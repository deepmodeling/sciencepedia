{"hands_on_practices": [{"introduction": "理论通过实践得以升华。虽然许多随机微分方程 (SDE) 没有解析解，迫使我们依赖于数值近似，但有些核心模型（如 Ornstein-Uhlenbeck 过程）确实存在精确解。这个练习提供了一个宝贵的机会，将最基础的数值方法——欧拉-丸山法 (Euler-Maruyama scheme)——与精确解进行直接比较。通过这样做，你将能够亲手量化数值方法的离散化误差，并学会在固定的计算预算下评估其效率，这是计算科学中的一项关键技能。[@problem_id:2415924]", "problem": "考虑一个在计算经济学和金融学中广泛使用的均值回归短利率模型，即 Ornstein–Uhlenbeck 过程（也称为 Vasicek 模型），它由以下随机微分方程 (SDE) 定义：\n$$\ndX_t = \\kappa(\\theta - X_t)\\,dt + \\sigma\\,dW_t,\\quad X_0 = x_0,\n$$\n其中，$X_t$ 是状态变量（例如，短期利率），$\\kappa > 0$ 是均值回归速度，$\\theta$ 是长期均值，$\\sigma > 0$ 是扩散系数，$W_t$ 是标准布朗运动。您的任务是，从第一性原理出发，通过数值方式证明，当在一个固定时间 $T$ 估计期望 $E[X_T]$ 时，如果在固定的计算预算下，效率由单位模拟成本下的均方误差衡量，那么在离散时间点上对精确解进行抽样比使用 Euler–Maruyama 格式更有效率。\n\n请基于以下基本原理进行推导：\n- 对于 $dX_t = a(X_t,t)\\,dt + b(X_t,t)\\,dW_t$，使用 Itô 随机微分方程和 Itô 积分的定义。\n- Ornstein–Uhlenbeck 过程是一个线性 SDE；线性一阶 SDE 可以使用积分因子求解。\n- Euler–Maruyama 格式是通过在步长为 $\\Delta$ 的小区间 $[t_n,t_{n+1}]$ 上使用 Itô 积分的定义对 SDE 进行时间离散化，并在左端点近似漂移项和扩散项得到的。\n\n任务：\n1) 使用积分因子，推导 Ornstein–Uhlenbeck 过程在大小为 $\\Delta$ 的单步上的精确离散时间转移，即，获得一个给定 $X_t$ 的 $X_{t+\\Delta}$ 的表达式，该表达式是 $X_t$ 的仿射函数加上一个高斯新息。将其均值和方差表示为 $\\kappa$、$\\theta$、$\\sigma$ 和 $\\Delta$ 的函数。\n\n2) 通过在 $[t_n,t_{n+1}]$ 上应用 Itô 积分的定义并在 $t_n$ 处近似漂移项和扩散项，推导此 SDE 在步长为 $\\Delta$ 的单步上的 Euler–Maruyama 更新规则。\n\n3) 对于固定的终端时间 $T$，定义一个计算预算，该预算由生成的高斯随机变量总数衡量：\n$$\nC = M \\times N,\n$$\n其中 $N = T/\\Delta$ 是每条路径的时间步数（假设 $T/\\Delta$ 是整数），$M$ 是模拟路径的数量。为了在固定成本下进行公平比较，您必须在改变 $\\Delta$ 的同时保持 $C$ 不变，并设置 $M = \\lfloor C/N \\rfloor$。\n\n4) 对于下面的每个参数配置，以及为该配置给定的每个时间步长 $\\Delta$，使用以下方法模拟 $M$ 条截至时间 $T$ 的独立路径：\n- 您在任务1中推导的精确离散时间转移（精确抽样）。\n- 您在任务2中推导的 Euler–Maruyama 格式（Euler 格式）。\n\n在每一步和每条路径上，对两种方法使用相同的高斯新息，以确保公平且经过方差缩减的比较。对于每个配置和 $\\Delta$，通过以下公式估计 $E[X_T]$ 的蒙特卡洛估计量的均方误差 (MSE)：\n$$\n\\widehat{\\mathrm{MSE}} = \\left(\\overline{X}_T - \\mu_T\\right)^2 + \\frac{S_T^2}{M},\n$$\n其中 $\\overline{X}_T$ 是 $M$ 条路径上 $X_T$ 的样本均值，$S_T^2$ 是 $M$ 条路径上 $X_T$ 的样本方差，$\\mu_T = E[X_T]$ 是由 SDE 在时间 $T$ 的精确解所隐含的精确均值。对于每个配置和 $\\Delta$，在相同的计算预算 $C$ 下，报告以下比率：\n$$\nR = \\frac{\\widehat{\\mathrm{MSE}}_{\\mathrm{Euler}}}{\\widehat{\\mathrm{MSE}}_{\\mathrm{Exact}}},\n$$\n\n5) 随机性控制与公平性：\n- 对于每个配置索引 $i \\in \\{0,1,2\\}$，使用一个基础整数种子 $s_i$。对于该配置中的第 $j$ 个步长，使用种子 $s_i + j$ 生成一个独立标准正态随机变量矩阵 $Z \\in \\mathbb{R}^{M \\times N}$。在该配置和步长内，对精确法和 Euler 法重复使用相同的 $Z$。\n\n实现和数值规格：\n- 此问题不涉及物理单位。\n- 此问题不涉及角度。\n- 不涉及百分比；任何分数量必须表示为小数或分数。\n- 最终程序必须是一个单一、完整、可运行的程序，它能执行所有计算并生成指定的输出，无需用户输入。\n\n参数配置测试套件：\n- 配置 $0$：$\\kappa = 1.2$, $\\theta = 0.04$, $\\sigma = 0.25$, $x_0 = 0.03$, $T = 1.0$，步长 $\\Delta \\in \\{0.2, 0.05, 0.01\\}$，基础种子 $s_0 = 13579$。\n- 配置 $1$：$\\kappa = 3.0$, $\\theta = 0.02$, $\\sigma = 0.15$, $x_0 = 0.08$, $T = 0.5$，步长 $\\Delta \\in \\{0.1, 0.05, 0.01\\}$，基础种子 $s_1 = 24680$。\n- 配置 $2$：$\\kappa = 0.3$, $\\theta = 0.01$, $\\sigma = 0.05$, $x_0 = 0.00$, $T = 2.0$，步长 $\\Delta \\in \\{0.4, 0.1, 0.02\\}$，基础种子 $s_2 = 11223$。\n\n在所有配置中，将计算预算设置为相同的值 $C = 2,000,000$，并设置 $M = \\lfloor C/N \\rfloor$。\n\n最终输出规格：\n- 您的程序应生成单行输出，其中包含 $9$ 个比率 $R$（每个配置三个，按上面列出的配置和步长顺序排列），形式为用方括号括起来的逗号分隔列表，每个比率四舍五入到 $6$ 位小数。例如，包含三个比率的输出看起来像 $[1.234000,1.050000,1.002345]$。", "solution": "所述问题是有效的。它在科学上基于随机微分方程和数值分析的既定理论，问题本身是适定的，提供了所有必要的参数和条件，并且是客观的，依赖于精确的数学定义。我将开始解答。\n\n该问题要求对模拟 Ornstein-Uhlenbeck 过程的两种方法进行数值比较，该过程由以下随机微分方程 (SDE) 描述：\n$$ dX_t = \\kappa(\\theta - X_t)\\,dt + \\sigma\\,dW_t, \\quad X_0 = x_0 $$\n其中 $\\kappa > 0$、$\\theta$ 和 $\\sigma > 0$ 是常数。这是一个线性 SDE。\n\n首先，我将推导所需的模拟格式。\n\n**1. 精确离散时间转移的推导**\n\n该 SDE 可以重写为：\n$$ dX_t + \\kappa X_t dt = \\kappa \\theta dt + \\sigma dW_t $$\n这是一个一阶线性微分方程。我们采用积分因子，$I(t) = e^{\\int \\kappa dt} = e^{\\kappa t}$。将 SDE 乘以 $e^{\\kappa t}$ 得到：\n$$ e^{\\kappa t} dX_t + \\kappa e^{\\kappa t} X_t dt = \\kappa \\theta e^{\\kappa t} dt + \\sigma e^{\\kappa t} dW_t $$\n根据 Itô 乘积法则，左侧是 $e^{\\kappa t} X_t$ 的微分：\n$$ d(e^{\\kappa t} X_t) = \\kappa \\theta e^{\\kappa t} dt + \\sigma e^{\\kappa t} dW_t $$\n我们对该表达式从任意时间 $t$ 积分到 $t+\\Delta$：\n$$ \\int_t^{t+\\Delta} d(e^{\\kappa s} X_s) = \\int_t^{t+\\Delta} \\kappa \\theta e^{\\kappa s} ds + \\int_t^{t+\\Delta} \\sigma e^{\\kappa s} dW_s $$\n$$ e^{\\kappa (t+\\Delta)} X_{t+\\Delta} - e^{\\kappa t} X_t = \\kappa \\theta \\left[ \\frac{e^{\\kappa s}}{\\kappa} \\right]_t^{t+\\Delta} + \\sigma \\int_t^{t+\\Delta} e^{\\kappa s} dW_s $$\n$$ e^{\\kappa (t+\\Delta)} X_{t+\\Delta} = e^{\\kappa t} X_t + \\theta (e^{\\kappa (t+\\Delta)} - e^{\\kappa t}) + \\sigma \\int_t^{t+\\Delta} e^{\\kappa s} dW_s $$\n乘以 $e^{-\\kappa(t+\\Delta)}$，我们分离出 $X_{t+\\Delta}$：\n$$ X_{t+\\Delta} = X_t e^{-\\kappa\\Delta} + \\theta (1 - e^{-\\kappa\\Delta}) + \\sigma \\int_t^{t+\\Delta} e^{-\\kappa(t+\\Delta - s)} dW_s $$\n随机积分项是一个确定性函数的 Itô 积分，其结果是一个均值为零的正态分布随机变量。其方差使用 Itô 等距性计算：\n$$ \\mathrm{Var}\\left( \\int_t^{t+\\Delta} e^{-\\kappa(t+\\Delta - s)} dW_s \\right) = \\int_t^{t+\\Delta} \\left( e^{-\\kappa(t+\\Delta - s)} \\right)^2 ds = \\int_t^{t+\\Delta} e^{-2\\kappa(t+\\Delta - s)} ds $$\n通过变量替换 $u = s - t$，上式变为：\n$$ \\int_0^{\\Delta} e^{-2\\kappa(\\Delta - u)} du = e^{-2\\kappa\\Delta} \\int_0^{\\Delta} e^{2\\kappa u} du = e^{-2\\kappa\\Delta} \\left[ \\frac{e^{2\\kappa u}}{2\\kappa} \\right]_0^{\\Delta} = \\frac{1 - e^{-2\\kappa\\Delta}}{2\\kappa} $$\n因此，该随机积分可以表示为 $\\sqrt{\\frac{1 - e^{-2\\kappa\\Delta}}{2\\kappa}} Z_{t+\\Delta}$，其中 $Z_{t+\\Delta} \\sim \\mathcal{N}(0, 1)$。\n精确的离散时间转移规则是：\n$$ X_{t+\\Delta} = X_t e^{-\\kappa\\Delta} + \\theta(1 - e^{-\\kappa\\Delta}) + \\sigma \\sqrt{\\frac{1 - e^{-2\\kappa\\Delta}}{2\\kappa}} Z_{t+\\Delta} $$\n给定 $X_t$, $X_{t+\\Delta}$ 的条件分布是高斯分布，其：\n- 均值：$E[X_{t+\\Delta} | X_t] = X_t e^{-\\kappa\\Delta} + \\theta(1 - e^{-\\kappa\\Delta})$\n- 方差：$\\mathrm{Var}(X_{t+\\Delta} | X_t) = \\sigma^2 \\frac{1 - e^{-2\\kappa\\Delta}}{2\\kappa}$\n\n**2. Euler–Maruyama 更新规则的推导**\n\nEuler–Maruyama 格式通过在一个小时间步长 $\\Delta = t_{n+1} - t_n$ 上离散化 SDE 的积分形式来对其进行近似。\n$$ X_{t_{n+1}} - X_{t_n} = \\int_{t_n}^{t_{n+1}} \\kappa(\\theta - X_s) ds + \\int_{t_n}^{t_{n+1}} \\sigma dW_s $$\n该格式将在区间 $[t_n, t_{n+1}]$ 上的被积函数近似为常数，其值在左端点 $t_n$ 处计算：\n$$ \\int_{t_n}^{t_{n+1}} \\kappa(\\theta - X_s) ds \\approx \\kappa(\\theta - X_{t_n})\\Delta $$\n$$ \\int_{t_n}^{t_{n+1}} \\sigma dW_s = \\sigma (W_{t_{n+1}} - W_{t_n}) = \\sigma \\sqrt{\\Delta} Z_{n+1} $$\n其中 $Z_{n+1} \\sim \\mathcal{N}(0, 1)$。结合这些可得到更新规则，其中我们记 $X_n \\equiv X_{t_n}$：\n$$ X_{n+1} = X_n + \\kappa(\\theta - X_n)\\Delta + \\sigma\\sqrt{\\Delta}Z_{n+1} $$\n这就是 Ornstein-Uhlenbeck 过程所需的 Euler-Maruyama 离散化。\n\n**3. 数值实验设计与评估**\n\n目标是比较精确抽样方法和 Euler-Maruyama 格式的效率。效率是通过在固定计算预算 $C$ 下，$E[X_T]$ 的蒙特卡洛估计量的均方误差 (MSE) 来衡量的。\n\n计算预算定义为 $C = M \\times N$，其中 $M$ 是模拟路径的数量，$N$ 是每条路径的时间步数。给定 $T$ 和步长 $\\Delta$，则 $N = T/\\Delta$。那么路径数就是 $M = \\lfloor C/N \\rfloor$。这种设置确保了对于任何 $\\Delta$ 的选择，生成的高斯随机变量总数近似恒定。\n\n对于每次模拟运行（由一组参数和步长 $\\Delta$ 定义），我们执行以下操作：\n1.  生成一个 $M \\times N$ 的独立标准正态离差矩阵 $Z$。该矩阵用于精确模拟和 Euler 模拟，以确保在方差缩减的情况下进行公平比较。\n2.  使用精确转移和 Euler-Maruyama 格式，从 $X_0 = x_0$ 开始，模拟 $M$ 条从 $t=0$ 到 $t=T$ 的路径。\n3.  对于每种方法，这将产生一个包含 $M$ 个在时间 $T$ 的最终状态的向量。我们计算样本均值 $\\overline{X}_T$ 和样本方差 $S_T^2$。\n4.  过程在时间 $T$ 的真实解析均值是通过求解期望的常微分方程 $d\\mu_t/dt = \\kappa(\\theta - \\mu_t)$ 得到的，其解为 $\\mu_T = E[X_T] = \\theta + (x_0 - \\theta)e^{-\\kappa T}$。\n5.  每种方法的估计 MSE 使用指定公式计算：\n    $$ \\widehat{\\mathrm{MSE}} = \\left(\\overline{X}_T - \\mu_T\\right)^2 + \\frac{S_T^2}{M} $$\n    $(\\overline{X}_T - \\mu_T)^2$ 项捕获了样本均值的平方误差，该误差由偏差和统计波动两部分组成。$S_T^2/M$ 项是样本均值方差的估计。\n6.  最后，我们计算估计 MSE 的比率：\n    $$ R = \\frac{\\widehat{\\mathrm{MSE}}_{\\mathrm{Euler}}}{\\widehat{\\mathrm{MSE}}_{\\mathrm{Exact}}} $$\n比率 $R > 1$ 表明 Euler-Maruyama 格式比精确抽样方法的效率更低（在相同的计算成本下产生更高的 MSE）。Euler 方法的弱收敛误差（偏差）随 $\\Delta$ 的增大而增长，预计是造成这种效率差异的主要驱动因素。根据定义，精确抽样器没有这种偏差。\n\n下面的程序为指定的测试配置实现了这整个过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by simulating the Ornstein-Uhlenbeck process using\n    the exact method and the Euler-Maruyama scheme, and computes the ratio\n    of their Mean-Squared Errors.\n    \"\"\"\n\n    # Test suite of parameter configurations.\n    test_cases = [\n        # Configuration 0\n        {\n            \"params\": {\"kappa\": 1.2, \"theta\": 0.04, \"sigma\": 0.25, \"x0\": 0.03, \"T\": 1.0},\n            \"deltas\": [0.2, 0.05, 0.01],\n            \"base_seed\": 13579\n        },\n        # Configuration 1\n        {\n            \"params\": {\"kappa\": 3.0, \"theta\": 0.02, \"sigma\": 0.15, \"x0\": 0.08, \"T\": 0.5},\n            \"deltas\": [0.1, 0.05, 0.01],\n            \"base_seed\": 24680\n        },\n        # Configuration 2\n        {\n            \"params\": {\"kappa\": 0.3, \"theta\": 0.01, \"sigma\": 0.05, \"x0\": 0.00, \"T\": 2.0},\n            \"deltas\": [0.4, 0.1, 0.02],\n            \"base_seed\": 11223\n        }\n    ]\n\n    C = 2_000_000\n    results = []\n\n    for case_config in test_cases:\n        p = case_config[\"params\"]\n        kappa, theta, sigma, x0, T = p[\"kappa\"], p[\"theta\"], p[\"sigma\"], p[\"x0\"], p[\"T\"]\n        \n        # Calculate the true mean at time T for MSE calculation.\n        mu_T = theta + (x0 - theta) * np.exp(-kappa * T)\n\n        for j, delta in enumerate(case_config[\"deltas\"]):\n            # Set up simulation parameters\n            N = int(T / delta)\n            M = C // N\n            seed = case_config[\"base_seed\"] + j\n            \n            # Generate all standard normal random variables at once\n            rng = np.random.default_rng(seed)\n            Z = rng.standard_normal(size=(M, N))\n\n            # --- Exact Simulation ---\n            X_exact = np.full(M, x0, dtype=np.float64)\n            # Precompute constants for the exact update rule\n            e_neg_kd = np.exp(-kappa * delta)\n            var_term = sigma * np.sqrt((1 - np.exp(-2 * kappa * delta)) / (2 * kappa))\n            for i in range(N):\n                X_exact = X_exact * e_neg_kd + theta * (1 - e_neg_kd) + var_term * Z[:, i]\n\n            # --- Euler-Maruyama Simulation ---\n            X_euler = np.full(M, x0, dtype=np.float64)\n            # Precompute constant for the Euler update rule\n            sqrt_delta = np.sqrt(delta)\n            for i in range(N):\n                X_euler = X_euler + kappa * (theta - X_euler) * delta + sigma * sqrt_delta * Z[:, i]\n            \n            # --- Calculate MSE for both methods ---\n            # MSE for Exact method\n            mean_exact = np.mean(X_exact)\n            var_exact = np.var(X_exact, ddof=1) if M > 1 else 0.0\n            mse_exact = (mean_exact - mu_T)**2 + var_exact / M\n\n            # MSE for Euler method\n            mean_euler = np.mean(X_euler)\n            var_euler = np.var(X_euler, ddof=1) if M > 1 else 0.0\n            mse_euler = (mean_euler - mu_T)**2 + var_euler / M\n\n            # Avoid division by zero, although MSE_exact should be positive\n            if mse_exact > 0:\n                ratio = mse_euler / mse_exact\n            else:\n                # If exact MSE is zero, Euler MSE must also be zero for a ratio of 1\n                ratio = 1.0 if mse_euler == 0 else np.inf\n            \n            results.append(f\"{ratio:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the simulation and print the results.\nsolve()\n```", "id": "2415924"}, {"introduction": "随机微分方程的符号形式有时并不足以完全定义其含义，随机积分的伊藤 (Itô) 和斯特拉托诺维奇 (Stratonovich) 解释是两种不同的选择，这代表了一项关键的建模决策。本练习使用几何布朗运动 (Geometric Brownian Motion) 模型，旨在揭示这个看似微妙的数学选择如何能够导致对系统稳定性的长期预测产生截然不同的结论。通过亲手实现一个与伊藤积分兼容的数值格式以及一个与斯特拉托诺维奇积分兼容的格式，你将能够数值验证随机微积分中的这一基本原理，并深刻理解其在模型行为预测中的重要性。[@problem_id:2415964]", "problem": "您的任务是设计、分析并数值验证一个案例，在该案例中，对于同一个符号化的随机微分方程，伊东（Itô）和斯特拉托诺维奇（Stratonovich）两种解释会得出相反的长期稳定性评估。请严格在计算经济学和金融学中使用的线性、乘性噪声模型的参数族内进行研究：\n$$\ndX_t = \\alpha\\,X_t\\,dt + \\beta\\,X_t\\,\\star\\,dW_t, \n$$\n其中 $X_t$ 是一个实值状态，$\\alpha \\in \\mathbb{R}$ 是一个常数漂移系数，$\\beta \\in \\mathbb{R}$ 是一个常数扩散负载，$W_t$ 是一个标准维纳过程，$\\star$ 表示伊东解释（写作 $dW_t$）或斯特拉托诺维奇解释（写作 $\\circ\\,dW_t$）。您的目标是从第一性原理出发，说明为何 $X_t$ 的长期几乎必然增长率依赖于所选的解释，构建一个参数集使得两种解释的稳定性结论相反，然后通过数值方法进行验证。\n\n您的推理起点：\n- 伊东积分和斯特拉托诺维奇积分的定义及其各自不同的链式法则。\n- 应用于足够平滑被积函数的、从伊东积分到斯特拉托诺维奇积分的转换法则。\n- $X_t$ 的几乎必然长期增长率的定义，即当极限存在时，$\\frac{1}{T}\\ln|X_T|$ 在 $T \\to \\infty$ 时的极限。\n\n您的任务：\n1) 基于上述基本原理，并且不使用任何现成的“捷径”公式，推导在伊东解释和斯特拉托诺维奇解释下，模型族 $dX_t = \\alpha X_t\\,dt + \\beta X_t\\,\\star\\,dW_t$ 的几乎必然长期增长率的显式表达式。\n2) 找出常数系数 $\\alpha$ 和 $\\beta$，使得伊东解释预测系统将长期稳定到 $0$（负增长率），而斯特拉托诺维奇解释预测系统将长期不稳定（正增长率）。请使用您推导出的表达式逻辑地解释您的选择。\n3) 实现两种数值格式来近似样本路径和经验增长率：\n   - 对于伊东解释：应用欧拉-丸山法（Euler–Maruyama method）于 $dX_t = \\alpha X_t\\,dt + \\beta X_t\\,dW_t$。\n   - 对于斯特拉托诺维奇解释：应用一个强1阶且与斯特拉托诺维奇解释一致的方法，例如随机霍恩法（stochastic Heun method），于 $dX_t = \\alpha X_t\\,dt + \\beta X_t \\circ dW_t$。\n   使用单条路径（非系综平均），设 $X_0 = 1$，时间范围为 $T$，均匀步长为 $\\Delta t$。使用固定的随机种子生成布朗增量 $\\Delta W_n \\sim \\mathcal{N}(0,\\Delta t)$ 以确保可复现性。对每种解释，计算经验长期增长率 $\\widehat{g} = \\frac{1}{T}\\ln|X_T|$。\n\n4) 使用三路决策和容差 $\\varepsilon$ 对每种解释进行数值上的稳定性分类：“稳定”如果 $\\widehat{g} < -\\varepsilon$，“不稳定”如果 $\\widehat{g} > \\varepsilon$，否则为“中性”。\n\n5) 将数值分类与您在任务 1 中推导的理论分类进行比较，并为每个测试案例返回一个表示是否一致的布尔值。\n\n所有测试案例使用的仿真参数：\n- 初始条件：$X_0 = 1$。\n- 时间范围：$T = 1000$。\n- 时间步长：$\\Delta t = 10^{-3}$。\n- 分类容差：$\\varepsilon = 2\\times 10^{-2}$。\n- 伪随机数生成器种子：$12345$。\n- 角度或物理单位在此不适用。\n\n测试套件（五个案例），每个案例以 $(\\alpha,\\beta)$ 形式给出：\n- 案例 A（目标：稳定性相反）：$(\\alpha,\\beta) = (0.05, 0.4)$。\n- 案例 B（两者皆稳定）：$(\\alpha,\\beta) = (-0.05, 0.2)$。\n- 案例 C（两者皆不稳定）：$(\\alpha,\\beta) = (0.2, 0.1)$。\n- 案例 D（伊东解释接近中性边界）：$(\\alpha,\\beta) = (0.08, 0.4)$。\n- 案例 E（斯特拉托诺维奇解释接近中性边界）：$(\\alpha,\\beta) = (0.0, 0.4)$。\n\n要求的输出：\n- 对于每个案例，使用指定的数值格式计算两种解释下的经验增长率，使用容差 $\\varepsilon$ 对其进行分类，与您在任务 1 中得出的理论分类进行比较，并输出一个表示是否一致的布尔值。\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，`[True,False,True,True,False]`）。\n\n关于数值实现的说明：\n- 对于应用于 $dX_t = \\alpha X_t\\,dt + \\beta X_t\\,dW_t$ 的伊东欧拉-丸山步，其在 $\\Delta t$ 上的单步更新（增量为 $\\Delta W$）是 $X_{n+1} = X_n + \\alpha X_n \\Delta t + \\beta X_n \\Delta W$。\n- 对于应用于 $dX_t = \\alpha X_t\\,dt + \\beta X_t \\circ dW_t$ 的、与斯特拉托诺维奇解释一致的随机霍恩步，首先构建预测子 $X_n^\\ast = X_n + \\alpha X_n \\Delta t + \\beta X_n \\Delta W$，然后 $X_{n+1} = X_n + \\tfrac{1}{2}\\left[\\alpha X_n + \\alpha X_n^\\ast\\right]\\Delta t + \\tfrac{1}{2}\\left[\\beta X_n + \\beta X_n^\\ast\\right]\\Delta W$。\n\n最终输出格式：\n- 一行，包含一个 Python 风格的布尔值列表，严格按照上述五个测试案例的顺序，无空格，例如 `[True,True,False,True,True]`。", "solution": "所提出的问题是随机微积分和随机微分方程（SDE）数值方法领域一个有效的练习。它具有科学依据、问题适定、客观且完整。所有参数和方法都已明确指定，从而可以得到唯一且可复现的解。我将继续进行推导和数值验证。\n\n问题的核心是几何布朗运动的随机微分方程：\n$$\ndX_t = \\alpha\\,X_t\\,dt + \\beta\\,X_t\\,\\star\\,dW_t\n$$\n其中 $\\alpha, \\beta \\in \\mathbb{R}$ 是常数系数，$W_t$ 是标准维纳过程，$\\star$ 表示随机积分可以按伊东（Itô）或斯特拉托诺维奇（Stratonovich）的意义来解释。我们的任务是证明解释的选择可能导致关于解 $X_t$ 长期稳定性的不同结论。稳定性通过几乎必然的长期增长率来评估，定义为 $g = \\lim_{T \\to \\infty} \\frac{1}{T}\\ln|X_T|$。\n\n我们将为每种解释推导增长率，找出使稳定性结论相反的参数，然后数值验证这些理论发现。\n\n**任务 1：长期增长率的推导**\n\n为了分析 $X_t$ 的长期行为，我们研究 $Y_t = \\ln(X_t)$ 的动态。由于初始条件为 $X_0 = 1 > 0$ 且 SDE 是线性的，解 $X_t$ 不会穿过零，因此我们可以使用 $\\ln(X_t)$ 而非 $\\ln|X_t|$。我们对函数 $f(x) = \\ln(x)$ 应用相应的链式法则，其中 $f'(x) = 1/x$ 且 $f''(x) = -1/x^2$。\n\n**伊东解释**\n\nSDE 为 $dX_t = \\alpha X_t dt + \\beta X_t dW_t$。我们对 $Y_t = f(X_t)$ 应用伊东引理：\n$$\ndY_t = f'(X_t)dX_t + \\frac{1}{2}f''(X_t)(dX_t)^2\n$$\n二次变分项 $(dX_t)^2$ 使用乘法规则 $dt \\cdot dt = 0$，$dt \\cdot dW_t = 0$ 和 $dW_t \\cdot dW_t = dt$ 来计算。\n$$\n(dX_t)^2 = (\\alpha X_t dt + \\beta X_t dW_t)^2 = \\beta^2 X_t^2 (dW_t)^2 = \\beta^2 X_t^2 dt\n$$\n将导数和 $(dX_t)^2$ 代入引理：\n$$\ndY_t = \\frac{1}{X_t}(\\alpha X_t dt + \\beta X_t dW_t) + \\frac{1}{2}\\left(-\\frac{1}{X_t^2}\\right)(\\beta^2 X_t^2 dt)\n$$\n$$\ndY_t = (\\alpha dt + \\beta dW_t) - \\frac{1}{2}\\beta^2 dt = \\left(\\alpha - \\frac{1}{2}\\beta^2\\right)dt + \\beta dW_t\n$$\n从 $t=0$ 积分到 $t=T$：\n$$\nY_T - Y_0 = \\int_{0}^{T}\\left(\\alpha - \\frac{1}{2}\\beta^2\\right)ds + \\int_{0}^{T}\\beta dW_s = \\left(\\alpha - \\frac{1}{2}\\beta^2\\right)T + \\beta W_T\n$$\n由于 $X_0 = 1$，我们有 $Y_0 = \\ln(1) = 0$。因此，$\\ln(X_T) = (\\alpha - \\frac{1}{2}\\beta^2)T + \\beta W_T$。几乎必然的长期增长率则为：\n$$\ng_{\\text{Itô}} = \\lim_{T \\to \\infty} \\frac{1}{T}\\ln(X_T) = \\lim_{T \\to \\infty} \\left[ \\left(\\alpha - \\frac{1}{2}\\beta^2\\right) + \\beta \\frac{W_T}{T} \\right]\n$$\n根据重对数律，$\\lim_{T \\to \\infty} W_T/T = 0$ 几乎必然成立。因此，增长率为：\n$$\ng_{\\text{Itô}} = \\alpha - \\frac{1}{2}\\beta^2\n$$\n\n**斯特拉托诺维奇解释**\n\nSDE 为 $dX_t = \\alpha X_t dt + \\beta X_t \\circ dW_t$。斯特拉托诺维奇链式法则与普通链式法则形式相同：$d(f(X_t)) = f'(X_t) \\circ dX_t$。\n将此应用于 $Y_t = \\ln(X_t)$：\n$$\ndY_t = \\frac{1}{X_t} \\circ dX_t = \\frac{1}{X_t} \\circ (\\alpha X_t dt + \\beta X_t \\circ dW_t) = \\alpha dt + \\beta \\circ dW_t\n$$\n从 $t=0$ 积分到 $t=T$：\n$$\nY_T - Y_0 = \\int_{0}^{T} \\alpha ds + \\int_{0}^{T} \\beta \\circ dW_s = \\alpha T + \\beta W_T\n$$\n由于 $Y_0=0$，我们有 $\\ln(X_T) = \\alpha T + \\beta W_T$。增长率为：\n$$\ng_{\\text{Stratonovich}} = \\lim_{T \\to \\infty} \\frac{1}{T}\\ln(X_T) = \\lim_{T \\to \\infty} \\left[ \\alpha + \\beta \\frac{W_T}{T} \\right] = \\alpha\n$$\n这个结果可以通过将斯特拉托诺维奇 SDE 转换为其等价的伊东 SDE 来确认。修正项为 $\\frac{1}{2} b(x) b'(x)$，其中 $b(x) = \\beta x$。这得到 $\\frac{1}{2}(\\beta x)(\\beta) = \\frac{1}{2}\\beta^2 x$。等价的伊东 SDE 是 $dX_t = (\\alpha X_t + \\frac{1}{2}\\beta^2 X_t) dt + \\beta X_t dW_t$。此伊东形式的漂移系数为 $\\alpha' = \\alpha + \\frac{1}{2}\\beta^2$。使用伊东增长率公式 $g = \\alpha' - \\frac{1}{2}\\beta^2$，我们得到 $g = (\\alpha + \\frac{1}{2}\\beta^2) - \\frac{1}{2}\\beta^2 = \\alpha$，结果一致。\n\n**任务 2：识别稳定性相反的参数**\n\n我们寻找参数 $(\\alpha, \\beta)$，使得 $g_{\\text{Itô}}$ 和 $g_{\\text{Stratonovich}}$ 的符号相反，从而导致不同的稳定性结论。我们要求伊东系统是稳定的（$g < 0$），而斯特拉托诺维奇系统是不稳定的（$g > 0$）。\n1.  斯特拉托诺维奇解释下的不稳定性：$g_{\\text{Stratonovich}} = \\alpha > 0$。\n2.  伊东解释下的稳定性：$g_{\\text{Itô}} = \\alpha - \\frac{1}{2}\\beta^2 < 0$。\n\n这两个条件结合起来，得到不等式 $0 < \\alpha < \\frac{1}{2}\\beta^2$。任何满足此条件的参数对 $(\\alpha, \\beta)$ 都会产生所期望的相反稳定性行为。问题提供了案例 A，其参数为 $(\\alpha, \\beta) = (0.05, 0.4)$。我们来检验这个选择。\n在此，$\\alpha = 0.05$ 且 $\\frac{1}{2}\\beta^2 = \\frac{1}{2}(0.4)^2 = 0.08$。条件 $0 < 0.05 < 0.08$ 得到满足。\n对于这些参数：\n- $g_{\\text{Itô}} = 0.05 - 0.08 = -0.03 < 0$，预测为稳定（$\\lim_{t\\to\\infty}X_t = 0$）。\n- $g_{\\text{Stratonovich}} = 0.05 > 0$，预测为不稳定（$\\lim_{t\\to\\infty}X_t = \\infty$）。\n参数的选择是合乎逻辑的，并正确地展示了这一现象。\n\n**任务 3、4 和 5：数值验证**\n\n我们现在将实现数值格式，并对给定的测试套件验证理论分类。实现将使用欧拉-丸山法处理伊东 SDE，使用随机霍恩法处理斯特拉托诺维奇 SDE。在每个测试案例中，将生成并使用同一条维纳过程路径进行两种模拟，以确保直接比较。数值增长率计算为 $\\widehat{g} = \\frac{1}{T}\\ln|X_T|$。通过将 $\\widehat{g}$ 与容差 $\\varepsilon = 2 \\times 10^{-2}$ 进行比较来对稳定性进行数值分类。数值分类将与使用相同容差 $\\varepsilon$ 的 $g_{\\text{Itô}}$ 和 $g_{\\text{Stratonovich}}$ 公式推导出的理论分类进行比较。每个案例的最终输出是一个布尔值，当且仅当两种数值分类都与它们各自的理论分类相匹配时，该值为 `True`。\n\n五个测试案例的理论分类如下，使用规则：“稳定”如果 $g < -0.02$，“不稳定”如果 $g > 0.02$，否则为“中性”。\n\n- **案例 A** $(\\alpha, \\beta) = (0.05, 0.4)$:\n  $g_{\\text{Itô}} = -0.03$ (稳定), $g_{\\text{Stratonovich}} = 0.05$ (不稳定)。\n- **案例 B** $(\\alpha, \\beta) = (-0.05, 0.2)$:\n  $g_{\\text{Itô}} = -0.05 - 0.5(0.2)^2 = -0.07$ (稳定), $g_{\\text{Stratonovich}} = -0.05$ (稳定)。\n- **案例 C** $(\\alpha, \\beta) = (0.2, 0.1)$:\n  $g_{\\text{Itô}} = 0.2 - 0.5(0.1)^2 = 0.195$ (不稳定), $g_{\\text{Stratonovich}} = 0.2$ (不稳定)。\n- **案例 D** $(\\alpha, \\beta) = (0.08, 0.4)$:\n  $g_{\\text{Itô}} = 0.08 - 0.5(0.4)^2 = 0.0$ (中性), $g_{\\text{Stratonovich}} = 0.08$ (不稳定)。\n- **案例 E** $(\\alpha, \\beta) = (0.0, 0.4)$:\n  $g_{\\text{Itô}} = 0.0 - 0.5(0.4)^2 = -0.08$ (稳定), $g_{\\text{Stratonovich}} = 0.0$ (中性)。\n\n最终答案中的代码将执行模拟和比较。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes the stability of a linear SDE under Itô and Stratonovich\n    interpretations, comparing theoretical predictions with numerical simulations.\n    \"\"\"\n\n    # --- Simulation Parameters ---\n    X0 = 1.0\n    T = 1000.0\n    dt = 1e-3\n    epsilon = 2e-2\n    seed = 12345\n\n    # --- Test Cases ---\n    test_cases = [\n        (0.05, 0.4),   # Case A\n        (-0.05, 0.2),  # Case B\n        (0.2, 0.1),    # Case C\n        (0.08, 0.4),   # Case D\n        (0.0, 0.4),    # Case E\n    ]\n\n    # --- Generate Wiener Path ---\n    # The same path is used for all test cases and both interpretations\n    # to ensure consistency and reproducibility.\n    num_steps = int(T / dt)\n    rng = np.random.default_rng(seed)\n    dW = rng.normal(0.0, np.sqrt(dt), num_steps)\n\n    def classify_stability(g, eps):\n        \"\"\"Classifies stability based on growth rate g and tolerance eps.\"\"\"\n        if g  -eps:\n            return \"stable\"\n        if g > eps:\n            return \"unstable\"\n        return \"neutral\"\n\n    results = []\n    for alpha, beta in test_cases:\n        # --- 1. Theoretical Classification ---\n        g_ito_theo = alpha - 0.5 * beta**2\n        g_strato_theo = alpha\n\n        theo_class_ito = classify_stability(g_ito_theo, epsilon)\n        theo_class_strato = classify_stability(g_strato_theo, epsilon)\n\n        # --- 2. Numerical Simulation: Itô (Euler-Maruyama) ---\n        x_ito = X0\n        for i in range(num_steps):\n            x_ito = x_ito * (1.0 + alpha * dt + beta * dW[i])\n\n        # Compute and classify empirical growth rate\n        g_ito_num = np.log(np.abs(x_ito)) / T if x_ito != 0 else -np.inf\n        num_class_ito = classify_stability(g_ito_num, epsilon)\n\n        # --- 3. Numerical Simulation: Stratonovich (Heun) ---\n        x_strato = X0\n        for i in range(num_steps):\n            # Predictor step\n            x_pred = x_strato * (1.0 + alpha * dt + beta * dW[i])\n            # Corrector step\n            x_strato = x_strato \\\n                + 0.5 * (alpha * x_strato + alpha * x_pred) * dt \\\n                + 0.5 * (beta * x_strato + beta * x_pred) * dW[i]\n\n        # Compute and classify empirical growth rate\n        g_strato_num = np.log(np.abs(x_strato)) / T if x_strato != 0 else -np.inf\n        num_class_strato = classify_stability(g_strato_num, epsilon)\n\n        # --- 4. Comparison ---\n        # Agreement is True if both numerical classifications match their\n        # theoretical counterparts.\n        agreement = (theo_class_ito == num_class_ito) and \\\n                    (theo_class_strato == num_class_strato)\n        results.append(agreement)\n\n    # --- Final Output ---\n    # Must be a single line with a list of booleans, as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2415964"}, {"introduction": "在数值模拟中，全程使用一个固定的微小时间步长虽然安全，但往往效率低下。一种更高级、更高效的策略是让步长根据解的局部行为动态调整。本练习将指导你设计一个自适应步长控制器，其核心思想是利用一个低阶方法（欧拉-丸山法）和一个高阶方法（米尔斯坦法）在单步计算结果上的差异来估计局部误差。根据这个误差，算法可以决定是接受还是拒绝当前步长的计算结果，并动态地调整下一步的步长。掌握这项技术是构建稳健、高效的现代数值求解器的关键一步。[@problem_id:3002532]", "problem": "考虑一个形式为 $\\,\\mathrm{d}X_t = a(X_t)\\,\\mathrm{d}t + b(X_t)\\,\\mathrm{d}W_t\\,$ 的标量Itō随机微分方程 (SDE)，其中 $\\,W_t\\,$ 是标准布朗运动。从Itō SDE的定义、Itō–Taylor展开以及时间步长 $\\,h0\\,$ 上布朗运动增量 $\\,\\Delta W \\sim \\mathcal{N}(0,h)\\,$ 的性质出发，设计一个嵌入式误差估计器的方案，该估计器通过比较单步Euler–Maruyama (EM) 更新和Milstein更新来产生接受决策和建议的下一时间步长。\n\n您的程序必须为单个试验步实现以下概念性流程：\n- 给定函数 $\\,a(x)\\,$、$\\,b(x)\\,$ 以及 $\\,b(x)\\,$ 对 $\\,x\\,$ 的导数 $\\,b'(x)\\,$，根据每种方法对应的Itō–Taylor展开原理，构建单步Euler–Maruyama更新和单步Milstein更新。\n- 将误差估计器定义为在相同状态 $\\,x\\,$ 和相同增量 $\\,\\Delta W\\,$ 下两个单步更新之间的绝对差。\n- 使用混合的绝对-相对容差缩放误差，形成无量纲误差度量 $\\,\\varepsilon\\,$：\n$$\n\\varepsilon \\;=\\; \\frac{\\lvert y_{\\text{Milstein}} - y_{\\text{EM}} \\rvert}{a_{\\text{tol}} + r_{\\text{tol}}\\,\\lvert y_{\\text{Milstein}} \\rvert},\n$$\n其中 $\\,a_{\\text{tol}}0\\,$ 是绝对容差，$\\,r_{\\text{tol}}\\ge 0\\,$ 是相对容差。\n- 接受准则：如果 $\\,\\varepsilon \\le 1\\,$，则宣布该试验步被接受，否则被拒绝。\n- 步长自适应：设 $\\,p\\,$ 为用于推进解的已接受方法的强收敛阶（对于标量交换噪声Milstein方法，取 $p=1$）。提出一个新的步长\n$$\nh_{\\text{new}} \\;=\\; h \\,\\cdot\\, \\operatorname{clip}\\!\\left(\\gamma \\,\\varepsilon^{-1/p},\\, \\mathrm{fac}_{\\min},\\, \\mathrm{fac}_{\\max}\\right),\n$$\n其中 $\\,\\gamma\\in(0,1)\\,$ 是一个安全因子，$\\,\\operatorname{clip}(u, L, U) = \\min\\{\\max\\{u,L\\},U\\}\\,$ 将乘法变化限制在 $\\,\\mathrm{fac}_{\\min}\\,$ 和 $\\,\\mathrm{fac}_{\\max}\\,$ 之间。\n\n为具有常数 $\\,\\alpha\\,$ 和 $\\,\\beta\\,$ 的特定族 $\\,a(x) = \\alpha x\\,$ 和 $\\,b(x) = \\beta x\\,$ 实现上述过程。使用以下测试套件，其中每个案例指定了 $\\,(\\alpha, \\beta, x, h, a_{\\text{tol}}, r_{\\text{tol}}, \\gamma, \\mathrm{fac}_{\\min}, \\mathrm{fac}_{\\max}, z)\\,$，并且布朗增量由 $\\,\\Delta W = \\sqrt{h}\\,z\\,$ 确定性地规定：\n\n- 案例1（理想情况，中等噪声）：$\\,(0.5,\\,0.2,\\,1.0,\\,0.05,\\,10^{-3},\\,10^{-2},\\,0.9,\\,0.2,\\,5.0,\\,0.1)\\,$。\n- 案例2（边缘情况，大扩散和大增量）：$\\,(0.1,\\,2.5,\\,1.0,\\,0.05,\\,10^{-3},\\,10^{-2},\\,0.9,\\,0.2,\\,5.0,\\,3.0)\\,$。\n- 案例3（边界情况，极小状态和步长）：$\\,(0.1,\\,0.8,\\,10^{-6},\\,10^{-4},\\,10^{-8},\\,10^{-1},\\,0.9,\\,0.2,\\,5.0,\\,0.3)\\,$。\n- 案例4（压力情况，大步长和负增量）：$\\,(0.1,\\,1.0,\\,1.0,\\,0.5,\\,10^{-4},\\,10^{-3},\\,0.8,\\,0.2,\\,5.0,\\,-1.0)\\,$。\n\n您的程序应为每个案例计算：\n- 接受决策，如果接受则编码为 $\\,1\\,$，拒绝则为 $\\,0\\,$，\n- 建议的下一时间步长 $\\,h_{\\text{new}}\\,$，\n- 无量纲误差度量 $\\,\\varepsilon\\,$。\n\n最终输出格式：您的程序应生成单行输出，包含一个由逗号分隔的四个列表组成的列表，每个列表对应一个测试案例，每个内部列表的格式为 $[ \\text{accept}, h_{\\text{new}}, \\varepsilon ]$。例如，形如 $[[1,0.0623,0.54],[0,0.01,2.3],[\\dots],[\\dots]]$ 的一行。", "solution": "所提出的问题是有效的。它在科学上基于随机微分方程（SDE）数值方法的既定理论，特别是Itō-Taylor展开以及由此产生的Euler-Maruyama和Milstein格式。该问题是适定的，提供了所有必要的参数、函数以及维纳增量的确定性设置，从而确保每个测试用例都有唯一且可验证的解。其语言客观而精确。\n\n我们的任务是为以下形式的标量Itō SDE设计并实现一种自适应步长控制机制：\n$$\n\\mathrm{d}X_t = a(X_t)\\,\\mathrm{d}t + b(X_t)\\,\\mathrm{d}W_t\n$$\n其中 $W_t$ 是一个标准维纳过程（布朗运动）。自适应策略的核心在于比较一个低阶数值近似与一个更高阶的数值近似，以估计单步的局部误差。\n\nEuler-Maruyama和Milstein方法的基础都是过程 $X_t$ 在时间 $t_n$ 附近的Itō-Taylor展开，它给出了在 $t_{n+1} = t_n + h$ 处的值：\n$$\nX_{n+1} = X_n + a(X_n)h + b(X_n)\\Delta W_n + \\frac{1}{2} b(X_n)b'(X_n) \\left( (\\Delta W_n)^2 - h \\right) + \\mathcal{O}(h^{3/2})\n$$\n这里，$X_n \\equiv X_{t_n}$，$\\Delta W_n = W_{t_{n+1}} - W_{t_n}$ 是在区间 $[t_n, t_{n+1}]$ 上的维纳增量，它是一个服从 $\\mathcal{N}(0, h)$ 分布的随机变量。符号 $b'(x)$ 表示 $b(x)$ 关于其参数 $x$ 的导数。\n\n从这个展开式中，我们推导出两种具有不同强收敛阶的数值格式：\n\n1.  **Euler-Maruyama (EM) 格式**：该方法通过在随机积分项后截断Itō-Taylor展开得到。它的强收敛阶为 $0.5$。从状态 $x$ 出发，步长为 $h$，增量为 $\\Delta W$ 的单步更新（我们记为 $y_{\\text{EM}}$）是：\n    $$\n    y_{\\text{EM}}(x, h, \\Delta W) = x + a(x)h + b(x)\\Delta W\n    $$\n\n2.  **Milstein 格式**：通过在展开式中包含下一项，我们得到Milstein方法。对于标量SDE（其噪声总是可交换的），该方法的强收敛阶为 $1.0$。单步更新 $y_{\\text{Milstein}}$ 是：\n    $$\n    y_{\\text{Milstein}}(x, h, \\Delta W) = x + a(x)h + b(x)\\Delta W + \\frac{1}{2}b(x)b'(x)\\left( (\\Delta W)^2 - h \\right)\n    $$\n    我们可以将其简明地表示为 $y_{\\text{Milstein}} = y_{\\text{EM}} + \\frac{1}{2}b(x)b'(x)\\left( (\\Delta W)^2 - h \\right)$。\n\n该问题指定了用于几何布朗运动的SDE：\n$$\n\\mathrm{d}X_t = \\alpha X_t\\,\\mathrm{d}t + \\beta X_t\\,\\mathrm{d}W_t\n$$\n由此，我们确定漂移系数、扩散系数以及扩散系数的导数：\n$$\na(x) = \\alpha x, \\quad b(x) = \\beta x, \\quad b'(x) = \\beta\n$$\n\n自适应控制机制采用一种嵌入式方法，其中高阶（Milstein）更新和低阶（EM）更新之间的差值作为低阶方法局部误差的估计。这个误差估计器 $E$ 是：\n$$\nE = \\lvert y_{\\text{Milstein}} - y_{\\text{EM}} \\rvert = \\left\\lvert \\frac{1}{2}b(x)b'(x)\\left( (\\Delta W)^2 - h \\right) \\right\\rvert\n$$\n对于特定的SDE，这变成：\n$$\nE = \\left\\lvert \\frac{1}{2}(\\beta x)(\\beta)\\left( (\\Delta W)^2 - h \\right) \\right\\rvert = \\left\\lvert \\frac{1}{2}\\beta^2 x \\left( (\\Delta W)^2 - h \\right) \\right\\rvert\n$$\n该问题确定性地规定维纳增量为 $\\Delta W = \\sqrt{h}\\,z$，其中 $z$ 是一个给定值。将此代入误差表达式可得到一个更直接的公式：\n$$\nE = \\left\\lvert \\frac{1}{2}\\beta^2 x \\left( (\\sqrt{h}z)^2 - h \\right) \\right\\rvert = \\left\\lvert \\frac{1}{2}\\beta^2 x \\left( h z^2 - h \\right) \\right\\rvert = \\left\\lvert \\frac{1}{2}\\beta^2 x h (z^2-1) \\right\\rvert\n$$\n为了做出接受决策，这个绝对误差 $E$ 通过一个混合的绝对-相对容差准则进行缩放，形成一个无量纲的误差度量 $\\varepsilon$：\n$$\n\\varepsilon = \\frac{E}{a_{\\text{tol}} + r_{\\text{tol}}\\,\\lvert y_{\\text{Milstein}} \\rvert}\n$$\n其中 $a_{\\text{tol}}$ 是绝对容差，$r_{\\text{tol}}$ 是相对容差。解使用更精确的Milstein更新 $y_{\\text{Milstein}}$ 来推进。如果 $\\varepsilon \\le 1$，则试验步被接受，否则被拒绝。\n\n最后，根据计算出的误差 $\\varepsilon$ 提出一个新的步长 $h_{\\text{new}}$。该公式源于这样一个原理：对于一个 $p$ 阶方法，误差的行为如同 $E \\propto h^p$。为达到目标误差，步长应按与 $\\varepsilon^{-1/p}$ 成比例的因子进行调整。指定的公式是：\n$$\nh_{\\text{new}} = h \\cdot \\operatorname{clip}\\!\\left(\\gamma \\,\\varepsilon^{-1/p},\\, \\mathrm{fac}_{\\min},\\, \\mathrm{fac}_{\\max}\\right)\n$$\n这里，$p$ 是已接受方法（Milstein）的强收敛阶，所以 $p=1$。安全因子 $\\gamma$ 可以防止过于乐观的步长增加，而 $\\mathrm{fac}_{\\min}, \\mathrm{fac}_{\\max}$ 则限制变化以保持稳定性。$\\operatorname{clip}(u, L, U)$ 函数将值 $u$ 约束在区间 $[L, U]$ 内。在 $\\varepsilon=0$ 的特殊情况下，项 $\\varepsilon^{-1/p}$ 在形式上是无穷大的；在这种情况下，标准的解释是将步长增加到允许的最大因子 $\\mathrm{fac}_{\\max}$。\n\n单个试验步的算法如下：\n1.  给定参数 $(\\alpha, \\beta, x, h, a_{\\text{tol}}, r_{\\text{tol}}, \\gamma, \\mathrm{fac}_{\\min}, \\mathrm{fac}_{\\max}, z)$。\n2.  计算维纳增量：$\\Delta W = \\sqrt{h}\\,z$。\n3.  直接计算误差估计：$E = |\\frac{1}{2}\\beta^2 x h (z^2-1)|$。\n4.  计算高阶更新：$y_{\\text{Milstein}} = x + \\alpha x h + \\beta x \\Delta W + \\frac{1}{2}\\beta^2 x h (z^2-1)$。\n5.  计算无量纲误差：$\\varepsilon = E / (a_{\\text{tol}} + r_{\\text{tol}}\\,|y_{\\text{Milstein}}|)$。\n6.  确定接受与否：如果 $\\varepsilon \\le 1$，`accept` 为 $1$；否则为 $0$。\n7.  使用 $p=1$ 的自适应公式计算新步长 $h_{\\text{new}}$。如果 $\\varepsilon=0$，乘法因子为 $\\mathrm{fac}_{\\max}$。\n\n此过程被系统地应用于所提供的每个测试案例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements an adaptive step-size controller for a scalar SDE\n    based on an embedded Euler-Maruyama and Milstein method pair.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is (alpha, beta, x, h, a_tol, r_tol, gamma, fac_min, fac_max, z)\n    test_cases = [\n        (0.5, 0.2, 1.0, 0.05, 1e-3, 1e-2, 0.9, 0.2, 5.0, 0.1),\n        (0.1, 2.5, 1.0, 0.05, 1e-3, 1e-2, 0.9, 0.2, 5.0, 3.0),\n        (0.1, 0.8, 1e-6, 1e-4, 1e-8, 1e-1, 0.9, 0.2, 5.0, 0.3),\n        (0.1, 1.0, 1.0, 0.5, 1e-4, 1e-3, 0.8, 0.2, 5.0, -1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, beta, x, h, a_tol, r_tol, gamma, fac_min, fac_max, z = case\n\n        # The strong convergence order of the Milstein method (scalar commutative case)\n        p = 1.0\n\n        # Calculate the deterministic Wiener increment\n        delta_W = np.sqrt(h) * z\n\n        # The term that differentiates Milstein from Euler-Maruyama\n        # This is also the local error estimate before taking the absolute value.\n        # E = |milstein_term|\n        milstein_correction = 0.5 * beta**2 * x * (delta_W**2 - h)\n        # Note: delta_W**2 - h = (sqrt(h)*z)**2 - h = h*z**2 - h = h * (z**2 - 1)\n        # So, milstein_correction = 0.5 * beta**2 * x * h * (z**2 - 1)\n        \n        # Absolute error estimator\n        error_est = np.abs(milstein_correction)\n\n        # Calculate the one-step Euler-Maruyama update\n        y_em = x + alpha * x * h + beta * x * delta_W\n        \n        # Calculate the one-step Milstein update by adding the correction term\n        y_milstein = y_em + milstein_correction\n        \n        # Calculate the dimensionless error metric epsilon\n        # Handle the case where the denominator could be zero, though unlikely with a_tol > 0\n        tolerance_scale = a_tol + r_tol * np.abs(y_milstein)\n        if tolerance_scale == 0:\n            # If both error and tolerance are zero, error is controlled.\n            # If error is non-zero and tolerance is zero, error is infinite.\n            epsilon = 0.0 if error_est == 0.0 else np.inf\n        else:\n            epsilon = error_est / tolerance_scale\n\n        # Acceptance criterion\n        accept = 1 if epsilon = 1.0 else 0\n\n        # Step-size adaptation\n        if epsilon == 0.0:\n            # If error is zero, increase step size by the maximum factor\n            scaling_factor = fac_max\n        else:\n            # Standard PI controller-based step size adaptation\n            raw_scaling_factor = gamma * (epsilon**(-1.0 / p))\n            scaling_factor = np.clip(raw_scaling_factor, fac_min, fac_max)\n        \n        h_new = h * scaling_factor\n\n        results.append([accept, h_new, epsilon])\n\n    # Final print statement in the exact required format.\n    # Convert each inner list to its string representation and join with commas.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3002532"}]}