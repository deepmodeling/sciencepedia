{"hands_on_practices": [{"introduction": "我们使用稀疏矩阵的主要动机是其高效率，但这究竟意味着什么？不同的稀疏格式选择又会带来多大差异？本练习将让您在一个真实的投资组合优化场景中，直接量化比较两种常用格式——键字典（DOK）和压缩稀疏行（CSR）的内存占用。通过亲手计算，您将深刻理解为何在计算金融领域，数据结构的选择是一个至关重要的设计决策。[@problem_id:2432973]", "problem": "您正在为计算经济学与金融学中的一个只做多投资组合选择问题建模，该问题包含行业限制。现有 $N$ 种资产和 $S$ 个行业。每种资产恰好属于一个行业。设 $x \\in \\mathbb{R}^{N}$ 表示资产决策变量，$y \\in \\mathbb{R}^{S}$ 表示二元行业使用指标。投资组合持有的资产不超过 $k$ 个行业的约束由一个具有以下结构的稀疏线性系统表示：\n1. 对于每个行业 $s \\in \\{1,\\dots,S\\}$，约束为\n$$\\sum_{i \\in \\text{sector}(s)} 1 \\cdot x_i - M \\cdot y_s \\le 0,$$\n其中 $M$ 是任意正常数，每种资产 $i$ 恰好以系数 1 出现在一个此类求和中。\n2. 对活跃行业数量的限制：\n$$\\sum_{s=1}^{S} 1 \\cdot y_s \\le k.$$\n将这些约束排列成一个单一的稀疏约束矩阵 $A \\in \\mathbb{R}^{(S+1)\\times (N+S)}$，该矩阵作用于串联向量 $(x,y) \\in \\mathbb{R}^{N+S}$，其右端向量为 $b \\in \\mathbb{R}^{S+1}$，其中 $k$ 仅出现在其最后一个分量中。在这些条件下，$A$ 中的非零元数量为\n$$\\mathrm{nnz} = N + 2S,$$\n因为在 $S$ 个行业行中，$x$ 有 $N$ 个单位系数，在相同的行中，$y$ 变量有 $S$ 个系数，在最后一行中，$y$ 变量有 $S$ 个单位系数。\n\n您将比较矩阵 $A$ 及其右端向量 $b$ 的两种稀疏表示的内存使用量（以字节为单位）：\n- 键字典 (Dictionary of Keys, DOK)：将每个非零元存储为三元组 $(\\text{row}, \\text{col}, \\text{value})$，索引使用 64 位有符号整数，值使用 64 位浮点数。右端向量 $b$ 也存储为 64 位浮点数项。假设除了这些基本字段外没有额外的开销。\n- 压缩稀疏行 (Compressed Sparse Row, CSR)：为 $A$ 存储三个数组：`data`（长度为 $\\mathrm{nnz}$ 的 64 位浮点数）、`column indices`（长度为 $\\mathrm{nnz}$ 的 64 位有符号整数）和 `row pointer`（长度为 $(S+1)+1$ 的 64 位有符号整数）。右端向量 $b$ 也存储为 64 位浮点数项。\n\n所有索引字段每项使用 8 字节，所有浮点字段每项使用 8 字节。$M$ 的大小不影响内存使用量。$k$ 的值仅影响 $b$ 中一个条目的数值，因此不改变存储条目的数量。\n\n任务：对于每个测试用例 $(N,S,k)$，计算键字典 (DOK) 和压缩稀疏行 (CSR) 表示在上述模型下所需的确切总内存（以字节为单位），包括 $b$ 的存储。然后，对每个测试用例，计算比率\n$$r = \\frac{\\text{bytes}_{\\mathrm{DOK}}}{\\text{bytes}_{\\mathrm{CSR}}},$$\n该比率是无量纲的。报告每个 $r$ 值，四舍五入到三位小数。\n\n测试集（每个元组为 $(N,S,k)$，其中 $N \\in \\mathbb{Z}_{\\ge 0}$，$S \\in \\mathbb{Z}_{\\ge 1}$，$k \\in \\{0,1,\\dots,S\\}$）：\n- $(500, 10, 3)$\n- $(10000, 100, 5)$\n- $(0, 8, 0)$\n- $(1000, 1, 1)$\n- $(50, 200, 5)$\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 `\"[r_1,r_2,r_3,r_4,r_5]\"`，其中每个 $r_j$ 按规定四舍五入到三位小数。", "solution": "所提出的问题是适定的、有科学依据的，并包含了获得唯一解所需的所有信息。我们将对指定稀疏矩阵表示的内存需求进行系统性推导。\n\n该问题要求比较线性约束系统 $Ax \\le b$ 的键字典 (DOK) 和压缩稀疏行 (CSR) 格式的内存使用量。该系统由 $N$ 个资产和 $S$ 个行业定义。约束矩阵 $A$ 的维度为 $(S+1) \\times (N+S)$，右端向量 $b$ 的维度为 $S+1$。$A$ 中的非零元数量由 $\\mathrm{nnz} = N + 2S$ 给出。所有索引字段存储为 64 位（8 字节）整数，所有值字段存储为 64 位（8 字节）浮点数。\n\n首先，我们计算键字典 (DOK) 表示所需的总内存，记为 $\\text{bytes}_{\\mathrm{DOK}}$。在 DOK 格式中，矩阵 $A$ 的 $\\mathrm{nnz}$ 个非零元中的每一个都存储为一个元组 $(\\text{row}, \\text{col}, \\text{value})$。元组中每个分量的内存为：行索引 8 字节，列索引 8 字节，值 8 字节。因此，存储一个非零元的内存为 $8 + 8 + 8 = 24$ 字节。矩阵 $A$ 的总内存是非零元数量与每个条目内存的乘积：\n$$ \\text{Mem}_{\\mathrm{DOK}}(A) = \\mathrm{nnz} \\times 24 = (N + 2S) \\times 24 = 24N + 48S $$\n右端向量 $b$ 有 $S+1$ 个条目，每个条目是 8 字节的浮点数。其内存占用为：\n$$ \\text{Mem}(b) = (S+1) \\times 8 = 8S + 8 $$\nDOK 表示的总内存是矩阵 $A$ 和向量 $b$ 的内存之和：\n$$ \\text{bytes}_{\\mathrm{DOK}} = \\text{Mem}_{\\mathrm{DOK}}(A) + \\text{Mem}(b) = (24N + 48S) + (8S + 8) = 24N + 56S + 8 $$\n\n接下来，我们计算压缩稀疏行 (CSR) 表示的总内存，记为 $\\text{bytes}_{\\mathrm{CSR}}$。矩阵 $A$ 的 CSR 格式由三个数组组成：一个用于值的 `data` 数组，一个 `column indices` 数组，以及一个 `row pointer` 数组。`data` 数组存储 $\\mathrm{nnz}$ 个非零值，`column indices` 数组存储这些值中每个值的列索引。这两个数组的长度都是 $\\mathrm{nnz}$，并使用 8 字节的元素（分别为 64 位浮点数和 64 位整数）。`row pointer` 数组指定了每行在其他两个数组中的起始位置；其长度是行数加一，即 $(S+1)+1 = S+2$，其元素是 8 字节的整数。矩阵 $A$ 在 CSR 格式下的内存为：\n$$ \\text{Mem}_{\\mathrm{CSR}}(A) = \\underbrace{(N+2S) \\times 8}_{\\text{data}} + \\underbrace{(N+2S) \\times 8}_{\\text{indices}} + \\underbrace{(S+2) \\times 8}_{\\text{row pointer}} \\\\ \\text{Mem}_{\\mathrm{CSR}}(A) = 16(N+2S) + 8(S+2) = 16N + 32S + 8S + 16 = 16N + 40S + 16 $$\n向量 $b$ 的存储方式与前一种情况相同，需要 $\\text{Mem}(b) = 8S + 8$ 字节。CSR 表示的总内存是矩阵 $A$ 和向量 $b$ 的内存之和：\n$$ \\text{bytes}_{\\mathrm{CSR}} = \\text{Mem}_{\\mathrm{CSR}}(A) + \\text{Mem}(b) = (16N + 40S + 16) + (8S + 8) = 16N + 48S + 24 $$\n\n最后，我们计算比率 $r = \\frac{\\text{bytes}_{\\mathrm{DOK}}}{\\text{bytes}_{\\mathrm{CSR}}}$。代入推导出的表达式：\n$$ r = \\frac{24N + 56S + 8}{16N + 48S + 24} $$\n这个表达式可以通过分子分母同除以它们的最大公约数 8 来简化：\n$$ r = \\frac{3N + 7S + 1}{2N + 6S + 3} $$\n这个最终公式用于计算每个测试用例所需的比率。正如问题中所述，$k$ 和 $M$ 参数确实对内存计算没有影响。比率 $r$ 仅取决于资产数量 $N$ 和行业数量 $S$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the ratio of memory usage between DOK and CSR sparse representations\n    for a series of test cases based on a portfolio optimization problem.\n    \"\"\"\n    test_cases = [\n        # Each tuple is (N, S, k)\n        (500, 10, 3),\n        (10000, 100, 5),\n        (0, 8, 0),\n        (1000, 1, 1),\n        (50, 200, 5)\n    ]\n\n    results = []\n    for case in test_cases:\n        N, S, k = case  # The parameter k is not used in the memory calculation.\n\n        # Derived formula for the ratio r = bytes_DOK / bytes_CSR\n        # r = (24*N + 56*S + 8) / (16*N + 48*S + 24)\n        # Simplified formula by dividing numerator and denominator by 8:\n        # r = (3*N + 7*S + 1) / (2*N + 6*S + 3)\n        numerator = 3 * N + 7 * S + 1\n        denominator = 2 * N + 6 * S + 3\n        \n        # Based on problem constraints (N>=0, S>=1), the denominator is always positive.\n        # min denominator: 2*0 + 6*1 + 3 = 9. So no division by zero check is needed.\n        ratio = numerator / denominator\n        \n        # Format the result to three decimal places.\n        results.append(f\"{ratio:.3f}\")\n\n    # Print the final output in the specified format: \"[r1,r2,r3,r4,r5]\"\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2432973"}, {"introduction": "将数据以稀疏格式存储后，我们需要高效的算法来处理它，同时保持其稀疏性。本练习将探讨哈达玛积（Hadamard product），也即逐元素乘积，这是一种融合不同数据源（例如市场相关性与新闻情绪）信息的基本操作。解决此问题的关键在于，算法的关注点应仅限于两个矩阵中非零元素的交集，从而避免生成庞大而低效的稠密中间矩阵。通过这个练习，您将学会如何针对稀疏数据进行算法思维，并实现高效、可扩展的计算。[@problem_id:2433011]", "problem": "给定多对实值稀疏方阵，它们分别代表资产相关性矩阵和新闻情绪联动矩阵。对于每一对矩阵，计算其哈达玛积（Hadamard product，或称元素积 element-wise product），定义为 $A = C \\circ S$，其中对于所有索引 $i,j$，有 $A_{ij} = C_{ij} \\cdot S_{ij}$。每个稀疏矩阵由其维度 $n$ 和一个非零元素的有限列表指定。索引是从零开始的。任何未在列表中列出的元素都精确地为零。\n\n对于每个测试用例，计算并返回三个量：\n- $A$ 的非零元素数量，记为 $\\mathrm{nnz}(A)$。\n- $A$ 的所有元素之和，记为 $\\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} A_{ij}$。\n- $A$ 的弗罗贝尼乌斯范数的平方（squared Frobenius norm），记为 $\\lVert A \\rVert_F^2 = \\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} A_{ij}^2$。\n\n您的程序必须生成单行输出，其中包含所有测试用例的结果。结果应为一个由方括号括起来的逗号分隔列表。每个测试用例的结果本身也必须是一个列表，格式为 $[\\mathrm{nnz}(A), \\text{sum}, \\text{frob\\_sq}]$，其中 $\\mathrm{nnz}(A)$ 是一个整数，两个浮点值则打印并四舍五入到一位小数。例如：$[[x_1,y_1,z_1],[x_2,y_2,z_2],[x_3,y_3,z_3]]$。\n\n测试套件：\n- 测试用例 1：\n  - 维度: $n = 5$。\n  - 相关性矩阵 $C$ 的非零元素：\n    - 对角线元素：$(0,0,1)$、$(1,1,1)$、$(2,2,1)$、$(3,3,1)$、$(4,4,1)$。\n    - 非对角线对称元素对：$(0,1,0.3)$、$(1,0,0.3)$、$(0,3,-0.2)$、$(3,0,-0.2)$、$(2,4,0.5)$、$(4,2,0.5)$、$(1,2,0.1)$、$(2,1,0.1)$。\n  - 情绪矩阵 $S$ 的非零元素：\n    - 对角线元素：$(0,0,0.5)$、$(2,2,1.5)$、$(4,4,-1.0)$。\n    - 非对角线对称元素对：$(0,1,10)$、$(1,0,10)$、$(0,3,3)$、$(3,0,3)$、$(1,3,7)$、$(2,4,-2)$、$(4,2,-2)$、$(1,2,8)$、$(2,1,8)$。\n- 测试用例 2：\n  - 维度: $n = 4$。\n  - 相关性矩阵 $C$ 的非零元素：\n    - 对角线元素：$(0,0,1)$、$(1,1,1)$、$(2,2,1)$、$(3,3,1)$。\n    - 非对角线对称元素对：$(0,1,0.4)$、$(1,0,0.4)$、$(2,3,-0.7)$、$(3,2,-0.7)$。\n  - 情绪矩阵 $S$ 的非零元素：\n    - 仅非对角线对称元素对：$(1,2,5)$、$(2,1,5)$、$(0,3,9)$、$(3,0,9)$、$(1,3,2)$、$(3,1,2)$。\n- 测试用例 3：\n  - 维度: $n = 6$。\n  - 相关性矩阵 $C$ 的非零元素：\n    - 对角线元素：$(0,0,1)$、$(1,1,1)$、$(2,2,1)$、$(3,3,1)$、$(4,4,1)$、$(5,5,1)$。\n    - 非对角线对称元素对：$(0,2,0.2)$、$(2,0,0.2)$、$(1,2,-0.4)$、$(2,1,-0.4)$、$(3,4,0.9)$、$(4,3,0.9)$、$(4,5,0.6)$、$(5,4,0.6)$。\n  - 情绪矩阵 $S$ 的非零元素：\n    - 对角线元素：$(1,1,2.0)$、$(3,3,-1.0)$、$(5,5,4.0)$。\n    - 非对角线对称元素对：$(0,2,-5.0)$、$(2,0,-5.0)$、$(1,2,1.0)$、$(2,1,1.0)$、$(3,4,10.0)$、$(4,3,10.0)$、$(4,5,-3.0)$、$(5,4,-3.0)$、$(0,1,7.0)$、$(2,3,8.0)$。\n\n所有矩阵元素均为实数。索引 $(i,j)$ 满足 $0 \\le i,j < n$。对于每个测试用例，所列出的元素是全部非零元素的集合；任何未列出的元素都必须被视为精确的零。任何列表中都没有重复的索引对。\n\n最终输出格式：\n- 单行输出，包含 $[r_1,r_2,r_3]$，其中每个 $r_k$ 是测试用例 $k$ 的结果列表 $[\\mathrm{nnz}(A), \\text{sum}, \\text{frob\\_sq}]$，并且两个浮点值如上所述四舍五入到一位小数。", "solution": "问题已经过分析，被认为是有效的。这是一个适定（well-posed）的计算问题，基于线性代数和计算科学的标准原理，并提供了所有必要的数据。我们将继续进行求解。\n\n任务是计算由两个稀疏矩阵 $C$ 和 $S$ 的哈达玛积所产生的矩阵 $A$ 的三个属性。哈达玛积定义为 $A = C \\circ S$，其中每个元素 $A_{ij}$ 是源矩阵相应元素的简单乘积：$A_{ij} = C_{ij} \\cdot S_{ij}$。这些矩阵是稀疏的，意味着它们的大多数元素都为零。每个测试用例需要计算的属性是：非零元素的数量 $\\mathrm{nnz}(A)$；所有元素的总和 $\\sum_{i,j} A_{ij}$；以及弗罗贝尼乌斯范数的平方 $\\lVert A \\rVert_F^2 = \\sum_{i,j} A_{ij}^2$。\n\n解决该问题的基本原理植根于稀疏矩阵的哈达玛积的定义。一个元素 $A_{ij}$ 为非零的充分必要条件是 $C_{ij}$ 和 $S_{ij}$ 两者都为非零。如果 $C_{ij}$ 或 $S_{ij}$ 中任何一个为零（对于大多数索引都是这种情况），那么 $A_{ij}$ 必定为零。这导出了一个关键的观察：$A_{ij}$ 可能为非零的索引 $(i,j)$ 集合，是 $C$ 和 $S$ 的非零索引集合的交集。令 $\\mathcal{N}(M)$ 为矩阵 $M$ 具有非零元素的索引 $(i,j)$ 的集合。那么，$A$的非零结构由以下公式确定：\n$$\n\\mathcal{N}(A) = \\mathcal{N}(C) \\cap \\mathcal{N}(S)\n$$\n试图通过在内存中构建完整的 $n \\times n$ 稠密矩阵来解决此问题，是一种天真且计算上浪费的方法。对于大的维度 $n$，这将导致与 $n^2$ 成正比的过量内存消耗，以及涉及大量零值元素的不必要计算。唯一正确且高效的方法是直接对所提供的非零元素列表进行操作，从而充分利用数据的稀疏性。\n\n我们的算法是围绕这一稀疏索引集求交集的原理设计的。用于测试成员资格和检索与索引关联的值的最有效数据结构是哈希映射（hash map），在 Python 中称为字典（dictionary）。\n\n算法流程如下：\n$1$. 对于给定的一对矩阵 $C$ 和 $S$，我们首先处理其中一个（比如 $C$）来构建一个哈希映射。我们称此映射为 `c_map`。该映射的键是索引元组 $(i, j)$，值是对应的非零矩阵元素 $C_{ij}$。此步骤需要对 $C$ 的非零元素列表进行单次遍历，时间复杂度为 $O(\\mathrm{nnz}(C))$。\n\n$2$. 接下来，我们遍历第二个矩阵 $S$ 的非零元素列表。对于每个元素 $(i, j, S_{ij})$，我们使用索引元组 $(i, j)$ 作为键，在 `c_map` 中进行查找。这种哈希映射查找的平均情况时间复杂度为 $O(1)$。\n\n$3$. 如果在 `c_map` 中找到了键 $(i, j)$，这表示我们找到了一个 $C$ 和 $S$ 都具有非零元素的索引。我们从映射中检索值 $C_{ij}$ 并计算乘积 $A_{ij} = C_{ij} \\cdot S_{ij}$。\n\n$4$. 对于每个计算出的非零元素 $A_{ij}$，我们更新我们的三个聚合量：\n- 我们将非零元素的计数 $\\mathrm{nnz}(A)$ 加一。\n- 我们将 $A_{ij}$ 加到总和的运行总计中。\n- 我们将 $A_{ij}^2$ 加到弗罗贝尼乌斯范数平方的运行总计中。\n\n对 $S$ 中的所有非零元素重复此过程。迭代完成后，我们就计算出了矩阵 $A$ 所需的所有量。因此，该算法的总时间复杂度为 $O(\\mathrm{nnz}(C) + \\mathrm{nnz}(S))$，这相对于作为输入的非零元素数量是线性的。空间复杂度为 $O(\\min(\\mathrm{nnz}(C), \\mathrm{nnz}(S)))$，因为我们只需要将其中一个矩阵存储在哈希映射中；为了优化，我们会选择较小的一个。这种方法是最高效的，因为它避免了对零值元素的任何操作，并利用了常数时间查找。", "answer": "```python\nimport numpy as np\n# No other libraries are needed for this solution.\n\ndef solve():\n    \"\"\"\n    Solves the sparse matrix Hadamard product problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 5,\n            \"C_nonzeros\": [\n                (0, 0, 1.0), (1, 1, 1.0), (2, 2, 1.0), (3, 3, 1.0), (4, 4, 1.0),\n                (0, 1, 0.3), (1, 0, 0.3), (0, 3, -0.2), (3, 0, -0.2), (2, 4, 0.5),\n                (4, 2, 0.5), (1, 2, 0.1), (2, 1, 0.1)\n            ],\n            \"S_nonzeros\": [\n                (0, 0, 0.5), (2, 2, 1.5), (4, 4, -1.0), (0, 1, 10.0), (1, 0, 10.0),\n                (0, 3, 3.0), (3, 0, 3.0), (1, 3, 7.0), (2, 4, -2.0), (4, 2, -2.0),\n                (1, 2, 8.0), (2, 1, 8.0)\n            ]\n        },\n        {\n            \"n\": 4,\n            \"C_nonzeros\": [\n                (0, 0, 1.0), (1, 1, 1.0), (2, 2, 1.0), (3, 3, 1.0),\n                (0, 1, 0.4), (1, 0, 0.4), (2, 3, -0.7), (3, 2, -0.7)\n            ],\n            \"S_nonzeros\": [\n                (1, 2, 5.0), (2, 1, 5.0), (0, 3, 9.0), (3, 0, 9.0),\n                (1, 3, 2.0), (3, 1, 2.0)\n            ]\n        },\n        {\n            \"n\": 6,\n            \"C_nonzeros\": [\n                (0, 0, 1.0), (1, 1, 1.0), (2, 2, 1.0), (3, 3, 1.0), (4, 4, 1.0), (5, 5, 1.0),\n                (0, 2, 0.2), (2, 0, 0.2), (1, 2, -0.4), (2, 1, -0.4), (3, 4, 0.9),\n                (4, 3, 0.9), (4, 5, 0.6), (5, 4, 0.6)\n            ],\n            \"S_nonzeros\": [\n                (1, 1, 2.0), (3, 3, -1.0), (5, 5, 4.0), (0, 2, -5.0), (2, 0, -5.0),\n                (1, 2, 1.0), (2, 1, 1.0), (3, 4, 10.0), (4, 3, 10.0), (4, 5, -3.0),\n                (5, 4, -3.0), (0, 1, 7.0), (2, 3, 8.0)\n            ]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        c_nonzeros = case[\"C_nonzeros\"]\n        s_nonzeros = case[\"S_nonzeros\"]\n\n        # To optimize, build the map from the smaller set of nonzeros.\n        if len(c_nonzeros) <= len(s_nonzeros):\n            map_nonzeros = c_nonzeros\n            iterate_nonzeros = s_nonzeros\n        else:\n            map_nonzeros = s_nonzeros\n            iterate_nonzeros = c_nonzeros\n\n        map_data = {(i, j): val for i, j, val in map_nonzeros}\n\n        nnz_A = 0\n        sum_A = 0.0\n        frob_sq_A = 0.0\n\n        for i, j, val_iter in iterate_nonzeros:\n            if (i, j) in map_data:\n                val_map = map_data[(i, j)]\n                a_ij = val_iter * val_map\n                \n                # An entry is counted if the product is non-zero.\n                # Given inputs are non-zero, this check is robust for potential floating point issues.\n                if a_ij != 0.0:\n                    nnz_A += 1\n                    sum_A += a_ij\n                    frob_sq_A += a_ij**2\n\n        all_results.append(f\"[{nnz_A},{sum_A:.1f},{frob_sq_A:.1f}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2433011"}, {"introduction": "现在，让我们将理论与一个强大的实际应用联系起来。稀疏矩阵表示法在解决源自网络分析的大规模问题中不可或缺，而网络分析是现代经济学的核心领域之一。本练习将引导您建立并求解一个大型稀疏线性方程组 $ (I - \\alpha A^{\\top}) x = \\mathbf{1} $，用以计算一家公司在供应链网络中的影响力，即其卡茨中心性（Katz centrality）。这个实践将展示稀疏矩阵表示法的最终威力：使得分析那些若使用稠密矩阵则计算上不可行的复杂系统成为可能。[@problem_id:2432966]", "problem": "给定有向加权供应链网络，其由邻接矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 表示，其中 $A_{ij}$ 是从公司 $i$ 到公司 $j$ 的权重。公司网络的Katz中心性 $x \\in \\mathbb{R}^{n}$ 被定义为以下线性系统的唯一解：\n$$\n\\left(I - \\alpha A^{\\top}\\right) x = \\mathbf{1},\n$$\n其中 $I$ 是 $n \\times n$ 的单位矩阵，$\\alpha \\in \\mathbb{R}$ 满足 $\\alpha \\ge 0$，$A^{\\top}$ 是 $A$ 的转置，$\\mathbf{1}$ 是 $n$ 维的全一向量。当 $\\alpha < 1/\\rho(A)$ 时，解的存在性和唯一性得到保证，其中 $\\rho(A)$ 是 $A$ 的谱半径。\n\n您的任务是编写一个完整、可运行的程序，为几个指定的稀疏网络计算Katz中心性向量 $x$。节点由从 $0$ 到 $n-1$ 的整数标记。每个网络由一个元组 $(n,\\ \\text{边列表},\\ \\alpha)$ 指定，其中边列表是一组三元组 $(i,j,w)$ 的集合，其中 $i,j \\in \\{0,\\dots,n-1\\}$ 且 $w \\in \\mathbb{R}$，表示一条从 $i \\to j$ 权重为 $w$ 的有向边。邻接矩阵 $A$ 由这些边定义，任何未列出的条目均为零。\n\n计算下面每种情况的 $x$，并报告每个向量，其中每个分量四舍五入到 $6$ 位小数。\n\n测试套件：\n- 情况 $1$（通用无环供应链，正常情况）：\n  - $n = 4$\n  - 边：$(0,1,0.2)$, $(0,2,0.1)$, $(1,2,0.3)$, $(1,3,0.4)$, $(2,3,0.5)$\n  - $\\alpha = 0.85$\n- 情况 $2$（边界情况 $\\alpha = 0$）：\n  - $n = 3$\n  - 边：$(0,1,1)$, $(1,2,1)$, $(2,0,1)$\n  - $\\alpha = 0$\n- 情况 $3$（接近可逆性边界但可行）：\n  - $n = 3$\n  - 边：$(0,1,1)$, $(1,2,1)$, $(2,0,1)$\n  - $\\alpha = 0.99$\n- 情况 $4$（边缘情况：零矩阵）：\n  - $n = 5$\n  - 边：无\n  - $\\alpha = 0.7$\n\n数值精度要求：每个解向量的每个分量相对于真实解的绝对误差必须小于 $10^{-6}$。\n\n最终输出格式：您的程序应生成一行输出，其中包含解向量列表（每个测试用例一个），该列表是单个逗号分隔的列表，并用方括号括起来。每个向量本身也是一个用方括号括起来的逗号分隔列表，每个数字都是一个小数，小数点后恰好有 $6$ 位数字。外部列表中的向量顺序必须与上面列出的测试用例顺序相匹配。", "solution": "所提出的问题是线性代数在网络分析中的一个直接应用。我们的任务是为一系列网络计算Katz中心性向量 $x$。中心性向量 $x$ 被定义为以下线性系统的解：\n$$\n\\left(I - \\alpha A^{\\top}\\right) x = \\mathbf{1}\n$$\n在这里，$I$ 是 $n \\times n$ 的单位矩阵，$A$ 是网络的邻接矩阵，$\\alpha$ 是一个非负标量衰减因子，$\\mathbf{1}$ 是 $n$ 维的全一向量。矩阵 $A^{\\top}$ 是 $A$ 的转置。在 $\\alpha < 1/\\rho(A)$ 的条件下，唯一非负解 $x$ 的存在性得到保证，其中 $\\rho(A)$ 是 $A$ 的谱半径。问题陈述确保了所有测试用例都满足此条件。\n\n任务的核心是求解这个线性方程组，可以表示为 $M x = b$，其中系数矩阵是 $M = I - \\alpha A^{\\top}$，右侧向量是 $b = \\mathbf{1}$。\n\n这些网络被描述为稀疏网络，意味着邻接矩阵 $A$ 包含绝大多数的零元素。为了计算效率，必须使用为稀疏矩阵设计的数据结构，而不是密集的 $n \\times n$ 数组。Python中的 `scipy.sparse` 库提供了必要的工具。\n\n对于每个测试用例 $(n, \\text{边列表}, \\alpha)$，算法按以下步骤进行：\n\n1.  **构造矩阵 $M = I - \\alpha A^{\\top}$**：\n    *   首先，我们以稀疏格式构造邻接矩阵的转置 $A^{\\top}$。输入边列表以三元组 $(i, j, w)$ 的形式提供了 $A$ 的条目，这对应于矩阵元素 $A_{ij} = w$。因此，对于转置矩阵 $A^{\\top}$，这对应于元素 $(A^{\\top})_{ji} = w$。我们可以通过向稀疏矩阵构造函数（例如 `scipy.sparse.coo_matrix`）提供行索引、列索引和数据值的列表来高效地组装 $A^{\\top}$。\n    *   使用像 `scipy.sparse.identity(n)`这样的函数来构造大小为 $n \\times n$ 的单位矩阵 $I$。\n    *   然后，矩阵 $M$ 通过稀疏矩阵运算 $I - \\alpha \\cdot A^{\\top}$ 计算得出。`SciPy` 能正确处理其稀疏矩阵格式的标量乘法和减法。\n\n2.  **构造向量 $b$**：\n    *   向量 $b = \\mathbf{1}$ 是一个 $n$ 维向量，其中每个分量都是 $1$。这可以使用 `numpy.ones(n)` 创建。\n\n3.  **求解线性系统 $M x = b$**：\n    *   准备好稀疏矩阵 $M$ 和密集向量 $b$ 后，我们使用专门的稀疏线性求解器求解 $x$。函数 `scipy.sparse.linalg.spsolve(M, b)` 就是为此目的设计的。它采用了高效的数值方法（例如基于稀疏矩阵LU分解的直接方法），避免了密集矩阵求逆所带来的高昂内存和计算成本。\n\n4.  **处理特殊情况**：\n    *   考察边界条件是有益的。\n    *   对于情况 $2$，其中 $\\alpha=0$，方程简化为 $(I - 0 \\cdot A^{\\top}) x = \\mathbf{1}$，即 $I x = \\mathbf{1}$。解显然是 $x = \\mathbf{1}$。\n    *   对于情况 $4$，其中边列表为空，邻接矩阵 $A$ 是零矩阵。因此，$A^{\\top}$ 也是零矩阵。方程变为 $(I - \\alpha \\cdot 0) x = \\mathbf{1}$，同样是 $I x = \\mathbf{1}$，得出 $x = \\mathbf{1}$，无论 $\\alpha$ 的值如何。\n    *   在这两种情况下，稀疏求解器的计算机制是不必要的，结果可以直接得出。我们的实现将识别这些简单情况。\n\n对于一般情况，如情况 $1$ 和情况 $3$，需要完整的数值计算过程。对于情况 $1$，矩阵 $A$ 是无环的，导致 $A^{\\top}$ 是一个幂零矩阵。矩阵 $M = I - \\alpha A^{\\top}$ 是下三角矩阵，该系统可以通过前向替换进行解析求解，这为数值结果提供了一个很好的检验。对于情况 $3$，对于该特定矩阵，$\\rho(A)=1$，所以 $\\alpha=0.99$ 接近稳定性边界。矩阵 $M$ 变得接近奇异，但问题仍然是适定的，数值求解器将产生一个有效的解，我们通过解析推导得出，对于所有 $i$，$x_i = 1/(1-\\alpha) = 100$。\n\n实现将遵循此逻辑，处理每个测试用例，计算向量 $x$，并将输出格式化为指定的 $6$ 位小数精度。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import coo_matrix, identity\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the Katz centrality problem for a batch of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: General acyclic supply chain\n        {'n': 4, 'edges': [(0, 1, 0.2), (0, 2, 0.1), (1, 2, 0.3), (1, 3, 0.4), (2, 3, 0.5)], 'alpha': 0.85},\n        # Case 2: Boundary at alpha = 0\n        {'n': 3, 'edges': [(0, 1, 1), (1, 2, 1), (2, 0, 1)], 'alpha': 0},\n        # Case 3: Near the invertibility boundary\n        {'n': 3, 'edges': [(0, 1, 1), (1, 2, 1), (2, 0, 1)], 'alpha': 0.99},\n        # Case 4: Zero matrix\n        {'n': 5, 'edges': [], 'alpha': 0.7},\n    ]\n\n    all_results_str = []\n\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        alpha = case['alpha']\n\n        # The Katz centrality vector is the solution x to the linear system\n        # (I - alpha * A_transpose) * x = 1\n        # where 1 is a vector of ones.\n\n        # Handle trivial cases for efficiency and correctness.\n        # If alpha is 0 or there are no edges (A is zero matrix),\n        # the equation becomes I*x = 1, so x is a vector of ones.\n        if alpha == 0 or not edges:\n            x = np.ones(n)\n        else:\n            # Construct the transpose of the adjacency matrix A in sparse format.\n            # For an edge (i, j, w) in A, A[i,j] = w.\n            # In A_transpose, this becomes A_transpose[j,i] = w.\n            row_indices = [j for i, j, w in edges]\n            col_indices = [i for i, j, w in edges]\n            data = [w for i, j, w in edges]\n\n            # Use Coordinate (COO) format for easy construction, then convert to\n            # Compressed Sparse Row (CSR) for efficient arithmetic and solving.\n            A_transpose = coo_matrix((data, (row_indices, col_indices)), shape=(n, n)).asformat('csr')\n\n            # Create the identity matrix in sparse CSR format.\n            I = identity(n, format='csr')\n\n            # Form the coefficient matrix M = I - alpha * A_transpose.\n            M = I - alpha * A_transpose\n\n            # The right-hand side vector `b` is a vector of ones.\n            b = np.ones(n)\n\n            # Solve the sparse linear system Mx = b.\n            x = spsolve(M, b)\n\n        # Format the resulting vector according to the problem specification.\n        # Each component is rounded to 6 decimal places.\n        formatted_x = [f\"{val:.6f}\" for val in x]\n        all_results_str.append(f\"[{','.join(formatted_x)}]\")\n\n    # Print the final result in the exact single-line format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "2432966"}]}