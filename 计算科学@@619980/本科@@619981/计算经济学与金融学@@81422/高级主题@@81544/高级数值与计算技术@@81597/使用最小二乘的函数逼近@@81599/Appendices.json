{"hands_on_practices": [{"introduction": "第一个练习将让您扮演一位应用经济学家的角色。您将使用多项式逼近来为著名的拉弗曲线建模，学习如何通过普通最小二乘法 (OLS) 将模型与含噪声的数据进行拟合 [@problem_id:2395010]。更关键的是，您将使用交叉验证来选择合适的多项式次数，这是一种在模型拟合度和复杂性之间取得平衡以避免过拟合的重要技术。", "problem": "考虑一个经济体，其中政府税收是平均税率的函数。设税率用 $t \\in [0,1]$ 表示（以小数而非百分比形式），并假设我们观测到由一个结构形式在不同税率下生成的带有噪声的税收样本。您的任务是使用普通最小二乘法（OLS）拟合一个二次或三次多项式，以近似未知的拉弗曲线（税收作为税率的函数），然后利用拟合的近似函数计算单位区间上能使税收最大化的税率。\n\n从以下基本原理开始：\n- 给定样本对 $\\{(t_i, y_i)\\}_{i=1}^n$，一个 $d$ 次多项式为 $p_d(t) = \\sum_{j=0}^{d} \\beta_j t^j$。普通最小二乘法（OLS）通过最小化残差平方和 $\\sum_{i=1}^{n} (y_i - p_d(t_i))^2$ 来估计系数。\n- 模型选择可通过 $K$ 折交叉验证进行，该方法评估样本外预测误差，并选择平均验证误差最低的次数 $d$。\n\n您的程序必须：\n1. 对每个测试用例，按如下方式模拟数据 $(t_i, y_i)$。抽取 $n$ 个独立的税率 $t_i \\sim \\text{Uniform}[0,1]$。生成噪声 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$。通过 $R_{\\text{true}}(t) = A \\cdot t \\cdot (1 - t)^k$ 定义真实税收函数。然后设 $y_i = R_{\\text{true}}(t_i) + \\varepsilon_i$。所有随机性必须按照测试套件中的规定进行确定性播种。\n2. 对每个候选次数 $d \\in \\{2,3\\}$，使用模拟数据通过 OLS 拟合 $p_d(t)$。\n3. 使用 $K=5$ 折的 $K$ 折交叉验证（使用给定的种子进行随机打乱）来选择具有最低平均验证均方误差的次数 $d$。如果出现平局，则优先选择较低的次数。\n4. 在完整数据集上重新拟合所选次数，以获得最终系数 $\\hat{\\beta}_j$。\n5. 通过在闭区间 $[0,1]$上最大化拟合的多项式 $p_d(t)$ 来计算估计的税收最大化税率 $\\hat{t}^\\star$。具体而言，通过求解 $p_d'(t)=0$ 找到所有位于 $[0,1]$ 内的实数临界点，在这些点以及端点 $t=0$ 和 $t=1$ 处评估 $p_d(t)$，并将 $\\hat{t}^\\star$ 设为最大值点。然后计算估计的最大税收 $\\hat{R}^\\star = p_d(\\hat{t}^\\star)$。\n6. 本问题不涉及角度。所有税率均以 $[0,1]$ 内的小数表示，所有税收均以不带百分号的实数表示。\n\n使用以下测试套件。对于每种情况，对所有随机操作（包括数据生成和分折打乱）使用提供的种子，抽取 $n$ 个点，使用噪声标准差 $\\sigma$ 以及数据生成过程 $R_{\\text{true}}(t) = A \\cdot t \\cdot (1 - t)^k$ 的参数 $A$ 和 $k$：\n- 情况 1：种子 $42$， $n=40$， $\\sigma=0.005$， $A=1.0$， $k=1$。\n- 情况 2：种子 $123$， $n=50$， $\\sigma=0.01$， $A=1.0$， $k=2$。\n- 情况 3：种子 $7$， $n=25$， $\\sigma=0.05$， $A=1.0$， $k=2$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个 Python 风格的列表，该列表包含三个子列表，每个子列表对应一个测试用例，顺序与上文相同。每个子列表的形式必须为 $[d, \\hat{t}^\\star, \\hat{R}^\\star]$，其中 $d$ 是所选次数（整数，值为 $\\{2,3\\}$ 之一），$\\hat{t}^\\star$ 和 $\\hat{R}^\\star$ 四舍五入到恰好六位小数。例如：$[[2,0.500000,0.250000],[3,0.333333,0.197531],[2,0.480000,0.210000]]$。", "solution": "根据指定标准对问题进行验证。\n\n**第 1 步：提取给定信息**\n- **定义域**：税率 $t \\in [0,1]$。\n- **数据**：样本对 $\\{(t_i, y_i)\\}_{i=1}^n$。\n- **模型**：$d$ 次多项式，$p_d(t) = \\sum_{j=0}^{d} \\beta_j t^j$。\n- **估计方法**：通过最小化残差平方和 $\\sum_{i=1}^{n} (y_i - p_d(t_i))^2$ 的普通最小二乘法（OLS）。\n- **模型选择**：$K$ 折交叉验证，其中 $K=5$。选择平均验证误差最低的次数 $d$。候选次数为 $d \\in \\{2,3\\}$。若出现平局，则选择较低的次数。\n- **数据生成过程**：\n    - $t_i \\sim \\text{Uniform}[0,1]$。\n    - 噪声 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$。\n    - 真实税收函数 $R_{\\text{true}}(t) = A \\cdot t \\cdot (1 - t)^k$。\n    - 观测税收样本 $y_i = R_{\\text{true}}(t_i) + \\varepsilon_i$。\n- **最优化**：通过在区间 $[0,1]$ 上最大化拟合的多项式 $p_d(t)$ 来找到使税收最大化的税率 $\\hat{t}^\\star$。估计的最大税收为 $\\hat{R}^\\star = p_d(\\hat{t}^\\star)$。\n- **测试用例**：\n    - 情况 1：种子=$42$，$n=40$，$\\sigma=0.005$，$A=1.0$，$k=1$。\n    - 情况 2：种子=$123$，$n=50$，$\\sigma=0.01$，$A=1.0$，$k=2$。\n    - 情况 3：种子=$7$，$n=25$，$\\sigma=0.05$，$A=1.0$，$k=2$。\n\n**第 2 步：使用提取的给定信息进行验证**\n- **科学依据**：该问题具有科学依据。它提出了经济计量学和统计学中的一个标准任务：从含噪声数据中进行函数近似。使用多项式回归、普通最小二乘法和交叉验证进行模型选择是基础且成熟的方法。拉弗曲线是经济学中的一个有效概念，所选的函数形式是一个数学上易于处理的模型。\n- **适定性**：该问题是适定的。所有必需的参数、数据生成过程和算法步骤都已明确定义。目标清晰，并且在给定确定性种子的情况下，每个测试用例都会产生唯一的计算结果。\n- **客观性**：问题陈述是客观的，使用了精确的数学和统计语言，没有主观或含糊不清的术语。\n\n**第 3 步：结论与行动**\n该问题有效。这是一个在应用统计学中定义明确的计算练习。将提供一个解决方案。\n\n---\n\n该问题要求我们从一组带噪声的观测数据中，近似一个表示税收与税率关系的未知函数。我们将使用多项式回归，并通过 $K$ 折交叉验证从候选集合 $\\{2, 3\\}$ 中选择最优的多项式次数。随后，我们将在有效定义域 $[0,1]$ 上找到使估计的税收函数最大化的税率。\n\n**1. 数据生成**\n对于每个测试用例，我们都给定一个伪随机数生成器的种子、样本数量 $n$、噪声标准差 $\\sigma$ 以及真实税收函数的参数 $A$ 和 $k$。数据点 $(t_i, y_i)$（$i=1, \\dots, n$）按以下方式生成：\n- 税率 $t_i$ 从区间 $[0, 1]$ 上的均匀分布中抽取，即 $t_i \\sim \\text{U}[0, 1]$。\n- 相应的真实税收通过 $R_{\\text{true}}(t_i) = A \\cdot t_i \\cdot (1 - t_i)^k$ 计算。\n- 噪声项 $\\varepsilon_i$ 从均值为 $0$、方差为 $\\sigma^2$ 的正态分布中抽取，即 $\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$。\n- 观测到的税收为 $y_i = R_{\\text{true}}(t_i) + \\varepsilon_i$。\n\n**2. 通过普通最小二乘法（OLS）进行多项式回归**\n我们试图用一个 $d$ 次多项式 $p_d(t) = \\sum_{j=0}^{d} \\beta_j t^j$ 来近似真实函数。系数 $\\boldsymbol{\\beta} = [\\beta_0, \\beta_1, \\dots, \\beta_d]^T$ 通过最小化残差平方和（SSR）来估计：\n$$\n\\text{SSR}(\\boldsymbol{\\beta}) = \\sum_{i=1}^{n} (y_i - p_d(t_i))^2\n$$\n这是一个线性最小二乘问题。设 $\\mathbf{y} = [y_1, \\dots, y_n]^T$ 为观测税收的向量。设 $\\mathbf{X}$ 为 $n \\times (d+1)$ 的设计矩阵，对于多项式拟合，它是一个范德蒙矩阵：\n$$\n\\mathbf{X} =\n\\begin{pmatrix}\n1 & t_1 & t_1^2 & \\dots & t_1^d \\\\\n1 & t_2 & t_2^2 & \\dots & t_2^d \\\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n1 & t_n & t_n^2 & \\dots & t_n^d\n\\end{pmatrix}\n$$\n问题在于最小化 $||\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\beta}||_2^2$。解 $\\hat{\\boldsymbol{\\beta}}$ 由正规方程组给出：\n$$\n(\\mathbf{X}^T \\mathbf{X})\\hat{\\boldsymbol{\\beta}} = \\mathbf{X}^T \\mathbf{y}\n$$\n假设 $\\mathbf{X}^T \\mathbf{X}$ 可逆，则 OLS 估计值为 $\\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y}$。在计算上，通常使用如 QR 分解等高效方法求解，这也是数值库通常采用的实现方式。\n\n**3. 通过 $K$ 折交叉验证进行模型选择**\n为在二次（$d=2$）和三次（$d=3$）模型之间进行选择，我们使用 $K=5$ 的 $K$ 折交叉验证。该技术提供了模型样本外预测误差的估计，有助于防止过拟合。\n对每个候选次数 $d$，其过程如下：\n1. 将包含 $n$ 个样本的数据集随机打乱，并划分为 $K=5$ 个大小近乎相等的不相交子集（折）。\n2. 对每一折 $k \\in \\{1, 2, 3, 4, 5\\}$：\n   a. 将第 $k$ 折指定为验证集。其余 $K-1$ 折合并形成训练集。\n   b. 在训练集上使用 OLS 拟合一个次数为 $d$ 的多项式，得到系数 $\\hat{\\boldsymbol{\\beta}}^{(k)}$。\n   c. 在验证集上计算均方误差（MSE）：$MSE_k = \\frac{1}{|N_k|} \\sum_{i \\in \\text{fold } k} (y_i - p_d(t_i; \\hat{\\boldsymbol{\\beta}}^{(k)}))^2$，其中 $|N_k|$ 是第 $k$ 折中的样本数。\n3. 次数 $d$ 的交叉验证分数为这些 MSE 的平均值：$CV(d) = \\frac{1}{K} \\sum_{k=1}^{K} MSE_k$。\n选择使该分数最小化的次数作为最优次数 $d^\\star$：$d^\\star = \\arg\\min_{d \\in \\{2,3\\}} CV(d)$。如果 $CV(2) = CV(3)$，我们选择更简单的模型，即 $d^\\star=2$。\n\n**4. 所选模型的优化**\n一旦选定最优次数 $d^\\star$，就在整个数据集上重新拟合多项式模型，以获得最终的系数向量 $\\hat{\\boldsymbol{\\beta}}$。我们将最终估计的税收函数表示为 $p_{d^\\star}(t)$。\n\n下一步是在闭区间 $[0, 1]$ 上找到使该函数最大化的税率 $\\hat{t}^\\star$。根据极值定理，闭区间上的连续函数必能达到其最大值和最小值。最大值点必须位于区间的端点（$t=0$ 或 $t=1$）或导数 $p'_{d^\\star}(t)$ 为零的内部临界点。\n\n该多项式的导数为 $p'_{d^\\star}(t) = \\sum_{j=1}^{d^\\star} j \\hat{\\beta}_j t^{j-1}$。\n- 如果 $d^\\star=2$，导数为 $p'_2(t) = \\hat{\\beta}_1 + 2\\hat{\\beta}_2 t$。令其为零得到一个临界点：$t_c = -\\frac{\\hat{\\beta}_1}{2\\hat{\\beta}_2}$。\n- 如果 $d^\\star=3$，导数为 $p'_3(t) = \\hat{\\beta}_1 + 2\\hat{\\beta}_2 t + 3\\hat{\\beta}_3 t^2$。这是一个二次方程。可以使用二次公式求其根，最多可得到两个实数临界点。\n\n最大值点 $\\hat{t}^\\star$ 的候选值集合包括端点 $\\{0, 1\\}$ 以及所有位于区间 $[0, 1]$ 内的实数临界点。我们在所有这些候选点上评估 $p_{d^\\star}(t)$。产生最高税收的 $t$ 值即为估计的最优税率 $\\hat{t}^\\star$。\n$$\n\\hat{t}^\\star = \\arg\\max_{t \\in \\text{candidates}} p_{d^\\star}(t)\n$$\n然后，估计的最大税收为 $\\hat{R}^\\star = p_{d^\\star}(\\hat{t}^\\star)$。对每个测试用例重复此过程，以生成最终结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Laffer curve approximation problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # (seed, n, sigma, A, k)\n        (42, 40, 0.005, 1.0, 1),\n        (123, 50, 0.01, 1.0, 2),\n        (7, 25, 0.05, 1.0, 2),\n    ]\n\n    all_results = []\n    \n    for seed, n, sigma, A, k_param in test_cases:\n        # Set all sources of randomness for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # 1. Simulate data\n        t = rng.uniform(0, 1, n)\n        true_revenue = A * t * (1 - t)**k_param\n        noise = rng.normal(0, sigma, n)\n        y = true_revenue + noise\n\n        # 2. & 3. Model selection using 5-fold cross-validation\n        K = 5\n        indices = np.arange(n)\n        rng.shuffle(indices)\n        folds = np.array_split(indices, K)\n        \n        candidate_degrees = [2, 3]\n        cv_errors = {}\n\n        for d in candidate_degrees:\n            fold_mses = []\n            for k_fold_idx in range(K):\n                val_indices = folds[k_fold_idx]\n                train_indices = np.concatenate([folds[i] for i in range(K) if i != k_fold_idx])\n\n                t_train, y_train = t[train_indices], y[train_indices]\n                t_val, y_val = t[val_indices], y[val_indices]\n\n                # Fit model on training data\n                X_train = np.vander(t_train, d + 1, increasing=True)\n                coeffs, _, _, _ = np.linalg.lstsq(X_train, y_train, rcond=None)\n\n                # Evaluate on validation data\n                X_val = np.vander(t_val, d + 1, increasing=True)\n                y_pred_val = X_val @ coeffs\n                mse = np.mean((y_val - y_pred_val)**2)\n                fold_mses.append(mse)\n            \n            cv_errors[d] = np.mean(fold_mses)\n\n        # Select the best degree, preferring the lower degree in case of a tie\n        if cv_errors[2] <= cv_errors[3]:\n            d_star = 2\n        else:\n            d_star = 3\n\n        # 4. Refit the chosen model on the full dataset\n        X_full = np.vander(t, d_star + 1, increasing=True)\n        # beta has shape (d_star + 1,) where beta[j] is the coefficient for t^j\n        beta, _, _, _ = np.linalg.lstsq(X_full, y, rcond=None)\n\n        # 5. Compute the estimated revenue-maximizing tax rate\n        \n        # Derivative coefficients: p'(t) = sum_{j=1 to d} j * beta[j] * t^(j-1)\n        # np.roots expects coefficients in descending power order\n        # For p'(t) = c_0*t^(d-1) + ... + c_{d-1}, coeffs are [c_0, ..., c_{d-1}]\n        # c_m = (m+1)*beta[m+1] in our notation.\n        # So for np.roots, we need [(d_star)*beta[d_star], (d_star-1)*beta[d_star-1], ..., 1*beta[1]]\n        deriv_coeffs = [j * beta[j] for j in range(d_star, 0, -1)]\n        critical_points = np.roots(deriv_coeffs)\n        \n        # Candidate points for the maximum on [0, 1]\n        candidate_t = [0.0, 1.0]\n        for root in critical_points:\n            # Filter for real roots within the interval [0, 1]\n            if np.isreal(root) and 0.0 <= root.real <= 1.0:\n                candidate_t.append(root.real)\n        \n        candidate_t = np.unique(candidate_t)\n\n        # Evaluate the polynomial at candidate points to find the maximum\n        # np.polyval expects coefficients in descending power order [beta_d, ..., beta_0]\n        poly_coeffs_desc = beta[::-1]\n        candidate_R = np.polyval(poly_coeffs_desc, candidate_t)\n        \n        max_idx = np.argmax(candidate_R)\n        t_star = candidate_t[max_idx]\n        R_star = candidate_R[max_idx]\n\n        all_results.append(\n            f\"[{d_star},{t_star:.6f},{R_star:.6f}]\"\n        )\n        \n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2395010"}, {"introduction": "虽然普通最小二乘法功能强大，但在数据稀疏或预测变量高度相关时，其结果可能会不稳定。本练习介绍了一种解决方案：岭回归，它是一种正则化最小二乘法 [@problem_id:2394930]。通过对系数的大小施加一个小的惩罚项，我们可以获得更稳定和可靠的估计，这对于建立稳健的现实世界模型至关重要。", "problem": "一位市场分析师希望估计一个线性的反需求关系，该关系将每日需求量与公布价格联系起来。对于每一天 $t \\in \\{1,2,\\dots,T\\}$，分析师观测到一个价格 $p_t \\in \\mathbb{R}$ 和一个数量 $q_t \\in \\mathbb{R}$。该关系被建模为 $q_t = a + b \\, p_t + \\varepsilon_t$，其中 $a \\in \\mathbb{R}$ 和 $b \\in \\mathbb{R}$ 是未知常数，而 $\\varepsilon_t \\in \\mathbb{R}$ 代表一个未观测到的误差。分析师每天仅使用截至当天观测到的数据来更新其估计值。在第 $t$ 天，将估计量 $(\\hat{a}_t,\\hat{b}_t)$ 定义为惩罚平方和的最小化者\n$$\n\\sum_{i=1}^{t} \\left(q_i - a - b \\, p_i\\right)^2 \\;+\\; \\lambda \\, (a^2 + b^2),\n$$\n对于给定的惩罚权重 $\\lambda > 0$，其中截距项和斜率项都受到惩罚。样本的最终估计量为 $(\\hat{a}_T,\\hat{b}_T)$。对于给定的预测价格 $p^\\star \\in \\mathbb{R}$，将预测数量定义为 $\\hat{q}^\\star = \\hat{a}_T + \\hat{b}_T \\, p^\\star$。\n\n实现一个程序，对于下述每个测试用例，该程序按时间顺序处理每日观测数据，在每一天维护由最小化问题隐含的当前估计量，并在最后一天之后返回最终估计量以及在指定预测价格下的预测数量。程序必须将所有量视为实数。不涉及角度。不涉及物理单位。所有输出都必须是实数。\n\n该测试套件包含三个用例。在每个用例中，程序会获得一个每日价格序列、一个等长的每日数量序列、一个正惩罚项 $\\lambda$ 和一个预测价格 $p^\\star$。\n\n测试用例 1（良态数据，中等变异）：\n- 价格 $p_t$，$t \\in \\{1,\\dots,6\\}$：$\\{1.0, 2.0, 3.0, 4.0, 5.0, 2.5\\}$。\n- 数量 $q_t$，$t \\in \\{1,\\dots,6\\}$：$\\{9.2, 5.9, 3.0, 0.1, -3.2, 4.55\\}$。\n- 惩罚项 $\\lambda = 0.1$。\n- 预测价格 $p^\\star = 3.3$。\n\n测试用例 2（边界条件：无正则化时欠定）：\n- 价格 $p_t$，$t \\in \\{1\\}$：$\\{2.0\\}$。\n- 数量 $q_t$，$t \\in \\{1\\}$：$\\{2.0\\}$。\n- 惩罚项 $\\lambda = 10.0$。\n- 预测价格 $p^\\star = 2.0$。\n\n测试用例 3（近似共线性：价格高度聚集）：\n- 价格 $p_t$，$t \\in \\{1,\\dots,5\\}$：$\\{1.0, 1.01, 0.99, 1.0, 1.005\\}$。\n- 数量 $q_t$，$t \\in \\{1,\\dots,5\\}$：$\\{5.0, 4.98, 5.02, 5.0, 4.99\\}$。\n- 惩罚项 $\\lambda = 0.5$。\n- 预测价格 $p^\\star = 1.0$。\n\n您的程序必须在单行内生成一个长度为 3 的列表，其第 $j$ 个元素对应于测试用例 $j \\in \\{1,2,3\\}$，并且该元素本身是一个包含三个实数 $[\\hat{a}_T, \\hat{b}_T, \\hat{q}^\\star]$ 的列表，其中每个数都四舍五入到小数点后恰好六位。最终输出格式必须是包含一个用方括号括起来的、以逗号分隔的列表的单行，不带任何附加文本，例如：\n$[[x_{11},x_{12},x_{13}],[x_{21},x_{22},x_{23}],[x_{31},x_{32},x_{33}]]$。", "solution": "问题陈述已经过验证，并被认为是有效的。这是一个良定的数学优化问题，其基础是正则化线性回归的既定原则。所有必要的数据和条件均已提供，不存在科学或逻辑上的矛盾。\n\n该问题要求通过最小化惩罚平方和来估计线性模型 $q_t = a + b \\, p_t + \\varepsilon_t$ 的系数 $a \\in \\mathbb{R}$ 和 $b \\in \\mathbb{R}$。对于一个包含 $T$ 个观测值 $\\{(p_i, q_i)\\}_{i=1}^T$ 的数据集，需要最小化的目标函数是\n$$ S(a, b) = \\sum_{i=1}^{T} (q_i - a - b \\, p_i)^2 + \\lambda (a^2 + b^2) $$\n其中 $\\lambda > 0$ 是一个给定的惩罚权重。估计量 $(\\hat{a}_T, \\hat{b}_T)$ 是使 $S(a, b)$ 最小化的 $(a, b)$ 的值。这是 Ridge Regression 的一个特定实例，其中截距项也受到了惩罚。\n\n为了找到最小值，我们必须计算 $S(a, b)$ 关于 $a$ 和 $b$ 的偏导数，并将它们设为零。这一点对应于梯度为零，即 $\\nabla S(a, b) = \\mathbf{0}$。\n\n关于 $a$ 的偏导数是：\n$$ \\frac{\\partial S}{\\partial a} = \\sum_{i=1}^{T} 2(q_i - a - b \\, p_i)(-1) + 2\\lambda a = -2 \\sum_{i=1}^{T} (q_i - a - b \\, p_i) + 2\\lambda a $$\n将 $\\frac{\\partial S}{\\partial a} = 0$ 设为零，得到第一个正规方程：\n$$ \\sum_{i=1}^{T} (q_i - a - b \\, p_i) = \\lambda a $$\n$$ \\sum_{i=1}^{T} q_i - T a - b \\sum_{i=1}^{T} p_i = \\lambda a $$\n$$ (T + \\lambda)a + \\left(\\sum_{i=1}^{T} p_i\\right)b = \\sum_{i=1}^{T} q_i $$\n\n关于 $b$ 的偏导数是：\n$$ \\frac{\\partial S}{\\partial b} = \\sum_{i=1}^{T} 2(q_i - a - b \\, p_i)(-p_i) + 2\\lambda b = -2 \\sum_{i=1}^{T} (q_i p_i - a p_i - b p_i^2) + 2\\lambda b $$\n将 $\\frac{\\partial S}{\\partial b} = 0$ 设为零，得到第二个正规方程：\n$$ \\sum_{i=1}^{T} (q_i p_i - a p_i - b p_i^2) = \\lambda b $$\n$$ \\left(\\sum_{i=1}^{T} p_i\\right)a + \\left(\\sum_{i=1}^{T} p_i^2 + \\lambda\\right)b = \\sum_{i=1}^{T} p_i q_i $$\n\n这两个方程构成了关于估计量 $(\\hat{a}_T, \\hat{b}_T)$ 的一个线性方程组。该方程组的矩阵形式为：\n$$\n\\begin{pmatrix}\nT + \\lambda & \\sum_{i=1}^{T} p_i \\\\\n\\sum_{i=1}^{T} p_i & \\sum_{i=1}^{T} p_i^2 + \\lambda\n\\end{pmatrix}\n\\begin{pmatrix}\n\\hat{a}_T \\\\\n\\hat{b}_T\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\sum_{i=1}^{T} q_i \\\\\n\\sum_{i=1}^{T} p_i q_i\n\\end{pmatrix}\n$$\n该系统可以写作 $(\\mathbf{X}^T\\mathbf{X} + \\lambda\\mathbf{I})\\boldsymbol{\\beta} = \\mathbf{X}^T\\mathbf{y}$，其中 $\\boldsymbol{\\beta} = [\\hat{a}_T, \\hat{b}_T]^T$，$\\mathbf{y}$ 是数量向量，$\\mathbf{I}$ 是 $2 \\times 2$ 的单位矩阵，$\\mathbf{X}$ 是一个 $T \\times 2$ 的设计矩阵，其中一列全为 1，另一列为价格。对于 $\\lambda > 0$，目标函数 $S(a, b)$ 是严格凸的，这保证了解的唯一性。\n\n针对每个测试用例求解最终估计量 $(\\hat{a}_T, \\hat{b}_T)$ 的算法如下：\n$1$. 对于给定的包含 $T$ 个价格-数量对 $\\{p_i, q_i\\}_{i=1}^T$ 的数据集，计算必要的汇总统计量：$T$, $\\sum p_i$, $\\sum q_i$, $\\sum p_i^2$ 和 $\\sum p_i q_i$。\n$2$. 构建 $2 \\times 2$ 矩阵 $\\mathbf{M} = \\begin{pmatrix} T + \\lambda & \\sum p_i \\\\ \\sum p_i & \\sum p_i^2 + \\lambda \\end{pmatrix}$ 和 $2 \\times 1$ 向量 $\\mathbf{v} = \\begin{pmatrix} \\sum q_i \\\\ \\sum p_i q_i \\end{pmatrix}$。\n$3$. 求解线性系统 $\\mathbf{M}\\boldsymbol{\\beta} = \\mathbf{v}$ 以得到系数向量 $\\boldsymbol{\\beta} = [\\hat{a}_T, \\hat{b}_T]^T$。这可以使用数值线性代数库高效且稳健地完成。\n$4$. 一旦求得最终估计量 $\\hat{a}_T$ 和 $\\hat{b}_T$，使用模型 $\\hat{q}^\\star = \\hat{a}_T + \\hat{b}_T p^\\star$ 计算给定价格 $p^\\star$ 的预测数量。\n$5$. 每个测试用例的最终结果是一个列表 $[\\hat{a}_T, \\hat{b}_T, \\hat{q}^\\star]$，其中每个元素都四舍五入到小数点后六位。\n\n“按时间顺序处理每日观测数据”这一措辞并不意味着必须使用递归实现，因为第 $T$ 天的最终估计仅依赖于截至该天的完整观测数据集。对整个样本进行批量计算既更直接，在数值上也更优越。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the penalized least squares problem for all test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"prices\": [1.0, 2.0, 3.0, 4.0, 5.0, 2.5],\n            \"quantities\": [9.2, 5.9, 3.0, 0.1, -3.2, 4.55],\n            \"lambda\": 0.1,\n            \"p_star\": 3.3\n        },\n        {\n            \"prices\": [2.0],\n            \"quantities\": [2.0],\n            \"lambda\": 10.0,\n            \"p_star\": 2.0\n        },\n        {\n            \"prices\": [1.0, 1.01, 0.99, 1.0, 1.005],\n            \"quantities\": [5.0, 4.98, 5.02, 5.0, 4.99],\n            \"lambda\": 0.5,\n            \"p_star\": 1.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        p_vec = np.array(case[\"prices\"])\n        q_vec = np.array(case[\"quantities\"])\n        lam = case[\"lambda\"]\n        p_star = case[\"p_star\"]\n\n        # Calculate the required sums for the normal equations.\n        T = len(p_vec)\n        sum_p = np.sum(p_vec)\n        sum_q = np.sum(q_vec)\n        sum_p_sq = np.sum(p_vec**2)\n        sum_pq = np.sum(p_vec * q_vec)\n\n        # Construct the matrix M and vector v for the linear system M*beta = v.\n        # M = X'X + lambda*I\n        # v = X'y\n        M = np.array([\n            [T + lam, sum_p],\n            [sum_p, sum_p_sq + lam]\n        ])\n        v = np.array([sum_q, sum_pq])\n\n        # Solve for the coefficients [a_hat, b_hat].\n        try:\n            coeffs = np.linalg.solve(M, v)\n            a_hat, b_hat = coeffs[0], coeffs[1]\n        except np.linalg.LinAlgError:\n            # This should not occur as M is positive definite for lambda > 0.\n            a_hat, b_hat = float('nan'), float('nan')\n\n        # Calculate the forecast quantity.\n        q_star_hat = a_hat + b_hat * p_star\n\n        # Round results to six decimal places.\n        rounded_result = [\n            round(a_hat, 6),\n            round(b_hat, 6),\n            round(q_star_hat, 6)\n        ]\n        results.append(rounded_result)\n\n    # Format the final output string to match the required format precisely.\n    # The format is [[...],[...],[...]] with no spaces.\n    outer_list_str = []\n    for inner_list in results:\n        # Format each inner list as '[x,y,z]'\n        inner_str = f\"[{','.join(f'{x:.6f}' for x in inner_list)}]\"\n        outer_list_str.append(inner_str)\n    \n    final_output_str = f\"[{','.join(outer_list_str)}]\"\n    # Python's default float-to-string conversion for .6f can sometimes produce -0.000000\n    # The problem asks for non-negative zero.\n    print(final_output_str.replace('-0.000000', '0.000000'))\n\nsolve()\n```", "id": "2394930"}, {"introduction": "函数逼近不仅仅是曲线拟合，它更是一种强大的数值分析工具。这个来自金融领域的高级练习通过用一个简单的多项式来逼近一个复杂的期权定价函数，从而证明了这一点 [@problem_id:2394969]。随后，您将对这个多项式代理模型进行微分，以高效地估计期权的风险敏感度（“Greeks”），展示了最小二乘法如何从模型中发掘更深层次的洞见。", "problem": "您的任务是，将欧式看涨期权的价格函数近似为标的资产水平的单变量函数，然后通过微分使用该近似值计算敏感性指标（“希腊字母”）。对于一份标的资产水平为 $S$、行权价为 $K$、连续复利无风险利率为 $r$（以小数表示）、波动率为 $\\sigma$（以小数表示）、到期时间为 $T$（以年为单位）的欧式看涨期权，其在 Black–Scholes 模型下的价格为\n$$\nC(S) \\;=\\; S\\,\\Phi(d_1) \\;-\\; K\\,e^{-r T}\\,\\Phi(d_2),\n$$\n其中\n$$\nd_1 \\;=\\; \\frac{\\ln(S/K) + \\left(r + \\tfrac{1}{2}\\sigma^2\\right) T}{\\sigma\\sqrt{T}}, \n\\qquad\nd_2 \\;=\\; d_1 \\;-\\; \\sigma\\sqrt{T},\n$$\n$\\Phi(\\cdot)$ 是标准正态分布的累积分布函数，$\\ln(\\cdot)$ 表示自然对数。期权的 Delta 和 Gamma 分别是价格相对于 $S$ 的一阶和二阶偏导数：\n$$\n\\Delta(S) \\;=\\; \\frac{\\partial C}{\\partial S}(S), \n\\qquad\n\\Gamma(S) \\;=\\; \\frac{\\partial^2 C}{\\partial S^2}(S).\n$$\n在 Black–Scholes 模型下，解析公式为\n$$\n\\Delta_{\\mathrm{BS}}(S) \\;=\\; \\Phi(d_1), \n\\qquad\n\\Gamma_{\\mathrm{BS}}(S) \\;=\\; \\frac{\\phi(d_1)}{S\\,\\sigma\\,\\sqrt{T}},\n$$\n其中 $\\phi(\\cdot)$ 是标准正态概率密度函数。\n\n您的任务是，对于每个指定的参数集，使用 $S$ 在规定区间上的样本点，为定价函数 $C(S)$ 构建一个 $m$ 次的最小二乘多项式逼近。然后，通过对该多项式进行一次和二次对 $S$ 的微分，在指定的评估点计算近似的 Delta 和 Gamma。最后，报告这些近似值相对于 Black–Scholes 解析 Delta 和 Gamma 的绝对误差。\n\n对于每个测试用例：\n- 在闭区间 $[S_{\\min}, S_{\\max}]$ 上构建一个包含 $n$ 个点的等距网格 $\\{S_i\\}_{i=1}^n$。\n- 使用上述 Black–Scholes 公式计算每个网格点上的精确实价格 $y_i = C(S_i)$。\n- 令 $\\mathcal{P}_m$ 表示 $S$ 的次数最多为 $m$ 的多项式集合。计算最小二乘多项式逼近 $\\hat{C}_m \\in \\mathcal{P}_m$，该逼近通过 $\\hat{C}_m$ 的系数来最小化 $\\sum_{i=1}^n \\left(y_i - \\hat{C}_m(S_i)\\right)^2$。\n- 对 $\\hat{C}_m$ 进行关于 $S$ 的微分，以获得 $\\widehat{\\Delta}_m(S) = \\frac{\\mathrm{d}}{\\mathrm{d}S}\\hat{C}_m(S)$ 和 $\\widehat{\\Gamma}_m(S) = \\frac{\\mathrm{d}^2}{\\mathrm{d}S^2}\\hat{C}_m(S)$。\n- 在评估点 $S_0$ 处，计算绝对误差 $|\\widehat{\\Delta}_m(S_0) - \\Delta_{\\mathrm{BS}}(S_0)|$ 和 $|\\widehat{\\Gamma}_m(S_0) - \\Gamma_{\\mathrm{BS}}(S_0)|$。\n\n设计细节：\n- 所有利率和波动率都必须按小数处理（例如，年化利率 $2\\%$ 以 $0.02$ 的形式输入和使用）。\n- 不涉及物理单位。此问题中没有角度。不要使用百分号表示任何答案。\n- 程序的最终输出必须是单行，包含一个由方括号括起来的、逗号分隔的结果列表。每个测试用例贡献一个包含两个浮点数的内部列表，顺序为 $[\\text{DeltaError}, \\text{GammaError}]$，每个浮点数四舍五入到六位小数。例如，包含两个测试用例的输出应如下所示：$[[0.000123,0.045678],[0.000010,0.000200]]$。\n\n测试套件（每个项目符号指定 $(K, r, \\sigma, T, S_{\\min}, S_{\\max}, n, m, S_0)$）：\n- 案例 A: $(100,\\, 0.02,\\, 0.2,\\, 0.5,\\, 50,\\, 150,\\, 101,\\, 5,\\, 100)$。\n- 案例 B: $(100,\\, 0.01,\\, 0.25,\\, 1.0,\\, 80,\\, 200,\\, 121,\\, 6,\\, 180)$。\n- 案例 C: $(100,\\, 0.03,\\, 0.05,\\, 1.0,\\, 80,\\, 120,\\, 81,\\, 5,\\, 100)$。\n- 案例 D: $(100,\\, 0.00,\\, 0.3,\\, 0.01,\\, 80,\\, 120,\\, 81,\\, 5,\\, 100)$。\n- 案例 E: $(120,\\, 0.02,\\, 0.2,\\, 1.0,\\, 60,\\, 120,\\, 121,\\, 5,\\, 60)$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的结果列表，其中每个元素是对应于案例 A 到 E 的内部列表 $[\\text{DeltaError}, \\text{GammaError}]$，每个浮点数四舍五入到六位小数。", "solution": "所述问题已经过严格验证。它要求使用多项式最小二乘拟合来数值逼近欧式看涨期权的价格函数及其前两个导数——Delta 和 Gamma。其理论基础是 Black-Scholes 模型（数理金融中的一个基本概念）和最小二乘法（数值分析中的标准工具）。所有参数、约束和目标都已足够清晰和精确地指定。所提供的测试用例完全在模型和数值方法的有效性域内。未发现任何科学或逻辑上的矛盾、歧义或信息缺失。因此，该问题被认为是有效的、适定的，且具有科学依据。我们可以着手构建解决方案。\n\n目标是将欧式看涨期权的 Black-Scholes 价格函数 $C(S)$ 近似为标的资产价格 $S$ 的一个多项式。其价格由以下公式给出\n$$\nC(S) = S\\,\\Phi(d_1) - K\\,e^{-r T}\\,\\Phi(d_2)\n$$\n其中 $K$ 是行权价，$r$ 是无风险利率，$T$ 是到期时间，$\\sigma$ 是波动率，而 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数（CDF）。$d_1$ 和 $d_2$ 项定义为\n$$\nd_1 = \\frac{\\ln(S/K) + \\left(r + \\frac{1}{2}\\sigma^2\\right) T}{\\sigma\\sqrt{T}}, \\quad d_2 = d_1 - \\sigma\\sqrt{T}\n$$\n问题要求我们生成一组包含 $n$ 个样本点 $(S_i, y_i)$ 的集合，其中网格 $\\{S_i\\}_{i=1}^n$ 在区间 $[S_{\\min}, S_{\\max}]$ 上是等距的，并且 $y_i = C(S_i)$。我们接着寻找一个次数最多为 $m$ 的多项式 $\\hat{C}_m(S)$，\n$$\n\\hat{C}_m(S) = \\sum_{j=0}^{m} p_j S^{m-j}\n$$\n该多项式能最小化残差平方和 $L = \\sum_{i=1}^n (y_i - \\hat{C}_m(S_i))^2$。这是一个经典的线性最小二乘问题。系数向量 $\\mathbf{p} = [p_0, p_1, \\dots, p_m]^T$ 可以通过求解正规方程 $(\\mathbf{X}^T \\mathbf{X})\\mathbf{p} = \\mathbf{X}^T \\mathbf{y}$ 来找到，其中 $\\mathbf{y}$ 是价格 $y_i$ 的向量，$\\mathbf{X}$ 是设计矩阵，其元素为 $X_{ij} = S_i^{m-j}$。通常采用数值稳定的算法（如基于 QR 分解的算法）来求解该系统。\n\n一旦确定了逼近多项式 $\\hat{C}_m(S)$ 的系数，我们就可以方便地计算其导数，以近似期权的敏感性指标，即“希腊字母”。Delta，$\\Delta = \\frac{\\partial C}{\\partial S}$，是关于 $S$ 的一阶导数；Gamma，$\\Gamma = \\frac{\\partial^2 C}{\\partial S^2}$，是二阶导数。这些指标的多项式近似为：\n$$\n\\widehat{\\Delta}_m(S) = \\frac{\\mathrm{d}}{\\mathrm{d}S}\\hat{C}_m(S) = \\sum_{j=0}^{m-1} (m-j) p_j S^{m-j-1}\n$$\n$$\n\\widehat{\\Gamma}_m(S) = \\frac{\\mathrm{d}^2}{\\mathrm{d}S^2}\\hat{C}_m(S) = \\sum_{j=0}^{m-2} (m-j)(m-j-1) p_j S^{m-j-2}\n$$\n然后，在指定的点 $S_0$ 处评估这些近似的希腊字母。\n\n通过将这些近似值与从 Black-Scholes 模型导出的 Delta 和 Gamma 的解析公式进行比较，来评估其准确性：\n$$\n\\Delta_{\\mathrm{BS}}(S) = \\Phi(d_1)\n$$\n$$\n\\Gamma_{\\mathrm{BS}}(S) = \\frac{\\phi(d_1)}{S\\,\\sigma\\,\\sqrt{T}}\n$$\n其中 $\\phi(\\cdot)$ 是标准正态分布的概率密度函数（PDF）。在评估点 $S_0$ 处计算绝对误差：\n$$\n\\text{DeltaError} = |\\widehat{\\Delta}_m(S_0) - \\Delta_{\\mathrm{BS}}(S_0)|\n$$\n$$\n\\text{GammaError} = |\\widehat{\\Gamma}_m(S_0) - \\Gamma_{\\mathrm{BS}}(S_0)|\n$$\n每个测试用例的计算过程包括以下步骤：生成资产价格网格，计算这些点上的精确期权价格，拟合多项式，对其进行微分，在 $S_0$ 处评估近似和解析的希腊字母，最后计算绝对误差。将使用标准的数值库来进行正态分布函数计算以及多项式拟合和微分，以确保准确性和数值稳定性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\n# language: Python\n# version: 3.12\n# libraries:\n#     - name: numpy\n#       version: 1.23.5\n#     - name: scipy\n#       version: 1.11.4\n\ndef black_scholes_call(S, K, T, r, sigma):\n    \"\"\"\n    Calculates the Black-Scholes price for a European call option.\n    Note: S can be a numpy array.\n    \"\"\"\n    # Ensure S is a float array to avoid potential type issues\n    S = np.asarray(S, dtype=float)\n    \n    # Handle the case where T is very close to zero\n    if T  1e-9:\n        return np.maximum(S - K, 0)\n        \n    # Handle the case where S is very close to zero\n    S[S  1e-9] = 1e-9\n\n    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n    return price\n\ndef black_scholes_delta(S, K, T, r, sigma):\n    \"\"\"\n    Calculates the analytical Black-Scholes Delta for a European call option.\n    \"\"\"\n    S = float(S)\n    if T  1e-9:\n        return 1.0 if S > K else 0.0\n    if S  1e-9:\n        S = 1e-9\n    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    return norm.cdf(d1)\n\ndef black_scholes_gamma(S, K, T, r, sigma):\n    \"\"\"\n    Calculates the analytical Black-Scholes Gamma for a European call option.\n    \"\"\"\n    S = float(S)\n    if T  1e-9:\n        return 0.0\n    if S  1e-9:\n        S = 1e-9\n    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    pdf_d1 = norm.pdf(d1)\n    return pdf_d1 / (S * sigma * np.sqrt(T))\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and generate the final output.\n    \"\"\"\n    # Test cases: (K, r, sigma, T, S_min, S_max, n, m, S0)\n    test_cases = [\n        (100, 0.02, 0.2, 0.5, 50, 150, 101, 5, 100),\n        (100, 0.01, 0.25, 1.0, 80, 200, 121, 6, 180),\n        (100, 0.03, 0.05, 1.0, 80, 120, 81, 5, 100),\n        (100, 0.00, 0.3, 0.01, 80, 120, 81, 5, 100),\n        (120, 0.02, 0.2, 1.0, 60, 120, 121, 5, 60),\n    ]\n\n    results = []\n    for case in test_cases:\n        K, r, sigma, T, S_min, S_max, n, m, S0 = case\n\n        # 1. Construct the grid and evaluate exact prices\n        S_grid = np.linspace(S_min, S_max, n)\n        y_grid = black_scholes_call(S_grid, K, T, r, sigma)\n\n        # 2. Compute the least-squares polynomial approximant\n        # np.polyfit returns coefficients in descending order of power\n        coeffs = np.polyfit(S_grid, y_grid, m)\n        \n        # 3. Differentiate the polynomial to get Greeks approximations\n        # np.poly1d creates a polynomial object from coefficients\n        Delta_poly = np.polyder(coeffs, 1)\n        Gamma_poly = np.polyder(coeffs, 2)\n\n        # 4. Evaluate approximated Greeks at the evaluation point S0\n        delta_approx = np.polyval(Delta_poly, S0)\n        gamma_approx = np.polyval(Gamma_poly, S0)\n\n        # 5. Evaluate analytical Greeks at S0\n        delta_exact = black_scholes_delta(S0, K, T, r, sigma)\n        gamma_exact = black_scholes_gamma(S0, K, T, r, sigma)\n\n        # 6. Compute absolute errors\n        delta_error = abs(delta_approx - delta_exact)\n        gamma_error = abs(gamma_approx - gamma_exact)\n        \n        results.append([delta_error, gamma_error])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f'[{d_err:.6f},{g_err:.6f}]' for d_err, g_err in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2394969"}]}