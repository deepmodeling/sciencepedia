{"hands_on_practices": [{"introduction": "我们的第一个实践练习将从一个经典的宏观经济学问题入手。我们将推导出一个新古典主义增长模型中的稳态资本存量 $K$ 的封闭解表达式。然后，我们将通过对模型的关键参数（如主观贴现因子 $\\beta$ 和资本折旧率 $\\delta$）进行“参数扫描”，来探索经济的长期均衡如何响应这些参数的变化。这项任务是一个理想的“易并行”问题的入门范例，因为对于每一组参数组合的计算都是完全独立的，可以同时进行而互不干扰 [@problem_id:2390013]。", "problem": "考虑一个确定的、无限期的代表性代理人经济，其中单一商品用于消费和投资。时间是离散的，由 $t \\in \\{0,1,2,\\dots\\}$ 索引。代表性家庭对消费序列 $\\{c_t\\}_{t=0}^{\\infty}$ 的偏好由预期贴现总和 $\\sum_{t=0}^{\\infty} \\beta^t u(c_t)$ 给出，其中 $\\beta \\in (0,1)$ 是主观贴现因子，而 $u(\\cdot)$ 是一个严格递增、严格凹且二阶连续可微的效用函数。假设效用函数为恒定相对风险厌恶（CRRA）形式，其系数为 $\\sigma > 0$，即当 $\\sigma \\neq 1$ 时，$u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$；当 $\\sigma = 1$ 时，$u(c) = \\log c$。生产是竞争性的，由单个企业运营，采用 Cobb-Douglas 生产技术 $y_t = A k_t^{\\alpha} n_t^{1-\\alpha}$，其中 $A = 1$，$\\alpha \\in (0,1)$，劳动供给是无弹性的 $n_t \\equiv 1$，以及物质资本 $k_t$。资本以 $\\delta \\in [0,1]$ 的速率折旧。竞争性要素价格等于其边际产品：资本租金率为 $r_t = \\alpha k_t^{\\alpha - 1}$，工资为 $w_t = (1 - \\alpha) k_t^{\\alpha}$。家庭的人均时期预算约束为 $c_t + k_{t+1} = (1 - \\delta) k_t + r_t k_t + w_t$，其中 $k_{t+1} \\ge 0$ 且 $c_t \\ge 0$。假设没有人口增长或技术增长。\n\n仅从这些基本要素和定义出发，并只使用第一性原理（例如家庭的跨期最优性条件和竞争均衡条件），在无外生增长的假设下，推导出刻画唯一正稳态资本存量 $K$ 的稳态条件，并将其表示为参数 $\\alpha$、$\\beta$ 和 $\\delta$ 的函数。然后，实现一个程序，使用此稳态条件，在保持 $\\alpha$ 固定的情况下，为一组参数对 $(\\beta,\\delta)$ 计算 $K$。\n\n你的实现应利用每个 $(\\beta,\\delta)$ 对都可以独立于其他对进行评估这一事实，这使得该计算成为模拟中的一个易并行问题。然而，你的程序必须按顺序确定性地执行，无需任何用户输入。\n\n所有计算均使用以下参数化：\n- 资本份额：$\\alpha = 0.36$。\n- 生产率：$A = 1$。\n- 劳动：$n_t \\equiv 1$。\n- 风险厌恶参数 $\\sigma$ 是任意但固定且严格为正的；根据上述假设，你的最终稳态表达式必须不依赖于 $\\sigma$。\n\n测试套件（为每对参数计算稳态资本存量 $K$）：\n- 案例1：$(\\beta,\\delta) = (0.96,0.08)$。\n- 案例2：$(\\beta,\\delta) = (0.96,0.00)$。\n- 案例3：$(\\beta,\\delta) = (0.96,1.00)$。\n- 案例4：$(\\beta,\\delta) = (0.99,0.08)$。\n- 案例5：$(\\beta,\\delta) = (0.90,0.08)$。\n- 案例6：$(\\beta,\\delta) = (0.99,0.01)$。\n- 案例7：$(\\beta,\\delta) = (0.95,0.20)$。\n- 案例8：$(\\beta,\\delta) = (0.999,0.50)$。\n\n科学真实性与可行性条件：\n- 假设对于有效的参数对，存在严格为正的稳态资本 $K > 0$ 的内部解。\n- 如果对于某个参数对，推导出的稳态条件意味着 $K$ 为非正值或未定义（例如，由于你推导的表达式中分母为非正值），你的程序应为该情况返回一个非数值（Not-a-Number）。\n\n数值与输出要求：\n- 将所有数值答案表示为无单位的实数。\n- 将每个报告的稳态资本 $K$ 四舍五入到6位小数。\n- 你的程序应生成单行输出，其中包含测试套件的结果，结果按顺序排列，形式为用方括号括起来的逗号分隔列表，且不含空格。例如：“[k1,k2,k3,k4,k5,k6,k7,k8]”。", "solution": "问题陈述经评估有效。这是现代宏观经济理论中的一个标准、良态问题，特别是关于新古典增长模型的分析。所有必需的参数、函数形式和均衡条件都已提供，不存在内部矛盾或科学不准确之处。我们开始进行推导。\n\n目标是推导代表性代理人经济中的稳态资本存量，记为 $K$。此推导分三步进行：首先，建立家庭的跨期最优性条件（欧拉方程）；其次，施加所有的人均变量都恒定的稳态条件；第三，求解得到的代数方程以得出 $K$。\n\n首先，我们构建家庭的动态优化问题。家庭选择消费序列 $\\{c_t\\}_{t=0}^{\\infty}$ 和资本序列 $\\{k_{t+1}\\}_{t=0}^{\\infty}$，以最大化其由 $\\sum_{t=0}^{\\infty} \\beta^t u(c_t)$ 给出的终生效用，并受一系列预算约束的限制。时期 $t$ 的预算约束为 $c_t + k_{t+1} = (1 - \\delta) k_t + r_t k_t + w_t$。\n\n在竞争均衡中，要素价格等于其边际产品。给定 Cobb-Douglas 生产函数 $y_t = k_t^{\\alpha}$（因为 $A=1$ 且 $n_t=1$），资本租金率为 $r_t = \\frac{\\partial y_t}{\\partial k_t} = \\alpha k_t^{\\alpha-1}$，工资率为 $w_t = y_t - r_t k_t = k_t^\\alpha - (\\alpha k_t^{\\alpha-1})k_t = (1-\\alpha)k_t^\\alpha$。将这些代入家庭的预算约束，得到 $c_t + k_{t+1} = (1 - \\delta) k_t + (\\alpha k_t^{\\alpha-1})k_t + (1-\\alpha)k_t^\\alpha = (1 - \\delta)k_t + \\alpha k_t^\\alpha + (1 - \\alpha)k_t^\\alpha = k_t^\\alpha + (1 - \\delta)k_t$。这就是经济的总资源约束。\n\n家庭的问题可以用动态规划来解决。Bellman 方程为：\n$$V(k_t) = \\max_{k_{t+1}} \\left\\{ u(k_t^\\alpha + (1-\\delta)k_t - k_{t+1}) + \\beta V(k_{t+1}) \\right\\}$$\n关于选择变量 $k_{t+1}$ 的一阶条件是：\n$$-u'(c_t) \\cdot 1 + \\beta V'(k_{t+1}) = 0 \\implies u'(c_t) = \\beta V'(k_{t+1})$$\n通过对 Bellman 方程关于状态变量 $k_t$ 求导得到的包络条件是：\n$$V'(k_t) = u'(c_t) \\left( \\frac{\\partial y_t}{\\partial k_t} + 1 - \\delta \\right) = u'(c_t) (\\alpha k_t^{\\alpha-1} + 1 - \\delta)$$\n将包络条件向前推一期得到：\n$$V'(k_{t+1}) = u'(c_{t+1}) (\\alpha k_{t+1}^{\\alpha-1} + 1 - \\delta)$$\n将这个 $V'(k_{t+1})$ 的表达式代回一阶条件，得到欧拉方程：\n$$u'(c_t) = \\beta u'(c_{t+1}) (\\alpha k_{t+1}^{\\alpha-1} + 1 - \\delta)$$\n对于指定的恒定相对风险厌恶（CRRA）效用函数 $u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$（或当 $\\sigma=1$ 时，$u(c)=\\log c$），其边际效用为 $u'(c) = c^{-\\sigma}$。欧拉方程变为：\n$$c_t^{-\\sigma} = \\beta c_{t+1}^{-\\sigma} (\\alpha k_{t+1}^{\\alpha-1} + 1 - \\delta)$$\n\n其次，我们施加稳态条件。在没有外生增长的稳态中，所有的人均变量都不随时间变化。因此，对于所有 $t$，$k_t = k_{t+1} = K$ 且 $c_t = c_{t+1} = C$。将这些条件应用于欧拉方程，我们得到：\n$$C^{-\\sigma} = \\beta C^{-\\sigma} (\\alpha K^{\\alpha-1} + 1 - \\delta)$$\n由于我们假设存在严格为正的消费 $C > 0$ 的内部解，我们可以将两边同除以 $C^{-\\sigma}$：\n$$1 = \\beta (\\alpha K^{\\alpha-1} + 1 - \\delta)$$\n这就是刻画稳态资本存量 $K$ 的基本条件。注意，风险厌恶参数 $\\sigma$ 已经消掉了，这与问题陈述的要求一致。\n\n第三，我们求解这个代数方程以得到 $K$。\n$$\\frac{1}{\\beta} = \\alpha K^{\\alpha-1} + 1 - \\delta$$\n整理各项以分离出 $K$：\n$$\\alpha K^{\\alpha-1} = \\frac{1}{\\beta} - (1 - \\delta) = \\frac{1 - \\beta(1-\\delta)}{\\beta} = \\frac{1 - \\beta + \\beta\\delta}{\\beta}$$\n$$K^{\\alpha-1} = \\frac{1 - \\beta + \\beta\\delta}{\\alpha\\beta}$$\n为了解出 $K$，我们将两边都取 $\\frac{1}{\\alpha-1}$ 次方。这等价于将底数取倒数，然后取 $\\frac{1}{1-\\alpha}$ 次方：\n$$K = \\left( \\frac{\\alpha\\beta}{1 - \\beta + \\beta\\delta} \\right)^{\\frac{1}{1-\\alpha}}$$\n这就是唯一的正稳态资本存量的最终表达式。\n\n为了进行计算，我们使用给定的固定参数 $\\alpha = 0.36$。因此，指数为 $\\frac{1}{1 - 0.36} = \\frac{1}{0.64} = 1.5625$。幂运算的底数为 $\\frac{\\alpha\\beta}{1 - \\beta + \\beta\\delta}$。要使 $K$ 成为一个正实数，底数必须为正。给定 $\\alpha \\in (0,1)$ 和 $\\beta \\in (0,1)$，分子 $\\alpha\\beta$ 始终为正。分母为 $(1-\\beta) + \\beta\\delta$。由于 $1-\\beta > 0$ 且 $\\beta\\delta \\ge 0$（因为 $\\delta \\in [0,1]$），分母始终严格为正。因此，对于测试套件中提供的所有有效参数对，稳态资本存量 $K$ 都是正且良定义的，预计不会出现非数值（Not-a-Number）结果。\n\n实现过程将对每一个指定的 $(\\beta, \\delta)$ 对应用此公式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the steady-state capital stock for a neoclassical growth model\n    for a given set of parameters.\n    \"\"\"\n    \n    # Fixed parameters from the problem statement.\n    # Capital share in production.\n    alpha = 0.36\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple (beta, delta).\n    test_cases = [\n        (0.96, 0.08),   # Case 1\n        (0.96, 0.00),   # Case 2\n        (0.96, 1.00),   # Case 3\n        (0.99, 0.08),   # Case 4\n        (0.90, 0.08),   # Case 5\n        (0.99, 0.01),   # Case 6\n        (0.95, 0.20),   # Case 7\n        (0.999, 0.50),  # Case 8\n    ]\n\n    results = []\n    \n    # The exponent in the final expression for the steady-state capital stock K.\n    exponent = 1.0 / (1.0 - alpha)\n\n    # Iterate through each parameter set (beta, delta)\n    for beta, delta in test_cases:\n        # The steady-state capital stock K is given by the formula:\n        # K = ( (alpha * beta) / (1 - beta + beta * delta) ) ^ (1 / (1 - alpha))\n        \n        # Calculate the denominator of the base.\n        denominator = 1.0 - beta + beta * delta\n        \n        # As reasoned in the solution, the denominator for the given parameter ranges\n        # is always positive. Thus, we do not need to explicitly handle division by zero\n        # or non-positive bases.\n        \n        # Calculate the base of the exponentiation.\n        base = (alpha * beta) / denominator\n        \n        # Calculate the steady-state capital stock K.\n        k_steady_state = np.power(base, exponent)\n        \n        # Round the result to 6 decimal places as required.\n        result_rounded = round(k_steady_state, 6)\n        \n        results.append(result_rounded)\n\n    # Format the final output string as a comma-separated list in brackets.\n    # The map(str, ...) ensures each number is converted to a string before joining.\n    # No spaces are included between the elements, as per the output format requirement.\n    output_string = f\"[{','.join(map(str, results))}]\"\n    \n    # Final print statement in the exact required format.\n    print(output_string)\n\n# Execute the main function.\nsolve()\n```", "id": "2390013"}, {"introduction": "在第二个练习中，我们将复杂度提升一步，转向一个基于代理人的微观经济学模型。在这里，每个独立的计算任务不再是简单的公式求解，而是一次完整的蒙特卡洛模拟，用以分析全民基本收入（UBI）政策对劳动力供给的影响。通过为不同的政策设定（UBI 的数额 $y$ 和税率 $\\tau$）运行独立的模拟，我们可以评估不同政策组合的宏观效应。这个练习展示了如何在一个并行计算框架下，利用模拟来进行有效的政策分析 [@problem_id:2390040]。", "problem": "考虑一个简单的基于主体的劳动供给模型，该模型旨在对全民基本收入 (UBI) 和劳动收入税率进行易于并行的参数扫描。每个主体选择劳动供给以最大化其静态效用，同时受线性预算约束和外生收入部分的影响。经济环境、分布和决策问题定义如下。\n\n- 每个主体的决策变量是劳动供给 $l \\in [0,1]$。\n- 对于给定的全民基本收入 (UBI) 金额 $y \\ge 0$ 和税率 $\\tau \\in [0,1]$（表示为小数而非百分比），生产率为 $w_i > 0$ 且负效用参数为 $\\phi_i > 0$ 的主体 $i$ 拥有消费 $c$ 和时期效用：\n  - 预算约束：$c = (1 - \\tau)\\, w_i\\, l + y + \\varepsilon$。\n  - 效用：$U_i(l; y,\\tau,w_i,\\phi_i,\\varepsilon) = \\log(c) - \\frac{\\phi_i}{2}\\, l^2$。\n- 个体特定的生产率 $w_i$ 和负效用参数 $\\phi_i$ 在主体间是异质的，并且是来自对数正态分布的独立同分布抽样，其对应的正态分布参数分别为 $(\\mu_w,\\sigma_w)$ 和 $(\\mu_\\phi,\\sigma_\\phi)$。具体而言，$w_i \\sim \\operatorname{Lognormal}(\\mu_w,\\sigma_w^2)$ 且 $\\phi_i \\sim \\operatorname{Lognormal}(\\mu_\\phi,\\sigma_\\phi^2)$。\n- 非劳动收入冲击 $\\varepsilon$ 在各主体和模拟重复中是独立同分布的，服从指数分布 $\\varepsilon \\sim \\operatorname{Exponential}(\\lambda)$，其均值 $\\mathbb{E}[\\varepsilon] = 1/\\lambda$ 严格为正。\n\n对于任意给定的配对 $(y,\\tau)$，将主体的最优化问题定义为：选择 $l \\in [0,1]$ 以最大化 $U_i(l; y,\\tau,w_i,\\phi_i,\\varepsilon)$。\n\n蒙特卡洛实验设定：\n- 主体数量：$N = 10000$。\n- 每个主体的冲击重复次数：$K = 16$。\n- 分布参数：$\\mu_w = 0$, $\\sigma_w = 0.5$；$\\mu_\\phi = 0$, $\\sigma_\\phi = 0.5$。\n- 指数冲击均值：$\\mathbb{E}[\\varepsilon] = m_\\varepsilon = 0.5$（因此 $\\lambda = 1/m_\\varepsilon$）。\n- 将每个 $(y,\\tau)$ 配对独立处理，以使参数扫描是易于并行的。为每个配对使用独立的随机数生成器种子，以确保结果可复现且与评估顺序无关。使用基础种子 $12345$，对于第 $j$ 个测试用例（索引从零开始），使用种子 $12345 + j$。\n\n任务：\n- 对于下面测试套件中的每个 $(y,\\tau)$ 配对，模拟上述经济体并计算期望劳动供给 $\\mathbb{E}[l^\\star(y,\\tau)]$，其中 $l^\\star(y,\\tau)$ 表示在给定 $(y,\\tau)$、主体类型 $(w_i,\\phi_i)$ 以及抽样 $\\varepsilon$ 的情况下的最优劳动供给。期望值是在主体异质性和冲击的联合分布上计算的，通过蒙特卡洛实验近似为 $N$ 个主体和 $K$ 次冲击的平均值。\n- 对每个主体和每次冲击抽样，在 $l \\in [0,1]$ 上精确求解效用最大化问题；不要对 $l$ 进行离散化。如果存在内部解，则使用该解；否则，比较边界 $l=0$ 和 $l=1$ 处的目标函数值，并选择使其最大化的值。\n\n测试套件（对 UBI $y$ 和税率 $\\tau$ 的参数扫描）：\n1. $(y,\\tau) = (0.0, 0.0)$\n2. $(y,\\tau) = (0.0, 1.0)$\n3. $(y,\\tau) = (1.0, 0.0)$\n4. $(y,\\tau) = (1.0, 0.5)$\n5. $(y,\\tau) = (2.0, 0.8)$\n6. $(y,\\tau) = (3.0, 0.0)$\n7. $(y,\\tau) = (0.0, 0.8)$\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个 Python 风格的列表，按所列顺序包含上述测试用例的 $\\mathbb{E}[l^\\star(y,\\tau)]$ 的蒙特卡洛估计值。每个值必须四舍五入到恰好 $6$ 位小数。例如，一个有效的输出可能如下所示：\n  - $[\\dots]$ 其中每个条目在小数点后恰好有 $6$ 位数字。\n- 不涉及物理单位或角度。税率必须作为小数处理，而非百分比。\n\n实现约束：\n- 参数扫描必须以易于并行的方式处理：每个 $(y,\\tau)$ 用例都使用其自身的随机种子进行独立计算。程序必须是完全自包含的，并且不需要用户输入。", "solution": "首先，将对问题进行严格的验证过程。\n\n### 步骤 1：提取给定条件\n问题陈述提供了以下定义和参数：\n\n- **主体决策问题**：\n    - 决策变量：劳动供给 $l \\in [0,1]$。\n    - 预算约束：$c = (1 - \\tau)\\, w_i\\, l + y + \\varepsilon$。\n    - 效用函数：$U_i(l; y,\\tau,w_i,\\phi_i,\\varepsilon) = \\log(c) - \\frac{\\phi_i}{2}\\, l^2$。\n    - 政策变量：全民基本收入 (UBI) $y \\ge 0$，税率 $\\tau \\in [0,1]$。\n    - 主体特定参数：生产率 $w_i > 0$，劳动负效用参数 $\\phi_i > 0$。\n    - 外生冲击：非劳动收入冲击 $\\varepsilon$。\n\n- **随机环境**：\n    - 生产率分布：$w_i \\sim \\operatorname{Lognormal}(\\mu_w, \\sigma_w^2)$，其中 $\\mu_w = 0, \\sigma_w = 0.5$。\n    - 负效用参数分布：$\\phi_i \\sim \\operatorname{Lognormal}(\\mu_\\phi, \\sigma_\\phi^2)$，其中 $\\mu_\\phi = 0, \\sigma_\\phi = 0.5$。\n    - 冲击分布：$\\varepsilon \\sim \\operatorname{Exponential}(\\lambda)$，均值 $\\mathbb{E}[\\varepsilon] = m_\\varepsilon = 0.5$，因此 $\\lambda = 1/m_\\varepsilon = 2$。\n\n- **蒙特卡洛实验设定**：\n    - 主体数量：$N = 10000$。\n    - 每个主体的冲击重复次数：$K = 16$。\n    - 随机数生成：基础种子为 $12345$。对于第 $j$ 个测试用例（索引从0开始），种子为 $12345 + j$。\n\n- **任务**：\n    - 对于每个给定的 $(y, \\tau)$ 配对，计算期望最优劳动供给 $\\mathbb{E}[l^\\star(y,\\tau)]$。\n    - 期望值通过 $N \\times K$ 次模拟的样本均值来近似。\n    - $l$ 的最优化问题必须在连续域 $[0,1]$ 上进行解析求解。\n\n- **测试套件**：\n    1. $(y,\\tau) = (0.0, 0.0)$\n    2. $(y,\\tau) = (0.0, 1.0)$\n    3. $(y,\\tau) = (1.0, 0.0)$\n    4. $(y,\\tau) = (1.0, 0.5)$\n    5. $(y,\\tau) = (2.0, 0.8)$\n    6. $(y,\\tau) = (3.0, 0.0)$\n    7. $(y,\\tau) = (0.0, 0.8)$\n\n### 步骤 2：使用提取的给定条件进行验证\n根据既定标准评估问题的有效性。\n\n- **科学依据**：该模型是微观经济学理论中一个标准的、尽管经过简化的静态劳动供给模型。对消费使用对数效用，对劳动使用二次负效用是一种常见且易于理解的设定（例如，King-Plosser-Rebelo 偏好）。所选择的分布（用于持续异质性的对数正态分布，用于冲击的指数分布）在计算经济学中是标准方法。该问题牢固地植根于已确立的经济学原理。\n\n- **适定性 (Well-Posed)**：主体的最优化问题是在紧集 $l \\in [0,1]$ 上最大化一个连续效用函数。为使 $\\log(c)$ 有定义，效用函数的参数 $c$ 必须为正。给定 $w_i > 0$, $\\phi_i > 0$, $y \\ge 0$, $\\tau \\in [0,1]$, $l \\in [0,1]$，且 $\\varepsilon$ 是从指数分布中抽取的（因此 $\\varepsilon \\ge 0$），消费 $c = (1-\\tau)w_i l + y + \\varepsilon$ 是一些非负项的和。由于 $w_i$ 和 $\\varepsilon$ 是从连续分布中抽取的，它们恰好为零的概率为零。因此，几乎必然可以保证 $c > 0$，使得对数函数有明确定义。效用函数 $U(l)$ 对于 $l$ 是严格凹的，因为它是 一个凹函数（$\\log(c)$，是 $l$ 的线性函数的凹函数）与另一个凹函数 ($-\\frac{\\phi_i}{2}l^2$) 的和。在紧凸集上最大化一个严格凹函数存在唯一解。因此，该问题是适定的。\n\n- **客观性**：该问题以数学精度进行了规定。所有术语都有定义，参数也被赋予了明确的值。没有主观或含糊的语言。\n\n该问题没有表现出任何诸如科学上不健全、不完整、矛盾或不可行之类的缺陷。\n\n### 步骤 3：结论与行动\n问题是**有效的**。将着手制定解决方案。\n\n### 求解推导\n\n问题的核心是通过求解以下最优化问题来找到一个主体的最优劳动供给 $l^\\star$，针对每一组参数 $(y, \\tau, w_i, \\phi_i, \\varepsilon)$：\n$$\n\\max_{l \\in [0,1]} U(l) = \\log((1-\\tau)w_i l + y + \\varepsilon) - \\frac{\\phi_i}{2}l^2\n$$\n\n为找到内部解，我们计算效用函数关于 $l$ 的一阶导数并将其设为零。这是一阶条件 (FOC)。\n令 $W_i \\equiv (1-\\tau)w_i$ 为税后工资率，令 $Y_{i} \\equiv y + \\varepsilon$ 为非劳动收入部分。效用函数变为 $U(l) = \\log(W_i l + Y_i) - \\frac{\\phi_i}{2}l^2$。一阶条件为：\n$$\n\\frac{\\partial U}{\\partial l} = \\frac{W_i}{W_i l + Y_i} - \\phi_i l = 0\n$$\n这假定存在内部解 $l \\in (0,1)$。整理各项得：\n$$\n\\frac{W_i}{W_i l + Y_i} = \\phi_i l\n$$\n$$\nW_i = \\phi_i l (W_i l + Y_i)\n$$\n$$\nW_i = \\phi_i W_i l^2 + \\phi_i Y_i l\n$$\n这可以写成关于 $l$ 的二次方程：\n$$\n(\\phi_i W_i) l^2 + (\\phi_i Y_i) l - W_i = 0\n$$\n其形式为 $al^2 + bl + c = 0$，系数为 $a = \\phi_i W_i$，$b = \\phi_i Y_i$ 和 $c = -W_i$。\n\n当 $\\tau=1$ 时会出现一个特殊情况。此时，$W_i = (1-1)w_i = 0$。二次方程的系数将变得不确定。我们必须回到一阶条件。如果 $W_i=0$，一阶条件简化为 $-\\phi_i l = 0$，这意味着 $l=0$。这很直观：如果劳动收入被 100% 征税，就没有工作的动机。因此，对于 $\\tau=1$，最优劳动供给为 $l^\\star = 0$。\n\n对于 $\\tau < 1$，我们有 $W_i > 0$（因为 $w_i > 0$）。我们可以使用二次公式求解 $l$：\n$$\nl_{int} = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} = \\frac{-\\phi_i Y_i \\pm \\sqrt{(\\phi_i Y_i)^2 - 4(\\phi_i W_i)(-W_i)}}{2\\phi_i W_i}\n$$\n$$\nl_{int} = \\frac{-\\phi_i Y_i \\pm \\sqrt{\\phi_i^2 Y_i^2 + 4\\phi_i W_i^2}}{2\\phi_i W_i}\n$$\n由于劳动供给 $l$ 不能为负，我们必须取正根：\n$$\nl_{int} = \\frac{-\\phi_i Y_i + \\sqrt{\\phi_i^2 Y_i^2 + 4\\phi_i W_i^2}}{2\\phi_i W_i}\n$$\n为了更好的数值稳定性，可以简化此公式：\n$$\nl_{int} = -\\frac{Y_i}{2W_i} + \\sqrt{\\left(\\frac{Y_i}{2W_i}\\right)^2 + \\frac{1}{\\phi_i}}\n$$\n该值 $l_{int}$ 代表无约束的最优劳动供给。然而，选择被约束在区间 $[0,1]$ 内。效用函数是严格凹的，这意味着约束最优解 $l^\\star$ 可以通过简单地将无约束最优解“钳位”到可行区间来获得：\n- 如果 $l_{int} < 0$，函数在 $[0,1]$ 上是递减的，所以 $l^\\star = 0$。\n- 如果 $l_{int} > 1$，函数在 $[0,1]$ 上是递增的，所以 $l^\\star = 1$。\n- 如果 $0 \\le l_{int} \\le 1$，无约束最优解是可行的，所以 $l^\\star = l_{int}$。\n\n这可以简洁地表示为 $l^\\star = \\max(0, \\min(l_{int}, 1))$。\n\n### 蒙特卡洛模拟算法\n对于每个测试用例 $(y, \\tau)$，期望劳动供给 $\\mathbb{E}[l^\\star]$ 通过大量模拟主体和冲击的样本均值来近似。对于索引为 $j$ 的每个测试用例 $(y_j, \\tau_j)$ 的过程如下：\n\n1.  **设置种子**：使用种子 $12345 + j$ 初始化随机数生成器，以确保跨测试用例的可复现性和独立性。\n2.  **生成异质性**：从 $\\operatorname{Lognormal}(\\mu_w, \\sigma_w^2)$ 中抽取 $N = 10000$ 个独立的主体生产率值 $\\{w_i\\}_{i=1}^N$。从 $\\operatorname{Lognormal}(\\mu_\\phi, \\sigma_\\phi^2)$ 中抽取 $N = 10000$ 个独立的负效用参数值 $\\{\\phi_i\\}_{i=1}^N$。\n3.  **生成冲击**：对于每个主体 $i$，从 $\\operatorname{Exponential}(\\lambda)$ 中抽取 $K = 16$ 个独立的收入冲击值 $\\{\\varepsilon_{ik}\\}_{k=1}^K$。这总共会产生 $N \\times K$ 个冲击。\n4.  **计算最优劳动**：对于 $N \\times K$ 个 $(w_i, \\phi_i, \\varepsilon_{ik})$ 组合中的每一个：\n    *   如果 $\\tau_j = 1$，则设 $l^\\star_{ik} = 0$。\n    *   如果 $\\tau_j < 1$，则计算 $W_i = (1-\\tau_j)w_i$ 和 $Y_{ik} = y_j + \\varepsilon_{ik}$。然后使用推导出的公式计算无约束最优解 $l_{int}$。最后，找到约束最优解 $l^\\star_{ik} = \\max(0, \\min(l_{int}, 1))$。\n5.  **估计期望值**：计算所有计算出的最优劳动供给值的样本均值：\n$$\n\\mathbb{E}[l^\\star(y_j, \\tau_j)] \\approx \\frac{1}{N \\cdot K} \\sum_{i=1}^{N} \\sum_{k=1}^{K} l^\\star_{ik}\n$$\n对测试套件中的每个 $(y, \\tau)$ 配对重复此过程。使用 `numpy` 的向量化实现对此任务非常高效，因为它通过对随机数数组进行操作，避免了对主体和冲击的显式循环。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the expected labor supply in an agent-based model\n    across a parameter sweep of UBI (y) and tax rate (tau).\n    \"\"\"\n\n    # Monte Carlo experiment specification\n    N_AGENTS = 10000\n    K_SHOCKS = 16\n    \n    # Distribution parameters\n    MU_W, SIGMA_W = 0.0, 0.5\n    MU_PHI, SIGMA_PHI = 0.0, 0.5\n    MEAN_EPSILON = 0.5  # This is the scale parameter 1/lambda for np.random.exponential\n    \n    BASE_SEED = 12345\n\n    # Test suite of (y, tau) pairs\n    test_cases = [\n        (0.0, 0.0),  # case 0\n        (0.0, 1.0),  # case 1\n        (1.0, 0.0),  # case 2\n        (1.0, 0.5),  # case 3\n        (2.0, 0.8),  # case 4\n        (3.0, 0.0),  # case 5\n        (0.0, 0.8),  # case 6\n    ]\n\n    results = []\n\n    for j, (y, tau) in enumerate(test_cases):\n        # Set seed for reproducibility for this specific test case\n        seed = BASE_SEED + j\n        rng = np.random.default_rng(seed)\n\n        # Generate agent heterogeneity parameters (w_i, phi_i)\n        # w_i ~ Lognormal(mu_w, sigma_w^2)\n        w = rng.lognormal(mean=MU_W, sigma=SIGMA_W, size=N_AGENTS)\n        # phi_i ~ Lognormal(mu_phi, sigma_phi^2)\n        phi = rng.lognormal(mean=MU_PHI, sigma=SIGMA_PHI, size=N_AGENTS)\n\n        # Handle the special case of 100% tax rate\n        if tau == 1.0:\n            # If labor income is taxed at 100%, optimal labor is always 0.\n            expected_l_star = 0.0\n        else:\n            # Generate idiosyncratic shocks for each agent and replication\n            # epsilon ~ Exponential(lambda) where mean = 1/lambda\n            # Scale parameter for numpy's exponential is the mean.\n            epsilon = rng.exponential(scale=MEAN_EPSILON, size=(N_AGENTS, K_SHOCKS))\n\n            # Reshape 1D agent-specific arrays to (N_AGENTS, 1) for broadcasting\n            w_bc = w.reshape(-1, 1)\n            phi_bc = phi.reshape(-1, 1)\n\n            # Calculate parameters for the utility maximization problem\n            # W is post-tax wage rate\n            W = (1.0 - tau) * w_bc\n            # Y is non-labor income\n            Y = y + epsilon\n            \n            # Using the simplified and numerically stable formula for the interior solution:\n            # l_int = -Y/(2W) + sqrt((Y/(2W))^2 + 1/phi)\n            Z = Y / (2.0 * W)\n            phi_inv = 1.0 / phi_bc\n            \n            # The calculation is vectorized across all agents and shocks\n            l_int = -Z + np.sqrt(Z**2 + phi_inv)\n            \n            # The optimal labor supply l_star must be in [0, 1].\n            # We clamp the interior solution to this interval.\n            l_star = np.clip(l_int, 0.0, 1.0)\n            \n            # The expectation is the mean over all N_AGENTS*K_SHOCKS simulations\n            expected_l_star = np.mean(l_star)\n        \n        results.append(expected_l_star)\n\n    # Format the results to exactly 6 decimal places as strings\n    formatted_results = [f\"{res:.6f}\" for res in results]\n\n    # Print the final output in the required format\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2390040"}, {"introduction": "最后一个实践练习将我们带入运筹管理和企业决策的领域。我们将模拟供应链中著名的“牛鞭效应”（bullwhip effect），即需求变异性沿供应链向上游逐级放大的现象。本练习的目标是比较零售商采用不同预测策略对整个供应链稳定性的影响。每个预测策略都构成一个独立的动态模拟场景，这使其成为另一个典型的易并行问题，展示了并行计算在比较和优化商业策略中的巨大潜力 [@problem_id:2389983]。", "problem": "编写一个完整、可运行的程序，模拟在几种不同的零售商预测规则下，串行多级供应链中的牛鞭效应。该供应链有 $4$ 个层级，索引为 $e \\in \\{0,1,2,3\\}$，其中 $e=0$ 是零售商，$e=1$ 是批发商，$e=2$ 是分销商，$e=3$ 是工厂。时间是离散的，以周期 $t=1,2,\\dots,T$ 计。每个层级都采用周期性盘点、基础库存策略。所有层级的提前期都是确定性的且相同，对于所有 $e$ 都有 $L_e=L$，其中 $L=2$ 个周期。\n\n外生客户需求 $D_t$ 在每个周期到达零售商 ($e=0$)。外生需求过程是独立同分布的，服从均值为 $\\lambda$ 的泊松分布，即 $D_t \\sim \\text{Poisson}(\\lambda)$，其中 $\\lambda=20$。使用以种子 $20240501$ 初始化的伪随机数生成器，生成一个单一的需求实现 $\\{D_t\\}_{t=1}^T$，并在所有测试案例中重复使用。所有其他层级 $e \\ge 1$ 在周期 $t$ 面临的需求，是其紧邻的下游层级在同一周期下的订单，即 $X_{e,t} = Q_{e-1,t}$。零售商观测到的需求定义为 $X_{0,t} = D_t$。\n\n在每个周期 $t$ 内，事件按以下顺序发生，并从下游到上游（从 $e=0$到 $e=3$）进行处理：\n- 层级 $e$ 在 $L$ 个周期前订购的货物在本周期初到达，并计入现有库存。具体而言，在周期 $t$ 到达层级 $e$ 的数量等于其自身的订单 $Q_{e,t-L}$（如果 $t-L \\ge 1$），否则为 $0$。没有产能限制或供应短缺；到货量等于计划数量。\n- 层级 $e$ 观测其周期- $t$ 的需求 $X_{e,t}$，对于 $e=0$，$X_{e,t}$ 等于 $D_t$；对于 $e \\ge 1$，$X_{e,t}$ 等于 $Q_{e-1,t}$。需求从现有库存中满足；任何未满足的需求都将完全缺货并延期处理。\n- 每个层级根据刚刚观测到的 $X_{e,t}$ 更新其对平均需求的预测。\n- 每个层级计算其基础库存目标 $S_{e,t}$ 并下达订单 $Q_{e,t}$，使其库存头寸等于该目标，同时订单量须为非负数。库存头寸为 $IP_{e,t} = \\text{现有库存}_{e,t} + \\text{在途库存}_{e,t} - \\text{缺货量}_{e,t}$。目标是 $S_{e,t} = L \\cdot F_{e,t}$，其中 $F_{e,t}$ 是对未来一个周期的平均需求的当前预测。下达的订单是 $Q_{e,t}=\\max\\{0,\\, S_{e,t} - IP_{e,t}\\}$。订单 $Q_{e,t}$ 将在 $L$ 个周期后，即在周期 $t+L$开始时到达层级 $e$。\n\n所有层级开始时现有库存和缺货量均为零，且管道为空（没有待收的在途订单）。所有层级 $e$ 的预测都初始化为 $F_{e,0}=\\lambda$。对于指数平滑法，在观测到 $X_{e,t}$ 之后、计算 $Q_{e,t}$ 之前，更新遵循 $F_{e,t} \\leftarrow \\alpha \\cdot X_{e,t} + (1-\\alpha)\\cdot F_{e,t-1}$。对于窗口长度为 $k$ 的移动平均法，在观测到 $X_{e,t}$ 后的预测是该层级最近 $\\min\\{k,t\\}$ 个观测需求的算术平均值，即 $F_{e,t}=\\frac{1}{m}\\sum_{j=0}^{m-1} X_{e,t-j}$，其中 $m=\\min\\{k,t\\}$。\n\n只有零售商的预测方法在不同测试案例中有所变化；所有上游层级 $e \\ge 1$ 均使用平滑参数为 $\\alpha_{\\text{up}}=0.5$ 的指数平滑法。零售商的预测方法选项定义了测试套件。使用 $T=3000$ 个周期的总时长，并在计算统计数据时舍弃最初 $B=500$ 个周期的 burn-in（预热）数据。对于每个测试案例，为每个层级 $e \\in \\{0,1,2,3\\}$ 计算牛鞭比率\n$$\nB_e \\;=\\;\\frac{\\operatorname{Var}\\left(Q_{e,t}\\,:\\,t=B+1,\\dots,T\\right)}{\\operatorname{Var}\\left(D_t\\,:\\,t=B+1,\\dots,T\\right)},\n$$\n其中方差是分母为 $n-1$ 的无偏样本方差。\n\n测试套件（每项指定零售商的预测规则及其参数）：\n- 案例 1：移动平均法，窗口 $k=5$。\n- 案例 2：移动平均法，窗口 $k=1$。\n- 案例 3：指数平滑法，$\\alpha=0.2$。\n- 案例 4：指数平滑法，$\\alpha=0.9$。\n\n你的程序必须：\n- 使用种子 $20240501$ 生成一个单一的外生需求路径 $\\{D_t\\}_{t=1}^T$，并在所有案例中重复使用。\n- 对每个测试案例，按规定运行模拟，并计算向量 $\\left[B_0,B_1,B_2,B_3\\right]$。\n- 将每个牛鞭比率四舍五入到 $4$ 位小数。\n\n最终输出格式：你的程序应生成单行输出，包含一个由列表组成的逗号分隔列表，不含空格。每个内部列表对应上述顺序中的一个测试案例，并包含四个四舍五入后的牛鞭比率（对应 $e=0,1,2,3$）。例如，打印的行必须如下所示\n[[b00,b01,b02,b03],[b10,b11,b12,b13],[b20,b21,b22,b23],[b30,b31,b32,b33]]\n其中 $b_{ij}$ 是四舍五入到 $4$ 位小数的十进制数。", "solution": "牛鞭效应量化了订单变异性在供应链中向上游移动时被放大的程度。在采用周期性盘点、订货点策略和确定性提前期的情况下，每个层级的基本状态包括现有库存、缺货量以及由其过去订单创建的计划到货管道。外生随机性来自零售商的客户需求 $D_t$，此处指定为 $D_t \\sim \\text{Poisson}(\\lambda)$，其中 $\\lambda=20$。\n\n我们设置了 $4$ 个层级，索引为 $e \\in \\{0,1,2,3\\}$，它们具有相同的提前期 $L_e=L=2$。在周期 $t$ 内，处理过程从下游向上游进行，以确保上游层级观测到的需求是其紧邻下游层级在同一周期内下的订单。具体来说，$X_{0,t}=D_t$，而对于 $e \\ge 1$，$X_{e,t}=Q_{e-1,t}$。这个顺序在每个周期中产生了一系列明确定义的事件：\n1. 到货：如果 $t-L \\ge 1$，数量为 $Q_{e,t-L}$ 的货物会到达层级 $e$，这反映了确定性的提前期 $L$。这些到货会加入现有库存。由于供应不受限制且等于计划到货量，上游的产能或拥堵不会干扰动态过程，因此预测的信息效应被隔离开来。\n2. 需求实现与满足：层级 $e$ 观测到 $X_{e,t}$。它会尽力从现有库存中满足需求，任何不足部分都会被缺货处理。设 $\\text{on\\_hand}_{e,t}$ 和 $\\text{backorders}_{e,t}$ 表示在周期 $t$ 订货前的状态，并设已实现的需求为 $x=X_{e,t}$，那么满足的数量为 $\\min\\{\\text{on\\_hand}_{e,t},x\\}$，缺货增量为 $x-\\min\\{\\text{on\\_hand}_{e,t},x\\}$。\n3. 预测更新：每个层级都维持一个对平均需求的预测 $F_{e,t}$。对于平滑参数为 $\\alpha \\in (0,1]$ 的指数平滑法，\n$$\nF_{e,t}\\leftarrow \\alpha X_{e,t} + (1-\\alpha)F_{e,t-1}.\n$$\n对于窗口长度为 $k \\in \\mathbb{N}$ 的移动平均法，在观测到 $X_{e,t}$ 后的预测是\n$$\nF_{e,t} \\;=\\; \\frac{1}{m}\\sum_{j=0}^{m-1} X_{e,t-j},\\quad m=\\min\\{k,t\\}.\n$$\n初始预测为 $F_{e,0}=\\lambda$。只有零售商的预测方法在各测试案例间有所不同；所有上游层级都使用平滑参数为 $\\alpha_{\\text{up}}=0.5$ 的指数平滑法。\n4. 订货点决策：库存头寸为\n$$\nIP_{e,t} \\;=\\; \\text{现有库存}_{e,t} + \\text{在途库存}_{e,t} - \\text{缺货量}_{e,t},\n$$\n其中 $\\text{on\\_order}_{e,t}$ 是层级 $e$ 在未来 $L$ 个周期内的计划到货总和。基础库存目标是\n$$\nS_{e,t} \\;=\\; L \\cdot F_{e,t},\n$$\n这是在没有安全库存情况下的预期提前期需求。下达的订单是\n$$\nQ_{e,t} \\;=\\; \\max\\{0,\\; S_{e,t} - IP_{e,t}\\}.\n$$\n该订单被添加到层级 $e$ 管道的末端，并将在 $L$ 个周期后到达。\n\n所有层级开始时都为空管道、零现有库存和零缺货量。通过在总时长 $T=3000$ 个周期中计算统计数据时丢弃前 $B=500$ 个周期的数据，可以减轻由空初始条件引起的初始瞬态效应。所有测试案例都使用相同的外生需求路径 $\\{D_t\\}_{t=1}^T$，以隔离零售商预测规则的影响。\n\n为衡量牛鞭效应，对每个层级 $e$，我们计算订单序列 $\\{Q_{e,t}\\}_{t=B+1}^T$ 的无偏样本方差，并将其除以外生客户需求 $\\{D_t\\}_{t=B+1}^T$ 的无偏样本方差：\n$$\nB_e \\;=\\;\\frac{\\operatorname{Var}\\left(Q_{e,t}\\,:\\,t=B+1,\\dots,T\\right)}{\\operatorname{Var}\\left(D_t\\,:\\,t=B+1,\\dots,T\\right)}.\n$$\n分子和分母使用分母为 $n-1$ 的标准无偏估计量。$B_e>1$ 的值表明，层级 $e$ 的变异性相对于外生客户需求有所放大，这是牛鞭效应的典型特征。更平滑的预测（例如，较小 $\\alpha$ 值的指数平滑法或较大 $k$ 值的移动平均法）通常会减少订单的变异性，而反应更灵敏的预测（例如， $k=1$ 的移动平均法或 $\\alpha$ 接近 $1$ 的指数平滑法）则倾向于增加订单变异性，从而提高牛鞭比率，尤其是在上游。\n\n该程序精确地实现了上述动态系统，使用种子 $20240501$ 生成了指定的需求路径，使用相同的外生路径独立模拟每个测试案例，计算每个案例中四个层级（$e=0,1,2,3$）的牛鞭比率，将每个比率四舍五入到 $4$ 位小数，并按要求格式打印单行结果列表：\n[[b00,b01,b02,b03],[b10,b11,b12,b13],[b20,b21,b22,b23],[b30,b31,b32,b33]]。\n每个测试案例都与其他案例相互独立，因此可以单独评估而没有案例间的交互，这反映了该任务的易并行特性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_case(demand_path, method, param, T, burn_in, L, lam, alpha_up):\n    \"\"\"\n    Simulate the 4-echelon supply chain for one retailer forecasting case.\n    demand_path: numpy array of length T with exogenous customer demand for the retailer.\n    method: 'MA' or 'ES' for retailer's forecasting method.\n    param: window k for MA (int) or alpha for ES (float).\n    Returns list of 4 bullwhip ratios [B0, B1, B2, B3].\n    \"\"\"\n    E = 4  # number of echelons: 0=retailer,1=wholesaler,2=distributor,3=factory\n    orders = np.zeros((E, T), dtype=float)\n    on_hand = np.zeros(E, dtype=float)\n    backorders = np.zeros(E, dtype=float)\n    # Pipelines: each is a list of length L storing scheduled arrivals for future periods\n    pipelines = [([0.0] * L) for _ in range(E)]\n    # Forecasts initialized to lambda\n    forecasts = np.full(E, float(lam), dtype=float)\n    # Moving average buffers per echelon (retailer may use MA; upstream use ES)\n    ma_buffers = [[] for _ in range(E)]\n\n    for t in range(T):\n        downstream_order = None  # will hold Q_{e-1,t} as demand for echelon e\n        for e in range(E):\n            # 1) Arrivals\n            if L > 0:\n                arrival = pipelines[e].pop(0)\n                on_hand[e] += arrival\n            else:\n                arrival = 0.0\n\n            # 2) Demand observed for echelon e\n            if e == 0:\n                x = float(demand_path[t])\n            else:\n                x = float(downstream_order) if downstream_order is not None else 0.0\n\n            # Fulfill demand from on-hand; backorder any unmet\n            fulfilled = min(on_hand[e], x)\n            on_hand[e] -= fulfilled\n            unmet = x - fulfilled\n            backorders[e] += unmet\n\n            # 3) Forecast update\n            if e == 0:\n                if method == 'MA':\n                    k = int(param)\n                    # Update buffer with latest observation\n                    ma_buffers[e].append(x)\n                    # Keep only last k\n                    if len(ma_buffers[e]) > k:\n                        ma_buffers[e] = ma_buffers[e][-k:]\n                    # Forecast is mean of available buffer\n                    if len(ma_buffers[e]) > 0:\n                        forecasts[e] = float(sum(ma_buffers[e]) / len(ma_buffers[e]))\n                    else:\n                        forecasts[e] = float(lam)\n                elif method == 'ES':\n                    alpha = float(param)\n                    forecasts[e] = alpha * x + (1.0 - alpha) * forecasts[e]\n                else:\n                    raise ValueError(\"Unknown method\")\n            else:\n                # Upstream echelons use exponential smoothing with fixed alpha_up\n                alpha = float(alpha_up)\n                forecasts[e] = alpha * x + (1.0 - alpha) * forecasts[e]\n\n            # 4) Order-up-to decision\n            on_order = sum(pipelines[e]) if L > 0 else 0.0\n            inventory_position = on_hand[e] + on_order - backorders[e]\n            S_target = L * forecasts[e]\n            q = S_target - inventory_position\n            if q  0.0:\n                q = 0.0\n            orders[e, t] = q\n\n            # Schedule arrival after L periods\n            if L > 0:\n                pipelines[e].append(q)\n\n            # Set demand for next upstream echelon within same period\n            downstream_order = q\n\n    # Compute bullwhip ratios using unbiased sample variance after burn-in\n    mask = np.arange(T) >= burn_in\n    var_D = np.var(demand_path[mask], ddof=1)\n    # Guard against zero variance (should not happen with Poisson)\n    if var_D = 0.0:\n        var_D = np.nan\n\n    bullwhip = []\n    for e in range(E):\n        var_Q = np.var(orders[e, mask], ddof=1)\n        ratio = var_Q / var_D if np.isfinite(var_D) and var_D > 0 else float('nan')\n        bullwhip.append(ratio)\n\n    return bullwhip\n\n\ndef solve():\n    # Parameters as specified in the problem statement\n    T = 3000\n    burn_in = 500\n    L = 2\n    lam = 20\n    seed = 20240501\n    alpha_up = 0.5  # upstream echelons' exponential smoothing parameter\n\n    # Generate a single exogenous demand path reused across all test cases\n    rng = np.random.default_rng(seed)\n    demand_path = rng.poisson(lam=lam, size=T).astype(float)\n\n    # Define test cases: (method, parameter)\n    test_cases = [\n        ('MA', 5),     # Case 1: Moving average k=5\n        ('MA', 1),     # Case 2: Moving average k=1\n        ('ES', 0.2),   # Case 3: Exponential smoothing alpha=0.2\n        ('ES', 0.9),   # Case 4: Exponential smoothing alpha=0.9\n    ]\n\n    results = []\n    for method, param in test_cases:\n        ratios = simulate_case(demand_path, method, param, T, burn_in, L, lam, alpha_up)\n        # Round to 4 decimals\n        rounded = [float(f\"{r:.4f}\") for r in ratios]\n        results.append(rounded)\n\n    # Print single-line output in required format without spaces\n    # Construct string like [[b00,b01,b02,b03],[b10,...],...]\n    inner_lists = []\n    for row in results:\n        inner = \",\".join(f\"{x:.4f}\" for x in row)\n        inner_lists.append(f\"[{inner}]\")\n    output = \"[\" + \",\".join(inner_lists) + \"]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2389983"}]}