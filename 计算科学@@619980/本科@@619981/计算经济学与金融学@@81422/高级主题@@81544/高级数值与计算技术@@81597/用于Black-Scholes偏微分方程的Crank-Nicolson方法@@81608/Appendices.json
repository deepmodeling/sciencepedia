{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。本节的第一个练习将引导您从零开始构建一个有限差分求解器，用于为欧式看涨期权定价。这个练习的核心是对比Crank-Nicolson (CN)方法与更简单的显式时间步进方法。通过亲手实现这两种方法并量化解中的数值振荡，您将深刻理解CN方法在处理非光滑初始条件（如期权到期回报）时可能出现的伪影，尤其是在短期限的情况下。这项实践将为您奠定坚实的编程与分析基础，并揭示选择数值方案时需要权衡的实际问题。[@problem_id:2439346]", "problem": "编写一个完整、可运行的程序，用于比较 Crank-Nicolson (CN) 有限差分法和完全显式时间步进有限差分法在为由 Black-Scholes 偏微分方程 (PDE) 控制的欧式看涨期权定价时的行为。您的目标是研究短期限下行权价附近的数值振荡，并使用一个简单、客观的度量来量化它们。\n\n您的公式必须基于以下公认的基础：\n- 在风险中性定价下，欧式看涨期权价格 $V(S,t)$ 的 Black-Scholes 偏微分方程：\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0,\n$$\n其中 $S$ 为标的资产价格，$r$ 为无风险利率，$\\sigma$ 为波动率，$t$ 表示当前时间（较早的时间对应于较长的到期时间）。\n- 到期日 $t = T$ 时的终端条件：\n$$\nV(S,T) = \\max(S - K, 0),\n$$\n其中 $K$ 为行权价。\n- 对于一个足够大的有限域 $S \\in [0, S_{\\max}]$，边界条件为：\n$$\nV(0,t) = 0, \\quad V(S_{\\max}, t) \\approx S_{\\max} - K e^{-r (T - t)}.\n$$\n\n使用 $M$ 个区间对空间域进行均匀离散化，使得 $S_j = j \\Delta S$，$j = 0,1,\\dots,M$，其中 $\\Delta S = S_{\\max}/M$。使用 $N_t$ 个步长对时间进行均匀离散化，使得 $t_n = n \\Delta t$，$n=0,1,\\dots,N_t$，其中 $\\Delta t = T/N_t$。在均匀网格上使用标准的空间中心有限差分。实现：\n- 一种 Crank-Nicolson (CN) 时间步进方法（时间上的隐式梯形法则）。\n- 一种完全显式时间前向法（使用相同的空间模板）。\n\n两种格式都应将数值解从 $t=T$ 向后推进到 $t=0$。\n\n按如下方式定义并计算一个关注行权价邻域的振荡度量。设 $j_K$ 是最接近行权价的空间索引，$j_K = \\mathrm{round}(K/\\Delta S)$。对于一个固定的窗口半宽 $w$，考虑索引 $j \\in \\{ \\max(1, j_K - w), \\dots, \\min(M-1, j_K + w) \\}$。设 $j$ 处的离散二阶差分为\n$$\n\\Delta^2 V_j = V_{j+1}(0) - 2 V_j(0) + V_{j-1}(0),\n$$\n其中 $V_j(0)$ 表示在 $t=0$ 时的数值解。定义振荡幅度\n$$\n\\mathcal{O} = \\max_{j} \\big( 0, -\\Delta^2 V_j \\big),\n$$\n在指定窗口内。对于像欧式看涨期权这样的凸性收益，其真实解是关于 $S$ 的凸函数，因此行权价附近的任何负的离散二阶差分都表明存在伪数值振荡。\n\n为每个测试用例实现这两种方法，并计算比率\n$$\nR = \\frac{\\mathcal{O}_{\\mathrm{CN}}}{\\mathcal{O}_{\\mathrm{EXP}} + \\varepsilon},\n$$\n其中使用一个小的 $\\varepsilon = 10^{-12}$ 以避免除以零。报告每个测试用例的 $R$ 值。\n\n所有利率必须以小数形式表示（例如，年化利率百分之五表示为 $r = 0.05$）。没有物理单位。\n\n使用以下测试套件，该套件在保持空间网格相同的情况下，探索了一系列短期限和波动率。在所有情况下，设置 $K = 100$，$S_{\\max} = 5K$，$M = 100$，窗口半宽 $w = 5$。\n- 情况 A（短期限，粗糙时间）：$\\sigma = 0.2$, $r = 0.05$, $T = 0.01$, $N_t = 10$。\n- 情况 B（短期限，更精细时间）：$\\sigma = 0.2$, $r = 0.05$, $T = 0.01$, $N_t = 40$。\n- 情况 C（极短期限，低波动率）：$\\sigma = 0.1$, $r = 0.05$, $T = 0.005$, $N_t = 8$。\n- 情况 D（短期限，较高波动率）：$\\sigma = 0.3$, $r = 0.05$, $T = 0.02$, $N_t = 64$。\n\n您的程序必须按 A、B、C、D 的顺序为每个情况计算 $R$，并生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[x_1,x_2,x_3,x_4]$。每个 $x_i$ 都应为浮点数。不强制要求四舍五入，但可接受固定的小数位数。\n\n确保您实现的科学真实性和内部一致性。仅使用所述的标准有限差分离散化。不要在您的度量中使用任何解析定价公式；纯粹通过行权价邻域中的离散凸性来评估振荡。", "solution": "问题陈述已经过严格验证，被认为是有效的。它在科学上基于 Black-Scholes 模型和标准数值分析技术，问题设定完整且一致，表述客观。我们将着手提供一个完整的解决方案。\n\n该问题要求实现并比较两种用于求解欧式看涨期权 Black-Scholes 偏微分方程 (PDE) 的有限差分方法。目标是量化在短期限下，行权价附近的数值振荡。\n\nBlack-Scholes 偏微分方程由下式给出：\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0\n$$\n这是一个终值问题，在到期日 $t=T$ 的终端条件为期权的收益函数：\n$$\nV(S,T) = \\max(S-K, 0)\n$$\n为了进行数值求解，我们通常将其转换为一个初值问题。令 $\\tau = T - t$。此变换将时间导数 $\\frac{\\partial}{\\partial t}$ 变为 $-\\frac{\\partial}{\\partial \\tau}$，问题从 $\\tau=0$ （到期日）到 $\\tau=T$ （今天）在 $\\tau$ 上前向求解。该偏微分方程变为：\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V\n$$\n这是一个形式为 $\\frac{\\partial V}{\\partial \\tau} = \\mathcal{L}V$ 的抛物线型偏微分方程，其中 $\\mathcal{L}$ 是一个线性空间微分算子。\n\n我们将空间域 $S \\in [0, S_{\\max}]$ 离散化为 $M$ 个宽度为 $\\Delta S = S_{\\max}/M$ 的区间，使得 $S_j = j \\Delta S$，$j \\in \\{0, 1, \\dots, M\\}$。时间域 $\\tau \\in [0, T]$ 被离散化为 $N_t$ 个步长为 $\\Delta\\tau = T/N_t$ 的时间步，使得 $\\tau_n = n \\Delta\\tau$，$n \\in \\{0, 1, \\dots, N_t\\}$。令 $V_j^n$ 表示 $V(S_j, \\tau_n)$ 的数值近似。\n\n使用标准中心有限差分来处理空间导数，算子 $\\mathcal{L}$ 在网格点 $S_j$ 处被近似为：\n$$\n(\\mathcal{L}_h V)_j = \\left(\\frac{\\sigma^2 S_j^2}{2(\\Delta S)^2} - \\frac{r S_j}{2\\Delta S}\\right)V_{j-1} + \\left(-\\frac{\\sigma^2 S_j^2}{(\\Delta S)^2} - r\\right)V_j + \\left(\\frac{\\sigma^2 S_j^2}{2(\\Delta S)^2} + \\frac{r S_j}{2\\Delta S}\\right)V_{j+1}\n$$\n其中 $\\mathcal{L}_h$ 是离散空间算子。使用 $S_j = j\\Delta S$，我们定义系数：\n$$\n\\alpha_j = \\frac{1}{2}\\sigma^2 j^2 - \\frac{1}{2}rj \\\\\n\\beta_j = -\\sigma^2 j^2 - r \\\\\n\\gamma_j = \\frac{1}{2}\\sigma^2 j^2 + \\frac{1}{2}rj\n$$\n节点 $j$ 处的离散化偏微分方程则为 $\\frac{dV_j}{d\\tau} \\approx \\alpha_j V_{j-1} + \\beta_j V_j + \\gamma_j V_{j+1}$。这是不正确的。这些系数与包含 $\\Delta S$ 的完整表达式相关。半离散化偏微分方程的正确形式是：\n$$\n\\frac{d V_j}{d \\tau} = \\frac{1}{(\\Delta S)^2}\\left(\\frac{1}{2}\\sigma^2 (j\\Delta S)^2 - \\frac{r(j\\Delta S)\\Delta S}{2}\\right)V_{j-1} + \\dots\n$$\n一种更直接的方法是标准的。让我们直接为时间步进格式定义系数：设 $\\tilde{\\alpha}_j = \\frac{\\Delta\\tau}{2}\\left(\\sigma^2 j^2 - rj\\right)$, $\\tilde{\\beta}_j = \\Delta\\tau\\left(\\sigma^2 j^2 + r\\right)$, $\\tilde{\\gamma}_j = \\frac{\\Delta\\tau}{2}\\left(\\sigma^2 j^2 + rj\\right)$。\n\n**1. 完全显式法**\n此方法在 $\\tau$ 上使用前向欧拉离散化：$\\frac{V^{n+1}-V^n}{\\Delta\\tau} = \\mathcal{L}_h V^n$。内部节点（$j = 1, \\dots, M-1$）的更新规则是：\n$$\nV_j^{n+1} = (1 - \\tilde{\\beta}_j)V_j^n + \\tilde{\\alpha}_j V_{j-1}^n + \\tilde{\\gamma}_j V_{j+1}^n\n$$\n该格式计算上很简单，但只是条件稳定的。在每个时间步，我们根据上一步的向量 $V^n$ 计算新值的向量 $V^{n+1}$。\n\n**2. Crank-Nicolson 法**\n此方法对时间导数使用梯形法则：$\\frac{V^{n+1}-V^n}{\\Delta\\tau} = \\frac{1}{2}(\\mathcal{L}_h V^n + \\mathcal{L}_h V^{n+1})$。这是一种隐式方法，它在每个时间步都会导出一个线性方程组：\n$$\n-\\tilde{\\alpha}_j V_{j-1}^{n+1} + (1 + \\tilde{\\beta}_j) V_j^{n+1} - \\tilde{\\gamma}_j V_{j+1}^{n+1} = \\tilde{\\alpha}_j V_{j-1}^n + (1 - \\tilde{\\beta}_j) V_j^n + \\tilde{\\gamma}_j V_{j+1}^n\n$$\n方程左侧包含步骤 $n+1$ 的未知值，形成一个三对角方程组 $A \\boldsymbol{V}^{n+1} = \\boldsymbol{b}$，其中 $\\boldsymbol{V}^{n+1}$ 是未知期权价格的向量。矩阵 $A$ 在整个时间步进过程中是恒定的，这使得可以利用像 Thomas 算法这样的三对角求解器进行高效求解。\n\n**边界条件**\n对于这两种方法，必须在每个时间步 $n$ 应用边界条件：\n- 在 $S=0$ 处：$V_0^{n+1} = 0$。\n- 在 $S=S_{\\max}$ 处：$V_M^{n+1} = S_{\\max} - K e^{-r \\tau_{n+1}}$。\n对于 Crank-Nicolson 方法，在节点 $j=M-1$ 的方程中，已知值 $V_M^{n+1}$ 被移到线性方程组的右侧。\n\n**振荡度量**\n解的凸性在 $\\tau=T$（即 $t=0$）时进行评估。空间节点 $j$ 处的离散二阶差分为 $\\Delta^2 V_j = V_{j+1} - 2 V_j + V_{j-1}$。对于欧式看涨期权，价格是关于 $S$ 的凸函数，因此我们期望 $\\Delta^2 V_j \\ge 0$。振荡幅度 $\\mathcal{O}$ 被定义为在行权价 $K$ 附近的一个窗口内，二阶差分负部的最大值：\n$$\n\\mathcal{O} = \\max_{j \\in W} \\left( 0, - (V_{j+1} - 2V_j + V_{j-1}) \\right)\n$$\n其中窗口 $W$ 为 $\\{ \\max(1, j_K - w), \\dots, \\min(M-1, j_K + w) \\}$，且 $j_K = \\mathrm{round}(K/\\Delta S)$。更大的 $\\mathcal{O}$ 值表示更严重的伪振荡。最终要求的输出是比率 $R = \\mathcal{O}_{\\mathrm{CN}} / (\\mathcal{O}_{\\mathrm{EXP}} + \\varepsilon)$。\n\n对每个测试用例，该过程通过以下步骤实现：\n1. 设置空间和时间网格。\n2. 使用终端条件 $V(S,T)$ 初始化解向量。\n3. 使用显式或 Crank-Nicolson 更新规则，从 $\\tau=0$ 迭代到 $\\tau=T$，并在每一步应用边界条件。\n4. 在最后一个时间步之后，为每种方法计算振荡度量 $\\mathcal{O}$。\n5. 计算比率 $R$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\n# language: Python\n# version: 3.12\n# libraries:\n#   name: numpy\n#   version: 1.23.5\n#   name: scipy\n#   version: 1.11.4\n\ndef solve_black_scholes_fdm(params, method):\n    \"\"\"\n    Solves the Black-Scholes PDE using the specified finite difference method.\n\n    Args:\n        params (dict): Dictionary of parameters (K, S_max, M, T, N_t, r, sigma).\n        method (str): 'explicit' or 'cn' (Crank-Nicolson).\n\n    Returns:\n        numpy.ndarray: The option prices at t=0 across the spatial grid.\n    \"\"\"\n    K, S_max, M, T, N_t, r, sigma = params['K'], params['S_max'], params['M'], params['T'], params['N_t'], params['r'], params['sigma']\n\n    # Grid setup\n    dS = S_max / M\n    dt = T / N_t  # This is delta_tau\n    S = np.linspace(0, S_max, M + 1)\n    \n    # Initial condition at t=T (tau=0)\n    V = np.maximum(S - K, 0)\n    \n    # Coefficients for the discretized PDE (do not depend on time)\n    # These are for the interior points j = 1, ..., M-1\n    j = np.arange(1, M)\n    alpha = 0.5 * dt * (sigma**2 * j**2 - r * j)\n    beta = dt * (sigma**2 * j**2 + r)\n    gamma = 0.5 * dt * (sigma**2 * j**2 + r * j)\n\n    if method == 'explicit':\n        # Time-stepping loop\n        for n in range(N_t):\n            V_old = V.copy()\n            # Vectorized update for interior points\n            V[1:M] = (1 - beta) * V_old[1:M] + alpha * V_old[0:M-1] + gamma * V_old[2:M+1]\n            \n            # Apply boundary conditions for the next step\n            V[0] = 0.0\n            V[M] = S_max - K * np.exp(-r * (n + 1) * dt)\n            \n    elif method == 'cn':\n        # Setup the tridiagonal matrix A for the linear system A*V_new = B\n        l_diag = -alpha[1:]      # Lower diagonal\n        m_diag = 1 + beta\n        u_diag = -gamma[:-1]     # Upper diagonal\n        \n        # Matrix A in banded format for scipy solver\n        # 1st row: super-diagonal, 2nd row: main-diagonal, 3rd row: sub-diagonal\n        A_banded = np.zeros((3, M - 1))\n        A_banded[0, 1:] = u_diag\n        A_banded[1, :] = m_diag\n        A_banded[2, :-1] = l_diag\n\n        # Time-stepping loop\n        for n in range(N_t):\n            # Setup RHS vector B\n            B = alpha * V[0:M-1] + (1 - beta) * V[1:M] + gamma * V[2:M+1]\n\n            # Adjust RHS for boundary conditions\n            # BC at S=0 (V[0]=0) does not require adjustment as alpha[0]*V[0]=0\n            v_M_new = S_max - K * np.exp(-r * (n + 1) * dt)\n            B[-1] += gamma[-1] * v_M_new\n\n            # Solve the linear system\n            V[1:M] = solve_banded((1, 1), A_banded, B)\n            \n            # Update boundary conditions\n            V[0] = 0.0\n            V[M] = v_M_new\n            \n    return V\n\ndef calculate_oscillation_metric(V, K, S_max, M, w):\n    \"\"\"\n    Calculates the oscillation metric from the final option prices.\n    \"\"\"\n    dS = S_max / M\n    j_K = int(round(K / dS))\n    \n    start_j = max(1, j_K - w)\n    end_j = min(M - 1, j_K + w)\n    \n    max_neg_convexity = 0.0\n    for j in range(start_j, end_j + 1):\n        second_diff = V[j+1] - 2 * V[j] + V[j-1]\n        max_neg_convexity = max(max_neg_convexity, -second_diff)\n\n    return max_neg_convexity\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {'K': 100, 'S_max': 500, 'M': 100, 'w': 5, 'sigma': 0.2, 'r': 0.05, 'T': 0.01, 'N_t': 10},\n        # Case B\n        {'K': 100, 'S_max': 500, 'M': 100, 'w': 5, 'sigma': 0.2, 'r': 0.05, 'T': 0.01, 'N_t': 40},\n        # Case C\n        {'K': 100, 'S_max': 500, 'M': 100, 'w': 5, 'sigma': 0.1, 'r': 0.05, 'T': 0.005, 'N_t': 8},\n        # Case D\n        {'K': 100, 'S_max': 500, 'M': 100, 'w': 5, 'sigma': 0.3, 'r': 0.05, 'T': 0.02, 'N_t': 64},\n    ]\n\n    epsilon = 1e-12\n    results = []\n\n    for params in test_cases:\n        # Solve with Crank-Nicolson\n        V_cn = solve_black_scholes_fdm(params, method='cn')\n        osc_cn = calculate_oscillation_metric(V_cn, params['K'], params['S_max'], params['M'], params['w'])\n\n        # Solve with Explicit method\n        V_exp = solve_black_scholes_fdm(params, method='explicit')\n        osc_exp = calculate_oscillation_metric(V_exp, params['K'], params['S_max'], params['M'], params['w'])\n\n        # Calculate the ratio\n        ratio = osc_cn / (osc_exp + epsilon)\n        results.append(ratio)\n\n    # Format the output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2439346"}, {"introduction": "在认识到标准Crank-Nicolson方法可能在非光滑初始条件下产生数值振荡后，一个自然的问题是：我们如何抑制这些振荡？这个练习将介绍一种经典且高效的解决方案——Rannacher平滑启动。该技术在初始的几个时间步采用具有强耗散性的一阶方法（如完全隐式格式），以“平滑”掉初始回报函数中的高频不连续性，然后再切换回高阶精度的CN方法。通过将此技术应用于回报函数更具挑战性的数字期权，您将学习如何有效地解决一个常见的数值难题，从而将您的问题解决能力从识别问题提升到实施解决方案。[@problem_id:2439391]", "problem": "要求您通过在有界空间域上使用两种不同的时间离散化格式求解 Black–Scholes 偏微分方程 (PDE)，来计算一种现金或空无数字看涨期权在零时刻的价值。标的资产价格在风险中性几何布朗运动下建模，其价值函数 $V(S,t)$ 满足 Black–Scholes 偏微分方程\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0,\n$$\n该方程定义在区域 $S \\in [0, S_{\\max}]$, $t \\in [0, T]$ 上，且在 $t = T$ 时有如下终端条件\n$$\nV(S,T) = \\begin{cases}\n1, & \\text{if } S > K,\\\\\n0, & \\text{if } S \\le K,\n\\end{cases}\n$$\n并在所有 $t \\in [0,T]$ 时有如下边界条件\n$$\nV(0,t) = 0,\\qquad \\lim_{S \\to \\infty} V(S,t) = e^{-r (T - t)}.\n$$\n在有界域上，您必须使用 $S_{\\max} = 4K$ 并在 $S = S_{\\max}$ 处通过设置 $V(S_{\\max}, t) = e^{-r (T - t)}$ 来施加边界条件。在变换后的到期时间变量 $\\tau = T - t$ 中进行计算，使得从 $\\tau = 0$ 到 $\\tau = T$ 的向前演化满足\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V,\n$$\n并在 $\\tau = 0$ 时有如下初始条件\n$$\nV(S,0) = \\begin{cases}\n1, & \\text{if } S > K,\\\\\n0, & \\text{if } S \\le K,\n\\end{cases}\n$$\n以及边界条件 $V(0,\\tau) = 0$, $V(S_{\\max}, \\tau) = e^{-r \\tau}$。\n\n将空间域 $[0, S_{\\max}]$ 均匀离散为 $M$ 个等距区间（即 $M+1$ 个网格点），并以大小为 $\\Delta \\tau = T/N$ 的 $N$ 个相等时间步长在到期时间上进行推进。在同一网格上构建以下两种格式：\n\n- 格式 A：使用一种对所有 $N$ 步都无条件稳定且时间上二阶精确的时间离散化方法。\n- 格式 B：对最初两个大小各为 $\\Delta \\tau/2$ 的半时间步，使用一种一阶精确且无条件稳定的时间离散化方法，然后对剩余的 $N-1$ 个大小为 $\\Delta \\tau$ 的完整步长，使用与格式 A 相同的二阶精确格式。\n\n对于空间算子，在均匀空间网格上对一阶和二阶导数使用标准的中心二阶有限差分。对于每组参数，通过对 $\\tau = T$ 时计算出的空间网格进行线性插值，来计算两种格式下 $S = S_0$ 处的期权价值。通过与零时刻现金或空无数字看涨期权的 Black-Scholes 解析解价值进行比较来量化其精度，\n$$\nV_{\\text{BS}}(S_0,0) = e^{-rT}\\,\\Phi(d_2),\\quad d_2 = \\frac{\\ln(S_0/K) + \\left(r - \\frac{1}{2}\\sigma^2\\right)T}{\\sigma \\sqrt{T}},\n$$\n其中 $\\Phi(\\cdot)$ 是标准正态累积分布函数。对于每种情况，报告三个浮点数：格式 A 的绝对误差、格式 B 的绝对误差，以及绝对误差之差（格式 A 减去格式 B）。正的差值表示格式 B 带来了改进。\n\n对所有测试用例使用以下通用离散化参数：\n- 空间网格大小 $M = 400$，\n- 时间步数 $N = 200$，\n- 上边界 $S_{\\max} = 4K$。\n\n测试套件（每个元组列出 $(S_0, K, r, \\sigma, T)$）：\n\n1. $(S_0, K, r, \\sigma, T) = (100, 100, 0.05, 0.2, 1.0)$,\n2. $(S_0, K, r, \\sigma, T) = (80, 100, 0.01, 0.4, 0.25)$,\n3. $(S_0, K, r, \\sigma, T) = (120, 100, 0.10, 0.15, 2.0)$。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，其顺序为\n$[\\text{errA}_1, \\text{errB}_1, \\text{errA}_1 - \\text{errB}_1, \\text{errA}_2, \\text{errB}_2, \\text{errA}_2 - \\text{errB}_2, \\text{errA}_3, \\text{errB}_3, \\text{errA}_3 - \\text{errB}_3]$，\n其中 $\\text{errA}_i$ 和 $\\text{errB}_i$ 分别是测试用例 $i$ 中格式 A 和格式 B 的绝对误差。所有量均为无量纲，并应以十进制数报告。", "solution": "所给出的问题是计算金融领域一个有效的、适定的初边值问题。它要求使用有限差分法，对现金或空无数字看涨期权的 Black-Scholes 偏微分方程 (PDE) 进行数值求解。所有参数、条件和数值格式的描述都足够清晰，可以得到唯一解。问题的核心是比较标准 Crank-Nicolson 格式与一个采用 Rannacher 时间步进的修正版格式在处理非光滑初始条件时的精度。这是偏微分方程数值分析中的一个标准且有意义的练习。\n\n我们从变换到到期时间坐标 $\\tau = T - t$ 的 Black-Scholes PDE 开始。期权价值 $V(S, \\tau)$ 由以下方程决定：\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V\n$$\n这是一个抛物型偏微分方程，我们可以将其写成更紧凑的形式 $\\frac{\\partial V}{\\partial \\tau} = \\mathcal{L}V$，其中 $\\mathcal{L}$ 是空间微分算子：\n$$\n\\mathcal{L} \\equiv \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2}{\\partial S^2} + r S \\frac{\\partial}{\\partial S} - r\n$$\n该问题在域 $S \\in [0, S_{\\max}]$ 和 $\\tau \\in [0, T]$ 上求解，其中 $S_{\\max} = 4K$。在 $\\tau=0$（对应于时间 $t=T$）时的初始条件是该数字期权的不连续支付：\n$$\nV(S, 0) = H(S-K) = \\begin{cases} 1, & \\text{if } S > K \\\\ 0, & \\text{if } S \\le K \\end{cases}\n$$\n对于所有 $\\tau \\in [0, T]$，边界条件为 $V(0, \\tau) = 0$ 和 $V(S_{\\max}, \\tau) = e^{-r\\tau}$。\n\n我们将空间域离散化为 $M=400$ 个宽度为 $\\Delta S = S_{\\max}/M$ 的区间，从而创建一个点网格 $S_j = j\\Delta S$，$j = 0, 1, \\dots, M$。到期时间域被离散为 $N=200$ 个大小为 $\\Delta\\tau = T/N$ 的步长，时间点为 $\\tau_k = k\\Delta\\tau$。令 $V_j^k$ 表示 $V(S_j, \\tau_k)$ 的数值近似。\n\n算子 $\\mathcal{L}$ 中的空间导数对于内部网格点 $j = 1, \\dots, M-1$ 使用二阶中心有限差分进行近似：\n$$\n\\frac{\\partial V}{\\partial S}\\bigg|_{S_j} \\approx \\frac{V_{j+1} - V_{j-1}}{2\\Delta S}, \\qquad \\frac{\\partial^2 V}{\\partial S^2}\\bigg|_{S_j} \\approx \\frac{V_{j+1} - 2V_j + V_{j-1}}{(\\Delta S)^2}\n$$\n将这些应用于网格点 $S_j$ 处的 $\\mathcal{L}V$ 可得：\n$$\n(\\mathcal{L}V)_j \\approx \\alpha_j V_{j-1} + \\beta_j V_j + \\gamma_j V_{j+1}\n$$\n其中系数定义为：\n$$\n\\alpha_j = \\frac{1}{2} \\left(\\frac{\\sigma S_j}{\\Delta S}\\right)^2 - \\frac{r S_j}{2\\Delta S} = \\frac{1}{2}\\sigma^2 j^2 - \\frac{1}{2}rj \\quad (\\text{因为 } S_j = j\\Delta S)\n$$\n$$\n\\beta_j = - \\left(\\frac{\\sigma S_j}{\\Delta S}\\right)^2 - r = -\\sigma^2 j^2 - r\n$$\n$$\n\\gamma_j = \\frac{1}{2} \\left(\\frac{\\sigma S_j}{\\Delta S}\\right)^2 + \\frac{r S_j}{2\\Delta S} = \\frac{1}{2}\\sigma^2 j^2 + \\frac{1}{2}rj\n$$\n这种半离散化方法为内部未知量向量 $\\mathbf{V}(\\tau) = [V_1(\\tau), \\dots, V_{M-1}(\\tau)]^T$ 导出一个常微分方程组：\n$$\n\\frac{d\\mathbf{V}}{d\\tau} = \\mathbf{A}\\mathbf{V} + \\mathbf{f}(\\tau)\n$$\n此处，$\\mathbf{A}$ 是一个三对角矩阵，其元素由系数 $\\alpha_j$, $\\beta_j, \\gamma_j$ 推导而来。向量 $\\mathbf{f}(\\tau)$ 包含由边界条件产生的项。具体来说，$V_0=0$ 的处理方式是从 $j=1$ 开始网格，而 $S_M = S_{\\max}$ 处的条件为 $V_{M-1}$ 的方程贡献一项：$\\mathbf{f}(\\tau)$ 的最后一个分量是 $\\gamma_{M-1}V(S_M, \\tau) = \\gamma_{M-1}e^{-r\\tau}$。\n\n现在我们应用指定的时间步进格式。\n\n**格式 A: Crank-Nicolson 方法**\n该格式在时间上是二阶精确且无条件稳定的。它对时间层 $k$ 和 $k+1$ 之间的空间算子进行平均：\n$$\n\\frac{\\mathbf{V}^{k+1} - \\mathbf{V}^k}{\\Delta\\tau} = \\frac{1}{2} \\left( (\\mathbf{A}\\mathbf{V}^{k+1} + \\mathbf{f}^{k+1}) + (\\mathbf{A}\\mathbf{V}^k + \\mathbf{f}^k) \\right)\n$$\n整理各项后，在每个时间步中得到一个需求解 $\\mathbf{V}^{k+1}$ 的线性方程组：\n$$\n\\left(\\mathbf{I} - \\frac{\\Delta\\tau}{2}\\mathbf{A}\\right)\\mathbf{V}^{k+1} = \\left(\\mathbf{I} + \\frac{\\Delta\\tau}{2}\\mathbf{A}\\right)\\mathbf{V}^k + \\frac{\\Delta\\tau}{2}(\\mathbf{f}^{k+1} + \\mathbf{f}^k)\n$$\n左侧的矩阵是三对角的，并且在整个时间步进过程中保持不变，这使得可以通过三对角矩阵算法进行高效求解。\n\n**格式 B: Rannacher 平滑**\nCrank-Nicolson 方法虽然是高阶的，但众所周知，当应用于具有非光滑初始数据（如此问题中的赫维赛德函数）的问题时，会产生伪振荡。这些振荡会降低精度。格式 B 旨在减缓此问题。它在初始步骤中使用一种强阻尼的一阶方法来平滑解，然后再切换到更精确的 Crank-Nicolson 方法。\n\n1.  **初始平滑步骤：**我们使用隐式欧拉法进行两个大小为 $\\Delta\\tau/2$ 的步骤。隐式欧拉法是一阶精确和 L-稳定的，这为高频误差分量提供了强阻尼。对于大小为 $\\Delta\\tau'$ 的一个步长，其公式为：\n    $$\n    \\frac{\\mathbf{V}^{k+1} - \\mathbf{V}^k}{\\Delta\\tau'} = \\mathbf{A}\\mathbf{V}^{k+1} + \\mathbf{f}^{k+1} \\implies \\left(\\mathbf{I} - \\Delta\\tau'\\mathbf{A}\\right)\\mathbf{V}^{k+1} = \\mathbf{V}^k + \\Delta\\tau'\\mathbf{f}^{k+1}\n    $$\n    我们使用 $\\Delta\\tau' = \\Delta\\tau/2$ 应用此方法两次，将解从 $\\tau=0$ 推进到 $\\tau=\\Delta\\tau/2$，然后再推进到 $\\tau=\\Delta\\tau$。\n\n2.  **Crank-Nicolson 步骤：**对于从 $\\tau=\\Delta\\tau$ 到 $\\tau=T$ 的剩余 $N-1$ 个步骤，解已足够光滑，我们切换到步长为 $\\Delta\\tau$ 的标准 Crank-Nicolson 格式，与格式 A 中一样。\n\n经过总共 $N$ 个时间步后，两种格式都在 $\\tau=T$ 时生成一个期权价值向量 $\\mathbf{V}^N$。在特定现货价格 $S_0$ 处的最终价值是通过对计算值网格 $[V_0^N, V_1^N, \\dots, V_M^N]^T$ 进行线性插值得到的，其中 $V_0^N=0$ 且 $V_M^N=e^{-rT}$。每个格式的精度通过与现金或空无数字看涨期权的 Black-Scholes 解析公式计算的绝对误差来衡量：\n$$\nV_{\\text{BS}}(S_0, 0) = e^{-rT}\\Phi(d_2), \\quad \\text{with} \\quad d_2 = \\frac{\\ln(S_0/K) + (r - \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}}\n$$\n其中 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数。实现部分将计算两种格式的价值，并报告所需的误差度量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\nfrom scipy.stats import norm\n\ndef compute_option_values(S0, K, r, sigma, T, M, N):\n    \"\"\"\n    Computes the price of a cash-or-nothing digital call option using Scheme A and Scheme B.\n    \"\"\"\n\n    # 1. Grid and parameter setup\n    S_max = 4.0 * K\n    ds = S_max / M\n    dt = T / N\n\n    S_grid = np.linspace(0, S_max, M + 1)\n    \n    # 2. PDE coefficients\n    # We define coefficients for interior points j = 1, ..., M-1\n    j = np.arange(1, M)\n    alpha = 0.5 * sigma**2 * j**2 - 0.5 * r * j\n    beta = -sigma**2 * j**2 - r\n    gamma = 0.5 * sigma**2 * j**2 + 0.5 * r * j\n\n    # 3. Initial condition for V(S, tau=0)\n    V0 = np.zeros(M + 1)\n    V0[S_grid > K] = 1.0\n    V0_int = V0[1:M] # Interior points V_1 to V_{M-1}\n\n    # --- Scheme A: Crank-Nicolson for all steps ---\n    V_A = V0_int.copy()\n\n    # LHS matrix for CN, constant through time\n    mat_LHS_CN = np.zeros((3, M - 1))\n    mat_LHS_CN[0, 1:] = -0.5 * dt * gamma[:-1]\n    mat_LHS_CN[1, :] = 1.0 - 0.5 * dt * beta\n    mat_LHS_CN[2, :-1] = -0.5 * dt * alpha[1:]\n\n    for k in range(N):\n        tau_k = k * dt\n        tau_k1 = (k + 1) * dt\n        \n        # RHS vector construction: (I + 0.5*dt*A)V_A\n        RHS = V_A.copy()\n        RHS[0]    += 0.5 * dt * (beta[0] * V_A[0] + gamma[0] * V_A[1])\n        RHS[1:-1] += 0.5 * dt * (alpha[1:-1] * V_A[:-2] + beta[1:-1] * V_A[1:-1] + gamma[1:-1] * V_A[2:])\n        RHS[-1]   += 0.5 * dt * (alpha[-1] * V_A[-2] + beta[-1] * V_A[-1])\n\n        # Add boundary condition term for V_M\n        bc_term = 0.5 * dt * gamma[-1] * (np.exp(-r * tau_k) + np.exp(-r * tau_k1))\n        RHS[-1] += bc_term\n\n        V_A = solve_banded((1, 1), mat_LHS_CN, RHS)\n\n    # --- Scheme B: Rannacher Smoothing (IE + CN) ---\n    V_B = V0_int.copy()\n    dt_half = dt / 2.0\n\n    # LHS matrix for IE steps, constant\n    mat_LHS_IE = np.zeros((3, M - 1))\n    mat_LHS_IE[0, 1:] = -dt_half * gamma[:-1]\n    mat_LHS_IE[1, :] = 1.0 - dt_half * beta\n    mat_LHS_IE[2, :-1] = -dt_half * alpha[1:]\n\n    # First IE half-step (tau = 0 to dt/2)\n    RHS_IE1 = V_B.copy()\n    bc_term_1 = dt_half * gamma[-1] * np.exp(-r * dt_half)\n    RHS_IE1[-1] += bc_term_1\n    V_B = solve_banded((1, 1), mat_LHS_IE, RHS_IE1)\n\n    # Second IE half-step (tau = dt/2 to dt)\n    RHS_IE2 = V_B.copy()\n    bc_term_2 = dt_half * gamma[-1] * np.exp(-r * dt)\n    RHS_IE2[-1] += bc_term_2\n    V_B = solve_banded((1, 1), mat_LHS_IE, RHS_IE2)\n\n    # Remaining N-1 CN steps (tau = dt to T)\n    for k in range(1, N):\n        tau_k = k * dt\n        tau_k1 = (k + 1) * dt\n        \n        # RHS vector construction: (I + 0.5*dt*A)V_B\n        RHS = V_B.copy()\n        RHS[0]    += 0.5 * dt * (beta[0] * V_B[0] + gamma[0] * V_B[1])\n        RHS[1:-1] += 0.5 * dt * (alpha[1:-1] * V_B[:-2] + beta[1:-1] * V_B[1:-1] + gamma[1:-1] * V_B[2:])\n        RHS[-1]   += 0.5 * dt * (alpha[-1] * V_B[-2] + beta[-1] * V_B[-1])\n\n        # Add boundary condition term\n        bc_term = 0.5 * dt * gamma[-1] * (np.exp(-r * tau_k) + np.exp(-r * tau_k1))\n        RHS[-1] += bc_term\n\n        V_B = solve_banded((1, 1), mat_LHS_CN, RHS)\n\n    # --- Final value extraction ---\n    \n    # Reconstruct full solution vectors at tau=T\n    V_final_A = np.zeros(M + 1)\n    V_final_A[1:M] = V_A\n    V_final_A[M] = np.exp(-r * T)\n    \n    V_final_B = np.zeros(M + 1)\n    V_final_B[1:M] = V_B\n    V_final_B[M] = np.exp(-r * T)\n    \n    # Interpolate to find value at S0\n    val_A = np.interp(S0, S_grid, V_final_A)\n    val_B = np.interp(S0, S_grid, V_final_B)\n\n    return val_A, val_B\n\ndef solve():\n    \"\"\"\n    Main solver function to run test cases and format output.\n    \"\"\"\n    # Common discretization parameters\n    M = 400\n    N = 200\n\n    # Test suite: (S0, K, r, sigma, T)\n    test_cases = [\n        (100.0, 100.0, 0.05, 0.2, 1.0),\n        (80.0, 100.0, 0.01, 0.4, 0.25),\n        (120.0, 100.0, 0.10, 0.15, 2.0),\n    ]\n\n    results = []\n    for S0, K, r, sigma, T in test_cases:\n        # Compute numerical values\n        val_A, val_B = compute_option_values(S0, K, r, sigma, T, M, N)\n\n        # Compute analytical value\n        d2 = (np.log(S0 / K) + (r - 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        analytical_val = np.exp(-r * T) * norm.cdf(d2)\n\n        # Compute errors\n        err_A = abs(val_A - analytical_val)\n        err_B = abs(val_B - analytical_val)\n        err_diff = err_A - err_B\n\n        results.extend([err_A, err_B, err_diff])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2439391"}, {"introduction": "我们的旅程将从欧式期权拓展到更复杂、也更贴近现实世界的美式期权。与欧式期权不同，美式期权赋予持有者在到期前任何时间行权的权利。这个“提前行权”特征将标准的Black-Scholes偏微分方程（PDE）转化为一个自由边界问题，其离散形式是一个线性互补问题（LCP）。这项练习要求您将Crank-Nicolson框架与投影逐次超松弛（PSOR）迭代法相结合，在每个时间步求解此LCP，从而确保期权价值始终满足无套利条件和提前行权约束。完成这项任务标志着您已具备将核心数值方法应用于更高级金融工具的能力，这是计算金融领域的一项关键技能。[@problem_id:2439350]", "problem": "您的任务是基于 Black–Scholes 框架，实现一个用于计算美式看跌期权提前行权溢价的数值求解器。该求解器需采用 Crank–Nicolson 时间步进格式，并在每个时间步结合投影逐次超松弛 (PSOR) 方法来施加不等式约束。您的程序必须是一个完整的、可运行的程序，不接受任何输入，并按照下文指定的要求为一个固定的测试套件打印结果。\n\n请从以下基本原理出发：\n- 风险中性定价与无套利偏微分方程 (PDE)，该方程用于描述基于支付或不支付股息的标的资产的衍生品的无套利价格。在风险中性测度下，标的价格 $S$ 服从漂移项为 $r - q$ 的几何布朗运动，其中 $r$ 是连续复利无风险利率， $q$ 是连续股息率。对于一个足够平滑的价格函数 $V(S,t)$，其 Black–Scholes 偏微分方程 (PDE) 为\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + (r - q) S \\frac{\\partial V}{\\partial S} - r V = 0,\n$$\n其中 $\\sigma$ 是恒定波动率，$r$ 是恒定无风险利率，$q$ 是恒定股息率。\n- 对于一个执行价格为 $K$、到期日为 $T$ 的美式看跌期权，其价值 $V(S,t)$ 必须满足线性互补条件\n$$\nV(S,t) \\geq \\max(K - S, 0), \\quad -\\frac{\\partial V}{\\partial t} - \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} - (r - q) S \\frac{\\partial V}{\\partial S} + r V \\geq 0,\n$$\n以及逐点互补性\n$$\n\\left(V(S,t) - \\max(K - S, 0)\\right)\\left(-\\frac{\\partial V}{\\partial t} - \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} - (r - q) S \\frac{\\partial V}{\\partial S} + r V\\right) = 0,\n$$\n对所有 $S \\geq 0$ 和 $t \\in [0,T)$ 成立。终值支付条件为\n$$\nV(S,T) = \\max(K - S, 0).\n$$\n请使用与经济学原理一致的边界条件：对于美式看跌期权，在所有时间 $t \\in [0,T]$，下边界 $S = 0$ 处取 $V(0,t) = K$，而在一个足够大的上边界 $S = S_{\\max}$ 处取 $V(S_{\\max}, t) = 0$。\n\n任务要求：\n- 将空间域 $S \\in [0, S_{\\max}]$ 离散化为一个包含 $N$ 个子区间的均匀网格，步长为 $\\Delta S = S_{\\max} / N$；将时间域 $[0,T]$ 离散化为 $M$ 个均匀时间步，步长为 $\\Delta t = T/M$。对内部网格节点应用 Crank–Nicolson 方法，在每个后向时间步构建一个三对角线性互补问题 (LCP)。\n- 在每个时间步，使用投影逐次超松弛 (PSOR) 方法求解离散 LCP。迭代过程必须使用一个超松弛因子 $\\omega \\in (0,2)$，并通过在每个空间节点 $S_i$ 上将迭代值投影到障碍 $\\max(K - S_i, 0)$ 上来施加行权约束。\n- 使用线性插值法返回给定即期价格 $S_0$ 处的期权价格，该价格点可能不恰好落在网格节点上。\n- 所有利率 $r$、$q$ 和波动率 $\\sigma$ 必须以小数形式表示（例如，5% 表示为 $0.05$）。时间 $T$ 必须以年为单位。不涉及角度单位。输入或输出中不应出现百分号；只使用小数。\n\n实现细节期望：\n- 在均匀网格上推导 Crank–Nicolson 半隐式内部节点离散格式，在新时间层级上得到一个三对角左端项，在旧时间层级上得到一个三对角右端项，并一致地整合边界值。不要使用任何美式期权定价的解析公式或罚函数法；您必须通过 PSOR 来施加提前行权约束。\n- 为 PSOR 实现一个停止准则，该准则基于所有内部节点上的最大绝对变化量小于一个容差 $\\varepsilon$，并设置最大迭代次数上限以保证算法终止。\n- 通过为以下每个测试用例选择足够大的 $S_{\\max}$ 以及足够的空间和时间分辨率来确保数值稳定性。\n\n测试套件：\n请为下面的每一组参数计算在即期价格 $S_0$ 处的美式看跌期权价格。使用指定的 $S_{\\max}$、$N$、$M$、PSOR 松弛因子 $\\omega$、容差 $\\varepsilon$ 以及每个时间步的最大迭代次数 $I_{\\max}$。参数以元组 $(S_0, K, T, r, q, \\sigma, S_{\\max}, N, M, \\omega, \\varepsilon, I_{\\max})$ 的形式给出：\n- 案例 1 (基准，一年期，中等波动率): $(100.0, 100.0, 1.0, 0.05, 0.0, 0.2, 500.0, 200, 400, 1.5, 1\\times 10^{-8}, 10000)$.\n- 案例 2 (一年期，高波动率，低利率): $(100.0, 100.0, 1.0, 0.01, 0.0, 0.6, 600.0, 180, 500, 1.5, 1\\times 10^{-8}, 10000)$.\n- 案例 3 (一年期，零利率): $(100.0, 100.0, 1.0, 0.0, 0.0, 0.2, 500.0, 180, 400, 1.5, 1\\times 10^{-8}, 10000)$.\n- 案例 4 (短期限，价内): $(50.0, 100.0, 0.0833333333333, 0.05, 0.0, 0.2, 500.0, 140, 120, 1.5, 1\\times 10^{-8}, 10000)$.\n\n最终输出规格：\n- 您的程序必须生成单行输出，其中包含按案例 1 到 4 排序的结果，结果为一系列用逗号分隔的浮点数，并用方括号括起来。\n- 每个数字必须四舍五入到恰好 6 位小数。\n- 例如，输出格式必须类似于 $[v_1,v_2,v_3,v_4]$，其中每个 $v_i$ 是一个四舍五入到 6 位小数的浮点数。", "solution": "用户指定了一个计算金融领域的问题：通过数值求解带有提前行权约束的 Black-Scholes 偏微分方程 (PDE) 来为美式看跌期权定价。该问题在科学上是合理的、适定的，并且为得出完整解提供了所有必要参数，因此被认为是有效的。解决方案要求实现 Crank-Nicolson 方法进行时间离散化，并使用投影逐次超松弛 (PSOR) 方法来处理由提前行权特性产生的线性互补问题。\n\n用于期权价格 $V(S,t)$ 的 Black-Scholes 模型由以下 PDE 给出，其中 $S$ 是标的资产价格， $t$ 是时间：\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + (r - q) S \\frac{\\partial V}{\\partial S} - r V = 0\n$$\n此处，$r$ 是无风险利率，$q$ 是连续股息率，$\\sigma$ 是标的资产的波动率。对于美式看跌期权，此方程变为一个不等式，并且由于它是一个自由边界问题，其解必须满足一个线性互补形式。期权价格必须始终大于或等于其内在价值，即 $V(S,t) \\geq \\max(K-S, 0)$，其中 $K$ 是执行价格。\n\n这是一个终值问题，需要从到期日 $T$ 向后求解至当前时间 $t=0$。为了便于使用标准的前向步进数值格式，我们进行时间变量替换，令 $\\tau = T - t$。PDE 变为：\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + (r - q) S \\frac{\\partial V}{\\partial S} - r V\n$$\n我们将空间域 $S \\in [0, S_{\\max}]$ 离散化为 $N$ 个大小为 $\\Delta S = S_{\\max}/N$ 的区间，创建网格点 $S_i = i\\Delta S$，$i=0, 1, \\dots, N$。将时间域 $\\tau \\in [0, T]$ 离散化为 $M$ 个大小为 $\\Delta \\tau = T/M$ 的步长，创建时间点 $\\tau_j = j\\Delta\\tau$，$j=0, 1, \\dots, M$。令 $V_i^j$ 表示 $V(S_i, \\tau_j)$ 的数值近似。\n\nCrank-Nicolson 方法在中间点 $\\tau_{j+1/2}$ 处近似时间导数，并对空间算子在时间层 $j$ 和 $j+1$ 上取平均：\n$$\n\\frac{V^{j+1} - V^{j}}{\\Delta \\tau} = \\frac{1}{2}(\\mathcal{L}V^{j+1} + \\mathcal{L}V^{j})\n$$\n其中 $\\mathcal{L}$ 是空间微分算子。整理后，在每个时间步得到一个待解的线性方程组：\n$$\n\\left(\\mathbf{I} - \\frac{\\Delta \\tau}{2}\\mathbf{L}\\right) \\mathbf{V}^{j+1} = \\left(\\mathbf{I} + \\frac{\\Delta \\tau}{2}\\mathbf{L}\\right) \\mathbf{V}^{j}\n$$\n其中 $\\mathbf{L}$ 是在使用中心有限差分近似导数 $\\frac{\\partial V}{\\partial S}$ 和 $\\frac{\\partial^2 V}{\\partial S^2}$ 后，算子 $\\mathcal{L}$ 的矩阵表示：\n$$\n\\frac{\\partial V}{\\partial S}\\bigg|_{S_i} \\approx \\frac{V_{i+1} - V_{i-1}}{2\\Delta S}, \\quad \\frac{\\partial^2 V}{\\partial S^2}\\bigg|_{S_i} \\approx \\frac{V_{i+1} - 2V_i + V_{i-1}}{(\\Delta S)^2}\n$$\n将这些近似代入算子 $\\mathcal{L}$，可得到矩阵 $\\mathbf{L}$ 的三对角结构。对于每个内部节点 $i=1, \\dots, N-1$，方程为：\n$$\nL_i V_{i-1}^{j+1} + M_i V_i^{j+1} + R_i V_{i+1}^{j+1} = Q_i\n$$\n系数定义如下：\n$$\nL_i = -\\frac{\\Delta \\tau}{4}\\left(\\sigma^2 i^2 - (r-q)i\\right)\n$$\n$$\nM_i = 1 + \\frac{\\Delta \\tau}{2}\\left(\\sigma^2 i^2 + r\\right)\n$$\n$$\nR_i = -\\frac{\\Delta \\tau}{4}\\left(\\sigma^2 i^2 + (r-q)i\\right)\n$$\n右端项 $Q_i$ 由时间步 $j$ 的已知值构造：\n$$\nQ_i = -L_i V_{i-1}^{j} + (2-M_i)V_i^{j} - R_i V_{i+1}^{j}\n$$\n美式看跌期权的边界条件是 $V(0,\\tau) = K$ 和 $V(S_{\\max}, \\tau) = 0$。通过调整右端向量 $Q$ 来整合这些条件。对于第一个内部节点 $i=1$，项 $L_1 V_0^{j+1}$ 移到右侧，变为 $L_1 K$。类似地，在最后一个内部节点 $i=N-1$ 处，项 $R_{N-1}V_N^{j+1}$ 为 $0$。\n\n提前行权约束要求对所有 $i$ 都有 $V_i^{j+1} \\geq g_i = \\max(K-S_i, 0)$。这使得线性系统转变为一个线性互补问题 (LCP)，我们使用投影逐次超松弛 (PSOR) 方法来求解。对于每个时间步，我们进行迭代以求解向量 $\\mathbf{V}^{j+1}$。对每个内部节点 $i$ 的第 $k$ 次迭代的更新规则如下：\n\n1. 计算标准的 SOR 更新：\n$$\nv_i^{*} = (1-\\omega)V_i^{(k)} + \\frac{\\omega}{M_i} \\left( Q_i - L_i V_{i-1}^{(k+1)} - R_i V_{i+1}^{(k)} \\right)\n$$\n其中 $\\omega \\in (0,2)$ 是松弛参数，$V^{(k)}$ 是上一次迭代的向量，$V^{(k+1)}$ 使用当前迭代中已更新的值。\n\n2. 将结果投影到行权价值（障碍）上：\n$$\nV_i^{(k+1)} = \\max(v_i^{*}, g_i)\n$$\nPSOR 迭代持续进行，直到所有节点上连续迭代值之间的最大绝对变化量小于容差 $\\varepsilon$，或者达到最大迭代次数 $I_{\\max}$。\n\n总体算法如下：\n1.  在到期日 $\\tau=0$ (即 $t=T$)，使用终值支付函数 $V_i^0 = \\max(K - S_i, 0)$ 初始化期权价值网格 $\\mathbf{V}$。\n2.  从 $j=0$ 到 $M-1$ 进行时间步迭代（即时间从后向前）。在每个步骤中：\n    a.  使用 $\\mathbf{V}^j$ 的值计算右端向量 $\\mathbf{Q}$。\n    b.  根据边界条件调整 $\\mathbf{Q}$。\n    c.  以 $\\mathbf{V}^j$ 为初始猜测值，使用 PSOR 算法为 $\\mathbf{V}^{j+1}$ 求解 LCP。\n    d.  施加边界条件 $V_0^{j+1} = K$ 和 $V_N^{j+1} = 0$。\n3.  在最后一个时间步之后，向量 $\\mathbf{V}^M$ 包含 $t=0$ 时的期权价格。\n4.  使用线性插值法找到特定即期价格 $S_0$ 处的期权价格，该价格点可能不在网格点上。\n\n此过程为美式看跌期权价格提供了一个稳健的数值解，该解遵循了 Black-Scholes 框架的无套利条件和提前行权约束。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_american_put_price(S0, K, T, r, q, sigma, S_max, N, M, omega, epsilon, I_max):\n    \"\"\"\n    Computes the American put option price using the Crank-Nicolson FDM and PSOR.\n\n    :param S0: Initial stock price\n    :param K: Strike price\n    :param T: Time to maturity (in years)\n    :param r: Risk-free interest rate (decimal)\n    :param q: Continuous dividend yield (decimal)\n    :param sigma: Volatility (decimal)\n    :param S_max: Maximum stock price in the grid\n    :param N: Number of spatial steps\n    :param M: Number of time steps\n    :param omega: SOR relaxation factor\n    :param epsilon: PSOR tolerance\n    :param I_max: Max iterations for PSOR\n    :return: American put option price at S0\n    \"\"\"\n    # 1. Grid setup\n    dt = T / M\n    ds = S_max / N\n    S = np.linspace(0, S_max, N + 1)\n    \n    # 2. Initialize option values at maturity (t=T)\n    V = np.maximum(K - S, 0)\n    \n    # 3. Pre-compute Crank-Nicolson coefficients for the tridiagonal system\n    # These coefficients are used for the matrix on the LHS of the time-step equation.\n    i = np.arange(1, N)  # Interior nodes\n    \n    # Coefficients for L_i * V_{i-1} + M_i * V_i + R_i * V_{i+1} = Q_i\n    L_coeffs = -0.25 * dt * (sigma**2 * i**2 - (r - q) * i)\n    M_coeffs = 1 + 0.5 * dt * (sigma**2 * i**2 + r)\n    R_coeffs = -0.25 * dt * (sigma**2 * i**2 + (r - q) * i)\n\n    # 4. Time-stepping loop (backward from T to 0)\n    for j in range(M - 1, -1, -1):\n        # Calculate the explicit part (RHS) of the CN scheme\n        Q = -L_coeffs * V[:-2] + (2 - M_coeffs) * V[1:-1] - R_coeffs * V[2:]\n\n        # Adjust RHS for boundary conditions\n        # For S=0, V=K. For S=S_max, V=0.\n        # Boundary condition V(0,t)=K affects the equation for the first interior node (i=1)\n        Q[0] += L_coeffs[0] * K  # Term involving V_0 from LHS, moved to RHS\n        Q[0] += L_coeffs[0] * K  # Term involving V_0 from RHS side\n        # V(S_max,t)=0 means the R_coeffs[N-2] term involving V_N is zero, no adjustment needed\n\n        # 5. PSOR solver for the linear complementarity problem at each time step\n        v_interior = V[1:-1].copy()  # Initial guess from previous time step\n        obstacle = np.maximum(K - S[1:-1], 0)\n\n        for k in range(I_max):\n            v_old_iter = v_interior.copy()\n\n            # Iterate through interior nodes\n            for i in range(N - 1):\n                # SOR update calculation\n                sor_sum = 0\n                if i > 0:\n                    sor_sum += L_coeffs[i] * v_interior[i - 1]\n                if i < N - 2:\n                    sor_sum += R_coeffs[i] * v_old_iter[i + 1]\n\n                v_star = (1 - omega) * v_old_iter[i] + (omega / M_coeffs[i]) * (Q[i] - sor_sum)\n                \n                # Projection step\n                v_interior[i] = max(v_star, obstacle[i])\n\n            # Check for convergence\n            if np.max(np.abs(v_interior - v_old_iter)) < epsilon:\n                break\n        \n        # Update V with the solution for the current time step\n        V[1:-1] = v_interior\n        V[0] = K  # Boundary at S=0\n        V[N] = 0.0 # Boundary at S=S_max\n        \n    # 6. Interpolate to find price at S0\n    idx = int(S0 / ds)\n    if idx >= N: # Handle case where S0 is at or beyond S_max\n        return 0.0\n    \n    # Linear interpolation\n    price = V[idx] + (V[idx + 1] - V[idx]) * (S0 - S[idx]) / ds\n    return price\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (S0, K, T, r, q, sigma, S_max, N, M, omega, epsilon, I_max)\n        (100.0, 100.0, 1.0, 0.05, 0.0, 0.2, 500.0, 200, 400, 1.5, 1e-8, 10000),\n        (100.0, 100.0, 1.0, 0.01, 0.0, 0.6, 600.0, 180, 500, 1.5, 1e-8, 10000),\n        (100.0, 100.0, 1.0, 0.0, 0.0, 0.2, 500.0, 180, 400, 1.5, 1e-8, 10000),\n        (50.0, 100.0, 0.0833333333333, 0.05, 0.0, 0.2, 500.0, 140, 120, 1.5, 1e-8, 10000),\n    ]\n\n    results = []\n    for case in test_cases:\n        params = {\n            \"S0\": case[0], \"K\": case[1], \"T\": case[2], \"r\": case[3], \"q\": case[4], \n            \"sigma\": case[5], \"S_max\": case[6], \"N\": case[7], \"M\": case[8], \n            \"omega\": case[9], \"epsilon\": case[10], \"I_max\": case[11]\n        }\n        price = compute_american_put_price(**params)\n        results.append(f\"{price:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "2439350"}]}