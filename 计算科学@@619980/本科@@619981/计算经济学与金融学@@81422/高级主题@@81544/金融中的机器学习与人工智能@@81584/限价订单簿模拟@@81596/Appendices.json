{"hands_on_practices": [{"introduction": "要构建一个可信的限价订单簿模拟，我们首先需要理解市场参与者的决策过程。这个练习将引导你从理论层面入手，为一位被称为“做市商”的关键市场参与者建立一个数学模型。通过解决这个优化问题，你将推导出做市商在平衡获取买卖价差的收益与管理库存风险之间的最优报价策略，这为我们后续模拟中智能体的行为设计提供了坚实的理论基础。[@problem_id:2406577]", "problem": "模拟一个单一资产的限价订单簿 (LOB)，时间范围为一个长度为 $\\Delta t > 0$ 的短时期。中间价用 $S$ 表示，其在 $\\Delta t$ 内的期望变化为零。一位做市商在低于 $S$ 的 $\\delta_b \\ge 0$ 距离处发布一个单位大小的买入限价单，并在高于 $S$ 的 $\\delta_a \\ge 0$ 距离处发布一个单位大小的卖出限价单。每次执行使库存量在买方变为 $+q$，在卖方变为 $-q$，其中 $q>0$ 是给定的。初始库存为 $I_0 \\in \\mathbb{R}$。\n\n对做市商报价的订单到达是独立的泊松过程，其均值为\n$$\n\\Lambda_b(\\delta_b) = (\\alpha - \\beta \\delta_b)\\,\\Delta t,\\qquad \\Lambda_a(\\delta_a) = (\\alpha - \\beta \\delta_a)\\,\\Delta t,\n$$\n其中 $\\alpha>0$ 和 $\\beta>0$ 是给定常数，报价受到限制，以使 $\\Lambda_b(\\delta_b)\\ge 0$ 和 $\\Lambda_a(\\delta_a)\\ge 0$。每个执行的买入（或卖出）订单的利润是相对于 $S$ 衡量的，等于 $\\delta_b q$（或 $\\delta_a q$）。\n\n在时期结束时，做市商会产生一个非线性的库存惩罚 $C(I_T)=k I_T^2$，其中 $k>0$，期末库存为 $I_T = I_0 + q N_b - q N_a$，这里的 $N_b \\sim \\mathrm{Poisson}(\\Lambda_b(\\delta_b))$ 和 $N_a \\sim \\mathrm{Poisson}(\\Lambda_a(\\delta_a))$ 是独立的。\n\n建立并求解选择 $(\\delta_b,\\delta_a)$ 的优化问题，以最大化在时间范围 $\\Delta t$ 内扣除预期期末库存惩罚后的预期净利润。提供最优距离 $\\delta_b^\\star$ 和 $\\delta_a^\\star$ 的解析表达式，用 $\\alpha$、$\\beta$、$\\Delta t$、$q$、$k$ 和 $I_0$ 表示。", "solution": "用户要求建立并求解一个限价订单簿中做市商的优化问题。我将首先验证问题陈述。\n\n步骤1：提取已知条件\n- 时间范围：$\\Delta t > 0$。\n- 中间价：$S$，其 $E[\\Delta S] = 0$。\n- 买入限价单价格：$S - \\delta_b$，其中 $\\delta_b \\ge 0$。\n- 卖出限价单价格：$S + \\delta_a$，其中 $\\delta_a \\ge 0$。\n- 订单执行大小：$q > 0$。\n- 初始库存：$I_0 \\in \\mathbb{R}$。\n- 订单到达率是独立泊松过程的均值：\n  - 买方：$\\Lambda_b(\\delta_b) = (\\alpha - \\beta \\delta_b)\\,\\Delta t$。\n  - 卖方：$\\Lambda_a(\\delta_a) = (\\alpha - \\beta \\delta_a)\\,\\Delta t$。\n- 常数：$\\alpha > 0$，$\\beta > 0$。\n- 约束条件：$\\Lambda_b(\\delta_b)\\ge 0$ 和 $\\Lambda_a(\\delta_a)\\ge 0$。这意味着 $0 \\le \\delta_b \\le \\alpha/\\beta$ 和 $0 \\le \\delta_a \\le \\alpha/\\beta$。\n- 每次买入执行的利润：$\\delta_b q$。\n- 每次卖出执行的利润：$\\delta_a q$。\n- 期末库存惩罚：$C(I_T) = k I_T^2$，其中 $k > 0$。\n- 期末库存：$I_T = I_0 + q N_b - q N_a$，其中 $N_b \\sim \\mathrm{Poisson}(\\Lambda_b(\\delta_b))$ 和 $N_a \\sim \\mathrm{Poisson}(\\Lambda_a(\\delta_a))$ 分别是买入和卖出执行的次数。\n- 目标：选择 $(\\delta_b, \\delta_a)$ 以最大化预期总利润。\n\n步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题是一个简化的做市模型，与量化金融领域的既有文献（例如 Avellaneda-Stoikov 框架）一致。使用泊松过程描述订单到达和二次库存惩罚是标准的建模选择。\n- **良态问题**：该问题要求在一个紧集上最大化一个函数。我将证明，目标函数是严格凹的，这保证了唯一最大值的存在。该问题是良态的。\n- **客观性**：该问题以清晰的数学术语陈述，不含主观内容。\n\n问题陈述是有效的。它是自洽的、有科学依据的并且是客观的。我现在开始求解。\n\n在时间范围 $\\Delta t$ 内的总利润 $\\Pi$ 是已执行订单的利润之和减去期末库存惩罚：\n$$\n\\Pi = q \\delta_b N_b + q \\delta_a N_a - k I_T^2 = q \\delta_b N_b + q \\delta_a N_a - k (I_0 + q N_b - q N_a)^2\n$$\n目标是通过选择 $\\delta_b$ 和 $\\delta_a$ 来最大化预期利润 $E[\\Pi]$。\n$$\nE[\\Pi] = E[q \\delta_b N_b + q \\delta_a N_a - k (I_0 + q N_b - q N_a)^2]\n$$\n根据期望的线性性质，\n$$\nE[\\Pi] = q \\delta_b E[N_b] + q \\delta_a E[N_a] - k E[(I_0 + q N_b - q N_a)^2]\n$$\n对于一个泊松随机变量 $X \\sim \\mathrm{Poisson}(\\lambda)$，其期望为 $E[X] = \\lambda$，方差为 $\\mathrm{Var}(X) = \\lambda$。其二阶矩为 $E[X^2] = \\mathrm{Var}(X) + (E[X])^2 = \\lambda + \\lambda^2$。\n随机变量 $N_b$ 和 $N_a$ 是独立的。\n$E[N_b] = \\Lambda_b$ 且 $E[N_a] = \\Lambda_a$。\n预期期末库存为 $E[I_T] = E[I_0 + q N_b - q N_a] = I_0 + q E[N_b] - q E[N_a] = I_0 + q(\\Lambda_b - \\Lambda_a)$。\n期末库存的方差为 $\\mathrm{Var}(I_T) = \\mathrm{Var}(I_0 + q N_b - q N_a) = q^2\\mathrm{Var}(N_b) + q^2\\mathrm{Var}(N_a) = q^2(\\Lambda_b + \\Lambda_a)$。\n预期的二次惩罚为 $E[k I_T^2] = k E[I_T^2] = k (\\mathrm{Var}(I_T) + (E[I_T])^2)$。\n$$\nE[k I_T^2] = k \\left[ q^2(\\Lambda_b + \\Lambda_a) + (I_0 + q(\\Lambda_b - \\Lambda_a))^2 \\right]\n$$\n因此，要最大化的目标函数，我们称之为 $F(\\delta_b, \\delta_a)$，是：\n$$\nF(\\delta_b, \\delta_a) = q \\delta_b \\Lambda_b + q \\delta_a \\Lambda_a - k \\left[ q^2(\\Lambda_b + \\Lambda_a) + (I_0 + q(\\Lambda_b - \\Lambda_a))^2 \\right]\n$$\n为了找到最优的 $(\\delta_b, \\delta_a)$，我们计算 $F$ 的偏导数并令其为零。我们注意到 $\\frac{\\partial \\Lambda_b}{\\partial \\delta_b} = -\\beta \\Delta t$，$\\frac{\\partial \\Lambda_a}{\\partial \\delta_a} = -\\beta \\Delta t$，且交叉导数为零。\n\n关于 $\\delta_b$ 的偏导数是：\n$$\n\\frac{\\partial F}{\\partial \\delta_b} = \\frac{\\partial}{\\partial \\delta_b} (q \\delta_b \\Lambda_b) - k q^2 \\frac{\\partial \\Lambda_b}{\\partial \\delta_b} - 2k(I_0 + q(\\Lambda_b - \\Lambda_a))q \\frac{\\partial \\Lambda_b}{\\partial \\delta_b} = 0\n$$\n使用乘法法则，$\\frac{\\partial}{\\partial \\delta_b} (q \\delta_b \\Lambda_b) = q \\Lambda_b + q \\delta_b \\frac{\\partial \\Lambda_b}{\\partial \\delta_b}$。\n$$\nq \\Lambda_b + q \\delta_b \\frac{\\partial \\Lambda_b}{\\partial \\delta_b} - k q^2 \\frac{\\partial \\Lambda_b}{\\partial \\delta_b} - 2kq(I_0 + q(\\Lambda_b - \\Lambda_a)) \\frac{\\partial \\Lambda_b}{\\partial \\delta_b} = 0\n$$\n代入 $\\frac{\\partial \\Lambda_b}{\\partial \\delta_b} = -\\beta \\Delta t$：\n$$\nq \\Lambda_b - q \\delta_b (\\beta \\Delta t) + k q^2 (\\beta \\Delta t) + 2kq(I_0 + q(\\Lambda_b - \\Lambda_a)) (\\beta \\Delta t) = 0\n$$\n除以 $q \\beta \\Delta t$ (非零)：\n$$\n\\frac{\\Lambda_b}{\\beta \\Delta t} - \\delta_b + kq + 2k(I_0 + q(\\Lambda_b - \\Lambda_a)) = 0\n$$\n代入 $\\Lambda_b = (\\alpha - \\beta \\delta_b)\\Delta t$：\n$$\n\\frac{(\\alpha - \\beta \\delta_b)\\Delta t}{\\beta \\Delta t} - \\delta_b + kq + 2k I_0 + 2kq(\\Lambda_b - \\Lambda_a) = 0\n$$\n$$\n\\frac{\\alpha}{\\beta} - 2\\delta_b + kq + 2k I_0 + 2kq(\\Lambda_b - \\Lambda_a) = 0\n$$\n$$\n2\\delta_b = \\frac{\\alpha}{\\beta} + kq + 2k I_0 + 2kq(\\Lambda_b - \\Lambda_a) \\quad (1)\n$$\n根据对称性，关于 $\\delta_a$ 的偏导数得出：\n$$\n\\frac{\\partial F}{\\partial \\delta_a} = q \\Lambda_a + q \\delta_a \\frac{\\partial \\Lambda_a}{\\partial \\delta_a} - k q^2 \\frac{\\partial \\Lambda_a}{\\partial \\delta_a} - 2k(I_0 + q(\\Lambda_b - \\Lambda_a))(-q) \\frac{\\partial \\Lambda_a}{\\partial \\delta_a} = 0\n$$\n除以 $q \\beta \\Delta t$ 并代入 $\\frac{\\partial \\Lambda_a}{\\partial \\delta_a} = -\\beta \\Delta t$：\n$$\n\\frac{\\Lambda_a}{\\beta \\Delta t} - \\delta_a + kq - 2k(I_0 + q(\\Lambda_b - \\Lambda_a)) = 0\n$$\n$$\n\\frac{\\alpha}{\\beta} - 2\\delta_a + kq - 2k I_0 - 2kq(\\Lambda_b - \\Lambda_a) = 0\n$$\n$$\n2\\delta_a = \\frac{\\alpha}{\\beta} + kq - 2k I_0 - 2kq(\\Lambda_b - \\Lambda_a) \\quad (2)\n$$\n我们现在得到了一个关于 $\\delta_b$ 和 $\\delta_a$ 的二元线性方程组。\n将 (1) 和 (2) 相加：\n$$\n2(\\delta_b + \\delta_a) = 2\\left(\\frac{\\alpha}{\\beta} + kq\\right) \\implies \\delta_b + \\delta_a = \\frac{\\alpha}{\\beta} + kq\n$$\n将 (1) 减去 (2)：\n$$\n2(\\delta_b - \\delta_a) = 4k I_0 + 4kq(\\Lambda_b - \\Lambda_a)\n$$\n代入 $\\Lambda_b - \\Lambda_a = (\\alpha - \\beta \\delta_b)\\Delta t - (\\alpha - \\beta \\delta_a)\\Delta t = \\beta \\Delta t (\\delta_a - \\delta_b)$：\n$$\n2(\\delta_b - \\delta_a) = 4k I_0 + 4kq\\beta \\Delta t (\\delta_a - \\delta_b) = 4k I_0 - 4kq\\beta \\Delta t (\\delta_b - \\delta_a)\n$$\n$$\n2(1 + 2kq\\beta \\Delta t)(\\delta_b - \\delta_a) = 4k I_0\n$$\n$$\n\\delta_b - \\delta_a = \\frac{2k I_0}{1 + 2kq\\beta \\Delta t}\n$$\n我们求解该方程组：\n$$\n\\delta_b + \\delta_a = \\frac{\\alpha}{\\beta} + kq\n$$\n$$\n\\delta_b - \\delta_a = \\frac{2k I_0}{1 + 2kq\\beta \\Delta t}\n$$\n将这两个方程相加得到 $2\\delta_b$：\n$$\n\\delta_b^\\star = \\frac{1}{2} \\left( \\frac{\\alpha}{\\beta} + kq \\right) + \\frac{k I_0}{1 + 2kq \\beta \\Delta t}\n$$\n第一个方程减去第二个方程得到 $2\\delta_a$：\n$$\n\\delta_a^\\star = \\frac{1}{2} \\left( \\frac{\\alpha}{\\beta} + kq \\right) - \\frac{k I_0}{1 + 2kq \\beta \\Delta t}\n$$\n这些是在假设存在内部解的情况下的最优报价距离。目标函数 $F$ 的海森矩阵是常数且负定的，这确保了 $F$ 是严格凹函数，并且该驻点是唯一的全局最大值点。问题指定了约束条件 $0 \\le \\delta_b, \\delta_a \\le \\alpha/\\beta$。所提供的解在其满足这些约束的参数区域内是有效的。一个完整的处理方法将涉及分析边界解，但这些表达式代表了从模型核心逻辑推导出的解析解。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\delta_b^\\star = \\frac{1}{2} \\left( \\frac{\\alpha}{\\beta} + kq \\right) + \\frac{k I_0}{1 + 2kq \\beta \\Delta t} \\\\ \\delta_a^\\star = \\frac{1}{2} \\left( \\frac{\\alpha}{\\beta} + kq \\right) - \\frac{k I_0}{1 + 2kq \\beta \\Delta t} \\end{pmatrix}}\n$$", "id": "2406577"}, {"introduction": "在理解了单个智能体的决策逻辑后，我们接下来着手构建他们赖以交互的市场环境——限价订单簿本身。这个实践任务的核心是设计并实现一个高效的“订单匹配引擎”。与常见的离散价格模型不同，该练习要求你处理连续的价格，这需要你运用如堆（heaps）和队列（queues）等高级数据结构来精确且高效地执行价格-时间优先原则，这是任何高性能金融市场模拟的核心技术挑战。[@problem_id:2406545]", "problem": "你的任务是设计并实现一个连续价格的限价订单簿（LOB）模拟器。与常见的离散报价单位设置不同，这里的价格是实数值，而不是对齐到某个网格。该模拟器必须实现价格-时间优先原则，允许订单取消，并能处理市价单和限价单的部分成交，所有这些都需要在一个小的数值容差下进行，以处理浮点数比较。\n\n这个问题的核心是将具有连续价格的双向拍卖的微观结构逻辑，转化为高效的数据结构和算法匹配引擎，然后计算指定的汇总指标。以下是你必须遵守的基础定义和规则。\n\n定义和规则：\n- 限价单是一个元组 $(\\text{side}, \\text{quantity}, \\text{price}, \\text{id})$，其中 $\\text{side} \\in \\{\\text{buy}, \\text{sell}\\}$（买/卖），$\\text{quantity} \\in \\mathbb{R}_{>0}$（数量），$\\text{price} \\in \\mathbb{R}_{>0}$（价格），以及一个唯一的整数标识符 $\\text{id} \\in \\mathbb{Z}_{>0}$。市价单是一个没有价格的元组 $(\\text{side}, \\text{quantity}, \\text{id})$。取消订单是针对一个现有标识符的 $(\\text{id})$。\n- 价格-时间优先：在同一边（买或卖）且价格相同的挂单中，执行优先级按到达时间排序（先进先出）。在不同价格之间，最优价格的订单首先执行：买单的最高价和卖单的最低价。\n- 带容差的匹配条件：设 $\\varepsilon \\ge 0$ 为一个数值容差。当一个价格为 $p_b$ 的新买入限价单进入时，如果当前的最优卖价 $a^\\star$ 满足 $a^\\star \\le p_b + \\varepsilon$，则该订单是可立即成交的。当一个价格为 $p_s$ 的新卖出限价单进入时，如果当前的最优买价 $b^\\star$ 满足 $b^\\star + \\varepsilon \\ge p_s$，则该订单是可立即成交的。市价单总是可立即成交的。\n- 成交价格：交易以挂单的价格发生。\n- 部分成交：如果新进订单的剩余数量为 $q_\\text{in} > 0$，而价格为 $p^\\star$ 的最优对向挂单的剩余数量为 $q^\\star > 0$，则成交数量为 $\\min(q_\\text{in}, q^\\star)$。双方数量相应减少；新进订单的任何剩余部分将继续匹配；对于不可立即成交的限价单，其任何剩余部分将成为一个新的挂单。\n- 订单取消：通过标识符取消订单，会从订单簿中移除该挂单的任何剩余数量（如果该订单存在且尚未被完全执行或取消）。\n- 空边最优价：如果在结束时，买方或卖方订单簿为空，则将该边的最优价定义为 $0$。\n\n每个测试用例所需的输出指标：\n- 在处理完测试用例中的所有事件后，最终的最优买价 $b^\\star_\\text{final}$ 和最终的最优卖价 $a^\\star_\\text{final}$（如果一边为空，则使用 $0$）。\n- 总交易次数 $N_T$，其中每次与挂单的匹配都算作一次交易，即使是由单个新进订单触发的多次匹配。\n- 总成交量 $Q_T = \\sum_i q_i$，其中 $q_i$ 是第 $i$ 次交易的数量。\n- 所有交易的成交量加权平均价（VWAP）：\n$$\n\\text{VWAP} = \n\\begin{cases}\n\\frac{\\sum_i q_i p_i}{\\sum_i q_i}, & \\text{if } \\sum_i q_i > 0,\\\\\n0, & \\text{otherwise},\n\\end{cases}\n$$\n其中 $p_i$ 是第 $i$ 次交易的成交价格。\n所有浮点数输出必须四舍五入到恰好 $6$ 位小数；整数必须不带小数位打印。\n\n算法要求：\n- 因为价格是连续的，所以你不能对价格进行离散化或分桶。必须使用支持顺序统计的数据结构，例如用于最优价格提取的堆，并为每个不同的价格使用一个队列来维持时间优先。你必须处理空价格水平的惰性删除。浮点数比较必须使用给定的 $\\varepsilon$ 容差。\n- 交易执行采用价格-时间优先原则，成交价格始终是挂单的价格。\n\n测试套件：\n对于每个测试用例 $k \\in \\{1,2,3,4\\}$，都给定一个容差 $\\varepsilon_k$ 和一个事件序列 $\\{E_{k,j}\\}_{j=1}^{m_k}$。\n\n事件编码：\n- 限价单：$E=(\\text{\"limit\"}, \\text{side}, q, p, \\text{id})$，其中 $\\text{side} \\in \\{\\text{\"buy\"}, \\text{\"sell\"}\\}$，$q \\in \\mathbb{R}_{>0}$，$p \\in \\mathbb{R}_{>0}$，$\\text{id} \\in \\mathbb{Z}_{>0}$。\n- 市价单：$E=(\\text{\"market\"}, \\text{side}, q, \\text{id})$，其中 $\\text{side} \\in \\{\\text{\"buy\"}, \\text{\"sell\"}\\}$，$q \\in \\mathbb{R}_{>0}$，$\\text{id} \\in \\mathbb{Z}_{>0}$。\n- 取消订单：$E=(\\text{\"cancel\"}, \\text{id})$。\n\n测试用例 1：\n- $\\varepsilon_1 = 10^{-9}$。\n- 事件：\n  - $E_{1,1}=(\\text{\"limit\"}, \\text{\"sell\"}, 5, 101.0, 1)$。\n  - $E_{1,2}=(\\text{\"limit\"}, \\text{\"sell\"}, 3, 100.5, 2)$。\n  - $E_{1,3}=(\\text{\"limit\"}, \\text{\"buy\"}, 4, 100.0, 3)$。\n  - $E_{1,4}=(\\text{\"limit\"}, \\text{\"buy\"}, 6, 101.0, 4)$。\n\n测试用例 2（边界情况：单一价格水平上的等价和严格先进先出）：\n- $\\varepsilon_2 = 0$。\n- 事件：\n  - $E_{2,1}=(\\text{\"limit\"}, \\text{\"sell\"}, 2, 100.0, 10)$。\n  - $E_{2,2}=(\\text{\"limit\"}, \\text{\"sell\"}, 1, 100.0, 11)$。\n  - $E_{2,3}=(\\text{\"limit\"}, \\text{\"buy\"}, 3, 100.0, 12)$。\n\n测试用例 3（市价单扫过多个价格水平）：\n- $\\varepsilon_3 = 10^{-9}$。\n- 事件：\n  - $E_{3,1}=(\\text{\"limit\"}, \\text{\"sell\"}, 1, 100.0, 20)$。\n  - $E_{3,2}=(\\text{\"limit\"}, \\text{\"sell\"}, 2, 100.2, 21)$。\n  - $E_{3,3}=(\\text{\"limit\"}, \\text{\"sell\"}, 4, 101.0, 22)$。\n  - $E_{3,4}=(\\text{\"market\"}, \\text{\"buy\"}, 5, 23)$。\n\n测试用例 4（容差导致的交叉和订单取消）：\n- $\\varepsilon_4 = 10^{-3}$。\n- 事件：\n  - $E_{4,1}=(\\text{\"limit\"}, \\text{\"sell\"}, 5, 100.0001, 30)$。\n  - $E_{4,2}=(\\text{\"limit\"}, \\text{\"buy\"}, 2, 100.0, 31)$。\n  - $E_{4,3}=(\\text{\"cancel\"}, 30)$。\n  - $E_{4,4}=(\\text{\"market\"}, \\text{\"sell\"}, 1, 32)$。\n\n程序输入和输出：\n- 无外部输入。在程序中硬编码上述测试套件。\n- 对于每个测试用例，按顺序处理所有事件并计算 $[b^\\star_\\text{final}, a^\\star_\\text{final}, N_T, Q_T, \\text{VWAP}]$。\n- 你的程序应生成单行输出，其中包含一个测试用例结果的顶层列表，每个结果都是如上指定的列表，浮点数四舍五入到恰好 $6$ 位小数，且不含任何空格。例如：$[[\\dots],[\\dots],[\\dots],[\\dots]]$。\n\n约束和保证：\n- 所有数量和价格都是严格为正的实数，且在合理的金融范围内。\n- 标识符在整个测试套件中是唯一的，取消操作仅引用先前提交的标识符。\n- 匹配引擎不能对价格进行离散化；它必须遵守使用 $\\varepsilon$ 定义的连续价格比较规则。", "solution": "该问题要求设计并实现一个连续价格的限价订单簿（LOB）模拟器。该解决方案必须遵循价格-时间优先原则，处理多种订单类型，并计算特定的金融指标。解决方案的核心是一个事件驱动的模拟，它建立在精心选择的数据结构之上，这些数据结构能高效地管理订单簿的状态。\n\n**1. 基础设计：事件驱动模拟**\n\n模拟通过按时间顺序处理一系列事件来进行。LOB 的状态——包括所有买方（bid）和卖方（ask）的挂单——会根据每个事件进行更新。此设计被封装在一个 `LimitOrderBook` 类中，该类维护订单簿的状态，并包含处理事件和匹配订单的逻辑。\n\n**2. 核心数据结构**\n\n为了在连续价格环境中满足价格-时间优先规则，采用了堆和队列的组合。这种混合结构对于所需的操作是最佳的：快速检索最优价格的订单，并对相同价格的订单严格执行到达时间优先。\n\n- **价格优先（堆）**：交易必须以可用的最优价格进行。对于买单（bids），最优价格是最高价。对于卖单（asks），最优价格是最低价。\n    - **卖方订单簿** 由一个最小堆管理，它提供对最低价格（最优卖价）的 $O(1)$ 访问。Python 的 `heapq` 库用于此目的。\n    - **买方订单簿** 由一个最大堆管理。由于 `heapq` 只提供最小堆，这是通过存储买价的负值（例如，价格为 $p$ 则存为 $-p$）来实现的，这有效地反转了排序顺序，并允许最小堆以 $O(1)$ 的时间检索到最大价格。\n\n- **时间优先（队列）**：对于相同价格的订单，执行遵循先进先出（FIFO）原则。\n    - 一个字典 `price_levels` 将每个不同的价格 $p$ 映射到一个该价格下的订单队列（具体来说是 `collections.deque`）。选择 `deque` 是因为它在两端进行追加和弹出操作的效率为 $O(1)$，这对于管理订单的到达和执行非常理想。\n\n- **订单追踪（字典）**：取消订单需要通过其唯一标识符 `id` 快速查找订单。\n    - 一个字典 `orders_map` 将每个 `id` 映射到其对应的 `Order` 对象。这允许以 $O(1)$ 的时间访问任何活动订单以进行修改（例如，减少数量）或取消。定义了一个 `Order` 类来存储其 `id`、`side`、`price` 和剩余的 `quantity`。\n\n**3. 算法逻辑与执行流程**\n\n模拟器的逻辑围绕一个主事件处理循环组织。\n\n- **事件分发**：一个中央方法 `process_event` 识别事件的类型——限价单、市价单或取消订单——并将其分派给相应的处理函数。\n\n- **订单匹配引擎**：这是 LOB 的核心。当一个可成交订单到达时（市价单，或穿过买卖价差的限价单），`_match_order` 方法被调用。\n    - 一个价格为 $p_b$ 的新进买单，如果最优卖价 $a^\\star$ 满足 $a^\\star \\le p_b + \\varepsilon$，则该订单可成交。一个价格为 $p_s$ 的新进卖单，如果最优买价 $b^\\star$ 满足 $b^\\star + \\varepsilon \\ge p_s$，则该订单可成交。市价单总是可成交的。\n    - 只要新进订单的数量 $q_\\text{in} > 0$ 且对向订单簿中有可交叉的订单，匹配循环就会继续。\n    - 每一步中，它都与最优价格的挂单进行匹配。交易以挂单的价格发生。成交数量为 $\\min(q_\\text{in}, q^\\star)$，其中 $q^\\star$ 是挂单的数量。\n    - 两个订单的数量都会减少。如果挂单被完全成交，它将从其价格水平队列和 `orders_map` 中移除。如果新进订单被成交，匹配过程停止。任何不可成交的新进限价单的剩余部分随后被放入订单簿中。\n\n- **订单放置**：如果一个限价单不可立即成交，或者在匹配后仍有剩余数量，它将通过 `_add_order_to_book` 方法被添加到订单簿中。这包括将 `Order` 对象添加到相应的价格水平队列和 `orders_map` 中。如果该价格水平是新的，则价格也会被推入相应的买方或卖方堆中。\n\n- **订单取消与惰性删除**：对给定 `id` 的取消事件通过在 `orders_map` 中查找订单并将其 `quantity` 设置为 $0$ 来处理。这是一种“惰性”取消。这个“僵尸”订单对象仍保留在其队列中。\n    - 为防止这些数量为零的订单影响匹配，实现了一个 `_peek_best_price` 辅助函数。在从堆中返回最优价格之前，此函数会检查相应的价格水平队列。它通过从队列前端移除任何数量为零的订单来清理队列。如果此清理操作清空了整个价格水平，则该价格将从堆中弹出，并且该过程重复进行，直到在堆顶找到一个有效的、非空的价格水平或堆变为空。这种惰性删除机制通过避免为查找和移除空价格水平而对订单簿进行代价高昂的遍历，确保了高性能。\n\n**4. 输出指标的计算**\n\n在处理完一个测试用例中的所有事件后，计算最终指标：\n- **最优买/卖价 ($b^\\star_\\text{final}, a^\\star_\\text{final}$)**：分别使用 `_peek_best_price` 方法为买方和卖方检索这些值。如果一边为空，则价格定义为 $0$。\n- **总交易次数 ($N_T$)**：每当新进订单与挂单发生一次匹配时，计数器加一。\n- **总成交量 ($Q_T$)**：这是所有交易数量的累积总和。\n- **成交量加权平均价 (VWAP)**：计算公式为 $\\frac{\\sum_i q_i p_i}{\\sum_i q_i}$，其中 $q_i$ 和 $p_i$ 分别是每笔交易的数量和价格。在模拟期间，会维护分子 $\\sum_i q_i p_i$ 的累加和。最终的 VWAP 是这个总和除以最终的 $Q_T$。如果 $Q_T = 0$，则 VWAP 为 $0$。\n\n所有浮点数结果都按要求格式化并四舍五入到 $6$ 位小数。整个设计确保了正确性、对指定规则的遵守以及适用于高性能匹配引擎模拟的计算效率。", "answer": "```python\nimport collections\nimport heapq\n\nclass Order:\n    \"\"\"Represents an order in the book.\"\"\"\n    __slots__ = ['id', 'side', 'quantity', 'price']\n    \n    def __init__(self, id, side, quantity, price=None):\n        self.id = id\n        self.side = side\n        self.quantity = float(quantity)\n        self.price = float(price) if price is not None else None\n\nclass LimitOrderBook:\n    \"\"\"A continuous-price limit order book simulator.\"\"\"\n    \n    def __init__(self, epsilon=1e-9):\n        # Bids are a max-heap (implemented with negative prices in a min-heap)\n        self.bids = []  \n        # Asks are a min-heap\n        self.asks = []  \n        # price -> deque of orders\n        self.price_levels = collections.defaultdict(collections.deque)\n        # id -> Order object\n        self.orders_map = {}\n        self.epsilon = epsilon\n        \n        # Statistics\n        self.n_trades = 0\n        self.total_quantity = 0.0\n        self.vwap_numerator = 0.0\n\n    def _peek_best_price(self, side):\n        \"\"\"Returns the best price for a side, handling lazy deletion.\"\"\"\n        heap = self.bids if side == \"buy\" else self.asks\n        \n        while heap:\n            price_in_heap = heap[0]\n            real_price = -price_in_heap if side == \"buy\" else price_in_heap\n            \n            level_queue = self.price_levels[real_price]\n            \n            # Clean up filled/cancelled orders from the front of the queue\n            while level_queue and level_queue[0].quantity <= 0:\n                dead_order = level_queue.popleft()\n                if dead_order.id in self.orders_map:\n                    del self.orders_map[dead_order.id]\n            \n            if not level_queue:\n                # Price level is now empty, remove from heap and map\n                heapq.heappop(heap)\n                del self.price_levels[real_price]\n            else:\n                # Found a valid price level\n                return real_price\n        \n        return 0.0 # Per problem spec for empty side\n\n    def _add_order_to_book(self, order):\n        \"\"\"Adds a limit order to the book.\"\"\"\n        if order.quantity <= 0: return\n\n        # If price level is new, add price to the correct heap\n        if not self.price_levels[order.price]:\n            if order.side == \"buy\":\n                heapq.heappush(self.bids, -order.price)\n            else:\n                heapq.heappush(self.asks, order.price)\n        \n        self.price_levels[order.price].append(order)\n        self.orders_map[order.id] = order\n\n    def _match_order(self, incoming_order):\n        \"\"\"Matches an incoming order against the book.\"\"\"\n        while incoming_order.quantity > 0:\n            best_opp_price = self._peek_best_price(\"sell\" if incoming_order.side == \"buy\" else \"buy\")\n            \n            if best_opp_price == 0.0:\n                break # No liquidity on the opposing side\n\n            # Check marketability for incoming limit orders\n            is_marketable = False\n            if incoming_order.price is None: # Market order\n                is_marketable = True\n            elif incoming_order.side == \"buy\": # Buy limit\n                if best_opp_price <= incoming_order.price + self.epsilon:\n                    is_marketable = True\n            else: # Sell limit\n                if best_opp_price + self.epsilon >= incoming_order.price:\n                    is_marketable = True\n\n            if not is_marketable:\n                break # Incoming limit order is no longer aggressive enough\n\n            resting_order_queue = self.price_levels[best_opp_price]\n            \n            # Match against orders at this price level\n            while resting_order_queue and incoming_order.quantity > 0:\n                resting_order = resting_order_queue[0]\n                \n                trade_qty = min(incoming_order.quantity, resting_order.quantity)\n                \n                # Update statistics\n                self.n_trades += 1\n                self.total_quantity += trade_qty\n                # Trade happens at the resting order's price\n                self.vwap_numerator += trade_qty * resting_order.price\n                \n                # Update quantities\n                incoming_order.quantity -= trade_qty\n                resting_order.quantity -= trade_qty\n                \n                if resting_order.quantity <= 0:\n                    resting_order_queue.popleft()\n                    if resting_order.id in self.orders_map:\n                         del self.orders_map[resting_order.id]\n            \n            # If the price level was exhausted, _peek_best_price will clean it up on the next loop\n        \n        # If incoming was a limit order with residual quantity, add it to the book\n        if incoming_order.price is not None and incoming_order.quantity > 0:\n            self._add_order_to_book(incoming_order)\n\n    def process_event(self, event):\n        \"\"\"Processes a single event tuple.\"\"\"\n        event_type = event[0]\n        \n        if event_type == \"limit\":\n            _, side, qty, price, oid = event\n            order = Order(oid, side, qty, price)\n            self._match_order(order)\n            \n        elif event_type == \"market\":\n            _, side, qty, oid = event\n            order = Order(oid, side, qty, None)\n            self._match_order(order)\n\n        elif event_type == \"cancel\":\n            _, oid = event\n            if oid in self.orders_map:\n                self.orders_map[oid].quantity = 0\n\n    def get_final_metrics(self):\n        \"\"\"Returns the final metrics for the test case.\"\"\"\n        b_star = self._peek_best_price(\"buy\")\n        a_star = self._peek_best_price(\"sell\")\n        \n        vwap = 0.0\n        if self.total_quantity > 0:\n            vwap = self.vwap_numerator / self.total_quantity\n\n        return [\n            f\"{b_star:.6f}\",\n            f\"{a_star:.6f}\",\n            self.n_trades,\n            f\"{self.total_quantity:.6f}\",\n            f\"{vwap:.6f}\"\n        ]\n\ndef solve():\n    test_cases = [\n        # Test Case 1\n        (1e-9, [\n            (\"limit\", \"sell\", 5, 101.0, 1),\n            (\"limit\", \"sell\", 3, 100.5, 2),\n            (\"limit\", \"buy\", 4, 100.0, 3),\n            (\"limit\", \"buy\", 6, 101.0, 4),\n        ]),\n        # Test Case 2\n        (0.0, [\n            (\"limit\", \"sell\", 2, 100.0, 10),\n            (\"limit\", \"sell\", 1, 100.0, 11),\n            (\"limit\", \"buy\", 3, 100.0, 12),\n        ]),\n        # Test Case 3\n        (1e-9, [\n            (\"limit\", \"sell\", 1, 100.0, 20),\n            (\"limit\", \"sell\", 2, 100.2, 21),\n            (\"limit\", \"sell\", 4, 101.0, 22),\n            (\"market\", \"buy\", 5, 23),\n        ]),\n        # Test Case 4\n        (1e-3, [\n            (\"limit\", \"sell\", 5, 100.0001, 30),\n            (\"limit\", \"buy\", 2, 100.0, 31),\n            (\"cancel\", 30),\n            (\"market\", \"sell\", 1, 32),\n        ])\n    ]\n\n    all_results = []\n    for epsilon, events in test_cases:\n        lob = LimitOrderBook(epsilon)\n        for event in events:\n            lob.process_event(event)\n        \n        metrics = lob.get_final_metrics()\n        all_results.append(f\"[{','.join(map(str, metrics))}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2406545"}, {"introduction": "当你掌握了智能体策略的理论和订单簿匹配引擎的实现方法后，就可以将它们整合起来，构建一个完整的模拟来进行前沿的金融市场研究。这个综合性练习将指导你模拟一个包含高频交易者（HFT）的简化市场生态系统。你的任务是利用这个模拟平台，通过编程实验来分析“亚美分定价”这一市场微观结构政策对市场流动性、价差和交易策略的影响，亲身体验如何运用模拟作为工具来探索和评估复杂的市场动态。[@problem_id:2406579]", "problem": "构建一个完整的、可运行的程序，该程序在价格-时间优先原则下模拟一个离散时间限价订单簿，以研究允许次分位定价对订单队列动态和程式化高频交易（HFT）策略的影响。模型必须按如下方式定义。\n\n资产具有一个以任意货币单位计量的固定参考水平价格 $P^{\\ast}$。价格被限制在一个价格跳动单位为 $\\Delta p$ 的网格上，因此任何报价都必须是 $\\Delta p$ 的倍数。将基准最优买入价和最优卖出价初始化为 $B_0 = P^{\\ast} - \\Delta p$ 和 $A_0 = P^{\\ast} + \\Delta p$。将基准最优买入队列规模 $Q^0_B$ 和最优卖出队列规模 $Q^0_A$（以单位计）初始化，两者均为整数。时间是离散的，步长为 $t \\in \\{1,2,\\ldots,T\\}$。在每个时间步，根据总和为 $1$ 的概率 $p_{\\text{MB}}$、$p_{\\text{MS}}$、$p_{\\text{LB}}$、$p_{\\text{LS}}$ 和 $p_{\\text{C}}$ 的分类分布，独立于过去发生一个事件。五种事件类型是：\n- 市价买单（MB），单位规模为 $1$：如果当前最优卖出队列可用，则从中移除 $1$ 个单位。\n- 市价卖单（MS），单位规模为 $1$：如果当前最优买入队列可用，则从中移除 $1$ 个单位。\n- 基准限价买单（LB），单位规模为 $1$：在价格 $B_t$ 处向基准最优买入队列添加 $1$ 个单位。\n- 基准限价卖单（LS），单位规模为 $1$：在价格 $A_t$ 处向基准最优卖出队列添加 $1$ 个单位。\n- 基准取消订单（C），单位规模为 $1$：从当前规模严格为正的基准最优队列中恰好一个队列移除 $1$ 个单位，在该类队列中均匀随机选择；如果两个基准最优队列都为空，则此事件无效果。\n\n价格-时间优先原则意味着交易在最高买价和最低卖价执行；在同一价格水平内，执行优先级为先进先出，但由于模拟聚合了每侧同质的单位规模订单，因此只需相应地更新聚合队列规模即可。对于所有 $t$，基准订单的价格 $B_t$ 和 $A_t$ 保持固定在 $B_t = P^{\\ast} - \\Delta p$ 和 $A_t = P^{\\ast} + \\Delta p$。\n\n引入一个程式化高频交易（HFT）代理，其特征由以下参数定义：HFT挂单数量 $q_{\\text{HFT}} \\in \\mathbb{Z}_{\\ge 0}$（单位）及其限价订单的生存时间 $\\tau \\in \\mathbb{Z}_{\\ge 1}$（步）。HFT代理被允许在任何时候最多在一侧将价格相对于基准最优价改善一个价格跳动单位，这之所以可行，仅因为价格网格允许这样的价格改善。HFT代理遵循以下规则：\n- 激活：在LB事件之后，如果 $q_{\\text{HFT}} \\ge 1$，HFT立即在改善后的价格 $P^{\\ast}$（比基准最优买入价好一个价格跳动单位）发布一个规模为 $q_{\\text{HFT}}$ 的买入限价单。在LS事件之后，如果 $q_{\\text{HFT}} \\ge 1$，HFT立即在改善后的价格 $P^{\\ast}$（比基准最优卖出价好一个价格跳动单位）发布一个规模为 $q_{\\text{HFT}}$ 的卖出限价单。如果HFT在另一侧已有活动订单，则该订单在本次激活时被取消。在激活（或在同侧重新激活）时，HFT订单的剩余数量设置为 $q_{\\text{HFT}}$，其剩余生存时间设置为 $\\tau$。\n- 优先级和价差：如果HFT在价格 $P^{\\ast}$ 有活动买单，则当前最优买入价变为 $P^{\\ast}$，而最优卖出价保持在 $A_t = P^{\\ast} + \\Delta p$，产生当前价差为 $\\Delta p$。如果HFT在价格 $P^{\\ast}$ 有活动卖单，则当前最优卖出价变为 $P^{\\ast}$，而最优买入价保持在 $B_t = P^{\\ast} - \\Delta p$，产生当前价差为 $\\Delta p$。如果HFT没有活动订单，价差等于 $2\\Delta p$。\n- 针对市价单的执行：由于价格更优，市价买单（或市价卖单）首先与任何活动的HFT卖单（或HFT买单）执行。如果HFT订单在该侧存在且剩余数量严格为正，则成交一个单位，使HFT的剩余数量减少 $1$，并且HFT立即通过向另一侧的基准最优队列提交一个单位规模的对冲市价单来中和库存，如果可用，这将使另一侧的基准队列减少 $1$。如果相关侧没有HFT订单，则市价单（如果可用）会消耗相应基准最优队列的 $1$ 个单位。\n- HFT订单生命周期：在每个时间步结束时，如果HFT有活动订单，其剩余生存时间减少 $1$。如果剩余生存时间达到 $0$ 或剩余数量达到 $0$，HFT将取消其订单（不再活动）。\n- HFT利润核算：每个成交的HFT单位立即产生已实现利润，该利润等于另一侧执行价格与HFT改善后价格之间的同期价差，在此模型中，每成交一个HFT单位，该利润等于 $\\Delta p$。如果在时间步 $t$ 没有HFT成交发生，则HFT在 $t$ 的利润为 $0$。\n\n在时间范围 $\\{1,\\ldots,T\\}$ 内计算以下性能统计数据：\n- 平均价差：$\\frac{1}{T}\\sum_{t=1}^{T} \\left(A^{\\text{best}}_t - B^{\\text{best}}_t\\right)$，其中 $A^{\\text{best}}_t$ 和 $B^{\\text{best}}_t$ 是由上述HFT激活规则在时间 $t$ 所隐含的最优卖出价和最优买入价。\n- HFT每步成交率：HFT单位成交总数除以 $T$。\n- HFT每步平均利润：HFT总利润除以 $T$。\n- 基准最优队列平均规模：$\\frac{1}{T}\\sum_{t=1}^{T} \\left(Q_{B,t} + Q_{A,t}\\right)$，其中 $Q_{B,t}$ 和 $Q_{A,t}$ 是在步骤 $t$ 结束时的基准最优买入和最优卖出队列规模。\n\n除价格以任意货币单位计量外，所有数量均无单位。不涉及角度或物理单位。所有答案必须以浮点数表示。\n\n您的程序必须为以下测试套件运行模拟。每个元组列出 $(\\Delta p, T, q_{\\text{HFT}}, \\tau, \\text{seed}, (p_{\\text{MB}}, p_{\\text{MS}}, p_{\\text{LB}}, p_{\\text{LS}}, p_{\\text{C}}))$。在所有测试用例中，使用 $P^{\\ast} = 100$，$Q^0_B = 10$，$Q^0_A = 10$，以及所有市价单、基准限价单和取消订单的单位规模均为 $1$。\n- 情况1：$(0.01, 50000, 1, 50, 123, (0.2, 0.2, 0.25, 0.25, 0.1))$\n- 情况2：$(0.001, 50000, 1, 50, 456, (0.2, 0.2, 0.25, 0.25, 0.1))$\n- 情况3：$(0.001, 50000, 0, 50, 789, (0.2, 0.2, 0.25, 0.25, 0.1))$\n- 情况4：$(0.005, 50000, 1, 50, 321, (0.2, 0.2, 0.25, 0.25, 0.1))$\n- 情况5：$(0.001, 50000, 1, 50, 654, (0.15, 0.15, 0.15, 0.15, 0.4))$\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身是一个包含浮点数的列表 $[\\text{avg\\_spread}, \\text{hft\\_fill\\_rate}, \\text{hft\\_profit\\_per\\_step}, \\text{avg\\_baseline\\_queue}]$。例如，输出格式必须为\n$[[x_{1,1},x_{1,2},x_{1,3},x_{1,4}],[x_{2,1},x_{2,2},x_{2,3},x_{2,4}],[x_{3,1},x_{3,2},x_{3,3},x_{3,4}],[x_{4,1},x_{4,2},x_{4,3},x_{4,4}],[x_{5,1},x_{5,2},x_{5,3},x_{5,4}]]$\n，行内任何地方都不能有空格。", "solution": "该问题要求构建一个离散时间限价订单簿（LOB）的模拟模型，以分析高频交易（HFT）策略的影响。该问题是良构的，在计算金融领域有其科学依据，其参数和规则的规定足够详细，可以得出一个唯一的、可复现的解。\n\n解决方案是对指定随机过程的直接实现。解决方案的核心是一个函数，该函数模拟LOB在 $T$ 个时间步长的时间范围内的演化。\n\n**1. 状态表示**\n在任何离散时间步 $t$，系统的状态由一组变量完全描述：\n- $Q_{B,t}$：在价格 $P^{\\ast} - \\Delta p$ 的基准最优买入队列中的静止单位数量。\n- $Q_{A,t}$：在价格 $P^{\\ast} + \\Delta p$ 的基准最优卖出队列中的静止单位数量。\n- HFT订单状态：一个表示HFT单个活动订单的结构，由其方向（买入或卖出）、剩余数量 $q_{\\text{rem}}$ 和剩余生存时间（TTL）$\\tau_{\\text{rem}}$ 定义。如果没有活动订单，其状态标记为“无”。\n\n模拟在 $t=0$ 开始，初始队列规模为 $Q^0_B$ 和 $Q^0_A$，并且没有活动的HFT订单。\n\n**2. 模拟动态**\n模拟从 $t=1$ 进行到 $T$。在每个时间步内，遵循严格的操作序列来更新LOB的状态。\n\n**步骤 2.1：事件生成**\n在每个步骤 $t$ 的开始，从由概率 $(p_{\\text{MB}}, p_{\\text{MS}}, p_{\\text{LB}}, p_{\\text{LS}}, p_{\\text{C}})$ 定义的分类分布中抽取一个单一事件。五种可能的事件是：市价买单（MB）、市价卖单（MS）、基准限价买单（LB）、基准限价卖单（LS）和基准取消订单（C）。\n\n**步骤 2.2：状态转移逻辑**\n系统状态根据抽取的事件和HFT代理的规则进行更新。\n\n- **市价单 (MB, MS):** 如果HFT在更优价格（价格 $P^{\\ast}$）存在订单，市价单首先消耗HFT的流动性。市价买单（MB）消耗HFT的卖单，市价卖单（MS）消耗HFT的买单。\n    - 每成交一个单位，HFT的订单数量 $q_{\\text{rem}}$ 递减。\n    - HFT的总成交量增加 $1$，其总利润增加定义的每次成交利润 $\\Delta p$。\n    - HFT通过向另一侧的基准队列发送一个规模为 $1$ 的对冲市价单，立即中和其获得的头寸。例如，在HFT买单成交后，HFT提交一个市价买单，消耗基准卖出队列 $Q_{A,t}$ 中的一个单位。\n    - 如果相应一侧没有可用的HFT订单，市价单会从相应的基准队列（MB对应 $Q_{A,t}$，MS对应 $Q_{B,t}$）中消耗一个单位，前提是队列不为空。\n\n- **基准限价单 (LB, LS):** 基准限价买单（LB）使 $Q_{B,t}$ 增加 $1$，基准限价卖单（LS）使 $Q_{A,t}$ 增加 $1$。\n    - 紧随LB或LS事件之后，HFT代理（如果 $q_{\\text{HFT}} \\ge 1$）在改善后的价格 $P^{\\ast}$ 放置一个规模为 $q_{\\text{HFT}}$、TTL为 $\\tau$ 的新限价单。LB触发HFT买单，LS触发HFT卖单。\n    - 发布新的HFT订单会取消任何已存在的HFT订单，确保HFT在订单簿的最多一侧是活动的。激活一个订单会将其数量重置为 $q_{\\text{HFT}}$，TTL重置为 $\\tau$。\n\n- **基准取消订单 (C):** 从非空的基准队列之一（$Q_{B,t}$ 或 $Q_{A,t}$）中移除一个单位。如果两者都非空，则均匀随机选择一个。如果只有一个非空，则选择它。如果两者都为空，则无效果。\n\n**步骤 2.3：步末更新**\n在事件逻辑完全解决后，执行步末更新。\n- **HFT订单生命周期:** 如果一个HFT订单是活动的，其TTL $\\tau_{\\text{rem}}$ 递减 $1$。然后检查订单是否应取消。如果其TTL已达到 $0$ 或其剩余数量 $q_{\\text{rem}}$ 已达到 $0$，则该订单从订单簿中移除（其状态设置为“无”）。\n\n**3. 指标计算**\n性能统计数据在 $T$ 个时间步上进行聚合。在每个步骤 $t$ 结束时，在所有状态转移和取消操作处理完毕后，记录以下指标：\n\n- **价差:** 计算最优买卖价差 $A^{\\text{best}}_t - B^{\\text{best}}_t$。如果HFT有活动订单（在取消检查后），价差为 $\\Delta p$。否则，价差由基准队列决定，为 $2\\Delta p$。\n- **基准队列规模:** 记录基准队列的总规模 $Q_{B,t} + Q_{A,t}$。\n\n模拟完成后，通过将累计总数除以 $T$ 来计算最终的平均指标：\n- 平均价差: $\\frac{1}{T}\\sum_{t=1}^{T} (A^{\\text{best}}_t - B^{\\text{best}}_t)$\n- HFT成交率: $\\frac{1}{T} \\times (\\text{HFT总成交数})$\n- HFT平均利润: $\\frac{1}{T} \\times (\\text{HFT总利润})$\n- 平均基准队列规模: $\\frac{1}{T}\\sum_{t=1}^{T} (Q_{B,t} + Q_{A,t})$\n\n**4. 实现**\n模拟是使用Python实现的，利用 `numpy` 库进行可复现的随机数生成，每个测试用例由指定的种子控制。上述逻辑被封装在一个以模型参数为输入的函数中。一个主函数遍历所提供的测试用例，调用模拟，并将结果格式化为所要求的精确字符串格式。", "answer": "```python\nimport numpy as np\n\ndef run_simulation(delta_p, T, q_hft, tau, seed, probs):\n    \"\"\"\n    Runs a single simulation of the limit order book model.\n    \"\"\"\n    # Fixed parameters\n    P_star = 100.0\n    Q0_B = 10\n    Q0_A = 10\n    \n    # State variables\n    q_b = Q0_B\n    q_a = Q0_A\n    hft_order = {'side': 'none', 'qty': 0, 'ttl': 0}\n\n    # Statistics accumulators\n    total_spread = 0.0\n    total_hft_fills = 0\n    total_hft_profit = 0.0\n    total_baseline_queue_size = 0.0\n\n    # Setup random number generator\n    rng = np.random.default_rng(seed)\n    events = ['MB', 'MS', 'LB', 'LS', 'C']\n\n    for _ in range(T):\n        # Step 1: Draw event\n        event = rng.choice(events, p=probs)\n        \n        # Step 2: State Transition Logic\n        if event == 'MB':  # Market Buy\n            if hft_order['side'] == 'sell' and hft_order['qty'] > 0:\n                hft_order['qty'] -= 1\n                total_hft_fills += 1\n                total_hft_profit += delta_p\n                # HFT offset order (market sell against baseline bid)\n                if q_b > 0:\n                    q_b -= 1\n            else:\n                if q_a > 0:\n                    q_a -= 1\n        \n        elif event == 'MS':  # Market Sell\n            if hft_order['side'] == 'buy' and hft_order['qty'] > 0:\n                hft_order['qty'] -= 1\n                total_hft_fills += 1\n                total_hft_profit += delta_p\n                # HFT offset order (market buy against baseline ask)\n                if q_a > 0:\n                    q_a -= 1\n            else:\n                if q_b > 0:\n                    q_b -= 1\n        \n        elif event == 'LB':  # Baseline Limit Buy\n            q_b += 1\n            if q_hft >= 1:\n                hft_order = {'side': 'buy', 'qty': q_hft, 'ttl': tau}\n        \n        elif event == 'LS':  # Baseline Limit Sell\n            q_a += 1\n            if q_hft >= 1:\n                hft_order = {'side': 'sell', 'qty': q_hft, 'ttl': tau}\n        \n        elif event == 'C':  # Baseline Cancellation\n            can_cancel_b = q_b > 0\n            can_cancel_a = q_a > 0\n            if can_cancel_b and can_cancel_a:\n                if rng.random() < 0.5:\n                    q_b -= 1\n                else:\n                    q_a -= 1\n            elif can_cancel_b:\n                q_b -= 1\n            elif can_cancel_a:\n                q_a -= 1\n\n        # Step 3: End-of-step HFT order lifecycle update\n        if hft_order['side'] != 'none':\n            hft_order['ttl'] -= 1\n            if hft_order['ttl'] <= 0 or hft_order['qty'] <= 0:\n                hft_order = {'side': 'none', 'qty': 0, 'ttl': 0}\n\n        # Step 4: Calculate and accumulate metrics for the current step t\n        current_spread = 2.0 * delta_p\n        if hft_order['side'] != 'none':\n            current_spread = delta_p\n        \n        total_spread += current_spread\n        total_baseline_queue_size += (q_b + q_a)\n\n    # Final calculation of average metrics\n    avg_spread = total_spread / T\n    hft_fill_rate = total_hft_fills / T\n    hft_avg_profit = total_hft_profit / T\n    avg_baseline_queue = total_baseline_queue_size / T\n\n    return [avg_spread, hft_fill_rate, hft_avg_profit, avg_baseline_queue]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.01, 50000, 1, 50, 123, (0.2, 0.2, 0.25, 0.25, 0.1)),\n        (0.001, 50000, 1, 50, 456, (0.2, 0.2, 0.25, 0.25, 0.1)),\n        (0.001, 50000, 0, 50, 789, (0.2, 0.2, 0.25, 0.25, 0.1)),\n        (0.005, 50000, 1, 50, 321, (0.2, 0.2, 0.25, 0.25, 0.1)),\n        (0.001, 50000, 1, 50, 654, (0.15, 0.15, 0.15, 0.15, 0.4)),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        delta_p, T, q_hft, tau, seed, probs = case\n        result = run_simulation(delta_p, T, q_hft, tau, seed, probs)\n        all_results.append(result)\n\n    # Format the output string exactly as specified\n    result_strings = []\n    for res_list in all_results:\n        # Format each float to a reasonable precision to avoid excessive length\n        inner_str = f\"[{','.join(f'{x:.8f}' for x in res_list)}]\"\n        result_strings.append(inner_str)\n    \n    final_output = f\"[[{','.join(result_strings)}]]\"\n    \n    print(final_output.replace(\" \", \"\"))\n\nsolve()\n```", "id": "2406579"}]}