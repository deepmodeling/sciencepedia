{"hands_on_practices": [{"introduction": "对随机波动率模型下的期权进行定价是现代金融领域的一项基本挑战。与简洁的Black-Scholes模型不同，Heston模型没有简单的闭式解。本练习将引导你运用一种强大且广泛应用的半解析方法，即结合特征函数与傅里叶逆变换来推导期权价格。通过对该公式进行数值实现，你将构建一个强大的定价引擎，这是任何量化金融从业者必备的核心技能。[@problem_id:2430270]", "problem": "您的任务是推导并实现一种数值方法，用于在与计算经济学和金融学相关的随机波动率背景下，为欧式看涨期权定价。标的资产价格遵循具有平方根方差动态的仿射随机波动率模型。您的目标是将风险中性定价、特征函数和傅里叶逆变换联系起来，并使用辛普森法则对所得积分进行求值。\n\n从以下基本概念开始：\n- 风险中性定价：对于一个行权价为 $K$、到期日为 $T$ 的欧式看涨期权，其标的资产当前价格为 $S_0$，无风险利率为 $r$ (连续复利)，则该期权在时间 $0$ 的价格 $C$ 满足\n  \n$$\n  C = e^{-r T} \\mathbb{E}^{\\mathbb{Q}}\\left[\\left(S_T - K\\right)^{+}\\right],\n  $$\n\n  其中 $\\mathbb{Q}$ 表示风险中性测度，$(\\cdot)^{+}$ 表示取正部。\n- 特征函数定义：对于一个实值随机变量 $X$，其特征函数 $\\varphi_X(u)$ 为\n  \n$$\n  \\varphi_X(u) = \\mathbb{E}\\left[e^{i u X}\\right],\n  $$\n\n  其中 $i$ 是虚数单位，所有角度变量均以弧度度量。\n- 傅里叶逆变换：对于一个可积函数，通过适当的阻尼以确保平方可积性，该函数可以通过对频率（以弧度为单位）进行积分，使用傅里叶逆变换来恢复。\n\n模型：\n- 对数价格过程 $X_t = \\ln S_t$ 在到期日 $T$ 的特征函数依赖于一组参数 $\\kappa$、$\\theta$、$\\nu$、$\\rho$ 和 $v_0$，其中 $\\kappa > 0$ 是方差的均值回归速度，$\\theta > 0$ 是长期方差水平，$\\nu > 0$ 是方差的波动率，$\\rho \\in [-1,1]$ 是资产与方差冲击之间的瞬时相关性， $v_0 > 0$ 是初始方差。假设没有股息。\n\n您的任务：\n1. 从风险中性定价表达式和特征函数的定义出发，推导出一个看涨期权价格的单积分傅里叶逆变换表达式。该表达式使用一个阻尼参数 $\\alpha > 0$ 来保证在对数行权价下，带阻尼的收益函数的可积性。明确地根据 $X_T = \\ln S_T$ 的特征函数来论证被积函数的形式。陈述所有关于 $\\alpha$ 和角度单位的必要条件。\n2. 将特征函数具体化到仿射平方根（Heston）随机波动率模型的动态 $(S_t, V_t)$，推导出以 $\\kappa$、$\\theta$、$\\nu$、$\\rho$、$v_0$、$S_0$、$r$ 和 $T$ 表示的闭式特征函数 $\\varphi_{X_T}(u)$，并解释为保持特征指数的连续性，复数平方根和对数的分支选择所起的作用。\n3. 设计一个辛普森法则方案来对所得积分进行数值求值。使用偶数个子区间 $N$ 和一个频率上限 $U_{\\max} > 0$。解释复合辛普森权重是如何构造的，并说明关于步长的全局截断误差阶数。指明频率变量以弧度为单位，并确保积分的角度依赖性得到一致处理。\n4. 实现一个程序，该程序：\n   - 对于下面测试套件中的每一组参数，通过您的傅里叶逆变换和辛普森法则来计算看涨期权价格。\n   - 使用阻尼参数 $\\alpha = 1.5$，频率上限 $U_{\\max} = 200.0$，以及 $N = 4096$ 个子区间用于复合辛普森法则（注意 $N$ 必须是偶数）。\n   - 将每个计算出的价格四舍五入到六位小数。\n\n测试套件（每行是 $(S_0, K, T, r, \\kappa, \\theta, \\nu, \\rho, v_0)$）：\n- 案例 A（基准，负相关）：$(\\$100.0$, \\$100.0$, $1.0$, $0.05$, $1.5$, $0.04$, $0.3$, $-0.7$, $0.04 )$。\n- 案例 B（零相关）：$(\\$100.0$, \\$100.0$, $1.0$, $0.05$, $1.5$, $0.04$, $0.3$, $0.0$, $0.04 )$。\n- 案例 C（高正相关）：$(\\$100.0$, \\$100.0$, $1.0$, $0.05$, $1.5$, $0.04$, $0.3$, $0.9$, $0.04 )$。\n- 案例 D（短期，价外）：$(\\$100.0$, \\$120.0$, $0.01$, $0.02$, $2.0$, $0.04$, $0.5$, $-0.5$, $0.04 )$。\n\n角度单位：所有傅里叶频率和参数必须以弧度处理。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个价格都四舍五入到六位小数，顺序与测试套件相同，例如 $[x_A,x_B,x_C,x_D]$。不应打印任何额外文本。\n\n您的实现必须是一个完整、可运行的程序。它不能读取任何输入。所有数值应以一致的货币单位（例如，美元）处理，但输出是无单位的数值。最终答案必须是浮点数。", "solution": "问题要求在 Heston 随机波动率模型下，推导并实现一种基于傅里叶变换的方法来为欧式看涨期权定价。定价积分将使用辛普森法则进行数值评估。这个问题在科学上是合理的，提法是适定的，并且所有必要的参数都已提供。\n\n在此，我将逐步进行解决方案的推导和设计。\n\n### 任务1：看涨期权傅里叶逆变换公式的推导\n\n欧式看涨期权在时间 $0$ 的价格 $C$（行权价为 $K$，到期日为 $T$）由其贴现收益的风险中性期望给出：\n$$\nC(K, T) = e^{-rT} \\mathbb{E}^{\\mathbb{Q}}\\left[(S_T - K)^+\\right]\n$$\n其中 $S_T$ 是到期时的资产价格，$r$ 是无风险利率，$\\mathbb{Q}$ 是风险中性测度。符号 $(x)^+$ 代表 $\\max(x, 0)$。\n\n收益函数 $(S_T - K)^+$ 不在 $L^1(\\mathbb{R})$ 中，因此其傅里叶变换没有明确定义。Carr 和 Madan 引入的一种标准方法是对一个具有更好可积性的修正后期权价格函数应用傅里叶变换。设 $k = \\ln K$ 为对数行权价。看涨期权价格作为 $k$ 的函数 $C(k)$，在 $k \\to -\\infty$ 时不衰减，这使其不适用于傅里叶分析。\n\n我们定义一个带阻尼的看涨期权价格函数 $c_T(k) = e^{\\alpha k} C(k)$，其中 $\\alpha > 0$ 是一个实值阻尼参数。对于合适的 $\\alpha$ 选择，$c_T(k)$ 是平方可积的，即 $c_T(k) \\in L^2(\\mathbb{R})$，且其傅里叶变换存在。\n$c_T(k)$ 的傅里叶变换由下式给出：\n$$\n\\hat{c}_T(u) = \\int_{-\\infty}^{\\infty} e^{iuk} c_T(k) dk = \\int_{-\\infty}^{\\infty} e^{iuk} e^{\\alpha k} C(k) dk\n$$\n原始看涨期权价格随后可以通过傅里叶逆变换恢复：\n$$\nC(k) = e^{-\\alpha k} c_T(k) = \\frac{e^{-\\alpha k}}{2\\pi} \\int_{-\\infty}^{\\infty} e^{-iuk} \\hat{c}_T(u) du\n$$\n为了找到 $\\hat{c}_T(u)$，我们代入 $C(k)$ 的定义并交换积分顺序（由 Tonelli 定理保证）：\n$$\n\\hat{c}_T(u) = \\int_{-\\infty}^{\\infty} e^{(\\alpha+iu)k} \\left( e^{-rT} \\mathbb{E}^{\\mathbb{Q}}\\left[(e^{x_T} - e^k)^+\\right] \\right) dk\n= e^{-rT} \\mathbb{E}^{\\mathbb{Q}}\\left[ \\int_{-\\infty}^{\\infty} e^{(\\alpha+iu)k} (e^{x_T} - e^k)^+ dk \\right]\n$$\n其中 $x_T = \\ln S_T$。内部积分仅在 $k \\le x_T$ 时非零：\n$$\n\\int_{-\\infty}^{x_T} e^{(\\alpha+iu)k} (e^{x_T} - e^k) dk = \\int_{-\\infty}^{x_T} (e^{x_T}e^{(\\alpha+iu)k} - e^{(\\alpha+1+iu)k}) dk\n$$\n为了使该积分在 $k \\to -\\infty$ 时收敛，我们需要 $\\text{Re}(\\alpha+iu) = \\alpha > 0$ 和 $\\text{Re}(\\alpha+1+iu) = \\alpha+1 > 0$。如果 $\\alpha > 0$，这两个条件都满足。计算该积分得到：\n$$\n\\left[ \\frac{e^{x_T} e^{(\\alpha+iu)k}}{\\alpha+iu} - \\frac{e^{(\\alpha+1+iu)k}}{\\alpha+1+iu} \\right]_{-\\infty}^{x_T} = \\frac{e^{x_T} e^{(\\alpha+iu)x_T}}{\\alpha+iu} - \\frac{e^{(\\alpha+1+iu)x_T}}{\\alpha+1+iu} = \\frac{e^{(\\alpha+1+iu)x_T}}{(\\alpha+iu)(\\alpha+1+iu)}\n$$\n取期望得到 $\\hat{c}_T(u)$：\n$$\n\\hat{c}_T(u) = \\frac{e^{-rT}}{(\\alpha+iu)(\\alpha+1+iu)} \\mathbb{E}^{\\mathbb{Q}}\\left[ e^{(\\alpha+1+iu)x_T} \\right]\n$$\n期望项与 $x_T$ 的特征函数 $\\varphi_{x_T}(z) = \\mathbb{E}^{\\mathbb{Q}}[e^{izx_T}]$ 相关。我们有：\n$$\n\\mathbb{E}^{\\mathbb{Q}}\\left[ e^{(\\alpha+1+iu)x_T} \\right] = \\mathbb{E}^{\\mathbb{Q}}\\left[ e^{i(u-i(\\alpha+1))x_T} \\right] = \\varphi_{x_T}(u - i(\\alpha+1))\n$$\n因此，带阻尼的看涨期权价格的傅里叶变换为：\n$$\n\\hat{c}_T(u) = \\frac{e^{-rT} \\varphi_{x_T}(u-i(\\alpha+1))}{(\\alpha+iu)(\\alpha+1+iu)}\n$$\n看涨期权价格随后通过逆变换恢复。由于 $C(k)$ 是实数，$\\hat{c}_T(u)$ 是共轭对称的，即 $\\hat{c}_T(-u) = \\overline{\\hat{c}_T(u)}$。这使我们能够将逆变换积分从 $(-\\infty, \\infty)$ 简化到 $(0, \\infty)$：\n$$\n\\int_{-\\infty}^{\\infty} e^{-iuk} \\hat{c}_T(u) du = 2 \\int_0^{\\infty} \\text{Re}\\left[e^{-iuk} \\hat{c}_T(u)\\right] du\n$$\n最终的定价公式是一个单一的实值积分：\n$$\nC(K) = \\frac{e^{-\\alpha \\ln K}}{\\pi} \\int_{0}^{\\infty} \\text{Re}\\left( e^{-iu \\ln K} \\frac{e^{-rT} \\varphi_{x_T}(u-i(\\alpha+1))}{(\\alpha+iu)(\\alpha+1+iu)} \\right) du\n$$\n**条件**：\n1.  **阻尼参数 $\\alpha$**：对于推导中的积分收敛，$\\alpha$ 必须为正 ($\\alpha > 0$)。此外，量 $\\alpha+1$ 必须位于 $x_T$ 的矩生成函数 $\\mathbb{E}[e^{\\gamma x_T}]$ 的收敛带内。对于 Heston 模型，此条件对一定范围内的正 $\\alpha$ 都成立。给定的 $\\alpha=1.5$ 是一个有效选择。\n2.  **角度单位**：频率变量 $u$ 的单位是弧度/对数价格单位。所有角度量，例如复数的辐角，都必须统一以弧度处理。\n\n### 任务2：Heston 模型特征函数\n\n在风险中性测度 $\\mathbb{Q}$ 下，Heston 模型的动态由以下随机微分方程组给出：\n$$\n\\begin{aligned}\ndS_t &= r S_t dt + \\sqrt{V_t} S_t dW_{1,t} \\\\\ndV_t &= \\kappa(\\theta - V_t) dt + \\nu \\sqrt{V_t} dW_{2,t}\n\\end{aligned}\n$$\n其中 $\\mathbb{E}^{\\mathbb{Q}}[dW_{1,t}dW_{2,t}] = \\rho dt$。对数价格 $x_t = \\ln S_t$ 遵循 $dx_t = (r - V_t/2) dt + \\sqrt{V_t} dW_{1,t}$。\n\n$x_T$ 的特征函数 $\\varphi_{x_T}(u) = \\mathbb{E}^{\\mathbb{Q}}[e^{iu x_T} | \\mathcal{F}_0]$ 已知具有仿射指数形式：\n$$\n\\varphi_{x_T}(u) = \\exp(C(T, u) + D(T, u)v_0 + iu x_0)\n$$\n其中 $x_0 = \\ln S_0$，$v_0$ 是初始方差，$\\tau = T$ 是到期时间。函数 $C(\\tau, u)$ 和 $D(\\tau, u)$ 是一类 Riccati 型常微分方程组的解。它们的闭式解为：\n$$\n\\begin{aligned}\nC(\\tau, u) &= iur\\tau + \\frac{\\kappa\\theta}{\\nu^2}\\left[ (\\kappa-i\\rho\\nu u-d)\\tau - 2\\ln\\left( \\frac{1-ge^{-d\\tau}}{1-g} \\right) \\right] \\\\\nD(\\tau, u) &= \\frac{\\kappa-i\\rho\\nu u-d}{\\nu^2}\\left[ \\frac{1-e^{-d\\tau}}{1-ge^{-d\\tau}} \\right]\n\\end{aligned}\n$$\n其中\n$$\n\\begin{aligned}\nd &= \\sqrt{(\\kappa - i\\rho\\nu u)^2 + \\nu^2(u^2+iu)} \\\\\ng &= \\frac{\\kappa - i\\rho\\nu u - d}{\\kappa - i\\rho\\nu u + d}\n\\end{aligned}\n$$\n对于定价公式，我们需要在复数参数 $z = u - i(\\alpha+1)$ 处评估此函数。这可以通过在上述表达式中用 $z$ 替换 $u$ 来实现。\n\n**复变函数的分支选择**：\n$d$ 和 $C$ 的表达式涉及复数平方根和对数函数，它们是多值的。\n1.  **复数平方根**：对于 $d = \\sqrt{\\cdot}$，我们必须选择一个使 $d$ 成为 $u$ 的连续函数的分支。标准选择是主分支，它能确保 $\\text{Re}(d) \\ge 0$。这对模型的稳定性至关重要，因为它保证了诸如 $e^{-d\\tau}$ 之类的项在 $\\tau \\to \\infty$ 时会衰减或保持有界。\n2.  **复数对数**：项 $\\ln(\\cdot)$ 也必须在单个连续的分支上计算。典型方法是定义 $\\ln(z) = \\ln|z| + i \\cdot \\text{arg}(z)$，并对辐角 $\\text{arg}(z)$ 进行“展开”，以确保它从 $u=0$ 时的值（即 $0$）开始连续变化，从而避免 $\\pm 2\\pi$ 的伪跳跃。在数值实现中，这通常由标准库的复数函数隐式处理，但其根本的数学要求是连续性。\n\n### 任务3：用于数值积分的辛普森法则\n\n任务是使用复合辛普森法则来近似积分 $I = \\int_0^{U_{\\max}} f(u) du$，其中 $f(u)$ 是在任务1中推导的复数被积函数的实部。我们将积分区间 $[0, U_{\\max}]$ 分成偶数个 $N$ 子区间，每个子区间的宽度为 $\\Delta u = U_{\\max} / N$。这将创建 $N+1$ 个网格点 $u_j = j \\Delta u$，其中 $j=0, 1, ..., N$。\n\n复合辛普森法则通过对跨越相邻子区间对拟合的二次多项式下的面积求和来近似积分。近似值由下式给出：\n$$\nI \\approx \\frac{\\Delta u}{3} \\sum_{j=0}^{N} w_j f(u_j)\n$$\n权重 $w_j$ 的构造如下：\n-   $w_0 = 1$\n-   $w_N = 1$\n-   奇数索引 $j \\in \\{1, 3, \\dots, N-1\\}$ 的 $w_j = 4$\n-   偶数索引 $j \\in \\{2, 4, \\dots, N-2\\}$ 的 $w_j = 2$\n这个权重方案可以概括为 $[1, 4, 2, 4, \\dots, 2, 4, 1]$。\n\n对于一个足够光滑的函数 $f$（具体来说是 $f \\in C^4([0, U_{\\max}])$），复合辛普森法则的全局截断误差在步长 $\\Delta u$ 上是四阶的。误差由下式给出：\n$$\nE = -\\frac{U_{\\max}}{180} (\\Delta u)^4 f^{(4)}(\\xi)\n$$\n其中某个 $\\xi \\in [0, U_{\\max}]$。因此，对于足够大的子区间数 $N$，该方法非常精确。\n\n### 任务4：实现设计\n\n实现将遵循推导出的公式。\n1.  将创建一个函数 `heston_char_func` 来计算 Heston 特征函数 $\\varphi_{x_T}(z)$，其中 $z$ 是一个复数参数。该函数将封装 $C(\\tau,z)$ 和 $D(\\tau,z)$ 的公式。它将使用 `numpy` 进行向量化的复数运算。\n2.  一个主定价函数将设置从 $0$ 到 $U_{\\max}$ 的数值积分网格，包含 $N=4096$ 个子区间。\n3.  对于网格上的每个点 $u_j$，将计算复数参数 $z_j = u_j - i(\\alpha+1)$。\n4.  将使用 $z_j$ 值的数组调用 `heston_char_func` 函数，以获得相应的特征函数值。\n5.  将为每个 $u_j$ 计算完整的被积函数，包括前置因子和分母。然后我们取其实部。\n6.  通过将辛普森法则的权重应用于被积函数值的数组并求和，再乘以 $\\Delta u/3$ 来计算积分。\n7.  最后，将积分结果乘以外部因子 $K^{-\\alpha}/\\pi$ 得到看涨期权价格。对每个测试案例重复此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It calculates European call option prices under the Heston model\n    using Fourier inversion and Simpson's rule.\n    \"\"\"\n\n    def heston_char_func(z, T, r, kappa, theta, nu, rho, v0, s0):\n        \"\"\"\n        Computes the Heston characteristic function for the log-price x_T = ln(S_T).\n        The formula is evaluated at a complex argument z.\n        \"\"\"\n        x0 = np.log(s0)\n        \n        # d = sqrt( (kappa - i*rho*nu*z)^2 + nu^2 * (z^2 + i*z) )\n        # Note: (kappa - i*rho*nu*z)^2 = (i*rho*nu*z - kappa)^2\n        d = np.sqrt((kappa - 1j * rho * nu * z)**2 + nu**2 * (z**2 + 1j * z))\n        \n        # g = (kappa - i*rho*nu*z - d) / (kappa - i*rho*nu*z + d)\n        g_num = kappa - 1j * rho * nu * z - d\n        g_den = kappa - 1j * rho * nu * z + d\n        g = g_num / g_den\n        \n        # C = i*z*r*T + k*theta/nu^2 * [ (k-i*rho*nu*z-d)*T - 2*ln((1-g*exp(-d*T))/(1-g)) ]\n        # The log term can be numerically unstable if g is close to 1.\n        # We use a stable calculation:\n        # log( (1-g*exp(-d*T))/(1-g) ) = log(1-g*exp(-d*T)) - log(1-g)\n        log_term_num = 1 - g * np.exp(-d * T)\n        log_term_den = 1 - g\n        # Handle cases where denominator is zero (can happen at z=0 if d=0)\n        # However, for valid Heston parameters, d(z=0)=kappa > 0, so g(z=0)=0, and log_term_den=1.\n        log_term = np.log(log_term_num) - np.log(log_term_den)\n        \n        C = 1j * z * r * T + (kappa * theta / nu**2) * (g_num * T - 2 * log_term)\n        \n        # D = (kappa - i*rho*nu*z - d) / nu^2 * [ (1-exp(-d*T))/(1-g*exp(-d*T)) ]\n        D = (g_num / nu**2) * ((1 - np.exp(-d * T)) / (1 - g * np.exp(-d * T)))\n        \n        # Characteristic function phi(z) = exp(C + D*v0 + i*z*x0)\n        phi = np.exp(C + D * v0 + 1j * z * x0)\n        \n        return phi\n\n    def price_call_heston_fourier(s0, K, T, r, kappa, theta, nu, rho, v0):\n        \"\"\"\n        Prices a European call option using Carr-Madan Fourier inversion formula\n        with Simpson's rule for numerical integration.\n        \"\"\"\n        # Numerical parameters\n        alpha = 1.5\n        U_max = 200.0\n        N = 4096 # Must be even\n\n        # Integration grid\n        du = U_max / N\n        u = np.arange(N + 1) * du\n        \n        # Use log-strike\n        k = np.log(K)\n\n        # Complex argument for characteristic function\n        z = u - 1j * (alpha + 1.0)\n        \n        # Calculate characteristic function values\n        phi = heston_char_func(z, T, r, kappa, theta, nu, rho, v0, s0)\n\n        # Integrand of the Carr-Madan formula\n        # I(u) = Re( exp(-i*u*k) * (exp(-rT)*phi) / ((alpha+i*u)*(alpha+1+i*u)) )\n        numerator = np.exp(-r * T) * phi\n        denominator = (alpha + 1j * u) * (alpha + 1.0 + 1j * u)\n        \n        full_integrand = np.exp(-1j * u * k) * numerator / denominator\n        integrand_values = np.real(full_integrand)\n\n        # Simpson's rule for integration\n        # Weights: 1, 4, 2, 4, ..., 2, 4, 1\n        weights = np.full(N + 1, 2.0)\n        weights[1::2] = 4.0\n        weights[0] = 1.0\n        weights[-1] = 1.0\n        \n        integral = (du / 3.0) * np.sum(weights * integrand_values)\n\n        # Final call price formula\n        call_price = (np.exp(-alpha * k) / np.pi) * integral\n        \n        return call_price\n\n    # Test suite from the problem statement\n    # (S0, K, T, r, kappa, theta, nu, rho, v0)\n    test_cases = [\n        (100.0, 100.0, 1.0, 0.05, 1.5, 0.04, 0.3, -0.7, 0.04), # Case A\n        (100.0, 100.0, 1.0, 0.05, 1.5, 0.04, 0.3, 0.0, 0.04),  # Case B\n        (100.0, 100.0, 1.0, 0.05, 1.5, 0.04, 0.3, 0.9, 0.04),  # Case C\n        (100.0, 120.0, 0.01, 0.02, 2.0, 0.04, 0.5, -0.5, 0.04), # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        price = price_call_heston_fourier(*case)\n        results.append(round(price, 6))\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2430270"}, {"introduction": "一个理论模型只有在参数能反映市场现实时才具有实用价值。本练习将带你从定价转向模型校准这一核心任务。你将学习如何将先前构建的定价函数作为优化框架的基石，以使Heston模型与观测到的市场数据相匹配。通过最小化模型价格与市场价格之间的差异，你将能发掘出市场所蕴含的模型参数，这是金融机构日常工作中的一项重要内容。[@problem_id:2394979]", "problem": "给定一个随机波动率资产定价设置和一组综合市场期权价格。在风险中性测度下，标的资产价格 $S_t$ 服从 Heston 随机波动率模型，其方差为 $v_t$：\n$$\n\\mathrm{d}S_t = (r - q) S_t \\,\\mathrm{d}t + \\sqrt{v_t}\\, S_t \\,\\mathrm{d}W_{1,t}, \\quad\n\\mathrm{d}v_t = \\kappa(\\theta - v_t)\\,\\mathrm{d}t + \\nu \\sqrt{v_t}\\,\\mathrm{d}W_{2,t},\n$$\n瞬时相关性为 $\\mathrm{d}W_{1,t}\\,\\mathrm{d}W_{2,t} = \\rho\\,\\mathrm{d}t$。参数包括：无风险利率 $r$，连续股息率 $q$，均值回归速度 $\\kappa$，长期方差 $\\theta$，方差的波动率 $\\nu$，相关性 $\\rho$ 和初始方差 $v_0$。初始资产价格为 $S_0$。\n\n对于一个执行价为 $K$、到期日为 $T$ 的欧式看涨期权，其风险中性价格为\n$$\nC(K,T) = S_0 \\, e^{-q T} \\, P_1(K,T) - K \\, e^{-r T} \\, P_2(K,T),\n$$\n其中 $P_1(K,T)$ 和 $P_2(K,T)$ 是风险中性概率，可以通过 Heston 模型下 $\\log S_T$ 的特征函数 $\\phi(u;T)$ 来表示：\n$$\nP_2(K,T) = \\frac{1}{2} + \\frac{1}{\\pi} \\int_{0}^{\\infty} \\Re\\left( \\frac{e^{-i u \\log K} \\, \\phi(u;T)}{i u} \\right) \\mathrm{d}u,\n$$\n$$\nP_1(K,T) = \\frac{1}{2} + \\frac{1}{\\pi} \\int_{0}^{\\infty} \\Re\\left( \\frac{e^{-i u \\log K} \\, \\phi(u - i;T)}{i u \\, S_0 \\, e^{(r - q) T}} \\right) \\mathrm{d}u,\n$$\n其中 $i = \\sqrt{-1}$，Heston 模型对复数参数 $u \\in \\mathbb{C}$ 的特征函数为\n$$\n\\phi(u;T) = \\exp\\left( i u \\left(\\log S_0 + (r - q) T\\right) + C(u;T) + D(u;T)\\, v_0 \\right),\n$$\n$$\nd(u) = \\sqrt{(\\rho \\nu i u - \\kappa)^2 + \\nu^2 (i u + u^2)}, \\quad\ng(u) = \\frac{\\kappa - \\rho \\nu i u - d(u)}{\\kappa - \\rho \\nu i u + d(u)},\n$$\n$$\nC(u;T) = \\frac{\\kappa \\theta}{\\nu^2} \\left( (\\kappa - \\rho \\nu i u - d(u)) T - 2 \\log\\left( \\frac{1 - g(u) e^{-d(u) T}}{1 - g(u)} \\right) \\right),\n$$\n$$\nD(u;T) = \\frac{\\kappa - \\rho \\nu i u - d(u)}{\\nu^2} \\cdot \\frac{1 - e^{-d(u) T}}{1 - g(u) e^{-d(u) T}}.\n$$\n\n您的任务是在给定固定的 $(\\kappa,\\theta,\\nu)$ 和市场数据的情况下，通过最小化模型价格与一组给定市场期权价格之间的平方误差和，来校准 Heston 模型参数 $v_0$ 和 $\\rho$。具体而言，对于一组执行价 $K_m$ 和到期日 $T_n$，定义最小二乘目标\n$$\n\\min_{v_0,\\rho} \\; \\sum_{n} \\sum_{m} \\left( C_{\\text{model}}(K_m,T_n; v_0,\\rho) - C_{\\text{mkt}}(K_m,T_n) \\right)^2\n$$\n约束条件为 $v_0 \\ge 0$ 和 $-1 < \\rho < 1$。函数 $C_{\\text{model}}$ 由上述 Heston 模型公式给出，而 $C_{\\text{mkt}}$ 是下方测试套件中提供的市场价格。\n\n使用以下固定参数和金融工具：\n- 初始资产价格 $S_0 = 100$。\n- 无风险利率 $r = 0.02$。\n- 连续股息率 $q = 0$。\n- Heston 固定参数 $\\kappa = 1.5$，$\\theta = 0.04$，$\\nu = 0.5$。\n- 执行价 $K \\in \\{80, 90, 100, 110, 120\\}$。\n- 到期日 $T \\in \\{0.5, 1.0\\}$。\n\n每个测试案例的市场价格 $C_{\\text{mkt}}(K,T)$ 都是由同一个 Heston 模型，使用上述固定参数和以下“真实”参数 $(v_0^{\\text{true}}, \\rho^{\\text{true}})$ 综合生成的：\n- 测试案例 1：$v_0^{\\text{true}} = 0.04$，$\\rho^{\\text{true}} = -0.5$。\n- 测试案例 2：$v_0^{\\text{true}} = 0.09$，$\\rho^{\\text{true}} = -0.9$。\n- 测试案例 3：$v_0^{\\text{true}} = 0.01$，$\\rho^{\\text{true}} = 0$。\n\n您的程序必须：\n- 为每个测试案例根据所述的真实参数构建 $C_{\\text{mkt}}(K,T)$。\n- 为每个测试案例，通过在所有列出的执行价和到期日上最小化定价误差平方和来校准 $(v_0,\\rho)$，其中 $v_0 \\in [10^{-6}, 0.5]$ 且 $\\rho \\in (-0.999, 0.999)$。\n- 生成最终校准的参数对，格式为列表的列表 $[ [\\widehat v_0^{(1)}, \\widehat \\rho^{(1)}], [\\widehat v_0^{(2)}, \\widehat \\rho^{(2)}], [\\widehat v_0^{(3)}, \\widehat \\rho^{(3)}] ]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个内部列表包含两个浮点数 $[\\widehat v_0, \\widehat \\rho]$，四舍五入到 6 位小数，并按测试案例 1、2、3 的顺序排列。例如：$[[0.040000,-0.500000],[0.090000,-0.900000],[0.010000,0.000000]]$。\n\n此问题不涉及物理单位，也不需要角度单位。所有百分比必须表示为小数。", "solution": "所提出的问题是计算金融领域一个有效且适定的练习。它要求针对一组综合生成的期权价格，校准 Heston 随机波动率模型的部分参数。该问题具有科学依据，因为它使用了金融数学中标准、广为接受的模型和定价公式。所有必要的数据、方程和约束条件都已提供，使得问题自成一体且清晰明确。目标是从无噪声数据中恢复已知参数，这可以用来测试定价模型和优化程序的正确实现。\n\n任务的核心是为 Heston 模型下的欧式看涨期权实现一个定价函数，然后在一个最小二乘优化框架内使用它，以找到最能拟合给定市场期权价格的参数 $(v_0, \\rho)$。该过程可分解为以下逻辑步骤。\n\n首先，我们必须实现资产价格对数 $\\log S_T$ 的 Heston 特征函数 $\\phi(u;T)$。该函数针对复数参数 $u \\in \\mathbb{C}$ 给出如下：\n$$\n\\phi(u;T) = \\exp\\left( i u \\left(\\log S_0 + (r - q) T\\right) + C(u;T) + D(u;T)\\, v_0 \\right)\n$$\n分量 $C(u;T)$ 和 $D(u;T)$ 依赖于几个中间的复值函数 $d(u)$ 和 $g(u)$：\n$$\nd(u) = \\sqrt{(\\rho \\nu i u - \\kappa)^2 + \\nu^2 (i u + u^2)}\n$$\n$$\ng(u) = \\frac{\\kappa - \\rho \\nu i u - d(u)}{\\kappa - \\rho \\nu i u + d(u)}\n$$\n$$\nC(u;T) = \\frac{\\kappa \\theta}{\\nu^2} \\left( (\\kappa - \\rho \\nu i u - d(u)) T - 2 \\log\\left( \\frac{1 - g(u) e^{-d(u) T}}{1 - g(u)} \\right) \\right)\n$$\n$$\nD(u;T) = \\frac{\\kappa - \\rho \\nu i u - d(u)}{\\nu^2} \\cdot \\frac{1 - e^{-d(u) T}}{1 - g(u) e^{-d(u) T}}\n$$\n这些公式的实现需要仔细处理复数运算。必须为 $d(u)$ 使用复数平方根的主分支，这在像 `numpy` 这样的数值库中是标准做法。\n\n其次，在特征函数可用后，欧式看涨期权价格 $C(K,T)$ 可通过傅里叶逆变换表示的风险中性定价公式计算：\n$$\nC(K,T) = S_0 \\, e^{-q T} \\, P_1(K,T) - K \\, e^{-r T} \\, P_2(K,T)\n$$\n概率 $P_1(K,T)$ 和 $P_2(K,T)$ 通过对特征函数变换的实部进行数值积分来求得：\n$$\nP_2(K,T) = \\frac{1}{2} + \\frac{1}{\\pi} \\int_{0}^{\\infty} \\Re\\left( \\frac{e^{-i u \\log K} \\, \\phi(u;T)}{i u} \\right) \\mathrm{d}u\n$$\n$$\nP_1(K,T) = \\frac{1}{2} + \\frac{1}{\\pi} \\int_{0}^{\\infty} \\Re\\left( \\frac{e^{-i u \\log K} \\, \\phi(u - i;T)}{i u \\, S_0 \\, e^{(r - q) T}} \\right) \\mathrm{d}u\n$$\n这些半无限积分使用数值求积例程进行评估，`scipy.integrate.quad` 是一个合适的选择。尽管分母中有 $i u$ 项，但由于极限存在，被积函数在 $u=0$ 处表现良好。\n\n第三，校准本身被表述为一个非线性最小二乘优化问题。需要最小化的目标函数是模型生成价格与“市场”价格之间的平方误差和 (SSE)：\n$$\nf(v_0, \\rho) = \\sum_{n} \\sum_{m} \\left( C_{\\text{model}}(K_m,T_n; v_0,\\rho) - C_{\\text{mkt}}(K_m,T_n) \\right)^2\n$$\n优化在箱型约束 $v_0 \\in [10^{-6}, 0.5]$ 和 $\\rho \\in [-0.999, 0.999]$ 下执行。一个能够处理此类约束的拟牛顿法，例如 `L-BFGS-B`，适用于此任务，并可在 `scipy.optimize.minimize` 中找到。\n\n每个测试案例的总体算法如下：\n1.  使用“真实”参数 $(v_0^{\\text{true}}, \\rho^{\\text{true}})$ 和固定参数 $(S_0, r, q, \\kappa, \\theta, \\nu)$，为所有指定的执行价 $K_m$ 和到期日 $T_n$ 生成参考“市场”价格 $C_{\\text{mkt}}(K_m, T_n)$。\n2.  定义目标函数，该函数接受一个参数向量 $(v_0, \\rho)$，计算相应的 Heston 模型价格 $C_{\\text{model}}(K_m, T_n)$，并返回与市场价格的平方差之和。\n3.  调用 `L-BFGS-B` 优化器，找到使此目标函数最小化的参数值 $(\\widehat{v}_0, \\widehat{\\rho})$。提供一个在搜索域内的合理初始猜测，例如 $(v_0, \\rho) = (0.05, 0.0)$，以开始搜索。\n4.  由于市场数据是人工合成且无噪声的，优化预计将收敛到真实参数，从而导致目标函数值接近于零。为每个测试案例记录校准后的参数 $(\\widehat{v}_0, \\widehat{\\rho})$。\n\n最后，将收集到的校准参数对集合格式化为指定的字符串表示形式，作为最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the Heston model calibration problem for three test cases.\n    \"\"\"\n\n    # Fixed parameters and market data structure\n    S0 = 100.0\n    r = 0.02\n    q = 0.0\n    kappa = 1.5\n    theta = 0.04\n    nu = 0.5\n    strikes = np.array([80, 90, 100, 110, 120])\n    maturities = np.array([0.5, 1.0])\n\n    def heston_price(K, T, v0, rho):\n        \"\"\"\n        Calculates the Heston model price for a European call option.\n        This function uses the characteristic function and numerical integration.\n        \"\"\"\n        \n        # Characteristic function implementation\n        def heston_char_func(u, T, v0, rho):\n            \"\"\"Computes the Heston characteristic function phi(u;T).\"\"\"\n            i = 1j\n            log_S0 = np.log(S0)\n\n            # d(u)\n            d = np.sqrt((rho * nu * i * u - kappa)**2 + nu**2 * (i * u + u**2))\n            \n            # g(u)\n            g_numerator = kappa - rho * nu * i * u - d\n            g_denominator = kappa - rho * nu * i * u + d\n            g = g_numerator / g_denominator\n\n            # C(u;T)\n            log_term = np.log((1 - g * np.exp(-d * T)) / (1 - g))\n            C = (kappa * theta / nu**2) * (g_numerator * T - 2 * log_term)\n\n            # D(u;T)\n            D_num = g_numerator * (1 - np.exp(-d * T))\n            D_den = nu**2 * (1 - g * np.exp(-d * T))\n            D = D_num / D_den\n\n            # The characteristic function phi(u;T)\n            phi = np.exp(i * u * (log_S0 + (r - q) * T) + C + D * v0)\n            return phi\n\n        # Integrand for P2\n        def p2_integrand(u, K, T, v0, rho):\n            i = 1j\n            log_K = np.log(K)\n            phi = heston_char_func(u, T, v0, rho)\n            return np.real(np.exp(-i * u * log_K) * phi / (i * u))\n\n        # Integrand for P1\n        def p1_integrand(u, K, T, v0, rho):\n            i = 1j\n            log_K = np.log(K)\n            phi = heston_char_func(u - i, T, v0, rho)\n            denominator = i * u * S0 * np.exp((r - q) * T)\n            return np.real(np.exp(-i * u * log_K) * phi / denominator)\n        \n        # Integration limit. A large finite number is sufficient.\n        integration_limit = 200\n\n        # Calculate P1 and P2 using numerical quadrature\n        integral_p2, _ = quad(p2_integrand, 0, integration_limit, args=(K, T, v0, rho))\n        P2 = 0.5 + integral_p2 / np.pi\n        \n        integral_p1, _ = quad(p1_integrand, 0, integration_limit, args=(K, T, v0, rho))\n        P1 = 0.5 + integral_p1 / np.pi\n\n        # Final call price\n        call_price = S0 * np.exp(-q * T) * P1 - K * np.exp(-r * T) * P2\n        return call_price\n\n    # Define the test cases with true parameters\n    test_cases = [\n        (0.04, -0.5),  # Test case 1\n        (0.09, -0.9),  # Test case 2\n        (0.01, 0.0),   # Test case 3\n    ]\n\n    calibrated_results = []\n\n    for v0_true, rho_true in test_cases:\n        # 1. Generate synthetic market prices\n        market_prices = []\n        for T_val in maturities:\n            for K_val in strikes:\n                price = heston_price(K_val, T_val, v0_true, rho_true)\n                market_prices.append(price)\n        market_prices = np.array(market_prices)\n\n        # 2. Define the objective function for the optimizer\n        def objective_function(params):\n            v0_cal, rho_cal = params\n            model_prices = []\n            for T_val in maturities:\n                for K_val in strikes:\n                    price = heston_price(K_val, T_val, v0_cal, rho_cal)\n                    model_prices.append(price)\n            model_prices = np.array(model_prices)\n            return np.sum((model_prices - market_prices)**2)\n\n        # 3. Perform optimization\n        initial_guess = [0.05, 0.0]  # A neutral starting point\n        bounds = [(1e-6, 0.5), (-0.999, 0.999)]\n        \n        # Use L-BFGS-B method for bounded optimization\n        result = minimize(objective_function, initial_guess, method='L-BFGS-B', bounds=bounds)\n        \n        calibrated_v0, calibrated_rho = result.x\n        calibrated_results.append([calibrated_v0, calibrated_rho])\n\n    # 4. Format and print the final output\n    output_str = f\"[{','.join([f'[{v:.6f},{r:.6f}]' for v, r in calibrated_results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2394979"}, {"introduction": "本练习将你的校准技能提升至比较分析的层次，这也是投资组合经理和风险分析师的常见工作。你将为两种不同的资产校准Heston模型，以提取并比较关键的风险参数，例如相关性参数$\\rho$和波动率的波动率$\\nu$。这项实践不仅能巩固你的数值优化技能，还能让你更深刻地理解市场如何为不同资产的不同风险来源进行定价。[@problem_id:2434416]", "problem": "您需要编写一个完整的、可运行的程序，该程序为每个测试案例中的两只股票分别校准 Heston 随机波动率模型，并比较相关性参数和波动率的波动率参数。您必须使用基于傅里叶变换的方法实现 Heston 模型下的欧式看涨期权定价，并且只校准资产与方差布朗运动之间的相关性参数（用 $\\rho$ 表示）以及方差的波动率参数（用 $\\nu$ 表示）。所有其他参数都是固定的。您的程序必须根据指定的 Heston 真实参数生成合成的“观测”期权价格，然后通过在指定期权网格上最小化每只股票的定价平方误差来恢复 $\\rho$ 和 $\\nu$。最后，对于每个测试案例，程序必须报告绝对差 $|\\rho_{A} - \\rho_{B}|$ 和 $|\\nu_{A} - \\nu_{B}|$，结果为浮点数并四舍五入到六位小数。\n\n基本原理。在风险中性测度下，根据 Heston 模型，资产价格过程 $S_{t}$ 和瞬时方差 $v_{t}$ 服从以下方程：\n$$\ndS_{t} = r S_{t} \\, dt + \\sqrt{v_{t}} \\, S_{t} \\, dW^{(1)}_{t},\n\\qquad\ndv_{t} = \\kappa \\left(\\theta - v_{t}\\right) dt + \\nu \\sqrt{v_{t}} \\, dW^{(2)}_{t},\n$$\n其中 $\\mathbb{E}\\left[dW^{(1)}_{t}\\, dW^{(2)}_{t}\\right] = \\rho \\, dt$，$r$ 是连续复利无风险利率，$\\kappa$ 是方差的均值回归速度，$\\theta$ 是长期方差，$\\nu$ 是方差的波动率，$\\rho$ 是资产与方差布朗运动之间的瞬时相关性。根据无套利原理和风险中性定价，到期日为 $T$、执行价为 $K$ 的欧式看涨期权在时间 $0$ 的价格是其收益的贴现风险中性期望。\n\n您的实现要求：\n- 实现一个基于风险中性特征函数和带数值积分的傅里叶逆变换的、数值稳定的 Heston 欧式看涨期权定价器。除了风险中性定价原理和特征函数的使用外，您不能假设任何给定的期权价格闭式解。\n- 不考虑股息（股息收益率为 $0$）。\n- 通过带简单边界的非线性最小二乘法校准 $\\rho$ 和 $\\nu$，同时在每个测试案例中，保持其他 Heston 参数固定并在两只股票之间共享。使用边界 $-0.999 < \\rho < 0.999$ 和 $10^{-4} \\le \\nu \\le 2.0$。\n- 您用于校准的“观测”期权价格必须由您自己的 Heston 定价器使用每个测试案例中每只股票的真实参数生成。\n\n校准设计：\n- 每个测试案例中两只股票都使用的期权网格：\n  - 到期日 $T \\in \\{\\,0.25,\\,0.5,\\,1.0\\,\\}$（单位：年）。\n  - 执行价 $K$ 由应用于即期价格的执行价乘数给出，乘数为 $\\{\\,0.8,\\,0.9,\\,1.1,\\,1.2\\,\\}$。例如，$K = 0.8 \\times S_{0}$ 对买方来说是一个深度实值看涨期权。\n- 对于每只股票，将所有到期日-执行价组合的模型价格与观测价格之差构成残差向量，并在上述边界条件下，最小化关于 $(\\rho,\\nu)$ 的残差平方和。\n\n测试套件：\n提供三个测试案例。在每个案例中，两只股票共享相同的 $(S_{0}, r, \\kappa, \\theta, v_{0})$，但具有不同的真实参数 $(\\rho, \\nu)$。您的程序必须从这些真实值合成观测价格，然后在每个案例中为股票 A 和股票 B 独立校准 $(\\rho, \\nu)$。\n\n- 案例 1：\n  - 共享：$S_{0} = 100$, $r = 0.01$, $\\kappa = 1.5$, $\\theta = 0.04$, $v_{0} = 0.04$。\n  - 股票 A 真实值：$\\rho_{A} = -0.7$, $\\nu_{A} = 0.6$。\n  - 股票 B 真实值：$\\rho_{B} = -0.6$, $\\nu_{B} = 0.55$。\n- 案例 2：\n  - 共享：$S_{0} = 100$, $r = 0.005$, $\\kappa = 2.0$, $\\theta = 0.03$, $v_{0} = 0.03$。\n  - 股票 A 真实值：$\\rho_{A} = -0.95$, $\\nu_{A} = 0.3$。\n  - 股票 B 真实值：$\\rho_{B} = -0.90$, $\\nu_{B} = 0.28$。\n- 案例 3：\n  - 共享：$S_{0} = 100$, $r = 0.02$, $\\kappa = 1.2$, $\\theta = 0.05$, $v_{0} = 0.05$。\n  - 股票 A 真实值：$\\rho_{A} = -0.5$, $\\nu_{A} = 0.9$。\n  - 股票 B 真实值：$\\rho_{B} = -0.48$, $\\nu_{B} = 1.0$。\n\n答案规格和输出格式：\n- 对于每个测试案例，在校准两只股票后，计算两个浮点数：\n  - $d_{\\rho} = \\left|\\hat{\\rho}_{A} - \\hat{\\rho}_{B}\\right|$，\n  - $d_{\\nu} = \\left|\\hat{\\nu}_{A} - \\hat{\\nu}_{B}\\right|$，\n  其中帽子符号表示校准后的值。\n- 将这些浮点数都四舍五入到恰好六位小数。\n- 您的程序应生成单行输出，其中包含所有结果，并按案例顺序和案例内参数顺序展平为 $[d_{\\rho}^{(1)}, d_{\\nu}^{(1)}, d_{\\rho}^{(2)}, d_{\\nu}^{(2)}, d_{\\rho}^{(3)}, d_{\\nu}^{(3)}]$ 的形式。例如，一个有效的输出可能看起来像 $[0.100000,0.050000,0.050000,0.020000,0.020000,0.100000]$。\n\n注意：\n- 不涉及角度。\n- 没有物理单位；在此处使用的风险中性定价框架下，所有量都是无量纲的。\n- 实现必须是完全确定性的，不能使用任何随机性。", "solution": "问题陈述已通过验证。\n\n### 步骤 1：提取给定信息\n- **Heston 模型动态**：在风险中性测度 $\\mathbb{Q}$ 下，资产价格 $S_t$ 及其方差 $v_t$ 服从以下随机微分方程：\n$$\ndS_{t} = r S_{t} \\, dt + \\sqrt{v_{t}} \\, S_{t} \\, dW^{(1)}_{t}\n$$\n$$\ndv_{t} = \\kappa \\left(\\theta - v_{t}\\right) dt + \\nu \\sqrt{v_{t}} \\, dW^{(2)}_{t}\n$$\n其中 $dW^{(1)}_{t}$ 和 $dW^{(2)}_{t}$ 是相关性为 $\\mathbb{E}\\left[dW^{(1)}_{t}\\, dW^{(2)}_{t}\\right] = \\rho \\, dt$ 的维纳过程。\n- **参数**：\n    - $r$：连续复利无风险利率。\n    - $\\kappa$：方差的均值回归速度。\n    - $\\theta$：长期方差。\n    - $\\nu$：方差的波动率（vol-of-vol）。\n    - $\\rho$：资产与方差过程之间的相关性。\n    - $S_0$：初始资产价格。\n    - $v_0$：初始方差。\n- **任务**：为每个测试案例中的两只股票 A 和 B 校准参数 $(\\rho, \\nu)$。\n- **固定参数**：对于每个测试案例，$(S_0, r, \\kappa, \\theta, v_0)$ 在股票 A 和 B 之间共享。\n- **校准方法**：\n    - 目标：最小化模型预测的欧式看涨期权价格与综合生成的“观测”价格之间的平方误差和。\n    - 优化变量：$(\\rho, \\nu)$。\n    - 边界：$-0.999 < \\rho < 0.999$ 和 $10^{-4} \\le \\nu \\le 2.0$。\n- **观测数据生成**：“观测”价格是使用提供的 Heston 模型定价器和每只股票的真实参数生成的。\n- **用于校准的期权网格**：\n    - 到期日 $T \\in \\{0.25, 0.5, 1.0\\}$ 年。\n    - 执行价 $K = S_0 \\times m$，其中乘数 $m \\in \\{0.8, 0.9, 1.1, 1.2\\}$。\n- **测试案例**：\n    - **案例 1**：共享：$S_{0} = 100$, $r = 0.01$, $\\kappa = 1.5$, $\\theta = 0.04$, $v_{0} = 0.04$。股票 A 真实值：$(\\rho_{A}, \\nu_{A}) = (-0.7, 0.6)$。股票 B 真实值：$(\\rho_{B}, \\nu_{B}) = (-0.6, 0.55)$。\n    - **案例 2**：共享：$S_{0} = 100$, $r = 0.005$, $\\kappa = 2.0$, $\\theta = 0.03$, $v_{0} = 0.03$。股票 A 真实值：$(\\rho_{A}, \\nu_{A}) = (-0.95, 0.3)$。股票 B 真实值：$(\\rho_{B}, \\nu_{B}) = (-0.90, 0.28)$。\n    - **案例 3**：共享：$S_{0} = 100$, $r = 0.02$, $\\kappa = 1.2$, $\\theta = 0.05$, $v_{0} = 0.05$。股票 A 真实值：$(\\rho_{A}, \\nu_{A}) = (-0.5, 0.9)$。股票 B 真实值：$(\\rho_{B}, \\nu_{B}) = (-0.48, 1.0)$。\n- **输出**：对于每个案例，计算 $d_{\\rho} = |\\hat{\\rho}_{A} - \\hat{\\rho}_{B}|$ 和 $d_{\\nu} = |\\hat{\\nu}_{A} - \\hat{\\nu}_{B}|$，其中带帽子的变量是校准值。报告一个展平的列表，其中包含这些值，四舍五入到六位小数。\n\n### 步骤 2：使用提取的给定信息进行验证\n- **科学依据**：该问题基于 Heston 随机波动率模型，这是量化金融中的一个经典模型。通过特征函数的傅里叶逆变换进行定价的方法是一种标准且严谨的技术。该问题具有科学合理性。\n- **适定性**：该问题是适定的。它要求根据同一模型生成的合成数据来校准模型，这是测试定价和校准程序实现的标准流程。鉴于数据的合成性质，预期优化问题存在唯一解。\n- **客观性**：该问题使用精确的数学定义、数值和明确的目标进行陈述。它不含主观性。\n- **完整性与一致性**：该问题提供了实现解决方案所需的所有数据和约束。参数，包括那些违反 Feller 条件（$2\\kappa\\theta > \\nu^2$）的参数，也都在特征函数定义的域内，这使得问题规范与所选的数学框架保持一致。\n- **其他缺陷**：该问题不是比喻性的、琐碎的，也没有超出科学可验证性的范围。\n\n### 步骤 3：结论与行动\n问题有效。将提供解决方案。\n\n### 解决方案设计\n\n解决方案的核心是实现 Heston 模型的欧式看涨期权定价器，并在校准的数值优化程序中使用它。\n\n**1. Heston 模型期权定价**\n\n执行价为 $K$、到期日为 $T$ 的欧式看涨期权价格 $C$ 由风险中性定价公式给出：\n$$\nC(S_0, v_0, T) = e^{-rT} \\mathbb{E}_{\\mathbb{Q}}[\\max(S_T - K, 0) | \\mathcal{F}_0]\n$$\n这个期望可以使用傅里叶方法高效计算。价格可以分解为：\n$$\nC(S_0, K, T) = S_0 P_1 - K e^{-rT} P_2\n$$\n其中 $P_1$ 和 $P_2$ 是在不同计价单位下的概率。Heston 证明了这些概率可以通过对数价格 $x_T = \\ln(S_T)$ 的条件特征函数进行逆变换来计算。基于 Gil-Pelaez 逆变换定理，该公式为：\n$$\nP_j(\\phi; K) = \\frac{1}{2} + \\frac{1}{\\pi} \\int_0^\\infty \\text{Re}\\left[ \\frac{e^{-i\\phi \\ln K} f_j(\\phi)}{i\\phi} \\right] d\\phi\n$$\n对于 $j \\in \\{1, 2\\}$，其中 $f_j$ 是相关的特征函数。\n\n在风险中性测度下，对数价格 $x_T = \\ln(S_T)$ 的特征函数由 $f(\\phi) = \\mathbb{E}[e^{i\\phi x_T}]$ 给出。对于 Heston 模型，它有一个已知的半闭式解形式：\n$$\nf(\\phi, T) = \\exp(C(\\phi, T) + D(\\phi, T)v_0 + i\\phi (\\ln S_0 + rT))\n$$\n其中\n$$\nC(\\phi, T) = \\frac{\\kappa\\theta}{\\nu^2} \\left[ (\\kappa - \\rho\\nu i\\phi - d)T - 2\\ln\\left(\\frac{1 - ge^{-dT}}{1-g}\\right) \\right]\n$$\n$$\nD(\\phi, T) = \\frac{\\kappa - \\rho\\nu i\\phi - d}{\\nu^2} \\left(\\frac{1 - e^{-dT}}{1-ge^{-dT}}\\right)\n$$\n其中辅助变量为：\n$$\nd = \\sqrt{(\\kappa - \\rho\\nu i\\phi)^2 + (\\phi^2 + i\\phi)\\nu^2}\n$$\n$$\ng = \\frac{\\kappa - \\rho\\nu i\\phi - d}{\\kappa - \\rho\\nu i\\phi + d}\n$$\n计算 $P_1$ 和 $P_2$ 所需的特征函数是：\n- $f_2(\\phi) = f(\\phi, T)$：风险中性测度下 $\\ln(S_T)$ 的特征函数。\n- $f_1(\\phi) = f(\\phi-i, T)$：一个相关的特征函数，对应于股票计价单位。这等价于在计算 $f(\\phi, T)$ 时将 $\\phi$ 替换为 $\\phi-i$。\n\n用于计算 $P_1$ 和 $P_2$ 的积分使用求积法进行数值计算，`scipy.integrate.quad` 很适合此任务。\n\n**2. 校准流程**\n\n校准旨在找到参数 $(\\hat{\\rho}, \\hat{\\nu})$，使得模型输出与一组观测市场价格最佳匹配。问题指定这些“观测”价格是使用具有已知真实参数的同一定价模型综合生成的。\n\n令 $\\Theta = (\\rho, \\nu)$ 为待校准的参数向量。令用于校准的期权集合由 $i=1, \\dots, N$ 索引，其执行价为 $K_i$，到期日为 $T_i$。\n要最小化的目标函数是平方误差和（SSE）：\n$$\n\\text{SSE}(\\Theta) = \\sum_{i=1}^{N} \\left[ C_{\\text{model}}(K_i, T_i; \\Theta) - C_{\\text{observed}}(K_i, T_i) \\right]^2\n$$\n其中 $C_{\\text{model}}$ 是我们的 Heston 定价器给出的价格，$C_{\\text{observed}}$ 是合成的目标价格。\n\n这个最小化问题是一个带有箱型约束的非线性最小二乘问题：\n$$\n-0.999 \\le \\rho \\le 0.999 \\quad \\text{and} \\quad 10^{-4} \\le \\nu \\le 2.0\n$$\n我们采用 `scipy.optimize.minimize` 中可用的 L-BFGS-B 算法，这是一种准牛顿方法，非常适合此类约束优化问题。对于 $\\rho$ 的严格不等式，我们通过将指定值用作包含边界来处理，这是一种标准做法。\n\n**3. 算法实现**\n\n总体算法如下：\n1. 对于提供的三个测试案例中的每一个：\n    a. 定义共享参数 $(S_0, r, \\kappa, \\theta, v_0)$ 和股票 A 的真实参数 $(\\rho_A, \\nu_A)$ 以及股票 B 的真实参数 $(\\rho_B, \\nu_B)$。\n    b. 根据指定的到期日和执行价乘数，构建包含 $3 \\times 4 = 12$ 个看涨期权的期权网格。\n    c. 对于股票 A：\n        i. 使用 Heston 定价器和真实参数 $(\\rho_A, \\nu_A)$ 生成 12 个“观测”价格。\n        ii. 定义一个目标函数，用于计算给定参数对 $(\\rho, \\nu)$ 的 SSE。\n        iii. 使用 `scipy.optimize.minimize` 的 L-BFGS-B 方法、边界和一个合理的初始猜测值（例如 $\\rho=-0.5, \\nu=0.5$）来找到校准后的参数 $\\hat{\\rho}_A$ 和 $\\hat{\\nu}_A$。\n    d. 对于股票 B：\n        i. 使用真实参数 $(\\rho_B, \\nu_B)$ 重复(c)中的过程，以找到校准后的参数 $\\hat{\\rho}_B$ 和 $\\hat{\\nu}_B$。\n    e. 计算绝对差 $d_{\\rho} = |\\hat{\\rho}_A - \\hat{\\rho}_B|$ 和 $d_{\\nu} = |\\hat{\\nu}_A - \\hat{\\nu}_B|$。\n2. 收集六个差值结果 ($d_{\\rho}^{(1)}, d_{\\nu}^{(1)}, d_{\\rho}^{(2)}, d_{\\nu}^{(2)}, d_{\\rho}^{(3)}, d_{\\nu}^{(3)}$)。\n3. 将这些值格式化为用逗号分隔的数字字符串，每个数字四舍五入到六位小数，并用方括号括起来。这是最终的输出。\n该确定性过程严格遵守问题要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Main function to solve the Heston model calibration problem.\n    \"\"\"\n\n    def heston_char_func(phi, T, r, kappa, theta, nu, rho, v0, S0):\n        \"\"\"\n        Computes the Heston characteristic function for the log-price ln(S_T).\n        f(phi, T) = E[exp(i*phi*ln(S_T))]\n        \"\"\"\n        x0 = np.log(S0)\n        \n        # d and g are auxiliary variables in the Heston characteristic function\n        d = np.sqrt((kappa - rho * nu * 1j * phi)**2 + (phi**2 + 1j * phi) * nu**2)\n        g = (kappa - rho * nu * 1j * phi - d) / (kappa - rho * nu * 1j * phi + d)\n        \n        # C and D are the main components of the characteristic function's exponent\n        C = r * 1j * phi * T + (kappa * theta / nu**2) * \\\n            ((kappa - rho * nu * 1j * phi - d) * T - 2 * np.log((1 - g * np.exp(-d * T)) / (1 - g)))\n        \n        D = (kappa - rho * nu * 1j * phi - d) / nu**2 * ((1 - np.exp(-d * T)) / (1 - g * np.exp(-d * T)))\n        \n        return np.exp(C + D * v0 + 1j * phi * x0)\n\n    def heston_price_integrand(phi, j, S0, K, T, r, kappa, theta, nu, rho, v0):\n        \"\"\"\n        Computes the integrand for calculating P_j in the Heston pricing formula.\n        j=1 or j=2.\n        \"\"\"\n        if j == 1:\n            # Use characteristic function f(phi-i) for P1\n            char_val = heston_char_func(phi - 1j, T, r, kappa, theta, nu, rho, v0, S0)\n        else: # j == 2\n            # Use characteristic function f(phi) for P2\n            char_val = heston_char_func(phi, T, r, kappa, theta, nu, rho, v0, S0)\n        \n        integrand = np.real(np.exp(-1j * phi * np.log(K)) * char_val / (1j * phi))\n        return integrand\n        \n    def heston_call_price(S0, K, T, r, kappa, theta, nu, rho, v0):\n        \"\"\"\n        Calculates the Heston European call price using Fourier inversion.\n        \"\"\"\n        # Integration limit for the semi-infinite integral\n        integration_limit = 200.0\n\n        # Integral for P1\n        args1 = (1, S0, K, T, r, kappa, theta, nu, rho, v0)\n        integral1, _ = quad(heston_price_integrand, 0, integration_limit, args=args1)\n        P1 = 0.5 + integral1 / np.pi\n\n        # Integral for P2\n        args2 = (2, S0, K, T, r, kappa, theta, nu, rho, v0)\n        integral2, _ = quad(heston_price_integrand, 0, integration_limit, args=args2)\n        P2 = 0.5 + integral2 / np.pi\n        \n        price = S0 * P1 - K * np.exp(-r * T) * P2\n        return price\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"shared\": {\"S0\": 100, \"r\": 0.01, \"kappa\": 1.5, \"theta\": 0.04, \"v0\": 0.04},\n            \"A\": {\"rho\": -0.7, \"nu\": 0.6},\n            \"B\": {\"rho\": -0.6, \"nu\": 0.55}\n        },\n        {\n            \"shared\": {\"S0\": 100, \"r\": 0.005, \"kappa\": 2.0, \"theta\": 0.03, \"v0\": 0.03},\n            \"A\": {\"rho\": -0.95, \"nu\": 0.3},\n            \"B\": {\"rho\": -0.90, \"nu\": 0.28}\n        },\n        {\n            \"shared\": {\"S0\": 100, \"r\": 0.02, \"kappa\": 1.2, \"theta\": 0.05, \"v0\": 0.05},\n            \"A\": {\"rho\": -0.5, \"nu\": 0.9},\n            \"B\": {\"rho\": -0.48, \"nu\": 1.0}\n        }\n    ]\n    \n    # Define the option grid structure\n    maturities = [0.25, 0.5, 1.0]\n    strike_multipliers = [0.8, 0.9, 1.1, 1.2]\n    \n    results = []\n    \n    for case in test_cases:\n        shared_params = case[\"shared\"]\n        S0, r, kappa, theta, v0 = shared_params.values()\n        \n        params_A_truth = case[\"A\"]\n        params_B_truth = case[\"B\"]\n        \n        # Construct the option grid for this case\n        option_grid = []\n        for T in maturities:\n            for mult in strike_multipliers:\n                K = S0 * mult\n                option_grid.append({\"T\": T, \"K\": K})\n\n        calibrated_params = {}\n        for stock_label, truth_params in [(\"A\", params_A_truth), (\"B\", params_B_truth)]:\n            \n            # 1. Generate synthetic \"observed\" prices\n            observed_prices = np.array([\n                heston_call_price(S0, opt['K'], opt['T'], r, kappa, theta,\n                                   truth_params['nu'], truth_params['rho'], v0)\n                for opt in option_grid\n            ])\n            \n            # 2. Define the objective function for minimization\n            def objective_function(params):\n                rho, nu = params\n                model_prices = np.array([\n                    heston_call_price(S0, opt['K'], opt['T'], r, kappa, theta, nu, rho, v0)\n                    for opt in option_grid\n                ])\n                return np.sum((model_prices - observed_prices)**2)\n\n            # 3. Calibrate parameters rho and nu\n            initial_guess = [-0.5, 0.5]\n            bounds = ((-0.999, 0.999), (1e-4, 2.0))\n            \n            opt_result = minimize(objective_function, initial_guess, method='L-BFGS-B', bounds=bounds)\n            \n            calibrated_params[stock_label] = opt_result.x\n\n        rho_A_cal, nu_A_cal = calibrated_params[\"A\"]\n        rho_B_cal, nu_B_cal = calibrated_params[\"B\"]\n        \n        # 4. Compute and store absolute differences\n        d_rho = abs(rho_A_cal - rho_B_cal)\n        d_nu = abs(nu_A_cal - nu_B_cal)\n        \n        results.append(d_rho)\n        results.append(d_nu)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "2434416"}]}