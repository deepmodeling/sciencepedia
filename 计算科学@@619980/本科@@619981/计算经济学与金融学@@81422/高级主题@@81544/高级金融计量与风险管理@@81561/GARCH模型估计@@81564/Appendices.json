{"hands_on_practices": [{"introduction": "GARCH模型中的参数 $\\alpha_1$ 和 $\\beta_1$ 共同决定了波动率冲击的持续性，即一个突发的市场震荡对其后波动率的影响会持续多久。为了直观地量化这种持续性，我们引入“半衰期”这一概念，它衡量了冲击的影响衰减一半所需的时间。通过这个实践[@problem_id:2395686]，你将学会如何计算和解释波动率半衰期，从而将抽象的模型参数转化为对市场动态更深刻的理解。", "problem": "考虑一个用于零均值收益率过程 $\\left\\{r_t\\right\\}$ 的单变量广义自回归条件异方差（GARCH）$\\left(1,1\\right)$ 阶模型：\n$$r_t=\\epsilon_t,\\quad \\epsilon_t=\\sqrt{h_t}\\,z_t,$$\n其中 $\\left\\{z_t\\right\\}$ 是独立同分布的，满足 $\\mathbb{E}\\left[z_t\\right]=0$ 和 $\\mathbb{V}\\mathrm{ar}\\left[z_t\\right]=1$，且条件方差 $\\left\\{h_t\\right\\}$ 服从\n$$h_t=\\omega+\\alpha_1\\,\\epsilon_{t-1}^2+\\beta_1\\,h_{t-1},$$\n参数满足 $\\omega>0$、$\\alpha_1\\ge 0$、$\\beta_1\\ge 0$。在协方差平稳性条件 $\\alpha_1+\\beta_1<1$ 下，单位波动性冲击的影响以 $\\alpha_1+\\beta_1$ 的速率进行几何衰减。将波动性冲击的半衰期定义为预期影响衰减至其初始大小一半所需的时期数 $k$，由下式给出：\n$$k=\\frac{\\ln\\left(0.5\\right)}{\\ln\\left(\\alpha_1+\\beta_1\\right)},$$\n其中 $\\ln\\left(\\cdot\\right)$ 表示自然对数。对于边界情况 $\\alpha_1+\\beta_1=1$，半衰期取为 $+\\infty$。\n\n您的任务是为下列每组参数计算半衰期 $k$，每组参数代表一种不同的金融资产。将每对 $\\left(\\alpha_1,\\beta_1\\right)$ 视为一个独立的测试用例。假设 $\\omega>0$ 使得 $h_t$ 有良好定义，并且 $\\alpha_1,\\beta_1$ 满足所述的非负约束。遵循惯例，如果 $\\alpha_1+\\beta_1=1$，则该测试用例的输出必须为 $+\\infty$。\n\n测试套件（资产和参数）：\n- 资产 A: $\\alpha_1=0.05$, $\\beta_1=0.90$。\n- 资产 B: $\\alpha_1=0.05$, $\\beta_1=0.949$。\n- 资产 C: $\\alpha_1=0.10$, $\\beta_1=0.40$。\n- 资产 D: $\\alpha_1=0.10$, $\\beta_1=0.90$。\n- 资产 E: $\\alpha_1=0.02$, $\\beta_1=0.92$。\n\n程序输出要求：\n- 对每个资产，使用上述公式计算半衰期 $k$。\n- 对于边界情况 $\\alpha_1+\\beta_1=1$，输出 $+\\infty$。\n- 对于所有有限的 $k$，四舍五入到恰好 $6$ 位小数。\n- 程序应生成单行输出，包含所有按 A、B、C、D、E 顺序排列的结果，格式为一个用逗号分隔的列表，并用方括号括起来且没有空格，例如 $\\left[\\text{result}_A,\\text{result}_B,\\text{result}_C,\\text{result}_D,\\text{result}_E\\right]$。\n- 在输出行中将 $+\\infty$ 直接表示为 $\\text{inf}$。\n\n不涉及物理单位。不涉及角度。每个测试用例的最终答案必须是浮点数，边界情况按规定用 $\\text{inf}$ 表示。解决方案应适用于上面提供的确切参数值，并遵守测试套件的顺序。", "solution": "所提出的问题在科学上是适定的，并为获得唯一解提供了充分的信息。任务是为几种不同参数设置下的广义自回归条件异方差（GARCH($1,1$)）过程计算波动性冲击的半衰期。\n\n针对零均值收益率序列 $r_t$ 的 GARCH($1,1$) 模型由以下方程定义：\n$$r_t = \\epsilon_t$$\n$$\\epsilon_t = \\sqrt{h_t} z_t$$\n其中 $\\{z_t\\}$ 是一个均值为零、方差为一的独立同分布（i.i.d.）过程。条件方差 $h_t$ 按以下方式演变：\n$$h_t = \\omega + \\alpha_1 \\epsilon_{t-1}^2 + \\beta_1 h_{t-1}$$\n波动性冲击的持续性由参数 $\\alpha_1$ 和 $\\beta_1$ 的和决定。这个和，我们记为 $S = \\alpha_1 + \\beta_1$，决定了过去冲击对未来条件方差影响的衰减速率。对于协方差平稳过程，要求 $S < 1$。\n\n半衰期 $k$ 定义为冲击的预期影响衰减至其初始值 $50\\%$ 所需的时间周期数。这由关系式 $(\\alpha_1 + \\beta_1)^k = 0.5$ 决定。求解 $k$ 可得以下公式：\n$$k = \\frac{\\ln(0.5)}{\\ln(\\alpha_1 + \\beta_1)}$$\n此公式在 $\\alpha_1 + \\beta_1 < 1$ 时有效。一个介于 $0$ 和 $1$ 之间的数的对数是负数，因此分子和分母都为负，从而得到一个正的半衰期 $k$。\n\n在 $\\alpha_1 + \\beta_1 = 1$ 的特殊情况下，该过程被称为积分 GARCH（IGARCH）模型。在此模式下，冲击对条件方差具有无限持续的影响，因此半衰期 $k$ 被取为 $+\\infty$。\n\n我们现在为每组指定的参数计算半衰期。\n\n1.  **资产 A**：参数为 $\\alpha_1 = 0.05$ 和 $\\beta_1 = 0.90$。\n    持续性为 $S = 0.05 + 0.90 = 0.95$。\n    半衰期计算如下：\n    $$k_A = \\frac{\\ln(0.5)}{\\ln(0.95)} \\approx \\frac{-0.693147}{-0.051293} \\approx 13.513427$$\n    结果四舍五入到 $6$ 位小数为 $13.513427$。\n\n2.  **资产 B**：参数为 $\\alpha_1 = 0.05$ 和 $\\beta_1 = 0.949$。\n    持续性为 $S = 0.05 + 0.949 = 0.999$。这表明持续性非常高。\n    半衰期计算如下：\n    $$k_B = \\frac{\\ln(0.5)}{\\ln(0.999)} \\approx \\frac{-0.693147}{-0.0010005} \\approx 692.800063$$\n    结果四舍五入到 $6$ 位小数为 $692.800063$。\n\n3.  **资产 C**：参数为 $\\alpha_1 = 0.10$ 和 $\\beta_1 = 0.40$。\n    持续性为 $S = 0.10 + 0.40 = 0.50$。\n    半衰期计算如下：\n    $$k_C = \\frac{\\ln(0.5)}{\\ln(0.5)} = 1$$\n    结果表示为 $6$ 位小数是 $1.000000$。\n\n4.  **资产 D**：参数为 $\\alpha_1 = 0.10$ 和 $\\beta_1 = 0.90$。\n    持续性为 $S = 0.10 + 0.90 = 1.0$。\n    这对应于 IGARCH 边界情况。半衰期是无限的。\n    $$k_D = +\\infty$$\n\n5.  **资产 E**：参数为 $\\alpha_1 = 0.02$ 和 $\\beta_1 = 0.92$。\n    持续性为 $S = 0.02 + 0.92 = 0.94$。\n    半衰期计算如下：\n    $$k_E = \\frac{\\ln(0.5)}{\\ln(0.94)} \\approx \\frac{-0.693147}{-0.061875} \\approx 11.202302$$\n    结果四舍五入到 $6$ 位小数为 $11.202302$。\n\n最终结果按要求汇编成一个单一列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the volatility shock half-life for a GARCH(1,1) model\n    for a given test suite of parameters.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple contains (alpha_1, beta_1) for an asset.\n    test_cases = [\n        (0.05, 0.90),   # Asset A\n        (0.05, 0.949),  # Asset B\n        (0.10, 0.40),   # Asset C\n        (0.10, 0.90),   # Asset D\n        (0.02, 0.92)    # Asset E\n    ]\n\n    results = []\n    for alpha_1, beta_1 in test_cases:\n        # Calculate the shock persistence parameter\n        persistence = alpha_1 + beta_1\n\n        # Check for the boundary case (IGARCH) where persistence is 1.\n        # np.isclose is used for safe floating-point comparison.\n        if np.isclose(persistence, 1.0):\n            result_str = 'inf'\n        else:\n            # Calculate the half-life k using the provided formula.\n            # k = ln(0.5) / ln(alpha_1 + beta_1)\n            half_life = np.log(0.5) / np.log(persistence)\n            # Format the result to exactly 6 decimal places.\n            result_str = f\"{half_life:.6f}\"\n        \n        results.append(result_str)\n\n    # Final print statement in the exact required format.\n    # The format is a comma-separated list of results enclosed in square brackets.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2395686"}, {"introduction": "GARCH模型的参数通常通过最大似然估计（MLE）得到，这一过程本质上是一个数值优化问题。要高效、准确地找到似然函数的最大值，基于梯度的优化算法至关重要。在这个实践中[@problem_id:2395726]，你将从第一性原理出发，推导并实现GARCH(1,1)模型对数似然函数的解析梯度，这不仅能加深你对MLE工作原理的理解，也是掌握高级计量经济学软件开发背后核心技术的关键一步。", "problem": "考虑一个单变量收益率序列 $\\{r_t\\}_{t=1}^T$，其模型为阶数为 $\\left(1,1\\right)$、条件均值为零且误差服从正态分布的广义自回归条件异方差（GARCH）模型。该模型由下式给出\n$$\nr_t = \\varepsilon_t, \\quad \\varepsilon_t \\mid \\mathcal{F}_{t-1} \\sim \\mathcal{N}\\!\\left(0, h_t\\right),\n$$\n其条件方差动态为\n$$\nh_t = \\omega + \\alpha \\,\\varepsilon_{t-1}^2 + \\beta \\,h_{t-1},\n$$\n对所有 $t \\in \\{1,\\dots,T\\}$，其中参数向量为 $\\theta = \\left(\\omega,\\alpha,\\beta\\right)$，且满足 $\\omega > 0$、$\\alpha \\ge 0$、$\\beta \\ge 0$ 和 $\\alpha + \\beta < 1$。在正态分布假设下，样本的对数似然为\n$$\n\\ell\\!\\left(\\theta\\right) = -\\frac{1}{2}\\sum_{t=1}^{T}\\left[\\log\\!\\left(2\\pi\\right) + \\log\\!\\left(h_t\\right) + \\frac{\\varepsilon_t^2}{h_t}\\right].\n$$\n假设初始化为\n$$\nh_0 = \\frac{\\omega}{1-\\alpha-\\beta}, \\qquad \\varepsilon_0^2 = h_0.\n$$\n\n任务：\n1. 在上述初始化条件下，从第一性原理出发，推导总对数似然 $\\ell\\!\\left(\\theta\\right)$ 关于 $\\theta = \\left(\\omega,\\alpha,\\beta\\right)$ 的解析梯度向量。\n2. 实现一个程序，在给定数据和参数向量 $\\theta$ 的情况下，计算在 $\\theta$ 处的解析梯度（而非数值近似）。\n\n测试套件：\n- 使用长度为 $T = 12$ 的收益率序列，如下所示：\n$$\n\\{r_t\\}_{t=1}^{12} = \\{\\,0.004,\\,-0.002,\\,0.006,\\,0.000,\\,-0.007,\\,0.005,\\,-0.0035,\\,0.001,\\,0.000,\\,0.0045,\\,-0.0025,\\,0.003\\,\\}.\n$$\n- 在以下四个参数向量处计算梯度，每个向量都满足 $\\omega > 0$、$\\alpha \\ge 0$、$\\beta \\ge 0$ 和 $\\alpha + \\beta < 1$：\n  1. $\\theta_1 = \\left(0.00001,\\,0.05,\\,0.90\\right)$,\n  2. $\\theta_2 = \\left(0.00001,\\,0.09,\\,0.90\\right)$,\n  3. $\\theta_3 = \\left(0.00002,\\,0.00,\\,0.80\\right)$,\n  4. $\\theta_4 = \\left(0.00002,\\,0.10,\\,0.00\\right)$.\n\n最终输出格式要求：\n- 您的程序必须生成单行输出，其中包含四个测试用例的梯度向量列表，顺序与上文所列一致，形式为用方括号括起来的逗号分隔列表。每个梯度向量表示为按顺序 $\\left[\\frac{\\partial \\ell}{\\partial \\omega},\\,\\frac{\\partial \\ell}{\\partial \\alpha},\\,\\frac{\\partial \\ell}{\\partial \\beta}\\right]$ 排列的三个实数列表。例如，输出应具有以下形式：\n$$\n\\big[\\,[g_{1,\\omega}, g_{1,\\alpha}, g_{1,\\beta}],\\,[g_{2,\\omega}, g_{2,\\alpha}, g_{2,\\beta}],\\,[g_{3,\\omega}, g_{3,\\alpha}, g_{3,\\beta}],\\,[g_{4,\\omega}, g_{4,\\alpha}, g_{4,\\beta}]\\,\\big].\n$$\n\n所有答案均为实数，不涉及物理单位。不涉及角度。如果在计算过程中出现百分比，最终输出时必须表示为小数。输出必须严格遵守上述指定的单行格式。", "solution": "该问题要求推导并实现 GARCH($1$,$1$) 模型对数似然的解析梯度。问题陈述科学严谨，数学上适定且完整。我们开始进行求解。\n\n对于一个条件均值为零的收益率序列 $\\{r_t\\}_{t=1}^T$，指定的 GARCH($1$,$1$) 模型为：\n$$\nr_t = \\varepsilon_t, \\quad \\varepsilon_t \\mid \\mathcal{F}_{t-1} \\sim \\mathcal{N}(0, h_t)\n$$\n$$\nh_t = \\omega + \\alpha \\varepsilon_{t-1}^2 + \\beta h_{t-1}\n$$\n参数向量为 $\\theta = (\\omega, \\alpha, \\beta)^T$。对于大小为 $T$ 的样本，其对数似然函数由下式给出：\n$$\n\\ell(\\theta) = -\\frac{1}{2}\\sum_{t=1}^{T}\\left[\\log(2\\pi) + \\log(h_t) + \\frac{r_t^2}{h_t}\\right]\n$$\n其中我们根据模型定义代入了 $\\varepsilon_t = r_t$。\n\n梯度向量 $\\nabla_\\theta \\ell(\\theta)$ 的分量为 $\\frac{\\partial \\ell}{\\partial \\omega}$、$\\frac{\\partial \\ell}{\\partial \\alpha}$ 和 $\\frac{\\partial \\ell}{\\partial \\beta}$。设 $\\theta_j$ 为 $\\theta$ 的一个通用分量。对求和项应用链式法则，可得到总对数似然关于 $\\theta_j$ 的偏导数：\n$$\n\\frac{\\partial \\ell}{\\partial \\theta_j} = \\sum_{t=1}^{T} \\frac{\\partial}{\\partial \\theta_j} \\left(-\\frac{1}{2} \\left[ \\log(h_t) + \\frac{r_t^2}{h_t} \\right]\\right) = \\sum_{t=1}^{T} \\left( -\\frac{1}{2} \\left[ \\frac{1}{h_t} - \\frac{r_t^2}{h_t^2} \\right] \\right) \\frac{\\partial h_t}{\\partial \\theta_j}\n$$\n该表达式可简化为：\n$$\n\\frac{\\partial \\ell}{\\partial \\theta_j} = \\sum_{t=1}^{T} \\frac{1}{2h_t^2} \\left( r_t^2 - h_t \\right) \\frac{\\partial h_t}{\\partial \\theta_j}\n$$\n为了计算该梯度，我们必须计算条件方差的时间序列 $\\{h_t\\}_{t=1}^T$ 及其关于每个参数的偏导数序列 $\\{\\frac{\\partial h_t}{\\partial \\theta_j}\\}_{t=1}^T$。这些序列可通过从 GARCH($1$,$1$) 方差方程推导出的递推关系获得。\n\n首先，我们建立 $\\{h_t\\}$ 的递推关系。问题指定了初始化 $h_0 = \\frac{\\omega}{1-\\alpha-\\beta}$ 和 $\\varepsilon_0^2 = h_0$。对于 $t>1$，$\\varepsilon_{t-1}^2 = r_{t-1}^2$ 由数据给出。在 $t=1$ 时的条件方差为：\n$$\nh_1 = \\omega + \\alpha \\varepsilon_0^2 + \\beta h_0 = \\omega + (\\alpha + \\beta) h_0 = \\omega + (\\alpha + \\beta) \\frac{\\omega}{1-\\alpha-\\beta} = \\frac{\\omega(1-\\alpha-\\beta) + \\omega(\\alpha+\\beta)}{1-\\alpha-\\beta} = \\frac{\\omega}{1-\\alpha-\\beta}\n$$\n这是该过程的无条件方差。对于 $t=2, \\dots, T$，方差通过递推计算：\n$$\nh_t = \\omega + \\alpha r_{t-1}^2 + \\beta h_{t-1}\n$$\n\n接下来，我们推导 $h_t$ 偏导数的递推公式。\n\n**1. 关于 $\\omega$ 的导数**\n我们将 $h_t$ 的表达式对 $\\omega$ 求导。\n对于 $t=1$：\n$$ \\frac{\\partial h_1}{\\partial \\omega} = \\frac{\\partial}{\\partial \\omega} \\left(\\frac{\\omega}{1-\\alpha-\\beta}\\right) = \\frac{1}{1-\\alpha-\\beta} $$\n对于 $t > 1$：\n$$ \\frac{\\partial h_t}{\\partial \\omega} = \\frac{\\partial}{\\partial \\omega} (\\omega + \\alpha r_{t-1}^2 + \\beta h_{t-1}) = 1 + \\beta \\frac{\\partial h_{t-1}}{\\partial \\omega} $$\n这为 $\\{\\frac{\\partial h_t}{\\partial \\omega}\\}_{t=1}^T$ 定义了一个简单的线性递推关系。\n\n**2. 关于 $\\alpha$ 的导数**\n我们对 $\\alpha$ 求导。对于 $t=1$：\n$$ \\frac{\\partial h_1}{\\partial \\alpha} = \\frac{\\partial}{\\partial \\alpha} \\left(\\frac{\\omega}{1-\\alpha-\\beta}\\right) = \\omega(-1)(1-\\alpha-\\beta)^{-2}(-1) = \\frac{\\omega}{(1-\\alpha-\\beta)^2} $$\n对于 $t > 1$，$r_{t-1}^2$ 是一个固定的数据点，其对 $\\alpha$ 的导数为零：\n$$ \\frac{\\partial h_t}{\\partial \\alpha} = \\frac{\\partial}{\\partial \\alpha} (\\omega + \\alpha r_{t-1}^2 + \\beta h_{t-1}) = r_{t-1}^2 + \\beta \\frac{\\partial h_{t-1}}{\\partial \\alpha} $$\n\n**3. 关于 $\\beta$ 的导数**\n我们对 $\\beta$ 求导。对于 $t=1$：\n$$ \\frac{\\partial h_1}{\\partial \\beta} = \\frac{\\partial}{\\partial \\beta} \\left(\\frac{\\omega}{1-\\alpha-\\beta}\\right) = \\omega(-1)(1-\\alpha-\\beta)^{-2}(-1) = \\frac{\\omega}{(1-\\alpha-\\beta)^2} $$\n对于 $t > 1$：\n$$ \\frac{\\partial h_t}{\\partial \\beta} = \\frac{\\partial}{\\partial \\beta} (\\omega + \\alpha r_{t-1}^2 + \\beta h_{t-1}) = h_{t-1} + \\beta \\frac{\\partial h_{t-1}}{\\partial \\beta} $$\n\n**算法总结**\n\n为计算给定参数集 $\\theta = (\\omega, \\alpha, \\beta)$ 和收益率序列 $\\{r_t\\}_{t=1}^T$ 的梯度向量 $\\nabla_\\theta \\ell(\\theta)$，我们执行以下步骤：\n\n1.  初始化长度为 $T$ 的数组，用于存储序列 $h_t$、$\\frac{\\partial h_t}{\\partial \\omega}$、$\\frac{\\partial h_t}{\\partial \\alpha}$ 和 $\\frac{\\partial h_t}{\\partial \\beta}$（$t=1, \\dots, T$）。\n2.  计算 $t=1$ 时的初始值：\n    -   $h_1 = \\frac{\\omega}{1-\\alpha-\\beta}$\n    -   $\\frac{\\partial h_1}{\\partial \\omega} = \\frac{1}{1-\\alpha-\\beta}$\n    -   $\\frac{\\partial h_1}{\\partial \\alpha} = \\frac{\\omega}{(1-\\alpha-\\beta)^2}$\n    -   $\\frac{\\partial h_1}{\\partial \\beta} = \\frac{\\omega}{(1-\\alpha-\\beta)^2}$\n3.  从 $t=2$ 迭代到 $T$，使用 $t-1$ 时刻已计算的值来计算每个序列的值：\n    -   $h_t = \\omega + \\alpha r_{t-1}^2 + \\beta h_{t-1}$\n    -   $\\frac{\\partial h_t}{\\partial \\omega} = 1 + \\beta \\frac{\\partial h_{t-1}}{\\partial \\omega}$\n    -   $\\frac{\\partial h_t}{\\partial \\alpha} = r_{t-1}^2 + \\beta \\frac{\\partial h_{t-1}}{\\partial \\alpha}$\n    -   $\\frac{\\partial h_t}{\\partial \\beta} = h_{t-1} + \\beta \\frac{\\partial h_{t-1}}{\\partial \\beta}$\n4.  将梯度分量 $(\\frac{\\partial \\ell}{\\partial \\omega}, \\frac{\\partial \\ell}{\\partial \\alpha}, \\frac{\\partial \\ell}{\\partial \\beta})$ 初始化为零。\n5.  从 $t=1$ 迭代到 $T$，计算每个时间步对总梯度的贡献并累加求和：\n    -   公共因子：$c_t = \\frac{1}{2h_t^2} ( r_t^2 - h_t )$\n    -   $\\frac{\\partial \\ell}{\\partial \\omega} \\mathrel{+}= c_t \\cdot \\frac{\\partial h_t}{\\partial \\omega}$\n    -   $\\frac{\\partial \\ell}{\\partial \\alpha} \\mathrel{+}= c_t \\cdot \\frac{\\partial h_t}{\\partial \\alpha}$\n    -   $\\frac{\\partial \\ell}{\\partial \\beta} \\mathrel{+}= c_t \\cdot \\frac{\\partial h_t}{\\partial \\beta}$\n6.  最终的累加和构成了梯度向量。该过程在所提供的程序中实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_garch_gradient(r, omega, alpha, beta):\n    \"\"\"\n    Computes the analytical gradient of the GARCH(1,1) log-likelihood.\n\n    Args:\n        r (np.ndarray): The series of returns.\n        omega (float): GARCH parameter omega.\n        alpha (float): GARCH parameter alpha.\n        beta (float): GARCH parameter beta.\n\n    Returns:\n        list[float]: The gradient vector [d_ell/d_omega, d_ell/d_alpha, d_ell/d_beta].\n    \"\"\"\n    T = len(r)\n    r_sq = r**2\n\n    # Arrays to store h_t and its derivatives\n    h = np.zeros(T)\n    dh_domega = np.zeros(T)\n    dh_dalpha = np.zeros(T)\n    dh_dbeta = np.zeros(T)\n    \n    # Check for stationarity condition to avoid division by zero\n    stat_denom = 1.0 - alpha - beta\n    if stat_denom = 0:\n        # Parameters violate the stationarity constraint, which would make h0 infinite or negative.\n        # This case is not expected for the given valid test cases but is good practice.\n        return [np.nan, np.nan, np.nan]\n\n    # Initialization for t=1 (index 0)\n    # h_1 = omega / (1 - alpha - beta)\n    h[0] = omega / stat_denom\n    \n    # Derivatives of h_1\n    # dh1/d_omega = 1 / (1 - alpha - beta)\n    dh_domega[0] = 1.0 / stat_denom\n    # dh1/d_alpha = omega / (1 - alpha - beta)^2\n    dh_dalpha[0] = omega / (stat_denom**2)\n    # dh1/d_beta = omega / (1 - alpha - beta)^2\n    dh_dbeta[0] = omega / (stat_denom**2)\n    \n    # Recursive calculation for t = 2 to T (indices 1 to T-1)\n    for t in range(1, T):\n        # h_t = omega + alpha * r_{t-1}^2 + beta * h_{t-1}\n        h[t] = omega + alpha * r_sq[t-1] + beta * h[t-1]\n        \n        # dh_t/d_omega = 1 + beta * dh_{t-1}/d_omega\n        dh_domega[t] = 1.0 + beta * dh_domega[t-1]\n        \n        # dh_t/d_alpha = r_{t-1}^2 + beta * dh_{t-1}/d_alpha\n        dh_dalpha[t] = r_sq[t-1] + beta * dh_dalpha[t-1]\n        \n        # dh_t/d_beta = h_{t-1} + beta * dh_{t-1}/d_beta\n        dh_dbeta[t] = h[t-1] + beta * dh_dbeta[t-1]\n        \n    # Compute the gradient of the log-likelihood\n    grad_omega = 0.0\n    grad_alpha = 0.0\n    grad_beta = 0.0\n    \n    for t in range(T):\n        common_factor = 0.5 * (r_sq[t] / h[t] - 1.0) / h[t]\n        grad_omega += common_factor * dh_domega[t]\n        grad_alpha += common_factor * dh_dalpha[t]\n        grad_beta += common_factor * dh_dbeta[t]\n\n    return [grad_omega, grad_alpha, grad_beta]\n\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    # Define the data and test cases from the problem statement.\n    returns_data = np.array([\n        0.004, -0.002, 0.006, 0.000, -0.007, 0.005, \n        -0.0035, 0.001, 0.000, 0.0045, -0.0025, 0.003\n    ])\n    \n    test_cases = [\n        (0.00001, 0.05, 0.90),  # theta_1\n        (0.00001, 0.09, 0.90),  # theta_2\n        (0.00002, 0.00, 0.80),  # theta_3\n        (0.00002, 0.10, 0.00)   # theta_4\n    ]\n\n    results = []\n    for params in test_cases:\n        omega, alpha, beta = params\n        gradient = compute_garch_gradient(returns_data, omega, alpha, beta)\n        results.append(gradient)\n\n    # Format the results into the required string format.\n    # The string representation of a list in Python already includes brackets and spaces.\n    # Joining the string representations of each gradient list with a comma\n    # and enclosing in outer brackets produces the desired format.\n    # e.g., \"[[g1_w, g1_a, g1_b],[g2_w, g2_a, g2_b]]\"\n    result_str = f\"[{','.join(map(str, results))}]\"\n    \n    # To remove spaces for a more compact representation, though not strictly required by example\n    result_str_no_space = result_str.replace(\" \", \"\")\n\n    print(result_str_no_space)\n\nsolve()\n```", "id": "2395726"}, {"introduction": "在时间序列分析中，获得一个统计上显著的模型仅仅是第一步，模型诊断同样至关重要。一个常见的陷阱是，模型的设定偏误可能会导致虚假的结论，例如，忽略了均值中的结构性突变，却错误地检测到了GARCH效应。本实践[@problem_id:2399496]通过一个模拟研究，清晰地揭示了这种伪GARCH效应，旨在培养你审慎的建模习惯和诊断模型设定问题的能力。", "problem": "您的任务是设计并实现一个仿真和测试程序，用于研究时间序列均值中的结构性断点如何被标准的自回归条件异方差检验错误地识别为一阶的广义自回归条件异方差（GARCH），记作 $GARCH(1,1)$。您的程序必须是完全自包含的，并且无需任何用户交互即可产生结果。\n\n需要使用的基本依据包括以下经过充分检验的定义和事实。\n\n- 如果一个时间序列 $\\{y_t\\}_{t=1}^T$ 的确定性均值在已知时间 $T_b$ 之后（即从 $t = T_b + 1$ 开始）从 $\\mu_1$ 变为 $\\mu_2$，而其创新方差保持不变，则称该序列在时间 $T_b$ 处存在均值上的结构性断点。具体而言，对于 $t \\le T_b$，$y_t = \\mu_1 + \\varepsilon_t$；对于 $t  T_b$，$y_t = \\mu_2 + \\varepsilon_t$，其中 $\\varepsilon_t \\overset{iid}{\\sim} \\mathcal{N}(0,\\sigma^2)$。\n- 一个普通最小二乘（OLS）均值模型为 $y_t = x_t^{\\prime}\\beta + \\varepsilon_t$，其中 $x_t$ 包含一个截距项，并在适用时包含额外的回归量，例如一个断点虚拟变量 $d_t$，其中对于 $t \\le T_b$，$d_t = 0$，对于 $t  T_b$，$d_t = 1$。OLS残差为 $e_t = y_t - x_t^{\\prime}\\hat{\\beta}$。\n- 对于零均值的创新序列 $\\{u_t\\}$，其 $GARCH(1,1)$ 模型为 $u_t = \\sqrt{h_t} z_t$，其中 $z_t \\overset{iid}{\\sim} \\mathcal{N}(0,1)$，条件方差为 $h_t = \\omega + \\alpha u_{t-1}^2 + \\beta h_{t-1}$。参数需满足 $\\omega  0$、$\\alpha \\ge 0$、$\\beta \\ge 0$ 以及 $\\alpha + \\beta  1$ 以确保无条件方差为有限值。观测到的序列为 $y_t = \\mu + u_t$。\n- 对 OLS 残差序列 $\\{e_t\\}$ 进行的 $q$ 阶自回归条件异方差的恩格尔（Engle）拉格朗日乘数（LM）检验，其过程是将 $e_t^2$ 对一个常数项和 $q$ 阶滞后的 $e_t^2$ 进行回归，计算决定系数 $R^2$，并构建统计量 $LM = n R^2$，其中 $n$ 为该回归中可用的观测数量。在截至滞后 $q$ 阶不存在自回归条件异方差的原假设下，$LM$ 渐近服从自由度为 $q$ 的 $\\chi^2_q$ 分布。$p$-值为 $1 - F_{\\chi^2_q}(LM)$，其中 $F_{\\chi^2_q}$ 是自由度为 $q$ 的卡方分布的累积分布函数。\n\n您的任务是精确地实现以下步骤。\n\n1. 模拟数据生成过程（DGP）：\n   - 均值存在结构性断点且方差恒定：对于给定的参数 $T$、$\\mu_1$、$\\mu_2$、$\\sigma$ 和断点位置比例 $b \\in (0,1)$，模拟 $\\{y_t\\}$，其中 $T_b = \\lfloor b T \\rfloor$，$\\varepsilon_t \\overset{iid}{\\sim} \\mathcal{N}(0,\\sigma^2)$，如上所述。\n   - 无断点的独立同分布（iid）同方差序列：$y_t = \\mu + \\varepsilon_t$，$\\varepsilon_t \\overset{iid}{\\sim} \\mathcal{N}(0,\\sigma^2)$。\n   - 无均值断点的 $GARCH(1,1)$ 序列：$y_t = \\mu + u_t$，其中 $u_t$ 服从前述定义的 $GARCH(1,1)$ 过程。将 $h_0$ 初始化为无条件方差 $h_0 = \\omega/(1-\\alpha-\\beta)$，并使用 500 个步骤的预热期来减轻初始化效应的影响。\n\n2. 建模与残差提取：\n   - 对每个模拟序列，拟合两个 OLS 均值模型以获得残差 $\\{e_t\\}$：\n     - 错误设定的均值：仅含截距项的模型，$x_t = [1]$ 对所有 $t$ 成立。\n     - 正确设定的均值：当 DGP 存在结构性断点时，模型包含截距项和断点虚拟变量，即 $x_t = [1, d_t]$；否则为仅含截距项的模型。\n\n3. 自回归条件异方差检验：\n   - 对每组残差和指定的滞后阶数 $q$，运行上述的恩格尔 LM 检验，并基于 $\\chi^2_q$ 分布计算 $p$-值。\n\n4. 解释原则（供您推理时使用，不作为输出的一部分）：低的 $p$-值表示拒绝无自回归条件异方差的原假设。需要观察的核心现象是，当均值模型设定错误时，均值中的结构性断点会在 $e_t^2$ 中引发序列相关性，从而导致对 $GARCH$ 类行为的虚假检出。\n\n使用以下参数集测试套件。所有随机抽样必须使用相同的固定种子 $12345$ 生成，以确保结果可复现。\n\n- 测试用例1（理想路径，样本中段的强断点）：\n  - DGP：均值存在结构性断点，方差恒定。\n  - 参数：$T = 4000$, $\\mu_1 = 0.0$, $\\mu_2 = 2.0$, $\\sigma = 1.0$, $b = 0.5$, $q = 5$。\n\n- 测试用例2（边界条件，后期断点，检验中最小滞后阶数）：\n  - DGP：均值存在结构性断点，方差恒定。\n  - 参数：$T = 4000$, $\\mu_1 = 0.0$, $\\mu_2 = 3.0$, $\\sigma = 1.0$, $b = 0.9$, $q = 1$。\n\n- 测试用例3（边缘情况，真实的 $GARCH(1,1)$）：\n  - DGP：无均值断点的 $GARCH(1,1)$。\n  - 参数：$T = 5000$, $\\mu = 0.0$, $\\omega = 0.1$, $\\alpha = 0.05$, $\\beta = 0.9$, $q = 5$。\n\n- 测试用例4（对照组，iid 同方差）：\n  - DGP：无均值断点的同方差 iid。\n  - 参数：$T = 4000$, $\\mu = 0.0$, $\\sigma = 1.0$, $q = 5$。\n\n每个测试用例的所需输出：\n\n- 对每个测试用例 $i \\in \\{1,2,3,4\\}$，计算两个 $p$-值：\n  - $p^{(i)}_{\\text{misspec}}$：使用仅含截距项的均值模型得到的 LM 检验 $p$-值。\n  - $p^{(i)}_{\\text{well}}$：使用正确设定的均值模型（仅在适用时包含断点虚拟变量）得到的 LM 检验 $p$-值。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表包含 8 个结果，顺序严格为\n  $[p^{(1)}_{\\text{misspec}}, p^{(1)}_{\\text{well}}, p^{(2)}_{\\text{misspec}}, p^{(2)}_{\\text{well}}, p^{(3)}_{\\text{misspec}}, p^{(3)}_{\\text{well}}, p^{(4)}_{\\text{misspec}}, p^{(4)}_{\\text{well}}]$，\n  每个值四舍五入到六位小数。例如，输出可能看起来像 $[0.000001,0.845210,0.000004,0.612345,0.000000,0.000000,0.523410,0.523410]$。\n\n此问题中的所有量均为无单位的实数，不涉及任何物理单位。不使用角度。百分比（当在概念上引用时）必须作为小数处理；但是，您必须仅输出上述指定的 $p$-值。", "solution": "问题陈述已经过严格验证，并被认定为有效。它在已建立的计量经济学理论中具有科学依据，特别是关于时间序列模型设定错误的研究。该问题是适定的，为获得唯一、可验证的解提供了完整且一致的定义、参数和程序。不存在逻辑矛盾、歧义或事实不准确之处。该任务是计量经济学中的一个标准计算练习，而非要求主观看法或推测性推理。我们现在开始进行系统性求解。\n\n目标是，通过计算来展示时间序列均值中的结构性断点（如果未被正确建模）如何产生自回归条件异方差（ARCH）的虚假证据，这种现象在实践中可能导致不正确的模型选择。解决方案分为三个主要阶段：数据模拟、模型估计与残差提取，以及假设检验。\n\n首先，我们处理指定的三种不同数据生成过程（DGP）的模拟。对所有随机操作使用固定的随机种子 $12345$，以确保可复现性。\n\n1.  **结构性断点序列**：一个长度为 $T$ 的时间序列 $\\{y_t\\}_{t=1}^T$，其均值存在单一断点，根据以下模型生成：\n    $$\n    y_t =\n    \\begin{cases}\n    \\mu_1 + \\varepsilon_t  \\text{若 } t \\le T_b \\\\\n    \\mu_2 + \\varepsilon_t  \\text{若 } t  T_b\n    \\end{cases}\n    $$\n    其中，断点为 $T_b = \\lfloor bT \\rfloor$（给定断点比例 $b \\in (0,1)$），扰动项 $\\varepsilon_t$ 是从正态分布 $\\varepsilon_t \\overset{iid}{\\sim} \\mathcal{N}(0, \\sigma^2)$ 中抽取的独立同分布（iid）样本。\n\n2.  **GARCH(1,1) 序列**：一个由广义自回归条件异方差(1,1)过程控制的时间序列 $\\{y_t\\}_{t=1}^T$ 按 $y_t = \\mu + u_t$ 生成。创新项 $u_t$ 由 $u_t = \\sqrt{h_t} z_t$ 定义，其中 $z_t \\overset{iid}{\\sim} \\mathcal{N}(0,1)$。条件方差 $h_t$ 按以下方式演化：\n    $$\n    h_t = \\omega + \\alpha u_{t-1}^2 + \\beta h_{t-1}\n    $$\n    参数必须满足平稳性条件 $\\omega  0, \\alpha \\ge 0, \\beta \\ge 0$ 和 $\\alpha + \\beta  1$。模拟从 $h_0$ 设置为无条件方差 $h_{uncond} = \\frac{\\omega}{1-\\alpha-\\beta}$ 开始，并生成最初的 500 个数据点后丢弃，以减轻初始化偏差。\n\n3.  **IID 同方差序列**：这是一个作为基线的对照序列，生成方式为 $y_t = \\mu + \\varepsilon_t$，其中 $\\varepsilon_t \\overset{iid}{\\sim} \\mathcal{N}(0, \\sigma^2)$。\n\n其次，对每个模拟序列 $\\{y_t\\}$，通过两种不同的普通最小二乘法（OLS）均值模型设定来获取残差。通用 OLS 模型为 $y_t = x_t^{\\prime}\\beta + e_t$，其中 $x_t$ 是回归量向量，$\\beta$ 是系数向量，$e_t$ 是残差。$\\beta$ 的 OLS 估计量为 $\\hat{\\beta} = (X'X)^{-1}X'y$，其中 $X$ 和 $y$ 分别是回归量和因变量的矩阵和向量形式。然后残差计算为 $e = y - X\\hat{\\beta}$。\n\n1.  **错误设定的模型**：此模型始终假设一个简单的常数均值，通过单一回归量（一个截距项）实现。因此，对所有 $t$，$x_t = [1]$。对于具有结构性断点的 DGP，此模型是错误设定的。\n\n2.  **正确设定的模型**：此模型正确反映了 DGP 的底层均值结构。对于结构性断点 DGP，回归量是一个截距项和一个断点虚拟变量 $d_t$，其中对于 $t \\le T_b$，$d_t=0$；对于 $t  T_b$，$d_t=1$。因此，$x_t = [1, d_t]$。对于具有常数均值的 GARCH 和 IID DGP，正确设定的模型与错误设定的模型相同，仅包含一个截距项。\n\n第三，对从每个模型中提取的残差序列 $\\{e_t\\}$，进行 $q$ 阶 ARCH 效应的恩格尔拉格朗日乘数（LM）检验。该检验的原假设是不存在直到 $q$ 阶的 ARCH 效应，即在辅助回归中 $H_0: \\gamma_1 = \\gamma_2 = \\dots = \\gamma_q = 0$：\n$$\ne_t^2 = \\gamma_0 + \\gamma_1 e_{t-1}^2 + \\dots + \\gamma_q e_{t-q}^2 + \\nu_t\n$$\nLM 检验统计量计算为 $LM = nR^2$，其中 $n$ 是辅助回归中的观测数量（$n = T-q$），$R^2$ 是此回归的决定系数。在原假设下，LM 统计量渐近服从自由度为 $q$ 的卡方分布，$LM \\sim \\chi^2_q$。$p$-值是观测到至少与计算出的检验统计量一样极端的检验统计量的概率，由 $1 - F_{\\chi^2_q}(LM)$ 给出，其中 $F_{\\chi^2_q}$ 是 $\\chi^2_q$ 分布的累积分布函数。\n\n一个低的 $p$-值（例如 $ 0.05$）会导致拒绝原假设，表明存在 ARCH 效应。分析的核心在于比较结构性断点 DGP 的错误设定模型和正确设定模型的 $p$-值。如果错误设定的模型产生低的 $p$-值，而正确设定的模型产生高的 $p$-值，则证实了 ARCH 的虚假检出。对于 GARCH DGP，预计两个模型都会产生低的 $p$-值。对于 IID DGP，预计两个模型都会产生高的 $p$-值。对四个指定的测试用例中的每一个都实施整个过程，以生成所需的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    \n    # Establish a reproducible random number generator\n    rng = np.random.default_rng(12345)\n\n    def generate_structural_break(T, mu1, mu2, sigma, b, rng_gen):\n        \"\"\"Generates a time series with a structural break in the mean.\"\"\"\n        Tb = int(np.floor(b * T))\n        innovations = rng_gen.normal(loc=0.0, scale=sigma, size=T)\n        y = np.zeros(T)\n        y[:Tb] = mu1 + innovations[:Tb]\n        y[Tb:] = mu2 + innovations[Tb:]\n        return y, Tb\n\n    def generate_garch(T, mu, omega, alpha, beta, rng_gen):\n        \"\"\"Generates a GARCH(1,1) time series.\"\"\"\n        burn_in = 500\n        total_len = T + burn_in\n        \n        z = rng_gen.normal(loc=0.0, scale=1.0, size=total_len)\n        u = np.zeros(total_len)\n        h = np.zeros(total_len)\n        \n        h[0] = omega / (1 - alpha - beta)\n        u[0] = np.sqrt(h[0]) * z[0]\n        \n        for t in range(1, total_len):\n            h[t] = omega + alpha * u[t-1]**2 + beta * h[t-1]\n            u[t] = np.sqrt(h[t]) * z[t]\n        \n        y = mu + u[burn_in:]\n        return y\n\n    def generate_iid(T, mu, sigma, rng_gen):\n        \"\"\"Generates an IID homoskedastic time series.\"\"\"\n        innovations = rng_gen.normal(loc=0.0, scale=sigma, size=T)\n        y = mu + innovations\n        return y\n\n    def get_residuals(y, with_break_dummy, Tb=None):\n        \"\"\"\n        Fits an OLS model to the data and returns the residuals.\n        \"\"\"\n        T = len(y)\n        if with_break_dummy:\n            if Tb is None:\n                raise ValueError(\"Tb must be provided for break dummy model.\")\n            X = np.ones((T, 2))\n            dummy = np.zeros(T)\n            dummy[Tb:] = 1.0\n            X[:, 1] = dummy\n        else:\n            X = np.ones((T, 1))\n\n        beta_hat = np.linalg.lstsq(X, y, rcond=None)[0]\n        y_hat = X @ beta_hat\n        residuals = y - y_hat\n        return residuals\n\n    def engle_lm_test(residuals, q):\n        \"\"\"\n        Performs the Engle LM test for ARCH effects.\n        \"\"\"\n        T = len(residuals)\n        e_sq = residuals**2\n        \n        # Dependent variable for the auxiliary regression\n        Y_aux = e_sq[q:]\n        n = len(Y_aux) # n = T - q\n        \n        # Independent variables (constant + q lags of e_sq)\n        X_aux = np.ones((n, q + 1))\n        for i in range(q):\n            # lag i+1\n            X_aux[:, i + 1] = e_sq[q - 1 - i : T - 1 - i]\n            \n        # OLS on the auxiliary regression\n        try:\n            # lstsq returns sum of squared residuals in the second element\n            rss_val = np.linalg.lstsq(X_aux, Y_aux, rcond=None)[1][0]\n        except IndexError:\n            # This can happen if the problem is perfectly determined, rss is empty.\n            rss_val = 0.0\n\n        # Total sum of squares of the dependent variable\n        tss = np.sum((Y_aux - np.mean(Y_aux))**2)\n        \n        if tss  1e-12: # Handle cases with zero variance\n             R2 = 0.0\n        else:\n            R2 = 1 - rss_val / tss\n\n        lm_stat = n * R2\n        p_value = 1 - chi2.cdf(lm_stat, q)\n        \n        return p_value\n\n    test_cases = [\n        {'type': 'break', 'params': {'T': 4000, 'mu1': 0.0, 'mu2': 2.0, 'sigma': 1.0, 'b': 0.5, 'q': 5}},\n        {'type': 'break', 'params': {'T': 4000, 'mu1': 0.0, 'mu2': 3.0, 'sigma': 1.0, 'b': 0.9, 'q': 1}},\n        {'type': 'garch', 'params': {'T': 5000, 'mu': 0.0, 'omega': 0.1, 'alpha': 0.05, 'beta': 0.9, 'q': 5}},\n        {'type': 'iid', 'params': {'T': 4000, 'mu': 0.0, 'sigma': 1.0, 'q': 5}}\n    ]\n    \n    results = []\n    \n    # Test case 1\n    case = test_cases[0]\n    params = case['params']\n    y, Tb = generate_structural_break(params['T'], params['mu1'], params['mu2'], params['sigma'], params['b'], rng)\n    res_misspec = get_residuals(y, with_break_dummy=False)\n    p_misspec = engle_lm_test(res_misspec, params['q'])\n    res_well = get_residuals(y, with_break_dummy=True, Tb=Tb)\n    p_well = engle_lm_test(res_well, params['q'])\n    results.extend([p_misspec, p_well])\n    \n    # Test case 2\n    case = test_cases[1]\n    params = case['params']\n    y, Tb = generate_structural_break(params['T'], params['mu1'], params['mu2'], params['sigma'], params['b'], rng)\n    res_misspec = get_residuals(y, with_break_dummy=False)\n    p_misspec = engle_lm_test(res_misspec, params['q'])\n    res_well = get_residuals(y, with_break_dummy=True, Tb=Tb)\n    p_well = engle_lm_test(res_well, params['q'])\n    results.extend([p_misspec, p_well])\n\n    # Test case 3\n    case = test_cases[2]\n    params = case['params']\n    y = generate_garch(params['T'], params['mu'], params['omega'], params['alpha'], params['beta'], rng)\n    # For GARCH DGP, both misspecified and well-specified models are intercept-only\n    res = get_residuals(y, with_break_dummy=False)\n    p_val = engle_lm_test(res, params['q'])\n    results.extend([p_val, p_val])\n\n    # Test case 4\n    case = test_cases[3]\n    params = case['params']\n    y = generate_iid(params['T'], params['mu'], params['sigma'], rng)\n    # For IID DGP, both misspecified and well-specified models are intercept-only\n    res = get_residuals(y, with_break_dummy=False)\n    p_val = engle_lm_test(res, params['q'])\n    results.extend([p_val, p_val])\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{v:.6f}' for v in results)}]\")\n\nsolve()\n```", "id": "2399496"}]}