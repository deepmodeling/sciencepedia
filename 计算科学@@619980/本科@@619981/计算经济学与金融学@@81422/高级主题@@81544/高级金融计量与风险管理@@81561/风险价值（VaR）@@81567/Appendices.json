{"hands_on_practices": [{"introduction": "风险管理的一个核心原则是多样化，即合并资产通常可以降低总体风险。然而，在险价值（VaR）作为一种风险度量，并不总是遵守这一原则。本练习通过蒙特卡洛模拟，直观地揭示了VaR的一个关键理论缺陷：次可加性的缺失 ([@problem_id:2412240])。你将构建一个反例，其中两个资产组合的VaR竟然高于各资产VaR之和，从而深刻理解为何VaR在某些情况下可能误导决策，以及为何金融界寻求更稳健的风险度量。", "problem": "构建一个独立的程序，从基本原理出发，计算在特定情况下风险价值（VaR）是否具有次可加性。设损失为一个实值随机变量。对于一个损失随机变量 $X$，其累积分布函数为 $F_X(x)$，给定一个水平 $\\alpha \\in (0,1)$，将水平为 $\\alpha$ 的风险价值定义为\n$$\n\\operatorname{VaR}_{\\alpha}(X) = \\inf\\{x \\in \\mathbb{R} : F_X(x) \\ge \\alpha\\}.\n$$\n给定一个来自 $X$ 的独立同分布样本 $L_1,\\dots,L_n$，定义经验分布函数 $F_n(x) = \\frac{1}{n} \\sum_{i=1}^n \\mathbf{1}\\{L_i \\le x\\}$ 和经验风险价值估计量\n$$\n\\widehat{\\operatorname{VaR}}_{\\alpha}(X) = \\inf\\{x \\in \\mathbb{R} : F_n(x) \\ge \\alpha\\}.\n$$\n考虑以下每个测试案例中的两个损失随机变量 $A$ 和 $B$，并定义投资组合损失 $P = A + B$。对于每个测试案例 $j$，计算布尔结果\n$$\nI_j = \\big[\\widehat{\\operatorname{VaR}}_{\\alpha}(P) > \\widehat{\\operatorname{VaR}}_{\\alpha}(A) + \\widehat{\\operatorname{VaR}}_{\\alpha}(B)\\big].\n$$\n所有案例均使用相同的样本量 $n$ 和相同的固定伪随机种子 $s$。所有概率都应解释为 $[0,1]$ 范围内的小数。不涉及物理单位。\n\n您的程序必须实现以下测试套件。在所有案例中，抽样数量为 $n = 400,000$，伪随机种子为 $s = 20231407$。所有伯努利事件和标准正态变量都必须根据指定的依赖结构进行抽取。\n\n- 测试案例 1（独立的罕见大额损失）：$\\alpha = 0.95$。资产 $A$ 以 $0.03$ 的概率产生 $10$ 的损失，否则损失为 $0$。资产 $B$ 具有相同的分布。$A$ 和 $B$ 相互独立。\n- 测试案例 2（独立的非对称罕见损失）：$\\alpha = 0.975$。资产 $A$ 以 $0.02$ 的概率产生 $8$ 的损失，否则损失为 $0$。资产 $B$ 以 $0.02$ 的概率产生 $12$ 的损失，否则损失为 $0$。$A$ 和 $B$ 相互独立。\n- 测试案例 3（同单调的罕见损失）：$\\alpha = 0.95$。资产 $A$ 以 $0.03$ 的概率产生 $10$ 的损失，否则损失为 $0$。资产 $B$ 具有相同的边际分布。其依赖关系是同单调的：存在一个在 $[0,1]$ 上均匀分布的变量 $U$，当且仅当 $U  0.03$ 时，A 和 B 同时达到其损失水平，否则二者均为 $0$。\n- 测试案例 4（相关的高斯损失）：$\\alpha = 0.99$。资产 $A$ 是均值为 $0$、标准差为 $1$ 的高斯分布。资产 $B$ 是均值为 $0$、标准差为 $1.2$ 的高斯分布。$A$ 和 $B$ 之间的相关系数为 $0.6$。\n- 测试案例 5（完全负相关的高斯损失）：$\\alpha = 0.99$。资产 $A$ 是均值为 $0$、标准差为 $1$ 的高斯分布。资产 $B$ 几乎必然等于 $-A$（完全负相关），因此投资组合损失恒为 $0$。\n\n对于每个案例，生成完全符合所述分布和依赖关系的 $n$ 组成对样本 $(A_i,B_i)$。使用上述 $\\widehat{\\operatorname{VaR}}_{\\alpha}$ 的定义，计算 $A$、$B$ 和 $P = A+B$ 在指定水平 $\\alpha$ 下的经验风险价值。然后计算定义的 $I_j$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的结果列表，以逗号分隔（例如，\"[true,false,true,true,false]\"），但使用大写的 Python 布尔字面量。也就是说，确切的输出格式必须是\n\"[result1,result2,result3,result4,result5]\"，其中每个结果为 \"True\" 或 \"False\"。", "solution": "该问题要求对风险价值（$\\operatorname{VaR}$）这一度量指标的次可加性进行计算研究。如果对于任意两个损失随机变量 $X$ 和 $Y$，不等式 $\\rho(X+Y) \\le \\rho(X) + \\rho(Y)$ 均成立，则称风险度量 $\\rho$ 具有次可加性。该性质将分散化原则形式化：合并后投资组合的风险不应大于其各组成部分风险之和。风险价值是一种广泛使用的风险度量，但它并不是 Artzner 等人 (1999) 定义下的一致性风险度量，这恰恰因为它可能不满足次可加性。本练习通过具体的构造性例子来证明这一点。\n\n任务是为五个不同的测试案例计算不等式 $\\widehat{\\operatorname{VaR}}_{\\alpha}(P) > \\widehat{\\operatorname{VaR}}_{\\alpha}(A) + \\widehat{\\operatorname{VaR}}_{\\alpha}(B)$ 的布尔结果，其中 $A$ 和 $B$ 是损失随机变量，$P=A+B$ 是投资组合损失，$\\widehat{\\operatorname{VaR}}_{\\alpha}$ 是在置信水平 $\\alpha$ 下的经验风险价值估计量。\n\n经验 $\\operatorname{VaR}$ 定义为 $\\widehat{\\operatorname{VaR}}_{\\alpha}(X) = \\inf\\{x \\in \\mathbb{R} : F_n(x) \\ge \\alpha\\}$，其中 $F_n(x)$ 是来自大小为 $n$ 的样本的经验累积分布函数。对于一个损失样本 $L_1, \\dots, L_n$，设其排序后的样本为 $L_{(1)} \\le L_{(2)} \\le \\dots \\le L_{(n)}$。经验累积分布函数 $F_n(x)$ 是一个阶梯函数，在每个数据点处跃升 $1/n$。条件 $F_n(x) \\ge \\alpha$ 等价于说至少有 $n\\alpha$ 个样本点小于或等于 $x$。这意味着 $x$ 必须至少与第 $\\lceil n\\alpha \\rceil$ 个顺序统计量一样大。因此，经验 VaR 正是该顺序统计量的值：\n$$\n\\widehat{\\operatorname{VaR}}_{\\alpha}(X) = L_{(\\lceil n\\alpha \\rceil)}\n$$\n我们对每个测试案例的通用流程如下：\n1.  使用固定的种子 $s = 20231407$ 初始化一个伪随机数生成器。\n2.  根据指定的边际分布和依赖结构，生成 $n = 400,000$ 组成对样本 $(A_i, B_i)$，其中 $i=1, \\dots, n$。\n3.  创建投资组合损失样本 $P_i = A_i + B_i$。\n4.  对于 $\\{A_i\\}$、$\\{B_i\\}$ 和 $\\{P_i\\}$这三个样本中的每一个，计算在指定水平 $\\alpha$ 下的经验 $\\operatorname{VaR}$。这包括对样本进行排序，并选择索引为 $k-1$（使用基于0的索引）的元素，其中 $k = \\lceil n\\alpha \\rceil$。\n5.  评估布尔表达式 $I_j = [\\widehat{\\operatorname{VaR}}_{\\alpha}(P) > \\widehat{\\operatorname{VaR}}_{\\alpha}(A) + \\widehat{\\operatorname{VaR}}_{\\alpha}(B)]$。\n\n每个案例的具体生成方法如下：\n\n测试案例 1（独立的罕见大额损失）：$\\alpha = 0.95$。$A$ 和 $B$ 的损失是从伯努利分布中抽取的，代表以概率 $p=0.03$ 发生大小为 $10$ 的损失，否则损失为 $0$。通过使用两组独立的均匀随机数流 $U_A$ 和 $U_B$ 来模拟独立性，以生成 $A$ 和 $B$ 的样本。对于每个 $i \\in \\{1, \\dots, n\\}$，如果 $U_{A,i}  0.03$ 则 $A_i=10$，否则 $A_i=0$，对 $B_i$ 使用 $U_{B,i}$ 进行类似操作。VaR 计算的索引为 $k = \\lceil 400,000 \\times 0.95 \\rceil = 380,000$。\n\n测试案例 2（独立的非对称罕见损失）：$\\alpha = 0.975$。此案例在结构上与第一个相似，但参数不对称。资产 $A$ 以 $0.02$ 的概率产生 $8$ 的损失，资产 $B$ 以 $0.02$ 的概率产生 $12$ 的损失。独立性再次通过独立的随机数流进行建模。VaR 索引为 $k = \\lceil 400,000 \\times 0.975 \\rceil = 390,000$。\n\n测试案例 3（同单调的罕见损失）：$\\alpha = 0.95$。$A$ 和 $B$ 的边际分布与案例 1 相同。然而，其依赖关系是同单调的。这通过使用单一的均匀随机数流 $U$ 来建模。对于每个 $i \\in \\{1, \\dots, n\\}$，如果 $U_i  0.03$，则 $A_i$ 和 $B_i$ 都设为 $10$，否则都为 $0$。这代表了尾部事件中的完全正相关。VaR 索引为 $k = \\lceil 400,000 \\times 0.95 \\rceil = 380,000$。\n\n测试案例 4（相关的高斯损失）：$\\alpha = 0.99$。$A \\sim \\mathcal{N}(0, 1^2)$ 且 $B \\sim \\mathcal{N}(0, 1.2^2)$，相关系数 $\\rho(A, B) = 0.6$。我们从此二元正态分布中生成成对样本。这可以通过首先生成成对的独立标准正态变量 $(Z_{1,i}, Z_{2,i})$，然后应用与协方差矩阵 $\\Sigma$ 的 Cholesky 分解相对应的线性变换来实现：\n$$\n\\Sigma = \\begin{pmatrix} \\sigma_A^2  \\rho \\sigma_A \\sigma_B \\\\ \\rho \\sigma_A \\sigma_B  \\sigma_B^2 \\end{pmatrix} = \\begin{pmatrix} 1  0.72 \\\\ 0.72  1.44 \\end{pmatrix}\n$$\n一个更简单、等价的构造是 $A_i = Z_{1,i}$ 和 $B_i = \\sigma_B (\\rho Z_{1,i} + \\sqrt{1-\\rho^2} Z_{2,i})$。VaR 索引为 $k = \\lceil 400,000 \\times 0.99 \\rceil = 396,000$。对于像多元正态分布这样的椭球分布，VaR 已知是次可加的。\n\n测试案例 5（完全负相关的高斯损失）：$\\alpha = 0.99$。资产 $A \\sim \\mathcal{N}(0, 1^2)$ 且 $B = -A$。这是一个完全对冲的案例。我们为 $A$ 生成一个标准正态变量样本，并将 $B$ 的样本设置为其逐元素取反。投资组合损失在所有结果中均为 $P = A+B = 0$。因此，其经验 $\\widehat{\\operatorname{VaR}}_{\\alpha}(P)$ 必定为 $0$。VaR 索引为 $k = \\lceil 400,000 \\times 0.99 \\rceil = 396,000$。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes whether Value-at-Risk (VaR) is subadditive in five specific cases.\n    \"\"\"\n    \n    # Global parameters\n    N_SAMPLES = 400_000\n    SEED = 20231407\n    \n    # Initialize a single random number generator for all simulations\n    rng = np.random.default_rng(SEED)\n\n    test_cases = [\n        # Case 1: Independent, rare large losses\n        {\n            \"alpha\": 0.95,\n            \"A\": {\"type\": \"bernoulli\", \"loss\": 10.0, \"p\": 0.03},\n            \"B\": {\"type\": \"bernoulli\", \"loss\": 10.0, \"p\": 0.03},\n            \"dep\": \"independent\"\n        },\n        # Case 2: Independent, asymmetric rare losses\n        {\n            \"alpha\": 0.975,\n            \"A\": {\"type\": \"bernoulli\", \"loss\": 8.0, \"p\": 0.02},\n            \"B\": {\"type\": \"bernoulli\", \"loss\": 12.0, \"p\": 0.02},\n            \"dep\": \"independent\"\n        },\n        # Case 3: Comonotonic rare losses\n        {\n            \"alpha\": 0.95,\n            \"A\": {\"type\": \"bernoulli\", \"loss\": 10.0, \"p\": 0.03},\n            \"B\": {\"type\": \"bernoulli\", \"loss\": 10.0, \"p\": 0.03},\n            \"dep\": \"comonotonic\"\n        },\n        # Case 4: Correlated Gaussian losses\n        {\n            \"alpha\": 0.99,\n            \"A\": {\"type\": \"gaussian\", \"mean\": 0.0, \"std\": 1.0},\n            \"B\": {\"type\": \"gaussian\", \"mean\": 0.0, \"std\": 1.2},\n            \"dep\": \"correlated\", \"rho\": 0.6\n        },\n        # Case 5: Perfectly negatively dependent Gaussian losses\n        {\n            \"alpha\": 0.99,\n            \"A\": {\"type\": \"gaussian\", \"mean\": 0.0, \"std\": 1.0},\n            \"B\": {\"type\": \"gaussian\", \"mean\": 0.0, \"std\": 1.0},\n            \"dep\": \"negatively_dependent\"\n        }\n    ]\n\n    results = []\n\n    def get_empirical_var(samples, alpha):\n        \"\"\"\n        Calculates the empirical Value-at-Risk.\n        Defined as the k-th order statistic, where k = ceil(n*alpha).\n        \"\"\"\n        n = len(samples)\n        k = math.ceil(n * alpha)\n        # Using k-1 for 0-based indexing\n        sorted_samples = np.sort(samples)\n        return sorted_samples[k - 1]\n\n    for case in test_cases:\n        alpha = case[\"alpha\"]\n        \n        # --- Generate samples for A and B based on the case ---\n        if case[\"dep\"] == \"independent\":\n            u_a = rng.random(size=N_SAMPLES)\n            u_b = rng.random(size=N_SAMPLES)\n            params_a = case[\"A\"]\n            samples_a = np.where(u_a  params_a[\"p\"], params_a[\"loss\"], 0.0)\n            params_b = case[\"B\"]\n            samples_b = np.where(u_b  params_b[\"p\"], params_b[\"loss\"], 0.0)\n\n        elif case[\"dep\"] == \"comonotonic\":\n            u = rng.random(size=N_SAMPLES)\n            params_a = case[\"A\"]\n            samples_a = np.where(u  params_a[\"p\"], params_a[\"loss\"], 0.0)\n            params_b = case[\"B\"]\n            samples_b = np.where(u  params_b[\"p\"], params_b[\"loss\"], 0.0)\n\n        elif case[\"dep\"] == \"correlated\":\n            params_a = case[\"A\"]\n            params_b = case[\"B\"]\n            rho = case[\"rho\"]\n            \n            mean = [params_a[\"mean\"], params_b[\"mean\"]]\n            cov = [[params_a[\"std\"]**2, rho * params_a[\"std\"] * params_b[\"std\"]],\n                   [rho * params_a[\"std\"] * params_b[\"std\"], params_b[\"std\"]**2]]\n            \n            samples = rng.multivariate_normal(mean, cov, size=N_SAMPLES)\n            samples_a = samples[:, 0]\n            samples_b = samples[:, 1]\n            \n        elif case[\"dep\"] == \"negatively_dependent\":\n            params_a = case[\"A\"]\n            samples_a = rng.normal(loc=params_a[\"mean\"], scale=params_a[\"std\"], size=N_SAMPLES)\n            samples_b = -samples_a\n        \n        # --- Create portfolio samples ---\n        samples_p = samples_a + samples_b\n        \n        # --- Calculate VaR for A, B, and Portfolio P ---\n        var_a = get_empirical_var(samples_a, alpha)\n        var_b = get_empirical_var(samples_b, alpha)\n        var_p = get_empirical_var(samples_p, alpha)\n        \n        # --- Check for subadditivity violation ---\n        is_violated = var_p  (var_a + var_b)\n        results.append(is_violated)\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2412240"}, {"introduction": "在认识到VaR的局限性后，风险管理领域引入了一个更为稳健的度量——预期亏损（Expected Shortfall, ES）。与仅仅关注损失阈值的VaR不同，ES衡量的是当损失超过VaR时，亏损的平均大小，从而能更好地捕捉尾部风险的严重性 ([@problem_id:2390682])。在本练习中，你将通过模拟具有“肥尾”特征的学生$t$分布的资产回报，亲手计算并比较VaR和ES，直观地感受在不同尾部风险情境下，ES如何为我们提供更全面的风险视图。", "problem": "编写一个完整、可运行的程序。对于一个由$M$个资产组成的固定等权重投资组合，其中各资产的收益率是独立同分布的，当每项资产的收益率服从具有不同自由度的学生t分布时，该程序需要估计并比较在置信水平$0.95$下的在险价值(VaR)和期望亏损(ES)。所有收益率都应解释为无量纲的小数形式收益率。\n\n设$R_{i}$表示在单一情景下资产$i$的收益率，其中$i \\in \\{1,\\dots,M\\}$。对于给定的自由度参数$\\nu$，假设$R_{i} = s(\\nu)\\,T_{i}$，其中$T_{i}$服从自由度为$\\nu$、单位尺度的学生t分布，而$s(\\nu)$是比例因子\n$$\ns(\\nu) \\equiv \\sqrt{\\frac{\\nu - 2}{\\nu}},\n$$\n该比例因子确保了当$\\nu  2$时$\\operatorname{Var}(R_{i}) = 1$。定义在某一情景下的等权重投资组合收益率为\n$$\nR_{p} \\equiv \\frac{1}{M}\\sum_{i=1}^{M} R_{i},\n$$\n相应的投资组合损失为\n$$\nL \\equiv -R_{p}.\n$$\n\n定义置信水平为$\\alpha \\in (0,1)$的在险价值(VaR)为\n$$\n\\operatorname{VaR}_{\\alpha}(L) \\equiv \\inf\\{x \\in \\mathbb{R} : \\mathbb{P}(L \\le x) \\ge \\alpha \\},\n$$\n以及期望亏损(ES)（也称为条件在险价值）为\n$$\n\\operatorname{ES}_{\\alpha}(L) \\equiv \\mathbb{E}\\!\\left[\\,L \\,\\middle|\\, L \\ge \\operatorname{VaR}_{\\alpha}(L)\\right].\n$$\n\n您的程序必须：\n- 对每个指定的$\\nu$，使用上述构造生成向量$(R_{1},\\dots,R_{M})$的$N$个独立情景，其中$T_{i}$在各资产$i$之间及各情景之间均独立，并计算每个情景下的相关投资组合损失$L$。\n- 使用模拟得到的$L$的经验分布来计算$\\operatorname{VaR}_{\\alpha}(L)$和$\\operatorname{ES}_{\\alpha}(L)$的经验估计量，其中经验$\\operatorname{VaR}_{\\alpha}(L)$是对应于指数$k \\equiv \\lceil \\alpha N \\rceil$的顺序统计量，而经验$\\operatorname{ES}_{\\alpha}(L)$是所有大于或等于该经验$\\operatorname{VaR}_{\\alpha}(L)$的模拟损失的样本均值。\n\n测试套件和使用的参数：\n- 资产数量：$M = 10$。\n- 置信水平：$\\alpha = 0.95$。\n- 每个测试的情景数量：$N = 100000$。\n- 随机数生成器种子必须固定为$123456$。\n- 待测试的自由度（每个都是一个独立的测试用例）：$\\nu \\in \\{2.2,\\,3.0,\\,5.0,\\,30.0,\\,100.0\\}$。\n\n您的程序应生成单行输出，其中包含所有测试用例的汇总结果，格式为 Python 列表字面量。对于每个测试用例，返回一个包含两个浮点数（小数形式，非百分比）的列表$[\\widehat{\\operatorname{VaR}}_{0.95},\\widehat{\\operatorname{ES}}_{0.95}]$。按照上面给出的$\\nu$值列表的顺序汇总 5 个测试用例。因此，最终输出格式必须是形如\n[[v_1,e_1],[v_2,e_2],[v_3,e_3],[v_4,e_4],[v_5,e_5]]\n的单行，其中每个$v_j$和$e_j$分别是对应$\\nu$的$\\operatorname{VaR}_{0.95}$和$\\operatorname{ES}_{0.95}$的经验估计值，以浮点数表示。", "solution": "任务是构建一个程序，用于估计一个等权重投资组合的在险价值($\\operatorname{VaR}$)和期望亏损($\\operatorname{ES}$)。构成投资组合的资产收益率被建模为服从缩放后学生t分布的独立同分布随机变量。该估计需要针对自由度参数$\\nu$的几个不同值进行。\n\n在进行求解之前，必须对问题陈述进行严格的验证。\n\n**问题验证**\n\n**第1步：提取已知条件**\n-   投资组合构成：等权重，包含 $M = 10$ 个资产。\n-   资产收益率：$R_i$（其中 $i \\in \\{1,\\dots,M\\}$）是独立同分布的(i.i.d.)。\n-   收益率分布模型：$R_i = s(\\nu) T_i$，其中 $T_i$ 是一个服从自由度为 $\\nu$、单位尺度的学生t分布的随机变量。\n-   比例因子：$s(\\nu) = \\sqrt{\\frac{\\nu - 2}{\\nu}}$，为 $\\nu  2$ 定义。这确保了 $\\operatorname{Var}(R_i) = 1$。\n-   投资组合收益率：$R_p = \\frac{1}{M}\\sum_{i=1}^{M} R_i$。\n-   投资组合损失：$L = -R_p$。\n-   在险价值定义：$\\operatorname{VaR}_{\\alpha}(L) = \\inf\\{x \\in \\mathbb{R} : \\mathbb{P}(L \\le x) \\ge \\alpha \\}$。\n-   期望亏损定义：$\\operatorname{ES}_{\\alpha}(L) = \\mathbb{E}[L \\mid L \\ge \\operatorname{VaR}_{\\alpha}(L)]$。\n-   模拟参数：情景数量 $N = 100000$；置信水平 $\\alpha = 0.95$；随机数生成器种子固定为 $123456$。\n-   测试用例：自由度 $\\nu \\in \\{2.2, 3.0, 5.0, 30.0, 100.0\\}$。\n-   经验估计量：\n    -   $\\widehat{\\operatorname{VaR}}_{\\alpha}(L)$ 是对应于指数 $k = \\lceil \\alpha N \\rceil$ 的顺序统计量。\n    -   $\\widehat{\\operatorname{ES}}_{\\alpha}(L)$ 是所有大于或等于经验 $\\operatorname{VaR}$ 的模拟损失的样本均值。\n-   输出格式：代表 Python 列表的列表的单行：`[[v_1,e_1],[v_2,e_2],...,[v_5,e_5]]`。\n\n**第2步：使用提取的已知条件进行验证**\n1.  **科学与事实的合理性**：该问题在科学上是合理的。使用学生t分布对重尾金融收益率进行建模是量化金融中的一种标准技术。$\\operatorname{VaR}$和$\\operatorname{ES}$的定义是教科书中的定义。比例因子$s(\\nu)$的公式正确，确保了当$\\nu  2$时资产收益率的单位方差，因为$\\operatorname{Var}(T_i) = \\frac{\\nu}{\\nu-2}$。从2.2开始的$\\nu$的测试用例都满足此条件。\n2.  **适定性**：问题是适定的。它提供了所有必要的参数（$M, \\alpha, N$，种子，$\\nu$的测试值），明确定义了模型，并指定了要使用的确切估计量。这确保了可以获得唯一的数值结果。\n3.  **客观性**：问题陈述使用精确、客观、形式化的数学语言表达，没有任何主观或模棱两可的说法。\n4.  **完整性与一致性**：问题是自洽且内部一致的。所有必需的定义和数据均已提供。不存在矛盾之处。\n5.  **可行性**：指定的计算（5个测试用例，每个用例包含$M=10$个资产的$N=100000$个情景）对于现代硬件和标准科学库是计算可行的。\n\n**结论与行动**\n问题陈述是**有效的**，因为它基于科学、适定、客观、完整且计算上可行。我们现在将继续推导并实现解决方案。\n\n**解决方案推导**\n\n问题的核心是执行蒙特卡洛模拟，以估计投资组合损失$L$的风险度量。$L$的分布继承自资产收益率$R_i$的属性。\n\n**1. 投资组合损失的属性**\n资产$i$的收益率$R_i$在$\\nu  1$时均值为$\\mathbb{E}[R_i] = 0$，在$\\nu  2$时方差为$\\operatorname{Var}(R_i) = 1$。投资组合收益率为$R_p = \\frac{1}{M}\\sum_{i=1}^{M} R_i$。由于资产收益率是独立同分布的，投资组合收益率的期望和方差为：\n$$\n\\mathbb{E}[R_p] = \\mathbb{E}\\left[\\frac{1}{M}\\sum_{i=1}^{M} R_i\\right] = \\frac{1}{M}\\sum_{i=1}^{M} \\mathbb{E}[R_i] = 0\n$$\n$$\n\\operatorname{Var}(R_p) = \\operatorname{Var}\\left(\\frac{1}{M}\\sum_{i=1}^{M} R_i\\right) = \\frac{1}{M^2}\\sum_{i=1}^{M} \\operatorname{Var}(R_i) = \\frac{M}{M^2} = \\frac{1}{M}\n$$\n投资组合损失定义为$L = -R_p$。因此，其统计属性为$\\mathbb{E}[L] = 0$和$\\operatorname{Var}(L) = \\frac{1}{M}$。对于本问题，$M=10$，因此$\\operatorname{Var}(L) = 0.1$。$L$的分布是缩放后的t分布变量之和，没有简单的封闭形式，这使得必须使用模拟方法。\n\n**2. 蒙特卡洛模拟算法**\n对于$\\nu \\in \\{2.2, 3.0, 5.0, 30.0, 100.0\\}$中的每个给定值，执行以下步骤：\n\na. **随机变量生成**：生成一个$N \\times M$的矩阵$\\mathbf{T}$，其中$N = 100000$，$M=10$。每个元素$T_{ki}$（代表情景$k$和资产$i$）都是从自由度为$\\nu$的标准学生t分布中抽取的独立样本。固定的种子$123456$确保了可复现性。\n\nb. **收益率计算**：计算比例因子$s(\\nu) = \\sqrt{(\\nu - 2)/\\nu}$。然后，通过逐元素相乘构造资产收益率矩阵$\\mathbf{R}$：$\\mathbf{R} = s(\\nu) \\mathbf{T}$。\n\nc. **投资组合损失计算**：对每个情景$k=1, \\dots, N$，计算投资组合收益率$R_{p,k} = \\frac{1}{M}\\sum_{i=1}^{M} R_{ki}$。这可以通过计算$\\mathbf{R}$矩阵每行的平均值来实现。相应的投资组合损失由向量$\\mathbf{L}$给出，其中$L_k = -R_{p,k}$。\n\n**3. VaR和ES的经验估计**\n使用生成的包含$N$个投资组合损失样本的向量$\\mathbf{L}$：\n\na. **VaR估计**：将向量$\\mathbf{L}$按非递减顺序排序，得到顺序统计量$L_{(1)} \\le L_{(2)} \\le \\dots \\le L_{(N)}$。置信水平为$\\alpha = 0.95$的经验$\\operatorname{VaR}$是第$k$个顺序统计量，其中指数$k$由下式给出：\n$$\nk = \\lceil \\alpha N \\rceil = \\lceil 0.95 \\times 100000 \\rceil = 95000\n$$\n在以零为起始索引的数组中，这对应于索引为$k-1 = 94999$的元素。因此，$\\widehat{\\operatorname{VaR}}_{0.95} = L_{(95000)}$。\n\nb. **ES估计**：经验$\\operatorname{ES}$定义为所有大于或等于估计$\\operatorname{VaR}$的模拟损失的样本均值。\n$$\n\\widehat{\\operatorname{ES}}_{0.95} = \\frac{\\sum_{k=1}^{N} L_k \\cdot \\mathbf{1}_{\\{L_k \\ge \\widehat{\\operatorname{VaR}}_{0.95}\\}}}{\\sum_{k=1}^{N} \\mathbf{1}_{\\{L_k \\ge \\widehat{\\operatorname{VaR}}_{0.95}\\}}}\n$$\n其中$\\mathbf{1}_{\\{\\cdot\\}}$是指示函数。这通过筛选原始损失向量$\\mathbf{L}$中所有满足条件的值，然后计算它们的算术平均值来实现。\n\n随着$\\nu \\to \\infty$，学生t分布收敛于标准正态分布。因此，对于较大的$\\nu$，我们预计结果将趋近于高斯投资组合损失$L \\sim \\mathcal{N}(0, 1/M)$的理论值。当$M=10$和$\\alpha=0.95$时，理论值为$\\operatorname{VaR}_{0.95} = \\frac{1}{\\sqrt{10}} \\Phi^{-1}(0.95) \\approx 0.5202$和$\\operatorname{ES}_{0.95} = \\frac{1}{\\sqrt{10}} \\frac{\\phi(\\Phi^{-1}(0.95))}{1-0.95} \\approx 0.6521$，其中$\\Phi$和$\\phi$分别是标准正态分布的累积分布函数(CDF)和概率密度函数(PDF)。对于较小的$\\nu$，t分布的肥尾应该会导致$\\operatorname{VaR}$和$\\operatorname{ES}$的值都更高。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import t\n\ndef solve():\n    \"\"\"\n    Estimates and compares Value at Risk (VaR) and Expected Shortfall (ES)\n    for an equally weighted portfolio with asset returns following a scaled\n    Student's t-distribution with varying degrees of freedom.\n    \"\"\"\n    \n    # Define the test cases and parameters from the problem statement.\n    M = 10  # Number of assets\n    alpha = 0.95  # Confidence level\n    N = 100000  # Number of scenarios\n    seed = 123456  # Random number generator seed\n    \n    test_cases = [\n        2.2,\n        3.0,\n        5.0,\n        30.0,\n        100.0,\n    ]\n\n    # Initialize a random number generator with the specified seed for reproducibility.\n    rng = np.random.default_rng(seed)\n\n    results = []\n    \n    for nu in test_cases:\n        # Main logic to calculate the result for one case goes here.\n\n        # 1. Generate N x M matrix of random variates from Student's t-distribution.\n        # The random_state parameter is passed the generator instance to ensure it is used.\n        T_matrix = t.rvs(df=nu, size=(N, M), random_state=rng)\n\n        # 2. Calculate the scaling factor s(nu) to ensure Var(R_i) = 1.\n        # This is valid for nu  2, which holds for all test cases.\n        s_nu = np.sqrt((nu - 2) / nu)\n        \n        # 3. Scale the random variates to get the asset returns matrix R.\n        R_matrix = s_nu * T_matrix\n\n        # 4. Compute the equally weighted portfolio return for each scenario.\n        # This is the mean of each row (axis=1).\n        R_p_vector = np.mean(R_matrix, axis=1)\n\n        # 5. Compute the portfolio loss L = -R_p.\n        L_vector = -R_p_vector\n\n        # 6. Estimate VaR at confidence level alpha.\n        # First, sort the losses in ascending order.\n        L_sorted = np.sort(L_vector)\n        \n        # The index for VaR is k = ceil(alpha*N).\n        # In 0-based Python indexing, this corresponds to index k-1.\n        k_index = int(np.ceil(alpha * N)) - 1\n        var_estimate = L_sorted[k_index]\n\n        # 7. Estimate ES at confidence level alpha.\n        # ES is the sample average of all losses greater than or equal to the empirical VaR.\n        # This is implemented by boolean indexing on the original loss vector.\n        es_estimate = np.mean(L_vector[L_vector = var_estimate])\n        \n        # Append the [VaR, ES] pair for the current test case.\n        results.append([var_estimate, es_estimate])\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a list of lists, e.g., [[v1, e1], [v2, e2]].\n    # The str() function on a list provides the correct formatting for each inner list.\n    # The ','.join() method combines these strings with a comma separator.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2390682"}, {"introduction": "拥有一个能够预测风险（如VaR）的模型后，我们如何检验其准确性？答案是回测（Backtesting）。这个练习将带你超越简单地计算VaR被突破的频率，引入更高级的、基于损失函数的回测方法 ([@problem_id:2446219])。你将学习并应用分位数损失函数（quantile loss function），它不仅惩罚错误的频率，还惩罚错误的大小，这让你能以更精细和经济直观的方式评估风险模型的表现，是成为一名合格的量化风险分析师的关键一步。", "problem": "你的任务是实现一个自包含的风险价值 (VaR) 回测框架，该框架通过一个损失函数，对 VaR 突破的频率和幅度进行惩罚来评估预测。请从以下基本定义和事实开始。\n\n对于一个损失随机变量 $L$，在水平 $\\alpha \\in (0,1)$ 下的单步 VaR 预测是任意满足在预测分布下超过 $v$ 的概率接近 $\\alpha$ 的数字 $v$，即 $P(L \\le v) \\approx 1 - \\alpha$。等价地，以收益 $R$ 表示，并遵循惯例 $L = -R$，VaR 预测 $v$ 是对 $L$ 的 $\\alpha$-分位数的预测。回测是根据已实现损失序列 $\\{L_t\\}_{t=1}^T$ 来评估一系列此类预测 $\\{v_t\\}_{t=1}^T$。\n\n为了同时捕捉突破的频率和幅度，使用与水平 $\\alpha$ 相关的分位数（检验）损失，其对于预测误差 $u \\in \\mathbb{R}$ 的定义为\n$$\n\\ell_{\\alpha}(u) = \\left(\\alpha - \\mathbf{1}\\{u  0\\}\\right) u,\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。对于 VaR 回测，相关误差为 $u_t = L_t - v_t$；当 $u_t  0$ 时，发生一次突破。\n\n为给定的收益序列 $\\{R_t\\}_{t=1}^T$、VaR 预测序列 $\\{v_t\\}_{t=1}^T$ 和水平 $\\alpha$，实现以下回测指标：\n1. 经验覆盖偏差，定义为\n$$\n\\widehat{c} - \\alpha, \\quad \\text{where} \\quad \\widehat{c} = \\frac{1}{T} \\sum_{t=1}^T \\mathbf{1}\\{L_t  v_t\\} = \\frac{1}{T} \\sum_{t=1}^T \\mathbf{1}\\{-R_t  v_t\\}.\n$$\n2. 平均分位数损失，\n$$\n\\overline{L}_{\\alpha} = \\frac{1}{T} \\sum_{t=1}^T \\ell_{\\alpha}(L_t - v_t) = \\frac{1}{T} \\sum_{t=1}^T \\ell_{\\alpha}(-R_t - v_t).\n$$\n\n你的程序必须为下方的每个测试案例计算一个双元素列表 $[\\widehat{c} - \\alpha, \\overline{L}_{\\alpha}]$，其中两个条目都需四舍五入到六位小数。所有数值输入和输出都必须是十进制形式（不要使用百分号）。不涉及任何物理单位。\n\n待实现的测试套件：\n- 案例 A（混合结果）：\n  - $\\alpha = 0.05$\n  - 收益 $\\{R_t\\}_{t=1}^{10} = [\\,-0.01,\\, 0.002,\\, -0.03,\\, -0.015,\\, 0.005,\\, -0.04,\\, 0.01,\\, -0.025,\\, 0.003,\\, -0.012\\,]$\n  - VaR 预测 $\\{v_t\\}_{t=1}^{10} = [\\,0.015,\\, 0.01,\\, 0.02,\\, 0.015,\\, 0.008,\\, 0.025,\\, 0.009,\\, 0.02,\\, 0.007,\\, 0.012\\,]$\n- 案例 B（无突破；保守的 VaR）：\n  - $\\alpha = 0.05$\n  - 收益 $\\{R_t\\}_{t=1}^{5} = [\\,-0.005,\\, 0.004,\\, 0.002,\\, -0.003,\\, 0.001\\,]$\n  - VaR 预测 $\\{v_t\\}_{t=1}^{5} = [\\,0.02,\\, 0.02,\\, 0.02,\\, 0.02,\\, 0.02\\,]$\n- 案例 C（全部突破；激进的 VaR）：\n  - $\\alpha = 0.05$\n  - 收益 $\\{R_t\\}_{t=1}^{3} = [\\,-0.05,\\, -0.06,\\, -0.04\\,]$\n  - VaR 预测 $\\{v_t\\}_{t=1}^{3} = [\\,0.01,\\, 0.005,\\, 0.02\\,]$\n- 案例 D（单次大幅度突破）：\n  - $\\alpha = 0.05$\n  - 收益 $\\{R_t\\}_{t=1}^{5} = [\\,-0.001,\\, -0.002,\\, -0.15,\\, -0.003,\\, 0.0\\,]$\n  - VaR 预测 $\\{v_t\\}_{t=1}^{5} = [\\,0.005,\\, 0.005,\\, 0.01,\\, 0.005,\\, 0.005\\,]$\n\n最终输出格式要求：\n你的程序应产生一行输出，包含一个以方括号括起来的逗号分隔列表，其中每个元素本身是对应一个测试案例的双元素列表 $[\\widehat{c} - \\alpha, \\overline{L}_{\\alpha}]$，例如 $[[x_1,y_1],[x_2,y_2],\\ldots]$。每个浮点数必须四舍五入到六位小数。", "solution": "该问题要求为风险价值 (VaR) 预测实现一个回测框架。在提出严谨的解决方案之前，我将首先确立问题陈述的有效性。\n\n对该问题进行验证。\n\n**步骤 1：提取已知条件**\n- 损失 $L$ 与收益 $R$ 之间的关系是 $L_t = -R_t$。\n- VaR 水平由 $\\alpha \\in (0,1)$ 表示。\n- 分位数损失函数定义为 $\\ell_{\\alpha}(u) = (\\alpha - \\mathbf{1}\\{u  0\\}) u$，其中 $u$ 是预测误差。\n- 预测误差为 $u_t = L_t - v_t$。突破定义为 $L_t  v_t$，这等价于 $u_t  0$。\n- 第一个要求的指标是经验覆盖偏差：$\\widehat{c} - \\alpha$，其中 $\\widehat{c} = \\frac{1}{T} \\sum_{t=1}^T \\mathbf{1}\\{L_t  v_t\\}$。\n- 第二个要求的指标是平均分位数损失：$\\overline{L}_{\\alpha} = \\frac{1}{T} \\sum_{t=1}^T \\ell_{\\alpha}(L_t - v_t)$。\n- 提供的测试套件包含四个案例（A、B、C、D），每个案例都有指定的收益 $\\{R_t\\}$、VaR 预测 $\\{v_t\\}$ 的时间序列以及给定的水平 $\\alpha$。\n- 每个测试案例的最终输出必须是一个列表 $[\\widehat{c} - \\alpha, \\overline{L}_{\\alpha}]$，其中每个值都四舍五入到六位小数。\n\n**步骤 2：使用提取的已知条件进行验证**\n根据验证标准对问题进行评估。\n- **科学基础：** 该问题基于量化金融和计量经济学中已建立的标准概念。风险价值、分位数损失函数和回测是金融风险管理的基本工具。所提供的定义和公式是正确的，并与学术文献一致。该问题在科学上是合理的。\n- **适定性与完整性：** 该问题是适定的。计算解决方案所需的所有必要数据（时间序列、参数）、定义和数学公式都已明确提供。没有缺失或矛盾的元素。任务是基于这些输入进行直接计算，这会为每个案例带来唯一的解决方案。\n- **客观性：** 问题陈述以精确、客观和技术性的语言呈现，没有任何主观性主张或模糊之处。\n\n**步骤 3：结论与行动**\n该问题被判定为有效。这是在计算金融领域中一个定义明确的计算任务，它具有科学基础且陈述客观。现在将逐步制定解决方案。\n\n**基于原则的解决方案**\n\n目标是针对一系列已实现收益 $\\{R_t\\}_{t=1}^T$ 和一个水平 $\\alpha$，为一系列风险价值预测 $\\{v_t\\}_{t=1}^T$ 计算两个回测指标。\n\n首先，我们将长度为 $T$ 的给定时间序列的输入形式化：\n- 收益序列：$\\{R_t\\}_{t=1}^T$。\n- VaR 预测序列：$\\{v_t\\}_{t=1}^T$。\n- VaR 水平：$\\alpha$。\n\n从这些输入中，我们推导出必要中间量。时间 $t$ 的损失定义为收益的负值，$L_t = -R_t$。预测误差是实际损失与预测损失之间的差值，$u_t = L_t - v_t$。\n\n然后按如下方式计算两个指标：\n\n**1. 经验覆盖偏差 $(\\widehat{c} - \\alpha)$**\n该指标评估 VaR 突破的频率是否与目标频率 $\\alpha$ 一致。一个理想的 VaR 模型应以 $\\alpha$ 的概率产生突破。\n- 经验覆盖率 $\\widehat{c}$ 是样本中观测到的突破频率。当实际损失 $L_t$ 大于 VaR 预测 $v_t$ 时，发生一次突破。\n- 我们将时间 $t$ 发生突破的指示变量定义为 $I_t = \\mathbf{1}\\{L_t  v_t\\}$。如果发生突破，该变量为 $1$，否则为 $0$。\n- 经验覆盖率是样本期间这些指示变量的平均值：\n$$\n\\widehat{c} = \\frac{1}{T} \\sum_{t=1}^T I_t = \\frac{1}{T} \\sum_{t=1}^T \\mathbf{1}\\{L_t  v_t\\}\n$$\n- 最终指标是此经验比率与理论比率 $\\alpha$ 的偏差：\n$$\n\\text{覆盖偏差} = \\widehat{c} - \\alpha\n$$\n接近 $0$ 的值表示模型的突破频率与 VaR 水平一致。正值意味着突破过多（模型过于激进），而负值意味着突破过少（模型过于保守）。\n\n**2. 平均分位数损失 $(\\overline{L}_{\\alpha})$**\n此指标通过惩罚突破的发生及其幅度，同时也惩罚过于保守的预测，提供了一种更细致的评估。它是样本上分位数损失函数 $\\ell_{\\alpha}(u)$ 的平均值。\n- 分位数损失函数由 $\\ell_{\\alpha}(u) = (\\alpha - \\mathbf{1}\\{u  0\\}) u$ 给出。误差项为 $u_t = L_t - v_t$。\n- 我们可以分两种情况分析损失函数：\n    - **突破 ($L_t  v_t \\implies u_t  0$)：** 此时，$\\mathbf{1}\\{u_t  0\\} = 0$。损失为 $\\ell_{\\alpha}(u_t) = \\alpha \\cdot u_t$。惩罚与亏损幅度 $u_t$ 成正比，并按小概率 $\\alpha$ 进行缩放。\n    - **无突破 ($L_t \\le v_t \\implies u_t \\le 0$)：** 此时，$\\mathbf{1}\\{u_t  0\\} = 1$（对于 $u_t0$）或 $0$（对于 $u_t=0$）。如果 $u_t  0$，损失为 $\\ell_{\\alpha}(u_t) = (\\alpha - 1) u_t = (1-\\alpha)(-u_t)$。这会惩罚那些 VaR 估计远大于损失的过于保守的预测。惩罚与「过度预测」的幅度 $|u_t|$ 成正比，并按大概率 $(1-\\alpha)$ 进行缩放。如果 $u_t = 0$，损失为 $0$。\n- 平均分位数损失是样本期间这些个别损失的平均值：\n$$\n\\overline{L}_{\\alpha} = \\frac{1}{T} \\sum_{t=1}^T \\ell_{\\alpha}(L_t - v_t)\n$$\n一个能正确指定损失分布条件分位数的模型，在理论上将使此预期损失最小化。因此，较低的 $\\overline{L}_{\\alpha}$ 值更优。\n\n每个测试案例的计算过程包括将给定的收益列表和 VaR 预测列表转换为数值数组，应用上述公式计算两个指标，并将结果四舍五入到指定精度。此过程将在提供的 Python 代码中实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the VaR backtesting problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A (mixed outcomes)\n        {\n            \"alpha\": 0.05,\n            \"returns\": [-0.01, 0.002, -0.03, -0.015, 0.005, -0.04, 0.01, -0.025, 0.003, -0.012],\n            \"var_forecasts\": [0.015, 0.01, 0.02, 0.015, 0.008, 0.025, 0.009, 0.02, 0.007, 0.012]\n        },\n        # Case B (no exceedances)\n        {\n            \"alpha\": 0.05,\n            \"returns\": [-0.005, 0.004, 0.002, -0.003, 0.001],\n            \"var_forecasts\": [0.02, 0.02, 0.02, 0.02, 0.02]\n        },\n        # Case C (all exceedances)\n        {\n            \"alpha\": 0.05,\n            \"returns\": [-0.05, -0.06, -0.04],\n            \"var_forecasts\": [0.01, 0.005, 0.02]\n        },\n        # Case D (a single large exceedance)\n        {\n            \"alpha\": 0.05,\n            \"returns\": [-0.001, -0.002, -0.15, -0.003, 0.0],\n            \"var_forecasts\": [0.005, 0.005, 0.01, 0.005, 0.005]\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        alpha = case[\"alpha\"]\n        # Convert inputs to NumPy arrays for vectorized operations\n        R_t = np.array(case[\"returns\"])\n        v_t = np.array(case[\"var_forecasts\"])\n        \n        # Ensure T is correctly inferred from the data length\n        T = len(R_t)\n\n        # Calculate the loss series L_t = -R_t\n        L_t = -R_t\n\n        # 1. Calculate Empirical Coverage Deviation\n        # An exceedance occurs if L_t  v_t\n        exceedances = L_t  v_t\n        c_hat = np.mean(exceedances)\n        coverage_deviation = c_hat - alpha\n\n        # 2. Calculate Average Quantile Loss\n        # Forecast error u_t = L_t - v_t\n        u_t = L_t - v_t\n        \n        # Indicator function: 1 if u_t  0, else 0\n        indicator_u_neg = (u_t  0).astype(float)\n        \n        # Quantile loss for each time step: l_alpha(u_t) = (alpha - I{u_t  0}) * u_t\n        quantile_losses = (alpha - indicator_u_neg) * u_t\n        \n        # Average quantile loss\n        L_bar_alpha = np.mean(quantile_losses)\n\n        # Round results to 6 decimal places\n        result_pair = [\n            round(coverage_deviation, 6),\n            round(L_bar_alpha, 6)\n        ]\n        all_results.append(result_pair)\n\n    # Format the final output string as per problem specification\n    # str() on a list gives the desired '[...]' format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2446219"}]}