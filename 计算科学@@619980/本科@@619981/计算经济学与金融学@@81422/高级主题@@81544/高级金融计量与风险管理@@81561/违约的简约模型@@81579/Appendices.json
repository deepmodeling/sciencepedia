{"hands_on_practices": [{"introduction": "为了真正掌握简约式模型，我们必须从其基本构件开始。第一个练习通过模拟来直观地展示恒定违约强度 $\\lambda$ 这一基本概念，其中违约被视为泊松过程的第一个事件。通过亲手生成违约时间，你将对这个简单而强大的模型如何随时间演变获得具体而深刻的理解。[@problem_id:2425480]", "problem": "要求您实现一个程序，在恒定违约强度的简约式（基于强度）模型中模拟独立公司的违约时间。在此框架中，单个公司的违约时间是一个具有恒定强度参数 $ \\lambda $ 的随机时间，且各公司之间的违约是相互独立的。所有时间量均以年为单位。\n\n您的程序必须针对每个指定的测试用例，在恒定强度 $ \\lambda $ 下生成 $ N $ 个独立的违约时间，在有限时间域 $ [0, T] $ 内观测该过程（在 $ T $ 之后发生的违约不予计算），将时间域划分为宽度为 $ w $ 年的等宽时间区间，并统计落入每个时间区间的违约次数。如果 $ \\lambda = 0 $，则解释为在任何有限时间域内均不发生违约。如果 $ N = 0 $，则解释为没有需要模拟的公司。时间区间必须将 $ [0, T] $ 精确地划分为 $ B $ 个宽度为 $ w $ 的相等子区间，其中 $ B = T / w $ 为整数。请使用提供的随机种子以确保可复现性。\n\n对于每个测试用例，要求的输出是每个区间的整数计数值列表，从最早的时间区间到最晚的时间区间排列，其中每个区间对应于半开区间 $ [t_k, t_{k+1}) $（对于 $ k = 0, 1, \\dots, B - 2 $），而最后一个区间包含右端点 $ T $，即 $ [t_{B-1}, T] $，其中 $ t_k = k w $。\n\n测试套件：\n- 情况1（一般情况）：$ N = 1000 $，$ \\lambda = 0.05 $ 每年，$ T = 80 $ 年，$ w = 5 $ 年，随机种子 $ s = 1729 $。\n- 情况2（零强度边缘情况）：$ N = 1000 $，$ \\lambda = 0 $，$ T = 20 $ 年，$ w = 5 $ 年，随机种子 $ s = 7 $。\n- 情况3（高强度，短时间域）：$ N = 1000 $，$ \\lambda = 2.0 $ 每年，$ T = 3.0 $ 年，$ w = 0.5 $ 年，随机种子 $ s = 2024 $。\n- 情况4（零公司边缘情况）：$ N = 0 $，$ \\lambda = 0.1 $ 每年，$ T = 10 $ 年，$ w = 1 $ 年，随机种子 $ s = 99 $。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个用方括号括起来的列表的列表，以逗号分隔，其中不含任何空格。例如，如果有两个测试用例，可接受的格式为：[[1,2,3],[0,0,1]]。在此问题中，您必须输出四个列表（每个测试用例一个），并将其聚合到单行上的一个顶级列表中，无任何附加文本。\n\n所有时间均以年为单位，所有输出均为每个区间的无量纲整数计数值。本任务不涉及角度。最终输出必须严格遵循指定的单行格式。", "solution": "在尝试任何解决方案之前，问题陈述将首先经过严格的验证过程。\n\n### 问题验证\n\n**步骤1：提取给定信息**\n\n提供的明确数据、变量和条件如下：\n- **模型**：针对独立公司的简约式（基于强度）模型。\n- **违约强度**：恒定参数，记为 $\\lambda$。\n- **违约时间**：一个随机变量 $\\tau$，由强度 $\\lambda$ 控制。如果 $\\lambda=0$，则不发生违约。\n- **公司数量**：$N$。如果 $N=0$，则不模拟任何公司。\n- **观测时间域**：有限区间 $[0, T]$。在时间 $T$ 之后发生的违约将被舍弃。\n- **时间区间**：时间域 $[0, T]$ 被划分为 $B$ 个宽度为 $w$ 的等宽区间。\n- **区间划分**：$B = T/w$ 是一个整数。区间为 $[t_k, t_{k+1})$（对于 $k = 0, 1, \\dots, B-2$），最后一个区间为 $[t_{B-1}, T]$，其中 $t_k = kw$。\n- **随机性**：为每个测试用例提供了一个随机种子 $s$，以确保可复现性。\n- **输出**：对于每个测试用例，输出一个每个区间违约次数的整数计数值列表。\n\n**测试套件：**\n- **情况1**：$N = 1000$，$\\lambda = 0.05$ 年$^{-1}$，$T = 80$ 年，$w = 5$ 年，$s = 1729$。\n- **情况2**：$N = 1000$，$\\lambda = 0$ 年$^{-1}$，$T = 20$ 年，$w = 5$ 年，$s = 7$。\n- **情况3**：$N = 1000$，$\\lambda = 2.0$ 年$^{-1}$，$T = 3.0$ 年，$w = 0.5$ 年，$s = 2024$。\n- **情况4**：$N = 0$，$\\lambda = 0.1$ 年$^{-1}$，$T = 10$ 年，$w = 1$ 年，$s = 99$。\n\n**步骤2：使用提取的给定信息进行验证**\n\n根据验证标准对问题进行评估：\n\n1.  **科学基础**：该问题描述了使用基于强度的模型来模拟违约时间。这等同于将违约建模为具有恒定强度 $\\lambda$ 的泊松过程的首次到达时间。发生此类事件的时间是一个众所周知的随机变量，服从指数分布。该框架是量化金融和信用风险建模的基石。其前提在科学和数学上是合理的。\n\n2.  **适定性**：问题清晰明确。每种情况的所有参数（$N$、$\\lambda$、$T$、$w$、$s$）都已指定。模拟违约时间并将其在离散时间区间中进行计数的任务定义清晰。使用随机种子确保了该模拟虽然原则上是随机的，但会产生一个唯一的、确定性的输出。该问题是适定的。\n\n3.  **客观性**：语言是正式和量化的。没有主观的、基于观点的或模糊的陈述。\n\n**步骤3：结论与行动**\n\n此问题是**有效的**。这是一个标准的、定义明确的模拟任务，基于概率论的基本原理及其在计算金融中的应用。将提供一个解决方案。\n\n### 解决方案推导\n\n该问题要求模拟 $N$ 家独立公司的违约时间。每家公司的违约由一个恒定强度 $\\lambda$ 控制。这是一个经典的泊松过程模型。\n\n**理论基础**\n\n在恒定速率为 $\\lambda$ 的泊松过程中，第一次事件（违约）发生的时间是一个服从指数分布的随机变量 $\\tau$。一家公司到时间 $t$ 尚未违约的概率，即生存概率，由以下公式给出：\n$$\nS(t) = P(\\tau > t) = e^{-\\lambda t}\n$$\n因此，违约时间 $\\tau$ 的累积分布函数（CDF），即在时间 $t$ 或之前发生违约的概率，为：\n$$\nF(t) = P(\\tau \\le t) = 1 - S(t) = 1 - e^{-\\lambda t}\n$$\n\n**模拟方法**\n\n为了从给定分布生成随机变量，逆变换采样法是一种标准且稳健的技术。设 $U$ 是从区间 $(0, 1)$ 上的标准均匀分布中抽取的随机变量，即 $U \\sim \\text{Uniform}(0, 1)$。我们可以通过设置 $F(\\tau) = U$ 并求解 $\\tau$ 来从指数分布中生成样本 $\\tau$：\n$$\nU = 1 - e^{-\\lambda \\tau}\n$$\n$$\n1 - U = e^{-\\lambda \\tau}\n$$\n$$\n\\ln(1 - U) = -\\lambda \\tau\n$$\n$$\n\\tau = -\\frac{1}{\\lambda} \\ln(1 - U)\n$$\n由于 $1 - U$ 也服从 $\\text{Uniform}(0, 1)$ 分布，我们可以将表达式简化为：\n$$\n\\tau = -\\frac{1}{\\lambda} \\ln(U)\n$$\n此公式用于为 $N$ 家公司中的每一家生成违约时间。\n\n**算法实现**\n\n对于由参数 $(N, \\lambda, T, w, s)$ 指定的每个测试用例，执行以下算法：\n\n1.  **初始化**：使用给定的种子 $s$ 初始化伪随机数生成器，以确保结果是可复现的。\n\n2.  **边缘情况处理**：\n    *   如果公司数量 $N = 0$，则没有需要模拟的违约。\n    *   如果违约强度 $\\lambda = 0$，则任何公司的违约时间 $\\tau = \\infty$。在这两种情况下，有限时间域 $[0, T]$ 内都不会观察到违约。\n    *   区间数量为 $B = T/w$。这些情况的输出是一个包含 $B$ 个零的列表。\n\n3.  **一般情况模拟**（$N > 0$ 且 $\\lambda > 0$）：\n    a.  **生成随机变量**：从分布 $\\text{Uniform}(0, 1)$ 中抽取一个包含 $N$ 个独立随机数的向量 $\\{U_i\\}_{i=1}^N$。\n    b.  **生成违约时间**：使用逆变换公式 $\\tau_i = -\\frac{1}{\\lambda} \\ln(U_i)$ 将此向量转换为一个违约时间向量 $\\{\\tau_i\\}_{i=1}^N$。为提高计算效率，此操作以向量化方式进行。\n    c.  **应用时间域约束**：问题规定只计算时间域 $[0, T]$ 内的违约。因此，对模拟出的违约时间进行筛选，只保留满足 $\\tau_i \\le T$ 的时间。\n    d.  **分箱**：将观测区间 $[0, T]$ 分为 $B = T/w$ 个区间。区间边界由序列 $\\{0, w, 2w, \\dots, (B-1)w, T\\}$ 定义。通过统计落入每个区间的已筛选违约时间的数量来构建一个直方图。问题规定第 $k$ 个区间是半开区间 $[kw, (k+1)w)$（对于 $k \\in \\{0, \\dots, B-2\\}$），最后一个区间是闭区间 $[(B-1)w, T]$。标准的数值库提供了能正确实现此逻辑的直方图函数。例如，Python 中的 `numpy.histogram` 函数及其默认设置精确匹配此要求。\n    e.  **输出**：每个区间的计数值数组构成了该测试用例的最终答案。\n\n此过程被系统地应用于所提供的四个测试用例中的每一个。最终输出是将每个用例的结果聚合成一个单一格式化字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates default times in a reduced-form model and provides bin counts.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general case)\n        {'N': 1000, 'lambda': 0.05, 'T': 80.0, 'w': 5.0, 'seed': 1729},\n        # Case 2 (zero intensity edge case)\n        {'N': 1000, 'lambda': 0.0, 'T': 20.0, 'w': 5.0, 'seed': 7},\n        # Case 3 (high intensity, short horizon)\n        {'N': 1000, 'lambda': 2.0, 'T': 3.0, 'w': 0.5, 'seed': 2024},\n        # Case 4 (zero firms edge case)\n        {'N': 0, 'lambda': 0.1, 'T': 10.0, 'w': 1.0, 'seed': 99},\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case['N']\n        lam = case['lambda']\n        T = case['T']\n        w = case['w']\n        seed = case['seed']\n\n        # The number of bins, B, is guaranteed to be an integer.\n        num_bins = int(T / w)\n\n        # Handle edge cases where N=0 or lambda=0.\n        # If N=0, there are no firms to default.\n        # If lambda=0, the intensity is zero, so the default time is infinite.\n        # In both scenarios, no defaults occur in any finite horizon.\n        if N == 0 or lam == 0:\n            counts = [0] * num_bins\n            results.append(counts)\n            continue\n\n        # Initialize the random number generator for reproducibility.\n        rng = np.random.default_rng(seed)\n\n        # Generate N uniform random variables from (0, 1).\n        # We use rng.random which is exclusive of 1.0, but log(0) is still an issue\n        # if the sample is exactly 0. In practice, this is exceedingly rare.\n        # np.random.uniform is on [low, high), so we can use it on (0,1)\n        # However, np.random.random() is sufficient and standard.\n        uniform_samples = rng.random(size=N)\n\n        # Apply the inverse transform sampling method to get exponentially distributed default times.\n        # tau = - (1/lambda) * ln(U)\n        default_times = -np.log(uniform_samples) / lam\n\n        # Filter out defaults that occur after the time horizon T.\n        defaults_in_horizon = default_times[default_times <= T]\n\n        # Define the bin edges for the histogram.\n        # np.linspace(0, T, num_bins + 1) creates edges [0, w, 2w, ..., T].\n        bin_edges = np.linspace(0.0, T, num_bins + 1)\n\n        # Use numpy.histogram to count defaults in each bin.\n        # By default, np.histogram uses bins as [edge, next_edge) for all but the\n        # last bin, which is [last_edge_-1, last_edge]. This matches the problem spec exactly.\n        # The problem states: \"[t_k, t_{k+1})\" for k=0..B-2, and \"[t_{B-1}, T]\" for the last bin.\n        counts_np, _ = np.histogram(defaults_in_horizon, bins=bin_edges)\n\n        # Convert the numpy array of counts to a list of standard Python integers.\n        counts = counts_np.tolist()\n        \n        results.append(counts)\n\n    # The required output format is a single line with no spaces.\n    # repr() creates a string representation, e.g., \"[[1, 2], [3, 4]]\".\n    # .replace(' ', '') removes all spaces to match the required format \"[[1,2],[3,4]]\".\n    final_output = repr(results).replace(' ', '')\n    print(final_output)\n\nsolve()\n```", "id": "2425480"}, {"introduction": "虽然恒定的违约强度是一个有用的起点，但在现实世界中，违约风险会随着具体特征而变化。本练习将带你从抽象理论走向实证应用，将违约强度建模为借款人协变量（如FICO分数和收入）的函数。你将学习如何从一个包含违约和未违约贷款（右删失数据）的数据集中估计模型参数，这是现代信用风险分析中的一项核心技能。[@problem_id:2425483]", "problem": "考虑一个用于无担保P2P个人消费贷款的基于强度的简约式违约模型。设违约时间为一个非负随机变量，在观测窗口内具有条件恒定的违约强度，记为 $\\lambda(\\mathbf{x})$，其中 $\\mathbf{x}$ 表示借款人协变量。违约强度由转换后协变量的对数线性函数指定：\n$$\n\\lambda(\\mathbf{x}) \\equiv \\exp\\!\\left(\\theta_0 + \\theta_1\\,g_1(\\text{FICO}) + \\theta_2\\,g_2(\\text{INC})\\right),\n$$\n其中 $g_1(\\text{FICO}) = \\dfrac{\\text{FICO} - 700}{100}$ 且 $g_2(\\text{INC}) = \\ln\\!\\left(\\dfrac{\\text{INC}}{50000}\\right)$。此处使用自然对数。时间单位为年，收入以美元/年为单位。\n\n假设观测到6笔独立的贷款，每笔贷款都有协变量、以年为单位的观测时间以及一个右删失指标。对于第 $i$ 笔贷款，观测时间为 $t_i \\ge 0$，事件指标为 $d_i \\in \\{0,1\\}$，其中 $d_i=1$ 表示在时间 $t_i$ 发生违约，$d_i=0$ 表示在时间 $t_i$ 发生右删失。观测到的数据集如下：\n- 贷款 A：FICO $650$，收入 $30000$，观测时间 $0.5$，违约指标 $1$。\n- 贷款 B：FICO $720$，收入 $60000$，观测时间 $1.0$，违约指标 $0$。\n- 贷款 C：FICO $680$，收入 $45000$，观测时间 $0.8$，违约指标 $1$。\n- 贷款 D：FICO $760$，收入 $120000$，观测时间 $1.2$，违约指标 $0$。\n- 贷款 E：FICO $700$，收入 $50000$，观测时间 $1.5$，违约指标 $0$。\n- 贷款 F：FICO $600$，收入 $25000$，观测时间 $0.3$，违约指标 $1$。\n\n在上述模型下，假设给定 $\\mathbf{x}$ 时违约时间服从条件指数分布，并且各贷款之间相互独立，请通过最大化模型和观测数据所蕴含的似然来估计参数向量 $\\boldsymbol{\\theta} = (\\theta_0,\\theta_1,\\theta_2)$。\n\n估计出 $\\boldsymbol{\\theta}$ 后，对以下每个测试案例，使用相同的协变量变换 $g_1$ 和 $g_2$，计算在固定期限 $H$（以年为单位）内模型蕴含的违约概率：\n\n新贷款和期限的测试套件：\n- 案例 $1$：FICO $710$，收入 $55000$，$H=1.0$。\n- 案例 $2$：FICO $580$，收入 $20000$，$H=1.0$。\n- 案例 $3$：FICO $800$，收入 $200000$，$H=1.0$。\n- 案例 $4$：FICO $700$，收入 $50000$，$H=0.5$。\n\n你的程序必须：\n- 接收上述固定数据集，并仅使用所提供的信息和模型定义来估计 $\\boldsymbol{\\theta}$。\n- 对每个测试案例，计算在指定期限 $H$ 内发生违约的概率，结果以 $[0,1]$ 区间内的小数表示。\n- 生成单行输出，其中包含按案例1到4顺序排列的结果，形式为方括号括起来的逗号分隔列表，每个值都四舍五入到6位小数。例如，输出应类似于 $[0.123456,0.234567,0.345678,0.456789]$。\n\n所有时间都必须以年为单位处理。所有概率都必须以小数形式表示，而不是百分比，并且在最终输出中必须四舍五入到恰好6位小数。", "solution": "对问题陈述进行验证。\n\n逐字提取已知条件：\n- 模型：基于强度的简约式模型。\n- 违约强度：$\\lambda(\\mathbf{x}) \\equiv \\exp\\!\\left(\\theta_0 + \\theta_1\\,g_1(\\text{FICO}) + \\theta_2\\,g_2(\\text{INC})\\right)$。\n- 协变量变换：$g_1(\\text{FICO}) = \\dfrac{\\text{FICO} - 700}{100}$ 和 $g_2(\\text{INC}) = \\ln\\!\\left(\\dfrac{\\text{INC}}{50000}\\right)$。\n- 时间单位：年。\n- 数据：6笔独立贷款，包含协变量（$\\text{FICO}_i, \\text{INC}_i$）、观测时间 $t_i$ 和违约指标 $d_i \\in \\{0,1\\}$。\n    - 贷款 A：FICO $650$，收入 $30000$，$t_A=0.5$，$d_A=1$。\n    - 贷款 B：FICO $720$，收入 $60000$，$t_B=1.0$，$d_B=0$。\n    - 贷款 C：FICO $680$，收入 $45000$，$t_C=0.8$，$d_C=1$。\n    - 贷款 D：FICO $760$，收入 $120000$，$t_D=1.2$，$d_D=0$。\n    - 贷款 E：FICO $700$，收入 $50000$，$t_E=1.5$，$d_E=0$。\n    - 贷款 F：FICO $600$，收入 $25000$，$t_F=0.3$，$d_F=1$。\n- 任务1：通过最大似然估计（MLE）来估计 $\\boldsymbol{\\theta} = (\\theta_0,\\theta_1,\\theta_2)$。\n- 任务2：为4个测试案例计算在期限 H 内模型蕴含的违约概率。\n    - 案例 $1$：FICO $710$，收入 $55000$，$H=1.0$。\n    - 案例 $2$：FICO $580$，收入 $20000$，$H=1.0$。\n    - 案例 $3$：FICO $800$，收入 $200000$，$H=1.0$。\n    - 案例 $4$：FICO $700$，收入 $50000$，$H=0.5$。\n- 输出格式：用方括号括起来的逗号分隔概率列表，四舍五入到6位小数。\n\n验证结论：\n该问题具有科学依据、提法适定且客观。它描述了生存分析的一个标准应用，具体来说是一个带有右删失数据的指数回归模型，这是生物统计学和计量经济学中用于为事件时间现象建模的常用技术。模型被完整地指定，数据已提供，目标明确。不存在矛盾、歧义或违反科学原则之处。该问题是有效的。我们继续求解。\n\n问题的核心是通过最大化观测数据的似然函数，来估计参数化生存模型的参数向量 $\\boldsymbol{\\theta} = (\\theta_0, \\theta_1, \\theta_2)^T$。该模型假设，对于具有协变量 $\\mathbf{x}$ 的给定贷款，其违约时间 $T$ 是一个指数随机变量，其恒定率参数为 $\\lambda(\\mathbf{x})$，称为违约强度。该强度由对数线性形式 $\\lambda(\\mathbf{x}) = \\exp(\\boldsymbol{\\theta}^T \\mathbf{x})$ 给出，其中 $\\mathbf{x} = [1, g_1(\\text{FICO}), g_2(\\text{INC})]^T$ 是转换后协变量的向量，包含用于截距项 $\\theta_0$ 的常数。\n\n对于一个率参数为 $\\lambda$ 的指数分布，其概率密度函数（PDF）为 $f(t|\\lambda) = \\lambda e^{-\\lambda t}$，其生存函数为 $S(t|\\lambda) = P(T > t) = e^{-\\lambda t}$。数据集包含右删失观测值。对于一个观测时间为 $t_i$、事件指标为 $d_i$ 的观测 $i$：\n- 如果发生违约 ($d_i=1$)，则事件在时间 $t_i$ 被观测到，其对似然的贡献是在 $t_i$ 处求值的PDF：$f(t_i|\\lambda_i) = \\lambda_i e^{-\\lambda_i t_i}$。\n- 如果观测值是右删失的 ($d_i=0$)，则事件在时间 $t_i$ 之前未发生，其对似然的贡献是存活超过时间 $t_i$ 的概率：$S(t_i|\\lambda_i) = e^{-\\lambda_i t_i}$。\n\n单个观测 $i$ 的似然贡献可以简洁地写为：\n$$\nL_i(\\boldsymbol{\\theta}) = [f(t_i|\\lambda_i)]^{d_i} [S(t_i|\\lambda_i)]^{1-d_i} = (\\lambda_i e^{-\\lambda_i t_i})^{d_i} (e^{-\\lambda_i t_i})^{1-d_i} = \\lambda_i^{d_i} e^{-\\lambda_i t_i}.\n$$\n假设 $N=6$ 笔贷款之间相互独立，总似然是各个贡献的乘积：\n$$\nL(\\boldsymbol{\\theta}) = \\prod_{i=1}^{N} L_i(\\boldsymbol{\\theta}) = \\prod_{i=1}^{N} \\lambda_i^{d_i} e^{-\\lambda_i t_i}.\n$$\n最大化似然等价于一个数值上更稳定的任务，即最大化对数似然函数 $\\ell(\\boldsymbol{\\theta}) = \\ln L(\\boldsymbol{\\theta})$：\n$$\n\\ell(\\boldsymbol{\\theta}) = \\sum_{i=1}^{N} \\ln(\\lambda_i^{d_i} e^{-\\lambda_i t_i}) = \\sum_{i=1}^{N} (d_i \\ln \\lambda_i - \\lambda_i t_i).\n$$\n代入 $\\lambda_i = \\exp(\\boldsymbol{\\theta}^T \\mathbf{x}_i)$，对数似然变为：\n$$\n\\ell(\\boldsymbol{\\theta}) = \\sum_{i=1}^{N} \\left(d_i (\\boldsymbol{\\theta}^T \\mathbf{x}_i) - t_i \\exp(\\boldsymbol{\\theta}^T \\mathbf{x}_i)\\right).\n$$\n该函数需要关于 $\\boldsymbol{\\theta}$ 进行最大化。这是一个标准的无约束优化问题。我们可以通过找到对数似然梯度的根来求得最优参数 $\\hat{\\boldsymbol{\\theta}}$。关于每个参数 $\\theta_j$ 的偏导数是：\n$$\n\\frac{\\partial \\ell}{\\partial \\theta_j} = \\sum_{i=1}^{N} \\left( d_i x_{ij} - t_i \\exp(\\boldsymbol{\\theta}^T \\mathbf{x}_i) x_{ij} \\right) = \\sum_{i=1}^{N} x_{ij} (d_i - t_i \\lambda_i).\n$$\n将梯度向量 $\\nabla_{\\boldsymbol{\\theta}} \\ell(\\boldsymbol{\\theta})$ 设为零，得到一个必须通过数值方法求解的非线性方程组。这可以通过使用诸如 BFGS 之类的拟牛顿法最小化负对数似然 $-\\ell(\\boldsymbol{\\theta})$ 来实现，该方法使用梯度信息来指导对最小值的搜索。\n\n首先，我们从训练数据构建 $6 \\times 3$ 的设计矩阵 $\\mathbf{X}$，其中每一行对应一笔贷款，形式为 $[1, g_1(\\text{FICO}_i), g_2(\\text{INC}_i)]$。我们还构建观测时间向量 $\\mathbf{t}$ 和事件指标向量 $\\mathbf{d}$。需要最小化的负对数似然函数是：\n$$\n-\\ell(\\boldsymbol{\\theta}) = \\sum_{i=1}^{N} \\left( t_i \\exp(\\boldsymbol{\\theta}^T \\mathbf{x}_i) - d_i (\\boldsymbol{\\theta}^T \\mathbf{x}_i) \\right).\n$$\n该目标函数的梯度是 $\\mathbf{X}^T(\\mathbf{t} \\odot \\boldsymbol{\\lambda} - \\mathbf{d})$，其中 $\\odot$ 表示逐元素乘法。\n\n一旦获得最大似然估计值 $\\hat{\\boldsymbol{\\theta}}$，我们就可以计算具有协变量 $\\mathbf{x}_{\\text{new}}$ 的新贷款在期限 $H$ 内的违约概率。估计的违约强度为 $\\hat{\\lambda}_{\\text{new}} = \\exp(\\hat{\\boldsymbol{\\theta}}^T \\mathbf{x}_{\\text{new}})$。到时间 $H$ 为止发生违约的概率由指数分布的累积分布函数给出：\n$$\nP(T \\le H | \\mathbf{x}_{\\text{new}}) = 1 - S(H | \\mathbf{x}_{\\text{new}}) = 1 - e^{-\\hat{\\lambda}_{\\text{new}} H}.\n$$\n对问题陈述中提供的四个测试案例中的每一个，都使用其各自的协变量和期限执行此计算。最终的数值结果四舍五入到6位小数。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the problem of estimating parameters for a reduced-form default model\n    and calculating default probabilities for new loans.\n    \"\"\"\n    \n    # Step 1: Define the training dataset from the problem statement.\n    # Data: (FICO, Income, Observed Time, Default Indicator)\n    training_data = [\n        (650, 30000, 0.5, 1),  # Loan A\n        (720, 60000, 1.0, 0),  # Loan B\n        (680, 45000, 0.8, 1),  # Loan C\n        (760, 120000, 1.2, 0),  # Loan D\n        (700, 50000, 1.5, 0),  # Loan E\n        (600, 25000, 0.3, 1),  # Loan F\n    ]\n\n    # Step 2: Define covariate transformation functions.\n    def g1(fico):\n        return (fico - 700) / 100\n\n    def g2(income):\n        return np.log(income / 50000)\n\n    # Step 3: Prepare the design matrix X and vectors t_obs, d_obs.\n    n_loans = len(training_data)\n    X = np.zeros((n_loans, 3))\n    t_obs = np.zeros(n_loans)\n    d_obs = np.zeros(n_loans)\n\n    for i, (fico, income, time, default) in enumerate(training_data):\n        X[i, 0] = 1 # Intercept\n        X[i, 1] = g1(fico)\n        X[i, 2] = g2(income)\n        t_obs[i] = time\n        d_obs[i] = default\n\n    # Step 4: Define the negative log-likelihood function and its gradient for optimization.\n    def neg_log_likelihood(theta):\n        \"\"\"Negative log-likelihood function for exponential regression model.\"\"\"\n        eta = X @ theta\n        lambda_vals = np.exp(eta)\n        log_lik = d_obs @ eta - t_obs @ lambda_vals\n        return -log_lik\n    \n    def grad_neg_log_likelihood(theta):\n        \"\"\"Gradient of the negative log-likelihood function.\"\"\"\n        eta = X @ theta\n        lambda_vals = np.exp(eta)\n        residual = t_obs * lambda_vals - d_obs\n        grad = X.T @ residual\n        return grad\n\n    # Step 5: Perform Maximum Likelihood Estimation using a numerical optimizer.\n    theta_initial = np.zeros(3) # Initial guess for theta = (theta_0, theta_1, theta_2)\n    \n    # Using BFGS algorithm which is a quasi-Newton method.\n    opt_result = minimize(\n        fun=neg_log_likelihood,\n        x0=theta_initial,\n        method='BFGS',\n        jac=grad_neg_log_likelihood,\n        options={'disp': False}\n    )\n    \n    theta_hat = opt_result.x\n\n    # Step 6: Define test cases and compute default probabilities.\n    test_cases = [\n        # (FICO, Income, Horizon H)\n        (710, 55000, 1.0),   # Case 1\n        (580, 20000, 1.0),   # Case 2\n        (800, 200000, 1.0),  # Case 3\n        (700, 50000, 0.5),   # Case 4\n    ]\n\n    results = []\n    for fico, income, horizon in test_cases:\n        # Create covariate vector for the test case\n        x_new = np.array([1, g1(fico), g2(income)])\n        \n        # Calculate estimated default intensity\n        lambda_hat = np.exp(x_new @ theta_hat)\n        \n        # Calculate probability of default within the horizon\n        prob_default = 1 - np.exp(-lambda_hat * horizon)\n        \n        results.append(prob_default)\n\n    # Step 7: Format the output as specified.\n    # The results must be rounded to 6 decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2425483"}, {"introduction": "最前沿的模型认识到，违约强度并非静止不变，而是随时间随机演化的。这个综合性练习将挑战你校准一个随机强度模型，其中强度遵循Ornstein-Uhlenbeck过程，以拟合市场信用违约互换（CDS）的利差曲线。这个练习整合了随机微积分、数值方法和优化技术，让你完成一项对量化分析师至关重要的核心任务。[@problem_id:2425452]", "problem": "你的任务是构建一个完整、可运行的程序，该程序能将一个仿射形式的简约式违约强度模型校准至合成的信用违约互换（CDS）数据。模型规定如下。违约强度由 $\\lambda_t = Y_t + \\psi$ 给出，其中 $Y_t$ 在风险中性测度下遵循一个Ornstein–Uhlenbeck（OU）过程：\n$$\ndY_t = \\kappa \\left( \\theta - Y_t \\right) dt + \\sigma \\, dW_t,\n$$\n其中 $\\kappa > 0$，$\\sigma \\ge 0$，$\\theta \\in \\mathbb{R}$，且 $Y_0 \\in \\mathbb{R}$。仿射偏移量 $\\psi \\in \\mathbb{R}$ 是一个常数参数。CDS采用简约式方法进行定价，使用连续保費近似、恒定的无风险利率 $r \\ge 0$、在 $(0,1]$ 区间内的小数形式违约损失率（LGD）以及保护期限 $T > 0$。\n\n从以下基础出发，不要使用任何未经证明的捷径：\n- Ornstein–Uhlenbeck 随机微分方程及其著名的高斯性。\n- 生存概率的定义 $S(t) = \\mathbb{E}\\left[ \\exp\\left( - \\int_0^t \\lambda_s \\, ds \\right) \\right]$。\n- 连续保费的公平CDS价差 $s^{\\star}(T)$ 满足一个等式，该等式使违约分支的现值与保费分支的现值相等，\n$$\ns^{\\star}(T) \\int_0^T e^{- r t} S(t) \\, dt = \\mathrm{LGD} \\int_0^T e^{- r t} \\left( - \\frac{dS(t)}{dt} \\right) dt.\n$$\n\n你的程序必须：\n- 根据给定的 $Y_0$、$\\kappa$、$\\theta$、$\\sigma$ 和 $\\psi$，推导并实现模型所蕴含的生存概率 $S(t)$。\n- 利用 $S(t)$，通过上述积分方程，为每个报价期限 $T$ 计算连续保费的公平CDS平价价差 $s^{\\star}(T)$，其中 $r$ 为常数，$\\mathrm{LGD}$ 为小数形式。如果需要，你可以使用数值积分。不应使用任何离散计息惯例；应完全采用连续保费近似。\n- 通过最小化模型隐含的平价价差与每个数据集所提供的合成报价在所有期限上的平方误差和，来校准未知参数 $\\psi$ 和 $\\theta$。使用最小二乘准则，并为优化器施加简单、合理的边界条件以保证适定性。对于每个数据集，你应将 $(\\kappa,\\sigma,r,\\mathrm{LGD},Y_0)$ 视为已知输入。\n\n重要单位和惯例：\n-所有利率（包括 $\\kappa$、$\\theta$、$\\sigma$、$Y_0$、$\\psi$、$r$ 和CDS平价价差）必须以“年化”小数形式处理（例如，$0.02$ 表示“年化百分之二”）。\n- 本任务不涉及角度或物理单位。\n- 所有输出均以小数形式报告。\n\n需要在代码中实现并覆盖的测试套件（对于以下每种情况，首先使用“真实”参数在指定期限上计算模型隐含的平价价差 $s^{\\star}(T)$来生成合成CDS报价，然后从这些报价中反向校准 $\\psi$ 和 $\\theta$，同时将 $\\kappa$、$\\sigma$、$Y_0$、$r$ 和 $\\mathrm{LGD}$ 视为已知）：\n\n- 情况A（理想路径，中等均值回归和波动率）：\n  - 已知输入：$\\kappa = 1.0$，$\\sigma = 0.1$，_ $Y_0 = 0.02$，$r = 0.02$，$\\mathrm{LGD} = 0.6$，期限 $T \\in \\{ 1.0, 3.0, 5.0 \\}$ 年。\n  - 用于生成数据的真实参数：$\\theta_{\\text{true}} = 0.015$，$\\psi_{\\text{true}} = 0.01$。\n\n- 情况B（边界条件，含确定性强度分量，$\\sigma = 0$）：\n  - 已知输入：$\\kappa = 0.7$，$\\sigma = 0.0$，$Y_0 = 0.03$，$r = 0.01$，$\\mathrm{LGD} = 0.6$，期限 $T \\in \\{ 1.0, 2.0, 4.0 \\}$ 年。\n  - 用于生成数据的真实参数：$\\theta_{\\text{true}} = 0.03$，$\\psi_{\\text{true}} = 0.005$。\n\n- 情况C（快速均值回归，较高偏移量）：\n  - 已知输入：$\\kappa = 3.0$，$\\sigma = 0.2$，$Y_0 = 0.01$，$r = 0.015$，$\\mathrm{LGD} = 0.6$，期限 $T \\in \\{ 2.0, 5.0, 7.0 \\}$ 年。\n  - 用于生成数据的真实参数：$\\theta_{\\text{true}} = 0.012$，$\\psi_{\\text{true}} = 0.02$。\n\n算法要求：\n- 对于每种情况，首先使用真实参数计算合成报价。然后，仅使用这些报价，通过受简单边界约束的最小二乘法校准 $\\psi$ 和 $\\theta$，边界需保持 $\\psi$ 为严格正数，且 $\\theta$ 在一个宽泛、合理的区间内。对所有必要的积分使用稳健的数值积分方法。\n- 输出格式：你的程序应生成单行输出，包含一个扁平列表，其中校准后的参数按以下順序排列：\n$$\n[\\psi_A, \\theta_A, \\psi_B, \\theta_B, \\psi_C, \\theta_C],\n$$\n其中下标表示对应的情况。将每个值四舍五入到6位小数。例如，一个可接受的格式是 $[0.010000,0.015000,0.005000,0.030000,0.020000,0.012000]$。\n\n你的实现必须是自包含的，不需要用户输入，并且不访问任何外部资源。最后打印的行必须与上述描述的格式完全匹配。所有量都必须以年化小数形式计算。", "solution": "问题陈述已经过验证并被认为是有效的。它在科学上基于量化金融的原理，特别是仿射期限结构模型。该模型由一个Ornstein-Uhlenbeck过程驱动违约强度，是一个标准的结构（Vasicek类型模型）。这个问题是适定的，为通过数值校准获得唯一解提供了足够的信息，并且没有歧义或矛盾。它代表了计算金融领域的一个标准练习。\n\n解决方案主要分为三个阶段：首先，推导生存概率函数；其次，构建信用违约互換（CDS）价差的计算公式；第三，阐明数值校准的流程。\n\n### 1. 生存概率推导\n\n违约强度由仿射过程 $\\lambda_t = Y_t + \\psi$ 给出，其中 $Y_t$ 在风险中性测度 $\\mathbb{Q}$ 下遵循Ornstein-Uhlenbeck（OU）过程：\n$$\ndY_t = \\kappa (\\theta - Y_t) dt + \\sigma dW_t\n$$\n初始条件为 $Y_0$。参数 $\\kappa$、$\\theta$、$\\sigma$ 和 $\\psi$ 均为常数。\n\n到时间 $t$ 为止的生存概率 $S(t)$ 定义为与累积违约强度相关的贴现因子的风险中性期望值：\n$$\nS(t) = \\mathbb{E}^{\\mathbb{Q}} \\left[ \\exp\\left( - \\int_0^t \\lambda_s ds \\right) \\bigg| \\mathcal{F}_0 \\right]\n$$\n代入 $\\lambda_s = Y_s + \\psi$ 并利用积分的线性性质，可得：\n$$\nS(t) = \\mathbb{E}^{\\mathbb{Q}} \\left[ \\exp\\left( - \\int_0^t (Y_s + \\psi) ds \\right) \\right] = \\exp(-\\psi t) \\mathbb{E}^{\\mathbb{Q}} \\left[ \\exp\\left( - \\int_0^t Y_s ds \\right) \\right]\n$$\n该期望项是仿射过程的标准结果。对于为 $Y_t$ 定义的OU过程，已知该期望对初始状态 $Y_0$ 具有指数仿射形式：\n$$\n\\mathbb{E}^{\\mathbb{Q}} \\left[ \\exp\\left( - \\int_0^t Y_s ds \\right) \\right] = \\exp\\left( A(t) - B(t)Y_0 \\right)\n$$\n其中 $A(t)$ 和 $B(t)$ 是时间的确定性函数。这些函数解一个从Feynman-Kac定理导出的常微分方程组。标准解为：\n$$\nB(t) = \\frac{1}{\\kappa} \\left( 1 - e^{-\\kappa t} \\right)\n$$\n和\n$$\nA(t) = \\left( \\theta - \\frac{\\sigma^2}{2\\kappa^2} \\right) [B(t) - t] - \\frac{\\sigma^2}{4\\kappa} B(t)^2\n$$\n这个 $A(t)$ 和 $B(t)$ 的公式是稳健的，即使在模型变为确定性的 $\\sigma = 0$ 情况下也成立。$\\kappa \\to 0$ 的情况代表一个不同的过程（布朗运动），在此不作讨论，因为问题指定了 $\\kappa > 0$。\n\n综合这些结果，生存概率 $S(t)$ 由以下解析表达式给出：\n$$\nS(t) = \\exp \\left( -\\psi t + A(t) - B(t)Y_0 \\right)\n$$\n\n### 2. CDS价差计算\n\n连续保费CDS的公平平价价差，记为 $s^{\\star}(T)$，由一个使保费分支的现值（PV）与违约分支的现值（PV）相等的方程定义：\n$$\ns^{\\star}(T) \\int_0^T e^{-rt} S(t) dt = \\mathrm{LGD} \\int_0^T e^{-rt} \\left( -\\frac{dS(t)}{dt} \\right) dt\n$$\n其中 $r$ 是恒定的无风险利率，$\\mathrm{LGD}$ 是小数形式的违约损失率。\n\n设保费分支的现值为 $PL(T) = \\int_0^T e^{-rt} S(t) dt$。右侧的积分代表经LGD缩放的违约概率密度的现值，可以使用分部积分法进行简化。令 $u = e^{-rt}$ 且 $dv = -S'(t)dt$。则 $du = -re^{-rt}dt$ 且 $v = S(t)$。\n$$\n\\int_0^T e^{-rt}(-S'(t))dt = \\left[ e^{-rt}S(t) \\right]_0^T - \\int_0^T S(t)(-re^{-rt})dt\n$$\n$$\n= \\left( e^{-rT}S(T) - S(0) \\right) + r \\int_0^T e^{-rt}S(t)dt\n$$\n由于 $S(0) = 1$（时间零点的生存概率为1），这变为：\n$$\n\\int_0^T e^{-rt}(-S'(t))dt = e^{-rT}S(T) - 1 + r \\cdot PL(T)\n$$\n等等，此处推导有误。重新评估分部积分法：\n令 $u = e^{-rt}$ 且 $dv = -S'(t)dt$。积分为 $\\int u \\, dv$。\n根据分部积分法：$\\int u \\, dv = uv - \\int v \\, du$。\n$uv = e^{-rt}(-S(t))$。因此 $[uv]_0^T = -e^{-rT}S(T) - (-e^0 S(0)) = 1-e^{-rT}S(T)$。\n$\\int v \\, du = \\int_0^T (-S(t))(-re^{-rt})dt = r \\int_0^T e^{-rt}S(t)dt = r \\cdot PL(T)$。\n因此，违约分支积分的正确表达式是：\n$$\n\\int_0^T e^{-rt}(-S'(t))dt = 1 - e^{-rT}S(T) - r \\cdot PL(T)\n$$\n这个表达式避免了对 $S(t)$ 求导，因此在数值上更为稳定。\n\n于是，公平价差 $s^{\\star}(T)$ 可通过求解得到：\n$$\ns^{\\star}(T) = \\mathrm{LGD} \\frac{1 - e^{-rT}S(T) - r \\cdot PL(T)}{PL(T)}\n$$\n$PL(T)$ 的积分没有闭式解，必须通过数值积分计算。\n\n### 3. 校准流程\n\n目标是通过最小化模型隐含价差 $s^{\\star}_{\\text{model}}(T_i; \\mathbf{p})$与在一组期限 $\\{T_i\\}_{i=1}^N$ 上的合成市场报价 $s^{\\text{quote}}_i$ 之间的平方差之和来校准参数 $\\mathbf{p} = (\\psi, \\theta)$。\n\n需要最小化的目标函数是：\n$$\nJ(\\psi, \\theta) = \\sum_{i=1}^N \\left( s^{\\star}_{\\text{model}}(T_i; \\psi, \\theta) - s^{\\text{quote}}_i \\right)^2\n$$\n每次校准的已知参数为 $(\\kappa, \\sigma, Y_0, r, \\mathrm{LGD})$。这是一个非线性最小二乘问题。将使用受参数边界约束的准牛顿优化算法（特别是能处理箱型约束的L-BFGS-B）来求解。按照规定，我们将施加 $\\psi > 0$ 的约束，并将 $\\theta$ 限制在一个宽泛、合理的区间内，以确保解的稳定性和金融合理性。\n\n每个测试用例的总体算法如下：\n1.  使用“真实”参数 $(\\psi_{\\text{true}}, \\theta_{\\text{true}})$ 和该情况下的其他已知量，通过实现上面推导的价差公式，计算每个期限 $T_i$ 的合成CDS报价 $s^{\\text{quote}}_i$。\n2.  定义目标函数 $J(\\psi, \\theta)$，该函数接受候选参数，计算相应的模型价差，并返回与合成报价之间的平方误差和。\n3.  使用一个优化程序（`scipy.optimize.minimize`），并提供一个初始猜测值和预定义的边界，来找到最小化 $J$ 的参数向量 $(\\hat{\\psi}, \\hat{\\theta})$。\n4.  得到的结果对 $(\\hat{\\psi}, \\hat{\\theta})$ 构成该情况下的校准参数。对所有指定的测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import minimize\n\ndef B_func(t, kappa):\n    \"\"\"\n    Calculates the B(t) function for the affine model.\n    B(t) = (1/kappa) * (1 - exp(-kappa * t))\n    \"\"\"\n    if np.isclose(kappa, 0.0):\n        # Taylor expansion for small kappa: (1 - (1 - kt + (kt)^2/2)) / k = t - kt^2/2 -> t\n        return t\n    return (1.0 - np.exp(-kappa * t)) / kappa\n\ndef A_func(t, kappa, theta, sigma):\n    \"\"\"\n    Calculates the A(t) function for the affine model.\n    A(t) = (theta - sigma^2/(2*kappa^2)) * [B(t) - t] - (sigma^2 / (4*kappa)) * B(t)^2\n    \"\"\"\n    if np.isclose(kappa, 0.0):\n        # Limit for kappa -> 0 with dY_t = sigma * dW_t\n        # This case is not required by problem spec (kappa>0) but good for robustness.\n        # Direct derivation gives A(t) = sigma^2 * t^3 / 6\n        return sigma**2 * t**3 / 6.0\n        \n    b_val = B_func(t, kappa)\n    \n    # This calculation can be unstable if kappa is very small.\n    # Grouping terms to improve stability. theta * (B(t) - t) is one part.\n    # The sigma part: sigma^2 * [ - (B(t)-t)/(2k^2) - B(t)^2/(4k) ]\n    # = sigma^2 * [ (t-B(t))/(2k^2) - B(t)^2/(4k) ]\n    # = sigma^2/(4k^3) * [ 2k(t-B(t)) - k^2 B(t)^2 ]\n    # 2k(t-B(t)) = 2k(t - (1-e^-kt)/k) = 2kt - 2 + 2e^-kt\n    # k^2 B(t)^2 = (1-e^-kt)^2 = 1 - 2e^-kt + e^-2kt\n    # sum = 2kt - 3 + 4e^-kt - e^-2kt\n    # So A(t) = theta(B(t)-t) + sigma^2/(4k^3) * (2kt - 3 + 4e^-kt - e^-2kt)\n    # The standard form is generally stable enough for kappa values not extremely close to 0.\n    term1_factor = theta - (sigma**2) / (2.0 * kappa**2)\n    term1 = term1_factor * (b_val - t)\n    term2 = -(sigma**2) / (4.0 * kappa) * b_val**2\n    return term1 + term2\n\ndef survival_prob(t, Y0, kappa, theta, sigma, psi):\n    \"\"\"\n    Calculates the survival probability S(t) given model parameters.\n    S(t) = exp(-psi*t + A(t) - B(t)*Y0)\n    \"\"\"\n    if t < 1e-9:  # Survival probability at t=0 is 1.\n        return 1.0\n\n    a_val = A_func(t, kappa, theta, sigma)\n    b_val = B_func(t, kappa)\n    \n    exponent = -psi * t + a_val - b_val * Y0\n    return np.exp(exponent)\n\ndef calculate_spread(T_maturity, Y0, kappa, theta, sigma, psi, r, LGD):\n    \"\"\"\n    Calculates the fair CDS par spread s*(T) for a given maturity.\n    \"\"\"\n    # Integrand for the premium leg PV\n    integrand_pl = lambda t: np.exp(-r * t) * survival_prob(t, Y0, kappa, theta, sigma, psi)\n    \n    # Calculate premium leg PV using numerical quadrature\n    pl_pv, quad_err = quad(integrand_pl, 0, T_maturity, epsabs=1e-9, epsrel=1e-9)\n    \n    if pl_pv < 1e-12:\n        return np.inf  # Avoid division by zero\n        \n    s_T = survival_prob(T_maturity, Y0, kappa, theta, sigma, psi)\n    \n    # PV of default leg per unit of LGD, derived using integration by parts\n    dl_pv_per_lgd = 1.0 - np.exp(-r * T_maturity) * s_T - r * pl_pv\n    \n    spread = LGD * dl_pv_per_lgd / pl_pv\n    return spread\n\ndef solve():\n    \"\"\"\n    Main function to run test cases, calibrate parameters, and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"knowns\": {\"kappa\": 1.0, \"sigma\": 0.1, \"Y0\": 0.02, \"r\": 0.02, \"LGD\": 0.6},\n            \"maturities\": [1.0, 3.0, 5.0],\n            \"true_params\": {\"theta\": 0.015, \"psi\": 0.01},\n        },\n        {\n            \"name\": \"Case B\",\n            \"knowns\": {\"kappa\": 0.7, \"sigma\": 0.0, \"Y0\": 0.03, \"r\": 0.01, \"LGD\": 0.6},\n            \"maturities\": [1.0, 2.0, 4.0],\n            \"true_params\": {\"theta\": 0.03, \"psi\": 0.005},\n        },\n        {\n            \"name\": \"Case C\",\n            \"knowns\": {\"kappa\": 3.0, \"sigma\": 0.2, \"Y0\": 0.01, \"r\": 0.015, \"LGD\": 0.6},\n            \"maturities\": [2.0, 5.0, 7.0],\n            \"true_params\": {\"theta\": 0.012, \"psi\": 0.02},\n        },\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        knowns = case[\"knowns\"]\n        true_params = case[\"true_params\"]\n        maturities = case[\"maturities\"]\n\n        # Step 1: Generate synthetic CDS quotes using the true parameters\n        synthetic_quotes = [\n            calculate_spread(\n                T_maturity=T,\n                Y0=knowns[\"Y0\"],\n                kappa=knowns[\"kappa\"],\n                theta=true_params[\"theta\"],\n                sigma=knowns[\"sigma\"],\n                psi=true_params[\"psi\"],\n                r=knowns[\"r\"],\n                LGD=knowns[\"LGD\"],\n            ) for T in maturities\n        ]\n\n        # Step 2: Define the objective function for calibration\n        def objective_function(params):\n            psi_cal, theta_cal = params\n            \n            # Simple check for parameter validity\n            if psi_cal <= 0:\n                return 1e9 # Return a large number if parameters are out of bounds\n\n            model_spreads = [\n                calculate_spread(\n                    T_maturity=T,\n                    Y0=knowns[\"Y0\"],\n                    kappa=knowns[\"kappa\"],\n                    theta=theta_cal,\n                    sigma=knowns[\"sigma\"],\n                    psi=psi_cal,\n                    r=knowns[\"r\"],\n                    LGD=knowns[\"LGD\"],\n                ) for T in maturities\n            ]\n            \n            error = np.sum((np.array(model_spreads) - np.array(synthetic_quotes))**2)\n            return error\n\n        # Step 3: Calibrate parameters using least squares minimization\n        initial_guess = [0.01, 0.01]  # Generic initial guess\n        bounds = [(1e-7, 0.5), (-0.1, 0.5)] # Bounds: psi > 0, theta in a wide range\n\n        result = minimize(\n            objective_function,\n            initial_guess,\n            method='L-BFGS-B',\n            bounds=bounds,\n            options={'ftol': 1e-12, 'gtol': 1e-12}\n        )\n        \n        calibrated_psi, calibrated_theta = result.x\n        all_results.extend([calibrated_psi, calibrated_theta])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{val:.6f}\" for val in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2425452"}]}