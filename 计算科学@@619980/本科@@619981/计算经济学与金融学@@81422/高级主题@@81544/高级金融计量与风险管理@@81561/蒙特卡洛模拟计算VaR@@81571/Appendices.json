{"hands_on_practices": [{"introduction": "我们的第一个实践练习将引导你使用蒙特卡洛模拟构建一个基础的在险价值（VaR）计算模型。你将运用历史数据自举法 (historical bootstrap)，即通过对历史回报率数据集进行重采样来生成未来的回报情景。这个动手练习 ([@problem_id:2412304]) 对于从第一性原理理解如何构建潜在未来结果的分布，并量化极端损失风险至关重要。", "problem": "给定一个在离散时间步上定义的价格过程，其初始价格为 $S_0 \\in \\mathbb{R}_{+}$。在每一步 $t \\in \\{1,2,\\dots,H\\}$，简单回报率 $r_t$ 是从一个给定的有限历史简单回报率集合 $\\{r^{(1)}, r^{(2)}, \\dots, r^{(m)}\\}$ 所支持的经验分布中进行的独立抽取，每个支持点的抽取概率相等，为 $1/m$。价格通过简单复利演变，即 $S_{t} = S_{t-1}\\,(1 + r_t)$，其中 $t=1,\\dots,H$。对于一个固定的时间范围 $H \\in \\mathbb{N}_0$，根据此模型模拟 $N \\in \\mathbb{N}$ 个独立的期末价格，以获得期末价格样本 $\\{S_H^{(i)}\\}_{i=1}^N$。将路径 $i$ 上的损失定义为 $L^{(i)} = S_0 - S_H^{(i)}$（正值表示损失）。对于给定的概率水平 $q \\in [0,1]$，将在险价值 (Value-at-Risk, VaR) 定义为损失分布的样本 $q$-分位数。具体来说，如果 $L_{(1)} \\le \\dots \\le L_{(N)}$ 是排序后的损失，且 $h = (N-1)\\,q + 1$，其中 $k = \\lfloor h \\rfloor$ 且 $\\gamma = h - k$，则\n$$\n\\operatorname{VaR}_q =\n\\begin{cases}\nL_{(k)} + \\gamma \\big(L_{(k+1)} - L_{(k)}\\big), & \\text{若 } 1 \\le k < N, \\\\\nL_{(N)}, & \\text{若 } k \\ge N.\n\\end{cases}\n$$\n如果 $N=1$，则 $\\operatorname{VaR}_q = L_{(1)}$。所有回报率都必须作为以小数表示的简单回报率处理（例如，$0.01$ 表示百分之一），并且 VaR 必须以与 $S_0$ 相同的货币单位的浮点数表示（而不是比例）。为每个测试用例使用指定的伪随机种子来初始化随机数生成器，以确保结果是可复现的。如果 $H=0$，则将其解释为一个退化时间范围，此时几乎必然有 $S_H = S_0$。\n\n您的任务是为以下每个测试用例计算 $\\operatorname{VaR}_q$。最终输出必须是单行文本，其中包含一个用方括号括起来的、以逗号分隔的结果列表，结果的顺序与测试用例的顺序相同。每个结果必须四舍五入到六位小数。\n\n测试套件：\n1) $S_0 = 100.0$，历史回报率 $[ -0.03,\\,-0.01,\\,0.0,\\,0.005,\\,0.01,\\,0.015,\\,0.02,\\,0.03 ]$，$H = 5$，$N = 20000$，$q = 0.99$，种子 $= 202311$。\n2) $S_0 = 250.0$，历史回报率 $[ -0.02,\\,-0.015,\\,-0.01,\\,-0.005,\\,0.0,\\,0.005,\\,0.01,\\,0.015 ]$，$H = 10$，$N = 15000$，$q = 0.95$，种子 $= 42$。\n3) $S_0 = 100.0$，历史回报率 $[ -0.02,\\,0.0,\\,0.02 ]$，$H = 1$，$N = 100000$，$q = 0.5$，种子 $= 7$。\n4) $S_0 = 123.45$，历史回报率 $[ -0.01,\\,0.0,\\,0.01,\\,0.02 ]$，$H = 0$，$N = 10000$，$q = 0.99$，种子 $= 99$。\n5) $S_0 = 80.0$，历史回报率 $[ -0.05,\\,-0.01,\\,0.0,\\,0.02,\\,0.04 ]$，$H = 3$，$N = 1$，$q = 0.975$，种子 $= 555$。\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，\"[result1,result2,result3,result4,result5]\"），其中每个结果是四舍五入到六位小数的在险价值。", "solution": "问题陈述已经过严格验证，被认为是科学上合理、定义明确且完整的。它提出了一个标准的计算金融任务：使用非参数蒙特卡洛模拟来估计在险价值。我们现在将进行正式的求解。\n\n问题的核心是为初始价值为 $S_0$ 的金融头寸估计在险价值 ($\\operatorname{VaR}_q$)。价格过程 $S_t$ 在离散时间步 $t \\in \\{1, 2, \\dots, H\\}$ 上演变。该演变由简单回报率 $r_t$ 驱动，这些回报率被建模为独立同分布的随机变量。它们的分布是来自给定 $m$ 个历史回报率集合 $\\{r^{(1)}, r^{(2)}, \\dots, r^{(m)}\\}$ 的经验分布，其中每个历史回报率以 $1/m$ 的概率被抽中。\n\n在时间 $t$ 的价格由简单复利法则给出：\n$$\nS_t = S_{t-1} (1 + r_t)\n$$\n从初始价格 $S_0$ 开始，在时间范围 $H$ 的期末价格是 $H$ 次连续乘法的结果：\n$$\nS_H = S_0 \\prod_{t=1}^{H} (1 + r_t)\n$$\n与价格路径相关的损失定义为初始价格与期末价格之差：\n$$\nL = S_0 - S_H\n$$\n$L$ 的正值对应于货币损失。\n\n为了估计作为损失分布的 $q$-分位数的 $\\operatorname{VaR}_q$，我们采用蒙特卡洛方法。这包括模拟价格过程的 $N$ 条独立路径。对于每个模拟路径 $i \\in \\{1, \\dots, N\\}$，我们生成一个包含 $H$ 个随机回报率的序列 $\\{r_{i,t}\\}_{t=1}^H$，每个回报率都从指定的经验分布中抽取。这产生了一个包含 $N$ 个期末价格的样本：\n$$\nS_H^{(i)} = S_0 \\prod_{t=1}^{H} (1 + r_{i,t}) \\quad \\text{for } i=1, \\dots, N\n$$\n根据这个期末价格样本，我们计算出相应的损失样本：\n$$\nL^{(i)} = S_0 - S_H^{(i)} \\quad \\text{for } i=1, \\dots, N\n$$\n然后将 $\\operatorname{VaR}_q$ 计算为损失集合 $\\{L^{(i)}\\}_{i=1}^N$ 的样本 $q$-分位数。该问题为样本分位数指定了一个基于线性插值的精确定义。设 $L_{(1)} \\le L_{(2)} \\le \\dots \\le L_{(N)}$ 为按非降序排列的损失。分位数使用索引 $h = (N-1)q + 1$ 计算。设 $k = \\lfloor h \\rfloor$ 为整数部分，$\\gamma = h - k$ 为小数部分。则 $\\operatorname{VaR}_q$ 由下式给出：\n$$\n\\operatorname{VaR}_q = L_{(k)} + \\gamma (L_{(k+1)} - L_{(k)})\n$$\n对于 $1 \\le k < N$。如果 $k \\ge N$（这在 $q=1$ 时发生），则 $\\operatorname{VaR}_q = L_{(N)}$。这个定义等同于分位数的 `'linear'` 插值方法，这是诸如 `numpy` 等数值计算库中可用的标准实现。\n\n该计算算法旨在使用向量化操作来提高效率：\n1.  对每个测试用例，初始化参数 $S_0$、历史回报率数组 $\\mathcal{R}$、时间范围 $H$、路径数 $N$、分位数水平 $q$ 和随机种子。\n2.  播种伪随机数生成器以确保可复现性。\n3.  特殊情况 $H=0$ 意味着 $S_H = S_0$，因此损失始终为 $0$，且 $\\operatorname{VaR}_q = 0.0$。\n4.  特殊情况 $N=1$ 只需要模拟一条路径。根据定义，产生的单个损失 $L^{(1)} = S_0 - S_H^{(1)}$ 即为 $\\operatorname{VaR}_q$。\n5.  在一般情况下（$H > 0, N > 1$），通过从历史回报率数组中有放回地抽样，生成一个 $N \\times H$ 的回报率矩阵。\n6.  该回报率矩阵被转换为一个增长因子 $(1+r)$ 矩阵。沿每行（时间轴）计算这些因子的乘积，得到一个总路径乘数向量。\n7.  将此向量乘以 $S_0$ 得到包含 $N$ 个期末价格的向量 $\\{S_H^{(i)}\\}$。\n8.  损失向量 $\\{L^{(i)}\\}$ 计算为 $S_0 - \\{S_H^{(i)}\\}$。\n9.  最后，将配置为线性插值的 `numpy.quantile` 函数应用于损失向量和指定的分位数水平 $q$，以计算 $\\operatorname{VaR}_q$。\n\n此过程被系统地应用于问题陈述中提供的每个测试用例。最终结果将四舍五入到指定的精度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Value-at-Risk (VaR) for several test cases using Monte Carlo simulation.\n    \"\"\"\n    test_cases = [\n        (100.0, [-0.03, -0.01, 0.0, 0.005, 0.01, 0.015, 0.02, 0.03], 5, 20000, 0.99, 202311),\n        (250.0, [-0.02, -0.015, -0.01, -0.005, 0.0, 0.005, 0.01, 0.015], 10, 15000, 0.95, 42),\n        (100.0, [-0.02, 0.0, 0.02], 1, 100000, 0.5, 7),\n        (123.45, [-0.01, 0.0, 0.01, 0.02], 0, 10000, 0.99, 99),\n        (80.0, [-0.05, -0.01, 0.0, 0.02, 0.04], 3, 1, 0.975, 555),\n    ]\n\n    results = []\n    for case in test_cases:\n        S0, hist_returns, H, N, q, seed = case\n        \n        # Handle the degenerate case where the horizon H is 0.\n        # The terminal price is S0, so the loss is always 0.\n        if H == 0:\n            var = 0.0\n            results.append(var)\n            continue\n            \n        rng = np.random.default_rng(seed)\n        hist_returns_arr = np.array(hist_returns)\n        \n        # Handle the case where only one path is simulated (N=1).\n        # The VaR is simply the loss from that single path.\n        if N == 1:\n            # Simulate one path of H steps.\n            returns_path = rng.choice(hist_returns_arr, size=H, replace=True)\n            # The problem defines simple compounding.\n            path_multiplier = np.prod(1 + returns_path)\n            S_H = S0 * path_multiplier\n            loss = S0 - S_H\n            var = loss\n            results.append(var)\n            continue\n\n        # General case for Monte Carlo simulation (H > 0, N > 1).\n        # Generate N x H matrix of random returns by choosing from historical returns.\n        returns_matrix = rng.choice(hist_returns_arr, size=(N, H), replace=True)\n        \n        # Calculate terminal prices for all N paths using vectorized operations.\n        # The product of (1 + r_t) is taken along the time axis (axis=1).\n        path_multipliers = np.prod(1 + returns_matrix, axis=1)\n        terminal_prices = S0 * path_multipliers\n        \n        # Calculate the distribution of losses.\n        losses = S0 - terminal_prices\n        \n        # Calculate VaR, which is the sample q-quantile of the loss distribution.\n        # The problem's VaR formula corresponds to numpy's 'linear' interpolation method.\n        var = np.quantile(losses, q, method='linear')\n        \n        results.append(var)\n\n    # Format the final output as a comma-separated list string, with each\n    # result rounded to six decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2412304"}, {"introduction": "在基础自举法之上，本练习将介绍一种更精密的VaR计算技术：已过滤历史数据模拟法 (Filtered Historical Simulation, FHS)。FHS通过根据当前市场波动率对历史回报进行缩放，来增强历史模拟的适用性，从而创造出更贴近当前风险环境的情景。通过这项实践 ([@problem_id:2412321])，你将学会如何实现一个能适应变化市场条件的动态VaR模型。", "problem": "实现一个程序，使用筛选历史模拟法（filtered historical simulation）计算线性投资组合的单日风险价值（VaR）。从以下定义和假设开始：一个投资组合包含 $N$ 项资产，其在时间 $t \\in \\{1,\\dots,T\\}$ 上的历史简单回报率为 $\\{r_{i,t}\\}$（资产 $i \\in \\{1,\\dots,N\\}$），在相同时刻的历史条件波动率为 $\\{\\sigma_{i,t}\\}$，当前的条件波动率向量为 $\\sigma_{i,0}$，以及总和为 $1$ 的固定投资组合权重 $w_i$。对于每个历史时刻 $t$，定义标准化残差 $z_{i,t} = r_{i,t} / \\sigma_{i,t}$，假设所有 $\\sigma_{i,t} > 0$。筛选历史模拟法通过将每个标准化的历史残差缩放到当前条件来构建一个经验情景集：情景 $t$ 中模拟的未来资产回报率为 $\\tilde{r}_{i,t} = \\sigma_{i,0} \\cdot z_{i,t}$。情景 $t$ 中对应的投资组合回报率为 $s_t = \\sum_{i=1}^N w_i \\tilde{r}_{i,t}$。将投资组合回报率的经验 $\\alpha$-分位数定义为 $\\{s_t\\}_{t=1}^T$ 的第 $k$ 阶统计量，其中 $k = \\lceil \\alpha T \\rceil$（$\\lceil \\cdot \\rceil$ 表示向上取整函数），使用基于1的索引。将置信水平为 $\\alpha$ 的单日 VaR 定义为 $\\text{VaR}_\\alpha = - q_\\alpha$，其中 $q_\\alpha$ 是 $\\{s_t\\}_{t=1}^T$ 的经验 $\\alpha$-分位数。所有回报率必须按无单位的小数值（而非百分比）处理。\n\n您的任务是严格按照上述步骤实现程序，不进行任何重采样：直接使用 $T$ 个缩放后的情景 $\\{\\tilde{r}_{i,t}\\}$。使用以下三个测试用例；每个用例都是独立的，并应在相同的程序逻辑上进行评估：\n\n- 测试用例1（双资产投资组合，基准当前波动率）：\n  - 历史回报率矩阵 $R \\in \\mathbb{R}^{T \\times N}$，$T=5$，$N=2$：\n    - 行 $t=1$：$[-0.02,\\;0.01]$\n    - 行 $t=2$：$[0.01,\\;-0.005]$\n    - 行 $t=3$：$[-0.01,\\;0.015]$\n    - 行 $t=4$：$[0.02,\\;-0.01]$\n    - 行 $t=5$：$[-0.015,\\;0.005]$\n  - 历史条件波动率矩阵 $S \\in \\mathbb{R}_{>0}^{T \\times N}$：\n    - 行 $t=1$：$[0.02,\\;0.01]$\n    - 行 $t=2$：$[0.01,\\;0.005]$\n    - 行 $t=3$：$[0.01,\\;0.015]$\n    - 行 $t=4$：$[0.02,\\;0.01]$\n    - 行 $t=5$：$[0.015,\\;0.005]$\n  - 权重 $w = [0.6,\\;0.4]$。\n  - 当前波动率 $\\sigma_0 = [0.03,\\;0.02]$。\n  - 置信水平 $\\alpha = 0.05$。\n\n- 测试用例2（历史数据和权重相同，当前波动率较低，$\\alpha$ 值不同）：\n  - $R$ 和 $S$ 与测试用例1相同。\n  - 权重 $w = [0.6,\\;0.4]$。\n  - 当前波动率 $\\sigma_0 = [0.015,\\;0.01]$。\n  - 置信水平 $\\alpha = 0.10$。\n\n- 测试用例3（单资产边界情况）：\n  - 历史回报率向量 $R_A = [-0.02,\\;0.01,\\;-0.01,\\;0.02,\\;-0.015]$，$T=5$，$N=1$。\n  - 历史条件波动率 $S_A = [0.02,\\;0.01,\\;0.01,\\;0.02,\\;0.015]$。\n  - 权重 $w = [1.0]$。\n  - 当前波动率 $\\sigma_0 = [0.04]$。\n  - 置信水平 $\\alpha = 0.20$。\n\n程序要求：\n- 精确实现定义：计算 $z_{i,t} = r_{i,t} / \\sigma_{i,t}$，然后计算 $\\tilde{r}_{i,t} = \\sigma_{i,0} \\cdot z_{i,t}$，再对每个情景 $t$ 计算 $s_t = \\sum_{i=1}^N w_i \\tilde{r}_{i,t}$。\n- 将经验 $\\alpha$-分位数计算为第 $k$ 小的值，其中 $k = \\lceil \\alpha T \\rceil$，然后计算 $\\text{VaR}_\\alpha = -q_\\alpha$。\n- 将每个测试用例的VaR报告为小数（无百分号），并四舍五入到六位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表（例如，“[x1,x2,x3]”），无空格，并按测试用例1、测试用例2、测试用例3的顺序排列。\n\n您的程序必须是自包含的，并且不得读取任何外部输入或文件。", "solution": "我们从风险计量和时变波动率建模的基本原理推导出该算法。目标是计算在线性投资组合下，使用筛选历史模拟法得到的置信水平为 $\\alpha$ 的单日风险价值（VaR）。置信水平为 $\\alpha$ 的风险价值（VaR）被定义为一个数值 $\\text{VaR}_\\alpha$，在特定模型下，损失超过 $\\text{VaR}_\\alpha$ 的概率为 $\\alpha$。对于单日时间范围和线性投资组合，设投资组合回报率为 $s$，一个常见的经验定义使用回报率分布的 $\\alpha$-分位数的负值：令 $q_\\alpha$ 为回报率的 $\\alpha$-分位数，则 $\\text{VaR}_\\alpha = - q_\\alpha$。\n\n为了构建用于筛选历史模拟的 $q_\\alpha$，我们从资产 $i \\in \\{1,\\dots,N\\}$ 在时间 $t \\in \\{1,\\dots,T\\}$ 上的历史简单回报率 $r_{i,t}$ 开始。我们假设每个历史时刻 $t$ 都有一个条件波动率序列 $\\sigma_{i,t} > 0$，以及一个当前的条件波动率 $\\sigma_{i,0} > 0$。在条件异方差但标准化且平稳的创新过程的假设下，我们通过波动率对回报率进行标准化，得到 $z_{i,t} = r_{i,t} / \\sigma_{i,t}$。标准化残差 $z_{i,t}$ 被视为从一个均值为零、单位尺度的平稳分布中抽取的样本，如果存在偏度（skewness）和峰度（kurtosis）等特征，该方法也能捕捉到。\n\n为了在不指定参数分布的情况下模拟当前条件下的未来资产回报率，筛选历史模拟法将每个标准化残差缩放到当前波动率：$\\tilde{r}_{i,t} = \\sigma_{i,0} \\cdot z_{i,t}$。对于权重 $w_i$ 总和为1的线性投资组合，情景 $t$ 中的模拟投资组合回报率为\n$$\ns_t = \\sum_{i=1}^N w_i \\tilde{r}_{i,t} = \\sum_{i=1}^N w_i \\sigma_{i,0} \\frac{r_{i,t}}{\\sigma_{i,t}}.\n$$\n这 $T$ 个值 $\\{s_t\\}_{t=1}^T$ 构成了经验情景集。将它们升序排列，$s_{(1)} \\le \\cdots \\le s_{(T)}$，经验 $\\alpha$-分位数被定义为 $q_\\alpha = s_{(k)}$，其中 $k = \\lceil \\alpha T \\rceil$，使用基于1的索引。VaR 则为 $\\text{VaR}_\\alpha = - q_\\alpha$。\n\n我们将此方法应用于三个指定的测试用例。\n\n测试用例1：\n- $T=5$, $N=2$，历史回报率 $R$ 和历史波动率 $S$：\n  - $t=1$：$r_{1,1} = -0.02$, $r_{2,1} = 0.01$, $\\sigma_{1,1} = 0.02$, $\\sigma_{2,1} = 0.01$。\n  - $t=2$：$r_{1,2} = 0.01$, $r_{2,2} = -0.005$, $\\sigma_{1,2} = 0.01$, $\\sigma_{2,2} = 0.005$。\n  - $t=3$：$r_{1,3} = -0.01$, $r_{2,3} = 0.015$, $\\sigma_{1,3} = 0.01$, $\\sigma_{2,3} = 0.015$。\n  - $t=4$：$r_{1,4} = 0.02$, $r_{2,4} = -0.01$, $\\sigma_{1,4} = 0.02$, $\\sigma_{2,4} = 0.01$。\n  - $t=5$：$r_{1,5} = -0.015$, $r_{2,5} = 0.005$, $\\sigma_{1,5} = 0.015$, $\\sigma_{2,5} = 0.005$。\n- 标准化残差 $z_{1,t} = r_{1,t}/\\sigma_{1,t} \\in \\{-1, 1, -1, 1, -1\\}$ 和 $z_{2,t} = r_{2,t}/\\sigma_{2,t} \\in \\{1, -1, 1, -1, 1\\}$。\n- 权重 $w_1 = 0.6$，$w_2 = 0.4$，当前波动率 $\\sigma_{1,0} = 0.03$，$\\sigma_{2,0} = 0.02$。\n- 对于每个 $t$，$\\tilde{r}_{1,t} = 0.03 z_{1,t}$，$\\tilde{r}_{2,t} = 0.02 z_{2,t}$。因此 $s_t = 0.6 \\cdot \\tilde{r}_{1,t} + 0.4 \\cdot \\tilde{r}_{2,t} = 0.6 \\cdot 0.03 z_{1,t} + 0.4 \\cdot 0.02 z_{2,t} = 0.018 z_{1,t} + 0.008 z_{2,t}$。\n- 使用符号模式，我们得到 $s_t \\in \\{-0.01, 0.01, -0.01, 0.01, -0.01\\}$。排序后：$[-0.01, -0.01, -0.01, 0.01, 0.01]$。\n- 当 $\\alpha = 0.05$ 时，$k = \\lceil 0.05 \\cdot 5 \\rceil = \\lceil 0.25 \\rceil = 1$，所以 $q_\\alpha = -0.01$ 且 $\\text{VaR}_\\alpha = 0.01$。\n\n测试用例2：\n- 与测试用例1相同的 $R$、$S$ 和 $w$。\n- 当前波动率减半：$\\sigma_{1,0} = 0.015$，$\\sigma_{2,0} = 0.01$；因此 $\\tilde{r}_{1,t} = 0.015 z_{1,t}$，$\\tilde{r}_{2,t} = 0.01 z_{2,t}$ 且 $s_t = 0.6 \\cdot 0.015 z_{1,t} + 0.4 \\cdot 0.01 z_{2,t} = 0.009 z_{1,t} + 0.004 z_{2,t}$。\n- 使用相同的符号模式，$s_t \\in \\{-0.005, 0.005, -0.005, 0.005, -0.005\\}$。排序后：$[-0.005, -0.005, -0.005, 0.005, 0.005]$。\n- 当 $\\alpha = 0.10$ 时，$k = \\lceil 0.10 \\cdot 5 \\rceil = \\lceil 0.5 \\rceil = 1$，所以 $q_\\alpha = -0.005$ 且 $\\text{VaR}_\\alpha = 0.005$。\n\n测试用例3：\n- 单资产，其 $R_A = [-0.02, 0.01, -0.01, 0.02, -0.015]$, $S_A = [0.02, 0.01, 0.01, 0.02, 0.015]$，所以 $z_{1,t} \\in \\{-1, 1, -1, 1, -1\\}$。\n- 权重 $w_1 = 1.0$，当前波动率 $\\sigma_{1,0} = 0.04$ 给出 $\\tilde{r}_{1,t} = 0.04 z_{1,t}$ 且 $s_t = \\tilde{r}_{1,t} \\in \\{-0.04, 0.04, -0.04, 0.04, -0.04\\}$。\n- 排序后：$[-0.04, -0.04, -0.04, 0.04, 0.04]$。\n- 当 $\\alpha = 0.20$ 时，$k = \\lceil 0.20 \\cdot 5 \\rceil = \\lceil 1.0 \\rceil = 1$，所以 $q_\\alpha = -0.04$ 且 $\\text{VaR}_\\alpha = 0.04$。\n\n实现细节：\n- 逐元素计算 $z_{i,t}$ 为 $r_{i,t}/\\sigma_{i,t}$。\n- 使用给定的 $w_i$ 和 $\\sigma_{i,0}$ 计算每个 $t$ 的 $s_t$。\n- 将 $\\{s_t\\}$ 升序排序并取第 $k$ 个元素，其中 $k = \\lceil \\alpha T \\rceil$。\n- 对每个测试用例，输出 $\\text{VaR}_\\alpha = - q_\\alpha$，四舍五入到六位小数。\n- 生成单行输出：一个用方括号括起来的逗号分隔列表，按测试用例1、测试用例2、测试用例3的顺序排列。\n\n根据以上推导，三个测试用例的预期VaR输出分别为 $0.01$、$0.005$ 和 $0.04$，每个都表示为小数并四舍五入到六位小数。", "answer": "```python\nimport numpy as np\n\ndef empirical_var_fhs(R, S, w, sigma_now, alpha):\n    \"\"\"\n    Filtered Historical Simulation VaR:\n    - R: array of shape (T, N) historical returns\n    - S: array of shape (T, N) historical conditional volatilities (>0)\n    - w: array of shape (N,) portfolio weights summing to 1\n    - sigma_now: array of shape (N,) current conditional volatilities (>0)\n    - alpha: float in (0,1), VaR level\n    Returns VaR as a positive float (-alpha-quantile of returns).\n    \"\"\"\n    R = np.asarray(R, dtype=float)\n    S = np.asarray(S, dtype=float)\n    w = np.asarray(w, dtype=float)\n    sigma_now = np.asarray(sigma_now, dtype=float)\n    T, N = R.shape\n    assert S.shape == (T, N)\n    assert w.shape == (N,)\n    assert sigma_now.shape == (N,)\n    assert np.all(S > 0), \"Historical sigmas must be > 0\"\n    assert np.all(sigma_now > 0), \"Current sigmas must be > 0\"\n    # Standardized residuals z_{i,t}\n    Z = R / S\n    # Scaled returns under current volatility: \\tilde r_{i,t} = sigma_now[i] * Z[t,i]\n    # Portfolio return per scenario t: s_t = sum_i w_i * \\tilde r_{i,t}\n    scaled = Z * sigma_now  # shape (T, N)\n    s = scaled @ w  # shape (T,)\n    # Empirical alpha-quantile using k = ceil(alpha * T), 1-based\n    s_sorted = np.sort(s)\n    k = int(np.ceil(alpha * T))\n    k = max(k, 1)  # ensure at least first order statistic\n    q_alpha = s_sorted[k - 1]\n    var = -q_alpha\n    return var\n\ndef solve():\n    results = []\n\n    # Test Case 1\n    R1 = np.array([\n        [-0.02,   0.01 ],\n        [ 0.01,  -0.005],\n        [-0.01,   0.015],\n        [ 0.02,  -0.01 ],\n        [-0.015,  0.005]\n    ], dtype=float)\n    S1 = np.array([\n        [0.02,  0.01 ],\n        [0.01,  0.005],\n        [0.01,  0.015],\n        [0.02,  0.01 ],\n        [0.015, 0.005]\n    ], dtype=float)\n    w1 = np.array([0.6, 0.4], dtype=float)\n    sigma_now1 = np.array([0.03, 0.02], dtype=float)\n    alpha1 = 0.05\n    var1 = empirical_var_fhs(R1, S1, w1, sigma_now1, alpha1)\n    results.append(round(var1, 6))\n\n    # Test Case 2\n    sigma_now2 = np.array([0.015, 0.01], dtype=float)\n    alpha2 = 0.10\n    var2 = empirical_var_fhs(R1, S1, w1, sigma_now2, alpha2)\n    results.append(round(var2, 6))\n\n    # Test Case 3 (single asset)\n    R3 = np.array([[-0.02],\n                   [ 0.01],\n                   [-0.01],\n                   [ 0.02],\n                   [-0.015]], dtype=float)\n    S3 = np.array([[0.02],\n                   [0.01],\n                   [0.01],\n                   [0.02],\n                   [0.015]], dtype=float)\n    w3 = np.array([1.0], dtype=float)\n    sigma_now3 = np.array([0.04], dtype=float)\n    alpha3 = 0.20\n    var3 = empirical_var_fhs(R3, S3, w3, sigma_now3, alpha3)\n    results.append(round(var3, 6))\n\n    # Print in exact required format: single line, comma-separated, no spaces, in brackets\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "2412321"}, {"introduction": "尽管VaR是一个广泛应用的风险指标，但它并非一个“一致性”风险度量，这主要是因为它可能违背次可加性原则。最后的这个练习将使用蒙特卡洛模拟，不仅是为了计算，更是为了进行概念探索，让你构建一个投资组合，其总风险大于各组成部分风险之和（$\\text{VaR}(A+B) \\gt \\text{VaR}(A) + \\text{VaR}(B)$）。这项练习 ([@problem_id:2412240]) 为VaR的一个关键理论局限性提供了强有力的动手实践证明，并揭示了风险分散的好处并非总是成立。", "problem": "构建一个独立的程序，从第一性原理出发，计算风险价值（VaR）在特定定义的情况下是否具有次可加性。设损失为一个实值随机变量。对于一个损失随机变量 $X$，其累积分布函数为 $F_X(x)$，以及一个水平 $\\alpha \\in (0,1)$，将水平为 $\\alpha$ 的风险价值定义为\n$$\n\\operatorname{VaR}_{\\alpha}(X) = \\inf\\{x \\in \\mathbb{R} : F_X(x) \\ge \\alpha\\}.\n$$\n给定一个来自 $X$ 的独立同分布样本 $L_1, \\dots, L_n$，定义经验分布函数 $F_n(x) = \\frac{1}{n} \\sum_{i=1}^n \\mathbf{1}\\{L_i \\le x\\}$ 和经验风险价值估计量\n$$\n\\widehat{\\operatorname{VaR}}_{\\alpha}(X) = \\inf\\{x \\in \\mathbb{R} : F_n(x) \\ge \\alpha\\}.\n$$\n对于下述每个测试用例，考虑两个损失随机变量 $A$ 和 $B$，并定义投资组合损失 $P = A + B$。对每个测试用例 $j$，计算布尔结果\n$$\nI_j = \\big[\\widehat{\\operatorname{VaR}}_{\\alpha}(P) > \\widehat{\\operatorname{VaR}}_{\\alpha}(A) + \\widehat{\\operatorname{VaR}}_{\\alpha}(B)\\big].\n$$\n所有用例均使用相同的样本量 $n$ 和固定的伪随机种子 $s$。所有概率都应解释为 $[0,1]$ 范围的小数。不涉及物理单位。\n\n你的程序必须实现以下测试套件。在所有情况下，抽样数量为 $n = 400,000$，伪随机种子为 $s = 20231407$。所有的伯努利事件和标准正态变量都必须根据指定的依赖结构进行抽样。\n\n- 测试用例 1 (独立，罕见大额损失)：$\\alpha = 0.95$。资产 $A$ 的损失有 $0.03$ 的概率为 $10$，否则为 $0$。资产 $B$ 具有相同的分布。$A$ 和 $B$ 是独立的。\n- 测试用例 2 (独立，不对称罕见损失)：$\\alpha = 0.975$。资产 $A$ 的损失有 $0.02$ 的概率为 $8$，否则为 $0$。资产 $B$ 的损失有 $0.02$ 的概率为 $12$，否则为 $0$。$A$ 和 $B$ 是独立的。\n- 测试用例 3 (同单调罕见损失)：$\\alpha = 0.95$。资产 $A$ 的损失有 $0.03$ 的概率为 $10$，否则为 $0$。资产 $B$ 具有相同的边际分布。其依赖关系是同单调的：存在一个在 $[0,1]$ 上的均匀分布 $U$，使得当且仅当 $U < 0.03$ 时，$A$ 和 $B$ 的损失均等于其损失水平，否则均为 $0$。\n- 测试用例 4 (相关高斯损失)：$\\alpha = 0.99$。资产 $A$ 是均值为 $0$、标准差为 $1$ 的高斯分布。资产 $B$ 是均值为 $0$、标准差为 $1.2$ 的高斯分布。$A$ 和 $B$ 之间的相关系数为 $0.6$。\n- 测试用例 5 (完全负相关高斯损失)：$\\alpha = 0.99$。资产 $A$ 是均值为 $0$、标准差为 $1$ 的高斯分布。资产 $B$ 几乎必然等于 $-A$（完全负相关），因此投资组合损失恒为 $0$。\n\n对于每种情况，生成与所述分布和依赖关系一致的 $n$ 对抽样 $(A_i,B_i)$。使用上面 $\\widehat{\\operatorname{VaR}}_{\\alpha}$ 的定义，计算在指定 $\\alpha$ 水平下 $A$、$B$ 和 $P = A+B$ 的经验风险价值。然后计算定义的 $I_j$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[true,false,true,true,false]”），但使用大写的 Python 布尔字面量。也就是说，确切的输出格式必须是“[result1,result2,result3,result4,result5]”，其中每个结果为 “True” 或 “False”。", "solution": "该问题要求对风险价值 ($\\operatorname{VaR}$) 度量的次可加性进行计算研究。如果对于任意两个损失随机变量 $X$ 和 $Y$，不等式 $\\rho(X+Y) \\le \\rho(X) + \\rho(Y)$ 均成立，则风险度量 $\\rho$ 被定义为次可加的。该属性形式化了多样化原则：合并后投资组合的风险不应大于其各个组成部分风险的总和。风险价值是一种广泛使用的风险度量，但它并不是 Artzner 等人 (1999) 意义上的一致性风险度量，这恰恰是因为它可能不满足次可加性。本练习通过具体的、构造性的例子来证明这一点。\n\n任务是为五个不同的测试用例计算不等式 $\\widehat{\\operatorname{VaR}}_{\\alpha}(P) > \\widehat{\\operatorname{VaR}}_{\\alpha}(A) + \\widehat{\\operatorname{VaR}}_{\\alpha}(B)$ 的布尔结果，其中 $A$ 和 $B$ 是损失随机变量，$P=A+B$ 是投资组合损失，$\\widehat{\\operatorname{VaR}}_{\\alpha}$ 是在置信水平 $\\alpha$ 下的经验风险价值估计量。\n\n经验 $\\operatorname{VaR}$ 定义为 $\\widehat{\\operatorname{VaR}}_{\\alpha}(X) = \\inf\\{x \\in \\mathbb{R} : F_n(x) \\ge \\alpha\\}$，其中 $F_n(x)$ 是来自大小为 $n$ 的样本的经验累积分布函数。对于一个损失样本 $L_1, \\dots, L_n$，设其排序后的样本为 $L_{(1)} \\le L_{(2)} \\le \\dots \\le L_{(n)}$。经验CDF $F_n(x)$ 是一个阶跃函数，在每个数据点处跳跃 $1/n$。条件 $F_n(x) \\ge \\alpha$ 等价于说至少有 $n\\alpha$ 个样本点小于或等于 $x$。这意味着 $x$ 必须至少与第 $\\lceil n\\alpha \\rceil$ 个顺序统计量一样大。因此，经验VaR恰好是该顺序统计量的值：\n$$\n\\widehat{\\operatorname{VaR}}_{\\alpha}(X) = L_{(\\lceil n\\alpha \\rceil)}\n$$\n我们对每个测试用例的通用流程如下：\n1.  用固定的种子 $s = 20231407$ 初始化一个伪随机数生成器。\n2.  根据指定的边际分布和依赖结构，为 $i=1, \\dots, n$ 生成一个大小为 $n = 400,000$ 的配对抽样样本 $(A_i, B_i)$。\n3.  创建投资组合损失样本 $P_i = A_i + B_i$。\n4.  对于三个样本 $\\{A_i\\}$、$\\{B_i\\}$ 和 $\\{P_i\\}$ 中的每一个，计算在指定水平 $\\alpha$ 下的经验 $\\operatorname{VaR}$。这包括对样本进行排序，并选择索引为 $k-1$（使用基于0的索引）的元素，其中 $k = \\lceil n\\alpha \\rceil$。\n5.  评估布尔表达式 $I_j = [\\widehat{\\operatorname{VaR}}_{\\alpha}(P) > \\widehat{\\operatorname{VaR}}_{\\alpha}(A) + \\widehat{\\operatorname{VaR}}_{\\alpha}(B)]$。\n\n每个用例的具体生成方法如下：\n\n测试用例 1 (独立，罕见大额损失)：$\\alpha = 0.95$。$A$ 和 $B$ 的损失是从伯努利分布中抽取的，表示有 $p=0.03$ 的概率发生 $10$ 的损失，否则为 $0$。独立性通过使用两个独立的均匀随机数流 $U_A$ 和 $U_B$ 来为 $A$ 和 $B$ 生成样本。对于每个 $i \\in \\{1, \\dots, n\\}$，如果 $U_{A,i} < 0.03$，则 $A_i=10$，否则 $A_i=0$；对 $B_i$ 使用 $U_{B,i}$ 进行类似操作。VaR计算的索引为 $k = \\lceil 400,000 \\times 0.95 \\rceil = 380,000$。\n\n测试用例 2 (独立，不对称罕见损失)：$\\alpha = 0.975$。此用例在结构上与第一个相似，但参数不对称。资产 $A$ 有 $0.02$ 的概率损失为 $8$，资产 $B$ 有 $0.02$ 的概率损失为 $12$。独立性再次通过独立的随机数流来建模。VaR索引为 $k = \\lceil 400,000 \\times 0.975 \\rceil = 390,000$。\n\n测试用例 3 (同单调罕见损失)：$\\alpha = 0.95$。$A$ 和 $B$ 的边际分布与用例 1 相同。然而，依赖关系是同单调的。这通过使用单一的均匀随机数流 $U$ 来建模。对于每个 $i \\in \\{1, \\dots, n\\}$，如果 $U_i < 0.03$，则 $A_i$ 和 $B_i$ 都设为 $10$，否则都为 $0$。这代表了尾部事件中的完全正相关性。VaR索引为 $k = \\lceil 400,000 \\times 0.95 \\rceil = 380,000$。\n\n测试用例 4 (相关高斯损失)：$\\alpha = 0.99$。$A \\sim \\mathcal{N}(0, 1^2)$ 且 $B \\sim \\mathcal{N}(0, 1.2^2)$，相关系数 $\\rho(A, B) = 0.6$。我们从此二元正态分布中生成配对样本。这可以通过首先生成独立标准正态变量对 $(Z_{1,i}, Z_{2,i})$，然后应用与协方差矩阵 $\\Sigma$ 的 Cholesky 分解相对应的线性变换来实现：\n$$\n\\Sigma = \\begin{pmatrix} \\sigma_A^2 & \\rho \\sigma_A \\sigma_B \\\\ \\rho \\sigma_A \\sigma_B & \\sigma_B^2 \\end{pmatrix} = \\begin{pmatrix} 1 & 0.72 \\\\ 0.72 & 1.44 \\end{pmatrix}\n$$\n一种更简单、等效的构造是 $A_i = Z_{1,i}$ 和 $B_i = \\sigma_B (\\rho Z_{1,i} + \\sqrt{1-\\rho^2} Z_{2,i})$。VaR索引为 $k = \\lceil 400,000 \\times 0.99 \\rceil = 396,000$。对于像多元正态这样的椭球分布，已知VaR是次可加的。\n\n测试用例 5 (完全负相关高斯损失)：$\\alpha = 0.99$。资产 $A \\sim \\mathcal{N}(0, 1^2)$ 且 $B = -A$。这是一个完全对冲的情况。我们为 $A$ 生成一个标准正态变量样本，并将 $B$ 的样本设置为其逐元素的相反数。投资组合损失在所有结果中均为 $P = A+B = 0$。因此，其经验 $\\widehat{\\operatorname{VaR}}_{\\alpha}(P)$ 必须为 $0$。VaR索引为 $k = \\lceil 400,000 \\times 0.99 \\rceil = 396,000$。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes whether Value-at-Risk (VaR) is subadditive in five specific cases.\n    \"\"\"\n    \n    # Global parameters\n    N_SAMPLES = 400_000\n    SEED = 20231407\n    \n    # Initialize a single random number generator for all simulations\n    rng = np.random.default_rng(SEED)\n\n    test_cases = [\n        # Case 1: Independent, rare large losses\n        {\n            \"alpha\": 0.95,\n            \"A\": {\"type\": \"bernoulli\", \"loss\": 10.0, \"p\": 0.03},\n            \"B\": {\"type\": \"bernoulli\", \"loss\": 10.0, \"p\": 0.03},\n            \"dep\": \"independent\"\n        },\n        # Case 2: Independent, asymmetric rare losses\n        {\n            \"alpha\": 0.975,\n            \"A\": {\"type\": \"bernoulli\", \"loss\": 8.0, \"p\": 0.02},\n            \"B\": {\"type\": \"bernoulli\", \"loss\": 12.0, \"p\": 0.02},\n            \"dep\": \"independent\"\n        },\n        # Case 3: Comonotonic rare losses\n        {\n            \"alpha\": 0.95,\n            \"A\": {\"type\": \"bernoulli\", \"loss\": 10.0, \"p\": 0.03},\n            \"B\": {\"type\": \"bernoulli\", \"loss\": 10.0, \"p\": 0.03},\n            \"dep\": \"comonotonic\"\n        },\n        # Case 4: Correlated Gaussian losses\n        {\n            \"alpha\": 0.99,\n            \"A\": {\"type\": \"gaussian\", \"mean\": 0.0, \"std\": 1.0},\n            \"B\": {\"type\": \"gaussian\", \"mean\": 0.0, \"std\": 1.2},\n            \"dep\": \"correlated\", \"rho\": 0.6\n        },\n        # Case 5: Perfectly negatively dependent Gaussian losses\n        {\n            \"alpha\": 0.99,\n            \"A\": {\"type\": \"gaussian\", \"mean\": 0.0, \"std\": 1.0},\n            \"B\": {\"type\": \"gaussian\", \"mean\": 0.0, \"std\": 1.0},\n            \"dep\": \"negatively_dependent\"\n        }\n    ]\n\n    results = []\n\n    def get_empirical_var(samples, alpha):\n        \"\"\"\n        Calculates the empirical Value-at-Risk.\n        Defined as the k-th order statistic, where k = ceil(n*alpha).\n        \"\"\"\n        n = len(samples)\n        k = math.ceil(n * alpha)\n        # Using k-1 for 0-based indexing\n        sorted_samples = np.sort(samples)\n        return sorted_samples[k - 1]\n\n    for case in test_cases:\n        alpha = case[\"alpha\"]\n        \n        # --- Generate samples for A and B based on the case ---\n        if case[\"dep\"] == \"independent\":\n            u_a = rng.random(size=N_SAMPLES)\n            u_b = rng.random(size=N_SAMPLES)\n            params_a = case[\"A\"]\n            samples_a = np.where(u_a  params_a[\"p\"], params_a[\"loss\"], 0.0)\n            params_b = case[\"B\"]\n            samples_b = np.where(u_b  params_b[\"p\"], params_b[\"loss\"], 0.0)\n\n        elif case[\"dep\"] == \"comonotonic\":\n            u = rng.random(size=N_SAMPLES)\n            params_a = case[\"A\"]\n            samples_a = np.where(u  params_a[\"p\"], params_a[\"loss\"], 0.0)\n            params_b = case[\"B\"]\n            samples_b = np.where(u  params_b[\"p\"], params_b[\"loss\"], 0.0)\n\n        elif case[\"dep\"] == \"correlated\":\n            params_a = case[\"A\"]\n            params_b = case[\"B\"]\n            rho = case[\"rho\"]\n            \n            mean = [params_a[\"mean\"], params_b[\"mean\"]]\n            cov = [[params_a[\"std\"]**2, rho * params_a[\"std\"] * params_b[\"std\"]],\n                   [rho * params_a[\"std\"] * params_b[\"std\"], params_b[\"std\"]**2]]\n            \n            samples = rng.multivariate_normal(mean, cov, size=N_SAMPLES)\n            samples_a = samples[:, 0]\n            samples_b = samples[:, 1]\n            \n        elif case[\"dep\"] == \"negatively_dependent\":\n            params_a = case[\"A\"]\n            samples_a = rng.normal(loc=params_a[\"mean\"], scale=params_a[\"std\"], size=N_SAMPLES)\n            samples_b = -samples_a\n        \n        # --- Create portfolio samples ---\n        samples_p = samples_a + samples_b\n        \n        # --- Calculate VaR for A, B, and Portfolio P ---\n        var_a = get_empirical_var(samples_a, alpha)\n        var_b = get_empirical_var(samples_b, alpha)\n        var_p = get_empirical_var(samples_p, alpha)\n        \n        # --- Check for subadditivity violation ---\n        is_violated = var_p > (var_a + var_b)\n        results.append(is_violated)\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2412240"}]}