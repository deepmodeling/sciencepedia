{"hands_on_practices": [{"introduction": "一切建模始于可靠的数据生成。本练习将指导你使用逆变换采样法（Inverse Transform Sampling）——一种生成随机变量的基础而强大的技术——来编程实现一个广义帕累托分布（GPD）的随机数生成器。通过将生成样本的分位数与理论分位数进行比较，你将学习如何验证你的模拟结果的准确性，这是所有计算金融和风险建模工作的重要第一步 [@problem_id:2397442]。", "problem": "一家金融机构使用广义帕累托分布 (Generalized Pareto Distribution, GPD) 对超过某一高阈值的超额损失进行建模。设 $X$ 服从 GPD，其形状参数为 $\\xi \\in \\mathbb{R}$，尺度参数为 $\\beta \\in (0,\\infty)$，位置参数为 $\\mu \\in \\mathbb{R}$。其累积分布函数定义如下\n- 对于 $\\xi \\neq 0$，\n$$\nF(x;\\xi,\\beta,\\mu) \\;=\\; 1 - \\left(1 + \\xi \\frac{x-\\mu}{\\beta}\\right)^{-1/\\xi}\n\\quad \\text{当} \\quad\n\\begin{cases}\nx \\ge \\mu & \\text{若 } \\xi \\ge 0, \\\\\n\\mu \\le x \\le \\mu - \\beta/\\xi & \\text{若 } \\xi < 0,\n\\end{cases}\n$$\n- 对于 $\\xi = 0$，\n$$\nF(x;0,\\beta,\\mu) \\;=\\; 1 - \\exp\\!\\left(-\\frac{x-\\mu}{\\beta}\\right)\n\\quad \\text{当} \\quad x \\ge \\mu.\n$$\n\n您必须编写一个完整的程序，该程序能为多组参数集从上述 GPD 生成独立同分布的随机变量，然后通过在一个固定的概率网格上比较经验分位数与理论分位数来评估生成的样本。所有计算都应使用指定的种子以保证可复现性。不允许使用外部数据或用户输入。\n\n定义与要求：\n- 设 $U$ 是一个在 $(0,1)$ 上服从标准连续均匀分布的随机变量。分位数函数 $F^{-1}(p;\\xi,\\beta,\\mu)$ 对 $p \\in (0,1)$ 定义为其支撑集上 $F(\\cdot;\\xi,\\beta,\\mu)$ 的反函数。\n- 对于给定的概率 $p \\in (0,1)$，有限样本 $x_{1},\\dots,x_{n}$ 的经验 $p$-分位数定义如下：将样本按非递减顺序排序得到 $x_{(1)} \\le \\dots \\le x_{(n)}$，令 $s = (n-1)p$，设整数索引 $i = \\lfloor s \\rfloor + 1$ 和 $j = \\lceil s \\rceil + 1$ 均在 $\\{1,\\dots,n\\}$ 内，并令 $\\lambda = s - \\lfloor s \\rfloor$。经验分位数为\n$$\nQ_{\\text{emp}}(p) \\;=\\; (1-\\lambda)\\,x_{(i)} + \\lambda\\,x_{(j)}.\n$$\n- 构建一个分位数网格 $\\mathcal{P} = \\{0.01, 0.02, \\dots, 0.99\\}$ 和一个中心网格 $\\mathcal{P}_{\\text{central}} = \\{0.05, 0.10, \\dots, 0.95\\}$。\n- 对于给定的参数集和大小为 $n$ 的样本，计算向量 $\\mathbf{Q}_{\\text{th}} = \\big(F^{-1}(p;\\xi,\\beta,\\mu)\\big)_{p \\in \\mathcal{P}}$ 和 $\\mathbf{Q}_{\\text{emp}} = \\big(Q_{\\text{emp}}(p)\\big)_{p \\in \\mathcal{P}}$。利用这些向量，计算：\n    1. $\\mathbf{Q}_{\\text{th}}$ 与 $\\mathbf{Q}_{\\text{emp}}$ 之间的决定系数 $R^{2}$，定义为这两个向量的 Pearson 相关系数的平方。\n    2. 通过普通最小二乘法拟合线性模型 $Q_{\\text{emp}} \\approx a + b\\,Q_{\\text{th}}$ 所得的最小二乘斜率 $b$ 和截距 $a$。\n    3. 中心网格上的最大绝对偏差，经尺度参数归一化后为 $\\Delta_{\\max} = \\max_{p \\in \\mathcal{P}_{\\text{central}}} \\big|Q_{\\text{emp}}(p) - F^{-1}(p;\\xi,\\beta,\\mu)\\big|/\\beta$。\n    4. 对于 $\\xi < 0$ 的情况，支撑集的上端点为 $x_{\\max} = \\mu - \\beta/\\xi$。定义支撑集检查为 $\\mathbf{1}\\{\\max_{k} x_{k} \\le x_{\\max}\\}$，其中 $x_{k}$ 是抽样值，$\\mathbf{1}\\{\\cdot\\}$ 是指示函数。对于 $\\xi \\ge 0$ 的情况，此检查自动满足。\n\n每组参数集的接受标准：\n- $R^{2} \\ge 0.9995$，\n- $|b - 1| \\le 0.02$，\n- $|a| \\le 0.05\\,\\beta$，\n- $\\Delta_{\\max} \\le 0.12$，\n- 支撑集检查通过。\n\n对于每组参数集，输出一个布尔值，指示是否同时满足所有接受标准。\n\n测试套件：\n- 案例 1：$(\\xi,\\beta,\\mu,n,\\text{seed}) = (0.25,\\,1.40,\\,0.00,\\,120000,\\,1729)$。\n- 案例 2：$(\\xi,\\beta,\\mu,n,\\text{seed}) = (0.00,\\,2.20,\\,0.50,\\,150000,\\,41041)$。\n- 案例 3：$(\\xi,\\beta,\\mu,n,\\text{seed}) = (-0.35,\\,1.10,\\,-0.30,\\,120000,\\,271828)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为按上述案例顺序排列的结果，例如 $[\\text{True},\\text{False},\\text{True}]$，其中每个条目都是一个布尔值。", "solution": "所述问题经过了严格的验证。\n\n**步骤 1：提取已知条件**\n- **分布**：广义帕累托分布 (GPD)，其形状参数为 $\\xi \\in \\mathbb{R}$，尺度参数为 $\\beta \\in (0,\\infty)$，位置参数为 $\\mu \\in \\mathbb{R}$。\n- **累积分布函数 (CDF)**：\n  - 对于 $\\xi \\neq 0$：$F(x;\\xi,\\beta,\\mu) = 1 - \\left(1 + \\xi \\frac{x-\\mu}{\\beta}\\right)^{-1/\\xi}$，当 $\\xi \\ge 0$ 时支撑集为 $x \\ge \\mu$，当 $\\xi < 0$ 时支撑集为 $\\mu \\le x \\le \\mu - \\beta/\\xi$。\n  - 对于 $\\xi = 0$：$F(x;0,\\beta,\\mu) = 1 - \\exp\\left(-\\frac{x-\\mu}{\\beta}\\right)$，支撑集为 $x \\ge \\mu$。\n- **分位数函数**：$F^{-1}(p;\\xi,\\beta,\\mu)$ 定义为 CDF 在 $p \\in (0,1)$ 上的反函数。\n- **经验分位数**：对于排序后的样本 $x_{(1)} \\le \\dots \\le x_{(n)}$，经验 $p$-分位数为 $Q_{\\text{emp}}(p) = (1-\\lambda)\\,x_{(i)} + \\lambda\\,x_{(j)}$，其中 $s = (n-1)p$，$i = \\lfloor s \\rfloor + 1$，$j = \\lceil s \\rceil + 1$，$\\lambda = s - \\lfloor s \\rfloor$。\n- **概率网格**：$\\mathcal{P} = \\{0.01, 0.02, \\dots, 0.99\\}$ 和 $\\mathcal{P}_{\\text{central}} = \\{0.05, 0.10, \\dots, 0.95\\}$。\n- **评估所需的指标**：\n    1. 在网格 $\\mathcal{P}$ 上，理论分位数 $\\mathbf{Q}_{\\text{th}}$ 与经验分位数 $\\mathbf{Q}_{\\text{emp}}$ 之间的决定系数 $R^{2}$。\n    2. 线性模型 $Q_{\\text{emp}} \\approx a + b\\,Q_{\\text{th}}$ 的最小二乘斜率 $b$ 和截距 $a$。\n    3. 最大归一化绝对偏差 $\\Delta_{\\max} = \\max_{p \\in \\mathcal{P}_{\\text{central}}} \\big|Q_{\\text{emp}}(p) - F^{-1}(p)\\big|/\\beta$。\n    4. 支撑集检查：对于 $\\xi < 0$，指示函数 $\\mathbf{1}\\{\\max_{k} x_{k} \\le \\mu - \\beta/\\xi\\}$；对于 $\\xi \\ge 0$，此项默认满足。\n- **接受标准**：\n    1. $R^{2} \\ge 0.9995$\n    2. $|b - 1| \\le 0.02$\n    3. $|a| \\le 0.05\\,\\beta$\n    4. $\\Delta_{\\max} \\le 0.12$\n    5. 支撑集检查必须通过。\n- **测试案例**：\n    1. $(\\xi,\\beta,\\mu,n,\\text{seed}) = (0.25, 1.40, 0.00, 120000, 1729)$\n    2. $(\\xi,\\beta,\\mu,n,\\text{seed}) = (0.00, 2.20, 0.50, 150000, 41041)$\n    3. $(\\xi,\\beta,\\mu,n,\\text{seed}) = (-0.35, 1.10, -0.30, 120000, 271828)$\n\n**步骤 2：验证问题陈述**\n根据所需标准对问题进行评估。\n- **科学依据**：该问题建立在极值理论和计算统计学的原理之上。GPD 是这些领域的标准模型。所有定义，包括 CDF 和统计指标，都是标准且正确的。\n- **适定性**：该问题是适定的。它要求实现一个基于伪随机数生成和指定种子的确定性算法。这确保了存在唯一且可验证的解。所有必要信息都已提供。\n- **客观性**：该问题以精确的数学和算法术语陈述，没有主观性或歧义。定义、测试案例和接受标准都得到了完整而清晰的规定。\n\n**步骤 3：结论与行动**\n该问题是有效的。它是一个定义明确的计算统计学练习，要求实现随机变量生成、分位数分析和统计验证。将提供完整的解决方案。\n\n**方法论**\n解决方案将基于逆变换采样法原理构建。对于一个具有 CDF $F(x)$ 的连续随机变量，其分位数函数为 $F^{-1}(p)$。如果 $U$ 是一个服从 $(0,1)$ 上标准均匀分布的随机变量，那么随机变量 $X = F^{-1}(U)$ 的 CDF 为 $F(x)$。\n\n首先，我们推导 GPD 的分位数函数 $F^{-1}(p)$。\n令 $p = F(x)$。我们求解 $x$。\n\n案例 1：$\\xi \\neq 0$\n$$ p = 1 - \\left(1 + \\xi \\frac{x-\\mu}{\\beta}\\right)^{-1/\\xi} $$\n$$ 1-p = \\left(1 + \\xi \\frac{x-\\mu}{\\beta}\\right)^{-1/\\xi} $$\n$$ (1-p)^{-\\xi} = 1 + \\xi \\frac{x-\\mu}{\\beta} $$\n$$ (1-p)^{-\\xi} - 1 = \\xi \\frac{x-\\mu}{\\beta} $$\n$$ x - \\mu = \\frac{\\beta}{\\xi} \\left( (1-p)^{-\\xi} - 1 \\right) $$\n因此，分位数函数为：\n$$ F^{-1}(p;\\xi,\\beta,\\mu) = \\mu + \\frac{\\beta}{\\xi} \\left( (1-p)^{-\\xi} - 1 \\right) $$\n\n案例 2：$\\xi = 0$\n这对应于尺度为 $\\beta$、位置为 $\\mu$ 的指数分布。\n$$ p = 1 - \\exp\\left(-\\frac{x-\\mu}{\\beta}\\right) $$\n$$ 1-p = \\exp\\left(-\\frac{x-\\mu}{\\beta}\\right) $$\n$$ \\ln(1-p) = -\\frac{x-\\mu}{\\beta} $$\n$$ x - \\mu = -\\beta \\ln(1-p) $$\n因此，分位数函数为：\n$$ F^{-1}(p;0,\\beta,\\mu) = \\mu - \\beta \\ln(1-p) $$\n\n对于每个测试案例，程序将按以下步骤进行：\n1.  为保证可复现性，设置随机数生成器种子。\n2.  从标准均匀分布 $U(0,1)$ 中生成大小为 $n$ 的样本。\n3.  根据 $\\xi$ 的值，使用上面推导出的适当的分位数函数将此样本转换为 GPD 样本。\n4.  构建概率网格 $\\mathcal{P}$ 和 $\\mathcal{P}_{\\text{central}}$。\n5.  将分位数函数应用于网格 $\\mathcal{P}$ 中的概率，计算理论分位数向量 $\\mathbf{Q}_{\\text{th}}$。\n6.  从生成的样本中计算同一网格 $\\mathcal{P}$ 的经验分位数向量 $\\mathbf{Q}_{\\text{emp}}$。所提供的 $Q_{\\text{emp}}(p)$ 公式对应于标准的线性插值方法，该方法在数值库中可用。\n7.  计算四个指定的指标：\n    a. $R^2$：计算为 $\\mathbf{Q}_{\\text{th}}$ 和 $\\mathbf{Q}_{\\text{emp}}$ 之间 Pearson 相关系数的平方。\n    b. $a, b$：通过对 $\\mathbf{Q}_{\\text{emp}}$ 关于 $\\mathbf{Q}_{\\text{th}}$ 进行普通最小二乘线性回归获得。\n    c. $\\Delta_{\\max}$：通过在中心网格 $\\mathcal{P}_{\\text{central}}$ 上找到经验分位数和理论分位数之间的最大绝对差，并用 $\\beta$ 进行归一化来计算。\n    d. 支撑集检查：对于 $\\xi < 0$，确认所有生成的随机变量都小于或等于支撑集的理论上界 $x_{\\max} = \\mu - \\beta/\\xi$。\n8.  最后，验证是否满足所有五个接受标准。每个测试案例的结果是一个布尔值。\n最终输出是将这些布尔结果汇总成指定的列表格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Validates GPD random variate generation against theoretical properties\n    for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (xi, beta, mu, n, seed)\n        (0.25, 1.40, 0.00, 120000, 1729),\n        (0.00, 2.20, 0.50, 150000, 41041),\n        (-0.35, 1.10, -0.30, 120000, 271828),\n    ]\n\n    results = []\n    \n    # Define probability grids\n    # P = {0.01, ..., 0.99}\n    p_grid = np.linspace(0.01, 0.99, 99)\n    # P_central = {0.05, ..., 0.95}\n    p_central = np.linspace(0.05, 0.95, 19)\n\n    def gpd_quantile(p, xi, beta, mu):\n        \"\"\"Computes the theoretical quantile for the GPD.\"\"\"\n        if xi == 0:\n            # Handle the case for xi = 0 (Exponential distribution)\n            return mu - beta * np.log(1 - p)\n        else:\n            # Handle the case for xi != 0\n            # Expression ( (1-p)**(-xi) - 1 ) / xi can be written using expm1 for numerical stability\n            # for small xi, as expm1(y)/y -> 1 as y->0.\n            # Here y = -xi * log(1-p).\n            return mu + beta * (np.power(1 - p, -xi) - 1) / xi\n\n    for case in test_cases:\n        xi, beta, mu, n, seed = case\n        \n        # 1. Generate random variates using inverse transform sampling\n        np.random.seed(seed)\n        uniform_samples = np.random.uniform(size=n)\n        gpd_samples = gpd_quantile(uniform_samples, xi, beta, mu)\n\n        # 2. Compute theoretical and empirical quantiles\n        q_th = gpd_quantile(p_grid, xi, beta, mu)\n        q_emp = np.quantile(gpd_samples, p_grid, method='linear')\n\n        # 3. Calculate metrics and perform checks\n        \n        # Metric 1: R^2\n        pearson_r, _ = stats.pearsonr(q_th, q_emp)\n        r_squared = pearson_r**2\n        check1 = r_squared >= 0.9995\n\n        # Metric 2: OLS slope and intercept\n        lin_reg = stats.linregress(x=q_th, y=q_emp)\n        b, a = lin_reg.slope, lin_reg.intercept\n        check2 = abs(b - 1) <= 0.02\n        check3 = abs(a) <= 0.05 * beta\n\n        # Metric 3: Maximum absolute deviation on the central grid\n        q_th_central = gpd_quantile(p_central, xi, beta, mu)\n        q_emp_central = np.quantile(gpd_samples, p_central, method='linear')\n        delta_max = np.max(np.abs(q_emp_central - q_th_central)) / beta\n        check4 = delta_max <= 0.12\n\n        # Metric 4: Support upper endpoint check\n        if xi < 0:\n            support_upper_bound = mu - beta / xi\n            check5 = np.max(gpd_samples) <= support_upper_bound\n        else:\n            # For xi >= 0, the support is unbounded above, so the check is satisfied\n            check5 = True\n\n        # Combine all checks\n        all_criteria_met = all([check1, check2, check3, check4, check5])\n        results.append(all_criteria_met)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2397442"}, {"introduction": "广义帕累托分布的一个关键应用是检验现实世界的数据是否偏离了基准模型。本练习模拟了一个常见场景：检验一个过程（例如比特币区块的发现间隔时间）的极端事件是否遵循简单的指数分布，这对应于 GPD 的形状参数 $\\xi = 0$ 的特殊情况。你将通过实现似然比检验（Likelihood-Ratio Test）来对 $\\xi$ 进行假设检验，从而掌握一种判断数据尾部行为是“轻”还是“重”的标准化统计方法 [@problem_id:2397475]。", "problem": "要求您设计并实现一个程序，该程序针对代表比特币（Bitcoin）区块发现的间隔时间（inter-arrival times）合成样本，通过拟合广义帕累托分布（Generalized Pareto Distribution, GPD）并检验GPD形状参数是否为零，来评估高阈值下的超额分布是否与指数模型一致。该场景依赖于以下基本建模基础：在一个强度恒定的齐次泊松过程中，间隔时间服从指数分布；对于一个足够高的阈值，超出该阈值的超额量（exceedances）的分布可以用广义帕累托分布（GPD）来建模。指数分布的情况对应于形状参数为零的GPD。您必须基于此推导出适当的基于似然的推断。\n\n每个测试用例需要实现的任务：\n- 根据指定的数据生成过程，生成一个大小为 $n$ 的非负间隔时间的独立同分布样本。两种可能的数据生成过程是：\n  - 均值为 $m$ 的指数分布。\n  - 形状参数为 $\\xi$、尺度参数为 $\\beta$ 的广义帕累托分布（GPD）。\n- 计算经验阈值 $u$ 作为样本的 $q$-分位数，其中 $q \\in (0,1)$ 是给定的。\n- 构建超额量 $Y = \\{X_i - u : X_i > u\\}$。\n- 通过最大似然估计（Maximum Likelihood Estimation, MLE）将GPD拟合到 $Y$，其中位置参数固定为零，并记录估计出的形状参数 $\\hat{\\xi}$。\n- 使用似然比检验（Likelihood-Ratio Test, LRT），在显著性水平 $\\alpha$ 下，检验原假设 $H_0\\!:\\, \\xi = 0$ 与双边备择假设 $H_1\\!:\\, \\xi \\neq 0$。从自由度为1的渐近卡方分布中计算p值（p-value）。\n- 每个测试用例生成一个三元组 $[\\hat{\\xi}, \\text{p\\_value}, \\text{reject}]$，其中 $\\hat{\\xi}$ 和 $\\text{p\\_value}$ 是浮点数，$\\text{reject}$ 是一个布尔值，如果原假设在水平 $\\alpha$ 下被拒绝，则为真，否则为假。\n\n重要的实现和输出细节：\n- 您的代码必须是完全确定性的。使用给定的种子来初始化随机数生成器，并可复现地抽取所有随机样本。\n- 单位：在合成数据中，间隔时间可以解释为以秒为单位，但您不需要报告任何带单位的量。所有要求的输出都是无量纲的。\n- 最终输出必须是单行，包含一个列表的列表，每个测试用例一个，每个内部列表的形式为 $[\\hat{\\xi}, \\text{p\\_value}, \\text{reject}]$。整个输出必须精确地打印为单个Python风格的列表字面量，例如 `[[x_1, p_1, \\text{True}], [x_2, p_2, \\text{False}], \\ldots]`。在打印输出中，将浮点数 $\\hat{\\xi}$ 和 $\\text{p\\_value}$ 四舍五入到 $6$ 位小数。\n\n需要实现和评估的测试套件：\n- 案例 1：种子 = 12345，分布 = 均值为 $m = 600$ 的指数分布，样本大小 $n = 5000$，阈值分位数 $q = 0.80$，显著性水平 $\\alpha = 0.05$。\n- 案例 2：种子 = 54321，分布 = $\\xi = 0.25$ 且 $\\beta = 600$ 的GPD，样本大小 $n = 5000$，阈值分位数 $q = 0.80$，显著性水平 $\\alpha = 0.05$。\n- 案例 3：种子 = 20231105，分布 = $\\xi = 0.05$ 且 $\\beta = 600$ 的GPD，样本大小 $n = 6000$，阈值分位数 $q = 0.85$，显著性水平 $\\alpha = 0.05$。\n- 案例 4：种子 = 314159，分布 = 均值为 $m = 600$ 的指数分布，样本大小 $n = 3000$，阈值分位数 $q = 0.98$，显著性水平 $\\alpha = 0.05$。\n\n您的程序应生成一行输出，其中包含按上述四个案例顺序排列的结果，形式为Python风格的列表的列表，例如：\n$[[\\hat{\\xi}_1,\\text{p\\_value}_1,\\text{reject}_1],[\\hat{\\xi}_2,\\text{p\\_value}_2,\\text{reject}_2],[\\hat{\\xi}_3,\\text{p\\_value}_3,\\text{reject}_3],[\\hat{\\xi}_4,\\text{p\\_value}_4,\\text{reject}_4]]$。", "solution": "该问题要求实现一个统计流程，以验证一组间隔时间数据集是否与指数分布一致。该方法论植根于极值理论（Extreme Value Theory, EVT），特别是超阈值峰值（Peaks-Over-Threshold, POT）方法。其核心原则是，对于广义的随机变量，超过一个足够高阈值的数值的分布可以用广义帕累托分布（Generalized Pareto Distribution, GPD）来近似。GPD的一个特例，即形状参数 $\\xi$ 等于零时，对应于指数分布。我们将利用这一事实来构建假设检验。\n\n每个测试用例的流程如下：\n$1$. 根据指定参数生成间隔时间的合成样本。\n$2$. 通过经验方法，将样本的一个分位数确定为高阈值 $u$。\n$3$. 收集超过该阈值的超额量 $Y = X_i - u$。\n$4$. 使用最大似然估计（Maximum Likelihood Estimation, MLE）将GPD拟合到这些超额量上。\n$5$. 进行似然比检验（Likelihood-Ratio Test, LRT）以检验原假设 $H_0: \\xi = 0$ 与备择假设 $H_1: \\xi \\neq 0$。\n\n我们首先建立理论基础。\n\n**1. 广义帕累托分布（GPD）**\nGPD是一个双参数分布族，用于对其他分布的尾部进行建模。在位置参数固定为零的情况下，其概率密度函数（PDF）$f(y; \\xi, \\beta)$ 对于观测值 $y$ 由下式给出：\n$$\nf(y; \\xi, \\beta) =\n\\begin{cases}\n\\frac{1}{\\beta} \\left(1 + \\frac{\\xi y}{\\beta}\\right)^{-\\frac{1}{\\xi}-1} & \\text{if } \\xi \\neq 0 \\\\\n\\frac{1}{\\beta} \\exp\\left(-\\frac{y}{\\beta}\\right) & \\text{if } \\xi = 0\n\\end{cases}\n$$\n其中 $\\xi$ 是形状参数，$\\beta > 0$ 是尺度参数。当 $\\xi \\ge 0$ 时，其支撑集为 $y \\ge 0$；当 $\\xi < 0$ 时，其支撑集为 $0 \\le y \\le -\\beta/\\xi$。$\\xi=0$ 的情况恰好是均值为 $\\beta$ 的指数分布。这种关系是我们检验的基石。\n\n**2. 最大似然估计（MLE）**\n给定一个包含 $N_u$ 个超额量的样本 $Y = \\{y_1, y_2, \\dots, y_{N_u}\\}$，其对数似然函数 $\\ell(\\xi, \\beta | Y)$ 是每个观测值的对数概率密度函数之和：\n$$ \\ell(\\xi, \\beta | Y) = \\sum_{i=1}^{N_u} \\ln f(y_i; \\xi, \\beta) $$\n对于 $\\xi \\neq 0$，该函数为：\n$$ \\ell(\\xi, \\beta) = -N_u \\ln \\beta - \\left(\\frac{1}{\\xi} + 1\\right) \\sum_{i=1}^{N_u} \\ln\\left(1 + \\frac{\\xi y_i}{\\beta}\\right) $$\n最大似然估计值 $(\\hat{\\xi}, \\hat{\\beta})$ 是使该函数最大化的参数值。这是一个数值优化问题，我们将使用计算库来解决。\n\n**3. 似然比检验（LRT）**\n我们希望检验原假设 $H_0: \\xi = 0$ 与双边备择假设 $H_1: \\xi \\neq 0$。LRT统计量 $\\Lambda$ 定义为无约束模型的最大对数似然与受原假设约束的模型的最大对数似然之差的两倍：\n$$ \\Lambda = 2 \\left( \\sup_{\\xi, \\beta} \\ell(\\xi, \\beta | Y) - \\sup_{\\beta} \\ell(0, \\beta | Y) \\right) $$\n第一项 $\\sup_{\\xi, \\beta} \\ell(\\xi, \\beta | Y) = \\ell(\\hat{\\xi}, \\hat{\\beta} | Y)$ 是在无约束MLE $(\\hat{\\xi}, \\hat{\\beta})$ 处计算的对数似然。\n\n第二项 $\\sup_{\\beta} \\ell(0, \\beta | Y)$ 是在 $H_0$ 条件下模型的对数似然，此时 $\\xi=0$。这是一个指数模型。其对数似然为：\n$$ \\ell(0, \\beta | Y) = -N_u \\ln \\beta - \\frac{1}{\\beta} \\sum_{i=1}^{N_u} y_i $$\n在 $H_0$ 下，$\\beta$ 的MLE（记为 $\\hat{\\beta}_0$）可通过将其关于 $\\beta$ 的导数设为零得到，结果是超额量的样本均值：\n$$ \\hat{\\beta}_0 = \\frac{1}{N_u} \\sum_{i=1}^{N_u} y_i = \\bar{y} $$\n因此，受约束的最大对数似然为 $\\ell(0, \\hat{\\beta}_0 | Y)$。\n\n根据 Wilks 定理，在原假设下，LRT统计量 $\\Lambda$ 渐近服从卡方分布，其自由度等于在 $H_0$ 下被固定的参数数量。在我们的案例中，一个参数（$\\xi$）被固定，所以 $\\Lambda \\sim \\chi^2_1$。\n\n检验的p值是在假设 $H_0$ 为真的情况下，观测到至少与计算出的检验统计量一样极端的统计量的概率：\n$$ \\text{p-value} = P(\\chi^2_1 \\ge \\Lambda) $$\n如果p值小于指定的显著性水平 $\\alpha$，我们拒绝原假设 $H_0$，并得出结论：数据与指数尾部模型不一致。\n\n**算法与实现**\n\n每个测试用例的计算流程如下：\n$1$. **可复现性**：为确保结果的确定性，为每个案例使用指定的种子初始化一个随机数生成器。我们使用 `numpy.random.default_rng`。\n$2$. **数据生成**：\n   - 对于均值为 $m$ 的指数分布，我们使用 `rng.exponential(scale=m, size=n)` 生成 $n$ 个样本。\n   - 对于形状为 $\\xi$、尺度为 $\\beta$ 的GPD，我们使用 `scipy.stats.genpareto.rvs(c=xi, scale=beta, size=n, random_state=rng)` 生成 $n$ 个样本。\n$3$. **阈值处理**：使用 `numpy.quantile` 将生成样本 $X$ 的第 $q$-分位数计算为经验阈值 $u$。然后，通过取所有大于 $u$ 的 $X_i$ 并减去阈值，形成超额样本 $Y=\\{X_i - u | X_i > u\\}$。\n$4$. **无约束MLE**：通过数值最大化对数似然函数来估计GPD参数 $(\\hat{\\xi}, \\hat{\\beta})$。我们使用 `scipy.stats.genpareto.fit(Y, floc=0)` 来执行此操作，将位置参数固定为 $0$。这会得到无约束估计值 $\\hat{\\xi}$ 和 $\\hat{\\beta}$。\n$5$. **约束MLE**：在 $H_0: \\xi=0$ 的条件下，分布是指数分布。尺度参数的MLE，即 $\\hat{\\beta}_0$，是 $Y$ 的样本均值，通过 `numpy.mean(Y)` 计算。\n$6$. **LRT计算**：\n   - 使用估计的参数计算无约束对数似然 $\\ell(\\hat{\\xi}, \\hat{\\beta})$：$\\sum \\ln f(y_i; \\hat{\\xi}, \\hat{\\beta})$。\n   - 类似地计算约束对数似然 $\\ell(0, \\hat{\\beta}_0)$：$\\sum \\ln f(y_i; 0, \\hat{\\beta}_0)$。\n   - 检验统计量为 $\\Lambda = 2(\\ell(\\hat{\\xi}, \\hat{\\beta}) - \\ell(0, \\hat{\\beta}_0))$。为处理可能导致小的负值的数值不精确问题，我们取 $\\max(0, \\Lambda)$。\n$7$. **P值与决策**：P值由 $\\chi^2_1$ 分布的生存函数 `scipy.stats.chi2.sf(\\Lambda, df=1)` 计算得出。如果 $\\text{p-value} < \\alpha$，则拒绝原假设。\n$8$. **输出格式化**：收集每个案例产生的三元组 $[\\hat{\\xi}, \\text{p-value}, \\text{reject}]$。浮点值被格式化为 $6$ 位小数，并按要求组装成最终的字符串表示形式。\n\n这种严谨的、由理论驱动的方法确保了对所述问题给出一个正确且可复现的解决方案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and produce the final output.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'case_id': 1, 'seed': 12345, 'dist': 'exponential', 'params': {'m': 600}, 'n': 5000, 'q': 0.80, 'alpha': 0.05},\n        {'case_id': 2, 'seed': 54321, 'dist': 'gpd', 'params': {'xi': 0.25, 'beta': 600}, 'n': 5000, 'q': 0.80, 'alpha': 0.05},\n        {'case_id': 3, 'seed': 20231105, 'dist': 'gpd', 'params': {'xi': 0.05, 'beta': 600}, 'n': 6000, 'q': 0.85, 'alpha': 0.05},\n        {'case_id': 4, 'seed': 314159, 'dist': 'exponential', 'params': {'m': 600}, 'n': 3000, 'q': 0.98, 'alpha': 0.05},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Step 1: Initialize RNG for reproducibility\n        rng = np.random.default_rng(case['seed'])\n\n        # Step 2: Generate sample data\n        if case['dist'] == 'exponential':\n            m = case['params']['m']\n            sample_X = rng.exponential(scale=m, size=case['n'])\n        elif case['dist'] == 'gpd':\n            xi, beta = case['params']['xi'], case['params']['beta']\n            # Use scipy's GPD generator, passing the numpy RNG\n            sample_X = stats.genpareto.rvs(c=xi, scale=beta, size=case['n'], random_state=rng)\n\n        # Step 3: Compute threshold and form exceedances\n        u = np.quantile(sample_X, case['q'])\n        exceedances = sample_X[sample_X > u]\n        sample_Y = exceedances - u\n        \n        # Guard against cases with no exceedances\n        if len(sample_Y) == 0:\n            results.append([float('nan'), float('nan'), False])\n            continue\n            \n        # Step 4: Fit GPD to Y (unrestricted model)\n        # floc=0 fixes the location parameter to 0\n        xi_hat, _, beta_hat = stats.genpareto.fit(sample_Y, floc=0)\n\n        # Step 5: Calculate unrestricted log-likelihood\n        log_lik_unrestricted = np.sum(stats.genpareto.logpdf(sample_Y, c=xi_hat, scale=beta_hat, loc=0))\n\n        # Step 6: Fit GPD under H0: xi=0 (restricted model - exponential)\n        # For exponential dist, the MLE of scale is the mean\n        beta_hat_h0 = np.mean(sample_Y)\n        \n        # Step 7: Calculate restricted log-likelihood\n        # GPD with c=0 is exponential\n        log_lik_restricted = np.sum(stats.genpareto.logpdf(sample_Y, c=0, scale=beta_hat_h0, loc=0))\n\n        # Step 8: Compute the Likelihood-Ratio Test statistic\n        lrt_statistic = 2 * (log_lik_unrestricted - log_lik_restricted)\n        # LRT statistic must be non-negative. Small negative values can arise from numerical precision issues.\n        lrt_statistic = max(0, lrt_statistic)\n\n        # Step 9: Compute p-value from chi-square distribution with 1 dof\n        p_value = stats.chi2.sf(lrt_statistic, df=1)\n\n        # Step 10: Decide whether to reject H0\n        reject_h0 = p_value < case['alpha']\n\n        results.append([xi_hat, p_value, reject_h0])\n\n    # Final print statement in the exact required format.\n    # Format each inner list into a string, then join them.\n    formatted_results = []\n    for res in results:\n        xi_str = f\"{res[0]:.6f}\"\n        pval_str = f\"{res[1]:.6f}\"\n        reject_str = str(res[2]) # Converts True to 'True', False to 'False'\n        formatted_results.append(f\"[{xi_str},{pval_str},{reject_str}]\")\n        \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2397475"}, {"introduction": "在风险管理中，模型选择的后果可能非常严重。本练习通过一个思想实验，量化了错误设定尾部分布模型所带来的风险：当真实的尾部是重尾（Fréchet 类型，$\\xi \\gt 0$）时，分析师却错误地假设其为指数型尾部（Gumbel 类型，$\\xi = 0$）。通过计算真实与错误模型下的预期短缺（Expected Shortfall），你将深刻理解为何准确估计 GPD 的形状参数 $\\xi$ 对避免低估极端风险至关重要 [@problem_id:2391806]。", "problem": "一位风险管理者使用超阈值峰值 (Peaks-Over-Threshold) 框架对投资组合损失的超出额进行建模。令投资组合损失为一个随机变量 $L$，并令 $u$ 为一个固定的阈值。定义在 $L>u$ 条件下的超出额为 $Y=L-u$。假设在 $L>u$ 的条件下，超出额 $Y$ 服从形状参数为 $\\xi$、尺度参数为 $\\beta>0$ 的广义帕累托分布 (Generalized Pareto Distribution, GPD)。$Y$ 的累积分布函数为\n$$F_Y(y)=1-\\left(1+\\frac{\\xi y}{\\beta}\\right)^{-1/\\xi}\\quad\\text{对于 }\\xi\\neq 0,\\ y\\ge 0,\\ 1+\\frac{\\xi y}{\\beta}>0,$$\n及\n$$F_Y(y)=1-\\exp\\left(-\\frac{y}{\\beta}\\right)\\quad\\text{对于 }\\xi=0,\\ y\\ge 0.$$\n令 $p_u=\\mathbb{P}(L>u)$ 表示超出概率。对于一个无条件概率水平 $\\alpha\\in(0,1)$ 且满足 $\\alpha>1-p_u$，定义水平为 $\\alpha$ 的无条件风险价值 (Value at Risk, VaR) 为 $\\mathrm{VaR}_\\alpha$，即 $L$ 的 $\\alpha$-分位数。定义水平为 $\\alpha$ 的期望亏损 (Expected Shortfall, ES) 为 $\\mathrm{ES}_\\alpha=\\mathbb{E}[L\\mid L>\\mathrm{VaR}_\\alpha]$，当其有限时。\n\n假设真实的尾部分布为弗雷歇型 (Fréchet-type)，其 $\\xi=\\xi_{\\text{true}}>0$ 且 $\\xi_{\\text{true}}<1$（因此 $\\mathrm{ES}_\\alpha$ 是有限的），但一位分析师将尾部误设为 Gumbel 型，强制设定 $\\xi=0$，同时使用相同的 $u$、$p_u$ 和 $\\beta$。\n\n对于下方的每个测试用例，计算误设比率\n$$R=\\frac{\\mathrm{ES}_\\alpha^{\\text{mis}}}{\\mathrm{ES}_\\alpha^{\\text{true}}},$$\n其中 $\\mathrm{ES}_\\alpha^{\\text{true}}$ 是在真实 $\\xi_{\\text{true}}>0$ 下计算的，而 $\\mathrm{ES}_\\alpha^{\\text{mis}}$ 是在误设的 $\\xi=0$ 下计算的，两者都使用相同的 $u$、$p_u$ 和 $\\beta$。所有计算都应遵循上述定义以及广义帕累托分布和条件超出额的标准性质。将每个 $R$ 表示为保留 $6$ 位小数的十进制数。\n\n测试集（每个元组为 $(u,p_u,\\beta,\\xi_{\\text{true}},\\alpha)$）：\n- 用例 1：$(1.0,0.05,1.5,0.3,0.99)$\n- 用例 2：$(1.0,0.10,0.7,0.05,0.98)$\n- 用例 3：$(0.5,0.02,1.0,0.9,0.999)$\n- 用例 4：$(2.0,0.01,0.8,0.4,0.995)$\n\n您的程序必须生成单行输出，其中包含所有用例的结果，结果为逗号分隔的列表，用方括号括起，并与测试集的顺序相同（例如 $[r_1,r_2,r_3,r_4]$），每个 $r_i$ 保留 $6$ 位小数。", "solution": "该问题要求计算期望亏损 (Expected Shortfall, ES) 风险度量的误设比率。这是量化风险管理中的一个标准问题，需要严格应用极值理论 (Extreme Value Theory, EVT) 的定义。我们将首先验证问题陈述，然后着手推导必要的公式。\n\n验证步骤确认该问题在科学上是合理的、适定的且客观的。\n按要求逐字提取已知条件：\n- 投资组合损失是一个随机变量 $L$。\n- 阈值为 $u$。\n- 超出额为 $Y=L-u$，条件为 $L>u$。\n- $Y$ 的分布是广义帕累托分布 (GPD)，形状参数为 $\\xi$，尺度参数为 $\\beta>0$。\n- 当 $\\xi\\neq 0$ 时，$Y$ 的累积分布函数为：$F_Y(y)=1-\\left(1+\\frac{\\xi y}{\\beta}\\right)^{-1/\\xi}$。\n- 当 $\\xi=0$ 时，$Y$ 的累积分布函数为：$F_Y(y)=1-\\exp\\left(-\\frac{y}{\\beta}\\right)$。\n- 超出概率为 $p_u=\\mathbb{P}(L>u)$。\n- 风险价值为 $\\mathrm{VaR}_\\alpha$，即 $L$ 的 $\\alpha$-分位数，其中 $\\alpha \\in (0,1)$ 且 $\\alpha > 1-p_u$。\n- 期望亏损为 $\\mathrm{ES}_\\alpha=\\mathbb{E}[L\\mid L>\\mathrm{VaR}_\\alpha]$。\n- 真实模型具有弗雷歇型尾部，其 $\\xi=\\xi_{\\text{true}} \\in (0,1)$。\n- 误设模型具有 Gumbel 型尾部，其 $\\xi=0$。\n- 参数 $u$、$p_u$ 和 $\\beta$ 是不变的。\n- 任务是计算比率 $R=\\frac{\\mathrm{ES}_\\alpha^{\\text{mis}}}{\\mathrm{ES}_\\alpha^{\\text{true}}}$。\n\n该问题是有效的。它是超阈值峰值 (Peaks-Over-Threshold, POT) 方法的一个标准应用，建立在公认的数学和统计原理之上。所有定义和条件都是标准的、完整的且一致的。条件 $\\alpha > 1-p_u$ 确保了 $\\mathrm{VaR}_\\alpha > u$，从而将分位数置于由 GPD 建模的尾部区域。条件 $\\xi_{\\text{true}} < 1$ 确保了 GPD 的一阶矩，即期望亏损，是有限的。我们开始求解。\n\n推导过程分三个阶段：首先，我们推导 $\\mathrm{VaR}_\\alpha$ 的通用表达式；其次，我们推导 $\\mathrm{ES}_\\alpha$ 的通用表达式；第三，我们将这些表达式应用于真实模型和误设模型，并构造比率。\n\n**1. 风险价值 ($\\mathrm{VaR}_\\alpha$) 的推导**\n\nPOT 模型将 $L$ 的无条件尾部与超出额 $Y$ 的条件分布联系起来。对于任何损失水平 $l > u$， $L$ 的尾部概率由下式给出：\n$$ \\mathbb{P}(L > l) = \\mathbb{P}(L > l \\mid L > u) \\cdot \\mathbb{P}(L > u) $$\n这可以用超出额 $Y = L - u$ 及其生存函数 $S_Y(y) = 1 - F_Y(y)$ 来表示：\n$$ \\mathbb{P}(L > l) = \\mathbb{P}(Y > l - u) \\cdot p_u = S_Y(l-u) \\cdot p_u $$\n根据定义，$\\mathrm{VaR}_\\alpha$ 是满足 $\\mathbb{P}(L > \\mathrm{VaR}_\\alpha) = 1-\\alpha$ 的值。我们有：\n$$ 1-\\alpha = S_Y(\\mathrm{VaR}_\\alpha - u) \\cdot p_u $$\n$$ S_Y(\\mathrm{VaR}_\\alpha - u) = \\frac{1-\\alpha}{p_u} $$\n令 $y_\\alpha = \\mathrm{VaR}_\\alpha - u$。值 $y_\\alpha$ 是 GPD 对应于概率 $q = 1 - \\frac{1-\\alpha}{p_u}$ 的分位数。GPD 的反累积分布函数（分位数函数）$F_Y^{-1}(q) = y$ 为：\n$$ y = \\begin{cases} \\frac{\\beta}{\\xi}\\left((1-q)^{-\\xi} - 1\\right) & \\text{若 } \\xi \\neq 0 \\\\ -\\beta \\ln(1-q) & \\text{若 } \\xi = 0 \\end{cases} $$\n代入 $1-q = \\frac{1-\\alpha}{p_u}$ 得到 $y_\\alpha$ 的表达式：\n$$ y_\\alpha = \\begin{cases} \\frac{\\beta}{\\xi}\\left(\\left(\\frac{1-\\alpha}{p_u}\\right)^{-\\xi} - 1\\right) = \\frac{\\beta}{\\xi}\\left(\\left(\\frac{p_u}{1-\\alpha}\\right)^{\\xi} - 1\\right) & \\text{若 } \\xi \\neq 0 \\\\ -\\beta \\ln\\left(\\frac{1-\\alpha}{p_u}\\right) = \\beta \\ln\\left(\\frac{p_u}{1-\\alpha}\\right) & \\text{若 } \\xi = 0 \\end{cases} $$\n最后，由于 $\\mathrm{VaR}_\\alpha = u + y_\\alpha$，我们得到了 $\\mathrm{VaR}_\\alpha$ 的公式。\n\n**2. 期望亏损 ($\\mathrm{ES}_\\alpha$) 的推导**\n\n$\\mathrm{ES}_\\alpha$ 定义为条件期望 $\\mathbb{E}[L \\mid L > \\mathrm{VaR}_\\alpha]$。由于 $\\mathrm{VaR}_\\alpha > u$，条件 $L > \\mathrm{VaR}_\\alpha$ 意味着 $L > u$。因此，我们可以将 $L$ 表示为 $u+Y$：\n$$ \\mathrm{ES}_\\alpha = \\mathbb{E}[u+Y \\mid u+Y > \\mathrm{VaR}_\\alpha] = u + \\mathbb{E}[Y \\mid Y > \\mathrm{VaR}_\\alpha - u] = u + \\mathbb{E}[Y \\mid Y > y_\\alpha]$$\n条件期望 $\\mathbb{E}[Y \\mid Y > y_\\alpha]$ 可以使用 GPD 的平均超额函数 $e(z) = \\mathbb{E}[Y-z \\mid Y > z]$ 来表示。\n$$ \\mathbb{E}[Y \\mid Y > y_\\alpha] = y_\\alpha + \\mathbb{E}[Y-y_\\alpha \\mid Y > y_\\alpha] = y_\\alpha + e(y_\\alpha) $$\n因此，$\\mathrm{ES}_\\alpha = u + y_\\alpha + e(y_\\alpha) = \\mathrm{VaR}_\\alpha + e(\\mathrm{VaR}_\\alpha - u)$。对于 $\\xi < 1$ 的 GPD，其平均超额函数为：\n$$ e(z) = \\frac{\\beta + \\xi z}{1-\\xi} $$\n对于 $\\xi=0$ 的特殊情况（指数分布），该式简化为 $e(z) = \\beta$，这与无记忆性相符。\n将其代入 $\\mathrm{ES}_\\alpha$ 的表达式中：\n$$ \\mathrm{ES}_\\alpha = \\mathrm{VaR}_\\alpha + \\frac{\\beta + \\xi(\\mathrm{VaR}_\\alpha - u)}{1-\\xi} $$\n通过代入已推导出的 $\\mathrm{VaR}_\\alpha - u = y_\\alpha$ 的形式，可以获得一个简化表达式：\n$$ \\mathrm{ES}_\\alpha = \\mathrm{VaR}_\\alpha + \\frac{\\beta + \\xi y_\\alpha}{1-\\xi} $$\n\n**3. 真实模型和误设模型的具体化**\n\n我们现在将这些通用公式应用于这两种场景。令 $Z = \\frac{p_u}{1-\\alpha}$。\n\n_真实模型：_ $\\xi = \\xi_{\\text{true}} \\in (0, 1)$\n$$ \\mathrm{VaR}_\\alpha^{\\text{true}} = u + \\frac{\\beta}{\\xi_{\\text{true}}}\\left(Z^{\\xi_{\\text{true}}} - 1\\right) $$\n$$ \\mathrm{ES}_\\alpha^{\\text{true}} = \\mathrm{VaR}_\\alpha^{\\text{true}} + \\frac{\\beta + \\xi_{\\text{true}}(\\mathrm{VaR}_\\alpha^{\\text{true}} - u)}{1-\\xi_{\\text{true}}} $$\n代入 $\\mathrm{VaR}_\\alpha^{\\text{true}} - u$：\n$$ \\mathrm{ES}_\\alpha^{\\text{true}} = \\mathrm{VaR}_\\alpha^{\\text{true}} + \\frac{\\beta + \\xi_{\\text{true}}\\left(\\frac{\\beta}{\\xi_{\\text{true}}}\\left(Z^{\\xi_{\\text{true}}} - 1\\right)\\right)}{1-\\xi_{\\text{true}}} = \\mathrm{VaR}_\\alpha^{\\text{true}} + \\frac{\\beta + \\beta(Z^{\\xi_{\\text{true}}} - 1)}{1-\\xi_{\\text{true}}} = \\mathrm{VaR}_\\alpha^{\\text{true}} + \\frac{\\beta Z^{\\xi_{\\text{true}}}}{1-\\xi_{\\text{true}}} $$\n\n_误设模型：_ $\\xi = 0$\n$$ \\mathrm{VaR}_\\alpha^{\\text{mis}} = u + \\beta \\ln(Z) $$\n$$ \\mathrm{ES}_\\alpha^{\\text{mis}} = \\mathrm{VaR}_\\alpha^{\\text{mis}} + \\frac{\\beta + 0 \\cdot (\\mathrm{VaR}_\\alpha^{\\text{mis}} - u)}{1-0} = \\mathrm{VaR}_\\alpha^{\\text{mis}} + \\beta $$\n\n因此，误设比率 $R$ 为：\n$$ R = \\frac{\\mathrm{ES}_\\alpha^{\\text{mis}}}{\\mathrm{ES}_\\alpha^{\\text{true}}} = \\frac{u + \\beta \\ln\\left(\\frac{p_u}{1-\\alpha}\\right) + \\beta}{u + \\frac{\\beta}{\\xi_{\\text{true}}}\\left(\\left(\\frac{p_u}{1-\\alpha}\\right)^{\\xi_{\\text{true}}} - 1\\right) + \\frac{\\beta \\left(\\frac{p_u}{1-\\alpha}\\right)^{\\xi_{\\text{true}}}}{1-\\xi_{\\text{true}}}} $$\n这些公式被用来实现并计算每个测试用例所需的比率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the misspecification ratio R = ES_mis / ES_true for several test cases.\n    \"\"\"\n    # Test cases: (u, p_u, beta, xi_true, alpha)\n    test_cases = [\n        (1.0, 0.05, 1.5, 0.3, 0.99),\n        (1.0, 0.10, 0.7, 0.05, 0.98),\n        (0.5, 0.02, 1.0, 0.9, 0.999),\n        (2.0, 0.01, 0.8, 0.4, 0.995)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        u, p_u, beta, xi_true, alpha = case\n        \n        # Helper term Z\n        z_factor = p_u / (1 - alpha)\n\n        # --- True Model Calculation (xi = xi_true > 0) ---\n        \n        # Power term for true model\n        z_pow_xi = np.power(z_factor, xi_true)\n        \n        # VaR_true\n        var_true = u + (beta / xi_true) * (z_pow_xi - 1)\n        \n        # ES_true\n        # The formula derived is ES_true = VaR_true + (beta * Z^xi_true) / (1 - xi_true)\n        es_true = var_true + (beta * z_pow_xi) / (1 - xi_true)\n\n        # --- Misspecified Model Calculation (xi = 0) ---\n        \n        # VaR_mis\n        # The formula is VaR_mis = u + beta * log(Z)\n        var_mis = u + beta * np.log(z_factor)\n\n        # ES_mis\n        # The formula is ES_mis = VaR_mis + beta\n        es_mis = var_mis + beta\n        \n        # --- Ratio Calculation ---\n        ratio = es_mis / es_true\n        results.append(f\"{ratio:.6f}\") # Format to 6 decimal places\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2391806"}]}