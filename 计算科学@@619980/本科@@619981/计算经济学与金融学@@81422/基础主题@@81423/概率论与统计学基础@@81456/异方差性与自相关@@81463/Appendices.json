{"hands_on_practices": [{"introduction": "理解预测的不确定性如何随时间演变，是任何预测建模的基础。本练习将通过一个简单的自回归 ($AR(1)$) 过程，深入探讨预测不确定性的期限结构。通过推导$h$步预测误差方差的解析表达式，你将亲眼见证预测误差是如何随着预测期$h$的增加而增长，并最终收敛到时间序列的长期无条件方差，从而深刻理解平稳性的含义和预测能力的极限。[@problem_id:2399435]", "problem": "考虑一个标量时间序列 $\\{y_{t}\\}$ 的平稳一阶自回归 (AR) 过程，记为 $AR(1)$，其定义如下：\n$$\ny_{t}=\\mu+\\phi\\left(y_{t-1}-\\mu\\right)+\\epsilon_{t},\n$$\n其中 $|\\phi|<1$，$\\mu$ 是一个常数，且 $\\{\\epsilon_{t}\\}$ 是一个独立同分布 (i.i.d.) 的新息序列，满足 $\\mathbb{E}[\\epsilon_{t}]=0$ 和 $\\operatorname{Var}(\\epsilon_{t})=\\sigma_{\\epsilon}^{2}$，并且独立于过去的信息 $\\mathcal{F}_{t-1}$。对于任意整数 $h\\geq 1$，令在时刻 $t$ 的 $h$ 步最小均方误差预测为 $\\hat{y}_{t+h|t}=\\mathbb{E}[y_{t+h}\\mid \\mathcal{F}_{t}]$。\n\n请仅使用模型定义以及条件期望和方差的性质，推导 $h$ 步预测误差方差\n$$\n\\operatorname{Var}\\!\\left(y_{t+h}-\\hat{y}_{t+h|t}\\mid \\mathcal{F}_{t}\\right)\n$$\n的精确解析表达式（作为 $\\phi$、$\\sigma_{\\epsilon}^{2}$ 和 $h$ 的函数），并证明当 $h\\to\\infty$ 时，它收敛于平稳条件下 $y_{t}$ 的无条件方差。\n\n答案要求：\n- 以 $\\phi$、$\\sigma_{\\epsilon}^{2}$ 和 $h$ 表示 $\\operatorname{Var}\\!\\left(y_{t+h}-\\hat{y}_{t+h|t}\\mid \\mathcal{F}_{t}\\right)$，并将其作为单一的封闭形式解析表达式提供最终答案。\n- 无需数值近似。\n- 最终表达式中不包含单位。", "solution": "定义均值偏差过程 $x_{t}\\equiv y_{t}-\\mu$。$AR(1)$ 模型可以写为\n$$\nx_{t}=\\phi x_{t-1}+\\epsilon_{t},\n$$\n其中 $|\\phi|<1$ 且 $\\mathbb{E}[\\epsilon_{t}]=0$, $\\operatorname{Var}(\\epsilon_{t})=\\sigma_{\\epsilon}^{2}$，且 $\\{\\epsilon_{t}\\}$ 独立于 $\\mathcal{F}_{t-1}$。通过将递推关系向前迭代 $h$ 步，我们得到向前 $h$ 步的表达式\n$$\nx_{t+h}=\\phi^{h}x_{t}+\\sum_{i=0}^{h-1}\\phi^{i}\\epsilon_{t+h-i}.\n$$\n在给定 $\\mathcal{F}_{t}$ 的条件下取条件期望，并利用对于所有 $j\\geq 1$ 都有 $\\mathbb{E}[\\epsilon_{t+j}\\mid \\mathcal{F}_{t}]=0$，我们得到\n$$\n\\hat{x}_{t+h|t}\\equiv \\mathbb{E}[x_{t+h}\\mid \\mathcal{F}_{t}]=\\phi^{h}x_{t}.\n$$\n因此，均值偏差形式的 $h$ 步预测误差为\n$$\ne_{t+h|t}\\equiv x_{t+h}-\\hat{x}_{t+h|t}=\\sum_{i=0}^{h-1}\\phi^{i}\\epsilon_{t+h-i}.\n$$\n根据方差的线性性质以及新息序列 $\\{\\epsilon_{t}\\}$ 的相互独立性和同方差性，条件预测误差方差为\n$$\n\\operatorname{Var}\\!\\left(e_{t+h|t}\\mid \\mathcal{F}_{t}\\right)=\\operatorname{Var}\\!\\left(\\sum_{i=0}^{h-1}\\phi^{i}\\epsilon_{t+h-i}\\,\\middle|\\, \\mathcal{F}_{t}\\right)=\\sum_{i=0}^{h-1}\\phi^{2i}\\operatorname{Var}(\\epsilon_{t+h-i})=\\sigma_{\\epsilon}^{2}\\sum_{i=0}^{h-1}\\phi^{2i}.\n$$\n该和是一个有限几何级数。对于 $|\\phi|<1$，其封闭形式为\n$$\n\\sum_{i=0}^{h-1}\\phi^{2i}=\\frac{1-\\phi^{2h}}{1-\\phi^{2}}.\n$$\n因此，\n$$\n\\operatorname{Var}\\!\\left(y_{t+h}-\\hat{y}_{t+h|t}\\mid \\mathcal{F}_{t}\\right)=\\operatorname{Var}\\!\\left(e_{t+h|t}\\mid \\mathcal{F}_{t}\\right)=\\sigma_{\\epsilon}^{2}\\,\\frac{1-\\phi^{2h}}{1-\\phi^{2}}.\n$$\n\n为证明其收敛于 $y_{t}$ 的无条件方差，我们首先计算 $x_{t}$ 的平稳方差。在平稳性条件下，令 $V\\equiv \\operatorname{Var}(x_{t})$，我们有\n$$\nV=\\operatorname{Var}(\\phi x_{t-1}+\\epsilon_{t})=\\phi^{2}\\operatorname{Var}(x_{t-1})+\\operatorname{Var}(\\epsilon_{t})=\\phi^{2}V+\\sigma_{\\epsilon}^{2},\n$$\n这意味着\n$$\nV=\\frac{\\sigma_{\\epsilon}^{2}}{1-\\phi^{2}}.\n$$\n由于 $y_{t}=x_{t}+\\mu$，可得 $\\operatorname{Var}(y_{t})=V=\\sigma_{\\epsilon}^{2}/(1-\\phi^{2})$。最后，利用 $|\\phi|<1$，\n$$\n\\lim_{h\\to\\infty}\\operatorname{Var}\\!\\left(y_{t+h}-\\hat{y}_{t+h|t}\\mid \\mathcal{F}_{t}\\right)=\\lim_{h\\to\\infty}\\sigma_{\\epsilon}^{2}\\,\\frac{1-\\phi^{2h}}{1-\\phi^{2}}=\\sigma_{\\epsilon}^{2}\\,\\frac{1}{1-\\phi^{2}}=\\operatorname{Var}(y_{t}),\n$$\n这就证明了当 $h\\to\\infty$ 时，$h$ 步预测误差方差收敛于无条件方差。\n\n因此，所需的 $h$ 步预测误差方差的解析表达式（适用于计算实现）为 $\\sigma_{\\epsilon}^{2}(1-\\phi^{2h})/(1-\\phi^{2})$。", "answer": "$$\\boxed{\\sigma_{\\epsilon}^{2}\\,\\frac{1-\\phi^{2h}}{1-\\phi^{2}}}$$", "id": "2399435"}, {"introduction": "在金融数据中，“波动率聚集”是常见现象，而GARCH模型是捕捉此特征的主要工具。然而，其他数据特征有时会伪装成波动率聚集，误导我们的建模选择。本模拟练习将揭示一个常见的陷阱：当一个时间序列的均值发生未被模型考虑的结构性突变时，其残差会表现出虚假的GARCH效应，从而导致模型误判。[@problem_id:2399496] 这个动手实践将磨练你的模型诊断技能，教你在下结论前审慎地评估统计检验结果，并考虑更合适的模型设定。", "problem": "要求您设计并实现一个模拟和测试程序，以研究时间序列均值中的结构性突变如何被标准的自回归条件异方差检验错误地识别为阶数为(1,1)的广义自回归条件异方差（GARCH），记为 $GARCH(1,1)$。您的程序必须是完全自包含的，并且无需任何用户交互即可产生结果。\n\n需要使用的基本依据包括以下经过充分检验的定义和事实。\n\n- 如果一个时间序列 $\\{y_t\\}_{t=1}^T$ 的确定性均值在已知时间点 $T_b$ 之后（即从 $t = T_b + 1$ 开始）从 $\\mu_1$ 变为 $\\mu_2$，而其创新项方差保持不变，则称该序列在 $T_b$ 处存在均值上的结构性突变。具体而言，对于 $t \\le T_b$，有 $y_t = \\mu_1 + \\varepsilon_t$；对于 $t > T_b$，有 $y_t = \\mu_2 + \\varepsilon_t$，其中 $\\varepsilon_t \\overset{iid}{\\sim} \\mathcal{N}(0,\\sigma^2)$。\n- 普通最小二乘（OLS）均值模型为 $y_t = x_t^{\\prime}\\beta + \\varepsilon_t$，其中 $x_t$ 包含一个截距项，并在适用时包含其他回归量，例如突变虚拟变量 $d_t$，其中当 $t \\le T_b$ 时 $d_t = 0$，当 $t > T_b$ 时 $d_t = 1$。OLS 残差为 $e_t = y_t - x_t^{\\prime}\\hat{\\beta}$。\n- 针对零均值创新项 $\\{u_t\\}$ 的 $GARCH(1,1)$ 模型为 $u_t = \\sqrt{h_t} z_t$，其中 $z_t \\overset{iid}{\\sim} \\mathcal{N}(0,1)$，条件方差为 $h_t = \\omega + \\alpha u_{t-1}^2 + \\beta h_{t-1}$。参数需满足 $\\omega > 0$, $\\alpha \\ge 0$, $\\beta \\ge 0$ 以及 $\\alpha + \\beta < 1$ 以确保无条件方差为有限值。观测到的序列为 $y_t = \\mu + u_t$。\n- 针对 OLS 残差序列 $\\{e_t\\}$ 的q阶自回归条件异方差的 Engle 拉格朗日乘子 (LM) 检验，其步骤是：将 $e_t^2$ 对一个常数项和 $e_t^2$ 的q阶滞后项进行回归，计算决定系数 $R^2$，并构建统计量 $LM = n R^2$，其中 $n$ 是该回归中的可用观测值数量。在截至q阶滞后不存在自回归条件异方差的原假设下，$LM$ 渐进服从 $\\chi^2_q$ 分布。其 $p$-值为 $1 - F_{\\chi^2_q}(LM)$，其中 $F_{\\chi^2_q}$ 是自由度为q的卡方分布的累积分布函数。\n\n您的任务是精确地实现以下步骤。\n\n1. 数据生成过程（DGP）的模拟：\n   - 均值存在结构性突变且方差恒定：对于给定的参数 $T, \\mu_1, \\mu_2, \\sigma$ 和突变点分数 $b \\in (0,1)$，按照上文描述模拟序列 $\\{y_t\\}$，其中 $T_b = \\lfloor b T \\rfloor$ 且 $\\varepsilon_t \\overset{iid}{\\sim} \\mathcal{N}(0,\\sigma^2)$。\n   - 独立同分布（iid）的同方差无突变序列：$y_t = \\mu + \\varepsilon_t$，$\\varepsilon_t \\overset{iid}{\\sim} \\mathcal{N}(0,\\sigma^2)$。\n   - 无均值突变的 $GARCH(1,1)$ 序列：$y_t = \\mu + u_t$，其中 $u_t$ 服从上文定义的 $GARCH(1,1)$ 过程。将 $h_0$ 初始化为无条件方差 $h_0 = \\omega/(1-\\alpha-\\beta)$，并使用初始500步的预烧期（burn-in）来减轻初始化效应。\n\n2. 建模与残差提取：\n   - 对每个模拟序列，拟合两个 OLS 均值模型以获得残差 $\\{e_t\\}$：\n     - 错误设定的均值模型：对所有 $t$ 采用仅含截距项的模型 $x_t = [1]$。\n     - 正确设定的均值模型：当 DGP 存在结构性突变时，采用截距项加突变虚拟变量的模型，即 $x_t = [1, d_t]$；否则，采用仅含截距项的模型。\n\n3. 自回归条件异方差检验：\n   - 对每组残差和指定的滞后阶数 $q$，运行上文所述的 Engle LM 检验，并基于 $\\chi^2_q$ 分布计算 $p$-值。\n\n4. 解释原则（供您推理，不属于输出的一部分）：低的 $p$-值表示拒绝无自回归条件异方差的原假设。需要观察的核心现象是，当均值模型设定错误时，均值上的结构性突变会在 $e_t^2$ 中引起序列相关性，从而导致对 $GARCH$ 类行为的伪检测。\n\n请使用以下参数集测试套件。所有的随机抽样必须使用相同的固定种子 $12345$ 生成，以确保结果是可复现的。\n\n- 测试用例1（理想路径，样本中段的强突变）：\n  - DGP：具有恒定方差的均值结构性突变。\n  - 参数：$T = 4000$, $\\mu_1 = 0.0$, $\\mu_2 = 2.0$, $\\sigma = 1.0$, $b = 0.5$, $q = 5$。\n\n- 测试用例2（边界条件，晚期突变，检验中最小滞后阶数）：\n  - DGP：具有恒定方差的均值结构性突变。\n  - 参数：$T = 4000$, $\\mu_1 = 0.0$, $\\mu_2 = 3.0$, $\\sigma = 1.0$, $b = 0.9$, $q = 1$。\n\n- 测试用例3（边缘案例，真实的 $GARCH(1,1)$）：\n  - DGP：无均值突变的 $GARCH(1,1)$。\n  - 参数：$T = 5000$, $\\mu = 0.0$, $\\omega = 0.1$, $\\alpha = 0.05$, $\\beta = 0.9$, $q = 5$。\n\n- 测试用例4（对照组，独立同分布同方差）：\n  - DGP：无均值突变的同方差独立同分布。\n  - 参数：$T = 4000$, $\\mu = 0.0$, $\\sigma = 1.0$, $q = 5$。\n\n每个测试用例的所需输出：\n\n- 对每个测试用例 $i \\in \\{1,2,3,4\\}$，计算两个 $p$-值：\n  - $p^{(i)}_{\\text{misspec}}$：使用仅含截距项的均值模型得到的 LM 检验 $p$-值。\n  - $p^{(i)}_{\\text{well}}$：使用正确设定的均值模型（仅在适用时包含突变虚拟变量）得到的 LM 检验 $p$-值。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表包含8个结果，严格按照以下顺序排列：\n  $[p^{(1)}_{\\text{misspec}}, p^{(1)}_{\\text{well}}, p^{(2)}_{\\text{misspec}}, p^{(2)}_{\\text{well}}, p^{(3)}_{\\text{misspec}}, p^{(3)}_{\\text{well}}, p^{(4)}_{\\text{misspec}}, p^{(4)}_{\\text{well}}]$,\n  每个值需四舍五入到六位小数。例如，输出可能看起来像这样：$[0.000001,0.845210,0.000004,0.612345,0.000000,0.000000,0.523410,0.523410]$。\n\n本问题中的所有量均为无单位的实数，不涉及任何物理单位。不使用角度。百分比在概念上引用时，必须作为小数处理；但是，您只需按上述描述输出指定的 $p$-值。", "solution": "该问题陈述已经过严格验证，被认定为有效。它在科学上基于成熟的计量经济学理论，特别是时间序列模型设定误差的研究。该问题定义明确，为获得唯一、可验证的解提供了完整且一致的定义、参数和程序。其中不存在逻辑矛盾、含糊不清或事实错误。该任务是计量经济学中的一个标准计算练习，而非征求主观看法或推测性推理。我们现在将系统地进行求解。\n\n目标是通过计算来证明，如果时间序列均值中的结构性突变未被正确建模，会如何产生自回归条件异方差（ARCH）的伪证据——这种现象在实践中可能导致错误的模型选择。解决方案分为三个主要阶段：数据模拟、模型估计与残差提取，以及假设检验。\n\n首先，我们着手模拟所指定的三种不同的数据生成过程（DGP）。为确保可复现性，所有随机操作均使用固定的随机种子 $12345$。\n\n1.  **结构性突变序列**：生成一个长度为 $T$ 且均值存在单次突变的时间序列 $\\{y_t\\}_{t=1}^T$，其模型如下：\n    $$\n    y_t =\n    \\begin{cases}\n    \\mu_1 + \\varepsilon_t & \\text{若 } t \\le T_b \\\\\n    \\mu_2 + \\varepsilon_t & \\text{若 } t > T_b\n    \\end{cases}\n    $$\n    其中，对于给定的突变点分数 $b \\in (0,1)$，突变点为 $T_b = \\lfloor bT \\rfloor$，创新项 $\\varepsilon_t$ 是从正态分布 $\\mathcal{N}(0, \\sigma^2)$ 中抽取的独立同分布（iid）样本。\n\n2.  **GARCH(1,1)序列**：生成一个由广义自回归条件异方差过程驱动的时间序列 $\\{y_t\\}_{t=1}^T$，$y_t = \\mu + u_t$。创新项 $u_t$ 定义为 $u_t = \\sqrt{h_t} z_t$，其中 $z_t \\overset{iid}{\\sim} \\mathcal{N}(0,1)$。条件方差 $h_t$ 的演化方程为：\n    $$\n    h_t = \\omega + \\alpha u_{t-1}^2 + \\beta h_{t-1}\n    $$\n    参数需满足平稳性条件 $\\omega > 0$, $\\alpha \\ge 0$, $\\beta \\ge 0$ 以及 $\\alpha + \\beta < 1$。模拟初始化时，将 $h_0$ 设为无条件方差 $h_{uncond} = \\frac{\\omega}{1-\\alpha-\\beta}$，并生成一个初始样本（500个数据点）后丢弃，以减轻初始化偏差的影响。\n\n3.  **独立同分布同方差序列**：这是一个作为基准的对照序列，生成方式为 $y_t = \\mu + \\varepsilon_t$，其中 $\\varepsilon_t \\overset{iid}{\\sim} \\mathcal{N}(0, \\sigma^2)$。\n\n其次，对于每个模拟序列 $\\{y_t\\}$，我们通过两种不同的普通最小二乘（OLS）均值模型设定来获得残差。通用的 OLS 模型为 $y_t = x_t^{\\prime}\\beta + e_t$，其中 $x_t$ 是回归量向量，$\\beta$ 是系数向量，$e_t$ 是残差。$\\beta$的 OLS 估计量为 $\\hat{\\beta} = (X'X)^{-1}X'y$，其中 $X$ 和 $y$ 分别是回归量和因变量的矩阵和向量形式。残差则计算为 $e = y - X\\hat{\\beta}$。\n\n1.  **错误设定的模型**：该模型统一假设一个简单的常数均值，通过单一回归量（截距项）实现。因此，对所有 $t$，有 $x_t = [1]$。对于包含结构性突变的 DGP，此模型是设定错误的。\n\n2.  **正确设定的模型**：该模型正确反映了 DGP 的底层均值结构。对于结构性突变的 DGP，回归量为一个截距项和一个突变虚拟变量 $d_t$，其中当 $t \\le T_b$ 时 $d_t=0$，当 $t > T_b$ 时 $d_t=1$。因此，$x_t = [1, d_t]$。对于 GARCH 和 IID 这两种具有恒定均值的 DGP，正确设定的模型与错误设定的模型相同，均只包含一个截距项。\n\n第三，对每个模型提取的残差序列 $\\{e_t\\}$ 进行 Engle 的拉格朗日乘子（LM）检验，以检测q阶ARCH效应。该检验的原假设是：截至q阶滞后均不存在ARCH效应，即在辅助回归方程中 $H_0: \\gamma_1 = \\gamma_2 = \\dots = \\gamma_q = 0$：\n$$\ne_t^2 = \\gamma_0 + \\gamma_1 e_{t-1}^2 + \\dots + \\gamma_q e_{t-q}^2 + \\nu_t\n$$\nLM 检验统计量计算为 $LM = nR^2$，其中 $n$ 是辅助回归中的观测数量（$n = T-q$），$R^2$ 是该回归的决定系数。在原假设下，LM 统计量渐近服从自由度为q的卡方分布，即 $LM \\sim \\chi^2_q$。$p$-值，即观测到至少与计算值一样极端的检验统计量的概率，由 $1 - F_{\\chi^2_q}(LM)$ 给出，其中 $F_{\\chi^2_q}$ 是 $\\chi^2_q$ 分布的累积分布函数。\n\n一个低的 $p$-值（例如 < 0.05）会导致拒绝原假设，表明存在ARCH效应。分析的核心在于比较结构性突变 DGP 下，错误设定模型和正确设定模型所得的 $p$-值。如果错误设定的模型产生一个低的 $p$-值，而正确设定的模型产生一个高的 $p$-值，则证实了ARCH的伪检测现象。对于 GARCH DGP，预计两种模型都会产生低的 $p$-值。对于 IID DGP，预计两种模型都会产生高的 $p$-值。对四个指定的测试用例均执行此完整流程，以生成所需输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    \n    # Establish a reproducible random number generator\n    rng = np.random.default_rng(12345)\n\n    def generate_structural_break(T, mu1, mu2, sigma, b, rng_gen):\n        \"\"\"Generates a time series with a structural break in the mean.\"\"\"\n        Tb = int(np.floor(b * T))\n        innovations = rng_gen.normal(loc=0.0, scale=sigma, size=T)\n        y = np.zeros(T)\n        y[:Tb] = mu1 + innovations[:Tb]\n        y[Tb:] = mu2 + innovations[Tb:]\n        return y, Tb\n\n    def generate_garch(T, mu, omega, alpha, beta, rng_gen):\n        \"\"\"Generates a GARCH(1,1) time series.\"\"\"\n        burn_in = 500\n        total_len = T + burn_in\n        \n        z = rng_gen.normal(loc=0.0, scale=1.0, size=total_len)\n        u = np.zeros(total_len)\n        h = np.zeros(total_len)\n        \n        h[0] = omega / (1 - alpha - beta)\n        u[0] = np.sqrt(h[0]) * z[0]\n        \n        for t in range(1, total_len):\n            h[t] = omega + alpha * u[t-1]**2 + beta * h[t-1]\n            u[t] = np.sqrt(h[t]) * z[t]\n        \n        y = mu + u[burn_in:]\n        return y\n\n    def generate_iid(T, mu, sigma, rng_gen):\n        \"\"\"Generates an IID homoskedastic time series.\"\"\"\n        innovations = rng_gen.normal(loc=0.0, scale=sigma, size=T)\n        y = mu + innovations\n        return y\n\n    def get_residuals(y, with_break_dummy, Tb=None):\n        \"\"\"\n        Fits an OLS model to the data and returns the residuals.\n        \"\"\"\n        T = len(y)\n        if with_break_dummy:\n            if Tb is None:\n                raise ValueError(\"Tb must be provided for break dummy model.\")\n            X = np.ones((T, 2))\n            dummy = np.zeros(T)\n            dummy[Tb:] = 1.0\n            X[:, 1] = dummy\n        else:\n            X = np.ones((T, 1))\n\n        beta_hat = np.linalg.lstsq(X, y, rcond=None)[0]\n        y_hat = X @ beta_hat\n        residuals = y - y_hat\n        return residuals\n\n    def engle_lm_test(residuals, q):\n        \"\"\"\n        Performs the Engle LM test for ARCH effects.\n        \"\"\"\n        T = len(residuals)\n        e_sq = residuals**2\n        \n        # Dependent variable for the auxiliary regression\n        Y_aux = e_sq[q:]\n        n = len(Y_aux) # n = T - q\n        \n        # Independent variables (constant + q lags of e_sq)\n        X_aux = np.ones((n, q + 1))\n        for i in range(q):\n            # lag i+1\n            X_aux[:, i + 1] = e_sq[q - 1 - i : T - 1 - i]\n            \n        # OLS on the auxiliary regression\n        try:\n            # lstsq returns sum of squared residuals in the second element\n            rss_val = np.linalg.lstsq(X_aux, Y_aux, rcond=None)[1][0]\n        except IndexError:\n            # This can happen if the problem is perfectly determined, rss is empty.\n            rss_val = 0.0\n\n        # Total sum of squares of the dependent variable\n        tss = np.sum((Y_aux - np.mean(Y_aux))**2)\n        \n        if tss  1e-12: # Handle cases with zero variance\n             R2 = 0.0\n        else:\n            R2 = 1 - rss_val / tss\n\n        lm_stat = n * R2\n        p_value = 1 - chi2.cdf(lm_stat, q)\n        \n        return p_value\n\n    test_cases = [\n        {'type': 'break', 'params': {'T': 4000, 'mu1': 0.0, 'mu2': 2.0, 'sigma': 1.0, 'b': 0.5, 'q': 5}},\n        {'type': 'break', 'params': {'T': 4000, 'mu1': 0.0, 'mu2': 3.0, 'sigma': 1.0, 'b': 0.9, 'q': 1}},\n        {'type': 'garch', 'params': {'T': 5000, 'mu': 0.0, 'omega': 0.1, 'alpha': 0.05, 'beta': 0.9, 'q': 5}},\n        {'type': 'iid', 'params': {'T': 4000, 'mu': 0.0, 'sigma': 1.0, 'q': 5}}\n    ]\n    \n    results = []\n    \n    # Test case 1\n    case = test_cases[0]\n    params = case['params']\n    y, Tb = generate_structural_break(params['T'], params['mu1'], params['mu2'], params['sigma'], params['b'], rng)\n    res_misspec = get_residuals(y, with_break_dummy=False)\n    p_misspec = engle_lm_test(res_misspec, params['q'])\n    res_well = get_residuals(y, with_break_dummy=True, Tb=Tb)\n    p_well = engle_lm_test(res_well, params['q'])\n    results.extend([p_misspec, p_well])\n    \n    # Test case 2\n    case = test_cases[1]\n    params = case['params']\n    y, Tb = generate_structural_break(params['T'], params['mu1'], params['mu2'], params['sigma'], params['b'], rng)\n    res_misspec = get_residuals(y, with_break_dummy=False)\n    p_misspec = engle_lm_test(res_misspec, params['q'])\n    res_well = get_residuals(y, with_break_dummy=True, Tb=Tb)\n    p_well = engle_lm_test(res_well, params['q'])\n    results.extend([p_misspec, p_well])\n\n    # Test case 3\n    case = test_cases[2]\n    params = case['params']\n    y = generate_garch(params['T'], params['mu'], params['omega'], params['alpha'], params['beta'], rng)\n    # For GARCH DGP, both misspecified and well-specified models are intercept-only\n    res = get_residuals(y, with_break_dummy=False)\n    p_val = engle_lm_test(res, params['q'])\n    results.extend([p_val, p_val])\n\n    # Test case 4\n    case = test_cases[3]\n    params = case['params']\n    y = generate_iid(params['T'], params['mu'], params['sigma'], rng)\n    # For IID DGP, both misspecified and well-specified models are intercept-only\n    res = get_residuals(y, with_break_dummy=False)\n    p_val = engle_lm_test(res, params['q'])\n    results.extend([p_val, p_val])\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{v:.6f}' for v in results)}]\")\n\nsolve()\n```", "id": "2399496"}, {"introduction": "波动率建模不仅是一项学术活动，更是现代金融风险管理的核心。本练习将指导你应用GARCH模型来计算一项关键的风险指标——在险价值 (Value-at-Risk, VaR)，并学习如何通过“回测”(backtesting)来系统地评估模型的预测准确性。[@problem_id:2399425] 完成此练习将带你走过量化风险分析师的完整工作流程：从构建模型、生成风险预测到严格的实证检验，让你直观地理解理论模型在实践中的应用与验证。", "problem": "您的任务是通过将波动率模型与风险价值(VaR)阈值相结合，来量化单一资产投资组合的单步市场风险，然后评估观测到的VaR突破频率是否与模型隐含的尾部概率一致。收益过程由广义自回归条件异方差(GARCH)模型定义。您必须实现一个完整的程序，该程序能够模拟收益、计算基于模型的VaR，并执行无条件覆盖的正式回测。\n\n定义与设置：\n\n- 阶数为$(1,1)$的广义自回归条件异方差(GARCH)模型由以下递归式给出\n$$\nr_t \\;=\\; \\sqrt{h_t}\\,\\varepsilon_t,\\qquad\nh_t \\;=\\; \\omega \\;+\\; \\alpha\\, r_{t-1}^2 \\;+\\; \\beta\\, h_{t-1},\n$$\n对于 $t \\in \\{1,2,\\dots,B+T\\}$，初始条件为 $r_0 \\equiv 0$ 和 $h_0 \\equiv \\dfrac{\\omega}{1-\\alpha-\\beta}$，其中 $\\omegagt;0$， $\\alpha \\ge 0$， $\\beta \\ge 0$，且 $\\alpha+\\beta lt; 1$。这里 $r_t$ 表示收益， $h_t$ 表示条件方差。\n\n- 创新项 $\\varepsilon_t$ 是均值为$0$、方差为$1$的独立同分布。考虑两种情况：\n  1. 条件正态分布情况：$\\varepsilon_t \\sim \\mathcal{N}(0,1)$。\n  2. 条件标准化学生t分布情况：$\\varepsilon_t = \\dfrac{u_t}{\\sqrt{\\nu/(\\nu-2)}}$，其中 $u_t \\sim t_\\nu$ 且自由度 $\\nugt;2$；此缩放确保 $\\mathbb{E}[\\varepsilon_t^2]=1$。\n\n- 在尾部概率水平 $p \\in (0,1)$ 下的单步风险价值(VaR)定义为 $r_t$ 的条件$p$分位数。在VaR计算的条件正态假设下，基于截至$t-1$时刻的信息，对$t$时刻的基于模型的预测阈值为\n$$\nv_{t-1}(p) \\;=\\; z_p \\,\\sqrt{h_t},\n$$\n其中 $z_p$ 是标准正态分布的$p$分位数， $h_t$ 是基于截至$t-1$时刻的信息通过GARCH递归计算出的条件方差。\n\n- 如果 $r_t lt; v_{t-1}(p)$，则在$t$时刻发生一次VaR突破。定义指示函数 $I_t \\equiv \\mathbf{1}\\{r_t lt; v_{t-1}(p)\\}$，并令 $n \\equiv \\sum_{t=1}^{T} I_{B+t}$ 为在$B$个周期的预烧期之后，$T$个周期的评估样本中的总突破次数。\n\n回测要求：\n\n- 为检验突破频率是否与模型隐含的尾部概率$p$匹配，请使用Kupiec失败比例(POF)检验。在原假设 $\\mathbb{P}(I_t=1)=p$ 对所有$t$独立成立的情况下，检验统计量为\n$$\n\\text{LR}_{\\text{uc}} \\;=\\; -2 \\left[\nn \\ln(p) + (T-n)\\ln(1-p) \\;-\\; \\big(n \\ln(\\hat{p}) + (T-n)\\ln(1-\\hat{p})\\big)\n\\right],\n$$\n其中 $\\hat{p} \\equiv n/T$ 是样本突破频率。使用约定 $0 \\cdot \\ln 0 \\equiv 0$。如果在显著性水平 $\\alpha_{\\text{test}}=0.05$ 下， $\\text{LR}_{\\text{uc}} gt; q_{0.95}(\\chi^2_1)$，则拒绝原假设，其中 $q_{0.95}(\\chi^2_1)$ 是自由度为$1$的卡方分布的$0.95$分位数（约等于$3.841458820694124$）。\n\n模拟详情：\n\n- 对每个测试用例，使用给定的随机种子以保证可复现性，从指定的GARCH模型和创新项分布中模拟总共$B+T$个周期。使用最后$T$个周期进行评估（丢弃$B$个周期的预烧期）。对于每个评估周期 $t \\in \\{B+1,\\dots,B+T\\}$，使用条件方差 $h_t$ 和标准正态分位数 $z_p$ 计算VaR阈值 $v_{t-1}(p)$，然后记录是否发生突破。\n\n测试套件：\n\n实现您的程序以处理以下三个测试用例。对于学生t分布创新项的情况，VaR阈值仍必须使用标准正态分位数 $z_p$ 进行计算；仅数据生成过程有所不同。\n\n- 测试用例1（一般情况，设定正确的正态创新项）：\n  - $T=2500$, $B=500$,\n  - $\\omega=0.0005\\times 10^{-2}$, $\\alpha=0.05$, $\\beta=0.94$,\n  - $p=0.05$,\n  - 创新项分布：正态,\n  - 随机种子：$123456$。\n\n- 测试用例2（数据生成过程存在重尾，VaR在正态性假设下计算）：\n  - $T=4000$, $B=500$,\n  - $\\omega=0.0002\\times 10^{-1}$, $\\alpha=0.10$, $\\beta=0.85$,\n  - $p=0.01$,\n  - 创新项分布：自由度为 $\\nu=5$ 的标准化学生t分布，\n  - 随机种子：$314159$。\n\n- 测试用例3（使用中位数VaR和纯ARCH模型的边界式覆盖）：\n  - $T=1000$, $B=500$,\n  - $\\omega=0.0004\\times 10^{-2}$, $\\alpha=0.15$, $\\beta=0.00$,\n  - $p=0.50$,\n  - 创新项分布：正态,\n  - 随机种子：$271828$。\n\n程序输出要求：\n\n- 对每个测试用例，输出一个布尔值，表示Kupiec失败比例检验是否在$0.05$的显著性水平上拒绝了正确无条件覆盖的原假设（如果拒绝则输出$\\text{True}$，否则输出$\\text{False}$）。\n\n- 您的程序应生成单行输出，其中包含按顺序排列的三个测试用例的布尔值，格式为方括号内以逗号分隔的列表，例如 $[\\text{False},\\text{True},\\text{False}]$。\n\n所有概率必须作为小数处理和报告，而非百分比。本问题不涉及物理单位。本问题不涉及角度。\n\n您的最终程序必须是完整的，无需任何用户输入或外部文件即可运行，并且必须严格遵守指定的输出格式。", "solution": "问题陈述经评估有效。这是一个定义明确、科学合理且完整的计算金融学练习，特别是在市场风险建模和模型验证领域。所有定义、参数和约束都已明确指定，任务在算法上是可执行的。\n\n解决方案通过根据提供的规范实现一个模拟和回测框架来展开。每个测试用例的处理过程如下：\n\n1.  **GARCH(1,1)过程模拟**\n    问题的核心是模拟一个遵循GARCH($1$,$1$)过程的金融收益序列 $r_t$。该模型由两个方程定义：\n    $$r_t = \\sqrt{h_t}\\,\\varepsilon_t$$\n    $$h_t = \\omega + \\alpha\\, r_{t-1}^2 + \\beta\\, h_{t-1}$$\n    其中 $r_t$ 是$t$时刻的收益， $h_t$ 是收益的条件方差，而 $\\varepsilon_t$ 是均值为零、方差为一的独立同分布(i.i.d.)创新项。模型参数 $\\omega$, $\\alpha$, 和 $\\beta$ 必须满足 $\\omega0$, $\\alpha \\ge 0$, $\\beta \\ge 0$, 且 $\\alpha+\\beta  1$，以保证方差过程为正且平稳。\n\n    模拟从初始条件 $r_0 = 0$ 和 $h_0 = \\frac{\\omega}{1-\\alpha-\\beta}$ 开始，其中 $h_0$ 是该过程的无条件方差。总共模拟$B+T$个周期，其中$B$是预烧样本的长度， $T$ 是评估样本的长度。\n\n    对于每个时间步 $t \\in \\{1, 2, \\dots, B+T\\}$，会抽取一个随机创新项 $\\varepsilon_t$。指定了两种类型的创新项分布：\n    - **正态分布**：$\\varepsilon_t \\sim \\mathcal{N}(0,1)$，从标准正态分布中抽取。\n    - **标准化学生t分布**：$\\varepsilon_t = \\frac{u_t}{\\sqrt{\\nu/(\\nu-2)}}$，其中 $u_t$ 从具有 $\\nu$ 个自由度的学生t分布中抽取。缩放因子 $\\sqrt{\\nu/(\\nu-2)}$ 确保了 $\\mathbb{E}[\\varepsilon_t^2]=1$。\n\n    模拟以迭代方式进行，使用前一步的值为每个时间步计算 $h_t$ 和 $r_t$。\n\n2.  **风险价值(VaR)回测**\n    在模拟了收益和方差的完整路径后，最后$T$个观测值用于回测。对于评估期内的每个时间步 $t$（从$t=B+1$ 到 $t=B+T$），我们执行以下操作：\n    - **VaR计算**：计算在给定尾部概率$p$下的单步风险价值。问题指定VaR模型基于条件正态性假设，无论真实的数据生成过程如何。公式为：\n      $$v_{t-1}(p) = z_p \\sqrt{h_t}$$\n      此处， $z_p$ 是标准正态分布的$p$分位数（例如，对于$p=0.05$，$z_{0.05} \\approx -1.645$）。至关重要的是要注意到 $h_t$ 是利用截至$t-1$时刻的可用信息对$t$时刻的方差预测。\n    - **突破识别**：如果实现的收益 $r_t$ 小于计算出的VaR阈值，则记录一次VaR突破（或失败）：\n      $$I_t = \\mathbf{1}\\{r_t  v_{t-1}(p)\\} = 1$$\n    计算评估期内的总突破次数 $n = \\sum_{t=B+1}^{B+T} I_t$。\n\n3.  **Kupiec失败比例(POF)检验**\n    为了检验VaR模型的有效性，使用Kupiec POF检验。该检验检查观测到的突破频率 $\\hat{p} = n/T$ 是否与预期频率 $p$ 在统计上一致。\n    - **原假设 ($H_0$)**：VaR突破的概率等于 $p$，即 $\\mathbb{P}(I_t=1) = p$。\n    - **检验统计量**：该检验使用一个似然比(LR)统计量，在原假设下，该统计量渐近服从自由度为一的卡方分布($\\chi^2_1$)。该统计量由下式给出：\n      $$\\text{LR}_{\\text{uc}} = -2 \\left[ \\ln(L(p)) - \\ln(L(\\hat{p})) \\right] = -2 \\left[ (n \\ln(p) + (T-n)\\ln(1-p)) - (n \\ln(\\hat{p}) + (T-n)\\ln(1-\\hat{p})) \\right]$$\n      其中 $L(p)$ 是二项似然函数。对于 $n=0$ 或 $n=T$ 的情况，应用约定 $0 \\cdot \\ln(0) = 0$。\n    - **决策规则**：如果在显著性水平 $\\alpha_{\\text{test}}=0.05$ 下，计算出的统计量 $\\text{LR}_{\\text{uc}}$ 大于 $\\chi^2_1$ 分布的 $0.95$ 分位数（约等于$3.8415$），则拒绝原假设。拒绝意味着VaR模型在其无条件覆盖方面存在错误设定。\n\n此实现将这些步骤封装到一个单一、可复现的程序中。每个测试用例都使用其特定的参数集和随机种子进行处理，并确定最终的布尔结果（拒绝或不拒绝）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm, t, chi2\n\ndef run_backtest(T, B, omega, alpha, beta, p, innovation_dist, nu, seed):\n    \"\"\"\n    Simulates a GARCH(1,1) process and performs a Kupiec POF backtest on VaR.\n    \n    Returns:\n        bool: True if the null hypothesis is rejected, False otherwise.\n    \"\"\"\n    # 1. Initialization\n    rng = np.random.default_rng(seed)\n    N = B + T\n    \n    # 2. Generate Innovations\n    if innovation_dist == 'normal':\n        eps = rng.standard_normal(size=N)\n    elif innovation_dist == 't':\n        if nu = 2:\n            raise ValueError(\"Degrees of freedom nu must be  2 for finite variance.\")\n        # Scale to have variance 1\n        scale_factor = np.sqrt((nu - 2) / nu)\n        # Pass numpy's random number generator to scipy for reproducibility\n        eps = t.rvs(df=nu, size=N, random_state=rng) * scale_factor\n    else:\n        raise ValueError(\"Invalid innovation distribution specified.\")\n\n    # 3. Simulate GARCH process\n    r = np.zeros(N + 1)\n    h = np.zeros(N + 1)\n    \n    # Initial conditions\n    r[0] = 0.0\n    denominator = 1 - alpha - beta\n    if denominator  1e-9: # Guard against division by zero\n        h[0] = omega / denominator\n    else:\n        # Fallback for alpha+beta=1, though problem parameters are stationary\n        h[0] = omega \n\n    for i in range(1, N + 1):\n        h[i] = omega + alpha * r[i-1]**2 + beta * h[i-1]\n        r[i] = np.sqrt(h[i]) * eps[i-1]\n        \n    # 4. Backtesting Loop\n    exceptions = 0\n    z_p = norm.ppf(p)\n    \n    # Evaluation period from t=B+1 to B+T, which corresponds to array indices B+1 to N\n    for i in range(B + 1, N + 1):\n        # VaR for time i is computed using variance h[i]\n        var_threshold = z_p * np.sqrt(h[i])\n        # An exception occurs if the return is less than the VaR threshold\n        if r[i]  var_threshold:\n            exceptions += 1\n            \n    # 5. Kupiec Proportion of Failures (POF) Test\n    n = exceptions\n    \n    if T == 0:\n        return False # No data to test\n\n    p_hat = n / T\n    \n    # Define a safe log-likelihood function for a binomial outcome\n    # This correctly handles the 0*log(0) = 0 convention\n    def log_likelihood(count, total, prob):\n        if total == 0:\n            return 0.0\n        # Edge cases where probability is 0 or 1\n        if prob == 0.0:\n            return 0.0 if count == 0 else -np.inf\n        if prob == 1.0:\n            return 0.0 if count == total else -np.inf\n        \n        term1 = count * np.log(prob) if count  0 else 0.0\n        term2 = (total - count) * np.log(1 - prob) if total  count else 0.0\n        return term1 + term2\n\n    log_L_p = log_likelihood(n, T, p)\n    log_L_phat = log_likelihood(n, T, p_hat)\n    \n    # If the observed data is impossible under H0, the LR statistic is infinite\n    if log_L_p == -np.inf:\n        lr_uc = np.inf\n    else:\n        lr_uc = -2 * (log_L_p - log_L_phat)\n        \n    # 6. Decision\n    # Critical value from chi-square distribution with 1 df at 95% confidence\n    crit_val = chi2.ppf(0.95, df=1) # Approx 3.8414588...\n    \n    return lr_uc  crit_val\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (T, B, omega, alpha, beta, p, innovation_dist, nu, seed)\n        (2500, 500, 0.0005e-2, 0.05, 0.94, 0.05, 'normal', None, 123456),\n        (4000, 500, 0.0002e-1, 0.10, 0.85, 0.01, 't', 5, 314159),\n        (1000, 500, 0.0004e-2, 0.15, 0.00, 0.50, 'normal', None, 271828)\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters and call the backtesting function\n        T, B, omega, alpha, beta, p, innovation_dist, nu, seed = case\n        result = run_backtest(T, B, omega, alpha, beta, p, innovation_dist, nu, seed)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # str(True) - 'True', str(False) - 'False'\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2399425"}]}