{"hands_on_practices": [{"introduction": "本练习将经济优化理论应用于一个常见的现实场景：自由职业者如何定价和安排工作时间。通过这个假设性问题，我们将探索在结果不确定的情况下，如何通过构建期望利润函数并运用多元微积分来找到最优决策。这个练习旨在锻炼你解决多变量优化问题的核心分析能力，这是经济学分析的基石。[@problem_id:2422477]", "problem": "考虑一位风险中性的自由工作者，其为一个单一时期决定小时费率 $w \\ge 0$ 并预留可用工作时长 $h \\ge 0$。该工作者与客户匹配的概率为 $p(w) = \\exp(-\\alpha w)$，其中 $\\alpha > 0$。如果匹配成功，该工作者在全部 $h$ 小时内每小时赚取 $w$，总收入为 $w h$；如果未匹配成功，收入为 $0$。预留 $h$ 小时会产生机会成本 $c(h) = \\frac{\\gamma}{2} h^{2}$（其中 $\\gamma > 0$），无论是否匹配成功，该成本都会发生。\n\n假设存在内部解，且该工作者选择 $(w,h)$ 以最大化期望利润（期望收入减去机会成本），请确定以 $\\alpha$ 和 $\\gamma$ 的闭式表达式表示的利润最大化选择 $(w^{\\star}, h^{\\star})$。\n\n你的最终答案必须是单一的解析表达式。不要提供不等式或方程式。无需四舍五入。", "solution": "在尝试求解之前，需对问题陈述进行验证。\n\n步骤 1：提取已知条件\n- 决策变量：小时费率 $w \\ge 0$，可用工作时长 $h \\ge 0$。\n- 与客户匹配的概率：$p(w) = \\exp(-\\alpha w)$。\n- 概率函数的参数约束：$\\alpha > 0$。\n- 匹配成功时的收入：$w h$。\n- 未匹配成功时的收入：$0$。\n- 机会成本函数：$c(h) = \\frac{\\gamma}{2} h^{2}$。\n- 成本函数的参数约束：$\\gamma > 0$。\n- 工作者的目标：最大化期望利润。\n- 期望利润定义：期望收入减去机会成本。\n- 假设：存在内部解，即最优选择 $(w^{\\star}, h^{\\star})$ 满足 $w^{\\star} > 0$ 和 $h^{\\star} > 0$。\n- 目标：确定以 $\\alpha$ 和 $\\gamma$ 的闭式表达式表示的利润最大化选择 $(w^{\\star}, h^{\\star})$。\n\n步骤 2：使用提取的已知条件进行验证\n该问题是微观经济理论中的一个标准优化练习，具体场景为不确定性下的劳动供给。\n- **科学依据**：该问题在经济学原理上有充分的依据。使用指数函数表示成功概率和使用二次函数表示成本在经济建模中很常见，以确保诸如边际收益递减和边际成本递增等理想属性。风险中性的假设将效用函数简化为关于货币的线性函数。该问题在科学上和数学上都是合理的。\n- **适定性**：该问题是适定的。它指定了一个目标函数（期望利润），该函数需要对两个选择变量（$w$ 和 $h$）进行最大化，并受给定的函数形式和参数约束（$\\alpha > 0$, $\\gamma > 0$）的限制。存在内部解的假设将求解方法指向标准的微分学，确保可以找到唯一解。\n- **客观性**：问题陈述使用了精确、客观的数学语言，没有模糊性或主观论断。\n\n步骤 3：结论与行动\n该问题是有效的。它是一个定义明确、有科学依据的优化问题。下面将推导其解。\n\n工作者的期望利润（记为 $\\Pi(w, h)$）是期望收入减去机会成本。期望收入是匹配成功时的收入 $w h$ 乘以匹配成功的概率 $p(w)$，加上未匹配成功时的收入 $0$ 乘以未匹配成功的概率 $1-p(w)$。机会成本 $c(h)$ 无论结果如何都会产生。\n\n因此，期望利润函数为：\n$$\n\\Pi(w, h) = p(w) \\cdot (wh) + (1 - p(w)) \\cdot 0 - c(h)\n$$\n代入 $p(w)$ 和 $c(h)$ 的给定函数形式：\n$$\n\\Pi(w, h) = \\exp(-\\alpha w) w h - \\frac{\\gamma}{2} h^{2}\n$$\n为了关于 $w$ 和 $h$ 最大化此函数，我们求其一阶偏导数并令其等于零。这是一阶临界点条件。问题关于存在内部解的假设保证了该点对应于最大利润。\n\n首先，我们对工资 $w$ 求导：\n$$\n\\frac{\\partial \\Pi}{\\partial w} = \\frac{\\partial}{\\partial w} \\left( w h \\exp(-\\alpha w) - \\frac{\\gamma}{2} h^{2} \\right)\n$$\n对第一项使用乘法求导法则：\n$$\n\\frac{\\partial \\Pi}{\\partial w} = h \\cdot \\frac{d}{dw}(w \\exp(-\\alpha w)) = h \\left( 1 \\cdot \\exp(-\\alpha w) + w \\cdot (-\\alpha \\exp(-\\alpha w)) \\right)\n$$\n$$\n\\frac{\\partial \\Pi}{\\partial w} = h \\exp(-\\alpha w) (1 - \\alpha w)\n$$\n将此偏导数设为零，得到第一个条件：\n$$\nh \\exp(-\\alpha w) (1 - \\alpha w) = 0\n$$\n\n接着，我们对小时数 $h$ 求导：\n$$\n\\frac{\\partial \\Pi}{\\partial h} = \\frac{\\partial}{\\partial h} \\left( w h \\exp(-\\alpha w) - \\frac{\\gamma}{2} h^{2} \\right)\n$$\n$$\n\\frac{\\partial \\Pi}{\\partial h} = w \\exp(-\\alpha w) - \\gamma h\n$$\n将此偏导数设为零，得到第二个条件：\n$$\nw \\exp(-\\alpha w) - \\gamma h = 0\n$$\n\n我们现在得到一个包含两个未知数 $w$ 和 $h$ 的方程组：\n1. $h \\exp(-\\alpha w) (1 - \\alpha w) = 0$\n2. $w \\exp(-\\alpha w) - \\gamma h = 0$\n\n从方程（1）可知，因为我们寻求的是内部解，其中 $h^{\\star} > 0$，并且项 $\\exp(-\\alpha w)$ 对于任何有限的 $w$ 都严格为正，所以该方程只有在 $(1 - \\alpha w)$ 项等于零时才成立。\n$$\n1 - \\alpha w = 0\n$$\n求解 $w$ 得到最优小时费率 $w^{\\star}$：\n$$\nw^{\\star} = \\frac{1}{\\alpha}\n$$\n由于给定 $\\alpha > 0$，因此 $w^{\\star}$ 为正，这与内部解的假设一致。\n\n现在，我们将最优工资 $w^{\\star}$ 代入方程（2）以求最优小时数 $h^{\\star}$：\n$$\n\\left(\\frac{1}{\\alpha}\\right) \\exp\\left(-\\alpha \\left(\\frac{1}{\\alpha}\\right)\\right) - \\gamma h = 0\n$$\n$$\n\\frac{1}{\\alpha} \\exp(-1) - \\gamma h = 0\n$$\n整理以求解 $h$：\n$$\n\\gamma h = \\frac{1}{\\alpha} \\exp(-1) = \\frac{1}{\\alpha e}\n$$\n这给出了最优小时数 $h^{\\star}$：\n$$\nh^{\\star} = \\frac{1}{\\alpha \\gamma e}\n$$\n由于给定 $\\alpha > 0$ 和 $\\gamma > 0$，因此 $h^{\\star}$ 也为正，与内部解的假设一致。\n\n因此，利润最大化的选择是 $(w^{\\star}, h^{\\star}) = \\left(\\frac{1}{\\alpha}, \\frac{1}{\\alpha \\gamma e}\\right)$。\n\n为确保严谨，我们可以使用二阶条件来验证这是一个最大值。二阶偏导数的 Hessian 矩阵是：\n$$ H(w,h) = \\begin{pmatrix} \\frac{\\partial^2 \\Pi}{\\partial w^2} & \\frac{\\partial^2 \\Pi}{\\partial w \\partial h} \\\\ \\frac{\\partial^2 \\Pi}{\\partial h \\partial w} & \\frac{\\partial^2 \\Pi}{\\partial h^2} \\end{pmatrix} $$\n其分量为：\n$$ \\frac{\\partial^2 \\Pi}{\\partial w^2} = -h\\alpha\\exp(-\\alpha w)(2 - \\alpha w) $$\n$$ \\frac{\\partial^2 \\Pi}{\\partial h^2} = -\\gamma $$\n$$ \\frac{\\partial^2 \\Pi}{\\partial w \\partial h} = \\exp(-\\alpha w)(1 - \\alpha w) $$\n在临界点 $w^{\\star} = 1/\\alpha$ 和 $h^{\\star} = 1/(\\alpha \\gamma e)$ 处：\n$$ \\frac{\\partial^2 \\Pi}{\\partial w^2}\\bigg|_{(w^{\\star},h^{\\star})} = -h^{\\star}\\alpha\\exp(-1)(2 - 1) = -\\frac{1}{\\alpha\\gamma e}\\alpha e^{-1} = -\\frac{1}{\\gamma e^2} < 0 $$\n$$ \\frac{\\partial^2 \\Pi}{\\partial h^2}\\bigg|_{(w^{\\star},h^{\\star})} = -\\gamma < 0 $$\n$$ \\frac{\\partial^2 \\Pi}{\\partial w \\partial h}\\bigg|_{(w^{\\star},h^{\\star})} = \\exp(-1)(1 - 1) = 0 $$\n此时 Hessian 矩阵的行列式是：\n$$ D = \\left(-\\frac{1}{\\gamma e^2}\\right)(-\\gamma) - (0)^2 = \\frac{1}{e^2} > 0 $$\n由于行列式 $D$ 为正，且 $\\frac{\\partial^2 \\Pi}{\\partial w^2}$ 为负，因此该临界点是一个局部最大值，符合要求。\n\n利润最大化的选择由推导出的 $w^{\\star}$ 和 $h^{\\star}$ 表达式给出。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{1}{\\alpha} & \\frac{1}{\\alpha \\gamma e} \\end{pmatrix}}\n$$", "id": "2422477"}, {"introduction": "这个练习从静态分析转向动态决策，探讨了一家奢侈品垄断企业如何进行跨期规划。其核心概念是“品牌稀释”——即当期过高的销量可能会损害品牌价值，从而降低未来的市场需求。通过运用“逆向归纳法”，你将学习如何量化并解决这种跨期权衡问题，这对于理解企业长期战略至关重要。[@problem_id:2422445]", "problem": "考虑一个生产单一奢侈品的垄断厂商，其生产活动分为两个离散的时期，用 $t \\in \\{1,2\\}$ 表示。在每个时期 $t$，该商品的反需求函数是线性的，由 $p_t(q_t) = A_t - B_t q_t$ 给出，其中 $A_t > 0$ 和 $B_t > 0$ 是参数，$q_t \\ge 0$ 是时期 $t$ 的销售量。该厂商的边际成本为常数 $c \\ge 0$，且在两个时期内保持不变。收入和成本以任意货币单位计价。时间没有物理单位，是无量纲的。跨期权衡通过一个贴现因子 $\\beta \\in (0,1)$ 来衡量，该因子以小数形式表示（而非百分比）。\n\n品牌稀释：大量销售奢侈品可能会损害品牌形象，并降低未来的支付意愿。我们将此建模为时期2需求截距的向下移动，其移动程度取决于时期1的销量$q_1$超出声望阈值销量 $q_{\\text{bar}} \\ge 0$ 的程度。具体来说，时期2的截距为\n$$\nA_2^{\\text{eff}}(q_1) = A_2 - d \\cdot \\max\\{0,\\, q_1 - q_{\\text{bar}}\\},\n$$\n其中 $d \\ge 0$ 是稀释敏感度。如果 $q_1 \\le q_{\\text{bar}}$，则没有品牌稀释，且 $A_2^{\\text{eff}}(q_1) = A_2$；如果 $q_1 > q_{\\text{bar}}$，截距以 $-d$ 的斜率线性减小。\n\n垄断厂商在时期1选择 $q_1$，在时期2选择 $q_2$，以最大化其利润的贴现总和。时期 $t$ 的利润为\n$$\n\\pi_t(q_t) = \\big(p_t(q_t) - c\\big)\\, q_t = \\big(A_t - B_t q_t - c\\big)\\, q_t,\n$$\n需要注意的是，在时期2，相关的截距是 $A_2^{\\text{eff}}(q_1)$，即 $p_2(q_2) = A_2^{\\text{eff}}(q_1) - B_2 q_2$。总目标函数为\n$$\n\\Pi(q_1,q_2) = \\pi_1(q_1) + \\beta \\, \\pi_2(q_2),\n$$\n约束条件为 $q_1 \\ge 0$ 和 $q_2 \\ge 0$，同时隐含的需求非负价格条件确保在时期$t$有 $q_t \\le A_t/B_t$，其中时期2使用 $A_2^{\\text{eff}}(q_1)$ 代替 $A_2$。\n\n推导与计算的基本依据：\n- 在线性需求下，垄断厂商在时期 $t$ 的静态利润最大化问题，对于给定的截距 $A$、斜率 $B$ 和成本 $c$，其一阶条件会导出经过充分检验的结论：$q^\\star = \\max\\{0,\\, (A - c)/(2B)\\}$ 和 $p^\\star = (A + c)/2$，前提是 $A > c$。\n- 未来收益的贴现通过将时期2的利润乘以 $\\beta$ 来建模。\n\n计算任务：\n- 以纯数学方式进行。您必须通过后向归纳法计算子博弈完美结果：对于任意固定的 $q_1$，时期2的垄断厂商会根据给定的 $A_2^{\\text{eff}}(q_1)$ 来优化选择 $q_2$；厂商在预期到这一点后，选择 $q_1$ 以最大化总贴现利润。\n- 假设厂商不能以负价格销售，因此 $q_1 \\in [0,\\, A_1/B_1]$，并且在时期2，当 $A_2^{\\text{eff}}(q_1) > 0$ 时，$q_2 \\in [0,\\, A_2^{\\text{eff}}(q_1)/B_2]$；否则 $q_2 = 0$。\n- 对于下方的每个测试用例，计算唯一的利润最大化配对 $(q_1^\\star, q_2^\\star)$，以及相应的均衡价格 $p_1^\\star$ 和 $p_2^\\star$，和总贴现利润 $\\Pi^\\star = \\pi_1(q_1^\\star) + \\beta \\pi_2(q_2^\\star)$。所有标量输出必须是实数。\n\n测试套件（每个元组为 $(A_1, B_1, A_2, B_2, c, q_{\\text{bar}}, d, \\beta)$）：\n- 案例1：$(A_1, B_1, A_2, B_2, c, q_{\\text{bar}}, d, \\beta) = (100,\\, 1,\\, 120,\\, 1.5,\\, 10,\\, 20,\\, 0.8,\\, 0.95)$。\n- 案例2：$(A_1, B_1, A_2, B_2, c, q_{\\text{bar}}, d, \\beta) = (100,\\, 1,\\, 120,\\, 1.5,\\, 10,\\, 80,\\, 0.8,\\, 0.95)$。\n- 案例3：$(A_1, B_1, A_2, B_2, c, q_{\\text{bar}}, d, \\beta) = (50,\\, 1,\\, 8,\\, 1.2,\\, 10,\\, 20,\\, 1.0,\\, 0.9)$。\n- 案例4：$(A_1, B_1, A_2, B_2, c, q_{\\text{bar}}, d, \\beta) = (80,\\, 1,\\, 100,\\, 0.5,\\, 20,\\, 15,\\, 3.5,\\, 0.9)$。\n\n输出规格：\n- 对于每个测试用例，输出列表 $[q_1^\\star, q_2^\\star, p_1^\\star, p_2^\\star, \\Pi^\\star]$，其中每个数字四舍五入到6位小数。\n- 您的程序应生成单行输出，其中包含所有案例的结果，形式为这些列表的单一列表，按上述测试套件的顺序排列，并格式化为用方括号括起来的逗号分隔列表。\n- 不应从标准输入读取任何内容。所有计算都必须在程序内部对给定案例进行，并且只应打印所需的单行输出。", "solution": "该问题要求计算一个垄断厂商在两个时期内的利润最大化产量、价格和总利润，同时要考虑品牌稀释效应。该问题是适定的，并且在微观经济学理论中有坚实的科学基础。我们将使用后向归纳法来求解，以找到子博弈完美均衡。\n\n垄断厂商的总利润 $\\Pi$ 是时期1和时期2利润的贴现总和：\n$$ \\Pi(q_1, q_2) = \\pi_1(q_1) + \\beta \\pi_2(q_2) $$\n其中 $\\pi_t(q_t) = (p_t(q_t) - c)q_t$，$p_t(q_t) = A_t - B_t q_t$ 是反需求函数，$c$ 是不变的边际成本，$\\beta$ 是贴现因子。品牌稀释通过一个有效的时期2需求截距 $A_2^{\\text{eff}}(q_1)$ 来建模，该截距取决于时期1的销量 $q_1$：\n$$ A_2^{\\text{eff}}(q_1) = A_2 - d \\cdot \\max\\{0, q_1 - q_{\\text{bar}}\\} $$\n在这里，$d$ 是稀释敏感度，$q_{\\text{bar}}$ 是一个声望销售阈值。\n\n**步骤1：时期2的优化（后向归纳）**\n\n在时期2，销量 $q_1$ 已经确定。垄断厂商面临一个静态优化问题，其需求截距为给定的 $A_2^{\\text{eff}}(q_1)$。时期2的利润是 $\\pi_2(q_2) = (A_2^{\\text{eff}}(q_1) - B_2 q_2 - c)q_2$。\n关于 $q_2$ 对 $\\pi_2$ 求最大化的一阶条件产生了标准的垄断产量：\n$$ q_2^\\star(q_1) = \\max\\left\\{0, \\frac{A_2^{\\text{eff}}(q_1) - c}{2B_2}\\right\\} $$\n由此产生的时期2的最大化利润，作为 $q_1$ 的函数，是：\n$$ \\pi_2^\\star(q_1) = \\frac{\\left(\\max\\{0, A_2^{\\text{eff}}(q_1) - c\\}\\right)^2}{4B_2} $$\n\n**步骤2：时期1的优化**\n\n厂商在预期到时期2的最优反应后，在时期1选择 $q_1 \\ge 0$ 以最大化总贴现利润函数，该函数现在仅依赖于 $q_1$：\n$$ \\Pi(q_1) = (A_1 - B_1 q_1 - c)q_1 + \\beta \\pi_2^\\star(q_1) $$\n代入 $\\pi_2^\\star(q_1)$ 和 $A_2^{\\text{eff}}(q_1)$ 的表达式：\n$$ \\Pi(q_1) = (A_1 - B_1 q_1 - c)q_1 + \\frac{\\beta}{4B_2} \\left(\\max\\{0, A_2 - c - d \\cdot \\max\\{0, q_1 - q_{\\text{bar}}\\}\\}\\right)^2 $$\n这个目标函数是连续的，但分段可微。不可微点（拐点）出现在 $q_1 = q_{\\text{bar}}$ 处，以及可能在 $A_2 - c - d(q_1 - q_{\\text{bar}}) = 0$ 处，即 $q_1 = q_{\\text{crit}} \\equiv q_{\\text{bar}} + (A_2-c)/d$（对于 $d > 0$ 和 $A_2 > c$）。函数 $\\Pi(q_1)$ 由最多三个二次函数段组成。\n\n**步骤3：寻找全局最大值**\n\n为了找到这个连续分段函数的全局最大值，我们必须在所有候选点上对其进行求值。这些点包括每个平滑段内导数为零的点（驻点）以及拐点本身。最优产量 $q_1^\\star$ 的候选集构建如下：\n1.  **边界点和拐点**：点 $q_1=0$（非负约束）、声望阈值 $q_1 = q_{\\text{bar}}$，以及稀释至零利润点 $q_1 = q_{\\text{crit}}$ 都是最优值的潜在候选点。\n2.  **驻点**：我们在每个平滑区域内通过将导数 $\\frac{d\\Pi}{dq_1}$ 设为零来找到驻点。\n    -   对于 $0 \\le q_1 < q_{\\text{bar}}$，目标函数简化，其驻点是标准的静态垄断产量 $q_{S1} = (A_1-c)/(2B_1)$。\n    -   对于 $q_{\\text{bar}} < q_1 < q_{\\text{crit}}$，导数会导出一个不同的驻点，我们称之为 $q_{S2}$：\n        $$ q_{S2} = \\frac{2B_2(A_1 - c) - \\beta d(A_2 - c + dq_{\\text{bar}})}{4B_1B_2 - \\beta d^2} $$\n        该点仅当其落在其有效区域内，并且分母 $4B_1B_2 - \\beta d^2$ 不为零时，才是一个候选点。如果分母为负，目标函数在此区间是局部凸的，那么该段的最大值必定位于其边界（$q_{\\text{bar}}$ 或 $q_{\\text{crit}}$）。\n    -   对于 $q_1 > q_{\\text{crit}}$，时期2的利润为零。目标函数再次变为时期1的利润函数，其驻点为 $q_{S1}$。\n\n算法方法是构建一个包含所有此类候选点的集合，确保包含了所有的拐点和所有相关的可行驻点（$q_1 \\ge 0$）。然后，我们在每个候选点上评估总利润函数 $\\Pi(q_1)$。产生最高利润的 $q_1$ 值即为最优产量 $q_1^\\star$。\n\n**步骤4：计算最终结果**\n\n一旦确定了最优的 $q_1^\\star$，其余的均衡值按如下方式计算：\n-   时期1价格：$p_1^\\star = A_1 - B_1 q_1^\\star$。\n-   时期2有效截距：$A_{2, \\text{eff}}^\\star = A_2 - d \\cdot \\max\\{0, q_1^\\star - q_{\\text{bar}}\\}$。\n-   时期2产量：$q_2^\\star = \\max\\{0, (A_{2, \\text{eff}}^\\star - c) / (2B_2)\\}$。\n-   时期2价格：如果 $q_2^\\star > 0$，$p_2^\\star = (A_{2, \\text{eff}}^\\star + c) / 2$。如果 $q_2^\\star = 0$，市场出清价格是阻断价格 $p_2^\\star = A_{2, \\text{eff}}^\\star$。\n-   总贴现利润：$\\Pi^\\star = (p_1^\\star - c)q_1^\\star + \\beta (p_2^\\star - c)q_2^\\star$。\n\n对于给定的问题结构，这一系统性程序保证能找到唯一的利润最大化结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-period monopoly problem with brand dilution for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # (A1, B1, A2, B2, c, q_bar, d, beta)\n        (100.0, 1.0, 120.0, 1.5, 10.0, 20.0, 0.8, 0.95),\n        (100.0, 1.0, 120.0, 1.5, 10.0, 80.0, 0.8, 0.95),\n        (50.0, 1.0, 8.0, 1.2, 10.0, 20.0, 1.0, 0.9),\n        (80.0, 1.0, 100.0, 0.5, 20.0, 15.0, 3.5, 0.9),\n    ]\n\n    all_results = []\n\n    for params in test_cases:\n        result = _solve_single_case(params)\n        all_results.append([f\"{x:.6f}\" for x in result])\n\n    # Format the final output string as a list of lists.\n    output_str = \"[\" + \",\".join([f\"[{','.join(res)}]\" for res in all_results]) + \"]\"\n    print(output_str)\n\ndef _calculate_total_profit(q1, params):\n    \"\"\"\n    Helper function to calculate total discounted profit for a given q1.\n    \"\"\"\n    A1, B1, A2, B2, c, q_bar, d, beta = params\n\n    if q1 < 0:\n        return -np.inf\n\n    # Period 1 profit\n    pi1 = (A1 - B1 * q1 - c) * q1\n    \n    # Period 2 effective demand intercept\n    A2_eff = A2 - d * max(0, q1 - q_bar)\n\n    # Optimal period 2 profit\n    pi2_opt = 0.0\n    if A2_eff > c:\n        # Standard monopoly profit formula: (A-c)^2 / (4B)\n        pi2_opt = (A2_eff - c)**2 / (4 * B2)\n\n    return pi1 + beta * pi2_opt\n\n\ndef _solve_single_case(params):\n    \"\"\"\n    Solves a single instance of the monopolist problem.\n    \"\"\"\n    A1, B1, A2, B2, c, q_bar, d, beta = params\n\n    # The optimal q1 must be one of the critical points of the piecewise objective function.\n    # We collect all such candidates and evaluate the profit at each.\n    candidates = {0.0, q_bar}\n    \n    # Candidate from static profit maximization in period 1\n    if A1 > c:\n        q_s1 = (A1 - c) / (2 * B1)\n        candidates.add(q_s1)\n\n    # Candidates related to the dilution mechanism\n    if d > 0 and A2 > c:\n        # Kink point where period 2 profit becomes zero due to dilution\n        q_crit = q_bar + (A2 - c) / d\n        candidates.add(q_crit)\n        \n        # Stationary point in the dilution region (q_bar < q1 < q_crit)\n        denom = 4 * B1 * B2 - beta * d**2\n        if abs(denom) > 1e-12: # Avoid division by zero\n            num = 2 * B2 * (A1 - c) - beta * d * (A2 - c + d * q_bar)\n            q_s2 = num / denom\n            candidates.add(q_s2)\n\n    max_profit = -np.inf\n    q1_star = 0.0\n\n    # Feasibility limit for q1 (where price becomes zero)\n    q1_max_feasible = A1 / B1 if B1 > 0 else np.inf\n\n    for q1_cand in candidates:\n        # Only consider physically and economically meaningful candidates\n        if q1_cand < 0 or q1_cand > q1_max_feasible + 1e-9:\n            continue\n        \n        current_profit = _calculate_total_profit(q1_cand, params)\n        \n        if current_profit > max_profit:\n            max_profit = current_profit\n            q1_star = q1_cand\n\n    # Calculate final equilibrium values based on the optimal q1_star\n    p1_star = A1 - B1 * q1_star\n    A2_eff_star = A2 - d * max(0, q1_star - q_bar)\n    \n    if A2_eff_star > c:\n        q2_star = (A2_eff_star - c) / (2 * B2)\n        p2_star = (A2_eff_star + c) / 2\n    else:\n        q2_star = 0.0\n        # If no production, the market clearing price is the choke price\n        p2_star = A2_eff_star\n\n    # Recalculate final total profit for precision\n    pi1_star = (p1_star - c) * q1_star\n    pi2_star = (p2_star - c) * q2_star\n    Pi_star = pi1_star + beta * pi2_star\n\n    return [q1_star, q2_star, p1_star, p2_star, Pi_star]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2422445"}, {"introduction": "本练习将我们带入计算经济学的前沿，模拟一个信息不完全的古诺双寡头市场。与依赖完全理性假设的传统模型不同，这里的企业通过一种“强化学习”算法，在与对手的持续互动中“学习”如何制定产量决策。通过构建这个基于主体的模拟，你将亲身体验市场均衡如何从简单的学习规则中涌现出来，并掌握一种分析复杂战略互动的新工具。[@problem_id:2422430]", "problem": "考虑一个具有反需求函数和恒定边际成本的同质商品古诺（Cournot）双寡头模型。时间是离散的。在每个时期，两家厂商同时选择非负的产量，并从实现的市场价格中获得利润。厂商均不知道竞争对手的行为。相反，每家厂商仅根据其实现的利润，通过更新与每个可行产量水平相关的内部价值，来随时间调整自身的产量。\n\n模型基本要素与时序如下。\n\n1. 市场环境。\n- 每个时期 $t$ 的反需求函数为 $p_t = \\max\\{0, a - b(q_{1,t} + q_{2,t})\\}$，其中 $a \\gt 0$，$b \\gt 0$，$q_{i,t} \\ge 0$ 是厂商 $i$ 在时期 $t$ 的产量。\n- 厂商 $i$ 的边际成本为恒定的 $c_i \\ge 0$，因此其在时期 $t$ 的利润为 $\\pi_{i,t} = (p_t - c_i)\\,q_{i,t}$。\n\n2. 行动空间离散化。\n- 固定产能 $Q_{\\max} \\gt 0$ 和整数网格大小 $M \\ge 2$。每家厂商的可行行动集是大小为 $M$ 的网格 $\\mathcal{A} = \\{0, \\Delta, 2\\Delta, \\dots, Q_{\\max}\\}$，其中 $\\Delta = Q_{\\max}/(M-1)$。\n\n3. 学习动态。\n- 每家厂商 $i \\in \\{1,2\\}$ 维护一个行动价值向量 $Q_i \\in \\mathbb{R}^M$，其所有索引 $m \\in \\{0,1,\\dots,M-1\\}$ 的初始值均为 $Q_i[m] = 0$。\n- 对于每个时期 $t \\in \\{1,2,\\dots,T\\}$：\n    - 每家厂商使用带有温度参数 $\\tau \\gt 0$ 的 softmax 选择规则独立地抽取其行动：\n    $$\\mathbb{P}\\{a_{i,t} = m\\} = \\frac{\\exp\\!\\left(Q_i[m]/\\tau\\right)}{\\sum_{j=0}^{M-1} \\exp\\!\\left(Q_i[j]/\\tau\\right)}, \\quad m \\in \\{0,1,\\dots,M-1\\}.$$\n    - 如果 $a_{i,t} = m$，则对应的产量为 $q_{i,t} = m\\Delta$。\n    - 市场价格 $p_t$ 和利润 $\\pi_{i,t}$ 根据需求和成本基本要素得以实现。\n    - 每家厂商使用学习率为 $\\alpha \\in (0,1]$ 的新近度加权规则，仅更新其所执行的行动的价值：\n    $$Q_i[a_{i,t}] \\leftarrow (1 - \\alpha)\\,Q_i[a_{i,t}] + \\alpha\\,\\pi_{i,t}.$$\n    - 在该时期，$Q_i$ 的所有其他分量保持不变。\n- 所有随机抽样都将从一个伪随机数生成器生成，并为确保可复现性指定一个整数种子。\n\n4. 性能度量。\n- 在 $T$ 个时期之后，为每家厂商计算最后 $W$ 个时期的平均产量：\n$$\\overline{q_i} = \\frac{1}{W} \\sum_{t=T-W+1}^{T} q_{i,t}, \\quad i \\in \\{1,2\\},$$\n其中 $W \\in \\{1,2,\\dots,T\\}$ 是给定的。对于每组参数，所需的输出是两个平均值 $(\\overline{q_1}, \\overline{q_2})$。\n\n实现要求。\n\n- 使用上述确切的动态过程。使用所述的确切 softmax 选择概率和确切的价值更新规则。对所有 $t$ 使用 $p_t = \\max\\{0, a - b(q_{1,t}+q_{2,t})\\}$。\n- 对每个测试用例使用指定的伪随机数生成器种子进行所有行动抽取，并在每个测试用例开始时将生成器重新初始化为此种子。\n- 对于每个测试用例，报告四舍五入到 $4$ 位小数的数对 $(\\overline{q_1}, \\overline{q_2})$。\n\n测试套件。\n\n对于下面的每一行，元组为 $(a, b, c_1, c_2, Q_{\\max}, M, \\alpha, \\tau, T, W, \\text{seed})$。\n\n- 案例 A（对称，内部基准）：$(100.0, 1.0, 10.0, 10.0, 100.0, 51, 0.10, 1.00, 20000, 5000, 2023)$。\n- 案例 B（非对称成本）：$(100.0, 1.0, 10.0, 40.0, 100.0, 51, 0.10, 1.00, 20000, 5000, 2024)$。\n- 案例 C（近边界高成本）：$(50.0, 1.5, 45.0, 45.0, 60.0, 61, 0.15, 0.80, 20000, 5000, 2025)$。\n- 案例 D（产能紧张）：$(60.0, 2.0, 5.0, 5.0, 10.0, 21, 0.10, 0.70, 20000, 5000, 2026)$。\n\n最终输出格式。\n\n- 您的程序应生成单行输出，其中包含案例 A-D 的结果，格式为长度为 $4$ 的逗号分隔列表，其中每个元素本身是一个双元素列表 $[\\overline{q_1}, \\overline{q_2}]$。该行必须是单个 Python 风格的列表字面量，每个平均值四舍五入到 $4$ 位小数，例如：\n$[[x_{A,1}, x_{A,2}],[x_{B,1}, x_{B,2}],[x_{C,1}, x_{C,2}],[x_{D,1}, x_{D,2}]]$.", "solution": "问题陈述需要进行验证。\n\n### 步骤 1：提取已知条件\n\n- **市场模型**：同质商品古诺（Cournot）双寡头。\n- **反需求函数**：$p_t = \\max\\{0, a - b(q_{1,t} + q_{2,t})\\}$，参数为 $a > 0$，$b > 0$。\n- **厂商产量**：$q_{i,t} \\ge 0$ 为厂商 $i \\in \\{1,2\\}$ 在时期 $t$ 的产量。\n- **成本结构**：厂商 $i$ 的边际成本为恒定的 $c_i \\ge 0$。\n- **利润函数**：$\\pi_{i,t} = (p_t - c_i)\\,q_{i,t}$。\n- **行动空间**：一个离散网格 $\\mathcal{A} = \\{0, \\Delta, 2\\Delta, \\dots, Q_{\\max}\\}$，大小为 $M \\ge 2$，其中 $Q_{\\max} > 0$ 是产能上限，$\\Delta = Q_{\\max}/(M-1)$。\n- **学习模型**：每家厂商 $i$ 维护一个行动价值向量 $Q_i \\in \\mathbb{R}^M$。\n- **初始化**：在 $t=0$ 时，对所有 $m \\in \\{0, \\dots, M-1\\}$，$Q_i[m] = 0$。\n- **模拟时域**：$t \\in \\{1, 2, \\dots, T\\}$。\n- **行动选择**：使用温度参数 $\\tau > 0$ 的 Softmax 选择规则：\n$$ \\mathbb{P}\\{a_{i,t} = m\\} = \\frac{\\exp(Q_i[m]/\\tau)}{\\sum_{j=0}^{M-1} \\exp(Q_i[j]/\\tau)} $$\n- **行动对应的产量**：如果行动 $a_{i,t} = m$，则产量 $q_{i,t} = m\\Delta$。\n- **价值更新规则**：使用学习率 $\\alpha \\in (0,1]$ 的新近度加权平均：\n$$ Q_i[a_{i,t}] \\leftarrow (1 - \\alpha)\\,Q_i[a_{i,t}] + \\alpha\\,\\pi_{i,t} $$\n只更新所选行动的价值。\n- **可复现性**：所有随机抽样必须来自一个为每个测试用例指定了整数种子的伪随机数生成器。\n- **性能指标**：最后 $W$ 个时期的平均产量，其中 $W \\in \\{1, \\dots, T\\}$：\n$$ \\overline{q_i} = \\frac{1}{W} \\sum_{t=T-W+1}^{T} q_{i,t} $$\n- **测试用例**：提供了四组参数 $(a, b, c_1, c_2, Q_{\\max}, M, \\alpha, \\tau, T, W, \\text{seed})$。\n- **输出格式**：最终结果是每个案例的一对 $(\\overline{q_1}, \\overline{q_2})$ 的列表，四舍五入到 4 位小数，格式化为 Python 风格的列表的列表。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n- **科学依据**：该问题描述了一个古诺双寡头模型，其中厂商使用标准的强化学习算法（与 Q-learning 和指数权重相关）来调整其策略。这是计算经济学和博弈论中一个成熟且科学上有效的主题。该模型没有违反任何基本原则。\n- **良定性**：该问题指定了一个完整的计算过程。所有参数、初始条件和动态规则都已明确定义。为每个案例使用带有固定种子的伪随机数生成器确保了模拟是确定性的并产生唯一结果。因此，该问题是良定的。\n- **客观性**：该问题使用精确的数学和算法语言陈述，没有任何主观或模棱两可的术语。\n\n问题陈述通过了所有验证标准。它是科学合理的、良定的、客观的、完整的且计算上可行的。没有矛盾或谬误。\n\n### 步骤 3：结论与行动\n\n该问题**有效**。将提供一个解决方案。\n\n### 算法解决方案\n\n该问题要求实现一个双厂商（双寡头）古诺市场竞争的模拟。两家厂商都作为随时间学习的自主代理人行事。解决方案涉及构建一个进行 $T$ 个时期的离散时间模拟。对于每个测试用例，必须使用指定的参数重新初始化模拟。\n\n解决方案的核心是一个从 $t=1$ 迭代到 $T$ 的循环。对于每次模拟，必须初始化以下对象：\n\n1.  一个使用指定 `seed` 的伪随机数生成器 (RNG)。这对可复现性至关重要。\n2.  离散行动空间 $\\mathcal{A}$，它是一个从 $0$ 到 $Q_{\\max}$ 的 $M$ 个等距产量水平的网格。让它由一个长度为 $M$ 的向量 `actions` 表示，其中 `actions`$[m] = m \\cdot \\Delta$。\n3.  两个行动价值向量 $Q_1$ 和 $Q_2$，大小均为 $M$，初始化为全零。\n4.  两个历史向量 `q1_history` 和 `q2_history`，长度为 $T$，用于存储每个时期中选择的产量。\n\n在每个时期 $t$ 的主循环内部：\n\n1.  **行动选择**：对于每家厂商 $i \\in \\{1,2\\}$，必须选择一个行动。这是一个两步过程：\n    a.  使用当前的行动价值向量 $Q_i$ 和温度参数 $\\tau$ 计算每个行动 $m \\in \\{0, \\dots, M-1\\}$ 的 softmax 概率。为确保数值稳定性，标准做法是在应用指数函数之前，从向量 $Q_i/\\tau$ 的所有元素中减去其最大值。然后概率 $P_i$ 由以下公式给出：\n    $$ v_m = Q_i[m]/\\tau $$\n    $$ P_i[m] = \\frac{\\exp(v_m - \\max(v))}{\\sum_{j=0}^{M-1} \\exp(v_j - \\max(v))} $$\n    b.  使用 RNG 根据概率分布 $P_i$ 抽取一个行动索引 $a_{i,t} \\in \\{0, \\dots, M-1\\}$。\n\n2.  **市场交互**：一旦两家厂商都选择了它们的行动 $a_{1,t}$ 和 $a_{2,t}$，它们各自的产出量就被确定：\n    $$ q_{i,t} = \\text{actions}[a_{i,t}] $$\n    这些产量存储在历史向量中。市场总产量为 $Q_{\\text{total}, t} = q_{1,t} + q_{2,t}$。然后根据反需求函数实现市场价格：\n    $$ p_t = \\max\\{0, a - b \\cdot Q_{\\text{total}, t}\\} $$\n\n3.  **利润计算**：计算每家厂商该时期的利润：\n    $$ \\pi_{i,t} = (p_t - c_i) \\cdot q_{i,t} $$\n\n4.  **价值更新**：每家厂商更新与其刚刚执行的行动相关的价值。对于每家厂商 $i$，更新规则应用于单个元素 $Q_i[a_{i,t}]$：\n    $$ Q_i[a_{i,t}] \\leftarrow (1 - \\alpha) \\cdot Q_i[a_{i,t}] + \\alpha \\cdot \\pi_{i,t} $$\n\n在 $T$ 个时期的模拟循环完成后，计算性能指标。对于每家厂商 $i$，使用存储的 `q_history` 向量计算最后 $W$ 个时期的平均产量 $\\overline{q_i}$。\n\n$$ \\overline{q_i} = \\frac{1}{W} \\sum_{k=T-W}^{T-1} \\text{q\\_history}_i[k] $$\n这两个平均值 $(\\overline{q_1}, \\overline{q_2})$ 四舍五入到 4 位小数。对提供的四个测试用例中的每一个都重复此整个过程。最终输出是将所有案例的结果汇总到指定的列表的列表格式中。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Cournot duopoly learning simulation for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Case A (symmetric, interior benchmark)\n        (100.0, 1.0, 10.0, 10.0, 100.0, 51, 0.10, 1.00, 20000, 5000, 2023),\n        # Case B (asymmetric costs)\n        (100.0, 1.0, 10.0, 40.0, 100.0, 51, 0.10, 1.00, 20000, 5000, 2024),\n        # Case C (near-boundary high costs)\n        (50.0, 1.5, 45.0, 45.0, 60.0, 61, 0.15, 0.80, 20000, 5000, 2025),\n        # Case D (tight capacity)\n        (60.0, 2.0, 5.0, 5.0, 10.0, 21, 0.10, 0.70, 20000, 5000, 2026),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        a, b, c1, c2, Q_max, M, alpha, tau, T, W, seed = case\n\n        # Initialize pseudo-random number generator for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # 1. Setup\n        # Action space\n        delta = Q_max / (M - 1)\n        actions = np.arange(M) * delta\n        action_indices = np.arange(M)\n\n        # Action-value vectors\n        Q1 = np.zeros(M)\n        Q2 = np.zeros(M)\n\n        # History of quantities\n        q1_history = np.zeros(T)\n        q2_history = np.zeros(T)\n\n        # 2. Simulation Loop\n        for t in range(T):\n            # Firm 1 action selection\n            v1 = Q1 / tau\n            # Numerically stable softmax\n            exp_v1 = np.exp(v1 - np.max(v1))\n            probs1 = exp_v1 / np.sum(exp_v1)\n            action_idx1 = rng.choice(action_indices, p=probs1)\n            q1_t = actions[action_idx1]\n\n            # Firm 2 action selection\n            v2 = Q2 / tau\n            exp_v2 = np.exp(v2 - np.max(v2))\n            probs2 = exp_v2 / np.sum(exp_v2)\n            action_idx2 = rng.choice(action_indices, p=probs2)\n            q2_t = actions[action_idx2]\n            \n            # Store quantities\n            q1_history[t] = q1_t\n            q2_history[t] = q2_t\n\n            # Market price\n            p_t = max(0.0, a - b * (q1_t + q2_t))\n\n            # Profits\n            pi1_t = (p_t - c1) * q1_t\n            pi2_t = (p_t - c2) * q2_t\n\n            # Value update\n            Q1[action_idx1] = (1.0 - alpha) * Q1[action_idx1] + alpha * pi1_t\n            Q2[action_idx2] = (1.0 - alpha) * Q2[action_idx2] + alpha * pi2_t\n\n        # 3. Performance Measure\n        avg_q1 = np.mean(q1_history[-W:])\n        avg_q2 = np.mean(q2_history[-W:])\n\n        # Append rounded results\n        result_pair = [round(avg_q1, 4), round(avg_q2, 4)]\n        all_results.append(result_pair)\n\n    # 4. Final Output Formatting\n    # The format is a string representation of a Python list of lists.\n    # str(list) automatically adds spaces after commas, which is fine for a Python literal.\n    # The scaffold f\"[{','.join(map(str, results))}]\" replicates this behavior.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2422430"}]}