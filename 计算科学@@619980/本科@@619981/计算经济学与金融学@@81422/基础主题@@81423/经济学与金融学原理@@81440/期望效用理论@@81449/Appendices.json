{"hands_on_practices": [{"introduction": "期望效用理论为分析不确定性下的决策提供了一个强大的框架，其应用远远超出了金融领域。第一个练习将挑战你将该理论应用于一个法律情境。通过推导使原告对上法庭和接受和解感到无差异的和解金额，你将亲身体验确定性等价物的概念，并了解风险厌恶如何影响现实世界中的选择。[@problem_id:2391038]", "problem": "一位初始财富为 $W>0$ 的原告面临一个决策：是接受一笔确定的和解金，还是提起诉讼。根据期望效用理论 (EUT)，原告使用恒定相对风险厌恶 (CRRA) 效用函数 $u(x)=\\frac{x^{1-\\gamma}}{1-\\gamma}$ 来评估结果，其中风险厌恶系数 $\\gamma>0$ 且 $\\gamma\\neq 1$，函数定义域为 $x>0$。\n\n如果原告接受金额为 $S\\geq 0$ 的和解，他将产生一笔和解相关成本 $K_{S}\\geq 0$，并最终获得确定的财富 $W+S-K_{S}$。如果原告提起诉讼，法院有 $p\\in(0,1)$ 的概率判决损害赔偿总额 $D>0$，否则判决为零。律师通过风险代理费获得报酬，费率为裁决总额的 $c\\in(0,1)$，因此如果原告胜诉，他将获得损害赔偿净额 $(1-c)D$。提起诉讼会产生一笔由原告承担的诉讼成本 $K_{T}\\geq 0$，无论结果如何都需支付。因此，在诉讼情况下，原告的最终财富有 $p$ 的概率为 $W-K_{T}+(1-c)D$，有 $1-p$ 的概率为 $W-K_{T}$。\n\n假设所有相关的最终财富水平都严格为正：$W-K_{T}>0$，$W-K_{T}+(1-c)D>0$，以及 $W+S-K_{S}>0$。\n\n设 $S^{\\ast}$ 表示在期望效用最大化的前提下，使原告在接受和解与提起诉讼之间无差异的和解金额。请推导 $S^{\\ast}$ 作为参数 $W$、$\\gamma$、$p$、$D$、$c$、$K_{S}$ 和 $K_{T}$ 函数的闭式表达式。你的最终答案必须是单一的解析表达式。不要进行近似计算。", "solution": "在尝试求解之前，需对问题陈述进行验证。\n\n逐字提取已知条件：\n- 初始财富：$W > 0$。\n- 效用函数：$u(x) = \\frac{x^{1-\\gamma}}{1-\\gamma}$，其中 $\\gamma > 0$，$\\gamma \\neq 1$，定义域为 $x > 0$。\n- 和解金额：$S \\geq 0$。\n- 和解成本：$K_S \\geq 0$。\n- 和解后的最终财富：$W + S - K_S$。\n- 诉讼获胜概率：$p \\in (0,1)$。\n- 损害赔偿总额：$D > 0$。\n- 风险代理费率：$c \\in (0,1)$。\n- 损害赔偿净额：$(1-c)D$。\n- 诉讼成本：$K_T \\geq 0$。\n- 诉讼获胜后的最终财富：$W - K_T + (1-c)D$。\n- 诉讼失败后的最终财富：$W - K_T$。\n- 财富为正的假设：$W - K_T > 0$，$W - K_T + (1-c)D > 0$ 和 $W + S - K_S > 0$。\n- 目标：推导无差异和解金额 $S^{\\ast}$ 的闭式表达式。\n\n该问题在科学上基于期望效用理论，这是经济学的一个基本概念。该问题是良定的，所有必要的参数和约束都已定义，从而确保存在唯一解。其语言客观而精确。所有假设，例如最终财富状态为正，都已明确说明，以确保效用函数是定义明确的。因此，该问题是有效的。我们可以开始推导。\n\n核心原则是，如果从确定选项（和解）中获得的效用等于从不确定选项（诉讼）中获得的期望效用，则原告对这两个选项是无差异的。\n\n设 $S^{\\ast}$ 是使原告无差异的和解金额。接受此和解的最终财富是一个确定数额，我们将其表示为 $W_{S^{\\ast}}$。\n$$\nW_{S^{\\ast}} = W + S^{\\ast} - K_S\n$$\n从此确定结果中得到的效用为 $u(W_{S^{\\ast}})$。\n\n如果原告提起诉讼，其结果是一个博弈。设胜诉时的最终财富为 $W_{win}$，败诉时的最终财富为 $W_{lose}$。\n$$\nW_{win} = W - K_T + (1-c)D\n$$\n$$\nW_{lose} = W - K_T\n$$\n获胜的概率为 $p$，失败的概率为 $1-p$。诉讼的期望效用，表示为 $E[u(\\text{诉讼})]$，是各种可能结果效用的概率加权平均值。\n$$\nE[u(\\text{诉讼})] = p \\cdot u(W_{win}) + (1-p) \\cdot u(W_{lose})\n$$\n因此，无差异条件为：\n$$\nu(W_{S^{\\ast}}) = E[u(\\text{诉讼})]\n$$\n将指定的 CRRA 效用函数 $u(x) = \\frac{x^{1-\\gamma}}{1-\\gamma}$ 代入无差异条件，可得：\n$$\n\\frac{(W_{S^{\\ast}})^{1-\\gamma}}{1-\\gamma} = p \\frac{(W_{win})^{1-\\gamma}}{1-\\gamma} + (1-p) \\frac{(W_{lose})^{1-\\gamma}}{1-\\gamma}\n$$\n由于问题陈述 $\\gamma \\neq 1$，分母 $(1-\\gamma)$ 非零，可以通过乘法从所有项中消去。\n$$\n(W_{S^{\\ast}})^{1-\\gamma} = p (W_{win})^{1-\\gamma} + (1-p) (W_{lose})^{1-\\gamma}\n$$\n此方程定义了确定性等价关系。项 $W_{S^{\\ast}}$ 是诉讼博弈的确定性等价财富，并根据和解相关成本进行了调整。为了求解 $W_{S^{\\ast}}$，我们将方程两边同时取 $\\frac{1}{1-\\gamma}$ 次幂。\n$$\nW_{S^{\\ast}} = \\left[ p (W_{win})^{1-\\gamma} + (1-p) (W_{lose})^{1-\\gamma} \\right]^{\\frac{1}{1-\\gamma}}\n$$\n现在，我们代入 $W_{S^{\\ast}}$、$W_{win}$ 和 $W_{lose}$ 的表达式：\n$$\nW + S^{\\ast} - K_S = \\left[ p (W - K_T + (1-c)D)^{1-\\gamma} + (1-p) (W - K_T)^{1-\\gamma} \\right]^{\\frac{1}{1-\\gamma}}\n$$\n最后一步是通过代数方法分离出 $S^{\\ast}$。这是一个简单的重新整理。\n$$\nS^{\\ast} = \\left[ p(W - K_T + (1-c)D)^{1-\\gamma} + (1-p)(W - K_T)^{1-\\gamma} \\right]^{\\frac{1}{1-\\gamma}} - W + K_S\n$$\n该表达式提供了作为给定参数函数的无差异和解金额 $S^{\\ast}$ 所需的闭式形式。所有最终财富状态都严格为正的假设确保了所有被幂运算的项都为正，从而使该表达式有明确定义。", "answer": "$$\n\\boxed{\\left[ p(W - K_T + (1-c)D)^{1-\\gamma} + (1-p)(W - K_T)^{1-\\gamma} \\right]^{\\frac{1}{1-\\gamma}} - W + K_S}\n$$", "id": "2391038"}, {"introduction": "现在我们进入金融领域，这个练习旨在解决一个常见的情景：评估一项复杂的投资。我们将计算一个结构性票据的期望效用，其回报取决于一篮子资产的表现。这个问题将要求你处理正态分布的回报和恒定绝对风险厌恶 (CARA) 效用函数，从而展示如何量化一个风险资产对于特定投资者的价值。[@problem_id:2391039]", "problem": "一位具有恒定绝对风险厌恶 (CARA) 效用函数的投资者，其效用函数定义为 $U(w) = -\\exp(-\\gamma w)$，风险厌恶参数 $\\gamma = 3.0 \\times 10^{-6}$。他考虑购买一份基于一篮子国际股票指数、按面值发行的一年期结构性票据。该投资者将其全部初始财富 $W_{0} = 1.0 \\times 10^{6}$ 用于以 $1.0 \\times 10^{6}$ 的价格购买一张该票据，并且没有其他风险或收入来源。该票据的到期收益为\n$$\nX = N \\left( 1 + \\beta \\sum_{i=1}^{3} w_{i} R_{i} \\right),\n$$\n其中名义本金 $N = 1.0 \\times 10^{6}$，$\\beta = 0.8$，权重为 $(w_{1}, w_{2}, w_{3}) = (0.5, 0.3, 0.2)$，而 $(R_{1}, R_{2}, R_{3})$ 分别是美国、欧洲和新兴市场指数的一年期简单回报率。假设 $(R_{1}, R_{2}, R_{3})$ 服从联合正态分布，其均值向量为\n$$\n\\boldsymbol{\\mu} = \\begin{pmatrix} 0.06 \\\\ 0.04 \\\\ 0.08 \\end{pmatrix}\n$$\n协方差矩阵为\n$$\n\\boldsymbol{\\Sigma} = \\begin{pmatrix}\n0.0225 & 0.0162 & 0.0150 \\\\\n0.0162 & 0.0324 & 0.0225 \\\\\n0.0150 & 0.0225 & 0.0625\n\\end{pmatrix}.\n$$\n投资者的期末财富等于该票据的收益，即 $W_{T} = X$。\n\n在这些假设下，计算预期效用 $\\mathbb{E}[U(W_{T})]$。将最终答案表示为纯数字（无单位），并四舍五入至四位有效数字。", "solution": "该问题陈述已经过验证，具有科学依据，表述清晰且客观。其包含了所有必要信息，无矛盾或歧义。下面开始解答。\n\n投资者的期末财富 $W_{T}$ 等于结构性票据的收益 $X$。该收益由下式给出：\n$$\nW_T = X = N \\left( 1 + \\beta \\sum_{i=1}^{3} w_{i} R_{i} \\right)\n$$\n设该指数篮子的加权平均回报率为 $R_p = \\sum_{i=1}^{3} w_{i} R_{i}$。期末财富可以写成 $R_p$ 的线性函数：\n$$\nW_T = N + N \\beta R_p\n$$\n回报率 $(R_1, R_2, R_3)$ 服从联合正态分布。联合正态随机变量的线性组合也是一个正态分布的随机变量。因此，$R_p$ 服从正态分布。由于 $W_T$ 是 $R_p$ 的线性变换，所以 $W_T$ 也服从正态分布，即 $W_T \\sim \\mathcal{N}(\\mu_{W_T}, \\sigma^2_{W_T})$。\n\n为了求得预期效用，我们必须首先确定此分布的参数：均值 $\\mu_{W_T} = \\mathbb{E}[W_T]$ 和方差 $\\sigma^2_{W_T} = \\text{Var}(W_T)$。\n\n期末财富的均值为：\n$$\n\\mu_{W_T} = \\mathbb{E}[N + N \\beta R_p] = N + N \\beta \\mathbb{E}[R_p]\n$$\n投资组合的预期回报率 $\\mathbb{E}[R_p]$ 是各项资产预期回报率的加权平均值：\n$$\n\\mathbb{E}[R_p] = \\mathbb{E}\\left[\\sum_{i=1}^{3} w_{i} R_{i}\\right] = \\sum_{i=1}^{3} w_{i} \\mathbb{E}[R_{i}] = \\mathbf{w}^T \\boldsymbol{\\mu}\n$$\n根据给定的值 $\\mathbf{w} = \\begin{pmatrix} 0.5 \\\\ 0.3 \\\\ 0.2 \\end{pmatrix}$ 和 $\\boldsymbol{\\mu} = \\begin{pmatrix} 0.06 \\\\ 0.04 \\\\ 0.08 \\end{pmatrix}$：\n$$\n\\mathbb{E}[R_p] = (0.5)(0.06) + (0.3)(0.04) + (0.2)(0.08) = 0.030 + 0.012 + 0.016 = 0.058\n$$\n现在我们可以使用 $N = 1.0 \\times 10^{6}$ 和 $\\beta = 0.8$ 计算 $\\mu_{W_T}$：\n$$\n\\mu_{W_T} = (1.0 \\times 10^{6}) + (1.0 \\times 10^{6})(0.8)(0.058) = 1.0 \\times 10^{6} (1 + 0.0464) = 1,046,400\n$$\n\n期末财富的方差为：\n$$\n\\sigma^2_{W_T} = \\text{Var}(N + N \\beta R_p) = (N \\beta)^2 \\text{Var}(R_p)\n$$\n投资组合回报率的方差 $\\text{Var}(R_p)$ 由下式给出：\n$$\n\\text{Var}(R_p) = \\mathbf{w}^T \\boldsymbol{\\Sigma} \\mathbf{w}\n$$\n其中 $\\boldsymbol{\\Sigma}$ 是回报率的协方差矩阵。我们计算该二次型：\n$$\n\\mathbf{w}^T \\boldsymbol{\\Sigma} = \\begin{pmatrix} 0.5 & 0.3 & 0.2 \\end{pmatrix} \\begin{pmatrix} 0.0225 & 0.0162 & 0.0150 \\\\ 0.0162 & 0.0324 & 0.0225 \\\\ 0.0150 & 0.0225 & 0.0625 \\end{pmatrix}\n$$\n$$\n\\mathbf{w}^T \\boldsymbol{\\Sigma} = \\begin{pmatrix} (0.5)(0.0225) + (0.3)(0.0162) + (0.2)(0.0150) \\\\ (0.5)(0.0162) + (0.3)(0.0324) + (0.2)(0.0225) \\\\ (0.5)(0.0150) + (0.3)(0.0225) + (0.2)(0.0625) \\end{pmatrix}^T\n$$\n$$\n\\mathbf{w}^T \\boldsymbol{\\Sigma} = \\begin{pmatrix} 0.01125 + 0.00486 + 0.003 \\\\ 0.0081 + 0.00972 + 0.0045 \\\\ 0.0075 + 0.00675 + 0.0125 \\end{pmatrix}^T = \\begin{pmatrix} 0.01911 & 0.02232 & 0.02675 \\end{pmatrix}\n$$\n现在，我们将其右乘 $\\mathbf{w}$：\n$$\n\\text{Var}(R_p) = \\mathbf{w}^T \\boldsymbol{\\Sigma} \\mathbf{w} = \\begin{pmatrix} 0.01911 & 0.02232 & 0.02675 \\end{pmatrix} \\begin{pmatrix} 0.5 \\\\ 0.3 \\\\ 0.2 \\end{pmatrix}\n$$\n$$\n\\text{Var}(R_p) = (0.01911)(0.5) + (0.02232)(0.3) + (0.02675)(0.2) = 0.009555 + 0.006696 + 0.005350 = 0.021601\n$$\n现在我们计算 $\\sigma^2_{W_T}$：\n$$\n\\sigma^2_{W_T} = ((1.0 \\times 10^{6})(0.8))^2 (0.021601) = (8.0 \\times 10^5)^2 (0.021601) = (6.4 \\times 10^{11})(0.021601) = 1.382464 \\times 10^{10}\n$$\n\n投资者的效用函数为 $U(W_T) = -\\exp(-\\gamma W_T)$。预期效用为 $\\mathbb{E}[U(W_T)] = \\mathbb{E}[-\\exp(-\\gamma W_T)] = -\\mathbb{E}[\\exp(-\\gamma W_T)]$。项 $\\mathbb{E}[\\exp(t W_T)]$ 是随机变量 $W_T$ 的矩生成函数 (MGF)。对于一个服从正态分布的变量 $W_T \\sim \\mathcal{N}(\\mu_{W_T}, \\sigma^2_{W_T})$，其矩生成函数为 $M_{W_T}(t) = \\exp(\\mu_{W_T} t + \\frac{1}{2}\\sigma^2_{W_T} t^2)$。\n我们在 $t = -\\gamma$ 处计算矩生成函数的值：\n$$\n\\mathbb{E}[\\exp(-\\gamma W_T)] = M_{W_T}(-\\gamma) = \\exp(\\mu_{W_T}(-\\gamma) + \\frac{1}{2}\\sigma^2_{W_T}(-\\gamma)^2) = \\exp(-\\gamma \\mu_{W_T} + \\frac{1}{2}\\gamma^2 \\sigma^2_{W_T})\n$$\n因此，预期效用为：\n$$\n\\mathbb{E}[U(W_T)] = -\\exp\\left(-\\gamma \\mu_{W_T} + \\frac{1}{2}\\gamma^2 \\sigma^2_{W_T}\\right)\n$$\n代入给定的值 $\\gamma = 3.0 \\times 10^{-6}$ 以及计算出的均值和方差：\n指数部分为：\n$$\n-\\gamma \\mu_{W_T} + \\frac{1}{2}\\gamma^2 \\sigma^2_{W_T} = -(3.0 \\times 10^{-6})(1,046,400) + \\frac{1}{2}(3.0 \\times 10^{-6})^2 (1.382464 \\times 10^{10})\n$$\n$$\n= -3.1392 + \\frac{1}{2}(9.0 \\times 10^{-12})(1.382464 \\times 10^{10})\n$$\n$$\n= -3.1392 + (4.5)(1.382464 \\times 10^{-2}) = -3.1392 + 0.06221088 = -3.07698912\n$$\n最后，预期效用为：\n$$\n\\mathbb{E}[U(W_T)] = -\\exp(-3.07698912) \\approx -0.04610142\n$$\n四舍五入到四位有效数字，结果为 $-0.04610$。", "answer": "$$\n\\boxed{-0.04610}\n$$", "id": "2391039"}, {"introduction": "虽然解析解很优美，但许多现实世界的问题需要数值方法来解决。最后一个练习将通过要求你构建一个通用的计算工具来提升你的技能。你将创建一个函数，它能够为任何给定的效用函数和抽奖计算确定性等价物，通过使用数值求根方法，弥合理论定义与实际应用之间的鸿沟。[@problem_id:2391058]", "problem": "你的任务是编写一个完整的、可运行的程序，用于在期望效用理论下计算离散财富抽签的确定性等价。该程序必须定义一个函数，该函数接受一个代表效用函数的任意 Python 可调用对象和一个关于财富结果的离散概率分布，并返回确定性等价。\n\n科学基础是期望效用公理和确定性等价的定义：\n- 设随机财富 $W$ 取离散值 $\\{w_i\\}_{i=1}^n$，其相关概率为 $\\{p_i\\}_{i=1}^n$，其中 $p_i \\ge 0$ 且 $\\sum_{i=1}^n p_i = 1$。\n- 设 $u(\\cdot)$ 是一个严格递增且连续的效用函数。\n- 期望效用为 $E[u(W)] = \\sum_{i=1}^n p_i \\, u(w_i)$。\n- 确定性等价 $\\mathrm{CE}$ 被定义为满足 $u(\\mathrm{CE}) = E[u(W)]$ 的唯一实数。\n\n编程要求：\n- 实现一个函数，其输入为：\n  - 一个 Python 函数句柄 $u(w)$，可实现为接受标量 $w$ 并返回标量 $u(w)$ 的可调用对象。\n  - 一个包含实数的财富值列表或 NumPy 数组 $W = [w_1, \\dots, w_n]$。\n  - 一个包含非负实数的权重列表或 NumPy 数组 $p = [p_1, \\dots, p_n]$。\n- 验证与归一化：\n  - 验证 $p$ 的所有条目均为非负，且至少有一个条目为严格正数。\n  - 如果 $\\sum_i p_i \\neq 1$，则对向量进行归一化，使其总和为 $1$。\n  - 验证 $W$ 和 $p$ 具有相同的长度 $n$。\n- 计算：\n  - 计算 $E[u(W)] = \\sum_{i=1}^n p_i \\, u(w_i)$。\n  - 在 $u(\\cdot)$ 是严格递增且连续的假设下，使用稳健的区间求根方法，在区间 $[ \\min_i w_i, \\max_i w_i ]$ 上求解 $u(c) - E[u(W)] = 0$ 的唯一解 $\\mathrm{CE}$，绝对容差为 $10^{-9}$。如果 $u(\\min_i w_i) = E[u(W)]$ 或 $u(\\max_i w_i) = E[u(W)]$，则返回相应的边界作为确定性等价。\n- 数值单位：没有需要报告的物理单位。所有输出都应为实数。\n- 输出格式：你的程序应生成单行输出，其中包含以下测试套件的确定性等价，格式为用方括号括起来的逗号分隔列表，每个数字四舍五入到 $6$ 位小数。\n\n测试套件（每个要点定义了 $u(\\cdot)$、$W$ 和 $p$）。请确保所有数字都按书面形式精确处理：\n- 测试 $1$ (风险中性)：$u(w) = w$，$W = [0.0, 100.0]$，$p = [0.5, 0.5]$。\n- 测试 $2$ (恒定相对风险厌恶，参数 $\\gamma = 2$)：对于 $w > 0$，$u(w) = \\dfrac{w^{1-\\gamma}}{1-\\gamma}$，当 $\\gamma = 2$ 时等于 $-\\dfrac{1}{w}$。使用 $W = [50.0, 150.0]$，$p = [0.3, 0.7]$。\n- 测试 $3$ (恒定绝对风险厌恶，参数 $a = 0.05$)：对于所有实数 $w$，$u(w) = -\\exp(-a w)$。使用 $W = [-50.0, 50.0]$，$p = [0.5, 0.5]$。\n- 测试 $4$ (退化分布，对数效用)：对于 $w > 0$，$u(w) = \\ln(w)$。使用 $W = [80.0]$，$p = [1.0]$。\n- 测试 $5$ (平方根效用，未归一化权重)：对于 $w \\ge 0$，$u(w) = \\sqrt{w}$。使用 $W = [25.0, 100.0, 400.0]$，$p = [1.0, 1.0, 2.0]$。\n\n最终输出规范：\n- 程序应按所列顺序计算五个测试中的每一个的确定性等价，并将它们作为 Python 风格的列表单行输出：\n  - 将每个确定性等价四舍五入到 $6$ 位小数。\n  - 确切的所需格式为单行：\n  - 示例格式：$\\texttt{[x\\_1,x\\_2,x\\_3,x\\_4,x\\_5]}$，其中 $x_i$ 是四舍五入后的数字，无额外文本。", "solution": "问题陈述已经过严格验证。\n\n**第一步：提取已知信息**\n- **主题**：期望效用理论，确定性等价。\n- **定义**：\n  - 一个离散随机财富变量 $W$ 取值为 $\\{w_i\\}_{i=1}^n$，其概率为 $\\{p_i\\}_{i=1}^n$。\n  - 约束条件: $p_i \\ge 0$ 且 $\\sum_{i=1}^n p_i = 1$。\n  - 效用函数 $u(\\cdot)$ 是严格递增且连续的。\n  - 期望效用: $E[u(W)] = \\sum_{i=1}^n p_i \\, u(w_i)$。\n  - 确定性等价 ($\\mathrm{CE}$): 满足 $u(\\mathrm{CE}) = E[u(W)]$ 的值。\n- **编程要求**：\n  - 一个函数必须接受一个可调用的效用函数 $u$，一个财富列表/数组 $W$，以及一个权重列表/数组 $p$。\n  - **验证**：\n    - 所有的 $p_i$ 都必须是非负的。\n    - 至少有一个 $p_i$ 必须是严格正数。\n    - 如果向量 $p$ 的总和不为 $1$，则必须对其进行归一化。\n    - $W$ 和 $p$ 必须有相同的长度。\n  - **计算**：\n    - 通过求解 $u(c) - E[u(W)] = 0$ 来找到 $\\mathrm{CE}$。\n    - 在区间 $[\\min_i w_i, \\max_i w_i]$ 上使用区间求根方法。\n    - 使用 $10^{-9}$ 的绝对容差。\n    - 处理 $\\mathrm{CE}$ 位于区间边界的情况。\n- **测试套件**：\n  - **测试 $1$**：$u(w) = w$，$W = [0.0, 100.0]$，$p = [0.5, 0.5]$。\n  - **测试 $2$**：$u(w) = \\frac{w^{1-\\gamma}}{1-\\gamma}$，其中 $\\gamma = 2$ (因此 $u(w) = -w^{-1}$)，$W = [50.0, 150.0]$，$p = [0.3, 0.7]$。\n  - **测试 $3$**：$u(w) = -\\exp(-a w)$，其中 $a = 0.05$，$W = [-50.0, 50.0]$，$p = [0.5, 0.5]$。\n  - **测试 $4$**：$u(w) = \\ln(w)$，$W = [80.0]$，$p = [1.0]$。\n  - **测试 $5$**：$u(w) = \\sqrt{w}$，$W = [25.0, 100.0, 400.0]$，$p = [1.0, 1.0, 2.0]$。\n- **输出格式**：单行，用方括号括起来的逗号分隔列表，每个值四舍五入到 $6$ 位小数。\n\n**第二步：使用提取的已知信息进行验证**\n根据所需标准对问题进行评估：\n- **科学依据**：该问题基于 von Neumann-Morgenstern 期望效用理论，这是经济学、金融学和决策理论中的一个基本概念。所提供的定义和效用函数都是标准的。\n- **适定性 (Well-Posed)**：该问题是适定的。效用函数 $u(\\cdot)$ 是严格递增且连续的先验假设保证了唯一确定性等价 $\\mathrm{CE}$ 的存在。令待求解的函数为 $f(c) = u(c) - E[u(W)]$。期望效用 $E[u(W)]$ 是值 $\\{u(w_i)\\}$ 的凸组合。鉴于 $u$ 是严格递增的，对于所有的 $i$，我们有 $u(\\min(W)) \\le u(w_i) \\le u(\\max(W))$。因此，$u(\\min(W)) \\le E[u(W)] \\le u(\\max(W))$。这意味着 $f(\\min(W)) \\le 0$ 和 $f(\\max(W)) \\ge 0$。根据介值定理，在区间 $[\\min(W), \\max(W)]$ 内必定存在一个根。$u(\\cdot)$ 的严格单调性确保了此根是唯一的。\n- **客观性**：该问题使用精确、客观的数学和计算语言进行陈述。\n- **缺陷**：未发现与科学不健全、不完整、矛盾或含糊不清相关的缺陷。该问题是计算经济学中一个标准的、可形式化的练习。\n\n**第三步：结论与行动**\n该问题是**有效的**。将构建一个解决方案。\n\n**基于原则的设计**\n\n任务是为一个给定的关于财富结果的离散抽签找到其确定性等价 $\\mathrm{CE}$。一个抽签由一组可能的财富结果 $W = \\{w_1, w_2, \\dots, w_n\\}$ 及其相应的概率 $P_s = \\{p_1, p_2, \\dots, p_n\\}$ 定义。问题陈述允许使用未归一化的权重，我们将首先将其归一化为一个有效的概率分布 $\\tilde{P} = \\{\\tilde{p}_1, \\tilde{p}_2, \\dots, \\tilde{p}_n\\}$，其中 $\\tilde{p}_i = p_i / \\sum_{j=1}^n p_j$。\n\n问题的核心在于期望效用理论。对于一个给定的效用函数 $u(w)$，它量化了个体对某一财富水平 $w$ 的偏好，该抽签的期望效用是每个可能结果效用的加权平均值：\n$$\nE[u(W)] = \\sum_{i=1}^n \\tilde{p}_i u(w_i)\n$$\n确定性等价 $\\mathrm{CE}$ 是指能提供与抽签的期望效用相同效用水平的确定性财富数量。其由以下方程正式定义：\n$$\nu(\\mathrm{CE}) = E[u(W)]\n$$\n如果逆效用函数 $u^{-1}(\\cdot)$ 已知且易于计算，则可以直接求得 $\\mathrm{CE}$：\n$$\n\\mathrm{CE} = u^{-1}(E[u(W)])\n$$\n然而，对于许多效用函数，其逆函数要么没有封闭的解析形式，要么计算上不方便。该问题要求采用更通用的数值方法：求根。我们定义一个函数 $g(c)$，其根即为所求的确定性等价：\n$$\ng(c) = u(c) - E[u(W)] = 0\n$$\n问题规定 $u(\\cdot)$ 是严格递增且连续的。这保证了 $g(c)$ 也是严格递增且连续的。正如在验证阶段所确立的，在由最小和最大可能财富结果定义的闭区间 $[\\min(W), \\max(W)]$ 内，保证存在一个唯一的根满足 $g(c)=0$。\n\n这种结构使得该问题适合使用区间求根算法，例如 Brent's method，该方法既稳健又高效。算法将系统地缩小搜索区间 $[a, b]$，其中 $g(a)$ 和 $g(b)$ 符号相反，直到在指定的容差内找到根。\n\n因此，计算过程如下：\n1.  **输入验证与归一化**：给定输入 $u$、$W$ 和 $p$，首先确保它们是有效的。将 $W$ 和 $p$ 转换为数值数组。检查长度是否一致。确认 $p$ 中的概率为非负且总和为正值。然后，将 $p$ 归一化以创建一个真实的概率向量 $\\tilde{p}$。\n2.  **处理退化情况**：如果抽签只有一个可能的结果（即 $\\min(W) = \\max(W)$），那么它不是一个抽签，而是一个确定的结果。确定性等价就是这个值。\n3.  **计算期望效用**：计算 $E[u(W)] = \\sum_i \\tilde{p}_i u(w_i)$。这是一个简单的点积运算。\n4.  **数值求解**：\n    a. 定义搜索区间为 $[\\min(W), \\max(W)]$。\n    b. 定义目标函数 $g(c) = u(c) - E[u(W)]$。\n    c. 处理平凡的边界解：如果在很小的机器精度范围内 $g(\\min(W)) \\approx 0$ 或 $g(\\max(W)) \\approx 0$，则相应的边界即为解。\n    d. 使用数值求解器，例如 `scipy.optimize.brentq`，在区间内找到 $g(c)$ 的根，并达到 $10^{-9}$ 的所需绝对容差。\n\n这种结构化的方法保证了正确且稳健的实现，遵循了期望效用理论和数值分析的既定原则。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and compute their certainty equivalents.\n    \"\"\"\n\n    def calculate_certainty_equivalent(u, W, p):\n        \"\"\"\n        Computes the certainty equivalent for a discrete wealth lottery.\n\n        Args:\n            u (callable): A strictly increasing and continuous utility function.\n            W (list or np.ndarray): A list of wealth outcomes.\n            p (list or np.ndarray): A list of corresponding non-negative weights.\n\n        Returns:\n            float: The certainty equivalent.\n        \"\"\"\n        # 1. Input Validation and Normalization\n        try:\n            W_arr = np.asarray(W, dtype=float)\n            p_arr = np.asarray(p, dtype=float)\n        except Exception as e:\n            raise TypeError(f\"Inputs W and p must be convertible to numeric arrays. Error: {e}\")\n\n        if W_arr.ndim != 1 or p_arr.ndim != 1:\n            raise ValueError(\"Inputs W and p must be 1-dimensional arrays.\")\n        \n        if len(W_arr) != len(p_arr):\n            raise ValueError(\"Wealth outcomes (W) and weights (p) must have the same length.\")\n\n        if np.any(p_arr < 0):\n            raise ValueError(\"All probability weights in p must be non-negative.\")\n\n        p_sum = np.sum(p_arr)\n        if p_sum <= 0:\n            raise ValueError(\"The sum of probability weights must be strictly positive.\")\n\n        # Normalize probabilities\n        p_norm = p_arr / p_sum\n\n        # 2. Handle Degenerate Case\n        w_min, w_max = np.min(W_arr), np.max(W_arr)\n        if np.isclose(w_min, w_max):\n            return w_min\n\n        # 3. Compute Expected Utility\n        u_values = np.array([u(w) for w in W_arr])\n        expected_utility = np.dot(p_norm, u_values)\n\n        # 4. Numerical Solution\n        # Define the objective function for the root-finder\n        def g(c):\n            return u(c) - expected_utility\n\n        # The root is guaranteed to be in [w_min, w_max] because u is monotonic.\n        # Check boundary solutions as per problem spec\n        if np.isclose(g(w_min), 0.0):\n            return w_min\n        if np.isclose(g(w_max), 0.0):\n            return w_max\n        \n        # Use Brent's method for robust root-finding\n        try:\n            # xtol is the absolute tolerance on the root\n            ce = brentq(g, w_min, w_max, xtol=1e-9)\n        except ValueError:\n            # This should not happen if u is strictly increasing\n            raise RuntimeError(\n                \"Root-finding failed. The bracket [min(W), max(W)] might be invalid, \"\n                \"which implies the utility function is not strictly increasing.\"\n            )\n\n        return ce\n\n    # Define utility functions for the test suite\n    u1 = lambda w: w\n    \n    gamma = 2.0\n    u2 = lambda w: (w**(1.0 - gamma)) / (1.0 - gamma) if w > 0 else -np.inf\n\n    a = 0.05\n    u3 = lambda w: -np.exp(-a * w)\n    \n    u4 = lambda w: np.log(w) if w > 0 else -np.inf\n    \n    u5 = lambda w: np.sqrt(w) if w >= 0 else -np.inf\n\n    # Test suite from the problem description\n    test_cases = [\n        (u1, [0.0, 100.0], [0.5, 0.5]),\n        (u2, [50.0, 150.0], [0.3, 0.7]),\n        (u3, [-50.0, 50.0], [0.5, 0.5]),\n        (u4, [80.0], [1.0]),\n        (u5, [25.0, 100.0, 400.0], [1.0, 1.0, 2.0]),\n    ]\n\n    results = []\n    for u_func, W, p in test_cases:\n        ce = calculate_certainty_equivalent(u_func, W, p)\n        results.append(f\"{ce:.6f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2391058"}]}