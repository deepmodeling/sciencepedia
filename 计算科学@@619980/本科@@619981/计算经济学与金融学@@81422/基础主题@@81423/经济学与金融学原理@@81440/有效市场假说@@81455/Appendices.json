{"hands_on_practices": [{"introduction": "有效市场假说（EMH）的弱式有效形式是最基本也是最常被检验的一个版本，它主张资产的未来回报无法通过其历史价格信息来预测。本练习将带领您通过编写程序来模拟和检验时间序列的弱式有效性，让您亲手实践检验EMH的核心统计方法 [@problem_id:2389249]。您将学习如何使用标准的计量经济学工具，如Ljung-Box检验和自回归模型，来区分一个随机游走过程（有效市场）和一个具有可预测性的过程（无效市场）。", "problem": "考虑一个区块链在等时间间隔内的每字节平均交易费用的离散时间序列。设严格为正的费用水平在时间索引 $t \\in \\{0,1,2,\\dots,n\\}$ 时表示为 $f_t$，并定义对数费用 $y_t = \\ln(f_t)$。单步对数回报率为 $r_t = y_t - y_{t-1}$，其中 $t \\in \\{1,2,\\dots,n\\}$。在弱式有效市场假说（EMH）下，相对于由过去值生成的信息集，过程 $\\{r_t\\}$ 是一个鞅差序列，这意味着 $E[r_t \\mid \\mathcal{I}_{t-1}] = 0$，并且对于 $\\{r_{t-1}, r_{t-2}, \\dots\\}$ 具有零线性可预测性。等价地，在弱式EMH下，$\\{r_t\\}$ 的所有非零滞后自相关系数均为零，并且基于 $r_{t-1}$ 的 $r_t$ 的最佳线性单步预测器的斜率为零。\n\n您的任务是编写一个完整的程序，对以下每个测试案例，根据指定的数据生成过程模拟费用序列 $\\{f_t\\}$，计算回报序列 $\\{r_t\\}$，然后在一个给定的显著性水平下，将该序列分类为弱式有效或非弱式有效。一个序列当且仅当在所陈述的显著性水平 $\\alpha$ 下，数据支持以下两个属性时，才必须被分类为弱式有效：(i) 所有滞后至 $m$ 阶的自相关系数均为零的联合原假设不被拒绝，以及 (ii) 基于 $r_{t-1}$ 的 $r_t$ 的最佳线性预测器中的斜率系数为零的原假设不被拒绝。否则，将该序列分类为非弱式有效。\n\n模拟应按以下方式进行。对于每个测试案例，将初始水平固定为 $f_0 = 100.0$。对于所有随机模拟，使用固定的随机种子 $123456$，以确保结果是可复现的。有两种过程设定：\n- 对数费用的随机游走（表示为RW）：$y_t = y_{t-1} + \\varepsilon_t$，其中 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$ 在时间 $t$ 上独立，这意味着 $r_t = \\varepsilon_t$。\n- 回报率的一阶自回归（表示为AR1）：$r_t = \\phi r_{t-1} + \\varepsilon_t$，其中 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$ 在时间 $t$ 上独立，并且 $y_t = y_{t-1} + r_t$。对于此情况，使用 $200$ 步的“预烧期”（burn-in），这些步骤将被丢弃，以便在收集 $n$ 个保留的观测值之前近似 $\\{r_t\\}$ 的平稳性。对于 RW，不需要预烧期。\n\n对于每个测试案例，在模拟 $\\{f_t\\}$ 和计算 $\\{r_t\\}$ 之后，应用在高斯鞅差新息的原假设下有效的统计决策规则，以确定是否在显著性水平 $\\alpha$ 下拒绝这两个属性中的每一个。使用以下测试套件，其中每个案例由元组 $(S, n, \\sigma, \\phi, \\alpha, m)$ 给出，当 $S=\\text{RW}$ 时忽略 $\\phi$：\n- 案例 A: $(\\text{RW},\\, 500,\\, 0.02,\\, 0.0,\\, 0.01,\\, 10)$\n- 案例 B: $(\\text{AR1},\\, 500,\\, 0.02,\\, 0.35,\\, 0.01,\\, 10)$\n- 案例 C: $(\\text{AR1},\\, 80,\\, 0.03,\\, 0.0,\\, 0.01,\\, 8)$\n- 案例 D: $(\\text{AR1},\\, 500,\\, 0.02,\\, -0.5,\\, 0.01,\\, 10)$\n\n您的程序必须输出一行，其中包含案例A到D的四个布尔分类结果，顺序排列，使用方括号括起来的逗号分隔列表的精确格式，无空格，其中每个条目为 True 或 False。例如，所需格式类似于 [True,False,True,False]。", "solution": "在弱式有效市场假说（EMH）下，对数费用增量 $r_t = y_t - y_{t-1}$ 构成了相对于自然信息流的鞅差序列（MDS）。形式上，这表示为 $E[r_t \\mid \\mathcal{I}_{t-1}] = 0$ 对所有 $t$ 成立，其中 $\\mathcal{I}_{t-1}$ 是由过去观测值生成的 sigma-代数。该陈述的两个可操作的含义是：(i) 非零滞后的自相关函数为零，以及 (ii) 基于 $r_{t-1}$ 的 $r_t$ 的最佳线性预测器的斜率为零。\n\n数据生成。对于随机游走（RW）设定，对数费用遵循 $y_t = y_{t-1} + \\varepsilon_t$，其中 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$ 且 $r_t = \\varepsilon_t$。对于一阶自回归（AR1）设定，回报率遵循 $r_t = \\phi r_{t-1} + \\varepsilon_t$，其中 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$ 且 $y_t = y_{t-1} + r_t$。在所有情况下，费用水平为 $f_t = \\exp(y_t)$ 以确保其为正。对于 AR1，通过生成一个 200 步的“预烧期”（burn-in）来减轻初始化效应，这些步骤将被丢弃，以便当 $|\\phi| < 1$ 时，保留的 $n$ 个观测值近似服从平稳分布。所有随机抽样均使用固定的种子 $123456$ 生成，以确保可复现性。\n\n检验属性(i)：滞后至 $m$ 阶的自相关系数联合为零。给定一个样本 $\\{r_t\\}_{t=1}^n$，定义中心化的回报率 $\\tilde{r}_t = r_t - \\bar{r}$，其中 $\\bar{r} = \\frac{1}{n}\\sum_{t=1}^n r_t$。滞后 $k$ 阶的样本自协方差为 $\\hat{\\gamma}_k = \\frac{1}{n}\\sum_{t=k+1}^n \\tilde{r}_t \\tilde{r}_{t-k}$，滞后零阶的自协方差为 $\\hat{\\gamma}_0 = \\frac{1}{n}\\sum_{t=1}^n \\tilde{r}_t^2$。滞后 $k$ 阶的样本自相关系数为 $\\hat{\\rho}_k = \\hat{\\gamma}_k / \\hat{\\gamma}_0$。一个将这些直至滞后 $m$ 阶的自相关系数汇总起来的综合统计量是 Ljung–Box 统计量\n$$\nQ = n(n+2)\\sum_{k=1}^m \\frac{\\hat{\\rho}_k^2}{n-k}.\n$$\n在滞后 1 到 $m$ 阶自相关为零以及条件同方差性的原假设下，$Q$ 渐近服从 $\\chi^2_m$ 分布。决策规则是计算 $p$ 值 $p_{\\text{LB}} = 1 - F_{\\chi^2_m}(Q)$，如果 $p_{\\text{LB}} < \\alpha$ 则拒绝原假设。\n\n检验属性(ii)：最佳线性单步预测器中的斜率为零。考虑线性模型\n$$\nr_t = \\beta_0 + \\beta_1 r_{t-1} + \\varepsilon_t^{\\ast}, \\quad t=2,\\dots,n,\n$$\n通过普通最小二乘法（OLS）估计。令 $X$ 为 $(n-1)\\times 2$ 矩阵，其一列为1，另一列为滞后回报率 $r_{t-1}$，令 $y$ 为同期的回报率 $r_t$ 的 $(n-1)\\times 1$ 向量。OLS 估计量为 $\\hat{\\beta} = (X^{\\top}X)^{-1}X^{\\top}y$。残差方差为 $\\hat{\\sigma}^2 = \\frac{1}{n-1-2}\\sum_{t=2}^n \\hat{\\varepsilon}_t^2$，其中 $\\hat{\\varepsilon}_t = r_t - \\hat{\\beta}_0 - \\hat{\\beta}_1 r_{t-1}$。$\\hat{\\beta}_1$ 的估计方差是 $\\hat{\\sigma}^2 (X^{\\top}X)^{-1}$ 的 $(2,2)$ 元素，表示为 $\\widehat{\\mathrm{Var}}(\\hat{\\beta}_1)$。检验统计量是\n$$\nt = \\frac{\\hat{\\beta}_1}{\\sqrt{\\widehat{\\mathrm{Var}}(\\hat{\\beta}_1)}},\n$$\n在原假设 $H_0:\\beta_1=0$ 和条件同方差正态误差下，该统计量服从自由度为 $n-3$ 的学生t分布。双边 $p$ 值为 $p_{\\text{REG}} = 2\\left(1 - F_{t_{n-3}}(|t|)\\right)$。如果 $p_{\\text{REG}} < \\alpha$，则拒绝原假设。\n\n分类规则。对于每个案例，在给定的 $\\alpha$ 水平下计算 $p_{\\text{LB}}$ 和 $p_{\\text{REG}}$。当且仅当两个原假设都未被拒绝时，即当且仅当 $p_{\\text{LB}} \\ge \\alpha$ 且 $p_{\\text{REG}} \\ge \\alpha$时，将序列分类为弱式有效。\n\n测试套件参数。每个测试案例由 $(S, n, \\sigma, \\phi, \\alpha, m)$ 指定，其中当 $S=\\text{RW}$ 时忽略 $\\phi$，并且所有模拟均使用 $f_0=100.0$ 和固定种子 $123456$：\n- 案例 A: $(\\text{RW},\\, 500,\\, 0.02,\\, 0.0,\\, 0.01,\\, 10)$，代表对数费用的随机游走，其增量为独立同分布的高斯变量，这在期望上满足弱式EMH。\n- 案例 B: $(\\text{AR1},\\, 500,\\, 0.02,\\, 0.35,\\, 0.01,\\, 10)$，代表正自相关的回报率，由于线性可预测性而违反了弱式EMH。\n- 案例 C: $(\\text{AR1},\\, 80,\\, 0.03,\\, 0.0,\\, 0.01,\\, 8)$，代表不相关的回报率，样本量较小，作为一个边界类型的案例。\n- 案例 D: $(\\text{AR1},\\, 500,\\, 0.02,\\, -0.5,\\, 0.01,\\, 10)$，代表负自相关的回报率，由于线性可预测性而违反了弱式EMH。\n\n最终输出格式。您的程序应生成单行输出，包含案例A到D的四个布尔结果，格式为方括号括起来的逗号分隔列表，无空格，例如：[True,False,True,False]。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2, t as student_t\n\ndef ljung_box_pvalue(returns: np.ndarray, m: int) -> float:\n    \"\"\"\n    Compute the Ljung-Box Q statistic p-value for autocorrelations up to lag m.\n    returns: 1D array of returns r_t\n    m: maximum lag to include\n    \"\"\"\n    r = returns.astype(float)\n    n = r.shape[0]\n    if n <= m + 1:\n        # Not enough data; return p-value of 0 to force non-acceptance.\n        return 0.0\n    r_centered = r - r.mean()\n    gamma0 = np.dot(r_centered, r_centered) / n\n    if gamma0 <= 0:\n        # Degenerate variance: treat as non-acceptance.\n        return 0.0\n    Q = 0.0\n    for k in range(1, m + 1):\n        num = np.dot(r_centered[k:], r_centered[:-k]) / n\n        rho_k = num / gamma0\n        Q += rho_k * rho_k / (n - k)\n    Q *= n * (n + 2)\n    p_val = 1.0 - chi2.cdf(Q, df=m)\n    # Numerical guard\n    if p_val < 0.0:\n        p_val = 0.0\n    if p_val > 1.0:\n        p_val = 1.0\n    return p_val\n\ndef ols_predictability_pvalue(returns: np.ndarray) -> float:\n    \"\"\"\n    Test H0: beta1 = 0 in the regression r_t = beta0 + beta1 * r_{t-1} + e_t.\n    Returns the two-sided p-value based on Student t with n-3 degrees of freedom.\n    \"\"\"\n    r = returns.astype(float)\n    n = r.shape[0]\n    # Need at least 3 observations to compute t-stat with df = n-3 >= 1\n    if n < 4:\n        return 0.0\n    y = r[1:]\n    x = r[:-1]\n    X = np.column_stack([np.ones_like(x), x])\n    XtX = X.T @ X\n    # Check for invertibility\n    try:\n        XtX_inv = np.linalg.inv(XtX)\n    except np.linalg.LinAlgError:\n        return 0.0\n    beta_hat = XtX_inv @ (X.T @ y)\n    residuals = y - X @ beta_hat\n    dof = y.shape[0] - X.shape[1]\n    if dof <= 0:\n        return 0.0\n    rss = float(residuals.T @ residuals)\n    sigma2_hat = rss / dof\n    var_beta = sigma2_hat * XtX_inv\n    se_beta1 = np.sqrt(max(var_beta[1, 1], 0.0))\n    if se_beta1 == 0.0:\n        # No variability; return 0 p-value to avoid false acceptance\n        return 0.0\n    t_stat = beta_hat[1] / se_beta1\n    # Two-sided p-value\n    p_val = 2.0 * (1.0 - student_t.cdf(abs(t_stat), df=dof))\n    # Numerical guard\n    if p_val < 0.0:\n        p_val = 0.0\n    if p_val > 1.0:\n        p_val = 1.0\n    return p_val\n\ndef simulate_series(case, rng: np.random.Generator):\n    \"\"\"\n    Simulate fee levels and returns based on the specified test case.\n    case: tuple (S, n, sigma, phi, alpha, m)\n    rng: numpy Generator for reproducibility\n    Returns: returns array r of length n\n    \"\"\"\n    S, n, sigma, phi, alpha, m = case\n    y0 = np.log(100.0)  # initial log-fee\n    if S == \"RW\":\n        # Random walk in log fees: y_t = y_{t-1} + e_t\n        eps = rng.normal(loc=0.0, scale=sigma, size=n)\n        r = eps  # returns are the innovations\n        # Form y and f if needed (not used directly for tests)\n        # y = y0 + np.cumsum(r)\n        return r\n    elif S == \"AR1\":\n        # AR(1) in returns with burn-in for stationarity\n        burn = 200\n        total = n + burn\n        eps = rng.normal(loc=0.0, scale=sigma, size=total)\n        r_full = np.empty(total, dtype=float)\n        r_full[0] = eps[0]\n        for t in range(1, total):\n            r_full[t] = phi * r_full[t - 1] + eps[t]\n        r = r_full[burn:]\n        return r\n    else:\n        raise ValueError(\"Unknown specification S: {}\".format(S))\n\ndef classify_efficiency(case, rng: np.random.Generator) -> bool:\n    \"\"\"\n    Classify a single test case as weak-form efficient (True) or not (False).\n    \"\"\"\n    S, n, sigma, phi, alpha, m = case\n    r = simulate_series(case, rng)\n    # Property (i): joint zero autocorrelations up to lag m\n    p_lb = ljung_box_pvalue(r, m)\n    # Property (ii): zero slope in linear predictability\n    p_reg = ols_predictability_pvalue(r)\n    # Efficient if both nulls are not rejected at level alpha\n    return (p_lb >= alpha) and (p_reg >= alpha)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"RW\", 500, 0.02, 0.0, 0.01, 10),     # Case A\n        (\"AR1\", 500, 0.02, 0.35, 0.01, 10),   # Case B\n        (\"AR1\", 80, 0.03, 0.0, 0.01, 8),      # Case C\n        (\"AR1\", 500, 0.02, -0.5, 0.01, 10),   # Case D\n    ]\n\n    rng = np.random.default_rng(123456)\n\n    results = []\n    for case in test_cases:\n        result = classify_efficiency(case, rng)\n        results.append(result)\n\n    # Final print statement in the exact required format: booleans without spaces.\n    print(\"[\" + \",\".join(\"True\" if r else \"False\" for r in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2389249"}, {"introduction": "在对有效市场假说的实证研究中，发现了许多所谓的“市场异象”，其中“动量效应”是最著名和最持久的一个。本练习旨在将动量效应这一概念转化为一个可量化的交易策略，并对其进行回测 [@problem_id:2389238]。您将通过计算一个波动率调整后的动量强度指标，来比较加密货币和传统股票市场中动量效应的强弱，从而深入理解如何评估和比较看似能挑战EMH的交易策略。", "problem": "给定一个与有效市场假说 (EMH) 在“动量”异象背景下的研究相关的正式测试任务。对于一个资产，其逐期简单回报率的时间序列为 $\\{r_t\\}_{t=1}^T$，以小数形式表示（例如，百分之一的回报写为 $0.01$），定义一个回看窗口为 $L \\in \\mathbb{N}$ 的动量信号和一个经波动率调整的强度指标如下。\n\n- 对于每个时间索引 $t$ 且 $t \\in \\{L+1, \\ldots, T\\}$，定义回看和 $b_t = \\sum_{i=1}^{L} r_{t-i}$ 以及信号\n$$\ns_t = \n\\begin{cases}\n+1, & \\text{若 } b_t > 0, \\\\\n-1, & \\text{若 } b_t < 0, \\\\\n0, & \\text{若 } b_t = 0.\n\\end{cases}\n$$\n- 在时间 $t$ 的已实现动量策略回报为 $x_t = s_t \\cdot r_t$。\n- 令 $N = T - L$ 表示非预热观测值的数量。定义样本均值 $\\mu = \\frac{1}{N} \\sum_{t=L+1}^{T} x_t$ 和总体标准差 $\\sigma = \\sqrt{\\frac{1}{N} \\sum_{t=L+1}^{T} (x_t - \\mu)^2}$。定义经波动率调整的强度（一个类似于夏普比率的逐期比率）为\n$$\nS =\n\\begin{cases}\n\\mu / \\sigma, & \\text{若 } \\sigma > 0, \\\\\n0, & \\text{若 } \\sigma = 0.\n\\end{cases}\n$$\n\n对于每个测试用例，给定两个等长的回报序列：一个代表加密货币，另一个代表传统股票指数。对于每个测试用例，使用相同的 $L$ 计算 $S_{\\text{crypto}}$ 和 $S_{\\text{equity}}$。使用容差 $\\varepsilon = 10^{-12}$，将强度比较结果分类为一个整数：\n- 如果 $S_{\\text{crypto}} > S_{\\text{equity}} + \\varepsilon$（加密货币更强），输出 $1$。\n- 如果 $\\lvert S_{\\text{crypto}} - S_{\\text{equity}} \\rvert \\le \\varepsilon$（在容差范围内相等），输出 $0$。\n- 如果 $S_{\\text{crypto}} < S_{\\text{equity}} - \\varepsilon$（加密货币更弱），输出 $-1$。\n\n所有回报率都是无量纲的，并且必须作为小数处理，而不是百分比。不使用角度。您的程序必须生成单行输出，其中包含所有测试用例的结果，格式为方括号内以逗号分隔的列表，例如，“[1,0,-1]”。\n\n测试套件：\n- 测试用例 $1$（理想路径，经波动率调整后加密货币动量更强），$L = 2$：\n    - 加密货币回报 $r^{(C)}$: $(0.02, 0.015, 0.018, 0.017, -0.005, 0.02, 0.019, 0.018, 0.017, 0.016, 0.015, 0.014)$，\n    - 股票回报 $r^{(E)}$: $(0.005, -0.006, 0.004, -0.005, 0.003, -0.004, 0.002, -0.003, 0.001, -0.002, 0.001, -0.001)$。\n- 测试用例 $2$（构造性相等），$L = 3$：\n    - 加密货币回报 $r^{(C)}$: $(0.01, -0.005, 0.012, 0.0, 0.008, -0.004, 0.009, -0.003, 0.007, -0.002)$，\n    - 股票回报 $r^{(E)}$: $(0.01, -0.005, 0.012, 0.0, 0.008, -0.004, 0.009, -0.003, 0.007, -0.002)$。\n- 测试用例 $3$（加密货币更弱；股票呈趋势而加密货币交替波动），$L = 2$：\n    - 加密货币回报 $r^{(C)}$: $(0.03, -0.025, 0.03, -0.025, 0.03, -0.025, 0.03, -0.025)$，\n    - 股票回报 $r^{(E)}$: $(0.008, 0.009, 0.01, 0.011, 0.012, 0.013, 0.012, 0.011)$。\n- 测试用例 $4$（边界情况：零波动率），$L = 1$：\n    - 加密货币回报 $r^{(C)}$: $(0.0, 0.0, 0.0, 0.0)$，\n    - 股票回报 $r^{(E)}$: $(0.0, 0.0, 0.0, 0.0)$。\n- 测试用例 $5$（边界情况：最小有效样本），$L = 2$：\n    - 加密货币回报 $r^{(C)}$: $(0.01, -0.01, 0.02)$，\n    - 股票回报 $r^{(E)}$: $(0.01, -0.01, 0.02)$。\n\n您的程序应生成单行输出，其中包含结果，格式为方括号内以逗号分隔的列表（例如，“[result1,result2,result3,result4,result5]”）。", "solution": "所述问题已经过严格验证，并被认定为有效。该问题在计算金融领域具有科学依据，特别是关于有效市场假说的检验。其定义在数学上是精确的，所提供的数据是自洽且一致的，目标是清晰且可形式化的。不存在矛盾、歧义或违反科学原则之处。因此，我们可以着手构建一个解决方案。\n\n主要目标是为两个给定的资产回报时间序列——一个用于加密货币，一个用于股票指数——计算一个经波动率调整的动量强度指标，表示为 $S$，并对它们进行比较。整个过程将被封装在一个为严谨且可重复的分析而设计的计算框架内。\n\n解决方案的核心是一个函数，旨在为单个回报序列 $\\{r_t\\}_{t=1}^T$ 和一个指定的回看窗口 $L \\in \\mathbb{N}$ 计算强度指标 $S$。该算法流程如下：\n\n1.  输入是回报的时间序列（我们将其表示为数值数组）和整数回看窗口大小 $L$。总时间周期数为 $T$。\n\n2.  计算在非预热期间进行，时间索引 $t$ 从 $L+1$ 到 $T$。对于每个这样的 $t$，我们首先计算回看和 $b_t$，定义为前 $L$ 个回报的总和：\n    $$\n    b_t = \\sum_{i=1}^{L} r_{t-i}\n    $$\n    此操作等效于对回报序列应用一个滑动窗口求和滤波器。\n\n3.  根据 $b_t$ 的符号生成一个动量信号 $s_t$。该信号指示策略采取多头 ($+1$)、空头 ($-1$) 或中性 ($0$) 头寸。信号定义为：\n    $$\n    s_t = \\text{sgn}(b_t) = \n    \\begin{cases}\n    +1, & \\text{若 } b_t > 0, \\\\\n    -1, & \\text{若 } b_t < 0, \\\\\n    0, & \\text{若 } b_t = 0.\n    \\end{cases}\n    $$\n\n4.  在时间 $t$ 的已实现动量策略回报，表示为 $x_t$，是信号与时间 $t$ 实际资产回报的乘积：\n    $$\n    x_t = s_t \\cdot r_t\n    $$\n    此步骤有效地执行了交易策略：从信号方向的持续运动中获利。\n\n5.  对所有 $t \\in \\{L+1, \\ldots, T\\}$ 重复此过程，生成一个包含 $N = T - L$ 个策略回报的序列 $\\{x_t\\}$。\n\n6.  从此策略回报序列中，我们计算其样本均值 $\\mu$ 及其总体标准差 $\\sigma$。这些由标准公式给出：\n    $$\n    \\mu = \\frac{1}{N} \\sum_{t=L+1}^{T} x_t\n    $$\n    $$\n    \\sigma = \\sqrt{\\frac{1}{N} \\sum_{t=L+1}^{T} (x_t - \\mu)^2}\n    $$\n    明确要求使用总体标准差（$1/N$ 归一化）。\n\n7.  最后，计算经波动率调整的强度 $S$。它是一个类似于夏普比率的比率，定义为平均策略回报除以其波动率。为零波动率的情况定义了一个特殊条件：\n    $$\n    S =\n    \\begin{cases}\n    \\mu / \\sigma, & \\text{若 } \\sigma > 0, \\\\\n    0, & \\text{若 } \\sigma = 0.\n    \\end{cases}\n    $$\n    当且仅当所有策略回报 $x_t$ 都相同时，才会出现 $\\sigma=0$ 的情况。这包括 $N=1$ 的边界情况，此时标准差必然为 $0$。\n\n主程序结构遍历每个给定的测试用例。对于每个用例，它会调用上述函数两次：一次用于加密货币回报 $r^{(C)}$ 以计算 $S_{\\text{crypto}}$，另一次用于股票回报 $r^{(E)}$ 以计算 $S_{\\text{equity}}$。\n\n然后使用数值容差 $\\varepsilon = 10^{-12}$ 对这两个强度指标进行比较，以处理浮点数运算的限制。比较产生一个整数分类：\n-   $1$ 若 $S_{\\text{crypto}} > S_{\\text{equity}} + \\varepsilon$\n-   $-1$ 若 $S_{\\text{crypto}} < S_{\\text{equity}} - \\varepsilon$\n-   $0$ 若 $|S_{\\text{crypto}} - S_{\\text{equity}}| \\le \\varepsilon$\n\n来自所有测试用例的这些整数结果被收集并格式化为问题陈述所指定的单个输出字符串。该实现将利用 `numpy` 库中的例程来进行高效的数组操作和统计计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating and comparing the volatility-adjusted\n    momentum strength for given asset return series.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        {\n            \"L\": 2,\n            \"r_crypto\": np.array([0.02, 0.015, 0.018, 0.017, -0.005, 0.02, 0.019, 0.018, 0.017, 0.016, 0.015, 0.014]),\n            \"r_equity\": np.array([0.005, -0.006, 0.004, -0.005, 0.003, -0.004, 0.002, -0.003, 0.001, -0.002, 0.001, -0.001]),\n        },\n        # Test case 2\n        {\n            \"L\": 3,\n            \"r_crypto\": np.array([0.01, -0.005, 0.012, 0.0, 0.008, -0.004, 0.009, -0.003, 0.007, -0.002]),\n            \"r_equity\": np.array([0.01, -0.005, 0.012, 0.0, 0.008, -0.004, 0.009, -0.003, 0.007, -0.002]),\n        },\n        # Test case 3\n        {\n            \"L\": 2,\n            \"r_crypto\": np.array([0.03, -0.025, 0.03, -0.025, 0.03, -0.025, 0.03, -0.025]),\n            \"r_equity\": np.array([0.008, 0.009, 0.01, 0.011, 0.012, 0.013, 0.012, 0.011]),\n        },\n        # Test case 4\n        {\n            \"L\": 1,\n            \"r_crypto\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"r_equity\": np.array([0.0, 0.0, 0.0, 0.0]),\n        },\n        # Test case 5\n        {\n            \"L\": 2,\n            \"r_crypto\": np.array([0.01, -0.01, 0.02]),\n            \"r_equity\": np.array([0.01, -0.01, 0.02]),\n        },\n    ]\n\n    def calculate_strength(returns: np.ndarray, L: int) -> float:\n        \"\"\"\n        Calculates the volatility-adjusted strength (S) for a given series of returns.\n        \n        Args:\n            returns: A numpy array of asset returns.\n            L: The lookback window size.\n\n        Returns:\n            The calculated strength metric S.\n        \"\"\"\n        T = len(returns)\n        if T <= L:\n            # Not enough data for any non-warmup observation.\n            return 0.0\n\n        strategy_returns = []\n        # Loop from t = L+1 to T (using 0-based indexing for t from L to T-1)\n        for t in range(L, T):\n            # Calculate lookback sum b_t = sum of returns from t-L to t-1\n            lookback_sum = np.sum(returns[t-L:t])\n            \n            # Determine signal s_t\n            signal = np.sign(lookback_sum)\n            \n            # Calculate realized momentum return x_t\n            realized_return = signal * returns[t]\n            strategy_returns.append(realized_return)\n\n        x = np.array(strategy_returns)\n        \n        # N is the number of non-warmup observations\n        N = len(x)\n        if N == 0:\n            return 0.0\n            \n        mu = np.mean(x)\n        # sigma is the population standard deviation (ddof=0 is the default in numpy.std)\n        sigma = np.std(x)\n\n        if sigma > 0:\n            S = mu / sigma\n        else:\n            S = 0.0\n            \n        return S\n\n    results = []\n    epsilon = 1e-12\n\n    for case in test_cases:\n        L = case[\"L\"]\n        r_crypto = case[\"r_crypto\"]\n        r_equity = case[\"r_equity\"]\n\n        s_crypto = calculate_strength(r_crypto, L)\n        s_equity = calculate_strength(r_equity, L)\n\n        if s_crypto > s_equity + epsilon:\n            results.append(1)\n        elif s_crypto < s_equity - epsilon:\n            results.append(-1)\n        else:\n            results.append(0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2389238"}]}