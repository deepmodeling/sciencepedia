{"hands_on_practices": [{"introduction": "经济学理论的一个强大之处在于，它能帮助我们从可观测的市场行为中推断出不可观测的个体偏好。本练习将带你应用经典的Merton投资组合模型，这是一种将简单的投资决策与投资者深层次的风险厌恶程度联系起来的逆向工程。通过分析一个投资者在风险资产和无风险资产之间的资金分配，你将亲手计算出其隐含的相对风险厌恶系数 $\\gamma$。[@problem_id:2445855]", "problem": "一位投资者将其财富的一个固定比例分配给标准普尔（S&P）$500$指数，其余部分分配给一个无风险货币市场账户。该投资者对期末财富具有恒定相对风险厌恶（CRRA）偏好，其效用函数为 $U(W) = \\frac{W^{1-\\gamma}}{1-\\gamma}$，其中 $\\gamma > 0, \\gamma \\neq 1$。S&P $500$ 指数价格 $S_t$ 服从几何布朗运动（GBM），其表达式为 $\\mathrm{d}S_t/S_t = \\mu \\,\\mathrm{d}t + \\sigma \\,\\mathrm{d}B_t$，其中 $\\mu$ 和 $\\sigma$ 是常数，$B_t$ 是标准布朗运动。无风险利率为常数 $r$。在投资期限 $[0,T]$ 内，该投资者始终在 S&P $500$ 指数中保持固定的投资组合权重 $\\omega$，并将 $1-\\omega$ 的比例投资于无风险资产。\n\n您观察到 $\\omega = 0.60$。假设年化参数为 $\\mu = 0.07$，$\\sigma = 0.20$ 和 $r = 0.02$，所有单位均为年化单位。在既定假设下，推断该投资者的隐含相对风险厌恶系数 $\\gamma$。将您的答案四舍五入至三位有效数字。", "solution": "该问题要求从投资者观察到的最优投资组合配置中推断其相对风险厌恶系数 $\\gamma$。我们首先验证问题陈述的有效性。\n\n第一步：提取已知条件。\n- 投资者效用函数：$U(W) = \\frac{W^{1-\\gamma}}{1-\\gamma}$，其中 $\\gamma > 0, \\gamma \\neq 1$。这是一个恒定相对风险厌恶（CRRA）效用函数。\n- 风险资产（S&P 500）价格动态：$\\frac{\\mathrm{d}S_t}{S_t} = \\mu \\,\\mathrm{d}t + \\sigma \\,\\mathrm{d}B_t$。\n- 无风险资产回报率：常数 $r$。\n- 投资组合配置：将固定比例 $\\omega$ 投资于风险资产，将 $1-\\omega$ 投资于无风险资产。\n- 观察到和给定的参数：\n  - $\\omega = 0.60$\n  - $\\mu = 0.07$ (风险资产的年化期望收益)\n  - $\\sigma = 0.20$ (风险资产的年化波动率)\n  - $r = 0.02$ (年化无风险利率)\n  - 投资期限：$[0,T]$。\n\n第二步：使用提取的已知条件进行验证。\n该问题具有科学依据，因为它是 Merton 投资组合问题的直接应用，这是数理金融学中一个经典且基础的课题。该问题是适定的，因为可以从所提供的参数和已建立的理论模型中确定 $\\gamma$ 的唯一值。问题陈述客观，具有精确的数值和函数形式。它自成体系且没有矛盾。所提供的参数值对于金融市场是现实的。因此，该问题被认为是有效的，可以构建解决方案。\n\n第三步：进行求解。\n投资者的目标是最大化期末财富的期望效用 $E[U(W_T)]$。对于一个具有 CRRA 效用函数的投资者，在只有一个服从几何布朗运动的风险资产和一个恒定无风险利率的市场中，分配给风险资产的最优财富比例 $\\omega^*$ 是不随时间变化的。这是 Merton 投资组合理论的一个标准结果。\n\n设 $W_t$ 为投资者在时间 $t$ 的财富。财富过程的动态由投资组合各部分的收益决定。财富的变化量 $dW_t$ 由风险头寸和无风险头寸的收益之和给出：\n$$ dW_t = (\\omega W_t) \\frac{dS_t}{S_t} + ((1-\\omega)W_t) r dt $$\n代入风险资产的随机微分方程（SDE）$\\frac{dS_t}{S_t} = \\mu dt + \\sigma dB_t$：\n$$ dW_t = \\omega W_t (\\mu dt + \\sigma dB_t) + (1-\\omega)W_t r dt $$\n我们可以通过对确定性项（$dt$）和随机项（$dB_t$）进行分组来重新整理此式：\n$$ dW_t = [\\omega \\mu + (1-\\omega)r] W_t dt + \\omega \\sigma W_t dB_t $$\n两边同除以 $W_t$ 得到财富投资组合回报率的 SDE：\n$$ \\frac{dW_t}{W_t} = [\\omega(\\mu - r) + r] dt + \\omega \\sigma dB_t $$\n最优化问题 $\\max_{\\omega} E\\left[\\frac{W_T^{1-\\gamma}}{1-\\gamma}\\right]$ 的解给出了最优配置 $\\omega^*$。对于给定的效用函数，相对风险厌恶系数定义为 $RRA(W) = - \\frac{W U''(W)}{U'(W)}$。对于指定的效用函数，$U'(W) = W^{-\\gamma}$ 且 $U''(W) = -\\gamma W^{-\\gamma-1}$，这给出 $RRA(W) = - \\frac{W (-\\gamma W^{-\\gamma-1})}{W^{-\\gamma}} = \\gamma$。\n\n著名的 Merton 比例给出了最优配置为：\n$$ \\omega^* = \\frac{\\mu - r}{\\gamma \\sigma^2} $$\n在这里，$\\mu - r$ 是风险的市场价格，或称股权风险溢价。项 $\\gamma \\sigma^2$ 是投资者风险厌恶程度与风险资产收益方差的乘积。\n\n问题陈述该投资者保持恒定的配置 $\\omega = 0.60$。我们将此观察到的配置等同于投资者的最优配置，因此我们设 $\\omega^* = \\omega$。我们已知以下参数值：\n- $\\mu = 0.07$\n- $r = 0.02$\n- $\\sigma = 0.20$\n- $\\omega^* = 0.60$\n\n现在我们可以通过重新整理最优配置的公式来求解隐含的相对风险厌恶系数 $\\gamma$：\n$$ \\gamma = \\frac{\\mu - r}{\\omega^* \\sigma^2} $$\n将给定的数值代入此表达式：\n$$ \\gamma = \\frac{0.07 - 0.02}{0.60 \\times (0.20)^2} $$\n首先，我们计算分子和分母中的各项：\n- 股权风险溢价：$\\mu - r = 0.05$。\n- 风险资产的方差：$\\sigma^2 = (0.20)^2 = 0.04$。\n- 分母的乘积：$\\omega^* \\sigma^2 = 0.60 \\times 0.04 = 0.024$。\n\n现在，将这些值代回 $\\gamma$ 的表达式中：\n$$ \\gamma = \\frac{0.05}{0.024} $$\n为了计算数值，我们可以将其表示为整数分数：\n$$ \\gamma = \\frac{50}{24} = \\frac{25}{12} $$\n其计算结果约为 $2.08333...$。问题要求答案四舍五入到三位有效数字。\n$$ \\gamma \\approx 2.08 $$\n该值是一个合理的风险厌恶度量。", "answer": "$$\n\\boxed{2.08}\n$$", "id": "2445855"}, {"introduction": "虽然像Merton模型这样的解析解非常优雅，但现实世界中的许多金融产品和收益分布过于复杂，无法用简洁的公式来描述。本练习将引导你从第一性原理出发，处理一个不具备解析解的复杂收益情景。你将使用蒙特卡洛模拟来估计期望效用，并结合数值根求解算法来计算确定性等价物，这些都是计算金融领域不可或缺的核心技能。[@problem_id:2445887]", "problem": "要求您实现一个程序，用以在指数效用函数下，为一个不具有解析易解分布的随机收益计算其确定性等价。请完全基于期望效用和确定性等价的基本定义进行求解。请勿使用直接表示确定性等价的封闭式公式；相反，应实现一种求解其定义方程的数值方法。\n\n决策者具有恒定绝对风险厌恶的指数效用函数：\n- 效用：$u(w) = -\\exp(-a\\,w)$，其中 $a \\gt 0$ 为风险厌恶系数。\n- 确定性等价 (CE)：对于一个随机收益 $W$，其确定性等价 $c$ 是满足方程 $u(c) = \\mathbb{E}[u(W)]$ 的唯一实数。\n\n该彩票的收益定义如下。设 $Z \\sim \\mathcal{N}(0,1)$ 和 $U \\sim \\text{Uniform}(0,1)$ 为相互独立的随机变量。定义收益为\n$$\nW = \\exp(\\mu + \\sigma Z) + K \\, U^2.\n$$\n对于一般的参数值，$W$ 的这个分布对于 $\\mathbb{E}\\left[\\exp(-a W)\\right]$ 没有解析易解的形式，因此其确定性等价必须通过数值方法获得。\n\n实现一个程序，该程序对测试套件中的每一组参数执行以下步骤：\n- 使用蒙特卡洛 (MC) 模拟，并设置固定的随机种子，根据上述定义生成 $N$ 个独立的 $W$ 样本。在整个过程中，每个样本都使用相同的 $Z$ 和 $U$ 的独立抽样。\n- 通过样本均值来估计 $\\mathbb{E}[u(W)]$。\n- 数值求解 $c$，使得 $u(c) - \\widehat{\\mathbb{E}[u(W)]} = 0$ 成立。使用一种在单调性下保证收敛的区间法（例如，二分法）。使用一个稳健的区间，该区间根据模拟样本中的 $W$ 值的最小值和最大值构建，并利用 $u(\\cdot)$ 的单调性。\n- 返回数值计算出的确定性等价 $c$，结果为浮点数并四舍五入到 $6$ 位小数。\n\n测试套件：\n- 案例 1：$(a, \\mu, \\sigma, K, N, \\text{seed}) = (\\,0.5,\\, 0.1,\\, 0.6,\\, 2.5,\\, 200000,\\, 13579\\,)$。\n- 案例 2：$(a, \\mu, \\sigma, K, N, \\text{seed}) = (\\,0.01,\\, 0.2,\\, 0.8,\\, 5.0,\\, 200000,\\, 24680\\,)$。\n- 案例 3：$(a, \\mu, \\sigma, K, N, \\text{seed}) = (\\,2.0,\\, 0.0,\\, 0.9,\\, 1.0,\\, 200000,\\, 98765\\,)$。\n\n要求与约束：\n- 仅使用期望效用和确定性等价的定义作为理论基础。\n- 数值解法必须依赖于一个单调求根方案，该方案使用由模拟样本所确定的有效区间。\n- 所有随机数生成必须对每个案例使用指定的种子。\n- 三个案例的最终输出必须是四舍五入到 $6$ 位小数的浮点值。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔列表，例如 $[x_1,x_2,x_3]$，其中每个 $x_i$ 是案例 $i$ 的确定性等价，四舍五入到 $6$ 位小数。", "solution": "问题陈述已经过验证，被认为是有效的。它在科学上以效用理论为基础，在数学和算法上是适定的，并提供了完整且明确的规范。我们将继续进行解法的推导和实现。\n\n目标是为一个面临随机收益 $W$ 彩票且具有指数效用函数的决策者计算其确定性等价，记为 $c$。\n\n确定性等价 $c$ 的基本定义是：能提供与随机收益 $W$ 的期望效用相同效用水平的确定性财富量。这由以下方程正式表述：\n$$\nu(c) = \\mathbb{E}[u(W)]\n$$\n决策者的效用函数属于恒定绝对风险厌恶（CARA）族，具体为下式给出的指数效用函数：\n$$\nu(w) = -\\exp(-a\\,w)\n$$\n其中 $w$ 是财富，$a > 0$ 是绝对风险厌恶系数。\n\n随机收益 $W$ 由两个独立的随机变量构成，即 $Z \\sim \\mathcal{N}(0,1)$（标准正态变量）和 $U \\sim \\text{Uniform}(0,1)$（标准均匀变量），具体如下：\n$$\nW = \\exp(\\mu + \\sigma Z) + K U^2\n$$\n参数 $\\mu$、$\\sigma$ 和 $K$ 定义了收益的结构。$W$ 的分布是一个混合分布，对于期望 $\\mathbb{E}[\\exp(-aW)]$ 没有解析的封闭式表达式，而这是解析求解 $c$ 所必需的。因此，必须采用数值方法。\n\n我们的数值策略遵循问题的约束，并基于以下基本原则：\n\n1.  **期望效用的蒙特卡洛估计**：由于我们无法解析计算 $\\mathbb{E}[u(W)]$，我们使用大数定律对其进行估计。我们生成大量的，即 $N$ 个独立的收益样本 $\\{W_1, W_2, \\ldots, W_N\\}$。然后，期望效用通过样本均值来近似：\n    $$\n    \\widehat{\\mathbb{E}[u(W)]} = \\frac{1}{N} \\sum_{i=1}^{N} u(W_i) = \\frac{1}{N} \\sum_{i=1}^{N} (-\\exp(-a\\,W_i))\n    $$\n    每个样本 $W_i$ 都是通过从各自的分布中抽取一对独立样本 $Z_i$ 和 $U_i$，并应用 $W$ 的公式生成的。\n\n2.  **确定性等价的数值解**：有了估计值 $\\widehat{\\mathbb{E}[u(W)]}$，我们现在必须求解 $c$ 的定义方程：\n    $$\n    u(c) = \\widehat{\\mathbb{E}[u(W)]}\n    $$\n    代入效用函数，我们得到：\n    $$\n    -\\exp(-a\\,c) = \\widehat{\\mathbb{E}[u(W)]}\n    $$\n    这是一个关于单个变量 $c$ 的非线性方程。问题明确要求使用数值求根方法求解此方程，而不是使用直接的解析反演 $c = -\\frac{1}{a} \\ln(-\\widehat{\\mathbb{E}[u(W)]})$，以演示数值计算过程。我们必须找到函数 $f(c)$ 的根：\n    $$\n    f(c) = u(c) - \\widehat{\\mathbb{E}[u(W)]} = -\\exp(-a\\,c) - \\widehat{\\mathbb{E}[u(W)]} = 0\n    $$\n\n3.  **使用区间法的求根**：函数 $f(c)$ 是连续的，并且关于 $c$ 是严格单调的，因为其导数 $f'(c) = a\\exp(-a\\,c)$ 在 $a > 0$ 时恒为正。这保证了根的唯一性，并使得二分法——一种稳健的区间算法——成为一个合适的选择。\n\n    要应用二分法，我们需要一个区间 $[c_{low}, c_{high}]$，使得 $f(c_{low})$ 和 $f(c_{high})$ 异号。一个可靠的区间可以根据期望的性质来构建。由于效用函数 $u(w)$ 是单调递增的，确定性等价 $c$ 必须位于 $W$ 可能结果的范围内。根据 Jensen's 不等式，$c \\le \\mathbb{E}[W]$。更一般地，对于样本中的任何实现 $W_i$，我们有 $\\min(W_i) \\le W_i \\le \\max(W_i)$。应用单调效用函数并取期望意味着 $u(\\min(W_i)) \\le \\mathbb{E}[u(W)] \\le u(\\max(W_i))$。由于 $u(c)=\\mathbb{E}[u(W)]$，因此可以得出 $u(\\min(W_i)) \\le u(c) \\le u(\\max(W_i))$，所以 $\\min(W_i) \\le c \\le \\max(W_i)$。我们使用样本的最小值和最大值，即 $c_{low} = \\min_{i}\\{W_i\\}$ 和 $c_{high} = \\max_{i}\\{W_i\\}$，作为求根算法的稳健区间。我们可以验证 $f(c_{low}) \\le 0$ 和 $f(c_{high}) \\ge 0$，这证明了该区间的有效性。\n\n每个测试案例的完整算法如下：\n1.  使用指定的种子初始化伪随机数生成器，以确保可复现性。\n2.  生成 $N$ 个独立的 $Z_i \\sim \\mathcal{N}(0,1)$ 和 $U_i \\sim \\text{Uniform}(0,1)$ 样本。\n3.  计算 $N$ 个收益样本 $W_i = \\exp(\\mu + \\sigma Z_i) + K U_i^2$。\n4.  计算估计的期望效用 $\\widehat{\\mathbb{E}[u(W)]} = \\frac{1}{N}\\sum_{i=1}^{N} (-\\exp(-a\\,W_i))$。\n5.  定义待求解的函数：$f(c) = -\\exp(-a\\,c) - \\widehat{\\mathbb{E}[u(W)]}$。\n6.  为求根器建立区间：$[c_{low}, c_{high}] = [\\min(\\{W_i\\}), \\max(\\{W_i\\})]$。\n7.  使用 `scipy.optimize` 库中的二分法，在建立的区间内高精度地找到 $f(c)=0$ 的根 $c$。\n8.  按要求将计算出的 $c$ 值四舍五入到 $6$ 位小数。\n\n该过程在以下 Python 程序中实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import bisect\n\ndef solve():\n    \"\"\"\n    Computes the certainty equivalent for a random payoff under exponential utility\n    using Monte Carlo simulation and numerical root-finding.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, mu, sigma, K, N, seed)\n        (0.5, 0.1, 0.6, 2.5, 200000, 13579),\n        (0.01, 0.2, 0.8, 5.0, 200000, 24680),\n        (2.0, 0.0, 0.9, 1.0, 200000, 98765),\n    ]\n\n    results = []\n    \n    # Process each test case\n    for a, mu, sigma, K, N, seed in test_cases:\n        \n        # 1. Initialize the pseudo-random number generator for reproducibility.\n        rng = np.random.default_rng(seed)\n\n        # 2. Generate N independent samples of Z and U.\n        # Z ~ N(0,1)\n        Z_samples = rng.standard_normal(N)\n        # U ~ Uniform(0,1)\n        U_samples = rng.uniform(0, 1, N)\n\n        # 3. Compute the N samples of the payoff W.\n        # W = exp(mu + sigma*Z) + K*U^2\n        W_samples = np.exp(mu + sigma * Z_samples) + K * U_samples**2\n\n        # 4. Calculate the estimated expected utility.\n        # u(w) = -exp(-a*w)\n        # E[u(W)] is approximated by the sample mean of u(W_i).\n        utility_samples = -np.exp(-a * W_samples)\n        expected_utility_hat = np.mean(utility_samples)\n\n        # 5. Define the function to be solved for the certainty equivalent c.\n        # The defining equation is u(c) = E[u(W)].\n        # We need to find the root of f(c) = u(c) - E_hat[u(W)] = 0.\n        # f(c) = -exp(-a*c) - expected_utility_hat\n        def target_function(c):\n            return -np.exp(-a * c) - expected_utility_hat\n\n        # 6. Establish the bracket for the root finder.\n        # The certainty equivalent must be within the range of possible outcomes.\n        # We use the sample min and max as a robust bracket.\n        c_low = np.min(W_samples)\n        c_high = np.max(W_samples)\n\n        # 7. Employ a bisection method to find the root c.\n        # A high-precision tolerance is used before final rounding.\n        try:\n            certainty_equivalent = bisect(target_function, c_low, c_high, xtol=1e-12)\n        except ValueError:\n            # This should not happen if the bracket is valid, but is good practice.\n            certainty_equivalent = np.nan\n\n        # 8. Round the result to 6 decimal places.\n        results.append(round(certainty_equivalent, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2445887"}, {"introduction": "传统的期望效用理论假设决策者是完全理性的，但这有时难以解释现实中的某些行为。一个著名的悖论是，为何同一个人会既购买期望收益为负的彩票，又购买昂贵的保险？本练习将带你走出传统模型的框架，通过编程实现累积前景理论（CPT），探索损失厌恶和概率权重等心理学概念如何从计算上解释这种看似矛盾的决策行为。[@problem_id:2445905]", "problem": "构建一个完整的程序，根据累积前景理论（CPT）评估选择，以确定一个人是否会同时购买彩票和购买保险。评估必须依据累积前景理论（CPT）的第一性原理进行，并使用零作为参照点。对于每个测试用例，您将获得 CPT 价值函数和概率权重函数的参数，以及两个二元决策的描述：购买彩票和购买保险。您的程序必须为每个测试用例输出两个整数，分别表示是否严格偏好购买彩票和是否严格偏好购买保险。\n\n使用以下定义。\n\n1. 价值函数。对于结果 $x$（衡量为相对于参照点 $0$ 的变化），\n$$\nv(x) =\n\\begin{cases}\nx^{\\alpha}, & \\text{if } x \\ge 0, \\\\\n-\\lambda \\, (-x)^{\\beta}, & \\text{if } x < 0,\n\\end{cases}\n$$\n其中 $\\alpha \\in (0,1]$，$\\beta \\in (0,1]$，且 $\\lambda \\ge 1$。\n\n2. 概率权重。对于任意概率 $p \\in (0,1)$，定义收益侧权重函数 $w^{+}(p)$ 和损失侧权重函数 $w^{-}(p)$ 如下：\n$$\nw^{+}(p) = \\frac{p^{\\gamma}}{\\left(p^{\\gamma} + (1-p)^{\\gamma}\\right)^{1/\\gamma}}, \\quad\nw^{-}(p) = \\frac{p^{\\delta}}{\\left(p^{\\delta} + (1-p)^{\\delta}\\right)^{1/\\delta}},\n$$\n其中 $\\gamma \\in (0,1]$ 且 $\\delta \\in (0,1]$。\n\n3. 累积前景理论（CPT）下的决策评估。\n- 购买彩票的决策：决策者在不购买（确定结果为 $0$）和购买彩票之间做出选择。如果购买彩票，结果为以概率 $p$ 获得收益 $g-c$ 和以概率 $1-p$ 遭受损失 $-c$，其中 $g \\ge 0$ 是奖金，$c \\ge 0$ 是彩票成本，$p \\in (0,1)$。购买的 CPT 价值是\n$$\nV_{\\text{buy-lottery}} = w^{+}(p)\\, v(g-c) + w^{-}(1-p)\\, v(-c).\n$$\n决策者严格偏好购买彩票，当且仅当 $V_{\\text{buy-lottery}} > 0$。\n\n- 购买保险的决策：决策者在不投保和购买全额保险之间选择。如果不投保，结果为以概率 $q$ 遭受损失 $-L$ 和以概率 $1-q$ 结果为 $0$，其中 $L \\ge 0$ 是损失额，$q \\in (0,1)$ 是损失概率。如果投保，结果是确定的损失 $-\\pi$，其中 $\\pi \\ge 0$ 是保险费。CPT 价值是\n$$\nV_{\\text{uninsured}} = w^{-}(q)\\, v(-L), \\quad V_{\\text{insured}} = v(-\\pi).\n$$\n决策者严格偏好购买保险，当且仅当 $V_{\\text{insured}} > V_{\\text{uninsured}}$。\n\n您的程序必须严格实现上述定义。对于严格不等式的数值比较，如果左侧减去右侧的值超过 $10^{-12}$，则视为严格大于。\n\n测试套件。使用以下四个测试用例，每个用例由参数元组 $(\\alpha,\\beta,\\lambda,\\gamma,\\delta,p,g,c,q,L,\\pi)$ 指定。\n\n- 用例 $1$：$(0.88, 0.88, 2.25, 0.61, 0.69, 0.01, 500, 5, 0.01, 500, 6)$。\n- 用例 $2$：$(1.0, 1.0, 1.0, 1.0, 1.0, 0.01, 500, 5, 0.01, 500, 5)$。\n- 用例 $3$：$(0.88, 0.88, 1.1, 0.4, 1.0, 0.01, 500, 5, 0.01, 500, 8)$。\n- 用例 $4$：$(0.6, 0.9, 3.5, 1.0, 0.5, 0.01, 500, 5, 0.01, 500, 6)$。\n\n答案规格和输出格式。对于每个测试用例，计算两个整数：\n- $b_{\\ell} \\in \\{0,1\\}$，如果 $V_{\\text{buy-lottery}} > 0$，则其值为 $1$，否则为 $0$。\n- $b_{i} \\in \\{0,1\\}$，如果 $V_{\\text{insured}} > V_{\\text{uninsured}}$，则其值为 $1$，否则为 $0$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的 $8$ 个整数的逗号分隔列表，按顺序 $[b_{\\ell}^{(1)}, b_{i}^{(1)}, b_{\\ell}^{(2)}, b_{i}^{(2)}, b_{\\ell}^{(3)}, b_{i}^{(3)}, b_{\\ell}^{(4)}, b_{i}^{(4)}]$，其中上标表示测试用例的索引。输出行中不允许有任何额外的文本或空格。", "solution": "该问题要求根据一组指定参数，在累积前景理论（CPT）下评估决策。在提供解决方案之前，必须对问题陈述的科学合理性、完整性和客观性进行验证。\n\n**第一步：提取已知信息**\n\n问题提供了以下定义和数据：\n\n1.  **价值函数**：对于相对于参照点 $0$ 的结果 $x$，价值函数 $v(x)$ 定义为：\n    $$\n    v(x) =\n    \\begin{cases}\n    x^{\\alpha}, & \\text{if } x \\ge 0 \\\\\n    -\\lambda \\, (-x)^{\\beta}, & \\text{if } x < 0\n    \\end{cases}\n    $$\n    参数为 $\\alpha \\in (0,1]$，$\\beta \\in (0,1]$，且 $\\lambda \\ge 1$。\n\n2.  **概率权重函数**：对于概率 $p \\in (0,1)$，权重函数为：\n    $$\n    w^{+}(p) = \\frac{p^{\\gamma}}{\\left(p^{\\gamma} + (1-p)^{\\gamma}\\right)^{1/\\gamma}} \\quad (\\text{收益侧})\n    $$\n    $$\n    w^{-}(p) = \\frac{p^{\\delta}}{\\left(p^{\\delta} + (1-p)^{\\delta}\\right)^{1/\\delta}} \\quad (\\text{损失侧})\n    $$\n    参数为 $\\gamma \\in (0,1]$ 且 $\\delta \\in (0,1]$。\n\n3.  **购买彩票的决策**：选择在于不购买（结果为 $0$）和购买彩票之间。购买彩票的结果是以概率 $p$ 获得收益 $g-c$ 和以概率 $1-p$ 遭受损失 $-c$。购买的 CPT 价值为：\n    $$\n    V_{\\text{buy-lottery}} = w^{+}(p)\\, v(g-c) + w^{-}(1-p)\\, v(-c)\n    $$\n    严格偏好购买的条件是当且仅当 $V_{\\text{buy-lottery}} > 0$。\n\n4.  **购买保险的决策**：选择在于不投保（以概率 $q$ 遭受损失 $-L$，否则为 $0$）和购买保险（确定损失 $-\\pi$）之间。CPT 价值为：\n    $$\n    V_{\\text{uninsured}} = w^{-}(q)\\, v(-L)\n    $$\n    $$\n    V_{\\text{insured}} = v(-\\pi)\n    $$\n    严格偏好购买保险的条件是当且仅当 $V_{\\text{insured}} > V_{\\text{uninsured}}$。\n\n5.  **数值容差**：严格不等式 $A > B$ 满足的条件是 $A - B > 10^{-12}$。\n\n6.  **测试用例**：提供了四个用例，参数元组为 $(\\alpha, \\beta, \\lambda, \\gamma, \\delta, p, g, c, q, L, \\pi)$：\n    *   用例 $1$：$(0.88, 0.88, 2.25, 0.61, 0.69, 0.01, 500, 5, 0.01, 500, 6)$\n    *   用例 $2$：$(1.0, 1.0, 1.0, 1.0, 1.0, 0.01, 500, 5, 0.01, 500, 5)$\n    *   用例 $3$：$(0.88, 0.88, 1.1, 0.4, 1.0, 0.01, 500, 5, 0.01, 500, 8)$\n    *   用例 $4$：$(0.6, 0.9, 3.5, 1.0, 0.5, 0.01, 500, 5, 0.01, 500, 6)$\n\n**第二步：使用提取的已知信息进行验证**\n\n根据指定标准对问题进行验证。\n\n*   **科学依据**：该问题基于累积前景理论，这是由 Tversky 和 Kahneman 发展的行为经济学的基石。价值函数表现出敏感性递减和损失厌恶，概率权重函数捕捉了对小概率的过度加权，这些都是已确立的实证发现。将其应用于彩票-保险悖论是 CPT 的经典用例。所提供的公式是 CPT 对指定简单前景的正确应用。该问题是科学合理的。\n*   **适定性**：问题提供了所有必要的数学公式、每个测试用例的参数以及明确的决策规则。计算是确定性的，确保每个用例都有唯一的解。该问题是适定的。\n*   **客观性**：问题使用精确的数学语言表述。它不包含任何主观或含糊的术语。\n\n问题陈述没有显示出科学不合理、不完整、矛盾或模棱两可等缺陷。这是计算经济学领域内一个形式化的、可解决的问题。\n\n**第三步：结论与行动**\n\n该问题是 **有效的**。将构建一个解决方案。\n\n**基于原理的设计与求解算法**\n\n任务是按照规定实现 CPT 框架，并将其应用于四个测试用例。对于每个用例，我们必须确定两个二元结果：购买彩票的决策（$b_{\\ell}$）和购买保险的决策（$b_{i}$）。该解决方案是所提供公式的直接实现。\n\n**1. 核心 CPT 函数的实现**\n\n首先，我们必须实现模型的三个基本组成部分。\n\n*   **价值函数 $v(x)$**：将创建一个函数，根据给定的参数 $\\alpha$、$\\beta$ 和 $\\lambda$ 计算结果 $x$ 的价值。\n    *   如果 $x \\ge 0$，函数返回 $x^{\\alpha}$。\n    *   如果 $x < 0$，函数返回 $-\\lambda(-x)^{\\beta}$。\n    \n*   **收益侧权重函数 $w^{+}(p)$**：一个函数将根据参数 $\\gamma$ 计算收益概率 $p$ 的决策权重。公式为 $w^{+}(p) = p^{\\gamma} / (p^{\\gamma} + (1-p)^{\\gamma})^{1/\\gamma}$。\n\n*   **损失侧权重函数 $w^{-}(p)$**：一个函数将根据参数 $\\delta$ 计算损失概率 $p$ 的决策权重。公式为 $w^{-}(p) = p^{\\delta} / (p^{\\delta} + (1-p)^{\\delta})^{1/\\delta}$。\n\n**2. 彩票决策评估**\n\n对于每个测试用例，购买彩票的决策评估如下：\n\n1.  识别彩票决策的参数：$\\alpha, \\beta, \\lambda, \\gamma, \\delta, p, g, c$。\n2.  计算相对于参照点 $0$ 的两种可能结果：收益 $x_{g} = g-c$ 和损失 $x_{\\ell} = -c$。\n3.  使用价值函数计算这些结果的价值：$v(x_{g})$ 和 $v(x_{\\ell})$。\n4.  计算所需的决策权重。收益 $g-c$ 发生的概率为 $p$，因此我们需要 $w^{+}(p)$。损失 $-c$ 发生的概率为 $1-p$，因此我们需要 $w^{-}(1-p)$。\n5.  使用提供的公式计算购买彩票的 CPT 价值：\n    $$\n    V_{\\text{buy-lottery}} = w^{+}(p) v(g-c) + w^{-}(1-p) v(-c)\n    $$\n6.  应用决策规则。如果 $V_{\\text{buy-lottery}} > 0$，决策者严格偏好购买彩票。使用指定的容差，检查条件为 $V_{\\text{buy-lottery}} > 10^{-12}$。\n7.  如果满足条件，则将决策变量 $b_{\\ell}$ 设为 $1$，否则设为 $0$。\n\n**3. 保险决策评估**\n\n同样，对于每个测试用例，购买保险的决策评估如下：\n\n1.  识别保险决策的参数：$\\alpha, \\beta, \\lambda, \\delta, q, L, \\pi$。注意，$\\gamma$ 未被使用。\n2.  计算“未投保”前景的 CPT 价值。这涉及一个单一的非零结果，即以概率 $q$ 遭受损失 $-L$。其价值为：\n    $$\n    V_{\\text{uninsured}} = w^{-}(q) v(-L)\n    $$\n    这需要计算 $v(-L)$ 和决策权重 $w^{-}(q)$。\n3.  计算“已投保”前景的 CPT 价值。这是一个确定的结果：损失保费 $-\\pi$。其价值就是：\n    $$\n    V_{\\text{insured}} = v(-\\pi)\n    $$\n4.  应用决策规则。如果 $V_{\\text{insured}} > V_{\\text{uninsured}}$，决策者严格偏好购买保险。检查条件为 $V_{\\text{insured}} - V_{\\text{uninsured}} > 10^{-12}$。\n5.  如果满足条件，则将决策变量 $b_{i}$ 设为 $1$，否则设为 $0$。\n\n**4. 程序执行**\n\n将构建一个程序来执行此逻辑。它将遍历四个测试用例。在每次迭代中，它将解包 $11$ 个参数，调用实现上述逻辑的函数来计算 $b_{\\ell}$ 和 $b_{i}$，并存储这两个整数结果。最后，程序将把来自四个用例的所有 $8$ 个计算出的整数格式化为方括号内的一个逗号分隔列表，以符合要求。\n\n这种结构化的过程确保了解决方案严格遵守问题陈述中定义的 CPT 第一性原理，并以指定格式生成正确的输出。使用像 NumPy 这样的数值库适合于精确处理幂运算。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Evaluates lottery and insurance decisions under Cumulative Prospect Theory (CPT)\n    for a given set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (alpha, beta, lam, gamma, delta, p, g, c, q, L, pi)\n    test_cases = [\n        (0.88, 0.88, 2.25, 0.61, 0.69, 0.01, 500, 5, 0.01, 500, 6),\n        (1.0, 1.0, 1.0, 1.0, 1.0, 0.01, 500, 5, 0.01, 500, 5),\n        (0.88, 0.88, 1.1, 0.4, 1.0, 0.01, 500, 5, 0.01, 500, 8),\n        (0.6, 0.9, 3.5, 1.0, 0.5, 0.01, 500, 5, 0.01, 500, 6),\n    ]\n\n    TOLERANCE = 1e-12\n    results = []\n\n    def value_func(x, alpha, beta, lam):\n        \"\"\"CPT value function v(x).\"\"\"\n        if x >= 0:\n            return np.power(x, alpha)\n        else:\n            return -lam * np.power(-x, beta)\n\n    def weight_func_plus(p, gamma):\n        \"\"\"CPT gain-side probability weighting function w+(p).\"\"\"\n        if p == 0.0 or p == 1.0:\n            return p\n        p_gamma = np.power(p, gamma)\n        one_minus_p_gamma = np.power(1.0 - p, gamma)\n        return p_gamma / np.power(p_gamma + one_minus_p_gamma, 1.0 / gamma)\n\n    def weight_func_minus(p, delta):\n        \"\"\"CPT loss-side probability weighting function w-(p).\"\"\"\n        if p == 0.0 or p == 1.0:\n            return p\n        p_delta = np.power(p, delta)\n        one_minus_p_delta = np.power(1.0 - p, delta)\n        return p_delta / np.power(p_delta + one_minus_p_delta, 1.0 / delta)\n    \n    for case in test_cases:\n        alpha, beta, lam, gamma, delta, p, g, c, q, L, pi = case\n\n        # --- Lottery Decision ---\n        gain_outcome = g - c\n        loss_outcome = -c\n        \n        v_gain = value_func(gain_outcome, alpha, beta, lam)\n        v_loss = value_func(loss_outcome, alpha, beta, lam)\n        \n        w_plus_p = weight_func_plus(p, gamma)\n        w_minus_1_minus_p = weight_func_minus(1.0 - p, delta)\n        \n        V_buy_lottery = w_plus_p * v_gain + w_minus_1_minus_p * v_loss\n        \n        b_l = 1 if V_buy_lottery > TOLERANCE else 0\n        \n        # --- Insurance Decision ---\n        V_uninsured = weight_func_minus(q, delta) * value_func(-L, alpha, beta, lam)\n        V_insured = value_func(-pi, alpha, beta, lam)\n        \n        b_i = 1 if (V_insured - V_uninsured) > TOLERANCE else 0\n        \n        results.extend([b_l, b_i])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2445905"}]}