{"hands_on_practices": [{"introduction": "这项基础练习旨在通过一项基本任务——描绘给定效用水平下的无差异曲线——来巩固您的理解。您将使用具有广泛适用性的恒定替代弹性（CES）效用函数，通过计算来确定构成单条曲线的点，并分析边际替代率（$MRS$）如何沿曲线变化。这项实践对于将偏好结构可视化，以及理解消费者愿意做出的局部权衡至关重要。[@problem_id:2401500]", "problem": "考虑两种商品的恒定替代弹性（CES）效用函数，其定义为 $U(x,y) = \\left(a x^{\\rho} + b y^{\\rho}\\right)^{1/\\rho}$，参数为 $a>0$、$b>0$ 且 $\\rho \\neq 0$。在效用水平 $U_0>0$ 处的无差异曲线是集合 $\\{(x,y): U(x,y)=U_0, x>0, y>0\\}$。您的任务是编写一个完整、可运行的程序。对于每组指定的参数集以及无差异曲线正定义域中的两个给定x值，该程序需要生成同一无差异曲线上对应的y值，并评估边际替代率（MRS）是否在沿曲线的这两点之间严格递减。\n\n使用的定义：\n- 效用水平 $U_0$ 的无差异曲线由 $U(x,y)=U_0$ 隐式给出，其中 $x>0$ 且 $y>0$。\n- 边际替代率（MRS）定义为 $\\text{MRS}(x,y) = \\dfrac{\\partial U/\\partial x}{\\partial U/\\partial y}$。\n\n对于下方的每个测试用例，执行以下操作：\n1. 给定 $(a,b,\\rho,U_0)$ 和属于效用水平 $U_0$ 的无差异曲线定义域的两个正x值 $(x_1,x_2)$，计算满足 $U(x_i,y_i)=U_0$（其中 $i \\in \\{1,2\\}$）的唯一正y值 $(y_1,y_2)$。\n2. 使用上述定义计算 $\\text{MRS}(x_1,y_1)$ 和 $\\text{MRS}(x_2,y_2)$，并返回一个布尔值，以表明是否 $\\text{MRS}(x_1,y_1) > \\text{MRS}(x_2,y_2)$，即，当x沿同一无差异曲线从 $x_1$ 增加到 $x_2$ 时，MRS是否严格递减。\n\n测试套件：\n- 案例1：$a=0.6, b=0.4, \\rho=-1.0, U_0=1.0, x_1=0.61, x_2=0.8$。\n- 案例2：$a=0.6, b=0.4, \\rho=0.5, U_0=1.0, x_1=0.5, x_2=2.7$。\n- 案例3：$a=0.6, b=0.4, \\rho=2.0, U_0=1.0, x_1=0.3, x_2=1.2$。\n\n要求：\n- 全文假设 $x>0$ 且 $y>0$。对于每个案例，所提供的 $x_1$ 和 $x_2$ 均位于可行域内，在该域中存在一个唯一的正y值满足 $U(x,y)=U_0$。\n- 对于每个测试用例，返回一个列表 $[y_1,y_2,\\text{decreasing}]$，其中 $y_1$ 和 $y_2$ 是四舍五入到6位小数的浮点数，且当且仅当 $\\text{MRS}(x_1,y_1) > \\text{MRS}(x_2,y_2)$ 时，$\\text{decreasing}$ 是布尔值 $\\text{True}$。\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，每个条目对应一个测试用例，顺序与上文所列相同。每个条目本身也应是一个用方括号括起来的、以逗号分隔的列表。例如，最终输出格式必须如下所示的单行：\n  \"[[y1_case1,y2_case1,decreasing_case1],[y1_case2,y2_case2,decreasing_case2],[y1_case3,y2_case3,decreasing_case3]]\"\n- 不涉及物理单位。", "solution": "我们已知恒定替代弹性（CES）效用函数 $U(x,y) = \\left(a x^{\\rho} + b y^{\\rho}\\right)^{1/\\rho}$，其中 $a>0$、$b>0$ 且 $\\rho \\neq 0$。在效用水平 $U_0>0$ 处的无差异曲线由满足 $U(x,y)=U_0$ 且 $x>0, y>0$ 的点集 $(x,y)$ 定义。\n\n步骤1：求解无差异曲线。固定 $U_0>0$。方程 $U(x,y)=U_0$ 意味着\n$$\n\\left(a x^{\\rho} + b y^{\\rho}\\right)^{1/\\rho} = U_0 \\quad \\Longleftrightarrow \\quad a x^{\\rho} + b y^{\\rho} = U_0^{\\rho}.\n$$\n求解 $y^{\\rho}$ 可得\n$$\ny^{\\rho} = \\frac{U_0^{\\rho} - a x^{\\rho}}{b}.\n$$\n在 $x>0, y>0$ 以及所提供x值的可容许性这一既定假设下，等式右侧为正，因此y的唯一正解是\n$$\ny(x) = \\left(\\frac{U_0^{\\rho} - a x^{\\rho}}{b}\\right)^{1/\\rho}.\n$$\n\n步骤2：边际替代率（MRS）。根据定义，\n$$\n\\text{MRS}(x,y) = \\frac{\\partial U/\\partial x}{\\partial U/\\partial y}.\n$$\n令 $S(x,y) = a x^{\\rho} + b y^{\\rho}$。那么 $U(x,y) = S(x,y)^{1/\\rho}$。使用链式法则，\n$$\n\\frac{\\partial U}{\\partial x} = \\frac{1}{\\rho} S^{1/\\rho - 1} \\cdot a \\rho x^{\\rho - 1} = a x^{\\rho - 1} S^{1/\\rho - 1},\n$$\n$$\n\\frac{\\partial U}{\\partial y} = \\frac{1}{\\rho} S^{1/\\rho - 1} \\cdot b \\rho y^{\\rho - 1} = b y^{\\rho - 1} S^{1/\\rho - 1}.\n$$\n因此，边际替代率可简化为\n$$\n\\text{MRS}(x,y) = \\frac{a x^{\\rho - 1}}{b y^{\\rho - 1}} = \\frac{a}{b} \\left(\\frac{x}{y}\\right)^{\\rho - 1}.\n$$\n\n步骤3：应用于测试套件。对于每个案例，我们使用公式\n$$\ny(x) = \\left(\\frac{U_0^{\\rho} - a x^{\\rho}}{b}\\right)^{1/\\rho},\n$$\n计算 $y_1 = y(x_1)$ 和 $y_2 = y(x_2)$，然后计算 $\\text{MRS}(x_i,y_i) = \\dfrac{a}{b} \\left(\\dfrac{x_i}{y_i}\\right)^{\\rho - 1}$（其中 $i \\in \\{1,2\\}$）。最后，我们构成布尔值 $\\text{decreasing} = \\left[\\text{MRS}(x_1,y_1) > \\text{MRS}(x_2,y_2)\\right]$。下方的数值按要求四舍五入到6位小数。\n\n- 案例1：$a=0.6, b=0.4, \\rho=-1.0, U_0=1.0, x_1=0.61, x_2=0.8$。\n  - $y_1 = \\left(\\dfrac{1.0^{-1.0} - 0.6 \\cdot 0.61^{-1.0}}{0.4}\\right)^{-1} = \\dfrac{0.4 \\cdot 0.61}{0.61 - 0.6} = 24.4 \\rightarrow 24.400000$。\n  - $y_2 = \\left(\\dfrac{1.0^{-1.0} - 0.6 \\cdot 0.8^{-1.0}}{0.4}\\right)^{-1} = \\dfrac{0.4 \\cdot 0.8}{0.8 - 0.6} = 1.6 \\rightarrow 1.600000$。\n  - $\\text{MRS}(x_1,y_1) = \\dfrac{0.6}{0.4} \\left(\\dfrac{0.61}{24.4}\\right)^{-2}$, $\\text{MRS}(x_2,y_2) = \\dfrac{0.6}{0.4} \\left(\\dfrac{0.8}{1.6}\\right)^{-2}$。由于 $\\left(\\dfrac{0.61}{24.4}\\right)^{-2} \\gg \\left(\\dfrac{0.8}{1.6}\\right)^{-2}$，我们得到严格递减：$\\text{decreasing}=\\text{True}$。\n\n- 案例2：$a=0.6, b=0.4, \\rho=0.5, U_0=1.0, x_1=0.5, x_2=2.7$。\n  - $y_1 = \\left(\\dfrac{1.0^{0.5} - 0.6 \\cdot 0.5^{0.5}}{0.4}\\right)^{2} \\approx 2.071067811865475 \\rightarrow 2.071068$。\n  - $y_2 = \\left(\\dfrac{1.0^{0.5} - 0.6 \\cdot 2.7^{0.5}}{0.4}\\right)^{2} \\approx 0.001242456 \\rightarrow 0.001242$。\n  - $\\text{MRS}(x_1,y_1) = \\dfrac{0.6}{0.4} \\left(\\dfrac{0.5}{2.071068}\\right)^{-0.5}$, $\\text{MRS}(x_2,y_2) = \\dfrac{0.6}{0.4} \\left(\\dfrac{2.7}{0.001242}\\right)^{-0.5}$。从数值上看，$\\text{MRS}(x_1,y_1) > \\text{MRS}(x_2,y_2)$，所以 $\\text{decreasing}=\\text{True}$。\n\n- 案例3：$a=0.6, b=0.4, \\rho=2.0, U_0=1.0, x_1=0.3, x_2=1.2$。\n  - $y_1 = \\left(\\dfrac{1.0^{2.0} - 0.6 \\cdot 0.3^{2.0}}{0.4}\\right)^{0.5} = \\sqrt{\\dfrac{1 - 0.054}{0.4}} = \\sqrt{2.365} \\approx 1.5378556 \\rightarrow 1.537856$。\n  - $y_2 = \\left(\\dfrac{1.0^{2.0} - 0.6 \\cdot 1.2^{2.0}}{0.4}\\right)^{0.5} = \\sqrt{\\dfrac{1 - 0.864}{0.4}} = \\sqrt{0.34} \\approx 0.583095 \\rightarrow 0.583095$。\n  - $\\text{MRS}(x_1,y_1) = \\dfrac{0.6}{0.4} \\left(\\dfrac{0.3}{1.537856}\\right)^{1}$, $\\text{MRS}(x_2,y_2) = \\dfrac{0.6}{0.4} \\left(\\dfrac{1.2}{0.583095}\\right)^{1}$。这里 $\\text{MRS}(x_1,y_1) < \\text{MRS}(x_2,y_2)$，所以 $\\text{decreasing}=\\text{False}$。\n\n因此，每个案例的预期列表（其中y值四舍五入到6位小数并附带布尔标志）如下：\n- 案例1：$[24.400000, 1.600000, \\text{True}]$。\n- 案例2：$[2.071068, 0.001242, \\text{True}]$。\n- 案例3：$[1.537856, 0.583095, \\text{False}]$。\n\n程序应将这三个案例的结果输出为单行，格式为用方括号括起来的、以逗号分隔的列表，其中每个案例的结果本身也是一个按上述案例顺序排列的、用方括号括起来的逗号分隔列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef compute_y(a, b, rho, U0, x):\n    # Compute y on the indifference curve U(x,y)=U0 with y>0\n    base = (U0**rho - a * (x**rho)) / b\n    if base <= 0:\n        # Domain violation; for given test suite this should not occur.\n        return float('nan')\n    y = base ** (1.0 / rho)\n    return y\n\ndef mrs(a, b, rho, x, y):\n    # MRS = MU_x / MU_y = (a/b) * (x/y)^(rho - 1)\n    return (a / b) * ((x / y) ** (rho - 1.0))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (a, b, rho, U0, x1, x2)\n    test_cases = [\n        (0.6, 0.4, -1.0, 1.0, 0.61, 0.8),\n        (0.6, 0.4,  0.5, 1.0, 0.5,  2.7),\n        (0.6, 0.4,  2.0, 1.0, 0.3,  1.2),\n    ]\n\n    case_outputs = []\n    for a, b, rho, U0, x1, x2 in test_cases:\n        y1 = compute_y(a, b, rho, U0, x1)\n        y2 = compute_y(a, b, rho, U0, x2)\n\n        # Compute MRS at both points\n        mrs1 = mrs(a, b, rho, x1, y1)\n        mrs2 = mrs(a, b, rho, x2, y2)\n        decreasing = mrs1 > mrs2\n\n        # Format y-values to 6 decimal places\n        y1_str = f\"{y1:.6f}\"\n        y2_str = f\"{y2:.6f}\"\n        case_str = f\"[{y1_str},{y2_str},{decreasing}]\"\n        case_outputs.append(case_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(case_outputs)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2401500"}, {"introduction": "在无差异曲线概念的基础上，本实践将解决消费者理论的核心问题：在给定预算下寻找最优消费束。您将了解到，对于许多现实且复杂的效用函数，经典的相切条件——即边际替代率等于价格比率——无法通过简单的解析方法求解。本练习要求您应用数值根查找算法来精确定位效用最大化的消费点，从而展示了计算经济学中的一项强大技术。[@problem_id:2401479]", "problem": "考虑一个消费者选择两种商品的组合，其数量分别用 $x$ 和 $y$ 表示。该消费者面临严格为正的价格 $p_x$ 和 $p_y$，其收入为 $m > 0$。偏好由以下效用函数表示：\n$$\nu(x,y) \\;=\\; a_1 \\ln(x) \\;+\\; a_2 \\ln(y) \\;+\\; b_1 \\sqrt{x} \\;+\\; b_2 \\sqrt{y} \\;+\\; c \\left(\\theta x^{\\rho} + (1-\\theta) y^{\\rho}\\right)^{\\tfrac{1}{\\rho}},\n$$\n其中 $a_1,a_2,b_1,b_2,c,\\theta,\\rho$ 是满足 $a_1 > 0$、$a_2 > 0$、$b_1 \\ge 0$、$b_2 \\ge 0$、$c \\ge 0$、$0 < \\theta < 1$ 以及 $0 < \\rho < 1$ 的参数。假设 $x > 0$ 且 $y > 0$。消费者的预算集由线性约束 $p_x x + p_y y \\le m$ 定义，而单调性意味着预算约束在最优点处是紧的，因此 $p_x x + p_y y = m$。\n\n商品 $x$ 对商品 $y$ 的边际替代率定义为 $MRS_{xy} = MU_x / MU_y$，其中 $MU_x$ 和 $MU_y$ 分别是关于 $x$ 和 $y$ 的边际效用。内部最优点满足条件 $MRS_{xy} = p_x/p_y$ 和 $p_x x + p_y y = m$。\n\n你的任务是通过求解由边际替代率等于价格比以及紧的预算约束所构成的方程组，为下面测试套件中的每一组参数计算出唯一的内部最优商品束 $(x^\\star, y^\\star)$。解必须满足 $x^\\star > 0$ 和 $y^\\star > 0$。\n\n测试套件（每个测试是一个有序元组 $(a_1,a_2,b_1,b_2,c,\\theta,\\rho,p_x,p_y,m)$）：\n- 测试 $1$：$(0.9, 1.1, 0.7, 0.8, 0.6, 0.35, 0.5, 2.0, 1.5, 12.0)$\n- 测试 $2$：$(1.0, 1.0, 0.5, 0.5, 0.9, 0.6, 0.4, 5.0, 1.0, 10.0)$\n- 测试 $3$：$(0.8, 1.2, 0.6, 0.9, 0.7, 0.4, 0.7, 1.2, 1.3, 100.0)$\n- 测试 $4$：$(1.5, 0.7, 0.4, 0.6, 0.5, 0.5, 0.6, 3.0, 2.0, 5.0)$\n\n答案规格：\n- 对每个测试，输出数对 $[x^\\star,y^\\star]$，四舍五入到 $6$ 位小数。\n- 将所有测试的结果按测试顺序汇总到单行中，形成一个不带空格的列表的列表。例如，对于 $4$ 个测试，一个有效的输出格式为 $[[x_1,y_1],[x_2,y_2],[x_3,y_3],[x_4,y_4]]$，其中每个 $x_i$ 和 $y_i$ 都是四舍五入到 $6$ 位小数的浮点数。", "solution": "所给问题是微观经济学理论中一个经典的效用最大化问题。消费者寻求选择两种商品的组合（数量用 $x > 0$ 和 $y > 0$ 表示），以在线性预算约束下最大化给定的效用函数。该问题定义明确，有科学依据，并提供了求得唯一解所需的所有信息。\n\n消费者的最优化问题是：\n$$\n\\max_{x,y} \\; u(x,y) \\quad \\text{subject to} \\quad p_x x + p_y y \\le m\n$$\n效用函数由下式给出：\n$$\nu(x,y) = a_1 \\ln(x) + a_2 \\ln(y) + b_1 \\sqrt{x} + b_2 \\sqrt{y} + c \\left(\\theta x^{\\rho} + (1-\\theta) y^{\\rho}\\right)^{\\frac{1}{\\rho}}\n$$\n给定参数 $a_1 > 0$ 和 $a_2 > 0$，对数项确保了当 $x$ 或 $y$ 趋近于零时，边际效用趋于无穷大。这保证了任何最优解都必须是内部解，即 $x^\\star > 0$ 且 $y^\\star > 0$。对于内部解，预算约束将是紧的，即 $p_x x + p_y y = m$。\n\n内部最优点的条件有两方面：\n1. 必须满足预算约束：$p_x x + p_y y = m$。\n2. 无差异曲线的斜率必须等于预算线的斜率。这就是相切条件，表示为边际替代率（$MRS_{xy}$）与价格比相等：\n$$\nMRS_{xy} = \\frac{MU_x}{MU_y} = \\frac{p_x}{p_y}\n$$\n其中 $MU_x = \\frac{\\partial u}{\\partial x}$ 和 $MU_y = \\frac{\\partial u}{\\partial y}$ 分别是商品 $x$ 和商品 $y$ 的边际效用。\n\n首先，我们必须通过对效用函数 $u(x,y)$求偏导数来推导边际效用。\n关于 $x$ 的边际效用是：\n$$\nMU_x = \\frac{\\partial u}{\\partial x} = \\frac{a_1}{x} + \\frac{b_1}{2\\sqrt{x}} + c \\theta \\left(\\theta x^{\\rho} + (1-\\theta) y^{\\rho}\\right)^{\\frac{1-\\rho}{\\rho}} x^{\\rho-1}\n$$\n关于 $y$ 的边际效用是：\n$$\nMU_y = \\frac{\\partial u}{\\partial y} = \\frac{a_2}{y} + \\frac{b_2}{2\\sqrt{y}} + c (1-\\theta) \\left(\\theta x^{\\rho} + (1-\\theta) y^{\\rho}\\right)^{\\frac{1-\\rho}{\\rho}} y^{\\rho-1}\n$$\n最优性条件构成了一个包含两个未知数 $x$ 和 $y$ 的非线性方程组：\n$$\n\\begin{cases}\np_y \\left( \\frac{a_1}{x} + \\frac{b_1}{2\\sqrt{x}} + c \\theta (\\dots)^{\\frac{1-\\rho}{\\rho}} x^{\\rho-1} \\right) = p_x \\left( \\frac{a_2}{y} + \\frac{b_2}{2\\sqrt{y}} + c (1-\\theta) (\\dots)^{\\frac{1-\\rho}{\\rho}} y^{\\rho-1} \\right) \\\\\np_x x + p_y y = m\n\\end{cases}\n$$\n由于这些方程的复杂性，解析解是难以求得的。因此，需要采用数值方法。\n\n该方程组可以简化为一个单变量求根问题。根据预算约束，我们将 $y$ 表示为 $x$ 的函数：\n$$\ny(x) = \\frac{m - p_x x}{p_y}\n$$\n对于内部解，我们要求 $x > 0$ 和 $y > 0$。条件 $y > 0$ 意味着 $m - p_x x > 0$，即 $x < m/p_x$。因此，$x$ 的搜索空间是开区间 $(0, m/p_x)$。\n\n通过将 $y(x)$ 代入整理后的相切条件 $p_y MU_x - p_x MU_y = 0$，我们得到一个关于 $x$ 的单一方程：\n$$\nf(x) = p_y \\cdot MU_x(x, y(x)) - p_x \\cdot MU_y(x, y(x)) = 0\n$$\n我们必须在区间 $(0, m/p_x)$ 内找到 $f(x)$ 的根。让我们考察 $f(x)$ 在区间边界处的行为。\n当 $x \\to 0^+$ 时，$MU_x$ 中的项 $\\frac{a_1}{x}$ 和 $\\frac{b_1}{2\\sqrt{x}}$ 趋于 $+\\infty$，而 $MU_y$ 保持有限。因此，$f(x) \\to +\\infty$。\n当 $x \\to (m/p_x)^-$ 时，$y(x) \\to 0^+$。$MU_y$ 中的项 $\\frac{a_2}{y}$ 和 $\\frac{b_2}{2\\sqrt{y}}$ 趋于 $+\\infty$，而 $MU_x$ 保持有限。因此，$f(x) \\to -\\infty$。\n\n由于 $f(x)$ 在区间 $(0, m/p_x)$ 上是连续的，并且其在边界处的值符号相反，根据介值定理，可以保证在该区间内至少存在一个根 $x^\\star$。所提供的效用函数是严格拟凹的，这确保了该根是唯一的。\n\n找到唯一的商品束 $(x^\\star, y^\\star)$ 的算法如下：\n1. 对每个测试用例，根据给定的常数 $(a_1, a_2, b_1, b_2, c, \\theta, \\rho, p_x, p_y, m)$ 定义如上所述的函数 $f(x)$。\n2. 为 $x$ 建立一个搜索区间，例如 $[\\epsilon, m/p_x - \\epsilon]$，其中 $\\epsilon$ 是一个很小的正数（例如 $10^{-9}$），以避免在边界处出现数值不稳定性。\n3. 使用稳健的一维求根算法（如 Brent 方法）来求解 $f(x) = 0$ 以得到 $x^\\star$。`scipy.optimize.brentq` 函数适用于此任务，因为如果函数在区间端点的值符号相反，它保证能找到一个根。\n4. 一旦找到最优值 $x^\\star$，使用预算约束 $y^\\star = (m - p_x x^\\star) / p_y$ 计算出相应的商品 $y$ 的最优数量。\n5. 所得数对 $(x^\\star, y^\\star)$ 即为唯一的最优消费束。\n6. 对每个测试用例，将计算出的值四舍五入到 $6$ 位小数，并汇总成指定的输出格式。\n将实施此程序来求解所有给定测试用例的最优商品束。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Computes the optimal consumption bundle (x*, y*) for a given utility function\n    and budget constraint by numerically solving the system of first-order conditions.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.9, 1.1, 0.7, 0.8, 0.6, 0.35, 0.5, 2.0, 1.5, 12.0),\n        (1.0, 1.0, 0.5, 0.5, 0.9, 0.6, 0.4, 5.0, 1.0, 10.0),\n        (0.8, 1.2, 0.6, 0.9, 0.7, 0.4, 0.7, 1.2, 1.3, 100.0),\n        (1.5, 0.7, 0.4, 0.6, 0.5, 0.5, 0.6, 3.0, 2.0, 5.0)\n    ]\n\n    results = []\n    for params in test_cases:\n        a1, a2, b1, b2, c, theta, rho, px, py, m = params\n\n        def objective_function(x):\n            \"\"\"\n            This function represents the rearranged tangency condition: p_y*MU_x - p_x*MU_y = 0.\n            We solve for the root of this function to find the optimal x.\n            The variable y is substituted using the budget constraint y = (m - px*x) / py.\n            \"\"\"\n            # Ensure x is within the valid domain (0, m/px)\n            if x <= 1e-12:\n                # If x is near zero, MUx dominates, so f(x) -> +inf\n                return np.inf\n            \n            y = (m - px * x) / py\n            \n            if y <= 1e-12:\n                # If y is near zero, MUy dominates, so f(x) -> -inf\n                return -np.inf\n\n            # Calculate Marginal Utility of x (MU_x)\n            mu_x_term1 = a1 / x\n            mu_x_term2 = b1 / (2 * np.sqrt(x))\n            if c > 0:\n                Z = theta * x**rho + (1 - theta) * y**rho\n                mu_x_term3 = c * theta * (Z**((1 - rho) / rho)) * (x**(rho - 1))\n            else:\n                mu_x_term3 = 0.0\n            mu_x = mu_x_term1 + mu_x_term2 + mu_x_term3\n\n            # Calculate Marginal Utility of y (MU_y)\n            mu_y_term1 = a2 / y\n            mu_y_term2 = b2 / (2 * np.sqrt(y))\n            if c > 0:\n                # Z is the same and already computed if c > 0\n                mu_y_term3 = c * (1 - theta) * (Z**((1 - rho) / rho)) * (y**(rho - 1))\n            else:\n                mu_y_term3 = 0.0\n            mu_y = mu_y_term1 + mu_y_term2 + mu_y_term3\n\n            return py * mu_x - px * mu_y\n\n        # The search for optimal x must be in the interval (0, m/px) to ensure x > 0 and y > 0.\n        # We use a small epsilon to avoid division by zero or other numerical issues at the boundaries.\n        lower_bound = 1e-9\n        upper_bound = m / px - 1e-9\n        \n        # Use Brent's method to find the root of the objective function.\n        # This gives us the optimal quantity of good x.\n        optimal_x = brentq(objective_function, lower_bound, upper_bound)\n        \n        # Calculate the optimal quantity of good y from the budget constraint.\n        optimal_y = (m - px * optimal_x) / py\n\n        # Append the rounded results to the list.\n        results.append([round(optimal_x, 6), round(optimal_y, 6)])\n\n    # Format the final output string to match the specified format: [[x1,y1],[x2,y2],...] with no spaces.\n    final_output_str = f\"[{','.join(map(str, results))}]\".replace(\" \", \"\")\n    print(final_output_str)\n\nsolve()\n```", "id": "2401479"}, {"introduction": "这最后一项实践将您的分析从单个消费者提升到整个纯交换经济。通过推导并汇总每个经济主体的需求——他们都基于各自的柯布-道格拉斯偏好做出最优决策——您将确定市场出清的均衡价格。这项练习展示了通过无差异曲线可视化的个人效用最大化原则，如何扩展以解释市场范围内的现象，并构成了构建一般均衡理论的基石。[@problem_id:2401506]", "problem": "考虑一个纯交换、静态、双商品的经济体，其中存在有限个代理人，由 $i \\in \\{1,\\dots,N\\}$ 索引。每个代理人 $i$ 拥有商品 $x$ 和 $y$ 的禀赋 $(w_i^x, w_i^y) \\in \\mathbb{R}_+^2$，其偏好由 Cobb–Douglas 效用函数 $U_i(x_i,y_i) = x_i^{\\alpha_i} y_i^{1-\\alpha_i}$ 表示，参数 $\\alpha_i \\in [0,1]$。价格为严格正数，记为 $(p_x, p_y)$；我们通过设定 $p_y = 1$ 进行归一化，并记 $p_x = p$。竞争性均衡是一个价格 $p > 0$ 和一个配置 $\\{(x_i^*, y_i^*)\\}_{i=1}^N$，使得：(i) 对每个 $i$，$(x_i^*, y_i^*)$ 在预算集 $\\{(x_i, y_i) \\in \\mathbb{R}_+^2: p x_i + y_i \\le m_i\\}$ 中是效用最大化的，其中 $m_i = p w_i^x + w_i^y$，并且 (ii) 市场出清，即 $\\sum_{i=1}^N x_i^* = \\sum_{i=1}^N w_i^x$ 且 $\\sum_{i=1}^N y_i^* = \\sum_{i=1}^N w_i^y$。您编写的程序必须通过从这些关于偏好、预算集和市场出清的核心定义出发，并推导出这些基元所蕴含的相应需求行为，来为每个测试用例计算均衡价格 $p$。角度和物理单位不适用；所有量均为无单位的实数。\n\n您的程序必须解决以下参数集测试套件。对于每个测试用例 $k$，您将获得列表 $\\{\\alpha_i\\}_{i=1}^{N_k}$、$\\{w_i^x\\}_{i=1}^{N_k}$ 和 $\\{w_i^y\\}_{i=1}^{N_k}$。\n\n- 测试用例 $1$ (理想路径):\n  - $N_1 = 3$\n  - $\\{\\alpha_i\\} = \\{0.3,\\,0.5,\\,0.7\\}$\n  - $\\{w_i^x\\} = \\{2.0,\\,1.0,\\,3.0\\}$\n  - $\\{w_i^y\\} = \\{1.0,\\,2.0,\\,1.0\\}$\n\n- 测试用例 $2$ (接近边界的偏好和禀赋中的零值):\n  - $N_2 = 4$\n  - $\\{\\alpha_i\\} = \\{0.01,\\,0.4,\\,0.6,\\,0.9\\}$\n  - $\\{w_i^x\\} = \\{0.0,\\,1.0,\\,2.0,\\,1.0\\}$\n  - $\\{w_i^y\\} = \\{3.0,\\,0.0,\\,1.0,\\,0.0\\}$\n\n- 测试用例 $3$ (对称的总量，边界相等性检查):\n  - $N_3 = 2$\n  - $\\{\\alpha_i\\} = \\{0.4,\\,0.6\\}$\n  - $\\{w_i^x\\} = \\{1.0,\\,1.0\\}$\n  - $\\{w_i^y\\} = \\{1.0,\\,1.0\\}$\n\n- 测试用例 $4$ (异质alpha与稀疏禀赋):\n  - $N_4 = 3$\n  - $\\{\\alpha_i\\} = \\{0.2,\\,0.8,\\,0.5\\}$\n  - $\\{w_i^x\\} = \\{0.0,\\,2.0,\\,1.0\\}$\n  - $\\{w_i^y\\} = \\{2.0,\\,0.0,\\,3.0\\}$\n\n您的程序必须为每个测试用例计算由效用最大化和市场出清所决定的竞争性均衡相对价格 $p$ (当 $p_y = 1$ 时)。将每个 $p$ 四舍五入到恰好 $6$ 位小数后报告。最终输出格式必须是单行，包含由方括号括起来的四个逗号分隔的结果，不含空格。例如，输出格式必须类似于 \"[r1,r2,r3,r4]\"，其中 $r_k$ 是四舍五入后的数字，如 $[0.123456,1.000000,2.500000,0.314159]$。\n\n您的程序不得读取任何输入，并且必须是完全自包含的。唯一要求的输出是上述单行文本。预期的解题方法必须从所述的基元（偏好、预算集和市场出清）开始，推导由 Cobb–Douglas 偏好下的无差异曲线和预算线所决定的个人需求，汇总为市场需求，然后施加市场出清条件来确定均衡价格 $p$。", "solution": "问题陈述经过严格审视，被认定为有效。它提出了一个计算微观经济学中适定的问题，该问题基于成熟的经济学理论，并给出了一套完整且一致的已知条件。不存在科学或逻辑上的缺陷。任务是计算一个纯交换经济中的竞争性均衡价格，这是一个标准的可解问题。\n\n解决方案首先通过从每个代理人的效用最大化问题中推导出个人需求函数来着手。其次，将这些个人需求汇总以形成总市场需求。最后，施加市场出清条件（即总需求等于总供给），以求解均衡价格。\n\n设代理人 $i$ 的特征由 Cobb-Douglas 效用函数 $U_i(x_i, y_i) = x_i^{\\alpha_i} y_i^{1-\\alpha_i}$ 和禀赋 $(w_i^x, w_i^y)$ 描述。商品 $y$ 的价格被归一化为 $p_y=1$，商品 $x$ 的价格记为 $p > 0$。代理人的收入或财富为 $m_i = p w_i^x + w_i^y$。\n\n代理人的效用最大化问题 (UMP) 是：\n$$ \\max_{x_i, y_i \\ge 0} x_i^{\\alpha_i} y_i^{1-\\alpha_i} \\quad \\text{以} \\quad p x_i + y_i \\le m_i \\quad \\text{为约束条件} $$\n由于效用函数对两个参数都是严格递增的，在最优点，预算约束将是紧的，即 $p x_i + y_i = m_i$。对于内部解（当 $\\alpha_i \\in (0,1)$ 时可以保证），无差异曲线与预算线之间的相切条件必须成立。边际替代率 (MRS) 由下式给出：\n$$ \\text{MRS}_{i} = \\frac{\\partial U_i / \\partial x_i}{\\partial U_i / \\partial y_i} = \\frac{\\alpha_i x_i^{\\alpha_i-1} y_i^{1-\\alpha_i}}{(1-\\alpha_i) x_i^{\\alpha_i} y_i^{-\\alpha_i}} = \\frac{\\alpha_i}{1-\\alpha_i} \\frac{y_i}{x_i} $$\n在最优点，MRS 必须等于价格比率 $p_x/p_y = p/1 = p$：\n$$ \\frac{\\alpha_i}{1-\\alpha_i} \\frac{y_i}{x_i} = p \\implies y_i = p \\frac{1-\\alpha_i}{\\alpha_i} x_i $$\n将此 $y_i$ 表达式代入预算约束 $p x_i + y_i = m_i$：\n$$ p x_i + p \\frac{1-\\alpha_i}{\\alpha_i} x_i = m_i $$\n$$ p x_i \\left( 1 + \\frac{1-\\alpha_i}{\\alpha_i} \\right) = m_i \\implies p x_i \\left( \\frac{\\alpha_i + 1 - \\alpha_i}{\\alpha_i} \\right) = m_i \\implies \\frac{p x_i}{\\alpha_i} = m_i $$\n这得出了商品 $x$ 上的支出占收入的比例为 $\\alpha_i$：$p x_i = \\alpha_i m_i$。商品 $x$ 的个人需求函数，记作 $x_i^*(p)$，是：\n$$ x_i^*(p) = \\frac{\\alpha_i m_i}{p} $$\n代入 $m_i = p w_i^x + w_i^y$，我们得到以价格 $p$ 和代理人基元表示的商品 $x$ 的需求：\n$$ x_i^*(p) = \\frac{\\alpha_i(p w_i^x + w_i^y)}{p} = \\alpha_i w_i^x + \\frac{\\alpha_i w_i^y}{p} $$\n同样，商品 $y$ 的需求是 $y_i^*(p) = (1-\\alpha_i)m_i = (1-\\alpha_i)(p w_i^x + w_i^y)$。\n\n均衡价格 $p$ 通过对其中一种商品施加市场出清条件来找到。根据 Walras's Law，如果一个市场出清，另一个市场也会出清。我们使用商品 $x$ 的市场。商品 $x$ 的总需求必须等于其总供给（总禀赋）：\n$$ \\sum_{i=1}^N x_i^*(p) = \\sum_{i=1}^N w_i^x $$\n代入个人需求 $x_i^*(p)$ 的表达式：\n$$ \\sum_{i=1}^N \\left( \\alpha_i w_i^x + \\frac{\\alpha_i w_i^y}{p} \\right) = \\sum_{i=1}^N w_i^x $$\n我们现在求解这个方程以得到 $p$。整理各项：\n$$ \\sum_{i=1}^N \\frac{\\alpha_i w_i^y}{p} = \\sum_{i=1}^N w_i^x - \\sum_{i=1}^N \\alpha_i w_i^x $$\n$$ \\frac{1}{p} \\sum_{i=1}^N \\alpha_i w_i^y = \\sum_{i=1}^N (1 - \\alpha_i) w_i^x $$\n只要 $\\sum_{i=1}^N (1 - \\alpha_i) w_i^x \\neq 0$（对于所有给定的测试用例都成立），我们就可以解出 $p$：\n$$ p = \\frac{\\sum_{i=1}^N \\alpha_i w_i^y}{\\sum_{i=1}^N (1 - \\alpha_i) w_i^x} $$\n这个封闭形式的表达式允许根据经济体的参数 $\\{\\alpha_i\\}_{i=1}^N$、$\\{w_i^x\\}_{i=1}^N$ 和 $\\{w_i^y\\}_{i=1}^N$ 直接计算均衡价格 $p$。对于所有提供的测试用例，分子和分母都是严格正的，确保了唯一、正的均衡价格 $p>0$。现在实施此公式以解决给定的测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the competitive equilibrium price for a series of pure-exchange economies.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple containing lists for alphas, endowments of x, and endowments of y.\n    test_cases = [\n        # Test case 1\n        (\n            [0.3, 0.5, 0.7],          # alphas\n            [2.0, 1.0, 3.0],          # endowments w_x\n            [1.0, 2.0, 1.0]           # endowments w_y\n        ),\n        # Test case 2\n        (\n            [0.01, 0.4, 0.6, 0.9],    # alphas\n            [0.0, 1.0, 2.0, 1.0],     # endowments w_x\n            [3.0, 0.0, 1.0, 0.0]      # endowments w_y\n        ),\n        # Test case 3\n        (\n            [0.4, 0.6],               # alphas\n            [1.0, 1.0],               # endowments w_x\n            [1.0, 1.0]                # endowments w_y\n        ),\n        # Test case 4\n        (\n            [0.2, 0.8, 0.5],          # alphas\n            [0.0, 2.0, 1.0],          # endowments w_x\n            [2.0, 0.0, 3.0]           # endowments w_y\n        )\n    ]\n\n    results = []\n    # Loop over each test case to calculate the equilibrium price p.\n    for case in test_cases:\n        alphas, w_x, w_y = case\n\n        # Convert lists to NumPy arrays for efficient vectorized computation.\n        alphas_arr = np.array(alphas)\n        w_x_arr = np.array(w_x)\n        w_y_arr = np.array(w_y)\n\n        # The equilibrium price p is derived from the market clearing condition for good x:\n        # Sum(alpha_i * w_i_y) / Sum((1 - alpha_i) * w_i_x)\n        \n        # Calculate the numerator of the price formula.\n        # This is the sum of alpha_i * w_i_y over all agents i.\n        numerator = np.dot(alphas_arr, w_y_arr)\n\n        # Calculate the denominator of the price formula.\n        # This is the sum of (1 - alpha_i) * w_i_x over all agents i.\n        denominator = np.dot(1 - alphas_arr, w_x_arr)\n\n        # Calculate the equilibrium price p.\n        # Check for division by zero, although not expected for the given test cases.\n        if denominator == 0:\n            # Handle cases where equilibrium might not be well-defined or is at a boundary.\n            # This is not triggered by the problem's test suite.\n            p = np.nan\n        else:\n            p = numerator / denominator\n\n        # Format the result to exactly 6 decimal places and add to the results list.\n        results.append(f\"{p:.6f}\")\n\n    # Final print statement in the exact required format: [r1,r2,r3,r4]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2401506"}]}