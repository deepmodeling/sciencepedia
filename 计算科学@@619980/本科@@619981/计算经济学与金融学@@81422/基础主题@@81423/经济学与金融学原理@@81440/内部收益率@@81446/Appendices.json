{"hands_on_practices": [{"introduction": "这项练习颠覆了典型的问题解决方法。你不再是根据给定的现金流计算IRR，而是要去设计一个项目以达到一个特定的高回报目标[@problem_id:2403035]。这种实践旨在强化现金流与IRR之间基础的代数关系，并鼓励你思考项目参数如何影响其盈利能力。", "problem": "一个项目在整数时间 $t=0,1,\\dots,n$ 产生现金流。在时间 $t=0$ 时，现金流为 $-I$，其中 $I>0$。在每个时间 $t=1,2,\\dots,n$ 时，项目支付一笔恒定的现金流 $A$。内部收益率 (IRR) 定义为使得净现值满足以下条件的收益率 $r$：\n$$\\sum_{t=0}^{n} \\frac{\\mathrm{CF}_t}{(1+r)^{t}}=0,$$\n其中 $\\mathrm{CF}_t$ 表示在时间 $t$ 的现金流。假设内部收益率等于 $r=1$。请确定比率 $A/I$ 的值，以一个关于 $n$ 的封闭形式解析表达式表示。你的答案应为一个简化的单一表达式，不带单位，也无需四舍五入。", "solution": "该问题陈述科学严谨、问题定义明确、客观，并包含足够的信息以获得唯一解。我们开始进行推导。\n\n内部收益率 (IRR)，记为 $r$，其定义条件为一系列现金流 $\\mathrm{CF}_t$ 的净现值 (NPV) 为零。净现值的计算公式如下：\n$$ \\sum_{t=0}^{n} \\frac{\\mathrm{CF}_t}{(1+r)^{t}}=0 $$\n该问题指明了一个项目在 $n+1$ 个时期内的现金流。在时间 $t=0$ 时，现金流是一笔初始投资，所以 $\\mathrm{CF}_0 = -I$，其中 $I > 0$。在随后的时间 $t=1, 2, \\dots, n$ 内，项目产生一笔恒定的回报，所以 $\\mathrm{CF}_t = A$。\n\n将这些具体的现金流代入净现值方程，我们得到：\n$$ \\frac{\\mathrm{CF}_0}{(1+r)^{0}} + \\sum_{t=1}^{n} \\frac{\\mathrm{CF}_t}{(1+r)^{t}} = 0 $$\n$$ \\frac{-I}{1} + \\sum_{t=1}^{n} \\frac{A}{(1+r)^{t}} = 0 $$\n我们可以将恒定的现金流 $A$ 从求和式中提出来：\n$$ -I + A \\sum_{t=1}^{n} \\frac{1}{(1+r)^{t}} = 0 $$\n问题指出该项目的内部收益率为 $r=1$。我们必须将此值代入我们的方程中：\n$$ -I + A \\sum_{t=1}^{n} \\frac{1}{(1+1)^{t}} = 0 $$\n$$ -I + A \\sum_{t=1}^{n} \\left(\\frac{1}{2}\\right)^{t} = 0 $$\n求和项是一个有限几何级数。一个有限几何级数 $\\sum_{k=1}^{n} x^k$ 的和为 $x \\frac{1-x^n}{1-x}$。在我们的例子中，公比为 $x = \\frac{1}{2}$。应用这个公式，我们求出该和的值：\n$$ \\sum_{t=1}^{n} \\left(\\frac{1}{2}\\right)^{t} = \\left(\\frac{1}{2}\\right) \\frac{1 - \\left(\\frac{1}{2}\\right)^n}{1 - \\frac{1}{2}} = \\left(\\frac{1}{2}\\right) \\frac{1 - \\frac{1}{2^n}}{\\frac{1}{2}} = 1 - \\frac{1}{2^n} $$\n现在，我们将此结果代回主方程：\n$$ -I + A \\left(1 - \\frac{1}{2^n}\\right) = 0 $$\n我们的目标是确定比率 $A/I$。我们重新整理方程以求解该比率：\n$$ A \\left(1 - \\frac{1}{2^n}\\right) = I $$\n两边同除以 $I$ 得到：\n$$ \\frac{A}{I} \\left(1 - \\frac{1}{2^n}\\right) = 1 $$\n分离出比率 $A/I$ 可得：\n$$ \\frac{A}{I} = \\frac{1}{1 - \\frac{1}{2^n}} $$\n为了将其表示为一个简化的封闭形式表达式，我们合并分母中的项：\n$$ \\frac{A}{I} = \\frac{1}{\\frac{2^n - 1}{2^n}} $$\n最后，取分母的倒数得到结果：\n$$ \\frac{A}{I} = \\frac{2^n}{2^n - 1} $$\n这就是比率 $A/I$ 关于 $n$ 的封闭形式解析表达式。", "answer": "$$\\boxed{\\frac{2^n}{2^n - 1}}$$", "id": "2403035"}, {"introduction": "金融领域一个常见的误区是想当然地认为投资组合的IRR就是其组成项目IRR的加权平均值。本练习将通过计算一个组合项目的IRR，来揭示为何这种直觉是错误的[@problem_id:2403026]。理解这种非线性特性对于准确评估多元化投资至关重要。", "problem": "一家公司评估两个独立的、规模固定的项目，其年度现金流如下。时间以年为单位，现金流发生在每年年末。项目A的现金流为 $C^{A}_{0}=-100$， $C^{A}_{1}=+60$， $C^{A}_{2}=+60$。项目B的现金流为 $C^{B}_{0}=-100$， $C^{B}_{1}=+0$， $C^{B}_{2}=+130$。该公司通过投资一个单位的项目A和一个单位的项目B来构建一个投资组合，因此该投资组合的现金流为 $C^{P}_{t}=C^{A}_{t}+C^{B}_{t}$，其中 $t\\in\\{0,1,2\\}$。\n\n根据定义，内部收益率（IRR）是使净现值（NPV）为零的数值 $r$，即对于给定的现金流 $\\{C_{t}\\}_{t=0}^{T}$，有 $\\sum_{t=0}^{T}\\frac{C_{t}}{(1+r)^{t}}=0$。\n\n请仅使用此定义，计算该投资组合的IRR，并使用基于NPV定义的方程来证明，为什么该投资组合的IRR不是以初始投资额为权重的各单个项目IRR的简单加权平均值。仅报告投资组合的IRR，以小数形式表示，并四舍五入到四位有效数字。不要使用百分号。", "solution": "该问题陈述已经过验证，被认为是科学合理的、定义明确且客观的。这是一个计算金融学中的标准问题。\n\n首先，我们确定投资组合的现金流。该投资组合包含一个单位的项目A和一个单位的项目B。在时间 $t$ 的投资组合现金流，记为 $C^{P}_{t}$，是各单个项目现金流的总和，即 $C^{P}_{t} = C^{A}_{t} + C^{B}_{t}$。\n\n给定的现金流如下：\n项目A：$C^{A}_{0}=-100$，$C^{A}_{1}=+60$，$C^{A}_{2}=+60$。\n项目B：$C^{B}_{0}=-100$，$C^{B}_{1}=+0$，$C^{B}_{2}=+130$。\n\n由此产生的投资组合现金流为：\n$C^{P}_{0} = C^{A}_{0} + C^{B}_{0} = -100 + (-100) = -200$。\n$C^{P}_{1} = C^{A}_{1} + C^{B}_{1} = 60 + 0 = 60$。\n$C^{P}_{2} = C^{A}_{2} + C^{B}_{2} = 60 + 130 = 190$。\n\n投资组合的内部收益率（IRR），我们记为 $r_{P}$，是使投资组合现金流的净现值（NPV）为零的贴现率。投资组合的NPV由以下方程给出：\n$$\n\\text{NPV}_{P}(r) = \\sum_{t=0}^{2} \\frac{C^{P}_{t}}{(1+r)^{t}} = C^{P}_{0} + \\frac{C^{P}_{1}}{1+r} + \\frac{C^{P}_{2}}{(1+r)^{2}}\n$$\n令 $\\text{NPV}_{P}(r_{P}) = 0$：\n$$\n-200 + \\frac{60}{1+r_{P}} + \\frac{190}{(1+r_{P})^{2}} = 0\n$$\n为了求解此方程中的 $r_{P}$，我们引入换元 $x = \\frac{1}{1+r_{P}}$。该方程变为关于 $x$ 的二次方程：\n$$\n190x^{2} + 60x - 200 = 0\n$$\n两边同除以 $10$ 可将方程简化为：\n$$\n19x^{2} + 6x - 20 = 0\n$$\n我们使用二次公式 $x = \\frac{-b \\pm \\sqrt{b^{2}-4ac}}{2a}$ 求解 $x$：\n$$\nx = \\frac{-6 \\pm \\sqrt{6^{2} - 4(19)(-20)}}{2(19)} = \\frac{-6 \\pm \\sqrt{36 + 1520}}{38} = \\frac{-6 \\pm \\sqrt{1556}}{38}\n$$\n由于 $r_{P}$ 代表传统投资的利率，我们预期 $1+r_{P} > 0$，这意味着 $x = \\frac{1}{1+r_{P}}$ 必须为正。因此，我们取正根：\n$$\nx = \\frac{-6 + \\sqrt{1556}}{38} = \\frac{-6 + 2\\sqrt{389}}{38} = \\frac{-3 + \\sqrt{389}}{19}\n$$\n使用数值近似 $\\sqrt{389} \\approx 19.72308$，我们得到：\n$$\nx \\approx \\frac{-3 + 19.72308}{19} = \\frac{16.72308}{19} \\approx 0.880162\n$$\n现在我们从换元 $x = \\frac{1}{1+r_{P}}$ 中求解 $r_{P}$：\n$$\n1+r_{P} = \\frac{1}{x} \\approx \\frac{1}{0.880162} \\approx 1.136154\n$$\n$$\nr_{P} \\approx 1.136154 - 1 = 0.136154\n$$\n四舍五入到四位有效数字，投资组合的IRR为 $0.1362$。\n\n接下来，我们必须证明为什么投资组合的IRR不是各单个项目IRR的简单加权平均值。设 $r_{A}$ 和 $r_{B}$ 分别为项目A和项目B的IRR。它们由各自NPV方程的根定义：\n$$\n\\text{NPV}_{A}(r_{A}) = \\sum_{t=0}^{2} \\frac{C^{A}_{t}}{(1+r_{A})^{t}} = -100 + \\frac{60}{1+r_{A}} + \\frac{60}{(1+r_{A})^{2}} = 0\n$$\n$$\n\\text{NPV}_{B}(r_{B}) = \\sum_{t=0}^{2} \\frac{C^{B}_{t}}{(1+r_{B})^{t}} = -100 + \\frac{0}{1+r_{B}} + \\frac{130}{(1+r_{B})^{2}} = 0\n$$\n投资组合的IRR，$r_{P}$，由投资组合NPV方程的根定义：\n$$\n\\text{NPV}_{P}(r_{P}) = \\sum_{t=0}^{2} \\frac{C^{P}_{t}}{(1+r_{P})^{t}} = \\sum_{t=0}^{2} \\frac{C^{A}_{t} + C^{B}_{t}}{(1+r_{P})^{t}} = 0\n$$\n根据求和的可加性，这可以表示为：\n$$\n\\sum_{t=0}^{2} \\frac{C^{A}_{t}}{(1+r_{P})^{t}} + \\sum_{t=0}^{2} \\frac{C^{B}_{t}}{(1+r_{P})^{t}} = 0\n$$\n这等价于陈述 $\\text{NPV}_{A}(r_{P}) + \\text{NPV}_{B}(r_{P}) = 0$。\n\n各单个项目IRR的加权平均值，其权重 $w_{A}$ 和 $w_{B}$ 与初始投资额 $|C^{A}_{0}|=100$ 和 $|C^{B}_{0}|=100$ 成正比，将是 $r_{\\text{avg}} = w_{A}r_{A} + w_{B}r_{B}$。由于初始投资额相等，权重为 $w_A=w_B=0.5$，平均值为 $r_{\\text{avg}} = \\frac{r_{A}+r_{B}}{2}$。\n\n断言 $r_{P} = r_{\\text{avg}}$ 是不正确的。根本原因在于NPV函数相对于贴现率 $r$ 的非线性。IRR是方程 $\\text{NPV}(r)=0$ 的一个根。两个非线性函数之和的根，即 $\\text{NPV}_{A}(r) + \\text{NPV}_{B}(r) = 0$ 的根，通常不是各单个函数根（即 $\\text{NPV}_{A}(r_{A})=0$ 和 $\\text{NPV}_{B}(r_{B})=0$）的简单平均值。\n\n准确地说，NPV与 $r$ 之间的关系涉及 $(1+r)^{-t}$ 形式的项，这些是关于 $r$ 的非线性函数。要使根具有加权平均这样的性质，函数需要是关于变量的线性函数。例如，如果 $\\text{NPV}(r)$ 是 $r$ 的线性函数，比如 $\\text{NPV}_{i}(r) = k_{i}(r_{i}-r)$，那么 $\\text{NPV}_{P}(r) = k_{A}(r_{A}-r) + k_{B}(r_{B}-r)$。将其设为零将得到 $r_{P} = \\frac{k_{A}}{k_{A}+k_{B}}r_{A} + \\frac{k_{B}}{k_{A}+k_{B}}r_{B}$，这是一个加权平均值。然而，NPV函数显然不是 $r$ 的线性函数。\n\n因此，方程 $\\text{NPV}_{A}(r_{P}) + \\text{NPV}_{B}(r_{P}) = 0$ 必须直接求解 $r_{P}$，其解不能假定为 $r_{A}$ 和 $r_{B}$ 的线性组合。对于非线性函数，求根运算与加法运算不满足这种交换律。这构成了对投资组合IRR是其组成部分IRR的简单加权平均这一观点的正式反驳。\n\n计算得出的投资组合IRR为 $r_{P} \\approx 0.136154$。为完整起见，各单个项目的IRR分别为 $r_{A} = \\frac{6}{\\sqrt{69}-3}-1 \\approx 0.1307$ 和 $r_{B} = \\sqrt{1.3}-1 \\approx 0.1402$。加权平均值为 $r_{\\text{avg}} \\approx \\frac{0.1307+0.1402}{2} \\approx 0.1355$。正如形式论证和显式计算所证明的，$r_{P} \\neq r_{\\text{avg}}$。\n最终答案是投资组合的IRR，四舍五入到四位有效数字。\n$r_{P} \\approx 0.1362$。", "answer": "$$\n\\boxed{0.1362}\n$$", "id": "2403026"}, {"introduction": "从手动计算到计算思维的转变是现代金融的一项关键技能。这个问题要求你编写一个程序，用以求解为达到目标IRR所需的未知现金流[@problem_id:2403004]。这项任务将净现值（NPV）定义的代数结构直接转化为算法，为构建更复杂的金融模型提供了实践基础。", "problem": "您需要实现一个完整、可运行的程序，该程序计算单个缺失的现金流，以达到一个指定的目标内部收益率（IRR）。内部收益率（IRR）定义为使一系列现金流的净现值（NPV）等于零的唯一贴现率 $r$。对于发生在整数时间点 $t \\in \\{0,1,\\dots,T\\}$ 的现金流 $\\{C_t\\}_{t=0}^{T}$，其在贴现率为 $r$ 时的净现值（NPV）定义如下\n$$\n\\mathrm{NPV}(r; C_0,\\dots,C_T) \\equiv \\sum_{t=0}^{T} \\frac{C_t}{(1+r)^t}.\n$$\n您的任务是使用此定义推导出一个算法，在给定目标贴现率 $r^\\ast$ 和现金流序列 $\\{C_t\\}_{t=0}^{T}$ 中单个未知现金流 $C_k$ 的情况下，计算出使 $\\mathrm{NPV}(r^\\ast; C_0,\\dots,C_T) = 0$ 成立的 $C_k$ 的唯一值。\n\n要求与假设：\n- 时间 $t$ 为整数，满足 $t \\in \\{0,1,\\dots,T\\}$ 且 $T$ 为有限值。\n- 恰好有一个现金流是未知的；其索引记为 $k$，其中 $k \\in \\{0,1,\\dots,T\\}$。\n- 目标贴现率 $r^\\ast$ 必须满足 $r^\\ast > -1$，从而确保 $(1+r^\\ast) > 0$。\n- 所有现金流均为实数。正值代表现金流入，负值代表现金流出。\n- 百分比必须作为小数处理（例如，10%的利率必须作为 $0.10$ 输入和处理）。\n\n编程任务：\n- 编写一个函数，该函数接收 $r^\\ast$和一个包含恰好一个缺失值 $C_k$ 的现金流列表，计算满足 $\\mathrm{NPV}(r^\\ast; C_0,\\dots,C_T)=0$ 所需的 $C_k$ 值，并返回 $C_k$。\n- 应从缺失条目在列表中的位置推断出索引 $k$。\n- 对于数值输出，将计算出的 $C_k$ 四舍五入到 $6$ 位小数。\n\n测试套件：\n请严格按照此顺序使用以下五个测试用例。在每个用例中，列表都包含一个由特殊占位符表示的缺失条目。为具体起见，请使用编程语言中表示缺失值的哨兵值。您必须计算并输出相应的 $C_k$ 值。测试定义中的所有数字均应解释为实数值：\n\n1. 目标利率 $r^\\ast = 0.10$，现金流 $[\\,\\text{缺失},\\, 50.0,\\, 60.0,\\, 70.0\\,]$，其中 $t \\in \\{0,1,2,3\\}$。\n2. 目标利率 $r^\\ast = -0.20$，现金流 $[\\,-100.0,\\, \\text{缺失},\\, 150.0\\,]$，其中 $t \\in \\{0,1,2\\}$。\n3. 目标利率 $r^\\ast = -0.90$，现金流 $[\\,-100.0,\\, \\text{缺失}\\,]$，其中 $t \\in \\{0,1\\}$。\n4. 目标利率 $r^\\ast = 0.05$，现金流 $[\\,-100.0,\\, 0.0,\\, 0.0,\\, 0.0,\\, \\text{缺失}\\,]$，其中 $t \\in \\{0,1,2,3,4\\}$。\n5. 目标利率 $r^\\ast = 0.12$，现金流 $[\\,-200.0,\\, 80.0,\\, \\text{缺失},\\, 50.0\\,]$，其中 $t \\in \\{0,1,2,3\\}$。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含五个结果，形式为方括号内的逗号分隔列表，每个数字四舍五入到 $6$ 位小数，且没有多余的空格。例如，格式必须与\n`[x1,x2,x3,x4,x5]`\n完全一致，其中每个 $x_i$ 是一个打印为 $6$ 位小数的实数。\n\n不需要也不允许用户输入；程序必须按原样运行，并仅打印上述测试套件的结果。", "solution": "所述问题需进行验证。\n\n### 第一步：提取已知条件\n\n逐字从问题陈述中提取已知条件：\n- **净现值（NPV）的定义**：对于在整数时间点 $t \\in \\{0, 1, \\dots, T\\}$ 发生的一系列现金流 $\\{C_t\\}_{t=0}^{T}$，其在贴现率为 $r$ 时的净现值（NPV）为\n$$\n\\mathrm{NPV}(r; C_0,\\dots,C_T) \\equiv \\sum_{t=0}^{T} \\frac{C_t}{(1+r)^t}.\n$$\n- **任务**：在给定目标贴现率 $r^\\ast$ 的情况下，计算单个缺失的现金流 $C_k$，以满足条件 $\\mathrm{NPV}(r^\\ast; C_0,\\dots,C_T) = 0$。\n- **约束与假设**：\n    - 时间 $t$ 是整数：$t \\in \\{0, 1, \\dots, T\\}$。\n    - 恰好有一个现金流 $C_k$ 是未知的，其中 $k \\in \\{0, 1, \\dots, T\\}$。\n    - 目标贴现率 $r^\\ast$ 满足 $r^\\ast > -1$。\n    - 所有现金流 $C_t$ 均为实数。\n    - 百分比必须作为小数处理。\n- **编程要求**：\n    - 缺失现金流的索引 $k$ 将从其在输入列表中的位置推断出来。\n    - 计算出的 $C_k$ 值必须四舍五入到 $6$ 位小数。\n- **测试套件**：\n    1. $r^\\ast = 0.10$，现金流：$[\\,\\text{缺失},\\, 50.0,\\, 60.0,\\, 70.0\\,]$，$t \\in \\{0,1,2,3\\}$。\n    2. $r^\\ast = -0.20$，现金流：$[\\,-100.0,\\, \\text{缺失},\\, 150.0\\,]$，$t \\in \\{0,1,2\\}$。\n    3. $r^\\ast = -0.90$，现金流：$[\\,-100.0,\\, \\text{缺失}\\,]$，$t \\in \\{0,1\\}$。\n    4. $r^\\ast = 0.05$，现金流：$[\\,-100.0,\\, 0.0,\\, 0.0,\\, 0.0,\\, \\text{缺失}\\,]$，$t \\in \\{0,1,2,3,4\\}$。\n    5. $r^\\ast = 0.12$，现金流：$[\\,-200.0,\\, 80.0,\\, \\text{缺失},\\, 50.0\\,]$，$t \\in \\{0,1,2,3\\}$。\n\n### 第二步：使用提取的已知条件进行验证\n\n根据既定标准对问题进行评估。\n- **具有科学依据**：该问题基于金融学和经济学中使用的净现值的标准、基本定义。该概念在数学上是合理的，并被广泛接受。约束条件 $r^\\ast > -1$ 确保了贴现因子 $(1+r^\\ast)$ 为正，这是行为良好的金融模型的标准要求。\n- **适定的**：该问题要求在一个相对于 $C_k$ 是线性的方程中求解单个未知数 $C_k$。一个单变量线性方程有唯一解。因此，该问题是适定的。\n- **客观的**：该问题以精确的数学语言陈述，没有歧义、主观性或个人观点。\n- **完整性和一致性**：该问题提供了所有必要信息：控制方程、约束条件和用于测试的具体输入数据。所提供的信息是内部一致的。\n\n### 第三步：结论与行动\n\n问题陈述是**有效的**。它在科学上合理、适定且完整。我将继续推导解决方案。\n\n目标是在给定目标贴现率 $r^\\ast$ 的情况下，找出在时间点 $k$ 的未知现金流 $C_k$ 的值，使得整个现金流系列 $\\{C_t\\}_{t=0}^{T}$ 的净现值为零。\n\n定义方程为：\n$$\n\\mathrm{NPV}(r^\\ast; C_0, \\dots, C_T) = \\sum_{t=0}^{T} \\frac{C_t}{(1+r^\\ast)^t} = 0\n$$\n这个求和式可以展开，将包含未知现金流 $C_k$ 的项与包含已知现金流的项分开。设 $S$ 为现金流已知的那些时间索引的集合。所有时间索引的集合是 $\\{0, 1, \\dots, T\\}$。未知现金流在索引 $k$ 处，因此 $S = \\{0, 1, \\dots, T\\} \\setminus \\{k\\}$。该方程可以重写为：\n$$\n\\frac{C_k}{(1+r^\\ast)^k} + \\sum_{t \\in S} \\frac{C_t}{(1+r^\\ast)^t} = 0\n$$\n由于该方程对于未知数 $C_k$ 是线性的，我们可以直接求解它。首先，我们分离出包含 $C_k$ 的项：\n$$\n\\frac{C_k}{(1+r^\\ast)^k} = - \\sum_{t \\in S} \\frac{C_t}{(1+r^\\ast)^t}\n$$\n右侧的求和项代表了所有*已知*现金流的净现值，按利率 $r^\\ast$ 计算。让我们将这个和表示为 $\\mathrm{NPV}_{\\text{known}}$。\n$$\n\\mathrm{NPV}_{\\text{known}} = \\sum_{t=0, t \\neq k}^{T} \\frac{C_t}{(1+r^\\ast)^t}\n$$\n将其代回，我们得到：\n$$\n\\frac{C_k}{(1+r^\\ast)^k} = - \\mathrm{NPV}_{\\text{known}}\n$$\n为了求出 $C_k$，我们在等式两边同乘以因子 $(1+r^\\ast)^k$。条件 $r^\\ast > -1$ 确保了 $(1+r^\\ast) \\neq 0$，因此这个操作总是有效的。\n$$\nC_k = - \\mathrm{NPV}_{\\text{known}} \\cdot (1+r^\\ast)^k\n$$\n这为未知现金流 $C_k$ 提供了一个直接的解析公式。实现该公式的算法如下：\n1.  接收目标利率 $r^\\ast$ 和现金流列表，该列表在索引 $k$ 处包含一个表示未知值的特殊标记。\n2.  确定与缺失现金流对应的索引 $k$。\n3.  计算所有*已知*现金流的现值之和。这通过从 $t=0$ 迭代到 $t=T$ 来实现，跳过索引 $k$，对于每个已知的现金流 $C_t$，计算 $\\frac{C_t}{(1+r^\\ast)^t}$ 并将其累加到一个总和中。\n4.  将此总和乘以 $-1$ 然后再乘以 $(1+r^\\ast)^k$ 以获得 $C_k$ 的最终值。\n5.  将结果四舍五入到指定的 $6$ 位小数精度。\n\n此过程在计算上简单直接，并保证对任何有效的输入集都能产生唯一的正确答案。代码实现将遵循此逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes a single missing cash flow to achieve a specified Internal Rate of Return (IRR).\n    The program is self-contained and processes a fixed set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # The missing value is represented by the Python sentinel `None`.\n    test_cases = [\n        {'r_star': 0.10, 'cash_flows': [None, 50.0, 60.0, 70.0]},\n        {'r_star': -0.20, 'cash_flows': [-100.0, None, 150.0]},\n        {'r_star': -0.90, 'cash_flows': [-100.0, None]},\n        {'r_star': 0.05, 'cash_flows': [-100.0, 0.0, 0.0, 0.0, None]},\n        {'r_star': 0.12, 'cash_flows': [-200.0, 80.0, None, 50.0]},\n    ]\n\n    def compute_missing_cashflow(r_star: float, cash_flows: list) -> float:\n        \"\"\"\n        Calculates the value of a single missing cash flow C_k that makes the NPV of the\n        cash flow series equal to zero for a given target rate r_star.\n\n        Args:\n            r_star: The target discount rate (as a decimal).\n            cash_flows: A list of cash flows, with exactly one entry being None.\n\n        Returns:\n            The value of the missing cash flow C_k, rounded to 6 decimal places.\n        \"\"\"\n        if not (r_star > -1):\n            raise ValueError(\"Target rate r_star must be greater than -1.\")\n        \n        try:\n            k = cash_flows.index(None)\n        except ValueError:\n            raise ValueError(\"The cash_flows list must contain exactly one 'None' placeholder.\")\n            \n        npv_of_known_flows = 0.0\n        # The sum is taken over all known cash flows\n        # The equation to solve is: C_k/(1+r*)^k + sum_{t!=k} C_t/(1+r*)^t = 0\n        for t, cf in enumerate(cash_flows):\n            if cf is not None:\n                npv_of_known_flows += cf / ((1 + r_star)**t)\n        \n        # From the equation, C_k = - (sum_{t!=k} C_t/(1+r*)^t) * (1+r*)^k\n        c_k = -npv_of_known_flows * ((1 + r_star)**k)\n        \n        return round(c_k, 6)\n\n    results = []\n    for case in test_cases:\n        r_star = case['r_star']\n        flows = case['cash_flows']\n        missing_flow = compute_missing_cashflow(r_star, flows)\n        results.append(f\"{missing_flow:.6f}\") # Format to ensure 6 decimal places\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2403004"}]}