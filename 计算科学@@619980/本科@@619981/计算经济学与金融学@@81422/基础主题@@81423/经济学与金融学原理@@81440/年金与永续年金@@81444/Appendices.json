{"hands_on_practices": [{"introduction": "永续年金的概念不仅是金融领域的抽象工具，其核心数学原理——无穷等比级数的求和——也广泛应用于众多科学和工程领域。本练习旨在挑战您将此原应用于一个非金融情景：模拟一个太阳能发电场在其整个生命周期内的总能量输出，其发电量会以一个恒定的年衰减率下降。通过将一个物理上的衰减过程构建为负增长率的永续年金模型[@problem_id:2371754]，您将对这一基本估值工具建立起更深刻、更直观的理解。", "problem": "一个公用事业规模的太阳能光伏电站的铭牌容量为 $100$ 兆瓦。其容量因子为 $0.25$，一个非闰年有 $8760$ 小时。光伏组件每年经历 $0.5$％ 的恒定比例衰减，并且这种衰减使得每年产生的能量相对于前一年发生乘法性减少。假设该设施在这些条件下无限期运行，没有容量增加、退役、维护冲击或外部限制。\n\n使用永续年金模型（其中年度能量输出流在所述衰减过程下无限持续），确定未来所有年份累计生产的总能量。以兆瓦时 (MWh) 为单位表示您的答案，并将结果四舍五入到四位有效数字。", "solution": "首先必须验证问题陈述的科学合理性、适定性和客观性。\n\n**步骤 1：提取已知条件**\n- 铭牌容量: $100$ 兆瓦\n- 容量因子: $0.25$\n- 非闰年小时数: $8760$\n- 比例衰减率: 每年 $0.5$％\n- 衰减效应: 随后每年产出的能量相对于前一年发生乘性减少。\n- 运行时间: 无限期。\n- 模型类型: 永续年金模型。\n- 要求输出: 以兆瓦时 (MWh) 为单位的总累计能量，四舍五入到四位有效数字。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据。铭牌容量、容量因子和年衰减率等概念是电力系统工程和可再生能源金融领域的标准指标。给定的数值是现实的；$0.25$ 的容量因子对于许多地区的太阳能光伏是典型的，而 $0.5\\%$ 的年衰减率是现代晶体硅组件的标准假设。该问题是适定的，它描述了一个公比的绝对值小于一的无穷等比级数，这保证了级数收敛到一个唯一的有限和。语言客观而精确。使用永续模型是一种理想化处理，但它被明确说明为一种建模假设，并且是近似长期累积效应的有效数学技术。因此，该问题被认定为有效。\n\n**步骤 3：结论与行动**\n问题有效。现在将推导完整的解法。\n\n该问题要求计算一个经历恒定比例衰减的太阳能设施在无限时间范围内产生的总能量。这等同于求一个无穷等比级数的和。\n\n首先，让我们确定第一年运行产生的能量，我们将其表示为 $E_1$。能量输出是平均功率与运行时间的乘积。平均功率是铭牌容量乘以容量因子。\n\n设 $C$ 为铭牌容量，$f$ 为容量因子，$T$ 为一年的小时数。\n第一年产生的能量由下式给出：\n$$E_1 = C \\times f \\times T$$\n代入给定值：\n$$C = 100 \\text{ MW}$$\n$$f = 0.25$$\n$$T = 8760 \\text{ h}$$\n因此，\n$$E_1 = 100 \\text{ MW} \\times 0.25 \\times 8760 \\text{ h} = 25 \\text{ MW} \\times 8760 \\text{ h} = 219000 \\text{ MWh}$$\n\n问题陈述，能量输出每年经历 $d = 0.5\\%$ 的恒定比例衰减。这意味着任何给定年份产生的能量是前一年产生能量的一个恒定比例。设这个恒定的乘法因子为 $r$。\n$$d = 0.5\\% = 0.005$$\n因子 $r$ 为：\n$$r = 1 - d = 1 - 0.005 = 0.995$$\n\n年度能量生产流构成一个等比数列：\n- 第 1 年: $E_1 = 219000 \\text{ MWh}$\n- 第 2 年: $E_2 = E_1 \\times r$\n- 第 3 年: $E_3 = E_2 \\times r = E_1 \\times r^2$\n- 第 $n$ 年: $E_n = E_1 \\times r^{n-1}$\n\n未来所有年份累计生产的总能量 $E_{\\text{total}}$ 是这个无穷等比级数的和：\n$$E_{\\text{total}} = \\sum_{n=1}^{\\infty} E_n = \\sum_{n=1}^{\\infty} E_1 \\times r^{n-1}$$\n无穷等比级数的求和公式为：\n$$S = \\frac{a}{1-r}$$\n其中 $a$ 是首项，$r$ 是公比。该公式仅在 $|r| < 1$ 时有效。在本问题中，首项是 $a = E_1$，公比是 $r = 0.995$。由于 $|0.995| < 1$，级数收敛，我们可以应用该公式。\n\n$$E_{\\text{total}} = \\frac{E_1}{1-r}$$\n代入 $E_1$ 和 $r$ 的值：\n$$E_{\\text{total}} = \\frac{219000}{1 - 0.995} = \\frac{219000}{0.005}$$\n这等价于：\n$$E_{\\text{total}} = 219000 \\times \\frac{1}{0.005} = 219000 \\times 200$$\n$$E_{\\text{total}} = 43800000 \\text{ MWh}$$\n\n问题要求答案四舍五入到四位有效数字。计算出的值为 $43,800,000$。前四位有效数字是 $4$、$3$、$8$ 和 $0$。为了用包含四位有效数字的标准科学记数法表示，我们写作：\n$$E_{\\text{total}} = 4.380 \\times 10^7$$\n这是该设施在指定的衰减模型下，其无限运营寿命内产生的总累计能量。", "answer": "$$\\boxed{4.380 \\times 10^7}$$", "id": "2371754"}, {"introduction": "虽然标准的年金公式非常强大，但许多现实世界中的金融产品具有复杂且非标准的现金流结构。本练习将引导您超越现成的公式，进入计算金融的实践领域，要求您为一个具有条件支付的结构性产品计算其内部收益率（Internal Rate of Return, IRR）。通过从第一性原理出发，实施一个数值求解器来寻找使项目净现值为零的收益率[@problem_id:2371722]，您将在评估那些不存在简单解析解的独特金融工具方面获得宝贵的动手经验。", "problem": "你的任务是实现一个完整的程序，用于计算一个结构性产品的内部收益率（IRR）。该产品根据一个国家通货膨胀率的已实现路径来支付有条件的票息。程序必须仅依赖以下基本概念：通过固定利率进行现值贴现的货币时间价值，以及将现金流的现值等同于零的利率定义为内部收益率。不得假定任何其他快捷方式或预设的公式。\n\n单个产品实例由输入元组 $\\left(P, C, L, U, T, g, \\{i_t\\}_{t=1}^{T}\\right)$ 定义，其中 $P$ 是在时间 $t=0$ 投资的初始本金， $C$ 是固定的年度票息金额， $L$ 和 $U$ 是通胀区间的下限和上限， $T$ 是以年为单位的到期期限， $g$ 是到期本金保证比例， $\\{i_t\\}$ 是已实现的年度通胀率序列，表示为小数（而非百分比）。该结构性产品的现金流如下：\n- 在时间 $t=0$，投资者支付初始流出 $-P$。\n- 对于每个年度 $t \\in \\{1,2,\\dots,T\\}$，当且仅当通胀率 $i_t$ 满足 $L \\le i_t \\le U$ 时，才会支付一笔金额为 $C$ 的票息；否则，该年度的票息为 0。\n- 在到期日 $t=T$，除了按上述方式确定的任何票息外，无论通胀路径如何，投资者都会收到一笔等于 $gP$ 的到期保证还款。\n\n对于每个输入元组，将内部收益率（IRR），表示为 $r$，定义为贴现率（表示为小数），使得将所有现金流以利率 $r$ 贴现至时间 $t=0$ 并求和的结果为零。你的程序必须为每个指定的测试案例计算这个 $r$。所有利率（通胀率、IRR）都必须表示为小数（例如，使用 $0.03$ 而非 $3\\%$）。不涉及任何物理单位。\n\n测试套件：\n为以下五个案例中的每一个计算 IRR $r$。在每个案例中，区间包含边界值，因此等于 $L$ 或 $U$ 的通胀率 $i_t$ 也有资格获得当年的票息。所有标量输入都是实数，所有通胀序列都是实值列表。\n\n- 案例 1（混合了区间内和区间外的年份）：\n  - $P = 1000$, $C = 50$, $L = 0.02$, $U = 0.035$, $T = 5$, $g = 1.0$, $\\{i_t\\}_{t=1}^{5} = [0.03, 0.01, 0.025, 0.04, 0.033]$。\n- 案例 2（边界值包含在内，导致每年都触发票息）：\n  - $P = 1000$, $C = 40$, $L = 0.02$, $U = 0.035$, $T = 5$, $g = 1.0$, $\\{i_t\\}_{t=1}^{5} = [0.02, 0.035, 0.035, 0.02, 0.025]$。\n- 案例 3（从未支付票息，到期返还全部本金）：\n  - $P = 1000$, $C = 60$, $L = 0.02$, $U = 0.035$, $T = 5$, $g = 1.0$, $\\{i_t\\}_{t=1}^{5} = [0.05, 0.05, 0.05, 0.05, 0.05]$。\n- 案例 4（从未支付票息，到期返还部分本金）：\n  - $P = 1000$, $C = 50$, $L = 0.02$, $U = 0.035$, $T = 5$, $g = 0.9$, $\\{i_t\\}_{t=1}^{5} = [0.05, 0.05, 0.05, 0.05, 0.05]$。\n- 案例 5（一年期产品，支付票息，返还全部本金）：\n  - $P = 1000$, $C = 100$, $L = 0.02$, $U = 0.035$, $T = 1$, $g = 1.0$, $\\{i_t\\}_{t=1}^{1} = [0.025]$。\n\n程序要求：\n- 对于每个案例，根据上述定义构建现金流序列，使用给定的通胀路径和界限来确定哪些票息会被支付。\n- 按上述定义计算 IRR $r$。解必须通过数值计算得出；不应假设通常情况下存在精确的代数简化方法。\n- 数值输出规范：对于每个案例，将 IRR 作为浮点数输出，并四舍五入到 $8$ 位小数。将所有五个案例的结果汇总到一行，以逗号分隔的列表形式，并用方括号括起来，例如 $[r_1, r_2, r_3, r_4, r_5]$，其中每个 $r_k$ 都四舍五入到 $8$ 位小数。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[0.01234567,0.00000000,-0.01234567,0.03456789,0.10000000]$）。不允许有任何其他输出。", "solution": "所呈现的问题是计算金融领域一个定义明确的练习。它要求计算一个结构化金融产品的内部收益率（IRR），该产品的现金流取决于一个外部经济变量——通货膨胀率。所有参数和条件都以足够的清晰度和精确度指定，从而可以得到唯一且可验证的解。该问题在科学上基于货币时间价值的基本原理。\n\n验证步骤如下：\n1.  **已知条件提取**：所有输入参数 $(P, C, L, U, T, g, \\{i_t\\}_{t=1}^{T})$、现金流规则、IRR的定义以及测试数据都已明确陈述且自成一体。\n2.  **验证**：该问题在科学上是合理的，依赖于已确立的贴现现金流分析这一金融概念。该问题是良构的，因为所描述的现金流（单一初始流出后跟一系列非负流入）通常会产生唯一的实值IRR。问题陈述是客观且没有歧义的。它可以形式化为一个精确的数学方程，并且与计算金融中的年金和永续年金主题直接相关。\n3.  **结论**：问题有效。将构建一个解决方案。\n\n问题的核心是找到我们表示为 $r$ 的内部收益率。根据定义，$r$ 是使结构性产品所有现金流的净现值（NPV）等于零的特定贴现率。\n\n首先，我们必须根据提供的参数构建现金流序列 $\\{CF_t\\}_{t=0}^{T}$。\n设 $P$ 为初始本金， $C$ 为年度票息， $L$ 和 $U$ 为通胀区间的下限和上限， $T$ 为以年为单位的到期期限， $g$ 为到期本金保证比例， $\\{i_t\\}_{t=1}^{T}$ 为已实现的年度通胀率序列。\n\n现金流确定如下：\n- 在时间 $t=0$，存在一笔初始投资，即流出 $P$。因此，$CF_0 = -P$。\n- 对于其后的每一年 $t$，其中 $t \\in \\{1, 2, \\dots, T\\}$，我们必须确定是否支付票息。设 $c_t$ 为时间 $t$ 的票息支付。支付的条件是该年的通胀率 $i_t$ 落在指定的区间内，包括其边界。\n$$\nc_t =\n\\begin{cases}\nC & \\text{if } L \\le i_t \\le U \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\n- 对于每一年 $t \\in \\{1, 2, \\dots, T-1\\}$ 的现金流就是该年的票息支付：$CF_t = c_t$。\n- 在到期年 $t=T$，现金流包括该年的票息 $c_T$ 和到期保证本金还款 $gP$。\n$$\nCF_T = c_T + gP\n$$\n\n在建立完整的现金流序列 $\\{CF_t\\}_{t=0}^{T}$ 后，我们可以将净现值定义为贴现率 $r$ 的函数：\n$$\n\\text{NPV}(r) = \\sum_{t=0}^{T} \\frac{CF_t}{(1+r)^t}\n$$\n根据定义，IRR 是解方程 $\\text{NPV}(r) = 0$ 的利率 $r$：\n$$\n\\sum_{t=0}^{T} \\frac{CF_t}{(1+r)^t} = 0\n$$\n代入 $CF_0 = -P$，我们可以将其重写为：\n$$\n-P + \\sum_{t=1}^{T} \\frac{CF_t}{(1+r)^t} = 0 \\quad \\implies \\quad P = \\sum_{t=1}^{T} \\frac{CF_t}{(1+r)^t}\n$$\n这个方程是一个关于变量 $v = (1+r)^{-1}$ 的 $T$ 次多项式。对于 $T > 4$ 的情况，不存在通用的根的代数解。因此，我们必须采用数值求根算法来求解 $r$。\n\n解决此问题的步骤如下：\n1.  对于由元组 $(P, C, L, U, T, g, \\{i_t\\}_{t=1}^{T})$ 定义的每个测试案例：\n    a. 根据上述规则构建现金流向量 $CF = [CF_0, CF_1, \\dots, CF_T]$。\n    b. 定义目标函数 $f(r) = \\text{NPV}(r)$，我们需要求解 $f(r)=0$。\n    c. 利用数值求解器找到 $f(r)$ 的根。`scipy.optimize.newton` 函数实现了割线法（牛顿法的一种变体），是完成此任务的一个合适且稳健的选择。提供一个初始猜测值，例如 $r_0 = 0.1$，以启动迭代过程。\n2.  然后将每个案例计算出的 $r$ 值按要求四舍五入到 $8$ 位小数。\n3.  将最终结果汇总成一个单一的格式化字符串。\n\n此方法仅依赖于 IRR 的基本定义和一个通用的数值求解器，遵守了问题陈述的所有约束。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import newton\n\ndef solve():\n    \"\"\"\n    Computes the Internal Rate of Return (IRR) for a structured product\n    across several test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (mixed in-band and out-of-band years)\n        {'P': 1000, 'C': 50, 'L': 0.02, 'U': 0.035, 'T': 5, 'g': 1.0, 'i_t': [0.03, 0.01, 0.025, 0.04, 0.033]},\n        # Case 2 (boundary inclusions trigger coupons every year)\n        {'P': 1000, 'C': 40, 'L': 0.02, 'U': 0.035, 'T': 5, 'g': 1.0, 'i_t': [0.02, 0.035, 0.035, 0.02, 0.025]},\n        # Case 3 (no coupons ever, full principal returned at maturity)\n        {'P': 1000, 'C': 60, 'L': 0.02, 'U': 0.035, 'T': 5, 'g': 1.0, 'i_t': [0.05, 0.05, 0.05, 0.05, 0.05]},\n        # Case 4 (no coupons ever, partial principal returned at maturity)\n        {'P': 1000, 'C': 50, 'L': 0.02, 'U': 0.035, 'T': 5, 'g': 0.9, 'i_t': [0.05, 0.05, 0.05, 0.05, 0.05]},\n        # Case 5 (one-year product, coupon paid, full principal returned)\n        {'P': 1000, 'C': 100, 'L': 0.02, 'U': 0.035, 'T': 1, 'g': 1.0, 'i_t': [0.025]},\n    ]\n\n    def npv_function(r, cash_flows):\n        \"\"\"\n        Calculates the Net Present Value for a given discount rate r and\n        a sequence of cash flows.\n        \"\"\"\n        times = np.arange(len(cash_flows))\n        return np.sum(cash_flows / ((1 + r)**times))\n\n    def compute_irr_for_case(params):\n        \"\"\"\n        Calculates the IRR for a single structured product instance.\n        \"\"\"\n        P, C, L, U, T, g, inflation_rates = \\\n            params['P'], params['C'], params['L'], params['U'], \\\n            params['T'], params['g'], params['i_t']\n\n        # Construct the cash flow sequence\n        cash_flows = np.zeros(T + 1)\n        cash_flows[0] = -P\n\n        for t in range(1, T + 1):\n            # Inflation rates list is 0-indexed, time t is 1-indexed\n            inflation_t = inflation_rates[t - 1]\n            coupon = 0\n            if L <= inflation_t <= U:\n                coupon = C\n            cash_flows[t] = coupon\n        \n        # Add the terminal principal guarantee at maturity\n        cash_flows[T] += g * P\n        \n        # Use a numerical solver (secant method) to find the root of the NPV function\n        # An initial guess of 0.1 (10%) is provided.\n        try:\n            irr = newton(npv_function, x0=0.1, args=(cash_flows,))\n        except RuntimeError:\n            # In cases where the function is very flat (like IRR=0),\n            # a different starting guess might be needed.\n            try:\n                irr = newton(npv_function, x0=0.0, args=(cash_flows,))\n            except RuntimeError:\n                 # Should not happen for these well-behaved cases\n                 irr = np.nan\n\n        return irr\n\n    results = []\n    for case in test_cases:\n        result = compute_irr_for_case(case)\n        results.append(result)\n\n    # Format each result to 8 decimal places and join into the final string\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2371722"}, {"introduction": "我们的最终练习是通往现代量化金融的一座桥梁，它引入了一种现金流受到随机不确定性影响的永续年金。您将为一个资产进行估值，其净支付受到一个遵循均值回归过程的税率影响——这是利率和其他经济变量的常用模型。本练习展示了一种强大的技术：通过求解期望，一个复杂的连续时间随机问题可以被简化为一个具有优美解析解的确定性问题[@problem_id:2371735]，这揭示了随机微积分与资产定价理论之间的深刻联系。", "problem": "考虑一笔连续时间永续年金，其以每年 $C$ 货币单位的恒定瞬时率支付。在时间 $t \\ge 0$ 的税后现金流等于 $C \\cdot (1 - \\tau_t)$，其中税率 $\\tau_t$ 是一个随机过程，遵循以下均值回归随机微分方程演化\n$$\nd\\tau_t = \\kappa \\left(\\bar{\\tau} - \\tau_t \\right) dt + \\sigma \\, dW_t,\n$$\n初始条件为 $\\tau_0$，均值回归速度 $\\kappa > 0$，长期均值 $\\bar{\\tau}$ 满足 $0 \\le \\bar{\\tau} \\le 1$，波动率参数 $\\sigma \\ge 0$，且 $(W_t)_{t \\ge 0}$ 为标准维纳过程。连续复利贴现率是常数，等于 $r > 0$ (单位：年$^{-1}$)。所有比率（$r$、$\\kappa$、$\\bar{\\tau}$、$\\tau_0$）必须以小数形式处理，而不是百分号。假设估值是通过计算折现净现金流的期望来进行的，并且所有必要的可积性条件均成立。\n\n定义现值 $V$ 为\n$$\nV \\equiv \\mathbb{E}\\left[ \\int_{0}^{\\infty} e^{- r t} \\, C \\, (1 - \\tau_t) \\, dt \\right],\n$$\n以与 $C$ 相同的货币单位表示。\n\n您的任务是编写一个完整、可运行的程序，为下面的测试套件中的每组参数计算 $V$。每个结果必须报告为四舍五入到 $12$ 位小数的浮点数。最终输出必须是单行，包含一个由逗号分隔的结果列表，并用方括号括起来。\n\n使用以下测试套件（每个项目符号为一个测试用例，指定了 $(C, r, \\kappa, \\bar{\\tau}, \\tau_0, \\sigma)$）：\n\n- $(100.0, 0.05, 0.3, 0.3, 0.2, 0.1)$\n- $(100.0, 0.05, 0.3, 0.3, 0.3, 0.4)$\n- $(100.0, 0.05, 0.0001, 0.3, 0.8, 0.2)$\n- $(100.0, 0.05, 10.0, 0.6, 0.2, 0.3)$\n- $(100.0, 0.05, 0.2, 1.0, 0.7, 0.0)$\n- $(100.0, 0.1, 0.4, 0.0, 0.5, 0.5)$\n\n最终输出格式规范：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔结果列表（例如，“[x_1,x_2,x_3,x_4,x_5,x_6]”），其中每个 $x_i$ 是对应的四舍五入到 $12$ 位小数的现值。不应打印额外的文本或空格。", "solution": "问题陈述已经过验证，并被认定为有效。这是一个量化金融领域的适定问题，基于成熟的随机过程和资产定价理论。所有参数均已提供，不存在内部矛盾或科学谬误。任务是推导并计算一个解析解。\n\n永续年金的现值 $V$ 定义为所有未来折现税后现金流之和的期望值：\n$$\nV \\equiv \\mathbb{E}\\left[ \\int_{0}^{\\infty} e^{- r t} \\, C \\, (1 - \\tau_t) \\, dt \\right]\n$$\n其中 $C$ 是恒定现金流率，$r$ 是恒定贴现率，$\\tau_t$ 是随机税率。鉴于问题陈述所有必要的可积性条件均成立，我们可以应用Fubini定理来交换期望和积分算子。常数 $C$ 也可以被提取出来。\n$$\nV = C \\int_{0}^{\\infty} e^{- r t} \\, \\mathbb{E}\\left[ 1 - \\tau_t \\right] \\, dt\n$$\n根据期望的线性性质，这变为：\n$$\nV = C \\int_{0}^{\\infty} e^{- r t} \\, (1 - \\mathbb{E}[\\tau_t]) \\, dt\n$$\n因此，问题简化为确定在任意时间 $t \\ge 0$ 时税率过程的期望值 $\\mathbb{E}[\\tau_t]$。\n\n税率 $\\tau_t$ 遵循Ornstein-Uhlenbeck随机微分方程：\n$$\nd\\tau_t = \\kappa \\left(\\bar{\\tau} - \\tau_t \\right) dt + \\sigma \\, dW_t\n$$\n这是一个标准的线性SDE。对于遵循此SDE的过程，在给定时间 $t=0$ 时的值 $\\tau_0$ 的条件下，其期望的解是随机微积分中的一个众所周知的结果。期望 $\\mathbb{E}[\\tau_t]$ 根据常微分方程 $d\\mathbb{E}[\\tau_t]/dt = \\kappa(\\bar{\\tau} - \\mathbb{E}[\\tau_t])$ 进行确定性演化，因为随机项 $\\sigma dW_t$ 的期望为零。该ODE在初始条件 $\\mathbb{E}[\\tau_0] = \\tau_0$ 下的解为：\n$$\n\\mathbb{E}[\\tau_t] = \\tau_0 e^{-\\kappa t} + \\bar{\\tau} (1 - e^{-\\kappa t})\n$$\n此表达式显示了期望税率从 $\\tau_0$ 开始，并以由 $\\kappa$ 决定的速度向长期平均值 $\\bar{\\tau}$ 进行均值回归。值得注意的是，波动率参数 $\\sigma$ 不影响 $\\tau_t$ 的期望路径，这是维纳过程增量具有零均值特性的直接结果。\n\n将 $\\mathbb{E}[\\tau_t]$ 的这个表达式代入 $V$ 的积分中：\n$$\nV = C \\int_{0}^{\\infty} e^{- r t} \\left( 1 - \\left[ \\tau_0 e^{-\\kappa t} + \\bar{\\tau} (1 - e^{-\\kappa t}) \\right] \\right) dt\n$$\n重新整理积分内的项可得：\n$$\n1 - \\bar{\\tau} - \\tau_0 e^{-\\kappa t} + \\bar{\\tau} e^{-\\kappa t} = (1 - \\bar{\\tau}) + (\\bar{\\tau} - \\tau_0) e^{-\\kappa t}\n$$\n$V$ 的积分现在可以分成两部分：\n$$\nV = C \\left[ \\int_{0}^{\\infty} (1 - \\bar{\\tau}) e^{-r t} \\, dt + \\int_{0}^{\\infty} (\\bar{\\tau} - \\tau_0) e^{-\\kappa t} e^{-r t} \\, dt \\right]\n$$\n$$\nV = C \\left[ (1 - \\bar{\\tau}) \\int_{0}^{\\infty} e^{-r t} \\, dt + (\\bar{\\tau} - \\tau_0) \\int_{0}^{\\infty} e^{-(r + \\kappa) t} \\, dt \\right]\n$$\n这些是标准的反常积分。对于任何常数 $\\alpha > 0$，积分 $\\int_{0}^{\\infty} e^{-\\alpha t} dt = 1/\\alpha$。第一个积分收敛是因为 $r > 0$，第二个积分收敛是因为 $r > 0$ 且 $\\kappa > 0$，因此 $r + \\kappa > 0$。计算这些积分得到：\n$$\nV = C \\left[ (1 - \\bar{\\tau}) \\frac{1}{r} + (\\bar{\\tau} - \\tau_0) \\frac{1}{r + \\kappa} \\right]\n$$\n这是现值 $V$ 的最终解析公式。此公式将用于计算指定测试用例的值。每个测试用例的参数 $(C, r, \\kappa, \\bar{\\tau}, \\tau_0, \\sigma)$ 如下：\n- 案例 1: $(100.0, 0.05, 0.3, 0.3, 0.2, 0.1)$\n- 案例 2: $(100.0, 0.05, 0.3, 0.3, 0.3, 0.4)$\n- 案例 3: $(100.0, 0.05, 0.0001, 0.3, 0.8, 0.2)$\n- 案例 4: $(100.0, 0.05, 10.0, 0.6, 0.2, 0.3)$\n- 案例 5: $(100.0, 0.05, 0.2, 1.0, 0.7, 0.0)$\n- 案例 6: $(100.0, 0.1, 0.4, 0.0, 0.5, 0.5)$\n\n下面的程序将为每个案例计算 $V$，将结果四舍五入到 $12$ 位小数，并以指定的列表格式打印它们。", "answer": "```python\n# The problem is scientifically valid and well-posed. The solution is implemented below.\n\n# No extra imports are needed beyond the standard library.\n# numpy is allowed but not necessary for this analytical solution.\n\ndef solve():\n    \"\"\"\n    Computes the present value of a perpetuity with stochastic tax rates\n    for a given set of test cases.\n    \"\"\"\n    # Test suite: (C, r, kappa, tau_bar, tau_0, sigma)\n    test_cases = [\n        (100.0, 0.05, 0.3, 0.3, 0.2, 0.1),\n        (100.0, 0.05, 0.3, 0.3, 0.3, 0.4),\n        (100.0, 0.05, 0.0001, 0.3, 0.8, 0.2),\n        (100.0, 0.05, 10.0, 0.6, 0.2, 0.3),\n        (100.0, 0.05, 0.2, 1.0, 0.7, 0.0),\n        (100.0, 0.1, 0.4, 0.0, 0.5, 0.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        C, r, kappa, tau_bar, tau_0, sigma = case\n\n        # The analytical formula for the present value V is:\n        # V = C * [ (1 - tau_bar) / r + (tau_bar - tau_0) / (r + kappa) ]\n        # The volatility parameter sigma does not influence the expected present value.\n        \n        term1 = (1 - tau_bar) / r\n        term2 = (tau_bar - tau_0) / (r + kappa)\n        \n        present_value = C * (term1 + term2)\n        \n        # Round the result to 12 decimal places as specified.\n        # Python's round() function handles this appropriately for standard cases.\n        rounded_value = round(present_value, 12)\n        \n        results.append(str(rounded_value))\n\n    # Print the final output in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver.\nsolve()\n\n```", "id": "2371735"}]}