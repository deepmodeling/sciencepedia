{"hands_on_practices": [{"introduction": "计算债券的现值是一项基本技能，但真实世界的金融工具常常包含使教科书公式复杂化的特征。本练习旨在挑战你对一种“阶梯式”票息债券进行估值，其票息支付需遵循一个非线性的分段税收规则 [@problem_id:2395387]。这项实践将锻炼你在应用折现原理之前，如何细致地确定每个时期的确切税后现金流，这是精确定价复杂金融资产的关键一步。", "problem": "一位投资者评估一支阶梯式息票债券，其面值 $F = 1000$ 美元，到期时间为 $N = 6$ 年。息票方案如下：在第 $t = 1, 2, 3$ 年，年息票利率为面值的 $0.03$，而在第 $t = 4, 5, 6$ 年，年息票利率为面值的 $0.07$。息票税仅适用于息票支付，并在收款时根据当期息票金额 $C$ 按如下阶梯函数征收：\n$$\n\\tau(C) = \n\\begin{cases}\n0.10, & \\text{若 } 0 \\le C \\le 40, \\\\\n0.20, & \\text{若 } 40 < C \\le 60, \\\\\n0.35, & \\text{若 } C > 60.\n\\end{cases}\n$$\n到期时本金的赎回是免税的。该投资者使用固定的有效年收益率 $y = 0.06$ 对现金流进行折现。通过以收益率 $y$ 对税后息票现金流和免税的本金赎回进行折现，计算该债券的现值（PV），以美元计。将您的答案四舍五入到四位有效数字。最终金额以美元表示。", "solution": "该问题已经过验证，被认定是有效的。这是一个计算金融学中的适定问题，基于现值分析的既定原则，并包含了求解所需的所有必要且一致的信息。\n\n债券的现值（$PV$）是其未来现金流的总和，每笔现金流都折现到时间 $t=0$ 的价值。现金流由定期的税后息票支付和最终的本金赎回组成。现值的一般公式为：\n$$\nPV = \\sum_{t=1}^{N} \\frac{CF_t}{(1+y)^t}\n$$\n其中 $CF_t$ 是在第 $t$ 年末收到的总现金流，$N$ 是到期年数，$y$ 是用于折现的年有效收益率。\n\n首先，我们必须确定每年的现金流。该债券的面值为 $F = 1000$ 美元，到期时间为 $N = 6$ 年。折现收益率为 $y = 0.06$。\n\n步骤1：计算第 $t = 1, 2, 3$ 年的息票支付和税后现金流。\n给定的年息票利率为 $0.03$。息票金额 $C_1$ 为：\n$$\nC_1 = 0.03 \\times F = 0.03 \\times 1000 = 30\n$$\n为了计算税后现金流，我们应用给定的税收函数 $\\tau(C)$：\n$$\n\\tau(C) = \n\\begin{cases}\n0.10, & \\text{若 } 0 \\le C \\le 40, \\\\\n0.20, & \\text{若 } 40 < C \\le 60, \\\\\n0.35, & \\text{若 } C > 60.\n\\end{cases}\n$$\n对于 $C_1 = 30$，税率为 $\\tau(30) = 0.10$。\n前三年每年的税后现金流 $CF_1$ 为：\n$$\nCF_1 = C_1 \\times (1 - \\tau(C_1)) = 30 \\times (1 - 0.10) = 30 \\times 0.90 = \\$27\n$$\n\n步骤2：计算第 $t = 4, 5, 6$ 年的息票支付和税后现金流。\n给定的年息票利率为 $0.07$。息票金额 $C_2$ 为：\n$$\nC_2 = 0.07 \\times F = 0.07 \\times 1000 = 70\n$$\n对于 $C_2 = 70$，税率为 $\\tau(70) = 0.35$。\n后三年每年由息票产生的税后现金流 $CF_2$ 为：\n$$\nCF_2 = C_2 \\times (1 - \\tau(C_2)) = 70 \\times (1 - 0.35) = 70 \\times 0.65 = \\$45.50\n$$\n\n步骤3：确定总现金流序列。\n在时间 $t$ 的现金流包括税后息票。在到期日（$t=6$），现金流还包括免税的本金赎回 $F = 1000$。\n总现金流（$CF_t$）序列为：\n- 对于 $t = 1, 2, 3$：$CF_t = \\$27$\n- 对于 $t = 4, 5$：$CF_t = \\$45.50$\n- 对于 $t = 6$：$CF_6 = (\\text{税后息票}) + (\\text{本金}) = 45.50 + 1000 = \\$1045.50$\n\n步骤4：计算现值。\n现值是折现现金流的总和：\n$$\nPV = \\frac{27}{(1+0.06)^1} + \\frac{27}{(1+0.06)^2} + \\frac{27}{(1+0.06)^3} + \\frac{45.5}{(1+0.06)^4} + \\frac{45.5}{(1+0.06)^5} + \\frac{1045.5}{(1+0.06)^6}\n$$\n这个计算可以通过将两组息票支付序列和最终的本金支付分开来组织。\n现值可以表示为所有六次税后息票的现值与本金现值之和：\n$$\nPV = \\left( \\sum_{t=1}^{3} \\frac{27}{(1.06)^t} + \\sum_{t=4}^{6} \\frac{45.5}{(1.06)^t} \\right) + \\frac{1000}{(1.06)^6}\n$$\n我们使用普通年金的现值公式 $PV_A = P \\times \\frac{1 - (1+y)^{-n}}{y}$，其中 $P$ 是每期支付额。令 $a_{\\overline{n}|y} = \\frac{1 - (1+y)^{-n}}{y}$。\n\n前三次息票的现值为：\n$$\nPV_{\\text{coupons}, 1-3} = 27 \\times a_{\\overline{3}|0.06} = 27 \\times \\frac{1 - (1.06)^{-3}}{0.06} \\approx 27 \\times 2.673012 = 72.171324\n$$\n第 $4, 5, 6$ 年的息票现值是一个递延年金。其价值可以通过一个 $6$ 年期年金和一个 $3$ 年期年金的差值来计算：\n$$\nPV_{\\text{coupons}, 4-6} = 45.5 \\times (a_{\\overline{6}|0.06} - a_{\\overline{3}|0.06})\n$$\n$a_{\\overline{6}|0.06} = \\frac{1 - (1.06)^{-6}}{0.06} \\approx 4.917324$\n$$\nPV_{\\text{coupons}, 4-6} \\approx 45.5 \\times (4.917324 - 2.673012) = 45.5 \\times 2.244312 = 102.116196\n$$\n所有税后息票的总现值为：\n$$\nPV_{\\text{coupons}} \\approx 72.171324 + 102.116196 = 174.28752\n$$\n本金赎回的现值为：\n$$\nPV_{\\text{principal}} = \\frac{1000}{(1.06)^6} \\approx 1000 \\times 0.70496054 = 704.96054\n$$\n债券的总现值是这些组成部分的总和：\n$$\nPV = PV_{\\text{coupons}} + PV_{\\text{principal}} \\approx 174.28752 + 704.96054 = 879.24806\n$$\n题目要求将答案四舍五入到四位有效数字。计算出的值为 $879.24806$。前四位有效数字是 $8, 7, 9, 2$。第五位数字是 $4$，所以我们向下舍入。\n$$\nPV \\approx 879.2\n$$\n债券的现值以美元表示。", "answer": "$$\n\\boxed{879.2}\n$$", "id": "2395387"}, {"introduction": "金融协议通常包含条件性条款，即只有在满足特定条件时才会支付款项。本练习将引导你从手动计算转向算法问题解决，要求你对一个支付取决于公司利润的或有年金进行估值 [@problem_id:2395348]。你将开发一个程序来处理这些“如果-那么”情景并适应时变利率，从而培养对现实金融合约进行建模和估值的核心技能。", "problem": "要求您编写一个完整、可运行的程序，该程序用于计算一种或有年金的现值，其期末支付在特定条件未满足时将被跳过。条件为：公司季度利润必须达到或超过给定阈值，才会在该季度末进行固定支付；否则，该季度的支付将被跳过。所有支付均在每季度末发生。所有利率必须以小数形式处理（不带百分号）。假设对于每个时期 $t$，单期总回报满足 $1 + r_t > 0$。程序不得要求任何用户输入。\n\n基本原理。使用以下基础理论：确定性、离散复利和无套利条件下的货币时间价值。具体而言，一笔现值为 $v$ 的金额，以每期无风险利率 $r_1, r_2, \\dots, r_t$ 进行投资和复利计算，在 $t$ 个时期后累积为 $v \\cdot \\prod_{i=1}^{t} (1 + r_i)$。利用此基础来推导如何以现值计算未来日期的现金流价值。\n\n问题设置。对于一个 $N$ 个季度的有限期限，您将获得以下信息：\n- 一个恒定的季度末支付金额 $A$（以货币单位计）。\n- 一个利润序列 $\\{P_t\\}_{t=1}^{N}$，其中 $P_t$ 是在第 $t$ 季度观察到的利润。\n- 一个阈值 $\\theta$（单位与 $\\{P_t\\}$ 相同）。当且仅当 $P_t \\ge \\theta$ 时，才会支付第 $t$ 季度的款项；否则，该支付将被跳过。\n- 一个确定性的每季度无风险利率序列 $\\{r_t\\}_{t=1}^{N}$（每个利率均以小数表示，而非百分比）。\n\n您的任务是计算该年金在时间 $t = 0$ 的现值。该年金在每个满足 $P_t \\ge \\theta$ 的季度 $t$ 结束时支付 $A$，否则支付 $0$，并使用给定的利率期限结构 $\\{r_t\\}$ 进行贴现。\n\n覆盖范围与测试套件。实现您的程序，为以下每一组参数计算现值。在所有情况下，支付条件均使用包含等于的规则 $P_t \\ge \\theta$，且支付发生在每个季度 $t \\in \\{1,2,\\dots,N\\}$ 的末尾。\n\n- 测试用例 1（理想路径，恒定正利率，混合支付/跳过）：\n  - $A = 100$\n  - $\\theta = 2.5$\n  - $\\{P_t\\}_{t=1}^{5} = [3, 2, 4, 1, 5]$\n  - $\\{r_t\\}_{t=1}^{5} = [0.01, 0.01, 0.01, 0.01, 0.01]$\n- 测试用例 2（边界情况：零利率，等于阈值触发支付）：\n  - $A = 50$\n  - $\\theta = 2$\n  - $\\{P_t\\}_{t=1}^{3} = [2, 2, 2]$\n  - $\\{r_t\\}_{t=1}^{3} = [0.0, 0.0, 0.0]$\n- 测试用例 3（从未进行任何支付）：\n  - $A = 500$\n  - $\\theta = 10$\n  - $\\{P_t\\}_{t=1}^{4} = [1, 1, 1, 1]$\n  - $\\{r_t\\}_{t=1}^{4} = [0.05, 0.05, 0.05, 0.05]$\n- 测试用例 4（时变利率，包括一个小的负利率，多次支付）：\n  - $A = 123.45$\n  - $\\theta = 2$\n  - $\\{P_t\\}_{t=1}^{6} = [5, 0, 3, 2, 2, 10]$\n  - $\\{r_t\\}_{t=1}^{6} = [0.02, 0.03, -0.005, 0.01, 0.0, 0.04]$\n- 测试用例 5（全部支付，中等正利率，等于阈值）：\n  - $A = 200$\n  - $\\theta = 10$\n  - $\\{P_t\\}_{t=1}^{2} = [10, 10]$\n  - $\\{r_t\\}_{t=1}^{2} = [0.05, 0.05]$\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个数值结果四舍五入到六位小数。例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$。程序必须按顺序计算并打印上述每个测试用例的一个现值。不应打印任何其他文本。", "solution": "问题陈述已经过分析，并被确定为有效。它在科学上基于金融数学原理，问题定义明确，包含所有必要数据和无歧义的条件，并且表述客观。该问题按其陈述是可解的。\n\n任务是计算一个在 $N$ 个季度的有限期限内的或有年金的现值 ($PV$)。当且仅当公司在该季度 $t$ 的利润 $P_t$ 大于或等于指定阈值 $\\theta$ 时，该年金才会在季度末提供一笔金额为 $A$ 的支付。估值必须考虑一个确定性但可能随时间变化的每季度无风险利率序列 $\\{r_t\\}_{t=1}^{N}$。\n\n此计算的基本原理是现值的可加性。一连串现金流的总现值是每笔单独现金流现值的总和。\n\n首先，我们将每季度 $t \\in \\{1, 2, \\dots, N\\}$ 末发生的现金流 $C_t$ 形式化。根据问题的或有规则，现金流要么是 $A$ 要么是 $0$。这可以用一个指示函数 $I(\\cdot)$ 在数学上表示，当其参数为真时，该函数取值为 $1$，否则为 $0$。\n\n$$C_t = A \\cdot I(P_t \\ge \\theta)$$\n\n接下来，我们必须确定每笔现金流 $C_t$ 的现值。问题指定了具有单期利率期限结构 $\\{r_t\\}$ 的离散复利框架。在时间 $t$ 的未来价值，我们称之为 $FV_t$，通过以下公式与其在时间 $t=0$ 的现值 $PV_0$ 相关联：\n\n$$FV_t = PV_0 \\cdot \\prod_{i=1}^{t} (1 + r_i)$$\n\n这个公式描述了现值金额如何随时间累积价值。为了求出在未来时间 $t$ 收到的现金流 $C_t$ 的现值，我们必须反转这个过程，这被称为贴现。通过重新整理公式， $C_t$ 的现值为：\n\n$$PV(C_t) = \\frac{C_t}{\\prod_{i=1}^{t} (1 + r_i)}$$\n\n分母中的项 $\\prod_{i=1}^{t} (1 + r_i)$ 是到时间 $t$ 为止的累积因子。它的倒数，$D_t = 1 / \\prod_{i=1}^{t} (1 + r_i)$，是时间 $t$ 的贴现因子。问题陈述中提到，对于所有 $t$ 都有 $1 + r_t > 0$，这确保了贴现因子始终是良定义且为正的。\n\n根据价值可加性原理，整个或有年金的总现值是从 $t=1$ 到 $N$ 的每个季度现金流现值的总和：\n\n$$PV_{total} = \\sum_{t=1}^{N} PV(C_t) = \\sum_{t=1}^{N} C_t \\cdot D_t$$\n\n代入我们对 $C_t$ 和 $D_t$ 的表达式，我们得到所需现值的完整公式：\n\n$$PV_{total} = \\sum_{t=1}^{N} \\left( A \\cdot I(P_t \\ge \\theta) \\cdot \\frac{1}{\\prod_{i=1}^{t} (1 + r_i)} \\right)$$\n\n为了以算法方式实现此计算，我们对每个测试用例按以下步骤进行：\n1.  将利润和利率序列表示为数组 $\\{P_t\\}_{t=1}^{N}$ 和 $\\{r_t\\}_{t=1}^{N}$。\n2.  首先，我们确定或有现金流的序列。对于从 $1$ 到 $N$ 的每个 $t$，我们检查是否 $P_t \\ge \\theta$。如果为真，现金流为 $A$；否则为 $0$。这样就生成了现金流序列 $\\{C_t\\}_{t=1}^{N}$。\n3.  接下来，我们计算贴现因子的期限结构。每个时期 $t$ 的贴现因子取决于总回报 $(1 + r_i)$ 的累积乘积。设 $Z_t = \\prod_{i=1}^{t} (1 + r_i)$ 为累积因子。这可以通过迭代计算得出，其中 $Z_t = Z_{t-1} \\cdot (1 + r_t)$，初始值为 $Z_0=1$。那么贴现因子为 $D_t = 1/Z_t$。\n4.  对于每个季度 $t$，我们将现金流 $C_t$ 乘以相应的贴现因子 $D_t$ 来计算贴现现金流。\n5.  最后，我们将所有 $N$ 个季度的这些贴现现金流相加，以获得总现值。\n\n这个基于资产估值第一性原理的流程，将被应用于每个提供的测试用例，以得出最终的数值解。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the present value of a contingent annuity for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {'A': 100, 'theta': 2.5, 'P_t': [3, 2, 4, 1, 5], 'r_t': [0.01, 0.01, 0.01, 0.01, 0.01]},\n        # Test case 2\n        {'A': 50, 'theta': 2, 'P_t': [2, 2, 2], 'r_t': [0.0, 0.0, 0.0]},\n        # Test case 3\n        {'A': 500, 'theta': 10, 'P_t': [1, 1, 1, 1], 'r_t': [0.05, 0.05, 0.05, 0.05]},\n        # Test case 4\n        {'A': 123.45, 'theta': 2, 'P_t': [5, 0, 3, 2, 2, 10], 'r_t': [0.02, 0.03, -0.005, 0.01, 0.0, 0.04]},\n        # Test case 5\n        {'A': 200, 'theta': 10, 'P_t': [10, 10], 'r_t': [0.05, 0.05]}\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract parameters for the current test case\n        A = case['A']\n        theta = case['theta']\n        P_t = np.array(case['P_t'])\n        r_t = np.array(case['r_t'])\n\n        # Step 1: Determine the contingent cash flows for each period.\n        # The cash flow is 'A' if P_t >= theta, and 0 otherwise.\n        # This is achieved by creating a boolean mask and multiplying by A.\n        payment_occurs_mask = (P_t >= theta)\n        cash_flows = A * payment_occurs_mask\n\n        # Step 2: Calculate the discount factor for each period.\n        # The discount factor for period t is 1 / product(1+r_i) for i from 1 to t.\n        \n        # Gross returns for each period (1 + r_t)\n        gross_returns = 1 + r_t\n        \n        # Cumulative product of gross returns gives the denominator of the discount factor.\n        # np.cumprod([g1, g2, g3]) yields [g1, g1*g2, g1*g2*g3]\n        discount_denominators = np.cumprod(gross_returns)\n        \n        # Step 3: Calculate the present value of each cash flow\n        discounted_cash_flows = cash_flows / discount_denominators\n        \n        # Step 4: Sum the present values of all cash flows to get the total PV\n        total_pv = np.sum(discounted_cash_flows)\n        \n        # Format the result to six decimal places and append to the list\n        results.append(f\"{total_pv:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2395348"}, {"introduction": "一个公司的价值不仅是其当前现金流的总和，也反映了其未来的增长潜力。这个高级练习将带你进入动态系统的估值领域，其中公司的盈利根据其再投资决策和资本回报递减而演变 [@problem_id:2395318]。通过实现一个递归函数，你将学习如何为这种反馈循环建模，这是一种用于评估具有内生增长前景资产的强大计算方法。", "problem": "一家公司在离散时间（由 $t \\in \\{0,1,2,\\dots\\}$ 索引）内产生收益。设时间 $t$ 的收益为 $Y_t \\ge 0$，以货币单位计。在每个时间点 $t$，公司支付的股息 $D_t$ 等于未再投资的收益部分，即 $D_t = (1-g_t) Y_t$，其中 $g_t \\in [0,1]$ 是时间 $t$ 的再投资率。再投资金额为 $I_t = g_t Y_t$。新投资的回报不是恒定的：在时间 $t$ 进行再投资所带来的下一期收益的增量比例增益由一个回报函数 $r(Y_t) = \\dfrac{a}{1 + b Y_t}$ 给出，其中 $a > 0$ 和 $b \\ge 0$ 是参数。收益根据递归式 $Y_{t+1} = Y_t \\bigl(1 + r(Y_t) g_t \\bigr)$ 演变。公司的现值 (PV) 是以一个恒定的要求回报率 $R > 0$（以小数而非百分比表示）折现的股息总和，\n$$\n\\text{PV}(Y_0) = \\sum_{t=0}^{\\infty} \\beta^t D_t,\n$$\n其中 $\\beta = \\dfrac{1}{1+R}$。您必须使用递归计算来近似 $\\text{PV}(Y_0)$，该计算在下一个折现后股息贡献的绝对值低于容差 $\\varepsilon > 0$（即当 $\\beta^t |D_t| < \\varepsilon$）或达到硬性期限 $H \\in \\mathbb{N}$ 时停止，以先发生者为准。所有比率必须以小数形式提供和解释。每个测试用例的最终答案必须是以与 $Y_0$ 相同的货币单位表示的PV值，并四舍五入到6位小数。\n\n实现一个完整的、可运行的程序，该程序定义并使用一个与上述描述一致的递归函数，为以下测试套件中的每组参数计算 $\\text{PV}(Y_0)$。在每种情况下，如果提供的再投资序列 $[g_0,g_1,\\dots,g_{L-1}]$ 长度为 $L$，则对于所有 $t \\ge L$，使用 $g_t = g_{L-1}$。\n\n测试套件：\n- 用例 $1$（一般性、非恒定再投资）：$Y_0 = 100.0$, $R = 0.08$, $a = 0.25$, $b = 0.01$, $[g_0,g_1,g_2] = [0.4,0.35,0.3]$, $H = 500$, $\\varepsilon = 10^{-12}$。\n- 用例 $2$（完全再投资边界）：$Y_0 = 50.0$, $R = 0.10$, $a = 0.30$, $b = 0.02$, $[g_0] = [1.0]$, $H = 500$, $\\varepsilon = 10^{-12}$。\n- 用例 $3$（小额再投资伴随回报快速递减）：$Y_0 = 120.0$, $R = 0.05$, $a = 0.20$, $b = 0.05$, $[g_0] = [0.05]$, $H = 500$, $\\varepsilon = 10^{-12}$。\n- 用例 $4$（时变再投资趋近于零）：$Y_0 = 80.0$, $R = 0.12$, $a = 0.40$, $b = 0.03$, $[g_0,g_1,g_2,g_3] = [0.6,0.2,0.1,0.0]$, $H = 500$, $\\varepsilon = 10^{-12}$。\n\n您的程序必须生成一行输出，其中包含按上述顺序列出的各用例结果，格式为一个由方括号括起来的、逗号分隔的四个四舍五入后的PV值列表。输出必须只包含这四个四舍五入到6位小数的浮点数，不得包含任何额外文本。", "solution": "问题陈述已经过评估，并被确定为有效。它具有科学依据，是适定的，并且是客观的。为得到唯一的确定性解所需的所有必要数据和条件均已提供。该问题是计算金融中的一个标准练习，具体涉及使用具有非恒定增长的股息折现模型对公司进行估值。它没有违反任何指定的无效标准。因此，我们可以着手解决。\n\n目标是根据公司未来的股息流计算其现值 $\\text{PV}$。基本原则是，一项资产的价值是其预期未来现金流折算到现在的总和。对于在每个离散时间段 $t \\in \\{0, 1, 2, \\dots\\}$ 支付股息 $D_t$ 的公司，其现值由以下公式给出：\n$$\n\\text{PV}(Y_0) = \\sum_{t=0}^{\\infty} \\beta^t D_t\n$$\n其中 $Y_0$ 是初始收益，$D_t = (1-g_t)Y_t$ 是时间 $t$ 的股息，$g_t$ 是再投资率，而 $\\beta = \\frac{1}{1+R}$ 是对应于要求回报率 $R$ 的折现因子。\n\n收益 $Y_t$ 根据以下递归关系演变：\n$$\nY_{t+1} = Y_t \\left(1 + r(Y_t) g_t\\right)\n$$\n其中新投资的回报由 $r(Y_t) = \\frac{a}{1 + b Y_t}$ 给出。\n\n$\\text{PV}(Y_0)$ 的无限求和在计算上是不可行的。因此，我们必须用有限和来近似它。求和根据两个条件进行截断：最大时间期限 $H$ 和容差 $\\varepsilon$。如果在时间 $t$ 满足 $t \\ge H$ 或者该时期的折现股息项 $\\beta^t D_t$ 小于 $\\varepsilon$，则计算停止。\n\n为了形式化所需的递归计算，我们定义一个函数 $V(t, Y_t, \\beta_p)$，用于计算从时间 $t$ 开始的折现股息之和，其中 $Y_t$ 是时间 $t$ 的收益，$\\beta_p = \\beta^t$ 是时期 $t$ 的折现因子。总现值即为 $V(0, Y_0, 1)$。\n\n时间 $t$ 的股息是 $D_t = (1-g_t)Y_t$。这笔股息对总现值的贡献是 $\\Delta \\text{PV}_t = \\beta_p D_t$。\n\n递归结构基于以下逻辑：从时间 $t$ 开始的总价值等于时间 $t$ 的股息价值加上从时间 $t+1$ 开始的总价值。\n$$\nV(t, Y_t, \\beta_p) = \\Delta \\text{PV}_t + V(t+1, Y_{t+1}, \\beta_p \\cdot \\beta)\n$$\n这个递归关系必须包含终止条件。如果满足条件，递归将终止，并且不再增加任何价值。这导致了以下对递归步骤的精确定义：\n\n$V(t, Y_t, \\beta_p) = \\begin{cases} 0 & \\text{若 } t \\ge H \\text{ 或 } \\beta_p (1-g_t)Y_t < \\varepsilon \\\\ \\beta_p (1-g_t)Y_t + V(t+1, Y_{t+1}, \\beta_p \\cdot \\beta) & \\text{其他情况} \\end{cases}$\n\n其中 $Y_{t+1}$ 由 $Y_t$ 和 $g_t$ 计算得出。对于任何时间 $t$，再投资率 $g_t$ 由给定的序列 $[g_0, g_1, \\dots, g_{L-1}]$ 通过以下规则确定：如果 $t < L$，$g_t$ 是序列的第 $t$ 个元素；否则，$g_t = g_{L-1}$。这可以通过访问序列索引 $\\min(t, L-1)$ 来实现。\n\n递归的基准情形是返回 $0$ 的条件。递归步骤计算当前项，并加上对下一个时间步调用的结果。为计算给定参数集下的总现值，初始调用为 $V(0, Y_0, 1.0)$。这个结构为该问题提供了一个完整的算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport sys\n\n# It is good practice to set a higher recursion limit for problems involving deep recursion,\n# though the default of 1000 is sufficient for H=500.\nsys.setrecursionlimit(2000)\n\ndef compute_pv_recursive(t, current_y, current_beta_power, params):\n    \"\"\"\n    Recursively computes the Present Value of dividends from time t onwards.\n\n    Args:\n        t (int): The current time step.\n        current_y (float): The earnings at time t.\n        current_beta_power (float): The discount factor for time t, beta^t.\n        params (dict): A dictionary containing all model parameters.\n\n    Returns:\n        float: The Present Value of the dividend stream from time t onwards.\n    \"\"\"\n    # Unpack parameters\n    a = params['a']\n    b = params['b']\n    g_sequence = params['g_sequence']\n    H = params['H']\n    epsilon = params['epsilon']\n    beta = params['beta']\n    \n    # Termination condition 1: Hard horizon\n    if t >= H:\n        return 0.0\n\n    # Determine the reinvestment fraction g_t\n    g_sequence_len = len(g_sequence)\n    if t < g_sequence_len:\n        g_t = g_sequence[t]\n    else:\n        g_t = g_sequence[-1]\n\n    # Calculate dividend D_t\n    d_t = (1.0 - g_t) * current_y\n    \n    # Calculate the discounted dividend term\n    term = current_beta_power * d_t\n\n    # Termination condition 2: Tolerance\n    # Since Y_t >= 0 and g_t <= 1, D_t is non-negative. So |D_t| = D_t.\n    if term < epsilon:\n        return 0.0\n\n    # Calculate return on investment r(Y_t)\n    r_t = a / (1.0 + b * current_y)\n\n    # Calculate earnings for the next period Y_{t+1}\n    next_y = current_y * (1.0 + r_t * g_t)\n\n    # Recursive step\n    return term + compute_pv_recursive(t + 1, next_y, current_beta_power * beta, params)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        {'Y0': 100.0, 'R': 0.08, 'a': 0.25, 'b': 0.01, 'g_sequence': [0.4, 0.35, 0.3], 'H': 500, 'epsilon': 1e-12},\n        {'Y0': 50.0, 'R': 0.10, 'a': 0.30, 'b': 0.02, 'g_sequence': [1.0], 'H': 500, 'epsilon': 1e-12},\n        {'Y0': 120.0, 'R': 0.05, 'a': 0.20, 'b': 0.05, 'g_sequence': [0.05], 'H': 500, 'epsilon': 1e-12},\n        {'Y0': 80.0, 'R': 0.12, 'a': 0.40, 'b': 0.03, 'g_sequence': [0.6, 0.2, 0.1, 0.0], 'H': 500, 'epsilon': 1e-12},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Initial parameters for the recursive calculation\n        t0 = 0\n        y0 = case['Y0']\n        beta = 1.0 / (1.0 + case['R'])\n        \n        # Add beta to the parameters dictionary to pass to the recursive function\n        case['beta'] = beta\n\n        # Initial call to the recursive function\n        pv = compute_pv_recursive(t0, y0, 1.0, case)\n        \n        # Round result to 6 decimal places\n        results.append(round(pv, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2395318"}]}