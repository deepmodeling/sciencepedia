{"hands_on_practices": [{"introduction": "理论学习之后，我们通过第一个实践来巩固核心概念。现实世界中的利率并非一成不变，不同期限的投资往往对应着不同的利率。这个练习将挑战你使用一个动态变化的利率结构（即利率期限结构）来计算年金的现值，摆脱对单一固定利率的依赖。通过该练习，你将深化对逐期折现这一基本原理的理解，这是从理想化模型迈向真实金融场景的关键一步。[@problem_id:2444469]", "problem": "一个项目在每年年末支付一笔固定的现金流 $A$ 美元，为期 $n$ 年，其中 $A = 12{,}000$ 且 $n = 6$。经济体具有一个确定性的期限结构，由适用于第 $k-1$ 年到第 $k$ 年期间的一年期实际利率 $r_k$ 描述，其中 $k \\in \\{1,2,3,4,5,6\\}$。假设采用与这些特定时期实际利率相符的离散复利方式，并且现金流在每个时期末收到。利率如下：\n- $r_1 = 0.030$\n- $r_2 = 0.033$\n- $r_3 = 0.036$\n- $r_4 = 0.038$\n- $r_5 = 0.041$\n- $r_6 = 0.043$\n\n计算这笔年金在时间点 $0$ 的现值。将您的答案四舍五入至四位有效数字。以美元为单位表示最终结果。", "solution": "首先对问题陈述进行验证。\n\n根据陈述提取已知条件如下：\n- 等额年度现金流，$A = 12000$ 美元。\n- 支付次数，$n = 6$ 年。\n- 现金流时点：为期 $n$ 年，在每年年末。\n- 利率的期限结构由适用于第 $k-1$ 年至第 $k$ 年期间的一年期实际利率 $r_k$ 给出。\n- $r_1 = 0.030$\n- $r_2 = 0.033$\n- $r_3 = 0.036$\n- $r_4 = 0.038$\n- $r_5 = 0.041$\n- $r_6 = 0.043$\n- 复利计算方式为离散复利。\n- 目标是计算在时间点 $t=0$ 的现值 $PV$。\n- 最终答案必须四舍五入至四位有效数字，并以美元表示。\n\n经判定，该问题是有效的。它在科学上基于金融数学的原理，特别是货币的时间价值。此问题是适定的，为得到唯一解提供了所有必要数据，且其术语客观明确。不存在矛盾、数据缺失或违反科学原理的情况。我们开始进行求解。\n\n一系列现金流的现值（$PV$）是每笔独立现金流的折现值之和。在未来某个时间点收到的一笔现金流，需要使用其间各期的现行利率将其折现至时间点 $t=0$ 的价值。\n\n在本题中，在每年年末 $k$ 都会收到一笔固定的现金流 $A$，其中 $k \\in \\{1, 2, 3, 4, 5, 6\\}$。折现率不是恒定的，它遵循一个指定的期限结构。一年期实际利率 $r_j$ 适用于从第 $j-1$ 年到第 $j$ 年的区间。\n\n要计算在第 $k$ 年年末收到的单笔现金流 $A$ 的现值，我们必须使用相应的一年期利率，将其逐年折现回来。第 $k$ 年现金流的折现因子是各个独立的一年期折现因子的乘积。\n\n在第 $k=1$ 年的现金流的现值为：\n$$ PV_1 = \\frac{A}{1+r_1} $$\n在第 $k=2$ 年的现金流的现值为：\n$$ PV_2 = \\frac{A}{(1+r_1)(1+r_2)} $$\n推广开来，在第 $k$ 年的现金流的现值由下式给出：\n$$ PV_k = \\frac{A}{\\prod_{j=1}^{k} (1+r_j)} $$\n该年金的总现值是所有 $n$ 笔现金流的现值之和：\n$$ PV = \\sum_{k=1}^{n} PV_k = \\sum_{k=1}^{n} \\frac{A}{\\prod_{j=1}^{k} (1+r_j)} $$\n已知 $A=12000$ 且 $n=6$，我们可以写出完整的表达式：\n$$ PV = A \\left( \\frac{1}{1+r_1} + \\frac{1}{(1+r_1)(1+r_2)} + \\dots + \\frac{1}{\\prod_{j=1}^{6} (1+r_j)} \\right) $$\n让我们定义累积折现项 $D_k = \\prod_{j=1}^{k} (1+r_j)$。该公式变为：\n$$ PV = A \\sum_{k=1}^{6} \\frac{1}{D_k} $$\n我们现在代入给定的利率来计算每个 $D_k$：\n- $r_1=0.030 \\implies D_1 = 1+0.030 = 1.030$\n- $r_2=0.033 \\implies D_2 = D_1 \\times (1+0.033) = 1.030 \\times 1.033 = 1.06399$\n- $r_3=0.036 \\implies D_3 = D_2 \\times (1+0.036) = 1.06399 \\times 1.036 = 1.10230564$\n- $r_4=0.038 \\implies D_4 = D_3 \\times (1+0.038) = 1.10230564 \\times 1.038 = 1.14419325432$\n- $r_5=0.041 \\implies D_5 = D_4 \\times (1+0.041) = 1.14419325432 \\times 1.041 = 1.19110517774712$\n- $r_6=0.043 \\implies D_6 = D_5 \\times (1+0.043) = 1.19110517774712 \\times 1.043 = 1.2423227003902556$\n\n现在我们计算折现因子之和, $\\sum_{k=1}^{6} \\frac{1}{D_k}$：\n$$ \\sum_{k=1}^{6} \\frac{1}{D_k} = \\frac{1}{1.030} + \\frac{1}{1.06399} + \\frac{1}{1.10230564} + \\frac{1}{1.14419325432} + \\frac{1}{1.19110517774712} + \\frac{1}{1.2423227003902556} $$\n$$ \\approx 0.97087379 + 0.93985846 + 0.90718532 + 0.87397753 + 0.83953959 + 0.80494899 $$\n将这些值相加得到：\n$$ \\sum_{k=1}^{6} \\frac{1}{D_k} \\approx 5.33638366 $$\n现在，我们计算总现值：\n$$ PV = 12000 \\times 5.33638366 \\approx 64036.60396 $$\n题目要求将答案四舍五入至四位有效数字。$64036.60396$ 的前四位有效数字是 $6$、$4$、$0$ 和 $3$。第五位数字是 $6$，大于或等于 $5$，所以我们将第四位有效数字向上取整。数值 $3$ 变为 $4$。\n$$ PV \\approx 64040 $$\n用标准科学记数法表示，即为 $6.404 \\times 10^4$。结果以美元为单位。", "answer": "$$ \\boxed{6.404 \\times 10^4} $$", "id": "2444469"}, {"introduction": "掌握了基本的估值方法后，我们来探讨一个更复杂的资本预算决策问题。内部收益率（$IRR$）是评估项目投资吸引力的常用指标，但对于某些非传统现金流模式的项目，它可能会产生误导性的多个解。本练习模拟了一个具有初期巨额投资和期末高昂环境整治成本的采矿项目，旨在揭示“多重$IRR$问题”，并引入修正内部收益率（$MIRR$）作为更稳健的决策工具。[@problem_id:2444465]", "problem": "一个露天开采项目在时点 $t=0,1,2,3,4$ 的期末现金流（单位：百万货币单位，MMU）如下：$C_0=-1{,}000$，$C_1=+1{,}200$，$C_2=+1{,}200$，$C_3=+1{,}200$，以及一笔巨大的环境整治支出 $C_4=-2{,}700$。公司的资本成本为 $10\\%$（在计算修正内部收益率时，该成本既用作负现金流的融资利率，也用作正现金流的再投资利率）。\n\n关于该项目的内部收益率 (IRR) 和修正内部收益率 (MIRR)，以下哪项陈述是正确的？\n\nA. 该项目存在唯一的IRR，约等于 $11.3\\%$，这也是它的MIRR；由于这个值约等于 $10\\%$ 的资本成本，因此该项目是临界的。\n\nB. 该项目存在两个IRR，分别约为 $3.2\\%$ 和 $77.6\\%$。在融资和再投资利率均为 $10\\%$ 的情况下，MIRR 约为 $11.3\\%$，并且在 $10\\%$ 折现率下的净现值 (NPV) 为正；尽管存在多个IRR，MIRR 在此提供了一个唯一的、与决策一致的概括。\n\nC. 该项目没有IRR，因为在所有折现率下NPV都为负；MIRR也为负。\n\nD. 该项目有两个IRR，约为 $-3\\%$ 和 $30\\%$；根据定义，MIRR 总是等于资本成本 $10\\%$，所以多重IRR问题是无关紧要的。", "solution": "将折现率为 $r$ 时的净现值 (NPV) 定义为\n$$\n\\text{NPV}(r)\\;=\\;-1{,}000\\;+\\;\\frac{1{,}200}{(1+r)^1}\\;+\\;\\frac{1{,}200}{(1+r)^2}\\;+\\;\\frac{1{,}200}{(1+r)^3}\\;-\\;\\frac{2{,}700}{(1+r)^4}.\n$$\n根据定义，内部收益率 (IRR) 是任何满足 $\\text{NPV}(r)=0$ 的 $r$。由于现金流的符号模式为 $(-,+,+,+,-)$，存在两次符号变化，因此根据 Descartes 符号法则，可能存在 $0$ 个或 $2$ 个正的 IRR。在融资利率为 $f$ 和再投资利率为 $g$ 的情况下，修正内部收益率 (MIRR) 的定义是通过一个等式来确定的，该等式让以 $g$ 复利计算的正现金流的终值（在期末）等于以 $f$ 折现的负现金流的现值（在 $t=0$）在 $n$ 个周期内增长后的值：\n$$\n\\text{MIRR}\\;=\\;\\left(\\frac{\\text{FV of positive cash flows at }g}{\\text{PV of negative cash flows at }f}\\right)^{1/n}-1,\n$$\n此处 $n=4$。\n\n步骤 1：确定在基准利率下 $\\text{NPV}(r)$ 的符号，并框定 IRR 的根所在的区间。\n\n- 在 $r=0$ 时，$\\text{NPV}(0)= -1{,}000+1{,}200+1{,}200+1{,}200-2{,}700=-100<0$。\n\n- 在 $r=0.10$ 时，计算各项的现值：\n$\\frac{1{,}200}{1.1}=1{,}090.909$，$\\frac{1{,}200}{1.1^2}=\\frac{1{,}200}{1.21}=991.736$，$\\frac{1{,}200}{1.1^3}=\\frac{1{,}200}{1.331}\\approx 901.580$，以及 $\\frac{2{,}700}{1.1^4}=\\frac{2{,}700}{1.4641}\\approx 1{,}843.277$。\n因此，\n$$\n\\text{NPV}(0.10)\\approx -1{,}000+(1{,}090.909+991.736+901.580)-1{,}843.277\\approx 140.95>0.\n$$\n由于 $\\text{NPV}(0)<0$ 且 $\\text{NPV}(0.10)>0$，在区间 $(0,0.10)$ 内至少存在一个 IRR。\n\n- 在 $r=0.78$ 时，有 $1+r=1.78$，则 $(1+r)^2=3.1684$，$(1+r)^3\\approx 5.6398$，$(1+r)^4\\approx 10.0359$。然后\n$\\frac{1{,}200}{1.78}\\approx 674.157$，$\\frac{1{,}200}{3.1684}\\approx 378.904$，$\\frac{1{,}200}{5.6398}\\approx 212.796$，$\\frac{2{,}700}{10.0359}\\approx 268.93$。\n因此\n$$\n\\text{NPV}(0.78)\\approx -1{,}000+(674.157+378.904+212.796)-268.93\\approx -3.07<0.\n$$\n\n- 在 $r=0.77$ 时，有 $1+r=1.77$，则 $(1+r)^2=3.1329$, $(1+r)^3\\approx 5.545$, $(1+r)^4\\approx 9.815$。然后\n$\\frac{1{,}200}{1.77}\\approx 677.966$，$\\frac{1{,}200}{3.1329}\\approx 382.900$，$\\frac{1{,}200}{5.545}\\approx 216.460$，$\\frac{2{,}700}{9.815}\\approx 274.97$。\n因此\n$$\n\\text{NPV}(0.77)\\approx -1{,}000+(677.966+382.900+216.460)-274.97\\approx 2.36>0.\n$$\n由于 $\\text{NPV}(0.77)>0$ 且 $\\text{NPV}(0.78)<0$，第二个 IRR 位于区间 $(0.77,0.78)$ 内。\n\n为了更精确地确定较小的 IRR，在 $r=0.031$ 和 $r=0.032$ 附近进行评估：\n\n- 在 $r=0.031$ 时，$(1+r)=1.031$，$(1+r)^2\\approx 1.063$，$(1+r)^3\\approx 1.095$，$(1+r)^4\\approx 1.128$。然后\n$\\frac{1{,}200}{1.031}\\approx 1{,}164.89$，$\\frac{1{,}200}{1.063}\\approx 1{,}128.53$，$\\frac{1{,}200}{1.095}\\approx 1{,}095.89$，$\\frac{2{,}700}{1.128}\\approx 2{,}392.0$。\n因此\n$$\n\\text{NPV}(0.031)\\approx -1{,}000}+(1{,}164.89+1{,}128.53+1{,}095.89)-2{,}392.0\\approx -2.69<0.\n$$\n\n- 在 $r=0.032$ 时，$(1+r)=1.032$，$(1+r)^2\\approx 1.0650$，$(1+r)^3\\approx 1.0981$，$(1+r)^4\\approx 1.1343$。然后\n$\\frac{1{,}200}{1.032}\\approx 1{,}162.79$，$\\frac{1{,}200}{1.0650}\\approx 1{,}126.76$，$\\frac{1{,}200}{1.0981}\\approx 1{,}092.86$，$\\frac{2{,}700}{1.1343}\\approx 2{,}380.5$。\n因此\n$$\n\\text{NPV}(0.032)\\approx -1{,}000}+(1{,}162.79+1{,}126.76+1{,}092.86)-2{,}380.5\\approx 1.91>0.\n$$\n因此，较小的 IRR 约等于 $r\\approx 3.2\\%$。根据上述的区间框定，较大的 IRR 约等于 $r\\approx 77.6\\%$（由区间 $(0.77,0.78)$ 数值精算得出）。\n\n步骤 2：在融资利率 $f=10\\%$、再投资利率 $g=10\\%$ 且 $n=4$ 的情况下计算 MIRR。\n\n- 负现金流在 $f=10\\%$ 时的现值：\n$$\n\\text{PV}_{-} = 1{,}000+\\frac{2{,}700}{(1.10)^4}=1{,}000+\\frac{2{,}700}{1.4641}\\approx 1{,}000+1{,}843.277=2{,}843.277.\n$$\n\n- 正现金流在 $g=10\\%$ 复利计算下于 $t=4$ 时的终值：\n$$\n\\text{FV}_{+} = 1{,}200(1.10)^3+1{,}200(1.10)^2+1{,}200(1.10)=1{,}200(1.331+1.21+1.10)=1{,}200(3.641)=4{,}369.2.\n$$\n\n- MIRR:\n$$\n\\text{MIRR}=\\left(\\frac{\\text{FV}_{+}}{\\text{PV}_{-}}\\right)^{1/4}-1=\\left(\\frac{4{,}369.2}{2{,}843.277}\\right)^{1/4}-1\\approx (1.5362)^{0.25}-1\\approx 0.113\\;\\text{或}\\;11.3\\%.\n$$\n\n步骤 3：检查在 $10\\%$ 利率下的 NPV，以使决策与 MIRR 保持一致：\n根据上面的计算，\n$$\n\\text{NPV}(0.10)\\approx 140.95>0,\n$$\n因此，根据 NPV 准则，在 $10\\%$ 的资本成本下，该项目是增值的。约 $11.3\\%$ 的 MIRR 超过了 $10\\%$ 的最低资本回报率，得出了相同的接受/拒绝决策。相比之下，存在两个 IRR（约 $3.2\\%$ 和约 $77.6\\%$）使得未修正的 IRR 准则变得模棱两可。\n\n逐项分析选项：\n\n- 选项 A：陈述存在唯一的 IRR，约等于 $11.3\\%$ 且等于 MIRR。这是不正确的。现金流模式 $(-,+,+,+,-)$ 容许存在两个 IRR，而计算出的 MIRR $\\approx 11.3\\%$ 并不是 IRR。\n\n- 选项 B：报告了两个接近 $3.2\\%$ 和 $77.6\\%$ 的 IRR，一个接近 $11.3\\%$ 的 MIRR，并指出在 $10\\%$ 利率下的 NPV 为正，且 MIRR 提供了一个唯一的、与决策一致的总结。这与计算结果相符，是正确的。\n\n- 选项 C：声称没有 IRR 且 MIRR 为负。这与显示存在两个 IRR 的区间框定以及计算出的正值 MIRR 相矛盾。\n\n- 选项 D：给出了不合理的 IRR 值（$-3\\%$ 和 $30\\%$）并声称 MIRR 总是等于资本成本。MIRR 仅在特殊的现金流配置下才等于资本成本，通常并非根据其定义就成立；在此例中 MIRR $\\approx 11.3\\%\\neq 10\\%$。这是不正确的。\n\n因此，正确选项是 B。", "answer": "$$\\boxed{B}$$", "id": "2444465"}, {"introduction": "许多重要的金融问题，例如计算债券的到期收益率（$YTM$），并没有简单的代数解。在本次动手实践中，你将亲手编写代码，实现一个数值算法（区间法）来求解这一关键指标。这个练习旨在打通金融理论与计算实践之间的壁垒，让你体验如何将抽象的金融概念转化为可执行的程序，从而解决无法通过解析方法处理的实际问题。[@problem_id:2377925]", "problem": "您将实现一个区间求根算法，用以计算附息债券和零息债券的到期收益率 (YTM)。YTM 是一种名义年利率（按每年指定频率复利），它使所有未来现金流的现值等于当前市场价格。此任务必须被构建为一个单未知数的标量求根问题，使用区间法求解一个连续函数，并从第一性原理出发进行论证。\n\n基本原理：\n- 货币时间价值：未来现金流的现值等于其金额乘以一个适当的折现因子，该折现因子源自名义年收益率、复利频率和所经过的时间。\n- 连续性与单调性：对于由名义年收益率（每年复利固定次数）折现的一系列严格为正的现金流，其现值是关于收益率的连续严格递减函数。\n- 介值定理 (IVT)：如果一个闭区间上的连续函数在两个端点处的取值异号，那么它在该区间内至少有一个根。\n\n按如下方式定义标量函数。设未知数为名义年收益率 $y$。设复利频率为每年 $m$ 次支付，其中 $m \\in \\mathbb{N}$，并假设 $m T \\in \\mathbb{N}$，因此总期数为整数。对于一个面值为 $F$，年票面利率为 $c$（以年化小数表示），到期时间为 $T$ 年，当前市场价格为 $P$ 的债券，将 $f(y)$ 定义为所有未来票息支付和赎回金额的现值（使用名义年收益率 $y$ 和复利频率 $m$ 进行折现）与观测价格 $P$ 之间的差额。YTM 是任何满足 $f(y) = 0$ 且符合财务可行性条件 $1 + y/m > 0$ 的 $y$。\n\n您的程序必须：\n- 实现一个区间求根方法（例如，二分法或试位法），该方法仅使用函数求值和区间端点，并保证对存在符号变化的连续函数收敛，而不依赖导数信息。您必须使用一个固定的初始区间 $[y_{\\min}, y_{\\max}] = [-0.99, 3.0]$，并验证对于每个测试用例，都有 $f(y_{\\min}) \\cdot f(y_{\\max}) \\le 0$。如果初始区间没有跨越一个根，您必须在维持财务可行性条件 $1 + y/m > 0$ 的同时，审慎地扩展该区间，直到找到符号变化或达到合理的扩展限制。\n- 对于每支债券，通过将每笔现金流按名义年收益率 $y$（每年复利 $m$ 次）所隐含的每期利率进行折现来计算现值，然后对其各自期数索引下的所有现金流求和。每期折现因子必须强制满足财务可行性条件 $1 + y/m > 0$。\n- 使用一个停止准则，确保区间绝对宽度小于或等于指定的容差 $\\varepsilon$，或者中点处的函数绝对值小于或等于指定的容差 $\\delta$。使用 $\\varepsilon = 10^{-12}$ 和 $\\delta = 10^{-12}$，并且每次求根最多迭代 $10{,}000$ 次。\n- 结果以年化小数形式输出（无百分号）。不涉及角度。货币价值采用任意一致的单位；无需货币符号。\n\n测试套件：\n对于每种情况，参数均按上述约定以 $(F, c, m, T, P)$ 形式给出。假设 $m T \\in \\mathbb{N}$。\n\n- 情况 $1$ (一般附息债券，折价): $(F=\\$1000, c=0.05, m=2, T=5, P=\\$950)$。\n- 情况 $2$ (零息债券，正收益率): $(F=\\$1000, c=0.0, m=1, T=3, P=\\$850)$。\n- 情况 $3$ (平价债券，一致性检验): $(F=\\$1000, c=0.04, m=2, T=7, P=\\$1000)$。\n- 情况 $4$ (零息债券，负收益率): $(F=\\$1000, c=0.0, m=1, T=1, P=\\$1005)$。\n\n答案规范：\n- 对于每个测试用例，将 YTM 作为浮点数输出，以年化小数表示，并精确到 $10$ 位小数。\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，按情况 $1$ 到 $4$ 的顺序排列。例如，输出格式必须严格为 $[y_1,y_2,y_3,y_4]$，其中每个 $y_k$ 都四舍五入到 $10$ 位小数。", "solution": "该问题陈述已经过严格验证。所有给定信息都已提取，并根据科学合理性、完整性和客观性标准进行了核对。该问题定义明确，以成熟的金融数学为基础，不包含任何歧义、矛盾或事实错误。为测试用例提供的参数在物理上和财务上都是合理的。因此，该问题被认定为有效，并将提供解答。\n\n核心任务是确定一组债券的到期收益率 (YTM)，记为 $y$。YTM 是使债券未来现金流的现值等于其当前市场价格的名义年利率。这是一个关于收益率 $y$ 的标量函数的求根问题。\n\n首先，我们必须从第一性原理出发构建此函数。设一支债券的面值为 $F$，年票面利率为 $c$，到期时间为 $T$ 年，票息复利频率为每年 $m$ 次。问题指定总期数 $N = mT$ 为一个整数。\n\n债券的总现金流由两部分组成：定期的票息支付和最终的面值赎回。\n年票息金额为 $cF$。由于每年支付 $m$ 次，每次票息支付额为 $C = \\frac{cF}{m}$。这些支付发生在每个计息期末，总共有 $N = mT$ 个计息期。\n在最后一个计息期 $N$ 结束时，面值 $F$ 也会返还。\n因此，在计息期 $k \\in \\{1, 2, \\dots, N-1\\}$ 结束时的现金流为 $C_k = C$，而在最后一个计息期 $N$ 的现金流为 $C_N = C + F$。\n\n货币时间价值原理指出，未来的现金流必须经过折现才能得到其现值。设 $y$ 为名义年收益率。每期收益率为 $r = \\frac{y}{m}$。在第 $k$ 期的现金流的折现因子为 $(1+r)^{-k} = (1 + y/m)^{-k}$。财务可行性的一个关键条件是折现率必须有明确定义，这要求 $1 + y/m > 0$。\n\n所有未来现金流的总现值 $\\text{PV}(y)$ 是每笔现金流折现值的总和：\n$$ \\text{PV}(y) = \\sum_{k=1}^{N} \\frac{C_k}{(1 + y/m)^k} $$\n代入附息债券的具体现金流 ($c>0$)：\n$$ \\text{PV}(y) = \\left( \\sum_{k=1}^{N} \\frac{C}{(1+y/m)^k} \\right) + \\frac{F}{(1+y/m)^N} $$\n其中 $C = \\frac{cF}{m}$ 且 $N=mT$。对于零息债券 ($c=0$)，票息支付为零，公式简化为单笔总额的现值：\n$$ \\text{PV}(y) = \\frac{F}{(1+y/m)^N} $$\n问题将待求解的函数 $f(y)$ 定义为现金流现值与市场价格 $P$ 之间的差额：\n$$ f(y) = \\text{PV}(y) - P = 0 $$\n对于任何一组正现金流，函数 $\\text{PV}(y)$ 在其可行域 $y > -m$ 上是关于 $y$ 的连续且严格递减的函数。因此，$f(y)$ 也是一个连续且严格递减的函数。这种单调性保证了如果根存在，它就是唯一的。\n\n根据介值定理 (IVT)，可以保证在一个区间内存在根。该定理指出，对于闭区间 $[a, b]$ 上的连续函数，如果 $f(a)$ 和 $f(b)$ 符号相反，那么在 $(a, b)$ 内必然存在至少一个值 $y^*$ 使得 $f(y^*) = 0$。这是区间求根方法的理论基础。\n\n我们将实现二分法，这是一种稳健且简单的区间算法，无需导数信息。它的收敛性得到保证，尽管是线性收敛，但这对于所要求的精度来说是可以接受的。\n\n算法流程如下：\n$1$. 初始化搜索区间。问题指定了一个初始区间 $[a, b] = [y_{\\min}, y_{\\max}] = [-0.99, 3.0]$。我们必须验证该区间是否有效，即 $f(a) \\cdot f(b) \\le 0$。鉴于 $f(y)$ 是单调递减的，我们期望 $f(a) > 0$ 和 $f(b) < 0$。如果此条件不成立，则必须扩展区间。由于当 $y \\to -m^+$ 时 $f(y) \\to \\infty$，而当 $y \\to \\infty$ 时 $f(y) \\to -P < 0$，因此保证存在满足介值定理条件的区间。扩展逻辑将在 $f(b)>0$ 时增加 $b$，并在 $f(a)<0$ 时减小 $a$（朝 $-m$ 方向）。对于指定的测试用例，初始区间 $[-0.99, 3.0]$ 已经足够，无需扩展。\n\n$2$. 迭代直至满足停止准则。在每次迭代中：\n   a. 计算当前区间的中点：$y_{\\text{mid}} = a + \\frac{b-a}{2}$。这种表示法优于 $(a+b)/2$，以避免在数值较大时可能出现的浮点溢出。\n   b. 在中点处计算函数值 $f(y_{\\text{mid}})$。\n   c. 检查停止准则。如果区间宽度足够小，即 $|b-a| \\le \\varepsilon = 10^{-12}$，或者中点处的函数值接近于零，即 $|f(y_{\\text{mid}})| \\le \\delta = 10^{-12}$，则过程终止。同时强制执行迭代次数上限（$10,000$ 次）以防止无限循环。\n   d. 更新区间。根据 $f(y_{\\text{mid}})$ 的符号，舍弃保证不包含根的那一半区间。如果 $f(y_{\\text{mid}})$ 与 $f(a)$ 同号，则新区间变为 $[y_{\\text{mid}}, b]$。否则，变为 $[a, y_{\\text{mid}}]$。由于我们预期 $f(a)>0$，如果 $f(y_{\\text{mid}})>0$，根位于 $[y_{\\text{mid}},b]$，因此我们设置 $a = y_{\\text{mid}}$。如果 $f(y_{\\text{mid}})<0$，根位于 $[a, y_{\\text{mid}}]$，因此我们设置 $b = y_{\\text{mid}}$。\n\n$3$. 最终结果是最后计算区间的的中点，它以有保证的误差界限逼近根 $y^*$。\n\n此方法将应用于每个测试用例，以计算相应的 YTM。计算使用浮点算术进行，最终结果按要求四舍五入到 $10$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants as per problem specification\nTOLERANCE_EPSILON = 1e-12\nTOLERANCE_DELTA = 1e-12\nMAX_ITERATIONS = 10000\nINITIAL_BRACKET = [-0.99, 3.0]\n\ndef calculate_f_y(y, F, c, m, T, P):\n    \"\"\"\n    Calculates the value of the price-yield function f(y) = PV(y) - P.\n    \n    Args:\n        y (float): The nominal annual yield (YTM).\n        F (float): Face value of the bond.\n        c (float): Annual coupon rate (decimal).\n        m (int): Compounding frequency per year.\n        T (int): Maturity in years.\n        P (float): Current market price.\n\n    Returns:\n        float: The value of f(y).\n    \"\"\"\n    # Financial feasibility condition: 1 + y/m > 0\n    if 1.0 + y / m <= 0:\n        return float('inf')  # Return a large positive value for infeasible yields\n\n    num_periods = int(m * T)\n    coupon_per_period = c * F / m\n\n    present_value = 0.0\n    \n    # The term (1 + y/m) is used repeatedly\n    discount_base = 1.0 + y / m\n    \n    # Calculate present value of coupon payments using direct summation\n    if c > 0:\n        for k in range(1, num_periods + 1):\n            present_value += coupon_per_period / (discount_base ** k)\n\n    # Add present value of face value redemption\n    present_value += F / (discount_base ** num_periods)\n    \n    return present_value - P\n\ndef find_ytm(params):\n    \"\"\"\n    Computes the Yield-to-Maturity (YTM) for a bond using the bisection method.\n\n    Args:\n        params (tuple): A tuple containing bond parameters (F, c, m, T, P).\n\n    Returns:\n        float: The calculated YTM.\n    \"\"\"\n    F, c, m, T, P = params\n    \n    a, b = INITIAL_BRACKET[0], INITIAL_BRACKET[1]\n    \n    fa = calculate_f_y(a, F, c, m, T, P)\n    fb = calculate_f_y(b, F, c, m, T, P)\n    \n    # Bracket expansion logic as required by the problem statement.\n    # Note: For the given test cases, the initial bracket is sufficient.\n    # This logic is included for robustness as per the directive.\n    expansion_limit = 20\n    expand_iter = 0\n    while fa * fb > 0 and expand_iter < expansion_limit:\n        # f(y) is monotonically decreasing.\n        # If both are positive, root is to the right of b.\n        if fa > 0 and fb > 0:\n            b *= 2.0\n        # If both are negative, root is to the left of a.\n        elif fa < 0 and fb < 0:\n            # Conservatively move 'a' towards the theoretical limit -m\n            a = (a - m) / 2.0\n            if a <= -m: # Ensure feasibility\n                a = -m + 1e-9\n        else: # One or both are zero, which is a root\n            return a if fa == 0 else b\n\n        fa = calculate_f_y(a, F, c, m, T, P)\n        fb = calculate_f_y(b, F, c, m, T, P)\n        expand_iter += 1\n\n    if fa * fb > 0:\n        raise ValueError(f\"Failed to find a bracketing interval for params: {params}\")\n\n    # Ensure fa is positive and fb is negative to simplify bisection logic\n    if fa < 0:\n        a, b = b, a\n        fa, fb = fb, fa\n\n    # Bisection method implementation\n    for _ in range(MAX_ITERATIONS):\n        mid = a + (b - a) / 2.0\n        f_mid = calculate_f_y(mid, F, c, m, T, P)\n        \n        # Check stopping criteria\n        if (b - a) <= TOLERANCE_EPSILON or abs(f_mid) <= TOLERANCE_DELTA:\n            return mid\n        \n        # Update bracket\n        if f_mid > 0:  # Root is in the right half [mid, b]\n            a = mid\n            fa = f_mid\n        else:  # Root is in the left half [a, mid]\n            b = mid\n            fb = f_mid\n            \n    # If max iterations is reached, return the best estimate.\n    return a + (b - a) / 2.0\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Test suite: (F, c, m, T, P)\n    test_cases = [\n        (1000.0, 0.05, 2, 5.0, 950.0),    # Case 1: General coupon bond, discount\n        (1000.0, 0.0, 1, 3.0, 850.0),    # Case 2: Zero-coupon, positive yield\n        (1000.0, 0.04, 2, 7.0, 1000.0),   # Case 3: Par bond, consistency check\n        (1000.0, 0.0, 1, 1.0, 1005.0)     # Case 4: Zero-coupon, negative yield\n    ]\n\n    results = []\n    for case in test_cases:\n        ytm = find_ytm(case)\n        # Format to 10 decimal places as required\n        results.append(f\"{ytm:.10f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver\nsolve()\n```", "id": "2377925"}]}