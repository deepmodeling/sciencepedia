{"hands_on_practices": [{"introduction": "消费者决策常常面临两种现实约束：一些商品需要按固定比例消费（如左脚和右脚的鞋），而另一些商品只能以整数单位购买（如汽车或家电）。本练习巧妙地结合了这两种情况，要求您在一个里昂惕夫（Leontief）效用函数（代表完全互补品）的框架下，为一个其中一种商品只能按整数单位购买的消费者进行优化。由于效用函数不可微且存在整数约束，传统的基于微积分的切线法则（即边际替代率等于价格比）不再适用。您需要通过逻辑和算法推理 [@problem_id:2384153]，探索如何在连续最优解附近进行搜索，以找到离散约束下的真正最优选择。", "problem": "考虑一个消费者选择两种商品（商品 $x$ 和商品 $y$）的非负数量，以在线性预算约束下最大化其效用。其效用函数为 Leontief（完全互补品）形式，由 $U(x,y)=\\min(a x, b y)$ 给出，其中 $a>0$ 和 $b>0$ 是固定参数。商品 $x$ 的价格为 $p_x>0$，商品 $y$ 的价格为 $p_y>0$。收入为 $m\\ge 0$。选择集受到预算约束 $p_x x + p_y y \\le m$、$x \\ge 0$以及一项可用性限制，即 $y$ 的选择必须是离散的整数单位 $y \\in \\{0,1,2,\\dots\\}$。消费者寻求选择 $(x,y)$ 以最大化 $U(x,y)$。\n\n在所有效用最大化的商品组合中，选择能达到最大效用且 $y$ 为最小整数的那个组合。对于选定的 $y$，选择能达到该效用水平并满足预算约束的最小非负实数 $x$。\n\n所有变量都是无单位的。不涉及角度或物理单位。\n\n您的程序必须根据上述约束和选择规则，为下面的每个参数集计算出效用最大化的商品组合 $(x^\\star,y^\\star)$ 以及相应的最大效用 $U^\\star=U(x^\\star,y^\\star)$。每个参数集所需的输出是一个三元组 $[x^\\star,y^\\star,U^\\star]$。\n\n请为以下参数集测试套件提供结果，每个参数集指定为 $(a,b,p_x,p_y,m)$：\n- $(a,b,p_x,p_y,m) = (\\, 1,\\, 1,\\, 2,\\, 3,\\, 20 \\,)$\n- $(a,b,p_x,p_y,m) = (\\, 2,\\, 1,\\, 3,\\, 5,\\, 11 \\,)$\n- $(a,b,p_x,p_y,m) = (\\, 1.5,\\, 2,\\, 1,\\, 10,\\, 7 \\,)$\n- $(a,b,p_x,p_y,m) = (\\, 2,\\, 1,\\, 3,\\, 4,\\, 9.5 \\,)$\n- $(a,b,p_x,p_y,m) = (\\, 3,\\, 5,\\, 2,\\, 7,\\, 100 \\,)$\n\n最终输出格式：\n- 对于每个参数集，输出一个三元组 $[x^\\star,y^\\star,U^\\star]$，其中 $x^\\star$ 和 $U^\\star$ 是保留六位小数的实数，$y^\\star$ 是一个整数。\n- 将所有参数集的结果汇总到单行中，形成为一个由方括号括起来的、逗号分隔的列表，且无空格。例如：$[[\\!x^\\star_1,y^\\star_1,U^\\star_1],[\\!x^\\star_2,y^\\star_2,U^\\star_2],\\dots]$。", "solution": "所给出的问题是一个源于微观经济学领域的有约束效用最大化问题。该问题定义明确、数学上一致，并且基于成熟的经济学理论。效用函数为 Leontief 形式，$U(x,y)=\\min(ax, by)$，代表完全互补品。消费者的选择受到预算约束 $p_x x + p_y y \\le m$ 和混合变量约束的限制，其中商品 $x$ 是一个连续非负变量（$x \\ge 0$），而商品 $y$ 是一个离散非负整数（$y \\in \\{0,1,2,\\dots\\}$）。目标是找到满足这些约束以及一套特定平局打破规则的商品组合 $(x^\\star, y^\\star)$ 和相应的最大效用 $U^\\star$。\n\n分析始于 Leontief 效用函数的性质。为了最大化效用，一个理性的消费者绝不会选择 $ax \\neq by$ 的商品组合。例如，如果 $ax > by$，则效用完全由 $by$ 项决定。消费者可以减少 $x$ 的消费而没有任何效用损失，从而节省收入。这笔节省下来的收入可以被重新分配，以增加两种商品的消费，从而带来严格更高的效用水平。因此，任何具有正效用的最优商品组合都必须满足条件 $ax = by$。这个关系定义了扩展路径，最优组合必须位于该路径上。由此，我们推导出商品的最优比例为 $x = \\frac{b}{a}y$。\n\n$y$ 必须是整数的约束将问题转化为一个混合整数优化问题。我们不能再简单地求解方程组 $ax = by$ 和 $p_x x + p_y y = m$。相反，我们必须对每个可行的整数值 $y$ 评估其可能的最大效用。\n\n对于 $y$ 的一个整数选择（我们称之为 $y_k$），只有当其成本不超过总收入时，即 $p_y y_k \\le m$，它才是可行的。这意味着 $y$ 的可行整数集是有限的，由 $y_k \\in \\{0, 1, 2, \\dots, \\lfloor \\frac{m}{p_y} \\rfloor \\}$ 给出。对于任何一个这样的可行 $y_k$，消费者会通过将所有剩余收入分配给商品 $x$ 来最大化效用。此时可以购买的 $x$ 的最大数量为 $x_{max} = \\frac{m - p_y y_k}{p_x}$。这个商品组合 $(x_{max}, y_k)$ 的效用是 $U_k = U(x_{max}, y_k) = \\min(a \\cdot x_{max}, b \\cdot y_k)$。\n\n我们的目标是从可行集中找到能使函数 $U_k$ 最大化的整数 $y_k$。为了指导这一搜索过程，我们考虑一个类似的问题，即假设 $y$ 是一个连续变量。效用函数 $U(y) = \\min(a \\frac{m - p_y y}{p_x}, by)$ 在 $\\min$ 函数的两个参数相等时达到最大值，即 $a \\frac{m - p_y y}{p_x} = by$。求解 $y$ 可得连续最优值 $y_{cont}^* = \\frac{am}{b p_x + a p_y}$。\n\n函数 $g(y) = by$ 是 $y$ 的增函数，而函数 $f(y) = a \\frac{m - p_y y}{p_x}$ 是 $y$ 的减函数。因此，函数 $\\min(f(y), g(y))$ 是拟凹的，在 $y < y_{cont}^*$ 时递增，在 $y > y_{cont}^*$ 时递减。因此，对于整数 $y$ 而言，最大效用必定出现在夹着连续最优解两侧的两个整数之一处：$y_1 = \\lfloor y_{cont}^* \\rfloor$ 或 $y_2 = \\lceil y_{cont}^* \\rceil = y_1 + 1$。\n\n求解算法如下：\n1. 计算连续最优值 $y_{cont}^* = \\frac{am}{b p_x + a p_y}$。\n2. 第一个整数候选值是 $y_1 = \\lfloor y_{cont}^* \\rfloor$。我们计算相应的最大效用 $U_1 = \\min\\left(a \\frac{m - p_y y_1}{p_x}, b y_1\\right)$。\n3. 第二个整数候选值是 $y_2 = y_1 + 1$。我们必须首先通过检查 $p_y y_2 \\le m$ 来验证其可行性。如果可行，我们计算其效用 $U_2 = \\min\\left(a \\frac{m - p_y y_2}{p_x}, b y_2\\right)$。\n4. 然后我们确定最优整数 $y^\\star$ 和最大效用 $U^\\star$。最大效用为 $U^\\star = \\max(U_1, U_2)$（如果 $y_2$ 不可行，则就是 $U_1$）。问题指定了一个平局打破规则：如果多个商品组合产生相同的最大效用，我们必须选择具有最小整数 $y^\\star$ 的那一个。因此：\n    - 如果 $U_2 > U_1$，我们选择 $y^\\star = y_2$ 并且 $U^\\star = U_2$。\n    - 否则（如果 $U_1 \\ge U_2$ 或 $y_2$ 不可行），我们选择 $y^\\star = y_1$ 并且 $U^\\star = U_1$。\n5. 最后，我们必须确定 $x^\\star$ 的值。第二个平局打破规则规定，对于选定的 $y^\\star$，我们必须选择能够达到效用 $U^\\star$ 并满足预算约束的最小非负 $x$。为了达到效用 $U^\\star$，我们需要 $\\min(ax, by^\\star) \\ge U^\\star$。这意味着 $ax \\ge U^\\star$ 且 $by^\\star \\ge U^\\star$。条件 $ax \\ge U^\\star$ 给出 $x \\ge U^\\star/a$。满足此条件的最小非负 $x$ 正是 $x^\\star = U^\\star/a$。根据 $U^\\star$ 的定义，这个 $x^\\star$ 的选择被保证是预算可行的。\n\n这个步骤根据问题的具体要求，提供了唯一的效用最大化商品组合 $(x^\\star, y^\\star)$ 及其相关效用 $U^\\star$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the utility maximization problem for a series of test cases.\n    The utility function is Leontief U(x,y) = min(ax, by), with y being discrete.\n    \"\"\"\n    # Define the test cases from the problem statement as (a, b, p_x, p_y, m).\n    test_cases = [\n        (1.0, 1.0, 2.0, 3.0, 20.0),\n        (2.0, 1.0, 3.0, 5.0, 11.0),\n        (1.5, 2.0, 1.0, 10.0, 7.0),\n        (2.0, 1.0, 3.0, 4.0, 9.5),\n        (3.0, 5.0, 2.0, 7.0, 100.0),\n    ]\n\n    results_as_strings = []\n    for a, b, px, py, m in test_cases:\n        # Handle the trivial case of zero income.\n        if m <= 0:\n            x_star, y_star, U_star = 0.0, 0, 0.0\n        else:\n            # Calculate the optimal 'y' as if it were a continuous variable.\n            # This is the point where the two components of the utility function,\n            # scaled by the budget, would be equal.\n            # y_cont_star = (a * m) / (b * p_x + a * p_y)\n            y_cont_star = (a * m) / (b * px + a * py)\n            \n            # The optimal integer y must be one of the two integers surrounding y_cont_star.\n            # Candidate 1: floor(y_cont_star)\n            y1 = int(np.floor(y_cont_star))\n            \n            # Calculate the maximum utility achievable with y1.\n            # This assumes all remaining budget is spent on x.\n            xmax1 = (m - py * y1) / px\n            U1 = min(a * xmax1, b * y1)\n            \n            # Initialize the optimal choice with the results from y1.\n            y_star = y1\n            U_star = U1\n            \n            # Candidate 2: ceil(y_cont_star) = y1 + 1\n            y2 = y1 + 1\n            \n            # Check if y2 is affordable within the budget.\n            if py * y2 <= m:\n                # If affordable, calculate its corresponding maximum utility.\n                xmax2 = (m - py * y2) / px\n                U2 = min(a * xmax2, b * y2)\n                \n                # Update the optimal choice if y2 yields a strictly higher utility.\n                # If utilities are equal, the tie-breaking rule requires choosing the\n                # smaller y, which is y1, so we do nothing in case of a tie.\n                if U2 > U1:\n                    y_star = y2\n                    U_star = U2\n            \n            # The final optimal value of x is determined by the utility level U_star.\n            # To get utility U_star, we must have ax >= U_star, so the smallest x is U_star / a.\n            if a > 0:\n                x_star = U_star / a\n            else: # Should not happen based on problem constraints (a>0)\n                x_star = 0.0\n\n        # Format the result triple [x*, y*, U*] as a string.\n        res_str = f\"[{x_star:.6f},{y_star},{U_star:.6f}]\"\n        results_as_strings.append(res_str)\n        \n    # Aggregate all result strings into the final required output format.\n    final_output = f\"[{','.join(results_as_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2384153"}, {"introduction": "想象一下，您预算有限，面前有一系列心仪的商品（如一个视频游戏、一本书、一副新耳机），每件商品都有其价格和能带给您的“幸福度”（即效用）。您对每件商品的决策只有两种：买或不买。这个练习揭示了消费者理论与计算机科学之间深刻而有趣的联系，它将这种不可分商品的离散选择问题构建为经典的 0/1 背包问题。通过这个练习 [@problem_id:2384164]，您不仅能学会如何将一个经济学问题形式化为整数规划，还将掌握解决此类问题的强大算法工具——动态规划，这是一种在各个领域都有着广泛应用的优化技术。", "problem": "给定一个包含不可分商品的离散时间消费者选择问题。消费者面临一组有限的商品，索引为 $i \\in \\{1,\\dots,n\\}$。每种商品可以不购买，也可以购买一个单位。消费者有一个非负、可加可分的效用指数，由向量 $u \\in \\mathbb{R}_{\\ge 0}^{n}$ 表示，其中 $u_i$ 是获得一个单位商品 $i$ 的效用；以及严格非负的价格，由向量 $p \\in \\mathbb{R}_{\\ge 0}^{n}$ 表示，其中 $p_i$ 是一个单位商品 $i$ 的价格。消费者拥有预算 $M \\in \\mathbb{R}_{\\ge 0}$。决策变量为 $x_i \\in \\{0,1\\}$，其中 $i$ 表示商品 $i$ 是否被购买。消费者寻求在预算约束下最大化总效用。\n\n根据基础微观经济学原理，消费者问题是在资源约束下最大化一个效用函数。在商品间效用可加和商品不可分的条件下，这成为一个组合优化问题。你的任务是：\n\n- 从效用最大化和预算集的定义出发，推导出这个离散消费者选择问题的精确数学公式，引入二元决策变量和线性预算约束。使用一个有效的整数规划来表达该问题。\n- 解释该公式如何成为零一背包问题的一个实例，其中效用扮演价值的角色，价格扮演重量的角色，预算则是背包的容量。\n- 设计并实现一个精确算法，将该问题作为整数规划来求解。你必须给出一个总效用的精确最大化器。你可以使用一个有原则的算法，例如带有分数背包上界的分支定界方案，或者一个伪多项式动态规划，确保对所有提供的测试用例都正确。从第一性原理清晰地解释算法逻辑。\n\n你的程序必须实现求解器，并将其应用于以下测试实例集，每个实例由一个效用向量 $u$、一个价格向量 $p$ 和一个预算 $M$ 指定：\n\n- 测试 $1$ (一般情况): $u = [9,6,7,3]$, $p = [4,3,5,2]$, $M = 7$.\n- 测试 $2$ (零预算边界): $u = [5,4]$, $p = [1,2]$, $M = 0$.\n- 测试 $3$ (零价格商品): $u = [4,10,2]$, $p = [0,5,3]$, $M = 5$.\n- 测试 $4$ (单位美元效用相等，但最优总效用唯一): $u = [6,6,5]$, $p = [4,4,5]$, $M = 8$.\n- 测试 $5$ (存在被支配的选项): $u = [8,7,6,9]$, $p = [5,6,4,7], $M = 9$.\n- 测试 $6$ (预算超过总成本，全选): $u = [3,5,2]$, $p = [1,2,1]$, $M = 10$.\n\n为覆盖率设计：\n- 测试 $1$ 是一个标准的非平凡实例。\n- 测试 $2$ 检查 $M = 0$ 的边界情况。\n- 测试 $3$ 检查对零价格商品的处理。\n- 测试 $4$ 检查在效用-价格比率相等但最优总效用唯一的情况下的行为。\n- 测试 $5$ 包含一个被支配的选项以验证正确的剪枝。\n- 测试 $6$ 检查容量占优的状态，此时最优选择是购买所有商品。\n\n假设：\n- 所有效用项均满足 $u_i \\ge 0$。\n- 所有价格均满足 $p_i \\ge 0$，除非另有说明，否则至少有一个 $p_i > 0$。\n- 如果任何 $p_i = 0$ 且 $u_i > 0$，则为此类商品设置 $x_i = 1$ 始终是理性的。\n\n你的程序应为每个测试用例计算可实现的最大总效用，并将其作为一个整数。你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，例如 $[a_1,a_2,\\dots,a_6]$，其中 $a_j$ 是测试 $j$ 的最大总效用，顺序如上。不涉及物理单位或角度单位。将每个数字表示为整数。此问题中不使用任何百分比。", "solution": "在可加可分效用函数和预算约束下的离散消费者选择问题是微观经济学理论中的一个经典模型，也是组合优化中的一个基本问题。我们将首先验证问题陈述，然后推导其数学公式，将其与一个已知问题结构联系起来，最后设计并实现一个正确且精确的算法。\n\n**问题公式化**\n\n消费者的目标是在预算约束下最大化从一组商品中获得的总效用。设商品集由 $i \\in \\{1, \\dots, n\\}$ 索引。对于每种商品 $i$，消费者做出一个二元决策，由变量 $x_i$ 表示，其中如果购买该商品，则 $x_i = 1$，如果不购买，则 $x_i = 0$。\n效用是可加可分的，这意味着总效用是所购买单个商品效用的总和。给定一个效用向量 $u = (u_1, u_2, \\dots, u_n)$，总效用表示为线性函数：\n$$\nU(x) = \\sum_{i=1}^{n} u_i x_i\n$$\n消费者面临预算约束。给定一个价格向量 $p = (p_1, p_2, \\dots, p_n)$ 和总预算 $M$，总支出不得超过预算。这表示为线性不等式：\n$$\n\\sum_{i=1}^{n} p_i x_i \\le M\n$$\n结合目标函数、预算约束和决策变量的二元性质，我们得到以下整数线性规划（ILP）公式：\n$$\n\\begin{aligned}\n\\text{maximize} \\quad & \\sum_{i=1}^{n} u_i x_i \\\\\n\\text{subject to} \\quad & \\sum_{i=1}^{n} p_i x_i \\le M \\\\\n& x_i \\in \\{0, 1\\}, \\quad \\forall i \\in \\{1, \\dots, n\\}\n\\end{aligned}\n$$\n此公式精确地描述了消费者的优化问题。所有参数（$u_i$、$p_i$、$M$）均为给定的非负实数。\n\n**与 0-1 背包问题的关系**\n\n推导出的整数线性规划在结构上与典型的 0-1 背包问题相同。0-1 背包问题是一个组合优化问题，其定义如下：给定一组物品，每个物品都有一个价值和一个重量，确定要包含在一个集合（“背包”）中的物品子集，以使总价值最大化，同时受总重量不超过给定容量的约束。\n\n其形式上的对应关系直接而明确：\n-   消费者的商品对应于背包问题中的*物品*。\n-   商品 $i$ 的效用 $u_i$ 对应于物品 $i$ 的*价值*。\n-   商品 $i$ 的价格 $p_i$ 对应于物品 $i$ 的*重量*。\n-   消费者的预算 $M$ 对应于背包的*容量*。\n-   决策变量 $x_i$（购买或不购买）等同于是否将物品放入背包的决策。\n\n因此，解决消费者的效用最大化问题等同于解决一个 0-1 背包问题的实例。已知该问题是 NP-难的，这意味着没有已知的算法可以在关于物品数量和输入表示所需比特数的多项式时间内解决它。然而，它可以通过动态规划得到一个伪多项式时间解。\n\n**算法设计：动态规划**\n\n我们将构建一个动态规划算法来寻找精确的最优效用。该算法依赖于最优性原理：问题的最优解可以由其子问题的最优解构造而成。\n\n首先，我们处理零价格商品的特殊情况。根据问题的假设，如果一个商品 $i$ 的价格 $p_i=0$ 且效用 $u_i > 0$，那么获取它始终是最优的，因为它在不消耗预算的情况下提供正效用。因此，我们可以预处理商品列表。我们将所有这些零价格商品的效用相加，建立一个 `base_utility`，然后使用原始预算 $M$ 解决剩余商品（价格为正）的问题。\n\n令剩余的商品（价格 $p_i>0$）从 $1$ 到 $n'$ 索引。子问题定义为使用前 $i$ 个商品（$1 \\le i \\le n'$）的子集，在预算为 $w$（$0 \\le w \\le M$）的情况下可获得的最大效用。令 $dp[i][w]$ 表示此解的值。\n\n递推关系是通过考虑第 $i$ 个商品（效用 $u_i$，价格 $p_i$）推导出来的：\n1.  **不包含商品 $i$**：最大效用与用前 $i-1$ 个商品和预算 $w$ 可达到的效用相同。此值为 $dp[i-1][w]$。\n2.  **包含商品 $i$**：仅当其价格 $p_i$ 不超过当前预算 $w$ 时才可能。如果包含，它为效用贡献 $u_i$，剩余的预算 $w - p_i$ 可用于前 $i-1$ 个商品的最优配置。此情况下的总效用为 $u_i + dp[i-1][w-p_i]$。\n\n最优选择是这两个选项中的最大值。因此，递推关系为：\n$$\ndp[i][w] = \\begin{cases}\ndp[i-1][w] & \\text{if } p_i > w \\\\\n\\max(dp[i-1][w], u_i + dp[i-1][w-p_i]) & \\text{if } p_i \\le w\n\\end{cases}\n$$\n基本情况是对于所有 $w$，$dp[0][w] = 0$，因为从零个商品中无法获得效用。\n\n这个二维动态规划公式的时间复杂度为 $O(n'M)$，空间复杂度为 $O(n'M)$。通过观察到第 $i$ 行的计算仅依赖于第 $i-1$ 行，可以把空间复杂度优化到 $O(M)$。通过使用一个一维数组 `dp[w]` 并将预算 `w` 从 $M$ 向下迭代到 $p_i$，我们防止了在同一个商品处理步骤中多次使用商品 $i$ 的信息。对于一个大小为 $M+1$ 的一维数组 `dp`，优化后的递推关系是：\n\n对于每个商品 $i$ 从 $1$ 到 $n'$：\n对于每个预算 $w$ 从 $M$ 向下到 $p_i$：\n$$\ndp[w] = \\max(dp[w], u_i + dp[w-p_i])\n$$\n子问题的最终解是 $dp[M]$。最大总效用是此值加上零价格商品的 `base_utility`。由于问题的测试用例涉及整数价格和预算，因此这种动态规划方法适用且高效。实现将遵循这种空间优化的方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the discrete consumer choice problem for a suite of test cases.\n    This problem is equivalent to the 0-1 knapsack problem.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1 (general case)\n        {'u': [9, 6, 7, 3], 'p': [4, 3, 5, 2], 'M': 7},\n        # Test 2 (zero budget boundary)\n        {'u': [5, 4], 'p': [1, 2], 'M': 0},\n        # Test 3 (zero-price item)\n        {'u': [4, 10, 2], 'p': [0, 5, 3], 'M': 5},\n        # Test 4 (tie in per-dollar utilities, unique optimal utility)\n        {'u': [6, 6, 5], 'p': [4, 4, 5], 'M': 8},\n        # Test 5 (dominated item present)\n        {'u': [8, 7, 6, 9], 'p': [5, 6, 4, 7], 'M': 9},\n        # Test 6 (budget exceeds total cost, take all)\n        {'u': [3, 5, 2], 'p': [1, 2, 1], 'M': 10},\n    ]\n\n    results = []\n    for case in test_cases:\n        utilities = case['u']\n        prices = case['p']\n        budget = case['M']\n        \n        n = len(utilities)\n        base_utility = 0\n        \n        # Preprocessing step for zero-price items\n        positive_price_items = []\n        for i in range(n):\n            if prices[i] == 0:\n                if utilities[i] > 0:\n                    base_utility += utilities[i]\n            else:\n                # We only consider items that could potentially fit in the budget\n                if prices[i] <= budget:\n                    positive_price_items.append({'u': utilities[i], 'p': prices[i]})\n\n        # If budget is 0, no items with positive price can be bought.\n        if budget == 0:\n            results.append(base_utility)\n            continue\n\n        # Dynamic Programming solution for the 0-1 Knapsack problem\n        # dp[w] stores the maximum utility for a budget of w.\n        # The budget is treated as an integer quantity.\n        dp = np.zeros(budget + 1, dtype=int)\n        \n        for item in positive_price_items:\n            utility = item['u']\n            price = item['p']\n            # Iterate backwards to use each item at most once\n            for w in range(budget, price - 1, -1):\n                dp[w] = max(dp[w], utility + dp[w - price])\n                \n        max_utility = dp[budget] + base_utility\n        results.append(int(max_utility))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2384164"}]}