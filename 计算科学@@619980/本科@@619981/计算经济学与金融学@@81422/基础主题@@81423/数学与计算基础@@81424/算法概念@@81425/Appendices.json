{"hands_on_practices": [{"introduction": "经济学中的许多决策，无论看似多么复杂，其核心都可以归结为一个计算过程。本练习将一个典型的风险决策问题——白领犯罪的权衡——转化为一个清晰的算法。通过将收益、成本和被捕概率作为输入，我们可以得出一个精确的决策阈值，这展示了将经济理论形式化为可计算模型的强大能力。这个练习将帮助你掌握将经济学原理转化为算法的第一步 [@problem_id:2438853]。", "problem": "在一个与计算经济学和金融学相关的简单微观经济决策模型中，考虑一个风险中性的代理人，他正在考虑是否实施一项白领违规行为。该行为若未被发现则会带来货币收益，若被发现则会受到货币惩罚。设决策算法的输入为三元组 $\\left(p, V, C\\right)$，其中 $p \\in [0,1]$ 是被发现的概率，$V>0$ 是仅在未被发现时实现的收益，$C>0$ 是仅在被发现时产生的惩罚。如果代理人不实施该行为，货币回报为 $0$。如果代理人实施该行为，则有 $1-p$ 的概率货币回报为 $V$，有 $p$ 的概率货币回报为 $-C$。该代理人是风险中性的，并以最大化期望货币回报为目标。\n\n将代理人的决策建模为一个确定性算法 $f$，该算法将输入 $\\left(p, V, C\\right)$ 映射为一个二元行动 $f\\left(p,V,C\\right) \\in \\{0,1\\}$，其中 $f\\left(p,V,C\\right)=1$ 表示选择实施，而 $f\\left(p,V,C\\right)=0$ 表示放弃。通过实施与放弃之间的无差异条件来定义算法决策边界，并推导最大侦测概率 $p^{\\ast}$（仅作为 $V$ 和 $C$ 的函数）的闭式表达式，使得 $f\\left(p,V,C\\right)=1$ 当且仅当 $p < p^{\\ast}$。\n\n以 $V$ 和 $C$ 的单个解析闭式表达式的形式提供您的最终答案。无需数值近似或四舍五入。", "solution": "问题要求将一个决策问题表示为一个算法，并根据一个阈值概率 $p^{\\ast}$ 来刻画决策边界，该阈值依赖于 $V$ 和 $C$。基本原则是在风险中性条件下的期望回报最大化。\n\n设实施行为的期望回报表示为 $\\mathbb{E}\\left[\\Pi_{\\text{commit}}\\right]$，放弃行为的期望回报表示为 $\\mathbb{E}\\left[\\Pi_{\\text{abstain}}\\right]$。根据设定，放弃行为的回报为 $0$，因此\n$$\n\\mathbb{E}\\left[\\Pi_{\\text{abstain}}\\right] = 0.\n$$\n如果代理人实施该行为，则有 $1-p$ 的概率回报为 $V$，有 $p$ 的概率回报为 $-C$。因此，根据全期望定律，\n$$\n\\mathbb{E}\\left[\\Pi_{\\text{commit}}\\right] = (1-p)\\cdot V + p \\cdot (-C) = V - p\\left(V + C\\right).\n$$\n\n如果实施行为的期望回报至少与放弃行为的期望回报相等，则算法 $f\\left(p,V,C\\right)$ 返回 $1$（实施），否则返回 $0$（放弃）。因此，定义两个行动之间边界的无差异条件是\n$$\n\\mathbb{E}\\left[\\Pi_{\\text{commit}}\\right] = \\mathbb{E}\\left[\\Pi_{\\text{abstain}}\\right].\n$$\n代入以上表达式可得\n$$\nV - p\\left(V + C\\right) = 0.\n$$\n对 $p$ 求解，得到阈值侦测概率 $p^{\\ast}$：\n$$\np^{\\ast} = \\frac{V}{V + C}.\n$$\n\n那么，算法决策规则可以表述为：对于给定的输入 $\\left(p,V,C\\right)$，其中 $V>0$ 且 $C>0$，当且仅当 $p < p^{\\ast}$ 时选择实施，其中 $p^{\\ast}$ 是使代理人处于无差异状态的最大侦测概率。所要求的 $p^{\\ast}$ 关于 $V$ 和 $C$ 的闭式表达式为\n$$\np^{\\ast} = \\frac{V}{V + C}.\n$$", "answer": "$$\\boxed{\\frac{V}{V+C}}$$", "id": "2438853"}, {"introduction": "现实世界中的经济选择往往涉及在多个相互冲突的目标之间进行权衡，例如在购物时平衡成本、营养和个人偏好。本练习要求你设计并实现一个算法，来解决这个多目标优化问题。你将学习如何通过系统化的步骤——从筛选可行方案到识别“帕累托最优”集，再到运用加权评分进行最终抉择——来为复杂的消费者选择问题构建一个确定性的计算模型 [@problem_id:2438877]。", "problem": "您的任务是在计算经济学和金融背景下，通过将一个程式化的消费者多属性选择建模为一个多目标优化问题来形式化算法的概念，然后实现一个确定性算法来精确求解小规模实例。消费者考虑超市中的商品，每种商品都有一个属性向量 $[成本,\\, 营养,\\, 偏好]$。消费者选择一个由二元决策向量 $x \\in \\{0,1\\}^n$ 表示的购物篮，并受到预算约束。\n\n建模基本依据：\n1. 预算约束下的理性选择：一个购物篮 $x$ 是可行的，当且仅当 $\\sum_{i=1}^n p_i x_i \\le B$，其中 $p_i$ 是商品 $i$ 的成本，$B$ 是预算。\n2. 多目标优化与Pareto支配：定义目标向量 $f(x) = [成本(x),\\, -营养(x),\\, -偏好(x)]$，使得所有分量都最小化。一个可行购物篮 $x$ 被另一个可行购物篮 $y$ Pareto支配，当且仅当逐分量满足 $f(y) \\le f(x)$ 且至少存在一个严格不等式。一个可行购物篮是Pareto有效的（非支配的），当且仅当没有其他可行购物篮能对其构成Pareto支配。\n3. 标量化（加权和）作为算法选择规则：一旦获得Pareto有效集，通过最大化经过尺度归一化的属性得分的加权和来挑选单个购物篮。\n\n需要实现的算法规范：\n给定一个测试用例，包含：\n- 一个商品列表，其属性为 $(p_i,\\, n_i,\\, s_i)$，其中 $i = 1,\\dots,n$，\n- 一个预算 $B$，\n- 一个非负权重向量 $w = (w_1,w_2,w_3)$，其中 $w_1 + w_2 + w_3 = 1$，分别对应于对可负担性、营养和偏好的重视程度，\n\n您的算法必须确定性地执行以下步骤：\n1. 枚举所有满足 $\\sum_{i=1}^n p_i x_i \\le B$ 的购物篮 $x \\in \\{0,1\\}^n$，生成可行集 $\\mathcal{F}$。\n2. 计算关于最小化 $[成本(x),\\, -营养(x),\\, -偏好(x)]$ 的Pareto有效子集 $\\mathcal{P} \\subseteq \\mathcal{F}$。\n3. 对每个可行购物篮 $x \\in \\mathcal{F}$，定义效益向量 $g(x) = [-成本(x),\\, 营养(x),\\, 偏好(x)]$。对每个分量 $j \\in \\{1,2,3\\}$，计算 $m_j = \\min_{x \\in \\mathcal{F}} g_j(x)$ 和 $M_j = \\max_{x \\in \\mathcal{F}} g_j(x)$。定义归一化得分\n$$\nz_j(x) = \n\\begin{cases}\n0 & \\text{如果 } M_j = m_j, \\\\\n\\dfrac{g_j(x) - m_j}{M_j - m_j} & \\text{其他情况}.\n\\end{cases}\n$$\n然后计算加权和\n$$\nW(x) = w_1 z_1(x) + w_2 z_2(x) + w_3 z_3(x).\n$$\n4. 选择Pareto有效集 $\\mathcal{P}$ 中使 $W(x)$ 最大化的唯一购物篮 $\\hat{x}$。为保证唯一的确定性结果，当 $|W(x) - W(y)| \\le \\varepsilon$（其中 $\\varepsilon = 10^{-9}$）时，应用以下严格的平局打破规则：在得分相同的购物篮中，选择 $成本(x)$ 最小的；若仍平局，选择 $营养(x)$ 最大的；若仍平局，选择 $偏好(x)$ 最大的；若仍平局，选择所选商品索引排序列表字典序最小的那个。\n\n您的程序必须实现此算法，并为下述每个测试用例生成所选的购物篮。购物篮由其中包含的商品索引的排序列表表示，使用从零开始的索引，即商品索引为 $0,1,\\dots,n-1$。如果所选购物篮为空，则为该测试用例输出一个空列表 $[]$。\n\n角度单位不适用。不使用物理单位；所有数值均为无量纲数。\n\n测试套件：\n您的程序需要解决以下五个测试用例。对于每个用例，输入包括商品属性列表 $[p_i, n_i, s_i]$、预算 $B$ 和权重向量 $w = [w_1,w_2,w_3]$。\n\n- 测试用例 $1$：\n  - 商品: $[[3.5, 6, 7], [2.0, 4, 5], [5.0, 9, 6], [4.0, 5, 8], [1.5, 3, 3]]$。\n  - 预算: $B = 10.0$。\n  - 权重: $w = [0.4, 0.4, 0.2]$。\n- 测试用例 $2$：\n  - 商品: $[[1.0, 2, 2], [1.0, 2, 2], [2.0, 3, 5]]$。\n  - 预算: $B = 2.0$。\n  - 权重: $w = [0.2, 0.3, 0.5]$。\n- 测试用例 $3$：\n  - 商品: $[[2.0, 10, 0], [3.0, 0, 10]]$。\n  - 预算: $B = 0.0$。\n  - 权重: $w = [1/3, 1/3, 1/3]$。\n- 测试用例 $4$：\n  - 商品: $[[1.0, 1, 1], [2.0, 2, 2], [3.0, 3, 2], [4.0, 4, 5]]$。\n  - 预算: $B = 10.0$。\n  - 权重: $w = [0.1, 0.3, 0.6]$。\n- 测试用例 $5$ （用于测试确定性平局打破规则的明确平局情况）：\n  - 商品: $[[1.0, 1, 0], [1.0, 0, 1]]$。\n  - 预算: $B = 1.0$。\n  - 权重: $w = [0.0, 0.5, 0.5]$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表，列表的每个元素是对应测试用例的所选商品索引的排序列表。例如，一个包含三个测试用例的输出可能看起来像 $[[0,2],[1],[]]$。\n\n您的任务：编写一个完整、可运行的程序，为所提供的测试套件精确实现上述算法，并以指定的精确格式打印单行结果。", "solution": "该问题陈述经过严格验证，并被确定为有效。它在科学上基于微观经济学理论和多目标优化的既定原则，问题设定良好，具有完整且一致的定义和约束，并以客观、形式化的语言表述。算法任务明确，确保可以为给定的测试用例计算出唯一的、确定性的解。因此，我们可以着手推导和实现解决方案。\n\n该问题要求实现一个确定性算法来模拟消费者的多属性选择。这被形式化为一个多目标优化问题，通过首先识别Pareto有效解集，然后使用标量化的加权和方法选择单个最优购物篮来解决。该算法必须是精确的，并将依赖于穷举枚举，考虑到所提供测试用例中商品集的规模较小，这在计算上是可行的。\n\n方法步骤执行如下：\n\n1.  **生成可行集**：\n    对于一个给定的 $n$ 个商品的集合，存在 $2^n$ 种可能的购物篮。一个购物篮由一个二元决策向量 $x \\in \\{0, 1\\}^n$ 表示，其中如果商品 $i$ 被包含在内，则 $x_i=1$，否则 $x_i=0$。对于每种可能的购物篮，其总成本计算为 $cost(x) = \\sum_{i=1}^n p_i x_i$。如果一个购物篮的成本不超过预算 $B$，则它被认为是可行的。所有此类可行购物篮的集合表示为 $\\mathcal{F}$。\n    $$ \\mathcal{F} = \\left\\{ x \\in \\{0,1\\}^n \\mid \\sum_{i=1}^n p_i x_i \\le B \\right\\} $$\n    计算并存储每个购物篮 $x$ 的属性，即总成本 $cost(x)$、总营养 $nutrition(x) = \\sum_{i=1}^n n_i x_i$ 和总偏好 $preference(x) = \\sum_{i=1}^n s_i x_i$。\n\n2.  **识别Pareto有效集**：\n    优化是相对于目标向量 $f(x) = [cost(x), -nutrition(x), -preference(x)]$进行的，其中所有分量都将被最小化。一个可行购物篮 $x \\in \\mathcal{F}$被另一个可行购物篮 $y \\in \\mathcal{F}$ Pareto支配，如果 $f(y)$ 在所有目标上均优于或等于 $f(x)$，并且至少在一个目标上严格优于 $f(x)$。形式上，$y$ 支配 $x$ 当且仅当对于所有 $j \\in \\{1, 2, 3\\}$ 都有 $f_j(y) \\le f_j(x)$，且 $f(y) \\ne f(x)$。\n    Pareto有效集 $\\mathcal{P}$ 由所有不被任何其他可行购物篮Pareto支配的可行购物篮组成。\n    $$ \\mathcal{P} = \\{x \\in \\mathcal{F} \\mid \\nexists y \\in \\mathcal{F} \\text{ such that } y \\text{ Pareto-dominates } x\\} $$\n    该集合通过遍历 $\\mathcal{F}$ 中的所有购物篮对，并剔除任何被发现受支配的购物篮来构建。\n\n3.  **标量化与评分**：\n    为了从Pareto有效集 $\\mathcal{P}$ 中选择单个购物篮，应用了加权和方法。首先，为每个可行购物篮 $x \\in \\mathcal{F}$ 定义一个效益向量 $g(x) = [-cost(x), nutrition(x), preference(x)]$。然后，该向量的分量被归一化到一个共同的尺度，通常是 $[0, 1]$。对于每个分量 $j \\in \\{1, 2, 3\\}$，在整个可行集 $\\mathcal{F}$ 上找到最小值 $m_j$ 和最大值 $M_j$：\n    $$ m_j = \\min_{x \\in \\mathcal{F}} g_j(x), \\quad M_j = \\max_{x \\in \\mathcal{F}} g_j(x) $$\n    分量 $j$ 对购物篮 $x$ 的归一化得分为：\n    $$ z_j(x) = \\begin{cases} 0 & \\text{if } M_j = m_j \\\\ \\frac{g_j(x) - m_j}{M_j - m_j} & \\text{otherwise} \\end{cases} $$\n    使用提供的权重 $w = (w_1, w_2, w_3)$ 为每个购物篮计算最终的标量得分 $W(x)$：\n    $$ W(x) = \\sum_{j=1}^3 w_j z_j(x) $$\n\n4.  **选择最优购物篮**：\n    最后一步是从Pareto有效集 $\\mathcal{P}$ 中选择使加权得分 $W(x)$ 最大化的单个购物篮 $\\hat{x}$。为确保唯一且确定性的结果，应用了严格的平局打破规则。首先，形成一个候选集，该集合包含 $\\mathcal{P}$ 中所有加权得分与在 $\\mathcal{P}$ 中找到的最大得分之差在容差 $\\varepsilon = 10^{-9}$ 以内的购物篮。如果该集合包含多个购物篮，则通过选择具有以下特征的购物篮来解决平局：\n    1.  最小的 $cost(x)$。\n    2.  若平局持续，则选择最大的 $nutrition(x)$。\n    3.  若平局持续，则选择最大的 $preference(x)$。\n    4.  若平局仍然持续，则选择其已排序的商品索引列表在字典序上最小的购物篮。\n\n这个完整、确定性的程序保证了对于任何有效输入，都能选出满足问题所有约束的单个、唯一定义的最优购物篮。实现将忠实地执行这些步骤。", "answer": "```python\nimport numpy as np\nimport math\n\nclass Basket:\n    \"\"\"A class to represent a basket of items and its attributes.\"\"\"\n    def __init__(self, indices, cost, nutrition, preference):\n        self.indices = tuple(sorted(indices))\n        self.cost = cost\n        self.nutrition = nutrition\n        self.preference = preference\n        self.score = 0.0\n\n    def __repr__(self):\n        return f\"Basket(indices={self.indices}, cost={self.cost}, nutr={self.nutrition}, pref={self.preference})\"\n\ndef solve_case(items_list, budget, weights):\n    \"\"\"\n    Solves a single test case according to the problem specification.\n    \"\"\"\n    items = np.array(items_list)\n    n = items.shape[0]\n\n    # Step 1: Enumerate all feasible baskets\n    feasible_baskets = []\n    for i in range(2**n):\n        indices = [j for j in range(n) if (i >> j) & 1]\n        \n        if not indices:\n            basket_attrs = np.zeros(3)\n        else:\n            basket_attrs = items[indices, :].sum(axis=0)\n\n        cost, nutrition, preference = basket_attrs[0], basket_attrs[1], basket_attrs[2]\n\n        if cost <= budget:\n            feasible_baskets.append(Basket(indices, cost, nutrition, preference))\n\n    if not feasible_baskets:\n        return []\n\n    # Step 2: Compute the Pareto-efficient subset\n    pareto_set = []\n    for b1 in feasible_baskets:\n        is_dominated = False\n        f1 = np.array([b1.cost, -b1.nutrition, -b1.preference])\n        for b2 in feasible_baskets:\n            if b1 is b2:\n                continue\n            f2 = np.array([b2.cost, -b2.nutrition, -b2.preference])\n            if np.all(f2 <= f1) and np.any(f2 < f1):\n                is_dominated = True\n                break\n        if not is_dominated:\n            pareto_set.append(b1)\n\n    if not pareto_set:\n        # This case implies an empty feasible set, but with B>=0, the empty basket is always feasible.\n        # If such a case arises, the empty basket is the logical choice.\n        return []\n\n    # Step 3: Compute weighted scores\n    g_vectors = np.array([[-b.cost, b.nutrition, b.preference] for b in feasible_baskets])\n    \n    m = np.min(g_vectors, axis=0) if g_vectors.size > 0 else np.zeros(3)\n    M = np.max(g_vectors, axis=0) if g_vectors.size > 0 else np.zeros(3)\n    \n    deltas = M - m\n    \n    for b in pareto_set:\n        g_b = np.array([-b.cost, b.nutrition, b.preference])\n        z_b = np.zeros(3)\n        for j in range(3):\n            if deltas[j] != 0:\n                z_b[j] = (g_b[j] - m[j]) / deltas[j]\n        \n        b.score = np.dot(weights, z_b)\n\n    # Step 4: Select the single best basket from the Pareto set\n    if not pareto_set: # Should not happen if feasible_baskets is not empty\n        return []\n\n    max_score = -float('inf')\n    for b in pareto_set:\n        if b.score > max_score:\n            max_score = b.score\n            \n    epsilon = 1e-9\n    candidates = [b for b in pareto_set if abs(b.score - max_score) <= epsilon]\n\n    if len(candidates) == 1:\n        return list(candidates[0].indices)\n\n    # Apply tie-breaking rules by sorting\n    candidates.sort(key=lambda b: (b.cost, -b.nutrition, -b.preference, b.indices))\n    \n    return list(candidates[0].indices)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        (\n            [[3.5, 6, 7], [2.0, 4, 5], [5.0, 9, 6], [4.0, 5, 8], [1.5, 3, 3]],\n            10.0,\n            [0.4, 0.4, 0.2]\n        ),\n        (\n            [[1.0, 2, 2], [1.0, 2, 2], [2.0, 3, 5]],\n            2.0,\n            [0.2, 0.3, 0.5]\n        ),\n        (\n            [[2.0, 10, 0], [3.0, 0, 10]],\n            0.0,\n            [1/3, 1/3, 1/3]\n        ),\n        (\n            [[1.0, 1, 1], [2.0, 2, 2], [3.0, 3, 2], [4.0, 4, 5]],\n            10.0,\n            [0.1, 0.3, 0.6]\n        ),\n        (\n            [[1.0, 1, 0], [1.0, 0, 1]],\n            1.0,\n            [0.0, 0.5, 0.5]\n        )\n    ]\n\n    results = []\n    for items, budget, weights in test_cases:\n        result = solve_case(items, budget, weights)\n        results.append(result)\n\n    # Format output as a single string\n    result_str_list = []\n    for res in results:\n        # Custom formatting to avoid spaces after commas in lists\n        result_str_list.append(f\"[{','.join(map(str, res))}]\")\n    \n    final_output = f\"[{','.join(result_str_list)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2438877"}, {"introduction": "算法不仅能解决静态决策，更能为跨期（dynamic）决策提供强大分析工具。本练习探讨了一个经典的资源开采问题，并要求你比较两种截然不同的算法策略：一种是只顾眼前利益的“贪心算法”，另一种是深谋远虑的“最优动态规划”算法。通过亲手实现并比较它们的结果，你将深刻理解短视策略与长远规划之间的差异，并体会动态优化在经济和金融问题中的核心价值 [@problem_id:2438788]。", "problem": "考虑一个受计算经济学和金融学启发的有限期界资源开采问题。一家公司拥有一座包含不可再生资源的矿山。时间是离散的，有 $T$ 个周期，由 $t \\in \\{1,\\dots,T\\}$ 索引。该公司在每个周期选择开采量 $x_t$，该选择受到库存约束和特定周期的运营能力限制。设初始库存为 $S \\ge 0$。设每周期能力上限为 $u_t \\ge 0$。设矿石品位（作为收入的乘法因子）为 $c_t \\ge 0$。设恒定的产出价格为 $p \\ge 0$。设每周期凸性开采成本为参数是 $a > 0$ 的二次形式。设跨期贴现因子为 $\\beta \\in (0,1]$。利润以贴现单位计算。\n\n在周期 $t$ 开采 $x_t$ 的每周期瞬时净收益由以下凹函数给出：\n$$\nb_t(x_t) \\equiv p\\,c_t\\,x_t - \\frac{a}{2}\\,x_t^2,\n$$\n总贴现净现值 (NPV) 为：\n$$\n\\sum_{t=1}^T \\beta^{t-1}\\, b_t(x_t).\n$$\n\n可行性约束为：\n$$\n0 \\le x_t \\le u_t \\quad \\text{for all } t, \\qquad \\sum_{t=1}^T x_t \\le S.\n$$\n\n您的任务是实现并比较两种算法：\n\n- 一种短视的贪婪算法：在每个周期 $t$，它选择 $x_t$ 以最大化当前周期的 $b_t(x_t)$，仅受瞬时约束 $0 \\le x_t \\le \\min\\{u_t, s_t\\}$ 的限制，其中 $s_t$ 是在做出周期 $t$ 决策之前的剩余库存。贪婪算法忽略了除当前库存可行性之外对未来周期的任何影响。选择 $x_t$ 后，通过 $s_{t+1} = s_t - x_t$ 更新剩余库存，其中 $s_1 = S$。\n- 一种基于 Bellman 最优性原理的最优动态规划 (DP) 解，该解在所有约束条件下最大化总贴现 NPV。您可以通过任何等价于求解有限期界 DP 问题的正确算法来计算此最优解。\n\n对于这两种算法，计算贴现 NPV：\n$$\nV \\equiv \\sum_{t=1}^T \\beta^{t-1}\\, \\left(p\\,c_t\\,x_t - \\frac{a}{2}\\,x_t^2\\right).\n$$\n\n实现一个程序，对于以下测试套件，为每个参数集返回一个三元组，该三元组由最优 NPV、贪婪 NPV 和一个相等性指标组成。如果两个 NPV 之间的绝对差值至多为 $10^{-6}$，则该指标定义为 $1$，否则为 $0$。所有浮点数输出必须四舍五入到 6 位小数。\n\n测试套件（每个案例是一个元组 $(T, \\beta, p, a, S, \\mathbf{c}, \\mathbf{u})$，其中 $\\mathbf{c}=(c_1,\\dots,c_T)$ 且 $\\mathbf{u}=(u_1,\\dots,u_T)$）：\n\n- 案例 1：$T=4$, $\\beta=0.95$, $p=2.0$, $a=2.0$, $S=6.0$, $\\mathbf{c}=(1.0, 1.5, 1.2, 1.1)$, $\\mathbf{u}=(5.0, 5.0, 5.0, 5.0)$。\n- 案例 2：$T=3$, $\\beta=0.98$, $p=1.0$, $a=1.0$, $S=3.0$, $\\mathbf{c}=(1.0, 2.0, 5.0)$, $\\mathbf{u}=(10.0, 10.0, 10.0)$。\n- 案例 3：$T=3$, $\\beta=0.5$, $p=1.0$, $a=1.0$, $S=3.0$, $\\mathbf{c}=(5.0, 2.0, 1.0)$, $\\mathbf{u}=(10.0, 10.0, 10.0)$。\n- 案例 4：$T=4$, $\\beta=0.99$, $p=1.0$, $a=1.0$, $S=1.5$, $\\mathbf{c}=(2.0, 2.0, 10.0, 2.0)$, $\\mathbf{u}=(10.0, 10.0, 1.0, 10.0)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按以下顺序跨测试案例展平：对于案例 $i$，依次附加最优 NPV、贪婪 NPV、相等性指标（按此顺序），所有值均按指定要求四舍五入。例如，输出必须如下所示：\n[opt_1, greedy_1, eq_1, opt_2, greedy_2, eq_2, ...]", "solution": "首先，对问题陈述进行严格的验证。\n\n**步骤 1：提取已知条件**\n- **时间范围**：离散， $T$ 个周期， $t \\in \\{1,\\dots,T\\}$。\n- **决策变量**：开采量 $x_t$。\n- **参数**：初始库存 $S \\ge 0$，每周期能力 $u_t \\ge 0$，矿石品位 $c_t \\ge 0$，产出价格 $p \\ge 0$，成本参数 $a > 0$，贴现因子 $\\beta \\in (0,1]$。\n- **目标函数**：最大化总贴现净现值 (NPV)，$V = \\sum_{t=1}^T \\beta^{t-1}\\, b_t(x_t)$，其中每周期净收益为 $b_t(x_t) \\equiv p\\,c_t\\,x_t - \\frac{a}{2}\\,x_t^2$。\n- **约束**：\n    1. 能力约束：对所有 $t$，$0 \\le x_t \\le u_t$。\n    2. 库存约束：$\\sum_{t=1}^T x_t \\le S$。\n- **算法**：\n    1. **贪婪算法**：在每个周期 $t$，选择 $x_t$ 以最大化 $b_t(x_t)$，约束条件为 $0 \\le x_t \\le \\min\\{u_t, s_t\\}$，其中 $s_t$ 是剩余库存。\n    2. **最优算法**：一个动态规划解或等价解，用于在所有约束下最大化总贴现 NPV。\n- **输出要求**：对每个测试案例，提供一个三元组：（最优 NPV，贪婪 NPV，相等性指标）。如果绝对差值 $\\le 10^{-6}$，则指标为 $1$，否则为 $0$。输出必须四舍五入到 6 位小数。已提供测试案例。\n\n**步骤 2：验证**\n- **科学依据**：该问题是一个经典的有限期界资源开采模型，是计算经济学和资源经济学中的一个基础课题。该模型基于已确立的经济学原理。它是有效的。\n- **适定性**：目标函数 $\\sum \\beta^{t-1} (p c_t x_t - \\frac{a}{2} x_t^2)$ 是向量 $\\mathbf{x} = (x_1, \\dots, x_T)$ 的严格凹函数，因为 $a>0$ 且 $\\beta>0$。由线性不等式定义的可行集是凸且紧的。在一个非空、紧、凸集上最大化一个严格凹函数，存在唯一解。该问题是适定的。\n- **客观与完整性**：该问题使用精确的数学语言进行描述，并为给定的测试案例提供了所有必要的数据。它是有效的。\n\n**步骤 3：结论**\n问题是有效的。我们继续进行求解。\n\n该问题要求实现并比较两种用于资源开采问题的算法。\n\n**贪婪算法**\n贪婪算法是短视的。在每个周期 $t$，它仅在当前约束下最大化当期收益 $b_t(x_t) = p c_t x_t - \\frac{a}{2} x_t^2$。函数 $b_t(x_t)$ 是一个开口向下的抛物线。其无约束最大值可以通过将其关于 $x_t$ 的导数设为零来找到：\n$$\n\\frac{d b_t(x_t)}{d x_t} = p c_t - a x_t = 0 \\implies x_t^* = \\frac{p c_t}{a}\n$$\n在周期 $t$，贪婪决策者面临的约束是能力上限 $u_t$ 和剩余库存 $s_t$。因此，选择必须满足 $0 \\le x_t \\le \\min\\{u_t, s_t\\}$。由于 $p, c_t, a$ 是非负的，所以 $x_t^* \\ge 0$。因此，贪婪选择 $x_t^g$ 是无约束最优解 $x_t^*$ 在可行区间上的投影：\n$$\nx_t^g = \\min\\left(\\frac{p c_t}{a}, u_t, s_t\\right)\n$$\n该算法通过从 $t=1$ 到 $T$ 迭代进行，计算 $x_t^g$，并用初始库存 $s_1 = S$ 更新剩余库存 $s_{t+1} = s_t - x_t^g$。然后使用得到的开采路径 $\\{x_t^g\\}_{t=1}^T$ 计算总 NPV。\n\n**最优算法**\n该问题是一个凸优化问题，具体来说是一个二次规划 (QP)，因为目标是二次的，约束是线性的。虽然可以用通用的 QP 求解器求解，但通过分析 Karush-Kuhn-Tucker (KKT) 条件可以得到一种更高效的方法。\n\n该优化问题的拉格朗日函数是：\n$$\n\\mathcal{L}(\\mathbf{x}, \\lambda, \\boldsymbol{\\mu}, \\boldsymbol{\\nu}) = \\sum_{t=1}^T \\beta^{t-1}\\left(p c_t x_t - \\frac{a}{2} x_t^2\\right) - \\lambda\\left(\\sum_{t=1}^T x_t - S\\right) - \\sum_{t=1}^T \\mu_t(x_t - u_t) - \\sum_{t=1}^T \\nu_t(-x_t)\n$$\n其中 $\\lambda \\ge 0$、$\\mu_t \\ge 0$ 和 $\\nu_t \\ge 0$ 分别是总库存、每周期能力上限和每周期非负性约束的拉格朗日乘子。\n\n关于 $x_t$ 的平稳性一阶条件是：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial x_t} = \\beta^{t-1}(p c_t - a x_t) - \\lambda - \\mu_t + \\nu_t = 0\n$$\n互补松弛条件意味着如果 $0 < x_t < u_t$，则 $\\mu_t = \\nu_t = 0$。在这种内部解的情况下，最优开采量 $x_t$ 满足：\n$$\n\\beta^{t-1}(p c_t - a x_t) = \\lambda \\implies p c_t - a x_t = \\lambda \\beta^{-(t-1)} \\implies x_t = \\frac{p c_t - \\lambda \\beta^{-(t-1)}}{a}\n$$\n项 $\\lambda$ 是资源库存 $S$ 的影子价格。该条件表明，在所有开采量为正且不处于边界的周期中，贴现的开采边际利润必须等于这个影子价格。\n考虑到边界条件（$x_t=0$ 或 $x_t=u_t$），对于给定的 $\\lambda$，最优开采量 $x_t^*$ 为：\n$$\nx_t^*(\\lambda) = \\text{max}\\left(0, \\min\\left(\\frac{p c_t - \\lambda \\beta^{-(t-1)}}{a}, u_t\\right)\\right)\n$$\n令 $X(\\lambda) = \\sum_{t=1}^T x_t^*(\\lambda)$。函数 $X(\\lambda)$ 是关于 $\\lambda$ 的一个连续非增函数。$\\lambda$ 的正确值由总库存约束和互补松弛条件 $\\lambda(\\sum_{t=1}^T x_t^* - S) = 0$ 确定。\n\n找到最优路径的算法如下：\n1.  假设库存约束不紧（即不起作用），计算总开采量，这对应于将影子价格 $\\lambda$ 设为 0。令此值为 $X(0) = \\sum_t \\max(0, \\min(\\frac{p c_t}{a}, u_t))$。\n2.  如果 $X(0) \\le S$，则相对于其有利可图的开采机会，资源并不稀缺。最优解在 $\\lambda^*=0$ 时获得，且对所有 $t$，有 $x_t^* = x_t^*(0)$。\n3.  如果 $X(0) > S$，则库存约束是紧的，需要 $\\lambda^* > 0$。我们必须找到满足市场出清条件 $X(\\lambda^*) = S$ 的唯一的 $\\lambda^* > 0$。这是一个针对方程 $g(\\lambda) = X(\\lambda) - S = 0$ 的一维求根问题。可以使用二分法或牛顿族方法（例如，Brent 法）高效地找到 $\\lambda^*$。$\\lambda$ 的搜索区间为 $[0, \\lambda_{max}]$，其中 $\\lambda_{max} = \\max_t(p c_t \\beta^{t-1})$ 是一个确保所有 $x_t=0$ 的上界。\n4.  一旦找到 $\\lambda^*$，就可以确定最优开采路径 $\\{x_t^*(\\lambda^*)\\}_{t=1}^T$，并可以计算最优 NPV。\n\n对于此问题结构，这种基于 KKT 的方法优于通用的 QP 求解器。实现将使用 Brent 法进行求根，因为它既鲁棒又高效。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves a series of finite-horizon resource extraction problems using both a greedy\n    and an optimal algorithm, then compares the results.\n    \"\"\"\n\n    test_cases = [\n        (4, 0.95, 2.0, 2.0, 6.0, np.array([1.0, 1.5, 1.2, 1.1]), np.array([5.0, 5.0, 5.0, 5.0])),\n        (3, 0.98, 1.0, 1.0, 3.0, np.array([1.0, 2.0, 5.0]), np.array([10.0, 10.0, 10.0])),\n        (3, 0.5, 1.0, 1.0, 3.0, np.array([5.0, 2.0, 1.0]), np.array([10.0, 10.0, 10.0])),\n        (4, 0.99, 1.0, 1.0, 1.5, np.array([2.0, 2.0, 10.0, 2.0]), np.array([10.0, 10.0, 1.0, 10.0])),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        T, beta, p, a, S, c, u = case\n        \n        # --- Greedy Algorithm ---\n        x_g = np.zeros(T)\n        s_rem = S\n        for t in range(T):\n            x_unconstrained = p * c[t] / a\n            x_g[t] = np.clip(x_unconstrained, 0, min(u[t], s_rem))\n            s_rem -= x_g[t]\n\n        # --- Optimal Algorithm ---\n        betas = beta ** np.arange(T)\n        \n        def get_x_opt(lam, T, p, a, beta, c, u):\n            \"\"\"Computes optimal extraction path for a given lambda.\"\"\"\n            beta_inv_powers = beta ** (-np.arange(T))\n            numerators = p * c - lam * beta_inv_powers\n            x_unbounded = numerators / a\n            return np.clip(x_unbounded, 0, u)\n\n        # Check if resource constraint is binding\n        x_opt_lam0 = get_x_opt(0, T, p, a, beta, c, u)\n        \n        if np.sum(x_opt_lam0) <= S:\n            lam_opt = 0.0\n            x_opt = x_opt_lam0\n        else:\n            # Resource constraint is binding, find lambda > 0\n            # Define the function whose root we want to find\n            def total_extraction_diff(lam):\n                return np.sum(get_x_opt(lam, T, p, a, beta, c, u)) - S\n            \n            # Find a safe upper bound for lambda search\n            # Any lambda larger than this will result in all xt <= 0\n            lam_upper_bound = np.max(p * c * (beta ** np.arange(T))) + 1.0\n\n            try:\n                lam_opt = brentq(total_extraction_diff, 0, lam_upper_bound, xtol=1e-12, rtol=1e-12)\n            except ValueError:\n                # Fallback if signs are not different, though theoretically they should be\n                lam_opt = 0.0 # Should not happen with this problem structure\n            \n            x_opt = get_x_opt(lam_opt, T, p, a, beta, c, u)\n\n        # --- NPV Calculation ---\n        def calculate_npv(x_path, T, beta, p, c, a):\n            npv = 0.0\n            for t in range(T):\n                benefit = p * c[t] * x_path[t] - (a / 2) * x_path[t]**2\n                npv += (beta**t) * benefit\n            return npv\n\n        greedy_npv = calculate_npv(x_g, T, beta, p, c, a)\n        optimal_npv = calculate_npv(x_opt, T, beta, p, c, a)\n\n        # --- Formatting and Appending Results ---\n        optimal_npv_rounded = round(optimal_npv, 6)\n        greedy_npv_rounded = round(greedy_npv, 6)\n        \n        eq_indicator = 1 if abs(optimal_npv - greedy_npv) <= 1e-6 else 0\n        \n        results.extend([f\"{optimal_npv_rounded:.6f}\", f\"{greedy_npv_rounded:.6f}\", eq_indicator])\n\n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2438788"}]}