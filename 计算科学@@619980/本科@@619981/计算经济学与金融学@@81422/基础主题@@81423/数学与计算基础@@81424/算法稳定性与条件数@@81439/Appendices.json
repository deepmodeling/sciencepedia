{"hands_on_practices": [{"introduction": "在计算金融中，求解线性方程组是一项基本任务。然而，一个问题的“良态”（well-conditioned）特性，即其解对输入数据的微小变化不敏感，并不足以保证我们能得到准确的答案。这个实践练习 [@problem_id:2370924] 将通过一个精心设计的例子，揭示算法本身稳定性是多么关键：我们将看到，一个看似微不足道的算法细节——是否使用“部分枢轴选择”（partial pivoting）——是如何成为获得精确解与得到完全错误结果的分水岭。", "problem": "考虑一个线性方程组，它编码了一个带有小比例扭曲的有摩擦市场中，两个合成投资组合之间的成对无套利平衡。设未知向量为 $x \\in \\mathbb{R}^{2}$，对于给定的参数 $\\varepsilon \\in (0,1)$，定义系数矩阵和右端项如下：\n$$\nA(\\varepsilon) \\equiv \\begin{bmatrix}\n\\varepsilon & 1 \\\\\n1 & 1\n\\end{bmatrix}, \\qquad \nb \\equiv \\begin{bmatrix}\n1 \\\\\n2\n\\end{bmatrix}.\n$$\n该系统可以被解释为一组线性化的无套利一致性方程，它连接了两种复制策略，其中小摩擦参数 $\\varepsilon$ 仅出现在第一个方程中。这些方程是无量纲的，不需要物理单位。\n\n定义关于欧几里得范数的谱条件数如下：\n$$\n\\kappa_{2}\\!\\left(A(\\varepsilon)\\right) \\equiv \\|A(\\varepsilon)\\|_{2}\\,\\|A(\\varepsilon)^{-1}\\|_{2}.\n$$\n\n定义解 $x$ 的两个计算近似值如下：\n1. $x_{\\mathrm{np}}(\\varepsilon)$ 是通过三角分解求解 $A(\\varepsilon)\\,x=b$ 得到的结果，该分解在每一步都保持行序固定（无行交换）。\n2. $x_{\\mathrm{pp}}(\\varepsilon)$ 是通过三角分解求解 $A(\\varepsilon)\\,x=b$ 得到的结果，该分解在每个消元步骤中，会对活动子矩阵内的行进行重排，以使当前列的主元具有最大绝对值（允许在列内进行行交换）。\n\n设精确解记为 $x^{\\star}(\\varepsilon)$，并定义任意近似值 $y \\in \\mathbb{R}^{2}$ 的相对误差如下：\n$$\n\\mathcal{E}(y;\\varepsilon) \\equiv \\frac{\\|y - x^{\\star}(\\varepsilon)\\|_{2}}{\\|x^{\\star}(\\varepsilon)\\|_{2}}.\n$$\n\n你的程序必须对每个指定的测试用例值 $\\varepsilon$ 计算以下三元组：\n$$\n\\left(\\kappa_{2}\\!\\left(A(\\varepsilon)\\right), \\ \\mathcal{E}\\!\\left(x_{\\mathrm{np}}(\\varepsilon);\\varepsilon\\right), \\ \\mathcal{E}\\!\\left(x_{\\mathrm{pp}}(\\varepsilon);\\varepsilon\\right)\\right),\n$$\n然后评估布尔值：\n$$\nS(\\varepsilon) \\equiv \\Big(\\kappa_{2}\\!\\left(A(\\varepsilon)\\right) \\leq 10\\Big) \\ \\wedge \\ \\Big(\\mathcal{E}\\!\\left(x_{\\mathrm{np}}(\\varepsilon);\\varepsilon\\right) \\geq 10^{-3}\\Big) \\ \\wedge \\ \\Big(\\mathcal{E}\\!\\left(x_{\\mathrm{pp}}(\\varepsilon);\\varepsilon\\right) \\leq 10^{-12}\\Big).\n$$\n其预期的解释是，$S(\\varepsilon)$ 为真，当且仅当系统是良态的，同时固定行序的消元法产生较大的前向误差，而进行行交换的消元法仍保持高精度。\n\n测试套件：\n- $\\varepsilon = 10^{-16}$\n- $\\varepsilon = 10^{-12}$\n- $\\varepsilon = 10^{-8}$\n- $\\varepsilon = 10^{-4}$\n- $\\varepsilon = 10^{-1}$\n\n答案规格：\n- 对于按上述顺序列出的每个测试用例，计算所定义的 $S(\\varepsilon)$。\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[r_{1},r_{2},r_{3},r_{4},r_{5}]$，其中每个 $r_{i}$ 是与第 $i$ 个测试用例的 $S(\\varepsilon)$ 相对应的字面标记 True 或 False。\n\n所有计算都必须使用标准双精度浮点算术进行。此任务不涉及角度和物理单位，也不需要百分比；任何比率都应以纯小数形式报告。", "solution": "提交分析的问题陈述被认为是有效的。这是一个数值线性代数领域内的适定（well-posed）且有科学依据的问题，其表述语言客观而精确。所有必要的数据、定义和约束均已提供，且不存在内部矛盾或逻辑缺陷。该问题要求分析算法稳定性，这是计算科学中的一个基本概念。我们将着手进行求解。\n\n目标是研究对于参数 $\\varepsilon$ 的各种小值，求解线性系统 $A(\\varepsilon)x = b$ 的数值稳定性。具体来说，我们必须比较两种基于三角分解的方法的精度：一种是保持固定行序的方法（不带主元选择的高斯消元法），另一种是重排行以使用最大量值主元的方法（带部分主元选择的高斯消元法）。\n\n首先，我们确定精确解 $x^{\\star}(\\varepsilon)$，它将作为比较数值近似解的基准。矩阵 $A(\\varepsilon)$ 由下式给出：\n$$\nA(\\varepsilon) = \\begin{bmatrix} \\varepsilon & 1 \\\\ 1 & 1 \\end{bmatrix}.\n$$\n其行列式为 $\\det(A(\\varepsilon)) = \\varepsilon \\cdot 1 - 1 \\cdot 1 = \\varepsilon - 1$。由于问题指定 $\\varepsilon \\in (0,1)$，行列式非零，因此矩阵总是可逆的。其逆矩阵为：\n$$\nA(\\varepsilon)^{-1} = \\frac{1}{\\varepsilon - 1} \\begin{bmatrix} 1 & -1 \\\\ -1 & \\varepsilon \\end{bmatrix}.\n$$\n因此，精确解 $x^{\\star}(\\varepsilon) = A(\\varepsilon)^{-1}b$ 为：\n$$\nx^{\\star}(\\varepsilon) = \\frac{1}{\\varepsilon - 1} \\begin{bmatrix} 1 & -1 \\\\ -1 & \\varepsilon \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix} = \\frac{1}{\\varepsilon - 1} \\begin{bmatrix} 1 - 2 \\\\ -1 + 2\\varepsilon \\end{bmatrix} = \\frac{1}{\\varepsilon - 1} \\begin{bmatrix} -1 \\\\ -1 + 2\\varepsilon \\end{bmatrix} = \\begin{bmatrix} \\frac{1}{1-\\varepsilon} \\\\ \\frac{1-2\\varepsilon}{1-\\varepsilon} \\end{bmatrix}.\n$$\n当 $\\varepsilon \\to 0$ 时，精确解趋近于 $x^{\\star}(0) = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$。对于小的 $\\varepsilon$ 值，解本身是良态的。\n\n接下来，我们分析问题的条件。谱条件数 $\\kappa_{2}(A(\\varepsilon))$ 衡量解 $x$ 对 $A$ 或 $b$ 中扰动的敏感度。当 $\\varepsilon \\to 0$ 时，矩阵 $A(\\varepsilon)$ 趋近于 $A(0) = \\begin{bmatrix} 0 & 1 \\\\ 1 & 1 \\end{bmatrix}$。$A(0)$ 的奇异值是 $A(0)^T A(0) = \\begin{bmatrix} 1 & 1 \\\\ 1 & 2 \\end{bmatrix}$ 的特征值的平方根。该矩阵的特征值为 $\\lambda = (3 \\pm \\sqrt{5})/2$。奇异值为 $\\sigma_{\\max} = \\sqrt{(3 + \\sqrt{5})/2}$ 和 $\\sigma_{\\min} = \\sqrt{(3 - \\sqrt{5})/2}$。条件数为\n$$\n\\kappa_{2}(A(0)) = \\frac{\\sigma_{\\max}}{\\sigma_{\\min}} = \\frac{\\sqrt{3+\\sqrt{5}}}{\\sqrt{3-\\sqrt{5}}} = \\frac{3+\\sqrt{5}}{2} \\approx 2.618.\n$$\n这是一个小数，表明对于小的 $\\varepsilon$，矩阵 $A(\\varepsilon)$ 是良态的。该问题本身对小扰动不敏感。因此，$S(\\varepsilon)$ 中的第一个条件 $\\kappa_{2}(A(\\varepsilon)) \\leq 10$ 对于所有测试值 $\\varepsilon$ 都将满足。因此，计算解中的任何大误差都必定源于所用算法的不稳定性，而不是问题本身的病态性。\n\n现在我们分析第一种数值方法，即 $x_{\\mathrm{np}}(\\varepsilon)$，它对应于不带主元选择的高斯消元法。我们对 $A(\\varepsilon)$ 进行 LU 分解，即 $A(\\varepsilon) = LU$。\n$$\nA(\\varepsilon) = \\begin{bmatrix} \\varepsilon & 1 \\\\ 1 & 1 \\end{bmatrix}.\n$$\n为消去元素 $a_{21}=1$，我们使用乘数 $m_{21} = a_{21}/a_{11} = 1/\\varepsilon$。得到的上三角矩阵 $U$ 为：\n$$\nU = \\begin{bmatrix} \\varepsilon & 1 \\\\ 0 & 1 - 1/\\varepsilon \\end{bmatrix}.\n$$\n下三角矩阵 $L$ 为：\n$$\nL = \\begin{bmatrix} 1 & 0 \\\\ 1/\\varepsilon & 1 \\end{bmatrix}.\n$$\n对于很小的 $\\varepsilon$ (例如 $\\varepsilon \\approx 10^{-16}$），乘数 $1/\\varepsilon$ 会变得极大。在标准双精度浮点运算中（其机器精度约为 $2.2 \\times 10^{-16}$），计算项 $\\mathrm{fl}(1 - 1/\\varepsilon)$ 会遭遇灾难性抵消。与 $1/\\varepsilon$ 相比，数字 $1$ 微不足道，因此结果就是 $\\mathrm{fl}(-1/\\varepsilon)$。\n该系统通过向前代入 $Ly=b$ 和向后代入 $Ux=y$ 求解。\n求解 $Ly=b$：\n$y_1 = b_1 = 1$。\n$(1/\\varepsilon)y_1 + y_2 = b_2 \\implies y_2 = 2 - 1/\\varepsilon$。\n在浮点运算中，$\\mathrm{fl}(y_2) = \\mathrm{fl}(2 - 1/\\varepsilon) \\approx -1/\\varepsilon$。\n求解 $Ux=y$：\n计算出的 $U$ 矩阵的 $(2,2)$ 元素是 $\\tilde{u}_{22} = \\mathrm{fl}(1-1/\\varepsilon) \\approx -1/\\varepsilon$。\n$\\tilde{u}_{22} x_2 = \\tilde{y}_2 \\implies (-1/\\varepsilon) x_2 \\approx -1/\\varepsilon \\implies x_2 \\approx 1$。\n$\\varepsilon x_1 + x_2 = y_1 \\implies \\varepsilon x_1 + 1 \\approx 1 \\implies \\varepsilon x_1 \\approx 0 \\implies x_1 \\approx 0$。\n计算出的解是 $x_{\\mathrm{np}}(\\varepsilon) \\approx \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$。\n将此与小 $\\varepsilon$ 的精确解 $x^{\\star}(\\varepsilon) \\approx \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$ 比较，误差是显著的。相对误差为\n$$\n\\mathcal{E}(x_{\\mathrm{np}};\\varepsilon) = \\frac{\\|x_{\\mathrm{np}} - x^{\\star}(\\varepsilon)\\|_{2}}{\\|x^{\\star}(\\varepsilon)\\|_{2}} \\approx \\frac{\\|\\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} - \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}\\|_{2}}{\\|\\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} \\|_{2}} = \\frac{\\|\\begin{bmatrix} -1 \\\\ 0 \\end{bmatrix}\\|_{2}}{\\sqrt{1^2+1^2}} = \\frac{1}{\\sqrt{2}} \\approx 0.707.\n$$\n这是一个非常大的误差，远超 $10^{-3}$。这说明了当遇到小主元时，不带主元选择的高斯消元法的数值不稳定性。对于任何小到足以引起这种浮点行为的 $\\varepsilon$，这种情况都会发生。只有当 $\\varepsilon$ 足够大，以至于 $1/\\varepsilon$ 不大时，这种不稳定性才会消失。对于 $\\varepsilon = 10^{-1}$，乘数为 $10$，计算 $1-10=-9$ 在浮点运算中是精确的。在这种情况下，无主元消元是精确的。因此，条件 $\\mathcal{E}(x_{\\mathrm{np}}(\\varepsilon);\\varepsilon) \\geq 10^{-3}$ 对于小的 $\\varepsilon$ 将为真，但对于 $\\varepsilon = 10^{-1}$ 将为假。\n\n现在，我们分析第二种方法，即 $x_{\\mathrm{pp}}(\\varepsilon)$，它对应于带部分主元选择的高斯消元法。在每个步骤中，交换行以确保主元元素（对角线元素）在活动子矩阵的其所在列中是最大的。\n对于 $A(\\varepsilon) = \\begin{bmatrix} \\varepsilon & 1 \\\\ 1 & 1 \\end{bmatrix}$ 且 $\\varepsilon \\in (0,1)$，我们有 $|a_{21}| = 1 > |\\varepsilon| = |a_{11}|$。因此，我们必须交换第 1 行和第 2 行。这等效于乘以一个置换矩阵 $P = \\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\end{bmatrix}$。系统变为 $PAx=Pb$。\n$$\nPA = \\begin{bmatrix} 1 & 1 \\\\ \\varepsilon & 1 \\end{bmatrix}, \\quad Pb = \\begin{bmatrix} 2 \\\\ 1 \\end{bmatrix}.\n$$\n现在我们对这个新系统进行消元。乘数为 $m_{21} = \\varepsilon/1 = \\varepsilon$。因为 $|\\varepsilon|<1$，所以乘数很小，这是稳定消元步骤的标志。\n上三角矩阵 $U$ 变为：\n$$\nU = \\begin{bmatrix} 1 & 1 \\\\ 0 & 1-\\varepsilon \\end{bmatrix}.\n$$\n运算过程为 $y_1=2$， $y_2=1-2\\varepsilon$，然后 $(1-\\varepsilon)x_2 = 1-2\\varepsilon \\implies x_2 = (1-2\\varepsilon)/(1-\\varepsilon)$，以及 $x_1+x_2=2 \\implies x_1=2-x_2 = 1/(1-\\varepsilon)$。计算出的解与精确解的解析形式相同。由于所有运算都涉及良态算术（没有大小相近的大数相减），浮点计算将是高度精确的。相对误差 $\\mathcal{E}(x_{\\mathrm{pp}}(\\varepsilon);\\varepsilon)$ 将在机器精度（约 $10^{-16}$）的量级上，因此对于所有测试用例都满足条件 $\\mathcal{E}(x_{\\mathrm{pp}}(\\varepsilon);\\varepsilon) \\leq 10^{-12}$。\n\n总而言之，对于 $\\varepsilon \\in \\{10^{-16}, 10^{-12}, 10^{-8}, 10^{-4}\\}$：\n1.  $\\kappa_{2}(A(\\varepsilon)) \\leq 10$ 为 `True`。\n2.  由于不稳定性，$\\mathcal{E}(x_{\\mathrm{np}}(\\varepsilon);\\varepsilon) \\geq 10^{-3}$ 为 `True`。\n3.  由于稳定性，$\\mathcal{E}(x_{\\mathrm{pp}}(\\varepsilon);\\varepsilon) \\leq 10^{-12}$ 为 `True`。\n因此，$S(\\varepsilon)$ 的值为 `True`。\n\n对于 $\\varepsilon=10^{-1}$：\n1.  $\\kappa_{2}(A(0.1)) \\leq 10$ 为 `True`。\n2.  $\\mathcal{E}(x_{\\mathrm{np}}(0.1);\\varepsilon) \\geq 10^{-3}$ 为 `False`，因为乘数 $1/0.1=10$ 不足以引起显著的浮点误差，计算是精确的。\n3.  $\\mathcal{E}(x_{\\mathrm{pp}}(0.1);\\varepsilon) \\leq 10^{-12}$ 为 `True`。\n由于第二个条件为假，$S(0.1)$ 的值为 `False`。\n\n程序将实现这些计算并验证这一推理过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# The problem can be solved with numpy; scipy is not strictly necessary but is permitted.\n\ndef solve():\n    \"\"\"\n    Solves the specified problem by analyzing the numerical stability of solving\n    a linear system with and without pivoting.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        1e-16,\n        1e-12,\n        1e-8,\n        1e-4,\n        1e-1,\n    ]\n\n    results = []\n    \n    for eps in test_cases:\n        # Define the matrix A and vector b for the current epsilon\n        A = np.array([[eps, 1.0], [1.0, 1.0]], dtype=np.float64)\n        b = np.array([1.0, 2.0], dtype=np.float64)\n\n        # --- 1. Calculate the 'exact' solution x_star ---\n        # Using the analytical formula derived from the problem.\n        # This gives a high-precision reference for error calculation.\n        x_star = np.array([1.0 / (1.0 - eps), (1.0 - 2.0 * eps) / (1.0 - eps)], dtype=np.float64)\n\n        # --- 2. Calculate the condition number kappa_2 ---\n        kappa_2 = np.linalg.cond(A, 2)\n\n        # --- 3. Calculate the solution with no pivoting (x_np) ---\n        # This requires manually implementing Gaussian elimination without row swaps.\n        def solve_no_pivot(mat_A, vec_b):\n            n = len(vec_b)\n            A_np = mat_A.copy()\n            b_np = vec_b.copy()\n\n            # Forward elimination to create an upper triangular matrix\n            # This is a 2x2 specific implementation for simplicity and clarity.\n            if A_np[0, 0] == 0:\n                # This case isn't hit for eps > 0 but is a necessary check\n                # for a general algorithm. A zero pivot without pivoting fails.\n                return np.array([np.nan, np.nan])\n            \n            m = A_np[1, 0] / A_np[0, 0]\n            A_np[1, :] -= m * A_np[0, :]\n            b_np[1] -= m * b_np[0]\n            \n            # Backward substitution\n            x = np.zeros(n, dtype=np.float64)\n            if A_np[1, 1] == 0:\n                # Another fail condition, singular matrix after elimination.\n                return np.array([np.nan, np.nan])\n                \n            x[1] = b_np[1] / A_np[1, 1]\n            x[0] = (b_np[0] - A_np[0, 1] * x[1]) / A_np[0, 0]\n            \n            return x\n\n        x_np = solve_no_pivot(A, b)\n        \n        # --- 4. Calculate the solution with partial pivoting (x_pp) ---\n        # np.linalg.solve uses LAPACK routines which employ partial pivoting by default.\n        x_pp = np.linalg.solve(A, b)\n\n        # --- 5. Calculate relative errors ---\n        norm_x_star = np.linalg.norm(x_star, 2)\n        if norm_x_star == 0:\n             # Avoid division by zero, though not relevant for this problem.\n            rel_error_np = np.linalg.norm(x_np - x_star, 2)\n            rel_error_pp = np.linalg.norm(x_pp - x_star, 2)\n        else:\n            rel_error_np = np.linalg.norm(x_np - x_star, 2) / norm_x_star\n            rel_error_pp = np.linalg.norm(x_pp - x_star, 2) / norm_x_star\n            \n        # --- 6. Evaluate the boolean condition S(epsilon) ---\n        S = (kappa_2 = 10.0) and (rel_error_np >= 1e-3) and (rel_error_pp = 1e-12)\n        results.append(S)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2370924"}, {"introduction": "在前一个练习的基础上，我们现在探讨另一面：病态问题（ill-conditioned problems）。有些问题天生就对初始数据或计算过程中的微小舍入误差极其敏感，即使我们使用最稳定可靠的算法，也难以获得精确的解。这个实践练习 [@problem_id:2421700] 将使用著名的“希尔伯特矩阵”（Hilbert matrix）作为案例，它向我们生动地展示了，当问题本身是“病态”的，一个数值稳定的算法（表现为微小的“后向误差”）仍然可能导致巨大的“前向误差”，即计算出的解与真实解相去甚远。", "problem": "要求您编写一个完整的、可运行的程序，用以演示在使用 Hilbert 矩阵求解线性系统时的数值稳定性和不稳定性。一个大小为 $n$ 的 Hilbert 矩阵，记作 $H_n$，是一个 $n \\times n$ 矩阵，其元素为 $H_{ij} = \\dfrac{1}{i + j - 1}$，其中 $1 \\le i, j \\le n$。该矩阵是对称正定的，但它也是出了名的病态矩阵 (ill-conditioned)，这意味着微小的扰动（例如，由浮点运算产生的舍入误差）可能会导致线性系统计算解的巨大变化。\n\n基本原理和定义：考虑线性系统 $A x = b$，其中 $A$ 是一个非奇异矩阵。对于解 $x$，以下概念是基础。\n- 相对前向误差为 $\\dfrac{\\lVert \\hat{x} - x \\rVert_2}{\\lVert x \\rVert_2}$。\n- 后向误差（一种常见的归一化选择）为 $\\dfrac{\\lVert A \\hat{x} - b \\rVert_2}{\\lVert A \\rVert_2 \\lVert \\hat{x} \\rVert_2 + \\lVert b \\rVert_2}$。\n- $2$-范数条件数是 $\\kappa_2(A) = \\lVert A \\rVert_2 \\lVert A^{-1} \\rVert_2$。\n\n经过充分检验的、可作为出发点的事实：\n- 在符合电气和电子工程师协会 (IEEE) $754$ 标准的浮点运算中，稳定的直接求解器（例如，标准库中实现的带部分主元的 Gaussian 消元法）通常是后向稳定的：计算出的解 $\\hat{x}$ 是一个邻近系统 $(A + \\Delta A)\\hat{x} = b$ 的精确解，其中 $\\dfrac{\\lVert \\Delta A \\rVert_2}{\\lVert A \\rVert_2}$ 的量级与单位舍入误差 $u$（对于双精度，约为 $2^{-53} \\approx 1.11 \\times 10^{-16}$）相当。\n- 对于微小扰动，前向误差的界与条件数成正比：$\\dfrac{\\lVert \\hat{x} - x \\rVert_2}{\\lVert x \\rVert_2} \\lesssim \\kappa_2(A) \\cdot \\dfrac{\\lVert \\Delta A \\rVert_2}{\\lVert A \\rVert_2}$。\n\n任务：实现一个程序，对于指定测试集中的每个 $n$，构造 Hilbert 矩阵 $H_n$，选择一个已知的精确解 $x_\\text{true}$，构造 $b = H_n x_\\text{true}$，在双精度下对系统进行数值求解以获得 $\\hat{x}$，并报告：\n- 相对前向误差 $\\dfrac{\\lVert \\hat{x} - x_\\text{true} \\rVert_2}{\\lVert x_\\text{true} \\rVert_2}$，\n- 归一化后向误差 $\\dfrac{\\lVert H_n \\hat{x} - b \\rVert_2}{\\lVert H_n \\rVert_2 \\lVert \\hat{x} \\Vert_2 + \\lVert b \\rVert_2}$，\n- $2$-范数条件数 $\\kappa_2(H_n)$。\n\n精确解的选择：使用 $x_\\text{true}$，其元素为 $x_i = (-1)^{i-1}$，其中 $i = 1, \\dots, n$，因此 $x_\\text{true}$ 的元素为 $\\{+1, -1, +1, -1, \\dots\\}$。\n\n数值环境：使用双精度浮点运算。不允许使用随机数。不涉及角度。没有物理单位。\n\n测试集：按顺序对 $n \\in \\{2, 5, 8, 12, 14\\}$ 运行您的程序。这些案例涵盖了一个基准小尺寸 ($n = 2$)、一个典型的表现良好的中小规模案例 ($n = 5$)、一个明显病态的中等规模案例 ($n = 8$)，以及两个愈发极端的病态案例 ($n = 12$ 和 $n = 14$)。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含所有测试用例的结果，形式为用方括号括起来的逗号分隔列表，每个测试用例以内部列表 `[n, forward_error, backward_error, kappa_2]` 的形式报告。输出中不得包含任何空格。例如，整体结构必须是\n`[[n_1,forward_error_1,backward_error_1,kappa_2,1],[n_2,forward_error_2,backward_error_2,kappa_2,2],...]`。\n所有数值都应以十进制浮点数形式打印（科学记数法是可接受的）。程序不得读取任何输入。", "solution": "所述问题是数值线性代数中一个标准而基础的练习，也是计算科学的基石。其目的在于通过经验性地展示算法的稳定性与一个问题的条件性之间的关键区别。在继续之前，需要进行严格的验证。\n\n该问题要求分析线性系统 $H_n x = b$，其中 $H_n$ 是大小为 $n$ 的 Hilbert 矩阵。所有给定条件都已明确说明：$H_n$ 的定义为 $H_{ij} = (i+j-1)^{-1}$，精确解向量 $x_\\text{true}$ 的选择，构造向量 $b$ 的步骤，要使用的数值方法（双精度运算，标准线性求解器），以及要报告的精确量：相对前向误差、归一化后向误差和 $2$-范数条件数。还指定了矩阵大小的测试集 $n \\in \\{2, 5, 8, 12, 14\\}$。\n\n问题陈述具有科学依据，借鉴了矩阵分析和数值稳定性理论的既定原则。它是一个适定问题 (well-posed)，提供了一套完整且一致的指令，可以得出一个唯一的、可验证的计算结果。其语言客观明确。因此，该问题被认为是有效的，并将提出一个解决方案。\n\n核心概念是数学问题的条件性。如果输入数据的微小相对变化能导致输出解的巨大相对变化，则称该问题是病态的 (ill-conditioned)。对于线性系统 $Ax=b$，解 $x$ 对 $A$ 和 $b$ 中扰动的敏感度由矩阵 $A$ 的条件数来衡量，对于 $2$-范数，其定义为：\n$$\n\\kappa_2(A) = \\lVert A \\rVert_2 \\lVert A^{-1} \\rVert_2\n$$\n大的条件数意味着问题是病态的。Hilbert 矩阵是出了名的病态矩阵，其 $\\kappa_2(H_n)$ 会随着 $n$ 呈指数级增长。\n\n如果一个解决问题的算法不会引入超出问题自身条件性所固有的显著额外误差，则称该算法是数值稳定的。一个后向稳定算法，例如带部分主元的 Gaussian 消元法（像 `numpy.linalg.solve` 这样的标准库求解器的基础），会计算出一个解 $\\hat{x}$，该解是一个轻微扰动问题的精确解：\n$$\n(A + \\Delta A)\\hat{x} = b, \\quad \\text{其中} \\quad \\frac{\\lVert \\Delta A \\rVert_2}{\\lVert A \\rVert_2} \\approx u\n$$\n这里，$u$ 是单位舍入误差，或称机器精度（对于 IEEE $754$ 双精度， $u = 2^{-53} \\approx 1.11 \\times 10^{-16}$）。小的后向误差是这一性质的体现。问题中定义了一个特定的归一化后向误差：\n$$\nE_b = \\frac{\\lVert A \\hat{x} - b \\rVert_2}{\\lVert A \\rVert_2 \\lVert \\hat{x} \\rVert_2 + \\lVert b \\rVert_2}\n$$\n这个量衡量了残差 $A\\hat{x}-b$ 相对于问题规模的大小。对于一个后向稳定算法，我们期望 $E_b$ 会很小，量级与 $u$ 相当。\n\n相比之下，相对前向误差衡量的是解本身的差异：\n$$\nE_f = \\frac{\\lVert \\hat{x} - x_\\text{true} \\rVert_2}{\\lVert x_\\text{true} \\rVert_2}\n$$\n连接这些量的基本关系可近似表示为：\n$$\nE_f \\lesssim \\kappa_2(A) \\cdot (\\text{后向误差})\n$$\n这个不等式表明，即使使用后向稳定算法（后向误差很小），如果问题是病态的（$\\kappa_2(A)$ 很大），计算解中产生的前向误差也可能大到无法接受。Hilbert 矩阵为这一现象提供了一个经典的案例研究。\n\n对于测试集 $\\{2, 5, 8, 12, 14\\}$ 中的每个 $n$，要实现的计算步骤如下：\n$1$。构造 $n \\times n$ 的 Hilbert 矩阵 $H_n$，其元素为 $H_{ij} = (i+j-1)^{-1}$，其中 $i,j \\in \\{1, \\dots, n\\}$。\n$2$。构造大小为 $n$ 的真实解向量 $x_\\text{true}$，其元素为 $(x_\\text{true})_i = (-1)^{i-1}$，其中 $i \\in \\{1, \\dots, n\\}$。\n$3$。计算右端向量 $b = H_n x_\\text{true}$。该计算在双精度下进行，其结果是数值测试的参考右端项。\n$4$。对线性系统 $H_n x = b$ 进行数值求解，以获得计算解 $\\hat{x}$。这将使用一个标准的、稳定的直接求解器来完成。\n$5$。计算三个所需的诊断量：\n    a. $2$-范数条件数 $\\kappa_2(H_n)$。\n    b. 相对前向误差 $E_f = \\frac{\\lVert \\hat{x} - x_\\text{true} \\rVert_2}{\\lVert x_\\text{true} \\rVert_2}$。\n    c. 归一化后向误差 $E_b = \\frac{\\lVert H_n \\hat{x} - b \\rVert_2}{\\lVert H_n \\rVert_2 \\lVert \\hat{x} \\rVert_2 + \\lVert b \\rVert_2}$。\n$6$。收集并报告结果 $[n, E_f, E_b, \\kappa_2(H_n)]$。\n\n预期行为：随着 $n$ 的增加，$\\kappa_2(H_n)$ 将会极快增长。归一化后向误差 $E_b$ 将保持很小，接近机器精度，从而证实求解器的稳定性。因此，前向误差 $E_f$ 将急剧增长，大致追踪乘积 $\\kappa_2(H_n) \\cdot u$ 的变化。当 $n=12$ 和 $n=14$ 时，条件数会大到使得 $\\kappa_2(H_n) \\cdot u \\gg 1$，这表明矩阵在数值上是奇异的，并且计算出的解 $\\hat{x}$ 预计将没有任何正确的有效数字。本程序将精确地展示这一行为。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Demonstrates numerical stability and instability when solving a linear system\n    with a Hilbert matrix for various sizes.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [2, 5, 8, 12, 14]\n\n    results = []\n    for n in test_cases:\n        # Construct the Hilbert matrix H_n.\n        # scipy.linalg.hilbert uses 1-based indexing in its definition,\n        # which matches the problem statement.\n        H = linalg.hilbert(n)\n\n        # Construct the known exact solution x_true with entries (-1)^(i-1).\n        # For 0-based array indexing, this is (-1)^i.\n        x_true = np.array([(-1)**i for i in range(n)])\n\n        # Construct the right-hand side vector b = H_n * x_true.\n        # This is performed in standard double-precision floating-point arithmetic.\n        b = H @ x_true\n\n        # Solve the system H_n * x = b numerically to obtain the computed solution x_hat.\n        # numpy.linalg.solve is a backward stable direct solver.\n        x_hat = np.linalg.solve(H, b)\n\n        # Calculate the 2-norm condition number of H_n.\n        # This is kappa_2(H_n) = ||H_n||_2 * ||H_n^-1||_2.\n        cond_num = np.linalg.cond(H, p=2)\n\n        # Calculate the forward relative error: ||x_hat - x_true||_2 / ||x_true||_2.\n        norm_x_true = np.linalg.norm(x_true, ord=2)\n        norm_error_x = np.linalg.norm(x_hat - x_true, ord=2)\n        forward_error = norm_error_x / norm_x_true\n\n        # Calculate the normalized backward error:\n        # ||H_n * x_hat - b||_2 / (||H_n||_2 * ||x_hat||_2 + ||b||_2).\n        residual_vec = H @ x_hat - b\n        norm_residual = np.linalg.norm(residual_vec, ord=2)\n        norm_H = np.linalg.norm(H, ord=2)\n        norm_x_hat = np.linalg.norm(x_hat, ord=2)\n        norm_b = np.linalg.norm(b, ord=2)\n        backward_error = norm_residual / (norm_H * norm_x_hat + norm_b)\n        \n        # Store the results for the current n.\n        results.append([n, forward_error, backward_error, cond_num])\n\n    # Format the final output string exactly as required.\n    # Each sublist is formatted as \"[n,ferr,berr,cond]\" with no spaces.\n    str_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    \n    # All sublist strings are joined by commas and enclosed in brackets.\n    final_output_str = f\"[{','.join(str_results)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n\n```", "id": "2421700"}, {"introduction": "现在，我们将这些关于稳定性和条件数的概念应用到一个具体的金融模型中。二叉树模型是进行期权定价的常用工具，但其数值实现的稳定性并非理所当然。这个实践练习 [@problem_id:2370925] 旨在研究模型离散化的一个关键参数——时间步数（number of time steps）——如何影响价格计算的稳定性。你将通过编程发现，当步数过少时，尤其对于深度价外期权，计算出的价格可能会出现非单调的“震荡”行为，而不是平滑地收敛到真实值。", "problem": "考虑一个无套利市场，在该市场中，标的资产价格过程在风险中性概率测度下被建模为一个重组二叉树，该二叉树在到期期限 $T$ 内近似于一个连续时间的几何布朗运动，具有连续复利无风险利率 $r$、连续股息率 $q$ 和波动率 $\\sigma$。对于给定的时间步数 $N \\in \\mathbb{N}$，令 $\\Delta t = T/N$，并定义 Cox–Ross–Rubinstein (CRR) 的上涨和下跌乘数分别为 $u = \\exp(\\sigma \\sqrt{\\Delta t})$ 和 $d = 1/u$，以及风险中性概率为 $p = \\dfrac{\\exp\\left((r - q)\\Delta t\\right) - d}{u - d}$，其中 $0  p  1$。对于一个即期价格为 $S_0$、行权价为 $K$、到期日为 $T$ 的欧式看涨期权，通过风险中性定价法将 $N$ 步二叉树价格 $V_N$ 定义为\n$$\nV_N = \\exp(-r T) \\sum_{k=0}^{N} \\binom{N}{k} p^k (1-p)^{N-k} \\max\\!\\left(S_0\\, u^{k} d^{N-k} - K, 0\\right).\n$$\n您将考察 $V_N$ 作为时间步数 $N$ 的函数的稳定性，针对几组参数集，重点关注深度价外的情况。对于一组固定的参数集，为 $N_i \\in \\{1,2,3,4,5,6,7,8,9,10,11,12\\}$ 定义序列 $\\{V_{N_i}\\}$。使用此序列，计算以下两个标量诊断指标，以量化在步数过少时出现的振荡和不稳定性：\n- 振荡计数 $O$，定义为序列一阶差分中严格符号变化的次数。即，对于 $i = 1,\\dots,11$，令 $\\Delta_i = V_{N_{i+1}} - V_{N_{i}}$，忽略任何满足 $|\\Delta_i| \\le \\varepsilon$（其中 $\\varepsilon = 10^{-12}$）的 $\\Delta_i$，并在剩余子序列中计算满足 $\\Delta_i \\Delta_{i-1}  0$ 的索引 $i$ 的数量。\n- 不稳定比率 $R$，定义为\n$$\nR = \\frac{\\sum_{i=1}^{11} |\\Delta_i|}{\\left|V_{N_{12}} - V_{N_{1}}\\right| + \\varepsilon},\n$$\n其中 $\\varepsilon = 10^{-12}$。大于 $1$ 的 $R$ 值表示存在振荡行为，该行为使得总变差超过了从 $N=1$ 到 $N=12$ 的净变化。\n\n使用以下参数集测试套件，每个套件指定 $(S_0, K, r, q, \\sigma, T)$：\n- 测试案例 $1$ (深度价外)：$(S_0, K, r, q, \\sigma, T) = (100, 150, 0.05, 0, 0.20, 1)$。\n- 测试案例 $2$ (平价对照)：$(S_0, K, r, q, \\sigma, T) = (100, 100, 0.05, 0, 0.20, 1)$。\n- 测试案例 $3$ (更深度价外)：$(S_0, K, r, q, \\sigma, T) = (100, 200, 0.05, 0, 0.20, 1)$。\n- 测试案例 $4$ (短期，深度价外)：$(S_0, K, r, q, \\sigma, T) = (100, 150, 0.05, 0, 0.20, 0.25)$。\n\n对于每个测试案例，您的程序必须计算序列 $\\{V_{N}\\}_{N=1}^{12}$，然后计算如上定义的 $(O, R)$ 对。要求的最终输出格式为单行，其中包含一个用方括号括起来的逗号分隔列表，按顺序汇总四个测试案例的结果，格式为\n$[O_1, R_1, O_2, R_2, O_3, R_3, O_4, R_4]$，\n其中每个 $O_j$ 是一个整数，每个 $R_j$ 是一个四舍五入到六位小数的浮点数。不应打印任何其他文本。", "solution": "该问题陈述已经过严格验证，并被确定为有效。其科学基础扎根于金融工程的既定原理，特别是 Cox-Ross-Rubinstein 二叉树期权定价模型。该问题提法恰当，所有参数、定义和目标函数均已清晰明确地陈述，不存在内部矛盾、事实错误或模糊之处。因此，我们可以着手推导解决方案。\n\n目标是分析在时间步数 $N$ 较少时，二叉树期权定价公式的数值稳定性。欧式看涨期权的价格 $V_N$ 由风险中性定价公式给出：\n$$\nV_N = \\exp(-r T) \\sum_{k=0}^{N} \\binom{N}{k} p^k (1-p)^{N-k} \\max\\!\\left(S_0\\, u^{k} d^{N-k} - K, 0\\right)\n$$\n其中参数定义如下：\n- 时间步数为 $N$，时间增量为 $\\Delta t = T/N$。\n- 标的资产价格的上涨和下跌因子分别为 $u = \\exp(\\sigma \\sqrt{\\Delta t})$和 $d = 1/u$。\n- 风险中性的上涨概率为 $p = \\dfrac{\\exp\\left((r - q)\\Delta t\\right) - d}{u - d}$。条件 $0  p  1$ 是一个基本的无套利要求，对于所提供的测试数据和指定的 $N$ 范围，该条件得到满足。\n\n对于4个测试案例中的每一个，计算流程如下：\n\n首先，我们必须为 $N \\in \\{1, 2, \\dots, 12\\}$ 生成期权价格序列 $\\{V_{N}\\}$。对于从1到12的每个整数 $N$，我们执行以下步骤：\n1.  计算时间步长 $\\Delta t = T/N$。\n2.  根据定义计算 CRR 参数 $u$、$d$ 和 $p$。\n3.  计算 $V_N$ 公式中的求和项。这涉及从 $k=0$ 到 $N$ 的迭代。在每次迭代 $k$ 中：\n    a. 我们计算达到第 $k$ 个终端状态的概率，该概率由二项概率质量函数 $B(k; N, p) = \\binom{N}{k} p^k (1-p)^{N-k}$ 给出。为保证数值稳定性，二项式系数 $\\binom{N}{k}$ 使用标准库函数计算。\n    b. 我们计算第 $k$ 个状态下的终端资产价格：$S_T(k) = S_0 u^k d^{N-k}$。\n    c. 我们确定此状态下的期权收益：$\\max(S_T(k) - K, 0)$。\n    d. 对总期望收益的贡献是概率与收益的乘积。\n4.  最终期权价格 $V_N$ 是通过将这些概率加权收益的总和从到期日 $T$ 折现到现在而获得的，折现因子为 $\\exp(-rT)$。\n这个过程产生了所需的序列 $V_1, V_2, \\dots, V_{12}$。\n\n其次，在计算出序列 $\\{V_N\\}$ 后，我们继续计算两个诊断指标：振荡计数 $O$ 和不稳定比率 $R$。\n1.  计算一阶差分序列 $\\Delta_i = V_{i+1} - V_{i}$，其中 $i \\in \\{1, 2, \\dots, 11\\}$。\n2.  为了计算振荡计数 $O$，我们将指令“count... in the remaining subsequence”解释为：首先对差分序列 $\\Delta$ 进行过滤，排除满足 $|\\Delta_i| \\le \\varepsilon$（其中容差 $\\varepsilon$ 给定为 $10^{-12}$）的元素，然后计算这个新的、更短的序列中相邻元素之间的符号变化次数。也就是说，$O$ 是满足 $\\Delta'_j \\Delta'_{j+1}  0$ 的索引 $j$ 的数量，其中 $\\Delta'$ 是过滤后的序列。此过程通过忽略数值上不显著的波动来稳健地识别真实的价格振荡。\n3.  为了计算不稳定比率 $R$，我们使用以下公式：\n$$\nR = \\frac{\\sum_{i=1}^{11} |\\Delta_i|}{\\left|V_{12} - V_{1}\\right| + \\varepsilon}\n$$\n分子代表总变差（所有价格变化幅度的总和），而分母是从第一步到最后一步的净变化幅度，并由 $\\varepsilon$ 进行稳定化处理。大于 $1$ 的比率 $R$ 表明从 $V_1$ 到 $V_{12}$ 的路径不是单调的；总变差超过了净变差，这是振荡收敛的特征。\n\n对4个指定的参数集中的每一个都执行此完整流程。最终输出是计算出的 $(O, R)$ 对的聚合。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import comb\n\ndef calculate_vn(s0, k_strike, r, q, sigma, t, n_steps):\n    \"\"\"\n    Calculates the European call option price using the N-step CRR binomial model.\n    The implementation is vectorized for efficiency.\n    \"\"\"\n    if n_steps == 0:\n        return max(s0 - k_strike, 0)\n    \n    dt = t / n_steps\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1.0 / u\n    p = (np.exp((r - q) * dt) - d) / (u - d)\n\n    # Vector of possible numbers of up-moves\n    k_moves = np.arange(0, n_steps + 1)\n    \n    # Vector of terminal stock prices\n    st_values = s0 * (u**k_moves) * (d**(n_steps - k_moves))\n    \n    # Vector of payoffs at terminal nodes\n    payoff_values = np.maximum(st_values - k_strike, 0)\n    \n    # Vector of probabilities for each terminal node\n    probs = comb(n_steps, k_moves, exact=False) * (p**k_moves) * ((1 - p)**(n_steps - k_moves))\n    \n    # Expected payoff is the sum of probability-weighted payoffs\n    expected_payoff = np.sum(probs * payoff_values)\n    \n    # Discount the expected payoff to present value\n    vn = np.exp(-r * t) * expected_payoff\n    return vn\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (S0, K, r, q, sigma, T)\n        (100, 150, 0.05, 0, 0.20, 1),    # Test case 1\n        (100, 100, 0.05, 0, 0.20, 1),    # Test case 2\n        (100, 200, 0.05, 0, 0.20, 1),    # Test case 3\n        (100, 150, 0.05, 0, 0.20, 0.25), # Test case 4\n    ]\n\n    all_results = []\n    epsilon = 1e-12\n    n_values = range(1, 13)\n\n    for case in test_cases:\n        s0, k_strike, r, q, sigma, t = case\n        \n        # 1. Compute the sequence of option prices {V_N} for N=1 to 12.\n        v_sequence = [calculate_vn(s0, k_strike, r, q, sigma, t, n) for n in n_values]\n        \n        # 2. Compute the first differences.\n        deltas = np.diff(v_sequence)\n        \n        # 3. Calculate the Instability Ratio (R).\n        sum_abs_deltas = np.sum(np.abs(deltas))\n        net_change = np.abs(v_sequence[-1] - v_sequence[0])\n        instability_ratio = sum_abs_deltas / (net_change + epsilon)\n        \n        # 4. Calculate the Oscillation Count (O).\n        # Filter out differences that are close to zero.\n        filtered_deltas = [d for d in deltas if np.abs(d) > epsilon]\n        \n        oscillation_count = 0\n        # A sign change can only occur if there are at least two significant differences.\n        if len(filtered_deltas) > 1:\n            for i in range(len(filtered_deltas) - 1):\n                # Check for a strict sign change between adjacent elements in the filtered sequence.\n                if filtered_deltas[i] * filtered_deltas[i+1]  0:\n                    oscillation_count += 1\n        \n        all_results.append(oscillation_count)\n        all_results.append(f\"{instability_ratio:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2370925"}]}