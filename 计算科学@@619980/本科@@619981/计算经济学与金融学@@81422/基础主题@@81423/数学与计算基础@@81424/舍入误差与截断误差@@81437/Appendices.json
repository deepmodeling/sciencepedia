{"hands_on_practices": [{"introduction": "在数值计算中，即便是像二次方程求根公式这样我们早已熟知的公式，也可能在有限精度算术下失效。本练习将通过一个精心设计的二次方程，引导您直面“灾难性抵消”（catastrophic cancellation）这一现象。通过识别不稳定的根并重构其表达式，您将亲身体验诊断和修复此类常见数值错误的过程，从而对浮点运算的微妙之处有更深刻的理解。[@problem_id:2435764]", "problem": "考虑二次多项式 $p(x) = x^2 - 10^8 x + 1$。从第一性原理出发，推导 $p(x) = 0$ 的两个实数根的精确封闭形式表达式。然后，使用有限精度浮点运算中的舍入基本模型（如电气和电子工程师协会（IEEE）754 双精度（binary64）标准），解释两个精确封闭形式表达式中哪一个在数值计算上是不稳定的，并说明原因，指出灾难性抵消的机制。最后，将不稳定的根改写成一个代数上等价且能避免减法抵消的精确形式。\n\n答案要求：以两个根的精确符号表达式的形式给出最终答案，无需数值近似。不需要舍入。将你的最终答案表示为一对精确表达式。", "solution": "在尝试任何解答之前，需要对问题陈述进行验证。\n\n首先，我们提取问题的已知条件。\n给定的二次多项式为 $p(x) = x^2 - 10^8 x + 1$。\n问题要求解方程 $p(x) = 0$ 的根。\n数值稳定性的分析必须在有限精度浮点运算的框架下进行，特别是参考电气和电子工程师协会（IEEE）754 双精度标准。\n任务包括识别由标准二次公式导出的哪个根的表达式因“灾难性抵消”而数值不稳定，并随后为该根推导出一个代数上等价但数值上稳定的表达式。\n\n接下来，我们验证问题陈述的有效性。\n该问题具有科学依据，因为它涉及数值分析中的一个基本主题：在减去两个几乎相等的数时精度的损失。这种现象被称为灾难性抵消，是浮点运算中一个众所周知的后果。该多项式及其系数在数学上是合理的。\n该问题是适定的。它提供了求解根并分析其数值性质所需的所有信息（$a=1$, $b=-10^8$, $c=1$）。问题是明确的，可以导出一组唯一的稳定根表达式。\n问题是客观的，以精确的数学术语陈述，不含任何主观或推测性内容。\n因此，该问题被认为是有效的，并将提供解答。\n\n需要求解的二次方程是 $x^2 - 10^8 x + 1 = 0$。\n我们应用标准二次公式来求解 $ax^2 + bx + c = 0$ 的根，其根由 $x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$ 给出。\n对于给定的多项式，系数为 $a=1$, $b=-10^8$ 和 $c=1$。\n将这些值代入公式得到：\n$$x = \\frac{-(-10^8) \\pm \\sqrt{(-10^8)^2 - 4(1)(1)}}{2(1)}$$\n$$x = \\frac{10^8 \\pm \\sqrt{10^{16} - 4}}{2}$$\n这给出了两个精确的实数根：\n$$x_1 = \\frac{10^8 + \\sqrt{10^{16} - 4}}{2}$$\n$$x_2 = \\frac{10^8 - \\sqrt{10^{16} - 4}}{2}$$\n\n现在，我们必须在有限精度算术中分析这些表达式的数值稳定性。潜在不稳定性的来源在于减去两个几乎相等的量。\n我们来考察所涉及项的量级。项 $10^{16}$ 远大于 $4$。因此，$\\sqrt{10^{16} - 4}$ 的值非常接近 $\\sqrt{10^{16}} = 10^8$。\n为了更清楚地看到这一点，我们可以使用二项式近似。\n$$\\sqrt{10^{16} - 4} = \\sqrt{10^{16}(1 - 4 \\times 10^{-16})} = 10^8 \\sqrt{1 - 4 \\times 10^{-16}}$$\n对于一个很小的值 $\\epsilon$，近似式 $(1 - \\epsilon)^{1/2} \\approx 1 - \\frac{1}{2}\\epsilon$ 成立。这里，$\\epsilon = 4 \\times 10^{-16}$，它非常小。\n因此，$\\sqrt{10^{16} - 4} \\approx 10^8 (1 - \\frac{1}{2}(4 \\times 10^{-16})) = 10^8 (1 - 2 \\times 10^{-16}) = 10^8 - 2 \\times 10^{-8}$。\n$\\sqrt{10^{16} - 4}$ 的值仅比 $10^8$ 略小。\n\n考虑 $x_1$ 的表达式：$x_1 = \\frac{10^8 + \\sqrt{10^{16} - 4}}{2}$。该表达式涉及两个量级相似的大正数相加。在浮点运算中，此操作是数值稳定的。和的相对误差很小，在机器精度的量级。\n\n考虑 $x_2$ 的表达式：$x_2 = \\frac{10^8 - \\sqrt{10^{16} - 4}}{2}$。该表达式涉及两个非常接近的数相减。令 $y = \\sqrt{10^{16} - 4}$。在浮点计算中，$10^8$ 和 $y$ 的计算值将在许多有效高位上相同。当执行减法 $10^8 - y$ 时，这些有效高位会相互抵消，结果由剩下的、不太重要的数字决定，而这些数字在计算 $y$ 时会受到舍入误差的严重影响。相对误差的这种巨大增加就是灾难性抵消现象。因此，如果使用标准双精度算术直接求值，$x_2$ 的表达式是数值不稳定的，并且会产生一个非常不准确的结果。\n\n为了找到 $x_2$ 的一个数值稳定的表达式，我们使用韦达定理（Vieta's formulas），该定理将多项式的系数与其根联系起来。对于二次方程 $ax^2 + bx + c = 0$，其两根之积由 $x_1 x_2 = \\frac{c}{a}$ 给出。\n对我们的方程，这给出 $x_1 x_2 = \\frac{1}{1} = 1$。\n我们可以使用其公式精确地计算稳定的根 $x_1$。然后，我们可以从关系式 $x_2 = \\frac{1}{x_1}$ 中找到 $x_2$。\n代入 $x_1$ 的稳定表达式：\n$$x_2 = \\frac{1}{\\frac{10^8 + \\sqrt{10^{16} - 4}}{2}} = \\frac{2}{10^8 + \\sqrt{10^{16} - 4}}$$\n这个修正后的 $x_2$ 表达式只涉及正数的加法和除法，这两种运算都是数值稳定的。它避免了减法抵消，因此是数值计算的首选形式。\n\n我们通过将其分母有理化来验证这个新形式在代数上与原始不稳定的 $x_2$ 形式等价：\n$$\\frac{2}{10^8 + \\sqrt{10^{16} - 4}} \\cdot \\frac{10^8 - \\sqrt{10^{16} - 4}}{10^8 - \\sqrt{10^{16} - 4}} = \\frac{2(10^8 - \\sqrt{10^{16} - 4})}{(10^8)^2 - (10^{16} - 4)} = \\frac{2(10^8 - \\sqrt{10^{16} - 4})}{10^{16} - 10^{16} + 4} = \\frac{2(10^8 - \\sqrt{10^{16} - 4})}{4} = \\frac{10^8 - \\sqrt{10^{16} - 4}}{2}$$\n这证实了代数等价性。\n\n最终要求的答案包含两个根的精确符号表达式，并以其数值稳定的形式重写。\n较大的根是 $x_1 = \\frac{10^8 + \\sqrt{10^{16} - 4}}{2}$。\n较小的根，以其稳定形式表示为 $x_2 = \\frac{2}{10^8 + \\sqrt{10^{16} - 4}}$。", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{10^8 + \\sqrt{10^{16} - 4}}{2} & \\frac{2}{10^8 + \\sqrt{10^{16} - 4}} \\end{pmatrix}}$$", "id": "2435764"}, {"introduction": "在识别了数值不稳定性之后，我们来探讨一种强大的解决方案：泰勒级数近似。本练习将背景设定在信用风险模型中，展示一个看似简单的违约概率计算如何在短时间步长下变得非常不准确。通过用稳定的多项式近似取代原始公式，并对截断误差和舍入误差之间的权衡进行量化分析，您将学会如何在实际应用中选择合适的计算方法。[@problem_id:2427694]", "problem": "在一个基于强度的违约的简化形式信用风险模拟中，在恒定风险率 $\\lambda$ 下，一个公司在长度为 $\\Delta t$ 的短时间步长内违约的概率由精确表达式 $p(x) = 1 - \\exp(-x)$ 给出，其中 $x = \\lambda \\Delta t$。考虑两种用于计算小 $x$ 值下 $p(x)$ 的浮点算法：算法A直接计算 $1 - \\exp(-x)$，算法B使用二阶泰勒多项式 $x - x^{2}/2$。假设浮点运算采用“舍入到最近值”规则，单位舍入误差为 $u = 2^{-53}$，并且任何单次运算或 `exp(·)` 的浮点计算结果可以建模为精确结果乘以 $(1 + \\delta)$，其中 $|\\delta| \\leq u$，忽略 $u$ 和截断余数中的高于一阶的项。仅使用这些假设和第一性原理，确定一个正值 $x^{\\ast}$，使得算法A的前向相对误差的主导项等于算法B的前向相对误差的主导项。将你的答案四舍五入到四位有效数字。", "solution": "该问题要求找到一个值 $x^*$，使得计算 $p(x) = 1 - \\exp(-x)$ 的两种算法的前向相对误差的主导项相等。分析将在给定的针对小的正数 $x$ 的浮点误差模型下进行。\n\n对于真值 $p(x)$ 的一个近似值 $\\hat{p}(x)$，其前向相对误差定义为 $\\frac{|\\hat{p}(x) - p(x)|}{|p(x)|}$。我们将分析每种算法的该误差的主导项。\n\n算法A直接计算 $p(x)$ 为 $f_A(x) = 1 - \\exp(-x)$。浮点运算中的计算过程建模如下。设 $fl(\\cdot)$ 表示一个浮点运算。\n$\\exp(-x)$ 的计算结果为一个浮点数 $\\hat{y} = fl(\\exp(-x)) = \\exp(-x)(1 + \\delta_{1})$，其中 $|\\delta_{1}| \\leq u$。\n随后的减法运算给出最终计算值 $\\hat{p}_A(x) = fl(1 - \\hat{y}) = (1 - \\hat{y})(1 + \\delta_{2})$，其中 $|\\delta_{2}| \\leq u$。\n\n代入 $\\hat{y}$ 的表达式：\n$$\n\\hat{p}_A(x) = (1 - \\exp(-x)(1 + \\delta_{1}))(1 + \\delta_{2})\n$$\n展开此式并只保留 $\\delta_i$ 的一阶项：\n$$\n\\hat{p}_A(x) \\approx (1 - \\exp(-x) - \\delta_{1}\\exp(-x))(1 + \\delta_{2}) \\approx 1 - \\exp(-x) + \\delta_{2}(1 - \\exp(-x)) - \\delta_{1}\\exp(-x)\n$$\n绝对误差为 $E_A(x) = \\hat{p}_A(x) - p(x)$：\n$$\nE_A(x) \\approx [1 - \\exp(-x) + \\delta_{2}(1 - \\exp(-x)) - \\delta_{1}\\exp(-x)] - [1 - \\exp(-x)] = \\delta_{2}(1 - \\exp(-x)) - \\delta_{1}\\exp(-x)\n$$\n因此，算法A的相对误差为：\n$$\n\\text{RelErr}_A(x) = \\frac{|E_A(x)|}{|p(x)|} \\approx \\frac{|\\delta_{2}(1 - \\exp(-x)) - \\delta_{1}\\exp(-x)|}{|1 - \\exp(-x)|} = \\left| \\delta_{2} - \\delta_{1} \\frac{\\exp(-x)}{1 - \\exp(-x)} \\right|\n$$\n对于小的正数 $x > 0$，我们有 $\\exp(-x) \\approx 1$ 和 $1 - \\exp(-x) \\approx x$。分数 $\\frac{\\exp(-x)}{1 - \\exp(-x)} \\approx \\frac{1}{x}$，当 $x \\to 0$ 时，这个值会变得非常大。这一项主导了误差，是灾难性抵消的典型案例。通过将 $|\\delta_{1}|$ 最大化到 $u$ 来获得主导项的最坏情况相对误差：\n$$\n\\text{RelErr}_A(x) \\approx u \\frac{\\exp(-x)}{1 - \\exp(-x)}\n$$\n\n算法B使用二阶泰勒多项式 $f_B(x) = x - \\frac{x^2}{2}$。该算法的误差有两个组成部分：截断误差和舍入误差。\n截断误差来自于用有限多项式近似 $p(x)$。$p(x)$ 在 $x=0$ 处的泰勒级数为：\n$$\np(x) = 1 - \\exp(-x) = 1 - \\left(1 - x + \\frac{x^2}{2!} - \\frac{x^3}{3!} + \\dots \\right) = x - \\frac{x^2}{2} + \\frac{x^3}{6} - \\dots\n$$\n截断误差为 $T_B(x) = p(x) - f_B(x) = (\\frac{x^3}{6} - \\dots)$。主导项是 $\\frac{x^3}{6}$。\n相应的相对截断误差为：\n$$\n\\text{RelTruncErr}_B(x) = \\frac{|T_B(x)|}{|p(x)|} \\approx \\frac{|x^3/6|}{|x|} = \\frac{x^2}{6}\n$$\n计算 $x - \\frac{x^2}{2}$ 的舍入误差对于小 $x$ 来说很小，因为该运算不会发生灾难性抵消。标准分析表明，相对舍入误差的界是一个单位舍入误差 $u$ 的小倍数。对于此近似有用的那些小 $x$ 值，截断误差项 $\\frac{x^2}{6}$ 显著大于舍入误差项，后者是 $u$ 的量级。因此，算法B的主导误差是其截断误差。\n$$\n\\text{RelErr}_B(x) \\approx \\frac{x^2}{6}\n$$\n我们需要找到使主导相对误差相等的值 $x^*$：\n$$\n\\text{RelErr}_A(x^*) = \\text{RelErr}_B(x^*) \\implies u \\frac{\\exp(-x^*)}{1 - \\exp(-x^*)} = \\frac{(x^*)^2}{6}\n$$\n为了解出 $x^*$，我们对左侧的项使用小 $x$ 近似，因为问题正是在此区间内提出的。对于小的 $x^*$，$\\exp(-x^*) \\approx 1$ 且 $1 - \\exp(-x^*) \\approx x^*$。方程简化为：\n$$\n\\frac{u}{x^*} \\approx \\frac{(x^*)^2}{6}\n$$\n解出 $x^*$:\n$$\n(x^*)^3 = 6u\n$$\n$$\nx^* = (6u)^{1/3}\n$$\n现在，我们代入给定的值 $u = 2^{-53}$：\n$$\nx^* = (6 \\cdot 2^{-53})^{1/3} = 6^{1/3} \\cdot 2^{-53/3}\n$$\n我们计算其数值：\n$$\nx^* \\approx (6 \\cdot (1.110223 \\times 10^{-16}))^{1/3} = (6.661338 \\times 10^{-16})^{1/3} \\approx 8.732892 \\times 10^{-6}\n$$\n将结果四舍五入到四位有效数字，得到：\n$$\nx^* \\approx 8.733 \\times 10^{-6}\n$$\n在 $x^*$ 的这个值上，算法B的相对截断误差约为 $\\frac{(x^*)^2}{6} \\approx \\frac{(8.733 \\times 10^{-6})^2}{6} \\approx 1.27 \\times 10^{-11}$，这确实远大于 $u = 2^{-53} \\approx 1.11 \\times 10^{-16}$。这证实了忽略算法B的舍入误差是一个有效的简化。", "answer": "$$\n\\boxed{8.733 \\times 10^{-6}}\n$$", "id": "2427694"}, {"introduction": "最后的练习将解决一个不同但同样重要的挑战：在对长序列数值求和时舍入误差的累积——这是金融领域计算累计回报率等指标时的日常任务。本练习将简单的累加求和与精巧的卡恩求和算法（Kahan summation algorithm）进行对比，后者是一种能显著提高精度的补偿求和方法。通过实现和比较这两种方法，您将掌握一种编写稳健数值代码的实用工业级技术。[@problem_id:2427731]", "problem": "给定一项在计算经济学和金融领域的任务，要求量化在聚合长序列的小额资产收益时浮点舍入误差的影响，并使用一种补偿求和算法来减轻这种影响。考虑一个实值收益序列 $\\{r_i\\}_{i=1}^n$，其数学上的精确累计收益是实数和 $S = \\sum_{i=1}^n r_i$。在实际的二进制浮点运算中，加法操作由标准浮点舍入模型建模：对于任意两个实数 $a$ 和 $b$，其和的计算值为 $\\operatorname{fl}(a+b) = (a+b)(1+\\delta)$，其中 $|\\delta| \\le u$，$u$ 是单位舍入，例如对于64位二进制浮点数，$u = 2^{-53}$。在处理量级和符号各异的长序列求和时，朴素的从左到右求和会累积舍入误差，并可能丢失低位比特，特别是当将非常小的值加到一个大得多的部分和上时，这种现象在聚合长时期内的小额每日收益时尤为重要。\n\n您的任务是编写一个完整的、可运行的程序，该程序：\n- 实现两种方法，用浮点运算对给定的有序收益序列求和：\n  1. 一种朴素的从左到右求和方法，它在单个标量中累加。\n  2. 一种由 Kahan 提出的补偿求和方法，它在不改变序列顺序的情况下，跟踪并校正因舍入而丢失的低位比特。\n- 通过将每个收益解释为分母固定为 $D = 10^{16}$ 的十进制分数，并以整数形式对分子求和，使用精确有理数运算来计算数学上的精确和 $S$ 的高精度基准。具体来说，对于每个小数点后最多有 $16$ 位数字的十进制收益 $r_i$，将其解释为精确有理数 $\\frac{\\lfloor r_i \\cdot D \\rceil}{D}$，其中对于下面提供的值，舍入是精确的（对于给定的测试集，不需要舍入）。然后，使用整数精确计算 $S = \\frac{1}{D}\\sum_{i=1}^n (r_i \\cdot D)$，并且仅为了报告绝对误差的目的才将 $S$ 转换为浮点数。\n- 对于每个测试序列，报告两个浮点数形式的绝对误差：$|S_{\\text{naive}} - S|$ 和 $|S_{\\text{Kahan}} - S|$，以及一个布尔值，指示 Kahan 补偿误差是否严格小于朴素误差。\n\n重要说明：\n- 将收益视为无单位的十进制数（不要使用百分号）。不涉及任何物理单位或角度单位。\n- 所有求和必须按指定的顺序执行；不允许重排顺序。\n- 最终输出必须将所有测试用例的结果聚合到一行中，该行包含一个由方括号括起来的、逗号分隔的列表。此列表的每个元素本身都必须是一个形式为 $[e_n, e_k, b]$ 的列表，其中 $e_n$ 是朴素求和的绝对误差（一个浮点数），$e_k$ 是 Kahan 补偿求和的绝对误差（一个浮点数），如果 $e_k < e_n$，则布尔值 $b$ 等于 $\\text{True}$，否则等于 $\\text{False}$。例如：$[[e_{n,1}, e_{k,1}, b_1],[e_{n,2}, e_{k,2}, b_2],\\dots]$。\n\n测试集与覆盖范围：\n- 使用以下四个有序序列，每个序列都紧凑地指定为一个片段列表 $(v, c)$，表示值 $v$ 按该顺序连续出现 $c$ 次。所有值都是十进制字符串，所有计数都是非负整数。每个值的小数点后最多有 $16$ 位数字，因此公分母 $D = 10^{16}$ 对精确有理数求和是有效的。\n\n  1. 正常路径但易于发生对消的序列（大偏移量周围的小增量）：\n     - $\\left(\"1.0\",\\, 1\\right)$，然后是 $\\left(\"1e-16\",\\, 1000000\\right)$，然后是 $\\left(\"-1.0\",\\, 1\\right)$。数学上的精确和为 $S = 10^{6}\\cdot 10^{-16} = 10^{-10}$。\n  2. 围绕零的轻微不平衡的微小正负收益：\n     - $\\left(\"1e-8\",\\, 100000\\right)$，然后是 $\\left(\"-1e-8\",\\, 99999\\right)$。数学上的精确和为 $S = 10^{-8}$。\n  3. 全为零的边界情况：\n     - $\\left(\"0.0\",\\, 50000\\right)$。数学上的精确和为 $S = 0$。\n  4. 量级混合、存在严重对消且包含许多微小项的序列：\n     - $\\left(\"1e-16\",\\, 300000\\right)$，然后是 $\\left(\"1.0\",\\, 1\\right)$，然后是 $\\left(\"-1.0\",\\, 1\\right)$，然后是 $\\left(\"1e-16\",\\, 300000\\right)$，然后是 $\\left(\"-1e-16\",\\, 600000\\right)$。数学上的精确和为 $S = 0$。\n\n要求：\n- 按规定实现两种求和方法和精确有理数基准。\n- 对于四个测试序列中的每一个，计算并报告三元组 $[|S_{\\text{naive}}-S|,\\, |S_{\\text{Kahan}}-S|,\\, (|S_{\\text{Kahan}}-S| < |S_{\\text{naive}}-S|)]$。\n- 您的程序应生成单行输出，其中包含这四个三元组的列表，格式完全如下：$[[e_{n,1},e_{k,1},b_1],[e_{n,2},e_{k,2},b_2],[e_{n,3},e_{k,3},b_3],[e_{n,4},e_{k,4},b_4]]$。", "solution": "我们从标准的浮点加法误差模型开始。设 $a$ 和 $b$ 为实数，并假设我们在二进制浮点运算中通过舍入到最近来计算它们的和。计算结果满足\n$$\n\\operatorname{fl}(a+b) \\;=\\; (a+b)(1+\\delta), \\quad |\\delta| \\le u,\n$$\n其中 $u$ 是单位舍入。对于64位二进制格式，有 $u = 2^{-53} \\approx 1.11 \\times 10^{-16}$。在对一个长序列 $\\{r_i\\}_{i=1}^n$ 求和时，朴素的从左到右算法通过 $s \\leftarrow \\operatorname{fl}(s + r_i)$ 更新一个运行总和 $s$，其中 $i=1,\\dots,n$。朴素求和的累积前向误差可以通过众所周知的后向误差分析结果来界定：粗略地说，绝对误差的增长数量级为 $u$ 乘以各项绝对值之和，即\n$$\n|s_{\\text{naive}} - S| \\lesssim \\gamma_n \\sum_{i=1}^n |r_i|, \\quad \\gamma_n = \\frac{nu}{1 - nu},\n$$\n只要 $nu < 1$ 成立，这就凸显了误差存在 $O(nu)$ 的增长，并且误差对排序和对消结构很敏感。特别是，当将一个非常小的 $r_i$ 加到一个大得多的运行总和 $s$ 中时，如果 $|r_i| < \\tfrac{1}{2}\\operatorname{ulp}(s)$，那么 $s + r_i$ 会舍入回 $s$，而 $r_i$ 的低位比特实际上被丢弃了。当聚合许多小的每日收益，且时间跨度长、并因大的收益或亏损而产生偏移时，这种现象在经济学上就变得很重要。\n\n为了减轻这种损失，Kahan 补偿求和引入了一个辅助变量 $c$，用于跟踪因舍入而丢失的低位比特的运行补偿。其思想是从下一个加数中预先减去补偿，并通过上次加法中观察到的舍入误差来更新补偿。具体地，设 $s$ 为运行总和， $c$ 为补偿，两者都初始化为 $0$。对于每个加数 $x$，定义补偿后的加数 $y = x - c$，并形成暂定和 $t = s + y$。新的补偿是 $y$ 中未被 $t$ 捕获的部分，代数上表示为 $c \\leftarrow (t - s) - y$，并且运行总和更新为 $s \\leftarrow t$。在精确算术中，$(t - s) = y$，所以 $c$ 将保持为零，但在浮点算术中，由于 $s + y$ 的舍入，$(t - s)$ 可能与 $y$ 不同，这个差值被存储在 $c$ 中，以便在下一步中反馈。这为丢失的低位比特提供了一阶校正，并在许多易于发生对消的情况下显著减少了误差，其误差通常被一个与 $n$ 无关的 $u$ 的常数倍所界定。\n\n为了进行基准测试，我们需要一个数学上精确和 $S = \\sum_{i=1}^n r_i$ 的基准。由于测试序列表示为小数部分最多16位的十进制字符串，每个 $r_i$ 都可以精确地表示为分母为 $D = 10^{16}$ 的有理数。因此，如果 $r_i$ 写成一个十进制字符串，则 $r_i \\cdot D$ 是一个整数，精确和为\n$$\nS \\;=\\; \\frac{1}{D} \\sum_{i=1}^n \\left(r_i \\cdot D\\right), \\qquad D = 10^{16}.\n$$\n我们可以通过解析每个十进制字符串 $r_i$ 并乘以 $D$，使用整数算术精确计算分子 $\\sum_{i=1}^n (r_i \\cdot D)$，并且仅在最后为了计算绝对误差 $|S_{\\text{naive}} - S|$ 和 $|S_{\\text{Kahan}} - S|$ 时才将 $S$ 转换为浮点数。\n\n算法设计：\n- 实现一个生成器，按所提供的顺序迭代每个测试序列，为朴素求和与 Kahan 求和生成浮点值。\n- 将朴素求和实现为重复的浮点加法。\n- 实现 Kahan 补偿求和，其变量 $s$ 和 $c$ 初始化为 $0$，并按如下方式更新\n  $$\n  y \\leftarrow x - c,\\quad t \\leftarrow s + y,\\quad c \\leftarrow (t - s) - y,\\quad s \\leftarrow t.\n  $$\n- 通过对分母为 $D = 10^{16}$ 的整数分子求和来实现精确有理数基准：对于每个片段 $(v, c)$，精确计算整数 $n_v = v \\cdot D$ 并将 $c \\cdot n_v$ 加到整数累加器中。精确和为 $S = N / D$，其中 $N$ 是整数总和。这对给定的测试集是有效的，因为每个 $v$ 的小数点后最多有16位，所以 $v \\cdot D$ 是一个整数。\n- 对于每个测试用例，计算绝对误差 $e_n = |S_{\\text{naive}} - S|$ 和 $e_k = |S_{\\text{Kahan}} - S|$，以及布尔值 $b = (e_k < e_n)$。\n- 按照四个指定序列的顺序，生成包含四个三元组 $[e_n, e_k, b]$ 的列表的单行最终输出。\n\n测试集解释：\n1. 序列1：$\\left(\"1.0\",\\, 1\\right)$，$\\left(\"1e-16\",\\, 1000000\\right)$，$\\left(\"-1.0\",\\, 1\\right)$。这里 $S = 10^6 \\cdot 10^{-16} = 10^{-10}$。朴素求和在将每个 $10^{-16}$ 加到 $1.0$ 时通常会丢失它，导致在最后的 $-1.0$ 操作后结果接近 $0$，而 Kahan 求和会在 $c$ 中恢复低位比特，得到接近 $10^{-10}$ 的结果。\n2. 序列2：$\\left(\"1e-8\",\\, 100000\\right)$，$\\left(\"-1e-8\",\\, 99999\\right)$。这里 $S = 10^{-8}$。两种方法都应该表现良好；绝对误差预计与 $S$ 相比会非常小。\n3. 序列3：$\\left(\"0.0\",\\, 50000\\right)$。这里 $S = 0$。两种方法在浮点算术中都应精确得到 $0$，导致绝对误差为零。\n4. 序列4：$\\left(\"1e-16\",\\, 300000\\right)$，$\\left(\"1.0\",\\, 1\\right)$，$\\left(\"-1.0\",\\, 1\\right)$，$\\left(\"1e-16\",\\, 300000\\right)$，$\\left(\"-1e-16\",\\, 600000\\right)$。这里 $S = 0$。长串的微小项与大量级对消交织在一起，给两种方法都带来了压力；补偿方法减少了舍入误差的累积。\n\n程序必须实现这些步骤并以精确格式打印单行输出：\n$$\n\\left[\\,[e_{n,1},e_{k,1},b_1],\\,[e_{n,2},e_{k,2},b_2],\\,[e_{n,3},e_{k,3},b_3],\\,[e_{n,4},e_{k,4},b_4]\\,\\right].\n$$", "answer": "```python\nimport math\nfrom decimal import Decimal, getcontext\n\n# No external input; all parameters are embedded per the problem statement.\n\ndef naive_sum(seq_iter):\n    \"\"\"Naive left-to-right summation over an iterator of floats.\"\"\"\n    s = 0.0\n    for x in seq_iter:\n        s += x\n    return s\n\ndef kahan_sum(seq_iter):\n    \"\"\"Kahan compensated summation over an iterator of floats.\"\"\"\n    s = 0.0\n    c = 0.0\n    for x in seq_iter:\n        y = x - c\n        t = s + y\n        c = (t - s) - y\n        s = t\n    return s\n\ndef float_generator_from_segments(segments):\n    \"\"\"\n    Yield floats in the specified order for segments specified as\n    a list of tuples: (value_string, count_int).\n    \"\"\"\n    for v_str, cnt in segments:\n        x = float(v_str)\n        for _ in range(cnt):\n            yield x\n\ndef exact_sum_from_segments(segments, D=10**16):\n    \"\"\"\n    Compute the exact rational sum as N/D where D=10^16, by summing integer numerators.\n    Each value v_str must be a decimal with at most 16 digits after the decimal point.\n    Returns the exact sum as a float for error comparison.\n    \"\"\"\n    # Use high precision Decimal to convert values exactly, then multiply by D to get integer.\n    getcontext().prec = 50\n    D_dec = Decimal(D)\n    N = 0  # integer numerator\n    for v_str, cnt in segments:\n        v_dec = Decimal(v_str)\n        n_v = int((v_dec * D_dec).to_integral_exact())  # exact integer for given test suite\n        if cnt:\n            N += n_v * cnt\n    # Convert to float for error measurement; loss here is negligible vs measured errors\n    return N / D\n\ndef compute_case(segments):\n    \"\"\"Compute absolute errors for naive and Kahan sums against exact rational baseline.\"\"\"\n    true_sum = exact_sum_from_segments(segments)\n    nsum = naive_sum(float_generator_from_segments(segments))\n    ksum = kahan_sum(float_generator_from_segments(segments))\n    en = abs(nsum - true_sum)\n    ek = abs(ksum - true_sum)\n    return [en, ek, ek  en]\n\ndef solve():\n    # Define the test cases as per the problem statement.\n    test_cases = [\n        # 1) (\"1.0\", 1), (\"1e-16\", 1000000), (\"-1.0\", 1)\n        [(\"1.0\", 1), (\"1e-16\", 1_000_000), (\"-1.0\", 1)],\n        # 2) (\"1e-8\", 100000), (\"-1e-8\", 99999)\n        [(\"1e-8\", 100_000), (\"-1e-8\", 99_999)],\n        # 3) (\"0.0\", 50000)\n        [(\"0.0\", 50_000)],\n        # 4) (\"1e-16\", 300000), (\"1.0\", 1), (\"-1.0\", 1), (\"1e-16\", 300000), (\"-1e-16\", 600000)\n        [(\"1e-16\", 300_000), (\"1.0\", 1), (\"-1.0\", 1), (\"1e-16\", 300_000), (\"-1e-16\", 600_000)],\n    ]\n\n    results = []\n    for segments in test_cases:\n        res = compute_case(segments)\n        results.append(res)\n\n    # Print in the exact required single-line format.\n    # Convert booleans and floats to their standard string representations.\n    def fmt(item):\n        if isinstance(item, list):\n            return \"[\" + \",\".join(fmt(x) for x in item) + \"]\"\n        if isinstance(item, bool):\n            return \"True\" if item else \"False\"\n        # float or int\n        return str(item)\n\n    print(fmt(results))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2427731"}]}