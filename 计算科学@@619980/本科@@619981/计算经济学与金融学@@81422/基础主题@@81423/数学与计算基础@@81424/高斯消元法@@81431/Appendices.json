{"hands_on_practices": [{"introduction": "高斯消元法是求解线性方程组的核心算法。第一个练习将引导你亲手实践这一过程，通过一系列初等行变换，将一个具体的 $3 \\times 3$ 线性方程组转化为易于求解的行阶梯形矩阵。掌握这个基本功，不仅能让你熟悉算法的机械步骤，更能为你理解其在更复杂经济模型中的应用打下坚实的基础。[@problem_id:23125]", "problem": "考虑下列关于三元变量 $x, y,$ 和 $z$ 的线性方程组：\n$$\n\\begin{cases}\nx + y + z = 4 \\\\\n2x - y + z = 8 \\\\\nx - 2y - z = 1\n\\end{cases}\n$$\n使用高斯消元法，将方程组变换为行阶梯形，并求出变量 $z$ 的值。", "solution": "我们写出该方程组的增广矩阵：\n$$\n\\left[\n\\begin{array}{ccc|c}\n1 & 1 & 1 & 4 \\\\\n2 & -1 & 1 & 8 \\\\\n1 & -2 & -1 & 1\n\\end{array}\n\\right].\n$$\n第一步：执行行变换 $R_2\\leftarrow R_2-2R_1$ 和 $R_3\\leftarrow R_3-R_1$，消去第二行和第三行中的 $x$：\n$$\nR_2: (2-2\\cdot1,\\;-1-2\\cdot1,\\;1-2\\cdot1\\;|\\;8-2\\cdot4)\n=(0,\\,-3,\\,-1\\;|\\;0),\n$$\n$$\nR_3: (1-1,\\;-2-1,\\;-1-1\\;|\\;1-4)\n=(0,\\,-3,\\,-2\\;|\\;-3).\n$$\n矩阵变为\n$$\n\\left[\n\\begin{array}{ccc|c}\n1 & 1 & 1 & 4 \\\\\n0 & -3 & -1 & 0 \\\\\n0 & -3 & -2 & -3\n\\end{array}\n\\right].\n$$\n第二步：执行行变换 $R_3\\leftarrow R_3-R_2$，消去第三行中的 $y$：\n$$\nR_3: (0-0,\\;-3-(-3),\\;-2-(-1)\\;|\\;-3-0)\n=(0,\\;0,\\;-1\\;|\\;-3).\n$$\n现在矩阵为行阶梯形：\n$$\n\\left[\n\\begin{array}{ccc|c}\n1 & 1 & 1 & 4 \\\\\n0 & -3 & -1 & 0 \\\\\n0 & 0 & -1 & -3\n\\end{array}\n\\right].\n$$\n由第三行可得\n$$\n-1\\cdot z=-3,\n$$\n因此\n$$\nz=3.\n$$", "answer": "$$\\boxed{3}$$", "id": "23125"}, {"introduction": "理论上的算法在实际计算中常常会遇到精度问题，尤其是在金融建模中。这个练习模拟了一个基于无套利定价原理的场景，揭示了在有限精度计算下，朴素的高斯消元法可能因数值不稳定性而产生严重错误，甚至导致虚假的套利结论。通过对比不带主元选择和带主元选择的计算结果，你将深刻理解主元选择策略在保证计算结果准确性中的关键作用。[@problem_id:2396422]", "problem": "考虑一个具有完备市场的两状态、单期经济。令 $q_1$ 和 $q_2$ 表示 Arrow–Debreu 状态价格（分别为在状态1或状态2下交割的一单位消费的今日价格）。根据无套利原则，任何交易资产 $j$（其在两种状态下的支付分别为 $x_{1j}$ 和 $x_{2j}$）的价格 $p_j$ 满足以下系统\n$$\np_j \\;=\\; q_1 x_{1j} \\;+\\; q_2 x_{2j}, \\quad j \\in \\{1,2\\}.\n$$\n您观察到两种交易资产，其支付和价格如下（所有金额单位均为美元）：\n- 资产 $1$：支付向量 $(x_{11}, x_{21}) = (0.001234,\\, 1.000000)$，价格 $p_1 = 1.001234$。\n- 资产 $2$：支付向量 $(x_{12}, x_{22}) = (1.000000,\\, 1.000000)$，价格 $p_2 = 2.000000$。\n\n假设市场是无套利且完备的。一位分析师试图通过使用高斯消元法求解关于 $(q_1, q_2)$ 的 $2\\times 2$ 线性系统来恢复 $(q_1, q_2)$。然而，该分析师在算法的每个中间步骤中都使用四舍五入到三位有效数字的算术。\n\n任务：\n1) 以 $A \\boldsymbol{q} = \\boldsymbol{p}$ 的形式建立线性系统，其中\n$$\nA \\;=\\; \\begin{pmatrix}\n0.001234 & 1.000000 \\\\\n1.000000 & 1.000000\n\\end{pmatrix}, \n\\quad \n\\boldsymbol{q} \\;=\\; \\begin{pmatrix} q_1 \\\\ q_2 \\end{pmatrix}, \n\\quad \n\\boldsymbol{p} \\;=\\; \\begin{pmatrix} 1.001234 \\\\ 2.000000 \\end{pmatrix}.\n$$\n2) 对增广矩阵执行不带主元选择的高斯消元法，所有算术运算（包括每个中间结果）都通过四舍五入保留三位有效数字。将得到的估计值记为 $(\\tilde{q}_1, \\tilde{q}_2)$。\n3) 使用 $(\\tilde{q}_1, \\tilde{q}_2)$，计算一个在两种状态下支付为 $(1, 0)$ 的 Arrow–Debreu 证券的模型隐含无套利价值 $\\tilde{v}$。\n4) 在同一个无套利市场中，该 Arrow–Debreu 证券的观测市场价值 $v$ 与精确求解上述系统的真实状态价格相符（因此 $v = q_1$）。根据所给数据，观测到的 $v$ 等于 $1.000000$。因此，使用不带主元选择的高斯消元法的分析师会声称存在一个虚假套利机会，即通过做空观测到的证券，并以其模型隐含价值买入其复制投资组合，单位利润为 $\\pi = v - \\tilde{v}$。\n5) 现在重复消元过程，但使用部分主元法（在消元前，总是通过交换将可用的绝对值最大的主元置于对角线上），每一步仍然使用三位有效数字的算术，以获得 $(\\hat{q}_1, \\hat{q}_2)$ 和对应的 $\\hat{v}$。解释为什么这样做可以消除虚假套利。\n\n作为最终答案，报告在步骤4中计算的单位虚假套利利润 $\\pi$，四舍五入至三位有效数字。最终利润以美元表示。", "solution": "对问题陈述进行有效性评估。\n\n**步骤1：提取已知条件**\n- 资产价格的方程组为 $p_j = q_1 x_{1j} + q_2 x_{2j}$，对于 $j \\in \\{1, 2\\}$。\n- 资产 $1$：支付向量 $(x_{11}, x_{21}) = (0.001234, 1.000000)$，价格 $p_1 = 1.001234$。\n- 资产 $2$：支付向量 $(x_{12}, x_{22}) = (1.000000, 1.000000)$，价格 $p_2 = 2.000000$。\n- 线性系统以矩阵形式 $A \\boldsymbol{q} = \\boldsymbol{p}$ 给出：\n$$\nA = \\begin{pmatrix} 0.001234 & 1.000000 \\\\ 1.000000 & 1.000000 \\end{pmatrix}, \\quad \\boldsymbol{q} = \\begin{pmatrix} q_1 \\\\ q_2 \\end{pmatrix}, \\quad \\boldsymbol{p} = \\begin{pmatrix} 1.001234 \\\\ 2.000000 \\end{pmatrix}\n$$\n- 所有算术运算在每个中间步骤都需四舍五入至$3$位有效数字。\n- 支付为 $(1, 0)$ 的 Arrow-Debreu 证券的真实价值是 $v = q_1 = 1.000000$。\n- 虚假套利利润定义为 $\\pi = v - \\tilde{v}$，其中 $\\tilde{v}$ 是使用不带主元选择的高斯消元法计算出的价值。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，植根于资产定价基本定理和标准数值线性代数。这是一个适定问题；矩阵 $A$ 是非奇异的，因为其行列式为 $0.001234 \\times 1.000000 - 1.000000 \\times 1.000000 = -0.998766 \\neq 0$，这保证了 $(q_1, q_2)$ 存在唯一解。该问题是客观、完整且不包含矛盾的。数据值的选择旨在说明一个众所周知的数值不稳定性问题，这是计算科学中一种标准的教学手段。该问题是可形式化的，并与指定主题相关。\n\n**步骤3：结论与行动**\n该问题有效。将提供完整解答。\n\n通过直接代数运算可以找到该系统的精确解。用第二个方程减去第一个方程得到 $(1 - 0.001234)q_1 = 2 - 1.001234$，简化为 $0.998766 q_1 = 0.998766$，意味着 $q_1 = 1$。代回可得 $q_2 = 1$。真实的状态价格向量是 $(q_1, q_2) = (1, 1)$。\n\n我们现在使用有限精度算术来分析解。\n\n**第1部分：不带主元选择的高斯消元法**\n\n首先，我们建立增广矩阵 $[A|\\boldsymbol{p}]$ 并将所有元素四舍五入到$3$位有效数字。\n$$\n[A|\\boldsymbol{p}] = \\left[ \\begin{array}{cc|c}\n0.001234 & 1.000000 & 1.001234 \\\\\n1.000000 & 1.000000 & 2.000000\n\\end{array} \\right] \\quad \\rightarrow \\quad \\left[ \\begin{array}{cc|c}\n0.00123 & 1.00 & 1.00 \\\\\n1.00 & 1.00 & 2.00\n\\end{array} \\right]\n$$\n主元是 $a_{11} = 0.00123$。第二行的乘数是 $m_{21} = \\frac{a_{21}}{a_{11}} = \\frac{1.00}{0.00123}$。\n计算：$1.00 \\div 0.00123 \\approx 813.008...$。四舍五入到$3$位有效数字得到 $m_{21} = 813$。\n我们执行行操作 $R_2 \\leftarrow R_2 - m_{21} R_1$。\n第二行的新元素计算如下：\n$a'_{22} = a_{22} - m_{21} \\times a_{12} = 1.00 - 813 \\times 1.00 = 1.00 - 813 = -812$。\n$p'_{2} = p_{2} - m_{21} \\times p_{1} = 2.00 - 813 \\times 1.00 = 2.00 - 813 = -811$。\n系统变为上三角形式：\n$$\n\\left[ \\begin{array}{cc|c}\n0.00123 & 1.00 & 1.00 \\\\\n0 & -812 & -811\n\\end{array} \\right]\n$$\n现在我们执行回代以求得近似解 $(\\tilde{q}_1, \\tilde{q}_2)$。\n由第二行得：$-812 \\tilde{q}_2 = -811$。\n$\\tilde{q}_2 = \\frac{-811}{-812} \\approx 0.99876...$。四舍五入到$3$位有效数字：$\\tilde{q}_2 = 0.999$。\n由第一行得：$0.00123 \\tilde{q}_1 + 1.00 \\tilde{q}_2 = 1.00$。\n代入 $\\tilde{q}_2$：$0.00123 \\tilde{q}_1 + 1.00 \\times 0.999 = 1.00$。\n乘积 $1.00 \\times 0.999 = 0.999$。\n$0.00123 \\tilde{q}_1 + 0.999 = 1.00$。\n$0.00123 \\tilde{q}_1 = 1.00 - 0.999 = 0.001$。这个中间结果只有$1$位有效数字。\n$\\tilde{q}_1 = \\frac{0.001}{0.00123} \\approx 0.81300...$。四舍五入到$3$位有效数字：$\\tilde{q}_1 = 0.813$。\n因此，不带主元选择的解是 $(\\tilde{q}_1, \\tilde{q}_2) = (0.813, 0.999)$。\n\n支付为 $(1, 0)$ 的 Arrow-Debreu 证券的模型隐含价值是 $\\tilde{v} = 1 \\cdot \\tilde{q}_1 + 0 \\cdot \\tilde{q}_2 = \\tilde{q}_1 = 0.813$。\n真实市场价值为 $v = 1.000000$。\n虚假套利利润为 $\\pi = v - \\tilde{v} = 1.000 - 0.813 = 0.187$。\n\n**第2部分：带部分主元选择的高斯消元法**\n\n我们从相同的四舍五入后的增广矩阵开始：\n$$\n\\left[ \\begin{array}{cc|c}\n0.00123 & 1.00 & 1.00 \\\\\n1.00 & 1.00 & 2.00\n\\end{array} \\right]\n$$\n在第一列中， $|a_{21}| = 1.00 > |a_{11}| = 0.00123$。因此，我们交换第1行和第2行。\n$$\n\\left[ \\begin{array}{cc|c}\n1.00 & 1.00 & 2.00 \\\\\n0.00123 & 1.00 & 1.00\n\\end{array} \\right]\n$$\n现在主元是 $a_{11} = 1.00$。乘数是 $m_{21} = \\frac{a_{21}}{a_{11}} = \\frac{0.00123}{1.00} = 0.00123$。\n我们执行行操作 $R_2 \\leftarrow R_2 - m_{21} R_1$。\n第二行的新元素计算如下：\n$a'_{22} = a_{22} - m_{21} \\times a_{12} = 1.00 - 0.00123 \\times 1.00 = 1.00 - 0.00123 = 0.99877$。四舍五入到$3$位有效数字得到 $0.999$。\n$p'_{2} = p_{2} - m_{21} \\times p_{1} = 1.00 - 0.00123 \\times 2.00 = 1.00 - 0.00246 = 0.99754$。四舍五入到$3$位有效数字得到 $0.998$。\n系统变为：\n$$\n\\left[ \\begin{array}{cc|c}\n1.00 & 1.00 & 2.00 \\\\\n0 & 0.999 & 0.998\n\\end{array} \\right]\n$$\n我们对解 $(\\hat{q}_1, \\hat{q}_2)$ 执行回代。\n由第二行得：$0.999 \\hat{q}_2 = 0.998$。\n$\\hat{q}_2 = \\frac{0.998}{0.999} \\approx 0.99899...$。四舍五入到$3$位有效数字：$\\hat{q}_2 = 0.999$。\n由第一行得：$1.00 \\hat{q}_1 + 1.00 \\hat{q}_2 = 2.00$。\n$1.00 \\hat{q}_1 + 1.00 \\times 0.999 = 2.00$。\n$1.00 \\hat{q}_1 + 0.999 = 2.00$。\n$1.00 \\hat{q}_1 = 2.00 - 0.999 = 1.001$。四舍五入到$3$位有效数字得到 $1.00$。\n$1.00 \\hat{q}_1 = 1.00$，所以 $\\hat{q}_1 = 1.00$。\n带部分主元选择的解是 $(\\hat{q}_1, \\hat{q}_2) = (1.00, 0.999)$。\n\n新的模型隐含价值是 $\\hat{v} = \\hat{q}_1 = 1.00$。\n现在的套利利润是 $\\hat{\\pi} = v - \\hat{v} = 1.00 - 1.00 = 0$。\n\n**解释**\n\n虚假套利是不带主元选择的高斯消元法算法中数值不稳定性的直接后果。矩阵 $A$ 的元素数量级差异巨大。\n\n当不使用主元选择时，小元素 $a_{11} = 0.00123$ 被选为主元。这导致一个非常大的乘数，$m_{21} = 813$。在消元步骤 $R_2 \\leftarrow R_2 - m_{21} R_1$ 中，第2行中的原始信息被一个大数的减法有效地破坏了。$m_{21} \\times a_{12} = 813$ 这一项淹没了 $a_{22}=1.00$ 的原始值。这在随后的回代步骤中导致了灾难性抵消（$1.00 - 0.999 = 0.001$），其中两个几乎相等的数字相减，导致有效数字从$3$位损失到$1$位。最终结果 $\\tilde{q}_1 = 0.813$ 与真实值 $q_1 = 1$ 相比严重不准确。\n\n部分主元法纠正了这种不稳定性。通过交换行，它确保主元是该列中可用的绝对值最大的元素。在这种情况下，$1.00$ 成为主元。这保证了乘数 $m_{21} = 0.00123$ 很小（具体来说， $|m_{ij}| \\le 1$）。在执行消元步骤时，我们减去一个小的量，这保留了原始矩阵条目的有效数字。由此产生的计算是数值稳定的，得到 $\\hat{q}_1 = 1.00$，这个结果在$3$位有效数字的工作精度下是准确的。这个准确的状态价格导出的模型价值 $\\hat{v}$ 与观测到的市场价值 $v$ 相匹配，从而正确地表明不存在套利机会。", "answer": "$$\n\\boxed{0.187}\n$$", "id": "2396422"}, {"introduction": "在计算经济学中，我们常常需要对同一模型、不同参数（例如不同的市场需求）进行反复求解。这个练习将引导你运用高斯消元法的一个重要成果——$LU$ 分解，来高效地解决一个经典的列昂惕夫投入产出模型 (Leontief input-output model)。通过对同一系统矩阵处理上千个不同的需求向量，你将亲身体会到“一次分解，多次求解”的计算威力，这是大规模经济分析和仿真的基石。[@problem_id:2396443]", "problem": "考虑一个来自计算经济学的静态投入产出模型（Leontief 系统），其中总产出向量 $x$ 必须满足 $(I - A)\\,x = d$。这里，$A$ 是一个给定的非负产业间系数矩阵，$d$ 是一个最终需求向量。假设矩阵 $I - A$ 是非奇异的。使用的基本原理是，任何具有非奇异矩阵 $A$ 的系统 $A\\,x = b$ 都可以通过高斯消元法求解。高斯消元法执行一系列初等行变换和行交换，将 $A$ 转换为一个上三角矩阵 $U$，同时记录下构成单位下三角矩阵 $L$ 的乘数以及由置换向量编码的行交换序列。这将高斯消元法的效果紧凑地表示为一个分解 $P\\,A = L\\,U$，其中 $P$ 是由行交换定义的置换矩阵。一旦 $L$ 和 $U$ 可用，任何右端项 $b$ 都可以通过两次三角求解来解决：通过前向替换求解 $L\\,y = P\\,b$，然后通过反向替换求解 $U\\,x = y$。在初始的 $O(n^3)$ 级别分解成本之后，这将每个右端项的求解成本降低到 $O(n^2)$ 级别的算术运算，这在为许多需求向量 $d_i$ 求解同一系统时至关重要。\n\n您的任务是编写一个完整、可运行的程序，该程序：\n- 对于下方的每个测试用例，根据给定的 $A$ 构建 $B = I - A$，然后进行一次带部分主元的高斯消元计算，以获得上三角矩阵 $U$、相关的单位下三角矩阵 $L$（由消元乘数编码）和编码行交换的置换向量，然后使用这些结果快速求解多个 $d$ 对应的 $B\\,x = d$，而无需重新计算消元过程。\n- 仅使用分解输出，通过置换、前向替换和反向替换来求解每个右端项。\n- 生成所要求的数值聚合结果。\n\n仅使用不带物理单位的纯数字。不涉及角度。百分比（如果概念上出现）必须表示为小数。\n\n测试套件和要求的输出：\n1) 通用重复求解场景 ($3\\times 3$)。令\n$$\nA_1 = \\begin{bmatrix}\n0.2 & 0.1 & 0.05 \\\\\n0.05 & 0.25 & 0.1 \\\\\n0.1 & 0.05 & 0.2\n\\end{bmatrix}, \\quad\nB_1 = I - A_1.\n$$\n对于每个整数 $i \\in \\{1,2,\\dots,1000\\}$，定义最终需求向量\n$$\nd_i = \\begin{bmatrix}\n0.5 + 0.0003\\,i \\\\\n0.4 + 0.0001\\,i \\\\\n0.3 + 0.0002\\,i\n\\end{bmatrix}.\n$$\n使用对 $B_1$ 的单次高斯消元，通过重用相同的 $U$ 和置换向量，并采用前向和反向替换，求解所有 $i$ 的 $B_1\\,x_i = d_i$。报告以下三个浮点输出：$i = 1$、$i = 500$ 和 $i = 1000$ 时的总产出 $t_i = \\mathbf{1}^\\top x_i$（其中 $\\mathbf{1}$ 是全一向量）。\n\n2) 具有两个需求的更大系统 ($4\\times 4$)。令\n$$\nA_2 = \\begin{bmatrix}\n0.1 & 0.05 & 0.02 & 0.0 \\\\\n0.03 & 0.2 & 0.04 & 0.01 \\\\\n0.0 & 0.05 & 0.15 & 0.02 \\\\\n0.02 & 0.0 & 0.03 & 0.1\n\\end{bmatrix}, \\quad\nB_2 = I - A_2.\n$$\n对以下两个需求分别求解 $B_2\\,x = d$\n$$\nd^{(a)} = \\begin{bmatrix} 0.2 \\\\ 0.1 \\\\ 0.15 \\\\ 0.05 \\end{bmatrix}, \\quad\nd^{(b)} = \\begin{bmatrix} 0.3 \\\\ 0.0 \\\\ 0.2 \\\\ 0.1 \\end{bmatrix}.\n$$\n报告 $d^{(a)}$ 和 $d^{(b)}$ 情况下第二部门的产出（$x$ 的第二个分量）。\n\n3) 边界情况（单位系统，$2\\times 2$）。令\n$$\nA_3 = \\begin{bmatrix}\n0 & 0 \\\\\n0 & 0\n\\end{bmatrix}, \\quad\nB_3 = I - A_3 = I.\n$$\n对以下三个需求分别求解\n$$\nd^{(1)} = \\begin{bmatrix} 0.7 \\\\ 0.9 \\end{bmatrix}, \\quad\nd^{(2)} = \\begin{bmatrix} 0.0 \\\\ 0.12345 \\end{bmatrix}, \\quad\nd^{(3)} = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}.\n$$\n报告这三个需求下解 $x$ 的第一个分量。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序必须完全如下：\n- 测试 1 的三个值（$t_1$、$t_{500}$、$t_{1000}$），后接测试 2 的两个值（$d^{(a)}$ 和 $d^{(b)}$ 的第二个分量），再后接测试 3 的三个值（$d^{(1)}$、$d^{(2)}$ 和 $d^{(3)}$ 的第一个分量）。\n- 具体来说，打印的行必须如下所示\n$$\n[\\,v_1,v_2,v_3,v_4,v_5,v_6,v_7,v_8\\,],\n$$\n其中每个 $v_j$ 是您的程序按上述顺序计算的浮点数。", "solution": "所述问题是有效的。它定义良好，其科学基础是经济学中成熟的 Leontief 投入产出模型和数值线性代数中的 LU 分解方法。所有必需的数据和条件都已提供，并且它们是一致且明确的。我们将继续进行求解。\n\n基本任务是在给定技术矩阵 $A$ 的情况下，为不同的需求向量 $d$ 求解线性方程组 $(I - A)x = d$。令 $B = I - A$。我们需要求解 $B x = d$。对于每个测试用例，矩阵 $B$ 是固定的，而向量 $d$ 是变化的。这种结构使得首先计算 $B$ 的带部分主元的 LU 分解，然后重用此分解来求解每个 $d$ 变得非常高效。\n\n带部分主元的 LU 分解会找到一个置换矩阵 $P$、一个单位下三角矩阵 $L$ 和一个上三角矩阵 $U$，使得 $P B = L U$。原始系统 $B x = d$ 等价于 $P B x = P d$，即 $L U x = P d$。我们可以通过一个两步过程来求解：\n1.  首先，使用前向替换求解下三角系统 $L y = P d$，得到向量 $y$。\n2.  然后，使用反向替换求解上三角系统 $U x = y$，得到最终解向量 $x$。\n\n对于一个 $n \\times n$ 矩阵，初始分解是一个计算密集型操作，复杂度为 $O(n^3)$。然而，每次使用该分解进行的后续求解仅需 $O(n^2)$ 次运算。这是我们必须实现的原理。我们将使用提供此过程优化实现的库函数。\n\n### 测试用例 1\n\n技术矩阵为：\n$$\nA_1 = \\begin{bmatrix}\n0.2 & 0.1 & 0.05 \\\\\n0.05 & 0.25 & 0.1 \\\\\n0.1 & 0.05 & 0.2\n\\end{bmatrix}\n$$\nLeontief 矩阵 $B_1 = I - A_1$ 为：\n$$\nB_1 = \\begin{bmatrix}\n0.8 & -0.1 & -0.05 \\\\\n-0.05 & 0.75 & -0.1 \\\\\n-0.1 & -0.05 & 0.8\n\\end{bmatrix}\n$$\n我们对 $B_1$ 进行一次 LU 分解。\n对于 $i \\in \\{1, 2, \\dots, 1000\\}$，需求向量 $d_i$ 定义为：\n$$\nd_i = \\begin{bmatrix}\n0.5 + 0.0003 i \\\\\n0.4 + 0.0001 i \\\\\n0.3 + 0.0002 i\n\\end{bmatrix}\n$$\n我们使用计算出的分解来求解 $i \\in \\{1, 500, 1000\\}$ 时的 $B_1 x_i = d_i$。对于每个解 $x_i$，我们计算总产出 $t_i = \\mathbf{1}^\\top x_i = \\sum_{j=1}^3 (x_i)_j$。这三个值 $t_1$、$t_{500}$ 和 $t_{1000}$ 是需要报告的前三个结果。\n\n### 测试用例 2\n\n技术矩阵为：\n$$\nA_2 = \\begin{bmatrix}\n0.1 & 0.05 & 0.02 & 0.0 \\\\\n0.03 & 0.2 & 0.04 & 0.01 \\\\\n0.0 & 0.05 & 0.15 & 0.02 \\\\\n0.02 & 0.0 & 0.03 & 0.1\n\\end{bmatrix}\n$$\nLeontief 矩阵 $B_2 = I - A_2$ 为：\n$$\nB_2 = \\begin{bmatrix}\n0.9 & -0.05 & -0.02 & 0.0 \\\\\n-0.03 & 0.8 & -0.04 & -0.01 \\\\\n0.0 & -0.05 & 0.85 & -0.02 \\\\\n-0.02 & 0.0 & -0.03 & 0.9\n\\end{bmatrix}\n$$\n我们对 $B_2$ 进行一次 LU 分解。然后我们对两个独立的需求向量求解 $B_2 x = d$：\n$$\nd^{(a)} = \\begin{bmatrix} 0.2 \\\\ 0.1 \\\\ 0.15 \\\\ 0.05 \\end{bmatrix}, \\quad\nd^{(b)} = \\begin{bmatrix} 0.3 \\\\ 0.0 \\\\ 0.2 \\\\ 0.1 \\end{bmatrix}\n$$\n对于每个解 $x^{(a)}$ 和 $x^{(b)}$，我们报告其第二个分量 $(x^{(a)})_2$ 和 $(x^{(b)})_2$。这是第四和第五个结果。\n\n### 测试用例 3\n\n技术矩阵是一个 $2 \\times 2$ 的零矩阵：\n$$\nA_3 = \\begin{bmatrix}\n0 & 0 \\\\\n0 & 0\n\\end{bmatrix}\n$$\nLeontief 矩阵就是单位矩阵，$B_3 = I - A_3 = I$。\n$$\nB_3 = \\begin{bmatrix}\n1 & 0 \\\\\n0 & 1\n\\end{bmatrix}\n$$\n尽管 $I x = d$ 的解显然是 $x=d$，我们必须遵守程序，使用其 LU 分解（$P=L=U=I$）。我们对三个需求向量进行求解：\n$$\nd^{(1)} = \\begin{bmatrix} 0.7 \\\\ 0.9 \\end{bmatrix}, \\quad\nd^{(2)} = \\begin{bmatrix} 0.0 \\\\ 0.12345 \\end{bmatrix}, \\quad\nd^{(3)} = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}\n$$\n对于每个解，我们报告其第一个分量。这些值将是 $(x^{(1)})_1 = 0.7$，$(x^{(2)})_1 = 0.0$ 和 $(x^{(3)})_1 = 1.0$。这些是最后三个结果。\n\n程序将被构造成执行这些计算，按顺序收集所有八个指定值，并以所需格式打印它们。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import lu_factor, lu_solve\n\ndef solve():\n    \"\"\"\n    Solves a series of Leontief input-output models using LU factorization.\n    \"\"\"\n    # This list will store the final results in the required order.\n    final_results = []\n\n    # === Test Case 1 ===\n    # General repeated-solve scenario (3x3).\n    A1 = np.array([\n        [0.2, 0.1, 0.05],\n        [0.05, 0.25, 0.1],\n        [0.1, 0.05, 0.2]\n    ])\n    B1 = np.identity(A1.shape[0]) - A1\n    \n    # Compute LU factorization of B1 once.\n    # lu_factor returns the LU-factored matrix and pivot indices.\n    lu1, piv1 = lu_factor(B1)\n    \n    # Indices for which to compute the solution.\n    indices_to_report = [1, 500, 1000]\n    \n    # Solve for each specified index i.\n    for i in indices_to_report:\n        d_i = np.array([\n            0.5 + 0.0003 * i,\n            0.4 + 0.0001 * i,\n            0.3 + 0.0002 * i\n        ])\n        \n        # Solve B1 * x_i = d_i using the pre-computed factorization.\n        x_i = lu_solve((lu1, piv1), d_i)\n        \n        # Calculate total output t_i = 1^T * x_i (sum of components).\n        t_i = np.sum(x_i)\n        final_results.append(t_i)\n\n    # === Test Case 2 ===\n    # Larger system with two demands (4x4).\n    A2 = np.array([\n        [0.1, 0.05, 0.02, 0.0],\n        [0.03, 0.2, 0.04, 0.01],\n        [0.0, 0.05, 0.15, 0.02],\n        [0.02, 0.0, 0.03, 0.1]\n    ])\n    B2 = np.identity(A2.shape[0]) - A2\n    \n    # Compute LU factorization of B2 once.\n    lu2, piv2 = lu_factor(B2)\n    \n    demands2 = [\n        np.array([0.2, 0.1, 0.15, 0.05]),  # d^(a)\n        np.array([0.3, 0.0, 0.2, 0.1])    # d^(b)\n    ]\n    \n    for d in demands2:\n        # Solve B2 * x = d using the factorization.\n        x = lu_solve((lu2, piv2), d)\n        \n        # Report the second component of the solution vector.\n        final_results.append(x[1])\n        \n    # === Test Case 3 ===\n    # Boundary case (identity system, 2x2).\n    A3 = np.array([\n        [0.0, 0.0],\n        [0.0, 0.0]\n    ])\n    B3 = np.identity(A3.shape[0]) - A3\n    \n    # Compute LU factorization of B3 (which is I) once.\n    lu3, piv3 = lu_factor(B3)\n    \n    demands3 = [\n        np.array([0.7, 0.9]),          # d^(1)\n        np.array([0.0, 0.12345]),      # d^(2)\n        np.array([1.0, 1.0])           # d^(3)\n    ]\n    \n    for d in demands3:\n        # Solve B3 * x = d. Since B3=I, x will be equal to d.\n        # We still use the solver as required by the problem statement.\n        x = lu_solve((lu3, piv3), d)\n        \n        # Report the first component of the solution vector.\n        final_results.append(x[0])\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "2396443"}]}