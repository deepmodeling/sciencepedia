{"hands_on_practices": [{"introduction": "本练习旨在探讨理论上的渐近复杂度与实际计算性能之间的重要区别。我们将比较一个直接的 $O(N^2)$ 卷积算法和一个更快的基于 FFT 的 $O(N \\log N)$ 方法，但会引入一个更真实的成本模型，该模型同时考虑了算术运算和内存缓存未命中。通过推导 FFT 方法开始展现优势的“交叉点”，你将对硬件架构如何影响高性能计算中的算法选择有一个实践性的理解。[@problem_id:3096816]", "problem": "一个在一维均匀网格（大小为 $N$）上的偏微分方程（PDE）求解器计算一个完整的线性卷积（等效于乘以一个由格林函数导出的密集托普利茨算子）。有两种算法策略可用：直接实空间卷积和基于快速傅里叶变换（FFT）的卷积。基于FFT的方法可以通过实数到复数FFT（利用埃尔米特对称性）或通过对补零的实数数据执行复数FFT来实现。\n\n使用以下基础：\n- 算法复杂度的定义：直接实空间卷积执行的基本算术运算数量级为 $O(N^{2})$，而基于FFT的卷积执行的基本算术运算数量级为 $O(N \\log N)$。\n- 在一个简化的中央处理器（CPU）缓存模型中，总墙上时钟时间被建模为算术时间与因缓存未命中导致的数据移动惩罚之和：$T = \\alpha \\times (\\text{number of floating-point operations}) + \\tau \\times (\\text{number of cache misses})$。\n- 对于此求解器，通过FFT的线性卷积使用零填充至长度 $M = 2N$。一个 Cooley–Tukey FFT执行 $\\log_{2}(M)$ 个阶段，每个阶段包括对长度为 $M$ 的数组进行一次连续的流式处理。\n- 对长度为 $X$ 的数组的每次流式处理会产生大约 $X / w$ 次缓存未命中，其中 $w$ 是每个缓存行中的双精度浮点值的数量。\n- 算术成本和常数：\n  - 直接实空间卷积使用大约 $2 N^{2}$ 次浮点运算（每对数据一次乘法和一次加法）。\n  - 长度为 $M$ 的实数到复数FFT每次变换大约需要 $k_{rc} \\, M \\log_{2}(M)$ 次浮点运算，而复数FFT每次变换大约需要 $k_{c} \\, M \\log_{2}(M)$ 次浮点运算。假设 $k_{rc} = 2.5$ 和 $k_{c} = 5.0$。\n  - 使用实数到复数FFT时，逐点频谱乘法需要 $b_{rc} \\, M$ 次浮点运算；使用复数FFT时，需要 $b_{c} \\, M$ 次浮点运算。假设 $b_{rc} = 3$ 和 $b_{c} = 6$。\n- 缓存未命中惩罚和硬件参数：\n  - 每次浮点运算时间 $\\alpha = 1.0 \\times 10^{-9}$ 秒。\n  - 每次缓存未命中惩罚 $\\tau = 2.0 \\times 10^{-8}$ 秒。\n  - 缓存行容纳 $w = 8$ 个双精度值。\n\n将缓存未命中次数建模如下：\n- 直接实空间卷积（密集、朴素的双循环实现）：两个输入数组每个被流式处理 $N$ 次，产生大约 $\\frac{2 N^{2}}{w}$ 次未命中，输出数组被写入一次，产生大约 $\\frac{N}{w}$ 次未命中。\n- 长度为 $M = 2N$ 的基于FFT的卷积：\n  - 三次FFT变换（两次正向和一次逆向）每次变换产生大约 $\\frac{M}{w} \\log_{2}(M)$ 次未命中，总计为 $\\frac{3 M}{w} \\log_{2}(M)$。\n  - 一次逐点频谱乘法过程产生大约 $\\frac{M}{w}$ 次未命中。\n\n任务：\n1. 从给定的定义和事实出发，分别推导直接卷积、基于实数到复数FFT的卷积和基于复数FFT的卷积的显式时间模型 $T_{\\text{direct}}(N)$、$T_{\\text{rc}}(N)$ 和 $T_{\\text{cpx}}(N)$，用 $N$、$\\alpha$、$\\tau$、$w$、$k_{rc}$、$k_{c}$、$b_{rc}$ 和 $b_{c}$ 表示。\n2. 比较 $T_{\\text{rc}}(N)$ 和 $T_{\\text{cpx}}(N)$，以确定在所提供模型下，对于所有相关的 $N$，哪种FFT变体具有更小的常数因子。\n3. 使用更快的FFT变体，求解最小的整数网格尺寸 $N^{\\ast}$，使得对于所有 $N \\ge N^{\\ast}$，基于FFT的卷积时间严格小于直接卷积时间，即 $T_{\\text{FFT}}(N)  T_{\\text{direct}}(N)$。以单个整数形式提供 $N^{\\ast}$。$N^{\\ast}$ 不需要单位。\n\n最终答案必须是一个数字。", "solution": "用户希望我解决一个问题，该问题涉及对两种不同卷积算法的性能进行建模，并找出它们执行时间的交叉点。\n\n### 步骤1：提取已知信息\n\n- **问题类型**：一维偏微分方程求解器，作用于大小为 $N$ 的均匀网格。\n- **核心操作**：完整线性卷积。\n- **算法**：\n  1. 直接实空间卷积 ($T_{\\text{direct}}$)。\n  2. 基于FFT的卷积，有两种变体：\n     a. 实数到复数FFT ($T_{\\text{rc}}$)。\n     b. 对补零的实数数据进行复数FFT ($T_{\\text{cpx}}$)。\n- **渐进复杂度**：\n  - 直接法：$O(N^2)$ 次运算。\n  - 基于FFT：$O(N \\log N)$ 次运算。\n- **时间模型**：$T = \\alpha \\times (\\text{number of floating-point operations}) + \\tau \\times (\\text{number of cache misses})$。\n- **FFT参数**：从长度 $N$ 补零至 $M = 2N$。FFT有 $\\log_{2}(M)$ 个阶段，每个阶段都是一次流式处理。\n- **缓存未命中模型**：\n  - 对长度为 $X$ 的数据进行流式处理：$X/w$ 次未命中。\n  - 直接卷积未命中次数：$\\frac{2N^2}{w} + \\frac{N}{w}$。\n  - 基于FFT的卷积未命中次数（3次变换和1次逐点操作）：$3 \\frac{M}{w} \\log_{2}(M) + \\frac{M}{w}$。\n- **算术成本 (FLOPs)**：\n  - 直接卷积：$2N^2$。\n  - 长度为 $M$ 的实数到复数FFT：每次变换 $k_{rc} M \\log_{2}(M)$，其中 $k_{rc} = 2.5$。\n  - 长度为 $M$ 的复数FFT：每次变换 $k_c M \\log_{2}(M)$，其中 $k_c = 5.0$。\n  - 逐点频谱乘法（实数到复数）：$b_{rc} M$，其中 $b_{rc} = 3$。\n  - 逐点频谱乘法（复数）：$b_c M$，其中 $b_c = 6$。\n- **硬件参数**：\n  - $\\alpha = 1.0 \\times 10^{-9}$ 秒/FLOP。\n  - $\\tau = 2.0 \\times 10^{-8}$ 秒/未命中。\n  - $w = 8$ 个双精度值/缓存行。\n\n### 步骤2：使用提取的已知信息进行验证\n\n该问题具有科学依据。它提出了一个简化但标准的性能模型，用于在计算科学中比较算法。模型组件——算术成本（FLOPs）和内存访问成本（缓存未命中）——是性能工程的基础。直接卷积和基于FFT的卷积的渐进复杂度和具体操作计数是标准估计。缓存未命中模型基于一个合理的流式访问模式。所有参数都明确定义且量纲一致。该问题是良构的，目标明确，并有足够的信息来为指定任务推导出唯一解。语言客观而精确。因此，该问题被认为是有效的。\n\n### 步骤3：执行\n\n问题有效。我现在开始进行求解。\n\n解决方案按照任务要求分为三个部分。\n\n**任务1：推导显式时间模型。**\n\n首先，我们推导直接实空间卷积的总时间表达式，$T_{\\text{direct}}(N)$。\n浮点运算（FLOPs）次数给定为 $2N^2$。\n缓存未命中次数给定为 $\\frac{2N^2}{w} + \\frac{N}{w}$。\n总时间 $T_{\\text{direct}}(N)$ 是算术时间与缓存未命中惩罚之和：\n$$T_{\\text{direct}}(N) = \\alpha \\cdot (2N^2) + \\tau \\cdot \\left(\\frac{2N^2}{w} + \\frac{N}{w}\\right)$$\n按 $N$ 的幂次对项进行分组：\n$$T_{\\text{direct}}(N) = \\left(2\\alpha + \\frac{2\\tau}{w}\\right)N^2 + \\left(\\frac{\\tau}{w}\\right)N$$\n\n接下来，我们推导基于FFT的卷积所需的时间。对两个长度为 $N$ 的实数信号进行卷积的整个过程包括：\n1. 将两个输入信号补零至长度 $M=2N$。\n2. 执行两次正向FFT。\n3. 对频谱进行逐点乘法。\n4. 执行一次逆向FFT。\n这总共相当于3次变换。\n\n对于基于实数到复数FFT的方法，$T_{\\text{rc}}(N)$：\n对长度为 $M=2N$ 进行3次变换的FLOPs数量为 $3 \\cdot (k_{rc} M \\log_2(M)) = 3k_{rc}(2N)\\log_2(2N) = 6k_{rc}N\\log_2(2N)$。\n逐点频谱乘法的FLOPs数量为 $b_{rc}M = 2b_{rc}N$。\n总FLOPs = $6k_{rc}N\\log_2(2N) + 2b_{rc}N$。\n3次变换的缓存未命中次数为 $3 \\cdot (\\frac{M}{w} \\log_2(M)) = 3\\frac{2N}{w}\\log_2(2N) = \\frac{6N}{w}\\log_2(2N)$。\n逐点处理过程的缓存未命中次数为 $\\frac{M}{w} = \\frac{2N}{w}$。\n总未命中次数 = $\\frac{6N}{w}\\log_2(2N) + \\frac{2N}{w}$。\n总时间 $T_{\\text{rc}}(N)$ 为：\n$$T_{\\text{rc}}(N) = \\alpha \\left(6k_{rc}N\\log_2(2N) + 2b_{rc}N\\right) + \\tau \\left(\\frac{6N}{w}\\log_2(2N) + \\frac{2N}{w}\\right)$$\n按项分组：\n$$T_{\\text{rc}}(N) = \\left(6\\alpha k_{rc} + \\frac{6\\tau}{w}\\right)N\\log_2(2N) + \\left(2\\alpha b_{rc} + \\frac{2\\tau}{w}\\right)N$$\n\n对于基于复数FFT的方法，$T_{\\text{cpx}}(N)$，其结构相同，但使用常数 $k_c$ 和 $b_c$：\nFLOPs数量为 $6k_{c}N\\log_2(2N) + 2b_{c}N$。\n缓存未命中模型与实数到复数情况相同，因为它取决于数据移动而非执行的算术运算。总未命中次数 = $\\frac{6N}{w}\\log_2(2N) + \\frac{2N}{w}$。\n总时间 $T_{\\text{cpx}}(N)$ 为：\n$$T_{\\text{cpx}}(N) = \\alpha \\left(6k_{c}N\\log_2(2N) + 2b_{c}N\\right) + \\tau \\left(\\frac{6N}{w}\\log_2(2N) + \\frac{2N}{w}\\right)$$\n按项分组：\n$$T_{\\text{cpx}}(N) = \\left(6\\alpha k_{c} + \\frac{6\\tau}{w}\\right)N\\log_2(2N) + \\left(2\\alpha b_{c} + \\frac{2\\tau}{w}\\right)N$$\n\n**任务2：比较FFT变体。**\n\n我们比较 $T_{\\text{rc}}(N)$ 和 $T_{\\text{cpx}}(N)$。\n$T_{\\text{rc}}(N) = C_{1,rc} N\\log_2(2N) + C_{2,rc} N$\n$T_{\\text{cpx}}(N) = C_{1,cpx} N\\log_2(2N) + C_{2,cpx} N$\n系数为：\n$C_{1,rc} = 6\\alpha k_{rc} + \\frac{6\\tau}{w}$\n$C_{1,cpx} = 6\\alpha k_{c} + \\frac{6\\tau}{w}$\n$C_{2,rc} = 2\\alpha b_{rc} + \\frac{2\\tau}{w}$\n$C_{2,cpx} = 2\\alpha b_{c} + \\frac{2\\tau}{w}$\n\n给定 $k_{rc} = 2.5$ 和 $k_c = 5.0$，因此 $k_{rc}  k_c$。由于 $\\alpha > 0$，可得 $C_{1,rc}  C_{1,cpx}$。\n给定 $b_{rc} = 3$ 和 $b_c = 6$，因此 $b_{rc}  b_c$。由于 $\\alpha > 0$，可得 $C_{2,rc}  C_{2,cpx}$。\n由于实数到复数FFT变体的两个系数都更小，且 $N > 0$，因此对于所有 $N \\ge 1$，$T_{\\text{rc}}(N)  T_{\\text{cpx}}(N)$。\n更快的FFT变体是实数到复数FFT方法。我们将其时间表示为 $T_{\\text{FFT}}(N) = T_{\\text{rc}}(N)$。\n\n**任务3：找到交叉网格尺寸 $N^{\\ast}$。**\n\n我们需要找到最小的整数 $N^{\\ast}$，使得对于所有 $N \\ge N^{\\ast}$，都有 $T_{\\text{FFT}}(N)  T_{\\text{direct}}(N)$。即以下不等式：\n$$T_{\\text{rc}}(N)  T_{\\text{direct}}(N)$$\n$$\\left(6\\alpha k_{rc} + \\frac{6\\tau}{w}\\right)N\\log_2(2N) + \\left(2\\alpha b_{rc} + \\frac{2\\tau}{w}\\right)N  \\left(2\\alpha + \\frac{2\\tau}{w}\\right)N^2 + \\left(\\frac{\\tau}{w}\\right)N$$\n当 $N > 0$ 时，我们可以将不等式两边同时除以 $N$：\n$$\\left(6\\alpha k_{rc} + \\frac{6\\tau}{w}\\right)\\log_2(2N) + \\left(2\\alpha b_{rc} + \\frac{2\\tau}{w}\\right)  \\left(2\\alpha + \\frac{2\\tau}{w}\\right)N + \\frac{\\tau}{w}$$\n重新整理各项以分离出 $N$ 项：\n$$\\left(6\\alpha k_{rc} + \\frac{6\\tau}{w}\\right)\\log_2(2N) + \\left(2\\alpha b_{rc} + \\frac{\\tau}{w}\\right)  \\left(2\\alpha + \\frac{2\\tau}{w}\\right)N$$\n现在，代入给定的数值：$\\alpha = 1.0 \\times 10^{-9}$，$\\tau = 2.0 \\times 10^{-8}$，$w=8$，$k_{rc}=2.5$，$b_{rc}=3$。\n\n计算不等式的系数：\n- $\\log_2(2N)$ 的系数：\n$6\\alpha k_{rc} + \\frac{6\\tau}{w} = 6(1.0 \\times 10^{-9})(2.5) + \\frac{6(2.0 \\times 10^{-8})}{8} = 15 \\times 10^{-9} + 1.5 \\times 10^{-8} = 15 \\times 10^{-9} + 15 \\times 10^{-9} = 30 \\times 10^{-9}$。\n- 左侧的常数项：\n$2\\alpha b_{rc} + \\frac{\\tau}{w} = 2(1.0 \\times 10^{-9})(3) + \\frac{2.0 \\times 10^{-8}}{8} = 6 \\times 10^{-9} + 0.25 \\times 10^{-8} = 6 \\times 10^{-9} + 2.5 \\times 10^{-9} = 8.5 \\times 10^{-9}$。\n- 右侧 $N$ 的系数：\n$2\\alpha + \\frac{2\\tau}{w} = 2(1.0 \\times 10^{-9}) + \\frac{2(2.0 \\times 10^{-8})}{8} = 2 \\times 10^{-9} + 0.5 \\times 10^{-8} = 2 \\times 10^{-9} + 5 \\times 10^{-9} = 7 \\times 10^{-9}$。\n\n不等式变为：\n$$(30 \\times 10^{-9})\\log_2(2N) + (8.5 \\times 10^{-9})  (7 \\times 10^{-9})N$$\n我们可以将整个不等式两边同时除以 $10^{-9}$：\n$$30\\log_2(2N) + 8.5  7N$$\n这是一个超越不等式，我们通过测试 $N$ 的整数值来求解。设 $f(N) = 7N - 30\\log_2(2N) - 8.5$。我们寻找使 $f(N)>0$ 的最小整数 $N$。函数 $f(N)$ 在 $N > \\frac{30}{7\\ln(2)} \\approx 6.2$ 时单调递增，所以一旦找到交叉点，该不等式将对所有更大的 $N$ 成立。\n让我们测试 $N$ 的整数值：\n- 对于 $N=25$：\n$f(25) = 7(25) - 30\\log_2(50) - 8.5 \\approx 175 - 30(5.6439) - 8.5 = 175 - 169.317 - 8.5 = -2.817  0$。\n所以对于 $N=25$，$T_{\\text{direct}}(25)  T_{\\text{FFT}}(25)$。\n- 对于 $N=26$：\n$f(26) = 7(26) - 30\\log_2(52) - 8.5 \\approx 182 - 30(5.7004) - 8.5 = 182 - 171.012 - 8.5 = 2.488 > 0$。\n所以对于 $N=26$，$T_{\\text{FFT}}(26)  T_{\\text{direct}}(26)$。\n\n使得基于FFT的方法严格更快的最小整数网格尺寸是 $N=26$。由于 $O(N^2)$ 的直接方法成本比 $O(N\\log N)$ 的FFT方法成本增长得更快，因此对于所有 $N \\ge 26$，FFT方法将一直更快。因此，$N^\\ast = 26$。", "answer": "$$\\boxed{26}$$", "id": "3096816"}, {"introduction": "“最佳”算法通常取决于具体情境。本练习要求你比较粒子模拟中两种常见的邻近点搜索策略：简单的均匀网格法和更复杂的 k-d 树。你将为这两种方法建立成本模型，并推导出决定其优劣的“收支平衡”密度阈值，从而阐明算法的优劣权衡不仅取决于其自身复杂度，也与数据本身的空间分布特性息息相关。[@problem_id:3096897]", "problem": "一个模拟将 $n$ 个粒子独立且均匀随机地放置在一个面积为 $A$ 的二维（$2$-D）方形区域中。如果两个粒子间的欧几里得距离小于一个固定的相互作用半径 $r$（其中 $r \\ll \\sqrt{A}$），则它们会发生相互作用。您必须对所有粒子执行邻居查询，以识别所有相互作用的粒子对。\n\n考虑两种算法策略：\n\n- 带哈希的均匀网格：将区域划分为边长为 $\\ell = r$ 的方形单元格。每个粒子被插入到一个以其单元格索引为键的哈希表中。对某个粒子的邻居查询会扫描该粒子所在单元格及其相邻单元格组成的 $3 \\times 3$ 块（即 $9$ 个单元格）中的所有粒子。\n\n- k维树（k-d树）：为点集构建一个二叉空间分割树，每个粒子执行一个半径为 $r$ 的固定半径范围查询。\n\n假设采用以下以基本操作为单位的成本模型：\n\n- 均匀网格：\n  - 每个粒子的构建成本：$c_{b,g}$。\n  - 每次查询的固定开销（不包括距离检查）：$c_{o,g}$。\n  - 每个候选者的距离检查成本：$c_{d,g}$。\n\n- k-d树：\n  - 每个粒子的构建成本与 $\\log_{2}(n)$ 成正比：$c_{b,k} \\log_{2}(n)$。\n  - 每次查询的开销与 $\\log_{2}(n)$ 成正比：$c_{o,k} \\log_{2}(n)$。\n  - 每个邻居的距离检查成本：$c_{d,k}$。\n\n使用以下基本事实：大O表示法 $O(\\cdot)$ 对增长进行分类，在均匀分布下任何区域内的期望点数等于密度乘以该区域的面积（其中密度为 $\\rho = n/A$），以及半径为 $r$ 的圆的面积为 $\\pi r^{2}$。\n\n在以下假设下，使用上述常量为每种方法的所有 $n$ 次查询建立期望总操作数的模型：\n\n- 均匀网格的 $3 \\times 3$ 单元格邻域面积为 $9 \\ell^{2} = 9 r^{2}$，因此每次查询的期望候选点数为 $9 \\rho r^{2}$。\n- k-d树精确返回半径 $r$ 内的点，每次查询的期望数量为 $\\rho \\pi r^{2}$。\n\n推导收支平衡密度阈值 $\\rho^{*}$（作为一个闭式解析表达式），在该密度下，均匀网格和k-d树的期望总操作数相等。用 $n$、$r$ 以及常量 $c_{b,g}$、$c_{o,g}$、$c_{d,g}$、$c_{b,k}$、$c_{o,k}$ 和 $c_{d,k}$ 表示您的最终答案。不需要进行数值近似，最终表达式中也不应包含单位。", "solution": "目标是推导出一个阈值密度 $\\rho^{*}$，在该密度下，均匀网格和k维树（k-d树）的期望总操作数相等。我们从基本定义开始：\n\n- 大O表示法 $O(\\cdot)$ 描述了渐近增长率，但在这里我们保留显式的常数因子以获得一个具体的收支平衡表达式。\n- 对于以密度 $\\rho = n/A$ 独立均匀分布的点，可测量区域内的期望点数等于 $\\rho$ 乘以该区域的面积。\n- 半径为 $r$ 的圆的面积是 $\\pi r^{2}$。\n\n现在我们将算法行为转化为期望操作模型：\n\n带哈希的均匀网格：\n- 构建阶段将每个粒子插入一个以其单元格索引为键的哈希表中，每个粒子的成本为 $c_{b,g}$。对于 $n$ 个粒子，期望构建成本为 $n c_{b,g}$。\n- 对于每个粒子的查询，会产生一个固定的常数开销 $c_{o,g}$，用于识别和遍历包含 $9$ 个单元格的固定大小邻域。这些单元格并集中的期望候选点数是密度乘以邻域的面积。由于单元格边长为 $\\ell = r$，邻域面积为 $9 \\ell^{2} = 9 r^{2}$，因此每次查询的期望候选点数为 $9 \\rho r^{2}$。每个候选点会产生一次成本为 $c_{d,g}$ 的距离检查。因此，每次查询的期望成本为\n$$\nc_{o,g} + c_{d,g} \\cdot 9 \\rho r^{2}.\n$$\n对所有 $n$ 次查询求和，期望查询成本为\n$$\nn c_{o,g} + n c_{d,g} \\cdot 9 \\rho r^{2}.\n$$\n因此，网格方法的期望总操作数为\n$$\nT_{\\text{grid}} = n c_{b,g} + n c_{o,g} + 9 n c_{d,g} \\rho r^{2}.\n$$\n\nk-d树：\n- 构建阶段每个粒子的成本为 $c_{b,k} \\log_{2}(n)$，因此期望构建成本为 $n c_{b,k} \\log_{2}(n)$。\n- 每次查询会产生一个遍历树的开销 $c_{o,k} \\log_{2}(n)$，外加每个返回邻居的成本。在均匀分布下，半径 $r$ 内的真实邻居的期望数量是密度乘以半径为 $r$ 的圆盘面积，即 $\\rho \\pi r^{2}$。每个检查的邻居成本为 $c_{d,k}$，因此每次查询的期望成本为\n$$\nc_{o,k} \\log_{2}(n) + c_{d,k} \\cdot \\rho \\pi r^{2}.\n$$\n对所有 $n$ 次查询求和，期望查询成本为\n$$\nn c_{o,k} \\log_{2}(n) + n c_{d,k} \\rho \\pi r^{2}.\n$$\n因此，k-d树方法的期望总操作数为\n$$\nT_{\\text{kdtree}} = n c_{b,k} \\log_{2}(n) + n c_{o,k} \\log_{2}(n) + n c_{d,k} \\rho \\pi r^{2}.\n$$\n我们可以将 $\\log_{2}(n)$ 项组合在一起：\n$$\nT_{\\text{kdtree}} = n \\left( c_{b,k} + c_{o,k} \\right) \\log_{2}(n) + n c_{d,k} \\rho \\pi r^{2}.\n$$\n\n收支平衡条件：\n令 $T_{\\text{grid}} = T_{\\text{kdtree}}$ 并求解 $\\rho$：\n$$\nn c_{b,g} + n c_{o,g} + 9 n c_{d,g} \\rho r^{2} = n \\left( c_{b,k} + c_{o,k} \\right) \\log_{2}(n) + n c_{d,k} \\rho \\pi r^{2}.\n$$\n两边同时除以 $n$：\n$$\nc_{b,g} + c_{o,g} + 9 c_{d,g} \\rho r^{2} = \\left( c_{b,k} + c_{o,k} \\right) \\log_{2}(n) + c_{d,k} \\rho \\pi r^{2}.\n$$\n将含 $\\rho$ 的项收集到左侧，将常数项收集到右侧：\n$$\n\\left( 9 c_{d,g} - \\pi c_{d,k} \\right) \\rho r^{2} = \\left( c_{b,k} + c_{o,k} \\right) \\log_{2}(n) - \\left( c_{b,g} + c_{o,g} \\right).\n$$\n假设 $9 c_{d,g} \\neq \\pi c_{d,k}$ 以使 $\\rho$ 的系数非零，求解收支平衡密度 $\\rho^{*}$：\n$$\n\\rho^{*} = \\frac{ \\left( c_{b,k} + c_{o,k} \\right) \\log_{2}(n) - \\left( c_{b,g} + c_{o,g} \\right) }{ \\left( 9 c_{d,g} - \\pi c_{d,k} \\right) r^{2} }.\n$$\n\n相对于 $O(n)$ 与 $O(n \\log n)$ 的解释：\n- 对于网格，主导项在 $n$ 上是线性的，与邻居相关的项按 $n \\rho r^{2}$ 缩放。当 $\\rho$ 低于 $\\rho^{*}$ 时，网格的总成本较低，并且对于固定的 $r$ 和有界的 $\\rho r^{2}$，其行为类似于 $O(n)$。\n- 对于k-d树，构建和每次查询的遍历都存在固有的 $n \\log_{2}(n)$ 开销。当 $\\rho$ 超过 $\\rho^{*}$ 时，邻居项可能占主导地位，但当 $\\rho$ 低于 $\\rho^{*}$ 时，$\\log_{2}(n)$ 项起决定性作用，总成本为 $O(n \\log n)$。\n\n因此，闭式收支平衡密度阈值是上面推导出的表达式。", "answer": "$$\\boxed{\\frac{\\left(c_{b,k}+c_{o,k}\\right)\\log_{2}(n)-\\left(c_{b,g}+c_{o,g}\\right)}{\\left(9c_{d,g}-\\pi c_{d,k}\\right) r^{2}}}$$", "id": "3096897"}, {"introduction": "高效的算法设计常常需要融合不同方法的优点。在这个问题中，你将设计并分析一个混合求根算法，它结合了二分法保证收敛的稳健性和牛顿法局部快速收敛的效率。通过这个实践，你将学习如何通过创建一个比其任何单一组件都更强大、更高效的解决方案，来分析和优化算法。[@problem_id:3096800]", "problem": "给定一个定义在闭区间 $[a,b] = [0,1]$ 上的实值函数 $f$，该函数具有以下性质：\n- $f$ 在 $[0,1]$ 上二阶连续可微。\n- 在 $(0,1)$ 区间内存在唯一根 $\\alpha$ 满足 $f(\\alpha) = 0$，并且 $f$ 在 $[0,1]$ 上严格单调递增。\n- 导数 $f'$ 在 $[0,1]$ 上是利普希茨连续的，利普希茨常数为 $L$，即对于所有 $x,y \\in [0,1]$，都有 $|f'(x) - f'(y)| \\le L |x - y|$。\n- 根处的导数值有下界 $f'(\\alpha) \\ge m$，其中 $m > 0$ 是某个已知常数。\n\n请设计一种混合算法，该算法结合了二分法和牛顿法，具体如下。从初始区间 $[0,1]$ 开始，其中 $f(0)$ 和 $f(1)$ 异号。首先运行二分法，直到当前区间的宽度最多为 $2 r$。您必须根据 $m$ 和 $L$ 来确定阈值半径 $r$，以保证后续从该区间中点开始的牛顿迭代能够二次收敛到 $\\alpha$。然后切换到牛顿法，并进行迭代，直到绝对误差最多为给定的容差 $\\epsilon$。\n\n假设采用以下计算成本模型：\n- 每次 $f$ 的求值成本为 $1$ 个单位。\n- 每次 $f'$ 的求值成本为 $1$ 个单位。\n- 二分法仅使用 $f$ 的求值（每次迭代一次新的 $f$ 求值）。\n- 牛顿法每次迭代使用一次 $f$ 和一次 $f'$。\n\n任务：\n1. 仅使用基本定义和 $f'$ 的利普希茨界，确定一个用 $m$ 和 $L$ 表示的有效 $r$ 值，以保证牛顿法从与 $\\alpha$ 相距 $r$ 范围内的任何初始点开始都具有局部二次收敛性。\n2. 根据 $m$、$L$、初始区间宽度 $b-a$ 和容差 $\\epsilon$，推导该混合方法达到 $|x - \\alpha| \\le \\epsilon$ 所需总运行时间（计算单位成本求值总数）的一个明确的最坏情况上界。\n3. 最后，对于参数值 $m = 0.4$、$L = 2$、$a = 0$、$b = 1$ 和 $\\epsilon = 10^{-12}$，精确计算您得到的界，并报告该界所要求的单位成本求值总数的精确整数值。不要四舍五入；提供精确的整数计数作为最终答案。", "solution": "用户希望分析一个结合了二分法和牛顿法的混合求根算法。我将首先验证问题陈述，然后按顺序解决问题的三个部分。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n- 给定一个定义在 $[a,b] = [0,1]$ 上的实值函数 $f$。\n- $f$ 在 $[0,1]$ 上二阶连续可微。\n- 在 $(0,1)$ 区间内存在唯一根 $\\alpha$ 满足 $f(\\alpha) = 0$。\n- $f$ 在 $[0,1]$ 上严格单调递增。\n- 导数 $f'$ 在 $[0,1]$ 上是利普希茨连续的，利普希茨常数为 $L$：对于所有 $x,y \\in [0,1]$，都有 $|f'(x) - f'(y)| \\le L |x - y|$。\n- 根处的导数值有界：$f'(\\alpha) \\ge m$，其中 $m > 0$ 是一个已知常数。\n- 混合算法从 $[0,1]$ 上的二分法开始。\n- 二分法运行直到区间宽度最多为 $2r$。\n- 阈值半径 $r$ 必须根据 $m$ 和 $L$ 来确定。\n- 在最后一个二分法区间的中点处，以其作为初始猜测值，切换到牛顿法。\n- 牛顿法迭代直到绝对误差最多为 $\\epsilon$。\n- 计算成本：$f$ 的求值成本为 $1$ 个单位；$f'$ 的求值成本为 $1$ 个单位。\n- 二分法迭代成本：$1$ 个单位（$1$ 次 $f$ 的求值）。\n- 牛顿法迭代成本：$2$ 个单位（$1$ 次 $f$ 的求值，$1$ 次 $f'$ 的求值）。\n- 最终评估的参数值：$m = 0.4$，$L = 2$，$a = 0$，$b = 1$，$\\epsilon = 10^{-12}$。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n- **科学依据**：该问题是数值分析中的一个标准练习，涉及已成熟算法（二分法和牛顿法）的收敛性质。对函数 $f$ 的假设（光滑性、利普希茨连续性）在此类方法的分析中很常见。该问题牢固地植根于数学原理。\n- **适定性**：该问题是适定的。二分法和牛顿法的结合是一种标准技术。所提供的条件足以保证半径 $r$ 和复杂度界的解的存在性和唯一性。\n- **客观性**：语言精确且数学化。没有主观或基于意见的陈述。\n- 问题是自洽的，其约束条件是一致的。它没有违反任何无效性标准。\n\n**步骤 3：结论与行动**\n\n问题是**有效的**。我将继续进行完整解答。\n\n### 第 1 部分：确定收敛半径 $r$\n\n目标是找到一个半径 $r$，使得如果牛顿法的初始猜测值 $x_0$ 满足 $|x_0 - \\alpha| \\le r$，则能保证二次收敛到根 $\\alpha$。\n\n牛顿迭代公式为 $x_{k+1} = x_k - \\frac{f(x_k)}{f'(x_k)}$。第 $k$ 次迭代的误差为 $e_k = x_k - \\alpha$。\n$$ e_{k+1} = x_{k+1} - \\alpha = x_k - \\alpha - \\frac{f(x_k)}{f'(x_k)} $$\n根据泰勒定理，我们在 $x_k$ 附近展开 $f(\\alpha)$：\n$$ 0 = f(\\alpha) = f(x_k) + f'(x_k)(\\alpha - x_k) + \\frac{f''(\\zeta_k)}{2}(\\alpha - x_k)^2 $$\n其中 $\\zeta_k$ 介于 $x_k$ 和 $\\alpha$ 之间。整理可得：\n$$ f(x_k) = -f'(x_k)(\\alpha - x_k) - \\frac{f''(\\zeta_k)}{2}(\\alpha - x_k)^2 = f'(x_k)(x_k-\\alpha) - \\frac{f''(\\zeta_k)}{2}(x_k-\\alpha)^2 $$\n将此代入 $e_{k+1}$ 的误差方程：\n$$ e_{k+1} = (x_k - \\alpha) - \\frac{f'(x_k)(x_k-\\alpha) - \\frac{f''(\\zeta_k)}{2}(x_k-\\alpha)^2}{f'(x_k)} = \\frac{f''(\\zeta_k)}{2 f'(x_k)}(x_k-\\alpha)^2 = \\frac{f''(\\zeta_k)}{2 f'(x_k)} e_k^2 $$\n为保证收敛，我们必须对项 $\\frac{f''(\\zeta_k)}{2 f'(x_k)}$ 进行界定。\n$f'$ 的利普希茨连续性 $|f'(x) - f'(y)| \\le L|x-y|$，根据中值定理，意味着对于所有 $z \\in [0,1]$，都有 $|f''(z)| \\le L$。\n我们已知 $f'(\\alpha) \\ge m > 0$。对于任何满足 $|x - \\alpha| \\le r$ 的 $x$，我们有：\n$$ |f'(x) - f'(\\alpha)| \\le L|x - \\alpha| \\le Lr $$\n这意味着 $f'(x) \\ge f'(\\alpha) - Lr \\ge m - Lr$。为确保 $f'(x)$ 非零且为正（因为 $f$ 是严格递增的），我们要求 $m - Lr > 0$，即 $r  m/L$。\n利用这些界，误差递推关系变为：\n$$ |e_{k+1}| \\le \\frac{L}{2(m - Lr)}|e_k|^2 $$\n为了使收敛具有鲁棒性，我们需要误差序列至少在初始阶段是严格递减的。一个充分条件是，如果 $|e_k| \\le r$，则 $|e_{k+1}|  |e_k|$。如果 $\\frac{L}{2(m-Lr)}|e_k|  1$ 则可以保证这一点。一个更严格的条件，对所有 $|e_k| \\le r$ 都充分，是 $\\frac{Lr}{2(m-Lr)}  1$。为了简化下一部分的分析，我们施加一个更强的条件，确保收缩因子至少为 $1/2$：\n$$ \\frac{Lr}{2(m-Lr)} \\le \\frac{1}{2} $$\n这可以简化为 $Lr \\le m-Lr$，从而得到 $2Lr \\le m$，或者 $r \\le \\frac{m}{2L}$。\n因此，半径的一个有效选择是 $r = \\frac{m}{2L}$。由于 $m, L > 0$，这个选择也满足 $r  m/L$。\n\n### 第 2 部分：总运行时间上界\n\n总运行时间是二分法阶段和牛顿法阶段的成本之和。\n\n**阶段 1：二分法**\n初始区间是 $[a,b]$，宽度为 $W_0 = b-a$。二分法应用 $N_b$ 次迭代，直到区间宽度 $W_{N_b}$ 最多为 $2r$。经过 $N_b$ 次迭代后，宽度为 $W_{N_b} = \\frac{b-a}{2^{N_b}}$。\n我们要求 $W_{N_b} \\le 2r$。使用我们的选择 $r = \\frac{m}{2L}$：\n$$ \\frac{b-a}{2^{N_b}} \\le 2 \\left(\\frac{m}{2L}\\right) = \\frac{m}{L} $$\n$$ 2^{N_b} \\ge \\frac{L(b-a)}{m} \\implies N_b \\ge \\log_2\\left(\\frac{L(b-a)}{m}\\right) $$\n由于 $N_b$ 必须是整数，迭代次数是满足此条件的最小整数，即：\n$$ N_b = \\left\\lceil \\log_2\\left(\\frac{L(b-a)}{m}\\right) \\right\\rceil $$\n每次二分法迭代的成本为 $1$ 个单位。此阶段的成本为 $C_b = N_b$。\n\n**阶段 2：牛顿法**\n在二分法阶段之后，我们得到一个包含 $\\alpha$ 且宽度最多为 $2r$ 的区间。牛顿法的初始猜测值是该区间的中点 $x_0$。初始误差由区间宽度的一半为界：$|e_0| = |x_0 - \\alpha| \\le r = \\frac{m}{2L}$。\n误差递推关系为 $|e_{k+1}| \\le \\frac{L}{2(m-Lr)}|e_k|^2$。当 $r = \\frac{m}{2L}$ 时，我们有 $m-Lr = m - L\\frac{m}{2L} = \\frac{m}{2}$。\n$$ |e_{k+1}| \\le \\frac{L}{2(m/2)}|e_k|^2 = \\frac{L}{m}|e_k|^2 $$\n让我们通过定义一个缩放误差 $\\delta_k = \\frac{L}{m}|e_k|$ 来分析收敛速度。递推关系变为 $\\delta_{k+1} \\le \\delta_k^2$。\n初始缩放误差为 $\\delta_0 = \\frac{L}{m}|e_0| \\le \\frac{L}{m} \\cdot r = \\frac{L}{m} \\cdot \\frac{m}{2L} = \\frac{1}{2}$。\n通过归纳法，$\\delta_k \\le (\\delta_0)^{2^k} \\le \\left(\\frac{1}{2}\\right)^{2^k}$。\n当 $|e_{N_n}| \\le \\epsilon$ 时，该方法在 $N_n$ 次迭代后停止。用缩放误差表示，即 $\\frac{m}{L}\\delta_{N_n} \\le \\epsilon$，或 $\\delta_{N_n} \\le \\frac{L\\epsilon}{m}$。\n我们需要找到迭代次数 $N_n$，使得我们的误差界满足这个标准：\n$$ \\left(\\frac{1}{2}\\right)^{2^{N_n}} \\le \\frac{L\\epsilon}{m} $$\n对两边取以 $2$ 为底的对数（并反转不等式）：\n$$ -2^{N_n} \\le \\log_2\\left(\\frac{L\\epsilon}{m}\\right) \\implies 2^{N_n} \\ge -\\log_2\\left(\\frac{L\\epsilon}{m}\\right) = \\log_2\\left(\\frac{m}{L\\epsilon}\\right) $$\n再次取以 $2$ 为底的对数：\n$$ N_n \\ge \\log_2\\left(\\log_2\\left(\\frac{m}{L\\epsilon}\\right)\\right) $$\n所需的牛顿迭代次数是满足此条件的最小整数：\n$$ N_n = \\left\\lceil \\log_2\\left(\\log_2\\left(\\frac{m}{L\\epsilon}\\right)\\right) \\right\\rceil $$\n每次牛顿迭代的成本为 $2$ 个单位。此阶段的成本为 $C_n = 2N_n$。\n\n**总运行时间上界**\n总的最坏情况运行时间 $C_{total}$ 是两个阶段成本的总和：\n$$ C_{total} = C_b + C_n = \\left\\lceil \\log_2\\left(\\frac{L(b-a)}{m}\\right) \\right\\rceil + 2 \\left\\lceil \\log_2\\left( \\log_2\\left(\\frac{m}{L\\epsilon}\\right) \\right) \\right\\rceil $$\n\n### 第 3 部分：计算该界的值\n\n我们给定的参数值为 $m = 0.4$，$L = 2$，$a = 0$，$b = 1$（所以 $b-a=1$），以及 $\\epsilon = 10^{-12}$。\n\n**二分法成本 ($C_b$)**\n$$ C_b = \\left\\lceil \\log_2\\left(\\frac{L(b-a)}{m}\\right) \\right\\rceil = \\left\\lceil \\log_2\\left(\\frac{2 \\cdot 1}{0.4}\\right) \\right\\rceil = \\left\\lceil \\log_2(5) \\right\\rceil $$\n由于 $2^2 = 4$ 和 $2^3 = 8$，我们有 $2  \\log_2(5)  3$。因此：\n$$ C_b = \\lceil \\log_2(5) \\rceil = 3 $$\n\n**牛顿法成本 ($C_n$)**\n$$ C_n = 2 \\left\\lceil \\log_2\\left( \\log_2\\left(\\frac{m}{L\\epsilon}\\right) \\right) \\right\\rceil $$\n首先，我们计算最内层的项：\n$$ \\frac{m}{L\\epsilon} = \\frac{0.4}{2 \\times 10^{-12}} = \\frac{0.2}{10^{-12}} = 2 \\times 10^{11} $$\n现在我们计算内层对数，称之为 $Y$：\n$$ Y = \\log_2(2 \\times 10^{11}) $$\n我们可以通过找到包围 $2 \\times 10^{11}$ 的 $2$ 的幂来界定 $Y$。我们知道 $2^{10} = 1024 \\approx 10^3$。\n$$ 2 \\times 10^{11} = 2 \\times (10^3)^{11/3} \\approx 2 \\times (2^{10})^{11/3} = 2^1 \\times 2^{110/3} = 2^{113/3} \\approx 2^{37.67} $$\n更正式地，$2^{37} = 2^7 \\times (2^{10})^3 = 128 \\times (1024)^3 > 128 \\times (10^3)^3 = 1.28 \\times 10^{11}$。而 $2^{38} = 2 \\times 2^{37} > 2.56 \\times 10^{11}$。\n所以，$1.28 \\times 10^{11}  2 \\times 10^{11}  2.56 \\times 10^{11}$，这意味着 $37  \\log_2(2 \\times 10^{11})  38$。所以，$Y$ 是一个介于 $37$ 和 $38$ 之间的值。\n现在我们计算外层对数项：\n$$ \\log_2(Y) = \\log_2(\\text{一个介于 } 37 \\text{ 和 } 38 \\text{ 之间的值}) $$\n由于 $2^5 = 32$ 和 $2^6 = 64$，我们有 $32  Y  64$。取以 $2$ 为底的对数：\n$$ \\log_2(32)  \\log_2(Y)  \\log_2(64) \\implies 5  \\log_2(Y)  6 $$\n牛顿迭代的次数是这个值的上取整：\n$$ N_n = \\lceil \\log_2(Y) \\rceil = 6 $$\n牛顿阶段的成本是：\n$$ C_n = 2 \\times N_n = 2 \\times 6 = 12 $$\n\n**总成本**\n单位成本求值的总数是两个阶段成本的总和：\n$$ C_{total} = C_b + C_n = 3 + 12 = 15 $$\n根据推导出的界，所需的单位成本求值总数的精确整数值为 15。", "answer": "$$\\boxed{15}$$", "id": "3096800"}]}