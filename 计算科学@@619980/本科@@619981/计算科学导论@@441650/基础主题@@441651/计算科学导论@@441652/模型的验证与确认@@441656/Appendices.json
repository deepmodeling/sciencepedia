{"hands_on_practices": [{"introduction": "验证数值模型的一个关键步骤是检查它是否遵循其所模拟系统的基本物理定律，例如能量守恒。本练习将热方程作为一个经典案例，来验证其能量耗散的特性。我们将看到，这个验证测试不仅能确认物理属性，还能揭示数值格式中潜在的稳定性问题。[@problem_id:3201887]", "problem": "您将为一维热方程实现一个基于物理性质的数值验证。其基本原理是热方程，这是一个线性的偏微分方程（PDE），用于描述热量的守恒与扩散。在空间区间 $[0,1]$ 上，带狄利克雷（Dirichlet）边界条件的一维热方程为\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\nu \\frac{\\partial^2 u}{\\partial x^2}(x,t), \\quad x \\in [0,1], \\ t \\ge 0,\n$$\n边界条件为 $u(0,t) = 0$ 和 $u(1,t) = 0$，其中 $\\nu > 0$ 是扩散系数。关于此偏微分方程的一个基本且经过充分验证的事实是，其平方 $L^2$ 能量，\n$$\nE(t) = \\int_0^1 u(x,t)^2 \\, dx,\n$$\n在时间上是单调不增的，这反映了物理上的耗散现象。\n\n您的任务是对此偏微分方程进行离散化，并验证离散能量\n$$\nE_n = \\Delta x \\sum_{i=1}^{N-2} u_i^n{}^2,\n$$\n是否在时间步长上单调不增。使用一个包含 $N$ 个点的均匀网格，其中 $\\Delta x = \\frac{1}{N-1}$，以及时间步长 $\\Delta t$。使用二阶中心差分来近似空间导数，并使用前向欧拉法（forward Euler method）进行时间推进：\n$$\nu_i^{n+1} = u_i^n + \\alpha\\left(u_{i+1}^n - 2u_i^n + u_{i-1}^n\\right), \\quad i=1,\\dots,N-2,\n$$\n其中 $u_0^n = u_{N-1}^n = 0$ 强制施加了狄利克雷边界条件，且 $\\alpha = \\nu \\frac{\\Delta t}{\\Delta x^2}$。离散能量 $E_n$ 应在每个时间步上使用内部点 $i=1,\\dots,N-2$ 进行计算，边界点的值设为零。\n\n实现一个程序，对于每个给定的测试用例，根据指定的初始条件初始化 $u_i^0$，对 $n = 0,1,\\dots,n_{\\text{steps}}$（其中 $n_{\\text{steps}} = \\left\\lfloor \\frac{T_{\\text{end}}}{\\Delta t} \\right\\rfloor$）运行显式格式，并检查是否在所有步骤中都满足 $E_{n+1} \\le E_n$。为了考虑浮点舍入误差，需要使用一个小的数值容差 $\\varepsilon = 10^{-12} \\cdot (1 + E_n)$。该程序必须为每个测试用例返回一个布尔值，指示在整个模拟过程中能量是否为单调不增。\n\n初始条件对空间网格点 $x_i = i \\Delta x$ 定义如下：\n- \"sine\": $u_i^0 = \\sin(\\pi x_i)$。\n- \"highfreq\": $u_i^0 = \\sin(m \\pi x_i)$，其中 $m = \\left\\lfloor 0.45\\cdot(N-1) \\right\\rfloor$ 且 $m \\ge 1$。\n- \"zero\": $u_i^0 = 0$。\n\n参数 $\\alpha$ 通过 $\\Delta t = \\alpha \\frac{\\Delta x^2}{\\nu}$ 决定时间步长。\n\n测试套件：\n提供一个程序来评估以下测试用例，每个用例为一个元组 $(N,\\nu,\\alpha,T_{\\text{end}},\\text{initial})$：\n1. $(41, 0.1, 0.4, 0.1, \\text{\"sine\"})$。\n2. $(41, 0.1, 0.5, 0.1, \\text{\"sine\"})$。\n3. $(41, 0.1, 0.6, 0.1, \\text{\"highfreq\"})$。\n4. $(5, 1.0, 0.5, 0.5, \\text{\"sine\"})$。\n5. $(21, 0.5, 0.9, 0.1, \\text{\"zero\"})$。\n\n覆盖性设计：\n- 用例 1 是一个标准的稳定配置，预期会表现出能量衰减。\n- 用例 2 是一个边界稳定性情况。\n- 用例 3 使用了更大的 $\\alpha$ 和一个高频初始条件，这对稳定性构成了压力，并可能违反能量单调性。\n- 用例 4 使用一个粗糙网格来测试边界和离散化处理。\n- 用例 5 的初始能量为零，用于在可能不稳定的参数下检查平凡的单调性。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，\"[result1,result2,...]\"），每个结果是一个布尔值（\"True\" 或 \"False\"），对应于相应测试用例的单调性检查。不涉及物理单位，答案仅为布尔值。", "solution": "该问题要求对一维热方程的有限差分离散格式的能量耗散性质进行数值验证。连续问题由偏微分方程（PDE）\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\nu \\frac{\\partial^2 u}{\\partial x^2}(x,t)\n$$\n给出，定义在空间域 $x \\in [0,1]$ 上，并带有齐次狄利克雷边界条件 $u(0,t) = u(1,t) = 0$。扩散系数为 $\\nu > 0$。该系统的一个基本性质是总能量（由平方 $L^2$-范数 $E(t) = \\int_0^1 u(x,t)^2 \\, dx$ 定义）是时间的单调不增函数，即 $\\frac{dE}{dt} \\le 0$。这反映了在边界保持恒定温度的孤立系统中热量耗散的物理原理。\n\n我们的任务是验证一个特定的数值格式是否保留了此性质的离散模拟。空间域 $[0,1]$ 使用一个包含 $N$ 个点的均匀网格进行离散化，$x_i = i \\Delta x$，$i=0, 1, \\dots, N-1$，其中网格间距为 $\\Delta x = \\frac{1}{N-1}$。在网格点 $x_i$ 和时间步 $n$ 的解表示为 $u_i^n \\approx u(x_i, n\\Delta t)$。\n\n提供的数值格式是时间前向、空间中心（FTCS）方法。时间导数由前向差分近似，空间二阶导数由二阶中心差分近似：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\nu \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{\\Delta x^2}.\n$$\n重新整理该方程，得到内部网格点（$i=1, \\dots, N-2$）的显式更新规则：\n$$\nu_i^{n+1} = u_i^n + \\alpha \\left(u_{i+1}^n - 2u_i^n + u_{i-1}^n\\right),\n$$\n其中 $\\alpha = \\nu \\frac{\\Delta t}{\\Delta x^2}$ 是无量纲扩散数。通过在所有时间步 $n$ 上设置 $u_0^n = 0$ 和 $u_{N-1}^n = 0$ 来施加边界条件。\n\n这种显式格式的一个关键方面是其条件稳定性。冯·诺依曼（von Neumann）稳定性分析表明，该格式当且仅当 $\\alpha \\le 0.5$ 时是稳定的。如果违反此条件（$\\alpha > 0.5$），数值解的高频分量将在每个时间步被放大，导致指数级增长并完全偏离真实解。\n\n离散能量被定义为连续能量积分的数值求积：\n$$\nE_n = \\Delta x \\sum_{i=1}^{N-2} (u_i^n)^2.\n$$\n这对应于 $\\int_0^1 u(x,t)^2 dx$ 的梯形法则近似，因为被积函数在边界处为零。我们的任务是检查此离散能量在模拟的每个时间步上是否为单调不增，即对于所有 $n$ 是否有 $E_{n+1} \\le E_n$。由于浮点运算，我们必须使用一个小的容差来检查这个不等式：$E_{n+1} \\le E_n + \\varepsilon$，其中 $\\varepsilon = 10^{-12} (1 + E_n)$。在任何一步未能满足此条件，都意味着该测试用例的能量单调性被违反。\n\n为每个测试用例 $(N,\\nu,\\alpha,T_{\\text{end}},\\text{initial})$ 实现的算法如下：\n1.  计算离散化参数：$\\Delta x = \\frac{1}{N-1}$，$\\Delta t = \\alpha \\frac{\\Delta x^2}{\\nu}$，以及时间步数 $n_{\\text{steps}} = \\lfloor \\frac{T_{\\text{end}}}{\\Delta t} \\rfloor$。\n2.  根据指定的初始条件（\"sine\"、\"highfreq\" 或 \"zero\"）初始化大小为 $N$ 的解向量 $u^0$。边界值 $u_0^0$ 和 $u_{N-1}^0$ 设置为 $0$。\n3.  计算初始能量 $E_0$。\n4.  对 $n$ 从 $0$ 到 $n_{\\text{steps}}-1$ 进行迭代：\n    a. 使用 FTCS 更新规则为所有内部点计算下一个时间步的解 $u^{n+1}$。边界值保持为零。\n    b. 计算新能量 $E_{n+1}$。\n    c. 检查是否 $E_{n+1} > E_n + \\varepsilon$。如果满足此条件，则性质被违反。该测试用例的结果为 `False`，并且此用例的模拟可以终止。\n    d. 更新能量以进行下一次比较：$E_n \\leftarrow E_{n+1}$。\n5.  如果循环完成而没有任何违反，则性质成立，结果为 `True`。\n\n此过程将应用于每个测试用例。\n-   用例 1、2 和 4 的 $\\alpha \\le 0.5$，因此格式是稳定的，预期能量单调性会保持（`True`）。用例 2 代表稳定性极限 $\\alpha=0.5$。\n-   用例 3 的 $\\alpha = 0.6 > 0.5$，这是不稳定的。“highfreq”初始条件将激发不稳定模式，导致能量增长（`False`）。\n-   用例 5 的 $\\alpha = 0.9 > 0.5$（不稳定），但初始条件恒为零。对于线性格式，假设没有舍入误差，零初始数据将产生始终为零的解。因此，对于所有 $n$，$E_n = 0$，条件 $E_{n+1} \\le E_n$ 被平凡地满足（`True`）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, nu, alpha, T_end, initial_type):\n    \"\"\"\n    Runs a single simulation of the 1D heat equation and checks for energy monotonicity.\n\n    Args:\n        N (int): Number of grid points.\n        nu (float): Diffusion coefficient.\n        alpha (float): Dimensionless diffusion number.\n        T_end (float): Total simulation time.\n        initial_type (str): Type of initial condition (\"sine\", \"highfreq\", \"zero\").\n\n    Returns:\n        bool: True if discrete energy is monotonically non-increasing, False otherwise.\n    \"\"\"\n    # Step 1: Initialize parameters and grid\n    dx = 1.0 / (N - 1)\n    # Avoid division by zero if nu is zero, though problem states nu > 0\n    if nu == 0:\n        # If nu=0, dt is technically infinite unless alpha=0.\n        # This case is not in the test suite but is a safe guard.\n        if alpha == 0:\n            dt = 0  # No time evolution\n        else:\n            return False # Ill-defined problem\n    else:\n        dt = alpha * dx**2 / nu\n\n    if dt == 0:\n        n_steps = 0\n    else:\n        n_steps = int(T_end / dt)\n\n    x = np.linspace(0.0, 1.0, N)\n    u = np.zeros(N, dtype=np.float64)\n\n    # Step 2: Set initial condition\n    if initial_type == \"sine\":\n        u = np.sin(np.pi * x)\n    elif initial_type == \"highfreq\":\n        m = int(0.45 * (N - 1))\n        # Per problem spec, ensure m >= 1\n        if m  1:\n            m = 1\n        u = np.sin(m * np.pi * x)\n    elif initial_type == \"zero\":\n        # u is already initialized to zeros\n        pass\n    \n    # Enforce boundary conditions, though initializers above already satisfy them\n    u[0] = 0.0\n    u[-1] = 0.0\n\n    # Step 3: Calculate initial energy\n    E_prev = dx * np.sum(u[1:-1]**2)\n    is_monotonic = True\n\n    # Step 4: Time-stepping loop\n    for _ in range(n_steps):\n        # Create a copy to store the new state\n        u_new = u.copy()\n        \n        # Apply FTCS update rule for interior points\n        u_new[1:-1] = u[1:-1] + alpha * (u[2:] - 2 * u[1:-1] + u[:-2])\n        \n        # Update u for the next iteration\n        u = u_new\n\n        # Calculate new energy\n        E_curr = dx * np.sum(u[1:-1]**2)\n\n        # Check for monotonicity violation with tolerance\n        epsilon = 1e-12 * (1.0 + E_prev)\n        if E_curr > E_prev + epsilon:\n            is_monotonic = False\n            break\n\n        # Update previous energy\n        E_prev = E_curr\n\n    return is_monotonic\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (41, 0.1, 0.4, 0.1, \"sine\"),\n        (41, 0.1, 0.5, 0.1, \"sine\"),\n        (41, 0.1, 0.6, 0.1, \"highfreq\"),\n        (5, 1.0, 0.5, 0.5, \"sine\"),\n        (21, 0.5, 0.9, 0.1, \"zero\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3201887"}, {"introduction": "计算模型中的错误常常隐藏在实现细节中，尤其是在边界条件的处理上。本练习将展示一种强大的验证技术：通过检查代码是否保持了系统的已知不变量（如质量和对称性）来验证其正确性。通过交换不同的边界条件并观察结果，我们可以对代码实现进行“压力测试”，从而增强我们对其正确性的信心。[@problem_id:3201854]", "problem": "您的任务是对一个一维扩散模型进行验证与确认实践，具体方法是对应力测试边界条件，并检查关键物理不变量是否得以保持。请实现一个程序，模拟具有两种边界条件类型的无量纲一维扩散，并在一个小型测试套件上评估不变量的保持情况。本问题中的所有量均为无量纲（无单位）。\n\n该扩散过程由偏微分方程 (PDE) $$\\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2},$$ 控制，其中 $u$ 是场，$t$ 是时间，$x$ 是空间，$D$ 是扩散系数。在长度为 $L$ 的域上，使用一个包含 $N$ 个点的均匀网格，采用有限差分法 (FDM)，时间上使用前向欧拉离散，空间拉普拉斯算子使用中心二阶差分。设时间步长为 $\\Delta t$，网格间距为 $\\Delta x$。定义 $$\\alpha = \\frac{D \\Delta t}{\\Delta x^2}.$$ 采用两种边界条件类型：\n- 反射（诺伊曼，零通量）：在边界处 $\\frac{\\partial u}{\\partial x} = 0$。\n- 周期性：$u(x + L) = u(x)$。\n\n您的实现必须：\n1. 通过重复应用显式更新，将场从初始条件 $u^0$ 演化到 $u^n$，总时间为预设的 $T$。选择步数 $n$ 为 $n = \\lceil T / \\Delta t \\rceil$，并调整 $\\Delta t$ 以精确满足 $n \\Delta t = T$。对于反射边界，使用 $\\Delta x = L/(N-1)$；对于周期性边界，使用 $\\Delta x = L/N$。\n2. 对于反射边界，使用鬼点策略来强制执行零通量边界条件，该策略在端点处产生的更新与零梯度一致。\n3. 对于周期性边界，强制执行环绕索引。\n\n定义需要检查的以下不变量：\n- （离散）质量守恒：量 $\\sum_{j} u_j \\Delta x$ 不随时间变化。\n- 对称性保持：如果初始场关于中心对称（回文），那么对于线性扩散，对称性将被保持。\n- 对于周期性边界条件和波数为 $k$ 的余弦初始条件，模态振幅必须根据周期性离散拉普拉斯算子的离散特征值进行衰减。如果每步放大因子为 $$g_k = 1 - 4 \\alpha \\sin^2\\left(\\frac{\\pi k}{N}\\right),$$ 那么经过 $n$ 步后，振幅比必须为 $g_k^n$。\n\n测试套件：\n- 案例 1（恒定场，跨边界比较）：\n  - 参数：$L = 1.0$, $D = 0.1$, $N = 64$, $T = 0.1$，初始化所有 $j$ 的 $u_j^0 = 3.0$。\n  - 时间步长选择：对两种边界类型都设置 $\\alpha = 0.45$；也就是说，选择 $\\Delta t$ 使得在每种边界类型的 $\\Delta x$ 下 $\\alpha = 0.45$。使用各自的 $\\Delta x$ 和 $\\Delta t$ 独立运行反射和周期性边界条件。\n  - 输出三个布尔值：\n    - 案例 1.1：在反射边界下质量守恒。\n    - 案例 1.2：在周期性边界下质量守恒。\n    - 案例 1.3：从恒定场开始，反射和周期性运行产生的最终数组在容差范围内相等。\n\n- 案例 2（周期性余弦模态，理论振幅衰减）：\n  - 参数：$L = 1.0$, $D = 0.2$, $N = 128$, $T = 0.05$，波数 $k = 1$，初始化 $u_j^0 = \\cos\\left( \\frac{2\\pi k j}{N} \\right)$。\n  - 时间步长选择：设置 $\\alpha = 0.10$（对于周期性边界，$\\Delta x = L/N$），因此 $\\Delta t$ 必须满足 $\\alpha = D \\Delta t / \\Delta x^2$。\n  - 输出三个布尔值：\n    - 案例 2.1：在周期性边界下质量守恒。\n    - 案例 2.2：测量的振幅比在容差范围内等于 $g_k^n$。\n    - 案例 2.3：在相同的初始条件和 $T$ 下，使用其自身的 $\\Delta x$ 和 $\\Delta t$ (对应于 $\\alpha = 0.10$) 运行时，反射边界下质量守恒。\n\n- 案例 3（回文对称形状，两种边界下的对称性保持）：\n  - 参数：$L = 1.0$, $D = 0.1$, $N = 129$, $T = 0.05$，将 $u^0$ 初始化为关于中心对称的回文三角形凸起（例如，构造左半部分并将其镜像到右半部分，以使 $u_j^0 = u_{N-1-j}^0$ 精确成立）。\n  - 时间步长选择：在两种边界类型下均设置 $\\alpha = 0.45$。\n  - 输出三个布尔值：\n    - 案例 3.1：在反射边界下质量守恒。\n    - 案例 3.2：在反射边界下，对称性（回文属性）在容差范围内得以保持。\n    - 案例 3.3：在周期性边界下，对称性在容差范围内得以保持。\n\n- 案例 4（库朗极限下的边缘稳定性，最小网格）：\n  - 参数：$L = 1.0$, $D = 0.1$, $N = 3$，初始化 $u^0 = [1.0, 0.0, 0.0]$，选择 $\\Delta t = \\Delta x^2/(2D)$ 以使 $\\alpha = 0.5$，并设置 $T = 5 \\Delta t$。\n  - 边界：周期性。\n  - 输出三个布尔值：\n    - 案例 4.1：质量守恒。\n    - 案例 4.2：在整个模拟过程中，所有值都保持有限（没有非数值或无穷大）。\n    - 案例 4.3：解保持在初始范围 $[\\min(u^0), \\max(u^0)]$ 内。\n\n容差策略：\n- 在比较浮点数量（例如，质量和对称性）时，使用绝对容差 $\\varepsilon_{\\text{abs}} = 10^{-10}$ 和相对容差 $\\varepsilon_{\\text{rel}} = 10^{-9}$。\n- 对于振幅比比较，使用 $\\varepsilon_{\\text{rel}} = 10^{-8}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,...]”）。按指定顺序（案例 1.1, 案例 1.2, 案例 1.3, 案例 2.1, 案例 2.2, 案例 2.3, 案例 3.1, 案例 3.2, 案例 3.3, 案例 4.1, 案例 4.2, 案例 4.3）列出四个案例的布尔值。", "solution": "问题陈述已经过分析并被确定为 **有效**。这是一个计算科学领域中定义明确、科学上合理的的问题，专注于数值模型的验证与确认。\n\n核心任务是使用有限差分法 (FDM) 模拟一维扩散方程，\n$$ \\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2} $$\n我们在均匀网格上采用前向时间、中心空间 (FTCS) 格式。\n\n令 $u_j^n$ 表示场 $u(x, t)$ 在网格点 $x_j = j \\Delta x$ 和时间 $t_n = n \\Delta t$ 处的数值近似。FTCS 离散格式为：\n$$ \\frac{u_j^{n+1} - u_j^n}{\\Delta t} = D \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{\\Delta x^2} $$\n重新整理得到时间推进的更新规则：\n$$ u_j^{n+1} = u_j^n + \\frac{D \\Delta t}{\\Delta x^2} (u_{j+1}^n - 2u_j^n + u_{j-1}^n) $$\n引入无量纲稳定性参数 $\\alpha = \\frac{D \\Delta t}{\\Delta x^2}$，更新规则变为：\n$$ u_j^{n+1} = u_j^n + \\alpha (u_{j+1}^n - 2u_j^n + u_{j-1}^n) $$\n此方程适用于网格的内部点。边界点需要根据指定的边界条件进行特殊处理。网格间距 $\\Delta x$ 取决于边界条件类型和长度为 $L$ 的域上的网格点数 $N$：\n- 对于反射边界：$\\Delta x = L/(N-1)$\n- 对于周期性边界：$\\Delta x = L/N$\n\n模拟运行总时间为 $T$。时间步长 $\\Delta t$ 最初由期望的 $\\alpha$ 值确定，$\\Delta t_{\\text{initial}} = \\alpha \\Delta x^2 / D$。然后步数为 $n = \\lceil T / \\Delta t_{\\text{initial}} \\rceil$。为确保模拟在 $T$ 时刻精确结束，时间步长被调整为 $\\Delta t = T/n$。这会轻微改变 $\\alpha$ 的值，必须为模拟循环重新计算。\n\n**边界条件实现**\n\n1.  **反射（诺伊曼）边界条件**：此条件 $\\frac{\\partial u}{\\partial x} = 0$ 意味着边界上没有通量。我们使用鬼点来实现这一点。\n    - 在左边界（$x=0$，索引 $j=0$）：引入一个鬼点 $u_{-1}^n$。梯度的中心差分给出 $\\frac{u_1^n - u_{-1}^n}{2 \\Delta x} = 0$，这意味着 $u_{-1}^n = u_1^n$。将此代入 $j=0$ 的通用更新规则中，得到：\n      $$ u_0^{n+1} = u_0^n + \\alpha(u_1^n - 2u_0^n + u_1^n) = u_0^n + 2\\alpha(u_1^n - u_0^n) $$\n    - 在右边界（$x=L$，索引 $j=N-1$）：使用一个鬼点 $u_{N}^n$。条件 $\\frac{u_{N}^n - u_{N-2}^n}{2 \\Delta x} = 0$ 意味着 $u_{N}^n = u_{N-2}^n$。将其代入 $j=N-1$ 的通用更新规则中：\n      $$ u_{N-1}^{n+1} = u_{N-1}^n + \\alpha(u_{N}^n - 2u_{N-1}^n + u_{N-2}^n) = u_{N-1}^n + 2\\alpha(u_{N-2}^n - u_{N-1}^n) $$\n\n2.  **周期性边界条件**：此条件 $u(x+L) = u(x)$ 意味着网格是环绕的。点 $u_0$ 的邻居是 $u_1$ 和 $u_{N-1}$，点 $u_{N-1}$ 的邻居是 $u_0$ 和 $u_{N-2}$。通过对索引使用模运算（例如，$(j+1) \\pmod N$ 和 $(j-1) \\pmod N$），通用更新规则适用于所有点 $j \\in \\{0, 1, \\dots, N-1\\}$。这可以使用 `numpy.roll` 高效实现。\n\n**验证与确认检查**\n\n使用一个辅助函数 `is_close(a, b, rtol, atol)` 来比较浮点值，实现为 `abs(a - b) = (atol + rtol * abs(b))`。\n\n- **质量守恒**：总离散质量为 $M = \\Delta x \\sum_{j=0}^{N-1} u_j$。我们使用 $\\varepsilon_{\\text{rel}} = 10^{-9}$ 和 $\\varepsilon_{\\text{abs}} = 10^{-10}$ 检查初始质量 $M_0$ 和最终质量 $M_f$ 是否接近。\n\n- **对称性保持**：对于一个回文的初始条件（$u_j^0 = u_{N-1-j}^0$），最终状态 $u^n$ 也应是回文的。这通过将最终数组 `u_final` 与其反转版本 `u_final[::-1]` 进行比较来检查。\n\n- **振幅衰减**：对于周期性余弦初始条件 $u_j^0 = \\cos\\left( \\frac{2\\pi k j}{N} \\right)$，FTCS 格式的理论放大因子为 $g_k = 1 - 4 \\alpha \\sin^2\\left(\\frac{\\pi k}{N}\\right)$。经过 $n$ 步后，最终振幅应为初始振幅的 $g_k^n$ 倍。测量的最终振幅取为 $u_0^n$。初始振幅为 $u_0^0 = 1$。该检查使用相对容差 $\\varepsilon_{\\text{rel}} = 10^{-8}$ 将测量比率 $u_0^n/u_0^0 = u_0^n$ 与理论比率 $g_k^n$ 进行比较。\n\n- **稳定性和范围**：对于 $\\alpha=0.5$ 的情况（处于稳定性极限），我们验证解保持有限（没有 `NaN` 或 `inf` 值），并遵守最大值原理，即 $u^n$ 中的值保持在初始值范围 $[\\min(u^0), \\max(u^0)]$ 内。\n\n所提供的 Python 代码在一个 `simulate` 函数中实现了这些原理，该函数处理两种边界条件的核心 FDM 逻辑。`solve` 函数按规定组织四个测试案例，计算十二个布尔结果，并以所需格式打印它们。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs a verification and validation exercise on a 1D diffusion model.\n    \"\"\"\n    \n    # Tolerance policy\n    ATOL = 1e-10\n    RTOL_MASS_SYM = 1e-9\n    RTOL_AMP = 1e-8\n\n    def simulate(L, D, N, T, u0_in, bc_type, alpha):\n        \"\"\"\n        Simulates the 1D diffusion equation using the FTCS scheme.\n        \"\"\"\n        u0 = u0_in.copy()\n        \n        if bc_type == 'reflective':\n            dx = L / (N - 1)\n        elif bc_type == 'periodic':\n            dx = L / N\n        else:\n            raise ValueError(\"Invalid boundary condition type.\")\n\n        # Determine dt and number of steps\n        if D > 0 and dx > 0:\n            dt_initial = alpha * dx**2 / D\n            if T > 0 and dt_initial > 0:\n                n_steps = int(np.ceil(T / dt_initial))\n            else:\n                n_steps = 1\n            if n_steps == 0:\n                n_steps = 1 # Ensure at least one step if T is very small\n        else: # Handle D=0 or dx=0 cases\n            dt_initial = 0\n            n_steps = 1\n        \n        dt = T / n_steps\n        \n        # Recalculate alpha with the adjusted dt\n        alpha_actual = D * dt / dx**2 if dx > 0 else 0.0\n\n        u = u0.copy()\n        for _ in range(n_steps):\n            u_new = u.copy()\n            if bc_type == 'reflective':\n                # Interior points\n                u_new[1:-1] = u[1:-1] + alpha_actual * (u[2:] - 2 * u[1:-1] + u[:-2])\n                # Boundary points\n                u_new[0] = u[0] + 2 * alpha_actual * (u[1] - u[0])\n                u_new[-1] = u[-1] + 2 * alpha_actual * (u[-2] - u[-1])\n            elif bc_type == 'periodic':\n                u_jp1 = np.roll(u, -1)\n                u_jm1 = np.roll(u, 1)\n                u_new = u + alpha_actual * (u_jp1 - 2 * u + u_jm1)\n            u = u_new\n            \n        return u, dx, dt, n_steps, alpha_actual\n\n    results = []\n\n    # --- Case 1 ---\n    L1, D1, N1, T1, alpha1 = 1.0, 0.1, 64, 0.1, 0.45\n    u0_1 = np.full(N1, 3.0)\n\n    # 1.1: Mass conservation (reflective)\n    u_ref_1, dx_ref_1, _, _, _ = simulate(L1, D1, N1, T1, u0_1, 'reflective', alpha1)\n    mass0_ref_1 = np.sum(u0_1) * dx_ref_1\n    massf_ref_1 = np.sum(u_ref_1) * dx_ref_1\n    results.append(np.isclose(mass0_ref_1, massf_ref_1, rtol=RTOL_MASS_SYM, atol=ATOL))\n\n    # 1.2: Mass conservation (periodic)\n    u_per_1, dx_per_1, _, _, _ = simulate(L1, D1, N1, T1, u0_1, 'periodic', alpha1)\n    mass0_per_1 = np.sum(u0_1) * dx_per_1\n    massf_per_1 = np.sum(u_per_1) * dx_per_1\n    results.append(np.isclose(mass0_per_1, massf_per_1, rtol=RTOL_MASS_SYM, atol=ATOL))\n\n    # 1.3: Final arrays equality\n    results.append(np.allclose(u_ref_1, u_per_1, rtol=RTOL_MASS_SYM, atol=ATOL))\n\n    # --- Case 2 ---\n    L2, D2, N2, T2, k2, alpha2 = 1.0, 0.2, 128, 0.05, 1, 0.10\n    j2 = np.arange(N2)\n    u0_2 = np.cos(2 * np.pi * k2 * j2 / N2)\n\n    # Periodic run for 2.1 and 2.2\n    u_per_2, dx_per_2, _, n_per_2, alpha_p_act_2 = simulate(L2, D2, N2, T2, u0_2, 'periodic', alpha2)\n\n    # 2.1: Mass conservation (periodic)\n    mass0_per_2 = np.sum(u0_2) * dx_per_2\n    massf_per_2 = np.sum(u_per_2) * dx_per_2\n    results.append(np.isclose(mass0_per_2, massf_per_2, rtol=RTOL_MASS_SYM, atol=ATOL))\n\n    # 2.2: Amplitude decay\n    g_k = 1 - 4 * alpha_p_act_2 * np.sin(np.pi * k2 / N2)**2\n    theo_ratio = g_k**n_per_2\n    meas_ratio = u_per_2[0] / u0_2[0]\n    results.append(np.isclose(meas_ratio, theo_ratio, rtol=RTOL_AMP, atol=ATOL))\n\n    # 2.3: Mass conservation (reflective)\n    u_ref_2, dx_ref_2, _, _, _ = simulate(L2, D2, N2, T2, u0_2, 'reflective', alpha2)\n    mass0_ref_2 = np.sum(u0_2) * dx_ref_2\n    massf_ref_2 = np.sum(u_ref_2) * dx_ref_2\n    results.append(np.isclose(mass0_ref_2, massf_ref_2, rtol=RTOL_MASS_SYM, atol=ATOL))\n\n    # --- Case 3 ---\n    L3, D3, N3, T3, alpha3 = 1.0, 0.1, 129, 0.05, 0.45\n    mid3 = (N3 - 1) / 2\n    u0_3 = 1.0 - np.abs(np.arange(N3) - mid3) / mid3\n\n    # 3.1: Mass conservation (reflective)\n    u_ref_3, dx_ref_3, _, _, _ = simulate(L3, D3, N3, T3, u0_3, 'reflective', alpha3)\n    mass0_ref_3 = np.sum(u0_3) * dx_ref_3\n    massf_ref_3 = np.sum(u_ref_3) * dx_ref_3\n    results.append(np.isclose(mass0_ref_3, massf_ref_3, rtol=RTOL_MASS_SYM, atol=ATOL))\n\n    # 3.2: Symmetry preservation (reflective)\n    results.append(np.allclose(u_ref_3, u_ref_3[::-1], rtol=RTOL_MASS_SYM, atol=ATOL))\n    \n    # 3.3: Symmetry preservation (periodic)\n    u_per_3, _, _, _, _ = simulate(L3, D3, N3, T3, u0_3, 'periodic', alpha3)\n    results.append(np.allclose(u_per_3, u_per_3[::-1], rtol=RTOL_MASS_SYM, atol=ATOL))\n\n    # --- Case 4 ---\n    L4, D4, N4 = 1.0, 0.1, 3\n    u0_4 = np.array([1.0, 0.0, 0.0])\n    alpha4 = 0.5\n    \n    # Override T calculation for this case\n    dx4 = L4 / N4\n    dt4 = alpha4 * dx4**2 / D4\n    T4 = 5 * dt4\n\n    # Run simulation with periodic BC\n    u_final_4, dx_final_4, _, n_steps_4, _ = simulate(L4, D4, N4, T4, u0_4, 'periodic', alpha4)\n    \n    # 4.1: Mass conservation\n    mass0_4 = np.sum(u0_4) * dx_final_4\n    massf_4 = np.sum(u_final_4) * dx_final_4\n    results.append(np.isclose(mass0_4, massf_4, rtol=RTOL_MASS_SYM, atol=ATOL))\n\n    # 4.2: Finiteness\n    results.append(np.all(np.isfinite(u_final_4)))\n    \n    # 4.3: Range preservation (Maximum Principle)\n    min_u0 = np.min(u0_4)\n    max_u0 = np.max(u0_4)\n    range_ok = np.all((u_final_4 >= min_u0 - ATOL)  (u_final_4 = max_u0 + ATOL))\n    results.append(range_ok)\n\n    # Format output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3201854"}, {"introduction": "模型验证与确认的原则不仅适用于基于物理的模拟，也同样适用于数据驱动的统计模型。本练习将探讨参数推断问题，其目标是从数据中估计模型参数。通过使用已知“真实”参数的合成数据，我们可以验证我们估计算法的正确性，并检验它们在不同类型噪声下的稳健性。[@problem_id:3201817]", "problem": "考虑一个零截距的单参数正向模型，其中观测数据点根据关系式 $y_i = \\theta x_i + \\varepsilon_i$（其中 $i = 1, \\dots, n$）生成。解释变量 $x_i$ 是从区间 $[1, 10]$ 上的均匀分布中独立采样的，而加性噪声 $\\varepsilon_i$ 在各 $i$ 之间是独立的。目标是通过使用噪声水平 $\\sigma$ 受控的合成数据集来验证参数推断的正确性（验证）并评估推断的稳健性（确认），并量化 $\\theta$ 的参数恢复准确性。\n\n使用以下基本原理：\n- 最大似然估计（MLE）原理：给定一个指定噪声分布的参数化概率模型 $p(y \\mid \\theta)$，$\\theta$ 的MLE会最大化观测数据的似然，等价于最小化负对数似然。\n- 对于高斯噪声，假设 $\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$ 且独立。在此假设下，MLE最小化残差平方和 $\\sum_{i=1}^n (y_i - \\theta x_i)^2$。\n- 对于拉普拉斯噪声，假设 $\\varepsilon_i \\sim \\mathrm{Laplace}(0, b)$ 且独立，其中拉普拉斯尺度参数 $b$ 与标准差的关系为 $b = \\sigma / \\sqrt{2}$。在此假设下，MLE最小化绝对残差和 $\\sum_{i=1}^n |y_i - \\theta x_i|$。\n\n基于这些原理，对于零截距模型，可以得出以下推断规则：\n- 在高斯假设下，MLE估计量满足正规方程，并简化为闭式估计量 $\\hat{\\theta}_{\\mathrm{OLS}} = \\frac{\\sum_{i=1}^n x_i y_i}{\\sum_{i=1}^n x_i^2}$，这是约束通过原点的回归的普通最小二乘法（OLS）斜率。\n- 在拉普拉斯假设下，MLE估计量求解 $\\min_{\\theta \\in \\mathbb{R}} \\sum_{i=1}^n |y_i - \\theta x_i|$。对于 $x_i \\neq 0$，该优化等价于计算比率 $r_i = y_i / x_i$ 的加权中位数，权重为 $w_i = |x_i|$，因为次梯度条件 $\\sum_{i=1}^n x_i \\,\\mathrm{sign}(y_i - \\theta x_i) = 0$ 是加权中位数解的特征。\n\n准确性度量：对于任何给定的数据集和估计量 $\\hat{\\theta}$，将参数恢复误差定义为绝对偏差 $E = |\\hat{\\theta} - \\theta_{\\mathrm{true}}|$。这是一个无量纲的量，因为模型纯粹是数学上的，尺度是任意的。\n\n针对给定参数 $(\\theta_{\\mathrm{true}}, \\sigma, n, \\text{noise type}, \\text{estimator}, \\text{seed})$ 的测试用例的合成数据生成协议：\n1. 使用指定的整数种子初始化伪随机数生成器。\n2. 对 $i = 1, \\dots, n$，从 $\\mathrm{Uniform}(1, 10)$ 中采样 $x_i$。\n3. 如果噪声类型为高斯噪声，从 $\\mathcal{N}(0, \\sigma^2)$ 中采样 $\\varepsilon_i$。如果噪声类型为拉普拉斯噪声，从 $\\mathrm{Laplace}(0, b)$ 中采样 $\\varepsilon_i$，其中 $b = \\sigma / \\sqrt{2}$。\n4. 构建 $y_i = \\theta_{\\mathrm{true}} x_i + \\varepsilon_i$。\n5. 如果估计量是 $\\mathrm{OLS}$，则计算 $\\hat{\\theta}$ 为 $\\hat{\\theta}_{\\mathrm{OLS}} = \\frac{\\sum_{i=1}^n x_i y_i}{\\sum_{i=1}^n x_i^2}$。如果估计量是 $\\mathrm{LAD}$（最小绝对偏差，即拉普拉斯MLE），则计算 $\\hat{\\theta}$ 为 $r_i = y_i/x_i$ 的加权中位数，权重为 $w_i = |x_i|$；$x_i = 0$ 的点（在指定的 $x_i$ 采样下几乎肯定不会出现）不携带关于 $\\theta$ 的信息，如果出现，应在加权中位数计算中排除。\n6. 计算并报告该测试用例的参数恢复误差 $E = |\\hat{\\theta} - \\theta_{\\mathrm{true}}|$。\n\n覆盖典型和边缘场景的测试套件（每个条目列出 $(\\theta_{\\mathrm{true}}, \\sigma, n, \\text{noise type}, \\text{estimator}, \\text{seed})$）：\n- 案例 $1$：$(2.0, 0.5, 200, \\text{gaussian}, \\text{OLS}, 10)$ 是一个通用的“理想路径”，其中估计量与高斯噪声模型匹配。\n- 案例 $2$：$(2.0, 0.5, 200, \\text{gaussian}, \\text{LAD}, 10)$ 是一个模型不匹配的案例，用于评估在高斯噪声下的稳健性。\n- 案例 $3$：$(1.5, 0.5, 200, \\text{laplace}, \\text{LAD}, 20)$ 是一个“理想路径”，其中估计量与拉普拉斯噪声模型匹配。\n- 案例 $4$：$(1.5, 0.5, 200, \\text{laplace}, \\text{OLS}, 20)$ 是一个模型不匹配的案例，用于评估在拉普拉斯噪声下的稳健性。\n- 案例 $5$：$(-3.0, 0.0, 50, \\text{gaussian}, \\text{OLS}, 30)$ 是一个无噪声的边界情况。\n- 案例 $6$：$(0.75, 5.0, 200, \\text{laplace}, \\text{LAD}, 40)$ 是一个高噪声重尾情况，用于探究稳健性。\n- 案例 $7$：$(1.0, 0.5, 5, \\text{laplace}, \\text{LAD}, 50)$ 是一个小样本场景，用于检验估计量的稳定性。\n- 案例 $8$：$(-1.0, 1.0, 100, \\text{gaussian}, \\text{OLS}, 60)$ 增加了对中等高斯噪声下负参数的覆盖。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个元素对应于所列顺序中的一个测试用例，并且是该用例的绝对参数恢复误差 $E$，四舍五入到六位小数。例如，一个有效的输出行格式为 $[\\text{E}_1, \\text{E}_2, \\dots, \\text{E}_8]$，其中每个 $\\text{E}_k$ 都呈现为小数点后有六位的十进制数。", "solution": "用户提供了一个关注计算科学背景下统计估计量验证与确认的问题。该问题定义明确，科学上合理，并为推导解决方案提供了清晰、正式的流程。\n\n该问题要求对一个简单线性模型的参数推断进行分析和实现。该模型是一个通过原点的单参数回归，由方程 $y_i = \\theta x_i + \\varepsilon_i$ 指定，其中 $i = 1, \\dots, n$。给定解释变量 $x_i$ 从均匀分布 $\\mathrm{Uniform}(1, 10)$ 中采样，噪声项 $\\varepsilon_i$ 是独立同分布的。核心任务是计算参数恢复误差 $E = |\\hat{\\theta} - \\theta_{\\mathrm{true}}|$，这需要针对由真实参数 $\\theta_{\\mathrm{true}}$、噪声水平 $\\sigma$、样本大小 $n$、噪声分布类型和所选估计量 $\\hat{\\theta}$ 定义的各种情景进行计算。\n\n理论基础是最大似然估计（MLE）。MLE估计量的具体形式取决于噪声项 $\\varepsilon_i$ 的假定概率分布。问题指定了两种情况：高斯噪声和拉普拉斯噪声。\n\n首先，考虑噪声是高斯分布的情况，$\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$。给定 $x_i$ 和 $\\theta$ 时，单个观测值 $y_i$ 的概率密度函数是 $p(y_i \\mid x_i, \\theta) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{(y_i - \\theta x_i)^2}{2\\sigma^2}\\right)$。假设独立性，整个数据集 $\\mathbf{y} = (y_1, \\dots, y_n)$ 的似然函数是单个密度的乘积：$L(\\theta; \\mathbf{y}, \\mathbf{x}) = \\prod_{i=1}^n p(y_i \\mid x_i, \\theta)$。对数似然是 $\\ln L(\\theta) = \\sum_{i=1}^n \\left( -\\frac{1}{2}\\ln(2\\pi\\sigma^2) - \\frac{(y_i - \\theta x_i)^2}{2\\sigma^2} \\right)$。为了找到 $\\theta$ 的MLE，我们最大化 $\\ln L(\\theta)$。这等价于最小化负对数似然，在舍去与 $\\theta$ 无关的项后，简化为最小化残差平方和：$\\mathrm{SSR}(\\theta) = \\sum_{i=1}^n (y_i - \\theta x_i)^2$。这就是普通最小二乘法（OLS）的原理。为了找到最小值，我们将关于 $\\theta$ 的导数设为零：$\\frac{d}{d\\theta} \\mathrm{SSR}(\\theta) = \\sum_{i=1}^n 2(y_i - \\theta x_i)(-x_i) = 0$。这简化为 $\\sum_{i=1}^n (x_i y_i - \\theta x_i^2) = 0$，从而给出OLS估计量的闭式解：\n$$\n\\hat{\\theta}_{\\mathrm{OLS}} = \\frac{\\sum_{i=1}^n x_i y_i}{\\sum_{i=1}^n x_i^2}\n$$\n当指定的 `estimator` 为 `OLS` 时，将使用此估计量。\n\n其次，考虑噪声服从拉普拉斯分布的情况，$\\varepsilon_i \\sim \\mathrm{Laplace}(0, b)$。标准差 $\\sigma$ 与尺度参数 $b$ 的关系是 $\\sigma = \\sqrt{2}b$，所以 $b = \\sigma / \\sqrt{2}$。概率密度函数是 $p(z) = \\frac{1}{2b} \\exp\\left(-\\frac{|z|}{b}\\right)$。对数似然是 $\\ln L(\\theta) = \\sum_{i=1}^n \\left( -\\ln(2b) - \\frac{|y_i - \\theta x_i|}{b} \\right)$。最大化它等价于最小化绝对残差和：$\\mathrm{SAR}(\\theta) = \\sum_{i=1}^n |y_i - \\theta x_i|$。这就是最小绝对偏差（LAD）的原理。这个优化问题没有像OLS那样简单的闭式解，因为目标函数不是处处可微的。然而，问题正确地指出，对于模型 $y_i = \\theta x_i + \\varepsilon_i$，最小化 $\\sum_{i=1}^n |y_i - \\theta x_i|$ 等价于找到单个斜率估计值 $r_i = y_i / x_i$ 的加权中位数，其中权重为 $w_i = |x_i|$。由于问题指定 $x_i \\in [1, 10]$，所有 $x_i$ 都是正数，因此一个有效的实现可以使用权重 $w_i = x_i$。当指定的 `estimator` 为 `LAD` 时，将使用此估计量。加权中位数的计算算法如下：\n$1$. 对于每个数据点 $(x_i, y_i)$，计算比率 $r_i = y_i / x_i$ 和权重 $w_i = |x_i|$。\n$2$. 根据 $r_i$ 的值对 $(r_i, w_i)$ 对进行排序。让排序后的比率为 $r_{(j)}$，对应的权重为 $w_{(j)}$。\n$3$. 计算排序后权重的累积和，$C_k = \\sum_{j=1}^k w_{(j)}$。\n$4$. 找到第一个索引 $k$，使得累积权重 $C_k$ 大于或等于总权重的一半，即 $C_k \\ge \\frac{1}{2} \\sum_{i=1}^n w_i$。\n$5$. 加权中位数是对应的比率，$\\hat{\\theta}_{\\mathrm{LAD}} = r_{(k)}$。\n\n解决该问题的总体流程包括遍历所提供的八个测试用例。对于每个由 $(\\theta_{\\mathrm{true}}, \\sigma, n, \\text{noise type}, \\text{estimator}, \\text{seed})$ 指定的用例：\n$1$. 使用给定的 `seed` 初始化一个伪随机数生成器以确保可复现性。\n$2$. 从 $\\mathrm{Uniform}(1, 10)$ 分布中生成 $n$ 个解释变量 $x_i$ 的样本。\n$3$. 生成 $n$ 个噪声项 $\\varepsilon_i$ 的样本。如果 `noise type` 是 `gaussian`，则从 $\\mathcal{N}(0, \\sigma^2)$ 中采样。如果 `noise type` 是 `laplace`，则计算尺度参数 $b = \\sigma / \\sqrt{2}$ 并从 $\\mathrm{Laplace}(0, b)$ 中采样。\n$4$. 构建观测数据 $y_i = \\theta_{\\mathrm{true}} x_i + \\varepsilon_i$。\n$5$. 使用指定的 `estimator`（`OLS` 或 `LAD`）对合成数据集 $(\\mathbf{x}, \\mathbf{y})$ 计算参数估计值 $\\hat{\\theta}$。\n$6$. 计算绝对参数恢复误差 $E = |\\hat{\\theta} - \\theta_{\\mathrm{true}}|$。该值是该测试用例的结果。\n\n对所有八个测试用例重复此过程，并将所得误差收集并按指定格式格式化。$\\sigma = 0$ 的案例5是一个特殊的验证案例。在这里，对所有 $i$ 都有 $\\varepsilon_i = 0$，所以 $y_i = \\theta_{\\mathrm{true}} x_i$。OLS估计量应能精确恢复真实参数：$\\hat{\\theta}_{\\mathrm{OLS}} = \\frac{\\sum x_i (\\theta_{\\mathrm{true}} x_i)}{\\sum x_i^2} = \\theta_{\\mathrm{true}} \\frac{\\sum x_i^2}{\\sum x_i^2} = \\theta_{\\mathrm{true}}$。因此误差 $E$ 必须为 $0$。这可以用来检查OLS实现的正确性。其他案例测试估计量在匹配的噪声模型下（一致性验证，例如案例1）和不匹配的噪声模型下（稳健性确认，例如案例2）的性能。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef weighted_median(values, weights):\n    \"\"\"\n    Computes the weighted median of a 1D array of values.\n    \n    Args:\n        values (np.ndarray): The data values.\n        weights (np.ndarray): The corresponding weights.\n\n    Returns:\n        float: The weighted median.\n    \"\"\"\n    if not isinstance(values, np.ndarray):\n        values = np.array(values)\n    if not isinstance(weights, np.ndarray):\n        weights = np.array(weights)\n    \n    # Sort values and their corresponding weights\n    sorter = np.argsort(values)\n    sorted_values = values[sorter]\n    sorted_weights = weights[sorter]\n    \n    # Calculate cumulative weights\n    cum_weights = np.cumsum(sorted_weights)\n    total_weight = cum_weights[-1]\n    \n    # Find the index of the median value. The weighted median is the first\n    # value for which the cumulative weight is >= half the total weight.\n    # The 'side' parameter ensures we get the correct behavior for this definition.\n    median_idx = np.searchsorted(cum_weights, total_weight / 2.0, side='left')\n    \n    # Handle the edge case where all weights might be zero or floating point\n    # issues might push the index out of bounds.\n    if median_idx == len(sorted_values):\n        median_idx -= 1\n        \n    return sorted_values[median_idx]\n\ndef compute_error(theta_true, sigma, n, noise_type, estimator, seed):\n    \"\"\"\n    Generates synthetic data and computes the parameter recovery error for a single test case.\n    \n    Args:\n        theta_true (float): The true value of the parameter theta.\n        sigma (float): The standard deviation of the noise.\n        n (int): The number of data points.\n        noise_type (str): Type of noise ('gaussian' or 'laplace').\n        estimator (str): Type of estimator ('OLS' or 'LAD').\n        seed (int): The seed for the random number generator.\n\n    Returns:\n        float: The absolute parameter recovery error.\n    \"\"\"\n    # 1. Initialize a pseudorandom number generator with the specified seed.\n    rng = np.random.default_rng(seed)\n    \n    # 2. Sample x_i from Uniform(1, 10).\n    x = rng.uniform(low=1.0, high=10.0, size=n)\n    \n    # 3. Generate noise epsilon_i based on noise type and sigma.\n    if sigma == 0.0:\n        epsilon = np.zeros(n)\n    elif noise_type == 'gaussian':\n        epsilon = rng.normal(loc=0.0, scale=sigma, size=n)\n    elif noise_type == 'laplace':\n        # For Laplace(0, b), variance is 2*b^2. So sigma = sqrt(2)*b, or b = sigma/sqrt(2).\n        b_scale = sigma / np.sqrt(2.0)\n        epsilon = rng.laplace(loc=0.0, scale=b_scale, size=n)\n    else:\n        raise ValueError(f\"Unknown noise type: {noise_type}\")\n        \n    # 4. Form y_i = theta_true * x_i + epsilon_i.\n    y = theta_true * x + epsilon\n    \n    # 5. Compute the parameter estimate theta_hat.\n    if estimator == 'OLS':\n        # OLS estimator for zero-intercept model: sum(x*y) / sum(x^2).\n        theta_hat = np.sum(x * y) / np.sum(x**2)\n    elif estimator == 'LAD':\n        # LAD estimator for zero-intercept model is the weighted median of y/x.\n        # The weights are |x|. Since x is sampled from [1, 10], |x| = x.\n        ratios = y / x\n        weights = x\n        theta_hat = weighted_median(ratios, weights)\n    else:\n        raise ValueError(f\"Unknown estimator: {estimator}\")\n        \n    # 6. Compute the absolute parameter recovery error.\n    error = np.abs(theta_hat - theta_true)\n    \n    return error\n\ndef solve():\n    \"\"\"\n    Execute the full test suite and print the results in the required format.\n    \"\"\"\n    # Test suite as defined in the problem statement.\n    # Each tuple: (theta_true, sigma, n, noise_type, estimator, seed)\n    test_cases = [\n        (2.0, 0.5, 200, 'gaussian', 'OLS', 10),\n        (2.0, 0.5, 200, 'gaussian', 'LAD', 10),\n        (1.5, 0.5, 200, 'laplace', 'LAD', 20),\n        (1.5, 0.5, 200, 'laplace', 'OLS', 20),\n        (-3.0, 0.0, 50, 'gaussian', 'OLS', 30),\n        (0.75, 5.0, 200, 'laplace', 'LAD', 40),\n        (1.0, 0.5, 5, 'laplace', 'LAD', 50),\n        (-1.0, 1.0, 100, 'gaussian', 'OLS', 60)\n    ]\n    \n    results = []\n    for case in test_cases:\n        error = compute_error(*case)\n        results.append(error)\n        \n    # Format the final output string according to the problem requirements.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3201817"}]}