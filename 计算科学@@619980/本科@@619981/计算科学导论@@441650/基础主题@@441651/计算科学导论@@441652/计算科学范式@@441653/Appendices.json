{"hands_on_practices": [{"introduction": "计算科学的核心是验证，即确保我们的代码正确地实现了数学模型。本练习将引导您使用一种强大的技术——基于属性的测试——来验证一个简单的一维热方程求解器。您将学习如何利用守恒定律和对称性等基本物理不变量，通过自动化的随机测试来发现代码中的缺陷，从而建立对程序正确性的信心。[@problem_id:3109343]", "problem": "设计并实现一个独立的程序，该程序演示通过基于属性的测试来验证科学代码的计算科学范式。该程序必须实例化一个简单的、具有物理动机的数值模型，并使用随机生成的输入来测试核心不变量是否得到遵守。模型、不变量和测试策略详述如下。\n\n模型。考虑一个具有 $N$ 个点的一维周期性离散网格上的热方程（也称为扩散方程），其连续形式为 $u_t = D u_{xx}$，其中 $u$ 表示一个标量场，$D$ 是扩散系数。使用标准的显式前向欧拉有限差分时间推进法，配合对称三点模板、周期性边界条件和无量纲化参数。将离散状态定义为一个向量 $u \\in \\mathbb{R}^N$，并执行一个时间步长\n$$\nu_i^{\\text{new}} \\;=\\; u_i^{\\text{old}} \\;+\\; \\alpha \\,\\big(u_{i-1}^{\\text{old}} \\;-\\; 2\\,u_i^{\\text{old}} \\;+\\; u_{i+1}^{\\text{old}}\\big)\n$$\n对所有索引 $i \\in \\{0,1,\\dots,N-1\\}$ 进行计算，索引采用周期性方式，即 $u_{-1} \\equiv u_{N-1}$ 和 $u_{N} \\equiv u_0$。标量 $\\alpha \\ge 0$ 编码了无量纲化的时间步长和扩散常数。该模型是计算科学中用于研究守恒、对称性和单调性属性的典型实例。\n\n基本基础和不变量。以下不变量源于核心的物理和数学原理，必须用于构建基于属性的测试：\n- 总量（质量）守恒。对于周期性边界和上述对称模板，离散总量 $S = \\sum_{i=0}^{N-1} u_i$ 在更新步骤下应保持守恒，这反映了在没有源和汇的情况下物理质量的守恒。\n- 空间反射下的对称等变性。定义离散反射算子 $\\mathcal{R}$ 为 $(\\mathcal{R}u)_i = u_{N-1-i}$。由于模板是对称的，因此对反射后的状态执行步进，然后反射结果，这两个操作应该可以交换顺序：\n$$\n\\text{step}(\\mathcal{R}u) \\;=\\; \\mathcal{R}(\\text{step}(u)).\n$$\n- 值域的单调性。对于 $0 \\le \\alpha \\le \\tfrac{1}{2}$，更新是 $u_{i-1}$、$u_i$ 和 $u_{i+1}$ 的一个非负凸组合；因此，离散值域 $R(u) = \\max_i u_i - \\min_i u_i$ 在步进操作下应该是非增的（即 $R(u^{\\text{new}}) \\le R(u^{\\text{old}})$）。这捕捉了扩散的平滑特性。\n\n测试策略。通过生成随机状态 $u$ 并自动检查上述不变量来实施基于属性的测试。对于数值验证，采用容差 $\\varepsilon = 10^{-10}$ 并如下定义违规：\n- 守恒违规：如果 $\\big|\\sum_i u_i^{\\text{new}} - \\sum_i u_i^{\\text{old}}\\big| > \\varepsilon$。\n- 对称等变性违规：如果 $\\max_i \\big|(\\text{step}(\\mathcal{R}u))_i - (\\mathcal{R}(\\text{step}(u)))_i\\big| > \\varepsilon$。\n- 单调性违规：如果 $R(u^{\\text{new}}) - R(u^{\\text{old}}) > \\varepsilon$。\n\n缺陷注入。为了模拟代码缺陷，您必须实现步进的两种变体：\n- 一种使用循环移位（即周期性邻居）的正确周期性实现。\n- 一种错误的实现，它在两端错误地使用了零边界条件，即，将 $\\{0,\\dots,N-1\\}$ 之外的邻居视为 $0$ 而不是环绕。此缺陷应会破坏守恒性和对称性，也可能影响单调性。\n\n随机输入生成。对于每个测试用例，从 $[0,1]$ 上的均匀分布中抽样分量，生成 $T$ 个独立的随机状态 $u$。此外，如果测试用例指定“包含零”，则插入一个额外的试验，该试验由全零状态 $u = 0$ 组成，以探查平凡不变量的满足情况。使用提供的种子以确保可复现性。\n\n测试套件。您的程序必须评估以下测试用例，每个用例都以元组 $(N,\\alpha,T,\\text{seed},\\text{mode},\\text{include\\_zero})$ 的形式给出：\n- 用例 1：$(64, 0.2, 200, 101, \\text{``correct''}, \\text{True})$。\n- 用例 2：$(64, 0.49, 200, 102, \\text{``correct''}, \\text{True})$。\n- 用例 3：$(64, 0.6, 200, 103, \\text{``correct''}, \\text{False})$。\n- 用例 4：$(64, 0.2, 200, 104, \\text{``buggy''}, \\text{True})$。\n- 用例 5：$(1, 0.2, 50, 105, \\text{``correct''}, \\text{True})$。\n- 用例 6：$(32, 0.2, 200, 106, \\text{``buggy''}, \\text{False})$。\n\n所需输出。对于每个测试用例，汇总其所有试验中观察到的三个不变量的违规次数，顺序固定为：守恒、对称等变性、单调性。将每个测试用例的结果表示为一个包含三个整数的列表 $[c,s,m]$，其中 $c$ 是守恒违规计数， $s$ 是对称等变性违规计数， $m$ 是单调性违规计数。您的程序必须生成单行输出，其中包含所有用例的结果，格式为逗号分隔的列表，并用方括号括起来，即一个 Python 风格的列表的列表。因此，该行应表示一个包含 6 个元素的列表，每个元素都是一个按所述顺序排列的三个整数的列表。\n\n角度单位不适用。无需进行物理单位转换。\n\n科学真实性。模型、不变量和测试源于广泛使用的数值分析和物理原理。所选参数在合理的范围内。随机化试验模拟了计算科学中常见的基于属性的测试。\n\n您的解决方案必须推导、实现和测试这些属性，而不依赖于未经上述基本基础证明的快捷公式。最终答案必须是一个完整的、可运行的程序，能够产生指定的单行输出。", "solution": "该问题要求设计并实现一个基于属性的测试框架，以验证一维热方程的数值模型。这涉及到实现数值方案，形式化定义其基本不变量，然后使用随机生成的数据系统地测试这些不变量是否被违反。\n\n### 1. 数值模型与实现\n\n该物理系统由周期性域上的热方程 $u_t = D u_{xx}$ 控制。我们在一个包含 $N$ 个点的网格上离散化该系统，状态由一个向量 $u \\in \\mathbb{R}^N$ 表示。时间演化采用显式前向欧拉方法建模，空间二阶导数使用中心三点模板。每个网格点 $u_i$ 的更新规则如下：\n$$\nu_i^{\\text{new}} = u_i^{\\text{old}} + \\alpha \\left(u_{i-1}^{\\text{old}} - 2u_i^{\\text{old}} + u_{i+1}^{\\text{old}}\\right)\n$$\n其中 $\\alpha \\ge 0$ 是一个结合了时间步长和扩散系数的无量纲参数。索引以周期性方式处理，即 $u_{-1} \\equiv u_{N-1}$ 和 $u_N \\equiv u_0$。\n\n此更新可以表示为适合数值计算的向量化形式。括号中的项是离散拉普拉斯算子 $\\Delta_d u$。\n\n**正确实现（周期性边界）：**\n对于周期性边界，$u_i$ 的邻居是 $u_{(i-1) \\pmod N}$ 和 $u_{(i+1) \\pmod N}$。此操作可以使用状态向量 $u$ 上的循环移位来高效实现。设 $u^{\\text{old}}$ 是前一个时间步的状态值向量。新的状态向量 $u^{\\text{new}}$ 是：\n$$\nu^{\\text{new}} = u^{\\text{old}} + \\alpha \\left( \\text{shift}(u^{\\text{old}}, 1) - 2u^{\\text{old}} + \\text{shift}(u^{\\text{old}}, -1) \\right)\n$$\n其中 $\\text{shift}(u, k)_i = u_{(i-k) \\pmod N}$。这对应于 NumPy 中的 `np.roll`。\n\n**错误实现（零边界）：**\n一个常见的缺陷是边界条件的错误处理。错误的实现通过将“幽灵”单元格的值设为零来假定零通量边界。对于 $i=0$，邻居 $u_{-1}$ 被视为 $0$。对于 $i=N-1$，邻居 $u_N$ 被视为 $0$。边界上的更新规则变为：\n$$\nu_0^{\\text{new}} = u_0^{\\text{old}} + \\alpha \\left(0 - 2u_0^{\\text{old}} + u_1^{\\text{old}}\\right)\n$$\n$$\nu_{N-1}^{\\text{new}} = u_{N-1}^{\\text{old}} + \\alpha \\left(u_{N-2}^{\\text{old}} - 2u_{N-1}^{\\text{old}} + 0\\right)\n$$\n内部点 $i \\in \\{1, \\dots, N-2\\}$ 使用标准模板进行更新。\n\n### 2. 不变量与基于属性的测试\n\n我们根据源自底层物理和数学的三个基本属性来验证这些实现。\n\n**A. 总量守恒**\n此属性反映了封闭系统中质量或能量的守恒。总量是和 $S = \\sum_{i=0}^{N-1} u_i$。\n对于**正确**的周期性实现，让我们对所有 $i$ 求和更新规则：\n$$\n\\sum_{i=0}^{N-1} u_i^{\\text{new}} = \\sum_{i=0}^{N-1} u_i^{\\text{old}} + \\alpha \\sum_{i=0}^{N-1} \\left(u_{i-1}^{\\text{old}} - 2u_i^{\\text{old}} + u_{i+1}^{\\text{old}}\\right)\n$$\n最后一项在周期性边界下是一个离散的伸缩求和：\n$$\n\\sum_{i=0}^{N-1} (u_{i-1} - 2u_i + u_{i+1}) = \\sum u_{i-1} - 2\\sum u_i + \\sum u_{i+1} = S^{\\text{old}} - 2S^{\\text{old}} + S^{\\text{old}} = 0\n$$\n因此，$\\sum u_i^{\\text{new}} = \\sum u_i^{\\text{old}}$。总和是一个不变量。\n对于**错误**的实现，离散拉普拉斯算子的和是 $\\sum_{i=0}^{N-1} L_i = -u_0 - u_{N-1}$（通过逐项求和推导），这通常是非零的。因此，守恒性被违反。\n测试检查 $|\\sum u_i^{\\text{new}} - \\sum u_i^{\\text{old}}| > \\varepsilon$ 是否成立，其中 $\\varepsilon=10^{-10}$。\n\n**B. 空间反射下的对称等变性**\n反射算子定义为 $(\\mathcal{R}u)_i = u_{N-1-i}$。模板的对称性意味着时间步长操作 $\\text{step}(\\cdot)$ 应与 $\\mathcal{R}$ 可交换：$\\text{step}(\\mathcal{R}u) = \\mathcal{R}(\\text{step}(u))$。\n对于**正确**的实现，在反射状态 $(\\mathcal{R}u)$ 上索引 $i$ 处的更新取决于 $u_{N-1-(i-1)}, u_{N-1-i}, u_{N-1-(i+1)}$。在原始状态 $u$ 上索引 $N-1-i$ 处的更新取决于 $u_{N-1-i-1}, u_{N-1-i}, u_{N-1-i+1}$。因为 $i\\pm1$ 邻居的系数相同，所以这两个操作产生相同的结果。\n**错误**的实现破坏了这种对称性。零边界条件应用于索引 $0$ 和 $N-1$。当我们计算 $\\text{step}(\\mathcal{R}u)$ 时，零边界条件应用于 $(\\mathcal{R}u)_0 = u_{N-1}$ 和 $(\\mathcal{R}u)_{N-1} = u_0$。当我们计算 $\\mathcal{R}(\\text{step}(u))$ 时，我们反射的是将零边界条件应用于 $u_0$ 和 $u_{N-1}$ 的结果。这些操作是不等价的。\n测试检查 $\\max_i |(\\text{step}(\\mathcal{R}u))_i - (\\mathcal{R}(\\text{step}(u)))_i| > \\varepsilon$ 是否成立。\n\n**C. 值域的单调性**\n对于 $0 \\le \\alpha \\le \\frac{1}{2}$，更新规则是非负系数的凸组合：\n$$\nu_i^{\\text{new}} = \\alpha u_{i-1}^{\\text{old}} + (1-2\\alpha)u_i^{\\text{old}} + \\alpha u_{i+1}^{\\text{old}}\n$$\n其中 $\\alpha \\ge 0$ 且 $(1-2\\alpha) \\ge 0$。系数之和为 1。此属性被称为离散极值原理。它意味着新值 $u_i^{\\text{new}}$ 不会超出其贡献的旧值的范围。全局来看，这意味着 $\\min(u^{\\text{old}}) \\le \\min(u^{\\text{new}})$ 和 $\\max(u^{\\text{new}}) \\le \\max(u^{\\text{old}})$。因此，值域 $R(u) = \\max_i u_i - \\min_i u_i$ 必须是非增的：$R(u^{\\text{new}}) \\le R(u^{\\text{old}})$。\n只要 $0 \\le \\alpha \\le \\frac{1}{2}$，此属性对于**正确**和**错误**的实现都成立，因为在错误情况下，边界上的更新规则也构成凸组合。\n当 $\\alpha > \\frac{1}{2}$ 时，预计此属性不成立，这对应于一个物理上和数值上都不稳定的区域。\n测试检查 $R(u^{\\text{new}}) - R(u^{\\text{old}}) > \\varepsilon$ 是否成立。\n\n### 3. 测试流程\n\n程序迭代一组预定义的测试用例。对于每个用例，它使用给定的种子初始化一个随机数生成器以保证可复现性。它生成 $T$ 个随机状态向量 $u$，其分量从 $[0,1]$ 上的均匀分布中抽取。如果指定，则包含一个使用零向量 $u=0$ 的额外试验。对于每个试验状态，程序应用指定的（`correct` 或 `buggy`）时间步长函数，并检查三个不变量的违反情况。每个不变量的总违规次数被计数并报告。这个自动化过程是基于属性的测试的典范，其中系统的抽象属性在一大组随机输入上得到验证，从而为正确性提供有力证据或揭示细微的错误。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef step_correct(u: np.ndarray, alpha: float) -> np.ndarray:\n    \"\"\"\n    Performs one time step of the 1D heat equation with periodic boundary conditions.\n    \"\"\"\n    if u.size == 0:\n        return np.array([])\n    # The discrete Laplacian with periodic boundaries is implemented via circular shifts.\n    laplacian = np.roll(u, 1) - 2 * u + np.roll(u, -1)\n    return u + alpha * laplacian\n\ndef step_buggy(u: np.ndarray, alpha: float) -> np.ndarray:\n    \"\"\"\n    Performs one time step of the 1D heat equation with buggy zero boundary conditions.\n    \"\"\"\n    n = u.size\n    if n == 0:\n        return np.array([])\n    \n    u_new = np.copy(u)\n    \n    # Interior points update\n    if n > 2:\n        laplacian_interior = u[:-2] - 2 * u[1:-1] + u[2:]\n        u_new[1:-1] += alpha * laplacian_interior\n\n    # Boundary points update with zero-value neighbors\n    if n >= 2:\n        # Left boundary i=0, neighbor u_{-1} is 0\n        laplacian_0 = 0 - 2 * u[0] + u[1]\n        u_new[0] += alpha * laplacian_0\n        # Right boundary i=n-1, neighbor u_{n} is 0\n        laplacian_n_minus_1 = u[n-2] - 2 * u[n-1] + 0\n        u_new[n-1] += alpha * laplacian_n_minus_1\n    elif n == 1:\n        # Special case for N=1, both neighbors are 0\n        laplacian_0 = 0 - 2 * u[0] + 0\n        u_new[0] += alpha * laplacian_0\n\n    return u_new\n\ndef solve():\n    \"\"\"\n    Main function to run the property-based tests for the given cases.\n    \"\"\"\n    test_cases = [\n        (64, 0.2, 200, 101, \"correct\", True),\n        (64, 0.49, 200, 102, \"correct\", True),\n        (64, 0.6, 200, 103, \"correct\", False),\n        (64, 0.2, 200, 104, \"buggy\", True),\n        (1, 0.2, 50, 105, \"correct\", True),\n        (32, 0.2, 200, 106, \"buggy\", False),\n    ]\n\n    all_results = []\n    epsilon = 1e-10\n\n    for n, alpha, t, seed, mode, include_zero in test_cases:\n        \n        # 1. Select the stepping function based on the test case mode\n        step_func = step_correct if mode == \"correct\" else step_buggy\n\n        # 2. Generate random states for testing\n        rng = np.random.default_rng(seed)\n        states = [rng.uniform(0, 1, size=n) for _ in range(t)]\n        if include_zero:\n            states.append(np.zeros(n))\n        \n        # 3. Initialize violation counters\n        conservation_violations = 0\n        symmetry_violations = 0\n        monotonicity_violations = 0\n\n        # 4. Iterate through test states and check invariants\n        for u_old in states:\n            if u_old.size == 0:\n                continue\n            \n            # --- Perform one time step ---\n            u_new = step_func(u_old, alpha)\n\n            # --- Test 1: Conservation of total quantity ---\n            sum_old = np.sum(u_old)\n            sum_new = np.sum(u_new)\n            if np.abs(sum_new - sum_old) > epsilon:\n                conservation_violations += 1\n\n            # --- Test 2: Symmetry equivariance ---\n            # LHS: step(reflect(u))\n            u_reflected = u_old[::-1]\n            lhs = step_func(u_reflected, alpha)\n            # RHS: reflect(step(u))\n            rhs = u_new[::-1]\n            \n            if np.max(np.abs(lhs - rhs)) > epsilon:\n                symmetry_violations += 1\n\n            # --- Test 3: Monotonicity of the range ---\n            # This property is only guaranteed for 0 <= alpha <= 0.5\n            # The test is run for all alpha to see when it fails.\n            if u_old.size > 0:\n                range_old = np.max(u_old) - np.min(u_old)\n                range_new = np.max(u_new) - np.min(u_new)\n                if range_new - range_old > epsilon:\n                    monotonicity_violations += 1\n            \n        all_results.append([conservation_violations, symmetry_violations, monotonicity_violations])\n\n    # Final print statement in the exact required format.\n    print(f\"{all_results}\")\n\nsolve()\n```", "id": "3109343"}, {"introduction": "一个经过验证的程序是可靠计算研究的必要条件，但还不够。我们还必须仔细审视离散化过程对解的影响。本练习将揭示一个看似无害的网格设计选择，如何能够破坏物理模型固有的基本对称性。通过这个泊松方程求解器的实例，您将亲身体会到连续模型与其离散表示之间的微妙而关键的联系。[@problem_id:3109385]", "problem": "计算科学范式的一个核心主题是从建模，经过离散化和算法求解，到验证和解释的严谨过程。考虑一个在方形域 $[0,1] \\times [0,1]$ 上的二维稳态扩散模型，其边界上具有齐次狄利克雷边界条件 $u=0$。其控制方程为泊松方程 $ \\nabla^2 u = -f $，其中 $f$ 是一个源项。在连续模型中，如果源 $f$ 是一个位于 $(x,y)=(0.5,0.5)$、总强度为 $S$ 的点源，那么解 $u(x,y)$ 关于 $(0.5,0.5)$ 是径向对称的。\n\n在本问题中，您将创建一个测试案例，其中对称性因特定基于网格的表示引入的离散化偏差而发生破缺，然后重新设计网格以恢复对称性，并量化其对输出的影响。这些任务必须以纯粹的数学和算法术语完成，并产生可量化测试的输出。\n\n建模和离散化：\n- 在 $[0,1] \\times [0,1]$ 上使用泊松方程 $ \\nabla^2 u = -f $，边界条件为 $u=0$，其中 $f$ 表示位于中心 $(0.5,0.5)$、总强度为 $S=1$ 的点源的离散近似。\n- 使用一个笛卡尔网格对域进行离散化，该网格在 $x$ 方向有 $N_x$ 个点，在 $y$ 方向有 $N_y$ 个点，允许 $N_x \\neq N_y$。网格间距为 $h_x = 1/(N_x-1)$ 和 $h_y = 1/(N_y-1)$。\n- 使用从内部节点泰勒展开导出的二阶中心有限差分法来离散化拉普拉斯算子 $ \\nabla^2 u $；为内部未知量组装一个稀疏线性系统，并将齐次狄利克雷边界值合并进去。\n- 通过将整个源强度 $S$ 分配给由每个坐标向下取整（floor）确定的单个最近网格节点，来离散地表示点源。具体来说，令 $I_c = \\lfloor 0.5\\,(N_x-1) \\rfloor$ 和 $J_c = \\lfloor 0.5\\,(N_y-1) \\rfloor$ 为在完整网格索引 $0,\\dots,N_x-1$ 和 $0,\\dots,N_y-1$ 中所选源节点的索引。将此节点映射到内部系统中，并将其右端项设为 $S$。每当 $(0.5,0.5)$ 不恰好是网格节点时，这个向下取整规则就会引入离散化偏差。\n\n对称性量化：\n- 定义镜像算子 $M$，它将离散场绕中心翻转：$M(u)[i,j] = u[N_x-1-i, N_y-1-j]$，适用于所有网格索引 $(i,j)$。计算相对不对称性度量\n$$\nE_{\\mathrm{sym}} = \\frac{\\lVert u - M(u) \\rVert_2}{\\lVert u \\rVert_2},\n$$\n其中 $\\lVert \\cdot \\rVert_2$ 表示展平的网格场的欧几里得范数。\n- 令 $(i_{\\max}, j_{\\max})$ 为计算出的离散场 $u$ 的最大值索引。计算该最大值与物理中心的偏移量\n$$\nd_{\\max} = \\sqrt{\\big(i_{\\max}\\,h_x - 0.5\\big)^2 + \\big(j_{\\max}\\,h_y - 0.5\\big)^2 }.\n$$\n\n测试套件和输出：\n- 使用三个测试案例：\n  1. 一个由于在偶数网格上离散化偏差导致的对称性破缺案例：$N_x=80$, $N_y=80$，源强度 $S=1$，基于向下取整的最近节点源布置。\n  2. 一个将中心与网格节点对齐的重新设计的对称网格：$N_x=81$, $N_y=81$，源强度 $S=1$，基于向下取整的最近节点源布置（当 $N_x$ 和 $N_y$ 均为奇数时，该方法会精确选中中心节点）。\n  3. 一个各向异性但中心对齐的网格：$N_x=81$, $N_y=21$，源强度 $S=1$，基于向下取整的最近节点源布置。\n\n对于每个测试案例，求解离散线性系统以获得内部场，将其扩展为包含边界零值的完整 $N_x \\times N_y$ 网格，计算 $E_{\\mathrm{sym}}$ 和 $d_{\\max}$，并报告这两个值。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个测试案例的结果，格式为方括号内的逗号分隔列表，每个测试案例的结果是一个双元素列表 $[E_{\\mathrm{sym}}, d_{\\max}]$，两个值都四舍五入到六位小数。例如，输出格式必须严格为\n$[[E_1,d_1],[E_2,d_2],[E_3,d_3]]$\n不含任何空格。", "solution": "该问题要求在单位方形域 $\\Omega = [0,1] \\times [0,1]$ 上，对二维泊松方程 $\\nabla^2 u = -f$ 进行数值求解，边界条件为齐次狄利克雷条件 $u=0$ on $\\partial\\Omega$。问题的核心是研究当源项 $f$ 是位于域中心 $(0.5, 0.5)$、强度为 $S=1$ 的点源的离散近似时，网格离散化对数值解对称性的影响。\n\n求解过程首先采用有限差分法对控制偏微分方程进行离散化，得到一个线性代数方程组。然后，针对三种不同的网格配置求解该系统，以量化离散化选择对对称性的影响。\n\n该域使用笛卡尔网格进行离散化，在 $x$ 方向有 $N_x$ 个点，在 $y$ 方向有 $N_y$ 个点。网格间距为 $h_x = 1/(N_x-1)$ 和 $h_y = 1/(N_y-1)$。在网格点 $(x_i, y_j) = (i h_x, j h_y)$ 处的解值表示为 $u_{i,j}$，其中 $i \\in \\{0, \\dots, N_x-1\\}$ 且 $j \\in \\{0, \\dots, N_y-1\\}$。\n\n在一个内部网格点 $(i,j)$（其中 $1 \\le i \\le N_x-2$ 且 $1 \\le j \\le N_y-2$）处，拉普拉斯算子 $\\nabla^2 u$ 使用二阶中心有限差分格式进行近似：\n$$\n\\nabla^2 u \\bigg|_{(x_i, y_j)} \\approx \\frac{u_{i-1,j} - 2u_{i,j} + u_{i+1,j}}{h_x^2} + \\frac{u_{i,j-1} - 2u_{i,j} + u_{i,j+1}}{h_y^2} = -f_{i,j}\n$$\n未知值为内部点上 $N_{int} = (N_x-2)(N_y-2)$ 个 $u_{i,j}$ 的值。通过将这些未知量排列成一个长度为 $N_{int}$ 的向量 $\\mathbf{u}$，所有离散化方程构成一个稀疏线性系统 $A\\mathbf{u} = \\mathbf{b}$。矩阵 $A$ 表示离散化的负拉普拉斯算子（乘以 $-1$），向量 $\\mathbf{b}$ 表示离散化的源项 $-f$。问题规定源 $f$ 是一个总强度为 $S=1$ 的离散点源，其全部贡献都放在单个网格节点上。该源节点的索引 $(I_c, J_c)$ 由向下取整规则确定：$I_c = \\lfloor 0.5(N_x-1) \\rfloor$ 和 $J_c = \\lfloor 0.5(N_y-1) \\rfloor$。问题进一步规定，右端项向量 $\\mathbf{b}$ 中的相应条目被设置为 $S$。这意味着 $\\mathbf{b}$ 是一个零向量，只有一个元素的值为 $S=1$，该元素位于对应于网格节点 $(I_c, J_c)$ 的位置。\n\n矩阵 $A$ 是一个稀疏、对称、正定的矩阵。其结构是块三对角的。对于一个大小为 $(N_x-2) \\times (N_y-2)$ 的内部网格，以及一个从 $2$D 索引 $(i', j')$（其中 $i' \\in \\{0, \\dots, N_x-3\\}, j' \\in \\{0, \\dots, N_y-3\\}$）到 $1$D 索引 $k = i' + j'(N_x-2)$ 的行主序映射，矩阵元素定义如下：\n- 对角线元素：$A_{k,k} = \\frac{2}{h_x^2} + \\frac{2}{h_y^2}$\n- $x$方向邻居的非对角线元素：$A_{k, k \\pm 1} = -\\frac{1}{h_x^2}$\n- $y$方向邻居的非对角线元素：$A_{k, k \\pm (N_x-2)} = -\\frac{1}{h_y^2}$\n（问题中的方程是 $\\nabla^2 u = -f$。矩阵系统 $A\\mathbf{u}=\\mathbf{b}$ 是由 $-(\\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2}) = f_{i,j}$ 构成的。所以矩阵 $A$ 对应于负拉普拉斯算子，而 $\\mathbf{b}$ 对应于 $f$。问题中说右端项条目是 $S$，所以源节点处的 $f$ 是 $S$。但是，方程是 $\\nabla^2u=-f$。那么线性系统的右端项应该对应于 $-f$，也就是 $-S$。让我们再仔细读一遍：“为内部未知量组装一个稀疏线性系统……并将其右端项设为 $S$”。这是一个构建 $\\mathbf{b}$ 的明确指令，无论符号约定如何。我将遵循这个明确的指令。）因此，右端项向量中有一个值为 $S$ 的元素。\n\n对于指定的三个测试案例中的每一个，执行以下算法过程：\n$1$. 定义网格参数 $N_x$ 和 $N_y$，并计算 $h_x$ 和 $h_y$。\n$2$. 构建大小为 $N_{int} \\times N_{int}$ 的稀疏矩阵 $A$，该矩阵表示有限差分算子。\n$3$. 构建大小为 $N_{int}$ 的右端项向量 $\\mathbf{b}$。这包括找到源节点索引 $(I_c, J_c)$，将它们映射到 $1$D 内部索引 $k_c$，并设置 $\\mathbf{b}_{k_c} = S=1$。\n$4$. 求解稀疏线性系统 $A\\mathbf{u} = \\mathbf{b}$ 以找到内部未知量向量 $\\mathbf{u}$。\n$5$. 通过将内部解嵌入到一个零场中，重构大小为 $N_y \\times N_x$ 的完整解网格 $u$。\n$6$. 计算两个量化度量：\n    - 相对不对称性，$E_{\\mathrm{sym}} = \\frac{\\lVert u - M(u) \\rVert_2}{\\lVert u \\rVert_2}$，其中 $M(u)$ 是绕中心反射的场：$M(u)_{i,j} = u_{N_x-1-i, N_y-1-j}$。\n    - 最大值与中心的偏移量，$d_{\\max} = \\sqrt{(i_{\\max}h_x - 0.5)^2 + (j_{\\max}h_y - 0.5)^2}$，其中 $(i_{\\max}, j_{\\max})$ 是 $u$ 的最大值的索引。\n\n- **案例 1 ($N_x=80, N_y=80$)：** 这里 $N_x-1 = 79$ 是奇数，所以物理中心 $x=0.5$ 落在两条网格线之间。向下取整规则将源放置在索引 $I_c = \\lfloor 0.5 \\times 79 \\rfloor = 39$ 处，对应于 $x_{39} = 39/79 \\approx 0.4937$。因此，离散源偏离了中心。这破坏了问题的反射对称性，我们预期会得到一个非零的不对称性度量，$E_{\\mathrm{sym}} > 0$。解的最大值也将从中心移开，所以 $d_{\\max} > 0$。\n- **案例 2 ($N_x=81, N_y=81$)：** 这里 $N_x-1 = 80$ 是偶数。源索引为 $I_c = \\lfloor 0.5 \\times 80 \\rfloor = 40$。其物理位置是 $x_{40} = 40/80 = 0.5$。源被精确地放置在对称网格的中心。离散问题保留了连续模型的完全对称性，因此我们预期两个度量都为零（或接近机器精度），即 $E_{\\mathrm{sym}} \\approx 0$ 和 $d_{\\max} \\approx 0$。\n- **案例 3 ($N_x=81, N_y=21$)：** 该网格是各向异性的（$h_x \\neq h_y$），但它关于中心线 $x=0.5$ 和 $y=0.5$ 是反射对称的。与案例 2 类似，源索引为 $I_c=40$ 和 $J_c=10$，将源放置在精确的中心 $(0.5, 0.5)$。尽管网格是各向异性的，且解的等值线呈椭圆形，但问题设置仍然是完全对称的。因此，我们再次预期 $E_{\\mathrm{sym}} \\approx 0$ 和 $d_{\\max} \\approx 0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef solve_poisson(Nx, Ny, S=1.0):\n    \"\"\"\n    Solves the 2D Poisson equation on a unit square with a discrete point source.\n\n    Args:\n        Nx (int): Number of grid points in the x-direction.\n        Ny (int): Number of grid points in the y-direction.\n        S (float): Strength of the point source.\n\n    Returns:\n        tuple[float, float]: A tuple containing the asymmetry metric (Esym) and\n                             the offset of the maximum value (dmax).\n    \"\"\"\n\n    # 1. Grid Parameters\n    hx = 1.0 / (Nx - 1)\n    hy = 1.0 / (Ny - 1)\n\n    Nix = Nx - 2\n    Niy = Ny - 2\n    N_interior = Nix * Niy\n\n    if N_interior <= 0:\n        # Trivial case with no interior nodes\n        return 0.0, 0.5 if Nx==1 and Ny==1 else np.sqrt( (0.5-0.5)**2 + (0.5-0.5)**2 ) # special case for 1x1 grid\n\n    # 2. Construct the sparse matrix A (for -Laplacian)\n    # This matrix represents the 5-point stencil finite difference operator.\n    # It is constructed using its main and off-diagonals.\n    \n    main_diag = np.full(N_interior, 2.0/hx**2 + 2.0/hy**2)\n    \n    x_off_diag = np.full(N_interior - 1, -1.0/hx**2)\n    # Zero out connections that wrap around rows\n    x_off_diag[Nix-1::Nix] = 0.0\n\n    y_off_diag = np.full(N_interior - Nix, -1.0/hy**2)\n\n    diagonals = [y_off_diag, x_off_diag, main_diag, x_off_diag, y_off_diag]\n    offsets = [-Nix, -1, 0, 1, Nix]\n    \n    A = sparse.diags(diagonals, offsets, shape=(N_interior, N_interior), format='csr')\n\n    # 3. Construct the RHS vector b\n    b = np.zeros(N_interior)\n    \n    # Source indices based on the floor rule (global grid)\n    Ic = int(np.floor(0.5 * (Nx - 1)))\n    Jc = int(np.floor(0.5 * (Ny - 1)))\n    \n    # Convert to interior grid indices (i', j')\n    ic_int = Ic - 1\n    jc_int = Jc - 1\n\n    # Check if the source is on an interior node\n    if 0 <= ic_int < Nix and 0 <= jc_int < Niy:\n        # Convert to 1D flattened index (row-major)\n        k_c = jc_int * Nix + ic_int\n        b[k_c] = S\n\n    # 4. Solve the linear system\n    u_interior_flat = spsolve(A, b)\n\n    # 5. Reconstruct the full solution grid\n    u_full = np.zeros((Ny, Nx))\n    u_interior = u_interior_flat.reshape((Niy, Nix))\n    u_full[1:-1, 1:-1] = u_interior\n\n    # 6. Compute metrics\n    # Esym: Relative asymmetry metric\n    u_mirrored = np.flip(u_full)\n    norm_u = np.linalg.norm(u_full)\n    if norm_u == 0:\n        Esym = 0.0\n    else:\n        norm_diff = np.linalg.norm(u_full - u_mirrored)\n        Esym = norm_diff / norm_u\n\n    # dmax: Offset of the maximum value from the center\n    # np.unravel_index gives (row, col) which corresponds to (j, i)\n    j_max, i_max = np.unravel_index(np.argmax(u_full), u_full.shape)\n    \n    x_max = i_max * hx\n    y_max = j_max * hy\n    \n    dmax = np.sqrt((x_max - 0.5)**2 + (y_max - 0.5)**2)\n    \n    return Esym, dmax\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (80, 80),  # Symmetry-breaking case\n        (81, 81),  # Redesigned symmetric grid\n        (81, 21),  # Anisotropic but center-aligned grid\n    ]\n\n    results = []\n    source_strength = 1.0\n\n    for case in test_cases:\n        Nx, Ny = case\n        Esym, dmax = solve_poisson(Nx, Ny, source_strength)\n        results.append([Esym, dmax])\n\n    # Final print statement in the exact required format.\n    case_strs = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in results]\n    print(f\"[{','.join(case_strs)}]\")\n\nsolve()\n\n```", "id": "3109385"}, {"introduction": "科学方法的最后一个支柱是可复现性。在计算科学中，由于编译器、硬件和库的差异，实现跨平台逐比特相同的结果往往是不可能的。本练习将引导您超越确定性的结果比较，建立一个更稳健的统计可复现性框架。您将使用假设检验来正式判断两组模拟结果的分布是否等价，从而将可复现性的概念从“完全相同”提升到“统计上无差异”。[@problem_id:3109390]", "problem": "要求您本着计算科学范式的精神，设计一个小型、独立的再现性案例研究。该研究将模拟在不同编译器和标志配置下运行相同的分子动力学模拟，并通过正式检验系综分布的相等性来判断结果是否可再现。\n\n该模拟模型是一个使用速度 Verlet 更新方法积分的一维谐振子。在步长索引 $t$ 处的状态是位置 $x_t$ 和速度 $v_t$。物理参数是质量 $m$ 和刚度 $k$。模拟时间步长是 $\\Delta t$。为了模拟编译器和标志的差异，每次更新时，中间算术运算都会四舍五入到指定的小数精度 $p$，并且可以在更新中应用一个微小的确定性偏差项 $b$ 来表示诸如融合乘加重排序等效应。所有量都是无量纲的；本问题不涉及物理单位。\n\n从初始条件开始，您的程序必须为一组 $N$ 个独立的初始条件生成一个轨迹系综，然后形成一个最终能量的系综。状态 $(x, v)$ 的能量定义为 $E = \\frac{1}{2} m v^2 + \\frac{1}{2} k x^2$。您将为每个测试用例生成两个系综，代表两种编译器和标志配置 $A$ 和 $B$。\n\n您必须实现的单个时间步长的积分方案如下：\n- 使用以下公式计算下一个位置\n$$\nx_{t+\\Delta t} = x_t + v_t \\Delta t - \\frac{1}{2}\\frac{k}{m} x_t (\\Delta t)^2 + b\\, x_t v_t,\n$$\n然后将 $x_{t+\\Delta t}$ 四舍五入到 $p$ 位小数。\n- 使用以下公式计算下一个速度\n$$\nv_{t+\\Delta t} = v_t - \\frac{1}{2}\\frac{k}{m} (x_t + x_{t+\\Delta t}) \\Delta t + b\\, x_{t+\\Delta t} v_t,\n$$\n然后将 $v_{t+\\Delta t}$ 四舍五入到 $p$ 位小数。\n\n必须通过在对称区间上均匀抽样 $N$ 个确定性初始位置 $x_0$ 来构建系综，并为所有系综成员设置 $v_0 = 0$。具体来说，使用在 $[-X, X]$（其中 $X = 0.5$）上均匀分布的 $x_0$ 值。对于给定的配置 $(m, k, \\Delta t, p, b)$ 和步数 $T$，您应该：\n- 按所述初始化系综，\n- 使用上述更新将每个成员推进 $T$ 步，\n- 计算并收集每个成员的最终能量 $E$，形成一个能量系综。\n\n为了判定再现性，定义零假设 $H_0$ 为：来自配置 $A$ 和 $B$ 的两个能量系综是从相同的底层分布中抽取的样本：\n$$\nH_0: F_A(E) = F_B(E) \\text{ for all } E,\n$$\n其中 $F_A$ 和 $F_B$ 是累积分布函数。使用显著性水平为 $\\alpha$ 的双样本 Kolmogorov-Smirnov (KS) 检验来接受或拒绝再现性。具体来说，计算两个能量样本的 KS $p$-值；如果 $p$-值大于或等于 $\\alpha$，则宣布结果是可再现的，否则为不可再现。\n\n实现程序以运行以下测试套件，每个测试用例由配置 $A$ 和 $B$ 的参数元组以及 $\\alpha$ 定义：\n\n- 测试用例 1（理想路径，相同配置）：\n  - 配置 $A$：$m = 1.0$, $k = 2.0$, $\\Delta t = 0.005$, $p = 12$, $b = 0.0$, $T = 100$, $N = 1000$。\n  - 配置 $B$：$m = 1.0$, $k = 2.0$, $\\Delta t = 0.005$, $p = 12$, $b = 0.0$, $T = 100$, $N = 1000$。\n  - $\\alpha = 0.05$。\n- 测试用例 2（边界条件，极小的系综规模）：\n  - 配置 $A$：$m = 1.0$, $k = 2.0$, $\\Delta t = 0.005$, $p = 12$, $b = 0.0$, $T = 50$, $N = 8$。\n  - 配置 $B$：$m = 1.0$, $k = 2.0$, $\\Delta t = 0.005$, $p = 12$, $b = 0.0$, $T = 50$, $N = 8$。\n  - $\\alpha = 0.05$。\n- 测试用例 3（质量参数有明显差异）：\n  - 配置 $A$：$m = 1.0$, $k = 2.0$, $\\Delta t = 0.005$, $p = 12$, $b = 0.0$, $T = 100$, $N = 500$。\n  - 配置 $B$：$m = 1.5$, $k = 2.0$, $\\Delta t = 0.005$, $p = 12$, $b = 0.0$, $T = 100$, $N = 500$。\n  - $\\alpha = 0.05$。\n- 测试用例 4（多重差异：步长、舍入精度和偏差）：\n  - 配置 $A$：$m = 1.0$, $k = 2.0$, $\\Delta t = 0.005$, $p = 12$, $b = 0.0$, $T = 150$, $N = 1000$。\n  - 配置 $B$：$m = 2.0$, $k = 2.0$, $\\Delta t = 0.02$, $p = 6$, $b = 10^{-3}$, $T = 150$, $N = 1000$。\n  - $\\alpha = 0.05$。\n\n您的程序必须：\n- 实现所述的积分器和系综构建，\n- 对每个测试用例，为 $A$ 和 $B$ 生成能量系综，\n- 在指定的 $\\alpha$ 水平上应用双样本 KS 检验，\n- 生成一行输出，其中包含一个用方括号括起来的、以逗号分隔的布尔值列表（例如，`[True,False,True]`），按测试用例 1 到 4 的顺序排列。\n\n所有计算都是无量纲的；不要包含或转换任何物理单位。本问题不使用角度。如果出现百分比，必须以小数形式表示；但是，本问题没有明确要求使用百分比。", "solution": "该问题要求设计并实现一个计算实验来研究数值再现性。这通过在不同配置下模拟一维谐振子来完成，这些配置模拟了编译器或硬件的差异，然后使用统计检验来确定结果是否等效。该解决方案的核心涉及数值积分、系综生成和假设检验。\n\n首先，我们定义物理模型及其数值积分。该系统是一个质量为 $m$、弹簧常数为 $k$ 的简谐振子。一个状态由其位置 $x$ 和速度 $v$ 定义。一个状态 $(x, v)$ 的总能量在理想物理系统中是一个守恒量，由表达式 $E = \\frac{1}{2} m v^2 + \\frac{1}{2} k x^2$ 给出。对于数值模拟，我们用步长 $\\Delta t$ 将时间离散化。在时间步长索引 $t$ 处的状态 $(x_t, v_t)$ 使用指定的更新方案推进到下一个状态 $(x_{t+\\Delta t}, v_{t+\\Delta t})$。问题陈述提供了一个标准速度 Verlet 算法的变体。首先更新位置：\n$$\nx_{t+\\Delta t} = x_t + v_t \\Delta t - \\frac{1}{2}\\frac{k}{m} x_t (\\Delta t)^2 + b\\, x_t v_t\n$$\n然后使用这个更新后的位置 $x_{t+\\Delta t}$ 来计算新的速度：\n$$\nv_{t+\\Delta t} = v_t - \\frac{1}{2}\\frac{k}{m} (x_t + x_{t+\\Delta t}) \\Delta t + b\\, x_{t+\\Delta t} v_t\n$$\n在这些方程中，与偏差参数 $b$ 成比例的项是一个微小的确定性扰动，旨在模拟计算环境之间的细微算术差异，例如由融合乘加指令重排序引起的差异。为了进一步模拟有限精度算术的影响，位置和速度更新的结果 $x_{t+\\Delta t}$ 和 $v_{t+\\Delta t}$ 都被四舍五入到指定的小数位数 $p$。\n\n第二个原则是使用系综来捕捉系统演化的统计特性。单个轨迹对初始条件和扰动很敏感（“蝴蝶效应”）。为了获得对动力学的稳健统计描述，我们模拟了一个由 $N$ 个独立系统组成的系综，每个系统都从略有不同的初始条件开始。对于本问题，初始系综由 $N$ 个在区间 $[-0.5, 0.5]$ 上均匀分布的确定性起始位置 $x_0$ 构成。对于系综的所有成员，初始速度 $v_0$ 都设置为 $0$。然后，使用上述数值方案将这 $N$ 个系统中的每一个在时间上向前积分 $T$ 步。在模拟结束时，即时间 $T \\Delta t$ 处，我们计算 $N$ 个成员中每一个的最终能量 $E$。这个过程产生两组最终能量，一组用于“参考”配置 $A$，另一组用于“测试”配置 $B$。\n\n最后一步是正式检验再现性。核心问题是，来自配置 $A$ 和 $B$ 的两个最终能量系综是否可能从相同的底层概率分布中抽取。我们将其形式化为一个零假设 $H_0$，即两种配置的能量累积分布函数 (CDF) 相同：$H_0: F_A(E) = F_B(E)$。为了检验这个假设，我们采用双样本 Kolmogorov-Smirnov (KS) 检验。这是一种非参数检验，它量化了两个样本的经验累积分布函数之间的最大距离。KS 检验产生一个 $p$-值，它表示在假设 $H_0$ 为真的情况下，观察到等于或大于测量值的差异的概率。一个小的 $p$-值表明观察到的差异不太可能仅仅是由于随机机会造成的，从而导致我们拒绝 $H_0$。该问题基于显著性水平 $\\alpha$ 定义再现性：如果计算出的 $p$-值大于或等于 $\\alpha$，我们就不拒绝零假设，并宣布结果是可再现的。如果 $p$-值小于 $\\alpha$，我们就拒绝 $H_0$，并宣布结果是不可再现的。\n\n算法设计直接遵循这些原则。实现了一个函数，用于对给定的参数集 $(m, k, \\Delta t, p, b, T, N)$ 执行系综模拟。该函数将 $N$ 个系综成员的位置和速度初始化为 `numpy` 数组，然后迭代 $T$ 个时间步长，为了计算效率，将矢量化的更新方程一次性应用于整个系综。积分之后，它计算并返回一个最终能量的数组。程序的主体部分遍历指定的测试用例。对于每个用例，它调用配置 $A$ 和 $B$ 的模拟函数，获得两个能量系综，并将它们传递给 `scipy.stats.ks_2samp` 函数。将得到的 $p$-值与给定的 $\\alpha$ 进行比较，并存储一个布尔结果（$True$ 表示可再现，$False$ 表示不可再现）。最后，收集所有布尔结果并以指定格式打印。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Solves the computational reproducibility case study by running simulations\n    for given test cases and performing a Kolmogorov-Smirnov test.\n    \"\"\"\n\n    def run_simulation(m: float, k: float, dt: float, p: int, b: float, T: int, N: int) -> np.ndarray:\n        \"\"\"\n        Runs a single ensemble simulation for a given configuration.\n\n        Args:\n            m: Mass parameter.\n            k: Stiffness parameter.\n            dt: Time step.\n            p: Decimal precision for rounding.\n            b: Bias term.\n            T: Number of time steps.\n            N: Number of ensemble members.\n\n        Returns:\n            An array of final energies for each ensemble member.\n        \"\"\"\n        # Initialize ensemble states (position x, velocity v)\n        # For N=1, linspace produces array([0.]), the center of the interval, which is correct.\n        x = np.linspace(-0.5, 0.5, N)\n        v = np.zeros(N)\n\n        # Time integration loop\n        for _ in range(T):\n            # Position update step\n            x_new_unrounded = x + v * dt - 0.5 * (k / m) * x * (dt**2) + b * x * v\n            x_new = np.round(x_new_unrounded, p)\n\n            # Velocity update step, using the just-computed position x_new\n            v_new_unrounded = v - 0.5 * (k / m) * (x + x_new) * dt + b * x_new * v\n            v_new = np.round(v_new_unrounded, p)\n\n            # Update state vectors for the next iteration\n            x, v = x_new, v_new\n\n        # Calculate final energy for each ensemble member\n        energy = 0.5 * m * v**2 + 0.5 * k * x**2\n        return energy\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (happy path, identical configurations)\n        (\n            {'m': 1.0, 'k': 2.0, 'dt': 0.005, 'p': 12, 'b': 0.0, 'T': 100, 'N': 1000}, # Config A\n            {'m': 1.0, 'k': 2.0, 'dt': 0.005, 'p': 12, 'b': 0.0, 'T': 100, 'N': 1000}, # Config B\n            0.05  # alpha\n        ),\n        # Test case 2 (boundary condition, very small ensemble size)\n        (\n            {'m': 1.0, 'k': 2.0, 'dt': 0.005, 'p': 12, 'b': 0.0, 'T': 50, 'N': 8},\n            {'m': 1.0, 'k': 2.0, 'dt': 0.005, 'p': 12, 'b': 0.0, 'T': 50, 'N': 8},\n            0.05\n        ),\n        # Test case 3 (clear difference in mass parameter)\n        (\n            {'m': 1.0, 'k': 2.0, 'dt': 0.005, 'p': 12, 'b': 0.0, 'T': 100, 'N': 500},\n            {'m': 1.5, 'k': 2.0, 'dt': 0.005, 'p': 12, 'b': 0.0, 'T': 100, 'N': 500},\n            0.05\n        ),\n        # Test case 4 (multiple differences: step size, rounding precision, and bias)\n        (\n            {'m': 1.0, 'k': 2.0, 'dt': 0.005, 'p': 12, 'b': 0.0, 'T': 150, 'N': 1000},\n            {'m': 2.0, 'k': 2.0, 'dt': 0.02, 'p': 6, 'b': 1e-3, 'T': 150, 'N': 1000},\n            0.05\n        )\n    ]\n\n    results = []\n    for config_A, config_B, alpha in test_cases:\n        # Generate energy ensembles for both configurations\n        energy_A = run_simulation(**config_A)\n        energy_B = run_simulation(**config_B)\n        \n        # Perform the two-sample Kolmogorov-Smirnov test\n        ks_result = stats.ks_2samp(energy_A, energy_B)\n        p_value = ks_result.pvalue\n        \n        # Determine reproducibility based on the p-value and significance level alpha\n        is_reproducible = p_value >= alpha\n        results.append(is_reproducible)\n\n    # Final print statement in the exact required format.\n    # Python's str(bool) gives 'True' or 'False' as required.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3109390"}]}