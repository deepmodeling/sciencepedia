{"hands_on_practices": [{"introduction": "中间值定理（IVT）保证了根的存在性，但并未告诉我们如何找到它，也未说明根的数量。本练习 [@problem_id:3145023] 旨在弥合理论与应用之间的鸿沟。你将首先运用罗尔定理（中值定理的一个特例）来建立函数根的数量与其局部极值点数量之间的基本联系。接着，你将开发一个实用算法，通过系统性地扫描一个区间，利用 IVT 来“认证”并定位一个复杂函数的所有实数根，从而将一个存在性定理转变为一个强大的搜索工具。", "problem": "要求您设计并实现一个可运行的完整程序，该程序演示一个连续、可微的非单调函数 $f$ 如何在单个闭区间内拥有多个实数根，利用罗尔定理（Rolle’s theorem）得出一个给定的根数量所需的局部极值数量的下界，并通过在子区间上结合采样和介值定理（IVT）来找到所有这些根。\n\n您可以假设的基本前提包括：连续性和可微性的定义、介值定理（IVT）、中值定理（MVT）、罗尔定理（Rolle’s theorem）、极值定理（Extreme Value Theorem）以及关于驻点的费马引理（Fermat’s theorem）。您不得假设或使用任何其他专门的定理或黑箱求解器。\n\n您的程序需要完成的任务：\n\n1) 通过罗尔定理（Rolle’s theorem）推导理论下界。考虑一个在闭区间 $[a,b]$ 上连续且在开区间 $(a,b)$ 上可微的函数 $f$。假设 $f$ 在 $[a,b]$ 内有 $m$ 个不同的实数根。从已声明的定理出发，根据第一性原理，推导 $f$ 在 $[a,b]$ 内必须具有的局部极值的最小数量的一般表达式。您的程序必须根据其数值计算出的不同根的整数数量 $m$ 来实现这个下界，而不能事先假设此界。\n\n2) 通过采样和IVT进行根的隔离与精化。设计一个采样策略，该策略：\n- 在 $[a,b]$ 上建立一个均匀网格，\n- 检测出子区间 $[x_i,x_{i+1}]$，其中 $f(x_i)\\cdot f(x_{i+1})  0$，根据介值定理，这些子区间中每个都至少包含一个根，\n- 将任何满足 $f(x_i)=0$ 的端点 $x_i$ 包含为根，以及\n- 使用二分法程序对每个出现符号变化的区间进行精化，以逼近一个根，直到绝对误差小于预设的容差。\n因为介值定理仅保证在有符号变化的子区间内存在根，且本任务中的函数只有单根，所以必须使用足够精细的网格来确保每个单根都与至少一对符号变化的采样点相邻。对于三角函数，使用弧度制角度。\n\n3) 数值容差与输出。根的精化使用 $10^{-12}$ 的二分法容差，然后将每个近似根四舍五入到 $6$ 位小数。当两个数值上找到的根相差在 $10^{-6}$ 以内时，将它们视为同一个根。对每个测试用例，将根按严格递增顺序排序。所有角度均以弧度表示。\n\n测试套件。您的程序必须在以下纯粹以数学术语指定的测试用例上运行：\n- 案例 1：$f(x)=x^3-x$ 在 $[-2,2]$ 上。\n- 案例 2：$f(x)=(x-1)(x-1.5)(x-2.5)$ 在 $[0,3]$ 上。\n- 案例 3：$f(x)=\\sin(5x)-0.2$ 在 $[0,2\\pi]$ 上，其中 $x$ 以弧度度量。\n- 案例 4：$f(x)=(x-0.2)(x-0.8)$ 在 $[0,1]$ 上。\n- 案例 5：$f(x)=(x+1)(x-2)$ 在 $[-1,2]$ 上。\n\n对于每个案例，您的程序必须：\n- 生成区间内不同实数根的排序列表（四舍五入到 $6$ 位小数），以及\n- 仅根据您找到的不同实数根的整数数量 $m$ 来计算区间内所需局部极值最小数量的推导下界。\n\n最终输出格式。您的程序必须生成单行输出，该输出是一个由方括号括起、逗号分隔的结果列表，每个测试用例一个结果，每个结果的格式为：\n- 一个双元素列表，其中第一个元素是四舍五入后的根列表，第二个元素是任务1中的整数下界。\n\n具体来说，您的程序必须打印形如\n$[\\,[\\,[r_{1,1},\\ldots,r_{1,k_1}],b_1],\\,[\\,[r_{2,1},\\ldots,r_{2,k_2}],b_2],\\,\\ldots,\\,\\,[\\,[r_{5,1},\\ldots,r_{5,k_5}],b_5]\\,]$\n的单行，不带空格，其中 $r_{i,j}$ 是精确打印到 $6$ 位小数的浮点数，$b_i$ 是整数。不得打印任何其他文本。", "solution": "我们从第一性原理出发，将数学定理与具体的算法联系起来。\n\n基本原理。设 $f$ 在 $[a,b]$ 上连续，在 $(a,b)$ 上可微。\n- 介值定理 (IVT)：如果 $f$ 在 $[a,b]$ 上连续，且 $f(a)$ 和 $f(b)$ 符号相反，则存在 $c\\in(a,b)$ 使得 $f(c)=0$。\n- 中值定理 (MVT)：如果 $f$ 在 $[a,b]$ 上连续且在 $(a,b)$ 上可微，则存在 $c\\in(a,b)$ 使得 $f'(c)=\\dfrac{f(b)-f(a)}{b-a}$。\n- 罗尔定理（Rolle’s theorem）：如果 $f$ 在 $[a,b]$ 上连续，在 $(a,b)$ 上可微，且 $f(a)=f(b)$，则存在 $c\\in(a,b)$ 使得 $f'(c)=0$。\n- 极值定理（Extreme Value Theorem）：如果 $f$ 在紧区间 $[a,b]$ 上连续，则 $f$ 在 $[a,b]$ 上取得最大值和最小值。\n- 费马引理（Fermat’s theorem）：如果 $f$ 在内点 $c\\in(a,b)$ 处有局部极值且在 $c$ 点可微，则 $f'(c)=0$。\n\nA部分：根据根的数量确定局部极值数量的下界。假设 $f$ 在 $[a,b]$ 内有 $m \\ge 1$ 个不同的实数根，记为 $r_1  r_2  \\dots  r_m$。考虑任意两个相邻的根 $r_i$ 和 $r_{i+1}$。由于 $f(r_i)=f(r_{i+1})=0$，根据罗尔定理，在开区间 $(r_i, r_{i+1})$ 内至少存在一个点 $c_i$，使得 $f'(c_i)=0$。因为有 $m-1$ 个这样的不相交的根间区间，所以必须存在至少 $m-1$ 个不同的点，在这些点上导数为零。这些点是局部极值的候选点（根据费马引理）。因此，函数 $f$ 在 $[a,b]$ 内必须至少有 $m-1$ 个局部极值。如果 $m \\le 1$，则此论证不适用，所需的最小极值数量为0。因此，对于 $m$ 个根，下界是 $\\max(0, m-1)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef bisection(f, a, b, tol=1e-12, max_iter=100):\n    fa = f(a)\n    fb = f(b)\n    if abs(fa)  tol:\n        return a\n    if abs(fb)  tol:\n        return b\n    # Ensure there is a sign change\n    if fa * fb > 0:\n        # No sign change; bisection not applicable\n        return None\n    left, right = a, b\n    f_left, f_right = fa, fb\n    for _ in range(max_iter):\n        mid = 0.5 * (left + right)\n        f_mid = f(mid)\n        if abs(f_mid)  tol or 0.5 * (right - left)  tol:\n            return mid\n        # Choose the subinterval that preserves sign change\n        if f_left * f_mid = 0:\n            right, f_right = mid, f_mid\n        else:\n            left, f_left = mid, f_mid\n    return 0.5 * (left + right)\n\ndef isolate_and_refine_roots(f, a, b, n_grid, bisect_tol=1e-12, merge_tol=1e-6):\n    xs = np.linspace(a, b, n_grid)\n    fs = f(xs)\n    # Collect root candidates from endpoint zeros\n    candidates = []\n\n    # Check exact/near-zero samples\n    for xi, fi in zip(xs, fs):\n        if np.isfinite(fi) and abs(fi)  1e-12:\n            candidates.append(float(xi))\n\n    # Check sign changes on consecutive intervals\n    for i in range(len(xs) - 1):\n        x0, x1 = xs[i], xs[i + 1]\n        f0, f1 = fs[i], fs[i + 1]\n        if not (np.isfinite(f0) and np.isfinite(f1)):\n            continue\n        prod = f0 * f1\n        if prod  0.0:\n            r = bisection(f, x0, x1, tol=bisect_tol, max_iter=200)\n            if r is not None:\n                candidates.append(float(r))\n\n    # Deduplicate close roots\n    if not candidates:\n        roots = []\n    else:\n        candidates = sorted(candidates)\n        roots = [candidates[0]]\n        for r in candidates[1:]:\n            if abs(r - roots[-1]) = merge_tol:\n                # Merge by averaging for stability\n                roots[-1] = 0.5 * (roots[-1] + r)\n            else:\n                roots.append(r)\n\n    # Sort and round to 6 decimals for final reporting\n    roots.sort()\n    roots = [round(r, 12) for r in roots]  # preserve accuracy before formatting\n    return roots\n\ndef format_output(all_results):\n    # all_results is a list of tuples: (roots_list, bound_int)\n    # We must output a single line with no spaces, floats with exactly 6 decimals.\n    def fmt_float(x):\n        return f\"{x:.6f}\"\n\n    parts = []\n    for roots, bound in all_results:\n        roots_str = \"[\" + \",\".join(fmt_float(r) for r in roots) + \"]\"\n        part = \"[\" + roots_str + \",\" + str(int(bound)) + \"]\"\n        parts.append(part)\n    return \"[\" + \",\".join(parts) + \"]\"\n\ndef solve():\n    # Define test cases (functions and intervals)\n    # Case 1: f(x) = x^3 - x on [-2, 2]\n    def f1(x):\n        return x**3 - x\n\n    # Case 2: f(x) = (x - 1)*(x - 1.5)*(x - 2.5) on [0, 3]\n    def f2(x):\n        return (x - 1.0) * (x - 1.5) * (x - 2.5)\n\n    # Case 3: f(x) = sin(5x) - 0.2 on [0, 2π] (radians)\n    def f3(x):\n        return np.sin(5.0 * x) - 0.2\n\n    # Case 4: f(x) = (x - 0.2)*(x - 0.8) on [0, 1]\n    def f4(x):\n        return (x - 0.2) * (x - 0.8)\n\n    # Case 5: f(x) = (x + 1)*(x - 2) on [-1, 2]\n    def f5(x):\n        return (x + 1.0) * (x - 2.0)\n\n    # Sampling densities chosen to reliably capture all simple roots\n    test_cases = [\n        (f1, -2.0, 2.0, 40001),               # fine grid for cubic\n        (f2, 0.0, 3.0, 40001),                # fine grid for cubic with three roots\n        (f3, 0.0, 2.0 * np.pi, 60001),        # dense grid for sin wave crossings\n        (f4, 0.0, 1.0, 20001),                # quadratic with two interior roots\n        (f5, -1.0, 2.0, 30001),               # linear factors, roots at endpoints\n    ]\n\n    results = []\n    for f, a, b, n_grid in test_cases:\n        roots = isolate_and_refine_roots(f, a, b, n_grid=n_grid, bisect_tol=1e-12, merge_tol=1e-6)\n        # Compute bound on minimum number of local extrema required: max(m - 1, 0)\n        m = len(roots)\n        bound = max(m - 1, 0)\n        results.append((roots, bound))\n\n    # Print in exact required single-line format with no spaces and floats with 6 decimals\n    print(format_output(results))\n\nsolve()\n```", "id": "3145023"}, {"introduction": "对于任何计算科学家而言，一项至关重要的技能是理解其数值工具的能力，尤其是其局限性。基于网格和 IVT 的搜索是一种通用且直观的寻根方法，但它总是可靠的吗？本练习 [@problem_id:3144944] 将通过一个对比实验来检验该方法：将其结果与斯图姆定理（Sturm's Theorem）为多项式提供的精确根计数进行比较。通过分析 IVT 方法失效的案例——例如偶数重根或粗糙网格可能漏掉的紧密根簇——你将对数值算法的精妙之处和潜在陷阱有更深刻、更批判性的认识。", "problem": "您需要实现两种计算方法，利用微积分的基本结果来验证和计算一个实系数多项式 $p(x)$ 在闭区间 $[a,b]$ 上的实根数量。第一种方法使用 Sturm 序列来得出区间内不同实根的精确数量。第二种方法对 $[a,b]$ 的一个均匀网格划分进行采样，并利用介值定理 (IVT) 通过检测 $p(x)$ 在相邻网格点上的符号变化来验证必定包含至少一个根的子区间。然后，对于几个测试用例，比较 IVT 验证的子区间数量与 Sturm 精确根数。\n\n本任务的基本原理：\n- 多项式的连续性：任何实系数多项式 $p(x)$ 在 $\\mathbb{R}$ 上连续，因此在任何 $[a,b]$ 上也连续。\n- 介值定理 (IVT)：如果一个连续函数 $f$ 在 $[a,b]$ 上，其 $f(a)$ 和 $f(b)$ 的符号相反，则存在 $c \\in (a,b)$ 使得 $f(c)=0$。\n- 中值定理 (MVT) 和 Rolle 定理：如果一个可微函数 $f$ 满足 $f(a)=f(b)$，则存在 $c \\in (a,b)$ 使得 $f'(c)=0$。对于多项式而言，在 $p(x)$ 的任意两个不同实根之间，至少存在一个 $p'(x)$ 的实根。\n- 多项式 Euclidean 算法：对于多项式 $A(x)$ 和 $B(x)$，存在商式 $Q(x)$ 和余式 $R(x)$ 使得 $A(x) = Q(x)B(x) + R(x)$，且 $\\deg R  \\deg B$。\n\n定义和任务：\n1. 构建 $p(x)$ 的 Sturm 序列：\n   - 令 $p_0(x) = p(x)$ 且 $p_1(x) = p'(x)$。\n   - 对于 $k \\ge 1$，定义 $p_{k+1}(x) = -\\operatorname{rem}(p_{k-1}(x),p_k(x))$，其中 $\\operatorname{rem}$ 表示 $p_{k-1}$ 除以 $p_k$ 的多项式 Euclidean 除法中的余式。\n   - 持续此过程，直到生成一个常数多项式且下一个余式为零。\n   - 对于任意 $x \\in \\mathbb{R}$，将 $V(x)$ 定义为序列 $\\{p_i(x)\\}$ 中符号变化的次数，计算前需从序列中移除精确的零值（即，压缩掉等于零的项，并计算连续非零值之间的符号翻转次数）。\n   - 根据 Sturm 定理，$p(x)$ 在 $(a,b)$ 内的不同实根数量等于 $V(a) - V(b)$，前提是变号数的计算方式如上所述移除零值；即使 $a$ 或 $b$ 是根，此约定也能得出正确的极限计数。\n2. 在均匀网格上实现基于 IVT 的验证：\n   - 将 $[a,b]$ 划分成子区间 $[x_i, x_{i+1}]$，其中 $x_i = a + i h$，$h>0$ 是网格间距，$i=0,1,\\dots,N$，满足 $N h \\le b-a$ 且包含 $x_N=b$。\n   - 在每个网格节点上计算 $p(x_i)$。\n   - 一个 IVT 验证的子区间是任意满足 $p(x_i)$ 和 $p(x_{i+1})$ 严格异号（即 $p(x_i) p(x_{i+1})  0$）的相邻对 $[x_i, x_{i+1}]$。这证明了在 $(x_i, x_{i+1})$ 内至少存在一个根。\n   - 为了数值稳健性，使用一个小的阈值 $\\tau$ 将 $|p(x)| \\le \\tau$ 的值视为零；但是，如果一个区间的端点在数值上为零，则不计数该区间，除非端点之间存在严格的符号变化。换言之，仅在将近似零的值替换为精确零之后，计算具有严格符号变化的子区间，并忽略用于验证的零端点。\n3. 对于下面的每个测试用例，计算：\n   - 来自网格的 IVT 验证子区间的整数数量。\n   - 使用 Sturm 序列计算的 $(a,b)$ 内不同实根的整数数量。\n4. 输出格式：\n   - 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，并且是一个包含两个整数的列表 $[C_{\\mathrm{IVT}}, C_{\\mathrm{Sturm}}]$。例如，一个可能的输出是 $[[2,3],[1,2],[0,0]]$。\n\n数值细节：\n- 在 Sturm 求值的符号变号计数和 IVT 验证中处理网格端点值时，当 $|p(x)| \\le \\tau$ 时，使用零阈值 $\\tau = 10^{-12}$ 将其视为零。\n- 不涉及角度，也不涉及物理单位。\n\n测试套件：\n实现上述算法，并将其应用于以下多项式、区间和网格间距。系数按 $x$ 的降幂顺序给出。\n- 用例 1 (不同单根，部分落在网格节点上)：$p(x) = x^3 - x$，区间 $[a,b]=[-2,2]$，网格间距 $h=0.4$。\n- 用例 2 (包含一个偶重根，该根附近没有符号变化)：$p(x) = (x-1)^2(x+2) = x^3 - 3x + 2$，区间 $[a,b]=[-3,3]$，网格间距 $h=0.6$。\n- 用例 3 (具有多个实根的高阶多项式，粗网格)：$p(x) = x^5 - x$，区间 $[a,b]=[-10,10]$，网格间距 $h=4.7$。\n- 用例 4 (三个聚集的实根)：$p(x) = (x-0.2)(x-0.25)(x+0.75) = x^3 + 0.3 x^2 - 0.2875 x + 0.0375$，区间 $[a,b]=[-1,1]$，网格间距 $h=0.5$。\n- 用例 5 (没有实根)：$p(x) = x^2 + 1$，区间 $[a,b]=[-5,5]$，网格间距 $h=1.0$。\n\n答案规范：\n- 对每个用例，返回一对 $[C_{\\mathrm{IVT}}, C_{\\mathrm{Sturm}}]$，其中 $C_{\\mathrm{IVT}}$ 是 IVT 验证的子区间数量，$C_{\\mathrm{Sturm}}$ 是 $(a,b)$ 内不同实根的精确数量。\n- 您的程序应生成单行输出，包含按顺序排列的五个对，形式为一个用方括号括起来的逗号分隔列表，例如：$[[C_{\\mathrm{IVT,1}},C_{\\mathrm{Sturm,1}}],[C_{\\mathrm{IVT,2}},C_{\\mathrm{Sturm,2}}],[C_{\\mathrm{IVT,3}},C_{\\mathrm{Sturm,3}}],[C_{\\mathrm{IVT,4}},C_{\\mathrm{Sturm,4}}],[C_{\\mathrm{IVT,5}},C_{\\mathrm{Sturm,5}}]]$。", "solution": "问题陈述在形式上是有效的。它在科学上基于已建立的数学原理（Sturm 定理，介值定理），定义和数据完整一致，问题阐述清晰，并且表述客观。我们将着手提供一个解决方案。\n\n任务是实现并比较两种不同的方法，用于计算多项式 $p(x)$ 在给定区间 $[a,b]$ 内的实根数量。第一种方法基于 Sturm 定理，提供不同实根的精确数量。第二种方法基于介值定理 (IVT)，提供经认证包含至少一个根的子区间数量。\n\n**方法一：通过 Sturm 定理计算根数**\n\nSturm 定理提供了一个稳健的算法，用以确定实系数多项式在给定区间 $(a,b)$ 内的不同实根的精确数量。该方法的核心是构建一个称为 Sturm 序列的特殊多项式序列。\n\n对于给定的多项式 $p(x)$，其标准 Sturm 序列构建如下：\n$1$. 前两个元素是 $p_0(x) = p(x)$ 及其一阶导数 $p_1(x) = p'(x)$。\n$2$. 后续元素使用多项式 Euclidean 算法生成。对于 $k \\ge 1$，我们定义 $p_{k+1}(x)$ 为 $p_{k-1}(x)$ 除以 $p_k(x)$ 所得余式的负数：\n$$p_{k+1}(x) = -\\operatorname{rem}(p_{k-1}(x), p_k(x))$$\n重复此过程，直到余数为零多项式，此时序列终止。\n\n一旦构建了 Sturm 序列 $\\{p_0(x), p_1(x), \\dots, p_m(x)\\}$，我们定义 $V(x_0)$ 为在求值序列 $\\{p_0(x_0), p_1(x_0), \\dots, p_m(x_0)\\}$ 中的符号变化次数。在计算 $V(x_0)$ 时，任何精确为零的项在计数符号变化前都将从序列中省略。\n\nSturm 定理指出，对于在端点 $a$ 或 $b$ 没有重根的多项式 $p(x)$，其在区间 $(a,b)$ 内的不同实根数量由端点处的变号数之差给出：\n$$C_{\\mathrm{Sturm}} = V(a) - V(b)$$\n指定从求值序列中移除零的约定确保了即使 $a$ 或 $b$ 是 $p(x)$ 或任何 $p_i(x)$ 的根，该定理仍然成立。\n\n实现将使用 `numpy` 库。多项式由其系数按降幂顺序排列的数组表示。导数 $p'(x)$ 使用 `numpy.polyder` 计算。多项式除法和余数计算通过 `numpy.polydiv` 执行。在特定点 $a$ 和 $b$ 对多项式求值使用 `numpy.polyval`。用于识别零值的数值容差为 $\\tau = 10^{-12}$。\n\n**方法二：通过介值定理进行根认证**\n\n介值定理 (IVT) 指出，如果一个函数 $f(x)$ 在闭区间 $[a,b]$ 上连续，且 $y_0$ 是介于 $f(a)$ 和 $f(b)$ 之间的任意值，则在 $(a,b)$ 内至少存在一个 $c$ 使得 $f(c) = y_0$。一个用于求根的直接推论是，如果 $f(a)$ 和 $f(b)$ 的符号相反（即 $f(a)f(b)  0$），则在开区间 $(a,b)$ 内必定至少存在一个根。\n\n由于所有多项式在 $\\mathbb{R}$ 上都是连续的，因此该定理适用。算法流程如下：\n$1$. 将区间 $[a,b]$ 划分为一组子区间。生成一个具有指定间距 $h$ 的规则网格点 $x_i$。网格点定义为 $x_0=a, x_1=a+h, \\dots, x_k=a+kh$，其中 $a+kh \\le b$，如果端点 $x_{N}=b$ 尚未包含在内，则明确包含它。这样就产生了一系列子区间 $[x_i, x_{i+1}]$。\n$2$. 在每个网格点 $x_i$ 处计算多项式 $p(x)$ 的值。\n$3$. 对于每个子区间 $[x_i, x_{i+1}]$，我们检查端点之间是否存在严格的符号变化，即 $p(x_i) p(x_{i+1})  0$。在检查符号时，绝对值小于或等于容差 $\\tau=10^{-12}$ 的值被视为零。严格的符号变化要求两个端点都非零。\n$4$. 总数 $C_{\\mathrm{IVT}}$ 是检测到这种严格符号变化的子区间的数量。\n\n该方法给出了根数量的下界。它有已知的局限性：\n-   它无法检测偶数重根（例如 $(x-c)^2$），因为函数在 $x=c$ 处接触坐标轴但未改变符号。\n-   如果一对（或任意偶数个）不同且间距很近的根都落入单个子区间 $[x_i, x_{i+1}]$ 内，且 $p(x_i)$ 和 $p(x_{i+1})$ 符号相同，该方法可能会漏掉这些根。\n-   由于要求严格的符号变化，如果根恰好落在网格点上，该方法将不会计数。\n\n实现将按规定生成网格点，并使用 `numpy.polyval` 来计算多项式的值。计数符号变化的逻辑将遵循指定的对数值容差 $\\tau$ 的处理方式。\n\n最后的过程包括将两种算法应用于提供的测试用例，并为每个用例报告计数对 $[C_{\\mathrm{IVT}}, C_{\\mathrm{Sturm}}]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares Sturm's theorem and an IVT-based method for\n    counting real roots of polynomials on an interval.\n    \"\"\"\n    \n    TAU = 1e-12\n\n    def trim_poly(p):\n        \"\"\"Removes leading zero coefficients from a polynomial representation.\"\"\"\n        p = np.atleast_1d(p)\n        non_zeros = np.flatnonzero(p)\n        if non_zeros.size == 0:\n            return np.array([0.0])\n        return p[non_zeros[0]:]\n\n    def build_sturm_sequence(p_coeffs):\n        \"\"\"Constructs the Sturm sequence for a given polynomial.\"\"\"\n        p0 = trim_poly(p_coeffs)\n        if len(p0) == 1 and p0[0] == 0:\n            return []\n        \n        p1 = np.polyder(p0)\n        \n        sturm_seq = [p0, p1]\n        \n        pk_minus_1 = p0\n        pk = p1\n        \n        while True:\n            # The sequence terminates if pk is a zero polynomial\n            if len(pk) == 1 and np.isclose(pk[0], 0):\n                break\n            \n            # Use np.polydiv for polynomial long division\n            _quot, rem = np.polydiv(pk_minus_1, pk)\n            pk_plus_1 = -trim_poly(rem)\n            \n            # Check if the new polynomial (remainder) is zero\n            if len(pk_plus_1) == 1 and np.isclose(pk_plus_1[0], 0):\n                break\n            \n            sturm_seq.append(pk_plus_1)\n            \n            pk_minus_1 = pk\n            pk = pk_plus_1\n            \n        return sturm_seq\n\n    def count_sign_variations(sturm_seq, x, tau):\n        \"\"\"Counts the number of sign changes in the Sturm sequence evaluated at x.\"\"\"\n        if not sturm_seq:\n            return 0\n        \n        values = [np.polyval(p, x) for p in sturm_seq]\n        \n        # Filter out values that are numerically zero\n        non_zero_values = [v for v in values if abs(v) > tau]\n        \n        changes = 0\n        for i in range(len(non_zero_values) - 1):\n            if non_zero_values[i] * non_zero_values[i+1]  0:\n                changes += 1\n                \n        return changes\n\n    def sturm_root_count(p_coeffs, a, b, tau):\n        \"\"\"\n        Calculates the number of distinct real roots in (a, b) using Sturm's Theorem.\n        \"\"\"\n        seq = build_sturm_sequence(p_coeffs)\n        Va = count_sign_variations(seq, a, tau)\n        Vb = count_sign_variations(seq, b, tau)\n        return Va - Vb\n\n    def ivt_root_count(p_coeffs, a, b, h, tau):\n        \"\"\"\n        Counts subintervals with a certified root using the Intermediate Value Theorem.\n        \"\"\"\n        if a > b:\n            a, b = b, a\n        \n        # Generate grid points\n        num_full_steps = np.floor((b - a) / h)\n        grid_points = a + np.arange(num_full_steps + 1) * h\n        \n        # Ensure the endpoint b is included\n        if not np.isclose(grid_points[-1], b):\n            grid_points = np.append(grid_points, b)\n        \n        # Evaluate polynomial at grid points\n        p_values = np.polyval(p_coeffs, grid_points)\n        \n        # Determine signs, treating near-zeros as 0\n        signs = np.sign(p_values)\n        signs[np.abs(p_values) = tau] = 0\n        \n        ivt_count = 0\n        for i in range(len(signs) - 1):\n            # Check for a strict sign change (product is -1)\n            if signs[i] * signs[i+1]  0:\n                ivt_count += 1\n                \n        return ivt_count\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'p_coeffs': [1, 0, -1, 0], 'a': -2, 'b': 2, 'h': 0.4},\n        {'p_coeffs': [1, 0, -3, 2], 'a': -3, 'b': 3, 'h': 0.6},\n        {'p_coeffs': [1, 0, 0, 0, -1, 0], 'a': -10, 'b': 10, 'h': 4.7},\n        {'p_coeffs': [1, 0.3, -0.2875, 0.0375], 'a': -1, 'b': 1, 'h': 0.5},\n        {'p_coeffs': [1, 0, 1], 'a': -5, 'b': 5, 'h': 1.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        p, a, b, h = case['p_coeffs'], case['a'], case['b'], case['h']\n        \n        c_ivt = ivt_root_count(p, a, b, h, TAU)\n        c_sturm = sturm_root_count(p, a, b, TAU)\n        \n        results.append([c_ivt, c_sturm])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3144944"}, {"introduction": "中值定理（MVT）通常被视为一个纯理论性的结果，但它在计算科学中的真正威力体现在对数值误差的分析上。本练习 [@problem_id:3251117] 将通过一个具体实践来揭开中值定理的神秘面纱。你将首先推导一个基本数值近似方法——中心差分公式——的误差项，这个著名的误差项包含一个由中值定理保证其存在的点 $\\xi$。然后，核心任务是编写一个程序来数值计算这个“难以捉摸”的 $\\xi$ 的值，让你能够观察当步长 $h$ 变化时它的行为，从而为该定理在误差估计中的作用赋予一个切实的意义。", "problem": "设计并实现一个完整的程序，对于一个给定的光滑函数，该程序能够数值定位一个由导数中值定理保证存在的点 $\\xi \\in (x-h,x+h)$，使得在点 $x$ 处、步长为 $h$ 的一阶导数中心差分近似的误差可以用拉格朗日余项形式表示。此任务分为三个部分：\n\n1) 仅从基本定义和带拉格朗日余项的泰勒展开出发，推导一阶导数中心差分公式的精确主阶误差表达式。您必须确定正确的比例常数和符号，并在假设函数 $f$ 在 $x$ 的邻域内三阶连续可微的条件下，将误差表示为某个 $\\xi \\in (x-h,x+h)$ 处的 $f^{(3)}(\\xi)$ 的形式。不要假设任何现成的误差公式；从第一性原理进行推导。\n\n2) 基于您的推导，为给定的函数 $f$、其一阶导数 $f'$ 和三阶导数 $f^{(3)}$，在点 $x$ 和步长 $h>0$ 的条件下，提出一个计算有效 $\\xi$ 的数值方法。您的方法必须从导数中值定理和介值定理中获得逻辑上的证明：如果您的推导表明中心差分误差可以写成一个常数乘以 $f^{(3)}(\\xi)$，请解释如何变换观测误差，然后求解 $f^{(3)}(\\xi)=y^\\star$，以得到 $\\xi \\in [x-h,x+h]$，其中 $y^\\star$ 是您从观测误差计算出的一个量。您的数值方法应满足：\n- 当 $f^{(3)}$ 在 $[x-h,x+h]$ 上单调时，通过构造保证 $\\xi \\in [x-h,x+h]$，从而使 $y^\\star$ 被端点值 $f^{(3)}(x-h)$ 和 $f^{(3)}(x+h)$ 界定。\n- 处理 $f^{(3)}$ 在 $[x-h,x+h]$ 上（近似）恒定的退化情况；在这种情况下，请证明返回 $\\xi=x$ 是一个有效的数值代表。\n- 当 $h$ 很小但不为零时，对浮点效应具有鲁棒性。\n\n3) 将该方法实现为一个单一的可运行程序，为一个小规模的测试套件计算并报告距离 $|\\xi - x|$。对于下面的每个测试用例，为指定列表中的每个 $h$ 计算 $\\xi$，并按给定顺序记录相应的 $|\\xi-x|$ 值。该测试套件如下：\n\n- 案例 A（$f^{(3)}$ 递增）：$f(t)=e^{t}$，$f'(t)=e^{t}$，$f^{(3)}(t)=e^{t}$，在 $x=0.7$，对于 $h \\in \\{0.2,\\,0.1,\\,0.05,\\,0.025\\}$。\n- 案例 B（$f^{(3)}$ 线性）：$f(t)=t^{4}$，$f'(t)=4t^{3}$，$f^{(3)}(t)=24t$，在 $x=-0.3$，对于 $h \\in \\{0.2,\\,0.1,\\,0.05,\\,0.025\\}$。\n- 案例 C（$f^{(3)}$ 递减）：$f(t)=-e^{t}$，$f'(t)=-e^{t}$，$f^{(3)}(t)=-e^{t}$，在 $x=0.2$，对于 $h \\in \\{0.2,\\,0.1,\\,0.05,\\,0.025\\}$。\n- 案例 D（$f^{(3)}$ 恒定）：$f(t)=t^{3}$，$f'(t)=3t^{2}$，$f^{(3)}(t)=6$，在 $x=1.1$，对于 $h \\in \\{0.5,\\,0.25,\\,0.125,\\,0.0625\\}$。\n\n对于每个案例和每个 $h$，计算中心差分近似\n$$\nD_{c}(f;x,h)=\\frac{f(x+h)-f(x-h)}{2h},\n$$\n观测误差 $E=f'(x)-D_{c}(f;x,h)$，将其转换为您的推导所蕴含的适当目标值 $y^\\star$，然后在 $\\xi \\in [x-h,x+h]$ 中求解 $f^{(3)}(\\xi)=y^\\star$。最后，按以下顺序将绝对距离 $|\\xi-x|$ 的序列输出为包含 $16$ 个浮点数的单个扁平列表：\n\n$[\\,$案例 A（$h=0.2,\\,0.1,\\,0.05,\\,0.025$）；案例 B（$h=0.2,\\,0.1,\\,0.05,\\,0.025$）；案例 C（$h=0.2,\\,0.1,\\,0.05,\\,0.025$）；案例 D（$h=0.5,\\,0.25,\\,0.125,\\,0.0625$）$\\,]$.\n\n您的程序应生成单行输出，其中包含这个扁平列表，格式为带括号的逗号分隔 Python 风格列表，例如：\n\"[v1,v2,...,v16]\".\n所有实数必须以默认浮点格式打印。本问题不涉及任何物理单位或角度单位。", "solution": "该问题要求推导中心有限差分公式的误差项，制定一种数值方法以寻找误差项中的点 $\\xi$，并为一组给定的测试用例实现该方法。整个过程基于泰勒定理和连续函数的性质。\n\n### 第一部分：中心差分误差公式的推导\n\n任务是推导一阶导数的中心差分近似 $D_{c}(f;x,h) = \\frac{f(x+h) - f(x-h)}{2h}$ 的误差项。误差定义为 $E = f'(x) - D_{c}(f;x,h)$。我们假设函数 $f$ 在点 $x$ 的邻域内是三阶连续可微的，即 $f \\in C^3$。\n\n我们从 $f(x+h)$ 和 $f(x-h)$ 在 $x$ 点的泰勒展开开始。根据带拉格朗日余项的泰勒定理，对于某个 $\\xi_1 \\in (x, x+h)$ 和 $\\xi_2 \\in (x-h, x)$，我们可以写出：\n$$\nf(x+h) = f(x) + f'(x)h + \\frac{f''(x)}{2!}h^2 + \\frac{f^{(3)}(\\xi_1)}{3!}h^3\n$$\n$$\nf(x-h) = f(x) - f'(x)h + \\frac{f''(x)}{2!}h^2 - \\frac{f^{(3)}(\\xi_2)}{3!}h^3\n$$\n用第一个展开式减去第二个展开式，消去 $f(x)$ 和 $f''(x)$ 项：\n$$\nf(x+h) - f(x-h) = \\left( f'(x)h - (-f'(x)h) \\right) + \\left( \\frac{f^{(3)}(\\xi_1)}{6}h^3 - \\left(-\\frac{f^{(3)}(\\xi_2)}{6}h^3\\right) \\right)\n$$\n$$\nf(x+h) - f(x-h) = 2f'(x)h + \\frac{h^3}{6} \\left( f^{(3)}(\\xi_1) + f^{(3)}(\\xi_2) \\right)\n$$\n为了得到中心差分公式的表达式，我们两边除以 $2h$（因为 $h > 0$）：\n$$\n\\frac{f(x+h) - f(x-h)}{2h} = f'(x) + \\frac{h^2}{12} \\left( f^{(3)}(\\xi_1) + f^{(3)}(\\xi_2) \\right)\n$$\n这就给出了近似 $D_{c}(f;x,h) - f'(x)$ 的截断误差。问题将误差定义为 $E = f'(x) - D_{c}(f;x,h)$，所以我们有：\n$$\nE = - \\frac{h^2}{12} \\left( f^{(3)}(\\xi_1) + f^{(3)}(\\xi_2) \\right)\n$$\n为了用单个点 $\\xi$ 来表示这个误差，我们使用介值定理。由于假设 $f$ 是 $C^3$ 的，其三阶导数 $f^{(3)}$ 是一个连续函数。点 $\\xi_1$ 和 $\\xi_2$ 都在区间 $(x-h, x+h)$ 内。表达式 $\\frac{1}{2}(f^{(3)}(\\xi_1) + f^{(3)}(\\xi_2))$ 代表连续函数 $f^{(3)}$ 在区间 $(\\xi_2, \\xi_1) \\subset (x-h, x+h)$ 上的两个值的平均值。根据介值定理，必定存在一个点 $\\xi \\in (\\xi_2, \\xi_1)$，因此 $\\xi \\in (x-h, x+h)$，使得：\n$$\nf^{(3)}(\\xi) = \\frac{f^{(3)}(\\xi_1) + f^{(3)}(\\xi_2)}{2}\n$$\n将此代入我们的误差 $E$ 的表达式中：\n$$\nE = - \\frac{h^2}{12} \\left( 2 f^{(3)}(\\xi) \\right)\n$$\n这就得到了误差项的最终形式：\n$$\nE = f'(x) - D_{c}(f;x,h) = -\\frac{h^2}{6} f^{(3)}(\\xi)\n$$\n对于某个 $\\xi \\in (x-h, x+h)$。推导至此完成。\n\n### 第二部分：计算 $\\xi$ 的数值方法\n\n基于推导出的误差公式，我们可以设计一个数值方法来找到 $\\xi$。\n输入是函数 $f$、$f'$、$f^{(3)}$、一个点 $x$ 和一个步长 $h > 0$。\n\n1.  **计算观测误差**：首先，我们计算中心差分近似 $D_{c}(f;x,h)$，然后计算“观测”误差 $E_{obs}$，由于 $f'(x)$ 已知，我们可以得到其精确值：\n    $$\n    E_{obs} = f'(x) - \\frac{f(x+h) - f(x-h)}{2h}\n    $$\n2.  **确定目标值 $y^\\star$**：我们将观测误差与理论误差表达式相等：\n    $$\n    E_{obs} = -\\frac{h^2}{6} f^{(3)}(\\xi)\n    $$\n    我们可以解出 $f^{(3)}(\\xi)$ 来找到我们期望的点 $\\xi$ 必须满足的目标值 $y^\\star$：\n    $$\n    y^\\star = f^{(3)}(\\xi) = -\\frac{6 E_{obs}}{h^2} = -\\frac{6}{h^2} \\left( f'(x) - \\frac{f(x+h) - f(x-h)}{2h} \\right)\n    $$\n3.  **求解 $\\xi$**：问题现在简化为在区间 $[x-h, x+h]$ 内为方程 $f^{(3)}(t) - y^\\star = 0$ 找根。\n\n    -   **单调情况**：对于 $f^{(3)}(t)$ 在 $[x-h, x+h]$ 上单调的测试用例，理论保证 $y^\\star$ 位于值 $f^{(3)}(x-h)$ 和 $f^{(3)}(x+h)$ 之间。这是因为 $y^\\star$ 是 $f^{(3)}$ 在两个内部点 $\\xi_1$ 和 $\\xi_2$ 处的平均值。因此，对于函数 $G(t) = f^{(3)}(t) - y^\\star$，我们有一个被界定的根。在这种情况下，二分法是找到唯一根 $\\xi$ 的一种鲁棒且合适的选择。我们迭代地缩小区间 $[a, b]$（初始为 $[x-h, x+h]$），直到 $\\xi$ 达到所需的精度。\n\n    -   **恒定情况**：如果 $f^{(3)}(t)$ 在区间上是常数，比如说 $f^{(3)}(t) = C$，那么推导意味着 $y^\\star = \\frac{C+C}{2} = C$。方程变为 $C=C$，这对任何 $t \\in [x-h, x+h]$ 都成立。在这种退化情况下，技术上区间内的任何 $\\xi$ 值都是正确的。根据问题的指示，并作为一个有代表性的点的合理选择，我们选择区间的中心点 $\\xi = x$。这也与四次多项式（其 $f^{(3)}$ 是线性的）的精确解析结果 $\\xi = x$ 一致，并且该选择在 $h \\to 0$ 时提供了一个连续的极限。\n\n数值算法实现如下：首先，计算 $y^\\star$。然后，检查 $f^{(3)}(x-h)$ 和 $f^{(3)}(x+h)$ 是否足够接近以至于可以认为相等（在数值容差范围内），如果是，则返回 $\\xi=x$。否则，在区间 $[x-h, x+h]$ 上对 $G(t) = f^{(3)}(t) - y^\\star$ 应用二分法来找到 $\\xi$。\n\n### 第三部分：实现\n\n完整的程序实现了上述过程。一个函数 `compute_xi` 接受函数 $f$、$f'$、$f^{(3)}$ 以及参数 $x$ 和 $h$ 作为输入，并返回计算出的 $\\xi$ 值。主函数 `solve` 遍历四个指定的测试用例及其各自的 $h$ 值列表。对于每种组合，它调用 `compute_xi` 并计算距离 $|\\xi - x|$。这些距离被收集到一个扁平列表中，并以要求的格式打印出来。为了简洁，每个案例的函数都使用 lambda 表达式定义。对于常数情况 $f^{(3)}(t)=6$，函数被定义为 `lambda t: 6.0 + 0*t` 以确保它是一个接受参数的有效可调用对象，这是一种良好的编程实践。二分法被实现为固定迭代次数（100次），这足以达到双精度准确度。最终输出是一个包含16个浮点数的列表，对应于所有指定测试的 $|\\xi-x|$ 值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_xi(f, df, d3f, x, h, tol=1e-15, max_iter=100):\n    \"\"\"\n    Numerically computes the point xi in the Lagrange remainder form of the\n    central difference error.\n\n    Error E = f'(x) - D_c(f;x,h) = -h^2/6 * f'''(xi).\n\n    Args:\n        f (callable): The function.\n        df (callable): The first derivative of the function.\n        d3f (callable): The third derivative of the function.\n        x (float): The point at which to approximate the derivative.\n        h (float): The step size.\n        tol (float): The tolerance for the bisection method.\n        max_iter (int): The maximum number of iterations for bisection.\n\n    Returns:\n        float: The computed value of xi.\n    \"\"\"\n    # Step 1: Compute the central difference and the observed error.\n    d_c = (f(x + h) - f(x - h)) / (2.0 * h)\n    error_obs = df(x) - d_c\n\n    # Step 2: Compute the target value y_star for f'''(xi).\n    # f'''(xi) = -6 * error_obs / h^2\n    y_star = -6.0 * error_obs / (h**2)\n\n    # Step 3: Handle the (nearly) constant f''' case.\n    # We check if the values of f''' at the interval endpoints are close.\n    g_a_val = d3f(x - h)\n    g_b_val = d3f(x + h)\n    if np.isclose(g_a_val, g_b_val):\n        # For constant f''', any xi in (x-h, x+h) is valid. We choose x\n        # as a representative central point, as instructed.\n        return x\n\n    # Step 4: Solve f'''(xi) = y_star using the bisection method.\n    # We need to find the root of G(t) = f'''(t) - y_star.\n    a, b = x - h, x + h\n    G = lambda t: d3f(t) - y_star\n    \n    val_a = G(a)\n    val_b = G(b)\n\n    # The theory guarantees a root exists in (a, b). Floating point errors may\n    # cause y_star to be slightly outside [d3f(a), d3f(b)], but for the given\n    # well-behaved problems, this shouldn't be an issue.\n    if np.sign(val_a) == np.sign(val_b):\n        # This case suggests numerical precision issues or a non-monotonic f'''.\n        # For robustness, we could clamp, but for this problem we assume it won't happen.\n        # As a fallback, return the endpoint whose d3f value is closer to y_star.\n        if abs(val_a)  abs(val_b):\n            return a\n        else:\n            return b\n\n    # Bisection loop\n    for _ in range(max_iter):\n        mid = a + (b - a) / 2.0\n        val_mid = G(mid)\n\n        if abs(b - a) / 2.0  tol or val_mid == 0:\n            return mid\n\n        if np.sign(val_a) != np.sign(val_mid):\n            b = mid\n        else:\n            a = mid\n            val_a = val_mid # Update the boundary value for the next iteration\n            \n    return a + (b - a) / 2.0\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: f(t) = exp(t), increasing f'''\n        {'f': np.exp, 'df': np.exp, 'd3f': np.exp,\n         'x': 0.7, 'h_list': [0.2, 0.1, 0.05, 0.025]},\n        # Case B: f(t) = t^4, linear f'''\n        {'f': lambda t: t**4, 'df': lambda t: 4*t**3, 'd3f': lambda t: 24*t,\n         'x': -0.3, 'h_list': [0.2, 0.1, 0.05, 0.025]},\n        # Case C: f(t) = -exp(t), decreasing f'''\n        {'f': lambda t: -np.exp(t), 'df': lambda t: -np.exp(t), 'd3f': lambda t: -np.exp(t),\n         'x': 0.2, 'h_list': [0.2, 0.1, 0.05, 0.025]},\n        # Case D: f(t) = t^3, constant f'''\n        {'f': lambda t: t**3, 'df': lambda t: 3*t**2, 'd3f': lambda t: 6.0 + 0*t,\n         'x': 1.1, 'h_list': [0.5, 0.25, 0.125, 0.0625]}\n    ]\n\n    results = []\n    for case in test_cases:\n        f, df, d3f = case['f'], case['df'], case['d3f']\n        x, h_list = case['x'], case['h_list']\n        for h in h_list:\n            xi = compute_xi(f, df, d3f, x, h)\n            distance = abs(xi - x)\n            results.append(distance)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3251117"}]}