{"hands_on_practices": [{"introduction": "理论知识只有通过实例检验才能变得鲜活。本练习旨在通过两个精心设计的矩阵，深入探究三种主要诱导范数（$1$-范数、$2$-范数和$\\infty$-范数）之间的重要不等式关系。通过计算这个不等式的紧致性比率，你将直观地理解不同范数在衡量矩阵“大小”时的细微差别及其理论界限的有效性。[@problem_id:3158812]", "problem": "在计算科学导论中，矩阵范数用于量化线性变换如何放大以不同方式测量的向量。对于一个实矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 和一个向量 $x \\in \\mathbb{R}^{n}$，由向量范数 $\\|\\cdot\\|$ 导出的矩阵范数定义为 $\\|A\\| = \\sup_{x \\neq 0} \\frac{\\|Ax\\|}{\\|x\\|}$。考虑以下三种导出范数：$1$-范数（$\\|x\\|_{1} = \\sum_{i=1}^{n} |x_{i}|$)，无穷范数（$\\|x\\|_{\\infty} = \\max_{1 \\leq i \\leq n} |x_{i}|$)，以及 $2$-范数（$\\|x\\|_{2} = \\sqrt{\\sum_{i=1}^{n} x_{i}^{2}}$）。相应的导出矩阵范数记为 $\\|A\\|_{1}$、$\\|A\\|_{\\infty}$ 和 $\\|A\\|_{2}$。定义紧度比\n$$\nR(A) \\;=\\; \\frac{\\|A\\|_{2}}{\\sqrt{\\|A\\|_{1}\\,\\|A\\|_{\\infty}}}.\n$$\n从上述定义和关于 $A^{\\top}A$ 特征值的标准事实出发，计算下列两个矩阵的 $R(A)$ 的精确值：\n\n1. 设 $E \\in \\mathbb{R}^{m \\times n}$ 只有一个非零元素 $E_{11} = s$（其中 $s>0$），所有其他元素均为 $0$。计算 $R(E)$。\n\n2. 设 $H_{n} \\in \\mathbb{R}^{n \\times n}$ 是一个矩阵，其 $n$ 个列向量两两正交，且每个元素为 $+1$ 或 $-1$。计算 $R(H_{n})$ 关于 $n$ 的闭式表达式，然后计算当 $n=16$ 时该比率的值。\n\n将有序对 $\\left(R(E),\\,R(H_{16})\\right)$ 的最终答案以精确值的形式报告。无需四舍五入。", "solution": "首先对问题陈述进行严格的验证过程。\n\n### 步骤 1：提取已知条件\n- 一个实矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 和一个向量 $x \\in \\mathbb{R}^{n}$。\n- 导出矩阵范数定义：$\\|A\\| = \\sup_{x \\neq 0} \\frac{\\|Ax\\|}{\\|x\\|}$。\n- 向量 $1$-范数：$\\|x\\|_{1} = \\sum_{i=1}^{n} |x_{i}|$。\n- 向量无穷范数：$\\|x\\|_{\\infty} = \\max_{1 \\leq i \\leq n} |x_{i}|$。\n- 向量 $2$-范数：$\\|x\\|_{2} = \\sqrt{\\sum_{i=1}^{n} x_{i}^{2}}$。\n- 相应的导出矩阵范数：$\\|A\\|_{1}$、$\\|A\\|_{\\infty}$ 和 $\\|A\\|_{2}$。\n- 紧度比定义：$R(A) = \\frac{\\|A\\|_{2}}{\\sqrt{\\|A\\|_{1}\\,\\|A\\|_{\\infty}}}$。\n- 矩阵 $E \\in \\mathbb{R}^{m \\times n}$ 只有一个非零元素 $E_{11} = s$（其中 $s>0$），所有其他元素均为 $0$。\n- 矩阵 $H_{n} \\in \\mathbb{R}^{n \\times n}$，其 $n$ 个列向量两两正交，且每个元素为 $+1$ 或 $-1$。\n- 任务是计算 $R(E)$ 和 $R(H_{n})$ 作为 $n$ 的函数的精确值，对后者计算 $n=16$ 时的值，并报告有序对 $\\left(R(E),\\,R(H_{16})\\right)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学或事实不健全性**：该问题基于线性代数和数值分析中关于向量和矩阵范数的标准、正确的定义。所描述的矩阵是明确定义的数学对象。对于矩阵 $H_n$，其性质描述了一个缩放的 Hadamard 矩阵；已知当阶数 $n$ 是 $2$ 的幂时（包括 $n=16$），这类矩阵是存在的。该问题在数学上和科学上是健全的。\n2.  **非形式化或不相关**：该问题是一个矩阵代数的形式化练习，与计算科学中的矩阵范数主题直接相关。\n3.  **不完整或矛盾的设置**：为矩阵 $E$ 和 $H_n$ 提供的定义和性质对于计算所需范数是充分且一致的。没有缺失或矛盾的条件。\n4.  **不现实或不可行**：该问题纯属数学问题。条件在数学上是一致且可行的。\n5.  **不适定或结构不良**：该问题是适定的，具有清晰的定义和目标，可以导出一个唯一、可确定的解。\n6.  **伪深刻、琐碎或同义反复**：该问题需要对矩阵范数的性质及其计算有扎实的理解。这是一个实质性的练习，既不琐碎也不人为复杂。\n7.  **超出科学可验证性**：结果可以通过标准的数学证明推导和验证。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整的解答。\n\n***\n\n解答过程是先计算每个矩阵所需的范数，然后计算紧度比 $R(A)$。\n\n**第 1 部分：矩阵 $E$ 的计算**\n\n矩阵 $E \\in \\mathbb{R}^{m \\times n}$ 只有一个非零元素 $E_{11} = s > 0$。所有其他元素 $E_{ij}$ 均为 $0$。\n\n1.  **$\\|E\\|_{1}$ 的计算**：导出的矩阵 $1$-范数是最大绝对列和。\n    $$\n    \\|E\\|_{1} = \\max_{1 \\le j \\le n} \\sum_{i=1}^{m} |E_{ij}|\n    $$\n    第一列（$j=1$）的绝对值之和为 $\\sum_{i=1}^{m} |E_{i1}| = |E_{11}| + \\sum_{i=2}^{m} |E_{i1}| = |s| + 0 = s$，因为 $s>0$。\n    对于任何其他列（$j > 1$），和为 $\\sum_{i=1}^{m} |E_{ij}| = 0$，因为所有元素都为 $0$。\n    这些列和的最大值是 $s$。因此，$\\|E\\|_{1} = s$。\n\n2.  **$\\|E\\|_{\\infty}$ 的计算**：导出的矩阵 $\\infty$-范数是最大绝对行和。\n    $$\n    \\|E\\|_{\\infty} = \\max_{1 \\le i \\le m} \\sum_{j=1}^{n} |E_{ij}|\n    $$\n    第一行（$i=1$）的绝对值之和为 $\\sum_{j=1}^{n} |E_{1j}| = |E_{11}| + \\sum_{j=2}^{n} |E_{1j}| = |s| + 0 = s$。\n    对于任何其他行（$i > 1$），和为 $\\sum_{j=1}^{n} |E_{ij}| = 0$。\n    这些行和的最大值是 $s$。因此，$\\|E\\|_{\\infty} = s$。\n\n3.  **$\\|E\\|_{2}$ 的计算**：导出的 $2$-范数是矩阵的最大奇异值，也就是 $E^{\\top}E$ 最大特征值的平方根。矩阵 $E^{\\top}$ 是一个 $n \\times m$ 矩阵，其 $(E^{\\top})_{11} = s$，所有其他元素都为 $0$。我们来计算乘积 $E^{\\top}E \\in \\mathbb{R}^{n \\times n}$。\n    $E^{\\top}E$ 的 $(k,l)$ 元素由 $(E^{\\top}E)_{kl} = \\sum_{i=1}^{m} (E^{\\top})_{ki}E_{il} = \\sum_{i=1}^{m} E_{ik}E_{il}$ 给出。\n    $E$ 中唯一的非零元素是 $E_{11}=s$。所以，只有当 $i=1$ 且 $k=1$ 时，$E_{ik}$ 才非零。类似地，只有当 $i=1$ 且 $l=1$ 时，$E_{il}$ 才非零。\n    因此，只有当 $k=1$ 且 $l=1$ 时，这个和才非零：\n    $(E^{\\top}E)_{11} = \\sum_{i=1}^{m} E_{i1}E_{i1} = (E_{11})^2 = s^2$。\n    所有其他元素 $(E^{\\top}E)_{kl}$ 均为 $0$。\n    所以，$E^{\\top}E$ 是一个在 $(1,1)$ 位置为 $s^2$ 且其他位置全为零的矩阵。这个矩阵的特征值是其对角线元素，即一个 $s^2$ 和 $n-1$ 个零。\n    最大特征值为 $\\lambda_{\\max}(E^{\\top}E) = s^2$。\n    $2$-范数为 $\\|E\\|_{2} = \\sqrt{\\lambda_{\\max}(E^{\\top}E)} = \\sqrt{s^2} = s$（因为 $s>0$）。\n\n4.  **$R(E)$ 的计算**：\n    $$\n    R(E) = \\frac{\\|E\\|_{2}}{\\sqrt{\\|E\\|_{1}\\,\\|E\\|_{\\infty}}} = \\frac{s}{\\sqrt{s \\cdot s}} = \\frac{s}{\\sqrt{s^2}} = \\frac{s}{s} = 1.\n    $$\n\n**第 2 部分：矩阵 $H_n$ 的计算**\n\n矩阵 $H_{n} \\in \\mathbb{R}^{n \\times n}$ 的列向量两两正交，且每个元素 $(H_n)_{ij}$ 为 $+1$ 或 $-1$。\n\n设 $h_j$ 是 $H_n$ 的第 $j$ 列。给定的性质是：\n-   当 $i \\neq j$ 时，$h_i^{\\top}h_j = 0$。\n-   $H_n$ 的元素为 $(H_n)_{ij} \\in \\{+1, -1\\}$。\n\n根据第二个性质，任意列向量 $h_j$ 的欧几里得范数平方为：\n$h_j^{\\top}h_j = \\|h_j\\|^2_2 = \\sum_{i=1}^{n} ((H_n)_{ij})^2 = \\sum_{i=1}^{n} (\\pm 1)^2 = \\sum_{i=1}^{n} 1 = n$。\n\n结合这些性质，我们可以确定矩阵乘积 $H_n^{\\top}H_n$。该乘积的第 $(i,j)$ 个元素是 $h_i^{\\top}h_j$。\n$$\n(H_n^{\\top}H_n)_{ij} = h_i^{\\top}h_j = \\begin{cases} n,  \\text{如果 } i=j \\\\ 0,  \\text{如果 } i \\neq j \\end{cases}\n$$\n这意味着 $H_n^{\\top}H_n = n I_n$，其中 $I_n$ 是 $n \\times n$ 单位矩阵。\n\n1.  **$\\|H_n\\|_{1}$ 的计算**：最大绝对列和。\n    对于任意列 $j$，绝对列和为 $\\sum_{i=1}^{n} |(H_n)_{ij}|$。因为每个元素是 $\\pm 1$，其绝对值为 $1$。\n    $$\n    \\sum_{i=1}^{n} |(H_n)_{ij}| = \\sum_{i=1}^{n} 1 = n.\n    $$\n    由于每一列的和都是 $n$，所以最大值是 $n$。因此，$\\|H_n\\|_{1} = n$。\n\n2.  **$\\|H_n\\|_{\\infty}$ 的计算**：最大绝对行和。\n    类似地，对于任意行 $i$，绝对行和为 $\\sum_{j=1}^{n} |(H_n)_{ij}| = \\sum_{j=1}^{n} 1 = n$。\n    这些相同和的最大值是 $n$。因此，$\\|H_n\\|_{\\infty} = n$。\n\n3.  **$\\|H_n\\|_{2}$ 的计算**：$H_n^{\\top}H_n$ 的最大特征值的平方根。\n    如前所述，$H_n^{\\top}H_n = n I_n$。这是一个对角矩阵，所有对角元素都等于 $n$。\n    $n I_n$ 的特征值都等于 $n$。\n    最大特征值为 $\\lambda_{\\max}(H_n^{\\top}H_n) = n$。\n    因此，$2$-范数为 $\\|H_n\\|_{2} = \\sqrt{n}$。\n\n4.  **$R(H_n)$ 的计算**：\n    $$\n    R(H_n) = \\frac{\\|H_n\\|_{2}}{\\sqrt{\\|H_n\\|_{1}\\,\\|H_n\\|_{\\infty}}} = \\frac{\\sqrt{n}}{\\sqrt{n \\cdot n}} = \\frac{\\sqrt{n}}{\\sqrt{n^2}} = \\frac{\\sqrt{n}}{n} = \\frac{1}{\\sqrt{n}}.\n    $$\n\n最后，我们计算 $n=16$ 时的 $R(H_{n})$：\n$$\nR(H_{16}) = \\frac{1}{\\sqrt{16}} = \\frac{1}{4}.\n$$\n\n所求的有序对是 $(R(E), R(H_{16}))$。\n我们得到 $R(E)=1$ 和 $R(H_{16}) = \\frac{1}{4}$。\n该有序对是 $(1, \\frac{1}{4})$。", "answer": "$$\n\\boxed{\\begin{pmatrix} 1  \\frac{1}{4} \\end{pmatrix}}\n$$", "id": "3158812"}, {"introduction": "计算矩阵的谱范数（$2$-范数）是许多科学与工程应用的核心。本实践将指导你从第一性原理出发，实现计算谱范数的经典算法——幂迭代法。这个过程不仅能让你掌握一种强大的数值计算工具，还能通过与理论边界值的对比验证，加深你对不同范数之间联系的理解。[@problem_id:3158797]", "problem": "您需要编写一个完整、可运行的程序，该程序使用幂迭代法估计矩阵的谱范数，并根据基于范数的界验证该估计值。此任务必须在计算科学导论的背景下，从矩阵代数的基本原理出发解决，从诱导范数的定义以及特征值和奇异值的基本性质开始，而不使用专门的数值线性代数例程来直接计算奇异值或特征值。\n\n从以下基本定义和经过充分检验的事实开始：\n- 对于实矩阵 $A \\in \\mathbb{R}^{m \\times n}$，诱导2-范数（谱范数）定义为 $$\\|A\\|_2 = \\max_{\\mathbf{x} \\neq \\mathbf{0}} \\frac{\\|A \\mathbf{x}\\|_2}{\\|\\mathbf{x}\\|_2}.$$ 此范数等于 $A$ 的最大奇异值。\n- 构造对称半正定矩阵 $$B = A^\\top A \\in \\mathbb{R}^{n \\times n}.$$ $B$ 的最大特征值等于 $A$ 的最大奇异值的平方。因此，如果 $\\lambda_{\\max}(B)$ 表示 $B$ 的最大特征值，则 $$\\|A\\|_2 = \\sqrt{\\lambda_{\\max}(A^\\top A)}.$$\n- 矩阵的诱导1-范数和无穷范数分别定义为 $$\\|A\\|_1 = \\max_{1 \\leq j \\leq n} \\sum_{i=1}^m |a_{ij}| \\quad \\text{和} \\quad \\|A\\|_\\infty = \\max_{1 \\leq i \\leq m} \\sum_{j=1}^n |a_{ij}|.$$\n- 以下经过充分检验的不等式提供了谱范数关于1-范数和无穷范数的界：$$\\|A\\|_2 \\leq \\sqrt{\\|A\\|_1 \\, \\|A\\|_\\infty},$$ 以及 $$\\|A\\|_2 \\geq \\max\\left(\\frac{\\|A\\|_1}{\\sqrt{m}}, \\frac{\\|A\\|_\\infty}{\\sqrt{n}}\\right).$$\n\n您的程序必须对 $B = A^\\top A$ 实现幂迭代法以近似 $\\lambda_{\\max}(B)$，然后通过对近似值取平方根来估计 $\\|A\\|_2$。使用确定性的初始向量，在每一步中通过欧几里得范数进行归一化，在每次迭代中计算瑞利商，并在瑞利商的相对变化低于某个容差或达到最大迭代次数时终止。请确保处理退化情况，例如当 $B$ 是零矩阵时的零矩阵情况。\n\n测试套件：\n使用以下 $\\mathbb{R}^{m \\times n}$ 中的矩阵 $A$ 来测试实现的不同方面。这些矩阵是为确保科学真实性和覆盖范围而明确提供的。\n\n1. 正常路径（矩形，混合符号）：$$A_1 = \\begin{pmatrix} 3  -1 \\\\ 0  2 \\\\ 1  1 \\end{pmatrix}$$ 其中 $m = 3$ 且 $n = 2$。\n2. 边界情况（全零）：$$A_2 = \\begin{pmatrix} 0  0  0  0 \\\\ 0  0  0  0 \\\\ 0  0  0  0 \\\\ 0  0  0  0 \\end{pmatrix}$$ 其中 $m = 4$ 且 $n = 4$。\n3. 边缘情况（秩亏，列向量线性相关）：$$A_3 = \\begin{pmatrix} 1  2  3 \\\\ 2  4  6 \\end{pmatrix}$$ 其中 $m = 2$ 且 $n = 3$。\n4. 病态对称正定情况（希尔伯特矩阵）：$$A_4 = \\left[ a_{ij} \\right]_{i,j=1}^5, \\quad a_{ij} = \\frac{1}{i + j - 1}$$ 其中 $m = 5$ 且 $n = 5$。\n\n每个测试用例的计算和验证要求：\n- 通过应用于 $B = A^\\top A$ 的幂迭代法估计 $\\|A\\|_2$。\n- 计算下界 $$L = \\max\\left(\\frac{\\|A\\|_1}{\\sqrt{m}}, \\frac{\\|A\\|_\\infty}{\\sqrt{n}}\\right).$$\n- 计算上界 $$U = \\sqrt{\\|A\\|_1 \\, \\|A\\|_\\infty}.$$\n- 检查估计的 $\\|A\\|_2$ 是否在区间 $[L, U]$ 内。\n\n答案规范：\n- 对每个测试用例，输出一个包含四个值的列表：估计的谱范数（四舍五入到八位小数）、下界 $L$（四舍五入到八位小数）、上界 $U$（四舍五入到八位小数），以及一个指示估计值是否在界限内的布尔值。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个逗号分隔的列表，并用方括号括起来，每个测试用例本身也表示为一个带方括号的列表。例如，格式应为 $$\\texttt{[[est1,low1,up1,flag1],[est2,low2,up2,flag2],\\dots]}$$，不含空格，其中每个 $\\texttt{est}$、$\\texttt{low}$ 和 $\\texttt{up}$ 是一个四舍五入到八位的小数，每个 $\\texttt{flag}$ 是 $\\texttt{True}$ 或 $\\texttt{False}$。", "solution": "该问题经评估是有效的。它在科学上是合理的、适定的和客观的，为完整的解决方案提供了明确的任务以及所有必要的定义和数据。所涉及的所有原理——矩阵范数、特征值性质和幂迭代法——在数值线性代数领域都是标准且正确的。测试用例涵盖了一系列适当的场景，包括标准情况、边界情况（零矩阵）、边缘情况（秩亏矩阵）和病态情况。\n\n任务是估计给定实矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 的谱范数 $\\|A\\|_2$。解决方案将从基本原理出发，分三个阶段进行：首先，建立谱范数与相关矩阵特征值之间的理论联系；其次，详细说明用于近似所需特征值的幂迭代算法；第三，计算基于范数的界以验证数值估计。\n\n**1. 谱范数与特征值**\n\n矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 的谱范数，或称诱导2-范数，定义为：\n$$\n\\|A\\|_2 = \\max_{\\mathbf{x} \\neq \\mathbf{0}} \\frac{\\|A \\mathbf{x}\\|_2}{\\|\\mathbf{x}\\|_2}\n$$\n其中 $\\mathbf{x} \\in \\mathbb{R}^n$ 且 $\\|\\cdot\\|_2$ 表示欧几里得向量范数。这个定义等价于说 $\\|A\\|_2$ 是 $A$ 的最大奇异值，记为 $\\sigma_{\\max}(A)$。\n\n为了在不直接进行奇异值分解的情况下找到 $\\sigma_{\\max}(A)$，我们利用它与矩阵 $B = A^\\top A$ 特征值的关系。让我们考虑谱范数的平方：\n$$\n\\|A\\|_2^2 = \\left( \\max_{\\|\\mathbf{x}\\|_2 = 1} \\|A \\mathbf{x}\\|_2 \\right)^2 = \\max_{\\|\\mathbf{x}\\|_2 = 1} \\|A \\mathbf{x}\\|_2^2\n$$\n向量的欧几里得范数的平方可以写成内积：$\\|A \\mathbf{x}\\|_2^2 = (A \\mathbf{x})^\\top (A \\mathbf{x}) = \\mathbf{x}^\\top A^\\top A \\mathbf{x}$。\n将此代入表达式中得到：\n$$\n\\|A\\|_2^2 = \\max_{\\|\\mathbf{x}\\|_2 = 1} \\mathbf{x}^\\top (A^\\top A) \\mathbf{x}\n$$\n这就是矩阵 $B = A^\\top A$ 最大特征值的定义。矩阵 $B$ 是对称的（因为 $(A^\\top A)^\\top = A^\\top (A^\\top)^\\top = A^\\top A$）和半正定的（因为对于所有 $\\mathbf{x}$，$\\mathbf{x}^\\top B \\mathbf{x} = \\|A\\mathbf{x}\\|_2^2 \\geq 0$）。设 $\\lambda_{\\max}(B)$ 为 $B$ 的最大特征值。那么：\n$$\n\\|A\\|_2^2 = \\lambda_{\\max}(A^\\top A)\n$$\n因此，谱范数可以计算为：\n$$\n\\|A\\|_2 = \\sqrt{\\lambda_{\\max}(A^\\top A)}\n$$\n我们的主要计算任务就是找到对称矩阵 $B = A^\\top A$ 的最大特征值。\n\n**2. 幂迭代法**\n\n幂迭代法是一种用于近似主特征值（绝对值最大的特征值）及其对应特征向量的算法。对于像 $B = A^\\top A$ 这样的实对称矩阵，所有特征值都是实数，主特征值就是 $\\lambda_{\\max}(B)$。\n\n该算法按以下步骤进行：\n1.  **初始化**：选择一个确定性初始向量 $\\mathbf{x}_0 \\in \\mathbb{R}^n$ 且 $\\|\\mathbf{x}_0\\|_2 = 1$。一个常见的选择是归一化的全1向量。设 $\\lambda^{(0)} = 0$。\n2.  **迭代**：对于 $k = 1, 2, 3, \\dots, \\text{max_iter}$：\n    a.  **矩阵作用**：计算 $\\mathbf{y}^{(k)} = B \\mathbf{x}^{(k-1)}$。\n    b.  **归一化**：计算欧几里得范数 $\\|\\mathbf{y}^{(k)}\\|_2$。如果范数为零，则意味着 $\\lambda_{\\max}(B)=0$，迭代可以停止。否则，对向量进行归一化：$\\mathbf{x}^{(k)} = \\mathbf{y}^{(k)} / \\|\\mathbf{y}^{(k)}\\|_2$。\n    c.  **估计特征值**：使用瑞利商估计特征值。由于 $\\mathbf{x}^{(k)}$ 是单位向量，这可以简化为：\n        $$\n        \\lambda^{(k)} = (\\mathbf{x}^{(k)})^\\top B \\mathbf{x}^{(k)}\n        $$\n    d.  **检查收敛性**：如果特征值估计的相对变化低于指定的容差 $\\epsilon$，则迭代终止：\n        $$\n        \\frac{|\\lambda^{(k)} - \\lambda^{(k-1)}|}{|\\lambda^{(k)}|}  \\epsilon\n        $$\n        如果达到最大迭代次数，过程也会停止。\n在第 $k$ 次迭代收敛时，最大特征值的估计值为 $\\lambda_{\\max}(B) \\approx \\lambda^{(k)}$。\n\n一种特殊情况是当 $A$ 是零矩阵时。在这种情况下，$B = A^\\top A$ 也是零矩阵。对于任何初始向量 $\\mathbf{x}_0$，$B\\mathbf{x}_0=\\mathbf{0}$，因此 $\\lambda_{\\max}(B)=0$ 且 $\\|A\\|_2=0$。必须明确处理此情况以避免在归一化过程中出现除以零的错误。\n\n**3. 使用基于范数的界进行验证**\n\n对 $\\|A\\|_2$ 的数值估计可以通过检查它是否位于由其他更易于计算的矩阵范数定义的区间内来进行验证。所需的范数是1-范数和$\\infty$-范数：\n-   **1-范数（最大绝对列和）**：$\\|A\\|_1 = \\max_{1 \\leq j \\leq n} \\sum_{i=1}^m |a_{ij}|$\n-   **$\\infty$-范数（最大绝对行和）**：$\\|A\\|_\\infty = \\max_{1 \\leq i \\leq m} \\sum_{j=1}^n |a_{ij}|$\n\n这些范数为谱范数提供了以下界限：\n-   **下界**：$L = \\max\\left(\\frac{\\|A\\|_1}{\\sqrt{m}}, \\frac{\\|A\\|_\\infty}{\\sqrt{n}}\\right)$\n-   **上界**：$U = \\sqrt{\\|A\\|_1 \\|A\\|_\\infty}$\n\n估计的谱范数，我们称之为 $\\text{est}_{\\|A\\|_2}$，应满足不等式 $L \\leq \\text{est}_{\\|A\\|_2} \\leq U$。这为幂迭代的结果提供了一个关键的合理性检查。\n\n**每个测试用例的算法摘要：**\n1.  给定矩阵 $A \\in \\mathbb{R}^{m \\times n}$。\n2.  计算矩阵1-范数 $\\|A\\|_1$ 和 $\\infty$-范数 $\\|A\\|_\\infty$。\n3.  计算 $\\|A\\|_2$ 的下界 $L$ 和上界 $U$。\n4.  处理特殊情况：如果 $A$ 是零矩阵，则将估计的谱范数设为 $\\text{est}_{\\|A\\|_2} = 0$。\n5.  否则，构造矩阵 $B = A^\\top A$。\n6.  对 $B$ 应用幂迭代法以找到 $\\lambda_{\\max}(B)$ 的估计值。\n7.  计算估计的谱范数：$\\text{est}_{\\|A\\|_2} = \\sqrt{\\lambda_{\\max}(B)}$。\n8.  验证估计值是否在界限内：$L \\leq \\text{est}_{\\|A\\|_2} \\leq U$。\n9.  收集估计的范数、下界、上界以及布尔验证结果。所有数值均需四舍五入到八位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef estimate_spectral_norm(A, tol=1e-12, max_iter=2000):\n    \"\"\"\n    Estimates the spectral norm of a matrix A using power iteration on A.T @ A.\n\n    Args:\n        A (np.ndarray): The input matrix.\n        tol (float): The tolerance for convergence.\n        max_iter (int): The maximum number of iterations.\n\n    Returns:\n        float: The estimated spectral norm of A.\n    \"\"\"\n    m, n = A.shape\n    \n    # Handle the zero matrix case, where the norm is 0.\n    if not np.any(A):\n        return 0.0\n        \n    B = A.T @ A\n    \n    # Initialize a deterministic starting vector (vector of ones).\n    # Has to be of size n for the matrix B which is n x n.\n    x = np.ones(n)\n    \n    lambda_old = 0.0\n    \n    for _ in range(max_iter):\n        # Power iteration step\n        Bx = B @ x\n        norm_Bx = np.linalg.norm(Bx)\n        \n        # If Bx is zero, the largest eigenvalue is 0.\n        # This can happen if the initial vector is orthogonal to the dominant eigenvector space\n        # or if the matrix is a zero matrix (already handled).\n        if norm_Bx == 0:\n            lambda_new = 0.0\n            break\n            \n        x = Bx / norm_Bx\n        \n        # Rayleigh quotient to estimate the eigenvalue\n        lambda_new = x.T @ B @ x\n        \n        # Check for convergence using relative error\n        if lambda_new > 0 and abs(lambda_new - lambda_old)  tol * lambda_new:\n            break\n        \n        lambda_old = lambda_new\n    else: # This else belongs to the for loop and is executed if the loop finishes without break\n        # This could be a warning in a real application, but for this problem we just return the last value.\n        pass\n\n    return np.sqrt(lambda_new)\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. Happy path (rectangular, mixed signs)\n        np.array([[3., -1.], [0., 2.], [1., 1.]]),\n        \n        # 2. Boundary case (all zeros)\n        np.array([[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]]),\n\n        # 3. Edge case (rank-deficient)\n        np.array([[1., 2., 3.], [2., 4., 6.]]),\n        \n        # 4. Ill-conditioned symmetric positive definite case (Hilbert matrix)\n        # Using 1-based indexing for i,j from 1 to 5 as per problem.\n        # Python uses 0-based, so a[i,j] = 1/((i+1)+(j+1)-1) = 1/(i+j+1)\n        np.array([[1.0 / (i + j + 1) for j in range(5)] for i in range(5)])\n    ]\n\n    all_results_str = []\n    \n    for A in test_cases:\n        m, n = A.shape\n        \n        # Estimate the spectral norm using power iteration\n        est_norm_2 = estimate_spectral_norm(A)\n        \n        # Compute 1-norm and infinity-norm from first principles\n        norm_1 = np.max(np.sum(np.abs(A), axis=0))\n        norm_inf = np.max(np.sum(np.abs(A), axis=1))\n\n        # Compute the lower and upper bounds\n        # Handle division by zero if m or n is zero (not in test cases, but good practice).\n        lower_bound = 0\n        if m > 0 and n > 0:\n            term1 = norm_1 / np.sqrt(m)\n            term2 = norm_inf / np.sqrt(n)\n            lower_bound = np.max([term1, term2])\n        \n        upper_bound = np.sqrt(norm_1 * norm_inf)\n        \n        # Validate if the estimate is within the bounds\n        # Using a small tolerance for floating point comparisons\n        is_valid = (est_norm_2 >= lower_bound - 1e-9) and (est_norm_2 = upper_bound + 1e-9)\n\n        # Format results for the current case\n        case_result_str = (\n            f\"[{est_norm_2:.8f},\"\n            f\"{lower_bound:.8f},\"\n            f\"{upper_bound:.8f},\"\n            f\"{is_valid}]\"\n        )\n        all_results_str.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "3158797"}, {"introduction": "矩阵范数和条件数在分析数值算法的稳定性和效率方面扮演着至关重要的角色。本练习将理论付诸实践，通过构建一个在计算科学中无处不在的二维拉普拉斯算子离散矩阵，来研究其范数和条件数如何随网格规模变化。这项分析直接关系到偏微分方程求解器的性能，并能让你亲手计算出保证数值模拟稳定的关键参数——最大时间步长。[@problem_id:3158860]", "problem": "您将编写一个完整、可运行的程序，该程序构建与单位正方形上带有齐次狄利克雷边界条件的二维负拉普拉斯算子的标准五点有限差分离散对应的矩阵，然后使用此矩阵研究谱二范数和二范数条件数如何随网格分辨率变化。您的程序还必须量化相关的线性常微分方程（ODE）系统使用显式前向欧拉求解器时的最大稳定时间步长。所有计算都将以纯粹的、无量纲的数学术语进行。\n\n考虑单位正方形上一个 $n \\times n$ 的内部点网格，其均匀间距为 $h = \\frac{1}{n+1}$。令 $N = n^2$ 为未知数的数量。定义矩阵 $A \\in \\mathbb{R}^{N \\times N}$ 来表示带有齐次狄利克雷边界条件的负拉普拉斯算子 $- \\Delta$ 的标准五点模板有限差分近似。形式上，令 $T \\in \\mathbb{R}^{n \\times n}$ 为一个三对角矩阵，其主对角线元素为 $2$，第一亚对角线和第一超对角线元素为 $-1$。令 $I \\in \\mathbb{R}^{n \\times n}$ 表示单位矩阵。那么 $A$ 是按 $1/h^2$ 缩放的克罗内克和，即：\n$$\nA = \\frac{1}{h^2}\\left( I \\otimes T + T \\otimes I \\right).\n$$\n在所有后续计算中，您必须使用此 $A$ 作为唯一的矩阵。\n\n令 $\\lVert \\cdot \\rVert_2$ 表示谱（算子）二范数，令 $\\kappa_2(A) = \\lVert A \\rVert_2 \\lVert A^{-1} \\rVert_2$ 为二范数条件数。仅使用关于范数、特征值、克罗内克和以及线性多步法稳定性的基本定义和事实，对下面的每个测试用例执行以下操作：\n1. 完全按照规定构建 $A$。\n2. 计算 $\\lVert A \\rVert_2$。\n3. 计算 $\\kappa_2(A)$。\n4. 考虑通过对单位扩散系数的热方程进行半离散化得到的线性ODE系统 $u'(t) = - A \\, u(t)$。仅使用应用于 $u'(t) = -A \\, u(t)$ 的显式前向欧拉方法的线性稳定性定义，确定该系统的最大稳定时间步长 $\\Delta t_{\\max}$。\n\n您的程序必须为以下网格尺寸测试套件生成数值答案：\n- $n = 1$（边界情况，最小的非平凡系统），\n- $n = 4$（小型系统），\n- $n = 8$（中等系统），\n- $n = 16$（较大型系统），\n- $n = 32$（合理运行时间内的压力测试）。\n\n每个测试用例的输出必须是一个包含三个实数 $[\\lVert A \\rVert_2, \\kappa_2(A), \\Delta t_{\\max}]$ 的列表，其中每个数字都四舍五入到六位有效数字。最终输出必须是单行，包含这些按用例排列的结果的列表，顺序与上面列出的 $n$ 的顺序相同，并且行内没有任何空格。例如，输出必须如下所示：\n$$\n[[x_{11},x_{12},x_{13}],[x_{21},x_{22},x_{23}],\\dots,[x_{51},x_{52},x_{53}]]\n$$\n其中每个 $x_{ij}$ 是一个四舍五入到六位有效数字的实数。\n\n您的程序不得需要用户输入，也不得访问外部文件或网络。它必须使用一种数值上可靠的方法，基于 $A$ 的结构以及二范数和条件数的定义来估算 $\\lVert A \\rVert_2$ 和 $\\kappa_2(A)$。\n\n您的最终程序必须只打印上述描述的单行作为其输出。", "solution": "问题陈述已经过严格审查，并被确定为有效。它科学上基于偏微分方程数值分析的原理，是适定的，具有唯一且可计算的解，并以客观、形式化的语言表述。该问题是计算科学中的一个标准练习，旨在测试对有限差分法、从克罗内克积派生的矩阵性质以及常微分方程（ODE）数值方法稳定性的理解。所有必要的数据和定义均已提供。\n\n任务是为一系列网格尺寸 $n$ 计算三个量：谱范数 $\\lVert A \\rVert_2$、二范数条件数 $\\kappa_2(A)$ 以及相关 ODE 系统的最大稳定时间步长 $\\Delta t_{\\max}$。矩阵 $A \\in \\mathbb{R}^{N \\times N}$（其中 $N=n^2$）是单位正方形上负拉普拉斯算子的五点有限差分近似，由下式给出：\n$$\nA = \\frac{1}{h^2}\\left( I \\otimes T + T \\otimes I \\right)\n$$\n其中 $h = \\frac{1}{n+1}$，$I \\in \\mathbb{R}^{n \\times n}$ 是单位矩阵，$T \\in \\mathbb{R}^{n \\times n}$ 是主对角线元素为 $2$、第一亚对角线和第一超对角线元素为 $-1$ 的三对角矩阵。\n\n计算所需量的最有效且数值上最可靠的方法是利用已知的 $A$ 的特征值解析表达式，而不是构建完整的 $N \\times N$ 矩阵并使用数值特征值求解器，因为后者对于大的 $n$ 计算成本高昂且容易出现浮点误差。$A$ 的结构允许采用精确的解析方法。\n\n**1. 矩阵 $A$ 的特征值**\n\n矩阵 $T \\in \\mathbb{R}^{n \\times n}$ 的特征值有解析解，由下式给出：\n$$\n\\lambda_k(T) = 2 - 2 \\cos\\left(\\frac{k \\pi}{n+1}\\right) \\quad \\text{for } k = 1, 2, \\dots, n.\n$$\n矩阵 $A$ 被定义为缩放的克罗内克和 $A = \\frac{1}{h^2}(I \\otimes T + T \\otimes I)$。克罗内克和的一个基本性质是其特征值是构成矩阵特征值的和。具体来说，对于所有索引对 $j,k \\in \\{1, \\dots, n\\}$，$I \\otimes T + T \\otimes I$ 的特征值是 $\\lambda_j(T) + \\lambda_k(T)$。\n因此，$A$ 的特征值是：\n$$\n\\lambda_{j,k}(A) = \\frac{1}{h^2} \\left( \\lambda_j(T) + \\lambda_k(T) \\right) = \\frac{1}{h^2} \\left[ \\left(2 - 2 \\cos\\left(\\frac{j \\pi}{n+1}\\right)\\right) + \\left(2 - 2 \\cos\\left(\\frac{k \\pi}{n+1}\\right)\\right) \\right]\n$$\n对于 $j,k = 1, 2, \\dots, n$。由于 $h = \\frac{1}{n+1}$，我们有 $1/h^2 = (n+1)^2$。\n\n**2. 谱范数 $\\lVert A \\rVert_2$**\n\n矩阵 $T$ 是对称的，因此 $A$ 也是对称的。对于对称矩阵，谱范数（或 $2$-范数）等于其谱半径，即其特征值绝对值的最大值：\n$$\n\\lVert A \\rVert_2 = \\rho(A) = \\max_{j,k} |\\lambda_{j,k}(A)|.\n$$\n对于 $j,k \\in \\{1, \\dots, n\\}$，项 $\\frac{k \\pi}{n+1}$ 位于区间 $(0, \\pi)$ 内，因此 $\\cos(\\frac{k \\pi}{n+1})  1$。这确保了对所有 $k$ 都有 $\\lambda_k(T) > 0$，因此，所有特征值 $\\lambda_{j,k}(A)$ 都严格为正。范数就是最大特征值 $\\lambda_{\\max}(A)$。\n当余弦项最小时，达到最大特征值。余弦函数在 $[0, \\pi]$ 上是递减的，所以我们必须为余弦选择尽可能大的自变量，这对应于索引 $j=n$ 和 $k=n$。\n$$\n\\lVert A \\rVert_2 = \\lambda_{\\max}(A) = \\lambda_{n,n}(A) = \\frac{1}{h^2} \\left[ 4 - 4 \\cos\\left(\\frac{n \\pi}{n+1}\\right) \\right].\n$$\n使用恒等式 $1 - \\cos(\\theta) = 2 \\sin^2(\\theta/2)$，上式简化为：\n$$\n\\lVert A \\rVert_2 = \\frac{4}{h^2} \\left( 2 \\sin^2\\left(\\frac{n \\pi}{2(n+1)}\\right) \\right) = \\frac{8}{h^2} \\sin^2\\left(\\frac{n \\pi}{2(n+1)}\\right).\n$$\n\n**3. 条件数 $\\kappa_2(A)$**\n\n$2$-范数条件数定义为 $\\kappa_2(A) = \\lVert A \\rVert_2 \\lVert A^{-1} \\rVert_2$。由于 $A$ 是对称正定的，其特征值为正，且 $A^{-1}$ 的特征值为 $1/\\lambda_{j,k}(A)$。逆矩阵的范数是 $\\lVert A^{-1} \\rVert_2 = \\max(1/\\lambda) = 1/\\min(\\lambda) = 1/\\lambda_{\\min}(A)$。\n因此，条件数是最大特征值与最小特征值的比值：\n$$\n\\kappa_2(A) = \\frac{\\lambda_{\\max}(A)}{\\lambda_{\\min}(A)}.\n$$\n最小特征值 $\\lambda_{\\min}(A)$ 在其定义中的余弦项最大化时出现，这对应于最小的索引 $j=1$ 和 $k=1$。\n$$\n\\lambda_{\\min}(A) = \\lambda_{1,1}(A) = \\frac{1}{h^2} \\left[ 4 - 4 \\cos\\left(\\frac{\\pi}{n+1}\\right) \\right] = \\frac{8}{h^2} \\sin^2\\left(\\frac{\\pi}{2(n+1)}\\right).\n$$\n那么，比值为：\n$$\n\\kappa_2(A) = \\frac{\\frac{8}{h^2} \\sin^2\\left(\\frac{n \\pi}{2(n+1)}\\right)}{\\frac{8}{h^2} \\sin^2\\left(\\frac{\\pi}{2(n+1)}\\right)} = \\frac{\\sin^2\\left(\\frac{n \\pi}{2(n+1)}\\right)}{\\sin^2\\left(\\frac{\\pi}{2(n+1)}\\right)}.\n$$\n使用恒等式 $\\sin(\\frac{\\pi}{2} - x) = \\cos(x)$，我们有 $\\sin(\\frac{n \\pi}{2(n+1)}) = \\sin(\\frac{\\pi}{2} - \\frac{\\pi}{2(n+1)}) = \\cos(\\frac{\\pi}{2(n+1)})$。这给出了一个更简单的表达式：\n$$\n\\kappa_2(A) = \\frac{\\cos^2\\left(\\frac{\\pi}{2(n+1)}\\right)}{\\sin^2\\left(\\frac{\\pi}{2(n+1)}\\right)} = \\cot^2\\left(\\frac{\\pi}{2(n+1)}\\right).\n$$\n\n**4. 最大稳定时间步长 $\\Delta t_{\\max}$**\n\nODE 系统是 $u'(t) = -A u(t)$。应用显式前向欧拉方法得到以下迭代式：\n$$\nu_{m+1} = u_m + \\Delta t (-A u_m) = (I - \\Delta t A) u_m.\n$$\n为使此方法稳定，迭代矩阵 $G = I - \\Delta t A$ 的谱半径必须满足 $\\rho(G) \\le 1$。$G$ 的特征值为 $1 - \\Delta t \\lambda$，其中 $\\lambda$ 是 $A$ 的每个特征值。因此，稳定性条件为对所有 $j,k$ 都有 $|1 - \\Delta t \\lambda_{j,k}(A)| \\le 1$。\n这展开为 $-1 \\le 1 - \\Delta t \\lambda_{j,k}(A) \\le 1$。\n右侧不等式 $1 - \\Delta t \\lambda_{j,k}(A) \\le 1$ 意味着 $\\Delta t \\lambda_{j,k}(A) \\ge 0$，因为 $\\Delta t > 0$ 并且 $A$ 的所有特征值都是正的，所以这个条件总是成立的。\n左侧不等式 $-1 \\le 1 - \\Delta t \\lambda_{j,k}(A)$ 意味着 $\\Delta t \\lambda_{j,k}(A) \\le 2$，或 $\\Delta t \\le \\frac{2}{\\lambda_{j,k}(A)}$。\n为使所有特征值都满足这个条件，时间步长 $\\Delta t$ 必须受最严格情况的限制，这涉及到最大特征值 $\\lambda_{\\max}(A) = \\lVert A \\rVert_2$。\n$$\n\\Delta t \\le \\frac{2}{\\lambda_{\\max}(A)}.\n$$\n因此，最大稳定时间步长为：\n$$\n\\Delta t_{\\max} = \\frac{2}{\\lambda_{\\max}(A)} = \\frac{2}{\\lVert A \\rVert_2}.\n$$\n\n**5. 计算实现**\n\n程序将遍历给定的 $n$ 值。对于每个 $n$，它将计算 $h$，然后应用推导出的解析公式来计算 $\\lVert A \\rVert_2$、$\\kappa_2(A)$ 和 $\\Delta t_{\\max}$。结果将被格式化为六位有效数字，并组装成所需的最终输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs the matrix for the 2D Laplace operator, calculates its norm,\n    condition number, and the max stable timestep for an associated ODE system,\n    based on analytical formulas.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases_n = [1, 4, 8, 16, 32]\n\n    # A helper function to format a number to a specified number of significant figures.\n    # The '{:g}' format specifier in Python is suitable for this purpose.\n    def format_to_sig_figs(value, sig_figs):\n        return '{:.{p}g}'.format(value, p=sig_figs)\n\n    all_results = []\n    for n in test_cases_n:\n        # Mesh spacing h for an n x n grid of interior points on the unit square.\n        h = 1.0 / (n + 1)\n        pi = np.pi\n\n        # 1. Compute the spectral norm ||A||_2.\n        # This is equal to the maximum eigenvalue of A.\n        # norm_A = lambda_max(A) = (8/h^2) * sin^2(n*pi / (2*(n+1))).\n        # We can use the identity sin(pi/2 - x) = cos(x) to write\n        # sin(n*pi / (2*(n+1))) = sin(pi/2 - pi/(2*(n+1))) = cos(pi/(2*(n+1))).\n        arg_cos = pi / (2.0 * (n + 1))\n        norm_A = (8.0 / h**2) * (np.cos(arg_cos))**2\n\n        # 2. Compute the 2-norm condition number kappa_2(A).\n        # This is the ratio of the max to min eigenvalue.\n        # kappa_2(A) = cot^2(pi / (2*(n+1))).\n        arg_cot = pi / (2.0 * (n + 1))\n        # numpy does not have a cot function, but cot(x) = cos(x)/sin(x).\n        kappa_2_A = (np.cos(arg_cot) / np.sin(arg_cot))**2\n\n        # 3. Determine the largest stable time step dt_max for u'(t) = -A u(t).\n        # For the Forward Euler method, the stability condition is dt = 2/lambda_max(A).\n        # Therefore, dt_max = 2 / norm_A.\n        dt_max = 2.0 / norm_A\n\n        # Format results to six significant digits.\n        sig_figs = 6\n        rounded_norm = format_to_sig_figs(norm_A, sig_figs)\n        rounded_kappa = format_to_sig_figs(kappa_2_A, sig_figs)\n        rounded_dt = format_to_sig_figs(dt_max, sig_figs)\n\n        # Append the list of results for the current n.\n        all_results.append(f\"[{rounded_norm},{rounded_kappa},{rounded_dt}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3158860"}]}