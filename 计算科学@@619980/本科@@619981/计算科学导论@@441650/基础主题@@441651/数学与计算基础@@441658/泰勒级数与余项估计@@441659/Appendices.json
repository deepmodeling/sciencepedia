{"hands_on_practices": [{"introduction": "在科学与工程中，许多重要函数（如误差函数 $\\operatorname{erf}(x)$）无法用简单的初等函数表示。泰勒级数提供了一种强大的方法，用多项式来近似这些函数。但这引出了一个关键的实际问题：我们必须计算多少项才能保证达到预期的精度？本练习 [@problem_id:2442184] 将通过应用余项定理，确定在严格的误差容限下近似 $\\operatorname{erf}(x)$ 所需的最小项数，从而锻炼您解决这一核心问题的能力，这是数值计算中的一项基本功。", "problem": "在计算工程中，误差函数 (erf) 对实数输入定义为\n$$\\operatorname{erf}(x) = \\frac{2}{\\sqrt{\\pi}} \\int_{0}^{x} \\exp\\!\\left(-t^{2}\\right)\\, dt.$$\n对于 $\\operatorname{erf}(x)$ 的 Maclaurin 级数，考虑其截断\n$$S_{N}(x) = \\sum_{n=0}^{N} c_{n}\\, x^{2n+1},$$\n其中 $c_{n}$ 是从 $\\operatorname{erf}(x)$ 在 $x=0$ 处的 Maclaurin 展开式中获得的系数。确定最小的整数 $N$，使得在 $S_{N}(x)$ 处截断能保证在 $x=0.5$ 处的绝对近似误差满足\n$$\\left|\\operatorname{erf}(0.5) - S_{N}(0.5)\\right|  1.0 \\times 10^{-8}.$$\n最终答案仅提供整数 $N$。", "solution": "对问题陈述进行验证。\n\n**第1步：提取已知条件**\n- 误差函数定义为 $\\operatorname{erf}(x) = \\frac{2}{\\sqrt{\\pi}} \\int_{0}^{x} \\exp(-t^{2})\\, dt$。\n- 截断的 Maclaurin 级数为 $S_{N}(x) = \\sum_{n=0}^{N} c_{n}\\, x^{2n+1}$。\n- 求值点为 $x=0.5$。\n- 要求的绝对误差容差为 $|\\operatorname{erf}(0.5) - S_{N}(0.5)|  1.0 \\times 10^{-8}$。\n- 目标是找到满足此条件的最小整数 $N$。\n\n**第2步：使用提取的已知条件进行验证**\n该问题具有科学依据、良态（well-posed）且客观。\n- **科学依据**：误差函数、其级数展开以及截断误差分析是数学物理、数值分析和计算工程中的标准课题。所有定义都是标准且正确的。\n- **良态性**：该问题要求找到满足特定不等式的最小整数 $N$。该级数的性质确保了这样的整数存在且唯一。\n- **客观性**：该问题使用精确的数学语言陈述，没有歧义或主观内容。\n\n**第3步：结论与行动**\n该问题被判定为有效。将制定一个完整的解法。\n\n求解过程首先要确定 $\\operatorname{erf}(x)$ 的 Maclaurin 级数。该过程从已知的指数函数的 Maclaurin 级数开始：\n$$ \\exp(u) = \\sum_{k=0}^{\\infty} \\frac{u^{k}}{k!} $$\n通过代入 $u = -t^2$，我们得到被积函数的级数：\n$$ \\exp(-t^2) = \\sum_{k=0}^{\\infty} \\frac{(-t^2)^{k}}{k!} = \\sum_{k=0}^{\\infty} \\frac{(-1)^k t^{2k}}{k!} $$\n该级数具有无穷收敛半径，因此允许在任何有限区间上逐项积分。从 $t=0$ 积分到 $t=x$：\n$$ \\int_{0}^{x} \\exp(-t^{2})\\, dt = \\int_{0}^{x} \\left( \\sum_{k=0}^{\\infty} \\frac{(-1)^k t^{2k}}{k!} \\right) dt = \\sum_{k=0}^{\\infty} \\frac{(-1)^k}{k!} \\int_{0}^{x} t^{2k}\\, dt $$\n$$ = \\sum_{k=0}^{\\infty} \\frac{(-1)^k}{k!} \\left[ \\frac{t^{2k+1}}{2k+1} \\right]_{0}^{x} = \\sum_{k=0}^{\\infty} \\frac{(-1)^k x^{2k+1}}{k!(2k+1)} $$\n乘以 $\\operatorname{erf}(x)$ 定义中的常数因子 $\\frac{2}{\\sqrt{\\pi}}$，得到其 Maclaurin 级数。为了与问题的符号匹配，我们使用索引 $n$ 代替 $k$：\n$$ \\operatorname{erf}(x) = \\frac{2}{\\sqrt{\\pi}} \\sum_{n=0}^{\\infty} \\frac{(-1)^n x^{2n+1}}{n!(2n+1)} $$\n截断级数由 $S_N(x) = \\sum_{n=0}^{N} c_n x^{2n+1}$ 给出，其中系数为 $c_n = \\frac{2}{\\sqrt{\\pi}} \\frac{(-1)^n}{n!(2n+1)}$。近似误差是余项，$R_N(x) = \\operatorname{erf}(x) - S_N(x)$。\n$$ R_N(x) = \\frac{2}{\\sqrt{\\pi}} \\sum_{n=N+1}^{\\infty} \\frac{(-1)^n x^{2n+1}}{n!(2n+1)} $$\n对于任何固定的 $x  0$，$\\operatorname{erf}(x)$ 的 Maclaurin 级数是一个交错级数。为了应用交错级数余项定理，我们必须验证当 $x=0.5$ 时，各项的绝对值是单调递减趋于零的。令 $a_n = \\frac{2}{\\sqrt{\\pi}} \\frac{x^{2n+1}}{n!(2n+1)}$。连续项的绝对值之比为：\n$$ \\frac{a_{n+1}}{a_n} = \\frac{x^{2(n+1)+1}}{(n+1)!(2(n+1)+1)} \\cdot \\frac{n!(2n+1)}{x^{2n+1}} = \\frac{x^2 (2n+1)}{(n+1)(2n+3)} $$\n当 $x=0.5$ 时，该比率变为：\n$$ \\frac{(0.5)^2 (2n+1)}{(n+1)(2n+3)} = \\frac{0.25(2n+1)}{2n^2+5n+3} $$\n对于所有 $n \\ge 0$，分母 $2n^2+5n+3$ 严格大于分子 $0.5n+0.25$。因此，该比率始终小于 $1$，证实了各项的绝对值是单调递减的。由于分母中的阶乘，当 $n \\to \\infty$ 时，各项的极限为零。\n\n交错级数余项定理指出，绝对误差 $|R_N(x)|$ 小于第一项被舍弃项的绝对值，该项对应于 $n=N+1$。\n$$ |\\operatorname{erf}(0.5) - S_N(0.5)| = |R_N(0.5)| \\le \\left| c_{N+1} (0.5)^{2(N+1)+1} \\right| $$\n$$ |R_N(0.5)| \\le \\frac{2}{\\sqrt{\\pi}} \\frac{(0.5)^{2N+3}}{(N+1)!(2N+3)} $$\n我们要求这个误差界小于 $1.0 \\times 10^{-8}$：\n$$ \\frac{2}{\\sqrt{\\pi}} \\frac{1}{2^{2N+3}(N+1)!(2N+3)}  10^{-8} $$\n这可以简化为：\n$$ \\frac{1}{\\sqrt{\\pi} \\cdot 2^{2N+2}(N+1)!(2N+3)}  10^{-8} $$\n我们必须找到满足这个不等式的最小整数 $N$。我们测试 $N$ 的值。\n对于 $N=5$：\n误差界为 $\\frac{1}{\\sqrt{\\pi} \\cdot 2^{12} \\cdot 6! \\cdot (13)} = \\frac{1}{\\sqrt{\\pi} \\cdot 4096 \\cdot 720 \\cdot 13} = \\frac{1}{\\sqrt{\\pi} \\cdot 38338560}$。\n使用 $\\sqrt{\\pi} \\approx 1.77245$，分母约等于 $1.77245 \\times 38338560 \\approx 6.795 \\times 10^7$。\n误差界约等于 $\\frac{1}{6.795 \\times 10^7} \\approx 1.47 \\times 10^{-8}$。\n由于 $1.47 \\times 10^{-8}  1.0 \\times 10^{-8}$，$N=5$ 是不够的。\n\n对于 $N=6$：\n误差界为 $\\frac{1}{\\sqrt{\\pi} \\cdot 2^{14} \\cdot 7! \\cdot (15)} = \\frac{1}{\\sqrt{\\pi} \\cdot 16384 \\cdot 5040 \\cdot 15} = \\frac{1}{\\sqrt{\\pi} \\cdot 1238630400}$。\n使用 $\\sqrt{\\pi} \\approx 1.77245$，分母约等于 $1.77245 \\times 1238630400 \\approx 2.196 \\times 10^9$。\n误差界约等于 $\\frac{1}{2.196 \\times 10^9} \\approx 4.55 \\times 10^{-10}$。\n由于 $4.55 \\times 10^{-10}  1.0 \\times 10^{-8}$，$N=6$ 是足够的。\n\n因此，保证所需精度的最小整数 $N$ 值为 $6$。", "answer": "$$ \\boxed{6} $$", "id": "2442184"}, {"introduction": "泰勒多项式是一种“局部”近似，意味着其精度会随着我们远离展开中心而降低。这就提出了一个策略性问题：我们能否通过选择一个更佳的展开中心来提升近似效果？本练习 [@problem_id:3200380] 使用我们熟悉的 $\\sin(x)$ 函数，生动地揭示了这一原理。通过对比一个远离其中心的糟糕近似与另一个靠近更合适中心的高效近似，您将体会到如何利用函数的内在属性（如周期性）来构建高效而精确的计算模型。", "problem": "在计算实践中，人们经常在某个关心点附近用一个低阶泰勒多项式来代替一个光滑函数，以获得一个带有可量化余项（误差）的快速局部近似。考虑函数 $f(x) = \\sin(x)$ 和两个中心点：$a = \\pi$ 和 $a = 0$。令 $p^{(a)}_n(x)$ 表示 $f$ 在 $x=a$ 处的 $n$ 阶泰勒多项式。定义区间 $I = [\\pi - 0.1, \\,\\pi + 0.1]$。\n\n仅使用泰勒多项式的定义、带有拉格朗日余项的泰勒定理、正弦函数的周期性和对称性以及导数的界，判断下列哪些陈述是正确的。选择所有适用的选项。\n\nA. 对于所有 $x \\in I$，在 $a=\\pi$ 处的一阶泰勒近似满足不等式 $\\lvert \\sin(x) - p^{(\\pi)}_1(x) \\rvert \\le \\dfrac{(0.1)^2}{2}$。\n\nB. 对于所有 $x \\in I$，在 $a=0$ 处的一阶泰勒近似满足不等式 $\\lvert \\sin(x) - p^{(0)}_1(x) \\rvert \\le \\dfrac{(0.1)^2}{2}$。\n\nC. 记 $x = \\pi + h$，其中 $\\lvert h \\rvert \\le 0.1$，恒等式 $\\sin(x) = -\\sin(h)$ 意味着这两个线性化在平移后是一致的，即 $p^{(\\pi)}_1(\\pi + h) = -\\,p^{(0)}_1(h)$。\n\nD. 在同样的变量代换 $x=\\pi+h$下，对于任意固定的整数 $n \\ge 0$ 和足够小的 $\\lvert h \\rvert$，$\\sin(x)$ 在 $a=\\pi$ 处关于 $x=\\pi+h$ 的 n 阶泰勒近似的余项，与 $-\\sin(h)$ 在 $h=0$ 处关于 $h$ 的 n 阶泰勒近似的余项具有相同的绝对值，因此为 $\\sin$ 的麦克劳林余项得到的任何绝对值界都直接适用于在 $a=\\pi$ 处的展开。\n\nE. 在区间 $I$ 上，在 $a=\\pi$ 处的一阶泰勒近似的最大绝对误差至多为 $0.005$，而在 $a=0$ 处的一阶泰勒近似的最大绝对误差超过 $3.0$。\n\nF. 因为 $\\sin(\\pi) = 0$，所以常数多项式 $p(x) \\equiv 0$ 是在 $a=\\pi$ 处泰勒多项式意义下的最佳线性化。\n\nG. 对于 $a \\in \\{0,\\pi\\}$，一阶泰勒近似误差的真实主阶行为是关于偏离 $a$ 的位移的三次函数；也就是说，记 $h=x-a$，对于小的 $h$，误差表现为 $C\\,h^3$ 的形式（其中 $C$ 是某个非零常数），尽管基于二阶导数的一般余项界只给出了一个二次上界。", "solution": "问题陈述已经过验证，并且在科学上是合理的、适定的、客观的，并包含评估给定陈述所需的所有必要信息。\n\n所考虑的函数是 $f(x) = \\sin(x)$。它的导数是 $f'(x) = \\cos(x)$，$f''(x) = -\\sin(x)$，$f'''(x) = -\\cos(x)$，依此类推。一个关键性质是，对于任意整数 $k \\ge 0$，其 $k$ 阶导数 $f^{(k)}(x)$ 的绝对值以 1 为界，即对于所有 $x \\in \\mathbb{R}$ 都有 $\\lvert f^{(k)}(x) \\rvert \\le 1$。\n\n函数 $f$ 在中心点 $x=a$ 处的 $n$ 阶泰勒多项式由 $p_n^{(a)}(x) = \\sum_{k=0}^n \\dfrac{f^{(k)}(a)}{k!}(x-a)^k$ 给出。余项，或误差，是 $R_n^{(a)}(x) = f(x) - p_n^{(a)}(x)$。带有拉格朗日余项的泰勒定理表明，$R_n^{(a)}(x) = \\dfrac{f^{(n+1)}(c)}{(n+1)!}(x-a)^{n+1}$，其中 $c$ 是介于 $a$ 和 $x$ 之间的某个值。这给出了误差绝对值的一个界：$\\lvert R_n^{(a)}(x) \\rvert \\le \\dfrac{M_{n+1}}{(n+1)!}\\lvert x-a \\rvert^{n+1}$，其中 $M_{n+1}$ 是当 $t$ 介于 $a$ 和 $x$ 之间时 $\\lvert f^{(n+1)}(t) \\rvert$ 的一个上界。对于 $f(x) = \\sin(x)$，我们总可以对任意 $k$ 使用 $M_{k}=1$。\n\n关心的区间是 $I = [\\pi - 0.1, \\,\\pi + 0.1]$。对于任意 $x \\in I$，与 $a=\\pi$ 的位移是 $\\lvert x-\\pi \\rvert \\le 0.1$。\n\n**A. 对于所有 $x \\in I$，在 $a=\\pi$ 处的一阶泰勒近似满足不等式 $\\lvert \\sin(x) - p^{(\\pi)}_1(x) \\rvert \\le \\dfrac{(0.1)^2}{2}$。**\n\n在 $a=\\pi$ 处的一阶泰勒近似是 $p^{(\\pi)}_1(x) = f(\\pi) + f'(\\pi)(x-\\pi)$。\n我们有 $f(\\pi) = \\sin(\\pi) = 0$ 和 $f'(\\pi) = \\cos(\\pi) = -1$。\n因此，$p^{(\\pi)}_1(x) = 0 + (-1)(x-\\pi) = \\pi - x$。\n误差是余项 $R_1^{(\\pi)}(x) = \\sin(x) - p^{(\\pi)}_1(x)$。\n使用 $n=1$ 和 $a=\\pi$ 的拉格朗日形式余项：\n$$R_1^{(\\pi)}(x) = \\dfrac{f''(c)}{2!}(x-\\pi)^2 = \\dfrac{-\\sin(c)}{2}(x-\\pi)^2$$\n其中 $c$ 介于 $\\pi$ 和 $x$ 之间。\n误差的绝对值为 $\\lvert R_1^{(\\pi)}(x) \\rvert = \\left\\lvert \\dfrac{-\\sin(c)}{2}(x-\\pi)^2 \\right\\rvert = \\dfrac{\\lvert \\sin(c) \\rvert}{2}(x-\\pi)^2$。\n我们可以使用一般界 $\\lvert \\sin(c) \\rvert \\le 1$。\n对于 $x \\in I$，我们有 $\\lvert x-\\pi \\rvert \\le 0.1$。\n代入这些界，我们得到：\n$$\\lvert \\sin(x) - p^{(\\pi)}_1(x) \\rvert \\le \\dfrac{1}{2}(\\lvert x-\\pi \\rvert)^2 \\le \\dfrac{1}{2}(0.1)^2$$\n该陈述是泰勒余项定理的直接应用。\n\n结论：**正确**。\n\n**B. 对于所有 $x \\in I$，在 $a=0$ 处的一阶泰勒近似满足不等式 $\\lvert \\sin(x) - p^{(0)}_1(x) \\rvert \\le \\dfrac{(0.1)^2}{2}$。**\n\n在 $a=0$ 处的一阶泰勒近似（麦克劳林多项式）是 $p^{(0)}_1(x) = f(0) + f'(0)(x-0)$。\n我们有 $f(0)=\\sin(0)=0$ 和 $f'(0)=\\cos(0)=1$。所以，$p^{(0)}_1(x) = x$。\n误差是 $\\lvert \\sin(x) - x \\rvert$。$x$ 的区间是 $I = [\\pi-0.1, \\pi+0.1]$。\n所提出界中的表达式 $\\dfrac{(0.1)^2}{2}$ 暗示了余项定理的应用，其中到中心的距离至多为 0.1。展开中心是 $a=0$。对于 $x \\in I$，到中心的距离是 $\\lvert x-a \\rvert = \\lvert x-0 \\rvert = x$，其值约等于 $\\pi \\approx 3.14159$。该值远大于 0.1。\n让我们计算在 $x=\\pi \\in I$ 处的误差。\n误差 = $\\lvert \\sin(\\pi) - \\pi \\rvert = \\lvert 0 - \\pi \\rvert = \\pi \\approx 3.14159$。\n建议的界是 $\\dfrac{(0.1)^2}{2} = \\dfrac{0.01}{2} = 0.005$。\n显然，$\\pi  0.005$。该陈述是错误的。对于接近 $\\pi$ 的 $x$，近似 $p^{(0)}_1(x)=x$ 非常差。\n\n结论：**不正确**。\n\n**C. 记 $x = \\pi + h$，其中 $\\lvert h \\rvert \\le 0.1$，恒等式 $\\sin(x) = -\\sin(h)$ 意味着这两个线性化在平移后是一致的，即 $p^{(\\pi)}_1(\\pi + h) = -\\,p^{(0)}_1(h)$。**\n\n让我们计算所提议等式的两边。\n左边：根据分析 A，在 $a=\\pi$ 处的线性化是 $p^{(\\pi)}_1(x) = \\pi - x$。\n代入 $x = \\pi + h$，我们得到 $p^{(\\pi)}_1(\\pi+h) = \\pi - (\\pi+h) = -h$。\n右边：首先，我们需要函数 $f(y)=\\sin(y)$ 在 $y=0$ 处的线性化。如分析 B 中所见，这是 $p^{(0)}_1(y)=y$。\n表达式 $-p^{(0)}_1(h)$ 因此是 $-h$。\n由于左边和右边都等于 $-h$，等式 $p^{(\\pi)}_1(\\pi + h) = -\\,p^{(0)}_1(h)$ 对任意 $h$ 都成立。\n\n结论：**正确**。\n\n**D. 在同样的变量代换 $x=\\pi+h$下，对于任意固定的整数 $n \\ge 0$ 和足够小的 $\\lvert h \\rvert$，$\\sin(x)$ 在 $a=\\pi$ 处关于 $x=\\pi+h$ 的 n 阶泰勒近似的余项，与 $-\\sin(h)$ 在 $h=0$ 处关于 $h$ 的 n 阶泰勒近似的余项具有相同的绝对值，因此为 $\\sin$ 的麦克劳林余项得到的任何绝对值界都直接适用于在 $a=\\pi$ 处的展开。**\n\n令 $g(x) = \\sin(x)$ 和 $f(h) = -\\sin(h)$。我们比较 $g(x)$ 在 $a=\\pi$ 处的泰勒展开和 $f(h)$ 在 $a=0$ 处的泰勒展开。\n$g(x)$ 在 $x=\\pi$ 处的泰勒系数由 $g^{(k)}(\\pi)$ 给出。\n$f(h)$ 在 $h=0$ 处的泰勒系数由 $f^{(k)}(0)$ 给出。\n让我们比较这些导数。使用链式法则和三角恒等式：\n$g^{(k)}(x) = \\dfrac{d^k}{dx^k}\\sin(x) = \\sin(x + k\\pi/2)$。在 $x=\\pi$ 处，$g^{(k)}(\\pi) = \\sin(\\pi + k\\pi/2) = \\sin(\\pi)\\cos(k\\pi/2) + \\cos(\\pi)\\sin(k\\pi/2) = -\\sin(k\\pi/2)$。\n$f^{(k)}(h) = \\dfrac{d^k}{dh^k}(-\\sin(h)) = -\\sin(h + k\\pi/2)$。在 $h=0$ 处，$f^{(k)}(0) = -\\sin(k\\pi/2)$。\n因此，对于所有整数 $k \\ge 0$，$g^{(k)}(\\pi) = f^{(k)}(0)$。\n$g(x)$ 在 $a=\\pi$ 处的泰勒多项式，在 $x=\\pi+h$ 处求值，为 $p_{g,n}^{(\\pi)}(\\pi+h) = \\sum_{k=0}^n \\frac{g^{(k)}(\\pi)}{k!} h^k$。\n$f(h)$ 在 $a=0$ 处的泰勒多项式，在 $h$ 处求值，为 $p_{f,n}^{(0)}(h) = \\sum_{k=0}^n \\frac{f^{(k)}(0)}{k!} h^k$。\n由于系数相同，多项式也相同：$p_{g,n}^{(\\pi)}(\\pi+h) = p_{f,n}^{(0)}(h)$。\n现在我们来考察余项。\n$g(x)$ 的余项是 $R_{g,n}^{(\\pi)}(\\pi+h) = g(\\pi+h) - p_{g,n}^{(\\pi)}(\\pi+h) = \\sin(\\pi+h) - p_{g,n}^{(\\pi)}(\\pi+h)$。使用恒等式 $\\sin(\\pi+h)=-\\sin(h)$，这变为 $-\\sin(h) - p_{g,n}^{(\\pi)}(\\pi+h)$。\n$f(h)$ 的余项是 $R_{f,n}^{(0)}(h) = f(h) - p_{f,n}^{(0)}(h) = -\\sin(h) - p_{f,n}^{(0)}(h)$。\n由于多项式相等，余项也相等：$R_{g,n}^{(\\pi)}(\\pi+h) = R_{f,n}^{(0)}(h)$。\n因此，它们的绝对值相等：$\\lvert R_{g,n}^{(\\pi)}(\\pi+h) \\rvert = \\lvert R_{f,n}^{(0)}(h) \\rvert$。\n$f(h)=-\\sin(h)$ 的余项就是 $\\sin(h)$ 余项的负数，所以它们的绝对值相同。这意味着 $\\sin(h)$ 的麦克劳林余项的界也是 $\\sin(x)$ 在 $\\pi$ 附近展开的余项的界。\n\n结论：**正确**。\n\n**E. 在区间 $I$ 上，在 $a=\\pi$ 处的一阶泰勒近似的最大绝对误差至多为 $0.005$，而在 $a=0$ 处的一阶泰勒近似的最大绝对误差超过 $3.0$。**\n\n第一部分：$a=\\pi$ 的最大误差。\n根据分析 A，对于任何 $x \\in I$，误差满足 $\\lvert \\sin(x) - p^{(\\pi)}_1(x) \\rvert \\le \\dfrac{1}{2}(0.1)^2 = 0.005$。因此，最大绝对误差至多为 $0.005$。这部分是正确的。\n\n第二部分：$a=0$ 的最大误差。\n在 $x \\in I = [\\pi-0.1, \\pi+0.1]$ 上，误差是 $\\lvert \\sin(x) - p^{(0)}_1(x) \\rvert = \\lvert \\sin(x) - x \\rvert$。由于在此区间内 $x0$，我们有 $x  \\sin(x)$，所以误差是 $x - \\sin(x)$。\n令 $E(x) = x-\\sin(x)$。其导数为 $E'(x) = 1-\\cos(x)$。对于 $x \\in I$，$x$ 接近 $\\pi$，所以 $\\cos(x)$ 接近 $-1$。因此 $E'(x) = 1-\\cos(x)  0$。误差函数 $E(x)$ 在 $I$ 上是严格递增的。\n最大误差将出现在区间的右端点，$x = \\pi+0.1$。\n最大误差 = $(\\pi+0.1) - \\sin(\\pi+0.1) = \\pi + 0.1 - (-\\sin(0.1)) = \\pi + 0.1 + \\sin(0.1)$。\n使用近似值 $\\pi \\approx 3.14159$ 和 $\\sin(0.1) \\approx 0.09983$：\n最大误差 $\\approx 3.14159 + 0.1 + 0.09983 = 3.34142$。\n由于 $3.34142  3.0$，最大绝对误差确实超过 3.0。该陈述的两个部分都为真。\n\n结论：**正确**。\n\n**F. 因为 $\\sin(\\pi) = 0$，所以常数多项式 $p(x) \\equiv 0$ 是在 $a=\\pi$ 处泰勒多项式意义下的最佳线性化。**\n\n在泰勒级数的语境中，“最佳线性化”指的是一阶泰勒多项式 $p_1^{(a)}(x)$。\n根据分析 A，在 $a=\\pi$ 处的线性化是 $p_1^{(\\pi)}(x) = \\pi - x$。\n这是一个非常数多项式。\n多项式 $p(x) \\equiv 0$ 是零阶泰勒多项式，$p_0^{(\\pi)}(x) = \\sin(\\pi) = 0$。这是在 $x=\\pi$ 附近的最佳*常数*近似，但“线性化”意味着一阶多项式，它要考虑函数的斜率。$\\sin(x)$ 在 $x=\\pi$ 处的斜率是 $\\cos(\\pi)=-1$，非零。因此，最佳线性近似不是一个常数函数。\n\n结论：**不正确**。\n\n**G. 对于 $a \\in \\{0,\\pi\\}$，一阶泰勒近似误差的真实主阶行为是关于偏离 $a$ 的位移的三次函数；也就是说，记 $h=x-a$，对于小的 $h$，误差表现为 $C\\,h^3$ 的形式（其中 $C$ 是某个非零常数），尽管基于二阶导数的一般余项界只给出了一个二次上界。**\n\n一阶泰勒近似的误差是 $R_1^{(a)}(x) = f(x) - p_1^{(a)}(x)$。\n泰勒级数可以扩展到更高阶：$f(x) = p_1^{(a)}(x) + \\dfrac{f''(a)}{2!}(x-a)^2 + \\dfrac{f'''(a)}{3!}(x-a)^3 + \\dots$\n所以，误差是 $R_1^{(a)}(x) = \\dfrac{f''(a)}{2!}(x-a)^2 + \\dfrac{f'''(a)}{3!}(x-a)^3 + \\dots$\n\n让我们检查当 $a \\in \\{0, \\pi\\}$ 时 $f''(a)$ 的值。二阶导数是 $f''(x) = -\\sin(x)$。\n当 $a=0$ 时，$f''(0) = -\\sin(0) = 0$。\n当 $a=\\pi$ 时，$f''(\\pi) = -\\sin(\\pi) = 0$。\n在这两种情况下，$(x-a)^2$ 项的系数都是零。\n这意味着误差的主项是 $(x-a)^3$ 项。\n$R_1^{(a)}(x) = \\dfrac{f'''(a)}{3!}(x-a)^3 + \\dfrac{f^{(4)}(a)}{4!}(x-a)^4 + \\dots$\n让我们检查三阶导数系数。$f'''(x) = -\\cos(x)$。\n当 $a=0$ 时，$f'''(0) = -\\cos(0) = -1 \\ne 0$。\n当 $a=\\pi$ 时，$f'''(\\pi) = -\\cos(\\pi) = -(-1) = 1 \\ne 0$。\n所以对于小的 $h=x-a$，误差的行为如同 $R_1^{(a)}(a+h) \\approx \\dfrac{f'''(a)}{6}h^3$。\n当 $a=0$ 时，误差约为 $-\\frac{1}{6}h^3$。当 $a=\\pi$ 时，误差约为 $\\frac{1}{6}h^3$。\n在这两种情况下，主阶行为都是三次的，带有一个非零常数 $C$。\n该陈述也正确地指出，一个一般的余项界 $\\lvert R_1(x) \\rvert \\le \\frac{M_2}{2}(x-a)^2$ (其中 $M_2$ 是 $\\lvert f''(c)\\rvert$ 的一个界) 暗示了一个二次上界，这是正确的，但不如在这种 $f''(a)=0$ 的特殊情况下实际的三次行为那么精确。\n\n结论：**正确**。", "answer": "$$\\boxed{ACDEG}$$", "id": "3200380"}, {"introduction": "现在，我们将综合运用所学知识，应对科学计算中的一个真实挑战：创建一个能够为任意输入值计算 $\\sin(x)$ 的稳定而精确的函数。您将会发现，对于较大的输入值，由于数值不稳定性——这是计算中常见的陷阱——直接应用麦克劳林级数会如何灾难性地失败。这个总结性练习 [@problem_id:2442233] 将引导您实现一个稳健的解决方案，它巧妙地运用了“参数约减”技术（该技术正是我们上一个练习所学经验的体现），并结合对小数值进行严格控制的泰勒近似。这项实践完美展示了计算科学所要求的数学理论与编程智慧的融合。", "problem": "你需要编写一个完整、可运行的程序，使用麦克劳林级数计算正弦函数，并严格控制截断误差，同时分析该方法对于大自变量的数值稳定性。计算过程应完全使用弧度制。\n\n从以下基本依据出发：\n- 解析函数的麦克劳林级数定义和拉格朗日余项形式。对于一个充分可微的函数 $f$，其在 $x=0$ 处的 $m$ 次麦克劳林多项式的余项为 $R_{m}(x) = \\dfrac{f^{(m+1)}(\\xi)}{(m+1)!} x^{m+1}$，其中 $\\xi$ 介于 $0$ 和 $x$ 之间。\n- 三角函数的周期性和奇偶性恒等式：对于任意整数 $k$，有 $ \\sin(x + 2\\pi k) = \\sin(x)$；以及和角与象限对称性，这些性质可以将 $ \\sin(x)$ 与一个通过减去 $ \\dfrac{\\pi}{2}$ 整数倍约简后的小余量 $r$ 的 $ \\sin(r)$ 或 $ \\cos(r)$ 相关联。\n\n你的任务：\n1) 根据麦克劳林定义和拉格朗日余项公式，推导出一个停止准则，用于截断 $ \\sin(x)$ 和 $ \\cos(x)$ 的麦克劳林级数，以达到用户指定的绝对误差容限 $ \\varepsilon  0$。特别地，利用 $ \\sin(x)$ 或 $ \\cos(x)$ 的任意阶导数的绝对值在实数轴上至多为 $1$ 这一性质，来证明形如\n$$\n\\left| R_{2N+1}^{\\sin}(x) \\right| \\le \\frac{|x|^{2N+3}}{(2N+3)!}, \n\\qquad\n\\left| R_{2N}^{\\cos}(x) \\right| \\le \\frac{|x|^{2N+2}}{(2N+2)!},\n$$\n的界。然后，设计一个过程，对于给定的一个小自变量 $z$，找到最小的整数 $N \\ge 0$，使得相应的余项界小于或等于 $ \\varepsilon$。\n\n2) 设计并实现一个自变量约简策略，对于任意实数 $x$，使用 $ \\dfrac{\\pi}{2}$ 的整数倍将 $x$ 映射到区间 $[-\\dfrac{\\pi}{4}, \\dfrac{\\pi}{4}]$ 内的一个余量 $r$ 和一个象限索引 $q \\in \\{0,1,2,3\\}$，使得\n$$\n\\sin(x) = \n\\begin{cases}\n\\phantom{-}\\sin(r),  q \\equiv 0 \\ (\\text{mod } 4),\\\\\n\\phantom{-}\\cos(r),  q \\equiv 1 \\ (\\text{mod } 4),\\\\\n-\\sin(r),  q \\equiv 2 \\ (\\text{mod } 4),\\\\\n-\\cos(r),  q \\equiv 3 \\ (\\text{mod } 4).\n\\end{cases}\n$$\n利用此映射关系选择在小余量 $r$ 处计算哪个麦克劳林级数（正弦或余弦）。使用任务1中的停止准则，确定保证截断误差不超过 $ \\varepsilon$ 所需的最小级数项数。\n\n3) 从第一性原理出发，解释为什么对于大的 $|x|$ 直接进行麦克劳林求值是数值不稳定的：分析在阶乘增长占主导地位之前，中间项的量级如何变化，以及有限精度算术如何加剧相消问题。然后，将其与自变量约简策略的稳定性进行对比，并解释其局限性，即对于极大的 $|x|$，由于尾数位的限制，浮点数约简过程 $x \\mapsto r$ 本身可能损失精度。\n\n4) 为一个输入测试套件实现以下程序化输出。对于每个测试用例参数对 $(x, \\varepsilon)$：\n- 使用你的自变量约减麦克劳林方法计算 $s_{\\text{approx}}$。\n- 计算一个布尔值 $b_{\\text{ok}}$，当且仅当 $|s_{\\text{approx}} - \\sin(x)| \\le \\varepsilon$ 时为真，其中右侧的 $ \\sin(x)$ 使用高质量的库函数作为参考值进行计算。\n- 报告为所选级数实际求和的最小非零麦克劳林项数，记为 $T$（对于 $ \\sin$，这是对应于次数 $1,3,\\dots,2N+1$ 的 $T = N+1$ 项；对于 $ \\cos$，这是对应于次数 $0,2,\\dots,2N$ 的 $T = N+1$ 项）。\n- 通过检查在余项界降至 $ \\varepsilon$ 以下之前，是否必须超过 $T_{\\max} = 1000$ 个非零项的上限，或者中间余项是否溢出为非有限值，来评估在相同容限下一个朴素的、未经约简的 $ \\sin(x)$ 麦克劳林级数是否实际上不可用。如果不可用，则将布尔值 $b_{\\text{naive\\_impractical}}$ 记录为真，否则为假。\n\n角度单位：弧度。没有物理单位。所有百分比（若有）必须表示为小数。\n\n测试套件：\n- 案例 1：$(x, \\varepsilon) = (100.0, 10^{-12})$。\n- 案例 2：$(x, \\varepsilon) = (10^{6} + 0.1, 10^{-12})$。\n- 案例 3：$(x, \\varepsilon) = (10^{16} + 0.1, 10^{-12})$。\n- 案例 4：$(x, \\varepsilon) = \\left(\\dfrac{\\pi}{2} + 10^{-8}, 10^{-15}\\right)$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于上述顺序中的第 $k$ 个测试用例，输出三元组 $[b_{\\text{ok}}, T, b_{\\text{naive\\_impractical}}]$，并将这些三元组按测试用例的顺序展平为单个列表。例如，最后一行应如下所示\n$[b_{\\text{ok},1}, T_{1}, b_{\\text{naive\\_impractical},1}, b_{\\text{ok},2}, T_{2}, b_{\\text{naive\\_impractical},2}, b_{\\text{ok},3}, T_{3}, b_{\\text{naive\\_impractical},3}, b_{\\text{ok},4}, T_{4}, b_{\\text{naive\\_impractical},4}]$。", "solution": "所述问题定义明确、内部一致，并基于数值分析和微积分的基本原理。它既不模棱两可，也非科学上不合理。因此，我们将按要求进行严格的推导和实现。\n\n该任务是实现一种数值稳定的方法，使用麦克劳林级数展开来计算正弦函数 $\\sin(x)$，并将其性能与朴素的直接求值方法进行分析。解决方案分为三个主要部分：级数截断准则的推导、自变量约简策略的制定，以及数值稳定性的分析。\n\n**1. 截断准则的推导**\n\n一个解析函数 $f(x)$ 在 $x=0$ 附近展开的麦克劳林级数由 $f(x) = \\sum_{k=0}^{\\infty} \\frac{f^{(k)}(0)}{k!} x^k$ 给出。当这个级数在 $m$ 次项之后被截断时，结果是麦克劳林多项式 $P_m(x)$，误差是余项 $R_m(x)$。根据拉格朗日余项形式，$R_m(x) = \\frac{f^{(m+1)}(\\xi)}{(m+1)!} x^{m+1}$，其中 $\\xi$ 介于 $0$ 和 $x$ 之间。\n\n对于 $f(x) = \\sin(x)$，其导数是周期性的：$\\sin'(x) = \\cos(x)$，$\\sin''(x) = -\\sin(x)$，以此类推。关键的是，对于任意整数 $k \\ge 0$，其 $k$ 阶导数满足 $|f^{(k)}(x)| \\le 1$ 对所有实数 $x$ 成立。$\\sin(x)$ 的麦克劳林级数只包含 $x$ 的奇次幂：\n$$\n\\sin(x) = \\sum_{k=0}^{N} \\frac{(-1)^k}{(2k+1)!} x^{2k+1} + R_{2N+1}(x)\n$$\n这里，我们在对应于 $k=N$ 的项之后截断了级数，该项的次数为 $2N+1$。其多项式部分 $P_{2N+1}(x)$ 与 $P_{2N+2}(x)$ 相同，因为 $x^{2N+2}$ 的系数为零。因此，余项为 $R_{2N+2}(x)$，由下式给出：\n$$\nR_{2N+2}(x) = \\frac{f^{(2N+3)}(\\xi)}{(2N+3)!} x^{2N+3}\n$$\n其中 $f^{(2N+3)}(x)$ 是 $\\pm\\sin(x)$ 或 $\\pm\\cos(x)$。利用界 $|f^{(2N+3)}(\\xi)| \\le 1$，我们建立了在 $2N+1$ 次截断的正弦级数的误差界：\n$$\n\\left| R_{2N+1}^{\\sin}(x) \\right| = \\left| R_{2N+2}^{\\sin}(x) \\right| \\le \\frac{|x|^{2N+3}}{(2N+3)!}\n$$\n这证实了问题陈述中给出的不等式。\n\n对于 $f(x) = \\cos(x)$，其麦克劳林级数只包含 $x$ 的偶次幂：\n$$\n\\cos(x) = \\sum_{k=0}^{N} \\frac{(-1)^k}{(2k)!} x^{2k} + R_{2N}(x)\n$$\n多项式 $P_{2N}(x)$ 与 $P_{2N+1}(x)$ 相同。余项为 $R_{2N+1}(x)$：\n$$\nR_{2N+1}(x) = \\frac{f^{(2N+2)}(\\xi)}{(2N+2)!} x^{2N+2}\n$$\n同样，利用界 $|f^{(2N+2)}(\\xi)| \\le 1$，我们得到了在 $2N$ 次截断的余弦级数的误差界：\n$$\n\\left| R_{2N}^{\\cos}(x) \\right| = \\left| R_{2N+1}^{\\cos}(x) \\right| \\le \\frac{|x|^{2N+2}}{(2N+2)!}\n$$\n这也证实了问题的表述。\n\n为了满足给定的绝对误差容限 $\\varepsilon  0$，对于一个小自变量 $z$，我们必须找到最小的非负整数 $N$，使得误差界不超过 $\\varepsilon$。\n对于 $\\sin(z)$，我们必须找到最小的 $N \\ge 0$ 使得 $\\frac{|z|^{2N+3}}{(2N+3)!} \\le \\varepsilon$。\n对于 $\\cos(z)$，我们必须找到最小的 $N \\ge 0$ 使得 $\\frac{|z|^{2N+2}}{(2N+2)!} \\le \\varepsilon$。\n这需要一个迭代搜索，从 $N=0$ 开始，递增 $N$ 直到条件满足。需要求和的非零项数即为 $T = N+1$。\n\n**2. 自变量约简策略**\n\n对于大的 $|x|$，直接计算麦克劳林级数是低效且数值不稳定的。一种标准且稳健的技术是自变量约简，它利用了三角函数的周期性。任何实数 $x$ 都可以表示为 $x = q \\cdot \\frac{\\pi}{2} + r$，其中 $q$ 是一个整数，$r$ 是一个小的余量。我们选择 $q$ 为最接近 $x / (\\pi/2)$ 值的整数，这确保了余量 $r$ 位于区间 $[-\\frac{\\pi}{4}, \\frac{\\pi}{4}]$ 内。\n步骤如下：\n1. 计算 $y = x / (\\pi/2)$。\n2. 找到最近的整数 $q = \\text{round}(y)$。\n3. 计算余量 $r = x - q \\cdot (\\pi/2)$。根据构造，有 $|r| \\le \\frac_1{2} \\cdot \\frac{\\pi}{2} = \\frac{\\pi}{4}$。\n\n$\\sin(x)$ 的值随后与 $\\sin(r)$ 或 $\\cos(r)$ 相关，具体取决于 $q$ 模 $4$ 的值。设 $q_{\\text{mod} 4} = q \\pmod 4$。我们使用和角恒等式：\n- 如果 $q_{\\text{mod} 4} = 0$：$\\sin(x) = \\sin(4k \\cdot \\frac{\\pi}{2} + r) = \\sin(2k\\pi + r) = \\sin(r)$。\n- 如果 $q_{\\text{mod} 4} = 1$：$\\sin(x) = \\sin((4k+1) \\cdot \\frac{\\pi}{2} + r) = \\sin(2k\\pi + \\frac{\\pi}{2} + r) = \\cos(r)$。\n- 如果 $q_{\\text{mod} 4} = 2$：$\\sin(x) = \\sin((4k+2) \\cdot \\frac{\\pi}{2} + r) = \\sin(2k\\pi + \\pi + r) = -\\sin(r)$。\n- 如果 $q_{\\text{mod} 4} = 3$：$\\sin(x) = \\sin((4k+3) \\cdot \\frac{\\pi}{2} + r) = \\sin(2k\\pi + \\frac{3\\pi}{2} + r) = -\\cos(r)$。\n\n该策略将计算任意 $x$ 的 $\\sin(x)$ 的问题简化为计算小自变量 $|r| \\le \\pi/4$ 的 $\\sin(r)$ 或 $\\cos(r)$。对于这样的小自变量，麦克劳林级数收敛迅速，并且可以有效地应用上一节推导的截断准则来确定所需的项数。\n\n**3. 数值稳定性分析**\n\n对于大的 $|x|$，直接计算 $\\sin(x)$ 的麦克劳林级数是数值不稳定的，这主要源于两个问题：中间项溢出和灾难性相消。\n\n- **中间项增长与溢出**：$\\sin(x)$ 级数的第 $k$ 项为 $t_k = \\frac{(-1)^k x^{2k+1}}{(2k+1)!}$。这些项的量级最初随着 $k$ 的增加而迅速增长。最大项的量级出现在比率 $|t_{k+1}/t_k| = \\frac{|x|^2}{(2k+2)(2k+3)} \\approx 1$ 时，这意味着 $2k+2 \\approx |x|$。对于像 $x=100$ 这样的大值，这些项会增长到天文数字般的大小（例如，当 $k=49$ 时，项的量级约为 $100^{99}/99!$，这很容易超过标准双精度浮点数所能表示的范围，约 $10^{308}$）。\n\n- **灾难性相消**：最终结果 $\\sin(x)$ 必须位于 $[-1, 1]$ 区间内。对于大 $x$ 的级数求值涉及到对非常大的正项和负项求和以产生一个小的最终结果。标准浮点数具有固定数量的有效数字（尾数）。当两个大小相近的大数相减时，前导的有效数字会相互抵消，导致结果的有效数字位数大大减少。这种相对精度的损失被称为灾难性相消，它会使最终结果变得毫无意义。\n\n自变量约简策略完全规避了这些问题。自变量 $r$ 很小（$|r| \\le \\pi/4 \\approx 0.785$），因此麦克劳林级数的项 $\\frac{r^k}{k!}$ 的量级从一开始就是单调递减的。中间项不会增长，因此也不会发生灾难性相消。该方法是数值稳定的。\n\n然而，自变量约简本身也有一个局限性。当 $x$ 极大时，步骤 $r = x - q \\cdot (\\pi/2)$ 可能会遭受灾难性相消。原因是标准浮点数对 $\\pi$ 的表示具有有限精度。对于一个非常大的 $x$（例如，$x=10^{16}+0.1$），$x$ 本身在标准 `float64` 算术中可能就会被舍入（对于 $10^{16}$，其末位单位大于 $0.1$，所以 $10^{16}+0.1$ 被存储为精确的 $10^{16}$）。即使 $x$ 是可表示的，乘积 $q \\cdot (\\pi/2)$ 也是一个接近 $x$ 的大数。`float64` 表示 $\\pi$ 的有限精度会给这个乘积带来一个与 $q$ 成正比的绝对误差。当 $x$ 很大时，$q$ 也很大，这个误差可能会变得非常显著，甚至可能大于 $\\pi/2$ 本身。然后，减法 $x - q \\cdot (\\pi/2)$ 会抵消掉大部分有效数字，从而得到一个几乎没有正确数字的 $r$ 值。这揭示了对于极大自变量，使用固定精度算术进行计算的根本限制。这种现象预计将导致 $x = 10^{16} + 0.1$ 的测试用例无法通过精度检查。\n\n所提供的程序实现了这些原理来计算正弦函数，并分析其在指定测试用例下的数值特性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef get_required_terms_sin(z_abs, ε):\n    \"\"\"\n    Calculates the minimum number of terms T for the sin Maclaurin series.\n    The error bound after T terms (degree 2T-1) is |z|^(2T+1)/(2T+1)!.\n    \"\"\"\n    if z_abs == 0.0:\n        return 1\n    \n    z2 = z_abs * z_abs\n    \n    # Bound for T=1 term (degree 1)\n    bound = (z_abs**3) / 6.0\n    T = 1\n    \n    denom_fac1 = 4\n    denom_fac2 = 5\n    \n    while bound  ε:\n        T += 1\n        bound *= z2 / (denom_fac1 * denom_fac2)\n        denom_fac1 += 2\n        denom_fac2 += 2\n        if T  1000: # Safety break\n            return T\n            \n    return T\n\ndef get_required_terms_cos(z_abs, ε):\n    \"\"\"\n    Calculates the minimum number of terms T for the cos Maclaurin series.\n    The error bound after T terms (degree 2T-2) is |z|^(2T)/(2T)!.\n    \"\"\"\n    if z_abs == 0.0:\n        return 1\n    \n    z2 = z_abs * z_abs\n    \n    # Bound for T=1 term (degree 0)\n    bound = z2 / 2.0\n    T = 1\n    \n    denom_fac1 = 3\n    denom_fac2 = 4\n\n    while bound  ε:\n        T += 1\n        bound *= z2 / (denom_fac1 * denom_fac2)\n        denom_fac1 += 2\n        denom_fac2 += 2\n        if T  1000: # Safety break\n            return T\n            \n    return T\n\ndef eval_sin_series(z, T):\n    \"\"\"Evaluates the sin Maclaurin series for T terms.\"\"\"\n    if z == 0.0:\n        return 0.0\n\n    z2 = z * z\n    term = z\n    total = term\n    for k in range(1, T):\n        # term_k = -term_{k-1} * z^2 / ((2k)(2k+1))\n        term *= -z2 / ((2 * k) * (2 * k + 1))\n        total += term\n    return total\n\ndef eval_cos_series(z, T):\n    \"\"\"Evaluates the cos Maclaurin series for T terms.\"\"\"\n    z2 = z * z\n    term = 1.0\n    total = term\n    for k in range(1, T):\n        # term_k = -term_{k-1} * z^2 / ((2k-1)(2k))\n        term *= -z2 / ((2 * k - 1) * (2 * k))\n        total += term\n    return total\n\ndef compute_sin_reduced(x, ε):\n    \"\"\"\n    Computes sin(x) using argument reduction and Maclaurin series.\n    Returns the computed value and the number of terms used.\n    \"\"\"\n    pi_over_2 = np.pi / 2.0\n    \n    # Argument reduction\n    q_float = x / pi_over_2\n    q = np.round(q_float)\n    r = x - q * pi_over_2\n    \n    q_int = int(q)\n    quadrant = q_int % 4\n    \n    r_abs = abs(r)\n\n    if quadrant == 0:  # sin(r)\n        T = get_required_terms_sin(r_abs, ε)\n        val = eval_sin_series(r, T)\n        return val, T\n    elif quadrant == 1:  # cos(r)\n        T = get_required_terms_cos(r_abs, ε)\n        val = eval_cos_series(r, T)\n        return val, T\n    elif quadrant == 2:  # -sin(r)\n        T = get_required_terms_sin(r_abs, ε)\n        val = eval_sin_series(r, T)\n        return -val, T\n    else:  # quadrant == 3, -cos(r)\n        T = get_required_terms_cos(r_abs, ε)\n        val = eval_cos_series(r, T)\n        return -val, T\n\ndef check_naive_impractical(x, ε, T_max):\n    \"\"\"\n    Checks if a naive Maclaurin series evaluation of sin(x) is impractical.\n    Impractical if  T_max terms are needed or if intermediate terms overflow.\n    \"\"\"\n    x_abs = abs(x)\n    if x_abs == 0.0:\n        return False\n        \n    x2 = x_abs * x_abs\n    \n    # Check terms and remainder bound iteratively for T = 1, 2, ...\n    \n    # T=1 term magnitude (|x|)\n    term_mag = x_abs\n    if np.isinf(term_mag):\n        return True # Overflow\n\n    # Remainder bound for T=1 term\n    remainder_bound = term_mag * x2 / 6.0\n    if remainder_bound = ε:\n        return False # Practical\n    \n    for T in range(2, T_max + 1):\n        # Magnitude of the T-th term\n        # term_mag(T) = term_mag(T-1) * x^2 / ((2T-2)*(2T-1))\n        term_mag *= x2 / ((2*T - 2) * (2*T - 1))\n        if np.isinf(term_mag):\n            return True # Overflow of intermediate term\n\n        # Remainder bound for T terms\n        # bound(T) = term_mag(T) * x^2 / ((2T)*(2T+1))\n        remainder_bound = term_mag * x2 / ((2*T) * (2*T + 1))\n        if np.isinf(remainder_bound):\n            # This can happen if term_mag is huge but finite\n            # and gets multiplied by a large x2\n            return True\n            \n        if remainder_bound = ε:\n            return False # Practical, convergence within T_max terms\n\n    return True # Not converged within T_max terms\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (100.0, 1e-12),\n        (10**6 + 0.1, 1e-12),\n        (10**16 + 0.1, 1e-12),\n        (np.pi/2 + 1e-8, 1e-15),\n    ]\n\n    results = []\n    for x, ε in test_cases:\n        # 1. Compute s_approx and T using the reduced method.\n        s_approx, T = compute_sin_reduced(x, ε)\n        \n        # 2. Compute b_ok by comparing with a high-quality reference.\n        # Use np.longdouble for reference calculation where precision matters\n        ref_val = np.sin(np.longdouble(x))\n        b_ok = np.abs(s_approx - ref_val) = ε\n        \n        # 3. Assess if naive method is impractical.\n        T_max = 1000\n        b_naive_impractical = check_naive_impractical(x, ε, T_max)\n        \n        results.extend([b_ok, T, b_naive_impractical])\n\n    # Final print statement in the exact required format.\n    # Python's str() for a boolean is 'True' or 'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2442233"}]}