{"hands_on_practices": [{"introduction": "浮点数具有有限的精度，这一精度是相对于其数值大小而言的。这个练习将通过一个假设的实时调度器场景，来揭示一个关键概念：末位单位（Unit in the Last Place, ULP）。我们将计算能够成功累加到一个巨大时间戳上的最小时间增量，从而阐明为何微小的更新可能会在计算中“消失”。", "problem": "一个实时调度器使用电气与电子工程师协会（IEEE）754 binary64 浮点格式以秒为单位记录挂钟时间，并使用默认的“舍入到最近，偶数优先”规则执行加法运算。设当前记录的时间为 $t = 10^{12}$ 秒。从标准化的 IEEE 754 binary64 数（形式为 $m \\times 2^{e}$，其中 $m \\in [1,2)$ 且尾数具有 $53$ 位精度）的核心定义以及舍入到最近可表示值的定义出发，推导最小正实数增量 $\\delta_{\\min}$，使得计算出的浮点和 $fl(t + \\delta_{\\min})$ 严格大于 $t$。然后数值计算 $\\delta_{\\min}$。用秒表示你的最终答案，并四舍五入到四位有效数字。\n\n简要说明你的结果与一个使用微秒级时钟节拍（即每次节拍的预期增量为 $\\Delta t = 10^{-6}$ 秒）的调度器在 $t = 10^{12}$ 秒时能否成功推进时间的关系。", "solution": "首先根据指定标准对问题进行验证。\n\n### 步骤 1：提取已知条件\n- 数字格式：IEEE 754 binary64。\n- 舍入规则：舍入到最近，偶数优先。\n- 当前时间：$t = 10^{12}$ 秒。\n- 标准化数表示法：$m \\times 2^{e}$，其中 $m \\in [1,2)$ 且尾数具有 $53$ 位精度。\n- 任务 1：求最小正实数增量 $\\delta$，使得计算出的和 $fl(t + \\delta)$ 严格大于 $t$。\n- 任务 2：数值计算该增量的阈值，并四舍五入到四位有效数字。\n- 任务 3：将结果与 $\\Delta t = 10^{-6}$ 秒的调度器时钟节拍联系起来。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：** 该问题基于 IEEE 754 标准，这是计算科学的基石。所涉及的所有原则都是公认的。\n- **适定性：** 该问题要求在一个已定义的算术系统中求一个特定值。数量和运算都有明确定义。术语“最小正实数增量”在解集为开区间时存在细微的歧义，但这是一种常见的教学表述，其意图是求该集合的下确界或阈值。这并不使问题无法解决。\n- **客观性：** 该问题以精确的技术语言陈述，没有主观因素。\n- **结论：** 该问题被认为是有效的，因为它是自洽的、科学上合理的和客观的。措辞上的歧义是次要的，在数值分析的背景下有标准的解释。\n\n### 解题推导\n求解过程首先确定 $t = 10^{12}$ 的浮点表示，然后分析在指定的舍入规则下加上一个小的增量 $\\delta$ 的效果。\n\n一个标准化的 IEEE 754 binary64 数的形式为 $v = (-1)^s \\times m \\times 2^e$，其中 $s$ 是符号位，$m$ 是具有 $53$ 位精度的尾数，满足 $1 \\le m  2$，$e$ 是整数指数。尾数可以写成 $m = 1 + f$，其中 $f$ 是由 $52$ 位表示的小数部分，所以 $m$ 的形式为 $1 + k \\cdot 2^{-52}$，其中整数 $k \\in [0, 2^{52}-1]$。\n\n1.  **以 binary64 格式表示 $t = 10^{12}$。**\n    首先，我们确定指数 $e$。指数 $e$ 是满足 $2^e \\le t  2^{e+1}$ 的唯一整数。\n    $$e = \\lfloor \\log_2(t) \\rfloor = \\lfloor \\log_2(10^{12}) \\rfloor = \\lfloor 12 \\log_2(10) \\rfloor$$\n    使用近似值 $\\log_2(10) \\approx 3.321928$，我们得到：\n    $$e = \\lfloor 12 \\times 3.321928 \\rfloor = \\lfloor 39.863136 \\rfloor = 39$$\n    偏置指数 $E$ 为 $e + 1023 = 39 + 1023 = 1062$，这在 $11$ 位指数场的有效范围内。\n\n    理想的尾数是 $m_{\\text{ideal}} = \\frac{t}{2^e} = \\frac{10^{12}}{2^{39}}$。\n    为了确定 $t$ 是否可以精确表示，我们检查其尾数 $m_{\\text{ideal}}$ 是否可以表示为 $1 + k \\cdot 2^{-52}$ 的形式。这等效于检查 $t$ 是否为其所在范围内最小可表示步长的倍数。在区间 $[2^e, 2^{e+1})$ 内，可表示数之间的步长是末位单位（ULP），由下式给出：\n    $$\\text{ulp}(t) = 2^{e} \\times 2^{-52} = 2^{e-52}$$\n    对于 $e = 39$，ULP 为 $\\text{ulp}(t) = 2^{39-52} = 2^{-13}$。\n    在此范围内的任意数 $x$ 可被表示，当且仅当它是此 ULP 的整数倍。我们检查 $t$ 是否是 $2^{-13}$ 的倍数：\n    $$\\frac{t}{\\text{ulp}(t)} = \\frac{10^{12}}{2^{-13}} = 10^{12} \\times 2^{13} = (2 \\times 5)^{12} \\times 2^{13} = 2^{12} \\times 5^{12} \\times 2^{13} = 5^{12} \\times 2^{25}$$\n    因为 $5^{12} \\times 2^{25}$ 是一个整数，所以 $t = 10^{12}$ 是一个可以精确表示的 binary64 数。设 $fl(t)$ 表示 $t$ 的浮点表示。那么 $fl(t) = t$。\n\n2.  **求最小增量的阈值。**\n    设 $t$ 是一个可精确表示的浮点数。比它大的下一个可表示数是 $t_{\\text{next}} = t + \\text{ulp}(t)$。\n    $$t_{\\text{next}} = t + 2^{-13}$$\n    我们在寻找最小的正实数增量 $\\delta$，使得计算出的和 $fl(t + \\delta)$ 严格大于 $t$。这意味着 $fl(t + \\delta)$ 必须至少为 $t_{\\text{next}}$。\n    舍入规则是“舍入到最近，偶数优先”。一个实数值 $x$ 会被舍入到最近的可表示值。如果 $x$ 正好位于两个可表示值的中间，它会被舍入到尾数最低有效位为 $0$ 的那个值（即“偶数”的那个）。\n\n    $t$ 和 $t_{\\text{next}}$ 之间的中点是：\n    $$t_{\\text{mid}} = t + \\frac{t_{\\text{next}} - t}{2} = t + \\frac{\\text{ulp}(t)}{2} = t + \\frac{2^{-13}}{2} = t + 2^{-14}$$\n    为了使和 $t+\\delta$ 向上舍入到 $t_{\\text{next}}$，它必须严格大于中点 $t_{\\text{mid}}$，或者在 $t_{\\text{next}}$ 是“偶数”邻居的情况下恰好等于中点。\n\n    我们必须确定 $t$ 或 $t_{\\text{next}}$ 哪一个是“偶数”。如果一个浮点数尾数的整数表示是偶数，则该浮点数是“偶数”。$t$ 的尾数是 $m_t = \\frac{10^{12}}{2^{39}}$。它可以写成 $m_t = 1 + \\frac{K_t}{2^{52}}$，其中 $K_t$ 是一个整数。\n    $$K_t = (m_t - 1) \\times 2^{52} = \\left(\\frac{10^{12}}{2^{39}} - 1\\right) \\times 2^{52} = 10^{12} \\times 2^{13} - 2^{52} = 5^{12} \\times 2^{25} - 2^{52}$$\n    因为 $25 > 0$ 且 $52 > 0$，所以 $K_t$ 是一个偶数。因此，$t$ 是一个“偶数”浮点数。所以，$t_{\\text{next}}$（其尾数对应整数 $K_t+1$）必定是“奇数”。\n\n    现在考虑和 $s = t + \\delta$。\n    - 如果 $s  t_{\\text{mid}}$，$fl(s) = t$。\n    - 如果 $s > t_{\\text{mid}}$，$fl(s) = t_{\\text{next}}$。\n    - 如果 $s = t_{\\text{mid}}$，这是一个平局情况。该值会被舍入到“偶数”邻居，即 $t$。所以，$fl(t_{\\text{mid}}) = t$。\n\n    为了使 $fl(t + \\delta)$ 严格大于 $t$，我们需要 $fl(t + \\delta) = t_{\\text{next}}$。这要求精确和 $t+\\delta$ 严格大于中点：\n    $$t + \\delta > t_{\\text{mid}}$$\n    $$\\delta > t_{\\text{mid}} - t = 2^{-14}$$\n    满足此条件的正实数 $\\delta$ 的集合是开区间 $(\\frac{\\text{ulp}(t)}{2}, \\infty)$。该集合不包含最小元素。然而，问题要求的是“最小正实数增量”。在此背景下，这被理解为成功值的临界阈值或下确界。这个阈值是 $\\frac{\\text{ulp}(t)}{2} = 2^{-14}$。\n\n3.  **阈值的数值计算。**\n    我们计算这个阈值的数值，并四舍五入到四位有效数字。\n    $$\\text{阈值} = 2^{-14} = \\frac{1}{16384} = 0.00006103515625 \\text{ 秒}$$\n    用科学记数法表示，这是 $6.103515625 \\times 10^{-5}$ 秒。四舍五入到四位有效数字得到：\n    $$6.104 \\times 10^{-5} \\text{ s}$$\n\n4.  **与调度器时钟节拍的关系。**\n    调度器使用的预期时间增量为 $\\Delta t = 10^{-6}$ 秒。我们将其与产生存储时间 $t$ 变化所需的阈值进行比较。\n    所需的增量是 $\\delta > 2^{-14} \\approx 6.104 \\times 10^{-5}$ 秒。\n    调度器的增量是 $\\Delta t = 10^{-6}$ 秒 $= 0.1 \\times 10^{-5}$ 秒。\n    我们有 $\\Delta t  2^{-14}$。\n    由于增量 $\\Delta t$ 小于阈值，计算出的和 $fl(t + \\Delta t)$ 将被向下舍入到 $t$。\n    $$fl(10^{12} + 10^{-6}) = 10^{12}$$\n    因此，调度器将无法推进时钟。由于在这个时间量级上浮点精度不足，每次时钟节拍都会“丢失”。时钟将卡在 $t=10^{12}$ 秒。", "answer": "$$\n\\boxed{6.104 \\times 10^{-5}}\n$$", "id": "3109820"}, {"introduction": "在我们理解了精度的限制之后，现在我们来探究计算机如何处理那些恰好落在两个可表示数值之间的计算结果。本实践将研究 IEEE 754 标准定义的几种不同舍入策略。通过模拟一个简单的迭代过程，我们将看到舍入规则中看似微不足道的差异，如何导致截然不同的长期计算结果。", "problem": "一名开发者被要求比较在二进制浮点运算下，不同的舍入策略如何影响一个简单的迭代计算。该计算是由 $x_{k+1} = x_k + \\delta$ 定义的递推关系，其中 $\\delta = 2^{-54}$，初始值为 $x_0 = 1$。必须针对电气与电子工程师协会 (Institute of Electrical and Electronics Engineers, IEEE) 754 标准定义的以下舍入策略进行比较：向最邻近数舍入（偶数优先）、向零舍入、向正无穷舍入以及向负无穷舍入。此任务的基础是实数在 IEEE 754 binary64 格式中的表示，特别是在区间 $[1, 2)$ 内相邻可表示数之间的间距以及舍入模式的操作定义。在 IEEE 754 binary64 中，区间 $[1, 2)$ 内的规格化数在相邻可表示值之间具有 $2^{-52}$ 的恒定间距，这在该数量级上是末位单位 (unit in the last place, ULP)。目标是设计并实现一个实验，通过应用源于第一性原理的舍入决策，来严格模拟每种舍入模式下的递推过程，而不依赖硬件或运行时的舍入模式设置。\n\n程序必须按以下方式进行：\n- 将 $x_k$ 建模为区间 $[1, 2)$ 内的一个可表示的 binary64 值，概念化为 $x_k = 1 + n_k \\cdot 2^{-52}$，其中当 $x_k \\in [1, 2)$ 时，整数 $n_k \\in \\{0, 1, 2, \\dots\\}$，并使用增量与 ULP 单位的精确比较，在每一步应用舍入决策。\n- 在每一步，通过比较分数增量 $\\delta$ 相对于局部 ULP $2^{-52}$ 的大小，确定在每种舍入模式下精确和 $x_k + \\delta$ 的舍入结果，并相应地更新 $x_{k+1}$。\n- 不要使用任何外部硬件舍入控制；必须通过与 IEEE 754 舍入模式定义一致的逻辑来模拟舍入行为。\n- 为每种舍入模式和每个测试用例报告最终的 $x_N$ 值，其格式为 binary64。\n\n测试套件规范：\n- 使用迭代次数集合 $N \\in \\{0, 1, 3, 4, 10^6\\}$ (数字 $10^6$ 是一百万)。\n- 对于指定顺序中的每个 $N$，按固定顺序计算在各种舍入模式下的最终值 $x_N$：向最邻近数舍入（偶数优先）、向零舍入、向正无穷舍入、向负无穷舍入。\n- 所有报告的值必须是标量 binary64 浮点数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。\n- 列表必须按照上述顺序展平。具体来说，输出必须是 $[x_N^{\\text{nearest}}, x_N^{\\text{toward-zero}}, x_N^{\\text{plus-inf}}, x_N^{\\text{minus-inf}}, x_N^{\\text{nearest}}, \\dots]$，其中四个数字的块依次对应 $N = 0$，$N = 1$，$N = 3$，$N = 4$，然后是 $N = 10^6$ 重复。\n- 输出中不涉及单位或角度；所有数字都是纯粹的无量纲浮点值。", "solution": "在尝试任何解决方案之前，对问题陈述的有效性进行了严格评估。\n\n### 步骤 1：提取已知条件\n- **递推关系**：$x_{k+1} = x_k + \\delta$\n- **初始值**：$x_0 = 1$\n- **增量**：$\\delta = 2^{-54}$\n- **算术系统**：IEEE 754 binary64 浮点。\n- **舍入策略**：\n  1. 向最邻近数舍入（偶数优先）\n  2. 向零舍入\n  3. 向正无穷舍入\n  4. 向负无穷舍入\n- **关注区间**：变量 $x_k$ 位于区间 $[1, 2)$ 内。\n- **ULP 定义**：在区间 $[1, 2)$ 内，相邻可表示的 binary64 数之间的间距，即末位单位 (ULP)，是一个常数 $2^{-52}$。\n- **建模约束**：该模拟必须通过源于第一性原理的显式逻辑来模拟指定的舍入模式，而不依赖于硬件或运行时环境的舍入设置。\n- **测试套件**：迭代次数 $N$ 从集合 $\\{0, 1, 3, 4, 10^6\\}$ 中选取。\n- **输出规范**：对于每个 $N$，按固定顺序（最邻近、向零、向正无穷、向负无穷）报告四种舍入模式下的最终值 $x_N$。最终输出是这些结果的单个展平列表。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n\n- **科学上成立**：该问题在根本上是合理的。它基于 IEEE 754 浮点运算的明确定义和标准化原则。所提供的值，例如在 $[1, 2)$ 区间内数字的 ULP 为 $2^{-52}$ 以及增量 $\\delta = 2^{-54}$，都是正确的，并且经过恰当选择以测试舍入的细微差别。\n- **适定性**：该问题是适定的。它指定了一个具有明确初始条件的确定性递推关系。对于每种舍入模式，算术规则都是明确的，从而对任何给定的迭代次数 $N$ 都能得出唯一且稳定的解。\n- **客观性**：问题以精确、客观的语言陈述。它描述了一个计算实验，没有主观或含糊的术语。\n- **缺陷分析**：\n  1. **科学上不合理**：无。前提符合既定的计算机算术标准。\n  2. **不可形式化**：无。该问题是一个经典的数值分析练习，完全可以形式化。它与计算机数表示的主题直接相关。\n  3. **设置不完整/矛盾**：无。所有必要信息都已提供。模拟舍入逻辑的约束是问题设计的关键部分，而不是矛盾。\n  4. **不切实际/不可行**：无。计算是可行的。$10^6$ 次迭代在计算上是微不足道的。这些值始终在标准的 binary64 范围内。\n  5. **不适定**：无。每种情况的解都是唯一且稳定的。\n  6. **伪深刻/琐碎**：该问题并不琐碎。虽然在正确分析后，实现可能看起来很简单，但要得出该分析需要对浮点运算有透彻的理解。$\\delta$ 相对于 ULP 的选择是专门设计的，旨在探究增量小于半个 ULP 时的舍入规则，这是一个关键的概念挑战。\n  7. **超出科学可验证性**：无。通过应用 IEEE 754 标准的规则，结果是可验证的。\n\n### 步骤 3：结论与行动\n问题陈述是 **有效的**。将制定一个合理的解决方案。\n\n### 基于原理的设计与解决方案\n目标是模拟从 $x_0 = 1$ 开始，对于 $k = 0, 1, \\dots, N-1$ 的递推关系 $x_{k+1} = fl(x_k + \\delta)$。任务的核心是正确地建模在指定的 IEEE 754 舍入模式下，单次浮点加法的影响，并假设每次加法的结果都立即舍入为可表示的 binary64 数。\n\n初始值为 $x_0 = 1$。分析将集中在区间 $[1, 2)$，在此区间内 binary64 数的指数是固定的，其值由尾数决定。在该区间内，末位单位 (ULP) 是一个常数，等于 $u = 2^{-52}$。此区间内所有可表示的数都具有 $1 + n \\cdot u$ 的形式，其中 $n$ 为某个整数。\n\n增量为 $\\delta = 2^{-54}$。关键步骤是将 $\\delta$ 与 ULP $u$ 关联起来：\n$$\n\\delta = 2^{-54} = 2^{-2} \\cdot 2^{-52} = \\frac{1}{4}u\n$$\n在任意步骤 $k$，我们考虑精确的数学和 $S_k = x_k + \\delta$。由于 $x_k$ 是一个可表示的数，所以 $S_k$ 的形式为：\n$$\nS_k = x_k + \\frac{1}{4}u\n$$\n这个精确和 $S_k$ 位于两个相邻的可表示数之间：$x_k$ 及其后继数 $x_k^{+} = x_k + u$。为了确定舍入后的值 $x_{k+1}$，我们必须根据每种舍入模式的规则，将 $S_k$ 与这些可表示数进行比较。$x_k$ 和 $x_k^{+}$ 之间的中点是 $M = x_k + \\frac{1}{2}u$。\n\n每种舍入模式的分析如下：\n\n1.  **向正无穷舍入 (`roundTowardPositive`)**：此模式舍入到大于或等于精确结果的最小可表示数。由于 $S_k = x_k + \\frac{1}{4}u$ 严格大于 $x_k$ 且本身不可表示，因此必须向上舍入到下一个可表示的数 $x_k^{+}$。\n    $$\n    x_{k+1} = x_k^{+} = x_k + u\n    $$\n    这意味着在每次迭代中，该值都精确增加一个 ULP。经过 $N$ 次迭代后，最终值为：\n    $$\n    x_N = x_0 + N \\cdot u = 1 + N \\cdot 2^{-52}\n    $$\n\n2.  **向零舍入 (`roundTowardZero`)**：此模式向 $0$ 舍入。对于像 $S_k$ 这样的正数，这等同于截断。精确和 $S_k$ 位于开区间 $(x_k, x_k^{+})$ 内。小于或等于 $S_k$ 的最大可表示数是 $x_k$。\n    $$\n    x_{k+1} = x_k\n    $$\n    该值永不改变。经过 $N$ 次迭代后，最终值为：\n    $$\n    x_N = x_0 = 1\n    $$\n\n3.  **向负无穷舍入 (`roundTowardNegative`)**：此模式舍入到小于或等于精确结果的最大可表示数（向下取整函数）。对于 $S_k \\in (x_k, x_k^{+})$，该值为 $x_k$。\n    $$\n    x_{k+1} = x_k\n    $$\n    与向零舍入类似，该值永不改变。最终值为：\n    $$\n    x_N = x_0 = 1\n    $$\n\n4.  **向最邻近数舍入（偶数优先） (`roundTiesToEven`)**：此模式舍入到最邻近的可表示数。在出现平局（精确结果恰好在两个可表示数的中间点）的情况下，它会舍入到尾数最低有效位为偶数的那个数。\n    我们将精确和 $S_k = x_k + \\frac{1}{4}u$ 与中点 $M = x_k + \\frac{1}{2}u$ 进行比较。\n    $$\n    S_k  M\n    $$\n    由于精确和总是严格地更接近 $x_k$ 而不是 $x_k^{+}$，舍入规则规定向 $x_k$ 舍入。永远不会满足平局条件。\n    $$\n    x_{k+1} = x_k\n    $$\n    该值从其初始状态开始永不改变。最终值为：\n    $$\n    x_N = x_0 = 1\n    $$\n\n该分析表明，对于给定的递推关系并在每一步严格遵守 binary64 舍入规则，只有 `roundTowardPositive` 模式会导致值的累积。其他三种模式导致停滞，因为增量 $\\delta$ 太小，无法超过舍入阈值。\n\n该算法是针对测试套件中每个 $N$ 的这些导出公式的直接实现。\n对于任意 $N \\in \\{0, 1, 3, 4, 10^6\\}$：\n- $x_N^{\\text{nearest}} = 1.0$\n- $x_N^{\\text{toward-zero}} = 1.0$\n- $x_N^{\\text{plus-inf}} = 1.0 + N \\cdot 2^{-52}$\n- $x_N^{\\text{minus-inf}} = 1.0$\n\n这些公式即使对于 $N=0$ 也有效，它们为所有模式正确地得出 $1.0$。实现将为每个 $N$ 计算这些值，并按要求格式化它们。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates an iterative computation under different IEEE 754 rounding strategies\n    by applying rounding decisions derived from first principles.\n    \"\"\"\n\n    # Define the test cases from the problem statement for the number of iterations N.\n    test_cases = [0, 1, 3, 4, 10**6]\n\n    # Initialize a list to store the final results.\n    results = []\n\n    # Define constants based on the problem statement.\n    # The initial value x_0.\n    x0 = np.float64(1.0)\n    # The unit in the last place (ULP) for numbers in the interval [1, 2) in binary64.\n    ulp = np.float64(2**-52)\n\n    # The problem asks to simulate the recurrence x_{k+1} = fl(x_k + delta), where\n    # delta = 2**-54. The core of the problem is to understand how a single\n    # floating-point addition `x_k + delta` is rounded.\n    # The increment delta is 1/4 of the ULP.\n    # delta = ulp / 4.\n\n    # Analysis of rounding modes:\n    # The exact sum is S_k = x_k + ulp/4.\n    # This sum is between the representable numbers x_k and x_k_plus = x_k + ulp.\n    # The midpoint is M = x_k + ulp/2.\n\n    # 1. Round to nearest: S_k is closer to x_k than x_k_plus. Result is x_k. Value never changes.\n    # 2. Round toward zero: For positive numbers, this truncates. Result is x_k. Value never changes.\n    # 3. Round toward minus infinity: This is a floor operation. Result is x_k. Value never changes.\n    # 4. Round toward plus infinity: This is a ceil operation. Result is x_k_plus. Value increases by ulp each step.\n\n    for N in test_cases:\n        # Calculate the final value x_N for each rounding mode based on the analysis.\n        \n        # Mode 1: Rounding to nearest (ties to even)\n        # The recurrence x_{k+1} = round_nearest(x_k + delta) results in x_{k+1} = x_k.\n        # Thus, x_N = x_0.\n        xN_nearest = x0\n\n        # Mode 2: Rounding toward zero\n        # The recurrence x_{k+1} = round_zero(x_k + delta) results in x_{k+1} = x_k.\n        # Thus, x_N = x_0.\n        xN_toward_zero = x0\n\n        # Mode 3: Rounding toward plus infinity\n        # The recurrence x_{k+1} = round_plus_inf(x_k + delta) results in x_{k+1} = x_k + ulp.\n        # Thus, x_N = x_0 + N * ulp.\n        # The multiplication N * ulp is exact because N is an integer.\n        xN_plus_inf = x0 + np.float64(N) * ulp\n\n        # Mode 4: Rounding toward minus infinity\n        # The recurrence x_{k+1} = round_minus_inf(x_k + delta) results in x_{k+1} = x_k.\n        # Thus, x_N = x_0.\n        xN_minus_inf = x0\n\n        # Append the results for the current N to the list.\n        results.extend([xN_nearest, xN_toward_zero, xN_plus_inf, xN_minus_inf])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3109818"}, {"introduction": "当一次计算产生的结果比最小的标准化浮点数还要小时，会发生什么？这个练习深入探讨了次正规数（subnormal/denormal number）的世界，这是 IEEE 754 标准的一个关键特性。通过一个求解常微分方程的数值方法示例，我们将看到这些特殊的数值如何提供一个“安全网”，防止计算结果突兀地“下溢”为零，从而避免像“除以零”这样的灾难性失败。", "problem": "您将为一个应用于简单线性常微分方程的单步显式方法实现并分析一种自适应步长计算方法，重点关注电气和电子工程师协会（Institute of Electrical and Electronics Engineers, IEEE）浮点数算术标准（IEEE-754）中的二进制浮点次正规数（subnormal/denormal number）如何防止除零事件，以及启用“刷新到零”（Flush-To-Zero, FTZ）模式如何改变该行为。分析必须基于二进制浮点表示的基本原理和数值方法的局部误差缩放特性。\n\n考虑以下常微分方程的初值问题\n$$\n\\frac{dy}{dt} = -\\lambda y, \\quad y(0) = y_0,\n$$\n其中参数 $y_0 \\in \\mathbb{R}$ 和 $\\lambda > 0$。使用步长为 $h > 0$ 的前向欧拉法计算单步和倍半步近似值。单步近似值为\n$$\ny_1 = y_n - h \\lambda y_n,\n$$\n两个半步的近似值为\n$$\ny_{1/2} = y_n + \\frac{h}{2} f(y_n), \\quad y_{2} = y_{1/2} + \\frac{h}{2} f(y_{1/2})。\n$$\n通过绝对差定义局部误差估计\n$$\n\\mathrm{err} = \\lvert y_2 - y_1 \\rvert。\n$$\n\n您的推理应基于以下基本依据：\n- IEEE-754 binary64 格式的最小正规格化数为 $2^{-1022} \\approx 2.2250738585072014 \\times 10^{-308}$，并支持在区间 $(0, 2^{-1022})$ 内的次正规数，以提供逐渐下溢（gradual underflow）。\n- 在“刷新到零”（FTZ）模式下，任何次正规数结果在进一步使用前都会被替换为 $0$。\n- 前向欧拉法的局部截断误差随步长呈二次方缩放，这与单步和两个半步之差由一个 $h^2$ 阶项决定的观察结果一致。\n\n您的程序必须：\n1. 使用浮点运算，根据 $y_n$、$h$ 和 $\\lambda$ 计算上述定义的 $\\mathrm{err}$。\n2. 模拟 FTZ 行为：如果计算出的 $\\mathrm{err}$ 满足 $0  \\mathrm{err}  2^{-1022}$，则将其替换为 $0$，否则保持不变。同时，在没有 FTZ（无替换）的模式下计算结果。\n3. 基于二次方局部误差缩放计算一个自适应步长缩放因子 $s$。将 $s$ 限制在闭区间 $[s_{\\min}, s_{\\max}]$ 内，其中 $s_{\\min} = 0.1$ 且 $s_{\\max} = 10.0$。如果在计算 $s$ 时发生除零错误，需检测并明确记录该事件。\n4. 为每个测试用例生成结果，以量化有无 FTZ 模式下的行为。对于每个测试用例，报告一个数对 $[s_{\\text{no\\_ftz}}, \\text{ftz\\_div\\_zero}]$，其中 $s_{\\text{no\\_ftz}}$ 是在无 FTZ 模式下计算的缩放因子，$\\text{ftz\\_div\\_zero}$ 是一个布尔值，指示在模拟 FTZ 时是否发生除零错误。\n\n本问题不涉及物理单位。所有角度（如果有）必须以弧度为单位，但此处未出现角度。所有输出必须是数值浮点数、布尔值或其列表。\n\n测试套件：\n使用以下四个测试用例，以确保覆盖典型行为、边界条件和极端边缘情况。所有情况下，均使用双精度（binary64）算术。\n- 情况 1（正常路径）：$y_n = 1.0$, $h = 0.1$, $\\lambda = 1.0$, $\\mathrm{tol} = 10^{-6}$。\n- 情况 2（边界进入次正规数）：$y_n = 2^{-1022}$, $h = 1.0$, $\\lambda = 1.0$, $\\mathrm{tol} = 10^{-12}$。\n- 情况 3（极端下溢）：$y_n = 10^{-320}$, $h = 1.0$, $\\lambda = 1.0$, $\\mathrm{tol} = 10^{-12}$。\n- 情况 4（阈值规格化误差）：$y_n = 4 \\cdot 2^{-1022}$, $h = 1.0, \\lambda = 1.0, \\mathrm{tol} = 10^{-12}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个元素必须是对应测试用例的数对 $[s_{\\text{no\\_ftz}}, \\text{ftz\\_div\\_zero}]$。例如，整体格式必须为\n$$\n[\\,[s_{1,\\text{no\\_ftz}}, \\text{ftz\\_div\\_zero}_1], [s_{2,\\text{no\\_ftz}}, \\text{ftz\\_div\\_zero}_2], [s_{3,\\text{no\\_ftz}}, \\text{ftz\\_div\\_zero}_3], [s_{4,\\text{no\\_ftz}}, \\text{ftz\\_div\\_zero}_4]\\,]\n$$\n以单行形式打印，不含任何附加文本。", "solution": "### 问题验证\n\n**步骤 1：提取已知条件**\n\n-   **微分方程：** $\\frac{dy}{dt} = -\\lambda y$，初始条件为 $y(0) = y_0$。\n-   **参数：** $y_n \\in \\mathbb{R}$，$\\lambda > 0$，$h > 0$。\n-   **数值方法：** 前向欧拉法。\n-   **单步近似值 ($y_1$)：** $y_1 = y_n - h \\lambda y_n$。\n-   **两个半步近似值 ($y_2$)：** $y_{1/2} = y_n + \\frac{h}{2} f(y_n)$，以及 $y_{2} = y_{1/2} + \\frac{h}{2} f(y_{1/2})$。\n-   **误差估计：** $\\mathrm{err} = \\lvert y_2 - y_1 \\rvert$。\n-   **浮点标准：** IEEE-754 binary64。\n-   **最小正规格化数 ($N_{\\min}$):** $N_{\\min} = 2^{-1022} \\approx 2.225 \\times 10^{-308}$。\n-   **次正规数：** 区间 $(0, 2^{-1022})$ 内的数。\n-   **“刷新到零”（FTZ）模拟：** 如果计算出的 $\\mathrm{err}$ 满足 $0  \\mathrm{err}  2^{-1022}$，则将其替换为 $0$。否则，保持不变。\n-   **步长缩放：** 自适应步长缩放因子 $s$ 基于二次方局部误差缩放，即 $\\mathrm{err} \\propto h^2$。\n-   **缩放因子限制：** $s$ 被限制在区间 $[s_{\\min}, s_{\\max}] = [0.1, 10.0]$ 内。\n-   **除零检测：** 程序必须检测并报告在 FTZ 模拟下计算 $s$ 时是否发生除零错误。\n-   **每个测试用例的输出：** 一个数对 $[s_{\\text{no\\_ftz}}, \\text{ftz\\_div\\_zero}]$，其中 $s_{\\text{no\\_ftz}}$ 是无 FTZ 时的缩放因子，$\\text{ftz\\_div\\_zero}$ 是一个布尔值，指示在有 FTZ 时是否发生除零事件。\n-   **测试用例（使用 binary64 算术）：**\n    1.  $y_n = 1.0$, $h = 0.1$, $\\lambda = 1.0$, $\\mathrm{tol} = 10^{-6}$。\n    2.  $y_n = 2^{-1022}$, $h = 1.0, \\lambda = 1.0, \\mathrm{tol} = 10^{-12}$。\n    3.  $y_n = 10^{-320}$, $h = 1.0, \\lambda = 1.0, \\mathrm{tol} = 10^{-12}$。\n    4.  $y_n = 4 \\cdot 2^{-1022}$, $h = 1.0, \\lambda = 1.0, \\mathrm{tol} = 10^{-12}$。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n-   **科学基础：** 该问题牢固地建立在数值分析（显式单步法、局部误差估计、自适应步长控制）和计算机算术（IEEE-754 浮点表示、次正规数、“刷新到零”行为）的既定原则之上。物理模型是一个标准的一阶线性常微分方程。该问题在科学上是合理的。\n-   **适定性：** 所有必要的参数（$y_n, h, \\lambda, \\mathrm{tol}$）和定义都已提供，可以计算出唯一的解。步长缩放因子 $s$ 的公式没有明确给出，但通过自适应步长的标准实践和所提供的信息（误差估计器呈二次方（$O(h^2)$）缩放）可以明确推断。对于期望的容差 $\\mathrm{tol}$，选择新的步长 $h_{new} = s \\cdot h$，使得新误差约等于 $\\mathrm{tol}$。给定 $\\mathrm{err} \\approx C h^2$，我们希望 $\\mathrm{tol} \\approx C (s h)^2 = s^2 (C h^2) \\approx s^2 \\cdot \\mathrm{err}$。这导致 $s^2 \\approx \\mathrm{tol}/\\mathrm{err}$，因此 $s \\approx \\sqrt{\\mathrm{tol}/\\mathrm{err}}$。这个公式是标准的，使得问题是适定的。\n-   **客观性：** 问题以精确、客观的数学和计算术语陈述，没有任何主观性或模糊性。\n\n**步骤 3：结论与行动**\n\n该问题是有效的，因为它具有科学依据、适定、客观，并且不包含任何不一致或缺陷。将提供一个完整的解决方案。\n\n### 解决方案\n\n该解决方案要求计算前向欧拉法的自适应步长缩放因子，并分析其在标准 IEEE-754 算术和模拟的“刷新到零”（FTZ）模式下的行为。\n\n**1. 误差估计 $\\mathrm{err}$ 的推导**\n\n首先，我们推导误差估计 $\\mathrm{err} = \\lvert y_2 - y_1 \\rvert$ 的解析表达式。\n\n单步近似值为：\n$$y_1 = y_n - h \\lambda y_n = y_n(1 - h\\lambda)$$\n\n两个半步的近似值计算如下：\n$$y_{1/2} = y_n + \\frac{h}{2}f(y_n) = y_n - \\frac{h}{2}\\lambda y_n = y_n\\left(1 - \\frac{h\\lambda}{2}\\right)$$\n$$y_2 = y_{1/2} + \\frac{h}{2}f(y_{1/2}) = y_{1/2} - \\frac{h}{2}\\lambda y_{1/2} = y_{1/2}\\left(1 - \\frac{h\\lambda}{2}\\right)$$\n将 $y_{1/2}$ 的表达式代入 $y_2$ 的方程中：\n$$y_2 = y_n\\left(1 - \\frac{h\\lambda}{2}\\right)\\left(1 - \\frac{h\\lambda}{2}\\right) = y_n\\left(1 - h\\lambda + \\frac{h^2\\lambda^2}{4}\\right)$$\n\n现在，我们计算差值 $y_2 - y_1$：\n$$y_2 - y_1 = y_n\\left(1 - h\\lambda + \\frac{h^2\\lambda^2}{4}\\right) - y_n(1 - h\\lambda) = y_n\\left(\\frac{h^2\\lambda^2}{4}\\right)$$\n\n误差估计是这个差值的绝对值：\n$$\\mathrm{err} = \\lvert y_2 - y_1 \\rvert = \\left\\lvert y_n \\frac{h^2\\lambda^2}{4} \\right\\rvert = \\frac{\\lvert y_n \\rvert h^2 \\lambda^2}{4}$$\n这个表达式证实了局部误差估计随步长 $h$ 呈二次方缩放。\n\n**2. 自适应步长缩放因子 $s$**\n\n自适应步长的目标是调整步长 $h$，使局部误差估计满足指定的容差 $\\mathrm{tol}$。设新步长为 $h_{\\text{new}} = s \\cdot h$。新步长的误差 $\\mathrm{err}_{\\text{new}}$ 期望为 $\\mathrm{tol}$。使用二次方缩放关系 $\\mathrm{err} \\propto h^2$：\n$$\\frac{\\mathrm{err}_{\\text{new}}}{\\mathrm{err}} \\approx \\frac{(h_{\\text{new}})^2}{h^2} = \\frac{(s \\cdot h)^2}{h^2} = s^2$$\n设 $\\mathrm{err}_{\\text{new}} = \\mathrm{tol}$，我们得到：\n$$\\frac{\\mathrm{tol}}{\\mathrm{err}} \\approx s^2 \\implies s \\approx \\sqrt{\\frac{\\mathrm{tol}}{\\mathrm{err}}}$$\n问题要求将此缩放因子限制在区间 $[s_{\\min}, s_{\\max}] = [0.1, 10.0]$ 内。因此，计算出的缩放因子为：\n$$s = \\max\\left(0.1, \\min\\left(10.0, \\sqrt{\\frac{\\mathrm{tol}}{\\mathrm{err}}}\\right)\\right)$$\n这个计算仅在 $\\mathrm{err} > 0$ 时才可能。如果 $\\mathrm{err} = 0$，则会发生除零错误。\n\n**3. 浮点行为分析（标准 vs. FTZ）**\n\n问题的核心在于当 $\\mathrm{err}$ 的值非常小时其行为。在 IEEE-754 binary64 标准中，数字以浮点格式表示。\n-   **规格化数（Normal Numbers）：** 其量级大致在 $[2^{-1022}, 2^{1024})$ 范围内。最小的正规格化数是 $N_{\\min} = 2^{-1022}$。\n-   **次正规数（Subnormal/Denormal Numbers）：** 填补了 $0$ 和 $N_{\\min}$ 之间的空隙，允许“逐渐下溢”。其量级在 $(0, 2^{-1022})$ 范围内。\n-   **“刷新到零”（Flush-To-Zero, FTZ）：** 一种可选的算术模式，其中任何导致次正规数结果的运算都会被“刷新”为 $0$。在我们的模拟中，如果 $0  \\mathrm{err}  N_{\\min}$，我们设置 $\\mathrm{err}_{\\text{ftz}}=0$。\n\n如果 FTZ 导致 $\\mathrm{err}$ 变为 $0$，则 $s$ 的计算将涉及除零。支持次正规数的标准算术将计算出一个非常小的非零 $\\mathrm{err}$，从而避免除零错误。\n\n**4. 测试用例分析**\n\n设 $N_{\\min} = 2^{-1022}$。\n\n**情况 1：** $y_n = 1.0, h = 0.1, \\lambda = 1.0, \\mathrm{tol} = 10^{-6}$\n$\\mathrm{err} = \\frac{|1.0| \\cdot (0.1)^2 \\cdot (1.0)^2}{4} = \\frac{0.01}{4} = 0.0025$。\n这是一个规格化数，远大于 $N_{\\min}$。\n-   **无 FTZ：** $s_{\\text{raw}} = \\sqrt{10^{-6} / 0.0025} = \\sqrt{4 \\times 10^{-4}} = 0.02$。限制后得到 $s_{\\text{no\\_ftz}} = \\max(0.1, 0.02) = 0.1$。\n-   **FTZ：** $\\mathrm{err}$ 是规格化数，所以不会被刷新为零。不会发生除零错误。$\\text{ftz\\_div\\_zero} = \\mathrm{False}$。\n-   结果：$[0.1, \\mathrm{False}]$\n\n**情况 2：** $y_n = 2^{-1022}, h = 1.0, \\lambda = 1.0, \\mathrm{tol} = 10^{-12}$\n$\\mathrm{err} = \\frac{|2^{-1022}| \\cdot (1.0)^2 \\cdot (1.0)^2}{4} = \\frac{2^{-1022}}{4} = 2^{-1022} \\cdot 2^{-2} = 2^{-1024}$。\n值 $2^{-1024}$ 小于 $N_{\\min} = 2^{-1022}$ 且大于 $0$，因此它是一个次正规数。\n-   **无 FTZ：** $\\mathrm{err}$ 是一个非常小的正数。$s_{\\text{raw}} = \\sqrt{10^{-12} / 2^{-1024}}$。由于分母极小，$s_{\\text{raw}}$ 将是一个非常大的数。限制后得到 $s_{\\text{no\\_ftz}} = \\min(10.0, s_{\\text{raw}}) = 10.0$。\n-   **FTZ：** 由于 $\\mathrm{err}$ 是次正规数，它被刷新为 $0$。计算 $s$ 变成 $\\sqrt{10^{-12}/0}$，这是一个除零错误。因此，$\\text{ftz\\_div\\_zero} = \\mathrm{True}$。\n-   结果：$[10.0, \\mathrm{True}]$\n\n**情况 3：** $y_n = 10^{-320}, h = 1.0, \\lambda = 1.0, \\mathrm{tol} = 10^{-12}$\n注意 $10^{-320} \\approx (10^3)^{-106.67} \\approx (2^{10})^{-106.67} = 2^{-1066.7}$。这个值小于 $N_{\\min} \\approx 2.225 \\times 10^{-308}$，所以 $y_n$ 本身就是一个次正规数。\n$\\mathrm{err} = \\frac{|10^{-320}| \\cdot (1.0)^2 \\cdot (1.0)^2}{4} = 0.25 \\times 10^{-320}$。\n这个结果也深处于次正规数范围内。\n-   **无 FTZ：** $\\mathrm{err}$ 是一个非常小的正数。$s_{\\text{raw}} = \\sqrt{10^{-12} / (0.25 \\times 10^{-320})}$ 将是一个非常大的数。限制后得到 $s_{\\text{no\\_ftz}} = \\min(10.0, s_{\\text{raw}}) = 10.0$。\n-   **FTZ：** 由于 $\\mathrm{err}$ 是次正规数，它被刷新为 $0$。发生除零错误。$\\text{ftz\\_div\\_zero} = \\mathrm{True}$。\n-   结果：$[10.0, \\mathrm{True}]$\n\n**情况 4：** $y_n = 4 \\cdot 2^{-1022}, h = 1.0, \\lambda = 1.0, \\mathrm{tol} = 10^{-12}$\n$y_n = 2^2 \\cdot 2^{-1022} = 2^{-1020}$，这是一个小的规格化数。\n$\\mathrm{err} = \\frac{|4 \\cdot 2^{-1022}| \\cdot (1.0)^2 \\cdot (1.0)^2}{4} = 2^{-1022}$。\n$\\mathrm{err}$ 的结果恰好是 $N_{\\min}$，即最小的正规格化数。\n-   **无 FTZ：** $\\mathrm{err}$ 是一个小的正数。$s_{\\text{raw}} = \\sqrt{10^{-12} / 2^{-1022}}$ 将是一个非常大的数。限制后得到 $s_{\\text{no\\_ftz}} = \\min(10.0, s_{\\text{raw}}) = 10.0$。\n-   **FTZ：** 刷新的条件是 $0  \\mathrm{err}  N_{\\min}$。这里 $\\mathrm{err} = N_{\\min}$，所以条件不满足。$\\mathrm{err}$ 不会被刷新为零。不会发生除零错误。$\\text{ftz\\_div\\_zero} = \\mathrm{False}$。\n-   结果：$[10.0, \\mathrm{False}]$\n\n实现将遵循此逻辑为每个测试用例计算结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and analyzes an adaptive step-size scale factor for the forward Euler method,\n    focusing on the impact of IEEE-754 subnormal numbers and Flush-To-Zero (FTZ) behavior.\n    \"\"\"\n    \n    # Define constants based on the problem statement.\n    # Smallest positive normal number in binary64.\n    N_min = np.float64(2**-1022)\n    s_min = 0.1\n    s_max = 10.0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path)\n        (np.float64(1.0), np.float64(0.1), np.float64(1.0), np.float64(1e-6)),\n        # Case 2 (boundary into subnormal)\n        (N_min, np.float64(1.0), np.float64(1.0), np.float64(1e-12)),\n        # Case 3 (extreme underflow)\n        (np.float64(1e-320), np.float64(1.0), np.float64(1.0), np.float64(1e-12)),\n        # Case 4 (threshold normal error)\n        (np.float64(4 * N_min), np.float64(1.0), np.float64(1.0), np.float64(1e-12)),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        y_n, h, lam, tol = case\n\n        # Compute the one-step approximation y1\n        y1 = y_n - h * lam * y_n\n\n        # Compute the two half-steps approximation y2\n        y_half = y_n - (h / 2.0) * lam * y_n\n        y2 = y_half - (h / 2.0) * lam * y_half\n\n        # Compute the local error estimate\n        err = np.abs(y2 - y1)\n\n        # --- Part 1: No-FTZ (standard behavior with subnormals) ---\n        \n        # Check if err is exactly zero to avoid division by zero.\n        # This would happen if y_n=0. For non-zero y_n, err is non-zero.\n        # If error is zero, the step is perfect; can increase to maximum.\n        if err == 0.0:\n            s_no_ftz = s_max\n        else:\n            # Calculate the raw scale factor\n            s_raw = np.sqrt(tol / err)\n            # Clamp the scale factor to the specified interval\n            s_no_ftz = max(s_min, min(s_max, s_raw))\n\n        # --- Part 2: FTZ (emulated behavior) ---\n\n        # Emulate FTZ: if err is subnormal, flush it to zero.\n        # A number x is subnormal if 0  |x|  N_min.\n        err_ftz = 0.0 if (0  err  N_min) else err\n\n        # Check if a division by zero would occur when computing the scale factor.\n        # This happens if the error used in the denominator is zero.\n        # tol is guaranteed to be non-zero in all test cases.\n        ftz_div_zero = (err_ftz == 0.0)\n        \n        results.append([s_no_ftz, ftz_div_zero])\n\n    # Final print statement in the exact required format.\n    # e.g., [[s1,b1],[s2,b2],...] with no spaces inside inner brackets.\n    # Python's str(True) is \"True\", which is a valid representation.\n    output_parts = [f\"[{s},{str(b)}]\" for s, b in results]\n    print(f\"[{','.join(output_parts)}]\")\n\nsolve()\n```", "id": "3109800"}]}