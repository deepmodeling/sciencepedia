{"hands_on_practices": [{"introduction": "在科学研究中，我们常常需要理解一个新变量的分布，而这个新变量是某个已知随机变量的函数。本练习将探讨最简单的情形：线性变换。我们将利用累积分布函数（CDF）的基本定义来推导新变量的CDF，这个过程将巩固你对CDF定义的理解，并训练你在概率表达式中处理不等式的技巧。[@problem_id:1416764]", "problem": "在一个研究一维粒子扩散的实验中，一个粒子的最终位置由连续随机变量 $X$ 描述。该粒子被限制在区间 $[0, 2]$ 上运动。其位置由累积分布函数 (CDF) $F_X(x)$ 表征，具体如下：\n$$\nF_X(x) = \\begin{cases}\n0,  x  0 \\\\\n\\frac{x^2}{4},  0 \\le x  2 \\\\\n1,  x \\ge 2\n\\end{cases}\n$$\n一个测量设备记录该粒子的位置，但带有一个符号反转，从而产生一个新的随机变量 $Y = -X$。\n\n以下哪项表示随机变量 $Y$ 的累积分布函数 (CDF) $F_Y(y)$？\n\nA. $F_Y(y) = \\begin{cases} 0,  y \\le -2 \\\\ 1 - \\frac{y^2}{4},  -2  y \\le 0 \\\\ 1,  y  0 \\end{cases}$\n\nB. $F_Y(y) = \\begin{cases} 0,  y  -2 \\\\ \\frac{(y+2)^2}{4},  -2 \\le y  0 \\\\ 1,  y \\ge 0 \\end{cases}$\n\nC. $F_Y(y) = \\begin{cases} 0,  y  0 \\\\ 1-\\frac{(2-y)^2}{4},  0 \\le y  2 \\\\ 1,  y \\ge 2 \\end{cases}$\n\nD. $F_Y(y) = \\begin{cases} 0,  y  0 \\\\ \\frac{y^2}{4},  0 \\le y  2 \\\\ 1,  y \\ge 2 \\end{cases}$", "solution": "给定一个支撑集在 $[0,2]$ 上的连续随机变量 $X$，其累积分布函数为\n$$\nF_{X}(x)=\\begin{cases}\n0,  x  0 \\\\\n\\frac{x^{2}}{4},  0\\le x  2 \\\\\n1,  x\\ge 2\n\\end{cases}\n$$\n以及一个变换后的随机变量 $Y=-X$。我们要求解其累积分布函数 $F_{Y}(y)=\\mathbb{P}(Y\\le y)$。\n\n首先，确定 $Y$ 的支撑集。由于 $X\\in[0,2]$，可得 $Y=-X\\in[-2,0]$。\n\n对任意实数 $y$，根据累积分布函数的定义以及单调变换 $Y=-X$（这是一个严格递减的变换），我们有\n$$\nF_{Y}(y)=\\mathbb{P}(Y\\le y)=\\mathbb{P}(-X\\le y)=\\mathbb{P}(X\\ge -y).\n$$\n对于连续随机变量 $X$（这里 $F_{X}$ 是连续的），使用关系式 $\\mathbb{P}(X\\ge a)=1-F_{X}(a)$，我们对于 $-y$ 位于支撑集内的值得到，\n$$\nF_{Y}(y)=1-F_{X}(-y).\n$$\n\n现在根据 $Y$ 的支撑集，在实数线上进行分段求解。\n\n- 如果 $y  -2$，则 $-y > 2$。因此，$F_Y(y) = 1 - F_X(-y) = 1 - 1 = 0$。\n\n- 如果 $-2 \\le y  0$，则 $0  -y \\le 2$。因此，$F_Y(y) = 1 - F_X(-y) = 1 - \\frac{(-y)^2}{4} = 1 - \\frac{y^2}{4}$。\n\n- 如果 $y \\ge 0$，则 $-y \\le 0$。因此，$F_Y(y) = 1 - F_X(-y) = 1 - 0 = 1$。\n\n为了确保我们的分段函数在边界点上是正确的，并符合右连续性的要求，我们来检查 $y=-2$ 和 $y=0$ 的情况。\n\n- 在 $y=-2$ 处：$F_Y(-2) = 1 - \\frac{(-2)^2}{4} = 1 - 1 = 0$。这与 $y  -2$ 时的值一致，函数在此处是连续的。\n- 在 $y=0$ 处：$\\lim_{y \\to 0^-} F_Y(y) = \\lim_{y \\to 0^-} (1 - \\frac{y^2}{4}) = 1$。对于 $y \\ge 0$，$F_Y(y) = 1$。所以 $F_Y(0) = 1$。\n\n综合起来，我们得到的CDF是：\n$$\nF_Y(y) = \\begin{cases}\n0,  y  -2 \\\\\n1 - \\frac{y^2}{4},  -2 \\le y  0 \\\\\n1,  y \\ge 0\n\\end{cases}\n$$\n这与选项A的表达式在每个区间上的定义相匹配，除了在边界点 $y=-2$ 和 $y=0$ 处的包含关系。然而，对于连续随机变量的CDF，在单个点上的值不影响其整体，并且选项A最接近我们推导出的函数。仔细观察选项A：$F_Y(y) = \\begin{cases} 0,  y \\le -2 \\\\ 1 - \\frac{y^2}{4},  -2  y \\le 0 \\\\ 1,  y > 0 \\end{cases}$。这个形式也是正确的，因为它在 $y=0$ 处右连续 ($F_Y(0) = 1 - 0 = 1$，$\\lim_{y\\to 0^+} F_Y(y)=1$)，并且在 $y=-2$ 处也是连续的 ($\\lim_{y\\to -2^+} F_Y(y) = 1-1=0$, $F_Y(-2)=0$)。因此，选项A是正确的答案。", "answer": "$$\\boxed{A}$$", "id": "1416764"}, {"introduction": "在上一个练习的基础上，我们现在来探索一个更复杂的场景：非单调变换。当应用像 $Y=X^2$ 这样的函数时，多个不同的 $X$ 值可能会映射到同一个 $Y$ 值，这在推导新变量的CDF时需要我们更加审慎地考虑。这个问题对于培养你准确确定变换后变量事件空间的稳固理解至关重要。[@problem_id:1416753]", "problem": "设 $X$ 是一个连续随机变量，其累积分布函数 (CDF) $F_X(x)$ 由以下分段表达式给出：\n$$\nF_X(x) =\n\\begin{cases}\n0  \\text{for } x \\le -1 \\\\\n\\frac{1}{2}(x+1)^2  \\text{for } -1  x \\le 0 \\\\\n1 - \\frac{1}{2}(1-x)^2  \\text{for } 0  x \\le 1 \\\\\n1  \\text{for } x  1\n\\end{cases}\n$$\n一个新的随机变量 $Y$ 由变换 $Y = X^2$ 定义。求随机变量 $Y$ 的累积分布函数 $F_Y(y)$。答案应以 $F_Y(y)$ 的单个闭式解析表达式的形式呈现，该表达式可以是分段定义的。", "solution": "给定一个支撑集在 $[-1,1]$ 上的连续随机变量 $X$，其累积分布函数为\n$$\nF_{X}(x)=\n\\begin{cases}\n0  \\text{for } x \\le -1 \\\\\n\\frac{1}{2}(x+1)^{2}  \\text{for } -1  x \\le 0 \\\\\n1 - \\frac{1}{2}(1-x)^{2}  \\text{for } 0  x \\le 1 \\\\\n1  \\text{for } x  1\n\\end{cases}\n$$\n定义 $Y=X^{2}$。因为 $|X| \\le 1$，所以 $Y$ 的支撑集是 $[0,1]$。对于任意 $y \\in \\mathbb{R}$，$Y$ 的累积分布函数为\n$$\nF_{Y}(y)=\\mathbb{P}(Y \\le y)=\\mathbb{P}(X^{2} \\le y).\n$$\n- 若 $y  0$，那么事件 $X^2 \\le y$ 不可能发生，所以 $F_Y(y)=0$。\n- 若 $y \\ge 1$，那么因为 $X$ 的支撑集是 $[-1,1]$，事件 $X^2 \\le y$ 必然发生，所以 $F_Y(y)=1$。\n- 对于 $0 \\le y  1$，我们有：\n$$\nF_Y(y) = \\mathbb{P}(X^2 \\le y) = \\mathbb{P}(-\\sqrt{y} \\le X \\le \\sqrt{y})\n$$\n根据CDF的定义，对于连续随机变量，这等于 $F_X(\\sqrt{y}) - F_X(-\\sqrt{y})$。\n由于 $y \\in [0, 1)$，我们有 $\\sqrt{y} \\in [0, 1)$ 和 $-\\sqrt{y} \\in (-1, 0]$。\n我们将使用 $F_X(x)$ 的相应分段定义：\n对于 $\\sqrt{y} \\in [0, 1)$，我们使用 $F_X(x) = 1 - \\frac{1}{2}(1-x)^2$。\n$$ F_X(\\sqrt{y}) = 1 - \\frac{1}{2}(1-\\sqrt{y})^2 $$\n对于 $-\\sqrt{y} \\in (-1, 0]$，我们使用 $F_X(x) = \\frac{1}{2}(x+1)^2$。\n$$ F_X(-\\sqrt{y}) = \\frac{1}{2}(-\\sqrt{y}+1)^2 = \\frac{1}{2}(1-\\sqrt{y})^2 $$\n现在将它们相减：\n$$\nF_Y(y) = F_X(\\sqrt{y}) - F_X(-\\sqrt{y}) = \\left(1 - \\frac{1}{2}(1-\\sqrt{y})^2\\right) - \\left(\\frac{1}{2}(1-\\sqrt{y})^2\\right)\n$$\n$$\nF_Y(y) = 1 - (1-\\sqrt{y})^2 = 1 - (1 - 2\\sqrt{y} + y) = 2\\sqrt{y} - y\n$$\n将所有分段组合在一起，我们得到 $Y$ 的累积分布函数：\n$$\nF_{Y}(y)=\n\\begin{cases}\n0,  y \\le 0 \\\\\n2\\sqrt{y}-y,  0  y \\le 1 \\\\\n1,  y > 1\n\\end{cases}\n$$", "answer": "$$\\boxed{\nF_{Y}(y)=\n\\begin{cases}\n0,  y \\le 0 \\\\\n2\\sqrt{y}-y,  0  y \\le 1 \\\\\n1,  y > 1\n\\end{cases}\n}$$", "id": "1416753"}, {"introduction": "最后的这项实践将连接理论概率与计算科学的鸿沟。我们将处理一个“混合”随机变量，它既包含连续部分，也包含离散的跳跃点，这在现实世界的模型中很常见。我们的目标是推导它的CDF，然后是其“广义反函数CDF”，这是最基本的模拟算法之一——逆变换采样法（Inverse Transform Sampling）的关键。通过实现该方法，你将亲眼见证对分布函数的深刻理解如何使我们能够生成遵循几乎任何数学上可描述分布的随机数。[@problem_id:3183232]", "problem": "设 $X$ 是一个混合随机变量，其分布由一个具有分段定义的概率密度函数 (PDF) 的绝对连续部分和两个点质量峰 (原子) 组成。使用以下基本定义作为基础：\n- $X$ 的累积分布函数 (CDF) 为 $F_X(x) = \\mathbb{P}(X \\le x)$。\n- 当 $X$ 是绝对连续时，$F_X$ 是可导的，其导数等于概率密度函数：$f_X(x) = \\frac{d}{dx}F_X(x)$。\n- 在位于 $x_0$ 的任意原子处，CDF 的跳跃幅度为 $F_X(x_0) - F_X(x_0^-) = \\mathbb{P}(X = x_0)$。\n- 广义逆累积分布函数 (也称为分位数函数) 为 $F_X^{-1}(u) = \\inf\\{x \\in \\mathbb{R} : F_X(x) \\ge u\\}$，其中 $u \\in [0,1]$。\n- 逆变换采样法使用一个均匀分布随机变量 (URV) $U \\sim \\mathrm{Uniform}(0,1)$，并设置 $X = F_X^{-1}(U)$。\n\n$X$ 的分布规定如下：\n- 具有 PDF $f_X(x)$ 的连续部分：\n  1. 对于 $x \\in [0,1)$，$f_X(x) = a$，其中 $a = 0.4$。\n  2. 对于 $x \\in [1,2)$，$f_X(x) = b\\,(2-x)$，其中 $b = 0.8$。\n- 两个原子 (峰)：\n  1. 在 $x = 0.5$ 处，质量为 $p_1 = 0.1$。\n  2. 在 $x = 2$ 处，质量为 $p_2 = 0.1$。\n\n任务：\n1. 严格从上述基本定义出发，推导出对于所有实数 $x$ 的 CDF $F_X(x)$ 的完整分段表达式。您的推导必须正确处理在区间 $[0,1)$ 和 $[1,2)$ 上的连续累积，以及在 $x=0.5$ 和 $x=2$ 处大小分别为 $p_1$ 和 $p_2$ 的跳跃。\n2. 仅使用定义 $F_X^{-1}(u) = \\inf\\{x : F_X(x) \\ge u\\}$，推导出在 $u \\in [0,1]$ 上广义逆 CDF $F_X^{-1}(u)$ 的完整分段解析表达式。您的表达式必须明确处理 $F_X$ 在对应于 $x=0.5$ 和 $x=2$ 处跳跃的 $u$ 值上的不连续性。\n3. 实现一个程序，该程序：\n   - 计算并使用您推导出的 $F_X^{-1}(u)$，在给定 $U \\sim \\mathrm{Uniform}(0,1)$ 的情况下，通过逆变换采样法对 $X$ 进行采样。\n   - 通过检查特定的 $u$ 值是否映射到原子位置，以及通过经验性地验证五个不相交集合的概率来验证其在不连续点上的正确性。这五个集合以一种分离连续区域和原子的方式划分了支撑集：\n     - $S_1 = \\{X  0.5\\}$，期望概率为 $0.2$。\n     - $S_2 = \\{X = 0.5\\}$，期望概率为 $0.1$。\n     - $S_3 = \\{0.5  X  1\\}$，期望概率为 $0.2$。\n     - $S_4 = \\{1 \\le X  2\\}$，期望概率为 $0.4$。\n     - $S_5 = \\{X = 2\\}$，期望概率为 $0.1$。\n   - 使用一个容差参数 $\\varepsilon$，如果 $S_1,\\dots,S_5$ 中经验概率与理论概率之间的最大绝对偏差小于或等于 $\\varepsilon$，则宣布经验验证成功。\n\n测试套件：\n- 情况 1 (确定性峰值映射)：验证 $u$ 取值 $[0.2, 0.25, 0.3, 0.9, 0.95, 1.0]$ 时，$F_X^{-1}(u)$ 分别等于 $[0.5, 0.5, 0.5, 2, 2, 2]$。\n- 情况 2 (采样，中等规模)：使用种子 $123$ 和容差 $\\varepsilon = 0.02$ 采样 $N=5000$ 个值；返回一个布尔值，指示所有五个集合 $S_1$–$S_5$ 是否同时通过测试。\n- 情况 3 (采样，较大规模)：使用种子 $456$ 和容差 $\\varepsilon = 0.005$ 采样 $N=50000$ 个值；返回一个布尔值，指示所有五个集合 $S_1$–$S_5$ 是否同时通过测试。\n- 情况 4 (分位数的单调性)：检查 $F_X^{-1}(u)$ 在网格 $[0.0, 0.1, 0.19, 0.2, 0.25, 0.3, 0.31, 0.49, 0.5, 0.7, 0.89, 0.9, 0.95, 1.0]$ 上是否为非递减的。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果 (例如，\"[result1,result2,result3,result4]\")。每个结果必须是一个布尔值，按给定顺序指示相应测试用例的通过或失败。\n- 不得打印任何额外文本。", "solution": "该问题要求推导混合随机变量 $X$ 的累积分布函数 (CDF) $F_X(x)$ 及其广义逆函数 $F_X^{-1}(u)$，然后通过编程实现来验证推导结果。\n\n随机变量 $X$ 的分布由一个具有密度函数 $f_X(x)$ 的绝对连续部分和包含两个原子的离散部分组成。总概率必须等于 $1$。首先，我们验证此条件。\n连续部分的总概率为：\n$$\nP_c = \\int_0^1 a \\,dx + \\int_1^2 b(2-x) \\,dx\n$$\n给定 $a=0.4$ 和 $b=0.8$：\n$$\nP_c = \\int_0^1 0.4 \\,dx + \\int_1^2 0.8(2-x) \\,dx = 0.4[x]_0^1 + 0.8\\left[2x - \\frac{x^2}{2}\\right]_1^2\n$$\n$$\nP_c = 0.4(1-0) + 0.8\\left( (4-2) - (2 - \\frac{1}{2}) \\right) = 0.4 + 0.8\\left(2 - \\frac{3}{2}\\right) = 0.4 + 0.8(0.5) = 0.4 + 0.4 = 0.8\n$$\n离散原子的总概率是其质量之和：\n$$\nP_d = p_1 + p_2 = 0.1 + 0.1 = 0.2\n$$\n总概率为 $P_{total} = P_c + P_d = 0.8 + 0.2 = 1.0$。该分布是有效的。\n\n### 第 1 部分：累积分布函数 (CDF) $F_X(x)$ 的推导\n\n我们通过在 $X$ 的定义域上累积概率质量来推导 CDF $F_X(x) = \\mathbb{P}(X \\le x)$。对于混合随机变量，这涉及到对概率密度函数 $f_X(x)$ 进行积分，并加上位于小于或等于 $x$ 的位置上所有原子的质量。\n\n1.  **对于 $x  0$**：$X$ 的支撑集在 $[0, 2]$上。因此，$\\mathbb{P}(X \\le x) = 0$。\n\n2.  **对于 $0 \\le x  0.5$**：概率仅从连续密度 $f_X(t) = 0.4$ 累积。\n    $F_X(x) = \\int_{0}^x 0.4 \\,dt = 0.4x$。\n\n3.  **在 $x = 0.5$ 处**：存在一个质量为 $p_1 = 0.1$ 的原子。CDF 在此点发生跳跃。\n    跳跃前的值为 $F_X(0.5^-) = \\lim_{t \\uparrow 0.5} F_X(t) = 0.4(0.5) = 0.2$。\n    在 $x=0.5$ 处的 CDF 为 $F_X(0.5) = F_X(0.5^-) + \\mathbb{P}(X=0.5) = 0.2 + p_1 = 0.2 + 0.1 = 0.3$。\n\n4.  **对于 $0.5 \\le x  1$**：概率是直到并包括 $x=0.5$ 的质量之和，再加上在 $(0.5, x]$ 上从密度 $f_X(t)=0.4$ 累积的概率。\n    $F_X(x) = F_X(0.5) + \\int_{0.5}^x 0.4 \\,dt = 0.3 + 0.4(x - 0.5) = 0.3 + 0.4x - 0.2 = 0.4x + 0.1$。\n\n5.  **对于 $1 \\le x  2$**：由于在 $x=1$ 处没有原子，CDF 在此点是连续的。\n    $F_X(1) = 0.4(1) + 0.1 = 0.5$。\n    对于 $x \\in [1, 2)$，我们加上从密度 $f_X(t) = 0.8(2-t)$ 累积的概率。\n    $F_X(x) = F_X(1) + \\int_1^x 0.8(2-t) \\,dt = 0.5 + 0.8\\left[2t - \\frac{t^2}{2}\\right]_1^x$\n    $F_X(x) = 0.5 + 0.8\\left( (2x - \\frac{x^2}{2}) - (2 - \\frac{1}{2}) \\right) = 0.5 + 0.8\\left(2x - \\frac{x^2}{2} - \\frac{3}{2}\\right)$\n    $F_X(x) = 0.5 + 1.6x - 0.4x^2 - 1.2 = -0.4x^2 + 1.6x - 0.7$。\n\n6.  **在 $x = 2$ 处**：存在一个质量为 $p_2 = 0.1$ 的原子。CDF 再次发生跳跃。\n    跳跃前的值为 $F_X(2^-) = \\lim_{t \\uparrow 2} (-0.4t^2 + 1.6t - 0.7) = -0.4(4) + 1.6(2) - 0.7 = -1.6 + 3.2 - 0.7 = 0.9$。\n    在 $x=2$ 处的 CDF 为 $F_X(2) = F_X(2^-) + \\mathbb{P}(X=2) = 0.9 + p_2 = 0.9 + 0.1 = 1.0$。\n\n7.  **对于 $x > 2$**：所有概率都已被计算在内，故 $F_X(x) = 1.0$。\n\n综合这些部分，完整的 CDF 为：\n$$\nF_X(x) = \\begin{cases}\n0,  \\text{if } x  0 \\\\\n0.4x,  \\text{if } 0 \\le x  0.5 \\\\\n0.4x + 0.1,  \\text{if } 0.5 \\le x  1 \\\\\n-0.4x^2 + 1.6x - 0.7,  \\text{if } 1 \\le x  2 \\\\\n1,  \\text{if } x \\ge 2\n\\end{cases}\n$$\n\n### 第 2 部分：广义逆 CDF $F_X^{-1}(u)$ 的推导\n\n我们通过对分段 CDF $F_X(x)$ 的每个分段进行求逆，来推导广义逆 CDF $F_X^{-1}(u) = \\inf\\{x \\in \\mathbb{R} : F_X(x) \\ge u\\}$，其中 $u \\in [0, 1]$。\n\n1.  **对于 $u \\in [0, 0.2)$**：这对应于 $x \\in [0, 0.5)$。我们对 $u = 0.4x$ 求逆。\n    $x = u / 0.4 = 2.5u$。所以，$F_X^{-1}(u) = 2.5u$。\n\n2.  **对于 $u \\in [0.2, 0.3]$**：这个 $u$ 的范围对应于 $F_X$ 在 $x=0.5$ 处的跳跃。\n    $F_X(0.5^-)=0.2$ 且 $F_X(0.5)=0.3$。对于任何 $u \\in [0.2, 0.3]$，集合 $\\{x : F_X(x) \\ge u\\}$ 是 $[0.5, \\infty)$。这个集合的下确界是 $0.5$。\n    因此，$F_X^{-1}(u) = 0.5$。\n\n3.  **对于 $u \\in (0.3, 0.5]$**：这对应于 $x \\in (0.5, 1]$。我们对 $u = 0.4x + 0.1$ 求逆。\n    $0.4x = u - 0.1 \\implies x = (u - 0.1)/0.4 = 2.5u - 0.25$。\n    所以，$F_X^{-1}(u) = 2.5u - 0.25$。\n\n4.  **对于 $u \\in (0.5, 0.9]$**：这对应于 $x \\in (1, 2]$。我们对 $u = -0.4x^2 + 1.6x - 0.7$ 求逆。\n    重新整理得到一个关于 $x$ 的二次方程：$0.4x^2 - 1.6x + (u+0.7) = 0$。\n    使用求根公式，$x = \\frac{1.6 \\pm \\sqrt{1.6^2 - 4(0.4)(u+0.7)}}{2(0.4)} = \\frac{1.6 \\pm \\sqrt{2.56 - 1.6u - 1.12}}{0.8} = \\frac{1.6 \\pm \\sqrt{1.44 - 1.6u}}{0.8}$。\n    这简化为 $x = 2 \\pm \\frac{\\sqrt{1.44 - 1.6u}}{0.8} = 2 \\pm \\sqrt{2.25 - 2.5u}$。\n    因为 $x$ 必须在区间 $(1, 2]$ 内，我们必须选择负根。\n    $F_X^{-1}(u) = 2 - \\sqrt{2.25 - 2.5u}$。\n\n5.  **对于 $u \\in (0.9, 1.0]$**：这个 $u$ 的范围对应于在 $x=2$ 处的跳跃。\n    $F_X(2^-)=0.9$ 且 $F_X(2)=1.0$。对于任何 $u \\in (0.9, 1.0]$，集合 $\\{x : F_X(x) \\ge u\\}$ 是 $[2, \\infty)$。这个集合的下确界是 $2$。\n    因此，$F_X^{-1}(u) = 2$。\n\n综合这些部分，完整的逆 CDF 为：\n$$\nF_X^{-1}(u) = \\begin{cases}\n2.5u,  \\text{if } 0 \\le u  0.2 \\\\\n0.5,  \\text{if } 0.2 \\le u \\le 0.3 \\\\\n2.5u - 0.25,  \\text{if } 0.3  u \\le 0.5 \\\\\n2 - \\sqrt{2.25 - 2.5u},  \\text{if } 0.5  u \\le 0.9 \\\\\n2,  \\text{if } 0.9  u \\le 1.0\n\\end{cases}\n$$\n\n### 第 3 部分：实现\n\n推导出的 $F_X^{-1}(u)$ 表达式在 Python 中得以实现。该函数接收一个均匀随机变量样本 $u$，并从 $X$ 的分布中返回一个样本 $x$。然后，此函数用于执行问题陈述中描述的验证测试。代码定义了分段逆 CDF，然后执行四个测试用例：确定性峰值映射、两个具有不同样本量和容差的采样验证，以及一个单调性检查。这些布尔测试的结果被收集并以指定格式打印出来。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the solution by deriving the inverse CDF, and then running the specified test cases.\n    \"\"\"\n\n    def inverse_cdf_scalar(u):\n        \"\"\"\n        Computes the generalized inverse CDF F_X^{-1}(u) for a scalar u.\n        This function implements the piecewise formula derived in the solution.\n        \"\"\"\n        if u  0.0:\n            # Although u should be in [0,1], handle out-of-bounds for robustness.\n            return 0.0\n        elif u  0.2:\n            # Corresponds to x in [0, 0.5)\n            return 2.5 * u\n        elif u = 0.3:\n            # Corresponds to the atom at x = 0.5\n            return 0.5\n        elif u = 0.5:\n            # Corresponds to x in [0.5, 1)\n            return 2.5 * u - 0.25\n        elif u = 0.9:\n            # Corresponds to x in [1, 2)\n            # This is the solution to 0.4x^2 - 1.6x + (u+0.7) = 0\n            return 2.0 - np.sqrt(2.25 - 2.5 * u)\n        else: # u > 0.9\n            # Corresponds to the atom at x = 2 and u >= 1\n            return 2.0\n\n    # Vectorize the scalar function for efficient application to numpy arrays.\n    inverse_cdf = np.vectorize(inverse_cdf_scalar)\n\n    results = []\n\n    # Case 1: Deterministic spike mapping\n    u_vals_1 = np.array([0.2, 0.25, 0.3, 0.9, 0.95, 1.0])\n    expected_x = np.array([0.5, 0.5, 0.5, 2.0, 2.0, 2.0])\n    actual_x = inverse_cdf(u_vals_1)\n    # Use np.allclose for safe floating-point comparison\n    results.append(np.allclose(actual_x, expected_x))\n\n    def run_sampling_test(N, seed, epsilon):\n        \"\"\"\n        Helper function for Cases 2 and 3.\n        Generates N samples and validates their distribution against expected probabilities.\n        \"\"\"\n        np.random.seed(seed)\n        u_samples = np.random.rand(N)\n        x_samples = inverse_cdf(u_samples)\n\n        # Calculate empirical probabilities for the five disjoint sets.\n        # The comparisons are exact since the inverse CDF returns exact values for atoms.\n        p1_emp = np.sum(x_samples  0.5) / N   # S1: X  0.5\n        p2_emp = np.sum(x_samples == 0.5) / N  # S2: X = 0.5\n        p3_emp = np.sum((x_samples > 0.5)  (x_samples  1.0)) / N # S3: 0.5  X  1\n        p4_emp = np.sum((x_samples >= 1.0)  (x_samples  2.0)) / N # S4: 1 = X  2\n        p5_emp = np.sum(x_samples == 2.0) / N  # S5: X = 2\n\n        p_emp = np.array([p1_emp, p2_emp, p3_emp, p4_emp, p5_emp])\n        p_exp = np.array([0.2, 0.1, 0.2, 0.4, 0.1])\n        \n        # Check if the maximum absolute deviation is within the tolerance.\n        max_deviation = np.max(np.abs(p_emp - p_exp))\n        return max_deviation = epsilon\n\n    # Case 2: Sampling, moderate size\n    results.append(run_sampling_test(N=5000, seed=123, epsilon=0.02))\n\n    # Case 3: Sampling, larger size\n    results.append(run_sampling_test(N=50000, seed=456, epsilon=0.005))\n    \n    # Case 4: Monotonicity of the quantile function\n    u_grid = np.array([0.0, 0.1, 0.19, 0.2, 0.25, 0.3, 0.31, 0.49, 0.5, 0.7, 0.89, 0.9, 0.95, 1.0])\n    x_vals = inverse_cdf(u_grid)\n    # Check if the sequence of x values is non-decreasing using np.diff.\n    # A small tolerance is used for floating point arithmetic safety.\n    is_monotonic = np.all(np.diff(x_vals) >= -1e-9)\n    results.append(is_monotonic)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, [bool(r) for r in results]))}]\")\n\nsolve()\n```", "id": "3183232"}]}