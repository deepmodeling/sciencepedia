{"hands_on_practices": [{"introduction": "第一个练习将多项式混沌展开的核心理论与一个基本的统计概念直接联系起来。通过解析计算一个简单非线性函数的零阶PCE系数，我们将证明一个关键性质：该系数精确等于此函数的数学期望。这个练习旨在巩固您的理解，即PCE不仅是一个任意的多项式拟合，更是一种与底层随机变量的矩（moments）紧密相关的结构化展开。[@problem_id:3174309]", "problem": "考虑一个标量输入随机变量 $\\xi$，其概率密度函数在区间 $[0,1]$ 上为 $p_{\\xi}(x)=1$，在其他情况下为 $p_{\\xi}(x)=0$，因此 $\\xi$ 在 $[0,1]$ 上均匀分布。定义非线性变换 $f(\\xi)=\\sin(a\\,\\xi)$，其中 $a>0$ 是一个固定参数。使用多项式混沌展开 (PCE) 框架，基函数为在 $[0,1]$ 上关于权重 $p_{\\xi}(x)=1$ 的标准正交移位 Legendre 多项式 $\\{\\phi_{n}(x)\\}_{n\\geq 0}$，完成以下任务：\n\n1. 从 PCE 的定义和基 $\\{\\phi_{n}\\}$ 关于由 $p_{\\xi}$ 导出的内积的标准正交性出发，推导展开 $f(\\xi)$ 时与零阶模态（常数基函数）相关的系数的表达式。\n2. 使用此系数，通过在多项式阶数 3 处截断的 PCE 来近似期望 $\\mathbb{E}[\\sin(a\\,\\xi)]$。\n3. 独立地，从第一性原理出发，使用期望作为关于 $p_{\\xi}$ 的积分的定义，推导 $\\mathbb{E}[\\sin(a\\,\\xi)]$ 的精确解析表达式。\n4. 当 $a=\\pi$ 时，计算所得期望值，并以纯小数形式给出最终数值。\n\n将您的最终数值答案四舍五入到四位有效数字。不涉及物理单位。", "solution": "问题陈述已经过验证，被认为是合理、适定且有科学依据的。我们可以开始解答。\n\n问题要求分析函数 $f(\\xi) = \\sin(a\\,\\xi)$，其中 $\\xi$ 是在区间 $[0, 1]$ 上均匀分布的随机变量。因此，$\\xi$ 的概率密度函数 (PDF) 为当 $x \\in [0, 1]$ 时 $p_{\\xi}(x) = 1$，其他情况下为 $p_{\\xi}(x) = 0$。我们使用多项式混沌展开 (PCE)，其基为在 $[0,1]$ 上的标准正交移位 Legendre 多项式 $\\{\\phi_n(x)\\}_{n \\ge 0}$。\n\n关于权重函数 $w(x) = p_{\\xi}(x) = 1$ 的内积定义为：\n$$ \\langle g, h \\rangle = \\int_{0}^{1} g(x) h(x) w(x) \\,dx = \\int_{0}^{1} g(x) h(x) \\,dx $$\n基函数的标准正交性意味着 $\\langle \\phi_n, \\phi_m \\rangle = \\delta_{nm}$，其中 $\\delta_{nm}$ 是克罗内克 δ。\n\n函数 $f(\\xi)$ 的 PCE 由以下级数展开给出：\n$$ f(\\xi) = \\sum_{n=0}^{\\infty} c_n \\phi_n(\\xi) $$\n其中系数 $c_n$ 通过将函数 $f$ 投影到基函数上确定：\n$$ c_n = \\langle f, \\phi_n \\rangle = \\int_{0}^{1} f(x) \\phi_n(x) \\,dx $$\n\n**1. 零阶系数 ($c_0$) 的推导**\n\n第一个任务是找到系数 $c_0$ 的表达式，它对应于零阶基函数 $\\phi_0(x)$。零阶移位 Legendre 多项式是一个常数，我们将其标准（非归一化）多项式表示为 $P_0^*(x) = 1$。为了找到标准正交基函数 $\\phi_0(x)$，我们必须对 $P_0^*(x)$ 进行归一化。设 $\\phi_0(x) = k$，其中 $k$ 为某个常数。归一化条件为 $\\langle \\phi_0, \\phi_0 \\rangle = 1$。\n$$ \\int_{0}^{1} (k)^2 \\,dx = 1 $$\n$$ k^2 \\int_{0}^{1} 1 \\,dx = 1 $$\n$$ k^2 [x]_{0}^{1} = 1 \\implies k^2 (1 - 0) = 1 \\implies k^2 = 1 $$\n我们选择正根，所以 $k=1$。因此，零阶标准正交基函数为 $\\phi_0(x) = 1$。\n\n现在，我们可以使用其定义来计算系数 $c_0$：\n$$ c_0 = \\langle f, \\phi_0 \\rangle = \\int_{0}^{1} f(x) \\phi_0(x) \\,dx = \\int_{0}^{1} \\sin(a\\,x) \\cdot 1 \\,dx $$\n此积分计算如下：\n$$ c_0 = \\left[ -\\frac{1}{a} \\cos(a\\,x) \\right]_{0}^{1} = -\\frac{1}{a} (\\cos(a \\cdot 1) - \\cos(a \\cdot 0)) $$\n由于 $\\cos(0) = 1$，我们得到：\n$$ c_0 = -\\frac{1}{a} (\\cos(a) - 1) = \\frac{1 - \\cos(a)}{a} $$\n这就是零阶系数的表达式。\n\n**2. 期望 $\\mathbb{E}[\\sin(a\\,\\xi)]$ 的 PCE 近似**\n\n在多项式阶数 $P$ 处截断的 PCE 提供了函数 $f(\\xi)$ 的一个近似，记作 $f_P(\\xi)$：\n$$ f_P(\\xi) = \\sum_{n=0}^{P} c_n \\phi_n(\\xi) $$\n这个近似的期望由下式给出：\n$$ \\mathbb{E}[f_P(\\xi)] = \\mathbb{E}\\left[\\sum_{n=0}^{P} c_n \\phi_n(\\xi)\\right] $$\n根据期望算子的线性性：\n$$ \\mathbb{E}[f_P(\\xi)] = \\sum_{n=0}^{P} c_n \\mathbb{E}[\\phi_n(\\xi)] $$\n基函数 $\\phi_n(\\xi)$ 的期望是：\n$$ \\mathbb{E}[\\phi_n(\\xi)] = \\int_{-\\infty}^{\\infty} \\phi_n(x) p_{\\xi}(x) \\,dx = \\int_{0}^{1} \\phi_n(x) \\cdot 1 \\,dx $$\n回顾 $\\phi_0(x) = 1$，我们可以将此积分写成内积形式：\n$$ \\mathbb{E}[\\phi_n(\\xi)] = \\int_{0}^{1} \\phi_n(x) \\phi_0(x) \\,dx = \\langle \\phi_n, \\phi_0 \\rangle $$\n由于基的标准正交性，$\\langle \\phi_n, \\phi_0 \\rangle = \\delta_{n0}$。这意味着 $\\mathbb{E}[\\phi_0(\\xi)] = 1$ 且对于所有 $n > 0$ 都有 $\\mathbb{E}[\\phi_n(\\xi)] = 0$。\n\n将此结果代回 PCE 期望的表达式中：\n$$ \\mathbb{E}[f_P(\\xi)] = c_0 \\cdot \\mathbb{E}[\\phi_0(\\xi)] + \\sum_{n=1}^{P} c_n \\cdot \\mathbb{E}[\\phi_n(\\xi)] = c_0 \\cdot 1 + \\sum_{n=1}^{P} c_n \\cdot 0 = c_0 $$\n这证明了 PCE 的一个基本性质：任何阶数 $P \\ge 0$ 的 PCE 近似的期望都精确等于零阶系数 $c_0$。因此，对于均值的计算，在多项式阶数 3 处截断的规定是无关紧要的。\n因此，期望的 PCE 近似为：\n$$ \\mathbb{E}[\\sin(a\\,\\xi)] \\approx c_0 = \\frac{1 - \\cos(a)}{a} $$\n\n**3. $\\mathbb{E}[\\sin(a\\,\\xi)]$ 的精确解析表达式**\n\n我们可以从第一性原理出发，使用连续随机变量函数的期望定义来推导精确期望：\n$$ \\mathbb{E}[g(\\xi)] = \\int_{-\\infty}^{\\infty} g(x) p_{\\xi}(x) \\,dx $$\n对于我们的问题，$g(\\xi) = \\sin(a\\,\\xi)$ 且在 $[0,1]$ 上 $p_{\\xi}(x) = 1$。\n$$ \\mathbb{E}[\\sin(a\\,\\xi)] = \\int_{0}^{1} \\sin(a\\,x) \\cdot 1 \\,dx $$\n这正是我们为计算 $c_0$ 所计算的同一个积分。\n$$ \\mathbb{E}[\\sin(a\\,\\xi)] = \\left[ -\\frac{1}{a} \\cos(a\\,x) \\right]_{0}^{1} = -\\frac{1}{a} (\\cos(a) - \\cos(0)) = \\frac{1 - \\cos(a)}{a} $$\n正如在第 2 部分中所确立的，零阶 PCE 系数不是一个近似值，它与随机量的精确均值完全相同。\n\n**4. 当 $a = \\pi$ 时的数值计算**\n\n最后，我们计算当 $a=\\pi$ 时推导出的期望表达式：\n$$ \\mathbb{E}[\\sin(\\pi\\,\\xi)] = \\frac{1 - \\cos(\\pi)}{\\pi} $$\n利用 $\\cos(\\pi) = -1$ 这一事实，我们得到：\n$$ \\mathbb{E}[\\sin(\\pi\\,\\xi)] = \\frac{1 - (-1)}{\\pi} = \\frac{2}{\\pi} $$\n为了提供数值，我们计算这个量：\n$$ \\frac{2}{\\pi} \\approx 0.63661977... $$\n按照要求四舍五入到四位有效数字，我们得到 $0.6366$。", "answer": "$$\\boxed{0.6366}$$", "id": "3174309"}, {"introduction": "从解析理论到计算实践，需要对我们使用的工具进行严格的验证。本练习将指导您构建一个综合基准测试，以验证您实现的广义多项式混沌 (gPC) 框架。通过将其应用于一个二次响应函数——一个低阶gPC展开能够精确表示的特例——您可以确认您编写的通过数值积分提取系数以及后续计算矩的代码是否正确，从而为解决更复杂的不确定性量化问题打下坚实的基础。[@problem_id:3174279]", "problem": "要求您为广义多项式混沌 (gPC) 构建并验证一个合成基准，该基准能够为二次响应函数生成精确的均值和方差。该基准应设计为使总阶数为二的截断正交多项式混沌能够精确表示该响应。您将使用精确数值积分通过正交投影实现系数提取，并验证从 gPC 系数计算出的均值和方差与从分布矩推导出的解析值相匹配。\n\n基本基础和假设：考虑具有已知正交多项式族和精确求积法则的独立随机变量。对于概率密度函数为 $\\phi(x)$ 的标准正态随机变量 $X$ 和在 $[-1,1]$ 上的均匀随机变量 $U$，使用它们相关的正交多项式基和高斯求积法则。广义多项式混沌 (gPC) 基函数是适用于每个边际分布的正交单变量多项式的张量积。系数通过关于底层概率测度的正交投影来定义。\n\n您的任务：\n1. 构建正交单变量基：\n   - 对于 $X \\sim \\mathcal{N}(0,1)$，使用正交化的概率论者 Hermite 多项式 $\\{\\psi_n(x)\\}_{n \\ge 0}$，使得 $E[\\psi_m(X)\\psi_n(X)] = \\delta_{mn}$，其中 $\\delta_{mn}$ 是克罗内克 δ。\n   - 对于 $U \\sim \\text{Uniform}([-1,1])$，使用正交化的 Legendre 多项式 $\\{\\ell_n(u)\\}_{n \\ge 0}$，使得 $E[\\ell_m(U)\\ell_n(U)] = \\delta_{mn}$。\n   - 在多维情况下，使用总阶数最高为二的多重索引来索引单变量正交基的张量积。\n2. 通过正交投影提取 gPC 系数。对于响应 $f(\\boldsymbol{\\xi})$ 和一个正交基函数 $\\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})$，系数 $c_{\\boldsymbol{\\alpha}}$ 是内积\n   $$c_{\\boldsymbol{\\alpha}} = E\\left[f(\\boldsymbol{\\xi}) \\, \\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})\\right]$$\n   其中 $E[\\cdot]$ 表示关于 $\\boldsymbol{\\xi}$ 的联合分布的期望。\n3. 利用基的正交性，从提取的系数中计算均值和方差。然后，使用经过充分检验的二次多项式分布矩公式计算精确的解析均值和方差，并对两者进行比较。\n4. 使用适用于相应测度和多项式阶数的精确数值求积法则：\n   - 对于 $X \\sim \\mathcal{N}(0,1)$，使用三点 Gauss-Hermite 求积法，并通过变量替换 $x = \\sqrt{2}\\,t$ 来精确计算最高四阶多项式的期望值。\n   - 对于 $U \\sim \\text{Uniform}([-1,1])$，使用由概率密度缩放的三点 Gauss-Legendre 求积法来精确计算最高四阶多项式的期望值。\n5. 为一维和二维独立随机输入及二次响应实现上述过程。对于二维情况，使用张量积求积法以保持对适当阶数的二元多项式的精确性。\n\n按如下方式定义响应函数及其参数。对于一维情况，令\n$$f(x) = a_0 + a_1 x + a_2 x^2,$$\n对于具有独立输入 $(x,y)$ 的二维情况，令\n$$f(x,y) = c_0 + c_1 x + c_2 y + c_3 x^2 + c_4 y^2 + c_5 x y.$$\n\n使用以下参数值的测试套件：\n- 案例 1（标准正态，一维）：$a_0 = 1.3$, $a_1 = -0.7$, $a_2 = 0.5$。\n- 案例 2（在 $[-1,1]$ 上均匀分布，一维）：$a_0 = 0.2$, $a_1 = 1.1$, $a_2 = -0.5$。\n- 案例 3（标准正态，二维）：$c_0 = 0.9$, $c_1 = 0.2$, $c_2 = -0.4$, $c_3 = 0.3$, $c_4 = 0.1$, $c_5 = 0.25$。\n- 案例 4（在 $[-1,1]$ 上均匀分布，二维）：$c_0 = -0.5$, $c_1 = 0.6$, $c_2 = 0.1$, $c_3 = -0.2$, $c_4 = 0.7$, $c_5 = 0.3$。\n- 案例 5（标准正态，一维，常数边界情况）：$a_0 = 2.0$, $a_1 = 0.0$, $a_2 = 0.0$。\n- 案例 6（在 $[-1,1]$ 上均匀分布，一维，线性边界情况）：$a_0 = 0.0$, $a_1 = 1.0$, $a_2 = 0.0$。\n\n要使用的解析参考矩：\n- 对于 $X \\sim \\mathcal{N}(0,1)$：$E[X] = 0$, $E[X^2] = 1$, $E[X^4] = 3$。\n- 对于 $U \\sim \\text{Uniform}([-1,1])$：$E[U] = 0$, $E[U^2] = \\frac{1}{3}$, $E[U^4] = \\frac{1}{5}$。\n\n您的程序必须：\n- 为两种分布实现正交多项式求值。\n- 实现具有适当缩放的三点高斯求积法则，以精确计算所需多项式阶数的期望。\n- 提取总阶数为二的 gPC 系数。\n- 计算基于 gPC 的均值和方差，并对每个案例将其与解析结果进行比较。\n- 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的验证结果。对于每个案例，输出一个布尔值，指示均值和方差是否都在 $10^{-12}$ 的绝对容差内与解析值匹配。\n\n最终输出格式必须严格如下：\n“您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，[True,False,True,False,True,True]）。”", "solution": "问题陈述经评估有效。它在科学上基于广义多项式混沌 (gPC) 展开理论，这是一种不确定性量化中的标准方法。该问题是适定的，所有必要的参数、分布和响应函数都有明确的定义。目标明确且可证伪：根据解析结果验证数值实现的正确性。其潜在的数学假设是正确的，例如对于二次响应，2阶 gPC 展开是精确的，以及3点高斯求积法是充分的。\n\n解法如下。首先，我们为标准正态分布和均匀分布定义了必要的正交多项式基。其次，我们推导了二次响应函数的均值和方差的解析表达式。第三，我们在 gPC 基中表示响应函数，以找到理论系数以及相应的均值和方差。结果表明，这与解析结果相同。第四，我们描述了使用正交投影提取 gPC 系数的数值过程，该过程通过精确数值积分进行计算。最后，我们为每个测试案例实施此过程，并验证数值上获得的均值和方差在指定容差内与解析值匹配。\n\n具有随机输入 $\\boldsymbol{\\xi}$ 的响应函数 $f(\\boldsymbol{\\xi})$ 的 gPC 展开由下式给出\n$$f(\\boldsymbol{\\xi}) = \\sum_{\\boldsymbol{\\alpha} \\in \\mathbb{N}_0^d} c_{\\boldsymbol{\\alpha}} \\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})$$\n其中 $\\{\\Psi_{\\boldsymbol{\\alpha}}\\}$ 是相对于 $\\boldsymbol{\\xi}$ 的概率测度正交的多项式基，而 $c_{\\boldsymbol{\\alpha}}$ 是 gPC 系数。对于二次响应函数，当在总多项式阶数 $P=2$ 处截断时，该展开是精确的。\n\n系数通过正交投影求得：\n$$c_{\\boldsymbol{\\alpha}} = E\\left[f(\\boldsymbol{\\xi}) \\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})\\right]$$\n其中 $E[\\cdot]$ 表示期望。由于正交性，$E[\\Psi_{\\boldsymbol{\\alpha}}] = \\delta_{\\boldsymbol{\\alpha}\\mathbf{0}}$ 且 $E[\\Psi_{\\boldsymbol{\\alpha}}\\Psi_{\\boldsymbol{\\beta}}] = \\delta_{\\boldsymbol{\\alpha}\\boldsymbol{\\beta}}$。\n$f$ 的均值和方差可以直接从系数中计算得出：\n$$\\mu_f = E[f] = E\\left[\\sum_{\\boldsymbol{\\alpha}} c_{\\boldsymbol{\\alpha}} \\Psi_{\\boldsymbol{\\alpha}}\\right] = \\sum_{\\boldsymbol{\\alpha}} c_{\\boldsymbol{\\alpha}} E[\\Psi_{\\boldsymbol{\\alpha}}] = c_{\\mathbf{0}}$$\n$$\\sigma_f^2 = E[(f - \\mu_f)^2] = E\\left[\\left(\\sum_{\\boldsymbol{\\alpha} \\ne \\mathbf{0}} c_{\\boldsymbol{\\alpha}} \\Psi_{\\boldsymbol{\\alpha}}\\right)^2\\right] = \\sum_{\\boldsymbol{\\alpha} \\ne \\mathbf{0}} \\sum_{\\boldsymbol{\\beta} \\ne \\mathbf{0}} c_{\\boldsymbol{\\alpha}}c_{\\boldsymbol{\\beta}} E[\\Psi_{\\boldsymbol{\\alpha}}\\Psi_{\\boldsymbol{\\beta}}] = \\sum_{\\boldsymbol{\\alpha} \\ne \\mathbf{0}} c_{\\boldsymbol{\\alpha}}^2$$\n\n总阶数最高为 2 的单变量正交多项式基为：\n1.  对于 $X \\sim \\mathcal{N}(0,1)$：正交概率论者 Hermite 多项式。\n    $$\\psi_0(x) = 1, \\quad \\psi_1(x) = x, \\quad \\psi_2(x) = \\frac{1}{\\sqrt{2}}(x^2 - 1)$$\n    反向关系为：$1 = \\psi_0(x)$，$x = \\psi_1(x)$，以及 $x^2 = \\sqrt{2}\\psi_2(x) + \\psi_0(x)$。\n\n2.  对于 $U \\sim \\text{Uniform}([-1,1])$：正交 Legendre 多项式。\n    $$\\ell_0(u) = 1, \\quad \\ell_1(u) = \\sqrt{3}u, \\quad \\ell_2(u) = \\frac{\\sqrt{5}}{2}(3u^2 - 1)$$\n    反向关系为：$1 = \\ell_0(u)$，$u = \\frac{1}{\\sqrt{3}}\\ell_1(u)$，以及 $u^2 = \\frac{2}{3\\sqrt{5}}\\ell_2(u) + \\frac{1}{3} = \\frac{2\\sqrt{5}}{15}\\ell_2(u) + \\frac{1}{3}\\ell_0(u)$。\n\n解析均值和方差由分布的矩推导得出。\n对于一维响应 $f(z) = a_0 + a_1 z + a_2 z^2$，其中 $z$ 是 $X$ 或 $U$：\n$$\\mu_f = E[f(z)] = a_0 + a_1 E[z] + a_2 E[z^2]$$\n由于 $E[X]=0$ 和 $E[U]=0$，这简化为 $\\mu_f = a_0 + a_2 E[z^2]$。\n$$\\sigma_f^2 = E[(f(z) - \\mu_f)^2] = E[(a_1 z + a_2 (z^2-E[z^2]))^2]$$\n由于奇数矩为零，交叉项消失：\n$$\\sigma_f^2 = a_1^2 E[z^2] + a_2^2 E[(z^2-E[z^2])^2] = a_1^2 E[z^2] + a_2^2 (E[z^4] - (E[z^2])^2)$$\n\n对于二维响应 $f(x,y) = c_0 + c_1 x + c_2 y + c_3 x^2 + c_4 y^2 + c_5 xy$，其中 $x, y$ 是独立变量：\n$$\\mu_f = E[f(x,y)] = c_0 + c_3 E[x^2] + c_4 E[y^2]$$\n$$\\sigma_f^2 = \\text{Var}(f(x,y)) = c_1^2 \\text{Var}(x) + c_2^2 \\text{Var}(y) + c_3^2 \\text{Var}(x^2) + c_4^2 \\text{Var}(y^2) + c_5^2 \\text{Var}(xy)$$\n对于零均值变量 $z$，使用 $\\text{Var}(z) = E[z^2]$，以及 $x,y$ 的独立性，我们得到：\n$$\\sigma_f^2 = c_1^2 E[x^2] + c_2^2 E[y^2] + c_3^2(E[x^4] - (E[x^2])^2) + c_4^2(E[y^4] - (E[y^2])^2) + c_5^2 E[x^2]E[y^2]$$\n\n系数提取积分 $c_{\\boldsymbol{\\alpha}} = E[f(\\boldsymbol{\\xi}) \\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})]$ 使用数值积分进行计算。由于对于 $P=2$ 的情况，被积函数 $f(\\boldsymbol{\\xi})\\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})$ 是一个最高阶数为 $4=2+2$ 的多项式，一个对于最高 $2 \\times 3 - 1 = 5$ 阶多项式都精确的 3 点高斯求积法则可以得出精确的系数值。\n\n对于 $X \\sim \\mathcal{N}(0,1)$，我们使用 Gauss-Hermite 求积法。期望 $E[g(X)]$ 计算如下：\n$$E[g(X)] = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{\\infty} g(x) e^{-x^2/2} dx = \\frac{1}{\\sqrt{\\pi}} \\int_{-\\infty}^{\\infty} g(\\sqrt{2}t) e^{-t^2} dt \\approx \\frac{1}{\\sqrt{\\pi}} \\sum_{i=1}^{3} w_i g(\\sqrt{2}t_i)$$\n其中 $(t_i, w_i)$ 是标准 3 点 Gauss-Hermite 求积点和权重。\n\n对于 $U \\sim \\text{Uniform}([-1,1])$，我们使用 Gauss-Legendre 求积法。期望 $E[g(U)]$ 计算如下：\n$$E[g(U)] = \\frac{1}{2} \\int_{-1}^{1} g(u) du \\approx \\frac{1}{2} \\sum_{i=1}^{3} w_i g(u_i)$$\n其中 $(u_i, w_i)$ 是标准 3 点 Gauss-Legendre 求积点和权重。\n\n在二维情况下，使用单变量求积法则的张量积来保持精确性。该实现将为每个案例计算解析统计量和基于 gPC 的统计量，并验证它们的一致性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and validates a synthetic benchmark for generalized Polynomial Chaos (gPC)\n    for quadratic response functions. It verifies that mean and variance from gPC\n    coefficients (extracted via exact quadrature) match analytical values.\n    \"\"\"\n\n    TOLERANCE = 1e-12\n\n    # --- Orthonormal Polynomial Definitions ---\n    def hermite_psi(n, x):\n        \"\"\"Orthonormal probabilists' Hermite polynomials psi_n(x).\"\"\"\n        if n == 0:\n            return np.ones_like(x)\n        if n == 1:\n            return x\n        if n == 2:\n            return (x**2 - 1) / np.sqrt(2)\n        raise ValueError(\"Only degrees 0, 1, 2 are implemented.\")\n\n    def legendre_ell(n, u):\n        \"\"\"Orthonormal Legendre polynomials ell_n(u).\"\"\"\n        if n == 0:\n            return np.ones_like(u)\n        if n == 1:\n            return np.sqrt(3) * u\n        if n == 2:\n            return np.sqrt(5) / 2 * (3 * u**2 - 1)\n        raise ValueError(\"Only degrees 0, 1, 2 are implemented.\")\n\n    # --- Response Function Definitions ---\n    def response_1d(x, coeffs):\n        return coeffs['a0'] + coeffs['a1'] * x + coeffs['a2'] * x**2\n\n    def response_2d(xy, coeffs):\n        x, y = xy[..., 0], xy[..., 1]\n        return (coeffs['c0'] + coeffs['c1'] * x + coeffs['c2'] * y +\n                coeffs['c3'] * x**2 + coeffs['c4'] * y**2 + coeffs['c5'] * x * y)\n\n    # --- Analytical Statistics ---\n    def get_analytical_stats(case):\n        coeffs = case['coeffs']\n        dist_type = case['dist']\n        dim = case['dim']\n\n        # Moments\n        if dist_type == 'normal':\n            moments = {'E_z1': 0, 'E_z2': 1, 'E_z4': 3}\n        else: # uniform\n            moments = {'E_z1': 0, 'E_z2': 1/3, 'E_z4': 1/5}\n\n        if dim == 1:\n            mean = coeffs['a0'] + coeffs['a2'] * moments['E_z2']\n            var_z2 = moments['E_z4'] - moments['E_z2']**2\n            variance = coeffs['a1']**2 * moments['E_z2'] + coeffs['a2']**2 * var_z2\n        else: # dim == 2\n            mean = coeffs['c0'] + coeffs['c3'] * moments['E_z2'] + coeffs['c4'] * moments['E_z2']\n            var_z2 = moments['E_z4'] - moments['E_z2']**2\n            variance = (coeffs['c1']**2 * moments['E_z2'] +\n                        coeffs['c2']**2 * moments['E_z2'] +\n                        coeffs['c3']**2 * var_z2 +\n                        coeffs['c4']**2 * var_z2 +\n                        coeffs['c5']**2 * moments['E_z2'] * moments['E_z2'])\n        return mean, variance\n\n    # --- gPC Coefficient Extraction and Statistics ---\n    def get_gpc_stats(case):\n        dist_type = case['dist']\n        dim = case['dim']\n        coeffs = case['coeffs']\n\n        if dist_type == 'normal':\n            poly_func = hermite_psi\n            # 3-point Gauss-Hermite quadrature\n            gh_pts, gh_w = np.polynomial.hermite.hermgauss(3)\n            quad_pts = gh_pts * np.sqrt(2)\n            quad_w = gh_w / np.sqrt(np.pi)\n        else: # uniform\n            poly_func = legendre_ell\n            # 3-point Gauss-Legendre quadrature\n            gl_pts, gl_w = np.polynomial.legendre.leggauss(3)\n            quad_pts = gl_pts\n            quad_w = gl_w / 2.0\n\n        if dim == 1:\n            f_vals = response_1d(quad_pts, coeffs)\n            \n            multi_indices = [0, 1, 2]\n            pce_coeffs = []\n            for alpha in multi_indices:\n                psi_vals = poly_func(alpha, quad_pts)\n                integrand = f_vals * psi_vals\n                c_alpha = np.sum(integrand * quad_w)\n                pce_coeffs.append(c_alpha)\n            \n            mean_gpc = pce_coeffs[0]\n            var_gpc = np.sum(np.array(pce_coeffs[1:])**2)\n\n        else: # dim == 2\n            quad_pts_x, quad_pts_y = np.meshgrid(quad_pts, quad_pts)\n            quad_pts_2d = np.stack([quad_pts_x.ravel(), quad_pts_y.ravel()], axis=-1)\n            f_vals = response_2d(quad_pts_2d, coeffs)\n            \n            quad_w_x, quad_w_y = np.meshgrid(quad_w, quad_w)\n            quad_w_2d = (quad_w_x * quad_w_y).ravel()\n\n            multi_indices = [(0, 0), (1, 0), (0, 1), (2, 0), (0, 2), (1, 1)]\n            pce_coeffs = {}\n            for alpha in multi_indices:\n                psi_vals = poly_func(alpha[0], quad_pts_2d[:, 0]) * poly_func(alpha[1], quad_pts_2d[:, 1])\n                integrand = f_vals * psi_vals\n                c_alpha = np.sum(integrand * quad_w_2d)\n                pce_coeffs[alpha] = c_alpha\n\n            mean_gpc = pce_coeffs[(0, 0)]\n            var_gpc = sum(c**2 for k, c in pce_coeffs.items() if k != (0, 0))\n        \n        return mean_gpc, var_gpc\n\n    # --- Main Loop ---\n    test_cases = [\n        {'id': 1, 'dim': 1, 'dist': 'normal', 'coeffs': {'a0': 1.3, 'a1': -0.7, 'a2': 0.5}},\n        {'id': 2, 'dim': 1, 'dist': 'uniform', 'coeffs': {'a0': 0.2, 'a1': 1.1, 'a2': -0.5}},\n        {'id': 3, 'dim': 2, 'dist': 'normal', 'coeffs': {'c0': 0.9, 'c1': 0.2, 'c2': -0.4, 'c3': 0.3, 'c4': 0.1, 'c5': 0.25}},\n        {'id': 4, 'dim': 2, 'dist': 'uniform', 'coeffs': {'c0': -0.5, 'c1': 0.6, 'c2': 0.1, 'c3': -0.2, 'c4': 0.7, 'c5': 0.3}},\n        {'id': 5, 'dim': 1, 'dist': 'normal', 'coeffs': {'a0': 2.0, 'a1': 0.0, 'a2': 0.0}},\n        {'id': 6, 'dim': 1, 'dist': 'uniform', 'coeffs': {'a0': 0.0, 'a1': 1.0, 'a2': 0.0}},\n    ]\n\n    results = []\n    for case in test_cases:\n        mean_analytical, var_analytical = get_analytical_stats(case)\n        mean_gpc, var_gpc = get_gpc_stats(case)\n\n        mean_match = np.isclose(mean_analytical, mean_gpc, atol=TOLERANCE, rtol=0)\n        var_match = np.isclose(var_analytical, var_gpc, atol=TOLERANCE, rtol=0)\n        \n        results.append(mean_match and var_match)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3174279"}, {"introduction": "在实际应用中，PCE系数通常通过回归方法从数据中估计，这是一种“非侵入式”方法。然而，当我们所选多项式基的正交权重函数与数据的潜在概率分布不匹配时，会发生什么？本练习通过揭示这种不匹配所导致的系统性偏差，探讨了这一关键问题。通过比较来自“正确”正交投影的系数与来自不匹配的最小二乘拟合的系数，您将对应用基于回归的PCE方法时的假设和潜在陷阱获得至关重要的洞察。[@problem_id:3174362]", "problem": "您将编写一个完整的程序，以实证方式展示正交性权重不匹配如何影响多项式混沌展开（PCE）的系数。考虑勒让德多项式基，它在区间 $[-1,1]$上相对于均匀权重是正交的。您将比较一个截断阶数为 $p$ 的展开的两个系数向量：一个是通过在均匀权重下进行正交投影得到的，另一个是使用从非均匀输入分布中抽取的样本通过非加权最小二乘回归得到的。\n\n使用以下基本基础：\n- 勒让德多项式 $\\{P_n(x)\\}_{n=0}^{\\infty}$ 在 $[-1,1]$ 上对于内积 $\\langle f,g\\rangle = \\int_{-1}^{1} f(x) g(x)\\,dx$ 是正交的，即，\n$$\\int_{-1}^{1} P_m(x)\\,P_n(x)\\,dx = \\frac{2}{2n+1}\\,\\delta_{mn}$$\n- 一个截断阶数为 $p$ 的多项式混沌展开（PCE）将标量响应 $y(x)$ 近似为\n$$y(x)\\approx \\sum_{n=0}^{p} c_n\\,P_n(x)$$\n其中系数 $\\{c_n\\}_{n=0}^{p}$ 由适当的最优性准则确定。\n\n任务是量化当数据从非均匀输入分布生成，但仍使用（适用于均匀权重的）勒让德基和非加权最小二乘法时引入的系统性系数偏差。程序必须为每个测试用例实现以下步骤：\n1. 根据测试用例的规定定义函数 $y(x)$。\n2. 计算系数向量 $\\boldsymbol{c}^{\\star} = (c_0^{\\star},\\ldots,c_p^{\\star})$，该向量对应于在 $[-1,1]$ 上的均匀权重下，将 $y(x)$ 正交投影到基 $\\{P_n(x)\\}_{n=0}^{p}$ 上。为此，使用至少 $M=500$ 个节点的高斯-勒让德求积法对 $[-1,1]$ 上的所需积分进行数值逼近。\n3. 独立地，从形状参数为 $(a,b)$ 的 Beta 分布（在 $[0,1]$ 上）生成 $N$ 个独立同分布的样本，然后通过 $X = 2U - 1$ 将它们转换到 $[-1,1]$。使用这些输入计算输出样本 $Y = y(X)$，构建设计矩阵，其列为 $P_n(X)$（$n=0,\\ldots,p$），并通过数值稳定的求解器隐式求解正规方程，计算非加权最小二乘估计 $\\widehat{\\boldsymbol{c}}$。为了可复现性，使用固定的随机种子 $s=12345$。\n4. 报告定义为欧几里得范数的标量偏差大小\n$$\\|\\widehat{\\boldsymbol{c}} - \\boldsymbol{c}^{\\star}\\|_2 = \\left(\\sum_{n=0}^{p} \\left(\\widehat{c}_n - c_n^{\\star}\\right)^2\\right)^{1/2}$$\n\n实现以下参数值的测试套件以涵盖不同方面：\n- 情况 1（理想路径，显著不匹配）：$y(x)=\\exp(x)$，$p=3$，$N=400$，$(a,b)=(2,5)$。\n- 情况 2（分布无不匹配）：$y(x)=\\exp(x)$，$p=3$，$N=400$，$(a,b)=(1,1)$（变换后在 $[-1,1]$ 上均匀分布）。\n- 情况 3（不同的非线性和不匹配）：$y(x)=\\sin(x)$，$x$ 为弧度，$p=5$，$N=800$，$(a,b)=(5,2)$。\n- 情况 4（模型在基的张成空间内被良好指定）：$y(x)=1 + 0.2\\,x + 0.3\\,x^2$，$p=5$，$N=200$，$(a,b)=(2,5)$。\n\n您的程序应生成单行输出，其中包含四个情况的偏差大小，格式为逗号分隔的浮点数列表，保留六位小数，并用方括号括起来，顺序与上述相同，例如\n$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$。\n无需用户输入。所有角度均为弧度。不涉及物理单位。", "solution": "该问题要求对多项式混沌展开（PCE）系数的偏差进行实证研究，这种偏差在输入数据的采样分布与所选多项式基的正交性权重函数不匹配时产生。我们将比较通过两种不同方法得到的系数：一种是理论上最优的正交投影，另一种是数据驱动的最小二乘回归。\n\n基函数是勒让德多项式 $\\{P_n(x)\\}_{n=0}^{\\infty}$，它们在区间 $[-1, 1]$ 上相对于均匀权重函数 $w(x) = 1$ 是正交的。正交性条件由下式给出：\n$$\n\\int_{-1}^{1} P_m(x) P_n(x) \\,dx = \\frac{2}{2n+1}\\delta_{mn}\n$$\n其中 $\\delta_{mn}$ 是克罗内克 δ。\n\n一个函数 $y(x)$ 可以通过一个截断阶数为 $p$ 的 PCE 来近似：\n$$\ny(x) \\approx y_p(x) = \\sum_{n=0}^{p} c_n P_n(x)\n$$\n\n我们将为此展开计算两组系数，$\\boldsymbol{c}^{\\star}$ 和 $\\widehat{\\boldsymbol{c}}$。\n\n**1. 正交投影系数 ($\\boldsymbol{c}^{\\star}$)**\n\n系数 $\\boldsymbol{c}^{\\star} = (c_0^{\\star}, \\dots, c_p^{\\star})$ 是通过将函数 $y(x)$ 投影到函数空间 $L^2([-1,1])$ 中的基 $\\{P_n(x)\\}_{n=0}^{p}$ 上来确定的。使加权平方误差 $\\int_{-1}^{1} [y(x) - y_p(x)]^2 w(x) \\,dx$（其中 $w(x)=1$）最小化的系数由正交投影公式给出：\n$$\nc_n^{\\star} = \\frac{\\langle y, P_n \\rangle}{\\langle P_n, P_n \\rangle} = \\frac{\\int_{-1}^{1} y(x) P_n(x) \\,dx}{\\int_{-1}^{1} P_n(x)^2 \\,dx}\n$$\n代入内积的已知值 $\\langle P_n, P_n \\rangle = \\frac{2}{2n+1}$，我们得到每个系数的精确公式：\n$$\nc_n^{\\star} = \\frac{2n+1}{2} \\int_{-1}^{1} y(x) P_n(x) \\,dx\n$$\n为了计算这些系数，我们必须对积分进行数值近似。问题指定使用具有 $M \\geq 500$ 个节点的高斯-勒让德求积法。设 $\\{x_i\\}_{i=1}^M$ 是求积节点，$\\{w_i\\}_{i=1}^M$ 是区间 $[-1, 1]$ 上对应的权重。积分则近似为一个加权和：\n$$\n\\int_{-1}^{1} f(x) \\,dx \\approx \\sum_{i=1}^{M} w_i f(x_i)\n$$\n将此应用于我们的系数公式，我们得到数值估计：\n$$\nc_n^{\\star} \\approx \\frac{2n+1}{2} \\sum_{i=1}^{M} w_i y(x_i) P_n(x_i)\n$$\n这些系数可作为基于勒让德多项式的 PCE 的“真实”或理想系数。\n\n**2. 最小二乘回归系数 ($\\widehat{\\boldsymbol{c}}$)**\n\n第二组系数 $\\widehat{\\boldsymbol{c}} = (\\widehat{c}_0, \\dots, \\widehat{c}_p)$ 是从一个包含 $N$ 个输入-输出样本的有限集 $\\{(X_j, Y_j)\\}_{j=1}^N$ 估计得出的。输入样本 $X_j$ 并非从 $[-1, 1]$ 上的均匀分布中抽取。相反，它们是通过从 $[0,1]$ 上参数为 $(a,b)$ 的 Beta 分布中抽取 $U_j$，然后应用仿射变换 $X_j = 2U_j - 1$ 生成的。输出样本为 $Y_j = y(X_j)$。\n\n系数 $\\widehat{\\boldsymbol{c}}$ 是通过解决一个非加权线性最小二乘问题来找到的。我们寻求最小化残差平方和：\n$$\n\\min_{\\widehat{\\boldsymbol{c}}} \\sum_{j=1}^{N} \\left( Y_j - \\sum_{n=0}^{p} \\widehat{c}_n P_n(X_j) \\right)^2\n$$\n这可以表示为最小化 $\\|\\boldsymbol{Y} - \\boldsymbol{\\Psi}\\widehat{\\boldsymbol{c}}\\|_2^2$ 的矩阵形式，其中：\n- $\\boldsymbol{Y} = [Y_1, Y_2, \\dots, Y_N]^T$ 是输出样本的向量。\n- $\\boldsymbol{\\Psi}$ 是一个 $N \\times (p+1)$ 的设计矩阵，其元素为 $\\Psi_{jn} = P_n(X_j)$。\n- $\\widehat{\\boldsymbol{c}} = [\\widehat{c}_0, \\widehat{c}_1, \\dots, \\widehat{c}_p]^T$ 是待确定的系数向量。\n\n解可以通过求解正规方程 $(\\boldsymbol{\\Psi}^T \\boldsymbol{\\Psi}) \\widehat{\\boldsymbol{c}} = \\boldsymbol{\\Psi}^T \\boldsymbol{Y}$ 来找到。为保证数值稳定性，最好使用基于 QR 分解或奇异值分解的方法来求解，这些方法已在标准数值库中实现。\n\n**3. 偏差的来源**\n\n最小二乘估计 $\\widehat{\\boldsymbol{c}}$ 收敛于相对于 $X$ 的实际采样分布而言最优的系数。如果 $X$ 的概率密度函数是 $f_X(x)$，则最小二乘法是在权重为 $f_X(x)$ 的加权 $L^2$ 范数下最小化误差的离散近似。\n\n系统性偏差 $\\widehat{\\boldsymbol{c}} - \\boldsymbol{c}^{\\star}$ 的产生，正是因为采样分布的权重函数 $f_X(x)$ 与勒让德基正交性所对应的权重函数 $w(x) = 1$ 不匹配。唯一的例外是情况2，其中 Beta 分布的参数为 $(a,b)=(1,1)$，这对应于 $[0,1]$ 上的均匀分布。变换后，这会产生 $[-1,1]$ 上的均匀分布，因此 $f_X(x) \\propto w(x)$，偏差预计是最小的，仅可归因于有限样本方差。对于 $(a,b) \\neq (1,1)$ 的其他情况，会产生非均匀的采样密度 $f_X(x)$，从而导致可证明的系统性偏差。\n\n该偏差的大小通过差向量的欧几里得范数来量化：\n$$\n\\|\\widehat{\\boldsymbol{c}} - \\boldsymbol{c}^{\\star}\\|_2 = \\sqrt{\\sum_{n=0}^{p} (\\widehat{c}_n - c_n^{\\star})^2}\n$$\n\n**算法摘要**\n程序将为四个测试用例中的每一个执行以下步骤：\n1.  定义目标函数 $y(x)$ 和参数 $p, N, a, b$。\n2.  应用具有 $M=500$ 个节点的高斯-勒让德求积公式计算向量 $\\boldsymbol{c}^{\\star}$。\n3.  为保证可复现性，将随机种子设置为 $s=12345$。\n4.  从 Beta$(a,b)$ 分布中生成 $N$ 个样本，将它们转换到区间 $[-1,1]$，并评估 $y(x)$ 以获得样本对。\n5.  使用生成的输入样本和最高到 $p$ 阶的勒让德多项式的求值结果，构建设计矩阵 $\\boldsymbol{\\Psi}$。\n6.  求解线性最小二乘问题 $\\boldsymbol{Y} \\approx \\boldsymbol{\\Psi}\\widehat{\\boldsymbol{c}}$ 以找到系数向量 $\\widehat{\\boldsymbol{c}}$。\n7.  计算欧几里得范数 $\\|\\widehat{\\boldsymbol{c}} - \\boldsymbol{c}^{\\star}\\|_2$。\n8.  收集结果并按规定格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import eval_legendre\nfrom numpy.polynomial.legendre import leggauss\n\ndef compute_c_star(y_func, p: int, M: int) -> np.ndarray:\n    \"\"\"\n    Computes PCE coefficients via orthogonal projection using Gaussian-Legendre quadrature.\n\n    Args:\n        y_func: The function y(x) to be expanded.\n        p: The maximum order of the PCE.\n        M: The number of quadrature nodes to use.\n\n    Returns:\n        A numpy array containing the coefficients c_star.\n    \"\"\"\n    nodes, weights = leggauss(M)\n    c_star = np.zeros(p + 1)\n    \n    # Evaluate the function y at all quadrature nodes once\n    y_vals = y_func(nodes)\n    \n    for n in range(p + 1):\n        # Evaluate the nth Legendre polynomial at the nodes\n        p_n_vals = eval_legendre(n, nodes)\n        \n        # Approximate the integral using quadrature\n        integrand_values = y_vals * p_n_vals\n        integral = np.sum(weights * integrand_values)\n        \n        # Apply the projection formula\n        c_star[n] = (2 * n + 1) / 2.0 * integral\n        \n    return c_star\n\ndef compute_c_hat(y_func, p: int, N: int, a: float, b: float, seed: int) -> np.ndarray:\n    \"\"\"\n    Computes PCE coefficients via unweighted least squares from samples.\n\n    Args:\n        y_func: The function y(x) to generate samples.\n        p: The maximum order of the PCE.\n        N: The number of samples.\n        a: The alpha parameter of the Beta distribution.\n        b: The beta parameter of the Beta distribution.\n        seed: The random seed for reproducibility.\n\n    Returns:\n        A numpy array containing the estimated coefficients c_hat.\n    \"\"\"\n    # Generate samples from the specified distribution\n    rng = np.random.default_rng(seed)\n    U = rng.beta(a, b, size=N)\n    X = 2.0 * U - 1.0  # Transform samples from [0, 1] to [-1, 1]\n    Y = y_func(X)\n    \n    # Construct the design matrix Psi\n    Psi = np.zeros((N, p + 1))\n    for n in range(p + 1):\n        Psi[:, n] = eval_legendre(n, X)\n        \n    # Solve the least squares problem\n    c_hat, _, _, _ = np.linalg.lstsq(Psi, Y, rcond=None)\n    \n    return c_hat\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define constants\n    QUADRATURE_NODES = 500\n    RANDOM_SEED = 12345\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (y_function, order_p, num_samples_N, beta_a, beta_b)\n    test_cases = [\n        (lambda x: np.exp(x), 3, 400, 2, 5),\n        (lambda x: np.exp(x), 3, 400, 1, 1),\n        (lambda x: np.sin(x), 5, 800, 5, 2),\n        (lambda x: 1.0 + 0.2 * x + 0.3 * x**2, 5, 200, 2, 5)\n    ]\n\n    results = []\n    for case in test_cases:\n        y_func, p, N, a, b = case\n        \n        # 1. Compute the theoretical coefficients c_star via quadrature\n        c_star = compute_c_star(y_func, p, QUADRATURE_NODES)\n        \n        # 2. Compute the estimated coefficients c_hat via least squares\n        c_hat = compute_c_hat(y_func, p, N, a, b, RANDOM_SEED)\n        \n        # 3. Calculate the bias magnitude (Euclidean norm of the difference)\n        bias = np.linalg.norm(c_hat - c_star)\n        \n        results.append(bias)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3174362"}]}