{"hands_on_practices": [{"introduction": "在电路设计中，理解元件参数的微小变化如何影响电路的整体性能至关重要。本练习将通过一个经典的RLC串联电路，引导你推导其谐振频率 $\\omega_{0}$ 对电容值 $C$ 的归一化灵敏度 $S_{C}$。通过这个解析计算，你将掌握如何运用微积分来精确量化系统参数的敏感性，这是工程设计和公差分析中的一项基本技能。[@problem_id:3272518]", "problem": "一个串联RLC（电阻-电感-电容）电路在正弦稳态下由一个角频率为$\\omega$的源驱动。电感的阻抗为$j \\omega L$，电容的阻抗为$\\frac{1}{j \\omega C}$，电阻的阻抗为$R$，其中$j$表示虚数单位，$L$是电感值，$C$是电容值，$R$是电阻值。在通常的工程谐振意义上，对于串联RLC网络，谐振角频率$\\omega_{0}$被定义为净电抗为零时的频率，此时阻抗为纯实数。\n\n电容器的制造公差意味着实际的电容值为$C + \\delta C$，其中$|\\delta C| \\ll C$。请从基本原理（阻抗定义和谐振条件）出发，推导谐振角频率$\\omega_{0}$作为$L$和$C$的函数，然后从全微分出发，将$\\omega_{0}$关于$C$的归一化灵敏度定义为\n$$\nS_{C} \\equiv \\frac{C}{\\omega_{0}} \\frac{\\partial \\omega_{0}}{\\partial C}.\n$$\n计算$S_{C}$，将你的最终答案表示为单个实数。无需四舍五入，最终答案不带单位。", "solution": "该问题经验证具有科学依据、提法明确且客观。它是电路分析和灵敏度理论中的一个标准问题。我们可以开始求解。\n\n串联RLC电路的总阻抗$Z$是电阻（$R$）、电感（$L$）和电容（$C$）各自阻抗的总和。这些阻抗分别为$Z_R = R$，$Z_L = j \\omega L$和$Z_C = \\frac{1}{j \\omega C}$，其中$j$是满足$j^2 = -1$的虚数单位。\n\n总阻抗作为角频率$\\omega$的函数是：\n$$\nZ(\\omega) = Z_R + Z_L + Z_C = R + j \\omega L + \\frac{1}{j \\omega C}\n$$\n利用性质$\\frac{1}{j} = -j$，我们可以将阻抗重写为：\n$$\nZ(\\omega) = R + j \\omega L - \\frac{j}{\\omega C} = R + j \\left(\\omega L - \\frac{1}{\\omega C}\\right)\n$$\n阻抗$Z(\\omega)$是一个复数，包含实部（电阻）和虚部（电抗）。实部是$\\text{Re}(Z) = R$，虚部（即净电抗）是$\\text{Im}(Z) = X(\\omega) = \\omega L - \\frac{1}{\\omega C}$。\n\n问题将谐振角频率$\\omega_0$定义为净电抗为零时的频率。这个条件意味着总阻抗的虚部为零：\n$$\n\\text{Im}(Z(\\omega_0)) = 0\n$$\n代入电抗的表达式，我们得到：\n$$\n\\omega_0 L - \\frac{1}{\\omega_0 C} = 0\n$$\n为了解出$\\omega_0$，我们整理方程：\n$$\n\\omega_0 L = \\frac{1}{\\omega_0 C}\n$$\n$$\n\\omega_0^2 = \\frac{1}{LC}\n$$\n由于角频率必须是正数，我们取正平方根：\n$$\n\\omega_0 = \\frac{1}{\\sqrt{LC}} = (LC)^{-1/2}\n$$\n这就是谐振角频率作为电感值$L$和电容值$C$的函数的表达式。\n\n接下来，我们必须计算$\\omega_0$关于$C$的归一化灵敏度，其定义为：\n$$\nS_{C} \\equiv \\frac{C}{\\omega_{0}} \\frac{\\partial \\omega_{0}}{\\partial C}\n$$\n为了计算这个值，我们首先需要求出$\\omega_0$关于$C$的偏导数。我们将$L$视为常数。\n$$\n\\omega_0(C) = L^{-1/2} C^{-1/2}\n$$\n使用求导的幂法则，$\\frac{d}{dx}(x^n) = nx^{n-1}$，我们得到：\n$$\n\\frac{\\partial \\omega_0}{\\partial C} = L^{-1/2} \\left(-\\frac{1}{2} C^{-1/2 - 1}\\right) = L^{-1/2} \\left(-\\frac{1}{2} C^{-3/2}\\right)\n$$\n$$\n\\frac{\\partial \\omega_0}{\\partial C} = -\\frac{1}{2} L^{-1/2} C^{-3/2}\n$$\n现在，我们将$\\omega_0$和$\\frac{\\partial \\omega_0}{\\partial C}$的表达式代入灵敏度公式：\n$$\nS_C = \\frac{C}{\\omega_0} \\left( -\\frac{1}{2} L^{-1/2} C^{-3/2} \\right)\n$$\n代入$\\omega_0 = (LC)^{-1/2} = L^{-1/2}C^{-1/2}$：\n$$\nS_C = \\frac{C}{L^{-1/2}C^{-1/2}} \\left( -\\frac{1}{2} L^{-1/2} C^{-3/2} \\right)\n$$\n我们可以通过合并各项来简化这个表达式：\n$$\nS_C = -\\frac{1}{2} \\cdot \\frac{C}{L^{-1/2}C^{-1/2}} \\cdot L^{-1/2} C^{-3/2}\n$$\n涉及$L$的项相互抵消：分子中的$L^{-1/2}$和分母中的$L^{-1/2}$。\n$$\nS_C = -\\frac{1}{2} \\cdot \\frac{C}{C^{-1/2}} \\cdot C^{-3/2}\n$$\n现在，合并$C$的幂：\n$$\nS_C = -\\frac{1}{2} \\cdot C^{1 - (-1/2) - 3/2} = -\\frac{1}{2} \\cdot C^{1 + 1/2 - 3/2} = -\\frac{1}{2} \\cdot C^{3/2 - 3/2} = -\\frac{1}{2} \\cdot C^0\n$$\n因为任何非零数的0次幂都等于1，所以我们有：\n$$\nS_C = -\\frac{1}{2}\n$$\n谐振角频率关于电容值的归一化灵敏度是一个常数值$-\\frac{1}{2}$。这意味着电容值的微小相对增加，将导致谐振频率发生大小为其一半的相对减小。例如，$C$值增加1%会导致$\\omega_0$大约减少0.5%。", "answer": "$$\\boxed{-\\frac{1}{2}}$$", "id": "3272518"}, {"introduction": "当模型的输出无法用简单的解析式表达时，数值方法便成为分析其敏感性的关键工具。本练习以经典的Lotka-Volterra捕食者-被捕食者模型为例，要求你通过编程计算种群数量振荡周期对捕食者死亡率的敏感度。这项实践将综合运用常微分方程数值解法、事件检测和数值微分技术，让你深入理解如何对复杂动力学系统的行为进行量化分析。[@problem_id:3272403]", "problem": "考虑由以下初值问题给出的二维 Lotka–Volterra 捕食者-猎物系统\n$$\n\\frac{d x}{d t} = a\\, x - b\\, x\\, y,\\qquad \\frac{d y}{d t} = c\\, x\\, y - d\\, y,\\qquad x(0)=x_0>0,\\quad y(0)=y_0>0,\n$$\n其中，$x(t)$ 表示猎物种群数量，$y(t)$ 表示捕食者种群数量，参数 $a>0$, $b>0$, $c>0$, $d>0$ 分别表示猎物的内禀增长率、捕食率系数、捕食者的繁殖效率和捕食者的自然死亡率。时间以任意时间单位（tu）计量，参数 $d$ 的单位是反时间单位（每 tu）。对于正的参数和初始条件，解在正象限内沿着闭合轨道演化。\n\n定义周期 $T(d)$ 为从 $(x_0,y_0)$ 开始的轨迹上，捕食者种群数量 $y(t)$ 连续两次出现局部最大值之间所经过的时间。$y(t)$ 的局部最大值由其时间导数为零且符号从正变为负来确定，即当 $g(t)=\\frac{d y}{d t}$ 满足 $g(t^-)>0$ 和 $g(t^+)<0$ 时，其中时间 $t^-$ 和 $t^+$ 位于事件时间的两侧。\n\n您的任务是编写一个完整、可运行的程序，该程序针对下面指定的每个测试用例，数值估算周期对给定值 $d$ 处的捕食者自然死亡率的灵敏度，记为\n$$\nS(d) = \\frac{\\partial T}{\\partial d}.\n$$\n您必须通过对 $d$ 进行一个小的标量 $\\varepsilon>0$ 的对称扰动来近似 $S(d)$，计算相应的周期，并构建一个与基本定义一致的数值导数。所有数值计算都必须使用固定的时间步长以无量纲形式进行，并且每个事件时间（局部最大值）必须通过在时间步长端点之间进行插值来细化，以减少离散化误差。报告的灵敏度值必须以平方时间单位（tu$^2$）表示，并以浮点数形式返回。\n\n实现一个一致的单步法，以固定的步长积分该初值问题，该步长需足够精确以解析振荡；确保该方法尊重系统的结构，并在 $d$ 的小扰动下能产生稳定的周期估计。对于每个周期估计，向前积分时间，直到检测到 $y(t)$ 的两个连续局部最大值；如果在达到指定的最大积分时间之前没有发生这种情况，则认为该参数集的周期未定义，并为灵敏度传播一个未定义的数值结果。\n\n使用以下测试套件，其中每个案例以 $(a,b,c,d,x_0,y_0,\\Delta t,\\varepsilon,t_{\\max})$ 的形式给出：\n\n- 案例 1 (一般情况): $(1.0,\\,0.6,\\,0.5,\\,0.4,\\,1.5,\\,1.0,\\,10^{-3},\\,10^{-3},\\,200.0)$。\n- 案例 2 (捕食者低死亡率边界): $(1.2,\\,0.4,\\,0.3,\\,0.1,\\,3.0,\\,0.5,\\,10^{-3},\\,5\\times 10^{-4},\\,400.0)$。\n- 案例 3 (捕食者高死亡率及更强耦合): $(0.9,\\,0.7,\\,0.6,\\,0.8,\\,4.0,\\,2.5,\\,10^{-3},\\,10^{-3},\\,200.0)$。\n\n您的程序必须生成单行输出，其中按顺序包含所有三个案例的灵敏度估计值，格式为方括号内以逗号分隔的列表（例如，$[s_1,s_2,s_3]$）。值 $s_1$, $s_2$ 和 $s_3$ 必须是以平方时间单位（tu$^2$）表示的浮点数。", "solution": "在尝试提供解决方案之前，对问题进行验证。\n\n### 步骤 1：提取已知信息\n\n常微分方程（ODE）系统是 Lotka-Volterra 模型：\n$$\n\\frac{d x}{d t} = a\\, x - b\\, x\\, y\n$$\n$$\n\\frac{d y}{d t} = c\\, x\\, y - d\\, y\n$$\n初始条件为 $x(0) = x_0 > 0$ 和 $y(0) = y_0 > 0$。参数 $a, b, c, d$ 均为正常数。变量 $x(t)$ 和 $y(t)$ 分别代表猎物和捕食者种群。参数 $d$ 的单位是反时间单位（tu$^{-1}$）。\n\n周期 $T(d)$ 定义为捕食者种群 $y(t)$ 连续两个局部最大值之间经过的时间。局部最大值由 $\\frac{dy}{dt}=0$ 且导数从正变为负的点确定。\n\n目标是数值估计周期对参数 $d$ 的灵敏度，定义为：\n$$\nS(d) = \\frac{\\partial T}{\\partial d}\n$$\n该灵敏度将使用对称扰动 $\\varepsilon > 0$ 来近似：\n$$\nS(d) \\approx \\frac{T(d+\\varepsilon) - T(d-\\varepsilon)}{2\\varepsilon}\n$$\n指定的数值实现细节如下：\n- 使用一致的单步法以固定时间步长 $\\Delta t$ 进行 ODE 积分。\n- 使用插值法细化事件时间（局部最大值）。\n- 如果在最大积分时间 $t_{\\max}$ 之前未找到两个连续的最大值，则周期视为未定义。\n- 最终的灵敏度以 tu$^2$ 为单位表示。\n\n测试套件为每个案例提供了特定值，格式为 $(a, b, c, d, x_0, y_0, \\Delta t, \\varepsilon, t_{\\max})$：\n- 案例 1: $(1.0, 0.6, 0.5, 0.4, 1.5, 1.0, 10^{-3}, 10^{-3}, 200.0)$。\n- 案例 2: $(1.2, 0.4, 0.3, 0.1, 3.0, 0.5, 10^{-3}, 5\\times 10^{-4}, 400.0)$。\n- 案例 3: $(0.9, 0.7, 0.6, 0.8, 4.0, 2.5, 10^{-3}, 10^{-3}, 200.0)$。\n\n### 步骤 2：使用提取的已知信息进行验证\n\n- **科学依据：** 该问题基于 Lotka-Volterra 方程，这是数学生物学中一个基础且成熟的模型。灵敏度分析的概念是科学计算和工程学中一个标准且关键的课题。该问题在科学上是合理的。\n- **适定性：** 该问题提供了完整的信息集。对于每个测试用例，都指定了 ODE 的所有参数、初始条件和数值过程（$\\Delta t$, $\\varepsilon$, $t_{\\max}$）。周期 $T(d)$ 的定义是明确的。计算灵敏度 $S(d)$ 的数值近似任务定义清晰。该初值问题是适定的。\n- **客观性：** 该问题以精确、形式化的数学语言陈述，没有任何主观性或歧义。\n\n该问题不违反任何无效性标准：\n1.  **科学/事实不健全：** 无。模型和方法都是标准的。\n2.  **非形式化/不相关：** 无。该问题是将数值方法直接且形式化地应用于灵敏度分析。\n3.  **不完整/矛盾的设置：** 无。所有必需信息都已提供且内部一致。\n4.  **不现实/不可行：** 无。参数值适合于数值研究，计算是可行的。要求的结果单位 tu$^2$ 在量纲上与定义 $\\frac{\\partial T}{\\partial d}$ 一致，因为 $T$ 的单位是 tu，$d$ 的单位是 tu$^{-1}$。\n5.  **不适定/结构不良：** 无。问题结构清晰，待计算的量定义明确。\n6.  **伪深刻/琐碎：** 无。该问题需要一个非平凡的实现，涉及 ODE 积分、事件检测和数值微分，是计算科学中的一个标准问题。\n7.  **超出科学可验证范围：** 无。结果是可以通过数值方法验证的。\n\n### 步骤 3：结论与行动\n\n问题是 **有效的**。将提供一个解决方案。\n\n### 基于原则的设计\n\n解决方案需要对灵敏度 $S(d) = \\frac{\\partial T}{\\partial d}$ 进行数值估计，这可以通过二阶中心差分公式来解决：\n$$\nS(d) \\approx \\frac{T(d+\\varepsilon) - T(d-\\varepsilon)}{2\\varepsilon}\n$$\n这需要计算参数 $d$ 的两个扰动值 $d_{+} = d+\\varepsilon$ 和 $d_{-} = d-\\varepsilon$ 对应的周期 $T$。因此，问题的核心是开发一个稳健的函数来计算周期 $T$。\n\n通过将 ODE 系统随时间向前积分，并确定捕食者种群 $y(t)$ 连续两次局部最大值的时间来找到周期 $T$。\n\n**1. 数值积分：**\n该系统是一个初值问题（IVP）。一个合适的单步积分器是四阶 Runge-Kutta (RK$4$) 方法。对于固定的步长 $\\Delta t$，它在精度和稳定性之间提供了良好的平衡，并且符合问题的要求。给定状态向量 $\\mathbf{z}(t) = [x(t), y(t)]^T$ 和 ODE $\\frac{d\\mathbf{z}}{dt} = \\mathbf{f}(\\mathbf{z})$，从时间 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的单个 RK$4$ 步长计算如下：\n$$\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{z}_n)\n$$\n$$\n\\mathbf{k}_2 = \\mathbf{f}(\\mathbf{z}_n + \\frac{\\Delta t}{2} \\mathbf{k}_1)\n$$\n$$\n\\mathbf{k}_3 = \\mathbf{f}(\\mathbf{z}_n + \\frac{\\Delta t}{2} \\mathbf{k}_2)\n$$\n$$\n\\mathbf{k}_4 = \\mathbf{f}(\\mathbf{z}_n + \\Delta t \\mathbf{k}_3)\n$$\n$$\n\\mathbf{z}_{n+1} = \\mathbf{z}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n其中 $\\mathbf{f}(\\mathbf{z}) = [ax - bxy, cxy - dy]^T$。\n\n**2. 事件检测和细化：**\n$y(t)$ 的局部最大值出现在其导数 $\\frac{dy}{dt}$ 从正值穿过零变为负值时。该导数为 $\\frac{dy}{dt} = y(t)(c x(t) - d)$。由于 $y_0>0$ 的解保持在正象限（$y(t)>0$），极值条件简化为寻找函数 $g(t) = c x(t) - d$ 的根。\n\n我们可以通过检查 $g(t)$ 的符号变化来检测时间步 $[t_{n}, t_{n+1}]$ 内的根穿越。具体来说，如果 $g(t_n) > 0$ 且 $g(t_{n+1}) \\le 0$，则局部最大值被界定。\n\n一旦事件被界定在 $t_n$ 和 $t_{n+1}$ 之间，精确的事件时间 $t_{\\text{event}}$ 就通过对 $g(t)$ 进行线性插值（割线法）来估计。假设 $g(t)$ 在小区间 $\\Delta t$ 上是线性的，那么使 $g(t_{\\text{event}})=0$ 的时间 $t_{\\text{event}}$ 由以下公式给出：\n$$\nt_{\\text{event}} = t_n + \\Delta t \\frac{g(t_n)}{g(t_n) - g(t_{n+1})}\n$$\n与仅使用离散时间步端点相比，这个细化的时间为最大值位置提供了更准确的估计。\n\n**3. 周期计算：**\n积分从 $t=0$ 进行到 $t_{\\max}$。前两个检测到的局部最大值的细化时间 $t_{\\text{max},1}$ 和 $t_{\\text{max},2}$ 会被存储。然后周期计算为它们的差值：$T = t_{\\text{max},2} - t_{\\text{max},1}$。如果在积分时间达到 $t_{\\max}$ 之前找到的最大值少于两个，则周期被视为未定义，并返回一个`非数字`（$NaN$）值。\n\n**4. 实现结构：**\n整个算法以模块化的方式实现：\n- 一个函数实现 Lotka-Volterra 方程的右侧项 $\\mathbf{f}(\\mathbf{z})$。\n- 一个函数执行单个 RK$4$ 步长。\n- 一个主函数 `find_period` 负责协调时间积分和事件检测/细化逻辑，以计算单个周期 $T(d)$。\n- 一个函数 `calculate_sensitivity` 调用 `find_period` 来计算 $d+\\varepsilon$ 和 $d-\\varepsilon$ 的情况，并计算 $S(d)$ 的中心差分。\n- 一个主 `solve` 函数遍历所有测试用例，为每个用例调用 `calculate_sensitivity`，并按照指定格式化最终输出。这种结构确保了清晰性、正确性以及对问题规范的遵守。", "answer": "```python\nimport numpy as np\n\ndef lotka_volterra_rhs(state, a, b, c, d):\n    \"\"\"\n    Computes the right-hand side of the Lotka-Volterra equations.\n    d(state)/dt = f(state)\n    \"\"\"\n    x, y = state\n    dxdt = a * x - b * x * y\n    dydt = c * x * y - d * y\n    return np.array([dxdt, dydt])\n\ndef rk4_step(state, dt, rhs_func, a, b, c, d):\n    \"\"\"\n    Performs a single step of the fourth-order Runge-Kutta method.\n    The ODE is autonomous, so time t is not explicitly used by the RHS function.\n    \"\"\"\n    k1 = rhs_func(state, a, b, c, d)\n    k2 = rhs_func(state + 0.5 * dt * k1, a, b, c, d)\n    k3 = rhs_func(state + 0.5 * dt * k2, a, b, c, d)\n    k4 = rhs_func(state + dt * k3, a, b, c, d)\n    new_state = state + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n    return new_state\n\ndef find_period(a, b, c, d, x0, y0, dt, t_max):\n    \"\"\"\n    Numerically integrates the LV system to find the period between two\n    successive local maxima of the predator population y(t).\n    \"\"\"\n    state = np.array([x0, y0], dtype=float)\n    maxima_times = []\n\n    # Initial conditions must be positive for biologically meaningful orbits.\n    if x0 = 0 or y0 = 0:\n        return np.nan\n\n    num_steps = int(t_max / dt)\n    for step in range(num_steps):\n        state_prev = state\n        t_prev = step * dt\n\n        state = rk4_step(state_prev, dt, lotka_volterra_rhs, a, b, c, d)\n        t_curr = (step + 1) * dt\n        \n        # In the LV model, positivity is preserved. This is a safeguard.\n        if state[0] = 0 or state[1] = 0:\n            return np.nan\n\n        # The derivative of y is dy/dt = y(cx - d).\n        # We look for roots of g(t) = cx(t) - d.\n        g_prev = c * state_prev[0] - d\n        g_curr = c * state[0] - d\n        \n        # A local maximum is identified when g(t) crosses zero from positive to negative.\n        if g_prev > 0 and g_curr = 0:\n            #Denominator g_prev - g_curr cannot be zero due to the condition g_prev > 0 and g_curr = 0,\n            #unless g_prev and g_curr are both zero, which is numerically improbable.\n            denominator = g_prev - g_curr\n            t_event = t_prev + dt * g_prev / denominator\n            maxima_times.append(t_event)\n            \n            # Once two maxima are found, calculate the period and return.\n            if len(maxima_times) == 2:\n                period = maxima_times[1] - maxima_times[0]\n                return period\n\n    # If the loop completes without finding two maxima, the period is undefined.\n    return np.nan\n\ndef calculate_sensitivity(case):\n    \"\"\"\n    Calculates the sensitivity S(d) = dT/dd using a central difference scheme.\n    \"\"\"\n    a, b, c, d, x0, y0, dt, eps, t_max = case\n    \n    # Parameters must be positive; ensure d-epsilon is positive.\n    if d - eps = 0:\n        return np.nan\n\n    # Calculate period for d perturbed up and down.\n    T_plus = find_period(a, b, c, d + eps, x0, y0, dt, t_max)\n    T_minus = find_period(a, b, c, d - eps, x0, y0, dt, t_max)\n    \n    # If either period calculation failed, sensitivity is undefined.\n    if np.isnan(T_plus) or np.isnan(T_minus):\n        return np.nan\n        \n    # Central difference formula for the derivative.\n    sensitivity = (T_plus - T_minus) / (2.0 * eps)\n    return sensitivity\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # Test cases: (a, b, c, d, x0, y0, Δt, ε, t_max)\n    test_cases = [\n        (1.0, 0.6, 0.5, 0.4, 1.5, 1.0, 1e-3, 1e-3, 200.0),\n        (1.2, 0.4, 0.3, 0.1, 3.0, 0.5, 1e-3, 5e-4, 400.0),\n        (0.9, 0.7, 0.6, 0.8, 4.0, 2.5, 1e-3, 1e-3, 200.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        s = calculate_sensitivity(case)\n        results.append(s)\n        \n    # Format the output as a comma-separated list of floats in brackets.\n    # str() of np.nan produces 'nan', which is an acceptable representation of an undefined float.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main function.\nsolve()\n\n```", "id": "3272403"}, {"introduction": "灵敏度分析同样适用于由偏微分方程（PDE）描述的场问题，例如热传导或物质扩散。本练习探讨了一维扩散-反应方程的解如何响应边界条件的微小扰动。你将学习利用线性叠加原理将问题简化，并通过有限差分法构建并求解一个线性系统，最终量化边界扰动对整个求解域的影响程度，这是评估PDE模型稳定性和鲁棒性的核心步骤。[@problem_id:3191044]", "problem": "您需要量化并计算线性偏微分方程（PDE）解相对于狄利克雷边界数据扰动的灵敏度。考虑定义在域 $\\Omega = (0,L)$ 上的一维稳态扩散-反应方程：\n$$\n-\\,k\\,\\frac{d^2 u}{dx^2} + c\\,u = f \\quad \\text{on } (0,L),\n$$\n其狄利克雷边界条件为\n$$\nu(0) = g_0 + \\delta g_0, \\quad u(L) = g_L + \\delta g_L,\n$$\n其中 $k  0$ 是扩散系数，$c \\ge 0$ 是反应系数，$f$ 是给定的源项，$(\\delta g_0,\\delta g_L)$ 是微小的边界扰动。所有量均为无量纲。将对应于扰动边界 $(g_0+\\delta g_0, g_L+\\delta g_L)$ 的解定义为 $u(\\delta g)$，将 $(\\delta g_0,\\delta g_L) = (0,0)$ 时的基线解定义为 $u(0)$。对边界扰动的灵敏度由以下比率衡量\n$$\n\\alpha = \\frac{\\|u(\\delta g) - u(0)\\|}{\\|(\\delta g_0,\\delta g_L)\\|},\n$$\n其中分子是 $(0,L)$ 上的 $L^2$ 范数，分母是边界数据向量的欧几里得范数。\n\n您的任务是：\n- 从线性偏微分方程的线性叠加原理出发，构建差分场 $w = u(\\delta g) - u(0)$，该差分场求解的是一个带有非齐次狄利克雷边界数据的齐次方程。\n- 使用具有 $N$ 个内部节点的二阶中心有限差分（FD）离散化方法对 $w$ 进行数值近似。使用间距为 $h = L/(N+1)$ 的均匀网格。对于算子 $-k\\,u'' + c\\,u$，内部节点索引 $i \\in \\{1,\\dots,N\\}$ 的标准有限差分格式为\n$$\n-\\,k\\,\\frac{w_{i-1} - 2w_i + w_{i+1}}{h^2} + c\\,w_i = 0,\n$$\n其中狄利克雷值 $w_0 = \\delta g_0$ 和 $w_{N+1} = \\delta g_L$ 分别进入第一个和最后一个内部方程的右侧。\n- 使用内部节点上的离散 $L^2$ 范数来近似分子：\n$$\n\\|w\\|_{L^2(0,L)} \\approx \\left( h \\sum_{i=1}^{N} w_i^2 \\right)^{1/2}.\n$$\n- 使用欧几里得范数来计算边界扰动的大小：\n$$\n\\|(\\delta g_0,\\delta g_L)\\| = \\left( (\\delta g_0)^2 + (\\delta g_L)^2 \\right)^{1/2}.\n$$\n- 为下面的每个测试用例计算灵敏度比率 $\\alpha$。\n\n实现要求：\n- 使用线性系统求解器计算内部节点值 $(w_1,\\dots,w_N)$。\n- 仅使用如上所述的二阶中心有限差分法。\n- 所有量均为无量纲；不需要物理单位。\n- 将每个灵敏度比率 $\\alpha$ 报告为四舍五入到 $6$ 位小数的浮点数。\n\n测试套件：\n对于每个元组 $(L,k,c,N,\\delta g_0,\\delta g_L)$，计算相应的灵敏度比率 $\\alpha$：\n- 测试 1: $(L,k,c,N,\\delta g_0,\\delta g_L) = (\\,1.0,\\,1.0,\\,0.0,\\,200,\\,0.1,\\,-0.05\\,)$.\n- 测试 2: $(L,k,c,N,\\delta g_0,\\delta g_L) = (\\,5.0,\\,1.0,\\,0.0,\\,200,\\,0.1,\\,-0.05\\,)$.\n- 测试 3: $(L,k,c,N,\\delta g_0,\\delta g_L) = (\\,1.0,\\,1.0,\\,1.0,\\,200,\\,0.1,\\,-0.05\\,)$.\n- 测试 4: $(L,k,c,N,\\delta g_0,\\delta g_L) = (\\,0.25,\\,1.0,\\,10.0,\\,100,\\,0.0,\\,0.2\\,)$.\n- 测试 5: $(L,k,c,N,\\delta g_0,\\delta g_L) = (\\,2.0,\\,0.5,\\,0.0,\\,300,\\,0.05,\\,0.05\\,)$.\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的列表，该列表按测试顺序包含 5 个四舍五入后的灵敏度比率，例如“[a,b,c,d,e]”。每个条目必须四舍五入到 6 位小数，并以标准十进制表示法打印，不使用科学记数法。\n\n注意：您必须提供一个完整、可运行的程序，该程序需按规定实现有限差分法，并以所述的确切格式输出结果。不要读取任何输入；将测试套件硬编码在您的程序中。", "solution": "用户提供的问题经评估有效。该问题在科学上是合理的、适定的，并且为完整的数值求解提供了所有必要的参数。该问题要求计算线性偏微分方程（PDE）关于边界条件扰动的灵敏度比率，这是计算科学中灵敏度分析的标准程序。\n\n求解过程分为四个基本步骤：\n1.  推导解差分的控制方程。\n2.  使用有限差分法对该方程进行离散化。\n3.  构建并求解所得的线性方程组。\n4.  使用离散范数计算灵敏度比率。\n\n**1. 叠加原理与差分场**\n该控制性 PDE 是一个线性二阶常微分方程：\n$$\n-\\,k\\,\\frac{d^2 u}{dx^2} + c\\,u = f \\quad \\text{for } x \\in (0,L)\n$$\n我们将线性微分算子表示为 $\\mathcal{L}u = -k\\,u'' + c\\,u$。该问题涉及一个基线解 $u(0)$（对应于边界条件 $u(0)(0) = g_0$ 和 $u(0)(L) = g_L$）和一个扰动解 $u(\\delta g)$（对应于边界条件 $u(\\delta g)(0) = g_0 + \\delta g_0$ 和 $u(\\delta g)(L) = g_L + \\delta g_L$）。\n\n这两种情况的方程为：\n$$\n\\mathcal{L}u(0) = f, \\quad \\text{with B.C.s } u(0)(0) = g_0, u(0)(L) = g_L\n$$\n$$\n\\mathcal{L}u(\\delta g) = f, \\quad \\text{with B.C.s } u(\\delta g)(0) = g_0 + \\delta g_0, u(\\delta g)(L) = g_L + \\delta g_L\n$$\n我们关心的是定义为 $w = u(\\delta g) - u(0)$ 的差分场。由于算子 $\\mathcal{L}$ 的线性特性，我们可以写出：\n$$\n\\mathcal{L}w = \\mathcal{L}(u(\\delta g) - u(0)) = \\mathcal{L}u(\\delta g) - \\mathcal{L}u(0) = f - f = 0\n$$\n因此，差分场 $w$ 满足原 PDE 的齐次形式：\n$$\n-\\,k\\,\\frac{d^2 w}{dx^2} + c\\,w = 0\n$$\n$w$ 的边界条件可以通过从扰动边界条件中减去基线边界条件得到：\n$$\nw(0) = u(\\delta g)(0) - u(0)(0) = (g_0 + \\delta g_0) - g_0 = \\delta g_0\n$$\n$$\nw(L) = u(\\delta g)(L) - u(0)(L) = (g_L + \\delta g_L) - g_L = \\delta g_L\n$$\n该推导证实，解对边界扰动的灵敏度可以通过求解一个更简单的齐次 PDE 来分析，该 PDE 针对差分场 $w$，并以扰动本身作为新的边界条件。\n\n**2. 有限差分离散化**\n为了数值求解 $w(x)$，我们使用一个包含 $N$ 个内部节点的均匀网格对域 $(0,L)$ 进行离散化。网格点为 $x_i = i h$，其中 $i = 0, 1, \\dots, N+1$，网格间距为 $h = L/(N+1)$。在这些节点上的离散解记为 $w_i \\approx w(x_i)$。\n\n在内部节点 $x_i$ 处的二阶导数 $w''(x_i)$ 使用二阶中心有限差分公式进行近似：\n$$\n\\frac{d^2 w}{dx^2}\\bigg|_{x=x_i} \\approx \\frac{w_{i-1} - 2w_i + w_{i+1}}{h^2}\n$$\n将此式代入 $w$ 的齐次 PDE，得到每个内部节点 $i \\in \\{1, 2, \\dots, N\\}$ 的离散方程：\n$$\n-\\,k\\,\\frac{w_{i-1} - 2w_i + w_{i+1}}{h^2} + c\\,w_i = 0\n$$\n重新整理此方程，将包含未知值 $w_1, \\dots, w_N$ 的项组合到左侧，可得：\n$$\n-\\frac{k}{h^2}w_{i-1} + \\left(\\frac{2k}{h^2} + c\\right)w_i - \\frac{k}{h^2}w_{i+1} = 0\n$$\n\n**3. 线性系统的构建与求解**\n这 $N$ 个离散方程构成一个线性方程组，可以写成矩阵形式 $A\\mathbf{w} = \\mathbf{b}$，其中 $\\mathbf{w} = [w_1, w_2, \\dots, w_N]^T$ 是内部节点上未知解值的向量。\n\n边界值 $w_0 = \\delta g_0$ 和 $w_{N+1} = \\delta g_L$ 是已知量。它们被整合到第一个（$i=1$）和最后一个（$i=N$）内部节点的方程中：\n\n对于 $i=1$：\n$$\n-\\frac{k}{h^2}w_0 + \\left(\\frac{2k}{h^2} + c\\right)w_1 - \\frac{k}{h^2}w_2 = 0 \\implies \\left(\\frac{2k}{h^2} + c\\right)w_1 - \\frac{k}{h^2}w_2 = \\frac{k}{h^2}w_0 = \\frac{k}{h^2}\\delta g_0\n$$\n\n对于 $i=N$：\n$$\n-\\frac{k}{h^2}w_{N-1} + \\left(\\frac{2k}{h^2} + c\\right)w_N - \\frac{k}{h^2}w_{N+1} = 0 \\implies -\\frac{k}{h^2}w_{N-1} + \\left(\\frac{2k}{h^2} + c\\right)w_N = \\frac{k}{h^2}w_{N+1} = \\frac{k}{h^2}\\delta g_L\n$$\n得到的 $N \\times N$ 矩阵 $A$ 是一个对称三对角矩阵，其结构如下：\n-   主对角线元素：$A_{ii} = \\frac{2k}{h^2} + c$\n-   次对角线和超对角线元素：$A_{i,i-1} = A_{i,i+1} = -\\frac{k}{h^2}$\n\n右侧向量 $\\mathbf{b}$ 的大小为 $N \\times 1$：\n$$\n\\mathbf{b} = \\begin{bmatrix} (k/h^2)\\delta g_0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ (k/h^2)\\delta g_L \\end{bmatrix}\n$$\n使用标准的线性代数求解器求解该线性系统 $A\\mathbf{w}=\\mathbf{b}$，以得到向量 $\\mathbf{w}$。对于给定的参数（$k0, c \\ge 0$），矩阵 $A$ 是严格对角占优的，这保证了唯一解的存在。\n\n**4. 灵敏度比率的计算**\n灵敏度比率 $\\alpha$ 定义为输出差分的范数与输入扰动的范数之比：\n$$\n\\alpha = \\frac{\\|w\\|_{L^2(0,L)}}{\\|(\\delta g_0,\\delta g_L)\\|}\n$$\n分子使用离散 $L^2$ 范数进行近似，该范数涉及对计算出的内部解值 $w_i$ 的求和：\n$$\n\\|w\\|_{L^2(0,L)} \\approx \\left( h \\sum_{i=1}^{N} w_i^2 \\right)^{1/2}\n$$\n分母是边界扰动向量的标准欧几里得范数：\n$$\n\\|(\\delta g_0,\\delta g_L)\\| = \\sqrt{(\\delta g_0)^2 + (\\delta g_L)^2}\n$$\n通过根据已解出的向量 $\\mathbf{w}$ 和给定的扰动 $(\\delta g_0, \\delta g_L)$ 计算这两个范数，即可为每个测试用例计算出灵敏度比率 $\\alpha$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the sensitivity ratio for a series of test cases based on a\n    finite difference discretization of a diffusion-reaction PDE.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, k, c, N, delta_g0, delta_gL)\n        (1.0, 1.0, 0.0, 200, 0.1, -0.05),\n        (5.0, 1.0, 0.0, 200, 0.1, -0.05),\n        (1.0, 1.0, 1.0, 200, 0.1, -0.05),\n        (0.25, 1.0, 10.0, 100, 0.0, 0.2),\n        (2.0, 0.5, 0.0, 300, 0.05, 0.05),\n    ]\n\n    results = []\n    for L, k, c, N, delta_g0, delta_gL in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        alpha = compute_sensitivity(L, k, c, N, delta_g0, delta_gL)\n        results.append(alpha)\n\n    # Final print statement in the exact required format.\n    # Each value is rounded to 6 decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\ndef compute_sensitivity(L: float, k: float, c: float, N: int, delta_g0: float, delta_gL: float) -> float:\n    \"\"\"\n    Solves for the difference field w and computes the sensitivity ratio alpha.\n\n    Args:\n        L: Domain length.\n        k: Diffusion coefficient.\n        c: Reaction coefficient.\n        N: Number of interior nodes.\n        delta_g0: Perturbation at the x=0 boundary.\n        delta_gL: Perturbation at the x=L boundary.\n\n    Returns:\n        The computed sensitivity ratio alpha.\n    \"\"\"\n    # 1. Setup grid and constants\n    h = L / (N + 1)\n    k_over_h2 = k / (h**2)\n\n    # 2. Assemble the linear system A*w = b\n    # A is an N x N tridiagonal matrix\n    main_diag = (2 * k_over_h2 + c) * np.ones(N)\n    off_diag = -k_over_h2 * np.ones(N - 1)\n    \n    A = np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n    \n    # b is the N x 1 right-hand side vector\n    b = np.zeros(N)\n    b[0] = k_over_h2 * delta_g0\n    b[N - 1] = k_over_h2 * delta_gL\n\n    # 3. Solve the linear system for the interior solution w\n    w = np.linalg.solve(A, b)\n\n    # 4. Compute norms and the sensitivity ratio alpha\n    # Numerator: Discrete L2 norm of the solution difference w\n    # ||w||_L2 ≈ sqrt(h * sum(w_i^2))\n    norm_w_l2 = np.sqrt(h * np.sum(np.square(w)))\n\n    # Denominator: Euclidean norm of the boundary perturbations\n    norm_delta_g = np.sqrt(delta_g0**2 + delta_gL**2)\n\n    # Handle the case of zero perturbation to avoid division by zero\n    if norm_delta_g == 0:\n        return 0.0\n\n    alpha = norm_w_l2 / norm_delta_g\n    \n    return alpha\n\nsolve()\n```", "id": "3191044"}]}