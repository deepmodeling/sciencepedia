{"hands_on_practices": [{"introduction": "所有克雷洛夫子空间方法的核心都是逐步构建一个名为克雷洛夫子空间的特殊向量空间。这个练习将带你亲手构建这样一个子空间，通过重复将矩阵乘以一个起始向量，并检查生成向量的线性无关性，从而直观地理解其维度和结构。[@problem_id:2183348]", "problem": "考虑实矩阵 $A$ 和实列向量 $b$ 如下所示：\n$$A = \\begin{pmatrix} 1 & 1 & 0 \\\\ 1 & 2 & 1 \\\\ 0 & 1 & 1 \\end{pmatrix}, \\quad b = \\begin{pmatrix} 4 \\\\ 1 \\\\ 0 \\end{pmatrix}$$\n由 $A$ 和 $b$ 生成的 $m$ 阶 Krylov 子空间，记作 $\\mathcal{K}_m(A, b)$，是由向量 $\\{b, Ab, A^2b, \\dots, A^{m-1}b\\}$ 张成的线性子空间。求 Krylov 子空间 $\\mathcal{K}_3(A, b)$ 的维数。", "solution": "Krylov 子空间 $\\mathcal{K}_{3}(A,b)$ 是由 $\\{b, Ab, A^{2}b\\}$ 张成的空间。为了确定其维数，我们计算这些向量并检验它们的线性无关性。\n已知\n$$\nA = \\begin{pmatrix} 1 & 1 & 0 \\\\ 1 & 2 & 1 \\\\ 0 & 1 & 1 \\end{pmatrix}, \\quad b = \\begin{pmatrix} 4 \\\\ 1 \\\\ 0 \\end{pmatrix},\n$$\n我们计算\n$$\nAb = A\\begin{pmatrix} 4 \\\\ 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 \\cdot 4 + 1 \\cdot 1 + 0 \\cdot 0 \\\\ 1 \\cdot 4 + 2 \\cdot 1 + 1 \\cdot 0 \\\\ 0 \\cdot 4 + 1 \\cdot 1 + 1 \\cdot 0 \\end{pmatrix} = \\begin{pmatrix} 5 \\\\ 6 \\\\ 1 \\end{pmatrix}.\n$$\n接着，\n$$\nA^{2}b = A(Ab) = A\\begin{pmatrix} 5 \\\\ 6 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1 \\cdot 5 + 1 \\cdot 6 + 0 \\cdot 1 \\\\ 1 \\cdot 5 + 2 \\cdot 6 + 1 \\cdot 1 \\\\ 0 \\cdot 5 + 1 \\cdot 6 + 1 \\cdot 1 \\end{pmatrix} = \\begin{pmatrix} 11 \\\\ 18 \\\\ 7 \\end{pmatrix}.\n$$\n将这些向量作为列构成矩阵：\n$$\nK = \\begin{pmatrix} 4 & 5 & 11 \\\\ 1 & 6 & 18 \\\\ 0 & 1 & 7 \\end{pmatrix}.\n$$\n这些向量线性无关，当且仅当 $\\det(K) \\neq 0$。计算\n$$\n\\det(K) = 4\\begin{vmatrix} 6 & 18 \\\\ 1 & 7 \\end{vmatrix} - 5\\begin{vmatrix} 1 & 18 \\\\ 0 & 7 \\end{vmatrix} + 11\\begin{vmatrix} 1 & 6 \\\\ 0 & 1 \\end{vmatrix}\n= 4(42 - 18) - 5(7) + 11(1) = 96 - 35 + 11 = 72 \\neq 0.\n$$\n因此，$\\{b, Ab, A^{2}b\\}$ 是线性无关的，$\\mathcal{K}_{3}(A,b)$ 的维数是 $3$。", "answer": "$$\\boxed{3}$$", "id": "2183348"}, {"introduction": "共轭梯度（CG）法是求解大型对称正定线性系统的关键算法，其效率源于巧妙地选择一系列相互“共轭”的搜索方向。这个练习将让你深入CG算法的“引擎室”，通过计算新的搜索方向，来理解算法如何利用当前和之前的残差信息来保证迭代的最优性。[@problem_id:2183344]", "problem": "共轭梯度（CG）法是一种迭代算法，在科学计算中广泛用于求解形式为 $Ax=b$ 的大型线性方程组，特别是那些由偏微分方程离散化产生的方程组。该方法通过沿着一系列相对于系统矩阵 $A$ 互相共轭的搜索方向移动来优化近似解。\n\n假设您正在分析CG方法的一次特定运行。算法正处于步骤 $k=1$ 的开始阶段。您被提供了以下数据：\n- 当前的残差向量是 $r_1 = [-1, 2, -1]^T$。\n- 初始步骤（$k=0$）的残差向量是 $r_0 = [5, 5, 5]^T$。\n- 初始步骤（$k=0$）的搜索方向是 $p_0 = [5, 5, 5]^T$。\n\n使用共轭梯度法的标准 Fletcher-Reeves 公式，确定新的搜索方向向量 $p_1$。将您的答案表示为一个分量为有理数的列向量。", "solution": "共轭梯度（CG）法的标准 Fletcher-Reeves 公式在第 $k$ 次迭代时，使用当前残差 $r_k$ 和前一个搜索方向 $p_{k-1}$ 来更新搜索方向 $p_k$。更新规则由下式给出：\n$$p_k = r_k + \\beta_{k-1} p_{k-1}$$\n系数 $\\beta_{k-1}$ 是一个由当前和前一个残差计算出的标量：\n$$\\beta_{k-1} = \\frac{r_k^T r_k}{r_{k-1}^T r_{k-1}}$$\n在本题中，我们需要求解步骤 $k=1$ 时的新搜索方向 $p_1$。针对此特定步骤的更新规则是：\n$$p_1 = r_1 + \\beta_0 p_0$$\n且系数 $\\beta_0$ 由下式给出：\n$$\\beta_0 = \\frac{r_1^T r_1}{r_0^T r_0}$$\n我们已知以下向量：\n$r_1 = \\begin{pmatrix} -1 \\\\ 2 \\\\ -1 \\end{pmatrix}$, $r_0 = \\begin{pmatrix} 5 \\\\ 5 \\\\ 5 \\end{pmatrix}$, and $p_0 = \\begin{pmatrix} 5 \\\\ 5 \\\\ 5 \\end{pmatrix}$。\n\n首先，我们需要计算标量 $\\beta_0$。这涉及到计算残差向量 $r_1$ 和 $r_0$ 的点积（或欧几里得范数的平方）。\n\n分子 $r_1^T r_1$ 是：\n$$r_1^T r_1 = \\begin{pmatrix} -1 & 2 & -1 \\end{pmatrix} \\begin{pmatrix} -1 \\\\ 2 \\\\ -1 \\end{pmatrix} = (-1)(-1) + (2)(2) + (-1)(-1) = 1 + 4 + 1 = 6$$\n\n分母 $r_0^T r_0$ 是：\n$$r_0^T r_0 = \\begin{pmatrix} 5 & 5 & 5 \\end{pmatrix} \\begin{pmatrix} 5 \\\\ 5 \\\\ 5 \\end{pmatrix} = (5)(5) + (5)(5) + (5)(5) = 25 + 25 + 25 = 75$$\n\n现在，我们可以计算 $\\beta_0$：\n$$\\beta_0 = \\frac{6}{75} = \\frac{2 \\times 3}{25 \\times 3} = \\frac{2}{25}$$\n\n有了 $\\beta_0$ 的值，我们现在可以求解新的搜索方向向量 $p_1$：\n$$p_1 = r_1 + \\beta_0 p_0$$\n代入向量和 $\\beta_0$ 的值：\n$$p_1 = \\begin{pmatrix} -1 \\\\ 2 \\\\ -1 \\end{pmatrix} + \\frac{2}{25} \\begin{pmatrix} 5 \\\\ 5 \\\\ 5 \\end{pmatrix}$$\n首先，对向量 $p_0$ 进行标量乘法：\n$$\\frac{2}{25} \\begin{pmatrix} 5 \\\\ 5 \\\\ 5 \\end{pmatrix} = \\begin{pmatrix} \\frac{2 \\times 5}{25} \\\\ \\frac{2 \\times 5}{25} \\\\ \\frac{2 \\times 5}{25} \\end{pmatrix} = \\begin{pmatrix} \\frac{10}{25} \\\\ \\frac{10}{25} \\\\ \\frac{10}{25} \\end{pmatrix} = \\begin{pmatrix} \\frac{2}{5} \\\\ \\frac{2}{5} \\\\ \\frac{2}{5} \\end{pmatrix}$$\n现在，进行向量加法：\n$$p_1 = \\begin{pmatrix} -1 \\\\ 2 \\\\ -1 \\end{pmatrix} + \\begin{pmatrix} \\frac{2}{5} \\\\ \\frac{2}{5} \\\\ \\frac{2}{5} \\end{pmatrix} = \\begin{pmatrix} -1 + \\frac{2}{5} \\\\ 2 + \\frac{2}{5} \\\\ -1 + \\frac{2}{5} \\end{pmatrix}$$\n为了相加各分量，我们使用通分：\n$$p_1 = \\begin{pmatrix} -\\frac{5}{5} + \\frac{2}{5} \\\\ \\frac{10}{5} + \\frac{2}{5} \\\\ -\\frac{5}{5} + \\frac{2}{5} \\end{pmatrix} = \\begin{pmatrix} \\frac{-3}{5} \\\\ \\frac{12}{5} \\\\ \\frac{-3}{5} \\end{pmatrix}$$\n因此，新的搜索方向向量是 $p_1 = [-\\frac{3}{5}, \\frac{12}{5}, -\\frac{3}{5}]^T$。", "answer": "$$\\boxed{\\begin{pmatrix} -\\frac{3}{5} \\\\ \\frac{12}{5} \\\\ -\\frac{3}{5} \\end{pmatrix}}$$", "id": "2183344"}, {"introduction": "为什么有些问题用共轭梯度法（CG）能闪电般收敛，而另一些则步履维艰？这个实践将通过一个数值实验来揭示答案，让你亲手验证矩阵的特征值分布是如何深刻影响CG算法收敛速度的。通过编写代码并观察结果，你将把抽象的理论与具体、可量化的性能联系起来，从而获得对克雷洛夫方法更深层次的理解。[@problem_id:3149643]", "problem": "要求您设计并执行一个数值实验，从第一性原理出发，演示对称正定（SPD）矩阵的特征值聚类如何加速共轭梯度（CG）法（一种克雷洛夫子空间法）。该实验必须实现为一个完整的、可运行的程序。您的程序必须构造形式为 $A = Q \\,\\operatorname{diag}(\\{\\lambda_i\\}_{i=1}^n)\\, Q^\\top$ 的矩阵，其中 $Q$ 是一个正交矩阵，特征值 $\\{\\lambda_i\\}$ 的选择旨在产生不同的谱聚类模式。您必须跟踪由共轭梯度（CG）法生成的残差序列 $\\{\\lVert r_k \\rVert_2\\}_{k=0,1,\\dots}$ 的欧几里得二范数，其中 $r_k = b - A x_k$，并以此来量化收敛性。\n\n从以下核心定义和经过充分检验的事实开始：\n- 一个实矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是对称正定（SPD）的，如果 $A^\\top = A$ 且对于所有非零 $x \\in \\mathbb{R}^n$ 都有 $x^\\top A x > 0$。\n- 共轭梯度（CG）法是一种克雷洛夫子空间（KS）法，对于 SPD 矩阵 $A$，它产生的迭代值 $x_k \\in x_0 + \\mathcal{K}_k(A,r_0)$ 及其残差 $r_k = b - A x_k$，其中第 $k$ 个克雷洛夫子空间为 $\\mathcal{K}_k(A,r_0) = \\operatorname{span}\\{r_0, A r_0, A^2 r_0, \\dots, A^{k-1} r_0\\}$。\n- 存在一个 $k$ 次多项式 $p_k$ 满足 $p_k(0) = 1$，使得 $r_k = p_k(A)\\, r_0$。因此，CG 的收敛性取决于一个 $k$ 次多项式在 $A$ 的谱（即集合 $\\{\\lambda_i\\}$）上能变得多小。\n\n您的程序必须执行以下操作：\n1. 固定维度 $n = 120$，最大迭代次数 $K_{\\max} = 50$，以及容差 $\\text{tol} = 10^{-10}$。使用初始猜测 $x_0 = 0$ 和一个固定的右端项 $b \\in \\mathbb{R}^n$，其元素为使用固定种子 $s_b = 27182$ 生成的独立标准正态分布。使用固定种子 $s_Q = 31415$ 构造一个单一的正交矩阵 $Q \\in \\mathbb{R}^{n \\times n}$，方法是生成一个高斯随机矩阵，应用 QR 分解，并调整列的符号以使 $Q$ 是正交的（此过程近似于从正交群上的哈尔分布中抽样）。\n2. 对于下面的每个测试用例，使用指定的特征值构造 $A = Q \\,\\operatorname{diag}(\\{\\lambda_i\\})\\, Q^\\top$。运行共轭梯度（CG）法，最多进行 $K_{\\max}$ 次迭代，并跟踪相对残差范数序列 $\\rho_k = \\lVert r_k \\rVert_2 / \\lVert r_0 \\rVert_2$（$k = 0,1,\\dots,K_{\\max}$）。将一个测试用例的收敛迭代次数定义为满足 $\\rho_k \\le \\text{tol}$ 的最小整数 $k \\in \\{1,2,\\dots,K_{\\max}\\}$。如果在 $K_{\\max}$ 次迭代内不存在这样的 $k$，则将次数记为 $K_{\\max} + 1$。\n3. 对所有测试用例使用相同的 $Q$ 和 $b$，以分离出特征值分布的影响。\n\n测试套件（四个矩阵，旨在覆盖理想情况、谱分布散情况、双聚类情况和边界情况）：\n- 用例 1（紧密聚类加两个离群值）：\n  - 维度 $n = 120$。\n  - 特征值：116 个 $1.0$，2 个 $5.0$ 和 2 个 $20.0$。\n- 用例 2（均匀分布的谱）：\n  - 维度 $n = 120$。\n  - 特征值：在闭区间 $\\left[0.1,\\,20.0\\right]$ 内线性分布的 120 个不同值。\n- 用例 3（两个紧密聚类）：\n  - 维度 $n = 120$。\n  - 特征值：60 个 $0.5$ 和 60 个 $5.0$。\n- 用例 4（边界情况：完美聚类）：\n  - 维度 $n = 120$。\n  - 特征值：120 个 $3.0$。\n\n实现要求：\n- 仅使用基于残差和搜索方向的三项递推关系实现 CG，其中 $x_0 = 0$，$r_0 = b$，$p_0 = r_0$，步长 $\\alpha_k = \\dfrac{r_k^\\top r_k}{p_k^\\top A p_k}$，更新 $x_{k+1} = x_k + \\alpha_k p_k$，$r_{k+1} = r_k - \\alpha_k A p_k$，以及方向更新 $p_{k+1} = r_{k+1} + \\beta_{k+1} p_k$，其中 $\\beta_{k+1} = \\dfrac{r_{k+1}^\\top r_{k+1}}{r_k^\\top r_k}$。\n- 通过构造确保 $A$ 是精确对称的。\n\n最终输出规格：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表。该列表必须包含四个整数，每个测试用例一个，按上述顺序列出。对于每个测试用例，输出上面定义的收敛迭代次数。例如，输出必须如下所示：\n  - 示例格式：$[\\text{用例1\\_次数},\\text{用例2\\_次数},\\text{用例3\\_次数},\\text{用例4\\_次数}]$。\n- 不得打印任何附加文本。\n\n不涉及角度单位，也没有物理单位。所有数值答案必须根据上述规则报告为整数。不需要用户输入；程序必须是自包含的，并在给定种子下是确定性的。", "solution": "我们从共轭梯度（CG）法在对称正定（SPD）矩阵上的基本性质以及克雷洛夫子空间的结构出发。设 $A \\in \\mathbb{R}^{n \\times n}$ 为 SPD 矩阵，$b \\in \\mathbb{R}^n$，并给定初始猜测 $x_0 \\in \\mathbb{R}^n$。残差为 $r_k = b - A x_k$。CG 的第 $k$ 次迭代满足 $x_k \\in x_0 + \\mathcal{K}_k(A,r_0)$，其中 $\\mathcal{K}_k(A,r_0) = \\operatorname{span}\\{r_0, A r_0, \\dots, A^{k-1} r_0\\}$。存在一个 $k$ 次多项式 $p_k$，满足 $p_k(0) = 1$，使得 $r_k = p_k(A)\\, r_0$。这种多项式表示揭示了 CG 的收敛性取决于一个受 $p_k(0)=1$ 约束的 $k$ 次多项式在谱 $\\sigma(A) = \\{\\lambda_i\\}_{i=1}^n$ 上能变得多小。\n\n如果谱是聚类的，那么存在阶数相对较低的多项式，在这些聚类上可以同时很小。在极端情况下，如果 $A$ 恰好有 $m$ 个不同的特征值，那么存在一个 $m$ 次多项式 $q$，对于每个不同的特征值 $\\lambda^{(j)}$，它都满足插值条件 $q(\\lambda^{(j)}) = 0$ 且 $q(0) = 1$。那么 $q(A)$ 在对应于这些特征值的不变子空间上是零算子，并且在精确算术中，CG 最多在 $m$ 步内终止，且 $r_m = 0$。这一原理是特征值聚类加速 CG 的根本原因。\n\n相比之下，如果特征值分布在一个宽泛的区间内且有许多不同的值，那么受 $p_k(0)=1$ 约束的最佳 $k$ 次多项式无法在整个分布上一致地变小，除非 $k$ 很大。一个经典的结果是基于切比雪夫的界（在误差的 $A$-范数下），它涉及条件数 $\\kappa(A)$，其中因子 $\\left(\\frac{\\sqrt{\\kappa}-1}{\\sqrt{\\kappa}+1}\\right)^k$ 控制着衰减率；宽泛的谱分布通常会增加 $\\kappa(A)$ 并减慢收敛速度。\n\n实验的算法设计：\n1. 我们将矩阵构造为 $A = Q \\,\\operatorname{diag}(\\{\\lambda_i\\})\\, Q^\\top$，其中 $Q$ 是正交的。我们对所有测试使用一个固定的 $Q$ 来分离谱效应。正交矩阵 $Q$ 是通过创建一个高斯随机矩阵并应用带有列符号归一化的 QR 分解生成的，以确保 $Q^\\top Q = I$。此方法近似于一个哈尔分布的正交矩阵。\n2. 我们将 $b$ 生成为一个标准正态随机向量，以避免偏向任何特定的特征子空间，并固定种子以保证可复现性。我们使用 $x_0 = 0$，因此 $r_0 = b$。\n3. 我们使用三项递推关系实现 CG：\n   - 初始化 $x_0 = 0$，$r_0 = b$，$p_0 = r_0$，$\\rho_0 = \\lVert r_0 \\rVert_2 / \\lVert r_0 \\rVert_2 = 1$。\n   - 对于 $k = 0,1,\\dots,K_{\\max}-1$：\n     - 计算 $Ap_k = A p_k$，$\\alpha_k = \\dfrac{r_k^\\top r_k}{p_k^\\top A p_k}$。\n     - 更新 $x_{k+1} = x_k + \\alpha_k p_k$，$r_{k+1} = r_k - \\alpha_k Ap_k$。\n     - 计算 $\\rho_{k+1} = \\lVert r_{k+1} \\rVert_2 / \\lVert r_0 \\rVert_2$。\n     - 如果 $\\rho_{k+1} \\le \\text{tol}$，将收敛迭代次数记录为 $k+1$ 并停止该用例的计算。\n     - 否则计算 $\\beta_{k+1} = \\dfrac{r_{k+1}^\\top r_{k+1}}{r_k^\\top r_k}$ 并设置 $p_{k+1} = r_{k+1} + \\beta_{k+1} p_k$。\n   - 如果在 $K_{\\max}$ 次迭代内没有 $\\rho_k$ 满足容差，则将次数定义为 $K_{\\max}+1$。\n4. 测试套件设计：\n   - 用例 1 使用 116 个 $\\lambda = 1.0$ 的副本和两个离群值 $\\lambda = 5.0$ 和 $\\lambda = 20.0$（各两个副本）。只有 3 个不同的特征值，因此在精确算术中 CG 最多在 3 步内终止。因此，我们预期迭代次数会非常小。\n   - 用例 2 使用 120 个在 $\\left[0.1, 20.0\\right]$ 上均匀分布的不同特征值。谱分布很宽，且许多不同的值意味着 CG 需要多次迭代才能减小残差，因此我们预计在 $K_{\\max} = 50$ 次迭代内不会收敛到 $\\text{tol} = 10^{-10}$，从而得到迭代次数 51。\n   - 用例 3 使用一个双聚类谱，其中有 60 个副本在 $\\lambda = 0.5$ 处，60 个副本在 $\\lambda = 5.0$ 处。有 2 个不同的特征值，因此在精确算术中 CG 最多在 2 步内终止。我们预计迭代次数约为 2。\n   - 用例 4 是边界情况，有 120 个副本在 $\\lambda = 3.0$ 处。只有 1 个不同的特征值；在精确算术中 CG 在 1 步内终止。在数值上，使用双精度浮点数，相对残差应在一次迭代后远低于 $\\text{tol} = 10^{-10}$。\n\n给定固定的种子，$n = 120$，容差 $\\text{tol} = 10^{-10}$，以及 $K_{\\max} = 50$，程序确定性地计算每个用例中使得 $\\rho_k \\le \\text{tol}$ 的最小 $k$。基于上述谱分析，预期的输出是强调聚类带来的加速效应的整数。具体来说，我们预计结果为\n- 用例 1: 3，\n- 用例 2: 51，\n- 用例 3: 2，\n- 用例 4: 1。\n\n最终程序将生成一行包含四个用方括号括起来的逗号分隔整数，按用例顺序排列，即 $[3,51,2,1]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef random_orthogonal(n: int, seed: int) -> np.ndarray:\n    rng = np.random.default_rng(seed)\n    G = rng.standard_normal((n, n))\n    # QR decomposition\n    Q, R = np.linalg.qr(G)\n    # Normalize signs to ensure deterministic orientation\n    d = np.sign(np.diag(R))\n    d[d == 0] = 1.0\n    Q = Q @ np.diag(d)\n    return Q\n\ndef build_spd_from_spectrum(eigs: np.ndarray, Q: np.ndarray) -> np.ndarray:\n    D = np.diag(eigs)\n    A = Q @ D @ Q.T\n    # Symmetrize to counteract tiny numerical asymmetry\n    A = 0.5 * (A + A.T)\n    return A\n\ndef conjugate_gradient(A: np.ndarray, b: np.ndarray, kmax: int, tol: float):\n    n = A.shape[0]\n    x = np.zeros(n)\n    r = b.copy()\n    p = r.copy()\n    rTr = float(r @ r)\n    r0_norm = np.sqrt(rTr)\n    rel_residuals = [1.0]  # k=0\n    if r0_norm == 0.0:\n        return rel_residuals, 0  # Already converged\n    for k in range(kmax):\n        Ap = A @ p\n        denom = float(p @ Ap)\n        # For SPD, denom should be positive\n        if denom = 0:\n            # Breakdown (should not happen for SPD), stop\n            return rel_residuals, kmax + 1\n        alpha = rTr / denom\n        x = x + alpha * p\n        r = r - alpha * Ap\n        r_new_Tr = float(r @ r)\n        rel = np.sqrt(r_new_Tr) / r0_norm\n        rel_residuals.append(rel)\n        if rel = tol:\n            return rel_residuals, (k + 1)\n        beta = r_new_Tr / rTr\n        p = r + beta * p\n        rTr = r_new_Tr\n    return rel_residuals, (kmax + 1)\n\ndef solve():\n    # Common parameters\n    n = 120\n    K_max = 50\n    tol = 1e-10\n    seed_Q = 31415\n    seed_b = 27182\n\n    # Construct a single orthogonal Q\n    Q = random_orthogonal(n, seed_Q)\n\n    # Right-hand side b\n    rng_b = np.random.default_rng(seed_b)\n    b = rng_b.standard_normal(n)\n\n    # Test cases (eigenvalue spectra)\n    # Case 1: 116 x 1.0, 2 x 5.0, 2 x 20.0\n    eigs_case1 = np.array([1.0]*116 + [5.0]*2 + [20.0]*2, dtype=float)\n\n    # Case 2: 120 distinct values in [0.1, 20.0]\n    eigs_case2 = np.linspace(0.1, 20.0, n, dtype=float)\n\n    # Case 3: 60 x 0.5, 60 x 5.0\n    eigs_case3 = np.array([0.5]*60 + [5.0]*60, dtype=float)\n\n    # Case 4: 120 x 3.0\n    eigs_case4 = np.array([3.0]*n, dtype=float)\n\n    spectra = [eigs_case1, eigs_case2, eigs_case3, eigs_case4]\n\n    results = []\n    for eigs in spectra:\n        A = build_spd_from_spectrum(eigs, Q)\n        _, iters = conjugate_gradient(A, b, K_max, tol)\n        results.append(int(iters))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3149643"}]}