{"hands_on_practices": [{"introduction": "在使用任何数值格式之前，我们必须首先确定其稳定工作的条件。本练习将带你深入 Lax-Friedrichs 格式的理论核心，使用冯·诺伊曼稳定性分析方法来探索其稳定性边界。通过编写代码来数值化地验证著名的 Courant–Friedrichs–Lewy (CFL) 条件，即 $|\\lambda| \\le 1$，你将亲手搭建起抽象理论与计算实践之间的桥梁 [@problem_id:3151507]。", "problem": "您需要编写一个完整且可运行的程序，该程序将通过经验方法绘制应用于常系数线性平流方程 $u_t + a\\,u_x = 0$ 的 Lax–Friedrichs 格式的稳定性区域，然后将该经验区域与由 Courant–Friedrichs–Lewy (CFL) 条件给出的理论界限进行比较。您需要从第一性原理出发，使用标准的傅里叶稳定性（von Neumann）分析方法：在均匀网格上，线性、平移不变的格式允许平面波模式 $e^{\\mathrm{i}(j\\theta - n\\omega)}$，从而得到单步放大因子 $g(\\theta,\\lambda)$，其中 $\\theta$ 是无量纲波数，$\\lambda$ 是无量纲时间步长参数。对于通过空间上的两点平均、通量的中心差分以及时间上的显式前向欧拉法构建的 Lax–Friedrichs 格式，可以从格式定义中推导出此放大因子，并通过验证对所有 $\\theta$ 是否满足 $\\lvert g(\\theta,\\lambda)\\rvert \\le 1$ 来测试稳定性。\n\n您的程序必须纯粹通过数值方法实现以下任务：\n- 在指定区间内扫描一组无量纲时间步长参数 $\\lambda = a\\,\\Delta t/\\Delta x$，对于每个 $\\lambda$，在区间 $[0,\\pi]$（角度以弧度为单位）上扫描无量纲波数 $\\theta$。对于每对 $(\\lambda,\\theta)$，计算由 Lax–Friedrichs 格式和傅里叶模式分析所隐含的单步放大因子的大小 $\\lvert g(\\theta,\\lambda)\\rvert$。对于每个 $\\lambda$，将经验稳定性指标定义为 $\\max_{\\theta\\in[0,\\pi]} \\lvert g(\\theta,\\lambda)\\rvert \\le 1$（在与 $1$ 比较时允许一个绝对容差，以避免浮点数伪影）。\n- 基于 Lax–Friedrichs 格式的 CFL 条件，构建仅用 $\\lambda$ 表示的理论稳定性指标，并在扫描范围内将其与经验指标进行比较。\n\n使用以下测试套件来探究经验稳定性与理论 CFL 界限之间比较的不同方面。在所有测试中，将 $\\theta$ 解释为弧度。\n- 测试 A（一般扫描）：$\\lambda \\in [-1.5,\\,1.5]$，采样步长为 $0.01$；$\\theta \\in [0,\\pi]$，用 $2049$ 个等距点采样。在判断 $\\max_{\\theta}\\lvert g(\\theta,\\lambda)\\rvert \\le 1$ 时，使用 $10^{-12}$ 的绝对容差。如果对于每个采样的 $\\lambda$，经验稳定性指标都与该 $\\lambda$ 的理论指标匹配，则输出布尔值 $\\,\\mathrm{True}\\,$，否则输出 $\\,\\mathrm{False}\\,$。\n- 测试 B（边界检查）：取 $\\lambda=-1$ 和 $\\lambda=1$ 这两个值，并用 $10001$ 个等距点在 $\\theta \\in [0,\\pi]$ 上进行扫描。对于这两个 $\\lambda$ 值，计算量 $\\max_{\\theta} \\lvert g(\\theta,\\lambda)\\rvert - 1$，并输出一个浮点数，该浮点数等于此量在这两个 $\\lambda$ 边界值上的最大绝对值。\n- 测试 C（CFL 条件外拒绝，粗网格）：$\\lambda \\in [-2,\\,2]$，采样步长为 $0.5$；$\\theta \\in [0,\\pi]$，用 $33$ 个等距点采样。如果对于每个满足 $\\lvert\\lambda\\rvert > 1$ 的采样 $\\lambda$，都有 $\\max_{\\theta}\\lvert g(\\theta,\\lambda)\\rvert > 1$ 且超出量至少为 $10^{-9}$，则输出布尔值 $\\,\\mathrm{True}\\,$，否则输出 $\\,\\mathrm{False}\\,$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含测试 A、B 和 C 的结果，形式为用方括号括起来的逗号分隔列表，顺序如下，例如：\"[rA,rB,rC]\"。\n- 确保只有一行一个列表，没有其他额外输出。\n\n注意事项和约束：\n- 唯一可以从理论中假设的量是线性平流方程 $u_t + a\\,u_x = 0$、定义 $\\lambda = a\\,\\Delta t/\\Delta x$、通过 $\\lvert g(\\theta,\\lambda)\\rvert \\le 1$ 表征的稳定性，以及 Lax–Friedrichs 格式使用空间平均和中心通量，并采用前向欧拉时间步进。所有其他表达式必须在您的解中推导或论证。\n- 角度必须以弧度为单位。\n- 输出中不报告任何物理单位；所有量均为无量纲。", "solution": "该问题要求对应用于一维线性平流方程 $u_t + a u_x = 0$ 的 Lax-Friedrichs 数值格式的稳定性区域进行经验性验证。该分析将从第一性原理出发，使用傅里叶（von Neumann）稳定性分析，并与理论上的 Courant–Friedrichs–Lewy (CFL) 条件进行比较。\n\n首先，我们推导 Lax-Friedrichs 格式的显式形式及其放大因子。该格式构建在空间步长为 $\\Delta x$、时间步长为 $\\Delta t$ 的均匀网格上。设 $u_j^n$ 表示在网格点 $x_j = j\\Delta x$ 和时间层 $t_n = n\\Delta t$ 处解 $u(x_j, t_n)$ 的数值近似。该格式由时间上的前向欧拉步定义，其中 $u_j^n$ 的值被空间平均值替换，空间导数 $u_x$ 由中心差分近似。因此，方程 $u_t = -a u_x$ 被离散化为：\n$$\n\\frac{u_j^{n+1} - \\frac{1}{2}(u_{j+1}^n + u_{j-1}^n)}{\\Delta t} = -a \\left( \\frac{u_{j+1}^n - u_{j-1}^n}{2\\Delta x} \\right)\n$$\n解出 $u_j^{n+1}$ 可得：\n$$\nu_j^{n+1} = \\frac{1}{2}(u_{j+1}^n + u_{j-1}^n) - \\frac{a \\Delta t}{2\\Delta x}(u_{j+1}^n - u_{j-1}^n)\n$$\n通过定义无量纲 Courant 数 $\\lambda = a \\Delta t / \\Delta x$，我们可以简化表达式：\n$$\nu_j^{n+1} = \\frac{1}{2}(u_{j+1}^n + u_{j-1}^n) - \\frac{\\lambda}{2}(u_{j+1}^n - u_{j-1}^n)\n$$\n按空间索引对各项进行分组，得到格式的最终形式：\n$$\nu_j^{n+1} = \\left(\\frac{1 - \\lambda}{2}\\right) u_{j+1}^n + \\left(\\frac{1 + \\lambda}{2}\\right) u_{j-1}^n\n$$\n对于 von Neumann 稳定性分析，我们将单个傅里叶模式 $u_j^n = g^n(\\theta, \\lambda) e^{\\mathrm{i} j \\theta}$ 代入格式中。这里，$\\theta$ 是无量纲波数，$g(\\theta, \\lambda)$ 是单步放大因子。\n$$\ng^{n+1} e^{\\mathrm{i} j \\theta} = \\left(\\frac{1 - \\lambda}{2}\\right) g^n e^{\\mathrm{i} (j+1) \\theta} + \\left(\\frac{1 + \\lambda}{2}\\right) g^n e^{\\mathrm{i} (j-1) \\theta}\n$$\n两边同除以 $g^n e^{\\mathrm{i} j \\theta}$，我们得到放大因子 $g \\equiv g(\\theta, \\lambda)$ 的表达式：\n$$\ng = \\left(\\frac{1 - \\lambda}{2}\\right) e^{\\mathrm{i} \\theta} + \\left(\\frac{1 + \\lambda}{2}\\right) e^{-\\mathrm{i} \\theta}\n$$\n使用欧拉恒等式 $e^{\\pm \\mathrm{i} \\theta} = \\cos\\theta \\pm \\mathrm{i}\\sin\\theta$，我们可以分离 $g$ 的实部和虚部：\n$$\ng = \\frac{1}{2} (e^{\\mathrm{i} \\theta} + e^{-\\mathrm{i} \\theta}) - \\frac{\\lambda}{2} (e^{\\mathrm{i} \\theta} - e^{-\\mathrm{i} \\theta}) = \\cos\\theta - \\lambda (\\mathrm{i}\\sin\\theta)\n$$\n因此，放大因子为 $g(\\theta, \\lambda) = \\cos\\theta - \\mathrm{i}\\lambda\\sin\\theta$。\n\n为使格式稳定，放大因子的模对于任何波数 $\\theta$ 都不能超过 $1$，即 $\\lvert g(\\theta, \\lambda) \\rvert \\le 1$。其模计算如下：\n$$\n\\lvert g(\\theta, \\lambda) \\rvert = \\sqrt{(\\mathrm{Re}(g))^2 + (\\mathrm{Im}(g))^2} = \\sqrt{\\cos^2\\theta + (-\\lambda\\sin\\theta)^2} = \\sqrt{\\cos^2\\theta + \\lambda^2\\sin^2\\theta}\n$$\n因此，稳定性条件为 $\\sqrt{\\cos^2\\theta + \\lambda^2\\sin^2\\theta} \\le 1$。由于两边都是非负的，我们可以对它们进行平方：\n$$\n\\cos^2\\theta + \\lambda^2\\sin^2\\theta \\le 1\n$$\n使用恒等式 $\\cos^2\\theta = 1 - \\sin^2\\theta$，我们得到：\n$$\n1 - \\sin^2\\theta + \\lambda^2\\sin^2\\theta \\le 1 \\implies (\\lambda^2 - 1)\\sin^2\\theta \\le 0\n$$\n由于对于所有实数 $\\theta$，$\\sin^2\\theta \\ge 0$，此不等式对所有 $\\theta$ 成立的充要条件是系数 $(\\lambda^2 - 1)$ 为非正数：\n$$\n\\lambda^2 - 1 \\le 0 \\implies \\lambda^2 \\le 1 \\implies \\lvert\\lambda\\rvert \\le 1\n$$\n这就是 Lax-Friedrichs 格式的理论 CFL 稳定性条件。程序将通过经验方法测试此条件。$\\lvert g(\\theta, \\lambda) \\rvert$ 的最大值在 $\\theta=0$ 和 $\\theta=\\pi$ 处取得（此时 $\\lvert g \\rvert = 1$），或在 $\\theta = \\pi/2$ 处取得（此时 $\\lvert g \\rvert = \\lvert\\lambda\\rvert$）。因此，$\\max_\\theta \\lvert g(\\theta, \\lambda) \\rvert = \\max(1, \\lvert\\lambda\\rvert)$。所以，经验稳定性测试 $\\max_\\theta \\lvert g(\\theta, \\lambda) \\rvert \\le 1$ 在解析上等价于理论条件 $\\lvert\\lambda\\rvert \\le 1$。\n\n程序实现了以下三个测试：\n测试 A：该测试对 $\\lambda$ 从 $-1.5$ 到 $1.5$ 进行步长为 $0.01$ 的细粒度扫描，并对每个 $\\lambda$，在 $[0, \\pi]$ 区间上用 $2049$ 个点采样 $\\theta$。它将经验稳定性指标 `max_g = 1 + 1e-12` 与理论指标 `abs(lambda) = 1` 进行比较。如果对所有 $\\lambda$ 它们都匹配，结果为 `True`，否则为 `False`。\n\n测试 B：该测试检查稳定性边界。对于 $\\lambda = -1$ 和 $\\lambda = 1$，解析结果为 $\\max_\\theta \\lvert g(\\theta, \\lambda) \\rvert = 1$。测试使用对 $\\theta$ 的密集采样（$10001$ 个点）来计算这两个 $\\lambda$ 值下 $\\max_\\theta \\lvert g(\\theta, \\lambda) \\rvert - 1$ 的数值，并报告最大绝对偏差，该偏差量化了数值精度。\n\n测试 C：该测试确认格式在 CFL 限制之外是不稳定的。它以 $0.5$ 的步长扫描 $\\lambda$ 从 $-2$ 到 $2$。对于每个 $\\lvert\\lambda\\rvert  1$ 的 $\\lambda$，它验证计算出的 $\\max_\\theta \\lvert g(\\theta, \\lambda) \\rvert$ 是否比 $1$ 大至少 $10^{-9}$。这里使用了一个包含 $33$ 个点的粗网格来采样 $\\theta$，这已足够，因为它包含了对于不稳定的 $\\lambda$ 放大因子取最大值的关键点 $\\theta = \\pi/2$。如果所有被检查的 $\\lambda$ 值都被确认为不稳定，则结果为 `True`。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Empirically maps and validates the stability region of the Lax-Friedrichs scheme.\n    \"\"\"\n\n    def get_max_g_mag(lam, theta_vals):\n        \"\"\"\n        Computes the maximum magnitude of the amplification factor for a given lambda.\n        The amplification factor g(theta, lambda) = cos(theta) - i*lambda*sin(theta).\n        Its magnitude |g| = sqrt(cos(theta)^2 + (lambda*sin(theta))^2).\n        \"\"\"\n        cos_theta = np.cos(theta_vals)\n        sin_theta = np.sin(theta_vals)\n        g_mag_sq = cos_theta**2 + (lam**2) * (sin_theta**2)\n        max_g_mag = np.sqrt(np.max(g_mag_sq))\n        return max_g_mag\n\n    # Test A: General sweep to compare empirical and theoretical stability\n    def run_test_a():\n        lambda_vals = np.linspace(-1.5, 1.5, int(3.0 / 0.01) + 1)\n        theta_vals = np.linspace(0, np.pi, 2049)\n        tolerance = 1e-12\n        \n        all_match = True\n        for lam in lambda_vals:\n            max_g = get_max_g_mag(lam, theta_vals)\n            \n            # Empirical stability: max|g| = 1 (with tolerance)\n            empirical_stable = (max_g - 1.0) = tolerance\n            \n            # Theoretical stability: |lambda| = 1\n            theoretical_stable = np.abs(lam) = 1.0\n            \n            if empirical_stable != theoretical_stable:\n                all_match = False\n                break\n        return all_match\n\n    # Test B: Check deviation at the stability boundary\n    def run_test_b():\n        lambda_vals = [-1.0, 1.0]\n        theta_vals = np.linspace(0, np.pi, 10001)\n        \n        deviations = []\n        for lam in lambda_vals:\n            max_g = get_max_g_mag(lam, theta_vals)\n            deviation = max_g - 1.0\n            deviations.append(deviation)\n            \n        return np.max(np.abs(deviations))\n\n    # Test C: Verify instability outside the CFL condition on a coarse grid\n    def run_test_c():\n        lambda_vals = np.linspace(-2.0, 2.0, int(4.0 / 0.5) + 1)\n        theta_vals = np.linspace(0, np.pi, 33)\n        tolerance = 1e-9\n        \n        all_unstable_as_expected = True\n        for lam in lambda_vals:\n            # Only check for lambda values that should be unstable\n            if np.abs(lam)  1.0:\n                max_g = get_max_g_mag(lam, theta_vals)\n                # Check if max|g| is strictly greater than 1 by the tolerance\n                is_unstable = (max_g - 1.0)  tolerance\n                if not is_unstable:\n                    all_unstable_as_expected = False\n                    break\n        return all_unstable_as_expected\n\n    rA = run_test_a()\n    rB = run_test_b()\n    rC = run_test_c()\n    \n    results = [rA, rB, rC]\n    \n    # Format and print the final output as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3151507"}, {"introduction": "现实世界中的许多物理问题，如洪水、海啸的模拟，都需要求解非线性守恒律方程组，例如浅水方程。本练习将 Lax-Friedrichs 格式（在此场景下也称为 Rusanov 格式）应用于这一复杂的非线性系统，并专注于一个关键的稳健性挑战：在极端“近真空”条件下保持水深等物理量的正值性 [@problem_id:3151538]。这个实践不仅展示了如何将基本格式扩展到更复杂的方程组，还强调了使用局部波速估计来确保数值解物理真实性的重要性。", "problem": "考虑无量纲形式的一维浅水方程，\n$$\n\\partial_t h + \\partial_x (h u) = 0,\\qquad\n\\partial_t (h u) + \\partial_x\\left(h u^2 + \\tfrac{1}{2} g h^2\\right) = 0,\n$$\n其中 $h(x,t)$ 是水深，$u(x,t)$ 是深度平均的水平速度。常数 $g$ 表示无量纲的重力加速度。守恒变量为 $U = \\begin{bmatrix} h \\\\ m \\end{bmatrix}$，其中 $m = h u$，物理通量为 $F(U) = \\begin{bmatrix} h u \\\\ h u^2 + \\tfrac{1}{2} g h^2 \\end{bmatrix}$。\n\n从有限控制体上的积分守恒形式和浅水系统的特征速度出发，构建一个一阶守恒有限体积法，该方法使用 Lax–Friedrichs（也称为 Rusanov）数值通量在时间上推进单元平均值。在每个单元交界面处，使用局部耗散参数\n$$\n\\alpha = \\max\\left\\{\\,|u_L| + c_L,\\; |u_R| + c_R\\,\\right\\},\n$$\n其中 $c = \\sqrt{g h}$ 是重力波速，下标 $L$ 和 $R$ 分别表示交界面左侧和右侧的状态。使用显式向前欧拉时间积分和流出（零梯度）边界条件。时间步长必须满足基于每个时间步网格上最大波速的 Courant–Friedrichs–Lewy (CFL) 条件，\n$$\n\\Delta t = \\text{CFL}\\,\\frac{\\Delta x}{\\max_i\\left(|u_i| + \\sqrt{g h_i}\\right)}.\n$$\n\n您将测试该方法在近真空黎曼问题中保持水深非负性（正性）的能力。黎曼问题由分段常数初始数据定义：\n$$\n(h(x,0), u(x,0)) = \n\\begin{cases}\n(h_L, u_L),  x  x_0, \\\\\n(h_R, u_R),  x \\ge x_0,\n\\end{cases}\n$$\n其中 $x_0$ 是定义域的中点。在 $[0,1]$ 上使用包含 $N$ 个单元的均匀空间网格，并通过 $m = h u$ 初始化守恒变量。\n\n数值稳健性要求：\n- 如果在任何单元的任何时间步长，$h$ 在数值上变为负数，则声明该测试未保持正性。为本练习之目的，任何值 $h  -10^{-12}$ 均被视为负数。\n- 为避免在计算通量或速度时出现除以零的情况，当 $h \\le 10^{-14}$ 时，将 $u = m/h$ 视为 $0$；并使用 $\\max(h,0)$ 来计算 $\\sqrt{g h}$。\n\n所有量都是无量纲的；不使用也不报告任何物理单位。\n\n实现该算法并运行以下黎曼问题测试套件。对于每个测试，积分到指定的最终时间，并报告水深正性是否被保持（布尔结果）。\n\n测试套件（每个元组列出 $(N, T, g, \\text{CFL}, h_L, u_L, h_R, u_R)$）：\n1. $(400,\\; 0.05,\\; 1.0,\\; 0.45,\\; 10^{-6},\\; 0,\\; 1,\\; 0)$: 左侧近真空，右侧静水。\n2. $(400,\\; 0.05,\\; 1.0,\\; 0.90,\\; 10^{-6},\\; -2,\\; 10^{-6},\\; 2)$: 具有发散速度的对称近真空（强稀疏波）。\n3. $(400,\\; 0.05,\\; 1.0,\\; 0.45,\\; 10^{-6},\\; -2,\\; 10^{-6},\\; 2)$: 与测试2相同，但 Courant–Friedrichs–Lewy (CFL) 数更小。\n4. $(200,\\; 0.02,\\; 1.0,\\; 0.70,\\; 10^{-8},\\; -5,\\; 0.5,\\; 5)$: 严重的左侧近真空，流入中等深度的右侧区域，并伴有强烈的速度发散。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”），其中每个结果都是一个布尔值（“True”或“False”），表示对于相应的测试，在所有单元和所有时间步长直到最终时间 $T$，$h \\ge 0$ 是否都得以保持。", "solution": "该问题要求实现一个一阶守恒有限体积法来求解一维浅水方程，并在几个黎曼问题上测试其保正性。\n\n无量纲守恒形式的控制方程为：\n$$\n\\partial_t \\mathbf{U} + \\partial_x \\mathbf{F}(\\mathbf{U}) = \\mathbf{0}\n$$\n其中 $\\mathbf{U}$ 是守恒量矢量，$\\mathbf{F}(\\mathbf{U})$ 是相应物理通量的矢量。对于浅水系统，它们定义如下：\n$$\n\\mathbf{U} = \\begin{bmatrix} h \\\\ m \\end{bmatrix}, \\qquad \\mathbf{F}(\\mathbf{U}) = \\begin{bmatrix} m \\\\ \\frac{m^2}{h} + \\frac{1}{2} g h^2 \\end{bmatrix}\n$$\n此处，$h$ 是水深，$m = hu$ 是动量，$u$ 是深度平均速度，$g$ 是无量纲重力加速度。\n\n通过将空间域 $[0, 1]$ 离散为 $N$ 个均匀单元 $I_i = [x_{i-1/2}, x_{i+1/2}]$ 来构造有限体积法，每个单元的宽度为 $\\Delta x = 1/N$。我们将 $t$ 时刻守恒状态矢量的单元平均值定义为：\n$$\n\\mathbf{U}_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} \\mathbf{U}(x, t) \\, dx\n$$\n对单元 $I_i$ 上的控制偏微分方程进行积分，并应用散度定理，得到每个单元平均值的半离散常微分方程：\n$$\n\\frac{d\\mathbf{U}_i}{dt} = -\\frac{1}{\\Delta x} \\left( \\mathbf{F}^*_{i+1/2} - \\mathbf{F}^*_{i-1/2} \\right)\n$$\n其中 $\\mathbf{F}^*_{i+1/2}$ 是单元 $i$ 和单元 $i+1$ 之间交界面 $x_{i+1/2}$ 处的数值通量。它近似于物理通量 $\\mathbf{F}(\\mathbf{U}(x_{i+1/2}, t))$。\n\n对于一阶格式，数值通量是相邻单元中常数状态的函数，即 $\\mathbf{U}_L = \\mathbf{U}_i$ 和 $\\mathbf{U}_R = \\mathbf{U}_{i+1}$。问题指定了 Lax–Friedrichs (也称为 Rusanov) 数值通量，其形式如下：\n$$\n\\mathbf{F}^*(\\mathbf{U}_L, \\mathbf{U}_R) = \\frac{1}{2} \\left[ \\mathbf{F}(\\mathbf{U}_L) + \\mathbf{F}(\\mathbf{U}_R) - \\alpha (\\mathbf{U}_R - \\mathbf{U}_L) \\right]\n$$\n项 $\\alpha$ 是一个局部耗散参数，它必须是最大局部信号速度的估计值。其定义为：\n$$\n\\alpha_{i+1/2} = \\max\\left\\{ |u_L| + c_L, |u_R| + c_R \\right\\}\n$$\n其中 $c = \\sqrt{gh}$ 是重力波速。在交界面 $x_{i+1/2}$ 处，左右状态取自相邻单元，因此 $u_L=u_i$，$c_L=c_i$，$u_R=u_{i+1}$，$c_R=c_{i+1}$。\n\n时间积分使用显式向前欧拉法进行。将其应用于半离散形式，得到全离散更新公式：\n$$\n\\mathbf{U}_i^{n+1} = \\mathbf{U}_i^n - \\frac{\\Delta t}{\\Delta x} \\left( \\mathbf{F}^*_{i+1/2} - \\mathbf{F}^*_{i-1/2} \\right)\n$$\n其中上标 $n$ 表示时间层 $t^n = n\\Delta t$。\n\n时间步长 $\\Delta t$ 的选择必须满足 Courant–Friedrichs–Lewy (CFL) 稳定性条件。对于每个时间步，$\\Delta t$ 根据整个网格上的最大波速计算：\n$$\n\\Delta t = \\text{CFL} \\frac{\\Delta x}{\\max_i \\left( |u_i^n| + \\sqrt{g h_i^n} \\right)}\n$$\n其中 CFL 是一个小于或等于 $1$ 的常数。\n\n边界条件是流出（零梯度）。这是通过在计算域的边界处使用虚拟单元来实现的。对于包含单元 $i=1, \\dots, N$ 的域，我们引入虚拟单元 $i=0$ 和 $i=N+1$。这些单元中的状态被设置为与其相邻单元匹配：$\\mathbf{U}_0 = \\mathbf{U}_1$ 和 $\\mathbf{U}_{N+1} = \\mathbf{U}_N$。\n\n为了处理 $h$ 趋近于零的近真空状态，需要采取特定的数值预防措施以避免除以零和其他浮点问题：\n- 如果 $h \\le 10^{-14}$，则速度 $u=m/h$ 计算为 $0$。\n- 重力波速 $c = \\sqrt{gh}$ 使用 $\\sqrt{g \\cdot \\max(h, 0)}$ 进行计算，以防止定义域错误。\n- 如果任何单元的水深变为 $h  -10^{-12}$，则认为违反了正性。\n\n对于每个测试用例，总体算法流程如下：\n1. 根据给定的分段常数黎曼初始数据，为 $i=1, \\dots, N$ 初始化单元平均值 $\\mathbf{U}_i^0 = [h_i^0, m_i^0]^T$。\n2. 设置当前时间 $t=0$。\n3. 开始时间步进循环，持续直到 $t \\ge T$：\n    a. 通过设置虚拟单元的状态来应用边界条件。\n    b. 使用指定的稳健性规则，为所有单元（包括虚拟单元）计算原始变量 $(h_i, u_i)$ 和波速 $c_i$。\n    c. 使用 CFL 条件计算时间步长 $\\Delta t$，确保不越过最终时间 $T$。\n    d. 对于从 $i=0, \\dots, N$ 的每个交界面 $x_{i+1/2}$：\n        i. 识别左侧 ($\\mathbf{U}_i$) 和右侧 ($\\mathbf{U}_{i+1}$) 的状态。\n        ii. 计算耗散参数 $\\alpha_{i+1/2}$。\n        iii. 计算数值通量 $\\mathbf{F}^*_{i+1/2}$。\n    e. 使用向前欧拉公式更新每个内部单元 $i=1, \\dots, N$ 的状态：$\\mathbf{U}_i^{n+1} = \\mathbf{U}_i^n - (\\Delta t/\\Delta x) (\\mathbf{F}^*_{i+1/2} - \\mathbf{F}^*_{i-1/2})$。\n    f. 检查是否有任何单元 $i$ 的新水深 $h_i^{n+1}$ 小于 $-10^{-12}$。如果是，则声明此测试用例未保持正性，并终止模拟。\n    g. 推进时间：$t = t + \\Delta t$。\n4. 如果循环完成而没有违反正性，则声明此测试用例保持了正性。\n5. 收集并报告所有测试用例的布尔结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, T, g, CFL, h_L, u_L, h_R, u_R):\n    \"\"\"\n    Runs a single simulation of the shallow water equations.\n\n    Args:\n        N (int): Number of spatial grid cells.\n        T (float): Final simulation time.\n        g (float): Gravitational acceleration.\n        CFL (float): Courant–Friedrichs–Lewy number.\n        h_L (float): Initial depth on the left side.\n        u_L (float): Initial velocity on the left side.\n        h_R (float): Initial depth on the right side.\n        u_R (float): Initial velocity on the right side.\n\n    Returns:\n        bool: True if depth positivity is preserved, False otherwise.\n    \"\"\"\n    # -- 1. Setup Grid and Initial Conditions --\n    dx = 1.0 / N\n    x_centers = np.linspace(dx / 2.0, 1.0 - dx / 2.0, N)\n    \n    # State vector U = [h, m=hu]\n    U = np.zeros((2, N))\n    \n    # Initialize piecewise-constant data\n    h_init = np.where(x_centers  0.5, h_L, h_R)\n    u_init = np.where(x_centers  0.5, u_L, u_R)\n    m_init = h_init * u_init\n    \n    U[0, :] = h_init\n    U[1, :] = m_init\n\n    t = 0.0\n    \n    # Numerical robustness parameters\n    h_min_robustness = 1e-14\n    h_negativity_threshold = -1e-12\n\n    # -- 2. Main Time Loop --\n    while t  T:\n        # -- a. Apply Boundary Conditions (Ghost Cells) --\n        # Padded state vector for N cells + 2 ghost cells\n        U_padded = np.zeros((2, N + 2))\n        U_padded[:, 1:-1] = U\n\n        # Zero-gradient (outflow) boundaries\n        U_padded[:, 0] = U_padded[:, 1]\n        U_padded[:, -1] = U_padded[:, -2]\n\n        h_padded = U_padded[0, :]\n        m_padded = U_padded[1, :]\n\n        # -- b. Compute Primitives and Wave Speeds --\n        # Handle u = m/h for h -> 0\n        u_padded = np.zeros_like(h_padded)\n        positive_h_mask = h_padded  h_min_robustness\n        u_padded[positive_h_mask] = m_padded[positive_h_mask] / h_padded[positive_h_mask]\n        \n        # Handle c = sqrt(g*h) for h  0\n        c_padded = np.sqrt(g * np.maximum(0.0, h_padded))\n        \n        # -- c. Calculate Time Step (CFL Condition) --\n        max_abs_lambda = np.max(np.abs(u_padded[1:-1]) + c_padded[1:-1])\n        if max_abs_lambda == 0:\n            dt = T - t # Simulation is static, jump to end\n        else:\n            dt = CFL * dx / max_abs_lambda\n        \n        # Ensure final time T is not overshot\n        if t + dt  T:\n            dt = T - t\n        \n        if dt = 0: # Already at or past t=T\n            break\n\n        # -- d. Compute Numerical Flux --\n        # Physical flux F(U) = [m, m^2/h + 0.5*g*h^2]\n        F_padded = np.zeros_like(U_padded)\n        F_padded[0, :] = m_padded\n        F_padded[1, :] = m_padded * u_padded + 0.5 * g * h_padded**2\n        \n        # Left and Right states at interfaces (N+1 interfaces)\n        U_L = U_padded[:, :-1]\n        U_R = U_padded[:, 1:]\n        \n        F_L = F_padded[:, :-1]\n        F_R = F_padded[:, 1:]\n        \n        u_L_int = u_padded[:-1]\n        u_R_int = u_padded[1:]\n        c_L_int = c_padded[:-1]\n        c_R_int = c_padded[1:]\n        \n        # Dissipation coefficient alpha\n        alpha = np.maximum(np.abs(u_L_int) + c_L_int, np.abs(u_R_int) + c_R_int)\n        \n        # Lax-Friedrichs (Rusanov) flux\n        F_star = 0.5 * (F_L + F_R - alpha * (U_R - U_L))\n        \n        # -- e. Update Solution --\n        flux_diff = F_star[:, 1:] - F_star[:, :-1]\n        U -= (dt / dx) * flux_diff\n\n        # -- f. Check for Positivity Violation --\n        if np.any(U[0, :]  h_negativity_threshold):\n            return False  # Positivity not preserved\n            \n        # -- g. Advance Time --\n        t += dt\n\n    return True  # Positivity preserved\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (400, 0.05, 1.0, 0.45, 1e-6, 0.0, 1.0, 0.0),\n        (400, 0.05, 1.0, 0.90, 1e-6, -2.0, 1e-6, 2.0),\n        (400, 0.05, 1.0, 0.45, 1e-6, -2.0, 1e-6, 2.0),\n        (200, 0.02, 1.0, 0.70, 1e-8, -5.0, 0.5, 5.0)\n    ]\n\n    results = []\n    for case in test_cases:\n        positivity_preserved = run_simulation(*case)\n        results.append(positivity_preserved)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3151538"}]}