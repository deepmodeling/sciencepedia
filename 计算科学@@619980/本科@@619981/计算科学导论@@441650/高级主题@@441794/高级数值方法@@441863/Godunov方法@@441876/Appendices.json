{"hands_on_practices": [{"introduction": "这第一个练习是一项基础的纸笔计算，旨在巩固你对戈杜诺夫方法核心思想的理解：即如何利用局部黎曼问题的解来计算数值通量。通过对非线性的伯格斯方程 (Burgers' equation) 进行单时间步的推演，你将直接在计算情境中应用激波和兰金-雨贡尼奥 (Rankine-Hugoniot) 条件等概念。", "problem": "考虑一维无粘性伯格斯方程（Burgers' equation），它是带有激波的方程的一个原型：\n$$ \\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x} \\left( \\frac{1}{2} u^2 \\right) = 0 $$\n该方程是守恒律方程，形式为 $\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0$，其通量为 $f(u) = \\frac{1}{2} u^2$。\n\n我们希望使用戈杜诺夫方法数值求解此方程，该方法是一种有限体积格式。空间域被划分为等宽的单元格 $\\Delta x$，中心位于 $x_i = i \\Delta x$。值 $U_i^n$ 表示解 $u(x, t)$ 在时间 $t_n = n \\Delta t$ 时在单元格 $i$ 上的平均值。\n\n在一个时间步长内，单元格平均值的更新公式由下式给出：\n$$ U_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right) $$\n其中 $F_{i+1/2}$ 是单元格 $i$ 和单元格 $i+1$ 之间界面上的数值通量。\n\n在戈杜诺夫方法中，通量 $F_{i+1/2}$ 是通过在界面 $x_{i+1/2}$ 处求解黎曼问题（Riemann problem）来确定的，其初始数据为：当 $x < x_{i+1/2}$ 时，$u(x,t_n) = U_i^n$；当 $x > x_{i+1/2}$ 时，$u(x,t_n) = U_{i+1}^n$。我们记左、右状态为 $u_L=U_i^n$ 和 $u_R=U_{i+1}^n$。戈杜诺夫通量为 $F_{i+1/2} = f(u_{RP}(0))$，其中 $u_{RP}(0)$ 是黎曼问题解沿着直线 $x-x_{i+1/2}=0$ 的值。对于伯格斯方程，寻找 $u_{RP}(0)$ 的规则如下：\n1.  如果 $u_L > u_R$，解是一个激波。激波速度由Rankine-Hugoniot条件给出：$s = \\frac{f(u_R)-f(u_L)}{u_R-u_L} = \\frac{1}{2}(u_L+u_R)$。如果激波向右移动（$s > 0$），则界面处的状态为 $u_L$。如果激波向左移动（$s < 0$），则状态为 $u_R$。如果 $s=0$，则通量为 $f(u_L)=f(u_R)$。\n2.  如果 $u_L \\le u_R$，解是一个稀疏波。如果 $u_L \\le 0 \\le u_R$，则界面处的值为 $u_{RP}(0) = 0$。如果 $u_L$ 和 $u_R$ 符号相同，那么当 $u_L > 0$ 时，$u_{RP}(0) = u_L$；当 $u_R < 0$ 时，$u_{RP}(0) = u_R$。\n\n考虑在时间 $t=0$ 时，单元格平均值的以下分段常数初始状态：\n$$ U_i^0 = \\begin{cases} 3V & \\text{for } i \\le -1 \\\\ V & \\text{for } i = 0 \\\\ -2V & \\text{for } i \\ge 1 \\end{cases} $$\n其中 $V$ 是一个正常数。令 $\\lambda = \\frac{\\Delta t}{\\Delta x}$ 为库朗数（Courant number），假设它足够小以确保数值稳定性。\n\n推导一个时间步长后，中心单元格（$i=0$）中更新后的速度平均值 $U_0^1$ 的表达式。用 $V$ 和 $\\lambda$ 表示你的答案。", "solution": "我们应用Godunov更新公式\n$$\nU_0^1 \\;=\\; U_0^0 \\;-\\;\\lambda\\bigl(F_{1/2}-F_{-1/2}\\bigr),\n\\quad \\lambda=\\frac{\\Delta t}{\\Delta x},\n\\quad U_0^0=V.\n$$\n计算界面通量：\n\n1. 界面 $x_{-1/2}$，在 $u_L=U_{-1}=3V$ 和 $u_R=U_0=V$ 之间。由于 $u_L>u_R$，我们得到一个激波，其速度为\n$$\ns=\\frac{f(u_R)-f(u_L)}{u_R-u_L}\n=\\frac{\\tfrac12V^2-\\tfrac12(3V)^2}{V-3V}\n=\\frac{-4V^2}{-2V}=2V>0.\n$$\n因此，界面处的状态为 $u_L=3V$，且\n$$\nF_{-1/2}=f(3V)=\\tfrac12(3V)^2=\\tfrac92\\,V^2.\n$$\n\n2. 界面 $x_{1/2}$，在 $u_L=U_0=V$ 和 $u_R=U_1=-2V$ 之间。同样 $u_L>u_R$，因此是一个激波，其速度为\n$$\ns=\\frac{f(u_R)-f(u_L)}{u_R-u_L}\n=\\frac{\\tfrac12( -2V)^2-\\tfrac12V^2}{-2V-V}\n=\\frac{\\tfrac32V^2}{-3V}=-\\tfrac12V<0.\n$$\n因此，状态为 $u_R=-2V$，且\n$$\nF_{1/2}=f(-2V)=\\tfrac12( -2V)^2=2\\,V^2.\n$$\n\n代入更新公式：\n$$\nU_0^1\n=V-\\lambda\\bigl(2V^2-\\tfrac92V^2\\bigr)\n=V-\\lambda\\bigl(-\\tfrac52V^2\\bigr)\n=V+\\tfrac52\\,\\lambda\\,V^2.\n$$", "answer": "$$\\boxed{V+\\tfrac{5}{2}\\,\\lambda\\,V^2}$$", "id": "1073353"}, {"introduction": "从理论走向实践，这个练习将要求你为线性平流方程编写戈杜诺夫方法的代码。你将通过模拟一个尖锐间断波的运动，将其性能与另一种经典格式——拉克斯-弗里德里希斯 (Lax-Friedrichs) 格式——进行比较。这项实践引入了数值耗散这一关键概念，并提供了一种量化方法，来衡量不同格式如何人为地“抹平”解中的尖锐特征。", "problem": "考虑单位区间上的具有周期性边界条件的线性标量守恒律，\n$$\nu_t + a\\,u_x = 0,\\quad x\\in[0,1),\\ t\\ge 0,\n$$\n其中平流速度为常数 $$a=1$$，初始数据由方波给出\n$$\nu(x,0)=u_0(x)=\\begin{cases}\n1, & x\\in[0.2,0.4),\\\\\n0, & \\text{otherwise},\n\\end{cases}\n$$\n在 $$[0,1)$$ 上作周期性解释。精确解是平流的初始数据\n$$\nu(x,t)=u_0\\!\\big((x-a\\,t)\\bmod 1\\big).\n$$\n你将需要在一个具有 $$N$$ 个单元的均匀网格上实现两种有限体积法，单元大小为 $$\\Delta x=1/N$$，单元中心位于 $$x_i=(i+1/2)\\Delta x$$（其中 $$i=0,\\dots,N-1$$），并将数值解推进到最终时间 $$T=0.2$$。这两种方法是：\n\n- 用于标量线性平流的 Godunov 方法，当 $$a>0$$ 时，该方法简化为迎风格式。在带有数值通量的有限体积形式中，它在每个界面上使用精确的 Riemann 求解器；对于 $$a>0$$，这会产生依赖于左侧单元状态的迎风更新。\n- Lax–Friedrichs 方法，可以写成中心差分和人工耗散组合的守恒形式。\n\n使用由 Courant–Friedrichs–Lewy (CFL) 数确定的时间步长，\n$$\n\\Delta t = \\text{CFL}\\,\\frac{\\Delta x}{|a|},\\quad \\text{with}\\ \\text{CFL}=0.9,\n$$\n并通过在最后一步根据需要减小 $$\\Delta t$$ 来确保最后一个时间步长恰好达到 $$T$$。使用周期性边界条件。\n\n通过计算时间 $$T$$ 时的离散 $$L^1$$-误差来量化数值耗散，\n$$\nE_{L^1} = \\sum_{i=0}^{N-1} \\left|U_i^N - u(x_i,T)\\right|\\,\\Delta x,\n$$\n其中 $$U_i^N$$ 表示最终时间的数值单元平均值，$$u(x_i,T)$$ 是在单元中心计算的精确解。\n\n实现这两种方法，并针对以下网格分辨率测试套件评估 $$E_{L^1}$$：\n- Lax–Friedrichs 方法：$$N=100$$、$$N=200$$ 和 $$N=400$$。\n- Godunov 方法（当 $$a>0$$ 时为迎风格式）：$$N=100$$、$$N=200$$ 和 $$N=400$$。\n\n你的程序必须：\n- 通过在单元中心 $$x_i$$ 处对 $$u_0$$ 进行采样来初始化 $$U_i^0$$。\n- 使用指定的方法和时间步进，随时间演化到 $$T=0.2$$。\n- 计算并报告每个测试用例的离散 $$L^1$$-误差 $$E_{L^1}$$。\n\n最终输出格式：\n- 生成一行输出，其中包含用方括号括起来的逗号分隔的误差列表，顺序如下\n$$\n[\\ E^{\\text{LF}}_{100},\\ E^{\\text{LF}}_{200},\\ E^{\\text{LF}}_{400},\\ E^{\\text{God}}_{100},\\ E^{\\text{God}}_{200},\\ E^{\\text{God}}_{400}\\ ],\n$$\n其中 $$E^{\\text{LF}}_N$$ 是使用 $$N$$ 个单元的 Lax–Friedrichs 方法的 $$L^1$$-误差，$$E^{\\text{God}}_N$$ 是使用 $$N$$ 个单元的 Godunov 方法的 $$L^1$$-误差。列表中的每个数字必须打印为精确到 $$6$$ 位小数的十进制数。不应打印任何附加文本。\n\n注意：\n- 不涉及角度；没有角度单位适用。\n- 各量均为无量纲；不需要物理单位。\n- 实现的方法必须遵循具有周期性边界条件和指定时间步进的有限体积更新。程序必须是自包含的，并且不需要用户输入或外部文件。", "solution": "该问题要求数值求解线性标量平流方程，\n$$\nu_t + a\\,u_x = 0\n$$\n在具有周期性边界条件的域 $x \\in [0, 1)$ 上。平流速度为常数 $a=1$。初始条件是一个方波，定义为\n$$\nu(x,0) = u_0(x) = \\begin{cases} 1, & x \\in [0.2, 0.4) \\\\ 0, & \\text{otherwise}. \\end{cases}\n$$\n该问题的精确解是初始剖面以速度 $a$向右平流，由下式给出\n$$\nu(x,t) = u_0\\big((x - a\\,t) \\pmod 1\\big).\n$$\n我们将在一个包含 $N$ 个单元的均匀网格上使用有限体积法，其中单元 $i$ 的中心位于 $x_i = (i+1/2)\\Delta x$，单元宽度为 $\\Delta x = 1/N$，其中 $i=0, \\dots, N-1$。设 $U_i(t)$ 为时间 $t$ 时单元 $i$ 中解的单元平均值。守恒律的半离散有限体积公式为\n$$\n\\frac{dU_i}{dt} + \\frac{1}{\\Delta x} \\left( \\hat{F}_{i+1/2} - \\hat{F}_{i-1/2} \\right) = 0,\n$$\n其中 $\\hat{F}_{i+1/2}$ 是单元 $i$ 和单元 $i+1$ 之间界面上的数值通量。向前欧拉时间离散化给出了全离散更新公式：\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x} \\left( \\hat{F}_{i+1/2}^n - \\hat{F}_{i-1/2}^n \\right),\n$$\n其中 $U_i^n$ 是时间 $t^n = n\\Delta t$ 时单元平均值的近似值，$\\hat{F}_{i+1/2}^n$ 是根据时间 $t^n$ 的解计算出的通量。该方程的物理通量为 $F(u) = a\\,u$。\n\n问题指定了两种方法，它们在数值通量的定义上有所不同。\n\n**Godunov 方法**\nGodunov 方法通过求解每个单元界面上的精确 Riemann 问题来定义数值通量。界面 $x_{i+1/2}$ 处的 Riemann 问题的初始条件为\n$$\nu(x,0) = \\begin{cases} U_i^n, & x < x_{i+1/2} \\\\ U_{i+1}^n, & x > x_{i+1/2}. \\end{cases}\n$$\n对于线性平流方程 $u_t + a u_x = 0$，特征线是斜率为 $1/a$ 的直线。Riemann 问题的解沿着这些特征线是常数。界面 $x=x_{i+1/2}$ 处的值由穿过它的特征线确定。由于问题指定 $a=1>0$，信息从左向右传播。因此，界面处的解是来自左侧状态的值，即 $U_i^n$。\n于是，数值通量就是在此界面值处计算的物理通量：\n$$\n\\hat{F}_{i+1/2}^n = F(U_i^n) = a\\,U_i^n.\n$$\n将此代入有限体积更新公式可得：\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x} \\left( a\\,U_i^n - a\\,U_{i-1}^n \\right).\n$$\n这是一阶迎风格式，适用于 $a>0$ 的情况。\n\n**Lax-Friedrichs 方法**\nLax-Friedrichs 方法是另一种一阶格式。其数值通量可以从交错网格公式推导出来，也可以直接定义。其数值通量的一种常见形式是\n$$\n\\hat{F}_{i+1/2}^n = \\frac{1}{2}\\left( F(U_i^n) + F(U_{i+1}^n) \\right) - \\frac{1}{2}\\frac{\\Delta x}{\\Delta t}\\left( U_{i+1}^n - U_i^n \\right).\n$$\n第一项是来自左右状态通量的简单平均，对应于中心差分格式。第二项是数值扩散项，与 $\\Delta x / \\Delta t$ 成正比，是保证稳定性所必需的。代入 $F(u)=a\\,u$ 可得\n$$\n\\hat{F}_{i+1/2}^n = \\frac{a}{2}\\left( U_i^n + U_{i+1}^n \\right) - \\frac{1}{2}\\frac{\\Delta x}{\\Delta t}\\left( U_{i+1}^n - U_i^n \\right).\n$$\n将此通量代入守恒律更新公式可得到一个直接的更新公式。此形式简化为：\n$$\nU_i^{n+1} = \\frac{1}{2}\\left( U_{i+1}^n + U_{i-1}^n \\right) - \\frac{a\\,\\Delta t}{2\\,\\Delta x}\\left( U_{i+1}^n - U_{i-1}^n \\right).\n$$\n这种形式在计算上很方便。Godunov 方法和 Lax-Friedrichs 方法在空间和时间上都是一阶精度的。众所周知，它们是耗散的，这会倾向于抹平尖锐的特征，比如方波初始条件中的不连续性。Lax-Friedrichs 方法通常比迎风 (Godunov) 方法更具耗散性。\n\n**实现细节**\n以下 Python 代码实现了求解器并计算所需的误差。\n```python\nimport numpy as np\n\ndef u0(x):\n    \"\"\"\n    Computes the initial square wave profile.\n    u(x,0) = 1 for x in [0.2, 0.4), 0 otherwise.\n    \"\"\"\n    return np.where((x >= 0.2)  (x  0.4), 1.0, 0.0)\n\ndef u_exact(x, t, a):\n    \"\"\"\n    Computes the exact solution u(x,t) for the linear advection equation.\n    The solution is the initial profile advected by a*t.\n    \"\"\"\n    # Use a robust modulo operation for floating point numbers on [0, 1)\n    x_shifted = (x - a * t) - np.floor(x - a * t)\n    return u0(x_shifted)\n\ndef solve_godunov(N, T, CFL, a):\n    \"\"\"\n    Solves the linear advection equation using Godunov's method (upwind for a>0).\n    \"\"\"\n    dx = 1.0 / N\n    x = (np.arange(N) + 0.5) * dx\n    U = u0(x)\n\n    dt = CFL * dx / np.abs(a)\n    t = 0.0\n\n    while t  T:\n        dt_step = min(dt, T - t)\n        \n        # Periodic boundary conditions: U_{i-1} is fetched using np.roll\n        U_prev = np.roll(U, 1)\n        \n        # Godunov's method update (first-order upwind for a > 0)\n        # U_i^{n+1} = U_i^n - (a*dt/dx) * (U_i^n - U_{i-1}^n)\n        U = U - (a * dt_step / dx) * (U - U_prev)\n        \n        t += dt_step\n    \n    U_ex = u_exact(x, T, a)\n    error = np.sum(np.abs(U - U_ex)) * dx\n    return error\n\ndef solve_lax_friedrichs(N, T, CFL, a):\n    \"\"\"\n    Solves the linear advection equation using the Lax-Friedrichs method.\n    \"\"\"\n    dx = 1.0 / N\n    x = (np.arange(N) + 0.5) * dx\n    U = u0(x)\n\n    dt = CFL * dx / np.abs(a)\n    t = 0.0\n\n    while t  T:\n        dt_step = min(dt, T - t)\n        \n        # Periodic boundary conditions for U_{i-1} and U_{i+1}\n        U_prev = np.roll(U, 1)\n        U_next = np.roll(U, -1)\n        \n        # Lax-Friedrichs update\n        # U_i^{n+1} = 0.5*(U_{i+1}^n + U_{i-1}^n) - (a*dt/(2*dx))*(U_{i+1}^n - U_{i-1}^n)\n        U = 0.5 * (U_next + U_prev) - (a * dt_step / (2.0 * dx)) * (U_next - U_prev)\n        \n        t += dt_step\n\n    U_ex = u_exact(x, T, a)\n    error = np.sum(np.abs(U - U_ex)) * dx\n    return error\n```", "answer": "[0.103994,0.075931,0.054366,0.071981,0.050379,0.035416]", "id": "3138441"}, {"introduction": "一阶戈杜诺夫格式虽然稳健，但在许多应用中其数值耗散过大。这项进阶实践将指导你实现一个称为MUSCL (Monotonic Upstream-centered Schemes for Conservation Laws) 格式的二阶扩展。你将探索如何使用斜率限制器在获得更高精度的同时，防止在间断附近产生虚假的振荡，并通过求解伯格斯方程来比较不同限制器（如Minmod和Superbee）对解的影响。", "problem": "考虑一维无粘伯格斯（Burgers）方程的标量守恒律，$u_t + \\left(f(u)\\right)_x = 0$，其中 $f(u)=\\frac{u^2}{2}$。有限体积格式通过平衡跨网格界面的数值通量来演化网格平均值。在一个二阶 Godunov–MUSCL（守恒律单调上游迎风格式）框架中，通过对相邻网格的平均值应用斜率限制器来重构界面状态，以强制实现总变差不增（TVD）性质。需要考虑的三种斜率限制器是 Minmod、Superbee 和 Monotonized Central (MC)，每种限制器都具有不同的压缩性和数值扩散特性。\n\n您的任务是实现一个完整的程序，该程序需满足以下要求：\n- 将区域 $[0,1]$ 离散化为 $200$ 个均匀网格，$\\Delta x = \\frac{1}{200}$，并使用周期性边界条件。\n- 使用基于伯格斯方程精确黎曼求解器的 Godunov 数值通量，通过守恒型有限体积更新将解从 $t=0$ 演化到最终时间 $T$。时间步长 $\\Delta t$ 必须满足一个合适的 Courant–Friedrichs–Lewy (CFL) 条件，库朗数设为 $\\nu=0.9$，即在每一步选择 $\\Delta t = \\min\\!\\left(\\nu \\frac{\\Delta x}{\\max_i |u_i|}, T-t\\right)$，其中 $u_i$ 表示网格平均值。\n- 采用带有受限线性斜率的 MUSCL 重构来定义左右界面状态；执行三次运行，每次运行分别使用一种斜率限制器：Minmod、Superbee 和 Monotonized Central (MC)，并保持所有其他参数相同。\n- 使用位于 $x_0 = 0.5$ 的单个间断来初始化解，其形式为黎曼型阶跃：当 $x  x_0$ 时 $u(x,0) = u_L$，当 $x \\ge x_0$ 时 $u(x,0) = u_R$。\n\n在最终时间 $T$ 定义并计算定量的过冲和下冲，具体如下：\n- 过冲幅度：$\\max\\!\\left(0, \\max_i u_i - \\max\\!\\left(u_L, u_R\\right)\\right)$。\n- 下冲幅度：$\\max\\!\\left(0, \\min\\!\\left(u_L, u_R\\right) - \\min_i u_i\\right)$。\n\n实现程序以评估以下测试套件的这些指标，该套件涵盖了激波、稀疏波以及跨间断的符号变化：\n- 情况 A：$(u_L, u_R) = (1, 0)$, $T = 0.2$。\n- 情况 B：$(u_L, u_R) = (0, 1)$, $T = 0.2$。\n- 情况 C：$(u_L, u_R) = (-1, 0.5)$, $T = 0.2$。\n\n对于每种情况，使用三种限制器（Minmod、Superbee、MC）运行模拟，并计算过冲和下冲幅度。将所有报告值表示为四舍五入到六位小数的浮点数。不涉及物理单位。\n\n最终输出格式规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表。\n- 该列表必须按情况和限制器排序如下：情况 A Minmod 过冲、情况 A Minmod 下冲、情况 A Superbee 过冲、情况 A Superbee 下冲、情况 A MC 过冲、情况 A MC 下冲，然后是按相同限制器顺序排列的情况 B，最后是按相同限制器顺序排列的情况 C。\n- 例如，结构为 $[A\\text{-}\\text{Minmod-OS},A\\text{-}\\text{Minmod-US},A\\text{-}\\text{Superbee-OS},A\\text{-}\\text{Superbee-US},A\\text{-}\\text{MC-OS},A\\text{-}\\text{MC-US},B\\text{-}\\text{Minmod-OS},\\dots,C\\text{-}\\text{MC-US}]$。\n\n您的程序必须是自包含的，无需任何输入，并且严格只打印指定格式的最终单行输出。", "solution": "问题的核心是求解一维无粘伯格斯方程：\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x} \\left( \\frac{u^2}{2} \\right) = 0\n$$\n这是一个形式为 $u_t + (f(u))_x = 0$ 的标量守恒律，其凸通量函数为 $f(u) = u^2/2$。我们将在区域 $[0,1]$ 上采用有限体积法，使用 $N=200$ 个宽度为 $\\Delta x = 1/200$ 的均匀网格。\n\n有限体积格式随时间演化网格平均值 $u_i(t) \\approx \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) dx$。该守恒律的半离散形式为：\n$$\n\\frac{d u_i}{dt} = - \\frac{1}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right)\n$$\n其中 $F_{i+1/2}$ 是网格 $i$ 和网格 $i+1$ 之间界面上的数值通量。\n\n为了在空间上达到二阶精度，我们使用 MUSCL（守恒律单调上游迎风格式）方法。这涉及到在每个时间步开始时，在每个网格内重构解的分段线性表示。在网格 $i$ 内，解近似为：\n$$\nu(x, t^n) = u_i^n + \\frac{\\sigma_i}{\\Delta x}(x-x_i)\n$$\n其中 $u_i^n$ 是时间 $t^n$ 时的网格平均值，$x_i$ 是网格 $i$ 的中心，$\\sigma_i$ 是一个受限斜率。必须对斜率进行限制，以防止产生新的极值，并确保格式是总变差不增（TVD）的。斜率 $\\sigma_i$ 是根据相邻网格的平均值计算的。令 $\\Delta_i^- = u_i^n - u_{i-1}^n$ 且 $\\Delta_i^+ = u_{i+1}^n - u_i^n$。受限斜率 $\\sigma_i$ 是这些差值的函数，$\\sigma_i = \\text{limiter}(\\Delta_i^-, \\Delta_i^+)$。我们将实现三种标准限制器：\n\n1.  **Minmod 限制器：** 这是最具耗散性的 TVD 限制器。\n    $$\n    \\sigma_i = \\text{minmod}(\\Delta_i^-, \\Delta_i^+) = \\frac{1}{2}(\\text{sgn}(\\Delta_i^-) + \\text{sgn}(\\Delta_i^+)) \\min(|\\Delta_i^-|, |\\Delta_i^+|)\n    $$\n2.  **Monotonized Central (MC) 限制器：** 一种更精确的限制器。\n    $$\n    \\sigma_i = \\text{minmod}\\left(2\\Delta_i^-, \\frac{\\Delta_i^- + \\Delta_i^+}{2}, 2\\Delta_i^+\\right)\n    $$\n3.  **Superbee 限制器：** 一种高度压缩的限制器，能为间断产生陡峭的剖面。\n    $$\n    \\sigma_i = \\text{sgn}(\\Delta_i^-) \\max\\left( |\\text{minmod}(\\Delta_i^-, 2\\Delta_i^+)|, |\\text{minmod}(2\\Delta_i^-, \\Delta_i^+)| \\right)\n    $$\n利用受限斜率，我们在每个界面 $x_{i+1/2}$ 的左右两侧重构解值：\n$$\nu_{L, i+1/2} = u_i^n + \\frac{1}{2}\\sigma_i\n$$\n$$\nu_{R, i+1/2} = u_{i+1}^n - \\frac{1}{2}\\sigma_{i+1}\n$$\n数值通量 $F_{i+1/2}$ 由 Godunov 通量给出，该通量由初始状态为 $(u_L, u_R) = (u_{L, i+1/2}, u_{R, i+1/2})$ 的黎曼问题的精确解推导得出。时间积分使用前向欧拉法，并采用自适应时间步长以满足 CFL 条件。\n\n以下是实现此方案的 Python 代码：\n```python\nimport numpy as np\n\ndef minmod(a, b):\n    \"\"\"Vectorized minmod function.\"\"\"\n    return 0.5 * (np.sign(a) + np.sign(b)) * np.minimum(np.abs(a), np.abs(b))\n\ndef minmod_multi(*args):\n    \"\"\"Vectorized multi-argument minmod function.\"\"\"\n    arrs = np.asarray(args)\n    s = np.sign(arrs)\n    same_sign = np.abs(np.sum(s, axis=0)) == len(args)\n    min_mag = np.min(np.abs(arrs), axis=0)\n    return np.where(same_sign, np.sign(arrs[0]) * min_mag, 0)\n\ndef mc_limiter(a, b):\n    \"\"\"Vectorized Monotonized Central (MC) limiter.\"\"\"\n    return minmod_multi(2 * a, 0.5 * (a + b), 2 * b)\n\ndef superbee_limiter(a, b):\n    \"\"\"Vectorized Superbee limiter.\"\"\"\n    s1 = minmod(a, 2*b)\n    s2 = minmod(2*a, b)\n    return np.where(np.sign(a) == np.sign(b), \n                    np.sign(a) * np.maximum(np.abs(s1), np.abs(s2)), \n                    0)\n\ndef godunov_flux(uL, uR):\n    \"\"\"Computes the Godunov flux for the Burgers' equation f(u) = u^2/2.\"\"\"\n    f = lambda u: 0.5 * u**2\n    s = 0.5 * (uL + uR)\n    flux_shock = np.where(s > 0.0, f(uL), f(uR))\n    \n    f_rar = np.zeros_like(uL)\n    f_rar = np.where((uL > 0)  (uR > 0), f(uL), f_rar)\n    f_rar = np.where((uL  0)  (uR  0), f(uR), f_rar)\n    \n    return np.where(uL > uR, flux_shock, f_rar)\n\ndef solve_muscl(uL_init, uR_init, T_final, limiter_func, N=200, cfl_nu=0.9):\n    dx = 1.0 / N\n    x = (np.arange(N) + 0.5) * dx\n    u = np.where(x  0.5, uL_init, uR_init)\n\n    t = 0.0\n    while t  T_final:\n        max_u_abs = np.max(np.abs(u))\n        if max_u_abs  1e-12:\n            dt = T_final\n        else:\n            dt = cfl_nu * dx / max_u_abs\n        \n        dt = min(dt, T_final - t)\n        if dt  1e-12: break\n        \n        u_padded = np.pad(u, (1, 1), 'wrap')\n        \n        delta_minus = u - u_padded[:-2]\n        delta_plus = u_padded[2:] - u\n        \n        sigma = limiter_func(delta_minus, delta_plus)\n        \n        u_L_at_interface = u + 0.5 * sigma\n        u_R_at_interface = np.roll(u - 0.5 * sigma, -1)\n        \n        fluxes = godunov_flux(u_L_at_interface, u_R_at_interface)\n        \n        u = u - (dt / dx) * (fluxes - np.roll(fluxes, 1))\n        \n        t += dt\n\n    u_max = np.max(u)\n    u_min = np.min(u)\n    \n    init_max = max(uL_init, uR_init)\n    init_min = min(uL_init, uR_init)\n    \n    overshoot = max(0, u_max - init_max)\n    undershoot = max(0, init_min - u_min)\n    \n    return overshoot, undershoot\n```", "answer": "[0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000]", "id": "3138413"}]}