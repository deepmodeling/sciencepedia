{"hands_on_practices": [{"introduction": "理论学习之后，最好的深化理解方式便是亲手实现。本节的第一个练习将指导你为一个基本但极其重要的模型问题——一维泊松方程，构建一个完整的自适应网格加密（AMR）程序。通过这个练习 [@problem_id:2420755]，你将实践自适应算法的核心循环：在当前网格上求解、估计误差、标记待加密的单元并进行加密，从而为更复杂的应用打下坚实的基础。", "problem": "您需要实现一个完整的、可运行的程序，该程序使用连续分段仿射帽函数执行一维有限元分析，并执行由残差型后验误差指标驱动的自适应网格加密策略。考虑单位区间上的边值问题：求 $u:[0,1]\\to\\mathbb{R}$ 使得\n$$-u''(x)=f(x)\\ \\text{for}\\ x\\in(0,1),\\quad u(0)=0,\\quad u(1)=0.$$\n设 $\\mathcal{T}_h$ 是一个节点为 $0=x_0<x_1<\\dots<x_N=1$ 的网格，并设 $V_h$ 是在 $x=0$ 和 $x=1$ 处为零的连续分段仿射函数空间。有限元法 (finite element method, FEM) 寻求 $u_h\\in V_h$ 使得\n$$\\int_{0}^{1} u_h'(x)\\,v_h'(x)\\,dx=\\int_{0}^{1} f(x)\\,v_h(x)\\,dx\\quad \\text{for all}\\ v_h\\in V_h.$$\n使用与网格节点相关联的标准帽函数作为 $V_h$ 的基，组装全局线性系统，强加狄利克雷边界条件，并求解 $u_h$ 的节点值。\n\n在每个长度为 $h_i=x_i-x_{i-1}$ 的单元 $K_i=(x_{i-1},x_i)$ 上定义单元误差指标为\n$$\\eta_i^2 := h_i^2\\, f(m_i)^2 + \\tfrac{1}{2} h_i\\Big(\\mathbf{1}_{\\{i>1\\}}\\,J_{i-1}^2 + \\mathbf{1}_{\\{i<N\\}}\\,J_i^2\\Big),$$\n其中 $m_i=\\tfrac{1}{2}(x_{i-1}+x_i)$，并且对于每个内部节点 $x_j$（$j\\in\\{1,\\dots,N-1\\}$），\n$$J_j := \\big|\\,u_h'(x_j^-)-u_h'(x_j^+)\\,\\big|,$$\n其中 $u_h'(x_j^-)$ 是左侧单元 $(x_{j-1},x_j)$ 上的导数，$u_h'(x_j^+)$ 是右侧单元 $(x_j,x_{j+1})$ 上的导数。在每个单元 $K_i$ 上，导数 $u_h'$ 是常数，等于 $u_h$ 在 $K_i$ 上的斜率。\n\n通过迭代以下循环来执行自适应加密：在当前网格上求解离散问题，计算 $(\\eta_i)_{i=1}^N$，选择一个使 $\\eta_i$ 最大化的索引 $i^\\star$（如果有多个索引达到最大值，则选择最小的索引），并通过将其中心点 $m_{i^\\star}$ 作为新节点插入来二等分 $K_{i^\\star}$。将此过程重复指定的加密步数。\n\n在每个测试用例中，对于给定的 $f(x)$，双线性和线性形式中的所有积分都必须精确计算。在下面的所有测试用例中，右端项 $f(x)$ 是次数最多为 1 的多项式，因此 $f(x)$ 乘以一个帽函数在每个单元上的精确积分存在闭合形式。您不得引入任何单位。角度不会出现。\n\n测试套件。对于每种情况，从 $[0,1]$ 的一个包含 $N_0$ 个单元的均匀剖分（即节点位于 $x_j=j/N_0$，$j=0,\\dots,N_0$）开始，执行上面定义的恰好 $S$ 个加密步骤，并报告最终的节点坐标：\n- 情况 A：对于所有 $x\\in[0,1]$，$f(x)=1$，其中 $N_0=2$ 且 $S=2$。\n- 情况 B：对于所有 $x\\in[0,1]$，$f(x)=2x+1$，其中 $N_0=3$ 且 $S=3$。\n- 情况 C：对于所有 $x\\in[0,1]$，$f(x)=-4x+2$，其中 $N_0=1$ 且 $S=4$。\n\n最终输出格式。您的程序必须生成单行输出，其中包含一个由三个列表组成的列表，按顺序对应情况 A、B 和 C。每个内部列表必须按升序包含最终的网格节点坐标，以小数点后精确到 $6$ 位的小数形式写入。外部列表和每个内部列表都必须使用方括号和逗号，不含额外的空格或文本。例如，一个有效的格式是\n$$\\big[ [x_0^{(A)},x_1^{(A)},\\dots], [x_0^{(B)},x_1^{(B)},\\dots], [x_0^{(C)},x_1^{(C)},\\dots] \\big],$$\n其中每个 $x_j^{(\\cdot)}$ 是一个四舍五入后的小数。程序不得读取任何输入。", "solution": "所提出的问题是带有齐次狄利克雷边界条件的泊松方程的标准一维边值问题 (BVP)。我们的任务是在区间 $[0,1]$ 上找到一个满足以下条件的函数 $u(x)$\n$$-u''(x) = f(x) \\quad \\text{for } x \\in (0,1),$$\n$$u(0) = 0, \\quad u(1) = 0.$$\n该问题将使用带有自适应网格加密策略的有限元法 (FEM) 来解决。问题陈述是适定的、科学上合理的，并包含其唯一、可验证解所需的所有必要信息。我们继续进行该方法的推导和实现。\n\n首先，我们建立 BVP 的弱形式。设 $V = H_0^1(0,1)$ 是索博列夫空间，其函数的一阶导数平方可积，并在边界 $x=0$ 和 $x=1$ 处为零。将微分方程乘以一个测试函数 $v(x) \\in V$ 并在域 $(0,1)$ 上积分，得到\n$$-\\int_0^1 u''(x) v(x) dx = \\int_0^1 f(x) v(x) dx.$$\n对左侧应用分部积分法并使用边界条件 $v(0)=v(1)=0$，我们得到弱形式：求 $u \\in V$ 使得\n$$a(u,v) := \\int_0^1 u'(x) v'(x) dx = \\int_0^1 f(x) v(x) dx =: L(v) \\quad \\forall v \\in V.$$\n\n有限元法用一个有限维问题来近似这个无限维问题。我们引入一个由节点 $0=x_0 < x_1 < \\dots < x_N=1$ 组成的网格 $\\mathcal{T}_h$，它将区间 $[0,1]$ 剖分为 $N$ 个长度为 $h_i = x_i - x_{i-1}$ 的单元 $K_i=(x_{i-1}, x_i)$。我们定义了此网格上的一个有限维子空间 $V_h \\subset V$，它由在边界处为零的连续分段仿射函数组成。FEM 问题是：求 $u_h \\in V_h$ 使得\n$$a(u_h, v_h) = L(v_h) \\quad \\forall v_h \\in V_h.$$\n任何函数 $u_h \\in V_h$ 都可以表示为基函数的线性组合。$V_h$ 的基的一个标准选择是与内部节点 $\\{x_j\\}_{j=1}^{N-1}$ 相关联的“帽函数”集合 $\\{\\phi_j\\}_{j=1}^{N-1}$。帽函数 $\\phi_j(x)$ 定义为在节点 $x_j$ 处为 1，在所有其他节点 $x_k$ ($k \\neq j$) 处为 0。它在每个单元上是仿射的。\n因此，解 $u_h(x)$ 写为\n$$u_h(x) = \\sum_{j=1}^{N-1} U_j \\phi_j(x),$$\n其中 $U_j = u_h(x_j)$ 是未知的节点值。由于边界条件 $u_h(0)=u_h(1)=0$ 是强加的，求和仅遍及内部节点。\n\n将此展开式代入弱形式，并对每个 $i \\in \\{1,\\dots,N-1\\}$ 选择 $v_h = \\phi_i$，得到一个线性方程组 $A\\mathbf{U} = \\mathbf{b}$，其中 $\\mathbf{U} = [U_1, \\dots, U_{N-1}]^T$ 是未知节点值的向量，刚度矩阵 $A$ 和载荷向量 $\\mathbf{b}$ 的元素为\n$$A_{ij} = a(\\phi_j, \\phi_i) = \\int_0^1 \\phi_j'(x) \\phi_i'(x) dx,$$\n$$b_i = L(\\phi_i) = \\int_0^1 f(x) \\phi_i(x) dx.$$\n$\\phi_j(x)$ 的导数是分段常数：在 $(x_{j-1}, x_j)$ 上 $\\phi_j'(x) = 1/h_j$，在 $(x_j, x_{j+1})$ 上为 $-1/h_{j+1}$，在其他地方为 0。$\\phi_i'(x)$ 和 $\\phi_j'(x)$ 的支集仅在 $|i-j| \\le 1$ 时重叠，这使得矩阵 $A$ 是三对角的。元素计算如下：\n$$A_{ii} = \\int_{x_{i-1}}^{x_{i+1}} (\\phi_i'(x))^2 dx = \\frac{1}{h_i} + \\frac{1}{h_{i+1}},$$\n$$A_{i,i+1} = A_{i+1,i} = \\int_{x_i}^{x_{i+1}} \\phi_{i+1}'(x) \\phi_i'(x) dx = -\\frac{1}{h_{i+1}}.$$\n对于载荷向量，我们已知 $f(x)$ 是一个次数最多为 1 的多项式，我们将其写为 $f(x) = cx+d$。$b_i$ 的积分必须精确计算：\n$$b_i = \\int_{x_{i-1}}^{x_i} (cx+d)\\frac{x-x_{i-1}}{h_i}dx + \\int_{x_i}^{x_{i+1}} (cx+d)\\frac{x_{i+1}-x}{h_{i+1}}dx.$$\n这些积分的精确计算得出以下公式：\n$$b_i = (cx_i+d)\\frac{h_i+h_{i+1}}{2} + c \\frac{h_{i+1}^2 - h_i^2}{6} = f(x_i)\\frac{h_i+h_{i+1}}{2} + f'(x_i) \\frac{h_{i+1}^2 - h_i^2}{6}.$$\n组装好 $A$ 和 $\\mathbf{b}$ 后，求解系统 $A\\mathbf{U}=\\mathbf{b}$ 以找到 $u_h$ 的节点值。\n\n任务的核心是自适应网格加密。在给定网格上求解出 $u_h$ 后，我们为每个单元 $K_i=(x_{i-1},x_i)$ 计算一个后验误差指标 $\\eta_i$。指定的指标是\n$$\\eta_i^2 = h_i^2 f(m_i)^2 + \\frac{1}{2} h_i \\left( \\mathbf{1}_{\\{i>1\\}} J_{i-1}^2 + \\mathbf{1}_{\\{i<N\\}} J_i^2 \\right),$$\n其中 $m_i$ 是 $K_i$ 的中点，$J_j = |u_h'(x_j^-) - u_h'(x_j^+)|$ 是在内部节点 $x_j$ 处的导数跳跃。由于 $u_h$ 在每个单元上是仿射的，其导数是常数 $u_h'|_{K_k} = (U_k - U_{k-1})/h_k$。因此，$J_j$ 可以很容易地从解向量 $\\mathbf{U}$ 中计算出来。\n\nAMR 循环如下：\n1.  在当前网格 $\\mathcal{T}_h$ 上求解 $u_h$。\n2.  为每个单元 $K_i$ 计算误差指标 $\\eta_i$。\n3.  找到使 $\\eta_i$ 最大的单元 $K_{i^\\star}$。\n4.  通过将 $K_{i^\\star}$ 二等分来加密网格，即在 $x_{i^\\star-1}$ 和 $x_{i^\\star}$ 之间添加一个新节点。\n5.  将此过程重复指定的步数。\n对于每个测试用例，我们从一个均匀网格开始，执行指定数量的加密步骤，并报告最终的节点坐标。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D Poisson BVP with adaptive mesh refinement using FEM.\n    \"\"\"\n\n    test_cases = [\n        # Case A: f(x)=1, N0=2, S=2\n        (lambda x: 1.0, 0.0, 1.0, 2, 2),\n        # Case B: f(x)=2x+1, N0=3, S=3\n        (lambda x: 2.0 * x + 1.0, 2.0, 1.0, 3, 3),\n        # Case C: f(x)=-4x+2, N0=1, S=4\n        (lambda x: -4.0 * x + 2.0, -4.0, 2.0, 1, 4)\n    ]\n\n    all_results = []\n    \n    for f_func, c, d, N0, S in test_cases:\n        # Initialize mesh\n        nodes = np.linspace(0.0, 1.0, N0 + 1).tolist()\n\n        for _ in range(S):\n            nodes.sort()\n            current_nodes = np.array(nodes)\n            N = len(current_nodes) - 1  # Number of elements\n            num_interior_nodes = N - 1\n\n            if num_interior_nodes == 0:\n                # Trivial solution u_h = 0\n                full_U = np.zeros(N + 1)\n            else:\n                # Assemble stiffness matrix A\n                A = np.zeros((num_interior_nodes, num_interior_nodes))\n                h = np.diff(current_nodes)\n                \n                # Diagonal entries\n                for i in range(num_interior_nodes):\n                    idx = i + 1 # node index\n                    A[i, i] = 1.0 / h[idx-1] + 1.0 / h[idx]\n                \n                # Off-diagonal entries\n                for i in range(num_interior_nodes - 1):\n                    idx = i + 1 # node index\n                    A[i, i + 1] = -1.0 / h[idx]\n                    A[i + 1, i] = -1.0 / h[idx]\n\n                # Assemble load vector b\n                b = np.zeros(num_interior_nodes)\n                for i in range(num_interior_nodes):\n                    idx = i + 1  # node index\n                    x_i = current_nodes[idx]\n                    h_left = h[idx - 1]\n                    h_right = h[idx]\n                    \n                    val = (c * x_i + d) * (h_left + h_right) / 2.0\n                    val += c * (h_right**2 - h_left**2) / 6.0\n                    b[i] = val\n\n                # Solve linear system AU=b\n                interior_U = np.linalg.solve(A, b)\n                full_U = np.concatenate(([0], interior_U, [0]))\n\n            # Compute error indicators\n            h = np.diff(current_nodes)\n            \n            # Compute jumps J_j at interior nodes\n            jumps = np.zeros(num_interior_nodes)\n            if num_interior_nodes > 0:\n                derivs = (full_U[1:] - full_U[:-1]) / h\n                for j in range(1, N): # iterate over interior node indices\n                    jump_val = np.abs(derivs[j-1] - derivs[j])\n                    jumps[j-1] = jump_val\n\n            # Compute indicators eta_i for each element\n            etas_sq = np.zeros(N)\n            for i in range(N): # iterate over element indices\n                m_i = (current_nodes[i] + current_nodes[i+1]) / 2.0\n                h_i = h[i]\n                \n                # Element residual term\n                term1 = h_i**2 * f_func(m_i)**2\n                \n                # Jump residual term\n                term2 = 0.0\n                # Jump at left node x_i\n                if i > 0:\n                    term2 += 0.5 * h_i * jumps[i-1]**2\n                # Jump at right node x_{i+1}\n                if i  N - 1:\n                    term2 += 0.5 * h_i * jumps[i]**2\n                \n                etas_sq[i] = term1 + term2\n\n            # Mark element for refinement\n            # np.argmax selects the first occurrence in case of a tie, which matches the spec.\n            i_star = np.argmax(etas_sq)\n\n            # Refine by bisection\n            new_node = (current_nodes[i_star] + current_nodes[i_star+1]) / 2.0\n            nodes.append(new_node)\n        \n        nodes.sort()\n        formatted_nodes = [f\"{node:.6f}\" for node in nodes]\n        all_results.append(f\"[{','.join(formatted_nodes)}]\")\n        \n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2420755"}, {"introduction": "现实世界中的许多问题本质上是非线性的，这要求我们的数值方法也具备处理非线性的能力。这个练习 [@problem_id:3228530] 将挑战你把自适应网格加密技术应用于一个非线性边值问题。你将学习如何将AMR框架与牛顿法等非线性求解器相结合，并探索一种基于方程本身残差的加密指示器，这与上一个练习中基于解的跳跃项的后验误差估计有所不同。", "problem": "考虑定义在闭区间 $[0,1]$ 上的非线性边值问题 (BVP)：求一个二次连续可微函数 $u:[0,1]\\to\\mathbb{R}$，使得\n$$\n-\\,u''(x)\\;+\\;u(x)^3\\;=\\;1,\\quad x\\in(0,1),\\qquad u(0)=0,\\quad u(1)=0.\n$$\n从二阶导数作为对称差商极限的基本定义和 Taylor 展开出发，在非均匀网格 $\\{x_i\\}_{i=0}^{N}$（其中 $x_0=0$，$x_N=1$，且节点严格递增 $x_i  x_{i+1}$）上导出 BVP 的二阶精度有限差分离散化。这将产生一个关于内部节点值 $\\{u_i\\}_{i=1}^{N-1}$ 的非线性代数方程组。\n\n使用带回溯线搜索的 Newton 法求解该非线性系统。残差的欧几里得范数必须用作线搜索和收敛的准则。当 $\\|\\mathbf{F}(\\mathbf{u})\\|_2  \\varepsilon_N$ 时，Newton 迭代终止。\n\n实现一个自适应网格加密 (AMR) 循环。在每个网格区间 $[x_i,x_{i+1}]$ 上，通过从包含该区间的三个连续节点值构造一个唯一的二次多项式来定义一个误差/加密指标。根据此多项式，确定其常数二阶导数 $u''_{est}$ 及其在区间中点的值 $u_{mid}$。该区间的指标定义为方程在中点处的残差绝对值：$R_i = |-u''_{est} + u_{mid}^3 - 1|$。这与一种流行的用于激光脉冲模拟的技术有关，但那里的细节与此处无关。\n\n在每次 AMR 扫描中，在具有最大指标的 $m$ 个区间的中点添加新点。当新网格上的初始猜测需要时，使用前一个网格解的线性插值。整个 AMR 过程在最多 $K$ 次加密扫描后终止，或者当最大指标 $\\max_i R_i  \\varepsilon_R$ 时提前终止。\n\n对于以下每个测试用例 $(n_0,K,m,\\varepsilon_N,\\varepsilon_R)$，您的程序必须运行完整的模拟，从一个具有 $n_0$ 个内部节点的初始均匀网格开始，并报告最终网格中点的总数和最后一次扫描的最大指标。\n\n测试套件：\n- Test 1: (8, 4, 1, 1e-10, 1e-6)\n- Test 2: (3, 0, 1, 1e-10, 1e-6)\n- Test 3: (10, 8, 2, 1e-12, 1e-8)\n- Test 4: (12, 10, 1, 1e-10, 1e-3)\n\n输出格式：生成单行输出，其中包含一个列表，每个测试用例一个列表。每个内部列表必须包含最终网格点数 $N_{\\text{final}}$ 和最终最大区间残差指标 $R_{\\max}$。示例：`[[N1,R1],[N2,R2],...]`。", "solution": "用户提供了一个数值分析领域的适定问题。我将继续进行详细解答。\n\n### 步骤1：问题验证\n\n**1. 已知条件提取**\n- **微分方程**：$-\\,u''(x)\\;+\\;u(x)^3\\;=\\;1$，对于 $x\\in(0,1)$。\n- **边界条件**：$u(0)=0$, $u(1)=0$。\n- **函数性质**：$u:[0,1]\\to\\mathbb{R}$ 是二次连续可微函数。\n- **网格**：一个非均匀、严格递增的网格 $\\{x_i\\}_{i=0}^{N}$，其中 $x_0=0$ 且 $x_N=1$。\n- **离散化方案**：在非均匀网格上对 $u''(x)$ 使用二阶精度中心差分公式。\n- **非线性求解器**：带回溯线搜索的 Newton 法，使用残差的欧几里得范数作为线搜索准则。\n- **自适应网格加密 (AMR) 策略**：\n    - **加密指标**：在每个网格区间 $\\,[x_i,x_{i+1}]$ 的中点处计算的方程残差的绝对值 $|-\\,u''(x)+u(x)^3-1|$。\n    - **指标计算**：对于每个区间，从三个连续的节点值构造一个二次多项式。根据此多项式，确定其常数二阶导数 $u''_{est}$ 及其在区间中点的值 $u_{mid}$。指标为 $|-u''_{est} + u_{mid}^3 - 1|$。\n    - **加密规则**：在每次扫描中，在具有最大指标的 $m$ 个区间的中点添加新点。\n    - **终止条件**：在最多 $K$ 次加密扫描后，或当最大指标低于容差 $\\varepsilon_R$ 时停止。\n- **测试套件参数**：每个测试用例是一个元组 $(n_0,K,m,\\varepsilon_N,\\varepsilon_R)$，其中：\n    - $n_0$：初始均匀网格中的内部点数。\n    - $K$：最大加密扫描次数。\n    - $m$：每次扫描添加的新点数。\n    - $\\varepsilon_N$：Newton 法中残差范数的容差。\n    - $\\varepsilon_R$：AMR 最大指标的容差。\n- **测试用例**：\n    - 测试 1: $(8, 4, 1, 10^{-10}, 10^{-6})$\n    - 测试 2: $(3, 0, 1, 10^{-10}, 10^{-6})$\n    - 测试 3: $(10, 8, 2, 10^{-12}, 10^{-8})$\n    - 测试 4: $(12, 10, 1, 10^{-10}, 10^{-3})$\n- **输出**：对于每个测试用例，一个列表 $[N_{\\text{final}}, R_{\\max}]$，其中 $N_{\\text{final}}$ 是最终的网格点总数，而 $R_{\\max}$ 是最终的最大区间残差指标。\n\n**2. 使用提取的已知条件进行验证**\n- **科学/事实合理性**：该问题描述了一个非线性边值问题（Lane-Emden 方程的一个变种）的数值解法，这是科学计算中的一个标准课题。所指定的方法——有限差分、Newton 法和自适应网格加密——都是成熟且有效的技术。关于“受激辐射光放大 (LASER)”的陈述被明确标记为无关信息，起到干扰作用，但并未影响核心科学任务的有效性。该问题在科学上是合理的。\n- **适定性**：带有给定边界条件的微分方程是适定的。数值程序的描述足够详细，可以进行唯一的实现和求解。\n- **客观性**：问题以精确、定量的术语陈述，没有主观性语言。\n- **完整性和一致性**：问题是自洽的。提供了测试用例所需的所有参数和容差。关于数值方法和加密策略的说明在内部是一致的。\n- **可行性**：该任务是一个标准的计算问题，完全可以实现和解决。\n- **结构和清晰度**：虽然对 AMR 指标模板的描述需要仔细解读，但可以推断出一种合理且一致的方法，具体将在解决方案中详述。除此之外，问题结构清晰。\n\n**3. 结论与行动**\n该问题是**有效的**且定义明确。我现在将构建解决方案。\n\n### 步骤2：解决方案设计与实现\n\n解决方案将按照指定的数值流程实现。关键组成部分是：有限差分离散化、针对所得非线性系统的 Newton-Raphson 求解器，以及自适应网格加密循环。\n\n**1. 有限差分离散化**\n设网格由节点 $x_0, x_1, \\dots, x_N$ 定义。总点数为 $N+1$，内部点数为 $N-1$。设 $u_i$ 是 $u(x_i)$ 的数值近似。边界条件为 $u_0 = 0$ 和 $u_N = 0$。\n\n在内部节点 $x_i$（其中 $i \\in \\{1, \\dots, N-1\\}$）处，我们使用非均匀网格上二阶导数的二阶精度中心差分公式。设 $h_{i-1} = x_i - x_{i-1}$ 且 $h_i = x_{i+1} - x_i$。其近似为：\n$$\nu''(x_i) \\approx \\frac{2}{h_i + h_{i-1}} \\left( \\frac{u_{i+1} - u_i}{h_i} - \\frac{u_i - u_{i-1}}{h_{i-1}} \\right)\n$$\n将此代入 BVP，我们得到一个关于 $N-1$ 个未知内部值 $\\{u_i\\}_{i=1}^{N-1}$ 的包含 $N-1$ 个方程的非线性代数方程组：\n$$\nF_i(\\mathbf{u}) = -\\frac{2}{h_i + h_{i-1}} \\left( \\frac{u_{i+1} - u_i}{h_i} - \\frac{u_i - u_{i-1}}{h_{i-1}} \\right) + u_i^3 - 1 = 0, \\quad \\text{for } i = 1, \\dots, N-1\n$$\n其中 $\\mathbf{u} = [u_1, u_2, \\dots, u_{N-1}]^T$。注意，当 $i=1$ 时，$u_0=0$；当 $i=N-1$ 时，$u_N=0$。\n\n**2. Newton 法**\n我们使用 Newton 法求解方程组 $\\mathbf{F}(\\mathbf{u}) = \\mathbf{0}$。给定一个迭代值 $\\mathbf{u}^{(k)}$，下一个迭代值为 $\\mathbf{u}^{(k+1)} = \\mathbf{u}^{(k)} + \\alpha_k \\Delta \\mathbf{u}^{(k)}$，其中 $\\Delta \\mathbf{u}^{(k)}$ 是以下线性系统的解：\n$$\nJ(\\mathbf{u}^{(k)}) \\Delta \\mathbf{u}^{(k)} = -\\mathbf{F}(\\mathbf{u}^{(k)})\n$$\n这里，$J$ 是雅可比矩阵，其元素为 $J_{ij} = \\frac{\\partial F_i}{\\partial u_j}$。该矩阵是三对角的：\n- **对角线元素 ($j=i$)：** $\\frac{\\partial F_i}{\\partial u_i} = \\frac{2}{h_i + h_{i-1}} \\left( \\frac{1}{h_i} + \\frac{1}{h_{i-1}} \\right) + 3u_i^2 = \\frac{2}{h_i h_{i-1}} + 3u_i^2$\n- **次对角线元素 ($j=i-1$)：** $\\frac{\\partial F_i}{\\partial u_{i-1}} = -\\frac{2}{h_{i-1}(h_i + h_{i-1})}$\n- **超对角线元素 ($j=i+1$)：** $\\frac{\\partial F_i}{\\partial u_{i+1}} = -\\frac{2}{h_i(h_i + h_{i-1})}$\n\n步长 $\\alpha_k$ 通过回溯线搜索确定，以确保残差的欧几里得范数减小，即 $\\|\\mathbf{F}(\\mathbf{u}^{(k+1)})\\|_2  \\|\\mathbf{F}(\\mathbf{u}^{(k)})\\|_2$。我们从 $\\alpha_k = 1$ 开始，并相继将其减半，直到满足此条件。当 $\\|\\mathbf{F}(\\mathbf{u})\\|_2  \\varepsilon_N$ 时，迭代停止。\n\n**3. 自适应网格加密 (AMR)**\n在给定网格上求解 $\\mathbf{u}$ 后，我们估计每个区间 $[x_i, x_{i+1}]$ 内的误差以指导加密。\n- **指标模板选择**：问题指定从“包含该区间的三个连续节点值”构造一个二次插值。对于区间 $[x_i, x_{i+1}]$，这意味着要在基于节点 $\\{x_{j-1}, x_j, x_{j+1}\\}$（其中 $j=i$ 或 $j=i+1$）的模板中进行选择。一个简单而稳健的规则是，对除最后一个区间外的所有区间使用前向模板 $\\{x_i, x_{i+1}, x_{i+2}\\}$，而对最后一个区间则必须使用后向模板 $\\{x_{N-2}, x_{N-1}, x_N\\}$。\n- **指标计算**：对于每个区间 $[x_i, x_{i+1}]$，设选定的三个点为 $(x_a, u_a), (x_b, u_b), (x_c, u_c)$。我们构造插值多项式的 Newton 形式 $p(x) = c_0 + c_1(x-x_a) + c_2(x-x_a)(x-x_b)$。\n    - 常数二阶导数为 $p''(x) = 2c_2$，其中 $c_2$ 是二阶均差。设其为 $u''_{est}$。\n    - 我们在中点 $x_{mid} = \\frac{1}{2}(x_i+x_{i+1})$ 处计算 $p(x)$ 的值，得到 $u_{mid}$。\n    - 残差指标为 $R_i = |-u''_{est} + u_{mid}^3 - 1|$。\n- **加密**：我们找出具有最大指标 $R_i$ 的 $m$ 个区间，并在每个区间的中点添加一个新节点。然后将加密后的网格用于下一步的求解。为了在新的网格上为 Newton 法获得一个好的初始猜测，我们从旧网格上的解进行线性插值。\n- **终止条件**：该过程最多重复 $K$ 次扫描，或者直到 $\\max_i(R_i)  \\varepsilon_R$。\n\n每个测试用例的最终交付成果是最终网格中的总点数 $N_{\\text{final}}$ 和最后一步的最大残差指标 $R_{\\max}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef quadratic_eval(x_pts, y_pts, x_eval):\n    \"\"\"\n    Evaluates a quadratic polynomial and its second derivative.\n    The polynomial interpolates (x_pts, y_pts).\n    Uses Newton's form of the interpolating polynomial for numerical stability.\n    \n    Args:\n        x_pts (np.ndarray): Array of 3 x-coordinates for interpolation.\n        y_pts (np.ndarray): Array of 3 y-coordinates for interpolation.\n        x_eval (float): The point at which to evaluate the polynomial.\n        \n    Returns:\n        tuple: A tuple containing the polynomial's value at x_eval and its\n               constant second derivative.\n    \"\"\"\n    x0, x1, x2 = x_pts[0], x_pts[1], x_pts[2]\n    y0, y1, y2 = y_pts[0], y_pts[1], y_pts[2]\n\n    # Calculate divided differences\n    f_x0 = y0\n    f_x0_x1 = (y1 - y0) / (x1 - x0)\n    f_x1_x2 = (y2 - y1) / (x2 - x1)\n    f_x0_x1_x2 = (f_x1_x2 - f_x0_x1) / (x2 - x0)\n    \n    # Evaluate polynomial at x_eval using Newton form: p(x) = c0 + c1(x-x0) + c2(x-x0)(x-x1)\n    y_eval = f_x0 + f_x0_x1 * (x_eval - x0) + f_x0_x1_x2 * (x_eval - x0) * (x_eval - x1)\n    \n    # The second derivative is constant: p''(x) = 2 * c2\n    y_xx_eval = 2 * f_x0_x1_x2\n    \n    return y_eval, y_xx_eval\n\ndef calculate_indicators(x, u):\n    \"\"\"\n    Calculates residual indicators for each interval of the mesh.\n    \n    Args:\n        x (np.ndarray): The mesh nodes.\n        u (np.ndarray): The solution values at the mesh nodes.\n        \n    Returns:\n        np.ndarray: An array of residual indicators for each interval.\n    \"\"\"\n    N = len(x) - 1  # Number of intervals\n    if N  2:  # Need at least 3 points total for a quadratic\n        return np.array([])\n        \n    indicators = np.zeros(N)\n    \n    for i in range(N):  # Loop over intervals [x_i, x_{i+1}]\n        x_mid = (x[i] + x[i+1]) / 2.0\n        \n        # Choose stencil for the quadratic interpolant based on a simple rule\n        if i  N - 1:\n            p_indices = [i, i + 1, i + 2]\n        else:  # Last interval (i == N - 1)\n            p_indices = [N - 2, N - 1, N]\n            \n        x_pts = x[p_indices]\n        u_pts = u[p_indices]\n\n        # Get values from the quadratic interpolant\n        u_mid, u_xx_est = quadratic_eval(x_pts, u_pts, x_mid)\n        \n        # Compute the residual of the DE at the midpoint\n        residual = -u_xx_est + u_mid**3 - 1\n        indicators[i] = np.abs(residual)\n        \n    return indicators\n\ndef assemble_F(x, u):\n    \"\"\"\n    Assembles the residual vector F for the nonlinear system F(u) = 0.\n    \"\"\"\n    N = len(x) - 1\n    num_interior = N - 1\n    F = np.zeros(num_interior)\n    h = np.diff(x)  # h[i] = x[i+1] - x[i]\n    \n    for i in range(1, N):  # Iterate over interior nodes x_1 to x_{N-1}\n        h_im1 = h[i-1]\n        h_i = h[i]\n        \n        # Central difference for u'' on non-uniform mesh\n        u_xx = 2 * ((u[i+1]-u[i])/h_i - (u[i]-u[i-1])/h_im1) / (h_i + h_im1)\n        \n        # Equation index is i-1 for the 0-indexed vector F\n        F[i-1] = -u_xx + u[i]**3 - 1\n        \n    return F\n\ndef assemble_J(x, u):\n    \"\"\"\n    Assembles the Jacobian matrix J = dF/du for the interior nodes.\n    \"\"\"\n    N = len(x) - 1\n    num_interior = N - 1\n    J = np.zeros((num_interior, num_interior))\n    h = np.diff(x)\n    \n    for i in range(1, N):  # Row i-1 of J corresponds to equation at node x_i\n        row_idx = i - 1\n        h_im1 = h[i-1]\n        h_i = h[i]\n        \n        # Main diagonal: dF_{i-1} / du_i\n        term1 = 2 / (h_i + h_im1) * (1/h_im1 + 1/h_i)\n        term2 = 3 * u[i]**2\n        J[row_idx, row_idx] = term1 + term2\n        \n        # Lower diagonal: dF_{i-1} / du_{i-1}\n        if i > 1:\n            J[row_idx, row_idx - 1] = -2 / ((h_i + h_im1) * h_im1)\n\n        # Upper diagonal: dF_{i-1} / du_{i+1}\n        if i  N - 1:\n            J[row_idx, row_idx + 1] = -2 / ((h_i + h_im1) * h_i)\n            \n    return J\n\ndef newton_solver(x, u_initial, tol):\n    \"\"\"\n    Solves the nonlinear system using Newton's method with backtracking line search.\n    \"\"\"\n    u = u_initial.copy()\n    \n    max_iter = 50\n    min_alpha = 1e-8\n\n    for _ in range(max_iter):\n        F = assemble_F(x, u)\n        norm_F = np.linalg.norm(F)\n        \n        if norm_F  tol:\n            return u\n            \n        J = assemble_J(x, u)\n        \n        try:\n            # Solve the linear system for the Newton step\n            delta_u_interior = np.linalg.solve(J, -F)\n        except np.linalg.LinAlgError:\n            # Jacobian is singular; cannot solve. Return current solution.\n            return u\n\n        # Backtracking Line Search\n        alpha = 1.0\n        u_interior_current = u[1:-1]\n        \n        while alpha > min_alpha:\n            u_interior_new = u_interior_current + alpha * delta_u_interior\n            # Form complete vector with new interior and fixed boundaries\n            u_new = np.concatenate(([0.0], u_interior_new, [0.0]))\n            F_new = assemble_F(x, u_new)\n            \n            if np.linalg.norm(F_new)  norm_F:\n                u = u_new\n                break  # Found a suitable step size\n            \n            alpha /= 2.0\n        else:\n            # Line search failed to find a step that reduces the residual norm.\n            return u\n\n    return u\n\ndef run_case(n0, K, m, eps_N, eps_R):\n    \"\"\"\n    Runs a single adaptive finite difference simulation for the BVP.\n    \"\"\"\n    num_points = n0 + 2\n    x = np.linspace(0.0, 1.0, num_points)\n    # Initial guess for the very first solve is a zero vector.\n    u_guess = np.zeros(num_points)\n    \n    u = u_guess.copy()\n    final_R_max = 0.0\n\n    # The loop runs K times for refinement, plus one final solve/analysis.\n    for k in range(K + 1):\n        u = newton_solver(x, u_guess, eps_N)\n        \n        indicators = calculate_indicators(x, u)\n        R_max = np.max(indicators) if indicators.size > 0 else 0.0\n        \n        final_R_max = R_max\n\n        # Check for AMR termination\n        if k == K or R_max  eps_R:\n            break\n            \n        # Refine the mesh\n        num_intervals = len(x) - 1\n        m_actual = min(m, num_intervals)\n        \n        # Find indices of the m intervals with the largest indicators\n        indices_to_refine = np.argsort(indicators)[-m_actual:]\n        \n        new_points = [(x[idx] + x[idx+1]) / 2.0 for idx in indices_to_refine]\n        \n        x_old, u_old = x, u\n        x = np.sort(np.concatenate((x, new_points)))\n        \n        # Interpolate old solution onto new mesh to create a good initial guess\n        u_guess = np.interp(x, x_old, u_old)\n\n    return [len(x), final_R_max]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (8, 4, 1, 1e-10, 1e-6),\n        (3, 0, 1, 1e-10, 1e-6),\n        (10, 8, 2, 1e-12, 1e-8),\n        (12, 10, 1, 1e-10, 1e-3),\n    ]\n\n    results = []\n    for case in test_cases:\n        n0, K, m, eps_N, eps_R = case\n        result = run_case(n0, K, m, eps_N, eps_R)\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    formatted_results = [f\"[{res[0]},{res[1]}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3228530"}, {"introduction": "一个有效的AMR算法不仅在于如何加密网格，更在于“在哪里”以及“为什么”要加密。这个练习 [@problem_id:3094969] 引导我们进行一次批判性的计算实验，探究一种常见的基于梯度的加密准则可能存在的陷阱。我们将通过一个精心设计的震荡解，研究采样不足（混叠）如何导致算法在光滑区域产生“假阳性”信号，从而错误地触发网格加密，这对于设计鲁棒的AMR策略至关重要。", "problem": "您将研究一个简单的基于梯度的自适应网格加密 (AMR) 指标，在应用于一个构造的光滑振荡函数时，是否会因混叠而产生假阳性。考虑周期性域 $[0,1)$，并定义一个构造解 $u(x) = \\sin(2\\pi \\nu x)$，其中 $\\nu$ 是每单位长度的周期数，所有三角函数参数均以弧度为单位。您将使用一个包含 $N$ 个点的均匀周期性网格来离散化该域，这些点位于 $x_j = j/N$，$j \\in \\{0,1,\\dots,N-1\\}$，网格间距为 $h = 1/N$。在此网格上定义一个离散梯度指标：\n$$\nG_j = \\frac{\\left|u(x_{j+1}) - u(x_j)\\right|}{h},\n$$\n其中索引是周期性的，因此 $x_{N} \\equiv x_0$。如果 $G_j  \\tau$，则一个单元（索引为 $j$）被标记为需要加密，其中 $\\tau$ 是用户选择的阈值。\n\n为了定义由混叠引起的假阳性，假设在采样前应用了一个理想的抗混叠低通滤波器。对于频率为 $\\nu$ 的单色正弦波，以每单位长度 $N$ 个点的速率进行采样，其奈奎斯特截止频率为每单位长度 $N/2$ 个周期。在此理想化模型下，如果 $\\nu \\ge N/2$，低通滤波器会在采样前完全抑制信号内容，这意味着一个理想的粗网格表示为 $u \\equiv 0$，因此梯度处处为零；如果 $\\nu  N/2$，滤波器将不加改变地通过信号。如果实际采样指标标记了至少一个单元，而理想的抗混叠指标不会标记任何单元，则声明为假阳性。形式上，设\n$$\n\\text{actual\\_flags}(N,\\nu,\\tau) = \\#\\{\\, j \\in \\{0,\\dots,N-1\\} \\mid G_j  \\tau \\,\\},\n$$\n理想化的决策是\n$$\n\\text{ideal\\_flags}(N,\\nu,\\tau) = \n\\begin{cases}\n\\text{actual\\_flags}(N,\\nu,\\tau),  \\nu  N/2,\\\\\n0,  \\nu \\ge N/2,\n\\end{cases}\n$$\n那么假阳性就是布尔事件 $\\big(\\text{actual\\_flags}(N,\\nu,\\tau)  0\\big)$ 且 $\\big(\\text{ideal\\_flags}(N,\\nu,\\tau) = 0\\big)$。\n\n任务：编写一个完整、可运行的程序，对于下面列出的每个测试用例，构造离散样本，计算 $G_j$，统计被标记单元的数量，应用理想化的抗混叠准则，并输出是否出现假阳性。\n\n测试套件（每个元组为 $(N,\\nu,\\tau)$）：\n- $(32,17,10)$：频率略高于奈奎斯特频率，预期会出现由混叠引起的标记，而理想的低通滤波器会移除该信号。\n- $(32,16,10)$：恰好在奈奎斯特频率上，采样后的正弦函数在网格点上恒为零。\n- $(32,8,10)$：良好解析的频率，标记（如果有的话）不是由混叠引起的。\n- $(33,20,10)$：在奇数大小的网格上，频率高于奈奎斯特频率，预期会出现由混叠引起的标记。\n- $(64,63,10)$：远高于奈奎斯特频率，但混叠成一个非常低的离散频率；阈值可能足够高以抑制标记。\n\n所有计算均使用无量纲量；三角函数中的所有角度均以弧度为单位。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[True,False,False,True,False]”）。输出必须是布尔值列表，按顺序对应于上述测试用例。", "solution": "该问题要求研究一个简单的基于梯度的自适应网格加密 (AMR) 指标是否会因混叠而产生假阳性。我们得到了一个使用构造解来测试此现象的特定框架。\n\n根据指定标准，该问题被评估为有效。它在科学上基于数值分析和信号处理的既定原则（特别是奈奎斯特-香农采样定理和有限差分近似）。问题是适定的，所有量、条件和目标都得到了正式且明确的定义。其设置是自洽、一致且计算上可行的。该问题提出了一个关于计算科学中实际问题的非平凡问题，使其成为一项实质性的练习。\n\n分析过程如下。对于由参数元组 $(N, \\nu, \\tau)$ 指定的每个测试用例，我们必须确定是否出现假阳性。\n\n假阳性被正式定义为布尔事件 $(\\text{actual\\_flags}(N,\\nu,\\tau)  0) \\land (\\text{ideal\\_flags}(N,\\nu,\\tau) = 0)$。术语 $\\text{actual\\_flags}$ 是计算出的梯度指标超过阈值的网格单元数，而 $\\text{ideal\\_flags}$ 表示如果在采样前应用了理想的抗混叠滤波器，将被标记的单元数。\n\n问题陈述定义了这种理想滤波器的行为：\n$$\n\\text{ideal\\_flags}(N,\\nu,\\tau) = \n\\begin{cases}\n\\text{actual\\_flags}(N,\\nu,\\tau),  \\nu  N/2,\\\\\n0,  \\nu \\ge N/2,\n\\end{cases}\n$$\n这里，$N$ 是采样点数，$\\nu$ 是连续信号的频率。量 $N/2$ 是奈奎斯特频率，即在此采样率下可以唯一表示的最高频率。条件 $\\nu \\ge N/2$ 意味着信号被欠采样。在这个理想化模型中，任何处于或高于奈奎斯特频率的信号内容都会被完全衰减，从而产生一个零信号 ($u \\equiv 0$)，因此梯度指标处处为零。因此，$\\text{ideal\\_flags} = 0$。\n\n将此定义代入假阳性条件，我们发现只有在 $\\nu \\ge N/2$ 时才可能发生假阳性。该条件简化为：\n$$\n(\\text{actual\\_flags}(N,\\nu,\\tau)  0) \\land (\\nu \\ge N/2)\n$$\n这构成了我们算法的基础。对于每个测试用例 $(N, \\nu, \\tau)$：\n1.  首先，我们检查频率 $\\nu$ 是否等于或高于奈奎斯特频率，即 $\\nu \\ge N/2$。如果不满足此条件，根据定义，假阳性不可能发生，该测试用例的结果为 `False`。\n2.  如果 $\\nu \\ge N/2$，我们必须计算实际被标记的单元数。离散信号值 $u_j$ 是从连续构造解 $u(x) = \\sin(2\\pi \\nu x)$ 在网格点 $x_j = j/N$（其中 $j \\in \\{0, 1, \\dots, N-1\\}$）上采样得到的。这给出：\n    $$\n    u_j = u(x_j) = \\sin\\left(2\\pi \\nu \\frac{j}{N}\\right)\n    $$\n3.  接下来，我们为每个单元计算离散梯度指标 $G_j$。网格间距为 $h=1/N$。该指标定义为向前差分的绝对值，并用网格间距进行归一化：\n    $$\n    G_j = \\frac{\\left|u_{j+1} - u_j\\right|}{h} = N \\left|u_{j+1} - u_j\\right|\n    $$\n    索引是周期性的，意味着 $u_N$ 被视为 $u_0$。\n4.  然后我们统计该指标超过给定阈值 $\\tau$ 的单元数量：\n    $$\n    \\text{actual\\_flags} = \\#\\{\\, j \\in \\{0,\\dots,N-1\\} \\mid G_j  \\tau \\,\\}\n    $$\n5.  最后，如果 $\\text{actual\\_flags}  0$（并且我们处于 $\\nu \\ge N/2$ 的情况下），则发生了假阳性，该测试用例的结果为 `True`。否则，结果为 `False`。\n\n这个完整的程序将被实现并应用于每个提供的测试用例。例如，在 $(N, \\nu, \\tau) = (32, 17, 10)$ 的情况下，奈奎斯特频率为 $N/2 = 16$。由于 $\\nu = 17  16$，信号被欠采样。采样信号 $u_j = \\sin(2\\pi \\cdot 17 \\cdot j/32)$ 混叠成一个高频振荡 $u_j = (-1)^j \\sin(2\\pi j/32)$，这会产生大的梯度值。如果这些值中的任何一个超过 $\\tau=10$，则记录为假阳性。相反，对于 $(N, \\nu, \\tau) = (32, 8, 10)$，频率 $\\nu=8$ 低于奈奎斯特频率 $16$，因此信号被良好解析。根据我们的定义，无论 `actual_flags` 的值如何，这种情况都不能产生假阳性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes whether a simple gradient-based AMR indicator produces false \n    positives due to aliasing for a set of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each tuple is (N, nu, tau)\n    # N: number of grid points\n    # nu: frequency of the sine wave\n    # tau: threshold for the gradient indicator\n    test_cases = [\n        (32, 17, 10),\n        (32, 16, 10),\n        (32, 8, 10),\n        (33, 20, 10),\n        (64, 63, 10),\n    ]\n\n    results = []\n    \n    for N, nu, tau in test_cases:\n        # A false positive is defined as (actual_flags > 0) AND (ideal_flags == 0).\n        # The condition (ideal_flags == 0) is equivalent to nu >= N/2.\n        # Therefore, a false positive occurs if nu >= N/2 AND actual_flags > 0.\n\n        # Step 1: Check if the frequency is at or above the Nyquist frequency.\n        # The Nyquist frequency is N/2 cycles per unit length.\n        nyquist_freq = N / 2.0\n        \n        if nu  nyquist_freq:\n            # If the signal is well-resolved, a false positive (as defined) cannot occur.\n            results.append(False)\n            continue\n\n        # Step 2: If undersampled (nu >= nyquist_freq), compute the actual flags.\n        # Define the grid and grid spacing.\n        # Domain is [0, 1), so grid spacing h = 1/N.\n        h = 1.0 / N\n        # Grid points x_j = j/N for j = 0, ..., N-1.\n        j = np.arange(N)\n        x = j * h\n\n        # Step 3: Sample the continuous function u(x) = sin(2*pi*nu*x) on the grid.\n        u = np.sin(2 * np.pi * nu * x)\n        \n        # Step 4: Compute the discrete gradient indicator G_j = |u_{j+1} - u_j| / h.\n        # np.roll(u, -1) provides u_{j+1} with periodic boundary conditions (u_N = u_0).\n        u_j_plus_1 = np.roll(u, -1)\n        G = np.abs(u_j_plus_1 - u) / h\n        \n        # Step 5: Count the number of cells where the indicator exceeds the threshold.\n        actual_flags = np.sum(G > tau)\n        \n        # Step 6: Determine if a false positive occurred.\n        # This happens if there are any flags raised despite the signal\n        # frequency being above the Nyquist limit.\n        is_false_positive = actual_flags > 0\n        results.append(is_false_positive)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3094969"}]}