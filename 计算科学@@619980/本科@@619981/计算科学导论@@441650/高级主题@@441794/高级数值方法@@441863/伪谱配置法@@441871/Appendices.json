{"hands_on_practices": [{"introduction": "本练习旨在探索微分算子的一个基本性质：它的零空间。常数函数的导数为零，这一事实必须在其离散化的对应物——微分矩阵中得到体现。通过本练习 [@problem_id:3179523]，你将验证切比雪夫伪谱矩阵 $D$ 的这一性质，更重要的是，你将研究当我们为了施加边界条件而修改该矩阵时，这一性质会如何改变——这是求解实际微分方程的关键一步。", "problem": "您将实现并使用一个切比雪夫-洛巴托伪谱一阶导数配置矩阵，以研究端点条件如何影响离散微分算子的零空间。请完全基于精确数学术语和标准浮点算术，并遵循以下基本依据和事实。\n\n基本依据和事实：\n- 在伪谱配置法中，函数 $u(x)$ 通过选定节点上的插值多项式进行近似，其导数则通过对该插值多项式求导来近似。这产生一个线性算子（一个矩阵），该算子将节点值映射到节点导数的近似值。\n- 对于切比雪夫-洛巴托节点，节点为 $x_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$，其中 $j=0,\\ldots,N$，$N \\in \\mathbb{N}$ 是子区间的数量。如果 $p(x)$ 是任意一个次数至多为 $N$ 的多项式，则其在这些节点上的伪谱导数等于 $p(x)$ 在这些节点上的精确导数。\n- 常数函数 $p(x) \\equiv 1$ 的导数恒等于零，因此任何一致的一阶导数伪谱微分矩阵 $D$ 在精确算术下都应满足 $D \\mathbf{1} = \\mathbf{0}$，其中 $\\mathbf{1}$ 是全一向量。在浮点算术中，此恒等式在舍入误差范围内成立。\n\n待实现的定义：\n1. 切比雪夫-洛巴托节点：$x_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$，其中 $j=0,\\ldots,N$。\n2. 切比雪夫一阶导数伪谱矩阵 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$：由重心拉格朗日公式构造。令\n   - 当 $j \\in \\{0,N\\}$ 时，$c_j = 2$，否则 $c_j = 1$，\n   - $s_j = (-1)^j$，\n   - $w_j = c_j s_j$，\n   - $x_j$ 如上定义，\n   - $X$ 是一个矩阵，其元素为 $X_{jk} = x_j$，\n   - $\\Delta = X - X^\\top$ 为成对差分矩阵。\n   当 $j \\neq k$ 时，\n   $$ D_{jk} = \\frac{w_j}{w_k} \\cdot \\frac{1}{x_j - x_k}, $$\n   对每个 $j$，\n   $$ D_{jj} = -\\sum_{k\\neq j} D_{jk}. $$\n   该矩阵 $D$ 将节点采样值 $u(x_k)$ 映射为 $u'(x_j)$ 的近似值。\n3. 通过行替换施加端点条件的算子：为了在配置系统中施加齐次狄利克雷边界条件 $u(x_0)=0$ 和 $u(x_N)=0$，将 $D$ 的第一行和最后一行替换为强制施加这些条件的坐标行向量：将第一行设为 $[1, 0, \\ldots, 0]$，最后一行设为 $[0, \\ldots, 0, 1]$。将得到的矩阵记为 $A$。\n4. 仅内部算子：移除 $D$ 的第一行和最后一行以及第一列和最后一列，形成内部块 $D_{\\mathrm{int}} \\in \\mathbb{R}^{(N-1)\\times(N-1)}$。这对应于在端点值被单独处理时，作用于内部未知数。\n\n您的任务：\n- 根据上述定义，实现一个例程来为给定的 $N$ 构造 $D$。\n- 对于下面的每种算子类型，将离散化的常数函数样本定义为具有兼容长度的全一向量 $\\mathbf{1}$，并计算无穷范数残差\n  $$ r = \\lVert \\text{Operator} \\cdot \\mathbf{1} \\rVert_{\\infty}. $$\n- 根据指定的数值阈值解释 $r$，以判断常数函数是否（近似地）位于算子的零空间中。\n\n科学目标：\n- 利用常数多项式的伪谱导数为零的性质，证明为何在精确算术下 $D \\mathbf{1} = \\mathbf{0}$，并数值验证 $r$ 很小。\n- 分析移除端点列（仅内部算子）如何破坏导致 $D \\mathbf{1} = \\mathbf{0}$ 的精确抵消，从而使常数函数不再位于零空间中。\n- 分析通过行替换施加的端点约束如何改变算子零空间，使得 $\\mathbf{1}$ 不再是容许的，除非它满足边界条件，而对于齐次狄利克雷边界条件，除非常数为 $0$，否则它不满足。\n\n测试套件：\n对于以下每种情况，您将根据指定的标准计算一个布尔值。\n\n- 情况 1：算子类型“full”（完整），$N=8$。设容差 $\\tau = 1\\times 10^{-13}$。如果 $r \\le \\tau$，输出 $\\mathrm{True}$，否则输出 $\\mathrm{False}$。\n- 情况 2：算子类型“full”（完整），$N=32$。设容差 $\\tau = 1\\times 10^{-13}$。如果 $r \\le \\tau$，输出 $\\mathrm{True}$，否则输出 $\\mathrm{False}$。\n- 情况 3：算子类型“interior”（内部），$N=8$。设下界 $\\eta = 1\\times 10^{-8}$。如果 $r \\ge \\eta$，输出 $\\mathrm{True}$，否则输出 $\\mathrm{False}$。\n- 情况 4：算子类型“bc_rows”（边界条件行），$N=8$。理论上 $r \\ge 1$，因为第一个和最后一个残差分量等于 $1$。如果 $r \\ge 1$，输出 $\\mathrm{True}$，否则输出 $\\mathrm{False}$。\n- 情况 5：算子类型“full”（完整），$N=2$。设容差 $\\tau = 1\\times 10^{-13}$。如果 $r \\le \\tau$，输出 $\\mathrm{True}$，否则输出 $\\mathrm{False}$。\n- 情况 6：算子类型“interior”（内部），$N=2$。设下界 $\\eta = 1\\times 10^{-8}$。如果 $r \\ge \\eta$，输出 $\\mathrm{True}$，否则输出 $\\mathrm{False}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3]”）。对于此问题，结果是按情况 1 到情况 6 顺序排列的六个布尔值。", "solution": "问题陈述具有科学依据、是良定的且客观。它概述了一个标准的数值分析练习，涉及构造和检验一个切比雪夫伪谱微分矩阵。所有定义都精确，任务清晰，且上下文在计算科学的既定原则之内。因此，该问题是有效的。\n\n此问题的核心是研究一阶导数伪谱微分算子在不同配置下的零空间。如果一个线性算子将某个函数映射为零，则该函数位于算子的零空间中。对于一个微分算子——无论是连续的还是离散的——常数函数是其零空间最基本的元素，因为常数的导数恒等于零。我们将分析这一性质如何在从切比雪夫配置法派生出的三种离散算子形式中体现。\n\n在区间 $[-1, 1]$ 上的函数 $u(x)$ 通过一个穿过 $N+1$ 个切比雪夫-洛巴托节点 $x_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$（其中 $j=0, \\dots, N$）的 $N$ 次多项式插值函数 $p(x)$ 来近似。然后，导数 $u'(x)$ 由 $p'(x)$ 近似。这种关系定义了一个线性变换，从函数值向量 $\\mathbf{u} = [u(x_0), \\dots, u(x_N)]^\\top$ 变换到近似导数值向量 $\\mathbf{u}' = [u'(x_0), \\dots, u'(x_N)]^\\top$。这个变换由 $(N+1) \\times (N+1)$ 的切比雪夫一阶导数伪谱矩阵 $D$ 表示。\n\n$D$ 的元素由以下公式给出：\n$$ D_{jk} = \\frac{c_j(-1)^j}{c_k(-1)^k} \\frac{1}{x_j - x_k} \\quad \\text{for } j \\neq k $$\n$$ D_{jj} = -\\sum_{k\\neq j} D_{jk} $$\n其中，当 $j \\in \\{0, N\\}$ 时，$c_j = 2$，否则 $c_j = 1$。\n\n我们考虑常数函数 $u(x) = 1$。其节点值向量是全一向量 $\\mathbf{1} = [1, 1, \\dots, 1]^\\top$。我们将检验算子与 $\\mathbf{1}$ 的乘积，并计算所得残差向量的无穷范数，$r = \\lVert \\text{Operator} \\cdot \\mathbf{1} \\rVert_{\\infty}$。\n\n**1. 完整微分算子 ($D$)**\n\n这是如上定义的标准切比雪夫微分矩阵。我们分析它对常数函数向量 $\\mathbf{1}$ 的作用。\n\n*   **理论分析：**伪谱方法对于次数至多为 $N$ 的任何多项式都是精确的。常数函数 $u(x)=1$ 是一个 0 次多项式。其导数为 $u'(x)=0$。因此，离散微分算子 $D$ 必须将 $u(x)=1$ 的节点值映射到 $u'(x)=0$ 的节点值。这意味着 $D\\mathbf{1} = \\mathbf{0}$。\n    从代数上看，对角元素 $D_{jj} = -\\sum_{k\\neq j} D_{jk}$ 的构造确保了每一行元素的总和恰好为零：\n    $$ \\sum_{k=0}^{N} D_{jk} = D_{jj} + \\sum_{k\\neq j} D_{jk} = \\left(-\\sum_{k\\neq j} D_{jk}\\right) + \\sum_{k\\neq j} D_{jk} = 0 $$\n    向量 $D\\mathbf{1}$ 的第 $j$ 个分量由 $(D\\mathbf{1})_j = \\sum_{k=0}^{N} D_{jk} \\cdot 1_k = \\sum_{k=0}^{N} D_{jk}$ 给出。由于每行的和都为零，向量 $D\\mathbf{1}$ 就是零向量。\n*   **数值验证（情况 1, 2, 5）：**当用浮点算术实现时，此性质在机器精度范围内成立。计算出的残差 $r = \\lVert D \\mathbf{1} \\rVert_{\\infty}$ 将是一个与机器ε同量级的小数，反映了累积的舍入误差。对于 $N=2$，$N=8$ 和 $N=32$，计算出的残差都极小，满足条件 $r \\le \\tau = 1 \\times 10^{-13}$。因此，这些情况下的测试结果为 $\\mathrm{True}$，证实了全一向量在数值精度范围内位于 $D$ 的零空间中。\n\n**2. 内部算子 ($D_{\\mathrm{int}}$)**\n\n该算子是通过移除 $D$ 的第一行和最后一行以及第一列和最后一列得到的 $(N-1) \\times (N-1)$ 子矩阵。它表示导数在内部节点上的作用，前提是边界值被分开处理。\n\n*   **理论分析：**现在被作用的向量是长度为 $N-1$ 的全一向量，记为 $\\mathbf{1}_{\\mathrm{int}}$。对于一个内部行 $j$（其中 $1 \\le j \\le N-1$），乘积 $D_{\\mathrm{int}}\\mathbf{1}_{\\mathrm{int}}$ 的第 $j$ 个分量是 $D_{\\mathrm{int}}$ 第 $j$ 行元素的和：\n    $$ (D_{\\mathrm{int}}\\mathbf{1}_{\\mathrm{int}})_j = \\sum_{k=1}^{N-1} D_{jk} $$\n    根据完整矩阵 $D$ 的行和为零的性质，我们知道 $\\sum_{k=0}^{N} D_{jk} = 0$。我们可以将其重写为 $D_{j0} + \\sum_{k=1}^{N-1} D_{jk} + D_{jN} = 0$。因此，内部矩阵的行和为：\n    $$ \\sum_{k=1}^{N-1} D_{jk} = -(D_{j0} + D_{jN}) $$\n    这个和通常不为零。通过将算子限制在内部，常数函数位于零空间的性质被破坏了。\n*   **数值验证（情况 3，$N=8$）：**对于 $N=8$，残差向量的元素为 $-(D_{j0} + D_{j8})$，其中 $j=1, \\dots, 7$。这些值显著不为零，导致一个大的无穷范数残差 $r$。测试正确地识别了这一点，对于 $r \\ge \\eta = 1 \\times 10^{-8}$ 得出 $\\mathrm{True}$。\n*   **特殊情况（情况 6，$N=2$）：**对于 $N=2$，内部仅包含一个节点 $j=1$。节点为 $x_0=1$, $x_1=0$, $x_2=-1$。内部矩阵 $D_{\\mathrm{int}}$ 是一个包含元素 $D_{1,1}$ 的 $1 \\times 1$ 矩阵。残差就是 $r = |D_{1,1}|$。根据上述分析，$D_{1,1} = -(D_{1,0} + D_{1,2})$。由于对于偶数 $N$ 考虑中点 $j=N/2$（此处 $j=1=2/2$）时，切比雪夫节点和权重的对称性，项 $D_{j,0}$ 和 $D_{j,N}$ 会相互抵消。具体来说，$D_{1,0} = \\frac{1}{2}$ 且 $D_{1,2} = -\\frac{1}{2}$，所以它们的和为 $0$。因此，$D_{1,1} = 0$，残差 $r=0$。测试 $r \\ge \\eta$ 变为 $0 \\ge 1 \\times 10^{-8}$，结果为 $\\mathrm{False}$。\n\n**3. 施加端点条件的算子 ($A$)**\n\n该算子是通过将 $D$ 的第一行和最后一行替换为基向量以强制施加边界条件而形成的。对于齐次狄利克雷条件，第一行变为 $[1, 0, \\dots, 0]$，最后一行变为 $[0, \\dots, 0, 1]$。\n\n*   **理论分析：**该矩阵 $A$ 用于求解形式为 $A\\mathbf{u} = \\mathbf{f}$ 的方程组，其中第一个和最后一个方程为 $u_0=f_0$ 和 $u_N=f_N$。当我们测试 $A$ 对全一向量 $\\mathbf{1}$ 的作用时，我们实际上是在检查常数函数 $u(x)=1$ 是否在其零空间中。乘积 $A\\mathbf{1}$ 如下：\n    - 第一个分量：$(A\\mathbf{1})_0 = [1, 0, \\dots, 0] \\cdot [1, \\dots, 1]^\\top = 1$。这对应于检查 $u(x_0)=1$ 是否满足 $u(x_0)=0$。它不满足。\n    - 内部分量 ($j=1, \\dots, N-1$)：$(A\\mathbf{1})_j = (D\\mathbf{1})_j = 0$（在精确算术中），因为这些行来自原始矩阵 $D$。\n    - 最后一个分量：$(A\\mathbf{1})_N = [0, \\dots, 0, 1] \\cdot [1, \\dots, 1]^\\top = 1$。这对应于检查 $u(x_N)=1$ 是否满足 $u(x_N)=0$。它不满足。\n    得到的残差向量是 $\\mathbf{r} = [1, 0, \\dots, 0, 1]^\\top$。其无穷范数为 $r = \\lVert \\mathbf{r} \\rVert_{\\infty} = \\max(|1|, |0|, |1|) = 1$。常数函数不在 $A$ 的零空间中。只有平凡常数函数 $u(x)=0$ 才会在。\n*   **数值验证（情况 4，$N=8$）：**计算结果与理论预测完全相符。残差向量为 $[1, 0, \\dots, 0, 1]^\\top$（其中内部的零会受到浮点误差的影响，但仍然非常小），其无穷范数为 $r=1$。测试 $r \\ge 1$ 得到满足，结果为 $\\mathrm{True}$。\n\n总而言之，这项研究表明，微分算子在其零空间中包含常数函数这一基本性质是脆弱的。它对于完整、未修改的伪谱矩阵成立，但会被求解边值问题时使用的标准修改所破坏，例如将算子限制在内部点或通过行替换强制施加边界条件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_chebyshev_matrix(N: int) -> np.ndarray:\n    \"\"\"\n    Constructs the Chebyshev first-derivative pseudospectral matrix D\n    for N+1 Chebyshev-Lobatto nodes.\n\n    Args:\n        N (int): The number of subintervals (degree of polynomial).\n\n    Returns:\n        np.ndarray: The (N+1)x(N+1) differentiation matrix.\n    \"\"\"\n    if N == 0:\n        return np.array([[0.0]])\n    \n    # Define Chebyshev-Lobatto nodes\n    j = np.arange(N + 1)\n    x = np.cos(np.pi * j / N)\n    \n    # Define weights\n    c = np.ones(N + 1)\n    c[0] = 2.0\n    c[-1] = 2.0\n    \n    w_sign = np.power(-1.0, j)\n    w = c * w_sign\n\n    # Calculate off-diagonal elements using broadcasting\n    X = x.reshape(N + 1, 1)\n    dX = X - X.T\n    \n    W_ratio = w.reshape(N + 1, 1) / w.reshape(1, N + 1)\n    \n    # Temporarily add identity to dX to avoid division by zero on the diagonal.\n    # The diagonal values will be correctly computed later.\n    D = W_ratio / (dX + np.eye(N + 1))\n    np.fill_diagonal(D, 0.0)\n    \n    # Calculate diagonal elements such that row sums are zero\n    row_sums = D.sum(axis=1)\n    np.fill_diagonal(D, -row_sums)\n    \n    return D\n\ndef solve():\n    \"\"\"\n    Runs the test suite specified in the problem statement to analyze\n    the nullspace of various Chebyshev differentiation operators.\n    \"\"\"\n    results = []\n\n    # Case 1: 'full' operator, N=8\n    N1 = 8\n    tau1 = 1e-13\n    D1 = get_chebyshev_matrix(N1)\n    ones1 = np.ones(N1 + 1)\n    r1 = np.linalg.norm(D1 @ ones1, ord=np.inf)\n    results.append(r1 <= tau1)\n\n    # Case 2: 'full' operator, N=32\n    N2 = 32\n    tau2 = 1e-13\n    D2 = get_chebyshev_matrix(N2)\n    ones2 = np.ones(N2 + 1)\n    r2 = np.linalg.norm(D2 @ ones2, ord=np.inf)\n    results.append(r2 <= tau2)\n\n    # Case 3: 'interior' operator, N=8\n    N3 = 8\n    eta3 = 1e-8\n    D3 = get_chebyshev_matrix(N3)\n    D_int3 = D3[1:-1, 1:-1]\n    ones3 = np.ones(N3 - 1)\n    r3 = np.linalg.norm(D_int3 @ ones3, ord=np.inf)\n    results.append(r3 >= eta3)\n\n    # Case 4: 'bc_rows' operator, N=8\n    N4 = 8\n    eta4 = 1.0\n    D4 = get_chebyshev_matrix(N4)\n    A4 = D4.copy()\n    A4[0, :] = 0.0\n    A4[0, 0] = 1.0\n    A4[-1, :] = 0.0\n    A4[-1, -1] = 1.0\n    ones4 = np.ones(N4 + 1)\n    r4 = np.linalg.norm(A4 @ ones4, ord=np.inf)\n    results.append(r4 >= eta4)\n    \n    # Case 5: 'full' operator, N=2\n    N5 = 2\n    tau5 = 1e-13\n    D5 = get_chebyshev_matrix(N5)\n    ones5 = np.ones(N5 + 1)\n    r5 = np.linalg.norm(D5 @ ones5, ord=np.inf)\n    results.append(r5 <= tau5)\n\n    # Case 6: 'interior' operator, N=2\n    N6 = 2\n    eta6 = 1e-8\n    D6 = get_chebyshev_matrix(N6)\n    D_int6 = D6[1:-1, 1:-1] # This is the single element D[1,1]\n    ones6 = np.ones(N6 - 1) # Vector of length 1\n    r6 = np.linalg.norm(D_int6 @ ones6, ord=np.inf)\n    results.append(r6 >= eta6)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3179523"}, {"introduction": "在理解了微分矩阵的性质之后，我们现在将其应用于物理学和工程学中的一个经典问题：Sturm-Liouville 特征值问题。伪谱方法在处理此类问题时异常强大，通常只需相对较少的网格点就能得到非常精确的特征值近似。在本次实践中 [@problem_id:3179507]，你将离散化二阶微分算子 $-u'' = \\lambda u$，并将你的数值结果与精确的解析解进行比较，从而直接观察到使这些方法如此吸引人的“谱精度”。", "problem": "考虑基于 Chebyshev 多项式的伪谱配置法 (PCM)，用于在区间 $[-1,1]$ 上近似导数。设 $N \\in \\mathbb{N}$，并定义 Chebyshev 配置点（第一类）为 $x_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$，其中 $j = 0,1,\\dots,N$，所有角度单位均为弧度。设 $D \\in \\mathbb{R}^{(N+1) \\times (N+1)}$ 表示一阶微分矩阵，它在 Chebyshev 插值下将配置点上的函数值向量映射到这些点上的一阶导数值，并定义二阶导数矩阵为 $D^{(2)} = D^2$。考虑在 $[-1,1]$ 上的 Sturm–Liouville 特征值问题，其具有齐次 Dirichlet 边界条件：\n$$\n-u''(x) = \\lambda u(x), \\quad u(-1) = 0, \\quad u(1) = 0.\n$$\n已知该问题的精确特征值为\n$$\n\\lambda_k = \\left(\\frac{k \\pi}{2}\\right)^2, \\quad k = 1,2,3,\\dots,\n$$\n其中 $u_k(x)$ 在 $[-1,1]$ 上满足边界条件。\n\n你的任务是：\n- 使用上述定义的 Chebyshev 配置点，从多项式插值的基本原理出发，构造 Chebyshev 一阶微分矩阵 $D$。\n- 形成 $D^{(2)} = D^2$ 并通过限制在内部配置点 $x_j$（其中 $j = 1,2,\\dots,N-1$）上，对带有齐次 Dirichlet 边界条件的算子 $-u'' = \\lambda u$ 进行离散化。这将产生一个形如\n$$\nA \\mathbf{u}_{\\text{int}} = \\lambda \\mathbf{u}_{\\text{int}},\n$$\n的矩阵特征值问题，其中 $A \\in \\mathbb{R}^{(N-1) \\times (N-1)}$ 是从 $D^{(2)}$ 得到的，$\\mathbf{u}_{\\text{int}}$ 表示在配置点上 $u$ 的内部值向量。使用齐次边界条件来消除对边界值的依赖。\n- 计算 $A$ 的特征值，将它们按升序排序，并与精确特征值 $\\lambda_k$（其中 $k = 1,\\dots,N-1$）进行比较。\n- 对于每个 $N$，报告前 $N-1$ 个特征值的最大绝对相对误差：\n$$\nE_{\\max}(N) = \\max_{1 \\le k \\le N-1} \\frac{\\left| \\lambda_k^{\\text{num}} - \\lambda_k \\right|}{\\lambda_k}.\n$$\n\n你可以使用的基础知识包括：Chebyshev 点的定义、多项式插值及其导数的性质，以及有限区间上 Dirichlet Sturm–Liouville 问题及其精确特征值的形式。\n\n对 $N$ 使用以下测试集：\n- $N = 2$（具有最小非平凡内部的边界情况），\n- $N = 3$（小网格），\n- $N = 8$（中等网格），\n- $N = 16$（较大网格），\n- $N = 64$（细网格）。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个条目必须是测试集中相应 $N$ 的 $E_{\\max}(N)$ 值，格式为具有六位有效数字的科学记数法（例如，$[1.234567e-03,4.321000e-05,\\dots]$）。不涉及物理单位，所有角度测量必须以弧度为单位解释。最终输出必须是按上述指定的测试集 $N$ 值顺序排列的列表。", "solution": "所提出的问题是使用 Chebyshev 伪谱配置法对一维 Sturm-Liouville 问题的特征值进行数值近似。具体来说，我们要解决在区间 $[-1, 1]$ 上的特征值问题\n$$\n-u''(x) = \\lambda u(x)\n$$\n其边界条件为齐次 Dirichlet 边界条件 $u(-1) = 0$ 和 $u(1) = 0$。该任务要求构造 Chebyshev 微分矩阵，通过将问题限制在内部配置点来应用边界条件，然后计算所得离散算子的特征值。数值特征值的准确性将通过计算最大相对误差，与已知的精确特征值 $\\lambda_k = \\left(\\frac{k \\pi}{2}\\right)^2$（其中 $k = 1, 2, 3, \\dots$）进行比较评估。\n\n伪谱配置法基于用一个全局插值多项式 $p(x)$ 来近似函数 $u(x)$，该多项式在一组预设节点上与 $u(x)$ 的值相同。对于这个问题，我们使用 Chebyshev-Gauss-Lobatto 点，定义为\n$$\nx_j = \\cos\\left(\\frac{\\pi j}{N}\\right) \\quad \\text{其中 } j = 0, 1, \\dots, N.\n$$\n这些点是 N 次第一类 Chebyshev 多项式 $T_N(x)$ 的极值点。函数 $u(x)$ 的导数随后由插值多项式 $p(x)$ 在这些相同点上的导数来近似。\n\n该方法的核心是构造 Chebyshev 一阶微分矩阵 $D \\in \\mathbb{R}^{(N+1) \\times (N+1)}$。如果 $\\mathbf{u} = [u(x_0), u(x_1), \\dots, u(x_N)]^T$ 是配置点上的函数值向量，则一阶导数向量 $\\mathbf{u}' = [u'(x_0), u'(x_1), \\dots, u'(x_N)]^T$ 通过矩阵-向量乘积 $D\\mathbf{u}$ 来近似。$D$ 的元素可以从 Lagrange 插值的原理推导出来。如果 $p(x) = \\sum_{k=0}^N u_k L_k(x)$ 是对数据进行插值的次数最多为 $N$ 的唯一多项式，其中 $L_k(x)$ 是 Lagrange 基多项式，那么 $p'(x_i) = \\sum_{k=0}^N u_k L'_k(x_i)$。因此，微分矩阵的元素由 $(D)_{ik} = L'_k(x_i)$ 给出。对于 Chebyshev 点，这些元素有众所周知的解析形式：\n$$\n(D)_{ij} = \\begin{cases}\n\\frac{c_i}{c_j} \\frac{(-1)^{i+j}}{x_i - x_j} & i \\neq j \\\\\n-\\frac{x_j}{2(1-x_j^2)} & 1 \\le j \\le N-1 \\\\\n\\frac{2N^2+1}{6} & j = 0 \\\\\n-\\frac{2N^2+1}{6} & j = N\n\\end{cases}\n$$\n其中权重 $c_j$ 定义为 $c_0 = c_N = 2$ 且当 $j = 1, \\dots, N-1$ 时 $c_j = 1$。一种计算对角元素的数值上更稳定的方法是利用常数函数的导数为零这一性质。这意味着 $D$ 的每行之和必须为零，从而得到关系式 $(D)_{ii} = -\\sum_{j \\neq i} (D)_{ij}$。\n\n二阶导数通过应用两次一阶导数算子来近似。二阶导数向量 $\\mathbf{u}''$ 通过 $D^2 \\mathbf{u}$ 来近似，其中 $D^{(2)} = D^2$ 是二阶微分矩阵。因此，特征值问题 $-u''(x) = \\lambda u(x)$ 被离散化为\n$$\n-D^{(2)} \\mathbf{u} = \\lambda \\mathbf{u}.\n$$\n这代表一个由 $N+1$ 个线性方程组成的系统。现在必须施加边界条件 $u(-1) = 0$ 和 $u(1) = 0$。由于 $x_0 = \\cos(0) = 1$ 和 $x_N = \\cos(\\pi) = -1$，这些条件转化为 $u_0 = u(x_0) = 0$ 和 $u_N = u(x_N) = 0$。\n\n我们现在可以将系统简化为只包含内部点 $j = 1, \\dots, N-1$。对于内部的第 $j$ 行，方程为：\n$$\n-\\sum_{k=0}^{N} (D^{(2)})_{jk} u_k = \\lambda u_j.\n$$\n代入 $u_0 = 0$ 和 $u_N = 0$，求和简化为：\n$$\n-(D^{(2)})_{j0} u_0 - \\sum_{k=1}^{N-1} (D^{(2)})_{jk} u_k - (D^{(2)})_{jN} u_N = \\lambda u_j\n$$\n$$\n-\\sum_{k=1}^{N-1} (D^{(2)})_{jk} u_k = \\lambda u_j.\n$$\n这构成了一个大小为 $(N-1) \\times (N-1)$ 的标准矩阵特征值问题：\n$$\nA \\mathbf{u}_{\\text{int}} = \\lambda \\mathbf{u}_{\\text{int}},\n$$\n其中 $\\mathbf{u}_{\\text{int}} = [u_1, u_2, \\dots, u_{N-1}]^T$ 是内部点上的函数值向量，而 $A$ 是通过取 $D^{(2)}$ 中对应于行和列从 $1$ 到 $N-1$ 的子矩阵的负值而形成的 $(N-1) \\times (N-1)$ 矩阵。\n\n总体计算步骤如下：\n1.  对于给定的整数 $N$，构造 $(N+1) \\times (N+1)$ 的 Chebyshev 微分矩阵 $D$。\n2.  计算二阶导数矩阵 $D^{(2)} = D^2$。\n3.  从 $-D^{(2)}$ 中提取内部子矩阵，以形成 $(N-1) \\times (N-1)$ 矩阵 $A$。\n4.  计算 $A$ 的特征值。由于原始算子是自伴的，$A$ 的特征值将是实数。将它们按升序排序以获得数值近似值 $\\lambda_k^{\\text{num}}$，其中 $k = 1, \\dots, N-1$。\n5.  生成精确特征值 $\\lambda_k = (\\frac{k\\pi}{2})^2$，其中 $k = 1, \\dots, N-1$。\n6.  计算所有计算出的特征值的最大绝对相对误差 $E_{\\max}(N)$：\n    $$\n    E_{\\max}(N) = \\max_{1 \\le k \\le N-1} \\frac{\\left| \\lambda_k^{\\text{num}} - \\lambda_k \\right|}{\\lambda_k}.\n    $$\n对指定测试集中的每个 $N$ 值重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef construct_chebyshev_diff_matrix(N):\n    \"\"\"\n    Constructs the Chebyshev first derivative differentiation matrix.\n\n    Args:\n        N (int): The number of intervals, which defines the matrix size (N+1)x(N+1).\n\n    Returns:\n        numpy.ndarray: The (N+1)x(N+1) differentiation matrix D.\n    \"\"\"\n    if N == 0:\n        return np.array([[0.0]])\n        \n    size = N + 1\n    D = np.zeros((size, size))\n    x = np.cos(np.pi * np.arange(size) / N)\n    \n    # Weights for the formula\n    c = np.ones(size)\n    c[0] = 2.0\n    c[-1] = 2.0\n\n    # Off-diagonal elements\n    for i in range(size):\n        for j in range(size):\n            if i != j:\n                D[i, j] = (c[i] / c[j]) * ((-1)**(i + j)) / (x[i] - x[j])\n    \n    # Diagonal elements using the row-sum-to-zero property\n    for i in range(size):\n        D[i, i] = -np.sum(D[i, :])\n        \n    return D\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test cases and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [2, 3, 8, 16, 64]\n    \n    results = []\n    \n    for N in test_cases:\n        # Step 1: Construct the Chebyshev first derivative matrix D.\n        D = construct_chebyshev_diff_matrix(N)\n        \n        # Step 2: Compute the second derivative matrix D^(2) = D^2.\n        D2 = D @ D\n        \n        # Step 3: Form the matrix A for the interior problem.\n        # The equation is -u'' = lambda*u. A is the discretization of -d^2/dx^2.\n        # Boundary conditions u(-1)=0, u(1)=0 are imposed by taking the submatrix\n        # corresponding to interior points (j=1, ..., N-1).\n        A = -D2[1:N, 1:N]\n        \n        # Step 4: Compute the eigenvalues of A.\n        # For a real matrix A, eigenvalues can be complex. The analytical problem\n        # has real eigenvalues, so we take the real part of the numerical solution.\n        # A should be nearly symmetric, yielding nearly real eigenvalues.\n        numerical_eigenvalues = np.sort(np.real(np.linalg.eigvals(A)))\n        \n        # Step 5: Compute the exact eigenvalues.\n        # The eigenvalues correspond to k = 1, 2, ..., N-1.\n        k = np.arange(1, N)\n        exact_eigenvalues = (k * np.pi / 2.0)**2\n        \n        # Step 6: Calculate the maximum absolute relative error.\n        # For N=2, A is 1x1, so there is only one eigenvalue.\n        if N > 1:\n            relative_errors = np.abs(numerical_eigenvalues - exact_eigenvalues) / exact_eigenvalues\n            max_relative_error = np.max(relative_errors)\n        else: # Case N=1 has no interior points, so error is undefined. N=2 is the first meaningful case.\n              # For N=2, k=1, so there is one interior point and one eigenvalue.\n              # The code handles this correctly.\n            max_relative_error = np.nan\n\n        results.append(max_relative_error)\n\n    # Final print statement in the exact required format.\n    # The example format \"1.234567e-03\" has 7 significant digits, which corresponds\n    # to a precision of 6 digits after the decimal point in scientific notation.\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n```", "id": "3179507"}, {"introduction": "我们最后的实践将从稳态问题转向瞬态偏微分方程的动态世界，特别是平流方程 $u_t + a u_x = 0$。对于这类问题，数值稳定性是首要关注点；一个不稳定的方法会产生无用且发散的解。本练习 [@problem_id:3179536] 介绍了用于稳定性分析的能量法，以及一种称为“同步近似项”(Simultaneous Approximation Term, SAT)的现代边界条件施加技术，让你能够确定数值格式在何种条件下能保持稳定。", "problem": "考虑闭区间 $[-1,1]$ 上的一维线性平流方程 $u_t + a\\,u_x = 0$，其中 $a$ 为恒定的平流速度。在伪谱配置法中，使用 Chebyshev–Gauss–Lobatto 节点及相关的一阶微分矩阵来近似空间导数。通过同步近似项 (Simultaneous Approximation Term, SAT) 以迎风方式施加入流边界条件。在与 Chebyshev–Gauss–Lobatto 求积一致的离散内积中，使用能量法研究由此产生的半离散算子的稳定性。\n\n您必须使用的基本原理：\n- 直线法通过仅在空间上进行离散化，将偏微分方程转换为常微分方程组，得到 $u_t = \\mathcal{L}\\,u$，其中 $\\mathcal{L}$ 是半离散空间算子。\n- Chebyshev–Gauss–Lobatto 节点的定义为 $x_j = \\cos\\!\\left(\\frac{\\pi j}{N}\\right)$，其中 $j=0,1,\\dots,N$，$N$ 是多项式次数参数。这些节点用于导数的配置。\n- Chebyshev–Gauss–Lobatto 节点上的一阶伪谱微分矩阵是通过对与这些节点相关的 Lagrange 插值多项式求导并在节点处求值得到的。\n- 能量法通过研究离散能量范数 $\\|u\\|_H^2 = u^\\top H u$ 的时间变化率来评估稳定性，其中 $H$ 是定义离散内积的某个对称正定矩阵。如果对于所有状态 $u$，都有 $\\frac{d}{dt}\\|u\\|_H^2 \\le 0$，则表明系统是稳定的，这等价于对称矩阵 $S = H\\mathcal{L} + \\mathcal{L}^\\top H$ 是半负定的。\n\n您必须按以下步骤进行，不得使用简化推导的快捷公式：\n1. 对于给定的 $N$，在 $[-1,1]$ 上构建 Chebyshev–Gauss–Lobatto 节点 $x_j$。\n2. 通过对与这些节点相关的 Lagrange 基求导并在节点处求值，推导并组装 Chebyshev 配置一阶微分矩阵 $D$。\n3. 选择一个与 Chebyshev–Gauss–Lobatto 求积相关的对角、对称正定求积权重矩阵 $H$（必须使用与 Chebyshev 权重一致的权重），使得 $u^\\top H v$ 近似于 $\\int_{-1}^1 u(x)\\,v(x)\\,\\frac{dx}{\\sqrt{1-x^2}}$。\n4. 为直线法构建半离散算子 $\\mathcal{L}$，其中包含强度为 $s \\ge 0$ 的迎风 SAT 入流边界罚项，该罚项仅施加于入流边界：\n   - 如果 $a>0$，入流边界位于 $x=-1$（左端点）。\n   - 如果 $a<0$，入流边界位于 $x=+1$（右端点）。\n   迎风 SAT 罚项必须通过一个与入流端点对齐的秩一-项来惩罚入流边界值的偏差，该项按相应求积权重的倒数进行缩放，以便其影响在 $H$-内积中度量。\n5. 推导对称部分 $S = H\\mathcal{L} + \\mathcal{L}^\\top H$，并解释能量法如何将其特征值的符号与稳定性联系起来。\n6. 通过计算 $S$ 的最大特征值来实现数值测试以检查稳定性；通过测试最大特征值是否小于或等于 $10^{-10}$ 来报告稳定性的布尔值（此容差考虑了浮点舍入误差）。\n\n本问题不涉及物理单位或角度；所有量均为无量纲。测试套件的最终答案必须是布尔值。\n\n测试套件：\n使用以下参数集 $(N,a,s)$，其中 $N$ 是 Chebyshev–Gauss–Lobatto 节点之间的区间数（因此有 $N+1$ 个节点），$a$ 是平流速度，$s$ 是迎风 SAT 罚项强度：\n- $(16, 1.0, 0.0)$\n- $(16, 1.0, 0.5)$\n- $(16, 1.0, 1.0)$\n- $(16, 1.0, 4.0)$\n- $(16, -1.0, 0.5)$\n- $(32, 1.0, 2.0)$\n- $(32, -1.0, 2.0)$\n\n程序输出规范：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,...]”）。每个条目必须是布尔值，按上面列出的顺序指示其相应测试用例的稳定性。", "solution": "该问题要求分析一维线性平流方程 $u_t + a\\,u_x = 0$ 在区域 $x \\in [-1, 1]$ 上的伪谱配置法的稳定性。稳定性将通过能量法对一个采用同步近似项 (SAT) 来施加入流边界条件的半离散化方案进行研究。\n\n我们采用直线法，该方法通过离散化空间导数将偏微分方程 (PDE) 转换为形式为 $\\frac{d\\vec{u}}{dt} = \\mathcal{L}\\vec{u}$ 的常微分方程组 (ODE)。这里，$\\vec{u}(t)$ 是在时间 $t$ 时各配置点上解值的向量，$\\mathcal{L}$ 是半离散空间算子。\n\n**1. Chebyshev–Gauss–Lobatto 节点与求积**\n解 $u(x,t)$ 通过一个多项式插值来近似，并且偏微分方程在一组配置点上被强制满足。我们使用区间 $[-1, 1]$ 上的 $N+1$ 个 Chebyshev–Gauss–Lobatto (CGL) 节点，定义如下：\n$$\nx_j = \\cos\\left(\\frac{\\pi j}{N}\\right) \\quad \\text{for } j=0, 1, \\dots, N\n$$\n注意，节点的顺序是从 $x_0 = 1$ 到 $x_N = -1$。\n\n稳定性分析利用了一种基于离散内积的能量法，该离散内积近似于连续内积 $\\langle u, v \\rangle_w = \\int_{-1}^1 u(x)v(x) \\frac{dx}{\\sqrt{1-x^2}}$。相应的离散内积是 $(\\vec{u}, \\vec{v})_H = \\vec{u}^\\top H \\vec{v}$，其中 $H$ 是一个包含求积权重的对角、对称正定矩阵。对于 CGL 节点和 Chebyshev 权重函数 $w(x) = (1-x^2)^{-1/2}$，求积权重由下式给出：\n$$\nw_j = \\frac{\\pi}{c_j N} \\quad \\text{for } j=0, 1, \\dots, N\n$$\n其中 $c_0 = c_N = 2$ 且对于 $j=1, \\dots, N-1$ 有 $c_j = 1$。求积矩阵为 $H = \\text{diag}(w_0, w_1, \\dots, w_N)$。该矩阵是对称且正定的。解的离散能量为 $\\|\\vec{u}\\|_H^2 = \\vec{u}^\\top H \\vec{u}$。\n\n**2. Chebyshev 配置微分矩阵**\nCGL 节点上的空间导数 $u_x$ 通过矩阵向量积 $D\\vec{u}$ 来近似，其中 $D$ 是 $(N+1) \\times (N+1)$ 的 Chebyshev 微分矩阵。$D$ 的元素是通过对与节点 $\\{x_j\\}$ 相关的 Lagrange 插值多项式求导，并于这些相同的节点上求值得到的。$D$ 的元素由下式给出：\n$$\nD_{ij} = \\begin{cases}\n\\frac{c_i}{c_j} \\frac{(-1)^{i+j}}{x_i - x_j}, & i \\neq j \\\\\n\\frac{-x_j}{2(1-x_j^2)}, & i = j, \\quad j=1, \\dots, N-1 \\\\\n\\frac{2N^2+1}{6}, & i = j = 0 \\\\\n-\\frac{2N^2+1}{6}, & i = j = N\n\\end{cases}\n$$\n其中系数 $c_j$ 与为求积权重定义的相同。\n\n**3. 带 SAT 的半离散算子**\n$u_t + a\\,u_x = 0$ 的半离散化形式为 $\\frac{d\\vec{u}}{dt} = -aD\\vec{u}$。为了在不牺牲稳定性或精度的情况下施加边界条件，我们添加一个同步近似项 (SAT)。对于本问题，我们分析齐次边界条件下的稳定性，即规定的入流值为 $0$。\n\n算子 $\\mathcal{L}$ 被构造为 $\\mathcal{L} = -aD + P$，其中 $P$ 是罚算子。罚项以迎风方式施加在入流边界上。\n- 如果 $a > 0$，平流方向为正 $x$ 方向。由于我们的节点顺序是从 $x_0=1$ 到 $x_N=-1$，入流边界位于 $x = -1$，对应于节点 $j=N$。\n- 如果 $a < 0$，平流方向为负 $x$ 方向。入流边界位于 $x = 1$，对应于节点 $j=0$。\n\nSAT 惩罚的是入流节点处数值解与规定边界值（此处为 $0$）之间的偏差。ODE 方程组的罚项被构造为一个仅影响入流节点的秩一修正。根据规定，罚项强度 $s$ 按相应求积权重的倒数进行缩放。\n对于 $a > 0$（入流在 $j=N$）：添加到右侧的罚项是 $-s \\frac{1}{H_{NN}} u_N \\vec{e}_N$。算子为 $\\mathcal{L} = -aD - \\frac{s}{H_{NN}} E_{NN}$，其中 $E_{NN}$ 是一个在 $(N,N)$ 位置为 1、其余位置为 0 的矩阵，而 $\\vec{e}_N$ 是相应的标准基向量。\n对于 $a < 0$（入流在 $j=0$）：罚项是 $-s \\frac{1}{H_{00}} u_0 \\vec{e}_0$。算子为 $\\mathcal{L} = -aD - \\frac{s}{H_{00}} E_{00}$。\n\n**4. 能量法稳定性分析**\n半离散系统 $\\frac{d\\vec{u}}{dt} = \\mathcal{L}\\vec{u}$ 的稳定性通过考察离散能量 $\\|\\vec{u}\\|_H^2$ 的时间演化来评估：\n$$\n\\frac{d}{dt} \\|\\vec{u}\\|_H^2 = \\frac{d}{dt}(\\vec{u}^\\top H \\vec{u}) = \\dot{\\vec{u}}^\\top H \\vec{u} + \\vec{u}^\\top H \\dot{\\vec{u}}\n$$\n代入 $\\dot{\\vec{u}} = \\mathcal{L}\\vec{u}$：\n$$\n\\frac{d}{dt} \\|\\vec{u}\\|_H^2 = (\\mathcal{L}\\vec{u})^\\top H \\vec{u} + \\vec{u}^\\top H (\\mathcal{L}\\vec{u}) = \\vec{u}^\\top (\\mathcal{L}^\\top H + H \\mathcal{L}) \\vec{u} = \\vec{u}^\\top S \\vec{u}\n$$\n其中 $S = H\\mathcal{L} + \\mathcal{L}^\\top H$。如果能量不随时间增长，即对于任何状态 $\\vec{u}$ 都有 $\\frac{d}{dt}\\|\\vec{u}\\|_H^2 \\le 0$，则系统是稳定的。这等价于对称矩阵 $S$ 是半负定的，意味着其所有特征值都必须是非正的 ($\\lambda_k(S) \\le 0$)。\n\n我们现在推导 $S$。Chebyshev 微分矩阵 $D$ 和 CGL 求积矩阵 $H$ 的一个关键性质是离散分部求和公式：\n$$\nHD + D^\\top H = E_{00} - E_{NN}\n$$\n这个恒等式反映了分部积分在离散层面上的行为。\n\n我们来计算两种情况下的 $S$：\n情况 1: $a > 0$（入流在 $j=N$）。\n$\\mathcal{L} = -aD - \\frac{s}{H_{NN}} E_{NN}$。\n$$\nS = H\\left(-aD - \\frac{s}{H_{NN}} E_{NN}\\right) + \\left(-aD - \\frac{s}{H_{NN}} E_{NN}\\right)^\\top H\n$$\n$$\nS = -a(HD + D^\\top H) - \\frac{s}{H_{NN}}(H E_{NN} + E_{NN}^\\top H)\n$$\n由于 $H$ 是对角矩阵，所以 $H E_{NN} = H_{NN} E_{NN}$ 且 $E_{NN}^\\top H = H_{NN} E_{NN}$。\n$$\nS = -a(E_{00} - E_{NN}) - \\frac{s}{H_{NN}}(H_{NN} E_{NN} + H_{NN} E_{NN}) = -a E_{00} + a E_{NN} - 2s E_{NN}\n$$\n$$\nS = -a E_{00} + (a - 2s) E_{NN}\n$$\n矩阵 $S$ 是对角矩阵，其元素为 $S_{00} = -a$，$S_{NN} = a-2s$，所有其他对角元素均为 $0$。为使 $S$ 是半负定的，其所有对角元素都必须是非正的。由于 $a>0$，所以 $S_{00}=-a < 0$。我们需要 $a - 2s \\le 0$，这意味着 $s \\ge a/2$。\n\n情况 2: $a < 0$（入流在 $j=0$）。\n$\\mathcal{L} = -aD - \\frac{s}{H_{00}} E_{00}$。\n类似的推导得出：\n$$\nS = -a(E_{00} - E_{NN}) - \\frac{s}{H_{00}}(H E_{00} + E_{00}^\\top H) = -a E_{00} + a E_{NN} - 2s E_{00}\n$$\n$$\nS = (-a - 2s) E_{00} + a E_{NN}\n$$\n这是一个对角矩阵，其中 $S_{00} = -a - 2s$ 且 $S_{NN}=a$。由于 $a<0$，所以 $S_{NN}=a<0$。为满足半负定性，我们需要 $-a - 2s \\le 0$，这意味着 $2s \\ge -a$，或 $s \\ge -a/2 = |a|/2$。\n\n在这两种情况下，为保证稳定性，罚参数 $s$ 必须满足 $s \\ge |a|/2$。\n\n**5. 数值稳定性测试**\n数值实现将为每个测试用例 $(N, a, s)$ 构建矩阵 $D$、$H$ 和 $\\mathcal{L}$。然后，它将形成对称矩阵 $S = H\\mathcal{L} + \\mathcal{L}^\\top H$ 并计算其特征值。如果 $S$ 的最大特征值小于或等于一个小的容差（此处为 $10^{-10}$，以考虑浮点运算误差），则该格式被认为是稳定的。\n可以根据推导出的条件 $s \\ge |a|/2$ 来评估这些测试用例：\n- $(16, 1.0, 0.0)$: $0.0 \\ge 1.0/2 \\implies 0.0 \\ge 0.5$ (假，不稳定)。\n- $(16, 1.0, 0.5)$: $0.5 \\ge 1.0/2 \\implies 0.5 \\ge 0.5$ (真，稳定)。\n- $(16, 1.0, 1.0)$: $1.0 \\ge 1.0/2 \\implies 1.0 \\ge 0.5$ (真，稳定)。\n- $(16, 1.0, 4.0)$: $4.0 \\ge 1.0/2 \\implies 4.0 \\ge 0.5$ (真，稳定)。\n- $(16, -1.0, 0.5)$: $0.5 \\ge |-1.0|/2 \\implies 0.5 \\ge 0.5$ (真，稳定)。\n- $(32, 1.0, 2.0)$: $2.0 \\ge 1.0/2 \\implies 2.0 \\ge 0.5$ (真，稳定)。\n- $(32, -1.0, 2.0)$: $2.0 \\ge |-1.0|/2 \\implies 2.0 \\ge 0.5$ (真，稳定)。\n该实现应确认这些分析预测。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef chebyshev_diff_matrix(N):\n    \"\"\"\n    Constructs the Chebyshev collocation differentiation matrix on\n    Chebyshev-Gauss-Lobatto nodes.\n\n    Args:\n        N (int): The polynomial degree, resulting in N+1 nodes.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing:\n            - D (np.ndarray): The (N+1)x(N+1) differentiation matrix.\n            - x (np.ndarray): The (N+1) CGL nodes.\n    \"\"\"\n    if N == 0:\n        return np.array([[0.]]), np.array([1.])\n    \n    # CGL nodes\n    j = np.arange(N + 1)\n    x = np.cos(np.pi * j / N)\n\n    # c_j coefficients\n    c = np.ones(N + 1)\n    c[0] = 2.0\n    c[N] = 2.0\n\n    # Off-diagonal entries\n    # Use broadcasting to create matrices of x_i and x_j\n    X = np.tile(x, (N + 1, 1))\n    x_diff = X - X.T\n    \n    # Create matrix of (-1)^(i+j)\n    i = np.arange(N + 1)[:, np.newaxis]\n    j_row = np.arange(N + 1)[np.newaxis, :]\n    sign_matrix = (-1.0)**(i + j_row)\n\n    # Create matrix of c_i/c_j\n    c_ratio = np.outer(c, 1.0 / c)\n\n    D = c_ratio * sign_matrix / (x_diff + np.eye(N + 1)) # Add identity to avoid div by zero on diag\n    \n    # Diagonal entries\n    D[np.diag_indices_from(D)] = 0.0 # Clear diagonal before setting final values\n    \n    # Interior points\n    for j_diag in range(1, N):\n        D[j_diag, j_diag] = -x[j_diag] / (2.0 * (1.0 - x[j_diag]**2))\n        \n    # Endpoints\n    D[0, 0] = (2.0 * N**2 + 1.0) / 6.0\n    D[N, N] = -(2.0 * N**2 + 1.0) / 6.0\n\n    return D, x\n\ndef chebyshev_quadrature_matrix(N):\n    \"\"\"\n    Constructs the diagonal quadrature matrix H for CGL nodes.\n\n    Args:\n        N (int): The polynomial degree.\n\n    Returns:\n        np.ndarray: The (N+1)x(N+1) diagonal quadrature matrix H.\n    \"\"\"\n    if N == 0:\n        return np.array([[np.pi]])\n    c = np.ones(N + 1)\n    c[0] = 2.0\n    c[N] = 2.0\n    \n    weights = np.pi / (c * N)\n    H = np.diag(weights)\n    return H\n\ndef solve():\n    \"\"\"\n    Main function to perform stability analysis for the given test cases.\n    \"\"\"\n    test_cases = [\n        # (N, a, s)\n        (16, 1.0, 0.0),\n        (16, 1.0, 0.5),\n        (16, 1.0, 1.0),\n        (16, 1.0, 4.0),\n        (16, -1.0, 0.5),\n        (32, 1.0, 2.0),\n        (32, -1.0, 2.0),\n    ]\n\n    results = []\n    stability_tolerance = 1e-10\n\n    for N, a, s in test_cases:\n        # Step 1  2: Get differentiation matrix and nodes\n        D, x = chebyshev_diff_matrix(N)\n        \n        # Step 3: Get quadrature matrix\n        H = chebyshev_quadrature_matrix(N)\n        \n        # Step 4: Form the semi-discrete operator L\n        # The base operator is -a*D\n        L = -a * D\n        \n        # Add the upwind SAT penalty term\n        if a  0:\n            # Inflow is at x = -1, which is node N in our ordering x_j=cos(pi*j/N)\n            inflow_idx = N\n            H_inflow = H[inflow_idx, inflow_idx]\n            P = np.zeros((N + 1, N + 1))\n            P[inflow_idx, inflow_idx] = -s / H_inflow\n            L += P\n        elif a  0:\n            # Inflow is at x = 1, which is node 0\n            inflow_idx = 0\n            H_inflow = H[inflow_idx, inflow_idx]\n            P = np.zeros((N + 1, N + 1))\n            P[inflow_idx, inflow_idx] = -s / H_inflow\n            L += P\n        # If a = 0, there is no flow, and L is the zero matrix, which is stable.\n        # This case is not in the test suite.\n\n        # Step 5: Form the symmetric part S\n        S = H @ L + L.T @ H\n\n        # Step 6: Check stability by computing the largest eigenvalue of S\n        # Since S is symmetric, all eigenvalues are real.\n        eigenvalues = np.linalg.eigvalsh(S)\n        max_eigenvalue = np.max(eigenvalues)\n\n        is_stable = max_eigenvalue = stability_tolerance\n        results.append(is_stable)\n\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```", "id": "3179536"}]}