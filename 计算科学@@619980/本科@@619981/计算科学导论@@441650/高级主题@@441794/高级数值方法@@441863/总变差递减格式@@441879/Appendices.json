{"hands_on_practices": [{"introduction": "在数值求解守恒律，特别是那些包含尖锐梯度或间断的守恒律时，许多数值格式会引入虚假的、非物理的振荡。总变差递减（TVD）格式正是为解决这一问题而设计的，它能确保解的总“摆动性”不会随时间增加。本实践练习将指导你实现并比较三种基本方法——会产生振荡的 Lax–Wendroff 格式、稳健的一阶 Godunov 格式，以及先进的高分辨率 MUSCL 格式——让你亲眼见证它们在处理具有挑战性的方波初值时的不同表现 [@problem_id:3200760]。", "problem": "考虑一维标量守恒律 $u_t + f(u)_x = 0$，定义在周期性域 $x \\in [0,1)$ 上，其中平流通量为常数 $f(u) = a\\,u$，$a > 0$ 为常数。设离散解定义在一个包含 $N_x$ 个单元的均匀网格上，使用周期性边界条件，并令 $u_i^n$ 表示在单元索引 $i$ 和时间层 $n$ 的单元平均近似值。时间层 $n$ 的离散总变差定义为\n$$\nTV(u^n) = \\sum_{i=0}^{N_x-1} \\left| u_{i+1}^n - u_i^n \\right|,\n$$\n其中索引是周期性的，即 $u_{N_x}^n \\equiv u_0^n$。如果一个格式在适当的 Courant–Friedrichs–Lewy (CFL) 条件下对所有 $n$ 都满足 $TV(u^{n+1}) \\le TV(u^n)$，则称其为总变差递减（TVD）格式。\n\n您的任务是为 $a = 1$ 的具体情况，实现并比较三种有限体积时间推进格式：\n- Lax–Wendroff 格式，\n- 针对正速度标量平流的 Godunov 迎风格式，\n- Monotonic Upstream-centered Scheme for Conservation Laws (MUSCL) 格式，使用经典通量限制器形式的 minmod 限制器，当 Courant 数在 $[0,1]$ 区间内时，该格式满足 Sweby 对标量平流的 TVD 约束。\n\n从守恒的基本原理出发，即在均匀网格上，更新由守恒通量差分离散化给出，并定义 Courant 数为 $\\nu = a\\,\\Delta t / \\Delta x$。在整个过程中使用周期性边界条件。\n\n初始数据：构建方波脉冲\n$$\nu(x,0) = \\begin{cases}\n1,  x \\in [0.3, 0.7),\\\\\n0,  \\text{其他},\n\\end{cases}\n$$\n在单元中心采样。取计算域为 $[0,1)$，包含 $N_x$ 个均匀单元，单元宽度 $\\Delta x = 1/N_x$，单元中心 $x_i = (i+1/2)\\Delta x$，时间步长 $\\Delta t = \\nu\\,\\Delta x / a$，其中 $a=1$。\n\n对于下面的每个格式和每个测试案例，使用固定的 $\\Delta t$ 在时间上推进数值解，步数足以使模拟时间至少达到指定的结束时间 $T_{\\text{end}}$。在每个时间层 $n$（包括 $n=0$），计算 $TV(u^n)$ 并评估总变差是否随时间非增，即对于所有执行的步骤 $n$，是否有 $TV(u^{n+1}) \\le TV(u^{n})$ 成立，数值容差为 $\\varepsilon = 10^{-10}$ 以考虑浮点舍入。\n\n测试套件（每个元组为 $(N_x,\\ \\nu,\\ T_{\\text{end}})$）：\n- 案例 A: $(200,\\ 0.5,\\ 0.25)$，\n- 案例 B: $(40,\\ 0.9,\\ 0.35)$，\n- 案例 C: $(160,\\ 0.2,\\ 0.50)$。\n\n预测要求：基于标量守恒律中单调性和总变差递减格式的原理，合理解释这三种格式中哪种能保持数值解的单调性，从而在这些测试中产生非增的 $TV(u^n)$，哪种不能。您实现的程序必须通过检查 $TV(u^n)$ 序列的单调性来数值验证这些预测。\n\n最终输出要求：您的程序必须生成单行输出，其中包含一个逗号分隔的九个布尔值列表，并用方括号括起来，顺序如下\n$$\n[\\text{LW}_A,\\ \\text{GOD}_A,\\ \\text{MUSCL}_A,\\ \\text{LW}_B,\\ \\text{GOD}_B,\\ \\text{MUSCL}_B,\\ \\text{LW}_C,\\ \\text{GOD}_C,\\ \\text{MUSCL}_C],\n$$\n其中，如果 $TV(u^n)$ 对相应的格式和案例是（在容差 $\\varepsilon$ 内）非增的，则每个条目为 $True$，否则为 $False$。打印的列表中不允许有空格。所有量都是无量纲的；不需要物理单位。此问题中不出现角度，因此不需要角度单位。要求的输出类型是布尔值列表。", "solution": "问题陈述已经过严格验证，被认为是有效的。它在科学上基于双曲守恒律的数值方法理论，问题设定良好，具有完整且一致的定义和参数集，并以客观、正式的语言表述。任务是实现并分析三种标准的有限体积格式，这在计算科学中是一项可行且有意义的练习。\n\n目标是求解一维线性平流方程 $u_t + a u_x = 0$（其中 $a=1$），定义在周期性域 $x \\in [0,1)$ 上。在时间层 $n$，单元 $i$ 中的单元平均量 $u_i^n$ 的更新由守恒有限体积公式给出：\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2}^n - F_{i-1/2}^n \\right)\n$$\n其中 $F_{i+1/2}^n$ 是单元 $i$ 和 $i+1$ 之间界面的数值通量，$\\Delta x$ 是单元宽度，$\\Delta t$ 是时间步长。Courant 数定义为 $\\nu = a \\frac{\\Delta t}{\\Delta x}$。当 $a=1$ 时，这简化为 $\\nu = \\frac{\\Delta t}{\\Delta x}$。我们将分析总变差递减（TVD）性质，该性质要求总变差 $TV(u^n) = \\sum_{i=0}^{N_x-1} |u_{i+1}^n - u_i^n|$ 对所有时间步 $n$ 都是非增的。\n\n**格式行为预测**\n\n基于双曲守恒律有限体积方法的既定理论，我们可以预测每种格式在 TVD 性质方面的行为。\n\n1.  **Lax–Wendroff 格式**：这是一个在时间和空间上均为二阶精度的格式。虽然其较高的精度对于光滑解是理想的，但它是一种线性格式，众所周知不保持单调性。在不连续点或陡峭梯度附近，它会引入虚假的、非物理的振荡（Gibbs 现象），这会局部地产生新的极值。新极值的产生必然会增加总变差。因此，Lax-Wendroff 格式不是 TVD 的。我们预测它将在所有测试案例中都无法通过 TVD 检查。\n\n2.  **Godunov 迎风格式**：对于具有正速度 $a>0$ 的线性平流方程，Godunov 方法简化为一阶迎风格式。Harten 的一个关键定理指出，任何单调格式都是 TVD 的。在 Courant–Friedrichs–Lewy (CFL) 条件 $0 \\le \\nu \\le 1$ 下，一阶迎风格式是单调的。由于所有测试案例使用的 $\\nu$ 都在此范围内，我们预测 Godunov 格式对于所有测试案例都将是 TVD 的。\n\n3.  **带 Minmod 限制器的 MUSCL 格式**：守恒律的单调上游中心格式 (Monotonic Upstream-centered Scheme for Conservation Laws, MUSCL) 是一种高分辨率格式，旨在光滑区域实现更高阶的精度，同时防止在不连续点产生振荡，从而满足 TVD 性质。这是通过使用非线性的“限制器”函数实现的。minmod 限制器是保证格式为 TVD 的最基本的限制器之一。只要满足 CFL 条件 $0 \\le \\nu \\le 1$，该格式就被证明是 TVD 的。因此我们预测，MUSCL 实现将通过所有测试案例的 TVD 检查。\n\n**数值格式的数学公式**\n\n初始条件是一个方波脉冲：\n$$\nu(x,0) = \\begin{cases}\n1,  x \\in [0.3, 0.7) \\\\\n0,  \\text{其他}\n\\end{cases}\n$$\n单元平均近似值 $u_i^0$ 是通过在单元中心 $x_i = (i+1/2)\\Delta x$（对于 $i=0, 1, \\dots, N_x-1$）对该函数进行采样得到的。对于所有格式，都强制实施周期性边界条件，这意味着索引是循环处理的（例如，$u_{-1}^n = u_{N_x-1}^n$ 和 $u_{N_x}^n = u_0^n$）。对于 $a=1$ 的具体情况，通量为 $f(u)=u$。\n\n1.  **Lax–Wendroff 格式**：Lax-Wendroff 格式的数值通量由时间上的二阶泰勒级数展开推导而来。对于线性平流，这得到：\n    $$\n    F_{i+1/2}^{LW} = \\frac{1}{2}a\\left(u_i^n + u_{i+1}^n\\right) - \\frac{1}{2}\\frac{a^2 \\Delta t}{\\Delta x}\\left(u_{i+1}^n - u_i^n\\right) = \\frac{1}{2}a\\left(u_i^n + u_{i+1}^n\\right) - \\frac{1}{2}a\\nu\\left(u_{i+1}^n - u_i^n\\right)\n    $$\n\n2.  **Godunov 迎风格式**：对于正的平流速度 $a>0$，界面 $x_{i+1/2}$ 处的特征信息来自“迎风”方向，即单元 $i$。界面处的黎曼问题具有常数解 $u_i^n$。因此，通量就是迎风状态的通量：\n    $$\n    F_{i+1/2}^{GOD} = f(u_i^n) = a u_i^n\n    $$\n\n3.  **带 Minmod 限制器的 MUSCL 格式**：该格式通过首先在每个单元中重构数据的分段线性表示来增强 Godunov 方法，然后用此表示来寻找界面处的状态。对于 $a>0$ 的迎风偏置格式， $x_{i+1/2}$ 处的通量取决于界面左侧的重构状态 $u_{L, i+1/2}$。该状态是通过将单元 $i$ 内的重构线性廓线演化半个时间步得到的。公式为：\n    $$\n    F_{i+1/2}^{MUSCL} = a \\, u_{L, i+1/2}^n\n    $$\n    其中界面状态由下式给出\n    $$\n    u_{L, i+1/2}^n = u_i^n + \\frac{1}{2}(1-\\nu) \\sigma_i^n\n    $$\n    项 $\\sigma_i^n$ 是单元 $i$ 内的受限斜率。对于 minmod 限制器，该斜率被选为后向和前向差分斜率中幅度较小的一个，如果它们符号相反则为零：\n    $$\n    \\sigma_i^n = \\text{minmod}(u_i^n - u_{i-1}^n, u_{i+1}^n - u_i^n)\n    $$\n    minmod 函数定义为：\n    $$\n    \\text{minmod}(x, y) = \\begin{cases}\n    x  \\text{若 } |x|  |y| \\text{ 且 } xy > 0 \\\\\n    y  \\text{若 } |y| \\le |x| \\text{ 且 } xy > 0 \\\\\n    0  \\text{若 } xy \\le 0\n    \\end{cases}\n    $$\n这种构造确保不会产生新的局部极值，这是格式成为 TVD 的条件。\n\n**数值验证**\n\n该实现将针对三种格式中的每一种以及每个测试案例 $(N_x, \\nu, T_{\\text{end}})$ 模拟方波脉冲的平流。在每个时间步，包括初始状态 $n=0$ 时，计算总变差 $TV(u^n)$。然后检查 $TV$ 值的序列是否非增，即对所有步骤 $n$，是否有 $TV(u^{n+1}) \\le TV(u^n) + \\varepsilon$ 成立，其中 $\\varepsilon = 10^{-10}$ 是浮点算术误差的容差。将报告对九种组合中每一种的检查的布尔结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares Lax-Wendroff, Godunov, and MUSCL schemes for the 1D\n    linear advection equation, checking their Total Variation Diminishing (TVD) property.\n    \"\"\"\n    \n    # Define the test cases from the problem statement: (Nx, nu, T_end)\n    test_cases = [\n        (200, 0.5, 0.25),  # Case A\n        (40, 0.9, 0.35),   # Case B\n        (160, 0.2, 0.50),  # Case C\n    ]\n    \n    # Define problem constants\n    a = 1.0  # Advection speed\n    epsilon = 1e-10  # Numerical tolerance for TVD check\n\n    results = []\n\n    def initialize_u(Nx):\n        \"\"\"Constructs the initial square pulse on a grid of size Nx.\"\"\"\n        x = (np.arange(Nx) + 0.5) / Nx\n        u0 = np.where((x >= 0.3)  (x  0.7), 1.0, 0.0)\n        return u0\n\n    def compute_tv(u):\n        \"\"\"Computes the total variation of a periodic array u.\"\"\"\n        u_plus_1 = np.roll(u, -1)\n        return np.sum(np.abs(u_plus_1 - u))\n\n    def minmod(x, y):\n        \"\"\"Vectorized minmod limiter function.\"\"\"\n        return (np.sign(x) + np.sign(y)) / 2.0 * np.minimum(np.abs(x), np.abs(y))\n\n    def run_simulation(scheme, u0, Nx, nu, T_end):\n        \"\"\"\n        Runs a simulation for a given scheme and returns if it's TVD.\n        \n        Args:\n            scheme (str): 'lw', 'godunov', or 'muscl'\n            u0 (np.ndarray): Initial condition array.\n            Nx (int): Number of grid points.\n            nu (float): Courant number.\n            T_end (float): End time of the simulation.\n\n        Returns:\n            bool: True if the scheme is TVD for this run, False otherwise.\n        \"\"\"\n        dx = 1.0 / Nx\n        dt = nu * dx / a\n        num_steps = int(np.ceil(T_end / dt))\n        \n        u = u0.copy()\n        tv_history = [compute_tv(u)]\n\n        for _ in range(num_steps):\n            u_im1 = np.roll(u, 1)  # u_{i-1} for all i\n            u_ip1 = np.roll(u, -1) # u_{i+1} for all i\n            \n            if scheme == 'lw':\n                # Lax-Wendroff flux\n                flux = 0.5 * a * (u + u_ip1) - 0.5 * a * nu * (u_ip1 - u)\n            elif scheme == 'godunov':\n                # Godunov (upwind for a>0) flux\n                flux = a * u\n            elif scheme == 'muscl':\n                # MUSCL with minmod limiter\n                slope_bwd = u - u_im1\n                slope_fwd = u_ip1 - u\n                limited_slope = minmod(slope_bwd, slope_fwd)\n                u_L = u + 0.5 * (1.0 - nu) * limited_slope\n                flux = a * u_L\n            else:\n                raise ValueError(\"Unknown scheme\")\n\n            flux_im1 = np.roll(flux, 1)\n            u = u - (dt / dx) * (flux - flux_im1)\n            tv_history.append(compute_tv(u))\n\n        # Check if total variation is non-increasing\n        is_tvd = all(tv_history[i] >= tv_history[i+1] - epsilon for i in range(len(tv_history) - 1))\n        return is_tvd\n\n    for Nx, nu, T_end in test_cases:\n        u0 = initialize_u(Nx)\n        \n        # Run Lax-Wendroff\n        results.append(run_simulation('lw', u0, Nx, nu, T_end))\n        \n        # Run Godunov\n        results.append(run_simulation('godunov', u0, Nx, nu, T_end))\n        \n        # Run MUSCL\n        results.append(run_simulation('muscl', u0, Nx, nu, T_end))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3200760"}, {"introduction": "一个完全稳健的 TVD 模拟需要仔细考虑空间离散和时间积分两个方面。即使你的空间算子是 TVD 的，一个不恰当的时间积分方法也可能重新引入振荡，破坏你努力保持的性质。本实践探讨了解决方案：强稳定保持（SSP）Runge-Kutta 时间积分方法，这类方法被精心构造成能在其每个内插步都维持 TVD 性质。你将实现并验证这一关键的逐阶段（stagewise）保持行为，从而巩固你对如何构建一个完整且稳定的 TVD 格式的理解 [@problem_id:3200714]。", "problem": "要求您研究一维线性平流方程的强稳定性保持龙格-库塔 (SSP-RK) 时间积分器的总变差递减 (TVD) 行为，从第一性原理和核心定义出发。\n\n考虑线性平流方程\n$$\nu_t + a\\,u_x = 0,\n$$\n其中平流速度 $a>0$ 为常数，定义在周期性域 $x \\in [0,1)$ 上。使用包含 $N$ 个点的均匀网格对空间进行离散化，网格间距为 $\\Delta x = 1/N$，并采用周期性环绕索引。使用适用于 $a>0$ 的经典上风半离散化：\n$$\n\\left(L(u)\\right)_i = -a\\,\\frac{u_i - u_{i-1}}{\\Delta x},\n$$\n其中 $i$ 是网格索引，在左边界对 $i-1$ 应用周期性环绕。\n\n将网格函数 $u$ 的离散总变差定义为\n$$\nTV(u) = \\sum_{i=0}^{N-1} \\left| u_{i+1} - u_i \\right|,\n$$\n其中周期性环绕满足 $u_N \\equiv u_0$。\n\n使用以下每个时间积分器，对大小为 $\\Delta t$ 的一个完整时间步进行积分：\n- 2 阶强稳定性保持龙格-库塔 (SSP-RK2)：\n  阶段 1：$u^{(1)} = u^n + \\Delta t\\,L(u^n)$。\n  阶段 2 (最终)：$u^{n+1} = \\tfrac{1}{2}\\,u^n + \\tfrac{1}{2}\\,\\big(u^{(1)} + \\Delta t\\,L(u^{(1)})\\big)$。\n- 3 阶强稳定性保持龙格-库塔 (SSP-RK3)：\n  阶段 1：$u^{(1)} = u^n + \\Delta t\\,L(u^n)$。\n  阶段 2：$u^{(2)} = \\tfrac{3}{4}\\,u^n + \\tfrac{1}{4}\\,\\big(u^{(1)} + \\Delta t\\,L(u^{(1)})\\big)$。\n  阶段 3 (最终)：$u^{n+1} = \\tfrac{1}{3}\\,u^n + \\tfrac{2}{3}\\,\\big(u^{(2)} + \\Delta t\\,L(u^{(2)})\\big)$。\n\n使用库朗数 (也称为无量纲时间步长或 Courant–Friedrichs–Lewy 数)\n$$\n\\lambda = \\frac{a\\,\\Delta t}{\\Delta x}.\n$$\n\n您的程序必须执行以下操作：\n1. 固定 $N=400$ 个网格点和 $a=1$ (无量纲)。因此 $\\Delta x = 1/N$。对于给定的 $\\lambda$，设置 $\\Delta t = \\lambda\\,\\Delta x/a$。\n2. 使用通过周期性环绕索引移位实现的周期性边界条件。\n3. 在网格 $x_i = i\\,\\Delta x$ (对于 $i=0,\\dots,N-1$) 上实现两个初始条件 $u^n$：\n   - 不连续的方帽函数：当 $x \\in [0.25,0.75)$ 时 $u(x)=1$，否则 $u(x)=0$。\n   - 光滑的正弦波：$u(x) = \\sin(2\\pi x)$。\n4. 对于每个时间积分器 (SSP-RK2 和 SSP-RK3)，以及对于每个 $\\lambda \\in \\{0.8, 1.0, 1.2\\}$，从 $u^n$ 精确推进一个时间步，并记录每个中间阶段和最终状态 $u^{n+1}$ 后的离散总变差。\n5. 对于每次运行，评估逻辑条件\n   $$\n   TV\\big(u^{(\\text{stage})}\\big) \\le TV(u^n) \\quad \\text{对于每个阶段，包括最终状态}。\n   $$\n   为使其在数值上稳健，使用容差 $\\varepsilon=10^{-12}$，并将该条件解释为对于所有阶段 $TV\\big(u^{(\\text{stage})}\\big) \\le TV(u^n) + \\varepsilon$。\n6. 测试套件包括以下所有组合：\n   - 初始条件，顺序为：方帽函数，正弦波。\n   - 时间积分器，顺序为：SSP-RK2, SSP-RK3。\n   - 库朗数，顺序为：$\\lambda=0.8$，然后是 $\\lambda=1.0$，再然后是 $\\lambda=1.2$。\n   这会产生总共 $12$ 次运行。\n7. 对于 $12$ 次运行中的每一次，输出一个布尔值，指示上述分阶段 TV 有界性条件是否成立。\n8. 最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。该列表必须完全包含 $12$ 个布尔值，顺序如第 6 项所述。例如，一个有效的输出格式是\n   $$\n   [\\text{True},\\text{False},\\dots,\\text{True}],\n   $$\n   但需要有正好 $12$ 个布尔值条目，并且不需要空格。\n\n基本依据和目标：\n- 从线性平流方程定义、适用于 $a0$ 的上风空间半离散化以及离散总变差的定义出发。不要假定任何 TVD 属性；您必须从这些定义出发进行推理。\n- 您的解决方案必须使用这些基础知识解释，为什么某些 $\\lambda$ 值能确保对于应用于上风算子的前向欧拉步，$TV(u^{n+1}) \\le TV(u^n)$ 成立，以及 SSP-RK2 和 SSP-RK3 的各个阶段如何继承这种有界性。\n- 您的程序必须实现算法，以对测试套件进行数值验证。\n\n不涉及物理单位。角度（若有）以弧度为单位，但此处不需要角度计算。所有数值必须视为无量纲。最终答案必须是上述描述的布尔值，并以所要求的格式精确打印。", "solution": "问题的核心在于理解为什么某些用于双曲型偏微分方程的数值格式是“总变差递减” (TVD) 的。TVD 格式确保解的总变差不会随时间增加。此属性保证了数值解不会产生伪振荡，这是在此类问题中常见的现象。本问题研究强稳定性保持 (SSP) 方法的这一属性。它们所保持的“强稳定性”正是在合适的 Courant-Friedrichs-Lewy (CFL) 条件下，简单的前向欧拉时间步所具有的这类非线性稳定性属性（如 TVD）。\n\n首先，我们分析应用于半离散化的前向欧拉时间步。半离散方程为 $\\frac{du_i}{dt} = L(u)_i$。从 $u^n$ 开始的单步前向欧拉法由下式给出：\n$$\nu_i^{n+1} = u_i^n + \\Delta t L(u^n)_i\n$$\n代入给定的上风算子 $L(u)_i = -a \\frac{u_i - u_{i-1}}{\\Delta x}$ (对于 $a>0$)：\n$$\nu_i^{n+1} = u_i^n - \\Delta t \\left( a \\frac{u_i^n - u_{i-1}^n}{\\Delta x} \\right)\n$$\n使用库朗数定义 $\\lambda = \\frac{a \\Delta t}{\\Delta x}$，上式简化为：\n$$\nu_i^{n+1} = u_i^n - \\lambda (u_i^n - u_{i-1}^n) = (1 - \\lambda) u_i^n + \\lambda u_{i-1}^n\n$$\n此方程表明，新值 $u_i^{n+1}$ 是其旧值 $u_i^n$ 及其上风邻居 $u_{i-1}^n$ 的线性组合。为使此格式为 TVD，更新必须是凸组合，这要求系数为非负且总和为 1。系数之和为 $(1-\\lambda) + \\lambda = 1$。非负性约束要求 $1-\\lambda \\ge 0$ 和 $\\lambda \\ge 0$。由于 $a, \\Delta t, \\Delta x$ 均为正，$\\lambda \\ge 0$ 总是成立。关键条件是 $\\lambda \\le 1$。\n\n如果 $0 \\le \\lambda \\le 1$，前向欧拉步是一个凸组合，已知这是 TVD 的。让我们从总变差的定义来证明这一点：\n$$\n\\begin{align*}\nu_{i+1}^{n+1} - u_i^{n+1} = \\left( (1-\\lambda) u_{i+1}^n + \\lambda u_{i}^n \\right) - \\left( (1-\\lambda) u_i^n + \\lambda u_{i-1}^n \\right) \\\\\n= (1-\\lambda) (u_{i+1}^n - u_i^n) + \\lambda (u_i^n - u_{i-1}^n)\n\\end{align*}\n$$\n取绝对值并在所有网格点 $i$ 上求和：\n$$\n\\begin{align*}\nTV(u^{n+1}) = \\sum_i |u_{i+1}^{n+1} - u_i^{n+1}| = \\sum_i |(1-\\lambda) (u_{i+1}^n - u_i^n) + \\lambda (u_i^n - u_{i-1}^n)| \\\\\n\\le \\sum_i \\left( |1-\\lambda| |u_{i+1}^n - u_i^n| + |\\lambda| |u_i^n - u_{i-1}^n| \\right)\n\\end{align*}\n$$\n由于 $0 \\le \\lambda \\le 1$，我们有 $|1-\\lambda| = 1-\\lambda$ 和 $|\\lambda| = \\lambda$。\n$$\nTV(u^{n+1}) \\le (1-\\lambda) \\sum_i |u_{i+1}^n - u_i^n| + \\lambda \\sum_i |u_i^n - u_{i-1}^n|\n$$\n由于是周期性域，$\\sum_i |u_i^n - u_{i-1}^n| = \\sum_j |u_{j+1}^n - u_j^n| = TV(u^n)$。因此：\n$$\nTV(u^{n+1}) \\le (1-\\lambda) TV(u^n) + \\lambda TV(u^n) = TV(u^n)\n$$\n这证明了前向欧拉步与一阶上风格式的组合是 TVD 的，当且仅当满足 CFL 条件 $0 \\le \\lambda \\le 1$ 时。\n\n现在，考虑 SSP 龙格-库塔格式。它们的构造方式使其可以表示为前向欧拉步的凸组合。令 $\\mathcal{F}_{FE}(u) = u + \\Delta t L(u)$ 表示前向欧拉算子。我们刚刚建立的 TVD 属性是在条件 $\\lambda \\le 1$ 下，$TV(\\mathcal{F}_{FE}(u)) \\le TV(u)$。\nSSP-RK2 格式为：\n$$\n\\begin{align*}\nu^{(1)} = u^n + \\Delta t L(u^n) = \\mathcal{F}_{FE}(u^n) \\\\\nu^{n+1} = \\tfrac{1}{2}u^n + \\tfrac{1}{2}\\big(u^{(1)} + \\Delta t L(u^{(1)})\\big) = \\tfrac{1}{2}u^n + \\tfrac{1}{2}\\mathcal{F}_{FE}(u^{(1)})\n\\end{align*}\n$$\nSSP-RK3 格式为：\n$$\n\\begin{align*}\nu^{(1)} = u^n + \\Delta t L(u^n) = \\mathcal{F}_{FE}(u^n) \\\\\nu^{(2)} = \\tfrac{3}{4}u^n + \\tfrac{1}{4}\\big(u^{(1)} + \\Delta t L(u^{(1)})\\big) = \\tfrac{3}{4}u^n + \\tfrac{1}{4}\\mathcal{F}_{FE}(u^{(1)}) \\\\\nu^{n+1} = \\tfrac{1}{3}u^n + \\tfrac{2}{3}\\big(u^{(2)} + \\Delta t L(u^{(2)})\\big) = \\tfrac{1}{3}u^n + \\tfrac{2}{3}\\mathcal{F}_{FE}(u^{(2)})\n\\end{align*}\n$$\n每个阶段都是先前结果的凸组合。总变差半范数 $TV(\\cdot)$ 本身是凸的，即对于 $\\alpha \\in [0,1]$，$TV(\\alpha u + (1-\\alpha)v) \\le \\alpha TV(u) + (1-\\alpha)TV(v)$。我们可以分阶段地应用此属性。假设 $\\lambda \\le 1$。\n\n对于 SSP-RK2：\n- 阶段 1：$TV(u^{(1)}) = TV(\\mathcal{F}_{FE}(u^n)) \\le TV(u^n)$。\n- 阶段 2：$TV(u^{n+1}) \\le \\tfrac{1}{2}TV(u^n) + \\tfrac{1}{2}TV(\\mathcal{F}_{FE}(u^{(1)}))$。由于 $\\mathcal{F}_{FE}$ 是 TVD 的，$TV(\\mathcal{F}_{FE}(u^{(1)})) \\le TV(u^{(1)})$。结合阶段 1 的结果，$TV(u^{n+1}) \\le \\tfrac{1}{2}TV(u^n) + \\tfrac{1}{2}TV(u^{(1)}) \\le \\tfrac{1}{2}TV(u^n) + \\tfrac{1}{2}TV(u^n) = TV(u^n)$。\n\n对于 SSP-RK3：\n- 阶段 1：$TV(u^{(1)}) = TV(\\mathcal{F}_{FE}(u^n)) \\le TV(u^n)$。\n- 阶段 2：$TV(u^{(2)}) \\le \\tfrac{3}{4}TV(u^n) + \\tfrac{1}{4}TV(\\mathcal{F}_{FE}(u^{(1)})) \\le \\tfrac{3}{4}TV(u^n) + \\tfrac{1}{4}TV(u^{(1)}) \\le \\tfrac{3}{4}TV(u^n) + \\tfrac{1}{4}TV(u^n) = TV(u^n)$。\n- 阶段 3：$TV(u^{n+1}) \\le \\tfrac{1}{3}TV(u^n) + \\tfrac{2}{3}TV(\\mathcal{F}_{FE}(u^{(2)})) \\le \\tfrac{1}{3}TV(u^n) + \\tfrac{2}{3}TV(u^{(2)}) \\le \\tfrac{1}{3}TV(u^n) + \\tfrac{2}{3}TV(u^n) = TV(u^n)$。\n\n此分析证明，对于 SSP-RK2 和 SSP-RK3，只要其基础的前向欧拉步是 TVD 的，即要求 $\\lambda = a \\Delta t/\\Delta x \\le 1$，那么每个阶段都是 TVD 的。如果 $\\lambda > 1$，前向欧拉步不是凸组合，不保证是 TVD 的，因此我们预期总变差会增加。\n\n因此，对于数值实验：\n- 对于 $\\lambda = 0.8$ 和 $\\lambda = 1.0$，条件 $\\lambda \\le 1$ 成立。我们预期分阶段 TVD 属性会得到满足，结果为 `True`。\n- 对于 $\\lambda = 1.2$，条件 $\\lambda \\le 1$ 被违反。我们预期总变差至少在一个阶段会增加，结果为 `False`。\n\n下面的程序实现了这些格式，并验证了这一理论预测。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Investigates the Total Variation Diminishing (TVD) property of SSP-RK\n    methods for the 1D linear advection equation.\n    \"\"\"\n    # Define the parameters from the problem statement.\n    N = 400\n    a = 1.0\n    dx = 1.0 / N\n    epsilon = 1e-12\n    x_grid = np.arange(N) * dx\n\n    # Define initial condition functions.\n    def ic_top_hat(x):\n        \"\"\"Discontinuous top-hat function.\"\"\"\n        u = np.zeros_like(x)\n        u[(x >= 0.25)  (x  0.75)] = 1.0\n        return u\n\n    def ic_sine(x):\n        \"\"\"Smooth sine wave function.\"\"\"\n        return np.sin(2 * np.pi * x)\n\n    # Define the spatial operator L(u) using first-order upwind scheme.\n    def L(u, speed, delta_x):\n        \"\"\"\n        Calculates the semi-discretization L(u) for u_t = L(u).\n        Uses periodic boundary conditions via np.roll for the u_{i-1} term.\n        \"\"\"\n        return -speed * (u - np.roll(u, 1)) / delta_x\n\n    # Define the discrete Total Variation (TV).\n    def TV(u):\n        \"\"\"\n        Calculates the total variation of a grid function u.\n        Uses periodic boundary conditions via np.roll for the u_{i+1} term.\n        \"\"\"\n        return np.sum(np.abs(np.roll(u, -1) - u))\n\n    # Define time integration functions that return the TVD check result.\n    def check_ssp_rk2(u_n, courant_lambda, speed, delta_x):\n        \"\"\"\n        Performs one time step with SSP-RK2 and checks the stagewise TVD property.\n        \"\"\"\n        dt = courant_lambda * delta_x / speed\n        tv_n = TV(u_n)\n\n        # Stage 1\n        u_1 = u_n + dt * L(u_n, speed, delta_x)\n        if TV(u_1) > tv_n + epsilon:\n            return False\n\n        # Stage 2 (final)\n        u_n_plus_1 = 0.5 * u_n + 0.5 * (u_1 + dt * L(u_1, speed, delta_x))\n        if TV(u_n_plus_1) > tv_n + epsilon:\n            return False\n        \n        return True\n\n    def check_ssp_rk3(u_n, courant_lambda, speed, delta_x):\n        \"\"\"\n        Performs one time step with SSP-RK3 and checks the stagewise TVD property.\n        \"\"\"\n        dt = courant_lambda * delta_x / speed\n        tv_n = TV(u_n)\n\n        # Stage 1\n        u_1 = u_n + dt * L(u_n, speed, delta_x)\n        if TV(u_1) > tv_n + epsilon:\n            return False\n\n        # Stage 2\n        u_2 = 0.75 * u_n + 0.25 * (u_1 + dt * L(u_1, speed, delta_x))\n        if TV(u_2) > tv_n + epsilon:\n            return False\n\n        # Stage 3 (final)\n        u_n_plus_1 = (1.0/3.0) * u_n + (2.0/3.0) * (u_2 + dt * L(u_2, speed, delta_x))\n        if TV(u_n_plus_1) > tv_n + epsilon:\n            return False\n\n        return True\n\n    # Define the test suite.\n    initial_conditions = [ic_top_hat, ic_sine]\n    time_integrators = [check_ssp_rk2, check_ssp_rk3]\n    lambdas = [0.8, 1.0, 1.2]\n    \n    results = []\n\n    # Iterate through the test suite in the specified order.\n    for ic_func in initial_conditions:\n        for rk_func in time_integrators:\n            for lam in lambdas:\n                u_initial = ic_func(x_grid)\n                result = rk_func(u_initial, lam, a, dx)\n                results.append(result)\n\n    # Format the final output as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3200714"}]}