{"hands_on_practices": [{"introduction": "在分子动力学中，速度 Verlet 算法和蛙跳算法（Leapfrog）是两种最常用且极其重要的积分器。虽然它们的公式在形式上略有不同——一个使用与位置在同一时间网格上的速度，另一个使用交错时间网格上的速度——但它们在数学上是等价的。本实践旨在通过亲手实现这两种算法来加深对这一点的理解 [@problem_id:3144527]，你将验证在精确计算下它们的轨迹是相同的，同时观察到浮点运算带来的微小差异，从而对这些核心算法的内在联系和计算实现细节有更深入的认识。", "problem": "考虑一个一维链，由 $N$ 个相同的质点通过线性弹簧连接而成，两端采用固定的（狄利克雷）边界条件。质量均为单位质量，弹簧刚度也为单位刚度，因此所有量纲均为无量纲。设 $x_i(t)$ 表示质量点 $i$ 在时间 $t$ 相对于其平衡位置的位移，其中 $i \\in \\{1,2,\\dots,N\\}$。假设链的端点被固定在零位移处，因此 $x_1$ 和 $x_N$ 在链外的邻居固定为 $0$。从牛顿第二定律和加速度的定义出发，推导该链的控制二阶常微分方程。然后，根据基本的时间离散化原理（泰勒展开和中心差分），推导出这些方程的两个积分器：具有交错速度的蛙跳法和速度与位置定义在相同时间网格上的速度Verlet方法。确保交错速度的初始化与网格上的初始条件一致，以便在精确算术下，两种方案在每个整数时间步产生相同的位置更新。\n\n您的实现必须：\n- 根据当前位置 $x_i(t)$，使用最近邻弹簧力和固定端点计算加速度 $a_i(t)$，所有单位均为无量纲。\n- 实现具有交错速度的蛙跳法，并根据网格上的初始状态推导出一致的半步长初始化方法。\n- 实现速度在网格上的速度Verlet方法。\n- 从相同的初始条件开始，逐步推进两种方法，并在每个整数时间点，计算所有质量点上两个位置向量之间的最大绝对差。在整个模拟过程中累积这种最大差值。每个测试案例报告这一个标量值。\n\n科学假设和推导基础：\n- 使用牛顿第二定律 $m\\,d^2x_i/dt^2 = F_i$，其中 $m=1$ 且弹簧刚度为单位刚度。\n- 使用从时间上的泰勒展开推导出的、经过充分检验的中心差分离散方法。\n\n角度单位不适用。所有量均为无量纲，因此不需要物理单位。结果必须是纯数。\n\n测试套件：\n- 案例 $1$ (一般情况，简正模)：$N=8$，时间步长 $\\Delta t=0.01$，步数 $=5000$。初始位置 $x_i(0) = \\sin\\!\\big(\\pi\\frac{i}{N+1}\\big)$，对于 $i\\in\\{1,\\dots,N\\}$，初始速度 $v_i(0)=0$ 对所有 $i$ 均成立。\n- 案例 $2$ (边界情况，静止状态)：$N=5$，时间步长 $\\Delta t=0.10$，步数 $=100$。初始位置 $x_i(0)=0$，初始速度 $v_i(0)=0$ 对所有 $i$ 均成立。\n- 案例 $3$ (接近稳定性极限，混合初始状态)：$N=3$，时间步长 $\\Delta t=0.90$，步数 $=1000$。初始位置 $[x_1(0),x_2(0),x_3(0)] = [0.10,-0.05,0.07]$，初始速度 $[v_1(0),v_2(0),v_3(0)] = [0.05,0.00,-0.02]$。\n- 案例 $4$ (长时间累积)：$N=6$，时间步长 $\\Delta t=0.005$，步数 $=40000$。初始位置 $x_i(0) = \\sin\\!\\big(\\pi\\frac{i}{N+1}\\big)$，对于 $i\\in\\{1,\\dots,N\\}$，初始速度 $v_i(0)=0$ 对所有 $i$ 均成立。\n\n算法要求：\n- 对于蛙跳法，使用交错速度 $v_{i}(t+\\Delta t/2)$ 和在整数时间点上的位置 $x_{i}(t)$。以与网格上的初始条件和 $t=0$ 时的加速度相一致的方式初始化半步长速度。\n- 对于速度Verlet方法，使用在整数时间点上的位置 $x_i(t)$ 和速度 $v_i(t)$，并使用从位置计算出的加速度来更新它们。\n\n您的程序必须为每个案例生成一个标量，该标量等于在所有时间和所有质量点上，蛙跳法和速度Verlet法位置轨迹之间的最大绝对差。最终输出格式必须是一行，包含一个用方括号括起来的、由逗号分隔的标量列表，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_k$ 是对应于上述顺序中案例 $k$ 的浮点数。", "solution": "该问题是适定且科学上合理的，描述了力学和计算物理中的一个典型模型——一维谐振子链。我们将首先推导运动方程，然后推导两种指定的数值积分方案（蛙跳法和速度Verlet法），确立它们在位置更新上的数学等价性，最后描述计算由浮点算术引起的数值差异的实现方法。\n\n### 1. 运动方程的推导\n\n考虑一个由 $N$ 个质点组成的链，每个质点的质量均为单位质量，即 $m_i=1$。这些质点由线性弹簧连接，每个弹簧的刚度也为单位刚度，即 $k=1$。设 $x_i(t)$ 是第 $i$ 个质点相对于其平衡位置的位移。质点的索引为 $i \\in \\{1, 2, \\dots, N\\}$。该链具有固定的（狄利克雷）边界条件，意味着两端的位移保持为零。这可以通过假设存在虚拟质量点 $i=0$ 和 $i=N+1$ 来建模，其位置在所有时间 $t$ 都固定为 $x_0(t) = 0$ 和 $x_{N+1}(t) = 0$。\n\n作用在质量点 $i$ 上的力由胡克定律决定。作用在质量点 $i$ 上的合力是连接它与质量点 $i-1$ 的弹簧和连接它与质量点 $i+1$ 的弹簧所施加力的总和。\n右侧弹簧（在 $i$ 和 $i+1$ 之间）施加的力是 $F_{i \\leftarrow i+1} = k(x_{i+1} - x_i)$。\n左侧弹簧（在 $i$ 和 $i-1$ 之间）施加的力是 $F_{i \\leftarrow i-1} = k(x_{i-1} - x_i)$。\n\n作用在质量点 $i$ 上的总力为：\n$$ F_i = F_{i \\leftarrow i+1} + F_{i \\leftarrow i-1} = k(x_{i+1} - x_i) + k(x_{i-1} - x_i) = k(x_{i+1} - 2x_i + x_{i-1}) $$\n\n根据牛顿第二定律，$F_i = m_i \\ddot{x}_i$，其中 $\\ddot{x}_i = d^2x_i/dt^2$ 是加速度。在单位质量 ($m_i=1$) 和单位弹簧刚度 ($k=1$) 的条件下，质量点 $i$ 的运动方程变为：\n$$ \\ddot{x}_i(t) = x_{i+1}(t) - 2x_i(t) + x_{i-1}(t) $$\n这组 $N$ 个耦合二阶常微分方程(ODEs)，连同边界条件 $x_0(t)=0$ 和 $x_{N+1}(t)=0$，控制着系统的动力学。每个质量点的加速度 $a_i = \\ddot{x}_i$ 是其自身及其最近邻位置的函数。\n\n### 2. 数值积分器的推导\n\n我们以步长 $\\Delta t$ 对时间进行离散化，使得 $t_n = n \\Delta t$。我们将质量点 $i$ 在时间 $t_n$ 的位置、速度和加速度分别表示为 $x_i^n$、$v_i^n$ 和 $a_i^n$。推导的核心依赖于位置 $x(t)$ 在时间 $t_n$ 附近的泰勒级数展开：\n$$ x(t_n + \\Delta t) = x(t_n) + v(t_n)\\Delta t + \\frac{1}{2} a(t_n)\\Delta t^2 + O(\\Delta t^3) $$\n$$ v(t_n + \\Delta t) = v(t_n) + a(t_n)\\Delta t + O(\\Delta t^2) $$\n\n#### 2.1. 具有交错速度的蛙跳法\n\n蛙跳法采用交错时间网格，在整数时间步 $t_n$ 计算位置，在半整数时间步 $t_{n \\pm 1/2} = t_n \\pm \\Delta t/2$ 计算速度。更新规则基于中心差分近似：\n速度更新（一次“踢”）：\n$$ v^{n+1/2} = v^{n-1/2} + a^n \\Delta t $$\n位置更新（一次“漂”）：\n$$ x^{n+1} = x^n + v^{n+1/2} \\Delta t $$\n这里，$a^n$ 是根据位置 $x^n$ 计算出的加速度。\n\n为了初始化此方案，我们给定 $x^0$ 和 $v^0$（在网格上）。我们需要第一个半步长速度 $v^{1/2}$（或其之前的 $v^{-1/2}$）。可以通过近似半步长处的速度来推导出一个一致的初始化方法：\n$$ v^{1/2} = v(t_0+\\Delta t/2) \\approx v(t_0) + a(t_0) \\frac{\\Delta t}{2} $$\n因此，为了在交错网格上获得速度的初始“踢”是：\n$$ v^{1/2} = v^0 + \\frac{1}{2} a^0 \\Delta t $$\n其中 $a^0$ 是根据初始位置 $x^0$ 计算的。时间演化过程通过重复应用“踢”和“漂”步骤来进行。\n\n#### 2.2. 速度Verlet方法\n\n速度Verlet方法是一种广泛使用的算法，它将位置 $x^n$ 和速度 $v^n$ 保持在相同的整数时间网格上。它的推导使其具有时间可逆性和辛性，与蛙跳法共享许多优良性质。\n\n更新过程分两个阶段进行：\n1. 将位置更新到下一个完整时间步：\n$$ x^{n+1} = x^n + v^n \\Delta t + \\frac{1}{2} a^n \\Delta t^2 $$\n这是一个二阶泰勒展开。\n2. 使用新旧加速度的平均值更新速度：\n$$ v^{n+1} = v^n + \\frac{1}{2} (a^n + a^{n+1}) \\Delta t $$\n要实现这一点，首先计算 $x^{n+1}$，然后用这个新位置计算新的加速度 $a^{n+1} = a(x^{n+1})$，最后计算新的速度 $v^{n+1}$。\n\n#### 2.3. 位置更新的等价性\n\n问题要求在精确算术下证明位置更新的等价性。让我们假设在步骤 $n$，两种方法的状态通过以下方式相关联：$x_{\\text{LF}}^n = x_{\\text{VV}}^n = x^n$，并且蛙跳法的半步长速度与Verlet法在网格上的速度通过 $v_{\\text{LF}}^{n-1/2} = v_{\\text{VV}}^n - \\frac{1}{2} a^n \\Delta t$ 相关联。\n\n速度Verlet法的位置更新为：\n$$ x_{\\text{VV}}^{n+1} = x^n + v_{\\text{VV}}^n \\Delta t + \\frac{1}{2} a^n \\Delta t^2 $$\n\n对于蛙跳法，我们首先将速度从 $v_{\\text{LF}}^{n-1/2}$ 更新到 $v_{\\text{LF}}^{n+1/2}$：\n$$ v_{\\text{LF}}^{n+1/2} = v_{\\text{LF}}^{n-1/2} + a^n \\Delta t = \\left(v_{\\text{VV}}^n - \\frac{1}{2} a^n \\Delta t\\right) + a^n \\Delta t = v_{\\text{VV}}^n + \\frac{1}{2} a^n \\Delta t $$\n接下来，我们更新蛙跳法的位置：\n$$ x_{\\text{LF}}^{n+1} = x_{\\text{LF}}^n + v_{\\text{LF}}^{n+1/2} \\Delta t = x^n + \\left(v_{\\text{VV}}^n + \\frac{1}{2} a^n \\Delta t\\right) \\Delta t = x^n + v_{\\text{VV}}^n \\Delta t + \\frac{1}{2} a^n \\Delta t^2 $$\n比较 $x_{\\text{VV}}^{n+1}$ 和 $x_{\\text{LF}}^{n+1}$ 的表达式，我们发现它们是完全相同的。\n\n等价性的初始条件是 $x_{\\text{LF}}^0 = x_{\\text{VV}}^0 = x^0$。蛙跳法的一致初始化给出 $v_{\\text{LF}}^{1/2} = v^0 + \\frac{1}{2} a^0 \\Delta t$，而Verlet法在一步之后的第一速度将通过 $v_{\\text{VV}}^1 = v_{\\text{LF}}^{1/2} + \\frac{1}{2} a^1 \\Delta t$ 与其半步长对应值相关联。实际上，初始化 $v^{1/2} = v^0 + \\frac{1}{2}a^0\\Delta t$ 确保了归纳步骤从一开始就成立。\n\n由于位置更新公式在数学上是相同的，所以在浮点实现中观察到的两种方法计算出的轨迹之间的任何差异都是由舍入误差的累积引起的。具体来说，浮点运算中的操作顺序可能导致微小的差异，这些差异可能随时间增长。问题要求量化这个最大差异。\n\n### 3. 算法实现\n\n对于每个测试案例，我们用相同的初始条件 $(x^0, v^0)$ 初始化两个独立的模拟，一个用于蛙跳法，一个用于速度Verlet法。\n- 加速度函数 `compute_acceleration(x)` 的实现是为了计算所有 $i$ 的 $a_i = x_{i-1} - 2x_i + x_{i+1}$，同时遵循边界条件 $x_0=0$ 和 $x_{N+1}=0$。\n- 在一个循环中执行指定数量的时间步：\n    1. 使用其更新规则和一致的半步长速度，将蛙跳法模拟的状态推进一个步长。\n    2. 使用其更新规则，将速度Verlet法模拟的状态推进一个步长。\n    3. 在计算出 $x_{\\text{LF}}^{n+1}$ 和 $x_{\\text{VV}}^{n+1}$ 之后，计算所有质量点上的最大绝对差：$d_n = \\max_i |x_{i, \\text{LF}}^{n+1} - x_{i, \\text{VV}}^{n+1}|$。\n    4. 在整个模拟过程中维持一个运行中的最大值 $\\max_n d_n$。\n- 这个运行中最大值的最终值就是该测试案例的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing leapfrog and velocity Verlet integrators\n    for a 1D chain of masses.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: General, normal mode\n        {\n            'N': 8, 'dt': 0.01, 'steps': 5000,\n            'x0_func': lambda N: np.sin(np.pi * np.arange(1, N + 1) / (N + 1)),\n            'v0_func': lambda N: np.zeros(N)\n        },\n        # Case 2: Boundary case, rest state\n        {\n            'N': 5, 'dt': 0.10, 'steps': 100,\n            'x0_func': lambda N: np.zeros(N),\n            'v0_func': lambda N: np.zeros(N)\n        },\n        # Case 3: Near stability limit, mixed initial state\n        {\n            'N': 3, 'dt': 0.90, 'steps': 1000,\n            'x0_func': lambda N: np.array([0.10, -0.05, 0.07]),\n            'v0_func': lambda N: np.array([0.05, 0.00, -0.02])\n        },\n        # Case 4: Long-time accumulation\n        {\n            'N': 6, 'dt': 0.005, 'steps': 40000,\n            'x0_func': lambda N: np.sin(np.pi * np.arange(1, N + 1) / (N + 1)),\n            'v0_func': lambda N: np.zeros(N)\n        }\n    ]\n\n    results = []\n\n    def compute_acceleration(x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Computes acceleration for the 1D mass-spring chain with fixed ends.\n        a_i = x_{i-1} - 2*x_i + x_{i+1}\n        \"\"\"\n        N = len(x)\n        # Pad with fixed zero-displacement ends\n        x_padded = np.zeros(N + 2)\n        x_padded[1:N+1] = x\n        \n        # Acceleration from nearest-neighbor forces\n        a = x_padded[:-2] + x_padded[2:] - 2 * x_padded[1:-1]\n        return a\n\n    for case in test_cases:\n        N = case['N']\n        dt = case['dt']\n        steps = case['steps']\n        x0 = case['x0_func'](N)\n        v0 = case['v0_func'](N)\n\n        max_abs_diff = 0.0\n\n        # --- Leapfrog Simulation Initialization ---\n        x_lf = x0.copy()\n        v_lf = v0.copy()\n        a_lf_current = compute_acceleration(x_lf)\n        # Initial half-step velocity for consistency with on-grid v0\n        v_lf_half_step = v_lf + 0.5 * a_lf_current * dt\n\n        # --- Velocity Verlet Simulation Initialization ---\n        x_vv = x0.copy()\n        v_vv = v0.copy()\n        a_vv_current = compute_acceleration(x_vv)\n        \n        for _ in range(steps):\n            # --- Leapfrog Step ---\n            # Drift positions using half-step velocity\n            x_lf += v_lf_half_step * dt\n            # Compute new acceleration\n            a_lf_new = compute_acceleration(x_lf)\n            # Kick velocity to the next half-step\n            v_lf_half_step += a_lf_new * dt\n\n            # --- Velocity Verlet Step ---\n            # Update positions\n            x_vv += v_vv * dt + 0.5 * a_vv_current * dt**2\n            # Compute new acceleration\n            a_vv_new = compute_acceleration(x_vv)\n            # Update velocities using average acceleration\n            v_vv += 0.5 * (a_vv_current + a_vv_new) * dt\n            # Store new acceleration for the next step\n            a_vv_current = a_vv_new\n\n            # --- Comparison ---\n            # Compute the max absolute difference for the current step\n            current_diff = np.max(np.abs(x_lf - x_vv))\n            if current_diff > max_abs_diff:\n                max_abs_diff = current_diff\n\n        results.append(max_abs_diff)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3144527"}, {"introduction": "在掌握了积分算法的基本实现后，下一个关键步骤是理解它们的实际应用限制，其中最重要的就是数值稳定性。一个不稳定的模拟会产生完全没有物理意义的结果，因此选择合适的时间步长 $dt$ 是进行任何有意义的分子动力学模拟的前提。本练习将通过模拟一个由更真实的 Morse 势描述的“刚性”双原子系统 [@problem_id:3144487]，让你直观地探索过大的时间步长是如何导致能量不守恒甚至模拟崩溃的，并揭示如何通过调整系统参数（如质量）来改善积分的稳定性。", "problem": "考虑一个一维双原子二聚体，在约化的无量纲单位下通过莫尔斯势相互作用。莫尔斯势由函数 $$U(r) = D_e \\left(1 - e^{-a(r - r_e)}\\right)^2,$$ 定义，其中$r$是两个原子之间的标量距离，$D_e$是势阱深度，$a$控制着最小值附近的刚度（曲率），$r_e$是平衡键长。原子的质量分别为$m_1$和$m_2$，它们沿直线的位置是$x_1$和$x_2$。力是$-\\nabla U$，每个原子的运动方程遵循牛顿第二定律， $$m_i \\frac{d^2 x_i}{dt^2} = F_i,\\quad i \\in \\{1,2\\}.$$ 分子动力学（MD）指的是对这些运动方程进行时间积分。全过程使用约化单位，不附加任何物理单位；所有量均为无量纲。\n\n从基本定律和定义（牛顿第二定律、速度定义$v = dx/dt$以及加速度定义$a = dv/dt$）出发，推导一个与这些定律一致的二阶、时间可逆、辛积分方案，并实现它以推进原子的位置和速度。将二聚体初始化在位置$x_1(0) = -r_0/2$和$x_2(0) = r_0/2$，初始速度为零$v_1(0) = 0$和$v_2(0) = 0$，其中$r_0 = r_e + \\delta r$，$\\delta r$是一个偏离平衡位置的微小正位移。在每个时间步，计算总能量 $$E(t) = \\frac{1}{2} m_1 v_1(t)^2 + \\frac{1}{2} m_2 v_2(t)^2 + U\\left(|x_2(t) - x_1(t)|\\right).$$\n\n如果在一个模拟的整个轨迹中，以下所有标准都成立，则定义该模拟是数值稳定的：\n- 分离距离保持在 $$0.2\\, r_e \\le |x_2(t) - x_1(t)| \\le 2.0\\, r_e$$ 范围内。\n- 不发生数值溢出或未定义值（没有 $\\mathrm{NaN}$ 或 $\\infty$）。\n- 分数能量漂移，定义为 $$\\Delta_E = \\frac{\\max_t E(t) - \\min_t E(t)}{\\overline{E}},$$ 其中 $\\overline{E}$ 是 $E(t)$ 在轨迹上的时间平均值，满足 $$\\Delta_E \\le 0.2.$$\n\n您的程序必须实现上述内容，并对以下每个测试用例评估其稳定性。为了探究积分器在大时间步长$dt$下的失效模式，以及质量缩放或更小的$dt$如何缓解不稳定性，请使用以下固定的莫尔斯势和初始位移参数：\n- $D_e = 10$\n- $a = 8$\n- $r_e = 1$\n- $\\delta r = 0.05$\n将基础质量设为$m = 1$，并通过质量缩放因子$s$来定义实际的原子质量，即$m_1 = s \\cdot m$和$m_2 = s \\cdot m$。\n\n测试套件（每个测试用例是一个元组$(dt, s, N)$，其中$dt$是时间步长，$s$是质量缩放因子，$N$是积分步数）：\n1. $(0.01, 1, 2000)$: 小时间步长，基础质量。\n2. $(0.15, 1, 1000)$: 大时间步长，基础质量。\n3. $(0.15, 100, 1000)$: 大时间步长，大质量缩放。\n4. $(0.04, 1, 2000)$: 接近稳定性边界，基础质量。\n5. $(0.50, 100, 500)$: 极大时间步长，大质量缩放。\n\n对于每个测试用例，运行模拟$N$步，并根据上述标准返回一个指示稳定性的布尔值。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，`[result1,result2,result3,result4,result5]`），其中每个结果是按给定顺序对应于测试用例的布尔值。", "solution": "该问题要求推导并实现一个数值积分方案，以模拟一个通过莫尔斯势相互作用的一维双原子系统的动力学。这是一个计算科学领域的经典问题，特别是在分子动力学（MD）领域。目标是实现一个稳定且准确的积分器，对一组给定的参数运行模拟，并根据规定的标准评估每个模拟的数值稳定性。\n\n首先，我们验证问题陈述。\n\n### 步骤1：提取给定条件\n-   **势能函数：** $U(r) = D_e \\left(1 - e^{-a(r - r_e)}\\right)^2$，其中 $r = |x_2 - x_1|$。\n-   **运动方程：** $m_i \\frac{d^2 x_i}{dt^2} = F_i$ 对原子 $i \\in \\{1,2\\}$ 成立。\n-   **力的定义：** 力是势的负梯度，$F = -\\nabla U$。\n-   **初始条件：** $x_1(0) = -r_0/2$, $x_2(0) = r_0/2$，其中 $r_0 = r_e + \\delta r$。初始速度为 $v_1(0) = 0$ 和 $v_2(0) = 0$。\n-   **总能量：** $E(t) = \\frac{1}{2} m_1 v_1(t)^2 + \\frac{1}{2} m_2 v_2(t)^2 + U\\left(|x_2(t) - x_1(t)|\\right)$。\n-   **固定参数：** $D_e = 10$, $a = 8$, $r_e = 1$, $\\delta r = 0.05$。\n-   **质量缩放：** $m_1 = m_2 = s$，其中$s$是给定的质量缩放因子。\n-   **稳定性标准：**\n    1.  有界分离：$0.2 \\cdot r_e \\le |x_2(t) - x_1(t)| \\le 2.0 \\cdot r_e$。\n    2.  无数值溢出（例如，$\\mathrm{NaN}$ 或 $\\infty$）。\n    3.  分数能量漂移 $\\Delta_E = \\frac{\\max_t E(t) - \\min_t E(t)}{\\overline{E}} \\le 0.2$。\n-   **测试套件：** 5个元组 $(dt, s, N)$ 的列表，其中 $dt$ 是时间步长，$s$ 是质量缩放因子，$N$ 是步数。\n    1.  $(0.01, 1, 2000)$\n    2.  $(0.15, 1, 1000)$\n    3.  $(0.15, 100, 1000)$\n    4.  $(0.04, 1, 2000)$\n    5.  $(0.50, 100, 500)$\n\n### 步骤2：使用提取的给定条件进行验证\n该问题基于科学，使用了公认的莫尔斯势和牛顿运动定律。这是分子动力学模拟中的一个标准练习。问题陈述清晰，为每个测试用例提供了所有必要的物理参数、初始条件和数值参数。稳定性标准是用客观、量化的指标定义的。没有矛盾、歧义或不科学的前提。这是一个需要理论推导和计算实现的实质性任务。\n\n### 步骤3：结论与行动\n问题有效。我们继续进行求解。\n\n### 积分算法的推导与实现\n\n问题要求一个二阶、时间可逆、辛积分方案。Velocity Verlet算法满足这些属性，是MD模拟的标准选择。我们从位置$x(t)$的泰勒级数展开来推导它。\n\n对于质量为$m$的粒子，其位置$x(t)$根据牛顿第二定律演化，$\\ddot{x}(t) = a(t) = F(x(t))/m$。在时间$t+dt$处的位置的泰勒级数展开为：\n$$x(t+dt) = x(t) + \\dot{x}(t)dt + \\frac{1}{2}\\ddot{x}(t)dt^2 + O(dt^3)$$\n注意到$\\dot{x}(t) = v(t)$和$\\ddot{x}(t) = a(t)$，我们可以写出一个位置更新规则：\n$$x(t+dt) = x(t) + v(t)dt + \\frac{1}{2}a(t)dt^2$$\n此更新在$dt$上是二阶准确的。为了保持整个算法的这种准确性，速度更新也必须是二阶的。简单的向前欧拉速度更新，$v(t+dt) = v(t) + a(t)dt$，只是一阶的，会降低整体精度。相反，我们可以使用时间步开始和结束时加速度的平均值：\n$$v(t+dt) = v(t) + \\frac{a(t) + a(t+dt)}{2}dt$$\n这组方程定义了Velocity Verlet算法。然而，它的直接实现是隐式的，因为$a(t+dt)$依赖于$x(t+dt)$，而$x(t+dt)$尚未完全确定。Velocity Verlet的“蛙跳”变体将计算重新排列成一个显式的、计算效率高的序列：\n\n1.  计算半个时间步$t+dt/2$处的速度：\n    $$v(t + dt/2) = v(t) + \\frac{1}{2}a(t)dt$$\n2.  使用这个半步速度更新整个时间步$dt$的位置：\n    $$x(t+dt) = x(t) + v(t+dt/2)dt$$\n3.  计算新位置处的力$F(x(t+dt))$和加速度$a(t+dt)$。\n4.  完成时间步后半段的速度更新：\n    $$v(t+dt) = v(t+dt/2) + \\frac{1}{2}a(t+dt)dt$$\n\n该方案在代数上等价于原始公式，是显式的，并且具有MD所需的优异特性：它是二阶准确、时间可逆和辛的，这导致了良好的长期能量守恒。\n\n### 在双原子系统上的应用\n\n我们将此算法应用于两个原子中的每一个，索引为$i \\in \\{1,2\\}$。每个原子上的力源于莫尔斯势，该势取决于原子间距$r = |x_2 - x_1|$。原子$i$上的力是$F_i = -\\frac{\\partial U}{\\partial x_i}$。使用链式法则，对于$r = |x_2 - x_1|$：\n$$F_1 = -\\frac{dU}{dr}\\frac{\\partial r}{\\partial x_1} = -\\frac{dU}{dr}(-\\text{sgn}(x_2 - x_1)) = \\text{sgn}(x_2 - x_1)\\frac{dU}{dr}$$\n$$F_2 = -\\frac{dU}{dr}\\frac{\\partial r}{\\partial x_2} = -\\frac{dU}{dr}(\\text{sgn}(x_2 - x_1)) = -\\text{sgn}(x_2 - x_1)\\frac{dU}{dr}$$\n注意，牛顿第三定律$F_1 = -F_2$是满足的。莫尔斯势的导数是：\n$$\\frac{dU}{dr} = 2aD_e \\left(1 - e^{-a(r - r_e)}\\right) e^{-a(r - r_e)}$$\n加速度则为$a_1 = F_1/m_1$和$a_2 = F_2/m_2$。在这个问题中，$m_1 = m_2 = s$。\n\n模拟过程如下：\n1.  初始化位置$x_1 = -r_0/2$, $x_2 = r_0/2$和速度$v_1 = 0$, $v_2 = 0$。\n2.  计算初始力$F_1, F_2$和加速度$a_1, a_2$。\n3.  存储初始原子间距$r(0) = |x_2 - x_1|$和总能量$E(0)$。\n4.  循环$N$个时间步：\n    a. 对每个原子$i$，将速度更新到半步：$v_i(t+dt/2) = v_i(t) + \\frac{1}{2}a_i(t)dt$。\n    b. 对每个原子$i$，将位置更新到全步：$x_i(t+dt) = x_i(t) + v_i(t+dt/2)dt$。\n    c. 计算新的间距$r(t+dt)$以及新的力$F_i(t+dt)$和加速度$a_i(t+dt)$。在此步骤中，检查数值溢出，这会立即使模拟失效。\n    d. 对每个原子$i$，完成速度更新：$v_i(t+dt) = v_i(t+dt/2) + \\frac{1}{2}a_i(t+dt)dt$。\n    e. 存储新的间距$r(t+dt)$和总能量$E(t+dt)$。\n5. 在$N$步之后，根据三个稳定性标准分析存储的轨迹数据（$r(t)$和$E(t)$），以确定最终的布尔结果。\n\n对问题陈述中提供的每个测试用例都执行此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(dt, s, N):\n    \"\"\"\n    Runs a molecular dynamics simulation for a two-atom dimer.\n\n    Args:\n        dt (float): The time step for integration.\n        s (float): The mass scale factor for the atoms.\n        N (int): The number of integration steps.\n\n    Returns:\n        bool: True if the simulation is stable, False otherwise.\n    \"\"\"\n    # Fixed parameters for the Morse potential and initial displacement\n    De = 10.0\n    a = 8.0\n    re = 1.0\n    delta_r = 0.05\n    \n    # Initial conditions\n    r0 = re + delta_r\n    x1, x2 = -r0 / 2.0, r0 / 2.0\n    v1, v2 = 0.0, 0.0\n    m1, m2 = float(s), float(s)\n\n    # History storage\n    r_hist = np.zeros(N + 1)\n    E_hist = np.zeros(N + 1)\n\n    # --- Utility functions ---\n    def calculate_forces_and_separation(x1_pos, x2_pos):\n        r_vec = x2_pos - x1_pos\n        r_mag = np.abs(r_vec)\n        \n        if r_mag == 0:\n            return np.inf, -np.inf, r_mag\n        \n        # This term can overflow if r_mag gets too small.\n        # -a * (r_mag - re) becomes large and positive.\n        exp_arg = -a * (r_mag - re)\n        if exp_arg > np.log(np.finfo(float).max): # Avoid overflow in exp\n             return np.inf, -np.inf, r_mag\n\n        exp_term = np.exp(exp_arg)\n        \n        # dU/dr\n        F_grad = 2 * a * De * (1 - exp_term) * exp_term\n\n        # Forces on atoms 1 and 2\n        F1 = np.sign(r_vec) * F_grad\n        F2 = -F1\n        \n        return F1, F2, r_mag\n\n    def potential_energy(r_mag):\n        return De * (1 - np.exp(-a * (r_mag - re)))**2\n\n    def kinetic_energy(vel1, vel2, mass1, mass2):\n        return 0.5 * mass1 * vel1**2 + 0.5 * mass2 * vel2**2\n\n    # --- Simulation setup (t=0) ---\n    F1_curr, F2_curr, r_mag_curr = calculate_forces_and_separation(x1, x2)\n    acc1_curr, acc2_curr = F1_curr / m1, F2_curr / m2\n\n    r_hist[0] = r_mag_curr\n    E_hist[0] = kinetic_energy(v1, v2, m1, m2) + potential_energy(r_mag_curr)\n\n    # --- Main integration loop ---\n    for i in range(N):\n        # Velocity Verlet: half-step velocity update\n        v1_half = v1 + 0.5 * acc1_curr * dt\n        v2_half = v2 + 0.5 * acc2_curr * dt\n\n        # Velocity Verlet: full-step position update\n        x1 = x1 + v1_half * dt\n        x2 = x2 + v2_half * dt\n\n        # Calculate new forces and accelerations\n        F1_new, F2_new, r_mag_new = calculate_forces_and_separation(x1, x2)\n        \n        # Stability Check 2: Numerical overflow\n        if np.isinf(F1_new) or np.isnan(F1_new):\n            return False\n            \n        acc1_new = F1_new / m1\n        acc2_new = F2_new / m2\n\n        # Velocity Verlet: second half-step velocity update\n        v1 = v1_half + 0.5 * acc1_new * dt\n        v2 = v2_half + 0.5 * acc2_new * dt\n        \n        # Update accelerations for the next iteration\n        acc1_curr, acc2_curr = acc1_new, acc2_new\n\n        # Store diagnostics for analysis\n        r_hist[i+1] = r_mag_new\n        E_hist[i+1] = kinetic_energy(v1, v2, m1, m2) + potential_energy(r_mag_new)\n        \n        if np.isinf(E_hist[i+1]) or np.isnan(E_hist[i+1]):\n            return False\n\n    # --- Post-simulation stability analysis ---\n\n    # Stability Check 1: Separation magnitude bounds\n    min_r = np.min(r_hist)\n    max_r = np.max(r_hist)\n    if not (0.2 * re = min_r and max_r = 2.0 * re):\n        return False\n        \n    # Stability Check 3: Fractional energy drift\n    avg_E = np.mean(E_hist)\n    if avg_E == 0: # Should not occur in this problem\n        if np.max(E_hist) - np.min(E_hist) > 1e-9: # Tolerate zero drift if energy is always zero\n            return False\n    else:\n        delta_E = (np.max(E_hist) - np.min(E_hist)) / avg_E\n        if delta_E > 0.2:\n            return False\n            \n    # If all checks pass, the simulation is stable\n    return True\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.01, 1, 2000),      # small time step, base mass.\n        (0.15, 1, 1000),      # large time step, base mass.\n        (0.15, 100, 1000),    # large time step, heavy mass scaling.\n        (0.04, 1, 2000),      # near the stability boundary, base mass.\n        (0.50, 100, 500),     # extremely large time step, heavy mass scaling.\n    ]\n\n    results = []\n    for case in test_cases:\n        dt, s, N = case\n        is_stable = run_simulation(dt, s, N)\n        results.append(is_stable)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3144487"}, {"introduction": "当我们成功运行了一个稳定的模拟后，我们面临的挑战就转向了如何正确地分析和解读所生成的轨迹数据。我们“观察”或采样系统的方式可能会极大地影响我们得出的结论，甚至导致对物理过程的完全误判。本实践将引导你探索信号处理中的一个基本陷阱——“混叠”（aliasing）现象，即由于采样频率不足，高频运动被错误地识别为低频运动 [@problem_id:3144553]。通过模拟一个简谐振子并对其输出进行不同程度的降采样，你将对奈奎斯特定理（Nyquist criterion）的重要性以及它在MD模拟结果分析中的核心作用获得宝贵的实践经验。", "problem": "考虑一个受线性恢复力作用的一维质点，其运动由牛顿第二定律 $m \\, d^2 x/dt^2 = -k \\, x$ 描述，其中 $m$ 为质量，$k$ 为弹簧常数。其连续时间动力学是简谐振子的动力学，角频率为 $\\omega = \\sqrt{k/m}$ (单位 $\\mathrm{rad/s}$)，物理频率为 $f_{\\text{true}} = \\omega/(2\\pi)$ (单位 $\\mathrm{Hz}$)。你将实现速度 Verlet 算法，使用稳定的时间步长对此运动进行数值积分，然后探究降采样如何在采样轨迹中引起混叠。你的程序必须以 $\\mathrm{Hz}$ 为单位计算频率，角度始终以弧度为单位。\n\n仅从牛顿定律 ($F = m a$) 和运动学定义 ($v = dx/dt$ 和 $a = dv/dt$) 出发，实现速度 Verlet 算法，使用由力 $F = -k x$ 计算出的加速度，来推进谐振子的位置和速度。在使用安全时间步长 $\\Delta t$ 计算出有限时长 $T$ 内的高分辨率轨迹后，通过保留每第 $s$ 个样本来生成一个降采样序列。对于高分辨率和降采样序列，通过检测 $x(t)$ 的零点穿越并平均半周期区间来估计频率。评估采样频率 $f_s = 1/(\\Delta t \\, s)$ 是否满足数值实现的振荡频率的奈奎斯特准则，并展示混叠导致动力学被误解的案例。\n\n你必须设计程序来处理以下参数值的测试套件。对于所有测试，使用质量 $m = 1$ (单位 $\\mathrm{kg}$)，初始位置 $x_0 = 1$ (单位 $\\mathrm{m}$)，初始速度 $v_0 = 0$ (单位 $\\mathrm{m/s}$)，时间步长 $\\Delta t = 10^{-4}$ (单位 $\\mathrm{s}$)，以及总模拟时间 $T = 0.5$ (单位 $\\mathrm{s}$)。选择弹簧常数 $k$ 使得物理频率为 $f_{\\text{true}} = 50$ (单位 $\\mathrm{Hz}$)，即 $k = m \\, (2\\pi f_{\\text{true}})^2$。该测试套件仅改变降采样因子 $s$：\n\n- 测试 1 (理想情况): $s = 50$，因此 $f_s = 1/(\\Delta t \\, s) = 200$ (单位 $\\mathrm{Hz}$)，这应该满足振子动力学的奈奎斯特准则。\n- 测试 2 (混叠): $s = 167$，因此 $f_s \\approx 59.880239$ (单位 $\\mathrm{Hz}$)，这应该会违反奈奎斯特准则并表现出混叠。\n- 测试 3 (接近奈奎斯特边界): $s = 100$，因此 $f_s = 100$ (单位 $\\mathrm{Hz}$)，这恰好是物理频率的两倍，位于奈奎斯特准则的边界上。\n- 测试 4 (相称采样导致极端混叠): $s = 200$，因此 $f_s = 50$ (单位 $\\mathrm{Hz}$)，与物理频率相等，导致采样序列重复相同的相位并看起来是恒定的。\n\n对于每个测试用例，计算并返回以下量：\n- $f_{\\text{true}}$ (单位 $\\mathrm{Hz}$)，由 $\\omega = \\sqrt{k/m}$ 得出的物理振子频率。\n- $f_{\\text{Verlet}}$ (单位 $\\mathrm{Hz}$)，速度 Verlet 积分器数值实现的振荡频率，通过高分辨率轨迹的零点穿越估计得出。\n- $f_s$ (单位 $\\mathrm{Hz}$)，降采样后的采样频率。\n- $f_{\\text{down}}$ (单位 $\\mathrm{Hz}$)，从降采样序列的零点穿越估计出的频率。\n- $\\text{nyquist\\_ok}$，一个布尔指示符，如果 $f_s \\ge 2 f_{\\text{Verlet}}$ 则编码为 $1$，否则为 $0$。\n\n所有频率输出必须以 $\\mathrm{Hz}$ 为单位表示，并打印到小数点后 $6$ 位。最终输出必须是单行，包含测试套件的结果，形式为逗号分隔的子列表列表，每个子列表的格式必须为 $[f_{\\text{true}}, f_{\\text{Verlet}}, f_s, f_{\\text{down}}, \\text{nyquist\\_ok}]$。例如，形式为 $[[\\dots],[\\dots],[\\dots],[\\dots]]$ 的一行。\n\n你的程序必须只产生这一行输出，不得有任何附加文本。", "solution": "## 问题验证\n\n### 步骤 1：提取已知信息\n- **物理系统**：受线性恢复力作用的一维质点。\n- **运动方程**：$m \\, d^2 x/dt^2 = -k \\, x$。\n- **定义**：\n    - 质量：$m$\n    - 弹簧常数：$k$\n    - 位置：$x(t)$\n    - 速度：$v(t) = dx/dt$\n    - 加速度：$a(t) = dv/dt$\n    - 角频率：$\\omega = \\sqrt{k/m}$\n    - 物理频率：$f_{\\text{true}} = \\omega/(2\\pi)$\n- **数值方法**：速度 Verlet 算法。\n- **分析方法**：通过零点穿越检测估计频率。\n- **模拟参数（适用于所有测试）**：\n    - 质量, $m = 1$ kg\n    - 初始位置, $x_0 = 1$ m\n    - 初始速度, $v_0 = 0$ m/s\n    - 高分辨率时间步长, $\\Delta t = 10^{-4}$ s\n    - 总模拟时间, $T = 0.5$ s\n    - 要模拟的物理频率, $f_{\\text{true}} = 50$ Hz\n- **派生常数**：$k = m \\, (2\\pi f_{\\text{true}})^2$。\n- **测试套件（改变降采样因子 $s$）**：\n    - 测试 1: $s = 50$\n    - 测试 2: $s = 167$\n    - 测试 3: $s = 100$\n    - 测试 4: $s = 200$\n- **每个测试用例的必需输出**：\n    1. $f_{\\text{true}}$ (Hz)：物理振子频率。\n    2. $f_{\\text{Verlet}}$ (Hz)：从高分辨率模拟中数值实现的频率。\n    3. $f_s$ (Hz)：降采样后的采样频率，$f_s = 1/(\\Delta t \\cdot s)$。\n    4. $f_{\\text{down}}$ (Hz)：从降采样序列估计的频率。\n    5. $\\text{nyquist\\_ok}$：布尔值，如果 $f_s \\ge 2 f_{\\text{Verlet}}$ 则编码为 $1$，否则为 $0$。\n- **输出格式**：单行，逗号分隔的子列表列表，例如 $[[\\dots],[\\dots],[\\dots],[\\dots]]$，频率格式化为小数点后 6 位。\n\n### 步骤 2：使用提取的已知信息进行验证\n根据验证标准对问题进行评估：\n- **科学依据**：该问题基于经典力学的基本原理（简谐振子的牛顿第二定律）、标准数值方法（速度 Verlet 算法）和信号处理概念（奈奎斯特-香农采样定理，混叠）。所有概念在计算科学中都是成熟的。\n- **适定性**：问题被完全指定。所有必需的参数（$m, x_0, v_0, \\Delta t, T, f_{\\text{true}}$）、积分方案和分析方法都已明确定义。任务清晰，可以得出一组唯一的、可计算的结果。\n- **客观性**：问题以精确的技术语言陈述，没有任何主观或含糊的术语。\n- **缺陷清单**：该问题没有违反任何列出的无效标准。它在科学上是合理的，可形式化，完整，可行且结构良好。对于一个 $50\\,\\mathrm{Hz}$ 的振子（周期 $T_{\\text{osc}} = 0.02\\,\\mathrm{s}$），所选的时间步长 $\\Delta t = 10^{-4}\\,\\mathrm{s}$ 提供了 $\\Delta t / T_{\\text{osc}} = 1/200$ 的比率，确保了 Verlet 积分器的数值稳定性。\n\n### 步骤 3：结论和行动\n问题是**有效的**。将提供完整的解决方案。\n\n## 解法\n\n该问题要求我们使用速度 Verlet 算法模拟一个简谐振子，然后分析降采样对感知到的振荡频率的影响，从而展示混叠的概念。\n\n### 理论框架\n\n**1. 简谐振子 (SHO) 的动力学**\n系统由线性恢复力（胡克定律）的牛顿第二定律支配：\n$$ F = ma = -kx $$\n因此，加速度 $a$ 是位置 $x$ 的函数：\n$$ a(x) = -\\frac{k}{m}x $$\n这是简谐运动的方程。其解的形式为 $x(t) = A \\cos(\\omega t + \\phi)$，其中角频率 $\\omega$ 由下式给出：\n$$ \\omega = \\sqrt{\\frac{k}{m}} $$\n物理频率 $f_{\\text{true}}$ 通过 $f_{\\text{true}} = \\omega / (2\\pi)$ 与 $\\omega$ 相关。对于给定的参数 $m=1\\,\\mathrm{kg}$ 和 $f_{\\text{true}}=50\\,\\mathrm{Hz}$，弹簧常数 $k$ 计算如下：\n$$ k = m \\omega^2 = m (2\\pi f_{\\text{true}})^2 = 1 \\cdot (2\\pi \\cdot 50)^2 = (100\\pi)^2 \\approx 98696.044\\,\\mathrm{N/m} $$\n\n**2. 速度 Verlet 算法**\n速度 Verlet 算法是一种用于积分牛顿运动方程的数值方法。它以一种时间可逆且能表现出良好长期能量守恒的方式，将位置 $x$ 和速度 $v$ 从时间 $t$ 更新到 $t+\\Delta t$。更新规则如下：\n1. 将位置更新到完整时间步长：\n$$ x(t + \\Delta t) = x(t) + v(t)\\Delta t + \\frac{1}{2}a(t)(\\Delta t)^2 $$\n2. 计算新位置处的加速度：\n$$ a(t + \\Delta t) = -\\frac{k}{m}x(t + \\Delta t) $$\n3. 使用旧加速度和新加速度的平均值更新速度：\n$$ v(t + \\Delta t) = v(t) + \\frac{1}{2}[a(t) + a(t + \\Delta t)]\\Delta t $$\n该算法的速度局部误差为 $O(\\Delta t^3)$ 阶，位置局部误差为 $O(\\Delta t^4)$ 阶，全局误差为 $O(\\Delta t^2)$ 阶。关键是，它会引入一个小的相位误差，导致数值实现的频率 $f_{\\text{Verlet}}$ 与真实的解析频率 $f_{\\text{true}}$ 略有不同。对于简谐振子，数值频率低于真实频率：$f_{\\text{Verlet}}  f_{\\text{true}}$。\n\n**3. 通过零点穿越估计频率**\n要估计振荡信号 $x(t)$ 的频率，我们可以识别信号穿过零点的时间点。如果在时间步 $t_i$ 和 $t_{i+1}$ 之间，$x(t_i) \\cdot x(t_{i+1})  0$，则检测到一次零点穿越。可以使用线性插值找到更精确的穿越时间 $t_{\\text{cross}}$：\n$$ t_{\\text{cross}} = t_i - x(t_i) \\frac{t_{i+1} - t_i}{x(t_{i+1}) - x(t_i)} $$\n两个连续零点穿越之间的时间间隔对应于半个振荡周期，$T_{\\text{osc}}/2$。通过在整个轨迹上平均这些半周期区间，我们得到了平均半周期的稳健估计值 $\\langle T_{\\text{osc}}/2 \\rangle$。然后估计的频率为：\n$$ f_{\\text{est}} = \\frac{1}{2 \\langle T_{\\text{osc}}/2 \\rangle} $$\n\n**4. 采样、奈奎斯特准则与混叠**\n当在离散时间间隔对连续信号进行采样时，采样频率 $f_s$ 必须足够高才能捕捉信号的频率内容。奈奎斯特-香农采样定理指出，为避免信息丢失，采样频率 $f_s$ 必须严格大于信号中最高频率分量 $f_{\\text{max}}$ 的两倍。该条件是：\n$$ f_s > 2 f_{\\text{max}} $$\n在我们的案例中，信号的频率是数值实现的频率 $f_{\\text{Verlet}}$。问题将奈奎斯特准则定义为 $f_s \\ge 2 f_{\\text{Verlet}}$。如果不满足此准则，就会发生一种称为混叠的现象。原始信号中的高频 $f_{\\text{Verlet}}$ 在采样数据中表现为一个较低的“混叠”频率 $f_{\\text{alias}}$，由下式给出：\n$$ f_{\\text{alias}} = |f_{\\text{Verlet}} - n \\cdot f_s| $$\n其中 $n$ 是一个整数，其选择使得 $0 \\le f_{\\text{alias}} \\le f_s/2$。这种频率的错误表示就是我们将在某些测试用例中观察到的现象。\n\n### 算法实现计划\n\n对于由降采样因子 $s$ 定义的每个测试用例：\n1.  **高分辨率模拟**：速度 Verlet 算法将使用小时间步长 $\\Delta t = 10^{-4}\\,\\mathrm{s}$ 运行一次，总时长为 $T = 0.5\\,\\mathrm{s}$，生成高分辨率的时间和位置数组 `t_high` 和 `x_high`。\n2.  **计算 $f_{\\text{true}}$**：这是一个给定的常数值 $50\\,\\mathrm{Hz}$。\n3.  **计算 $f_{\\text{Verlet}}$**：将零点穿越频率估计算法应用于 `t_high` 和 `x_high` 数组。这给出了我们模拟的基线数值频率。\n4.  **降采样轨迹**：通过从高分辨率数组中选择每第 $s$ 个点来创建降采样轨迹 (`t_down`, `x_down`)。\n5.  **计算 $f_s$**：降采样数据的采样频率计算为 $f_s = 1 / (\\Delta t \\cdot s)$。\n6.  **计算 $f_{\\text{down}}$**：将零点穿越频率估计算法应用于降采样轨迹 (`t_down`, `x_down`)。如果检测到的穿越次数少于两次（如测试 4 中所预期的），则频率报告为 $0.0\\,\\mathrm{Hz}$。\n7.  **检查奈奎斯特准则**：如果 $f_s \\ge 2 f_{\\text{Verlet}}$，则布尔值 `nyquist_ok` 设置为 $1$，否则为 $0$。\n8.  **存储和格式化**：收集五个计算出的量（$f_{\\text{true}}, f_{\\text{Verlet}}, f_s, f_{\\text{down}}, \\text{nyquist\\_ok}$）并为最终输出进行格式化。\n\n此过程将对测试套件中的每个 $s$ 值重复进行，以展示不同的采样机制。\n- **测试 1 ($s=50$)**: $f_s = 200\\,\\mathrm{Hz}$。由于 $200 > 2 \\cdot f_{\\text{Verlet}} \\approx 100\\,\\mathrm{Hz}$，奈奎斯特准则得到满足。我们预期 $f_{\\text{down}} \\approx f_{\\text{Verlet}}$。\n- **测试 2 ($s=167$)**: $f_s \\approx 59.88\\,\\mathrm{Hz}$。这违反了该准则。我们预期会发生混叠，其中 $f_{\\text{down}} \\approx |f_{\\text{Verlet}} - f_s| \\approx |50 - 59.88| = 9.88\\,\\mathrm{Hz}$。\n- **测试 3 ($s=100$)**: $f_s = 100\\,\\mathrm{Hz}$。这处于奈奎斯特边界（$f_s = 2 f_{\\text{Verlet}}$）。频率仍应能被正确识别，因此 $f_{\\text{down}} \\approx f_{\\text{Verlet}}$。\n- **测试 4 ($s=200$)**: $f_s = 50\\,\\mathrm{Hz}$。这也违反了该准则，并且关键的是，$f_s \\approx f_{\\text{Verlet}}$。每个周期采样一次，相位几乎相同。由于模拟从波峰开始（$x_0=1, v_0=0$），所有样本都将接近波峰。将不会观察到零点穿越，因此 $f_{\\text{down}}$ 将为 $0.0\\,\\mathrm{Hz}$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of simulating a harmonic oscillator with the velocity Verlet \n    algorithm and analyzing aliasing effects from downsampling.\n    \"\"\"\n\n    def _run_verlet(k, m, x0, v0, dt, num_steps):\n        \"\"\"\n        Performs a velocity Verlet integration for a simple harmonic oscillator.\n        \"\"\"\n        t = np.zeros(num_steps + 1)\n        x = np.zeros(num_steps + 1)\n        v = np.zeros(num_steps + 1)\n\n        x[0] = x0\n        v[0] = v0\n        t[0] = 0.0\n\n        for i in range(num_steps):\n            a_current = -k / m * x[i]\n            \n            # Update position\n            x[i+1] = x[i] + v[i] * dt + 0.5 * a_current * dt**2\n            \n            # Calculate next acceleration\n            a_next = -k / m * x[i+1]\n            \n            # Update velocity\n            v[i+1] = v[i] + 0.5 * (a_current + a_next) * dt\n            \n            # Update time\n            t[i+1] = t[i] + dt\n            \n        return t, x\n\n    def _estimate_frequency(times, positions):\n        \"\"\"\n        Estimates frequency by finding zero-crossings with linear interpolation.\n        \"\"\"\n        crossings = []\n        for i in range(len(positions) - 1):\n            if positions[i] * positions[i+1]  0:\n                # Linear interpolation to find the exact time of crossing\n                t1, t2 = times[i], times[i+1]\n                p1, p2 = positions[i], positions[i+1]\n                t_cross = t1 - p1 * (t2 - t1) / (p2 - p1)\n                crossings.append(t_cross)\n\n        if len(crossings)  2:\n            return 0.0\n\n        half_periods = np.diff(crossings)\n        \n        if len(half_periods) == 0:\n            return 0.0\n            \n        avg_half_period = np.mean(half_periods)\n        \n        if avg_half_period = 0: # Avoid division by zero or negative\n            return 0.0\n\n        return 1.0 / (2.0 * avg_half_period)\n\n    # --- Main execution ---\n    \n    # Define problem parameters from the statement\n    m = 1.0             # kg\n    f_true = 50.0         # Hz\n    x0 = 1.0            # m\n    v0 = 0.0            # m/s\n    dt = 1e-4           # s\n    T_sim = 0.5         # s\n\n    # Derived constant\n    k = m * (2.0 * np.pi * f_true)**2\n\n    # Test suite of downsampling factors\n    test_suite_s = [50, 167, 100, 200]\n\n    all_results = []\n\n    # Run the high-resolution simulation once, as it's common to all tests\n    num_steps = int(T_sim / dt)\n    t_high, x_high = _run_verlet(k, m, x0, v0, dt, num_steps)\n    \n    # Estimate the numerically realized frequency from the high-res data\n    f_verlet = _estimate_frequency(t_high, x_high)\n\n    for s in test_suite_s:\n        # 1. Downsample the trajectory\n        t_down = t_high[::s]\n        x_down = x_high[::s]\n\n        # 2. Calculate the sampling frequency for the downsampled data\n        dt_s = dt * s\n        f_s = 1.0 / dt_s if dt_s > 0 else 0.0\n        \n        # 3. Estimate frequency from the downsampled data\n        f_down = _estimate_frequency(t_down, x_down)\n        \n        # 4. Check the Nyquist criterion using the accurate f_Verlet\n        nyquist_ok = 1 if f_s >= 2 * f_verlet else 0\n        \n        # 5. Store the tuple of results for this test case\n        case_results = [f_true, f_verlet, f_s, f_down, nyquist_ok]\n        all_results.append(case_results)\n\n    # Format the final output string exactly as specified\n    output_strings = []\n    for res in all_results:\n        # res = [f_true, f_verlet, f_s, f_down, nyquist_ok]\n        formatted_res = [\n            f\"{res[0]:.6f}\",\n            f\"{res[1]:.6f}\",\n            f\"{res[2]:.6f}\",\n            f\"{res[3]:.6f}\",\n            str(int(res[4]))\n        ]\n        output_strings.append(f\"[{','.join(formatted_res)}]\")\n        \n    final_output = f\"[{','.join(output_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3144553"}]}