{"hands_on_practices": [{"introduction": "平滑核函数是SPH方法的核心，其积分归一化性质是保证质量守恒和近似精度的基石。本练习旨在通过数值积分，验证SPH中最常用的三次样条核函数是否满足其理论上的归一化条件，即在整个空间上的积分为$1$。这不仅是一项对理论的验证，也是确保代码实现正确性的关键一步[@problem_id:3194379]。", "problem": "您的任务是设计并实现一个数值实验，以验证平滑粒子流体动力学（SPH, Smoothed-Particle Hydrodynamics）中的核函数归一化。目标是数值近似计算所选SPH核函数 $W(\\mathbf{r}, h)$ 的空间积分，并检验在一系列平滑长度 $h$ 下，该积分值是否接近 $1$。该实验应以纯数学和算法的形式进行表述，并通过一个单一、完整的程序来执行。\n\n基本原理：使用平滑粒子流体动力学（SPH）中标准的、广泛采用的三次样条核函数定义。该核函数是径向对称的，因此 $W(\\mathbf{r}, h) = W(r, h)$，其中 $r = \\lVert \\mathbf{r} \\rVert$。三次样条核函数由以下分段函数定义：\n$$\nW(r,h) = \\frac{\\sigma_d}{h^d}\n\\begin{cases}\n1 - \\frac{3}{2} q^2 + \\frac{3}{4} q^3, 0 \\le q  1, \\\\\n\\frac{1}{4} (2 - q)^3, 1 \\le q  2, \\\\\n0, q \\ge 2,\n\\end{cases}\n$$\n其中 $q = \\frac{r}{h}$，$d \\in \\{1, 2, 3\\}$ 是空间维度，$\\sigma_d$ 是与维度相关的归一化常数：\n- 对于 $d = 1$，$\\sigma_1 = \\frac{2}{3}$。\n- 对于 $d = 2$，$\\sigma_2 = \\frac{10}{7\\pi}$。\n- 对于 $d = 3$，$\\sigma_3 = \\frac{1}{\\pi}$。\n\n实验设计要求：\n- 使用径向简化方法数值近似计算空间积分 $\\int_{\\mathbb{R}^d} W(\\mathbf{r}, h)\\, dV$。由于 $W$ 仅依赖于 $r$，您必须将体积元 $dV$ 表示为 $r$ 的函数：\n    - 对于 $d = 1$，$dV = 2\\, dr$，积分区间为 $r \\in [0, 2h]$。\n    - 对于 $d = 2$，$dV = 2\\pi r\\, dr$，积分区间为 $r \\in [0, 2h]$。\n    - 对于 $d = 3$，$dV = 4\\pi r^2\\, dr$，积分区间为 $r \\in [0, 2h]$。\n- 使用 $N$ 个采样点的均匀划分和复合梯形法则，在区间 $r \\in [0, 2h]$ 上执行数值积分。\n- 对于每个测试用例，计算数值近似值\n$$\nI(d,h,N) \\approx \\int_0^{2h} W(r,h)\\, S_d(r)\\, dr,\n$$\n其中 $S_d(r)$ 是相应的径向曲面测度因子，具体为 $S_1(r) = 2$，$S_2(r) = 2\\pi r$ 和 $S_3(r) = 4\\pi r^2$。\n\n输出规范：\n- 对于每个测试用例，返回一个布尔值，指示数值近似值 $I(d,h,N)$ 是否在 $1$ 的 $10^{-5}$ 容差范围内，即 $\\lvert I(d,h,N) - 1 \\rvert \\le 10^{-5}$ 是否成立。\n- 最终的程序输出必须是单行文本，其中包含所有测试用例的结果，格式为方括号内以逗号分隔的列表（例如 $[true,false,true]$，Python布尔值写作 $True$ 或 $False$）。\n\n单位规范：\n- 积分 $\\int W\\, dV$ 是无量纲的。所有报告的布尔值也都是无单位的。\n\n测试套件：\n评估以下测试用例，每个用例由元组 $(d,h,N)$ 给出：\n1. $(1, 0.05, 100)$：一维正常路径，小 $h$ 和中等分辨率 $N$。\n2. $(2, 0.05, 100)$：二维正常路径，小 $h$ 和中等分辨率 $N$。\n3. $(3, 0.05, 100)$：三维正常路径，小 $h$ 和中等分辨率 $N$。\n4. $(3, 1.0, 1000)$：三维较大 $h$，高分辨率 $N$。\n5. $(2, 0.5, 600)$：二维中等 $h$，高分辨率 $N$。\n6. $(1, 2.0, 1200)$：一维较大 $h$，高分辨率 $N$。\n\n您的程序必须实现以上要求，并生成一行输出，其中按顺序包含六个布尔值，格式为方括号内以逗号分隔的列表。", "solution": "用户提供的问题是有效的。这是一个来自计算科学领域的适定（well-posed）、有科学依据的任务，具体涉及验证平滑粒子流体动力学（SPH）核函数的一个基本属性。所有必要信息均已提供，任务是基于标准的数学和算法原理实现一个数值实验。\n\n该解决方案基于以下原理及其到算法的转换进行设计。\n\n### 1. 核函数归一化原理\n\n在SPH中，物理量通过对邻近粒子的贡献求和来近似，这些贡献由核函数 $W$ 加权。为使该方法准确并守恒质量等物理量，核函数必须被归一化。这意味着它在整个空间上的积分必须等于1：\n$$\n\\int_{\\mathbb{R}^d} W(\\mathbf{r}, h) \\, dV = 1\n$$\n这里，$d$ 是空间维数，$h$ 是定义核函数支撑域大小的平滑长度，$dV$ 是体积元。本问题要求对三次样条核函数的这一性质进行数值验证。\n\n### 2. 三次样条核函数\n\n问题提供了标准三次样条核函数的定义，它是一个具有紧支撑（即仅在 $r  2h$ 时非零）的分段多项式函数。其公式为：\n$$\nW(r,h) = \\frac{\\sigma_d}{h^d}\n\\begin{cases}\n1 - \\frac{3}{2} q^2 + \\frac{3}{4} q^3, 0 \\le q  1, \\\\\n\\frac{1}{4} (2 - q)^3, 1 \\le q  2, \\\\\n0, q \\ge 2,\n\\end{cases}\n$$\n其中 $r = \\lVert \\mathbf{r} \\rVert$ 是径向距离，$q = r/h$ 是归一化半径，$\\sigma_d$ 是一个与维度相关的常数（$\\sigma_1 = 2/3$，$\\sigma_2 = 10/(7\\pi)$，$\\sigma_3 = 1/\\pi$），其取值经过专门选择，以确保归一化性质在解析上成立。\n\n该核函数的算法实现涉及创建一个函数，该函数以 $r$、$h$ 和 $d$ 作为输入。在此函数内部，计算 $q$ 的值。需要使用条件逻辑根据 $q$ 的值选择正确的多项式段。为了对 $r$ 值数组进行高效计算，NumPy的布尔数组掩码是向量化地应用分段公式的理想选择。\n\n### 3. 积分的径向简化\n\n核函数 $W(r,h)$ 是径向对称的，意味着其值仅取决于到原点的距离 $r$，而与方向无关。这种对称性使得 $d$ 维积分可以被显著简化。我们可以将积分从笛卡尔坐标系转换到广义球坐标系。体积元 $dV$ 变为 $r$ 和角度变量的函数。首先对角度变量进行积分，会得到一个因子，即半径为 $r$ 的超球体的表面积。这将多维积分简化为关于径向坐标 $r$ 的一维积分。\n$$\n\\int_{\\mathbb{R}^d} W(\\mathbf{r}, h) \\, dV = \\int_0^\\infty W(r,h) \\, S_d(r) \\, dr\n$$\n其中 $S_d(r)$ 是问题描述中提供的“曲面测度因子”：\n- 对于 $d=1$： “体积”元是 $dx$。积分为 $\\int_{-2h}^{2h} W(x,h) dx$。由于偶对称性（$W$ 依赖于 $r=|x|$），这等于 $2 \\int_0^{2h} W(r,h) dr$。因此，$S_1(r) = 2$。\n- 对于 $d=2$：体积元为 $dV = r \\, dr \\, d\\theta$。对 $\\theta$ 从 $0$ 到 $2\\pi$ 积分，得到一个因子 $2\\pi$。因此，$S_2(r) = 2\\pi r$。\n- 对于 $d=3$：体积元为 $dV = r^2 \\sin\\theta \\, dr \\, d\\theta \\, d\\phi$。对立体角（$\\int_0^{2\\pi} \\int_0^\\pi \\sin\\theta \\, d\\theta \\, d\\phi$）积分，得到 $4\\pi$。因此，$S_3(r) = 4\\pi r^2$。\n\n由于核函数在 $r=2h$ 之前具有紧支撑（即对于 $r \\ge 2h$，$W(r,h) = 0$），积分上限变为 $2h$。最终需要数值计算的积分是：\n$$\nI(d,h) = \\int_0^{2h} W(r,h) \\, S_d(r) \\, dr\n$$\n被积函数是 $f(r) = W(r,h) S_d(r)$。算法将通过首先计算核函数值 $W(r,h)$，然后乘以基于维度 $d$ 选择的适当因子 $S_d(r)$ 来构造此被积函数。\n\n### 4. 通过复合梯形法则进行数值积分\n\n为近似定积分 $I(d,h)$，问题指定了复合梯形法则。该方法通过将积分区间 $[0, 2h]$ 分为若干子区间，并对连接每个子区间端点函数值所构成的梯形面积求和，来近似被积函数下方的面积。\n\n对于一个由 $N$ 个等距点 $\\{r_0, \\dots, r_{N-1}\\}$ 划分为 $N-1$ 个子区间的区间 $[a,b]$，步长为 $\\Delta r = (b-a)/(N-1)$，其公式为：\n$$\n\\int_a^b f(r) dr \\approx \\frac{\\Delta r}{2} \\sum_{i=0}^{N-2} (f(r_i) + f(r_{i+1}))\n$$\n该方法实现简单，非常适合本问题中的连续被积函数。复合梯形法则的误差随着点数 $N$ 的增加而减小。\n\n算法实现使用 `numpy.linspace(0, 2*h, N)` 生成包含 $N$ 个采样点 `r_vals` 的数组。然后计算相应的被积函数值 `f_vals`。`numpy.trapz(f_vals, r_vals)` 函数提供了复合梯形法则的直接、高效且数值稳定的实现，用于计算定积分的近似值。\n\n### 5. 算法综合\n\n完整的算法结构如下：\n1.  一个主函数 `solve` 遍历测试用例列表 $(d,h,N)$。\n2.  对于每个测试用例，调用一个辅助函数，例如 `calculate_integral_and_check_norm`。\n3.  该辅助函数首先生成一个包含 $N$ 个径向点 $r_i$ 的数组，这些点在 $0$ 到 $2h$ 之间均匀分布。\n4.  然后它调用一个专门的核函数 `cubic_spline_kernel(r, h, d)`，该函数通过向量化操作计算所有点的核函数值 $W(r_i,h)$。\n5.  接着，该辅助函数根据维度 $d$ 选择正确的 $S_d(r_i)$，计算完整的被积函数值 $f(r_i) = W(r_i, h) S_d(r_i)$。\n6.  使用 `numpy.trapz` 计算数值积分 $I(d,h,N)$。\n7.  将绝对差 $|I(d,h,N) - 1|$ 与指定的容差 $10^{-5}$ 进行比较。\n8.  返回一个布尔结果（`True` 或 `False`）并附加到结果列表中。\n9.  最后，`solve` 函数将此布尔值列表格式化为所需的输出字符串 `\"[True,False,...]\"` 并打印出来。\n\n这种设计将数学原理直接转化为一个模块化且可验证的程序。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef cubic_spline_kernel(r: np.ndarray, h: float, d: int) - np.ndarray:\n    \"\"\"\n    Computes the SPH cubic spline kernel W(r, h) for a given dimension d.\n    The input r is expected to be a NumPy array.\n    \"\"\"\n    # 1. Determine the dimension-dependent normalization constant sigma_d.\n    if d == 1:\n        sigma_d = 2.0 / 3.0\n    elif d == 2:\n        sigma_d = 10.0 / (7.0 * np.pi)\n    elif d == 3:\n        sigma_d = 1.0 / np.pi\n    else:\n        # This case should not be reached with the given test suite.\n        raise ValueError(\"Dimension d must be 1, 2, or 3.\")\n\n    # 2. Calculate the normalized radius q = r/h.\n    # A small epsilon is added to h to avoid division by zero if h is ever 0.\n    q = r / (h + 1e-12)\n\n    # 3. Apply the piecewise function definition using boolean masking for vectorization.\n    # Initialize an array of zeros with the same shape as q.\n    kernel_values_unscaled = np.zeros_like(q, dtype=float)\n\n    # Condition for 0 = q  1\n    mask1 = q  1.0\n    q1 = q[mask1]\n    kernel_values_unscaled[mask1] = 1.0 - 1.5 * q1**2 + 0.75 * q1**3\n\n    # Condition for 1 = q  2\n    mask2 = (q = 1.0)  (q  2.0)\n    q2 = q[mask2]\n    kernel_values_unscaled[mask2] = 0.25 * (2.0 - q2)**3\n\n    # For q = 2, the values remain 0 as initialized.\n\n    # 4. Scale by the main normalization factor.\n    normalization_factor = sigma_d / (h**d)\n    return normalization_factor * kernel_values_unscaled\n\ndef calculate_integral_and_check_norm(d: int, h: float, N: int) - bool:\n    \"\"\"\n    Numerically integrates the kernel for a given test case and checks if it's normalized.\n    It returns True if |integral - 1| = 1e-5, and False otherwise.\n    \"\"\"\n    # Tolerance for checking the normalization.\n    tolerance = 1e-5\n\n    # 1. Set up the integration domain [0, 2h] and N sample points.\n    r_vals = np.linspace(0.0, 2.0 * h, N)\n\n    # 2. Calculate the kernel values at the sample points.\n    W_vals = cubic_spline_kernel(r_vals, h, d)\n\n    # 3. Calculate the full integrand, W(r,h) * S_d(r), where S_d is the surface measure.\n    if d == 1:\n        # S_1(r) = 2\n        integrand = 2.0 * W_vals\n    elif d == 2:\n        # S_2(r) = 2 * pi * r\n        integrand = 2.0 * np.pi * r_vals * W_vals\n    else:  # d == 3\n        # S_3(r) = 4 * pi * r^2\n        integrand = 4.0 * np.pi * r_vals**2 * W_vals\n    \n    # 4. Perform numerical integration using the composite trapezoid rule.\n    # np.trapz implements this rule efficiently.\n    integral_value = np.trapz(integrand, r_vals)\n\n    # 5. Check if the result is within the specified tolerance of 1.\n    is_normalized = abs(integral_value - 1.0) = tolerance\n    return is_normalized\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiment for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (d, h, N).\n    test_cases = [\n        (1, 0.05, 100),\n        (2, 0.05, 100),\n        (3, 0.05, 100),\n        (3, 1.0, 1000),\n        (2, 0.5, 600),\n        (1, 2.0, 1200),\n    ]\n\n    results = []\n    for case in test_cases:\n        d, h, N = case\n        # For each case, calculate the integral and check the normalization condition.\n        result = calculate_integral_and_check_norm(d, h, N)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # str(True) is 'True', str(False) is 'False', matching problem requirements.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3194379"}, {"introduction": "在验证了核函数本身的基本性质后，我们进一步考察其梯度特性，这对模拟流体动力学至关重要。核函数梯度的反对称性（$\\nabla_i W_{ij} = -\\nabla_j W_{ji}$）是牛顿第三定律在SPH框架下的体现，直接保证了粒子间相互作用力的动量守恒。通过本练习，您将通过数值计算来验证这一关键对称性，加深对SPH方法中力计算的理解[@problem_id:3194364]。", "problem": "给定一个二维光滑粒子流体动力学 (SPH) 设置，其中光滑核函数仅取决于粒子间的标量距离。基于“核函数是粒子间距的径向对称函数”和“梯度遵循链式法则”这两个基本原理，您必须设计并实现一个数值测试。该测试需要针对几种不同的粒子排列，量化相对于一个粒子计算的核函数梯度在多大程度上是相对于另一个粒子计算的核函数梯度的负值。使用以下基础：欧几里得范数、梯度的链式法则以及径向对称光滑核函数。所有计算均在二维空间中进行，所有位置以米为单位，光滑长度也以米为单位。您的输出必须是无量纲的浮点数。\n\n在您的程序中实现以下内容：\n\n- 使用光滑粒子流体动力学 (SPH) 中的标准二维三次样条核函数。该核函数被定义为距离 $r$ 和光滑长度 $h$ 的函数，其中 $q = r / h$。核函数由下式给出：\n$$\nW(r, h) = \\alpha_2 \\times\n\\begin{cases}\n1 - \\tfrac{3}{2} q^2 + \\tfrac{3}{4} q^3, 0 \\le q  1, \\\\\n\\tfrac{1}{4} (2 - q)^3, 1 \\le q  2, \\\\\n0, q \\ge 2,\n\\end{cases}\n$$\n其中\n$$\n\\alpha_2 = \\frac{10}{7 \\pi h^2}.\n$$\n利用链式法则和径向对称性，相对于 $r$ 的梯度因子大小由 $\\tfrac{dW}{dr}$ 决定，其中\n$$\n\\frac{dW}{dr} =\n\\alpha_2 \\times \\frac{1}{h} \\times\n\\begin{cases}\n-3 q + \\tfrac{9}{4} q^2, 0 \\le q  1, \\\\\n-\\tfrac{3}{4} (2 - q)^2, 1 \\le q  2, \\\\\n0, q \\ge 2.\n\\end{cases}\n$$\n对于任意一对不同的粒子位置 $\\mathbf{x}_i$ 和 $\\mathbf{x}_j$，定义矢量位移 $\\mathbf{r}_{ij} = \\mathbf{x}_i - \\mathbf{x}_j$，其欧几里得范数 $r_{ij} = \\lVert \\mathbf{r}_{ij} \\rVert_2$，以及当 $r_{ij}  0$ 时的单位方向 $\\hat{\\mathbf{r}}_{ij} = \\mathbf{r}_{ij} / r_{ij}$。相对于粒子 $\\mathbf{x}_i$ 的梯度是通过将 $\\hat{\\mathbf{r}}_{ij}$ 乘以 $\\tfrac{dW}{dr}$ 得到的，而相对于粒子 $\\mathbf{x}_j$ 的梯度也以类似方式得到。当 $r_{ij} = 0$ 时，定义梯度为零矢量。\n\n- 对于下述每个测试用例，计算所有无序粒子对的最大相对不对称性 $\\rho$，定义为\n$$\n\\rho = \\max_{i  j} \\frac{\\left\\lVert \\nabla_{\\mathbf{x}_i} W_{ij} + \\nabla_{\\mathbf{x}_j} W_{ji} \\right\\rVert_2}{\\left\\lVert \\nabla_{\\mathbf{x}_i} W_{ij} \\right\\rVert_2 + \\left\\lVert \\nabla_{\\mathbf{x}_j} W_{ji} \\right\\rVert_2 + \\epsilon},\n$$\n其中 $\\epsilon = 10^{-30}$ 用于避免除以 $0$。为每个测试用例报告 $\\rho$，它是一个无量纲的浮点数。当梯度完全反对称时，该度量等于 $0$；如果数值计算与理论性质一致，则该度量很小（接近机器精度）。\n\n测试套件和参数：\n\n- 用例 $1$ (理想情况)：在 $[0, 1] \\times [0, 1]$ 米范围内，使用伪随机种子 $123$ 均匀采样 $N = 20$ 个点，光滑长度 $h = 0.12$ 米。\n- 用例 $2$ (共线对称)：沿 $x$ 轴分布的 $N = 8$ 个点，其 $x$ 坐标为 $\\{-0.5, -0.25, -0.1, -0.01, 0.01, 0.1, 0.25, 0.5\\}$ 米，$y = 0$ 米，光滑长度 $h = 0.10$ 米。\n- 用例 $3$ (均匀网格)：在覆盖 $[0, 1] \\times [0, 1]$ 米范围的 $5 \\times 5$ 均匀网格上的 $N = 25$ 个点，光滑长度 $h = 0.08$ 米。\n- 用例 $4$ (近重合边缘情况)：通过在 $[0.4, 0.6] \\times [0.4, 0.6]$ 米范围内使用伪随机种子 $321$ 均匀采样 $5$ 个基点，然后将每个基点复制一份并添加 $\\delta = 10^{-12}$ 米的 $x$ 方向偏移，共创建 $N = 10$ 个点，光滑长度 $h = 0.05$ 米。\n- 用例 $5$ (各向异性矩形)：在 $[0, 2] \\times [0, 0.1]$ 米范围内，使用伪随机种子 $456$ 均匀采样 $N = 30$ 个点，光滑长度 $h = 0.20$ 米。\n\n单位和输出：\n\n- 所有位置以米为单位，光滑长度也以米为单位。\n- 报告的 $\\rho$ 值是无量纲的，必须作为十进制浮点数输出。\n- 您的程序应生成单行输出，其中包含五个用例的结果，格式为用方括号括起来的逗号分隔列表，按用例 $1$ 到 $5$ 的顺序排列，例如 $[r_1, r_2, r_3, r_4, r_5]$。\n\n约束和实现细节：\n\n- 使用双精度浮点数算术。\n- 当 $r_{ij} = 0$ 时，将梯度定义为零矢量以避免除以 $0$，这与径向对称性一致。\n- 对所有矢量范数使用欧几里得二范数。\n- 除已声明的假设外，不要做任何外部假设，并确保科学真实性。", "solution": "用户提供了一个计算科学领域的问题，具体涉及光滑粒子流体动力学 (SPH)。通过对其科学和数学基础、完整性以及内部一致性的严格审查，该问题的有效性已得到确认。此问题是适定的，并提供了一个有意义的数值任务。因此，有必要提供一个完整的解决方案。\n\n这个问题的核心是数值上测试 SPH 核函数的一个基本性质：光滑核函数梯度的反对称性。这个性质是核函数作为两粒子间距离的径向对称函数的直接结果。它对于确保 SPH 模拟中的线性动量守恒至关重要，因为它有效地体现了粒子对相互作用的牛顿第三定律。\n\n让我们首先将理论原理形式化。光滑核函数 $W$ 是两个粒子位置 $\\mathbf{x}_i$ 和 $\\mathbf{x}_j$ 的函数，通过标量距离 $r_{ij} = \\lVert \\mathbf{x}_i - \\mathbf{x}_j \\rVert_2$ 来体现。我们将其表示为 $W_{ij} = W(r_{ij}, h)$，其中 $h$ 是光滑长度。\n\n核函数相对于粒子 $i$ 坐标的梯度 $\\nabla_{\\mathbf{x}_i} W_{ij}$ 可以使用链式法则求得：\n$$\n\\nabla_{\\mathbf{x}_i} W_{ij} = \\frac{d W(r_{ij}, h)}{d r_{ij}} \\nabla_{\\mathbf{x}_i} r_{ij}\n$$\n距离 $r_{ij} = \\sqrt{(\\mathbf{x}_i - \\mathbf{x}_j) \\cdot (\\mathbf{x}_i - \\mathbf{x}_j)}$ 相对于 $\\mathbf{x}_i$ 的梯度是指向从 $\\mathbf{x}_j$ 到 $\\mathbf{x}_i$ 的单位矢量：\n$$\n\\nabla_{\\mathbf{x}_i} r_{ij} = \\frac{\\mathbf{x}_i - \\mathbf{x}_j}{\\lVert \\mathbf{x}_i - \\mathbf{x}_j \\rVert_2} = \\hat{\\mathbf{r}}_{ij}\n$$\n因此，核函数相对于 $\\mathbf{x}_i$ 的梯度是：\n$$\n\\nabla_{\\mathbf{x}_i} W_{ij} = \\frac{d W}{d r_{ij}} \\hat{\\mathbf{r}}_{ij}\n$$\n\n问题要求我们考虑和 $\\nabla_{\\mathbf{x}_i} W_{ij} + \\nabla_{\\mathbf{x}_j} W_{ji}$。项 $\\nabla_{\\mathbf{x}_j} W_{ji}$ 是对粒子对 $(j, i)$ 求值的核函数梯度，取其相对于粒子 $j$ 坐标的梯度。遵循同样的推导过程：\n$$\n\\nabla_{\\mathbf{x}_j} W_{ji} = \\frac{d W(r_{ji}, h)}{d r_{ji}} \\nabla_{\\mathbf{x}_j} r_{ji}\n$$\n其中 $r_{ji} = \\lVert \\mathbf{x}_j - \\mathbf{x}_i \\rVert_2$，单位矢量为 $\\hat{\\mathbf{r}}_{ji} = \\frac{\\mathbf{x}_j - \\mathbf{x}_i}{\\lVert \\mathbf{x}_j - \\mathbf{x}_i \\rVert_2}$。\n\n根据欧几里得范数和矢量减法的性质：\n1.  距离相等：$r_{ij} = \\lVert \\mathbf{x}_i - \\mathbf{x}_j \\rVert_2 = \\lVert -(\\mathbf{x}_j - \\mathbf{x}_i) \\rVert_2 = \\lVert \\mathbf{x}_j - \\mathbf{x}_i \\rVert_2 = r_{ji}$。\n2.  单位矢量反平行：$\\hat{\\mathbf{r}}_{ij} = \\frac{\\mathbf{x}_i - \\mathbf{x}_j}{r_{ij}} = -\\frac{\\mathbf{x}_j - \\mathbf{x}_i}{r_{ji}} = -\\hat{\\mathbf{r}}_{ji}$。\n\n由于 $r_{ij} = r_{ji}$，导数项 $\\frac{dW}{dr}$ 在两次计算中是相同的。因此，我们有：\n$$\n\\nabla_{\\mathbf{x}_j} W_{ji} = \\frac{d W}{d r_{ij}} (-\\hat{\\mathbf{r}}_{ij}) = - \\left( \\frac{d W}{d r_{ij}} \\hat{\\mathbf{r}}_{ij} \\right) = - \\nabla_{\\mathbf{x}_i} W_{ij}\n$$\n解析上，这导致了精确的反对称性质：\n$$\n\\nabla_{\\mathbf{x}_i} W_{ij} + \\nabla_{\\mathbf{x}_j} W_{ji} = \\mathbf{0}\n$$\n\n该数值测试的目的是验证这个解析结果在有限精度浮点运算下的保持情况。度量 $\\rho$ 旨在测量梯度之和的量级与它们各自量级之和的相对大小。\n$$\n\\rho = \\max_{i  j} \\frac{\\left\\lVert \\nabla_{\\mathbf{x}_i} W_{ij} + \\nabla_{\\mathbf{x}_j} W_{ji} \\right\\rVert_2}{\\left\\lVert \\nabla_{\\mathbf{x}_i} W_{ij} \\right\\rVert_2 + \\left\\lVert \\nabla_{\\mathbf{x}_j} W_{ji} \\right\\rVert_2 + \\epsilon}\n$$\n$\\rho = 0$ 的值表示与理论完美的数值吻合，而一个小的非零值则表示由于浮点表示和运算引起的微小偏差。小常数 $\\epsilon = 10^{-30}$ 确保了当两个梯度都为零时（例如，对于彼此光滑半径之外的粒子）的数值稳定性。\n\n解决每个测试用例的算法如下：\n1.  根据测试用例的规范生成粒子位置 $(\\mathbf{x}_1, \\ldots, \\mathbf{x}_N)$。\n2.  初始化变量 $\\rho_{\\max} = 0$。\n3.  遍历所有唯一的无序粒子对 $(i, j)$，其中 $i  j$。\n4.  对于每一对粒子，执行两次独立且完整的计算来确定梯度，从而让任何浮点不精确性得以显现：\n    a. 计算 $\\nabla_{\\mathbf{x}_i} W_{ij}$。这涉及计算 $\\mathbf{r}_{ij} = \\mathbf{x}_i - \\mathbf{x}_j$、$r_{ij} = \\lVert \\mathbf{r}_{ij} \\rVert_2$、$\\hat{\\mathbf{r}}_{ij} = \\mathbf{r}_{ij} / r_{ij}$，并使用所提供的三次样条核函数的分段公式计算导数大小 $\\frac{dW}{dr}(r_{ij}, h)$。\n    b. 类似地，通过计算 $\\mathbf{r}_{ji} = \\mathbf{x}_j - \\mathbf{x}_i$、$r_{ji} = \\lVert \\mathbf{r}_{ji} \\rVert_2$ 等来计算 $\\nabla_{\\mathbf{x}_j} W_{ji}$。\n5.  如果 $r_{ij} = 0$，梯度被定义为零矢量。\n6.  使用 $\\rho$ 的公式计算每对粒子的不对称性 $\\rho_{ij}$。\n7.  更新最大值：$\\rho_{\\max} = \\max(\\rho_{\\max}, \\rho_{ij})$。\n8.  $\\rho_{\\max}$ 的最终值即为该测试用例的结果。\n\n这五个测试用例旨在探究不同粒子配置下的这一性质：一般随机分布、高度对称的共线排列、规则网格、包含近乎重合粒子以测试数值精度的案例，以及各向异性分布。这为 SPH 梯度公式的数值鲁棒性提供了全面的测试。实现将使用 `numpy` 中标准的双精度浮点数算术。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef dWdr_cubic_spline_2d(r, h):\n    \"\"\"\n    Computes the magnitude of the gradient factor dW/dr for the 2D cubic spline kernel.\n\n    Args:\n        r (float): The scalar separation distance between two particles.\n        h (float): The smoothing length.\n\n    Returns:\n        float: The value of dW/dr.\n    \"\"\"\n    # The problem provides the normalization constant alpha_2.\n    alpha_2 = 10.0 / (7.0 * np.pi * h**2)\n    q = r / h\n\n    # The gradient factor depends on the value of q.\n    if q = 2.0:\n        # Outside kernel support (compact support radius is 2h)\n        return 0.0\n    elif q = 1.0:\n        # For 1 = q  2\n        factor = -0.75 * (2.0 - q)**2\n    elif q = 0.0:\n        # For 0 = q  1\n        factor = -3.0 * q + (9.0 / 4.0) * q**2\n    else:\n        # This case should not be reached as r is a norm and is non-negative.\n        return 0.0\n    \n    # The full derivative is dW/dr = (1/h) * dW/dq\n    return alpha_2 * factor / h\n\ndef solve():\n    \"\"\"\n    Main function to run the five test cases and compute the maximum relative asymmetry rho.\n    \"\"\"\n    # Epsilon for numerical stability, as specified.\n    epsilon = 1e-30\n    \n    # List of parameters for each test case from the problem statement.\n    test_params = [\n        {'case': 1, 'N': 20, 'h': 0.12, 'seed': 123},\n        {'case': 2, 'N': 8, 'h': 0.10},\n        {'case': 3, 'N': 25, 'h': 0.08},\n        {'case': 4, 'N': 10, 'h': 0.05, 'seed': 321, 'delta': 1e-12},\n        {'case': 5, 'N': 30, 'h': 0.20, 'seed': 456},\n    ]\n\n    results = []\n    \n    # Process each test case.\n    for params in test_params:\n        # Step 1: Generate particle positions based on case-specific rules.\n        if params['case'] == 1:\n            rng = np.random.default_rng(params['seed'])\n            positions = rng.uniform(low=0.0, high=1.0, size=(params['N'], 2))\n        elif params['case'] == 2:\n            x_coords = np.array([-0.5, -0.25, -0.1, -0.01, 0.01, 0.1, 0.25, 0.5])\n            positions = np.zeros((params['N'], 2))\n            positions[:, 0] = x_coords\n        elif params['case'] == 3:\n            grid_points = np.linspace(0.0, 1.0, 5)\n            x, y = np.meshgrid(grid_points, grid_points)\n            positions = np.vstack([x.ravel(), y.ravel()]).T\n        elif params['case'] == 4:\n            rng = np.random.default_rng(params['seed'])\n            num_base_points = params['N'] // 2\n            base_points = rng.uniform(low=0.4, high=0.6, size=(num_base_points, 2))\n            offset_points = base_points.copy()\n            offset_points[:, 0] += params['delta']\n            positions = np.concatenate((base_points, offset_points))\n        elif params['case'] == 5:\n            rng = np.random.default_rng(params['seed'])\n            positions = rng.uniform(low=[0.0, 0.0], high=[2.0, 0.1], size=(params['N'], 2))\n\n        N = params['N']\n        h = params['h']\n        max_rho = 0.0\n\n        # Step 2: Iterate over all unique particle pairs (i, j) with i  j.\n        for i in range(N):\n            for j in range(i + 1, N):\n                # Perform two independent calculations to expose potential floating-point differences.\n                \n                # --- Gradient calculation for Nabla_i(W_ij) ---\n                vec_ij = positions[i] - positions[j]\n                norm_ij = np.linalg.norm(vec_ij)\n\n                if norm_ij == 0.0:\n                    # Gradients are zero vectors by definition for coincident particles. \n                    grad_i_Wij = np.zeros(2)\n                else:\n                    dwdr_val_ij = dWdr_cubic_spline_2d(norm_ij, h)\n                    grad_i_Wij = dwdr_val_ij * vec_ij / norm_ij\n\n                # --- Gradient calculation for Nabla_j(W_ji) ---\n                vec_ji = positions[j] - positions[i]\n                norm_ji = np.linalg.norm(vec_ji)\n                \n                if norm_ji == 0.0:\n                    grad_j_Wji = np.zeros(2)\n                else: \n                    dwdr_val_ji = dWdr_cubic_spline_2d(norm_ji, h)\n                    grad_j_Wji = dwdr_val_ji * vec_ji / norm_ji\n\n                # Step 3: Compute the asymmetry metric rho_ij for the pair.\n                numerator = np.linalg.norm(grad_i_Wij + grad_j_Wji)\n                denominator = np.linalg.norm(grad_i_Wij) + np.linalg.norm(grad_j_Wji) + epsilon\n\n                if denominator > epsilon:\n                    rho_ij = numerator / denominator\n                else: # This occurs if both gradients are zero.\n                    rho_ij = 0.0\n                \n                # Step 4: Update the maximum asymmetry found so far.\n                if rho_ij > max_rho:\n                    max_rho = rho_ij\n        \n        results.append(max_rho)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3194364"}, {"introduction": "掌握了核函数及其梯度的基本性质后，现在是时候将它们应用于一个核心的SPH计算任务：密度估计。这个练习将引导您探究粒子排布的有序性（如晶格）与无序性（如玻璃态）对SPH密度估计精度的影响。通过量化不同粒子分布下的计算误差，您将直观地理解“粒子不一致性”这一SPH方法固有的挑战，并认识到粒子分布对模拟结果质量的重要性[@problem_id:2439536]。", "problem": "要求您定量评估粒子无序性如何影响二维均匀可压缩流体的平滑粒子流体动力学（SPH）密度估计的准确性。考虑一个流体，占据一个边长为 $L=1$、面积为 $A=L^2=1$ 的周期性单位正方形区域。该流体具有恒定的表面密度 $\\rho_0=1$，以无量纲单位表示。该区域由 $N$ 个等质量粒子填充，其位置为 $\\{\\mathbf{r}_i\\}_{i=1}^N$，总质量为 $M=\\rho_0 A=1$，因此每个粒子的质量为 $m=M/N=1/N$。\n\n对于任何粒子 $i$，SPH 密度估计定义为\n$$\n\\rho_i \\equiv \\sum_{j=1}^N m\\, W\\!\\left(\\left\\|\\mathbf{r}_i - \\mathbf{r}_j\\right\\|_\\mathrm{per},\\, h\\right),\n$$\n其中 $\\|\\cdot\\|_\\mathrm{per}$ 表示单位环面上的最小镜像周期距离，$W(r,h)$ 是二维空间中标准的三次样条 SPH 核函数，其紧支集为 $2h$，平滑长度为 $h$。平滑长度必须选择为\n$$\nh = \\eta \\,\\Delta, \\quad \\text{with} \\quad \\Delta = \\sqrt{\\frac{A}{N}} = \\frac{1}{\\sqrt{N}},\n$$\n其中固定常数 $\\eta=1.2$。\n\n对于每个指定的 $N$ 值，必须考虑两种不同的粒子排列：\n\n- 晶格排列：粒子放置在具有周期性边界的单位正方形内的一个大小为 $\\sqrt{N}\\times\\sqrt{N}$ 的规则正方形晶格上。\n- 类玻璃体排列：粒子放置在基数为 2 和 3 的二维 Halton 序列的前 $N$ 个点上，即对于 $k=1,2,\\ldots,N$，其位置为 $\\mathbf{r}_k=\\big(\\phi_2(k),\\,\\phi_3(k)\\big)$，其中 $\\phi_b(k)$ 是基数 $b$ 的根倒数函数。\n\n对于每种排列和每个 $N$，计算以下无量纲误差度量，以比较 SPH 密度估计 $\\{\\rho_i\\}$ 与精确的均匀密度 $\\rho_0$：\n- 平均绝对相对误差，\n$$\nE_1 = \\frac{1}{N}\\sum_{i=1}^N \\frac{\\left|\\rho_i-\\rho_0\\right|}{\\rho_0}.\n$$\n- 均方根相对误差，\n$$\nE_2 = \\frac{1}{\\sqrt{N}}\\left(\\sum_{i=1}^N \\left(\\frac{\\rho_i-\\rho_0}{\\rho_0}\\right)^2\\right)^{1/2}.\n$$\n- 最大相对误差，\n$$\nE_\\infty = \\max_{1\\le i\\le N} \\frac{\\left|\\rho_i-\\rho_0\\right|}{\\rho_0}.\n$$\n\n在整个计算过程中严格使用无量纲单位，并将所有误差值表示为小数（而非百分比）。对于每个误差度量，将结果四舍五入到六位小数。\n\n测试套件：\n对于以下有序的测试用例列表，评估三元组 $\\big[E_1,E_2,E_\\infty\\big]$，其中每个用例指定一个序对 $(N,\\text{排列})$：\n- $(N=100,\\;\\text{晶格})$\n- $(N=100,\\;\\text{类玻璃体})$\n- $(N=256,\\;\\text{晶格})$\n- $(N=256,\\;\\text{类玻璃体})$\n- $(N=441,\\;\\text{晶格})$\n- $(N=441,\\;\\text{类玻璃体})$\n\n在核函数评估中，对所有粒子对间距采用单位正方形环面上的最小镜像周期距离。对于晶格排列中的每个 $N$，假定 $N$ 是一个完全平方数，以使晶格为 $\\sqrt{N}\\times\\sqrt{N}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表，每个内部列表对应一个按指定顺序排列的测试用例，并按 $\\big[E_1,E_2,E_\\infty\\big]$ 的顺序包含三个四舍五入后的误差值。例如：\n\"[[e11,e12,e13],[e21,e22,e23],...]\"\n确保数值四舍五入到六位小数，并且除了这单行输出外没有其他文本。在所有计算和输出中使用无量纲单位。", "solution": "问题陈述已经过验证，并被确定为科学上合理、适定且完整。它构成了计算物理学领域中的一个标准数值实验，旨在评估平滑粒子流体动力学（SPH）方法的准确性。任务是计算二维粒子分布的密度误差。将采用如下的直接计算方法。\n\nSPH方法的核心是通过对一组离散粒子的求和来表示连续场 $A(\\mathbf{r})$。对于密度场 $\\rho$，这表示为：\n$$\n\\rho(\\mathbf{r}) = \\sum_{j} m_j W\\left(\\left\\|\\mathbf{r} - \\mathbf{r}_j\\right\\|,\\, h\\right)\n$$\n其中 $m_j$ 和 $\\mathbf{r}_j$ 分别是粒子 $j$ 的质量和位置，$W$ 是一个具有特征宽度 $h$（即平滑长度）的平滑核函数。问题将位于位置 $\\mathbf{r}_i$ 的粒子 $i$ 的SPH密度估计指定为：\n$$\n\\rho_i = \\sum_{j=1}^N m\\, W\\!\\left(\\left\\|\\mathbf{r}_i - \\mathbf{r}_j\\right\\|_\\mathrm{per},\\, h\\right)\n$$\n计算区域是一个二维单位正方形，具有周期性边界条件，面积 $A=1$，总质量 $M=1$。流体具有恒定的参考表面密度 $\\rho_0=1$。对于 $N$ 个粒子，每个粒子的质量因此为 $m = M/N = 1/N$。距离 $\\|\\mathbf{r}_i - \\mathbf{r}_j\\|_\\mathrm{per}$ 是单位环面上的最小镜像距离，对于位移矢量 $\\Delta\\mathbf{r} = (\\Delta x, \\Delta y)$，其计算公式为 $\\sqrt{(\\Delta x - \\text{round}(\\Delta x))^2 + (\\Delta y - \\text{round}(\\Delta y))^2}$。\n\n平滑长度 $h$ 与平均粒子间距 $\\Delta$ 相关。对于一个面积为 $A=1$、包含 $N$ 个粒子的二维区域，平均间距为 $\\Delta = \\sqrt{A/N} = 1/\\sqrt{N}$。平滑长度设定为 $h = \\eta \\Delta$，其中常数 $\\eta = 1.2$。\n\n核函数 $W(r, h)$ 是二维的标准三次样条函数，仅当 $r \\le 2h$ 时非零。其解析形式为：\n$$\nW(r,h) = \\frac{10}{7\\pi h^2} \\times \\begin{cases} 1 - \\frac{3}{2}q^2 + \\frac{3}{4}q^3  0 \\le q \\le 1 \\\\ \\frac{1}{4}(2-q)^3  1  q \\le 2 \\\\ 0  q  2 \\end{cases}\n$$\n其中 $q = r/h$ 是归一化距离。\n\n该分析需要两种粒子构型：\n1.  **晶格排列**：粒子被放置在一个均匀的 $\\sqrt{N} \\times \\sqrt{N}$ 网格上。对于 $i,j \\in \\{0, 1, \\dots, \\sqrt{N}-1\\}$，粒子 $(i,j)$ 的坐标取为 $(\\frac{i+0.5}{\\sqrt{N}}, \\frac{j+0.5}{\\sqrt{N}})$。这确保了晶格在单位区域内居中。\n2.  **类玻璃体排列**：粒子被放置在基数为 2 和 3 的二维 Halton 序列的前 $N$ 个点上。第 $k$ 个粒子（$k=1, \\dots, N$）的位置是 $\\mathbf{r}_k = (\\phi_2(k), \\phi_3(k))$，其中 $\\phi_b(k)$ 是基数 $b$ 的根倒数函数。\n\n对于每种构型和指定的 $N$ 值，使用三种误差度量将 SPH 估计的密度 $\\{\\rho_i\\}_{i=1}^N$ 与精确密度 $\\rho_0=1$进行比较：\n-   平均绝对相对误差：$E_1 = \\frac{1}{N}\\sum_{i=1}^N |\\rho_i-1|$\n-   均方根相对误差：$E_2 = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N (\\rho_i-1)^2}$\n-   最大相对误差：$E_\\infty = \\max_{1\\le i\\le N} |\\rho_i-1|$\n\n计算过程如下：\n1.  对于由 $(N, \\text{排列})$ 指定的每个测试用例，生成粒子位置 $\\{\\mathbf{r}_i\\}$。\n2.  计算所有 $i,j \\in \\{1, \\dots, N\\}$ 的成对周期距离矩阵 $d_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|_\\mathrm{per}$。为提高效率，此计算被向量化。\n3.  对所有粒子对评估核函数 $W(d_{ij}, h)$，创建一个核函数值矩阵。\n4.  通过对核函数矩阵的第 $i$ 行求和并乘以粒子质量 $m=1/N$ 来计算每个粒子 $\\rho_i$ 的密度。\n5.  从计算出的密度向量中计算误差度量 $E_1, E_2, E_\\infty$。\n6.  根据要求，将最终误差值四舍五入到六位小数。\n\n整个过程使用 Python 的 `numpy` 库实现，以高效处理数组操作。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the SPH density error problem.\n    \"\"\"\n    \n    # Define the problem constants and test cases.\n    RHO_0 = 1.0\n    ETA = 1.2\n    \n    test_cases = [\n        (100, 'lattice'),\n        (100, 'glass'),\n        (256, 'lattice'),\n        (256, 'glass'),\n        (441, 'lattice'),\n        (441, 'glass'),\n    ]\n\n    # --- Helper functions ---\n\n    def radical_inverse(k, base):\n        \"\"\"Computes the radical inverse of k in a given base.\"\"\"\n        inv = 0.0\n        f = 1.0 / base\n        while k  0:\n            inv += (k % base) * f\n            k //= base\n            f /= base\n        return inv\n\n    def generate_lattice(n_particles):\n        \"\"\"Generates particle positions on a regular square lattice.\"\"\"\n        n_side = int(np.sqrt(n_particles))\n        if n_side**2 != n_particles:\n            raise ValueError(\"N must be a perfect square for lattice arrangement\")\n        \n        points = np.zeros((n_particles, 2))\n        dx = 1.0 / n_side\n        \n        idx = 0\n        for i in range(n_side):\n            for j in range(n_side):\n                points[idx, 0] = (i + 0.5) * dx\n                points[idx, 1] = (j + 0.5) * dx\n                idx += 1\n        return points\n\n    def generate_glass(n_particles):\n        \"\"\"Generates particle positions from a Halton sequence.\"\"\"\n        points = np.zeros((n_particles, 2))\n        for k in range(1, n_particles + 1):\n            points[k-1, 0] = radical_inverse(k, 2)\n            points[k-1, 1] = radical_inverse(k, 3)\n        return points\n\n    def W_cubic_spline_vectorized(r, h):\n        \"\"\"Vectorized 2D cubic spline SPH kernel.\"\"\"\n        alpha_d = 10.0 / (7.0 * np.pi * h**2)\n        q = r / h\n        \n        res = np.zeros_like(q)\n        \n        # Condition: 1  q = 2\n        mask1 = (q > 1.0)  (q = 2.0)\n        q1 = q[mask1]\n        res[mask1] = alpha_d * 0.25 * (2.0 - q1)**3\n        \n        # Condition: 0 = q = 1\n        mask2 = q = 1.0\n        q2 = q[mask2]\n        res[mask2] = alpha_d * (1.0 - 1.5 * q2**2 + 0.75 * q2**3)\n        \n        return res\n\n    def compute_errors(n_particles, arrangement_type):\n        \"\"\"\n        Computes the SPH density and error metrics for a given configuration.\n        \"\"\"\n        # 1. Set parameters\n        m = 1.0 / n_particles\n        delta = 1.0 / np.sqrt(n_particles)\n        h = ETA * delta\n\n        # 2. Generate particle positions\n        if arrangement_type == 'lattice':\n            positions = generate_lattice(n_particles)\n        elif arrangement_type == 'glass':\n            positions = generate_glass(n_particles)\n        else:\n            raise ValueError(f\"Unknown arrangement type: {arrangement_type}\")\n            \n        # 3. Compute pairwise periodic distances (vectorized)\n        delta_r = positions[:, np.newaxis, :] - positions[np.newaxis, :, :]\n        delta_r -= np.round(delta_r)  # Minimum image convention for unit domain\n        distances = np.linalg.norm(delta_r, axis=2)\n\n        # 4. Evaluate kernel for all pairs\n        kernel_values = W_cubic_spline_vectorized(distances, h)\n\n        # 5. Sum contributions to get densities\n        densities = m * np.sum(kernel_values, axis=1)\n\n        # 6. Compute error metrics\n        relative_errors = (densities - RHO_0) / RHO_0\n        \n        e1 = np.mean(np.abs(relative_errors))\n        e2 = np.sqrt(np.mean(relative_errors**2))\n        e_inf = np.max(np.abs(relative_errors))\n        \n        return [round(e1, 6), round(e2, 6), round(e_inf, 6)]\n\n    # --- Main execution loop ---\n    \n    all_results = []\n    for n, arr_type in test_cases:\n        errors = compute_errors(n, arr_type)\n        all_results.append(errors)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2439536"}]}