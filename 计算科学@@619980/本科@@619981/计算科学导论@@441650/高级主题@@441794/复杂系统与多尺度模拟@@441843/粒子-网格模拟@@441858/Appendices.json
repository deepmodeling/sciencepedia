{"hands_on_practices": [{"introduction": "在将连续的物理定律离散化为数值算法时，我们常常会引入一些非物理效应。在“粒子-网格”（PIC）方法中，一个最基本的数值产物就是“自作用力”。本练习将通过一个理想化的思想实验，帮助你从解析上理解自作用力的来源，并推导其大小，这对于评估和改进模拟的保真度至关重要。[@problem_id:296780]", "problem": "在使用线性权重（也称为云中单元法或 CIC）的一维静电粒子模拟 (PIC) 中，带电粒子与计算网格相互作用，产生一种非物理的“自作用力”。这种力的产生是由于粒子自身的电荷在分配到网格上时，会产生一个网格化的电场，该电场再经过插值后反作用于粒子本身。这种伪力是空间离散化的直接后果，它会导致数值加热和能量不守恒。\n\n对于一个无限长的一维系统中，电荷为 $q$、网格间距为 $\\Delta x$、真空介电常数为 $\\epsilon_0$ 的单个粒子，其自身网格化电场的势能 $U_{self}$ 可以证明会随着它在网格单元内的位置而变化。该势能以网格周期 $\\Delta x$ 呈周期性变化，在由网格节点 $x_j$ 和 $x_{j+1}$ 定义的给定单元内，其表达式为：\n$$\nU_{self}(x) = \\frac{q^2 \\Delta x}{2\\epsilon_0} u(1-u)\n$$\n其中 $u = \\frac{x - x_j}{\\Delta x}$ 是粒子在单元内的归一化位置，对于 $x \\in [x_j, x_{j+1}]$。该能量在单元边界处（$u=0$ 和 $u=1$）为零，并在单元中心处（$u=1/2$）达到最大值。\n\n与此自势能相关的保守力为 $F_{self}(x) = -\\frac{\\partial U_{self}}{\\partial x}$。当粒子穿过单元时，这个力会发生变化，其在一个单元内的空间平均值为零。为了量化这个力的典型大小，计算其均方根 (RMS) 值是很有用的。\n\n对于在单个网格单元内均匀分布的粒子，推导其自作用力的均方根值 $F_{RMS}$。", "solution": "相关的自势能和归一化位置：\n$$U_{self}(x)=\\frac{q^2\\Delta x}{2\\epsilon_0}\\,u(1-u),\\qquad u=\\frac{x-x_j}{\\Delta x}.$$  \n自作用力：\n$$F_{self}(x)=-\\frac{\\partial U_{self}}{\\partial x}\n=-\\frac{1}{\\Delta x}\\frac{\\partial}{\\partial u}\\Bigl(\\frac{q^2\\Delta x}{2\\epsilon_0}u(1-u)\\Bigr)$$  \n$$\\;=\\;-\\,\\frac{q^2}{2\\epsilon_0}(1-2u)\n=\\frac{q^2}{2\\epsilon_0}(2u-1).$$  \n\n对 $u\\in[0,1]$ 区间进行平方和平均：\n$$F_{self}^2=\\frac{q^4}{4\\epsilon_0^2}(2u-1)^2,$$  \n$$\\langle F^2\\rangle=\\int_0^1\\frac{q^4}{4\\epsilon_0^2}(2u-1)^2\\,du\n=\\frac{q^4}{4\\epsilon_0^2}\\int_0^1(4u^2-4u+1)\\,du\n=\\frac{q^4}{4\\epsilon_0^2}\\cdot\\frac{1}{3}.$$\n\n因此，RMS 自作用力为  \n$$F_{RMS}=\\sqrt{\\langle F^2\\rangle}\n=\\frac{q^2}{2\\epsilon_0}\\sqrt{\\frac{1}{3}}\n=\\frac{q^2}{2\\sqrt{3}\\,\\epsilon_0}.$$", "answer": "$$\\boxed{\\frac{q^2}{2\\sqrt{3}\\,\\epsilon_0}}$$", "id": "296780"}, {"introduction": "理论分析为我们揭示了自作用力的存在，而下一步自然是进入计算世界，在模拟中直接测量它。本练习将指导你构建一个最小化的“粒子-网格”模型，以量化这种数值误差。通过编写代码来观察自作用力如何随网格间距和粒子形状函数等参数变化，你将获得连接理论与计算实践的宝贵经验。[@problem_id:3171279]", "problem": "要求您在真空中实现一个最小的一维 ($1$D) 粒子模拟 (PIC) 仿真，以量化自作用力误差。在物理正确的真空中，单个孤立的宏粒子应经历零加速度，因为没有外场，并且在连续介质理论中，粒子不会对自己产生作用力。然而，在离散的粒子模拟 (PIC) 系统中，有限的网格间距和粒子形状会导致非零的伪自作用力。您的任务是测量这种伪加速度的大小，并将其作为粒子形状函数阶数和网格间距的函数。\n\n从基本电磁定律开始。使用静电学中的高斯定律，即电场的散度等于电荷密度除以介电常数，即 $\\nabla \\cdot \\mathbf{E} = \\rho / \\varepsilon_0$。在一维空间、周期性边界条件和时不变场的情况下，使用静电势 $\\phi$，使得 $\\mathbf{E} = -\\nabla \\phi$ 和 $\\partial^2 \\phi / \\partial x^2 = -\\rho / \\varepsilon_0$。在归一化单位下工作，使得域长度、粒子电荷、粒子质量和真空介电常数均为1，即 $L = 1$, $q = 1$, $m = 1$, $\\varepsilon_0 = 1$。在这些归一化单位下，加速度等于在粒子位置处计算的电场，即 $a = E(x)$。\n\n在程序中实现以下算法：\n\n- 域和网格：使用长度为 $L = 1$ 的周期性域。使用 $N$ 个均匀分布的节点进行离散化，节点位置为 $x_i = i \\Delta x$，其中 $i \\in \\{0, 1, \\dots, N-1\\}$ 且 $\\Delta x = L/N$。\n- 单个粒子：放置一个电荷为 $q = 1$、质量为 $m = 1$ 的宏粒子于位置 $x_0 \\in [0, L)$。\n- 电荷分配（沉积）：使用阶数为 $S_m \\in \\{0, 1, 2\\}$ 的B样条形状函数，将粒子电荷分配到网格节点上，并进行周期性环绕处理。将归一化距离 $r = (x_0 - x_i)/\\Delta x$ 通过周期性约减到 $(-\\tfrac{1}{2}N, \\tfrac{1}{2}N)$，然后使用最小周期镜像将其约减到局部以单元为中心的区间。形状权重 $w_i$ 必须满足 $\\sum_i w_i = 1$。使用以下标准的一维形状函数：\n  - $S_m = 0$ 阶 (最近网格点, NGP)：若 $|r|  \\tfrac{1}{2}$ 则 $W_0(r) = 1$，否则为 $0$。\n  - $S_m = 1$ 阶 (单元云, CIC)：若 $|r|  1$ 则 $W_1(r) = 1 - |r|$，否则为 $0$。\n  - $S_m = 2$ 阶 (三角形状云, TSC)：\n    - 若 $|r| \\le \\tfrac{1}{2}$，则 $W_2(r) = \\tfrac{3}{4} - r^2$，\n    - 若 $\\tfrac{1}{2}  |r|  \\tfrac{3}{2}$，则 $W_2(r) = \\tfrac{1}{2} \\left(\\tfrac{3}{2} - |r|\\right)^2$，\n    - 否则 $W_2(r) = 0$。\n  通过 $\\rho_i = q \\, w_i / \\Delta x$ 形成网格电荷密度。\n- 场求解（周期性边界条件下的静电学）：使用离散傅里叶变换求解离散周期性泊松系统。设 $\\hat{\\rho}(k)$ 为 $\\rho_i$ 的离散傅里叶变换。对于每个非零角波数 $k$，设置 $\\hat{E}(k) = -\\mathrm{i} \\, \\hat{\\rho}(k) / k$。对于 $k = 0$，设置 $\\hat{E}(0) = 0$ 以强制执行与周期性一致的零均值场。进行逆变换以获得网格节点上的实空间场 $E_i$。\n- 到粒子的场插值：使用相同的形状权重将电场插值回粒子位置，$E(x_0) = \\sum_i E_i \\, w_i$。\n- 伪加速度：计算加速度 $a = q E(x_0)/m$，并报告其大小 $|a|$，作为一个无量纲数。\n\n使用指定的归一化单位（所有量均为无量纲），并将加速度报告为四舍五入到 $10$ 位小数的无量纲浮点数。\n\n测试套件。使用以下参数集运行您的程序，每个参数集由 $(N, S_m, x_0)$ 指定，且 $L = 1$：\n- 情况 1：$(16, 0, 0.13)$\n- 情况 2：$(16, 1, 0.13)$\n- 情况 3：$(16, 2, 0.13)$\n- 情况 4：$(64, 2, 0.13)$\n- 情况 5：$(64, 2, 0.5)$\n- 情况 6：$(32, 1, 1/(2 \\cdot 32))$，即 $(32, 1, 0.015625)$\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果与测试套件的顺序相同，且每个值都四舍五入到 $10$ 位小数（例如 $[0.1230000000,0.0456000000,\\dots]$）。", "solution": "用户希望实现一个一维粒子模拟 (PIC) 仿真，以计算周期性域中单个粒子的伪自作用力。\n\n### 步骤1：问题验证\n\n**1.1. 提取的已知条件**\n- **物理模型：** 一维静电学，周期性边界条件。\n- **控制方程：** $\\nabla \\cdot \\mathbf{E} = \\rho / \\varepsilon_0$，在一维情况下，当 $\\mathbf{E} = -\\nabla \\phi$ 时，方程变为 $\\partial^2 \\phi / \\partial x^2 = -\\rho / \\varepsilon_0$。\n- **归一化单位：** 域长度 $L=1$，粒子电荷 $q=1$，粒子质量 $m=1$，真空介电常数 $\\varepsilon_0=1$。这意味着加速度 $a = E(x)$。\n- **离散化：**\n    - 域 $[0, L)$ 被离散化为 $N$ 个网格单元，大小为 $\\Delta x = L/N$。\n    - 网格节点位于 $x_i = i \\Delta x$，其中 $i \\in \\{0, \\dots, N-1\\}$。\n- **粒子：** 位于位置 $x_0$ 的单个粒子。\n- **算法：**\n    1.  **电荷沉积：** 使用权重 $w_i$ 将粒子电荷 $q$ 分配到网格节点 $i$。权重由阶数为 $S_m \\in \\{0, 1, 2\\}$ 的 B 样条形状函数 $W_{S_m}(r)$ 导出，其中 $r = (x_0 - x_i)/\\Delta x$ 是使用最小周期镜像计算的。网格电荷密度为 $\\rho_i = q w_i / \\Delta x$。\n        - $S_m = 0$ 阶 (NGP)：若 $|r|  0.5$ 则 $W_0(r) = 1$，否则为 $0$。\n        - $S_m = 1$ 阶 (CIC)：若 $|r|  1$ 则 $W_1(r) = 1 - |r|$，否则为 $0$。\n        - $S_m = 2$ 阶 (TSC)：若 $|r| \\le 0.5$ 则 $W_2(r) = \\tfrac{3}{4} - r^2$；若 $0.5  |r|  1.5$ 则 $W_2(r) = \\tfrac{1}{2}(\\tfrac{3}{2} - |r|)^2$；否则为 $0$。\n    2.  **场求解：** 使用离散傅里叶变换 (DFT) 求解网格上的电场 $E_i$。设 $\\hat{\\rho}(k)$ 为 $\\rho_i$ 的 DFT。对于非零角波数 $k$，电场的 DFT 为 $\\hat{E}(k) = -\\mathrm{i} \\, \\hat{\\rho}(k) / k$。$\\hat{E}(k=0) = 0$。通过对 $\\hat{E}(k)$ 进行逆 DFT 获得 $E_i$。\n    3.  **场插值：** 使用相同的权重将网格场插值到粒子位置：$E(x_0) = \\sum_i E_i w_i$。\n    4.  **加速度：** 计算加速度 $a = q E(x_0)/m$ 并报告其大小 $|a|$。\n- **测试用例：**\n    - $(N, S_m, x_0) = (16, 0, 0.13)$\n    - $(N, S_m, x_0) = (16, 1, 0.13)$\n    - $(N, S_m, x_0) = (16, 2, 0.13)$\n    - $(N, S_m, x_0) = (64, 2, 0.13)$\n    - $(N, S_m, x_0) = (64, 2, 0.5)$\n    - $(N, S_m, x_0) = (32, 1, 0.015625)$\n- **输出格式：** 单行输出，包含一个用方括号括起来的逗号分隔列表，结果四舍五入到10位小数。\n\n**1.2. 验证**\n该问题具有科学依据，描述了计算等离子体物理学中的一个标准数值实验。其物理和数学框架（一维静电学、泊松方程、周期性边界）是健全的。指定的算法是一种成熟的伪谱粒子模拟 (PIC) 方法。所有参数、定义和方程均已提供，使得问题自成体系且适定。措辞客观明确。测试用例选择得当，包括高对称性情况（$x_0$ 位于网格节点上，$x_0$ 位于单元中心），在这些情况下自作用力应为零，这为正确性提供了有力的检验。该问题未违反任何无效性标准。\n\n**1.3. 结论**\n该问题是**有效的**。\n\n### 步骤2：解决方案设计\n\n实现将精确遵循指定的算法。一个主函数 `calculate_self_force(N, Sm, x0)` 将封装单个测试用例的逻辑。将为 B 样条形状函数定义辅助函数。总体流程如下：\n\n1.  **初始化**：设置物理常数（$L, q, m$）并导出网格参数（$\\Delta x$）。\n2.  **权重计算**：一个辅助函数 `get_weights` 将为给定的粒子位置 $x_0$、网格大小 $N$ 和形状阶数 $S_m$ 计算权重 $\\{w_i\\}$。这涉及为每个网格节点 $i$ 计算归一化的周期性距离 $r = (x_0 - x_i)/\\Delta x$，并应用相应的形状函数 $W_{S_m}(r)$。\n3.  **电荷沉积**：网格电荷密度 $\\rho$ 计算为 $\\rho_i = q \\cdot w_i / \\Delta x$。由于 $q=1$，这简化为 $\\rho_i = w_i / \\Delta x$。\n4.  **傅里叶空间中的场计算**：使用 `numpy.fft.fft` 函数计算 `rho_grid` 的 DFT，得到 `rho_hat`。使用 `numpy.fft.fftfreq` 并按 $2\\pi$ 和网格间距进行缩放，获得相应的角波数 $k$。傅里叶空间中的电场 `E_hat` 使用提供的公式 $\\hat{E}(k) = -\\mathrm{i} \\, \\hat{\\rho}(k) / k$ 进行计算。需要特别处理 $k=0$ 模式，将其设置为零，以避免除以零并强制执行零均值场。\n5.  **实空间中的场**：通过对 `E_hat` 应用逆 DFT (`numpy.fft.ifft`) 并取实部，恢复网格电场 $E_i$。\n6.  **力插值**：通过使用相同的权重插值网格场来计算粒子位置处的电场 $E(x_0)$：$E(x_0) = \\sum_i E_i w_i$。这是网格场向量和权重向量之间的点积。\n7.  **加速度计算**：在归一化单位下（$q=1, m=1$），加速度就等于插值得到的场，$a = E(x_0)$。其大小 $|a|$ 就是所需的结果。\n8.  **执行循环**：一个主函数 `solve` 将遍历提供的测试套件，为每个用例调用 `calculate_self_force`，将结果格式化为 $10$ 位小数，并以指定的列表格式打印它们。\n\n对于情况5（$x_0=0.5$ 在网格节点上）和情况6（$x_0=0.5 \\Delta x$ 在单元中心），由于对称性，力应为零。任何非零结果都应在机器浮点精度数量级。", "answer": "```python\nimport numpy as np\n\ndef _get_shape_function(Sm):\n    \"\"\"Returns the appropriate B-spline shape function for a given order.\"\"\"\n    if Sm == 0:\n        # Order 0: Nearest Grid Point (NGP)\n        def W(r):\n            ar = np.abs(r)\n            if ar  0.5:\n                return 1.0\n            return 0.0\n    elif Sm == 1:\n        # Order 1: Cloud-In-Cell (CIC) or Linear\n        def W(r):\n            ar = np.abs(r)\n            if ar  1.0:\n                return 1.0 - ar\n            return 0.0\n    elif Sm == 2:\n        # Order 2: Triangular Shaped Cloud (TSC) or Quadratic\n        def W(r):\n            ar = np.abs(r)\n            if ar = 0.5:\n                return 0.75 - ar**2\n            elif ar  1.5:\n                return 0.5 * (1.5 - ar)**2\n            return 0.0\n    else:\n        raise ValueError(\"Shape function order Sm must be 0, 1, or 2.\")\n    return W\n\ndef get_weights(N, Sm, x0, delta_x, L):\n    \"\"\"\n    Calculates the charge weights on the grid for a single particle.\n    The weights are calculated based on the particle's position relative to grid nodes.\n    \"\"\"\n    weights = np.zeros(N)\n    shape_func = _get_shape_function(Sm)\n    \n    # Vectorized calculation for efficiency\n    grid_indices = np.arange(N)\n    grid_positions = grid_indices * delta_x\n    \n    # Calculate distance from particle to each grid node\n    d = x0 - grid_positions\n    \n    # Apply periodic boundary condition to find the minimum image distance\n    d_periodic = (d + L/2) % L - L/2\n    \n    # Normalize distance by grid spacing\n    r = d_periodic / delta_x\n    \n    # Apply the shape function to the normalized distances\n    # This is faster than a Python loop for large N.\n    v_shape_func = np.vectorize(shape_func)\n    weights = v_shape_func(r)\n    \n    # As a property of B-splines (partition of unity), the sum should be 1.\n    # A small tolerance is used to account for floating-point inaccuracies.\n    assert np.isclose(np.sum(weights), 1.0), \"Sum of weights is not 1.\"\n\n    return weights\n\ndef calculate_self_force(N, Sm, x0):\n    \"\"\"\n    Implements the 1D PIC algorithm to find the spurious self-force on a single particle.\n    \"\"\"\n    # 1. Domain and particle properties (normalized units)\n    L = 1.0\n    q = 1.0\n    m = 1.0\n    delta_x = L / N\n\n    # 2. Charge Assignment (Deposition)\n    # Get the weights for each grid node. These same weights will be used for interpolation.\n    weights = get_weights(N, Sm, x0, delta_x, L)\n\n    # Calculate charge density on the grid: rho_i = q * w_i / delta_x\n    rho_grid = (q / delta_x) * weights\n\n    # 3. Field Solve (using Discrete Fourier Transform)\n    # Perform DFT on the charge density\n    rho_hat = np.fft.fft(rho_grid)\n    \n    # Get the corresponding frequencies and angular wavenumbers\n    # The sample spacing 'd' for fftfreq is the grid spacing delta_x\n    freqs = np.fft.fftfreq(N, d=delta_x)\n    k = 2.0 * np.pi * freqs\n    \n    # Calculate the electric field in Fourier space\n    E_hat = np.zeros_like(rho_hat, dtype=complex)\n    \n    # Create a mask for non-zero wavenumbers to avoid division by zero\n    k_nonzero_mask = (k != 0)\n    \n    # E_hat(k) = -i * rho_hat(k) / k for k != 0\n    E_hat[k_nonzero_mask] = -1j * rho_hat[k_nonzero_mask] / k[k_nonzero_mask]\n    \n    # E_hat(k=0) must be 0, which is handled by the mask and np.zeros_like initialization.\n    \n    # Perform Inverse DFT to get the electric field on the grid\n    E_grid = np.real(np.fft.ifft(E_hat))\n\n    # 4. Field Interpolation to Particle\n    # Interpolate the electric field back to the particle's position using the same weights\n    # E(x0) = sum(E_i * w_i)\n    E_particle = np.dot(E_grid, weights)\n    \n    # 5. Spurious Acceleration\n    # a = q * E(x0) / m. With normalized units, a = E(x0)\n    acceleration = E_particle / m\n    \n    return np.abs(acceleration)\n\ndef solve():\n    \"\"\"\n    Runs the simulation for the specified test suite and prints the results.\n    \"\"\"\n    test_cases = [\n        # (N, Sm, x0)\n        (16, 0, 0.13),\n        (16, 1, 0.13),\n        (16, 2, 0.13),\n        (64, 2, 0.13),\n        (64, 2, 0.5),\n        (32, 1, 1.0 / (2.0 * 32.0)), # which is 0.015625\n    ]\n\n    results = []\n    for N, Sm, x0 in test_cases:\n        accel_magnitude = calculate_self_force(N, Sm, x0)\n        results.append(f\"{accel_magnitude:.10f}\")\n        \n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\n# Execute the main function\nsolve()\n```", "id": "3171279"}, {"introduction": "在前两个练习的基础上，我们现在准备构建一个完整的、动态的一维“粒子-网格”模拟。本练习将引导你实现包含时间积分（蛙跳法）在内的完整PIC循环，用以模拟一个经典的等离子体物理现象——双流不稳定性。最终目标是验证一个基本物理原理——动量守恒，并检验数值方案在多大程度上能够维持这一守恒律。[@problem_id:3171208]", "problem": "您必须编写一个完整的、可运行的程序，执行一维静电粒子-网格（PIC）模拟，通过碰撞两个大小相等、方向相反的粒子束并随时间测量质心漂移，以验证动量守恒。该程序必须使用基本物理定律和核心数值定义，实现自洽场计算和粒子推进。所有量都用无量纲的归一化单位表示，其中粒子质量为 $m=1$，电子的粒子电荷为 $q=-1$，自由空间介电常数为 $\\epsilon_0=1$，区域长度为 $L=1$，因此最终结果是无量纲的。\n\n从以下基本原理出发：\n- 牛顿第二定律：$m \\, \\frac{d v_i}{d t} = q \\, E(x_i)$，适用于每个粒子索引 $i$。\n- 运动学：$\\frac{d x_i}{d t} = v_i$。\n- 具有确保电中性的均匀离子背景的静电学：电势 $\\phi(x)$ 满足一维泊松方程 $\\frac{d^2 \\phi}{d x^2} = -\\frac{\\rho(x)}{\\epsilon_0}$，电场满足 $E(x) = -\\frac{d \\phi}{d x}$，其中 $\\rho(x)$ 是电荷密度。\n- 使用快速傅里叶变换（FFT）在傅里叶空间中求解离散场：对于波数 $k \\neq 0$，傅里叶系数遵循 $\\phi_k = \\frac{\\rho_k}{\\epsilon_0 k^2}$ 和 $E_k = - i k \\phi_k$，并将 $k=0$ 模式设置为零以移除均匀背景分量。\n\n使用以下数值组件实现粒子-网格（PIC）方法（Particle-In-Cell (PIC)）：\n- 云-网格（CIC）沉积和插值（Cloud-In-Cell (CIC)）：将粒子电荷沉积到网格上以获得 $\\rho(x)$，并使用相同的线性权重将电场 $E(x)$ 从网格插值到粒子位置。\n- 用于粒子的蛙跳法时间积分器：速度定义在半时间步长，位置定义在整数时间步长，具体为 $v_{i}^{n+\\frac{1}{2}} = v_{i}^{n-\\frac{1}{2}} + \\frac{q}{m} E(x_i^n) \\Delta t$ 和 $x_i^{n+1} = x_i^n + v_{i}^{n+\\frac{1}{2}} \\Delta t$，并采用周期性环绕 $x \\mapsto x \\bmod L$。\n\n初始化：\n- 将 $N$ 个电子在 $[0,L)$ 区间内均匀随机放置。\n- 将一半电子的速度设为恒定的 $+v_0$，另一半设为 $-v_0$，以形成两个相等的反向流束。\n- 包含一个均匀的离子背景电荷密度，该密度恰好抵消了平均电子电荷密度，从而使系统整体保持电中性。\n\n测量目标：\n- 令 $P(t) = \\sum_{i=1}^{N} m \\, v_i(t)$ 表示总动量，令 $V_{\\mathrm{cm}}(t) = \\frac{P(t)}{N m}$ 表示质心速度。使用 $X_{\\mathrm{cm}}(t) - X_{\\mathrm{cm}}(0) = \\int_0^t V_{\\mathrm{cm}}(t') \\, dt'$，在模拟时间内对 $V_{\\mathrm{cm}}(t)$ 进行数值积分，以获得质心位移 $S(t)$。报告在整个模拟时间内质心位移的最大绝对值，并用区域长度 $L$ 进行归一化，即 $D = \\max_t \\frac{|S(t)|}{L}$。\n\n您的程序必须：\n1. 实现上述一维PIC算法，该算法具有周期性边界条件并使用FFT进行谱方法泊松求解。\n2. 一致地使用云-网格沉积和插值。\n3. 使用蛙跳法方案进行粒子更新，该方案通过初始场产生的半步加速来初始化 $v^{\\frac{1}{2}}$。\n4. 为保证可复现性，为每个测试用例使用固定的伪随机种子。\n\n测试套件：\n为以下参数集运行您的程序，每个案例返回一个结果：\n- 案例1（一般情况）：$N=800$，$N_g=128$，$\\Delta t=0.01$，$T=400$ 步，$v_0=0.2$，$L=1$，种子 $= 12345$。\n- 案例2（更小的时间步长）：$N=800$，$N_g=128$，$\\Delta t=0.005$，$T=400$ 步，$v_0=0.2$，$L=1$，种子 $= 12346$。\n- 案例3（更粗的网格和更少的粒子）：$N=200$，$N_g=64$，$\\Delta t=0.01$，$T=400$ 步，$v_0=0.2$，$L=1$，种子 $= 12347$。\n- 案例4（更大的时间步长和更粗的网格）：$N=800$，$N_g=64$，$\\Delta t=0.015$，$T=400$ 步，$v_0=0.2$，$L=1$，种子 $= 12348$。\n\n输出规范：\n- 对每个案例，在整个模拟过程中计算 $D = \\max_t \\frac{|S(t)|}{L}$。\n- 您的程序应生成单行输出，其中包含四个测试案例的结果，格式为方括号括起来的逗号分隔列表，每个值四舍五入到六位小数，例如，“[0.000001,0.000002,0.000100,0.000500]”。\n- 所有返回值均为无量纲浮点数。\n\n科学真实性和约束：\n- 仅使用给定的基本原理和数值构造。\n- 确保沉积和插值使用相同的线性权重。\n- 强制执行周期性边界条件。\n- 使用谱方法场求解器，将 $k=0$ 模式设置为零，以避免奇点并移除均匀背景。\n\n不允许外部输入或文件。代码必须完全独立且可执行。", "solution": "用户的问题陈述已经过分析，并被确定为**有效**。它具有科学依据、内容独立且定义明确。任务是实现一个一维静电粒子-网格（PIC）模拟，以量化双流不稳定性场景中动量守恒的数值误差。\n\n### 1. 粒子-网格（PIC）方法的原理\n\n粒子-网格（PIC）方法是一种数值技术，用于模拟等离子体的动力学。等离子体由带电粒子组成，这些粒子通过自生产生的电磁场相互作用。该模拟通过一个自洽循环，将粒子运动（由洛伦兹力控制）与场演化（由麦克斯韦方程组控制）耦合起来，从而演化整个系统。在这个问题中，我们考虑一个静电系统，将场方程简化为泊松方程。核心的PIC循环包括四个主要步骤：\n\n1.  **电荷沉积**：将离散的“宏粒子”的电荷沉积到计算网格上，以计算连续的电荷密度场 $\\rho(x)$。\n2.  **场求解**：使用上一步得到的电荷密度，通过求解泊松方程来计算网格上的电场 $E(x)$。\n3.  **力插值**：将电场从网格节点插值回连续的粒子位置。\n4.  **粒子推进**：使用插值得到的力，通过积分粒子的运动方程来在时间上推进粒子。\n\n### 2. 数值实现细节\n\n模拟按照规范实现，使用无量纲单位，其中粒子质量 $m=1$、粒子电荷 $q=-1$、自由空间介电常数 $\\epsilon_0=1$、区域长度 $L=1$。\n\n#### 2.1. 电荷沉积和力插值\n\n我们使用云-网格（CIC）方案，这是一种一阶（线性）加权方法。对于一个位于网格节点 $x_j=j\\Delta x$ 和 $x_{j+1}=(j+1)\\Delta x$ 之间的网格单元内的粒子，其位置为 $x_p$，其中 $\\Delta x = L/N_g$ 是网格间距，它的电荷被分配到这两个节点上。令 $j = \\lfloor x_p/\\Delta x \\rfloor$ 为左侧网格节点的索引。到下一个节点的小数距离为 $h = (x_p/\\Delta x) - j$。粒子的电荷 $q_p$ 随后按如下方式沉积：\n- $q_j = q_p (1-h)$ 到节点 $j$。\n- $q_{j+1} = q_p h$ 到节点 $j+1$。\n\n每个网格节点上的总电荷是所有粒子贡献的总和。然后电荷密度为 $\\rho_j = Q_j / \\Delta x$，其中 $Q_j$ 是节点 $j$ 上的总电荷。\n对于力插值，使用相同的线性加权因子来找到粒子位置处的电场：\n$$\nE(x_p) = E_j(1-h) + E_{j+1}h\n$$\n其中 $E_j$ 和 $E_{j+1}$ 是节点 $j$ 和 $j+1$ 处的电场。\n\n#### 2.2. 谱方法场求解\n\n一维泊松方程 $\\frac{d^2\\phi}{dx^2} = -\\frac{\\rho}{\\epsilon_0}$ 在傅里叶空间中变成一个代数方程。进行傅里叶变换得到：\n$$\n(-k^2) \\phi_k = -\\frac{\\rho_k}{\\epsilon_0} \\implies \\phi_k = \\frac{\\rho_k}{\\epsilon_0 k^2}\n$$\n其中 $k$ 是波数。类似地，关系式 $E = -\\frac{d\\phi}{dx}$ 变为 $E_k = -i k \\phi_k$。算法如下：\n1.  在网格上计算 $\\rho_j$。\n2.  计算其离散傅里叶变换 $\\rho_k = \\text{FFT}(\\rho_j)$。\n3.  与网格对应的波数是 $k_m = \\frac{2\\pi m}{L}$，适用于整数模式 $m$。对于离散FFT，这些是通过 `fftfreq` 生成的。\n4.  对于 $k \\neq 0$，计算 $\\phi_k = \\frac{\\rho_k}{\\epsilon_0 k^2}$。$k=0$ 模式对应于平均电势，被设置为零 ($\\phi_{k=0}=0$)，这与系统的整体电中性（电子加上均匀的离子背景）一致。这样可以避免除以零的奇点。\n5.  计算电场变换 $E_k = -i k \\phi_k$。\n6.  计算逆傅里叶变换 $E_j = \\text{IFFT}(E_k)$ 以获得网格上的电场。\n\n#### 2.3. 粒子推进器：蛙跳法积分器\n\n蛙跳法是一种二阶精度的时间积分方案，对于哈密顿系统是正则的（保持相空间体积）。它在时间上交错定义位置和速度：位置定义在整数时间步长 ($t^n = n\\Delta t$)，而速度定义在半时间步长 ($t^{n \\pm 1/2} = (n \\pm 1/2)\\Delta t$)。更新方程为：\n$$\nv_i^{n+\\frac{1}{2}} = v_i^{n-\\frac{1}{2}} + \\frac{q}{m} E(x_i^n) \\Delta t\n$$\n$$\nx_i^{n+1} = x_i^n + v_i^{n+\\frac{1}{2}} \\Delta t\n$$\n周期性边界条件应用于粒子位置：$x_i \\rightarrow x_i \\pmod L$。\n\n为了初始化此方案，我们从 $t=0$ 时的位置 $x_i^0$ 和速度 $v_i^0$ 开始。主循环需要在半时间步长上的速度。我们需要 $v_i^{-1/2}$ 来开始第一步 ($n=0$)。通过将初始速度中心化 $v_i^0 = \\frac{1}{2}(v_i^{-1/2} + v_i^{1/2})$ 并使用更新规则，我们可以推导出所需起始速度的表达式：\n$$\nv_i^{-1/2} = v_i^0 - \\frac{1}{2}\\frac{q}{m} E(x_i^0) \\Delta t\n$$\n这涉及使用从初始粒子位置计算出的电场进行一次“后退”半步。\n\n### 3. 质心漂移的测量\n\n由于只存在内力，系统的总动量应该守恒。总动量的任何变化都是由数值误差引起的，例如离散系统中自作用力的不完全抵消。我们通过跟踪质心位移来测量这个误差。\n\n在每个整数时间步长 $n$，需要速度 $v_i^n$。它是通过平均半时间步长的速度来计算的：\n$$\nv_i^n = \\frac{1}{2} (v_i^{n-\\frac{1}{2}} + v_i^{n+\\frac{1}{2}})\n$$\n质心速度则为 $V_{\\mathrm{cm}}^n = \\frac{\\sum_i m v_i^n}{N m}$。位移 $S(t)$ 是 $V_{\\mathrm{cm}}$ 的时间积分，我们将其数值近似为累加和：\n$$\nS^k = \\sum_{n=0}^{k-1} V_{\\mathrm{cm}}^n \\Delta t\n$$\n要报告的度量是整个模拟过程中的最大绝对位移，用区域长度归一化：$D = \\frac{1}{L} \\max_{k} |S^k|$。对于理想的模拟，$D=0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_pic_simulation(N, Ng, dt, T_steps, v0, L, seed):\n    \"\"\"\n    Performs a 1D electrostatic Particle-In-Cell (PIC) simulation.\n\n    Args:\n        N (int): Number of particles.\n        Ng (int): Number of grid points.\n        dt (float): Time step.\n        T_steps (int): Total number of time steps.\n        v0 (float): Initial beam speed.\n        L (float): Length of the periodic domain.\n        seed (int): Seed for the pseudorandom number generator.\n\n    Returns:\n        float: The maximum absolute center-of-mass displacement normalized by L.\n    \"\"\"\n    # 1. Define constants and simulation parameters\n    m = 1.0  # Particle mass\n    q = -1.0  # Particle charge\n    eps0 = 1.0 # Permittivity of free space\n    dx = L / Ng   # Grid spacing\n\n    # 2. Grid and k-space setup\n    # Define wavenumbers for the spectral solver.\n    k_vec = 2 * np.pi / L * np.fft.fftfreq(Ng, d=dx)\n    k_squared = k_vec**2\n    # Pre-calculate indices of non-zero k modes to avoid division by zero.\n    non_zero_k_indices = k_squared != 0\n\n    # 3. Particle initialization\n    rng = np.random.default_rng(seed)\n    # Uniformly random positions in [0, L)\n    pos = rng.random(N, dtype=np.float64) * L\n    # Two counter-streaming beams\n    vel = np.full(N, v0, dtype=np.float64)\n    vel[N // 2:] = -v0\n\n    # 4. Leapfrog Initialization\n    # To start the leapfrog integrator, we need v^{-1/2}.\n    # We first compute the initial electric field E(x^0).\n    \n    # 4a. Initial charge deposition (CIC)\n    rho = np.zeros(Ng, dtype=np.float64)\n    j_indices = (pos / dx).astype(int)\n    h = (pos / dx) - j_indices\n    w_left = 1.0 - h\n    w_right = h\n    np.add.at(rho, j_indices, q * w_left)\n    np.add.at(rho, (j_indices + 1) % Ng, q * w_right)\n    rho /= dx  # Convert charge to charge density\n\n    # 4b. Initial field solve (spectral)\n    rho_k = np.fft.fft(rho)\n    phi_k = np.zeros_like(rho_k)\n    phi_k[non_zero_k_indices] = rho_k[non_zero_k_indices] / (eps0 * k_squared[non_zero_k_indices])\n    E_k = -1j * k_vec * phi_k\n    E_grid = np.fft.ifft(E_k).real\n\n    # 4c. Initial force interpolation and velocity kick-back\n    E_p = E_grid[j_indices] * w_left + E_grid[(j_indices + 1) % Ng] * w_right\n    a0 = (q / m) * E_p\n    vel_half = vel - 0.5 * a0 * dt  # This is v^{-1/2}\n\n    # 5. Measurement initialization\n    s_cm = 0.0\n    max_s_cm_abs = 0.0\n\n    # 6. Main PIC Loop\n    for _ in range(T_steps):\n        # At the start of step n, we have pos (x^n) and vel_half (v^{n-1/2})\n        \n        # 6a. Charge Deposition (CIC)\n        rho.fill(0)\n        j_indices = (pos / dx).astype(int)\n        h = (pos / dx) - j_indices\n        w_left = 1.0 - h\n        w_right = h\n        np.add.at(rho, j_indices, q * w_left)\n        np.add.at(rho, (j_indices + 1) % Ng, q * w_right)\n        rho /= dx\n        \n        # 6b. Field Solve (spectral)\n        rho_k = np.fft.fft(rho)\n        phi_k.fill(0)\n        phi_k[non_zero_k_indices] = rho_k[non_zero_k_indices] / (eps0 * k_squared[non_zero_k_indices])\n        E_k = -1j * k_vec * phi_k\n        E_grid = np.fft.ifft(E_k).real\n\n        # 6c. Force Interpolation (CIC)\n        E_p = E_grid[j_indices] * w_left + E_grid[(j_indices + 1) % Ng] * w_right\n        an = (q / m) * E_p # Acceleration a^n\n\n        # 6d. Particle Push (Leapfrog) - Velocity update\n        vel_next_half = vel_half + an * dt # This gives v^{n+1/2}\n\n        # 6e. Measurement\n        # Get velocity at integer time step n: v^n = 0.5 * (v^{n-1/2} + v^{n+1/2})\n        vel_full = 0.5 * (vel_half + vel_next_half)\n        total_momentum = np.sum(m * vel_full)\n        v_cm = total_momentum / (N * m)\n        s_cm += v_cm * dt\n        max_s_cm_abs = max(max_s_cm_abs, abs(s_cm))\n\n        # 6f. Particle Push (Leapfrog) - Position update\n        pos = (pos + vel_next_half * dt) % L # This gives x^{n+1}\n        \n        # Update velocity for the next iteration\n        vel_half = vel_next_half\n        \n    return max_s_cm_abs / L\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, Ng, dt, T_steps, v0, L, seed)\n        (800, 128, 0.01, 400, 0.2, 1, 12345),\n        (800, 128, 0.005, 400, 0.2, 1, 12346),\n        (200, 64, 0.01, 400, 0.2, 1, 12347),\n        (800, 64, 0.015, 400, 0.2, 1, 12348),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_pic_simulation(*params)\n        results.append(result)\n\n    # Format the output as specified\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the solver\nsolve()\n```", "id": "3171208"}]}