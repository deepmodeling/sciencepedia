{"hands_on_practices": [{"introduction": "理解动力系统的最终归宿是研究其长期行为的核心。本练习将介绍吸引子、排斥子和吸引盆这些基本概念，你将运用线性稳定性分析这一动力系统中的基石技术，来对一个简单一维系统的定点进行分类。掌握这项练习 [@problem_id:1662857] 将为理解更复杂系统的长期行为打下坚实的基础。", "problem": "一个用于描述剪切流中微观棒状分子取向的简化一维模型，由其角度 $\\theta(t)$ 相对于参考方向的一阶非线性微分方程给出：\n$$\n\\frac{d\\theta}{dt} = \\sin(2\\theta)\n$$\n角度 $\\theta$ 以弧度为单位，其状态在闭区间 $[0, \\pi]$ 内。该系统中的一个吸引子对应一个稳定的平衡取向 $\\theta^*$，如果分子的初始取向 $\\theta(0)$ 在一个特定范围内，那么当时间 $t \\to \\infty$ 时，分子将趋近于该取向。使得系统向特定吸引子演化的初始取向集合，被称为该吸引子的吸引盆。\n\n对于由上述方程在定义域 $\\theta \\in [0, \\pi]$ 上定义的动力系统，请从以下选项中识别出所有的吸引子及其对应的吸引盆。\n\nA. 吸引子：$\\theta = \\pi/2$。吸引盆：$[0, \\pi]$。\n\nB. 吸引子：$\\theta = 0, \\pi$。吸引盆：对于 $\\theta=0$ 是 $\\{0\\}$，对于 $\\theta=\\pi$ 是 $\\{\\pi\\}$。\n\nC. 吸引子：$\\theta = \\pi/2$。吸引盆：$(0, \\pi)$。\n\nD. 吸引子：$\\theta=0, \\pi/2, \\pi$。它们各自的吸引盆为 $\\{0\\}$、$(0, \\pi)$ 和 $\\{\\pi\\}$。\n\nE. 吸引子：$\\theta = 0, \\pi$。吸引盆：对于 $\\theta=0$ 是 $[0, \\pi/2)$，对于 $\\theta=\\pi$ 是 $(\\pi/2, \\pi]$。", "solution": "为了解决这个问题，我们需要找到该动力系统的不动点，确定它们的稳定性以识别出吸引子，然后找到流向每个吸引子的初始条件集合，即其吸引盆。\n\n**第1步：找到不动点**\n不动点（记为 $\\theta^*$）是角度变化率为零的平衡解。我们通过令 $\\frac{d\\theta}{dt} = 0$ 来找到它们。\n$$\n\\sin(2\\theta^*) = 0\n$$\n该方程的通解是 $2\\theta^* = k\\pi$，其中 $k$ 是一个整数。这给出 $\\theta^* = \\frac{k\\pi}{2}$。我们关心的是在指定定义域 $\\theta \\in [0, \\pi]$ 内的不动点。\n\n当 $k=0$ 时，$\\theta^* = 0$。\n当 $k=1$ 时，$\\theta^* = \\pi/2$。\n当 $k=2$ 时，$\\theta^* = \\pi$。\n当 $k=3$ 时，$\\theta^* = 3\\pi/2$，这超出了定义域 $[0, \\pi]$。\n\n因此，在区间 $[0, \\pi]$ 内的不动点是 $\\theta^* = 0$，$\\theta^* = \\pi/2$ 和 $\\theta^* = \\pi$。\n\n**第2步：分析不动点的稳定性**\n为了确定一个不动点是吸引子（稳定的）还是排斥子（不稳定的），我们使用线性稳定性分析。令 $f(\\theta) = \\sin(2\\theta)$。如果 $f'(\\theta^*)  0$，则不动点 $\\theta^*$ 是稳定的；如果 $f'(\\theta^*) > 0$，则是不稳定的。\n\n首先，我们计算 $f(\\theta)$ 的导数：\n$$\nf'(\\theta) = \\frac{d}{d\\theta}(\\sin(2\\theta)) = 2\\cos(2\\theta)\n$$\n现在，我们在每个不动点处计算这个导数的值：\n\n- 在 $\\theta^* = 0$ 处：\n  $f'(0) = 2\\cos(2 \\cdot 0) = 2\\cos(0) = 2(1) = 2$。\n  由于 $f'(0) > 0$，在 $\\theta=0$ 处的不动点是不稳定的。\n\n- 在 $\\theta^* = \\pi/2$ 处：\n  $f'(\\pi/2) = 2\\cos(2 \\cdot \\pi/2) = 2\\cos(\\pi) = 2(-1) = -2$。\n  由于 $f'(\\pi/2)  0$，在 $\\theta=\\pi/2$ 处的不动点是稳定的。这是一个吸引子。\n\n- 在 $\\theta^* = \\pi$ 处：\n  $f'(\\pi) = 2\\cos(2 \\cdot \\pi) = 2\\cos(2\\pi) = 2(1) = 2$。\n  由于 $f'(\\pi) > 0$，在 $\\theta=\\pi$ 处的不动点是不稳定的。\n\n根据这个分析，我们得出结论，在定义域 $[0, \\pi]$ 内只有一个吸引子，位于 $\\theta = \\pi/2$。\n\n**第3步：确定吸引盆**\n位于 $\\theta = \\pi/2$ 的吸引子的吸引盆是定义域 $[0, \\pi]$ 中所有初始条件 $\\theta(0)$ 的集合，使得解 $\\theta(t)$ 在 $t \\to \\infty$ 时收敛到 $\\pi/2$。\n\n我们有一个一维系统，在 $\\pi/2$ 处有一个吸引子，在 $0$ 和 $\\pi$ 处有排斥子。我们可以通过检查 $\\dot{\\theta} = \\sin(2\\theta)$ 的符号来分析这些不动点之间区间内的流动方向。\n\n- 对于 $\\theta \\in (0, \\pi/2)$：自变量 $2\\theta$ 在 $(0, \\pi)$ 内，其中正弦函数为正。所以，$\\dot{\\theta} = \\sin(2\\theta) > 0$。这意味着如果系统从这个区间开始，$\\theta(t)$ 会随时间增加，远离在 $0$ 处的排斥子，并朝向在 $\\pi/2$ 处的吸引子移动。\n\n- 对于 $\\theta \\in (\\pi/2, \\pi)$：自变量 $2\\theta$ 在 $(\\pi, 2\\pi)$ 内，其中正弦函数为负。所以，$\\dot{\\theta} = \\sin(2\\theta)  0$。这意味着如果系统从这个区间开始，$\\theta(t)$ 会随时间减小，远离在 $\\pi$ 处的排斥子，并朝向在 $\\pi/2$ 处的吸引子移动。\n\n因此，任何在开区间 $(0, \\pi)$ 内的初始条件 $\\theta(0)$ 都会向 $\\theta = \\pi/2$ 演化。点 $\\theta=0$ 和 $\\theta=\\pi$ 本身是不动点；如果系统恰好从这些点之一开始，它将停留在那里，而不会向 $\\pi/2$ 移动。\n\n因此，吸引子 $\\theta = \\pi/2$ 的吸引盆是开区间 $(0, \\pi)$。\n\n**第4步：与给定选项比较**\n我们的发现是：\n- 一个吸引子在 $\\theta = \\pi/2$。\n- 其吸引盆是区间 $(0, \\pi)$。\n\n这与选项 C 相符。\nA 是不正确的，因为吸引盆的边界是排斥子，不包含在内。\nB 是不正确的，因为它将不稳定的不动点识别为吸引子。\nD 是不正确的，因为它将所有不动点都识别为吸引子。\nE 因与 B 相同的原因而不正确，且其吸引盆也是错误的。\n\n正确的选项是 C。", "answer": "$$\\boxed{C}$$", "id": "1662857"}, {"introduction": "在识别了基本的吸引子之后，我们进一步探索更复杂的现象，即多个吸引子共存的情况。本问题具体展示了经典混沌系统——受驱阻尼摆——中分形吸引盆边界的概念，通过分析预先计算好的数值数据，你将见证初始条件的微小变化如何导致截然不同的长期行为。这个实践 [@problem_id:1720620] 生动地揭示了复杂与混沌动力学的一个标志性特征：对初始条件的敏感性。", "problem": "受迫阻尼摆是一个能够表现出混沌行为的经典系统范例。其角位置 $\\theta(t)$ 由以下二阶非线性微分方程决定：\n$$ \\frac{d^2\\theta}{dt^2} + q \\frac{d\\theta}{dt} + \\sin(\\theta) = F \\cos(\\omega t) $$\n其中 $q$ 是阻尼系数，$F$ 是驱动力的振幅，$\\omega$ 是驱动频率。在本问题中，所有角度均以弧度为单位，角速度以 rad/s 为单位。\n\n我们考虑一组特定参数 $q=0.5$，$F=1.2$，以及 $\\omega = 2/3$，对于这组参数，摆具有多种共存的长期行为，这些行为被称为吸引子。经过足够长的时间后，系统在 $(\\theta, \\dot{\\theta})$ 相空间中的轨迹将稳定在这些吸引子中的一个之上。我们对其中两个感兴趣：\n1.  **振荡吸引子 ($A_0$)：** 摆最终稳定在某个固定角度范围内的周期性振荡。其长期平均角速度为零，即 $\\lim_{T\\to\\infty} \\frac{\\theta(T) - \\theta(0)}{T} = 0$。\n2.  **旋转吸引子 ($A_+$)：** 摆最终稳定在一种持续逆时针旋转的运动中。其长期平均角速度为正，即 $\\lim_{T\\to\\infty} \\frac{\\theta(T) - \\theta(0)}{T} > 0$。\n\n每个吸引子的吸引盆是所有演化到该吸引子的初始条件 $(\\theta_0, v_0) = (\\theta(0), \\dot{\\theta}(0))$ 的集合。这些吸引盆可以具有复杂的分形边界。您的任务是找出一对初始条件，它们表现出对此类边界特有的对初始状态的极端敏感性。\n\n以下是四个选项，每个选项包含两个初始点（点 1 和点 2）以及通过数值模拟确定的它们对应的长期吸引子。哪个选项提供的一对点，其相空间距离 $d = \\sqrt{(\\Delta\\theta_0)^2 + (\\Delta v_0)^2}$ 小于 $5 \\times 10^{-4}$，但却演化到两个不同的吸引子？\n\nA.\n点 1: $(\\theta_0, v_0) = (1.5000, 1.0000) \\to A_0$\n点 2: $(\\theta_0, v_0) = (1.5002, 1.0001) \\to A_0$\n\nB.\n点 1: $(\\theta_0, v_0) = (2.1000, 0.8000) \\to A_0$\n点 2: $(\\theta_0, v_0) = (2.1000, 0.8010) \\to A_+$\n\nC.\n点 1: $(\\theta_0, v_0) = (-0.7531, 1.2142) \\to A_+$\n点 2: $(\\theta_0, v_0) = (-0.7533, 1.2140) \\to A_0$\n\nD.\n点 1: $(\\theta_0, v_0) = (0.0000, 1.9080) \\to A_+$\n点 2: $(\\theta_0, v_0) = (-0.0005, 1.9084) \\to A_0$", "solution": "题目要求我们选择一个选项，其中两个初始条件在相空间的欧几里得距离小于一个给定的阈值 $5 \\times 10^{-4}$，但收敛到不同的吸引子。给定的距离为\n$$\nd=\\sqrt{(\\Delta\\theta_{0})^{2}+(\\Delta v_{0})^{2}}.\n$$\n我们对每个选项进行评估：\n\n选项 A：\n$$\n\\Delta\\theta_{0}=1.5002-1.5000=2\\times 10^{-4},\\quad \\Delta v_{0}=1.0001-1.0000=1\\times 10^{-4}.\n$$\n因此\n$$\nd=\\sqrt{(2\\times 10^{-4})^{2}+(1\\times 10^{-4})^{2}}=\\sqrt{5\\times 10^{-8}}=\\sqrt{5}\\times 10^{-4}  5\\times 10^{-4}\n$$\n因为 $\\sqrt{5}  5$。然而，两个点都趋向于 $A_{0}$，所以它们没有表现出不同的吸引子。\n\n选项 B：\n$$\n\\Delta\\theta_{0}=0,\\quad \\Delta v_{0}=0.8010-0.8000=1\\times 10^{-3}.\n$$\n因此\n$$\nd=\\sqrt{0+(1\\times 10^{-3})^{2}}=1\\times 10^{-3} > 5\\times 10^{-4}.\n$$\n距离阈值未满足。\n\n选项 C：\n$$\n\\Delta\\theta_{0}=-0.7533-(-0.7531)=-2\\times 10^{-4},\\quad \\Delta v_{0}=1.2140-1.2142=-2\\times 10^{-4}.\n$$\n因此\n$$\nd=\\sqrt{(-2\\times 10^{-4})^{2}+(-2\\times 10^{-4})^{2}}=\\sqrt{8\\times 10^{-8}}=\\sqrt{8}\\times 10^{-4}=2\\sqrt{2}\\times 10^{-4}  5\\times 10^{-4},\n$$\n因为 $(2\\sqrt{2})^{2}=8  25=5^{2}$。吸引子不同：$A_{+}$ vs $A_{0}$。这同时满足了距离和吸引子不同的条件。\n\n选项 D：\n$$\n\\Delta\\theta_{0}=0.0000-(-0.0005)=5\\times 10^{-4},\\quad \\Delta v_{0}=1.9084-1.9080=4\\times 10^{-4}.\n$$\n因此\n$$\nd=\\sqrt{(5\\times 10^{-4})^{2}+(4\\times 10^{-4})^{2}}=\\sqrt{41\\times 10^{-8}}=\\sqrt{41}\\times 10^{-4} > 5\\times 10^{-4},\n$$\n因为 $41 > 25$。距离阈值未满足。\n\n因此，只有选项 C 提供了在指定距离内且演化到不同吸引子的两个初始条件。", "answer": "$$\\boxed{C}$$", "id": "1720620"}, {"introduction": "我们已经看到了简单和复杂的吸引子，但如何从数值数据中系统地识别它们呢？这个编程挑战要求你将一个基本的数学定理——Poincaré-Bendixson定理——转化为一个实用的算法。你将实现一个计算测试，用以将平面系统的吸引子分类为不动点或极限环，完成这项练习 [@problem_id:3172607] 将使你掌握一项核心的计算科学技能：直接从模拟轨迹中推断出系统长期行为的定性结论。", "problem": "实现一个完整且可运行的程序，该程序针对一组给定的二维自治常微分方程动力系统，执行一个基于 Poincaré–Bendixson 框架的计算测试，以排除平面上的混沌吸引子，并将长期行为分类为收敛到不动点吸引子或极限环吸引子。该程序必须仅依赖于平面流和吸引子的基本定义以及通用的数值积分，不使用任何快捷公式。目标是从第一性原理推导出一个算法决策过程并加以实现。\n\n您必须从以下基本基础出发：平面自治系统 $\\dot{\\mathbf{x}}=\\mathbf{f}(\\mathbf{x})$（其中 $\\mathbf{x}\\in\\mathbb{R}^2$）的定义；由初始条件 $\\mathbf{x}(0)=\\mathbf{x}_0$ 确定的轨迹 $\\mathbf{x}(t)$ 的定义；不动点（平衡点）作为满足 $\\mathbf{f}(\\mathbf{x}^\\star)=\\mathbf{0}$ 的点 $\\mathbf{x}^\\star$ 的定义；周期轨道作为满足 $\\mathbf{x}(t+T)=\\mathbf{x}(t)$（对于某个周期 $T>0$）的非常数解 $\\mathbf{x}(t)$ 的定义；以及一个形式化的陈述，即根据 Poincaré–Bendixson 理论的经典结果，二维连续时间自治流中排除了混沌吸引子。算法必须通过以下方式从这些定义中推导得出：(i) 对流进行数值积分，以测试轨迹是否被困在一个紧致矩形内；(ii) 使用消失的速度和缩小的空间分布来测试是否收敛到平衡点；(iii) 使用与 Poincaré 回归概念一致的回归分析（例如，通过对长时间信号进行基于自相关的周期性测试）来测试是否趋近于周期轨道。不要计算特征值或调用线性化快捷方法；停留在定义和时间序列逻辑的层面上。\n\n您的程序必须为单个系统实现以下决策逻辑：\n- 给定 $\\dot{\\mathbf{x}}=\\mathbf{f}(\\mathbf{x})$、一个矩形区域 $R=[x_{\\min},x_{\\max}]\\times [y_{\\min},y_{\\max}]$、一个初始条件 $\\mathbf{x}_0$、总积分时间 $T>0$ 以及一个均匀采样步长 $\\Delta t>0$：\n  1) 从 $t=0$ 到 $t=T$ 进行数值积分，并检查在所有 $t\\in[0,T]$ 内是否有 $\\mathbf{x}(t)\\in R$。如果数值轨迹在 $[0,T]$ 内的任何时间离开了 $R$，则将该情况分类为 $0$。\n  2) 如果轨迹在 $[0,T]$ 内保持在 $R$ 中，则使用轨迹的最后一部分（例如，最后一部分样本）来决定：\n     - 如果该窗口内的平均速度 $\\|\\dot{\\mathbf{x}}(t)\\|$ 很小，并且该窗口中点的空间分布也很小，则分类为不动点吸引子并输出 $1$。\n     - 否则，如果长时间信号表现出明显的周期性，且与 Poincaré 回归概念一致（例如，在对一个坐标进行去趋势处理后，其归一化自相关中存在一个强的非零延迟峰值），则分类为极限环吸引子并输出 $2$。\n     - 如果两项测试均无定论，则输出 $0$。\n仅使用这些从定义中派生的标准，不要依赖任何外部预言机。\n\n测试套件：\n您的程序必须评估以下三个系统，并将其整数分类结果汇总到一个输出列表中。\n\n- 测试用例 $\\mathbf{1}$ (Van der Pol 振荡器)：$\\dot{x}=y$, $\\dot{y}=\\mu\\,(1-x^2)\\,y - x$，其中 $\\mu=1.5$。使用 $R=[-3,3]\\times[-3,3]$，初始条件 $\\mathbf{x}_0=(2,0)$，总时间 $T=60$，采样步长 $\\Delta t=0.02$。\n- 测试用例 $\\mathbf{2}$ (线性汇)：$\\dot{x}=-a\\,x$, $\\dot{y}=-b\\,y$，其中 $a=1$ 且 $b=2$。使用 $R=[-5,5]\\times[-5,5]$，初始条件 $\\mathbf{x}_0=(3,-4)$，总时间 $T=20$，采样步长 $\\Delta t=0.02$。\n- 测试用例 $\\mathbf{3}$ (线性源，无界)：$\\dot{x}=x$, $\\dot{y}=y$。使用 $R=[-2,2]\\times[-2,2]$，初始条件 $\\mathbf{x}_0=(1,1)$，总时间 $T=10$，采样步长 $\\Delta t=0.02$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表，用方括号括起来，按测试用例的顺序排列结果，例如 $[r_1,r_2,r_3]$，其中每个 $r_k\\in\\{0,1,2\\}$ 是根据上述规则对测试用例 $k$ 的整数分类。不应打印任何其他文本。", "solution": "用户提供的问题是科学严谨、定义明确且客观的。它根植于动力系统理论的既定原则，特别是关于平面自治系统行为的 Poincaré–Bendixson 定理。问题是完整的，提供了所有必要的微分方程、初始条件、参数，以及一个清晰的算法框架来分类轨迹的长期行为。任务是实现这个框架，这是计算科学中的一个标准练习。该问题有效。\n\n解决方案将是问题陈述中指定的决策逻辑的直接实现。这对每个动力系统都涉及三个主要步骤：数值积分，检查轨迹是否保持在定义的区域内，以及基于对轨迹最后部分的分析，将长期行为分类为收敛到不动点或极限环。\n\n**1. 数值积分**\n分析的核心是从初始条件 $\\mathbf{x}_0$ 开始的系统 $\\dot{\\mathbf{x}} = \\mathbf{f}(\\mathbf{x})$ 的轨迹 $\\mathbf{x}(t)=(x(t), y(t))$。由于通常无法获得解析解，我们必须生成轨迹的数值近似。为此，我们将使用一个鲁棒的数值常微分方程（ODE）求解器。`scipy.integrate.solve_ivp` 函数是一个绝佳的选择，它实现了高阶自适应步长方法（如 Runge-Kutta）。我们将按照要求，在均匀的时间点集合 $t_i = i \\cdot \\Delta t$（其中 $i=0, 1, \\dots, N-1$ 且 $N=T/\\Delta t$）上请求解。\n\n**2. 算法分类**\n问题规定了一个特定的分类算法。设给定的矩形区域为 $R = [x_{\\min}, x_{\\max}] \\times [y_{\\min}, y_{\\max}]$。\n\n**步骤 2a: 陷阱测试**\n这是决策逻辑中的第一个关卡。在计算所有 $i$ 的轨迹 $\\mathbf{x}(t_i)$ 之后，我们必须验证轨迹在整个积分时间 $T$ 内是否保持在区域 $R$ 内。这通过检查所有采样点 $t_i$ 是否满足 $x_{\\min} \\le x(t_i) \\le x_{\\max}$ 和 $y_{\\min} \\le y(t_i) \\le y_{\\max}$ 来执行。如果发现轨迹在任何一点离开了这个盒子，其行为就被分类为相对于 $R$ 是无界的，算法会分配分类代码 $0$。\n\n**步骤 2b: 不动点与极限环分析**\n如果轨迹被困在 $R$ 内，我们继续分析其长期行为。该分析侧重于轨迹的最后部分，例如，最后 $50\\%$ 的数据点。我们将这段子轨迹表示为 $\\mathbf{x}_{\\text{final}}(t)$。\n\n**不动点吸引子测试（分类 1）：**\n收敛到稳定不动点 $\\mathbf{x}^\\star$ 的轨迹具有两个特性：其速度 $\\dot{\\mathbf{x}}(t) = \\mathbf{f}(\\mathbf{x}(t))$ 必须趋近于零，其位置 $\\mathbf{x}(t)$ 必须趋近于常数向量 $\\mathbf{x}^\\star$。我们可以通过数值方法来测试这一点：\n1.  **消失的速度：** 我们计算分析窗口 $\\mathbf{x}_{\\text{final}}(t)$ 中每个点的速度 $\\|\\dot{\\mathbf{x}}(t)\\| = \\sqrt{\\dot{x}(t)^2 + \\dot{y}(t)^2}$。如果轨迹正在接近一个不动点，该窗口内的平均速度应该接近于零。我们测试 $\\text{mean}(\\|\\dot{\\mathbf{x}}_{\\text{final}}(t)\\|)  \\epsilon_{\\text{speed}}$ 是否成立，其中 $\\epsilon_{\\text{speed}}$ 是一个小的正阈值（例如 $10^{-3}$）。\n2.  **缩小的空间分布：** 分析窗口 $\\mathbf{x}_{\\text{final}}(t)$ 中的点应该聚集在一个非常小的区域内。我们可以通过测量点的空间范围来量化这一点。设 $\\Delta x = \\max(x_{\\text{final}}) - \\min(x_{\\text{final}})$ 和 $\\Delta y = \\max(y_{\\text{final}}) - \\min(y_{\\text{final}})$。总分布可以取为 $\\sqrt{\\Delta x^2 + \\Delta y^2}$。如果这个分布低于一个小的阈值 $\\epsilon_{\\text{spread}}$（例如 $10^{-2}$），则认为轨迹是局域化的。\n\n如果平均速度和空间分布都低于各自的阈值，我们将吸引子分类为不动点（代码 $1$）。\n\n**极限环吸引子测试（分类 2）：**\n如果不动点测试失败，系统可能正在收敛到一个极限环。极限环是一个周期性轨道。因此，其坐标的时间序列，如 $x(t)$，在长期内应该是周期性的。我们使用自相关来测试周期性，这与 Poincaré 回归图的概念是一致的。\n1.  **信号准备：** 我们从分析窗口中取一个坐标，比如说 $x_{\\text{final}}(t)$，并通过减去其平均值来去趋势。这将信号中心化到零附近，提高了自相关分析的可靠性。\n2.  **自相关：** 我们计算去趋势信号的归一化自相关。自相关函数测量信号与其自身时间延迟版本的相似性。对于一个周期为 $P$ 的周期性信号，自相关函数将在对应于 $P$ 的整数倍的延迟处表现出强烈的峰值。\n3.  **峰值检测：** 我们在自相关函数中寻找一个在非零延迟处的显著峰值。归一化确保了延迟为 $0$ 处的峰值为 $1$。一个“强”峰值是指其高度超过某个阈值（例如 $0.3$）的峰值。为避免因缓慢衰减而在延迟零附近产生伪峰，我们在少数几个延迟步长后开始搜索。如果找到这样一个峰值，它就是周期性的有力证据。\n\n如果在自相关中检测到显著的非零延迟峰值，我们将吸引子分类为极限环（代码 $2$）。\n\n**无定论情况（分类 0）：**\n如果轨迹被困住，但既未通过不动点测试也未通过极限环测试，则在给定标准下结果被认为是无定论的，并被分类为代码 $0$。\n\n这个完整的、由原理驱动的过程避免了像线性化这样的快捷方式，而是依赖于分析数值生成的轨迹本身的几何和时间属性，正如问题陈述所要求的那样。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to run the classification for all test cases.\n    \"\"\"\n\n    def classify_system(f, x0, rect, T, dt):\n        \"\"\"\n        Classifies the long-term behavior of a 2D autonomous system.\n\n        Args:\n            f: The vector field function f(t, x) where x is a 2-element array.\n            x0: The initial condition [x0, y0].\n            rect: The bounding rectangle [xmin, xmax, ymin, ymax].\n            T: Total integration time.\n            dt: Time step for sampling.\n\n        Returns:\n            An integer classification:\n            0: Unbounded or inconclusive.\n            1: Fixed point attractor.\n            2: Limit cycle attractor.\n        \"\"\"\n        xmin, xmax, ymin, ymax = rect\n        t_eval = np.arange(0, T, dt)\n\n        # 1. Numerically integrate the system\n        try:\n            sol = solve_ivp(f, [0, T], x0, t_eval=t_eval, dense_output=True, method='RK45')\n            if sol.status != 0: # Check for integration failure\n                return 0\n        except Exception:\n            return 0\n        \n        # Ensure solution covers the full time span\n        if sol.t[-1]  T - dt:\n            return 0\n\n        traj_x, traj_y = sol.y\n\n        # 2. Trapping Test: Check if trajectory leaves the rectangle R\n        if np.any(traj_x  xmin) or np.any(traj_x > xmax) or \\\n           np.any(traj_y  ymin) or np.any(traj_y > ymax):\n            return 0  # Classification 0: Left the box\n\n        # 3. Analyze the last portion of the trajectory\n        analysis_frac = 0.5\n        n_pts = len(t_eval)\n        start_idx = int(n_pts * (1.0 - analysis_frac))\n        \n        analysis_window_traj = sol.y[:, start_idx:]\n        \n        # 3a. Fixed Point Test\n        # Thresholds for speed and spatial spread\n        speed_thresh = 1e-3\n        spread_thresh = 1e-2\n\n        # Calculate velocities in the analysis window\n        velocities = f(None, analysis_window_traj) # f is autonomous\n        speeds = np.linalg.norm(velocities, axis=0)\n        avg_speed = np.mean(speeds)\n\n        # Calculate spatial spread in the analysis window\n        spread_x = np.max(analysis_window_traj[0]) - np.min(analysis_window_traj[0])\n        spread_y = np.max(analysis_window_traj[1]) - np.min(analysis_window_traj[1])\n        spatial_spread = np.sqrt(spread_x**2 + spread_y**2)\n\n        if avg_speed  speed_thresh and spatial_spread  spread_thresh:\n            return 1  # Classification 1: Fixed point\n\n        # 3b. Limit Cycle Test using Autocorrelation\n        # Thresholds for autocorrelation peak\n        acorr_peak_thresh = 0.3\n        min_lag_idx = 10  # Ignore initial decay near lag 0\n\n        signal = analysis_window_traj[0]\n        signal_detrended = signal - np.mean(signal)\n        \n        # Handle case where signal has zero variance\n        if np.var(signal_detrended)  1e-10:\n             return 0 # Not a limit cycle\n        \n        autocorr = np.correlate(signal_detrended, signal_detrended, mode='full')\n        \n        # Normalize by value at lag 0\n        lag_0_val = autocorr[len(signal_detrended)-1]\n        if lag_0_val  1e-10: return 0\n        \n        autocorr_normalized = autocorr / lag_0_val\n        \n        positive_lags_corr = autocorr_normalized[len(signal_detrended):]\n\n        # Simple peak finding logic\n        for i in range(min_lag_idx + 1, len(positive_lags_corr) - 1):\n            is_peak = positive_lags_corr[i] > positive_lags_corr[i-1] and \\\n                      positive_lags_corr[i] > positive_lags_corr[i+1]\n            if is_peak and positive_lags_corr[i] > acorr_peak_thresh:\n                return 2  # Classification 2: Limit cycle\n\n        # 3c. Inconclusive Case\n        return 0\n\n    # --- Test Cases ---\n\n    # Case 1: Van der Pol oscillator\n    def vdp_oscillator(t, xy):\n        x, y = xy\n        mu = 1.5\n        dxdt = y\n        dydt = mu * (1 - x**2) * y - x\n        return np.array([dxdt, dydt])\n    \n    case1 = {\n        \"f\": vdp_oscillator, \"x0\": [2.0, 0.0],\n        \"rect\": [-3.0, 3.0, -3.0, 3.0], \"T\": 60.0, \"dt\": 0.02\n    }\n\n    # Case 2: Linear sink\n    def linear_sink(t, xy):\n        x, y = xy\n        a, b = 1.0, 2.0\n        dxdt = -a * x\n        dydt = -b * y\n        return np.array([dxdt, dydt])\n    \n    case2 = {\n        \"f\": linear_sink, \"x0\": [3.0, -4.0],\n        \"rect\": [-5.0, 5.0, -5.0, 5.0], \"T\": 20.0, \"dt\": 0.02\n    }\n    \n    # Case 3: Linear source\n    def linear_source(t, xy):\n        x, y = xy\n        dxdt = x\n        dydt = y\n        return np.array([dxdt, dydt])\n    \n    case3 = {\n        \"f\": linear_source, \"x0\": [1.0, 1.0],\n        \"rect\": [-2.0, 2.0, -2.0, 2.0], \"T\": 10.0, \"dt\": 0.02\n    }\n\n    test_cases = [case1, case2, case3]\n    results = []\n\n    for case in test_cases:\n        result = classify_system(\n            case[\"f\"], case[\"x0\"], case[\"rect\"], case[\"T\"], case[\"dt\"]\n        )\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3172607"}]}