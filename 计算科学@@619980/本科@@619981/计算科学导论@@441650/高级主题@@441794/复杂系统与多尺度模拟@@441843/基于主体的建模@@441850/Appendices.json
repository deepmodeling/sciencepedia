{"hands_on_practices": [{"introduction": "代理人基模型 (Agent-based model, ABM) 的核心在于，个体代理人遵循简单的规则进行决策和行动。本练习旨在通过一个具体的生态学场景，帮助你掌握ABM的基本构造模块。你将扮演计算机的角色，手动追踪寄居蟹寻找新壳的过程 [@problem_id:1840928]，从而深入理解代理人状态、环境以及最重要的——序贯更新规则——是如何共同驱动模型演化的。这种“纸笔推演”是理解和调试复杂模型的基础。", "problem": "一位生态学家正在开发一个简单的基于智能体的模型，来模拟寄居蟹寻找新壳的行为。该模型设定在一个一维环境中，该环境由10个潮汐池组成，按顺序从1到10编号。\n\n模拟开始时有三只寄居蟹（Crab A、Crab B、Crab C）和四个空壳位于特定位置。每只寄居蟹和每个壳都有一个整数“大小”值。\n\n**初始状态 (时间 t=0):**\n*   **寄居蟹:**\n    *   Crab A：大小为10，位于2号潮汐池。\n    *   Crab B：大小为12，位于9号潮汐池。\n    *   Crab C：大小为8，位于5号潮汐池。\n*   **空壳:**\n    *   一个大小为11的壳，位于3号潮汐池。\n    *   一个大小为13的壳，位于8号潮汐池。\n    *   一个大小为9的壳，位于6号潮汐池。\n    *   一个大小为10的壳，位于7号潮汐池。\n\n模拟以离散的时间步进行。在每个时间步内，寄居蟹根据以下规则行动：\n\n1.  **行动顺序：** 寄居蟹按字母顺序依次行动：先是Crab A，然后是Crab B，最后是Crab C。环境状态（壳的位置）在每只寄居蟹行动后更新。\n2.  **目标：** 一只当前壳大小为 $S$ 的寄居蟹只会寻找大小为理想尺寸 $S+1$ 的新空壳。\n3.  **搜索协议：** 一只位于位置 $P$ 的寄居蟹首先在其当前所在的潮汐池（$P$）中寻找理想的壳。如果在池 $P$ 中没有理想的壳，它会搜索相邻的池 $P-1$ 和 $P+1$（如果这些池在环境边界（1到10号池）内存在）。\n4.  **行动规则：**\n    *   如果在寄居蟹当前的池（$P$）中找到了理想的壳，寄居蟹会换上新壳。它的旧壳被留在池 $P$ 中变为空壳。然后该寄居蟹的回合结束。\n    *   如果在池 $P$ 中没有理想的壳，但在相邻的池中找到了一个，寄居蟹会移动到那个位置并更换壳。如果在 $P-1$ 和 $P+1$ 中都存在理想的壳，寄居蟹优先选择索引号较小的位置。移动和更换后，寄居蟹的旧壳被留在其*原始*池中变为空壳。然后该寄居蟹的回合结束。\n    *   如果在当前或相邻的池中都找不到理想的壳，寄居蟹不移动也不更换壳，并且其回合结束。\n\n根据这些规则，确定在模拟运行了两个完整的时间步之后，Crab C所占据的壳的大小。", "solution": "我们根据所述规则模拟两个离散的时间步。设在时间 $t$，每只寄居蟹 $X \\in \\{A,B,C\\}$ 的大小和位置分别用 $s_{X}(t)$ 和 $p_{X}(t)$ 表示，在时间 $t$ 的空壳集合为 $E_{t}=\\{(P,\\text{size})\\}$。\n\n$t=0$ 时的初始状态：\n- $s_{A}(0)=10$, $p_{A}(0)=2$；$s_{B}(0)=12$, $p_{B}(0)=9$；$s_{C}(0)=8$, $p_{C}(0)=5$。\n- $E_{0}=\\{(3,11),(8,13),(6,9),(7,10)\\}$。\n\n时间步 1（按A、B、C的顺序处理，每次行动后更新状态）：\n- Crab A：理想大小为 $s_{A}(0)+1=11$。搜索池 $p_{A}(0)=2$：$E_{0}$ 中没有 $(2,11)$。相邻的池是 $1$ 和 $3$。池 $3$ 中有 $(3,11)\\in E_{0}$。行动：移动到 $3$ 并换壳。更新：\n  - $s_{A}(1)=11$, $p_{A}(1)=3$。\n  - 壳更新：从 $E_{0}$ 中移除 $(3,11)$ 并添加 A 的旧壳 $(2,10)$。A行动后：$E=\\{(2,10),(8,13),(6,9),(7,10)\\}$。\n- Crab B：理想大小为 $s_{B}(0)+1=13$。搜索池 $p_{B}(0)=9$：没有 $(9,13)$。相邻的池是 $8$ 和 $10$。池 $8$ 中有 $(8,13)$。行动：移动到 $8$ 并换壳。更新：\n  - $s_{B}(1)=13$, $p_{B}(1)=8$。\n  - 壳更新：移除 $(8,13)$ 并添加 B 的旧壳 $(9,12)$。B行动后：$E=\\{(2,10),(9,12),(6,9),(7,10)\\}$。\n- Crab C：理想大小为 $s_{C}(0)+1=9$。搜索池 $p_{C}(0)=5$：没有 $(5,9)$。相邻的池是 $4$ 和 $6$。池 $6$ 中有 $(6,9)$。行动：移动到 $6$ 并换壳。更新：\n  - $s_{C}(1)=9$, $p_{C}(1)=6$。\n  - 壳更新：移除 $(6,9)$ 并添加 C 的旧壳 $(5,8)$。\n时间步 1 之后：$E_{1}=\\{(2,10),(9,12),(7,10),(5,8)\\}$ 并且 $(s_{A}(1),p_{A}(1))=(11,3)$，$(s_{B}(1),p_{B}(1))=(13,8)$，$(s_{C}(1),p_{C}(1))=(9,6)$。\n\n时间步 2（再次按A、B、C的顺序，使用 $E_{1}$）：\n- Crab A：理想大小为 $s_{A}(1)+1=12$。搜索池 $p_{A}(1)=3$，然后是相邻的 $2$ 和 $4$。$(3,12)$、$(2,12)$ 和 $(4,12)$ 都不在 $E_{1}$ 中。无行动：\n  - $s_{A}(2)=11$, $p_{A}(2)=3$，$E$ 不变。\n- Crab B：理想大小为 $s_{B}(1)+1=14$。搜索池 $p_{B}(1)=8$，然后是相邻的 $7$ 和 $9$。$(8,14)$、$(7,14)$ 和 $(9,14)$ 都不在 $E_{1}$ 中。无行动：\n  - $s_{B}(2)=13$, $p_{B}(2)=8$，$E$ 不变。\n- Crab C：理想大小为 $s_{C}(1)+1=10$。搜索池 $p_{C}(1)=6$：$E_{1}$ 中没有 $(6,10)$。相邻的池是 $5$ 和 $7$。池 $7$ 中有 $(7,10)$。行动：移动到 $7$ 并换壳。更新：\n  - $s_{C}(2)=10$, $p_{C}(2)=7$。\n  - 壳更新：移除 $(7,10)$ 并添加 C 的旧壳 $(6,9)$。最终的空壳集合变为 $\\{(2,10),(9,12),(5,8),(6,9)\\}$。\n\n因此，在两个完整的时间步之后，Crab C 占据了一个大小为 $s_{C}(2)=10$ 的壳。", "answer": "$$\\boxed{10}$$", "id": "1840928"}, {"introduction": "在掌握了单个代理人的行为规则后，我们进一步探索ABM如何模拟群体层面的涌现现象。本练习将通过一个草原犬鼠种群模型 [@problem_id:1840929]，向你介绍生态学中的阿利效应 (Allee effect)——个体生存严重依赖于群体规模。通过追踪几轮年度循环，你将亲眼见证一个简单的局部生存规则（即洞穴中的成员数量必须达到阈值）如何导致整个种群数量发生复杂的非线性变化，深刻体会“涌现”这一复杂系统的核心概念。", "problem": "一位生态学家正在使用一个简单的基于智能体的模型来研究一个假设的草原犬鼠物种。这些草原犬鼠生活在线性排列的5个洞穴中，编号从1到5。模拟以离散的年度周期（年）进行。系统状态定义为每年年初每个洞穴中草原犬鼠的数量。\n\n在第1年年初，系统的初始状态如下：\n- 洞穴1：3只草原犬鼠\n- 洞穴2：0只草原犬鼠\n- 洞穴3：2只草原犬鼠\n- 洞穴4：0只草原犬鼠\n- 洞穴5：1只草原犬鼠\n\n每个年度周期包括三个连续的阶段：移动、生存和繁殖。\n\n1.  **移动阶段：** 所有在奇数编号洞穴（1, 3, 5）中的草原犬鼠会移动到下一个编号更大的洞穴。洞穴5中的草原犬鼠移动到洞穴1（循环边界）。所有在偶数编号洞穴（2, 4）中的草原犬鼠会移动到下一个编号更小的洞穴。\n\n2.  **生存阶段：** 该物种表现出强烈的阿利效应。在移动阶段之后，对每个洞穴中的草原犬鼠进行生存评估。如果一个洞穴包含总共3个或更多的个体，该洞穴中的所有个体都将存活。如果一个洞穴包含少于3个个体，该洞穴中的所有个体都将死亡并从模拟中移除。设生存所需的最小群体规模为 $N_{min} = 3$。\n\n3.  **繁殖阶段：** 每只在生存阶段存活下来的草原犬鼠会产下恰好一个后代。设繁殖率为 $R=1$。这些新生的后代被添加到与其父母相同的洞穴中。下一年度开始时的总种群数量是所有幸存者及其新生后代的总和。\n\n根据这些规则，计算第3年年初整个系统中草原犬鼠的总数。", "solution": "我们将逐步模拟两个完整的年度周期，以找出第3年年初的种群数量。\n\n**第1年**\n\n**初始状态（第1年年初）：**\n草原犬鼠的初始分布是：\n- 洞穴1：3\n- 洞穴2：0\n- 洞穴3：2\n- 洞穴4：0\n- 洞穴5：1\n总种群数量为 $3 + 0 + 2 + 0 + 1 = 6$。\n\n**1. 移动阶段（第1年）：**\n我们应用移动规则：\n- 奇数编号洞穴1中的3只草原犬鼠移动到洞穴2。\n- 奇数编号洞穴3中的2只草原犬鼠移动到洞穴4。\n- 奇数编号洞穴5中的1只草原犬鼠移动到洞穴1（循环边界）。\n- 偶数编号的洞穴（2和4）中没有草原犬鼠可以移动。\n\n移动阶段后，分布情况为：\n- 洞穴1：1（来自洞穴5）\n- 洞穴2：3（来自洞穴1）\n- 洞穴3：0\n- 洞穴4：2（来自洞穴3）\n- 洞穴5：0\n\n**2. 生存阶段（第1年）：**\n我们将每个洞穴中的个体数量与生存阈值 $N_{min} = 3$ 进行比较。\n- 洞穴1：1个个体。由于 $1  3$，有0个个体存活。\n- 洞穴2：3个个体。由于 $3 \\ge 3$，所有3个个体都存活。\n- 洞穴3：0个个体。由于 $0  3$，有0个个体存活。\n- 洞穴4：2个个体。由于 $2  3$，有0个个体存活。\n- 洞穴5：0个个体。由于 $0  3$，有0个个体存活。\n\n存活的草原犬鼠总数为3只，全部位于洞穴2。\n\n**3. 繁殖阶段（第1年）：**\n每只幸存者（共3只）产下 $R=1$ 个后代。\n- 新生后代总数 = $3 \\times 1 = 3$。\n这些后代被添加到其父母所在的洞穴（洞穴2）。\n第2年年初的新种群数量是幸存者和后代的总和。\n- 洞穴2的种群数量 = 3（幸存者） + 3（后代） = 6。\n\n**第2年年初的状态：**\n- 洞穴1：0\n- 洞穴2：6\n- 洞穴3：0\n- 洞穴4：0\n- 洞穴5：0\n总种群数量为 $0 + 6 + 0 + 0 + 0 = 6$。\n\n**第2年**\n\n**初始状态（第2年年初）：**\n分布情况如第1年年底所确定：\n- 洞穴1：0\n- 洞穴2：6\n- 洞穴3：0\n- 洞穴4：0\n- 洞穴5：0\n\n**1. 移动阶段（第2年）：**\n我们应用移动规则：\n- 偶数编号洞穴2中的6只草原犬鼠移动到下一个编号更小的洞穴，即洞穴1。\n- 其他洞穴中没有草原犬鼠可以移动。\n\n移动阶段后，分布情况为：\n- 洞穴1：6（来自洞穴2）\n- 洞穴2：0\n- 洞穴3：0\n- 洞穴4：0\n- 洞穴5：0\n\n**2. 生存阶段（第2年）：**\n我们将每个洞穴中的个体数量与生存阈值 $N_{min} = 3$ 进行比较。\n- 洞穴1：6个个体。由于 $6 \\ge 3$，所有6个个体都存活。\n- 所有其他洞穴都有0个个体，因此每个洞穴中存活的个体为0。\n\n存活的草原犬鼠总数为6只，全部位于洞穴1。\n\n**3. 繁殖阶段（第2年）：**\n每只幸存者（共6只）产下 $R=1$ 个后代。\n- 新生后代总数 = $6 \\times 1 = 6$。\n这些后代被添加到其父母所在的洞穴（洞穴1）。\n第3年年初的新种群数量是幸存者和后代的总和。\n- 洞穴1的种群数量 = 6（幸存者） + 6（后代） = 12。\n\n**第3年年初的状态：**\n- 洞穴1：12\n- 洞穴2：0\n- 洞穴3：0\n- 洞穴4：0\n- 洞穴5：0\n第3年年初的总种群数量为 $12 + 0 + 0 + 0 + 0 = 12$。", "answer": "$$\\boxed{12}$$", "id": "1840929"}, {"introduction": "学习ABM的最终目的是为了构建并利用计算模型来研究真实世界的复杂现象。这项高级练习将引导你从“纸笔推演”迈向实际的编程实现，构建一个包含多种真实世界元素的野火蔓延模型 [@problem_id:3096201]。你将综合运用二维网格、多样的代理人状态、随机性、环境因素（如风）以及复杂的邻里互动规则。更重要的是，这不仅仅是一个编程任务，更是一场计算实验：你将通过反复运行模型来估算其“逾渗阈值” (percolation threshold)——一个源自统计物理学的关键概念，它揭示了火灾能否穿越整片森林与燃料密度的深刻关系。", "problem": "考虑一个基于智能体模型（ABM），用于模拟在大小为 $L \\times L$ 的二维方格上发生的野火。每个格点是一个智能体，其离散状态为 $\\{ \\text{空}, \\text{燃料}, \\text{燃烧}, \\text{已燃烧} \\}$ 中的一种。燃料的异质性通过每次运行的两个独立随机场来建模：一个燃料占据场和一个干燥度场。燃料占据场是一个参数为 $p \\in [0,1]$ 的伯努利场；一个格点有概率 $p$ 为燃料，否则为空。干燥度场为每个格点分配一个标量 $s \\in [0,1]$，该标量从 $s \\sim \\mathrm{Uniform}(1-h,1)$ 分布中独立采样，其中 $h \\in [0,1]$ 控制异质性。一个恒定的风场向量由 $\\vec{w} = (w_x,w_y) \\in \\mathbb{R}^2$ 给出。火灾动态以离散时间步演化。在时间 $t=0$ 时，最左侧列（列索引为 $0$）上的所有燃料格点都被点燃（状态为燃烧）。在随后的每个时间步 $t \\to t+1$ 中，每个燃烧的格点会尝试点燃其在基本方向 $\\mathcal{N} = \\{\\text{东},\\text{西},\\text{南},\\text{北}\\}$ 上的四个最近邻格点，之后其自身状态变为已燃烧。一个邻近格点，如果它是燃料（非空、未燃烧过且当前未在燃烧），将以一个考虑了风向对齐和局部干燥度的概率被点燃。\n\n将四个基本方向的单位方向向量定义为 $\\vec{d}_\\text{东}=(1,0)$，$\\vec{d}_\\text{西}=(-1,0)$，$\\vec{d}_\\text{南}=(0,1)$ 和 $\\vec{d}_\\text{北}=(0,-1)$，坐标对齐方式为 $x$ 轴向右增加，$y$ 轴向下增加。设 $q_0 \\in [0,1]$ 为基准点燃概率分量，$\\gamma \\ge 0$ 为风敏感性参数。对于方向 $d \\in \\mathcal{N}$，定义方向性点燃概率分量\n$$\nq_d = \\mathrm{clip}\\left(q_0 + \\gamma \\cdot a(\\vec{w},\\vec{d}),\\,0,\\,1\\right),\n$$\n其中\n$$\na(\\vec{w},\\vec{d}) = \\begin{cases}\n\\frac{\\vec{w} \\cdot \\vec{d}}{\\|\\vec{w}\\|},  \\|\\vec{w}\\|  0,\\\\\n0,  \\|\\vec{w}\\| = 0,\n\\end{cases}\n$$\n且 $\\mathrm{clip}(x,0,1)$ 将 $x$ 截断到区间 $[0,1]$。如果多个燃烧的邻居试图点燃同一个燃料格点，假设这些尝试是独立的，并通过补集法则进行组合。如果格点 $(i,j)$ 的干燥度为 $s_{i,j}$，并且从方向子集 $\\mathcal{A} \\subseteq \\mathcal{N}$ 接收到点燃尝试，则其在下一个时间步的点燃概率为\n$$\nP^\\text{ignite}_{i,j} = 1 - \\prod_{d \\in \\mathcal{A}} \\left(1 - s_{i,j} \\, q_d\\right).\n$$\n边界是反射性的，即格子之外的格点不存在，也不会产生点燃尝试。当没有格点在燃烧时，火灾终止。定义一次运行实现穿越，如果在运行期间最右侧列（列索引为 $L-1$）的任何格点曾变为燃烧或已燃烧状态。\n\n从逾渗的角度来看，将给定燃料占据率 $p$ 下的经验穿越概率定义为实现穿越的独立运行（燃料场和干燥度场独立重采样）所占的比例。对于此ABM，逾渗阈值估计值 $p^\\ast$ 在离散扫描 $p \\in \\{p_{\\min}, p_{\\min}+\\Delta p, \\dots, p_{\\max}\\}$ 上的操作性定义是：其经验穿越概率至少为 $0.5$ 的最小扫描 $p$ 值。如果没有扫描的 $p$ 满足此标准，则定义 $p^\\ast = p_{\\max} + \\Delta p$ 作为一个哨兵值，表示阈值位于扫描范围之上。对于相同的晶格拓扑，方格上的键逾渗具有精确的键逾渗阈值 $p_c^\\text{bond} = 0.5$。对于每个测试用例，通过报告差异 $p^\\ast - p_c^\\text{bond}$ 来比较ABM阈值 $p^\\ast$ 和 $p_c^\\text{bond}$。\n\n请完全按照上述规定实现ABM，并使用离散扫描和重复运行来估计 $p^\\ast$。使用以下测试套件；每个测试用例是一个元组 $(L, w_x, w_y, h, q_0, \\gamma, p_{\\min}, p_{\\max}, \\Delta p, N_\\text{runs})$：\n- 测试用例 1: $(40, 0.0, 0.0, 0.2, 0.3, 0.4, 0.35, 0.75, 0.05, 60)$。\n- 测试用例 2: $(40, 2.0, 0.0, 0.2, 0.3, 0.4, 0.35, 0.75, 0.05, 60)$。\n- 测试用例 3: $(40, -2.0, 0.0, 0.2, 0.3, 0.4, 0.35, 0.75, 0.05, 60)$。\n- 测试用例 4: $(30, 1.0, 0.5, 0.4, 0.3, 0.4, 0.35, 0.75, 0.05, 60)$。\n\n您的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。对于每个测试用例，输出两个保留 $3$ 位小数的浮点数：首先是估计的ABM阈值 $p^\\ast$，然后是差异 $p^\\ast - p_c^\\text{bond}$。最终的输出列表按顺序汇总所有测试用例，结果为 $8$ 个数字：\n$$\n\\left[ p^\\ast_1,\\; p^\\ast_1 - 0.5,\\; p^\\ast_2,\\; p^\\ast_2 - 0.5,\\; p^\\ast_3,\\; p^\\ast_3 - 0.5,\\; p^\\ast_4,\\; p^\\ast_4 - 0.5 \\right].\n$$\n所有量都是无量纲的；不需要物理单位。角度（如果通过点积和归一化隐式引用）通过无量纲的对齐因子处理；不使用明确的角度单位。", "solution": "该问题要求实现一个用于模拟二维晶格上野火蔓延的随机代理基模型（ABM），并随后估计其逾渗阈值 $p^\\ast$。解决方案的开发首先是构建一个精确遵循指定动态的计算模型，然后将该模型部署在一个统计框架内以确定 $p^\\ast$。\n\n### 1. 模型构建与状态表示\n系统是一个大小为 $L \\times L$ 的方格。每个格点 $(i,j)$ 是一个智能体，其状态属于集合 $\\{\\text{空}, \\text{燃料}, \\text{燃烧}, \\text{已燃烧}\\}$。在计算实现中，这些离散状态被映射为整数值：空 $\\to 0$，燃料 $\\to 1$，燃烧 $\\to 2$，已燃烧 $\\to 3$。整个格子的状态由一个 $L \\times L$ 的 NumPy 数组表示。\n\n指定了两种淬火无序的来源：\n1.  **燃料占据场**：一个参数为 $p$ 的伯努利场决定了燃料的初始布局。这是通过生成一个在 $[0,1]$ 区间内均匀分布的 $L \\times L$ 随机数数组，并将随机数小于 $p$ 的格点指定为燃料来实现的。\n2.  **干燥度场**：为每个格点分配一个标量干燥度 $s_{i,j} \\in [0,1]$，该值从均匀分布 $\\mathrm{Uniform}(1-h,1)$ 中独立采样。这由一个独立的 $L \\times L$ 浮点型 NumPy 数组表示。\n\n这两个场在每次模拟运行开始时生成一次。\n\n### 2. 方向性点燃概率的预计算\n模型通过调制基准点燃概率来包含风的影响。风是一个恒定向量 $\\vec{w} = (w_x, w_y)$。它对基本方向 $d \\in \\{\\text{东}, \\text{西}, \\text{北}, \\text{南}\\}$ 上点燃的影响取决于风与该方向的对齐程度。对齐因子由 $a(\\vec{w},\\vec{d}) = (\\vec{w} \\cdot \\vec{d}) / \\|\\vec{w}\\|$ 给出（当 $\\|\\vec{w}\\| > 0$ 时），否则为 $0$。方向向量定义为 $\\vec{d}_\\text{东}=(1,0)$，$\\vec{d}_\\text{西}=(-1,0)$，$\\vec{d}_\\text{南}=(0,1)$ 和 $\\vec{d}_\\text{北}=(0,-1)$，其中y轴朝下。\n\n然后，方向性点燃概率分量 $q_d$ 计算为 $q_d = \\mathrm{clip}(q_0 + \\gamma \\cdot a(\\vec{w},\\vec{d}), 0, 1)$，其中 $q_0$ 是基准概率分量，$\\gamma$ 是风敏感性。由于 $\\vec{w}$、$q_0$ 和 $\\gamma$ 在单个测试用例的所有运行中都是恒定的，因此在启动模拟运行之前会预先计算四个值 $\\{q_{\\text{东}}, q_{\\text{西}}, q_{\\text{北}}, q_{\\text{南}}\\}$。\n\n### 3. 模拟算法\n单次模拟运行根据指定规则在离散时间步上演化格子的状态。\n\n**初始化**：\n一次运行开始时，首先按照第1节所述设置格子。在生成燃料场和干燥度场之后，通过将最左侧列（列索引为 $0$）中所有燃料格点的状态更改为“燃烧”（状态 $2$）来引燃初始火灾。\n\n**时间演化**：\n模拟在一个循环中进行，只要有“燃烧”的格点，循环就会继续。状态更新是同步的，这意味着它们是基于时间 $t$ 的格子状态来计算的，以确定时间 $t+1$ 的状态。\n\n1.  **识别点燃源**：创建一个布尔掩码 `is_burning` 来定位所有当前处于状态 $2$ 的格点。\n2.  **计算点燃概率**：模拟的核心是计算每个燃料格点的点燃概率 $P^\\text{ignite}_{i,j}$。问题陈述中指出，对于一个干燥度为 $s_{i,j}$ 的格点 $(i,j)$，如果它从一组邻居 $\\mathcal{A}$ 接收到点燃尝试，其总点燃概率为 $P^\\text{ignite}_{i,j} = 1 - \\prod_{d \\in \\mathcal{A}} (1 - s_{i,j} q_d)$。这个公式正确地组合了独立的概率事件。\n    为了高效实现这一点，我们首先计算*不*被点燃的概率。一个 $L \\times L$ 的数组 `prob_no_ignition` 被初始化为全1。对于每个基本方向，我们识别出该方向上与燃烧格点相邻的燃料格点。这可以通过对 `is_burning` 掩码进行移位操作，使用向量化的 NumPy 运算来完成。例如，要找到燃烧格点东侧的燃料格点，可将 `is_burning` 掩码向左移动一个位置。对于每个目标燃料格点，它们的 `prob_no_ignition` 值会乘以相应的因子 $(1 - s_{i,j} q_d)$。对所有四个方向重复此操作。\n3.  **随机点燃**：在考虑了所有相邻火源后，每个燃料格点的最终点燃概率为 `ignite_prob = 1.0 - prob_no_ignition`。然后为每个格点从 $\\mathrm{Uniform}(0,1)$ 分布中抽取一个随机数。如果抽取的随机数小于其计算出的 `ignite_prob`，则该燃料格点被新点燃。\n4.  **状态更新**：执行同步更新。所有在时间步开始时处于“燃烧”状态的格点都转变为“已燃烧”（状态 $3$）。所有新点燃的“燃料”格点都转变为“燃烧”（状态 $2$）。\n5.  **终止与穿越**：如果火灾熄灭（没有格点处于“燃烧”状态）或实现穿越，则运行终止。穿越定义为最右侧列（索引 $L-1$）中的任何格点进入“燃烧”或“已燃烧”状态。一个布尔标志用于跟踪是否发生了穿越。如果发生穿越，该次运行的模拟将立即停止，并记录为一次成功。如果火灾在到达最右侧列之前熄灭，则运行失败。\n\n### 4. 逾渗阈值估计\n主要目标是估计逾渗阈值 $p^\\ast$。这是通过对燃料占据概率 $p$ 的一个离散范围 $p \\in \\{p_{\\min}, p_{\\min}+\\Delta p, \\dots, p_{\\max}\\}$ 进行系统性扫描来实现的。对于每个 $p$ 值：\n1.  执行固定数量的独立模拟运行，即 $N_\\text{runs}$ 次。\n2.  统计导致穿越的运行次数。\n3.  经验穿越概率计算为（成功运行次数）/ $N_\\text{runs}$。\n4.  将此概率与阈值 $0.5$ 进行比较。扫描中第一个使得经验穿越概率至少为 $0.5$ 的 $p$ 值被定义为估计的逾渗阈值 $p^\\ast$。然后终止扫描。\n5.  如果扫描完成而穿越概率从未达到 $0.5$，则将 $p^\\ast$ 赋予防哨值 $p_{\\max} + \\Delta p$。\n\n### 5. 最终输出计算\n对于每个测试用例，如上所述确定估计的阈值 $p^\\ast$。最终报告的量是 $p^\\ast$ 本身以及差值 $p^\\ast - p_c^\\text{bond}$，其中参考的键逾渗阈值为 $p_c^\\text{bond}=0.5$。为每个测试用例计算这两个值，四舍五入到三位小数，并汇总到单个列表中作为最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(L, p, h, q_coeffs):\n    \"\"\"\n    Executes a single run of the wildfire ABM.\n\n    Args:\n        L (int): Lattice size.\n        p (float): Fuel occupancy probability.\n        h (float): Dryness heterogeneity parameter.\n        q_coeffs (tuple): Tuple of (q_E, q_W, q_N, q_S) ignition probabilities.\n\n    Returns:\n        bool: True if the fire crosses the lattice, False otherwise.\n    \"\"\"\n    # State mapping: 0=empty, 1=fuel, 2=burning, 3=burned\n    states = np.zeros((L, L), dtype=np.int8)\n    \n    # 1. Initialization\n    is_fuel_mask = np.random.rand(L, L)  p\n    states[is_fuel_mask] = 1\n    \n    dryness = np.random.uniform(1 - h, 1.0, size=(L, L))\n    \n    q_E, q_W, q_N, q_S = q_coeffs\n    \n    # Ignite the leftmost column where there is fuel\n    leftmost_fuel = states[:, 0] == 1\n    states[leftmost_fuel, 0] = 2\n    \n    # Check for immediate crossing (for L=1 or if no fuel on left edge)\n    if not np.any(leftmost_fuel):\n        return False\n    if np.any(states[:, -1] >= 2):\n        return True\n\n    # 2. Time evolution loop\n    while True:\n        is_burning = (states == 2)\n        if not np.any(is_burning):\n            break  # Fire has extinguished\n\n        is_fuel = (states == 1)\n        prob_no_ignition = np.ones((L, L), dtype=np.float64)\n\n        # Vectorized calculation of ignition probabilities from all 4 directions\n        # Igniters from West influence their Eastern neighbors\n        igniters_W = np.zeros_like(is_burning)\n        igniters_W[:, 1:] = is_burning[:, :-1]\n        ignitable_E = igniters_W  is_fuel\n        if q_E > 0:\n            prob_no_ignition[ignitable_E] *= (1.0 - dryness[ignitable_E] * q_E)\n\n        # Igniters from East influence their Western neighbors\n        igniters_E = np.zeros_like(is_burning)\n        igniters_E[:, :-1] = is_burning[:, 1:]\n        ignitable_W = igniters_E  is_fuel\n        if q_W > 0:\n            prob_no_ignition[ignitable_W] *= (1.0 - dryness[ignitable_W] * q_W)\n            \n        # Igniters from North influence their Southern neighbors\n        igniters_N = np.zeros_like(is_burning)\n        igniters_N[1:, :] = is_burning[:-1, :]\n        ignitable_S = igniters_N  is_fuel\n        if q_S > 0:\n            prob_no_ignition[ignitable_S] *= (1.0 - dryness[ignitable_S] * q_S)\n        \n        # Igniters from South influence their Northern neighbors\n        igniters_S = np.zeros_like(is_burning)\n        igniters_S[:-1, :] = is_burning[1:, :]\n        ignitable_N = igniters_S  is_fuel\n        if q_N > 0:\n            prob_no_ignition[ignitable_N] *= (1.0 - dryness[ignitable_N] * q_N)\n\n        ignite_prob = 1.0 - prob_no_ignition\n        \n        # Stochastic ignition event\n        rand_vals = np.random.rand(L, L)\n        newly_ignited = (rand_vals  ignite_prob)  is_fuel\n\n        # 3. Synchronous state update\n        states[is_burning] = 3   # Burning sites become burned\n        states[newly_ignited] = 2 # Newly ignited sites start burning\n        \n        # 4. Check for crossing\n        if np.any(states[:, -1] >= 2):  # burning (2) or burned (3)\n            return True\n\n    return False # Fire extinguished without crossing\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (40, 0.0, 0.0, 0.2, 0.3, 0.4, 0.35, 0.75, 0.05, 60),\n        (40, 2.0, 0.0, 0.2, 0.3, 0.4, 0.35, 0.75, 0.05, 60),\n        (40, -2.0, 0.0, 0.2, 0.3, 0.4, 0.35, 0.75, 0.05, 60),\n        (30, 1.0, 0.5, 0.4, 0.3, 0.4, 0.35, 0.75, 0.05, 60),\n    ]\n\n    results = []\n    p_c_bond = 0.5\n\n    for case in test_cases:\n        L, w_x, w_y, h, q_0, gamma, p_min, p_max, delta_p, N_runs = case\n\n        # Pre-compute directional ignition components\n        w_norm = np.sqrt(w_x**2 + w_y**2)\n        ax, ay = 0.0, 0.0\n        if w_norm > 1e-9:\n            ax = w_x / w_norm\n            ay = w_y / w_norm\n        \n        q_E = np.clip(q_0 + gamma * ax, 0, 1)\n        q_W = np.clip(q_0 + gamma * -ax, 0, 1)\n        q_S = np.clip(q_0 + gamma * ay, 0, 1) # y-axis increases downwards\n        q_N = np.clip(q_0 + gamma * -ay, 0, 1)\n\n        q_coeffs = (q_E, q_W, q_N, q_S)\n\n        p_values = np.arange(p_min, p_max + delta_p / 2, delta_p)\n        p_star = p_max + delta_p # Sentinel value\n\n        for p in p_values:\n            cross_count = 0\n            for _ in range(N_runs):\n                if run_simulation(L, p, h, q_coeffs):\n                    cross_count += 1\n            \n            empirical_prob = cross_count / N_runs\n            \n            if empirical_prob >= 0.5:\n                p_star = p\n                break\n        \n        results.append(p_star)\n        results.append(p_star - p_c_bond)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{val:.3f}' for val in results])}]\")\n\nsolve()\n```", "id": "3096201"}]}