{"hands_on_practices": [{"introduction": "逻辑斯谛映射（Logistic Map）为我们探索复杂的混沌世界提供了一个看似简单却极为深刻的入口。本练习将引导你通过计算来探索其参数空间，并揭示向混沌的过渡并非一条单行道；在混沌区域中，稳定的周期轨道会出人意料地在“有序窗口”中重现[@problem_id:3105341]。通过实现一个算法来检测周期性并验证其稳定性，你将亲身体验到混沌系统中所蕴含的“混沌中的秩序”这一精细结构。", "problem": "您将编写一个完整、可运行的程序，使用计算方法研究逻辑斯谛映射（logistic map）在混沌参数区域内的周期窗口。从离散动力系统的核心定义和基于极限的量开始，并推导出一个基于这些基础而不使用快捷公式的算法。\n\n基本基础：\n- 考虑由迭代 $x_{n+1} = f_r(x_n)$ 定义的逻辑斯谛映射，其中 $f_r(x) = r x (1 - x)$，控制参数 $r \\in [0,4]$，状态 $x_n \\in [0,1]$。\n- 如果存在一个最小的 $p$ 使得对于所有足够大的 $n$ 都有 $x_{n+p} = x_n$，则轨道 $(x_n)$ 的（最小）周期为 $p \\in \\mathbb{N}$。如果不存在这样的有限 $p$，则轨道是非周期的。\n- 对于参数 $r$ 下沿轨道 $(x_n)$ 的映射，其李雅普诺夫指数（Lyapunov exponent, LE）$\\lambda$ 定义为 $\\lambda = \\lim_{N \\to \\infty} \\frac{1}{N}\\sum_{n=0}^{N-1} \\ln |f_r'(x_n)|$，其中 $f_r'(x) = r (1 - 2x)$。负的李雅普诺夫指数表示轨道的指数稳定性，而正的李雅普诺夫指数表示附近轨迹的指数发散。\n- 在计算中，通过在舍弃初始瞬态后使用有限时间平均来近似李雅普诺夫指数，以减轻对初始条件的敏感性。\n\n问题要求：\n- 实现一个算法，对于给定的参数 $r$，通过测试复现条件 $x_{n+p} \\approx x_n$（在小容差的意义下），检测瞬态后的轨道是否以某个周期 $p \\leq p_{\\max}$ 呈周期性。使用最小周期准则（没有更小的 $q  p$ 满足该条件），并检查不同的相在数值上没有坍缩（对于 $p > 1$，确保 $p$ 个相值之间由一个阈值分隔）。仅当有限时间李雅普诺夫指数为负时，才接受周期分类。\n- 实现一个在闭区间 $[r_{\\min}, r_{\\max}]$ 上的参数扫描，步长为 $\\Delta r$ 的均匀网格，如果轨道具有最小周期 $p$ 且李雅普诺夫指数为负，则将每个网格点 $r$ 分类为属于一个指定的目标周期-$p$ 窗口，并将窗口的测度计算为所有分类网格点上的黎曼和 $\\sum \\Delta r$。同时计算在网格上检测到的连续窗口段的数量。\n\n测试套件与答案规范：\n- 使用如上定义的逻辑斯谛映射 $x_{n+1} = r x_n (1 - x_n)$。\n- 使用每个测试用例中指定的固定初始条件和迭代次数。不要引入随机性。\n- 对于所有角度（本问题中没有），如果出现，请使用弧度。对于本问题中的所有数值输出，不涉及物理单位。\n- 您的程序必须严格实现以下测试用例：\n\n1. 在已知存在周期-3的区域进行周期检测：\n   - 参数：$r = 3.82842712$, $x_0 = 0.2$, $N_{\\text{transient}} = 2000$, $N_{\\text{sample}} = 1500$, $p_{\\max} = 10$, 容差 $\\varepsilon = 10^{-7}$。\n   - 此用例的输出：检测到的最小周期 $p$，为 $\\{0,1,2,\\dots,p_{\\max}\\}$ 中的一个整数。如果未检测到周期 $\\leq p_{\\max}$，则使用 $p = 0$。\n\n2. 在混沌区域进行周期检测：\n   - 参数：$r = 3.57$, $x_0 = 0.5$, $N_{\\text{transient}} = 2000$, $N_{\\text{sample}} = 1500$, $p_{\\max} = 10$, 容差 $\\varepsilon = 10^{-7}$。\n   - 此用例的输出：检测到的最小周期 $p$（如果没有，则使用 $p = 0$）。\n\n3. 局部区间内周期-3窗口的测度：\n   - 参数：$r_{\\min} = 3.82$, $r_{\\max} = 3.86$, $\\Delta r = 10^{-4}$, 目标周期 $p = 3$, $x_0 = 0.5$, $N_{\\text{transient}} = 2000$, $N_{\\text{sample}} = 1000$, $p_{\\max} = 10$, 容差 $\\varepsilon = 10^{-7}$。\n   - 此用例的输出：在此网格上检测到的周期-3窗口的总测度，表示为四舍五入到 $6$ 位小数的浮点数。\n\n4. 同一局部区间内连续周期-3窗口段的数量：\n   - 使用与用例3相同的参数。\n   - 此用例的输出：连续段的数量，为一个整数。\n\n5. 在更宽的混沌区间内周期-3窗口的测度：\n   - 参数：$r_{\\min} = 3.5$, $r_{\\max} = 4.0$, $\\Delta r = 10^{-3}$, 目标周期 $p = 3$, $x_0 = 0.5$, $N_{\\text{transient}} = 2000$, $N_{\\text{sample}} = 1000$, $p_{\\max} = 10$, 容差 $\\varepsilon = 10^{-7}$。\n   - 此用例的输出：总测度，表示为四舍五入到 $6$ 位小数的浮点数。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述五个测试用例的顺序排列结果。例如，输出应类似于 $[p_1,p_2,m_3,c_4,m_5]$，其中 $p_1$ 和 $p_2$ 是整数，$m_3$ 和 $m_5$ 是四舍五入到 $6$ 位小数的浮点数，$c_4$ 是一个整数。", "solution": "该问题是有效的。它提出了一个定义明确的计算任务，该任务基于混沌理论和离散动力系统的既定原则。逻辑斯谛映射、周期性和李雅普诺夫指数的定义都是标准的。该问题要求实现数值算法来近似这些量，这是计算科学中的一种标准方法。所有测试用例的参数都已明确提供。\n\n在要求“确保 $p$ 个相值由一个阈值分隔”以进行不同相检查时，存在一个小的歧义，因为没有给出该阈值的具体值。一个合理且一致的解释（此处将采纳）是使用为复现检查指定的相同容差 $\\varepsilon$。也就是说，对于一个具有点 $\\{c_1, \\dots, c_p\\}$ 的候选周期-$p$ 循环，要求对于所有 $i \\neq j$ 都有 $|c_i - c_j| \\ge \\varepsilon$。这种解释使得问题完全明确且可解。\n\n该解决方案基于基本原理设计，从核心定义开始，逐步构建所需的算法。\n\n**1. 逻辑斯谛映射与轨道生成**\n\n所考虑的动力系统是逻辑斯谛映射，一个函数 $f_r: [0,1] \\to [0,1]$，由迭代公式定义：\n$$x_{n+1} = f_r(x_n) = r x_n (1 - x_n)$$\n这里，$x_n$ 是系统在步骤 $n$ 的状态，$r \\in [0,4]$ 是一个控制参数。轨道是从初始条件 $x_0$ 生成的状态序列 $(x_n)_{n \\ge 0}$。为了分析长期（渐近）行为，我们首先将映射迭代 $N_{\\text{transient}}$ 步，让轨道稳定到其吸引子上。然后我们记录随后的 $N_{\\text{sample}}$ 个点用于分析。\n\n**2. 用于稳定性分析的李雅普诺夫指数**\n\n轨道的稳定性由李雅普诺夫指数（LE）$\\lambda$ 来量化。对于给定的轨道 $(x_n)$，它被定义为无限近轨迹指数发散的平均速率：\n$$\\lambda = \\lim_{N \\to \\infty} \\frac{1}{N}\\sum_{n=0}^{N-1} \\ln |f_r'(x_n)|$$\n逻辑斯谛映射的导数是 $f_r'(x) = r (1 - 2x)$。负的李雅普诺夫指数（$\\lambda  0$）表示邻近轨迹收敛，这是稳定轨道（如不动点或周期循环）的特征。正的李雅普诺夫指数（$\\lambda > 0$）表示指数发散，这是混沌的标志。\n\n在我们的计算方法中，我们用轨道瞬态后的 $N_{\\text{sample}}$ 个点上的有限时间平均来近似李雅普诺夫指数：\n$$\\hat{\\lambda} \\approx \\frac{1}{N_{\\text{sample}}} \\sum_{i=0}^{N_{\\text{sample}}-1} \\ln|f_r'(x_{N_{\\text{transient}}+i})|$$\n\n**3. 轨道分类算法**\n\n为了确定给定 $r$ 的轨道性质，我们实现一个执行以下步骤的函数：\n\n1.  **生成轨道并计算LE**：从 $x_0$ 开始，为 $N_{\\text{transient}} + N_{\\text{sample}}$ 次迭代生成轨道。存储最后的 $N_{\\text{sample}}$ 个点。同时，在采样阶段计算 LE 的和 $\\sum \\ln|f_r'(x_n)|$ 以求得 $\\hat{\\lambda}$。\n\n2.  **搜索最小周期**：我们搜索表征轨道的最小整数周期 $p$（其中 $1 \\le p \\le p_{\\max}$）。这是通过从 $1$ 到 $p_{\\max}$ 迭代 $p$ 来完成的。第一个满足以下条件的 $p$ 值被认为是最小周期 $p_{\\text{candidate}}$。\n    *   **复现条件**：轨道必须每 $p$ 步重复一次。在数值上，我们测试序列的最后 $p$ 个点是否与它们之前的 $p$ 个点在小容差 $\\varepsilon$ 内匹配。即，对于 $k \\in \\{0, 1, \\dots, p-1\\}$，我们检查是否 $|x_{N-1-k} - x_{N-1-k-p}|  \\varepsilon$，其中 $N = N_{\\text{transient}} + N_{\\text{sample}}$。\n    *   **不同相条件**：为了使周期 $p > 1$ 有效，其组成点必须在数值上是不同的。我们通过检查最后 $p$ 个点循环中的任意两点 $c_i, c_j$，对于 $i \\neq j$ 是否有 $|c_i - c_j| \\ge \\varepsilon$ 来验证这一点。\n\n3.  **最终分类**：一个轨道只有在找到一个最小周期 $p_{\\text{candidate}} > 0$ **并且**其对应的有限时间李雅普诺夫指数为负（$\\hat{\\lambda}  0$）时，才被分类为稳定的周期-$p$ 循环。如果 $p_{\\text{candidate}}>0$ 但 $\\hat{\\lambda} \\ge 0$，则轨道是周期性的但不稳定，因此我们根据问题的稳定性要求将其分类为非周期的（周期 $0$）。如果没有找到周期 $p \\le p_{\\max}$，轨道也被分类为非周期的（周期 $0$）。\n\n**4. 参数扫描算法**\n\n为了分析参数 $r$ 在一个区间上的属性，我们采用扫描算法：\n1.  **离散化参数空间**：在区间 $[r_{\\min}, r_{\\max}]$ 上创建一个步长为 $\\Delta r$ 的均匀 $r$ 值网格。\n\n2.  **分类每个点**：对于网格上的每个 $r_i$，执行上述轨道分类算法以确定其周期。\n\n3.  **计算窗口测度**：目标周期-$p$ 窗口的测度（或总宽度）通过黎曼和来近似。我们对网格上每个被分类为具有目标周期 $p$ 的 $r_i$ 求和步长 $\\Delta r$：\n    $$M_p = \\sum_{r_i \\text{ 其中周期为 } p} \\Delta r$$\n\n4.  **计算连续段**：为了计算目标周期的独立连续段的数量，我们遍历每个 $r_i$ 的分类序列。仅当遇到一个具有目标周期的点，而其前一个点具有不同周期时，计数器才递增，这标志着一个新段的开始。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef analyze_orbit(r, x0, N_transient, N_sample, p_max, tol):\n    \"\"\"\n    Analyzes the logistic map orbit for a given parameter r.\n    \n    Returns the detected least period p if the orbit is stable (LE  0),\n    otherwise returns 0.\n    \"\"\"\n    # Step 1: Generate orbit and compute Lyapunov exponent\n    x = x0\n    orbit_points = np.zeros(N_transient + N_sample)\n    \n    # Generate the full orbit\n    for i in range(N_transient + N_sample):\n        x = r * x * (1.0 - x)\n        orbit_points[i] = x\n\n    # Extract the post-transient part of the orbit\n    orbit_sample = orbit_points[N_transient:]\n    \n    le_sum = 0.0\n    for val in orbit_sample:\n        derivative_val = r * (1.0 - 2.0 * val)\n        # Prevent log(0) if x lands exactly on 0.5\n        if abs(derivative_val) > 1e-12:\n            le_sum += np.log(abs(derivative_val))\n    \n    le = le_sum / N_sample\n\n    # Step 2: Find minimal period p = p_max\n    p_candidate = 0\n    for p in range(1, p_max + 1):\n        # Ensure there are enough points in the orbit to check for period p\n        if N_sample  2 * p:\n            continue\n\n        # Check recurrence condition for the last p points of the sample\n        is_periodic = True\n        for k in range(p):\n            if abs(orbit_sample[-1 - k] - orbit_sample[-1 - k - p]) >= tol:\n                is_periodic = False\n                break\n        \n        if is_periodic:\n            # Minimal period found (due to loop order). Now check for distinct phases.\n            if p > 1:\n                last_cycle = orbit_sample[-p:]\n                phases_distinct = True\n                for i in range(p):\n                    for j in range(i + 1, p):\n                        if abs(last_cycle[i] - last_cycle[j])  tol:\n                            phases_distinct = False\n                            break\n                    if not phases_distinct:\n                        break\n                \n                if not phases_distinct:\n                    # Not a true p-cycle (numerically collapsed phases), try a larger p\n                    continue\n\n            # Found minimal period p with distinct phases.\n            p_candidate = p\n            break  # Exit the loop for p\n\n    # Step 3: Classify based on Lyapunov exponent\n    if p_candidate > 0 and le  0:\n        return p_candidate\n    else:\n        return 0\n\ndef solve():\n    \"\"\"\n    Solves all test cases as specified in the problem statement.\n    \"\"\"\n    results = []\n    \n    # Case 1: Period detection in period-3 window\n    params1 = {'r': 3.82842712, 'x0': 0.2, 'N_transient': 2000, 'N_sample': 1500, 'p_max': 10, 'tol': 1e-7}\n    p1 = analyze_orbit(**params1)\n    results.append(p1)\n\n    # Case 2: Period detection in chaotic region\n    params2 = {'r': 3.57, 'x0': 0.5, 'N_transient': 2000, 'N_sample': 1500, 'p_max': 10, 'tol': 1e-7}\n    p2 = analyze_orbit(**params2)\n    results.append(p2)\n\n    # Cases 3 and 4: Measure and segment count of period-3 window\n    r_min3, r_max3, dr3 = 3.82, 3.86, 1e-4\n    params3 = {'x0': 0.5, 'N_transient': 2000, 'N_sample': 1000, 'p_max': 10, 'tol': 1e-7}\n    target_p3 = 3\n    \n    num_points3 = int(round((r_max3 - r_min3) / dr3)) + 1\n    r_values3 = np.linspace(r_min3, r_max3, num_points3)\n    \n    measure3 = 0.0\n    segments4 = 0\n    in_segment = False\n    \n    for r_val in r_values3:\n        p = analyze_orbit(r_val, **params3)\n        if p == target_p3:\n            measure3 += dr3\n            if not in_segment:\n                segments4 += 1\n                in_segment = True\n        else:\n            in_segment = False\n            \n    m3 = round(measure3, 6)\n    c4 = segments4\n    results.append(f\"{m3:.6f}\")\n    results.append(c4)\n\n    # Case 5: Measure of period-3 windows over a wider interval\n    r_min5, r_max5, dr5 = 3.5, 4.0, 1e-3\n    params5 = {'x0': 0.5, 'N_transient': 2000, 'N_sample': 1000, 'p_max': 10, 'tol': 1e-7}\n    target_p5 = 3\n    \n    num_points5 = int(round((r_max5 - r_min5) / dr5)) + 1\n    r_values5 = np.linspace(r_min5, r_max5, num_points5)\n    \n    measure5 = 0.0\n    for r_val in r_values5:\n        p = analyze_orbit(r_val, **params5)\n        if p == target_p5:\n            measure5 += dr5\n\n    m5 = round(measure5, 6)\n    results.append(f\"{m5:.6f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3105341"}, {"introduction": "逻辑斯谛映射展示了一维系统中的混沌，但许多真实世界的系统是连续和多维的，例如以其蝴蝶形状吸引子而闻名的洛伦兹系统。本练习将引导你从定性观察转向定量测量，通过计算最大李雅普诺夫指数——衡量系统对初始条件敏感性的黄金标准[@problem_id:3105291]。你将实现并比较不同的数值积分方案，从而深刻理解算法和步长的选择如何影响混沌动力学长期模拟结果的可靠性。", "problem": "考虑由状态向量 $\\mathbf{x}(t) = (x(t), y(t), z(t))$ 定义的 Lorenz 常微分方程 (ODE) 系统：\n$$\n\\dot{x} = \\sigma\\,(y - x), \\quad\n\\dot{y} = x\\,(\\rho - z) - y, \\quad\n\\dot{z} = x\\,y - \\beta\\,z,\n$$\n其中 $\\sigma$、$\\rho$ 和 $\\beta$ 是正参数。最大李雅普诺夫指数 (LE) $\\lambda_{\\max}$ 衡量了流 $\\Phi^t$ 的邻近轨道分离的平均指数速率，可以从第一性原理定义为：\n$$\n\\lambda_{\\max} = \\lim_{t \\to \\infty} \\frac{1}{t} \\ln \\frac{\\|\\delta \\mathbf{x}(t)\\|}{\\|\\delta \\mathbf{x}(0)\\|},\n$$\n其中 $\\delta \\mathbf{x}(t)$ 根据围绕 $\\mathbf{x}(t)$ 的线性化（变分）动力学演化。变分方程为：\n$$\n\\frac{d}{dt}\\,\\delta \\mathbf{x} = J(\\mathbf{x}(t))\\,\\delta \\mathbf{x},\n$$\n其中 $J(\\mathbf{x})$ 是沿轨道 $\\mathbf{x}(t)$ 求值的向量场的雅可比矩阵。对于 Lorenz 系统，\n$$\nJ(\\mathbf{x}) =\n\\begin{bmatrix}\n-\\sigma  \\sigma  0 \\\\\n\\rho - z  -1  -x \\\\\ny  x  -\\beta\n\\end{bmatrix}.\n$$\n\n任务：编写一个完整的、可运行的程序，使用三种不同的时间步进格式，对 Lorenz 系统的最大李雅普诺夫指数 $\\lambda_{\\max}$ 进行数值估计：\n- 显式二阶 Runge–Kutta (RK2，中点法)。\n- 显式经典四阶 Runge–Kutta (RK4)。\n- 具有自动步长控制的自适应嵌入式 Runge–Kutta (自适应 RK45)。\n\n你的程序必须：\n- 实现动力学为 $(\\mathbf{x}, \\delta \\mathbf{x})$ 的增广 ODE 系统\n$$\n\\frac{d}{dt} \\begin{bmatrix} \\mathbf{x} \\\\ \\delta \\mathbf{x} \\end{bmatrix}\n=\n\\begin{bmatrix}\n\\dot{\\mathbf{x}}(\\mathbf{x}) \\\\\nJ(\\mathbf{x})\\,\\delta \\mathbf{x}\n\\end{bmatrix}.\n$$\n- 对系统进行时间演化，每隔 $\\tau_R$ 时间单位周期性地将微扰向量 $\\delta \\mathbf{x}$ 重新归一化至一个固定的微小范数 $\\delta_0$，以避免 $\\delta \\mathbf{x}$ 范数出现上溢或下溢。如果在重新归一化之前的微扰范数是 $\\|\\delta \\mathbf{x}\\|$，则累加 $\\ln\\left(\\|\\delta \\mathbf{x}\\|/\\delta_0\\right)$，然后设置 $\\delta \\mathbf{x} \\leftarrow \\delta_0\\, \\delta \\mathbf{x} / \\|\\delta \\mathbf{x}\\|$。从累加过程中舍弃一个持续时间为 $T_{\\mathrm{trans}}$ 的初始暂态区间。在总积分时间 $T_{\\mathrm{tot}}$ 结束后，估计：\n$$\n\\hat{\\lambda}_{\\max} = \\frac{1}{T_{\\mathrm{tot}} - T_{\\mathrm{trans}}} \\sum_{k} \\ln\\left(\\frac{\\|\\delta \\mathbf{x}_k\\|}{\\delta_0}\\right),\n$$\n其中，求和遍及所有发生在时间 $T_{\\mathrm{trans}}$ 之后的重新归一化时刻。\n\n使用以下科学上合理且广泛使用的参数值和设置：\n- Lorenz 参数：$\\sigma = 10$，$\\rho = 28$，$\\beta = 8/3$。\n- 状态初始条件：$\\mathbf{x}(0) = (1, 1, 1)$。\n- 初始微扰：$\\delta \\mathbf{x}(0)$ 与 $x$ 轴对齐，并归一化为 $\\|\\delta \\mathbf{x}(0)\\| = \\delta_0$，其中 $\\delta_0 = 10^{-8}$。\n- 总积分时间：$T_{\\mathrm{tot}} = 20$。\n- 暂态舍弃时间：$T_{\\mathrm{trans}} = 5$。\n- 重新归一化间隔：$\\tau_R = 0.1$。\n\n要实现的时间步进格式和参数：\n- RK2 (中点法)，固定步长为 $h$。\n- RK4 (经典法)，固定步长为 $h$。\n- 自适应 RK45，使用嵌入式误差控制，相对容差为 $\\mathrm{rtol}$，绝对容差为 $\\mathrm{atol}$。\n\n测试套件：\n- 案例 $1$：RK2，其中 $h = 0.02$。\n- 案例 $2$：RK2，其中 $h = 0.005$。\n- 案例 $3$：RK4，其中 $h = 0.02$。\n- 案例 $4$：RK4，其中 $h = 0.005$。\n- 案例 $5$：自适应 RK45，其中 $\\mathrm{rtol} = 10^{-3}$ 且 $\\mathrm{atol} = 10^{-6}$。\n- 案例 $6$：自适应 RK45，其中 $\\mathrm{rtol} = 10^{-6}$ 且 $\\mathrm{atol} = 10^{-9}$。\n\n要求：\n- 为增广系统 $(\\mathbf{x}, \\delta \\mathbf{x})$ 显式地实现 RK2 和 RK4，并确保对于固定步长的情况，重新归一化间隔 $\\tau_R$ 是 $h$ 的整数倍。\n- 使用带有自动步长控制的嵌入式方法实现自适应 RK45（您可以使用标准的科学计算库例程），在每个长度为 $\\tau_R$ 的区间上进行分段积分，以确保重新归一化恰好在 $\\tau_R$ 的倍数时刻发生。\n- 按上述规定为每个测试案例估计 $\\hat{\\lambda}_{\\max}$，并将每个结果四舍五入到四位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为按测试套件顺序排列的结果，例如 $[\\hat{\\lambda}_1,\\hat{\\lambda}_2,\\hat{\\lambda}_3,\\hat{\\lambda}_4,\\hat{\\lambda}_5,\\hat{\\lambda}_6]$，其中每个 $\\hat{\\lambda}_i$ 都四舍五入到四位小数。\n\n关于您推导和设计所用基础的说明：\n- 使用 ODE 的定义、由 ODE 生成的流映射以及通过线性化动力学得到的李雅普诺夫指数的定义作为基本依据。\n- 使用经过充分检验的误差阶事实：对于足够光滑的问题，阶数为 $p$ 的固定步长显式 Runge–Kutta 方法的全局截斷误差与 $h^p$ 成正比；自适应嵌入式 Runge–Kutta 格式通过控制局部误差来满足指定的容差。不要引用或使用任何绕过从变分方程和重新归一化过程推导估计量的现成公式。\n\n最终输出格式：\n- 一行包含 $6$ 个浮点数的列表，每个浮点数四舍五入到四位小数，格式严格为 $[\\text{float},\\text{float},\\text{float},\\text{float},\\text{float},\\text{float}]$，没有空格。", "solution": "该问题要求对 Lorenz 系统的最大李雅普诺夫指数 $\\lambda_{\\max}$进行数值估计。指定的方法是基于以下步骤的标准算法：首先对常微分方程(ODE)系统及其相应的变分方程组成的增广系统进行积分，然后对微扰向量进行周期性的重新归一化。\n\n首先，我们定义增广状态向量 $\\mathbf{Y}(t) \\in \\mathbb{R}^6$。该向量结合了原始状态向量 $\\mathbf{x}(t) = [x(t), y(t), z(t)]^T$ 和无穷小微扰向量 $\\delta\\mathbf{x}(t) = [\\delta x(t), \\delta y(t), \\delta z(t)]^T$。因此，$\\mathbf{Y}(t) = [\\mathbf{x}(t)^T, \\delta\\mathbf{x}(t)^T]^T$。这个增广状态的时间演化由一个包含六个耦合一阶常微分方程的系统决定：\n$$\n\\frac{d\\mathbf{Y}}{dt} = \\mathbf{F}(\\mathbf{Y}(t)) =\n\\begin{bmatrix}\n\\dot{\\mathbf{x}}(\\mathbf{x}) \\\\\n\\frac{d}{dt}\\delta\\mathbf{x}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{f}(\\mathbf{x}) \\\\\nJ(\\mathbf{x})\\,\\delta\\mathbf{x}\n\\end{bmatrix}\n$$\n其中 $\\mathbf{f}(\\mathbf{x})$ 是 Lorenz 系统的向量场，$J(\\mathbf{x})$ 是其雅可比矩阵。\n\n$\\mathbf{f}(\\mathbf{x})$ 的分量由以下各式给出：\n$$\n\\begin{aligned}\n\\dot{x} = \\sigma (y - x) \\\\\n\\dot{y} = x (\\rho - z) - y \\\\\n\\dot{z} = x y - \\beta z\n\\end{aligned}\n$$\n雅可比矩阵 $J(\\mathbf{x}) = \\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{x}}$ 为：\n$$\nJ(\\mathbf{x}) =\n\\begin{bmatrix}\n-\\sigma  \\sigma  0 \\\\\n\\rho - z  -1  -x \\\\\ny  x  -\\beta\n\\end{bmatrix}\n$$\n参数指定为 $\\sigma = 10$，$\\rho = 28$ 和 $\\beta = 8/3$。\n\n最大李雅普诺夫指数由邻近轨道的长期平均指数分离率定义：\n$$\n\\lambda_{\\max} = \\lim_{t \\to \\infty} \\frac{1}{t} \\ln \\frac{\\|\\delta \\mathbf{x}(t)\\|}{\\|\\delta \\mathbf{x}(0)\\|}\n$$\n由于 $\\|\\delta \\mathbf{x}(t)\\|$ 呈指数增长，直接对变分方程进行数值积分会导致上溢。为规避此问题，我们采用重新归一化程序。总积分时间 $T_{\\mathrm{tot}}$ 被划分为 $N = T_{\\mathrm{tot}} / \\tau_R$ 个长度为 $\\tau_R$ 的区间。\n\n算法流程如下：\n1.  在 $t=0$ 时初始化状态：$\\mathbf{x}(0) = (1, 1, 1)$ 和 $\\delta\\mathbf{x}(0) = (\\delta_0, 0, 0)$，其中 $\\delta_0 = 10^{-8}$。这设定了初始增广状态 $\\mathbf{Y}(0)$。\n2.  对于每个区间 $k=1, \\dots, N$，在时间范围 $[(k-1)\\tau_R, k\\tau_R]$ 上对 6D 系统 $\\dot{\\mathbf{Y}} = \\mathbf{F}(\\mathbf{Y})$ 进行积分。\n3.  设区间末端的微扰向量为 $\\delta\\mathbf{x}_k^{\\text{pre}}$。计算其范数 $d_k = \\|\\delta\\mathbf{x}_k^{\\text{pre}}\\|$。\n4.  如果当前时间 $t_k = k\\tau_R$ 大于暂态时间 $T_{\\mathrm{trans}}$，则将值 $\\ln(d_k / \\delta_0)$ 累加到一个总和中。项 $d_k/\\delta_0$ 代表了微扰在长度为 $\\tau_R$ 的区间内的增长因子。\n5.  将微扰向量重新归一化，使其范数为 $\\delta_0$：$\\delta\\mathbf{x}_k^{\\text{post}} = (\\delta_0 / d_k) \\delta\\mathbf{x}_k^{\\text{pre}}$。这个新向量将用作下一个积分区间中 $\\mathbf{Y}$ 的微扰部分的初始条件。状态部分 $\\mathbf{x}$ 的演化则不受影响地继续。\n6.  在总时间 $T_{\\mathrm{tot}}$ 积分完成后，最大李雅普诺夫指数的估计值通过计算非暂态时段内累加的对数增长因子之时间平均值得到：\n$$\n\\hat{\\lambda}_{\\max} = \\frac{1}{T_{\\mathrm{tot}} - T_{\\mathrm{trans}}} \\sum_{k \\text{ s.t. } k\\tau_R > T_{\\mathrm{trans}}} \\ln\\left(\\frac{d_k}{\\delta_0}\\right)\n$$\n模拟参数为 $T_{\\mathrm{tot}} = 20$，$T_{\\mathrm{trans}} = 5$ 和 $\\tau_R = 0.1$。\n\n我们为此过程实现了三种数值积分格式：\n\n**1. 固定步长 Runge-Kutta 方法 (RK2 和 RK4):**\n对于一个 ODE 系统 $\\dot{\\mathbf{Y}} = \\mathbf{F}(t, \\mathbf{Y})$，从 $t_n$ 到 $t_{n+1} = t_n + h$ 的单步计算如下：\n- **RK2 (中点法):**\n  $$\n  \\begin{aligned}\n  \\mathbf{k}_1 = \\mathbf{F}(t_n, \\mathbf{Y}_n) \\\\\n  \\mathbf{k}_2 = \\mathbf{F}(t_n + h/2, \\mathbf{Y}_n + (h/2)\\mathbf{k}_1) \\\\\n  \\mathbf{Y}_{n+1} = \\mathbf{Y}_n + h \\mathbf{k}_2\n  \\end{aligned}\n  $$\n- **RK4 (经典法):**\n  $$\n  \\begin{aligned}\n  \\mathbf{k}_1 = \\mathbf{F}(t_n, \\mathbf{Y}_n) \\\\\n  \\mathbf{k}_2 = \\mathbf{F}(t_n + h/2, \\mathbf{Y}_n + (h/2)\\mathbf{k}_1) \\\\\n  \\mathbf{k}_3 = \\mathbf{F}(t_n + h/2, \\mathbf{Y}_n + (h/2)\\mathbf{k}_2) \\\\\n  \\mathbf{k}_4 = \\mathbf{F}(t_n + h, \\mathbf{Y}_n + h\\mathbf{k}_3) \\\\\n  \\mathbf{Y}_{n+1} = \\mathbf{Y}_n + (h/6)(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n  \\end{aligned}\n  $$\n对于每个持续时间为 $\\tau_R$ 的重新归一化区间，我们执行 $M = \\tau_R / h$ 步所选的固定步长积分器。\n\n**2. 自适应 Runge-Kutta 方法 (RK45):**\n此方法使用一对嵌入式的四阶和五阶 Runge-Kutta 公式来估计每一步的局部截断误差。步长会自动调整，以将此误差保持在用户指定的相对容差 $\\mathrm{rtol}$ 和绝对容差 $\\mathrm{atol}$ 之内。我们使用 `scipy.integrate.solve_ivp` 函数并设置 `method='RK45'`。为确保重新归一化恰好在 $\\tau_R$ 的倍数时刻发生，我们对每个区间 $[(k-1)\\tau_R, k\\tau_R]$ 独立调用此求解器。\n\n程序会针对六个测试案例计算 $\\hat{\\lambda}_{\\max}$，这些案例的积分方法及其参数（$h$、$\\mathrm{rtol}$、$\\mathrm{atol}$）各不相同，并将每个结果四舍五入到四位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# --- Problem Parameters ---\n# Lorenz system parameters\nSIGMA = 10.0\nRHO = 28.0\nBETA = 8.0 / 3.0\n\n# Simulation parameters\nT_TOT = 20.0\nT_TRANS = 5.0\nTAU_R = 0.1\nDELTA_0 = 1e-8\n\ndef lorenz_augmented(t, Y):\n    \"\"\"\n    Defines the augmented ODE system for the Lorenz equations and their\n    variational dynamics.\n    \n    Args:\n        t (float): Current time (unused, for compatibility with solvers).\n        Y (np.ndarray): 6-element state vector [x, y, z, dx, dy, dz].\n\n    Returns:\n        np.ndarray: 6-element time derivative vector dY/dt.\n    \"\"\"\n    x, y, z = Y[0], Y[1], Y[2]\n    d_vec = Y[3:]\n\n    # Lorenz system dynamics\n    dxdt = SIGMA * (y - x)\n    dydt = x * (RHO - z) - y\n    dzdt = x * y - BETA * z\n    \n    # Jacobian matrix J(x)\n    J = np.array([\n        [-SIGMA, SIGMA, 0.0],\n        [RHO - z, -1.0, -x],\n        [y, x, -BETA]\n    ])\n\n    # Variational equation dynamics\n    d_delta_vec_dt = J @ d_vec\n    \n    return np.hstack(([dxdt, dydt, dzdt], d_delta_vec_dt))\n\ndef rk2_step(f, t, y, h):\n    \"\"\"Performs a single step of the RK2 (midpoint) method.\"\"\"\n    k1 = f(t, y)\n    k2 = f(t + h / 2.0, y + h / 2.0 * k1)\n    return y + h * k2\n\ndef rk4_step(f, t, y, h):\n    \"\"\"Performs a single step of the classical RK4 method.\"\"\"\n    k1 = f(t, y)\n    k2 = f(t + h / 2.0, y + h / 2.0 * k1)\n    k3 = f(t + h / 2.0, y + h / 2.0 * k2)\n    k4 = f(t + h, y + h * k3)\n    return y + h / 6.0 * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\ndef calculate_lyapunov(method, h=None, rtol=None, atol=None):\n    \"\"\"\n    Calculates the largest Lyapunov exponent for the Lorenz system\n    using the specified numerical method and parameters.\n    \n    Args:\n        method (str): 'rk2', 'rk4', or 'rk45'.\n        h (float, optional): Fixed step size for RK2/RK4.\n        rtol (float, optional): Relative tolerance for RK45.\n        atol (float, optional): Absolute tolerance for RK45.\n        \n    Returns:\n        float: The estimated largest Lyapunov exponent.\n    \"\"\"\n    # Initial conditions\n    x0 = np.array([1.0, 1.0, 1.0])\n    dx0 = np.array([DELTA_0, 0.0, 0.0]) # Perturbation aligned with x-axis\n    Y = np.hstack((x0, dx0))\n    \n    t = 0.0\n    log_sum = 0.0\n    \n    num_renorm_intervals = int(round(T_TOT / TAU_R))\n    \n    for i in range(num_renorm_intervals):\n        t_start = i * TAU_R\n        t_end = (i + 1) * TAU_R\n        \n        # Integrate over one re-normalization interval\n        if method in ['rk2', 'rk4']:\n            num_steps = int(round(TAU_R / h))\n            solver_step = rk2_step if method == 'rk2' else rk4_step\n            Y_interval = Y.copy()\n            t_interval = t_start\n            for _ in range(num_steps):\n                Y_interval = solver_step(lorenz_augmented, t_interval, Y_interval, h)\n                t_interval += h\n            Y = Y_interval\n        elif method == 'rk45':\n            sol = solve_ivp(lorenz_augmented, (t_start, t_end), Y, \n                            method='RK45', rtol=rtol, atol=atol)\n            Y = sol.y[:, -1]\n\n        t = t_end\n        \n        # Extract perturbation vector and calculate its norm\n        delta_x = Y[3:]\n        norm_delta_x = np.linalg.norm(delta_x)\n        \n        # Accumulate log of growth factor after transient period\n        if t > T_TRANS:\n            # Avoid log(0) in case of underflow\n            if norm_delta_x > 0:\n                log_sum += np.log(norm_delta_x / DELTA_0)\n        \n        # Re-normalize perturbation vector\n        Y[3:] = (delta_x / norm_delta_x) * DELTA_0 if norm_delta_x > 0 else dx0\n    \n    # Calculate final Lyapunov exponent estimate\n    lambda_max = log_sum / (T_TOT - T_TRANS)\n    return lambda_max\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {'method': 'rk2', 'h': 0.02},\n        {'method': 'rk2', 'h': 0.005},\n        {'method': 'rk4', 'h': 0.02},\n        {'method': 'rk4', 'h': 0.005},\n        {'method': 'rk45', 'rtol': 1e-3, 'atol': 1e-6},\n        {'method': 'rk45', 'rtol': 1e-6, 'atol': 1e-9},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_lyapunov(**case)\n        results.append(f\"{result:.4f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3105291"}, {"introduction": "即使拥有完美的模型和强大的计算机，预测混沌系统的未来也存在着根本性的限制。本练习将探讨混沌与计算机有限精度算术之间的相互作用，揭示这一限制的来源[@problem_id:3105374]。通过使用单精度和双精度并行模拟洛伦兹系统，你将亲眼见证微不足道的舍入误差如何被指数级放大，最终导致两条数值轨迹大相径庭。这个练习让你能够具体地估算“阴影时间”（shadowing time），即一个计算轨迹在多长时间内能够“伴随”某个真实轨迹，从而为你揭示数值模拟的有效性边界。", "problem": "考虑由以下常微分方程（ODE）组定义的洛伦兹初值问题\n$$\n\\frac{dx}{dt} = \\sigma (y - x), \\quad \\frac{dy}{dt} = x(\\rho - z) - y, \\quad \\frac{dz}{dt} = xy - \\beta z,\n$$\n其中 $x$、$y$ 和 $z$ 是状态变量，而 $\\sigma$、$\\rho$ 和 $\\beta$ 是固定的实数参数。该系统是一个经典的混沌动力学系统。在一个混沌系统中，状态或计算中的微小扰动会随时间增长，导致轨迹发散。数值积分中的浮点舍入和截断误差就充当了此类扰动。\n\n你的任务是编写一个完整、可运行的计算机程序，该程序能够：\n- 使用一个为求解该 ODE 初值问题、从第一性原理推导出的固定步长数值积分器来模拟洛伦兹系统。使用与四阶龙格-库塔（RK）格式相符的方法，在离散时间点 $t_k = k \\,\\Delta t$（其中 $k = 0,1,\\dots,N$）上近似求解，时间步长为 $\\Delta t$，总时长为 $T_{\\text{total}} = N \\Delta t$。\n- 在相同的参数和初始条件下，并行运行两次模拟：一次使用单精度（IEEE $754$ binary$32$，此后表示为 $\\text{float32}$），另一次使用双精度（IEEE $754$ binary$64$，此后表示为 $\\text{float64}$）。确保每次运行中的所有算术运算都遵循各自的精度。\n- 在每一步 $k$ 计算差值的欧几里得范数，以测量两条轨迹之间的发散度\n$$\ns_k = \\left\\| \\mathbf{x}^{(32)}_k - \\mathbf{x}^{(64)}_k \\right\\|_2,\n$$\n其中 $\\mathbf{x}^{(p)}_k$ 表示在精度 $p \\in \\{32, 64\\}$ 下计算得到的状态向量。\n- 对于给定的容差 $\\varepsilon$，将阴影时间 $T_{\\text{shadow}}$ 估计为满足 $s_k \\ge \\varepsilon$ 的最早离散时间 $t_k$。如果在 $T_{\\text{total}}$ 之前不存在这样的 $k$，则设 $T_{\\text{shadow}} = T_{\\text{total}}$。\n\n需使用并遵循的基本依据：\n- 上述洛伦兹 ODE 定义。\n- 初值问题的表述，以及基于评估瞬时变化率并将其聚合以近似流的固定步长时间离散化概念。\n- 浮点算术的概念，其中舍入误差会在动力学系统中累积和传播。\n\n在所有模拟中使用以下固定参数：\n- $\\sigma = 10$, $\\rho = 28$, $\\beta = \\frac{8}{3}$.\n- 初始条件 $\\mathbf{x}_0 = (1, 1, 1)$。\n- 时间变量 $t$ 是无量纲的；报告时间时也使用相同的无量纲单位。不应用任何物理单位。\n\n定义并应用由3个案例组成的测试套件，每个案例由 $(\\Delta t, T_{\\text{total}}, \\varepsilon)$ 指定：\n- 案例 1：$\\Delta t = 0.01$, $T_{\\text{total}} = 30$, $\\varepsilon = 10^{-3}$。\n- 案例 2：$\\Delta t = 0.02$, $T_{\\text{total}} = 30$, $\\varepsilon = 10^{-2}$。\n- 案例 3：$\\Delta t = 0.005$, $T_{\\text{total}} = 50$, $\\varepsilon = 10^{-5}$。\n\n覆盖范围理由：\n- 案例 1 是一个标准的“理想路径”，具有适中的步长和容差。\n- 案例 2 探究对更粗离散化的敏感性，这可能会放大数值误差并加速发散。\n- 案例 3 使用更精细的步长和非常小的容差来检验早期的指数分离和阈值穿越情况。\n\n对于每个案例，你的程序必须计算并返回两个量：\n- 如上定义的 $T_{\\text{shadow}}$。\n- 在 $t_N = T_{\\text{total}}$ 时的最后一步发散度 $s_N$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含所有 3 个测试案例的结果，格式为一个用方括号括起来的逗号分隔列表，其中每个案例的结果本身是一个包含两个浮点数 $[T_{\\text{shadow}}, s_N]$ 的列表。例如，输出必须具有以下形式\n$$\n\\texttt{[[T_1,s_1],[T_2,s_2],[T_3,s_3]]}\n$$\n其中 $T_i$ 和 $s_i$ 由具体数值替代。不应打印任何额外文本。", "solution": "洛伦兹系统是一组耦合常微分方程（ODE），它在 $\\mathbb{R}^3$ 上定义了一个确定性流 $\\Phi_t$。给定参数 $(\\sigma,\\rho,\\beta)$ 和初始条件 $\\mathbf{x}_0 = (x_0,y_0,z_0)$，该初值问题旨在求解满足以下条件的 $\\mathbf{x}(t)$\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{f}(\\mathbf{x}) \\quad \\text{with} \\quad \\mathbf{x}(0) = \\mathbf{x}_0,\n$$\n其中\n$$\n\\mathbf{f}(\\mathbf{x}) = \\begin{bmatrix}\n\\sigma(y - x)\\\\\nx(\\rho - z) - y\\\\\nxy - \\beta z\n\\end{bmatrix}.\n$$\n计算近似解的一种标准方法是将时间离散化为大小为 $\\Delta t$ 的步长，并应用一种固定步长的显式方法，该方法通过组合由瞬时变化率计算出的局部更新来近似流。四阶龙格-库塔（RK$4$）方法是通过将精确解的泰勒展开匹配到四阶项而推导出来的。在从 $\\mathbf{x}_k$ 到 $\\mathbf{x}_{k+1}$ 的每一步中，RK$4$ 方法会进行分阶段的斜率评估计算：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{x}_k),\\\\\n\\mathbf{k}_2 = \\mathbf{f}\\!\\left(\\mathbf{x}_k + \\frac{\\Delta t}{2}\\mathbf{k}_1\\right),\\\\\n\\mathbf{k}_3 = \\mathbf{f}\\!\\left(\\mathbf{x}_k + \\frac{\\Delta t}{2}\\mathbf{k}_2\\right),\\\\\n\\mathbf{k}_4 = \\mathbf{f}\\!\\left(\\mathbf{x}_k + \\Delta t\\,\\mathbf{k}_3\\right),\n\\end{aligned}\n$$\n并通过以下方式推进状态：\n$$\n\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\Delta t\\,\\frac{1}{6}\\left(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4\\right).\n$$\n这种构造源于在区间 $[t_k, t_{k+1}]$ 上对 ODE 进行积分，并使用匹配局部截断误差阶数条件的求积法来近似该积分。\n\n数字计算机上的浮点运算将实数表示为一个带舍入的有限集合。在 IEEE $754$ binary$32$（单精度）中，机器 ε（1 与大于 1 的下一个可表示数之间的距离）约为 $2^{-23} \\approx 1.19\\times 10^{-7}$，而在 IEEE $754$ binary$64$（双精度）中，其值约为 $2^{-52} \\approx 2.22\\times 10^{-16}$。在所选精度下，每次算术运算都会因舍入到最接近的可表示数而引入一个微小的扰动。\n\n以正的最大李雅普诺夫指数为特征的混沌动力学，在足够短的时间内会以指数方式放大微小扰动。如果 $\\lambda_{\\max} > 0$ 表示最大李雅普诺夫指数，那么对于足够小的初始分离距离 $s_0$ 并在线性化范围内，两条邻近轨迹之间的分离距离 $s(t)$ 遵循\n$$\ns(t) \\approx s_0\\,e^{\\lambda_{\\max} t}.\n$$\n因此，达到阈值 $\\varepsilon$ 所需的时间近似为\n$$\nT_{\\text{shadow}} \\approx \\frac{1}{\\lambda_{\\max}} \\ln\\!\\left(\\frac{\\varepsilon}{s_0}\\right),\n$$\n这说明了它对初始分离距离 $s_0$（在此由单精度和双精度计算之间舍入差异的累积所隐含设定）和系统失稳率的依赖性。\n\n算法设计：\n- 使用相同的数值方法（RK$4$）、时间步长 $\\Delta t$、参数 $(\\sigma,\\rho,\\beta)$ 和初始条件 $\\mathbf{x}_0$ 并行计算两条轨迹，但使用不同的算术精度：一条使用 $\\text{float32}$，另一条使用 $\\text{float64}$。确保每次运行中的所有中间量和常数都转换为各自的精度，以隔离浮点效应。\n- 在每个离散时间 $t_k = k\\,\\Delta t$，计算欧几里得分离距离\n$$\ns_k = \\left\\|\\mathbf{x}^{(32)}_k - \\mathbf{x}^{(64)}_k\\right\\|_2 = \\sqrt{(x^{(32)}_k - x^{(64)}_k)^2 + (y^{(32)}_k - y^{(64)}_k)^2 + (z^{(32)}_k - z^{(64)}_k)^2}.\n$$\n- 阴影时间确定为\n$$\nT_{\\text{shadow}} = \\min\\{t_k \\,:\\, s_k \\ge \\varepsilon\\},\n$$\n并约定，如果在 $T_{\\text{total}}$ 之前该集合为空，则 $T_{\\text{shadow}} = T_{\\text{total}}$。\n- 同时记录在 $t_N = T_{\\text{total}}$ 时的最后一步发散度 $s_N$，以量化模拟结束时的累积分离距离。\n\n测试套件：\n- 使用固定的参数 $\\sigma=10$, $\\rho=28$, $\\beta=8/3$，初始条件 $\\mathbf{x}_0=(1,1,1)$，以及指定的三个案例：\n  - 案例 1：$\\Delta t = 0.01$, $T_{\\text{total}} = 30$, $\\varepsilon=10^{-3}$。\n  - 案例 2：$\\Delta t = 0.02$, $T_{\\text{total}} = 30$, $\\varepsilon=10^{-2}$。\n  - 案例 3：$\\Delta t = 0.005$, $T_{\\text{total}} = 50$, $\\varepsilon=10^{-5}$。\n由于每个 $T_{\\text{total}}/\\Delta t$ 都是整数，离散网格与总时长精确对齐，从而避免了差一错误。\n\n程序计算并按要求的单行格式汇总结果：\n$$\n\\texttt{[[T_1,s_1],[T_2,s_2],[T_3,s_3]]}.\n$$\n这种设计直接探究了计算精度（$\\text{float32}$ 与 $\\text{float64}$）如何影响混沌系统中的发散，并为每种容差和步长选择提供了阴影时间的经验估计，其理论基础是 ODE 积分、浮点舍入以及对初始条件的敏感性等原理。", "answer": "```python\nimport numpy as np\n\ndef lorenz_deriv(x, sigma, rho, beta, dtype):\n    # x is a vector [x, y, z] with given dtype\n    # Returns derivative dx/dt as the same dtype vector.\n    x0 = x[0]; y0 = x[1]; z0 = x[2]\n    # Cast parameters to dtype to keep arithmetic consistent.\n    sigma = dtype(sigma)\n    rho = dtype(rho)\n    beta = dtype(beta)\n    dx = sigma * (y0 - x0)\n    dy = x0 * (rho - z0) - y0\n    dz = x0 * y0 - beta * z0\n    return np.array([dx, dy, dz], dtype=dtype)\n\ndef rk4_step(x, dt, sigma, rho, beta, dtype):\n    # One RK4 step with all arithmetic in given dtype.\n    dt = dtype(dt)\n    k1 = lorenz_deriv(x, sigma, rho, beta, dtype)\n    k2 = lorenz_deriv(x + (dt / dtype(2)) * k1, sigma, rho, beta, dtype)\n    k3 = lorenz_deriv(x + (dt / dtype(2)) * k2, sigma, rho, beta, dtype)\n    k4 = lorenz_deriv(x + dt * k3, sigma, rho, beta, dtype)\n    x_next = x + dt * (dtype(1)/dtype(6)) * (k1 + dtype(2)*k2 + dtype(2)*k3 + k4)\n    return x_next\n\ndef shadowing_time_and_final_separation(x0, sigma, rho, beta, dt, T_total, epsilon):\n    \"\"\"\n    Integrate the Lorenz system in float32 and float64 in parallel using RK4.\n    Compute the shadowing time T_shadow as the earliest t_k where separation >= epsilon.\n    Also return the final separation at t_N = T_total.\n    \"\"\"\n    # Ensure integer number of steps\n    steps = int(round(T_total / dt))\n    # Initialize states in respective precisions\n    x32 = np.array(x0, dtype=np.float32)\n    x64 = np.array(x0, dtype=np.float64)\n\n    T_shadow = None\n    separation_final = None\n\n    # Time loop\n    for k in range(steps):\n        # Advance both states\n        x32 = rk4_step(x32, dt, sigma, rho, beta, np.float32)\n        x64 = rk4_step(x64, dt, sigma, rho, beta, np.float64)\n        # Compute separation using higher precision for the difference\n        diff = x32.astype(np.float64) - x64\n        sep = float(np.linalg.norm(diff, ord=2))\n        # Record earliest crossing of epsilon\n        if T_shadow is None and sep >= epsilon:\n            T_shadow = (k + 1) * dt  # time after completing this step\n        # Update final separation\n        separation_final = sep\n\n    if T_shadow is None:\n        T_shadow = T_total\n\n    return float(T_shadow), float(separation_final)\n\ndef solve():\n    # Fixed Lorenz parameters and initial condition\n    sigma = 10.0\n    rho = 28.0\n    beta = 8.0 / 3.0\n    x0 = (1.0, 1.0, 1.0)\n\n    # Test suite: (dt, T_total, epsilon)\n    test_cases = [\n        (0.01, 30.0, 1e-3),   # Case 1: happy path\n        (0.02, 30.0, 1e-2),   # Case 2: coarser step, larger tolerance\n        (0.005, 50.0, 1e-5),  # Case 3: finer step, very small tolerance\n    ]\n\n    results = []\n    for dt, T_total, epsilon in test_cases:\n        T_shadow, s_final = shadowing_time_and_final_separation(\n            x0=x0, sigma=sigma, rho=rho, beta=beta, dt=dt, T_total=T_total, epsilon=epsilon\n        )\n        results.append([T_shadow, s_final])\n\n    # Final print statement in the exact required format.\n    # Single line, list of lists with floats.\n    print(f\"[{','.join('[' + ','.join(map(str, r)) + ']' for r in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3105374"}]}