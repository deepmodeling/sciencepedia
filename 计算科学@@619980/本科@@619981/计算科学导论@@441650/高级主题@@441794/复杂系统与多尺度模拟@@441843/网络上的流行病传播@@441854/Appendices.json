{"hands_on_practices": [{"introduction": "在疫情爆发初期，其传播速度是公共卫生应对的关键指标。本练习旨在通过动手实践，将网络拓扑的数学特性与疫情的宏观增长联系起来。您将学习如何从接触网络的邻接矩阵中推导出理论上的早期指数增长率 $r$，并通过直接的数值模拟来验证这一理论预测，从而深刻理解网络结构是如何决定流行病传播速度的。[@problem_id:3124341]", "problem": "要求您通过下一代矩阵（NGM）将流行病早期的指数增长与接触网络的结构联系起来，并通过直接计算的时间序列来验证该预测。请在以下设定下进行操作。\n\n使用的基本原理和定义：\n- 在静态、无向接触网络上的易感-感染-恢复（SIR）过程的早期阶段，设邻接矩阵为 $A$，每次接触的传播率为 $\\beta$（单位：$\\text{day}^{-1}$），恢复率为 $\\gamma$（单位：$\\text{day}^{-1}$），则期望的感染状态向量 $i(t)$ 根据线性常微分方程（ODE） $$\\frac{d}{dt} i(t) = \\left(\\beta A - \\gamma I\\right) i(t),$$ 演化，其中 $I$ 是单位矩阵，$i(t)$ 是每个节点的期望感染计数的向量。这是在感染比例很小时有效的标准线性化方法。\n- 下一代矩阵（NGM）$K$ 定义为在早期阶段，单个感染者在其整个感染期内通过边产生的二次感染的期望数量。在这种具有指数分布感染期的网络设置中，$K$ 由 $$K = \\frac{\\beta}{\\gamma} A.$$ 给出。$K$ 的主特征值（谱半径）记为 $\\rho(K)$。\n- 总感染数量定义为 $$I_{\\text{tot}}(t) = \\sum_{j} i_j(t).$$ 在早期阶段，预期 $$I_{\\text{tot}}(t) \\approx I_0 e^{r t},$$ 其中 $r$ 是早期指数增长率（单位：$\\text{day}^{-1}$），$I_0$ 是一个常数。\n\n您的任务：\n1. 从第一性原理和上述基础出发，推导一种从 $K$ 的主特征值计算早期指数增长率 $r$ 的方法。\n2. 通过从线性常微分方程生成时间序列来独立估计 $r$。请使用以下协议，以确保结果可复现且完全确定：\n   - 使用初始条件 $$i(0) = \\frac{1}{N} \\mathbf{1},$$ 其中 $N$ 是节点数，$\\mathbf{1}$ 是全1向量，因此 $$I_{\\text{tot}}(0) = 1.$$\n   - 使用矩阵指数精确求解线性常微分方程的解： $$i(t) = \\exp\\left[\\left(\\beta A - \\gamma I\\right) t\\right] i(0).$$\n   - 在 $t_{\\min}$ 到 $t_{\\max}$ 范围内以步长 $\\Delta t$ 均匀采样时间，其中 $$t_{\\min} = 0.5\\ \\text{days},\\quad t_{\\max} = 8.0\\ \\text{days},\\quad \\Delta t = 0.05\\ \\text{days}.$$\n   - 使用自然对数构建 $$y(t) = \\ln I_{\\text{tot}}(t)$$，并通过对采样时间点上的 $y(t)$ 与 $t$ 进行普通最小二乘法（OLS）线性回归，将斜率作为 $r_{\\text{fit}}$ 的估计值。\n3. 对于下面的每个测试用例，计算绝对差 $$\\left|r_{\\text{fit}} - r_{\\text{theory}}\\right|,$$ 其中 $r_{\\text{theory}}$ 是从 $K$ 的主特征值计算出的早期增长率，$r_{\\text{fit}}$ 是基于回归的估计值。\n\n测试套件（所有率的单位为 $\\text{day}^{-1}$，时间单位为天）：\n- 用例 $1$（长度为 $4$ 的路径图）： $$A_1 = \\begin{bmatrix} 0  1  0  0 \\\\ 1  0  1  0 \\\\ 0  1  0  1 \\\\ 0  0  1  0 \\end{bmatrix},\\quad \\beta_1 = 0.5,\\quad \\gamma_1 = 0.4.$$\n- 用例 $2$（$3$ 个节点上的完全图）： $$A_2 = \\begin{bmatrix} 0  1  1 \\\\ 1  0  1 \\\\ 1  1  0 \\end{bmatrix},\\quad \\beta_2 = 0.3,\\quad \\gamma_2 = 0.6.$$\n- 用例 $3$（$5$ 个节点上的星形图，节点 $0$ 是中心节点）： $$A_3 = \\begin{bmatrix} 0  1  1  1  1 \\\\ 1  0  0  0  0 \\\\ 1  0  0  0  0 \\\\ 1  0  0  0  0 \\\\ 1  0  0  0  0 \\end{bmatrix},\\quad \\beta_3 = 0.2,\\quad \\gamma_3 = 0.5.$$\n\n程序要求行为：\n- 为所有三个用例实现上述计算。\n- 您的程序必须输出一行，其中包含一个逗号分隔的列表，列表包含三个绝对差值，按用例 1、2、3 的顺序排列，并用方括号括起来。每个数字必须精确到 $6$ 位小数。例如，输出格式应如下所示： $$[0.000123,0.000000,0.000457].$$", "solution": "用户的要求是验证网络上流行病的早期指数增长率与下一代矩阵（NGM）谱特性之间的关系。这涉及两个主要任务：首先，从 NGM 的主特征值推导出理论增长率 $r_{\\text{theory}}$；其次，通过拟合从线性化的流行病动态模型生成的时间序列来估计增长率 $r_{\\text{fit}}$。最后，需要为三种特定的网络结构计算这两个量之间的绝对差。\n\n### 步骤 1：理论增长率（$r_{\\text{theory}}$）推导\n\n分析始于为每个节点的期望感染人数 $i(t)$ 提供的线性常微分方程（ODE）系统：\n$$ \\frac{d}{dt} i(t) = (\\beta A - \\gamma I) i(t) $$\n其中 $A$ 是邻接矩阵，$\\beta$ 是传播率，$\\gamma$ 是恢复率，$I$ 是单位矩阵。我们定义矩阵 $M = \\beta A - \\gamma I$。于是该系统变为 $\\frac{d}{dt} i(t) = M i(t)$。\n\n这是一个线性、一阶、齐次常系数常微分方程组。其通解可以表示为其基本模式的线性组合。如果 $\\{\\lambda_j\\}$ 和 $\\{v_j\\}$ 是 $M$ 的特征值和对应特征向量的集合，则解由下式给出：\n$$ i(t) = \\sum_j c_j v_j e^{\\lambda_j t} $$\n其中系数 $c_j$ 由初始条件 $i(0)$ 决定。\n\n对于大的 $t$，对应于最大特征值 $\\lambda_{\\text{max}} = \\rho(M)$（$M$ 的谱半径）的项将主导求和，前提是其初始分量 $c_{\\text{max}}$ 非零。\n$$ i(t) \\approx c_{\\text{max}} v_{\\text{max}} e^{\\lambda_{\\text{max}} t} \\quad \\text{for } t \\to \\infty $$\n总感染人数为 $I_{\\text{tot}}(t) = \\mathbf{1}^T i(t)$，其中 $\\mathbf{1}$ 是全1向量。在早期阶段，由主导模式驱动，这变为：\n$$ I_{\\text{tot}}(t) \\approx (c_{\\text{max}} \\mathbf{1}^T v_{\\text{max}}) e^{\\lambda_{\\text{max}} t} $$\n将此与预期的指数增长形式 $I_{\\text{tot}}(t) \\approx I_0 e^{r t}$ 进行比较，我们将早期指数增长率 $r$ 等同于 $M$ 的主特征值：\n$$ r = \\lambda_{\\text{max}}(M) = \\rho(\\beta A - \\gamma I) $$\n$M$ 的特征值可以与 $A$ 的特征值相关联。如果 $\\mu_j$ 是 $A$ 的特征值，那么 $\\beta A - \\gamma I$ 的特征值是 $\\beta \\mu_j - \\gamma$。因此，主特征值为：\n$$ r = \\beta \\mu_{\\text{max}} - \\gamma = \\beta \\rho(A) - \\gamma $$\n其中 $\\rho(A)$ 是邻接矩阵 $A$ 的谱半径。\n\n下一代矩阵由 $K = \\frac{\\beta}{\\gamma} A$ 给出。$K$ 的特征值是 $\\frac{\\beta}{\\gamma} \\mu_j$。其主特征值为 $\\rho(K) = \\frac{\\beta}{\\gamma} \\rho(A)$。我们可以用 $\\rho(K)$ 来表示 $\\rho(A)$：$\\rho(A) = \\frac{\\gamma}{\\beta} \\rho(K)$。\n\n将此代回 $r$ 的表达式，我们得到所需的关系：\n$$ r_{\\text{theory}} = \\beta \\left(\\frac{\\gamma}{\\beta} \\rho(K)\\right) - \\gamma = \\gamma \\rho(K) - \\gamma $$\n$$ r_{\\text{theory}} = \\gamma (\\rho(K) - 1) $$\n这个方程将宏观增长率 $r$ 与微观参数（$\\beta, \\gamma$）和网络拓扑（封装在 $\\rho(A)$ 中，从而也封装在 $\\rho(K)$ 中）联系起来。当且仅当 $\\rho(K)  1$ 时，流行病会增长（$r_{\\text{theory}}  0$），这是众所周知的阈值条件。\n\n### 步骤 2：增长率的数值估计（$r_{\\text{fit}}$）\n\n通过数值模拟动态过程并拟合结果，可以获得 $r$ 的一个独立估计。\n1.  **求解常微分方程**：对于初始条件为 $i(0)$ 的方程 $\\frac{d}{dt} i(t) = M i(t)$，其精确解由矩阵指数给出：\n    $$ i(t) = \\exp(M t) i(0) $$\n    其中 $M = \\beta A - \\gamma I$。初始条件指定为 $i(0) = \\frac{1}{N} \\mathbf{1}$，其中 $N$ 是节点数。\n\n2.  **生成时间序列**：我们在从 $t_{\\min} = 0.5$ 到 $t_{\\max} = 8.0$ 且步长为 $\\Delta t = 0.05$ 的离散时间点 $t_k$ 上计算 $i(t)$。对于每个 $t_k$，我们计算总感染人口 $I_{\\text{tot}}(t_k) = \\sum_j i_j(t_k)$。\n\n3.  **执行线性回归**：模型 $I_{\\text{tot}}(t) \\approx I_0 e^{rt}$ 可以通过取自然对数进行线性化：\n    $$ y(t) = \\ln I_{\\text{tot}}(t) \\approx \\ln(I_0) + r t $$\n    这是一个 $y = c + r t$ 形式的线性方程。我们通过对数据对 $(t_k, y(t_k))$ 执行普通最小二乘法（OLS）线性回归来估计斜率 $r$。得到的斜率就是我们的估计值 $r_{\\text{fit}}$。\n\n### 步骤 3：测试用例计算\n\n对于三个测试用例中的每一个，我们执行以下计算：\n1.  定义邻接矩阵 $A$ 和参数 $\\beta, \\gamma$。\n2.  计算 $r_{\\text{theory}}$：a. 构建下一代矩阵 NGM，$K = (\\beta / \\gamma) A$。b. 求其谱半径，$\\rho(K) = \\max_j |\\lambda_j(K)|$。c. 计算 $r_{\\text{theory}} = \\gamma (\\rho(K) - 1)$。\n3.  计算 $r_{\\text{fit}}$：a. 构建动态矩阵，$M = \\beta A - \\gamma I$。b. 从 $t_{\\min}$ 到 $t_{\\max}$ 生成时间向量 $t$。c. 对于每个时间点，计算 $i(t) = \\exp(Mt)i(0)$，然后计算 $I_{\\text{tot}}(t) = \\sum_j i_j(t)$。d. 形成向量 $y(t) = \\ln I_{\\text{tot}}(t)$。e. 找到 $y(t)$ 与 $t$ 的最佳拟合线的斜率，该斜率即为 $r_{\\text{fit}}$。\n4.  计算绝对差 $|r_{\\text{fit}} - r_{\\text{theory}}|$。\n\n$r_{\\text{theory}}$ 和 $r_{\\text{fit}}$ 之间的差异之所以产生，是因为时间序列拟合是在一个有限区间内进行的，在该区间内，非主导的特征模式可能仍具有不可忽略的影响，导致 $\\ln I_{\\text{tot}}(t)$ 与完美的直线略有偏差。理论增长率 $r_{\\text{theory}}$ 代表了当 $t \\to \\infty$ 时的渐近增长率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Computes the absolute difference between theoretical and fitted epidemic growth rates\n    for three network test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (path graph of length 4)\n        {\n            \"A\": np.array([\n                [0, 1, 0, 0],\n                [1, 0, 1, 0],\n                [0, 1, 0, 1],\n                [0, 0, 1, 0]\n            ]),\n            \"beta\": 0.5,\n            \"gamma\": 0.4\n        },\n        # Case 2 (complete graph on 3 nodes)\n        {\n            \"A\": np.array([\n                [0, 1, 1],\n                [1, 0, 1],\n                [1, 1, 0]\n            ]),\n            \"beta\": 0.3,\n            \"gamma\": 0.6\n        },\n        # Case 3 (star graph on 5 nodes)\n        {\n            \"A\": np.array([\n                [0, 1, 1, 1, 1],\n                [1, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0]\n            ]),\n            \"beta\": 0.2,\n            \"gamma\": 0.5\n        }\n    ]\n\n    results = []\n    \n    # Define time sampling parameters\n    t_min = 0.5\n    t_max = 8.0\n    dt = 0.05\n    # Use np.arange which handles floating point steps robustly\n    t_vals = np.arange(t_min, t_max + dt/2, dt)\n\n    for case in test_cases:\n        A = case[\"A\"]\n        beta = case[\"beta\"]\n        gamma = case[\"gamma\"]\n        N = A.shape[0]\n\n        # 1. Compute theoretical growth rate (r_theory)\n        # Construct the Next-Generation Matrix K\n        K = (beta / gamma) * A\n        \n        # Find the spectral radius of K (leading eigenvalue)\n        # For non-negative matrices (like A and K), the spectral radius is an eigenvalue\n        eigvals_K = np.linalg.eigvals(K)\n        rho_K = np.max(np.abs(eigvals_K))\n        \n        # Calculate r_theory\n        r_theory = gamma * (rho_K - 1)\n\n        # 2. Compute fitted growth rate (r_fit)\n        # Construct the dynamics matrix M\n        M = beta * A - gamma * np.identity(N)\n        \n        # Define initial condition\n        i0 = np.ones(N) / N\n        \n        I_tot_vals = []\n        for t in t_vals:\n            # Evolve the system using the matrix exponential\n            exp_Mt = expm(M * t)\n            i_t = exp_Mt @ i0\n            \n            # Calculate total infected\n            I_tot_t = np.sum(i_t)\n            I_tot_vals.append(I_tot_t)\n        \n        # Take natural log for linear regression\n        y_vals = np.log(np.array(I_tot_vals))\n        \n        # Perform Ordinary Least Squares regression to find the slope\n        # np.polyfit(x, y, 1) returns [slope, intercept]\n        coeffs = np.polyfit(t_vals, y_vals, 1)\n        r_fit = coeffs[0]\n\n        # 3. Compute the absolute difference\n        diff = np.abs(r_fit - r_theory)\n        results.append(diff)\n\n    # Final print statement in the exact required format.\n    # Each number is rounded to exactly 6 decimal places.\n    print(f\"[{','.join([f'{x:.6f}' for x in results])}]\")\n\nsolve()\n```", "id": "3124341"}, {"introduction": "理解了疫情如何传播后，一个自然而然的问题是如何有效地进行干预。在资源有限的现实世界中，明智地分配检测资源至关重要。本练习将引导您探索如何利用网络科学中的中心性概念来设计“智能”的检测策略，并将其与更简单的随机检测策略进行效果对比，从而量化评估不同干预措施的效率。[@problem_id:3124329]", "problem": "考虑一个由 $N$ 个节点组成的简单、无向、无权重的网络，其邻接矩阵为 $A \\in \\{0,1\\}^{N \\times N}$，其中 $A_{ij} = 1$ 表示节点 $i$ 和节点 $j$ 之间存在一条边，且 $A_{ii} = 0$。定义节点 $i$ 的度中心性 (DC) 为 $c_i = \\sum_{j=1}^{N} A_{ij}$。假设每条边独立地携带一次暴露，该暴露以概率 $\\alpha \\in [0,1]$ 导致感染。在各条边之间独立的假设下，节点 $i$ 在快照时间被感染的概率为 $q_i$，该概率取决于 $c_i$ 和 $\\alpha$。假设测试是完美的：如果存在感染，测试总能检测到，并且没有假阳性或假阴性。\n\n可用的测试预算为 $B \\in \\mathbb{N}_0$。考虑以下选择测试节点的策略：\n\n- 策略 $\\mathcal{T}$ (目标性，有放回)：执行 $B$ 次独立抽取（有放回）。每次抽取时，以与 $c_i$ 成正比的概率选择节点 $i$。如果 $\\sum_{j=1}^{N} c_j = 0$，则选择概率被解释为在所有节点上均匀分布。如果一个节点在 $B$ 次抽取中至少出现一次，则认为该节点被“测试”了。\n- 策略 $\\mathcal{U}$ (均匀，有放回)：执行 $B$ 次独立抽取（有放回），每次抽取从 $N$ 个节点中均匀随机地选择一个节点。如果一个节点在 $B$ 次抽取中至少出现一次，则认为该节点被“测试”了。\n- 策略 $\\mathcal{D}$ (确定性前 $B$ 个，无放回)：选择最多 $B$ 个具有最大 $c_i$ 值的不同节点（若出现相同值，则按节点索引递增排序来打破平局），并对每个节点仅测试一次。如果 $B \\ge N$，则测试所有 $N$ 个节点。\n\n您的任务是计算在每种策略下，通过测试检测到的受感染节点的期望数量。计算必须从边暴露的独立性和度中心性的定义开始，并通过重复独立抽取的概率法则和用于检测的集合包含关系进行。在问题陈述中不应假设任何简便公式；请在您的解决方案和程序设计中从第一性原理推导所需的量。\n\n使用以下测试套件。对于每种情况，都指定了 $A$ 以及 $B$ 和 $\\alpha$。节点索引从 $0$ 到 $N-1$。\n\n- 情况 1 (一般连通网络，中等预算)：$N = 6$，\n$$\nA^{(1)} = \\begin{bmatrix}\n0  1  1  0  0  0 \\\\\n1  0  1  1  0  0 \\\\\n1  1  0  1  0  0 \\\\\n0  1  1  0  1  0 \\\\\n0  0  0  1  0  1 \\\\\n0  0  0  0  1  0\n\\end{bmatrix},\\quad B^{(1)} = 3,\\quad \\alpha^{(1)} = 0.2.\n$$\n\n- 情况 2 (中心性相等的正则图)：$N = 5$，\n$$\nA^{(2)} = \\begin{bmatrix}\n0  1  0  0  1 \\\\\n1  0  1  0  0 \\\\\n0  1  0  1  0 \\\\\n0  0  1  0  1 \\\\\n1  0  0  1  0\n\\end{bmatrix},\\quad B^{(2)} = 4,\\quad \\alpha^{(2)} = 0.3.\n$$\n\n- 情况 3 (边界预算)：重用 $A^{(1)}$，其中 $B^{(3)} = 0$ 且 $\\alpha^{(3)} = 0.7$。\n\n- 情况 4 (星形网络，大预算)：$N = 6$，\n$$\nA^{(4)} = \\begin{bmatrix}\n0  1  1  1  1  1 \\\\\n1  0  0  0  0  0 \\\\\n1  0  0  0  0  0 \\\\\n1  0  0  0  0  0 \\\\\n1  0  0  0  0  0 \\\\\n1  0  0  0  0  0\n\\end{bmatrix},\\quad B^{(4)} = 20,\\quad \\alpha^{(4)} = 0.1.\n$$\n\n对于每种情况，计算三个值：在策略 $\\mathcal{T}$、$\\mathcal{U}$ 和 $\\mathcal{D}$ 下检测到的受感染节点的期望数量。您的程序应生成单行输出，其中包含四个情况的结果，格式为逗号分隔的列表的列表，每个内部列表按 $[\\mathcal{T}, \\mathcal{U}, \\mathcal{D}]$ 的顺序排列，每个数值打印到六位小数，例如\n$$\n\\text{[}[r_{1,\\mathcal{T}},r_{1,\\mathcal{U}},r_{1,\\mathcal{D}}],[r_{2,\\mathcal{T}},r_{2,\\mathcal{U}},r_{2,\\mathcal{D}}],[r_{3,\\mathcal{T}},r_{3,\\mathcal{U}},r_{3,\\mathcal{D}}],[r_{4,\\mathcal{T}},r_{4,\\mathcal{U}},r_{4,\\mathcal{D}}]\\text{]}.\n$$\n不涉及物理单位。所有结果均以实数（浮点数）表示。计算必须与上述独立性假设在科学上保持一致。", "solution": "经评估，此问题是有效的，因为它以概率论和网络科学为科学基础，问题适定，并以客观、形式化的语言表述。问题是自包含的，提供了所有必要的数据和定义。因此，我们可以着手解决。\n\n目标是计算三种不同测试策略下检测到的受感染节点的期望数量，记为 $E[X]$。令 $I_i$ 为节点 $i$ 被感染事件的指示随机变量，令 $T_i$ 为节点 $i$ 被测试事件的指示随机变量。检测到的受感染节点数量为 $X = \\sum_{i=0}^{N-1} I_i T_i$。\n\n根据期望的线性性质，检测到的受感染节点的期望数量为：\n$$ E[X] = E\\left[\\sum_{i=0}^{N-1} I_i T_i\\right] = \\sum_{i=0}^{N-1} E[I_i T_i] $$\n指示变量的期望是其所指示事件的概率。因此，$E[I_i T_i] = P(I_i=1 \\text{ and } T_i=1)$。节点的感染状态由网络的属性和感染概率 $\\alpha$ 决定，而测试状态由测试策略和预算 $B$ 决定。这两个过程是独立的。因此，我们可以写出：\n$$ P(I_i=1 \\text{ and } T_i=1) = P(I_i=1) \\cdot P(T_i=1) $$\n我们记 $q_i = P(I_i=1)$ 为节点 $i$ 被感染的概率，记 $p_{\\text{test},i} = P(T_i=1)$ 为节点 $i$ 被测试的概率。那么，检测到的受感染节点的期望数量为：\n$$ E[X] = \\sum_{i=0}^{N-1} q_i \\cdot p_{\\text{test},i} $$\n现在我们必须从第一性原理为每种策略推导 $q_i$ 和 $p_{\\text{test},i}$ 的表达式。\n\n**1. 感染概率 ($q_i$) 的推导**\n问题陈述中提到，每条边独立地携带一次暴露，并以概率 $\\alpha$ 导致感染。如果节点 $i$ 的至少一个邻居传播了感染，则节点 $i$ 会被感染。计算其互补事件的概率更为直接：节点 $i$ *未*被感染。这种情况发生当且仅当其*所有*邻居都*没有*传播感染。\n\n令 $c_i$ 为节点 $i$ 的度中心性，即其邻居的数量。\n$$ c_i = \\sum_{j=0}^{N-1} A_{ij} $$\n对于单个邻居，*不*传播感染的概率是 $(1-\\alpha)$。由于来自所有 $c_i$ 个邻居的暴露是独立事件，因此它们中没有任何一个向节点 $i$ 传播感染的概率是它们各自不传播概率的乘积：\n$$ P(I_i=0) = (1-\\alpha)^{c_i} $$\n节点 $i$ 被感染的概率 $q_i$ 是此事件的补集：\n$$ q_i = P(I_i=1) = 1 - P(I_i=0) = 1 - (1-\\alpha)^{c_i} $$\n\n**2. 各策略下测试概率 ($p_{\\text{test},i}$) 的推导**\n\n**策略 $\\mathcal{T}$ (目标性，有放回)：**\n在此策略中，执行 $B$ 次独立测试。对于每次测试，以与其度中心性 $c_i$ 成正比的概率 $p_i^{(\\mathcal{T})}$ 选择节点 $i$。\n$$ p_i^{(\\mathcal{T})} = \\frac{c_i}{\\sum_{j=0}^{N-1} c_j} $$\n如果总度数和 $\\sum_{j=0}^{N-1} c_j = 0$（一个没有边的网络），则选择概率是均匀的：$p_i^{(\\mathcal{T})} = 1/N$。令 $C_{\\text{tot}} = \\sum_{j=0}^{N-1} c_j$。\n如果一个节点在 $B$ 次抽取中至少被选择一次，则认为该节点被测试了。在单次抽取中节点 $i$ *不*被选择的概率是 $(1 - p_i^{(\\mathcal{T})})$。由于 $B$ 次抽取是独立的，因此节点 $i$ 在 $B$ 次抽取中*从未*被选择的概率是 $(1 - p_i^{(\\mathcal{T})})^B$。\n节点 $i$ 被测试的概率 $p_{\\text{test},i}^{(\\mathcal{T})}$ 是其补集：\n$$ p_{\\text{test},i}^{(\\mathcal{T})} = 1 - \\left(1 - \\frac{c_i}{C_{\\text{tot}}}\\right)^B $$\n（如果 $C_{\\text{tot}}=0$，则按均匀情况处理）。\n\n**策略 $\\mathcal{U}$ (均匀，有放回)：**\n这是目标性策略的一个简化版本，其中在单次抽取中选择任何节点 $i$ 的概率是均匀的：$p_i^{(\\mathcal{U})} = 1/N$。遵循与策略 $\\mathcal{T}$ 相同的逻辑：\n$$ p_{\\text{test},i}^{(\\mathcal{U})} = 1 - \\left(1 - \\frac{1}{N}\\right)^B $$\n请注意，这个概率对于所有节点都是相同的。\n\n**策略 $\\mathcal{D}$ (确定性前 $B$ 个，无放回)：**\n这个策略是确定性的。选择一个固定的节点集合 $S_D$进行测试。节点根据其度中心性 $c_i$ 按降序排列。若出现相同值，则选择索引较小的节点来打破平局。从这个排序中选择前 $B$ 个节点。如果 $B \\ge N$，则测试所有节点。\n对于节点 $i$，其被测试的“概率”为 $1$ 或 $0$：\n$$ p_{\\text{test},i}^{(\\mathcal{D})} = \\begin{cases} 1  \\text{if node } i \\in S_D \\\\ 0  \\text{if node } i \\notin S_D \\end{cases} $$\n集合 $S_D$ 包含排序列表中的前 $\\min(B, N)$ 个节点。\n\n**3. 最终计算**\n对于每种策略 $\\mathcal{P} \\in \\{\\mathcal{T}, \\mathcal{U}, \\mathcal{D}\\}$，通过对每个节点的贡献求和来计算检测到的受感染节点的期望数量：\n$$ E[X]_{\\mathcal{P}} = \\sum_{i=0}^{N-1} q_i \\cdot p_{\\text{test},i}^{(\\mathcal{P})} = \\sum_{i=0}^{N-1} \\left(1 - (1-\\alpha)^{c_i}\\right) \\cdot p_{\\text{test},i}^{(\\mathcal{P})} $$\n对于每个测试用例，都实现了此公式以及 $p_{\\text{test},i}^{(\\mathcal{P})}$ 的具体表达式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the expected number of detected infected nodes for four test cases\n    under three different testing policies.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    A1 = np.array([\n        [0, 1, 1, 0, 0, 0],\n        [1, 0, 1, 1, 0, 0],\n        [1, 1, 0, 1, 0, 0],\n        [0, 1, 1, 0, 1, 0],\n        [0, 0, 0, 1, 0, 1],\n        [0, 0, 0, 0, 1, 0]\n    ])\n\n    A2 = np.array([\n        [0, 1, 0, 0, 1],\n        [1, 0, 1, 0, 0],\n        [0, 1, 0, 1, 0],\n        [0, 0, 1, 0, 1],\n        [1, 0, 0, 1, 0]\n    ])\n\n    A4 = np.array([\n        [0, 1, 1, 1, 1, 1],\n        [1, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0]\n    ])\n\n    test_cases = [\n        (A1, 3, 0.2),  # Case 1\n        (A2, 4, 0.3),  # Case 2\n        (A1, 0, 0.7),  # Case 3\n        (A4, 20, 0.1)  # Case 4\n    ]\n\n    results = []\n    for A, B, alpha in test_cases:\n        case_results = _calculate_expected_detections(A, B, alpha)\n        results.append(case_results)\n    \n    # Format the final output string as specified.\n    outer_list = []\n    for inner_list in results:\n        formatted_inner = [f\"{v:.6f}\" for v in inner_list]\n        outer_list.append(f\"[{','.join(formatted_inner)}]\")\n    final_output = f\"[{','.join(outer_list)}]\"\n\n    print(final_output)\n\ndef _calculate_expected_detections(A, B, alpha):\n    \"\"\"\n    Calculates the expected detections for a single case (A, B, alpha).\n    Returns a list of three float values for policies T, U, and D.\n    \"\"\"\n    N = A.shape[0]\n    \n    # 1. Calculate degree centrality and infection probabilities\n    degrees = np.sum(A, axis=1)\n    q = 1 - (1 - alpha)**degrees\n    \n    # --- Policy T (Targeted, with replacement) ---\n    total_degree = np.sum(degrees)\n    if B == 0:\n        p_test_T = np.zeros(N)\n    elif total_degree == 0:\n        # Uniform selection if no edges exist\n        p_draw_T = np.full(N, 1/N)\n        p_test_T = 1 - (1 - p_draw_T)**B\n    else:\n        p_draw_T = degrees / total_degree\n        p_test_T = 1 - (1 - p_draw_T)**B\n    \n    exp_detected_T = np.sum(q * p_test_T)\n\n    # --- Policy U (Uniform, with replacement) ---\n    if B == 0:\n        p_test_U_scalar = 0.0\n    else:\n        p_test_U_scalar = 1 - (1 - 1/N)**B\n    \n    exp_detected_U = np.sum(q) * p_test_U_scalar\n\n    # --- Policy D (Deterministic top-B, without replacement) ---\n    exp_detected_D = 0.0\n    if B > 0:\n        # Sort nodes by degree (desc) and then index (asc)\n        node_indices = np.arange(N)\n        # We sort by (-degree, index)\n        ranked_nodes = sorted(node_indices, key=lambda i: (-degrees[i], i))\n        \n        # Select top min(B, N) nodes to test\n        nodes_to_test = ranked_nodes[:min(B, N)]\n        \n        # Sum infection probabilities for tested nodes\n        exp_detected_D = np.sum(q[nodes_to_test])\n        \n    return [exp_detected_T, exp_detected_U, exp_detected_D]\n\nsolve()\n```", "id": "3124329"}, {"introduction": "在许多实际情境中，我们无法直接观察到疫情传播的全部细节，而是只能获得部分信息，例如每日新增感染总人数。本练习模拟了流行病学家面临的一项核心挑战：模型不确定性。您将学习如何基于不完整的观测数据，运用隐马尔可夫模型（Hidden Markov Model）的框架来计算不同流行病模型（如SI与SIR）的可能性，从而推断出最能解释现有数据的潜在传播机制。[@problem_id:3124380]", "problem": "给定一个邻接矩阵为 $\\mathbf{A} \\in \\{0,1\\}^{n \\times n}$ 的无向简单网络，其中 $\\mathbf{A}$ 的对角线元素为零且对称。考虑网络上的两种流行病过程：易感-感染 (Susceptible-Infected, SI) 模型和易感-感染-移除 (Susceptible-Infected-Removed, SIR) 模型。时间是离散的，索引为 $t \\in \\{0,1,2,\\ldots,T\\}$。每个节点在时间 $t$ 的状态为 $S$ (易感)、$I$ (感染) 或 $R$ (移除) 之一。系统同步演化，其动态变化如下，假定在给定时间 $t$ 的当前状态下，各节点之间是独立的：\n\n1. 感染事件：对于在时间 $t$ 的任何易感节点 $j$，令 $m_j(t)$ 为 $j$ 在时间 $t$ 的受感染邻居数量。在从 $t$ 到 $t+1$ 的时间间隔内，每个受感染的邻居独立地以每条边 $\\beta \\in [0,1]$ 的概率尝试传播。节点 $j$ 在时间 $t+1$ 之前被感染的概率是\n$$\np_{\\text{inf}}(j,t) \\;=\\; 1 - (1-\\beta)^{m_j(t)}.\n$$\n\n2. 恢复事件：在易感-感染-移除 (SIR) 模型中，每个受感染的节点在同一时间间隔内独立地以概率 $\\gamma \\in [0,1]$ 恢复，并在时间 $t+1$ 之前变为移除状态。在易感-感染 (SI) 模型中，不发生恢复，这通过设置 $\\gamma = 0$ 来建模。移除的节点一旦产生，将永久保持移除状态。\n\n假设更新是同步的，并且传播尝试源于在时间 $t$ 受感染的节点，无论它们是否在时间 $t+1$ 之前恢复。在时间 $t+1$ 新感染的节点在下一个步骤之前不能感染其他节点。\n\n观测模型和先验：您只能观测到每个时间点的总感染节点数，记为 $I(t)$，其中 $t \\in \\{0,1,\\ldots,T\\}$，但不知道受感染节点的具体身份。在时间 $t=0$ 时，恰好有一个节点被感染，所有其他节点都是易感的。初始受感染节点的身份是未知的，并假定在 $n$ 个节点上均匀分布，与网络结构无关。因此，关于初始节点级状态的先验为每个恰好有一个感染节点且没有移除节点的配置分配 $1/n$ 的概率。\n\n任务：设计并实现一个程序，给定 $\\mathbf{A}$、$\\beta$、$\\gamma$（用于 SIR 模型）以及观测序列 $I(0), I(1), \\ldots, I(T)$，计算在易感-感染 (SI) 模型下的似然 $L_{\\text{SI}} = \\Pr(I(0{:}T)\\mid \\text{SI}, \\mathbf{A}, \\beta)$ 和在易感-感染-移除 (SIR) 模型下的似然 $L_{\\text{SIR}} = \\Pr(I(0{:}T)\\mid \\text{SIR}, \\mathbf{A}, \\beta, \\gamma)$。使用这些来产生似然比\n$$\n\\Lambda \\;=\\; \\frac{L_{\\text{SI}}}{L_{\\text{SIR}}}.\n$$\n通过将节点级流行病视为所有节点级配置上的有限状态马尔可夫链，并使用前向动态规划方法对与观测过程一致的所有隐藏路径求和，来精确计算这些似然。不要通过模拟进行近似，也不要假设超出模型所隐含的条件独立性之外的任何分解。观测值 $I(t)$ 是时间 $t$ 隐藏状态的确定性函数，即状态为 $I$ 的节点计数。\n\n测试套件：您的程序必须为以下 $4$ 个测试案例中的每一个计算 $\\Lambda$。在每个案例中，网络 $\\mathbf{A}$ 都是无向且简单的。易感-感染 (SI) 模型使用给定的 $\\beta$ 并设置 $\\gamma = 0$。易感-感染-移除 (SIR) 模型使用给定的 $\\beta$ 和 $\\gamma$。每个案例都指定了观测序列 $I(0{:}T)$。\n\n案例 $\\#1$:\n- $n = 4$ 且\n$$\n\\mathbf{A} \\;=\\;\n\\begin{pmatrix}\n0  1  0  0\\\\\n1  0  1  0\\\\\n0  1  0  1\\\\\n0  0  1  0\n\\end{pmatrix}.\n$$\n- $\\beta = 0.4$, $\\gamma = 0.2$。\n- $I(0{:}3) = [\\,1,\\,2,\\,3,\\,4\\,]$。\n\n案例 $\\#2$:\n- $n = 4$ 且\n$$\n\\mathbf{A} \\;=\\;\n\\begin{pmatrix}\n0  1  0  0\\\\\n1  0  1  0\\\\\n0  1  0  1\\\\\n0  0  1  0\n\\end{pmatrix}.\n$$\n- $\\beta = 0.2$, $\\gamma = 0.5$。\n- $I(0{:}3) = [\\,1,\\,1,\\,1,\\,1\\,]$。\n\n案例 $\\#3$:\n- $n = 5$ 且\n$$\n\\mathbf{A} \\;=\\;\n\\begin{pmatrix}\n0  1  1  1  1\\\\\n1  0  0  0  0\\\\\n1  0  0  0  0\\\\\n1  0  0  0  0\\\\\n1  0  0  0  0\n\\end{pmatrix}.\n$$\n- $\\beta = 0.35$, $\\gamma = 0.3$。\n- $I(0{:}3) = [\\,1,\\,2,\\,1,\\,1\\,]$。\n\n案例 $\\#4$:\n- $n = 3$ 且\n$$\n\\mathbf{A} \\;=\\;\n\\begin{pmatrix}\n0  0  0\\\\\n0  0  0\\\\\n0  0  0\n\\end{pmatrix}.\n$$\n- $\\beta = 0.7$, $\\gamma = 0.4$。\n- $I(0{:}2) = [\\,1,\\,1,\\,1\\,]$。\n\n最终输出规范：您的程序应生成单行输出，其中包含按顺序排列的案例 $\\#1$ 到 $\\#4$ 的似然比，形式为方括号内由逗号分隔的列表。每个有限结果必须打印为小数点后精确保留 $6$ 位的小数。如果 $L_{\\text{SIR}} = 0$ 且 $L_{\\text{SI}}  0$，则打印 $+\\infty$ 为 $\\,\\text{inf}\\,$。如果 $L_{\\text{SI}} = 0$ 且 $L_{\\text{SIR}} = 0$，则打印 $\\,\\text{nan}\\,$。例如，一个有效的输出格式是\n$$\n[\\,x_1, x_2, x_3, x_4\\,],\n$$\n其中每个 $x_k$ 是一个具有 $6$ 位小数的浮点数，或按规定为 $\\,\\text{inf}\\,$ 或 $\\,\\text{nan}\\,$。此任务不涉及物理单位或角度。", "solution": "该问题要求计算两种流行病模型（易感-感染 (SI) 模型和易感-感染-移除 (SIR) 模型）的似然比 $\\Lambda = L_{\\text{SI}} / L_{\\text{SIR}}$，给定一个观测到的总感染人数序列 $I(0), \\ldots, I(T)$。任务的核心是计算在每个模型下这个观测序列的似然 $\\Pr(I(0{:}T))$。由于具体受感染节点的身份是未知的，这是一个隐马尔可夫模型 (HMM) 中的推断问题。解决方案采用前向动态规划算法来精确计算所需的似然。\n\n### 隐马尔可夫模型表述\n\n该系统可以描述为一个具有以下组件的隐马尔可夫模型：\n\n1.  **隐藏状态**：时间 $t$ 的一个隐藏状态，记为 $C_t$，是网络中所有 $n$ 个节点的完整状态配置。每个节点可以处于三种状态之一：易感 ($S$)、感染 ($I$) 或移除 ($R$)。我们可以将一个配置表示为一个向量 $C = (c_1, c_2, \\ldots, c_n)$，其中 $c_i \\in \\{S, I, R\\}$。隐藏状态的总数为 $3^n$。为了计算方便，我们将每个状态 $\\{S, I, R\\}$ 映射到一个整数 $\\{0, 1, 2\\}$，并通过一个三进制编码将每个配置 $C$ 表示为在 $[0, 3^n-1]$ 范围内的唯一整数索引：$\\text{idx}(C) = \\sum_{i=1}^n c_i 3^{i-1}$。\n\n2.  **观测**：时间 $t$ 的观测是 $O_t = I(t)$，即总感染节点数。观测是隐藏状态 $C_t$ 的一个确定性函数。令 $N_I(C)$ 为配置 $C$ 中感染节点的数量。\n\n3.  **初始状态概率**：给定在 $t=0$ 时初始状态 $C_0$ 的先验分布。恰好有一个节点被感染，所有其他节点都是易感的。初始节点的身份是从 $n$ 个节点中随机均匀选择的。因此，初始配置 $C_0$ 的概率为：\n    $$\n    \\Pr(C_0) = \\begin{cases} 1/n  \\text{若 } N_I(C_0)=1 \\text{ 且 } N_R(C_0)=0 \\\\ 0  \\text{其他情况} \\end{cases}\n    $$\n    其中 $N_R(C_0)$ 是 $C_0$ 中移除节点的数量。\n\n4.  **转移概率**：转移概率 $a_{C,C'} = \\Pr(C_{t+1}=C' \\mid C_t=C)$ 量化了动态过程。由于给定配置 $C_t$ 时，节点状态的变化是条件独立的，此概率可在所有节点上分解：\n    $$\n    a_{C,C'} = \\prod_{j=1}^n \\Pr(c'_{j} \\mid C_t=C)\n    $$\n    其中 $c'_j$ 是节点 $j$ 在 $C'$ 中的状态。单个节点的转移概率 $\\Pr(c'_j \\mid C)$ 由模型动态定义：\n    -   如果节点 $j$ 是易感的 ($c_j=S$)：它以概率 $p_{\\text{inf}}(j,C) = 1 - (1-\\beta)^{m_j(C)}$ 变为感染状态 ($c'_j=I$)，其中 $m_j(C)$ 是配置 $C$ 中 $j$ 的受感染邻居数量。它以概率 $1-p_{\\text{inf}}(j,C)$ 保持易感状态 ($c'_j=S$)。\n    -   如果节点 $j$ 是感染的 ($c_j=I$)：它以概率 $\\gamma$ 变为移除状态 ($c'_j=R$)。它以概率 $1-\\gamma$ 保持感染状态 ($c'_j=I$)。对于 SI 模型，$\\gamma=0$。\n    -   如果节点 $j$ 是移除的 ($c_j=R$)：它以概率 $1$ 保持移除状态 ($c'_j=R$)。\n\n5.  **发射概率**：发射概率 $\\Pr(O_t \\mid C_t=C)$ 是确定性的。如果状态 $C$ 中感染节点的数量与观测值 $I(t)$ 匹配，则为 $1$，否则为 $0$。\n    $$\n    \\Pr(O_t=I(t) \\mid C_t=C) = \\mathbb{I}(N_I(C) = I(t))\n    $$\n    其中 $\\mathbb{I}(\\cdot)$ 是指示函数。\n\n### 前向算法\n\n为了计算似然 $L = \\Pr(I(0{:}T))$，我们使用前向算法。令 $\\alpha_t(C) = \\Pr(I(0{:}t), C_t=C)$ 为观测序列截至时间 $t$ 且在时间 $t$ 处于状态 $C$ 的联合概率。\n\n**1. 初始化 ($t=0$):**\n每个状态 $C$ 的初始前向概率是该状态的概率与第一个观测一致的概率。\n$$\n\\alpha_0(C) = \\Pr(I(0), C_0=C) = \\Pr(O_0=I(0) \\mid C_0=C) \\Pr(C_0) = \\mathbb{I}(N_I(C)=I(0)) \\Pr(C_0)\n$$\n鉴于问题的先验和 $I(0)=1$，对于任何具有一个感染节点和 $n-1$ 个易感节点的 $n$ 种配置，这简化为 $\\alpha_0(C) = 1/n$，对于所有其他配置，则为 $0$。\n\n**2. 递归 ($t=0, \\ldots, T-1$):**\n下一个时间步 $t+1$ 的前向概率是根据时间 $t$ 的概率计算得出的：\n$$\n\\alpha_{t+1}(C') = \\left( \\sum_{C} \\alpha_t(C) a_{C,C'} \\right) \\Pr(O_{t+1}=I(t+1) \\mid C_{t+1}=C')\n$$\n发射概率项起到了一个过滤器的作用：如果 $N_I(C') \\neq I(t+1)$，则 $\\alpha_{t+1}(C') = 0$。否则：\n$$\n\\alpha_{t+1}(C') = \\sum_{C} \\alpha_t(C) a_{C,C'}\n$$\n\n**3. 终止:**\n观测序列的总似然是在最终时间 $T$ 时所有可能状态的前向概率之和：\n$$\nL = \\Pr(I(0{:}T)) = \\sum_C \\alpha_T(C)\n$$\n\n### 实现策略\n\n该算法实现如下：\n1.  **状态空间生成**：预先计算所有 $3^n$ 个状态及其属性（感染节点数、每个节点的感染邻居数）。\n2.  **转移矩阵**：预先计算状态转移概率矩阵 $\\mathbf{P}$，其元素为 $P_{ij} = a_{C_i, C_j}$。这是一个 $3^n \\times 3^n$ 的矩阵。\n3.  **前向传递**：在 $t=0$ 时初始化前向概率向量 $\\boldsymbol{\\alpha}_t$。然后，对于直到 $T-1$ 的每个时间步，通过对时间 $t$ 所有状态的贡献求和，并根据观测值 $I(t+1)$ 进行过滤，来计算下一个向量 $\\boldsymbol{\\alpha}_{t+1}$。这实际上是一个矩阵-向量乘法 $\\boldsymbol{\\alpha}_{t+1} \\gets \\boldsymbol{\\alpha}_{t} \\mathbf{P}$，然后进行过滤。\n4.  **似然计算**：最终的似然是最终向量 $\\boldsymbol{\\alpha}_T$ 中所有元素的和。\n5.  **比率计算**：该过程运行两次：一次用于 SI 模型（$\\gamma=0$）以获得 $L_{\\text{SI}}$，另一次用于 SIR 模型（使用给定的 $\\gamma  0$）以获得 $L_{\\text{SIR}}$。然后计算比率 $\\Lambda=L_{\\text{SI}}/L_{\\text{SIR}}$，并处理 $L_{\\text{SIR}}=0$ 的情况。\n\n这种方法提供了问题所要求的精确解，并且对于问题中指定的小网络规模是可行的。", "answer": "```python\nimport numpy as np\n\ndef _compute_likelihood(A, beta, gamma, I_seq):\n    \"\"\"\n    Computes the likelihood of an observed sequence of infected counts\n    using a forward algorithm on the exact state-space Markov chain.\n\n    Args:\n        A (np.ndarray): Adjacency matrix of the network.\n        beta (float): Per-edge transmission probability.\n        gamma (float): Recovery probability.\n        I_seq (list): Sequence of observed infected counts.\n\n    Returns:\n        float: The likelihood of the observation sequence.\n    \"\"\"\n    n = A.shape[0]\n    T = len(I_seq) - 1\n    num_states = 3**n\n\n    # 1. Pre-computation of state properties\n    # Each state is an integer from 0 to 3^n - 1.\n    # We map state_idx - {config, num_I, m_counts}\n    # config is a tuple of node states (0:S, 1:I, 2:R)\n    states_info = []\n    for i in range(num_states):\n        \n        # Convert index to base-3 configuration\n        config = []\n        temp_i = i\n        for _ in range(n):\n            state = temp_i % 3\n            config.append(state)\n            temp_i //= 3\n        config = tuple(config)\n        num_I = config.count(1)\n        \n        # For each susceptible node, count its infected neighbors\n        m_counts = []\n        for j in range(n):\n            m_j = 0\n            if config[j] == 0:\n                for k in range(n):\n                    if A[j, k] == 1 and config[k] == 1:\n                        m_j += 1\n            m_counts.append(m_j)\n        \n        states_info.append({\n            'num_I': num_I,\n            'm_counts': tuple(m_counts)\n        })\n\n    # 2. Pre-computation of the transition probability matrix P[C, C']\n    P = np.zeros((num_states, num_states), dtype=np.float64)\n    for idx_C in range(num_states):\n        C_m_counts = states_info[idx_C]['m_counts']\n        # Convert indices to configurations to calculate transitions\n        C_config_temp, C_idx_temp = [], idx_C\n        for _ in range(n):\n            C_config_temp.append(C_idx_temp % 3); C_idx_temp //= 3\n\n        for idx_C_prime in range(num_states):\n            C_prime_config_temp, C_prime_idx_temp = [], idx_C_prime\n            for _ in range(n):\n                C_prime_config_temp.append(C_prime_idx_temp % 3); C_prime_idx_temp //= 3\n            \n            prob = 1.0\n            possible = True\n            for j in range(n):\n                c_j, c_j_prime = C_config_temp[j], C_prime_config_temp[j]\n                \n                if c_j == 0:  # Susceptible\n                    m_j = C_m_counts[j]\n                    p_inf = 1.0 - (1.0 - beta)**m_j\n                    if c_j_prime == 1: prob *= p_inf\n                    elif c_j_prime == 0: prob *= (1.0 - p_inf)\n                    else: possible = False; break\n                elif c_j == 1:  # Infected\n                    if c_j_prime == 1: prob *= (1.0 - gamma)\n                    elif c_j_prime == 2: prob *= gamma\n                    else: possible = False; break\n                elif c_j == 2:  # Removed\n                    if c_j_prime != 2: possible = False; break\n            \n            if possible:\n                P[idx_C, idx_C_prime] = prob\n    \n    # 3. Forward Algorithm\n    # Initialization (t=0)\n    alpha = np.zeros(num_states, dtype=np.float64)\n    if I_seq[0] != 1: return 0.0\n        \n    for i in range(num_states):\n        info = states_info[i]\n        is_initial_config = (info['num_I'] == 1 and sum(1 for state in get_config_from_idx(i,n) if state == 0) == n - 1)\n        if is_initial_config:\n            alpha[i] = 1.0 / n\n\n    # Recursion (t = 0 to T-1)\n    for t in range(T):\n        alpha_next = np.zeros(num_states, dtype=np.float64)\n        I_t_plus_1 = I_seq[t + 1]\n        \n        # Effective matrix-vector product filtered by observation\n        alpha_next = alpha @ P\n        \n        # Filter based on observation I(t+1)\n        for i in range(num_states):\n            if states_info[i]['num_I'] != I_t_plus_1:\n                alpha_next[i] = 0.0\n        \n        alpha = alpha_next\n        if np.sum(alpha) == 0.0: return 0.0\n\n    # 4. Termination\n    return np.sum(alpha)\n    \ndef get_config_from_idx(idx, n):\n    \"\"\" Helper to convert index to config, used in alpha init \"\"\"\n    config = []\n    temp_i = idx\n    for _ in range(n):\n        config.append(temp_i % 3)\n        temp_i //= 3\n    return tuple(config)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results in the specified format.\n    \"\"\"\n    test_cases = [\n        {\n            \"A\": np.array([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], dtype=int),\n            \"beta\": 0.4, \"gamma\": 0.2, \"I_seq\": [1, 2, 3, 4]\n        },\n        {\n            \"A\": np.array([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], dtype=int),\n            \"beta\": 0.2, \"gamma\": 0.5, \"I_seq\": [1, 1, 1, 1]\n        },\n        {\n            \"A\": np.array([[0, 1, 1, 1, 1], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0]], dtype=int),\n            \"beta\": 0.35, \"gamma\": 0.3, \"I_seq\": [1, 2, 1, 1]\n        },\n        {\n            \"A\": np.array([[0, 0, 0], [0, 0, 0], [0, 0, 0]], dtype=int),\n            \"beta\": 0.7, \"gamma\": 0.4, \"I_seq\": [1, 1, 1]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        A, beta, gamma, I_seq = case[\"A\"], case[\"beta\"], case[\"gamma\"], case[\"I_seq\"]\n        \n        L_si = _compute_likelihood(A, beta, 0.0, I_seq)\n        L_sir = _compute_likelihood(A, beta, gamma, I_seq)\n\n        if L_sir == 0.0:\n            if L_si > 0.0:\n                ratio_str = 'inf'\n            else:  # Both L_si and L_sir are 0\n                ratio_str = 'nan'\n        else:\n            ratio = L_si / L_sir\n            ratio_str = f\"{ratio:.6f}\"\n        \n        results.append(ratio_str)\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3124380"}]}