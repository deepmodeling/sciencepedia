{"hands_on_practices": [{"introduction": "周期性边界条件 (Periodic Boundary Conditions, PBC) 是模拟体相系统的基石，但它们也给计算粒子间距离带来了复杂性。本练习将带您深入分子动力学模拟的一个核心算法：在最普适的三斜晶胞中应用的最小镜像约定 (Minimum Image Convention, MIC)，其中晶胞由一个矩阵 $\\mathbf{h}$ 定义。掌握这项技能对于正确实现粒子间的成对相互作用至关重要。[@problem_id:3177576]", "problem": "考虑一个由晶胞矩阵 $\\,\\mathbf{h}\\,$ 表示的周期性分子动力学模拟晶胞，该矩阵将分数坐标 $\\,\\mathbf{s}\\in[0,1)^3\\,$ 映射到笛卡尔坐标 $\\,\\mathbf{r}=\\mathbf{h}\\,\\mathbf{s}\\,$。在周期性边界条件 (PBC) 下，对于整数三元组 $\\,\\mathbf{n}\\in\\mathbb{Z}^3\\,$，粒子会在晶格平移 $\\,\\mathbf{h}\\,\\mathbf{n}\\,$ 的位置上被复制。最小镜像约定 (MIC) 规定，在计算对偶距离时，必须选择能产生最短欧几里得分离的晶格平移。在三斜晶胞中，这可以通过以下步骤完成：使用逆晶胞矩阵 $\\,\\mathbf{h}^{-1}\\,$ 将笛卡尔位移转换到分数坐标空间，将分数位移中心化到范围 $\\,[-\\tfrac{1}{2},\\tfrac{1}{2})\\,$ 内，再通过 $\\,\\mathbf{h}\\,$ 转换回笛卡尔空间。您的任务是实现一个程序，该程序针对多个测试用例，使用此 MIC 构建邻居列表，并与指定的期望列表进行验证。\n\n从基本原理开始：\n- 牛顿第二定律将力与粒子运动联系起来，但此处我们专注于 PBC 下的几何计算。\n- 周期性定义 $\\,\\mathbf{r}\\sim\\mathbf{r}+\\mathbf{h}\\,\\mathbf{n}\\,$ 和欧几里得范数 $\\,\\|\\cdot\\|\\,$ 是基本事实。\n- 将分数坐标包裹到 $\\,[-\\tfrac{1}{2},\\tfrac{1}{2})\\,$ 是确保选择最小镜像的核心操作。\n\n定义与要求：\n- 粒子 $\\,i\\,$ 的邻居列表包含所有满足 MIC 距离 $\\,d_{ij}\\,$ 不超过截断半径 $\\,r_c\\,$（即 $\\,d_{ij}\\le r_c\\,$）的粒子索引 $\\,j\\neq i\\,$。\n- 距离和位置均使用无量纲的约化单位；不需要物理单位。\n- 不使用角度；不需要角度单位。\n- 对于每个测试用例，计算每个粒子的邻居列表并与期望列表进行比较；测试结果是一个布尔值，表示所有粒子的列表是否都完全匹配。", "solution": "该问题是有效的，因为它提出了一个明确定义的计算任务，该任务基于分子动力学模拟的基本原理，特别是在周期性边界条件（PBC）下对一般三斜晶胞应用最小镜像约定（MIC）。所提供的算法是标准的，测试用例在科学上是合理的且可验证的。测试用例3中粒子索引的微小记法不一致被解释为印刷错误，不影响严谨的求解。\n\n解决方案将基于以下原理和算法步骤构建。\n\n**基本原理**\n\n1.  **周期性空间**: 模拟晶胞由一个 $3 \\times 3$ 的矩阵 $\\mathbf{h}$ 定义，其列向量为晶格矢量 $[\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3]$。空间是周期性的，意味着位于笛卡尔坐标 $\\mathbf{r}$ 的粒子，对于任意整数向量 $\\mathbf{n} \\in \\mathbb{Z}^3$，在所有 $\\mathbf{r} + \\mathbf{h}\\mathbf{n}$ 位置都有其周期性镜像。\n\n2.  **分数坐标**: 周期性晶胞的几何形状最自然地是用分数坐标 $\\mathbf{s} \\in [0, 1)^3$ 来描述。一个位置 $\\mathbf{s}$ 通过线性变换 $\\mathbf{r} = \\mathbf{h}\\mathbf{s}$ 映射到其等效的笛卡尔坐标 $\\mathbf{r}$。逆变换为 $\\mathbf{s} = \\mathbf{h}^{-1}\\mathbf{r}$。\n\n3.  **最小镜像约定 (MIC)**: 两个粒子 $i$ 和 $j$ 之间的距离，是其中一个粒子的所有周期性镜像相对于另一个粒子位置的最小欧几里得距离。该距离由 $d_{ij} = \\min_{\\mathbf{n} \\in \\mathbb{Z}^3} \\| (\\mathbf{r}_j + \\mathbf{h}\\mathbf{n}) - \\mathbf{r}_i \\|$ 给出。\n\n**算法实现**\n\nMIC 距离可以通过将位移矢量变换到分数坐标并将其包裹到中心周期性镜像（即晶格的维格纳-赛兹原胞）中来高效计算。对于一般的三斜晶胞，这被简化为将每个分数分量包裹到范围 $[-\\frac{1}{2}, \\frac{1}{2})$ 内。\n\n对于每对粒子 $(i, j)$，算法按以下步骤进行：\n\n1.  **笛卡尔位移**: 计算笛卡尔坐标中的“朴素”位移矢量，$\\Delta\\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$。\n\n2.  **分数位移**: 使用逆晶胞矩阵将此位移转换为分数坐标：$\\Delta\\mathbf{s} = \\mathbf{h}^{-1}\\Delta\\mathbf{r}$。\n\n3.  **包裹**: 中心化分数位移矢量。$\\Delta\\mathbf{s}$ 的每个分量 $\\Delta s_k$ 都通过操作 $\\Delta s'_k = \\Delta s_k - \\lfloor \\Delta s_k + \\frac{1}{2} \\rfloor$ 映射到区间 $[-\\frac{1}{2}, \\frac{1}{2})$。此包裹操作能正确选择最近的周期性镜像。\n\n4.  **最小镜像位移**: 将包裹后的分数位移 $\\Delta\\mathbf{s}'$ 变换回笛卡尔坐标，以获得最小镜像位移矢量：$\\Delta\\mathbf{r}_{\\text{MIC}} = \\mathbf{h}\\Delta\\mathbf{s}'$。\n\n5.  **距离计算**: MIC 距离是欧几里得范数 $d_{ij} = \\|\\Delta\\mathbf{r}_{\\text{MIC}}\\|$。为提高效率，我们计算距离的平方 $d_{ij}^2 = \\Delta\\mathbf{r}_{\\text{MIC}} \\cdot \\Delta\\mathbf{r}_{\\text{MIC}}$，并将其与截断距离的平方 $r_c^2$ 进行比较。\n\n6.  **邻居列表构建**: 如果 $d_{ij}^2 \\le r_c^2$，则将粒子 $j$ 添加到粒子 $i$ 的邻居列表，并将粒子 $i$ 添加到粒子 $j$ 的邻居列表。\n\n此算法将系统地应用于每个测试用例。首先确保粒子位置是笛卡尔坐标。对于给出分数坐标的测试用例，使用 $\\mathbf{r}_i = \\mathbf{h}\\mathbf{s}_i$ 将其转换。然后，将计算出的所有粒子的邻居列表与期望列表进行比较。一个测试用例的结果为 `True` 当且仅当所有计算出的列表与期望列表完全匹配（在确保了规范排序，如排序后）。最终输出汇总了所有测试用例的布尔结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the neighbor list construction problem for all specified test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: orthorhombic, boundary wrap along one axis\n        {\n            \"h\": np.diag([10.0, 10.0, 10.0]),\n            \"positions\": np.array([\n                [1.0, 1.0, 1.0], \n                [9.0, 1.0, 1.0], \n                [5.0, 5.0, 5.0]\n            ]),\n            \"pos_type\": 'cartesian',\n            \"rc\": 2.1,\n            \"expected\": {0: [1], 1: [0], 2: []}\n        },\n        # Test Case 2: triclinic shear, neighbors via off-diagonal coupling\n        {\n            \"h\": np.array([\n                [10.0, 3.0, 0.0], \n                [0.0, 10.0, 0.0], \n                [0.0, 0.0, 10.0]\n            ]),\n            \"positions\": np.array([\n                [0.1, 0.1, 0.1], \n                [0.9, 0.1, 0.1], \n                [0.1, 0.9, 0.1]\n            ]),\n            \"pos_type\": 'fractional',\n            \"rc\": 2.1,\n            \"expected\": {0: [1, 2], 1: [0], 2: [0]}\n        },\n        # Test Case 3: exact half-box separation, inclusion at equality\n        {\n            \"h\": np.diag([10.0, 10.0, 10.0]),\n            \"positions\": np.array([\n                [0.49, 0.5, 0.5], \n                [0.99, 0.5, 0.5]\n            ]), # Indices s_3, s_4 are typos for 0, 1\n            \"pos_type\": 'fractional',\n            \"rc\": 5.0,\n            \"expected\": {0: [1], 1: [0]}\n        },\n        # Test Case 4: stronger shear reduces neighbor connectivity\n        {\n            \"h\": np.array([\n                [10.0, 5.0, 0.0], \n                [0.0, 10.0, 0.0], \n                [0.0, 0.0, 10.0]\n            ]),\n            \"positions\": np.array([\n                [0.1, 0.1, 0.1], \n                [0.9, 0.1, 0.1], \n                [0.1, 0.9, 0.1]\n            ]),\n            \"pos_type\": 'fractional',\n            \"rc\": 2.1,\n            \"expected\": {0: [1], 1: [0], 2: []}\n        },\n        # Test Case 5: triple-axis wrap in an orthorhombic cell\n        {\n            \"h\": np.diag([10.0, 10.0, 10.0]),\n            \"positions\": np.array([\n                [9.7, 9.7, 9.7], \n                [0.3, 0.3, 0.3]\n            ]),\n            \"pos_type\": 'cartesian',\n            \"rc\": 1.2,\n            \"expected\": {0: [1], 1: [0]}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        computed_lists = compute_neighbor_lists(\n            case[\"h\"], case[\"positions\"], case[\"rc\"], case[\"pos_type\"]\n        )\n        \n        # Verify the computed lists against the expected lists.\n        # Ensure expected lists are sorted for consistent comparison.\n        expected_lists = {p: sorted(n) for p, n in case[\"expected\"].items()}\n        \n        results.append(computed_lists == expected_lists)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_neighbor_lists(h, positions, rc, pos_type='cartesian'):\n    \"\"\"\n    Computes neighbor lists using the Minimum Image Convention.\n\n    Args:\n        h (np.ndarray): 3x3 cell matrix.\n        positions (np.ndarray): Nx3 array of particle positions.\n        rc (float): Cutoff distance.\n        pos_type (str): 'cartesian' or 'fractional'.\n\n    Returns:\n        dict: A dictionary where keys are particle indices and values are\n              sorted lists of their neighbors.\n    \"\"\"\n    if pos_type == 'fractional':\n        # Convert fractional coordinates to Cartesian\n        cart_pos = positions @ h.T\n    else:\n        cart_pos = positions\n\n    num_particles = cart_pos.shape[0]\n    h_inv = np.linalg.inv(h)\n    rc_sq = rc**2\n\n    neighbor_lists = {i: [] for i in range(num_particles)}\n\n    # Iterate over all unique pairs of particles (i, j) where i  j\n    for i in range(num_particles):\n        for j in range(i + 1, num_particles):\n            # 1. Compute Cartesian displacement\n            delta_r = cart_pos[j] - cart_pos[i]\n\n            # 2. Transform to fractional displacement\n            delta_s = delta_r @ h_inv.T\n            \n            # 3. Center fractional displacement into [-0.5, 0.5)\n            # This is equivalent to delta_s - round(delta_s) for the specified interval.\n            # A more robust implementation handles the 0.5 boundary case correctly.\n            delta_s_wrapped = delta_s - np.floor(delta_s + 0.5)\n\n            # 4. Transform back to Cartesian minimum image vector\n            delta_r_mic = delta_s_wrapped @ h.T\n\n            # 5. Compute squared distance and check against cutoff\n            dist_sq = np.dot(delta_r_mic, delta_r_mic)\n\n            if dist_sq = rc_sq:\n                neighbor_lists[i].append(j)\n                neighbor_lists[j].append(i)\n    \n    # Sort lists for canonical representation\n    for i in range(num_particles):\n        neighbor_lists[i].sort()\n        \n    return neighbor_lists\n\nsolve()\n```", "id": "3177576"}, {"introduction": "在掌握了如何寻找近邻粒子之后，下一个关键问题便是如何高效地完成这项任务。虽然计算所有粒子对之间的相互作用最为精确，但其计算成本过高；使用近邻列表是解决方法，但这需要在计算精度和速度之间做出权衡。本练习将指导您建立一个简化模型，以确定更新近邻列表的最佳频率 $n_{\\mathrm{steps}}$，这是任何高效分子动力学模拟中的一个关键参数。[@problem_id:3177610]", "problem": "您的任务是为分子动力学模拟中的邻居列表重构周期设计一个简单的、有原则的优化器。使用约化Lennard-Jones单位，其中玻尔兹曼常数为 $k_{B}=1$，粒子质量为 $m$，Lennard-Jones长度和能量标度分别为 $\\sigma=1$ 和 $\\epsilon=1$，时间单位为 $\\sqrt{m \\sigma^{2} / \\epsilon}$。考虑一个三维系统，其均匀数密度为 $\\rho$，球形截断半径为 $r_{c}$，邻居列表缓冲层（skin）为 $r_{\\mathrm{skin}}$。您的目标是为每个测试用例计算一个最优的整数重构周期 $n_{\\mathrm{steps}}$，该周期在将平均每粒子力误差的估计值保持在指定容差以下的同时，最小化均摊重构成本。\n\n请仅基于以下基本定律和经过充分检验的公式进行推导：\n- 牛顿运动定律以及速度的定义 $v = dx/dt$。\n- 根据能量均分定理，在约化单位下，温度为 $T$、质量为 $m$ 的粒子的均方根（RMS）速率为 $v_{\\mathrm{rms}} = \\sqrt{3 k_{B} T / m} = \\sqrt{3 T / m}$。\n- 对于两个不相关的粒子，其均方根相对速率可近似为 $v_{\\mathrm{rel,rms}} = \\sqrt{2}\\, v_{\\mathrm{rms}}$。\n- 对于Lennard-Jones (LJ) 对势 $U(r) = 4 \\epsilon \\left[ (\\sigma/r)^{12} - (\\sigma/r)^{6} \\right]$，在距离为 $r$ 时的对力大小为 $|F_{\\mathrm{LJ}}(r)| = \\left| \\frac{dU}{dr} \\right| = \\left| 24 \\epsilon \\left( 2 \\frac{\\sigma^{12}}{r^{13}} - \\frac{\\sigma^{6}}{r^{7}} \\right) \\right|$。在 $\\epsilon=\\sigma=1$ 的约化单位下，该式简化为 $|F_{\\mathrm{LJ}}(r)| = \\left| 24 \\left( \\frac{2}{r^{13}} - \\frac{1}{r^{7}} \\right) \\right|$。\n\n使用以下建模假设，以科学上合理的方式将物理学与计算联系起来：\n- 在大小为 $\\Delta t$ 的 $n$ 个步长内，均方根相对位移可近似为 $\\Delta r_{\\mathrm{rel}} \\approx v_{\\mathrm{rel,rms}} \\, n \\, \\Delta t$。\n- 如果 $\\Delta r_{\\mathrm{rel}} \\le r_{\\mathrm{skin}}$，带有缓冲层（skin）$r_{\\mathrm{skin}}$ 的邻居列表可减少遗漏的相互作用；如果 $\\Delta r_{\\mathrm{rel}}  r_{\\mathrm{skin}}$，定义一个超出接近距离 $e = \\max(0, \\Delta r_{\\mathrm{rel}} - r_{\\mathrm{skin}})$。\n- 对于均匀流体，在重构周期内可能进入截断球内的粒子对数，与截断处的壳层厚度 $e$ 成正比。每个粒子遗漏邻居的期望数可近似为 $N_{\\mathrm{miss}} \\approx \\rho \\, 4 \\pi r_{c}^{2} \\, e$。\n- 平均每粒子力误差可近似为 $E_{f}(n) \\approx N_{\\mathrm{miss}} \\, |F_{\\mathrm{LJ}}(r_{c})| = \\rho \\, 4 \\pi r_{c}^{2} \\, e \\, |F_{\\mathrm{LJ}}(r_{c})|$。\n- 对于给定的容差 $\\varepsilon_{f}$，施加约束 $E_{f}(n) \\le \\varepsilon_{f}$。这给出了一个允许的超出量 $e_{\\max} = \\varepsilon_{f} / \\left( \\rho \\, 4 \\pi r_{c}^{2} \\, |F_{\\mathrm{LJ}}(r_{c})| \\right)$，并因此得到边界条件 $\\Delta r_{\\mathrm{rel}} \\le r_{\\mathrm{skin}} + e_{\\max}$。\n- 对于计算成本，将每步的均摊重构成本建模为 $C_{\\mathrm{step}}(n) = C_{\\mathrm{pair}}(\\rho, r_{c}, r_{\\mathrm{skin}}) + C_{\\mathrm{rebuild}}/n$，其中 $C_{\\mathrm{rebuild}}$ 是一个正常数重构成本，而 $C_{\\mathrm{pair}}(\\cdot)$ 与 $n$ 无关。由于对于固定的参数，$C_{\\mathrm{rebuild}}/n$ 是关于 $n$ 单调递减的，因此在力误差约束下，成本最优的选择是满足误差边界的最大的 $n$。\n- 强制施加一个实际的工程上限 $n_{\\mathrm{cap}}$，使得 $n_{\\mathrm{steps}} \\le n_{\\mathrm{cap}}$，并且 $n_{\\mathrm{steps}} \\ge 1$。\n\n因此，您的程序必须为每个测试用例计算以下内容：\n- 计算 $v_{\\mathrm{rms}} = \\sqrt{3 T / m}$，然后计算 $v_{\\mathrm{rel,rms}} = \\sqrt{2} \\, v_{\\mathrm{rms}}$。\n- 在约化单位下计算 $|F_{\\mathrm{LJ}}(r_{c})| = \\left| 24 \\left( 2/r_{c}^{13} - 1/r_{c}^{7} \\right) \\right|$。\n- 计算 $e_{\\max} = \\varepsilon_{f} / \\left( \\rho \\, 4 \\pi r_{c}^{2} \\, |F_{\\mathrm{LJ}}(r_{c})| \\right)$，并约定如果 $|F_{\\mathrm{LJ}}(r_{c})| = 0$，则 $e_{\\max}$ 实际上是无界的。\n- 计算误差约束下的边界 $n_{\\max} = \\left\\lfloor \\dfrac{r_{\\mathrm{skin}} + e_{\\max}}{v_{\\mathrm{rel,rms}} \\, \\Delta t} \\right\\rfloor$，并约定如果 $v_{\\mathrm{rel,rms}} \\, \\Delta t = 0$，则将 $n_{\\max}$ 视为无界的。\n- 输出 $n_{\\mathrm{steps}} = \\max\\left( 1, \\min\\left( n_{\\max}, n_{\\mathrm{cap}} \\right) \\right)$。\n\n本问题中的所有量都在约化Lennard-Jones单位中定义。最终输出是无量纲的，因为它是一个整数步数。\n\n测试套件。对于每个元组 $(\\rho, T, m, \\Delta t, r_{c}, r_{\\mathrm{skin}}, \\varepsilon_{f}, n_{\\mathrm{cap}})$，计算 $n_{\\mathrm{steps}}$：\n- 情况 1：$(\\rho, T, m, \\Delta t, r_{c}, r_{\\mathrm{skin}}, \\varepsilon_{f}, n_{\\mathrm{cap}}) = (\\, 0.8, \\, 1.0, \\, 1.0, \\, 0.005, \\, 2.5, \\, 0.3, \\, 0.05, \\, 100 \\,)$。\n- 情况 2：$(\\, 0.8, \\, 1.0, \\, 1.0, \\, 0.005, \\, 2.5, \\, 0.05, \\, 0.05, \\, 100 \\,)$。\n- 情况 3：$(\\, 0.8, \\, 0.2, \\, 1.0, \\, 0.005, \\, 2.5, \\, 0.3, \\, 0.05, \\, 100 \\,)$。\n- 情况 4：$(\\, 0.8, \\, 1.0, \\, 1.0, \\, 0.005, \\, 2.5, \\, 0.3, \\, 0.0, \\, 100 \\,)$。\n- 情况 5：$(\\, 0.8, \\, 0.05, \\, 1.0, \\, 0.005, \\, 2.5, \\, 0.3, \\, 0.5, \\, 100 \\,)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[\\text{result}_{1},\\text{result}_{2},\\text{result}_{3}]$）。对于本问题，输出 $[n_{1},n_{2},n_{3},n_{4},n_{5}]$，其中每个 $n_{i}$ 均按上述方法计算。", "solution": "所提出的问题是计算科学领域的一个有效练习，特别是在分子动力学（MD）模拟的优化方面。它概述了一个有原则的、尽管简化的模型，用以确定重构邻居列表的最佳频率。该模型在重构的计算成本与使用过时列表所产生的数值误差之间取得了平衡。所提供的所有物理假设和数学公式都是标准的，或在入门级MD的背景下是合理的近似。该问题是自洽的、适定的，并且具有科学依据。我们现在将基于所提供的框架，对解决方案进行系统性推导。\n\n目标是为一个通过Lennard-Jones势相互作用的三维粒子系统，找到邻居列表的最佳整数重构周期，记为 $n_{\\mathrm{steps}}$。该系统的特征是数密度 $\\rho$、温度 $T$ 和粒子质量 $m$。模拟使用的时间步长为 $\\Delta t$。邻居列表使用截断半径 $r_c$ 和厚度为 $r_{\\mathrm{skin}}$ 的缓冲区域或“skin”构建。该优化必须满足对平均每粒子力误差的约束，该误差不得超过容差 $\\varepsilon_f$，同时还要遵守一个最大的实际重构周期 $n_{\\mathrm{cap}}$。所有量都以约化Lennard-Jones单位给出，其中能量标度 $\\epsilon=1$，长度标度 $\\sigma=1$，玻尔兹曼常数 $k_B=1$。\n\n推导过程分三个主要阶段：首先，我们对导致力误差的物理过程进行建模；其次，我们将误差约束形式化；第三，我们求解满足此约束同时最小化计算成本的最佳步数。\n\n**1. 粒子位移和力误差的建模**\n\n使用固定邻居列表时，误差的主要来源是粒子的运动。一个最初在邻居列表半径 $r_c + r_{\\mathrm{skin}}$ 之外的粒子，可能在两次重构之间的 $n_{\\mathrm{steps}}$ 步内移动到相互作用截断半径 $r_c$ 之内。此类事件会导致“遗漏”相互作用，从而产生力计算误差。\n\n为了量化这一点，我们首先估计粒子的典型速率。根据三维空间中的能量均分定理，每个粒子的平均动能为 $\\frac{3}{2} k_B T$。在指定了粒子质量 $m$ 且 $k_B=1$ 的约化单位中，均方根（RMS）速率 $v_{\\mathrm{rms}}$ 为：\n$$v_{\\mathrm{rms}} = \\sqrt{\\frac{3 k_B T}{m}} = \\sqrt{\\frac{3T}{m}}$$\n两个粒子接近或分离的速率由它们的相对速度给出。对于从同一分布中抽取的两个速度不相关的粒子，其均方根相对速率可近似为：\n$$v_{\\mathrm{rel,rms}} = \\sqrt{2} \\, v_{\\mathrm{rms}} = \\sqrt{2} \\sqrt{\\frac{3T}{m}} = \\sqrt{\\frac{6T}{m}}$$\n在持续时间为 $\\Delta t$ 的 $n$ 个步长内，我们使用线性近似来表示一对粒子间的均方根相对位移：\n$$\\Delta r_{\\mathrm{rel}}(n) \\approx v_{\\mathrm{rel,rms}} \\, n \\, \\Delta t$$\n如果该位移超过了缓冲层（skin）厚度，即 $\\Delta r_{\\mathrm{rel}}  r_{\\mathrm{skin}}$，则有可能发生遗漏相互作用。我们定义“超出接近距离” $e$ 为相对位移侵入受缓冲层保护区域的量：\n$$e = \\max(0, \\Delta r_{\\mathrm{rel}} - r_{\\mathrm{skin}})$$\n\n**2. 力误差约束的形式化**\n\n每个粒子遗漏的平均邻居相互作用数 $N_{\\mathrm{miss}}$，可以通过考虑预计进入中心粒子相互作用球内的粒子数来估计。这些粒子源自一个半径为 $r_c$、厚度为 $e$ 的球壳。对于数密度均匀为 $\\rho$ 的系统，该球壳的体积约为 $4 \\pi r_c^2 e$。因此，遗漏邻居的期望数为：\n$$N_{\\mathrm{miss}} \\approx \\rho \\, 4 \\pi r_c^2 \\, e$$\n为了估计由此产生的力误差，我们假设每个此类粒子对的遗漏相互作用力约等于截断距离处的力大小，即 $|F_{\\mathrm{LJ}}(r_c)|$。那么，总的平均每粒子力误差 $E_f(n)$ 就是遗漏邻居数与该特征力大小的乘积：\n$$E_f(n) \\approx N_{\\mathrm{miss}} \\, |F_{\\mathrm{LJ}}(r_c)| = (\\rho \\, 4 \\pi r_c^2 \\, e) \\, |F_{\\mathrm{LJ}}(r_c)|$$\n在约化单位（$\\epsilon=1, \\sigma=1$）下，Lennard-Jones力的大小由以下公式给出：\n$$|F_{\\mathrm{LJ}}(r)| = \\left| 24 \\left( \\frac{2}{r^{13}} - \\frac{1}{r^{7}} \\right) \\right|$$\n问题施加了约束，即该估计误差不得超过指定的容差 $\\varepsilon_f$：\n$$E_f(n) \\le \\varepsilon_f$$\n代入 $E_f(n)$ 的表达式并求解超出距离 $e$，得到最大允许超出接近量 $e_{\\max}$：\n$$(\\rho \\, 4 \\pi r_c^2 \\, e_{\\max}) \\, |F_{\\mathrm{LJ}}(r_c)| = \\varepsilon_f \\implies e_{\\max} = \\frac{\\varepsilon_f}{\\rho \\, 4 \\pi r_c^2 \\, |F_{\\mathrm{LJ}}(r_c)|}$$\n如果 $|F_{\\mathrm{LJ}}(r_c)| = 0$，则分母为零。在这种物理上特定的情况下（即截断点位于力的最小值处），无论有多少遗漏的邻居，估计的力误差都为零，因此 $e_{\\max}$ 可被视为无穷大。\n\n**3. 推导最佳重构周期**\n\n对 $e \\le e_{\\max}$ 的约束意味着对总相对位移的约束。由 $e = \\Delta r_{\\mathrm{rel}} - r_{\\mathrm{skin}}$，我们必须有 $\\Delta r_{\\mathrm{rel}} - r_{\\mathrm{skin}} \\le e_{\\max}$，整理后可得：\n$$\\Delta r_{\\mathrm{rel}} \\le r_{\\mathrm{skin}} + e_{\\max}$$\n代入我们的位移模型 $\\Delta r_{\\mathrm{rel}} \\approx v_{\\mathrm{rel,rms}} \\, n \\, \\Delta t$，得到对步数 $n$ 的约束：\n$$v_{\\mathrm{rel,rms}} \\, n \\, \\Delta t \\le r_{\\mathrm{skin}} + e_{\\max}$$\n求解 $n$ 可得出误差容差所允许的最大步数：\n$$n \\le \\frac{r_{\\mathrm{skin}} + e_{\\max}}{v_{\\mathrm{rel,rms}} \\, \\Delta t}$$\n由于 $n$ 必须是整数，满足此不等式的最大整数值可以通过对右侧表达式取底得到。我们将此值记为 $n_{\\max}$：\n$$n_{\\max} = \\left\\lfloor \\frac{r_{\\mathrm{skin}} + e_{\\max}}{v_{\\mathrm{rel,rms}} \\, \\Delta t} \\right\\rfloor$$\n如果分母 $v_{\\mathrm{rel,rms}} \\, \\Delta t = 0$（例如，在零温度下），粒子是静止的，因此不需要重构来校正运动。在这种情况下，$n_{\\max}$ 可被视为无穷大。\n\n计算成本模型以每步的均摊成本给出：$C_{\\mathrm{step}}(n) = C_{\\mathrm{pair}} + C_{\\mathrm{rebuild}}/n$。为了最小化此成本，我们必须最大化 $n$。因此，在误差约束下，$n$ 的最优选择恰好是 $n_{\\max}$。\n\n最后，我们必须纳入实际约束，即重构周期必须至少为1步，且不超过工程上限 $n_{\\mathrm{cap}}$。结合这些，最佳重构周期的最终表达式为：\n$$n_{\\mathrm{steps}} = \\max\\left(1, \\min\\left(n_{\\max}, n_{\\mathrm{cap}}\\right)\\right)$$\n该公式代表了根据指定模型确定最佳邻居列表重构周期的完整算法。对于每个测试用例，我们将按指定顺序计算各个量，以得出最终的整数 $n_{\\mathrm{steps}}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the optimal neighbor list rebuild period for a series of test cases\n    based on a principled model for molecular dynamics simulations.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (rho, T, m, dt, r_c, r_skin, eps_f, n_cap)\n    test_cases = [\n        (0.8, 1.0, 1.0, 0.005, 2.5, 0.3, 0.05, 100),\n        (0.8, 1.0, 1.0, 0.005, 2.5, 0.05, 0.05, 100),\n        (0.8, 0.2, 1.0, 0.005, 2.5, 0.3, 0.05, 100),\n        (0.8, 1.0, 1.0, 0.005, 2.5, 0.3, 0.0, 100),\n        (0.8, 0.05, 1.0, 0.005, 2.5, 0.3, 0.5, 100),\n    ]\n\n    results = []\n    for case in test_cases:\n        rho, T, m, dt, r_c, r_skin, eps_f, n_cap = case\n\n        # Step 1: Compute v_rms and v_rel_rms\n        # v_rms = sqrt(3 * k_B * T / m). In reduced units, k_B = 1.\n        if T >= 0.0 and m > 0.0:\n            v_rms = np.sqrt(3.0 * T / m)\n        else:\n            v_rms = 0.0\n        \n        # v_rel_rms = sqrt(2) * v_rms\n        v_rel_rms = np.sqrt(2.0) * v_rms\n\n        # Step 2: Compute the LJ force magnitude at the cutoff\n        # |F_LJ(r)| = |24 * (2/r^13 - 1/r^7)| in reduced units\n        if r_c > 0:\n            term13 = 2.0 / (r_c ** 13)\n            term7 = 1.0 / (r_c ** 7)\n            F_lj_rc_mag = np.abs(24.0 * (term13 - term7))\n        else:\n            F_lj_rc_mag = np.inf\n\n        # Step 3: Compute the maximum permissible excess distance, e_max\n        # e_max = eps_f / (rho * 4 * pi * r_c^2 * |F_LJ(r_c)|)\n        denominator_emax = rho * 4.0 * np.pi * (r_c ** 2) * F_lj_rc_mag\n        if denominator_emax > 0:\n            e_max = eps_f / denominator_emax\n        else:\n            # If denominator is zero (due to F_lj=0 or rho=0 or r_c=0), \n            # e_max is effectively unbounded.\n            e_max = np.inf\n\n        # Step 4: Compute the maximum number of steps, n_max\n        # n_max = floor((r_skin + e_max) / (v_rel_rms * dt))\n        denominator_nmax = v_rel_rms * dt\n        if denominator_nmax > 0:\n            n_max_float = (r_skin + e_max) / denominator_nmax\n            # Handle the case where n_max_float could be inf\n            if np.isinf(n_max_float):\n                n_max = np.inf\n            else:\n                 n_max = np.floor(n_max_float)\n        else:\n            # If particles are not moving relative to each other,\n            # n_max is effectively unbounded.\n            n_max = np.inf\n\n        # Step 5: Apply practical constraints to find n_steps\n        # n_steps = max(1, min(n_max, n_cap))\n        # min(n_max, n_cap) will correctly handle n_max = inf\n        n_steps = int(max(1, min(n_max, n_cap)))\n        \n        results.append(n_steps)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3177610"}, {"introduction": "一次技术上设置无误的模拟，并不总能产出科学上有效的结果。最后的这项练习将呈现一个常见而关键的情景：一个在温度 $T=298\\ \\mathrm{K}$ 和压强 $P=1\\ \\mathrm{atm}$ 下进行的模拟，尽管使用了正确的力场，却产生了不符合物理规律的结果。通过诊断导致蛋白质意外解链的可能原因，您将学会如何将底层的模拟参数（如积分时间步长 $\\Delta t$ 和静电模型）与分子系统宏观的稳定性及物理真实性联系起来。[@problem_id:2417128]", "problem": "您正在分析一个小可溶性蛋白的全原子分子动力学 (MD) 轨迹。该模拟在等温等压 (NPT) 系综下，温度为 $298\\ \\mathrm{K}$，压力为 $1\\ \\mathrm{atm}$，并使用了显式水模型。该蛋白质在 $5\\ \\mathrm{ns}$ 内自发地、不可逆地去折叠，这与实验中观察到的在该条件下的稳定性不符。假设生物分子力场参数是正确的。下列哪些模拟设置是导致这种非物理性去折叠的最可能的主要原因？请选择所有适用项。\n\nA. 使用了 $\\Delta t = 2\\ \\mathrm{fs}$ 的积分时间步长，但没有约束任何涉及氢原子的键。\n\nB. 所有原子都与一个随机朗之万恒温器耦合，温度为 $298\\ \\mathrm{K}$，摩擦系数为 $\\gamma = 1\\ \\mathrm{ps^{-1}}$。\n\nC. 长程静电作用通过粒子网格埃瓦尔德 (PME) 方法处理，实空间截断半径为 $1.0\\ \\mathrm{nm}$，并使用了足够高的网格分辨率。\n\nD. 在周期性边界条件下，静电作用在 $0.8\\ \\mathrm{nm}$ 的实空间截断半径处被截断，使用了移位函数且没有倒易空间项（即未使用 PME）。", "solution": "首先将对问题陈述进行严格验证。\n\n### 步骤 1：提取已知条件\n- 系统：在显式水中的小可溶性蛋白的全原子分子动力学 (MD) 模拟。\n- 系综：等温等压 (NPT)。\n- 热力学条件：温度 $T = 298\\ \\mathrm{K}$，压力 $P = 1\\ \\mathrm{atm}$。\n- 观察：蛋白质在 $5\\ \\mathrm{ns}$ 的模拟时间内自发地、不可逆地去折叠。\n- 背景：此模拟行为与实验数据不一致，实验表明该蛋白质在这些条件下是稳定的。\n- 假设：生物分子力场参数是正确的。\n- 问题：从给定的模拟设置列表中，找出导致这种非物理性去折叠的最可能的主要原因。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题描述了计算生物物理学中遇到的一个现实场景。模拟结果与实验事实之间的差异促使人们对模拟方法进行严格评估。\n\n- **科学依据：** 该问题牢固地植根于统计力学和分子动力学模拟的原理。所提到的所有概念——NPT系综、力场、积分时间步长、恒温器和静电处理方法（PME、截断）——都是该领域的标准核心内容。观察到的假象，即非物理性去折叠，是模拟参数不正确的常见后果。\n- **问题明确性：** 问题定义清晰。在力场准确的假设下，误差来源必定在于用于实现物理模型的数值算法和参数。问题要求从一组给定选项中找出最可能的错误，这是一个明确定义的任务。\n- **客观性：** 陈述是客观和定量的，没有主观或模糊的语言。\n\n问题陈述是自洽的，并提供了所有必要信息，以便基于分子模拟的既定原理进行逻辑分析。\n\n### 步骤 3：结论与行动\n问题陈述是**有效的**。将通过分析每个提议的模拟设置所带来的物理和数值后果来推导出解决方案。\n\n蛋白质（假设其是稳定的，并由正确的力场描述）的快速、非物理性去折叠表明模拟方案中存在严重错误。这类错误通常分为两类：\n1.  运动方程积分的数值不稳定性，导致能量守恒的灾难性失败。\n2.  力计算中存在严重不准确的近似，从根本上歪曲了决定蛋白质稳定性的物理原理。\n\n我们现在将根据这些原则评估每个选项。\n\n**A. 使用了 $\\Delta t = 2\\ \\mathrm{fs}$ 的积分时间步长，但没有约束任何涉及氢原子的键。**\n\n牛顿运动方程的数值积分（例如通过Verlet算法）只有在积分时间步长 $\\Delta t$ 远小于系统中最快运动的周期时才是稳定的。生物分子中最快的周期性运动是涉及最轻原子——氢原子——的键振动（例如 C-H、N-H、O-H 键）。这些振动的周期约为 $\\tau \\approx 10\\ \\mathrm{fs}$。稳定的积分要求 $\\Delta t \\ll \\tau$。一个常见的经验法则是 $\\Delta t \\le \\tau/10$。\n在这种情况下，$\\Delta t = 2\\ \\mathrm{fs}$ 的时间步长大约是 $\\tau/5$。这个值太大了，无法准确解析氢键的振动频率。积分器将无法对这些高频振荡进行采样，导致共振和系统能量的快速、无限制的增加。这种数值假象，通常被称为“爆炸”(blowing up)，会使系统不受控制地升温并破坏蛋白质结构。使用 $\\Delta t = 2\\ \\mathrm{fs}$ 时间步长的标准做法是，必须使用 SHAKE 或 LINCS 等算法约束所有涉及氢原子的键的长度，从而从系统中移除这些快速的自由度。因此，在没有此类约束的情况下实施 $2\\ \\mathrm{fs}$ 的时间步长是一个关键的、根本性的错误。\n\n**结论：正确。** 这是导致观察到的灾难性去折叠的一个极有可能的原因。\n\n**B. 所有原子都与一个随机朗之万恒温器耦合，温度为 $298\\ \\mathrm{K}$，摩擦系数为 $\\gamma = 1\\ \\mathrm{ps^{-1}}$。**\n\n朗之万恒温器通过在牛顿运动方程中加入摩擦阻力和随机力来维持温度。这是一种在 MD 模拟中进行温度控制的稳健且被广泛接受的方法，尤其适用于模拟溶剂效应。摩擦系数 $\\gamma$ 决定了与热浴耦合的强度。$\\gamma = 1\\ \\mathrm{ps^{-1}}$ 的值是生物分子模拟中一个标准的、适中的选择。它能在不过度干扰系统动力学的情况下提供有效的温度控制。此设置不会引入大量能量或导致结构不稳定。如果说有什么影响的话，一个远大于此值的 $\\gamma$ 会使系统过阻尼，减慢动力学过程；而一个远小于此值的 $\\gamma$ 可能导致温度控制不佳，但这两种极端情况都不太可能导致所述的快速去折叠。指定的参数是完全标准的。\n\n**结论：错误。** 这代表了一个标准的、正确的模拟设置，不会导致所述的假象。\n\n**C. 长程静电作用通过粒子网格埃瓦尔德 (PME) 方法处理，实空间截断半径为 $1.0\\ \\mathrm{nm}$，并使用了足够高的网格分辨率。**\n\n粒子网格埃瓦尔德 (PME) 方法是精确计算周期性系统中长程静电相互作用的行业标准。它避免了简单截断方法带来的严重假象。$1.0\\ \\mathrm{nm}$ ($10\\ \\mathrm{\\AA}$) 的实空间截断半径，结合适当选择的傅里叶空间网格（“足够高的网格分辨率”），是一种稳健且高度精确的方案。众所周知，正确处理长程静电作用对于维持蛋白质等生物分子的稳定性至关重要。因此，正确使用 PME 应该能稳定蛋白质结构，而不是导致其去折叠。这个选项描述了一种高质量的、先进的模拟实践。\n\n**结论：错误。** 此设置能提高物理准确性和稳定性，因此与可能导致去折叠的原因正好相反。\n\n**D. 在周期性边界条件下，静电作用在 $0.8\\ \\mathrm{nm}$ 的实空间截断半径处被截断，使用了移位函数且没有倒易空间项（即未使用 PME）。**\n\n该选项描述了一种简单的基于截断的静电相互作用方案。库仑势是长程的，按 $1/r$ 衰减。简单地在 $0.8\\ \\mathrm{nm}$ ($8\\ \\mathrm{\\AA}$) 这样的短距离处截断这种相互作用是一种严重的物理近似。虽然使用移位函数可以确保力在截断点处变为零，从而避免了无穷大的能量导数并改善了能量守恒，但这并不能弥补其根本的物理不准确性。这种突兀的截断忽略了所有超过 $0.8\\ \\mathrm{nm}$ 的静电相互作用，而这些相互作用的集体效应对于大分子的结构完整性至关重要。它会引入显著的假象，例如在截断球面上的人为电荷基团极化、不正确的屏蔽效应，并可能导致形成非自然的盐桥和破坏正确的三级结构。对于像蛋白质在水中这样的极性、带电系统，这种方法是众所周知的严重不足，并很容易导致快速变性。\n\n**结论：正确。** 这代表了一个重大的物理近似错误，是导致非物理性蛋白质去折叠的一个非常可能的原因。", "answer": "$$\\boxed{AD}$$", "id": "2417128"}]}