{"hands_on_practices": [{"introduction": "我们的第一个实践将深入探讨天体物理模拟的核心，引入了碰撞过程。你不仅需要实现基本的引力定律，还要模拟非弹性合并，这是理解行星形成和星系演化的关键过程。这项练习 [@problem_id:3163488] 将挑战你应用动量和质量守恒定律，同时跟踪机械能的不守恒性，从而让你对宇宙结构形成的能量学有更深刻的理解。", "problem": "要求您编写一个完整、可运行的程序，该程序模拟一个二维牛顿 $N$ 体系统，该系统具有针对成对距离的非弹性合并规则。该问题的科学基础是牛顿万有引力定律和牛顿第二运动定律。您的实现必须从这些基本原理出发，推导力并更新系统状态，并且必须量化碰撞如何改变质量谱和机械能。\n\n系统必须使用无量纲单位进行建模。使用引力常数 $G=1$，用于力和势能计算的数值软化参数 $\\epsilon=10^{-3}$，以及一个辛时间步进方案。使用二维位置空间，并将所有物体视为点质量。\n\n从第一性原理实现以下内容：\n\n- **连续时间动力学**：加速度由符合牛顿定律和牛顿第二定律的成对引力相互作用决定，位置和速度的更新必须通过时间可逆的辛方法执行。\n- **碰撞与合并规则**：当物体 $i$ 和 $j$ 之间的瞬时距离 $r_{ij}$ 小于给定的碰撞半径 $r_{\\text{coll}}$ 时，它们会发生非弹性合并。该过程必须遵守质量和线动量守恒。\n\n您的任务是针对代码中定义的一组 $r_{\\text{coll}}$ 测试用例运行模拟，并为每个用例生成指定的输出元组，量化最终的系统状态。", "solution": "用户希望解决一个 N 体模拟问题。\n\n我的方法如下：\n1.  **问题验证**：我首先分析问题陈述，以确保其科学上合理、问题定义良好且包含所有必要信息。该问题描述了一个标准的 N 体模拟，包含牛顿引力和非弹性碰撞合并规则。物理原理（牛顿定律、质量和动量守恒）、数值方法（辛积分器、引力软化）以及初始条件都已清晰正确地指定。要求的输出是明确定义的度量指标，用以量化系统的演化。该问题是有效的，并且可以按所述方式解决。\n\n2.  **核心物理与数学**：\n    *   **牛顿万有引力定律**：物体 `j` 对物体 `i` 施加的力由 $\\mathbf{F}_{ij} = -G \\frac{m_i m_j}{|\\mathbf{r}_{ij}|^3} \\mathbf{r}_{ij}$ 给出，其中 $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$ 是位移矢量。为防止两个物体距离过近时出现数值奇点，引入了一个软化参数 $\\epsilon$。力的大小变为 $|\\mathbf{F}_{ij}| = G \\frac{m_i m_j}{r_{ij}^2 + \\epsilon^2}$。因此，力矢量为 $\\mathbf{F}_{ij} = -G \\frac{m_i m_j}{(r_{ij}^2 + \\epsilon^2)^{3/2}} \\mathbf{r}_{ij}$。\n    *   **牛顿第二定律**：物体 `i` 的加速度是作用在其上的合力除以其质量：$\\mathbf{a}_i = \\frac{1}{m_i} \\sum_{j \\neq i} \\mathbf{F}_{ij}$。\n    *   **机械能**：总机械能 $E$ 是总动能 $K$ 和总势能 $U$ 的和。\n        *   动能：$K = \\sum_i K_i = \\sum_i \\frac{1}{2} m_i |\\mathbf{v}_i|^2$。\n        *   势能：使用软化后，一对 $(i, j)$ 的势能为 $U_{ij} = -G \\frac{m_i m_j}{\\sqrt{r_{ij}^2 + \\epsilon^2}}$。总势能是所有唯一对的总和：$U = \\sum_{i", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\ndef solve():\n    \"\"\"\n    Main function to run the N-body simulation for all test cases and print the results.\n    \"\"\"\n    # Global constants for the simulation\n    G = 1.0\n    EPSILON = 1e-3\n    DT = 0.001\n    N_STEPS = 3000\n\n    # Initial conditions (fixed for all test cases)\n    initial_masses = np.array([1.0, 1.5, 0.8, 0.6, 1.2, 1.0])\n    initial_positions = np.array([\n        [1.0, 0.0],\n        [0.5, 0.8660254037844386],\n        [-0.5, 0.8660254037844386],\n        [-1.0, 0.0],\n        [-0.5, -0.8660254037844386],\n        [0.5, -0.8660254037844386]\n    ])\n    initial_velocities = -0.1 * initial_positions\n\n    def get_accelerations(masses, positions):\n        \"\"\"Calculates gravitational acceleration for all bodies.\"\"\"\n        n_bodies = len(masses)\n        if n_bodies == 1:\n            return np.zeros((n_bodies, 2))\n\n        pos_diff = positions[:, np.newaxis, :] - positions[np.newaxis, :, :]\n        dist_sq = np.sum(pos_diff**2, axis=-1)\n        \n        # Softened inverse cube law\n        inv_r3 = (dist_sq + EPSILON**2)**(-1.5)\n        np.fill_diagonal(inv_r3, 0.0)\n\n        # a_i = sum_j G * m_j * (r_j - r_i) / |r_ij|^3 (softened)\n        # Note: pos_diff = r_i - r_j, so we use -pos_diff for (r_j - r_i)\n        accel_factor = G * masses[np.newaxis, :] * inv_r3\n        accelerations = np.sum(accel_factor[:, :, np.newaxis] * (-pos_diff), axis=1)\n        \n        return accelerations\n    \n    def calculate_energy(masses, positions, velocities):\n        \"\"\"Calculates kinetic, potential, and total mechanical energy.\"\"\"\n        n_bodies = len(masses)\n        \n        # Kinetic Energy\n        vel_sq = np.sum(velocities**2, axis=1)\n        kinetic_energy = 0.5 * np.sum(masses * vel_sq)\n\n        # Potential Energy\n        potential_energy = 0.0\n        if n_bodies > 1:\n            # Create indices for upper triangle of pairwise interactions\n            i_indices, j_indices = np.triu_indices(n_bodies, k=1)\n            \n            pos_diff = positions[i_indices] - positions[j_indices]\n            dist = np.sqrt(np.sum(pos_diff**2, axis=1) + EPSILON**2)\n            \n            mass_prods = masses[i_indices] * masses[j_indices]\n            \n            potential_energy = -G * np.sum(mass_prods / dist)\n\n        total_energy = kinetic_energy + potential_energy\n        return kinetic_energy, potential_energy, total_energy\n\n    def handle_collisions(masses, positions, velocities, r_coll):\n        \"\"\"Detects and merges colliding bodies.\"\"\"\n        n_bodies = len(masses)\n        if n_bodies == 1:\n            return masses, positions, velocities, 0\n\n        # Build adjacency matrix for collisions\n        dist_matrix = squareform(pdist(positions))\n        adj_matrix = dist_matrix  r_coll\n        np.fill_diagonal(adj_matrix, False)\n        \n        # Find connected components (collision clusters) using BFS\n        visited = [False] * n_bodies\n        clusters = []\n        for i in range(n_bodies):\n            if not visited[i]:\n                cluster = []\n                queue = [i]\n                visited[i] = True\n                while queue:\n                    u = queue.pop(0)\n                    cluster.append(u)\n                    for v in range(n_bodies):\n                        if adj_matrix[u, v] and not visited[v]:\n                            visited[v] = True\n                            queue.append(v)\n                clusters.append(cluster)\n\n        if len(clusters) == n_bodies:  # No merges\n            return masses, positions, velocities, 0\n\n        new_masses, new_positions, new_velocities = [], [], []\n        num_merges = 0\n\n        for cluster in clusters:\n            if len(cluster) == 1:\n                idx = cluster[0]\n                new_masses.append(masses[idx])\n                new_positions.append(positions[idx])\n                new_velocities.append(velocities[idx])\n            else:\n                cluster_indices = np.array(cluster)\n                cluster_masses = masses[cluster_indices]\n                \n                total_mass = np.sum(cluster_masses)\n                \n                # Center of mass position\n                com_pos = np.sum(cluster_masses[:, np.newaxis] * positions[cluster_indices], axis=0) / total_mass\n                \n                # Center of mass velocity (momentum conservation)\n                com_vel = np.sum(cluster_masses[:, np.newaxis] * velocities[cluster_indices], axis=0) / total_mass\n                \n                new_masses.append(total_mass)\n                new_positions.append(com_pos)\n                new_velocities.append(com_vel)\n                \n                num_merges += len(cluster) - 1\n\n        return np.array(new_masses), np.array(new_positions), np.array(new_velocities), num_merges\n\n    def run_simulation(r_coll):\n        \"\"\"Runs a single simulation for a given collision radius.\"\"\"\n        # Initialize state from fixed initial conditions\n        m = initial_masses.copy()\n        r = initial_positions.copy()\n        v = initial_velocities.copy()\n\n        _, _, e_initial = calculate_energy(m, r, v)\n        total_merges = 0\n\n        # Main integration loop (KDK Leapfrog)\n        for _ in range(N_STEPS):\n            a = get_accelerations(m, r)\n            v_half = v + a * DT / 2.0\n            r_new = r + v_half * DT\n            \n            # For merging, we need full-step velocities to conserve momentum at the time of collision\n            a_new = get_accelerations(m, r_new)\n            v_new = v_half + a_new * DT / 2.0\n            \n            r, v = r_new, v_new\n            \n            # Check for collisions and merge bodies\n            if r_coll > 0.0:\n                  m, r, v, merges_in_step = handle_collisions(m, r, v, r_coll)\n                  total_merges += merges_in_step\n\n        # Final calculations\n        n_final = len(m)\n        m_final = np.sum(m)\n        k_final, u_final, e_final = calculate_energy(m, r, v)\n        \n        delta_e_frac = (e_final - e_initial) / np.abs(e_initial) if e_initial != 0 else 0.0\n        \n        # Mass statistics\n        if n_final > 0:\n            m_mean = np.mean(m)\n            m_std = np.std(m)\n            m_min = np.min(m)\n            m_max = np.max(m)\n        else: # Should not happen in this problem\n            m_mean = m_std = m_min = m_max = 0.0\n            \n        return (n_final, m_final, total_merges, k_final, u_final, e_initial, e_final,\n                delta_e_frac, m_mean, m_std, m_min, m_max)\n\n    test_cases = [\n        0.0,  # Case 1\n        0.05, # Case 2\n        0.15, # Case 3\n    ]\n\n    all_results = []\n    for r_coll in test_cases:\n        result_tuple = run_simulation(r_coll)\n        formatted_case = []\n        for item in result_tuple:\n            if isinstance(item, float):\n                formatted_case.append(f\"{item:.6f}\")\n            else:\n                formatted_case.append(str(item))\n        all_results.append(f\"[{','.join(formatted_case)}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3163488"}, {"introduction": "在建立了模拟之后，我们现在要探讨其长期可预测性，这是混沌系统研究的一个中心主题。这项实践 [@problem_id:3163501] 探索了“伪影时间”的概念，量化了计算机中固有的微小数值误差如何随时间指数级增长。通过比较高精度轨道与受模拟舍入误差影响的轨道，你将对蝴蝶效应以及模拟混沌动力学的基本限制获得切实的理解。", "problem": "您的任务是编写一个完整的、可运行的程序，以数值方式估算混沌引力 $N$ 体系统中影子时间与机器 epsilon $\\,\\epsilon_{\\mathrm{mach}}\\,$ 的函数关系。影子时间的定义是，在给定的有限精度 $\\,\\epsilon_{\\mathrm{mach}}\\,$ 下计算的轨道与高精度参考轨道之间的偏差首次超过预设阈值的时间。这项工作必须基于第一性原理，并侧重于数值精度如何与混沌动力学相互作用。\n\n从以下基本原理开始：\n- 牛顿第二定律将加速度 $\\,\\mathbf{a}_i(t)\\,$ 与合力 $\\,\\mathbf{F}_i(t)\\,$ 联系起来：\n$$m_i\\,\\mathbf{a}_i(t) = \\mathbf{F}_i(t)。$$\n- 对于二维空间牛顿引力作用下的点质量，物体 $\\,i\\,$ 因物体 $\\,j\\,$ 产生的加速度可以建模为\n$$\\mathbf{a}_i(t) = \\sum_{j \\neq i} G\\,m_j\\,\\frac{\\mathbf{r}_j(t) - \\mathbf{r}_i(t)}{\\left(\\lVert \\mathbf{r}_j(t) - \\mathbf{r}_i(t)\\rVert^2 + \\varepsilon_{\\text{soft}}^2\\right)^{3/2}}，$$\n其中 $\\,G\\,$ 是引力常数，$\\,\\varepsilon_{\\text{soft}}  0\\,$ 是一个小的软化长度，用于避免在近距离接触时出现奇异加速度。\n- 运动学通过 $\\,\\mathbf{v}_i(t) = \\frac{d\\mathbf{r}_i}{dt}\\,$ 和 $\\,\\mathbf{a}_i(t) = \\frac{d\\mathbf{v}_i}{dt}\\,$ 定义速度 $\\,\\mathbf{v}_i(t)\\,$ 和位置 $\\,\\mathbf{r}_i(t)\\,$。\n\n使用适用于哈密顿系统的辛方法（例如速度-Verlet 格式）来离散化时间。使用固定的时间步长 $\\,\\Delta t\\,$，并根据每一步的位置计算 $\\,\\mathbf{a}_i(t)\\,$。参考轨道必须使用标准双精度算术计算，不进行模拟量化。有限精度轨道必须通过将所有中间状态变量舍入到对应于该 $\\,\\epsilon_{\\mathrm{mach}}\\,$ 的二进制网格来模拟机器 epsilon $\\,\\epsilon_{\\mathrm{mach}}\\,$。为模拟 $\\,\\epsilon_{\\mathrm{mach}}\\,$，将每个实数 $\\,x\\,$ 的二进制表示视为 $\\,x = m \\cdot 2^e\\,$，其中 $\\,m\\,$ 是尾数，$\\,e\\,$ 是指数，并将 $\\,m\\,$ 舍入到 $\\,\\epsilon_{\\mathrm{mach}}\\,$ 的最近倍数，如果舍入导致 $\\,|m| = 1\\,$，则调整 $\\,e\\,$。在有限精度轨道的每次更新中，将此模拟舍入应用于位置、速度和加速度。电气和电子工程师协会（IEEE）754 标准是这种表示法的基础，但不要假设任何特定的硬件格式；应按照描述显式地实现舍入。\n\n按如下方式定义影子时间 $\\,T_{\\text{shad}}(\\epsilon_{\\mathrm{mach}})\\,$。令 $\\,\\mathbf{r}_i^{\\text{ref}}(t)\\,$ 表示参考位置，$\\,\\mathbf{r}_i^{\\epsilon}(t)\\,$ 表示在模拟精度 $\\,\\epsilon_{\\mathrm{mach}}\\,$ 下的位置。在每个离散时间，计算分离度\n$$D(t;\\epsilon_{\\mathrm{mach}}) = \\max_{i \\in \\{1,\\dots,N\\}} \\left\\lVert \\mathbf{r}_i^{\\epsilon}(t) - \\mathbf{r}_i^{\\text{ref}}(t) \\right\\rVert。$$\n然后\n$$T_{\\text{shad}}(\\epsilon_{\\mathrm{mach}}) = \\min\\{t_k : D(t_k;\\epsilon_{\\mathrm{mach}})  D_{\\text{thr}}\\}，$$\n其中 $\\,t_k = k\\,\\Delta t\\,$ 是离散时间，$\\,D_{\\text{thr}}\\,$ 是一个固定阈值。如果在模拟时程 $\\,T_{\\max}\\,$ 内从未超过此阈值，则设 $\\,T_{\\text{shad}}(\\epsilon_{\\mathrm{mach}}) = T_{\\max}\\,$。\n\n在无量纲单位下实现以下数值实验：\n- 物体数量 $\\,N = 5\\,$。\n- 引力常数 $\\,G = 1\\,$。\n- 所有 $\\,i\\,$ 的质量 $\\,m_i = 1\\,$。\n- 软化长度 $\\,\\varepsilon_{\\text{soft}} = 10^{-3}\\,$。\n- 时间步长 $\\,\\Delta t = 5 \\times 10^{-3}\\,$。\n- 最大模拟时间 $\\,T_{\\max} = 50\\,$。\n- 影子阈值 $\\,D_{\\text{thr}} = 5 \\times 10^{-2}\\,$。\n- 二维初始位置 $\\,\\mathbf{r}_i(0)\\,$ 和初始速度 $\\,\\mathbf{v}_i(0)\\,$：\n  - $\\,\\mathbf{r}_1(0) = (-1,\\,0)\\,$, $\\,\\mathbf{v}_1(0) = (0,\\,0.3)\\,$，\n  - $\\,\\mathbf{r}_2(0) = (1,\\,0)\\,$, $\\,\\mathbf{v}_2(0) = (0,\\,-0.3)\\,$，\n  - $\\,\\mathbf{r}_3(0) = (0,\\,0.9)\\,$, $\\,\\mathbf{v}_3(0) = (-0.35,\\,0)\\,$，\n  - $\\,\\mathbf{r}_4(0) = (0,\\,-0.9)\\,$, $\\,\\mathbf{v}_4(0) = (0.35,\\,0)\\,$，\n  - $\\,\\mathbf{r}_5(0) = (0.2,\\,0.2)\\,$, $\\,\\mathbf{v}_5(0) = (-0.15,\\,0.2)\\,$。\n- 使用速度-Verlet 更新规则来随时间推进 $\\,\\mathbf{r}_i(t)\\,$ 和 $\\,\\mathbf{v}_i(t)\\,$。\n\n构建一个测试套件，涵盖一系列模拟的机器 epsilon，以探测不同的区域：\n- $\\,\\epsilon_{\\mathrm{mach}} = 2^{-10}\\,$，\n- $\\,\\epsilon_{\\mathrm{mach}} = 2^{-15}\\,$，\n- $\\,\\epsilon_{\\mathrm{mach}} = 2^{-20}\\,$，\n- $\\,\\epsilon_{\\mathrm{mach}} = 2^{-25}\\,$，\n- $\\,\\epsilon_{\\mathrm{mach}} = 2^{-30}\\,$。\n\n对于每个测试用例，计算 $\\,T_{\\text{shad}}(\\epsilon_{\\mathrm{mach}})\\,$。最终程序输出必须是单行，包含测试套件的影子时间列表，形式为用方括号括起来的逗号分隔列表，每个值四舍五入到 $\\,6\\,$ 位小数，例如 $\\,\\left[\\ldots\\right]\\,$。不得打印任何其他文本。\n\n您的程序必须是自包含的，无需用户输入即可运行，并使用标准双精度计算参考轨道。所有量都是无量纲的，因此输出中不需要物理单位。确保您的数值设置是科学上现实且自洽的。", "solution": "目标是数值研究混沌 5 体引力系统中的影子时间 $T_{\\text{shad}}$。这个时间量化了以有限精度计算的数值轨道在多长时间内能保持接近一个高精度参考轨道。该分析的关键在于从第一性原理出发实现一个自定义的数值模拟，重点关注混沌动力学与计算舍入误差之间的相互作用，这些误差由一个模拟的机器 epsilon $\\epsilon_{\\mathrm{mach}}$ 进行系统性控制。\n\n该物理系统由二维平面上的 $N=5$ 个物体组成，它们通过牛顿引力相互作用。位于位置 $\\mathbf{r}_i$、质量为 $m_i$ 的物体 $i$ 的加速度 $\\mathbf{a}_i$ 由所有其他物体 $j$ 的引力之和决定：\n$$\n\\mathbf{a}_i(t) = \\sum_{j \\neq i} G\\,m_j\\,\\frac{\\mathbf{r}_j(t) - \\mathbf{r}_i(t)}{\\left(\\lVert \\mathbf{r}_j(t) - \\mathbf{r}_i(t)\\rVert^2 + \\varepsilon_{\\text{soft}}^2\\right)^{3/2}}\n$$\n此处，$G$ 是引力常数，$\\varepsilon_{\\text{soft}}$ 是一个软化参数，用于防止在近距离接触时分母变为零，从而导致不符合物理的无限大加速度。对于这个问题，我们使用无量纲单位，其中 $G=1$，所有质量 $m_i=1$，且 $\\varepsilon_{\\text{soft}} = 10^{-3}$。\n\n为了模拟系统的演化，我们必须对运动方程进行数值积分，这些方程构成一个二阶常微分方程组：$\\frac{d^2\\mathbf{r}_i}{dt^2} = \\mathbf{a}_i(\\{\\mathbf{r}_j\\})$。引力 N 体问题是一个哈密顿系统，这意味着在真实动力学中，某些量（如总能量）是守恒的。对于此类系统的长期模拟，使用辛积分器至关重要，它旨在保持相空间的几何性质，并且比非辛方法表现出更好的长期能量守恒性。速度-Verlet 算法是一种广泛使用的二阶辛方法，既准确又计算效率高。给定时间 $t$ 的状态 $(\\mathbf{r}_i(t), \\mathbf{v}_i(t))$ 和一个固定的时间步长 $\\Delta t$，时间 $t+\\Delta t$ 的状态通过三个步骤计算得出：\n1.  计算半步速度更新：$\\mathbf{v}_i(t + \\Delta t/2) = \\mathbf{v}_i(t) + \\frac{1}{2} \\mathbf{a}_i(t) \\Delta t$，其中 $\\mathbf{a}_i(t)$ 是根据位置 $\\mathbf{r}_i(t)$ 计算的。\n2.  将位置更新到完整的新时间步：$\\mathbf{r}_i(t + \\Delta t) = \\mathbf{r}_i(t) + \\mathbf{v}_i(t + \\Delta t/2) \\Delta t$。\n3.  使用新的加速度计算全步速度：$\\mathbf{v}_i(t + \\Delta t) = \\mathbf{v}_i(t + \\Delta t/2) + \\frac{1}{2} \\mathbf{a}_i(t + \\Delta t)$，其中 $\\mathbf{a}_i(t + \\Delta t)$ 是根据新位置 $\\mathbf{r}_i(t + \\Delta t)$ 计算的。\n\n研究的核心是比较两个并行的模拟：一个是使用标准双精度浮点算术计算的参考轨道（模拟非常高的精度），另一个是在模拟的、较大的机器 epsilon $\\epsilon_{\\mathrm{mach}}$ 下计算的受扰轨道。为了模拟有限精度，应用了一个自定义的舍入函数。任何浮点数 $x$ 都可以表示为 $x = m \\cdot 2^e$，其中 $m$ 是尾数，$e$ 是指数。问题规定将尾数 $m$ 舍入到所需 $\\epsilon_{\\mathrm{mach}}$ 的最近倍数。这通过计算舍入后的尾数 $m' = \\text{round}(m / \\epsilon_{\\mathrm{mach}}) \\cdot \\epsilon_{\\mathrm{mach}}$ 来实现。舍入后的数字则为 $x' = m' \\cdot 2^e$。一个特殊情况是，如果舍入导致 $|m'|=1$，这违反了 $|m| \\in [0.5, 1)$ 的标准归一化。在这种情况下，表示法需要重新归一化；例如，$1.0 \\cdot 2^e$ 变为 $0.5 \\cdot 2^{e+1}$。此舍入过程应用于受扰轨道的速度-Verlet 积分的每一步更新中的所有状态变量（位置、速度）和中间量（加速度）。\n\n影子时间 $T_{\\text{shad}}(\\epsilon_{\\mathrm{mach}})$ 是通过追踪两条轨道之间的差异来确定的。在每个时间步 $t_k = k \\Delta t$，我们计算所有物体的最大位置偏差：\n$$\nD(t_k; \\epsilon_{\\mathrm{mach}}) = \\max_{i \\in \\{1,\\dots,N\\}} \\left\\lVert \\mathbf{r}_i^{\\epsilon}(t_k) - \\mathbf{r}_i^{\\text{ref}}(t_k) \\right\\rVert\n$$\n其中 $\\mathbf{r}_i^{\\epsilon}$ 和 $\\mathbf{r}_i^{\\text{ref}}$ 分别是受扰模拟和参考模拟中的位置。影子时间是该偏差首次超过预定义阈值的时间 $t_k$，即 $D(t_k; \\epsilon_{\\mathrm{mach}})  D_{\\text{thr}}$。如果在总模拟时间 $T_{\\max}$ 内偏差从未超过该阈值，则影子时间报告为 $T_{\\max}$。对于本实验，参数设置为 $\\Delta t = 5 \\times 10^{-3}$，$T_{\\max} = 50$，以及 $D_{\\text{thr}} = 5 \\times 10^{-2}$。\n\n该算法通过遍历一组指定的 $\\epsilon_{\\mathrm{mach}}$ 值来执行。对于每个 $\\epsilon_{\\mathrm{mach}}$，两个模拟从相同的初始条件开始同步运行。参考模拟使用标准算术，而受扰模拟在每个阶段都应用自定义舍入。在每个时间步检查偏差 $D(t_k)$，直到它超过 $D_{\\text{thr}}$，此时当前时间 $t_k$ 被记录为该 $\\epsilon_{\\mathrm{mach}}$ 的 $T_{\\text{shad}}$，并且该测试用例的模拟终止。对所有测试用例重复此过程，并收集最终的影子时间。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef round_to_precision(x, eps_mach):\n    \"\"\"\n    Rounds a number or a NumPy array to a specified machine epsilon.\n    This function emulates finite precision arithmetic by rounding the mantissa\n    of the floating-point representation.\n    \"\"\"\n    # Handle the zero case to avoid issues with np.frexp(0)\n    if np.all(x == 0):\n        return x\n\n    # Decompose x into mantissa and exponent such that x = mantissa * 2**exponent\n    # with 0.5 = |mantissa|  1.0 for non-zero x.\n    mantissa, exponent = np.frexp(x)\n    \n    # Round the mantissa to the nearest multiple of eps_mach\n    rounded_mantissa = np.round(mantissa / eps_mach) * eps_mach\n\n    # Handle cases where rounding results in |mantissa| = 1.0, which needs\n    # renormalization to stay within the [0.5, 1.0) range for the mantissa.\n    # Ex: 1.0 * 2^e becomes 0.5 * 2^(e+1).\n    # This check must be done element-wise for arrays.\n    if isinstance(rounded_mantissa, np.ndarray):\n        overflow_mask = np.abs(rounded_mantissa) == 1.0\n        rounded_mantissa[overflow_mask] /= 2.0\n        exponent[overflow_mask] += 1\n    elif abs(rounded_mantissa) == 1.0:\n        rounded_mantissa /= 2.0\n        exponent += 1\n        \n    # Reconstruct the number from the rounded mantissa and adjusted exponent.\n    return np.ldexp(rounded_mantissa, exponent)\n\ndef calculate_accelerations(positions, masses, G, eps_soft_sq):\n    \"\"\"\n    Calculates the acceleration of each body due to gravitational interaction.\n    \"\"\"\n    N = positions.shape[0]\n    # Reshape for broadcasting:\n    # positions[:, np.newaxis, :] -> shape (N, 1, 2)\n    # positions[np.newaxis, :, :] -> shape (1, N, 2)\n    # diffs will have shape (N, N, 2), where diffs[i, j] = r_i - r_j\n    diffs = positions[:, np.newaxis, :] - positions[np.newaxis, :, :]\n    \n    # Calculate squared distances, shape (N, N)\n    dist_sq = np.sum(diffs**2, axis=-1)\n    \n    # Calculate the inverse cube of the softened distance\n    inv_r3 = (dist_sq + eps_soft_sq)**(-1.5)\n    # Set diagonal to zero to avoid self-interaction (i=j)\n    np.fill_diagonal(inv_r3, 0.0)\n    \n    # Calculate accelerations. The summation is over axis j=1.\n    # masses[np.newaxis, :, np.newaxis] broadcasts masses for j.\n    # The result has shape (N, 2). The formula is a_i = sum_j G*m_j*(r_j-r_i)/|...|^3\n    # which is sum_j G*m_j*(-diffs_ij)/|...|^3\n    accelerations = -G * np.sum(masses[np.newaxis, :, np.newaxis] * diffs * inv_r3[:, :, np.newaxis], axis=1)\n    \n    return accelerations\n\ndef run_simulation(eps_mach, N, G, masses, eps_soft, dt, T_max, D_thr, r0, v0):\n    \"\"\"\n    Runs a single N-body simulation for a given machine epsilon and returns the shadowing time.\n    \"\"\"\n    eps_soft_sq = eps_soft**2\n    num_steps = int(T_max / dt)\n\n    # --- Initialize Reference Trajectory ---\n    r_ref = r0.copy()\n    v_ref = v0.copy()\n    \n    # --- Initialize Finite-Precision Trajectory ---\n    # Start with identical initial conditions, then apply initial rounding.\n    r_eps = r0.copy()\n    v_eps = v0.copy()\n    r_eps = round_to_precision(r_eps, eps_mach)\n    v_eps = round_to_precision(v_eps, eps_mach)\n    \n    # Calculate initial accelerations\n    a_ref = calculate_accelerations(r_ref, masses, G, eps_soft_sq)\n    a_eps = calculate_accelerations(r_eps, masses, G, eps_soft_sq)\n    a_eps = round_to_precision(a_eps, eps_mach)\n\n    for k in range(num_steps):\n        # --- Update Reference Trajectory (Velocity-Verlet) ---\n        v_ref_half = v_ref + 0.5 * a_ref * dt\n        r_ref = r_ref + v_ref_half * dt\n        a_ref_new = calculate_accelerations(r_ref, masses, G, eps_soft_sq)\n        v_ref = v_ref_half + 0.5 * a_ref_new * dt\n        a_ref = a_ref_new\n\n        # --- Update Finite-Precision Trajectory (Velocity-Verlet with rounding) ---\n        v_eps_half = v_eps + 0.5 * a_eps * dt\n        v_eps_half = round_to_precision(v_eps_half, eps_mach)\n        \n        r_eps = r_eps + v_eps_half * dt\n        r_eps = round_to_precision(r_eps, eps_mach)\n        \n        a_eps_new = calculate_accelerations(r_eps, masses, G, eps_soft_sq)\n        a_eps_new = round_to_precision(a_eps_new, eps_mach)\n        \n        v_eps = v_eps_half + 0.5 * a_eps_new * dt\n        v_eps = round_to_precision(v_eps, eps_mach)\n        \n        a_eps = a_eps_new\n        \n        # --- Check for Shadowing ---\n        current_time = (k + 1) * dt\n        separation = np.linalg.norm(r_eps - r_ref, axis=1)\n        max_separation = np.max(separation)\n        \n        if max_separation > D_thr:\n            return current_time\n            \n    return T_max\n\ndef solve():\n    # Define the parameters for the numerical experiment\n    N = 5\n    G = 1.0\n    masses = np.ones(N)\n    eps_soft = 1.0e-3\n    dt = 5.0e-3\n    T_max = 50.0\n    D_thr = 5.0e-2\n\n    # Define initial positions and velocities\n    r0 = np.array([\n        [-1.0, 0.0],\n        [1.0, 0.0],\n        [0.0, 0.9],\n        [0.0, -0.9],\n        [0.2, 0.2]\n    ])\n    v0 = np.array([\n        [0.0, 0.3],\n        [0.0, -0.3],\n        [-0.35, 0.0],\n        [0.35, 0.0],\n        [-0.15, 0.2]\n    ])\n    \n    # Define the test cases for machine epsilon\n    test_cases = [2**-10, 2**-15, 2**-20, 2**-25, 2**-30]\n\n    results = []\n    for eps_mach in test_cases:\n        shadowing_time = run_simulation(eps_mach, N, G, masses, eps_soft, dt, T_max, D_thr, r0, v0)\n        results.append(shadowing_time)\n\n    # Format the final output as specified\n    formatted_results = ','.join([f\"{res:.6f}\" for res in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```", "id": "3163501"}, {"introduction": "一个正确的模拟只有在合理的时间内运行才有用。我们的最后一个实践将重点从物理准确性转向计算性能，使用 Roofline 模型。在这个练习中 [@problem_id:3163576]，你将不再以物理学家的身份，而是以计算机架构师的视角来分析 N 体代码的核心计算内核。通过计算其算术强度，你将能预测模拟是受处理器速度限制还是内存带宽限制，这是在现代硬件上优化科学代码的一项关键技能。", "problem": "考虑在$N$体引力模拟中使用的经典两两相互作用核。从 Newton 的运动定律和万有引力定律出发，粒子 $i$ 和粒子 $j$ 之间的每次相互作用计算都以一种标准算法模式实现，对于每一对 $(i,j)$，该模式对浮点标量执行以下算术步骤：相减以形成相对坐标 $dx, dy, dz$；平方求和以形成 $r^2$；加上一个小的软化参数；取平方根和倒数以获得 $1/r$；相乘以获得 $1/r^3$；按 $G$ 和源质量进行缩放；最后为粒子 $i$ 累加三个加速度分量。假设每种算术运算类型，包括加法、减法、乘法、除法和平方根，都精确地算作一次浮点运算。假设数据布局为数组结构（structure-of-arrays），其中位置存储为独立的数组，质量也存储为独立的数组。\n\n假设对于单次相互作用，关于主内存流量的数据移动模型如下：目标粒子 $i$ 的位置和累加器在内层循环中保存在寄存器中，其内存流量被分摊到许多源粒子 $j$ 上，因此在每次相互作用的层面上被忽略。对于每个源粒子 $j$，算法从主内存加载 $x_j, y_j, z_j$ 和 $m_j$。如果一个软件管理的缓存或分块方案使得每个加载的 $j$ 可以在多个不同的 $i$ 粒子之间重用，则用一个重用因子 $r$ 来对此建模，这意味着平均而言，每个 $j$ 的四个标量从主内存加载一次，但在被逐出之前用于 $r$ 次不同的两两相互作用。在此模型下，每次相互作用的有效主内存字节数是这四个标量的总字节数除以 $r$。\n\n使用 Roofline 性能模型，您必须在给定的硬件上对该核进行分类，判断其是受限于峰值浮点吞吐率还是主内存带宽，并预测其可达到的浮点速率。每个测试用例的相关输入是：每个标量的浮点精度（以字节为单位），重用因子 $r$，硬件峰值浮点速率 $P_{\\text{peak}}$（单位为吉浮点运算每秒），以及峰值主内存带宽 $B_{\\text{peak}}$（单位为吉字节每秒）。您的程序必须为每个测试用例计算算术强度 $I$（单位为浮点运算每字节），脊点 $R$（定义为区分带宽受限和计算受限区域的阈值），预测的可达到浮点速率 $P_{\\text{att}}$（单位为吉浮点运算每秒），以及一个区域标志（如果为带宽受限则定义为 $0$，如果为计算受限则定义为 $1$）。只能使用以下原则性依据：经典力学中速度和加速度的定义、Newton 的万有引力定律、如上所述的浮点运算计数定义、算术强度是每次传输字节的浮点运算次数的定义，以及计算的可达到速率受峰值浮点吞吐率和由算术强度调节的峰值带宽共同约束的理念。\n\n除了可以从上述定义推导出的公式外，您不得使用任何捷径公式。请仔细计算由算法步骤所隐含的每次两两相互作用的浮点运算次数，以及由内存模型和重用因子 $r$ 所隐含的每次相互作用传输的字节数。\n\n对于数值评估，请使用以下由六个独立的硬件和算法设置组成的测试套件，其中所有以吉浮点运算每秒和吉字节每秒为单位的量都应被视为实数：\n\n- 测试用例 1：双精度，每个标量 8 字节，重用因子 $r = 1$，$P_{\\text{peak}} = 200$，$B_{\\text{peak}} = 50$。\n- 测试用例 2：双精度，每个标量 8 字节，重用因子 $r = 1$，$P_{\\text{peak}} = 7000$，$B_{\\text{peak}} = 900$。\n- 测试用例 3：双精度，每个标量 8 字节，重用因子 $r = 8$，$P_{\\text{peak}} = 200$，$B_{\\text{peak}} = 50$。\n- 测试用例 4：单精度，每个标量 4 字节，重用因子 $r = 1$，$P_{\\text{peak}} = 14000$，$B_{\\text{peak}} = 900$。\n- 测试用例 5：双精度，每个标量 8 字节，重用因子 $r = 32$，$P_{\\text{peak}} = 200$，$B_{\\text{peak}} = 50$。\n- 测试用例 6：双精度，每个标量 8 字节，重用因子 $r = 1$，$P_{\\text{peak}} = 200$，$B_{\\text{peak}} = 304.7619047619$。\n\n角度单位不适用。无需物理单位。所有浮点输出必须表示为四舍五入到六位小数的实数。对于每个测试用例，输出一个列表，按此顺序包含：算术强度 $I$、脊点 $R$、预测的可达到速率 $P_{\\text{att}}$ 和区域标志，其中当且仅当 $I$ 大于或等于 $R$ 时，区域标志等于 $1$。您的程序应生成单行输出，其中包含这些按测试用例排列的列表，以逗号分隔，并包含在一对单独的方括号内（例如，$[[…],[…],…]$）。输出必须完全由上述测试套件和所述的原则性依据确定，无需任何额外输入。", "solution": "该问题要求使用 Roofline 性能模型对一个标准的引力 $N$ 体相互作用核进行分析。此分析基于对算术运算和主内存数据移动的精细计算，这些计算均源自问题陈述中概述的第一性原理。\n\n解决方案分三个阶段进行：\n1.  量化每次两两粒子相互作用的算术功（浮点运算）。\n2.  量化每次相互作用的主内存数据传输。\n3.  应用 Roofline 模型，使用这些量来确定性能特征。\n\n### 1. 算术工作负载分析（每次相互作用的浮点运算次数）\n\n浮点运算次数（FLOPs）是通过对目标粒子 $i$ 和源粒子 $j$ 之间单次相互作用的算法模式中描述的操作进行求和来确定的。每次算术运算（加法、减法、乘法、除法、平方根）都计为一次 FLOP。\n\n粒子 $j$ 对粒子 $i$ 的力由 Newton 的万有引力定律给出，$\\vec{F}_{ij} \\propto m_i m_j \\vec{r}_{ij} / ||\\vec{r}_{ij}||^3$，其中 $\\vec{r}_{ij} = \\vec{r}_j - \\vec{r}_i$。粒子 $i$ 的加速度为 $\\vec{a}_i = \\vec{F}_{ij}/m_i$。该算法计算 $\\vec{a}_i \\mathrel{+}= G m_j \\vec{r}_{ij} / ||\\vec{r}_{ij}||^3$。步骤如下：\n\n1.  **计算相对位置向量**：$\\vec{\\Delta r} = (dx, dy, dz) = \\vec{r}_j - \\vec{r}_i$。这需要对三个分量进行 3 次减法。\n    `FLOPs = 3`\n\n2.  **计算距离平方**：$r^2 = dx^2 + dy^2 + dz^2$。这涉及 3 次乘法（平方）和 2 次加法。\n    `FLOPs = 3 + 2 = 5`\n\n3.  **应用软化**：$r_s^2 = r^2 + \\epsilon^2$，其中 $\\epsilon^2$ 是软化参数。这是 1 次加法。\n    `FLOPs = 1`\n\n4.  **计算逆距离**：算法计算 $1/r_s$。这被描述为“取平方根和倒数”。\n    - $r_s = \\sqrt{r_s^2}$：1 次平方根运算。\n    - $1/r_s$：1 次除法运算。\n    `FLOPs = 1 + 1 = 2`\n\n5.  **计算逆立方距离**：为了从 $1/r_s$ 得到 $1/r_s^3$，需要两次乘法：$(1/r_s) \\cdot (1/r_s) \\to 1/r_s^2$，以及 $(1/r_s^2) \\cdot (1/r_s) \\to 1/r_s^3$。\n    `FLOPs = 2`\n\n6.  **按物理常数和质量缩放**：项 $1/r_s^3$ 按引力常数 $G$ 和源质量 $m_j$ 进行缩放。这产生一个标量 $s = G \\cdot m_j \\cdot (1/r_s^3)$。这需要 2 次乘法。\n    `FLOPs = 2`\n\n7.  **累加加速度**：粒子 $i$ 的加速度向量 $\\vec{a}_i$ 被更新：$\\vec{a}_i \\mathrel{+}= s \\cdot \\vec{\\Delta r}$。这涉及将 $\\vec{\\Delta r}$ 的每个分量乘以 $s$ 并加到 $\\vec{a}_i$ 的相应分量上。这是 3 次乘法和 3 次加法。\n    `FLOPs = 3 + 3 = 6`\n\n将所有步骤的 FLOP 计数相加，得到每次相互作用的总 FLOPs，$F$：\n$$ F = 3 + 5 + 1 + 2 + 2 + 2 + 6 = 21 \\text{ FLOPs} $$\n\n### 2. 数据传输分析（每次相互作用的字节数）\n\n内存模型指定，对于每个源粒子 $j$，其位置 $(x_j, y_j, z_j)$ 和质量 $m_j$ 从主内存加载。这构成 4 个标量值的加载。目标粒子 $i$ 的数据假定驻留在寄存器中，并且在每次相互作用的基础上不产生主内存流量。\n\n设 $S$ 是每个标量的浮点精度（以字节为单位）。从主内存为一个源粒子 $j$ 加载的总字节数为 $4S$。该模型包含一个重用因子 $r$，表示粒子 $j$ 的数据在从缓存中被逐出之前，被用于 $r$ 次不同的两两相互作用中。因此，内存访问成本被分摊到这 $r$ 次使用上。每次相互作用从主内存传输的有效字节数 $M$ 为：\n$$ M = \\frac{4S}{r} \\text{ bytes} $$\n\n### 3. Roofline 模型应用\n\nRoofline 模型根据核的算术强度和硬件的峰值能力来预测可达到的性能 $P_{\\text{att}}$。\n\n-   **算术强度 ($I$)**: 这是算术功与数据移动量的比率。\n    $$ I = \\frac{F}{M} = \\frac{21}{4S/r} = \\frac{21r}{4S} \\quad [\\text{FLOPs/byte}] $$\n\n-   **硬件参数**: 硬件由其峰值浮点速率 $P_{\\text{peak}}$（单位 GFLOPS）和其峰值主内存带宽 $B_{\\text{peak}}$（单位 GB/s）来表征。\n\n-   **脊点 ($R$)**: 这是性能限制从内存受限转换到计算受限的临界算术强度。它是峰值性能与峰值带宽的比率。\n    $$ R = \\frac{P_{\\text{peak}}}{B_{\\text{peak}}} \\quad [\\text{FLOPs/byte}] $$\n\n-   **可达到性能 ($P_{\\text{att}}$)**: 性能受计算上限和内存上限的双重约束。可达到的性能是这两个限制中的较小值。\n    - 计算受限性能: $P_{\\text{peak}}$\n    - 内存受限性能: $I \\cdot B_{\\text{peak}}$\n    $$ P_{\\text{att}} = \\min(P_{\\text{peak}}, I \\cdot B_{\\text{peak}}) \\quad [\\text{GFLOPS}] $$\n\n-   **区域分类**: 如果核的算术强度足以使浮点单元饱和，则其被分类为计算受限，否则为带宽受限。问题指定了区域标志的条件如下：\n    - 如果 $I \\geq R$，则为计算受限（标志 = $1$）。\n    - 如果 $I  R$，则为带宽受限（标志 = $0$）。\n\n这些推导出的公式足以计算每个测试用例所需的量。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the N-body Roofline model problem for a suite of test cases.\n    \"\"\"\n    \n    # Test cases defined as tuples of (precision_bytes, reuse_factor, P_peak, B_peak)\n    test_cases = [\n        # Test case 1: double precision, r=1, CPU-like\n        (8, 1, 200, 50),\n        # Test case 2: double precision, r=1, GPU-like\n        (8, 1, 7000, 900),\n        # Test case 3: double precision, r=8, CPU-like with tiling\n        (8, 8, 200, 50),\n        # Test case 4: single precision, r=1, GPU-like\n        (4, 1, 14000, 900),\n        # Test case 5: double precision, r=32, CPU-like with heavy tiling\n        (8, 32, 200, 50),\n        # Test case 6: double precision, r=1, knee-point case\n        (8, 1, 200, 304.7619047619),\n    ]\n\n    # Constant derived from the problem description: total FLOPs per interaction.\n    # 3(sub) + 5(r_sq) + 1(soften) + 2(inv_r) + 2(inv_r_cubed) + 2(scale_G_m) + 6(accum)\n    FLOPS_PER_INTERACTION = 21.0\n\n    results = []\n    \n    for case in test_cases:\n        s_bytes, r_reuse, p_peak, b_peak = case\n\n        # 1. Calculate Bytes per Interaction\n        # Load x_j, y_j, z_j, m_j (4 scalars) with reuse factor r.\n        bytes_per_interaction = (4.0 * s_bytes) / r_reuse\n\n        # 2. Calculate Arithmetic Intensity (I)\n        # I = FLOPs / Byte\n        arithmetic_intensity = FLOPS_PER_INTERACTION / bytes_per_interaction\n\n        # 3. Calculate Ridge Point (R)\n        # R = P_peak / B_peak\n        ridge_point = p_peak / b_peak\n        \n        # 4. Determine Regime and Attainable Performance (P_att)\n        # The performance is the minimum of the compute ceiling (P_peak)\n        # and the memory bandwidth ceiling (I * B_peak).\n        \n        # P_att = min(P_peak, I * B_peak)\n        attainable_rate = min(p_peak, arithmetic_intensity * b_peak)\n        \n        # Regime flag is 1 if compute-bound (I = R), 0 if bandwidth-bound (I  R).\n        regime_flag = 1 if arithmetic_intensity >= ridge_point else 0\n        \n        # Store the results for this case.\n        # The problem requires rounding floats to six decimal places.\n        case_result = [\n            round(arithmetic_intensity, 6),\n            round(ridge_point, 6),\n            round(attainable_rate, 6),\n            regime_flag\n        ]\n        results.append(case_result)\n\n    # Format the final output string as a list of lists, without spaces.\n    inner_strs = []\n    for res_list in results:\n        # Format floats to 6 decimal places, int as is.\n        formatted_vals = [f\"{res_list[0]:.6f}\", f\"{res_list[1]:.6f}\", f\"{res_list[2]:.6f}\", str(res_list[3])]\n        inner_strs.append(f\"[{','.join(formatted_vals)}]\")\n    \n    final_output_str = f\"[{','.join(inner_strs)}]\"\n\n    print(final_output_str)\n\nsolve()\n```", "id": "3163576"}]}