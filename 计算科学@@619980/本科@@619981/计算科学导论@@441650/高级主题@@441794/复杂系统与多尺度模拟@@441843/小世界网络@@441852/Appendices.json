{"hands_on_practices": [{"introduction": "小世界网络的一个标志性特征是高的聚类效应，这意味着网络中的节点倾向于形成紧密连接的群组。局部聚类系数是衡量这种效应的关键指标，它量化了一个节点的邻居之间相互连接的紧密程度。通过这个练习[@problem_id:1707846]，你将亲手计算一个规则网络中节点的聚类系数，并观察在对一条边进行重连后该系数如何变化，从而直观地理解网络局部结构的变化。", "problem": "网络中节点 $i$ 的局部聚类系数是衡量该节点邻居之间连接紧密程度的指标。其定义公式为：\n$$C_i = \\frac{2 E_i}{k_i(k_i - 1)}$$\n其中 $k_i$ 是节点 $i$ 的邻居数量（即度），$E_i$ 是节点 $i$ 的邻居之间存在的边的数量。\n\n考虑一个由8个节点组成的无向网络，节点标记为 $v_0, v_1, \\dots, v_7$。初始时，该网络是一个正则图，其中每个节点 $v_i$ 与另外四个节点相连：$v_{(i-2) \\pmod 8}$、$v_{(i-1) \\pmod 8}$、$v_{(i+1) \\pmod 8}$ 和 $v_{(i+2) \\pmod 8}$。\n\n首先，计算在这个初始网络配置中节点 $v_0$ 的局部聚类系数。\n\n接下来，网络结构被修改。连接节点 $v_0$ 和节点 $v_2$ 的单条边被移除。然后创建一条新边，连接节点 $v_0$ 和节点 $v_5$。网络中所有其他边保持不变。\n\n计算在这个修改后的网络中节点 $v_0$ 的新局部聚类系数。\n\n给出节点 $v_0$ 的初始聚类系数和重连后的聚类系数。你的答案应包含两个精确的分数。", "solution": "问题要求计算节点 $v_0$ 在指定边重连前后的两个局部聚类系数值。节点 $i$ 的局部聚类系数公式为 $C_i = \\frac{2 E_i}{k_i(k_i - 1)}$。\n\n**第1部分：初始聚类系数计算**\n\n首先，我们分析初始网络，以找到节点 $v_0$ 的聚类系数，我们称之为 $C_0^{\\text{initial}}$。\n\n1.  **确定 $v_0$ 的邻居**：根据规则，节点 $v_i$ 连接到 $v_{(i \\pm 1) \\pmod 8}$ 和 $v_{(i \\pm 2) \\pmod 8}$。对于 $i=0$，邻居是：\n    *   $v_{(0-1) \\pmod 8} = v_7$\n    *   $v_{(0+1) \\pmod 8} = v_1$\n    *   $v_{(0-2) \\pmod 8} = v_6$\n    *   $v_{(0+2) \\pmod 8} = v_2$\n    $v_0$ 的邻居集合是 $N_0 = \\{v_1, v_2, v_6, v_7\\}$。\n\n2.  **确定 $v_0$ 的度**：邻居的数量为 $k_0 = |N_0| = 4$。\n\n3.  **计算分母**：邻居之间可能的最大边数为 $\\frac{k_0(k_0-1)}{2} = \\frac{4(3)}{2} = 6$。公式的分母是 $k_0(k_0 - 1) = 4 \\times 3 = 12$。\n\n4.  **计算邻居之间存在的边数 ($E_0$)**：我们需要检查在初始网络中，$N_0 = \\{v_1, v_2, v_6, v_7\\}$ 中的哪些节点对是相连的。\n    *   **边 $(v_1, v_2)$**：节点 $v_1$ 连接到 $v_{(1\\pm1)\\pmod 8} = \\{v_0, v_2\\}$。所以，是的，$v_1$ 和 $v_2$ 之间有边。\n    *   **边 $(v_1, v_6)$**：$v_1$ 的邻居是 $v_0, v_2, v_3, v_7$。节点 $v_6$ 不在这个集合中。没有边。\n    *   **边 $(v_1, v_7)$**：$v_1$ 的邻居是 $v_0, v_2, v_3, v_7$。节点 $v_7$ 在这个集合中。是的，有边。\n    *   **边 $(v_2, v_6)$**：$v_2$ 的邻居是 $v_0, v_1, v_3, v_4$。节点 $v_6$ 不在这个集合中。没有边。\n    *   **边 $(v_2, v_7)$**：$v_2$ 的邻居是 $v_0, v_1, v_3, v_4$。节点 $v_7$ 不在这个集合中。没有边。\n    *   **边 $(v_6, v_7)$**：节点 $v_6$ 连接到 $v_{(6\\pm1)\\pmod 8} = \\{v_5, v_7\\}$。所以，是的，$v_6$ 和 $v_7$ 之间有边。\n    $v_0$ 的邻居之间存在的边是 $(v_1, v_2)$、$(v_1, v_7)$ 和 $(v_6, v_7)$。因此，这样的边数量为 $E_0 = 3$。\n\n5.  **计算 $C_0^{\\text{initial}}$**：\n    $C_0^{\\text{initial}} = \\frac{2 E_0}{k_0(k_0 - 1)} = \\frac{2 \\times 3}{12} = \\frac{6}{12} = \\frac{1}{2}$。\n\n**第2部分：重连后聚类系数计算**\n\n现在，我们分析修改后的网络，以找到节点 $v_0$ 的新聚类系数，我们称之为 $C_0^{\\text{rewired}}$。边 $(v_0, v_2)$ 被移除，边 $(v_0, v_5)$ 被添加。\n\n1.  **确定 $v_0$ 的新邻居**：旧的邻居集合是 $\\{v_1, v_2, v_6, v_7\\}$。节点 $v_2$ 被移除，$v_5$ 被添加。新的邻居集合是 $N'_0 = \\{v_1, v_5, v_6, v_7\\}$。\n\n2.  **确定 $v_0$ 的新度**：邻居的数量没有改变，所以 $k'_0 = |N'_0| = 4$。\n\n3.  **计算分母**：分母也没有改变：$k'_0(k'_0 - 1) = 4 \\times 3 = 12$。\n\n4.  **计算新邻居之间存在的边数 ($E'_0$)**：我们检查 $N'_0 = \\{v_1, v_5, v_6, v_7\\}$ 中节点对之间的边。注意，除 $v_0$ 外，节点之间的连接是基于初始网络的规则。\n    *   **边 $(v_1, v_5)$**：$v_1$ 的邻居是 $v_0, v_2, v_3, v_7$。节点 $v_5$ 不在这个集合中。没有边。\n    *   **边 $(v_1, v_6)$**：$v_1$ 的邻居是 $v_0, v_2, v_3, v_7$。节点 $v_6$ 不在这个集合中。没有边。\n    *   **边 $(v_1, v_7)$**：$v_1$ 的邻居包括 $v_7$。是的，这条边存在。\n    *   **边 $(v_5, v_6)$**：$v_5$ 的邻居是 $v_{(5\\pm1)\\pmod 8}=\\{v_4, v_6\\}$ 和 $v_{(5\\pm2)\\pmod 8}=\\{v_3, v_7\\}$。该集合是 $\\{v_3, v_4, v_6, v_7\\}$。节点 $v_6$ 在这个集合中。是的，这条边存在。\n    *   **边 $(v_5, v_7)$**：$v_5$ 的邻居包括 $v_7$。是的，这条边存在。\n    *   **边 $(v_6, v_7)$**：$v_6$ 的邻居包括 $v_7$。是的，这条边存在。\n    存在的边是 $(v_1, v_7)$、$(v_5, v_6)$、$(v_5, v_7)$ 和 $(v_6, v_7)$。因此，边的数量为 $E'_0 = 4$。\n\n5.  **计算 $C_0^{\\text{rewired}}$**：\n    $C_0^{\\text{rewired}} = \\frac{2 E'_0}{k'_0(k'_0 - 1)} = \\frac{2 \\times 4}{12} = \\frac{8}{12} = \\frac{2}{3}$。\n\n初始聚类系数是 $\\frac{1}{2}$，重连后的聚类系数是 $\\frac{2}{3}$。", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{1}{2} & \\frac{2}{3} \\end{pmatrix}}$$", "id": "1707846"}, {"introduction": "小世界网络的另一个核心特征是短的平均路径长度，即网络中任意两个节点之间的平均距离非常小。正是这种特性使得信息、疾病或影响能够迅速在网络中传播。这个练习[@problem_id:1707847]旨在通过一个简单的思想实验，让你清晰地看到，在一个高度有序的环形网络中，仅仅增加一条“捷径”就能如何戏剧性地缩短整个网络的平均路径长度。", "problem": "一个简单的网络模型由 $N=10$ 个节点组成，标记为 $v_0, v_1, \\dots, v_9$。最初，这些节点排列在一个规则的一维环形晶格中，其中每个节点 $v_i$ 仅与其两个直接邻居 $v_{i-1 \\pmod{10}}$ 和 $v_{i+1 \\pmod{10}}$ 相连。\n\n网络的平均路径长度 $L$ 定义为所有不同节点对之间最短路径距离的平均值。\n\n首先，考虑初始的环形晶格，并将其平均路径长度表示为 $L_{initial}$。然后，通过添加一条直接连接直径上相对的节点 $v_0$ 和 $v_5$ 的“捷径”边来修改网络。设这个新的、修改后的网络的平均路径长度为 $L_{final}$。\n\n计算比率 $\\frac{L_{final}}{L_{initial}}$。请将你的答案表示为最简分数形式。", "solution": "我们有一个10节点的循环图（每个节点的度为2）。对于初始环形晶格 $C_{10}$，其中 $N=10=2m$ 且 $m=5$，一个固定节点与其他节点之间的最短路径距离分布如下：在距离 $d=1,2,3,4$ 处各有 $2$ 个节点，在距离 $5$ 处有 $1$ 个节点。因此，从一个节点到所有其他节点的距离之和为\n$$\nS_{\\text{per node}}=2\\sum_{d=1}^{4} d + 5 = 2\\cdot 10 + 5 = 25 = m^{2}.\n$$\n那么，所有无序对的总和为\n$$\n\\text{Sum}_{\\text{init}}=\\frac{N\\cdot S_{\\text{per node}}}{2}=\\frac{10\\cdot 25}{2}=125,\n$$\n无序对的数量为 $\\binom{10}{2}=45$，所以\n$$\nL_{\\text{initial}}=\\frac{125}{45}=\\frac{25}{9}.\n$$\n\n添加捷径边 $(v_{0},v_{5})$ 后，图变成了两个共享边 $(0,5)$ 的 $6$-环。两个 $6$-环各自内部的距离与 $C_{6}$ 中的情况相同，而两个环之间的路径会以最优方式通过共享边。\n\n根据对称性，存在三种类型的节点：A类 $\\{0,5\\}$，B类 $\\{1,4,9,6\\}$，和 C类 $\\{2,3,8,7\\}$。计算从每类节点的一个代表到所有其他节点的距离之和：\n\n- 从 $0$ (A类) 出发：到 $\\{1,5,9\\}$ 的距离为 $1$，到 $\\{2,4,6,8\\}$ 的距离为 $2$，到 $\\{3,7\\}$ 的距离为 $3$。因此\n$$\nS_{0}=3\\cdot 1+4\\cdot 2+2\\cdot 3=17.\n$$\n\n- 从 $1$ (B类) 出发：到 $\\{0,2\\}$ 的距离为 $1$，到 $\\{3,5,9\\}$ 的距离为 $2$，到 $\\{4,8,6\\}$ 的距离为 $3$，到 $\\{7\\}$ 的距离为 $4$。因此\n$$\nS_{1}=2\\cdot 1+3\\cdot 2+3\\cdot 3+1\\cdot 4=21.\n$$\n\n- 从 $2$ (C类) 出发：到 $\\{1,3\\}$ 的距离为 $1$，到 $\\{0,4\\}$ 的距离为 $2$，到 $\\{5,9\\}$ 的距离为 $3$，到 $\\{8,6\\}$ 的距离为 $4$，到 $\\{7\\}$ 的距离为 $5$。因此\n$$\nS_{2}=2\\cdot 1+2\\cdot 2+2\\cdot 3+2\\cdot 4+1\\cdot 5=25.\n$$\n\n根据对称性，所有节点的有序距离总和为\n$$\nS_{\\text{tot, ordered}}=2\\cdot S_{0}+4\\cdot S_{1}+4\\cdot S_{2}=2\\cdot 17+4\\cdot 21+4\\cdot 25=34+84+100=218.\n$$\n因此，无序和为 $218/2=109$，所以\n$$\nL_{\\text{final}}=\\frac{109}{45}.\n$$\n\n因此，所求的比率为\n$$\n\\frac{L_{\\text{final}}}{L_{\\text{initial}}}=\\frac{\\frac{109}{45}}{\\frac{25}{9}}=\\frac{109}{45}\\cdot\\frac{9}{25}=\\frac{109}{125}.\n$$", "answer": "$$\\boxed{\\frac{109}{125}}$$", "id": "1707847"}, {"introduction": "理论计算为理解基本原理提供了坚实的基础，而计算科学的真正力量在于通过编程来模拟和探索复杂系统。在这个综合性练习[@problem_id:3194029]中，你将从手动计算转向算法实现。你将编写一个程序，通过贪心算法迭代地向规则网络中添加“捷径”，以系统性地降低其平均路径长度$L$，亲身体验从规则图到小世界网络的动态演化过程。", "problem": "给定一个称为环形格栅的无向、无权图结构。该环形格栅有 $N$ 个节点，标记为 $0,1,\\dots,N-1$，排列在一个圆环上，每个节点都与其两侧最近的 $k/2$ 个邻居相连（也就是说，节点 $i$ 与节点 $(i \\pm s) \\bmod N$ 相连，其中 $s = 1, 2, \\dots, k/2$）。假设 $k$ 为偶数且满足 $2 \\le k  N$。一个连通无向图 $G=(V,E)$ 的平均路径长度 $L(G)$ 从第一性原理定义为所有无序节点对之间最短路径距离的平均值：\n$$\nL(G) \\equiv \\frac{2}{N(N-1)} \\sum_{0 \\le u  v \\le N-1} d(u,v),\n$$\n其中 $d(u,v)$ 是节点 $u$ 和 $v$ 之间最短路径的长度（以边的数量计算）。\n\n快捷边（shortcut edge）定义为在两个不相邻的不同节点之间添加的一条额外的无向边。从环形格栅开始，您将迭代地添加快捷边以减小平均路径长度。在每次迭代中，应用以下确定性贪心策略：\n- 使用广度优先搜索（BFS）计算所有节点对的最短路径，以获得所有节点对 $(u,v)$ 的 $d(u,v)$。\n- 在所有 $u  v$ 的不相邻节点对 $(u,v)$ 中，选择当前最短路径距离 $d(u,v)$ 最大的那一对。如果存在多个距离相同的对，则通过选择字典序最小的对来打破平局，即选择最小的 $u$，如果 $u$ 相同，则选择最小的 $v$。\n- 将选定的边 $\\{u,v\\}$ 添加到图中。\n- 根据更新后的距离精确地重新计算平均路径长度 $L(G)$。\n\n给定一个目标平均路径长度 $\\hat L$（其中 $\\hat L \\ge 1$），定义 $t^*$ 为在贪心最远对策略下必须添加的快捷边的最小数量，使得经过 $t^*$ 次添加后，得到的图 $G_{t^*}$ 满足 $L(G_{t^*}) \\le \\hat L$。如果初始环形格栅已经满足 $L(G_0) \\le \\hat L$，则 $t^* = 0$。如有必要，此过程可以一直持续到图变为完全图；一个完全图的平均路径长度为 $1$。\n\n基本要求：\n- 使用最短路径距离的定义，并通过广度优先搜索（BFS）进行计算。\n- 使用所有节点对最短路径（APSP）的距离，根据其定义精确计算 $L(G)$。\n\n任务：\n- 实现一个完整的程序，对于每个测试用例，根据参数 $(N,k)$ 构建环形格栅，然后执行上述的贪心最远对快捷边添加策略，直到 $L(G) \\le \\hat L$，并返回整数 $t^*$。\n\n约束条件：\n- $N$ 是一个整数，满足 $N \\ge 4$。\n- $k$ 是一个偶数，满足 $2 \\le k  N$。\n- $\\hat L$ 是一个实数，满足 $\\hat L \\ge 1$。\n- 所有边都是无向和无权的。\n- 距离以边的数量计算（无单位的图论距离）。\n\n测试套件：\n为以下参数集提供结果：\n- 案例 1：$N=20$, $k=4$, $\\hat L=3.0$。\n- 案例 2：$N=10$, $k=2$, $\\hat L=2.0$。\n- 案例 3：$N=30$, $k=4$, $\\hat L=50.0$。\n- 案例 4：$N=16$, $k=4$, $\\hat L=1.0$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含结果 $[t^*_1,t^*_2,t^*_3,t^*_4]$，格式为方括号内以逗号分隔的列表，顺序与上述测试用例相同。每个 $t^*_i$ 都必须是整数。", "solution": "用户提供的问题是网络科学领域中一个明确定义的计算任务，网络科学是计算科学中的一个跨学科领域。该问题要求实现一种确定性贪心算法，向环形格栅图添加“快捷”边，直到其平均最短路径长度低于指定目标。这个过程是用于生成小世界网络的 Watts-Strogatz 模型的一个简化、确定性变体。该问题具有科学依据，数学上一致，并且可以算法形式化。\n\n解决方案过程涉及一个迭代模拟。每次迭代包括计算所有节点对的最短路径，根据“最远对”贪心策略确定要添加的最佳候选边，更新图，并重新评估平均路径长度。\n\n以下是该方法的逐步分解。\n\n**步骤 1：图的表示与初始化**\n该图是无向无权的，包含 $N$ 个节点。考虑到测试用例中 $N$ 的规模相对较小，使用邻接矩阵（表示为 $A$）是解决此问题的合适表示方法。矩阵 $A$ 是一个 $N \\times N$ 矩阵，如果节点 $u$ 和 $v$ 之间存在边，则 $A_{uv} = 1$，否则 $A_{uv} = 0$。由于图是无向的，所以 $A$ 是对称的（$A_{uv} = A_{vu}$）。\n\n初始图是一个环形格栅。其构建方式如下：对于每个节点 $i \\in \\{0, 1, \\dots, N-1\\}$，创建边以将其连接到两侧各 $k/2$ 个最近的邻居。节点 $i$ 的邻居是所有满足 $s \\in \\{1, 2, \\dots, k/2\\}$ 的节点 $(i \\pm s) \\pmod N$。模 $N$ 运算确保了格栅的环形拓扑结构。\n\n**步骤 2：所有节点对最短路径（APSP）计算**\n算法的核心需要知道所有节点对 $(u,v)$ 之间的最短路径距离 $d(u,v)$。由于图是无权的，从单个源节点查找最短路径的最有效方法是广度优先搜索（BFS）算法。\n\n为了计算所有节点对的最短路径，我们可以从每个节点 $s \\in \\{0, 1, \\dots, N-1\\}$ 开始分别执行一次 BFS。从源节点 $s$ 开始的单次 BFS 运行过程如下：\n1. 初始化一个大小为 $N$ 的距离数组 `dist`，其中 `dist[s] = 0`，对于所有 $v \\neq s$，`dist[v] = \\infty$。\n2. 初始化一个队列，并将源节点 $s$ 添加到队列中。\n3. 当队列不为空时，从队列中取出一个节点 $u$。\n4. 对于 $u$ 的每个邻居 $v$（即，对于每个满足 $A_{uv}=1$ 的 $v$）：\n   - 如果 $v$ 尚未被访问（即 `dist[v] == \\infty`），则设置其距离 `dist[v] = dist[u] + 1` 并将 $v$ 入队。\n\n通过将每个节点作为源节点运行此过程，我们可以填充一个 $N \\times N$ 的距离矩阵 $D$，其中 $D_{uv} = d(u,v)$。\n\n**步骤 3：平均路径长度计算**\n平均路径长度 $L(G)$ 使用计算出的距离矩阵 $D$ 根据其定义精确计算。公式为：\n$$\nL(G) = \\frac{1}{\\binom{N}{2}} \\sum_{0 \\le u  v \\le N-1} d(u,v) = \\frac{2}{N(N-1)} \\sum_{0 \\le u  v \\le N-1} D_{uv}\n$$\n计算方法是，将距离矩阵 $D$ 的上三角部分的所有元素求和，然后除以唯一节点对的总数，即 $N(N-1)/2$。\n\n**步骤 4：迭代贪心算法**\n主逻辑是一个迭代循环，在每一步添加一条快捷边。设 $t$ 为已添加的快捷边数量，初始化为 $t=0$。设 $G_t$ 为经过 $t$ 次添加后的图。\n\n初始化：\n1. 构建初始环形格栅 $G_0$。\n2. 设置 $t=0$。\n\n循环：\n1. 使用基于 BFS 的 APSP 方法计算当前图 $G_t$ 的距离矩阵 $D_t$。\n2. 从 $D_t$ 计算平均路径长度 $L(G_t)$。\n3. **终止检查**：如果 $L(G_t) \\le \\hat L$，则过程终止。所需的快捷边数量为 $t^* = t$。一个特殊情况是当 $L(G_0) \\le \\hat L$ 时，这意味着 $t^*=0$。\n4. **最远对选择**：如果 $L(G_t) > \\hat L$，我们必须添加一条新的快捷边。我们根据贪心策略确定最佳候选边 $\\{u,v\\}$：\n   a. 考虑所有在 $G_t$ 中尚未连接的、满足 $u  v$ 的不同节点对 $(u,v)$（即 $A_{uv}=0$）。\n   b. 在这些不相邻的节点对中，找到使最短路径距离 $d(u,v)$ 最大化的那一对。\n   c. 如果最大距离存在平局，则通过选择字典序最小的对来打破平局。也就是说，我们选择具有最小 $u$ 的对 $(u,v)$，对于该 $u$，再选择最小的 $v$。通过从 $0$ 到 $N-2$ 迭代 $u$ 并从 $u+1$ 到 $N-1$ 迭代 $v$，选择第一个达到观测到的最大距离的对，可以自然地处理这种平局打破方式。\n5. **图更新**：将选定的快捷边 $\\{u,v\\}$ 添加到图中，更新邻接矩阵（$A_{uv}=1$ 和 $A_{vu}=1$）。\n6. 快捷边计数器加一：$t \\leftarrow t+1$。\n7. 重复循环。\n\n这个过程保证会终止，因为添加一条边只会减少或保持路径长度，所以 $L(G)$ 是 $t$ 的一个非增函数。在最坏的情况下，该过程将持续到图变为完全图，此时 $L(G)=1$。由于问题规定 $\\hat L \\ge 1$，目标总是可以达到的。\n\n**步骤 5：测试用例分析**\n- **案例 1 ($N=20, k=4, \\hat L=3.0$)**：必须计算环形格栅的初始平均路径长度。预计该值将大于 $3.0$，因此需要非零次迭代。\n- **案例 2 ($N=10, k=2, \\hat L=2.0$)**：初始图是一个 $10$ 节点的环。其平均路径长度精确为 $L(G_0) = \\frac{1}{10 \\cdot 9 / 2} \\sum_{i=1}^5 i \\cdot (\\text{距离为 } i \\text{ 的节点对数量}) = \\frac{2}{90} (1 \\cdot 10 + 2 \\cdot 10 + 3 \\cdot 10 + 4 \\cdot 10 + 5 \\cdot 5) = 2.5$。由于 $2.5 > 2.0$，我们预计 $t^* > 0$。\n- **案例 3 ($N=30, k=4, \\hat L=50.0$)**：任何包含 $30$ 个节点的连通图的最大可能平均路径长度都远小于 $50.0$。初始环形格栅的 $L(G_0)$ 值将显著低于此目标。因此，条件 $L(G_0) \\le \\hat L$ 将立即满足，得出 $t^*=0$。\n- **案例 4 ($N=16, k=4, \\hat L=1.0$)**：唯一平均路径长度为 $1.0$ 的连通图是完全图。此案例要求计算使用贪心策略将初始格栅变为完全图所需的边数。初始边数为 $N k / 2 = 16 \\cdot 4 / 2 = 32$。一个完全图 $K_{16}$ 有 $N(N-1)/2 = 16 \\cdot 15 / 2 = 120$ 条边。需要添加的快捷边数量是 $120 - 32 = 88$。贪心算法将一直持续到不存在不相邻的节点对为止，此时图变为完全图，因此 $t^*=88$。\n\n实现将遵循此逻辑，为所有测试用例提供精确的答案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef run_simulation(N, k, L_hat):\n    \"\"\"\n    Computes the number of shortcuts to reach a target average path length.\n\n    Args:\n        N (int): Number of nodes.\n        k (int): Number of neighbors for each node in the initial ring lattice (must be even).\n        L_hat (float): Target average path length.\n\n    Returns:\n        int: The minimal number of shortcuts (t*).\n    \"\"\"\n\n    # Step 1: Initialize the ring lattice using an adjacency matrix\n    adj_matrix = np.zeros((N, N), dtype=int)\n    half_k = k // 2\n    for i in range(N):\n        for s in range(1, half_k + 1):\n            neighbor_fwd = (i + s) % N\n            neighbor_bwd = (i - s + N) % N\n            adj_matrix[i, neighbor_fwd] = 1\n            adj_matrix[i, neighbor_bwd] = 1\n\n    t = 0\n    while True:\n        # Step 2: Compute All-Pairs Shortest Paths (APSP) using BFS\n        # A value of -1 indicates unreachable nodes\n        dist_matrix = -1 * np.ones((N, N), dtype=int)\n        \n        for start_node in range(N):\n            dist_matrix[start_node, start_node] = 0\n            q = deque([start_node])\n            \n            while q:\n                u = q.popleft()\n                # Find neighbors of u using the adjacency matrix\n                neighbors = np.where(adj_matrix[u] == 1)[0]\n                for v in neighbors:\n                    if dist_matrix[start_node, v] == -1:\n                        dist_matrix[start_node, v] = dist_matrix[start_node, u] + 1\n                        q.append(v)\n        \n        # Check for disconnected components (should not happen for k>=2)\n        if np.any(dist_matrix == -1):\n             raise RuntimeError(\"Graph is not connected.\")\n\n        # Step 3: Calculate the current average path length\n        # Summing the upper triangle of the distance matrix\n        num_pairs = N * (N - 1) / 2\n        total_distance = np.sum(np.triu(dist_matrix, k=1))\n        avg_path_len = total_distance / num_pairs\n\n        # Step 4: Check for termination\n        if avg_path_len = L_hat:\n            return t\n\n        # Step 5: Find the farthest non-adjacent pair\n        max_dist = -1\n        best_pair = (-1, -1)\n        \n        # Iterate in lexicographical order to handle tie-breaking automatically\n        for u in range(N):\n            for v in range(u + 1, N):\n                if adj_matrix[u, v] == 0:\n                    current_dist = dist_matrix[u, v]\n                    if current_dist > max_dist:\n                        max_dist = current_dist\n                        best_pair = (u, v)\n        \n        # If no non-adjacent pair is found, the graph is complete.\n        if best_pair == (-1, -1):\n            if avg_path_len = L_hat:\n                 return t\n            else:\n                 # This should only happen if L_hat  1, which is disallowed\n                 raise RuntimeError(\"Graph is complete but L > L_hat.\")\n\n        # Step 6: Add the shortcut edge to the graph\n        u, v = best_pair\n        adj_matrix[u, v] = 1\n        adj_matrix[v, u] = 1\n        t += 1\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (20, 4, 3.0),\n        (10, 2, 2.0),\n        (30, 4, 50.0),\n        (16, 4, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, k, L_hat = case\n        result = run_simulation(N, k, L_hat)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3194029"}]}