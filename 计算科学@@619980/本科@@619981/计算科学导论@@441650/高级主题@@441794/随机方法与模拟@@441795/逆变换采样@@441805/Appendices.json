{"hands_on_practices": [{"introduction": "三角分布是逆变换采样的一个绝佳入门案例。它的概率密度函数（PDF）是分段线性的，形状直观，这使得推导其累积分布函数（CDF）及其反函数成为一个很好的微积分和代数练习。通过这个实践 [@problem_id:2403851]，你将掌握该方法的核心步骤，并学会处理由分段定义带来的边界条件。", "problem": "要求您为具有有限支撑集的三角概率分布实现逆变换采样。三角分布由三个实数参数 $a$、$c$ 和 $b$ 定义，满足 $a < b$ 和 $a \\le c \\le b$，其中 $a$ 是左端点，$b$ 是右端点，$c$ 是众数（峰值位置）。其概率密度函数在 $[a, c]$ 和 $[c, b]$ 上是连续分段线性的，在 $[a, b]$ 之外为零。您的任务是从第一性原理推导采样器，并将其实现为一个程序。\n\n基本原理：\n- 概率密度函数 (PDF)：一个非负函数 $f(x)$，其在支撑集上的积分为 $1$。\n- 累积分布函数 (CDF)：$F(x) = \\mathbb{P}(X \\le x) = \\int_{-\\infty}^{x} f(t)\\, dt$。\n- 逆变换采样：如果 $U$ 是一个在 $[0,1]$ 上均匀分布的随机变量，且 $F$ 是一个连续、严格递增的累积分布函数，则 $X = F^{-1}(U)$ 的累积分布函数为 $F$。\n\n要求：\n1) 仅从上述定义出发，推导在 $[a, c, b]$ 上的三角分布的分段累积分布函数 $F(x)$，并解析地对其求逆以获得对于 $u \\in [0,1]$ 的分位数函数 $F^{-1}(u)$。确保您的推导覆盖了一般情况 $a < c < b$，并能正确处理极限情况 $c = a$ 和 $c = b$。\n\n2) 实现一个程序，给定 $(a, c, b)$ 和一个包含多个 $u$ 值的列表（每个 $u \\in [0,1]$），使用您推导出的逆函数返回相应的样本 $x = F^{-1}(u)$。您必须处理以下细节：\n- 为保证数值鲁棒性，在应用逆函数之前将每个 $u$ 限定在 $[0,1]$ 范围内。\n- 您的实现必须在 $c = a$ 和 $c = b$ 时能正常工作，不会出现除以零或无效分支的问题。\n- 对于每个计算出的样本，将结果四舍五入到小数点后 $10$ 位。\n\n3) 您不得依赖任何库中预封装的三角分布。您可以使用允许的库中的基本数值运算，但采样器必须直接实现您推导出的逆函数。\n\n本挑战的输入和输出是固定的；没有用户输入。您的程序必须在预设的参数集和 $u$ 值（见下文测试套件）下评估逆函数，并打印包含所有结果的单行输出。\n\n测试套件：\n- 情况 $1$（一般“理想情况”）：$(a, c, b) = (0, 2, 5)$，使用 $u$ 值列表 $[0, 0.1, 0.4, 0.5, 0.9, 1]$。\n- 情况 $2$（边界情况 $c = a$）：$(a, c, b) = (3, 3, 7)$，使用 $u$ 值列表 $[0, 0.25, 0.999999, 1]$。\n- 情况 $3$（边界情况 $c = b$）：$(a, c, b) = (-2, 1, 1)$，使用 $u$ 值列表 $[0, 0.25, 0.8, 1]$。\n- 情况 $4$（边界鲁棒性）：$(a, c, b) = (0, 1, 2)$，使用 $u$ 值列表 $[0, 10^{-12}, 0.5, 1 - 10^{-12}, 1]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个包含四舍五入后样本的列表。具体而言，输出必须是形式为\n$[[x_{1,1},x_{1,2},\\dots],[x_{2,1},\\dots],[x_{3,1},\\dots],[x_{4,1},\\dots]]$\n的单行字符串，不含空格。每个 $x_{i,j}$ 都必须是四舍五入到小数点后 $10$ 位的浮点数。\n- 本问题不涉及任何物理单位；所有量均为无量纲实数。", "solution": "用户提供了一个问题陈述。我将首先对其进行验证。\n\n### 步骤 1：提取已知条件\n- **分布**：三角概率分布。\n- **参数**：实数 $a$、$c$、$b$ 满足 $a < b$ 和 $a \\le c \\le b$。$a$ 是最小值，$b$ 是最大值，$c$ 是众数。\n- **概率密度函数 (PDF)**：$f(x)$ 是连续的、分段线性的，支撑集为 $[a, b]$。\n- **累积分布函数 (CDF)**：$F(x) = \\mathbb{P}(X \\le x) = \\int_{-\\infty}^{x} f(t)\\, dt$。\n- **核心任务**：使用逆变换采样，从均匀随机变量 $U \\sim \\text{Uniform}[0,1]$ 生成样本 $X = F^{-1}(U)$。\n- **推导要求**：从第一性原理推导分段 CDF $F(x)$ 及其逆函数，即分位数函数 $F^{-1}(u)$。推导必须覆盖一般情况 $a < c < b$ 和极限情况 $c = a$ 及 $c = b$。\n- **实现要求**：\n    1. 实现推导出的 $F^{-1}(u)$ 函数。\n    2. 不要使用库中为三角分布预封装的函数。\n    3. $u$ 的输入值必须被限定在区间 $[0,1]$ 内。\n    4. 实现必须能正确处理 $c=a$ 和 $c=b$ 的情况。\n    5. 输出样本必须四舍五入到小数点后 10 位。\n- **测试套件**：\n    - 情况 1：$(a, c, b) = (0, 2, 5)$，$u = [0, 0.1, 0.4, 0.5, 0.9, 1]$。\n    - 情况 2：$(a, c, b) = (3, 3, 7)$，$u = [0, 0.25, 0.999999, 1]$。\n    - 情况 3：$(a, c, b) = (-2, 1, 1)$，$u = [0, 0.25, 0.8, 1]$。\n    - 情况 4：$(a, c, b) = (0, 1, 2)$，$u = [0, 10^{-12}, 0.5, 1 - 10^{-12}, 1]$。\n- **输出格式**：一个表示结果列表的列表的单行字符串，不含空格：`[[...],[...],[...],[...]]`。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题基于概率论（PDF、CDF）和计算统计学（逆变换采样）的基本、成熟原理。三角分布是一个标准的、无争议的概率分布。此标准已满足。\n- **良构性**：该问题提供了所有必要的定义、约束（$a < b$，$a \\le c \\le b$）和明确的目标。CDF 及其逆函数（对于连续、严格递增的函数）的存在性和唯一性由数学原理保证。此标准已满足。\n- **客观性**：问题以精确的数学语言陈述，没有任何主观性或模糊性。此标准已满足。\n- **缺陷检查**：该问题不违反任何科学定律，是可形式化、完整且可验证的。约束是一致的，所需任务定义明确。此标准已满足。\n\n### 步骤 3：结论与行动\n问题陈述是**有效**的。我将继续进行推导和求解。\n\n任务是推导三角分布的分位数函数并加以实现。这分三个阶段进行：首先，定义概率密度函数 (PDF)；其次，对 PDF 进行积分以求得累积分布函数 (CDF)；第三，对 CDF 求逆以获得分位数函数 $F^{-1}(u)$。\n\n**1. 概率密度函数 (PDF), $f(x)$**\n\nPDF $f(x)$ 描述了一个顶点为 $(a, 0)$、$(c, h)$ 和 $(b, 0)$ 的三角形，其中 $h$ 是三角形的高。PDF 下方的总面积必须为 $1$。三角形的面积由 $\\frac{1}{2} \\times \\text{底} \\times \\text{高}$ 给出。\n$$\n\\text{Area} = \\frac{1}{2} (b-a) h = 1 \\implies h = \\frac{2}{b-a}\n$$\nPDF 是一个分段线性函数。\n对于 $a \\le x \\le c$，直线通过 $(a, 0)$ 和 $(c, h)$。其方程为：\n$$\nf(x) = \\frac{h-0}{c-a} (x-a) = \\frac{2(x-a)}{(b-a)(c-a)}\n$$\n对于 $c < x \\le b$，直线通过 $(c, h)$ 和 $(b, 0)$。其方程为：\n$$\nf(x) = h + \\frac{0-h}{b-c} (x-c) = \\frac{2}{b-a} - \\frac{2(x-c)}{(b-a)(b-c)} = \\frac{2(b-c) - 2(x-c)}{(b-a)(b-c)} = \\frac{2(b-x)}{(b-a)(b-c)}\n$$\n综合起来，PDF 为：\n$$\nf(x) = \\begin{cases}\n\\frac{2(x-a)}{(b-a)(c-a)} & \\text{if } a \\le x \\le c \\\\\n\\frac{2(b-x)}{(b-a)(b-c)} & \\text{if } c < x \\le b \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\n这些表达式是在假设 $a < c < b$ 的情况下定义的。我们将看到，最终的分位数函数能够正确处理 $c=a$ 和 $c=b$ 的边界情况。\n\n**2. 累积分布函数 (CDF), $F(x)$**\n\nCDF 是 PDF 的积分，$F(x) = \\int_{a}^{x} f(t) \\,dt$。\n对于 $x < a$，$F(x)=0$。对于 $x > b$，$F(x)=1$。\n\n对于 $a \\le x \\le c$：\n$$\nF(x) = \\int_{a}^{x} \\frac{2(t-a)}{(b-a)(c-a)} \\,dt = \\frac{2}{(b-a)(c-a)} \\left[ \\frac{(t-a)^2}{2} \\right]_{a}^{x} = \\frac{(x-a)^2}{(b-a)(c-a)}\n$$\n在众数 $c$ 处，CDF 的值为 $F(c) = \\frac{(c-a)^2}{(b-a)(c-a)} = \\frac{c-a}{b-a}$。这个值是区间 $[a, c]$ 内的总概率质量。\n\n对于 $c < x \\le b$：\n$$\nF(x) = F(c) + \\int_{c}^{x} \\frac{2(b-t)}{(b-a)(b-c)} \\,dt \\\\\nF(x) = \\frac{c-a}{b-a} + \\frac{2}{(b-a)(b-c)} \\left[ -\\frac{(b-t)^2}{2} \\right]_{c}^{x} \\\\\nF(x) = \\frac{c-a}{b-a} + \\frac{-(b-x)^2 - (-(b-c)^2)}{(b-a)(b-c)} \\\\\nF(x) = \\frac{c-a}{b-a} + \\frac{(b-c)^2 - (b-x)^2}{(b-a)(b-c)}\n$$\n通过化简可以得到一个更简洁的形式：\n$$\nF(x) = \\frac{(c-a)(b-c) + (b-c)^2 - (b-x)^2}{(b-a)(b-c)} = \\frac{(b-c)(c-a+b-c) - (b-x)^2}{(b-a)(b-c)} \\\\\nF(x) = \\frac{(b-c)(b-a) - (b-x)^2}{(b-a)(b-c)} = 1 - \\frac{(b-x)^2}{(b-a)(b-c)}\n$$\n所以，完整的 CDF 是：\n$$\nF(x) = \\begin{cases}\n0 & \\text{if } x < a \\\\\n\\frac{(x-a)^2}{(b-a)(c-a)} & \\text{if } a \\le x \\le c \\\\\n1 - \\frac{(b-x)^2}{(b-a)(b-c)} & \\text{if } c < x \\le b \\\\\n1 & \\text{if } x > b\n\\end{cases}\n$$\n\n**3. 逆 CDF (分位数函数), $F^{-1}(u)$**\n\n为了实现逆变换采样，我们必须从方程 $u = F(x)$ 中解出 $x$，其中 $u \\in [0, 1]$。\n逆函数的形式取决于 $u$ 是落在对应于 $x \\le c$ 的范围还是 $x > c$ 的范围。区分这两种情况的 $u$ 的临界值是 $u_c = F(c) = \\frac{c-a}{b-a}$。\n\n情况 1：$0 \\le u \\le u_c$（对应于 $a \\le x \\le c$）\n$$\nu = \\frac{(x-a)^2}{(b-a)(c-a)} \\\\\n(x-a)^2 = u(b-a)(c-a) \\\\\nx-a = \\sqrt{u(b-a)(c-a)} \\quad (\\text{因为 } x \\ge a \\text{，取正根}) \\\\\nx = a + \\sqrt{u(b-a)(c-a)}\n$$\n\n情况 2：$u_c < u \\le 1$（对应于 $c < x \\le b$）\n$$\nu = 1 - \\frac{(b-x)^2}{(b-a)(b-c)} \\\\\n(b-x)^2 = (1-u)(b-a)(b-c) \\\\\nb-x = \\sqrt{(1-u)(b-a)(b-c)} \\quad (\\text{因为 } x \\le b \\text{，取正根}) \\\\\nx = b - \\sqrt{(1-u)(b-a)(b-c)}\n$$\n\n最终得到的分位数函数 $F^{-1}(u)$ 是：\n$$\nF^{-1}(u) = \\begin{cases}\na + \\sqrt{u (b-a) (c-a)} & \\text{if } 0 \\le u \\le \\frac{c-a}{b-a} \\\\\nb - \\sqrt{(1-u) (b-a) (b-c)} & \\text{if } \\frac{c-a}{b-a} < u \\le 1\n\\end{cases}\n$$\n这个单一、统一的公式是鲁棒的，并且能正确处理边界情况。\n- 如果 $c=a$，那么 $u_c = \\frac{c-a}{b-a} = 0$。条件 $0 \\le u \\le 0$ 仅对 $u=0$ 成立。对于任何 $u > 0$，使用第二个分支：$x = b - \\sqrt{(1-u) (b-a) (b-a)} = b - (b-a)\\sqrt{1-u}$。这对应于一个峰值在 $a$ 处的直角三角形。\n- 如果 $c=b$，那么 $u_c = \\frac{c-a}{b-a} = 1$。条件 $0 \\le u \\le 1$ 对所有 $u$ 都成立，因此总是使用第一个分支：$x = a + \\sqrt{u (b-a) (b-a)} = a + (b-a)\\sqrt{u}$。这对应于一个峰值在 $b$ 处的直角三角形。\n\n推导是完整且合理的。实现将遵循这个最终公式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements the inverse transform sampling for a triangular distribution.\n    The final output is printed in the exact required format.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: General case\n        {'params': (0, 2, 5), 'u_values': [0, 0.1, 0.4, 0.5, 0.9, 1]},\n        # Case 2: Edge case c = a\n        {'params': (3, 3, 7), 'u_values': [0, 0.25, 0.999999, 1]},\n        # Case 3: Edge case c = b\n        {'params': (-2, 1, 1), 'u_values': [0, 0.25, 0.8, 1]},\n        # Case 4: Boundary robustness\n        {'params': (0, 1, 2), 'u_values': [0, 10**-12, 0.5, 1 - 10**-12, 1]},\n    ]\n    \n    all_results = []\n\n    for case in test_cases:\n        a, c, b = case['params']\n        u_values = case['u_values']\n        \n        case_results = []\n        \n        # Pre-calculate terms for efficiency and clarity\n        # The problem states a  b, so b - a > 0 is guaranteed.\n        range_ab = b - a\n        range_ac = c - a\n        range_cb = b - c\n        \n        # Calculate the CDF value at the mode, which is the threshold for u\n        # This handles the case where b-a might equal 0 if the problem constraints were different,\n        # but here it's safe.\n        if range_ab == 0:\n            # Degenerate case, not covered by problem statement a  b\n            # but good practice for robustness. All samples are at 'a'.\n            fc = 0.5 # A reasonable default.\n        else:\n            fc = range_ac / range_ab\n        \n        for u in u_values:\n            # Per requirement, clamp u into [0, 1] for numerical robustness.\n            u_clamped = max(0.0, min(1.0, u))\n            \n            x = 0.0\n            # The logic directly implements the derived piecewise inverse CDF.\n            # The comparison u_clamped = fc correctly selects the formula branch,\n            # naturally handling the edge cases c=a (fc=0) and c=b (fc=1).\n            if u_clamped = fc:\n                # This branch corresponds to the interval [a, c]\n                # x = a + sqrt(u * (b-a) * (c-a))\n                # Handle potential floating point issue if range_ac is zero (c=a)\n                if range_ac == 0:\n                    term = 0.0\n                else:\n                    term = u_clamped * range_ab * range_ac\n                x = a + np.sqrt(term)\n            else:\n                # This branch corresponds to the interval (c, b]\n                # x = b - sqrt((1-u) * (b-a) * (b-c))\n                # Handle potential floating point issue if range_cb is zero (c=b)\n                if range_cb == 0:\n                    term = 0.0\n                else:\n                    term = (1 - u_clamped) * range_ab * range_cb\n                x = b - np.sqrt(term)\n            \n            # Round the result to 10 decimal places as required.\n            case_results.append(round(x, 10))\n            \n        all_results.append(case_results)\n\n    # Format the final output string to the exact required format.\n    # e.g., [[x11,x12,...],[x21,...],[x31,...],[x41,...]] with no spaces.\n    # Convert list of lists to string and remove whitespace.\n    output_string = str(all_results).replace(\" \", \"\")\n    \n    print(output_string)\n\nsolve()\n```", "id": "2403851"}, {"introduction": "在掌握了有限区间上的分布后，我们将挑战定义在整个实数轴上的拉普拉斯分布。这个练习 [@problem_id:3244399] 不仅让你处理分段指数形式的PDF，还将引导你思考实际编程中遇到的数值稳定性问题。当均匀随机变量 $U$ 的取值非常接近 $0$ 或 $1$ 时，如何确保采样结果的有效性，是本实践的一个关键学习点。", "problem": "您需要实现逆变换采样，以生成来自拉普拉斯（双指数）分布的独立随机变量，其难度设定在高等本科水平。您的推导和算法必须从概率密度函数和累积分布函数的基本定义出发，并基于一个经过充分验证的事实：即通过逆累积分布函数变换一个均匀分布的随机变量，可以得到目标分布的一个样本。具体来说，您必须基于以下基础：如果 $U$ 是一个在 $(0,1)$ 上均匀分布的连续随机变量，而 $F_X$ 是一个连续随机变量 $X$ 的累积分布函数，那么 $F_X(X)$ 在 $(0,1)$ 上均匀分布；反之，$X = F_X^{-1}(U)$ 的累积分布函数为 $F_X$。您不能假定任何针对拉普拉斯分布的预先推导好的公式；必须从拉普拉斯概率密度函数出发，通过正确的分段积分和求逆来推导它们。\n\n任务:\n- 仅使用上述基本定义和事实，推导位置参数为 $\\mu$、尺度参数为 $b$ 的拉普拉斯（双指数）分布的逆累积分布函数，并完全用 $\\mu$、$b$ 和 $U$ 来表示。\n- 设计并实现一个数值稳定的逆变换采样程序，该程序在给定 $\\mu$、$b$、一个正整数 $n$ 和一个整数随机种子 $\\text{seed}$ 的情况下，生成 $n$ 个来自拉普拉斯分布的独立样本。您必须确保在边界 $0$ 和 $1$ 处的均匀值映射不会产生非有限输出；请解释并实现一种与浮点运算一致、有原则的方法来避免此类边界问题。\n- 对于随机抽样测试用例，计算并返回所生成样本的样本均值、总体方差（即除以 $n$，而非 $n-1$）和样本中位数。\n- 对于确定性映射测试用例，直接在指定的均匀值处评估逆累积分布函数，并返回映射后的值。\n\n约束条件:\n- 使用参数为 $\\mu$ 和 $b$（其中 $b0$）的拉普拉斯概率密度函数。不要使用任何来自外部库的专用分布例程；您的实现必须基于推导出的逆累积分布函数和均匀随机数生成器。\n- 程序应自成一体，无需用户输入，且仅使用Python标准库和指定的数值库。\n- 不涉及角度；不需要角度单位。不涉及物理量；不需要物理单位。\n- 所有输出必须表示为十进制浮点数。\n\n测试套件:\n为以下测试用例提供结果：\n1. 随机生成（正常路径）：$\\mu = 0$, $b = 1$, $n = 100000$, $\\text{seed} = 314159$。\n2. 随机生成（平移且尺度更窄）：$\\mu = 2.5$, $b = 0.5$, $n = 50000$, $\\text{seed} = 271828$。\n3. 随机生成（边缘尺度，极小）：$\\mu = -3$, $b = 10^{-6}$, $n = 3$, $\\text{seed} = 99$。\n4. 确定性映射（逆映射的边界压力测试）：$\\mu = 1$, $b = 2$，在均匀值 $[10^{-12}, 0.5, 1 - 10^{-12}]$ 处进行评估。\n\n答案规格:\n- 对于前三个测试用例，输出一个包含三个浮点数的列表，按 $[\\text{均值}, \\text{方差}, \\text{中位数}]$ 的顺序表示所生成样本的统计量。\n- 对于第四个测试用例，输出一个包含三个浮点数的列表，表示指定均匀输入在逆累积分布函数下的映射值。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result1,result2,result3]$），其中每个 $resultk$ 都符合上述规范。因此，这四个测试用例的聚合格式必须是一个包含四个元素的顶层列表，其中前三个元素是各含三个浮点数的列表，第四个元素是一个包含三个浮点数的列表。", "solution": "使用逆变换采样从拉普拉斯分布生成随机变量是数值方法中的一个适定问题。它要求从第一性原理出发，对逆累积分布函数进行严格推导，然后进行数值上稳健的实现。\n\n### 第一步：拉普拉斯累积分布函数（CDF）的推导\n\n该过程始于位置参数为 $\\mu$、尺度参数为 $b  0$ 的拉普拉斯分布随机变量 $X$ 的概率密度函数（PDF）。其PDF由下式给出：\n$$f_X(x; \\mu, b) = \\frac{1}{2b} \\exp\\left(-\\frac{|x-\\mu|}{b}\\right)$$\n累积分布函数（CDF）$F_X(x) = P(X \\le x)$ 是通过将PDF从 $-\\infty$ 积分到 $x$ 得到的：\n$$F_X(x) = \\int_{-\\infty}^{x} \\frac{1}{2b} \\exp\\left(-\\frac{|t-\\mu|}{b}\\right) dt$$\n由于存在绝对值项 $|t-\\mu|$，该积分必须分段计算。\n\n**情况1：$x \\le \\mu$**\n对于积分范围 $(-\\infty, x]$ 内的任何 $t$，我们有 $t \\le x \\le \\mu$，这意味着 $t-\\mu \\le 0$。因此，$|t-\\mu| = -(t-\\mu) = \\mu-t$。CDF为：\n$$F_X(x) = \\int_{-\\infty}^{x} \\frac{1}{2b} \\exp\\left(-\\frac{\\mu-t}{b}\\right) dt = \\frac{1}{2b} \\int_{-\\infty}^{x} \\exp\\left(\\frac{t-\\mu}{b}\\right) dt$$\n进行积分：\n$$F_X(x) = \\frac{1}{2b} \\left[ b \\exp\\left(\\frac{t-\\mu}{b}\\right) \\right]_{-\\infty}^{x} = \\frac{1}{2} \\left( \\exp\\left(\\frac{x-\\mu}{b}\\right) - \\lim_{t\\to-\\infty} \\exp\\left(\\frac{t-\\mu}{b}\\right) \\right)$$\n$$F_X(x) = \\frac{1}{2} \\exp\\left(\\frac{x-\\mu}{b}\\right)$$\n\n**情况2：$x  \\mu$**\n积分在 $t=\\mu$ 点处分开：\n$$F_X(x) = \\int_{-\\infty}^{\\mu} f_X(t) dt + \\int_{\\mu}^{x} f_X(t) dt$$\n第一项是 $F_X(\\mu)$，可以从情况1的结果中得出：$F_X(\\mu) = \\frac{1}{2} \\exp\\left(\\frac{\\mu-\\mu}{b}\\right) = \\frac{1}{2}$。这是预料之中的，因为该分布关于其中位数 $\\mu$ 对称。\n对于第二项，其中 $t \\in [\\mu, x]$，我们有 $t-\\mu \\ge 0$，所以 $|t-\\mu| = t-\\mu$。\n$$\\int_{\\mu}^{x} \\frac{1}{2b} \\exp\\left(-\\frac{t-\\mu}{b}\\right) dt = \\frac{1}{2b} \\left[ -b \\exp\\left(-\\frac{t-\\mu}{b}\\right) \\right]_{\\mu}^{x}$$\n$$= -\\frac{1}{2} \\left[ \\exp\\left(-\\frac{x-\\mu}{b}\\right) - \\exp\\left(-\\frac{\\mu-\\mu}{b}\\right) \\right] = -\\frac{1}{2} \\left(\\exp\\left(-\\frac{x-\\mu}{b}\\right) - 1\\right) = \\frac{1}{2} \\left(1 - \\exp\\left(-\\frac{x-\\mu}{b}\\right)\\right)$$\n合并 $x  \\mu$ 的两项：\n$$F_X(x) = F_X(\\mu) + \\frac{1}{2} \\left(1 - \\exp\\left(-\\frac{x-\\mu}{b}\\right)\\right) = \\frac{1}{2} + \\frac{1}{2} - \\frac{1}{2} \\exp\\left(-\\frac{x-\\mu}{b}\\right) = 1 - \\frac{1}{2} \\exp\\left(-\\frac{x-\\mu}{b}\\right)$$\n\n完整的分段CDF为：\n$$F_X(x) = \\begin{cases} \\frac{1}{2} \\exp\\left(\\frac{x-\\mu}{b}\\right)  \\text{if } x \\le \\mu \\\\ 1 - \\frac{1}{2} \\exp\\left(-\\frac{x-\\mu}{b}\\right)  \\text{if } x  \\mu \\end{cases}$$\n\n### 第二步：逆CDF（分位数函数）的推导\n\n逆变换采样方法依赖于这样一个事实：如果 $U$ 是一个在 $(0,1)$ 上均匀分布的随机变量，那么 $X = F_X^{-1}(U)$ 就是一个具有CDF $F_X$ 的随机变量。为了求逆CDF，我们令 $u = F_X(x)$（其中 $u \\in (0,1)$），然后解出 $x$。\n\n**情况1：$0  u \\le 0.5$（对应于 $x \\le \\mu$）**\n$$u = \\frac{1}{2} \\exp\\left(\\frac{x-\\mu}{b}\\right)$$\n$$2u = \\exp\\left(\\frac{x-\\mu}{b}\\right)$$\n$$\\ln(2u) = \\frac{x-\\mu}{b}$$\n$$x = \\mu + b \\ln(2u)$$\n\n**情况2：$0.5  u  1$（对应于 $x  \\mu$）**\n$$u = 1 - \\frac{1}{2} \\exp\\left(-\\frac{x-\\mu}{b}\\right)$$\n$$1-u = \\frac{1}{2} \\exp\\left(-\\frac{x-\\mu}{b}\\right)$$\n$$2(1-u) = \\exp\\left(-\\frac{x-\\mu}{b}\\right)$$\n$$\\ln(2(1-u)) = -\\frac{x-\\mu}{b}$$\n$$x = \\mu - b \\ln(2(1-u))$$\n\n完整的分段逆CDF，$x = F_X^{-1}(u)$，为：\n$$F_X^{-1}(u) = \\begin{cases} \\mu + b \\ln(2u)  \\text{if } 0  u \\le 0.5 \\\\ \\mu - b \\ln(2(1-u))  \\text{if } 0.5  u  1 \\end{cases}$$\n\n### 第三步：算法设计和数值稳定性\n\n推导出的逆CDF包含对数项 $\\ln(u)$ 和 $\\ln(1-u)$，它们分别在 $u=0$ 和 $u=1$ 处是奇异的。理论上逆CDF的定义域是严格的开区间 $(0,1)$。然而，数值随机数生成器可能在一个闭合或半闭合的区间（如 $[0,1)$）上运行，有可能产生值 $0$。在 $u=0$ 处直接求值将导致 $\\ln(0)$，这是一个非有限值 $(-\\infty)$，违反了问题对有限输出的要求。\n\n为了创建一个数值稳定的实现，我们必须采用一种有原则的方法来处理这些边界值。对于连续分布，浮点生成器产生精确的 $0.0$ 是一个数值假象。我们将此值解释为代表属于最小可表示正数区间 $[0, \\epsilon_{\\text{min}})$ 的样本，其中 $\\epsilon_{\\text{min}}$ 是给定浮点类型的最小正规格化数。为确保有限输出，我们将任何输入 $u=0$ 映射到 $\\epsilon_{\\text{min}}$。这个正则化步骤保证了对数的参数始终为正，从而正确地产生一个大数量级的有限数，该数代表了分布的尾部行为。`numpy.finfo` 实用工具提供了获取此机器ε的标准方法。测试用例不涉及精确为 $u=1$ 的输入，但类似的正则化方法也同样适用。\n\n算法如下：\n1.  对于给定的测试用例，定义参数 $\\mu$、$b$，对于随机情况，还需定义 $n$ 和 `seed`。\n2.  在 $[0,1)$ 上生成一个包含 $n$ 个均匀随机数 $u_i$ 的数组，或使用提供的确定性值。\n3.  对均匀值进行正则化：任何精确为 $0$ 的 $u_i$ 都被替换为最小的可表示正浮点数。\n4.  使用布尔掩码以向量化的方式应用分段逆CDF公式：\n    -   对于所有 $u_i \\le 0.5$，计算 $x_i = \\mu + b \\ln(2u_i)$。\n    -   对于所有 $u_i  0.5$，计算 $x_i = \\mu - b \\ln(2(1-u_i))$。\n5.  对于随机生成情况，计算所得样本 $x_i$ 的样本均值、总体方差（除以 $n$）和样本中位数。\n6.  对于确定性映射情况，返回计算出的 $x_i$ 值。\n7.  按规定格式化所有结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by deriving and implementing inverse transform sampling\n    for the Laplace distribution, handling all specified test cases.\n    \"\"\"\n\n    def inverse_cdf_laplace(u, mu, b):\n        \"\"\"\n        Calculates samples from a Laplace distribution using the inverse CDF method.\n\n        This function implements the derived piecewise inverse CDF:\n        x = mu + b * log(2u)          if 0  u = 0.5\n        x = mu - b * log(2(1-u))        if 0.5  u  1\n\n        It includes a principled approach to handle boundary values of u to\n        ensure numerically stable, finite outputs.\n\n        Args:\n            u (np.ndarray): Array of uniform random numbers in [0, 1).\n            mu (float): The location parameter of the Laplace distribution.\n            b (float): The scale parameter (b > 0) of the Laplace distribution.\n\n        Returns:\n            np.ndarray: Array of samples from the Laplace(mu, b) distribution.\n        \"\"\"\n        # Copy input to avoid modifying the original array\n        u_reg = np.copy(u).astype(np.float64)\n\n        # The theoretical domain of the inverse CDF is (0,1). Practical RNGs\n        # may produce 0 from the interval [0,1). We regularize such values to\n        # prevent log(0) which results in a non-finite output. A value of 0.0\n        # is mapped to the smallest positive representable float (machine epsilon),\n        # ensuring the logarithm's argument is always positive.\n        tiny = np.finfo(u_reg.dtype).tiny\n        u_reg[u_reg == 0] = tiny\n        \n        # The test cases do not include u=1, but a robust implementation would\n        # also regularize it. e.g., u_reg[u_reg == 1] = 1.0 - tiny\n\n        # Initialize the output array for samples\n        samples = np.zeros_like(u_reg)\n\n        # Create a boolean mask to apply the piecewise function\n        mask_le_half = (u_reg = 0.5)\n        \n        # Branch 1: u = 0.5\n        samples[mask_le_half] = mu + b * np.log(2 * u_reg[mask_le_half])\n\n        # Branch 2: u > 0.5 (using the inverted mask)\n        mask_gt_half = ~mask_le_half\n        samples[mask_gt_half] = mu - b * np.log(2 * (1 - u_reg[mask_gt_half]))\n\n        return samples\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. Random generation (happy path)\n        {'type': 'random', 'mu': 0.0, 'b': 1.0, 'n': 100000, 'seed': 314159},\n        # 2. Random generation (shifted and narrower scale)\n        {'type': 'random', 'mu': 2.5, 'b': 0.5, 'n': 50000, 'seed': 271828},\n        # 3. Random generation (edge scale, extremely small)\n        {'type': 'random', 'mu': -3.0, 'b': 1e-6, 'n': 3, 'seed': 99},\n        # 4. Deterministic mapping (boundary stress test)\n        {'type': 'deterministic', 'mu': 1.0, 'b': 2.0, 'u_values': np.array([1e-12, 0.5, 1 - 1e-12])}\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'random':\n            rng = np.random.default_rng(case['seed'])\n            uniform_samples = rng.uniform(size=case['n'])\n            \n            laplace_samples = inverse_cdf_laplace(uniform_samples, case['mu'], case['b'])\n            \n            # Calculate required statistics\n            sample_mean = np.mean(laplace_samples)\n            # Population variance (ddof=0 is the default for np.var)\n            pop_variance = np.var(laplace_samples)\n            sample_median = np.median(laplace_samples)\n            \n            results.append([sample_mean, pop_variance, sample_median])\n        \n        elif case['type'] == 'deterministic':\n            mapped_values = inverse_cdf_laplace(case['u_values'], case['mu'], case['b'])\n            results.append(mapped_values.tolist())\n\n    # Final print statement in the exact required format.\n    # The format \"[list1,list2,...]\" is achieved by mapping each inner list to\n    # its string representation and then joining with commas.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3244399"}, {"introduction": "最后，我们将理论与实际应用联系起来，学习如何从经验数据中采样。在许多现实场景中，我们没有一个精确的解析表达式来描述数据分布，而是拥有一个由观测数据构成的直方图。本实践 [@problem_id:2403898] 将教你如何基于直方图构建一个分段均匀分布模型，并利用逆变换采样从中生成新的样本，这充分展示了该方法在数据分析和模拟中的强大功能。", "problem": "给定经验数据的直方图摘要，其形式为区间边界和区间频数。假设在每个区间内，其底层的概率密度是均匀的，因此得到的累积分布函数 (CDF) 是分段线性的。请使用逆变换采样的原理，构建一个采样器，将均匀随机数映射为由该直方图所蕴含的分段均匀分布的样本。然后，通过将生成样本的经验统计量与直方图模型所蕴含的相应解析值进行比较，来验证您的采样器。\n\n需要使用的基本原理和定义：\n- 实值随机变量 $X$ 的累积分布函数 $F(x)$ 定义为 $F(x) = \\mathbb{P}(X \\le x)$。\n- 如果 $U$ 在 $[0,1]$ 上均匀分布，且 $F$ 是一个连续且严格递增的 CDF，则 $X = F^{-1}(U)$ 的 CDF 为 $F$（逆变换采样）。对于分段线性的 $F$，其逆函数 $F^{-1}$ 在每个线性段上通过对相应的仿射映射求逆来计算。\n- 对于一个由区间边界 $x_0  x_1  \\dots  x_N$ 和非负频数 $c_0,\\dots,c_{N-1}$（总和 $C = \\sum_{i=0}^{N-1} c_i  0$）表征的直方图，定义区间概率 $p_i = c_i / C$。在区间内分段均匀的假设下，CDF 在每个区间上是线性的：对于 $x \\in [x_i, x_{i+1}]$，\n$$\nF(x) = \\sum_{j=0}^{i-1} p_j \\;+\\; p_i \\cdot \\frac{x - x_i}{x_{i+1} - x_i}.\n$$\n其在概率区间 $u \\in [F(x_i), F(x_{i+1})]$ 上的逆函数为\n$$\nF^{-1}(u) = x_i + (x_{i+1} - x_i)\\,\\frac{u - F(x_i)}{p_i},\n$$\n对于任何满足 $p_i  0$ 的 $i$。\n\n编程任务：\n1. 实现一个函数，在给定区间边界 $\\{x_i\\}_{i=0}^N$ 和频数 $\\{c_i\\}_{i=0}^{N-1}$ 的情况下，构建在边界处的归一化累积概率，即对于 $i=0,\\dots,N$，有 $F(x_i) = \\sum_{j=0}^{i-1} p_j$，其中 $F(x_0)=0$ 且 $F(x_N)=1$。\n2. 实现一个逆变换采样器，该采样器：\n   - 从 $[0,1)$ 上的均匀分布中抽取 $u$。\n   - 找到区间索引 $i$，使得 $F(x_i) \\le u  F(x_{i+1})$。\n   - 返回 $x = x_i + (x_{i+1}-x_i)\\,\\frac{u - F(x_i)}{p_i}$。\n   - 稳健地处理零频数区间。特别是，要确保对于任何连续的零频数区间块，当 $u$ 等于该块上的平坦 CDF 值时，逆映射会选择随后的正质量区间。\n3. 实现以下各项的解析计算：\n   - 分段均匀模型下的期望值：\n     $$\n     \\mathbb{E}[X] = \\sum_{i=0}^{N-1} p_i \\cdot \\frac{x_i + x_{i+1}}{2}.\n     $$\n   - 在任意阈值 $t$ 处的 CDF：\n     $$\n     F(t) = \\begin{cases}\n     0,  t \\le x_0,\\\\\n     1,  t \\ge x_N,\\\\\n     \\sum_{j=0}^{k-1} p_j + p_k \\cdot \\dfrac{t - x_k}{x_{k+1} - x_k},  t \\in [x_k, x_{k+1}) \\text{ for some } k.\n     \\end{cases}\n     $$\n   - 在概率水平 $q \\in [0,1]$ 处的分位数（逆 CDF）：\n     $$\n     F^{-1}(q) = \\begin{cases}\n     x_0,  q \\le 0,\\\\\n     x_N,  q \\ge 1,\\\\\n     x_i + (x_{i+1}-x_i)\\,\\dfrac{q - F(x_i)}{p_i},  q \\in [F(x_i), F(x_{i+1})) \\text{ for some } i \\text{ with } p_i  0.\n     \\end{cases}\n     $$\n4. 实现从生成样本中计算出的经验对应项：\n   - 经验均值 $\\hat{\\mu} = \\dfrac{1}{M}\\sum_{m=1}^M X_m$。\n   - 在阈值 $t$ 处的经验 CDF：$\\hat{F}(t) = \\dfrac{1}{M}\\sum_{m=1}^M \\mathbf{1}\\{X_m \\le t\\}$。\n   - 使用 Hyndman–Fan 类型 7 定义计算在水平 $q$ 处的经验分位数：对于排序后的样本 $X_{(1)} \\le \\dots \\le X_{(M)}$，定义 $h = (M-1)q + 1$，$k = \\lfloor h \\rfloor$，$\\gamma = h - k$，以及\n     $$\n     \\hat{Q}_7(q) = (1-\\gamma)X_{(k)} + \\gamma X_{(k+1)},\n     $$\n     约定当 $q=0$ 时为 $X_{(1)}$，当 $q=1$ 时为 $X_{(M)}$。\n\n测试套件和要求的输出：\n- 对于所有测试，请使用上述的分段均匀模型。\n- 对于每个测试，使用指定的随机种子生成 $M$ 个样本。计算三个绝对误差：\n  - 均值的绝对误差：$|\\hat{\\mu} - \\mathbb{E}[X]|$。\n  - 在指定阈值 $t$ 处的 CDF 的绝对误差：$|\\hat{F}(t) - F(t)|$。\n  - $q$-分位数的绝对误差：$|\\hat{Q}_7(q) - F^{-1}(q)|$。\n- 测试：\n  - 测试 A (常规非均匀区间)：\n    - 区间边界：$[-2.0,-1.0,0.0,1.0,3.0]$。\n    - 频数：$[10,20,40,30]$。\n    - 样本量：$M = 200000$。\n    - 随机种子：$123456789$。\n    - 阈值：$t = 0.5$。\n    - 分位数水平：$q = 0.95$。\n  - 测试 B (存在内部零频数区间)：\n    - 区间边界：$[0.0,1.0,2.0,3.0,4.0,5.0]$。\n    - 频数：$[5,0,15,0,5]$。\n    - 样本量：$M = 100000$。\n    - 随机种子：$2023$。\n    - 阈值：$t = 2.5$。\n    - 分位数水平：$q = 0.8$。\n  - 测试 C (含零的窄区间和宽区间)：\n    - 区间边界：$[-1.0,0.0,0.1,0.5,3.0]$。\n    - 频数：$[0,50,0,50]$。\n    - 样本量：$M = 150000$。\n    - 随机种子：$777$。\n    - 阈值：$t = 0.05$。\n    - 分位数水平：$q = 0.5$。\n- 最终输出格式：\n  - 您的程序应生成单行输出，其中包含一个逗号分隔的列表，按顺序包含九个浮点误差 $[|\\hat{\\mu}_A - \\mathbb{E}_A[X]|,|\\hat{F}_A(t)-F_A(t)|,|\\hat{Q}_{7,A}(q)-F_A^{-1}(q)|,|\\hat{\\mu}_B - \\mathbb{E}_B[X]|,|\\hat{F}_B(t)-F_B(t)|,|\\hat{Q}_{7,B}(q)-F_B^{-1}(q)|,|\\hat{\\mu}_C - \\mathbb{E}_C[X]|,|\\hat{F}_C(t)-F_C(t)|,|\\hat{Q}_{7,C}(q)-F_C^{-1}(q)|]$。\n  - 将报告的每个浮点数四舍五入到 $6$ 位小数。\n  - 列表必须用方括号打印，不含空格，例如：$[0.001000,0.000500,0.002345, \\dots ]$，包含恰好 $9$ 个值，且无附加文本。", "solution": "问题陈述经评估后确定为有效。它具有科学依据，问题提法恰当，并包含唯一可验证解所需的所有必要信息和定义。其基本原理是概率论和计算统计学中的标准内容。任务的规定足够清晰，可以进行明确的实现。因此，我们着手解决该问题。\n\n目标是为由直方图定义的概率分布构建并验证一个逆变换采样器。该模型假设直方图的各个区间上存在一个分段均匀的概率密度函数 (PDF)。\n\n设直方图由一组 $N+1$ 个区间边界 $x_0  x_1  \\dots  x_N$ 和 $N$ 个相应的非负区间频数 $c_0, c_1, \\dots, c_{N-1}$ 定义。观测总数为 $C = \\sum_{i=0}^{N-1} c_i$，且给定该值大于 $0$。\n\n首先，我们对频数进行归一化，以获得区间概率 $p_i = c_i / C$（其中 $i=0, \\dots, N-1$）。该模型假设在每个区间 $[x_i, x_{i+1}]$ 内，概率密度是均匀的。因此，PDF $f(x)$ 是分段常数：\n$$\nf(x) =\n\\begin{cases}\n\\frac{p_i}{x_{i+1} - x_i}  \\text{if } x \\in [x_i, x_{i+1}) \\text{ and } p_i  0 \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n累积分布函数 (CDF) $F(x) = \\mathbb{P}(X \\le x) = \\int_{-\\infty}^{x} f(\\xi) d\\xi$ 是一个连续的分段线性函数。CDF 在每个区间边界 $x_i$ 处的值是所有前面区间的概率之和：\n$$\nF(x_i) = \\sum_{j=0}^{i-1} p_j\n$$\n对于区间 $[x_i, x_{i+1}]$ 内的任何点 $x$，CDF 由线性插值给出：\n$$\nF(x) = F(x_i) + p_i \\cdot \\frac{x - x_i}{x_{i+1} - x_i}\n$$\n请注意，如果一个区间 $i$ 的频数为零（即 $c_i=0$，因此 $p_i=0$），则 CDF 在该区间上是平坦的，即对于所有 $x \\in [x_i, x_{i+1}]$，有 $F(x) = F(x_i)$。\n\n任务的核心是实现逆变换采样方法。该方法依赖于以下性质：如果 $U$ 是在 $[0,1]$ 上均匀分布的随机变量，则 $X = F^{-1}(U)$ 是一个以 $F$ 为 CDF 的随机变量。逆 CDF $F^{-1}(u)$（对于 $u \\in [0,1]$）通过对 $F(x)$ 的表达式求逆得到。对于给定的概率 $u \\in [F(x_i), F(x_{i+1}))$，其对应于一个 $p_i  0$ 的区间 $i$，其逆函数为：\n$$\nF^{-1}(u) = x_i + (x_{i+1} - x_i)\\,\\frac{u - F(x_i)}{p_i}\n$$\n该算法按以下步骤进行：\n1.  **预计算：** 给定区间边界和频数列表，我们首先计算区间概率数组 $\\{p_i\\}_{i=0}^{N-1}$。然后，我们计算在区间边界处的累积概率数组，记为 `cum_probs`，其中 `cum_probs[i]` $= F(x_i)$（对于 $i=0,\\dots,N$）。该数组长度为 $N+1$，其中 `cum_probs[0]`$=0$ 且 `cum_probs[N]`$=1$。\n2.  **采样：** 要生成一组 $M$ 个样本：\n    a. 从均匀分布 $U[0, 1)$ 中抽取 $M$ 个独立的随机数 $\\{u_k\\}_{k=1}^M$。\n    b. 对于每个 $u_k$，确定区间索引 $i$，使得 $F(x_i) \\le u_k  F(x_{i+1})$。这个搜索可以使用二分搜索算法高效地对所有 $u_k$ 进行矢量化操作，例如使用 `numpy.searchsorted(cum_probs, u, side='right')`，它会给出区间边界的索引，从中可以推导出区间索引 $i$。此过程自然地处理了零概率区间，因为搜索会跳过 CDF 的平坦区域。\n    c. 对每个 $u_k$ 使用其已识别的区间索引 $i$ 应用逆 CDF 公式，以计算样本 $x_k = F^{-1}(u_k)$。为了提高效率，此步骤也进行了矢量化处理。\n3.  **解析计算：**\n    - **期望值：** 解析均值 $\\mathbb{E}[X]$ 是每个区间的期望值与其概率加权的总和。对于在 $[x_i, x_{i+1}]$ 上的均匀分布，均值为 $(x_i + x_{i+1})/2$。因此，\n      $$ \\mathbb{E}[X] = \\sum_{i=0}^{N-1} p_i \\cdot \\frac{x_i + x_{i+1}}{2} $$\n    - **在阈值 $t$ 处的 CDF**：要计算 $F(t)$，首先找到区间索引 $k$，使得 $x_k \\le t  x_{k+1}$。然后应用 $F(x)$ 的分段线性公式。对于边界情况 $t \\le x_0$ 和 $t \\ge x_N$，结果分别为 $F(t)=0$ 和 $F(t)=1$。\n    - **在概率 $q$ 处的分位数**：要计算 $F^{-1}(q)$，首先找到区间索引 $i$，使得 $F(x_i) \\le q  F(x_{i+1})$，然后应用逆函数公式。\n4.  **从样本进行的经验计算：**\n    - **经验均值 $\\hat{\\mu}$：** $M$ 个生成样本的算术平均值。\n    - **经验 CDF $\\hat{F}(t)$：** $M$ 个样本中小于或等于阈值 $t$ 的样本所占的比例。\n    - **经验分位数 $\\hat{Q}_7(q)$：** 使用 Hyndman-Fan 类型 7 定义从排序后的样本中计算，这对应于顺序统计量之间的线性插值。这在 `numpy.quantile` 中可用，参数为 `interpolation='linear'`。\n5.  **验证：** 对于问题中定义的每个测试用例，采样器使用指定的随机种子生成 $M$ 个样本。计算均值、在 $t$ 处的 CDF 和在 $q$ 处的分位数的解析值。将这些值与从生成样本中计算出的经验对应值进行比较。解析值和经验值之间的绝对误差是最终结果。\n\n提供的 Python 代码实现了这整个过程。它通过一个 `PiecewiseUniform` 类来封装分布的属性和方法，并用一个主函数 `solve` 来执行指定的测试套件并按要求格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing and validating an inverse transform sampler\n    for a piecewise-uniform distribution defined by a histogram.\n    \"\"\"\n\n    class PiecewiseUniform:\n        \"\"\"\n        Represents a piecewise-uniform probability distribution derived from a histogram.\n        \"\"\"\n        def __init__(self, edges: list[float], counts: list[int]):\n            self.edges = np.array(edges, dtype=np.float64)\n            self.counts = np.array(counts, dtype=np.float64)\n            \n            if len(self.edges) != len(self.counts) + 1:\n                raise ValueError(\"Number of edges must be one more than the number of counts.\")\n            \n            total_counts = np.sum(self.counts)\n            if total_counts == 0:\n                # Based on problem statement C > 0, but good practice to check.\n                # If all counts are zero, probs are ill-defined.\n                # For this problem, we can assume valid inputs.\n                self.probs = np.zeros_like(self.counts)\n            else:\n                self.probs = self.counts / total_counts\n\n            # Cumulative probabilities at bin edges F(x_i)\n            self.cum_probs = np.zeros(len(self.edges), dtype=np.float64)\n            self.cum_probs[1:] = np.cumsum(self.probs)\n\n        def analytical_mean(self) -> float:\n            \"\"\"Computes the analytical expected value.\"\"\"\n            bin_midpoints = (self.edges[:-1] + self.edges[1:]) / 2.0\n            return np.sum(self.probs * bin_midpoints)\n\n        def analytical_cdf(self, t: float) -> float:\n            \"\"\"Computes the analytical CDF at a threshold t.\"\"\"\n            if t = self.edges[0]:\n                return 0.0\n            if t >= self.edges[-1]:\n                return 1.0\n            \n            # Find bin index k such that edges[k] = t  edges[k+1]\n            bin_idx = np.searchsorted(self.edges, t, side='right') - 1\n            \n            x_k = self.edges[bin_idx]\n            x_k_plus_1 = self.edges[bin_idx + 1]\n            p_k = self.probs[bin_idx]\n            F_x_k = self.cum_probs[bin_idx]\n            \n            # Handle case where bin width is zero to avoid division by zero\n            bin_width = x_k_plus_1 - x_k\n            if bin_width == 0:\n                return F_x_k\n            \n            return F_x_k + p_k * (t - x_k) / bin_width\n\n        def analytical_quantile(self, q: float) -> float:\n            \"\"\"Computes the analytical quantile (inverse CDF) at probability q.\"\"\"\n            if q = 0.0:\n                return self.edges[0]\n            if q >= 1.0:\n                return self.edges[-1]\n\n            # Find bin index i such that F(x_i) = q  F(x_{i+1})\n            bin_idx = np.searchsorted(self.cum_probs, q, side='right') - 1\n            \n            # This logic should always find a bin with non-zero probability,\n            # unless q falls in a flat region exactly. In that case, the quantile is\n            # the start of the next bin with positive mass. searchsorted handles this.\n            \n            F_x_i = self.cum_probs[bin_idx]\n            p_i = self.probs[bin_idx]\n\n            if p_i == 0:\n                # If q falls exactly on a cumulative probability level that starts a\n                # sequence of zero-count bins, the quantile is the edge of the next\n                # non-zero bin. This is what np.searchsorted finds.\n                return self.edges[bin_idx+1]\n\n            x_i = self.edges[bin_idx]\n            x_i_plus_1 = self.edges[bin_idx + 1]\n            \n            return x_i + (x_i_plus_1 - x_i) * (q - F_x_i) / p_i\n\n        def sample(self, M: int, seed: int) -> np.ndarray:\n            \"\"\"Generates M samples using inverse transform sampling.\"\"\"\n            rng = np.random.default_rng(seed)\n            u_samples = rng.uniform(0.0, 1.0, M)\n            \n            # Find bin indices for all uniform samples\n            bin_indices = np.searchsorted(self.cum_probs, u_samples, side='right') - 1\n            \n            # Fetch corresponding parameters for vectorization\n            x_i = self.edges[bin_indices]\n            x_i_plus_1 = self.edges[bin_indices + 1]\n            cum_prob_i = self.cum_probs[bin_indices]\n            prob_i = self.probs[bin_indices]\n\n            # The formula is undefined for prob_i = 0.\n            # We filter to avoid division by zero.\n            # `searchsorted` should prevent selection of bins with p=0 unless u falls\n            # exactly on a boundary, but u is from a continuous distribution.\n            # A failsafe is to only compute for prob_i > 0\n            samples = np.zeros_like(u_samples)\n            \n            # Mask for bins with positive probability\n            pos_prob_mask = prob_i > 0\n            \n            # Calculate samples for bins with positive probability\n            samples[pos_prob_mask] = x_i[pos_prob_mask] + \\\n                (x_i_plus_1[pos_prob_mask] - x_i[pos_prob_mask]) * \\\n                (u_samples[pos_prob_mask] - cum_prob_i[pos_prob_mask]) / prob_i[pos_prob_mask]\n\n            # For any bins with prob_i == 0 (should not happen with U[0,1) and searchsorted)\n            # the sample would be the left edge of the bin.\n            # The quantile for a flat CDF region is typically defined as the infimum of the set of x\n            # that satisfy F(x) >= q, which corresponds to the start of the next bin with mass.\n            # Our `searchsorted` logic already handles this correctly.\n            # Any u that falls into such a region gets assigned to the next bin.\n            # So, the mask is almost a theoretical precaution.\n\n            return samples\n\n    test_cases = [\n        {\n            \"name\": \"Test A\",\n            \"edges\": [-2.0, -1.0, 0.0, 1.0, 3.0],\n            \"counts\": [10, 20, 40, 30],\n            \"M\": 200000,\n            \"seed\": 123456789,\n            \"t\": 0.5,\n            \"q\": 0.95\n        },\n        {\n            \"name\": \"Test B\",\n            \"edges\": [0.0, 1.0, 2.0, 3.0, 4.0, 5.0],\n            \"counts\": [5, 0, 15, 0, 5],\n            \"M\": 100000,\n            \"seed\": 2023,\n            \"t\": 2.5,\n            \"q\": 0.8\n        },\n        {\n            \"name\": \"Test C\",\n            \"edges\": [-1.0, 0.0, 0.1, 0.5, 3.0],\n            \"counts\": [0, 50, 0, 50],\n            \"M\": 150000,\n            \"seed\": 777,\n            \"t\": 0.05,\n            \"q\": 0.5\n        }\n    ]\n\n    all_errors = []\n\n    for case in test_cases:\n        dist = PiecewiseUniform(case[\"edges\"], case[\"counts\"])\n        \n        # Generate samples\n        samples = dist.sample(case[\"M\"], case[\"seed\"])\n        \n        # Analytical values\n        ana_mean = dist.analytical_mean()\n        ana_cdf = dist.analytical_cdf(case[\"t\"])\n        ana_quantile = dist.analytical_quantile(case[\"q\"])\n        \n        # Empirical values\n        emp_mean = np.mean(samples)\n        emp_cdf = np.sum(samples = case[\"t\"]) / case[\"M\"]\n        emp_quantile = np.quantile(samples, case[\"q\"], method='linear')\n        \n        # Errors\n        err_mean = abs(emp_mean - ana_mean)\n        err_cdf = abs(emp_cdf - ana_cdf)\n        err_quantile = abs(emp_quantile - ana_quantile)\n        \n        all_errors.extend([err_mean, err_cdf, err_quantile])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{e:.6f}' for e in all_errors)}]\")\n\nsolve()\n```", "id": "2403898"}]}