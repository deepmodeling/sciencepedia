{"hands_on_practices": [{"introduction": "马尔可夫链的核心思想是利用当前状态和固定的转移概率来预测未来。这个练习将通过一个常见的电子游戏场景，让你亲手计算一个非玩家角色（NPC）在几个时间步后的状态概率，从而掌握马尔可夫链状态演化的基本计算方法。[@problem_id:1639029]", "problem": "一位工程师正在为一款视频游戏编写一个非玩家角色（NPC）守卫的行为程序。该NPC的状态以离散的时间步长（或称“更新周期”）进行更新。该NPC可以处于三种状态之一：'巡逻'(Patrol)、'警戒'(Alert)或'攻击'(Attack)。这些状态之间的转换是概率性的，并且仅取决于当前状态。\n\n- 如果NPC处于'巡逻'状态，它会沿着预设的路线行进。在任何给定的更新周期中，它有80%的概率保持在'巡逻'状态，有20%的概率听到可疑声音并转换到'警戒'状态。它不能直接从'巡逻'状态转换到'攻击'状态。\n\n- 如果NPC处于'警戒'状态，它会主动调查干扰。在任何给定的更新周期中，它有30%的概率一无所获并返回'巡逻'状态，有40%的概率继续调查并保持在'警戒'状态，还有30%的概率发现玩家并转换到'攻击'状态。\n\n- 如果NPC处于'攻击'状态，它正与玩家进行战斗。在任何给定的更新周期中，它有10%的概率跟丢玩家并返回'巡逻'状态。否则，它将保持在'攻击'状态。它不能从'攻击'状态转换回'警戒'状态。\n\n该NPC被初始化并在其第一个更新周期开始时处于'巡逻'状态。在第三个更新周期结束时，该NPC处于'攻击'状态的概率是多少？将你的最终答案四舍五入到四位有效数字。", "solution": "将NPC的状态建模为一个时间齐次马尔可夫链，其状态按“巡逻”(Patrol)、“警戒”(Alert)、“攻击”(Attack)的顺序排列为 $[P, A, T]$。一步转移矩阵 $M$ 为\n$$\nM=\\begin{pmatrix}\n0.8 & 0.2 & 0 \\\\\n0.3 & 0.4 & 0.3 \\\\\n0.1 & 0 & 0.9\n\\end{pmatrix}.\n$$\n设行向量 $p_{n}$ 表示第 $n$ 个更新周期结束时的状态分布。状态的演变由马尔可夫性质和矩阵乘法给出：\n$$\np_{n+1}=p_{n}M.\n$$\nNPC以“巡逻”状态开始，因此在第一个更新周期之前 $p_{0}=(1,0,0)$。第一个更新周期后，\n$$\np_{1}=p_{0}M=(1,0,0)M=(0.8,\\,0.2,\\,0).\n$$\n第二个更新周期后，\n$$\np_{2}=p_{1}M=(0.8,\\,0.2,\\,0)M,\n$$\n其分量为\n$$\n\\begin{aligned}\np_{2}(P)&=0.8\\cdot 0.8+0.2\\cdot 0.3+0\\cdot 0.1=0.64+0.06=0.70,\\\\\np_{2}(A)&=0.8\\cdot 0.2+0.2\\cdot 0.4+0\\cdot 0=0.16+0.08=0.24,\\\\\np_{2}(T)&=0.8\\cdot 0+0.2\\cdot 0.3+0\\cdot 0.9=0.06.\n\\end{aligned}\n$$\n第三个更新周期后，\n$$\np_{3}=p_{2}M,\n$$\n根据关于当前状态的全概率公式，处于“攻击”状态的概率为\n$$\np_{3}(T)=p_{2}(P)\\cdot 0+p_{2}(A)\\cdot 0.3+p_{2}(T)\\cdot 0.9=0.24\\cdot 0.3+0.06\\cdot 0.9=0.072+0.054=0.126.\n$$\n四舍五入到四位有效数字，结果是 $0.1260$。", "answer": "$$\\boxed{0.1260}$$", "id": "1639029"}, {"introduction": "除了短期预测，马尔可夫链在分析系统长期稳定行为方面也极为强大。本练习将探讨一个网站的用户浏览模型，引导你求解该系统的稳态分布（stationary distribution），即用户在长时间浏览后停留在每个页面的概率。理解稳态是分析许多现实世界系统（如人口流动、市场份额）平衡状态的关键。[@problem_id:1639030]", "problem": "一个用于描述用户在小型商业网站上导航的简化模型由一个离散时间马尔可夫链构成。该网站由三个不同的页面组成：主页（状态 1）、博客页面（状态 2）和联系页面（状态 3）。浏览行为由以下转移概率建模：\n\n- 位于主页（状态 1）的用户将以概率 $p_1$ 导航到博客页面（状态 2），或以概率 $1-p_1$ 导航到联系页面（状态 3）。\n- 位于博客页面（状态 2）的用户将以概率 $p_2$ 返回主页（状态 1），以概率 $p_3$ 导航到联系页面（状态 3），或以剩余的概率停留在博客页面。\n- 位于联系页面（状态 3）的用户将总是返回主页（状态 1）。\n\n所有参数 $p_1, p_2, p_3$ 均为区间 $(0, 1)$ 内的常数，且已知 $p_2 + p_3 < 1$。这组条件确保了该马尔可夫链是遍历的，这意味着它有唯一的平稳分布。\n\n假设用户已经浏览该网站很长时间，该过程达到了一个平稳状态。确定平稳分布 $\\pi = (\\pi_1, \\pi_2, \\pi_3)$，其中 $\\pi_i$ 是长期来看在页面 $i$ 上找到用户的概率。将你的答案表示为以参数 $p_1$、$p_2$ 和 $p_3$ 表示的行向量。", "solution": "令转移矩阵为 $P$，其中状态按主页（1）、博客（2）、联系（3）的顺序排列，则\n$$\nP=\\begin{pmatrix}\n0 & p_{1} & 1-p_{1} \\\\\np_{2} & 1-p_{2}-p_{3} & p_{3} \\\\\n1 & 0 & 0\n\\end{pmatrix}.\n$$\n平稳分布 $\\pi=(\\pi_{1},\\pi_{2},\\pi_{3})$ 满足 $\\pi=\\pi P$ 和 $\\pi_{1}+\\pi_{2}+\\pi_{3}=1$。按分量写出平稳性方程，得到\n$$\n\\pi_{1}=p_{2}\\pi_{2}+\\pi_{3},\\quad\n\\pi_{2}=p_{1}\\pi_{1}+(1-p_{2}-p_{3})\\pi_{2},\\quad\n\\pi_{3}=(1-p_{1})\\pi_{1}+p_{3}\\pi_{2}.\n$$\n由第二个方程可得，\n$$\n(p_{2}+p_{3})\\pi_{2}=p_{1}\\pi_{1}\\quad\\Rightarrow\\quad \\pi_{2}=\\frac{p_{1}}{p_{2}+p_{3}}\\pi_{1}.\n$$\n将此结果代入第三个方程可得\n$$\n\\pi_{3}=(1-p_{1})\\pi_{1}+p_{3}\\cdot\\frac{p_{1}}{p_{2}+p_{3}}\\pi_{1}\n=\\frac{(1-p_{1})p_{2}+p_{3}}{p_{2}+p_{3}}\\pi_{1}.\n$$\n应用归一化条件：\n$$\n\\pi_{1}+\\pi_{2}+\\pi_{3}\n=\\pi_{1}\\left[1+\\frac{p_{1}}{p_{2}+p_{3}}+\\frac{(1-p_{1})p_{2}+p_{3}}{p_{2}+p_{3}}\\right]\n=1.\n$$\n合并方括号中的项，可解得\n$$\n\\pi_{1}=\\frac{p_{2}+p_{3}}{p_{1}+2p_{2}+2p_{3}-p_{1}p_{2}}.\n$$\n因此，\n$$\n\\pi_{2}=\\frac{p_{1}}{p_{2}+p_{3}}\\pi_{1}=\\frac{p_{1}}{p_{1}+2p_{2}+2p_{3}-p_{1}p_{2}},\\quad\n\\pi_{3}=\\frac{(1-p_{1})p_{2}+p_{3}}{p_{2}+p_{3}}\\pi_{1}=\\frac{(1-p_{1})p_{2}+p_{3}}{p_{1}+2p_{2}+2p_{3}-p_{1}p_{2}}.\n$$\n因此，作为行向量的平稳分布为\n$$\n\\left(\\frac{p_{2}+p_{3}}{p_{1}+2p_{2}+2p_{3}-p_{1}p_{2}},\\ \\frac{p_{1}}{p_{1}+2p_{2}+2p_{3}-p_{1}p_{2}},\\ \\frac{(1-p_{1})p_{2}+p_{3}}{p_{1}+2p_{2}+2p_{3}-p_{1}p_{2}}\\right).\n$$", "answer": "$$\\boxed{\\begin{pmatrix}\\frac{p_{2}+p_{3}}{p_{1}+2p_{2}+2p_{3}-p_{1}p_{2}} & \\frac{p_{1}}{p_{1}+2p_{2}+2p_{3}-p_{1}p_{2}} & \\frac{(1-p_{1})p_{2}+p_{3}}{p_{1}+2p_{2}+2p_{3}-p_{1}p_{2}}\\end{pmatrix}}$$", "id": "1639030"}, {"introduction": "将理论付诸实践是计算科学的精髓。这个综合性练习要求你不仅要分析一个给定的系统（学生课堂专注度模型），还要通过编程实现核心算法，以评估和比较不同“干预”措施的效果。通过这个练习，你将学会如何利用马尔可夫链模型进行量化决策，找到优化系统性能的最佳策略。[@problem_id:3158351]", "problem": "考虑一个离散时间马尔可夫链 (DTMC)，其有限状态空间为 $\\mathcal{S} = \\{\\text{Attentive}, \\text{Distracted}, \\text{Absent}\\}$，分别索引为 $0, 1, 2$。设 $P$ 为状态转移矩阵，其中 $P_{ij}$ 是从状态 $i$ 转移到状态 $j$ 的单步转移概率。设 $\\pi_0$ 为一个表示为行向量的初始状态分布，设 $H$ 为一个正整数，代表要评估的时间步数（视界）。我们将在视界 $H$ 内，过程处于“专注”(Attentive) 状态的期望时间步数定义为在每个时间步处于“专注”状态的概率之和。\n\n一个干预被建模为对 $P$ 的修改，通过在指定行内将一个非负量 $\\delta$ 的概率质量从源列转移到目标列，同时保持行的随机性。这表示为一个四元组 $(r, s, t, \\delta)$，意味着：在第 $r$ 行，将 $P_{r s}$ 减去 $\\delta$（必要时以可用的 $P_{r s}$ 为上限），并将 $P_{r t}$ 增加相同的 $\\delta$。对于一个给定的干预，可以顺序应用多个此类转移。所有索引都是从0开始的。修改后，任何微小的数值偏差都应被校正，以确保每行之和为1。\n\n对于每个测试用例，你的任务是：\n1. 使用基线矩阵 $P$ 和初始分布 $\\pi_0$，计算在视界 $H$ 内“专注”时间步的期望数量。\n2. 对于一组给定的候选干预，选择能够最大化第1项中期望数量的单个干预。若出现平局，则选择具有更长的长期“专注”比例（在第3项中定义）的干预来打破平局；如果仍然平局，则选择索引最小的干预。\n3. 为基线 $P$ 和所选干预计算长期“专注”比例。长期比例是满足 $\\pi_\\infty P = \\pi_\\infty$ 和 $\\sum_i (\\pi_\\infty)_i = 1$ 的平稳分布 $\\pi_\\infty$ 中的“专注”状态分量。\n\n您必须使用马尔可夫链的基本定义和期望的线性性质来实现此功能。不允许使用任何启发式捷径。所有答案都必须以实数形式返回，不带百分号；此问题不涉及角度。最终输出必须是单行，包含一个每个测试用例结果的列表，其中每个测试用例的结果是一个格式为 $[E_{\\text{base}}, E_{\\text{best}}, \\pi_{\\infty,\\text{att}}^{\\text{base}}, \\pi_{\\infty,\\text{att}}^{\\text{best}}, \\text{best\\_index}]$ 的列表。将所有浮点值四舍五入到6位小数。最后一行必须严格遵循此列表格式，不得有任何附加文本。\n\n使用以下测试套件。对于每个测试用例，状态排序为 $[0=\\text{Attentive}, 1=\\text{Distracted}, 2=\\text{Absent}]$。\n\n测试用例 1 (一般课堂动态):\n- $P = \\begin{bmatrix} 0.6  0.3  0.1 \\\\ 0.4  0.4  0.2 \\\\ 0.2  0.3  0.5 \\end{bmatrix}$\n- $\\pi_0 = \\begin{bmatrix} 1.0  0.0  0.0 \\end{bmatrix}$\n- $H = 10$\n- 候选干预:\n  - 索引 $0$: $(1,1,0,0.1)$\n  - 索引 $1$: $(2,2,0,0.1)$\n  - 索引 $2$: $(0,2,0,0.05)$ 和 $(0,1,0,0.05)$\n\n测试用例 2 (从分心状态开始的近专注稳定性):\n- $P = \\begin{bmatrix} 0.95  0.05  0.0 \\\\ 0.7  0.3  0.0 \\\\ 0.3  0.2  0.5 \\end{bmatrix}$\n- $\\pi_0 = \\begin{bmatrix} 0.0  1.0  0.0 \\end{bmatrix}$\n- $H = 5$\n- 候选干预:\n  - 索引 $0$: $(1,1,0,0.15)$\n  - 索引 $1$: $(2,2,0,0.2)$\n  - 索引 $2$: $(0,1,0,0.04)$\n\n测试用例 3 (基线中缺席状态为吸收态):\n- $P = \\begin{bmatrix} 0.5  0.4  0.1 \\\\ 0.3  0.3  0.4 \\\\ 0.0  0.0  1.0 \\end{bmatrix}$\n- $\\pi_0 = \\begin{bmatrix} 0.5  0.5  0.0 \\end{bmatrix}$\n- $H = 8$\n- 候选干预:\n  - 索引 $0$: $(1,2,0,0.2)$\n  - 索引 $1$: $(0,2,0,0.1)$\n  - 索引 $2$: $(2,2,0,0.05)$\n\n测试用例 4 (短视界，混合初始状态):\n- $P = \\begin{bmatrix} 0.7  0.2  0.1 \\\\ 0.2  0.7  0.1 \\\\ 0.1  0.2  0.7 \\end{bmatrix}$\n- $\\pi_0 = \\begin{bmatrix} \\frac{1}{3}  \\frac{1}{3}  \\frac{1}{3} \\end{bmatrix}$\n- $H = 1$\n- 候选干预:\n  - 索引 $0$: $(0,1,0,0.1)$\n  - 索引 $1$: $(1,2,0,0.1)$\n  - 索引 $2$: $(2,2,0,0.2)$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表，每个元素对应一个测试用例，并且每个这样的元素本身就是一个逗号分隔的列表 $[E_{\\text{base}}, E_{\\text{best}}, \\pi_{\\infty,\\text{att}}^{\\text{base}}, \\pi_{\\infty,\\text{att}}^{\\text{best}}, \\text{best\\_index}]$，浮点值四舍五入到6位小数。", "solution": "用户需要一个涉及离散时间马尔可夫链 (DTMC) 问题的解决方案。我将首先验证问题陈述，如果有效，则提供一个合理的解决方案。\n\n### 步骤1：提取已知条件\n- **模型**：一个离散时间马尔可夫链 (DTMC)，其状态空间为 $\\mathcal{S} = \\{\\text{Attentive}, \\text{Distracted}, \\text{Absent}\\}$，索引为 $\\{0, 1, 2\\}$。\n- **参数**：一个状态转移矩阵 $P$，一个初始分布行向量 $\\pi_0$，以及一个正整数视界 $H$。\n- **关注指标**：在视界 $H$ 内处于“专注”状态的期望时间步数，定义为在每个时间步处于“专注”状态的概率之和。\n- **干预**：对 $P$ 的修改，由四元组 $(r, s, t, \\delta)$ 定义，其中概率质量 $\\delta$ 在第 $r$ 行从 $P_{rs}$ 转移到 $P_{rt}$。该转移以可用的概率 $P_{rs}$ 为上限。修改后，行将重新归一化以确保和为1。\n- **任务**：\n  1.  计算基线 $P$ 的“专注”步数期望值 ($E_{\\text{base}}$)。\n  2.  从一组候选干预中选择最佳干预，该干预可最大化此期望值。平局首先按长期“专注”比例打破，然后按最小的干预索引打破。\n  3.  为基线（$\\pi_{\\infty,\\text{att}}^{\\text{base}}$）和最佳干预矩阵（$\\pi_{\\infty,\\text{att}}^{\\text{best}}$）计算长期“专注”比例。这是满足 $\\pi_\\infty P = \\pi_\\infty$ 的平稳分布 $\\pi_\\infty$ 的“专注”状态分量。\n- **输出**：对于每个测试用例，一个列表 $[E_{\\text{base}}, E_{\\text{best}}, \\pi_{\\infty,\\text{att}}^{\\text{base}}, \\pi_{\\infty,\\text{att}}^{\\text{best}}, \\text{best\\_index}]$，所有浮点值四舍五入到6位小数。\n- **测试用例**：提供了四个测试用例，包含 $P$、$\\pi_0$、 $H$ 和候选干预的具体值。\n\n### 步骤2：使用提取的已知条件进行验证\n1.  **科学性（关键）**：该问题植根于 DTMC 的标准理论。转移矩阵、状态随时间分布、期望值和平稳分布等概念是该领域的基础。该问题在科学上是合理的。\n2.  **良构性**：问题定义明确。目标是定量的、清晰的。期望的度量标准和选择最佳干预的标准，包括打破平局的规则，都得到了明确的规定，确保可以确定唯一的解决方案。\n3.  **客观性（关键）**：问题陈述使用精确、正式的数学语言，没有任何主观性或歧义。\n4.  **完整性和一致性**：提供了每个测试用例所需的所有数据（$P, \\pi_0, H$ 和干预措施）。定义与马尔可夫链的标准文献一致。提供的转移矩阵是有效的随机矩阵（行和为1）。\n\n### 步骤3：结论与行动\n问题是**有效的**。我将着手设计并实现一个解决方案。\n\n### 解决方案设计\n\n该解决方案将构建为三个核心计算函数，并应用于每个测试用例。\n\n**1. “专注”时间步的期望数量**\n设 $\\pi_k$ 为时间步 $k$ 的状态分布。它是一个行向量，其中 $(\\pi_k)_j = P(X_k = j)$。分布的演化由 $\\pi_k = \\pi_{k-1} P = \\pi_0 P^k$ 给出。\n问题将在视界 $H$ 内的“专注”步数的期望值定义为在每个时间步处于“专注”状态（状态0）的概率之和。假设时间步 $k \\in \\{0, 1, \\dots, H-1\\}$，则为：\n$$E_{\\text{att}} = \\sum_{k=0}^{H-1} P(X_k = 0) = \\sum_{k=0}^{H-1} (\\pi_k)_0 = \\sum_{k=0}^{H-1} (\\pi_0 P^k)_0$$\n这可以通过迭代计算：初始化 $\\pi_{\\text{current}} = \\pi_0$ 和一个运行总和。在一个循环 $H$ 步中，将 $(\\pi_{\\text{current}})_0$ 加到总和中，并更新 $\\pi_{\\text{current}} \\leftarrow \\pi_{\\text{current}} P$。\n\n**2. 平稳分布与长期比例**\n平稳分布 $\\pi_\\infty$ 是在转移矩阵 $P$ 下保持不变的概率分布，即 $\\pi_\\infty P = \\pi_\\infty$。这可以重写为一个齐次线性方程组：\n$$\\pi_\\infty (P - I) = \\mathbf{0}$$\n其中 $I$ 是单位矩阵，$\\mathbf{0}$ 是零向量。为了获得唯一解，我们添加约束条件，即 $\\pi_\\infty$ 的元素之和必须为1：$\\sum_i (\\pi_\\infty)_i = 1$。\n该系统可以使用标准线性代数求解。对等式进行转置得到 $(P^T - I^T)\\pi_\\infty^T = \\mathbf{0}^T$。我们可以构造一个矩阵 $A = P^T - I$，将其中的一行（例如最后一行）替换为全为1的行以强制执行求和约束，并构造一个对应的右侧向量 $\\mathbf{b}$（例如 $[0, 0, \\dots, 1]^T$）。然后可以求解系统 $A \\pi_\\infty^T = \\mathbf{b}$ 以得到 $\\pi_\\infty^T$。长期“专注”比例就是第一个分量 $(\\pi_\\infty)_0$。此方法对不可约链和具有瞬态导致吸收态的可约链都有效，如测试用例所示。\n\n**3. 干预的应用与选择**\n一个干预由一个或多个转移 $(r, s, t, \\delta)$ 组成。对于每次转移，概率质量在第 $r$ 行内移动。移动的质量量 $\\Delta$ 是 $\\min(\\delta, P_{rs})$。矩阵更新为 $P'_{rs} = P_{rs} - \\Delta$ 和 $P'_{rt} = P_{rt} + \\Delta$。在应用了为候选干预规定的所有转移后，必须对修改后的行进行重新归一化，以确保它们的和为1。\n\n对于每个测试用例，总体流程如下：\n1.  使用基线矩阵 $P$ 计算 $E_{\\text{base}}$ 和 $\\pi_{\\infty,\\text{att}}^{\\text{base}}$。\n2.  对于每个候选干预（索引为 $0, 1, \\dots$）：\n    a. 将指定的转移应用于 $P$ 的副本以创建新矩阵 $P_{\\text{new}}$。\n    b. 使用 $P_{\\text{new}}$ 计算 $E_{\\text{new}}$ 和 $\\pi_{\\infty,\\text{att}}^{\\text{new}}$。\n    c. 将这些结果与干预索引一起存储。\n3.  根据指定标准比较所有候选者的结果：\n    a. 主要标准：最大化期望的“专注”步数 $E$。\n    b. 次要平局打破标准：最大化长期“专注”比例 $\\pi_{\\infty,\\text{att}}$。\n    c. 第三平局打破标准：选择最小的干预索引。\n4.  这可以通过将候选结果按 $E$ 降序、然后按 $\\pi_{\\infty,\\text{att}}$ 降序、最后按索引升序排序来有效实现。排序后的第一项即为最佳干预。\n5.  提取最佳干预的统计数据（$E_{\\text{best}}, \\pi_{\\infty,\\text{att}}^{\\text{best}}, \\text{best\\_index}$）。\n6.  组装所需的五个值并按指定格式进行格式化。对所有测试用例重复此过程。", "answer": "```python\nimport numpy as np\n\ndef apply_interventions(p_matrix, interventions):\n    \"\"\"Applies a list of sequential interventions to a transition matrix.\"\"\"\n    p_new = p_matrix.copy()\n    modified_rows = set()\n    for r, s, t, delta in interventions:\n        if r < 0 or r >= p_new.shape[0] or s < 0 or s >= p_new.shape[1] or t < 0 or t >= p_new.shape[1]:\n            continue # Invalid index\n        \n        actual_delta = min(delta, p_new[r, s])\n        p_new[r, s] -= actual_delta\n        p_new[r, t] += actual_delta\n        modified_rows.add(r)\n    \n    # Re-normalize modified rows to correct for any floating point deviations\n    for r in modified_rows:\n        row_sum = np.sum(p_new[r, :])\n        if row_sum > 0:\n            p_new[r, :] /= row_sum\n    return p_new\n\ndef calculate_expected_attentive_steps(p_matrix, pi0, h):\n    \"\"\"Calculates the expected number of attentive steps over a horizon H.\"\"\"\n    pi_current = pi0.copy()\n    expected_steps = 0.0\n    for _ in range(h):\n        # The probability of being in the attentive state (index 0) at the current step\n        expected_steps += pi_current[0, 0]\n        # Evolve the distribution to the next step\n        pi_current = pi_current @ p_matrix\n    return expected_steps\n\ndef calculate_stationary_distribution(p_matrix):\n    \"\"\"Calculates the stationary distribution of a transition matrix P.\"\"\"\n    n_states = p_matrix.shape[0]\n    # We solve the system pi * (P - I) = 0 with constraint sum(pi) = 1.\n    # This is equivalent to (P^T - I^T) * pi^T = 0^T.\n    A = p_matrix.T - np.eye(n_states)\n    \n    # Replace the last row with the constraint sum(pi) = 1\n    A[-1, :] = 1.0\n    \n    # The right-hand side vector for the linear system\n    b = np.zeros(n_states)\n    b[-1] = 1.0\n    \n    # Solve A * pi^T = b for pi^T\n    try:\n        pi_T = np.linalg.solve(A, b)\n        return pi_T.T # Return as a row vector\n    except np.linalg.LinAlgError:\n        # Fallback for singular matrices if standard solve fails\n        pi_T, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n        return pi_T.T\n\ndef solve_case(p_matrix, pi0, h, candidate_interventions):\n    \"\"\"Solves a single test case.\"\"\"\n    # 1. Baseline calculations\n    e_base = calculate_expected_attentive_steps(p_matrix, pi0, h)\n    pi_inf_base = calculate_stationary_distribution(p_matrix)\n    pi_inf_att_base = pi_inf_base[0]\n\n    # 2. Evaluate candidate interventions\n    candidate_results = []\n    # Use sorted items to ensure consistent processing order\n    for index, intervention_spec in sorted(candidate_interventions.items()):\n        p_candidate = apply_interventions(p_matrix, intervention_spec)\n        e_candidate = calculate_expected_attentive_steps(p_candidate, pi0, h)\n        pi_inf_candidate = calculate_stationary_distribution(p_candidate)\n        pi_inf_att_candidate = pi_inf_candidate[0]\n        \n        candidate_results.append({\n            'index': index,\n            'E': e_candidate,\n            'pi_inf_att': pi_inf_att_candidate,\n        })\n    \n    # 3. Sort to find the best intervention based on the specified criteria\n    # Primary: Maximize E (desc). Secondary: Maximize pi_inf_att (desc). Tertiary: Smallest index (asc).\n    # Sorting by -index with reverse=True achieves ascending order for the index tie-breaker.\n    best_intervention_stats = sorted(\n        candidate_results, \n        key=lambda x: (x['E'], x['pi_inf_att'], -x['index']), \n        reverse=True\n    )[0]\n    \n    e_best = best_intervention_stats['E']\n    pi_inf_att_best = best_intervention_stats['pi_inf_att']\n    best_index = best_intervention_stats['index']\n    \n    return [e_base, e_best, pi_inf_att_base, pi_inf_att_best, best_index]\n\ndef solve():\n    \"\"\"Main function to run all test cases and print the final result.\"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            'P': np.array([[0.6, 0.3, 0.1], [0.4, 0.4, 0.2], [0.2, 0.3, 0.5]]),\n            'pi0': np.array([[1.0, 0.0, 0.0]]),\n            'H': 10,\n            'interventions': {\n                0: [(1, 1, 0, 0.1)],\n                1: [(2, 2, 0, 0.1)],\n                2: [(0, 2, 0, 0.05), (0, 1, 0, 0.05)]\n            }\n        },\n        # Test case 2\n        {\n            'P': np.array([[0.95, 0.05, 0.0], [0.7, 0.3, 0.0], [0.3, 0.2, 0.5]]),\n            'pi0': np.array([[0.0, 1.0, 0.0]]),\n            'H': 5,\n            'interventions': {\n                0: [(1, 1, 0, 0.15)],\n                1: [(2, 2, 0, 0.2)],\n                2: [(0, 1, 0, 0.04)]\n            }\n        },\n        # Test case 3\n        {\n            'P': np.array([[0.5, 0.4, 0.1], [0.3, 0.3, 0.4], [0.0, 0.0, 1.0]]),\n            'pi0': np.array([[0.5, 0.5, 0.0]]),\n            'H': 8,\n            'interventions': {\n                0: [(1, 2, 0, 0.2)],\n                1: [(0, 2, 0, 0.1)],\n                2: [(2, 2, 0, 0.05)]\n            }\n        },\n        # Test case 4\n        {\n            'P': np.array([[0.7, 0.2, 0.1], [0.2, 0.7, 0.1], [0.1, 0.2, 0.7]]),\n            'pi0': np.array([[1/3, 1/3, 1/3]]),\n            'H': 1,\n            'interventions': {\n                0: [(0, 1, 0, 0.1)],\n                1: [(1, 2, 0, 0.1)],\n                2: [(2, 2, 0, 0.2)]\n            }\n        }\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        result = solve_case(case['P'], case['pi0'], case['H'], case['interventions'])\n        # Format the result list into the required string format\n        r_str = f\"[{result[0]:.6f},{result[1]:.6f},{result[2]:.6f},{result[3]:.6f},{int(result[4])}]\"\n        all_results_str.append(r_str)\n\n    # Combine all case results into a single line string representation of a list of lists.\n    final_output = f\"[{','.join(all_results_str)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3158351"}]}