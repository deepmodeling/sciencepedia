{"hands_on_practices": [{"introduction": "来自蒙特卡洛模拟等计算科学实践的数据通常是时间相关的，这使得标准误差的朴素估计产生误导性结果。本练习将指导您生成一个合成的时间相关数据序列，模拟扩散蒙特卡洛计算中的能量轨迹，并实现分块方法来获得一个无偏的误差估计 [@problem_id:2885597]。通过将分块误差与忽略相关性的朴素误差进行比较，您将亲身体会到正确处理时间序列数据的必要性。", "problem": "考虑量子化学中固定节点基态能量的扩散蒙特卡罗（DMC）估计，其中测量的局域能量构成一个相关的时间序列。固定节点近似约束了节面，并将渐近平均能量移动了一个恒定的偏差，但它不改变围绕该平均值的涨落的平稳性或自相关结构。因此，核心的统计任务是从相关观测值中估计样本均值的无偏标准误差。\n\n从以下基础出发：\n- 具有有限积分自相关时间的平稳时间序列的样本均值遵循马尔可夫链的中心极限定理：随着样本数量的增加，样本均值的标度化偏差趋于正态分布，并且样本均值的方差取决于自相关函数。\n- 具有平稳均值和方差的一阶自回归过程（AR(1)）是用于模拟指数衰减时间相关的经过充分检验的模型。\n\n您的程序必须：\n- 使用具有指定参数的AR(1)高斯过程生成合成的类DMC局域能量轨迹。\n- 计算忽略相关性的均值朴素标准误差。\n- 使用二进制分块（也称重分块）计算分块标准误差。该方法通过对块大小为2的幂次的连续块进行平均来对序列进行粗粒化，并选择满足最小块数约束的最大块大小，从而减少时间相关性带来的偏差。\n\n形式上，让合成的局域能量时间序列由一个AR(1)递归定义\n$$\nX_{t} = \\mu + \\rho \\left( X_{t-1} - \\mu \\right) + \\varepsilon_{t}, \\quad \\varepsilon_{t} \\sim \\mathcal{N}\\!\\left(0, \\sigma_{\\varepsilon}^{2}\\right),\n$$\n并在其平稳分布中初始化，\n$$\nX_{0} \\sim \\mathcal{N}\\!\\left(\\mu, \\sigma^{2}\\right), \\quad \\sigma_{\\varepsilon}^{2} = \\sigma^{2}\\left(1-\\rho^{2}\\right),\n$$\n其中 $t \\in \\{1,2,\\dots,N-1\\}$，$N$是总样本数，$\\mu$是固定节点能量偏移（一个恒定的均值），$\\sigma$是局域能量的平稳标准差，$\\rho \\in (-1,1)$控制相关强度。\n\n给定一个实现 $\\{X_{t}\\}_{t=0}^{N-1}$：\n- 朴素标准误差是样本标准差除以 $\\sqrt{N}$，其中样本方差使用无偏除数。\n- 对于分块，定义块大小 $b \\in \\{2^{0}, 2^{1}, 2^{2}, \\dots\\}$，并对于每个块大小 $b$，形成 $n_{b} = \\lfloor N/b \\rfloor$ 个大小为 $b$ 的连续块，取其均值，并计算这些块均值的样本方差（使用无偏除数）。在块大小为 $b$ 时的分块标准误差是块均值方差除以 $n_{b}$ 后再开方。选择最大的块大小 $b^{\\star}$，使得 $n_{b^{\\star}} \\geq B_{\\min}$，其中 $B_{\\min}$ 是指定的最小块数。使用此分块标准误差作为报告的基于分块的误差棒。\n\n您的程序必须实现以上内容，而不使用任何快捷公式来获得答案，并且必须为每个测试用例输出以下包含四个浮点数的列表：\n- 均值的朴素标准误差。\n- 在指定的$B_{\\min}$下，于$b^{\\star}$处确定的均值的分块标准误差。\n- 朴素标准误差与分块标准误差的比值。\n- 估计的有效样本大小，定义为原始序列的无偏样本方差与分块标准误差平方的比值。\n\n所有浮点输出必须四舍五入到六位小数。\n\n测试套件：\n使用以下四个参数集，每个参数集以元组 $(N, \\mu, \\sigma, \\rho, \\text{seed}, B_{\\min})$ 的形式给出：\n- 情况 1：$(N=65536, \\mu=-0.5, \\sigma=1.0, \\rho=0.0, \\text{seed}=12345, B_{\\min}=16)$。\n- 情况 2：$(N=65536, \\mu=-0.5, \\sigma=1.0, \\rho=0.8, \\text{seed}=24680, B_{\\min}=16)$。\n- 情况 3：$(N=65536, \\mu=-0.5, \\sigma=1.0, \\rho=0.98, \\text{seed}=13579, B_{\\min}=16)$。\n- 情况 4：$(N=50000, \\mu=-1.0, \\sigma=1.5, \\rho=0.9, \\text{seed}=98765, B_{\\min}=16)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个Python风格的列表，每个测试用例对应一个条目，每个条目本身是按上述顺序排列的四个浮点数的列表。该列表必须以逗号分隔，并用方括号括起来，例如，\n```\n[[naive_1, blocked_1, ratio_1, effN_1], [naive_2, blocked_2, ratio_2, effN_2], ...]\n```\n不需要物理单位。不涉及角度。不得使用百分比；任何分数都必须表示为小数。程序必须是完全自包含的，不需要任何输入。必须通过提供的种子确保确定性伪随机数生成。所有步骤的计算都必须遵守上述定义。", "solution": "所提出的问题是关于相关时间序列统计分析的一个明确定义的练习，这是处理计算物理和化学中蒙特卡罗模拟数据的基本任务。使用一阶自回归（AR(1)）过程来模拟扩散蒙特卡罗（DMC）计算中的局域能量涨落，是一种标准且具有物理合理性的近似。其目标是在存在时间相关性的情况下，正确估计平均能量的统计不确定性。这要求超越那些假设数据独立的朴素统计估计量。\n\n对问题陈述的验证证实了它具有科学依据，在数学上是适定的，并包含了继续进行所需的所有必要信息。它既不琐碎也不适定。因此，可以构建一个严谨的解。\n\n解决方案将遵循统计力学和时间序列分析的原理，分三个阶段进行开发。\n\n首先，我们必须生成合成数据。局域能量时间序列，由随机变量序列 $\\{X_t\\}_{t=0}^{N-1}$ 表示，被建模为一个平稳高斯AR(1)过程。其演化由以下递归关系给出：\n$$\nX_{t} = \\mu + \\rho \\left( X_{t-1} - \\mu \\right) + \\varepsilon_{t}\n$$\n其中 $\\mu$ 是恒定平均能量，$\\rho$ 是连续步骤之间的自相关系数，$\\varepsilon_t$ 是均值为零、方差为 $\\sigma_{\\varepsilon}^2$ 的独立同分布高斯噪声项。为确保过程是平稳的，且具有恒定方差 $\\sigma^2 = \\text{Var}(X_t)$，噪声方差必须设置为 $\\sigma_{\\varepsilon}^2 = \\sigma^2(1-\\rho^2)$。模拟从平稳分布本身抽取初始状态 $X_0$ 开始，该分布是均值为 $\\mu$、方差为 $\\sigma^2$ 的正态分布，即 $X_0 \\sim \\mathcal{N}(\\mu, \\sigma^2)$。后续点 $X_t$（对于 $t \\in \\{1, 2, \\dots, N-1\\}$）通过该递归生成。此过程保证了整个生成的序列是来自指定平稳过程的真实样本。\n\n第二，我们计算均值的朴素标准误差。该估计量基于一个错误的假设，即 $N$ 个数据点是不相关的。它的计算方法如下：\n$$\n\\text{SE}_{\\text{naive}} = \\frac{s}{\\sqrt{N}}\n$$\n其中 $s^2$ 是时间序列 $\\{X_t\\}$ 的无偏样本方差：\n$$\ns^2 = \\frac{1}{N-1} \\sum_{t=0}^{N-1} (X_t - \\bar{X})^2\n$$\n这里，$\\bar{X}$ 是序列的样本均值。对于任何正相关（$\\rho > 0$），该估计量将系统地低估真实不确定性。\n\n第三，我们实现分块法，这是一种用于处理序列相关的鲁棒技术。其核心原理是将数据粗粒化为足够大的块，以使块平均值近似不相关。对于选定的块大小 $b$，原始序列被划分为 $n_b = \\lfloor N/b \\rfloor$ 个不重叠的块。计算每个块的均值，从而得到一个由 $n_b$ 个块平均值组成的新的、更短的时间序列。\n然后，可以从这些块均值的样本方差来估计总均值的方差。对于给定的块大小 $b$，标准误差为：\n$$\n\\text{SE}_{\\text{blocked}}(b) = \\sqrt{\\frac{\\text{var}(\\text{block means})}{n_b}}\n$$\n其中 $\\text{var}(\\text{block means})$ 是 $n_b$ 个块平均值的无偏样本方差。随着块大小 $b$ 的增加，块平均值的相关性降低，$\\text{SE}_{\\text{blocked}}(b)$ 会收敛到均值的真实标准误差。然而，随着 $b$ 的增加，$n_b$ 会减少，导致对方差的统计估计变差。因此，我们必须选择一个最佳块大小 $b^{\\star}$。问题指定了一个实用准则：$b^{\\star}$ 是形式为 $2^k$（其中整数 $k \\ge 0$）的最大块大小，使得块的数量 $n_{b^{\\star}}$ 至少为指定的最小值 $B_{\\min}$。此过程在减少相关性偏差和保持统计稳定性之间提供了平衡。\n\n最后，我们计算两个派生量来表征相关性的影响。朴素标准误差与分块标准误差的比值 $\\text{SE}_{\\text{naive}} / \\text{SE}_{\\text{blocked}}(b^{\\star})$，量化了朴素公式的低估程度。有效样本大小定义为：\n$$\nN_{\\text{eff}} = \\frac{s^2}{(\\text{SE}_{\\text{blocked}}(b^{\\star}))^2}\n$$\n表示产生等效统计误差所需的独立样本数量。对于正相关数据，我们期望 $N_{\\text{eff}}  N$。\n\n实现将对测试套件中提供的每个参数集执行此完整过程，通过使用指定的伪随机数生成器种子来确保确定性输出。所有数值结果将按要求四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Generates synthetic DMC local-energy traces using an AR(1) process and\n    computes naive and blocked standard errors of the mean.\n    \"\"\"\n    \n    # Test cases are given as (N, mu, sigma, rho, seed, B_min).\n    test_cases = [\n        (65536, -0.5, 1.0, 0.0, 12345, 16),\n        (65536, -0.5, 1.0, 0.8, 24680, 16),\n        (65536, -0.5, 1.0, 0.98, 13579, 16),\n        (50000, -1.0, 1.5, 0.9, 98765, 16)\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N, mu, sigma, rho, seed, B_min = case\n\n        # Initialize the pseudorandom number generator for reproducibility.\n        rng = np.random.default_rng(seed)\n\n        # Generate the AR(1) time series.\n        # This series emulates correlated local energy data from a DMC simulation.\n        X = np.zeros(N)\n        sigma_eps = sigma * np.sqrt(1.0 - rho**2)\n\n        # Initialize from the stationary distribution.\n        X[0] = rng.normal(loc=mu, scale=sigma)\n        \n        # Generate the rest of the series via the AR(1) recursion.\n        for t in range(1, N):\n            epsilon_t = rng.normal(loc=0.0, scale=sigma_eps)\n            X[t] = mu + rho * (X[t-1] - mu) + epsilon_t\n\n        # Calculate the unbiased sample variance of the original series.\n        # This will be used for both naive error and effective sample size.\n        sample_variance = np.var(X, ddof=1)\n\n        # 1. Compute the naive standard error of the mean.\n        # This estimator ignores correlations and is expected to be inaccurate for rho != 0.\n        naive_se = np.sqrt(sample_variance / N)\n\n        # 2. Compute the blocked standard error of the mean.\n        # This involves reblocking the data with increasing block sizes.\n        blocked_se = -1.0  # Placeholder, will be updated in the loop.\n        k = 0\n        while True:\n            # Block sizes are powers of two.\n            b = 2**k\n            n_b = N // b\n            \n            # Stop if the number of blocks is less than the required minimum.\n            # The result from the previous iteration is the correct one.\n            if n_b  B_min:\n                break\n            \n            # If n_b becomes 1, variance calculation is impossible (ddof=1).\n            # B_min > 1 ensures this path is not taken for the final result.\n            if n_b = 1:\n                # If this is the first iteration (k=0), it means N  B_min\n                # and no valid blocking is possible. Set SE to NaN.\n                if k == 0:\n                    blocked_se = np.nan\n                break\n\n            # Reshape the data into blocks. Leftover data at the end of the series is discarded.\n            num_elements_to_block = n_b * b\n            data_to_block = X[:num_elements_to_block]\n            blocks = data_to_block.reshape((n_b, b))\n            \n            # Compute the means of the blocks.\n            block_means = np.mean(blocks, axis=1)\n            \n            # Compute the unbiased variance of the block means.\n            var_block_means = np.var(block_means, ddof=1)\n            \n            # The standard error of the grand mean, estimated from this blocking level.\n            # This value is updated and stored. The last valid one is used.\n            blocked_se = np.sqrt(var_block_means / n_b)\n            \n            k += 1\n\n        # 3. Compute the ratio of naive to blocked standard error.\n        ratio = naive_se / blocked_se\n        \n        # 4. Compute the effective sample size.\n        effective_n = sample_variance / (blocked_se**2)\n\n        # Collect and round results to six decimal places.\n        result_list = [\n            round(naive_se, 6),\n            round(blocked_se, 6),\n            round(ratio, 6),\n            round(effective_n, 6)\n        ]\n        all_results.append(result_list)\n\n    # Format the final output string to be a compact list of lists.\n    # e.g., [[item1,item2],[item3,item4]]\n    # The map(str, ...) converts each inner list to its string representation.\n    # The ','.join(...) combines them into a single string.\n    # The outer f-string adds the enclosing brackets.\n    final_output_str = f\"[{','.join(map(str, all_results))}]\"\n    final_output_str = final_output_str.replace(\" \", \"\")\n\n    print(final_output_str)\n\nsolve()\n```", "id": "2885597"}, {"introduction": "分块方法之所以有效，是因为它能正确处理数据中的时间依赖性。为了加深对这一核心原理的理解，本练习设计了一个验证性实验 [@problem_id:3102616]。您将通过随机打乱一个自相关时间序列的数据点顺序来破坏其时间结构，然后对打乱后的序列应用分块方法，并观察其误差估计如何退化为适用于独立同分布 (IID) 数据的简单方差估计。这个过程清晰地揭示了数据顺序是分块方法发挥作用的关键。", "problem": "您的任务是，在存在序列依赖性的情况下，验证用于样本均值误差估计的分块法。\n\n分块法将一个按时间排序的序列划分为大小相等的非重叠组，形成块均值，并根据块之间的变异性来估计样本均值的方差。需要验证的核心原理是：通过对时间索引进行随机排列来破坏时间依赖性，应使基于分块法的方差估计量收敛到独立同分布 (IID) 的方差公式。\n\n使用的基本定义和事实：\n- 一个离散时间序列 $\\{X_t\\}_{t=1}^n$ 的样本均值为 $\\bar{X} = \\frac{1}{n} \\sum_{t=1}^n X_t$。\n- 对于方差为 $\\sigma^2$ 的 IID 数据，样本均值的方差为 $\\operatorname{Var}(\\bar{X}) = \\sigma^2 / n$。\n- 在使用块大小为 $b$ 的分块法时，前 $m = \\lfloor n/b \\rfloor$ 个不重叠的块产生块均值 $Y_i = \\frac{1}{b} \\sum_{t=(i-1)b+1}^{ib} X_t$，$i=1,\\dots,m$。当块足够大，使得块均值近似独立时，$\\bar{X}$ 的方差可利用 $\\{Y_i\\}$ 之间的变异性来近似。\n- 将索引的随机排列 $\\pi$ 应用于该序列，得到 $X'_t = X_{\\pi(t)}$，这会保留 $\\{X_t\\}$ 的边际分布，但会破坏时间顺序，从而破坏序列依赖性。\n\n任务：\n1. 对于每个指定的测试用例，通过一阶自回归 (AR) 模型生成一个时间序列。该序列满足 $X_t = \\phi X_{t-1} + \\epsilon_t$，其中 $|\\phi|  1$，$\\epsilon_t \\sim \\mathcal{N}(0,\\sigma_\\epsilon^2)$ 是独立的高斯新息，$X_0$ 从方差为 $\\sigma_\\epsilon^2 / (1 - \\phi^2)$ 的平稳分布中抽取以确保平稳性。每个测试用例使用一个固定的随机种子。\n2. 对于给定的块大小列表 $b$，按如下方式计算基于分块法的样本均值方差估计量：形成 $m = \\lfloor n/b \\rfloor$ 个不重叠的块均值 $Y_1,\\dots,Y_m$，计算 $\\{Y_i\\}$ 的带贝塞尔校正 (Bessel’s correction) 的无偏样本方差 $s_Y^2$，并通过 $\\hat{\\sigma}^2(b) = s_Y^2 / m$ 估计样本均值的方差。这利用了在 $\\{Y_i\\}$ 独立的条件下 $\\operatorname{Var}\\left(\\frac{1}{m}\\sum_{i=1}^m Y_i\\right) = \\operatorname{Var}(Y_i)/m$ 这一恒等式。\n3. 计算朴素的 IID 样本均值方差估计量 $\\hat{\\sigma}_{\\text{iid}}^2 = s_X^2 / n$，其中 $s_X^2$ 是 $\\{X_t\\}_{t=1}^n$ 的无偏样本方差。\n4. 通过对索引进行随机排列，创建序列的随机排列版本 $\\{X'_t\\}_{t=1}^n$。对于每个 $b$，通过分块法从 $\\{X'_t\\}$ 计算 $\\hat{\\sigma}'^2(b)$，并将其与 $\\hat{\\sigma}_{\\text{iid}}^2$ 进行比较。\n5. 对于每个测试用例，如果对于所有列出的块大小 $b$，相对误差 $|\\hat{\\sigma}'^2(b) - \\hat{\\sigma}_{\\text{iid}}^2| / \\hat{\\sigma}_{\\text{iid}}^2$ 都小于指定的容差 $\\varepsilon$，则生成一个布尔值 true；否则为 false。这验证了当顺序被打乱时，分块估计量会收敛到 IID 方差。\n\n约束和实现细节：\n- 如果 $b$ 不能整除 $n$，则只使用前 $m b$ 个点；在下面的测试套件中，每个 $b$ 都能整除 $n$，因此 $m$ 是一个整数。\n- 使用带贝塞尔校正 (Bessel’s correction) 的无偏样本方差。\n- 每个测试用例使用一个固定的伪随机数生成器种子，以确保可复现性以及测试用例之间的随机性独立。\n\n测试套件：\n- 测试用例 1 (具有强自相关的常规成功路径)：$n = 8192$，$\\phi = 0.8$，$\\sigma_\\epsilon = 1$，块大小 $b \\in \\{1,2,4,8,16,32,64,128,256\\}$，容差 $\\varepsilon = 0.08$。\n- 测试用例 2 (弱自相关)：$n = 4096$，$\\phi = 0.2$，$\\sigma_\\epsilon = 1$，块大小 $b \\in \\{1,2,4,8,16,32,64,128,256,512\\}$，容差 $\\varepsilon = 0.08$。\n- 测试用例 3 (IID 边界, $\\phi = 0$)：$n = 4096$，$\\phi = 0$，$\\sigma_\\epsilon = 1$，块大小 $b \\in \\{1,2,4,8,16,32,64,128,256,512\\}$，容差 $\\varepsilon = 0.08$。\n- 测试用例 4 (具有极强自相关和更宽 $b$ 覆盖范围的边缘情况)：$n = 8192$，$\\phi = 0.95$，$\\sigma_\\epsilon = 1$，块大小 $b \\in \\{1,2,4,8,16,32,64,128,256,512\\}$，容差 $\\varepsilon = 0.08$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有四个测试用例的结果，格式为方括号内以逗号分隔的列表，例如 $[\\text{result1},\\text{result2},\\text{result3},\\text{result4}]$，其中每个 $\\text{result}$ 是一个布尔值，表示在该测试用例中，收敛条件是否对所有列出的块大小都成立。", "solution": "本任务旨在验证时间序列分析中用于误差估计的分块法的一项核心原理。具体而言，我们将验证对于一个具有时间依赖性的时间序列，随机排列其数据点会破坏这种依赖性，从而使得分块法对样本均值方差的估计值收敛到用于独立同分布 (IID) 数据的更简单公式。\n\n验证将针对几个测试用例进行数值计算，每个测试用例均由一个一阶自回归模型 (AR($1$)) 定义。对于每个用例，我们遵循一个精确的算法流程。\n\n首先，我们根据以下方程从一个 AR($1$) 过程中生成一个长度为 $n$ 的平稳时间序列 $\\{X_t\\}_{t=1}^n$：\n$$X_t = \\phi X_{t-1} + \\epsilon_t$$\n其中 $\\phi$ 是满足 $|\\phi|  1$ 的自回归系数，而 $\\{\\epsilon_t\\}$ 是从均值为 $0$、方差为 $\\sigma_\\epsilon^2$ 的正态分布中抽取的独立同分布高斯随机变量（新息），即 $\\epsilon_t \\sim \\mathcal{N}(0, \\sigma_\\epsilon^2)$。为确保平稳性，初始值 $X_0$ 从该过程的平稳分布中抽取，该分布为 $\\mathcal{N}(0, \\sigma_X^2)$，其方差为 $\\sigma_X^2 = \\sigma_\\epsilon^2 / (1 - \\phi^2)$。每个测试用例都使用一个固定的伪随机数生成器种子以保证可复现性。\n\n其次，我们计算样本均值 $\\bar{X} = \\frac{1}{n} \\sum_{t=1}^n X_t$ 的方差的标准 IID 估计量。这个我们记为 $\\hat{\\sigma}_{\\text{iid}}^2$ 的估计量仅在数据点不相关时才有效。其计算公式为：\n$$\\hat{\\sigma}_{\\text{iid}}^2 = \\frac{s_X^2}{n}$$\n其中 $s_X^2$ 是时间序列 $\\{X_t\\}_{t=1}^n$ 的无偏样本方差，使用贝塞尔校正 (Bessel's correction) 计算：\n$$s_X^2 = \\frac{1}{n-1} \\sum_{t=1}^n (X_t - \\bar{X})^2$$\n\n第三，我们通过对原始序列 $\\{X_t\\}_{t=1}^n$ 的索引应用随机排列，创建一个排列后的时间序列 $\\{X'_t\\}_{t=1}^n$。此操作保留了值的集合，因此样本均值和方差也保持不变 ($s_{X'}^2 = s_X^2$)，但它破坏了 AR($1$) 过程固有的时间相关结构。得到的序列 $\\{X'_t\\}$ 是一个可交换序列。\n\n第四，对于排列后的序列 $\\{X'_t\\}$，我们对一系列块大小 $b$ 应用分块法。该序列被划分为 $m = \\lfloor n/b \\rfloor$ 个不重叠的块。对于给定的测试用例，$n$ 总是能被 $b$ 整除，所以 $m=n/b$。我们计算每个块的均值：\n$$Y'_i = \\frac{1}{b} \\sum_{t=(i-1)b+1}^{ib} X'_t \\quad \\text{for } i = 1, \\dots, m$$\n分块法通过将这些块均值 $\\{Y'_i\\}_{i=1}^m$ 视为近似独立的数据点来估计样本均值的方差。该估计量我们记为 $\\hat{\\sigma}'^2(b)$，由下式给出：\n$$\\hat{\\sigma}'^2(b) = \\frac{s_{Y'}^2}{m}$$\n其中 $s_{Y'}^2$ 是块均值 $\\{Y'_i\\}$ 的无偏样本方差：\n$$s_{Y'}^2 = \\frac{1}{m-1} \\sum_{i=1}^m (Y'_i - \\bar{Y'})^2$$\n在这里，$\\bar{Y'}$ 是块均值的均值，其数值上与总样本均值 $\\bar{X'}$ 相同。\n\n最后，我们进行验证。核心假设是，对于排列后的（时间上无结构的）数据，分块估计量 $\\hat{\\sigma}'^2(b)$ 应与 IID 估计量 $\\hat{\\sigma}_{\\text{iid}}^2$ 一致，而与块大小 $b$ 无关。我们通过检查对于所有指定的块大小 $b$，两个估计量之间的相对误差是否小于给定的容差 $\\varepsilon$ 来测试这一点。对于每个测试用例，最终结果是一个布尔值，如果以下条件对其块大小列表中的所有 $b$ 都成立，则为 `True`，否则为 `False`：\n$$\\frac{\\left| \\hat{\\sigma}'^2(b) - \\hat{\\sigma}_{\\text{iid}}^2 \\right|}{\\hat{\\sigma}_{\\text{iid}}^2}  \\varepsilon$$\n\n理论上，这种收敛是预期的，因为对于一个可交换序列，块均值的样本方差的期望值 $E[s_{Y'}^2]$ 可以被证明近似于 $b \\cdot \\operatorname{Var}(\\bar{X'})$，其中 $\\bar{X'}$ 是 $n$ 个相关抽样的样本均值。在我们这里对一组固定数字进行随机排列的情况下，通过方差分析 (Analysis of Variance, ANOVA) 的论证，可以表明组间均方 (mean square between blocks) 的期望值等于数据的总样本方差，即 $E[MSB] = s_X^2$。由于 $\\hat{\\sigma}'^2(b) = MSB/n$ 且 $\\hat{\\sigma}_{\\text{iid}}^2 = s_X^2/n$，我们预期它们的值会很接近。容差 $\\varepsilon$ 解释了 $MSB$ 在其期望值周围的统计波动，当块数 $m$ 较小时，这一点尤其重要。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the validation for all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'n': 8192, 'phi': 0.8, 'sigma_eps': 1.0, 'block_sizes': [1, 2, 4, 8, 16, 32, 64, 128, 256], 'tolerance': 0.08},\n        {'n': 4096, 'phi': 0.2, 'sigma_eps': 1.0, 'block_sizes': [1, 2, 4, 8, 16, 32, 64, 128, 256, 512], 'tolerance': 0.08},\n        {'n': 4096, 'phi': 0.0, 'sigma_eps': 1.0, 'block_sizes': [1, 2, 4, 8, 16, 32, 64, 128, 256, 512], 'tolerance': 0.08},\n        {'n': 8192, 'phi': 0.95, 'sigma_eps': 1.0, 'block_sizes': [1, 2, 4, 8, 16, 32, 64, 128, 256, 512], 'tolerance': 0.08},\n    ]\n\n    results = []\n    # Use a different seed for each test case for independent experiments.\n    # The seeds are fixed to ensure the overall result is reproducible.\n    for i, case in enumerate(test_cases):\n        result = validate_blocking_collapse(**case, seed=i)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef validate_blocking_collapse(n, phi, sigma_eps, block_sizes, tolerance, seed):\n    \"\"\"\n    Performs the validation for a single test case.\n\n    Args:\n        n (int): Length of the time series.\n        phi (float): Autoregressive coefficient.\n        sigma_eps (float): Standard deviation of innovations.\n        block_sizes (list): List of block sizes to test.\n        tolerance (float): Relative error tolerance.\n        seed (int): Seed for the pseudorandom number generator.\n\n    Returns:\n        bool: True if the collapse condition holds for all block sizes, False otherwise.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    # 1. Generate AR(1) time series\n    if abs(phi)  1.0:\n        var_x_stationary = sigma_eps**2 / (1 - phi**2)\n    else:\n        # This case is not expected based on problem constraints but included for robustness.\n        var_x_stationary = 1.0 \n    \n    x0 = rng.normal(loc=0, scale=np.sqrt(var_x_stationary))\n    innovations = rng.normal(loc=0, scale=sigma_eps, size=n)\n    \n    x = np.zeros(n)\n    x[0] = phi * x0 + innovations[0]\n    for t in range(1, n):\n        x[t] = phi * x[t-1] + innovations[t]\n        \n    # 2. Compute naive IID variance estimator for the sample mean\n    s_x_sq = np.var(x, ddof=1)\n    sigma_iid_sq = s_x_sq / n\n\n    # 3. Create a randomly permuted version of the series\n    x_prime = rng.permutation(x)\n\n    # 4. For each block size, compute the blocking estimator and check the condition\n    for b in block_sizes:\n        m = n // b\n        \n        # Ensure there are at least 2 blocks to compute variance\n        if m  2:\n            # According to problem specification, m is always >= 8.\n            # If for some reason m  2, the variance s_Y^2 is undefined.\n            # We treat this as a failure of the condition.\n            return False\n\n        # Reshape the permuted series into blocks\n        blocks = x_prime.reshape((m, b))\n        \n        # Compute means of the blocks\n        y_prime = np.mean(blocks, axis=1)\n        \n        # Compute the unbiased sample variance of the block means\n        s_y_prime_sq = np.var(y_prime, ddof=1)\n        \n        # Compute the blocking-based variance estimator for the sample mean\n        sigma_prime_sq_b = s_y_prime_sq / m\n\n        # 5. Check if the relative error is within the specified tolerance\n        if sigma_iid_sq == 0:\n            # This is extremely unlikely but would occur if all x_t are identical.\n            # If both estimators are 0, the error is 0. If not, it's infinite.\n            if sigma_prime_sq_b != 0:\n                return False\n        else:\n            relative_error = np.abs(sigma_prime_sq_b - sigma_iid_sq) / sigma_iid_sq\n            if relative_error >= tolerance:\n                # If the condition fails for any block size, the entire test case fails.\n                return False\n\n    # If the loop completes, the condition held for all block sizes.\n    return True\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3102616"}]}