{"hands_on_practices": [{"introduction": "掌握离散事件模拟的最好方法就是亲手构建一个。我们的第一个练习将超越简单的“一次服务一个客户”模型，进入一个更贴近现实的“批量服务”场景，这在制造业和数据处理等领域非常普遍。通过这个练习 [@problem_id:3119935]，你将巩固管理事件列表、跟踪客户统计数据等核心技能，并学会在更复杂的设置中应用它们。", "problem": "您需要设计并实现一个单服务器批量服务队列的离散事件模拟（DES），该队列被称为具有最大批量大小的马尔可夫到达/马尔可夫服务/单服务器（$M/M/1$）队列。在此系统中，到达形成一个率为 $\\lambda$ 的泊松过程，服务时间服从率为 $\\mu$（按批次计）的指数分布。服务器可以启动一次服务，同时为最多 $b$ 名顾客提供服务；服务开始时选择的批量大小是当前队列长度和最大批量大小 $b$ 的最小值。一批次的服务时间不依赖于该批次的大小。顾客在先进先出（FIFO）队列中等待。\n\n从核心定义出发，您必须实现一个事件调度离散事件模拟，该模拟模型遵循以下规则：\n\n- 到达遵循率为 $\\lambda$ 的泊松过程；到达间隔时间是独立的，并服从均值为 $1/\\lambda$ 的指数分布。\n- 当服务器空闲且队列非空时，立即开始对大小为 $k = \\min(b, q)$ 的批次进行服务，其中 $q$ 是当前队列长度。批次中的所有 $k$ 名顾客在同一时刻开始服务，并在一个均值为 $1/\\mu$ 的指数分布服务时间后一同离开。\n- 当一个批次正在服务时，新到达的顾客会加入队列，并将在当前服务完成后于未来的批次中得到服务。\n- 顾客的等待时间定义为从到达时刻到服务开始时刻的时间。吞吐量定义为在模拟时域内离开的顾客数量除以模拟时域长度。\n\n您的模拟必须使用下一事件时间推进方法：在任何步骤中，下一个事件是下一到达时间和下一服务完成时间中的最小值。模拟必须从时间 $t=0$ 运行到一个有限时域 $T$，初始状态为空队列和空闲服务器。您必须报告运行过程中的以下性能指标：\n- 吞吐量 $\\tau$，定义为 $D/T$，其中 $D$ 是在时间 $T$ 之前完成服务的顾客数量。\n- 平均等待时间 $\\overline{W}$，计算对象为在时间 $T$ 之前开始服务的所有顾客。\n\n重要的建模说明：\n- 假设一批次的服务时间分布为 $\\text{Exponential}(\\mu)$，与批次中的顾客数量无关。\n- 为保证可复现性，每个测试用例必须使用指定的伪随机种子。\n- 如果在时域内没有顾客开始服务，则将 $\\overline{W}$ 定义为 $\\mathrm{NaN}$（非数字），并将 $\\tau$ 定义为 $0$。\n\n使用的基本定义：\n- 泊松过程：到达具有独立、平稳的增量；到达间隔时间是独立的指数随机变量，参数为 $\\lambda$。\n- 参数为 $\\alpha$ 的指数分布：一种具有无记忆性的非负随机变量，均值为 $1/\\alpha$。\n- FIFO 规则：顾客按其到达时间的非递减顺序获得服务。\n\n实现一个完整的、可运行的程序，为以下测试套件计算 $\\tau$ 和 $\\overline{W}$，其中每个参数集为 $(\\lambda, \\mu, b, T, \\text{seed})$：\n\n- 测试 $1$：$(\\lambda=\\;0.8,\\;\\mu=\\;1.0,\\;b=\\;2,\\;T=\\;20000,\\;\\text{seed}=\\;1)$，一个中等负载的稳定情况。\n- 测试 $2$：$(\\lambda=\\;2.0,\\;\\mu=\\;1.0,\\;b=\\;2,\\;T=\\;20000,\\;\\text{seed}=\\;2)$，一个接近额定容量 $\\mu \\cdot b$ 的边界负载情况。\n- 测试 $3$：$(\\lambda=\\;1.5,\\;\\mu=\\;1.0,\\;b=\\;1,\\;T=\\;20000,\\;\\text{seed}=\\;3)$，一个经典的单顾客批次过载情况（一次服务一个）。\n- 测试 $4$：$(\\lambda=\\;0.9,\\;\\mu=\\;1.0,\\;b=\\;4,\\;T=\\;20000,\\;\\text{seed}=\\;4)$，一个具有较大批次容量的稳定情况。\n- 测试 $5$：$(\\lambda=\\;3.0,\\;\\mu=\\;0.5,\\;b=\\;10,\\;T=\\;20000,\\;\\text{seed}=\\;5)$，一个具有大批次容量的稳定高负载情况。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例贡献一对 $[\\tau,\\overline{W}]$，两个值都以小数点后六位的小数形式打印。最终格式必须为：\n$$\\big[ [\\tau_1,\\overline{W}_1], [\\tau_2,\\overline{W}_2], [\\tau_3,\\overline{W}_3], [\\tau_4,\\overline{W}_4], [\\tau_5,\\overline{W}_5] \\big]$$\n其中顺序对应测试 $1$ 到 $5$。吞吐量 $\\tau$ 的单位必须是顾客/单位时间，等待时间 $\\overline{W}$ 的时间单位必须与 $T$ 相同。", "solution": "该问题要求设计并实现一个单服务器批量服务队列的离散事件模拟，具体是一个被归类为具有最大批量大小 $b$ 的 $M/M/1$ 模型。该模拟必须使用下一事件时间推进机制构建，并将用于估计系统性能指标。该问题具有科学依据，定义明确，并为可复现的模拟提供了所有必要的参数。\n\n### 1. 离散事件模拟（DES）的概念框架\n\n离散事件模拟将系统随时间的演变建模为一系列改变系统状态的瞬时事件。此模拟的基本组成部分是：\n\n-   **状态变量**：在任何时间点能完全描述系统的最小变量集。对于此问题，状态由队列中等待的顾客数量 $q$ 和服务器状态（空闲或繁忙）定义。为了计算单个顾客的等待时间，我们还必须存储每个等待顾客的到达时间。\n-   **模拟时钟 ($t_{sim}$)**：一个在模拟内部跟踪当前时间的变量。时间从一个事件跳跃到下一个事件，以离散的方式推进。\n-   **事件**：触发系统状态改变的瞬时发生。在此模型中，有两种事件类型：顾客**到达**和批次**服务完成**（对应多个顾客的离开）。\n-   **事件调度**：一种管理未来事件的机制。鉴于只有两种未来事件需要跟踪（下一次到达和潜在的下一次服务完成），我们可以使用两个变量 $t_A$ 和 $t_D$ 来存储它们的预定时间。预定时间最小的事件是下一个将要发生的事件。\n\n### 2. 状态变量和统计累加器\n\n模拟动态地维护以下变量以跟踪系统状态并计算最终指标：\n\n-   **模拟时钟**：$t_{sim}$\n-   **到达时间队列**：$Q_{times}$，一个先进先出（FIFO）数据结构，用于保存当前正在等待服务的顾客的到达时间。其长度对应于队列长度，$q = |Q_{times}|$。\n-   **服务器状态**：$S$，一个二进制指示器，其中 $S=0$ 表示服务器空闲，$S=1$ 表示服务器繁忙。\n-   **下一次到达时间**：$t_A$，下一次顾客到达的预定时间。\n-   **下一次离开时间**：$t_D$，当前批次服务完成的预定时间。当服务器空闲时，它被设置为无穷大（$\\infty$）。\n-   **服务中批次大小**：$k_{service}$，当前正在服务的批次中的顾客数量。\n\n为了计算所需的性能指标，在整个模拟过程中会更新以下统计累加器：\n\n-   $N_D$：已离开（完成服务）的顾客总数。\n-   $N_S$：已开始服务的顾客总数。\n-   $W_{tot}$：所有已开始服务的顾客的等待时间累积总和。\n\n### 3. 模拟算法：下一事件时间推进\n\n模拟执行一个主循环，该循环重复地将时钟推进到下一个预定事件时间，处理该事件，并更新系统状态。该过程从 $t_{sim}=0$ 开始，并持续到下一个事件时间将超过模拟时域 $T$ 为止。\n\n#### 初始化（在 $t_{sim}=0$ 时）\n\n1.  设置模拟时钟 $t_{sim} = 0$。\n2.  初始化系统状态：队列 $Q_{times}$ 为空，服务器空闲（$S=0$）。\n3.  初始化统计累加器：$N_D = 0$，$N_S = 0$，$W_{tot} = 0$。\n4.  初始化服务器变量：$k_{service}=0$。\n5.  为伪随机数生成器设定种子以保证可复现性。\n6.  安排第一次到达：使用公式 $\\Delta t_A = -\\frac{1}{\\lambda}\\ln(U)$ 从率为 $\\lambda$（均值为 $1/\\lambda$）的指数分布中生成一个到达间隔时间 $\\Delta t_A$，其中 $U$ 是来自 Uniform$(0,1)$ 分布的随机变量。将第一次到达时间设置为 $t_A = \\Delta t_A$。\n7.  将下一次离开时间设置为无穷大，$t_D = \\infty$，因为服务器初始时是空闲的。\n\n#### 模拟主循环\n\n循环按以下方式进行：\n\n1.  **确定下一事件**：识别下一个事件的时间，$t_{next} = \\min(t_A, t_D)$。\n2.  **检查终止条件**：如果 $t_{next} > T$，则模拟时域已过，循环终止。\n3.  **推进时钟**：将模拟时钟更新到下一个事件时间：$t_{sim} = t_{next}$。\n4.  **处理事件**：\n    -   **如果 $t_{sim}$ 是到达时间（$t_{sim} = t_A$）：**\n        a. 一名新顾客到达。将其到达时间 $t_{sim}$ 添加到队列 $Q_{times}$ 中。\n        b. 安排下一次到达。从 $\\text{Exponential}(\\lambda)$ 分布中生成一个新的到达间隔时间 $\\Delta t_A$，并设置新的到达时间 $t_A = t_{sim} + \\Delta t_A$。\n    -   **如果 $t_{sim}$ 是离开时间（$t_{sim} = t_D$）：**\n        a. 大小为 $k_{service}$ 的批次完成服务。增加总离开计数：$N_D \\leftarrow N_D + k_{service}$。\n        b. 服务器变为空闲。设置 $S=0$ 并将下一次离开时间重置为 $t_D = \\infty$。\n\n5.  **检查新服务是否开始**：此逻辑在任何事件之后执行。\n    -   如果服务器空闲（$S=0$）且队列不为空（$|Q_{times}|>0$）：\n        a. 服务器变为繁忙：设置 $S=1$。\n        b. 确定此服务实例的批量大小：$k = \\min(b, |Q_{times}|)$。\n        c. 记录当前服务中批次的大小：$k_{service} = k$。\n        d. 对于队列前面的 $k$ 名顾客中的每一位：\n           i. 从 $Q_{times}$ 中取出他们的到达时间 $t_{arr}$。\n           ii. 计算他们的等待时间：$W_i = t_{sim} - t_{arr}$。\n           iii. 将此加到总等待时间中：$W_{tot} \\leftarrow W_{tot} + W_i$。\n        e. 将已开始服务的顾客数量增加批量大小：$N_S \\leftarrow N_S + k$。\n        f. 为这个新批次安排服务完成。从 $\\text{Exponential}(\\mu)$ 分布中生成一个服务时间 $\\Delta t_S$，并设置离开时间 $t_D = t_{sim} + \\Delta t_S$。\n\n#### 最终计算\n\n模拟循环终止后，计算性能指标：\n\n1.  **吞吐量 ($\\tau$)**：定义为完成服务的顾客速率。其计算公式为 $\\tau = N_D / T$。如果没有顾客离开，$N_D=0$，因此 $\\tau=0$。\n2.  **平均等待时间 ($\\overline{W}$)**：对在时间 $T$ 之前开始服务的所有顾客进行平均。\n    -   如果 $N_S > 0$，则平均等待时间为 $\\overline{W} = W_{tot} / N_S$。\n    -   如果 $N_S = 0$，则没有顾客开始服务。在这种情况下，$\\overline{W}$ 被定义为非数字（$\\mathrm{NaN}$）。\n\n这种严谨的、事件驱动的方法确保了系统动态根据指定规则被精确建模。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef run_simulation(lambda_rate, mu_rate, b, T, seed):\n    \"\"\"\n    Runs a discrete event simulation of a single-server queue with bulk service.\n\n    Args:\n        lambda_rate (float): Arrival rate (Poisson process).\n        mu_rate (float): Service rate per batch (Exponential distribution).\n        b (int): Maximum batch size.\n        T (float): Simulation time horizon.\n        seed (int): Seed for the pseudo-random number generator.\n\n    Returns:\n        tuple[float, float]: A tuple containing the calculated throughput (tau)\n                             and mean waiting time (W_mean).\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    # State variables\n    t_sim = 0.0\n    queue_arrival_times = deque()\n    server_busy = False\n\n    # Event times\n    t_arrival = rng.exponential(scale=1.0 / lambda_rate)\n    t_departure = float('inf')\n\n    # Statistical accumulators\n    departed_count = 0\n    started_service_count = 0\n    wait_time_sum = 0.0\n    \n    # Variable to store the size of the batch currently in service\n    batch_size_in_service = 0\n\n    while True:\n        # Determine the next event time\n        if t_arrival = t_departure:\n            is_arrival_event = True\n            next_event_time = t_arrival\n        else:\n            is_arrival_event = False\n            next_event_time = t_departure\n\n        # Check termination condition\n        if next_event_time > T:\n            break\n        \n        t_sim = next_event_time\n\n        if is_arrival_event:\n            # --- Process Arrival Event ---\n            queue_arrival_times.append(t_sim)\n            # Schedule the next arrival\n            t_arrival = t_sim + rng.exponential(scale=1.0 / lambda_rate)\n        else:\n            # --- Process Departure Event ---\n            departed_count += batch_size_in_service\n            server_busy = False\n            t_departure = float('inf')\n            batch_size_in_service = 0\n\n        # --- Check for new Service Start (after any event) ---\n        if not server_busy and len(queue_arrival_times) > 0:\n            server_busy = True\n            \n            # Determine batch size\n            batch_k = min(b, len(queue_arrival_times))\n            batch_size_in_service = batch_k\n            \n            # Process customers starting service\n            for _ in range(batch_k):\n                arrival_t = queue_arrival_times.popleft()\n                wait_time_sum += (t_sim - arrival_t)\n            \n            started_service_count += batch_k\n            \n            # Schedule the departure for this batch\n            service_time = rng.exponential(scale=1.0 / mu_rate)\n            t_departure = t_sim + service_time\n    \n    # --- Final Calculations after loop termination ---\n    tau = departed_count / T\n\n    if started_service_count > 0:\n        W_mean = wait_time_sum / started_service_count\n    else:\n        # As per problem spec, if no customer starts service, W is NaN.\n        # tau will naturally be 0 in this case as departed_count is 0.\n        W_mean = float('nan')\n\n    return tau, W_mean\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs the simulation for each, and prints the formatted results.\n    \"\"\"\n    test_cases = [\n        # (lambda_rate, mu_rate, b, T, seed)\n        (0.8, 1.0, 2, 20000, 1),  # Test 1\n        (2.0, 1.0, 2, 20000, 2),  # Test 2\n        (1.5, 1.0, 1, 20000, 3),  # Test 3\n        (0.9, 1.0, 4, 20000, 4),  # Test 4\n        (3.0, 0.5, 10, 20000, 5)  # Test 5\n    ]\n\n    results = []\n    for case in test_cases:\n        tau, W_mean = run_simulation(*case)\n        \n        # Format results to six decimal places, handling NaN for waiting time.\n        tau_str = f\"{tau:.6f}\"\n        if np.isnan(W_mean):\n            W_mean_str = \"NaN\" \n        else:\n            W_mean_str = f\"{W_mean:.6f}\"\n            \n        results.append(f\"[{tau_str},{W_mean_str}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3119935"}, {"introduction": "构建完一个模拟程序后，我们如何能确定它除了得出最终数字外，在逻辑上是正确无误的呢？这个实践引入了“不变量”这一至关重要的概念，即系统必须始终遵守的基本规则。通过在运行时中加入检查，甚至故意注入错误来测试你的防御机制 [@problem_id:3119919]，你将学会如何构建更健壮、更值得信赖的模拟模型。", "problem": "您将实现一个具有指数到达间隔和服务时间的单服务器队列的离散事件模拟。目标是在运行时验证不变性属性，并注入受控的逻辑故障以测试检测覆盖率。该模拟必须通过固定的随机种子来确保其确定性。其基本原理包括离散事件模拟的定义、用于到达的泊松过程概念以及实体守恒原则。\n\n系统定义如下：\n- 事件是到达和服务完成（离开）。在时间 $t$ 处理完每个事件后，必须断言以下不变性：\n  1. 队列长度非负性：$Q(t) \\ge 0$，其中 $Q(t)$ 是在队列中等待的实体数量（不包括任何当前正在接受服务的实体）。\n  2. 实体守恒：$S(t) + D(t) = A(t)$，其中 $S(t)$ 是系统中当前的实体数量（等待中加上服务中），$D(t)$ 是累计离开数量，而 $A(t)$ 是累计到达数量。\n- 到达遵循速率为 $\\lambda$（单位：$\\text{s}^{-1}$，即每秒）的指数到达间隔分布。服务遵循速率为 $\\mu$（单位：$\\text{s}^{-1}$）的指数分布。模拟时间上限为 $T_{\\text{end}}$ 秒。\n\n根据以下规则实现离散事件模拟：\n- 使用按时间排序的优先事件列表，严格按时间顺序处理事件。\n- 在到达事件时：\n  - 除非故障另有规定，否则增加累计到达数 $A(t)$。\n  - 如果服务器空闲，立即开始服务，并在抽取一次服务时间后安排一个离开事件；否则，增加队列长度。\n  - 相应地更新 $S(t)$。\n- 在离开事件时：\n  - 增加累计离开数 $D(t)$。\n  - 如果队列非空，则减少队列长度并立即开始为下一个实体服务（安排其离开事件）；否则，将服务器标记为空闲。\n  - 相应地更新 $S(t)$。\n- 在每个事件之后，对两个不变性强制执行运行时断言。如果任何断言失败，模拟必须记录检测到违规，并停止处理该测试用例的后续事件。\n\n故障注入机制：\n- 故障 $f_1$（“负队列故障”）：在第一个离开事件时，在检查不变性之前，恶意地将 $Q(t)$ 设置为 $-1$。这用于测试对非负性不变性的检测。\n- 故障 $f_2$（“丢弃到达故障”）：在第 $k$ 次到达时（$k$ 为正整数），将到达事件处理进系统，但不增加 $A(t)$。这用于测试对守恒不变性的检测。\n\n单位：\n- 时间 $t$ 和 $T_{\\text{end}}$ 必须以秒为单位。\n- 速率 $\\lambda$ 和 $\\mu$ 必须以 $\\text{s}^{-1}$ 为单位。\n\n随机性：\n- 对所有随机抽样使用固定种子 $s = 42$，以确保确定性。\n\n您的程序必须实现模拟和不变性检查，并且必须支持按测试用例切换这两种故障。对于每个测试用例，返回一个布尔值，指示是否检测到任何不变性违规（如果检测到违规则为 $\\text{True}$，否则为 $\\text{False}$）。\n\n测试套件（所有时间单位为秒，所有速率单位为 $\\text{s}^{-1}$，$k$ 是一个无单位的正整数索引）：\n- 案例 1（正常路径）：$\\lambda = 1.5$, $\\mu = 2.0$, $T_{\\text{end}} = 10.0$, $f_1 = \\text{False}$, $f_2 = \\text{False}$, $k = 3$。\n- 案例 2（边界情况，无到达）：$\\lambda = 0.0$, $\\mu = 1.0$, $T_{\\text{end}} = 5.0$, $f_1 = \\text{False}$, $f_2 = \\text{False}$, $k = 3$。\n- 案例 3（快速服务边缘情况）：$\\lambda = 10.0$, $\\mu = 100.0$, $T_{\\text{end}} = 1.0$, $f_1 = \\text{False}$, $f_2 = \\text{False}$, $k = 3$。\n- 案例 4（负队列故障）：$\\lambda = 0.5$, $\\mu = 0.5$, $T_{\\text{end}} = 10.0$, $f_1 = \\text{True}$, $f_2 = \\text{False}$, $k = 3$。\n- 案例 5（丢弃到达故障）：$\\lambda = 2.0$, $\\mu = 3.0$, $T_{\\text{end}} = 10.0$, $f_1 = \\text{False}$, $f_2 = \\text{True}$, $k = 3$。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个布尔值，顺序与上述案例一致（例如，$[\\text{True},\\text{False},\\dots]$）。不允许有其他输出。", "solution": "问题陈述已经过评估，并被确定为 **有效的**。它在科学上基于排队论和离散事件模拟的既定原则，并且是适定的，为确定性实现提供了一套完整且一致的定义、参数和约束。\n\n任务是实现一个单服务器队列的离散事件模拟（DES），由于其 **马** 尔可夫（指数）的到达间隔和服务时间分布，在排队论中被称为 M/M/1 队列。该实现将用于在运行时验证系统不变性并测试对注入故障的检测。\n\n**1. 离散事件模拟原理**\n\n离散事件模拟将系统演化建模为在特定时间点发生的一系列离散事件。我们模拟模型的核心组件是：\n- **系统状态**：一组在任何给定时间 $t$ 捕获系统基本信息的变量。\n- **模拟时钟**：一个表示模拟中当前时间 $t$ 的变量。\n- **事件列表**：一种数据结构，通常是优先队列，用于存储按其计划发生时间排序的未来事件。\n\n模拟通过从事件列表中反复提取下一个最紧急的事件、将模拟时钟推进到该事件的时间，并执行更新系统状态的事件处理例程来进行。\n\n**2. 系统状态表示**\n\n对于 M/M/1 队列，系统在时间 $t$ 的状态由以下变量定义：\n- $Q(t)$：在队列中等待的实体数量。这是一个非负整数。\n- $B(t)$：一个表示服务器状态的二元变量，其中如果服务器繁忙则 $B(t)=1$，如果空闲则 $B(t)=0$。\n- $A(t)$：直到时间 $t$ 到达系统的实体累计计数。\n- $D(t)$：直到时间 $t$ 离开系统的实体累计计数。\n\n从这些变量中，我们可以推导出 $S(t)$，即当前在系统中的实体总数（正在服务或在队列中等待）：\n$$S(t) = Q(t) + B(t)$$\n\n**3. 事件驱动逻辑和事件例程**\n\n模拟由事件调度算法驱动。一个实现为最小优先队列的事件列表将待处理事件存储为 `(event_time, event_type)` 元组。主循环持续处理具有最小时间戳的事件，直到事件列表为空或超过模拟结束时间 $T_{\\text{end}}$。\n\n两种类型的事件驱动系统动态：到达和离开。\n\n**到达事件例程**：\n时间 $t$ 的一个到达事件会触发以下操作：\n1.  **故障注入检查**：如果故障 $f_2$ 已启用且这是第 $k$ 次到达，则跳过对 $A(t)$ 的增加。否则，$A(t)$ 增加：$A(t) \\leftarrow A(t^-) + 1$。\n2.  **状态更新**：\n    - 如果服务器空闲 ($B(t^-)=0$)，到达的实体立即进入服务。我们设置 $B(t) \\leftarrow 1$ 并安排一个新的 `Departure` 事件。这个未来离开事件的时间是 $t + \\tau_s$，其中 $\\tau_s$ 是从速率为 $\\mu$ 的指数分布中抽取的随机服务时间。\n    - 如果服务器繁忙 ($B(t^-)=1$)，实体必须等待。队列长度增加：$Q(t) \\leftarrow Q(t^-) + 1$。\n3.  **安排下一次到达**：在时间 $t + \\tau_a$ 安排一个新的 `Arrival` 事件，其中 $\\tau_a$ 是从速率为 $\\lambda$ 的指数分布中抽取的随机到达间隔时间。仅当 $\\lambda  0$ 时才执行此操作。\n\n**离开事件例程**：\n时间 $t$ 的离开事件表示一次服务完成：\n1.  **状态更新**：累计离开计数增加：$D(t) \\leftarrow D(t^-) + 1$。\n2.  **服务器和队列更新**：\n    - 如果队列不为空 ($Q(t^-)  0$)，队列中的下一个实体立即进入服务。我们减少队列长度，$Q(t) \\leftarrow Q(t^-) - 1$，并在时间 $t + \\tau_s$ 安排一个新的 `Departure` 事件，其中 $\\tau_s$ 从服务时间分布中抽取。服务器保持繁忙状态 ($B(t)=1$)。\n    - 如果队列为空 ($Q(t^-)=0$)，服务器变为空闲：$B(t) \\leftarrow 0$。\n\n**4. 随机变量生成**\n\n到达间隔和服务时间是分别遵循速率为 $\\lambda$ 和 $\\mu$ 的指数分布的随机变量。可以使用逆变换采样法从速率参数为 $\\theta$ 的指数分布中生成一个随机变量 $x$。其公式为：\n$$ x = -\\frac{1}{\\theta} \\ln(U) $$\n其中 $U$ 是从区间 $(0, 1)$ 上的均匀分布中抽取的随机数。\n为确保问题所要求的确定性行为，在每次模拟运行开始时，使用固定值 $s=42$ 为伪随机数生成器设置种子。\n\n**5. 不变性断言和故障注入**\n\n每个事件处理完毕后，会断言两个基本系统不变性，以确保模拟状态的逻辑正确性。故障注入机制旨在确定性地违反这些不变性，以测试监控逻辑。\n\n1.  **队列非负性**：$Q(t) \\ge 0$。物理上不可能在队列中拥有负数个项目。故障 $f_1$ 测试对此不变性违规的检测。在第一个离开事件时，它会在检查不变性之前恶意地将 $Q(t)$ 的值设置为 $-1$。\n\n2.  **实体守恒**：$A(t) = S(t) + D(t)$。这表达了守恒定律：一个已经到达的实体必须要么仍在系统中（$S(t)$），要么已经离开（$D(t)$）。故障 $f_2$ 针对此不变性。在第 $k$ 次到达时，它导致模拟从累计计数 $A(t)$ 中“丢弃”该次到达，同时仍允许实体进入系统。这会造成一个差异，使得 $S(t) + D(t)$ 将大于 $A(t)$，从而违反等式。\n\n如果任一检查失败，一个“检测到违规”标志将被设置为 `True`，并且该特定测试用例的模拟将终止。否则，模拟继续进行。每个案例的最终结果是此标志的最终状态。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef run_simulation(lam: float, mu: float, T_end: float, f1: bool, f2: bool, k: int) -> bool:\n    \"\"\"\n    Runs a discrete event simulation of a single-server queue (M/M/1).\n\n    Args:\n        lam: The arrival rate (lambda) in s^-1.\n        mu: The service rate (mu) in s^-1.\n        T_end: The simulation end time in seconds.\n        f1: Boolean flag to enable the negative queue fault.\n        f2: Boolean flag to enable the drop arrival fault.\n        k: The index of the arrival to drop for the f2 fault.\n\n    Returns:\n        A boolean indicating if any invariant violation was detected.\n    \"\"\"\n    # Set the random seed for reproducibility in this specific run.\n    np.random.seed(42)\n\n    # State variables\n    current_time = 0.0\n    queue_length = 0\n    # server_busy is equivalent to B(t), where 1 is busy and 0 is idle.\n    server_busy = False\n    cumulative_arrivals = 0\n    cumulative_departures = 0\n    \n    # Internal counters for fault logic\n    arrival_handler_calls = 0\n    departure_handler_calls = 0\n\n    violation_detected = False\n\n    # Event list: min-heap of (time, type_id, event_id)\n    # type_id: 0 for Arrival, 1 for Departure\n    # event_id: unique counter to break ties and ensure heap stability\n    event_list = []\n    event_id_counter = 0\n\n    # Schedule the first arrival if arrival rate is positive\n    if lam > 0:\n        interarrival_time = np.random.exponential(scale=1.0/lam)\n        heapq.heappush(event_list, (interarrival_time, 0, event_id_counter))\n        event_id_counter += 1\n\n    # Main simulation loop\n    while event_list:\n        event_time, event_type_id, _ = heapq.heappop(event_list)\n        \n        # Stop if simulation time exceeds T_end\n        if event_time > T_end:\n            break\n\n        current_time = event_time\n\n        # --- Event Handlers ---\n        if event_type_id == 0:  # Arrival Event\n            arrival_handler_calls += 1\n            \n            # Process arrival into system; A(t) increment is conditional on fault f2\n            if not server_busy:\n                server_busy = True\n                service_time = np.random.exponential(scale=1.0/mu)\n                departure_time = current_time + service_time\n                heapq.heappush(event_list, (departure_time, 1, event_id_counter))\n                event_id_counter += 1\n            else:\n                queue_length += 1\n            \n            # Fault f2: on k-th arrival, do not increment cumulative_arrivals\n            if not(f2 and arrival_handler_calls == k):\n                cumulative_arrivals += 1\n            \n            # Schedule the next arrival\n            if lam > 0:\n                interarrival_time = np.random.exponential(scale=1.0/lam)\n                next_arrival_time = current_time + interarrival_time\n                heapq.heappush(event_list, (next_arrival_time, 0, event_id_counter))\n                event_id_counter += 1\n\n        elif event_type_id == 1:  # Departure Event\n            departure_handler_calls += 1\n            cumulative_departures += 1\n\n            if queue_length > 0:\n                queue_length -= 1\n                # Server remains busy, start service for next in queue\n                service_time = np.random.exponential(scale=1.0/mu)\n                departure_time = current_time + service_time\n                heapq.heappush(event_list, (departure_time, 1, event_id_counter))\n                event_id_counter += 1\n            else:\n                server_busy = False\n\n        # --- Invariant Assertion ---\n        # The monitor checks the state, which may be maliciously altered.\n        q_for_check = queue_length\n\n        # Fault f1: On first departure, set Q(t) to -1 before check.\n        if f1 and event_type_id == 1 and departure_handler_calls == 1:\n            q_for_check = -1\n\n        # Invariant 1: Non-negativity of queue length, Q(t) >= 0.\n        if q_for_check  0:\n            violation_detected = True\n\n        # Invariant 2: Conservation of entities, S(t) + D(t) = A(t).\n        # S(t) is calculated based on the state visible to the monitor,\n        # which includes any faulted values.\n        # S(t) = Q(t) + B(t), where B(t) is 1 if server is busy, 0 otherwise.\n        s_for_check = q_for_check + (1 if server_busy else 0)\n        if s_for_check + cumulative_departures != cumulative_arrivals:\n            violation_detected = True\n\n        if violation_detected:\n            break\n\n    return violation_detected\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (lambda, mu, T_end, f1, f2, k)\n        (1.5, 2.0, 10.0, False, False, 3),  # Case 1: Happy path\n        (0.0, 1.0, 5.0, False, False, 3),   # Case 2: No arrivals\n        (10.0, 100.0, 1.0, False, False, 3),# Case 3: Fast service\n        (0.5, 0.5, 10.0, True, False, 3),   # Case 4: Negative queue fault\n        (2.0, 3.0, 10.0, False, True, 3)    # Case 5: Drop arrival fault\n    ]\n\n    results = []\n    for case in test_cases:\n        lam, mu, T_end, f1, f2, k = case\n        result = run_simulation(lam, mu, T_end, f1, f2, k)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3119919"}, {"introduction": "现实世界中的系统常常需要优先处理紧急任务。这个实践将挑战一个高级且功能强大的调度机制：抢占式优先队列。你将学习如何管理一个动态的事件日历，其中的事件可以被取消或重新调度 [@problem_id:3119930]，这是模拟操作系统调度器或急诊室运作等复杂系统的关键技能。", "problem": "您必须实现一个单服务器系统的离散事件仿真（DES），该系统采用抢占式恢复静态优先级调度策略。该仿真必须维护一个正确的事件日历，支持显式抢占，包括级联抢占。您的任务是编写一个完整、可运行的程序，该程序针对一组固定的作业集测试套件，对系统进行仿真并验证一组不变量。程序必须输出单行，其中包含一个布尔值列表，每个测试用例对应一个布尔值，表示该测试用例的所有不变量是否都成立。\n\n系统描述和基本原理：\n- 离散事件仿真（DES）仅在离散事件发生时推进仿真时钟。核心状态由事件日历（一个优先队列）驱动，状态转换在事件发生时刻瞬时完成。基本原理是事件调度范式和抢占式恢复优先队列的定义。\n- 系统有一个单服务器。时间是连续的，并由一个实值仿真时钟 $t \\in \\mathbb{R}_{\\ge 0}$ 表示。\n- 每个作业 $j$ 由一个四元组 $(\\text{id}_j, a_j, d_j, p_j)$ 定义，其中 $\\text{id}_j$ 是唯一的整数标识符，$a_j$ 是到达时间，$d_j$ 是所需服务时长，$p_j$ 是静态优先级。较小的优先级数值意味着较高的调度优先权：如果 $p_i  p_k$，则作业 $i$ 的优先级高于作业 $k$。\n- 抢占式恢复策略：当一个作业在时间 $t$ 到达时，如果服务器空闲，它会立即开始；如果服务器正忙于处理作业 $r$，而到达的作业 $j$ 具有更高的优先级，即 $p_j  p_r$，则 $r$ 被抢占。作业 $r$ 的剩余处理时间会扣除其已执行的服务量，然后 $r$ 被放回就绪队列；新作业 $j$ 在时间 $t$ 立即开始。服务是可恢复且无损的：如果作业 $r$ 在恢复时有剩余时间 $x$，它需要恰好 $x$ 个单位的服务才能完成。\n- 事件日历：存在两种事件类型——到达和完成。日历是一个优先队列，按 $(\\text{time}, \\text{kind})$ 进行字典序排序，当事件同时发生时，到达事件先于完成事件处理。在同时到达的事件中，较小的 $p_j$ 优先处理；若优先级相同，则按到达列表的顺序递增处理。为支持安全抢占，完成事件必须可通过令牌化（tokenization）取消：每个已调度的完成事件都携带一个令牌，该令牌在完成事件触发时必须与作业的当前令牌匹配；否则，该完成事件是过时的，必须被忽略。\n- 在相同时间 $t$ 的平局处理：在考虑时间 $t$ 的任何完成事件之前，处理所有在时间 $t$ 到达的事件。这确保了新到达的更高优先级作业可以抢占一个本应在同一时间 $t$ 完成的作业。如果一个作业的剩余时间恰好在抢占瞬间达到 $0$，则将其视为在那个时间 $t$ 立即完成。\n\n每个测试用例需要验证的不变量：\n- I$1$：单调时间：从日历中弹出的事件时间序列是非递减的。形式上，如果 $t_0, t_1, \\dots, t_m$ 是弹出事件的时间，那么对所有 $k$ 都有 $t_{k+1} \\ge t_k$。\n- I$2$：运行作业的唯一性：在任何瞬间 $t$，单个服务器上最多只有一个正在运行的作业。\n- I$3$：单作业核算：对于每个作业 $j$，其获得的总服务量等于其服务时长，即 $\\text{worked}_j = d_j$，并且在完成时剩余时间为 $0$。\n- I$4$：系统级核算：服务器的总累计繁忙时间等于 $\\sum_j d_j$。累计繁忙时间是集合 $\\{ t \\mid \\text{服务器在时间 } t \\text{ 处于繁忙状态} \\}$ 的度量；您必须通过对状态变化进行积分来计算它，而不是直接对每个作业的服务时长求和。\n- I$5$：安全取消：没有过时的完成事件会改变状态。通过为每个作业 $j$ 分配一个令牌 $\\tau_j \\in \\mathbb{N}$ 来实现这一点，每当为 $j$ 调度一个新的完成事件时，该令牌就会递增；一个带有令牌 $\\hat{\\tau}$ 的弹出完成事件必须被忽略，除非 $\\hat{\\tau} = \\tau_j$ 并且该作业当前正在运行。\n\n需要实现的事件排序规则：\n- 日历排序：当时间相同时，到达事件先于完成事件。\n- 对于在同一时间 $t$ 到达的事件，按 $p_j$ 递增排序；若优先级相同，则按该测试用例的输入顺序处理。\n- 启动一个剩余时间为 $0$ 的作业，会导致其在同一时间 $t$ 立即完成，而无需发布完成事件。\n\n测试套件：\n每个测试用例都是一个 $(\\text{id}, a, d, p)$ 四元组的列表。所有时间都使用任意一致的单位；输出中不需要物理单位，因为最终输出是布尔值。\n- 测试用例 A（理想路径，无抢占）：\n  - $[(0, 0, 2, 2), (1, 3, 1, 3), (2, 4, 1.5, 3)]$。\n- 测试用例 B（单次抢占）：\n  - $[(0, 0, 5, 3), (1, 1, 2, 1)]$。\n- 测试用例 C（级联抢占）：\n  - $[(0, 0, 10, 4), (1, 1, 4, 3), (2, 2, 1, 2), (3, 2.5, 0.5, 1), (4, 6, 2, 4)]$。\n- 测试用例 D（同时到达事件和一个零时长作业在完成时间点）：\n  - $[(0, 0, 2, 2), (1, 0, 1, 1), (2, 1, 0, 0), (3, 1, 1, 3)]$。\n\n需要实现的内容：\n- 一个如上所述的完整 DES 引擎，包含事件日历、按静态优先级排序的就绪队列、支持可恢复服务的显式抢占，以及令牌化的完成事件取消机制。\n- 程序必须运行所有四个测试用例，为每个用例验证不变量 I$1$–I$5$，并生成一个单行输出，该输出是一个 Python 列表字面量，按 $[A, B, C, D]$ 的顺序包含恰好四个布尔值，指示每个测试用例的所有不变量是否成立。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如，“[True,False,True,True]”。不允许有其他输出。", "solution": "用户在离散事件仿真（DES）领域提供了一个定义明确的问题。任务是为一个具有静态优先级、抢占式恢复调度策略的单服务器排队系统实现一个仿真。该实现必须针对几个测试用例，通过一组全面的不变量进行验证。\n\n### 问题有效性判定\n问题陈述是**有效的**。它在科学上基于排队系统和离散事件仿真的既有理论。问题定义良好，对系统组件、状态转换和事件排序规则有清晰明确的定义。需求是自洽且一致的，为构建正确的仿真模型提供了所有必要的信息。该任务是计算科学领域一个标准的、非平凡的练习，需要仔细的算法设计来处理抢占、并发事件和状态管理。\n\n### 解决方案设计\n该解决方案是一个用 Python 实现的离散事件仿真引擎。设计围绕一个 `Simulator` 类展开，该类封装了仿真状态和逻辑。仿真的核心是一个事件驱动循环，它处理来自按时间排序的事件日历中的事件。\n\n#### 数据结构\n1.  **作业状态**：每个作业 $j$ 由一个数据结构表示，该结构存储其定义参数 $(\\text{id}_j, a_j, d_j, p_j)$ 及其动态状态：剩余服务时长、已获得的总服务量，以及用于处理抢占的取消令牌 $\\tau_j$。\n\n2.  **事件日历**：一个最小优先队列，使用 Python 的 `heapq` 模块实现，用于存储未来事件。事件是按字典序排序的元组，确保按照指定的规则进行正确处理。事件的元组格式为 $(\\text{time}, \\text{type}, \\dots)$。\n    -   **到达**事件由元组 $(\\text{time}, 0, \\text{priority}, \\text{input\\_order}, \\text{job\\_id})$ 表示。数字类型 $0$ 确保在同一时间，到达事件在完成事件之前被处理。作业的优先级和原始输入顺序被包含在内，以解决同时到达事件的平局问题。\n    -   **完成**事件由 $(\\text{time}, 1, \\text{job\\_id}, \\text{token})$ 表示。类型 $1$ 使其优先级低于到达事件。令牌用于在执行时验证事件的有效性。\n\n3.  **就绪队列**：一个同样用 `heapq` 实现的最小优先队列，用于存储已到达但未被服务的作业。作业按优先级排序，平局时按其原始输入顺序解决。元组格式为 $(\\text{priority}, \\text{input\\_order}, \\text{job\\_id})$。\n\n#### 仿真算法\n仿真通过将仿真时钟 $t$ 推进到下一个事件的时间来进行。核心算法对每个不同的事件时间遵循一个三阶段过程。\n\n1.  **状态更新阶段**：时钟 $t$ 从其前一个值 $t_{prev}$ 推进到新的事件时间 $t_{new}$。计算经过的时间 $\\Delta t = t_{new} - t_{prev}$。如果在此期间有一个作业在服务器上运行，其剩余时长将减去 $\\Delta t$，其已获得的总服务量将增加。服务器的总繁忙时间也会更新。\n\n2.  **事件处理阶段**：从事件日历中提取所有安排在当前时间 $t_{new}$ 的事件。它们被顺序处理（日历的排序规则已经正确地对它们进行了排序）。\n    -   **到达**：将到达的作业添加到就绪队列中。\n    -   **完成**：检查事件的令牌是否与作业的当前令牌匹配，并验证该作业确实是当前正在运行的作业。如果事件是过时的（令牌不匹配或另一个作业正在运行），则将其丢弃。否则，该作业被标记为完成，服务器被标记为空闲。问题将此检查指定为不变量 I5。\n\n3.  **调度阶段**：在处理完时间 $t_{new}$ 的所有事件后，仿真器做出调度决策。\n    -   如果当前有作业正在运行，则将其优先级与就绪队列中最高优先级的作业进行比较。如果就绪队列中的作业具有严格更高的优先级（即更小的优先级数值），则抢占正在运行的作业。抢占操作包括更新作业的取消令牌（使其旧的完成事件无效）并将其从服务器移至就绪队列。\n    -   如果服务器空闲（因为一个作业刚刚完成或被抢占）且就绪队列不为空，则从就绪队列中移除最高优先级的作业并开始服务。\n    -   当一个作业开始服务时，会调度一个新的完成事件并将其添加到事件日历中。事件时间为 $t_{new} + d_{rem}$，其中 $d_{rem}$ 是作业的剩余时长，事件用作业的当前令牌进行标记。对于剩余时长为零的作业，通过立即完成它们而不调度事件来处理这种特殊情况。\n\n#### 不变量验证\n在每次仿真运行结束时，会检查以下不变量：\n-   **I1（单调时间）**：维护所有弹出事件时间的记录。检查该列表以确保其非递减。\n-   **I2（运行作业的唯一性）**：这由仿真器的设计保证，该设计使用单个变量来跟踪运行作业的 ID。根据构造，此不变量被认为是 `True`。\n-   **I3（单作业核算）**：对每个作业，验证其获得的总服务量等于其原始时长，并且其剩余时长为零，误差在小的浮点容差 $\\epsilon = 10^{-9}$ 之内。\n-   **I4（系统级核算）**：将在仿真过程中累积的服务器总繁忙时间与所有作业原始时长的总和进行比较。它们必须在容差 $\\epsilon$ 内相等。\n-   **I5（安全取消）**：此不变量由事件处理阶段的核心逻辑来保证，该逻辑根据令牌匹配规则严格忽略过时的完成事件。通过仿真器的正确构造，此不变量也被认为是 `True`。\n\n每个测试用例的最终输出是一个布尔值，指示所有五个不变量是否都成立。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport heapq\n\n# Per the execution environment, numpy and scipy would be available,\n# but are not necessary for this problem. The standard library's\n# heapq is sufficient and appropriate.\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n\n    TOLERANCE = 1e-9  # Tolerance for floating-point comparisons\n\n    class Job:\n        \"\"\"Represents a job in the simulation.\"\"\"\n        def __init__(self, id, arrival, duration, priority, original_index):\n            self.id = id\n            self.arrival = float(arrival)\n            self.duration = float(duration)\n            self.priority = int(priority)\n            self.original_index = int(original_index)\n\n            # Dynamic state\n            self.remaining_duration = float(duration)\n            self.service_received = 0.0\n            self.token = 0\n            self.completion_time = None\n\n    class Simulator:\n        \"\"\"\n        Implements the Discrete Event Simulation for a single-server,\n        preemptive-resume, static-priority system.\n        \"\"\"\n        def __init__(self):\n            # Simulation state\n            self.time = 0.0\n            self.jobs = {}\n            self.event_calendar = []  # (time, type, prio, idx, job_id) or (time, type, job_id, token)\n            self.ready_queue = []  # (priority, original_index, job_id)\n            self.running_job_id = None\n\n            # Invariant tracking\n            self.total_server_busy_time = 0.0\n            self.event_times_log = []\n\n        def simulate(self, job_specs):\n            \"\"\"\n            Runs the full simulation for a given set of jobs.\n            \n            Args:\n                job_specs: A list of (id, arrival, duration, priority) tuples.\n            \n            Returns:\n                A boolean indicating if all invariants held true.\n            \"\"\"\n            # 1. Initialization\n            for i, spec in enumerate(job_specs):\n                job_id, arrival, duration, priority = spec\n                job = Job(job_id, arrival, duration, priority, i)\n                self.jobs[job_id] = job\n                \n                # Event tuple: (time, type, priority, original_index, job_id)\n                # type 0 for arrival, 1 for completion.\n                # This ordering handles all tie-breaking rules.\n                event = (job.arrival, 0, job.priority, job.original_index, job.id)\n                heapq.heappush(self.event_calendar, event)\n\n            # 2. Main Simulation Loop\n            while self.event_calendar:\n                # --- State Update Phase ---\n                next_event_time = self.event_calendar[0][0]\n                delta_t = next_event_time - self.time\n                if self.running_job_id is not None:\n                    job = self.jobs[self.running_job_id]\n                    job.service_received += delta_t\n                    job.remaining_duration -= delta_t\n                    self.total_server_busy_time += delta_t\n                self.time = next_event_time\n\n                # --- Event Processing Phase ---\n                newly_arrived_jobs = []\n                while self.event_calendar and self.event_calendar[0][0] == self.time:\n                    event = heapq.heappop(self.event_calendar)\n                    self.event_times_log.append(event[0])\n                    \n                    event_type = event[1]\n                    if event_type == 0:  # Arrival\n                        _, _, _, _, job_id = event\n                        newly_arrived_jobs.append(self.jobs[job_id])\n                    else:  # Completion\n                        _, _, job_id, token = event\n                        job = self.jobs[job_id]\n                        # Invariant I5 check:\n                        if token == job.token and self.running_job_id == job_id:\n                            job.completion_time = self.time\n                            job.remaining_duration = 0.0\n                            self.running_job_id = None\n                        # Stale events are ignored, upholding invariant I5.\n\n                for job in newly_arrived_jobs:\n                    heapq.heappush(self.ready_queue, (job.priority, job.original_index, job.id))\n\n                # --- Scheduling Phase ---\n                # A running job might have just finished or new higher-prio jobs arrived.\n                # Check for preemption if a job is running.\n                if self.running_job_id is not None and self.ready_queue:\n                    current_job = self.jobs[self.running_job_id]\n                    best_ready_job_spec = self.ready_queue[0]\n                    if best_ready_job_spec[0]  current_job.priority:\n                        # Preempt the current job\n                        current_job.token += 1\n                        heapq.heappush(self.ready_queue, (current_job.priority, current_job.original_index, current_job.id))\n                        self.running_job_id = None\n\n                # If server is idle, start a new job. Loop to handle zero-duration jobs.\n                while self.running_job_id is None and self.ready_queue:\n                    _, _, job_id_to_start = heapq.heappop(self.ready_queue)\n                    job = self.jobs[job_id_to_start]\n                    \n                    self.running_job_id = job.id\n                    if job.remaining_duration > TOLERANCE:\n                        completion_time = self.time + job.remaining_duration\n                        event = (completion_time, 1, job.id, job.token)\n                        heapq.heappush(self.event_calendar, event)\n                    else:\n                        job.completion_time = self.time\n                        job.remaining_duration = 0.0\n                        self.running_job_id = None # continues loop\n\n            return self.verify_invariants()\n\n        def verify_invariants(self):\n            # I1: Monotonic time\n            i1_ok = all(self.event_times_log[i] = self.event_times_log[i+1] for i in range(len(self.event_times_log) - 1))\n\n            # I2: Uniqueness of running job (guaranteed by design)\n            i2_ok = True\n\n            # I3: Per-job accounting\n            i3_ok = True\n            for job in self.jobs.values():\n                if abs(job.service_received - job.duration) > TOLERANCE or abs(job.remaining_duration) > TOLERANCE:\n                    i3_ok = False\n                    break\n            \n            # I4: System-wide accounting\n            total_job_durations = sum(j.duration for j in self.jobs.values())\n            i4_ok = abs(self.total_server_busy_time - total_job_durations)  TOLERANCE\n            \n            # I5: Safe cancellation (guaranteed by design)\n            i5_ok = True\n            \n            return all([i1_ok, i2_ok, i3_ok, i4_ok, i5_ok])\n\n    test_cases = {\n        'A': [(0, 0, 2, 2), (1, 3, 1, 3), (2, 4, 1.5, 3)],\n        'B': [(0, 0, 5, 3), (1, 1, 2, 1)],\n        'C': [(0, 0, 10, 4), (1, 1, 4, 3), (2, 2, 1, 2), (3, 2.5, 0.5, 1), (4, 6, 2, 4)],\n        'D': [(0, 0, 2, 2), (1, 0, 1, 1), (2, 1, 0, 0), (3, 1, 1, 3)],\n    }\n    \n    results = []\n    # Process test cases in specified order 'A', 'B', 'C', 'D'\n    for key in sorted(test_cases.keys()):\n        sim = Simulator()\n        result = sim.simulate(test_cases[key])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3119930"}]}