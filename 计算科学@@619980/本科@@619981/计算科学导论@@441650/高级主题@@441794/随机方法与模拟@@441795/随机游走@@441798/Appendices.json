{"hands_on_practices": [{"introduction": "我们从一个随机游走理论中的经典问题——“赌徒破产”问题——开始。这个练习要求我们计算一个在一维有界区间内运动的简单对称随机游走，在到达一个边界（例如 $0$）之前先到达另一个边界（$N$）的概率。通过基于第一步分析建立和求解一个简单的差分方程，你可以掌握分析随机游走问题的基本技巧，并体会到从基本原理推导出精确解的乐趣。[@problem_id:3079249]", "problem": "考虑一个在整数上的一维简单对称随机游走 $\\{S_{n}\\}_{n \\geq 0}$，起始于 $S_{0}=i$（其中 $0  i  N$）。游走在 $0$ 和 $N$ 处有吸收边界。求该游走在 $N$ 处被吸收的概率。", "solution": "### 第1步：提取已知条件\n- 该过程是一个在整数集 $\\mathbb{Z}$ 上的一维简单对称随机游走 $\\{S_{n}\\}_{n \\geq 0}$。\n- 初始状态为 $S_{0}=i$，其中 $i$ 是一个满足 $0  i  N$ 的整数。\n- 过程在达到 $0$ 或 $N$ 时停止。这些是吸收边界。\n- 我们想求的是从 $i$ 开始，在 $N$ 处被吸收的概率。我们把这个概率记为 $p_i$。\n\n### 第2步：建立递推关系\n$p_i$ 是从 $i$ 开始，最终到达 $N$ 的概率。我们可以通过考虑第一步来建立一个关于 $p_i$ 的递推关系。从位置 $i$ 开始，游走者下一步将以 $1/2$ 的概率移动到 $i+1$，以 $1/2$ 的概率移动到 $i-1$。\n- 如果游走者移动到 $i+1$，那么他此后到达 $N$ 的概率就是 $p_{i+1}$。\n- 如果游走者移动到 $i-1$，那么他此后到达 $N$ 的概率就是 $p_{i-1}$。\n根据全概率公式，我们可以写出：\n$$ p_i = \\frac{1}{2} p_{i+1} + \\frac{1}{2} p_{i-1} $$\n这个关系对所有内部点 $i \\in \\{1, 2, \\dots, N-1\\}$ 都成立。\n\n### 第3步：确定边界条件\n我们需要确定 $p_i$ 在边界上的值。\n- 如果游走者从 $i=0$ 开始，他已经在一个吸收边界上。他没有机会到达 $N$，所以他到达 $N$ 的概率为 0。因此，$p_0 = 0$。\n- 如果游走者从 $i=N$ 开始，他已经在他想要到达的目标处。因此，他到达 $N$ 的概率为 1。因此，$p_N = 1$。\n\n### 第4步：求解差分方程\n我们现在有一个二阶线性差分方程和两个边界条件：\n$$ p_i = \\frac{1}{2} p_{i+1} + \\frac{1}{2} p_{i-1} \\quad \\text{for } 0  i  N $$\n$$ p_0 = 0, \\quad p_N = 1 $$\n将方程重新整理为 $2p_i = p_{i+1} + p_{i-1}$，或者 $p_{i+1} - p_i = p_i - p_{i-1}$。这表明相邻概率之间的差是恒定的。换句话说，$p_i$ 是一个关于 $i$ 的线性函数（算术级数）。\n因此，我们可以写出 $p_i = ai + b$ 的形式，其中 $a$ 和 $b$ 是待定常数。\n我们使用边界条件来求解 $a$ 和 $b$：\n- 使用 $p_0 = 0$：$a(0) + b = 0 \\implies b=0$。\n- 使用 $p_N = 1$：$a(N) + b = 1$。\n将 $b=0$ 代入第二个方程，我们得到 $aN = 1$，所以 $a = 1/N$。\n因此，最终解为：\n$$ p_i = \\frac{i}{N} $$\n\n### 第5步：验证\n最终的表达式是 $p_i = i/N$。\n- 边界条件：当 $i=0$ 时，$p_0=0/N=0$。当 $i=N$ 时，$p_N=N/N=1$。边界条件满足。\n- 递推关系：$\\frac{1}{2} p_{i+1} + \\frac{1}{2} p_{i-1} = \\frac{1}{2} \\frac{i+1}{N} + \\frac{1}{2} \\frac{i-1}{N} = \\frac{1}{2N} (i+1+i-1) = \\frac{2i}{2N} = \\frac{i}{N} = p_i$。递推关系也满足。\n解是正确的。", "answer": "$$\\boxed{\\frac{i}{N}}$$", "id": "3079249"}, {"introduction": "在知道了随机游走将在何处结束之后，一个自然而然的进阶问题是：平均需要多长时间才能到达边界？这个问题旨在计算游走被吸收的期望时间。我们将运用一个更强大、更精妙的工具——鞅论和可选停止定理——来解决这个问题，特别是通过构造一个巧妙的鞅 $S_n^2 - n$ 来优雅地求解，这展示了高等随机过程工具在解决看似复杂问题时的威力。[@problem_id:3079267]", "problem": "考虑离散时间整数上的简单对称随机游走。设 $N \\in \\mathbb{N}$ 是一个固定的数，并设 $S_{0} = i$，其中 $i \\in \\{0, 1, \\dots, N\\}$。对于 $n \\geq 1$，定义 $S_{n} = S_{n-1} + X_{n}$，其中 $(X_{n})_{n \\geq 1}$ 是独立同分布的随机变量，满足 $\\mathbb{P}(X_{n} = 1) = \\mathbb{P}(X_{n} = -1) = \\tfrac{1}{2}$。定义到达时间\n$$\n\\tau_{0} = \\inf\\{n \\geq 0 : S_{n} = 0\\}, \\qquad \\tau_{N} = \\inf\\{n \\geq 0 : S_{n} = N\\},\n$$\n和吸收时间 $\\tau = \\tau_{0} \\wedge \\tau_{N}$。请仅使用鞅的基本定义和有界停止时的可选停止定理（OST），推导期望吸收时间 $E_{i}[\\tau]$ 作为 $i$ 和 $N$ 的函数的闭式表达式。你的最终答案必须是单一的解析表达式。不要提供直接揭示最终表达式的中间公式；相反，应从第一性原理出发论证每一步。无需进行舍入。", "solution": "问题要求计算一个从 $S_{0} = i$ 开始、在 $0$ 和 $N$ 处有吸收壁的整数上的简单对称随机游走的期望吸收时间，记为 $E_{i}[\\tau]$。吸收时间为 $\\tau = \\inf\\{n \\geq 0 : S_{n} \\in \\{0, N\\}\\}$。本解答将使用鞅理论和可选停止定理（OST）进行推导。\n\n首先，我们来形式化这个过程。随机游走定义为 $S_{n} = S_{n-1} + X_{n}$（对于 $n \\geq 1$），其中 $S_{0}=i$。步长 $(X_{n})_{n \\geq 1}$ 是独立同分布的随机变量，满足 $\\mathbb{P}(X_{n} = 1) = \\mathbb{P}(X_{n} = -1) = 1/2$。令 $\\mathcal{F}_{n} = \\sigma(X_{1}, \\dots, X_{n})$ 为该过程的自然信息流，其中 $\\mathcal{F}_{0} = \\{\\emptyset, \\Omega\\}$。在从 $S_0=i$ 开始的条件下的期望记为 $E_i[\\cdot]$。\n\n可选停止定理（OST）指出，对于一个鞅 $(M_{n})_{n \\geq 0}$ 和一个停止时 $T$，在某些条件下，有 $E[M_{T}] = E[M_{0}]$。题目要求使用针对有界停止时的可选停止定理。停止时 $\\tau$ 并不是确定性有界的。然而，对于有限区间上的一维随机游走，已知 $\\tau$ 是几乎必然有限的，且 $E_i[\\tau]  \\infty$。OST 的一个严格应用涉及考虑有界停止时 $\\tau_{k} = \\tau \\wedge k = \\min(\\tau, k)$，其中 $k \\in \\mathbb{N}$。对 $\\tau_k$ 应用 OST 得到 $E[M_{\\tau_k}] = E[M_0]$。然后我们可以令 $k \\to \\infty$ 取极限，并且在满足适当的收敛条件（例如控制收敛定理或单调收敛定理）的情况下，我们可以推断出 $E[M_{\\tau}] = E[M_0]$。我们将在此理解的基础上进行推导。\n\n我们的推导需要两个不同的鞅。\n\n首先，我们确定在每个边界上的吸收概率。设 $p_{i} = \\mathbb{P}_{i}(S_{\\tau} = N)$ 为游走从 $i$ 出发，在 $N$ 处被吸收的概率。因此，$\\mathbb{P}_{i}(S_{\\tau} = 0) = 1 - p_{i}$。为了求 $p_{i}$，我们考虑过程 $(S_{n})_{n \\geq 0}$ 本身。我们来验证它是否是关于信息流 $(\\mathcal{F}_{n})_{n \\geq 0}$ 的一个鞅。对于任意 $n \\geq 1$：\n$$\nE[S_{n} | \\mathcal{F}_{n-1}] = E[S_{n-1} + X_{n} | \\mathcal{F}_{n-1}]\n$$\n由于 $S_{n-1}$ 是 $\\mathcal{F}_{n-1}$-可测的，且 $X_{n}$ 独立于 $\\mathcal{F}_{n-1}$：\n$$\nE[S_{n} | \\mathcal{F}_{n-1}] = S_{n-1} + E[X_{n}]\n$$\n单步的期望为 $E[X_{n}] = (1) \\cdot \\mathbb{P}(X_{n}=1) + (-1) \\cdot \\mathbb{P}(X_{n}=-1) = 1 \\cdot \\frac{1}{2} - 1 \\cdot \\frac{1}{2} = 0$。\n因此，$E[S_{n} | \\mathcal{F}_{n-1}] = S_{n-1}$，这证实了 $(S_{n})_{n \\geq 0}$ 是一个鞅。\n\n该鞅的增量是有界的，即 $|S_{n} - S_{n-1}| = |X_{n}| = 1$。停止时 $\\tau$ 具有有限的期望。这些是可选停止定理适用于鞅 $S_n$ 和停止时 $\\tau$ 的充分条件。应用可选停止定理：\n$$\nE_{i}[S_{\\tau}] = E_{i}[S_{0}] = i\n$$\n在吸收时间 $\\tau$ 的位置的期望值为：\n$$\nE_{i}[S_{\\tau}] = N \\cdot \\mathbb{P}_{i}(S_{\\tau} = N) + 0 \\cdot \\mathbb{P}_{i}(S_{\\tau} = 0) = N \\cdot p_{i}\n$$\n令这两个 $E_{i}[S_{\\tau}]$ 的表达式相等，我们得到 $N \\cdot p_{i} = i$，从而得出吸收概率：\n$$\np_{i} = \\frac{i}{N}\n$$\n\n第二，为了求出期望时间 $E_{i}[\\tau]$，我们需要一个包含时间指标 $n$ 的鞅。让我们考虑过程 $M_{n} = S_{n}^2 - n$。我们来验证它是否是一个鞅。对于任意 $n \\geq 1$：\n$$\nE[M_{n} | \\mathcal{F}_{n-1}] = E[S_{n}^2 - n | \\mathcal{F}_{n-1}] = E[S_{n}^2 | \\mathcal{F}_{n-1}] - n\n$$\n我们展开 $S_{n}^2 = (S_{n-1} + X_{n})^2 = S_{n-1}^2 + 2S_{n-1}X_{n} + X_{n}^2$。\n$$\nE[S_{n}^2 | \\mathcal{F}_{n-1}] = E[S_{n-1}^2 + 2S_{n-1}X_{n} + X_{n}^2 | \\mathcal{F}_{n-1}]\n$$\n利用条件期望的线性和 $S_{n-1}$ 是 $\\mathcal{F}_{n-1}$-可测的事实：\n$$\nE[S_{n}^2 | \\mathcal{F}_{n-1}] = S_{n-1}^2 + 2S_{n-1}E[X_{n} | \\mathcal{F}_{n-1}] + E[X_{n}^2 | \\mathcal{F}_{n-1}]\n$$\n如前所述，$E[X_{n} | \\mathcal{F}_{n-1}] = E[X_{n}] = 0$。对于 $E[X_{n}^2 | \\mathcal{F}_{n-1}]$ 项，我们有 $E[X_{n}^2] = (1)^2 \\cdot \\frac{1}{2} + (-1)^2 \\cdot \\frac{1}{2} = 1$。\n将这些结果代回：\n$$\nE[S_{n}^2 | \\mathcal{F}_{n-1}] = S_{n-1}^2 + 2S_{n-1}(0) + 1 = S_{n-1}^2 + 1\n$$\n现在我们可以完成 $E[M_{n} | \\mathcal{F}_{n-1}]$ 的计算：\n$$\nE[M_{n} | \\mathcal{F}_{n-1}] = (S_{n-1}^2 + 1) - n = S_{n-1}^2 - (n-1) = M_{n-1}\n$$\n这证明了 $(M_{n})_{n \\geq 0} = (S_{n}^2 - n)_{n \\geq 0}$ 确实是一个鞅。\n\n现在我们将可选停止定理应用于鞅 $M_{n}$ 和停止时 $\\tau$。由于 $E_i[\\tau]  \\infty$ 并且鞅的增量在有限时间区间内是有界的，因此满足可选停止定理的条件。\n$$\nE_{i}[M_{\\tau}] = E_{i}[M_{0}]\n$$\n初始值为 $M_{0} = S_{0}^2 - 0 = i^2$。\n在停止时的值为 $M_{\\tau} = S_{\\tau}^2 - \\tau$。其期望为：\n$$\nE_{i}[M_{\\tau}] = E_{i}[S_{\\tau}^2 - \\tau] = E_{i}[S_{\\tau}^2] - E_{i}[\\tau]\n$$\n令这两个期望的表达式相等，得到：\n$$\nE_{i}[S_{\\tau}^2] - E_{i}[\\tau] = i^2\n$$\n我们可以重新整理这个等式来表示期望吸收时间：\n$$\nE_{i}[\\tau] = E_{i}[S_{\\tau}^2] - i^2\n$$\n为了完成解答，我们必须计算 $E_{i}[S_{\\tau}^2]$。在吸收时的位置 $S_{\\tau}$ 只能是 $0$ 或 $N$。\n$$\nE_{i}[S_{\\tau}^2] = (N^2) \\cdot \\mathbb{P}_{i}(S_{\\tau} = N) + (0^2) \\cdot \\mathbb{P}_{i}(S_{\\tau} = 0) = N^2 \\cdot p_{i}\n$$\n使用我们之前推导出的吸收概率结果 $p_{i} = i/N$：\n$$\nE_{i}[S_{\\tau}^2] = N^2 \\cdot \\left(\\frac{i}{N}\\right) = Ni\n$$\n最后，将此结果代入我们关于 $E_{i}[\\tau]$ 的表达式中：\n$$\nE_{i}[\\tau] = Ni - i^2\n$$\n这可以因式分解，得到期望吸收时间作为起始位置 $i$ 和边界 $N$ 的函数的最终闭式表达式。\n$$\nE_{i}[\\tau] = i(N-i)\n$$\n这个结果对于任何起始位置 $i \\in \\{0, 1, \\dots, N\\}$ 都有效。如果 $i=0$ 或 $i=N$，起始位置已经在吸收边界上，所以 $\\tau=0$，公式也正确地分别得到 $0(N-0)=0$ 和 $N(N-N)=0$。", "answer": "$$\n\\boxed{i(N-i)}\n$$", "id": "3079267"}, {"introduction": "理论模型的美妙在于其理想化的假设，但在计算实践中，我们必须面对现实的挑战。这个动手练习将我们的注意力从理论转向实际的计算机模拟，聚焦于一个核心问题：如何在并行计算中生成真正独立的随机游走？你将亲手实现并对比几种不同的伪随机数生成器（PRNG）播种策略，量化由于不当处理所导致的统计伪影（spurious correlations），并学习如何通过使用独立流或跨越（leapfrogging）等标准技术来保证模拟结果的有效性。[@problem_id:3183815]", "problem": "考虑一个一维随机游走，它由一系列独立同分布的步长增量构成，其中每个增量都是一个 Rademacher 随机变量，取值为 $\\{-1,+1\\}$，两种结果的概率各为 $1/2$。设 $T$ 表示用于生成 $T$ 个独立随机游走轨迹的并行线程数，设 $N$ 表示每个轨迹的步数。对于线程索引 $i \\in \\{1,\\dots,T\\}$ 和步数索引 $t \\in \\{1,\\dots,N\\}$，令 $X_{t,i} \\in \\{-1,+1\\}$ 表示线程 $i$ 在时间 $t$ 的增量，并定义线程 $i$ 的终点（$N$ 步之后的位置）为 $S_i(N) = \\sum_{t=1}^{N} X_{t,i}$。在实践中，我们使用伪随机数生成器（PRNG）来产生增量 $\\{X_{t,i}\\}$，而跨线程的粗心播种可能会在不同线程 $i \\neq j$ 的序列 $\\{X_{t,i}\\}_{t=1}^{N}$ 和 $\\{X_{t,j}\\}_{t=1}^{N}$ 之间引入相关性。您的任务是量化由跨线程共享种子引起的误差，并实现两种补救措施来减轻此类误差。\n\n从随机游走的定义和步长增量应在线程间独立的要求出发，实现三种生成机制：\n- 朴素机制：使用相同的基础种子 $s$ 为每个线程构造 $T$ 个 PRNG 实例，并直接从每个实例中为每个线程抽取 $N$ 步。\n- 独立流机制：通过一个旨在产生统计独立流的种子派生机制，从单个基础种子 $s$ 派生出 $T$ 个子种子，从而构造 $T$ 个独立的 PRNG 实例。\n- 跳跃机制：使用一个以基础种子 $s$ 初始化的单一 PRNG 实例，抽取 $T \\cdot N$ 个增量，并将子序列 $\\{X_{k}\\}_{k=i,i+T,i+2T,\\dots}$ 分配给线程 $i$，这样每个线程从其线程索引开始，每隔 $T$ 个值接收一个值。\n\n对于每种机制和参数集，计算以下诊断指标：\n1. 所有不同线程对之间的皮尔逊相关系数的平均值，\n   $$\n   \\bar{\\rho}\n   =\n   \\frac{2}{T(T-1)}\n   \\sum_{1 \\le i  j \\le T}\n   \\rho_{ij},\n   \\quad\n   \\rho_{ij}\n   =\n   \\frac{\\sum_{t=1}^{N} (X_{t,i} - \\bar{X}_i)(X_{t,j} - \\bar{X}_j)}{\\sqrt{\\sum_{t=1}^{N} (X_{t,i} - \\bar{X}_i)^2} \\sqrt{\\sum_{t=1}^{N} (X_{t,j} - \\bar{X}_j)^2}},\n   $$\n   其中 $\\bar{X}_i = \\frac{1}{N}\\sum_{t=1}^{N} X_{t,i}$ 是线程 $i$ 的样本均值。\n2. 所有不同线程对中的最大皮尔逊相关系数，\n   $$\n   \\rho_{\\max} = \\max_{1 \\le i  j \\le T} \\rho_{ij}.\n   $$\n3. 跨线程的归一化终点标准差，\n   $$\n   \\sigma_{\\text{end}} = \\frac{\\operatorname{std}\\left(\\{S_i(N)\\}_{i=1}^{T}\\right)}{\\sqrt{N}},\n   $$\n   其中 $\\operatorname{std}$ 表示 $T$ 个终点值的样本标准差。如果 $T=1$，则定义 $\\bar{\\rho} = 0$，$\\rho_{\\max} = 0$，并对单个终点使用总体标准差，此时 $\\sigma_{\\text{end}} = 0$。\n\n对所有机制和参数集使用相同固定的基础种子 $s = 123456789$。通过将均匀整数抽取 $U_{t,i} \\in \\{0,1\\}$ 映射为 $X_{t,i} = 2U_{t,i}-1$ 来生成 Rademacher 增量 $\\{-1,+1\\}$。将报告的每个浮点数四舍五入到 $6$ 位小数。\n\n测试套件：\n- 案例 1：朴素机制，$T=4$，$N=10000$。\n- 案例 2：独立流机制，$T=4$，$N=10000$。\n- 案例 3：跳跃机制，$T=4$，$N=10000$。\n- 案例 4：朴素机制，边界条件 $T=1$，$N=100$。\n- 案例 5：独立流机制，边缘条件 $T=8$，$N=50$。\n\n您的程序应生成单行输出，其中包含一个由逗号分隔的列表，用方括号括起来，每个元素对应一个测试案例的结果，并且本身是一个包含三个浮点数的列表，顺序为 $[\\bar{\\rho}, \\rho_{\\max}, \\sigma_{\\text{end}}]$。例如，您的输出应类似于 $[[a_1,b_1,c_1],[a_2,b_2,c_2],\\dots]$，所有浮点数均四舍五入到 $6$ 位小数。此问题不涉及物理单位，也不出现角度；所有浮点数必须以十进制形式报告。", "solution": "问题陈述已经过审查，并被认为是有效的。它具有科学依据，问题设定良好、客观，并包含计算唯一解所需的所有信息。该问题探讨了计算科学中的一个基本主题：正确生成并行伪随机数流，以确保蒙特卡洛模拟中的统计独立性。我们接下来进行求解。\n\n核心任务是量化用于模拟多个一维随机游走的不同并行伪随机数生成器（PRNG）播种策略所产生的统计误差。我们将实现三种不同的生成机制，并计算一组诊断指标来衡量线程间的相关性。\n\n对于给定的线程 $i \\in \\{1, \\dots, T\\}$，其一维随机游走由其在 $t$ 步后的位置 $S_i(t)$ 定义。位置在每一步由一个随机增量更新。在 $N$ 步后的最终位置（或终点）由所有增量的总和给出：\n$$\nS_i(N) = \\sum_{t=1}^{N} X_{t,i}\n$$\n增量 $X_{t,i}$ 是独立同分布（i.i.d.）的 Rademacher 随机变量，以相等的概率取值于 $\\{-1, +1\\}$，即 $P(X_{t,i}=+1) = P(X_{t,i}=-1) = 1/2$。对于一组 $T$ 个并行的独立模拟，关键假设是对于任意两个不同的线程 $i \\neq j$，增量序列 $\\{X_{t,i}\\}_{t=1}^N$ 和 $\\{X_{t,j}\\}_{t=1}^N$ 在统计上是独立的。\n\n每步增量的矩为 $E[X_{t,i}] = (+1) \\cdot (1/2) + (-1) \\cdot (1/2) = 0$ 和 $Var(X_{t,i}) = E[X_{t,i}^2] - (E[X_{t,i}])^2 = ((+1)^2 \\cdot (1/2) + (-1)^2 \\cdot (1/2)) - 0^2 = 1$。由于单次游走内各步的独立性，终点的方差为 $Var(S_i(N)) = \\sum_{t=1}^{N} Var(X_{t,i}) = N$。因此，单次游走终点的理论标准差为 $\\sqrt{N}$。\n\n我们现在将描述三种生成机制以及对诊断统计量的预期结果。\n\n1.  **朴素机制**：在这种机制中，$T$ 个并行线程中的每一个都使用完全相同的基础种子 $s$ 来初始化其自己的 PRNG 实例。由于 PRNG 是一个确定性算法，提供相同的种子保证了相同的初始状态，因此也保证了完全相同的伪随机抽取序列。这意味着对于所有步 $t$ 和所有线程 $i, j$，$X_{t,i} = X_{t,j}$。\n    -   **预期诊断结果**：步长序列的完全一致意味着完美的正线性关系。因此，对于所有 $i \\neq j$ 对，皮尔逊相关系数 $\\rho_{ij}$ 将恰好为 $1$。这将导致平均相关性 $\\bar{\\rho} = 1$ 和最大相关性 $\\rho_{\\max} = 1$。由于所有轨迹都相同，它们的终点 $S_i(N)$ 将完全相等。一组相同数字的标准差为 $0$，因此归一化终点标准差将为 $\\sigma_{\\text{end}} = 0$。这种机制是统计独立性灾难性失败的例证。\n\n2.  **独立流机制**：此方法使用专为并行应用设计的现代 PRNG 框架。单个基础种子 $s$ 用于初始化一个 `SeedSequence`，然后它“派生”出 $T$ 个子 `SeedSequence` 对象。这些子对象中的每一个都用于为一个 PRNG 实例播种。该机制旨在产生统计上独立的随机数流。\n    -   **预期诊断结果**：由于生成的步长序列被设计为独立的，样本皮尔逊相关系数 $\\rho_{ij}$ 应该是围绕 $0$ 波动的小值。对于大的 $N$，两个独立随机序列之间的样本相关系数的标准差约为 $1/\\sqrt{N}$。因此，我们预期 $\\bar{\\rho} \\approx 0$ 且 $\\rho_{\\max}$ 很小。终点 $\\{S_i(N)\\}_{i=1}^T$ 构成了一个包含 $T$ 个独立同分布随机变量的样本，每个变量的理论标准差为 $\\sqrt{N}$。因此，归一化的样本标准差 $\\sigma_{\\text{end}}$ 预期接近于 $1$。\n\n3.  **跳跃机制**：在这里，用基础种子 $s$ 初始化一个单一的 PRNG 实例。它生成一个长度为 $T \\cdot N$ 的长序列。然后将这个主序列划分给 $T$ 个线程。线程 $i$ 接收索引为 $i, i+T, i+2T, \\dots$（使用问题描述中的 1-based 索引）的值的子序列。这也被称为跨步技术。\n    -   **预期诊断结果**：对于高质量、长周期的 PRNG（例如 `numpy.random.default_rng` 中默认使用的 PCG64 生成器），通过跨步产生的子序列也预期是统计独立的。因此，与独立流机制类似，我们预计 $\\bar{\\rho} \\approx 0$，$\\rho_{\\max}$ 会很小，并且 $\\sigma_{\\text{end}} \\approx 1$。\n\n解决方案的算法如下：\n- 对于每个测试案例，由一种机制、线程数 $T$ 和步数 $N$ 指定：\n    1.  首先，处理 $T=1$ 的特殊情况。根据问题定义，诊断指标为 $[\\bar{\\rho}, \\rho_{\\max}, \\sigma_{\\text{end}}] = [0.0, 0.0, 0.0]$。\n    2.  如果 $T>1$，根据指定的机制生成 Rademacher 增量的 $T \\times N$ 矩阵 $\\{X_{t,i}\\}$。基础种子 $s = 123456789$ 将被一致地使用。Rademacher 随机变量 $X_{t,i} \\in \\{-1, +1\\}$ 通过变换 $X_{t,i} = 2U_{t,i} - 1$ 从均匀整数 $U_{t,i} \\in \\{0, 1\\}$ 生成。\n    3.  计算诊断指标：\n        a.  从 $T \\times N$ 的步长矩阵计算 $T \\times T$ 的皮尔逊相关矩阵。提取所有不同对 $i  j$ 的相关系数 $\\rho_{ij}$。计算它们的平均值 $\\bar{\\rho}$ 和最大值 $\\rho_{\\max}$。\n        b.  通过对步长矩阵的每一行求和，计算 $T$ 个线程中每一个的终点 $S_i(N)$。\n        c.  计算 $T$ 个终点的样本标准差（使用分母为 $T-1$，即在 `NumPy` 中 `ddof=1`）。\n        d.  将此标准差除以 $\\sqrt{N}$ 进行归一化，得到 $\\sigma_{\\text{end}}$。\n- 收集每个案例的最终结果，四舍五入到 $6$ 位小数，并格式化为所需的输出字符串。", "answer": "```python\nimport numpy as np\n\ndef generate_rademacher(rng, size):\n    \"\"\"Generates Rademacher random variables in {-1, 1}.\"\"\"\n    # Generate uniform integers in {0, 1}\n    uniform_ints = rng.integers(0, 2, size=size, dtype=np.int8, endpoint=False)\n    # Map 0 -> -1 and 1 -> 1 using the transformation 2*U - 1\n    return 2 * uniform_ints - 1\n\ndef generate_naive(T, N, seed):\n    \"\"\"Generates T sequences of N steps using the naive (same seed) regime.\"\"\"\n    # Handle the T=1 case separately for consistency, though the loop would also work.\n    if T == 1:\n        rng = np.random.default_rng(seed)\n        return generate_rademacher(rng, size=(1, N))\n    \n    steps = np.zeros((T, N), dtype=np.int8)\n    for i in range(T):\n        # All threads initialize their PRNG with the exact same seed, leading to identical sequences.\n        rng = np.random.default_rng(seed)\n        steps[i, :] = generate_rademacher(rng, size=N)\n    return steps\n\ndef generate_independent(T, N, seed):\n    \"\"\"Generates T sequences of N steps using the independent-streams regime.\"\"\"\n    if T == 1:\n        rng = np.random.default_rng(seed)\n        return generate_rademacher(rng, size=(1, N))\n\n    # Create a SeedSequence from the base seed.\n    ss = np.random.SeedSequence(seed)\n    # Spawn T independent child seeds.\n    child_seeds = ss.spawn(T)\n    # Create a list of PRNGs, each seeded with a child seed.\n    rngs = [np.random.default_rng(s) for s in child_seeds]\n    \n    steps = np.zeros((T, N), dtype=np.int8)\n    for i in range(T):\n        steps[i, :] = generate_rademacher(rngs[i], size=N)\n    return steps\n\ndef generate_leapfrog(T, N, seed):\n    \"\"\"Generates T sequences of N steps using the leapfrogging regime.\"\"\"\n    if T == 1:\n        rng = np.random.default_rng(seed)\n        return generate_rademacher(rng, size=(1, N))\n\n    rng = np.random.default_rng(seed)\n    # Generate a single long sequence of T*N random numbers.\n    long_sequence = generate_rademacher(rng, size=T * N)\n    \n    steps = np.zeros((T, N), dtype=np.int8)\n    for i in range(T):\n        # Thread i (0-indexed) gets elements at indices i, i+T, i+2T, ...\n        steps[i, :] = long_sequence[i::T]\n    return steps\n\ndef compute_diagnostics(steps, T, N):\n    \"\"\"Computes the three diagnostic metrics for a given set of step sequences.\"\"\"\n    # Handle the boundary condition for T=1 as specified in the problem.\n    if T == 1:\n        return [0.0, 0.0, 0.0]\n\n    # 1.  2. Average and Maximum Pearson Correlation\n    # np.corrcoef expects rows as variables (threads) and columns as observations (steps).\n    # The 'steps' array is already in this (T, N) format.\n    corr_matrix = np.corrcoef(steps)\n    \n    # Extract the upper triangle of the correlation matrix, excluding the diagonal (k=1).\n    # These are the correlations for all unique pairs of threads.\n    upper_triangle_indices = np.triu_indices(T, k=1)\n    correlations = corr_matrix[upper_triangle_indices]\n    \n    rho_bar = np.mean(correlations)\n    rho_max = np.max(correlations)\n\n    # 3. Normalized Endpoint Standard Deviation\n    # Sum along the step axis (axis=1) to get the N-step endpoint for each of the T threads.\n    endpoints = np.sum(steps, axis=1)\n    \n    # Calculate the sample standard deviation (ddof=1) across the T endpoints.\n    std_endpoints = np.std(endpoints, ddof=1)\n    \n    # Normalize by the theoretical standard deviation of a single walk.\n    sigma_end = std_endpoints / np.sqrt(N)\n    \n    return [rho_bar, rho_max, sigma_end]\n    \ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    BASE_SEED = 123456789\n    \n    test_cases = [\n        (\"naive\", 4, 10000),             # Case 1\n        (\"independent\", 4, 10000),      # Case 2\n        (\"leapfrog\", 4, 10000),         # Case 3\n        (\"naive\", 1, 100),              # Case 4\n        (\"independent\", 8, 50),         # Case 5\n    ]\n    \n    results_list_of_lists = []\n    for regime, T, N in test_cases:\n        if regime == \"naive\":\n            steps = generate_naive(T, N, BASE_SEED)\n        elif regime == \"independent\":\n            steps = generate_independent(T, N, BASE_SEED)\n        else:  # regime == \"leapfrog\"\n            steps = generate_leapfrog(T, N, BASE_SEED)\n\n        # Compute the diagnostic triplet [rho_bar, rho_max, sigma_end]\n        result_triplet = compute_diagnostics(steps, T, N)\n        results_list_of_lists.append(result_triplet)\n\n    # Format the final output string according to the problem specification.\n    # Ex: [[a1,b1,c1],[a2,b2,c2],...] with 6 decimal places and no spaces.\n    string_results = []\n    for r_rho, r_max, r_sig in results_list_of_lists:\n        # Format each float to 6 decimal places.\n        string_results.append(f\"[{r_rho:.6f},{r_max:.6f},{r_sig:.6f}]\")\n    \n    final_output_string = f\"[{','.join(string_results)}]\"\n    print(final_output_string)\n\nsolve()\n\n```", "id": "3183815"}]}