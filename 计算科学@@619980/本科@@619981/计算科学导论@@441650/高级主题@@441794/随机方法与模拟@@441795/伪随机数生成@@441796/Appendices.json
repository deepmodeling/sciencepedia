{"hands_on_practices": [{"introduction": "一个理想的伪随机数生成器（PRNG）不仅应在一维上表现出均匀性，其在高维空间中的分布也应同样无规律。本练习旨在通过动手实践，揭示线性同余生成器（LCG）一个众所知的弱点：即使序列在一维上完全均匀，其连续的数值对 $(U_i, U_{i+1})$ 在二维平面上也会暴露出明显的几何结构，即所谓的“晶格结构”。通过编程实现并计算相关度量，你将直观地理解为何必须对生成器的多维性质进行审慎评估。[@problem_id:3264088]", "problem": "考虑由整数模的剩余类上的确定性映射产生的序列，以及它们在归一化到单位区间后的行为。令 $m \\in \\mathbb{N}$，并设 $(X_i)_{i \\ge 0}$ 是一个序列，其中 $X_i \\in \\{0,1,\\dots,m-1\\}$，其归一化形式为 $U_i = X_i / m \\in [0,1)$。一维边际均匀性被离散地定义为在一个完整周期内恰好访问每个剩余类一次，而二维结构则通过连续对 $(U_i, U_{i+1})$ 的几何形状来评估。\n\n从模算术和剩余类双射的基本定义出发，设计并实现能够产生具有以下性质的序列的生成器：\n- 一个生成器，其在 $\\{0,1,\\dots,m-1\\}$ 上的一维边际分布是精确均匀的，即在一个周期内每个剩余类都恰好出现一次。\n- 一个生成器，其连续对 $(X_i, X_{i+1})$ 满足线性模关系，从而使得归一化后的 $(U_i,U_{i+1})$ 在二维空间中表现出易于检测的几何结构。\n\n您的程序必须：\n1. 为每个测试用例生成所需的序列。\n2. 为每个测试用例计算以下量化指标，所有指标均基于归一化对 $(U_i, U_{i+1})$：\n    - 一维均匀性比率，定义为 $|\\mathrm{VisitedStates}| / m$，其中 $|\\mathrm{VisitedStates}|$ 是在一个检测到的周期内观察到的 $\\{X_i\\}$ 中不同值的数量。该比率是 $[0,1]$ 内的实数。\n    - $[0,1) \\times [0,1)$ 上大小为 $G \\times G$ 的均匀网格的占据数，定义为点对集合 $(U_i, U_{i+1})$ 击中的不同网格单元的数量，单元格索引为 $(\\lfloor G U_i \\rfloor, \\lfloor G U_{i+1} \\rfloor)$。此计数是一个整数。\n    - 点对云 $(U_i,U_{i+1})$ 各分量之间的皮尔逊相关系数，对所有可用点对进行计算。该系数是一个实数。\n    - 模差 $(X_{i+1} - X_i) \\bmod m$ 在宽度为 $m/G$ 的粗分箱下的不同箱数，即 $\\left\\lfloor \\frac{(X_{i+1} - X_i) \\bmod m}{m/G} \\right\\rfloor$ 的不同值的数量。此计数是一个整数。\n\n仅使用模算术和剩余类双射的定义作为基本基础。不要依赖任何未经证明的快捷公式。您必须从第一性原理推导出为什么一维边际可以精确均匀，同时为什么二维连续对图可以显示出可见的结构。\n\n实现以下测试套件，该套件旨在覆盖一般情况、边界情况和比较情况。对于所有情况，使用 $G = 64$：\n- 情况 A（加法同余满周期）：模数 $m = 4096$，增量 $c = 5$，种子 $X_0 = 0$。通过连续加 $c$ 模 $m$ 来生成序列，直到状态重复，然后在第一次重复时停止。\n- 情况 B（加法同余短周期边界情况）：模数 $m = 4096$，增量 $c = 512$，种子 $X_0 = 0$。通过连续加法模 $m$ 生成序列，直到状态重复，然后停止。\n- 情况 C（线性同余一般情况）：模数 $m = 4096$，乘数 $a = 5$，增量 $c = 1$，种子 $X_0 = 1$。通过重复应用线性映射模 $m$ 生成序列，直到状态重复，然后停止。\n- 情况 D（独立均匀基线）：模数 $m = 4096$，种子 $s = 12345$。生成 $m$ 个独立样本 $U_i \\in [0,1)$，设置 $X_i = \\lfloor m U_i \\rfloor$，并使用前 $m$ 个值，不进行周期检测。\n\n对于每种情况，使用所有可用的连续对 $(U_i, U_{i+1})$ 计算上面列出的四个指标，其中索引 $i$ 遍历该情况生成的序列位置，并在不环绕配对时在最后一个元素之前停止。将所有量表示为不带单位的纯数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个情况的结果是一个四元素列表，顺序为：[均匀性比率, 占据数, 相关系数, 差值分箱数]。例如，输出应类似于 $[[r_1,o_1,\\rho_1,b_1],[r_2,o_2,\\rho_2,b_2],[r_3,o_3,\\rho_3,b_3],[r_4,o_4,\\rho_4,b_4]]$，不含多余的空格或文本。", "solution": "该问题要求对通过模算术生成的确定性序列进行分析和实现，这种序列常用于伪随机数生成。任务的核心是从第一性原理出发，理解这些序列的性质，特别是一维均匀性和二维结构。\n\n## 基本原理\n\n### 模算术与线性同余生成器（LCG）\n序列 $(X_i)_{i \\ge 0}$ 在模 $m$ 的剩余类集合 $\\mathbb{Z}_m = \\{0, 1, \\dots, m-1\\}$ 内生成。这类生成器中被广泛研究的一类是线性同余生成器（LCG），由以下递推关系定义：\n$$X_{i+1} = (a X_i + c) \\bmod m$$\n其中 $m > 0$ 是模数，$a$ 是乘数，$c$ 是增量，$X_0$ 是种子。当 $a=1$ 时，该生成器称为加法同余生成器（ACG）。归一化序列由 $U_i = X_i/m \\in [0, 1)$ 给出。\n\n### 一维均匀性与周期性\n一个好的生成器的一个关键特性是长周期。周期是满足对所有 $i$ 都有 $X_{i+p} = X_i$ 的最小正数 $p$。为了使生成器发挥最大作用，我们希望周期尽可能大。一个 LCG 具有满周期 $m$ 当且仅当它在重复之前恰好生成 $\\{0, 1, \\dots, m-1\\}$ 中的每个整数一次。这赋予了完美的一维边际均匀性，意味着均匀性比率 $|\\mathrm{VisitedStates}|/m$ 恰好为 $1$。\n\n达到满周期的条件取决于参数 $a$、$c$ 和 $m$。\n1.  **对于 ACG ($a=1$)：** 递推关系为 $X_{i+1} = (X_i + c) \\bmod m$。状态序列是模 $m$ 的等差数列。该序列具有满周期 $m$ 当且仅当增量 $c$ 是加法群 $\\mathbb{Z}_m$ 的一个生成元，这要求 $c$ 与 $m$ 互质。即 $\\gcd(c, m) = 1$。如果 $\\gcd(c, m) = d > 1$，则周期缩短为 $m/d$。\n\n2.  **对于 LCG ($a>1$)：** 当模数 $m$ 是 2 的幂时，例如 $m = 2^k$ 且 $k \\ge 2$，著名的 Hull-Dobell 定理指出 LCG 具有满周期 $m$ 当且仅当：\n    -   $c$ 是奇数（即 $\\gcd(c, m) = 1$）。\n    -   $a \\equiv 1 \\pmod 4$。\n\n### 二维结构\nLCG 的确定性特性对连续对 $(X_i, X_{i+1})$ 施加了严格的结构。对 LCG 递推关系进行归一化，我们得到：\n$$m U_{i+1} = (a m U_i + c) \\pmod m$$\n两边除以 $m$ 得到：\n$$U_{i+1} = (a U_i + c/m) \\pmod 1$$\n这个方程揭示了所有连续对 $(U_i, U_{i+1})$ 都位于有限数量的平行超平面上。在二维空间中，这些是直线。具体来说，这些点落在由 $y = ax + c/m - k$ 定义的线段上，其中 $k$ 为整数，使得该直线与单位正方形 $[0,1) \\times [0,1)$ 相交。这种固有的晶格结构是一种“易于检测的几何结构”，也是 LCG 的一个众所周知弱点，而指定的指标就是为了量化这一点。\n\n## 测试用例分析\n\n对于所有情况，用于占据度量指标的网格大小为 $G=64$。\n\n**情况 A：加法同余，满周期**\n($m=4096$, $c=5$, $X_0=0$, $a=1$)\n-   **均匀性：** $m=4096=2^{12}$ 且 $c=5$。由于 $5$ 是一个奇数，它与 2 的幂没有公因子，因此 $\\gcd(5, 4096)=1$。该 ACG 具有 $m=4096$ 的满周期。序列恰好访问 $\\{0, \\dots, 4095\\}$ 中的每个状态一次。均匀性比率为 $4096/4096 = 1.0$。\n-   **结构：** 点对 $(U_i, U_{i+1})$ 满足 $U_{i+1} = (U_i + 5/4096) \\pmod 1$。这些点位于两条平行的直线上。预计会有很强的正相关性。模差 $(X_{i+1} - X_i) \\bmod m$ 总是 $5$。这个单一的值落入分箱 $\\lfloor 5 / (4096/64) \\rfloor = \\lfloor 5/64 \\rfloor = 0$ 中。因此，差值分箱数为 $1$。\n\n**情况 B：加法同余，短周期**\n($m=4096$, $c=512$, $X_0=0$, $a=1$)\n-   **均匀性：** 此处，$c=512=2^9$。最大公约数为 $\\gcd(512, 4096) = 512$。周期为 $m/\\gcd(c,m) = 4096/512 = 8$。该序列只访问 $8$ 个状态。均匀性比率为 $8/4096 = 1/512$。\n-   **结构：** 这 $8$ 个状态都是 $512$ 的倍数。点对 $(U_i, U_{i+1})$ 位于单条直线 $y=x+1/8$ 上。相关性将是完美的。模差总是 $512$，落入分箱 $\\lfloor 512 / 64 \\rfloor = 8$ 中。差值分箱数为 $1$。\n\n**情况 C：线性同余，一般情况**\n($m=4096$, $a=5$, $c=1$, $X_0=1$)\n-   **均匀性：** 满足 Hull-Dobell 条件：$m=2^{12}$，$c=1$ 是奇数，且 $a=5 \\equiv 1 \\pmod 4$。该 LCG 具有 $m=4096$ 的满周期。均匀性比率为 $1.0$。\n-   **结构：** 点对 $(U_i, U_{i+1})$ 位于由 $U_{i+1} = (5 U_i + 1/4096) \\pmod 1$ 定义的 $a=5$ 条平行线上。模差为 $(X_{i+1} - X_i) \\bmod m = (4X_i + 1) \\bmod m$。由于 $X_i$ 遍历所有剩余类，且 $\\gcd(4, 4096)=4$，差值会取 $4096/4=1024$ 个不同的值，所有这些值都与 $1 \\pmod 4$ 同余。这些值是 $\\{1, 5, 9, \\dots\\}$。这 $1024$ 个值在 $[0, 4096)$ 上分布良好，并将落入所有 $G=64$ 个宽度为 $m/G=64$ 的分箱中。差值分箱数将为 $64$。\n\n**情况 D：独立均匀基线**\n($m=4096$, $s=12345$)\n-   这种情况作为“良好”随机性的基准，其中连续值是独立的。\n-   **均匀性：** 抽取 $m=4096$ 个值。访问到的唯一状态数量与赠券收集者问题有关。唯一值的期望数量是 $m(1-(1-1/m)^m) \\approx m(1-1/e) \\approx 0.632m$。因此，比率应接近 $0.632$。\n-   **结构：** 对于独立对 $(U_i, U_{i+1})$，点应该均匀地散布在单位正方形上，没有可辨别的线性结构。皮尔逊相关系数应接近 $0$。这些点应占据许多网格单元，其期望计数与均匀性结果相似，约为 $m(1-e^{-1}) \\approx 2588$。模差 $(X_{i+1}-X_i)\\bmod m$ 将在 $\\{0, \\dots, m-1\\}$ 上近似均匀分布。对于 $4095$ 个这样的差值，极有可能所有 $64$ 个分箱都会被访问到。差值分箱数应为 $64$。\n\n## 量化指标\n问题定义了需要计算的四个指标：\n1.  **均匀性比率：** $R_U = \\frac{|\\{X_i\\}|}{m}$，其中 $|\\{X_i\\}|$ 是在一个周期内访问的不同状态的数量。\n2.  **占据数：** $N_{occ} = |\\{(\\lfloor G U_i \\rfloor, \\lfloor G U_{i+1} \\rfloor)\\}|$, 即点对 $(U_i, U_{i+1})$ 在 $G \\times G$ 网格中击中的唯一单元格数量。\n3.  **皮尔逊相关系数：** $\\rho(U_i, U_{i+1}) = \\frac{\\mathrm{Cov}(U_i, U_{i+1})}{\\sigma_{U_i}\\sigma_{U_{i+1}}}$，用于衡量连续归一化值之间的线性相关性。\n4.  **差值分箱数：** $N_{db} = |\\{\\lfloor \\frac{(X_{i+1}-X_i)\\bmod m}{m/G} \\rfloor\\}|$, 即模差所击中的唯一粗分箱的数量。\n\n接下来的实现将遵循这些原理来生成序列，并为每种情况计算指定的指标。", "answer": "```python\nimport numpy as np\n\ndef generate_sequence_lcg(m, a, c, x0):\n    \"\"\"\n    Generates a sequence from a Linear Congruential Generator (LCG)\n    X_{i+1} = (a * X_i + c) mod m, until the first state repeats.\n    \"\"\"\n    seq = []\n    # Use a dictionary for fast lookups and to store the first occurrence index.\n    visited = {}\n    x = x0\n    i = 0\n    while x not in visited:\n        visited[x] = i\n        seq.append(x)\n        x = (a * x + c) % m\n        i += 1\n    return np.array(seq, dtype=np.int64)\n\ndef calculate_metrics(X, m, G):\n    \"\"\"\n    Calculates the four specified metrics for a given sequence X.\n    \"\"\"\n    # 1. One-dimensional uniformity ratio\n    # Using np.unique is a robust way to count distinct elements.\n    num_distinct_states = len(np.unique(X))\n    uniformity_ratio = num_distinct_states / m\n\n    if len(X)  2:\n        # Cannot compute pair-based metrics if sequence length is less than 2.\n        return [uniformity_ratio, 0, 0.0, 0]\n\n    # Create consecutive pairs from the sequence\n    X_i = X[:-1]\n    X_ip1 = X[1:]\n\n    # Normalize pairs to the unit interval [0, 1)\n    U_i = X_i / m\n    U_ip1 = X_ip1 / m\n\n    # 2. Occupancy count of a uniform grid\n    grid_indices = np.floor(np.vstack([U_i * G, U_ip1 * G]).T).astype(np.int32)\n    # Using a set of tuples is an efficient way to count unique 2D integer points.\n    unique_cells = set(map(tuple, grid_indices))\n    occupancy_count = len(unique_cells)\n\n    # 3. Pearson correlation coefficient\n    # Check for constant series to avoid NaN from division by zero in correlation formula.\n    if np.std(U_i) == 0 or np.std(U_ip1) == 0:\n        correlation = 1.0 if np.array_equal(U_i, U_ip1) else 0.0\n    else:\n        correlation = np.corrcoef(U_i, U_ip1)[0, 1]\n\n    # 4. Number of distinct bins of the modular difference\n    # np.mod ensures the result is in [0, m), correctly handling negative differences.\n    diff = np.mod(X_ip1 - X_i, m)\n    bin_width = m / G\n    diff_bins = np.floor(diff / bin_width)\n    diff_bin_count = len(np.unique(diff_bins))\n    \n    return [uniformity_ratio, occupancy_count, correlation, diff_bin_count]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (name, (m, a, c, x0), G) or (name, (m, seed), G)\n    test_cases = [\n        ('A', (4096, 1, 5, 0), 64),\n        ('B', (4096, 1, 512, 0), 64),\n        ('C', (4096, 5, 1, 1), 64),\n        ('D', (4096, 12345), 64)\n    ]\n\n    results = []\n    for case in test_cases:\n        name, params, G = case\n        \n        if name == 'D':\n            m, seed = params\n            # Generate sequence for Case D (independent uniform baseline)\n            rng = np.random.default_rng(seed=seed)\n            U = rng.random(size=m)\n            X = np.floor(m * U).astype(np.int64)\n        else:\n            # Generate sequence for Cases A, B, C (LCGs)\n            m, a, c, x0 = params\n            X = generate_sequence_lcg(m, a, c, x0)\n            \n        metrics = calculate_metrics(X, m, G)\n        results.append(metrics)\n\n    # The final print statement must produce the exact single-line format.\n    # repr() creates a string representation of the list, and replace() removes spaces.\n    print(repr(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3264088"}, {"introduction": "伪随机数序列的确定性本质不仅是其局限，也为其高效操作提供了可能。本练习将引导你推导并实现线性同余生成器（LCG）的“跳跃”（skip-ahead）功能，即在 $O(\\log t)$ 时间内计算出序列中超前 $t$ 步的数，而非进行 $t$ 次迭代。掌握此项技术对于并行计算中的随机数流分割至关重要，它确保了不同处理器能从同一序列中获得独立的子序列。[@problem_id:3179049]", "problem": "你将实现并验证一个线性同余生成器 (LCG) 的跳步操作。一个在整数模 $m$ 上的 LCG 由递推关系 $x_{n+1} \\equiv a x_n + c \\pmod m$ 定义，其中 $a$、$c$、$m$ 是固定的整数，且 $m \\geq 2$，$x_n \\in \\{0,1,\\dots,m-1\\}$。你的任务是从 LCG 的基本定义和标准模算术规则出发，推导、实现并测试一个单次操作即可将状态推进 $t$ 步的程序。\n\n出发点 (基本依据)：\n- 模算术的定义：对于整数 $u$、$v$ 和 $m \\ge 2$，$u \\equiv v \\pmod m$ 当且仅当 $m$ 整除 $u - v$；加法和乘法与模数兼容。\n- 整数上的有限几何级数恒等式：对于整数 $t \\ge 1$，当 $r \\ne 1$ 时，$\\sum_{k=0}^{t-1} r^k = \\frac{r^t - 1}{r - 1}$。\n- 平方求幂法以 $O(\\log e)$ 次乘法计算 $b^e$。\n- 整数 $q$ 模 $m$ 的乘法逆元存在的充要条件是 $\\gcd(q,m)=1$；它可以通过扩展欧几里得算法计算。\n\n要求：\n1) 从递推关系 $x_{n+1} \\equiv a x_n + c \\pmod m$ 推导出 $x_{n+t}$ 关于 $x_n$、$a$、$c$、$t$ 和 $m$ 的闭式表达式。表达出现的有限和，并解释何时除以 $a-1$ 在模 $m$ 意义下是有效的。\n2) 设计一个 $O(\\log t)$ 的跳步算法，该算法从 $x_n$ 计算 $x_{n+t}$ 而无需迭代 $t$ 次，使用：\n   - 平方求幂法计算 $a^t \\bmod m$，以及\n   - 扩展欧几里得算法在需要时计算模乘法逆元。\n   正确处理边界情况 $t=0$。\n3) 通过数值实验进行验证：对于下述每个测试用例，将跳步结果与基准真相 (ground truth)进行核对。当 $t$ 小到计算上合理时，基准真相必须通过直接迭代递推关系 $t$ 次来计算，否则通过代数一致性检查来计算。全程使用纯整数运算。\n\n假设：\n- 对于所有测试用例，假设 $\\gcd(a-1,m)=1$，因此只要出现除以 $a-1$ 的情况，在模 $m$ 意义下都是有效的。\n- 不涉及角度。不涉及物理单位。\n\n测试套件：\n- 测试 $1$ (正常路径，小模数)：$(m,a,c,x_n,t) = (\\,`97`\\,,\\,`23`\\,,\\,`17`\\,,\\,`42`\\,,\\,`35`\\,)$。基准真相：迭代递推关系 $t$ 次。\n- 测试 $2$ (大质数模数，仿射情况)：$(m,a,c,x_n,t) = (\\,`2147483647`\\,,\\,`48271`\\,,\\,`12345`\\,,\\,`987654321`\\,,\\,`50000`\\,)$。基准真相：迭代递推关系 $t$ 次。\n- 测试 $3$ (乘法 LCG，大 $t$ 值仍可行)：$(m,a,c,x_n,t) = (\\,`2147483647`\\,,\\,`16807`\\,,\\,`0`\\,,\\,`1`\\,,\\,`80000`\\,)$。基准真相：迭代递推关系 $t$ 次。\n- 测试 $4$ (边界情况 $t=0$)：$(m,a,c,x_n,t) = (\\,`2147483647`\\,,\\,`1103515245`\\,,\\,`12345`\\,,\\,`67890`\\,,\\,`0`\\,)$。基准真相：$x_{n+t} = x_n$。\n- 测试 $5$ (边界情况 $t=1$)：$(m,a,c,x_n,t) = (\\,`65537`\\,,\\,`3`\\,,\\,`7`\\,,\\,`1234`\\,,\\,`1`\\,)$。基准真相：应用一次 $x \\mapsto a x + c \\bmod m$。\n- 测试 $6$ (无需朴素迭代的组合性检查)：$(m,a,c,x_n,t_1,t_2) = (\\,`1000003`\\,,\\,`123457`\\,,\\,`891`\\,,\\,`222`\\,,\\,`1234`\\,,\\,`5678`\\,)$。验证先应用 $t_1$ 步的跳步操作，再接着应用 $t_2$ 步的跳步操作，其结果与一次性应用 $t_1 + t_2$ 步的跳步操作相等。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的布尔值逗号分隔列表（例如， $[{\\rm True},{\\rm False},{\\rm True}]$），按顺序对应测试 1 到 6 的结果。", "solution": "问题陈述已经过严格的验证过程，并被确定为有效。这是一个在计算科学领域中提法得当、有科学依据的问题，其表述清晰、客观。所有必要的数据和约束都已提供，不存在内部矛盾或逻辑缺陷。\n\n**1. $x_{n+t}$ 闭式表达式的推导**\n\n线性同余生成器 (LCG) 由以下递推关系定义：\n$$x_{k+1} \\equiv a x_k + c \\pmod m$$\n我们的目标是找到一个用 $x_n$、$a$、$c$、$t$ 和 $m$ 表示 $x_{n+t}$ 的表达式。我们可以通过展开递推关系来推导：\n$x_{n+1} \\equiv a x_n + c \\pmod m$\n$x_{n+2} \\equiv a x_{n+1} + c \\equiv a(a x_n + c) + c \\equiv a^2 x_n + ac + c \\pmod m$\n$x_{n+3} \\equiv a x_{n+2} + c \\equiv a(a^2 x_n + ac + c) + c \\equiv a^3 x_n + a^2 c + ac + c \\pmod m$\n\n这揭示了其一般形式，可以通过对 $t$ 进行数学归纳法来正式证明：\n$$x_{n+t} \\equiv a^t x_n + c \\sum_{k=0}^{t-1} a^k \\pmod m$$\n求和项是一个有限几何级数。对于任意整数 $r \\ne 1$，该级数的恒等式为 $\\sum_{k=0}^{t-1} r^k = \\frac{r^t - 1}{r - 1}$。将此应用于我们的表达式，令 $r=a$，可得：\n$$\\sum_{k=0}^{t-1} a^k = \\frac{a^t - 1}{a - 1}$$\n该恒等式在 $a \\ne 1$ 的条件下成立。在模算術中，当且仅当整数 $q$ 与模数 $m$ 互质时，才允许除以 $q$。在这种情况下，除以 $q$ 等价于乘以其模乘法逆元 $q^{-1} \\pmod m$，即一个整数 $q_{\\text{inv}}$ 使得 $q \\cdot q_{\\text{inv}} \\equiv 1 \\pmod m$。\n\n问题陈述中假设 $\\gcd(a-1, m) = 1$。这保证了 $(a-1)$ 模 $m$ 的乘法逆元存在且唯一。设此逆元记为 $(a-1)^{-1}$。因此，该几何级数之和可以在模 $m$ 的意义下计算为：\n$$\\sum_{k=0}^{t-1} a^k \\equiv (a^t - 1)(a-1)^{-1} \\pmod m$$\n将其代回 $x_{n+t}$ 的表达式，我们得到闭式解：\n$$x_{n+t} \\equiv a^t x_n + c \\left( (a^t - 1)(a-1)^{-1} \\right) \\pmod m$$\n此表达式允许我们直接从 $x_n$ 计算 $x_{n+t}$，而无需执行 $t$ 次单独的迭代。\n\n**2. $O(\\log t)$ 跳步算法的设计**\n\n$x_{n+t}$ 的闭式表达式为高效算法的实现提供了基础。其计算可以分解为多个步骤，这些步骤的复杂度不随 $t$ 线性增长。\n\n首先，我们处理 $t=0$ 的边界情况。公式正确地得出 $x_{n+0} \\equiv a^0 x_n + c(a^0-1)(a-1)^{-1} \\equiv 1 \\cdot x_n + c(1-1)(a-1)^{-1} \\equiv x_n \\pmod m$。因此，对于 $t=0$，算法只需返回 $x_n$。\n\n对于 $t  0$，算法按以下步骤进行：\n1.  **计算 $A \\equiv a^t \\pmod m$**：这是一个模幂运算。可以使用平方求幂法（也称为二进制幂）高效地执行，其时间复杂度为 $O(\\log_2 t)$。\n2.  **计算 $I \\equiv (a-1)^{-1} \\pmod m$**：这是 $(a-1)$ 关于模数 $m$ 的模乘法逆元。它使用扩展欧几里得算法计算，该算法找到整数 $i$ 和 $j$ 使得 $(a-1)i + mj = \\gcd(a-1, m)$。由于题目给定 $\\gcd(a-1, m) = 1$，我们有 $(a-1)i + mj = 1$，这意味着 $(a-1)i \\equiv 1 \\pmod m$。因此，逆元 $I$ 就是 $i \\pmod m$。此计算的时间复杂度为 $O(\\log m)$。\n3.  **组合最终结果**：使用预先计算出的值 $A$ 和 $I$，我们利用推導出的公式计算 $x_{n+t}$。所有算术运算都在模 $m$ 下进行：\n    - 计算求和部分：$S \\equiv c \\cdot (A - 1) \\cdot I \\pmod m$。\n    - 计算初始状态部分：$X \\equiv A \\cdot x_n \\pmod m$。\n    - 最终状态为：$x_{n+t} \\equiv (X + S) \\pmod m$。\n    这些步骤中的每一步都只涉及常数次模乘法和模加法。\n\n该算法的总时间复杂度由模幂运算和模逆元步骤决定，总体复杂度为 $O(\\log t + \\log m)$。与复杂度为 $O(t)$ 的朴素迭代方法相比，这是一个显著的改进。\n\n**3. 通过数值实验进行验证**\n\n跳步算法的正确性通过一组测试用例进行验证。\n- 对于步数 $t$ 在计算上可行的测试（测试 1、2、3、5），通过实现一个简单的迭代函数，将 LCG 递推关系 $x_{k+1} \\equiv (ax_k + c) \\pmod m$ 精确应用 $t$ 次来建立基准真相。然后将跳步算法的输出与此基准真相进行比较。\n- 对于边界情况 $t=0$（测试 4），基准真相根据定义就是 $x_n$。算法的输出将与此值进行核对。\n- 对于组合性检查（测试 6），我们验证跳步算子（我们称之为 $S(x, k)$）的代数性质，该算子将状态 $x$ 推进 $k$ 步。该测试确认，应用两次连续的跳步 $S(S(x_n, t_1), t_2)$，与一次性组合跳步 $S(x_n, t_1 + t_2)$ 产生相同的结果。这表明跳步操作构成了一个有效的半群作用，这是其正确性的一个基本要求，且不依赖于通过迭代计算基准真相的能力。\n\n所有计算都使用纯整数运算，并在每一步进行取模操作，以防止溢出并保持正确性，因为 Python 的任意精度整数支持所涉及的大数运算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are needed for this problem.\n\ndef solve():\n    \"\"\"\n    Implements and verifies a skip-ahead operation for a linear congruential\n    generator (LCG).\n    \"\"\"\n\n    def lcg_iterate(m: int, a: int, c: int, x_n: int, t: int) -> int:\n        \"\"\"\n        Computes x_{n+t} by iterating the LCG recurrence t times.\n        Serves as the ground truth for verification.\n        \"\"\"\n        x = x_n\n        for _ in range(t):\n            x = (a * x + c) % m\n        return x\n\n    def lcg_skip_ahead(m: int, a: int, c: int, x_n: int, t: int) -> int:\n        \"\"\"\n        Computes x_{n+t} using the O(log t) closed-form formula.\n        x_{n+t} = (a^t * x_n + c * (a^t - 1) * (a - 1)^-1) mod m\n        \"\"\"\n        if t  0:\n            raise ValueError(\"Step count t cannot be negative.\")\n        if t == 0:\n            return x_n\n\n        # The term (a-1) can be negative. The modulo operation works correctly\n        # with Python's integers.\n        a_minus_1 = a - 1\n        \n        # In Python 3.8+, pow(base, -1, mod) computes the modular\n        # multiplicative inverse using the Extended Euclidean Algorithm.\n        # The problem guarantees gcd(a-1, m) == 1.\n        a_minus_1_inv = pow(a_minus_1, -1, m)\n\n        # A = a^t mod m, calculated efficiently with modular exponentiation.\n        A = pow(a, t, m)\n\n        # Sum of geometric series part: c * (a^t - 1) * (a - 1)^-1 mod m\n        # (A - 1) might be negative, but Python's % handles this as desired\n        # for modular arithmetic (i.e., result has same sign as modulus).\n        sum_term = (A - 1) * a_minus_1_inv % m\n        \n        # Combine the terms according to the derived formula\n        term1 = (A * x_n) % m\n        term2 = (c * sum_term) % m\n        \n        result = (term1 + term2) % m\n        return result\n\n    # Test cases extracted from the problem statement\n    test_cases = [\n        # Test 1: Happy path, small modulus\n        {'m': 97, 'a': 23, 'c': 17, 'x_n': 42, 't': 35, 'type': 'iterate'},\n        # Test 2: Large prime modulus, affine case\n        {'m': 2147483647, 'a': 48271, 'c': 12345, 'x_n': 987654321, 't': 50000, 'type': 'iterate'},\n        # Test 3: Multiplicative LCG, large t still feasible\n        {'m': 2147483647, 'a': 16807, 'c': 0, 'x_n': 1, 't': 80000, 'type': 'iterate'},\n        # Test 4: Boundary case t=0\n        {'m': 2147483647, 'a': 1103515245, 'c': 12345, 'x_n': 67890, 't': 0, 'type': 'identity'},\n        # Test 5: Boundary case t=1\n        {'m': 65537, 'a': 3, 'c': 7, 'x_n': 1234, 't': 1, 'type': 'onestep'},\n        # Test 6: Composition check\n        {'m': 1000003, 'a': 123457, 'c': 891, 'x_n': 222, 't1': 1234, 't2': 5678, 'type': 'composition'}\n    ]\n\n    results = []\n    for case in test_cases:\n        m, a, c, x_n = case['m'], case['a'], case['c'], case['x_n']\n        \n        if case['type'] == 'iterate':\n            t = case['t']\n            skip_result = lcg_skip_ahead(m, a, c, x_n, t)\n            iter_result = lcg_iterate(m, a, c, x_n, t)\n            results.append(skip_result == iter_result)\n            \n        elif case['type'] == 'identity':\n            t = case['t']\n            skip_result = lcg_skip_ahead(m, a, c, x_n, t)\n            # Ground truth for t=0 is x_n\n            results.append(skip_result == x_n)\n\n        elif case['type'] == 'onestep':\n            t = case['t']\n            skip_result = lcg_skip_ahead(m, a, c, x_n, t)\n            # Ground truth for t=1 is one application of the recurrence\n            onestep_result = (a * x_n + c) % m\n            results.append(skip_result == onestep_result)\n\n        elif case['type'] == 'composition':\n            t1, t2 = case['t1'], case['t2']\n            # Verify S(S(x, t1), t2) == S(x, t1 + t2)\n            res_t1 = lcg_skip_ahead(m, a, c, x_n, t1)\n            res_t1_t2 = lcg_skip_ahead(m, a, c, res_t1, t2)\n            res_total_t = lcg_skip_ahead(m, a, c, x_n, t1 + t2)\n            results.append(res_t1_t2 == res_total_t)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3179049"}, {"introduction": "我们如何从数学上严格判断一个伪随机数生成器（PRNG）的输出是否“足够随机”？本练习将指导你从零开始实现一个经典的统计检验方法——皮尔逊卡方检验（Pearson chi-squared test），用以评估一个自定义的线性同余生成器的输出序列是否符合均匀分布。你将不仅实现生成器和卡方统计量的计算，还将深入到 $p$ 值的数值计算核心，从而完整地掌握一套评估 PRNG 质量的标准化流程。[@problem_id:3264207]", "problem": "您需要从第一性原理出发，实现一个皮尔逊卡方检验，以检验自定义伪随机数生成器 (PRNG) 输出的均匀性。伪随机数生成器 (PRNG) 是指任何旨在生成一个序列以模拟来自目标分布的独立样本的确定性算法。在此任务中，PRNG 将是一个线性同余生成器 (LCG)，目标分布是区间 $\\left[0,1\\right)$ 上的连续均匀分布。\n\n从核心定义和经过充分检验的事实出发，实现以下内容：\n\n- 构建一个线性同余生成器 (LCG)，其整数状态的更新规则定义为：下一个状态等于当前状态乘以乘数再加上增量，然后对模数取模。通过将每个整数状态除以模数，将其映射到 $\\left[0,1\\right)$ 内的一个实数。LCG 状态更新使用整数算术，并精确生成 $n$ 个样本。\n- 将 $\\left[0,1\\right)$ 划分成 $k$ 个等宽的区间（bins）。根据样本计算观测到的区间频数。在完全均匀的假设下，期望的区间频数是总样本数除以区间数。\n- 根据观测频数和期望频数计算皮尔逊卡方统计量。为卡方分布使用正确的自由度。\n- 使用正则化上不完全伽马函数计算卡方分布上尾的 $p$ 值。您必须通过数值计算来实现此评估，而不使用黑盒统计检验函数。为提高数值稳定性，可以使用伽马函数的自然对数。\n- 通过将 $p$ 值与给定的显著性水平 $\\alpha$（一个小数）进行比较，来决定是否接受均匀性。当 $p$ 值大于或等于 $\\alpha$ 时接受均匀性，否则拒绝。\n\n实现约束：\n\n- 程序必须是一个完整、可运行的程序，仅使用 Python 标准库和指定版本的 Numerical Python (NumPy) 库。\n- PRNG 必须是自行构建的，不得使用任何外部随机源。\n- $p$ 值的计算必须通过对正则化上不完全伽马函数的数值稳定评估来实现，避免使用任何外部统计库。\n\n测试套件：\n\n为以下参数集提供结果。每个集合都是一个元组 $\\left(m,a,c,s,n,k,\\alpha\\right)$，包含模数 $m$、乘数 $a$、增量 $c$、种子 $s$、样本量 $n$、区间数量 $k$ 和显著性水平 $\\alpha$。\n\n- 情况 1（理想情况，广泛使用的参数）：$\\left(2^{31}-1,16807,0,1,100000,100,0.01\\right)$。\n- 情况 2（退化的生成器，常数序列）：$\\left(2^{16},1,0,12345,10000,50,0.01\\right)$。\n- 情况 3（乘法LCG的退化种子）：$\\left(2^{31}-1,16807,0,0,10000,50,0.01\\right)$。\n- 情况 4（可靠性临界：每个区间的期望计数较小）：$\\left(2^{31}-1,16807,0,1,200,50,0.05\\right)$。\n- 情况 5（模数过小导致短周期）：$\\left(8,5,0,1,1000,10,0.01\\right)$。\n\n最终输出规范：\n\n- 对于每种情况，输出一个布尔值，指示在显著性水平 $\\alpha$ 下是否接受均匀性假设。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来、以逗号分隔且无空格的结果列表，按上述情况排序。例如：$\\left[\\text{result1},\\text{result2},\\text{result3},\\text{result4},\\text{result5}\\right]$，其中每个结果为 $\\text{True}$ 或 $\\text{False}$。", "solution": "我们通过整合将 PRNG 输出与统计决策过程联系起来的定义和性质来构建解决方案。\n\n首先，定义一个线性同余生成器 (LCG)。给定整数 $m$、$a$、$c$ 和一个初始种子 $s$，LCG 的状态通过以下方式演变：\n$$\nX_{n+1} = \\left(a X_n + c\\right) \\bmod m,\n$$\n其中 $X_0 = s$。每个状态 $X_n \\in \\{0,1,\\ldots,m-1\\}$ 都被映射为一个实数样本\n$$\nU_n = \\frac{X_n}{m},\n$$\n该样本位于 $\\left[0,1\\right)$ 内。\n\n为了评估 $\\{U_n\\}$ 的均匀性，将 $\\left[0,1\\right)$ 划分成 $k$ 个不相交的等宽区间（bins）。设这些区间为\n$$\nB_i = \\left[\\frac{i}{k}, \\frac{i+1}{k}\\right), \\quad i = 0,1,\\ldots,k-1.\n$$\n通过计算落入 $B_i$ 的样本数量来定义观测频数 $O_i$。在完全均匀分布的假设下，样本落入任何一个区间的概率是 $1/k$，因此每个区间的期望频数是\n$$\nE = \\frac{n}{k},\n$$\n其中 $n$ 是样本总数。\n\n均匀性的皮尔逊卡方统计量为\n$$\n\\chi^2 = \\sum_{i=0}^{k-1} \\frac{\\left(O_i - E\\right)^2}{E}.\n$$\n在均匀性原假设下，只要 $n$ 足够大且期望频数不太小，该统计量近似服从自由度为\n$$\n\\nu = k - 1\n$$\n的卡方分布。卡方分布是伽马分布的一个特例：如果 $X \\sim \\chi^2_\\nu$，则 $X$ 服从形状参数为 $\\nu/2$、尺度参数为 $2$ 的伽马分布。因此，对于一个观测值 $\\chi^2$ 的上尾 $p$ 值与正则化上不完全伽马函数相关。具体来说，\n$$\np = Q\\left(\\frac{\\nu}{2},\\frac{\\chi^2}{2}\\right),\n$$\n其中 $Q(a,x)$ 是由\n$$\nQ(a,x) = \\frac{\\Gamma(a,x)}{\\Gamma(a)}\n$$\n定义的正则化上不完全伽马函数，而 $\\Gamma(a,x)$ 是上不完全伽马函数，$\\Gamma(a)$ 是伽马函数。\n\n为了在不使用黑盒函数的情况下数值计算 $Q(a,x)$，我们使用两种互补的展开式以保证数值稳定性（如标准数值分析参考文献中所述）。设 $a0$ 且 $x \\ge 0$。引入公共预因子\n$$\n\\mathrm{pref}(a,x) = \\exp\\left(a \\ln x - x - \\ln \\Gamma(a)\\right).\n$$\n然后使用：\n- 当 $x  a+1$ 时，使用正则化下不完全伽马函数 $P(a,x)$ 的收敛级数，\n$$\nP(a,x) = \\mathrm{pref}(a,x) \\sum_{n=0}^{\\infty} \\frac{x^n}{a (a+1) \\cdots (a+n)},\n$$\n该级数通过级数项的递推关系实现，并返回 $Q(a,x) = 1 - P(a,x)$。\n- 当 $x \\ge a+1$ 时，使用 $Q(a,x)$ 的连分数，该连分数基于\n$$\nQ(a,x) = \\mathrm{pref}(a,x) \\cdot \\left[ \\cfrac{1}{x+1-a - \\cfrac{1 \\cdot (1-a)}{x+3-a - \\cfrac{2 \\cdot (2-a)}{x+5-a - \\cdots}}} \\right],\n$$\n并通过使用标准保护措施（微小值初始化和收敛容差）对连分数进行稳定的正向迭代来求值。\n\n给定计算出的 $p$ 值 $p$，在显著性水平 $\\alpha$ 下应用决策规则：\n$$\n\\text{接受均匀性} \\quad \\Leftrightarrow \\quad p \\ge \\alpha.\n$$\n\n算法设计：\n\n- 在 LCG 中使用整数算术生成 $n$ 个样本。通过除以 $m$ 将状态映射到 $\\left[0,1\\right)$ 内的实数。\n- 通过 $b(U_n) = \\min\\left(\\left\\lfloor k U_n \\right\\rfloor, k-1\\right)$ 计算区间索引，以确保索引在 $\\{0,1,\\ldots,k-1\\}$ 内。\n- 通过类似直方图的计算累积观测频数 $O_i$。\n- 计算 $E = n/k$，然后通过归一化偏差的平方和计算 $\\chi^2$。\n- 令 $\\nu = k-1$，计算 $a = \\nu/2$ 和 $x = \\chi^2/2$，使用上述分裂策略评估 $Q(a,x)$，并将 $p$ 与 $\\alpha$ 进行比较。\n\n边缘情况考虑：\n\n- 退化的生成器，如 $a=1, c=0$，会产生一个常数序列，将所有质量集中在单个区间内，这会产生极大的 $\\chi^2$ 值和 $p \\approx 0$，因此拒绝原假设。\n- 种子 $s=0$ 的乘法 LCG 对所有 $n$ 都产生 $U_n=0$，同样导致拒绝。\n- 当 $n$ 小而 $k$ 大时，期望频数 $E=n/k$ 可能很小，导致卡方近似的准确性降低。算法仍然会计算一个有效的统计量和 $p$ 值，但在这种情况下应谨慎解释决策结果。\n\n该程序评估五个指定的情况，并输出一行由五个布尔值组成的字符串，用方括号括起来，以逗号分隔且无空格，对应于按顺序对这些情况的接受决策。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef lcg_generate(m: int, a: int, c: int, seed: int, n: int) -> np.ndarray:\n    \"\"\"\n    Generate n samples in [0,1) using a Linear Congruential Generator (LCG):\n    X_{n+1} = (a * X_n + c) mod m, with X_0 = seed.\n    Returns a NumPy array of floats in [0,1).\n    \"\"\"\n    samples = np.empty(n, dtype=np.float64)\n    state = seed % m\n    for i in range(n):\n        # Map current state to [0,1)\n        samples[i] = state / m\n        # Advance state\n        state = (a * state + c) % m\n    return samples\n\ndef chi_square_uniformity(samples: np.ndarray, k: int):\n    \"\"\"\n    Compute Pearson chi-squared statistic for uniformity over k equal bins on [0,1).\n    Returns (chi2_stat, p_value).\n    \"\"\"\n    n = samples.size\n    # Bin indices: floor(k * x), clipped to k-1 to guard against edge\n    bin_indices = np.minimum((samples * k).astype(np.int64), k - 1)\n    counts = np.bincount(bin_indices, minlength=k)\n    expected = n / k\n    # Chi-squared statistic: sum((O_i - E)^2 / E)\n    diffs = counts - expected\n    chi2 = np.sum((diffs * diffs) / expected)\n    # Degrees of freedom\n    v = k - 1\n    # Upper-tail p-value using regularized upper incomplete gamma:\n    # p = Q(v/2, chi2/2)\n    a = 0.5 * v\n    x = 0.5 * chi2\n    p = gammaincc(a, x)\n    return chi2, p\n\ndef gammaincc(a: float, x: float) -> float:\n    \"\"\"\n    Regularized upper incomplete gamma function Q(a, x) = Gamma(a, x) / Gamma(a).\n    Implements the Numerical Recipes-style algorithm with series for P(a, x) when x  a+1,\n    and continued fraction for Q(a, x) when x >= a+1.\n    \"\"\"\n    if a = 0.0 or x  0.0:\n        raise ValueError(\"Invalid arguments for gammaincc: require a > 0 and x >= 0.\")\n    if x == 0.0:\n        return 1.0\n    # Common prefactor: exp(a*ln(x) - x - lnGamma(a))\n    ln_gamma_a = math.lgamma(a)\n    lnpref = a * math.log(x) - x - ln_gamma_a\n    pref = math.exp(lnpref)\n    # Switch by x relative to a+1\n    if x  a + 1.0:\n        # Compute P(a, x) via series\n        return 1.0 - _gammainc_lower_reg_series(a, x, pref)\n    else:\n        # Compute Q(a, x) via continued fraction\n        return _gammainc_upper_reg_cf(a, x, pref)\n\ndef _gammainc_lower_reg_series(a: float, x: float, pref: float) -> float:\n    \"\"\"\n    Regularized lower incomplete gamma P(a, x) via series expansion.\n    Returns P(a, x).\n    \"\"\"\n    eps = 1e-14\n    max_iter = 100000\n    sum_term = 1.0 / a\n    term = sum_term\n    ap = a\n    for n in range(1, max_iter + 1):\n        ap += 1.0\n        term *= x / ap\n        sum_term += term\n        if abs(term)  abs(sum_term) * eps:\n            break\n    return pref * sum_term\n\ndef _gammainc_upper_reg_cf(a: float, x: float, pref: float) -> float:\n    \"\"\"\n    Regularized upper incomplete gamma Q(a, x) via continued fraction.\n    Returns Q(a, x).\n    \"\"\"\n    eps = 1e-14\n    max_iter = 100000\n    tiny = 1e-300\n    b = x + 1.0 - a\n    c = 1.0 / tiny\n    d = 1.0 / b\n    h = d\n    for i in range(1, max_iter + 1):\n        an = -i * (i - a)\n        b += 2.0\n        d = 1.0 / (an * d + b)\n        c = b + an / c\n        if c == 0.0:\n            c = tiny\n        del_cf = d * c\n        h *= del_cf\n        if abs(del_cf - 1.0)  eps:\n            break\n    return pref * h\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (m, a, c, seed, n, k, alpha)\n    test_cases = [\n        (2**31 - 1, 16807, 0, 1, 100000, 100, 0.01),   # Case 1: Park-Miller minimal standard\n        (2**16, 1, 0, 12345, 10000, 50, 0.01),         # Case 2: Degenerate generator (constant)\n        (2**31 - 1, 16807, 0, 0, 10000, 50, 0.01),     # Case 3: Seed zero degeneracy\n        (2**31 - 1, 16807, 0, 1, 200, 50, 0.05),       # Case 4: Borderline small expected count\n        (8, 5, 0, 1, 1000, 10, 0.01),                  # Case 5: Very small modulus, short cycle\n    ]\n\n    results = []\n    for case in test_cases:\n        m, a, c, seed, n, k, alpha = case\n        samples = lcg_generate(m, a, c, seed, n)\n        chi2, pval = chi_square_uniformity(samples, k)\n        accept = pval >= alpha\n        results.append(accept)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3264207"}]}