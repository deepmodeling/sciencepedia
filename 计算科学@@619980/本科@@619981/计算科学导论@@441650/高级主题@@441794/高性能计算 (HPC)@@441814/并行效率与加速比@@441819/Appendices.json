{"hands_on_practices": [{"introduction": "并行计算的性能提升并非简单地通过增加处理器数量就能实现。本练习揭示了系统内存这一有限资源如何对性能构成硬性限制。通过一个假设场景，即增加过多的并行任务会耗尽可用内存，我们将推导出加速比完全停滞的临界点，这为我们进行资源感知的性能分析提供了宝贵的一课。 [@problem_id:3169117]", "problem": "一位计算科学家在一台共享内存工作站上运行一个由$N$个独立任务组成的易并行工作流。每个任务在单个处理核心上单独执行时，具有统一的计算时间$t$，并需要$m$字节的私有工作集在随机存取存储器（RAM）中。因此，总顺序计算时间为 $T_{\\text{comp}} = N t$。该工作站有$p$个相同的核心，它们共享一个容量为$M$字节的RAM。假设$M \\geq m$，因此至少有一个任务可以无需分页即可驻留在内存中。操作系统为每个核心调度最多一个任务，但当$p m > M$时，会发生虚拟内存分页，并且在持续的稳态颠簸下，并发驻留任务的有效数量受限于能容纳的工作集的最大数量：$p_{\\text{eff}} = \\min\\!\\left(p, \\left\\lfloor \\frac{M}{m} \\right\\rfloor\\right)$。在这些假设下：\n- 从加速比和易并行工作负载的理想性能的基本定义出发，推导实际完工时间 $T(p)$，其形式为一个理想并行计算时间与一个由有限内存容量（分页）引起的惩罚项之和。也就是说，将 $T(p)$ 表示为 $T(p) = \\text{(理想计算时间)} + \\text{(分页惩罚)}$ 的形式，并用 $T_{\\text{comp}}$、$p$、$M$ 和 $m$ 明确地表示出分页惩罚 $\\psi(p)$。\n- 使用以顺序时间和并行时间定义的加速比 $S(p)$，计算出用 $p$、$M$ 和 $m$ 表示的 $S(p)$ 的闭式表达式。\n\n将最终答案以 $S(p)$ 的单一闭式解析表达式的形式给出。不需要进行数值近似。在最终的方框答案中不要包含任何单位。", "solution": "在尝试任何解决方案之前，需对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n-   $N$：独立任务的数量。\n-   $t$：单个任务在单个核心上的计算时间。\n-   $m$：单个任务的私有工作集大小（字节）。\n-   $T_{\\text{comp}} = N t$：总顺序计算时间。\n-   $p$：工作站上相同核心的数量。\n-   $M$：随机存取存储器（RAM）的总容量（字节）。\n-   假设：$M \\geq m$。\n-   $p_{\\text{eff}} = \\min\\!\\left(p, \\left\\lfloor \\frac{M}{m} \\right\\rfloor\\right)$：并发驻留任务的有效数量。\n-   第一个目标：以 $T(p) = \\text{(理想计算时间)} + \\text{(分页惩罚)}$ 的形式推导完工时间 $T(p)$，并确定分页惩罚 $\\psi(p)$。\n-   第二个目标：计算用 $p$、$M$ 和 $m$ 表示的加速比 $S(p)$ 的闭式表达式。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据：** 问题使用了计算科学的标准概念，包括并行加速比、易并行工作负载、共享内存，以及一个因内存颠簸（虚拟内存分页）导致性能下降的简化但合理的模型。该模型中，有效并行度受限于物理RAM能容纳的工作负载数量，这是一个有效且常用的一阶近似。\n2.  **提法明确：** 问题提供了一个清晰、自洽的模型，包含了所有必要的变量和定义。目标是具体的，并能在所提供框架的基础上导出一个唯一的、可推导的解。\n3.  **客观性：** 问题以精确的技术语言陈述，没有主观性或歧义。\n4.  **完整且一致：** 所有变量都已定义，并且它们之间的关系也已明确说明。假设 $M \\geq m$ 确保了问题设置的非平凡性，并允许至少一个任务运行。$p_{\\text{eff}}$ 的定义是无歧义的。\n5.  **现实且可行：** 该模型是一个简化，但捕捉了并行计算中一个真实的性能瓶颈。参数是符号化的，从而避免了数值数据中的不一致性。\n6.  **结构与平凡性：** 问题结构良好，需要非平凡的推理来连接理想并行度、内存限制和实际性能等概念。这是该领域一个标准的概念性问题。\n\n### 步骤 3：结论与行动\n问题被认为是**有效的**，因为它是科学上合理的、自洽的且提法明确的。将推导解决方案。\n\n### 推导过程\n解决方案的推导首先建立理想性能，然后引入内存约束以找到实际性能，最后推导加速比。\n\n总顺序计算时间，即在单个核心（$p=1$）上运行整个工作负载的时间，由 $T_1 = T_{\\text{comp}} = N t$ 给出。\n\n对于易并行工作负载，任务是独立的。在具有无限内存的理想情况下，总工作量 $T_{\\text{comp}}$ 将完美地分配到 $p$ 个可用核心上。理想的并行执行时间，或称完工时间，将是：\n$$T_{\\text{ideal}}(p) = \\frac{T_{\\text{comp}}}{p}$$\n这一项代表了问题陈述中要求的“(理想计算时间)”。\n\n问题引入了内存约束。并发运行 $p$ 个任务所需的总内存为 $p \\cdot m$。如果 $p \\cdot m > M$，系统无法将所有工作集同时保存在RAM中，导致虚拟内存分页和性能下降（颠簸）。问题通过定义一个有效并发任务数 $p_{\\text{eff}}$ 来对此进行建模，它代表了系统在不因内存限制而导致性能崩溃的情况下可以维持的最大并行度。这个有效并行度由下式给出：\n$$p_{\\text{eff}} = \\min\\left(p, \\left\\lfloor \\frac{M}{m} \\right\\rfloor\\right)$$\n这里，$\\lfloor M/m \\rfloor$ 是可以装入总RAM $M$ 的完整任务工作集的最大数量。因此，可以并发运行的实际任务数量受限于核心数 $p$ 或内存容量，取两者中较小者。\n\n实际完工时间 $T(p)$ 是总工作量 $T_{\\text{comp}}$ 除以有效并行度 $p_{\\text{eff}}$：\n$$T(p) = \\frac{T_{\\text{comp}}}{p_{\\text{eff}}} = \\frac{T_{\\text{comp}}}{\\min\\left(p, \\left\\lfloor \\frac{M}{m} \\right\\rfloor\\right)}$$\n\n第一个目标是将 $T(p)$ 表示为理想时间与一个惩罚项 $\\psi(p)$ 的和。\n$$T(p) = T_{\\text{ideal}}(p) + \\psi(p)$$\n我们可以求解分页惩罚 $\\psi(p)$：\n$$\\psi(p) = T(p) - T_{\\text{ideal}}(p)$$\n代入 $T(p)$ 和 $T_{\\text{ideal}}(p)$ 的表达式：\n$$\\psi(p) = \\frac{T_{\\text{comp}}}{p_{\\text{eff}}} - \\frac{T_{\\text{comp}}}{p}$$\n提取公因子 $T_{\\text{comp}}$ 并代入 $p_{\\text{eff}}$ 的定义，得到分页惩罚的显式表达式：\n$$\\psi(p) = T_{\\text{comp}} \\left( \\frac{1}{\\min\\left(p, \\left\\lfloor \\frac{M}{m} \\right\\rfloor\\right)} - \\frac{1}{p} \\right)$$\n当 $p \\le \\lfloor M/m \\rfloor$ 时，内存充足。在这种情况下，$\\min(p, \\lfloor M/m \\rfloor) = p$，惩罚项 $\\psi(p)$ 变为 $T_{\\text{comp}}(1/p - 1/p) = 0$，正如预期。当 $p > \\lfloor M/m \\rfloor$ 时，内存不足，$\\min(p, \\lfloor M/m \\rfloor) = \\lfloor M/m \\rfloor$，此时会产生一个非零的惩罚项 $\\psi(p) = T_{\\text{comp}}(1/\\lfloor M/m \\rfloor - 1/p)$。\n\n第二个目标是推导加速比 $S(p)$。加速比定义为顺序执行时间与并行执行时间之比：\n$$S(p) = \\frac{T_1}{T(p)}$$\n我们有 $T_1 = T_{\\text{comp}}$ 和 $T(p) = T_{\\text{comp}} / p_{\\text{eff}}$。将这些代入加速比的定义中：\n$$S(p) = \\frac{T_{\\text{comp}}}{T_{\\text{comp}} / p_{\\text{eff}}}$$\n简化该表达式得到：\n$$S(p) = p_{\\text{eff}}$$\n最后，我们代入 $p_{\\text{eff}}$ 的定义，得到用 $p$、$M$ 和 $m$ 表示的加速比的闭式表达式：\n$$S(p) = \\min\\left(p, \\left\\lfloor \\frac{M}{m} \\right\\rfloor\\right)$$\n这个结果表明，加速比随处理器数量线性增加（$S(p)=p$），直到系统内存容量饱和。超过该点（$p > \\lfloor M/m \\rfloor$）后，加速比稳定在一个常数值 $S(p) = \\lfloor M/m \\rfloor$，这表明由于内存瓶颈，增加更多处理器不会带来进一步的性能提升。", "answer": "$$\\boxed{\\min\\left(p, \\left\\lfloor \\frac{M}{m} \\right\\rfloor\\right)}$$", "id": "3169117"}, {"introduction": "高效的并行编程往往需要在不同开销之间做出明智的权衡。本练习探讨了一个典型的两难问题：是否值得花费额外的CPU时间进行数据压缩，以减少网络通信的耗时？通过分析其成本与收益，你将推导出使压缩策略变得有利可图的精确条件，这是优化数据密集型应用的一项关键技能。 [@problem_id:3169043]", "problem": "一个数据并行模拟在 $p$ 个相同的处理单元上执行。设 $T_{1}$ 表示最佳单核实现的墙钟时间，该实现仅包含计算，总计算时间为 $W$。在 $p$ 个处理单元上的并行实现将计算分为一个串行部分 $s \\in (0,1)$ 和一个完全并行部分 $1-s$。其中，串行部分在单个处理单元上运行，而并行部分则在 $p$ 个处理单元之间均匀分配，无负载不均衡。此外，该并行实现执行 $N$ 次相同的最近邻交换。在每次交换中，每个处理单元参与一次大小为 $M$ 字节的点对点消息传递。通信遵循标准的延迟-带宽模型：发送一个大小为 $x$ 字节的消息耗时 $L + x/B$ 秒，其中 $L$ 是延迟，$B$ 是以字节/秒为单位的持续带宽。\n\n为了减少通信量，考虑引入一个无损数据压缩步骤。压缩将消息大小减小一个因子 $\\eta \\in (0,1]$，因此大小为 $M$ 的消息变为 $\\eta M$。然而，压缩传出消息和解压传入消息会消耗中央处理器 (CPU) 时间。将每次交换、每个处理单元的压缩-解压组合 CPU 成本建模为 $\\kappa M$ 秒，其中 $\\kappa$ 是一个以秒/字节为单位的常数。假设压缩和解压成本不能与通信或其他计算重叠。\n\n仅使用加速比 $S(p) = T_{1}/T_{p}$ 的定义和上述延迟-带宽通信模型，推导在固定 $p$ 值下，启用压缩能够严格提高加速比的条件。以单一符号表达式的形式，报告边界值 $\\eta^{\\ast}$ (仅为 $\\kappa$ 和 $B$ 的函数)，使得当且仅当 $\\eta < \\eta^{\\ast}$ 时，启用压缩可提高加速比。你的最终答案必须是 $\\eta^{\\ast}$ 的闭式解析表达式，不带单位，不带不等式。不要对结果进行四舍五入。", "solution": "首先验证问题，以确保其自洽、一致且科学合理。\n\n**第1步：提取已知条件**\n- 处理单元数量: $p$\n- 最佳单核实现的墙钟时间: $T_{1}$\n- 单核实现的总计算时间: $W$，其中 $T_{1} = W$\n- 计算的串行部分: $s \\in (0,1)$\n- 计算的并行部分: $1-s$\n- 最近邻交换次数: $N$\n- 每次交换的消息大小 (未压缩): $M$ 字节\n- 通信延迟: $L$ 秒\n- 通信带宽: $B$ 字节/秒\n- 大小为 $x$ 字节的消息的通信成本: $L + x/B$ 秒\n- 压缩因子: $\\eta \\in (0,1]$\n- 压缩后消息大小: $\\eta M$\n- 每次交换、每个核心的压缩-解压组合 CPU 成本: $\\kappa M$ 秒\n- 压缩/解压成本常数: $\\kappa$ 秒/字节\n- 约束条件：压缩和解压成本不能与通信或其他计算重叠。\n- 加速比的定义: $S(p) = T_{1}/T_{p}$\n- 目标：找到边界值 $\\eta^{\\ast}$ (一个关于 $\\kappa$ 和 $B$ 的函数)，使得当且仅当 $\\eta < \\eta^{\\ast}$ 时，启用压缩可严格提高加速比。\n\n**第2步：使用提取的已知条件进行验证**\n该问题提法得当且具有科学依据。它展示了并行计算中性能权衡的标准分析方法，对计算使用了类似阿姆达尔定律的模型，对通信使用了标准的延迟-带宽模型。所有术语都定义清晰，且假设（例如，成本不重叠）都已明确说明，这使得问题自洽且明确。在计算科学的背景下，这些参数具有物理意义。问题中没有矛盾、科学缺陷或主观因素。\n\n**第3步：结论与行动**\n问题有效。将推导解决方案。\n\n**推导**\n\n设 $T_{p,\\text{no comp}}$ 为在 $p$ 个处理单元上不使用压缩时的总墙钟时间，而 $T_{p,\\text{comp}}$ 为使用压缩时的时间。\n\n单处理器执行时间给出为 $T_{1} = W$。\n\n并行执行时间是串行计算时间、并行计算时间以及通信时间的总和。根据问题陈述，这些阶段是不同的，它们的成本在关键路径上是可加的。\n\n在不使用压缩的情况下，执行时间 $T_{p,\\text{no comp}}$ 的组成部分为：\n1.  计算的串行部分所需时间: $sW$\n2.  计算的并行部分所需时间: $\\frac{(1-s)W}{p}$\n3.  通信时间：共有 $N$ 次交换，每次交换对于大小为 $M$ 的消息耗时 $L + \\frac{M}{B}$。总通信时间为 $N \\left(L + \\frac{M}{B}\\right)$。\n\n因此，不使用压缩的总时间为：\n$$T_{p,\\text{no comp}} = sW + \\frac{(1-s)W}{p} + N \\left(L + \\frac{M}{B}\\right)$$\n\n使用压缩时，消息大小减小到 $\\eta M$，但引入了额外的压缩和解压计算成本。该成本为每次交换 $\\kappa M$，不能与其他操作重叠。\n\n执行时间 $T_{p,\\text{comp}}$ 的组成部分为：\n1.  计算的串行部分所需时间: $sW$\n2.  计算的并行部分所需时间: $\\frac{(1-s)W}{p}$\n3.  压缩/解压时间：对于 $N$ 次交换中的每一次，每个处理器产生 $\\kappa M$ 的成本。增加的总 CPU 时间为 $N \\kappa M$。\n4.  通信时间：现在消息大小为 $\\eta M$。总通信时间为 $N \\left(L + \\frac{\\eta M}{B}\\right)$。\n\n因此，使用压缩的总时间为：\n$$T_{p,\\text{comp}} = sW + \\frac{(1-s)W}{p} + N \\kappa M + N \\left(L + \\frac{\\eta M}{B}\\right)$$\n\n加速比定义为 $S(p) = T_{1}/T_{p}$。设 $S_{\\text{no comp}}(p)$ 和 $S_{\\text{comp}}(p)$ 分别为不使用压缩和使用压缩时的加速比。\n$$S_{\\text{no comp}}(p) = \\frac{T_{1}}{T_{p,\\text{no comp}}}$$\n$$S_{\\text{comp}}(p) = \\frac{T_{1}}{T_{p,\\text{comp}}}$$\n\n如果 $S_{\\text{comp}}(p) > S_{\\text{no comp}}(p)$，则压缩严格提高了加速比。\n$$\\frac{T_{1}}{T_{p,\\text{comp}}} > \\frac{T_{1}}{T_{p,\\text{no comp}}}$$\n由于对于一个非平凡问题 $T_{1}=W$ 必须为正，且执行时间总是正的，我们可以对两边取倒数并反转不等号：\n$$T_{p,\\text{comp}} < T_{p,\\text{no comp}}$$\n这直观地意味着，要提高加速比，总执行时间必须减少。\n\n代入执行时间的表达式：\n$$sW + \\frac{(1-s)W}{p} + N \\kappa M + N \\left(L + \\frac{\\eta M}{B}\\right) < sW + \\frac{(1-s)W}{p} + N \\left(L + \\frac{M}{B}\\right)$$\n串行和并行计算的项 $sW$ 和 $\\frac{(1-s)W}{p}$ 在两边共有，因此可以消去。通信成本中的延迟部分 $NL$ 也被消去。\n$$N \\kappa M + N \\frac{\\eta M}{B} < N \\frac{M}{B}$$\n假设消息数量 $N$ 和消息大小 $M$ 为正（否则通信是微不足道的，压缩也无关紧要），我们可以将整个不等式除以 $NM$：\n$$\\kappa + \\frac{\\eta}{B} < \\frac{1}{B}$$\n我们需要找到边界值 $\\eta^{\\ast}$，使得当且仅当 $\\eta < \\eta^{\\ast}$ 时不等式成立。为此，我们求解 $\\eta$：\n$$\\frac{\\eta}{B} < \\frac{1}{B} - \\kappa$$\n乘以带宽 $B$（一个正量），不等式方向保持不变：\n$$\\eta < B \\left(\\frac{1}{B} - \\kappa\\right)$$\n$$\\eta < 1 - \\kappa B$$\n这个不等式给出了压缩有利时 $\\eta$ 所需满足的条件。边界值是该不等式的右侧。\n因此，边界值 $\\eta^{\\ast}$ 是：\n$$\\eta^{\\ast} = 1 - \\kappa B$$\n性能改善的条件是 $\\eta < \\eta^{\\ast}$，如果 $\\eta^{\\ast}$ 是在 $\\eta$ 的允许范围内的值，则该条件得到满足。其物理释义是，无量纲乘积 $\\kappa B$ 代表了计算处理一个字节的时间与传输一个字节的时间之比。只有当这个比率小于1时，压缩才是有益的。如果 $\\kappa B \\ge 1$，那么 $\\eta^{\\ast} \\le 0$，并且由于 $\\eta \\in (0,1]$，不存在能够提高性能的 $\\eta$ 值。所推导出的 $\\eta^{\\ast}$ 表达式仅是 $\\kappa$ 和 $B$ 的函数，符合题目要求。", "answer": "$$\\boxed{1 - \\kappa B}$$", "id": "3169043"}, {"introduction": "像阿姆达尔定律这样的理论模型非常强大，但它们如何与充满噪声的真实实验数据联系起来？这个动手编程练习将指导你使用一种稳健的数值方法，从测得的加速比数据中估算出一个关键的模型参数——串行分数 $f$。掌握这项技术，你将能够诊断性能瓶颈，并量化代码的可扩展性极限。 [@problem_id:3169134]", "problem": "您将获得一组测得的并行加速比数据，这组数据应符合一个固定问题规模在弱测量噪声下的性能模型。其科学依据如下。加速比 $S(p)$ 定义为 $S(p) = T(1)/T(p)$，其中 $T(p)$ 是在 $p$ 个相同处理单元上的运行时间。对于固定规模工作负载的共享内存或消息传递并行化，一个经过充分检验的模型是：运行时间分解为一个串行部分和一个可在 $p$ 个处理器上理想划分的并行部分，对于串行比例 $f \\in [0,1]$，可得到 $T(p) = T(1)\\,(f + (1 - f)/p)$，因此 $S(p) = 1/(f + (1 - f)/p)$。测量值 $S_{\\text{meas}}(p)$ 在此结构周围含有少量噪声。您的任务是设计并实现一种稳健的数值方法，该方法通过对 $p$ 的扰动进行适当的线性化，并使用有限差分法，从带噪声的 $(p_i, S_{\\text{meas}}(p_i))$ 数据中估计 $f$。\n\n要求：\n- 从上述模型和定义出发，推导一种方法，将对 $f$ 的估计转化为从受扰动的测量值中估计斜率。该方法必须通过聚合多个有限差分斜率来应对轻度噪声，从而保证稳健性。\n- 您必须仅根据提供的测量数据来估计 $f$，不能借助任何关于 $f$ 的先验知识。\n- 不涉及任何物理单位。所有输出必须是小数（而非百分比）。\n\n待实现的算法说明：\n- 对于一个由数据对 $(p_i, S_{\\text{meas}}(p_i))$ 组成的数据集，计算 $x_i = 1/p_i$ 和 $y_i = 1/S_{\\text{meas}}(p_i)$。\n- 按 $x_i$ 的升序对数据对进行排序。\n- 对于排序后的所有相邻数据对，计算有限差分斜率 $m_j = (y_{j+1} - y_j)/(x_{j+1} - x_j)$。\n- 通过取 $\\{m_j\\}$ 的中位数 $\\widehat{m}$ 来稳健地聚合这些斜率。将此聚合斜率解释为对串行比例补值的估计，并定义 $\\widehat{f} = 1 - \\widehat{m}$。\n- 最后，将 $\\widehat{f}$ 限制在区间 $[0,1]$ 内，方法是将任何低于 $0$ 的值截断为 $0$，高于 $1$ 的值截断为 $1$。\n- 对每个数据集，返回估计值 $\\widehat{f}$，并精确到 $4$ 位小数。\n\n测试套件（每个数据集是处理器数量列表及其对应的测量加速比）：\n- 数据集 A（中等串行比例的一般情况）：$p = [\\,1,\\,2,\\,4,\\,8,\\,16,\\,32\\,]$, $S_{\\text{meas}}(p) = [\\,1.0,\\,1.79,\\,3.10,\\,4.68,\\,6.45,\\,7.78\\,]$。\n- 数据集 B（接近理想可扩展性，串行比例非常小）：$p = [\\,1,\\,8,\\,16,\\,32,\\,64,\\,128\\,]$, $S_{\\text{meas}}(p) = [\\,1.0,\\,7.45,\\,13.90,\\,24.50,\\,39.00,\\,56.70\\,]$。\n- 数据集 C（串行比例大）：$p = [\\,1,\\,2,\\,4,\\,8,\\,16\\,]$, $S_{\\text{meas}}(p) = [\\,1.0,\\,1.43,\\,1.80,\\,2.11,\\,2.28\\,]$。\n- 数据集 D（最小两点情况，边界条件）：$p = [\\,8,\\,16\\,]$, $S_{\\text{meas}}(p) = [\\,3.3333333333,\\,4.0\\,]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含以逗号分隔的估计值列表，并用方括号括起。每个估计值格式化为恰好 $4$ 位小数，且不含空格。例如：\"[0.1234,0.0056,0.4000,0.2000]\"。", "solution": "经评估，用户提供的问题是有效的。它在科学上基于并行计算性能建模的原理，特别是阿姆达尔定律。该问题定义明确，提供了完整且无歧义的算法说明，以及执行所需的所有数据。所用语言客观而精确。因此，下面提供一个合理的解决方案。\n\n问题的核心是从一组带噪声的加速比测量值 $S_{\\text{meas}}(p)$ 中，估计并行程序的串行比例 $f$。其底层的性能模型是针对固定规模工作负载的阿姆达尔定律，该定律将 $p$ 个处理单元上的加速比 $S(p)$ 与串行比例 $f$ 联系起来。\n\n在 $p$ 个处理器上的运行时间 $T(p)$ 被建模为一个恒定的串行部分和一个完全可并行化部分的和：\n$$T(p) = T(1) f + T(1) \\frac{1-f}{p} = T(1) \\left( f + \\frac{1-f}{p} \\right)$$\n这里，$f \\in [0, 1]$ 是程序在单个处理器上执行时间中，本质上是串行且无法并行的部分所占的比例。加速比 $S(p)$ 是串行运行时间 $T(1)$ 与并行运行时间 $T(p)$ 的比值：\n$$S(p) = \\frac{T(1)}{T(p)} = \\frac{T(1)}{T(1) \\left( f + \\frac{1-f}{p} \\right)} = \\frac{1}{f + \\frac{1-f}{p}}$$\n该模型相对于变量 $p$ 是非线性的。为了便于估计 $f$，可以通过变量替换将模型线性化。我们定义两个新变量：\n$$x = \\frac{1}{p} \\quad \\text{and} \\quad y = \\frac{1}{S(p)}$$\n将这些定义代入加速比方程，得到 $y$ 和 $x$ 之间的线性关系：\n$$y(x) = f + (1-f)x$$\n该方程是标准直线形式 $y = c + mx$，其中 y 轴截距 $c$ 是串行比例 $f$，斜率 $m$ 是可并行化比例 $1-f$。因此，问题就从对 $S(p)$ 的非线性模型进行拟合，转变为对 $y(x)$ 的线性模型进行拟合。目标是估计 $f$。从线性模型中我们可以看到，如果能稳健地估计出斜率 $\\widehat{m}$，就可以推导出串行比例的估计值 $\\widehat{f} = 1 - \\widehat{m}$。\n\n指定的算法提供了一种具体的数值方法，用于从带噪声的数据点 $(p_i, S_{\\text{meas}}(p_i))$ 中估计该斜率。步骤如下：\n\n$1$. **数据转换**：对于每个测量数据对 $(p_i, S_{\\text{meas}}(p_i))$，我们在线性化空间中计算对应的点 $(x_i, y_i)$，其中 $x_i = 1/p_i$ 且 $y_i = 1/S_{\\text{meas}}(p_i)$。\n\n$2$. **数据排序**：转换后的点集 $\\{(x_i, y_i)\\}$ 根据 $x_i$ 值按升序排序。此步骤至关重要，因为它将数据点沿自变量轴排列，这是计算相邻点之间有意义的有限差分的先决条件。\n\n$3$. **有限差分斜率计算**：对于已排序序列中每对相邻点 $(x_j, y_j)$ 和 $(x_{j+1}, y_{j+1})$，使用有限差分公式计算斜率的局部估计值：\n$$m_j = \\frac{y_{j+1} - y_j}{x_{j+1} - x_j}$$\n在没有噪声的情况下，所有这些斜率 $m_j$ 都将相同且等于 $1-f$。然而，$S_{\\text{meas}}(p_i)$ 中的测量噪声会传播到 $y_i$，导致计算出的 $m_j$ 值发生变化。\n\n$4$. **稳健的斜率聚合**：为了从局部斜率集合 $\\{m_j\\}$ 中获得对真实斜率的单个稳健估计，算法指定使用中位数。聚合后的斜率估计值为 $\\widehat{m} = \\text{median}(\\{m_j\\})$。中位数是一种稳健的统计量度，这意味着与算术平均值相比，它对异常数据点（可能由异常大的噪声测量引起）的敏感度较低。\n\n$5$. **串行比例估计**：利用从线性模型推导出的关系，从聚合斜率 $\\widehat{m}$ 中估计串行比例 $f$：\n$$\\widehat{f} = 1 - \\widehat{m}$$\n\n$6$. **截断**：串行比例 $f$ 在物理上被限制在区间 $[0, 1]$ 内。由于噪声的存在，原始估计值 $\\widehat{f}$ 可能会略微超出此范围。最后一步是截断该估计值，以确保其位于这些具有物理意义的界限内：$\\widehat{f}_{\\text{clipped}} = \\max(0, \\min(1, \\widehat{f}))$。这在最终结果上强制施加了物理约束。\n\n该程序构成了一种完整而稳健的方法，它基于对底层性能模型的合理线性化，从所提供的数据中估计串行比例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of estimating the serial fraction 'f' from parallel speedup data.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Dataset A (general case with moderate serial fraction)\n        {'p': [1, 2, 4, 8, 16, 32], 'S': [1.0, 1.79, 3.10, 4.68, 6.45, 7.78]},\n        # Dataset B (near-ideal scalability, very small serial fraction)\n        {'p': [1, 8, 16, 32, 64, 128], 'S': [1.0, 7.45, 13.90, 24.50, 39.00, 56.70]},\n        # Dataset C (large serial fraction)\n        {'p': [1, 2, 4, 8, 16], 'S': [1.0, 1.43, 1.80, 2.11, 2.28]},\n        # Dataset D (minimal two-point case, boundary condition)\n        {'p': [8, 16], 'S': [3.3333333333, 4.0]},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        p_values = np.array(case['p'], dtype=np.float64)\n        s_values = np.array(case['S'], dtype=np.float64)\n        \n        # Step 1: Compute x_i = 1/p_i and y_i = 1/S_meas(p_i).\n        x_values = 1.0 / p_values\n        y_values = 1.0 / s_values\n        \n        # Combine x and y into pairs for sorting.\n        # A list of tuples (x, y) is created.\n        points = list(zip(x_values, y_values))\n        \n        # Step 2: Sort pairs by x_i in ascending order.\n        points.sort(key=lambda point: point[0])\n        \n        # Unzip back into sorted x and y arrays\n        sorted_x, sorted_y = zip(*points)\n        sorted_x = np.array(sorted_x)\n        sorted_y = np.array(sorted_y)\n        \n        # Step 3: Compute finite-difference slopes m_j.\n        # This is only possible if there are at least 2 points.\n        if len(points)  2:\n            # According to the model, an estimate isn't possible, but test cases have = 2 points.\n            # A single point would lead to an undefined slope.\n            # For robustness, handle this edge case, though not triggered by test data.\n            results.append(np.nan) \n            continue\n\n        slopes = []\n        for j in range(len(points) - 1):\n            delta_y = sorted_y[j+1] - sorted_y[j]\n            delta_x = sorted_x[j+1] - sorted_x[j]\n            \n            # Avoid division by zero, although sorted distinct p values should prevent this.\n            if delta_x == 0:\n                continue \n            \n            m_j = delta_y / delta_x\n            slopes.append(m_j)\n        \n        # If no valid slopes were computed (e.g., all x are identical), handle it.\n        if not slopes:\n            results.append(np.nan)\n            continue\n            \n        # Step 4: Aggregate these slopes robustly by taking the median.\n        m_hat = np.median(slopes)\n        \n        # Step 5: Interpret this aggregated slope as estimating the complement of the serial fraction.\n        f_hat = 1.0 - m_hat\n        \n        # Step 6: Bound f_hat to the interval [0,1].\n        f_clipped = np.clip(f_hat, 0.0, 1.0)\n        \n        results.append(f_clipped)\n\n    # Format results to exactly 4 decimal places for the final output.\n    formatted_results = [f\"{res:.4f}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3169134"}]}