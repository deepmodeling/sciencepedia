{"hands_on_practices": [{"introduction": "为了将理论知识转化为解决实际问题的能力，本章提供了一系列动手实践，旨在加深你对共享内存与分布式内存系统核心差异的理解。我们将从最基本的交互模式出发，逐步扩展到宏观的系统设计决策。第一个练习[@problem_id:3191797]将通过一个经典的“乒乓”测试来揭示数据交换的底层成本，让你能够量化对比共享内存中因缓存一致性产生的隐式通信与分布式内存中的显式消息传递。", "problem": "一位开发人员正在分析共享内存系统和分布式内存系统之间的性能差异。在共享内存系统中，位于不同中央处理器（CPU）核心上的两个线程交替写入同一内存位置，该位置假定位于同一缓存行中，从而引发缓存一致性流量。在分布式内存系统中，两个进程通过网络交替向对方发送固定大小的消息。目标是从基本原理出发，构建一个量化模型，并实现一个程序，用于计算给定事件数量的总时间，并统计一致性或消息传递事件的数量。\n\n使用以下基础模型：\n\n- 共享内存系统中的缓存一致性对每个缓存行强制执行单写入者不变量。当一个没有所有权的线程试图写入由另一个核心拥有的缓存行时，一致性协议会执行失效操作并转移所有权，这相对于本地写入会产生额外的延迟。这是在现代多处理器中经过充分验证的观察结果。设缓存行大小为 $C$ 字节。设每次事件的本地写入时间为 $t_{w}$（单位：纳秒）。设一致性传输产生的延迟为 $L_{\\text{coh}}$（单位：纳秒），外加一个由持续内存系统带宽 $B_{\\text{sm}}$（单位：吉字节/秒，使用吉字节定义 $1\\,\\text{GB}=10^{9}$ 字节）决定的数据移动时间。该模型必须反映出，仅当写入者不是缓存行的当前所有者时，才会发生一致性传输。\n\n- 通过网络进行的消息传递具有延迟-带宽行为：发送一个大小为 $M$ 字节的消息所需的时间是一个固定延迟 $L_{\\text{net}}$（单位：纳秒）、一个由链路带宽 $B_{\\text{net}}$（单位：吉字节/秒，其中 $1\\,\\text{GB}=10^{9}$ 字节）决定的传输时间，以及一个每条消息的软件开销 $o$（单位：纳秒）的总和。这是一个被广泛接受的延迟-带宽模型。\n\n开发者必须在两种系统中考虑一种综合访问模式：\n\n- 共享内存乒乓（ping-pong）：两个线程交替写入同一逻辑位置。该位置在数组内的地址步长为 $s$ 字节。如果 $s  C$，写入会命中同一缓存行，从而引发一致性事件；如果 $s \\ge C$，则不会。\n- 分布式内存乒乓（ping-pong）：两个进程交替向对方发送一个大小为 $M$ 字节的消息。\n\n在这两种情况下，总共发生 $E$ 次交替写入或发送事件。您的任务是：\n\n1.  为共享内存系统推导总时间 $T_{\\text{sm}}(E)$ 和一致性事件计数 $X_{\\text{sm}}(E)$ 的模型。\n2.  为分布式内存系统推导总时间 $T_{\\text{dist}}(E)$ 和消息事件计数 $X_{\\text{dist}}(E)$ 的模型。\n3.  实现一个函数，该函数接收包含五个测试用例的测试套件，其中每个测试用例提供所有必要参数的数值 `(E, C, s, t_w, L_coh, B_sm, L_net, B_net, o, M)`。对于每个测试用例，计算并返回一个元组 `[T_sm(E), X_sm(E), T_dist(E), X_dist(E)]`，其中时间以纳秒为单位，事件计数为整数。\n\n最终输出必须是一个二维列表，格式为 `[[case1_results], [case2_results], ...]`。", "solution": "用户提供了一个问题陈述，需要对其进行验证，如果有效，则需要一个完整的解决方案。\n\n### 步骤 1：提取已知信息\n问题陈述中提供了以下参数和定义：\n- 共享内存的系统参数：\n    - $C$：缓存行大小，单位为字节。\n    - $t_{w}$：每次事件的本地写入时间，单位为纳秒。\n    - $L_{\\text{coh}}$：一致性传输延迟，单位为纳秒。\n    - $B_{\\text{sm}}$：持续内存系统带宽，单位为吉字节/秒（$1\\,\\text{GB}=10^{9}$ 字节）。\n- 分布式内存的系统参数：\n    - $M$：消息大小，单位为字节。\n    - $L_{\\text{net}}$：网络延迟，单位为纳秒。\n    - $B_{\\text{net}}$：网络链路带宽，单位为吉字节/秒（$1\\,\\text{GB}=10^{9}$ 字节）。\n    - $o$：每条消息的软件开销，单位为纳秒。\n- 访问模式参数：\n    - $E$：交替写入或发送事件的总数。\n    - $s$：共享内存情况下的地址步长，单位为字节。\n- 共享内存一致性的条件：\n    - 如果 $s  C$，则发生一致性传输。\n    - 如果 $s \\ge C$，则不发生一致性传输。\n- 建模要求：\n    - 为共享内存系统推导总时间 $T_{\\text{sm}}(E)$ 和事件计数 $X_{\\text{sm}}(E)$ 的模型。\n    - 为分布式内存系统推导总时间 $T_{\\text{dist}}(E)$ 和事件计数 $X_{\\text{dist}}(E)$ 的模型。\n- 输出要求：\n    - 对每个测试用例，计算 $[T_{\\text{sm}}(E), X_{\\text{sm}}(E), T_{\\text{dist}}(E), X_{\\text{dist}}(E)]$。\n    - 时间必须是浮点数，单位为纳秒。\n    - 事件计数必须是整数。\n- 测试套件：一组 5 个测试用例，为所有参数提供数值。\n\n### 步骤 2：使用提取的已知信息进行验证\n根据指定标准对问题进行评估：\n- **科学依据**：该问题基于计算机体系结构和高性能计算中已建立的（尽管是简化的）性能模型。用于消息传递的延迟-带宽模型和用于缓存一致性的延迟加传输时间模型是标准的一阶近似。由缓存行粒度引起的伪共享概念是并行编程中的一个基本主题。该问题在科学上是合理的。\n- **适定性**：所有必要的参数都已定义，目标明确，所需的输出也已指定。该问题是自包含的，其结构可以为每个测试用例导出一个唯一的、稳定的解决方案。\n- **客观性**：该问题使用精确的技术语言陈述，没有主观性或歧义。\n\n该问题不具有任何无效标志。这是一个在计算性能建模方面定义明确的练习。\n\n### 步骤 3：结论与行动\n该问题被判定为**有效**。将开发一个解决方案。\n\n### 基于原理的解决方案推导\n\n目标是推导在“乒乓”访问模式下，两种不同并行编程范式的总时间和事件计数的量化模型。\n\n#### 1. 共享内存系统模型 ($T_{\\text{sm}}$, $X_{\\text{sm}}$)\n在共享内存乒乓场景中，两个线程交替写入一个内存位置。关键因素是这些写入是否竞争同一个缓存行。\n\n**一致性延迟的条件**：当一个线程试图写入它不拥有所有权的缓存行时，会触发一个一致性事件。如果两个线程的写入目标位于同一个缓存行内，就会发生这种情况。给定缓存行大小 $C$ 和两个线程写入位置之间的地址步长 $s$，如果 $s  C$，则会发生引起一致性的“伪共享”或“真共享”场景。如果 $s \\ge C$，则写入位置保证在不同的缓存行中，线程可以独立操作，不会在其核心之间引发一致性流量。\n\n**一致性事件计数 ($X_{\\text{sm}}$)**：我们考虑一个包含 $E$ 次写入事件的交替序列。假设第一次写入（事件 1）由线程 A 执行，从而建立其对该缓存行的所有权。这次初始写入不涉及从另一个核心的传输。第二次写入（事件 2）由线程 B 执行，需要将所有权从线程 A 的缓存转移到线程 B 的缓存。第三次写入（事件 3）由线程 A 执行，需要将所有权从 B 传回 A。此模式对所有后续写入都成立。因此，对于总共 $E$ 次写入事件，一致性传输发生在事件 $2, 3, \\dots, E$。一致性传输的次数为 $E-1$。如果 $E \\le 1$，则不发生传输。此逻辑仅在 $s  C$ 时适用。\n\n因此，一致性事件的数量 $X_{\\text{sm}}$ 为：\n$$ X_{\\text{sm}}(E) = \\begin{cases} \\max(0, E-1)  \\text{if } s  C \\\\ 0  \\text{if } s \\ge C \\end{cases} $$\n结果必须是整数。\n\n**总时间 ($T_{\\text{sm}}$)**：总时间是所有本地写入时间和所有一致性传输时间的总和。$E$ 次事件中的每一次都涉及一次本地写入，耗时 $t_w$。单次一致性传输的成本是固定延迟 $L_{\\text{coh}}$ 和数据移动时间的总和。移动的数据是一个大小为 $C$ 的缓存行。带宽 $B_{\\text{sm}}$ 以 GB/s 为单位。我们将其转换为字节/纳秒。由于 $1\\,\\text{GB} = 10^9\\,\\text{字节}$ 且 $1\\,\\text{s} = 10^9\\,\\text{ns}$，因此 $B_{\\text{sm}}\\,\\text{GB/s}$ 的带宽在数值上等于 $B_{\\text{sm}}\\,\\text{字节/纳秒}$。传输一个缓存行的时间是 $t_{\\text{transfer}} = \\frac{C}{B_{\\text{sm}}}$。因此，一次一致性事件的成本是 $L_{\\text{coh}} + \\frac{C}{B_{\\text{sm}}}$。\n\n总时间 $T_{\\text{sm}}(E)$ 是 $E$ 次本地写入和 $X_{\\text{sm}}(E)$ 次一致性事件的总和：\n$$ T_{\\text{sm}}(E) = (E \\cdot t_w) + X_{\\text{sm}}(E) \\cdot \\left(L_{\\text{coh}} + \\frac{C}{B_{\\text{sm}}}\\right) $$\n代入 $X_{\\text{sm}}(E)$ 的表达式：\n$$ T_{\\text{sm}}(E) = E \\cdot t_w + \\begin{cases} \\max(0, E-1) \\cdot \\left(L_{\\text{coh}} + \\frac{C}{B_{\\text{sm}}}\\right)  \\text{if } s  C \\\\ 0  \\text{if } s \\ge C \\end{cases} $$\n\n#### 2. 分布式内存系统模型 ($T_{\\text{dist}}$, $X_{\\text{dist}}$)\n在分布式内存乒乓中，两个进程交替向对方发送消息。\n\n**消息事件计数 ($X_{\\text{dist}}$)**：问题陈述指出，进程总共进行 $E$ 次发送事件。每次发送都构成一个独立的消息传递事件。因此，消息的总数就是 $E$。\n$$ X_{\\text{dist}}(E) = E $$\n结果必须是整数。\n\n**总时间 ($T_{\\text{dist}}$)**：总时间是所有 $E$ 次消息发送成本的总和。问题描述了单次消息发送的延迟-带宽模型。发送一个大小为 $M$ 的消息的时间是一个固定的网络延迟 $L_{\\text{net}}$、一个每条消息的软件开销 $o$ 和一个传输时间的总和。传输时间由消息大小 $M$ 和网络带宽 $B_{\\text{net}}$ 决定。与 $B_{\\text{sm}}$ 类似，$B_{\\text{net}}$（单位：GB/s）在数值上等于 $B_{\\text{net}}$（单位：字节/纳秒）。传输时间为 $t_{\\text{transmit}} = \\frac{M}{B_{\\text{net}}}$。因此，每条消息的总成本是 $L_{\\text{net}} + o + \\frac{M}{B_{\\text{net}}}$。\n\n由于这 $E$ 个事件是以乒乓模式顺序发生的，总时间是 $E$ 乘以单个事件的成本。\n$$ T_{\\text{dist}}(E) = E \\cdot \\left( L_{\\text{net}} + o + \\frac{M}{B_{\\text{net}}} \\right) $$\n\n将实施这些推导出的模型，以计算所提供测试套件的结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the total time and event counts for shared and distributed memory\n    ping-pong scenarios based on provided performance models.\n    \"\"\"\n\n    # Test suite: (E, C, s, t_w, L_coh, B_sm, L_net, B_net, o, M)\n    test_cases = [\n        # Case 1: general case with false sharing\n        (1000, 64, 8, 3, 100, 40, 5000, 10, 200, 64),\n        # Case 2: boundary, single event\n        (1, 64, 8, 3, 100, 40, 5000, 10, 200, 64),\n        # Case 3: no false sharing, stride crosses cache line\n        (1000, 64, 128, 3, 100, 40, 5000, 10, 200, 64),\n        # Case 4: fast shared memory link, slower network\n        (1000, 64, 8, 2, 10, 200, 20000, 5, 100, 64),\n        # Case 5: larger message size effect\n        (500, 64, 8, 3, 100, 40, 5000, 10, 200, 1024),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        E, C, s, t_w, L_coh, B_sm, L_net, B_net, o, M = case\n\n        # Shared Memory Calculation\n        # Bandwidth B_sm is in GB/s, which is numerically equivalent to bytes/ns.\n        # Check for false sharing condition s  C\n        if s  C:\n            # Coherence transfers occur for every event except the first one.\n            X_sm = max(0, E - 1)\n            # Cost of a single coherence event = latency + data transfer time\n            coherence_cost = float(L_coh) + float(C) / float(B_sm)\n            # Total time = sum of all local write times + sum of all coherence costs\n            T_sm = float(E * t_w) + float(X_sm) * coherence_cost\n        else:\n            # No false sharing means no coherence transfers.\n            X_sm = 0\n            # Total time is just the sum of local write times.\n            T_sm = float(E * t_w)\n\n        # Distributed Memory Calculation\n        # Bandwidth B_net is in GB/s, which is numerically equivalent to bytes/ns.\n        # Number of message events is the total number of events E.\n        X_dist = E\n        # Cost of a single message = latency + overhead + transmission time\n        message_cost = float(L_net) + float(o) + float(M) / float(B_net)\n        # Total time is the number of events multiplied by the cost per event.\n        T_dist = float(E) * message_cost\n\n        # Ensure event counts are integers\n        X_sm = int(X_sm)\n        X_dist = int(X_dist)\n\n        # Append results for this case\n        all_results.append([T_sm, X_sm, T_dist, X_dist])\n\n    # Format the final output string precisely as specified, without spaces.\n    inner_results_str = [\n        f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in all_results\n    ]\n    final_output = f\"[{','.join(inner_results_str)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3191797"}, {"introduction": "在理解了基本的双向交互后，我们现在将这个概念扩展到一个更贴近实际科学计算的场景：基于网格的模拟。当我们将一个大型计算网格分解到多个处理器上时，为了计算边界附近的点，处理器之间必须交换边界数据，即所谓的“幽灵单元”或“晕轮”。这个练习[@problem_id:3191809]将指导你推导这种数据交换带来的存储开销，它直接关系到通信开销，并揭示并行计算效率中至关重要的“表面积-体积比”效应。", "problem": "您正在对一个二维均匀笛卡尔网格上的标量场进行显式时间步进有限差分更新建模。该网格的间距为 $h$，离散了一个水平方向有 $n_1$ 个单元格、垂直方向有 $n_2$ 个单元格的矩形子域。在分布式内存环境中，每个子域由一个进程拥有，并假定其完全位于内部（即有四个邻居）。数值模板的半径为1（一个五点模板），每个进程在其 $n_{1} \\times n_{2}$ 个内部单元格周围分配一个单层单元格厚度的“鬼”层（ghost layer）。为了便于索引和缓冲区打包，鬼层包括了角落的鬼单元格，因此本地分配的大小为 $(n_{1}+2) \\times (n_{2}+2)$。在单节点共享内存环境中，您将计算分块为 $t_{1} \\times t_{2}$ 个内部单元格的瓦片（tile），并在更新 $t_{1} \\times t_{2}$ 个内部单元格之前，将一个单层单元格厚度的“晕”（halo，包括角落）暂存到高速缓存中。\n\n仅从矩形的基本几何事实（周长等于两倍边长之和；面积等于边长之积）以及单层单元格厚度的晕层定义为填充矩形与其内部矩形之间的集合差出发，执行以下推理步骤：\n\n- 推导单个分布式内存子域周围的进程间接口的总物理长度 $H$ 的表达式，用 $h$、$n_{1}$ 和 $n_{2}$ 表示。\n- 从离散结构出发，推导每个分布式内存子域存储的鬼单元格数量 $G_{D}$（包括所有角落），以及相应的无量纲存储开销分数 $f_{D} = G_{D}/(n_{1} n_{2})$。\n- 对于共享内存瓦片，推导除 $t_{1} \\times t_{2}$ 个内部单元格之外暂存的额外元素数量 $G_{S}$（包括角落），以及相应的无量纲暂存开销分数 $f_{S} = G_{S}/(t_{1} t_{2})$。\n- 将分布式内存晕层开销分数与共享内存瓦片边界开销分数之比定义为 $R = f_{D}/f_{S}$，并将 $R$ 简化为一个用 $n_{1}$、$n_{2}$、$t_{1}$ 和 $t_{2}$ 表示的闭式表达式。\n\n提供您最终的答案，即 $R$ 的简化解析表达式。不要代入数值。最终答案不带任何单位。", "solution": "问题涉及两种设置：带有鬼层的分布式内存子域和带有暂存晕的共享内存瓦片。推导可以基于基本几何学和矩形网格的组合学。\n\n首先，考虑子域的物理几何形状。内部区域由水平方向的 $n_{1}$ 个单元格和垂直方向的 $n_{2}$ 个单元格组成。每个单元格的宽度和高度均为 $h$，因此内部矩形的物理边长为 $n_{1} h$ 和 $n_{2} h$。围绕该内部子域的进程间接口的总物理长度是该矩形的周长。根据矩形周长等于其边长之和的两倍这一基本事实，我们得到\n$$\nH = 2\\big(n_{1} h + n_{2} h\\big) = 2 h \\big(n_{1} + n_{2}\\big)\n$$.\n\n其次，考虑分布式内存子域的离散晕，当分配一个包含角落的单层单元格厚度的层时。填充后的数组大小为 $(n_{1}+2) \\times (n_{2}+2)$，内部大小为 $n_{1} \\times n_{2}$。鬼区域是集合差，因此鬼单元格的总数是单元格计数的差值：\n$$\nG_{D} = (n_{1}+2)(n_{2}+2) - n_{1} n_{2} = 2 n_{1} + 2 n_{2} + 4\n$$.\n无量纲存储开销分数是鬼单元格数除以内部区域的单元格面积（归一化）：\n$$\nf_{D} = \\frac{G_{D}}{n_{1} n_{2}} = \\frac{2 n_{1} + 2 n_{2} + 4}{n_{1} n_{2}}\n$$.\n\n第三，对于大小为 $t_{1} \\times t_{2}$ 个内部单元格、带有一个单层单元格厚度的暂存晕（包括角落）的共享内存瓦片，适用同样的填充与内部逻辑。总暂存区域有 $(t_{1}+2)(t_{2}+2)$ 个元素，其中 $t_{1} t_{2}$ 个是内部元素。因此，暂存的额外元素数量为\n$$\nG_{S} = (t_{1}+2)(t_{2}+2) - t_{1} t_{2} = 2 t_{1} + 2 t_{2} + 4\n$$,\n且无量纲暂存开销分数为\n$$\nf_{S} = \\frac{G_{S}}{t_{1} t_{2}} = \\frac{2 t_{1} + 2 t_{2} + 4}{t_{1} t_{2}}\n$$.\n\n最后，定义分布式内存晕层开销分数与共享内存瓦片边界开销分数之比：\n$$\nR = \\frac{f_{D}}{f_{S}} = \\frac{\\dfrac{2 n_{1} + 2 n_{2} + 4}{n_{1} n_{2}}}{\\dfrac{2 t_{1} + 2 t_{2} + 4}{t_{1} t_{2}}}\n$$.\n通过适当地乘以分子和分母来简化这个复合分数，得到\n$$\nR = \\frac{(2 n_{1} + 2 n_{2} + 4)\\, t_{1} t_{2}}{(2 t_{1} + 2 t_{2} + 4)\\, n_{1} n_{2}}\n$$.\n这个闭式表达式比较了分布式内存中的晕层开销分数与共享内存瓦片中的边界暂存开销分数的大小，它纯粹是内部维度 $n_{1}$、$n_{2}$、$t_{1}$ 和 $t_{2}$ 的函数，由基本的周长和集合差计数原理推导得出。", "answer": "$$\\boxed{\\frac{(2 n_{1} + 2 n_{2} + 4)\\, t_{1} t_{2}}{(2 t_{1} + 2 t_{2} + 4)\\, n_{1} n_{2}}}$$", "id": "3191809"}, {"introduction": "最后，让我们将视角提升到在集群上并行化算法时的最高层设计决策。面对一个庞大的数据集，首要问题通常是：我们应该在每个节点上复制整个数据集，还是将其分割（分片）到不同节点上？这个实践[@problem_id:3191832]将通过一个具体场景，引导你完成基于内存限制做出此决策所需的“信封背面计算”，并估算分片策略带来的通信成本。", "problem": "一位计算科学家正在评估在集群上处理一个大型一维数组的两种并行化策略：在每个节点上复制整个数组，以及将数组分片到不同节点并使用最近邻的幽灵单元。目标是判断复制策略是否可行，如果不可行，则确定在分片策略下需要多少节点才能满足每个节点的内存限制，并量化每次迭代中幽灵单元交换的通信时间。\n\n使用的基本定义和事实：\n- 在共享内存设计中，所有线程可以访问单个内存地址空间；而在分布式内存设计中，每个进程拥有私有内存，任何非本地可用的数据都必须通过通信获取。\n- 在分布式内存环境下的复制策略中，每个节点在本地存储整个数组，因此每个节点的内存占用等于整个数组的大小。\n- 在使用一维块分解将数组分片到 $p$ 个节点的情况下，每个节点存储其本地数据块以及为两个邻居（左和右）准备的幽灵单元。如果每个边界需要 $g$ 个幽灵元素，那么每个节点在其本地数据块之外还额外存储 $2g$ 个元素。\n- 在一个只考虑带宽的通信模型中（忽略延迟），通信时间与传输的字节数成正比：$T = \\beta \\times B$，其中 $B$ 是传输的总字节数，$\\beta$ 是每字节秒数的系数。\n\n给定数据：\n- 数组长度为 $A = 6.0 \\times 10^{9}$ 个元素。\n- 每个元素大小为 $s = 8$ 字节。\n- 每个节点的随机存取存储器（RAM）为 $M = 24 \\times 10^{9}$ 字节。\n- 每次迭代中，每个节点需要为每个邻居（共两个邻居）准备 $g = 5.0 \\times 10^{6}$ 个幽灵元素。\n- 带宽模型的比例系数为 $\\beta = 2.5 \\times 10^{-10}$ 秒/字节。\n\n任务：\n1. 通过将整个数组的大小与每个节点的内存 $M$ 进行比较，判断复制策略是否可行。\n2. 如果复制策略不可行，确定最小整数 $p$，使得分片布局能够装入单个节点的内存中，需要考虑本地数据块和幽灵单元。\n3. 使用只考虑带宽的模型，计算每次迭代中每个节点与两个邻居交换幽灵单元的通信时间（只计算发送；假设交换是对称的，并忽略延迟）。以秒为单位表示时间。\n\n将通信时间四舍五入到四位有效数字。按顺序报告你的最终答案：最小的 $p$ 值和每个节点的幽灵单元交换时间（秒）。", "solution": "首先根据所需标准对问题陈述进行验证。\n\n### 第1步：提取给定数据\n- 数组长度：$A = 6.0 \\times 10^{9}$ 个元素\n- 每个元素的大小：$s = 8$ 字节\n- 每个节点的RAM：$M = 24 \\times 10^{9}$ 字节\n- 每个邻居的幽灵元素：$g = 5.0 \\times 10^{6}$ 个元素\n- 幽灵单元交换的邻居数量：$2$\n- 带宽模型系数：$\\beta = 2.5 \\times 10^{-10}$ 秒/字节\n\n### 第2步：使用提取的数据进行验证\n- **科学依据**：该问题使用了高性能和并行计算中的标准概念，包括内存限制、域分解（分片）、用于边界数据交换的幽灵单元，以及一个简化的只考虑带宽的通信模型。这些是计算科学中基本且成熟的原理。所提供的数值虽然很大，但对于现代高性能计算集群而言是合理的。\n- **适定性**：该问题的结构清晰，包含一系列明确的任务，可以导出一个唯一的、可量化的解决方案。所有必要的数据均已提供。\n- **客观性**：该问题以精确、量化的术语陈述，没有任何主观或模棱两可的语言。\n\n### 第3步：结论与行动\n该问题是有效的，因为它具有科学依据、适定、客观，并包含足够的信息以获得唯一解。我将继续进行完整解答。\n\n### 任务1：复制策略的可行性\n首先，我们判断在每个节点上复制整个数组是否是一种可行的策略。这需要将数组的总大小与单个节点上的可用内存进行比较。\n\n数组的总大小 $S_{total}$ 是元素数量 $A$ 与每个元素大小 $s$ 的乘积。\n$$S_{total} = A \\times s$$\n代入给定值：\n$$S_{total} = (6.0 \\times 10^{9} \\text{ 元素}) \\times (8 \\text{ 字节/元素}) = 48 \\times 10^{9} \\text{ 字节}$$\n\n每个节点的可用内存为 $M = 24 \\times 10^{9}$ 字节。\n我们将 $S_{total}$ 与 $M$ 进行比较：\n$$48 \\times 10^{9} \\text{ 字节} > 24 \\times 10^{9} \\text{ 字节}$$\n由于数组总大小 $S_{total}$ 大于每个节点的内存 $M$，因此在每个节点上复制整个数组是不可行的。\n\n### 任务2：分片策略所需的最少节点数\n由于复制策略不可行，我们必须使用分片（域分解）策略。我们需要找到最小的节点数 $p$，使得每个节点上的数组部分（包括幽灵单元）能够装入该节点的内存 $M$ 中。\n\n对于一个分片到 $p$ 个节点上的一维数组，每个节点存储一个大小为 $A/p$ 个元素的本地数据块。此外，每个节点还存储为其两个邻居（左和右）准备的幽灵单元。问题陈述中说明每个边界需要 $g$ 个幽灵元素。因此，每个节点必须额外存储 $2g$ 个元素。\n\n单个节点上存储的总元素数 $N_p$ 是其本地数据块和幽灵单元的总和：\n$$N_p = \\frac{A}{p} + 2g$$\n\n每个节点的总内存占用 $M_p$ 是元素数量 $N_p$ 乘以每个元素的大小 $s$：\n$$M_p = \\left(\\frac{A}{p} + 2g\\right) \\times s$$\n\n为使此布局可行，每个节点的内存占用 $M_p$ 必须小于或等于每个节点的可用内存 $M$：\n$$M_p \\leq M$$\n$$\\left(\\frac{A}{p} + 2g\\right) \\times s \\leq M$$\n\n我们对 $p$ 求解这个不等式：\n$$\\frac{A}{p} + 2g \\leq \\frac{M}{s}$$\n$$\\frac{A}{p} \\leq \\frac{M}{s} - 2g$$\n$$p \\geq \\frac{A}{\\frac{M}{s} - 2g}$$\n\n现在，我们代入给定值：\n$A = 6.0 \\times 10^{9}$\n$M = 24 \\times 10^{9}$\n$s = 8$\n$g = 5.0 \\times 10^{6}$\n\n首先，计算分母中的项：\n$$\\frac{M}{s} - 2g = \\frac{24 \\times 10^{9}}{8} - 2 \\times (5.0 \\times 10^{6})$$\n$$\\frac{M}{s} - 2g = 3.0 \\times 10^{9} - 1.0 \\times 10^{7}$$\n$$\\frac{M}{s} - 2g = 300 \\times 10^{7} - 1.0 \\times 10^{7} = 299 \\times 10^{7} = 2.99 \\times 10^{9}$$\n\n现在，将此结果代回关于 $p$ 的不等式中：\n$$p \\geq \\frac{6.0 \\times 10^{9}}{2.99 \\times 10^{9}}$$\n$$p \\geq \\frac{6.0}{2.99} \\approx 2.00668896...$$\n\n由于节点数 $p$ 必须是整数，因此 $p$ 的最小值是满足此条件的最小整数，即 $2.00668896...$ 的上取整。\n$$p_{min} = 3$$\n\n### 任务3：每个节点的通信时间\n每次迭代的通信时间 $T$ 使用只考虑带宽的模型计算，$T = \\beta \\times B$，其中 $B$ 是每个节点传输的总字节数。\n\n问题要求计算“与两个邻居交换幽灵单元（只计算发送）”的时间。这意味着我们计算一个节点发送的数据量。一次典型的幽灵单元交换涉及一个节点将其左边界数据发送给其左邻居，并将其右边界数据发送给其右邻居。每次传输都涉及 $g$ 个元素。\n\n一个节点发送的总元素数 = $g (\\text{到左侧}) + g (\\text{到右侧}) = 2g$。\n一个节点发送的总字节数 $B$ 为：\n$$B = 2g \\times s$$\n$$B = 2 \\times (5.0 \\times 10^{6}) \\times 8 = 1.0 \\times 10^{7} \\times 8 = 8.0 \\times 10^{7} \\text{ 字节}$$\n\n现在，我们计算通信时间 $T$：\n$$T = \\beta \\times B$$\n$$T = (2.5 \\times 10^{-10} \\text{ 秒/字节}) \\times (8.0 \\times 10^{7} \\text{ 字节})$$\n$$T = (2.5 \\times 8.0) \\times (10^{-10} \\times 10^{7}) \\text{ s}$$\n$$T = 20.0 \\times 10^{-3} \\text{ s} = 0.02 \\text{ s}$$\n\n问题要求将通信时间四舍五入到四位有效数字。计算出的精确值为 $0.02$。为了用四位有效数字表示，我们写作 $2.000 \\times 10^{-2}$。\n\n最终答案需要两个值：最小整数 $p$ 和通信时间（秒）。\n- 最小 $p = 3$\n- 通信时间 $T = 2.000 \\times 10^{-2}$ s", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n3  2.000 \\times 10^{-2}\n\\end{pmatrix}\n}\n$$", "id": "3191832"}]}