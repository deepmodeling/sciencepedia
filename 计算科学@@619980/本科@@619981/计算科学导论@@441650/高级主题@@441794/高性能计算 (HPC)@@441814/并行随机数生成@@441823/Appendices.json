{"hands_on_practices": [{"introduction": "在将串行代码并行化时，一个看似简单的任务——处理随机数——实际上充满了陷阱。我们最直观的想法，比如让每个线程使用相同的种子，或者让所有线程共享一个全局的生成器，往往会导致灾难性的后果：产生的序列不再是统计独立的。这个实践将引导你亲手构建这两种错误的场景[@problem_id:3178991]，通过量化分析（例如计算相关系数），让你直观地理解为什么这些方法是错误的，并最终展示确保独立性的正确方法。这是构建可靠并行模拟的第一步。", "problem": "要求您编写一个完整、可运行的程序，定量且确定性地展示在多线程代码中意外共享伪随机数生成器状态如何产生相互依赖的流，以及如何为每个线程隔离流以防止这种情况。上下文是计算科学导论中的伪随机数生成，任务必须使用关于确定性状态机和经验统计比较的基本原理解来决断。伪随机数生成器是一个确定性有限状态机，具有状态更新函数和输出函数。如果两个线程从同一状态机消费，它们的输出属于同一个底层流，并且不是独立的。如果两个线程各自使用相同的种子创建自己的状态机，它们将产生完全相同的流。正确的隔离需要从一个主种子派生出每个线程的初始状态，且不能重叠。\n\n使用的基本原理：\n- 伪随机数生成器 (PRNG) 是一个确定性有限状态机：存在一个状态更新函数 $F$ 和一个输出函数 $G$，使得给定初始状态 $s_0$，状态通过 $s_{t+1} = F(s_t)$ 演化并产生输出 $x_t = G(s_t)$。确定性意味着同一状态机的两个消费者产生的是同一个唯一序列 $\\{x_t\\}$ 的不同部分，因此它们的输出通过共享状态而相互依赖。流的独立性要求初始状态不同且不重叠。\n- 可以使用两个实数序列之间的 Pearson 相关系数 $r$ 对独立性进行经验比较，该系数根据有限样本上的标准定义计算。两个独立同分布的$\\text{Uniform}(0,1)$序列的独立性意味着，对于足够大的样本量 $n$，$r$ 会集中在 $0$ 附近，而完全相同的序列则得到 $r = 1$。\n- 在此类实验中，通过固定种子并仔细控制共享状态的消耗调度，可以获得确定性的可复现性。\n\n您的程序必须实现三个多线程实验，每个实验都创建两个伪随机数流，每流抽取 $n$ 次，使用标准数值库中可用的置换同余生成器 (PCG) 引擎 (PCG64)。所有数值量和变量都必须解释为纯数字，不带物理单位。\n\n需要实现的实验：\n1) 意外的“每线程相同种子”错误。创建 2 个工作线程。每个线程创建自己的本地 PRNG 实例，但两个线程都使用相同的固定种子 $s$。每个线程在 $[0,1)$ 区间内产生 $n$ 个实数。计算两个长度为 $n$ 的序列之间的经验 Pearson 相关系数 $r_1$。由于两个线程产生的是相同的确定性序列，当对完全相同的序列进行精确计算时，这个 $r_1$ 应等于 $1$。\n2) 带有强制交替的共享全局生成器。创建 2 个工作线程，它们共享一个以 $s$ 为种子的全局 PRNG 实例。强制执行严格的交替调度，使线程以 $A_0, B_0, A_1, B_1, \\dots, A_{n-1}, B_{n-1}$ 的精确顺序进行抽取，其中 $A_i$ 是分配给线程 A 的抽取值，$B_i$ 是分配给线程 B 的抽取值。另外，使用相同的种子 $s$，生成一个长度为 $2n$ 的单线程参考序列 $Z$。通过以相同的交替顺序交错两个线程的输出，构建合并序列 $M$。输出一个布尔值 $b_2$，指示 $M$ 是否与 $Z$ 逐元素相同。$b_2 = \\text{True}$ 的值表明，两个线程流是单个流的确定性依赖子序列。\n3) 通过主种子实现正确的每线程流隔离。使用单个主种子 $s$ 初始化一个主种子序列对象，然后为两个每线程 PRNG 实例 (PCG64) 派生出两个独立的子种子序列，从而使这两个流在构造上是不重叠的。运行 2 个线程，每个线程从其自己的 PRNG 生成 $n$ 个在 $[0,1)$ 区间内的实数。计算两个序列之间的经验 Pearson 相关系数 $r_3$。对于足够大的 $n$，这个 $r_3$ 的绝对值应接近于 $0$。\n\n测试套件和参数：\n- 使用以下三个测试用例，每个都是一个三元组 $(\\text{scenario}, n, s)$：\n  - `(\"same_seed_per_thread\", 4096, 123456789)`\n  - `(\"shared_generator_interleaved\", 4096, 123456789)`\n  - `(\"spawn_isolated_per_thread\", 4096, 123456789)`\n- 对于相关系数 $r_1$ 和 $r_3$，将其报告为四舍五入到 6 位小数的浮点数。\n- 对于实验 2 中的相等性检查，报告布尔值 $b_2$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。该列表的顺序必须与上述测试套件相对应，即 $[r_1, b_2, r_3]$，其中 $r_1$ 和 $r_3$ 是精确到 6 位小数的浮点数，而 $b_2$ 是一个布尔字面量。例如，一个语法上有效的输出看起来像 $[1.000000,True,0.001234]$。", "solution": "该问题要求对多线程程序中伪随机数生成器 (PRNG) 状态管理的效果进行确定性、定量的演示。其核心原理是，PRNG 是一个确定性有限状态机。其输出序列完全由其初始状态（或称种子）决定。正确的并行 PRNG 用法要求每个执行线程都在一个独立的随机数流上操作，这需要每个线程的 PRNG 都用一个能保证其序列不与其它序列重叠的状态来初始化。\n\n一个 PRNG 可以用状态空间 $S$、初始状态 $s_0 \\in S$、状态转移函数 $F: S \\to S$ 和输出函数 $G: S \\to \\mathbb{R}$ 来建模。状态序列由 $s_{t+1} = F(s_t)$ 给出，伪随机数序列为 $x_t = G(s_t)$。\n\n为了经验性地评估两个随机数流的独立性，我们使用 Pearson 相关系数 $r$。对于两个样本序列 $X = \\{x_i\\}_{i=1}^n$ 和 $Y = \\{y_i\\}_{i=1}^n$，其样本均值分别为 $\\bar{x}$ 和 $\\bar{y}$，相关系数为：\n$$\nr = \\frac{\\sum_{i=1}^n (x_i - \\bar{x})(y_i - \\bar{y})}{\\sqrt{\\sum_{i=1}^n (x_i - \\bar{x})^2} \\sqrt{\\sum_{i=1}^n (y_i - \\bar{y})^2}}\n$$\n对于完全相关的序列（即，在线性变换下相同），$|r|=1$。对于统计独立的序列，对于较大的样本量 $n$，$r$ 预计会接近 $0$。\n\n我们将使用 `numpy` 库提供的 PCG64 生成器来实现三个实验，每线程样本量为 $n=4096$，种子为 $s=123456789$。\n\n1.  **实验 1：每线程相同种子。**\n    这个实验模拟了一个常见错误，即两个线程 $T_A$ 和 $T_B$ 各自创建了一个新的 PRNG 实例，但使用了相同的种子 $s$。由于 PRNG 是确定性的，两个线程都初始化了相同的状态机：$(F, G, s_0=s)$。因此，两个线程将生成完全相同的 $n$ 个数字序列。来自 $T_A$ 的序列（我们称之为 $X_A$）将与来自 $T_B$ 的序列 $X_B$ 逐元素相同。因此，计算 $X_A$ 和 $X_B$ 之间的 Pearson 相关系数 $r_1$ 将得到一个恰好为 $r_1=1$ 的值，这表明完全缺乏独立性。\n\n2.  **实验 2：带强制交替的共享全局生成器。**\n    这个实验演示了两个线程 $T_A$ 和 $T_B$ 共享一个 PRNG 实例的后果。PRNG 的状态 $s_t$ 成为一个共享资源。为了使结果具有确定性和可验证性，我们使用同步原语（信号量）来强制执行严格的交替抽取调度。$T_A$ 抽取，然后 $T_B$ 抽取，接着 $T_A$ 抽取，依此类推。两个线程的总抽取序列为 $\\{A_0, B_0, A_1, B_1, \\dots, A_{n-1}, B_{n-1}\\}$。这个交错过程等效于单个线程抽取 $2n$ 个数字。为了证明这一点，我们使用相同的种子 $s$ 初始化一个单线程，生成一个长度为 $2n$ 的参考序列 $Z$。然后，我们通过交错来自 $T_A$ 和 $T_B$ 的输出来构建一个合并序列 $M$。我们预期布尔比较 $b_2 = (M \\equiv Z)$ 的结果为 True，这证实了这两个线程并未产生独立的流，而是同一个底层流的不相交子序列。\n\n3.  **实验 3：通过派生实现正确的流隔离。**\n    这个实验演示了在并行应用程序中创建独立随机数流的正确方法。我们不直接使用相同的种子，而是使用一个主种子 $s$ 来初始化一个 `SeedSequence` 对象。该对象充当一个工厂，为多个 PRNG 生成具有密码学强度的独立种子数据。我们使用其 `spawn(2)` 方法创建两个子 `SeedSequence` 对象 $ss_A$ 和 $ss_B$。这些子对象保证能初始化生成不重叠、统计独立的序列的 PRNG。线程 $T_A$ 使用从 $ss_A$ 初始化的 PRNG，线程 $T_B$ 使用从 $ss_B$ 初始化的 PRNG。得到的序列 $X_A$ 和 $X_B$ 将是统计独立的。它们之间计算出的 Pearson 相关系数 $r_3$ 将接近于零，反映了这种独立性。$r_3$ 的量级预计在 $1/\\sqrt{n}$ 左右。对于 $n=4096$，我们预期 $|r_3| \\approx 1/\\sqrt{4096} \\approx 0.0156$。\n\n下面的程序实现了这三个实验，计算了所需的指标（$r_1$、$b_2$、$r_3$），并按规定格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport threading\n\ndef solve():\n    \"\"\"\n    Runs three experiments to demonstrate PRNG state management in multithreading.\n    1. Same seed per thread - correlated streams.\n    2. Shared generator - dependent streams.\n    3. Spawning child seeds - independent streams.\n    \"\"\"\n    \n    # Define the test parameters from the problem statement.\n    # n and s are the same for all three experiments.\n    n = 4096\n    s = 123456789\n\n    # --- Experiment 1: \"same_seed_per_thread\" ---\n    # Each thread creates its own PRNG from the same seed.\n    def worker_exp1(seed, size, out_array):\n        \"\"\"Worker for experiment 1: creates a local PRNG.\"\"\"\n        rng = np.random.Generator(np.random.PCG64(seed))\n        out_array[:] = rng.random(size)\n\n    stream1_exp1 = np.empty(n, dtype=np.float64)\n    stream2_exp1 = np.empty(n, dtype=np.float64)\n    \n    thread1 = threading.Thread(target=worker_exp1, args=(s, n, stream1_exp1))\n    thread2 = threading.Thread(target=worker_exp1, args=(s, n, stream2_exp1))\n    \n    thread1.start()\n    thread2.start()\n    thread1.join()\n    thread2.join()\n\n    # The streams should be identical, so correlation is 1.0.\n    r1 = np.corrcoef(stream1_exp1, stream2_exp1)[0, 1]\n\n    # --- Experiment 2: \"shared_generator_interleaved\" ---\n    # Threads share one PRNG, with access ordered by semaphores.\n    def worker_A_exp2(rng, size, sem_a, sem_b, out_array):\n        \"\"\"Worker A: acquires sem_a, releases sem_b.\"\"\"\n        for i in range(size):\n            sem_a.acquire()\n            out_array[i] = rng.random()\n            sem_b.release()\n\n    def worker_B_exp2(rng, size, sem_a, sem_b, out_array):\n        \"\"\"Worker B: acquires sem_b, releases sem_a.\"\"\"\n        for i in range(size):\n            sem_b.acquire()\n            out_array[i] = rng.random()\n            sem_a.release()\n\n    shared_rng = np.random.Generator(np.random.PCG64(s))\n    stream_a_exp2 = np.empty(n, dtype=np.float64)\n    stream_b_exp2 = np.empty(n, dtype=np.float64)\n\n    # Semaphores to enforce strict A, B, A, B... alternation.\n    sem_a = threading.Semaphore(1)\n    sem_b = threading.Semaphore(0)\n\n    thread_a = threading.Thread(target=worker_A_exp2, args=(shared_rng, n, sem_a, sem_b, stream_a_exp2))\n    thread_b = threading.Thread(target=worker_B_exp2, args=(shared_rng, n, sem_a, sem_b, stream_b_exp2))\n    \n    thread_a.start()\n    thread_b.start()\n    thread_a.join()\n    thread_b.join()\n\n    # Interleave the results from the two threads.\n    merged_sequence = np.empty(2 * n, dtype=np.float64)\n    merged_sequence[0::2] = stream_a_exp2\n    merged_sequence[1::2] = stream_b_exp2\n    \n    # Generate the single-threaded reference sequence.\n    ref_rng = np.random.Generator(np.random.PCG64(s))\n    reference_sequence = ref_rng.random(2 * n)\n\n    # The interleaved threaded sequence should be identical to the reference.\n    b2 = np.array_equal(merged_sequence, reference_sequence)\n\n    # --- Experiment 3: \"spawn_isolated_per_thread\" ---\n    # Each thread gets an independent PRNG from a spawned SeedSequence.\n    def worker_exp3(rng, size, out_array):\n        \"\"\"Worker for experiment 3: uses a pre-made PRNG.\"\"\"\n        out_array[:] = rng.random(size)\n\n    # Create a master SeedSequence and spawn two independent children.\n    ss = np.random.SeedSequence(s)\n    child_sequences = ss.spawn(2)\n    \n    rng1_exp3 = np.random.Generator(np.random.PCG64(child_sequences[0]))\n    rng2_exp3 = np.random.Generator(np.random.PCG64(child_sequences[1]))\n\n    stream1_exp3 = np.empty(n, dtype=np.float64)\n    stream2_exp3 = np.empty(n, dtype=np.float64)\n\n    thread1_exp3 = threading.Thread(target=worker_exp3, args=(rng1_exp3, n, stream1_exp3))\n    thread2_exp3 = threading.Thread(target=worker_exp3, args=(rng2_exp3, n, stream2_exp3))\n    \n    thread1_exp3.start()\n    thread2_exp3.start()\n    thread1_exp3.join()\n    thread2_exp3.join()\n    \n    # The streams should be independent, so correlation is near 0.\n    r3 = np.corrcoef(stream1_exp3, stream2_exp3)[0, 1]\n\n    # Final print statement in the exact required format.\n    print(f\"[{r1:.6f},{b2},{r3:.6f}]\")\n\nsolve()\n```", "id": "3178991"}, {"introduction": "了解了并行随机数生成的陷阱之后，我们来学习一种经典的解决方案：序列分割。对于像线性同余生成器（LCG）这样有状态的生成器，我们可以将它产生的单一长序列分割成不重叠的子序列，分配给每个并行进程。为了高效地实现这一点，我们将实现一个“跳跃”（skip-ahead）函数[@problem_id:3170099]，它允许任何进程直接计算并跳转到其子序列的起始状态，而无需从头开始迭代。通过这个练习，你将能确保一个蒙特卡洛模拟，无论使用多少进程，都能得到比特级别完全相同的结果，这是科学计算中可复现性的一个关键要求。", "problem": "要求您设计并实现一个规范方案，该方案使用分块方法为 $p$ 个消息传递接口(MPI)进程分配独立的伪随机数生成器(PRNG)流，并验证 $\\hat{\\pi}$ 的蒙特卡洛估计量在不同进程数量下的可复现性。整个解决方案必须以一个完整、可运行的程序来表达。\n\n使用的基本原理：\n- 伪随机数生成器(PRNG)流的定义：一个由状态更新规则产生的确定性序列 $\\{x_n\\}$。\n- 线性同余生成器(LCG)的定义：一个模为 $m$ 的LCG由递推关系 $x_{n+1} = (a x_n + c) \\bmod m$ 定义，其初始状态为 $x_0$。\n- 将一个均匀整数状态映射到 $[0,1)$ 内的均匀实数变量：通过提取高位比特并乘以一个合适的2的幂来生成一个浮点数。\n- $\\pi$ 的蒙特卡洛估计：通过在 $[0,1]^2$ 中均匀采样 $(x,y)$ 并统计单位圆四分之一内的命中次数，估计量为 $\\hat{\\pi} = 4 H / N$，其中 $H$ 是命中次数，$N$ 是总试验次数。\n\n设计目标：\n1. 为 $p$ 个进程中的每一个分配一个不相交的连续试验索引块，使得对于固定的总试验次数 $N$，所有已分配试验的并集恰好是 $\\{0,1,\\dots,N-1\\}$，且此结果与 $p$ 无关，并且没有两个进程共享同一个索引。根据需要使用不等长尾块的分块方法。一个标准的连续分区定义如下：令 $q = \\lfloor N/p \\rfloor$ 和 $r = N \\bmod p$，则进程 $i$ 被分配的起始块为 $S_i = i q + \\min(i,r)$，块长度为 $L_i = q + 1$（如果 $i  r$）或 $L_i = q$（其他情况）。\n2. 每个试验索引 $t$ 对应两次PRNG抽取 $(u_{2t}, u_{2t+1})$ 以形成 $(x,y)$。因此，进程 $i$ 必须从位置 $2 S_i$ 开始其PRNG流，并消耗 $2 L_i$ 个值。为了高效地实现这一点，需要为LCG实现一个“向前跳转”例程，以便在不逐一迭代的情况下将状态向前推进 $k$ 步。\n\n科学和算法要求：\n- 使用一个LCG，其模数 $m = 2^{64}$，乘数 $a = 6364136223846793005$，增量 $c = 1442695040888963407$，以及一个在 $\\{0,1,\\dots,m-1\\}$ 内任意但固定的种子 $x_0$。当 $c$ 为奇数时，这些常数会产生一个模 $2^{64}$ 的满周期LCG，这是一个经过充分测试的配置。\n- 使用仿射变换的复合来推导并实现一种高效的向前跳转方法。对于单步操作，$T(x) = a x + c \\bmod m$ 是一个仿射映射。展示如何使用平方求幂和变换复合来计算 $T^k(x) = A_k x + C_k \\bmod m$，并避免模除法。\n- 通过取 $x_n$ 的最高53个比特位并乘以 $2^{-53}$，将每个 $x_n$ 映射到一个双精度实数 $u_n \\in [0,1)$，以确保在双精度网格上的均匀性。\n- 通过分块将试验分配给 $p$ 个模拟进程，通过向前跳转适当地推进每个进程的PRNG状态，并累加所有进程的命中次数 $H$，来模拟蒙特卡洛估计量 $\\hat{\\pi}$。\n\n测试套件：\n- 对于每个测试用例，程序必须返回一个布尔值，以指明所规定的可复现性或分块属性是否成立。共有四个测试用例：\n    1. 理想情况下的可复现性：$N = 200000$，进程数 $p \\in \\{1,2,4,8\\}$。验证所有 $\\hat{\\pi}$ 估计值作为浮点数完全相等。\n    2. N不可整除情况下的可复现性：$N = 123457$，进程数 $p \\in \\{3,5,7\\}$。验证在所有 $p$ 值下 $\\hat{\\pi}$ 相等。\n    3. 进程数相对于试验次数较多的边界情况：$N = 64$，进程数 $p \\in \\{1,64,128\\}$。验证在所有 $p$ 值下 $\\hat{\\pi}$ 相等，以及对零长度块的正确处理。\n    4. 分块正确性：$N = 1000$, $p = 33$。验证分块分区精确地覆盖了试验索引集 $\\{0,\\dots,999\\}$ 且无重叠。如果这些块是连续、不相交且完全覆盖索引集，则测试返回 $true$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个方括号内的逗号分隔列表形式的结果（例如，$[result_1,result_2,result_3,result_4]$）。\n- 对于上述四个测试用例，输出必须是按顺序排列的四个布尔值，分别对应测试1到4。\n\n所有计算都是纯数学的，不涉及物理单位。不使用角度。不使用百分比。整个程序必须是自包含的，不得读取输入，并且在给定固定种子 $x_0$ 的情况下必须是确定性的。问题陈述中对实现语言没有限制，但您提交的最终答案必须是按单独规定给出的一个完整、可运行的Python程序。", "solution": "问题陈述已经过严格评估，并被确定是有效的。它有科学依据，提法恰当且客观。它在计算科学领域提出了一个清晰、可形式化的挑战，没有内部矛盾、事实错误或含糊不清之处。因此，我们可以着手提供一个完整的解决方案。\n\n这个问题的核心在于证明，只要底层伪随机数流的划分在数学上是精确的，蒙特卡洛模拟就可以产生比特级别完全相同的结果，而无论计算工作如何在并行进程中划分。我们将通过组合三个关键组件来设计一个实现这一目标的系统：一个可靠的工作负载划分方法（分块）、一个用于遍历伪随机数流的高效算法（LCG向前跳转），以及一个用于估计 $\\pi$ 的确定性蒙特卡洛过程。\n\n首先，我们为线性同余生成器(LCG)在不进行显式迭代的情况下推进任意步数 $k$ 建立数学基础。一个LCG由以下递推关系定义：\n$$\nx_{n+1} = (a x_n + c) \\pmod m\n$$\n其中 $x_n$ 是第 $n$ 步的状态，$a$、$c$ 和 $m$ 分别是乘数、增量和模数。这是在整数模 $m$ 环上的一个仿射变换 $T(x) = ax + c$。应用生成器 $k$ 次等价于将该变换与自身复合 $k$ 次，得到 $T^k(x)$。\n\n设单步变换由系数对 $(a, c)$ 表示。两个此类变换 $(a_1, c_1)$ 和 $(a_2, c_2)$ 的复合产生一个新的变换：\n$$\n(T_1 \\circ T_2)(x) = T_1(T_2(x)) = a_1(a_2 x + c_2) + c_1 = (a_1 a_2) x + (a_1 c_2 + c_1)\n$$\n得到的变换由新的系数对 $(a_1 a_2, a_1 c_2 + c_1)$ 定义。这种复合运算是可结合的。这种代数结构允许我们使用二进制幂（也称为平方求幂）来计算 $k$ 步变换的参数 $(A_k, C_k)$，其中 $T^k(x) = A_k x + C_k \\pmod m$。\n\n寻找给定步数 $k$ 的 $(A_k, C_k)$ 的算法如下：\n1. 将“总”变换初始化为单位变换，$(A_{total}, C_{total}) = (1, 0)$。\n2. 将“当前”变换初始化为单步LCG参数，$(A_{current}, C_{current}) = (a, c)$。\n3. 当 $k > 0$ 时：\n    a. 如果 $k$ 是奇数，则将总变换与当前变换复合：$(A_{total}, C_{total}) \\leftarrow (A_{total} A_{current}, A_{total} C_{current} + C_{total})$。\n    b. 将当前变换自复合（平方）：$(A_{current}, C_{current}) \\leftarrow (A_{current}^2, A_{current} C_{current} + C_{current})$。\n    c. 更新 $k \\leftarrow \\lfloor k/2 \\rfloor$。\n所有算术运算都在模 $m$ 下进行。对于本问题，$m = 2^{64}$，因此我们使用无符号64位整数算术。$k$ 步后的最终状态为 $x_k = (A_k x_0 + C_k) \\pmod m$。\n\n其次，我们来解决工作负载分配问题。问题指定了使用分块策略在 $p$ 个进程间划分总共 $N$ 次蒙特卡洛试验。给出的公式如下：\n- $q = \\lfloor N/p \\rfloor$\n- $r = N \\bmod p$\n- 对于进程 $i \\in \\{0, 1, \\dots, p-1\\}$：\n  - 起始试验索引：$S_i = i q + \\min(i, r)$\n  - 试验次数：$L_i = q + 1$（如果 $i  r$），否则为 $L_i = q$。\n这种标准的划分方案创建了一组连续且不相交的试验索引块 $\\{[S_i, S_i + L_i - 1]\\}_{i=0}^{p-1}$，其并集恰好是所有试验索引的集合 $\\{0, 1, \\dots, N-1\\}$。\n\n第三，我们将并行方案与PRNG联系起来。每次蒙特卡洛试验 $t$ 需要两个随机变量 $(u_{2t}, u_{2t+1})$ 来构成坐标对 $(x,y)$。因此，被分配从 $S_i$ 开始的试验索引的进程 $i$，必须从全局PRNG流中的索引 $2S_i$ 处开始生成随机数。它将总共消耗 $2L_i$ 个随机数。通过使用上面推导出的向前跳转算法（设置 $k=2S_i$），每个进程都可以从全局种子 $x_0$ 直接计算出其唯一的起始状态 $x_{2S_i}$，然后继续生成其包含 $2L_i$ 个伪随机数的局部序列。\n\n从64位整数状态 $x_n$ 到双精度浮点数 $u_n \\in [0,1)$ 的转换，是通过提取 $x_n$ 的最高53个比特位并乘以 $2^{-53}$ 来实现的。这可以表示为 `(x_n >> 11) * (2**-53)`，它将整数状态映射到该区间内可表示的双精度数网格上。\n\n$\\pi$ 的蒙特卡洛估计过程如下：在单位正方形 $[0,1)^2$ 中生成 $N$ 个点 $(x, y)$，并统计落在四分之一单位圆内的“命中”次数 $H$，即满足 $x^2 + y^2 \\le 1$ 的点的数量。估计量为 $\\hat{\\pi} = 4H/N$。由于我们的并行方案确保所生成的随机对总集合 $\\{(u_{2t}, u_{2t+1})\\}_{t=0}^{N-1}$ 与进程数 $p$ 无关，因此总命中次数 $H = \\sum_{i=0}^{p-1} H_i$（其中 $H_i$ 是进程 $i$ 统计的命中次数）将是不变的。因此，最终的估计值 $\\hat{\\pi}$ 在不同的 $p$ 值下必须是比特级别完全相同的。\n\n该实现将包含执行LCG向前跳转、计算分块以及为给定的 $(N, p)$ 对运行完整模拟的函数。然后，测试套件将调用这些函数来验证所需的可复现性和正确分区的属性。对于所有测试，我们使用指定的LCG参数 $m=2^{64}$、$a=6364136223846793005$、$c=1442695040888963407$ 和一个固定的初始种子 $x_0 = 42$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for parallel random number generation.\n    \"\"\"\n\n    # LCG parameters from the problem statement.\n    # m = 2**64, but we use a mask for 64-bit unsigned arithmetic.\n    M_64_MASK = (1  64) - 1\n    A = 6364136223846793005\n    C = 1442695040888963407\n    # An arbitrary but fixed seed.\n    X0 = 42\n\n    def lcg_skip_ahead(k, a, c, mask):\n        \"\"\"\n        Computes the parameters (A_k, C_k) for an LCG skip of k steps.\n        The k-step transformation is T^k(x) = A_k * x + C_k (mod m).\n        This is equivalent to computing M^k where M is the matrix [[a, c], [0, 1]].\n        We do this via binary exponentiation on the transform parameters.\n\n        Args:\n            k (int): The number of steps to skip ahead.\n            a (int): The LCG multiplier.\n            c (int): The LCG increment.\n            mask (int): The mask for modulo 2**64 arithmetic.\n\n        Returns:\n            tuple[int, int]: The effective multiplier and increment (A_k, C_k).\n        \"\"\"\n        if k == 0:\n            return 1, 0\n\n        # total_a, total_c represent the composed transform so far.\n        # Identity transform: 1*x + 0.\n        total_a, total_c = 1, 0\n        \n        # current_a, current_c represent the transform for powers of 2 steps.\n        # Starts with the 1-step transform.\n        current_a, current_c = a, c\n\n        while k > 0:\n            if k  1:\n                # Compose total transform with current: total_new = current o total_old\n                # T_new(x) = current_a * (total_a * x + total_c) + current_c\n                # T_new(x) = (current_a * total_a) * x + (current_a * total_c + current_c)\n                # We use the equivalent composition T_new = total_old o current.\n                # T_new(x) = total_a * (current_a * x + current_c) + total_c\n                # T_new(x) = (total_a * current_a) * x + (total_a * current_c + total_c)\n                \n                total_c = (total_a * current_c + total_c)  mask\n                total_a = (total_a * current_a)  mask\n\n            # Square the current transform: current_new = current o current\n            # T_new(x) = a'(a'x + c') + c' = (a'^2)x + (a'c' + c')\n            current_c = (current_a * current_c + current_c)  mask\n            current_a = (current_a * current_a)  mask\n            \n            k >>= 1\n        \n        return total_a, total_c\n\n    def get_block_split(N, p, i):\n        \"\"\"\n        Calculates the start index and length of the block for process i.\n\n        Args:\n            N (int): Total number of trials.\n            p (int): Total number of processes.\n            i (int): The process rank (0-indexed).\n\n        Returns:\n            tuple[int, int]: (start_trial, num_trials) for process i.\n        \"\"\"\n        q = N // p\n        r = N % p\n        start_trial = i * q + min(i, r)\n        num_trials = q + 1 if i  r else q\n        return start_trial, num_trials\n\n    def run_simulation(N, p, x0, a, c, mask):\n        \"\"\"\n        Runs the Monte Carlo simulation for pi with N trials on p processes.\n\n        Args:\n            N (int): Total number of trials.\n            p (int): Number of simulated processes.\n            x0 (int): The initial seed for the entire stream.\n            a (int): LCG multiplier.\n            c (int): LCG increment.\n            mask (int): Modulo mask.\n\n        Returns:\n            float: The estimated value of pi.\n        \"\"\"\n        total_hits = 0\n        \n        # Scale for converting 53 high bits to a float in [0,1)\n        scale = 1.0 / (1  53)\n        \n        for i in range(p):\n            start_trial, num_trials = get_block_split(N, p, i)\n            \n            if num_trials == 0:\n                continue\n\n            # Each trial needs 2 random numbers.\n            skip_steps = 2 * start_trial\n            A_k, C_k = lcg_skip_ahead(skip_steps, a, c, mask)\n            \n            # This is the starting state for process i's PRNG stream.\n            x = (A_k * x0 + C_k)  mask\n            \n            local_hits = 0\n            for _ in range(num_trials):\n                # Generate u1 (for x-coordinate)\n                x = (a * x + c)  mask\n                u1 = (x >> 11) * scale\n                \n                # Generate u2 (for y-coordinate)\n                x = (a * x + c)  mask\n                u2 = (x >> 11) * scale\n                \n                if u1 * u1 + u2 * u2 = 1.0:\n                    local_hits += 1\n            \n            total_hits += local_hits\n            \n        if N == 0:\n            return 0.0  # Or other sensible value for N=0\n        \n        return 4.0 * total_hits / N\n\n    def test_reproducibility(N, p_list, x0, a, c, mask):\n        \"\"\"Helper to test reproducibility across different process counts.\"\"\"\n        if not p_list:\n            return True\n        results = [run_simulation(N, p, x0, a, c, mask) for p in p_list]\n        return len(set(results)) == 1\n\n    def test_block_assignment(N, p):\n        \"\"\"Verify that block splitting creates a correct partition.\"\"\"\n        current_pos = 0\n        total_len = 0\n        for i in range(p):\n            start, length = get_block_split(N, p, i)\n            if start != current_pos:\n                return False  # Partition is not contiguous\n            current_pos += length\n            total_len += length\n        \n        # Check if the partition covers the entire set and only the set\n        return current_pos == N and total_len == N\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: Happy path reproducibility\n        lambda: test_reproducibility(200000, [1, 2, 4, 8], X0, A, C, M_64_MASK),\n        # Test 2: Non-divisible N reproducibility\n        lambda: test_reproducibility(123457, [3, 5, 7], X0, A, C, M_64_MASK),\n        # Test 3: Boundary case with p > N\n        lambda: test_reproducibility(64, [1, 64, 128], X0, A, C, M_64_MASK),\n        # Test 4: Block assignment correctness\n        lambda: test_block_assignment(1000, 33)\n    ]\n\n    results = []\n    for test_func in test_cases:\n        results.append(test_func())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3170099"}, {"introduction": "除了分割现有序列，现代并行计算还催生了一种更为灵活和强大的范式：基于计数器的随机数生成。这种方法将随机数生成器视为一个无状态的“哈希”函数，它将一个唯一的索引（或“计数器”）$c$ 映射到一个随机数。这个实践将向你展示如何将多维循环的索引 $(i, j)$ 映射到一个一维计数器 $c = i \\cdot K + j$，并为每个索引独立地生成一个可复现的随机数[@problem_id:3170077]。这种方法的优美之处在于它完全不受执行顺序的影响，无论你是按行、按列还是分块处理数据，结果都保持不变，这对于优化高性能计算代码至关重要。", "problem": "给定一个关于索引 $i$ 和 $j$ 的嵌套并行循环结构，其中 $i \\in \\{0, 1, \\dots, N-1\\}$ 且 $j \\in \\{0, 1, \\dots, K-1\\}$。任务是为伪随机数生成构建一个确定性的流标记方案，该方案在循环执行调度（如循环分块和循环融合）发生改变时保持不变。该构建必须使用一个基于计数器的映射，将数对 $(i, j)$ 映射到由 $c = i \\cdot K + j$ 定义的单个整数计数器 $c$。该伪随机数生成器必须是无状态的，并且其输出必须完全由种子 $s$ 和计数器 $c$ 导出。\n\n基本原理：\n- 伪随机数生成器（PRNG）是一种确定性算法，它将一个种子 $s$ 和一个状态映射到一个输出。对于基于计数器的 PRNG，状态是一个计数器 $c$，对于一个固定的函数 $F$，其输出为 $F(s, c)$。\n- 无论执行调度或并行顺序如何，确定性函数 $F(s, c)$ 对于相同的输入都会产生相同的输出。\n- 映射 $c = i \\cdot K + j$ 是在数对 $(i, j)$（其中 $i \\in \\{0, 1, \\dots, N-1\\}$ 且 $j \\in \\{0, 1, \\dots, K-1\\}$）与整数 $c$（其中 $c \\in \\{0, 1, \\dots, N \\cdot K - 1\\}$）之间的一个双射，其逆映射为 $i = \\left\\lfloor \\frac{c}{K} \\right\\rfloor$ 和 $j = c \\bmod K$。\n\n你的程序必须：\n1. 实现一个定义为 $F(s, c)$ 的无状态、基于计数器的 PRNG，它从 $s$ 和 $c$ 生成一个 64 位无符号整数。该函数必须仅依赖于 $s$ 和 $c$，并且程序必须在不同的循环遍历顺序下展示其可复现性。\n2. 使用映射 $c = i \\cdot K + j$ 为所有 $(i, j)$ 数对标记流。对于给定的 $(i, j)$，PRNG 的输出在不同调度下必须相同，因为其值仅依赖于 $c$ 和 $s$。\n3. 在以下条件下验证可复现性：\n   - 行主序嵌套循环。\n   - 使用分块大小 $T_i$ 和 $T_j$ 进行循环分块。\n   - 循环融合成一个关于 $c$ 的单层循环。\n   - 通过排列计数器 $c$ 的序列进行任意重排序。\n4. 验证改变种子 $s$ 的效果，即当 $s$ 改变时输出会改变，而当 $s$ 固定时可复现性保持不变。\n\n测试套件：\n- 程序必须运行以下五个测试用例，并为每个用例返回一个布尔值，以指示所需属性是否成立。\n  - 测试 1（行主序 vs 分块）：\n    - 参数：$N = 4$, $K = 5$, $T_i = 2$, $T_j = 3$, $s = 0x0123456789ABCDEF$。\n    - 属性：对于所有 $(i, j)$，行主序遍历和分块遍历的输出是相同的。\n  - 测试 2（嵌套 vs 融合）：\n    - 参数：$N = 5$, $K = 7$, $s = 0x0123456789ABCDEF$。\n    - 属性：对于所有 $(i, j)$，嵌套遍历和对 $c \\in \\{0, 1, \\dots, N \\cdot K - 1\\}$ 的融合遍历的输出是相同的。\n  - 测试 3（边界情况 $K = 1$）：\n    - 参数：$N = 8$, $K = 1$, $s = 0x0123456789ABCDEF$。\n    - 属性：对于所有 $i$，嵌套遍历和对 $c \\in \\{0, 1, \\dots, N \\cdot K - 1\\}$ 的融合遍历的输出是相同的，其中当 $K = 1$ 时 $c = i$。\n  - 测试 4（种子改变 vs 可复现性）：\n    - 参数：$N = 3$, $K = 4$, $s_1 = 0x0123456789ABCDEF$, $s_2 = 0xF0E1D2C3B4A59687$。\n    - 属性：\n      - 使用固定的 $s_1$ 时，对于所有 $(i, j)$，行主序遍历和分块遍历下的输出是相同的。\n      - 当 $s_1 \\ne s_2$ 时，至少存在一个 $(i, j)$，使得 $F(s_1, c) \\ne F(s_2, c)$。\n    - 只有当两个属性都满足时，测试才返回 $true$。\n  - 测试 5（任意排列）：\n    - 参数：$N = 3$, $K = 7$, $s = 0x0123456789ABCDEF$。\n    - 属性：对于所有 $(i, j)$，在对计数器 $c \\in \\{0, 1, \\dots, N \\cdot K - 1\\}$ 进行任意排列的情况下，其输出与行主序遍历的输出匹配。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含以逗号分隔的列表形式的结果，并用方括号括起来，例如 `[result_1,result_2,result_3,result_4,result_5]`，其中每个 $result_k$ 为 `True` 或 `False`。不应打印任何其他文本。\n- 程序必须是自包含的，不需要任何输入，并且必须可以在现代环境中按原样运行。\n\n此问题不涉及物理单位或角度，因此不需要单位转换。", "solution": "所提供的问题被认为是有效的。这是一个计算科学领域中适定的、有科学依据的问题，要求设计和验证一个并行安全的伪随机数生成方案。\n\n该解决方案建立在两个核心原则之上：创建一个无状态、确定性的伪随机数生成器（PRNG），以及应用一个从多维循环空间到一维计数器空间的双射。\n\n**1. 无状态确定性原则**\n\nPRNG 通常是一个有状态函数，每次调用都会更新内部状态以生成序列中的下一个数。这种方法在并行环境中存在问题，因为对共享状态的并发更新需要同步，这会引入开销，并根据线程调度的不同导致输出序列的不确定性。\n\n解决方案是使用一个无状态的 PRNG，它是一个纯函数 $F(s, c)$，其输出完全依赖于其输入：一个全局种子 $s$ 和一个计数器 $c$。它在两次调用之间不维护任何内部状态。因此，对于给定的种子 $s$ 和计数器值 $c$，函数 $F(s, c)$ 将始终产生完全相同的输出，无论它在何时或哪个处理器上执行。\n\n对于这个问题，我们实现了这样一个函数 $F(s, c)$，它生成一个 64 位无符号整数。一个稳健的选择是基于 `splitmix64` 算法的函数。该函数将种子 $s$ 和计数器 $c$ 组合成一个初始值，然后应用一系列位移、异或操作以及与预定的大素数常数的乘法。这些操作有效地混合了输入的比特位，以产生具有良好统计随机性的输出。所有算术都使用 64 位无符号整数运算，确保溢出时回绕，这对算法的属性至关重要。\n\n设 $s$ 和 $c$ 为 64 位无符号整数。函数 $F(s, c)$ 定义如下，其中所有操作均在模 $2^{64}$ 下进行：\n1.  初始化状态：$x = s + c$。\n2.  第一轮混合：$x = (x \\oplus (x \\gg 30)) \\cdot 0xBF58476D1CE4E5B9$。\n3.  第二轮混合：$x = (x \\oplus (x \\gg 27)) \\cdot 0x94D049BB133111EB$。\n4.  最终混合：$x = x \\oplus (x \\gg 31)$。\n结果是 $x$ 的最终值。\n\n**2. 双射原则**\n\n为了使无状态 PRNG 在多维问题空间（例如关于索引 $(i, j)$ 的嵌套循环）中有用，我们必须唯一地标记该空间中的每个点。问题指定了一个从循环索引对 $(i, j)$ 到单个整数计数器 $c$ 的双射。给定的映射是一个标准的行主序线性化：\n$$c = i \\cdot K + j$$\n其中 $i \\in \\{0, 1, \\dots, N-1\\}$ 且 $j \\in \\{0, 1, \\dots, K-1\\}$。此函数保证每个唯一的索引对 $(i, j)$ 都映射到一个唯一的计数器 $c \\in \\{0, 1, \\dots, N \\cdot K - 1\\}$。这种唯一性是将随机数生成与循环执行顺序解耦的关键。\n\n**3. 调度变化下的不变性**\n\n通过组合双射和无状态 PRNG，我们得到了一个函数 $G(s, i, j) = F(s, i \\cdot K + j)$，它为循环迭代空间中的每个点 $(i, j)$ 生成一个伪随机数。\n\n不同的循环执行调度，例如：\n-   **行主序遍历**：对每个 $i$ 遍历 $j$。\n-   **循环分块**：将迭代空间分解为更小的矩形块并遍历这些块。\n-   **循环融合**：将嵌套循环折叠成一个关于计数器 $c$ 的单层循环。\n-   **任意排列**：以打乱的、非顺序的次序访问点 $(i, j)$。\n\n这些仅仅是为所有数对 $(i, j)$ 评估函数 $G(s, i, j)$ 的不同顺序。由于任何特定数对的 $G(s, i, j)$ 的值与任何其他数对的评估顺序无关，因此当最终生成的数集被组织成一个 $N \\times K$ 的网格时，在所有调度下都将是相同的。\n\n提供的测试套件验证了这种不变性。\n-   **测试 1 和 4**：比较行主序遍历与分块遍历。每个 $(i, j)$ 生成的值都基于相同的 $c = i \\cdot K + j$，因此生成的数值集合必须相同。\n-   **测试 2 和 3**：比较嵌套的行主序遍历与关于 $c$ 的融合循环。融合循环直接使用 $c$，而嵌套循环首先计算 $c = i \\cdot K + j$。逆映射 $i = \\lfloor c/K \\rfloor, j = c \\pmod K$ 确保为给定 $c$ 计算的值被放置在正确的 $(i, j)$ 位置。结果必须匹配。\n-   **测试 4**：验证改变种子 $s$ 会改变输出，从而证实了 PRNG 对种子的敏感性，这是一项基本要求。\n-   **测试 5**：比较行主序遍历与任意排列的执行顺序。这是对调度不变性最有力的证明，它证明了只要从 $0$ 到 $N \\cdot K - 1$ 的每个计数器值 $c$ 都被精确处理一次，最终结果就是确定性的。\n\n实现将确认所有这些属性都成立，从而为每个测试用例产生一个 `True` 值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef F(s, c):\n    \"\"\"\n    A stateless, counter-based PRNG that produces a 64-bit unsigned integer.\n    The function is based on the splitmix64 algorithm.\n    It is a pure function of the seed 's' and the counter 'c'.\n    \"\"\"\n    # Ensure inputs and all intermediate calculations use 64-bit unsigned integers.\n    s_64 = np.uint64(s)\n    c_64 = np.uint64(c)\n\n    # Combine seed and counter to initialize the state.\n    state = s_64 + c_64\n\n    # The splitmix64 mixing function.\n    state = (state ^ (state >> np.uint64(30))) * np.uint64(0xbf58476d1ce4e5b9)\n    state = (state ^ (state >> np.uint64(27))) * np.uint64(0x94d049bb133111eb)\n    state = state ^ (state >> np.uint64(31))\n    \n    return state\n\ndef generate_row_major(N, K, s):\n    \"\"\"Generates PRNs in a row-major nested loop traversal.\"\"\"\n    results = np.zeros((N, K), dtype=np.uint64)\n    for i in range(N):\n        for j in range(K):\n            c = i * K + j\n            results[i, j] = F(s, c)\n    return results\n\ndef generate_tiled(N, K, Ti, Tj, s):\n    \"\"\"Generates PRNs in a tiled loop traversal.\"\"\"\n    results = np.zeros((N, K), dtype=np.uint64)\n    for i_tile in range(0, N, Ti):\n        for j_tile in range(0, K, Tj):\n            for i in range(i_tile, min(i_tile + Ti, N)):\n                for j in range(j_tile, min(j_tile + Tj, K)):\n                    c = i * K + j\n                    results[i, j] = F(s, c)\n    return results\n\ndef generate_fused(N, K, s):\n    \"\"\"Generates PRNs in a single, fused loop over the counter 'c'.\"\"\"\n    results = np.zeros((N, K), dtype=np.uint64)\n    for c in range(N * K):\n        i = c // K\n        j = c % K\n        results[i, j] = F(s, c)\n    return results\n\ndef generate_permuted(N, K, s):\n    \"\"\"Generates PRNs by processing counters in a permuted, arbitrary order.\"\"\"\n    results = np.zeros((N, K), dtype=np.uint64)\n    counters = np.arange(N * K, dtype=np.uint64)\n    \n    # Use a fixed seed for the permutation to ensure the test is deterministic.\n    rng = np.random.default_rng(seed=42)\n    rng.shuffle(counters)\n    \n    for c in counters:\n        c_int = int(c)\n        i = c_int // K\n        j = c_int % K\n        results[i, j] = F(s, c)\n    return results\n\ndef solve():\n    \"\"\"\n    Runs the test suite to verify the properties of the stateless,\n    counter-based PRNG scheme.\n    \"\"\"\n    test_cases = [\n        # Test 1: Row-major vs. Tiled\n        {'N': 4, 'K': 5, 'Ti': 2, 'Tj': 3, 's': 0x0123456789ABCDEF},\n        # Test 2: Nested vs. Fused\n        {'N': 5, 'K': 7, 's': 0x0123456789ABCDEF},\n        # Test 3: Boundary case K=1\n        {'N': 8, 'K': 1, 's': 0x0123456789ABCDEF},\n        # Test 4: Seed change vs. reproducibility\n        {'N': 3, 'K': 4, 's1': 0x0123456789ABCDEF, 's2': 0xF0E1D2C3B4A59687},\n        # Test 5: Arbitrary permutation\n        {'N': 3, 'K': 7, 's': 0x0123456789ABCDEF},\n    ]\n\n    results = []\n\n    # --- Test 1: Row-major vs. Tiled ---\n    p = test_cases[0]\n    res_row_major = generate_row_major(p['N'], p['K'], p['s'])\n    res_tiled = generate_tiled(p['N'], p['K'], p['Ti'], p['Tj'], p['s'])\n    results.append(np.array_equal(res_row_major, res_tiled))\n\n    # --- Test 2: Nested vs. Fused ---\n    p = test_cases[1]\n    res_nested = generate_row_major(p['N'], p['K'], p['s'])\n    res_fused = generate_fused(p['N'], p['K'], p['s'])\n    results.append(np.array_equal(res_nested, res_fused))\n\n    # --- Test 3: Boundary case K=1 ---\n    p = test_cases[2]\n    res_nested = generate_row_major(p['N'], p['K'], p['s'])\n    res_fused = generate_fused(p['N'], p['K'], p['s'])\n    results.append(np.array_equal(res_nested, res_fused))\n    \n    # --- Test 4: Seed change vs. reproducibility ---\n    p = test_cases[3]\n    # Tiling requires tile sizes. We use a reasonable choice for the test.\n    Ti_t4, Tj_t4 = 2, 2\n    # Property 1: Reproducibility with fixed seed s1\n    res_row_major_s1 = generate_row_major(p['N'], p['K'], p['s1'])\n    res_tiled_s1 = generate_tiled(p['N'], p['K'], Ti_t4, Tj_t4, p['s1'])\n    prop1 = np.array_equal(res_row_major_s1, res_tiled_s1)\n    # Property 2: Different outputs for different seeds\n    res_row_major_s2 = generate_row_major(p['N'], p['K'], p['s2'])\n    prop2 = not np.array_equal(res_row_major_s1, res_row_major_s2)\n    results.append(prop1 and prop2)\n\n    # --- Test 5: Arbitrary permutation ---\n    p = test_cases[4]\n    res_row_major = generate_row_major(p['N'], p['K'], p['s'])\n    res_permuted = generate_permuted(p['N'], p['K'], p['s'])\n    results.append(np.array_equal(res_row_major, res_permuted))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3170077"}]}