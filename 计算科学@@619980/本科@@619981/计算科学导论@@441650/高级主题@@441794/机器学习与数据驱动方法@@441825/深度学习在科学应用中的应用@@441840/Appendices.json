{"hands_on_practices": [{"introduction": "将科学原理融入深度学习模型的一个直接方法，是通过在损失函数中加入惩罚项来实施物理约束。本练习将引导你为一个本可能违反单调性基本属性的累积分布函数（CDF）模型，设计并实现一个“软约束”。通过惩罚模型输出的非物理行为（即负斜率），我们能有效地引导模型在训练过程中学习到正确的科学规律。[@problem_id:3116982]", "problem": "您正在使用一个模拟无约束神经网络的简单可微参数形式，将累积分布函数 (CDF) 建模为函数 $\\hat{F}_{\\theta}(x)$。在科学应用中，学习到的 CDF 必须满足单调性的基本属性：对于一个实值随机变量 $X$，其累积分布函数 (CDF) $F(x) = \\mathbb{P}(X \\le x)$ 是非递减的，并且当其可微时，其导数 $F'(x)$ 等于概率密度函数 (PDF) $f(x)$，且满足 $f(x) \\ge 0$。这意味着单调性约束 $F'(x) \\ge 0$ 几乎处处成立。在许多用于科学应用的深度学习架构中，无约束模型可能会违反这种单调性，因此我们寻求一种有理论依据的损失函数来惩罚违反该约束的情况。\n\n从上述核心定义出发，设计一个包含以下部分的损失函数：\n- 一个介于学习到的 CDF $\\hat{F}_{\\theta}(x)$ 和从样本数据计算出的经验 CDF $\\tilde{F}(x)$ 之间的数据保真度项。\n- 一个单调性惩罚项，通过惩罚 $\\hat{F}_{\\theta}(x)$ 在网格上的负离散斜率来强制执行 $F'(x) \\ge 0$ 的约束。\n\n使用以下基础和定义：\n- 对于样本 $\\{s_j\\}_{j=1}^m$，经验 CDF $\\tilde{F}(x)$ 定义为 $\\tilde{F}(x) = \\frac{1}{m}\\sum_{j=1}^{m} \\mathbf{1}\\{s_j \\le x\\}$。\n- 给定一个网格 $\\{x_i\\}_{i=1}^{n}$，其中 $x_1  x_2  \\cdots  x_n$。对于 $i \\in \\{1,\\dots,n-1\\}$，定义离散斜率 $D_i = \\frac{\\hat{F}_{\\theta}(x_{i+1}) - \\hat{F}_{\\theta}(x_i)}{x_{i+1} - x_i}$。\n- 定义修正线性单元 (ReLU) 为 $\\operatorname{ReLU}(t) = \\max(0,t)$。\n\n您的任务：\n- 实现一个程序，对于每个提供的测试用例，计算总损失\n$$\nL(\\theta) = \\frac{1}{n}\\sum_{i=1}^{n}\\left(\\hat{F}_{\\theta}(x_i) - \\tilde{F}(x_i)\\right)^2 \\;+\\; \\lambda \\sum_{i=1}^{n-1}\\left(\\operatorname{ReLU}\\!\\left(-D_i\\right)\\right)^2,\n$$\n其中 $\\lambda$ 是一个非负惩罚权重。\n- 参数化 CDF 模型指定为\n$$\n\\hat{F}_{\\theta}(x) = \\sigma\\!\\left(\\alpha \\sin(2\\pi x) + \\beta x + \\gamma\\right),\n$$\n其中 $\\sigma(z) = \\frac{1}{1 + e^{-z}}$ 是逻辑S型函数（logistic sigmoid），$\\theta = (\\alpha,\\beta,\\gamma)$ 是实数参数。这种形式在 $[0,1]$ 区间内有界，但不保证是单调的，因此适合用于测试惩罚项。\n\n算法规格：\n- 通过计算小于或等于 $x_i$ 的样本点比例，直接从给定的样本集计算网格上的 $\\tilde{F}(x_i)$。\n- 按上述规定计算均方误差项和单调性惩罚项。\n- 不涉及物理单位。\n- 三角函数中的角度必须以弧度为单位。\n- 每个测试用例都指定了 $(\\theta, \\lambda)$、一个网格 $\\{x_i\\}_{i=1}^{n}$ 以及一个用于计算 $\\tilde{F}(x)$ 的样本集。\n\n测试套件：\n- 除非另有说明，否则使用在 $[0,1]$ 上均匀分布的网格点 $\\{x_i\\}_{i=1}^{n}$。\n- 情况一（普遍单调趋势，理想情况）：\n  - 网格：$n = 21$ 个点，$x_i = \\frac{i-1}{20}$，其中 $i \\in \\{1,\\dots,21\\}$。\n  - 样本集（类均匀分布）：$\\{0.05, 0.12, 0.18, 0.22, 0.31, 0.37, 0.41, 0.48, 0.53, 0.60, 0.66, 0.74, 0.80, 0.86, 0.92\\}$。\n  - 参数：$\\alpha = 0.0$, $\\beta = 8.0$, $\\gamma = 0.0$。\n  - 惩罚权重：$\\lambda = 10.0$。\n- 情况二（非单调振荡）：\n  - 网格：$n = 21$ 个点，$x_i = \\frac{i-1}{20}$。\n  - 样本集：与情况一相同。\n  - 参数：$\\alpha = 1.0$, $\\beta = 0.5$, $\\gamma = 0.0$。\n  - 惩罚权重：$\\lambda = 10.0$。\n- 情况三（具有更强惩罚的负局部斜率）：\n  - 网格：$n = 21$ 个点，$x_i = \\frac{i-1}{20}$。\n  - 样本集（更集中在零附近）：$\\{0.01, 0.03, 0.07, 0.10, 0.14, 0.18, 0.25, 0.35, 0.50, 0.70, 0.85, 0.95\\}$。\n  - 参数：$\\alpha = 0.6$, $\\beta = -0.1$, $\\gamma = -0.2$。\n  - 惩罚权重：$\\lambda = 50.0$。\n- 情况四（常数模型，单调性的边界场景）：\n  - 网格：$n = 21$ 个点，$x_i = \\frac{i-1}{20}$。\n  - 样本集：与情况三相同。\n  - 参数：$\\alpha = 0.0$, $\\beta = 0.0$, $\\gamma = 0.0$。\n  - 惩罚权重：$\\lambda = 10.0$。\n- 情况五（最小网格，经验样本中有重复值）：\n  - 网格：$n = 2$ 个点 $\\{0.0, 1.0\\}$。\n  - 样本集：$\\{0.2, 0.2, 0.2, 0.8, 0.8\\}$。\n  - 参数：$\\alpha = -0.8$, $\\beta = 0.7, \\gamma = 0.5$。\n  - 惩罚权重：$\\lambda = 5.0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含五个测试用例按顺序排列的结果，结果为逗号分隔的列表，并用方括号括起来，四舍五入到六位小数（例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5\\right]$）。", "solution": "该问题是有效的。它在科学上基于概率论和数值优化的原理，问题提法适定，提供了所有必要信息，并且其表述是客观的。它提出了一个科学机器学习中的标准任务：设计一个损失函数，以在参数模型上强制施加物理或数学约束（累积分布函数的单调性）。\n\n任务是为五个不同的测试用例计算总损失 $L(\\theta)$。该损失函数由两部分组成：一个数据保真度项和一个单调性惩罚项。\n$$\nL(\\theta) = \\underbrace{\\frac{1}{n}\\sum_{i=1}^{n}\\left(\\hat{F}_{\\theta}(x_i) - \\tilde{F}(x_i)\\right)^2}_{\\text{均方误差 (MSE)}} \\;+\\; \\underbrace{\\lambda \\sum_{i=1}^{n-1}\\left(\\operatorname{ReLU}\\!\\left(-D_i\\right)\\right)^2}_{\\text{单调性惩罚}}\n$$\n我们将为每个测试用例系统地计算每个组成部分。\n\nCDF 的参数模型由 $\\hat{F}_{\\theta}(x) = \\sigma\\!\\left(\\alpha \\sin(2\\pi x) + \\beta x + \\gamma\\right)$ 给出，其中 $\\sigma(z) = \\frac{1}{1 + e^{-z}}$ 是逻辑S型函数（logistic sigmoid），$\\theta = (\\alpha, \\beta, \\gamma)$。\n\n每个测试用例的处理过程如下：\n1.  定义点网格 $\\{x_i\\}_{i=1}^{n}$ 和样本集 $\\{s_j\\}_{j=1}^{m}$。\n2.  在每个网格点 $x_i$ 上计算经验 CDF $\\tilde{F}(x_i)$ 的值。根据定义，$\\tilde{F}(x_i) = \\frac{1}{m}\\sum_{j=1}^{m} \\mathbf{1}\\{s_j \\le x_i\\}$，即小于或等于 $x_i$ 的样本所占的比例。\n3.  使用给定的参数 $\\theta = (\\alpha, \\beta, \\gamma)$，在每个网格点 $x_i$ 上计算参数模型 CDF $\\hat{F}_{\\theta}(x_i)$ 的值。\n4.  计算 MSE 项：这是所有网格点上 $\\hat{F}_{\\theta}(x_i)$ 和 $\\tilde{F}(x_i)$ 之间差值平方的均值。\n$$\n\\text{MSE} = \\frac{1}{n}\\sum_{i=1}^{n}\\left(\\hat{F}_{\\theta}(x_i) - \\tilde{F}(x_i)\\right)^2\n$$\n5.  计算单调性惩罚项：\n    a. 首先，对于 $i \\in \\{1, \\dots, n-1\\}$，计算离散斜率 $D_i$：\n    $$\n    D_i = \\frac{\\hat{F}_{\\theta}(x_{i+1}) - \\hat{F}_{\\theta}(x_i)}{x_{i+1} - x_i}\n    $$\n    b. 接着，惩罚任何负斜率。每个区间的惩罚是 $\\left(\\operatorname{ReLU}(-D_i)\\right)^2$，其中 $\\operatorname{ReLU}(t) = \\max(0, t)$。只有当 $D_i  0$ 时，该项才非零。\n    c. 总惩罚是所有区间的加权和：\n    $$\n    \\text{Penalty} = \\lambda \\sum_{i=1}^{n-1}\\left(\\operatorname{ReLU}(-D_i)\\right)^2\n    $$\n6.  总损失 $L(\\theta)$ 是 MSE 和惩罚项之和。\n\n我们现在将此过程应用于每个测试用例。\n\n**情况 1:**\n- 网格：$n=21$ 个点在 $[0,1]$ 上，$x_i = \\frac{i-1}{20}$。\n- 样本集：$m=15$ 个点 $\\{0.05, \\dots, 0.92\\}$。\n- 参数：$\\theta = (\\alpha=0.0, \\beta=8.0, \\gamma=0.0)$。\n- 惩罚权重：$\\lambda = 10.0$。\n模型为 $\\hat{F}_{\\theta}(x) = \\sigma(8x)$。其参数的导数为 $8  0$。由于 $\\sigma$ 是一个严格递增函数，$\\hat{F}_{\\theta}(x)$ 保证是单调的。因此，所有离散斜率 $D_i$ 都将为正。对于所有的 $i$，$\\operatorname{ReLU}(-D_i)$ 项都将为 $0$，导致单调性惩罚为 $0$。总损失将仅为 $\\sigma(8x_i)$ 和计算出的 $\\tilde{F}(x_i)$ 之间的 MSE。\n\n**情况 2:**\n- 网格、样本集和 $\\lambda$ 与情况 1 相同。\n- 参数：$\\theta = (\\alpha=1.0, \\beta=0.5, \\gamma=0.0)$。\n模型为 $\\hat{F}_{\\theta}(x) = \\sigma(\\sin(2\\pi x) + 0.5x)$。正弦项 $\\sin(2\\pi x)$ 引入了振荡。其参数的导数为 $2\\pi \\cos(2\\pi x) + 0.5$，这可能是负的（例如，在 $x=0.5$ 附近）。这将导致存在负斜率 $D_i$ 的区间，从而产生非零的单调性惩罚。总损失将是 MSE 和此惩罚项之和。\n\n**情况 3:**\n- 网格：$n=21$ 个点在 $[0,1]$ 上。\n- 样本集：$m=12$ 个点 $\\{0.01, \\dots, 0.95\\}$。\n- 参数：$\\theta = (\\alpha=0.6, \\beta=-0.1, \\gamma=-0.2)$。\n- 惩罚权重：$\\lambda = 50.0$。\n模型为 $\\hat{F}_{\\theta}(x) = \\sigma(0.6\\sin(2\\pi x) - 0.1x - 0.2)$。负系数 $\\beta=-0.1$ 导致了下降趋势，使得负斜率更可能出现且更显著。因此，我们预计会有一个显著的非零单调性惩罚，并且该惩罚会被较大的权重 $\\lambda=50.0$ 放大。\n\n**情况 4:**\n- 网格、样本集与情况 3 相同。\n- 参数：$\\theta = (\\alpha=0.0, \\beta=0.0, \\gamma=0.0)$。\n- 惩罚权重：$\\lambda = 10.0$。\n模型为 $\\hat{F}_{\\theta}(x) = \\sigma(0) = 0.5$。这是一个常数函数。离散斜率 $D_i$ 全都恒等于 $0$。$\\operatorname{ReLU}(-D_i) = \\operatorname{ReLU}(0) = 0$。单调性惩罚将为 $0$。总损失将是常数值 $0.5$ 和经验 CDF $\\tilde{F}(x_i)$ 之间的 MSE。\n\n**情况 5:**\n- 网格：$n=2$ 个点，$x_1=0.0, x_2=1.0$。\n- 样本集：$m=5$ 个点 $\\{0.2, 0.2, 0.2, 0.8, 0.8\\}$。\n- 参数：$\\theta = (\\alpha=-0.8, \\beta=0.7, \\gamma=0.5)$。\n- 惩罚权重：$\\lambda = 5.0$。\n只有一个区间，从 $x_1=0.0$ 到 $x_2=1.0$。\n经验 CDF 值为 $\\tilde{F}(0.0) = \\frac{0}{5} = 0.0$ 和 $\\tilde{F}(1.0) = \\frac{5}{5} = 1.0$。\n模型值为 $\\hat{F}_{\\theta}(0.0) = \\sigma(-0.8\\sin(0) + 0.7(0) + 0.5) = \\sigma(0.5)$ 和 $\\hat{F}_{\\theta}(1.0) = \\sigma(-0.8\\sin(2\\pi) + 0.7(1) + 0.5) = \\sigma(1.2)$。\nMSE 项是 $\\frac{1}{2}\\left((\\sigma(0.5) - 0.0)^2 + (\\sigma(1.2) - 1.0)^2\\right)$。\n只有一个离散斜率，$D_1 = \\frac{\\hat{F}_{\\theta}(1.0) - \\hat{F}_{\\theta}(0.0)}{1.0-0.0} = \\sigma(1.2) - \\sigma(0.5)$。由于 $\\sigma$ 是递增的且 $1.2  0.5$，所以 $D_1$ 为正。\n因此，$\\operatorname{ReLU}(-D_1) = 0$，单调性惩罚为 $0$。总损失仅为 MSE 项。\n\n实现将遵循此逻辑对每个案例进行处理，并按规定执行数值计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the total loss for a parametric CDF model across five test cases.\n    The loss includes a data fidelity term and a monotonicity penalty.\n    \"\"\"\n\n    test_cases = [\n        # Case one\n        {\n            \"grid_n\": 21,\n            \"grid_lims\": (0.0, 1.0),\n            \"samples\": np.array([0.05, 0.12, 0.18, 0.22, 0.31, 0.37, 0.41, 0.48, 0.53, 0.60, 0.66, 0.74, 0.80, 0.86, 0.92]),\n            \"params\": {\"alpha\": 0.0, \"beta\": 8.0, \"gamma\": 0.0},\n            \"lambda_val\": 10.0\n        },\n        # Case two\n        {\n            \"grid_n\": 21,\n            \"grid_lims\": (0.0, 1.0),\n            \"samples\": np.array([0.05, 0.12, 0.18, 0.22, 0.31, 0.37, 0.41, 0.48, 0.53, 0.60, 0.66, 0.74, 0.80, 0.86, 0.92]),\n            \"params\": {\"alpha\": 1.0, \"beta\": 0.5, \"gamma\": 0.0},\n            \"lambda_val\": 10.0\n        },\n        # Case three\n        {\n            \"grid_n\": 21,\n            \"grid_lims\": (0.0, 1.0),\n            \"samples\": np.array([0.01, 0.03, 0.07, 0.10, 0.14, 0.18, 0.25, 0.35, 0.50, 0.70, 0.85, 0.95]),\n            \"params\": {\"alpha\": 0.6, \"beta\": -0.1, \"gamma\": -0.2},\n            \"lambda_val\": 50.0\n        },\n        # Case four\n        {\n            \"grid_n\": 21,\n            \"grid_lims\": (0.0, 1.0),\n            \"samples\": np.array([0.01, 0.03, 0.07, 0.10, 0.14, 0.18, 0.25, 0.35, 0.50, 0.70, 0.85, 0.95]),\n            \"params\": {\"alpha\": 0.0, \"beta\": 0.0, \"gamma\": 0.0},\n            \"lambda_val\": 10.0\n        },\n        # Case five\n        {\n            \"grid_points\": np.array([0.0, 1.0]),\n            \"samples\": np.array([0.2, 0.2, 0.2, 0.8, 0.8]),\n            \"params\": {\"alpha\": -0.8, \"beta\": 0.7, \"gamma\": 0.5},\n            \"lambda_val\": 5.0\n        }\n    ]\n\n    results = []\n    \n    # Define helper functions based on the problem statement\n    def sigmoid(z):\n        return 1.0 / (1.0 + np.exp(-z))\n\n    def f_hat(x, alpha, beta, gamma):\n        z = alpha * np.sin(2.0 * np.pi * x) + beta * x + gamma\n        return sigmoid(z)\n\n    def relu(t):\n        return np.maximum(0, t)\n\n    for case in test_cases:\n        # Step 1: Define grid and samples\n        if \"grid_points\" in case:\n            x_grid = case[\"grid_points\"]\n        else:\n            x_grid = np.linspace(case[\"grid_lims\"][0], case[\"grid_lims\"][1], case[\"grid_n\"])\n        \n        samples = case[\"samples\"]\n        n = len(x_grid)\n        m = len(samples)\n        \n        params = case[\"params\"]\n        alpha, beta, gamma = params[\"alpha\"], params[\"beta\"], params[\"gamma\"]\n        lambda_val = case[\"lambda_val\"]\n\n        # Step 2: Compute empirical CDF F_tilde\n        # For each x_i in x_grid, count how many samples are = x_i\n        counts = np.sum(samples[:, np.newaxis] = x_grid, axis=0)\n        f_tilde_values = counts / m\n        \n        # Step 3: Compute parametric CDF F_hat\n        f_hat_values = f_hat(x_grid, alpha, beta, gamma)\n\n        # Step 4: Calculate the MSE term\n        mse_term = np.mean((f_hat_values - f_tilde_values)**2)\n\n        # Step 5: Calculate the monotonicity penalty term\n        # a. Compute discrete slopes D_i\n        if n  1:\n            delta_f_hat = np.diff(f_hat_values)\n            delta_x = np.diff(x_grid)\n            # Avoid division by zero, though not expected in these cases\n            # A small tolerance epsilon could be added for robustness\n            discrete_slopes = delta_f_hat / delta_x\n            \n            # b. Apply ReLU to negative slopes and square\n            penalty_per_interval = relu(-discrete_slopes)**2\n            \n            # c. Sum and weight by lambda\n            monotonicity_penalty = lambda_val * np.sum(penalty_per_interval)\n        else:\n            monotonicity_penalty = 0.0\n\n        # Step 6: Compute total loss\n        total_loss = mse_term + monotonicity_penalty\n        results.append(total_loss)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "3116982"}, {"introduction": "除了通过损失函数施加约束，一种更强大的方法是将科学原理（如对称性）直接构建到网络架构中。本练习将带你探索几何深度学习的核心思想，即构建一个旋转等变的消息传递网络，用于预测分子的标量性质（如能量）。你将学习如何设计模型，使其预测结果在坐标系旋转时保持不变，这是许多物理定律的内在要求。[@problem_id:3117017]", "problem": "要求您设计并实现一个最小的、旋转等变的消息传递方案，该方案为分子构型生成一个旋转不变的标量预测。其目标是编码一个科学要求，即像能量这样的标量可观测量在三维特殊正交群 (SO) 的任何旋转下都保持不变，记为 $\\mathrm{SO}(3)$。\n\n从基本定义出发，一个旋转矩阵 $\\mathbf{R} \\in \\mathrm{SO}(3)$ 满足 $\\mathbf{R}^\\top \\mathbf{R} = \\mathbf{I}$ 和 $\\det(\\mathbf{R}) = 1$。像能量 $E$ 这样的标量物理属性必须对所有 $\\mathbf{R} \\in \\mathrm{SO}(3)$ 满足 $E(\\mathbf{R}\\mathbf{r}) = E(\\mathbf{r})$，其中 $\\mathbf{r} = (\\mathbf{r}_1,\\dots,\\mathbf{r}_N)$ 是 $\\mathbb{R}^3$ 中的原子坐标。\n\n您将实现一个单层等变消息传递机制和一个生成不变的类能标量的读出机制。程序必须遵循以下规范：\n\n1) 输入表示。一个分子是一组包含 $N$ 个原子的集合，原子具有位置 $\\mathbf{r}_i \\in \\mathbb{R}^3$ 和整数类型 $Z_i \\in \\mathbb{Z}_{\\ge 1}$（使用原子序数）。定义成对相对向量 $\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$，距离 $d_{ij} = \\|\\mathbf{r}_{ij}\\|_2$ 和单位方向 $\\hat{\\mathbf{r}}_{ij} = \\mathbf{r}_{ij}/d_{ij}$。为避免除以零，如果对于一个非常小的 $\\delta  0$ 有 $d_{ij} \\le \\delta$，则按照惯例设置 $\\hat{\\mathbf{r}}_{ij} = \\mathbf{0}$。\n\n2) 消息传递（矢量值，旋转等变）。定义一个标量、依赖于距离和类型的系数\n$$\ns_{ij} = \\exp(-\\beta\\, d_{ij})\\left(a_0 + a_1 Z_i + a_2 Z_j + a_3 Z_i Z_j\\right),\n$$\n并计算一个节点级矢量消息\n$$\n\\mathbf{m}_i = \\sum_{j \\ne i} s_{ij}\\, \\hat{\\mathbf{r}}_{ij}.\n$$\n这里 $\\beta, a_0, a_1, a_2, a_3$ 是固定的实数常量。\n\n3) 不变读出（标量类能预测）。定义每个节点的标量\n$$\ne_i = c_1 \\|\\mathbf{m}_i\\|_2^2 + c_2 \\sum_{j \\ne i} \\exp(-\\gamma\\, d_{ij}),\n$$\n以及总预测值\n$$\nE(\\mathbf{r}, \\mathbf{Z}) = \\sum_{i=1}^N e_i + c_3 \\sum_{i=1}^N Z_i,\n$$\n其中 $c_1, c_2, c_3, \\gamma$ 是固定的实数常量。\n\n4) 等变性/不变性要求。消息 $\\mathbf{m}_i$ 必须在 $\\mathbf{R} \\in \\mathrm{SO}(3)$ 下像矢量一样变换，而最终的 $E(\\mathbf{r}, \\mathbf{Z})$ 必须满足 $E(\\mathbf{R}\\mathbf{r}, \\mathbf{Z}) = E(\\mathbf{r}, \\mathbf{Z})$。\n\n5) 旋转生成。使用 Rodrigues 公式从给定的轴-角 $(\\hat{\\mathbf{a}}, \\theta)$ 构建 $\\mathbf{R}$\n$$\n\\mathbf{R} = \\cos\\theta\\, \\mathbf{I} + \\sin\\theta\\, [\\hat{\\mathbf{a}}]_\\times + (1-\\cos\\theta)\\, \\hat{\\mathbf{a}}\\hat{\\mathbf{a}}^\\top,\n$$\n其中 $[\\hat{\\mathbf{a}}]_\\times$ 是单位轴 $\\hat{\\mathbf{a}}$ 的斜对称矩阵，$\\theta$ 是以弧度为单位的角度。\n\n程序中要使用的常量：\n- $\\delta = 10^{-12}$，\n- $a_0 = 0.5$, $a_1 = 0.1$, $a_2 = -0.05$, $a_3 = 0.02$，\n- $\\beta = 1.3$, $\\gamma = 0.9$，\n- $c_1 = 0.7$, $c_2 = 0.2$, $c_3 = 0.05$。\n\n相等性的数值容差：\n- 如果 $|x-y| \\le \\tau$ 且 $\\tau = 10^{-10}$，则两个浮点预测值 $x$ 和 $y$ 被认为是相等的。\n\n角度单位：\n- 所有角度 $\\theta$ 都以弧度为单位指定。\n\n测试套件。您的程序必须硬编码以下四个测试用例，每个用例都包含位置 $\\mathbf{r}$（以任何一致的长度单位）、整数类型 $\\mathbf{Z}$ 和一个旋转轴-角 $(\\hat{\\mathbf{a}}, \\theta)$：\n\n- 情况 1（一般的、非退化的三角形）：$\\mathbf{Z} = [8, 1, 1]$，位置\n  $$\n  \\mathbf{r}_1 = (0.0, 0.0, 0.0),\\;\n  \\mathbf{r}_2 = (0.9572, 0.0, 0.0),\\;\n  \\mathbf{r}_3 = (-0.2399872, 0.927297, 0.0),\n  $$\n  旋转轴 $\\hat{\\mathbf{a}} \\propto (1.0, 2.0, 3.0)$ 归一化为单位长度，角度 $\\theta = 1.234$。\n\n- 情况 2（线性三原子分子，$180^\\circ$ 旋转）：$\\mathbf{Z} = [6, 1, 1]$，位置\n  $$\n  \\mathbf{r}_1 = (0.0, 0.0, 0.0),\\;\n  \\mathbf{r}_2 = (1.1, 0.0, 0.0),\\;\n  \\mathbf{r}_3 = (-1.1, 0.0, 0.0),\n  $$\n  旋转轴 $\\hat{\\mathbf{a}} = (0.0, 0.0, 1.0)$，角度 $\\theta = \\pi$。\n\n- 情况 3（单个原子）：$\\mathbf{Z} = [8]$，位置\n  $$\n  \\mathbf{r}_1 = (1.0, 2.0, 3.0),\n  $$\n  旋转轴 $\\hat{\\mathbf{a}} = (0.0, 0.0, 1.0)$，角度 $\\theta = 0.7$。\n\n- 情况 4（退化的、重合的位置，用于压力测试 $\\delta$ 的处理）：$\\mathbf{Z} = [1, 1, 1]$，位置\n  $$\n  \\mathbf{r}_1 = (0.0, 0.0, 0.0),\\;\n  \\mathbf{r}_2 = (0.0, 0.0, 0.0),\\;\n  \\mathbf{r}_3 = (0.0, 0.0, 0.0),\n  $$\n  旋转轴 $\\hat{\\mathbf{a}} = (0.0, 1.0, 0.0)$，角度 $\\theta = 2.2$。\n\n对于每种情况，计算 $E(\\mathbf{r}, \\mathbf{Z})$ 和 $E(\\mathbf{R}\\mathbf{r}, \\mathbf{Z})$，然后使用容差 $\\tau$ 对它们进行比较。预期的输出是每种情况对应的一个布尔值，表示旋转不变性是否在容差范围内成立。\n\n最终输出格式。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，例如\n$[b_1,b_2,b_3,b_4]$\n其中每个 $b_k$ 是情况 $k$ 的布尔值。", "solution": "该问题要求设计并验证一个用于标量分子属性的计算模型，该模型根据其构造在三维旋转下是不变的。这是物理知识启发的机器学习中的一个基本概念，将已知的物理对称性融入模型架构可以提高其准确性、数据效率和泛化能力。我们感兴趣的对称群是三维特殊正交群 $\\mathrm{SO}(3)$，它代表了所有正常旋转。\n\n如果对于任何旋转矩阵 $\\mathbf{R} \\in \\mathrm{SO}(3)$ 和任何原子位置构型 $\\mathbf{r} = (\\mathbf{r}_1, \\dots, \\mathbf{r}_N)$，标量属性 $E$ 保持不变，即 $E(\\mathbf{R}\\mathbf{r}, \\mathbf{Z}) = E(\\mathbf{r}, \\mathbf{Z})$，则称其为旋转不变的，其中 $\\mathbf{Z}$ 表示不变的原子类型。我们将通过分析每个组件的变换性质来证明指定的模型架构保证了这种不变性。\n\n该设计依赖于等变性和不变性的概念。如果一个矢量值函数 $f(\\mathbf{x})$ 满足 $f(\\mathbf{R}\\mathbf{x}) = \\mathbf{R}f(\\mathbf{x})$，则称其为等变的，这意味着其输出像矢量一样变换。如果一个标量值函数 $g(\\mathbf{x})$ 满足 $g(\\mathbf{R}\\mathbf{x}) = g(\\mathbf{x})$，则称其为不变的。该模型是通过一系列保持这些性质的操作构建的。\n\n**1. 输入特征及其变换性质**\n\n该模型始于从原子位置 $\\mathbf{r}_i \\in \\mathbb{R}^3$ 导出的基本几何量。在旋转 $\\mathbf{R}$ 的作用下，位置矢量变换为 $\\mathbf{r}'_i = \\mathbf{R}\\mathbf{r}_i$。\n\n- **相对位置矢量**：对于任意一对原子 $i$ 和 $j$，相对位置矢量为 $\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$。这些矢量是等变的，因为 $\\mathbf{r}'_{ij} = \\mathbf{r}'_j - \\mathbf{r}'_i = \\mathbf{R}\\mathbf{r}_j - \\mathbf{R}\\mathbf{r}_i = \\mathbf{R}(\\mathbf{r}_j - \\mathbf{r}_i) = \\mathbf{R}\\mathbf{r}_{ij}$。\n\n- **成对距离**：距离 $d_{ij} = \\|\\mathbf{r}_{ij}\\|_2$ 是欧几里得范数。由于旋转是等距变换（保持长度），距离是不变的：$d'_{ij} = \\|\\mathbf{r}'_{ij}\\|_2 = \\|\\mathbf{R}\\mathbf{r}_{ij}\\|_2 = \\|\\mathbf{r}_{ij}\\|_2 = d_{ij}$。\n\n- **单位方向矢量**：定义为 $\\hat{\\mathbf{r}}_{ij} = \\mathbf{r}_{ij} / d_{ij}$（对于 $d_{ij}  \\delta$），这些矢量是等变的：$\\hat{\\mathbf{r}}'_{ij} = \\mathbf{r}'_{ij} / d'_{ij} = (\\mathbf{R}\\mathbf{r}_{ij}) / d_{ij} = \\mathbf{R}(\\mathbf{r}_{ij} / d_{ij}) = \\mathbf{R}\\hat{\\mathbf{r}}_{ij}$。在 $d_{ij} \\le \\delta$ 的特殊情况下，设置 $\\hat{\\mathbf{r}}_{ij} = \\mathbf{0}$，这是旋转的一个不动点（$\\mathbf{R}\\mathbf{0} = \\mathbf{0}$）。\n\n原子类型 $Z_i$ 是不依赖于位置的标量，因此是内在不变的。\n\n**2. 等变消息传递**\n\n该模型通过消息传递机制为每个原子 $i$ 计算一个中间矢量表示 $\\mathbf{m}_i$。此阶段被设计为等变的。\n\n- **不变的消息系数 ($s_{ij}$)**：原子 $i$ 和 $j$ 之间的相互作用强度由一个标量系数 $s_{ij} = \\exp(-\\beta\\, d_{ij})\\left(a_0 + a_1 Z_i + a_2 Z_j + a_3 Z_i Z_j\\right)$ 调制。该系数仅是不变量（$d_{ij}$、$Z_i$、$Z_j$）和固定常量（$a_k$、$\\beta$）的函数，这使得 $s_{ij}$ 本身成为一个不变标量。\n\n- **等变矢量消息 ($\\mathbf{m}_i$)**：原子 $i$ 的消息是其邻居指向它的等变方向矢量的加权和：\n$$\n\\mathbf{m}_i = \\sum_{j \\ne i} s_{ij}\\, \\hat{\\mathbf{r}}_{ij}\n$$\n由于这是等变矢量（$\\hat{\\mathbf{r}}_{ij}$）与不变标量权重（$s_{ij}$）的线性组合，因此得到的矢量 $\\mathbf{m}_i$ 也是等变的。它在旋转下的变换为：\n$$\n\\mathbf{m}'_i = \\sum_{j \\ne i} s'_{ij}\\, \\hat{\\mathbf{r}}'_{ij} = \\sum_{j \\ne i} s_{ij}\\, (\\mathbf{R}\\hat{\\mathbf{r}}_{ij}) = \\mathbf{R} \\left(\\sum_{j \\ne i} s_{ij}\\, \\hat{\\mathbf{r}}_{ij}\\right) = \\mathbf{R}\\mathbf{m}_i\n$$\n\n**3. 不变读出与总预测**\n\n最后阶段将等变矢量集合 $\\{\\mathbf{m}_i\\}$ 映射到单个、总的不变标量 $E$。\n\n- **每节点不变标量 ($e_i$)**：首先为每个节点计算一个不变标量。\n$$\ne_i = c_1 \\|\\mathbf{m}_i\\|_2^2 + c_2 \\sum_{j \\ne i} \\exp(-\\gamma\\, d_{ij})\n$$\n项 $\\|\\mathbf{m}_i\\|_2^2$ 是等变矢量 $\\mathbf{m}_i$ 的范数的平方。等变矢量的范数总是不变的，因为 $\\|\\mathbf{R}\\mathbf{v}\\|_2^2 = (\\mathbf{R}\\mathbf{v})^\\top(\\mathbf{R}\\mathbf{v}) = \\mathbf{v}^\\top\\mathbf{R}^\\top\\mathbf{R}\\mathbf{v} = \\mathbf{v}^\\top\\mathbf{I}\\mathbf{v} = \\|\\mathbf{v}\\|_2^2$。第二项是不变距离 $d_{ij}$ 的函数之和，因此也是不变的。因此，作为不变项的线性组合，$e_i$ 是不变的。\n\n- **总不变预测 ($E$)**：最终的预测是这些每节点不变量与一个不变的原子类型贡献之和。\n$$\nE(\\mathbf{r}, \\mathbf{Z}) = \\sum_{i=1}^N e_i + c_3 \\sum_{i=1}^N Z_i\n$$\n作为不变量之和，总预测 $E$ 保证是旋转不变的，从而满足了问题的核心要求。\n\n**4. 实现与验证**\n\n该算法使用 `numpy` 进行数值计算。旋转矩阵 $\\mathbf{R}$ 通过 Rodrigues 公式从指定的轴-角对 $(\\hat{\\mathbf{a}}, \\theta)$ 生成：$\\mathbf{R} = \\cos\\theta\\, \\mathbf{I} + \\sin\\theta\\, [\\hat{\\mathbf{a}}]_\\times + (1-\\cos\\theta)\\, \\hat{\\mathbf{a}}\\hat{\\mathbf{a}}^\\top$，其中 $[\\hat{\\mathbf{a}}]_\\times$ 是与 $\\hat{\\mathbf{a}}$ 的叉积相对应的斜对称矩阵。将该逻辑应用于提供的测试用例，以在定义的容差 $\\tau = 10^{-10}$ 内数值上确认，对于原始原子坐标和旋转后的原子坐标，计算出的 $E$ 值是相同的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and verifies a rotation-invariant scalar prediction for molecular configurations.\n    \"\"\"\n    # Define constants from the problem statement.\n    DELTA = 1e-12\n    A0, A1, A2, A3 = 0.5, 0.1, -0.05, 0.02\n    BETA = 1.3\n    GAMMA = 0.9\n    C1, C2, C3 = 0.7, 0.2, 0.05\n    TOLERANCE_TAU = 1e-10\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"Z\": np.array([8, 1, 1], dtype=int),\n            \"r\": np.array([\n                [0.0, 0.0, 0.0],\n                [0.9572, 0.0, 0.0],\n                [-0.2399872, 0.927297, 0.0]\n            ]),\n            \"a\": np.array([1.0, 2.0, 3.0]),\n            \"theta\": 1.234\n        },\n        {\n            \"Z\": np.array([6, 1, 1], dtype=int),\n            \"r\": np.array([\n                [0.0, 0.0, 0.0],\n                [1.1, 0.0, 0.0],\n                [-1.1, 0.0, 0.0]\n            ]),\n            \"a\": np.array([0.0, 0.0, 1.0]),\n            \"theta\": np.pi\n        },\n        {\n            \"Z\": np.array([8], dtype=int),\n            \"r\": np.array([\n                [1.0, 2.0, 3.0]\n            ]),\n            \"a\": np.array([0.0, 0.0, 1.0]),\n            \"theta\": 0.7\n        },\n        {\n            \"Z\": np.array([1, 1, 1], dtype=int),\n            \"r\": np.array([\n                [0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0]\n            ]),\n            \"a\": np.array([0.0, 1.0, 0.0]),\n            \"theta\": 2.2\n        }\n    ]\n    \n    def compute_E(positions, types):\n        \"\"\"\n        Computes the total scalar prediction E for a given molecular configuration.\n        \"\"\"\n        num_atoms = len(types)\n        \n        # Handle single-atom and empty cases.\n        if num_atoms = 1:\n            return C3 * np.sum(types)\n\n        total_e_sum = 0.0\n        for i in range(num_atoms):\n            m_i = np.zeros(3)\n            e_i_dist_term = 0.0\n            \n            for j in range(num_atoms):\n                if i == j:\n                    continue\n                \n                # Calculate relative vector, distance, and unit vector\n                r_ij = positions[j] - positions[i]\n                d_ij = np.linalg.norm(r_ij)\n                \n                if d_ij = DELTA:\n                    r_hat_ij = np.zeros(3)\n                else:\n                    r_hat_ij = r_ij / d_ij\n                \n                # Calculate scalar coefficient s_ij\n                s_ij = np.exp(-BETA * d_ij) * (A0 + A1 * types[i] + A2 * types[j] + A3 * types[i] * types[j])\n                \n                # Update message vector m_i\n                m_i += s_ij * r_hat_ij\n                \n                # Update distance-dependent term for e_i\n                e_i_dist_term += np.exp(-GAMMA * d_ij)\n            \n            # Calculate per-node scalar e_i\n            m_i_norm_sq = np.dot(m_i, m_i) # More efficient than np.linalg.norm()**2\n            e_i = C1 * m_i_norm_sq + C2 * e_i_dist_term\n            total_e_sum += e_i\n            \n        # Calculate total prediction E\n        total_E = total_e_sum + C3 * np.sum(types)\n        return total_E\n\n    results = []\n    for case in test_cases:\n        Z, r, a, theta = case[\"Z\"], case[\"r\"], case[\"a\"], case[\"theta\"]\n        \n        # 1. Compute E for the original configuration\n        E_original = compute_E(r, Z)\n        \n        # 2. Generate the rotation matrix R using Rodrigues' formula\n        a_norm = np.linalg.norm(a)\n        if a_norm  DELTA: # Handles zero vector for axis\n             a_hat = np.zeros(3)\n        else:\n             a_hat = a / a_norm\n        \n        I = np.identity(3)\n        a_cross_matrix = np.array([\n            [0, -a_hat[2], a_hat[1]],\n            [a_hat[2], 0, -a_hat[0]],\n            [-a_hat[1], a_hat[0], 0]\n        ])\n        a_outer_product = np.outer(a_hat, a_hat)\n        \n        R = np.cos(theta) * I + np.sin(theta) * a_cross_matrix + (1 - np.cos(theta)) * a_outer_product\n\n        # 3. Apply rotation to coordinates\n        # r is (N, 3). R is (3, 3). We need (r @ R.T) or (R @ r.T).T\n        r_rotated = r @ R.T\n\n        # 4. Compute E for the rotated configuration\n        E_rotated = compute_E(r_rotated, Z)\n        \n        # 5. Check for invariance within the given tolerance\n        is_invariant = np.abs(E_original - E_rotated) = TOLERANCE_TAU\n        results.append(is_invariant)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3117017"}, {"introduction": "深度学习与传统科学计算之间的联系比表面上看起来要深刻得多。本练习揭示了深度学习中一种流行的架构——残差网络（ResNet）——与求解偏微分方程（PDE）的经典显式时间步进格式之间的惊人相似性。通过将求解器的一个步骤看作一个残差块，你将学会如何运用数值分析中的谱方法来分析该模型的稳定性，这是确保基于深度学习的动力学系统仿真可靠性的关键一步。[@problem_id:3116956]", "problem": "考虑一个由热方程控制的一维扩散，热方程是一个偏微分方程 (PDE)，具有周期性边界条件。在均匀空间网格上，其连续模型为 $u_t = \\alpha u_{xx}$。在一个标准的时间步长为 $dt$、空间网格间距为 $dx$ 的有限差分显式时间步进格式中，单个求解器步骤可以写为将离散算子 $\\mathcal{S}$ 应用于状态 $u^n$ 以产生 $u^{n+1} = \\mathcal{S}(u^n)$。在此问题中，您将使用一个残差网络（一个跳跃连接块）来模拟单个求解器步骤 $\\mathcal{S}$，并通过计算一个紧确界 $K$ 来评估所得算子的稳定性，该界 $K$ 需满足不等式 $\\|u^{n+1}\\|_2 \\le K \\|u^n\\|_2$ 对给定网格上的所有输入 $u^n$ 都成立。此处，$\\|\\cdot\\|_2$ 表示欧几里得范数。\n\n基本原理：\n- 有限差分通过局部模板来近似二阶导数。具有周期性边界条件的一维离散拉普拉斯算子使用标准的三点模板。\n- 周期性网格上的线性、移位不变离散算子是循环算子，可通过离散傅里叶变换 (DFT) 对角化。由欧几里得范数诱导的算子范数等于该算子在傅里叶基中的特征值的最大模。\n\n您的任务是：\n- 实现一个残差网络，该网络模拟周期性网格上热方程的一个显式欧拉求解器步骤。令残差块为 $\\mathcal{R}(u) = u + f(u)$，其中 $f(u)$ 通过周期性卷积应用离散拉普拉斯算子，并将其乘以 $\\alpha dt$。使用标准的拉普拉斯三点模板和循环（周期性）索引。具体来说，对于状态向量 $u \\in \\mathbb{R}^N$，定义\n$$\n\\mathrm{Lap}(u)_i = \\frac{u_{i+1} - 2u_i + u_{i-1}}{dx^2},\n$$\n采用周期性索引，并设置\n$$\n\\mathcal{R}(u) = u + \\alpha\\, dt\\, \\mathrm{Lap}(u).\n$$\n将 $\\mathcal{R}$ 视为一个残差网络，其残差分支中有一个线性卷积层和一个恒等跳跃连接。\n\n- 利用 $\\mathcal{R}$ 的循环结构，确定最紧确的界 $K$，使得对于所有 $u$，$\\|\\mathcal{R}(u)\\|_2 \\le K \\|u\\|_2$ 成立。界 $K$ 必须通过周期性网格（大小为 $N$）上循环算子的谱特性从第一性原理计算得出。\n\n- 通过在一小组随机生成的输入状态 $u$ 上对每个测试用例进行检查，数值验证不等式 $\\|\\mathcal{R}(u)\\|_2 \\le K \\|u\\|_2$ 成立。\n\n单位：\n- 设 $\\alpha$ 为扩散系数，单位为 $\\mathrm{m}^2/\\mathrm{s}$；$dx$ 的单位为 $\\mathrm{m}$；$dt$ 的单位为 $\\mathrm{s}$。界 $K$ 是无量纲的。\n\n不涉及角度单位。不涉及百分比。\n\n测试套件：\n使用以下参数集，每个参数集由 $(N, dx, \\alpha, dt)$ 指定：\n- 用例 1：$(N=\\;64, dx=\\;0.01\\;\\mathrm{m}, \\alpha=\\;10^{-4}\\;\\mathrm{m}^2/\\mathrm{s}, dt=\\;0.01\\;\\mathrm{s})$。\n- 用例 2：$(N=\\;64, dx=\\;0.01\\;\\mathrm{m}, \\alpha=\\;10^{-4}\\;\\mathrm{m}^2/\\mathrm{s}, dt=\\;0.50\\;\\mathrm{s})$。\n- 用例 3：$(N=\\;64, dx=\\;0.01\\;\\mathrm{m}, \\alpha=\\;10^{-4}\\;\\mathrm{m}^2/\\mathrm{s}, dt=\\;0.75\\;\\mathrm{s})$。\n- 用例 4：$(N=\\;65, dx=\\;0.01\\;\\mathrm{m}, \\alpha=\\;10^{-4}\\;\\mathrm{m}^2/\\mathrm{s}, dt=\\;0.75\\;\\mathrm{s})$。\n\n答案规格：\n- 对于每个测试用例，计算给定网格上算子 $\\mathcal{R}$ 的最紧确界 $K$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的 $K$ 值按上述用例顺序排列并四舍五入到三位小数，例如 $[K_1,K_2,K_3,K_4]$。\n\n覆盖设计：\n- 用例 1 是一个正常路径的稳定区域（$dt$ 较小）。\n- 用例 2 是一个边界区域。\n- 用例 3 是偶数网格上的一个不稳定区域。\n- 用例 4 探讨了与用例 3 相同的参数下，奇数网格尺寸对谱最大值的影响。\n\n所有数值必须由您的程序计算。不允许使用外部输入或文件。输出必须是严格符合指定格式的单行文本。", "solution": "任务是为数值算子 $\\mathcal{R}$ 找到最紧确的界 $K$。该算子模拟了一维热方程 $u_t = \\alpha u_{xx}$ 的显式欧拉求解器的一个步骤。界 $K$ 必须在大小为 $N$ 的周期性网格上对任何状态向量 $u \\in \\mathbb{R}^N$ 满足不等式 $\\|\\mathcal{R}(u)\\|_2 \\le K \\|u\\|_2$。\n\n算子 $\\mathcal{R}$ 定义为一个残差块：\n$$\n\\mathcal{R}(u) = u + \\alpha \\, dt \\, \\mathrm{Lap}(u)\n$$\n其中 $u$ 是大小为 $N$ 的状态向量，$\\alpha$ 是扩散系数，$dt$ 是时间步长，$\\mathrm{Lap}(u)$ 是离散拉普拉斯算子。在间距为 $dx$ 且具有周期性边界条件的均匀网格上，拉普拉斯算子的第 $i$ 个分量由三点模板给出：\n$$\n(\\mathrm{Lap}(u))_i = \\frac{u_{(i+1) \\pmod N} - 2u_i + u_{(i-1) \\pmod N}}{dx^2}\n$$\n算子 $\\mathcal{R}$ 是线性的，可以表示为矩阵向量积 $\\mathcal{R}(u) = A u$，其中 $A$ 是一个 $N \\times N$ 的矩阵。定义无量纲参数 $\\gamma$ 为 $\\gamma = \\frac{\\alpha \\, dt}{dx^2}$。矩阵 $A$ 可以写作：\n$$\nA = I + \\gamma L_d\n$$\n其中 $I$ 是 $N \\times N$ 的单位矩阵，$L_d$ 是表示周期性网格上带有模板 $(1, -2, 1)$ 的未缩放离散拉普拉斯算子的矩阵。由于移位不变模板和周期性边界条件，$L_d$ 和 $A$ 都是循环矩阵。$A$ 的第一行为 $(1 - 2\\gamma, \\gamma, 0, \\dots, 0, \\gamma)$。\n\n最紧确的界 $K$ 是算子的诱导 2-范数，它对应于矩阵 $A$ 的谱范数，记为 $\\|A\\|_2$。对于正规矩阵（包括任何循环矩阵），谱范数等于其谱半径 $\\rho(A)$，定义为其特征值的最大绝对值。\n$$\nK = \\|A\\|_2 = \\rho(A) = \\max_k |\\lambda_k(A)|\n$$\n循环矩阵的特征值 $\\lambda_k$ 由其第一行的离散傅里叶变换 (DFT) 给出。对于第一行为 $(c_0, c_1, \\dots, c_{N-1})$ 的循环矩阵，其特征值为 $\\lambda_k = \\sum_{j=0}^{N-1} c_j e^{-2\\pi i k j / N}$，其中 $k = 0, 1, \\dots, N-1$。\n\n对于矩阵 $A$，其第一行中唯一的非零元素是 $c_0 = 1 - 2\\gamma$，$c_1 = \\gamma$ 和 $c_{N-1} = \\gamma$。其特征值为：\n$$\n\\lambda_k = (1 - 2\\gamma) e^0 + \\gamma e^{-2\\pi i k(1)/N} + \\gamma e^{-2\\pi i k(N-1)/N}\n$$\n利用性质 $e^{-2\\pi i k(N-1)/N} = e^{-2\\pi i k} e^{2\\pi i k/N} = e^{2\\pi i k/N}$，表达式简化为：\n$$\n\\lambda_k = 1 - 2\\gamma + \\gamma (e^{-2\\pi i k/N} + e^{2\\pi i k/N})\n$$\n应用欧拉公式 $2\\cos\\theta = e^{i\\theta} + e^{-i\\theta}$，我们得到：\n$$\n\\lambda_k = 1 - 2\\gamma + 2\\gamma \\cos\\left(\\frac{2\\pi k}{N}\\right) = 1 + 2\\gamma \\left(\\cos\\left(\\frac{2\\pi k}{N}\\right) - 1\\right)\n$$\n利用三角恒等式 $\\cos(2\\theta) - 1 = -2\\sin^2(\\theta)$，特征值可以写成其最终的实值形式：\n$$\n\\lambda_k = 1 - 4\\gamma \\sin^2\\left(\\frac{\\pi k}{N}\\right), \\quad \\text{for } k = 0, 1, \\dots, N-1\n$$\n界 $K$ 是这些特征值在所有可能的模数 $k$ 上的绝对值的最大值：\n$$\nK = \\max_{k \\in \\{0, \\dots, N-1\\}} \\left| 1 - 4\\gamma \\sin^2\\left(\\frac{\\pi k}{N}\\right) \\right|\n$$\n令 $S_k = \\sin^2\\left(\\frac{\\pi k}{N}\\right)$。特征值的表达式是 $S_k$ 的一个线性函数。$S_k$ 的值范围从 $S_0 = 0$ 到最大值 $S_{max} = \\sin^2\\left(\\frac{\\pi \\lfloor N/2 \\rfloor}{N}\\right)$。$|\\lambda_k|$ 的最大值必定出现在 $S_k$ 的某个极值处。\n当 $k=0$ 时，$S_0=0$ 且 $\\lambda_0 = 1$。当 $k=\\lfloor N/2 \\rfloor$ 时，$S_k = S_{max}$，特征值为 $\\lambda_{ext} = 1 - 4\\gamma S_{max}$。因此，界 $K$ 由这两个特征值绝对值中的较大者决定：\n$$\nK = \\max(|\\lambda_0|, |\\lambda_{\\lfloor N/2 \\rfloor}|) = \\max\\left(1, \\left|1 - 4\\gamma S_{max}\\right|\\right)\n$$\n如果 $K \\le 1$，则数值格式是稳定的。这种情况发生在 $|1 - 4\\gamma S_{max}| \\le 1$ 时，这可以简化为此格式著名的 Courant-Friedrichs-Lewy (CFL) 条件：$4\\gamma S_{max} \\le 2$，即 $\\gamma S_{max} \\le 0.5$。\n- 如果 $\\gamma S_{max} \\le 0.5$，格式是稳定的。表达式 $1 - 4\\gamma S_{max}$ 介于 $-1$ 和 $1$ 之间，因此其绝对值小于或等于 $1$。在这种情况下，$K=1$。\n- 如果 $\\gamma S_{max}  0.5$，格式是不稳定的。表达式 $1 - 4\\gamma S_{max}$ 小于 $-1$。其绝对值为 $|1 - 4\\gamma S_{max}| = 4\\gamma S_{max} - 1$，该值大于 $1$。在这种情况下，$K = 4\\gamma S_{max} - 1$。\n\n对每个测试用例实施此逻辑，以计算相应的界 $K$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the tightest stability bound K for a finite-difference scheme\n    for the Heat Equation, interpreted as a residual network.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N, dx, alpha, dt)\n    test_cases = [\n        (64, 0.01, 1e-4, 0.01),  # Case 1: Stable\n        (64, 0.01, 1e-4, 0.50),  # Case 2: Boundary of stability\n        (64, 0.01, 1e-4, 0.75),  # Case 3: Unstable on an even grid\n        (65, 0.01, 1e-4, 0.75),  # Case 4: Unstable on an odd grid\n    ]\n\n    results = []\n    for case in test_cases:\n        N, dx, alpha, dt = case\n\n        # The operator is R(u) = u + alpha * dt * Lap(u).\n        # We can write this as R(u) = (I + gamma * L_d) * u,\n        # where gamma = alpha * dt / dx^2 and L_d is the discrete Laplacian matrix.\n        # The eigenvalues of the operator matrix A = I + gamma * L_d are:\n        # lambda_k = 1 - 4 * gamma * sin^2(pi * k / N) for k=0, ..., N-1.\n\n        # The bound K is the spectral radius of A, which is max(|lambda_k|).\n        # Let's compute gamma.\n        gamma = alpha * dt / (dx**2)\n\n        # The maximum of sin^2(pi*k/N) occurs at k = floor(N/2).\n        # This term determines the most negative eigenvalue, which dictates stability.\n        k_for_max_sin = np.floor(N / 2)\n        s_max_sq = np.sin(np.pi * k_for_max_sin / N)**2\n\n        # The eigenvalues are all real. The maximum absolute value is either at\n        # k=0 (lambda_0 = 1) or at k where sin^2 is maximized.\n        # The eigenvalue for the latter case is:\n        lambda_at_s_max = 1 - 4 * gamma * s_max_sq\n        \n        # The bound K is the maximum of |1| and |lambda_at_s_max|.\n        K = np.maximum(1.0, np.abs(lambda_at_s_max))\n\n        # A more direct formula based on stability condition gamma * s_max_sq = 0.5:\n        # if gamma * s_max_sq = 0.5:\n        #     K = 1.0\n        # else:\n        #     # In this case, lambda_at_s_max will be  -1, so its abs value is\n        #     # -(lambda_at_s_max) = 4 * gamma * s_max_sq - 1.\n        #     K = 4 * gamma * s_max_sq - 1\n\n        results.append(K)\n\n    # Format the results for output, rounding to three decimal places.\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3116956"}]}