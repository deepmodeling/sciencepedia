{"hands_on_practices": [{"introduction": "要真正掌握B样条，第一步是将其核心的数学定义转化为可执行的代码。本练习将指导你根据Cox-de Boor递推公式从零开始构建B样条曲线的求值程序。通过这个过程，你将亲手验证一个关键属性：使用“钳位”节点向量（clamped knot vector）如何确保曲线精确地通过其首尾控制点，这是许多设计应用中的基本要求。[@problem_id:3207506]", "problem": "你需要编写一个完整、可运行的程序，该程序构建并评估一条B样条（B-spline）曲线，并保证该曲线对其首尾控制点进行插值。你的设计必须从 B-spline 基函数的核心递归定义开始，然后实现一个兼顾数值稳定性和正确性的算法。\n\n从以下基本依据开始：B-spline 基函数的 Cox–de Boor 递归定义。对于一个给定的非递减节点向量 $\\{t_0, t_1, \\dots, t_m\\}$ 和阶数 $p \\ge 0$，基函数 $N_{i,p}(u)$ 由以下方式递归定义：\n$$\nN_{i,0}(u) = \n\\begin{cases}\n1, & t_i \\le u  t_{i+1} \\\\\n0,  \\text{其它情况}\n\\end{cases}\n$$\n对于 $p \\ge 1$：\n$$\nN_{i,p}(u) = \\frac{u - t_i}{t_{i+p} - t_i} N_{i,p-1}(u) + \\frac{t_{i+p+1} - u}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(u),\n$$\n约定分母为零的项视为零。参数化曲线则由下式给出：\n$$\n\\mathbf{C}(u) = \\sum_{i=0}^{n} N_{i,p}(u)\\,\\mathbf{P}_i,\n$$\n其中 $\\{\\mathbf{P}_0,\\dots,\\mathbf{P}_n\\}$ 是控制点。当节点向量是钳位（也称开放）的，即首尾节点各重复 $p+1$ 次时，可以保证曲线在参数域的端点处对首尾控制点进行插值。你的任务是实现一个使用这些定义的评估算法，并通过一个测试套件来证明你的曲线精确地通过其首尾控制点。\n\n要求：\n- 基于上述递归基函数定义，实现 B-spline 曲线评估，采用一种适合高年级本科生数值方法课程的数值稳定方法。你必须通过在两端使用重复度为 $p+1$ 的钳位节点向量来确保端点插值。\n- 评估域必须为 $[t_p, t_{m-p}]$。在 $u = t_p$ 和 $u = t_{m-p}$ 处，曲线必须分别返回 $\\mathbf{P}_0$ 和 $\\mathbf{P}_n$。\n- 使用欧几里得距离比较向量是否相等，容差为 $10^{-9}$，相对容差为零。如果范数差小于或等于 $10^{-9}$，则视为相等。\n\n测试套件与参数：\n对于下方的每个测试用例，在左端点 $u = t_p$ 和右端点 $u = t_{m-p}$ 处评估曲线，并检查这些点是否在容差范围内与首尾控制点匹配。你的程序应为每个测试用例生成一个布尔值，表示两个端点检查是否都通过。\n\n设每个控制点 $\\mathbf{P}_i$ 是一个指定维度（二维或三维）的坐标向量。节点向量要么是显式给出的，要么必须构建为钳位开放均匀节点向量。一个长度为 $m+1 = n + p + 2$ 的开放均匀钳位节点向量，其前 $p+1$ 个条目等于 $0$，后 $p+1$ 个条目等于 $1$，内部节点在 $(0,1)$ 区间内均匀分布。\n\n- 测试用例 1 (正常路径，二维，二次钳位开放均匀):\n  - 阶 $p = 2$。\n  - 控制点 $\\mathbf{P}_0,\\dots,\\mathbf{P}_4$: $\\{(0,0),(1,2),(2,0.5),(3,3),(4,0)\\}$。\n  - 为 $n=4, p=2$ 构建一个钳位开放均匀节点向量。\n- 测试用例 2 (边界情况，内部节点最少，三次钳位开放均匀，类 Bezier):\n  - 阶 $p = 3$。\n  - 控制点 $\\mathbf{P}_0,\\dots,\\mathbf{P}_3$: $\\{(0,0),(1,2),(3,2),(4,0)\\}$。\n  - 为 $n=3, p=3$ 构建一个钳位开放均匀节点向量。\n- 测试用例 3 (非均匀钳位，二维):\n  - 阶 $p = 3$。\n  - 控制点 $\\mathbf{P}_0,\\dots,\\mathbf{P}_6$: $\\{(0,0),(1,1),(2,-1),(3,2),(4,-0.5),(5,1.5),(6,0)\\}$。\n  - 显式钳位非均匀节点向量: $\\{0,0,0,0,0.15,0.6,0.85,1,1,1,1\\}$。\n- 测试用例 4 (边缘情况，线性钳位开放均匀):\n  - 阶 $p = 1$。\n  - 控制点 $\\mathbf{P}_0,\\dots,\\mathbf{P}_2$: $\\{(0,1),(1,0),(2,1.5)\\}$。\n  - 为 $n=2, p=1$ 构建一个钳位开放均匀节点向量。\n- 测试用例 5 (三维，三次钳位开放均匀):\n  - 阶 $p = 3$。\n  - 控制点 $\\mathbf{P}_0,\\dots,\\mathbf{P}_5$: $\\{(0,0,0),(1,2,1),(2,-1,2),(3,3,2),(4,0,1),(5,1,0)\\}$。\n  - 为 $n=5, p=3$ 构建一个钳位开放均匀节点向量。\n\n最终输出格式：\n- 你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，例如 $\\texttt{[true,false,true]}$。使用小写的 Python 布尔值格式。该列表必须为每个测试用例包含一个布尔值，并按上述顺序列出。", "solution": "该问题要求实现和验证 B-spline 曲线评估，并展示钳位节点向量的端点插值属性。解决方案直接源自问题陈述中提供的 B-spline 基函数的基本递归定义。\n\n一条 $p$ 阶 B-spline 曲线 $\\mathbf{C}(u)$ 是一个参数化曲线，定义为 $n+1$ 个控制点 $\\{\\mathbf{P}_0, \\dots, \\mathbf{P}_n\\}$ 的加权和：\n$$\n\\mathbf{C}(u) = \\sum_{i=0}^{n} N_{i,p}(u)\\,\\mathbf{P}_i\n$$\n权重是 B-spline 基函数 $N_{i,p}(u)$，它们是 $p$ 阶的分段多项式。它们的定义依赖于一个称为节点向量的非递减实数序列 $T = \\{t_0, t_1, \\dots, t_m\\}$，其中关系式 $m = n+p+1$ 必须成立。基函数由 Cox–de Boor 递归公式定义。\n\n当 $p=0$ 时：\n$$\nN_{i,0}(u) = \n\\begin{cases}\n1,   \\text{如果 } t_i \\le u  t_{i+1} \\\\\n0,   \\text{其它情况}\n\\end{cases}\n$$\n该定义意味着，对于任何长度为零的区间（即 $t_i = t_{i+1}$），基函数 $N_{i,0}(u)$ 始终为 $0$。对于参数值 $u$ 位于定义域最末端的情况，需要特殊考虑。如果曲线定义域是 $[t_p, t_{n+1}]$，那么对于 $u = t_{n+1}$，相关的非零 0 阶基函数被取为 $N_{n,0}(t_{n+1})=1$。\n\n当 $p \\ge 1$ 时：\n$$\nN_{i,p}(u) = \\frac{u - t_i}{t_{i+p} - t_i} N_{i,p-1}(u) + \\frac{t_{i+p+1} - u}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(u)\n$$\n问题指明，如果此表达式中的分母为零，则相应的项视为零。\n\n任务的核心是基于这些定义实现一个计算 $\\mathbf{C}(u)$ 的算法，并验证对于钳位节点向量，$\\mathbf{C}(t_p) = \\mathbf{P}_0$ 和 $\\mathbf{C}(t_{n+1}) = \\mathbf{P}_n$ 成立。一个钳位节点向量，其前 $p+1$ 个节点和后 $p+1$ 个节点分别相等。这种结构确保了 $N_{0,p}(t_p)=1$ 和 $N_{n,p}(t_{n+1})=1$，而所有其他基函数 $N_{i,p}$ 在各自的端点处为零，从而实现插值。\n\n对于每个测试用例，整体算法流程如下：\n1.  **参数设置**：定义阶数 $p$ 和 $n+1$ 个控制点集合 $\\{\\mathbf{P}_i\\}$。\n2.  **节点向量构建**：构建节点向量 $T$。对于需要钳位开放均匀节点向量的情况，前 $p+1$ 个节点设为 $0$，后 $p+1$ 个节点设为 $1$，而 $n-p$ 个内部节点在区间 $(0,1)$ 内均匀分布。节点数量为 $m+1 = n+p+2$。\n3.  **端点处曲线评估**：\n    *   在曲线定义域的左端点 $u_{left} = t_p$ 处进行评估。\n    *   在曲线定义域的右端点 $u_{right} = t_{n+1}$ 处进行评估。\n    *   评估本身 $\\mathbf{C}(u)$ 由一个计算 $\\sum_{i=0}^{n} N_{i,p}(u)\\,\\mathbf{P}_i$ 的函数执行。\n4.  **基函数计算**：每个基函数 $N_{i,p}(u)$ 的值通过一个直接实现 Cox-de Boor 公式的递归函数计算。为确保计算可行性，该递归函数使用记忆化（一种动态规划形式），以防止对相同基函数值的重复计算。基例 $N_{i,0}(u)$ 的实现必须仔细处理半开区间以及定义域右端点的特殊情况。\n5.  **验证**：将计算出的点 $\\mathbf{C}(u_{left})$ 与第一个控制点 $\\mathbf{P}_0$ 进行比较，并将 $\\mathbf{C}(u_{right})$ 与最后一个控制点 $\\mathbf{P}_n$ 进行比较。比较通过计算向量之间的欧几里得距离来完成。如果两个端点的距离都在指定的 $10^{-9}$ 容差范围内，则认为该测试用例通过。\n\n实现过程封装了这些步骤。一个主函数遍历测试套件，调用辅助函数来构建节点向量和评估 B-spline 曲线。评估函数 `b_spline_eval` 使用一个嵌套的辅助函数 `_basis_function` 来递归计算基函数。这种嵌套结构使得递归函数保持简洁，同时可以访问参数 $u$、节点向量 $T$ 和记忆化字典，从而避免了使用全局状态。每个测试用例的结果（一个布尔值）被收集起来，并以指定格式打印。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_clamped_uniform_knot_vector(n, p):\n    \"\"\"\n    Constructs a clamped open-uniform knot vector.\n    The domain for the interior knots is (0, 1).\n    \n    Args:\n        n (int): The number of control points minus 1.\n        p (int): The degree of the B-spline.\n        \n    Returns:\n        np.ndarray: The knot vector of length n + p + 2.\n    \"\"\"\n    num_knots = n + p + 2\n    T = np.zeros(num_knots, dtype=float)\n    \n    num_interior_knots = n - p\n    if num_interior_knots  0:\n      denominator = float(n - p + 1)\n      T[p + 1 : n + 1] = np.arange(1, num_interior_knots + 1) / denominator\n    \n    T[n + 1:] = 1.0\n    return T\n\ndef b_spline_eval(u, p, control_points, T):\n    \"\"\"\n    Evaluates the B-spline curve at a parameter value u using the recursive\n    Cox-de Boor basis function definition with memoization.\n    \n    Args:\n        u (float): The parameter value.\n        p (int): The degree of the B-spline.\n        control_points (np.ndarray): Array of control points.\n        T (np.ndarray): The knot vector.\n        \n    Returns:\n        np.ndarray: The computed point on the curve.\n    \"\"\"\n    n = len(control_points) - 1\n    memo = {}\n\n    def _basis_function(i, deg):\n        \"\"\"\n        Computes the value of the B-spline basis function N_i,deg(u) via\n        a memoized recursion. This is a nested function to capture u, T, n, and memo.\n        \"\"\"\n        if (i, deg) in memo:\n            return memo[(i, deg)]\n\n        if deg == 0:\n            # The curve domain is [t_p, t_{n+1}]. At the right boundary u = t_{n+1},\n            # the convention is that u falls in the last interval [t_n, t_{n+1}],\n            # making N_{n,0}(t_{n+1}) = 1.\n            if u == T[n + 1] and i == n:\n                res = 1.0\n            else:\n                # Standard definition for half-open interval [t_i, t_{i+1}).\n                # This is 0 if t_i == t_{i+1}.\n                res = 1.0 if T[i] = u and u  T[i + 1] else 0.0\n            memo[(i, deg)] = res\n            return res\n\n        # Recursive step\n        term1 = 0.0\n        den1 = T[i + deg] - T[i]\n        if den1 != 0.0:\n            term1 = ((u - T[i]) / den1) * _basis_function(i, deg - 1)\n\n        term2 = 0.0\n        den2 = T[i + deg + 1] - T[i + 1]\n        if den2 != 0.0:\n            term2 = ((T[i + deg + 1] - u) / den2) * _basis_function(i + 1, deg - 1)\n\n        res = term1 + term2\n        memo[(i, deg)] = res\n        return res\n\n    curve_point = np.zeros_like(control_points[0], dtype=float)\n    for i in range(n + 1):\n        basis_val = _basis_function(i, p)\n        # Optimization: only add if the basis function is non-zero\n        if basis_val  1e-12: # Check against small tolerance\n            curve_point += basis_val * control_points[i]\n            \n    return curve_point\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and verify endpoint interpolation.\n    \"\"\"\n    test_cases = [\n        # Case 1: 2D quadratic\n        {\n            \"p\": 2,\n            \"control_points\": np.array([\n                [0, 0], [1, 2], [2, 0.5], [3, 3], [4, 0]\n            ]),\n            \"knot_vector\": None \n        },\n        # Case 2: 2D cubic, Bezier-like\n        {\n            \"p\": 3,\n            \"control_points\": np.array([\n                [0, 0], [1, 2], [3, 2], [4, 0]\n            ]),\n            \"knot_vector\": None\n        },\n        # Case 3: 2D cubic, non-uniform knots\n        {\n            \"p\": 3,\n            \"control_points\": np.array([\n                [0, 0], [1, 1], [2, -1], [3, 2], [4, -0.5], [5, 1.5], [6, 0]\n            ]),\n            \"knot_vector\": np.array([0, 0, 0, 0, 0.15, 0.6, 0.85, 1, 1, 1, 1])\n        },\n        # Case 4: 2D linear\n        {\n            \"p\": 1,\n            \"control_points\": np.array([\n                [0, 1], [1, 0], [2, 1.5]\n            ]),\n            \"knot_vector\": None\n        },\n        # Case 5: 3D cubic\n        {\n            \"p\": 3,\n            \"control_points\": np.array([\n                [0, 0, 0], [1, 2, 1], [2, -1, 2], [3, 3, 2], [4, 0, 1], [5, 1, 0]\n            ]),\n            \"knot_vector\": None\n        }\n    ]\n\n    results = []\n    tolerance = 1e-9\n\n    for case in test_cases:\n        p = case[\"p\"]\n        P = case[\"control_points\"]\n        n = len(P) - 1\n\n        if case[\"knot_vector\"] is None:\n            T = build_clamped_uniform_knot_vector(n, p)\n        else:\n            T = case[\"knot_vector\"]\n        \n        # Endpoints of the parametric domain for a clamped knot vector\n        u_left = T[p]\n        u_right = T[n + 1]\n\n        # Evaluate curve at endpoints\n        C_left = b_spline_eval(u_left, p, P, T)\n        C_right = b_spline_eval(u_right, p, P, T)\n\n        # Verify interpolation\n        dist_left = np.linalg.norm(C_left - P[0])\n        dist_right = np.linalg.norm(C_right - P[-1])\n\n        check_left = dist_left = tolerance\n        check_right = dist_right = tolerance\n        \n        results.append(check_left and check_right)\n\n    # Format output as required\n    print(f\"[{','.join(map(str, results))}]\".lower())\n\nsolve()\n```", "id": "3207506"}, {"introduction": "掌握了B样条的基本构建后，下一步是学习如何精细地控制其局部形状。本练习将引导你探索B样条最强大的特性之一：节点重复度（knot multiplicity）。你将通过编写程序来量化增加节点重复度对曲线连续性和形状的影响，例如在曲线上产生尖角或平坦部分，从而深刻理解理论与实践之间的联系。[@problem_id:3099558]", "problem": "您将研究增加三次 B 样条中节点的多重性如何影响局部形状，包括相对于基准曲线可能出现的过冲以及角点或平坦点的产生。您将完全在一个纯数学的环境中工作，使用二维控制点和标准的 B 样条定义。您的程序必须是一个完整、可运行的实现，它从第一性原理出发评估曲线及其导数，并为一个小型的测试套件计算量化指标。\n\n基本依据和定义：\n- 一个次数为 $p$、控制点为 $\\{\\mathbf{P}_i\\}_{i=0}^{N-1}$、非递减节点向量为 $\\{t_j\\}_{j=0}^{N+p}$ 的 B 样条曲线定义为\n$$\n\\mathbf{C}(t) = \\sum_{i=0}^{N-1} N_{i,p}(t)\\,\\mathbf{P}_i,\n$$\n其中 $N_{i,p}(t)$ 是由 Cox–de Boor 递归公式定义的 B 样条基函数：\n$$\nN_{i,0}(t) =\n\\begin{cases}\n1,  t_i \\le t  t_{i+1},\\\\\n0,  \\text{其它情况},\n\\end{cases}\n$$\n并且对于 $p \\ge 1$\n$$\nN_{i,p}(t) = \\frac{t - t_i}{t_{i+p} - t_i} N_{i,p-1}(t) + \\frac{t_{i+p+1} - t}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(t),\n$$\n约定分母为零的项贡献为 $0$。\n- 曲线的导数使用基函数的导数：\n$$\n\\mathbf{C}'(t) = \\sum_{i=0}^{N-1} \\frac{d N_{i,p}(t)}{dt}\\,\\mathbf{P}_i,\n$$\n其中\n$$\n\\frac{d N_{i,p}(t)}{dt} = \\frac{p}{t_{i+p} - t_i} N_{i,p-1}(t) - \\frac{p}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(t),\n$$\n同样地，除以零的项贡献为 $0$。\n- 对于次数为 $p$ 的 B 样条中多重性为 $m$ 的节点，曲线在该节点处的连续性为 $C^{p-m}$，这意味着前 $p-m$ 阶导数是连续的，而第 $(p-m+1)$ 阶导数通常会有一个跳变。特别地，如果 $m = p+1$，曲线在该节点处会断开（没有位置连续性）。\n\n场景和建模设置：\n- 使用次数 $p = 3$（三次）和 $N = 8$ 个位于 $\\mathbb{R}^2$ 中的控制点。\n- 使用一个两端重复的开放节点向量：\n$$\n\\underbrace{0,0,0,0}_{p+1\\text{ 次}}, \\text{内部节点}, \\underbrace{1,1,1,1}_{p+1\\text{ 次}}。\n$$\n- 设我们感兴趣的内部节点位置为 $u_0 = 0.5$。内部节点项的总数为 $N - p - 1 = 4$。对于在 $u_0$ 处选定的多重性 $m \\in \\{1,2,3,4\\}$，按如下方式构建内部节点多重集。包含 $m$ 个 $u_0$ 的副本，并从固定列表 $\\{0.25,\\,0.33,\\,0.75\\}$ 中使用剩余的 $4 - m$ 个项，从该列表中取最小的 $4-m$ 个元素，然后对所有内部项进行排序。这样对每个 $m$ 都能产生恰好四个内部节点项。\n- 定义两种控制点场景：\n  - 场景 A（驼峰状）：\n    - $\\mathbf{P}_0=(0.0, 0.0)$，\n    - $\\mathbf{P}_1=(1.0, 1.0)$，\n    - $\\mathbf{P}_2=(2.0, 2.0)$，\n    - $\\mathbf{P}_3=(3.0, 4.0)$，\n    - $\\mathbf{P}_4=(4.0, 2.0)$，\n    - $\\mathbf{P}_5=(5.0, 1.5)$，\n    - $\\mathbf{P}_6=(6.0, 1.2)$，\n    - $\\mathbf{P}_7=(7.0, 1.1)$。\n  - 场景 B（局部平坦区域）：\n    - $\\mathbf{P}_0=(0.0, 0.0)$，\n    - $\\mathbf{P}_1=(1.0, 0.5)$，\n    - $\\mathbf{P}_2=(2.0, 1.0)$，\n    - $\\mathbf{P}_3=(3.0, 1.0)$，\n    - $\\mathbf{P}_4=(4.0, 1.0)$，\n    - $\\mathbf{P}_5=(5.0, 1.0)$，\n    - $\\mathbf{P}_6=(6.0, 1.2)$，\n    - $\\mathbf{P}_7=(7.0, 2.0)$。\n\n待计算的量：\n- 定义基准曲线为在 $u_0=0.5$ 处多重性 $m=1$ 的三次 B 样条，使用上述内部节点构造方法。将此基准表示为 $\\mathbf{C}_{\\mathrm{base}}(t)$。\n- 对于每个场景和每个 $m \\in \\{1,2,3,4\\}$，构造相应的节点向量并计算：\n  1. 在参数值的均匀样本上与基准曲线的最大绝对偏差：\n     $$\n     D_{\\max}(m) = \\max_{t \\in \\mathcal{T}} \\left\\lVert \\mathbf{C}_m(t) - \\mathbf{C}_{\\mathrm{base}}(t) \\right\\rVert_2.\n     $$\n     使用欧几里得范数。设样本 $\\mathcal{T}$ 为在开区间 $(0,1)$ 内的 $4001$ 个等距点，例如 $t_k$ 从 $10^{-6}$ 到 $1-10^{-6}$ 线性间隔，以避免恰好在节点处求值。\n  2. 内部节点 $u_0$ 处斜率不连续性的数值度量：\n     $$\n     J(m) = \\left\\lVert \\mathbf{C}_m'(u_0^+) - \\mathbf{C}_m'(u_0^-) \\right\\rVert_2.\n     $$\n     为了在不精确命中节点的情况下评估单边导数，选择\n     $$\n     \\delta = \\min\\left(0.1\\,(u_0 - u_\\text{L}),\\, 0.1\\,(u_\\text{R} - u_0),\\, 10^{-3}\\right),\n     $$\n     其中 $u_\\text{L}$ 是构造的节点向量中严格小于 $u_0$ 的最大节点，而 $u_\\text{R}$ 是严格大于 $u_0$ 的最小节点。然后通过使用上述基导数公式评估 $\\mathbf{C}_m'(u_0 - \\delta)$ 和 $\\mathbf{C}_m'(u_0 + \\delta)$ 来近似单边导数。它们差的欧几里得范数即为 $J(m)$。\n\n测试套件和要求的输出：\n- 使用场景 A 和场景 B 的控制点。\n- 对每个场景，为 $m = 1, 2, 3, 4$ 评估配对 $\\left(D_{\\max}(m), J(m)\\right)$。\n- 将报告的每个浮点结果四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含两个场景的所有结果，形式为一个用方括号括起来的逗号分隔列表。排序必须是：\n  - 场景 A: $D_{\\max}(1)$, $J(1)$, $D_{\\max}(2)$, $J(2)$, $D_{\\max}(3)$, $J(3)$, $D_{\\max}(4)$, $J(4)$,\n  - 接着是同样顺序的场景 B。\n即，输出格式为\n$$\n[\\;D_{\\max}^{A}(1),J^{A}(1),D_{\\max}^{A}(2),J^{A}(2),D_{\\max}^{A}(3),J^{A}(3),D_{\\max}^{A}(4),J^{A}(4),D_{\\max}^{B}(1),J^{B}(1),D_{\\max}^{B}(2),J^{B}(2),D_{\\max}^{B}(3),J^{B}(3),D_{\\max}^{B}(4),J^{B}(4)\\;].\n$$\n不需要单位，因为所有量都是无量纲的。", "solution": "用户提供了一个关于 B 样条曲线属性的明确定义的计算问题。我将首先验证问题陈述，然后基于基本原理提供一个全面的解决方案。\n\n### 问题验证\n\n1.  **提取已知条件**：\n    - **曲线类型**：次数为 $p=3$、具有 $N=8$ 个 $\\mathbb{R}^2$ 中控制点的 B 样条曲线。\n    - **曲线定义**：$\\mathbf{C}(t) = \\sum_{i=0}^{N-1} N_{i,p}(t)\\,\\mathbf{P}_i$，基函数 $N_{i,p}(t)$ 由 Cox–de Boor 递归公式定义。\n    - **曲线导数**：$\\mathbf{C}'(t) = \\sum_{i=0}^{N-1} \\frac{d N_{i,p}(t)}{dt}\\,\\mathbf{P}_i$，其中 $\\frac{d N_{i,p}(t)}{dt} = \\frac{p}{t_{i+p} - t_i} N_{i,p-1}(t) - \\frac{p}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(t)$。\n    - **节点向量**：开放节点向量，在 $0$ 处有 $p+1=4$ 个节点，在 $1$ 处有 $4$ 个节点。它包含 $N-p-1=4$ 个内部节点。\n    - **内部节点构造**：对于在 $u_0 = 0.5$ 处的多重性 $m \\in \\{1,2,3,4\\}$，四个内部节点由 $m$ 个 $0.5$ 的副本和集合 $\\{0.25, 0.33, 0.75\\}$ 中最小的 $4-m$ 个值组成，并进行排序。\n    - **控制点场景**：提供了两组控制点，场景 A（驼峰状）和场景 B（局部平坦区域）。\n    - **度量指标**：\n        1.  $D_{\\max}(m) = \\max_{t \\in \\mathcal{T}} \\left\\lVert \\mathbf{C}_m(t) - \\mathbf{C}_{\\mathrm{base}}(t) \\right\\rVert_2$，其中 $\\mathbf{C}_{\\mathrm{base}}$ 是 $m=1$ 时的曲线。评估网格 $\\mathcal{T}$ 在 $(0,1)$ 区间内有 $4001$ 个点。\n        2.  $J(m) = \\left\\lVert \\mathbf{C}_m'(u_0^+) - \\mathbf{C}_m'(u_0^-) \\right\\rVert_2$，单边导数在 $u_0 \\pm \\delta$ 处近似。$\\delta$ 定义为 $\\min\\left(0.1\\,(u_0 - u_\\text{L}),\\, 0.1\\,(u_\\text{R} - u_0),\\, 10^{-3}\\right)$。\n    - **输出格式**：包含 16 个浮点值的单行逗号分隔列表，四舍五入到六位小数，代表两种场景下每个 $m \\in \\{1,2,3,4\\}$ 的 $(D_{\\max}(m), J(m))$。\n\n2.  **对照标准验证**：\n    - **科学依据**：该问题植根于 B 样条的标准数学理论，这是计算科学和计算机辅助几何设计的核心课题。所有定义和公式都是正确的。\n    - **良构性**：问题以高度精确的方式被指定。所有参数、数据、构造规则以及待计算量的公式都已明确给出。该设置是自洽的，足以产生唯一、确定性的解。\n    - **客观性**：问题陈述完全是客观的，使用了精确的数学语言和量化定义。没有主观或含糊的元素。\n    - **其他标准**：该问题并非微不足道，因为它需要一个从第一性原理正确实现一个不平凡的算法。它不具有矛盾性、不切实际或病态问题。\n\n3.  **结论与行动**：\n    问题陈述是**有效**的。我将继续制定并实现一个解决方案。\n\n### 解决方案设计\n\n该解决方案需要根据提供的基本定义来实现 B 样条曲线评估及其导数。对 Cox-de Boor 公式进行直接递归实现计算效率低下。将采用一种更稳健、性能更好的方法，该方法基于标准文献中的算法（例如，Piegl 和 Tiller 的《The NURBS Book》）。这符合“从第一性原理”的要求，因为这些算法是数学定义的直接实现。\n\n1.  **核心算法**：\n    - **节点区间搜索**：将实现一个函数 `find_span` 来有效定位包含给定参数值 $t$ 的节点区间（span）。这是高效评估基函数的前提，通常使用二分搜索实现。\n    - **基函数评估**：一个函数 `basis_funs` 将实现一种迭代的动态规划方法（来自《The NURBS Book》的算法 A2.2），以计算给定次数的、在参数 $t$ 的节点区间内所有非零基函数的值。这比简单的递归方法效率高得多。\n    - **曲线评估**：函数 `evaluate_bspline` 将结合 `find_span` 和 `basis_funs` 来计算曲线上的点 $\\mathbf{C}(t)$。它找到相关的节点区间，计算非零基函数，然后用相应的控制点对它们进行加权求和。\n    - **曲线导数评估**：函数 `evaluate_bspline_derivative` 将通过直接实现求和 $\\sum_i \\frac{d N_{i,p}(t)}{dt} \\mathbf{P}_i$ 来计算 $\\mathbf{C}'(t)$。基函数的导数 $\\frac{d N_{i,p}(t)}{dt}$ 将使用提供的公式计算，这反过来又需要次数为 $p-1$ 的基函数。这些将使用相同的 `basis_funs` 算法高效计算。\n\n2.  **单一情况（$m$，场景）的工作流程**：\n    - **节点向量构造**：通过连接起始的重复节点（$p+1$ 个零）、四个指定的内部节点和结尾的重复节点（$p+1$ 个一），构造长度为 $N+p+1=12$ 的完整节点向量。\n    - **为 $D_{\\max}$ 进行曲线评估**：对于每个 $m$，在 $(0,1)$ 区间的 $4001$ 个采样点上评估曲线 $\\mathbf{C}_m(t)$。对于 $m=1$，这些点定义了基准曲线 $\\mathbf{C}_{\\mathrm{base}}$。对于 $m1$，计算与相应基准点的欧几里得距离，这些距离的最大值即为 $D_{\\max}(m)$。根据定义，$D_{\\max}(1)=0$。\n    - **为 $J(m)$ 计算导数跳变**：根据问题的规则确定小偏移量 $\\delta$。在 $u_0 - \\delta$ 和 $u_0 + \\delta$ 处评估导数 $\\mathbf{C}_m'(t)$。这两个导数向量之差的欧几里得范数即为跳变值 $J(m)$。B 样条的连续性性质表明，$J(1)$ 和 $J(2)$ 应接近于零，而 $J(3)$ 和 $J(4)$ 可能显著非零，这为实现提供了一个很好的健全性检查。\n\n3.  **总体结构**：\n    主程序将遍历两种控制点场景。在每个场景中，它将遍历从 $1$ 到 $4$ 的多重性 $m$。在每种情况下，它将构造适当的节点向量，计算配对 $(D_{\\max}(m), J(m))$，并存储结果。最后，所有 16 个标量结果将按要求格式化为单个字符串。", "answer": "```python\nimport numpy as np\n\ndef find_span(num_cp, degree, t, knots):\n    \"\"\"\n    Finds the knot span index for a given parameter t.\n    num_cp: number of control points (N).\n    degree: degree of the curve (p).\n    t: parameter value.\n    knots: knot vector.\n    Returns the index k such that knots[k] = t  knots[k+1].\n    \"\"\"\n    # For t=1.0, which can occur at the end of the domain for an open knot vector.\n    # The valid parameter range is [knots[p], knots[N]]. For an open knot vector,\n    # this is [0, 1]. The last span index is N-1.\n    if t = knots[num_cp]:\n        return num_cp - 1\n    \n    # Binary search for the span. The search space is [p, N-1].\n    low = degree\n    high = num_cp\n    \n    while low  high:\n        mid = (low + high) // 2\n        if t  knots[mid]:\n            high = mid\n        else:\n            low = mid + 1\n    return low - 1\n\ndef basis_funs(span, t, degree, knots):\n    \"\"\"\n    Computes the non-zero B-spline basis functions for a given parameter t.\n    (Cox's algorithm).\n    span: knot span index.\n    t: parameter value.\n    degree: degree of the curve.\n    knots: knot vector.\n    Returns an array of p+1 basis function values, N_{span-degree, degree}, ..., N_{span, degree}.\n    \"\"\"\n    basis = np.zeros(degree + 1)\n    left = np.zeros(degree + 1)\n    right = np.zeros(degree + 1)\n    \n    basis[0] = 1.0\n    for j in range(1, degree + 1):\n        left[j] = t - knots[span + 1 - j]\n        right[j] = knots[span + j] - t\n        saved = 0.0\n        for r in range(j):\n            den = knots[span + r + 1] - knots[span + r + 1 - j]\n            if den == 0.0:\n                temp = 0.0\n            else:\n                temp = basis[r] / den\n            basis[r] = saved + right[r + 1] * temp\n            saved = left[j - r] * temp\n        basis[j] = saved\n    return basis\n\ndef evaluate_bspline(t, num_cp, degree, knots, control_points):\n    \"\"\"\n    Evaluates a B-spline curve at a given parameter t.\n    \"\"\"\n    if t  knots[degree] or t  knots[num_cp]:\n        if t = knots[degree]: return control_points[0]\n        else: return control_points[-1]\n\n    span = find_span(num_cp, degree, t, knots)\n    basis_values = basis_funs(span, t, degree, knots)\n    \n    curve_point = np.zeros_like(control_points[0], dtype=float)\n    for i in range(degree + 1):\n        curve_point += basis_values[i] * control_points[span - degree + i]\n    return curve_point\n\ndef evaluate_bspline_derivative(t, num_cp, degree, knots, control_points):\n    \"\"\"\n    Evaluates the derivative of a B-spline curve at a given parameter t.\n    \"\"\"\n    if t  knots[degree] or t  knots[num_cp]:\n        return np.zeros_like(control_points[0], dtype=float)\n\n    span = find_span(num_cp, degree, t, knots)\n    basis_values_p_minus_1 = basis_funs(span, t, degree - 1, knots)\n    \n    deriv_point = np.zeros_like(control_points[0], dtype=float)\n    \n    for i in range(span - degree, span + 1):\n        # Contribution from control point P_i\n        # dN_{i,p}/dt = p/(t_{i+p}-t_i) * N_{i,p-1} - p/(t_{i+p+1}-t_{i+1}) * N_{i+1,p-1}\n        \n        # Term 1: involving N_{i, p-1}\n        num1 = 0.0\n        # The non-zero basis functions of degree p-1 for span k are N_{k-(p-1),p-1} to N_{k,p-1}\n        if (span - (degree - 1)) = i = span:\n            num1 = basis_values_p_minus_1[i - (span - (degree - 1))]\n        \n        den1 = knots[i + degree] - knots[i]\n        term1 = 0.0\n        if den1 != 0.0:\n            term1 = degree * num1 / den1\n\n        # Term 2: involving N_{i+1, p-1}\n        num2 = 0.0\n        if (span - (degree - 1)) = (i + 1) = span:\n            num2 = basis_values_p_minus_1[i + 1 - (span - (degree - 1))]\n\n        den2 = knots[i + degree + 1] - knots[i + 1]\n        term2 = 0.0\n        if den2 != 0.0:\n            term2 = degree * num2 / den2\n        \n        d_basis = term1 - term2\n        deriv_point += d_basis * control_points[i]\n        \n    return deriv_point\n\n\ndef solve():\n    p = 3\n    N = 8\n    u0 = 0.5\n    \n    P_A = np.array([\n        [0.0, 0.0], [1.0, 1.0], [2.0, 2.0], [3.0, 4.0],\n        [4.0, 2.0], [5.0, 1.5], [6.0, 1.2], [7.0, 1.1]\n    ], dtype=float)\n    \n    P_B = np.array([\n        [0.0, 0.0], [1.0, 0.5], [2.0, 1.0], [3.0, 1.0],\n        [4.0, 1.0], [5.0, 1.0], [6.0, 1.2], [7.0, 2.0]\n    ], dtype=float)\n\n    scenarios = [(\"A\", P_A), (\"B\", P_B)]\n    interior_knot_pool = [0.25, 0.33, 0.75]\n    \n    t_samples = np.linspace(1e-6, 1.0 - 1e-6, 4001)\n    \n    all_results = []\n    \n    for _, P in scenarios:\n        C_base_pts = None\n        \n        for m in range(1, 5):\n            # 1. Construct knot vector\n            num_other_knots = 4 - m\n            interior_knots = sorted(interior_knot_pool[:num_other_knots] + [u0] * m)\n            knots = np.concatenate((np.zeros(p + 1, dtype=float), np.array(interior_knots, dtype=float), np.ones(p + 1, dtype=float)))\n\n            # 2. Compute curve points for D_max calculation\n            C_m_pts = np.array([evaluate_bspline(t, N, p, knots, P) for t in t_samples])\n            \n            if m == 1:\n                C_base_pts = C_m_pts\n                D_max = 0.0\n            else:\n                deviations = np.linalg.norm(C_m_pts - C_base_pts, axis=1)\n                D_max = np.max(deviations)\n\n            # 3. Compute slope discontinuity J(m)\n            unique_knots = sorted(list(set(knots)))\n            u_L_idx = np.searchsorted(unique_knots, u0, side='left') - 1\n            u_R_idx = np.searchsorted(unique_knots, u0, side='right')\n            u_L = unique_knots[u_L_idx] if u_L_idx = 0 else knots[0]\n            u_R = unique_knots[u_R_idx] if u_R_idx  len(unique_knots) else knots[-1]\n            \n            term_L = 0.1 * (u0 - u_L) if u_L  u0 else np.inf\n            term_R = 0.1 * (u_R - u0) if u_R  u0 else np.inf\n            delta = min(term_L, term_R, 1e-3)\n            \n            dC_left = evaluate_bspline_derivative(u0 - delta, N, p, knots, P)\n            dC_right = evaluate_bspline_derivative(u0 + delta, N, p, knots, P)\n            J_m = np.linalg.norm(dC_right - dC_left)\n            \n            all_results.extend([D_max, J_m])\n            \n    print(f\"[{','.join(f'{r:.6f}' for r in all_results)}]\")\n\nsolve()\n```", "id": "3099558"}, {"introduction": "现在，让我们将所学知识应用于一个源自计算机图形学和几何建模的真实问题中。本练习要求你设计并实现一个稳健的算法，用于寻找B样条曲线上距离任意给定点最近的点。这个称为“点投影”（point projection）的任务是许多高级应用（如碰撞检测、几何查询）的基石，它要求你将B样条的求导与数值优化方法（如牛顿法）相结合，是综合运用计算科学技能的绝佳实践。[@problem_id:3207471]", "problem": "设计并实现一个完整且数值稳定的程序，对于给定的平面B样条曲线和一组外部点，使用带保护的牛顿-拉夫逊方法计算每个外部点到曲线上的最近点。曲线由一个次数、一个非递减的节点向量和一系列控制点定义。您的实现必须是自包含的，并且不得读取任何输入。\n\n您必须从以下基本定义和事实出发。\n\n1. 一个次数为 $p$、控制点为 $\\{\\mathbf{P}_i\\}_{i=0}^n \\subset \\mathbb{R}^2$、非递减节点向量为 $\\{U_j\\}_{j=0}^m$ 的B样条曲线，由B样条基函数 $\\{N_{i,p}(u)\\}_{i=0}^n$ 在参数域 $u \\in [U_p, U_{m-p}]$ 上的线性组合给出，即 $\\mathbf{C}(u) = \\sum_{i=0}^n N_{i,p}(u)\\,\\mathbf{P}_i$。Cox–de Boor 递归公式定义 $N_{i,0}(u)$ 为：如果 $U_i \\le u  U_{i+1}$ 则为 $1$，否则为 $0$；对于 $p \\ge 1$，则为 $N_{i,p}(u) = \\alpha_{i,p}(u)\\,N_{i,p-1}(u) + \\beta_{i+1,p}(u)\\,N_{i+1,p-1}(u)$，其系数为 $\\alpha_{i,p}(u) = \\dfrac{u - U_i}{U_{i+p} - U_i}$（当分母为 $0$ 时解释为 $0$）和 $\\beta_{i+1,p}(u) = \\dfrac{U_{i+p+1} - u}{U_{i+p+1} - U_{i+1}}$（当分母为 $0$ 时解释为 $0$）。de Boor 算法是 $\\mathbf{C}(u)$ 的一种数值稳定的求值方法，它与上述递归在代数上是等价的。\n2. 曲线上一点到固定点 $\\mathbf{q} \\in \\mathbb{R}^2$ 的欧几里得距离的平方是 $d^2(u) = \\|\\mathbf{C}(u) - \\mathbf{q}\\|_2^2$。在闭区间 $[U_p, U_{m-p}]$ 上最小化 $\\tfrac{1}{2} d^2(u)$ 可以得到最近点。您必须从第一性原理出发，推导 $\\tfrac{1}{2} d^2(u)$ 关于 $u$ 的一阶和二阶导数，并用 $\\mathbf{C}(u)$、$\\mathbf{C}'(u)$ 和 $\\mathbf{C}''(u)$ 来表示它们，然后在牛顿-拉夫逊迭代中使用这些导数。在没有从微分定义和链式法则进行论证的情况下，不得假定任何导数公式。\n\n您的算法设计要求如下。\n\n- 使用 de Boor 算法来计算 $\\mathbf{C}(u)$，并构造导数控制多边形以可靠地计算 $\\mathbf{C}'(u)$ 和 $\\mathbf{C}''(u)$。对于导数控制多边形，请使用经过充分检验的、关于连续控制点和节点向量的有限差分关系；不要在代码中对基函数进行符号微分。\n- 对通过对 $\\tfrac{1}{2} d^2(u)$ 求导得到的标量函数，实施一个带保护的牛顿-拉夫逊方法。您的方法必须包含以下所有数值保护措施：\n  1. 参数域投影，将迭代值保持在闭区间 $[U_p, U_{m-p}]$ 内。\n  2. 根的区间限定，通过扫描一个包含 $M$ 个采样参数的均匀网格来检测一阶导数的符号变化，然后在每个区间内执行带保护的牛顿步；当牛顿步超出该区间或曲率信息不可靠时，则回退到二分法。\n  3. 当从有希望的种子点运行无区间限定的投影牛顿精化时，采用阻尼或回溯步长策略，以防止 $\\tfrac{1}{2} d^2(u)$ 的值增加。\n  4. 通过计算求根阶段返回的所有候选驻点以及两个边界参数 $U_p$ 和 $U_{m-p}$ 处的平方距离，从中选择全局最小化子。\n\n测试与输出规范。\n\n- 使用以下测试曲线数据（所有坐标和节点均为无单位）：\n  - 次数 $p = 3$。\n  - 控制点 $\\mathbf{P}_0 = (0,0)$, $\\mathbf{P}_1 = (1,2)$, $\\mathbf{P}_2 = (3,3)$, $\\mathbf{P}_3 = (6,2)$, $\\mathbf{P}_4 = (7,0)$, $\\mathbf{P}_5 = (8,-1)$。\n  - 开放均匀节点向量 $U = [0,0,0,0,\\tfrac{1}{3},\\tfrac{2}{3},1,1,1,1]$。\n  - 因此，参数域为 $[0,1]$。\n- 使用以下外部查询点 $\\mathbf{q}$ 集合来构成您的测试套件：\n  1. $\\mathbf{q}_1 = (4,1.5)$，一个一般位置点。\n  2. $\\mathbf{q}_2 = (0,0)$，恰好在曲线的左端点。\n  3. $\\mathbf{q}_3 = (10,-2)$，在曲线右侧很远的位置。\n  4. $\\mathbf{q}_4 = (2.5,2.5)$，靠近曲线内部。\n  5. $\\mathbf{q}_5 = (6.8,-0.8)$，靠近曲线右侧部分。\n- 实现细节：\n  - 使用双精度浮点运算。\n  - 使用一个包含 $M = 200$ 个样本的均匀网格进行初始区间限定。\n  - 在牛顿-拉夫逊方法中，对一阶导数的绝对值使用 $\\varepsilon = 10^{-10}$ 的收敛容差，对区间缩小使用 $\\delta = 10^{-12}$ 的参数容差。将每个根的最大保护迭代次数限制为 $50$。\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。该列表必须为每个测试点包含一个条目，顺序相同，其中每个条目是一个双元素列表 $[u^\\star, d]$。这里 $u^\\star$ 是 $[0,1]$ 中的最小化参数，$d$ 是从外部点到曲线上最近点的欧几里得距离。两个条目都必须是浮点数。例如，输出格式应类似于 $[[u_1,d_1],[u_2,d_2],[u_3,d_3],[u_4,d_4],[u_5,d_5]]$，不含空格。", "solution": "提出的问题是，对于给定的平面B样条曲线和一组查询点，确定曲线上对应于离每个查询点最近的点 $\\mathbf{C}(u^\\star)$ 的参数 $u^\\star$。这是一个计算几何中的经典非线性优化问题。\n\n首先根据指定标准对问题进行验证。\n\n### 步骤 1：提取给定条件\n- **曲线定义**：一个次数为 $p$ 的B样条曲线定义为 $\\mathbf{C}(u) = \\sum_{i=0}^n N_{i,p}(u)\\,\\mathbf{P}_i$，参数 $u \\in [U_p, U_{m-p}]$，控制点为 $\\{\\mathbf{P}_i\\}_{i=0}^n \\subset \\mathbb{R}^2$，非递减节点向量为 $\\{U_j\\}_{j=0}^m$。关系 $m=n+p+1$ 成立。\n- **基函数**：基函数 $N_{i,p}(u)$ 由 Cox–de Boor 递归公式定义。\n- **求值**：指定使用 de Boor 算法对 $\\mathbf{C}(u)$ 进行数值稳定的求值。\n- **目标函数**：需要最小化的量是曲线上一点到固定外部点 $\\mathbf{q}$ 的欧几里得距离的平方 $d^2(u) = \\|\\mathbf{C}(u) - \\mathbf{q}\\|_2^2$，或等效地， $f(u) = \\tfrac{1}{2} d^2(u)$。\n- **导数**：必须从第一性原理推导 $f(u)$ 的一阶和二阶导数，并在牛顿-拉夫逊方法中使用它们。曲线导数 $\\mathbf{C}'(u)$ 和 $\\mathbf{C}''(u)$ 将通过导数控制多边形计算。\n- **算法**：要求采用带保护的牛顿-拉夫逊方法，包含：1) 参数域投影，2) 带回退到二分法的根的区间限定，3) 用于无区间限定精化的阻尼/回溯步长，以及 4) 从驻点和边界点中选择全局最小值。\n- **测试数据**：\n  - 次数：$p = 3$。\n  - 控制点：$\\mathbf{P}_0 = (0,0)$, $\\mathbf{P}_1 = (1,2)$, $\\mathbf{P}_2 = (3,3)$, $\\mathbf{P}_3 = (6,2)$, $\\mathbf{P}_4 = (7,0)$, $\\mathbf{P}_5 = (8,-1)$。这意味着 $n=5$。\n  - 节点向量：$U = [0,0,0,0,\\tfrac{1}{3},\\tfrac{2}{3},1,1,1,1]$。这意味着 $m=9$。关系 $m=n+p+1$ ($9=5+3+1$) 得到满足。\n  - 参数域：$[U_p, U_{m-p}] = [U_3, U_6] = [0,1]$。\n  - 查询点：$\\mathbf{q}_1 = (4,1.5)$, $\\mathbf{q}_2 = (0,0)$, $\\mathbf{q}_3 = (10,-2)$, $\\mathbf{q}_4 = (2.5,2.5)$, $\\mathbf{q}_5 = (6.8,-0.8)$。\n- **数值参数**：\n  - 网格样本数：$M = 200$。\n  - 收敛容差（导数）：$\\varepsilon = 10^{-10}$。\n  - 收敛容差（参数）：$\\delta = 10^{-12}$。\n  - 最大迭代次数：$50$。\n- **输出格式**：单行 `[[u1,d1],[u2,d2],...]`，其中 $u_k$ 是最优参数，$d_k$ 是第 $k$ 个查询点的最小距离。\n\n### 步骤 2：使用提取的给定条件进行验证\n对问题进行验证：\n- **科学基础**：该问题是数值方法和计算机辅助几何设计中一个标准的、经过充分研究的课题。所有概念（B样条、de Boor算法、牛顿法）都是基础的且陈述正确。\n- **适定性**：根据极值定理，最近点的存在性是有保证的，因为我们是在一个紧集（曲线的参数域）上最小化一个连续函数（距离）。所要求的算法是用于寻找全局最小值的稳健过程。\n- **客观性**：问题使用精确的数学和算法语言进行规定，不含任何主观性。\n- **完整性与一致性**：所有必要的数据，包括曲线定义、查询点以及算法的数值参数，都已提供。B样条的关系 $m=n+p+1$ 得到满足。数据是自洽的。\n- **可行性**：指定算法的实现虽然复杂，但在给定环境（带 NumPy 的 Python）下是完全可行的。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。它具有科学依据、适定性、客观性、完整性、一致性和可行性。我现在将提供一个完整的解决方案。\n\n### 基于原理的解决方案\n问题的核心是找到参数 $u^\\star$，该参数使得B样条曲线上的一点 $\\mathbf{C}(u)$ 与给定的外部点 $\\mathbf{q}$ 之间的距离最小。这等效于最小化距离平方函数，这样做在计算上更方便，因为它避免了平方根运算。\n设目标函数为 $f(u)$：\n$$f(u) = \\frac{1}{2} \\|\\mathbf{C}(u) - \\mathbf{q}\\|_2^2 = \\frac{1}{2} (\\mathbf{C}(u) - \\mathbf{q}) \\cdot (\\mathbf{C}(u) - \\mathbf{q})$$\n最小化是在有效的参数域 $u \\in [U_p, U_{m-p}]$ 上进行的。在域的内部点上取得局部最小值的必要条件是目标函数的一阶导数为零。\n\n**1. 目标函数的导数**\n我们使用链式法则和向量值函数的乘积法则来推导所需的 $f(u)$ 的导数。令 $\\mathbf{r}(u) = \\mathbf{C}(u) - \\mathbf{q}$。则 $f(u) = \\frac{1}{2} \\mathbf{r}(u) \\cdot \\mathbf{r}(u)$。\n\n一阶导数 $f'(u)$ 是：\n$$f'(u) = \\frac{d}{du} \\left( \\frac{1}{2} \\mathbf{r}(u) \\cdot \\mathbf{r}(u) \\right) = \\mathbf{r}'(u) \\cdot \\mathbf{r}(u)$$\n由于 $\\mathbf{r}'(u) = \\mathbf{C}'(u) - \\frac{d\\mathbf{q}}{du} = \\mathbf{C}'(u)$（因为 $\\mathbf{q}$ 是一个常数点），我们有：\n$$f'(u) = \\mathbf{C}'(u) \\cdot (\\mathbf{C}(u) - \\mathbf{q})$$\n$f(u)$ 的驻点是标量方程 $f'(u) = 0$ 的根。这个条件有一个清晰的几何解释：从查询点到曲线上最近点的向量 $\\mathbf{C}(u) - \\mathbf{q}$，必须与曲线的切向量 $\\mathbf{C}'(u)$ 正交。\n\n二阶导数 $f''(u)$ 通过对 $f'(u)$ 关于 $u$ 使用乘积法则求导得出：\n$$f''(u) = \\frac{d}{du} \\left( \\mathbf{C}'(u) \\cdot (\\mathbf{C}(u) - \\mathbf{q}) \\right) = \\mathbf{C}''(u) \\cdot (\\mathbf{C}(u) - \\mathbf{q}) + \\mathbf{C}'(u) \\cdot \\mathbf{C}'(u)$$\n$$f''(u) = \\mathbf{C}''(u) \\cdot (\\mathbf{C}(u) - \\mathbf{q}) + \\|\\mathbf{C}'(u)\\|_2^2$$\n这两个导数 $f'(u)$ 和 $f''(u)$ 构成了牛顿-拉夫逊方法的基础，用于寻找 $f'(u)$ 的根。迭代公式为 $u_{k+1} = u_k - \\frac{f'(u_k)}{f''(u_k)}$。\n\n**2. B样条曲线及其导数求值**\n为了计算 $f'(u)$ 和 $f''(u)$，我们需要 $\\mathbf{C}(u)$、$\\mathbf{C}'(u)$ 和 $\\mathbf{C}''(u)$。根据规定，这些需要通过数值方法计算。\n$\\mathbf{C}(u)$ 使用 de Boor 算法计算，这是一个作用于包含 $u$ 的节点区间内控制点的数值稳定的递推关系。\nB样条曲线的导数本身是次数更低的B样条曲线。一个次数为 $p$、控制点为 $\\{\\mathbf{P}_i\\}_{i=0}^n$、节点向量为 $\\{U_j\\}_{j=0}^m$ 的B样条曲线 $\\mathbf{C}(u)$，其导数 $\\mathbf{C}'(u)$ 是一个次数为 $p-1$ 的B样条曲线。它的控制点 $\\{\\mathbf{P}'_i\\}_{i=0}^{n-1}$ 和节点向量 $\\{U'_j\\}_{j=0}^{m-2}$ 由原曲线导出。控制点由下式给出：\n$$\\mathbf{P}'_i = p \\frac{\\mathbf{P}_{i+1} - \\mathbf{P}_i}{U_{i+p+1} - U_{i+1}} \\quad \\text{for } i \\in [0, n-1]$$\n$\\mathbf{C}'(u)$ 的节点向量是 $\\{U_j\\}_{j=1}^{m-1}$。然后通过对这个新定义的曲线应用 de Boor 算法来计算 $\\mathbf{C}'(u)$。二阶导数 $\\mathbf{C}''(u)$ 通过对 $\\mathbf{C}'(u)$ 应用相同的过程得到。这将产生一个次数为 $p-2$ 的B样条，其控制点 $\\{\\mathbf{P}''_i\\}$ 和节点可以类似地导出。\n\n**3. 数值最小化算法**\n$f(u)$ 在紧区间 $[U_p, U_{m-p}]$ 上的全局最小值必然出现在边界点（$U_p$ 或 $U_{m-p}$）或 $f'(u)=0$ 的内部点上。该算法系统地找出所有这些候选点，并选择产生最小距离的一个。\n\n**阶段 1：区间限定与带保护的求根**\n为确保找到 $f'(u)$ 的所有根，首先扫描域 $[U_p, U_{m-p}]$。\n1. 创建一个包含 $M=200$ 个参数值 $\\{u_j\\}_{j=0}^{M-1}$ 的均匀网格。\n2. 为每个网格点计算 $f'(u_j)$。\n3. 任何 $f'(u_j)$ 和 $f'(u_{j+1})$ 符号相反的区间 $[u_j, u_{j+1}]$ 必然包含至少一个根。这些区间成为求根算法的限定区间。\n4. 对每个区间，采用带保护的牛顿-拉夫逊方法。从一个初始猜测（例如，区间的中点）开始，计算标准的牛顿步 $u_{k+1} = u_k - f'(u_k)/f''(u_k)$。\n    - **保护措施**：如果新的估计值 $u_{k+1}$ 落在了区间之外，或者如果 $|f''(u_k)|$ 接近于零（表示步长不可靠），该方法回退到二分法步骤，$u_{k+1} = (a+b)/2$，其中 $[a, b]$ 是当前的限定区间。\n    - 根据 $f'(u_{k+1})$ 的符号更新区间。迭代过程持续进行，直到区间的宽度小于容差 $\\delta=10^{-12}$ 或 $|f'(u_k)|$ 小于容差 $\\varepsilon=10^{-10}$。将得到的根添加到一个候选参数集合中。\n\n**阶段 2：从有希望的种子点进行无区间限定的精化**\n如果 $f'(u)$ 触及零点但未穿越（即偶数重根），或者两个根非常接近，则区间限定阶段可能会漏掉根。为了找到额外的候选点，我们在网格上搜索距离本身的局部最小值。\n1. 为每个网格点 $u_j$ 计算平方距离 $d^2(u_j)$。\n2. 将网格上的局部最小值点 $u_j$（即 $d^2(u_{j-1})  d^2(u_j)  d^2(u_{j+1})$）识别为“有希望的种子点”。\n3. 从每个种子点开始，启动一个投影的、带阻尼的牛顿法，以精化局部最小值的估计。\n    - **投影**：每一步之后，将新的参数值限制在有效域 $[U_p, U_{m-p}]$ 内。\n    - **阻尼/回溯**：牛顿步旨在找到 $f'(u)$ 的根，而不一定是减小 $f(u)$。为确保取得进展，使用回溯线搜索。只有当步长能减小目标函数 $f(u)$ 时，才采用完整的步长。如果不能，则连续将步长减半，直到实现减小或步长变得太小。\n    这个精化过程会产生额外的候选参数。\n\n**阶段 3：全局最小值选择**\n最终的候选集包括：\n- 域的边界参数，$U_p$ 和 $U_{m-p}$。\n- 所有通过带保护的、限定区间的求根器找到的根。\n- 所有通过无区间限定搜索得到的精化局部最小值。\n\n去除重复项后，对该集合中的每个候选参数 $u$ 计算目标函数 $f(u)$。产生 $f(u)$ 最小值的参数 $u^\\star$ 就是全局最优参数。最终的最近距离是 $d = \\sqrt{2f(u^\\star)} = \\|\\mathbf{C}(u^\\star) - \\mathbf{q}\\|_2$。这个全面的搜索策略是稳健的，旨在找到真正的全局最小值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_span(n, p, u, U):\n    \"\"\"\n    Determine the knot span index.\n    n: number of control points - 1\n    p: degree\n    u: parameter\n    U: knot vector\n    \"\"\"\n    # For open knot vectors, the end of the domain needs special handling.\n    if u = U[n + 1]:\n        return n\n    \n    low = p\n    high = n + 1\n    mid = (low + high) // 2\n    \n    while u  U[mid] or u = U[mid + 1]:\n        if u  U[mid]:\n            high = mid\n        else:\n            low = mid\n        mid = (low + high) // 2\n    return mid\n\ndef de_boor(p, U, P, u):\n    \"\"\"\n    Evaluate curve point and derivatives using de Boor's algorithm.\n    p: degree\n    U: knot vector\n    P: control points\n    u: parameter\n    Returns: C(u), C'(u), C''(u)\n    \"\"\"\n    n = len(P) - 1\n    \n    # --- C(u) ---\n    span = find_span(n, p, u, U)\n    pts = P[span - p : span + 1].copy()\n    for r in range(1, p + 1):\n        for j in range(p, r - 1, -1):\n            alpha = (u - U[span - p + j]) / (U[span - p + j + p - r + 1] - U[span - p + j])\n            pts[j] = (1.0 - alpha) * pts[j - 1] + alpha * pts[j]\n    C = pts[p]\n\n    # --- C'(u) ---\n    C_prime = np.zeros_like(C)\n    if p  0:\n        P_prime = []\n        for i in range(n):\n            denom = U[i + p + 1] - U[i + 1]\n            if denom  1e-12:\n                P_prime.append(p * (P[i + 1] - P[i]) / denom)\n            else:\n                P_prime.append(np.zeros_like(P[0]))\n        \n        P_prime = np.array(P_prime)\n        U_prime = U[1:-1]\n        \n        span_prime = find_span(len(P_prime) - 1, p - 1, u, U_prime)\n        pts_prime = P_prime[span_prime - (p - 1) : span_prime + 1].copy()\n\n        for r in range(1, p):\n            for j in range(p - 1, r - 1, -1):\n                alpha = (u - U_prime[span_prime - (p - 1) + j]) / (U_prime[span_prime - (p - 1) + j + (p - 1) - r + 1] - U_prime[span_prime - (p - 1) + j])\n                pts_prime[j] = (1.0 - alpha) * pts_prime[j - 1] + alpha * pts_prime[j]\n        C_prime = pts_prime[p - 1]\n\n    # --- C''(u) ---\n    C_prime2 = np.zeros_like(C)\n    if p  1:\n        P_prime2 = []\n        n_prime = len(P_prime) - 1\n        p_prime = p - 1\n        for i in range(n_prime):\n            denom = U_prime[i + p_prime + 1] - U_prime[i + 1]\n            if denom  1e-12:\n                P_prime2.append(p_prime * (P_prime[i + 1] - P_prime[i]) / denom)\n            else:\n                P_prime2.append(np.zeros_like(P[0]))\n        \n        P_prime2 = np.array(P_prime2)\n        U_prime2 = U_prime[1:-1]\n        \n        span_prime2 = find_span(len(P_prime2) - 1, p - 2, u, U_prime2)\n        pts_prime2 = P_prime2[span_prime2 - (p - 2) : span_prime2 + 1].copy()\n        for r in range(1, p-1):\n            for j in range(p - 2, r - 1, -1):\n                alpha = (u - U_prime2[span_prime2 - (p - 2) + j]) / (U_prime2[span_prime2 - (p - 2) + j + (p - 2) - r + 1] - U_prime2[span_prime2 - (p - 2) + j])\n                pts_prime2[j] = (1.0 - alpha) * pts_prime2[j - 1] + alpha * pts_prime2[j]\n\n        C_prime2 = pts_prime2[p - 2]\n\n    return C, C_prime, C_prime2\n\ndef find_closest_point(p, U, P, q, M, epsilon, delta, max_iter):\n    u_min, u_max = U[p], U[len(P)]\n\n    memo = {}\n    def get_ders(u):\n        u_rounded = round(u, 15) # Mitigate floating point re-computation issues\n        if u_rounded not in memo:\n            memo[u_rounded] = de_boor(p, U, P, u)\n        return memo[u_rounded]\n\n    def obj_fun_prime(u):\n        C, C_prime, _ = get_ders(u)\n        return np.dot(C_prime, C - q)\n    \n    def obj_fun_second(u):\n        C, C_prime, C_prime2 = get_ders(u)\n        return np.dot(C_prime2, C - q) + np.dot(C_prime, C_prime)\n\n    candidates = {u_min, u_max}\n\n    # Stage 1: Bracketing and Safeguarded Root-Finding\n    grid = np.linspace(u_min, u_max, M)\n    grid_vals = np.array([obj_fun_prime(u) for u in grid])\n    \n    for i in range(M - 1):\n        if np.sign(grid_vals[i]) != np.sign(grid_vals[i+1]):\n            a, b = grid[i], grid[i+1]\n            u_k = (a + b) / 2.0\n            for _ in range(max_iter):\n                if b - a  delta: break\n                \n                f_prime = obj_fun_prime(u_k)\n                if abs(f_prime)  epsilon: break\n\n                f_second = obj_fun_second(u_k)\n                if abs(f_second)  1e-9:\n                    u_next = u_k - f_prime / f_second\n                    if u_next  a and u_next  b:\n                        u_k = u_next\n                    else:\n                        u_k = (a + b) / 2.0\n                else: # Unreliable curvature, revert to bisection\n                    u_k = (a + b) / 2.0\n                \n                f_prime_next = obj_fun_prime(u_k)\n                if np.sign(f_prime_next) == np.sign(obj_fun_prime(a)):\n                    a = u_k\n                else:\n                    b = u_k\n            \n            candidates.add(np.clip(u_k, u_min, u_max))\n\n    # Stage 2: Unbracketed Refinement\n    dist_sq_grid = [np.sum((de_boor(p, U, P, u)[0] - q)**2) for u in grid]\n    for i in range(1, M - 1):\n        if dist_sq_grid[i-1]  dist_sq_grid[i] and dist_sq_grid[i]  dist_sq_grid[i+1]:\n            u_k = grid[i]\n            for _ in range(max_iter):\n                f_prime = obj_fun_prime(u_k)\n                if abs(f_prime)  epsilon: break\n                \n                f_second = obj_fun_second(u_k)\n                if abs(f_second)  1e-9:\n                    step = -f_prime/f_second\n                    alpha = 1.0\n                    current_dist_sq = np.sum((de_boor(p, U, P, u_k)[0] - q)**2)\n                    \n                    for _ in range(5): # Backtracking\n                        u_next = np.clip(u_k + alpha * step, u_min, u_max)\n                        next_dist_sq = np.sum((de_boor(p, U, P, u_next)[0] - q)**2)\n                        if next_dist_sq  current_dist_sq:\n                            break\n                        alpha /= 2.0\n                    else:\n                        alpha = 0.1\n                        u_next = np.clip(u_k - alpha * f_prime, u_min, u_max)\n                    \n                    if abs(u_next - u_k)  delta: break\n                    u_k = u_next\n                else:\n                    u_k = np.clip(u_k - 0.01 * f_prime, u_min, u_max)\n            candidates.add(u_k)\n\n    # Stage 3: Global Minimum Selection\n    best_u = -1\n    min_dist_sq = float('inf')\n    \n    for u in candidates:\n        C = de_boor(p, U, P, u)[0]\n        dist_sq = np.sum((C - q)**2)\n        if dist_sq  min_dist_sq:\n            min_dist_sq = dist_sq\n            best_u = u\n            \n    return [best_u, np.sqrt(min_dist_sq)]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the solver.\n    \"\"\"\n    # Test curve data\n    p = 3\n    P = np.array([\n        [0.0, 0.0], [1.0, 2.0], [3.0, 3.0], \n        [6.0, 2.0], [7.0, 0.0], [8.0, -1.0]\n    ])\n    U = np.array([0.0, 0.0, 0.0, 0.0, 1/3, 2/3, 1.0, 1.0, 1.0, 1.0])\n\n    # External query points\n    queries = [\n        np.array([4.0, 1.5]),\n        np.array([0.0, 0.0]),\n        np.array([10.0, -2.0]),\n        np.array([2.5, 2.5]),\n        np.array([6.8, -0.8]),\n    ]\n\n    # Numerical parameters\n    M = 200\n    epsilon = 1e-10\n    delta = 1e-12\n    max_iter = 50\n\n    results = []\n    for q in queries:\n        u_star, dist = find_closest_point(p, U, P, q, M, epsilon, delta, max_iter)\n        results.append(f\"[{u_star},{dist}]\")\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3207471"}]}