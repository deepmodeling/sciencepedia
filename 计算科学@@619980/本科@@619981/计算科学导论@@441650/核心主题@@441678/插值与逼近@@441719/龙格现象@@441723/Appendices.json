{"hands_on_practices": [{"introduction": "多项式插值的稳定性与插值节点的属性密切相关。重心插值公式是数值计算中一种稳定且高效的计算方法，其性质与一组称为重心权重 ($w_j$) 的系数紧密相连。本练习将通过分析均匀分布节点下的重心权重，揭示龙格现象的内在原因。通过计算并比较区间中心点和端点处的权重大小，你将直观地理解为何误差在区间边缘容易被放大 [@problem_id:2199710]。", "problem": "在多项式插值的研究中，插值点（节点）的选择会显著影响所得多项式的准确性和稳定性。重心插值公式提供了一种数值稳定的方法来计算插值多项式，其性质与称为重心权的量密切相关。\n\n考虑在区间 $[-1, 1]$ 上的 $n+1$ 个均匀分布的插值节点 $x_j$，其中 $j=0, 1, \\ldots, n$。节点由公式 $x_j = -1 + j \\cdot h$ 给出，其中步长为 $h = \\frac{2}{n}$。\n\n节点 $x_j$ 的重心权 $w_j$ 定义为：\n$$\nw_j = \\left(\\prod_{k=0, k \\neq j}^{n} (x_j - x_k)\\right)^{-1}\n$$\n\n对于 $n=10$ 的特定情况（此时有 11 个插值节点），确定比值 $\\frac{|w_{10}|}{|w_5|}$ 的精确值。这个比值比较了区间右端点（$x_{10}=1$）的重心权大小与区间中心点（$x_5=0$）的重心权大小。\n\n将最终答案表示为最简分数。", "solution": "我们有均匀间隔的节点 $x_{j}=-1+jh$，其中 $h=\\frac{2}{n}$ 且 $j=0,1,\\ldots,n$。重心权为\n$$\nw_{j}=\\left(\\prod_{k=0,\\,k\\neq j}^{n}(x_{j}-x_{k})\\right)^{-1}.\n$$\n对于均匀间隔，\n$$\nx_{j}-x_{k}=(-1+jh)-(-1+kh)=(j-k)h,\n$$\n所以对 $n$ 项（不包括 $k=j$）的乘积可以分解为\n$$\n\\prod_{k=0,\\,k\\neq j}^{n}(x_{j}-x_{k})=h^{n}\\prod_{k=0,\\,k\\neq j}^{n}(j-k).\n$$\n因此\n$$\nw_{j}=h^{-n}\\left(\\prod_{k=0,\\,k\\neq j}^{n}(j-k)\\right)^{-1}.\n$$\n通过在 $j$ 处分割来计算整数乘积：\n$$\n\\prod_{k=0,\\,k\\neq j}^{n}(j-k)=\\left(\\prod_{k=0}^{j-1}(j-k)\\right)\\left(\\prod_{k=j+1}^{n}(j-k)\\right)\n=j!\\cdot\\left[\\prod_{m=1}^{n-j}(-m)\\right]=(-1)^{n-j}j!(n-j)!.\n$$\n因此，取绝对值，\n$$\n|w_{j}|=h^{-n}\\left|(-1)^{n-j}j!(n-j)!\\right|^{-1}=h^{-n}\\frac{1}{j!(n-j)!}.\n$$\n对于 $n=10$，我们得到\n$$\n\\frac{|w_{10}|}{|w_{5}|}=\\frac{h^{-10}/\\left(10!\\cdot 0!\\right)}{h^{-10}/\\left(5!\\cdot 5!\\right)}=\\frac{(5!)^{2}}{10!\\cdot 0!}=\\frac{(5!)^{2}}{10!}.\n$$\n使用 $10!=10\\cdot 9\\cdot 8\\cdot 7\\cdot 6\\cdot 5!$ 和 $5!=120$ 进行化简：\n$$\n\\frac{(5!)^{2}}{10!}=\\frac{5!}{10\\cdot 9\\cdot 8\\cdot 7\\cdot 6}=\\frac{120}{30240}=\\frac{1}{252}.\n$$\n因此，精确比值为 $\\frac{1}{252}$。", "answer": "$$\\boxed{\\frac{1}{252}}$$", "id": "2199710"}, {"introduction": "在理论上理解了均匀节点可能引发不稳定性之后，本练习提供了一个直接的数值比较。我们将使用一个光滑的钟形函数 $f(x) = \\exp(-5x^2)$，并为你提供基于均匀节点和切比雪夫节点预先计算好的插值多项式。你的任务是计算并比较这两种方法在区间端点附近的近似误差。这个实践将具体地展示，即使在阶数不高的情况下，切比雪夫节点在抑制端点误差方面也表现出优越性 [@problem_id:2199744]。", "problem": "考虑在区间 $[-1, 1]$ 上的函数 $f(x) = \\exp(-5x^2)$。为了近似该函数，构造了两个不同的 4 次多项式。\n\n第一个多项式 $P_U(x)$ 是通过在区间 $[-1, 1]$ 上的五个均匀间隔的节点上对 $f(x)$ 进行插值得到的。得到的多项式为：\n$$P_U(x) = 2.481 x^4 - 3.474 x^2 + 1$$\n\n第二个多项式 $P_C(x)$ 是通过在区间 $[-1, 1]$ 上的五个切比雪夫节点上对 $f(x)$ 进行插值得到的。得到的多项式为：\n$$P_C(x) = 2.302 x^4 - 3.175 x^2 + 1$$\n\n这些近似在点 $x$ 处的绝对误差定义为 $E_U(x) = |P_U(x) - f(x)|$ 和 $E_C(x) = |P_C(x) - f(x)|$。\n\n您的任务是计算在特定点 $x = 0.9$ 处这些误差的比率 $R = \\frac{E_U(0.9)}{E_C(0.9)}$。报告您的最终答案，四舍五入到三位有效数字。", "solution": "给定 $f(x)=\\exp(-5x^{2})$，$P_{U}(x)=2.481x^{4}-3.474x^{2}+1$ 和 $P_{C}(x)=2.302x^{4}-3.175x^{2}+1$。在 $x=0.9$ 处，计算必要的幂次：\n$$x^{2}=(0.9)^{2}=0.81,\\quad x^{4}=(0.81)^{2}=0.6561.$$\n\n在 $x=0.9$ 处计算多项式的值：\n$$P_{U}(0.9)=2.481\\cdot 0.6561-3.474\\cdot 0.81+1=1.6277841-2.81394+1=-0.1861559,$$\n$$P_{C}(0.9)=2.302\\cdot 0.6561-3.175\\cdot 0.81+1=1.5103422-2.57175+1=-0.0614078.$$\n\n在 $x=0.9$ 处计算函数的值：\n$$f(0.9)=\\exp\\!\\big(-5\\cdot 0.81\\big)=\\exp(-4.05)\\approx 0.0174223746396112.$$\n\n计算绝对误差：\n$$E_{U}(0.9)=|P_{U}(0.9)-f(0.9)|=|-0.1861559-0.0174223746396112|=0.2035782746396112,$$\n$$E_{C}(0.9)=|P_{C}(0.9)-f(0.9)|=|-0.0614078-0.0174223746396112|=0.0788301746396112.$$\n\n计算比率：\n$$R=\\frac{E_{U}(0.9)}{E_{C}(0.9)}=\\frac{0.2035782746396112}{0.0788301746396112}\\approx 2.58249.$$\n\n四舍五入到三位有效数字：\n$$R\\approx 2.58.$$", "answer": "$$\\boxed{2.58}$$", "id": "2199744"}, {"introduction": "最后的这个实践将引导你从简单的计算转向一个完整的计算实验。你将亲手为经典的龙格函数 $f(x) = \\frac{1}{1+25x^2}$ 实现多项式插值，并比较均匀节点与切比雪夫-洛巴托节点的效果。更重要的是，你将学习如何量化这一现象，不仅测量最大误差，还特别关注端点误差和振荡程度，从而掌握一套分析和验证插值方法的有力工具 [@problem_id:3212557]。", "problem": "您需要研究函数 $f(x)=\\dfrac{1}{1+25x^2}$ 在区间 $[-1,1]$ 上的多项式插值所出现的 Runge 现象，方法是比较两种节点选择：等距节点和 Chebyshev–Lobatto 节点。您的实现必须是一个完整、可运行的程序，该程序能进行数值计算，并报告量化指标，以便清晰地比较这两种节点选择。所有角度都必须以弧度为单位进行解释。\n\n只能使用基本定义和经过充分检验的事实作为您的出发点：\n- 插值问题是：给定 $[-1,1]$ 区间内的节点 $\\{x_j\\}_{j=0}^n$ 和数据值 $y_j=f(x_j)$，构造一个次数至多为 $n$ 的唯一多项式 $p_n$，使得对所有 $j$ 都满足 $p_n(x_j)=y_j$。\n- 第一类 Chebyshev 多项式 $\\{T_k\\}_{k\\ge 0}$ 定义为 $T_k(\\cos\\theta)=\\cos(k\\theta)$，其中 $\\theta\\in\\mathbb{R}$。Chebyshev–Lobatto 节点是 $T_n$ 的极值点，即 $x_k=\\cos\\left(\\dfrac{k\\pi}{n}\\right)$，其中 $k=0,1,\\dots,n$，且 $\\pi$ 以弧度计量。\n- Runge 现象指的是，当在 $[-1,1]$ 区间上使用等距节点对解析函数进行高次多项式插值时，可能在端点处出现的大幅振荡。\n\n您的任务是：\n1. 对于每种节点族和每个次数 $n$，构造插值多项式 $p_n$，且不使用任何预先存在的黑盒插值例程。您可以使用任何与多项式插值定义一致、在数学上等价且数值稳定的公式（例如，Lagrange 插值的重心坐标实现，或由均差构造的 Newton 形式）。请确保数值稳定性。\n2. 通过在 $[-1,1]$ 区间的一个包含 $M$ 个点的均匀网格上对 $p_n$ 和 $f$ 进行采样，来近似计算 $[-1,1]$ 上的一致误差 $\\lVert f-p_n\\rVert_{\\infty}$。使用 $M=20001$。\n3. 使用以下两个度量来量化端点窗口并集 $[-1,-1+w]\\cup[1-w,1]$（其中 $w=0.1$）上的端点行为：\n   - 端点误差振幅 $E_{\\mathrm{end}}=\\max_{x\\in[-1,-1+w]\\cup[1-w,1]} |f(x)-p_n(x)|$。\n   - 端点振荡计数，定义为在限制于 $[-1,-1+w]\\cup[1-w,1]$ 的采样网格上，$p_n$ 离散导数的严格符号变化次数。通过均匀网格上的中心有限差分计算导数，并通过将绝对值 $\\le \\tau$（其中 $\\tau=10^{-8}$）的值声明为零来对小量值设置阈值。每当两个连续的非零导数样本符号相反时，计为一个严格符号变化。零值应被忽略（不计算涉及零的转换；在确定变化时，通过沿用最后一个非零符号来压缩连续的零）。\n4. 对于每个 $n$，使用上述指标比较等距节点和 Chebyshev–Lobatto 节点。\n\n测试套件和参数：\n- 使用次数 $n\\in\\{5,10,20\\}$。\n- 对于每个 $n$，使用两种节点族：\n  - 等距节点：$x_j=-1+\\dfrac{2j}{n}$，其中 $j=0,1,\\dots,n$。\n  - Chebyshev–Lobatto 节点：$x_k=\\cos\\left(\\dfrac{k\\pi}{n}\\right)$，其中 $k=0,1,\\dots,n$，且 $\\pi$ 以弧度为单位。\n\n每个次数 $n$ 的必需输出：\n- 对于等距节点：按此顺序的三个值 $(\\lVert f-p_n\\rVert_{\\infty},\\ E_{\\mathrm{end}},\\ \\text{振荡计数})$。\n- 对于 Chebyshev–Lobatto 节点：按此顺序的三个值 $(\\lVert f-p_n\\rVert_{\\infty},\\ E_{\\mathrm{end}},\\ \\text{振荡计数})$。\n- 因此，对于每个 $n$，报告六个值。对于所有三个 $n$ 值，总共报告 18 个值。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含所有 18 个结果，形式为用方括号括起来的逗号分隔列表，按 $n=5$、然后 $n=10$、然后 $n=20$ 的顺序排列，在每个 $n$ 内部，先是等距节点的三元组，然后是 Chebyshev–Lobatto 节点的三元组。例如，您的输出应类似于\n  $[a_1,a_2,a_3,a_4,a_5,a_6,\\ a_7,a_8,a_9,a_{10},a_{11},a_{12},\\ a_{13},a_{14},a_{15},a_{16},a_{17},a_{18}]$,\n  其中所有 $a_i$ 都是按指定顺序排列的数字。\n- 将所有浮点输出四舍五入到 8 位小数；振荡计数必须是整数。\n\n角度单位说明：\n- 无论在何处使用余弦函数定义节点，其参数都必须以弧度为单位。\n\n您的程序必须是完全自包含的，不需要用户输入，并且仅依赖 Python 标准库和指定的数值库。唯一允许的数值库是标准的数值数组库。在给定规格下，输出必须是可复现的。", "solution": "我们从多项式插值的定义开始。对于节点 $\\{x_j\\}_{j=0}^n\\subset[-1,1]$ 和值 $y_j=f(x_j)$，存在一个唯一的次数不超过 $n$ 的多项式 $p_n\\in\\mathbb{P}_n$，使得对所有 $j$ 都有 $p_n(x_j)=y_j$。任何与此定义一致的表示形式都是可接受的。从数值方法的角度来看，一种稳健的方法是使用重心 Lagrange 公式，它能得到相同的插值多项式，但与朴素的 Lagrange 公式相比，其数值稳定性更好。\n\n使用的基本事实：\n1. 插值误差恒等式：对于 $f\\in C^{n+1}([-1,1])$，点态误差可以表示为\n   $$ f(x)-p_n(x)=\\frac{f^{(n+1)}(\\xi_x)}{(n+1)!}\\prod_{j=0}^n (x-x_j), $$\n   其中 $\\xi_x\\in(-1,1)$ 是某个依赖于 $x$ 的值。该恒等式表明，节点布局 $\\{x_j\\}$ 决定了因子 $\\prod_{j=0}^n(x-x_j)$ 的形态，从而决定了误差的大小和分布。\n2. 第一类 Chebyshev 多项式 $\\{T_k\\}$ 满足 $T_k(\\cos\\theta)=\\cos(k\\theta)$，其中 $\\theta\\in\\mathbb{R}$。$T_n$ 的极值点出现在 $x_k=\\cos\\left(\\frac{k\\pi}{n}\\right)$，$k=0,\\dots,n$，这些点即为 Chebyshev–Lobatto 节点。这些节点在端点附近聚集，并且已知相对于等距节点，它们能抑制 $[-1,1]$ 上 $\\prod_{j=0}^n(x-x_j)$ 的大小。\n3. 对于等距节点，随着 $n$ 的增长，Runge 现象会显著出现，即使对于解析函数 $f$，也会放大端点附近的振荡。Chebyshev–Lobatto 节点通过按照映射 $x=\\cos\\theta$（其中 $\\theta$ 均匀分布）所导出的密度来分布节点，从而缓解了这一问题。\n\n算法设计：\n- 函数与网格：\n  - 在 $[-1,1]$ 上定义 $f(x)=\\dfrac{1}{1+25x^2}$。\n  - 使用一个包含 $M=20001$ 个点、覆盖 $[-1,1]$ 的均匀网格 $\\{x^{\\mathrm{eval}}_i\\}_{i=0}^{M-1}$，通过采样来近似 $\\lVert f-p_n\\rVert_{\\infty}$。\n- 节点生成：\n  - 等距节点：$x_j=-1+\\dfrac{2j}{n}$，其中 $j=0,\\dots,n$。\n  - Chebyshev–Lobatto 节点：$x_k=\\cos\\left(\\dfrac{k\\pi}{n}\\right)$，其中 $k=0,\\dots,n$，且 $\\pi$ 以弧度为单位。\n- 插值构造：\n  - 使用重心 Lagrange 插值多项式（它在数学上等价于唯一的插值多项式），其权重为 $w_j=\\left(\\prod_{m\\ne j}(x_j-x_m)\\right)^{-1}$。用一个公共的非零因子缩放所有 $w_j$ 不会改变插值多项式，这可用于归一化权重以提高数值稳定性。\n  - 对于在点 $x$ 处的求值，第一重心公式的表达式为\n    $$ p_n(x)=\\frac{\\sum_{j=0}^n \\dfrac{w_j}{x-x_j} y_j}{\\sum_{j=0}^n \\dfrac{w_j}{x-x_j}}, $$\n    按照惯例，如果 $x=x_j$（在数值容差范围内），则精确地令 $p_n(x)=y_j$，以强制执行插值条件并避免除以零。\n  - 为了效率，对整个网格 $\\{x^{\\mathrm{eval}}_i\\}$ 上的求值进行向量化操作。\n- 误差指标：\n  - 计算采样误差 $e_i=|f(x^{\\mathrm{eval}}_i)-p_n(x^{\\mathrm{eval}}_i)|$，并通过 $\\max_i e_i$ 来近似 $\\lVert f-p_n\\rVert_{\\infty}$。\n  - 将宽度为 $w=0.1$ 的端点窗口定义为 $[-1,-1+w]\\cup[1-w,1]$，即 $[-1,-0.9]\\cup[0.9,1]$，并计算 $E_{\\mathrm{end}}=\\max\\{e_i: x^{\\mathrm{eval}}_i\\in[-1,-0.9]\\cup[0.9,1]\\}$。\n- 振荡指标：\n  - 通过中心有限差分在网格上近似 $p_n$ 的导数，即，在均匀网格上使用带边界处理的标准二阶精度离散导数。\n  - 使用 $\\tau=10^{-8}$ 对小的导数量值设置阈值：将绝对值 $\\le \\tau$ 的值映射为 $0$，其他值保持不变。在应用此阈值处理后，定义符号序列 $s_i=\\mathrm{sign}(p_n'(x^{\\mathrm{eval}}_i))$。\n  - 将范围限制在端点窗口并集内的索引。通过将序列压缩为其非零元素来移除零值，并计数严格符号变化：即连续两个非零符号不同（即它们的乘积为负）的索引数量。这就得出了端点区域的整数振荡计数。\n- 测试套件：\n  - 次数 $n\\in\\{5,10,20\\}$。对于每个 $n$，先为等距节点计算三元组 $(\\lVert f-p_n\\rVert_{\\infty}, E_{\\mathrm{end}}, \\text{振荡计数})$，然后为 Chebyshev–Lobatto 节点计算。\n- 输出格式化：\n  - 对于每个 $n$，将等距节点的三元组与 Chebyshev–Lobatto 节点的三元组连接起来，每个 $n$ 产生 6 个值。当 $n=5,10,20$ 按顺序处理时，总共产生 18 个值。\n  - 将所有浮点输出四舍五入到 8 位小数；振荡计数保持为整数。\n  - 以方括号括起来的逗号分隔列表形式打印单行。\n\n为何这能揭示 Runge 现象：\n- 根据误差恒等式，随着 $n$ 的增长，等距节点无法控制 $\\max_{x\\in[-1,1]}\\left|\\prod_{j=0}^n(x-x_j)\\right|$，即使对于解析函数 $f$ 也会导致大的端点振荡。而源于 $T_n$ 极值点的 Chebyshev–Lobatto 节点，在缩放因子范围内有效地最小化了节点多项式的上确界范数，使误差分布更均匀，并抑制了端点处的“爆炸”现象。全局上确界范数误差和端点误差振幅直接量化了这些效应。振荡计数则检测了 $p_n$ 在端点附近出现的、而在 $f$（在每个端点窗口上是单调的）中并不存在的伪振荡行为，从而提供了一种补充性的定性评估。相对于等距节点，Chebyshev–Lobatto 节点的这种伪振荡行为会减少。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef f(x):\n    return 1.0 / (1.0 + 25.0 * x * x)\n\ndef equispaced_nodes(n):\n    # n: degree, so n+1 nodes including endpoints\n    j = np.arange(n + 1, dtype=float)\n    return -1.0 + 2.0 * j / n\n\ndef chebyshev_lobatto_nodes(n):\n    # x_k = cos(k*pi/n), k=0..n, with radians\n    k = np.arange(n + 1, dtype=float)\n    return np.cos(np.pi * k / n)\n\ndef barycentric_weights(x):\n    # Compute first-form barycentric weights: w_j = 1 / prod_{k!=j} (x_j - x_k)\n    # Normalize to avoid overflow/underflow; overall scaling cancels in formula.\n    x = np.asarray(x, dtype=float)\n    m = x.size\n    w = np.empty(m, dtype=float)\n    for j in range(m):\n        diffs = x[j] - np.delete(x, j)\n        w[j] = 1.0 / np.prod(diffs)\n    # Normalize weights to unit max absolute value\n    maxabs = np.max(np.abs(w))\n    if maxabs == 0.0 or not np.isfinite(maxabs):\n        return w\n    return w / maxabs\n\ndef barycentric_interpolate(x_nodes, y_nodes, w, x_eval, atol=1e-14):\n    # Vectorized first-form barycentric interpolation\n    x_nodes = np.asarray(x_nodes, dtype=float)\n    y_nodes = np.asarray(y_nodes, dtype=float)\n    w = np.asarray(w, dtype=float)\n    x_eval = np.asarray(x_eval, dtype=float)\n    # Compute differences matrix\n    Xdiff = x_eval[:, None] - x_nodes[None, :]\n    # Identify exact matches to nodes within tolerance\n    mask_eq = np.isclose(Xdiff, 0.0, rtol=0.0, atol=atol)\n    any_eq = np.any(mask_eq, axis=1)\n    # For non-matching points, compute barycentric formula\n    # Avoid division by zero by masking those rows later\n    with np.errstate(divide='ignore', invalid='ignore'):\n        tmp = w[None, :] / Xdiff\n        num = np.dot(tmp, y_nodes)\n        den = np.sum(tmp, axis=1)\n        y = num / den\n    # Fix rows where x_eval equals a node\n    if np.any(any_eq):\n        idxs = np.where(any_eq)[0]\n        # For each such row, pick the corresponding node value\n        # If multiple trues due to tolerance, take the first\n        j_star = np.argmax(mask_eq[idxs, :], axis=1)\n        y[idxs] = y_nodes[j_star]\n    return y\n\ndef endpoint_masks(x_grid, w=0.1):\n    left = x_grid = (-1.0 + w)\n    right = x_grid >= (1.0 - w)\n    return left | right\n\ndef count_strict_sign_changes(values, tol=1e-8):\n    # values: derivative samples on a 1D grid\n    v = np.asarray(values, dtype=float)\n    s = np.sign(v)\n    s[np.abs(v) = tol] = 0.0\n    nonzero = s[s != 0.0]\n    if nonzero.size = 1:\n        return 0\n    # Count transitions where consecutive signs differ\n    return int(np.sum(nonzero[1:] * nonzero[:-1]  0.0))\n\ndef interpolation_metrics(n, node_kind, x_eval, f_eval, tau=1e-8):\n    # node_kind: 'equispaced' or 'cheb_lobatto'\n    if node_kind == 'equispaced':\n        x_nodes = equispaced_nodes(n)\n    elif node_kind == 'cheb_lobatto':\n        x_nodes = chebyshev_lobatto_nodes(n)\n    else:\n        raise ValueError(\"Unknown node kind\")\n\n    y_nodes = f(x_nodes)\n    w = barycentric_weights(x_nodes)\n    p_eval = barycentric_interpolate(x_nodes, y_nodes, w, x_eval)\n\n    # Errors\n    err = np.abs(f_eval - p_eval)\n    E_inf = float(np.max(err))\n\n    # Endpoint window metrics\n    mask_end = endpoint_masks(x_eval, w=0.1)\n    E_end = float(np.max(err[mask_end]))\n\n    # Oscillation count via discrete derivative\n    # Use np.gradient with x grid for better edge approximation\n    dp = np.gradient(p_eval, x_eval, edge_order=2)\n    osc_count = count_strict_sign_changes(dp[mask_end], tol=tau)\n\n    return E_inf, E_end, osc_count\n\ndef solve():\n    # Define the test cases from the problem statement.\n    degrees = [5, 10, 20]  # n values\n    # Evaluation grid\n    M = 20001\n    x_eval = np.linspace(-1.0, 1.0, M, dtype=float)\n    f_eval = f(x_eval)\n\n    results = []\n    for n in degrees:\n        # Equispaced nodes metrics\n        E_inf_e, E_end_e, osc_e = interpolation_metrics(n, 'equispaced', x_eval, f_eval, tau=1e-8)\n        # Chebyshev–Lobatto nodes metrics\n        E_inf_c, E_end_c, osc_c = interpolation_metrics(n, 'cheb_lobatto', x_eval, f_eval, tau=1e-8)\n\n        # Round floats to 8 decimal places as required; integers unchanged\n        results.extend([\n            f\"{np.round(E_inf_e, 8):.8f}\",\n            f\"{np.round(E_end_e, 8):.8f}\",\n            str(int(osc_e)),\n            f\"{np.round(E_inf_c, 8):.8f}\",\n            f\"{np.round(E_end_c, 8):.8f}\",\n            str(int(osc_c)),\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3212557"}]}