{"hands_on_practices": [{"introduction": "掌握傅里叶级数的关键在于熟练计算其系数。这个基础练习将指导你完成计算一个简单线性函数 $f(x)=x$ 的傅里叶系数的标准流程。这个过程不仅能让你熟悉积分公式的应用，更重要的是，它将展示如何利用函数的奇偶对称性来大幅简化计算，这是傅里叶分析中的一个核心技巧 [@problem_id:8857]。", "problem": "一个周期为 $2L$ 的周期函数 $f(x)$，如果满足某些条件（狄利克雷条件），就可以用其傅里叶级数来表示。对于一个定义在区间 $[-L, L]$ 上的函数，其傅里叶级数由下式给出\n$$\nf(x) \\sim \\frac{a_0}{2} + \\sum_{n=1}^{\\infty} \\left[ a_n \\cos\\left(\\frac{n\\pi x}{L}\\right) + b_n \\sin\\left(\\frac{n\\pi x}{L}\\right) \\right]\n$$\n级数的系数 $a_0$、$a_n$ 和 $b_n$ 使用以下公式计算：\n$$\na_0 = \\frac{1}{L} \\int_{-L}^{L} f(x) \\, dx\n$$\n$$\na_n = \\frac{1}{L} \\int_{-L}^{L} f(x) \\cos\\left(\\frac{n\\pi x}{L}\\right) \\, dx \\quad (n \\ge 1)\n$$\n$$\nb_n = \\frac{1}{L} \\int_{-L}^{L} f(x) \\sin\\left(\\frac{n\\pi x}{L}\\right) \\, dx \\quad (n \\ge 1)\n$$\n\n考虑定义在区间 $[-\\pi, \\pi]$ 上的简单线性函数 $f(x) = x$。该函数的周期为 $2\\pi$，所以 $L=\\pi$。\n\n推导该函数在指定区间上的完整傅里叶级数表示。", "solution": "问题是求函数 $f(x) = x$ 在区间 $[-\\pi, \\pi]$ 上的傅里叶级数。周期为 $2L = 2\\pi$，所以 $L=\\pi$。傅里叶级数的一般形式简化为：\n$$\nf(x) \\sim \\frac{a_0}{2} + \\sum_{n=1}^{\\infty} \\left[ a_n \\cos(nx) + b_n \\sin(nx) \\right]\n$$\n我们需要计算系数 $a_0$、$a_n$ 和 $b_n$。\n\n**步骤 1：计算系数 $a_0$。**\n$a_0$ 的公式是：\n$$\na_0 = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(x) \\, dx = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} x \\, dx\n$$\n函数 $f(x) = x$ 是一个奇函数，即 $f(-x) = -f(x)$。奇函数在对称区间（如 $[-\\pi, \\pi]$）上的积分为零。\n$$\na_0 = 0\n$$\n或者，可以直接计算积分：\n$$\na_0 = \\frac{1}{\\pi} \\left[ \\frac{x^2}{2} \\right]_{-\\pi}^{\\pi} = \\frac{1}{2\\pi} (\\pi^2 - (-\\pi)^2) = \\frac{1}{2\\pi} (\\pi^2 - \\pi^2) = 0\n$$\n\n**步骤 2：计算系数 $a_n$。**\n$a_n$ 的公式是：\n$$\na_n = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(x) \\cos(nx) \\, dx = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} x \\cos(nx) \\, dx\n$$\n被积函数是奇函数（$x$）和偶函数（$\\cos(nx)$）的乘积。奇函数和偶函数的乘积是奇函数。因此，在对称区间 $[-\\pi, \\pi]$ 上的积分为零。\n$$\na_n = 0 \\quad \\text{对于所有 } n \\ge 1\n$$\n\n**步骤 3：计算系数 $b_n$。**\n$b_n$ 的公式是：\n$$\nb_n = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(x) \\sin(nx) \\, dx = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} x \\sin(nx) \\, dx\n$$\n被积函数是奇函数（$x$）和奇函数（$\\sin(nx)$）的乘积。两个奇函数的乘积是偶函数。对于偶函数 $g(x)$，在对称区间上的积分为 $\\int_{-a}^{a} g(x) dx = 2\\int_{0}^{a} g(x) dx$。\n$$\nb_n = \\frac{2}{\\pi} \\int_{0}^{\\pi} x \\sin(nx) \\, dx\n$$\n我们使用分部积分法 $\\int u \\, dv = uv - \\int v \\, du$。令 $u = x$ 且 $dv = \\sin(nx) \\, dx$。则 $du = dx$ 且 $v = -\\frac{1}{n}\\cos(nx)$。\n$$\n\\int x \\sin(nx) \\, dx = x \\left(-\\frac{\\cos(nx)}{n}\\right) - \\int \\left(-\\frac{\\cos(nx)}{n}\\right) \\, dx = -\\frac{x\\cos(nx)}{n} + \\frac{1}{n} \\int \\cos(nx) \\, dx\n$$\n$$\n= -\\frac{x\\cos(nx)}{n} + \\frac{\\sin(nx)}{n^2}\n$$\n现在，我们计算定积分：\n$$\nb_n = \\frac{2}{\\pi} \\left[ -\\frac{x\\cos(nx)}{n} + \\frac{\\sin(nx)}{n^2} \\right]_{0}^{\\pi}\n$$\n$$\nb_n = \\frac{2}{\\pi} \\left( \\left( -\\frac{\\pi\\cos(n\\pi)}{n} + \\frac{\\sin(n\\pi)}{n^2} \\right) - \\left( 0 + 0 \\right) \\right)\n$$\n我们知道对于任何整数 $n$，$\\sin(n\\pi) = 0$ 且 $\\cos(n\\pi) = (-1)^n$。\n$$\nb_n = \\frac{2}{\\pi} \\left( -\\frac{\\pi(-1)^n}{n} \\right) = -\\frac{2(-1)^n}{n} = \\frac{2(-1)(-1)^n}{n} = \\frac{2(-1)^{n+1}}{n}\n$$\n\n**步骤 4：组合傅里叶级数。**\n将系数代入级数公式：\n$$\nf(x) \\sim \\frac{0}{2} + \\sum_{n=1}^{\\infty} \\left[ 0 \\cdot \\cos(nx) + \\frac{2(-1)^{n+1}}{n} \\sin(nx) \\right]\n$$\n$$\nf(x) \\sim \\sum_{n=1}^{\\infty} \\frac{2(-1)^{n+1}}{n} \\sin(nx)\n$$\n这可以展开写成：\n$$\nf(x) \\sim 2 \\left( \\sin(x) - \\frac{1}{2}\\sin(2x) + \\frac{1}{3}\\sin(3x) - \\frac{1}{4}\\sin(4x) + \\dots \\right)\n$$\n所求的傅里叶级数是最终组合的表达式。", "answer": "$$\n\\boxed{\\sum_{n=1}^{\\infty} \\frac{2(-1)^{n+1}}{n} \\sin(nx)}\n$$", "id": "8857"}, {"introduction": "傅里叶级数不仅仅是一套积分计算的“食谱”。这个练习将挑战你从一个更概念化的角度来理解傅里叶级数，即将其视为函数在三角函数基上的唯一表示。通过巧妙运用三角恒等式，你将发现可以完全绕过复杂的积分计算，直接写出函数的傅里叶级数 [@problem_id:2174822]，从而加深对傅里叶级数本质的理解。", "problem": "一个周期函数 $f(x)$ 在区间 $[-\\pi, \\pi]$ 上由表达式 $f(x) = (1+\\sin(x))^2$ 定义。该函数的傅里叶级数表示为\n$$S(x) = \\frac{a_0}{2} + \\sum_{n=1}^{\\infty} (a_n \\cos(nx) + b_n \\sin(nx))$$\n其中系数 $a_n$ 和 $b_n$ 通常通过积分公式求得。\n\n利用适当的三角恒等式，求出 $f(x)$ 在区间 $[-\\pi, \\pi]$ 上的傅里叶级数，而无需显式计算任何系数积分。将您的答案表示为一个有限三角级数。", "solution": "我们从函数 $f(x) = (1+\\sin(x))^{2}$ 开始。展开并使用三角恒等式，将其改写为以 $x$ 的整数倍的正弦和余弦表示的形式：\n$$\nf(x) = 1 + 2\\sin(x) + \\sin^{2}(x).\n$$\n使用恒等式 $\\sin^{2}(x) = \\frac{1 - \\cos(2x)}{2}$，我们得到\n$$\nf(x) = 1 + 2\\sin(x) + \\frac{1}{2} - \\frac{1}{2}\\cos(2x) = \\frac{3}{2} + 2\\sin(x) - \\frac{1}{2}\\cos(2x).\n$$\n在 $[-\\pi,\\pi]$ 上周期为 $2\\pi$ 的傅里叶级数是正交基函数 $\\{1,\\cos(nx),\\sin(nx)\\}$ 的和。由于 $f(x)$ 已经可以表示为这些基函数的有限线性组合，它的傅里叶级数与我们找到的表达式完全一致：\n$$\nS(x) = \\frac{3}{2} + 2\\sin(x) - \\frac{1}{2}\\cos(2x).\n$$\n与 $S(x) = \\frac{a_{0}}{2} + \\sum_{n=1}^{\\infty} \\big(a_{n}\\cos(nx) + b_{n}\\sin(nx)\\big)$ 比较，我们有 $a_{0} = 3$，$a_{2} = -\\frac{1}{2}$，$b_{1} = 2$，且所有其他系数均为零，因此该级数是有限的。", "answer": "$$\\boxed{\\frac{3}{2}+2\\sin(x)-\\frac{1}{2}\\cos(2x)}$$", "id": "2174822"}, {"introduction": "理论知识在计算实践中变得鲜活。这项高阶练习将理论与计算相结合，引导你通过编程来探索著名的吉布斯现象 (Gibbs phenomenon)。你将看到，在函数的不连续点附近，有限项傅里叶级数会产生一个“过冲”，其幅度并不会随着项数的增加而消失。通过数值方法量化这个过冲 [@problem_id:3132915]，你将对傅里叶级数的收敛特性有更深刻和直观的认识。", "problem": "考虑一个周期为 $2\\pi$ 的函数 $f(x)=\\mathrm{sgn}(\\sin x)$，其定义为：当 $x\\in(0,\\pi)$ 时 $f(x)=+1$，当 $x\\in(-\\pi,0)$ 时 $f(x)=-1$。此函数经过周期性延拓，并且按照惯例，进行 Fourier 分析时无需考虑跳跃点处的值。从周期为 $2\\pi$ 的函数 $f$ 的 Fourier 级数的基本定义出发：\n$$a_0=\\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x)\\,dx,\\quad a_n=\\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x)\\cos(nx)\\,dx,\\quad b_n=\\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x)\\sin(nx)\\,dx,$$\n推导其正弦级数系数，并为 $f(x)$ 构建包含 $N$ 项奇次谐波的部分和 $S_N(x)$，其中 $N$ 表示保留的奇次谐波的数量。角度必须以弧度为单位。仅使用这些基本定义来求得 $S_N(x)$，不要假定任何预先给出的 Fourier 系数公式。\n\n对于给定的 $N$，将 $x=0$ 处跳跃点附近的 Gibbs 过冲比定义为\n$$r_N=\\frac{\\max_{x\\in(0,\\pi)} S_N(x)-f(0^+)}{\\Delta f},$$\n其中 $f(0^+)=+1$ 是跳跃点处的右极限，$\\Delta f= f(0^+)-f(0^-)=2$ 是跳跃幅度。通过在区间 $(0,\\pi/2)$ 内定位 $S_N(x)$ 的第一个局部最大值来数值估算 $r_N$；一个稳健的方法是先在粗糙网格上计算 $S_N(x)$ 以框定第一个局部最大值的位置，然后在此范围内更密集的子网格上进行精细搜索。数值验证当 $N\\to\\infty$ 时，$r_N$ 趋近于已知的 Gibbs 极限过冲常数 $\\approx 0.08949$。\n\n你的程序必须：\n- 使用推导出的 Fourier 系数，并仅利用奇次谐波来构建 $S_N(x)$。\n- 通过两阶段网格搜索（先粗略框定，后局部精细化）在 $(0,\\pi/2)$ 区间内找到 $S_N(x)$ 的第一个局部最大值。\n- 使用上述定义计算 $r_N$，角度以弧度为单位。\n\n测试集：\n- 使用 $N\\in\\{1,3,25,200\\}$ 来探究小数目、中等数目和大规模数目的谐波，包括边界行为（$N=1$）和近渐近行为（$N=200$）。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[r_1,r_3,r_{25},r_{200},\\text{is\\_close}]$。$r_N$ 的值必须四舍五入到 5 位小数。最后一项 $\\text{is\\_close}$ 必须是一个布尔值，表示 $|r_{200}-0.08949|\\leq 5\\times 10^{-4}$ 是否成立。例如，输出必须类似于 $[0.12345,0.06789,0.09123,0.08949,True]$。", "solution": "用户提供的问题是 Fourier 分析中一个适定且有科学依据的练习，具体涉及方波的 Gibbs 现象。所有定义和常数都是标准且正确的。任务是推导 Fourier 级数，实现部分和，并对过冲进行数值研究。该问题是有效的，将提供解答。\n\n问题要求分析周期为 $2\\pi$ 的函数 $f(x) = \\mathrm{sgn}(\\sin x)$。该函数定义为：当 $x \\in (0, \\pi)$ 时 $f(x)=+1$，当 $x \\in (-\\pi, 0)$ 时 $f(x)=-1$。\n\n首先，我们使用提供的积分定义来确定 Fourier 系数 $a_0$、$a_n$ 和 $b_n$。我们从分析 $f(x)$ 的对称性开始。该函数是奇函数，因为对于任意 $x$，有 $f(-x) = \\mathrm{sgn}(\\sin(-x)) = \\mathrm{sgn}(-\\sin x) = -\\mathrm{sgn}(\\sin x) = -f(x)$。奇函数的 Fourier 级数简化为纯正弦级数，这意味着所有余弦系数 $a_0$ 和 $a_n$ 都必须为零。我们将对此进行明确验证。\n\n系数 $a_0$ 由下式给出：\n$$a_0 = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(x) \\, dx = \\frac{1}{\\pi} \\left( \\int_{-\\pi}^{0} (-1) \\, dx + \\int_{0}^{\\pi} (+1) \\, dx \\right)$$\n$$a_0 = \\frac{1}{\\pi} \\left( [-x]_{-\\pi}^{0} + [x]_{0}^{\\pi} \\right) = \\frac{1}{\\pi} \\left( (-(0) - (-(-\\pi))) + ((\\pi) - (0)) \\right) = \\frac{1}{\\pi} (-\\pi + \\pi) = 0$$\n\n对于 $n \\ge 1$，系数 $a_n$ 由下式给出：\n$$a_n = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(x) \\cos(nx) \\, dx$$\n被积函数是一个奇函数 $f(x)$ 和一个偶函数 $\\cos(nx)$ 的乘积。其结果是一个奇函数。任何奇函数在对称区间如 $[-\\pi, \\pi]$ 上的积分都为零。因此，对于所有 $n \\ge 1$，$a_n=0$。\n\n对于 $n \\ge 1$，正弦系数 $b_n$ 由下式给出：\n$$b_n = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(x) \\sin(nx) \\, dx$$\n被积函数是两个奇函数 $f(x)$ 和 $\\sin(nx)$ 的乘积。该乘积是一个偶函数。偶函数在对称区间 $[-\\pi, \\pi]$ 上的积分等于其在半区间 $[0, \\pi]$ 上积分的两倍。\n$$b_n = \\frac{2}{\\pi} \\int_{0}^{\\pi} f(x) \\sin(nx) \\, dx$$\n对于 $x \\in (0, \\pi)$，我们有 $f(x)=+1$。\n$$b_n = \\frac{2}{\\pi} \\int_{0}^{\\pi} (1) \\sin(nx) \\, dx = \\frac{2}{\\pi} \\left[ -\\frac{\\cos(nx)}{n} \\right]_{0}^{\\pi}$$\n$$b_n = -\\frac{2}{n\\pi} [\\cos(n\\pi) - \\cos(0)] = \\frac{2}{n\\pi} (1 - \\cos(n\\pi))$$\n由于 $\\cos(n\\pi) = (-1)^n$，表达式变为：\n$$b_n = \\frac{2}{n\\pi} (1 - (-1)^n)$$\n这个结果意味着，如果 $n$ 是偶数（例如，$n=2k$），则 $b_{2k} = \\frac{2}{2k\\pi} (1 - 1) = 0$。如果 $n$ 是奇数（例如，对于 $k=1, 2, \\dots$，$n=2k-1$），则 $b_{2k-1} = \\frac{2}{(2k-1)\\pi} (1 - (-1)) = \\frac{4}{(2k-1)\\pi}$。\n\n问题将部分和 $S_N(x)$ 定义为保留前 $N$ 个奇次谐波。这对应于对 $k=1, \\dots, N$ 的项求和。得到的部分和是：\n$$S_N(x) = \\sum_{k=1}^{N} b_{2k-1} \\sin((2k-1)x) = \\sum_{k=1}^{N} \\frac{4}{(2k-1)\\pi} \\sin((2k-1)x)$$\n$$S_N(x) = \\frac{4}{\\pi} \\sum_{k=1}^{N} \\frac{\\sin((2k-1)x)}{2k-1}$$\n\n接下来，我们讨论 Gibbs 过冲比 $r_N$。其定义为：\n$$r_N = \\frac{\\max_{x\\in(0,\\pi)} S_N(x) - f(0^+)}{\\Delta f}$$\n根据给定值 $f(0^+) = 1$ 和跳跃幅度 $\\Delta f = f(0^+) - f(0^-) = 1 - (-1) = 2$，该公式变为：\n$$r_N = \\frac{\\max_{x\\in(0,\\pi)} S_N(x) - 1}{2}$$\n为了找到 $S_N(x)$ 的最大值，我们必须在区间 $(0, \\pi/2)$ 内找到其第一个峰值的位置。解析上，这个点可以通过求解 $S_N'(x)=0$ 来找到。其导数为：\n$$S_N'(x) = \\frac{d}{dx} \\left( \\frac{4}{\\pi} \\sum_{k=1}^{N} \\frac{\\sin((2k-1)x)}{2k-1} \\right) = \\frac{4}{\\pi} \\sum_{k=1}^{N} \\cos((2k-1)x)$$\n使用三角恒等式 $\\sum_{k=1}^{N} \\cos((2k-1)x) = \\frac{\\sin(2Nx)}{2\\sin x}$，我们得到：\n$$S_N'(x) = \\frac{4}{\\pi} \\frac{\\sin(2Nx)}{2\\sin x} = \\frac{2 \\sin(2Nx)}{\\pi \\sin x}$$\n$S_N'(x)=0$ 的第一个正根出现在 $2Nx = \\pi$ 时，因此 $x_{\\text{max}} = \\frac{\\pi}{2N}$。问题中规定的数值方法——两阶段网格搜索——将被用来近似这个最大值。首先，在 $(0, \\pi/2)$ 上进行粗略网格搜索，以确定最大值周围的一个窄区间。其次，在该区间内进行精细网格搜索，以高精度地确定 $S_N(x)$ 的最大值。\n\n所提供的 Python 代码将针对指定的 $N \\in \\{1, 3, 25, 200\\}$ 值实现此逻辑，计算 $r_N$，并验证 $r_{200}$ 对已知 Gibbs 常数的渐近收敛性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef s_n(x_vals, N):\n    \"\"\"\n    Calculates the N-term odd-harmonic partial sum of the Fourier series for sgn(sin(x)).\n    \n    Args:\n        x_vals (np.ndarray): An array of x values (in radians) at which to evaluate the sum.\n        N (int): The number of odd harmonics to include in the sum.\n        \n    Returns:\n        np.ndarray: The values of S_N(x) corresponding to each x in x_vals.\n    \"\"\"\n    # The sum is over k=1 to N for harmonics n=2k-1.\n    k = np.arange(1, N + 1)\n    n_harmonics = 2 * k - 1\n    \n    # Use broadcasting for an efficient vectorized calculation.\n    # x_vals shape: (M,) -> (M, 1)\n    # n_harmonics shape: (N,)\n    # Resulting shape of arg: (M, N)\n    x_col = x_vals[:, np.newaxis]\n    arg = x_col * n_harmonics\n    \n    # Perform the summation\n    terms = np.sin(arg) / n_harmonics\n    sum_val = np.sum(terms, axis=1)\n    \n    return (4 / np.pi) * sum_val\n\ndef calculate_r(N):\n    \"\"\"\n    Numerically estimates the Gibbs overshoot ratio r_N for a given N.\n\n    Args:\n        N (int): The number of odd harmonics.\n\n    Returns:\n        float: The estimated value of r_N.\n    \"\"\"\n    # Stage 1: Coarse grid search to bracket the first maximum in (0, pi/2).\n    # We use a small positive number for the start of the interval to avoid x=0.\n    coarse_grid = np.linspace(1e-9, np.pi / 2, 2000)\n    s_coarse = s_n(coarse_grid, N)\n    idx_max_coarse = np.argmax(s_coarse)\n\n    # Define the search bracket for the fine grid. Handle edge cases.\n    if idx_max_coarse == 0:\n        bracket_start = coarse_grid[0]\n        bracket_end = coarse_grid[1]\n    elif idx_max_coarse == len(coarse_grid) - 1:\n        bracket_start = coarse_grid[-2]\n        bracket_end = coarse_grid[-1]\n    else:\n        bracket_start = coarse_grid[idx_max_coarse - 1]\n        bracket_end = coarse_grid[idx_max_coarse + 1]\n\n    # Stage 2: Fine grid search within the bracket to find the maximum value.\n    fine_grid = np.linspace(bracket_start, bracket_end, 10000)\n    s_fine = s_n(fine_grid, N)\n    s_max = np.max(s_fine)\n\n    # Calculate the Gibbs overshoot ratio r_N.\n    # f(0^+) = 1.0, Delta_f = f(0^+) - f(0^-) = 1 - (-1) = 2.0\n    f0_plus = 1.0\n    delta_f = 2.0\n    r_N = (s_max - f0_plus) / delta_f\n    \n    return r_N\n\ndef solve():\n    \"\"\"\n    Main function to execute the problem, calculate r_N for the test suite,\n    and print the final results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [1, 3, 25, 200]\n\n    results = []\n    for N in test_cases:\n        r_val = calculate_r(N)\n        results.append(r_val)\n\n    # Format the r_N values to 5 decimal places.\n    formatted_results = [f\"{r:.5f}\" for r in results]\n    \n    # Check if r_200 is close to the theoretical Gibbs constant.\n    gibbs_constant = 0.08949\n    tolerance = 5e-4\n    r_200 = results[-1]\n    is_close = abs(r_200 - gibbs_constant) = tolerance\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)},{is_close}]\")\n\nsolve()\n```", "id": "3132915"}]}