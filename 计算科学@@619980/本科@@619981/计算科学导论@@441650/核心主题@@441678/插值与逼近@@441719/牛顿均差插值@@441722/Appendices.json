{"hands_on_practices": [{"introduction": "在使用任何数值工具之前，验证其正确性至关重要。本练习将指导你实现差商算法，并对照函数 $f(x) = x^k$ 的已知理论结果进行验证，为后续更复杂的探索建立坚实的基础 [@problem_id:3164015]。", "problem": "您的任务是在计算科学导论领域内，针对一类特定函数，将牛顿差商的数值计算结果与精确的符号结果进行验证。您需要处理单项式函数 $f(x) = x^k$ 和在一组包含 $k+1$ 个不同插值节点上的 $k$ 阶差商。您的程序必须使用差商的标准递归定义来实现 $k$ 阶差商的数值计算，并将其与根据多项式插值基础性质得出的精确符号值进行比较。该比较必须基于指定的容差通过布尔判定进行量化。\n\n推导与验证的基础理论：\n- 多项式插值概念：给定 $k+1$ 个不同的点 $(x_i, f(x_i))$，其中 $i \\in \\{0,1,\\dots,k\\}$，存在一个唯一的次数至多为 $k$ 的多项式 $p(x)$ 对这些数据进行插值。\n- 插值多项式的牛顿形式使用由数据 $(x_i, f(x_i))$ 和牛顿多项式基构造的差商作为系数。\n\n您不能假设任何能够轻易得出结果的捷径公式；您应在解题过程中基于所述的基础理论进行推理。在您的程序中，您将：\n1. 使用浮点运算计算函数 $f(x) = x^k$ 在给定节点上的数值 $k$ 阶差商。\n2. 计算多项式插值的基础性质对函数 $f(x) = x^k$ 所隐含的精确符号值。\n3. 判断数值是否在指定的绝对容差 $\\varepsilon$ 范围内与精确值匹配。\n\n测试套件包含以下参数集 $(k, [x_0,\\dots,x_k])$，旨在覆盖典型和边缘场景。所有节点均为实数且两两不同。每个案例均使用 $f(x) = x^k$：\n- 案例 1：$k = 0$，节点 $[7.5]$。\n- 案例 2：$k = 1$，节点 $[-10.0, 10.0]$。\n- 案例 3：$k = 2$，节点 $[0.0, 0.5, 2.0]$。\n- 案例 4：$k = 3$，节点 $[-10^{-5}, 0.0, 10^{-5}, 2 \\cdot 10^{-5}]$。\n- 案例 5：$k = 4$，节点 $[-1.0, 5.0, -0.5, 0.0, 2.5]$ (无序)。\n- 案例 6：$k = 5$，节点 $[1.0, 1.0 + 10^{-8}, 1.0 + 2 \\cdot 10^{-8}, 1.0 + 3 \\cdot 10^{-8}, 1.0 + 4 \\cdot 10^{-8}, 1.0 + 5 \\cdot 10^{-8}]$。\n\n对于每个案例，您的程序必须：\n- 从给定的节点和函数 $f(x) = x^k$ 计算数值 $k$ 阶差商 $\\widehat{c}_k$。\n- 使用基础理论对函数 $f(x) = x^k$ 所隐含的精确符号值 $c_k$。\n- 使用绝对容差 $\\varepsilon = 10^{-10}$ 进行比较，并返回一个定义为 $b = \\left(|\\widehat{c}_k - c_k| \\le \\varepsilon\\right)$ 的布尔值 $b$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含六个案例的布尔结果，格式为方括号内以逗号分隔的列表，例如 $[{\\text{True}},{\\text{False}},\\dots]$。\n\n不涉及物理单位、角度单位或百分比格式。所有输出均为布尔值。", "solution": "我们从多项式插值的基础框架开始。给定 $k+1$ 个不同的节点 $x_0, x_1, \\dots, x_k$ 和函数值 $f(x_i)$，存在一个唯一的次数至多为 $k$ 的插值多项式 $p(x)$，使得对所有 $i$ 都有 $p(x_i) = f(x_i)$。该插值多项式的牛顿形式将 $p(x)$ 表示为牛顿基：\n$$\np(x) = c_0 + c_1 (x - x_0) + c_2 (x - x_0)(x - x_1) + \\cdots + c_k \\prod_{m=0}^{k-1} (x - x_m),\n$$\n其中每个系数 $c_j$ 是 $j$ 阶差商 $[x_0, x_1, \\dots, x_j] f$。\n\n牛顿基 $\\prod_{m=0}^{j-1} (x - x_m)$ 的一个核心性质是，其关于 $x$ 的首项为 $x^j$，且首项系数为 1。因此，$p(x)$ 中 $x^k$ 的系数恰好是 $c_k$，因为乘积 $\\prod_{m=0}^{k-1} (x - x_m)$ 的首项是 $x^k$ 且首项系数为 1，而所有低阶基多项式的次数都小于 $k$。所以，如果 $p(x)$ 对一个次数至多为 $k$ 的多项式函数 $f(x)$ 进行插值，则系数 $c_k$ 必须等于 $f(x)$ 的首项系数。\n\n将此结论应用于特定函数 $f(x) = x^k$，这是一个次数为 $k$ 且首项系数为 1 的单项式，我们得出：\n$$\n[x_0, x_1, \\dots, x_k] f = 1,\n$$\n对于任意选择的 $k+1$ 个不同节点 $x_0, x_1, \\dots, x_k$。这个精确的符号值 $c_k = 1$ 源于插值多项式的唯一性以及牛顿基的结构。\n\n为了计算数值 $k$ 阶差商，我们使用通过三角格式（通常称为差商表）实现的标准递归定义。定义零阶差商为 $d_i^{(0)} = f(x_i)$。对于 $m = 1$ 到 $k$，定义：\n$$\nd_i^{(m)} = \\frac{d_{i+1}^{(m-1)} - d_i^{(m-1)}}{x_{i+m} - x_i}, \\quad i = 0, 1, \\dots, k - m.\n$$\n于是，$k$ 阶差商的数值估计为 $\\widehat{c}_k = d_0^{(k)}$。该算法需要 $O(k^2)$ 次浮点运算，是数值插值中的标准算法。\n\n数值考量：差商的计算对节点的间距很敏感，因为分母 $x_{i+m} - x_i$ 可能会变得非常小，从而放大舍入误差。然而，对于尺度适中的问题，双精度浮点运算通常足够了。所选的测试套件包括：\n- 一个边界情况 $k = 0$，此时 $[x_0] f = f(x_0) = 1$。\n- 节点间距适中的低阶情况。\n- 一个无序的节点顺序，以强调差商的对称性。\n- 一个用于 $k = 5$ 的近乎重合的节点集，其增量为 $10^{-8}$，旨在对数值条件进行轻度压力测试，同时保持在合理的容差范围内。\n\n验证协议：对于每个测试案例，我们通过三角格式数值计算 $\\widehat{c}_k$，将其与精确值 $c_k = 1$ 进行比较，如果 $|\\widehat{c}_k - 1| \\le \\varepsilon$（其中 $\\varepsilon = 10^{-10}$），则判定为成功。程序以要求的单行格式输出这六个案例的六个布尔值列表。\n\n该方法将基础理论（牛顿插值和首项系数）与算法设计（差商表）相结合，以依据精确的符号知识来验证计算结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef monomial_values(xs, k):\n    \"\"\"Compute f(x) = x^k for all x in xs.\"\"\"\n    xs = np.asarray(xs, dtype=np.float64)\n    return xs ** k\n\ndef k_th_divided_difference(xs, ys):\n    \"\"\"\n    Compute the k-th order divided difference using the standard\n    recursive (triangular table) scheme.\n    Assumes len(xs) == len(ys) == k+1 and xs are distinct.\n    \"\"\"\n    n = len(xs)\n    dd = ys.astype(np.float64).copy()\n    # Build the table: dd[i] holds the current order divided differences\n    for m in range(1, n):\n        for i in range(n - m):\n            denom = xs[i + m] - xs[i]\n            dd[i] = (dd[i + 1] - dd[i]) / denom\n    return float(dd[0])\n\ndef solve():\n    # Define the test cases from the problem statement: (k, nodes)\n    test_cases = [\n        (0, [7.5]),\n        (1, [-10.0, 10.0]),\n        (2, [0.0, 0.5, 2.0]),\n        (3, [-1e-5, 0.0, 1e-5, 2e-5]),\n        (4, [-1.0, 5.0, -0.5, 0.0, 2.5]),\n        (5, [1.0, 1.0 + 1e-8, 1.0 + 2e-8, 1.0 + 3e-8, 1.0 + 4e-8, 1.0 + 5e-8]),\n    ]\n\n    tol = 1e-10\n    results = []\n    for k, nodes in test_cases:\n        xs = np.array(nodes, dtype=np.float64)\n        if len(xs) != k + 1:\n            # Defensive check: format requires k+1 nodes for k-th divided difference\n            raise ValueError(f\"Case with k={k} has {len(xs)} nodes; expected {k+1}.\")\n        ys = monomial_values(xs, k)\n        numeric = k_th_divided_difference(xs, ys)\n        exact = 1.0  # For f(x) = x^k, the k-th divided difference equals 1\n        ok = abs(numeric - exact) = tol\n        results.append(ok)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3164015"}, {"introduction": "多项式是光滑的，但许多现实世界中的函数并非如此。本练习将研究差商在处理带有尖点的函数 $f(x)=|x|$ 时的行为，并揭示差商系数如何成为诊断函数不光滑性的有力工具 [@problem_id:3164020]。", "problem": "您的任务是研究当被插值函数存在非光滑点时，最高阶牛顿系数（也称为最高阶均差）的行为。考虑绝对值函数 $f(x)=|x|$，该函数在 $x=0$ 处有一个不可微的尖点。在不同节点 $x_{0},x_{1},\\ldots,x_{k}$ 处对函数 $f$ 进行插值的、次数至多为 $k$ 的唯一多项式 $P_{k}$，可以采用牛顿基表示，其最高阶系数根据定义即为 $k$ 阶均差 $[x_{0},x_{1},\\ldots,x_{k}]f$。从以下基本事实出发：(i) 对于不同的节点，存在唯一的插值多项式；(ii) 对于任意一组不同的节点，都存在牛顿基展开式。请研究在不同节点配置下，$f(x)=|x|$ 的最高阶牛顿系数的大小，以评估非光滑性如何放大高阶系数。\n\n程序要求：\n- 实现一个程序，在给定不同的节点 $x_{0},x_{1},\\ldots,x_{k}$ 和一个函数 $f$ 的情况下，通过从插值多项式的牛顿形式中正确提取最高阶系数来计算 $k$ 阶均差 $[x_{0},x_{1},\\ldots,x_{k}]f$。计算过程必须与均差的标准定义一致。\n- 将您的实现应用于下面列出的每个测试用例的函数 $f(x)=|x|$。\n- 对于每个测试用例，您的程序必须计算并返回一个实数，该实数等于给定节点和函数 $f(x)=|x|$ 的 $k$ 阶均差 $[x_{0},x_{1},\\ldots,x_{k}]f$。不应返回任何其他量。\n\n测试套件 (每个用例指定了节点；此处 $k=\\text{节点数}-1$):\n1. 节点 $[-2,-1,0,1,2]$ (即 $x_{0}=-2$, $x_{1}=-1$, $x_{2}=0$, $x_{3}=1$, $x_{4}=2$；因此 $k=4$)。\n2. 节点 $[-2,-1,-0.5,-0.25]$ (即 $x_{0}=-2$, $x_{1}=-1$, $x_{2}=-0.5$, $x_{3}=-0.25$；因此 $k=3$)。\n3. 节点 $[0.25,0.5,1.0,2.0]$ (即 $x_{0}=0.25$, $x_{1}=0.5$, $x_{2}=1.0$, $x_{3}=2.0$；因此 $k=3$)。\n4. 节点 $[-10^{-3},0,10^{-3}]$ (即 $x_{0}=-10^{-3}$, $x_{1}=0$, $x_{2}=10^{-3}$；因此 $k=2$)。\n5. 节点 $[-10^{-3},10^{-3},2\\times 10^{-3}]$ (即 $x_{0}=-10^{-3}$, $x_{1}=10^{-3}$, $x_{2}=2\\times 10^{-3}$；因此 $k=2$)。\n6. 节点 $[-3,-0.1,0.2,0.9]$ (即 $x_{0}=-3$, $x_{1}=-0.1$, $x_{2}=0.2$, $x_{3}=0.9$；因此 $k=3$)。\n\n输出规格：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序与上述测试用例相同。例如，包含三个结果的输出应如下所示：$[\\text{result}_{1},\\text{result}_{2},\\text{result}_{3}]$。\n- 每个结果必须是一个实数（一个浮点数）。此问题不涉及单位。\n\n设计意图与覆盖范围：\n- 测试套件包括一个包含尖点的对称节点集 ($[-2,-1,0,1,2]$)，两个完全位于尖点一侧的光滑区间节点集 ($[-2,-1,-0.5,-0.25]$ 和 $[0.25,0.5,1.0,2.0]$)，两个靠近尖点、间距很小且能说明放大效应的边界情况 ($[-10^{-3},0,10^{-3}]$ 和 $[-10^{-3},10^{-3},2\\times 10^{-3}]$)，以及一个跨越尖点的通用不规则节点集 ($[-3,-0.1,0.2,0.9]$)。答案是实数，量化了每种情况下 $f(x)=|x|$ 的最高阶牛顿系数。", "solution": "该问题是有效的，因为它在科学上基于数值分析的原理，特别是多项式插值和牛顿均差。它是适定的、客观的，并且为每个测试用例计算唯一解提供了所有必要的数据。函数 $f(x)=|x|$ 是一个标准且具有说明性的例子，用以展示插值多项式对于非光滑函数的行为。\n\n目标是对于给定的几组不同节点，计算函数 $f(x)=|x|$ 的最高阶均差 $[x_{0}, x_{1}, \\ldots, x_{k}]f$。这个量恰好是牛顿形式插值多项式的首项系数。\n\n设 $f(x)$ 为一个函数，$x_{0}, x_{1}, \\ldots, x_{k}$ 是 $k+1$ 个不同的点，称为节点。存在一个次数至多为 $k$ 的唯一多项式 $P_k(x)$，使得对所有 $i \\in \\{0, 1, \\ldots, k\\}$ 都有 $P_k(x_i) = f(x_i)$。该多项式可以表示为牛顿形式：\n$$\nP_k(x) = c_0 + c_1(x-x_0) + c_2(x-x_0)(x-x_1) + \\cdots + c_k(x-x_0)(x-x_1)\\cdots(x-x_{k-1})\n$$\n系数 $c_j$ 是均差，定义为 $c_j = [x_0, x_1, \\ldots, x_j]f$。问题要求计算最高阶系数 $c_k = [x_0, x_1, \\ldots, x_k]f$。\n\n均差由以下递归公式定义：\n零阶均差是函数值本身：\n$$\n[x_i]f = f(x_i)\n$$\n对于阶数 $j > 0$，均差递归定义为：\n$$\n[x_i, x_{i+1}, \\ldots, x_{i+j}]f = \\frac{[x_{i+1}, \\ldots, x_{i+j}]f - [x_i, \\ldots, x_{i+j-1}]f}{x_{i+j} - x_i}\n$$\n这个递归定义构成了计算算法的基础。我们可以构建一个均差表，但为了只找到最高阶系数，可以使用一种空间效率更高的算法。我们可以使用一个大小为 $k+1$ 的一维数组（比如 `c`），并对其进行迭代更新。\n\n算法流程如下：\n1.  初始化一个长度为 $k+1$ 的数组 `c`，其值为节点处的函数值：$c_i = f(x_i)$，其中 $i=0, 1, \\ldots, k$。\n2.  对 $j$ 从 $1$ 到 $k$ 进行迭代。这对应于计算 $j$ 阶均差。\n3.  在每次迭代 $j$ 中，对 $i$ 从 $k$ 向下迭代到 $j$。这种反向循环顺序对于原地正确更新数组 `c` 至关重要。\n4.  使用递归公式更新条目 $c_i$。在步骤 $(j,i)$，值 $c_i$ 存储的是 $(j-1)$ 阶均差 $[x_{i-j+1}, \\ldots, x_i]f$，而 $c_{i-1}$ 存储的是 $[x_{i-j}, \\ldots, x_{i-1}]f$。更新公式为：\n    $$\n    c_i \\leftarrow \\frac{c_i - c_{i-1}}{x_i - x_{i-j}}\n    $$\n5.  循环完成后（即 $j=k$ 的迭代之后），数组的最后一个元素 $c_k$ 将保存所求的最高阶均差 $[x_0, x_1, \\ldots, x_k]f$。\n\n一个关键的理论结果将均差与导数联系起来。如果函数 $f$ 在包含节点 $x_0, \\ldots, x_n$ 的区间上 $n$ 次连续可微，那么在包含这些节点的最小区间内存在一点 $\\xi$，使得：\n$$\n[x_0, \\ldots, x_n]f = \\frac{f^{(n)}(\\xi)}{n!}\n$$\n本问题中的函数是 $f(x)=|x|$。这个函数除了在 $x=0$ 处有一个“尖点”（一个不可微点）之外，处处光滑。\n- 对于任何所有节点满足 $x_i > 0$ 或所有节点满足 $x_i  0$ 的节点集，该函数等价于一个线性多项式（分别为 $f(x)=x$ 或 $f(x)=-x$）。对于这样的函数，$f''(x) = 0$ 并且所有更高阶的导数也为零。因此，对于 $k \\ge 2$，其 $k$ 阶均差必定为 $0$。这适用于测试用例2和3。\n- 当节点集包含 $x=0$ 或跨越该点时，函数在包含节点的区间上是不光滑的。均差公式仍然适用，但我们不能再将其与高阶导数联系起来。相反，均差量化了函数在给定节点上的“多项式性”。预计在 $x=0$ 处的非光滑性将导致非零且可能很大的高阶均差，这反映了由绝对值函数引入的奇异性。测试用例旨在探究这种行为。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_highest_order_dd(nodes):\n    \"\"\"\n    Computes the highest-order Newton divided difference for f(x)=|x|.\n\n    Args:\n        nodes (list or tuple of float): A list of distinct nodes x_0, x_1, ..., x_k.\n\n    Returns:\n        float: The k-th order divided difference [x_0, ..., x_k]f.\n    \"\"\"\n    x = np.array(nodes, dtype=float)\n    y = np.abs(x)\n    k = len(x) - 1\n\n    if k  0:\n        # This case won't be triggered by the problem's test suite.\n        # A single node has a 0-th order difference, y[0]. \n        # For simplicity, we can handle it, though the loop structure naturally does.\n        return y[0] if k == -1 else 0.0\n\n    # The array 'coeffs' will be updated in-place.\n    # Initially, it holds the 0-th order differences (the function values).\n    coeffs = y.copy()\n\n    # Iterate from j=1 (1st order diff) to j=k (k-th order diff).\n    for j in range(1, k + 1):\n        # The inner loop computes the j-th order differences.\n        # It must run in reverse to use the (j-1)-th order differences\n        # from the previous 'j' iteration before they are overwritten.\n        for i in range(k, j - 1, -1):\n            numerator = coeffs[i] - coeffs[i-1]\n            denominator = x[i] - x[i-j]\n            coeffs[i] = numerator / denominator\n\n    # The highest-order coefficient is the last element.\n    return coeffs[k]\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing the highest-order divided difference\n    for f(x)=|x| for each of the provided test cases.\n    \"\"\"\n    test_cases = [\n        # 1. Symmetric set containing the kink\n        [-2.0, -1.0, 0.0, 1.0, 2.0],\n        # 2. Smooth-side set on the negative side\n        [-2.0, -1.0, -0.5, -0.25],\n        # 3. Smooth-side set on the positive side\n        [0.25, 0.5, 1.0, 2.0],\n        # 4. Small-spacing set symmetric about the kink\n        [-1e-3, 0.0, 1e-3],\n        # 5. Small-spacing asymmetric set near the kink\n        [-1e-3, 1e-3, 2e-3],\n        # 6. General irregular set crossing the kink\n        [-3.0, -0.1, 0.2, 0.9],\n    ]\n\n    results = []\n    for nodes in test_cases:\n        result = compute_highest_order_dd(nodes)\n        results.append(result)\n\n    # Format the final output string as required.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3164020"}, {"introduction": "高阶多项式插值可能会因剧烈振荡而失败，著名的龙格（Runge）现象便是例证。本练习将利用差商作为判据，构建一个自适应的分段插值算法，以有效逼近那些对于标准方法而言具有挑战性的函数 [@problem_id:3163936]。", "problem": "要求您在牛顿差商框架内，形式化并实现一个在单个全局插值多项式和分段多项式之间切换的原则性准则，并在函数 $f(x)=\\dfrac{1}{1+x^2}$ 上进行测试。请以纯数学术语进行描述，不依赖于任何特定的编程语言。您的最终交付成果必须是一个完整且可运行的程序，并遵循文末的输出规范。\n\n从以下基本定义开始。\n\n1. 给定不同的节点 $x_0,\\dots,x_n$ 和函数值 $y_i=f(x_i)$，差商递归定义为\n$$\nf[x_i]=y_i,\\quad f[x_i,x_{i+1},\\dots,x_{i+k}] \\;=\\; \\frac{f[x_{i+1},\\dots,x_{i+k}] - f[x_i,\\dots,x_{i+k-1}]}{x_{i+k}-x_i},\n$$\n其中 $k\\ge 1$。牛顿基函数为 $1,(x-x_0),(x-x_0)(x-x_1),\\dots$。\n\n2. 对于不同的 $x_i$，穿过点 $(x_i,y_i)$ 的次数最多为 $n$ 的唯一插值多项式是存在的，并且可以用牛顿基表示，其系数由差商构成。\n\n设计一个准则并构建一个算法，该算法从左到右遍历一组有序节点，并决定何时停止增长当前的多项式段并开始一个新分段。您的准则必须基于监测最新可用的高阶牛顿系数的绝对值的增长。具体来说，对于一个暂定包含节点 $x_s,\\dots,x_t$ 的当前分段和一个预备新节点 $x_{t+1}$，计算暂定节点集 $x_s,\\dots,x_{t+1}$ 的差商系数。如果最高阶系数 $|c_k|$（其中 $k=t+1-s \\ge 1$）的大小超过了预设的正阈值 $\\tau$，则不将 $x_{t+1}$ 添加到当前分段中；而是将当前分段确定为 $x_s,\\dots,x_t$，并从 $x_{t+1}$ 开始一个新分段。绝不要使用 $k=0$ 的系数（即 $f[x_s]$）来触发分割。如果从未超过阈值，您将得到一个单一的全局分段。\n\n实现以下任务。\n\n- 通过在区间 $[-5,5]$ 上取 $N$ 个等距点来构建节点，即 $x_i=-5 + \\dfrac{10\\,i}{N-1}$（其中 $i=0,\\dots,N-1$），并设置 $y_i=f(x_i)$，其中 $f(x)=\\dfrac{1}{1+x^2}$。\n- 实现一个顺序分段构建算法，该算法使用上述准则和阈值 $\\tau0$：\n  - 在最左侧的节点处初始化一个分段。\n  - 尝试通过逐个添加下一个节点来增长该分段。\n  - 在每次尝试时，为暂定分段重新计算牛顿差商系数，并仅检查阶数 $k \\ge 1$ 的最新系数。\n  - 如果 $|c_k| \\le \\tau$，则接受该节点并继续增长；如果 $|c_k| > \\tau$，则在不包含新节点的情况下完成当前分段，并从该节点开始一个新分段。\n- 对于求值，对于每个具有节点 $x_s,\\dots,x_t$ 及其牛顿系数 $c_0,\\dots,c_{t-s}$ 的分段，在 $[x_s,x_t]$ 中的任意 $x$ 处，使用牛顿基的嵌套乘法（霍纳法则）来计算多项式的值。\n\n为了进行定量评估，在一个密集网格上定义最大绝对误差如下。设求值网格为 $[-5,5]$ 上的 $M$ 个等距点。对于此网格上的每个 $x$，选择其节点区间包含 $x$ 的分段（除最后一个分段包含 $5$ 外，将右端点包含在左侧分段中），计算对应的分段多项式的值，并计算 $|p(x)-f(x)|$。报告网格上的最大值。\n\n您的程序必须为下面的每个测试用例计算在 $[-5,5]$ 上 $M=2001$ 个等距点网格上的最大绝对误差，并按要求的格式将结果作为单个列表输出。请使用实数算术，不要使用外部数据。\n\n测试套件：\n- 用例 A (理想情况): $N=21$, $\\tau=1.0$。\n- 用例 B (全局多项式): $N=21$, $\\tau=10^{12}$。\n- 用例 C (激进分割): $N=21$, $\\tau=10^{-3}$。\n- 用例 D (小数据集): $N=3$, $\\tau=1.0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 [用例 A, 用例 B, 用例 C, 用例 D]。每个条目必须是该用例的最大绝对误差的浮点数，四舍五入到 $6$ 位小数。示例格式：$[0.123456,0.000001,0.987654,0.314159]$。", "solution": "该问题要求设计并实现一种用于构建分段多项式插值的自适应算法。任务的核心是开发一个数据驱动的准则，以决定何时对插值域进行划分，目的是减轻在等距节点上进行高阶全局多项式插值时特有的振荡行为，即著名的龙格现象 (Runge's phenomenon)。函数 $f(x) = \\frac{1}{1+x^2}$ 在区间 $[-5, 5]$ 上是说明此问题的典型例子。\n\n该算法背后的基本原理是监测差商系数的增长。对于不同的节点 $x_0, x_1, \\dots, x_k$，k 阶差商 $f[x_0, \\dots, x_k]$ 与函数的导数通过差商均值定理相关联：\n$$\nf[x_0, \\dots, x_k] = \\frac{f^{(k)}(\\xi)}{k!}\n$$\n其中 $\\xi$ 位于节点所跨越的区间内。大幅值的差商意味着大的导数，这反过来表明插值多项式可能会经历快速变化和潜在的振荡。该算法将这一观察形式化为一个具体的分裂准则。\n\n算法流程如下：\n\n1.  **节点生成**：将域 $[-5, 5]$ 离散化为一组 $N$ 个有序的等距节点 $\\{x_i\\}_{i=0}^{N-1}$，其中 $x_i = -5 + \\frac{10i}{N-1}$。相应的函数值计算为 $y_i = f(x_i)$。\n\n2.  **顺序分段构建**：算法从左到右遍历节点以构建多项式分段。\n    *   设当前分段始于节点索引 $s$。初始时，$s=0$。\n    *   算法逐个暂定地添加后续节点 $x_{s+1}, x_{s+2}, \\dots, x_t$。\n    *   对于每个定义在节点 $\\{x_s, \\dots, x_t\\}$ 上的暂定分段，计算其牛顿差商系数 $c_j = f[x_s, \\dots, x_{s+j}]$，其中 $j = 0, \\dots, k$，而 $k = t-s$ 是暂定多项式的次数。\n    *   **分裂准则**：将最高阶系数的大小 $|c_k| = |f[x_s, \\dots, x_t]|$ 与预设的正阈值 $\\tau$ 进行比较。此检查针对任何阶数 $k \\ge 1$ 的新系数执行。\n        *   如果 $|c_k| \\le \\tau$，则节点 $x_t$ 成功并入当前分段。然后继续考虑下一个节点 $x_{t+1}$。\n        *   如果 $|c_k|  \\tau$，则拒绝添加节点 $x_t$，因为它可能引入不稳定性。当前分段最终确定为使用节点 $\\{x_s, \\dots, x_{t-1}\\}$。从节点 $x_t$ 开始一个新分段，即下一个分段的起始索引设置为 $s \\leftarrow t$。\n\n3.  **数据结构**：此过程的最终结果是一组分段。每个分段由其构成的节点 $\\{z_0, \\dots, z_d\\}$（原始 $x_i$ 的一个子序列）和相应的牛顿系数 $\\{c_0, \\dots, c_d\\}$ 定义。\n\n4.  **多项式求值**：对于一个给定的点 $x_{eval}$，我们必须首先确定正确的多项式分段。域 $[-5, 5]$ 根据各分段的起始节点进行划分。如果分段始于 $x_{s_0}, x_{s_1}, \\dots, x_{s_p}$，则第 $i$ 个分段的多项式用于在区间 $[x_{s_i}, x_{s_{i+1}})$ 上求值。最后一个分段覆盖区间 $[x_{s_p}, x_{N-1}]$。\n    一旦选定具有节点 $\\{z_0, \\dots, z_d\\}$ 和系数 $\\{c_0, \\dots, c_d\\}$ 的适当分段，就使用牛顿形式的霍纳 (Horner) 方法对多项式进行求值，这种方法计算效率高且数值稳定：\n    $$\n    P(x_{eval}) = (\\dots((c_d \\cdot (x_{eval}-z_{d-1}) + c_{d-1}) \\cdot (x_{eval}-z_{d-2}) + c_{d-2}) \\dots) \\cdot (x_{eval}-z_0) + c_0\n    $$\n\n5.  **误差评估**：为了量化所得分段插值函数 $P(x)$ 的准确性，在 $[-5, 5]$ 上的一个包含 $M=2001$ 个点的密集求值网格上，计算其与真实函数 $f(x)$ 的最大绝对误差。该误差由 $\\max_{x \\in \\text{grid}} |P(x) - f(x)|$ 给出。\n\n这种有原则的方法允许从单一全局多项式（当 $\\tau$ 很大时）自动过渡到细粒度的分段多项式（当 $\\tau$ 很小时），从而根据差商所揭示的函数局部行为来调整模型复杂度。\n\n实现包含三个主要部分：\na) 一个函数，用于为给定的一组节点和值计算牛顿差商系数。\nb) 主要的划分逻辑，它遍历节点，应用准则，并生成多项式分段的列表。\nc) 一个求值函数，它对任意 $x$ 找到正确的分段并计算其牛顿多项式的值，然后用该值计算指定网格上的最大误差。", "answer": "```python\nimport numpy as np\n\ndef _compute_divided_diffs(xs, ys):\n    \"\"\"\n    Computes the Newton divided-difference coefficients.\n    The coefficients are the top diagonal of the divided difference table.\n    \n    Args:\n        xs (np.ndarray): The x-coordinates of the nodes.\n        ys (np.ndarray): The y-coordinates of the nodes.\n\n    Returns:\n        np.ndarray: The array of Newton coefficients.\n    \"\"\"\n    n = len(xs)\n    if n == 0:\n        return np.array([])\n    \n    coeffs = np.copy(ys).astype(float)\n    for j in range(1, n):\n        for i in range(n - 1, j - 1, -1):\n            # To avoid division by zero for identical nodes, though problem states distinct.\n            denominator = xs[i] - xs[i - j]\n            if denominator == 0:\n                # This case should not be reached with distinct nodes.\n                # A large value can be used to signal an issue if needed.\n                return np.array([np.inf] * n)\n            coeffs[i] = (coeffs[i] - coeffs[i - 1]) / denominator\n    return coeffs\n\ndef _build_pieces(x_nodes, y_nodes, tau):\n    \"\"\"\n    Constructs the piecewise polynomial based on the splitting criterion.\n\n    Args:\n        x_nodes (np.ndarray): All x-coordinates for interpolation.\n        y_nodes (np.ndarray): All y-coordinates for interpolation.\n        tau (float): The threshold for splitting.\n\n    Returns:\n        list: A list of piece dictionaries. Each dictionary contains 'nodes' and 'coeffs'.\n    \"\"\"\n    N = len(x_nodes)\n    pieces = []\n    start_idx = 0\n\n    for i in range(1, N):\n        tentative_nodes_x = x_nodes[start_idx : i + 1]\n        tentative_nodes_y = y_nodes[start_idx : i + 1]\n        \n        order = len(tentative_nodes_x) - 1\n        \n        # The splitting criterion applies for order k >= 1\n        if order  1:\n            continue\n        \n        # We only need the highest order coefficient for the check.\n        # A full _compute_divided_diffs call is slightly inefficient but correct.\n        coeffs = _compute_divided_diffs(tentative_nodes_x, tentative_nodes_y)\n        highest_order_coeff = coeffs[-1]\n\n        if np.abs(highest_order_coeff) > tau:\n            # Finalize the piece with nodes from start_idx up to i-1\n            final_nodes_x = x_nodes[start_idx : i]\n            final_nodes_y = y_nodes[start_idx : i]\n            final_coeffs = _compute_divided_diffs(final_nodes_x, final_nodes_y)\n            pieces.append({'nodes': final_nodes_x, 'coeffs': final_coeffs})\n            \n            # Start a new piece at index i\n            start_idx = i\n\n    # Add the last remaining piece\n    final_nodes_x = x_nodes[start_idx:N]\n    final_nodes_y = y_nodes[start_idx:N]\n    final_coeffs = _compute_divided_diffs(final_nodes_x, final_nodes_y)\n    pieces.append({'nodes': final_nodes_x, 'coeffs': final_coeffs})\n\n    return pieces\n\ndef _evaluate_newton_poly(x, nodes, coeffs):\n    \"\"\"\n    Evaluates a polynomial in Newton form at a point x using Horner's method.\n    \"\"\"\n    d = len(coeffs) - 1\n    y = coeffs[d]\n    for i in range(d - 1, -1, -1):\n        y = y * (x - nodes[i]) + coeffs[i]\n    return y\n\ndef calculate_max_error(N, tau, M):\n    \"\"\"\n    Performs the full procedure for one test case.\n\n    Args:\n        N (int): Number of interpolation nodes.\n        tau (float): Splitting threshold.\n        M (int): Number of points in the evaluation grid.\n\n    Returns:\n        float: The maximum absolute error.\n    \"\"\"\n    f = lambda x: 1.0 / (1.0 + x**2)\n    \n    # 1. Construct nodes\n    x_nodes = np.linspace(-5.0, 5.0, N)\n    y_nodes = f(x_nodes)\n    \n    # 2. Build piecewise polynomial\n    pieces = _build_pieces(x_nodes, y_nodes, tau)\n    \n    # 3. Evaluate and compute error\n    x_eval_grid = np.linspace(-5.0, 5.0, M)\n    p_eval = np.zeros_like(x_eval_grid)\n    \n    piece_start_nodes_x = [p['nodes'][0] for p in pieces]\n    \n    for i, x_val in enumerate(x_eval_grid):\n        # Find which piece the evaluation point belongs to\n        # 'side=right' ensures that x_val is assigned to the interval [x_s, x_{s+1})\n        piece_idx = np.searchsorted(piece_start_nodes_x, x_val, side='right') - 1\n        # Handle x_val being less than the first node, which results in index -1, so clip to 0\n        if piece_idx  0:\n            piece_idx = 0\n            \n        selected_piece = pieces[piece_idx]\n        \n        p_eval[i] = _evaluate_newton_poly(x_val, selected_piece['nodes'], selected_piece['coeffs'])\n        \n    f_eval = f(x_eval_grid)\n    max_error = np.max(np.abs(p_eval - f_eval))\n    \n    return max_error\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        (21, 1.0),       # Case A\n        (21, 1e12),      # Case B (10^12)\n        (21, 1e-3),      # Case C (10^-3)\n        (3, 1.0),        # Case D\n    ]\n    \n    M = 2001\n    results = []\n    \n    for N, tau in test_cases:\n        max_err = calculate_max_error(N, tau, M)\n        # The problem asks for the floating-point number to be rounded.\n        results.append(round(max_err, 6))\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3163936"}]}