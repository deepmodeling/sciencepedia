{"hands_on_practices": [{"introduction": "在科学和工程领域，我们经常通过实验或测量获得离散的数据点。为了从这些点中估计未知值，我们需要一个连续的模型。线性样条插值通过用直线段连接相邻数据点，提供了一种构建这种模型的最直接的方法。本练习将带你实践如何使用线性插值公式，这是数据分析和数值方法中的一项基本技能。[@problem_id:2185168]", "problem": "在一种药物溶液的质量控制过程中，一个传感器探头随时间测量活性成分的浓度。由于测量设备的限制，探头仅在离散的时刻进行读数。收集到的数据点代表时间 $t$（单位：秒）和浓度 $C$（单位：毫克/升，mg/L），分别为 $(2, 5.1)$、$(4, 1.3)$ 和 $(7, 6.7)$。\n\n为了从这些离散数据中创建一个连续的浓度分布模型，工程师决定使用线性样条在测量点之间进行插值。使用这个线性样条模型，确定在时间 $t = 5$ 秒时活性成分的估计浓度。\n\n请用 mg/L 表示你的答案，并四舍五入到两位有效数字。", "solution": "线性样条使用直线段在相邻数据点之间进行插值。对于位于 $t=4$ 和 $t=7$ 之间的 $t=5$，我们使用通过 $(t_{1},C_{1})=(4,1.3)$ 和 $(t_{2},C_{2})=(7,6.7)$ 的直线。\n\n此区间上的线性插值公式为\n$$\nC(t)=C_{1}+\\frac{C_{2}-C_{1}}{t_{2}-t_{1}}\\left(t-t_{1}\\right).\n$$\n代入数值并简化斜率，\n$$\n\\frac{C_{2}-C_{1}}{t_{2}-t_{1}}=\\frac{6.7-1.3}{7-4}=\\frac{5.4}{3}=1.8.\n$$\n在 $t=5$ 处求值，\n$$\nC(5)=1.3+1.8\\,(5-4)=1.3+1.8=3.1.\n$$\n四舍五入到两位有效数字，估计值仍为 $3.1$。", "answer": "$$\\boxed{3.1}$$", "id": "2185168"}, {"introduction": "线性样条虽然是连续的，但在连接数据点的“节点”处并不平滑。这些“扭结”或尖角意味着样条的导数在这些点上是不连续的。本练习通过计算导数在节点处的跳跃值，来量化这种不平滑性。通过这个实践，你将更深刻地理解样条的连续性（即它们是 $C^0$ 连续但不是 $C^1$ 连续的），这对于为特定应用选择合适的样条至关重要。[@problem_id:2185160]", "problem": "一个线性样条函数 $S(x)$ 被构建用于插值一组数据点。用于此构建的数据点是 $(x_0, y_0) = (0, 0)$、$(x_1, y_1) = (1, 5)$ 和 $(x_2, y_2) = (2, 3)$。该样条由两条线性段组成，第一条连接前两个点，第二条连接后两个点。\n\n样条的导数 $S'(x)$ 在每个开区间 $(x_0, x_1)$ 和 $(x_1, x_2)$ 内是良定义的，但通常在内部节点 $x_1 = 1$ 处不连续。\n\n计算在节点 $x=1$ 处导数的跳跃值，该值定义为右导数与左导数之差，$S'(1^+) - S'(1^-)$。", "solution": "在每个区间 $\\left[x_{i},x_{i+1}\\right]$ 上的线性样条是线性插值函数\n$$\nS(x)=y_{i}+\\frac{y_{i+1}-y_{i}}{x_{i+1}-x_{i}}\\left(x-x_{i}\\right),\n$$\n因此它在 $(x_{i},x_{i+1})$ 上的导数是常数斜率\n$$\nS'(x)=\\frac{y_{i+1}-y_{i}}{x_{i+1}-x_{i}}.\n$$\n对于 $\\left[x_{0},x_{1}\\right]=[0,1]$，斜率为\n$$\nm_{01}=\\frac{y_{1}-y_{0}}{x_{1}-x_{0}}=\\frac{5-0}{1-0}=5,\n$$\n所以 $S'(1^{-})=5$。对于 $\\left[x_{1},x_{2}\\right]=[1,2]$，斜率为\n$$\nm_{12}=\\frac{y_{2}-y_{1}}{x_{2}-x_{1}}=\\frac{3-5}{2-1}=-2,\n$$\n所以 $S'(1^{+})=-2$。在 $x=1$ 处的跳跃值为\n$$\nS'(1^{+})-S'(1^{-})=m_{12}-m_{01}=-2-5=-7.\n$$", "answer": "$$\\boxed{-7}$$", "id": "2185160"}, {"introduction": "任何数值近似的可靠性都取决于我们对其准确性的理解。对于线性样条，一个重要的理论结果是其误差界，它将近似误差与原函数的二阶导数以及数据点之间的间距联系起来。这个高级练习将理论与实践相结合：你将首先推导这个经典的误差界，然后编写代码来通过实验验证它。这个过程不仅能加深你对数值理论的理解，还能培养你用计算实验来验证数学模型的关键能力。[@problem_id:3155367]", "problem": "考虑一个在闭区间 $[a,b]$ 上定义且二阶连续可微的实值函数 $f$。设 $a = x_0 < x_1 < \\dots < x_n = b$ 是 $[a,b]$ 的一个均匀剖分，其网格宽度为 $h = (b-a)/n$。定义线性样条 $S_h$ 为满足对所有 $i = 0,1,\\dots,n$ 都有 $S_h(x_i) = f(x_i)$ 的连续分段线性插值函数。您的任务如下。\n\n1) 仅使用单个子区间上线性插值的定义、中值定理以及带有拉格朗日余项的泰勒定理，推导在每个子区间 $[x_i, x_{i+1}]$ 上关于插值误差 $|f(x) - S_h(x)|$ 的一个一致（关于 $x$）界，该界用 $h$ 和 $\\max_{[a,b]} |f''(x)|$ 表示。由此，得出一个显式常数 $C$，使得全局无穷范数误差满足形式为 $\\|f - S_h\\|_{\\infty} \\le C\\, h^2 \\max_{x \\in [a,b]} |f''(x)|$ 的不等式。解释为什么常数 $C$ 对于线性插值是锐的。\n\n2) 实现一个程序，该程序为一个均匀剖分构造 $S_h$，并在以下测试套件上经验性地检验第1部分中推导出的界。在所有三角函数的情况下，角度必须以弧度为单位进行解释。对于每种情况，计算：\n- 网格宽度 $h = (b-a)/n$，\n- 通过在 $[a,b]$ 上的 $N_{\\text{eval}}$ 个等距点（其中 $N_{\\text{eval}} = 200001$）上计算 $|f(x) - S_h(x)|$ 的值，来得到 $\\|f - S_h\\|_{\\infty}$ 的一个数值近似，\n- 使用指定的 $f$ 的 $\\max_{[a,b]} |f''(x)|$ 的精确值，计算第1部分中的理论界。\n\n测试套件（每种情况是一个三元组 $(f,[a,b],n)$）：\n- 情况1：$f(x) = \\sin(x)$ 在 $[0,\\pi]$ 上, $n = 10$。\n- 情况2：$f(x) = e^{x}$ 在 $[0,1]$ 上, $n = 8$。\n- 情况3：$f(x) = x^3$ 在 $[0,1]$ 上, $n = 4$。\n- 情况4：$f(x) = x$ 在 $[0,1]$ 上, $n = 7$。\n- 情况5：$f(x) = x^2$ 在 $[-1,1]$ 上, $n = 6$。\n- 情况6（边界情况）：$f(x) = \\sin(x)$ 在 $[0,\\pi]$ 上, $n = 1$。\n\n对于每种情况，让程序返回一个布尔值，该值指示数值估计的 $\\|f - S_h\\|_{\\infty}$ 是否小于或等于理论界加上一个数值容差 $\\tau = 10^{-12}$，以考虑浮点和采样效应。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的布尔值列表，且不含空格。例如，一个包含三种情况的有效输出为“[True,False,True]”。对于此问题，您的输出必须按顺序包含恰好六个对应于六种情况的布尔值。", "solution": "用户提供的问题是有效的，因为它在科学上基于数值分析的原理，提法恰当且包含了所有必要信息，并以客观、正式的语言陈述。它代表了计算科学中的一个标准练习。\n\n按照要求，解决方案分两部分呈现：误差界的理论推导，以及随后通过数值实现进行的经验验证。\n\n### 第1部分：一致误差界的推导\n\n设 $f$ 是一个在 $[a,b]$ 上二阶连续可微的函数。设 $a = x_0 < x_1 < \\dots < x_n = b$ 是一个步长为 $h = (b-a)/n$ 的均匀剖分。线性样条 $S_h(x)$ 是在节点 $x_i$ 处插值 $f(x)$ 的连续分段线性函数，即，对 $i=0, \\dots, n$ 有 $S_h(x_i) = f(x_i)$。\n\n在任意子区间 $[x_i, x_{i+1}]$ 上，线性插值函数 $S_h(x)$ 由连接点 $(x_i, f(x_i))$ 和 $(x_{i+1}, f(x_{i+1}))$ 的唯一线段给出：\n$$\nS_h(x) = f(x_i) \\frac{x_{i+1}-x}{h} + f(x_{i+1}) \\frac{x-x_i}{h} \\quad \\text{for } x \\in [x_i, x_{i+1}]\n$$\n我们的目标是为误差 $e(x) = f(x) - S_h(x)$ 定界。\n\n根据构造，误差在子区间的端点处为零：$e(x_i) = f(x_i) - S_h(x_i) = 0$ 且 $e(x_{i+1}) = f(x_{i+1}) - S_h(x_{i+1}) = 0$。\n\n我们固定一个任意点 $x \\in (x_i, x_{i+1})$。为了找到 $e(x)$ 的表达式，我们定义一个辅助函数 $\\phi(t)$：\n$$\n\\phi(t) = e(t) - K(t-x_i)(t-x_{i+1})\n$$\n其中常数 $K$ 的选择使得 $\\phi(x) = 0$。这给出：\n$$\nK = \\frac{e(x)}{(x-x_i)(x-x_{i+1})}\n$$\n函数 $\\phi(t)$ 被构造成在区间 $[x_i, x_{i+1}]$ 中有三个不同的根：$\\phi(x_i)=0$，$\\phi(x)=0$ 和 $\\phi(x_{i+1})=0$。由于 $f$ 是二阶连续可微的，因此 $e(t) = f(t) - S_h(t)$ 也是，所以 $\\phi(t)$ 在 $[x_i, x_{i+1}]$ 上也是二阶连续可微的。\n\n通过对 $\\phi(t)$ 应用 Rolle 定理（中值定理的一个推论），我们可以断言存在两个点 $\\eta_1 \\in (x_i, x)$ 和 $\\eta_2 \\in (x, x_{i+1})$，使得 $\\phi'(\\eta_1)=0$ 和 $\\phi'(\\eta_2)=0$。\n\n再次对区间 $[\\eta_1, \\eta_2]$ 上的 $\\phi'(t)$ 应用 Rolle 定理，我们发现存在一个点 $\\xi \\in (\\eta_1, \\eta_2) \\subset (x_i, x_{i+1})$，使得 $\\phi''(\\xi)=0$。\n\n我们来计算 $\\phi(t)$ 的二阶导数：\n$$\n\\phi'(t) = e'(t) - K(2t - x_i - x_{i+1})\n$$\n$$\n\\phi''(t) = e''(t) - 2K\n$$\n由于 $S_h(t)$ 在 $[x_i, x_{i+1}]$ 上是一个线性函数，其二阶导数 $S_h''(t)=0$ 对 $t \\in (x_i, x_{i+1})$ 成立。因此，$e''(t) = f''(t) - S_h''(t) = f''(t)$。所以，我们有：\n$$\n\\phi''(t) = f''(t) - 2K\n$$\n在点 $t=\\xi$ 处，我们有 $\\phi''(\\xi) = f''(\\xi) - 2K = 0$，这意味着 $K = \\frac{f''(\\xi)}{2}$。\n\n将我们得到的两个 $K$ 的表达式相等，我们得到：\n$$\n\\frac{e(x)}{(x-x_i)(x-x_{i+1})} = \\frac{f''(\\xi)}{2}\n$$\n这给出了在点 $x$ 处的精确误差：\n$$\ne(x) = f(x) - S_h(x) = \\frac{f''(\\xi)}{2} (x-x_i)(x-x_{i+1})\n$$\n其中某个 $\\xi \\in (x_i, x_{i+1})$ 依赖于 $x$。\n\n为了找到在 $[x_i, x_{i+1}]$ 上误差的一致界，我们取绝对值并求其最大值：\n$$\n|e(x)| = \\left| \\frac{f''(\\xi)}{2} (x-x_i)(x-x_{i+1}) \\right| \\le \\frac{1}{2} \\max_{t \\in [x_i, x_{i+1}]} |f''(t)| \\cdot |(x-x_i)(x-x_{i+1})|\n$$\n项 $w(x) = (x-x_i)(x-x_{i+1})$ 是一个二次函数，在它的根 $x_i$ 和 $x_{i+1}$ 之间为负。其最大绝对值出现在区间的中点，即 $x = (x_i+x_{i+1})/2 = x_i + h/2$。\n$$\n\\max_{x \\in [x_i, x_{i+1}]} |w(x)| = \\left| \\left(\\frac{x_i+x_{i+1}}{2} - x_i\\right) \\left(\\frac{x_i+x_{i+1}}{2} - x_{i+1}\\right) \\right| = \\left| \\left(\\frac{h}{2}\\right) \\left(-\\frac{h}{2}\\right) \\right| = \\frac{h^2}{4}\n$$\n将此代入不等式，我们得到在子区间 $[x_i, x_{i+1}]$ 上的误差界：\n$$\n|f(x) - S_h(x)| \\le \\frac{h^2}{8} \\max_{t \\in [x_i, x_{i+1}]} |f''(t)|\n$$\n以无穷范数 $\\|f - S_h\\|_{\\infty}$ 度量的全局误差是整个区间 $[a,b]$ 上的最大误差：\n$$\n\\|f - S_h\\|_{\\infty} = \\max_{x \\in [a,b]} |f(x) - S_h(x)| = \\max_{i=0,\\dots,n-1} \\left( \\max_{x \\in [x_i, x_{i+1}]} |f(x) - S_h(x)| \\right)\n$$\n使用我们的子区间界：\n$$\n\\|f - S_h\\|_{\\infty} \\le \\max_{i=0,\\dots,n-1} \\left( \\frac{h^2}{8} \\max_{t \\in [x_i, x_{i+1}]} |f''(t)| \\right) = \\frac{h^2}{8} \\max_{t \\in [a,b]} |f''(t)|\n$$\n这给出了期望的不等式 $\\|f - S_h\\|_{\\infty} \\le C h^2 \\max_{x \\in [a,b]} |f''(x)|$，其中常数 $C = 1/8$。\n\n为了证明常数 $C=1/8$ 是锐的，我们必须展示一个达到等号的情况。考虑在任意长度为 $h$ 的区间 $[x_i, x_{i+1}]$ 上的函数 $f(x) = x^2$。其二阶导数为常数，$f''(x) = 2$。\n理论界为 $\\frac{h^2}{8} \\max |f''(x)| = \\frac{h^2}{8} \\cdot 2 = \\frac{h^2}{4}$。\n精确误差为 $e(x) = f(x) - S_h(x)$。在中点 $x_m = (x_i+x_{i+1})/2$ 处，样条函数的值为 $S_h(x_m) = \\frac{1}{2}(f(x_i)+f(x_{i+1})) = \\frac{1}{2}(x_i^2 + x_{i+1}^2)$。\n在中点处的误差为：\n$$\ne(x_m) = f(x_m) - S_h(x_m) = \\left(\\frac{x_i+x_{i+1}}{2}\\right)^2 - \\frac{x_i^2+x_{i+1}^2}{2} = \\frac{x_i^2+2x_ix_{i+1}+x_{i+1}^2}{4} - \\frac{2x_i^2+2x_{i+1}^2}{4} = -\\frac{(x_{i+1}-x_i)^2}{4} = -\\frac{h^2}{4}\n$$\n中点处的绝对误差为 $|e(x_m)| = h^2/4$，这与理论界相匹配。由于我们找到了一个函数使得该界得以达到，因此常数 $C=1/8$ 不能被改进，所以是锐的。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and verifies the linear spline interpolation error bound for a suite of test cases.\n    \"\"\"\n    # Define the test cases as a list of tuples.\n    # Each tuple contains: (function f, max|f''|, interval [a,b], number of subintervals n).\n    test_cases = [\n        (lambda x: np.sin(x), 1.0, (0, np.pi), 10),\n        (lambda x: np.exp(x), np.e, (0, 1), 8),\n        (lambda x: x**3, 6.0, (0, 1), 4),\n        (lambda x: x, 0.0, (0, 1), 7),\n        (lambda x: x**2, 2.0, (-1, 1), 6),\n        (lambda x: np.sin(x), 1.0, (0, np.pi), 1),\n    ]\n\n    results = []\n    N_eval = 200001\n    tolerance = 1e-12\n\n    for f, M2, interval, n in test_cases:\n        a, b = interval\n        \n        # 1. Calculate mesh width\n        h = (b - a) / n\n\n        # 2. Calculate the theoretical error bound\n        # Bound = C * h^2 * M2, where C = 1/8\n        theoretical_bound = (1/8) * h**2 * M2\n\n        # 3. Construct the linear spline and estimate the infinity-norm error\n        \n        # Define the interpolation nodes\n        x_nodes = np.linspace(a, b, n + 1)\n        y_nodes = f(x_nodes)\n        \n        # Define the fine grid for error evaluation\n        x_eval = np.linspace(a, b, N_eval)\n        \n        # Evaluate the original function on the fine grid\n        y_f_eval = f(x_eval)\n        \n        # Evaluate the linear spline on the fine grid\n        # numpy.interp performs piecewise-linear interpolation\n        y_s_eval = np.interp(x_eval, x_nodes, y_nodes)\n        \n        # Compute the numerical approximation of the infinity-norm error\n        numerical_error = np.max(np.abs(y_f_eval - y_s_eval))\n        \n        # 4. Compare the numerical error with the theoretical bound\n        is_valid = numerical_error = theoretical_bound + tolerance\n        results.append(is_valid)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3155367"}]}