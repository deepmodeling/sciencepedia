{"hands_on_practices": [{"introduction": "掌握三次样条的第一步是亲手计算并体会它与更简单的插值方法的区别。这个练习 [@problem_id:2164998] 将引导你对同一组简单的数据点，分别使用分段线性插值和自然三次样条进行计算。通过直接比较，你将清晰地看到样条是如何生成一条平滑曲线的，并熟悉求解样条核心参数的基本流程。", "problem": "一位工程师正在为一个薄而柔韧的杆的形状建模，该杆被约束穿过二维笛卡尔平面中的三个点：$P_0=(-1, 1)$、$P_1=(0, 0)$ 和 $P_2=(1, 1)$。提出了两种简单的模型来估计杆在其他水平位置 $x$ 处的垂直位置 $y$。\n\n模型A是分段线性插值，它用直线段连接指定的点。\n模型B是自然三次样条，它通过匹配内点处的一阶和二阶导数来确保曲线是光滑的，并且在端点处具有零二阶导数。\n\n计算在 $x=0.5$ 处，由模型A和模型B预测的杆的垂直位置。设这些值分别为 $y_A$ 和 $y_B$。将您的答案表示为一对精确分数 $(y_A, y_B)$。", "solution": "我们将节点标记为 $x_{0}=-1$、$x_{1}=0$、$x_{2}=1$，对应的值为 $y_{0}=1$、$y_{1}=0$、$y_{2}=1$。\n\n模型A（分段线性插值）：对于 $x \\in [x_{1},x_{2}]$，穿过 $(0,0)$ 和 $(1,1)$ 的直线的斜率为\n$$\nm=\\frac{y_{2}-y_{1}}{x_{2}-x_{1}}=\\frac{1-0}{1-0}=1,\n$$\n所以插值函数是\n$$\ny(x)=y_{1}+m(x-x_{1})=0+1\\cdot(x-0)=x.\n$$\n在 $x=\\frac{1}{2}$ 处求值得到\n$$\ny_{A}=y\\!\\left(\\frac{1}{2}\\right)=\\frac{1}{2}.\n$$\n\n模型B（自然三次样条）：设 $M_{i}=S''(x_{i})$。自然边界条件给出 $M_{0}=0$ 和 $M_{2}=0$。当 $h_{0}=x_{1}-x_{0}=1$ 和 $h_{1}=x_{2}-x_{1}=1$ 时，在内节点 $i=1$ 处的三次样条方程组为\n$$\nh_{0}M_{0}+2(h_{0}+h_{1})M_{1}+h_{1}M_{2}=6\\left(\\frac{y_{2}-y_{1}}{h_{1}}-\\frac{y_{1}-y_{0}}{h_{0}}\\right).\n$$\n代入数值，\n$$\n1\\cdot 0+2(1+1)M_{1}+1\\cdot 0=6\\left(\\frac{1-0}{1}-\\frac{0-1}{1}\\right)=6(1-(-1))=12,\n$$\n所以\n$$\n4M_{1}=12 \\quad \\Rightarrow \\quad M_{1}=3.\n$$\n在区间 $[x_{1},x_{2}]=[0,1]$ 上，样条函数为\n$$\nS(x)=\\frac{M_{1}}{6h_{1}}(x_{2}-x)^{3}+\\frac{M_{2}}{6h_{1}}(x-x_{1})^{3}+\\left(y_{1}-\\frac{M_{1}h_{1}^{2}}{6}\\right)\\frac{x_{2}-x}{h_{1}}+\\left(y_{2}-\\frac{M_{2}h_{1}^{2}}{6}\\right)\\frac{x-x_{1}}{h_{1}}.\n$$\n当 $h_{1}=1$，$M_{1}=3$，$M_{2}=0$，$y_{1}=0$ 和 $y_{2}=1$ 时，这简化为\n$$\nS(x)=\\frac{3}{6}(1-x)^{3}+0+\\left(0-\\frac{3}{6}\\right)(1-x)+\\left(1-0\\right)x\n=\\frac{1}{2}(1-x)^{3}-\\frac{1}{2}(1-x)+x.\n$$\n展开并合并同类项，\n$$\nS(x)=\\frac{1}{2}-\\frac{3}{2}x+\\frac{3}{2}x^{2}-\\frac{1}{2}x^{3}-\\frac{1}{2}+\\frac{1}{2}x+x\n=\\frac{3}{2}x^{2}-\\frac{1}{2}x^{3}.\n$$\n在 $x=\\frac{1}{2}$ 处求值得到\n$$\ny_{B}=S\\!\\left(\\frac{1}{2}\\right)=\\frac{3}{2}\\left(\\frac{1}{2}\\right)^{2}-\\frac{1}{2}\\left(\\frac{1}{2}\\right)^{3}\n=\\frac{3}{2}\\cdot\\frac{1}{4}-\\frac{1}{2}\\cdot\\frac{1}{8}\n=\\frac{3}{8}-\\frac{1}{16}\n=\\frac{5}{16}.\n$$\n\n因此，所求的数对是 $\\left(\\frac{1}{2},\\frac{5}{16}\\right)$。", "answer": "$$\\boxed{\\left(\\frac{1}{2}, \\frac{5}{16}\\right)}$$", "id": "2164998"}, {"introduction": "真正理解一个数学工具，意味着不仅要会正向应用，还要能理解其内在的约束关系。这个练习 [@problem_id:2164965] 提供了一个有趣的“逆向问题”：它不再是给你所有数据点求样条，而是给你样条的一个关键属性（二阶导数值 $S''$），让你反推出一个未知的数据点。这会加深你对数据点、二阶导数以及它们之间赖以联系的三对角方程组的理解。", "problem": "一个记作 $S(x)$ 的自然三次样条被用来插值一组三个数据点：$(x_0, y_0) = (0, 0)$、$(x_1, y_1) = (1, y_1)$ 和 $(x_2, y_2) = (2, 0)$。纵坐标 $y_1$ 的值是未知的。三次样条是一个分段三次且二阶连续可微的函数。对于自然三次样条，其在端点处的二阶导数为零。\n\n另已确定，该样条在内部点 $x_1=1$ 处的二阶导数恰好为 $S''(1) = 6$。利用此信息，确定 $y_1$ 的值。", "solution": "令 $x_{0}=0$，$x_{1}=1$，$x_{2}=2$，且 $y_{0}=0$，$y_{1}$ 未知，$y_{2}=0$。记 $M_{i}=S''(x_{i})$。对于自然三次样条，有 $M_{0}=0$ 和 $M_{2}=0$，并且已知 $M_{1}=6$。\n\n对于三次样条，其在节点处的二阶导数满足标准的三对角关系式（该关系式通过在内部节点处强制 $S'(x)$ 连续得到）：\n$$\nh_{0} M_{0} + 2\\left(h_{0}+h_{1}\\right) M_{1} + h_{1} M_{2}\n= 6\\left(\\frac{y_{2}-y_{1}}{h_{1}} - \\frac{y_{1}-y_{0}}{h_{0}}\\right),\n$$\n其中 $h_{i}=x_{i+1}-x_{i}$。在这里，$h_{0}=x_{1}-x_{0}=1$ 且 $h_{1}=x_{2}-x_{1}=1$，因此方程变为\n$$\nM_{0} + 4 M_{1} + M_{2} = 6\\left((y_{2}-y_{1}) - (y_{1}-y_{0})\\right) = 6(y_{2} - 2 y_{1} + y_{0}).\n$$\n代入 $M_{0}=0$、$M_{1}=6$、$M_{2}=0$、$y_{0}=0$ 和 $y_{2}=0$，我们得到\n$$\n0 + 4\\cdot 6 + 0 = 6(0 - 2 y_{1} + 0),\n$$\n因此\n$$\n24 = -12 y_{1} \\quad \\Longrightarrow \\quad y_{1} = -2。\n$$", "answer": "$$\\boxed{-2}$$", "id": "2164965"}, {"introduction": "在实际应用中，数值方法的选择会直接影响结果的质量，而三次样条也不例外。自然三次样条在其端点处二阶导数为零的“自然”假设，有时会引入不符合直觉的振荡，特别是在数据点斜率变化剧烈时。这个练习 [@problem_id:3220873] 要求你通过编程，比较自然样条和端点固定的“钳制样条”在处理这类问题时的表现，从而直观地理解边界条件对样条行为的决定性影响。", "problem": "要求您从第一性原理出发，实现具有两种不同端点边界条件的三次样条插值函数的构建和求值：自然边界条件和钳位边界条件。三次样条被定义为一个由连续子区间上的分段三次多项式组成的函数，它对给定的数据点进行插值，并在整个定义域上二阶连续可微。自然边界条件将端点的二阶导数设置为零，而钳位边界条件指定端点的一阶导数。您的任务是：\n- 推导一种算法公式，用于为严格递增的横坐标 $\\{x_i\\}_{i=0}^{n-1}$ 和纵坐标 $\\{y_i\\}_{i=0}^{n-1}$ 计算唯一的三次样条插值函数，此公式需适用于自然或钳位边界条件。推导必须从其定义属性开始：分段三次、插值约束以及在内部节点处直至二阶导数的连续性。\n- 实现两种边界条件的选择。对于钳位边界条件，使用由单侧割线斜率给出的端点导数，\n$$\ns_0 \\equiv \\frac{y_1 - y_0}{x_1 - x_0}, \\quad s_{n-1} \\equiv \\frac{y_{n-1} - y_{n-2}}{x_{n-1} - x_{n-2}}.\n$$\n\n为了量化反直觉的振荡，将一个子区间 $[x_i,x_{i+1}]$ 上的过冲幅度定义如下。令 $m_i = \\min\\{y_i,y_{i+1}\\}$ 且 $M_i = \\max\\{y_i,y_{i+1}\\}$。令 $S(x)$ 表示样条函数值。在 $[x_i,x_{i+1}]$ 上的过冲幅度是\n$$\n\\Delta_i \\equiv \\max\\Big\\{ \\max_{x \\in [x_i,x_{i+1}]} \\big(S(x) - M_i\\big), \\ \\max_{x \\in [x_i,x_{i+1}]}\\big(m_i - S(x)\\big), \\ 0 \\Big\\}.\n$$\n全局过冲为 $\\Delta \\equiv \\max_i \\Delta_i$。通过在每个 $[x_i,x_{i+1}]$ 上的1001个点的均匀网格上计算 $S(x)$ 来数值逼近子区间上的最大值。\n\n实现一个单一的程序，该程序：\n- 为测试套件中的每个数据集构建自然样条和钳位样条（使用上述的 $s_0$ 和 $s_{n-1}$）。\n- 计算并报告每个样条的全局过冲 $\\Delta$。\n\n您的实现必须是完全自包含的，并且除了指定的库之外，不得调用外部库。所有计算均为纯数学计算（无物理单位）。\n\n测试套件。使用以下数据集，每个数据集都以等长且 $x$ 严格递增的列表 $x$ 和 $y$ 的形式给出：\n\n- 情况 A（左端变陡，导致在左端点附近产生大的自然样条振荡）：\n  - $x = [\\,0.0,\\,0.5,\\,0.6,\\,2.0\\,]$\n  - $y = [\\,0.0,\\,1.0,\\,10.0,\\,12.0\\,]$\n\n- 情况 B（近线性，理想情况）：\n  - $x = [\\,0.0,\\,1.0,\\,2.0,\\,3.0\\,]$\n  - $y = [\\,0.0,\\,1.0,\\,2.0,\\,3.0\\,]$\n\n- 情况 C（右端变陡，导致在右端点附近产生自然样条振荡）：\n  - $x = [\\,0.0,\\,1.4,\\,1.5,\\,2.0\\,]$\n  - $y = [\\,0.0,\\,2.0,\\,3.0,\\,3.2\\,]$\n\n对于每种情况，计算并返回一对过冲幅度 $\\Delta_{\\text{natural}}$ 和 $\\Delta_{\\text{clamped}}$，作为浮点数。您的程序应生成单行输出，其中包含按顺序连接的所有结果，形式为方括号内以逗号分隔的列表，顺序如下\n$$\n[\\,\\Delta_{\\text{natural}}^{(A)},\\,\\Delta_{\\text{clamped}}^{(A)},\\,\\Delta_{\\text{natural}}^{(B)},\\,\\Delta_{\\text{clamped}}^{(B)},\\,\\Delta_{\\text{natural}}^{(C)},\\,\\Delta_{\\text{clamped}}^{(C)}\\,].\n$$", "solution": "用户要求推导和实现具有自然和钳位两种边界条件的三次样条插值。推导必须从第一性原理出发，实现部分必须计算几个测试用例的全局过冲。\n\n### 三次样条插值的推导\n\n一个三次样条 $S(x)$ 插值一组 $n$ 个数据点 $(x_i, y_i)$（$i=0, 1, \\ldots, n-1$，横坐标 $x_0  x_1  \\ldots  x_{n-1}$ 严格递增），它是在 $[x_0, x_{n-1}]$ 上定义的分段函数。对于每个子区间 $[x_i, x_{i+1}]$，样条段 $S_i(x)$ 是一个三次多项式。整个样条 $S(x)$ 必须满足以下属性：\n1.  **插值**：对所有 $i=0, \\ldots, n-1$，有 $S(x_i) = y_i$。\n2.  **连续性**：$S(x)$ 在 $[x_0, x_{n-1}]$ 上二阶连续可微，即 $S \\in C^2[x_0, x_{n-1}]$。这意味着在每个内部节点 $x_i$（$i=1, \\ldots, n-2$）处，有 $S_{i-1}(x_i) = S_i(x_i)$，$S'_{i-1}(x_i) = S'_i(x_i)$，以及 $S''_{i-1}(x_i) = S''_i(x_i)$。\n\n让我们将在节点处的样条二阶导数定义为 $M_i = S''(x_i)$（$i=0, \\ldots, n-1$）。由于每个样条段 $S_i(x)$ 是三次多项式，其二阶导数 $S_i''(x)$ 是一个线性函数。在区间 $[x_i, x_{i+1}]$ 上，$S_i''(x)$ 经过点 $(x_i, M_i)$ 和 $(x_{i+1}, M_{i+1})$。令 $h_i = x_{i+1} - x_i$。线性函数 $S_i''(x)$ 可以使用拉格朗日线性插值公式写成：\n$$\nS_i''(x) = M_i \\frac{x_{i+1} - x}{h_i} + M_{i+1} \\frac{x - x_i}{h_i}\n$$\n将 $S_i''(x)$ 对 $x$ 积分两次，得到三次多项式 $S_i(x)$ 的一般形式：\n$$\nS_i(x) = M_i \\frac{(x_{i+1} - x)^3}{6h_i} + M_{i+1} \\frac{(x - x_i)^3}{6h_i} + C(x-x_i) + D(x_{i+1}-x)\n$$\n其中 $C$ 和 $D$ 是积分常数，其表达式形式便于应用插值条件。\n我们强制执行插值条件 $S_i(x_i) = y_i$ 和 $S_i(x_{i+1}) = y_{i+1}$：\n在 $x=x_i$ 处：$y_i = M_i \\frac{h_i^3}{6h_i} + D h_i \\implies D = \\frac{y_i}{h_i} - \\frac{M_i h_i}{6}$。\n在 $x=x_{i+1}$ 处：$y_{i+1} = M_{i+1} \\frac{h_i^3}{6h_i} + C h_i \\implies C = \\frac{y_{i+1}}{h_i} - \\frac{M_{i+1} h_i}{6}$。\n\n将这些常数代回，我们得到样条段 $S_i(x)$ 的表达式，它用已知数据点和未知的二阶导数 $M_i$ 表示：\n$$\nS_i(x) = \\frac{M_i}{6h_i}(x_{i+1}-x)^3 + \\frac{M_{i+1}}{6h_i}(x-x_i)^3 + \\left(\\frac{y_{i+1}}{h_i} - \\frac{M_{i+1}h_i}{6}\\right)(x-x_i) + \\left(\\frac{y_i}{h_i} - \\frac{M_i h_i}{6}\\right)(x_{i+1}-x)\n$$\n这个方程定义了每个子区间 $[x_i, x_{i+1}]$（$i=0, \\ldots, n-2$）上的样条。为了找到未知值 $M_i$，我们使用一阶导数的连续性条件 $S'_{i-1}(x_i) = S'_i(x_i)$，在内部节点 $x_i$（$i=1, \\ldots, n-2$）处。\n\n首先，我们求导数 $S'_i(x)$：\n$$\nS'_i(x) = -\\frac{M_i}{2h_i}(x_{i+1}-x)^2 + \\frac{M_{i+1}}{2h_i}(x-x_i)^2 + \\left(\\frac{y_{i+1}}{h_i} - \\frac{M_{i+1}h_i}{6}\\right) - \\left(\\frac{y_i}{h_i} - \\frac{M_i h_i}{6}\\right)\n$$\n在节点处计算导数值：\n$S'_i(x_i) = -\\frac{M_i h_i}{2} + \\frac{y_{i+1}-y_i}{h_i} - \\frac{M_{i+1}h_i}{6} + \\frac{M_i h_i}{6} = \\frac{y_{i+1}-y_i}{h_i} - \\frac{h_i}{3}M_i - \\frac{h_i}{6}M_{i+1}$。\n$S'_{i-1}(x_i) = \\frac{M_{i-1}h_{i-1}}{6} + \\frac{M_i h_{i-1}}{3} + \\frac{y_i-y_{i-1}}{h_{i-1}}$。\n\n对于 $i=1, \\ldots, n-2$，令 $S'_{i-1}(x_i) = S'_i(x_i)$：\n$$\n\\frac{y_i-y_{i-1}}{h_{i-1}} + \\frac{h_{i-1}}{6}M_{i-1} + \\frac{h_{i-1}}{3}M_i = \\frac{y_{i+1}-y_i}{h_i} - \\frac{h_i}{3}M_i - \\frac{h_i}{6}M_{i+1}\n$$\n重新整理各项，将未知数 $M_{i-1}$、$M_i$ 和 $M_{i+1}$ 组合在一起：\n$$\nh_{i-1}M_{i-1} + (2h_{i-1} + 2h_i)M_i + h_iM_{i+1} = 6\\left(\\frac{y_{i+1}-y_i}{h_i} - \\frac{y_i-y_{i-1}}{h_{i-1}}\\right)\n$$\n这个基本关系为 $n$ 个未知数 $M_0, \\ldots, M_{n-1}$ 提供了 $n-2$ 个线性方程组。为了获得唯一解，我们需要两个额外的方程，这两个方程由边界条件提供。\n\n### 边界条件\n\n**1. 自然样条：**\n自然边界条件指定端点处的曲率为零：$S''(x_0)=0$ 和 $S''(x_{n-1})=0$。这直接转化为：\n$$\nM_0 = 0, \\quad M_{n-1} = 0\n$$\n将这些代入通用系统后，剩下 $n-2$ 个方程，用于求解 $n-2$ 个未知数 $M_1, \\ldots, M_{n-2}$。该系统形成一个严格对角占优的三对角矩阵，保证了唯一解的存在。\n\n**2. 钳位样条：**\n钳位边界条件指定了端点处的一阶导数：$S'(x_0)=s_0$ 和 $S'(x_{n-1})=s_{n-1}$。\n使用我们对 $S'_i(x_i)$ 的表达式，我们令 $i=0$：\n$S'(x_0) = S'_0(x_0) = \\frac{y_1-y_0}{h_0} - \\frac{h_0}{3}M_0 - \\frac{h_0}{6}M_1 = s_0$。\n整理后得到第一个边界方程：\n$$\n2h_0M_0 + h_0M_1 = 6\\left(\\frac{y_1-y_0}{h_0} - s_0\\right)\n$$\n对于 $x_{n-1}$ 处的条件，我们计算 $S'_{n-2}(x_{n-1})=s_{n-1}$：\n$S'_{n-2}(x_{n-1}) = \\frac{y_{n-1}-y_{n-2}}{h_{n-2}} + \\frac{h_{n-2}}{6}M_{n-2} + \\frac{h_{n-2}}{3}M_{n-1} = s_{n-1}$。\n整理后得到第二个边界方程：\n$$\nh_{n-2}M_{n-2} + 2h_{n-2}M_{n-1} = 6\\left(s_{n-1} - \\frac{y_{n-1}-y_{n-2}}{h_{n-2}}\\right)\n$$\n问题指定了 $s_0$ 和 $s_{n-1}$ 的特定值：\n$s_0 = \\frac{y_1 - y_0}{x_1 - x_0} = \\frac{y_1 - y_0}{h_0}$\n$s_{n-1} = \\frac{y_{n-1} - y_{n-2}}{x_{n-1} - x_{n-2}} = \\frac{y_{n-1} - y_{n-2}}{h_{n-2}}$\n选择这些值后，两个边界方程的右侧都变为零：\n$2h_0M_0 + h_0M_1 = 0 \\implies 2M_0 + M_1 = 0$。\n$h_{n-2}M_{n-2} + 2h_{n-2}M_{n-1} = 0 \\implies M_{n-2} + 2M_{n-1} = 0$。\n这两个方程与 $n-2$ 个内部方程相结合，为未知数 $M_0, \\ldots, M_{n-1}$ 形成一个完整的 $n \\times n$ 三对角系统。该系统也是严格对角占优的，并且有唯一解。\n\n### 过冲计算\n\n子区间 $[x_i, x_{i+1}]$ 上的过冲幅度定义为：\n$$\n\\Delta_i = \\max\\left\\{ \\max_{x \\in [x_i,x_{i+1}]} \\left(S(x) - \\max\\{y_i,y_{i+1}\\}\\right), \\ \\max_{x \\in [x_i,x_{i+1}]}\\left(\\min\\{y_i,y_{i+1}\\} - S(x)\\right), \\ 0 \\right\\}\n$$\n全局过冲是所有子区间的最大值，$\\Delta = \\max_i \\Delta_i$。在计算上，通过在跨越 $[x_i, x_{i+1}]$ 的一个包含1001个点的精细均匀网格上评估样条函数 $S(x)$，来逼近每个子区间上的最大值。此过程量化了样条函数在其插值数据点范围之外振荡的程度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_tdma(lower, main, upper, d):\n    \"\"\"\n    Solves a tridiagonal system of equations Ax=d using the Thomas algorithm.\n\n    Args:\n        lower (np.ndarray): The lower diagonal of A (length n-1).\n        main (np.ndarray): The main diagonal of A (length n).\n        upper (np.ndarray): The upper diagonal of A (length n-1).\n        d (np.ndarray): The right-hand side vector (length n).\n\n    Returns:\n        np.ndarray: The solution vector x.\n    \"\"\"\n    n = len(main)\n    c_p = np.zeros(n)\n    d_p = np.zeros(n)\n\n    # Forward elimination\n    c_p[0] = upper[0] / main[0]\n    d_p[0] = d[0] / main[0]\n    for i in range(1, n):\n        denom = main[i] - lower[i-1] * c_p[i-1]\n        if i  n - 1:\n            c_p[i] = upper[i] / denom\n        d_p[i] = (d[i] - lower[i-1] * d_p[i-1]) / denom\n\n    # Backward substitution\n    x = np.zeros(n)\n    x[n-1] = d_p[n-1]\n    for i in range(n-2, -1, -1):\n        x[i] = d_p[i] - c_p[i] * x[i+1]\n    return x\n\nclass CubicSpline:\n    \"\"\"\n    A class for computing and evaluating cubic spline interpolants.\n    \"\"\"\n    def __init__(self, x, y, bc_type='natural'):\n        self.x = np.asarray(x, dtype=float)\n        self.y = np.asarray(y, dtype=float)\n        self.n = len(x)\n        \n        if self.n  2:\n            raise ValueError(\"Need at least 2 points for interpolation.\")\n        \n        self.h = self.x[1:] - self.x[:-1]\n        \n        if np.any(self.h = 0):\n            raise ValueError(\"x coordinates must be strictly increasing.\")\n\n        if bc_type == 'natural':\n            self._compute_natural_spline()\n        elif bc_type == 'clamped':\n            self._compute_clamped_spline()\n        else:\n            raise ValueError(f\"Unsupported boundary condition type: {bc_type}\")\n\n    def _compute_natural_spline(self):\n        \"\"\"Computes the second derivatives M for a natural spline.\"\"\"\n        if self.n == 2:\n            self.M = np.zeros(self.n)\n            return\n\n        N = self.n - 2  # Size of the internal system\n        \n        A_lower = self.h[1:-1]\n        A_main = 2 * (self.h[:-1] + self.h[1:])\n        A_upper = self.h[1:-1]\n\n        delta = (self.y[1:] - self.y[:-1]) / self.h\n        b_rhs = 6 * (delta[1:] - delta[:-1])\n\n        M_internal = solve_tdma(A_lower, A_main, A_upper, b_rhs)\n        \n        self.M = np.zeros(self.n)\n        self.M[1:-1] = M_internal\n\n    def _compute_clamped_spline(self):\n        \"\"\"Computes the second derivatives M for a clamped spline with specified derivatives.\"\"\"\n        if self.n == 2:\n            # Linear interpolation for 2 points, second derivatives are zero\n            self.M = np.zeros(self.n)\n            return\n\n        N = self.n\n        A_lower = np.zeros(N - 1)\n        A_main = np.zeros(N)\n        A_upper = np.zeros(N - 1)\n        b_rhs = np.zeros(N)\n\n        # First row from boundary condition: 2*M_0 + M_1 = 0\n        A_main[0] = 2.0\n        A_upper[0] = 1.0\n        b_rhs[0] = 0.0\n\n        # Internal rows\n        delta = (self.y[1:] - self.y[:-1]) / self.h\n        internal_rhs = 6 * (delta[1:] - delta[:-1])\n        b_rhs[1:-1] = internal_rhs\n\n        A_main[1:-1] = 2 * (self.h[:-1] + self.h[1:])\n        A_lower[:-1] = self.h[:-1]\n        A_upper[1:] = self.h[1:]\n\n        # Last row from boundary condition: M_{n-2} + 2*M_{n-1} = 0\n        A_lower[-1] = 1.0\n        A_main[-1] = 2.0\n        b_rhs[-1] = 0.0\n        \n        self.M = solve_tdma(A_lower, A_main, A_upper, b_rhs)\n\n    def evaluate(self, x_eval):\n        \"\"\"Evaluates the spline at given points.\"\"\"\n        x_eval = np.asarray(x_eval)\n        indices = np.searchsorted(self.x, x_eval, side='right') - 1\n        indices = np.clip(indices, 0, self.n - 2)\n\n        xi = self.x[indices]\n        xi1 = self.x[indices + 1]\n        yi = self.y[indices]\n        yi1 = self.y[indices + 1]\n        hi = self.h[indices]\n        Mi = self.M[indices]\n        Mi1 = self.M[indices + 1]\n\n        t = x_eval - xi\n        t_comp = xi1 - x_eval\n        \n        term1 = (Mi / (6 * hi)) * (t_comp**3)\n        term2 = (Mi1 / (6 * hi)) * (t**3)\n        term3 = (yi1 / hi - Mi1 * hi / 6) * t\n        term4 = (yi / hi - Mi * hi / 6) * t_comp\n        \n        return term1 + term2 + term3 + term4\n\ndef calculate_overshoot(spline, n_grid=1001):\n    \"\"\"Calculates the global overshoot magnitude for a given spline.\"\"\"\n    max_overshoot = 0.0\n    for i in range(spline.n - 1):\n        xi, xi1 = spline.x[i], spline.x[i+1]\n        yi, yi1 = spline.y[i], spline.y[i+1]\n        \n        m_i = min(yi, yi1)\n        M_i = max(yi, yi1)\n        \n        x_grid = np.linspace(xi, xi1, n_grid)\n        y_grid = spline.evaluate(x_grid)\n        \n        overshoot = np.max(y_grid) - M_i\n        undershoot = m_i - np.min(y_grid)\n        \n        interval_max_deviation = max(overshoot, undershoot, 0.0)\n        \n        if interval_max_deviation  max_overshoot:\n            max_overshoot = interval_max_deviation\n            \n    return max_overshoot\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case A (left-end steepening)\n        {'x': [0.0, 0.5, 0.6, 2.0], 'y': [0.0, 1.0, 10.0, 12.0]},\n        # Case B (near-linear)\n        {'x': [0.0, 1.0, 2.0, 3.0], 'y': [0.0, 1.0, 2.0, 3.0]},\n        # Case C (right-end steepening)\n        {'x': [0.0, 1.4, 1.5, 2.0], 'y': [0.0, 2.0, 3.0, 3.2]}\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        x = case['x']\n        y = case['y']\n        \n        # Natural Spline\n        natural_spline = CubicSpline(x, y, bc_type='natural')\n        delta_natural = calculate_overshoot(natural_spline)\n        results.append(delta_natural)\n        \n        # Clamped Spline\n        clamped_spline = CubicSpline(x, y, bc_type='clamped')\n        delta_clamped = calculate_overshoot(clamped_spline)\n        results.append(delta_clamped)\n\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3220873"}]}