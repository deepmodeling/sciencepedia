{"hands_on_practices": [{"introduction": "在数值积分中，我们通常学习到复合梯形法则的误差以 $O(h^2)$ 的速度收敛，其中 $h$ 是步长。然而，误差的实际行为可能更为复杂和微妙。本练习将引导您探索一个有趣的“网格共振”现象，该现象在对周期函数进行积分时出现。通过从第一性原理推导误差的精确表达式，您将揭示函数频率与网格间距之间的相互作用如何导致出人意料的高精度或低精度结果，从而强调超越标准误差阶数进行深入分析的重要性 [@problem_id:3125380]。", "problem": "考虑在区间 $[a,b]$ 上的一个均匀剖分，将其分为 $n$ 个宽度为 $h = (b-a)/n$ 的子区间，在此剖分上应用复合梯形法则 (CTR)。根据定义，对于函数 $f(x)$，CTR 近似值为\n$$\nT_{n}[f] = h\\left(\\frac{f(a)}{2} + \\sum_{j=1}^{n-1} f(a+jh) + \\frac{f(b)}{2}\\right).\n$$\n在本问题中，设 $f(x) = \\sin(\\omega x)$，其中 $\\omega > 0$，并考虑区间 $[0,2\\pi]$。请仅使用基本定义和代数恒等式（例如有限几何级数），从第一性原理出发，推导出 CTR 误差\n$$\nE(\\omega,h) = T_{n}[f] - \\int_{0}^{2\\pi} \\sin(\\omega x)\\,dx\n$$\n的闭式表达式，该表达式应为关于 $\\omega$ 和 $h$ 的解析函数，其中 $h = 2\\pi/n$。您的推导应揭示误差如何依赖于网格共振参数 $\\omega h$，并解释在何种条件下，网格的选择会因共振现象而导致具有欺骗性的小误差。基于此分析，请提出一个关于如何选择 $h$ 的有原则的指导方针，以避免由共振引起的误导性接近零的误差。\n\n只需报告用 $\\omega$ 和 $h$ 表示的 $E(\\omega,h)$ 的最终闭式表达式。无需进行数值舍入，也不涉及单位。", "solution": "我们从复合梯形法则 (CTR) 在区间 $[0,2\\pi]$ 上的定义开始，该区间被分为 $n$ 个子区间，具有均匀的网格宽度 $h = 2\\pi/n$。节点为 $x_{j} = jh$，$j=0,1,\\dots,n$。对于函数 $f(x) = \\sin(\\omega x)$，CTR 近似值为\n$$\nT_{n}[f] = h\\left(\\frac{f(0)}{2} + \\sum_{j=1}^{n-1} f(jh) + \\frac{f(2\\pi)}{2}\\right).\n$$\n由于 $f(0) = \\sin(0) = 0$，我们有\n$$\nT_{n}[f] = h\\left(\\sum_{j=1}^{n-1} \\sin(\\omega j h) + \\frac{1}{2}\\sin(\\omega \\cdot 2\\pi)\\right).\n$$\n引入简写 $\\alpha = \\omega h$。那么 $\\omega \\cdot 2\\pi = \\omega n h = n\\alpha$，梯形和变为\n$$\n\\frac{T_{n}[f]}{h} = \\sum_{j=1}^{n-1} \\sin(j\\alpha) + \\frac{1}{2}\\sin(n\\alpha).\n$$\n\n为了计算有限和 $\\sum_{j=1}^{n-1} \\sin(j\\alpha)$，我们使用复指数表示法 $\\sin(\\theta) = \\operatorname{Im}(\\exp(i\\theta))$ 和有限几何级数。复指数的和为\n$$\n\\sum_{j=1}^{m} \\exp(i j \\alpha) = \\exp(i\\alpha)\\,\\frac{1 - \\exp(i m \\alpha)}{1 - \\exp(i\\alpha)}.\n$$\n取虚部并化简，得到标准恒等式\n$$\n\\sum_{j=1}^{m} \\sin(j\\alpha) = \\frac{\\sin\\left(\\frac{m\\alpha}{2}\\right)\\sin\\left(\\frac{(m+1)\\alpha}{2}\\right)}{\\sin\\left(\\frac{\\alpha}{2}\\right)}.\n$$\n令 $m = n-1$ 得到\n$$\n\\sum_{j=1}^{n-1} \\sin(j\\alpha) = \\frac{\\sin\\left(\\frac{(n-1)\\alpha}{2}\\right)\\sin\\left(\\frac{n\\alpha}{2}\\right)}{\\sin\\left(\\frac{\\alpha}{2}\\right)}.\n$$\n因此，\n$$\n\\frac{T_{n}[f]}{h} = \\frac{\\sin\\left(\\frac{(n-1)\\alpha}{2}\\right)\\sin\\left(\\frac{n\\alpha}{2}\\right)}{\\sin\\left(\\frac{\\alpha}{2}\\right)} + \\frac{1}{2}\\sin(n\\alpha).\n$$\n\n我们现在化简此表达式。使用差角恒等式 $\\sin\\left(\\frac{(n-1)\\alpha}{2}\\right) = \\sin\\left(\\frac{n\\alpha}{2} - \\frac{\\alpha}{2}\\right) = \\sin\\left(\\frac{n\\alpha}{2}\\right)\\cos\\left(\\frac{\\alpha}{2}\\right) - \\cos\\left(\\frac{n\\alpha}{2}\\right)\\sin\\left(\\frac{\\alpha}{2}\\right)$，我们得到\n$$\n\\frac{\\sin\\left(\\frac{(n-1)\\alpha}{2}\\right)}{\\sin\\left(\\frac{\\alpha}{2}\\right)} = \\sin\\left(\\frac{n\\alpha}{2}\\right)\\cot\\left(\\frac{\\alpha}{2}\\right) - \\cos\\left(\\frac{n\\alpha}{2}\\right).\n$$\n于是，\n$$\n\\frac{T_{n}[f]}{h} = \\sin\\left(\\frac{n\\alpha}{2}\\right)\\left[\\sin\\left(\\frac{n\\alpha}{2}\\right)\\cot\\left(\\frac{\\alpha}{2}\\right) - \\cos\\left(\\frac{n\\alpha}{2}\\right)\\right] + \\frac{1}{2}\\sin(n\\alpha).\n$$\n使用倍角恒等式 $\\sin(n\\alpha) = 2\\sin\\left(\\frac{n\\alpha}{2}\\right)\\cos\\left(\\frac{n\\alpha}{2}\\right)$ 重写最后一项：\n$$\n\\frac{1}{2}\\sin(n\\alpha) = \\sin\\left(\\frac{n\\alpha}{2}\\right)\\cos\\left(\\frac{n\\alpha}{2}\\right).\n$$\n合并同类项后，$\\cos\\left(\\frac{n\\alpha}{2}\\right)$ 项相互抵消，剩下\n$$\n\\frac{T_{n}[f]}{h} = \\sin^{2}\\left(\\frac{n\\alpha}{2}\\right)\\cot\\left(\\frac{\\alpha}{2}\\right).\n$$\n因此，\n$$\nT_{n}[f] = h\\,\\sin^{2}\\left(\\frac{n\\alpha}{2}\\right)\\cot\\left(\\frac{\\alpha}{2}\\right).\n$$\n\n接下来，计算 $f(x) = \\sin(\\omega x)$ 在 $[0,2\\pi]$ 上的精确积分：\n$$\nI = \\int_{0}^{2\\pi} \\sin(\\omega x)\\,dx = \\left[-\\frac{\\cos(\\omega x)}{\\omega}\\right]_{0}^{2\\pi} = \\frac{1 - \\cos(2\\pi \\omega)}{\\omega}.\n$$\n使用恒等式 $1 - \\cos(\\theta) = 2\\sin^{2}(\\theta/2)$，我们得到\n$$\nI = \\frac{2\\sin^{2}(\\pi \\omega)}{\\omega}.\n$$\n\n回顾 $n\\alpha = n(\\omega h) = \\omega n h = \\omega \\cdot 2\\pi$，所以\n$$\n\\sin^{2}\\left(\\frac{n\\alpha}{2}\\right) = \\sin^{2}(\\pi \\omega),\n$$\n梯形近似值简化为\n$$\nT_{n}[f] = h\\,\\sin^{2}(\\pi \\omega)\\,\\cot\\left(\\frac{\\omega h}{2}\\right).\n$$\n因此，CTR 误差 $E(\\omega,h) = T_{n}[f] - I$ 为\n$$\nE(\\omega,h) = \\sin^{2}(\\pi \\omega)\\left[h\\,\\cot\\left(\\frac{\\omega h}{2}\\right) - \\frac{2}{\\omega}\\right].\n$$\n\n这个闭式表达式通过因子 $\\cot\\left(\\frac{\\omega h}{2}\\right)$ 展示了共振结构，其大小对 $\\omega h$ 与 $2\\pi$ 的整数倍的接近程度高度敏感。具体来说，当 $\\omega h \\to 2\\pi m$ ($m \\in \\mathbb{Z}$) 时，对于小的 $\\delta$，我们有 $\\cot\\left(\\frac{\\omega h}{2}\\right) = \\cot\\left(m\\pi + \\frac{\\delta}{2}\\right) \\approx \\frac{2}{\\delta}$，而 $\\sin^{2}\\left(\\frac{n\\alpha}{2}\\right) = \\sin^{2}(\\pi \\omega)$ 与 $h$ 无关。局部展开显示\n$$\nh\\,\\cot\\left(\\frac{\\omega h}{2}\\right) \\approx \\frac{2h}{\\omega h} = \\frac{2}{\\omega},\n$$\n因此方括号中的项抵消后接近于零。所以，当 $\\omega h$ 接近 $2\\pi m$ 时，无论网格是否精细，$E(\\omega,h)$ 都会变得非常小，这可能因网格共振而非真正的收敛，造成了高精度的假象。相反地，当 $\\omega h$ 接近 $(2m+1)\\pi$ 时，我们有 $\\cot\\left(\\frac{\\omega h}{2}\\right) \\approx 0$ 且 $T_{n}[f] \\approx 0$，因此误差接近 $-I$。如果 $\\sin^{2}(\\pi \\omega)$ 不小，这个误差可能会很大。\n\n为避免误导性的近零误差，一个有原则的网格设计指导方针是确保 $\\omega h$ 与 $2\\pi$ 的整数倍保持一个可控的距离。等价地，可以对 $|\\sin(\\omega h/2)|$ 施加一个下界，例如\n$$\n|\\sin(\\omega h/2)| \\geq \\sigma,\n$$\n其中 $\\sigma \\in (0,1)$ 是一个预设的容差，这可以防止 $\\cot\\left(\\frac{\\omega h}{2}\\right)$ 的量级变得过大，并避免人为的抵消。在实践中，由于 $h = 2\\pi/n$，这转化为选择 $n$ 以使量 $\\omega \\cdot \\frac{2\\pi}{n}$ 与 $2\\pi \\mathbb{Z}$ 保持一个固定的距离，即，\n$$\n\\operatorname{dist}(\\omega h, 2\\pi \\mathbb{Z}) \\geq \\delta,\n$$\n其中 $\\delta > 0$ 是某个选定的、与 $\\sigma$ 相关的值，从而在网格细化过程中稳定误差行为，并防止由共振驱动的假象。\n\n因此，所要求的 CTR 误差的最终解析表达式为\n$$\nE(\\omega,h) = \\sin^{2}(\\pi \\omega)\\left[h\\,\\cot\\left(\\frac{\\omega h}{2}\\right) - \\frac{2}{\\omega}\\right].\n$$", "answer": "$$\\boxed{\\sin^{2}(\\pi \\omega)\\left[h\\,\\cot\\left(\\frac{\\omega h}{2}\\right) - \\frac{2}{\\omega}\\right]}$$", "id": "3125380"}, {"introduction": "认识到误差行为的复杂性之后，一个实际的问题随之而来：在不知道确切答案的情况下，我们如何可靠地估计误差？本练习将对两种常见的误差估计策略进行批判性比较：一种是在两种不同尺寸的网格上（例如步长为 $h$ 和 $h/2$）使用相同的规则，另一种是在同一网格上使用两种不同的规则（例如辛普森法则和梯形法则）。通过精心构造一个特定的函数，本练习将揭示一种看似直观的估计方法可能在何处失效，从而教会我们审慎地对待我们所使用的估计方法背后的假设 [@problem_id:3125467]。", "problem": "考虑光滑函数 $f(x)$ 在 $[0,1]$ 上的定积分，以及在均匀网格上使用复合积分法则。你将比较两种估计复合辛普森法则误差的方法：(i) 基于步长 $h$ 和 $h/2$ 计算复合辛普森积分值的两步估计法，以及 (ii) 通过在同一网格上计算的嵌套法则（此处为复合辛普森法则和复合梯形法则）之差形成的嵌入式估计法。考虑一个具体的四次多项式\n$$\nf(x) \\;=\\; \\frac{16}{3}\\left(\\left(x-\\frac{1}{2}\\right)^{2} - \\frac{1}{16}\\right)\\left(-8\\left(x-\\frac{1}{2}\\right)^{2} + 3\\right),\n$$\n该多项式关于 $x=\\frac{1}{2}$ 对称，满足 $f(0)=1$、$f\\!\\left(\\frac{1}{4}\\right)=0$、$f\\!\\left(\\frac{1}{2}\\right)=-1$、$f\\!\\left(\\frac{3}{4}\\right)=0$ 和 $f(1)=1$，并且在 $[0,1]$ 上不恒为零。\n\n设 $h=\\frac{1}{4}$（即有 $N=4$ 个子区间）和 $h/2=\\frac{1}{8}$（即有 $N=8$ 个子区间）。用 $S(h)$ 和 $S(h/2)$ 表示相应的复合辛普森近似值，用 $T(h)$ 和 $T(h/2)$ 表示相应的复合梯形近似值。设 $I=\\int_{0}^{1}f(x)\\,dx$ 表示精确积分值。\n\n你应该使用定义复合梯形法则（端点权重为 $1$，内部节点权重为 $2$，整体乘以 $\\frac{h}{2}$）和复合辛普森法则（内部奇数和偶数节点权重交替为 $4$ 和 $2$，端点权重为 $1$，整体乘以 $\\frac{h}{3}$）的基本原理，并结合以下事实：对于足够光滑的函数 $f$，复合辛普森法则的主阶全局误差与 $h^4$ 成比例。\n\n对于此函数 $f$ 和这些网格，下列哪个陈述是正确的？\n\nA. 在粗网格 $h=\\frac{1}{4}$ 上，嵌入式差值 $\\lvert S(h)-T(h)\\rvert$ 等于 $0$，会错误地暗示误差可以忽略不计，而基于 $h$ 和 $h/2$ 的两步估计法恰好等于真实误差 $\\lvert I-S(h/2)\\rvert=\\frac{1}{720}$。\n\nB. 在细化网格 $h/2=\\frac{1}{8}$ 上，嵌入式差值 $\\lvert S(h/2)-T(h/2)\\rvert$ 等于真实误差 $\\lvert I-S(h/2)\\rvert$，且两步估计值为 $0$。\n\nC. 嵌入式差值和两步估计值均为 $0$，因为复合辛普森法则对于均匀网格上的四次多项式是精确的。\n\nD. 两步估计值等于 $\\frac{1}{192}$，而粗网格上的嵌入式差值等于 $\\frac{1}{720}$，因此在这种情况下嵌入式估计更可靠。", "solution": "该问题陈述是数值分析中的一个有效练习。它内容自洽，有明确定义的函数、积分区间、数值方法和网格参数。所述的函数性质与其定义在数学上是一致的，且问题提法清晰。我们可以开始求解。\n\n主要任务是计算积分 $I = \\int_{0}^{1} f(x) \\, dx$ 的几个数值近似值，并比较不同的误差估计。函数由下式给出\n$$f(x) = -\\frac{128}{3}\\left(x-\\frac{1}{2}\\right)^4 + \\frac{56}{3}\\left(x-\\frac{1}{2}\\right)^2 - 1$$\n这是一个四次多项式。它是一个关于点 $x=\\frac{1}{2}$ 的偶函数。问题指定了 $[0,1]$ 上的两个均匀网格：一个步长为 $h=\\frac{1}{4}$ 的粗网格（$N=4$ 个子区间）和一个步长为 $h/2=\\frac{1}{8}$ 的细化网格（$N=8$ 个子区间）。\n\n首先，我们计算函数 $f(x)$ 在所需网格点上的值。\n粗网格点为 $\\{0, \\frac{1}{4}, \\frac{1}{2}, \\frac{3}{4}, 1\\}$。根据问题陈述，我们有：\n$f(0) = 1$\n$f(\\frac{1}{4}) = 0$\n$f(\\frac{1}{2}) = -1$\n$f(\\frac{3}{4}) = 0$\n$f(1) = 1$\n\n细网格点为 $\\{0, \\frac{1}{8}, \\frac{1}{4}, \\frac{3}{8}, \\frac{1}{2}, \\frac{5}{8}, \\frac{3}{4}, \\frac{7}{8}, 1\\}$。我们需要计算在新点上的函数值：$\\frac{1}{8}, \\frac{3}{8}, \\frac{5}{8}, \\frac{7}{8}$。\n对于 $x=\\frac{1}{8}$，有 $x-\\frac{1}{2} = -\\frac{3}{8}$。\n$f(\\frac{1}{8}) = -\\frac{128}{3}(-\\frac{3}{8})^4 + \\frac{56}{3}(-\\frac{3}{8})^2 - 1 = -\\frac{128}{3}\\frac{81}{4096} + \\frac{56}{3}\\frac{9}{64} - 1 = -\\frac{27}{32} + \\frac{63}{24} - 1 = \\frac{-27+84-32}{32} = \\frac{25}{32}$。\n对于 $x=\\frac{3}{8}$，有 $x-\\frac{1}{2} = -\\frac{1}{8}$。\n$f(\\frac{3}{8}) = -\\frac{128}{3}(-\\frac{1}{8})^4 + \\frac{56}{3}(-\\frac{1}{8})^2 - 1 = -\\frac{128}{3}\\frac{1}{4096} + \\frac{56}{3}\\frac{1}{64} - 1 = -\\frac{1}{96} + \\frac{7}{24} - 1 = \\frac{-1+28-96}{96} = -\\frac{69}{96} = -\\frac{23}{32}$。\n根据对称性，$f(\\frac{7}{8}) = f(\\frac{1}{8}) = \\frac{25}{32}$ 且 $f(\\frac{5}{8}) = f(\\frac{3}{8}) = -\\frac{23}{32}$。\n\n接下来，我们计算积分的近似值。\n**复合梯形法则：** $T_N = h \\left( \\frac{f(x_0)+f(x_N)}{2} + \\sum_{i=1}^{N-1} f(x_i) \\right)$。\n对于 $h=\\frac{1}{4}$（$N=4$）：\n$$T(h) = T(1/4) = \\frac{1}{4} \\left( \\frac{f(0)+f(1)}{2} + f(1/4)+f(1/2)+f(3/4) \\right) = \\frac{1}{4} \\left( \\frac{1+1}{2} + 0 - 1 + 0 \\right) = 0$$\n对于 $h/2=\\frac{1}{8}$（$N=8$）：\n$$T(h/2) = T(1/8) = \\frac{1}{8} \\left( \\frac{f(0)+f(1)}{2} + \\sum_{i=1}^{7} f(x_i) \\right)$$\n总和为 $f(\\frac{1}{8}) + f(\\frac{1}{4}) + f(\\frac{3}{8}) + f(\\frac{1}{2}) + f(\\frac{5}{8}) + f(\\frac{3}{4}) + f(\\frac{7}{8}) = \\frac{25}{32} + 0 - \\frac{23}{32} - 1 - \\frac{23}{32} + 0 + \\frac{25}{32} = \\frac{4}{32} - 1 = -\\frac{7}{8}$。\n$$T(1/8) = \\frac{1}{8} \\left( 1 - \\frac{7}{8} \\right) = \\frac{1}{8} \\cdot \\frac{1}{8} = \\frac{1}{64}$$\n\n**复合辛普森法则：** $S_N = \\frac{h}{3} \\left( f(x_0) + 4\\sum_{i=1}^{N/2} f(x_{2i-1}) + 2\\sum_{i=1}^{N/2-1} f(x_{2i}) + f(x_N) \\right)$。\n对于 $h=\\frac{1}{4}$（$N=4$）：\n$$S(h) = S(1/4) = \\frac{1/4}{3} \\left( f(0) + 4f(1/4) + 2f(1/2) + 4f(3/4) + f(1) \\right) = \\frac{1}{12} \\left( 1 + 4(0) + 2(-1) + 4(0) + 1 \\right) = 0$$\n对于 $h/2=\\frac{1}{8}$（$N=8$）：\n$$S(h/2) = S(1/8) = \\frac{1/8}{3} \\left( f(0) + 4(f_{1/8}+f_{3/8}+f_{5/8}+f_{7/8}) + 2(f_{1/4}+f_{1/2}+f_{3/4}) + f(1) \\right)$$\n内部奇数索引点上的和为 $2(f(\\frac{1}{8})+f(\\frac{3}{8})) = 2(\\frac{25}{32}-\\frac{23}{32}) = 2(\\frac{2}{32}) = \\frac{1}{8}$。\n内部偶数索引点上的和为 $0 - 1 + 0 = -1$。\n$$S(1/8) = \\frac{1}{24} \\left( 1 + 4(\\frac{1}{8}) + 2(-1) + 1 \\right) = \\frac{1}{24} \\left( 1 + \\frac{1}{2} - 2 + 1 \\right) = \\frac{1}{24} \\cdot \\frac{1}{2} = \\frac{1}{48}$$\n\n现在我们计算精确积分 $I$。令 $u = x-\\frac{1}{2}$，则 $dx = du$。\n$$I = \\int_{-1/2}^{1/2} \\left( -\\frac{128}{3}u^4 + \\frac{56}{3}u^2 - 1 \\right) du = 2 \\int_{0}^{1/2} \\left( -\\frac{128}{3}u^4 + \\frac{56}{3}u^2 - 1 \\right) du$$\n$$I = 2 \\left[ -\\frac{128}{15}u^5 + \\frac{56}{9}u^3 - u \\right]_0^{1/2} = 2 \\left( -\\frac{128}{15}(\\frac{1}{32}) + \\frac{56}{9}(\\frac{1}{8}) - \\frac{1}{2} \\right)$$\n$$I = 2 \\left( -\\frac{4}{15} + \\frac{7}{9} - \\frac{1}{2} \\right) = 2 \\left( \\frac{-24+70-45}{90} \\right) = 2 \\left( \\frac{1}{90} \\right) = \\frac{1}{45}$$\n\n我们现在评估误差估计和真实误差。\n**$S(h/2)$ 的真实误差：**\n$$\\lvert I - S(h/2)\\rvert = \\left\\lvert \\frac{1}{45} - \\frac{1}{48} \\right\\rvert = \\left\\lvert \\frac{16 - 15}{720} \\right\\rvert = \\frac{1}{720}$$\n**两步估计法：** 对于辛普森法则，一个 $p=4$ 阶的方法，其细化结果 $S(h/2)$ 的误差估计由理查森外推法给出：\n$$E_{2S} = \\frac{S(h/2) - S(h)}{2^p - 1} = \\frac{S(1/8) - S(1/4)}{2^4 - 1} = \\frac{1/48 - 0}{15} = \\frac{1}{48 \\times 15} = \\frac{1}{720}$$\n这个估计基于误差形式为 $E(h) \\approx C h^4$ 的假设。对于一个四次多项式，$f^{(4)}(x)$ 是一个常数，复合辛普森法则的误差公式 $E_S(h) = -\\frac{b-a}{180} h^4 f^{(4)}(\\xi)$ 变为精确形式：$E_S(h) = C h^4$。这就是为什么两步估计法能精确匹配真实误差的原因。\n\n**嵌入式差值估计：**\n在粗网格上（$h=\\frac{1}{4}$）：\n$$\\lvert S(h) - T(h) \\rvert = \\lvert S(1/4) - T(1/4) \\rvert = \\lvert 0 - 0 \\rvert = 0$$\n在细化网格上（$h/2=\\frac{1}{8}$）：\n$$\\lvert S(h/2) - T(h/2) \\rvert = \\lvert S(1/8) - T(1/8) \\rvert = \\left\\lvert \\frac{1}{48} - \\frac{1}{64} \\right\\rvert = \\left\\lvert \\frac{4 - 3}{192} \\right\\rvert = \\frac{1}{192}$$\n\n我们现在可以评估每个陈述。\n\n**A. 在粗网格 $h=\\frac{1}{4}$ 上，嵌入式差值 $\\lvert S(h)-T(h)\\rvert$ 等于 $0$，会错误地暗示误差可以忽略不计，而基于 $h$ 和 $h/2$ 的两步估计法恰好等于真实误差 $\\lvert I-S(h/2)\\rvert=\\frac{1}{720}$。**\n- 粗网格嵌入式差值 $\\lvert S(1/4)-T(1/4)\\rvert$ 确实为 $0$。\n- 这个 $0$ 的估计值对于 $S(1/4)$ 的真实误差 $\\lvert I-S(1/4) \\rvert = \\lvert \\frac{1}{45} - 0 \\rvert = \\frac{1}{45}$ 而言是一个很差的指标。所以它“错误地暗示误差可以忽略不计”。\n- 两步估计值为 $\\frac{1}{720}$。\n- 真实误差 $\\lvert I-S(h/2)\\rvert$ 为 $\\frac{1}{720}$。\n- 两步估计法精确匹配真实误差。\n这个陈述的每一部分都是正确的。\n\n**B. 在细化网格 $h/2=\\frac{1}{8}$ 上，嵌入式差值 $\\lvert S(h/2)-T(h/2)\\rvert$ 等于真实误差 $\\lvert I-S(h/2)\\rvert$，且两步估计值为 $0$。**\n- 细化网格上的嵌入式差值为 $\\frac{1}{192}$。真实误差为 $\\frac{1}{720}$。两者不相等。第一个子句是错误的。\n- 两步估计值为 $\\frac{1}{720}$，而不是 $0$。第二个子句是错误的。\n这个陈述是**不正确**的。\n\n**C. 嵌入式差值和两步估计值均为 $0$，因为复合辛普森法则对于均匀网格上的四次多项式是精确的。**\n- 粗网格嵌入式差值为 $0$，但细化网格嵌入式差值为 $\\frac{1}{192}$，两步估计值为 $\\frac{1}{720}$。“两者……均为 $0$”的说法是错误的。\n- 其理由“因为复合辛普森法则对于四次多项式是精确的”是错误的。复合辛普森法则对于次数最多为 $3$ 的多项式是精确的，因为其误差项取决于四阶导数，该导数对于三次多项式为零，但对于四次多项式不为零。\n这个陈述是**不正确**的。\n\n**D. 两步估计值等于 $\\frac{1}{192}$，而粗网格上的嵌入式差值等于 $\\frac{1}{720}$，因此在这种情况下嵌入式估计更可靠。**\n- 两步估计值为 $\\frac{1}{720}$，而不是 $\\frac{1}{192}$。\n- 粗网格嵌入式差值为 $0$，而不是 $\\frac{1}{720}$。\n陈述中的数值是不正确的。\n这个陈述是**不正确**的。\n\n根据以上分析，只有陈述 A 是正确的。", "answer": "$$\\boxed{A}$$", "id": "3125467"}, {"introduction": "现在，我们可以将误差估计的知识综合起来，构建一个强大且自动化的数值工具。本练习将指导您创建一个“自适应求积”算法，这是许多专业科学计算库（如 SciPy 或 MATLAB）中积分函数的核心引擎。其目标是构建一个能够智能地仅在需要时加密网格的方法，从而为各种不同函数高效地达到用户定义的混合误差容限。这个过程不仅能整合您关于误差估计的知识，还能让您体验到如何从基本原理出发，构建出稳健且实用的计算工具 [@problem_id:3125400]。", "problem": "您需要设计并实现一个完整的、可运行的程序，该程序构建一个用于一维定积分的自适应复合求积法则。目标是控制一个混合误差目标，该目标结合了绝对误差容限和相对误差容限，其中相对误差是相对于被积函数绝对值的积分来定义的。具体来说，您必须估算函数 $f$ 的积分，并同时估算其绝对值 $\\lvert f \\rvert$ 的积分，这样 $\\lvert f \\rvert$ 较小的区间就不会因为绝对误差容限而主导相对误差要求。\n\n从定积分 $\\int_a^b f(x)\\,dx$ 的基本定义和通过将区间 $[a,b]$ 细分为子区间而形成的复合求积法则出发，您必须构建一个自适应算法，该算法能够：\n- 基于从泰勒展开和复合求积法则的渐近截断误差一致的原理性论证得出的局部误差估计，递归地细分子区间。\n- 为每个子区间分配一个局部接受阈值，该阈值混合了绝对预算和相对预算，其中绝对预算按子区间在 $[a,b]$ 内的长度成比例分配，而子区间中的相对预算与其对 $\\int \\lvert f \\rvert$ 的估算值成比例。这种设计确保了 $\\lvert f \\rvert$ 较小的子区间不会因为相对误差约束而被强制过度细化，而是使用绝对预算。\n- 汇总已接受的子区间，以生成 $\\int_a^b f(x)\\,dx$ 的全局近似值和 $\\int_a^b \\lvert f(x) \\rvert\\,dx$ 的全局近似值。\n\n将具有给定绝对容限 $t_{\\mathrm{abs}}$ 和相对容限 $t_{\\mathrm{rel}}$ 的全局接受准则定义为混合形式，要求 $\\int_a^b f(x)\\,dx$ 的绝对误差小于或等于 $t_{\\mathrm{abs}} + t_{\\mathrm{rel}} \\int_a^b \\lvert f(x) \\rvert\\,dx$。您必须根据独立计算的高精度参考值来验证结果。本问题中所有三角函数均使用弧度。\n\n您的程序必须实现：\n- 一种带有局部误差估计和局部接受阈值的自适应复合规则，该阈值既包括与总长度 $(B-A)$ 内的子区间长度 $(b-a)$ 成比例的绝对预算项，也包括与子区间对 $\\int \\lvert f \\rvert$ 的局部估算值成比例的相对预算项。\n- 在每个子区间中使用一致的求积模板，同时估算 $\\int f$ 和 $\\int \\lvert f \\rvert$，以便相对容限有意义地应用于积分的量级，而不仅仅是其带符号的值。\n\n测试套件：\n对于下面的每个测试用例，使用您的自适应方法计算 $\\int_a^b f(x)\\,dx$ 的数值近似值 $I_{\\mathrm{num}}$，计算高精度参考值 $I_{\\mathrm{ref}}$ 和 $A_{\\mathrm{ref}} = \\int_a^b \\lvert f(x) \\rvert\\,dx$，然后输出一个布尔值，指示混合接受准则 $\\lvert I_{\\mathrm{ref}} - I_{\\mathrm{num}} \\rvert \\le t_{\\mathrm{abs}} + t_{\\mathrm{rel}} A_{\\mathrm{ref}}$ 是否满足。\n\n任何三角函数所需的角度单位均为弧度。\n\n使用以下测试用例，每个用例由 $(f, a, b, t_{\\mathrm{abs}}, t_{\\mathrm{rel}})$ 指定：\n\n- 用例 $1$：$f(x) = \\sin(x)$，$a=0$，$b=2\\pi$，$t_{\\mathrm{abs}} = 10^{-10}$，$t_{\\mathrm{rel}} = 10^{-6}$。\n- 用例 $2$：$f(x) = \\sin(50 x)$，$a=0$，$b=1$，$t_{\\mathrm{abs}} = 10^{-9}$，$t_{\\mathrm{rel}} = 5\\cdot 10^{-4}$。\n- 用例 $3$：$f(x) = x - 0.5$，$a=0$，$b=1$，$t_{\\mathrm{abs}} = 10^{-10}$，$t_{\\mathrm{rel}} = 10^{-6}$。\n- 用例 $4$：$f(x) = e^{-100 (x-0.5)^2} \\cos(10 x)$，$a=0$，$b=1$，$t_{\\mathrm{abs}} = 10^{-10}$，$t_{\\mathrm{rel}} = 10^{-6}$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_i$ 是对应测试用例的布尔值，指示是否满足混合准则。不应打印任何其他文本。", "solution": "数值逼近定积分 $I = \\int_a^b f(x)\\,dx$ 的问题是计算科学中的一项基本任务。虽然像梯形法则或辛普森法则这样的简单复合规则对于均匀网格上的良态函数是有效的，但对于在整个积分域上具有不同平滑度的函数，它们可能效率极低。自适应求积算法通过选择性地细化积分网格来解决这个问题，在函数复杂的区域投入更多的计算量，在函数平滑的区域投入较少的计算量。\n\n自适应算法的核心是局部误差估计算法和相应的接受准则。我们将基于成熟的辛普森求积法则和基于理查森外推法的误差估计来构建我们的方法。\n\n**1. 基本求积法则和误差估计**\n\n对于宽度为 $h = d-c$ 的单个子区间 $[c,d]$，辛普森法则提供了积分的估计值：\n$$ S(f, c, d) = \\frac{h}{6} \\left[ f(c) + 4f\\left(\\frac{c+d}{2}\\right) + f(d) \\right] $$\n从泰勒级数分析可知，该法则的局部截断误差为 $E_S \\approx C h^5 f^{(4)}(\\xi)$，其中 $C$ 是某个常数，$\\xi \\in (c,d)$。误差阶为 $O(h^5)$。\n\n为了在不知道 $f(x)$ 导数的情况下估计此误差，我们比较在 $[c,d]$ 上具有不同精度的两个积分近似值。\n设 $S_1$ 为在整个子区间 $[c,d]$ 上应用一次辛普森法则得到的粗略估计值。\n设 $S_2$ 为将子区间细分为两半 $[c,m]$ 和 $[m,d]$（其中 $m=(c+d)/2$），并对它们各自的辛普森法则结果求和得到的精细估计值：$S_2 = S(f, c, m) + S(f, m, d)$。\n\n粗略法则 $S_1$（步长为 $h$）的误差为 $E_1 \\approx C h^5 f^{(4)}(\\xi_1)$。\n精细法则 $S_2$ 的误差是两个步长为 $h/2$ 的子区间的误差之和，因此 $E_2 \\approx 2 \\times C (h/2)^5 f^{(4)}(\\xi_2) = \\frac{1}{16} C h^5 f^{(4)}(\\xi_2)$。\n假设 $f^{(4)}(x)$ 在子区间上变化缓慢，我们有 $E_1 \\approx 16 E_2$。\n真实积分 $I$ 可以写为 $I = S_1 + E_1$ 和 $I = S_2 + E_2$。\n将两者相减得到 $S_2 - S_1 = E_1 - E_2 \\approx 15 E_2$。\n因此，更精确的估计值 $S_2$ 的绝对误差可以估计为：\n$$ E_{S_2} \\approx \\frac{|S_2 - S_1|}{15} $$\n此外，通过应用理查森外推法，我们可以获得对积分本身更好的估计。改进后的估计值（对应于布尔法则）是：\n$$ I_{\\text{panel}} \\approx S_2 + E_2 = S_2 + \\frac{S_2 - S_1}{15} $$\n这个更高阶的估计值将用于被接受的子区间。\n\n**2. 混合误差准则和局部容限**\n\n当真实积分 $I_{\\text{ref}}$ 接近于零时，标准相对误差准则 $\\frac{|I_{\\text{num}}-I_{\\text{ref}}|}{|I_{\\text{ref}}|} \\le t_{\\text{rel}}$ 会出现问题。所提出的混合误差准则通过使用函数绝对值的积分作为相对容限的基础来避免这个问题：\n$$ |I_{\\text{num}} - I_{\\text{ref}}| \\le t_{\\text{abs}} + t_{\\text{rel}} \\int_a^b |f(x)|\\,dx $$\n为实现这一全局误差目标，我们必须将容限预算分配到各个局部子区间。对于总区间 $[A,B]$（宽度 $W=B-A$）内宽度为 $h=d-c$ 的子区间 $[c,d]$，我们通过按规定划分全局绝对和相对预算来定义局部容限 $\\tau$：\n- 绝对容限预算 $t_{\\text{abs}}$ 按子区间宽度成比例分配：$t_{\\text{abs}} \\frac{h}{W}$。\n- 相对容限预算与子区间上积分的量级成比例。为此，我们使用我们对 $\\int_c^d |f(x)|\\,dx$ 的数值估计，称之为 $A_{\\text{panel}}$。其贡献为 $t_{\\text{rel}} A_{\\text{panel}}$。\n\n子区间的局部容限是这两部分之和：\n$$ \\tau_{\\text{panel}} = t_{\\text{abs}} \\frac{h}{W} + t_{\\text{rel}} A_{\\text{panel}} $$\n如果子区间上 $f(x)$ 积分的估计误差（即 $|S_{2,f} - S_{1,f}|/15$）小于或等于此局部容限，则该子区间被接受。\n\n**3. 自适应算法**\n\n整个算法流程如下，使用一个栈来管理待细分的子区间，以避免深度递归。\n\n1.  将 $f$ 和 $|f|$ 的总积分估计值初始化为零：$I_{\\text{total}} = 0$, $A_{\\text{total}} = 0$。\n2.  将初始子区间 $(a, b)$ 推入栈中。\n3.  当栈不为空时：\n    a. 弹出一个子区间 $(c, d)$。\n    b. 在该子区间上同时计算 $f(x)$ 和 $|f(x)|$ 的粗略 ($S_1$) 和精细 ($S_2$) 积分估计值。这需要计算函数在 5 个点上的值。\n    c. 估计 $f$ 积分的误差：$E_f = |S_{2,f} - S_{1,f}|/15$。\n    d. 子区间上 $|f|$ 积分的估计值为 $A_{\\text{panel}} = S_{2,|f|} + (S_{2,|f|} - S_{1,|f|})/15$。由于 $|f(x)| \\ge 0$，我们确保 $A_{\\text{panel}} \\ge 0$。\n    e. 计算局部容限 $\\tau_{\\text{panel}} = t_{\\text{abs}} \\frac{d-c}{b-a} + t_{\\text{rel}} A_{\\text{panel}}$。\n    f. 如果 $E_f \\le \\tau_{\\text{panel}}$（或者如果子区间小于机器精度阈值），则接受该子区间。将其改进后的积分估计值 $I_{\\text{panel},f}$ 和 $A_{\\text{panel}}$ 分别加到总和 $I_{\\text{total}}$ 和 $A_{\\text{total}}$ 中。\n    g. 如果该子区间未被接受，则在其中心点 $m=(c+d)/2$ 处将其细分，并将两个新的子区间 $(c, m)$ 和 $(m, d)$ 推入栈中以进行进一步处理。\n4.  最终结果是累加和 $I_{\\text{total}}$。此过程将计算工作集中在函数的复杂区域，同时高效处理较平滑的区域，并且始终遵循一个稳健的混合误差准则。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef adaptive_quadrature(f, a, b, t_abs, t_rel):\n    \"\"\"\n    Computes the definite integral of f from a to b using an adaptive\n    composite quadrature rule based on Simpson's method and a mixed\n    error tolerance.\n    \"\"\"\n    # A small number to prevent division by zero or infinite loops for tiny intervals.\n    MIN_INTERVAL_WIDTH = 1e-15\n\n    # Wrapper for the absolute value of the function\n    abs_f = lambda x: np.abs(f(x))\n\n    # Storing tuple of (c, d) for each panel to be processed\n    panel_stack = [(a, b)]\n\n    total_integral_f = 0.0\n    total_width = b - a\n\n    # Max iteration guard to prevent potential infinite loops on pathological functions\n    max_panels = 100000\n    panel_count = 0\n\n    while panel_stack and panel_count  max_panels:\n        panel_count += 1\n        c, d = panel_stack.pop()\n        h = d - c\n\n        # If panel is too small, accept it and its contribution is likely negligible anyway.\n        if h  MIN_INTERVAL_WIDTH:\n            # Use a simple rule for this tiny interval\n            m = c + h / 2.0\n            total_integral_f += (h / 6.0) * (f(c) + 4.0 * f(m) + f(d))\n            continue\n\n        # 5 points for Simpson's rule comparison (1 coarse, 2 fine)\n        x0, x1, x2, x3, x4 = c, c + h * 0.25, c + h * 0.5, c + h * 0.75, d\n\n        # Evaluations for f\n        f_vals = np.array([f(x0), f(x1), f(x2), f(x3), f(x4)])\n        # Evaluations for |f|\n        abs_f_vals = np.abs(f_vals)\n\n        # Coarse estimate (S1) for f over [c, d]\n        s1_f = (h / 6.0) * (f_vals[0] + 4.0 * f_vals[2] + f_vals[4])\n        # Fine estimate (S2) for f over [c, d]\n        s2_f = (h / 12.0) * (f_vals[0] + 4.0 * f_vals[1] + 2.0 * f_vals[2] + 4.0 * f_vals[3] + f_vals[4])\n\n        # Coarse estimate (S1) for |f|\n        s1_absf = (h / 6.0) * (abs_f_vals[0] + 4.0 * abs_f_vals[2] + abs_f_vals[4])\n        # Fine estimate (S2) for |f|\n        s2_absf = (h / 12.0) * (abs_f_vals[0] + 4.0 * abs_f_vals[1] + 2.0 * abs_f_vals[2] + 4.0 * abs_f_vals[3] + abs_f_vals[4])\n\n        # Error estimate for the integral of f\n        error_f = np.abs(s2_f - s1_f) / 15.0\n\n        # Boole's rule estimate for the integral of |f| on the panel\n        # Ensure it's non-negative as it's used for tolerance scaling.\n        integral_absf_panel = s2_absf + (s2_absf - s1_absf) / 15.0\n        integral_absf_panel = np.maximum(0, integral_absf_panel)\n\n        # Local tolerance for the panel\n        local_tolerance = t_abs * (h / total_width) + t_rel * integral_absf_panel\n        \n        # If error is acceptable, add improved estimate to total and continue\n        if error_f = local_tolerance:\n            # Boole's rule (Richardson extrapolation) gives a more accurate result\n            integral_f_panel = s2_f + (s2_f - s1_f) / 15.0\n            total_integral_f += integral_f_panel\n        else:\n            # Subdivide panel and push halves to stack\n            m = x2\n            panel_stack.append((c, m))\n            panel_stack.append((m, d))\n\n    return total_integral_f\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        (lambda x: np.sin(x), 0, 2 * np.pi, 1e-10, 1e-6),\n        (lambda x: np.sin(50 * x), 0, 1, 1e-9, 5e-4),\n        (lambda x: x - 0.5, 0, 1, 1e-10, 1e-6),\n        (lambda x: np.exp(-100 * (x-0.5)**2) * np.cos(10 * x), 0, 1, 1e-10, 1e-6),\n    ]\n\n    results = []\n    for f, a, b, t_abs, t_rel in test_cases:\n        # Calculate numerical integral using our implemented method\n        I_num = adaptive_quadrature(f, a, b, t_abs, t_rel)\n\n        # Calculate high-accuracy reference values using scipy.integrate.quad\n        I_ref, _ = integrate.quad(f, a, b, epsabs=1e-14, epsrel=1e-14)\n        abs_f = lambda x: np.abs(f(x))\n        A_ref, _ = integrate.quad(abs_f, a, b, epsabs=1e-14, epsrel=1e-14)\n\n        # Check if the mixed error criterion is satisfied\n        actual_error = np.abs(I_ref - I_num)\n        allowed_error = t_abs + t_rel * A_ref\n        \n        results.append(actual_error = allowed_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3125400"}]}