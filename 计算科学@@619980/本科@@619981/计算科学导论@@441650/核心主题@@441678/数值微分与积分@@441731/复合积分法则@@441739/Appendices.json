{"hands_on_practices": [{"introduction": "数值积分的一个关键应用是处理从科学模型或实验中获得的离散数据。本练习将带你进入药代动力学领域，这是一个研究药物在体内如何被吸收、分布、代谢和排泄的学科。你将使用复合梯形法则来估算一个实际药物浓度曲线下的面积（AUC），这是一个评估药物暴露总量的核心指标，并通过比较不同采样方案的准确性，亲身体会离散化选择对科学计算结果的深远影响 [@problem_id:3108753]。", "problem": "您需要研究复合梯形积分法则在应用于分段指数药代动力学浓度-时间曲线时的准确性。目标是量化不同的采样方案如何影响浓度-时间曲线下面积（Area Under the Curve (AUC)）的估计误差。完全以纯数学术语进行工作，并实现一个完整的、可运行的程序，以生成所要求的输出。请使用以下科学上真实模型和规格。\n\n浓度-时间模型是区间 $[0,T]$ 上的一个具有两个变点的连续分段指数函数。设 $T = 24$ 小时，断点位于 $t_1 = 1.5$ 小时和 $t_2 = 6.0$ 小时。设初始浓度为 $C_0 = 10$ 毫克/升，指数衰减率在 $[0,t_1)$ 上为 $k_0 = 1.2$ /小时，在 $[t_1,t_2)$ 上为 $k_1 = 0.25$ /小时，在 $[t_2,T]$ 上为 $k_2 = 0.05$ /小时。浓度 $c(t)$ 定义为区间 $[0,T]$ 上的唯一函数，该函数是连续的，并且在每个子区间上都呈 $A \\exp(-k (t-t_{\\mathrm{start}}))$ 的分段形式，具体构造如下：\n- 在 $[0,t_1)$ 上：$c(t) = C_0 \\exp(-k_0 t)$。\n- 在 $[t_1,t_2)$ 上：$c(t) = c(t_1)\\,\\exp(-k_1 (t - t_1))$，其中 $c(t_1) = C_0 \\exp(-k_0 t_1)$ 确保在 $t_1$ 处的连续性。\n- 在 $[t_2,T]$ 上：$c(t) = c(t_2)\\,\\exp(-k_2 (t - t_2))$，其中 $c(t_2) = c(t_1)\\,\\exp(-k_1 (t_2 - t_1))$ 确保在 $t_2$ 处的连续性。\n\n您的任务是：\n- 从黎曼积分的定义和分段线性逼近的概念出发，实现复合梯形法则，以使用任意非递减采样方案 $0 = t_0  t_1  \\dots  t_n = T$ 来近似 $c(t)$ 在 $[0,T]$ 上的积分。该法则必须能正确处理非均匀步长。\n- 利用指数函数的反导数和积分在相邻区间上的可加性，从第一性原理出发，通过对三个子区间 $[0,t_1]$、$[t_1,t_2]$ 和 $[t_2,T]$ 上的贡献求和，推导出精确AUC的解析表达式，记为 $I_{\\mathrm{exact}} = \\int_0^T c(t)\\,dt$。\n- 使用您实现的复合梯形法则，根据下面测试套件中列出的每个方案的采样时间，估计同一区间上的AUC，并计算绝对误差 $E = \\lvert I_{\\mathrm{trap}} - I_{\\mathrm{exact}} \\rvert$，单位为毫克-小时/升。\n\n所有物理量必须一致处理，时间单位为小时，浓度单位为毫克/升。AUC以毫克-小时/升表示。绝对误差必须以毫克-小时/升报告。不涉及角度单位。不涉及百分比。\n\n采样方案测试套件（每个都是以小时为单位的时间列表）：\n- 方案A（均匀细粒度）：$t_j = 0, 0.1, 0.2, \\dots, 24$。\n- 方案B（均匀粗粒度）：$t_j = 0, 4, 8, 12, 16, 20, 24$。\n- 方案C（早期密集稀疏）：$[0, 0.05, 0.1, 0.2, 0.5, 1.0, 1.5, 2.0, 4.0, 8.0, 12.0, 16.0, 24.0]$。\n- 方案D（对数间隔，加端点）：通过 $t_i = 10^{a + i\\,(b-a)/(m-1)}$（其中 $i = 0, 1, \\dots, m-1$，$a = -3$，$b = \\log_{10}(24)$）构造 $m=18$ 个点，然后与 $\\{0, 24\\}$ 取并集，移除重复项，并按升序排序。\n- 方案E（仅端点）：$[0, 24]$。\n- 方案F（与变点对齐）：$[0.0, 0.75, 1.5, 3.75, 6.0, 12.0, 24.0]$。\n\n您的程序必须：\n- 精确地实现所定义的 $c(t)$，确保在 $t_1$ 和 $t_2$ 处的连续性。\n- 通过对每个子区间进行积分并求和，根据模型定义解析计算 $I_{\\mathrm{exact}}$。\n- 对每个方案，使用复合梯形法则以及给定的时间和在这些时间点上精确的 $c(t)$ 值来计算 $I_{\\mathrm{trap}}$。\n- 对每个方案，计算绝对误差 $E$（以毫克-小时/升为单位的浮点数），并将每个误差四舍五入到10位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为[方案A误差, 方案B误差, 方案C误差, 方案D误差, 方案E误差, 方案F误差]，例如，“[$e_A$,$e_B$,$e_C$,$e_D$,$e_E$,$e_F$]”。每个 $e_{\\cdot}$ 必须是四舍五入到10位小数的十进制字符串。", "solution": "该问题经评估在科学上是合理的、适定的，并包含唯一解所需的所有信息。我们继续进行推导和实现。\n\n该问题要求计算代表药代动力学浓度随时间变化的分段指数函数的精确解析积分与使用复合梯形法则得到的数值近似值之间的绝对误差。\n\n浓度-时间模型 $c(t)$ 定义在区间 $[0, T]$ 上，其中 $T=24$ 小时。该函数是连续且分段定义的，变点位于 $t_1 = 1.5$ 小时和 $t_2 = 6.0$ 小时。定义参数为初始浓度 $C_0 = 10$ mg/L 和指数衰减率 $k_0 = 1.2$ hr$^{-1}$、$k_1 = 0.25$ hr$^{-1}$ 和 $k_2 = 0.05$ hr$^{-1}$。\n\n函数 $c(t)$ 的构造如下：\n- 对于 $t \\in [0, t_1)$，浓度为 $c(t) = C_0 \\exp(-k_0 t)$。\n- 对于 $t \\in [t_1, t_2)$，浓度为 $c(t) = c(t_1) \\exp(-k_1 (t - t_1))$。通过定义 $c(t_1) = C_0 \\exp(-k_0 t_1)$ 来确保在 $t_1$ 处的连续性。\n- 对于 $t \\in [t_2, T]$，浓度为 $c(t) = c(t_2) \\exp(-k_2 (t - t_2))$。通过定义 $c(t_2) = c(t_1) \\exp(-k_1 (t_2 - t_1))$ 来确保在 $t_2$ 处的连续性。\n\n首先，我们推导精确曲线下面积（AUC）的解析表达式，记为 $I_{\\mathrm{exact}}$。AUC 是 $c(t)$ 从 $0$ 到 $T$ 的定积分。\n$$I_{\\mathrm{exact}} = \\int_0^T c(t) \\, dt$$\n根据积分的可加性，我们可以将积分拆分到由变点定义的各个子区间上：\n$$I_{\\mathrm{exact}} = \\int_0^{t_1} c(t) \\, dt + \\int_{t_1}^{t_2} c(t) \\, dt + \\int_{t_2}^{T} c(t) \\, dt$$\n我们分别对每个部分进行积分。\n\n1.  在 $[0, t_1]$ 上的积分：\n    $$I_1 = \\int_0^{t_1} C_0 \\exp(-k_0 t) \\, dt = C_0 \\left[ -\\frac{1}{k_0} \\exp(-k_0 t) \\right]_0^{t_1} = C_0 \\left( -\\frac{1}{k_0} \\exp(-k_0 t_1) - \\left(-\\frac{1}{k_0} \\exp(0)\\right) \\right) = \\frac{C_0}{k_0} (1 - \\exp(-k_0 t_1))$$\n\n2.  在 $[t_1, t_2]$ 上的积分：\n    设 $c(t_1) = C_0 \\exp(-k_0 t_1)$ 为时间 $t_1$ 时的浓度。\n    $$I_2 = \\int_{t_1}^{t_2} c(t_1) \\exp(-k_1 (t - t_1)) \\, dt = c(t_1) \\left[ -\\frac{1}{k_1} \\exp(-k_1(t - t_1)) \\right]_{t_1}^{t_2}$$\n    $$I_2 = c(t_1) \\left( -\\frac{1}{k_1} \\exp(-k_1(t_2 - t_1)) - \\left(-\\frac{1}{k_1} \\exp(0)\\right) \\right) = \\frac{c(t_1)}{k_1} (1 - \\exp(-k_1(t_2 - t_1)))$$\n\n3.  在 $[t_2, T]$ 上的积分：\n    设 $c(t_2) = c(t_1) \\exp(-k_1 (t_2 - t_1))$ 为时间 $t_2$ 时的浓度。\n    $$I_3 = \\int_{t_2}^{T} c(t_2) \\exp(-k_2 (t - t_2)) \\, dt = c(t_2) \\left[ -\\frac{1}{k_2} \\exp(-k_2(t - t_2)) \\right]_{t_2}^{T}$$\n    $$I_3 = c(t_2) \\left( -\\frac{1}{k_2} \\exp(-k_2(T - t_2)) - \\left(-\\frac{1}{k_2} \\exp(0)\\right) \\right) = \\frac{c(t_2)}{k_2} (1 - \\exp(-k_2(T - t_2)))$$\n\n总的精确AUC是 $I_{\\mathrm{exact}} = I_1 + I_2 + I_3$ 的和。\n\n接下来，我们为非均匀采样方案 $t_0, t_1, \\dots, t_n$（其中 $0 = t_0  t_1  \\dots  t_n = T$）定义复合梯形法则。该积分通过对每个子区间 $[t_{i-1}, t_i]$ 上形成的梯形面积求和来近似。\n$$I_{\\mathrm{trap}} = \\sum_{i=1}^{n} \\frac{c(t_{i-1}) + c(t_i)}{2} (t_i - t_{i-1})$$\n该公式被实现用来为每个给定的采样方案计算数值近似值 $I_{\\mathrm{trap}}$。\n\n最后，对于每个方案，绝对误差 $E$ 的计算公式为：\n$$E = |I_{\\mathrm{trap}} - I_{\\mathrm{exact}}|$$\n\n总体步骤如下：\n1.  定义常数 $C_0, k_0, k_1, k_2, t_1, t_2, T$。\n2.  根据其定义实现连续的分段函数 $c(t)$。\n3.  使用推导出的解析公式计算精确积分 $I_{\\mathrm{exact}}$。\n4.  对于每个测试方案（A到F）：\n    a.  生成时间点数组 $t_0, t_1, \\dots, t_n$。\n    b.  在每个时间点上评估浓度 $c(t_i)$。\n    c.  使用复合梯形法则计算近似积分 $I_{\\mathrm{trap}}$。\n    d.  计算绝对误差 $E = |I_{\\mathrm{trap}} - I_{\\mathrm{exact}}|$。\n    e.  将误差 $E$ 四舍五入到10位小数。\n5.  收集舍入后的误差，并将它们格式化为指定的输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the pharmacokinetic AUC error analysis problem.\n    \"\"\"\n    # Define model parameters\n    C0 = 10.0  # mg/L\n    k0 = 1.2   # 1/hr\n    k1 = 0.25  # 1/hr\n    k2 = 0.05  # 1/hr\n    t1 = 1.5   # hr\n    t2 = 6.0   # hr\n    T = 24.0   # hr\n\n    # Pre-calculate concentrations at breakpoints for the c(t) function\n    c_at_t1 = C0 * np.exp(-k0 * t1)\n    c_at_t2 = c_at_t1 * np.exp(-k1 * (t2 - t1))\n\n    def concentration(t):\n        \"\"\"\n        Calculates the concentration c(t) at time t or for a numpy array of times.\n        The function is vectorized using numpy.piecewise.\n        \"\"\"\n        t = np.asarray(t)\n        \n        # Conditions for the piecewise function\n        condlist = [t  t1, (t = t1)  (t  t2), t = t2]\n        \n        # Functions for each piece\n        funclist = [\n            lambda t: C0 * np.exp(-k0 * t),\n            lambda t: c_at_t1 * np.exp(-k1 * (t - t1)),\n            lambda t: c_at_t2 * np.exp(-k2 * (t - t2))\n        ]\n        \n        return np.piecewise(t, condlist, funclist)\n\n    def analytic_auc():\n        \"\"\"\n        Calculates the exact area under the curve (AUC) from t=0 to T.\n        \"\"\"\n        # Integral over [0, t1]\n        I1 = (C0 / k0) * (1.0 - np.exp(-k0 * t1))\n        \n        # Integral over [t1, t2]\n        I2 = (c_at_t1 / k1) * (1.0 - np.exp(-k1 * (t2 - t1)))\n        \n        # Integral over [t2, T]\n        I3 = (c_at_t2 / k2) * (1.0 - np.exp(-k2 * (T - t2)))\n        \n        return I1 + I2 + I3\n\n    def composite_trapezoidal_rule(time_points, concentrations):\n        \"\"\"\n        Implements the composite trapezoidal rule for non-uniform grid spacing.\n        \"\"\"\n        if len(time_points)  2:\n            return 0.0\n        \n        time_diffs = np.diff(time_points) # h_i = t_i - t_{i-1}\n        conc_sums = concentrations[:-1] + concentrations[1:] # c(t_{i-1}) + c(t_i)\n        \n        return np.sum(time_diffs * conc_sums / 2.0)\n\n    # --- Define Test Suite of Sampling Schedules ---\n\n    # Schedule A: uniform fine\n    schedule_A = np.linspace(0.0, 24.0, 241)\n\n    # Schedule B: uniform coarse\n    schedule_B = np.linspace(0.0, 24.0, 7)\n    \n    # Schedule C: early-heavy sparse\n    schedule_C = np.array([0.0, 0.05, 0.1, 0.2, 0.5, 1.0, 1.5, 2.0, 4.0, 8.0, 12.0, 16.0, 24.0])\n\n    # Schedule D: log-spaced, plus endpoints\n    m = 18\n    a = -3\n    b = np.log10(T)\n    # Generate log-spaced points, then form the union with endpoints to ensure they are included\n    log_points = np.logspace(a, b, num=m, base=10.0)\n    schedule_D = np.union1d(log_points, [0.0, T])\n\n    # Schedule E: endpoints only\n    schedule_E = np.array([0.0, 24.0])\n\n    # Schedule F: aligned with change-points\n    schedule_F = np.array([0.0, 0.75, 1.5, 3.75, 6.0, 12.0, 24.0])\n    \n    test_cases = [\n        schedule_A,\n        schedule_B,\n        schedule_C,\n        schedule_D,\n        schedule_E,\n        schedule_F\n    ]\n    \n    # --- Perform Calculations ---\n    \n    # Calculate the exact integral once\n    I_exact = analytic_auc()\n    \n    results = []\n    for schedule in test_cases:\n        # Evaluate concentrations at the sampling times\n        conc_values = concentration(schedule)\n        \n        # Compute the integral using the trapezoidal rule\n        I_trap = composite_trapezoidal_rule(schedule, conc_values)\n        \n        # Compute the absolute error\n        error = np.abs(I_trap - I_exact)\n        \n        # Round the error to 10 decimal places as required\n        rounded_error = round(error, 10)\n        \n        results.append(rounded_error)\n\n    # Format the final output string\n    # Using f-strings with a format specifier to ensure 10 decimal places are shown\n    formatted_results = [f\"{res:.10f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3108753"}, {"introduction": "在许多复杂的科学和工程问题中，数值积分往往不是最终目的，而是作为更宏大计算任务（如优化）的一个子模块。本练习模拟了这样一个场景：你需要通过梯度下降法来最小化一个其目标函数由积分定义的参数。由于积分本身是数值近似的，其产生的离散化误差将使梯度变得“嘈杂”，进而影响优化过程的收敛性，通过这个实践，你将深入理解数值误差如何在一个环环相扣的算法系统中传播和累积 [@problem_id:3108801]。", "problem": "您将研究复合数值积分的离散化误差如何传播到基于梯度的优化循环中，并影响其收敛性。考虑最小化泛函的标量优化问题\n$$\nJ(a) \\;=\\; \\int_{0}^{1} \\left(a\\,x^{2} - \\sin(2\\pi x)\\right)^{2}\\,dx,\n$$\n其中正弦函数的参数以弧度为单位。外部优化循环对标量参数 $a$ 使用梯度下降法，而内部目标函数求值则使用复合数值积分法则。您的任务是实现一个程序，以展示复合积分法则和网格分辨率的选择如何通过含噪声的梯度影响下降过程。\n\n所需组件和约束：\n\n- 基础部分：\n  - 使用复合梯形法则和复合辛普森法则，这两种都是标准的 Newton–Cotes 公式。\n  - 使用中心有限差分公式来近似通过求积得到的目标函数关于 $a$ 的导数。\n  - 使用固定步长梯度下降作为外部优化器。\n\n- 需要实现的数学定义：\n  1. 在 $[0,1]$ 上使用 $N$ 个子区间的复合梯形法则：\n     - 令 $h = \\frac{1-0}{N}$ 且 $x_{i} = 0 + i\\,h$（$i=0,1,\\dots,N$）。对于给定的函数 $f(x)$，\n       $$\n       \\int_{0}^{1} f(x)\\,dx \\;\\approx\\; h\\left(\\tfrac{1}{2}f(x_{0}) + \\sum_{i=1}^{N-1} f(x_{i}) + \\tfrac{1}{2}f(x_{N})\\right).\n       $$\n  2. 在 $[0,1]$ 上使用 $N$ 个子区间的复合辛普森法则：\n     - 要求 $N$ 为偶数。使用相同的 $h$ 和节点 $x_{i}$，\n       $$\n       \\int_{0}^{1} f(x)\\,dx \\;\\approx\\; \\frac{h}{3}\\left(f(x_{0}) + f(x_{N}) + 4\\sum_{i=1,\\,\\text{odd}}^{N-1} f(x_{i}) + 2\\sum_{i=2,\\,\\text{even}}^{N-2} f(x_{i})\\right).\n       $$\n  3. 使用步长为 $\\delta$ 的中心有限差分对外部循环进行梯度近似：\n     $$\n     \\frac{dJ}{da}(a) \\;\\approx\\; \\frac{J_{\\text{quad}}(a+\\delta) - J_{\\text{quad}}(a-\\delta)}{2\\,\\delta},\n     $$\n     其中 $J_{\\text{quad}}$ 是使用其中一种复合规则对 $J$ 进行的求积近似。\n  4. 使用固定学习率 $\\eta$ 的梯度下降更新：\n     $$\n     a_{k+1} \\;=\\; a_{k} \\;-\\; \\eta\\,g_{k}, \\quad \\text{其中 } g_{k} \\text{ 是在 } a_{k} \\text{ 处的有限差分梯度。}\n     $$\n\n- 终止条件与稳定性：\n  - 使用 $a_{0} = 0$ 进行初始化。\n  - 使用梯度容差 $\\varepsilon_{g} = 10^{-8}$ 和参数容差 $\\varepsilon_{a} = 10^{-9}$。\n  - 使用最大迭代次数 $K_{\\max} = 10000$。\n  - 如果循环超过 $K_{\\max}$ 仍未满足容差要求，或者 $|a_{k}|$ 增长超过 $10^{6}$，则判定为不收敛。\n\n- 用于误差评估的参考最优值：\n  - 由于 $J(a)$ 是关于 $a$ 的二次泛函，其精确最小值点 $a_{\\star}$ 可以通过标准微积分对精确积分关于 $a$ 求最小值来获得。请解析地计算该 $a_{\\star}$，并仅用它来报告绝对误差 $|a_{\\text{final}} - a_{\\star}|$；不要用它来指导优化器。\n\n- 测试套件：\n  - 对每个测试用例，使用指定的复合规则、子区间数量 $N$、学习率 $\\eta$ 和有限差分步长 $\\delta$ 运行优化器：\n    1. 复合梯形法则, $N=16$, $\\eta=0.5$, $\\delta=10^{-4}$。\n    2. 复合梯形法则, $N=64$, $\\eta=0.5$, $\\delta=10^{-4}$。\n    3. 复合辛普森法则, $N=16$ (偶数), $\\eta=0.5$, $\\delta=10^{-4}$。\n    4. 复合梯形法则, $N=4$, $\\eta=0.5$, $\\delta=10^{-4}$。\n    5. 复合梯形法则, $N=16$, $\\eta=1.6$, $\\delta=10^{-4}$。\n\n- 要求的最终输出格式：\n  - 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。\n  - 对于每个测试用例，输出一个形式为 $[\\text{converged}, \\text{iterations}, a_{\\text{final}}, \\text{abs\\_error}]$ 的列表，其中：\n    - $\\text{converged}$：如果根据定义的容差收敛，则为 $1$，否则为 $0$。\n    - $\\text{iterations}$：所用的迭代次数（整数）。\n    - $a_{\\text{final}}$：$a$ 的最终估计值，四舍五入到六位小数。\n    - $\\text{abs\\_error}$：$|a_{\\text{final}} - a_{\\star}|$ 的值，四舍五入到六位小数。\n  - 示例格式（非实际值）：$[[1,123,-0.750000,0.010000],[0,10000,-0.300000,0.400000],\\dots]$。\n\n注意：\n- 所有三角函数求值必须使用弧度。\n- 此问题不涉及物理单位。\n- 您的实现必须是自包含的，且不得读取任何输入。", "solution": "我们从数值分析基本原理和基础微积分出发，推导出所需的组件，然后组装一个算法来展示复合积分误差如何扰动梯度下降过程。\n\n1. 目标函数结构与精确最小值点。该泛函为\n$$\nJ(a) \\;=\\; \\int_{0}^{1} \\left(a\\,x^{2} - \\sin(2\\pi x)\\right)^{2}\\,dx.\n$$\n展开平方项可知，$J(a)$ 是一个关于 $a$ 的二次多项式。将精确积分对 $a$ 求导并令其为零，可得一阶最优性条件\n$$\n\\frac{dJ}{da}(a) \\;=\\; 2\\int_{0}^{1} \\left(a\\,x^{2} - \\sin(2\\pi x)\\right) x^{2}\\,dx \\;=\\; 0,\n$$\n这意味着\n$$\na_{\\star}\\int_{0}^{1} x^{4}\\,dx \\;=\\; \\int_{0}^{1} x^{2}\\sin(2\\pi x)\\,dx.\n$$\n左侧的积分是初等的：\n$$\n\\int_{0}^{1} x^{4}\\,dx \\;=\\; \\left.\\frac{x^{5}}{5}\\right|_{0}^{1} \\;=\\; \\frac{1}{5}.\n$$\n对于右侧，定义 $k = 2\\pi$。使用两次分部积分或已知的原函数，可以得到\n$$\n\\int x^{2}\\sin(kx)\\,dx \\;=\\; -\\frac{x^{2}\\cos(kx)}{k} + \\frac{2x\\sin(kx)}{k^{2}} + \\frac{2\\cos(kx)}{k^{3}} + C.\n$$\n在 $x=0$ 到 $x=1$ 的区间上求值，其中 $k=2\\pi$，且 $\\cos(2\\pi)=1$、$\\sin(2\\pi)=0$，得到\n$$\n\\int_{0}^{1} x^{2}\\sin(2\\pi x)\\,dx \\;=\\; -\\frac{1}{2\\pi}.\n$$\n因此，\n$$\na_{\\star} \\;=\\; \\frac{\\int_{0}^{1} x^{2}\\sin(2\\pi x)\\,dx}{\\int_{0}^{1} x^{4}\\,dx} \\;=\\; \\frac{-\\frac{1}{2\\pi}}{\\frac{1}{5}} \\;=\\; -\\frac{5}{2\\pi}.\n$$\n这个精确的 $a_{\\star}$ 为量化数值方法得到的 $a_{\\text{final}}$ 的误差提供了一个参考。\n\n2. 复合积分法则。对于在 $[0,1]$ 上的函数 $f(x)$，使用包含 $N$ 个子区间的均匀网格，步长为 $h = \\frac{1}{N}$，定义节点 $x_{i} = i\\,h$（$i=0,1,\\dots,N$）。\n- 复合梯形法则：\n$$\n\\int_{0}^{1} f(x)\\,dx \\;\\approx\\; h\\left(\\tfrac{1}{2}f(x_{0}) + \\sum_{i=1}^{N-1} f(x_{i}) + \\tfrac{1}{2}f(x_{N})\\right).\n$$\n对于足够光滑的 $f$，该法则的全局截断误差为 $O(h^{2})$ 阶。\n- 复合辛普森法则（$N$为偶数）：\n$$\n\\int_{0}^{1} f(x)\\,dx \\;\\approx\\; \\frac{h}{3}\\left(f(x_{0}) + f(x_{N}) + 4\\sum_{\\substack{i=1\\\\ i \\text{ odd}}}^{N-1} f(x_{i}) + 2\\sum_{\\substack{i=2\\\\ i \\text{ even}}}^{N-2} f(x_{i})\\right).\n$$\n对于足够光滑的 $f$，该法则的全局截断误差为 $O(h^{4})$ 阶。\n\n在我们的设定中，被积函数是\n$$\nf(x;a) \\;=\\; \\left(a\\,x^{2} - \\sin(2\\pi x)\\right)^{2},\n$$\n它在 $x$ 和 $a$ 上是光滑的，因此两种复合规则都适用。\n\n3. 通过有限差分得到含噪声的梯度。在外部优化循环中，通常会使用梯度。如果目标函数是通过求积计算的，求积误差会使得目标函数 $J_{\\text{quad}}(a)$ 只是 $J(a)$ 的一个近似。一个完全从这些近似目标函数值中获取梯度估计的直接方法是中心有限差分\n$$\ng(a) \\;\\approx\\; \\frac{J_{\\text{quad}}(a+\\delta) - J_{\\text{quad}}(a-\\delta)}{2\\,\\delta}.\n$$\n这个 $g(a)$ 从 $J_{\\text{quad}}$ 继承了由离散化引起的粗糙性。随着子区间数量 $N$ 的增加（$h$ 变小），近似效果会改善，梯度噪声也会减小。对于相同的 $N$，辛普森法则通常比梯形法则有更小的误差。\n\n4. 梯度下降更新与停止。给定当前估计值 $a_k$、固定学习率 $\\eta$ 以及梯度估计值 $g_k$，执行\n$$\na_{k+1} \\;=\\; a_{k} \\;-\\; \\eta\\,g_{k}.\n$$\n如果梯度大小很小（$|g_{k}|  \\varepsilon_{g}$），或者参数更新量很小（$|a_{k+1} - a_{k}|  \\varepsilon_{a}$），则停止。同时，如果 $|a_{k}| > 10^{6}$ 或 $k$ 达到 $K_{\\max}$，则中止以防止发散。\n\n5. 测试套件设计与预期效果。\n- 使用复合梯形法则和粗网格（例如 $N=4$）时，求积误差较大，有限差分梯度噪声更多，收敛可能会很慢，或者根据 $\\eta$ 的值，可能在迭代预算内无法收敛。\n- 将 $N$ 增加到 $N=16$ 或 $N=64$ 会减小求积误差，因此梯度变得更平滑，从而改善收敛行为。\n- 对于相同的 $N$，复合辛普森法则（$N$为偶数，例如 $N=16$）通常会产生更精确的目标函数值和噪声更小的梯度，与梯形法则相比，这应该会加速收敛。\n- 较大的学习率（例如 $\\eta=1.6$）会使下降过程不稳定，而噪声会加剧这种情况，可能引发振荡或发散。\n\n6. 程序输出。对于每个指定的测试用例，程序运行外部循环并报告一个列表 $[\\text{converged}, \\text{iterations}, a_{\\text{final}}, \\text{abs\\_error}]$，其中 $\\text{abs\\_error} = |a_{\\text{final}} - a_{\\star}|$ 且 $a_{\\star} = -\\frac{5}{2\\pi}$。单行程序输出是按给定顺序排列的这些列表的列表。这种安排便于直接比较不同法则和 $N$ 之间的结果，揭示了复合积分选择和网格大小如何通过梯度噪声影响优化器。", "answer": "```python\nimport numpy as np\n\ndef composite_trapezoid(f, a, b, N):\n    h = (b - a) / N\n    x = np.linspace(a, b, N + 1)\n    fx = f(x)\n    return h * (0.5 * fx[0] + fx[1:-1].sum() + 0.5 * fx[-1])\n\ndef composite_simpson(f, a, b, N):\n    if N % 2 != 0:\n        raise ValueError(\"Simpson's rule requires an even N.\")\n    h = (b - a) / N\n    x = np.linspace(a, b, N + 1)\n    fx = f(x)\n    # odd indices 1..N-1 step 2, even indices 2..N-2 step 2\n    odd_sum = fx[1:-1:2].sum()\n    even_sum = fx[2:-1:2].sum()\n    return (h / 3.0) * (fx[0] + fx[-1] + 4.0 * odd_sum + 2.0 * even_sum)\n\ndef objective_quadrature(a_param, rule, N):\n    # integrand: (a x^2 - sin(2π x))^2\n    def integrand(x):\n        return (a_param * x**2 - np.sin(2.0 * np.pi * x))**2\n    if rule == \"trap\":\n        return composite_trapezoid(integrand, 0.0, 1.0, N)\n    elif rule == \"simp\":\n        return composite_simpson(integrand, 0.0, 1.0, N)\n    else:\n        raise ValueError(\"Unknown rule\")\n\ndef finite_diff_grad(a_param, rule, N, delta):\n    # centered finite difference\n    jp = objective_quadrature(a_param + delta, rule, N)\n    jm = objective_quadrature(a_param - delta, rule, N)\n    return (jp - jm) / (2.0 * delta)\n\ndef gradient_descent(rule, N, eta, delta,\n                     a0=0.0, tol_g=1e-8, tol_a=1e-9, max_iter=10000, blowup=1e6):\n    a = a0\n    converged = False\n    iters = 0\n    for k in range(max_iter):\n        g = finite_diff_grad(a, rule, N, delta)\n        # update\n        a_new = a - eta * g\n        iters = k + 1\n        if not np.isfinite(a_new) or abs(a_new)  blowup:\n            converged = False\n            a = a_new\n            break\n        # termination checks\n        if abs(g)  tol_g or abs(a_new - a)  tol_a:\n            converged = True\n            a = a_new\n            break\n        a = a_new\n    # If loop ends without break by convergence, check last state\n    return converged, iters, a\n\ndef main():\n    # Analytical minimizer a* = -5 / (2π)\n    a_star = -5.0 / (2.0 * np.pi)\n\n    # Test cases: (rule, N, eta, delta)\n    test_cases = [\n        (\"trap\", 16, 0.5, 1e-4),\n        (\"trap\", 64, 0.5, 1e-4),\n        (\"simp\", 16, 0.5, 1e-4),\n        (\"trap\", 4, 0.5, 1e-4),\n        (\"trap\", 16, 1.6, 1e-4),\n    ]\n\n    results = []\n    for rule, N, eta, delta in test_cases:\n        # Ensure Simpson has even N (already ensured in the suite)\n        try:\n            converged, iters, a_final = gradient_descent(rule, N, eta, delta)\n        except Exception:\n            converged, iters, a_final = (False, 0, float(\"nan\"))\n        abs_err = abs(a_final - a_star) if np.isfinite(a_final) else float(\"inf\")\n        # Prepare formatted result: [converged(int), iterations(int), a_final(6dp), abs_error(6dp)]\n        results.append((1 if converged else 0, iters, a_final, abs_err))\n\n    # Format output exactly as specified: list of lists on one line, comma-separated, no extra text\n    out_items = []\n    for conv, iters, a_fin, err in results:\n        # Round floats to 6 decimals; if not finite, print \"nan\" or \"inf\" consistently\n        if np.isfinite(a_fin):\n            a_str = f\"{a_fin:.6f}\"\n        else:\n            a_str = \"nan\" if np.isnan(a_fin) else \"inf\"\n        if np.isfinite(err):\n            e_str = f\"{err:.6f}\"\n        else:\n            e_str = \"nan\" if np.isnan(err) else \"inf\"\n        out_items.append(f\"[{conv},{iters},{a_str},{e_str}]\")\n    print(\"[\" + \",\".join(out_items) + \"]\")\n\nif __name__ == \"__main__\":\n    main()\n```", "id": "3108801"}, {"introduction": "在实时控制等对计算时间有严格限制的应用中，我们需要能够在任何时刻给出当前最优解的“随时可用”（anytime）算法。本练习将指导你设计一个基于复合积分规则的高级数值积分方案，它通过二分逐级加密区间，并巧妙利用梯形法则和辛普森法则之间的数学关系（即理查森外推法的基础），来逐步提高积分近似的精度。这个练习将让你从一个数值方法的使用者转变为一个算法设计者，体验如何在满足计算预算的约束下，构建一个高效且自适应的数值计算引擎 [@problem_id:3108814]。", "problem": "您的任务是为实时控制环境设计并实现一个基于复化积分法则的即时数值积分方案。在这种环境下，标量函数 $f(x)$ 在有限闭区间 $[a,b]$ 上的积分必须在严格的截止时间内完成近似计算。为了以纯数学方式对此约束进行建模，定义一个计算预算 $N_{\\max}$，其为函数 $f(x)$ 允许求值的最大次数，即在 $[a,b]$ 上计算 $f(x)$ 的不同点的总数。目标是构建一个能够增量式地优化估计值，并在达到预算上限之前的任何时刻都能输出有效近似值的算法。\n\n从定积分作为 Riemann 和的极限的定义以及分段多项式插值的概念出发。考虑以下要求：\n\n- 对区间 $[a,b]$ 使用二分加密，从单个子区间 ($n=1$) 开始，然后重复地将子区间数量加倍 ($n \\to 2n$)，以构建一个均匀剖分。在从 $n$ 到 $2n$ 的每个加密步骤中，仅在每个子区间二等分所引入的 $n$ 个新中点处对 $f(x)$ 求值。始终重用所有网格点上先前已计算的 $f(x)$ 值。\n- 同时维护两种复化近似：\n  1. 在当前具有 $n$ 个子区间的均匀剖分上的复化梯形法则近似。\n  2. 定义在剖分具有偶数个子区间（即可表示为相邻子区间对）时的复化 Simpson 法则近似。\n- 即时特性要求算法在超出 $N_{\\max}$ 之前的任何时间被中断时，仍能返回可用的最佳梯形近似值。当存在足够的加密以形成至少一个 Simpson 法则块（偶数个子区间）时，也应生成 Simpson 近似，并增量式地更新和返回，作为可用的最佳 Simpson 估计值。如果 $N_{\\max}$ 太小而无法形成 Simpson 近似，算法仍应返回梯形近似值。\n\n设计算法时应使用的基本原理：\n- 定积分作为 Riemann 和的极限的定义。\n- 通过在每个子区间上对局域多项式插值函数进行积分而产生的复化法则原理。\n- 函数求值主导时间成本的计算成本模型；在每个不同点上对 $f(x)$ 的一次求值消耗一个单位的预算。\n\n角度单位说明：\n- 对于三角函数 $\\sin(x)$ 的任何使用，将 $x$ 解释为弧度。\n\n测试套件：\n在以下测试用例上实现并评估您的即时算法。对于每个用例，计算复化梯形即时近似和复化 Simpson 即时近似（如果在预算内可用），将两者与精确积分进行比较，并报告在给定预算下 Simpson 近似的绝对误差是否严格小于梯形近似的绝对误差（如果 Simpson 近似在预算内不可用，则报告其性能不优于梯形近似）。每个用例的精确积分都是解析已知的。\n\n- 用例 $1$：$f_1(x) = \\sin(x)$ 在 $[a,b] = [0,\\pi]$ 上，预算 $N_{\\max} = 3$。对 $\\sin(x)$ 使用弧度。\n- 用例 $2$：$f_2(x) = \\sin(x)$ 在 $[a,b] = [0,\\pi]$ 上，预算 $N_{\\max} = 2$。对 $\\sin(x)$ 使用弧度。\n- 用例 $3$：$f_3(x) = e^{x}$ 在 $[a,b] = [0,1]$ 上，预算 $N_{\\max} = 5$。\n- 用例 $4$：$f_4(x) = |x - 0.3|$ 在 $[a,b] = [0,1]$ 上，预算 $N_{\\max} = 9$。\n\n输出规范：\n- 对每个用例，符号化地计算精确积分 $I_{\\text{true}}$ 和即时近似值。令 $E_{\\mathrm{trap}} = |I_{\\mathrm{trap}} - I_{\\text{true}}|$ 为梯形近似的绝对误差，令 $E_{\\mathrm{simp}} = |I_{\\mathrm{simp}} - I_{\\text{true}}|$ 为 Simpson 近似（如果可用）的绝对误差。输出一个布尔值，指示在给定预算下 Simpson 近似是否严格优于梯形近似，即，如果 $E_{\\mathrm{simp}}  E_{\\mathrm{trap}}$ 且 Simpson 近似在预算内存在，则输出 $\\text{True}$；否则输出 $\\text{False}$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result_1,result_2,result_3,result_4]$）。结果必须与上述用例的顺序一致。\n\n覆盖性设计：\n- 测试套件包括一个预期高阶法则会有帮助的一般光滑情形（用例 3），两个具有三角函数行为且预算不同（包括一个最小边界预算）的情形（用例 1 和 2），以及一个在区间内部有尖点的非光滑情形（用例 4）。这覆盖了理想路径、边界条件和一个重要的边缘情况。\n\n您的实现必须是一个完整、可运行的程序，能够执行上述计算并按指定格式生成输出。", "solution": "用户要求设计并实现一个即时数值积分算法。该算法必须能增量式地优化定积分 $I = \\int_a^b f(x) dx$ 的近似值，并能在达到指定计算预算 $N_{\\max}$（定义为函数求值的最大次数）之前的任何时刻提供一个估计值。该方案必须同时维护来自复化梯形法则和复化 Simpson 法则的近似。\n\n该问题是有效的，因为它科学地基于数值分析的原理，具有明确的目标和约束，是适定的，并且表述客观。\n\n解决方案基于二分加密策略构建，该策略计算效率高，并且天然适用于积分近似的递推更新。\n\n**1. 算法框架：二分加密**\n\n算法从区间 $[a,b]$ 最粗糙的可能剖分开始，该剖分包含单个子区间 ($n=1$)，然后通过对每个现有子区间进行二等分来迭代地加密它。这个在每一步将子区间数量加倍 ($n \\to 2n$) 的过程称为二分加密。在加密级别 $k$（对于 $k=0, 1, 2, \\dots$），剖分由 $n = 2^k$ 个均匀子区间组成，每个子区间的宽度为 $h_k = (b-a)/2^k$。\n\n一个关键要求是有效利用计算预算。在从 $n$ 个子区间到 $2n$ 个子区间的每个加密步骤中，我们只在先前子区间的 $n$ 个新中点处对函数 $f(x)$ 求值。所有先前在现有网格点上计算的函数值都会被重用。\n\n直到加密级别 $k$ 为止，求值的不同点的总数为 $N_k = 2^k + 1$。只要所需函数求值次数不超过预算 $N_{\\max}$，算法就会继续执行级别 $k=0, 1, 2, \\dots$。\n\n**2. 复化梯形法则与递推更新**\n\n复化梯形法则通过对每个子区间上的梯形面积求和来近似积分。对于一个具有 $n$ 个宽度为 $h = (b-a)/n$ 的子区间的剖分，其近似值为：\n$$ T_n = h \\left[ \\frac{1}{2}f(x_0) + \\sum_{i=1}^{n-1} f(x_i) + \\frac{1}{2}f(x_n) \\right] $$\n其中 $x_i = a + i \\cdot h$。\n\n我们的二分加密方案的一个关键方面是能够从 $T_n$ 高效地计算 $T_{2n}$。当我们从 $n$ 个子区间加密到 $2n$ 个子区间时，新的步长变为 $h' = h/2$。新的网格点集包括所有旧点以及每个旧子区间的中点。这就导出了著名的递推公式：\n$$ T_{2n} = \\frac{1}{2} T_n + h' \\sum_{i=1}^{n} f(x'_{2i-1}) $$\n其中 $h' = (b-a)/(2n)$ 是新的步长，求和项是针对 $n$ 个新求值的中点。该公式允许我们在每个加密级别更新梯形近似，而无需对所有点重新求和，从而遵守了重用计算的原则。\n\n即时梯形近似 $I_{\\mathrm{trap}}$ 是在预算 $N_{\\max}$ 内计算出的最新的梯形值 $T_{2^k}$。\n\n**3. 通过 Richardson 外推法得到的复化 Simpson 法则**\n\n当子区间数 $n$ 为偶数时，复化 Simpson 法则是适用的。它是通过在相邻子区间对上对局部二次插值函数进行积分得出的。对于 $n$ 个宽度为 $h=(b-a)/n$ 的子区间，其公式为：\n$$ S_n = \\frac{h}{3} \\left[ f(x_0) + 4\\sum_{i=1}^{n/2} f(x_{2i-1}) + 2\\sum_{i=1}^{n/2-1} f(x_{2i}) + f(x_n) \\right] $$\n\n在我们的加密方案中，直接求和效率低下，取而代之的是，我们可以从两个连续加密级别的梯形法则近似推导出 Simpson 法则近似。这种关系是 Romberg 积分的基石，可以看作是 Richardson 外推法的一个应用。其公式为：\n$$ S_{2n} = \\frac{4T_{2n} - T_n}{3} $$\n这个非凡的恒等式使我们能够计算 Simpson 近似 $S_{2n}$，而无需额外的函数求值，仅使用最近的两个梯形近似 $T_{2n}$ 和 $T_n$。\n\nSimpson 近似 $I_{\\mathrm{simp}}$ 在级别 $k=1$（当形成 $n=2$ 个子区间时）首次可用，并随后在每次加密时更新。即时 Simpson 近似是在预算内计算出的最新值 $S_{2^k}$。如果预算 $N_{\\max}$ 不足以完成 $k=1$ 级别的加密（即 $N_{\\max}  3$），则 $I_{\\mathrm{simp}}$ 不可用。\n\n**4. 即时算法实现**\n\n算法流程如下：\n\n1.  **初始化 ($k=0$)：**\n    - 如果预算 $N_{\\max}  2$，则无法进行近似。否则，计算 $f(a)$ 和 $f(b)$。求值次数为 $N=2$。\n    - 计算初始梯形近似 $T_1 = \\frac{b-a}{2}(f(a)+f(b))$。这是当前最佳的梯形估计值 $I_{\\mathrm{trap}}$。\n    - 此时尚无 Simpson 近似。\n\n2.  **加密循环 (对于 $k=1, 2, \\dots$)：**\n    - 确定此级别所需的新函数求值次数：$2^{k-1}$。\n    - 如果当前求值次数加上新的求值次数超过 $N_{\\max}$，则终止循环。当前最佳估计值 $I_{\\mathrm{trap}}$ 和 $I_{\\mathrm{simp}}$（如果可用）即为给定预算下的最终结果。\n    - 否则，继续进行加密：\n        - 将当前梯形近似 $T_{2^{k-1}}$ 存储为 $T_{\\text{previous}}$。\n        - 在 $2^{k-1}$ 个新中点处对 $f(x)$ 求值，并将结果求和为项 $M_k$。\n        - 更新总求值次数 $N$。\n        - 计算新的梯形近似 $T_{2^k} = \\frac{1}{2}T_{\\text{previous}} + h_k M_k$，其中 $h_k = (b-a)/2^k$。这成为新的 $I_{\\mathrm{trap}}$。\n        - 计算新的 Simpson 近似 $S_{2^k} = \\frac{4T_{2^k} - T_{\\text{previous}}}{3}$。这成为新的 $I_{\\mathrm{simp}}$。\n\n3.  **最终比较：**\n    - 循环因预算约束终止后，计算给定测试用例的真实积分 $I_{\\text{true}}$。\n    - 计算绝对误差 $E_{\\mathrm{trap}} = |I_{\\mathrm{trap}} - I_{\\text{true}}|$ 以及（如果计算了 Simpson 近似）$E_{\\mathrm{simp}} = |I_{\\mathrm{simp}} - I_{\\text{true}}|$。\n    - 该测试用例的最终结果是表达式（$I_{\\mathrm{simp}}$ 可用且 $E_{\\mathrm{simp}}  E_{\\mathrm{trap}}$）的布尔值。\n\n该算法满足所有问题要求：它是即时的，使用二分加密，重用函数求值，同时维护梯形和 Simpson 近似，并遵守指定的计算预算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs, implements, and evaluates an anytime numerical integration scheme\n    based on composite trapezoidal and Simpson's rules with dyadic refinement.\n    \"\"\"\n\n    def f1(x):\n        return np.sin(x)\n\n    def f2(x):\n        return np.sin(x)\n\n    def f3(x):\n        return np.exp(x)\n\n    def f4(x):\n        return np.abs(x - 0.3)\n\n    test_cases = [\n        # Case 1: sin(x) on [0, pi] with budget N_max = 3\n        {'func': f1, 'a': 0.0, 'b': np.pi, 'N_max': 3, 'I_true': 2.0},\n        # Case 2: sin(x) on [0, pi] with budget N_max = 2\n        {'func': f2, 'a': 0.0, 'b': np.pi, 'N_max': 2, 'I_true': 2.0},\n        # Case 3: exp(x) on [0, 1] with budget N_max = 5\n        {'func': f3, 'a': 0.0, 'b': 1.0, 'N_max': 5, 'I_true': np.e - 1.0},\n        # Case 4: |x - 0.3| on [0, 1] with budget N_max = 9\n        {'func': f4, 'a': 0.0, 'b': 1.0, 'N_max': 9, 'I_true': 0.29},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        f = case['func']\n        a = case['a']\n        b = case['b']\n        N_max = case['N_max']\n        I_true = case['I_true']\n\n        # Anytime algorithm state variables\n        num_evals = 0\n        trap_approx = 0.0\n        simp_approx = None \n        simpson_available = False\n\n        # --- Algorithm Implementation ---\n\n        # Initialization (k=0, n=1)\n        if N_max  2:\n            # Not enough budget for the most basic approximation\n            trap_approx = np.nan\n        else:\n            f_a = f(a)\n            f_b = f(b)\n            num_evals = 2\n            \n            h = b - a\n            T_current = h * (f_a + f_b) / 2.0\n            trap_approx = T_current\n\n        # Refinement loop\n        k = 0\n        while True:\n            k += 1\n            n_prev = 2**(k - 1)\n            num_new_evals = n_prev\n            \n            # Check if budget for next refinement is available\n            if num_evals + num_new_evals  N_max:\n                break\n            \n            # Commit to the refinement\n            T_previous = T_current\n            \n            n_current = 2**k\n            h_current = (b - a) / n_current\n            \n            midpoint_sum = 0.0\n            for i in range(1, n_prev + 1):\n                midpoint_x = a + (2 * i - 1) * h_current\n                midpoint_sum += f(midpoint_x)\n            \n            num_evals += num_new_evals\n            \n            # Update trapezoidal approximation\n            T_current = 0.5 * T_previous + h_current * midpoint_sum\n            trap_approx = T_current\n            \n            # Update Simpson's approximation (now available)\n            simp_approx = (4.0 * T_current - T_previous) / 3.0\n            simpson_available = True\n        \n        # --- End of Algorithm ---\n\n        # Final comparison based on the problem statement\n        if simpson_available:\n            E_trap = np.abs(trap_approx - I_true)\n            E_simp = np.abs(simp_approx - I_true)\n            \n            # Output True if Simpson's rule is strictly better\n            result = E_simp  E_trap\n        else:\n            # Simpson's was not available within budget\n            result = False\n        \n        results.append(result)\n\n    # Format the final output exactly as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3108814"}]}