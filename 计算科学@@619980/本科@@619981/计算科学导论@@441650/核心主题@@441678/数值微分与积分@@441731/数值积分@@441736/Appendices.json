{"hands_on_practices": [{"introduction": "我们的第一个实践将理论与物理应用联系起来。通过计算一个非线性弹簧所做的功，你将亲手实现并比较两种基本的复合数值积分方法：梯形法则和辛普森法则。这项练习不仅能让你掌握这些方法的核心思想，还能让你在处理多项式函数时，直观地观察并理解它们的精度差异。[@problem_id:3214920]", "problem": "您需要设计并实现一个程序，用于计算一个具有非线性刚度的质点-弹簧系统沿一维位移从位置 $x=a$ 移动到位置 $x=b$ 所需的机械功 $W$。力定律为 $F(x)=kx+\\alpha x^{3}$，其中 $k$ 和 $\\alpha$ 是实数常量。功由黎曼积分定义为 $W=\\int_{a}^{b}F(x)\\,dx$。您的程序必须在具有 $n$ 个子区间的均匀划分上，使用两种复合数值积分方案来近似计算 $W$：复合梯形法则和复合辛普森法则。这两种方法都源于标准观点，即在子区间上用低阶多项式逼近被积函数，并对它们在子区间上的精确积分求和。此外，通过直接对给定的 $F(x)$ 进行积分来计算精确功，并用它来量化每种数值方法的绝对误差。所有的功值和误差都必须以焦耳 (J) 为单位，表示为浮点数。\n\n用于推导和算法设计的基础原理：功的积一定义 $W=\\int_{a}^{b}F(x)\\,dx$，多项式的性质，以及 Newton–Cotes 求积的基本原理，即通过在每个子区间上对被积函数的插值多项式进行积分来近似原积分。在您的推理中，不要假设或引用任何预先推导出的求积权重；相反，您的设计应基于多项式插值和多项式在有限区间上精确积分的第一性原理。\n\n在均匀划分 $\\{x_{i}\\}_{i=0}^{n}$ 上实现这两种复合规则，其中 $x_{0}=a$，$x_{n}=b$，$x_{i}=a+ih$，以及 $h=(b-a)/n$。对于复合辛普森法则，$n$ 必须是偶数。对于下面的每个测试用例，计算：\n- 精确功 $W_{\\text{exact}}=\\int_{a}^{b}F(x)\\,dx$，\n- 复合梯形近似值 $W_{\\text{trap}}$，\n- 复合辛普森近似值 $W_{\\text{simp}}$，\n- 梯形法则绝对误差 $e_{\\text{trap}}=\\lvert W_{\\text{trap}}-W_{\\text{exact}}\\rvert$，\n- 辛普森法则绝对误差 $e_{\\text{simp}}=\\lvert W_{\\text{simp}}-W_{\\text{exact}}\\rvert$。\n\n此问题不涉及角度单位。所有长度 $x$ 的单位是米 (m)，$k$ 的单位是牛顿/米 (N/m)，$\\alpha$ 的单位是牛顿/米³ (N/m³)，所有功值都必须以焦耳 (J) 为单位报告。\n\n使用以下测试套件，它涵盖了一般情况、线性边界情况、软化非线性情况和粗糙划分的边缘情况：\n- 用例 1：$k=100$，$\\alpha=2000$，$a=0$，$b=0.2$，$n=20$。\n- 用例 2：$k=250$，$\\alpha=0$，$a=0$，$b=0.3$，$n=12$。\n- 用例 3：$k=50$，$\\alpha=-500$，$a=0.0$，$b=0.25$，$n=10$。\n- 用例 4：$k=120$，$\\alpha=8000$，$a=0.05$，$b=0.18$，$n=2$。\n\n您的程序必须生成单行输出，其中包含所有测试用例的汇总结果，格式为逗号分隔的列表的列表，不含空格。对于每个用例，内部列表必须按 $[W_{\\text{exact}},W_{\\text{trap}},W_{\\text{simp}},e_{\\text{trap}},e_{\\text{simp}}]$ 的顺序排列。因此，最终输出必须是形式为 [[case1],[case2],[case3],[case4]] 的单行字符串，其中每个 [casei] 是按指定顺序用方括号括起来的五元组。不要打印单位；数值应理解为以焦耳 (J) 为单位。", "solution": "用户想要解决一个关于数值积分的问题，特别是使用复合求积法则计算机械功。\n\n### 第一步：提取已知条件\n\n-   **物理系统**：一个具有非线性恢复力的质点-弹簧系统。\n-   **力定律**：$F(x)=kx+\\alpha x^{3}$，其中 $k$ 和 $\\alpha$ 是实数常量。\n-   **功的定义**：$W=\\int_{a}^{b}F(x)\\,dx$。\n-   **数值方法**：复合梯形法则和复合辛普森法则。\n-   **划分**：具有 $n$ 个子区间的均匀划分 $\\{x_{i}\\}_{i=0}^{n}$，其中 $x_{0}=a$，$x_{n}=b$，$x_{i}=a+ih$，且 $h=(b-a)/n$。\n-   **约束**：对于复合辛普森法则，$n$ 必须是偶数。\n-   **任务**：对于每个测试用例，计算：\n    1.  精确功，$W_{\\text{exact}}=\\int_{a}^{b}F(x)\\,dx$。\n    2.  复合梯形近似值，$W_{\\text{trap}}$。\n    3.  复合辛普森近似值，$W_{\\text{simp}}$。\n    4.  梯形法则绝对误差，$e_{\\text{trap}}=\\lvert W_{\\text{trap}}-W_{\\text{exact}}\\rvert$。\n    5.  辛普森法则绝对误差，$e_{\\text{simp}}=\\lvert W_{\\text{simp}}-W_{\\text{exact}}\\rvert$。\n-   **推导要求**：算法必须从多项式插值和多项式精确积分的第一性原理推导得出。\n-   **单位**：长度 $x$ 单位为米 (m)，$k$ 单位为牛顿/米 (N/m)，$\\alpha$ 单位为牛顿/米³ (N/m³)，功 $W$ 单位为焦耳 (J)。\n-   **测试用例**：\n    -   用例 1：$k=100$，$\\alpha=2000$，$a=0$，$b=0.2$，$n=20$。\n    -   用例 2：$k=250$，$\\alpha=0$，$a=0$，$b=0.3$，$n=12$。\n    -   用例 3：$k=50$，$\\alpha=-500$，$a=0.0$，$b=0.25$，$n=10$。\n    -   用例 4：$k=120$，$\\alpha=8000$，$a=0.05$，$b=0.18$，$n=2$。\n\n### 第二步：使用提取的已知条件进行验证\n\n-   **科学基础**：该问题在经典力学（功作为力的积分）和数值分析（Newton-Cotes求积）方面有坚实的科学基础。力定律 $F(x)=kx+\\alpha x^3$ 是非线性弹簧（杜芬振子）的标准模型，是物理学和工程动力学中的一个核心内容。\n-   **适定性**：该问题是适定的。被积函数 $F(x)$ 是一个多项式，它是连续且无限可微的，保证了唯一确定积分的存在。指定的数值方法，即复合梯形法则和辛普森法则，是定义明确的算法，对于给定的函数和划分会产生唯一的结果。对于辛普森法则，$n$ 必须为偶数的条件已被注意到，并且所有提供的测试用例都遵守此要求。\n-   **客观性**：该问题以客观和精确的语言陈述。所有参数、变量和计算目标都清晰定义，没有歧义或主观解释。\n-   **完整性和一致性**：该问题提供了所有必要的信息：要积分的函数、其参数（$k, \\alpha$）、积分限（$a, b$）以及每个用例的子区间数（$n$）。要计算的量的定义是明确的。单位在整个问题中是一致的。\n-   **无其他缺陷**：该问题未显示出验证清单中的任何其他缺陷。辛普森法则对于给定的被积函数是精确的这一事实是一个需要被发现和证明的关键属性，而不是使问题变得微不足道的缺陷。任务仍然是从第一性原理推导方法并实现它们以计算指定的值。\n\n### 第三步：结论和行动\n\n问题陈述是**有效的**。它在科学上是合理的、适定的和完整的。我现在将进行完整的求解。\n\n### 基于原理的求解设计\n\n变力 $F(x)$ 在一维路径上将物体从 $x=a$ 移动到 $x=b$ 时所做的机械功 $W$ 由定积分给出：\n$$\nW = \\int_{a}^{b} F(x) \\,dx\n$$\n在此问题中，力由非线性函数 $F(x) = kx + \\alpha x^3$ 给出。我们将首先找到功的精确解析解，然后按要求从第一性原理推导数值近似。\n\n#### 1. 精确功计算 ($W_{\\text{exact}}$)\n精确功通过直接对多项式力函数进行积分得到。使用积分的幂法则 $\\int x^p \\,dx = \\frac{x^{p+1}}{p+1}$：\n$$\nW_{\\text{exact}} = \\int_{a}^{b} (kx + \\alpha x^3) \\,dx = \\left[ k\\frac{x^2}{2} + \\alpha\\frac{x^4}{4} \\right]_{a}^{b}\n$$\n在积分上下限处计算反导数得到：\n$$\nW_{\\text{exact}} = \\left( k\\frac{b^2}{2} + \\alpha\\frac{b^4}{4} \\right) - \\left( k\\frac{a^2}{2} + \\alpha\\frac{a^4}{4} \\right)\n$$\n该公式提供了精确的基准值，我们将用它来与数值方法进行比较。\n\n#### 2. 复合梯形法则 ($W_{\\text{trap}}$)\n该法则通过对每个子区间内曲线下形成的梯形面积求和来近似积分。积分区间 $[a, b]$ 被划分为 $n$ 个宽度为 $h = (b-a)/n$ 的均匀子区间 $[x_i, x_{i+1}]$，其中 $i = 0, 1, \\dots, n-1$。\n\n**第一性原理推导：**\n在单个子区间 $[x_i, x_{i+1}]$ 上，我们用一个通过点 $(x_i, F(x_i))$ 和 $(x_{i+1}, F(x_{i+1}))$ 的线性多项式（一条直线）$P_1(x)$ 来近似函数 $F(x)$。这个线性插值函数的积分就是由这些点和x轴构成的梯形的面积：\n$$\n\\int_{x_i}^{x_{i+1}} F(x) \\,dx \\approx \\int_{x_i}^{x_{i+1}} P_1(x) \\,dx = \\frac{1}{2} (F(x_i) + F(x_{i+1})) (x_{i+1} - x_i) = \\frac{h}{2} (F(x_i) + F(x_{i+1}))\n$$\n复合规则将这 $n$ 个子区间上的近似值相加：\n$$\nW_{\\text{trap}} = \\sum_{i=0}^{n-1} \\frac{h}{2} (F(x_i) + F(x_{i+1}))\n$$\n展开并合并各项：\n$$\nW_{\\text{trap}} = \\frac{h}{2} [ (F(x_0) + F(x_1)) + (F(x_1) + F(x_2)) + \\dots + (F(x_{n-1}) + F(x_n)) ]\n$$\n$$\nW_{\\text{trap}} = \\frac{h}{2} [ F(x_0) + 2F(x_1) + 2F(x_2) + \\dots + 2F(x_{n-1}) + F(x_n) ]\n$$\n为了便于实现，可以更紧凑地写成：\n$$\nW_{\\text{trap}} = h \\left( \\frac{F(x_0) + F(x_n)}{2} + \\sum_{i=1}^{n-1} F(x_i) \\right)\n$$\n\n#### 3. 复合辛普森法则 ($W_{\\text{simp}}$)\n该法则通过使用二次近似提供更高的精度。它要求子区间数量 $n$ 为偶数。该法则通过考虑成对的子区间，即宽度为 $2h$ 的区间，如 $[x_i, x_{i+2}]$ 来工作。\n\n**第一性原理推导：**\n在单个区间 $[x_{2j-2}, x_{2j}]$ 上（对于 $j = 1, \\dots, n/2$），我们用一个二次多项式 $P_2(x)$ 来近似 $F(x)$，该多项式在三个点上对函数进行插值：$(x_{2j-2}, F(x_{2j-2}))$，$(x_{2j-1}, F(x_{2j-1}))$ 和 $(x_{2j}, F(x_{2j}))$。\n为了找到 $P_2(x)$ 的积分，为简便起见，我们可以将区间平移到 $[-h, h]$（令 $z = x - x_{2j-1}$）。二次插值多项式在该区间上的积分给出了著名的单个区间的辛普森1/3法则公式：\n$$\n\\int_{x_{2j-2}}^{x_{2j}} F(x) \\,dx \\approx \\int_{-h}^{h} P_2(z) \\,dz = \\frac{h}{3} (F(x_{2j-2}) + 4F(x_{2j-1}) + F(x_{2j}))\n$$\n复合规则将这 $n/2$ 个区间上的近似值相加：\n$$\nW_{\\text{simp}} = \\sum_{j=1}^{n/2} \\frac{h}{3} (F(x_{2j-2}) + 4F(x_{2j-1}) + F(x_{2j}))\n$$\n展开这个和式可以揭示函数求值的权重模式：\n$$\nW_{\\text{simp}} = \\frac{h}{3} [ (F(x_0) + 4F(x_1) + F(x_2)) + (F(x_2) + 4F(x_3) + F(x_4)) + \\dots + (F(x_{n-2}) + 4F(x_{n-1}) + F(x_n)) ]\n$$\n具有偶数索引的内部点（例如 $F(x_2)$）被计算两次，而具有奇数索引的点被计算一次（乘以4）。合并各项得到最终公式：\n$$\nW_{\\text{simp}} = \\frac{h}{3} [ F(x_0) + 4F(x_1) + 2F(x_2) + 4F(x_3) + \\dots + 2F(x_{n-2}) + 4F(x_{n-1}) + F(x_n) ]\n$$\n这可以通过分别对奇数索引和偶数索引的项求和来实现：\n$$\nW_{\\text{simp}} = \\frac{h}{3} \\left( F(x_0) + F(x_n) + 4 \\sum_{i=1, i \\text{ odd}}^{n-1} F(x_i) + 2 \\sum_{i=2, i \\text{ even}}^{n-2} F(x_i) \\right)\n$$\n辛普森法则的一个关键性质是它对任意次数小于等于 $3$ 的多项式都是精确的。由于我们的力函数 $F(x) = kx + \\alpha x^3$ 是一个三次多项式，辛普森法则的误差项（取决于 $F(x)$ 的四阶导数）为零（$F^{(4)}(x) = 0$）。因此，复合辛普森法则将计算出精确功，$W_{\\text{simp}} = W_{\\text{exact}}$，且误差 $e_{\\text{simp}}$ 将为零（或在机器浮点精度范围内为零）。\n\n#### 4. 绝对误差计算\n梯形法则 ($e_{\\text{trap}}$) 和辛普森法则 ($e_{\\text{simp}}$) 的绝对误差通过计算数值近似值与精确值之差的绝对值得到：\n$$\ne_{\\text{trap}} = \\lvert W_{\\text{trap}} - W_{\\text{exact}} \\rvert\n$$\n$$\ne_{\\text{simp}} = \\lvert W_{\\text{simp}} - W_{\\text{exact}} \\rvert\n$$\n\n接下来的实现将为每个测试用例编写这些推导出的公式的代码。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes exact work, composite trapezoidal and Simpson's rule approximations,\n    and their absolute errors for a nonlinear spring system.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (k, alpha, a, b, n)\n        (100.0, 2000.0, 0.0, 0.2, 20),\n        (250.0, 0.0, 0.0, 0.3, 12),\n        (50.0, -500.0, 0.0, 0.25, 10),\n        (120.0, 8000.0, 0.05, 0.18, 2),\n    ]\n\n    results = []\n    for k, alpha, a, b, n in test_cases:\n        # Define the force function F(x) = kx + alpha*x^3\n        def F(x):\n            return k * x + alpha * x**3\n\n        # 1. Exact Work Calculation (W_exact)\n        # The analytical integral of F(x) is (k/2)*x^2 + (alpha/4)*x^4.\n        work_exact = (k / 2.0 * b**2 + alpha / 4.0 * b**4) - \\\n                     (k / 2.0 * a**2 + alpha / 4.0 * a**4)\n\n        # Set up the uniform partition for numerical integration\n        h = (b - a) / n\n        x = np.linspace(a, b, n + 1)\n        y = F(x)\n\n        # 2. Composite Trapezoidal Rule (W_trap)\n        # Formula: h * [ (y_0 + y_n)/2 + sum(y_i for i=1 to n-1) ]\n        if n > 0:\n            work_trap = h * (0.5 * y[0] + np.sum(y[1:-1]) + 0.5 * y[-1])\n        else: # Handle n=0 case, though not in test data\n            work_trap = 0.0\n\n        # 3. Composite Simpson's Rule (W_simp)\n        # Formula: (h/3) * [ y_0 + 4*sum(odd_indices) + 2*sum(even_indices) + y_n ]\n        # This rule requires n to be even, which is true for all test cases.\n        if n % 2 == 0 and n > 0:\n            sum_odd_indices = np.sum(y[1:-1:2])\n            sum_even_indices = np.sum(y[2:-1:2])\n            work_simp = (h / 3.0) * (y[0] + 4.0 * sum_odd_indices + 2.0 * sum_even_indices + y[-1])\n        else:\n            # Not applicable for odd n, but handle for completeness\n            work_simp = float('nan') \n\n        # 4. Absolute Error Calculations\n        error_trap = abs(work_trap - work_exact)\n        error_simp = abs(work_simp - work_exact)\n\n        # Append the 5-tuple of results for the current case.\n        results.append([work_exact, work_trap, work_simp, error_trap, error_simp])\n\n    # Final print statement in the exact required format.\n    # [[case1],[case2],[case3],[case4]] with no spaces.\n    case_strings = [f'[{\",\".join(map(str, res))}]' for res in results]\n    print(f'[{\",\".join(case_strings)}]')\n\nsolve()\n```", "id": "3214920"}, {"introduction": "在现实世界的许多问题中，被积函数的“趣味性”在积分区间内并非均匀分布。本练习将引导你处理一个具有尖锐峰值的函数，并实现一种更智能、更高效的策略：自适应辛普森积分法。通过将其与均匀网格方法进行比较，你将深刻理解自适应方法如何将计算资源集中在最需要的地方，从而在保证精度的同时节省计算成本。[@problem_id:3214881]", "problem": "考虑在区间 $[0,1]$ 上对函数 $f(x) = \\exp\\left(-100(x - 0.3)^2\\right)$ 进行定积分的数值计算。任务是实现两种基于辛普森法则的复合数值积分方法，并比较它们的精度和计算量：\n\n1. 一种均匀复合辛普森方法，将 $[0,1]$ 划分成 $N$ 个相等的子区间，其中 $N$ 是一个偶数。如果提供了奇数 $N$，实现时必须将其加 1，以使该法则适用。\n\n2. 一种带有局部误差控制的自适应复合辛普森方法，该方法递归地细分一个区间，直到满足指定的局部绝对容差 $\\text{tol}$。局部误差控制必须通过比较一个区间上的辛普森近似值与其两半区间上辛普森近似值之和来实施，并通过在子区间上分配容差的方式来确保全局绝对误差得到控制。\n\n该实现应基于以下基本原理：\n\n- 多项式插值：在区间上通过三点用二次插值多项式逼近一个足够光滑的函数，并对该插值多项式进行精确积分。\n- 基于复合多项式的求积误差行为：对于足够光滑的函数 $f$，辛普森法则在单个面板上的截断误差与区间长度的五次方成比例，在均匀应用时产生四阶的全局收敛率。\n\n使用高斯函数的已知反导数（以误差函数表示）计算积分的真值，并将其用作误差计算的基准。\n\n对于每种方法，报告：\n- 相对于积分真值的绝对误差。\n- 所使用的函数求值次数。\n\n程序必须实现这两种方法，并运行以下测试套件，其中每个测试用例是一对 $(\\text{tol}, N)$：\n\n- 测试用例 1 (正常路径)：$\\text{tol} = 10^{-6}$，$N = 100$。\n- 测试用例 2 (更严的容差，更密的网格)：$\\text{tol} = 10^{-8}$，$N = 1000$。\n- 测试用例 3 (更宽松的容差，更粗的网格)：$\\text{tol} = 10^{-4}$，$N = 10$。\n- 测试用例 4 (使用最少均匀面板的边界情况)：$\\text{tol} = 10^{-10}$，$N = 2$。\n- 测试用例 5 (非常严格的容差)：$\\text{tol} = 10^{-12}$，$N = 200$。\n\n您的程序必须生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。此列表的每个元素对应一个测试用例，并且本身必须是一个包含以下顺序的四个值的列表：$[\\text{abs\\_error\\_adaptive}, \\text{evals\\_adaptive}, \\text{abs\\_error\\_uniform}, \\text{evals\\_uniform}]$。例如，两个用例的输出形式为 $[[e_1,c_1,E_1,C_1],[e_2,c_2,E_2,C_2]]$。\n\n此问题不涉及物理单位，也不需要角度或百分比。最终输出值必须是实数或整数（视情况而定），不带任何附加文本。", "solution": "用户提供了一个有效的问题陈述。\n\n### 步骤 1：提取已知信息\n- **待积函数**：$f(x) = \\exp\\left(-100(x - 0.3)^2\\right)$\n- **积分区间**：$[0, 1]$\n- **方法 1**：均匀复合辛普森法则，使用 $N$ 个相等的子区间。如果 $N$ 是奇数，则必须加 1。\n- **方法 2**：自适应复合辛普森法则，使用局部绝对容差 $\\text{tol}$。通过比较同一区间上的单面板辛普森法则近似值 ($S_1$) 和双面板近似值 ($S_2$) 来估计局部误差。\n- **真值**：使用误差函数 $\\text{erf}(x)$ 计算。\n- **每种方法的输出**：相对于真值的绝对误差和函数求值总次数。\n- **测试套件**：一系列测试用例，每个用例由一对 $(\\text{tol}, N)$ 定义：\n    1. $(\\text{tol} = 10^{-6}, N = 100)$\n    2. $(\\text{tol} = 10^{-8}, N = 1000)$\n    3. $(\\text{tol} = 10^{-4}, N = 10)$\n    4. $(\\text{tol} = 10^{-10}, N = 2)$\n    5. $(\\text{tol} = 10^{-12}, N = 200)$\n- **输出格式**：单行文本：`[[abs_error_adaptive, evals_adaptive, abs_error_uniform, evals_uniform], ...]`，包含所有测试用例。\n\n### 步骤 2：使用提取的已知信息进行验证\n问题被评估为**有效**。\n\n- **科学依据**：该问题是数值分析中的一个标准练习，涉及实现和比较公认的求积法则（复合辛普森法则、自适应求积）。该函数是一个高斯函数，它是解析的，因此是无限可微的 ($C^\\infty$)，这使其成为高阶积分方法的理想选择。通过误差函数计算真值的方法在数学上是合理的。\n- **适定性**：问题定义清晰。函数、区间、方法和参数都已指定。对于每个测试用例，都可以计算出唯一的数值结果。\n- **客观性**：语言精确，没有主观或含糊的术语。\n- **完整性和一致性**：问题是自包含的。提供了实现解决方案和运行测试所需的所有信息。没有内部矛盾。\n- **可行性**：所需的计算是标准的，并且在计算上是可行的。\n\n### 步骤 3：结论与行动\n问题有效。将开发一个完整的解决方案。\n\n### 基于原理的解决方案\n任务是使用复合辛普森法则的两种变体来计算定积分 $I = \\int_0^1 f(x) \\,dx$（其中 $f(x) = \\exp\\left(-100(x - 0.3)^2\\right)$），并比较它们的效率。\n\n**1. 积分的真值**\n\n高斯函数的积分可以用误差函数 $\\text{erf}(z) = \\frac{2}{\\sqrt{\\pi}} \\int_0^z e^{-t^2} \\,dt$ 来表示。\n令 $I = \\int_0^1 \\exp\\left(-100(x - 0.3)^2\\right) \\,dx$。\n我们进行变量替换。令 $u = \\sqrt{100}(x - 0.3) = 10(x - 0.3)$。这意味着 $du = 10 \\,dx$，即 $dx = \\frac{1}{10} \\,du$。\n$u$ 的积分上下限是：\n- 当 $x = 0$ 时，$u = 10(0 - 0.3) = -3$。\n- 当 $x = 1$ 时，$u = 10(1 - 0.3) = 7$。\n\n积分变为：\n$$ I = \\int_{-3}^{7} e^{-u^2} \\frac{1}{10} \\,du = \\frac{1}{10} \\int_{-3}^{7} e^{-u^2} \\,du $$\n使用误差函数的定义：\n$$ \\int_a^b e^{-t^2} \\,dt = \\int_0^b e^{-t^2} \\,dt - \\int_0^a e^{-t^2} \\,dt = \\frac{\\sqrt{\\pi}}{2} \\left[ \\text{erf}(b) - \\text{erf}(a) \\right] $$\n当 $a = -3$ 和 $b = 7$ 时，我们得到：\n$$ I = \\frac{1}{10} \\left[ \\frac{\\sqrt{\\pi}}{2} (\\text{erf}(7) - \\text{erf}(-3)) \\right] $$\n利用性质 $\\text{erf}(-z) = -\\text{erf}(z)$，真值为：\n$$ I_{true} = \\frac{\\sqrt{\\pi}}{20} \\left[ \\text{erf}(7) + \\text{erf}(3) \\right] $$\n这个值将作为我们计算数值方法绝对误差的基准。\n\n**2. 均匀复合辛普森法则**\n\n辛普森法则通过对通过点 $(a, f(a))$、 $((a+b)/2, f((a+b)/2))$ 和 $(b, f(b))$ 的二次插值多项式进行积分，来近似函数 $f(x)$ 在区间 $[a, b]$ 上的积分。公式为：\n$$ S(a, b) = \\frac{b-a}{6} \\left[ f(a) + 4f\\left(\\frac{a+b}{2}\\right) + f(b) \\right] $$\n复合辛普森法则在积分区间的划分上应用此公式。对于将 $[a, b]$ 均匀划分为 $N$ 个等宽子区间（宽度 $h = (b-a)/N$，其中 $N$ 必须是偶数），节点为 $x_i = a + ih$（$i = 0, 1, \\dots, N$）。积分近似为：\n$$ S_N = \\frac{h}{3} \\left[ f(x_0) + 4\\sum_{i=1, i \\text{ odd}}^{N-1} f(x_i) + 2\\sum_{i=2, i \\text{ even}}^{N-2} f(x_i) + f(x_N) \\right] $$\n此方法的函数求值次数为 $N+1$。根据问题要求，如果给定的 $N$ 为奇数，则将其增加到 $N+1$，使求值次数变为 $N+2$。\n\n**3. 自适应复合辛普森法则**\n\n自适应求积方法根据被积函数的局部行为调整求值点的密度。函数 $f(x)$ 在 $x=0.3$ 附近有一个尖峰，在其他地方几乎为零，这使其成为自适应方法的理想候选。该方法工作如下：\n\n对于一个区间 $[a, b]$，我们计算两个近似值：\n- 一个“粗略”近似值 $S_1$，使用 $[a, b]$ 上的单个辛普森面板。\n- 一个“精细”近似值 $S_2$，通过在半区间 $[a, m]$ 和 $[m, b]$（其中 $m = (a+b)/2$）上对两个辛普森面板求和得到。\n\n在宽度为 $h=b-a$ 的区间上，单面板辛普森法则的误差近似为 $E_1 \\approx -\\frac{h^5}{2880} f^{(4)}(\\xi)$。双面板近似的误差为 $E_2 \\approx 2 \\times \\left(-\\frac{(h/2)^5}{2880} f^{(4)}(\\eta)\\right) \\approx \\frac{1}{16} E_1$。\n真积分 $I$ 可以写成 $I = S_1 + E_1$ 和 $I = S_2 + E_2$。\n假设 $f^{(4)}$ 在 $[a, b]$ 上几乎是常数，我们可以在近似值和较精细近似的误差 $E_2$ 之间建立关系：\n$$ S_2 - S_1 \\approx E_1 - E_2 \\approx 16 E_2 - E_2 = 15 E_2 $$\n因此，$S_2$ 中局部误差的估计值为 $\\text{err} \\approx \\frac{|S_2 - S_1|}{15}$。\n\n自适应算法是递归的：\n1. 对于给定的区间 $[a, b]$ 和局部容差 $\\text{tol}_{local}$，计算 $S_1$ 和 $S_2$。\n2. 计算误差估计 $\\text{err} = \\frac{|S_2 - S_1|}{15}$。\n3. 如果 $\\text{err}  \\text{tol}_{local}$，则该区间已足够精细。我们接受结果，并且为了提高精度，返回理查森外推值 $I_{[a,b]} = S_2 + \\frac{S_2 - S_1}{15}$。这是对该区间上积分更准确的估计。\n4. 如果 $\\text{err} \\ge \\text{tol}_{local}$，则该区间未解析。将其细分为 $[a, m]$ 和 $[m, b]$。对每个子区间递归调用算法，但每个子区间的容差减半：$\\text{tol}_{local}/2$。总积分是两次递归调用结果之和。\n\n为确保全局误差控制，容差按区间宽度成比例分配。初始调用使用全局容差 $\\text{tol}$。在半区间上的每个递归步骤使用其父区间容差的一半。\n\n为避免冗余计算，端点和中点的函数值会通过递归向下传递。在已知 $f(a)$、 $f((a+b)/2)$ 和 $f(b)$ 的情况下，对 $[a, b]$ 的一个递归步骤只需要计算两个新值：$f((a+m)/2)$ 和 $f((m+b)/2)$。在整个递归过程中跟踪函数求值的总次数。\n\n这种自适应策略将计算量集中在高斯函数峰值周围的区域（$x \\approx 0.3$），即函数变化迅速的地方，而在接近 $x=0$ 和 $x=1$ 的平坦区域使用很少的求值，从而实现高效率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Implements and compares uniform and adaptive Simpson's rule for integrating\n    a Gaussian function, then runs a suite of test cases.\n    \"\"\"\n    \n    # 1. Define the function to integrate\n    def f(x):\n        return np.exp(-100.0 * (x - 0.3)**2)\n\n    # 2. Calculate the \"true\" value of the integral using the error function\n    # I = integral from 0 to 1 of exp(-100*(x-0.3)^2) dx\n    # Let u = 10*(x-0.3), so du = 10*dx.\n    # Limits: x=0 - u=-3; x=1 - u=7.\n    # I = (1/10) * integral from -3 to 7 of exp(-u^2) du\n    # Using erf(z) = (2/sqrt(pi)) * integral from 0 to z of exp(-t^2) dt\n    # Integral from a to b = sqrt(pi)/2 * (erf(b) - erf(a))\n    # I = (1/10) * sqrt(pi)/2 * (erf(7) - erf(-3))\n    #   = (sqrt(pi)/20) * (erf(7) + erf(3))\n    true_value = (math.sqrt(math.pi) / 20.0) * (math.erf(7.0) + math.erf(3.0))\n\n    # 3. Uniform Composite Simpson's Rule Implementation\n    def uniform_simpson(func, a, b, N):\n        \"\"\"\n        Calculates the definite integral using the uniform composite Simpson's rule.\n        \n        Args:\n            func: The function to integrate.\n            a, b: The interval of integration.\n            N: The number of subintervals (must be even, adjusted if not).\n            \n        Returns:\n            A tuple (integral_value, num_evaluations).\n        \"\"\"\n        if N % 2 != 0:\n            N += 1\n        \n        h = (b - a) / float(N)\n        x = np.linspace(a, b, N + 1)\n        y = func(x)\n        \n        # Simpson's formula: h/3 * (y0 + 4y1 + 2y2 + ... + 4y(N-1) + yN)\n        # Slicing: y[1:-1:2] gets odd indices, y[2:-2:2] gets even indices.\n        integral = (h / 3.0) * (y[0] + 4.0 * np.sum(y[1:-1:2]) + 2.0 * np.sum(y[2:-2:2]) + y[-1])\n        \n        evals = N + 1\n        return integral, evals\n\n    # 4. Adaptive Composite Simpson's Rule Implementation\n    def adaptive_simpson(func, a, b, tol):\n        \"\"\"\n        Wrapper for the recursive adaptive Simpson's rule integrator.\n        \n        Args:\n            func: The function to integrate.\n            a, b: The interval of integration.\n            tol: The desired absolute error tolerance.\n            \n        Returns:\n            A tuple (integral_value, num_evaluations).\n        \"\"\"\n        \n        eval_count = [0] # Use a list as a mutable counter\n\n        def f_counted(x):\n            eval_count[0] += 1\n            return func(x)\n        \n        # Initial function evaluations\n        fa = f_counted(a)\n        fm = f_counted((a + b) / 2.0)\n        fb = f_counted(b)\n        \n        integral = _adaptive_simpson_recursive(f_counted, a, b, tol, fa, fm, fb)\n        \n        return integral, eval_count[0]\n\n    def _adaptive_simpson_recursive(func, a, b, tol, fa, fm, fb):\n        \"\"\"Recursive helper for adaptive Simpson's rule.\"\"\"\n        h = b - a\n        m = (a + b) / 2.0\n        \n        # Coarse approximation (1 panel)\n        s1 = (h / 6.0) * (fa + 4.0 * fm + fb)\n        \n        # Finer approximation (2 panels) requires 2 new function evaluations\n        ml = (a + m) / 2.0\n        mr = (m + b) / 2.0\n        fml = func(ml)\n        fmr = func(mr)\n        \n        s2 = (h / 12.0) * (fa + 4.0 * fml + 2.0 * fm + 4.0 * fmr + fb)\n        \n        # Error estimation: |(S2 - S1) / 15| is an estimate of the error in S2.\n        error_estimate = abs(s2 - s1) / 15.0\n        \n        if error_estimate  tol:\n            # Richardson extrapolation for a more accurate result\n            return s2 + (s2 - s1) / 15.0\n        else:\n            # Subdivide and recurse, distributing tolerance\n            left_integral = _adaptive_simpson_recursive(func, a, m, tol / 2.0, fa, fml, fm)\n            right_integral = _adaptive_simpson_recursive(func, m, b, tol / 2.0, fm, fmr, fb)\n            return left_integral + right_integral\n\n    # 5. Define test cases\n    test_cases = [\n        (1e-6, 100),\n        (1e-8, 1000),\n        (1e-4, 10),\n        (1e-10, 2),\n        (1e-12, 200),\n    ]\n\n    all_results = []\n\n    # 6. Run the test suite\n    for tol, N in test_cases:\n        # Run adaptive method\n        res_adaptive, evals_adaptive = adaptive_simpson(f, 0.0, 1.0, tol)\n        error_adaptive = abs(res_adaptive - true_value)\n\n        # Run uniform method\n        res_uniform, evals_uniform = uniform_simpson(f, 0.0, 1.0, N)\n        error_uniform = abs(res_uniform - true_value)\n        \n        # Store results for this test case\n        case_result = [error_adaptive, evals_adaptive, error_uniform, evals_uniform]\n        all_results.append(case_result)\n\n    # 7. Format and print the final output\n    # The output format must be exact: [[v1,v2,v3,v4],[v5,v6,v7,v8]] with no spaces.\n    # repr() gives the correct bracket/comma structure, and .replace removes spaces.\n    output_str = repr(all_results).replace(' ', '')\n    print(output_str)\n\nsolve()\n```", "id": "3214881"}]}