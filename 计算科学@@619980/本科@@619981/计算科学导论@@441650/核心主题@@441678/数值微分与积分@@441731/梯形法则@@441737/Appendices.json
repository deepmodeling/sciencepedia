{"hands_on_practices": [{"introduction": "计算变力所做的功是定积分的一个经典物理应用。当力的函数形式复杂，难以解析求解时，数值方法便为我们提供了强大的近似工具。本练习将通过一个简单的物理场景，带你从零开始应用梯形法则，直观地理解其核心思想：用一系列梯形的面积之和来逼近曲线下的面积。[@problem_id:2222091]", "problem": "在一个材料科学实验中，一个活塞被用来压缩气缸中的气体。这个过程进行得很缓慢，因此可以被认为是准静态和等温的。将活塞保持在位置 $x$ (从气缸的封闭端测量) 所需的力 $F$ 被发现遵循定律 $F(x) = \\frac{k}{x}$，其中 $k$ 是一个与温度和气体量相关的常数。\n\n为了移动活塞并压缩气体，必须做功。由外部作用力将活塞从初始位置 $x_i$ 移动到最终位置 $x_f$ 所做的精确功 $W$ 由积分 $W = \\int_{x_i}^{x_f} F(x) dx$ 给出。\n\n假设活塞从 $x_i = 1$ m 移动到 $x_f = 3$ m，并且常数 $k$ 等于 1 N·m。你的任务是求出所做功的近似值。近似方法包括以下步骤：\n1. 将总位移区间 $[x_i, x_f]$ 分成两个等长的子区间。\n2. 对于每个子区间，用力-位移曲线下的面积，由x轴、子区间端点处的垂直线以及连接这些端点处力值的直线段所形成的梯形面积来近似。\n3. 将这两个梯形的面积相加，得到总的近似功。\n\n使用这种方法，计算移动活塞所做的近似功。将你的答案以焦耳为单位，表示为最简分数。", "solution": "问题要求计算在力 $F(x) = \\frac{k}{x}$ 的作用下，将活塞从 $x_i = 1$ m 移动到 $x_f = 3$ m 所做的功 $W$ 的近似值。我们已知 $k = 1$ N·m。功由以下积分给出：\n$$W = \\int_{1}^{3} \\frac{1}{x} dx$$\n\n问题描述了一种数值近似方法，该方法等价于使用两个分段的复合梯形法则。设区间为 $[a, b] = [1, 3]$，分段数为 $n=2$。要积分的函数是 $f(x) = \\frac{1}{x}$。\n\n首先，我们计算每个子区间的宽度 $h$：\n$$h = \\frac{b - a}{n} = \\frac{3 - 1}{2} = 1$$\n\n两个子区间是 $[1, 2]$ 和 $[2, 3]$。评估点（子区间的端点）是 $x_0 = 1$，$x_1 = 2$ 和 $x_2 = 3$。\n\n所描述的近似方法是求两个梯形的面积之和。\n第一个梯形的面积，在区间 $[x_0, x_1]$ 上，是：\n$$A_1 = \\frac{h}{2} (f(x_0) + f(x_1))$$\n第二个梯形的面积，在区间 $[x_1, x_2]$ 上，是：\n$$A_2 = \\frac{h}{2} (f(x_1) + f(x_2))$$\n\n总的近似功 $W_{approx}$ 是这两个面积的和：\n$$W_{approx} = A_1 + A_2 = \\frac{h}{2}(f(x_0) + f(x_1)) + \\frac{h}{2}(f(x_1) + f(x_2))$$\n这可以简化为标准的复合梯形法则公式：\n$$W_{approx} = \\frac{h}{2} (f(x_0) + 2f(x_1) + f(x_2))$$\n\n现在我们在点 $x_0, x_1, x_2$ 处计算函数 $f(x) = \\frac{1}{x}$ 的值：\n$$f(x_0) = f(1) = \\frac{1}{1} = 1$$\n$$f(x_1) = f(2) = \\frac{1}{2}$$\n$$f(x_2) = f(3) = \\frac{1}{3}$$\n\n现在，我们将这些值代入 $W_{approx}$ 的公式中。我们还代入 $h=1$。\n$$W_{approx} = \\frac{1}{2} \\left( 1 + 2\\left(\\frac{1}{2}\\right) + \\frac{1}{3} \\right)$$\n\n我们简化括号内的表达式：\n$$W_{approx} = \\frac{1}{2} \\left( 1 + 1 + \\frac{1}{3} \\right)$$\n$$W_{approx} = \\frac{1}{2} \\left( 2 + \\frac{1}{3} \\right)$$\n\n为了加上括号内的项，我们找到一个公分母：\n$$W_{approx} = \\frac{1}{2} \\left( \\frac{6}{3} + \\frac{1}{3} \\right)$$\n$$W_{approx} = \\frac{1}{2} \\left( \\frac{7}{3} \\right)$$\n\n最后，我们进行乘法运算：\n$$W_{approx} = \\frac{7}{6}$$\n\n问题说明 $k$ 的单位是 N·m，$x$ 的单位是 m，所以功 $W$ 的单位是焦耳。问题要求答案以焦耳为单位，并表示为最简分数。我们的结果是 $7/6$。", "answer": "$$\\boxed{\\frac{7}{6}}$$", "id": "2222091"}, {"introduction": "得到一个近似值只是第一步，我们如何确保它在药物研发等关键应用中足够精确？本练习将探讨数值积分的“灵魂”——误差控制。通过运用梯形法则的理论误差界，我们将学会如何预先计算所需的计算量，以确保最终结果达到预设的精度要求，从而架起理论分析与实际工程需求之间的桥梁。[@problem_id:2210520]", "problem": "在一项药代动力学研究中，一种新药在患者血液中的浓度被建模为时间 $t$ 的函数，其方程为 $C(t) = C_0 \\exp(-kt^2)$。此处，$t$ 是注射后的时间（单位为小时），$C_0 = 50$ mg/L 是初始浓度，$k = 0.5 \\text{ hr}^{-2}$ 是一个与药物消除速率相关的常数。\n\n为了评估前两个小时内的总药物暴露量，一位生物医学工程师需要计算曲线下面积 (AUC)，它由定积分 $A = \\int_{0}^{T} C(t) dt$ 给出，其中 $T=2$ 小时。\n\n该工程师使用一种数值近似方法。时间区间 $[0, T]$ 被分成 $n$ 个相等的子区间，积分值通过对每个子区间上连接点 $(t_i, C(t_i))$ 和 $(t_{i+1}, C(t_{i+1}))$ 形成的梯形面积求和来近似。\n\n对于这种特定的数值方法，已知绝对误差 $|E_n|$ 由以下不等式界定：\n$$|E_n| \\le \\frac{M(T-0)^3}{12n^2}$$\n其中 $M$ 是浓度函数二阶导数的最大绝对值，$M = \\max_{t \\in [0, T]} |C''(t)|$。\n\n确定工程师必须使用的最小整数子区间数 $n$，以保证计算出的 AUC 的绝对误差小于 $10^{-3}$ mg·hr/L。", "solution": "给定 $C(t) = C_{0}\\exp(-k t^{2})$，其中 $C_{0} = 50$，$k = 0.5$，以及梯形法则误差界\n$$|E_{n}| \\le \\frac{M(T-0)^{3}}{12 n^{2}}, \\quad M = \\max_{t \\in [0,T]} |C''(t)|, \\quad T=2.$$\n\n首先计算 $C''(t)$。求导得，\n$$C'(t) = C_{0}\\exp(-k t^{2})(-2 k t),$$\n$$C''(t) = C_{0}\\exp(-k t^{2})\\left(-2k + 4k^{2} t^{2}\\right) = 2k C_{0}\\exp(-k t^{2})\\left(-1 + 2k t^{2}\\right).$$\n因此\n$$|C''(t)| = 2k C_{0}\\exp(-k t^{2})\\left| -1 + 2k t^{2} \\right|.$$\n\n令 $t_{0} = \\frac{1}{\\sqrt{2k}}$。对于 $t \\in [0,t_{0}]$，我们有 $-1 + 2k t^{2} \\le 0$，所以\n$$|C''(t)| = 2k C_{0}\\exp(-k t^{2})\\left(1 - 2k t^{2}\\right).$$\n定义 $h_{1}(t) = 2k C_{0}\\exp(-k t^{2})(1 - 2k t^{2})$。其导数为\n$$h_{1}'(t) = 4 k^{2} C_{0} t \\exp(-k t^{2})\\left(-3 + 2k t^{2}\\right).$$\n在 $(0,t_{0}]$ 上，因为 $t_{0}^{2} = \\frac{1}{2k}$，我们有 $-3 + 2k t^{2} \\le -3 + 1 = -2  0$，因此 $h_{1}'(t)  0$。所以 $h_{1}$ 在 $[0,t_{0}]$ 上是递减的，并在 $t=0$ 处取得其最大值：\n$$h_{1}(0) = 2k C_{0}.$$\n\n对于 $t \\in [t_{0},T]$，我们有 $-1 + 2k t^{2} \\ge 0$，所以\n$$|C''(t)| = 2k C_{0}\\exp(-k t^{2})\\left(-1 + 2k t^{2}\\right).$$\n定义 $h_{2}(t) = 2k C_{0}\\exp(-k t^{2})(-1 + 2k t^{2})$。其导数为\n$$h_{2}'(t) = 4 k^{2} C_{0} t \\exp(-k t^{2})\\left(3 - 2k t^{2}\\right).$$\n在 $[t_{0},T]$ 内的临界点出现在 $t = \\sqrt{\\frac{3}{2k}}$，如果该点位于区间内。当 $k = 0.5$ 时，我们有 $t_{0} = 1$，$T=2$，且 $\\sqrt{\\frac{3}{2k}} = \\sqrt{3} \\in [1,2]$。在候选点处计算 $h_{2}$ 的值：\n- 在 $t = t_{0}$ 处，$h_{2}(t_{0}) = 0$。\n- 在 $t = \\sqrt{\\frac{3}{2k}}$ 处，因为 $2k t^{2} = 3$，\n$$h_{2}\\!\\left(\\sqrt{\\frac{3}{2k}}\\right) = 2k C_{0} \\cdot 2 \\cdot \\exp\\!\\left(-\\frac{3}{2}\\right) = 4k C_{0}\\exp\\!\\left(-\\frac{3}{2}\\right).$$\n- 在 $t = T=2$ 处，\n$$h_{2}(2) = 2k C_{0}\\left(-1 + 8k\\right)\\exp(-4k).$$\n\n将这些值与 $2k C_{0}$ 进行比较。注意到\n$$4k C_{0}\\exp\\!\\left(-\\frac{3}{2}\\right) = 2k C_{0}\\cdot 2\\exp\\!\\left(-\\frac{3}{2}\\right)  2k C_{0}$$\n因为 $\\exp\\!\\left(\\frac{3}{2}\\right) > 2$，所以 $2\\exp(-\\frac{3}{2})  1$。此外，对于 $k=0.5$，$h_{2}(2)$ 也小于 $2k C_{0}$。因此，在 $[0,2]$ 上的最大值在 $t=0$ 处取得：\n$$M = \\max_{t \\in [0,2]} |C''(t)| = 2k C_{0} = 2 \\cdot 0.5 \\cdot 50 = 50.$$\n\n应用 $T=2$ 时的误差界：\n$$|E_{n}| \\le \\frac{M T^{3}}{12 n^{2}} = \\frac{50 \\cdot 2^{3}}{12 n^{2}} = \\frac{100}{3 n^{2}}.$$\n要求 $|E_{n}|  10^{-3}$：\n$$\\frac{100}{3 n^{2}}  10^{-3} \\quad \\Longleftrightarrow \\quad n^{2} > \\frac{100}{3 \\cdot 10^{-3}} = \\frac{100000}{3}.$$\n因此 $n > \\sqrt{\\frac{100000}{3}}$。因为 $182^{2} = 33124  \\frac{100000}{3}  33489 = 183^{2}$，所以满足该不等式的最小整数 $n$ 是\n$$n = 183.$$", "answer": "$$\\boxed{183}$$", "id": "2210520"}, {"introduction": "在前述练习中，我们使用了固定的步长，但这在计算上并非最优，因为它在函数平缓和剧烈变化的区域投入了相同的计算力。一个更智能的策略是“按需分配”计算资源。本练习将引导你构建一个自适应积分算法，它能通过局部误差估计，自动在函数变化复杂的区域加密计算节点，而在平缓区域放宽，从而在保证精度的前提下，极大地提升计算效率。[@problem_id:3284319]", "problem": "您的任务是构建一个基于基本原理的、自包含的程序，该程序实现一个基于梯形法则基本原理的自适应数值积分方案。核心目标是使用一种自适应细化策略来近似一系列测试函数的定积分 $\\int_{a}^{b} f(x)\\,dx$，该策略通过比较整个区间上的梯形近似与其两个半区间上的梯形近似之和来估计局部误差。\n\n从定积分作为黎曼和的极限的定义以及在 $x=a$ 和 $x=b$ 之间构造 $f(x)$ 的线性插值函数入手。单区间的梯形法则通过对该线性插值函数在 $[a,b]$ 上积分得到。您的算法必须：\n- 在任何宽度为 $h=b-a$ 的子区间 $[a,b]$ 上，计算整个区间的梯形近似值，以及其两个半区间 $[a,m]$ 和 $[m,b]$（其中 $m=(a+b)/2$）上组合的梯形近似值。\n- 仅使用这两种近似值（整个区间的近似值与两个半区间上的近似值之和）之间的比较来设计一个局部误差估计器。该估计器需从关于区间减半时局部截断误差如何随区间宽度变化的合理推断中导出。不要假设或使用任何未从此误差缩放推理中导出的快捷公式。\n- 如果估计的局部误差低于规定的容差，则接受该子区间，并可选择使用从相同误差缩放原理导出的偏差校正估计值；否则，分割该区间并在每个半区间上递归。\n- 通过最大递归深度参数 $D_{\\max}$ 确保终止，并正确处理 $a=b$ 的退化区间。\n\n任何三角函数的角度单位必须是弧度。本问题不涉及物理单位。测试套件中的所有数值容差均为绝对容差。\n\n请实现您的程序以评估以下测试套件。对于每个测试用例，使用您的自适应梯形方案和给定的容差计算积分近似值，并将结果汇总到指定格式的单行输出中。\n\n测试套件：\n1. $f(x)=\\sin(x)$ 在 $[0,\\pi]$ 上，容差 $10^{-12}$。\n2. $f(x)=e^{-x^{2}}$ 在 $[0,1]$ 上，容差 $10^{-12}$。\n3. $f(x)=\\dfrac{1}{1+x^{2}}$ 在 $[-5,5]$ 上，容差 $10^{-10}$。\n4. $f(x)=|x|$ 在 $[-1,1]$ 上，容差 $10^{-10}$。\n5. $f(x)=\\dfrac{\\sin(100x)}{1+x^{2}}$ 在 $[0,1]$ 上，容差 $10^{-8}$。\n6. $f(x)=5$ 在 $[2,5]$ 上，容差 $10^{-12}$。\n7. $f(x)=\\sin(x)$ 在 $[1,1]$ 上（零长度区间），容差 $10^{-12}$。\n\n覆盖性设计：\n- 第一个用例是一个完整周期内的光滑周期函数。\n- 第二个用例是区间内具有快速衰减尾部的钟形被积函数。\n- 第三个用例测试对称大区间上的有理被积函数。\n- 第四个用例测试在中断点不可微的被积函数。\n- 第五个用例是具有中等阻尼的振荡函数。\n- 第六个用例是常数函数，应立即终止。\n- 第七个用例是零长度区间的边界情况。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，不含额外的空格或文本。例如：\"[r1,r2,r3,r4,r5,r6,r7]\"。每个 $r_{i}$ 必须是一个浮点数，代表对应测试用例的积分近似值，由您的自适应梯形方法计算得出。", "solution": "该问题要求开发一种基于梯形法则的自适应数值积分方案。任务的核心是从基本原理出发，具体来说是通过比较一个区间上的粗略近似和更精细的近似，来推导误差估计和细化策略。\n\n### 基于原理的推导\n\n设待近似的定积分为 $I = \\int_{a}^{b} f(x)\\,dx$。\n\n**1. 从基本原理推导梯形法则**\n\n梯形法则用一个线性多项式 $p_1(x)$ 来近似被积函数 $f(x)$，该多项式在区间 $[a, b]$ 的端点处对函数进行插值。这些点的坐标是 $(a, f(a))$ 和 $(b, f(b))$。该线性插值函数由下式给出：\n$$p_1(x) = f(a) + \\frac{f(b) - f(a)}{b-a}(x - a)$$\n这个线性多项式在区间 $[a, b]$ 上的积分给出了梯形近似，记为 $T(a,b)$。令 $h = b - a$ 为区间宽度。\n$$T(a,b) = \\int_{a}^{b} p_1(x) \\,dx = \\int_{a}^{b} \\left( f(a) + \\frac{f(b) - f(a)}{h}(x - a) \\right) \\,dx$$\n$$= \\left[ f(a)x + \\frac{f(b) - f(a)}{h} \\left( \\frac{x^2}{2} - ax \\right) \\right]_{a}^{b}$$\n$$= f(a)(b-a) + \\frac{f(b) - f(a)}{h} \\left( \\left(\\frac{b^2}{2} - ab\\right) - \\left(\\frac{a^2}{2} - a^2\\right) \\right)$$\n$$= f(a)h + \\frac{f(b) - f(a)}{h} \\left( \\frac{b^2 - 2ab + a^2}{2} \\right) = f(a)h + \\frac{f(b) - f(a)}{h} \\frac{(b-a)^2}{2}$$\n$$= f(a)h + (f(b) - f(a))\\frac{h}{2} = \\frac{h}{2}(2f(a) + f(b) - f(a)) = \\frac{h}{2}(f(a) + f(b))$$\n这就是单区间的梯形法则。我们称之为粗略近似 $S_1$。\n$$S_1 = \\frac{h}{2}(f(a) + f(b))$$\n\n**2. 通过细化进行误差估计**\n\n为了估计误差，我们将 $S_1$ 与一个更精确的近似值 $S_2$ 进行比较，后者是通过将区间 $[a, b]$ 分成两个等宽的子区间 $[a, m]$ 和 $[m, b]$（其中 $m = (a+b)/2$）得到的。每个子区间的宽度是 $h/2$。近似值 $S_2$ 是对每个子区间应用梯形法则后的和：\n$$S_2 = T(a, m) + T(m, b) = \\frac{h/2}{2}(f(a) + f(m)) + \\frac{h/2}{2}(f(m) + f(b))$$\n$$S_2 = \\frac{h}{4}(f(a) + 2f(m) + f(b))$$\n\n对于宽度为 $w$ 的区间，梯形法则的局部截断误差由 $E(w) = -\\frac{w^3}{12}f''(\\xi)$ 给出，其中 $\\xi$ 在该区间内，且假设 $f$ 是二阶连续可微的。这表明误差与区间宽度的三次方成正比，即 $E(w) \\approx Cw^3$。\n\n真实积分 $I$ 可以通过我们的近似值 $S_1$ 和 $S_2$ 表示如下：\n$I = S_1 + E(h) \\approx S_1 + Ch^3$\n$I = S_2 + E(h/2) + E(h/2) \\approx S_2 + 2C(h/2)^3 = S_2 + \\frac{Ch^3}{4}$\n\n我们现在得到了一个关于两个未知数 $I$ 和 $C$ 的方程组：\n$I - S_1 \\approx Ch^3$\n$I - S_2 \\approx \\frac{Ch^3}{4}$\n\n用第一个方程减去第二个方程得到：\n$(I - S_2) - (I - S_1) \\approx \\frac{Ch^3}{4} - Ch^3 \\implies S_1 - S_2 \\approx -\\frac{3}{4}Ch^3$\n\n这使我们能够用我们计算出的量 $S_1$ 和 $S_2$ 来表示未知项 $Ch^3$：\n$Ch^3 \\approx \\frac{4}{3}(S_2 - S_1)$\n\n现在可以估计更精确近似值中的误差 $E_2 = I - S_2$。\n$E_2 \\approx \\frac{Ch^3}{4} \\approx \\frac{1}{4} \\left( \\frac{4}{3}(S_2 - S_1) \\right) = \\frac{1}{3}(S_2 - S_1)$\n\n因此，精细近似值 $S_2$ 的绝对局部误差可以估计为：\n$$\\text{err} \\approx \\frac{1}{3}|S_2 - S_1|$$\n该估计器完全是根据两个近似值的比较以及局部误差的缩放性质推导出来的，符合题目要求。\n\n**3. 自适应算法与偏差校正**\n\n自适应算法以递归方式进行。对于给定的区间 $[a, b]$ 和绝对容差 $\\tau$：\n1.  计算 $S_1$、$S_2$ 和误差估计 $\\text{err} = \\frac{1}{3}|S_2 - S_1|$。\n2.  如果 $\\text{err}  \\tau$，则认为该区间的近似已足够精确。该分支的处理过程终止。\n3.  如果 $\\text{err} \\ge \\tau$，则将区间分割为 $[a, m]$ 和 $[m, b]$。然后对每个子区间递归调用该算法，并相应地分配容差预算（通常每个子区间为 $\\tau/2$）。递归调用的结果将被求和。\n\n问题中提到了使用“偏差校正估计值”。这是理查森外推法的一个应用。通过用我们的误差估计 $E_2$ 来校正 $S_2$，可以得到对真实积分 $I$ 的一个更好的估计：\n$$I \\approx S_2 + E_2 \\approx S_2 + \\frac{1}{3}(S_2 - S_1) = \\frac{4S_2 - S_1}{3}$$\n这个校正后的值实际上就是区间 $[a,b]$ 上的辛普森法则：\n$$\\frac{4}{3} \\left( \\frac{h}{4}(f(a) + 2f(m) + f(b)) \\right) - \\frac{1}{3} \\left( \\frac{h}{2}(f(a) + f(b)) \\right) = \\frac{h}{3}(f(a) + 2f(m) + f(b)) - \\frac{h}{6}(f(a) + f(b))$$\n$$= \\frac{h}{6} (2f(a) + 4f(m) + 2f(b) - f(a) - f(b)) = \\frac{h}{6}(f(a) + 4f(m) + f(b))$$\n当一个区间被接受时（即 $\\text{err}  \\tau$），返回这个更高阶的辛普森法则近似值，可以在相同数量的函数求值次数下提供更精确的结果。\n\n**4. 实现结构与终止条件**\n\n该算法以递归函数的形式实现。一个包装函数负责初始化整个过程。\n- **递归的基准情形：**\n    1.  如果 $a = b$，积分为 $0$。\n    2.  设置最大递归深度 $D_{\\max}$ 来保证终止，即使在容差标准永远无法满足的情况下（例如，对于某些病态函数或浮点精度不足的情况）。如果达到此深度，则返回当前子区间的最佳估计值。\n\n- **递归步骤：**\n    一个内部函数 `_adaptive_trapezoid(f, a, b, tol, fa, fb, depth)` 将执行主要逻辑。通过将 `fa=f(a)` 和 `fb=f(b)` 作为参数传递，可以避免在父区间和子区间的共享端点上进行冗余的函数求值。如果误差标准未满足，它将进行两次递归调用：\n    `_adaptive_trapezoid(f, a, m, tol/2, fa, fm, depth+1) + _adaptive_trapezoid(f, m, b, tol/2, fm, fb, depth+1)`\n    其中 $m=(a+b)/2$ 且 $fm=f(m)$。这种结构高效且稳健地实现了自适应积分方案。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the adaptive integration problem for the given test suite.\n    \"\"\"\n\n    MAX_DEPTH = 50\n\n    def _adaptive_trapezoid(f, a, b, tol, fa, fb, depth):\n        \"\"\"\n        Recursive helper function for adaptive trapezoidal integration.\n\n        This function approximates the integral of f(x) from a to b. It estimates\n        the error by comparing a one-panel trapezoid rule with a two-panel rule.\n        If the error is too large, it recursively calls itself on the two halves\n        of the interval.\n\n        Args:\n            f (callable): The function to integrate.\n            a (float): The start of the integration interval.\n            b (float): The end of the integration interval.\n            tol (float): The absolute tolerance for this subinterval.\n            fa (float): The value of f(a), passed to avoid re-computation.\n            fb (float): The value of f(b), passed to avoid re-computation.\n            depth (int): The current recursion depth.\n\n        Returns:\n            float: The approximated integral value for the interval [a, b].\n        \"\"\"\n        # Base case 1: Zero-length interval\n        if a == b:\n            return 0.0\n\n        # Base case 2: Maximum recursion depth reached\n        if depth > MAX_DEPTH:\n            # Reached depth limit, return best available coarse estimate.\n            # A warning could be printed here in a real application.\n            h = b - a\n            return (h / 2.0) * (fa + fb)\n\n        h = b - a\n        m = (a + b) / 2.0\n        fm = f(m)\n\n        # S1: Coarse approximation (1 trapezoid over [a,b])\n        s1 = (h / 2.0) * (fa + fb)\n\n        # S2: Finer approximation (2 trapezoids over [a,m] and [m,b])\n        s2 = (h / 4.0) * (fa + 2.0 * fm + fb)\n\n        # Estimate the error of the more accurate approximation, S2.\n        # This is derived from Richardson extrapolation, where error(S2) ~ (S2-S1)/3\n        error_estimate = abs(s2 - s1) / 3.0\n\n        if error_estimate  tol:\n            # Error is within tolerance. Return the bias-reduced (Simpson's rule) value.\n            # This is S2 + error_estimate, which is more accurate.\n            return s2 + (s2 - s1) / 3.0\n        else:\n            # Error is too large. Split the interval and recurse.\n            # The tolerance is split between the two sub-intervals.\n            left_integral = _adaptive_trapezoid(f, a, m, tol / 2.0, fa, fm, depth + 1)\n            right_integral = _adaptive_trapezoid(f, m, b, tol / 2.0, fm, fb, depth + 1)\n            return left_integral + right_integral\n\n    def adaptive_integrator(f, a, b, tol):\n        \"\"\"\n        Wrapper function to start the adaptive integration process.\n        \"\"\"\n        # Initial call to the recursive helper function.\n        # Pre-calculates f(a) and f(b) for efficiency.\n        return _adaptive_trapezoid(f, a, b, tol, f(a), f(b), 0)\n\n    # Test Suite Definition\n    test_cases = [\n        {'func': lambda x: np.sin(x), 'interval': (0, np.pi), 'tol': 1e-12},\n        {'func': lambda x: np.exp(-x**2), 'interval': (0, 1), 'tol': 1e-12},\n        {'func': lambda x: 1.0 / (1.0 + x**2), 'interval': (-5, 5), 'tol': 1e-10},\n        {'func': lambda x: np.abs(x), 'interval': (-1, 1), 'tol': 1e-10},\n        {'func': lambda x: np.sin(100 * x) / (1.0 + x**2), 'interval': (0, 1), 'tol': 1e-8},\n        {'func': lambda x: 5.0, 'interval': (2, 5), 'tol': 1e-12}, # Use 5.0 to ensure float\n        {'func': lambda x: np.sin(x), 'interval': (1, 1), 'tol': 1e-12},\n    ]\n\n    results = []\n    for case in test_cases:\n        f = case['func']\n        a, b = case['interval']\n        tol = case['tol']\n        \n        # Handle the zero-length interval case explicitly in the wrapper for clarity,\n        # although the recursion also handles it.\n        if a == b:\n            result = 0.0\n        else:\n            result = adaptive_integrator(f, a, b, tol)\n        \n        results.append(result)\n\n    # Format the final output string exactly as required.\n    # The repr() function provides a high-precision string representation of floats.\n    print(f\"[{','.join(map(repr, results))}]\")\n\nsolve()\n\n```", "id": "3284319"}]}