{"hands_on_practices": [{"introduction": "实践的第一步是从基本原理出发，构建我们的核心工具。本练习将指导您使用泰勒级数展开，从头推导前向、后向和中心差分这三种基本的一阶导数近似公式。通过分析它们的截断误差，您将理解它们各自的精度，并学会如何在一个假设情景中，预测和验证一个特定函数在其特殊点（拐点）上的近似表现 [@problem_id:3132346]。", "problem": "给定标量函数 $f(x) = \\dfrac{1}{1 + e^{-x}}$，该函数对所有实数 $x$ 都是光滑的，并且在 $x = 0$ 处有一个拐点。您的任务是使用在间距为 $h > 0$ 的均匀网格上构建的离散差商来估计斜率 $f'(0)$，并量化当网格较粗时这些估计的偏差。\n\n使用以下内容作为您推导和算法设计的基础：\n- 光滑函数导数的定义，$f'(x) = \\lim_{h \\to 0} \\dfrac{f(x+h) - f(x)}{h}$。\n- 光滑函数在某点周围的泰勒级数展开，例如 $f(x \\pm h)$ 在 $x$ 点的展开。\n- 指数函数的基本微分法则。\n\n不要假定任何差分公式是已知的。相反，请从上述原理出发。\n\n任务：\n1. 从点 $x_0$ 处的泰勒级数展开开始，推导在 $x_0$ 点处导数的三种一维差商估计量（通常称为前向、后向和中心差分格式）的主阶截断误差。用 $f''(x_0)$、$f'''(x_0)$ 和 $h$ 的整数次幂表示截断误差。\n2. 将您的结果应用于逻辑函数 $f(x) = \\dfrac{1}{1 + e^{-x}}$ 在其拐点 $x_0 = 0$ 的情况。精确计算 $f'(0)$，并计算 $f''(0)$ 和 $f'''(0)$，以确定中心差分格式在 $x_0 = 0$ 处的主阶截断误差。\n3. 实现一个程序，对于测试集 $\\{2, 1, 0.5, 0.25\\}$ 中的每个步长 $h$，在 $x_0 = 0$ 处执行以下所有操作：\n   - 使用前向、后向和中心差分格式计算三个数值斜率估计值。\n   - 计算每个估计的经验偏差，公式为 $\\text{bias} = \\text{estimate} - f'(0)$。\n   - 使用您推导并应用于 $x_0 = 0$ 的主阶截断项，计算中心差分格式的预测主阶偏差。\n4. 最终输出格式：您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表形式的结果，不含空格，并用方括号括起来。对于每个步长 $h$，输出列表 $[h,\\text{bias}_{\\text{fwd}},\\text{bias}_{\\text{bwd}},\\text{bias}_{\\text{cen}},\\text{bias}_{\\text{cen,pred}}]$，其中所有条目都是十进制数。因此，总输出是按 $h \\in \\{2,1,0.5,0.25\\}$ 顺序排列的四个此类列表的单个列表。\n\n注意：\n- 本问题中没有物理单位；所有量均为无量纲。\n- 不涉及角度。\n- 最终输出必须是完全按照上述描述格式化的一行，即一个列表的列表，且仅包含指定的测试集值。", "solution": "该问题是有效的，因为它是自洽的，科学上基于微积分和数值分析的原理，并且陈述清晰明确。我们被要求从第一性原理推导数值微分公式，分析其截断误差，并将此分析应用于特定函数和特定点。\n\n### 第1部分：差分格式和截断误差的推导\n\n我们从光滑函数 $f(x)$ 在点 $x_0$ 周围的泰勒级数展开开始。对于步长 $h > 0$，$f(x_0+h)$ 和 $f(x_0-h)$ 的展开式为：\n$$f(x_0+h) = f(x_0) + hf'(x_0) + \\frac{h^2}{2!}f''(x_0) + \\frac{h^3}{3!}f'''(x_0) + O(h^4)$$\n$$f(x_0-h) = f(x_0) - hf'(x_0) + \\frac{h^2}{2!}f''(x_0) - \\frac{h^3}{3!}f'''(x_0) + O(h^4)$$\n\n估计量的偏差定义为 $\\text{bias} = \\text{estimator} - f'(x_0)$。我们寻求此偏差的主阶项，即主阶截断误差。\n\n**前向差分格式**\n前向差商定义为 $\\frac{f(x_0+h) - f(x_0)}{h}$。整理 $f(x_0+h)$ 的泰勒展开式：\n$$f(x_0+h) - f(x_0) = hf'(x_0) + \\frac{h^2}{2}f''(x_0) + O(h^3)$$\n除以 $h$：\n$$\\frac{f(x_0+h) - f(x_0)}{h} = f'(x_0) + \\frac{h}{2}f''(x_0) + O(h^2)$$\n因此偏差为：\n$$\\text{bias}_{\\text{fwd}} = \\left(\\frac{f(x_0+h) - f(x_0)}{h}\\right) - f'(x_0) = \\frac{h}{2}f''(x_0) + O(h^2)$$\n主阶截断误差为 $\\frac{h}{2}f''(x_0)$。\n\n**后向差分格式**\n后向差商为 $\\frac{f(x_0) - f(x_0-h)}{h}$。整理 $f(x_0-h)$ 的泰勒展开式：\n$$f(x_0) - f(x_0-h) = hf'(x_0) - \\frac{h^2}{2}f''(x_0) + O(h^3)$$\n除以 $h$：\n$$\\frac{f(x_0) - f(x_0-h)}{h} = f'(x_0) - \\frac{h}{2}f''(x_0) + O(h^2)$$\n偏差为：\n$$\\text{bias}_{\\text{bwd}} = \\left(\\frac{f(x_0) - f(x_0-h)}{h}\\right) - f'(x_0) = -\\frac{h}{2}f''(x_0) + O(h^2)$$\n主阶截断误差为 $-\\frac{h}{2}f''(x_0)$。\n\n**中心差分格式**\n为推导中心差分格式，我们将 $f(x_0-h)$ 的展开式从 $f(x_0+h)$ 的展开式中减去：\n$$f(x_0+h) - f(x_0-h) = (f(x_0) + hf'(x_0) + \\frac{h^2}{2}f''(x_0) + \\frac{h^3}{6}f'''(x_0)) - (f(x_0) - hf'(x_0) + \\frac{h^2}{2}f''(x_0) - \\frac{h^3}{6}f'''(x_0)) + O(h^5)$$\n$h$ 的偶次幂项相互抵消：\n$$f(x_0+h) - f(x_0-h) = 2hf'(x_0) + \\frac{2h^3}{6}f'''(x_0) + O(h^5) = 2hf'(x_0) + \\frac{h^3}{3}f'''(x_0) + O(h^5)$$\n整理得到估计量 $\\frac{f(x_0+h) - f(x_0-h)}{2h}$：\n$$\\frac{f(x_0+h) - f(x_0-h)}{2h} = f'(x_0) + \\frac{h^2}{6}f'''(x_0) + O(h^4)$$\n偏差为：\n$$\\text{bias}_{\\text{cen}} = \\left(\\frac{f(x_0+h) - f(x_0-h)}{2h}\\right) - f'(x_0) = \\frac{h^2}{6}f'''(x_0) + O(h^4)$$\n主阶截断误差为 $\\frac{h^2}{6}f'''(x_0)$。\n\n### 第2部分：应用于逻辑函数\n\n给定函数 $f(x) = \\frac{1}{1 + e^{-x}}$ 和目标点 $x_0 = 0$。我们必须计算其前三阶导数并在 $x_0 = 0$ 处求值。\n\n一种计算上高效的求导方法是利用性质 $f'(x) = f(x)(1-f(x))$。\n$f'(x) = \\frac{d}{dx}(1+e^{-x})^{-1} = -(1+e^{-x})^{-2}(-e^{-x}) = \\frac{e^{-x}}{(1+e^{-x})^2}$。\n$f(x)(1-f(x)) = \\frac{1}{1+e^{-x}}\\left(1 - \\frac{1}{1+e^{-x}}\\right) = \\frac{1}{1+e^{-x}}\\frac{e^{-x}}{1+e^{-x}} = \\frac{e^{-x}}{(1+e^{-x})^2}$。该性质成立。\n\n现在我们计算更高阶的导数：\n$f''(x) = \\frac{d}{dx}[f'(x)] = \\frac{d}{dx}[f(x)(1-f(x))] = f'(x)(1-f(x)) + f(x)(-f'(x)) = f'(x)(1-2f(x))$。\n$f'''(x) = \\frac{d}{dx}[f''(x)] = \\frac{d}{dx}[f'(x)(1-2f(x))] = f''(x)(1-2f(x)) + f'(x)(-2f'(x)) = f''(x)(1-2f(x)) - 2(f'(x))^2$。\n\n接下来，我们在 $x_0 = 0$ 处对它们求值：\n在 $x_0=0$ 处，$e^{-0}=1$，所以 $f(0) = \\frac{1}{1+1} = \\frac{1}{2}$。\n$f'(0) = f(0)(1-f(0)) = \\frac{1}{2}(1-\\frac{1}{2}) = \\frac{1}{4}$。这是斜率的精确值。\n$f''(0) = f'(0)(1-2f(0)) = \\frac{1}{4}(1-2(\\frac{1}{2})) = \\frac{1}{4}(0) = 0$。这证实了如题所述，$x_0 = 0$ 是一个拐点。\n$f'''(0) = f''(0)(1-2f(0)) - 2(f'(0))^2 = (0)(1-2(\\frac{1}{2})) - 2(\\frac{1}{4})^2 = 0 - 2(\\frac{1}{16}) = -\\frac{1}{8}$。\n\n问题指出 $x_0=0$ 是一个拐点，这意味着前向和后向格式的主阶 $O(h)$ 误差项（依赖于 $f''(x_0)$）为零。在该特定点，它们的精度变为 $O(h^2)$。中心差分格式的主阶截断误差由 $f'''(0)$ 决定。\n\n中心差分格式的预测主阶偏差由其误差展开式中的主项给出：\n$$\\text{bias}_{\\text{cen,pred}} = \\frac{h^2}{6}f'''(0) = \\frac{h^2}{6}\\left(-\\frac{1}{8}\\right) = -\\frac{h^2}{48}$$\n\n### 第3部分：算法实现\n\n程序将实现以下逻辑：\n1. 定义逻辑函数 $f(x)$。\n2. 设置精确导数 $f'(0) = 0.25$ 和 $f'''(0) = -0.125$。\n3. 对于集合 $\\{2, 1, 0.5, 0.25\\}$ 中的每个步长 $h$：\n   a. 在 $x_0=0$ 处计算三个数值估计：\n      - 前向：$\\text{est}_{\\text{fwd}} = \\frac{f(h) - f(0)}{h}$\n      - 后向：$\\text{est}_{\\text{bwd}} = \\frac{f(0) - f(-h)}{h}$\n      - 中心：$\\text{est}_{\\text{cen}} = \\frac{f(h) - f(-h)}{2h}$\n   b. 计算每个估计的经验偏差，公式为 $\\text{bias} = \\text{estimate} - 0.25$。\n   c. 使用推导出的公式计算中心差分格式的预测主阶偏差：$\\text{bias}_{\\text{cen,pred}} = -\\frac{h^2}{48}$。\n   d. 存储当前 $h$ 的结果 $[h, \\text{bias}_{\\text{fwd}}, \\text{bias}_{\\text{bwd}}, \\text{bias}_{\\text{cen}}, \\text{bias}_{\\text{cen,pred}}]$。\n4. 将收集到的结果格式化为表示列表的列表的单个字符串并打印出来。\n\n值得注意的是，对于函数 $f(x)=(1+e^{-x})^{-1}$，我们有对称性质 $f(x)+f(-x)=1$。在求值点 $x_0=0$（其中 $f(0)=0.5$），这导致前向、后向和中心差商在数值上是相同的。因此，它们的经验偏差也将相同。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical differentiation problem for the logistic function.\n\n    This function performs the following tasks:\n    1. Defines the logistic function and its exact derivative details at x=0.\n    2. Iterates through a set of step sizes h.\n    3. For each h, calculates the forward, backward, and central difference estimates\n       of the derivative at x=0.\n    4. Computes the empirical bias for each estimate.\n    5. Calculates the theoretically predicted leading-order bias for the central\n       difference scheme.\n    6. Formats and prints the results as a list of lists.\n    \"\"\"\n    \n    # Define the scalar function f(x)\n    def f(x: float) -> float:\n        return 1.0 / (1.0 + np.exp(-x))\n\n    # Test suite of step sizes\n    h_values = [2.0, 1.0, 0.5, 0.25]\n    \n    # Point of evaluation\n    x0 = 0.0\n    \n    # Analytically derived constants\n    f_prime_exact_at_0 = 0.25  # f'(0) = 1/4\n    f_triple_prime_at_0 = -0.125  # f'''(0) = -1/8\n    \n    all_results = []\n\n    for h in h_values:\n        # Evaluate the function at the required points on the grid\n        f_plus_h = f(x0 + h)\n        f_minus_h = f(x0 - h)\n        f_at_x0 = f(x0)\n\n        # Compute the three numerical slope estimates\n        est_fwd = (f_plus_h - f_at_x0) / h\n        est_bwd = (f_at_x0 - f_minus_h) / h\n        est_cen = (f_plus_h - f_minus_h) / (2.0 * h)\n        \n        # Compute the empirical bias for each estimate\n        bias_fwd = est_fwd - f_prime_exact_at_0\n        bias_bwd = est_bwd - f_prime_exact_at_0\n        bias_cen = est_cen - f_prime_exact_at_0\n        \n        # Compute the predicted leading-order bias for the central scheme\n        # The formula is (h^2 / 6) * f'''(0)\n        bias_cen_pred = (h**2 / 6.0) * f_triple_prime_at_0\n        \n        # Append the list of results for this h\n        all_results.append([h, bias_fwd, bias_bwd, bias_cen, bias_cen_pred])\n        \n    # Format the final output string as a list of lists without spaces\n    # Example: [[2.0,-0.0596...,-0.0596...,-0.0596...,-0.0833...],...]\n    output_str = f\"[{','.join([f'[{v[0]},{v[1]},{v[2]},{v[3]},{v[4]}]' for v in all_results])}]\"\n    \n    print(output_str)\n\nsolve()\n```", "id": "3132346"}, {"introduction": "掌握了基本公式后，一个自然的问题是：我们能做得更好吗？本练习将向您展示如何将泰勒级数方法推广，通过系统地设定约束条件来“设计”出精度更高的差分公式。您将亲自构建一个四阶精度的五点中心差分格式，以及用于处理边界条件的二阶精度单边格式，并通过一个思想实验来验证它们卓越的收敛速度 [@problem_id:3132411]。", "problem": "你的任务是设计并实现一个小型计算实验室，用于基于泰勒级数展开推导和验证一阶导数的高阶有限差分公式。此任务必须从第一性原理出发，使用泰勒展开和线性约束来完成，不得依赖任何预先记好的公式。用于验证的目标函数是使用弧度的正弦函数。本问题中所有角度都必须以弧度表示。\n\n从以下基础出发：\n\n- 一个足够光滑的函数在某点附近的泰勒级数展开由下式给出\n$$\nf(x_0 + k h) = \\sum_{n=0}^{\\infty} \\frac{f^{(n)}(x_0)}{n!} (k h)^n,\n$$\n其中 $h$ 是一个小步长，$k$ 是索引模板节点的整数。\n\n- 在 $x_0$ 处对一阶导数的线性有限差分近似可以写成\n$$\n\\frac{1}{h} \\sum_{k \\in \\mathcal{K}} w_k f(x_0 + k h),\n$$\n对于一组选定的偏移量 $\\mathcal{K}$ 和权重 $w_k$，其中权重通过匹配 $f'(x_0)$ 的泰勒展开系数并消去低阶截断项来确定。\n\n你的任务是：\n\n1. 仅使用泰勒级数展开和线性代数一致性条件，推导基于偏移量 $\\mathcal{K} = \\{-2,-1,0,1,2\\}$ 的五点、$\\mathcal{O}(h^4)$ 阶、$f'(x_0)$ 的对称中心差分模板。不要假设任何权重；根据展开式所蕴含的级数匹配条件以及主截断误差与 $h^4$ 成正比的要求来确定它们。\n\n2. 使用相同的方法，推导在左边界处使用偏移量 $\\mathcal{K} = \\{0,1,2\\}$ 的三点、$\\mathcal{O}(h^2)$ 阶、$f'(x_0)$ 的单边前向差分模板，以及在右边界处使用偏移量 $\\mathcal{K} = \\{0,-1,-2\\}$ 的三点、$\\mathcal{O}(h^2)$ 阶、单边后向差分模板。\n\n3. 将推导出的三个公式以函数形式在代码中实现。在测试函数\n$$\nf(x) = \\sin(x),\n$$\n及其精确导数\n$$\nf'(x) = \\cos(x),\n$$\n上验证它们，其中 $x$ 以弧度为单位。\n\n4. 对每个公式，通过计算在一系列递减步长 $h$ 上的绝对误差，并使用普通最小二乘法对数据 $(\\log h, \\log \\text{error})$ 进行直线拟合，来估计其观测到的精度阶。该直线的斜率即为观测到的精度阶 $p$。使用自然对数。\n\n5. 使用以下测试套件，它涵盖了内部点和边界点的情况，以及一系列避免越界访问的步长：\n- 五点中心模板的内部点：$x_0 = 1.3$。使用步长\n$$\nh \\in \\{0.2,\\; 0.1,\\; 0.05,\\; 0.025,\\; 0.0125,\\; 0.00625\\}。\n$$\n- 三点前向模板的左边界：$x_0 = 0$。使用相同的 $h$ 值集合。\n- 三点后向模板的右边界：$x_0 = 2\\pi$。使用相同的 $h$ 值集合。\n\n对于每种情况，计算上面列出的每个 $h$ 对应的绝对误差 $|D_h f(x_0) - f'(x_0)|$，然后通过 $(\\log h, \\log \\text{error})$ 平面中最佳拟合直线的斜率来估计观测阶 $p$。\n\n最终输出格式：\n你的程序应生成单行输出，包含三个观测阶，顺序如下：\n- 五点中心模板在 $x_0 = 1.3$ 处的观测阶，\n- 三点前向模板在 $x_0 = 0$ 处的观测阶，\n- 三点后向模板在 $x_0 = 2\\pi$ 处的观测阶。\n\n输出必须是一个用方括号括起来的逗号分隔列表，每个值四舍五入到三位小数，例如：\n$$\n[\\text{中心模板},\\text{前向模板},\\text{后向模板}]\n$$\n所有计算必须将角度视为弧度。程序不应需要用户输入；所有参数均按上述规定固定。", "solution": "该问题要求从第一性原理出发，使用泰勒级数展开推导三个用于计算一阶导数的有限差分公式，然后对其理论精度阶进行数值验证。验证过程包括将这些公式应用于函数 $f(x) = \\sin(x)$，并通过对误差与步长 $h$ 的对数-对数分析来确定观测到的精度阶。\n\n一阶导数 $f'(x_0)$ 的通用有限差分近似是一组整数偏移量 $\\mathcal{K}$ 对应的模板点 $x_0 + k h$ 处函数值的线性组合：\n$$\nf'(x_0) \\approx \\frac{1}{h} \\sum_{k \\in \\mathcal{K}} w_k f(x_0 + k h)\n$$\n权重 $w_k$ 的确定方法是将 $f(x_0 + k h)$ 在 $x_0$ 点的泰勒级数展开式\n$$\nf(x_0 + k h) = f(x_0) + (kh)f'(x_0) + \\frac{(kh)^2}{2!}f''(x_0) + \\frac{(kh)^3}{3!}f'''(x_0) + \\dots = \\sum_{n=0}^{\\infty} \\frac{f^{(n)}(x_0)}{n!} (k h)^n\n$$\n代入近似公式。通过合并每个导数 $f^{(n)}(x_0)$ 的项，我们得到一个关于 $h$ 的多项式。然后，我们通过要求低阶项的系数为零，并且 $f'(x_0)$ 的系数为 1，来建立关于权重 $w_k$ 的线性方程组。\n\n**1. 五点中心差分公式 ($\\mathcal{O}(h^4)$) 的推导**\n\n对于此公式，模板是具有偏移量 $\\mathcal{K} = \\{-2, -1, 0, 1, 2\\}$ 的对称模板。其近似式为\n$$\nh f'(x_0) + \\mathcal{O}(h^5) \\approx \\sum_{k=-2}^{2} w_k f(x_0 + k h)\n$$\n将每个项的泰勒级数代入，得到：\n$$\n\\sum_{k=-2}^{2} w_k f(x_0 + k h) = f(x_0) \\sum_{k=-2}^{2} w_k + h f'(x_0) \\sum_{k=-2}^{2} k w_k + \\frac{h^2 f''(x_0)}{2} \\sum_{k=-2}^{2} k^2 w_k + \\dots\n$$\n为了得到一个截断误差为 $\\mathcal{O}(h^4)$ 的 $f'(x_0)$ 近似值，我们要求该公式对最高为 4 次的多项式精确成立。这导出了以下关于权重 $w_k$ 的线性方程组：\n\\begin{enumerate}\n    \\item $f(x_0)$ 的系数: $\\sum_{k=-2}^{2} w_k = w_{-2} + w_{-1} + w_0 + w_1 + w_2 = 0$\n    \\item $h f'(x_0)$ 的系数: $\\sum_{k=-2}^{2} k w_k = -2w_{-2} - w_{-1} + w_1 + 2w_2 = 1$\n    \\item $h^2 f''(x_0)$ 的系数: $\\sum_{k=-2}^{2} k^2 w_k = 4w_{-2} + w_{-1} + w_1 + 4w_2 = 0$\n    \\item $h^3 f'''(x_0)$ 的系数: $\\sum_{k=-2}^{2} k^3 w_k = -8w_{-2} - w_{-1} + w_1 + 8w_2 = 0$\n    \\item $h^4 f^{(4)}(x_0)$ 的系数: $\\sum_{k=-2}^{2} k^4 w_k = 16w_{-2} + w_{-1} + w_1 + 16w_2 = 0$\n\\end{enumerate}\n对于对称模板，我们期望一阶导数的权重是反对称的，即 $w_{-k} = -w_k$。这意味着 $w_0 = -w_0 \\implies w_0 = 0$。\n应用此属性可简化方程组：\n\\begin{itemize}\n    \\item 方程 1: $(-w_2) + (-w_1) + 0 + w_1 + w_2 = 0$。此式自动满足。\n    \\item 方程 3: $4(-w_2) + (-w_1) + w_1 + 4w_2 = 0$。此式也自动满足。\n    \\item 方程 5: $16(-w_2) + (-w_1) + w_1 + 16w_2 = 0$。此式也自动满足。\n\\end{itemize}\n剩下的非平凡方程是：\n\\begin{itemize}\n    \\item 来自方程 2: $-2(-w_2) - (-w_1) + w_1 + 2w_2 = 2w_2 + w_1 + w_1 + 2w_2 = 2w_1 + 4w_2 = 1$。\n    \\item 来自方程 4: $-8(-w_2) - (-w_1) + w_1 + 8w_2 = 8w_2 + w_1 + w_1 + 8w_2 = 2w_1 + 16w_2 = 0$。\n\\end{itemize}\n现在我们求解这个 $2 \\times 2$ 方程组：\n\\begin{align*}\n    w_1 + 2w_2 = 1/2 \\\\\n    w_1 + 8w_2 = 0\n\\end{align*}\n第二个方程减去第一个方程得到 $6w_2 = -1/2$，所以 $w_2 = -1/12$。\n将此结果代入第二个方程得到 $w_1 = -8w_2 = -8(-1/12) = 8/12 = 2/3$。\n权重为：$w_0=0$, $w_1=2/3$, $w_2=-1/12$，且根据反对称性, $w_{-1}=-2/3$, $w_{-2}=1/12$。\n该公式为：\n$$\nf'(x_0) \\approx \\frac{1}{12h} [f(x_0-2h) - 8f(x_0-h) + 8f(x_0+h) - f(x_0+2h)]\n$$\n主误差项包含 $f^{(5)}(x_0)$ 并且与 $h^4$ 成正比。\n\n**2. 三点前向差分公式 ($\\mathcal{O}(h^2)$) 的推导**\n\n对于这个单边公式，模板偏移量为 $\\mathcal{K} = \\{0, 1, 2\\}$。我们需要消去直到 $f''(x_0)$ 的项以达到 $\\mathcal{O}(h^2)$ 的误差。\n近似式为 $h f'(x_0) + \\mathcal{O}(h^3) \\approx w_0 f(x_0) + w_1 f(x_0+h) + w_2 f(x_0+2h)$。\n这导出了以下方程组：\n\\begin{enumerate}\n    \\item $f(x_0)$ 的系数: $w_0 + w_1 + w_2 = 0$\n    \\item $h f'(x_0)$ 的系数: $w_1 + 2w_2 = 1$\n    \\item $h^2 f''(x_0)$ 的系数: $\\frac{1}{2}w_1 + \\frac{4}{2}w_2 = 0 \\implies w_1 + 4w_2 = 0$\n\\end{enumerate}\n由 (3) 得，$w_1 = -4w_2$。代入 (2) 得 $-4w_2 + 2w_2 = 1 \\implies -2w_2=1 \\implies w_2 = -1/2$。\n然后，$w_1 = -4(-1/2) = 2$。\n最后，由 (1) 得，$w_0 + 2 - 1/2 = 0 \\implies w_0 = -3/2$。\n权重为：$w_0=-3/2$, $w_1=2$, $w_2=-1/2$。\n该公式为：\n$$\nf'(x_0) \\approx \\frac{1}{h} \\left[-\\frac{3}{2}f(x_0) + 2f(x_0+h) - \\frac{1}{2}f(x_0+2h)\\right] = \\frac{-3f(x_0) + 4f(x_0+h) - f(x_0+2h)}{2h}\n$$\n\n**3. 三点后向差分公式 ($\\mathcal{O}(h^2)$) 的推导**\n\n对于这个单边公式，偏移量为 $\\mathcal{K} = \\{0, -1, -2\\}$。推导过程与前向差分情况类似。方程组为：\n\\begin{enumerate}\n    \\item $f(x_0)$ 的系数: $w_0 + w_{-1} + w_{-2} = 0$\n    \\item $h f'(x_0)$ 的系数: $-w_{-1} - 2w_{-2} = 1$\n    \\item $h^2 f''(x_0)$ 的系数: $\\frac{1}{2}w_{-1} + \\frac{4}{2}w_{-2} = 0 \\implies w_{-1} + 4w_{-2} = 0$\n\\end{enumerate}\n由 (3) 得，$w_{-1} = -4w_{-2}$。代入 (2) 得 $-(-4w_{-2}) - 2w_{-2} = 1 \\implies 2w_{-2}=1 \\implies w_{-2} = 1/2$。\n然后，$w_{-1} = -4(1/2) = -2$。\n最后，由 (1) 得，$w_0 - 2 + 1/2 = 0 \\implies w_0 = 3/2$。\n权重为：$w_0=3/2$, $w_{-1}=-2$, $w_{-2}=1/2$。\n该公式为：\n$$\nf'(x_0) \\approx \\frac{1}{h} \\left[\\frac{3}{2}f(x_0) - 2f(x_0-h) + \\frac{1}{2}f(x_0-2h)\\right] = \\frac{3f(x_0) - 4f(x_0-h) + f(x_0-2h)}{2h}\n$$\n\n**4. 精度阶的验证**\n\n数值方法的精度阶 $p$ 描述了当步长 $h$ 趋于零时，误差 $E$ 的行为。对于一个 $p$ 阶方法，当 $h$ 足够小时，误差期望满足 $E(h) \\approx C h^p$，其中 $C$ 为某个常数。对该关系式取自然对数，得到：\n$$\n\\ln(E) \\approx \\ln(C) + p \\ln(h)\n$$\n该方程形如 $y = m x + c$，其中 $y = \\ln(E)$，$x = \\ln(h)$，斜率 $m=p$，截距 $c=\\ln(C)$。为了数值估计 $p$，我们为一系列递减的步长 $h_i$ 计算绝对误差 $E_i = |D_{h_i} f(x_0) - f'(x_0)|$。然后我们对数据点 $(\\ln(h_i), \\ln(E_i))$ 进行普通最小二乘线性回归。所得最佳拟合直线的斜率即为观测到的精度阶 $p$。对于给定的点 $x_0$ 和步长 $h$，此过程将使用指定的测试函数 $f(x) = \\sin(x)$ 及其精确导数 $f'(x) = \\cos(x)$ 对三个推导出的公式进行实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Derives, implements, and validates finite difference formulas for the first derivative.\n    \"\"\"\n    \n    # Define the test function and its exact derivative (angles in radians)\n    f = np.sin\n    df_exact_func = np.cos\n    \n    # Define the sequence of step sizes\n    h_vals = np.array([0.2, 0.1, 0.05, 0.025, 0.0125, 0.00625])\n\n    # --- Finite Difference Formula Implementations ---\n    \n    def five_point_central(func, x0, h):\n        \"\"\"\n        Computes the O(h^4) five-point central difference approximation for f'(x0).\n        f'(x0) ~= (f(x-2h) - 8f(x-h) + 8f(x+h) - f(x+2h)) / (12h)\n        \"\"\"\n        f_m2 = func(x0 - 2 * h)\n        f_m1 = func(x0 - 1 * h)\n        f_p1 = func(x0 + 1 * h)\n        f_p2 = func(x0 + 2 * h)\n        \n        # Weights: w_-2=1/12, w_-1=-8/12, w_1=8/12, w_2=-1/12\n        return (f_m2 - 8 * f_m1 + 8 * f_p1 - f_p2) / (12 * h)\n\n    def three_point_forward(func, x0, h):\n        \"\"\"\n        Computes the O(h^2) three-point forward difference approximation for f'(x0).\n        f'(x0) ~= (-3f(x) + 4f(x+h) - f(x+2h)) / (2h)\n        \"\"\"\n        f0 = func(x0)\n        f1 = func(x0 + h)\n        f2 = func(x0 + 2 * h)\n        \n        # Weights: w_0=-3/2, w_1=4/2, w_2=-1/2\n        return (-3 * f0 + 4 * f1 - f2) / (2 * h)\n\n    def three_point_backward(func, x0, h):\n        \"\"\"\n        Computes the O(h^2) three-point backward difference approximation for f'(x0).\n        f'(x0) ~= (3f(x) - 4f(x-h) + f(x-2h)) / (2h)\n        \"\"\"\n        f0 = func(x0)\n        fm1 = func(x0 - h)\n        fm2 = func(x0 - 2 * h)\n        \n        # Weights: w_0=3/2, w_-1=-4/2, w_-2=1/2\n        return (3 * f0 - 4 * fm1 + fm2) / (2 * h)\n\n    # --- Test Suite Definition ---\n\n    test_cases = [\n        {\n            \"name\": \"Five-point central\",\n            \"x0\": 1.3,\n            \"formula\": five_point_central,\n        },\n        {\n            \"name\": \"Three-point forward\",\n            \"x0\": 0.0,\n            \"formula\": three_point_forward,\n        },\n        {\n            \"name\": \"Three-point backward\",\n            \"x0\": 2 * np.pi,\n            \"formula\": three_point_backward,\n        },\n    ]\n\n    observed_orders = []\n\n    for case in test_cases:\n        x0 = case[\"x0\"]\n        formula_func = case[\"formula\"]\n        \n        # Calculate the exact derivative at x0\n        df_true = df_exact_func(x0)\n        \n        # Compute absolute errors for the sequence of h values\n        errors = []\n        for h in h_vals:\n            df_approx = formula_func(f, x0, h)\n            error = np.abs(df_approx - df_true)\n            errors.append(error)\n        \n        errors = np.array(errors)\n        \n        # Prepare data for linear regression: (log(h), log(error))\n        log_h = np.log(h_vals)\n        log_error = np.log(errors)\n        \n        # Perform ordinary least squares regression\n        # The slope of the line is the observed order of accuracy\n        regression_result = linregress(log_h, log_error)\n        observed_order = regression_result.slope\n        \n        observed_orders.append(observed_order)\n\n    # Format the results for output\n    formatted_results = [\"{:.3f}\".format(p) for p in observed_orders]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3132411"}, {"introduction": "理论精度并非数值方法的全部。一个优秀的算法在面对不完美数据时应具有稳健性。本练习通过一个思想实验，模拟了一个常见于实际测量的挑战：数据中存在离群值。通过分析一个孤立的数据点误差如何影响三种基本差分公式的计算结果，您将发现它们在稳健性上存在着惊人且重要的差异 [@problem_id:3132362]。", "problem": "给定一个光滑实值函数 $f$，它在一个一维均匀网格 $x_j = x_0 + j h$ 上采样，网格间距为恒定的 $h > 0$。考虑在内部网格点 $x_i$ 处计算的三个一阶导数有限差分格式：前向差分、后向差分和中心差分。假设在测量数据中，恰好有一个样本点 $x_i$ 处的值被一个大小为 $a$ 的加性离群值污染，而所有其他样本点保持准确；也就是说，在 $x_i$ 处的测量值等于真实值加上 $a$，而在任何 $j \\neq i$ 的 $x_j$ 处的测量值等于真实值。使用克罗内克δ函数 $\\delta_{ij}$ 将此污染建模为加性扰动，其中当 $i=j$ 时 $\\delta_{ij} = 1$，否则 $\\delta_{ij}=0$。\n\n仅使用以下基本原理：\n- 导数作为差商极限的定义，以及\n- 有限差分格式通过用均匀网格上采样数据的有限差分代替极限来近似导数的思想，\n\n推导在内部网格点 $x_i$ 处，一个大小为 $a$ 的单点污染相对于未受污染情况，是如何改变 $x_i$ 处三种导数近似值的显式表达式。然后，给出这一变化的绝对大小（即灵敏度），作为 $a$ 和 $h$ 的函数，假设 $h>0$ 且中心差分有定义（即 $i$ 不是边界索引）。\n\n实现一个程序，对下方测试套件中的每个测试用例 $(h, a)$，计算一个包含三个实数的列表，这三个实数分别是三种格式在前向、后向、中心差分顺序下于 $x_i$ 处的绝对变化（灵敏度）。你的程序除了从上述基本原理推导出的公式外，不得假定任何特定公式，并且必须完全按照规定格式为测试套件生成结果。\n\n测试套件（每个用例为 $(h, a)$）：\n- 用例 1: $h = 0.1$, $a = 0.01$\n- 用例 2: $h = 0.1$, $a = 0$\n- 用例 3: $h = 10^{-6}$, $a = 10^{-3}$\n- 用例 4: $h = 2.5$, $a = -0.5$\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个由子列表组成的逗号分隔列表形式的结果，每个子列表对应一个测试用例，并按[前向, 后向, 中心]的顺序包含三个浮点数。整个序列必须用方括号括起来。例如，输出格式必须类似于 $[[v_{11},v_{12},v_{13}],[v_{21},v_{22},v_{23}],\\dots]$，前后无任何附加文本。不涉及物理单位，默认情况下，所有角度（如果有）均以弧度为单位（尽管本任务不直接使用角度）。", "solution": "该问题要求推导三种一阶导数 $f'(x_i)$ 的有限差分近似，对于在求值点 $x_i$ 的单个加性误差的灵敏度。推导必须基于第一性原理：导数的极限定义及其在均匀网格上通过有限差分的近似。\n\n设真实的光滑函数为 $f(x)$。其值在均匀网格 $x_j = x_0 + j h$ 上采样，其中 $j$ 为整数，恒定间距为 $h > 0$。采样值记为 $f_j = f(x_j)$。测量数据 $\\tilde{f}_j$ 在网格点 $x_i$ 处被一个大小为 $a$ 的单个加性离群值污染。这种污染被建模为 $\\tilde{f}_j = f_j + a \\delta_{ij}$，其中 $\\delta_{ij}$ 是克罗内克δ。这意味着 $\\tilde{f}_i = f_i + a$，而对于任何其他网格点 $j \\neq i$，测量值未受污染，即 $\\tilde{f}_j = f_j$。\n\n我们的目标是求出导数近似值的变化，我们通常将其表示为 $D$。这个变化 $\\Delta D$ 是使用被污染数据计算的近似值与使用真实数据计算的近似值之差：$\\Delta D = D(\\{\\tilde{f}_k\\}) - D(\\{f_k\\})$。灵敏度 $S$ 定义为该变化的绝对大小，即 $S = |\\Delta D|$。\n\n所有一阶导数 $f'(x)$ 的有限差分格式都是对极限定义 $f'(x) = \\lim_{\\Delta x \\to 0} \\frac{f(x+\\Delta x) - f(x)}{\\Delta x}$ 的近似。这些格式是通过用网格间距 $h$ 上的有限差分替换极限而产生的。我们现在将分析在内部网格点 $x_i$ 处的三种格式。\n\n1.  **前向差分格式**\n\n前向差分近似 $D_+f(x_i)$ 是通过考虑一个大小为 $h$ 的前向步长得到的。其公式为：\n$$D_+f(x_i) = \\frac{f(x_i+h) - f(x_i)}{h} = \\frac{f_{i+1} - f_i}{h}$$\n使用真实的、未受污染的函数值，近似值为 $D_+f(x_i)_{\\text{true}} = \\frac{f_{i+1} - f_i}{h}$。\n使用测量的、被污染的值，近似值为 $\\tilde{D}_+f(x_i) = \\frac{\\tilde{f}_{i+1} - \\tilde{f}_i}{h}$。\n根据我们的误差模型，我们代入 $\\tilde{f}_{i+1} = f_{i+1}$ (因为 $i+1 \\neq i$) 和 $\\tilde{f}_i = f_i + a$：\n$$\\tilde{D}_+f(x_i) = \\frac{f_{i+1} - (f_i + a)}{h} = \\frac{f_{i+1} - f_i}{h} - \\frac{a}{h} = D_+f(x_i)_{\\text{true}} - \\frac{a}{h}$$\n前向差分近似的变化是 $\\Delta D_+f(x_i) = \\tilde{D}_+f(x_i) - D_+f(x_i)_{\\text{true}} = -\\frac{a}{h}$。\n灵敏度是此变化的绝对大小：\n$$S_+ = \\left| -\\frac{a}{h} \\right| = \\frac{|a|}{h}$$\n\n2.  **后向差分格式**\n\n后向差分近似 $D_-f(x_i)$ 使用一个大小为 $h$ 的后向步长。其公式源自另一种极限形式 $f'(x) = \\lim_{h \\to 0} \\frac{f(x) - f(x-h)}{h}$：\n$$D_-f(x_i) = \\frac{f(x_i) - f(x_i-h)}{h} = \\frac{f_i - f_{i-1}}{h}$$\n真实的近似值为 $D_-f(x_i)_{\\text{true}} = \\frac{f_i - f_{i-1}}{h}$。\n使用被污染数据的近似值为 $\\tilde{D}_-f(x_i) = \\frac{\\tilde{f}_i - \\tilde{f}_{i-1}}{h}$。\n代入 $\\tilde{f}_i = f_i + a$ 和 $\\tilde{f}_{i-1} = f_{i-1}$ (因为 $i-1 \\neq i$)：\n$$\\tilde{D}_-f(x_i) = \\frac{(f_i + a) - f_{i-1}}{h} = \\frac{f_i - f_{i-1}}{h} + \\frac{a}{h} = D_-f(x_i)_{\\text{true}} + \\frac{a}{h}$$\n变化是 $\\Delta D_-f(x_i) = \\tilde{D}_-f(x_i) - D_-f(x_i)_{\\text{true}} = \\frac{a}{h}$。\n灵敏度为：\n$$S_- = \\left| \\frac{a}{h} \\right| = \\frac{|a|}{h}$$\n\n3.  **中心差分格式**\n中心差分近似 $D_0f(x_i)$ 使用围绕 $x_i$ 的宽度为 $2h$ 的对称区间，提供一个更平衡的近似。问题陈述 $x_i$ 是一个内部点，所以其邻近点 $x_{i-1}$ 和 $x_{i+1}$ 存在。其公式为：\n$$D_0f(x_i) = \\frac{f(x_i+h) - f(x_i-h)}{2h} = \\frac{f_{i+1} - f_{i-1}}{2h}$$\n真实的近似值为 $D_0f(x_i)_{\\text{true}} = \\frac{f_{i+1} - f_{i-1}}{2h}$。\n对于被污染的数据，近似值为 $\\tilde{D}_0f(x_i) = \\frac{\\tilde{f}_{i+1} - \\tilde{f}_{i-1}}{2h}$。\n关键在于，在 $x_i$ 处求导数的公式使用了来自 $x_{i+1}$ 和 $x_{i-1}$ 的值。污染仅限于 $x_i$ 处。因此，该格式使用的值是未受污染的：$\\tilde{f}_{i+1} = f_{i+1}$ 和 $\\tilde{f}_{i-1} = f_{i-1}$。受扰动的值 $\\tilde{f}_i$ 并未出现在计算 $x_i$ 处中心差分的计算模板中。\n因此，近似值没有改变：\n$$\\tilde{D}_0f(x_i) = \\frac{f_{i+1} - f_{i-1}}{2h} = D_0f(x_i)_{\\text{true}}$$\n变化是 $\\Delta D_0f(x_i) = 0$。\n因此，灵敏度为零：\n$$S_0 = |0| = 0$$\n\n总结来说，对于网格点 $x_i$ 处大小为 $a$ 的单点污染，在 $x_i$ 处计算的三种导数近似的灵敏度为：\n-   前向差分灵敏度：$S_+ = \\frac{|a|}{h}$\n-   后向差分灵敏度：$S_- = \\frac{|a|}{h}$\n-   中心差分灵敏度：$S_0 = 0$\n\n这些结果将在程序中实现，以计算给定测试用例的数值。前向和后向格式表现出的灵敏度会随着网格间距 $h$ 的减小而放大，这是数值微分中病态问题的典型特征。相比之下，由于其计算模板的结构，中心差分格式对求值点本身的离群值完全鲁棒。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the sensitivity of forward, backward, and central difference\n    schemes to a single-point outlier.\n    \"\"\"\n    \n    # Test suite of (h, a) pairs, where h is grid spacing and a is outlier magnitude.\n    test_cases = [\n        (0.1, 0.01),\n        (0.1, 0.0),\n        (1e-6, 1e-3),\n        (2.5, -0.5),\n    ]\n\n    all_results = []\n    for h, a in test_cases:\n        # Based on the derivation, the sensitivities (absolute changes) are:\n        # S_forward = |a| / h\n        # S_backward = |a| / h\n        # S_central = 0\n        \n        # The problem statement guarantees h > 0, so no division-by-zero check is needed.\n        \n        # Sensitivity of the forward difference scheme\n        sensitivity_forward = np.abs(a) / h\n        \n        # Sensitivity of the backward difference scheme\n        sensitivity_backward = np.abs(a) / h\n        \n        # Sensitivity of the central difference scheme\n        sensitivity_central = 0.0\n        \n        case_results = [sensitivity_forward, sensitivity_backward, sensitivity_central]\n        all_results.append(case_results)\n\n    # The required output is a single line string representation of a list of lists,\n    # with no spaces after commas. We construct this string manually to ensure\n    # exact formatting.\n    # Ex: [[v11,v12,v13],[v21,v22,v23]]\n    sublist_strs = [f\"[{','.join(map(str, r))}]\" for r in all_results]\n    final_output_str = f\"[{','.join(sublist_strs)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```", "id": "3132362"}]}