{"hands_on_practices": [{"introduction": "真正理解一个算法的最好方法就是从零开始构建它。第一个实践练习要求你仅根据其数学定义 $A = LL^\\top$ 来实现 Cholesky 分解。通过亲自推导 $L$ 矩阵元素的计算公式，并在不同类型的矩阵上进行测试，你将对该分解的工作原理获得深刻的基础性理解。[@problem_id:3106474]", "problem": "您需要在一个 Cholesky 分解定义的基础框架内，为实对称正定 (SPD) 矩阵实现并测试一个下三角 Cholesky 分解。此任务的基础是以下定义：一个实对称正定矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 可分解为 $A = L L^\\top$，其中 $L$ 是一个对角元严格为正的下三角矩阵。您的程序必须仅使用此定义和基本算术运算来计算出这样一个 $L$（或报告失败）；您不得调用任何直接执行 Cholesky 分解的库例程。您可以使用 Numerical Python (NumPy) 库中的数组操作来执行基本的线性代数任务。\n\n算法规范和约束：\n- 输入模型：您的程序将硬编码一小组测试矩阵；不需要也不允许用户输入。\n- 对称性检查：如果 $\\max_{i,j} \\lvert A_{ij} - A_{ji} \\rvert \\le \\varepsilon_{\\mathrm{sym}}$ 且 $\\varepsilon_{\\mathrm{sym}} = 10^{-12}$，则将实矩阵 $A$ 视为对称。\n- 正定性进展：在从 $A = L L^\\top$ 派生的构造性算法中，每一步计算下一个对角元的中间量都必须满足严格为正。使用正性阈值 $\\varepsilon_{\\mathrm{pos}} = 10^{-15}$ 来防止因数值误差导致非正主元。如果所需主元满足 $s \\le \\varepsilon_{\\mathrm{pos}}$，则将输入视为非正定并报告该情况失败。\n- 唯一性约束：强制 $L$ 的每个对角元都是相应中间主元的主（非负）平方根，以确保分解的唯一性。\n- 对对角输入的特殊行为：对于对角输入，验证算法简化为对角线上的逐元素操作，且该操作与定义关系 $A = L L^\\top$ 及 $L$ 的下三角结构一致。\n\n测试套件：\n实现该算法并在以下五种情况下对其进行评估。在每种情况下，您的程序必须根据所述标准计算一个布尔结果。\n\n- 情况 1（对角，良态缩放）：$A_1 = \\mathrm{diag}(4, 9, 16, 25)$。标准：分解成功，因子 $L_1$ 是下三角矩阵，其所有非对角元对于 $i \\ne j$ 满足 $\\lvert (L_1)_{ij} \\rvert \\le 10^{-12}$，并且逐元素满足 $\\lvert \\mathrm{diag}(L_1) - \\sqrt{\\mathrm{diag}(A_1)} \\rvert \\le 10^{-12}$。\n- 情况 2（对角，小正项）：$A_2 = \\mathrm{diag}(10^{-12}, 10^{-9}, 10^{-6})$。标准：与情况 1 相同，具有相同的容差。\n- 情况 3（对角，标量情况）：$A_3 = \\mathrm{diag}(7.25)$。标准：与情况 1 相同，具有相同的容差。\n- 情况 4（一般 SPD，非对角）：令\n$$\nB = \\begin{bmatrix}\n1.0  2.0  -1.0 \\\\\n0.5  -0.3  0.8 \\\\\n1.2  0.7  0.3\n\\end{bmatrix}, \\quad\nA_4 = B B^\\top + 0.5 I,\n$$\n其中 $I$ 是尺寸相符的单位矩阵。标准：分解成功并满足 $\\lVert A_4 - L_4 L_4^\\top \\rVert_\\infty \\le 10^{-10}$，其中 $\\lVert \\cdot \\rVert_\\infty$ 表示最大绝对值项。\n- 情况 5（对角，非正定）：$A_5 = \\mathrm{diag}(1.0, -4.0, 2.0)$。标准：分解在正性阈值 $\\varepsilon_{\\mathrm{pos}}$ 下失败。\n\n输出要求：\n- 您的程序必须实现由 $A = L L^\\top$ 和 $L$ 的下三角结构所蕴含的构造性算法，使用指定的容差 $\\varepsilon_{\\mathrm{sym}} = 10^{-12}$ 和 $\\varepsilon_{\\mathrm{pos}} = 10^{-15}$。\n- 对于五个情况中的每一种，计算一个布尔值，指示是否满足相应的标准。\n- 最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_k$ 是 $\\mathrm{True}$ 或 $\\mathrm{False}$。\n\n不涉及物理单位。不涉及角度或百分比。预期输出仅为布尔值。程序必须完全自包含，且不得读取任何输入。必须完全按照规定应用数值容差。最终输出必须是上文描述的精确格式的单行。", "solution": "用户要求实现实对称正定 (SPD) 矩阵 $A$ 的 Cholesky 分解，得到一个具有正对角元的下三角矩阵 $L$，使得 $A = L L^\\top$。该实现必须直接从此定义方程派生而来。\n\n### 步骤 1：提取已知信息并验证问题\n\n**提取的已知信息：**\n- **定义**：对于一个实对称正定矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其 Cholesky 分解为 $A = L L^\\top$，其中 $L$ 是一个对角元严格为正的下三角矩阵。\n- **算法约束**：实现必须是根据定义派生的构造性算法，而不是使用预先存在的 Cholesky 分解库函数。\n- **对称性检查**：如果 $\\max_{i,j} \\lvert A_{ij} - A_{ji} \\rvert \\le \\varepsilon_{\\mathrm{sym}}$ 且 $\\varepsilon_{\\mathrm{sym}} = 10^{-12}$，则矩阵 $A$ 被视为对称。\n- **正性检查**：算法必须检查中间主元量的严格正性。如果一个主元 $s \\le \\varepsilon_{\\mathrm{pos}}$ 且 $\\varepsilon_{\\mathrm{pos}} = 10^{-15}$，则该矩阵被认为不是正定的，分解失败。\n- **唯一性**：$L$ 的对角元必须是主（非负）平方根。\n- **测试套件**：\n    - 情况 1：$A_1 = \\mathrm{diag}(4, 9, 16, 25)$。标准：成功， $L_1$ 是下三角矩阵，对于 $i \\ne j$ 满足 $\\lvert (L_1)_{ij} \\rvert \\le 10^{-12}$，并且逐元素满足 $\\lvert \\mathrm{diag}(L_1) - \\sqrt{\\mathrm{diag}(A_1)} \\rvert \\le 10^{-12}$。\n    - 情况 2：$A_2 = \\mathrm{diag}(10^{-12}, 10^{-9}, 10^{-6})$。标准：与情况 1 相同。\n    - 情况 3：$A_3 = \\mathrm{diag}(7.25)$。标准：与情况 1 相同。\n    - 情况 4：$A_4 = B B^\\top + 0.5 I$，其中 $B = \\begin{bmatrix} 1.0  2.0  -1.0 \\\\ 0.5  -0.3  0.8 \\\\ 1.2  0.7  0.3 \\end{bmatrix}$。标准：成功且 $\\lVert A_4 - L_4 L_4^\\top \\rVert_\\infty \\le 10^{-10}$。\n    - 情况 5：$A_5 = \\mathrm{diag}(1.0, -4.0, 2.0)$。标准：分解失败。\n- **输出格式**：单行 `[r_1,r_2,r_3,r_4,r_5]`，其中每个 $r_k$ 是一个布尔值。\n\n**验证：**\n- **科学依据**：该问题基于 Cholesky 分解，这是线性代数和数值分析中一个基础且成熟的概念。\n- **适定性**：该问题是适定的。它提供了所有必需的矩阵、常数和容差，并为每个测试用例定义了无歧义的成功标准。\n- **客观性**：该问题以客观的数学语言陈述，不含主观性。\n\n**结论**：该问题是有效的。它是计算科学中一个标准的、定义明确的任务。\n\n### 步骤 2：算法推导与实现计划\n\n该算法通过将 $A$ 的元素与乘积 $L L^\\top$ 的元素相等来推导。设 $A \\in \\mathbb{R}^{n \\times n}$ 和 $L \\in \\mathbb{R}^{n \\times n}$ 是一个下三角矩阵，其中元素从 0 开始索引。$L$ 的元素表示为 $L_{ij}$，其中对于 $j > i$ 有 $L_{ij} = 0$。\n\n定义 $A = L L^\\top$ 意味着对于每个元素 $A_{ij}$：\n$$\nA_{ij} = (L L^\\top)_{ij} = \\sum_{k=0}^{n-1} L_{ik} (L^\\top)_{kj} = \\sum_{k=0}^{n-1} L_{ik} L_{jk}\n$$\n由于 $L$ 是下三角的，$L_{ik}=0$（对于 $k>i$）且 $L_{jk}=0$（对于 $k>j$）。因此，求和索引 $k$ 可以在 $\\min(i, j)$ 处截断：\n$$\nA_{ij} = \\sum_{k=0}^{\\min(i,j)} L_{ik} L_{jk}\n$$\n我们可以从 $j=0$ 到 $n-1$ 逐列计算 $L$ 的元素。对于每一列 $j$，我们首先计算对角元 $L_{jj}$，然后计算 $i > j$ 的非对角元 $L_{ij}$。\n\n**第 $j$ 列的计算（假设第 $0, \\dots, j-1$ 列已知）：**\n\n1.  **对角元 $L_{jj}$：**\n    在通用公式中设 $i=j$：\n    $$\n    A_{jj} = \\sum_{k=0}^{j} L_{jk} L_{jk} = \\left( \\sum_{k=0}^{j-1} L_{jk}^2 \\right) + L_{jj}^2\n    $$\n    解出 $L_{jj}^2$：\n    $$\n    L_{jj}^2 = A_{jj} - \\sum_{k=0}^{j-1} L_{jk}^2\n    $$\n    为使 $A$ 为正定，右侧项（主元）必须严格为正。我们检查该项是否大于 $\\varepsilon_{\\mathrm{pos}}$。如果条件成立，我们取其主平方根以满足唯一性要求：\n    $$\n    L_{jj} = \\sqrt{A_{jj} - \\sum_{k=0}^{j-1} L_{jk}^2}\n    $$\n\n2.  **$i > j$ 的非对角元 $L_{ij}$：**\n    对于对角线下方的元素，我们有 $\\min(i,j) = j$。公式变为：\n    $$\n    A_{ij} = \\sum_{k=0}^{j} L_{ik} L_{jk} = \\left( \\sum_{k=0}^{j-1} L_{ik} L_{jk} \\right) + L_{ij} L_{jj}\n    $$\n    解出 $L_{ij}$：\n    $$\n    L_{ij} L_{jj} = A_{ij} - \\sum_{k=0}^{j-1} L_{ik} L_{jk}\n    $$\n    由于 $L_{jj}$ 已计算出且严格为正，我们可以做除法：\n    $$\n    L_{ij} = \\frac{1}{L_{jj}} \\left( A_{ij} - \\sum_{k=0}^{j-1} L_{ik} L_{jk} \\right)\n    $$\n\n对 $j=0, 1, \\dots, n-1$ 迭代此构造过程，这将填充整个下三角矩阵 $L$。实现将遵循此逻辑，然后将指定的标准应用于每个测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef cholesky_decomposition(A, eps_sym, eps_pos):\n    \"\"\"\n    Computes the Cholesky decomposition of a matrix A.\n\n    Args:\n        A (np.ndarray): The matrix to decompose.\n        eps_sym (float): Tolerance for symmetry check.\n        eps_pos (float): Tolerance for positivity check of pivots.\n\n    Returns:\n        tuple: A tuple (L, success) where L is the lower-triangular factor\n               and success is a boolean indicating if the decomposition was successful.\n               If not successful, L is None.\n    \"\"\"\n    n = A.shape[0]\n    if A.shape[1] != n:\n        return None, False\n\n    # The problem implies test cases are constructed to be symmetric.\n    # The algorithm implementation naturally only uses the lower part of A.\n    # An explicit symmetry check is not strictly necessary for the algorithm to run\n    # but is part of the problem's formal specification.\n    if np.max(np.abs(A - A.T)) > eps_sym:\n        # For the given problem, all inputs are symmetric by construction,\n        # so this path is not expected to be taken.\n        pass\n\n    L = np.zeros_like(A, dtype=float)\n\n    for j in range(n):\n        # Compute the sum for the diagonal element L_jj\n        # This is the dot product of the j-th row of L up to column j-1\n        s_diag = np.dot(L[j, :j], L[j, :j])\n        \n        pivot = A[j, j] - s_diag\n        if pivot = eps_pos:\n            return None, False  # Matrix is not positive definite\n\n        L[j, j] = np.sqrt(pivot)\n\n        # Compute the off-diagonal elements in column j\n        for i in range(j + 1, n):\n            # This is the dot product of row i and row j of L, for already computed parts.\n            s_offdiag = np.dot(L[i, :j], L[j, :j])\n            L[i, j] = (A[i, j] - s_offdiag) / L[j, j]\n            \n    return L, True\n\ndef check_diagonal_case(A, L, success, tol_off_diag, tol_diag):\n    \"\"\"Checks the criteria for the diagonal test cases (1, 2, 3).\"\"\"\n    if not success:\n        return False\n    \n    # Check that L is numerically diagonal (all off-diagonals are close to zero)\n    off_diag_L = L - np.diag(np.diag(L))\n    cond1 = np.max(np.abs(off_diag_L)) = tol_off_diag\n    \n    # Check that the diagonal of L is the element-wise sqrt of the diagonal of A\n    diag_diff = np.abs(np.diag(L) - np.sqrt(np.diag(A)))\n    cond2 = np.all(diag_diff = tol_diag)\n    \n    return cond1 and cond2\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for Cholesky decomposition.\n    \"\"\"\n    # Define constants from the problem statement\n    eps_sym = 1e-12\n    eps_pos = 1e-15\n\n    # Define the test cases from the problem statement.\n    A1 = np.diag([4.0, 9.0, 16.0, 25.0])\n    A2 = np.diag([1e-12, 1e-9, 1e-6])\n    A3 = np.array([[7.25]])\n    \n    B = np.array([\n        [1.0, 2.0, -1.0],\n        [0.5, -0.3, 0.8],\n        [1.2, 0.7, 0.3]\n    ])\n    A4 = B @ B.T + 0.5 * np.identity(3)\n    \n    A5 = np.diag([1.0, -4.0, 2.0])\n\n    results = []\n\n    # Case 1\n    L1, success1 = cholesky_decomposition(A1, eps_sym, eps_pos)\n    results.append(check_diagonal_case(A1, L1, success1, tol_off_diag=1e-12, tol_diag=1e-12))\n\n    # Case 2\n    L2, success2 = cholesky_decomposition(A2, eps_sym, eps_pos)\n    results.append(check_diagonal_case(A2, L2, success2, tol_off_diag=1e-12, tol_diag=1e-12))\n\n    # Case 3\n    L3, success3 = cholesky_decomposition(A3, eps_sym, eps_pos)\n    results.append(check_diagonal_case(A3, L3, success3, tol_off_diag=1e-12, tol_diag=1e-12))\n\n    # Case 4\n    L4, success4 = cholesky_decomposition(A4, eps_sym, eps_pos)\n    res4 = False\n    if success4:\n        reconstruction_error = np.max(np.abs(A4 - L4 @ L4.T))\n        res4 = reconstruction_error = 1e-10\n    results.append(res4)\n\n    # Case 5\n    L5, success5 = cholesky_decomposition(A5, eps_sym, eps_pos)\n    # The criterion is that the factorization fails.\n    res5 = not success5\n    results.append(res5)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3106474"}, {"introduction": "一个能运行的算法固然不错，但一个可靠且稳健的算法对于科学计算至关重要。本练习将指导你通过集成一套全面的验证检查，将基础的 Cholesky 实现转变为一个专业级的函数。你将学习如何通过编程来验证输入的对称性，确保输出因子 $L$ 的有效性，并确认分解能够精确重构原始矩阵，从而实践测试驱动开发的思想。[@problem_id:3106422]", "problem": "您需要编写一个完整的、可运行的程序。该程序接收一个实数方阵 $A$，尝试计算一个下三角矩阵 $L$ 使得 $A = L L^\\top$ 成立，并验证对于对称正定 (SPD) 矩阵的 Cholesky 分解至关重要的两个性质：(i) $L$ 的对角线元素严格为正，以及 (ii) $L L^\\top$ 在指定容差范围内重构 $A$。您的设计必须从对称性和正定性的基本定义出发，并且不得依赖任何预先打包的分解例程。您的程序必须将这些检查集成到一个测试驱动的工作流中，方法是评估一个小型的矩阵测试套件，并为每个测试报告一个布尔值，以指示该测试的所有必需检查是否都已通过。\n\n用作基础的基本定义：\n- 一个实数方阵 $A \\in \\mathbb{R}^{n \\times n}$ 是对称的，如果 $A = A^\\top$。\n- 一个对称矩阵 $A$ 是对称正定 (SPD) 的，如果对于所有非零向量 $x \\in \\mathbb{R}^n$，$x^\\top A x  0$。\n- Cholesky 分解断言，对于 SPD 矩阵 $A$，存在一个唯一的、具有正对角线元素的下三角矩阵 $L$，使得 $A = L L^\\top$。\n\n您的程序必须：\n- 实现一个函数，该函数从上述定义出发，仅使用基本运算和必要的线性代数，尝试从输入 $A$ 计算下三角因子 $L$。该函数不得调用内置的 Cholesky 分解函数。\n- 实现错误检查以确保：\n  1) 在容差 $\\tau_{\\mathrm{sym}}$ 内的对称性，使用 $A - A^\\top$ 的最大绝对逐元素偏差进行判断。\n  2) $L$ 的对角线元素的严格正性，相对于正性阈值 $\\tau_{\\mathrm{pos}}$ 进行判断。\n  3) 在容差 $\\tau_{\\mathrm{rec}}$ 内的重构精度，使用相对弗罗贝尼乌斯范数误差 $\\lVert A - L L^\\top \\rVert_F / \\lVert A \\rVert_F$ 进行判断。\n- 为每个测试用例返回一个布尔判定结果：当且仅当所有三个检查都通过并且成功构造了一个有效的 $L$ 时，返回 true；否则返回 false。\n\n角度或物理单位在此不适用。\n\n测试套件：\n对于下面的每个案例，程序必须应用指定的容差并报告一个布尔值。测试套件必须按以下顺序执行。\n\n- 测试 $1$ (正常路径，小型 SPD 矩阵)：\n  - 矩阵 $A_1 = \\begin{bmatrix} 4  2  2 \\\\ 2  3  1 \\\\ 2  1  3 \\end{bmatrix}$。\n  - 容差：$\\tau_{\\mathrm{sym}} = 10^{-15}$，$\\tau_{\\mathrm{pos}} = 10^{-15}$，$\\tau_{\\mathrm{rec}} = 10^{-12}$。\n\n- 测试 $2$ (病态但 SPD，3 阶希尔伯特矩阵)：\n  - 矩阵 $A_2$ 的元素为 $(A_2)_{ij} = \\dfrac{1}{i + j - 1}$，其中 $i,j \\in \\{1,2,3\\}$，即 $A_2 = \\begin{bmatrix} 1  \\tfrac{1}{2}  \\tfrac{1}{3} \\\\ \\tfrac{1}{2}  \\tfrac{1}{3}  \\tfrac{1}{4} \\\\ \\tfrac{1}{3}  \\tfrac{1}{4}  \\tfrac{1}{5} \\end{bmatrix}$。\n  - 容差：$\\tau_{\\mathrm{sym}} = 10^{-15}$，$\\tau_{\\mathrm{pos}} = 10^{-15}$，$\\tau_{\\mathrm{rec}} = 10^{-12}$。\n\n- 测试 $3$ (对称但非正定)：\n  - 矩阵 $A_3 = \\begin{bmatrix} 1  2 \\\\ 2  1 \\end{bmatrix}$。\n  - 容差：$\\tau_{\\mathrm{sym}} = 10^{-15}$，$\\tau_{\\mathrm{pos}} = 10^{-15}$，$\\tau_{\\mathrm{rec}} = 10^{-12}$。\n\n- 测试 $4$ (非对称输入)：\n  - 矩阵 $A_4 = \\begin{bmatrix} 2  1 \\\\ 0  2 \\end{bmatrix}$。\n  - 容差：$\\tau_{\\mathrm{sym}} = 10^{-15}$，$\\tau_{\\mathrm{pos}} = 10^{-15}$，$\\tau_{\\mathrm{rec}} = 10^{-12}$。\n\n- 测试 $5$ (可复现生成的 5 阶随机 SPD 矩阵)：\n  - 通过以下算法配方构造 $A_5$：设置一个显式随机种子 $s = 0$，抽取一个具有独立标准正态分布元素的矩阵 $M \\in \\mathbb{R}^{5 \\times 5}$，然后令 $A_5 = M^\\top M + \\alpha I$，其中 $\\alpha = 10^{-6}$，$I$ 为 $5 \\times 5$ 的单位矩阵。\n  - 容差：$\\tau_{\\mathrm{sym}} = 10^{-15}$，$\\tau_{\\mathrm{pos}} = 10^{-15}$，$\\tau_{\\mathrm{rec}} = 10^{-12}$。\n\n- 测试 $6$ (近似对称的 SPD 矩阵，在对称性容差下可接受)：\n  - 按如下方式构造一个基础 SPD 矩阵 $S$：令 $Q = \\begin{bmatrix} 1  2  3 \\\\ 0  1  4 \\\\ 5  6  0 \\end{bmatrix}$，设置 $S = Q^\\top Q + \\beta I$，其中 $\\beta = 10^{-3}$，$I$ 为 $3 \\times 3$ 的单位矩阵。然后通过取 $S$ 并仅在元素 $(1,2)$（使用基于 1 的索引）上添加一个微小的扰动来定义 $A_6$：设置 $(A_6)_{1,2} \\leftarrow (A_6)_{1,2} + \\varepsilon$，其中 $\\varepsilon = 10^{-11}$，并保持所有其他元素与 $S$ 相同。\n  - 容差：$\\tau_{\\mathrm{sym}} = 10^{-10}$，$\\tau_{\\mathrm{pos}} = 10^{-15}$，$\\tau_{\\mathrm{rec}} = 10^{-12}$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含从测试 1 到测试 6 的布尔结果，格式为用方括号括起来的逗号分隔列表。例如，一个有效的输出看起来像 $[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{True},\\mathrm{True},\\mathrm{False}]$（这只是一个示例）。", "solution": "已根据指定的验证协议对问题陈述进行了分析。所有给定的条件、定义、约束和测试用例都已提取和评估。该问题被确定为**有效**。它在科学上植根于数值线性代数的原理，特别是 Cholesky 分解。它具备适定性、客观性、自洽性，并且可以算法形式化。测试套件定义明确，可以实现确定性和可验证的解决方案。\n\n核心任务是根据第一性原理实现 Cholesky 分解函数，并用它来验证几个测试矩阵的性质。Cholesky 分解指出，任何实对称正定 (SPD) 矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 都可以唯一地分解为乘积 $A = LL^\\top$，其中 $L$ 是一个对角线元素严格为正的下三角矩阵。\n\n计算 $L = (l_{ij})$ 元素的算法可以通过将 $A = (a_{ij})$ 的元素与乘积 $LL^\\top$ 的元素相等来推导。假设 $j \\le i$，$LL^\\top$ 的第 $(i, j)$ 个元素由 $(LL^\\top)_{ij} = \\sum_{k=1}^{j} l_{ik} l_{jk}$ 给出。\n\n我们可以逐列计算 $L$ 的元素，其中 $j = 0, 1, \\dots, n-1$。\n\n对于对角线元素 $l_{jj}$：\n对角线元素 $a_{jj}$ 的方程是：\n$$a_{jj} = \\sum_{k=0}^{j} l_{jk} l_{jk} = \\left( \\sum_{k=0}^{j-1} l_{jk}^2 \\right) + l_{jj}^2$$\n求解 $l_{jj}$，我们得到：\n$$l_{jj} = \\sqrt{a_{jj} - \\sum_{k=0}^{j-1} l_{jk}^2}$$\n为使 $L$ 为实数矩阵，平方根下的项必须为非负。为使其具有严格为正的对角线元素，该项必须严格为正。如果在任何步骤中该项小于或等于 $0$，则矩阵 $A$ 不是对称正定的，分解失败。这为正定性提供了一个算法测试。\n\n对于非对角线元素 $l_{ij}$，其中 $i  j$：\n非对角线元素 $a_{ij}$ 的方程是：\n$$a_{ij} = \\sum_{k=0}^{j} l_{ik} l_{jk} = \\left( \\sum_{k=0}^{j-1} l_{ik} l_{jk} \\right) + l_{ij} l_{jj}$$\n在 $l_{jj}  0$ 的条件下求解 $l_{ij}$：\n$$l_{ij} = \\frac{1}{l_{jj}} \\left( a_{ij} - \\sum_{k=0}^{j-1} l_{ik} l_{jk} \\right)$$\n这些公式定义了 Cholesky-Banachiewicz 算法。需要注意的是，这些推导假设 $A$ 是对称的（即 $a_{ij} = a_{ji}$）。所得算法仅需访问 $A$ 的下三角部分和对角线（即 $i \\ge j$ 的元素 $a_{ij}$）。我们的实现将遵循此标准惯例。对于并非完全对称的输入矩阵，该算法将对其下三角部分进行操作。\n\n对每个测试矩阵 $A$ 的整体验证过程包括三个检查：\n\n$1$。**对称性检查**：在尝试分解之前，我们在容差 $\\tau_{\\mathrm{sym}}$ 内验证 $A$ 是否对称。我们计算 $A$ 与其转置 $A^\\top$ 之间元素级绝对差的最大值。如果 $\\max_{i,j} |a_{ij} - a_{ji}|  \\tau_{\\mathrm{sym}}$，则检查通过。如果此检查失败，则认为矩阵在给定容差下为非对称，测试判定为 `False`。\n\n$2$。**对角线正性检查**：成功计算出下三角矩阵 $L$ 后，我们必须验证其所有对角线元素 $l_{ii}$ 都是严格为正的。此检查是相对于正性阈值 $\\tau_{\\mathrm{pos}}$ 进行的，即我们要求对于所有的 $i=0, \\dots, n-1$ 都有 $l_{ii}  \\tau_{\\mathrm{pos}}$。如果 $l_{ii}$ 的值为正但未超过此阈值，则表示检查失败。这种情况可能发生在接近奇异的矩阵上。\n\n$3$。**重构精度检查**：为确保计算出的因子 $L$ 是正确的，我们将其重构为矩阵 $L L^\\top$，并与原始矩阵 $A$ 进行比较。误差使用相对弗罗贝尼乌斯范数进行量化：\n$$\\text{err}_{\\mathrm{rec}} = \\frac{\\lVert A - L L^\\top \\rVert_F}{\\lVert A \\rVert_F}$$\n其中 $\\lVert M \\rVert_F = \\sqrt{\\sum_{i,j} M_{ij}^2}$。如果此相对误差小于指定的重构容差 $\\tau_{\\mathrm{rec}}$，则检查通过。\n\n一个测试用例返回 `True` 当且仅当输入矩阵通过了对称性检查，Cholesky 分解算法成功生成了矩阵 $L$，并且这个 $L$ 随后通过了对角线正性检查和重构精度检查。否则，测试用例返回 `False`。\n\n该逻辑被封装在一个评估所提供测试套件的程序中。对于测试 3，矩阵是对称但非正定的，因此分解算法预计会失败。对于测试 4，矩阵不是对称的，因此预计会在初始的对称性检查中失败。对于测试 6，矩阵被构造成近似对称，因此它将在给定的容差 $\\tau_{\\mathrm{sym}} = 10^{-10}$ 下通过对称性检查。由于所实现的算法从输入矩阵的下三角部分读取数据，它将有效地在底层的 SPD 矩阵上操作，成功计算出一个因子，并通所有后续检查。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_cholesky(A):\n    \"\"\"\n    Attempts to compute the Cholesky decomposition of a matrix A.\n\n    This function implements the Cholesky-Banachiewicz algorithm, which computes\n    the lower-triangular matrix L column by column, such that A = L L^T.\n    The algorithm assumes A is symmetric and will only access the lower-triangular\n    part of A.\n\n    Args:\n        A (np.ndarray): A square numpy array.\n\n    Returns:\n        np.ndarray or None: The lower-triangular factor L if the decomposition is\n        successful, otherwise None (if the matrix is not positive definite).\n    \"\"\"\n    n = A.shape[0]\n    if A.shape[1] != n:\n        raise ValueError(\"Input matrix must be square.\")\n\n    L = np.zeros_like(A, dtype=float)\n\n    for j in range(n):\n        # Compute the diagonal element L[j, j]\n        # s = sum_{k=0}^{j-1} L[j, k]^2\n        s = L[j, :j] @ L[j, :j].T\n        \n        # Argument for square root\n        d = A[j, j] - s\n        \n        # Check for positive definiteness. If d = 0, the matrix is not\n        # strictly positive definite.\n        if d = 0:\n            return None\n        \n        L[j, j] = np.sqrt(d)\n        \n        # Compute the off-diagonal elements in column j\n        for i in range(j + 1, n):\n            # s_ij = sum_{k=0}^{j-1} L[i,k] * L[j,k]\n            s_ij = L[i, :j] @ L[j, :j].T\n            L[i, j] = (A[i, j] - s_ij) / L[j, j]\n            \n    return L\n\ndef test_cholesky(A, tau_sym, tau_pos, tau_rec):\n    \"\"\"\n    Performs Cholesky decomposition and verifies a set of properties.\n\n    Args:\n        A (np.ndarray): The input matrix for testing.\n        tau_sym (float): Tolerance for the symmetry check.\n        tau_pos (float): Threshold for diagonal entry positivity.\n        tau_rec (float): Tolerance for reconstruction accuracy.\n\n    Returns:\n        bool: True if A passes all checks, False otherwise.\n    \"\"\"\n    if A.ndim != 2 or A.shape[0] != A.shape[1]:\n        return False\n\n    # 1. Symmetry check\n    sym_err = np.max(np.abs(A - A.T))\n    if sym_err > tau_sym:\n        return False\n\n    # Attempt to compute Cholesky factor\n    L = compute_cholesky(A)\n    \n    # If decomposition fails, L is None\n    if L is None:\n        return False\n        \n    # 2. Diagonal positivity check\n    if not np.all(np.diag(L) > tau_pos):\n        return False\n        \n    # 3. Reconstruction accuracy check\n    A_reconstructed = L @ L.T\n    norm_A = np.linalg.norm(A, 'fro')\n    \n    if norm_A == 0: # Handle zero matrix case\n        if np.linalg.norm(A - A_reconstructed, 'fro') == 0:\n            rec_err = 0.0\n        else:\n            return False # Non-zero error for a zero matrix\n    else:\n        rec_err = np.linalg.norm(A - A_reconstructed, 'fro') / norm_A\n\n    if rec_err > tau_rec:\n        return False\n        \n    # All checks passed\n    return True\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and report the test suite results.\n    \"\"\"\n    # Test 1: Happy path, small SPD\n    A1 = np.array([[4, 2, 2], [2, 3, 1], [2, 1, 3]], dtype=float)\n    tols1 = (1e-15, 1e-15, 1e-12)\n\n    # Test 2: Ill-conditioned but SPD (Hilbert matrix)\n    A2 = np.array([[1, 1/2, 1/3], [1/2, 1/3, 1/4], [1/3, 1/4, 1/5]], dtype=float)\n    tols2 = (1e-15, 1e-15, 1e-12)\n\n    # Test 3: Symmetric but not positive definite\n    A3 = np.array([[1, 2], [2, 1]], dtype=float)\n    tols3 = (1e-15, 1e-15, 1e-12)\n\n    # Test 4: Non-symmetric input\n    A4 = np.array([[2, 1], [0, 2]], dtype=float)\n    tols4 = (1e-15, 1e-15, 1e-12)\n\n    # Test 5: Random SPD matrix\n    np.random.seed(0)\n    M = np.random.randn(5, 5)\n    A5 = M.T @ M + 1e-6 * np.eye(5)\n    tols5 = (1e-15, 1e-15, 1e-12)\n\n    # Test 6: Nearly symmetric SPD matrix\n    Q = np.array([[1, 2, 3], [0, 1, 4], [5, 6, 0]], dtype=float)\n    S = Q.T @ Q + 1e-3 * np.eye(3)\n    A6 = S.copy()\n    A6[0, 1] += 1e-11 # Perturb upper triangle (index (0,1) is entry (1,2))\n    tols6 = (1e-10, 1e-15, 1e-12)\n    \n    test_cases = [\n        (A1, *tols1),\n        (A2, *tols2),\n        (A3, *tols3),\n        (A4, *tols4),\n        (A5, *tols5),\n        (A6, *tols6),\n    ]\n\n    results = []\n    for case in test_cases:\n        A, ts, tp, tr = case\n        result = test_cholesky(A, ts, tp, tr)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3106422"}, {"introduction": "当你尝试对一个非正定矩阵进行 Cholesky 分解时会发生什么？标准算法会失败，但这在实际应用中是很常见的情况。这个高级实践将介绍一种强大的技术，通过自适应对角正则化来创建一个能够处理这类情况的“稳健”求解器。你将实现一个智能循环，它能自动为矩阵添加一个稳定项 $\\lambda I$，并不断调整 $\\lambda$ 直至获得一个稳定的分解，这展示了构建弹性数值工具的一项关键策略。[@problem_id:3106437]", "problem": "您需要为一个对称矩阵实现一个鲁棒的数值例程，该例程通过带对角正则化的 Cholesky 分解来计算一个下三角因子。设 $A \\in \\mathbb{R}^{n \\times n}$ 是一个实对称矩阵。根据定义，如果对于所有非零 $x \\in \\mathbb{R}^n$ 都有 $x^\\top A x  0$，则该矩阵是对称正定（SPD）的。对于一个 SPD 矩阵 $A$，存在一个唯一的、对角线元素为正的下三角矩阵 $L$，使得 $A = L L^\\top$。当 $A$ 不是 SPD 矩阵时，计算科学中一个常见的技术是添加对角正则化（也称为对角移位），即考虑 $A + \\lambda I$，其中 $\\lambda \\ge 0$，$I$ 是单位矩阵。\n\n您的任务是设计并实现一个鲁棒的求解器，该求解器在给定一个实对称矩阵 $A$ 时，尝试计算其 Cholesky 因子，并自适应地增加一个标量对角正则化项 $\\lambda$，直到分解成功且根据一个最小对角线阈值达到数值稳定。该求解器必须遵循以下原则和约束。\n\n- 从核心定义出发：$A$ 的对称性、SPD 矩阵 Cholesky 分解的存在性和唯一性，以及加上 $\\lambda I$ 会将 $A$ 的每个特征值都移动 $\\lambda$ 这一事实。\n- 算法必须从 $\\lambda = 0$ 开始，尝试对 $A + \\lambda I$ 进行 Cholesky 分解。在任何计算分解失败的情况下，增加 $\\lambda$ 并重试。如果分解成功，但得到的下三角因子 $L$ 的最小对角线元素低于一个预设阈值，则利用观测到的最小对角线元素 $L_{ii}$ 的信息来增加 $\\lambda$ 并重试。持续此过程，直到分解成功且 $L$ 中的最小对角线元素达到或超过该阈值。\n- $\\lambda$ 的增加必须有逻辑上的合理解释，不能依赖任何黑箱捷径。具体来说：\n  - 如果还没有一次分解成功，选择一个足够大的 $\\lambda$ 增量，使得 $A + \\lambda I$ 按行成为严格对角占优，并带有一个小的正余量，这保证了对称矩阵的所有特征值均为正。具体地，对于每一行 $i$，令 $r_i = \\sum_{j \\ne i} |a_{ij}|$，$a_{ii}$ 为对角线元素。严格对角占优的一个充分条件是 $a_{ii} + \\lambda  r_i$。您的实现必须将此作为 $\\lambda$ 的一个安全下界，通过设置\n    $$\n    \\lambda \\leftarrow \\max\\left(\\lambda,\\ \\max_i \\max\\{0,\\ r_i - a_{ii} + \\eta\\}\\right),\n    $$\n    其中 $\\eta  0$ 是下面指定的一个小的安全余量。\n  - 如果对于某个 $\\lambda$ 已经成功分解，令 $\\ell_{\\min}$ 为 $L$ 中观测到的最小对角线元素。如果 $\\ell_{\\min}$ 小于阈值 $\\tau  0$，则利用 $\\ell_{\\min}$ 自适应地增加 $\\lambda$，以便下一次尝试能得到一个更大的 $\\ell_{\\min}$。您至少需要将 $\\lambda$ 增加 $(\\tau - \\ell_{\\min})^2$ 以确保在仅有对角线的情况下取得进展，并至少增加 $\\eta$ 以确保严格单调性：\n    $$\n    \\lambda \\leftarrow \\lambda + \\max\\left\\{(\\tau - \\ell_{\\min})^2,\\ \\eta\\right\\}。\n    $$\n- 在处理之前，始终通过将 $A$ 替换为 $(A + A^\\top)/2$ 来将其视为对称矩阵。最多尝试 $100$ 次；但是，对于所提供的测试，正确的实现应该能在此限制内远快地成功。\n\n使用的参数：\n- Cholesky 因子的最小可接受对角线阈值：$\\tau = 10^{-5}$。\n- 对角占优和单调性的安全余量：$\\eta = 10^{-12}$。\n- 最大尝试次数：$100$。\n\n测试套件：\n对于下面的每个矩阵，您的程序必须计算并报告您的算法在最后一次成功尝试中使用的最终标量 $\\lambda \\ge 0$。对每种情况都使用相同的 $\\tau$ 和 $\\eta$。这些矩阵是：\n\n- 情况 1（已经是 SPD，中等条件数）：\n  $$\n  A_1 = \\begin{bmatrix}\n  4  1  2 \\\\\n  1  3  0.5 \\\\\n  2  0.5  5\n  \\end{bmatrix}。\n  $$\n- 情况 2（对称不定）：\n  $$\n  A_2 = \\begin{bmatrix}\n  0  1 \\\\\n  1  0\n  \\end{bmatrix}。\n  $$\n- 情况 3（对称半正定，秩亏）：\n  $$\n  A_3 = \\begin{bmatrix}\n  1  1  1 \\\\\n  1  1  1 \\\\\n  1  1  1\n  \\end{bmatrix}。\n  $$\n- 情况 4（零矩阵）：\n  $$\n  A_4 = \\begin{bmatrix}\n  0  0 \\\\\n  0  0\n  \\end{bmatrix}。\n  $$\n- 情况 5（病态 SPD，极小的对角元素）：\n  $$\n  A_5 = \\begin{bmatrix}\n  10^{-12}  0 \\\\\n  0  1\n  \\end{bmatrix}。\n  $$\n\n程序要求：\n- 您的程序应实现上述鲁棒过程。它不能依赖任何外部输入。\n- 对于每种情况，计算成功尝试中实际使用的最终 $\\lambda$。\n- 最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的十进制数列表。例如，输出行必须像 $[x_1,x_2,x_3,x_4,x_5]$ 这样，没有空格。每个 $x_i$ 都应该是四舍五入到 $10$ 位有效数字的浮点字面量。", "solution": "用户提供的问题陈述已经过验证，被认为是可靠、适定和客观的。任务是为实对称矩阵实现一个鲁棒的 Cholesky 分解算法，该算法包含一个自适应的对角正则化方案。\n\nCholesky 分解背后的核心原理是，一个对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是正定的，当且仅当它有一个唯一的分解 $A = LL^\\top$，其中 $L$ 是一个对角线元素严格为正的下三角矩阵。如果对于所有非零向量 $x \\in \\mathbb{R}^n$，都有 $x^\\top A x  0$，则矩阵 $A$ 是对称正定（SPD）的。这等价于 $A$ 的所有特征值都是正的。\n\n当一个对称矩阵 $A$ 不是 SPD（即它是半正定或不定的，具有零或负特征值）时，标准的 Cholesky 算法会失败。一个常见的补救措施是对角正则化，即我们考虑矩阵 $A' = A + \\lambda I$，其中标量 $\\lambda \\ge 0$，$I$ 是单位矩阵。加上 $\\lambda I$ 会将 $A$ 的每个特征值都移动 $\\lambda$。因此，通过选择一个足够大的 $\\lambda$，我们可以确保 $A'$ 的所有特征值都是正的，从而使其成为 SPD 矩阵，并适用于 Cholesky 分解。\n\n所要求的算法将此正则化过程形式化为一个迭代和自适应的过程。\n\n**1. 对称化**\n作为预备步骤，输入矩阵 $A$ 被显式地对称化。这处理了输入中潜在的浮点不精确性。操作为 $A \\leftarrow \\frac{1}{2}(A + A^\\top)$。由于问题是为对称矩阵定义的，此步骤确保了数值表示严格满足该属性。\n\n**2. 迭代正则化和分解**\n该算法迭代地尝试找到一个合适的正则化参数 $\\lambda$，以得到一个成功且数值稳定的 Cholesky 分解。\n\n该过程从 $\\lambda = 0$ 的初始猜测开始，对应于尝试分解原始矩阵。算法在一个循环中进行，最多尝试 100 次。\n\n在每次迭代中，执行以下步骤：\n1.  构造正则化矩阵 $A' = A + \\lambda I$。\n2.  尝试计算 $A'$ 的 Cholesky 因子 $L$，使得 $A' = LL^\\top$。这通常使用一个库函数来完成，如果矩阵不是正定的，该函数会引发错误。\n\n可能出现两种结果：分解失败或成功。\n\n**3. 处理分解失败**\n如果 $A' = A + \\lambda I$ 的 Cholesky 分解失败，这意味着 $A'$ 不是正定的。为了保证在后续尝试中成功，必须增加 $\\lambda$。规定的更新规则基于使矩阵严格对角占优，这是对称矩阵为正定的一个充分（但非必要）条件。\n\n如果对于每一行 $i$，对角元素的绝对值大于该行中非对角元素绝对值之和，则对称矩阵 $M$ 是严格对角占优的：$|M_{ii}|  \\sum_{j \\neq i} |M_{ij}|$。对于我们的正则化矩阵 $A'$，此条件变为 $a_{ii} + \\lambda  \\sum_{j \\neq i} |a_{ij}|$。\n\n为了对所有行都满足此条件并带有一个小的安全余量 $\\eta  0$，我们必须选择 $\\lambda$ 使得对于所有 $i$ 都有 $\\lambda  (\\sum_{j \\neq i} |a_{ij}|) - a_{ii}$。因此，$\\lambda$ 的更新规则被设置为一个确保此条件满足的值，同时确保 $\\lambda$ 不会减小：\n$$\n\\lambda \\leftarrow \\max\\left(\\lambda_{old}, \\max_i \\max\\{0, r_i - a_{ii} + \\eta\\}\\right)\n$$\n其中 $r_i = \\sum_{j \\neq i} |a_{ij}|$。一旦 $\\lambda$ 更新到此值，后续对 $A + \\lambda I$ 的 Cholesky 分解尝试保证会成功。此规则是为“还没有一次分解成功”的情况指定的，但它为任何分解失败提供了一个鲁棒的后备方案。\n\n**4. 处理成功但不稳定的分解**\n如果 Cholesky 分解成功，产生一个下三角矩阵 $L$，我们必须评估其数值稳定性。不稳定性的一个常见指标是 $L$ 中存在非常小的对角线元素。这些可能导致 $L^{-1}$ 中出现大元素，并在后续计算（例如，解线性方程组）中放大误差。\n\n算法会检查 $L$ 的最小对角线元素，记为 $\\ell_{\\min} = \\min_i L_{ii}$，并与一个预设的阈值 $\\tau  0$ 进行比较。如果 $\\ell_{\\min}  \\tau$，则认为分解不稳定，必须增加 $\\lambda$ 以在下一次迭代中产生一个“更正定”的矩阵。\n\n此情况下的自适应更新规则是：\n$$\n\\lambda \\leftarrow \\lambda_{old} + \\max\\left\\{(\\tau - \\ell_{\\min})^2, \\eta\\right\\}\n$$\n这个更新是启发式的，但有其动机。对于一个简单的 $1 \\times 1$ 矩阵 $A = [a]$，$L = [\\sqrt{a}]$。如果我们想将 $L$ 从 $\\ell_{\\min}$ 更改为 $\\tau$，我们需要将 $a$ 更改 $\\tau^2 - \\ell_{\\min}^2 = (\\tau - \\ell_{\\min})(\\tau + \\ell_{\\min})$。项 $(\\tau - \\ell_{\\min})^2$ 是一个相关的、易于计算的增量。包含 $\\eta$ 确保了 $\\lambda$ 在每一步都严格增加，保证了进展和最终的终止。\n\n**5. 终止**\n当计算出 Cholesky 分解且得到的因子 $L$ 满足稳定性准则，即 $\\min_i L_{ii} \\ge \\tau$ 时，迭代过程成功终止。在这次成功尝试中使用的最终 $\\lambda$ 值就是给定矩阵 $A$ 的结果。如果超过最大尝试次数（100 次），循环也会终止，这表示算法失败。对于指定的测试用例，预期解将远在此限制内找到。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef robust_cholesky_lambda(A, tau, eta, max_attempts):\n    \"\"\"\n    Computes a regularized Cholesky decomposition of a symmetric matrix A.\n\n    Args:\n        A (np.ndarray): The input matrix.\n        tau (float): The minimum acceptable diagonal threshold for the Cholesky factor.\n        eta (float): The safety margin for regularization updates.\n        max_attempts (int): The maximum number of attempts.\n\n    Returns:\n        float: The final regularization parameter lambda used.\n    \"\"\"\n    if A.shape[0] != A.shape[1]:\n        raise ValueError(\"Input matrix must be square.\")\n    \n    # Symmetrize the matrix A\n    A_sym = (A + A.T) / 2.0\n    n = A_sym.shape[0]\n    \n    current_lambda = 0.0\n    \n    # Flag to track if a successful factorization has occurred yet.\n    # The problem describes different update rules based on this.\n    # However, the diagonal dominance update rule makes the next attempt succeed,\n    # so we will only use it once if the first attempt(s) fail.\n    \n    for _ in range(max_attempts):\n        A_reg = A_sym + current_lambda * np.identity(n)\n        \n        try:\n            L = np.linalg.cholesky(A_reg)\n            \n            # --- Factorization succeeded ---\n            min_diag_L = np.min(np.diag(L))\n            \n            if min_diag_L >= tau:\n                # Success and stable: terminate\n                return current_lambda\n            else:\n                # Success but unstable: update lambda and retry\n                increment = max((tau - min_diag_L)**2, eta)\n                current_lambda += increment\n                \n        except np.linalg.LinAlgError:\n            # --- Factorization failed ---\n            # Update lambda based on making the matrix diagonally dominant.\n            \n            # This rule is specified for \"if no factorization has succeeded yet\".\n            # After this update, factorization should succeed.\n            \n            row_sums = np.sum(np.abs(A_sym), axis=1) - np.abs(np.diag(A_sym))\n            diag_diffs = row_sums - np.diag(A_sym)\n            \n            # For rows where a_ii > r_i already, max(0, ...) is 0.\n            lambda_dd = np.max(np.maximum(0, diag_diffs)) + eta\n\n            # The rule is lambda - max(lambda, lambda_dd)\n            # This ensures lambda does not decrease. If the first lambda=0 failed, \n            # the new lambda will be lambda_dd.\n            current_lambda = max(current_lambda, lambda_dd)\n\n    # If the loop finishes, max attempts were reached without a stable factor.\n    raise RuntimeError(f\"Robust Cholesky failed to converge in {max_attempts} attempts.\")\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Parameters from the problem statement\n    tau = 1e-5\n    eta = 1e-12\n    max_attempts = 100\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([\n            [4.0, 1.0, 2.0],\n            [1.0, 3.0, 0.5],\n            [2.0, 0.5, 5.0]\n        ]),\n        np.array([\n            [0.0, 1.0],\n            [1.0, 0.0]\n        ]),\n        np.array([\n            [1.0, 1.0, 1.0],\n            [1.0, 1.0, 1.0],\n            [1.0, 1.0, 1.0]\n        ]),\n        np.array([\n            [0.0, 0.0],\n            [0.0, 0.0]\n        ]),\n        np.array([\n            [1e-12, 0.0],\n            [0.0, 1.0]\n        ])\n    ]\n\n    results = []\n    for A in test_cases:\n        final_lambda = robust_cholesky_lambda(A, tau, eta, max_attempts)\n        # Format to 10 significant digits using the 'g' format specifier\n        formatted_result = f'{final_lambda:.10g}'\n        results.append(formatted_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3106437"}]}