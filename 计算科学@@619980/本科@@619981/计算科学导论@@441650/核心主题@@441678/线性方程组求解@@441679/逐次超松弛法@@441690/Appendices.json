{"hands_on_practices": [{"introduction": "理解一个算法的最好方法之一就是亲手执行它。本练习提供了一个绝佳的起点，我们将一个经典的一维稳态热传导问题作为背景，这使得我们可以专注于逐次超松弛（SOR）方法本身的计算过程。通过手动计算单次迭代中一个点的温度更新值 [@problem_id:1369790]，你将对 SOR 的更新公式获得一个具体而直观的认识，理解它是如何巧妙地融合前一步的迭代值、高斯-赛德尔（Gauss-Seidel）更新量以及松弛因子 $\\omega$ 的。", "problem": "正在分析一个薄绝缘杆的简化稳态热分布模型。该杆被离散化为五个等间距的点，$P_0, P_1, P_2, P_3, P_4$。两个端点的温度保持恒定，分别为 $T_0 = 25.0^\\circ\\text{C}$ 和 $T_4 = 100.0^\\circ\\text{C}$。三个内部点（记为 $T_1, T_2,$ 和 $T_3$）的温度是未知的。\n\n在稳态下，每个内部点的温度是其两个直接相邻点温度的算术平均值。这个物理原理导出了一个关于未知温度 $T_1, T_2,$ 和 $T_3$ 的线性方程组。\n\n为求解该方程组，采用了逐次超松弛（SOR）迭代法。松弛参数选择为 $\\omega = 1.15$。迭代从所有未知温度的初始猜测值为零开始，即 $T_1^{(0)} = T_2^{(0)} = T_3^{(0)} = 0$。\n\n计算第一个内部点 $T_1$ 在第一次完整迭代后的温度值，记为 $T_1^{(1)}$。答案以摄氏度为单位，并四舍五入到三位有效数字。", "solution": "一维网格上的稳态条件要求，对于每个内部节点，满足以下平均关系\n$$\nT_{i}=\\frac{T_{i-1}+T_{i+1}}{2}.\n$$\n对于这三个未知数，这产生以下线性系统\n$$\n\\begin{aligned}\n2T_{1}-T_{2} &= T_{0},\\\\\n-T_{1}+2T_{2}-T_{3} &= 0,\\\\\n-T_{2}+2T_{3} &= T_{4}.\n\\end{aligned}\n$$\n对于系统 $A\\mathbf{T}=\\mathbf{b}$，SOR 迭代法的一般形式为：\n$$\nT_{i}^{(k+1)}=(1-\\omega)T_{i}^{(k)}+\\frac{\\omega}{a_{ii}}\\left(b_{i}-\\sum_{j<i}a_{ij}T_{j}^{(k+1)}-\\sum_{j>i}a_{ij}T_{j}^{(k)}\\right).\n$$\n我们要求解 $T_1^{(1)}$。对于 $i=1$，更新公式为：\n$$\nT_{1}^{(k+1)}=(1-\\omega)T_{1}^{(k)}+\\frac{\\omega}{a_{11}}\\left(b_{1}-\\sum_{j>1}a_{1j}T_{j}^{(k)}\\right).\n$$\n从方程组的第一行 $2T_1 - T_2 = T_0$ 可知，$a_{11}=2$, $a_{12}=-1$, $b_1=T_0=25$。\n代入 $k=0$、$\\omega = 1.15$、初始猜测 $T_1^{(0)}=0$, $T_2^{(0)}=0$：\n$$\n\\begin{aligned}\nT_{1}^{(1)} &= (1-1.15)T_{1}^{(0)} + \\frac{1.15}{2}\\left(T_0 - a_{12}T_2^{(0)}\\right) \\\\\n&= (-0.15) \\cdot 0 + \\frac{1.15}{2}\\left(25.0 - (-1) \\cdot 0\\right) \\\\\n&= 0.575 \\cdot 25.0 \\\\\n&= 14.375.\n\\end{aligned}\n$$\n四舍五入到三位有效数字，我们得到 $T_1^{(1)} = 14.4^\\circ\\text{C}$。", "answer": "$$\\boxed{14.4}$$", "id": "1369790"}, {"introduction": "在掌握了 SOR 方法的基本计算步骤之后，一个至关重要的问题是：这个迭代过程为什么会收敛？以及它何时会收敛？本练习将引导我们从具体计算转向收敛性的理论核心，重点关注决定迭代行为的关键——SOR 方法的迭代矩阵 $\\mathcal{L}_{\\omega}$。通过分析一个 SOR 方法不收敛的具体例子 [@problem_id:2207372]，你将计算其迭代矩阵的谱半径，并亲眼见证它为何大于 1。这个练习旨在巩固谱半径判据 $\\rho(\\mathcal{L}_{\\omega}) \\lt 1$ 的重要性，让你深刻理解抽象的数学性质与算法的实际表现之间的直接联系。", "problem": "考虑一个线性方程组 $A\\mathbf{x} = \\mathbf{b}$，其中 $A$ 是一个 2x2 矩阵，其元素为 $a_{11} = 1$，$a_{12} = 2$，$a_{21} = 3$ 和 $a_{22} = 1$。逐次超松弛 (Successive Over-Relaxation, SOR) 方法是求解此类系统的一种迭代技术。对于给定的初始猜测 $\\mathbf{x}^{(0)}$，该方法会生成一个近似序列 $\\mathbf{x}^{(k)}$，理想情况下该序列会收敛到真实解。SOR 方法的分量更新规则由下式给出：\n$$ x_i^{(k+1)} = (1-\\omega)x_i^{(k)} + \\frac{\\omega}{a_{ii}} \\left( b_i - \\sum_{j<i} a_{ij}x_j^{(k+1)} - \\sum_{j>i} a_{ij}x_j^{(k)} \\right) $$\n该方法是否收敛取决于其迭代矩阵 $\\mathcal{L}_{\\omega}$ 的谱半径 $\\rho(\\mathcal{L}_{\\omega})$，只有当 $\\rho(\\mathcal{L}_{\\omega}) < 1$ 时才收敛。对于给定的矩阵 $A$，请计算当松弛参数 $\\omega = \\frac{6}{5}$ 时，SOR 迭代矩阵的谱半径。将您的答案四舍五入到四位有效数字。", "solution": "我们使用标准分裂 $A = D - L - U$，其中 $D$ 是 $A$ 的对角部分，$-L$ 是严格下三角部分，$-U$ 是严格上三角部分。对于 SOR 方法，迭代矩阵为\n$$\n\\mathcal{L}_{\\omega} = (D - \\omega L)^{-1}\\big((1-\\omega)D + \\omega U\\big).\n$$\n给定 $A = \\begin{pmatrix}1 & 2 \\\\ 3 & 1\\end{pmatrix}$，我们有\n$$\nD = \\begin{pmatrix}1 & 0 \\\\ 0 & 1\\end{pmatrix},\\quad L = \\begin{pmatrix}0 & 0 \\\\ -3 & 0\\end{pmatrix},\\quad U = \\begin{pmatrix}0 & -2 \\\\ 0 & 0\\end{pmatrix}.\n$$\n则\n$$\nD - \\omega L = \\begin{pmatrix}1 & 0 \\\\ 3\\omega & 1\\end{pmatrix},\\quad (D - \\omega L)^{-1} = \\begin{pmatrix}1 & 0 \\\\ -3\\omega & 1\\end{pmatrix},\n$$\n且\n$$\n(1-\\omega)D + \\omega U = \\begin{pmatrix}1-\\omega & -2\\omega \\\\ 0 & 1-\\omega\\end{pmatrix}.\n$$\n因此，\n$$\n\\mathcal{L}_{\\omega} = \\begin{pmatrix}1 & 0 \\\\ -3\\omega & 1\\end{pmatrix}\\begin{pmatrix}1-\\omega & -2\\omega \\\\ 0 & 1-\\omega\\end{pmatrix}\n= \\begin{pmatrix}\n1-\\omega & -2\\omega \\\\\n-3\\omega(1-\\omega) & 6\\omega^{2} + (1-\\omega)\n\\end{pmatrix}.\n$$\n$\\mathcal{L}_{\\omega}$ 的特征值满足\n$$\n\\lambda^{2} - \\operatorname{tr}(\\mathcal{L}_{\\omega})\\,\\lambda + \\det(\\mathcal{L}_{\\omega}) = 0,\n$$\n其中\n$$\n\\operatorname{tr}(\\mathcal{L}_{\\omega}) = (1-\\omega) + \\big(6\\omega^{2} + (1-\\omega)\\big) = 6\\omega^{2} + 2 - 2\\omega,\n$$\n$$\n\\det(\\mathcal{L}_{\\omega}) = (1-\\omega)\\big(6\\omega^{2} + (1-\\omega)\\big) - (-2\\omega)\\big(-3\\omega(1-\\omega)\\big) = (1-\\omega)^{2}.\n$$\n因此特征值为\n$$\n\\lambda_{\\pm} = \\frac{1}{2}\\left(6\\omega^{2} + 2 - 2\\omega \\pm \\sqrt{\\big(6\\omega^{2} + 2 - 2\\omega\\big)^{2} - 4(1-\\omega)^{2}}\\right).\n$$\n对于 $\\omega = \\frac{6}{5}$，我们精确计算\n$$\n\\operatorname{tr} = \\frac{206}{25},\\quad \\det = \\frac{1}{25},\\quad \\sqrt{\\operatorname{tr}^{2} - 4\\det} = \\frac{84\\sqrt{6}}{25},\n$$\n所以\n$$\n\\lambda_{\\pm} = \\frac{1}{2}\\left(\\frac{206}{25} \\pm \\frac{84\\sqrt{6}}{25}\\right) = \\frac{103 \\pm 42\\sqrt{6}}{25}.\n$$\n谱半径是较大的那个特征值：\n$$\n\\rho(\\mathcal{L}_{\\omega}) = \\frac{103 + 42\\sqrt{6}}{25} \\approx 8.235142768\\ldots\n$$\n四舍五入到四位有效数字得到 $8.235$。", "answer": "$$\\boxed{8.235}$$", "id": "2207372"}, {"introduction": "我们已经知道了如何应用 SOR 方法，也理解了其收敛的条件。最后，也是最实用的一步，是学习如何让它更高效地工作，其关键在于松弛因子 $\\omega$ 的选择。本练习是一项计算科学研究中的典型任务：一个完整的数值实验。通过编写代码来系统地探索 $\\omega$ 与收敛速度（通过谱半径来衡量）之间的关系 [@problem_id:3198998]，你将能通过数值搜索找到最小化谱半径的最优松弛因子 $\\omega_{\\mathrm{opt}}$。这不仅是一项编程练习，更是优化迭代求解器性能的一项基本而重要的实践。", "problem": "要求您实现一个完整的、可运行的程序，该程序执行一项数值实验，以研究逐次超松弛 (SOR) 方法应用于具有齐次狄利克雷边界条件的一维泊松线性系统。该实验将绘制 SOR 迭代矩阵的谱半径作为松弛参数的函数，并仅使用基本定义，从此谱半径的最小值点推断出近似最优的松弛参数。\n\n在单位区间上具有齐次狄利克雷边界条件的一维泊松边值问题，在 $N$ 个内部点上进行离散化，网格间距为 $h = \\frac{1}{N+1}$。这会产生一个线性系统 $A \\mathbf{u} = \\mathbf{f}$，其中 $A \\in \\mathbb{R}^{N \\times N}$ 是一个三对角矩阵，主对角线上为 $2$，第一副对角线和第一超对角线上为 $-1$，对应于在 $u(0)=u(1)=0$ 条件下二阶导数的标准二阶中心有限差分近似。请注意，构造 SOR 迭代矩阵不需要右侧项 $\\mathbf{f}$。\n\n定义经典矩阵分裂 $A = D - L - U$，其中 $D$ 是 $A$ 的对角部分，$L$ 是 $A$ 的严格下三角部分（其符号选择使得 $A = D - L - U$），$U$ 是 $A$ 的严格上三角部分（使用相同的符号约定）。对于松弛参数 $\\omega$（满足 $0 < \\omega < 2$），SOR 不动点迭代 $x^{(k+1)} = T_{\\mathrm{SOR}}(\\omega) x^{(k)} + c(\\omega)$ 通过以下方式定义\n$$\nT_{\\mathrm{SOR}}(\\omega) = \\left(D - \\omega L\\right)^{-1} \\left((1-\\omega) D + \\omega U\\right).\n$$\n谱半径 $\\rho\\!\\left(T_{\\mathrm{SOR}}(\\omega)\\right)$ 是 $T_{\\mathrm{SOR}}(\\omega)$ 特征值的最大模。\n\n您的任务是：\n- 对于每个指定的测试用例，构造 $A$，为 $(0,2)$ 中的一组密集的 $\\omega$ 值构建 $T_{\\mathrm{SOR}}(\\omega)$，通过计算 $T_{\\mathrm{SOR}}(\\omega)$ 的特征值来数值计算每个 $\\omega$ 对应的 $\\rho\\!\\left(T_{\\mathrm{SOR}}(\\omega)\\right)$，并确定网格上使 $\\rho\\!\\left(T_{\\mathrm{SOR}}(\\omega)\\right)$ 最小的 $\\omega$ 值。将这个最小值点称为 $\\omega_{\\mathrm{opt}}$。\n- 确保不显式构造矩阵的逆；使用线性求解来将 $\\left(D - \\omega L\\right)^{-1}$ 应用于右侧的矩阵。\n\n使用以下参数值的测试套件：\n- 测试用例 1：$N = 1$，$\\omega_{\\min} = 0.05$，$\\omega_{\\max} = 1.95$，$\\Delta \\omega = 0.005$。\n- 测试用例 2：$N = 10$，$\\omega_{\\min} = 0.05$，$\\omega_{\\max} = 1.95$，$\\Delta \\omega = 0.01$。\n- 测试用例 3：$N = 50$，$\\omega_{\\min} = 0.05$，$\\omega_{\\max} = 1.95$，$\\Delta \\omega = 0.02$。\n\n约束和要求：\n- 所有计算都是纯数值的，并且必须在指定的区间内对 $\\omega$ 进行均匀采样，包括严格位于 $(0,2)$ 内的端点。\n- 对于每个测试用例，报告一个浮点数，该数等于在网格上找到的最小化 $\\omega_{\\mathrm{opt}}$，四舍五入到恰好 $6$ 位小数。\n- 您的程序应生成单行输出，其中包含按测试用例顺序排列的结果，格式为方括号内以逗号分隔的列表。例如：$[\\text{result}_1,\\text{result}_2,\\text{result}_3]$。", "solution": "该问题被评估为有效，因为它具有科学依据、适定且客观。它提出了一个计算科学中的标准数值实验，没有矛盾或歧义。\n\n目标是数值确定逐次超松弛 (SOR) 方法的最优松弛参数 $\\omega_{\\mathrm{opt}}$。该方法应用于由一维泊松方程 $u''(x) = g(x)$（在单位区间 $x \\in [0, 1]$ 上，具有齐次狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$）的有限差分法离散化所产生的线性系统。\n\n在具有 $N$ 个内部点和间距 $h = \\frac{1}{N+1}$ 的均匀网格上使用二阶中心有限差分格式，可得到线性系统 $A \\mathbf{u} = \\mathbf{f}$。矩阵 $A \\in \\mathbb{R}^{N \\times N}$ 是一个对称、正定、三对角矩阵，如下所示：\n$$\nA = \n\\begin{pmatrix}\n 2 & -1 & & & \\\\\n-1 &  2 & -1 & & \\\\\n & \\ddots & \\ddots & \\ddots & \\\\\n & & -1 &  2 & -1 \\\\\n & & & -1 & 2\n\\end{pmatrix}\n$$\nSOR 方法的收敛速度由其迭代矩阵的谱半径决定。为了构造这个矩阵，我们将 $A$ 分裂为其对角 ($D$)、严格下三角 ($L$) 和严格上三角 ($U$) 部分。问题指定分解为 $A = D - L - U$。给定 $A$ 的结构，这些矩阵是：\n- $D$ 是一个对角矩阵，所有元素都等于 $2$。$D = \\mathrm{diag}(2, 2, \\dots, 2)$。\n- 由于 $A_{i, i-1} = -1$ 且 $A = D - L - U$，我们有 $-1 = -L_{i, i-1}$，这意味着 $L_{i, i-1} = 1$。因此，$L$ 是一个严格下双对角矩阵，其第一副对角线上的元素为 $1$。\n- 同样，由于 $A_{i, i+1} = -1$，我们有 $-1 = -U_{i, i+1}$，所以 $U_{i, i+1} = 1$。因此，$U$ 是一个严格上双对角矩阵，其第一超对角线上的元素为 $1$。\n\nSOR 迭代由不动点关系 $\\mathbf{x}^{(k+1)} = T_{\\mathrm{SOR}}(\\omega) \\mathbf{x}^{(k)} + \\mathbf{c}$ 定义，其中 $\\omega \\in (0, 2)$ 是松弛参数，$T_{\\mathrm{SOR}}(\\omega)$ 是迭代矩阵。迭代矩阵的公式如下：\n$$\nT_{\\mathrm{SOR}}(\\omega) = (D - \\omega L)^{-1}((1-\\omega)D + \\omega U)\n$$\nSOR 迭代的渐近收敛速度由 $T_{\\mathrm{SOR}}(\\omega)$ 的谱半径控制，记为 $\\rho(T_{\\mathrm{SOR}}(\\omega))$，它是 $T_{\\mathrm{SOR}}(\\omega)$ 特征值的最大绝对值。最优松弛参数 $\\omega_{\\mathrm{opt}}$ 是使该谱半径最小化的 $\\omega$ 值：\n$$\n\\omega_{\\mathrm{opt}} = \\arg\\min_{\\omega \\in (0,2)} \\rho(T_{\\mathrm{SOR}}(\\omega))\n$$\n此问题要求通过在区间 $(0, 2)$ 内的指定离散网格上对 $\\omega$ 进行采样，对不同的矩阵大小 $N$ 进行数值搜索，以找到 $\\omega_{\\mathrm{opt}}$ 的近似值。\n\n每个测试用例 $(N, \\omega_{\\min}, \\omega_{\\max}, \\Delta \\omega)$ 的数值算法如下：\n1.  为给定的维度 $N$ 构造矩阵 $D$、$L$ 和 $U$。\n2.  从 $\\omega_{\\min}$到 $\\omega_{\\max}$ 以 $\\Delta \\omega$ 为增量生成一个均匀的 $\\omega$ 值网格。\n3.  将变量 $\\rho_{\\min}$ 初始化为一个非常大的数（例如，无穷大），并将 $\\omega_{\\mathrm{found}}$ 初始化为一个无效值。\n4.  遍历生成网格中的每个 $\\omega$ 值：\n    a.  构造矩阵 $M(\\omega) = D - \\omega L$ 和 $N(\\omega) = (1-\\omega)D + \\omega U$。\n    b.  计算 SOR 迭代矩阵 $T_{\\mathrm{SOR}}(\\omega) = M(\\omega)^{-1}N(\\omega)$。关键在于，不显式计算逆矩阵 $M(\\omega)^{-1}$。而是求解矩阵方程 $M(\\omega) T = N(\\omega)$ 以得到 $T$。由于 $M(\\omega)$ 是一个下三角矩阵（因为 $D$ 是对角的，$L$ 是严格下三角的），这个系统可以通过对 $N(\\omega)$ 的每一列使用前向替换来高效求解。\n    c.  计算所得矩阵 $T_{\\mathrm{SOR}}(\\omega)$ 的所有特征值 $\\lambda_i$。\n    d.  计算谱半径 $\\rho(\\omega) = \\max_{i} |\\lambda_i|$。\n    e.  如果 $\\rho(\\omega) < \\rho_{\\min}$，则更新 $\\rho_{\\min} = \\rho(\\omega)$ 并设置 $\\omega_{\\mathrm{found}} = \\omega$。\n5.  遍历所有 $\\omega$ 值后，最终的 $\\omega_{\\mathrm{found}}$ 是给定网格上 $\\omega_{\\mathrm{opt}}$ 的近似值。然后报告该值。\n\n为每个指定的测试用例实现这整个过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Performs a numerical experiment to find the optimal SOR relaxation parameter omega\n    by minimizing the spectral radius of the SOR iteration matrix.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, omega_min, omega_max, delta_omega)\n        (1, 0.05, 1.95, 0.005),\n        (10, 0.05, 1.95, 0.01),\n        (50, 0.05, 1.95, 0.02),\n    ]\n\n    results = []\n    for N, w_min, w_max, delta_w in test_cases:\n        # Construct the matrices D, L, and U based on the problem description.\n        # A is tridiagonal with 2 on the diagonal and -1 on the off-diagonals.\n        # The splitting is A = D - L - U.\n        # This implies:\n        # D has 2 on the diagonal.\n        # L has 1 on the first sub-diagonal.\n        # U has 1 on the first super-diagonal.\n        \n        # D is a diagonal matrix with entries 2.\n        D = np.diag(np.full(N, 2.0))\n        \n        if N > 1:\n            # L is strictly lower triangular with 1s on the first sub-diagonal.\n            L = np.diag(np.ones(N - 1), k=-1)\n            # U is strictly upper triangular with 1s on the first super-diagonal.\n            U = np.diag(np.ones(N - 1), k=1)\n        else: # N=1 case, L and U are zero matrices.\n            L = np.array([[0.0]])\n            U = np.array([[0.0]])\n\n        # Generate the grid of omega values.\n        # Using np.linspace is more robust for floating-point ranges.\n        num_points = int(round((w_max - w_min) / delta_w)) + 1\n        omegas = np.linspace(w_min, w_max, num_points)\n\n        min_rho = float('inf')\n        opt_omega = -1.0\n\n        for omega in omegas:\n            # Construct the matrices for the SOR operator T_sor = M^-1 * N\n            M_omega = D - omega * L\n            N_omega = (1.0 - omega) * D + omega * U\n\n            # Compute T_sor by solving the system M * T = N.\n            # This avoids explicit inversion of M.\n            # Since M_omega is lower triangular, we use solve_triangular.\n            T_sor = linalg.solve_triangular(M_omega, N_omega, lower=True)\n\n            # Compute the eigenvalues of the iteration matrix.\n            eigenvalues = linalg.eigvals(T_sor)\n\n            # The spectral radius is the maximum magnitude of the eigenvalues.\n            rho = np.max(np.abs(eigenvalues))\n\n            # Check if this omega gives a smaller spectral radius.\n            if rho < min_rho:\n                min_rho = rho\n                opt_omega = omega\n        \n        # Append the found optimal omega, formatted to 6 decimal places.\n        results.append(f\"{opt_omega:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3198998"}]}