{"hands_on_practices": [{"introduction": "要真正理解一个算法，将其可视化是一个有效方法。高斯-赛德尔方法在几何上可以看作是在坐标空间中的一系列移动，每一次迭代都使我们更接近方程组的解。通过完成这个练习 [@problem_id:2214528]，您将计算迭代过程的最初几个步骤，并直观地看到解向量是如何通过在代表系统中每个方程的直线上交替移动来“走向”最终解的。", "problem": "考虑$x_1$-$x_2$平面中的以下线性方程组：\n$$5x_1 - 2x_2 = 3$$\n$$x_1 + 4x_2 = 10$$\n高斯-赛德尔方法是一种用于近似求解线性方程组解的迭代算法。从一个初始猜测 $\\mathbf{x}^{(0)} = (x_1^{(0)}, x_2^{(0)})$ 开始，它为 $k = 1, 2, 3, \\ldots$ 生成一个近似序列 $\\mathbf{x}^{(k)} = (x_1^{(k)}, x_2^{(k)})$。在几何上，该方法的每一步都可以解释为在$x_1$-$x_2$平面上的一次移动。\n\n令由高斯-赛德尔方法生成的点序列表示为 $P_k = (x_1^{(k)}, x_2^{(k)})$。使用初始猜测 $P_0 = (0, 0)$，确定该方法前两次完整迭代所产生的点 $P_1 = (x_1^{(1)}, x_2^{(1)})$ 和 $P_2 = (x_1^{(2)}, x_2^{(2)})$ 的坐标。\n\n请将你的答案以四个坐标 $x_1^{(1)}, x_2^{(1)}, x_1^{(2)}, x_2^{(2)}$ 的形式，按此特定顺序，放在一个单行矩阵中。所有值都表示为精确分数。", "solution": "我们将每个方程求解一个变量，以获得高斯-赛德尔迭代形式。由$5x_{1}-2x_{2}=3$，解出$x_{1}$：\n$$\nx_{1}=\\frac{3+2x_{2}}{5}.\n$$\n由$x_{1}+4x_{2}=10$，解出$x_{2}$：\n$$\nx_{2}=\\frac{10-x_{1}}{4}.\n$$\n在高斯-赛德尔方法中，在第 $k$ 次迭代时，我们使用最新的值顺序更新：\n$$\nx_{1}^{(k)}=\\frac{3+2x_{2}^{(k-1)}}{5},\\qquad x_{2}^{(k)}=\\frac{10-x_{1}^{(k)}}{4}.\n$$\n从 $P_{0}=(x_{1}^{(0)},x_{2}^{(0)})=(0,0)$ 开始：\n\n第一次迭代 $k=1$：\n$$\nx_{1}^{(1)}=\\frac{3+2x_{2}^{(0)}}{5}=\\frac{3+2\\cdot 0}{5}=\\frac{3}{5},\n$$\n$$\nx_{2}^{(1)}=\\frac{10-x_{1}^{(1)}}{4}=\\frac{10-\\frac{3}{5}}{4}=\\frac{\\frac{50}{5}-\\frac{3}{5}}{4}=\\frac{\\frac{47}{5}}{4}=\\frac{47}{20}.\n$$\n\n第二次迭代 $k=2$：\n$$\nx_{1}^{(2)}=\\frac{3+2x_{2}^{(1)}}{5}=\\frac{3+2\\cdot \\frac{47}{20}}{5}=\\frac{3+\\frac{47}{10}}{5}=\\frac{\\frac{30}{10}+\\frac{47}{10}}{5}=\\frac{\\frac{77}{10}}{5}=\\frac{77}{50},\n$$\n$$\nx_{2}^{(2)}=\\frac{10-x_{1}^{(2)}}{4}=\\frac{10-\\frac{77}{50}}{4}=\\frac{\\frac{500}{50}-\\frac{77}{50}}{4}=\\frac{\\frac{423}{50}}{4}=\\frac{423}{200}.\n$$\n因此，所求坐标为 $x_{1}^{(1)}=\\frac{3}{5}$，$x_{2}^{(1)}=\\frac{47}{20}$，$x_{1}^{(2)}=\\frac{77}{50}$ 以及 $x_{2}^{(2)}=\\frac{423}{200}$。", "answer": "$$\\boxed{\\begin{pmatrix}\\frac{3}{5}  \\frac{47}{20}  \\frac{77}{50}  \\frac{423}{200}\\end{pmatrix}}$$", "id": "2214528"}, {"introduction": "并非所有线性系统都适用于迭代法求解，一个关键问题是：算法何时收敛？高斯-赛德尔方法的收敛性取决于系数矩阵的性质，例如对角占优性。这个练习 [@problem_id:1394885] 提供了一个反例，其中的迭代序列不会收敛到解，而是会发散。通过亲手计算，您将观察到迭代值如何迅速增大，从而深刻理解检验收敛条件在实际应用中的重要性。", "problem": "一位工程师的任务是求解一个用于模拟简单静态结构框架的线性方程组。该方程组如下：\n$$\n\\begin{cases}\n    x_1 + 2x_2 = 5 \\\\\n    3x_1 + x_2 = 4\n\\end{cases}\n$$\n工程师决定使用高斯-赛德尔法（一种迭代方法）来近似求解。该方法从解向量的一个初始猜测值开始，并在每次迭代中对其进行优化。\n\n从初始猜测值 $\\mathbf{x}^{(0)} = \\begin{pmatrix} x_1^{(0)} \\\\ x_2^{(0)} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$ 开始，计算经过三次完整的高斯-赛德尔法迭代后解向量 $\\mathbf{x}^{(3)} = \\begin{pmatrix} x_1^{(3)} \\\\ x_2^{(3)} \\end{pmatrix}$ 的值。", "solution": "高斯-赛德尔法使用最新的可用值顺序更新每个变量。对于方程组\n$$\n\\begin{cases}\nx_{1} + 2 x_{2} = 5 \\\\\n3 x_{1} + x_{2} = 4\n\\end{cases}\n$$\n将每个方程针对其对应的变量求解，以获得迭代公式：\n$$\nx_{1}^{(k+1)} = 5 - 2 x_{2}^{(k)}, \\quad x_{2}^{(k+1)} = 4 - 3 x_{1}^{(k+1)}.\n$$\n从 $\\mathbf{x}^{(0)} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$ 开始，计算三次完整迭代。\n\n第一次迭代 ($k=0 \\to 1$):\n$$\nx_{1}^{(1)} = 5 - 2 x_{2}^{(0)} = 5 - 2 \\cdot 0 = 5,\n$$\n$$\nx_{2}^{(1)} = 4 - 3 x_{1}^{(1)} = 4 - 3 \\cdot 5 = 4 - 15 = -11.\n$$\n\n第二次迭代 ($k=1 \\to 2$):\n$$\nx_{1}^{(2)} = 5 - 2 x_{2}^{(1)} = 5 - 2 \\cdot (-11) = 5 + 22 = 27,\n$$\n$$\nx_{2}^{(2)} = 4 - 3 x_{1}^{(2)} = 4 - 3 \\cdot 27 = 4 - 81 = -77.\n$$\n\n第三次迭代 ($k=2 \\to 3$):\n$$\nx_{1}^{(3)} = 5 - 2 x_{2}^{(2)} = 5 - 2 \\cdot (-77) = 5 + 154 = 159,\n$$\n$$\nx_{2}^{(3)} = 4 - 3 x_{1}^{(3)} = 4 - 3 \\cdot 159 = 4 - 477 = -473.\n$$\n\n因此，经过三次完整的高斯-赛德尔迭代后，解向量为 $\\mathbf{x}^{(3)} = \\begin{pmatrix} 159 \\\\ -473 \\end{pmatrix}$。", "answer": "$$\\boxed{\\begin{pmatrix}159  -473\\end{pmatrix}}$$", "id": "1394885"}, {"introduction": "从理论算法到实际的计算机程序，一个核心的实际问题是如何确定迭代何时停止。一个常见的策略是当残差（即 $b - Ax$）足够小时停止，但如何“衡量”残差的大小并非显而易见。这个练习 [@problem_id:3135103] 要求您实现并比较两种不同的停止准则，揭示一个看似直观的准则在特定情况下可能会产生误导，并促使您思考如何设计更稳健的收敛判断标准。", "problem": "要求您为应用于求解线性系统的高斯-赛德尔迭代法设计并分析一个终止准则。考虑一个方阵 $A \\in \\mathbb{R}^{n \\times n}$ 和一个右端向量 $b \\in \\mathbb{R}^{n}$。目标是使用 Gauss–Seidel 迭代法，从一个初始猜测 $x^{(0)}$ 开始，近似求解系统 $A x^{\\star} = b$ 的解 $x^{\\star}$。在每次迭代 $k$ 中，定义残差 $r^{(k)} = b - A x^{(k)}$。任务是实现两种停止准则，并在精心选择的测试用例上比较它们的行为。\n\n需要使用的基础知识：\n- 线性系统 $A x = b$ 的定义以及通过顺序满足单个方程进行迭代改进的概念。\n- 残差的定义 $r(x) = b - A x$ 及其作为衡量 $x$ 离解的距离的作用。\n- 向量的欧几里得范数（也称为 $2$-范数），记为 $\\| \\cdot \\|$，以及矩阵的诱导算子范数 $\\| A \\|$（$A$ 的最大奇异值）。\n\n要求：\n1. 从第一性原理实现 Gauss–Seidel 迭代：从 $x^{(0)}$ 开始，通过顺序更新分量来生成 $x^{(k+1)}$，使得在每次扫描中，每个标量方程都使用最新的可用分量值来满足。避免使用任何快捷公式；您的更新应基于在当前扫描中使用最近更新的分量和在上次扫描中使用的剩余分量，一次满足一个方程。\n2. 从迭代 $k = 1$ 开始，实现并跟踪两种停止准则：\n   - 规则 R1（通过右端向量进行归一化的残差）：在满足 $\\displaystyle \\frac{\\| r^{(k)} \\|}{\\| b \\|} \\leq \\tau$ 的最小 $k$ 处停止。\n   - 规则 R2（通过矩阵和迭代向量进行归一化的残差）：在满足 $\\displaystyle \\frac{\\| r^{(k)} \\|}{\\| A \\| \\, \\| x^{(k)} \\|} \\leq \\tau$ 的最小 $k$ 处停止。\n3. 边界情况的约定：\n   - 如果 $\\| r^{(k)} \\| = 0$，则无论分母为何，都将任一规则的比率视为 $0$ 并接受收敛。\n   - 对于规则 R1，如果 $\\| b \\| = 0$ 且 $\\| r^{(k)} \\| \\neq 0$，则将比率视为 $+\\infty$（在此次迭代中不收敛）。\n   - 对于规则 R2，如果在某次迭代中 $\\| x^{(k)} \\| = 0$ 且 $\\| r^{(k)} \\| \\neq 0$，则将该次迭代的比率视为 $+\\infty$。\n4. 对于每个测试用例，使用直接求解法计算精确解 $x^{\\star}$（以便评估前向误差）。将第 $k$ 次迭代的相对前向误差定义为 $\\displaystyle \\frac{\\| x^{(k)} - x^{\\star} \\|}{\\| x^{\\star} \\|}$，并仅将其用于分析（不要用作停止准则）。\n5. 定义容差 $\\tau = 10^{-4}$ 和最大迭代次数 $K_{\\max} = 5000$。对向量使用欧几里得范数，对矩阵使用诱导算子范数（最大奇异值）。不涉及角度；不涉及物理单位。\n6. 您的程序必须运行 Gauss–Seidel 迭代，不提前终止，以收集完整的序列 $\\{ x^{(k)} \\}_{k=1}^{K_{\\max}}$，并对该序列评估两种停止准则。然后，为每个测试用例返回：\n   - $N_{\\mathrm{R1}}$：满足规则 R1 的最小 $k$，如果在 $K_{\\max}$ 次迭代内未满足，则为 $K_{\\max}$，\n   - $N_{\\mathrm{R2}}$：满足规则 R2 的最小 $k$，如果在 $K_{\\max}$ 次迭代内未满足，则为 $K_{\\max}$，\n   - $\\mathrm{inflated}$：一个布尔值，如果规则 R1 比规则 R2 更早地发出收敛信号（即 $N_{\\mathrm{R1}}  N_{\\mathrm{R2}}$），并且在迭代 $N_{\\mathrm{R1}}$ 时，相对前向误差 $\\displaystyle \\frac{\\| x^{(N_{\\mathrm{R1}})} - x^{\\star} \\|}{\\| x^{\\star} \\|}$ 严格大于 $\\tau$，则为 $\\mathrm{True}$。否则，$\\mathrm{inflated}$ 为 $\\mathrm{False}$。\n\n测试套件：\n- 情况 1（良态缩放，对称正定，对角占优）：\n  - $A = \\begin{pmatrix} 4  -1  0 \\\\ -1  4  -1 \\\\ 0  -1  3 \\end{pmatrix}$，\n  - $b = \\begin{pmatrix} 15 \\\\ 10 \\\\ 10 \\end{pmatrix}$，\n  - $x^{(0)} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}$。\n  这种情况是一般性的理想路径，预计两种规则的行为会相似。\n- 情况 2（通过缩放 $b$（相对于矩阵范数）来构造，以夸大规则 R1 下的感知进展）：\n  - $A = \\begin{pmatrix} 10^{-2}  2 \\cdot 10^{-3}  0 \\\\ 10^{-3}  2 \\cdot 10^{-2}  3 \\cdot 10^{-3} \\\\ 0  10^{-3}  3 \\cdot 10^{-2} \\end{pmatrix}$，\n  - $b = \\begin{pmatrix} 10^{8} \\\\ -10^{8} \\\\ 10^{8} \\end{pmatrix}$，\n  - $x^{(0)} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}$。\n  这种情况的设计目的是，通过除以较大的 $\\| b \\|$ 来使 $\\displaystyle \\frac{\\| r^{(k)} \\|}{\\| b \\|}$ 比另一种规则更早地显得很小，从而可能夸大感知到的进展。\n- 情况 3（右端为零的边界条件）：\n  - $A = \\begin{pmatrix} 4  -1  0 \\\\ -1  4  -1 \\\\ 0  -1  3 \\end{pmatrix}$，\n  - $b = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}$，\n  - $x^{(0)} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}$。\n  这种情况验证了对 $\\| b \\| = 0$ 的处理以及零残差意味着接受的约定。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含结果，形式为以逗号分隔的每个案例的三元组列表，每个三元组格式为 $[N_{\\mathrm{R1}},N_{\\mathrm{R2}},\\mathrm{inflated}]$，整个集合用方括号括起来。例如，输出格式必须像 $[[N_{1,\\mathrm{R1}},N_{1,\\mathrm{R2}},\\mathrm{inflated}_1],[N_{2,\\mathrm{R1}},N_{2,\\mathrm{R2}},\\mathrm{inflated}_2],[N_{3,\\mathrm{R1}},N_{3,\\mathrm{R2}},\\mathrm{inflated}_3]]$，其中每个 $N$ 是一个整数，每个 $\\mathrm{inflated}$ 是 $\\mathrm{True}$ 或 $\\mathrm{False}$。", "solution": "该问题是有效的。这是一个定义明确的数值线性代数练习，专注于实现和分析用于求解线性方程组的 Gauss-Seidel 迭代法。该问题在科学上是合理的、自洽的，并且所有提供的数据和条件都是一致且明确的。\n\n任务是使用 Gauss-Seidel 迭代法，针对三种不同情况求解线性系统 $A x^{\\star} = b$。我们将从第一性原理实现该方法，应用两种不同的停止准则，并分析它们的行为。分析涉及比较每个规则满足时的迭代次数，并评估一个特殊条件 `inflated`，该条件用于诊断由其中一个规则发出的过早收敛信号。\n\n**1. Gauss-Seidel 迭代法**\n\nGauss-Seidel 方法是一种用于近似求解线性系统 $A x = b$ 的迭代技术。给定一个方阵 $A \\in \\mathbb{R}^{n \\times n}$ 和一个向量 $b \\in \\mathbb{R}^{n}$，我们寻求解向量 $x \\in \\mathbb{R}^{n}$。该系统可以按分量写成：\n$$ \\sum_{j=1}^{n} A_{ij} x_j = b_i \\quad \\text{for } i = 1, 2, \\ldots, n $$\n其中 $A_{ij}$ 是 $A$ 中第 $i$ 行第 $j$ 列的元素。为了形成一个迭代格式，我们求解第 $i$ 个方程以得到第 $i$ 个分量 $x_i$：\n$$ A_{ii} x_i = b_i - \\sum_{j \\neq i} A_{ij} x_j $$\n假设对所有 $i$ 都有 $A_{ii} \\neq 0$，我们可以写出：\n$$ x_i = \\frac{1}{A_{ii}} \\left( b_i - \\sum_{j \\neq i} A_{ij} x_j \\right) $$\nGauss-Seidel 迭代从一个初始猜测 $x^{(0)}$ 开始，构造一个近似解序列 $\\{x^{(k)}\\}_{k=0}^{\\infty}$。为了从当前迭代值 $x^{(k)}$ 计算下一个迭代值 $x^{(k+1)}$，我们按顺序更新每个分量 $x_i^{(k+1)}$，其中 $i=1, \\ldots, n$。该方法的核心原理是在当前迭代中使用最新计算出的分量值。在计算 $x_i^{(k+1)}$ 时，分量 $x_1^{(k+1)}, \\ldots, x_{i-1}^{(k+1)}$ 已经被确定。对于其余分量，我们使用上一次迭代的值，$x_{i+1}^{(k)}, \\ldots, x_{n}^{(k)}$。这导出了 Gauss-Seidel 方法的定义更新规则：\n$$ x_i^{(k+1)} = \\frac{1}{A_{ii}} \\left( b_i - \\sum_{j=1}^{i-1} A_{ij} x_j^{(k+1)} - \\sum_{j=i+1}^{n} A_{ij} x_j^{(k)} \\right) \\quad \\text{for } i = 1, \\ldots, n $$\n\n**2. 停止准则与分析**\n\n迭代法需要一个规则来确定何时停止。一个常见的误差度量是残差 $r^{(k)} = b - A x^{(k)}$，它仅在 $x^{(k)}$ 是精确解时才为零。我们的任务是评估两种基于残差的欧几里得范数（记为 $\\| \\cdot \\|$）的停止准则。给定的容差为 $\\tau = 10^{-4}$。\n\n*   **规则 R1（通过右端向量归一化）：** $\\displaystyle \\frac{\\| r^{(k)} \\|}{\\| b \\|} \\leq \\tau$\n    该准则衡量残差范数相对于右端向量 $b$ 的范数的比值。它很直观，但可能会产生误导。如果 $\\|b\\|$ 非常大，即使 $x^{(k)}$ 离真实解 $x^{\\star}$ 很远，这个比率也可能变得很小，从而给人一种收敛的错觉。相反，如果 $\\|b\\|$ 非常小，该准则可能过于严格。测试用例 2 就是为了暴露这个弱点而设计的。\n\n*   **规则 R2（通过矩阵和迭代向量归一化）：** $\\displaystyle \\frac{\\| r^{(k)} \\|}{\\| A \\| \\, \\| x^{(k)} \\|} \\leq \\tau$\n    该准则与后向误差的概念有关。左侧的值可以解释为对矩阵 $A$ 的最小相对扰动，使得 $x^{(k)}$ 成为某个扰动系统的精确解。它通常比规则 R1 更稳健，因为它通过一个与系统当前状态（$A$ 和 $x^{(k)}$）内在相关的尺度来对残差进行归一化，而不仅仅是输入 $b$。矩阵范数 $\\|A\\|$ 是诱导 $2$-范数，计算为 $A$ 的最大奇异值。\n\n为了进行分析，我们将使用直接求解器计算精确解 $x^{\\star}$。迭代值 $x^{(k)}$ 的真实精度由相对前向误差衡量：$\\frac{\\| x^{(k)} - x^{\\star} \\|}{\\| x^{\\star} \\|}$。我们需要识别规则 R1 何时过早地发出收敛信号。这由 `inflated` 标志捕获，如果规则 R1 比规则 R2 更早停止（$N_{\\mathrm{R1}}  N_{\\mathrm{R2}}$），并且在那时解尚不准确（在迭代 $N_{\\mathrm{R1}}$ 时的相对前向误差大于 $\\tau$），则该标志设置为 `True`。\n\n**3. 算法实现**\n\n对于每个测试用例，算法按以下步骤进行：\n\n1.  **初始化**：定义矩阵 $A$、向量 $b$ 和初始猜测 $x^{(0)}$。设置容差 $\\tau = 10^{-4}$ 和最大迭代次数 $K_{\\max} = 5000$。\n2.  **预计算**：\n    *   通过直接求解 $A x = b$（例如，使用 LU 分解）来计算精确解 $x^{\\star}$。\n    *   计算并存储常数范数：$\\|b\\|$, $\\|A\\|$（最大奇异值）和 $\\|x^{\\star}\\|$。\n3.  **迭代循环**：运行 Gauss-Seidel 迭代固定步数，从 $k=0$ 到 $K_{\\max}-1$，以生成迭代序列 $\\{x^{(k)}\\}_{k=1}^{K_{\\max}}$。\n    *   在每一步中，为了从 $x^{(k)}$ 得到 $x^{(k+1)}$，遍历分量 $i = 1, \\ldots, n$ 并应用更新公式。\n    *   计算出 $x^{(k+1)}$ 后，计算残差 $r^{(k+1)} = b - A x^{(k+1)}$。\n    *   计算并存储两种停止准则规则左侧的值，注意处理指定的边界条件（例如，如果分母为零）。\n    *   计算并存储相对前向误差 $\\frac{\\| x^{(k+1)} - x^{\\star} \\|}{\\| x^{\\star} \\|}$。\n4.  **后处理**：循环完成后，分析存储的序列。\n    *   找到 $N_{\\mathrm{R1}}$，即满足规则 R1 条件的第一个迭代索引 $k \\ge 1$。如果从未满足，则设置 $N_{\\mathrm{R1}} = K_{\\max}$。\n    *   类似地，为规则 R2 找到 $N_{\\mathrm{R2}}$。\n    *   通过检查是否 $N_{\\mathrm{R1}}  N_{\\mathrm{R2}}$ 以及在迭代 $N_{\\mathrm{R1}}$ 时的相对前向误差是否大于 $\\tau$ 来确定 `inflated` 布尔值。\n5.  **输出**：为每个测试用例收集三元组 $[N_{\\mathrm{R1}}, N_{\\mathrm{R2}}, \\mathrm{inflated}]$ 并按指定格式化最终输出。\n\n对于 $b=0$ 的情况 3 的特殊处理：精确解为 $x^{\\star}=0$。从 $x^{(0)}=0$ 开始，Gauss-Seidel 更新产生 $x^{(1)}=0$。因此残差 $r^{(1)}$ 为 $0$。根据约定，如果 $\\|r^{(k)}\\|=0$，则停止准则的比率被视为 $0$，它小于或等于 $\\tau$。因此，两个规则都在 $k=1$ 时满足，导致 $N_{\\mathrm{R1}}=1$ 和 $N_{\\mathrm{R2}}=1$。在这种情况下，条件 $N_{\\mathrm{R1}}  N_{\\mathrm{R2}}$ 为假，所以 `inflated` 是 `False`。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and analyzes Gauss-Seidel iteration with two stopping rules.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"A\": np.array([[4, -1, 0], [-1, 4, -1], [0, -1, 3]], dtype=float),\n            \"b\": np.array([15, 10, 10], dtype=float),\n            \"x0\": np.array([0, 0, 0], dtype=float),\n        },\n        {\n            \"A\": np.array([[1e-2, 2e-3, 0], [1e-3, 2e-2, 3e-3], [0, 1e-3, 3e-2]], dtype=float),\n            \"b\": np.array([1e8, -1e8, 1e8], dtype=float),\n            \"x0\": np.array([0, 0, 0], dtype=float),\n        },\n        {\n            \"A\": np.array([[4, -1, 0], [-1, 4, -1], [0, -1, 3]], dtype=float),\n            \"b\": np.array([0, 0, 0], dtype=float),\n            \"x0\": np.array([0, 0, 0], dtype=float),\n        },\n    ]\n\n    tau = 1e-4\n    K_max = 5000\n    results = []\n\n    for case in test_cases:\n        A = case[\"A\"]\n        b = case[\"b\"]\n        x_k = case[\"x0\"].copy()\n        n = A.shape[0]\n\n        # Pre-computation\n        try:\n            x_star = np.linalg.solve(A, b)\n        except np.linalg.LinAlgError:\n            # Should not happen for the given test cases as matrices are invertible.\n            # If it did, we couldn't compute forward error.\n            # Handle gracefully if needed for a general problem.\n            x_star = np.full_like(b, np.nan)\n\n        norm_b = np.linalg.norm(b)\n        norm_A = np.linalg.svd(A, compute_uv=False)[0]\n        norm_x_star = np.linalg.norm(x_star)\n\n        # Storage for analysis\n        ratios_r1 = []\n        ratios_r2 = []\n        fwd_errors = []\n\n        # Iteration loop\n        for _ in range(K_max):\n            x_next = x_k.copy()\n            for i in range(n):\n                sum1 = A[i, :i] @ x_next[:i]\n                sum2 = A[i, i+1:] @ x_k[i+1:]\n                if A[i, i] != 0:\n                    x_next[i] = (b[i] - sum1 - sum2) / A[i, i]\n            \n            x_k = x_next\n            \n            # Compute metrics for this iteration (k+1)\n            residual = b - A @ x_k\n            norm_r = np.linalg.norm(residual)\n            norm_x = np.linalg.norm(x_k)\n\n            # Rule R1 ratio\n            if norm_r == 0:\n                ratio_r1 = 0.0\n            elif norm_b == 0:\n                ratio_r1 = np.inf\n            else:\n                ratio_r1 = norm_r / norm_b\n            ratios_r1.append(ratio_r1)\n\n            # Rule R2 ratio\n            if norm_r == 0:\n                ratio_r2 = 0.0\n            elif norm_A * norm_x == 0:\n                ratio_r2 = np.inf\n            else:\n                ratio_r2 = norm_r / (norm_A * norm_x)\n            ratios_r2.append(ratio_r2)\n\n            # Forward error\n            if norm_x_star == 0:\n                # Use absolute error if x_star is the zero vector\n                fwd_error = np.linalg.norm(x_k - x_star)\n            else:\n                fwd_error = np.linalg.norm(x_k - x_star) / norm_x_star\n            fwd_errors.append(fwd_error)\n\n        # Post-processing to find N_R1, N_R2\n        N_R1 = K_max\n        for k, ratio in enumerate(ratios_r1):\n            if ratio = tau:\n                N_R1 = k + 1\n                break\n        \n        N_R2 = K_max\n        for k, ratio in enumerate(ratios_r2):\n            if ratio = tau:\n                N_R2 = k + 1\n                break\n\n        # Determine 'inflated' flag\n        inflated = False\n        if N_R1  N_R2:\n            # fwd_errors is 0-indexed, N_R1 is 1-indexed\n            if fwd_errors[N_R1 - 1] > tau:\n                inflated = True\n\n        results.append([N_R1, N_R2, inflated])\n\n    # Final print statement in the exact required format.\n    # Convert boolean to string 'True' or 'False' as required.\n    formatted_results = [f\"[{r[0]},{r[1]},{str(r[2])}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3135103"}]}