{"hands_on_practices": [{"introduction": "要真正掌握一个算法，最好的方法之一就是亲手执行它。这项练习将引导你从第一性原理出发，在一个简单的 $3 \\times 3$ 矩阵上逐步推导出 LU 分解的每一个元素。通过这种方式，你不仅能巩固对分解过程力学的理解，还能揭示其存在性和唯一性的深刻条件。[@problem_id:3156996]", "problem": "考虑将一个方阵 $A \\in \\mathbb{R}^{3 \\times 3}$ 分解为 $A = L U$ 的形式，这称为下三角-上三角（LU）分解，其中 $L$ 是下三角矩阵，$U$ 是上三角矩阵。你需要施加一个归一化约束，即 $U$ 的对角线元素全部等于 $1$，即 $u_{11} = u_{22} = u_{33} = 1$。这种归一化在计算实践中很常见，因为它将所有的主元缩放转移到了 $L$ 的对角线上。在标准的假设下进行操作：不执行行交换（即无主元选择），且对于给定的矩阵 $A$，该分解存在。\n\n从矩阵乘法和三角结构的核心定义出发，并仅使用线性代数中已经验证的结论（例如行列式的乘法性质和三角矩阵的行列式），按以下步骤进行：\n\n- 设\n$$A = \\begin{pmatrix}\n4  -2  6 \\\\\n8  -5  14 \\\\\n2  1  3\n\\end{pmatrix}, \\quad\nL = \\begin{pmatrix}\n\\ell_{11}  0  0 \\\\\n\\ell_{21}  \\ell_{22}  0 \\\\\n\\ell_{31}  \\ell_{32}  \\ell_{33}\n\\end{pmatrix}, \\quad\nU = \\begin{pmatrix}\n1  u_{12}  u_{13} \\\\\n0  1  u_{23} \\\\\n0  0  1\n\\end{pmatrix}.$$\n通过逐项对比 $A = L U$ 中的元素，并仅使用矩阵乘法的定义以及三角结构，求解相容的元素 $\\ell_{ij}$ 和 $u_{ij}$。\n\n- 从第一性原理出发，解释在 $u_{ii} = 1$ 的归一化条件下，LU 分解在何种意义上是唯一的，以及为确保在无主元选择的情况下分解存在且唯一，需要对 $A$ 施加什么约束（用顺序主子式来表述）。你的讨论应基于三角矩阵和行列式的定义与性质，而不应依赖任何预先给定的 LU 公式。\n\n- 作为你最终的数值结果，计算 $A$ 的行列式。将你的最终答案表示为一个精确的整数；无需四舍五入。", "solution": "该问题是有效的，因为它在科学上基于线性代数，问题提出得很好，并且是客观的。它为执行 LU 分解、分析其性质以及计算行列式提供了一个完整且一致的框架。我将开始解答。\n\n该问题要求基于矩阵 $A$ 分解为一个下三角矩阵 $L$ 和一个单位上三角矩阵 $U$（使得 $A=LU$）来完成三项任务。\n\n首先，我们必须为给定的矩阵 $A$ 求解 $L$ 和 $U$ 中的未知元素。\n给定的矩阵是：\n$$A = \\begin{pmatrix} 4  -2  6 \\\\ 8  -5  14 \\\\ 2  1  3 \\end{pmatrix}, \\quad L = \\begin{pmatrix} \\ell_{11}  0  0 \\\\ \\ell_{21}  \\ell_{22}  0 \\\\ \\ell_{31}  \\ell_{32}  \\ell_{33} \\end{pmatrix}, \\quad U = \\begin{pmatrix} 1  u_{12}  u_{13} \\\\ 0  1  u_{23} \\\\ 0  0  1 \\end{pmatrix}$$\n\n分解 $A=LU$ 表示为：\n$$ \\begin{pmatrix} 4  -2  6 \\\\ 8  -5  14 \\\\ 2  1  3 \\end{pmatrix} = \\begin{pmatrix} \\ell_{11}  0  0 \\\\ \\ell_{21}  \\ell_{22}  0 \\\\ \\ell_{31}  \\ell_{32}  \\ell_{33} \\end{pmatrix} \\begin{pmatrix} 1  u_{12}  u_{13} \\\\ 0  1  u_{23} \\\\ 0  0  1 \\end{pmatrix} $$\n根据矩阵乘法的定义，乘积 $LU$ 的元素由 $(LU)_{ij} = \\sum_{k=1}^{3} L_{ik} U_{kj}$ 给出。我们将这些元素与 $A$ 的相应元素 $a_{ij}$ 相等。$L$ 和 $U$ 的三角结构显著简化了求和过程。\n\n我们通过依次确定 $L$ 的列和 $U$ 的行来继续。\n\n第1列：\n$a_{11} = \\ell_{11} u_{11} = \\ell_{11} \\cdot 1 \\implies \\ell_{11} = 4$。\n$a_{21} = \\ell_{21} u_{11} = \\ell_{21} \\cdot 1 \\implies \\ell_{21} = 8$。\n$a_{31} = \\ell_{31} u_{11} = \\ell_{31} \\cdot 1 \\implies \\ell_{31} = 2$。\n\n第1行：\n$a_{12} = \\ell_{11} u_{12} \\implies 4 u_{12} = -2 \\implies u_{12} = -\\frac{1}{2}$。\n$a_{13} = \\ell_{11} u_{13} \\implies 4 u_{13} = 6 \\implies u_{13} = \\frac{3}{2}$。\n\n第2列：\n$a_{22} = \\ell_{21} u_{12} + \\ell_{22} u_{22} = 8(-\\frac{1}{2}) + \\ell_{22}(1) = -4 + \\ell_{22}$。\n所以，$-5 = -4 + \\ell_{22} \\implies \\ell_{22} = -1$。\n$a_{32} = \\ell_{31} u_{12} + \\ell_{32} u_{22} = 2(-\\frac{1}{2}) + \\ell_{32}(1) = -1 + \\ell_{32}$。\n所以，$1 = -1 + \\ell_{32} \\implies \\ell_{32} = 2$。\n\n第2行：\n$a_{23} = \\ell_{21} u_{13} + \\ell_{22} u_{23} = 8(\\frac{3}{2}) + (-1)u_{23} = 12 - u_{23}$。\n所以，$14 = 12 - u_{23} \\implies u_{23} = -2$。\n\n第3列：\n$a_{33} = \\ell_{31} u_{13} + \\ell_{32} u_{23} + \\ell_{33} u_{33} = 2(\\frac{3}{2}) + 2(-2) + \\ell_{33}(1) = 3 - 4 + \\ell_{33} = -1 + \\ell_{33}$。\n所以，$3 = -1 + \\ell_{33} \\implies \\ell_{33} = 4$。\n\n所有未知元素均已确定。得到的矩阵是：\n$$ L = \\begin{pmatrix} 4  0  0 \\\\ 8  -1  0 \\\\ 2  2  4 \\end{pmatrix}, \\quad U = \\begin{pmatrix} 1  -\\frac{1}{2}  \\frac{3}{2} \\\\ 0  1  -2 \\\\ 0  0  1 \\end{pmatrix} $$\n\n其次，我们从第一性原理出发解释唯一性和存在性条件。\n\n关于唯一性，假设对于一个非奇异矩阵 $A$ 存在两种这样的分解：$A = L_1 U_1$ 和 $A = L_2 U_2$。这里，$L_1$ 和 $L_2$ 是下三角矩阵，而 $U_1$ 和 $U_2$ 是单位上三角矩阵（对角线上元素为1的上三角矩阵）。\n从 $L_1 U_1 = L_2 U_2$，我们可以写出 $L_2^{-1} L_1 = U_2 U_1^{-1}$。\n下三角矩阵的逆是下三角矩阵，两个下三角矩阵的乘积也是下三角矩阵。因此，等式左侧的 $L_2^{-1} L_1$ 是一个下三角矩阵。\n单位上三角矩阵的逆是单位上三角矩阵，两个单位上三角矩阵的乘积也是单位上三角矩阵。因此，等式右侧的 $U_2 U_1^{-1}$ 是一个单位上三角矩阵。\n唯一一个同时是下三角矩阵和单位上三角矩阵的矩阵是单位矩阵 $I$。\n因此，我们必须有 $L_2^{-1} L_1 = I$ 和 $U_2 U_1^{-1} = I$。\n这些方程意味着 $L_1 = L_2$ 和 $U_1 = U_2$，这证明了如果分解存在，它就是唯一的。此证明依赖于 $L_2$ 和 $U_1$ 的可逆性。像 $U_1$ 这样的单位三角矩阵总是可逆的，因为其行列式为 $1$。$L_2$ 的可逆性取决于其对角线元素非零。\n\n关于存在性，我们必须建立一个条件来确保 $L$ 的对角线元素 $\\ell_{kk}$ 非零，因为在计算过程中它们被用作除数。例如，我们计算了 $u_{12} = a_{12}/\\ell_{11}$。通常，对于 $j > k$ 的 $u_{kj}$ 的公式涉及除以 $\\ell_{kk}$。\n让我们将 $\\ell_{kk}$ 与 $A$ 的性质联系起来。考虑 $A$ 的 $k \\times k$ 顺序主子矩阵，记为 $A_k$。分解 $A=LU$ 蕴含了这些子矩阵的分解。设 $L_k$ 和 $U_k$ 分别是 $L$ 和 $U$ 的 $k \\times k$ 顺序主子矩阵。矩阵乘法的结构意味着 $A_k = L_k U_k$。\n利用矩阵乘积的行列式等于行列式的乘积这一性质，我们有 $\\det(A_k) = \\det(L_k) \\det(U_k)$。\n三角矩阵的行列式是其对角线元素的乘积。\n对于单位上三角矩阵 $U_k$，其行列式为 $\\det(U_k) = u_{11} u_{22} \\cdots u_{kk} = 1^k = 1$。\n对于 $L_k$，其行列式为 $\\det(L_k) = \\ell_{11} \\ell_{22} \\cdots \\ell_{kk}$。\n因此，我们找到了关键关系：$\\det(A_k) = \\ell_{11} \\ell_{22} \\cdots \\ell_{kk}$。\n由此可得，对于 $k > 1$，有 $\\ell_{kk} = \\frac{\\det(A_k)}{\\det(A_{k-1})}$，且 $\\ell_{11} = \\det(A_1) = a_{11}$。\nLU 分解算法（无主元选择）顺序计算 $\\ell_{ij}$ 和 $u_{ij}$。为使算法可执行，我们必须能够解出每个未知数。这要求在每一步 $k$，对角线元素 $\\ell_{kk}$ 必须非零，因为它被用作除数来求解 $U$ 的第 $k$ 行的元素。\n对于所有 $k = 1, \\dots, n$，条件 $\\ell_{kk} \\neq 0$ 等价于条件 $\\det(A_k) \\neq 0$。\n因此，LU 分解（其中 $u_{ii}=1$ 且无主元选择）存在且唯一的充要条件是 $A$ 的所有顺序主子式均不为零。\n\n第三，我们计算 $A$ 的行列式。\n利用性质 $\\det(A) = \\det(L) \\det(U)$，我们可以很容易地从分解中求出行列式。\n$L$ 的行列式是其对角线元素的乘积：\n$$ \\det(L) = \\ell_{11} \\ell_{22} \\ell_{33} = (4)(-1)(4) = -16 $$\n$U$ 的行列式是其对角线元素的乘积：\n$$ \\det(U) = u_{11} u_{22} u_{33} = (1)(1)(1) = 1 $$\n因此，$A$ 的行列式是：\n$$ \\det(A) = \\det(L) \\det(U) = (-16)(1) = -16 $$\n这就提供了所要求的数值结果。", "answer": "$$\\boxed{-16}$$", "id": "3156996"}, {"introduction": "在掌握了 LU 分解的基本机理后，理解数值稳定性为何是计算中的核心议题至关重要。本练习通过一个编程实践，让你直接比较带部分主元选择的通用 LU 分解算法与一个省略了主元选择的专用算法（Thomas 算法）。通过在一些精心设计的“病态”矩阵上进行测试，你将亲眼见证微小的主元如何导致灾难性的误差，从而深刻体会主元策略的必要性。[@problem_id:3156918]", "problem": "您的任务是实现并比较两种求解三对角系数矩阵线性系统的基本方法，以计算矩阵的逆：带部分主元法的LU分解（Lower–Upper factorization）和托马斯算法。您的实现必须是一个完整的程序，该程序能为几个测试用例计算每种方法的量化误差度量，并报告一个单一的聚合结果行。\n\n背景和定义：\n- 令 $A \\in \\mathbb{R}^{n \\times n}$ 为一个非奇异三对角矩阵。对于多个右端项 $b$ 求解 $A x = b$，我们可以通过使用单位矩阵的各列作为右端项来求解，从而得到 $A^{-1}$。托马斯算法是高斯消元法针对三对角系统的一种特殊形式，它不执行主元选择。\n- 相比之下，带部分主元法（PP）的LU分解会计算一个置换矩阵 $P$、一个单位下三角矩阵 $L$ 和一个上三角矩阵 $U$，使得 $P A = L U$。为求解 $A x = b$，首先从 $L y = P b$ 计算 $y$，然后从 $U x = y$ 计算 $x$。\n- 矩阵 $M$ 的无穷范数，记为 $\\lVert M \\rVert_{\\infty}$，定义为最大绝对行和：$\\lVert M \\rVert_{\\infty} = \\max_{1 \\leq i \\leq n} \\sum_{j=1}^{n} |M_{i j}|$。\n- 带部分主元法的高斯消元的增长因子定义为 $\\rho = \\lVert U \\rVert_{\\infty} / \\lVert A \\rVert_{\\infty}$，它是一个与消元过程中误差传播相关的度量。\n\n基本原理：\n- 通过高斯消元法求解线性系统，是基于初等行变换等价于左乘以初等矩阵，以及将这些操作分解为 $P$、$L$ 和 $U$ 使得 $P A = L U$ 这一事实。前向代入和回代分别求解三角矩阵 $L$ 和 $U$ 的方程 $L y = c$ 和 $U x = y$。\n- 托马斯算法是通过将高斯消元法应用于三对角结构推导出来的，它执行前向消元以将次对角线元素清零，然后通过回代来恢复解；它放弃了主元选择，因此当主元数量级很小时可能会遇到问题。\n- 基于残差的误差评估使用恒等式 $A A^{-1} = I$；在有限精度下，可以通过计算残差 $R = A \\widetilde{A}^{-1} - I$ 及其无穷范数 $\\lVert R \\rVert_{\\infty}$ 来评估近似逆矩阵 $\\widetilde{A}^{-1}$。\n\n您的任务：\n1. 对于每个提供的测试矩阵，从其三对角分量（主对角线 $a$、上对角线 $b$、下对角线 $c$）构建稠密矩阵 $A$。\n2. 使用带部分主元法的LU分解计算近似逆矩阵 $\\widetilde{A}^{-1}_{\\mathrm{LU}}$，方法是针对单位矩阵 $I$ 的所有列求解 $A X = I$。\n3. 使用不带主元选择的托马斯算法计算近似逆矩阵 $\\widetilde{A}^{-1}_{\\mathrm{T}}$，同样通过求解 $A X = I$。\n4. 对每种方法，计算残差的无穷范数 $\\lVert A \\widetilde{A}^{-1} - I \\rVert_{\\infty}$，结果为一个标量浮点数。\n5. 对于带部分主元法的LU分解，计算：\n   - 增长因子 $\\rho = \\lVert U \\rVert_{\\infty} / \\lVert A \\rVert_{\\infty}$。\n   - 分解过程中执行的行交换总次数，结果为一个非负整数。\n6. 如果托马斯算法在前向消元或回代过程中遇到零主元，则视为该方法的求逆失败，并报告其残差为 $+\\infty$。否则，正常进行。\n\n测试套件：\n使用以下由其对角线指定的三对角矩阵：\n- 案例1（良态，对称正定）：\n  - 尺寸 $n = 5$\n  - 主对角线 $a = [2, 2, 2, 2, 2]$\n  - 上对角线 $b = [-1, -1, -1, -1]$\n  - 下对角线 $c = [-1, -1, -1, -1]$\n- 案例2（首个主元微小，体现主元选择的必要性）：\n  - 尺寸 $n = 5$\n  - 主对角线 $a = [10^{-12}, 2, 2, 2, 2]$\n  - 上对角线 $b = [1, 1, 1, 1]$\n  - 下对角线 $c = [1, 1, 1, 1]$\n- 案例3（内部主元微小，且有更大的次对角线元素以触发主元选择）：\n  - 尺寸 $n = 8$\n  - 主对角线 $a = [2, 2, 10^{-10}, 2, 2, 2, 2, 2]$\n  - 上对角线 $b = [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]$\n  - 下对角线 $c = [0.5, 0.5, 3.0, 0.5, 0.5, 0.5, 0.5]$\n\n输出规范：\n- 对于每个案例，按此确切顺序计算并记录四个值：\n  1. $r_{\\mathrm{LU}} = \\lVert A \\widetilde{A}^{-1}_{\\mathrm{LU}} - I \\rVert_{\\infty}$（浮点数）。\n  2. $r_{\\mathrm{T}} = \\lVert A \\widetilde{A}^{-1}_{\\mathrm{T}} - I \\rVert_{\\infty}$（浮点数，或在失败时为 $+\\infty$）。\n  3. $\\rho$（浮点数，LU增长因子）。\n  4. $s$（整数，LU分解中的行交换次数）。\n- 您的程序应生成单行输出，其中包含所有三个案例的结果，形式为一个包含十二个值的扁平列表，按案例顺序排列，并用逗号分隔，并用方括号括起来。例如：\"[rLU1,rT1,rho1,s1,rLU2,rT2,rho2,s2,rLU3,rT3,rho3,s3]\"。\n- 所有数字都是无量纲的；不涉及物理单位。\n\n约束和期望：\n- 您必须基于基本原理实现带部分主元法的LU分解以及前向/回代过程。您必须实现不带主元选择的托马斯算法，并按所述检测零主元。\n- 对所有矩阵范数，请使用上面定义的 $\\lVert \\cdot \\rVert_{\\infty}$。\n- 确保科学真实性和数值合理性；这些矩阵是非奇异的，且在给定规则下度量标准是明确定义的。", "solution": "用户的要求是实现并比较两种求解三对角线性系统的方法：带部分主元法的LU分解和托马斯算法。通过使用它们计算矩阵的逆并评估其数值稳定性。该问题定义清晰，科学上合理，并为完整解决方案提供了所有必要信息。\n\n解决方案将按以下结构组织：\n1.  实现辅助函数，用于构建测试矩阵和计算所需的矩阵无穷范数。\n2.  实现带部分主元法的LU分解（`lu_factor_pivoting`）和相应的求解器（`solve_lu`），该求解器使用前向代入和回代。\n3.  实现托马斯算法（`thomas_algorithm`），这是一种专门用于三对角系统的非主元求解器，包括零主元的检测。\n4.  一个主程序，遍历每个测试案例。对于每个案例，它将：\n    a. 构建稠密矩阵 $A$。\n    b. 通过重复调用LU求解器并以单位矩阵的各列作为右端项，计算逆矩阵 $\\widetilde{A}^{-1}_{\\mathrm{LU}}$。\n    c. 通过重复调用托马斯算法求解器，计算逆矩阵 $\\widetilde{A}^{-1}_{\\mathrm{T}}$。\n    d. 计算指定的度量指标：残差范数（$r_{\\mathrm{LU}}$, $r_{\\mathrm{T}}$）、增长因子（$\\rho$）和交换次数（$s$）。\n5.  最终结果被汇总并按指定格式格式化为单个字符串。\n\n**1. 辅助函数**\n\n将创建一个函数 `build_matrix`，用于从主对角线（$a$，长度为$n$）、上对角线（$b$，长度为$n-1$）和下对角线（$c$，长度为$n-1$）构建完整的稠密矩阵 $A \\in \\mathbb{R}^{n \\times n}$。\n\n一个函数 `infinity_norm` 将实现矩阵无穷范数 $\\lVert M \\rVert_{\\infty} = \\max_{i} \\sum_{j} |M_{ij}|$，即最大绝对行和。此函数将用于计算残差范数和增长因子。\n\n**2. 带部分主元法的LU分解**\n\n此方法的核心是一个函数 `lu_factor_pivoting`，它计算分解 $PA = LU$。\n-   输入：一个方阵 $A$。\n-   输出：一个单位下三角矩阵 $L$、一个上三角矩阵 $U$、一个置换矩阵 $P$ 和整数表示的行交换次数。\n\n该算法从 $k=0$ 到 $n-2$ 逐列进行：\n-   **主元选择**：对于第 $k$ 列，它在对角线或其下方（即对于 $i \\ge k$ 的 $A_{i,k}$）识别出绝对值最大的元素。假设它在第 $p$ 行。如果 $p \\neq k$，则执行第 $k$ 行和第 $p$ 行的行交换。此交换记录在置换矩阵 $P$ 中，并且交换计数器递增。为了保持 $L$ 的结构，在 $L$ 中已经计算过的第 $k$ 行和第 $p$ 行的部分也需要交换。\n-   **消元**：主元选择后，对于当前行 $k$下方的每一行 $j$（即 $j > k$），计算乘数 $L_{jk} = U_{jk} / U_{kk}$，并通过减去 $L_{jk}$ 乘以第 $k$ 行来更新 $U$ 的第 $j$ 行：$U_{j,:} \\leftarrow U_{j,:} - L_{jk} U_{k,:}$。\n\n第二个函数 `solve_lu` 使用此分解来求解 $Ax=b$。从 $PA=LU$，我们得到 $LUx = Pb$。这分两步解决：\n1.  **前向代入**：求解 $Ly=Pb$ 以获得中间向量 $y$。由于 $L$ 是单位下三角矩阵，这个过程是高效的：$y_i = (Pb)_i - \\sum_{j=0}^{i-1} L_{ij} y_j$。\n2.  **回代**：求解 $Ux=y$ 以获得最终解 $x$。由于 $U$ 是上三角矩阵，这个过程也是高效的：$x_i = (y_i - \\sum_{j=i+1}^{n-1} U_{ij} x_j) / U_{ii}$。\n\n为了计算逆矩阵 $\\widetilde{A}^{-1}_{\\mathrm{LU}}$，我们对单位矩阵 $I$ 的每一列 $e_j$ 求解 $Ax_j = e_j$。得到的解向量 $x_j$ 构成了 $\\widetilde{A}^{-1}_{\\mathrm{LU}}$ 的各列。\n\n**3. 托马斯算法**\n\n托马斯算法是高斯消元法针对三对角系统的简化形式。实现函数 `thomas_algorithm` 接受三个对角线 $a, b, c$ 和一个右端向量 $d$ 作为输入。\n-   **前向消元**：它从第二行（$i=1$）迭代到最后一行，消去次对角线元素 $c_{i-1}$。这是通过计算一个乘数 $m = c_{i-1} / a'_{i-1}$ 并更新主对角线项 $a'_i \\leftarrow a_i - m \\cdot b_{i-1}$ 和右端项 $d'_i \\leftarrow d_i - m \\cdot d'_{i-1}$ 来完成的。在每一步，都会检查以确保主元 $a'_{i-1}$ 非零。如果遇到零主元，算法失败。\n-   **回代**：前向扫描后，系统变为上双对角。通过从最后一个未知数 $x_{n-1}$ 向后迭代到第一个来找到解。$x_{n-1} = d'_{n-1} / a'_{n-1}$。然后，对于从 $n-2$ 到 $0$ 的 $i$，$x_i = (d'_i - b_i x_{i+1}) / a'_i$。同样，每个用于除法的对角元素 $a'_i$ 都会被检查是否为零。\n\n如果在任何阶段发现零主元，该函数将返回一个失败信号。否则，它返回解向量 $x$。逆矩阵 $\\widetilde{A}^{-1}_{\\mathrm{T}}$ 的计算方式与LU方法类似，也是逐列进行的。如果任何一列的求解失败，则整个逆矩阵计算被视为失败，并且残差范数 $r_{\\mathrm{T}}$ 报告为 $+\\infty$。\n\n**4. 度量和执行**\n\n主程序定义了三个测试案例。对于每个案例：\n1.  构建稠密矩阵 $A$。计算无穷范数 $\\lVert A \\rVert_{\\infty}$。\n2.  计算 $A$ 的LU分解。使用得到的 $U$ 矩阵计算增长因子 $\\rho = \\lVert U \\rVert_{\\infty} / \\lVert A \\rVert_{\\infty}$。记录交换次数 $s$。\n3.  使用LU求解器计算逆矩阵 $\\widetilde{A}^{-1}_{\\mathrm{LU}}$。形成残差 $R_{\\mathrm{LU}} = A \\widetilde{A}^{-1}_{\\mathrm{LU}} - I$，并计算其无穷范数 $r_{\\mathrm{LU}} = \\lVert R_{\\mathrm{LU}} \\rVert_{\\infty}$。\n4.  使用托马斯算法计算逆矩阵 $\\widetilde{A}^{-1}_{\\mathrm{T}}$。如果成功，则计算残差 $R_{\\mathrm{T}} = A \\widetilde{A}^{-1}_{\\mathrm{T}} - I$ 及其范数 $r_{\\mathrm{T}} = \\lVert R_{\\mathrm{T}} \\rVert_{\\infty}$。如果托马斯算法失败，则将 $r_{\\mathrm{T}}$ 设置为 `inf`。\n5.  收集得到的四个值（$r_{\\mathrm{LU}}, r_{\\mathrm{T}}, \\rho, s$）。\n\n处理完所有案例后，将结果列表扁平化并以所需格式打印。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    def build_matrix(n, a, b, c):\n        \"\"\"Constructs a dense matrix from tridiagonal components.\"\"\"\n        mat = np.zeros((n, n), dtype=float)\n        mat += np.diag(a)\n        mat += np.diag(b, k=1)\n        mat += np.diag(c, k=-1)\n        return mat\n\n    def infinity_norm(M):\n        \"\"\"Computes the infinity norm of a matrix M.\"\"\"\n        return np.max(np.sum(np.abs(M), axis=1))\n\n    def lu_factor_pivoting(A_in):\n        \"\"\"\n        Performs LU factorization with partial pivoting: PA = LU.\n        \n        Args:\n            A_in (np.ndarray): The matrix to factorize.\n\n        Returns:\n            tuple: A tuple containing:\n                L (np.ndarray): Unit lower triangular matrix.\n                U (np.ndarray): Upper triangular matrix.\n                P (np.ndarray): Permutation matrix.\n                swaps (int): Number of row swaps.\n        \"\"\"\n        n = A_in.shape[0]\n        U = A_in.copy().astype(float)\n        L = np.eye(n, dtype=float)\n        P = np.eye(n, dtype=float)\n        swaps = 0\n        \n        for k in range(n - 1):\n            # Find pivot row\n            pivot_row = np.argmax(np.abs(U[k:, k])) + k\n            \n            if np.abs(U[pivot_row, k])  1e-15:\n                # In the context of this problem, non-singular matrices are assumed, \n                # but this is a safeguard.\n                raise ValueError(\"Matrix is singular or near-singular.\")\n\n            if pivot_row != k:\n                # Swap rows in U\n                U[[k, pivot_row], k:] = U[[pivot_row, k], k:]\n                # Swap rows in P\n                P[[k, pivot_row], :] = P[[pivot_row, k], :]\n                # Swap the computed part of L\n                L[[k, pivot_row], :k] = L[[pivot_row, k], :k]\n                swaps += 1\n\n            # Elimination\n            for j in range(k + 1, n):\n                L[j, k] = U[j, k] / U[k, k]\n                U[j, k:] -= L[j, k] * U[k, k:]\n        \n        # Zero out the lower triangle of U for a clean upper triangular matrix\n        U = np.triu(U)\n        return L, U, P, swaps\n\n    def solve_lu(L, U, P, b):\n        \"\"\"\n        Solves Ax=b using a pre-computed LUP factorization.\n        \"\"\"\n        n = L.shape[0]\n        # Step 1: Solve Ly = Pb for y (Forward substitution)\n        Pb = P @ b\n        y = np.zeros(n, dtype=float)\n        for i in range(n):\n            y[i] = Pb[i] - np.dot(L[i, :i], y[:i])\n        \n        # Step 2: Solve Ux = y for x (Backward substitution)\n        x = np.zeros(n, dtype=float)\n        for i in range(n - 1, -1, -1):\n            if np.abs(U[i, i])  1e-15:\n                raise ValueError(\"Matrix is singular.\")\n            x[i] = (y[i] - np.dot(U[i, i+1:], x[i+1:])) / U[i, i]\n        return x\n\n    def thomas_algorithm(a_diag, b_diag, c_diag, d_vec):\n        \"\"\"\n        Solves a tridiagonal system Ax=d using the Thomas algorithm.\n        Returns the solution vector x, or None on failure (zero pivot).\n        \"\"\"\n        n = len(a_diag)\n        a_prime = np.copy(a_diag).astype(float)\n        d_prime = np.copy(d_vec).astype(float)\n        \n        # Forward elimination\n        for i in range(1, n):\n            if np.abs(a_prime[i-1])  1e-15:\n                return None  # Zero pivot failure\n            m = c_diag[i-1] / a_prime[i-1]\n            a_prime[i] -= m * b_diag[i-1]\n            d_prime[i] -= m * d_prime[i-1]\n        \n        # Backward substitution\n        if np.abs(a_prime[n-1])  1e-15:\n            return None # Zero pivot failure\n        \n        x = np.zeros(n, dtype=float)\n        x[n-1] = d_prime[n-1] / a_prime[n-1]\n        for i in range(n - 2, -1, -1):\n            if np.abs(a_prime[i])  1e-15:\n                return None # Zero pivot failure\n            x[i] = (d_prime[i] - b_diag[i] * x[i+1]) / a_prime[i]\n            \n        return x\n\n    test_cases = [\n        {\n            \"n\": 5,\n            \"a\": np.array([2, 2, 2, 2, 2]),\n            \"b\": np.array([-1, -1, -1, -1]),\n            \"c\": np.array([-1, -1, -1, -1]),\n        },\n        {\n            \"n\": 5,\n            \"a\": np.array([1e-12, 2, 2, 2, 2]),\n            \"b\": np.array([1, 1, 1, 1]),\n            \"c\": np.array([1, 1, 1, 1]),\n        },\n        {\n            \"n\": 8,\n            \"a\": np.array([2, 2, 1e-10, 2, 2, 2, 2, 2]),\n            \"b\": np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]),\n            \"c\": np.array([0.5, 0.5, 3.0, 0.5, 0.5, 0.5, 0.5]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        a, b, c = case[\"a\"], case[\"b\"], case[\"c\"]\n        \n        A = build_matrix(n, a, b, c)\n        I = np.eye(n)\n\n        # --- 1. LU with Partial Pivoting ---\n        L, U, P, s = lu_factor_pivoting(A)\n        \n        A_inv_lu = np.zeros_like(A)\n        for j in range(n):\n            A_inv_lu[:, j] = solve_lu(L, U, P, I[:, j])\n            \n        R_lu = A @ A_inv_lu - I\n        r_lu = infinity_norm(R_lu)\n        \n        rho = infinity_norm(U) / infinity_norm(A)\n\n        # --- 2. Thomas Algorithm ---\n        A_inv_t = np.zeros_like(A)\n        thomas_failed = False\n        for j in range(n):\n            col = thomas_algorithm(a, b, c, I[:, j])\n            if col is None:\n                thomas_failed = True\n                break\n            A_inv_t[:, j] = col\n        \n        if thomas_failed:\n            r_t = np.inf\n        else:\n            R_t = A @ A_inv_t - I\n            r_t = infinity_norm(R_t)\n            \n        results.extend([r_lu, r_t, rho, s])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3156918"}, {"introduction": "虽然主元选择对于通用矩阵是必不可少的，但它并非总是必需的，且会引入额外的计算开销。这项练习将探索一类重要的矩阵——严格对角占优矩阵，对于这类矩阵，我们可以从数学上证明，不带主元选择的 LU 分解是数值稳定的。这个练习将理论与计算相结合，要求你首先证明该稳定性，然后通过数值实验来验证这一理论保证，加深对数值稳定性的理解。[@problem_id:3156903]", "problem": "要求您构造一个具体的方阵序列，并根据第一性原理推断不带主元的高斯消去法的存在性、唯一性和数值稳定性。然后，您将实现一个算法，在受控的随机扰动下对稳定性进行数值量化。所有数学符号、变量、运算符甚至数字都必须使用 LaTeX 分隔符书写。\n\n任务 A (构造)。对于每个正整数 $n \\in \\{5,20,50\\}$，定义一个矩阵 $A_n \\in \\mathbb{R}^{n \\times n}$ 如下：\n$$\n(A_n)_{ij} =\n\\begin{cases}\n3,  \\text{if } i=j, \\\\\n-1,  \\text{if } |i-j|=1, \\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n仅从核心定义和公认事实出发，证明每个 $A_n$ 都是行严格对角占优的并且是非奇异的。然后，对于矩阵类 $\\{A_n\\}$，论证不带主元的高斯消去法对每个 $n$ 都能产生一个 $L U$ 分解，并且消去过程是稳定的，即元素增长因子受一个与 $n$ 无关的适中常数限制。\n\n任务 B (从第一性原理推导稳定性)。仅以核心定义和公认事实为基础：\n1) 从行严格对角占优的定义开始：一个矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是行严格对角占优的，如果对于每个 $i \\in \\{1,\\dots,n\\}$，\n$$\n|a_{ii}| \\;\\; \\sum_{j \\neq i} |a_{ij}|.\n$$\n2) 使用一个公认事实来证明 $A_n$ 的非奇异性，例如 Gershgorin 圆盘定理或 Levy–Desplanques 定理，这两个定理都表明行严格对角占优保证了非奇异性。\n3) 考虑不带主元的高斯消去法的基本步骤。设 $A^{(k)}$ 是经过 $k-1$ 步消去后的矩阵，主元为 $a^{(k)}_{kk} \\neq 0$，乘数为 $m_{ik} = a^{(k)}_{ik}/a^{(k)}_{kk}$ (对于 $ik$)。Schur 补的更新公式为\n$$\na^{(k+1)}_{ij} \\;=\\; a^{(k)}_{ij} \\;-\\; m_{ik}\\, a^{(k)}_{kj}, \\quad \\text{for } i,j  k.\n$$\n从这些关系和 $A^{(k)}$ 的行严格对角占优特性，推导出 $|m_{ik}|  1$ 并且严格对角占优性在尾随子矩阵中得以保持。通过归纳法得出结论：不会出现零主元，且 $A_n$ 存在不带主元的 $L U$ 分解。\n4) 定义元素增长因子\n$$\n\\gamma \\;=\\; \\frac{\\max_{i,j} |u_{ij}|}{\\max_{i,j} |a_{ij}|},\n$$\n其中 $U$ 是不带主元的消去法产生的上三角因子。利用由严格对角占优性得到的乘数界 $|m_{ik}|1$，将 $\\gamma$ 界定在一个适中的常数内（例如，证明对于这类矩阵，$\\gamma \\leq 2$，不考虑有限精度算术中的舍入效应）。\n\n任务 C (随机扰动下的数值实验)。对于每个 $n \\in \\{5,20,50\\}$ 和每个扰动水平 $\\varepsilon \\in \\{10^{-12},10^{-8},10^{-6}\\}$，执行以下操作：\n1) 如任务 A 中那样构造 $A_n$。\n2) 构造一个随机扰动 $E \\in \\mathbb{R}^{n \\times n}$，其元素从标准正态分布中抽取，并缩放 $E$ 使其谱范数满足\n$$\n\\|E\\|_2 \\;=\\; \\varepsilon \\, \\|A_n\\|_2.\n$$\n3) 构成扰动矩阵 $\\widetilde{A} = A_n + E$。生成一个随机的右端项 $b \\in \\mathbb{R}^n$，其元素是独立的标准正态分布。\n4) 计算 $\\widetilde{A}$ 的不带主元的 $L U$ 分解（自己实现高斯消去法；不要调用任何执行主元选择的库例程），并求解 $\\widetilde{A} x = b$。\n5) 计算元素增长因子\n$$\n\\gamma \\;=\\; \\frac{\\max_{i,j} |U_{ij}|}{\\max_{i,j} |\\widetilde{A}_{ij}|}.\n$$\n6) 计算相对于未扰动矩阵 $A_n$ 的缩放后向残差，\n$$\n\\eta \\;=\\; \\frac{\\|A_n x - b\\|_2}{\\|A_n\\|_2 \\, \\|x\\|_2 + \\|b\\|_2}.\n$$\n7) 对于每个测试用例，如果以下两个条件都成立，则认为消去过程是数值稳定的：\n   a) $\\gamma \\leq 2.1$,\n   b) $\\eta \\leq 1.5 \\, \\varepsilon$.\n\n测试套件和输出。使用给定的测试用例 $(n,\\varepsilon,\\text{seed})$：\n$$\n(5,10^{-12},0), \\quad (5,10^{-8},1), \\quad (5,10^{-6},2), \\quad (20,10^{-12},3), \\quad (20,10^{-8},4), \\quad (20,10^{-6},5), \\quad (50,10^{-12},6), \\quad (50,10^{-8},7), \\quad (50,10^{-6},8).\n$$\n对于每个三元组，在创建 $E$ 和 $b$ 之前，使用给定的整数种子设置伪随机数生成器。您的程序必须生成单行输出，包含九个布尔值结果，按所列顺序每个测试用例一个，其中每个布尔值表示该用例是否通过了步骤 7 中的两个稳定性检查。要求的格式是用方括号括起来的逗号分隔列表，例如 $[{\\tt True},{\\tt False},\\dots]$。不应打印任何其他文本。", "solution": "在提供解决方案之前，需对问题进行验证。\n\n### 步骤 1：提取已知条件\n- **矩阵定义**：对于每个正整数 $n \\in \\{5, 20, 50\\}$，矩阵 $A_n \\in \\mathbb{R}^{n \\times n}$ 定义为\n$$\n(A_n)_{ij} =\n\\begin{cases}\n3,  \\text{if } i=j, \\\\\n-1,  \\text{if } |i-j|=1, \\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n- **严格对角占优 (SDD) 定义**：一个矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是行严格对角占优的，如果对于每个 $i \\in \\{1, \\dots, n\\}$，满足 $|a_{ii}|  \\sum_{j \\neq i} |a_{ij}|$。\n- **高斯消去步骤**：Schur 补更新为 $a^{(k+1)}_{ij} = a^{(k)}_{ij} - m_{ik} a^{(k)}_{kj}$ (对于 $i,j  k$)，其中 $m_{ik} = a^{(k)}_{ik}/a^{(k)}_{kk}$。\n- **增长因子定义**：$\\gamma = \\frac{\\max_{i,j} |u_{ij}|}{\\max_{i,j} |a_{ij}|}$。\n- **扰动缩放**：对于一个随机扰动矩阵 $E$，其谱范数被缩放以满足 $\\|E\\|_2 = \\varepsilon \\|A_n\\|_2$。\n- **缩放后向残差**：$\\eta = \\frac{\\|A_n x - b\\|_2}{\\|A_n\\|_2 \\|x\\|_2 + \\|b\\|_2}$。\n- **数值稳定性条件**：\n  1. 增长因子 $\\gamma \\leq 2.1$。\n  2. 缩放后向残差 $\\eta \\leq 1.5 \\varepsilon$。\n- **测试套件**：一个包含 $9$ 个元组 $(n, \\varepsilon, \\text{seed})$ 的列表：$(5, 10^{-12}, 0)$, $(5, 10^{-8}, 1)$, $(5, 10^{-6}, 2)$, $(20, 10^{-12}, 3)$, $(20, 10^{-8}, 4)$, $(20, 10^{-6}, 5)$, $(50, 10^{-12}, 6)$, $(50, 10^{-8}, 7)$, $(50, 10^{-6}, 8)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题牢固地植根于数值线性代数的原理。它涉及标准定义和概念，如 LU 分解、高斯消去法、严格对角占优、Gershgorin 圆盘定理、元素增长因子和后向误差分析。所有这些概念都是计算科学的基石。矩阵 $A_n$ 是一个著名的对称三对角矩阵，常用作模型问题（例如，来自一维泊松方程的离散化）。\n2.  **适定性**：理论任务（A 和 B）是针对一类特定、明确定义的矩阵的标准证明。数值任务（C）是一个完全指定的计算实验。所有参数（$n$、$\\varepsilon$）、初始条件（随机种子）和评估指标（$\\gamma$、$\\eta$ 及其阈值）都已明确提供，确保可以获得唯一、确定且有意义的解。\n3.  **客观性**：问题以精确、形式化的数学语言陈述，没有任何主观性或歧义。\n\n问题陈述没有缺陷。它科学合理、适定、客观、完整，并与指定主题相关。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整解决方案。\n\n---\n\n### 任务 A 和 B：理论分析\n\n这里我们将任务 A 和 B 中要求的证明合并，因为它们在逻辑上是连续的。我们首先按照规定定义矩阵 $A_n$（对于 $n \\in \\mathbb{Z}^+$）：\n$$\n(A_n)_{ij} =\n\\begin{cases}\n3,  \\text{if } i=j, \\\\\n-1,  \\text{if } |i-j|=1, \\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n这是一个对称三对角矩阵。\n\n**$A_n$ 的严格对角占优性**\n\n如果一个矩阵 $A$ 的每一行 $i$，对角元素的绝对值都严格大于该行所有其他元素的绝对值之和，即 $|a_{ii}|  \\sum_{j \\neq i} |a_{ij}|$，则称该矩阵为行严格对角占优 (SDD)。我们来验证 $A_n$ 是否满足此条件。\n\n- 对于第一行 ($i=1$)，对角元素是 $(A_n)_{11} = 3$。唯一的非零非对角元素是 $(A_n)_{12} = -1$。非对角元素的绝对值之和为 $\\sum_{j \\neq 1} |(A_n)_{1j}| = |(A_n)_{12}| = |-1| = 1$。我们必须检查是否 $|(A_n)_{11}|  1$。由于 $|3| = 3  1$，该条件对 $i=1$ 成立。\n- 对于最后一行 ($i=n$)，对角元素是 $(A_n)_{nn} = 3$。唯一的非零非对角元素是 $(A_n)_{n,n-1} = -1$。其和为 $\\sum_{j \\neq n} |(A_n)_{nj}| = |(A_n)_{n,n-1}| = |-1| = 1$。我们检查是否 $|(A_n)_{nn}|  1$。由于 $|3| = 3  1$，该条件对 $i=n$ 成立。\n- 对于任意内部行 ($1  i  n$)，对角元素是 $(A_n)_{ii} = 3$。非零的非对角元素是 $(A_n)_{i,i-1} = -1$ 和 $(A_n)_{i,i+1} = -1$。绝对值之和为 $\\sum_{j \\neq i} |(A_n)_{ij}| = |(A_n)_{i,i-1}| + |(A_n)_{i,i+1}| = |-1| + |-1| = 2$。我们检查是否 $|(A_n)_{ii}|  2$。由于 $|3| = 3  2$，该条件成立。\n\n由于该条件对所有行 $i \\in \\{1, \\dots, n\\}$ 都成立，因此对于任何 $n \\ge 2$，矩阵 $A_n$ 都是行严格对角占优的。\n\n**$A_n$ 的非奇异性**\n\nLevy–Desplanques 定理指出，任何行严格对角占优的矩阵都是非奇异的。由于我们已经证明对于任何 $n \\ge 2$，$A_n$ 都是 SDD 的，因此直接根据该定理可得 $A_n$ 是非奇异的。这也适用于 $n=1$ 的情况，此时 $A_1 = [3]$ 显然是非奇异的。\n\n**不带主元的 LU 分解的存在性**\n\n不带主元的高斯消去法能够成功当且仅当矩阵的所有顺序主子矩阵都是非奇异的。令 $A_k$ 表示 $A_n$ 的 $k \\times k$ 顺序主子矩阵。$A_k$ 是由 $A_n$ 的前 $k$ 行和前 $k$ 列构成的。$A_k$ 的结构与我们定义的矩阵 $A_n$ 相同，只是大小为 $k \\times k$。如上所示，任何这样的矩阵 $A_k$ (对于 $k \\ge 1$) 都是严格对角占优的，因此是非奇异的。由于 $A_n$ 的所有顺序主子矩阵都是非奇异的，因此可以对 $A_n$ 执行不带主元的高斯消去法，从而产生 $LU$ 分解。\n\n**严格对角占优性的保持与乘数的有界性**\n\n我们通过归纳法证明，消去过程中生成的 Schur 补仍然是 SDD 的。设 $A^{(1)} = A_n$。在消去的第 $k$ 步，我们有矩阵 $A^{(k)}$。假设 $A^{(k)}$ 的大小为 $(n-k+1) \\times (n-k+1)$ 的尾随子矩阵是 SDD 的。我们称这个子矩阵为 $S^{(k)}$。主元是 $a_{kk}^{(k)}$。乘数是 $m_{ik} = a_{ik}^{(k)}/a_{kk}^{(k)}$ (对于 $i  k$)。下一个 Schur 补 $S^{(k+1)}$ 的元素由 $a_{ij}^{(k+1)} = a_{ij}^{(k)} - m_{ik}a_{kj}^{(k)}$ 给出 (对于 $i,j  k$)。\n\n对于 $S^{(k+1)}$ 中的任意行 $i  k$，新的对角元素是 $a_{ii}^{(k+1)}$，非对角元素绝对值之和为 $\\sum_{jk, j \\neq i} |a_{ij}^{(k+1)}|$。我们有：\n$$ |a_{ii}^{(k+1)}| = |a_{ii}^{(k)} - m_{ik}a_{ki}^{(k)}| \\ge |a_{ii}^{(k)}| - |m_{ik}||a_{ki}^{(k)}| $$\n$$ \\sum_{jk, j \\neq i} |a_{ij}^{(k+1)}| = \\sum_{jk, j \\neq i} |a_{ij}^{(k)} - m_{ik}a_{kj}^{(k)}| \\le \\sum_{jk, j \\neq i} |a_{ij}^{(k)}| + |m_{ik}|\\sum_{jk, j \\neq i} |a_{kj}^{(k)}| $$\n由于 $S^{(k)}$ 是 SDD 的，我们有 $|a_{ii}^{(k)}|  \\sum_{j \\ge k, j \\neq i} |a_{ij}^{(k)}|$ 和 $|a_{kk}^{(k)}|  \\sum_{j  k} |a_{kj}^{(k)}|$。\n证明 $|a_{ii}^{(k+1)}|  \\sum_{jk, j \\neq i} |a_{ij}^{(k+1)}|$ 依赖于证明\n$|a_{ii}^{(k)}| - |m_{ik}||a_{ki}^{(k)}|  \\sum_{jk, j \\neq i} |a_{ij}^{(k)}| + |m_{ik}|\\sum_{jk, j \\neq i} |a_{kj}^{(k)}|$。\n代入 SDD 性质 $|a_{ii}^{(k)}|  |a_{ik}^{(k)}| + \\sum_{jk, j \\neq i} |a_{ij}^{(k)}|$，这等价于证明：\n$|a_{ik}^{(k)}| - |m_{ik}||a_{ki}^{(k)}|  |m_{ik}|\\sum_{jk, j \\neq i} |a_{kj}^{(k)}|$，这可以简化为 $|a_{kk}^{(k)}|  \\sum_{jk} |a_{kj}^{(k)}|$，即主元行的 SDD 性质。因此，SDD 在所有 Schur 补中得以保持。\n\n对于特定的矩阵 $A_n$，其结构简化了分析。在步骤 $k$，活动子矩阵是三对角的。在第 $k$ 列对角线下方唯一的非零元素是 $a_{k+1,k}^{(k)}=-1$。所有其他 $a_{ik}^{(k)}=0$ (对于 $i  k+1$)。因此，唯一的非零乘数是 $m_{k+1,k} = a_{k+1,k}^{(k)}/a_{kk}^{(k)} = -1/a_{kk}^{(k)}$。\n主元 $d_k = a_{kk}^{(k)}$ 遵循一个递推关系。\n$d_1 = (A_n)_{11} = 3$。\n在步骤 1，更新只影响第 2 行：$a_{2j}^{(2)} = a_{2j}^{(1)} - m_{21}a_{1j}^{(1)}$。\n$d_2 = a_{22}^{(2)} = a_{22}^{(1)} - m_{21}a_{12}^{(1)} = 3 - (-1/3)(-1) = 3 - 1/3 = 8/3$。\n新的非对角元素是 $a_{23}^{(2)} = a_{23}^{(1)} - m_{21}a_{13}^{(1)} = -1 - (-1/3)(0) = -1$。\n这个过程继续下去，在步骤 $k$，主元是 $d_k = a_{kk}^{(k)}$，非对角元素是 $a_{k,k+1}^{(k)}=-1$。下一个主元是 $d_{k+1} = a_{k+1,k+1}^{(k+1)} = a_{k+1,k+1}^{(k)} - m_{k+1,k}a_{k,k+1}^{(k)} = 3 - (-1/d_k)(-1) = 3 - 1/d_k$。\n主元序列为 $d_1=3$，$d_2=8/3 \\approx 2.667$，$d_3=3-3/8=21/8=2.625$。该序列单调递减，并收敛于 $d=3-1/d$ 的较大根，即 $d=(3+\\sqrt{5})/2 \\approx 2.618$。\n因此，对于所有 $k$，我们有 $(3+\\sqrt{5})/2 \\le d_k \\le 3$。\n唯一非零的乘数是 $m_{k+1,k} = -1/d_k$。它们的绝对值为 $|m_{k+1,k}| = 1/d_k \\le 1/((3+\\sqrt{5})/2) = 2/(3+\\sqrt{5}) = (3-\\sqrt{5})/2 \\approx 0.382  1$。\n这证明了所有乘数的绝对值都受一个严格小于 1 的常数限制。\n\n**元素增长因子的界**\n\n增长因子为 $\\gamma = \\max_{i,j} |u_{ij}| / \\max_{i,j} |a_{ij}|$。对于 $A_n$，$\\max_{i,j} |(A_n)_{ij}| = 3$。\n消去法产生的矩阵 $U$ 的元素为 $u_{ij} = a_{ij}^{(i)}$。\n对角元素是主元，$u_{ii} = d_i$。我们发现 $(3+\\sqrt{5})/2 \\le d_i \\le 3$。\n非对角元素是 $u_{ij}$ (对于 $ji$)。唯一非零的非对角元素位于第一超对角线上。我们来追踪它们的值。在步骤 $k$，$u_{k,k+1} = a_{k,k+1}^{(k)}$。\n对于 $k=1$，$u_{12}=a_{12}^{(1)}=-1$。\n对于 $k=2$，$u_{23}=a_{23}^{(2)} = a_{23}^{(1)} - m_{21}a_{13}^{(1)} = -1 - (-1/3)(0) = -1$。\n通过归纳法可以看出，对于这种三对角矩阵，消去过程不会改变超对角线上的元素：$u_{i,i+1} = -1$ (对于所有 $i$)。\n矩阵 $U$ 是一个上双对角矩阵：\n$$\nU =\n\\begin{pmatrix}\nd_1  -1  0  \\dots \\\\\n0  d_2  -1  \\\\\n\\vdots   \\ddots  \\ddots \\\\\n   d_{n-1}  -1 \\\\\n0  \\dots   0  d_n\n\\end{pmatrix}\n$$\n$U$ 的元素是主元 $d_i \\in [(3+\\sqrt{5})/2, 3]$ 和 $-1$。\n因此，$\\max_{i,j} |u_{ij}| = \\max(d_1, |-1|) = \\max(3,1) = 3$。\n增长因子为 $\\gamma = \\frac{\\max_{i,j} |u_{ij}|}{\\max_{i,j} |(A_n)_{ij}|} = \\frac{3}{3} = 1$。\n这是一个非常稳定的情况。问题中要求的界 $\\gamma \\le 2$ 显然是满足的，因为 $\\gamma=1$。对于扰动矩阵 $\\widetilde{A}$，增长因子预计也接近 1。\n\n### 任务 C：数值实验设计\n\n对于每个测试用例 $(n, \\varepsilon, \\text{seed})$，实现将遵循以下步骤：\n1.  为保证可复现性，设置随机种子。\n2.  构造矩阵 $A_n \\in \\mathbb{R}^{n \\times n}$。\n3.  生成一个随机矩阵 $E \\in \\mathbb{R}^{n \\times n}$，其元素来自 $\\mathcal{N}(0,1)$。\n4.  计算谱范数 $\\|A_n\\|_2$ 和 $\\|E\\|_2$。缩放 $E$ 得到 $E' = E \\cdot (\\varepsilon \\|A_n\\|_2 / \\|E\\|_2)$。\n5.  构成扰动矩阵 $\\widetilde{A} = A_n + E'$。\n6.  生成一个随机右端向量 $b \\in \\mathbb{R}^n$，其元素来自 $\\mathcal{N}(0,1)$。\n7.  实现一个自定义函数 `lu_no_pivot` 来计算 $\\widetilde{A}$ 的不带主元的 $LU$ 分解，得到矩阵 $L$ 和 $U$。\n8.  实现用于前向替换（`forward_subst` 求解 $Ly=b$）和后向替换（`backward_subst` 求解 $Ux=y$）的自定义函数，以找到解 $x$。\n9.  计算增长因子 $\\gamma = \\max_{i,j} |U_{ij}| / \\max_{i,j} |\\widetilde{A}_{ij}|$。\n10. 计算缩放后向残差 $\\eta = \\|A_n x - b\\|_2 / (\\|A_n\\|_2 \\|x\\|_2 + \\|b\\|_2)$。\n11. 检查是否同时满足 $\\gamma \\le 2.1$ 和 $\\eta \\le 1.5\\varepsilon$。存储布尔结果。\n12. 在所有测试用例结束后，打印布尔结果列表。", "answer": "```python\nimport numpy as np\n\ndef lu_no_pivot(A):\n    \"\"\"\n    Computes the LU factorization of a square matrix A without pivoting.\n    \n    Args:\n        A (np.ndarray): The input square matrix.\n        \n    Returns:\n        (np.ndarray, np.ndarray): A tuple containing the lower triangular\n                                  matrix L and the upper triangular matrix U.\n    \"\"\"\n    n = A.shape[0]\n    U = A.astype(np.float64, copy=True)\n    L = np.eye(n, dtype=np.float64)\n    for k in range(n - 1):\n        if U[k, k] == 0:\n            # Although theoretically impossible for SDD matrices,\n            # this is a safeguard for floating point arithmetic.\n            raise ValueError(\"Zero pivot encountered during LU factorization without pivoting.\")\n        for i in range(k + 1, n):\n            m = U[i, k] / U[k, k]\n            L[i, k] = m\n            U[i, k:] -= m * U[k, k:]\n            U[i, k] = 0.0 # Enforce exact zero for numerical stability\n    return L, U\n\ndef forward_subst(L, b):\n    \"\"\"\n    Solves the lower triangular system Ly = b.\n    \n    Args:\n        L (np.ndarray): A lower triangular matrix.\n        b (np.ndarray): The right-hand side vector.\n        \n    Returns:\n        np.ndarray: The solution vector y.\n    \"\"\"\n    n = L.shape[0]\n    y = np.zeros(n, dtype=np.float64)\n    for i in range(n):\n        y[i] = b[i] - np.dot(L[i, :i], y[:i])\n    return y\n\ndef backward_subst(U, y):\n    \"\"\"\n    Solves the upper triangular system Ux = y.\n    \n    Args:\n        U (np.ndarray): An upper triangular matrix.\n        y (np.ndarray): The right-hand side vector.\n        \n    Returns:\n        np.ndarray: The solution vector x.\n    \"\"\"\n    n = U.shape[0]\n    x = np.zeros(n, dtype=np.float64)\n    for i in range(n - 1, -1, -1):\n        x[i] = (y[i] - np.dot(U[i, i+1:], x[i+1:])) / U[i, i]\n    return x\n\ndef run_test_case(n, epsilon, seed):\n    \"\"\"\n    Runs a single stability test case.\n    \n    Args:\n        n (int): The dimension of the matrix.\n        epsilon (float): The perturbation level.\n        seed (int): The seed for the random number generator.\n        \n    Returns:\n        bool: True if the stability checks pass, False otherwise.\n    \"\"\"\n    np.random.seed(seed)\n    \n    # 1. Construct A_n\n    A_n = np.diag(np.full(n, 3.0, dtype=np.float64)) + \\\n          np.diag(np.full(n - 1, -1.0, dtype=np.float64), k=1) + \\\n          np.diag(np.full(n - 1, -1.0, dtype=np.float64), k=-1)\n\n    # 2. Construct random perturbation E\n    E = np.random.randn(n, n)\n    \n    # Scale E\n    norm_An = np.linalg.norm(A_n, ord=2)\n    norm_E = np.linalg.norm(E, ord=2)\n    if norm_E > 0:\n        E_scaled = E * (epsilon * norm_An / norm_E)\n    else: # Should not happen in practice\n        E_scaled = np.zeros((n,n), dtype=np.float64)\n        \n    # 3. Form perturbed matrix A_tilde and random vector b\n    A_tilde = A_n + E_scaled\n    b = np.random.randn(n)\n\n    # 4. Compute LU factorization and solve A_tilde * x = b\n    try:\n        L, U = lu_no_pivot(A_tilde)\n        y = forward_subst(L, b)\n        x = backward_subst(U, y)\n    except ValueError:\n        # If a zero pivot occurs, the process is unstable by definition\n        return False\n        \n    # 5. Compute element growth factor gamma\n    max_abs_U = np.max(np.abs(U))\n    max_abs_A_tilde = np.max(np.abs(A_tilde))\n    gamma = max_abs_U / max_abs_A_tilde if max_abs_A_tilde != 0 else float('inf')\n\n    # 6. Compute scaled backward residual eta\n    residual_norm = np.linalg.norm(A_n @ x - b, ord=2)\n    norm_x = np.linalg.norm(x, ord=2)\n    norm_b = np.linalg.norm(b, ord=2)\n    \n    denominator = norm_An * norm_x + norm_b\n    eta = residual_norm / denominator if denominator > 0 else float('inf')\n\n    # 7. Check stability conditions\n    gamma_stable = (gamma = 2.1)\n    eta_stable = (eta = 1.5 * epsilon)\n    \n    return gamma_stable and eta_stable\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (n, epsilon, seed)\n        (5, 10**-12, 0),\n        (5, 10**-8, 1),\n        (5, 10**-6, 2),\n        (20, 10**-12, 3),\n        (20, 10**-8, 4),\n        (20, 10**-6, 5),\n        (50, 10**-12, 6),\n        (50, 10**-8, 7),\n        (50, 10**-6, 8),\n    ]\n\n    results = []\n    for n, epsilon, seed in test_cases:\n        is_stable = run_test_case(n, epsilon, seed)\n        results.append(str(is_stable))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3156903"}]}