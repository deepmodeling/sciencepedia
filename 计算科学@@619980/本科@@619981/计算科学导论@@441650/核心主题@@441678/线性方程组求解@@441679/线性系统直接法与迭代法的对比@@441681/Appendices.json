{"hands_on_practices": [{"introduction": "理论是基础，但真正的理解来自于实践。这个练习将指导你通过编写代码，直接比较一种直接法（无主元 $LU$ 分解）和两种经典的迭代法（Jacobi 和 Gauss-Seidel）[@problem_id:3118502]。你将通过计算生长因子、重构误差和迭代矩阵的谱半径等关键指标，来量化评估对角占优矩阵下直接法的数值稳定性与迭代法的收敛速度，从而对它们各自的性能特点建立直观的认识。", "problem": "您必须编写一个完整、可运行的程序，该程序构建一组具有对角占优性的矩阵，并用它们来比较求解线性系统的直接法与迭代法。直接法是无主元选取的下-上 (LU) 分解法，迭代法是雅可比法和高斯-赛德尔 (GS) 法。您的程序必须计算明确定义的度量指标，以使这种比较定量化，并且必须按照下面指定的精确格式生成单行输出。\n\n其基本原理是线性系统的定义和标准矩阵分解。考虑一个方阵 $A \\in \\mathbb{R}^{n \\times n}$ 和一个线性系统 $A x = b$，其中 $x, b \\in \\mathbb{R}^{n}$。对于直接法，将矩阵 $A$ 分解为 $A = L U$，其中 $L$ 是单位下三角矩阵， $U$ 是上三角矩阵，分解过程不进行任何行主元选取。对于迭代法，使用标准的矩阵分裂 $A = D + L + U$，其中 $D$ 是 $A$ 的对角部分， $L$ 是严格下三角部分， $U$ 是严格上三角部分。雅可比迭代矩阵为 $T_{\\mathrm{J}} = -D^{-1}(L + U)$，高斯-赛德尔迭代矩阵为 $T_{\\mathrm{GS}} = -(D + L)^{-1} U$。对于任何方阵 $M$，其谱半径定义为 $\\rho(M) = \\max_{i} \\lvert \\lambda_{i}(M) \\rvert$，其中 $\\lambda_{i}(M)$ 是 $M$ 的特征值。此处使用的一个基本事实是：一个迭代法对任意初始向量都收敛的充要条件是其迭代矩阵的谱半径在范数一致的意义下严格小于 $1$，即 $\\rho(M) < 1$。\n\n您需要计算以下定量度量指标：\n- 一个LU稳定性的代理指标，即增长因子 $\\gamma = \\dfrac{\\max_{i,j} \\lvert U_{i j} \\rvert}{\\max_{i,j} \\lvert A_{i j} \\rvert}$，它衡量了在无主元选取的消元过程中矩阵元素是否显著增长。\n- 一个LU重构残差 $r = \\dfrac{\\lVert A - L U \\rVert_{\\mathrm{F}}}{\\lVert A \\rVert_{\\mathrm{F}}}$，其中 $\\lVert \\cdot \\rVert_{\\mathrm{F}}$ 是弗罗贝尼乌斯范数，它量化了分解的后向误差。\n- 雅可比谱半径 $\\rho(T_{\\mathrm{J}})$。\n- 高斯-赛德尔谱半径 $\\rho(T_{\\mathrm{GS}})$。\n\n构建以下测试矩阵 $A$ 的集合，选择这些矩阵是为了涵盖理想情况、边界条件和边缘情况。所有元素均为实数，维度已明确固定：\n1. 理想情况，严格对角占优，尺寸 $3 \\times 3$：\n   $$A_{1} = \\begin{bmatrix}\n   4  -1  0 \\\\\n   -1  4  -1 \\\\\n   0  -1  3\n   \\end{bmatrix}.$$\n2. 边界条件，弱对角占优（内部行取等号），尺寸 $5 \\times 5$，具有类狄利克雷内部的三对角离散拉普拉斯算子：\n   $$A_{2} = \\begin{bmatrix}\n   2  -1  0  0  0 \\\\\n   -1  2  -1  0  0 \\\\\n   0  -1  2  -1  0 \\\\\n   0  0  -1  2  -1 \\\\\n   0  0  0  -1  2\n   \\end{bmatrix}.$$\n3. 边缘情况，病态但仍为严格对角占优，尺寸 $2 \\times 2$：\n   $$A_{3} = \\begin{bmatrix}\n   1  -0.999 \\\\\n   -0.999  1\n   \\end{bmatrix}.$$\n4. 一个更大的随机严格对角占优矩阵，尺寸 $6 \\times 6$，按如下方式确定性地构建：设置种子为 $123$ 的伪随机数生成器。对于每个非对角元素 $(i, j)$（其中 $i \\neq j$），从 $[-0.2, 0.2]$ 均匀抽取 $A_{4}[i, j]$。然后，对于每一行 $i$，设置对角元素\n   $$A_{4}[i, i] = \\sum_{j \\neq i} \\lvert A_{4}[i, j] \\rvert + 0.5,$$\n   以确保按行严格对角占优。\n\n对于每个测试矩阵 $A$，您必须：\n- 使用Doolittle算法执行无主元选取的LU分解，生成 $L$ 和 $U$，其中 $L$ 的对角线元素为单位1。\n- 计算上面定义的增长因子 $\\gamma$ 和重构残差 $r$。\n- 根据 $A$ 的分裂，构建 $T_{\\mathrm{J}} = -D^{-1}(L + U)$ 和 $T_{\\mathrm{GS}} = -(D + L)^{-1} U$，并计算它们的谱半径 $\\rho(T_{\\mathrm{J}})$ 和 $\\rho(T_{\\mathrm{GS}})$。\n\n您的程序必须生成单行输出，其中包含四个测试矩阵的结果，格式如下：\n- 一个用方括号括起来的逗号分隔列表，其中每个元素对应一个测试矩阵，并且其本身是一个包含四个浮点度量指标的列表\n  $$[\\gamma,\\ r,\\ \\rho(T_{\\mathrm{J}}),\\ \\rho(T_{\\mathrm{GS}})]。$$\n- 所有浮点数必须四舍五入到 $6$ 位小数。\n- 例如，确切的结构是\n  $$[[\\gamma_{1}, r_{1}, \\rho(T_{\\mathrm{J},1}), \\rho(T_{\\mathrm{GS},1})],[\\gamma_{2}, r_{2}, \\rho(T_{\\mathrm{J},2}), \\rho(T_{\\mathrm{GS},2})],[\\gamma_{3}, r_{3}, \\rho(T_{\\mathrm{J},3}), \\rho(T_{\\mathrm{GS},3})],[\\gamma_{4}, r_{4}, \\rho(T_{\\mathrm{J},4}), \\rho(T_{\\mathrm{GS},4})]]。$$\n\n不涉及任何物理单位。所有角度（如果需要）都将以弧度为单位，但此处并未使用。所有答案都是浮点数，并且必须遵守指定的四舍五入和格式要求。\n\n您的程序必须是自包含的，不需要用户输入，并使用指定的Python库。它必须明确地实现所需的算法，以确保结果是可复现和可测试的。", "solution": "该问题已经过验证，被认为是有效的。它在科学上基于数值线性代数的原理，问题设定良好，具有唯一且可计算的解，并且表达客观。任务是比较求解线性系统 $A x = b$ 的直接法（LU分解）与迭代法（雅可比法，高斯-赛德尔法）。此比较通过为一组四个特殊构造的矩阵计算四个定量度量指标来执行。\n\n解决方案通过一个Python程序实现，该程序为每个矩阵计算这些度量指标。对每个矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的处理过程如下：\n\n首先，我们按规定构造四个测试矩阵：\n1.  $A_{1}$：一个 $3 \\times 3$ 的严格对角占优矩阵，代表了所有方法的“理想情况”。\n    $$A_{1} = \\begin{bmatrix}\n    4  -1  0 \\\\\n    -1  4  -1 \\\\\n    0  -1  3\n    \\end{bmatrix}$$\n2.  $A_{2}$：一个 $5 \\times 5$ 矩阵，代表一维离散拉普拉斯算子。它是弱对角占优且不可约的，是收敛定理的一个边界条件，但在这种情况下迭代法已知是收敛的。\n    $$A_{2} = \\begin{bmatrix}\n    2  -1  0  0  0 \\\\\n    -1  2  -1  0  0 \\\\\n    0  -1  2  -1  0 \\\\\n    0  0  -1  2  -1 \\\\\n    0  0  0  -1  2\n    \\end{bmatrix}$$\n3.  $A_{3}$：一个 $2 \\times 2$ 矩阵，它是严格对角占优但病态的（接近奇异）。这作为一个边缘案例来测试算法的数值稳定性。\n    $$A_{3} = \\begin{bmatrix}\n    1  -0.999 \\\\\n    -0.999  1\n    \\end{bmatrix}$$\n4.  $A_{4}$：一个更大的 $6 \\times 6$ 严格对角占优矩阵，使用固定种子为 $123$ 的伪随机数生成器确定性地构造。非对角线元素 $A_{4}[i, j]$（其中 $i \\neq j$）从 $[-0.2, 0.2]$ 上的均匀分布中抽取。然后设置对角线元素以强制执行严格的行对角占优：$A_{4}[i, i] = \\sum_{j \\neq i} \\lvert A_{4}[i, j] \\rvert + 0.5$。\n\n对于每个矩阵 $A$，我们计算四个度量指标。\n\n前两个度量指标评估直接法，特别是无主元选取的LU分解（$A = LU$），其中 $L$ 是单位下三角矩阵， $U$ 是上三角矩阵。这是使用Doolittle算法实现的。对于一个 $n \\times n$ 的矩阵 $A$， $L$ 和 $U$ 的元素计算如下：\n$$ U_{kj} = A_{kj} - \\sum_{i=0}^{k-1} L_{ki} U_{ij}, \\quad \\text{for } j=k, \\dots, n-1 $$\n$$ L_{ik} = \\frac{1}{U_{kk}} \\left( A_{ik} - \\sum_{j=0}^{k-1} L_{ij} U_{jk} \\right), \\quad \\text{for } i=k+1, \\dots, n-1 $$\n其中 $L_{kk}=1$。该算法保证在执行时不会遇到零主元（$U_{kk} \\neq 0$），因为所有提供的矩阵都是对角占优的。\n\n1.  **增长因子 ($\\gamma$)**：该指标是无主元LU分解稳定性的一个代理。它定义为计算出的上三角矩阵 $U$ 中的最大绝对值与原始矩阵 $A$ 中的最大绝对值之比。\n    $$ \\gamma = \\dfrac{\\max_{i,j} \\lvert U_{i j} \\rvert}{\\max_{i,j} \\lvert A_{i j} \\rvert} $$\n    一个小的增长因子（接近 $1$）表明在消元过程中元素没有过度增长，这表明数值稳定性。对于对角占优矩阵，$\\gamma$ 预计会很小。\n\n2.  **LU重构残差 ($r$)**：该指标通过衡量计算出的因子 $L$ 和 $U$ 重构原始矩阵 $A$ 的程度来量化分解的后向误差。它计算为残差矩阵 $A - LU$ 的弗罗贝尼乌斯范数与 $A$ 的弗罗贝尼乌斯范数之比。\n    $$ r = \\dfrac{\\lVert A - L U \\rVert_{\\mathrm{F}}}{\\lVert A \\rVert_{\\mathrm{F}}} $$\n    一个接近机器精度的 $r$ 值表明分解非常精确。\n\n接下来的两个度量指标评估迭代法的收敛特性。雅可比法和高斯-赛德尔法基于将矩阵 $A$ 分裂为其对角部分（$D$）、严格下三角部分（$L_A$）和严格上三角部分（$U_A$），即 $A = D + L_A + U_A$。\n\n3.  **雅可比谱半径 ($\\rho(T_{\\mathrm{J}})$)**：雅可比迭代矩阵为 $T_{\\mathrm{J}} = -D^{-1}(L_A + U_A)$。迭代法收敛的充要条件是谱半径 $\\rho(T_{\\mathrm{J}}) = \\max_{i} \\lvert \\lambda_{i}(T_{\\mathrm{J}}) \\rvert$ 小于 $1$。$\\rho(T_{\\mathrm{J}})$ 的值决定了渐近收敛速度。\n\n4.  **高斯-赛德尔谱半径 ($\\rho(T_{\\mathrm{GS}})$)**：高斯-赛德尔迭代矩阵为 $T_{\\mathrm{GS}} = -(D + L_A)^{-1} U_A$。与雅可比法类似，当且仅当其谱半径 $\\rho(T_{\\mathrm{GS}})$ 小于 $1$ 时，收敛得到保证。对于所考虑的矩阵类别（对称正定矩阵，包括 $A_1$, $A_2$, $A_3$，或更一般的不可约对角占优矩阵），高斯-赛德尔法预计比雅可比法收敛得更快，即 $\\rho(T_{\\mathrm{GS}})  \\rho(T_{\\mathrm{J}})$。\n\n程序系统地将这些计算应用于四个测试矩阵中的每一个，整理结果，并按规定将其格式化为单行字符串，其中每个浮点数都四舍五入到 $6$ 位小数。", "answer": "```python\nimport numpy as np\n\ndef doolittle_lu(A):\n    \"\"\"\n    Performs LU decomposition of a square matrix A using the Doolittle algorithm\n    without pivoting. A = LU, where L is unit lower triangular.\n    \n    Args:\n        A (np.ndarray): The square matrix to decompose.\n    \n    Returns:\n        (np.ndarray, np.ndarray): The lower (L) and upper (U) triangular matrices.\n    \"\"\"\n    n = A.shape[0]\n    L = np.eye(n)\n    U = np.zeros((n, n))\n\n    for k in range(n):\n        # Vectorized calculation for the k-th row of U\n        U[k, k:] = A[k, k:] - L[k, :k] @ U[:k, k:]\n\n        if U[k, k] == 0:\n            # This should not occur for the given problem matrices\n            # as they are diagonally dominant.\n            raise ValueError(\"Zero pivot encountered.\")\n\n        # Vectorized calculation for the k-th column of L\n        if k + 1  n:\n            L[k+1:, k] = (A[k+1:, k] - L[k+1:, :k] @ U[:k, k]) / U[k, k]\n\n    return L, U\n\ndef compute_metrics(A):\n    \"\"\"\n    Computes the four specified metrics for a given matrix A.\n    \n    Args:\n        A (np.ndarray): The input square matrix.\n    \n    Returns:\n        list: A list containing [gamma, r, rho_J, rho_GS].\n    \"\"\"\n    # 1. Perform LU decomposition\n    L_lu, U_lu = doolittle_lu(A)\n\n    # 2. Compute growth factor (gamma)\n    max_abs_A = np.max(np.abs(A))\n    if max_abs_A == 0:\n        gamma = np.inf if np.max(np.abs(U_lu)) > 0 else 0.0\n    else:\n        gamma = np.max(np.abs(U_lu)) / max_abs_A\n\n    # 3. Compute reconstruction residual (r)\n    norm_A = np.linalg.norm(A, 'fro')\n    if norm_A == 0:\n        r = 0.0\n    else:\n        r = np.linalg.norm(A - L_lu @ U_lu, 'fro') / norm_A\n\n    # 4. Split A for iterative methods\n    D = np.diag(np.diag(A))\n    L_split = np.tril(A, k=-1)\n    U_split = np.triu(A, k=1)\n\n    # 5. Compute Jacobi spectral radius (rho_J)\n    D_inv = np.linalg.inv(D)\n    T_J = -D_inv @ (L_split + U_split)\n    rho_J = np.max(np.abs(np.linalg.eigvals(T_J)))\n\n    # 6. Compute Gauss-Seidel spectral radius (rho_GS)\n    D_plus_L_inv = np.linalg.inv(D + L_split)\n    T_GS = -D_plus_L_inv @ U_split\n    rho_GS = np.max(np.abs(np.linalg.eigvals(T_GS)))\n\n    return [gamma, r, rho_J, rho_GS]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, compute metrics, and print results.\n    \"\"\"\n    # Test case 1: Happy path, strictly diagonally dominant\n    A1 = np.array([\n        [4., -1., 0.],\n        [-1., 4., -1.],\n        [0., -1., 3.]\n    ])\n\n    # Test case 2: Boundary condition, weak diagonal dominance\n    A2 = np.array([\n        [2., -1., 0., 0., 0.],\n        [-1., 2., -1., 0., 0.],\n        [0., -1., 2., -1., 0.],\n        [0., 0., -1., 2., -1.],\n        [0., 0., 0., -1., 2.]\n    ])\n\n    # Test case 3: Edge case, ill-conditioned but strictly diagonally dominant\n    A3 = np.array([\n        [1., -0.999],\n        [-0.999, 1.]\n    ])\n\n    # Test case 4: Larger random strictly diagonally dominant matrix\n    n4 = 6\n    rng = np.random.default_rng(123)\n    A4 = rng.uniform(low=-0.2, high=0.2, size=(n4, n4))\n    for i in range(n4):\n        # Set diagonal to ensure strict row diagonal dominance\n        row_sum_abs = np.sum(np.abs(A4[i, :])) - np.abs(A4[i, i])\n        A4[i, i] = row_sum_abs + 0.5\n\n    test_cases = [A1, A2, A3, A4]\n    \n    all_results = []\n    for case in test_cases:\n        metrics = compute_metrics(case)\n        all_results.append(metrics)\n\n    # Format the final output string\n    formatted_case_results = []\n    for metrics in all_results:\n        rounded_metrics = [f\"{val:.6f}\" for val in metrics]\n        formatted_case_results.append(f\"[{','.join(rounded_metrics)}]\")\n    \n    final_output_string = f\"[{','.join(formatted_case_results)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "3118502"}, {"introduction": "在解决了较为理想化的稠密矩阵之后，我们转向更贴近现实世界应用的大型稀疏矩阵。此练习的核心在于探究矩阵的*结构*，特别是其非零元素的对称性，如何深刻影响算法的选择 [@problem_id:3118467]。你将通过构造具有不同对称性的稀疏矩阵，亲手检验直接法中棘手的“填充（fill-in）”现象，并理解为何共轭梯度法（CG）这类强大的迭代法仅适用于对称正定（Symmetric Positive Definite, SPD）的特殊情况。", "problem": "您的任务是构建和分析稀疏矩阵，以研究非零模式的对称性如何影响下三角-上三角（LU）分解中的分解填充，以及共轭梯度（CG）迭代法的适用性。其数学基础是线性系统定义 $A x = b$、导致LU分解的高斯消元概念，以及共轭梯度（CG）方法要求矩阵为对称正定（SPD）的条件。\n\n定义和核心事实：\n- 一个线性系统由一个方阵 $A \\in \\mathbb{R}^{N \\times N}$ 和一个向量 $b \\in \\mathbb{R}^{N}$ 指定，旨在求解满足 $A x = b$ 的 $x \\in \\mathbb{R}^{N}$。\n- LU分解将 $A$（可能经过行和列的置换后）表示为 $A = L U$ 的形式，其中 $L$ 是下三角矩阵， $U$ 是上三角矩阵。高斯消元会引入新的非零项，这种现象称为填充。填充项的数量可以通过 $L$ 和 $U$ 中的总非零元数量与 $A$ 中原始非零元数量之差来量化。\n- 共轭梯度（CG）方法是为对称正定（SPD）矩阵定义的。如果一个矩阵 $A$ 满足 $A^{\\mathsf{T}} = A$ 且对于所有非零向量 $x$ 都有 $x^{\\mathsf{T}} A x  0$，则该矩阵是SPD矩阵。\n- 非零模式对称性指的是 $A$ 的支撑集（非零项的索引集合）是否等于 $A^{\\mathsf{T}}$ 的支撑集，而与数值无关。\n\n您的程序必须构建三个测试矩阵，并为每个矩阵计算四个量：非零模式是否对称、在自然列排序下LU分解的填充计数、在减少填充的列排序下LU分解的填充计数，以及CG方法是否适用（即矩阵是否为SPD）。所有数学量必须按照下文规定处理，最终输出必须是符合要求格式的单行文本。\n\n矩阵构建和测试套件：\n- 测试用例1（对称正定基准）：设 $n = 6$，因此 $N = n^2 = 36$。在 $n \\times n$ 网格上使用狄利克雷边界条件定义二维离散拉普拉斯算子为\n$$\nT_1 = \\mathrm{diags}\\left(\\{-\\mathbf{1}_{n-1},\\ 2\\mathbf{1}_{n},\\ -\\mathbf{1}_{n-1}\\},\\ \\{-1, 0, 1\\}\\right),\n$$\n$$\nI_n = \\mathrm{eye}(n),\n$$\n$$\nA_1 = \\mathrm{kron}(I_n, T_1) + \\mathrm{kron}(T_1, I_n).\n$$\n这个 $A_1 \\in \\mathbb{R}^{N \\times N}$ 是对称正定的，并且具有对称的非零模式。\n- 测试用例2（非对称极端模式）：设 $N = 36$。定义\n$$\nI_N = \\mathrm{eye}(N),\n$$\n$$\nS = \\mathrm{diags}\\left(\\{\\mathbf{1}_{N-1}\\},\\ \\{1\\}\\right),\n$$\n$$\nR = \\text{第一行全为1的稀疏矩阵},\n$$\n$$\nC = \\text{最后一列全为1的稀疏矩阵}。\n$$\n设\n$$\nA_2 = I_N + S + R + C.\n$$\n这个 $A_2 \\in \\mathbb{R}^{N \\times N}$ 被设计成在其非零模式上具有强烈的非对称性，并且条件良好，足以进行LU分解。\n- 测试用例3（对称不定）：使用上面的 $A_1$，设\n$$\nA_3 = A_1 - 10 I_N,\n$$\n这保留了对称的非零模式，但破坏了正定性。\n\n对于每个矩阵 $A_k$（其中 $k \\in \\{1,2,3\\}$），执行以下计算：\n- 非零模式对称性布尔值：确定 $A_k$ 的支撑集是否等于 $A_k^{\\mathsf{T}}$ 的支撑集（如果对于每一对 $(i,j)$ 使得 $A_k(i,j) \\neq 0$，都有 $A_k(j,i) \\neq 0$，则为真）。\n- 自然列排序下LU分解的填充计数：使用自然列排序计算 $A_k$ 的LU分解，然后计算整数\n$$\n\\mathrm{fill\\_nat}(A_k) = \\mathrm{nnz}(L) + \\mathrm{nnz}(U) - \\mathrm{nnz}(A_k),\n$$\n其中 $\\mathrm{nnz}(\\cdot)$ 表示非零项的数量。您应该使用数值库中带有自然列排序的标准稀疏LU分解来获得 $L$ 和 $U$。\n- 减少填充的列排序下LU分解的填充计数：使用减少填充的列排序（如列近似最小度（COLAMD））重复计算，以获得\n$$\n\\mathrm{fill\\_colamd}(A_k) = \\mathrm{nnz}(L) + \\mathrm{nnz}(U) - \\mathrm{nnz}(A_k).\n$$\n- CG适用性布尔值：通过检查对称性并尝试通过Cholesky分解测试验证正定性，来确定 $A_k$ 是否适用于共轭梯度法。当且仅当 $A_k$ 是对称且正定的，报告为真。\n\n最终输出格式：\n- 您的程序应生成一个单行输出，其中包含一个用方括号括起来的逗号分隔列表。按以下顺序汇总所有三个测试用例的结果：\n$$\n[\\ \\mathrm{pat\\_sym}(A_1),\\ \\mathrm{fill\\_nat}(A_1),\\ \\mathrm{fill\\_colamd}(A_1),\\ \\mathrm{cg\\_app}(A_1),\\ \\mathrm{pat\\_sym}(A_2),\\ \\mathrm{fill\\_nat}(A_2),\\ \\mathrm{fill\\_colamd}(A_2),\\ \\mathrm{cg\\_app}(A_2),\\ \\mathrm{pat\\_sym}(A_3),\\ \\mathrm{fill\\_nat}(A_3),\\ \\mathrm{fill\\_colamd}(A_3),\\ \\mathrm{cg\\_app}(A_3)\\ ].\n$$\n这里 $\\mathrm{pat\\_sym}(A_k)$ 和 $\\mathrm{cg\\_app}(A_k)$ 是布尔值，$\\mathrm{fill\\_nat}(A_k)$ 和 $\\mathrm{fill\\_colamd}(A_k)$ 是整数。此问题不涉及物理单位。您的程序必须是自包含的，不需要任何输入，并且只产生这一单行输出。", "solution": "我们从线性系统 $A x = b$ 的基本定义开始，其中 $A \\in \\mathbb{R}^{N \\times N}$。直接法，特别是高斯消元，会得到一个下三角-上三角（LU）分解 $A = L U$（在置换意义下），其中 $L$ 是下三角矩阵， $U$ 是上三角矩阵。在消元过程中，即使 $A$ 是稀疏的，也可能产生新的非零元；这种现象称为填充。填充量可以通过计算因子中非零元数量相对于原始矩阵的增量来衡量。形式上，对于固定的排序，填充计数为 $\\mathrm{nnz}(L) + \\mathrm{nnz}(U) - \\mathrm{nnz}(A)$，其中 $\\mathrm{nnz}(\\cdot)$ 表示非零元的数量。\n\n迭代法以不同的方式逼近解。特别是，共轭梯度（CG）方法要求系数矩阵是对称正定（SPD）的。SPD条件是 $A^{\\mathsf{T}} = A$（对称性）和对于所有非零 $x \\in \\mathbb{R}^{N}$ 都有 $x^{\\mathsf{T}} A x  0$（正定性）。一个等效且实用的正定性测试是判断是否存在Cholesky分解 $A = R^{\\mathsf{T}} R$，其中 $R$ 是一个上三角矩阵；该分解成功当且仅当 $A$ 是SPD矩阵。\n\n非零模式对称性对填充的影响可以通过消元图来推断。$A$ 的稀疏模式在索引 $\\{1,\\dots,N\\}$ 上定义了一个图，其中边表示非零的非对角元。高斯消元对应于消除顶点，这会在其邻居之间引入边（填充）。对称模式通常允许更均衡的图结构，而减少填充的排序（如列近似最小度（COLAMD））利用这种结构来最小化消元过程中的度增长，从而减少填充。相比之下，强非对称模式，特别是那些具有密集行或列（形成星形或箭头形结构）的模式，可能导致更显著的填充，因为消元会密集地连接许多节点。\n\n与原理相结合的算法设计：\n- 将 $A_1$ 构建为在 $n \\times n$ 网格上具有狄利克雷边界的二维离散拉普拉斯算子，使用克罗内克积之和。设 $n = 6$，因此 $N = n^2 = 36$。一维拉普拉斯算子 $T_1 = \\mathrm{diags}(\\{-\\mathbf{1}_{n-1}, 2\\mathbf{1}_{n}, -\\mathbf{1}_{n-1}\\}, \\{-1, 0, 1\\})$ 是对称且严格对角占优的，而克罗内克和 $A_1 = \\mathrm{kron}(I_n, T_1) + \\mathrm{kron}(T_1, I_n)$ 是对称正定（SPD）的，并具有对称的非零模式。根据SPD性质，$A_1$ 允许进行Cholesky分解，因此CG方法适用。对于填充，我们使用稀疏LU分解和两种列排序：自然排序和减少填充的排序（COLAMD）来量化差异。\n- 将 $A_2$ 构建为一个具有显著非对称模式的矩阵：$A_2 = I_N + S + R + C$，其中 $I_N$ 是单位矩阵， $S$ 是超对角线， $R$ 是一个密集的首行， $C$ 是一个密集的末列。单位矩阵确保了非奇异性。模式对称性检查比较 $A_2$ 和 $A_2^{\\mathsf{T}}$ 的支撑集；密集的第一行和最后一列破坏了支撑集的对称性。CG方法不适用，因为模式不对称，且矩阵不是SPD。在非对称、星形结构中，LU填充往往更大，因为消元会产生许多新的耦合；我们再次在自然排序和COLAMD排序下测量填充。\n- 构建 $A_3 = A_1 - 10 I_N$。这保留了对称的非零模式，但破坏了正定性，因为减去一个足够大的单位矩阵倍数会将所有特征值向左移动，使它们变为负值（因为对于这个尺寸，$A_1$ 的特征值是有界正数）。Cholesky测试会失败，因此CG方法不适用。LU填充由模式和排序驱动，而不是值的符号；因此，对于固定的排序，$A_3$ 的填充情况与 $A_1$ 相似，可能由于主元选择策略而有微小差异。\n\n与上述一致的实现细节：\n- 模式对称性通过比较 $A$ 的非零索引集（支撑集）与 $A^{\\mathsf{T}}$ 的非零索引集来测试；相等则表示对称。\n- 填充计数使用提供 $L$ 和 $U$ 的稀疏LU例程计算。我们针对自然列排序和COLAMD列排序计算 $\\mathrm{nnz}(L) + \\mathrm{nnz}(U) - \\mathrm{nnz}(A)$。允许内部为数值稳定性进行行主元选择，这是现实直接法的一部分。\n- CG适用性通过两项检查确定：(i) 通过 $A \\stackrel{?}{=} A^{\\mathsf{T}}$ 检查对称性，以及 (ii) 通过尝试进行稠密Cholesky分解来检查正定性；成功则意味着SPD。\n\n测试套件和输出：\n- 测试用例1使用 $N=36$ 的SPD拉普拉斯算子 $A_1$。\n- 测试用例2使用 $N=36$ 的非对称箭头/星形矩阵 $A_2$。\n- 测试用例3使用 $N=36$ 的对称不定矩阵 $A_3 = A_1 - 10 I_N$。\n对于每个 $A_k$，程序输出布尔值 $\\mathrm{pat\\_sym}(A_k)$ 和 $\\mathrm{cg\\_app}(A_k)$，以及整数 $\\mathrm{fill\\_nat}(A_k)$ 和 $\\mathrm{fill\\_colamd}(A_k)$。所有十二个结果按照问题陈述中指定的确切顺序，在方括号内以单个逗号分隔的列表形式打印。\n\n这种设计直接反映了非零模式对称性与直接法和迭代法行为之间的相互作用：对称模式使得有效的减少填充排序成为可能，并在SPD成立时允许使用CG，而非对称模式通常会导致更大的填充并使CG失效。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, eye, kron, csr_matrix, coo_matrix, csc_matrix\nfrom scipy.sparse.linalg import splu\n\ndef build_laplacian_2d(n: int) -> csr_matrix:\n    \"\"\"\n    Build the 2D discrete Laplacian (Dirichlet) on an n x n grid using Kronecker sums.\n    Resulting matrix is SPD and has symmetric sparsity pattern.\n    \"\"\"\n    # 1D Laplacian: tridiagonal with [ -1, 2, -1 ]\n    main = 2.0 * np.ones(n)\n    off = -1.0 * np.ones(n - 1)\n    T1 = diags([off, main, off], offsets=[-1, 0, 1], shape=(n, n), format=\"csr\")\n    In = eye(n, format=\"csr\")\n    A = kron(In, T1, format=\"csr\") + kron(T1, In, format=\"csr\")\n    return A\n\ndef build_nonsymmetric_arrow(N: int) -> csr_matrix:\n    \"\"\"\n    Build a sparse matrix with a strongly nonsymmetric pattern:\n    Identity + superdiagonal + dense first row + dense last column.\n    \"\"\"\n    A = eye(N, format=\"csr\")\n    # Superdiagonal ones\n    A += diags([np.ones(N - 1)], offsets=[1], shape=(N, N), format=\"csr\")\n    # Dense first row of ones\n    row0 = np.zeros(N, dtype=int)\n    cols = np.arange(N, dtype=int)\n    data = np.ones(N)\n    R = csr_matrix((data, (row0, cols)), shape=(N, N))\n    A += R\n    # Dense last column of ones\n    rows = np.arange(N, dtype=int)\n    col_last = np.full(N, N - 1, dtype=int)\n    C = csr_matrix((np.ones(N), (rows, col_last)), shape=(N, N))\n    A += C\n    return A\n\ndef is_pattern_symmetric(A: csr_matrix) -> bool:\n    \"\"\"\n    Check whether the sparsity pattern of A equals that of A^T.\n    \"\"\"\n    cooA = A.tocoo()\n    coordsA = set(zip(cooA.row.tolist(), cooA.col.tolist()))\n    cooAT = A.T.tocoo()\n    coordsAT = set(zip(cooAT.row.tolist(), cooAT.col.tolist()))\n    return coordsA == coordsAT\n\ndef fill_in_count(A: csr_matrix, permc_spec: str) -> int:\n    \"\"\"\n    Compute fill-in count for sparse LU: nnz(L) + nnz(U) - nnz(A),\n    using specified column permutation strategy (permc_spec).\n    \"\"\"\n    # Convert to CSC for splu\n    Acsc = A.tocsc()\n    lu = splu(Acsc, permc_spec=permc_spec)\n    L = lu.L\n    U = lu.U\n    return L.nnz + U.nnz - A.nnz\n\ndef cg_applicable(A: csr_matrix) -> bool:\n    \"\"\"\n    Determine CG applicability: True iff A is symmetric and positive definite.\n    We test symmetry and attempt dense Cholesky.\n    \"\"\"\n    dense = A.toarray()\n    if not np.allclose(dense, dense.T, atol=1e-12):\n        return False\n    try:\n        np.linalg.cholesky(dense)\n        return True\n    except np.linalg.LinAlgError:\n        return False\n\ndef solve():\n    # Define test cases: three matrices as specified in the problem statement.\n    n = 6\n    N = n * n\n\n    # Test Case 1: SPD Laplacian\n    A1 = build_laplacian_2d(n)\n\n    # Test Case 2: Nonsymmetric arrow/star\n    A2 = build_nonsymmetric_arrow(N)\n\n    # Test Case 3: Symmetric indefinite (shifted Laplacian)\n    A3 = A1 - 10.0 * eye(N, format=\"csr\")\n\n    test_cases = [A1, A2, A3]\n\n    results = []\n    for A in test_cases:\n        # Pattern symmetry boolean\n        pat_sym = is_pattern_symmetric(A)\n        # Fill-in with natural ordering\n        fill_nat = fill_in_count(A, permc_spec=\"NATURAL\")\n        # Fill-in with COLAMD ordering\n        fill_colamd = fill_in_count(A, permc_spec=\"COLAMD\")\n        # CG applicability boolean\n        cg_app = cg_applicable(A)\n        # Append in required order per test case\n        results.extend([pat_sym, fill_nat, fill_colamd, cg_app])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3118467"}, {"introduction": "当问题规模达到百万甚至更大时，算法对计算机内存的占用往往成为决定其可行性的瓶颈。这个练习将带你从计算性能转向资源管理的视角 [@problem_id:3118498]。你将扮演一位计算科学家的角色，通过理论分析的方式精确估算并比较直接 $LU$ 分解（考虑填充）与现代迭代法 GMRES 在处理大规模稀疏问题时的内存足迹。这将具体揭示为何对于前沿科学计算中的许多挑战，迭代法是唯一现实的选择。", "problem": "一个稀疏线性系统源于在结构化网格上对一个偏微分方程进行均匀离散化，产生一个矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其平均稀疏度为每行 $z$ 个非零元。假设该矩阵以压缩稀疏行 (CSR) 格式存储，其中每个非零值以双精度（$8$ 字节）存储，每个列索引以 $32$ 位整数（$4$ 字节）存储，行指针数组有 $n+1$ 个条目，每个条目为 $32$ 位整数（$4$ 字节）。考虑两种求解策略：\n- 一种使用 LU (Lower-Upper) 分解的直接法，其中 $L$ 和 $U$ 因子中非零元的总数由填充因子 $f$ 乘以 $A$ 中非零元的数量来建模，并且 $L$ 和 $U$ 都以 CSR 格式存储，其每个条目和每个指针的存储成本与 $A$ 相同。\n- 一种使用带重启参数 $m$ 的广义最小残差 (GMRES) 法，记为 GMRES($m$)，该方法以双精度存储一个由 $(m+1)$ 个长度为 $n$ 的向量组成的 Arnoldi 基，一个大小为 $(m+1) \\times m$ 的双精度上 Hessenberg 矩阵，以及三个额外的长度为 $n$ 的工作向量（当前迭代解、右端项和残差），所有这些都以双精度存储。假设在 GMRES 过程中矩阵 $A$ 必须以 CSR 格式存储。\n\n给定参数 $n = 10^{6}$、$z = 7$、$f = 5$ 以及 $3.0 \\times 10^{8}$ 字节的内存上限，使用 CSR 内存模型来：\n1. 推导一个以 $n$ 和 $z$ 表示的、用于存储矩阵 $A$ 所需的 CSR 内存（单位：字节）的表达式。\n2. 推导一个以 $n$、$z$ 和 $f$ 表示的、用于存储 LU 因子所需的 CSR 内存（单位：字节）的表达式。\n3. 推导 GMRES($m$) 所需的总内存（单位：字节）的表达式，包括矩阵 $A$、Arnoldi 基、Hessenberg 矩阵和三个工作向量的存储。\n\n然后，确定最大的整数重启参数 $m$，使得 GMRES($m$) 在内存上限下是可行的，而 LU 分解是不可行的。只报告 $m$ 的值。无需四舍五入；提供精确的整数值作为最终答案。", "solution": "本题将首先被验证，如果被认为是有效的，将按照指定的推导步骤进行求解。\n\n**问题验证**\n\n*   **已知条件提取：**\n    *   矩阵 $A \\in \\mathbb{R}^{n \\times n}$。\n    *   平均稀疏度：每行 $z$ 个非零元。\n    *   存储格式：压缩稀疏行 (CSR)。\n    *   数据类型：值为双精度（$8$ 字节），索引和指针为 $32$ 位整数（$4$ 字节）。\n    *   行指针数组大小：$n+1$ 个条目。\n    *   直接法 (LU)：填充因子 $f$，$L$ 和 $U$ 因子以 CSR 格式存储。\n    *   迭代法 (GMRES($m$))：重启参数 $m$，存储一个由 $(m+1)$ 个向量组成的 Arnoldi 基（长度 $n$，双精度），一个大小为 $(m+1) \\times m$ 的 Hessenberg 矩阵（双精度），以及 $3$ 个工作向量（长度 $n$，双精度）。矩阵 $A$ 也需要存储。\n    *   参数：$n = 10^{6}$，$z = 7$，$f = 5$。\n    *   约束条件：内存上限 $\\le 3.0 \\times 10^{8}$ 字节。\n\n*   **验证结论：**\n    该问题具有科学依据、适定且客观。它基于数值线性代数和计算科学中的标准、可形式化的概念，即 CSR 存储的内存复杂度、带填充的 LU 分解以及 GMRES 算法。所有参数和模型都明确定义，使得问题自洽且无歧义。所提供的值对于大规模科学计算是现实的。因此，该问题被认为是**有效的**。\n\n**求解推导**\n\n求解过程需要为三种不同情况推导内存表达式，然后利用这些表达式找到 GMRES 允许的最大重启参数 $m$。\n\n**1. 矩阵 $A$ 的 CSR 格式内存**\n设 $M_A$ 是存储矩阵 $A$ 所需的内存（单位：字节）。CSR 格式由三个数组组成：一个用于存储非零值，一个用于存储它们的列索引，一个用于存储行指针。\n- 行数为 $n$。平均每行有 $z$ 个非零元，因此非零元的总数为 $nnz(A) = nz$。\n- 非零值内存：$nz$ 个值中的每一个都是双精度，需要 $8$ 字节。总计：$8nz$ 字节。\n- 列索引内存：$nz$ 个非零元中的每一个都有一个对应的列索引，以 $32$ 位整数（$4$ 字节）存储。总计：$4nz$ 字节。\n- 行指针内存：此数组有 $n+1$ 个条目，每个条目是 $32$ 位整数（$4$ 字节）。总计：$4(n+1)$ 字节。\n存储 $A$ 的总内存是这些部分的总和：\n$$M_A(n, z) = 8nz + 4nz + 4(n+1)$$\n$$M_A(n, z) = 12nz + 4n + 4$$\n\n**2. LU 因子的 CSR 格式内存**\n设 $M_{LU}$ 是存储 $L$ 和 $U$ 因子的内存。题目说明 $L$ 和 $U$ 中非零元的总数是 $A$ 中非零元数量的 $f$ 倍。\n- 因子中的非零元总数：$nnz(L) + nnz(U) = f \\times nnz(A) = fnz$。\n- 我们将这些因子的存储建模为 CSR 格式中的单个逻辑实体，具有 $fnz$ 个非零条目和 $n$ 行（需要 $n+1$ 个行指针），这与填充估计的通常做法一致。\n- 非零值内存：$8(fnz)$ 字节。\n- 列索引内存：$4(fnz)$ 字节。\n- 行指针内存：$4(n+1)$ 字节。\nLU 因子的总内存为：\n$$M_{LU}(n, z, f) = 8fnz + 4fnz + 4(n+1)$$\n$$M_{LU}(n, z, f) = 12fnz + 4n + 4$$\n\n**3. GMRES($m$) 的总内存**\n设 $M_{GMRES}(m)$ 为 GMRES($m$) 算法所需的总内存。这包括存储矩阵 $A$ 和算法所需的数据结构。\n- 矩阵 $A$ 的存储：$M_A = 12nz + 4n + 4$。\n- Arnoldi 基的存储：该基由 $m+1$ 个向量组成，每个向量长度为 $n$，以双精度存储。内存：$8n(m+1)$ 字节。\n- Hessenberg 矩阵的存储：这是一个以双精度存储的稠密 $(m+1) \\times m$ 矩阵。内存：$8m(m+1)$ 字节。\n- 工作向量的存储：三个长度为 $n$ 的双精度向量（当前迭代解、右端项、残差）。内存：$3 \\times 8n = 24n$ 字节。\n总内存是这些部分的总和：\n$$M_{GMRES}(n, z, m) = (12nz + 4n + 4) + 8n(m+1) + 8m(m+1) + 24n$$\n合并各项：\n$$M_{GMRES}(n, z, m) = 12nz + (4n + 8n + 24n) + 8nm + 8m^2 + 8m + 4$$\n$$M_{GMRES}(n, z, m) = 12nz + 36n + 4 + 8nm + 8m^2 + 8m$$\n\n**确定最大的整数重启参数 $m$**\n\n给定参数 $n = 10^{6}$，$z = 7$，$f = 5$ 以及内存上限 $M_{cap} = 3.0 \\times 10^{8}$ 字节。我们需要找到最大的整数 $m$，使得 $M_{LU}  M_{cap}$ 且 $M_{GMRES}(m) \\le M_{cap}$。\n\n首先，验证 LU 方法是不可行的：\n$$M_{LU} = 12(5)(10^{6})(7) + 4(10^{6}) + 4$$\n$$M_{LU} = 420 \\times 10^{6} + 4 \\times 10^{6} + 4$$\n$$M_{LU} = 424,000,004 \\text{ 字节}$$\n由于 $424,000,004  3.0 \\times 10^{8}$，LU 分解方法超出了内存上限，因此不可行。这满足了第一个条件。\n\n接下来，我们建立 GMRES($m$) 的不等式：\n$$M_{GMRES}(m) \\le 3.0 \\times 10^{8}$$\n$$12(10^{6})(7) + 36(10^{6}) + 4 + 8(10^{6})m + 8m^2 + 8m \\le 300,000,000$$\n$$84,000,000 + 36,000,000 + 4 + 8,000,000m + 8m^2 + 8m \\le 300,000,000$$\n$$120,000,004 + 8,000,008m + 8m^2 \\le 300,000,000$$\n这可以简化为一个关于 $m$ 的二次不等式：\n$$8m^2 + 8,000,008m - (300,000,000 - 120,000,004) \\le 0$$\n$$8m^2 + 8,000,008m - 179,999,996 \\le 0$$\n对于 $m$ 的预期范围，项 $8m^2$ 远小于项 $8,000,008m$。我们可以通过考察线性部分来近似求解：\n$$8,000,008m \\approx 179,999,996$$\n$$m \\approx \\frac{179,999,996}{8,000,008} \\approx \\frac{1.8 \\times 10^{8}}{8.0 \\times 10^{6}} = \\frac{180}{8} = 22.5$$\n这表明 $m$ 的最大整数值为 $22$。我们将通过在完整的二次不等式中测试 $m = 22$ 和 $m = 23$ 来验证这一点。\n\n当 $m = 22$ 时：\n$$8(22)^2 + 8,000,008(22) - 179,999,996$$\n$$8(484) + 176,000,176 - 179,999,996$$\n$$3,872 + 176,000,176 - 179,999,996$$\n$$176,004,048 - 179,999,996 = -3,995,948$$\n由于 $-3,995,948 \\le 0$，条件对于 $m=22$ 成立。\n\n当 $m = 23$ 时：\n$$8(23)^2 + 8,000,008(23) - 179,999,996$$\n$$8(529) + 184,000,184 - 179,999,996$$\n$$4,232 + 184,000,184 - 179,999,996$$\n$$184,004,416 - 179,999,996 = 4,004,420$$\n由于 $4,004,420  0$，条件对于 $m=23$ 不成立。\n\n因此，使得 GMRES($m$) 可行的最大整数重启参数 $m$ 是 $22$。", "answer": "$$\\boxed{22}$$", "id": "3118498"}]}