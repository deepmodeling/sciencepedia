{"hands_on_practices": [{"introduction": "单纯形法的核心思想是通过迭代，从可行域的一个顶点移动到相邻且更优的另一个顶点，不断改进目标函数值。这个过程的关键就是“主元变换”（pivot operation）。通过下面的练习 [@problem_id:2221017]，你将亲手执行一次完整的迭代，这是掌握单纯形算法如何逐步走向最优解的基础。", "problem": "一家营销分析公司正在使用线性规划来确定客户广告预算的最优分配。其目标是最大化客户覆盖率。决策变量为 $x_1$（在社交媒体上购买的广告单元数）和 $x_2$（在搜索引擎上购买的广告单元数）。该问题已被构建为一个标准的最大化问题，其初始单纯形表如下所示。变量 $s_1$ 和 $s_2$ 是松弛变量，分别代表未使用的预算和员工工时。变量 $Z$ 代表需要最大化的总客户覆盖率。\n\n表的行对应于目标函数 $Z$ 以及以 $s_1$ 和 $s_2$ 为基变量的两个约束条件。列对应于变量 $Z, x_1, x_2, s_1, s_2$ 和右侧（RHS）值。\n\n初始单纯形表为：\n$$\n\\begin{array}{c|cccccc}\n\\text{基变量} & Z & x_1 & x_2 & s_1 & s_2 & \\text{RHS} \\\\\n\\hline\nZ & 1 & -5 & -4 & 0 & 0 & 0 \\\\\ns_1 & 0 & 10 & 8 & 1 & 0 & 80 \\\\\ns_2 & 0 & 2 & 3 & 0 & 1 & 24 \\\\\n\\end{array}\n$$\n\n根据标准单纯形法对最大化问题执行一次完整的轴转操作。确定 Z-行中 $x_2$ 的系数、Z-行中 $s_1$ 的系数以及目标函数 $Z$ 的新值（Z-行的 RHS 值）的更新值。\n\n您的答案应该是一组按指定顺序排列的三个数值，以行矩阵的形式呈现：（$x_2$ 的系数, $s_1$ 的系数, $Z$ 的值）。", "solution": "我们应用标准单纯形法的轴转规则来解决最大化问题。\n\n1) 确定进基变量：在 Z-行中，决策变量的最负系数是 $x_{1}$ 的 $-5$，因此 $x_{1}$ 进基。\n\n2) 对 $x_{1}$ 列执行最小比率测试以选择离基变量：\n$$\n\\frac{80}{10}=8 \\quad \\text{对于 } s_{1}, \\qquad \\frac{24}{2}=12 \\quad \\text{对于 } s_{2}.\n$$\n最小比率为 $8$，因此 $s_{1}$ 离基。主元是 $s_{1}$ 行和 $x_{1}$ 列中的 $10$。\n\n3) 进行轴转，使主元变为 1，并从其他行中消去 $x_{1}$。\n\n将主元行（$s_{1}$ 行）除以 $10$ 进行归一化：\n$$\ns_{1}\\text{-行}: \\quad [0,\\;10,\\;8,\\;1,\\;0\\;|\\;80] \\;\\to\\; [0,\\;1,\\;\\tfrac{4}{5},\\;\\tfrac{1}{10},\\;0\\;|\\;8].\n$$\n\n将新的 $s_{1}$ 行乘以 $5$ 加到 Z-行，以从 Z-行中消去 $x_{1}$：\n$$\nZ\\text{-行}: \\quad [1,\\;-5,\\;-4,\\;0,\\;0\\;|\\;0] + 5\\cdot[0,\\;1,\\;\\tfrac{4}{5},\\;\\tfrac{1}{10},\\;0\\;|\\;8] = [1,\\;0,\\;0,\\;\\tfrac{1}{2},\\;0\\;|\\;40].\n$$\n\n（从 $s_{2}$ 行中消去 $x_{1}$ 是完整轴转操作的一部分，但对于求解所要求的 Z-行系数而言并非必需。）\n\n因此，在这次单次轴转之后，Z-行中 $x_{2}$ 的系数是 $0$，Z-行中 $s_{1}$ 的系数是 $\\tfrac{1}{2}$，目标函数的新值 $Z$（Z-行的 RHS）是 $40$。", "answer": "$$\\boxed{\\begin{pmatrix}0 & \\frac{1}{2} & 40\\end{pmatrix}}$$", "id": "2221017"}, {"introduction": "掌握了主元变换的机械步骤之后，我们需要更深入地理解线性规划背后的几何直觉。一个常见的误解是：无界的可行域必然导致无界的最优解。下面的思辨性练习 [@problem_id:2443959] 将引导你构建一个反例，从而澄清可行域的几何形态与目标函数行为之间的关键区别。", "problem": "在线性规划中，一个常见的误解是无界可行域必然导致目标函数无界。仅使用第一性原理，构建并分析一个二维线性规划问题，作为该说法的反例。\n\n从以下基本定义开始：\n- 可行域是满足问题所有线性约束的点的集合。\n- 如果存在一个方向向量，沿着该向量可以任意移动而仍保持在集合内，则该集合是无界的。\n- 线性目标函数是关于决策向量 $x$ 的线性形式 $c^{\\top}x$。\n\n考虑一个包含两个变量 $x_{1}$ 和 $x_{2}$ 的线性规划问题：\n- 决策变量：$x_{1} \\geq 0$，$x_{2} \\geq 0$。\n- 约束条件：$x_{1} \\leq 1$。\n- 目标：最大化 $z = x_{1}$。\n\n任务：\n1. 使用上述定义，直接从约束集出发，论证可行域是无界的。\n2. 仅利用目标函数的线性性质和约束条件 $x_{1} \\leq 1$，确定目标函数的最优值。\n3. 解释为何在此例中，可行域的无界性没有导致目标函数的无界性，并指出存在一个目标函数不增加的可行方向。\n\n将最大目标值作为你的最终答案。请以精确数字形式表示，无需四舍五入。", "solution": "该问题提出了一个线性规划，并要求进行分析，以证明无界可行域并不必然意味着目标函数无界。我们将严格遵守第一性原理和给定的定义，系统地完成每一项任务。\n\n该线性规划问题由决策变量 $x_1$ 和 $x_2$ 定义如下：\n最大化 $z = x_1$\n约束条件：\n$x_1 \\leq 1$\n$x_1 \\geq 0$\n$x_2 \\geq 0$\n\n设可行域为集合 $S$。一个点 $p = (x_1, x_2)$ 在 $S$ 中，当且仅当其坐标同时满足所有三个约束条件。因此，$S = \\{ (x_1, x_2) \\in \\mathbb{R}^2 \\mid 0 \\leq x_1 \\leq 1, x_2 \\geq 0 \\}$。该集合表示笛卡尔平面第一象限中的一个半无限带状区域。\n\n**任务1：可行域的无界性**\n\n为了证明可行域 $S$ 是无界的，我们必须根据给定的定义证明，存在一个方向向量，沿着该向量可以任意移动而仍保持在集合内。\n\n我们选择一个点 $p_0 \\in S$。一个简单的选择是 $p_0 = (0, 0)$，它显然满足 $0 \\leq 0 \\leq 1$ 和 $0 \\geq 0$。\n现在，我们定义一个方向向量 $d = (0, 1)^T$。我们构造一条从 $p_0$ 点出发，方向为 $d$ 的射线。该射线上的任何点都可以通过 $\\lambda \\geq 0$ 参数化为：\n$$ p(\\lambda) = p_0 + \\lambda d = (0, 0)^T + \\lambda (0, 1)^T = (0, \\lambda)^T $$\n任何此类点的坐标为 $(x_1, x_2) = (0, \\lambda)$。我们必须验证对于任何非负值 $\\lambda$，$p(\\lambda)$ 是否都保持在可行域 $S$ 内。我们检查约束条件：\n1.  $x_1 \\leq 1$：条件是 $0 \\leq 1$，成立。\n2.  $x_1 \\geq 0$：条件是 $0 \\geq 0$，成立。\n3.  $x_2 \\geq 0$：条件是 $\\lambda \\geq 0$，根据我们对参数 $\\lambda$ 的定义，该条件成立。\n\n由于对于任何 $\\lambda \\geq 0$，所有约束条件都得到满足，因此射线 $(0, \\lambda)$ 上的任何点都在可行集 $S$ 中。因为我们可以选择任意大的 $\\lambda$，所以我们可以沿方向 $d=(0,1)^T$ 从原点移动任意远的距离，同时保持在 $S$ 内部。因此，根据给定的定义，可行域 $S$ 是无界的。\n\n**任务2：目标函数的最优值**\n\n目标是在可行域 $S$ 内的所有点 $(x_1, x_2)$ 上最大化函数 $z = x_1$。$S$ 的定义包含了约束条件 $x_1 \\leq 1$。这个约束条件从本质上就对 $x_1$ 的可能取值施加了一个上界。\n\n目标函数 $z$ 是一个仅依赖于变量 $x_1$ 的线性函数。要最大化 $z$，我们必须找到在可行域 $S$ 内允许的 $x_1$ 的最大可能值。定义 $S$ 的约束条件是 $0 \\leq x_1 \\leq 1$ 和 $x_2 \\geq 0$。从约束条件 $x_1 \\leq 1$ 可以清楚地看出，$x_1$ 的值永远不能超过 $1$。\n\n这个最大值是否存在于可行域内？是的。考虑点 $p^* = (1, 0)$。\n- $p^*$ 是否可行？我们检查约束条件：$x_1 = 1$ 满足 $0 \\leq 1 \\leq 1$，而 $x_2 = 0$ 满足 $0 \\geq 0$。因此，$p^* \\in S$。\n- 在此点，目标函数值为 $z = x_1 = 1$。\n\n由于对于任何点 $(x_1, x_2) \\in S$，都有 $x_1 \\leq 1$，因此目标函数 $z = x_1$ 的上界为 $1$。因为我们已经找到了一个达到该值的可行点，所以目标函数的最大值恰好是 $1$。\n\n**任务3：解释有界目标与无界区域**\n\n在这种情况下，可行域的无界性并没有导致目标函数的无界性。其原因在于目标函数的梯度与可行域的无界方向之间的关系。\n\n目标函数是 $z = x_1$。这可以写成向量形式 $z = c^T x$，其中 $x = (x_1, x_2)^T$，成本向量（即 $z$ 的梯度）为 $c = (1, 0)^T$。\n\n在任务1中，我们确定了一个无界方向 $d = (0, 1)^T$。这个向量表明我们可以在正 $x_2$ 方向上无限移动。要使目标函数无界，其值必须随着我们沿这样一个可行方向移动而无限增加。让我们分析目标函数沿此方向 $d$ 的变化。\n\n目标函数 $z$ 在方向 $d$ 上的变化率由方向导数给出，对于线性函数，这仅仅是点积 $c^T d$。我们来计算这个值：\n$$ c^T d = (1, 0) \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = (1)(0) + (0)(1) = 0 $$\n结果 $c^T d = 0$ 表明，沿着无界方向 $d$ 移动根本不会改变目标函数的值。无界方向与目标函数增加的方向是正交的。\n\n为了说明这一点，考虑任意可行点 $p_0 = (x_{1,0}, x_{2,0}) \\in S$。我们从这个点沿方向 $d$ 移动。对于 $\\lambda \\geq 0$，新点为 $p(\\lambda) = p_0 + \\lambda d = (x_{1,0}, x_{2,0} + \\lambda)$。只要 $0 \\leq x_{1,0} \\leq 1$，这个新点对于所有 $\\lambda \\geq 0$ 都保持可行。该新点的目标值为：\n$$ z(p(\\lambda)) = c^T p(\\lambda) = c^T(p_0 + \\lambda d) = c^T p_0 + \\lambda(c^T d) $$\n因为我们发现 $c^T d = 0$，这可以简化为：\n$$ z(p(\\lambda)) = c^T p_0 = x_{1,0} $$\n这证实了在可行集内，沿任何平行于 $x_2$ 轴的射线上，目标函数的值保持不变。区域的无界性存在于一个目标函数不增加的方向。目标函数是有界的，因为它的值仅依赖于 $x_1$，而 $x_1$ 本身受到约束条件的限制。\n\n总之，对于一个具有无界可行域的线性规划问题，要使其目标函数无界，必须存在一个无界的可行方向 $d$，使得 $c^T d > 0$。在这个反例中，不存在这样的方向；对于唯一的无界方向，我们有 $c^T d = 0$。", "answer": "$$\\boxed{1}$$", "id": "2443959"}, {"introduction": "单纯形算法的运行需要一个有效的起点，即一个基本可行解。然而，当问题包含等式约束或“大于等于”约束时，初始基本可行解并不总是显而易见的。这时，我们就需要“两阶段法”（Two-Phase Method）。这个更具挑战性的实践 [@problem_id:3192717] 将指导你实现第一阶段的算法，它是一个系统性的过程，旨在找到一个初始基本可行解，或者证明问题本身无解（infeasible）。", "problem": "考虑线性规划（LP）中的形式可行性问题，即必须判断是否存在一个决策变量向量，满足一组有限的线性等式和不等式约束以及非负性限制。单纯形法通过寻找一个基本可行解（BFS）来构造性地解决可行性问题，该解由一组基本变量构成，使得所有变量均为非负且满足约束条件。当无法直接构成一个基本可行解时，会采用标准的两阶段法。在第一阶段中，通过引入人工变量来增广约束，并最小化这些人工变量的总和。这样做的合理性基于可行性的定义：如果人工变量总和的最小值严格为正，则不存在任何原始变量向量能够在非负的松弛或剩余变量下满足所有约束，因此原始 LP 是不可行的。反之，最小值为零则证明原始约束存在一个基本可行解，并且所有人工变量都可以被驱动为零。\n\n你的任务是使用人工变量实现单纯形法的第一阶段，将其视为一个原始单纯形问题，目标是最大化人工变量总和的负值（等价于最小化它们的总和）。从以下基本概念开始：\n\n- LP 可行性定义：寻找 $x \\in \\mathbb{R}^n$，使得 $A_{\\text{eq}} x = b_{\\text{eq}}$，$A_{\\text{le}} x \\le b_{\\text{le}}$，$A_{\\text{ge}} x \\ge b_{\\text{ge}}$，且 $x \\ge 0$。\n- 松弛变量和剩余变量的构造：对于约束 $a_i^\\top x \\le b_i$，引入松弛变量 $s_i \\ge 0$ 写成 $a_i^\\top x + s_i = b_i$；对于约束 $a_i^\\top x \\ge b_i$，引入剩余变量 $s_i \\ge 0$ 写成 $a_i^\\top x - s_i = b_i$。\n- 人工变量的构造：对于无法提供直接基本可行解的约束（所有等式约束以及引入剩余变量后的所有 $\\ge$ 约束），添加一个人工变量 $a_i \\ge 0$，写成 $a_i^\\top x - s_i + a_i = b_i$（对于 $\\ge$）或 $a_i^\\top x + a_i = b_i$（对于 $=$）。\n- 第一阶段目标：最小化 $\\sum_i a_i$，等价于最大化 $-\\sum_i a_i$。如果 $\\sum_i a_i$ 的最优值严格为正，则原始 LP 不可行。\n\n算法要求：\n\n- 使用检验数原则为第一阶段实现原始单纯形法。设 $M \\in \\mathbb{R}^{m \\times p}$ 为添加松弛变量、剩余变量和人工变量后的完整约束矩阵，其中 $p$ 是变量总数。设 $b \\in \\mathbb{R}^m$ 为经过必要符号调整以确保右端项非负后的右端向量。维护一个基索引集 $B$，该集合选择 $M$ 的 $m$ 个列构成基矩阵 $M_B$。对于第一阶段的目标 $c \\in \\mathbb{R}^p$（其人工变量对应的分量为 $-1$，其余为 $0$），计算每个非基列 $j$ 的检验数 $r_j = c_j - c_B^\\top M_B^{-1} M_{\\cdot j}$。选择满足 $r_j > 0$ 的变量作为进基变量（使用 Bland’s rule，选择最小的索引以避免循环）。为基本变量计算方向 $d = -M_B^{-1} M_{\\cdot j}$，对 $d_i < 0$ 的索引使用最小比率检验 $t_i = x_{B,i} / (-d_i)$（等价于，对 $M_B^{-1} M_{\\cdot j}$ 中分量为正的那些，使用 $x_{B,i} / (M_B^{-1} M_{\\cdot j})_i$），然后进行转轴操作。迭代直至不存在检验数为正的进基变量。第一阶段的最优值为 $-c_B^\\top x_B$，这等于人工变量总和的最小值。\n\n- 行符号规范化：对于任何 $b_i < 0$ 的约束，将整行乘以 $-1$ 并翻转不等号方向（$\\le$ 变为 $\\ge$，反之亦然）以保持 $b_i \\ge 0$。等式约束在乘以 $-1$ 后仍为等式。\n\n- 非负性：所有变量，包括原始变量、松弛变量、剩余变量和人工变量，都必须满足 $x \\ge 0$。\n\n测试套件：\n\n对于每个案例，变量为 $x_1, x_2 \\ge 0$。约束以 $(A, b, \\text{senses})$ 的形式提供，其中 $A \\in \\mathbb{R}^{m \\times 2}$，$b \\in \\mathbb{R}^m$，senses 是一个列表，其条目为 'le'、'ge' 或 'eq'，分别表示 $\\le$、$\\ge$、$=$。\n\n- 案例1（不可行）：$A = \\begin{bmatrix} 1 & 1 \\\\ 1 & 0 \\end{bmatrix}$，$b = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}$，senses $= [\\text{le}, \\text{ge}]$。约束：$x_1 + x_2 \\le 1$，$x_1 \\ge 2$。\n- 案例2（可行，仅含松弛变量）：$A = \\begin{bmatrix} 1 & 2 \\\\ 2 & 1 \\end{bmatrix}$，$b = \\begin{bmatrix} 4 \\\\ 5 \\end{bmatrix}$，senses $= [\\text{le}, \\text{le}]$。约束：$x_1 + 2 x_2 \\le 4$，$2 x_1 + x_2 \\le 5$。\n- 案例3（可行，等式需要人工变量）：$A = \\begin{bmatrix} 1 & 1 \\\\ 1 & 2 \\end{bmatrix}$，$b = \\begin{bmatrix} 3 \\\\ 5 \\end{bmatrix}$，senses $= [\\text{eq}, \\text{le}]$。约束：$x_1 + x_2 = 3$，$x_1 + 2 x_2 \\le 5$。\n- 案例4（不可行，等式不一致）：$A = \\begin{bmatrix} 1 & 1 \\\\ 1 & 1 \\end{bmatrix}$，$b = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}$，senses $= [\\text{eq}, \\text{eq}]$。约束：$x_1 + x_2 = 1$，$x_1 + x_2 = 2$。\n- 案例5（可行，行符号翻转和混合类型）：$A = \\begin{bmatrix} -1 & 1 \\\\ 0 & 1 \\end{bmatrix}$，$b = \\begin{bmatrix} -1 \\\\ 2 \\end{bmatrix}$，senses $= [\\text{ge}, \\text{le}]$。约束：$-x_1 + x_2 \\ge -1$，$x_2 \\le 2$。\n\n输出规格：\n\n- 你的程序必须生成单行输出，包含一个浮点数列表，每个测试案例对应一个数字。每个数字等于第一阶段目标 $\\sum a_i$ 的最小值（等价于 $-\\max (-\\sum a_i)$），并四舍五入到六位小数。在最终报告的数字中，将绝对值小于 $10^{-8}$ 的值解释为零。\n- 确切的输出格式必须是形如 $[v_1,v_2,v_3,v_4,v_5]$ 的单行，其中每个 $v_k$ 是一个小数点后有六位数字的十进制数。\n\n此问题不涉及物理单位或角度，因此不需要单位说明。", "solution": "用户的要求是实现单纯形法的第一阶段，以解决线性规划的可行性问题。问题在于确定一组线性约束是否存在非负解。这通过最小化辅助人工变量的总和来实现。如果最小总和为零，则原始问题是可行的；如果严格为正，则为不可行。\n\n### 问题验证\n\n**步骤 1：提取给定信息**\n\n- **问题定义**：寻找 $x \\in \\mathbb{R}^n$，使得 $A_{\\text{eq}} x = b_{\\text{eq}}$，$A_{\\text{le}} x \\le b_{\\text{le}}$，$A_{\\text{ge}} x \\ge b_{\\text{ge}}$，且 $x \\ge 0$。\n- **标准型转换**：\n    - 对于 $a_i^\\top x \\le b_i$，使用松弛变量 $s_i \\ge 0$：$a_i^\\top x + s_i = b_i$。\n    - 对于 $a_i^\\top x \\ge b_i$，使用剩余变量 $s_i \\ge 0$：$a_i^\\top x - s_i = b_i$。\n- **人工变量**：对于等式约束和 $\\ge$ 约束，添加人工变量 $a_i \\ge 0$ 以在初始基中起作用。\n- **第一阶段目标**：最小化 $\\sum_i a_i$，等价于最大化 $z = -\\sum_i a_i$。$\\sum_i a_i$ 的严格为正的最小值意味着不可行。\n- **算法规格**：使用检验数的原始单纯形法。\n    - 完整约束矩阵 $M \\in \\mathbb{R}^{m \\times p}$。\n    - 右端向量 $b \\in \\mathbb{R}^m$，所有条目均非负。\n    - 大小为 $m$ 的基索引集 $B$。\n    - 第一阶段代价向量 $c$：人工变量为 $c_j = -1$，否则为 $0$。\n    - 检验数：$r_j = c_j - c_B^\\top M_B^{-1} M_{\\cdot j}$。\n    - 进基变量：具有 $r_j > 0$ 的最小索引 $j$（Bland’s rule）。\n    - 离基变量：最小比率检验，使用 Bland’s rule 打破平局。\n- **行规范化**：如果 $b_i < 0$，则将约束乘以 $-1$ 并翻转不等号。\n- **测试案例**：提供了五个不同的案例，每个都由矩阵 $A$、向量 $b$ 和一个类型列表（`le`, `ge`, `eq`）定义。\n- **输出格式**：一个单行列表，包含每个测试案例的人工变量最小总和，四舍五入到六位小数。绝对值小于 $10^{-8}$ 的值视为零。\n\n**步骤 2：使用提取的给定信息进行验证**\n\n根据验证标准对问题陈述进行评估：\n\n1.  **科学依据**：该问题在根本上是合理的。它描述了单纯形算法第一阶段的标准教科书式表述，这是运筹学和计算科学的基石。\n2.  **良构性**：该问题是良构的。目标明确，算法被明确定义（使用 Bland’s rule 防止循环的原始单纯形法），并且每个测试案例的输入都已完全指定。这确保了存在唯一且有意义的解（人工变量的最小总和）并且该解是可计算的。\n3.  **客观性**：问题以精确、客观的数学语言陈述，没有任何主观性或模糊性。\n4.  **完整性与一致性**：设置是完整的且内部一致。它提供了所有必要的组成部分：约束转换规则、目标函数定义、算法步骤和特定的测试数据。\n\n**步骤 3：结论与行动**\n\n该问题是**有效**的。它是计算科学领域中一个清晰、合理且可形式化的任务。解决方案将继续执行指定算法的实现。\n\n### 算法设计与求解\n\n解决方案的核心是一个 Python 函数，它为第一阶段目标实现了原始单纯形算法。步骤如下：\n\n1.  **预处理和单纯形表构造**：处理输入的约束 $(A, b, \\text{senses})$。每个右端项 $b_i<0$ 的约束乘以 $-1$，并相应地翻转其类型。这确保了所有 $b_i \\ge 0$。为第一阶段问题构建一个完整矩阵 $M$。其列对应于原始变量（$x_j$）、松弛变量（$s_k$）、剩余变量（$sl_l$）和人工变量（$a_p$）。创建第一阶段的代价向量 $c$。对于每个人工变量，其对应条目为 $-1$，所有其他变量为 $0$，这与最大化 $z = -\\sum_i a_i$ 的目标一致。\n\n2.  **初始基的确定**：辅助问题需要一个初始基本可行解（BFS）。对于每个类型为 $\\le$ 的约束（规范化后），相应的松弛变量可以作为该行的基本变量。对于每个类型为 $\\ge$ 或 $=$ 的约束，引入一个人工变量并作为该行的基本变量。这些基本变量的索引集构成了初始基 $B$。如果不需要人工变量，则原始问题是平凡可行的，最小总和为 $0$。\n\n3.  **单纯形迭代**：算法进行迭代，直到找到第一阶段问题的最优解。每次迭代包括以下步骤：**计算检验数**：计算单纯形乘子（或对偶变量）向量 $\\pi = c_B^\\top M_B^{-1}$，其中 $M_B$ 是由 $M$ 中对应于基 $B$ 中变量的列构成的基矩阵，$c_B$ 是它们的代价。然后，每个非基本变量 $j$ 的检验数是 $r_j = c_j - \\pi M_{\\cdot j}$。**选择进基变量**：根据 Bland’s rule，选择满足 $r_j > 0$ 的最小索引 $j$ 的非基本变量进入基。如果不存在这样的变量，则当前解是最优的，循环终止。**选择离基变量（最小比率检验）**：为进基变量 $j$ 计算基本变量的变化方向 $d = M_B^{-1} M_{\\cdot j}$。通过最小比率检验找到最大步长 $\\theta$：$\\theta = \\min \\{ x_{B,i} / d_i \\mid d_i > 0 \\}$，其中 $x_B = M_B^{-1} b$ 是当前基本变量值的向量。离开基的变量是对应于限制 $\\theta$ 的行的那个变量。使用 Bland’s rule 来打破平局：在所有产生最小比率的行中，选择对应于最小索引的基本变量的那一行。**转轴操作**：通过用进基变量的索引替换离基变量的索引来更新基 $B$。\n\n4.  **终止与结果**：当所有检验数均为非正时，循环终止。第一阶段目标的最优值为 $z_{\\text{opt}} = c_B^\\top x_B$。人工变量的最小总和为 $-z_{\\text{opt}}$。返回该值。值为 $0$（在小容差范围内）表示可行；严格为正的值表示不可行。\n\n这个计算过程是使用 `NumPy` 库进行矩阵运算在 Python 中实现的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_phase1(A, b, senses, tol=1e-9):\n    \"\"\"\n    Implements Phase I of the Simplex method to determine LP feasibility.\n\n    This function sets up and solves the Phase I linear program, which seeks to\n    minimize the sum of artificial variables.\n\n    Args:\n        A (np.ndarray): The coefficient matrix of the original constraints.\n        b (np.ndarray): The right-hand side vector of the original constraints.\n        senses (list): A list of strings ('le', 'ge', 'eq') indicating the sense\n                       of each constraint.\n        tol (float): A tolerance for floating-point comparisons.\n\n    Returns:\n        float: The minimum sum of artificial variables. A value of 0 indicates\n               feasibility, while a positive value indicates infeasibility. Returns\n               inf if the algorithm fails to converge or encounters an issue.\n    \"\"\"\n    m, n = A.shape\n\n    # 1. Preprocessing and Tableau Setup\n    A_p = A.copy().astype(float)\n    b_p = b.copy().astype(float)\n    senses_p = list(senses)\n\n    # Row normalization to ensure b_p >= 0\n    for i in range(m):\n        if b_p[i] < 0:\n            A_p[i, :] *= -1\n            b_p[i] *= -1\n            if senses_p[i] == 'le': senses_p[i] = 'ge'\n            elif senses_p[i] == 'ge': senses_p[i] = 'le'\n\n    # Build variable map to track original, slack, surplus, and artificial variables\n    var_map = []\n    # Original variables\n    for i in range(n):\n        var_map.append(('orig', i))\n    \n    # Add slack, surplus, and artificial variables based on constraint senses\n    for i in range(m):\n        if senses_p[i] == 'le':\n            var_map.append(('slack', i))\n        elif senses_p[i] == 'ge':\n            var_map.append(('surplus', i))\n            var_map.append(('artif', i))\n        elif senses_p[i] == 'eq':\n            var_map.append(('artif', i))\n\n    # If no artificial variables are needed, the problem is trivially feasible\n    if not any(v_type == 'artif' for v_type, _ in var_map):\n      return 0.0\n\n    # Build the full constraint matrix M for the Phase I problem\n    num_total_vars = len(var_map)\n    M = np.zeros((m, num_total_vars))\n    M[:, :n] = A_p\n    for k in range(n, num_total_vars):\n        v_type, v_orig_idx = var_map[k]\n        if v_type == 'slack': M[v_orig_idx, k] = 1.0\n        elif v_type == 'surplus': M[v_orig_idx, k] = -1.0\n        elif v_type == 'artif': M[v_orig_idx, k] = 1.0\n\n    # Build the cost vector c for Phase I (maximize -sum(a_i))\n    c = np.zeros(num_total_vars)\n    for k, (v_type, _) in enumerate(var_map):\n        if v_type == 'artif': c[k] = -1.0\n\n    # 2. Initial Basis Identification\n    basis = [-1] * m\n    for i in range(m):\n        if senses_p[i] == 'le':\n            # Find the slack variable for row i to be basic\n            for k, (v_type, v_orig_idx) in enumerate(var_map):\n                if v_type == 'slack' and v_orig_idx == i:\n                    basis[i] = k\n                    break\n        else:  # 'ge' or 'eq'\n            # Find the artificial variable for row i to be basic\n            for k, (v_type, v_orig_idx) in enumerate(var_map):\n                if v_type == 'artif' and v_orig_idx == i:\n                    basis[i] = k\n                    break\n    \n    # 3. Simplex Loop\n    max_iter = 5 * m # Set a practical iteration limit\n    for _ in range(max_iter):\n        M_B = M[:, basis]\n        c_B = c[basis]\n\n        try:\n            M_B_inv = np.linalg.inv(M_B)\n        except np.linalg.LinAlgError:\n            # Singular basis matrix, indicates a problem like linearly dependent constraints.\n            # In Phase I, this suggests the system is ill-defined or infeasible.\n            return np.inf\n\n        non_basis_indices = sorted([i for i in range(num_total_vars) if i not in basis])\n        pi = c_B @ M_B_inv # Simplex multipliers\n\n        # Bland's rule for entering variable: choose smallest index with positive reduced cost\n        entering_var = -1\n        for j in non_basis_indices:\n            rc = c[j] - pi @ M[:, j]\n            if rc > tol:\n                entering_var = j\n                break\n\n        if entering_var == -1: # Optimality reached\n            x_B = M_B_inv @ b_p\n            obj_val = c_B @ x_B\n            return -obj_val\n\n        # Minimum Ratio Test to find leaving variable\n        d = M_B_inv @ M[:, entering_var]\n        \n        if np.all(d <= tol):\n            # Unbounded problem. This should not occur in a well-formed Phase I.\n            return np.inf\n\n        x_B = M_B_inv @ b_p\n        \n        min_ratio = np.inf\n        potential_leaves = []\n        for i in range(m):\n            if d[i] > tol:\n                ratio = x_B[i] / d[i]\n                if ratio < min_ratio - tol:\n                    min_ratio = ratio\n                    potential_leaves = [(ratio, basis[i])]\n                elif abs(ratio - min_ratio) < tol:\n                    potential_leaves.append((ratio, basis[i]))\n        \n        if not potential_leaves:\n           # This case should be prevented by the check for d > tol.\n           return np.inf\n            \n        # Bland's rule for leaving variable: break ties with smallest variable index\n        leaving_var = min(var_idx for _, var_idx in potential_leaves)\n        \n        # Pivot: update the basis\n        leaving_row_idx = basis.index(leaving_var)\n        basis[leaving_row_idx] = entering_var\n\n    return np.inf # Failed to converge within iteration limit\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the Phase I simplex solver.\n    \"\"\"\n    test_cases = [\n        # Case 1 (infeasible)\n        (np.array([[1, 1], [1, 0]]), np.array([1, 2]), ['le', 'ge']),\n        # Case 2 (feasible, slack-only)\n        (np.array([[1, 2], [2, 1]]), np.array([4, 5]), ['le', 'le']),\n        # Case 3 (feasible, equality requires artificial)\n        (np.array([[1, 1], [1, 2]]), np.array([3, 5]), ['eq', 'le']),\n        # Case 4 (infeasible, inconsistent equalities)\n        (np.array([[1, 1], [1, 1]]), np.array([1, 2]), ['eq', 'eq']),\n        # Case 5 (feasible, row sign flip)\n        (np.array([[-1, 1], [0, 1]]), np.array([-1, 2]), ['ge', 'le']),\n    ]\n\n    results = []\n    for A, b, senses in test_cases:\n        raw_result = solve_phase1(A, b, senses)\n        # Interpret values smaller than 1e-8 as zero, as per problem spec\n        if abs(raw_result) < 1e-8:\n            final_result = 0.0\n        else:\n            final_result = raw_result\n        results.append(final_result)\n\n    # Format the final output string exactly as required\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3192717"}]}