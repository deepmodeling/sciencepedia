{"hands_on_practices": [{"introduction": "在求解非线性方程时，一个常见的误区是直接套用现成的算法。然而，一个稳健的计算实践始于对问题本身的深刻理解。本练习将引导你结合微积分中的基本定理（如介值定理）与数值方法，首先从理论上分析一个给定的函数 $f(x) = \\cos(x) - x^3$ [@problem_id:3164859]，证明其根的存在性与唯一性。这一分析不仅能帮助你构建一个合理的初始猜测值，还能让你体验到理论分析是如何为数值计算的成功保驾护航的，这是计算科学中一项至关重要的技能。", "problem": "考虑实数域上的非线性方程 $f(x) = \\cos(x) - x^{3}$，其中所有角度均以弧度为单位。仅使用微积分和数值分析的基础概念，完成以下目标，以确定实根结构并计算唯一的实数解：\n1) 利用 $f(x)$ 的连续性以及介值定理 (Intermediate Value Theorem, IVT)，证明至少存在一个实根。确定一个符号发生变化的闭区间 $[a,b]$，并说明您选择 $a$ 和 $b$ 的理由。\n2) 分析导数 $f^{\\prime}(x)$ 的符号以及 $\\cos(x)$ 的值域，以确定是否存在多个实根。为 $f(x)$ 的实根数量提供一个逻辑上完备的论证。\n3) 通过定性的图形分析（基于 $\\cos(x)$ 和 $x^{3}$ 的行为）和导数符号检查，为迭代求根过程构建一个实用的初始猜测值 $x_{0}$。利用 $f(x)$ 在一些简单点上的值以及 $f(x)$ 在一个合适区间上的单调性，来证明您选择 $x_{0}$ 的合理性。\n4) 从 $f(x)$ 在当前迭代点处的一阶泰勒多项式推导出一个迭代求根方法，并应用该方法从您选择的 $x_{0}$ 开始计算唯一的实根。持续迭代，直到您的近似值在保留 $4$ 位有效数字时保持一致。\n\n将最终数值答案四舍五入至 $4$ 位有效数字，并以无量纲实数的形式表示。", "solution": "该问题要求分析函数 $f(x) = \\cos(x) - x^{3}$ 的实根。解题过程按要求分为四个部分。\n\n(1) 实根的存在性\n\n为了证明实根的存在性，我们将使用介值定理 (IVT)。函数为 $f(x) = \\cos(x) - x^{3}$。函数 $\\cos(x)$ 对所有实数 $x \\in \\mathbb{R}$ 都是连续的，函数 $x^{3}$ 是一个多项式，也对所有 $x \\in \\mathbb{R}$ 连续。两个连续函数的差仍然是连续的，因此 $f(x)$ 在整个实数轴 $\\mathbb{R}$ 上是连续的。\n\n介值定理指出，对于在闭区间 $[a, b]$ 上连续的函数 $f$，如果 $k$ 是介于 $f(a)$ 和 $f(b)$ 之间的任意数，那么在 $[a, b]$ 中至少存在一个数 $c$ 使得 $f(c) = k$。为了证明根的存在，我们需要找到一个区间 $[a, b]$，使得 $f(a)$ 和 $f(b)$ 异号，这意味着 $0$ 介于 $f(a)$ 和 $f(b)$ 之间。\n\n让我们在一些简单的点上计算 $f(x)$ 的值。\n对于 $a=0$：\n$$f(0) = \\cos(0) - 0^{3} = 1 - 0 = 1$$\n因此，$f(0)  0$。\n\n对于 $b=1$：\n$$f(1) = \\cos(1) - 1^{3} = \\cos(1) - 1$$\n由于角度是以弧度为单位，并且 $0  1  \\frac{\\pi}{2}$，我们知道 $0  \\cos(1)  1$。因此，$f(1) = \\cos(1) - 1  0$。\n\n因为 $f(x)$ 在闭区间 $[0, 1]$ 上是连续的，且 $f(0) = 1  0$ 而 $f(1)  0$，根据介值定理，可以保证在开区间 $(0, 1)$ 内至少存在一个根 $c$，使得 $f(c) = 0$。\n\n(2) 实根的数量\n\n为了确定实根的总数，我们首先分析任何可能的根的范围，然后检验函数的单调性。$f(x)$ 的一个根对应于方程 $\\cos(x) = x^{3}$ 的一个解。\n\n余弦函数的值域是 $[-1, 1]$，因此任何实根 $x$ 都必须满足 $-1 \\le x^{3} \\le 1$。这意味着 $-1 \\le x \\le 1$。因此，$f(x)$ 的所有实根都必须位于闭区间 $[-1, 1]$ 内。\n\n接下来，我们分析 $f(x)$ 的导数以确定其在该区间上的单调性。导数为：\n$$f^{\\prime}(x) = \\frac{d}{dx}(\\cos(x) - x^{3}) = -\\sin(x) - 3x^{2}$$\n我们分析 $f^{\\prime}(x)$ 在区间 $[-1, 1]$ 上的符号。\n\n情况一：$x \\in (0, 1]$。\n在此区间内，$x  0$，所以 $3x^{2}  0$。此外，对于 $x \\in (0, 1] \\subset (0, \\pi)$，我们有 $\\sin(x)  0$。因此，导数中的两项都是负的：\n$$f^{\\prime}(x) = \\underbrace{-\\sin(x)}_{0} + \\underbrace{(-3x^{2})}_{0}  0 \\quad \\text{对于 } x \\in (0, 1]$$\n由于在 $(0, 1]$ 上 $f^{\\prime}(x)  0$，函数 $f(x)$ 在区间 $[0, 1]$ 上是严格递减的。一个严格单调的函数在一个区间内最多只能有一个根。由于我们在第 (1) 部分已经证明在 $(0, 1)$ 中存在一个根，因此在 $[0, 1]$ 中必定只有一个根。\n\n情况二：$x \\in [-1, 0)$。\n在此区间内，$x  0$。让我们来检验 $f(x)$ 本身的符号。\n项 $\\cos(x)$ 对于 $x \\in [-1, 0) \\subset (-\\frac{\\pi}{2}, \\frac{\\pi}{2})$ 是正的。\n项 $-x^{3}$ 对于 $x  0$ 是正的。\n因此，对于 $x \\in [-1, 0)$，$f(x)$ 是两项正数之和：\n$$f(x) = \\underbrace{\\cos(x)}_{>0} + \\underbrace{(-x^{3})}_{>0}  0 \\quad \\text{对于 } x \\in [-1, 0)$$\n由于 $f(x)$ 在 $[-1, 0)$ 上是严格为正的，所以在这个区间内没有根。\n\n综合我们的发现：\n- 当 $|x|  1$ 时没有根。\n- 当 $x \\in [-1, 0)$ 时没有根。\n- 在 $[0, 1]$ 中恰好有一个根。\n因此，函数 $f(x) = \\cos(x) - x^{3}$ 恰好有一个实根。\n\n(3) 迭代过程的初始猜测值\n\n根据以上分析，唯一的根位于区间 $(0, 1)$ 内。一个实用的初始猜测值 $x_{0}$ 应选择在该区间内或其附近。我们寻找一个能使迭代法表现良好的值 $x_{0}$。导数是 $f'(x) = -\\sin(x) - 3x^2$。在 $x=0$ 处，$f'(0)=0$，这会在牛顿法中导致除以零。因此，$x_0=0$ 是一个不好的选择。\n\n我们选择 $x_{0}=1$ 作为我们的初始猜测值。这个选择是合理的，因为：\n- 它是已知存在根的区间 $[0, 1]$ 的一个简单端点。\n- 我们有 $f(1) = \\cos(1) - 1  0$。\n- 在该点的导数 $f'(1) = -\\sin(1) - 3 \\neq 0$，因此迭代步是良定义的。\n- 二阶导数是 $f''(x) = -\\cos(x) - 6x$。对于 $x \\in [0, 1]$，$\\cos(x)  0$ 且 $6x \\ge 0$，所以 $f''(x)  0$。这意味着 $f(x)$ 在 $[0,1]$ 上是下凹的。由于 $f(1)  0$ 且 $f(x)$ 是下凹的，对于牛顿法，选择初始猜测值 $x_0=1$ 将产生一个单调收敛到根的迭代序列。\n\n(4) 迭代求根与求解\n\n问题要求从以迭代点 $x_{n}$ 为中心的 $f(x)$ 的一阶泰勒多项式推导出一个迭代方法。一阶泰勒展开式为：\n$$f(x) \\approx f(x_{n}) + f^{\\prime}(x_{n})(x - x_{n})$$\n为了找到根，我们将多项式设为零，$f(x) = 0$，并求解 $x$，我们将其指定为下一个迭代值 $x_{n+1}$：\n$$0 = f(x_{n}) + f^{\\prime}(x_{n})(x_{n+1} - x_{n})$$\n$$x_{n+1} - x_{n} = -\\frac{f(x_{n})}{f^{\\prime}(x_{n})}$$\n$$x_{n+1} = x_{n} - \\frac{f(x_{n})}{f^{\\prime}(x_{n})}$$\n这就是著名的牛顿-拉弗森方法 (Newton-Raphson method)。对于我们特定的函数：\n$$f(x) = \\cos(x) - x^{3}$$\n$$f^{\\prime}(x) = -\\sin(x) - 3x^{2}$$\n迭代公式为：\n$$x_{n+1} = x_{n} - \\frac{\\cos(x_{n}) - x_{n}^{3}}{-\\sin(x_{n}) - 3x_{n}^{2}} = x_{n} + \\frac{\\cos(x_{n}) - x_{n}^{3}}{\\sin(x_{n}) + 3x_{n}^{2}}$$\n我们从 $x_{0} = 1$ 开始，并进行迭代，直到结果在 $4$ 位有效数字下保持稳定。所有计算都必须使用弧度。\n\n第 0 次迭代：$x_{0} = 1$。\n$$x_{1} = 1 + \\frac{\\cos(1) - 1^{3}}{\\sin(1) + 3(1)^{2}} \\approx 1 + \\frac{0.540302 - 1}{0.841471 + 3} = 1 + \\frac{-0.459698}{3.841471} \\approx 1 - 0.119668 = 0.880332$$\n\n第 1 次迭代：$x_{1} \\approx 0.880332$。\n$$x_{2} = 0.880332 + \\frac{\\cos(0.880332) - (0.880332)^{3}}{\\sin(0.880332) + 3(0.880332)^{2}} \\approx 0.880332 + \\frac{0.636904 - 0.682220}{0.770956 + 2.325042} = 0.880332 + \\frac{-0.045316}{3.095998} \\approx 0.880332 - 0.014637 = 0.865695$$\n\n第 2 次迭代：$x_{2} \\approx 0.865695$。\n$$x_{3} = 0.865695 + \\frac{\\cos(0.865695) - (0.865695)^{3}}{\\sin(0.865695) + 3(0.865695)^{2}} \\approx 0.865695 + \\frac{0.647963 - 0.648834}{0.761066 + 2.248281} = 0.865695 + \\frac{-0.000871}{3.009347} \\approx 0.865695 - 0.000289 = 0.865406$$\n为了检查一致性，我们在余下的步骤中使用更高的精度。\n$x_2 \\approx 0.86569529$\n$x_3 \\approx 0.86547407$\n\n第 3 次迭代：$x_{3} \\approx 0.86547407$。\n$$x_{4} = 0.86547407 + \\frac{\\cos(0.86547407) - (0.86547407)^{3}}{\\sin(0.86547407) + 3(0.86547407)^{2}} \\approx 0.86547407 + \\frac{-2.05 \\times 10^{-7}}{3.008351} \\approx 0.86547407 - 6.81 \\times 10^{-8} = 0.86547400$$\n\n比较四舍五入到 $4$ 位有效数字的迭代值：\n- $x_{2} \\approx 0.8657$\n- $x_{3} \\approx 0.8655$\n- $x_{4} \\approx 0.8655$\n\n在第三次和第四次迭代之间，$0.8655$ 这个值是一致的。因此，保留 $4$ 位有效数字的唯一实根是 $0.8655$。", "answer": "$$\\boxed{0.8655}$$", "id": "3164859"}, {"introduction": "理论上完美的数学公式在有限精度的计算机上执行时，可能会遇到意想不到的“灾难”。其中一个典型问题是“灾难性相消”（catastrophic cancellation），即两个几乎相等的数相减导致有效数字的大量损失。本练习 [@problem_id:3164945] 聚焦于函数 $f(x)=\\sqrt{1+x}-\\sqrt{1-x}-\\alpha$，它在 $x$ 趋近于零时会面临严重的数值不稳定性。你将通过巧妙的代数变换，学会如何重写表达式以避免灾难性相消，从而确保计算结果的准确性。这个技巧是编写高质量科学计算代码的基本功。", "problem": "考虑定义在 $x \\in (-1,1)$ 上的非线性函数 $f(x)=\\sqrt{1+x}-\\sqrt{1-x}-\\alpha$，其中 $\\alpha$ 是一个实数参数。在计算科学导论中，非线性求根问题通常需要在计算接近 $x=0$ 的表达式时，仔细处理数值抵消问题。您的任务是：\n\n1. 仅使用代数恒等式和实值平方根的标准性质，推导 $f(x)$ 的一个精确代数重排形式，以避免在 $|x|$ 很小时发生灾难性抵消。通过讨论重排形式如何改变计算中所涉及项的大小，解释为什么该形式能提高数值稳定性。\n\n2. 将方程 $f(x)=0$ 视为区间 $(-1,1)$ 上的一个求根问题，使用重排后的形式显式地解出以 $\\alpha$ 表示的 $x$。证明所选分支的合理性，包括对 $\\alpha$ 的任何必要约束和单调性论证，并确保您的推导过程不会重新引入对抵消敏感的步骤。\n\n将您的最终答案表示为根 $x^{\\star}(\\alpha)$ 的单一闭式解析表达式，并尽可能简化。无需四舍五入，不涉及单位。", "solution": "### 第1部分：$f(x)$的代数重排\n\n函数由 $f(x)=\\sqrt{1+x}-\\sqrt{1-x}-\\alpha$ 给出。当 $x$ 非常接近 $0$ 时，$\\sqrt{1+x}$ 和 $\\sqrt{1-x}$ 都非常接近 $1$，它们的差值会导致浮点运算中因灾难性相消而产生精度的显著损失。\n\n为了推导一个数值稳定的形式，我们将平方根之差的分子和分母同乘以其共轭表达式 $\\sqrt{1+x}+\\sqrt{1-x}$。这将有问题的减法运算转化为加法运算。\n\n$f(x) = \\left(\\sqrt{1+x}-\\sqrt{1-x}\\right) \\frac{\\sqrt{1+x}+\\sqrt{1-x}}{\\sqrt{1+x}+\\sqrt{1-x}} - \\alpha$\n\n使用恒等式 $(a-b)(a+b) = a^2-b^2$，分子变为：\n$(\\sqrt{1+x})^2 - (\\sqrt{1-x})^2 = (1+x) - (1-x) = 2x$\n\n因此，重排后的函数为：\n$f(x) = \\frac{2x}{\\sqrt{1+x}+\\sqrt{1-x}} - \\alpha$\n\n对于小的 $|x|$，这种形式在数值上更优。原始表达式涉及两个趋近于 $1$ 的量的相减。重排后表达式的分母则涉及这两个相同量的相加。当 $x \\to 0$ 时，其和趋近于 $1+1=2$。两个正数的相加是数值稳定的运算，从而避免了灾难性抵消并保持了相对精度。\n\n### 第2部分：求根问题的显式解\n\n我们需要求解方程 $f(x)=0$ 的根 $x$，我们将其记为 $x^{\\star}$。我们可以同时使用方程的原始形式和重排形式来求解。\n\n原始形式给出：\n$1) \\quad \\sqrt{1+x^{\\star}} - \\sqrt{1-x^{\\star}} = \\alpha$\n\n重排形式给出：\n$2) \\quad \\frac{2x^{\\star}}{\\sqrt{1+x^{\\star}}+\\sqrt{1-x^{\\star}}} = \\alpha$\n\n首先，我们分析函数 $g(x) = \\sqrt{1+x}-\\sqrt{1-x}$ 来确定 $\\alpha$ 的有效范围。其导数为 $g'(x) = \\frac{1}{2\\sqrt{1+x}} + \\frac{1}{2\\sqrt{1-x}}$。对于 $x \\in (-1,1)$，两项均为正，因此 $g'(x)  0$。这意味着 $g(x)$ 在其定义域上是严格单调递增的。因此对于 $g(x)$ 值域内的任何 $\\alpha$，都存在一个唯一的解 $x^{\\star}$。\n\n通过计算在定义域边界处的极限来求得值域：\n$\\lim_{x\\to -1^+} g(x) = \\sqrt{0} - \\sqrt{2} = -\\sqrt{2}$\n$\\lim_{x\\to 1^-} g(x) = \\sqrt{2} - \\sqrt{0} = \\sqrt{2}$\n由于 $g(x)$ 是连续且严格单调递增的，其值域为 $(-\\sqrt{2}, \\sqrt{2})$。因此，当且仅当 $\\alpha \\in (-\\sqrt{2}, \\sqrt{2})$ 时，存在唯一的解 $x^{\\star} \\in (-1,1)$。此外，注意到 $g(0) = 0$。由于 $g(x)$ 是递增的，如果 $\\alpha > 0$，解 $x^{\\star}$ 必须大于 $0$。如果 $\\alpha  0$，解 $x^{\\star}$ 必须小于 $0$。因此，$\\text{sgn}(x^{\\star}) = \\text{sgn}(\\alpha)$。\n\n现在我们求解 $x^{\\star}$。将方程 $(1)$ 和 $(2)$ 结合起来。从(2)得到 $\\sqrt{1+x^{\\star}}+\\sqrt{1-x^{\\star}} = \\frac{2x^{\\star}}{\\alpha}$ (假设 $\\alpha \\neq 0$)。将这个表达式与方程(1)相加：\n$( \\sqrt{1+x^{\\star}} - \\sqrt{1-x^{\\star}} ) + ( \\sqrt{1+x^{\\star}} + \\sqrt{1-x^{\\star}} ) = \\alpha + \\frac{2x^{\\star}}{\\alpha}$\n$2\\sqrt{1+x^{\\star}} = \\alpha + \\frac{2x^{\\star}}{\\alpha}$\n\n两边平方：\n$4(1+x^{\\star}) = \\left(\\alpha + \\frac{2x^{\\star}}{\\alpha}\\right)^2 = \\alpha^2 + 2(\\alpha)\\left(\\frac{2x^{\\star}}{\\alpha}\\right) + \\left(\\frac{2x^{\\star}}{\\alpha}\\right)^2$\n$4+4x^{\\star} = \\alpha^2 + 4x^{\\star} + \\frac{4(x^{\\star})^2}{\\alpha^2}$\n\n$4x^{\\star}$ 项在两边抵消：\n$4 = \\alpha^2 + \\frac{4(x^{\\star})^2}{\\alpha^2}$\n$4 - \\alpha^2 = \\frac{4(x^{\\star})^2}{\\alpha^2}$\n\n求解 $(x^{\\star})^2$：\n$(x^{\\star})^2 = \\frac{\\alpha^2 (4-\\alpha^2)}{4}$\n\n现在，我们取平方根：\n$x^{\\star} = \\pm \\sqrt{\\frac{\\alpha^2 (4-\\alpha^2)}{4}} = \\pm \\frac{|\\alpha|\\sqrt{4-\\alpha^2}}{2}$\n\n我们必须选择正确的符号。根据我们的单调性论证，已经确定 $\\text{sgn}(x^{\\star}) = \\text{sgn}(\\alpha)$。\n- 如果 $\\alpha  0$，则 $|\\alpha|=\\alpha$。我们需要 $x^{\\star}0$，所以必须选择正号：$x^{\\star} = +\\frac{\\alpha\\sqrt{4-\\alpha^2}}{2}$。\n- 如果 $\\alpha  0$，则 $|\\alpha|=-\\alpha$。我们需要 $x^{\\star}0$，所以必须选择负号：$x^{\\star} = -\\frac{(-\\alpha)\\sqrt{4-\\alpha^2}}{2} = \\frac{\\alpha\\sqrt{4-\\alpha^2}}{2}$。\n- 如果 $\\alpha = 0$，公式给出 $x^{\\star}=0$，这是正确的，因为 $g(0)=0$。\n\n在所有情况下，解都由相同的表达式给出。最终，根 $x^{\\star}$ 关于 $\\alpha$ 的简化闭式解析表达式为：\n$x^{\\star}(\\alpha) = \\frac{\\alpha\\sqrt{4-\\alpha^2}}{2}$\n\n此推导满足问题的约束。它使用有效的代数步骤来找到精确的解析解，并且该表达式对于 $\\alpha \\in (-\\sqrt{2}, \\sqrt{2})$ 有效，这确保了 $4-\\alpha^2 > 0$ 且根 $x^{\\star}$ 严格位于 $(-1,1)$ 区间内。", "answer": "$$\\boxed{\\frac{\\alpha}{2}\\sqrt{4-\\alpha^2}}$$", "id": "3164945"}, {"introduction": "我们解决的大多数教科书问题都假设函数求值是精确的。但在现实世界中，从物理实验到金融建模，数据往往伴随着噪声。本练习 [@problem_id:3164924] 将你带入一个更真实的场景：在一个含有随机噪声的函数 $f(x)=g(x)+\\epsilon$ 上进行求根。你将通过编程实践，比较一个简单的二分法和一个基于统计思想（平均值之取中位数）的稳健算法在寻找根时的表现。这个练习不仅能让你体验到算法在噪声环境下的脆弱性，更能让你掌握如何通过融合统计学方法来增强数值算法的鲁棒性，这是现代计算科学与数据科学交叉领域的核心议题。", "problem": "您将研究函数评估中随机扰动下求根的鲁棒性。考虑一个确定性目标函数 $g(x)$，它在区间 $[a,b]$上是连续且严格递增的。假设观测值遵循带噪声的测量模型 $f(x)=g(x)+\\epsilon$，其中 $\\epsilon$表示一个均值为零、方差有限的独立同分布随机变量。根是满足 $g(x^{\\star})=0$ 的点 $x^{\\star}$。二分法依赖于介值定理和符号测试，在 $g(a)g(b)0$ 时，通过迭代收缩区间 $[a,b]$ 来逼近根。在存在噪声的情况下，符号测试变得不可靠，这促使我们采用重复采样和鲁棒的聚合方法。\n\n仅使用大数定律和核心定义，实现两种基于二分法的估计器，它们使用从带噪声的评估中导出的符号测试：\n- 策略 A（单样本符号）：在每个函数评估点 $x$，抽取一个 $\\epsilon$ 样本，并使用单个带噪声观测值 $f(x)=g(x)+\\epsilon$ 的符号来决定二分法更新。\n- 策略 B（均值中位数符号）：在每个函数评估点 $x$，形成 $K$ 个组，每组包含 $M$ 个独立的 $\\epsilon$ 样本。在每个组内，计算 $M$ 个带噪声的 $f(x)$ 观测值的平均值。然后取这 $K$ 个组平均值的中位数。使用这个均值中位数估计器的符号来决定二分法更新。\n\n使用具体的目标函数 $g(x)=\\tanh(x)-\\frac{1}{2}$，该函数在 $[-2,2]$上连续且严格递增，并有一个唯一的根 $x^{\\star}=\\operatorname{arctanh}\\!\\left(\\frac{1}{2}\\right)=\\frac{1}{2}\\ln\\!\\left(\\frac{1+\\frac{1}{2}}{1-\\frac{1}{2}}\\right)=\\frac{1}{2}\\ln(3)$。在整个过程中，使用初始区间 $[a,b]=[-2,2]$。设噪声为高斯噪声，$\\epsilon\\sim\\mathcal{N}(0,\\sigma^{2})$。所有随机抽样必须由一个伪随机数生成器产生，该生成器在开始时用固定的种子 $20231105$ 初始化一次，之后不再重置种子，以确保确定性的可复现性。\n\n实现一个执行恰好 $L$ 次迭代的二分法程序。在每次迭代中，计算中点 $m=\\tfrac{a+b}{2}$。使用策略 A 或策略 B 估计 $f(m)$ 的符号，并根据常规的二分法逻辑更新区间：如果左端点和中点的估计符号相反（其乘积为非正），则设置 $b\\leftarrow m$，否则设置 $a\\leftarrow m$ 并将存储的左端点符号更新为中点的符号。经过 $L$ 次迭代后，输出中点 $\\hat{x}$作为估计的根。\n\n使用以下测试套件。对于每种情况，运行两种策略并报告绝对误差 $e=\\lvert\\hat{x}-x^{\\star}\\rvert$：\n- 情况 1（基准，无噪声）：$\\sigma=0$，$L=30$，对于策略 B 使用 $K=9$，$M=5$。\n- 情况 2（理想情况，小噪声）：$\\sigma=0.05$，$L=30$，对于策略 B 使用 $K=9$，$M=5$。\n- 情况 3（中等噪声）：$\\sigma=0.2$，$L=35$，对于策略 B 使用 $K=11$，$M=9$。\n- 情况 4（较大噪声，更鲁棒的聚合）：$\\sigma=0.4$，$L=40$，对于策略 B 使用 $K=21$，$M=9$。\n\n您的程序必须：\n- 实现 $g(x)=\\tanh(x)-\\frac{1}{2}$、带噪声的评估 $f(x)=g(x)+\\epsilon$（其中 $\\epsilon\\sim\\mathcal{N}(0,\\sigma^{2})$）以及上述两种符号估计策略。\n- 使用初始区间 $[-2,2]$，每次运行执行恰好 $L$ 次二分迭代。\n- 使用一个伪随机数生成器，在程序开始时用种子 $20231105$ 初始化一次。\n- 对于四种情况中的每一种，计算策略 A 和策略 B 的绝对误差，记为 $e_{\\text{A}}$ 和 $e_{\\text{B}}$。\n- 生成单行输出，包含按以下顺序排列的 8 个数字，每个数字四舍五入到 6 位小数：$[e_{\\text{A},1},e_{\\text{B},1},e_{\\text{A},2},e_{\\text{B},2},e_{\\text{A},3},e_{\\text{B},3},e_{\\text{A},4},e_{\\text{B},4}]$。\n\n不涉及物理单位。不使用角度。所有输出均为实数。最终输出格式必须是严格的一行，即一个用方括号括起来的逗号分隔列表，其中每个浮点数都按要求四舍五入到 6 位小数。您的解决方案必须是一个用现代编程语言编写的完整、可运行的程序。", "solution": "该问题要求实现并比较两种基于二分法的求根策略，这些策略应用于一个其评估值被加性高斯噪声污染的函数。目标是评估这些策略在不同噪声水平下的鲁棒性。\n\n### 问题阐述\n我们的任务是找到一个确定性目标函数 $g(x)$ 的根 $x^{\\star}$，该根定义为满足 $g(x^{\\star}) = 0$ 的点。但是，我们无法直接评估 $g(x)$。取而代之的是，我们观测到带噪声的测量值 $f(x) = g(x) + \\epsilon$，其中 $\\epsilon$ 是从均值为 $0$、标准差为 $\\sigma$ 的高斯分布 $\\mathcal{N}(0, \\sigma^2)$ 中抽取的随机变量。求根算法必须在这些带噪声的观测值上运行。\n\n具体的目标函数是 $g(x) = \\tanh(x) - \\frac{1}{2}$。该函数是连续且严格递增的。唯一的根 $x^{\\star}$ 由 $\\tanh(x^{\\star}) = \\frac{1}{2}$ 给出，解得 $x^{\\star} = \\operatorname{arctanh}(\\frac{1}{2}) = \\frac{1}{2}\\ln(3)$。根的搜索在初始区间 $[a_0, b_0] = [-2, 2]$ 内进行。我们可以验证 $g(-2)  0$ 且 $g(2) > 0$，因此根据介值定理，可以保证在该区间内存在一个根。\n\n### 带噪声符号测试的二分法\n标准二分法依赖于函数在区间 $[a, b]$ 端点及其 中点 $m = \\frac{a+b}{2}$ 处的符号。如果 $g(a)$ 和 $g(m)$ 的符号相反，则根必定位于 $[a, m]$ 内，因此我们设置 $b \\leftarrow m$。否则，根必定位于 $[m, b]$ 内，我们设置 $a \\leftarrow m$。这个过程在每次迭代中都将区间长度减半，从而保证了收敛。\n\n在有噪声的环境中，单个观测值 $f(x) = g(x) + \\epsilon$ 的符号可能不等于真实函数值 $g(x)$ 的符号，特别是当 $|g(x)|$ 相对于噪声幅度 $\\sigma$ 较小时。一次错误的符号测试可能导致二分法算法丢弃包含真实根的区间一半，从而影响收敛。\n\n指定的算法执行恰好 $L$ 次迭代。在每一步中，都会维持一个参考符号，初始时对应于左端点 $a$。设其为 $s_a$。中点是 $m = \\frac{a+b}{2}$，它的符号 $s_m$ 是从带噪声的数据中估计出来的。更新规则如下：\n- 如果 $s_a \\cdot s_m \\le 0$，则符号相反（或其中一个为零），因此通过设置 $b \\leftarrow m$ 使新区间变为 $[a, m]$。\n- 否则，新区间变为 $[m, b]$，通过设置 $a \\leftarrow m$ 实现。在这种情况下，新左端点 $m$ 的参考符号被更新为 $s_m$，因此我们设置 $s_a \\leftarrow s_m$。\n\n问题的核心在于设计两种不同的策略来估计函数在给定点 $x$ 处的符号。\n\n### 符号估计策略\n\n#### 策略 A：单样本符号\n这是最直接的方法。为了估计 $g(x)$ 的符号，我们进行一次带噪声的测量 $f(x) = g(x) + \\epsilon$，其中 $\\epsilon \\sim \\mathcal{N}(0, \\sigma^2)$，并使用其符号。\n$$\n\\text{sign}_{\\text{A}}(x) = \\text{sign}(g(x) + \\epsilon)\n$$\n这种方法计算成本低，但极易受噪声影响。如果 $|g(x)|$ 不大，一次大的波动 $\\epsilon$ 就可以轻易地翻转观测值的符号。\n\n#### 策略 B：均值中位数符号\n该策略采用统计聚合来获得更鲁棒的符号估计。其过程如下：\n1.  在给定点 $x$，我们抽取 $K \\times M$ 个独立的噪声样本，$\\epsilon_{ij}$ for $i=1, \\dots, K$ and $j=1, \\dots, M$。\n2.  这些样本被用来形成 $K$ 组，每组包含 $M$ 个带噪声的观测值：$f_{ij}(x) = g(x) + \\epsilon_{ij}$。\n3.  对于每个组 $i$，我们计算样本均值：\n    $$\n    \\bar{f}_i(x) = \\frac{1}{M} \\sum_{j=1}^{M} f_{ij}(x) = g(x) + \\frac{1}{M} \\sum_{j=1}^{M} \\epsilon_{ij}\n    $$\n    根据大数定律，当 $M \\to \\infty$ 时，这个样本均值 $\\bar{f}_i(x)$ 收敛于观测值的期望值，即 $g(x)$（因为 $E[\\epsilon] = 0$）。这个均值的方差减少了 $M$ 倍：$\\text{Var}(\\bar{f}_i(x)) = \\sigma^2 / M$。\n4.  然后我们计算这 $K$ 个组均值的中位数：\n    $$\n    \\hat{g}(x) = \\text{median}\\{\\bar{f}_1(x), \\dots, \\bar{f}_K(x)\\}\n    $$\n    中位数提供了鲁棒性。即使由于随机因素，某些组均值远离 $g(x)$，只要大多数组均值接近 $g(x)$，中位数就很可能接近 $g(x)$。\n5.  最终的符号估计是这个均值中位数估计器的符号：\n    $$\n    \\text{sign}_{\\text{B}}(x) = \\text{sign}(\\hat{g}(x))\n    $$\n这种策略计算量更大（每次符号测试需要 $K \\times M$ 次评估），但预计能提供更强的抗噪声能力。\n\n### 实现与执行\n该解决方案使用 Python 的 `numpy` 库实现。一个伪随机数生成器用种子 $20231105$ 初始化，以确保随机数序列是确定性的，并且结果是可复现的。\n\n对于指定的四个测试用例中的每一个：\n- 为每种策略调用一个二分求解器函数。该函数实现了上述描述的固定迭代次数 $L$ 的迭代逻辑。\n- 符号估计由策略 A 和策略 B 的专用函数执行，这些函数被传递给求解器。\n- 经过 $L$ 次迭代后，最终区间的中点被作为估计的根 $\\hat{x}$。\n- 计算绝对误差 $e = |\\hat{x} - x^{\\star}|$，其中 $x^{\\star} = \\frac{1}{2}\\ln(3)$。\n\n对于噪声 $\\sigma$ 较高的情形，参数 $K、M$ 和 $L$ 的值会增加。这是一个合理的设计，因为当噪声更有可能导致错误步骤时，需要更多的样本来进行鲁棒估计（更大的 $K、M$），也需要更多的迭代来精确解（更大的 $L$）。我们预计策略 B 将产生比策略 A 小得多的误差，尤其是在 $\\sigma$ 值较大时。对于无噪声情况（$\\sigma=0$），两种策略都简化为标准二分法，应产生相同的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef g(x: float) - float:\n    \"\"\"The deterministic target function g(x) = tanh(x) - 1/2.\"\"\"\n    return np.tanh(x) - 0.5\n\ndef estimate_sign_A(x: float, sigma: float, rng: np.random.Generator, K: int = None, M: int = None) - int:\n    \"\"\"\n    Estimates the sign of g(x) using a single noisy sample (Strategy A).\n    K and M are unused but included for a consistent function signature.\n    \"\"\"\n    if sigma == 0.0:\n        f_x = g(x)\n    else:\n        noise = rng.normal(loc=0.0, scale=sigma)\n        f_x = g(x) + noise\n    return np.sign(f_x)\n\ndef estimate_sign_B(x: float, sigma: float, rng: np.random.Generator, K: int, M: int) - int:\n    \"\"\"\n    Estimates the sign of g(x) using the median-of-means estimator (Strategy B).\n    \"\"\"\n    if sigma == 0.0:\n        return np.sign(g(x))\n    \n    g_x = g(x)\n    \n    # Generate KxM noise samples efficiently in a single array\n    noises = rng.normal(loc=0.0, scale=sigma, size=(K, M))\n    \n    # Compute K group means\n    group_means = g_x + np.mean(noises, axis=1)\n    \n    # Compute the median of the K group means\n    median_of_means = np.median(group_means)\n    \n    return np.sign(median_of_means)\n\ndef bisection_solver(\n    L: int, \n    sigma: float, \n    sign_strategy, \n    rng: np.random.Generator, \n    K: int, \n    M: int\n) - float:\n    \"\"\"\n    Performs bisection for L iterations using a given sign estimation strategy.\n    \n    Args:\n        L: Number of iterations.\n        sigma: Standard deviation of the noise.\n        sign_strategy: The function to use for sign estimation (estimate_sign_A or estimate_sign_B).\n        rng: The pseudorandom number generator.\n        K: Number of groups for Strategy B.\n        M: Number of samples per group for Strategy B.\n\n    Returns:\n        The estimated root after L iterations.\n    \"\"\"\n    a, b = -2.0, 2.0\n    \n    # Estimate the sign at the initial left endpoint\n    sign_a = sign_strategy(a, sigma, rng, K=K, M=M)\n    \n    for _ in range(L):\n        m = (a + b) / 2.0\n        \n        # If midpoint is the root, stop early (unlikely with float arithmetic)\n        if m == a or m == b:\n            break\n            \n        sign_m = sign_strategy(m, sigma, rng, K=K, M=M)\n        \n        # Bisection update rule\n        if sign_a * sign_m = 0:\n            b = m\n        else:\n            a = m\n            sign_a = sign_m\n            \n    return (a + b) / 2.0\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Initialize a single random number generator for reproducibility\n    rng = np.random.default_rng(20231105)\n    \n    # Define the true root\n    x_star = 0.5 * np.log(3.0)\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'sigma': 0.0, 'L': 30, 'K': 9, 'M': 5},\n        {'sigma': 0.05, 'L': 30, 'K': 9, 'M': 5},\n        {'sigma': 0.2, 'L': 35, 'K': 11, 'M': 9},\n        {'sigma': 0.4, 'L': 40, 'K': 21, 'M': 9},\n    ]\n\n    results = []\n    for case in test_cases:\n        sigma, L, K, M = case['sigma'], case['L'], case['K'], case['M']\n        \n        # Run Strategy A\n        x_hat_A = bisection_solver(L, sigma, estimate_sign_A, rng, K, M)\n        e_A = abs(x_hat_A - x_star)\n        \n        # Run Strategy B\n        x_hat_B = bisection_solver(L, sigma, estimate_sign_B, rng, K, M)\n        e_B = abs(x_hat_B - x_star)\n        \n        results.extend([e_A, e_B])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3164924"}]}