{"hands_on_practices": [{"introduction": "单纯形法在几何上对应于在可行多面体的顶点之间移动的过程。这个练习将带你通过代数方法，系统地找出所有这些顶点，即基本可行解 (Basic Feasible Solutions, BFS)。掌握这一基本功，是理解单纯形算法如何在解空间中进行搜索的关键第一步。[@problem_id:2180575]", "problem": "考虑一个包含两个决策变量 $x_1$ 和 $x_2$ 的线性规划问题。该问题的可行域由以下约束条件组定义：\n$$\n\\begin{align*}\n3x_1 + 2x_2 \\le 12 \\\\\nx_1 + 4x_2 \\le 10 \\\\\nx_1 \\ge 0 \\\\\nx_2 \\ge 0\n\\end{align*}\n$$\n该系统的一个基本解是通过将其转换为标准型并将特定数量的变量设为零来求得的。如果一个基本解也满足所有非负约束条件，则称其为基本可行解。\n\n你的任务是用代数方法确定该系统的所有不同基本可行解。然后，计算所有这些基本可行解的 $x_1$ 坐标之和。将你的最终答案表示为最简形式的精确分数。", "solution": "引入松弛变量 $s_{1}$ 和 $s_{2}$ 将不等式转换为等式，得到标准型\n$$\n\\begin{aligned}\n3x_{1}+2x_{2}+s_{1}=12,\\\\\nx_{1}+4x_{2}+s_{2}=10,\n\\end{aligned}\n$$\n其中 $x_{1},x_{2},s_{1},s_{2}\\geq 0$。这里有 $2$ 个方程，因此一个基本解是通过选择任意 $2$ 个变量作为基变量并将另外 $2$ 个设为零，然后求解得到的。一个基本可行解 (BFS) 额外要求所有变量都为非负。\n\n1. 基 $\\{s_{1},s_{2}\\}$：令 $x_{1}=0$，$x_{2}=0$。则 $s_{1}=12$，$s_{2}=10$。这是可行的，得到 $(x_{1},x_{2})=(0,0)$。\n\n2. 基 $\\{x_{1},s_{1}\\}$：令 $x_{2}=0$，$s_{2}=0$。由 $x_{1}+4x_{2}+s_{2}=10$ 可得 $x_{1}=10$。然后 $3x_{1}+2x_{2}+s_{1}=12$ 得到 $s_{1}=12-3\\cdot 10=-18$。不可行；舍去。\n\n3. 基 $\\{x_{2},s_{1}\\}$：令 $x_{1}=0$，$s_{2}=0$。由 $x_{1}+4x_{2}+s_{2}=10$ 可得 $4x_{2}=10$，所以 $x_{2}=\\frac{5}{2}$。然后 $3x_{1}+2x_{2}+s_{1}=12$ 得到 $s_{1}=12-2\\cdot\\frac{5}{2}=12-5=7\\geq 0$。可行，得到 $(x_{1},x_{2})=(0,\\frac{5}{2})$。\n\n4. 基 $\\{x_{1},s_{2}\\}$：令 $x_{2}=0$，$s_{1}=0$。由 $3x_{1}+2x_{2}+s_{1}=12$ 可得 $3x_{1}=12$，所以 $x_{1}=4$。然后 $x_{1}+4x_{2}+s_{2}=10$ 得到 $s_{2}=10-4=6\\geq 0$。可行，得到 $(x_{1},x_{2})=(4,0)$。\n\n5. 基 $\\{x_{2},s_{2}\\}$：令 $x_{1}=0$，$s_{1}=0$。由 $3x_{1}+2x_{2}+s_{1}=12$ 可得 $2x_{2}=12$，所以 $x_{2}=6$。然后 $x_{1}+4x_{2}+s_{2}=10$ 得到 $s_{2}=10-24=-14$。不可行；舍去。\n\n6. 基 $\\{x_{1},x_{2}\\}$：令 $s_{1}=0$，$s_{2}=0$。解方程组\n$$\n\\begin{aligned}\n3x_{1}+2x_{2}=12,\\\\\nx_{1}+4x_{2}=10.\n\\end{aligned}\n$$\n将第二个方程乘以 $3$ 得到 $3x_{1}+12x_{2}=30$，再减去第一个方程得到 $10x_{2}=18$，因此 $x_{2}=\\frac{9}{5}$。代入 $x_{1}+4x_{2}=10$ 得到 $x_{1}=10-4\\cdot\\frac{9}{5}=\\frac{14}{5}$。两者都非负，所以 $(x_{1},x_{2})=\\left(\\frac{14}{5},\\frac{9}{5}\\right)$ 是可行的。\n\n因此，不同的基本可行解为 $(0,0)$、$\\left(0,\\frac{5}{2}\\right)$、$(4,0)$ 和 $\\left(\\frac{14}{5},\\frac{9}{5}\\right)$。$x_{1}$ 坐标之和为\n$$\n0+0+4+\\frac{14}{5}=\\frac{20}{5}+\\frac{14}{5}=\\frac{34}{5}.\n$$", "answer": "$$\\boxed{\\frac{34}{5}}$$", "id": "2180575"}, {"introduction": "理论必须与实践相结合，线性规划正是在资源优化问题中大显身手的强大工具。本练习以经典的“饮食问题”为背景，要求你构建一个成本最小化模型。更进一步，你将通过编程进行灵敏度分析，探索当食物价格变化时最优饮食策略如何相应调整，这是真实世界建模中的一项核心技能。[@problem_id:2406884]", "problem": "考虑一个成本最小化的饮食模型，该模型被构建为一个针对五种食物的线性规划（LP）问题：牛油果、鸡胸肉、黑豆、白米和西兰花。设决策变量为以“份”为单位的非负消耗量，记为 $x_{A}$ (牛油果)、$x_{C}$ (鸡肉)、$x_{B}$ (黑豆)、$x_{R}$ (白米) 和 $x_{Br}$ (西兰花)。每份的营养成分贡献如下：牛油果提供 $240$ 千卡热量、$3$ 克蛋白质、$22$ 克脂肪和 $10$ 克纤维；鸡肉提供 $200$ 千卡热量、$35$ 克蛋白质、$5$ 克脂肪和 $0$ 克纤维；黑豆提供 $180$ 千卡热量、$12$ 克蛋白质、$1$ 克脂肪和 $12$ 克纤维；白米提供 $220$ 千卡热量、$4$ 克蛋白质、$1$ 克脂肪和 $1$ 克纤维；西兰花提供 $55$ 千卡热量、$4$ 克蛋白质、$0$ 克脂肪和 $5$ 克纤维。每日最低需求量为 $2000$ 千卡热量、$50$ 克蛋白质、$44$ 克脂肪和 $30$ 克纤维。需要最小化的总成本为 $c_{A} x_{A} + 2.5 x_{C} + 1.2 x_{B} + 0.6 x_{R} + 0.8 x_{Br}$，其中 $c_{A} \\ge 0$ 是每份牛油果的价格，其他价格是固定的，单位为每份相同的货币单位。模型为\n$$\n\\min_{x_{A},x_{C},x_{B},x_{R},x_{Br} \\ge 0} \\; c_{A} x_{A} + 2.5 x_{C} + 1.2 x_{B} + 0.6 x_{R} + 0.8 x_{Br}\n$$\n满足营养需求的约束条件\n$$\n240 x_{A} + 200 x_{C} + 180 x_{B} + 220 x_{R} + 55 x_{Br} \\ge 2000,\n$$\n$$\n3 x_{A} + 35 x_{C} + 12 x_{B} + 4 x_{R} + 4 x_{Br} \\ge 50,\n$$\n$$\n22 x_{A} + 5 x_{C} + 1 x_{B} + 1 x_{R} + 0 x_{Br} \\ge 44,\n$$\n$$\n10 x_{A} + 0 x_{C} + 12 x_{B} + 1 x_{R} + 5 x_{Br} \\ge 30.\n$$\n所有份量均为无量纲的份数计数，成本以每份一致的货币单位计算。对于每个指定的牛油果价格 $c_{A}$，该模型都有一个明确定义的最优解。\n\n任务：通过为一组牛油果价格 $c_{A}$ 求解上述问题，对牛油果的目标系数 $c_{A}$ 进行敏感性分析，并在每种情况下，返回最优牛油果数量 $x_{A}^{\\star}$（以份为单位）和最优最低总成本 $z^{\\star}$（以相同的货币单位）。报告 $x_{A}^{\\star}$ 和 $z^{\\star}$，四舍五入到 $4$ 位小数。\n\n待分析的牛油果价格测试集：\n- 正常路径中等价格：$c_{A} = 1.00$。\n- 低价（趋向于以牛油果为主的边缘情况）：$c_{A} = 0.50$。\n- 低于可能发生基变得中高价格：$c_{A} = 10.00$。\n- 高于可能发生基变得高价格：$c_{A} = 12.00$。\n- 非常高的价格（趋向于排除牛油果的边缘情况）：$c_{A} = 25.00$。\n\n最终输出格式：您的程序应生成单行输出，其中包含结果，格式为一个由逗号分隔的数对 $[x_{A}^{\\star},z^{\\star}]$ 列表，并用方括号括起来，顺序与测试集完全相同。每个数字四舍五入到 $4$ 位小数。例如：$[[0.0000,123.4567],[1.2345,67.8901]]$。", "solution": "首先执行问题验证，此为强制步骤。\n\n第一步：提取已知信息\n\n- **决策变量**：以“份”为单位的非负消耗量：$x_{A}$ (牛油果)、$x_{C}$ (鸡肉)、$x_{B}$ (黑豆)、$x_{R}$ (白米)、$x_{Br}$ (西兰花)，其中 $x_{A}, x_{C}, x_{B}, x_{R}, x_{Br} \\ge 0$。\n- **每份的营养贡献**：\n    - 牛油果：$240$ 千卡热量、$3$ 克蛋白质、$22$ 克脂肪、$10$ 克纤维。\n    - 鸡肉：$200$ 千卡热量、$35$ 克蛋白质、$5$ 克脂肪、$0$ 克纤维。\n    - 黑豆：$180$ 千卡热量、$12$ 克蛋白质、$1$ 克脂肪、$12$ 克纤维。\n    - 白米：$220$ 千卡热量、$4$ 克蛋白质、$1$ 克脂肪、$1$ 克纤维。\n    - 西兰花：$55$ 千卡热量、$4$ 克蛋白质、$0$ 克脂肪、$5$ 克纤维。\n- **每日最低需求**：$\\ge 2000$ 千卡热量、$\\ge 50$ 克蛋白质、$\\ge 44$ 克脂肪、$\\ge 30$ 克纤维。\n- **目标函数**：最小化总成本 $c_{A} x_{A} + 2.5 x_{C} + 1.2 x_{B} + 0.6 x_{R} + 0.8 x_{Br}$，其中 $c_{A} \\ge 0$。\n- **线性规划模型**：\n$$\n\\min_{x_{A},x_{C},x_{B},x_{R},x_{Br} \\ge 0} \\; c_{A} x_{A} + 2.5 x_{C} + 1.2 x_{B} + 0.6 x_{R} + 0.8 x_{Br}\n$$\n约束条件：\n$$\n240 x_{A} + 200 x_{C} + 180 x_{B} + 220 x_{R} + 55 x_{Br} \\ge 2000\n$$\n$$\n3 x_{A} + 35 x_{C} + 12 x_{B} + 4 x_{R} + 4 x_{Br} \\ge 50\n$$\n$$\n22 x_{A} + 5 x_{C} + 1 x_{B} + 1 x_{R} + 0 x_{Br} \\ge 44\n$$\n$$\n10 x_{A} + 0 x_{C} + 12 x_{B} + 1 x_{R} + 5 x_{Br} \\ge 30\n$$\n- **任务**：对于给定的一组 $c_{A}$ 值，找到最优的牛油果数量 $x_{A}^{\\star}$ 和最优的最小成本 $z^{\\star}$，四舍五入到 $4$ 位小数。\n- **测试集**：$c_{A} \\in \\{1.00, 0.50, 10.00, 12.00, 25.00\\}$。\n\n第二步：使用提取的已知信息进行验证\n\n该问题是一个经典的“饮食问题”，被构建为一个线性规划任务。这是运筹学和计算经济学中一个标准且已得到充分理解的问题。\n\n- **科学依据**：该问题基于成熟的线性规划数学理论。营养数据和饮食要求是合理的，可作为模型的有效基础。它不违反任何科学原则。\n- **适定性**：该问题是一个标准形式的线性规划。由线性不等式交集定义的可行域是凸的且非空。目标函数是线性的。由于成本和决策变量都是非负的，目标函数在可行域上有下界。问题陈述正确地断言，对于每个指定的价格 $c_{A}$，都存在一个明确定义的最优解。\n- **客观性**：该问题以数学精度指定，使用了无歧义的变量、系数和约束。它不含主观陈述。\n\n该问题通过了所有验证标准。它是自洽的、一致的、科学合理的且适定的。\n\n第三步：结论与行动\n\n问题被判定为**有效**。将提供解决方案。\n\n该问题要求解一个线性规划 (LP) 模型的多个实例，每个实例由变量 $x_A$ 的不同成本系数 $c_A$ 定义。这是对目标函数系数的敏感性分析。\n\n该 LP 模型可以用矩阵形式表示。设决策变量向量为 $\\mathbf{x} = [x_{A}, x_{C}, x_{B}, x_{R}, x_{Br}]^T$。目标是最小化总成本 $z = \\mathbf{c}^T \\mathbf{x}$，其中成本向量为 $\\mathbf{c} = [c_{A}, 2.5, 1.2, 0.6, 0.8]^T$。\n\n约束条件的形式为 $\\mathbf{A}\\mathbf{x} \\ge \\mathbf{b}$，其中约束矩阵 $\\mathbf{A}$ 和需求向量 $\\mathbf{b}$ 由以下给出：\n$$\n\\mathbf{A} = \\begin{pmatrix}\n240  200  180  220  55 \\\\\n3  35  12  4  4 \\\\\n22  5  1  1  0 \\\\\n10  0  12  1  5\n\\end{pmatrix},\n\\quad\n\\mathbf{b} = \\begin{pmatrix}\n2000 \\\\\n50 \\\\\n44 \\\\\n30\n\\end{pmatrix}\n$$\n决策变量还必须满足非负性约束 $\\mathbf{x} \\ge \\mathbf{0}$。\n\n为了通过计算解决此问题，我们使用 Python 中 `scipy.optimize` 库的 `linprog` 函数。该函数旨在解决以下形式的最小化问题：\n最小化 $\\mathbf{c}^T \\mathbf{x}$，约束条件为 $\\mathbf{A}_{ub} \\mathbf{x} \\le \\mathbf{b}_{ub}$ 和 $\\mathbf{A}_{eq} \\mathbf{x} = \\mathbf{b}_{eq}$，并对 $\\mathbf{x}$ 有界。\n\n我们问题的约束是“大于或等于”类型，即 $\\mathbf{A}\\mathbf{x} \\ge \\mathbf{b}$。必须将其转换为 `linprog` 函数所要求的“小于或等于”形式。这可以通过将不等式乘以 $-1$ 来实现，从而反转不等号：\n$$\n\\mathbf{A}\\mathbf{x} \\ge \\mathbf{b} \\iff -\\mathbf{A}\\mathbf{x} \\le -\\mathbf{b}\n$$\n因此，我们将向求解器传递 $\\mathbf{A}_{ub} = -\\mathbf{A}$ 和 $\\mathbf{b}_{ub} = -\\mathbf{b}$。非负性约束 $x_i \\ge 0$ 通过将每个变量的 `bounds` 设置为 $(0, \\infty)$ 来处理。\n\n求解算法如下：\n1. 将常数矩阵 $\\mathbf{A}$ 和 $\\mathbf{b}$ 定义为 NumPy 数组。\n2. 定义牛油果价格 $c_A$ 的测试值列表：$\\{1.00, 0.50, 10.00, 12.00, 25.00\\}$。\n3. 遍历测试集中的每个 $c_A$ 值。\n4. 在每次迭代中，构建相应的成本向量 $\\mathbf{c}$。\n5. 使用成本向量 $\\mathbf{c}$、转换后的约束矩阵 $-\\mathbf{A}$、转换后的需求向量 $-\\mathbf{b}$ 以及非负性边界调用 `scipy.optimize.linprog`。`highs` 方法是求解器的一个现代、高效且稳健的选择。\n6. 从求解器返回的结果对象中，提取最优的牛油果数量 $x_A^\\star$（即解向量 $\\mathbf{x}^\\star$ 的第一个元素）和最优的最小成本 $z^\\star$。\n7. 存储数对 $[x_A^\\star, z^\\star]$。\n8. 处理完所有 $c_A$ 值后，将收集到的结果格式化为指定的单个字符串：一个数对列表，其中每个数值都四舍五入到 $4$ 位小数。\n此过程系统地执行了所要求的敏感性分析，并生成了所需的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves a cost-minimization diet problem for a range of avocado prices.\n\n    The problem is formulated as a Linear Program (LP) and solved using\n    scipy.optimize.linprog.\n    \"\"\"\n    \n    # Define the constant constraint matrix A and requirements vector b.\n    # The columns correspond to [avocado, chicken, beans, rice, broccoli].\n    # The rows correspond to [kilocalories, protein, fat, fiber].\n    A_mat = np.array([\n        [240.0, 200.0, 180.0, 220.0, 55.0],  # Kilocalories\n        [3.0,   35.0,  12.0,  4.0,   4.0],   # Protein (g)\n        [22.0,  5.0,   1.0,   1.0,   0.0],   # Fat (g)\n        [10.0,  0.0,   12.0,  1.0,   5.0]    # Fiber (g)\n    ])\n    \n    # Daily minimum requirements vector b.\n    b_vec = np.array([2000.0, 50.0, 44.0, 30.0])\n    \n    # Fixed costs for non-avocado foods (per serving).\n    # [chicken, beans, rice, broccoli]\n    c_others = [2.5, 1.2, 0.6, 0.8]\n    \n    # Test suite of avocado prices (c_A) to be analyzed.\n    test_cases = [1.00, 0.50, 10.00, 12.00, 25.00]\n    \n    results = []\n    \n    for c_A in test_cases:\n        # Construct the full cost vector c for the current c_A.\n        c_vec = np.array([c_A] + c_others)\n        \n        # The linprog function solves minimization problems with constraints of\n        # the form A_ub @ x = b_ub. Our problem has A @ x >= b, which is\n        # equivalent to -A @ x = -b.\n        # We also enforce non-negativity constraints via the bounds parameter.\n        res = linprog(c=c_vec, \n                      A_ub=-A_mat, \n                      b_ub=-b_vec, \n                      bounds=(0, None), \n                      method='highs')\n        \n        if res.success:\n            # The optimal quantity of avocado (x_A) is the first element of the solution vector.\n            x_A_star = res.x[0]\n            # The optimal cost (z*) is the function value at the optimum.\n            z_star = res.fun\n            results.append([x_A_star, z_star])\n        else:\n            # The problem statement guarantees a solution exists, so this path\n            # should ideally not be taken. We include it for robustness.\n            results.append([float('nan'), float('nan')])\n            \n    # Format the results into the required string format.\n    # e.g., [[x1, z1], [x2, z2], ...] with numbers rounded to 4 decimal places.\n    formatted_pairs = [f\"[{x:.4f},{z:.4f}]\" for x, z in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_pairs)}]\")\n\nsolve()\n```", "id": "2406884"}, {"introduction": "在掌握了基本应用后，我们来探讨一个更深入的计算科学话题：算法效率。虽然单纯形法在实践中通常很高效，但其在最坏情况下可能需要指数时间。本练习将指导你构建著名的克莱-明蒂 (Klee-Minty) 立方体实例，通过编程实践，亲眼见证这一现象，并比较不同枢轴规则（如 Bland’s rule 和最陡边规则）的性能差异，从而深化对算法行为分析的理解。[@problem_id:3154344]", "problem": "要求您构建并分析一个三维 Klee-Minty 立方体线性规划（LP）实例，并比较单纯形法中的两种主元选择规则。首先从线性规划（LP）和单纯形法的核心定义开始。使用以下最大化问题的标准形式：最大化 $c^{\\mathsf{T}} x$，约束条件为 $A x \\le b$ 和 $x \\ge 0$，其中 $A \\in \\mathbb{R}^{m \\times n}$，$b \\in \\mathbb{R}^{m}$，$c \\in \\mathbb{R}^{n}$。引入松弛变量将不等式转换为等式，从而在原点处得到一个由松弛变量构成的基。使用单纯形法的基本原理：(i) 基本可行解由约束矩阵的 $m$ 个线性无关列构成的基确定，(ii) 判别数通过 $r_j = c_j - c_B^{\\mathsf{T}} B^{-1} a_j$ 决定最大化问题的进基变量，(iii) 步长由最小比率检验确定，该检验对 $B^{-1} b$ 和进基变量列 $a_j$ 的方向 $B^{-1} a_j$ 进行操作。\n\n通过设置 $n = 3$，$m = 3$ 以及以下矩阵来构建三维 Klee-Minty 立方体：\n$$\nA = \\begin{bmatrix}\n1  0  0 \\\\\n2  1  0 \\\\\n4  2  1\n\\end{bmatrix},\\quad\nb = \\begin{bmatrix} 2 \\\\ 4 \\\\ 8 \\end{bmatrix}.\n$$\n这是一个下三角、增量缩放的系统，它在几何上扭曲了三维立方体，以迫使单纯形法走上极端的路径。定义一个参数化的目标向量 $c(\\varepsilon)$ 以按字典序打破平局：\n$$\nc(\\varepsilon) = \\begin{bmatrix} \\varepsilon^2 \\\\ \\varepsilon \\\\ 1 \\end{bmatrix},\n$$\n其中 $\\varepsilon \\in (0,1)$。添加松弛变量后，完整的系数矩阵为 $[A \\mid I_3]$，完整的成本向量为 $\\big[c(\\varepsilon)^{\\mathsf{T}}, 0, 0, 0\\big]$。\n\n对此实例实现并执行两次原始单纯形法，使用两种不同的进基变量规则：\n- Bland’s 规则：在所有判别数为严格正的非基变量索引中，选择最小的索引（使用全局排序，其中 $x_1, x_2, x_3$ 的索引为 $1,2,3$，$s_1, s_2, s_3$ 的索引为 $4,5,6$）。对于出基变量，使用标准的最小比率检验，通过选择最小的基索引来打破平局，以保证算法终止。\n- 最陡边规则：在所有判别数 $r_j$ 为严格正的非基变量索引中，计算步进方向 $p = B^{-1} a_j$ 并使用复合方向的欧几里得范数 $\\|d_j\\|_2 = \\sqrt{1 + \\|p\\|_2^2}$（其中的 $1$ 是因为进基变量的单位变化）；选择使得分 $r_j / \\|d_j\\|_2$ 最大化的索引；通过最小索引打破平局。对于出基变量，使用相同的最小比率检验，并以最小索引打破平局。\n\n从原点的基本可行解开始，其中松弛变量为基变量。对于每种主元规则，运行单纯形法，直到没有正的判别数为止。计算达到最优解所需的枢轴变换（基交换）次数。\n\n测试套件。对三个参数值 $\\varepsilon \\in \\{0.5, 0.25, 0.1\\}$ 运行上述过程。对于每个 $\\varepsilon$，计算以下规则的主元变换次数：\n- Bland’s 规则，\n- 最陡边规则。\n\n您的程序必须生成单行输出，其中包含所有测试用例的聚合结果，形式为方括号内以逗号分隔的单个列表。顺序必须为\n$$\n\\big[\\text{bland}(\\varepsilon{=}0.5),\\;\\text{steepest}(\\varepsilon{=}0.5),\\;\\text{bland}(\\varepsilon{=}0.25),\\;\\text{steepest}(\\varepsilon{=}0.25),\\;\\text{bland}(\\varepsilon{=}0.1),\\;\\text{steepest}(\\varepsilon{=}0.1)\\big].\n$$\n所有输出都必须是整数。不涉及物理单位。不使用角度。不使用百分比。\n\n交付成果。提供一个完整的 Python 程序，该程序需构建 Klee-Minty 实例，严格按照规定实现两种主元规则，运行三个测试用例，并以上述确切格式单行打印结果。", "solution": "用户提供了一个来自线性规划和算法分析领域的经典问题。该问题要求实现原始单纯形法来求解一个特定的三维 Klee-Minty 立方体实例。核心任务是比较两种不同进基变量选择策略的性能（以主元变换次数衡量）：Bland’s 规则和最陡边规则。\n\n### 问题建模与方法\n\n一个指定标准形式的线性规划（LP）问题旨在最大化一个线性目标函数，并满足线性不等式约束：\n$$\n\\text{maximize} \\quad z = c^{\\mathsf{T}} x \\\\\n\\text{subject to} \\quad A x \\le b, \\quad x \\ge 0\n$$\n其中 $x \\in \\mathbb{R}^n$ 是决策变量向量，$c \\in \\mathbb{R}^n$ 是成本向量，$A \\in \\mathbb{R}^{m \\times n}$ 是约束矩阵，$b \\in \\mathbb{R}^m$ 是右侧向量。\n\n单纯形法是一种迭代算法，通过从可行多胞体的一个顶点（基本可行解）移动到相邻顶点来求解此类问题，每次移动都会改进（或不恶化）目标函数值。为实现这一过程，通过引入一个松弛变量向量 $s \\in \\mathbb{R}^m$ 将不等式约束 $Ax \\le b$ 转换为等式：\n$$\nA x + I_m s = b, \\quad x \\ge 0, \\quad s \\ge 0\n$$\n增广系统包含 $n+m$ 个变量。一个基本可行解是通过将变量划分为一组 $m$ 个*基*变量和 $n$ 个*非基*变量来找到的。非基变量设为 $0$，基变量的值由方程组确定。设 $B_{idx}$ 为基变量的索引集，$N_{idx}$ 为非基变量的索引集。设 $B$ 是一个矩阵，其列是完整系数矩阵 $[A \\mid I_m]$ 中对应于 $B_{idx}$ 中索引的列。基变量的值由 $x_B = B^{-1}b$ 给出。\n\n单纯形法的每次迭代，称为一次*主元变换*，包括以下步骤：\n1.  **定价（判别数计算）**：对于每个非基变量 $j \\in N_{idx}$，计算其判别数 $r_j = c_j - c_B^{\\mathsf{T}} B^{-1} a_j$，其中 $a_j$ 是对应于变量 $j$ 的列，$c_B$ 是基变量的成本。对于最大化问题，如果所有 $r_j \\le 0$，则当前解为最优解。\n2.  **进基变量选择**：如果一个或多个 $r_j  0$，则存在改进方向。选择一个 $r_q  0$ 的非基变量 $q$ 进入基。$q$ 的选择由*主元规则*确定。\n3.  **出基变量选择（最小比率检验）**：将要离开基的变量取决于在当前某个基变量变为零之前，进基变量可以增加多少。这通过最小比率检验来找到：在搜索方向 $d = B^{-1}a_q$ 的对应分量 $d_i$ 为正的所有基变量 $i$ 中，找到使 $x_{B_i} / d_i$ 最小化的出基变量索引 $p$。\n4.  **主元变换操作**：通过交换进基和出基变量来更新基。\n\n该问题要求在给定的 Klee-Minty 实例上实现并比较两种特定的主元规则：\n- **Bland’s 规则**：从判别数为正的非基变量集合中，选择索引最小的一个进入基。为防止循环，从平局的候选者中也选择索引最小的变量作为出基变量。\n- **最陡边规则**：此规则旨在最大化目标函数值沿可行域边缘移动单位距离时的改进率。它选择使得分 $S_j = r_j / \\|d_j\\|_2$ 最大化的进基变量 $q$，其中 $d_j = [p_j^{\\mathsf{T}}, -e_j^{\\mathsf{T}}]^{\\mathsf{T}}$ 是所有变量空间中的完整步进方向。问题中的范数简化为 $\\|d_j\\|_2 = \\sqrt{1 + \\|B^{-1} a_j\\|_2^2}$。通过选择最小索引来打破平局。\n\n### 算法设计\n\n提供的 Python 程序从第一性原理出发实现了单纯形法。\n1.  **初始化**：定义问题数据（$A$、$b$ 和 $c(\\varepsilon)$）。构建完整的系数矩阵 $[A \\mid I_3]$ 和完整的成本向量 $[c(\\varepsilon)^{\\mathsf{T}} \\mid 0_3^{\\mathsf{T}}]$。初始基由松弛变量组成。\n2.  **单纯形循环**：算法进行迭代，直到没有非基变量具有正的判别数为止。\n3.  **状态管理**：在每次迭代中，根据当前的基变量索引集构建基矩阵 $B$、其逆矩阵 $B^{-1}$ 和基成本向量 $c_B$。\n4.  **主元规则实现**：代码包含独立的逻辑块，用于根据指定的 `bland` 或 `steepest` 规则选择进基变量。\n    - 对于 Bland's 规则，它在所有 $r_j  0$ 的非基变量中找到最小的索引。\n    - 对于最陡边规则，它为所有候选变量计算得分 $S_j$，并选择使该得分最大化的变量，同时基于最小索引打破平局。\n5.  **最小比率检验**：通过计算比率来选择出基变量，并通过选择与最小索引基变量对应的候选行来处理平局，从而确保算法的终止。\n6.  **主元变换**：更新基变量和非基变量的索引集，并增加主元变换计数。\n7.  **测试**：一个主循环遍历指定的 $\\varepsilon$ 值，为每个测试创建一个新的求解器实例以确保干净的状态，运行两种规则的单纯形算法，并汇总最终输出的主元变换计数。该问题的结构使得 Bland's 规则所走的 Klee-Minty 路径和最陡边规则的单步解与 $\\varepsilon \\in (0,1)$ 的具体值无关，从而在所有测试用例中产生一致的主元变换计数。\n\n提供的程序忠实地执行了这一逻辑，以确定指定的主元变换次数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass SimplexSolver:\n    \"\"\"\n    A class to implement the simplex method for a given LP instance.\n    The instance is of the form: max c^T x, s.t. Ax = b, x = 0.\n    \"\"\"\n    def __init__(self, A: np.ndarray, b: np.ndarray, c: np.ndarray):\n        \"\"\"\n        Initializes the LP problem.\n        Args:\n            A: The constraint matrix (m x n).\n            b: The right-hand side vector (m x 1).\n            c: The objective function coefficient vector (n x 1).\n        \"\"\"\n        self.m, self.n = A.shape\n        # Augment A with slack variables\n        self.A_full = np.hstack([A, np.eye(self.m)])\n        self.b = b\n        # Augment c with zero costs for slack variables\n        self.c_full = np.concatenate([c, np.zeros(self.m)])\n        self.n_total = self.n + self.m\n        self.tol = 1e-9\n\n    def solve(self, rule: str) - int:\n        \"\"\"\n        Solves the LP problem using the specified pivot rule.\n        Args:\n            rule: The pivot rule to use, either 'bland' or 'steepest'.\n        Returns:\n            The number of pivots required to reach the optimal solution.\n            Returns negative values for errors or exceptional conditions.\n        \"\"\"\n        # Initial basis: slack variables (indices n to n+m-1)\n        basic_indices = list(range(self.n, self.n_total))\n        pivot_count = 0\n\n        while pivot_count  100: # Safety break to prevent infinite loops\n            nonbasic_indices = [i for i in range(self.n_total) if i not in basic_indices]\n            \n            # Form B, c_B, and B_inv from current basic_indices\n            B = self.A_full[:, basic_indices]\n            c_B = self.c_full[basic_indices]\n            try:\n                B_inv = np.linalg.inv(B)\n            except np.linalg.LinAlgError:\n                return -1 # Should not happen with a valid basis\n\n            # Step 1: Calculate reduced costs and find candidates for entering variable\n            candidates = {}  # {index: reduced_cost}\n            for j in nonbasic_indices:\n                a_j = self.A_full[:, j]\n                r_j = self.c_full[j] - c_B @ B_inv @ a_j\n                if r_j  self.tol:\n                    candidates[j] = r_j\n\n            # Step 2: Check for optimality\n            if not candidates:\n                return pivot_count # Optimal solution found\n\n            # Step 3: Select entering variable 'q' based on pivot rule\n            if rule == 'bland':\n                # Smallest index among candidates\n                q = min(candidates.keys())\n            elif rule == 'steepest':\n                max_score = -1.0\n                scores = {}\n                for j in candidates:\n                    a_j = self.A_full[:, j]\n                    p_j = B_inv @ a_j\n                    norm_d_j = np.sqrt(1 + p_j.T @ p_j)\n                    score = candidates[j] / norm_d_j\n                    scores[j] = score\n                    if score  max_score + self.tol:\n                        max_score = score\n                \n                # Tie-break by smallest index\n                best_indices = [j for j, s in scores.items() if abs(s - max_score)  self.tol]\n                q = min(best_indices)\n            else:\n                raise ValueError(\"Unknown pivot rule specified.\")\n\n            # Step 4: Select leaving variable (minimum ratio test)\n            a_q = self.A_full[:, q]\n            d = B_inv @ a_q\n            x_B = B_inv @ self.b\n            \n            min_ratio = float('inf')\n            leaving_row_candidates = [] # Stores (ratio, basic_var_index)\n            \n            for i in range(self.m):\n                if d[i]  self.tol:\n                    ratio = x_B[i] / d[i]\n                    leaving_row_candidates.append((ratio, basic_indices[i]))\n\n            if not leaving_row_candidates:\n                return -2 # Unbounded problem\n\n            min_ratio = min(c[0] for c in leaving_row_candidates)\n            \n            # Tie-breaking by smallest basis index\n            tied_vars = [var_idx for r, var_idx in leaving_row_candidates if abs(r - min_ratio)  self.tol]\n            leaving_var_idx = min(tied_vars)\n            \n            # Find the row index corresponding to the leaving variable\n            leaving_row_idx = basic_indices.index(leaving_var_idx)\n            \n            # Step 5: Perform pivot\n            basic_indices[leaving_row_idx] = q\n            pivot_count += 1\n\n        return -3 # Exceeded max pivot count\n\ndef solve():\n    \"\"\"\n    Main function to set up and run the Klee-Minty test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [0.5, 0.25, 0.1]\n    \n    A = np.array([\n        [1, 0, 0],\n        [2, 1, 0],\n        [4, 2, 1]\n    ], dtype=float)\n\n    b = np.array([2, 4, 8], dtype=float)\n    \n    results = []\n    \n    for eps in test_cases:\n        c = np.array([eps**2, eps, 1], dtype=float)\n        \n        # Bland's Rule\n        solver_bland = SimplexSolver(A, b, c)\n        bland_pivots = solver_bland.solve(rule='bland')\n        results.append(bland_pivots)\n        \n        # Steepest-Edge Rule\n        solver_steepest = SimplexSolver(A, b, c)\n        steepest_pivots = solver_steepest.solve(rule='steepest')\n        results.append(steepest_pivots)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3154344"}]}