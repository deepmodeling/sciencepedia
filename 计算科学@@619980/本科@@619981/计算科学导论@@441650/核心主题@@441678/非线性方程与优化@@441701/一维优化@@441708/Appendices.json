{"hands_on_practices": [{"introduction": "在将一个算法付诸实践之前，深刻理解其数学原理至关重要。本练习将引导你从第一性原理出发，推导黄金分割搜索法的核心机制，包括其收敛因子，并估算其收敛速度。通过这个纯理论的练习，你将为后续的编程实践打下坚实的基础。[@problem_id:3166848]", "problem": "考虑函数 $f(x) = \\exp(-x^{2})$ 在闭区间 $[-3,3]$ 上的情况。您将通过最小化 $g(x) = -f(x)$ 来找到其全局最大值，使用黄金分割搜索（GSS）方法。黄金分割搜索是一种区间搜索方法，其通过设置两个内部点，使得在舍弃一次函数求值后，剩余的区间保持相同的内部分割比例，并重用一个先前已计算过的点。\n\n任务：\n- 在不使用导数的情况下，根据单峰性的定义以及 $\\exp(-x^{2})$ 关于 $|x|$ 的单调性，论证 $g(x)$ 在 $[-3,3]$ 上是单峰的，并在区间内的一个单点上达到唯一的最小值。\n- 从黄金分割搜索的定义性自相似特性（未提供公式；请从第一性原理推导）出发，确定每次迭代中搜索区间长度收缩的常数因子。\n- 使用该收缩因子和初始区间长度，确定所需的最小整数迭代次数 $N$，以使最终区间长度至多为 $2 \\times 10^{-6}$。这保证了从该区间中返回的任何点（例如，其中点）与真正的最大值点之间的绝对值差最多为 $10^{-6}$。\n\n最终答案只报告整数 $N$。由于 $N$ 是一个整数，无需提供取整说明。", "solution": "经评估，此问题是有效的，因为它在计算数学方面有科学依据，问题提法良好且有唯一解，并且陈述客观。它展示了黄金分割搜索算法的一个标准应用，没有任何逻辑矛盾或信息缺失。\n\n解决方案按照题目要求，分为三个部分呈现。\n\n**第一部分：$g(x)$ 的单峰性**\n\n如果在一个区间 $[a,b]$ 上，存在唯一的点 $x^* \\in [a,b]$，使得函数在 $x^*$ 处达到其唯一的最小值（或最大值），并且函数在 $x^*$ 的两侧都是严格单调的，那么我们定义函数 $h(x)$ 在该区间上是严格单峰的。题目要求我们在区间 $[-3,3]$ 上最小化 $g(x) = -\\exp(-x^2)$。这等价于在同一区间上最大化函数 $f(x) = \\exp(-x^2)$。我们必须在不使用导数的情况下证明 $g(x)$ 在 $[-3,3]$ 上是严格单峰的。\n\n让我们分析一下各组成函数的行为。\n1.  函数 $u(x) = x^2$ 在 $x \\in [-3, 0]$ 上是严格递减的，在 $x \\in [0, 3]$ 上是严格递增的。它在该区间上的唯一最小值在 $x=0$ 处取得。\n2.  函数 $v(x) = -u(x) = -x^2$ 将具有相反的单调性。它在 $x \\in [-3, 0]$ 上是严格递增的，在 $x \\in [0, 3]$ 上是严格递减的。它在该区间上的唯一最大值在 $x=0$ 处取得。\n3.  指数函数 $f(x) = \\exp(v(x)) = \\exp(-x^2)$ 是其自变量的严格单调递增函数。因此，$f(x)$ 的单调性与其指数 $v(x)=-x^2$ 的单调性相同。所以，$f(x)$ 在 $[-3, 0]$ 上是严格递增的，在 $[0, 3]$ 上是严格递减的。这意味着 $f(x)$ 在 $x=0$ 处有唯一的最大值。\n4.  需要最小化的函数是 $g(x) = -f(x) = -\\exp(-x^2)$。乘以 $-1$ 会反转单调性。因此，$g(x)$ 在 $[-3, 0]$ 上是严格递减的，在 $[0, 3]$ 上是严格递增的。\n\n根据定义，一个函数先严格递减至一个唯一的最小值，然后严格递增，那么这个函数就是严格单峰的。函数 $g(x)$ 在 $[-3,3]$ 上表现出这种行为，其唯一的最小值出现在点 $x=0$ 处，该点位于区间内部。这就完成了关于 $g(x)$ 在 $[-3,3]$ 上单峰性的论证。\n\n**第二部分：收缩因子的推导**\n\n黄金分割搜索（GSS）算法在每次迭代中都将搜索区间的长度按一个常数因子进行缩减。设这个收缩因子为 $\\rho \\in (0,1)$。\n\n设第 $k$ 次迭代的搜索区间为 $[a_k, b_k]$，其长度为 $L_k = b_k - a_k$。在区间内选择两个内部点 $x_{k,1}$ 和 $x_{k,2}$，使得 $a_k  x_{k,1}  x_{k,2}  b_k$。这些点的放置是对称的，即无论舍弃原区间的哪一端，新区间的长度都相同。这个新长度是 $L_{k+1} = \\rho L_k$。\n这意味着子区间 $[a_k, x_{k,2}]$ 的长度必须等于子区间 $[x_{k,1}, b_k]$ 的长度。\n$$x_{k,2} - a_k = b_k - x_{k,1} = \\rho L_k$$\n由此，我们可以表示出内部点的位置：\n$$x_{k,2} = a_k + \\rho L_k$$\n$$x_{k,1} = b_k - \\rho L_k = (a_k + L_k) - \\rho L_k = a_k + (1-\\rho)L_k$$\n为了使点正确排序（$x_{k,1}  x_{k,2}$），我们必须有 $1-\\rho  \\rho$，这意味着 $1  2\\rho$，即 $\\rho > \\frac{1}{2}$。\n\nGSS的定义性属性是第 $k$ 次迭代中的一个内部点可以在第 $k+1$ 次迭代中被重用。假设在 $x_{k,1}$ 和 $x_{k,2}$ 处对函数求值后，我们发现最小值位于区间 $[a_k, x_{k,2}]$ 内。新的区间是 $[a_{k+1}, b_{k+1}] = [a_k, x_{k,2}]$。这个新区间的长度是 $L_{k+1} = x_{k,2} - a_k = \\rho L_k$。点 $x_{k,1}$ 包含在这个新区间内。\n\n对于第 $k+1$ 次迭代，我们需要在 $[a_{k+1}, b_{k+1}]$ 内选择两个新的内部点 $x_{k+1,1}$ 和 $x_{k+1,2}$。根据同样的规则，它们必须位于：\n$$x_{k+1,1} = a_{k+1} + (1-\\rho)L_{k+1} = a_k + (1-\\rho)(\\rho L_k)$$\n$$x_{k+1,2} = a_{k+1} + \\rho L_{k+1} = a_k + \\rho(\\rho L_k) = a_k + \\rho^2 L_k$$\n\n自相似性或点重用原则要求旧的点 $x_{k,1}$ 必须与新的点 $x_{k+1,1}$ 或 $x_{k+1,2}$ 之一重合。旧的点是 $x_{k,1} = a_k + (1-\\rho)L_k$。\n根据对称性，另一种情况（即新区为 $[x_{k,1}, b_k]$）将得到相同的条件。\n让我们检查两种点的匹配可能性：\n1.  $x_{k,1} = x_{k+1,1}$: $a_k + (1-\\rho)L_k = a_k + (1-\\rho)\\rho L_k$。由于 $L_k \\neq 0$ 且 $\\rho \\neq 1$，我们可以化简为 $1 = \\rho$。这与 $\\rho  1$ 的要求相矛盾。\n2.  $x_{k,1} = x_{k+1,2}$: $a_k + (1-\\rho)L_k = a_k + \\rho^2 L_k$。这可以化简为 $1-\\rho = \\rho^2$。\n\n整理后得到二次方程：\n$$\\rho^2 + \\rho - 1 = 0$$\n使用二次方程求根公式解出 $\\rho$：\n$$\\rho = \\frac{-1 \\pm \\sqrt{1^2 - 4(1)(-1)}}{2(1)} = \\frac{-1 \\pm \\sqrt{5}}{2}$$\n由于收缩因子 $\\rho$ 必须是一个正值（因为它是长度之比），我们必须取正根：\n$$\\rho = \\frac{\\sqrt{5}-1}{2}$$\n这个值是黄金比例 $\\phi = \\frac{1+\\sqrt{5}}{2}$ 的倒数，通常记为 $\\frac{1}{\\phi}$。其近似值为 $0.618034$。\n\n**第三部分：最小迭代次数**\n\n初始区间是 $[-3, 3]$，所以其长度为 $L_0 = 3 - (-3) = 6$。\n经过 $N$ 次迭代后，区间的长度由 $L_N = \\rho^N L_0$ 给出。\n问题要求最终区间长度 $L_N$ 至多为 $2 \\times 10^{-6}$。所以我们必须找到满足以下不等式的最小整数 $N$：\n$$L_N \\le 2 \\times 10^{-6}$$\n将 $L_N$ 的表达式以及 $L_0$ 和 $\\rho$ 的值代入：\n$$\\left(\\frac{\\sqrt{5}-1}{2}\\right)^N (6) \\le 2 \\times 10^{-6}$$\n两边除以 $6$：\n$$\\left(\\frac{\\sqrt{5}-1}{2}\\right)^N \\le \\frac{2 \\times 10^{-6}}{6} = \\frac{1}{3} \\times 10^{-6}$$\n为了解出 $N$，我们对两边取自然对数。由于 $\\ln(x)$ 是一个增函数，不等号的方向保持不变。\n$$N \\ln\\left(\\frac{\\sqrt{5}-1}{2}\\right) \\le \\ln\\left(\\frac{1}{3} \\times 10^{-6}\\right)$$\n项 $\\frac{\\sqrt{5}-1}{2} \\approx 0.618$ 小于 $1$，所以它的对数值是负的。当我们除以这个负数时，必须反转不等号的方向：\n$$N \\ge \\frac{\\ln\\left(\\frac{1}{3} \\times 10^{-6}\\right)}{\\ln\\left(\\frac{\\sqrt{5}-1}{2}\\right)}$$\n让我们计算分子和分母：\n$$ \\ln\\left(\\frac{1}{3} \\times 10^{-6}\\right) = \\ln(1) - \\ln(3) - \\ln(10^6) = -\\ln(3) - 6\\ln(10) $$\n分母可以用黄金比例 $\\phi = \\frac{1+\\sqrt{5}}{2}$ 表示为 $\\ln\\left(\\frac{1}{\\phi}\\right) = -\\ln(\\phi)$。\n$$ N \\ge \\frac{-\\ln(3) - 6\\ln(10)}{-\\ln(\\phi)} = \\frac{\\ln(3) + 6\\ln(10)}{\\ln\\left(\\frac{1+\\sqrt{5}}{2}\\right)} $$\n使用对数的数值：\n$$ \\ln(3) \\approx 1.09861 $$\n$$ \\ln(10) \\approx 2.30259 $$\n$$ \\ln\\left(\\frac{1+\\sqrt{5}}{2}\\right) \\approx \\ln(1.618034) \\approx 0.48121 $$\n代入这些值：\n$$ N \\ge \\frac{1.09861 + 6(2.30259)}{0.48121} = \\frac{1.09861 + 13.81554}{0.48121} = \\frac{14.91415}{0.48121} \\approx 30.993 $$\n由于迭代次数 $N$ 必须是整数，我们必须取大于或等于 $30.993$ 的最小整数。\n$$ N = 31 $$", "answer": "$$\\boxed{31}$$", "id": "3166848"}, {"introduction": "掌握了理论基础后，下一步是将其转化为可执行的代码。本练习要求你实现黄金分割搜索算法，并用它来解决一系列测试问题。其中一个精心设计的案例将揭示该算法一个有趣且重要的特性：其收敛速度是固定的，不受函数具体形态的影响，这凸显了其稳定性和可预测性。[@problem_id:3166878]", "problem": "您需要从基本原理出发，设计并实现一个使用黄金分割搜索（GSS）的一维最优化算法。该算法的基本依据是在闭区间上单峰函数的定义，以及要求选择的采样点能够保持搜索区间的自相似性，从而在每次迭代中可以重用一个函数值。一个连续单峰函数在一个区间上恰好有一个局部最小值，通过在保持连续区间长度固定比例的同时缩小区间，可以系统地收敛到该最小值。您的任务是推导实现这种不变性的点放置规则，实现由此产生的算法，并量化当初始内部点被有利地放置时，收敛被检测到的速度。\n\n实现黄金分割搜索算法，用于在区间 $[a,b]$ 上最小化一个连续单峰函数 $f(x)$。该算法必须：\n- 在 $[a,b]$ 中初始化两个内部评估点，每次区间缩减后重用一次函数求值。\n- 在每次迭代中，通过比较内部点的函数值，将区间缩减到包含极小值点的子区间。\n- 当区间长度小于或等于预设容差 $\\varepsilon$ 时终止。\n- 返回三个量：直到终止的迭代次数 $n$，极小值点的最终近似值 $x^\\star$，以及函数值 $f(x^\\star)$。\n\n创建一个特殊测试用例，使初始内部点之一在开始时与极小值点完全对齐。考虑函数 $f(x) = (x - \\tau)^2$，区间为 $[0,1]$，其中 $\\tau$ 是黄金比例共轭数 $\\tau = (\\sqrt{5} - 1)/2 \\approx 0.618$。由于黄金分割搜索的初始内部点位于 $x_1 = b - \\tau (b-a)$ 和 $x_2 = a + \\tau (b-a)$，在区间 $[0,1]$ 上，其中一个点等于 $x^\\star = \\tau$。通过对严格的容差 $\\varepsilon$ 测量迭代次数 $n$，验证算法检测到收敛的速度。\n\n您的程序必须根据这些原理实现黄金分割搜索，并将其应用于以下测试套件。对于每个测试用例，返回一个形如 $[n, x^\\star, f(x^\\star)]$ 的列表，并将所有结果汇总到一个单行打印的列表中，格式如下所述。\n\n测试套件：\n- 情况 $1$（对齐的内部点）：$f_1(x) = (x - \\tau)^2$，区间 $[0,1]$，容差 $\\varepsilon = 10^{-8}$。\n- 情况 $2$（对称但未对齐）：$f_2(x) = (x - 0.5)^2$，区间 $[0,1]$，容差 $\\varepsilon = 10^{-8}$。\n- 情况 $3$（最小值在端点）：$f_3(x) = x^2$，区间 $[0,1]$，容差 $\\varepsilon = 10^{-8}$。\n- 情况 $4$（极小值点周围的微小初始区间）：$f_4(x) = (x - \\tau)^2$，区间 $[\\tau - 10^{-12}, \\tau + 10^{-12}]$，容差 $\\varepsilon = 10^{-9}$。\n- 情况 $5$（光滑严格凸函数，较宽区间）：$f_5(x) = \\mathrm{e}^{x} + \\mathrm{e}^{-x}$，区间 $[-1,2]$，容差 $\\varepsilon = 10^{-8}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,\\dots]$）。\n- 对于每种情况，输出列表 $[n, x^\\star, f(x^\\star)]$，其中 $n$ 是整数，而 $x^\\star$ 和 $f(x^\\star)$ 都是四舍五入到 $10$ 位小数的浮点数。\n- 结果的顺序必须与上述测试套件的顺序相匹配。\n- 不涉及角度；不需要角度单位。不涉及物理单位。", "solution": "该问题要求从基本原理出发，设计并实现黄金分割搜索（GSS）算法，用于在闭区间 $[a,b]$ 上最小化一个连续单峰函数 $f(x)$。\n\n### 黄金分割搜索的原理与推导\n\n如果一个函数 $f(x)$ 在区间 $[a,b]$ 上存在唯一的极小值点 $x^\\star \\in [a,b]$，并且对于区间内的任意两点 $x_1  x_2$，如果 $x_2  x^\\star$，则 $f(x_1)  f(x_2)$；如果 $x_1  x^\\star$，则 $f(x_1)  f(x_2)$，那么该函数是单峰的。简而言之，该函数在最小值点的左侧严格递减，在右侧严格递增。\n\n黄金分割搜索的核心是迭代地缩小区间 $[a,b]$，同时确保最小值点 $x^\\star$ 始终位于缩小的区间内。为此，我们在两个内部点 $x_1$ 和 $x_2$（满足 $a  x_1  x_2  b$）处对函数进行采样。\n\n通过比较函数值 $f(x_1)$ 和 $f(x_2)$，我们可以舍弃区间的一部分：\n1.  如果 $f(x_1)  f(x_2)$，则最小值不可能在子区间 $(x_2, b]$ 内。因为如果最小值在该子区间内，那么 $x_1$ 和 $x_2$ 都将位于最小值的左侧，根据单峰性定义，这意味着 $f(x_1)  f(x_2)$，这与前提矛盾。因此，新的搜索区间必须是 $[a, x_2]$。\n2.  如果 $f(x_1) \\geq f(x_2)$，则最小值不可能在子区间 $[a, x_1)$ 内。因为如果最小值在该子区间内，那么 $x_1$ 和 $x_2$ 都将位于最小值的右侧，这意味着 $f(x_1)  f(x_2)$，这与前提矛盾。因此，新的搜索区间必须是 $[x_1, b]$。\n\n提高效率的关键在于选择 $x_1$ 和 $x_2$ 的位置，使得其中一个点（及其对应的函数求值结果）可以在下一次迭代中被重用。这通过对称地放置点并在每一步保持恒定的区间缩减比率来实现。\n\n设第 $k$ 步的区间长度为 $L_k = b_k - a_k$。我们希望每一步都将长度缩减一个常数因子 $\\tau$，即 $L_{k+1} = \\tau L_k$。我们根据区间长度来定义内部点的位置。我们选择一个参数 $\\tau \\in (1/2, 1)$，并从区间的两端对称地放置这些点：\n$x_{1,k} = b_k - \\tau(b_k - a_k)$\n$x_{2,k} = a_k + \\tau(b_k - a_k)$\n\n注意，因为 $\\tau  1/2$，我们有 $a_k  x_{1,k}  x_{2,k}  b_k$，正如所要求的那样。\n\n现在，考虑 $f(x_{1,k})  f(x_{2,k})$ 的情况。新的区间是 $[a_{k+1}, b_{k+1}] = [a_k, x_{2,k}]$。\n这个新区间的长度是 $L_{k+1} = x_{2,k} - a_k = \\tau(b_k - a_k) = \\tau L_k$。这与我们恒定比率缩减的目标是一致的。\n新的区间 $[a_{k+1}, b_{k+1}]$ 包含旧的内部点之一，$x_{1,k}$。对于下一次迭代，我们需要两个新的内部点，$x_{1,k+1}$ 和 $x_{2,k+1}$，它们由相同的规则定义：\n$x_{1,k+1} = b_{k+1} - \\tau L_{k+1} = x_{2,k} - \\tau(\\tau L_k) = (a_k + \\tau L_k) - \\tau^2 L_k = a_k + (\\tau - \\tau^2)L_k$。\n$x_{2,k+1} = a_{k+1} + \\tau L_{k+1} = a_k + \\tau(\\tau L_k) = a_k + \\tau^2 L_k$。\n\n为了重用一次函数求值，旧点 $x_{1,k}$ 必须与新点之一 $x_{1,k+1}$ 或 $x_{2,k+1}$ 重合。\n旧点的位置是 $x_{1,k} = b_k - \\tau L_k = (a_k+L_k) - \\tau L_k = a_k + (1-\\tau)L_k$。\n将其与新点进行比较，我们可以强制执行条件 $x_{1,k} = x_{2,k+1}$（通过观察，这是两个点中更靠近各自区间中心的一个）。这给出了方程：\n$a_k + (1-\\tau)L_k = a_k + \\tau^2 L_k$\n$1 - \\tau = \\tau^2$\n$\\tau^2 + \\tau - 1 = 0$\n\n求解这个二次方程的正根，得到：\n$\\tau = \\frac{-1 + \\sqrt{1^2 - 4(1)(-1)}}{2(1)} = \\frac{\\sqrt{5} - 1}{2}$\n\n这个值，约等于 $0.618034$，是黄金比例共轭数，通常表示为 $\\phi^{-1}$ 或简写为 $\\tau$。对于 $f(x_{1,k}) \\geq f(x_{2,k})$ 的情况，一个对称的论证表明，旧点 $x_{2,k}$ 变成了新点 $x_{1,k+1}$。\n\n因此，通过选择 $\\tau = (\\sqrt{5} - 1)/2$，我们保证每一步的区间长度都按因子 $\\tau$ 缩减，并且可以重用一次函数求值。\n\n### 算法实现\n\n该算法按以下步骤进行：\n1.  **初始化**：给定函数 $f(x)$、区间 $[a,b]$ 和容差 $\\varepsilon$。定义 $\\tau = (\\sqrt{5}-1)/2$。计算初始内部点 $x_1 = b - \\tau(b-a)$ 和 $x_2 = a + \\tau(b-a)$，并计算 $f_1 = f(x_1)$ 和 $f_2 = f(x_2)$。初始化迭代计数器 $n=0$。\n2.  **迭代**：当区间长度 $(b-a)  \\varepsilon$ 时：\n    a. 增加 $n$。\n    b. 如果 $f_1  f_2$：\n        i. 新区间为 $[a, x_2]$。设置 $b = x_2$。\n        ii. 旧的 $x_1$ 成为新的 $x_2$。设置 $x_2 = x_1$ 和 $f_2 = f_1$。\n        iii. 计算新的 $x_1 = b - \\tau(b-a)$ 并计算 $f_1 = f(x_1)$。\n    c. 否则 ($f_1 \\geq f_2$)：\n        i. 新区间为 $[x_1, b]$。设置 $a = x_1$。\n        ii. 旧的 $x_2$ 成为新的 $x_1$。设置 $x_1 = x_2$ 和 $f_1 = f_2$。\n        iii. 计算新的 $x_2 = a + \\tau(b-a)$ 并计算 $f_2 = f(x_2)$。\n3.  **终止**：当循环终止时，极小值点 $x^\\star$ 位于最终区间 $[a,b]$ 内。极小值点的最佳估计是该区间的中点，$x^\\star = (a+b)/2$。\n4.  **返回**：返回迭代次数 $n$、最终近似值 $x^\\star$ 和函数值 $f(x^\\star)$。\n\n### 特殊测试用例分析（情况 1）\n\n对于函数 $f_1(x) = (x - \\tau)^2$ 在区间 $[0,1]$ 上，其真正的最小值在 $x^\\star = \\tau$。\n初始区间为 $[a_0, b_0] = [0,1]$。初始内部点为：\n$x_{1,0} = 1 - \\tau(1-0) = 1-\\tau$\n$x_{2,0} = 0 + \\tau(1-0) = \\tau$\n初始点之一 $x_{2,0}$ 与真正的极小值点完全重合。因此，$f(x_{2,0}) = (\\tau - \\tau)^2 = 0$。另一个点的值为 $f(x_{1,0}) = ((1-\\tau) - \\tau)^2 = (1-2\\tau)^2  0$。\n\n由于 $f(x_{1,0})  f(x_{2,0})$，算法将新区间设置为 $[a_1, b_1] = [x_{1,0}, b_0] = [1-\\tau, 1]$。\n算法通过围绕函数值较低的点来缩小区间。在随后的每次迭代中，其中一个内部点将恰好是 $\\tau$，其函数值为 $0$。算法将总是选择包含 $\\tau$ 的子区间。\n\n然而，“收敛被检测到的速度有多快”这个问题可以通过检查终止准则 $(b-a) \\leq \\varepsilon$ 来回答。算法的收敛速度完全由区间缩减因子 $\\tau$ 决定。$n$ 次迭代后区间的长度为 $L_n = \\tau^n L_0$。满足容差所需的迭代次数可以通过求解 $\\tau^n L_0 \\leq \\varepsilon$ 找到，即 $n \\geq \\log(\\varepsilon/L_0) / \\log(\\tau)$。对于 $L_0=1$ 和 $\\varepsilon=10^{-8}$，这需要 $n \\geq \\log(10^{-8})/\\log(\\tau) \\approx 38.28$，意味着需要 $n=39$ 次迭代。\n\n将初始点有利地放置在精确的最小值处并不会改变收敛所需的迭代次数。该算法没有机制来“检测”它已经找到了最小值；它只根据区间宽度终止。这展示了黄金分割搜索的一个关键特性：它具有一个有保证但固定的线性收敛速率，该速率与函数在单峰性之外的具体行为无关。相比之下，使用导数信息的算法（如牛顿法）在这种情况下可能会收敛得快得多。\n\n这种情况的例外是情况 4，其中初始区间 $[\\tau - 10^{-12}, \\tau + 10^{-12}]$ 的长度为 $2 \\times 10^{-12}$，已经小于容差 $\\varepsilon = 10^{-9}$。在这种情况下，终止条件在第一次迭代之前就已满足，算法正确地返回 $n=0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for Golden-section search.\n    \"\"\"\n\n    def golden_section_search(f, a, b, tol):\n        \"\"\"\n        Implements the Golden-section search algorithm.\n        \n        Args:\n            f: The unimodal function to minimize.\n            a: The lower bound of the interval.\n            b: The upper bound of the interval.\n            tol: The tolerance for the interval length.\n            \n        Returns:\n            A list containing [n, x_star, f_x_star]:\n            - n: Number of iterations.\n            - x_star: The approximation of the minimizer.\n            - f_x_star: The function value at the approximation.\n        \"\"\"\n        # The golden ratio conjugate\n        tau = (np.sqrt(5) - 1) / 2\n\n        # Initial interior points\n        x1 = b - tau * (b - a)\n        x2 = a + tau * (b - a)\n\n        # Initial function evaluations\n        f1 = f(x1)\n        f2 = f(x2)\n\n        n = 0\n        while (b - a) > tol:\n            n += 1\n            if f1  f2:\n                # The minimum is in [a, x2]\n                b = x2\n                x2 = x1\n                f2 = f1\n                x1 = b - tau * (b - a)\n                f1 = f(x1)\n            else:\n                # The minimum is in [x1, b]\n                a = x1\n                x1 = x2\n                f1 = f2\n                x2 = a + tau * (b - a)\n                f2 = f(x2)\n        \n        # The final approximation is the midpoint of the last interval.\n        x_star = (a + b) / 2\n        f_x_star = f(x_star)\n        \n        return [n, x_star, f_x_star]\n\n    # Define constants and test functions\n    tau_val = (np.sqrt(5) - 1) / 2\n\n    def f1(x):\n        return (x - tau_val)**2\n\n    def f2(x):\n        return (x - 0.5)**2\n\n    def f3(x):\n        return x**2\n\n    def f4(x):\n        return (x - tau_val)**2\n\n    def f5(x):\n        return np.exp(x) + np.exp(-x)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (f1, 0.0, 1.0, 1e-8),\n        (f2, 0.0, 1.0, 1e-8),\n        (f3, 0.0, 1.0, 1e-8),\n        (f4, tau_val - 1e-12, tau_val + 1e-12, 1e-9),\n        (f5, -1.0, 2.0, 1e-8),\n    ]\n\n    results = []\n    for case in test_cases:\n        func, a, b, tol = case\n        n, x_star, f_x_star = golden_section_search(func, a, b, tol)\n        \n        # Format the result as a string with required precision\n        result_str = f\"[{n},{x_star:.10f},{f_x_star:.10f}]\"\n        results.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3166878"}]}