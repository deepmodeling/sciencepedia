{"hands_on_practices": [{"introduction": "我们从阐明卷积与互相关之间微妙而关键的区别开始。虽然这两种运算在计算上很相似，但它们的等价性取决于核函数的对称性，而对称性本身的定义在线性与循环边界条件下是不同的。这项练习 [@problem_id:3114298] 提供了一个具体的编程挑战，旨在探索这种关系，从而让你对这两种基本运算在何种情况下会产生相同结果建立起稳固的直觉。", "problem": "您需要编写一个完整、可运行的程序，用于在两种边界模型（循环边界条件和零填充）下，为精心选择的实值信号构建并比较离散卷积和离散互相关。请基于离散卷积和离散互相关的核心定义进行操作。\n\n请使用以下基本定义作为您推理和实现的基础。对于两个长度分别为 $N_x$ 和 $N_h$ 的有限长度实值离散时间信号 $x[n]$ 和 $h[n]$：\n- 线性卷积（使用零填充）定义为\n$$\ny_{\\text{lin}}[k] = \\sum_{n=-\\infty}^{\\infty} x[n]\\;h[k-n],\n$$\n约定在其支持索引范围之外的值被视为零。实际上，对于在 $0 \\le n \\le N_x-1$ 上有定义的有限信号 $x[n]$ 和在 $0 \\le n \\le N_h-1$ 上有定义的 $h[n]$，该求和简化为 $x[n]$ 和 $h[k-n]$ 均在其支持域内有定义的索引。输出长度为 $N_x + N_h - 1$。\n- 线性互相关（使用零填充）定义为\n$$\nr_{xh,\\text{lin}}[k] = \\sum_{n=-\\infty}^{\\infty} x[n]\\;h[n+k],\n$$\n同样，在其支持索引范围之外的值被视为零。\n- 对于周期为 $N$ 的循环边界条件 (CBC)，循环卷积定义为\n$$\ny_{\\text{circ}}[k] = \\sum_{n=0}^{N-1} x[n]\\;h[(k-n)\\bmod N],\n$$\n循环互相关定义为\n$$\nr_{xh,\\text{circ}}[k] = \\sum_{n=0}^{N-1} x[n]\\;h[(n+k)\\bmod N],\n$$\n对于 $0 \\le k \\le N-1$。\n\n您的任务是设计信号 $x[n]$ 和 $h[n]$，使得循环卷积 $x \\circledast h$ 和循环互相关 $r_{xh,\\text{circ}}[k]$ 在数值上相等，但线性（零填充）卷积和线性互相关不相等。您必须从原理上解释为什么会发生这种情况，并明确指出翻转（时间反转）和边界模型的作用。\n\n实现以下三个测试用例以展示覆盖性：\n- 测试用例 1（设计用于满足循环相等性但不满足线性相等性）：设 $N = 5$，$x[n]$ 为 $[\\,3,\\,1,\\,4,\\,1,\\,5\\,]$，$h[n]$ 为 $[\\,2,\\,5,\\,7,\\,7,\\,5\\,]$。这里，$h[n]$ 相对于索引 $0$ 是循环偶对称的，因为 $h[1] = h[4]$ 且 $h[2] = h[3]$，这确保了在循环边界条件下的相等性，但 $h[n]$ 在中心翻转下不是回文的，因此零填充的卷积和相关不相等。\n- 测试用例 2（设计用于满足线性相等性但不满足循环相等性）：设 $N = 5$，$x[n]$ 为 $[\\,2,\\,1,\\,0,\\,4,\\,3\\,]$，$h[n]$ 为 $[\\,1,\\,2,\\,3,\\,2,\\,1\\,]$。这里，$h[n]$ 在中心翻转下是回文的，确保了线性卷积等于线性相关，但 $h[n]$ 相对于索引 $0$ 不是循环偶对称的，因此循环卷积和循环相关不相等。\n- 测试用例 3（两种相等性都成立的边界情况）：设 $N = 6$，$x[n]$ 为 $[\\,0,\\,1,\\,0,\\,2,\\,0,\\,3\\,]$，$h[n]$ 为常数 $[\\,4,\\,4,\\,4,\\,4,\\,4,\\,4\\,]$，因此循环和线性相等性都成立。\n\n算法要求：\n- 对于每个 $k$，直接根据其定义使用模数索引计算 $y_{\\text{circ}}[k]$ 和 $r_{xh,\\text{circ}}[k]$。\n- 使用带零填充的标准线性卷积计算 $y_{\\text{lin}}[k]$。\n- 使用上面给出的定义计算 $r_{xh,\\text{lin}}[k]$。在实现上，可以使用线性互相关等于与 $h[n]$ 的中心翻转版本进行线性卷积这一等价关系，即定义 $\\mathrm{flip}(h)[m] = h[N_h - 1 - m]$，并计算 $r_{xh,\\text{lin}}[k] = \\mathrm{conv}(x,\\mathrm{flip}(h))[k]$。这种对齐方式会产生与线性卷积相同的输出索引，以便直接比较。\n- 使用数值容差进行相等性检查。如果两个序列的逐元素最大绝对差值小于 $10^{-12}$，则认为它们相等。\n\n要求的输出：\n- 对于每个测试用例，产生两个布尔值：第一个表示 $y_{\\text{circ}}[k]$ 是否逐元素等于 $r_{xh,\\text{circ}}[k]$，第二个表示 $y_{\\text{lin}}[k]$ 是否逐元素等于 $r_{xh,\\text{lin}}[k]$（在通过中心翻转产生的卷积对齐索引下）。\n- 您的程序应生成单行输出，其中包含结果，格式为逗号分隔的列表的列表，不含空格，精确格式如下 [[b_{1,1},b_{1,2}],[b_{2,1},b_{2,2}],[b_{3,1},b_{3,2}]]。\n\n此问题不涉及物理单位。角度和百分比也不会出现。\n\n请使用 Python 3.12 版本实现解决方案，且仅使用运行时环境中指定的允许库。", "solution": "此问题的解决方案依赖于对卷积和互相关之间关系的精确理解，以及这种关系如何受不同边界条件的影响——特别是线性运算的零填充和循环运算的模运算。\n\n两个实值信号 $x[n]$ 和 $h[n]$ 的离散卷积和互相关的基本定义是：\n- 卷积：$(x * h)[k] = \\sum_{n} x[n] h[k-n]$\n- 互相关：$(x \\star h)[k] = \\sum_{n} x[n] h[n+k]$\n\n关键洞见在于，互相关可以表示为与核 $h[n]$ 的时间反转（翻转）版本进行的卷积。我们定义一个时间反转算子 $\\mathrm{rev}(\\cdot)$。卷积 $(x * \\mathrm{rev}(h))[k]$ 由 $\\sum_{n} x[n] (\\mathrm{rev}(h))[k-n]$ 给出。可以证明，只要反转算子和求和边界针对所使用的边界模型进行适当定义，该表达式就等价于互相关的定义 $(x \\star h)[k]$。\n\n因此，卷积和互相关会产生相同的结果，即 $(x * h)[k] = (x \\star h)[k]$，当且仅当卷积核 $h[n]$ 在与边界模型相关联的特定时间反转操作下是对称的。这个条件是 $h[n] = \\mathrm{rev}(h)[n]$。问题的症结在于，时间反转算子在线性和循环情境下的定义是不同的。\n\n**1. 线性（零填充）运算**\n\n对于长度为 $N_x$ 的 $x[n]$ 和长度为 $N_h$ 的 $h[n]$ 这类有限长度信号，线性运算假设信号在其定义的支持域之外为零。相应的时间反转算子将核 $h[n]$ 绕其中心索引进行翻转。其定义如下：\n$$\n\\mathrm{rev}_{\\text{lin}}(h)[m] = h[N_h - 1 - m] \\quad \\text{for } 0 \\le m \\le N_h-1\n$$\n线性卷积和线性互相关相等，当且仅当 $h[m] = \\mathrm{rev}_{\\text{lin}}(h)[m]$，即 $h[m] = h[N_h - 1 - m]$。具有此属性的序列称为**回文序列**。例如，$[\\,1,\\,2,\\,3,\\,2,\\,1\\,]$ 是回文的。\n\n问题指定将线性互相关计算为 $x$ 与 $h$ 的翻转版本的卷积。这直接利用了恒等式 $(x \\star h)_{\\text{lin}} = (x * \\mathrm{rev}_{\\text{lin}}(h))_{\\text{lin}}$。因此，相等性比较变成了 $(x * h)_{\\text{lin}}$ 和 $(x * \\mathrm{rev}_{\\text{lin}}(h))_{\\text{lin}}$ 之间的直接比较。\n\n**2. 循环（周期性）运算**\n\n对于周期为 $N$ 的信号进行循环运算时，索引按模 $N$ 处理。循环时间反转算子将核 $h[n]$ 在圆上绕索引 $n=0$ 进行翻转：\n$$\n\\mathrm{rev}_{\\text{circ}}(h)[n] = h[(-n) \\pmod N] \\quad \\text{for } 0 \\le n \\le N-1\n$$\n循环卷积 $y_{\\text{circ}}[k] = \\sum_{n=0}^{N-1} x[n]\\;h[(k-n)\\bmod N]$ 等于循环互相关 $r_{xh,\\text{circ}}[k] = \\sum_{n=0}^{N-1} x[n]\\;h[(n+k)\\bmod N]$，当且仅当 $h[n] = \\mathrm{rev}_{\\text{circ}}(h)[n]$。这意味着 $h[n] = h[(-n) \\pmod N]$。具有此属性的序列称为**循环偶对称**。例如，当 $N=5$ 时，这要求 $h[1] = h[4]$ 且 $h[2] = h[3]$。序列 $[\\,2,\\,5,\\,7,\\,7,\\,5\\,]$ 对于 $N=5$ 是循环偶对称的。\n\n**有意设计的差异**\n\n问题的测试用例旨在利用回文对称性和循环偶对称性是两种不同性质这一事实。一个信号可以拥有其中一种对称性而不拥有另一种，这使我们能够构建出这样的场景：其中一对运算（例如循环运算）结果相等，而另一对（例如线性运算）则不相等。\n\n- **测试用例 1**：$h = [\\,2,\\,5,\\,7,\\,7,\\,5\\,]$ 且 $N=5$。\n  - 是否循环偶对称？：$h[1]=5$ 且 $h[(-1)\\bmod 5] = h[4]=5$。它们相等。$h[2]=7$ 且 $h[(-2)\\bmod 5] = h[3]=7$。它们相等。所以，$h$ 是循环偶对称的。我们预期 $y_{\\text{circ}} = r_{xh,\\text{circ}}$。\n  - 是否回文？：$h[0]=2$ 且 $h[5-1-0] = h[4]=5$。它们不相等。所以，$h$ 不是回文的。我们预期 $y_{\\text{lin}} \\ne r_{xh,\\text{lin}}$。\n  - 预测：$[\\mathrm{True}, \\mathrm{False}]$\n\n- **测试用例 2**：$h = [\\,1,\\,2,\\,3,\\,2,\\,1\\,]$ 且 $N=5$。\n  - 是否回文？：$h[0]=1, h[4]=1$。$h[1]=2, h[3]=2$。它是回文的。我们预期 $y_{\\text{lin}} = r_{xh,\\text{lin}}$。\n  - 是否循环偶对称？：$h[1]=2$ 且 $h[(-1)\\bmod 5] = h[4]=1$。它们不相等。它不是循环偶对称的。我们预期 $y_{\\text{circ}} \\ne r_{xh,\\text{circ}}$。\n  - 预测：$[\\mathrm{False}, \\mathrm{True}]$\n\n- **测试用例 3**：$h = [\\,4,\\,4,\\,4,\\,4,\\,4,\\,4\\,]$ 且 $N=6$。\n  - 常数信号显然既是回文的（$h[m]=4$ 且 $h[6-1-m]=4$）又是循环偶对称的（$h[n]=4$ 且 $h[(-n)\\bmod 6]=4$）。我们预期两种相等性都成立。\n  - 预测：$[\\mathrm{True}, \\mathrm{True}]$\n\n实现将遵循这些原则。循环运算使用循环和模运算直接根据其求和定义进行计算。线性运算为提高效率而使用 `numpy.convolve`，其中线性互相关按照问题陈述中的规定，通过与中心翻转的核进行卷积来计算。相等性通过确保结果序列之间的最大逐元素绝对差值低于 $10^{-12}$ 的容差来检查。", "answer": "```python\nimport numpy as np\n\ndef circular_convolution(x: np.ndarray, h: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the circular convolution of two 1D signals x and h.\n    Assumes len(x) == len(h).\n    \"\"\"\n    N = len(x)\n    y = np.zeros(N)\n    for k in range(N):\n        for n in range(N):\n            y[k] += x[n] * h[(k - n) % N]\n    return y\n\ndef circular_cross_correlation(x: np.ndarray, h: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the circular cross-correlation of two 1D signals x and h.\n    Assumes len(x) == len(h).\n    \"\"\"\n    N = len(x)\n    r = np.zeros(N)\n    for k in range(N):\n        for n in range(N):\n            r[k] += x[n] * h[(n + k) % N]\n    return r\n\ndef solve():\n    \"\"\"\n    Solves the problem by running three predefined test cases and\n    comparing convolution and cross-correlation under different boundary models.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, x_list, h_list)\n        (5, [3, 1, 4, 1, 5], [2, 5, 7, 7, 5]),\n        (5, [2, 1, 0, 4, 3], [1, 2, 3, 2, 1]),\n        (6, [0, 1, 0, 2, 0, 3], [4, 4, 4, 4, 4, 4]),\n    ]\n\n    results = []\n    tolerance = 1e-12\n\n    for N, x_list, h_list in test_cases:\n        x = np.array(x_list, dtype=float)\n        h = np.array(h_list, dtype=float)\n\n        # 1. Circular operations\n        y_circ = circular_convolution(x, h)\n        r_circ = circular_cross_correlation(x, h)\n        \n        # Check for circular equality\n        circ_diff = np.max(np.abs(y_circ - r_circ))\n        is_circ_equal = circ_diff  tolerance\n\n        # 2. Linear operations\n        # Linear convolution\n        y_lin = np.convolve(x, h, mode='full')\n        \n        # Linear cross-correlation via convolution with flipped kernel\n        # h_flipped[m] = h[N_h - 1 - m] is equivalent to h[::-1]\n        h_flipped = h[::-1]\n        r_lin = np.convolve(x, h_flipped, mode='full')\n\n        # Check for linear equality\n        lin_diff = np.max(np.abs(y_lin - r_lin))\n        is_lin_equal = lin_diff  tolerance\n\n        results.append([is_circ_equal, is_lin_equal])\n\n    # Format the output string as per the requirement: [[b1,b2],[b3,b4],...] with no spaces.\n    # str(True) -> 'True', str(False) -> 'False'\n    result_str = \",\".join([f\"[{b1},{b2}]\" for b1, b2 in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3114298"}, {"introduction": "在掌握了基本定义之后，我们转向一个强大的应用。卷积可以被用来求解线性时不变系统，例如物理和工程中的微分方程。这项练习 [@problem_id:3114358] 将引导你推导一维泊松方程的离散格林函数，它代表了系统的“脉冲响应”。通过将此函数与任意源项进行卷积，你可以高效地构建出解，这展示了计算科学中的一个深刻原理。", "problem": "考虑一个一维（1D）泊松问题，其定义在一个均匀网格上。该网格将区间 $\\left[0,L\\right]$ 离散化为 $N$ 个相等的子区间，网格点为 $x_{i} = i h$，$i = 0,1,\\dots,N$，网格间距为 $h = L/N$。令 $\\{u_{i}\\}_{i=0}^{N}$ 为函数 $u(x)$ 在这些网格点上的近似值，并具有固定端点 $u_{0} = 0$ 和 $u_{N} = 0$。在内部点 $i=1,\\dots,N-1$ 处，离散二阶导数由经过充分检验的三点二阶差分公式定义：\n$$\n\\frac{u_{i-1} - 2 u_{i} + u_{i+1}}{h^{2}},\n$$\n离散源项采样值为 $\\{f_{i}\\}_{i=1}^{N-1}$，因此离散泊松方程为：\n$$\n\\frac{u_{i-1} - 2 u_{i} + u_{i+1}}{h^{2}} = f_{i}, \\quad i = 1,2,\\dots,N-1,\n$$\n其中 $u_{0} = 0$ 且 $u_{N} = 0$。仅使用基本定义，推导与此边值问题相关的离散格林函数 $G_{i,j}$。对于每个固定的 $j \\in \\{1,\\dots,N-1\\}$，该函数是满足以下方程的序列：\n$$\n\\frac{G_{i-1,j} - 2 G_{i,j} + G_{i+1,j}}{h^{2}} = \\delta_{i j}, \\quad i = 1,2,\\dots,N-1,\n$$\n同时满足 $G_{0,j} = 0$ 和 $G_{N,j} = 0$，其中 $\\delta_{ij}$ 表示离散克罗内克 delta 函数。然后，从第一性原理验证与格林函数的离散卷积，\n$$\nu_{i} = \\sum_{j=1}^{N-1} G_{i,j} \\, f_{j},\n$$\n是具有给定固定端点条件的离散泊松方程的解。将格林函数 $G_{i,j}$ 的最终答案表示为关于 $i$、$j$、$N$ 和 $h$ 的单一闭式解析表达式。无需四舍五入。", "solution": "该问题是有效的。这是一个关于一维泊松方程有限差分近似的标准、适定的数值分析问题。所有术语都得到了精确定义，问题是自洽且科学合理的。\n\n按要求，求解过程包括两个主要部分：首先，从其定义方程和边界条件推导离散格林函数 $G_{i,j}$；其次，从第一性原理验证此格林函数与源项的离散卷积可得到离散泊松问题的解。\n\n### 第一部分：离散格林函数 $G_{i,j}$ 的推导\n\n对于固定的源指数 $j \\in \\{1, 2, \\dots, N-1\\}$，离散格林函数 $G_{i,j}$ 由以下关于 $i \\in \\{1, 2, \\dots, N-1\\}$ 的线性差分方程定义：\n$$\n\\frac{G_{i-1,j} - 2 G_{i,j} + G_{i+1,j}}{h^{2}} = \\delta_{i j}\n$$\n并服从齐次边界条件 $G_{0,j} = 0$ 和 $G_{N,j} = 0$。这里，$\\delta_{ij}$ 是克罗内克 delta 函数。\n\n方程两边乘以 $h^2$，得到：\n$$\nG_{i-1,j} - 2 G_{i,j} + G_{i+1,j} = h^{2} \\delta_{i j}\n$$\n\n对于任何满足 $i \\neq j$ 的指数 $i$，方程右侧为零，我们得到一个齐次二阶线性差分方程：\n$$\nG_{i-1,j} - 2 G_{i,j} + G_{i+1,j} = 0\n$$\n该差分方程的特征方程为 $r^2 - 2r + 1 = 0$，可化简为 $(r-1)^2 = 0$。这表明有一个重根 $r=1$。对于重根，作为 $i$ 的函数，$G_{i,j}$ 的通解是一个线性函数：\n$$\nG_{i,j} = A i + B\n$$\n其中系数 $A$ 和 $B$ 在区域 $i  j$ 和 $i > j$ 中可以不同。\n\n让我们在由源位置 $j$ 决定的两个区域中分析解。\n\n**区域 1: $0 \\le i \\le j$**\n通解为 $G_{i,j} = c_1 i + d_1$。应用在 $i=0$ 处的边界条件：\n$$\nG_{0,j} = c_1(0) + d_1 = 0 \\implies d_1 = 0\n$$\n因此，对于 $0 \\le i \\le j$，解的形式为：\n$$\nG_{i,j} = c_1 i\n$$\n\n**区域 2: $j \\le i \\le N$**\n通解为 $G_{i,j} = c_2 i + d_2$。应用在 $i=N$ 处的边界条件：\n$$\nG_{N,j} = c_2 N + d_2 = 0 \\implies d_2 = -c_2 N\n$$\n因此，对于 $j \\le i \\le N$，解的形式为：\n$$\nG_{i,j} = c_2(i - N)\n$$\n\n现在，我们必须在点 $i=j$ 处连接这两种形式，并施加来自源项的条件。\n首先，序列 $G_{i,j}$ 的值在 $i=j$ 处必须是唯一定义的。这意味着来自两个区域的表达式在 $i=j$ 处必须相等：\n$$\nc_1 j = c_2 (j - N) \\quad (1)\n$$\n\n其次，我们在 $i=j$ 处使用完整的非齐次方程：\n$$\nG_{j-1,j} - 2 G_{j,j} + G_{j+1,j} = h^{2}\n$$\n代入来自每个区域的 $G_{i,j}$ 的表达式：\n- $G_{j-1,j} = c_1(j-1)$ (因为 $j-1  j$)\n- $G_{j,j} = c_1 j = c_2(j-N)$\n- $G_{j+1,j} = c_2(j+1 - N)$ (因为 $j+1 > j$)\n将这些代入 $i=j$ 处的方程：\n$$\nc_1(j-1) - 2(c_1 j) + c_2(j+1 - N) = h^{2}\n$$\n展开并化简：\n$$\nc_1 j - c_1 - 2c_1 j + c_2(j-N) + c_2 = h^{2}\n$$\n$$\n-c_1 j - c_1 + c_2(j-N) + c_2 = h^{2}\n$$\n使用方程 $(1)$，我们可以用 $c_1 j$ 替换 $c_2(j-N)$：\n$$\n-c_1 j - c_1 + (c_1 j) + c_2 = h^{2}\n$$\n$$\nc_2 - c_1 = h^{2} \\quad (2)\n$$\n\n现在我们得到了一个关于系数 $c_1$ 和 $c_2$ 的二元一次方程组：\n1. $c_1 j = c_2 (j - N)$\n2. $c_2 = c_1 + h^{2}$\n\n将 $(2)$ 代入 $(1)$：\n$$\nc_1 j = (c_1 + h^{2})(j-N) = c_1 j - c_1 N + h^{2}j - h^{2}N\n$$\n$$\n0 = -c_1 N + h^2(j-N)\n$$\n$$\nc_1 N = h^{2}(j-N) \\implies c_1 = \\frac{h^{2}(j-N)}{N}\n$$\n现在，使用方程 $(2)$ 求 $c_2$：\n$$\nc_2 = c_1 + h^{2} = \\frac{h^{2}(j-N)}{N} + h^{2} = \\frac{h^{2}j - h^{2}N + h^{2}N}{N} = \\frac{h^{2}j}{N}\n$$\n正如预期的那样，系数 $c_1$ 和 $c_2$ 依赖于源指数 $j$。\n\n因此，$G_{i,j}$ 的分段表达式为：\n$$\nG_{i,j} = \\begin{cases} \\frac{h^{2}(j-N)}{N} i  \\text{if } 0 \\le i \\le j \\\\ \\frac{h^{2}j}{N} (i-N)  \\text{if } j \\le i \\le N \\end{cases}\n$$\n这个表达式可以使用 $\\min(i,j)$ 和 $\\max(i,j)$ 统一成单一的闭式形式。令 $i_ = \\min(i,j)$ 和 $i_ = \\max(i,j)$。\n如果 $i \\le j$，那么 $i_=i$ 且 $i_=j$。该公式给出 $\\frac{h^2 i (j-N)}{N} = \\frac{h^2}{N} i_ (i_ - N)$。\n如果 $i  j$，那么 $i_=j$ 且 $i_=i$。该公式给出 $\\frac{h^2 j (i-N)}{N} = \\frac{h^2}{N} i_ (i_ - N)$。\n两种情况都匹配。因此，离散格林函数的单一闭式表达式为：\n$$\nG_{i,j} = \\frac{h^{2}}{N} \\min(i,j) (\\max(i,j) - N)\n$$\n\n### 第二部分：通过卷积验证解\n\n问题提出离散泊松方程的解由离散卷积给出：\n$$\nu_{i} = \\sum_{j=1}^{N-1} G_{i,j} f_{j}\n$$\n我们必须从第一性原理验证这个 $u_i$ 的表达式同时满足微分方程和边界条件。\n\n首先，我们检验 $i \\in \\{1, 2, \\dots, N-1\\}$ 时的离散泊松方程。我们将离散二阶导数算子作用于 $u_i$：\n$$\n\\frac{u_{i-1} - 2 u_{i} + u_{i+1}}{h^{2}}\n$$\n代入 $u_i$ 的表达式：\n$$\n\\frac{1}{h^{2}} \\left( \\left(\\sum_{j=1}^{N-1} G_{i-1,j} f_{j}\\right) - 2\\left(\\sum_{j=1}^{N-1} G_{i,j} f_{j}\\right) + \\left(\\sum_{j=1}^{N-1} G_{i+1,j} f_{j}\\right) \\right)\n$$\n由于求和是在相同的指数 $j$ 上进行的，并且是有限的，我们可以将它们合并：\n$$\n\\sum_{j=1}^{N-1} \\left( \\frac{G_{i-1,j} - 2G_{i,j} + G_{i+1,j}}{h^{2}} \\right) f_{j}\n$$\n根据格林函数 $G_{i,j}$ 的定义，括号中的项恰好是克罗内克 delta 函数 $\\delta_{ij}$：\n$$\n\\sum_{j=1}^{N-1} \\delta_{ij} f_{j}\n$$\n克罗内克 delta 函数的筛选性质意味着求和会简化为单项，即 $j=i$ 的那一项：\n$$\nf_{i}\n$$\n因此，我们证明了 $\\frac{u_{i-1} - 2 u_{i} + u_{i+1}}{h^{2}} = f_i$，这验证了所提出的解在所有内部点都满足离散泊松方程。\n\n其次，我们必须检验边界条件。\n对于 $i=0$：\n$$\nu_{0} = \\sum_{j=1}^{N-1} G_{0,j} f_{j}\n$$\n根据构造，格林函数对所有 $j$ 都满足 $G_{0,j}=0$。因此：\n$$\nu_{0} = \\sum_{j=1}^{N-1} (0) f_{j} = 0\n$$\n对于 $i=N$：\n$$\nu_{N} = \\sum_{j=1}^{N-1} G_{N,j} f_{j}\n$$\n类似地，格林函数对所有 $j$ 都满足 $G_{N,j}=0$。因此：\n$$\nu_{N} = \\sum_{j=1}^{N-1} (0) f_{j} = 0\n$$\n两个边界条件都得到满足。验证完成。推导出的格林函数与源项进行卷积，正确地求解了给定的边值问题。\n格林函数的最终闭式表达式如下所示。", "answer": "$$ \\boxed{\\frac{h^{2}}{N} \\min(i,j) (\\max(i,j) - N)} $$", "id": "3114358"}, {"introduction": "最后，我们以一个更高级、更贴近现实世界的场景作为结束：如何从充满噪声和模糊的测量数据中恢复原始信号。这是一个经典的“逆问题”。这项练习 [@problem_id:3114304] 介绍了维纳反卷积，这是一种优雅而强大的技术，它能找到统计意义上的最优滤波器，以逆转卷积效应并最大程度地抑制噪声。从第一性原理出发推导维纳滤波器，将凸显功率谱密度和均方误差等概念如何被用来正则化解，从而实现稳健的信号恢复。", "problem": "给定一个离散时间、实值、有限长度的信号模型，其中未知输入 $x$ 通过一个冲激响应为 $h$ 的线性时不变系统进行观测，并受到加性噪声 $n$ 的污染，产生 $y$，其遵循 $y = x * h + n$，其中 $*$ 表示离散卷积。您的任务是从第一性原理出发，推导出一个频域滤波器，该滤波器能够最小化估计值 $\\hat{x}$ 与真实输入 $x$ 之间的期望均方误差（Mean Squared Error (MSE)），此时 $x$ 和 $n$ 是宽平稳且相互独立的，并且给定 $x$ 的功率谱密度（Power Spectral Density (PSD)）$S_{xx}(\\omega)$ 和 $n$ 的功率谱密度 $S_{nn}(\\omega)$。然后，您必须实现由此产生的维纳反卷积过程，使用快速傅里叶变换（Fast Fourier Transform (FFT)）在频域中操作，从 $y$ 中恢复 $\\hat{x}$。\n\n您的推导应严格从适用于该主题的基本定义和原理开始。允许使用的基础包括：离散卷积的定义、宽平稳性的定义及其通过傅里叶变换与自相关和功率谱密度的联系、均方误差的定义以及独立性属性。请勿使用或引用任何预先推导出的维纳滤波器公式或中间捷径表达式。您的推导应基于 $y$、系统频率响应 $H(\\omega)$ 以及谱 $S_{xx}(\\omega)$ 和 $S_{nn}(\\omega)$，建立 $x$ 的最优频域估计器的结构。\n\n实现要求：\n- 使用长度为 $N$ 的循环卷积，以确保离散傅里叶变换能精确地对角化卷积。对于长度均为 $N$ 的序列 $x$ 和冲激响应 $h$，按 $y = \\mathcal{F}^{-1}\\{\\mathcal{F}\\{x\\} \\cdot \\mathcal{F}\\{h\\}\\} + n$ 形成 $y$，其中 $\\mathcal{F}$ 表示离散傅里叶变换，$\\mathcal{F}^{-1}$ 表示其逆变换。\n- 使用您推导的表达式，在离散频率网格 $\\omega_k = 2\\pi k / N$（其中 $k = 0, 1, \\dots, N-1$）上逐点应用，构建频域反卷积滤波器。\n- 当 $x$ 是1阶自回归（AutoRegressive (AR) of order 1）过程时，使用其已知的参数形式 $S_{xx}(\\omega)$，即 $x[n] = \\phi x[n-1] + w[n]$，其中 $w[n]$ 是方差为 $\\sigma_w^2$ 的白高斯噪声，因此 $$S_{xx}(\\omega) = \\frac{\\sigma_w^2}{\\left|1 - \\phi e^{-j\\omega}\\right|^2}。$$ 对于方差为 $\\sigma_n^2$ 的白高斯噪声 $n$，使用 $S_{nn}(\\omega) = \\sigma_n^2$。\n- 按照规定，使用固定的种子生成所有随机序列，以确保可复现性。\n\n测试套件和参数：\n实现您的程序，使其无需任何用户输入即可运行以下三个测试用例。在每种情况下，所有序列的长度均为 $N$，并使用循环卷积。\n\n1. 情况 A（中等模糊和中等噪声）：\n- $N = 256$。\n- 输入 $x$ 是 AR(1) 过程，参数 $\\phi = 0.9$，驱动噪声方差 $\\sigma_w^2 = 1.0$。\n- 冲激响应 $h$ 是长度为 $N$ 的圆上的循环对称离散高斯核，标准差 $s = 3.0$ 个样本，定义为 $h[k] = \\exp\\left(-\\frac{1}{2}\\left(\\frac{d(k)}{s}\\right)^2\\right)$，其中 $k=0,\\dots,N-1$，$d(k) = \\min(k, N-k)$，并进行归一化，使得 $\\sum_{k=0}^{N-1} h[k] = 1$。\n- 加性噪声 $n$ 是白高斯噪声，方差 $\\sigma_n^2 = 0.2$。\n- 随机种子：生成 AR(1) 输入时使用种子 $x\\_seed = 0$，生成加性噪声时使用种子 $n\\_seed = 10$。\n\n2. 情况 B（单位系统和极低噪声）：\n- $N = 128$。\n- 输入 $x$ 是 AR(1) 过程，参数 $\\phi = 0.6$，驱动噪声方差 $\\sigma_w^2 = 1.0$。\n- 冲激响应 $h$ 是离散的 $\\delta$ 函数，即 $h[0] = 1$ 且对于 $k \\neq 0$ 有 $h[k] = 0$。\n- 加性噪声 $n$ 是白高斯噪声，方差 $\\sigma_n^2 = 0.01$。\n- 随机种子：生成 AR(1) 输入时使用种子 $x\\_seed = 1$，生成加性噪声时使用种子 $n\\_seed = 11$。\n\n3. 情况 C（近陷波系统和高噪声）：\n- $N = 512$。\n- 输入 $x$ 是 AR(1) 过程，参数 $\\phi = 0.95$，驱动噪声方差 $\\sigma_w^2 = 1.0$。\n- 冲激响应 $h$ 是双抽头的，其中 $h[0] = 1$ 和 $h[1] = -0.95$，对于 $k \\ge 2$ 有 $h[k] = 0$。\n- 加性噪声 $n$ 是白高斯噪声，方差 $\\sigma_n^2 = 0.5$。\n- 随机种子：生成 AR(1) 输入时使用种子 $x\\_seed = 2$，生成加性噪声时使用种子 $n\\_seed = 12$。\n\n对于每种情况，通过模拟1阶自回归递归 $x[n] = \\phi x[n-1] + w[n]$（$n = 0,\\dots,N-1$，其中 $x[0] = w[0]$，$w[n]$ 是方差为 $\\sigma_w^2$ 的独立同分布高斯样本）来生成 $x$。将 $n$ 生成为方差为 $\\sigma_n^2$ 的独立高斯样本。通过长度为 $N$ 的循环卷积构建 $y$ 并加上 $n$。使用已知的 $S_{xx}(\\omega)$ 和 $S_{nn}(\\omega)$ 在离散频率网格上，通过您推导的维纳反卷积滤波器计算 $\\hat{x}$。\n\n可量化的答案：\n对于每个测试用例，计算估计值与真实输入之间的实际均方误差，\n$$\\text{MSE} = \\frac{1}{N}\\sum_{n=0}^{N-1}\\left(\\hat{x}[n] - x[n]\\right)^2$$\n并报告这三个 MSE 值。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按情况 A、情况 B、情况 C 顺序排列的三个 MSE 值，形式为由方括号括起来的逗号分隔列表，每个值四舍五入到六位小数（例如，$[\\text{mse\\_A},\\text{mse\\_B},\\text{mse\\_C}]$）。", "solution": "问题是推导并实现一个最优线性滤波器，用于从测量值 $y$ 中估计信号 $x$。测量值 $y$ 是 $x$ 与系统响应 $h$ 卷积并加上噪声 $n$ 的结果。模型由 $y = x * h + n$ 给出，其中 $*$ 表示离散卷积。最优性准则是最小化真实信号 $x$ 与其估计值 $\\hat{x}$ 之间的均方误差（MSE）。\n\n我们的推导从第一性原理出发，假设信号 $x$ 和噪声 $n$ 是实值、宽平稳（WSS）的随机过程，并且它们相互独立，均值为零。我们已知它们的功率谱密度（PSD），分别表示为 $S_{xx}(\\omega)$ 和 $S_{nn}(\\omega)$。\n\n设估计值 $\\hat{x}$ 是通过将一个冲激响应为 $g$ 的线性时不变（LTI）滤波器应用于观测信号 $y$ 得到的。\n$$\n\\hat{x}[k] = (g * y)[k] = \\sum_{m} g[k-m] y[m]\n$$\n估计误差定义为 $e[k] = x[k] - \\hat{x}[k]$。我们的目标是找到能最小化 MSE 的滤波器 $g$，对于宽平稳过程，MSE 是误差平方的期望值，与时间索引 $k$ 无关。\n$$\n\\text{MSE} = J = E\\left[ e[k]^2 \\right]\n$$\n我们首先用输入信号和系统响应来表示误差 $e[k]$。\n$$\ne[k] = x[k] - (g * y)[k] = x[k] - (g * (x * h + n))[k]\n$$\n利用卷积的线性和结合律，我们得到：\n$$\ne[k] = x[k] - (g * h * x)[k] - (g * n)[k]\n$$\nMSE 是误差信号的方差，即 $J = E[e[k]^2]$。对于宽平稳过程，信号的平均功率由其在延迟为零时的自协方差 $R_{ee}[0]$ 给出。根据维纳-辛钦定理，这与误差的功率谱密度 $S_{ee}(\\omega)$ 的积分有关。\n$$\nJ = R_{ee}[0] = \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} S_{ee}(\\omega) \\,d\\omega\n$$\n为了最小化 $J$，我们可以等效地对每个频率 $\\omega$ 最小化误差功率谱密度 $S_{ee}(\\omega)$。这是可行的，因为被积函数是非负的。我们使用傅里叶变换转换到频域，傅里叶变换可以对角化线性时不变系统的卷积运算。设 $\\mathcal{F}$ 为傅里叶变换算子。设 $X(\\omega)$、$H(\\omega)$、$N(\\omega)$、$G(\\omega)$ 和 $E(\\omega)$ 分别是 $x[k]$、$h[k]$、$n[k]$、$g[k]$ 和 $e[k]$ 的傅里叶变换。\n\n误差的频域表示为：\n$$\nE(\\omega) = X(\\omega) - G(\\omega) \\left( X(\\omega)H(\\omega) + N(\\omega) \\right)\n$$\n重新整理各项，我们得到：\n$$\nE(\\omega) = X(\\omega) \\left( 1 - G(\\omega)H(\\omega) \\right) - G(\\omega)N(\\omega)\n$$\n误差的功率谱密度 $S_{ee}(\\omega)$ 是其傅里叶变换 $E(\\omega)$ 的模平方的期望值。对于长度为 $N$ 的离散时间过程，这正式定义为 $S_{ee}(\\omega_k) = E[|E(\\omega_k)|^2]$。\n$$\nS_{ee}(\\omega) = E\\left[ \\left| X(\\omega) \\left( 1 - G(\\omega)H(\\omega) \\right) - G(\\omega)N(\\omega) \\right|^2 \\right]\n$$\n展开模平方项 $|A-B|^2 = (A-B)(A-B)^* = |A|^2 - AB^* - A^*B + |B|^2$：\n$$\nS_{ee}(\\omega) = E\\left[ |X(\\omega)|^2 |1 - G(\\omega)H(\\omega)|^2 - X(\\omega)(1-G(\\omega)H(\\omega))G(\\omega)^*N(\\omega)^* - X(\\omega)^*(1-G(\\omega)H(\\omega))^*G(\\omega)N(\\omega) + |G(\\omega)|^2|N(\\omega)|^2 \\right]\n$$\n我们对每一项应用期望算子。由于 $x$ 和 $n$ 相互独立且均值为零，涉及 $X(\\omega)$ 和 $N(\\omega)$ 乘积的交叉项的期望值为零。例如，$E[X(\\omega)N(\\omega)^*] = E[X(\\omega)]E[N(\\omega)^*] = 0 \\cdot 0 = 0$。\n这极大地简化了表达式：\n$$\nS_{ee}(\\omega) = E\\left[ |X(\\omega)|^2 \\right] |1 - G(\\omega)H(\\omega)|^2 + |G(\\omega)|^2 E\\left[ |N(\\omega)|^2 \\right]\n$$\n根据定义，$S_{xx}(\\omega) = E[|X(\\omega)|^2]$ 且 $S_{nn}(\\omega) = E[|N(\\omega)|^2]$。因此，误差功率谱密度为：\n$$\nS_{ee}(\\omega) = S_{xx}(\\omega) |1 - G(\\omega)H(\\omega)|^2 + S_{nn}(\\omega) |G(\\omega)|^2\n$$\n我们的目标是找到对于每个 $\\omega$ 都能最小化此表达式的复值滤波器响应 $G(\\omega)$。让我们展开各项，为清晰起见暂时省略对 $\\omega$ 的依赖：\n$$\nS_{ee} = S_{xx} (1 - GH)(1 - G^*H^*) + S_{nn} GG^*\n$$\n$$\nS_{ee} = S_{xx} (1 - G^*H^* - GH + |G|^2|H|^2) + S_{nn} |G|^2\n$$\n$$\nS_{ee} = S_{xx} - S_{xx}G^*H^* - S_{xx}GH + |G|^2 \\left( S_{xx}|H|^2 + S_{nn} \\right)\n$$\n为了找到关于复变量 $G$ 的最小值，我们可以使用 Wirtinger 导数，将关于 $G^*$ 的导数置为零，并将 $G$ 和 $G^*$ 视为独立变量。\n$$\n\\frac{\\partial S_{ee}}{\\partial G^*} = -S_{xx}H^* + G \\left( S_{xx}|H|^2 + S_{nn} \\right)\n$$\n将此导数置为零，得到最优滤波器 $G$：\n$$\n-S_{xx}H^* + G_{opt} \\left( S_{xx}|H|^2 + S_{nn} \\right) = 0\n$$\n解出 $G_{opt}$：\n$$\nG_{opt}(\\omega) = \\frac{S_{xx}(\\omega)H(\\omega)^*}{S_{xx}(\\omega)|H(\\omega)|^2 + S_{nn}(\\omega)}\n$$\n这就是著名的维纳反卷积滤波器。分子项 $S_{xx}(\\omega)H(\\omega)^*$ 试图对系统进行逆运算，并由信号的功率加权。分母是观测信号 $y$ 的功率谱密度，因为利用 $x$ 和 $n$ 的独立性，可得 $S_{yy}(\\omega) = E[|X(\\omega)H(\\omega)+N(\\omega)|^2] = S_{xx}(\\omega)|H(\\omega)|^2 + S_{nn}(\\omega)$。该滤波器可以重写为：\n$$\nG_{opt}(\\omega) = \\frac{S_{xx}(\\omega)H(\\omega)^*}{S_{yy}(\\omega)} = \\frac{1}{H(\\omega)} \\frac{S_{xx}(\\omega)|H(\\omega)|^2}{S_{xx}(\\omega)|H(\\omega)|^2 + S_{nn}(\\omega)} = \\frac{1}{H(\\omega)} \\frac{\\text{SNR}(\\omega) \\cdot |H(\\omega)|^2}{\\text{SNR}(\\omega) \\cdot |H(\\omega)|^2 + 1}\n$$\n其中 $\\text{SNR}(\\omega) = S_{xx}(\\omega)/S_{nn}(\\omega)$。这种形式表明，该滤波器在信噪比高的频率处逼近逆滤波器 $1/H(\\omega)$，而在信噪比低的频率处衰减输出，从而防止噪声放大。\n\n对于实现，我们使用这些公式的离散版本。连续频率 $\\omega$ 被离散频率 $\\omega_k = 2\\pi k/N$（其中 $k \\in \\{0, 1, \\dots, N-1\\}$）所取代。傅里叶变换变为离散傅里叶变换（DFT），通过快速傅里叶变换（FFT）算法计算。\n系统的频率响应 $H(\\omega_k)$ 由冲激响应 $h[n]$ 的 FFT 给出。功率谱密度 $S_{xx}(\\omega_k)$ 和 $S_{nn}(\\omega_k)$ 在这些离散频率上进行评估。\n- 对于 AR(1) 过程 $x[n]=\\phi x[n-1]+w[n]$，其功率谱密度为 $S_{xx}(\\omega) = \\frac{\\sigma_w^2}{|1 - \\phi e^{-j\\omega}|^2}$。\n- 对于白噪声 $n[n]$，其功率谱密度为常数：$S_{nn}(\\omega) = \\sigma_n^2$。\n\n实现步骤如下：\n1. 根据给定的参数和随机种子，生成真实信号 $x[n]$ 和加性噪声 $n[n]$。\n2. 为给定情况定义冲激响应 $h[n]$。\n3. 通过 FFT 使用循环卷积计算观测信号 $y[n]$：$y = \\mathcal{F}^{-1}\\{\\mathcal{F}\\{x\\} \\cdot \\mathcal{F}\\{h\\}\\} + n$。\n4. 计算频率响应 $H[k] = \\mathcal{F}\\{h[n]\\}$。\n5. 在离散频率 $\\omega_k$ 上评估功率谱密度 $S_{xx}[k]$ 和 $S_{nn}[k]$。\n6. 在频域中构建维纳滤波器：$G[k] = \\frac{S_{xx}[k]H[k]^*}{S_{xx}[k]|H[k]|^2 + S_{nn}[k]}$。\n7. 在频域中将滤波器应用于观测信号：$\\hat{X}[k] = G[k] \\cdot \\mathcal{F}\\{y[n]\\}$。\n8. 将估计值变换回时域：$\\hat{x}[n] = \\mathcal{F}^{-1}\\{\\hat{X}[k]\\}$。\n9. 计算实际 MSE：$\\frac{1}{N}\\sum_{n=0}^{N-1} (\\hat{x}[n] - x[n])^2$。\n对所有三个指定的测试用例重复此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements the Wiener deconvolution filter for three test cases.\n    \"\"\"\n\n    def generate_ar1(N, phi, sigma_w_sq, seed):\n        \"\"\"Generates a single realization of an AR(1) process.\"\"\"\n        rng = np.random.default_rng(seed)\n        sigma_w = np.sqrt(sigma_w_sq)\n        w = rng.normal(scale=sigma_w, size=N)\n        x = np.zeros(N)\n        # Per problem spec: x[0] = w[0].\n        # Note: This makes the process not strictly stationary at the start.\n        x[0] = w[0]\n        for n in range(1, N):\n            x[n] = phi * x[n-1] + w[n]\n        return x\n\n    def run_case(N, phi, sigma_w_sq, h_def, sigma_n_sq, x_seed, n_seed):\n        \"\"\"\n        Runs a single deconvolution test case.\n\n        Args:\n            N (int): Signal length.\n            phi (float): AR(1) parameter for the input signal x.\n            sigma_w_sq (float): Driving noise variance for x.\n            h_def (tuple): Definition of the impulse response h.\n            sigma_n_sq (float): Variance of the additive white noise n.\n            x_seed (int): Random seed for generating x.\n            n_seed (int): Random seed for generating n.\n\n        Returns:\n            float: The mean squared error between the estimated signal and the true signal.\n        \"\"\"\n        # 1. Generate signals\n        x_true = generate_ar1(N, phi, sigma_w_sq, x_seed)\n        \n        rng_n = np.random.default_rng(n_seed)\n        noise = rng_n.normal(scale=np.sqrt(sigma_n_sq), size=N)\n\n        # 2. Define impulse response h\n        h = np.zeros(N)\n        htype, params = h_def\n        if htype == 'gaussian':\n            s = params['s']\n            k = np.arange(N)\n            d = np.minimum(k, N - k)\n            h = np.exp(-0.5 * (d / s)**2)\n            h /= np.sum(h) # Normalize\n        elif htype == 'delta':\n            h[0] = 1.0\n        elif htype == 'two-tap':\n            h[0] = 1.0\n            h[1] = -0.95\n\n        # 3. Create observed signal y = x * h + n using circular convolution\n        X_true_fft = np.fft.fft(x_true)\n        H_fft = np.fft.fft(h)\n        y_conv = np.real(np.fft.ifft(X_true_fft * H_fft))\n        y_obs = y_conv + noise\n\n        # 4. Construct the Wiener filter G\n        # Discrete frequencies\n        omega_k = (2 * np.pi / N) * np.arange(N)\n        \n        # PSD of AR(1) signal x\n        S_xx = sigma_w_sq / np.abs(1 - phi * np.exp(-1j * omega_k))**2\n        \n        # PSD of white noise n\n        S_nn = np.full(N, sigma_n_sq)\n        \n        # Wiener filter G in the frequency domain\n        G_numerator = S_xx * np.conj(H_fft)\n        G_denominator = S_xx * np.abs(H_fft)**2 + S_nn\n        G_fft = G_numerator / G_denominator\n\n        # 5. Apply the filter to estimate x\n        Y_obs_fft = np.fft.fft(y_obs)\n        X_hat_fft = G_fft * Y_obs_fft\n        x_hat = np.real(np.fft.ifft(X_hat_fft))\n\n        # 6. Calculate realized MSE\n        mse = np.mean((x_hat - x_true)**2)\n        \n        return mse\n\n    # --- Test Cases ---\n    test_cases = [\n        # Case A: Moderate blur, moderate noise\n        {\n            \"N\": 256, \"phi\": 0.9, \"sigma_w_sq\": 1.0,\n            \"h_def\": ('gaussian', {'s': 3.0}),\n            \"sigma_n_sq\": 0.2, \"x_seed\": 0, \"n_seed\": 10\n        },\n        # Case B: Identity system, very low noise\n        {\n            \"N\": 128, \"phi\": 0.6, \"sigma_w_sq\": 1.0,\n            \"h_def\": ('delta', {}),\n            \"sigma_n_sq\": 0.01, \"x_seed\": 1, \"n_seed\": 11\n        },\n        # Case C: Near-notched system, high noise\n        {\n            \"N\": 512, \"phi\": 0.95, \"sigma_w_sq\": 1.0,\n            \"h_def\": ('two-tap', {}),\n            \"sigma_n_sq\": 0.5, \"x_seed\": 2, \"n_seed\": 12\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        mse = run_case(**case)\n        results.append(mse)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{m:.6f}' for m in results)}]\")\n\nsolve()\n```", "id": "3114304"}]}