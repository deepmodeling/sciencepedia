{"hands_on_practices": [{"introduction": "理论上，傅里叶变换是一个强大的工具，但如何从一个给定的频谱 $X(\\omega)$ 反演出时域信号 $x(t)$ 呢？这个练习将展示一种核心技巧：通过简单的代数变形，将复杂的频谱函数分解为我们熟知的基本傅里叶变换对的线性组合。这个过程不仅能帮助你求解逆变换，更能加深你对线性时不变（LTI）系统频率响应的理解。[@problem_id:1762456]", "problem": "考虑一个稳定的线性时不变（LTI）系统，其行为在频域中进行描述。该系统的频率响应关联了输出频谱与输入频谱，由以下函数给出：\n$$ H(\\omega) = \\frac{j\\omega}{\\alpha + j\\omega} $$\n此处，$\\omega$ 是角频率，$j$ 是满足 $j^2 = -1$ 的虚数单位，$\\alpha$ 是一个表征系统特性的实正常数。\n\n确定该系统的冲激响应 $h(t)$。冲激响应是频率响应 $H(\\omega)$ 的连续时间傅里叶逆变换（CTFT）。您的答案应为一个关于 $t$ 和 $\\alpha$ 的表达式。", "solution": "我们要求解冲激响应 $h(t)$，它是 $H(\\omega)$ 的连续时间傅里叶逆变换（CTFT）。采用如下 CTFT 约定\n$$\nX(\\omega) = \\int_{-\\infty}^{\\infty} x(t)\\,\\exp(-j\\omega t)\\,dt,\\quad\nx(t) = \\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty} X(\\omega)\\,\\exp(j\\omega t)\\,d\\omega.\n$$\n给定 $H(\\omega) = \\dfrac{j\\omega}{\\alpha + j\\omega}$ 且 $\\alpha > 0$，首先通过简单的代数运算重写 $H(\\omega)$：\n$$\nH(\\omega) = \\frac{j\\omega}{\\alpha + j\\omega} = \\frac{\\alpha + j\\omega - \\alpha}{\\alpha + j\\omega} = 1 - \\frac{\\alpha}{\\alpha + j\\omega}.\n$$\n根据连续时间傅里叶逆变换的线性性质，\n$$\nh(t) = \\mathcal{F}^{-1}\\{H(\\omega)\\} = \\mathcal{F}^{-1}\\{1\\} - \\alpha\\,\\mathcal{F}^{-1}\\left\\{\\frac{1}{\\alpha + j\\omega}\\right\\}.\n$$\n在上述约定下，使用标准的 CTFT 变换对：\n- $\\delta(t) \\leftrightarrow 1$，因此 $\\mathcal{F}^{-1}\\{1\\} = \\delta(t)$。\n- 对于 $\\alpha > 0$，$\\exp(-\\alpha t)u(t) \\leftrightarrow \\dfrac{1}{\\alpha + j\\omega}$，因此 $\\mathcal{F}^{-1}\\left\\{\\dfrac{1}{\\alpha + j\\omega}\\right\\} = \\exp(-\\alpha t)u(t)$。\n\n因此，\n$$\nh(t) = \\delta(t) - \\alpha\\,\\exp(-\\alpha t)\\,u(t).\n$$\n该冲激响应对应于一个稳定的一阶高通 LTI 系统，其在 $-\\alpha$ 处有一个极点，在原点有一个零点。", "answer": "$$\\boxed{\\delta(t)-\\alpha \\exp(-\\alpha t) u(t)}$$", "id": "1762456"}, {"introduction": "从连续的数学定义到实际的计算机实现，傅里叶变换的计算充满了挑战和细节。这个实践将引导你搭建一个计算流程，使用离散傅里叶变换（DFT）来近似连续傅里叶变换（CTFT），并直面一个常见的数值计算问题——频谱泄漏。你将学习如何量化泄漏效应，并应用窗函数（windowing）这一关键技术来显著改善计算结果的准确性。[@problem_id:3112450]", "problem": "您需要实现一个完整的、基于第一性原理的计算流程，用于近似计算带有跳跃间断点的分段定义函数的连续时间傅里叶变换，诊断谱泄漏，并通过边界平滑来减轻它。请使用连续时间傅里叶变换（CTFT）的基本定义，并以此为基础构建算法步骤。每当使用角度时，单位必须是弧度。不涉及物理单位。\n\n从连续时间傅里叶变换（CTFT）的核心定义开始：给定一个在 $[0,1]$ 上具有有限支撑的实值函数 $f(x)$，其 CTFT 是一个映射 $\\omega \\mapsto F(\\omega)$，其中 $F(\\omega)$ 通过与复指数的积分来定义。您必须通过在 $f$ 的定义域上构建的均匀网格上的黎曼和来近似 $F(\\omega)$，并且必须通过一个定量的尾部能量度量来诊断谱泄漏。然后，提出并实现一种边界平滑方法，在定义域边缘强制实现连续性，并根据经验减少谱泄漏。\n\n您的程序必须使用纯粹的数学和算法逻辑执行以下任务：\n\n- 在 $[0,1]$ 上构建一个包含 $N$ 个点的均匀网格，其中 $N = 4096$。将网格表示为 $x_n = n \\Delta x$，对于 $n \\in \\{0,1,\\ldots,N-1\\}$，其中 $\\Delta x = 1/N$。\n- 对于每个在 $[0,1]$ 上由具有跳跃间断点的分段常数段定义的测试用例函数 $f$，请在网格上对 $f$ 进行采样。\n- 对于离散角频率 $\\omega_k = \\frac{2\\pi k}{T}$（其中 $k \\in \\{-\\lfloor N/2 \\rfloor, \\ldots, \\lfloor N/2 \\rfloor - 1\\}$ 且 $T = 1$），通过一个等效于由 $\\Delta x$ 缩放的离散傅里叶变换（DFT）的黎曼和来近似计算 CTFT。在均匀采样序列上定义离散傅里叶变换（DFT），并用它来计算无平滑和有边界平滑两种情况下的近似值 $\\hat{F}(\\omega_k)$。\n- 对于一个近似 $\\hat{F}$，通过超出指定角频率阈值的尾部能量分数来定义谱泄漏。设尾部阈值为 $\\omega_{\\text{tail}} = 200\\pi$。泄漏度量是在 $|\\omega| > \\omega_{\\text{tail}}$ 范围外的能量与所有采样频率上的总能量之比。能量由幅度的平方 $|\\hat{F}(\\omega_k)|^2$ 计算得出；任何统一的频率权重因子在该分数中都会被抵消。\n- 实现一种边界平滑，通过将采样后的 $f$ 乘以一个在端点处为零且在内部严格为正的光滑锥削函数，来强制在 $x=0$ 和 $x=1$ 处实现连续性。在离散网格上使用汉宁（Hann）锥削窗 $w(n)$，其定义为 $w(0) = 0$ 和 $w(N-1) = 0$，并且当 $w(n)$ 被视为 $x_n$ 的函数时，它在 $n$ 上是连续的。计算未平滑情况（在整个网格上等于 $1$ 的矩形窗）和平滑情况（汉宁锥削窗）的 CTFT 近似，然后计算它们各自的泄漏分数。\n- 对于每个测试用例，将未平滑的泄漏分数与平滑后的泄漏分数之比作为边界平滑带来的改善进行报告。大于 $1$ 的比率表示平滑减少了泄漏。\n\n测试套件规范：\n\n设 $T = 1$ 且 $N = 4096$。使用以下分段列表在 $[0,1]$ 上定义三个分段常数测试函数，其中除最后一个分段为 $[a,b]$ 外，每个分段均为 $[a,b)$，并且在每个分段上，函数等于给定的常数值。\n\n- 案例 1（存在边界不连续性）：$f(x) = 2$ 在 $[0,0.4)$ 上，$f(x) = -1$ 在 $[0.4,0.7)$ 上，以及 $f(x) = 0$ 在 $[0.7,1]$ 上。\n- 案例 2（端点处边界连续）：$f(x) = 0$ 在 $[0,0.3)$ 上，$f(x) = 3$ 在 $[0.3,0.6)$ 上，以及 $f(x) = 0$ 在 $[0.6,1]$ 上。\n- 案例 3（窄内部跳跃，端点为零）：$f(x) = 0$ 在 $[0,0.49)$ 上，$f(x) = 5$ 在 $[0.49,0.51)$ 上，以及 $f(x) = 0$ 在 $[0.51,1]$ 上。\n\n对每个案例，计算：\n\n- 未平滑矩形窗近似的泄漏分数，表示为 $\\lambda_{\\text{rect}}$。\n- 汉宁（Hann）锥削近似的泄漏分数，表示为 $\\lambda_{\\text{hann}}$。\n- 泄漏减少比率 $r = \\lambda_{\\text{rect}} / \\lambda_{\\text{hann}}$。\n\n最终输出格式要求：\n\n您的程序应生成单行输出，其中包含三个测试用例的泄漏减少比率，格式为方括号内以逗号分隔的列表，每个浮点数四舍五入到 $6$ 位小数，例如 $[r_1,r_2,r_3]$。角度必须以弧度为单位，角频率阈值为 $\\omega_{\\text{tail}} = 200\\pi$。", "solution": "我们从连续时间傅里叶变换（CTFT）的基本定义开始。对于在 $[0,1]$ 上有支撑的实值函数 $f(x)$，其 CTFT 是由积分定义的函数 $F(\\omega)$\n$$\nF(\\omega) = \\int_{-\\infty}^{\\infty} f(x) e^{-i \\omega x} \\, dx,\n$$\n当 $f(x)$ 在 $[0,1]$ 之外为零时，积分简化为\n$$\nF(\\omega) = \\int_{0}^{1} f(x) e^{-i \\omega x} \\, dx\n$$\n这是基本基础：CTFT 是通过与复指数核 $e^{-i \\omega x}$ 的积分来定义的，这是一个经过充分检验并被广泛接受的定义。\n\n为了实现一个有原则且与此定义一致的计算流程，我们采用黎曼和近似。设定义域在一个均匀网格 $x_n = n \\Delta x$ 上采样，$n \\in \\{0,1,\\ldots,N-1\\}$，其中 $\\Delta x = 1/N$。对于一组离散角频率 $\\omega_k = \\frac{2\\pi k}{T}$（其中 $T = 1$ 且 $k \\in \\{-\\lfloor N/2 \\rfloor, \\ldots, \\lfloor N/2 \\rfloor - 1\\}$），CTFT 的一个黎曼和近似由下式给出\n$$\n\\hat{F}(\\omega_k) \\approx \\Delta x \\sum_{n=0}^{N-1} f(x_n) e^{-i \\omega_k x_n}.\n$$\n当用 $\\Delta x$ 缩放时，这个求和在频率 $\\omega_k$ 处恰好是采样序列 $f(x_n)$ 的离散傅里叶变换（DFT），因为对于 $T=1$ 和 $x_n = n/N$，指数项 $e^{-i \\omega_k x_n}$ 变为 $e^{-i 2\\pi k n / N}$。因此，我们可以通过 DFT（通过快速傅里叶变换进行快速实现）乘以 $\\Delta x$ 来计算 $\\hat{F}(\\omega_k)$。\n\n谱泄漏通过测量谱估计 $\\hat{F}(\\omega)$ 中的能量如何扩散到选定频带之外来诊断。虽然对于具有跳跃的分段常数函数（已知其高频成分以 $1/\\omega$ 的形式衰减）来说，完美的带限是罕见的，但可以通过尾部能量定义一个一致的定量度量。对于任何近似 $\\hat{F}$，定义泄漏分数为\n$$\n\\lambda = \\frac{\\sum_{k : |\\omega_k| > \\omega_{\\text{tail}}} |\\hat{F}(\\omega_k)|^2}{\\sum_{k} |\\hat{F}(\\omega_k)|^2},\n$$\n其中 $\\omega_{\\text{tail}}$ 是一个固定的角频率阈值，所有求和都在离散频率网格上进行。分子和分母共享任何统一的频率仓宽度因子，因此该分数在此类缩放下是不变的。该度量量化了高频尾部中的能量比例。\n\n在基于 DFT 的近似中，边界不连续性是谱泄漏的一个已知来源：当端点值不同时，采样函数的隐式周期性延拓会在 $x=0$ 和 $x=1$ 处引入跳跃，从而激发高频分量。一种有原则的缓解方法是通过锥削进行边界平滑，这可以在边界处强制实现连续性（对于足够平滑的锥削函数，还可实现可微性）。汉宁（Hann）锥削在离散网格上定义为\n$$\nw(n) = \\tfrac{1}{2} \\left( 1 - \\cos\\left(\\frac{2\\pi n}{N-1}\\right) \\right),\n$$\n该函数满足 $w(0) = 0$ 和 $w(N-1) = 0$，并在中心附近平滑地达到 $1$。将此锥削应用于 $f$ 会得到 $f_{\\text{hann}}(x_n) = f(x_n) w(n)$，其隐式周期性延拓在端点处是连续的，从而减少了泄漏。在频域中，乘以锥削函数对应于原始 CTFT ($F$) 与锥削函数的 CTFT ($W$) 的卷积 $F * W$，这可以平滑尖锐的频谱特征，并以受控的方式将能量从频率网格的端点重新分布。\n\n算法步骤：\n\n1. 构建网格：设置 $N = 4096$ 和 $\\Delta x = 1/N$，网格点为 $x_n = n \\Delta x$。\n2. 对于每个分段定义的测试用例，通过根据 $x_n$ 是否在 $[a,b)$ 中选择每个分段的常数值来采样 $f(x_n)$，最后一个分段定义为 $[a,b]$ 以包含 $x=1$。\n3. 定义两个窗函数：矩形窗 $w_{\\text{rect}}(n) = 1$ 和如上所述的汉宁窗 $w_{\\text{hann}}(n)$。\n4. 为每个案例形成两个序列：$f_{\\text{rect}}(x_n) = f(x_n) w_{\\text{rect}}(n)$ 和 $f_{\\text{hann}}(x_n) = f(x_n) w_{\\text{hann}}(n)$。\n5. 计算它们的 DFT $\\mathcal{F}_{\\text{rect}}[k]$ 和 $\\mathcal{F}_{\\text{hann}}[k]$，并乘以 $\\Delta x$ 以获得 CTFT 近似 $\\hat{F}_{\\text{rect}}(\\omega_k)$ 和 $\\hat{F}_{\\text{hann}}(\\omega_k)$；离散角频率为 $\\omega_k = \\frac{2\\pi k}{T}$，其中 $T=1$ 且 $k$ 由 DFT 频率布局确定。\n6. 通过对 $|\\hat{F}(\\omega_k)|^2$ 在 $\\omega_{\\text{tail}} = 200\\pi$ 之外求和，并除以所有 $k$ 上的总能量和，来计算泄漏分数 $\\lambda_{\\text{rect}}$ 和 $\\lambda_{\\text{hann}}$。\n7. 计算每个案例的泄漏减少比率 $r = \\lambda_{\\text{rect}} / \\lambda_{\\text{hann}}$；$r > 1$ 表示边界平滑减少了谱泄漏。\n\n测试套件案例为：\n- 案例 1：$f(x) = 2$ 在 $[0,0.4)$ 上，$f(x) = -1$ 在 $[0.4,0.7)$ 上，$f(x) = 0$ 在 $[0.7,1]$ 上；这在 $x=0$ 到 $x=1$ 处有边界不连续性。\n- 案例 2：$f(x) = 0$ 在 $[0,0.3)$ 上，$f(x) = 3$ 在 $[0.3,0.6)$ 上，$f(x) = 0$ 在 $[0.6,1]$ 上；这在端点处是连续的。\n- 案例 3：$f(x) = 0$ 在 $[0,0.49)$ 上，$f(x) = 5$ 在 $[0.49,0.51)$ 上，$f(x) = 0$ 在 $[0.51,1]$ 上；这有窄的内部跳跃但端点为零。\n\n解释：\n- 在案例 1 中，端点不连续性预计会对泄漏产生强烈影响；汉宁锥削应显著减少 $\\lambda$，从而得到 $r \\gg 1$。\n- 在案例 2 中，端点是连续的；泄漏主要来自内部跳跃；汉宁锥削对泄漏的减少程度较低，因此 $r$ 可能比案例 1 更接近于 $1$。\n- 在案例 3 中，窄脉冲主要由于内部跳跃而产生宽广的频率内容；边界平滑主要解决端点问题，因此 $r$ 可能显示适度的改善。\n\n最后，程序必须在单行上打印泄漏减少比率 $[r_1,r_2,r_3]$，每个比率四舍五入到 $6$ 位小数，并且在整个过程中角度均以弧度处理，$\\omega_{\\text{tail}} = 200\\pi$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef hann_window(N: int) -> np.ndarray:\n    \"\"\"Generate a Hann window of length N that is zero at endpoints.\"\"\"\n    n = np.arange(N, dtype=float)\n    return 0.5 * (1.0 - np.cos(2.0 * np.pi * n / (N - 1)))\n\ndef sample_piecewise_function(N: int, segments: list) -> np.ndarray:\n    \"\"\"\n    Sample a piecewise-constant function on [0,1] with N samples.\n    segments: list of tuples (a, b, value), with [a,b) except last is [a,b].\n    Assumes segments cover [0,1] without gaps and with non-overlapping intervals.\n    \"\"\"\n    x = np.linspace(0.0, 1.0, N, endpoint=False)  # x_n = n/N, n=0..N-1\n    f = np.zeros_like(x)\n    for i, (a, b, val) in enumerate(segments):\n        if i  len(segments) - 1:\n            mask = (x >= a)  (x  b)\n        else:\n            # last segment includes the endpoint 1, but our grid excludes 1 (endpoint=False),\n            # so this mask is equivalent to [a,b) here.\n            mask = (x >= a)  (x  b)\n        f[mask] = val\n    return f\n\ndef ctft_approx_via_fft(samples: np.ndarray, T: float) - tuple:\n    \"\"\"\n    Approximate CTFT using FFT of samples scaled by Delta x.\n    Returns (omega, F_hat), where omega are angular frequencies in radians per unit x.\n    \"\"\"\n    N = samples.size\n    dx = T / N\n    # FFT and frequencies:\n    F = np.fft.fft(samples) * dx\n    # Frequencies in cycles per unit x, convert to angular frequency by 2*pi:\n    freqs = np.fft.fftfreq(N, d=dx)  # cycles per unit\n    omega = 2.0 * np.pi * freqs      # radians per unit\n    return omega, F\n\ndef leakage_fraction(omega: np.ndarray, F_hat: np.ndarray, omega_tail: float) - float:\n    \"\"\"\n    Compute leakage fraction: energy beyond |omega| > omega_tail divided by total energy.\n    \"\"\"\n    power = np.abs(F_hat)**2\n    mask_tail = np.abs(omega) > omega_tail\n    tail_energy = power[mask_tail].sum()\n    total_energy = power.sum()\n    # Handle potential numerical edge case:\n    if total_energy == 0.0:\n        return 0.0\n    return float(tail_energy / total_energy)\n\ndef solve():\n    # Parameters\n    T = 1.0\n    N = 4096\n    omega_tail = 200.0 * np.pi  # radians per unit x\n\n    # Define test cases: list of segments (a, b, value)\n    test_cases = [\n        # Case 1: boundary discontinuity present\n        [(0.0, 0.4, 2.0), (0.4, 0.7, -1.0), (0.7, 1.0, 0.0)],\n        # Case 2: boundary continuity at endpoints (zeros at ends)\n        [(0.0, 0.3, 0.0), (0.3, 0.6, 3.0), (0.6, 1.0, 0.0)],\n        # Case 3: narrow interior jump, endpoints are zero\n        [(0.0, 0.49, 0.0), (0.49, 0.51, 5.0), (0.51, 1.0, 0.0)],\n    ]\n\n    # Windows\n    rect = np.ones(N, dtype=float)\n    hann = hann_window(N)\n\n    results = []\n    for segments in test_cases:\n        # Sample f\n        f = sample_piecewise_function(N, segments)\n\n        # Unsmooth: rectangular window\n        f_rect = f * rect\n        omega_rect, F_rect = ctft_approx_via_fft(f_rect, T)\n        lambda_rect = leakage_fraction(omega_rect, F_rect, omega_tail)\n\n        # Smooth: Hann window\n        f_hann = f * hann\n        omega_hann, F_hann = ctft_approx_via_fft(f_hann, T)\n        lambda_hann = leakage_fraction(omega_hann, F_hann, omega_tail)\n\n        # Leakage reduction ratio\n        if lambda_hann == 0.0:\n            ratio = float('inf') if lambda_rect > 0.0 else 1.0\n        else:\n            ratio = lambda_rect / lambda_hann\n        results.append(ratio)\n\n    # Round to 6 decimal places and format output\n    formatted = [f\"{r:.6f}\" if np.isfinite(r) else \"inf\" for r in results]\n    print(f\"[{','.join(formatted)}]\")\n\nsolve()\n```", "id": "3112450"}, {"introduction": "在理想化的模型中，我们假设采样是完美均匀的，但在现实世界中，传感器的位置或采样时间总会存在微小的随机误差，即“抖动”（jitter）。这个进阶练习将理论推导与数值模拟相结合，让你深入探究这种采样位置的微小扰动如何传播并影响最终计算出的频谱。理解采样抖动对频率的依赖性，对于设计高精度的信号采集与分析系统至关重要。[@problem_id:3112380]", "problem": "要求您通过严谨的理论推导和数值计算，研究在数值近似连续傅里叶变换时，空间采样位置的微小随机扰动（抖动）如何传播到频域中。请在无物理单位的纯数学环境中进行全部工作。角度以弧度为单位。\n\n从函数 $f:\\mathbb{R}\\to\\mathbb{C}$ 的连续傅里叶变换的基本定义出发，\n$$\nF(\\omega)=\\int_{-\\infty}^{\\infty} f(x)\\,e^{-i\\,\\omega\\,x}\\,dx,\n$$\n以及使用 Riemann 型求积在有限区间上进行数值计算需要选择一个有限定义域和 $x$ 中的采样点网格这一事实出发。\n\n您将比较在同一有限区间 $[-L,L]$ 上构建的两种 $F(\\omega)$ 的数值近似：\n\n- 基准近似：构建于均匀网格 $x_n=-L+n\\,\\Delta x$（其中 $n\\in\\{0,1,\\dots,N-1\\}$，$\\Delta x=\\dfrac{2L}{N-1}$），并采用梯形法则的权重。\n\n- 抖动近似：构建于受扰动的采样位置 $\\tilde{x}_n=x_n+\\varepsilon_n$（其中每个 $\\varepsilon_n$ 是均值为 $0$、标准差为 $s\\,\\Delta x$ 的独立高斯随机变量），并采用适用于非均匀网格的梯形法则，使用相应的不均匀间距。\n\n您必须：\n\n- 从 $F(\\omega)$ 的定义和一阶泰勒展开出发，推导采样位置的微小扰动 $\\delta x$ 如何改变被积函数，进而改变计算出的变换结果。表达误差对 $\\omega$ 和 $f$ 的导数的主阶依赖关系。\n\n- 实现一个程序，用以量化特定测试函数 $f(x)=\\exp\\!\\left(-\\dfrac{x^2}{2\\,\\sigma^2}\\right)$ 在有限区间上的影响。在基准和抖动两种情况下使用相同的求积法则，以确保您的度量标准只反映抖动的影响。\n\n- 对于给定的在区间 $[-\\omega_{\\max},\\omega_{\\max}]$ 内均匀分布的频率集合 $\\{\\omega_m\\}_{m=1}^M$，计算基准近似 $F_{\\mathrm{uni}}(\\omega_m)$ 和抖动近似 $F_{\\mathrm{jit}}(\\omega_m)$。然后为每组参数计算一个单一的标量误差度量：\n$$\nE=\\frac{\\left(\\frac{1}{M}\\sum_{m=1}^M \\left|F_{\\mathrm{jit}}(\\omega_m)-F_{\\mathrm{uni}}(\\omega_m)\\right|^2\\right)^{1/2}}{\\left(\\frac{1}{M}\\sum_{m=1}^M \\left|F_{\\mathrm{uni}}(\\omega_m)\\right|^2\\right)^{1/2}}.\n$$\n这个 $E$ 是在所选频率网格上的相对均方根差异，它直接量化了 $x$ 中的采样扰动如何传播到 $\\omega$ 域。\n\n计算要求与约定：\n\n- 在所选网格上使用梯形法则对积分进行数值近似。在均匀网格上，内部点的权重为 $\\Delta x$，端点的权重为 $\\dfrac{\\Delta x}{2}$。在非均匀网格上，首先将受扰动的采样位置按升序排序以恢复有序网格，然后使用局部非均匀间距分配梯形权重。具体来说，对于排序后的节点 $\\{\\tilde{x}_k\\}_{k=0}^{N-1}$ 和间距 $\\Delta \\tilde{x}_k=\\tilde{x}_{k+1}-\\tilde{x}_k$，使用权重 $w_0=\\dfrac{1}{2}\\Delta \\tilde{x}_0$，$w_{N-1}=\\dfrac{1}{2}\\Delta \\tilde{x}_{N-2}$，对于内部索引 $k\\in\\{1,\\dots,N-2\\}$，$w_k=\\dfrac{1}{2}\\left(\\Delta \\tilde{x}_{k-1}+\\Delta \\tilde{x}_k\\right)$。\n\n- 在两个网格上，都通过对网格点 $k$ 求和 $w_k\\,f(x_k)\\,e^{-i\\,\\omega\\,x_k}$ 来近似积分。\n\n- 随机抖动应建模为均值为 $0$、标准差为 $s\\,\\Delta x$ 的独立高斯变量。必须通过为每个测试用例使用固定的伪随机数生成器种子来确保可复现性。\n\n测试套件：\n\n您的程序必须运行以下四组参数集，并以单个列表的形式输出相应的四个误差值 $E$。\n\n每个参数集是一个元组 $(\\sigma,L,N,s,\\omega_{\\max},M,\\text{seed})$：\n\n- 测试 1：$(\\sigma,L,N,s,\\omega_{\\max},M,\\text{seed}) = (0.6, 3.0, 2048, 0.0, 30.0, 301, 13)$.\n\n- 测试 2：$(\\sigma,L,N,s,\\omega_{\\max},M,\\text{seed}) = (0.6, 3.0, 2048, 0.02, 30.0, 301, 13)$.\n\n- 测试 3：$(\\sigma,L,N,s,\\omega_{\\max},M,\\text{seed}) = (0.6, 3.0, 2048, 0.1, 30.0, 301, 13)$.\n\n- 测试 4：$(\\sigma,L,N,s,\\omega_{\\max},M,\\text{seed}) = (0.6, 3.0, 2048, 0.3, 30.0, 301, 13)$.\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个数字使用标准舍入规则四舍五入到恰好六位小数，并按测试 1 到 4 的顺序排列。例如，一个包含四个结果的输出应类似于“[0.000001,0.012345,0.067890,0.123456]”。", "solution": "该问题是有效的。这是一个适定的、有科学依据的计算科学练习，要求基于明确陈述的数学定义和算法进行理论推导和数值实现。所有必要的参数都已提供，以获得唯一且可验证的解。\n\n### 第 1 部分：理论推导\n\n该问题要求推导空间采样位置的微小随机扰动（抖动）在计算傅里叶变换时如何传播到频域。我们从被数值积分的量开始，即函数 $f(x)$ 与复指数核的乘积。设此复合函数为 $g(x, \\omega) = f(x) e^{-i\\omega x}$。傅里叶变换为 $F(\\omega) = \\int_{-\\infty}^{\\infty} g(x, \\omega) dx$。\n\n数值求积将此积分近似为离散采样点集 $\\{x_n\\}$ 上的加权和：\n$$\nF_{\\text{approx}}(\\omega) = \\sum_n w_n g(x_n, \\omega)\n$$\n其中 $w_n$ 是求积权重。\n\n现在，考虑单个采样点 $x_n$ 受到微小量 $\\varepsilon_n$ 的扰动，使得新位置为 $\\tilde{x}_n = x_n + \\varepsilon_n$。该点被积函数的值可以通过在 $x_n$ 附近对 $g(x, \\omega)$ 进行一阶泰勒级数展开来近似：\n$$\ng(\\tilde{x}_n, \\omega) = g(x_n + \\varepsilon_n, \\omega) \\approx g(x_n, \\omega) + \\left. \\frac{\\partial g(x, \\omega)}{\\partial x} \\right|_{x=x_n} \\varepsilon_n\n$$\n因此，该点被积函数值的误差 $\\Delta g_n = g(\\tilde{x}_n, \\omega) - g(x_n, \\omega)$ 近似为：\n$$\n\\Delta g_n \\approx \\left. \\frac{\\partial g(x, \\omega)}{\\partial x} \\right|_{x=x_n} \\varepsilon_n\n$$\n我们计算 $g(x, \\omega)$ 关于 $x$ 的导数：\n$$\n\\frac{\\partial g(x, \\omega)}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( f(x) e^{-i\\omega x} \\right) = \\frac{df(x)}{dx} e^{-i\\omega x} + f(x) \\left( -i\\omega e^{-i\\omega x} \\right) = \\left( f'(x) - i\\omega f(x) \\right) e^{-i\\omega x}\n$$\n其中 $f'(x)$ 是 $f(x)$ 的导数。\n\n将其代回，点 $x_n$ 处被积函数的误差近似为：\n$$\n\\Delta g_n \\approx \\left( f'(x_n) - i\\omega f(x_n) \\right) e^{-i\\omega x_n} \\varepsilon_n\n$$\n此表达式揭示了局部误差对函数属性和变换参数的主阶依赖关系：\n1.  **对函数及其导数的依赖性**：误差与函数值 $f(x_n)$ 及其一阶导数 $f'(x_n)$ 的线性组合成正比。函数或其斜率的量级较大的区域将对总误差贡献更大。\n2.  **对频率 $\\omega$ 的依赖性**：误差包含两个部分。与 $f'(x_n)$ 成正比的项源于函数振幅的变化，$f(x_n+\\varepsilon_n) - f(x_n)$。此项的量级与 $\\omega$ 无关。与 $-i\\omega f(x_n)$ 成正比的项源于傅里叶核相位的变化，$e^{-i\\omega(x_n+\\varepsilon_n)} - e^{-i\\omega x_n}$。此项的量级随 $\\omega$ 线性增长。\n\n计算出的傅里叶变换的总误差 $\\Delta F(\\omega) = F_{\\mathrm{jit}}(\\omega) - F_{\\mathrm{uni}}(\\omega)$ 是这些局部误差的复数和，同时也要考虑求积权重的扰动。然而，分析单个点的贡献足以建立主要依赖关系。与 $\\omega$ 成正比的项表明，由采样抖动引起的误差预计在较高频率下更为显著。这是因为微小的空间位移 $\\varepsilon_n$ 会在傅里叶核中引起 $-\\omega \\varepsilon_n$ 的相移，并且随着 $|\\omega|$ 的增加，该相移会变大。\n\n误差的期望平方量级将有一个与 $\\omega^2$ 成正比的项：\n$$\n|\\Delta g_n|^2 \\approx \\left| f'(x_n) - i\\omega f(x_n) \\right|^2 |\\varepsilon_n|^2 = \\left( (f'(x_n))^2 + \\omega^2 (f(x_n))^2 \\right) |\\varepsilon_n|^2\n$$\n这证实了误差功率谱预计会随频率呈二次方增长，突显了高频分量对采样抖动的敏感性。\n\n### 第 2 部分：数值实现\n\n所提供的 Python 代码实现了上述数值实验。\n首先，定义了一个函数 `solve` 来管理测试用例。它遍历每个参数集，设置所需的空间和频率网格。\n\n对于每种情况，计算两种傅里叶变换：\n1.  **`F_uni`（基准）**：这是在完全均匀的网格 `x_uni` 上使用梯形法则和均匀权重计算的。\n2.  **`F_jit`（抖动）**：从均值为 $0$、标准差为 $s \\cdot \\Delta x$ 的高斯分布生成一个随机抖动数组 `eps`。将此抖动添加到均匀网格上以创建 `x_jit`。对于 $s=0$ 的特殊情况，确保不添加抖动，并为提高效率而短路计算，因为结果必须与均匀情况相同。对于 $s0$，首先对受扰动的网格点 `x_jit`进行排序，以恢复单调递增序列，这是非均匀网格梯形法则定义所要求的。函数 `f(x)` 在这些新的排序后位置上进行求值。然后根据排序后点之间的非均匀间距，按照问题陈述中给出的精确公式计算梯形权重。\n\n`F_uni` 和 `F_jit` 都是通过计算复指数核（在频率和空间点的所有组合上求值）的矩阵与相应加权函数值向量的矩阵乘积得到的。这种向量化的方法是高效的。\n\n最后，按照规定计算相对均方根误差度量 $E$。它通过基准均匀变换的均方根量级来归一化两种变换之间的均方根差异。收集所有测试用例的结果，格式化为六位小数，并以所需的列表格式打印。测试用例 1 中 $s=0$ 时正确地得出误差为 $0$，这是一个成功的合理性检查。后续测试中 $E$ 值的增加表明，傅里叶变换近似的质量随着抖动幅度的增加而下降，正如理论所预测的那样。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the effect of sampling jitter on the numerical Fourier transform\n    for a series of test cases and prints the results.\n    \"\"\"\n\n    def f_gaussian(x, sigma):\n        \"\"\"\n        Computes the Gaussian function f(x) = exp(-x^2 / (2*sigma^2)).\n        \"\"\"\n        return np.exp(-x**2 / (2 * sigma**2))\n\n    def compute_ft(x_nodes, f_vals, weights, omega_grid):\n        \"\"\"\n        Computes the Fourier transform using a generic quadrature sum.\n        \"\"\"\n        # Base of the integrand for the sum: w_k * f(x_k)\n        integrand_base = f_vals * weights\n        \n        # Matrix of complex exponentials: exp(-i * omega_m * x_k)\n        # Shape: (M, N)\n        exp_matrix = np.exp(-1j * np.outer(omega_grid, x_nodes))\n        \n        # The sum is a matrix-vector product.\n        # Result shape: (M,)\n        ft_vals = exp_matrix @ integrand_base\n        return ft_vals\n\n    # Test cases as defined in the problem statement.\n    test_cases = [\n        # (sigma, L, N, s, omega_max, M, seed)\n        (0.6, 3.0, 2048, 0.0, 30.0, 301, 13),\n        (0.6, 3.0, 2048, 0.02, 30.0, 301, 13),\n        (0.6, 3.0, 2048, 0.1, 30.0, 301, 13),\n        (0.6, 3.0, 2048, 0.3, 30.0, 301, 13),\n    ]\n\n    results = []\n    for case in test_cases:\n        sigma, L, N, s, omega_max, M, seed = case\n\n        # Define the spatial and frequency grids.\n        x_uni = np.linspace(-L, L, N)\n        dx = (2 * L) / (N - 1)\n        omega_grid = np.linspace(-omega_max, omega_max, M)\n        \n        # Define the specific function for this test.\n        f = lambda x: f_gaussian(x, sigma)\n\n        # --- Baseline (Uniform Grid) Calculation ---\n        f_uni_vals = f(x_uni)\n        \n        # Trapezoidal weights for the uniform grid.\n        weights_uni = np.full(N, dx)\n        weights_uni[0] = dx / 2.0\n        weights_uni[-1] = dx / 2.0\n        \n        F_uni = compute_ft(x_uni, f_uni_vals, weights_uni, omega_grid)\n\n        # --- Jittered Grid Calculation ---\n        if s == 0.0:\n            # If there is no jitter, the result is identical to the uniform case.\n            F_jit = F_uni\n        else:\n            # Generate jitter.\n            rng = np.random.default_rng(seed)\n            jitter_std = s * dx\n            eps = rng.normal(loc=0.0, scale=jitter_std, size=N)\n            x_jit_unsorted = x_uni + eps\n            \n            # Sort the jittered grid points to apply the trapezoidal rule.\n            x_jit_sorted = np.sort(x_jit_unsorted)\n            \n            # Evaluate the function on the sorted jittered grid.\n            f_jit_vals = f(x_jit_sorted)\n\n            # Trapezoidal weights for the non-uniform (sorted jittered) grid.\n            dx_jit = np.diff(x_jit_sorted)\n            weights_jit = np.zeros(N)\n            weights_jit[0] = dx_jit[0] / 2.0\n            weights_jit[-1] = dx_jit[-2] / 2.0\n            weights_jit[1:-1] = (dx_jit[:-1] + dx_jit[1:]) / 2.0\n            \n            F_jit = compute_ft(x_jit_sorted, f_jit_vals, weights_jit, omega_grid)\n\n        # --- Compute the Error Metric E ---\n        # Numerator: RMS of the difference |F_jit - F_uni|.\n        num_rms = np.sqrt(np.mean(np.abs(F_jit - F_uni)**2))\n        \n        # Denominator: RMS of the baseline signal |F_uni|.\n        den_rms = np.sqrt(np.mean(np.abs(F_uni)**2))\n        \n        # The metric E is the ratio. Handle division by zero.\n        if den_rms == 0.0:\n            E = np.inf if num_rms > 0 else 0.0\n        else:\n            E = num_rms / den_rms\n            \n        results.append(E)\n\n    # Format results for the final output.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3112380"}]}