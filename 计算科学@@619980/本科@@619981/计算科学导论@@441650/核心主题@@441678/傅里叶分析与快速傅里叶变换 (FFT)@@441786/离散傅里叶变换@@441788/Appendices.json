{"hands_on_practices": [{"introduction": "探索离散傅里叶变换 (DFT) 的第一步是理解它如何处理其最基本的构件：纯粹的频率分量。本练习将引导你直接应用 DFT 的定义到一个复指数信号上，该信号本身就是变换的基函数之一 [@problem_id:1759639]。掌握这个计算过程能揭示 DFT 的“筛选”特性，并为你理解它如何分离复杂信号中的频率成分建立直观感觉。", "problem": "在数字信号处理中，离散傅里叶变换（DFT）是分析有限长度信号频谱分量的基本工具。考虑一个纯音信号采样后的简化模型。该信号记为 $x[n]$，由单个复指数表示。\n\n该信号是一个长度为 $N$ 的序列，定义为：\n$$x[n] = \\exp\\left(j \\frac{2\\pi k_0 n}{N}\\right)$$\n对于时间索引 $n = 0, 1, \\ldots, N-1$。这里，$k_0$ 是一个整数常数，表示该纯音的归一化频率，并且满足 $0 \\le k_0  N$。\n\n你的任务是计算该信号的 $N$ 点 DFT。DFT 记为 $X[k]$，由以下分析方程定义：\n$$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j \\frac{2\\pi kn}{N}\\right)$$\n其中 $k$ 是频率索引，取整数值 $k = 0, 1, \\ldots, N-1$。\n\n找出 $X[k]$ 关于 $N$、$k$ 和 $k_0$ 的单一闭式解析表达式。", "solution": "我们从 DFT 分析方程开始，并代入给定的信号。根据定义，\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j \\frac{2\\pi kn}{N}\\right).\n$$\n将 $x[n] = \\exp\\left(j \\frac{2\\pi k_{0} n}{N}\\right)$ 代入，可得\n$$\nX[k] = \\sum_{n=0}^{N-1} \\exp\\left(j \\frac{2\\pi k_{0} n}{N}\\right)\\exp\\left(-j \\frac{2\\pi k n}{N}\\right) \n= \\sum_{n=0}^{N-1} \\exp\\left(j \\frac{2\\pi (k_{0}-k) n}{N}\\right).\n$$\n定义比值\n$$\nr \\triangleq \\exp\\left(j \\frac{2\\pi (k_{0}-k)}{N}\\right).\n$$\n那么\n$$\nX[k] = \\sum_{n=0}^{N-1} r^{n}.\n$$\n这是一个有限几何级数。使用几何级数求和公式，\n$$\n\\sum_{n=0}^{N-1} r^{n} = \n\\begin{cases}\n\\frac{1 - r^{N}}{1 - r},  r \\neq 1, \\\\\nN,  r = 1,\n\\end{cases}\n$$\n并注意到\n$$\nr^{N} = \\exp\\left(j \\frac{2\\pi (k_{0}-k) N}{N}\\right) = \\exp\\left(j 2\\pi (k_{0}-k)\\right) = 1,\n$$\n我们有：\n- 如果 $r \\neq 1$ （对于 $k,k_{0}\\in\\{0,\\ldots,N-1\\}$，等价于 $k \\neq k_{0}$），那么 $1 - r^{N} = 0$ 而 $1 - r \\neq 0$，所以 $X[k] = 0$。\n- 如果 $r = 1$ （等价于 $k = k_{0}$），那么和式中的每一项都等于 $1$，所以 $X[k] = N$。\n\n综合这两种情况，得到闭式表达式\n$$\nX[k] = N\\,\\delta_{k,k_{0}},\n$$\n其中 $\\delta_{k,k_{0}}$ 是克罗内克δ函数，当 $k=k_{0}$ 时等于 $1$，否则等于 $0$。", "answer": "$$\\boxed{N\\,\\delta_{k,k_{0}}}$$", "id": "1759639"}, {"introduction": "从抽象理论到计算实践的跨越是科学计算的核心。本练习要求你推导并用数值方法验证帕塞瓦尔定理 (Parseval's theorem)，这是一个基石性的属性，它表明 DFT 在信号的时域和频域之间保持能量守恒 [@problem_id:3222975]。通过实现这一验证，你不仅能获得处理数值计算实际问题的实践经验，还能对这一基本原理建立更深刻的理解和信任。", "problem": "要求您设计并实现一个程序，用以在离散傅里叶变换（DFT）下，数值验证离散时间序列域和离散频域之间的能量守恒性质。仅从以下基本基础开始：离散傅里叶变换（DFT）及其在非归一化正变换约定下的逆变换的定义，即\n- 正向 DFT：对于长度为 $N$ 的序列 $x[n]$，其变换 $X[k]$ 定义为 $X[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-j 2\\pi kn/N}$，其中 $k \\in \\{0,1,\\dots,N-1\\}$。\n- 逆向 DFT：$x[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\, e^{j 2\\pi kn/N}$，其中 $n \\in \\{0,1,\\dots,N-1\\}$。\n\n您的任务是：\n1) 从上述基础出发，推导在给定约定下，$x[n]$ 的时域平方 $\\ell_2$ 范数与 $X[k]$ 相应的频域平方 $\\ell_2$ 范数之间的关系。\n2) 设计一个数值实验来验证多个序列的这种关系。对于每个测试序列，计算时域能量 $E_{\\mathrm{time}} = \\sum_{n=0}^{N-1} |x[n]|^2$ 和频域能量 $E_{\\mathrm{freq}} = \\frac{1}{N} \\sum_{k=0}^{N-1} |X[k]|^2$。对于每个测试用例，计算无量纲的相对差异\n$$\nr \\;=\\; \\begin{cases}\n\\displaystyle \\frac{\\big| E_{\\mathrm{time}} - E_{\\mathrm{freq}} \\big|}{\\max\\{E_{\\mathrm{time}}, E_{\\mathrm{freq}}\\}},  \\text{if } \\max\\{E_{\\mathrm{time}}, E_{\\mathrm{freq}}\\}  0,\\\\\n0,  \\text{if } E_{\\mathrm{time}} = E_{\\mathrm{freq}} = 0,\n\\end{cases}\n$$\n\n测试套件。您的程序必须精确评估以下六个序列，每个序列的规格如下。在所有情况下，$n$ 和 $k$ 均为整数索引：\n- 情况 A（随机复数，正常情况）：长度 $N=128$。设 $x[n]$ 为复数值，其实部和虚部独立地从标准正态分布中抽取，使用固定的种子 $12345$ 以保证可复现性。\n- 情况 B（单频点复指数）：长度 $N=64$。设 $x[n] = c \\, e^{j 2\\pi m n / N}$，其中 $m=7$ 且 $c = 1.2 \\, e^{j\\,0.4}$。\n- 情况 C（频谱泄漏实正弦波）：长度 $N=36$。设 $x[n] = A \\sin\\!\\big(2\\pi f n / N + \\varphi\\big)$，其中 $A=1.0$，$f=\\sqrt{2}$，且 $\\varphi=0.3$。\n- 情况 D（冲激）：长度 $N=50$。设 $x[n]$ 在索引 $n_0=17$ 处为 $A$，其他地方为 $0$，其中 $A=3.0$。\n- 情况 E（中心化斜坡）：长度 $N=32$。设 $x[n] = n - \\frac{N-1}{2}$，其中 $n \\in \\{0,1,\\dots,N-1\\}$。\n- 情况 F（全零，边缘情况）：长度 $N=10$。设对所有 $n$，$x[n]=0$。\n\n实现要求：\n- 使用如上所述的非归一化正向 DFT 约定。\n- 使用从第一性原理出发的正确实现或与所述约定一致的库函数来计算 $X[k]$。\n- 对于每种情况，按定义计算 $E_{\\mathrm{time}}$、$E_{\\mathrm{freq}}$ 和相对差异 $r$。\n- 数值精度：浮点运算会引入舍入误差；相对差异 $r$ 应接近于 $0$。除上述定义之外，不得应用任何额外的缩放。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含六个相对差异值，格式为方括号内的逗号分隔列表，顺序为 [情况 A, 情况 B, 情况 C, 情况 D, 情况 E, 情况 F]。例如：\"[rA,rB,rC,rD,rE,rF]\"。\n- 每个 $r$ 必须是浮点数。不涉及单位。", "solution": "该问题要求推导并随后数值验证离散傅里叶变换（DFT）的能量守恒性质，这通常被称为帕塞瓦尔定理（Parseval's theorem）。所使用的特定 DFT 约定是非归一化正变换。\n\n分析分两个阶段进行：首先，根据给定的 DFT 定义，对预期的能量关系进行形式化的数学推导；其次，设计并实现一个数值实验，用一组测试信号来验证这种关系，并用一个相对误差度量来量化任何差异。\n\n**1. 帕塞瓦尔定理的数学推导**\n\n对于长度为 $N$ 的有限离散时间序列 $x[n]$，其中 $n \\in \\{0, 1, \\dots, N-1\\}$，我们有以下定义：\n\n- 正向 DFT: $X[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-j 2\\pi kn/N}$\n- 逆向 DFT: $x[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\, e^{j 2\\pi kn/N}$\n\n目标是建立时域能量（定义为序列 $x[n]$ 的平方 $\\ell_2$ 范数）\n$$E_{\\mathrm{time}} = \\sum_{n=0}^{N-1} |x[n]|^2$$\n与频域能量（定义了特定的缩放因子）之间的关系\n$$E_{\\mathrm{freq}} = \\frac{1}{N} \\sum_{k=0}^{N-1} |X[k]|^2$$\n\n我们从频域能量 $E_{\\mathrm{freq}}$ 的表达式开始推导。\n$$E_{\\mathrm{freq}} = \\frac{1}{N} \\sum_{k=0}^{N-1} |X[k]|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] X^*[k]$$\n其中 $X^*[k]$ 表示 $X[k]$ 的复共轭。\n\n将正向 DFT 的定义代入 $X[k]$，将其共轭代入 $X^*[k]$。为清晰起见，我们在共轭项中使用一个不同的求和索引 $m$。\n$$X[k] = \\sum_{n=0}^{N-1} x[n] e^{-j 2\\pi kn/N}$$\n$$X^*[k] = \\left( \\sum_{m=0}^{N-1} x[m] e^{-j 2\\pi km/N} \\right)^* = \\sum_{m=0}^{N-1} x^*[m] e^{j 2\\pi km/N}$$\n\n将这些代入 $E_{\\mathrm{freq}}$ 的表达式中，得到：\n$$E_{\\mathrm{freq}} = \\frac{1}{N} \\sum_{k=0}^{N-1} \\left( \\sum_{n=0}^{N-1} x[n] e^{-j 2\\pi kn/N} \\right) \\left( \\sum_{m=0}^{N-1} x^*[m] e^{j 2\\pi km/N} \\right)$$\n\n由于是有限和，我们可以重新排列求和的顺序：\n$$E_{\\mathrm{freq}} = \\frac{1}{N} \\sum_{n=0}^{N-1} \\sum_{m=0}^{N-1} x[n] x^*[m] \\left( \\sum_{k=0}^{N-1} e^{-j 2\\pi kn/N} e^{j 2\\pi km/N} \\right)$$\n$$E_{\\mathrm{freq}} = \\frac{1}{N} \\sum_{n=0}^{N-1} \\sum_{m=0}^{N-1} x[n] x^*[m] \\left( \\sum_{k=0}^{N-1} e^{j 2\\pi k(m-n)/N} \\right)$$\n\n最内层的关于索引 $k$ 的和是复指数的几何级数。它表现出一种基本的正交性：\n$$ \\sum_{k=0}^{N-1} e^{j 2\\pi k(m-n)/N} = \\begin{cases} N  \\text{if } m = n \\\\ 0  \\text{if } m \\neq n \\end{cases} $$\n这可以用克罗内克（Kronecker）$\\delta$ 函数 $\\delta_{m,n}$ 简写为 $N \\delta_{m,n}$。\n\n将此结果代回我们的 $E_{\\mathrm{freq}}$ 表达式：\n$$E_{\\mathrm{freq}} = \\frac{1}{N} \\sum_{n=0}^{N-1} \\sum_{m=0}^{N-1} x[n] x^*[m] (N \\delta_{m,n})$$\n\n$N$ 因子被消去。克罗内克（Kronecker）$\\delta$ 函数 $\\delta_{m,n}$ 使得关于 $m$ 的内层求和仅在 $m=n$ 时非零。这将双重求和简化为单一求和：\n$$E_{\\mathrm{freq}} = \\sum_{n=0}^{N-1} x[n] x^*[n]$$\n\n因为对于任意复数 $z$，$z z^* = |z|^2$，我们得到最终结果：\n$$E_{\\mathrm{freq}} = \\sum_{n=0}^{N-1} |x[n]|^2$$\n\n这证明了，对于给定的 DFT 约定，定义的时域能量和频域能量是相同的：\n$$E_{\\mathrm{time}} = E_{\\mathrm{freq}}$$\n\n**2. 数值验证设计**\n\n任务的第二部分是数值验证这个恒等式。由于浮点运算的精度有限，直接进行相等性检查 $E_{\\mathrm{time}} == E_{\\mathrm{freq}}$ 是不明智的。相反，我们计算无量纲的相对差异 $r$，定义为：\n$$\nr \\;=\\; \\begin{cases}\n\\displaystyle \\frac{\\big| E_{\\mathrm{time}} - E_{\\mathrm{freq}} \\big|}{\\max\\{E_{\\mathrm{time}}, E_{\\mathrm{freq}}\\}},  \\text{if } \\max\\{E_{\\mathrm{time}}, E_{\\mathrm{freq}}\\}  0,\\\\\n0,  \\text{if } E_{\\mathrm{time}} = E_{\\mathrm{freq}} = 0,\n\\end{cases}\n$$\n理论上，$r$ 应该精确为 $0$。在实践中，我们预期 $r$ 是一个与机器精度（machine epsilon）数量级相当的小数，反映了浮点舍入误差的累积。\n\n数值实现将使用 Python 及其 NumPy 库。函数 `numpy.fft.fft` 根据定义 $X[k] = \\sum_{n=0}^{N-1} x[n] e^{-j 2\\pi kn/N}$ 计算正向 DFT，这与问题中指定的非归一化约定完全匹配。\n\n验证将在六个不同的测试用例上进行，每个用例都旨在探测 DFT 的不同方面：\n- **情况 A**：长度为 $N=128$ 的随机复数序列，代表一个通用的、非周期性信号。其实部和虚部从标准正态分布中抽取，并使用固定种子以保证可复现性。\n- **情况 B**：长度为 $N=64$ 的单频复指数信号，$x[n] = 1.2 e^{j0.4} \\, e^{j 2\\pi (7) n / 64}$。其 DFT 仅在单个频率点上非零，代表一个频谱纯净的信号。\n- **情况 C**：长度为 $N=36$ 的实值正弦波，其频率 $f=\\sqrt{2}$ 不是频率分辨率 $1/N$ 的整数倍。这测试了频谱泄漏的情况，即能量分布在所有频率点上。\n- **情况 D**：长度为 $N=50$ 的离散冲激信号，$x[n]$ 在 $n=17$ 时为 $3.0$，其他情况下为 $0$。其变换在所有频率上具有恒定的幅度。\n- **情况 E**：长度为 $N=32$ 的实值线性斜坡序列，经过中心化处理以使均值为零。\n- **情况 F**：长度为 $N=10$ 的全零序列的平凡情况，其时域和频域能量在解析上均为零。\n\n对于每种情况，程序将生成序列 $x[n]$，通过 `numpy.fft.fft` 计算 $X[k]$，然后计算 $E_{\\mathrm{time}}$、$E_{\\mathrm{freq}}$ 和相对差异 $r$。最终输出将是所有测试用例计算出的 $r$ 值的集合。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and numerically verifies Parseval's theorem for the DFT.\n    \"\"\"\n    \n    def calculate_discrepancy(x: np.ndarray) - float:\n        \"\"\"\n        Computes the relative discrepancy between time and frequency domain energies.\n\n        Args:\n            x: A 1D numpy array representing the time-domain sequence x[n].\n\n        Returns:\n            The dimensionless relative discrepancy r.\n        \"\"\"\n        N = len(x)\n        if N == 0:\n            return 0.0\n\n        # Compute time-domain energy: E_time = sum(|x[n]|^2)\n        # Using np.vdot is numerically robust and efficient for sum of squares of a complex vector.\n        E_time = np.vdot(x, x).real\n\n        # Compute frequency-domain signal X[k] using the unnormalized forward DFT\n        X = np.fft.fft(x)\n\n        # Compute frequency-domain energy: E_freq = (1/N) * sum(|X[k]|^2)\n        E_freq = (1 / N) * np.vdot(X, X).real\n\n        # Compute the dimensionless relative discrepancy r\n        max_E = max(E_time, E_freq)\n        \n        if max_E  0:\n            r = np.abs(E_time - E_freq) / max_E\n        else:\n            # This case handles E_time = E_freq = 0, e.g., for an all-zero signal.\n            r = 0.0\n            \n        return r\n\n    results = []\n\n    # Case A: Random complex, happy path\n    N_A = 128\n    seed_A = 12345\n    rng = np.random.default_rng(seed_A)\n    real_part_A = rng.standard_normal(N_A)\n    imag_part_A = rng.standard_normal(N_A)\n    x_A = real_part_A + 1j * imag_part_A\n    results.append(calculate_discrepancy(x_A))\n\n    # Case B: Single-bin complex exponential\n    N_B = 64\n    m_B = 7\n    c_B = 1.2 * np.exp(1j * 0.4)\n    n_B = np.arange(N_B)\n    x_B = c_B * np.exp(1j * 2 * np.pi * m_B * n_B / N_B)\n    results.append(calculate_discrepancy(x_B))\n\n    # Case C: Spectral leakage real sinusoid\n    N_C = 36\n    A_C = 1.0\n    f_C = np.sqrt(2)\n    phi_C = 0.3\n    n_C = np.arange(N_C)\n    x_C = A_C * np.sin(2 * np.pi * f_C * n_C / N_C + phi_C)\n    results.append(calculate_discrepancy(x_C))\n\n    # Case D: Impulse\n    N_D = 50\n    A_D = 3.0\n    n0_D = 17\n    x_D = np.zeros(N_D)\n    x_D[n0_D] = A_D\n    results.append(calculate_discrepancy(x_D))\n\n    # Case E: Ramp, centered\n    N_E = 32\n    n_E = np.arange(N_E)\n    x_E = n_E - (N_E - 1) / 2.0\n    results.append(calculate_discrepancy(x_E))\n\n    # Case F: All zeros, edge case\n    N_F = 10\n    x_F = np.zeros(N_F)\n    results.append(calculate_discrepancy(x_F))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3222975"}, {"introduction": "离散傅里叶变换的威力远不止于一维信号，它在图像处理等二维应用中同样强大。本练习将 DFT 扩展到二维图像，并探索一个强大的应用：频域滤波 [@problem_id:3222771]。你将构建一个“理想”的低通滤波器，并观察移除高频信息如何影响一幅带有锐利边缘的图像，从而定量地观察到吉布斯现象 (Gibbs phenomenon)——这是理解信号处理中固有权衡的关键概念。", "problem": "您的任务是设计和评估一个通过离散傅里叶变换 (DFT) 实现的理想二维低通滤波器。从二维离散傅里叶变换 (DFT) 及其逆变换的定义出发，利用空间域和频率域之间的卷积-乘法对偶性，实现一个环形“砖墙”低通滤波器。然后，量化此滤波应用于具有单条锐利边缘的合成图像时所引入的振铃伪影（吉布斯现象）。\n\n基于以下基本原理进行工作：\n- 一个大小为 $N \\times N$ 的数组 $x[n,m]$ 的二维离散傅里叶变换 (DFT) 定义为\n$$\nX[u,v] = \\sum_{n=0}^{N-1}\\sum_{m=0}^{N-1} x[n,m] \\, \\exp\\!\\left(-2\\pi i \\left(\\frac{un}{N} + \\frac{vm}{N}\\right)\\right),\n$$\n其二维逆离散傅里叶变换 (IDFT) 为\n$$\nx[n,m] = \\frac{1}{N^2}\\sum_{u=0}^{N-1}\\sum_{v=0}^{N-1} X[u,v] \\, \\exp\\!\\left(2\\pi i \\left(\\frac{un}{N} + \\frac{vm}{N}\\right)\\right).\n$$\n- 频率域中的乘法对应于空间域中的卷积，这意味着频域空间中的理想低通掩模对应于与一个非紧支撑的空间点扩散函数进行卷积。因此，截断或急剧切断频率内容会在空间域的不连续点附近引入振荡伪影（吉布斯现象）。\n\n实现以下步骤：\n1. 构造一个合成的二值阶跃图像 $I \\in \\mathbb{R}^{N \\times N}$，其在中心列处有一条垂直边缘。具体来说，对于每个行索引 $i \\in \\{0,\\dots,N-1\\}$ 和列索引 $j \\in \\{0,\\dots,N-1\\}$，\n$$\nI[i,j] = \\begin{cases}\n0,  j  \\frac{N}{2},\\\\\n1,  j \\ge \\frac{N}{2}.\n\\end{cases}\n$$\n2. 计算 $I$ 的二维 DFT 以获得 $F$。设计一个环形砖墙低通掩模 $H$，其参数为截止半径 $r_c$。该半径在将零频分量中心化后（即，经过频率平移使零频位于数组中心后），以整数频率单元半径为单位进行度量。该掩模定义为\n$$\nH[u,v] = \\begin{cases}\n1,  \\sqrt{u^2 + v^2} \\le r_c,\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n其中 $u,v \\in \\{-\\frac{N}{2}, -\\frac{N}{2}+1,\\dots,\\frac{N}{2}-1\\}$ 表示由平移产生的中心化频率单元索引。\n3. 通过逐点相乘形成滤波后的频谱 $G = F \\cdot H$，然后计算二维逆 DFT 以获得空间域中的重建图像 $\\widehat{I}$。保留 $\\widehat{I}$ 的实部。\n4. 使用中心行来量化边缘附近的振铃。设 $c_0 = \\frac{N}{2}$ 为中心列索引，$W$ 为一个小的正整数窗口半宽度。定义中心行剖面 $p[j] = \\widehat{I}\\!\\left[\\frac{N}{2}, j\\right]$，其中 $j \\in \\{0,\\dots,N-1\\}$。计算：\n   - 亮侧渐近线上方的峰值过冲，\n   $$\n   \\Delta^+ = \\max\\left(0, \\max_{j \\in \\{c_0,\\dots,\\min(N-1,c_0+W)\\}} \\big(p[j] - 1\\big)\\right).\n   $$\n   - 暗侧渐近线下方的峰值下冲，\n   $$\n   \\Delta^- = \\max\\left(0, \\max_{j \\in \\{\\max(0,c_0-W),\\dots,c_0-1\\}} \\big(0 - p[j]\\big)\\right).\n   $$\n   - 整个图像的均方误差 (MSE)，\n   $$\n   \\mathrm{MSE} = \\frac{1}{N^2} \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\big(\\widehat{I}[i,j] - I[i,j]\\big)^2.\n   $$\n5. 对于每个测试用例，报告三元组 $\\left[\\Delta^+, \\Delta^-, \\mathrm{MSE}\\right]$，每个值四舍五入到 $6$ 位小数。\n\n测试套件：\n- 所有情况均使用 $N = 128$ 和 $W = 32$。针对截止半径（以中心化频率单元为单位）$r_c \\in \\{0, 8, 16, 128\\}$ 评估滤波器。$r_c = 0$ 的情况仅通过零频分量。$r_c = 128$ 的情况足够大，可以通过 $N = 128$ 的所有可用频率单元。\n- 本问题不使用角度。没有物理单位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个测试用例贡献一个包含三个浮点数的列表，顺序为 $\\left[\\Delta^+, \\Delta^-, \\mathrm{MSE}\\right]$，并四舍五入到 $6$ 位小数。例如，对于两个测试用例，一个有效的格式是 $[[0.000000,0.000000,0.250000],[0.012345,0.012345,0.123456]]$。\n- 对于本问题中的四个测试用例，您的程序必须以精确的聚合列表格式输出单行结果：$[\\,[\\Delta^+_1,\\Delta^-_1,\\mathrm{MSE}_1],\\,[\\Delta^+_2,\\Delta^-_2,\\mathrm{MSE}_2],\\,[\\Delta^+_3,\\Delta^-_3,\\mathrm{MSE}_3],\\,[\\Delta^+_4,\\Delta^-_4,\\mathrm{MSE}_4]\\,]$，每个浮点数四舍五入到 $6$ 位小数。", "solution": "该问题要求设计和评估一个使用离散傅里叶变换 (DFT) 实现的二维理想低通滤波器。先验验证证实了该问题是科学合理的、适定的和客观的。它构成了数字信号处理中的一个标准练习，探讨了卷积定理的推论，特别是在频域中应用“砖墙”滤波器时吉布斯现象（振铃伪影）的表现。我们将逐步进行实现和分析。\n\n核心原理是频域中的乘法与空域中的卷积之间的对偶性。用冲激响应为 $h[n,m]$ 的滤波器对图像 $x[n,m]$ 进行滤波是一个卷积运算：$y[n,m] = (x * h)[n,m]$。根据卷积定理，这等价于它们各自 DFT 的逐点相乘：$Y[u,v] = X[u,v] \\cdot H[u,v]$，其中 $X = \\mathcal{F}\\{x\\}$ 和 $H = \\mathcal{F}\\{h\\}$。理想低通滤波器由频域中的急剧截止定义，这对应于一个在特定频率半径内为1、在半径外为0的滤波器掩模 $H[u,v]$。\n\n算法流程如下：\n\n**步骤 1：构造合成图像**\n构造一个合成测试图像 $I \\in \\mathbb{R}^{N \\times N}$，使其具有单条、锐利的垂直边缘。这提供了一个强烈的、局部化的不连续性，非常适合观察振铃伪影。根据规定，对于 $N=128$，图像定义为：\n$$\nI[i,j] = \\begin{cases}\n0,  \\text{for } 0 \\le j  64 \\\\\n1,  \\text{for } 64 \\le j  128\n\\end{cases}\n$$\n这对所有行 $i \\in \\{0, \\dots, 127\\}$ 都成立。图像的值在垂直方向上是恒定的。\n\n**步骤 2：变换到频域及滤波器设计**\n首先，计算图像 $I[i,j]$ 的二维 DFT，以获得其频域表示 $F[u,v] = \\mathcal{F}\\{I\\}$。\n$$\nF[u,v] = \\sum_{n=0}^{N-1}\\sum_{m=0}^{N-1} I[n,m] \\, \\exp\\!\\left(-2\\pi i \\left(\\frac{un}{N} + \\frac{vm}{N}\\right)\\right)\n$$\n接下来，构造一个环形低通滤波器掩模 $H[u,v]$。该掩模在一个“已平移”的频域空间中设计，其中零频分量 $(u=0, v=0)$ 位于 $N \\times N$ 网格的中心。中心化的频率索引 $u,v$ 的范围是从 $-N/2$ 到 $N/2-1$。对于每个频率坐标 $(u,v)$，计算其与原点的欧几里得距离 $d = \\sqrt{u^2 + v^2}$。“砖墙”掩模 $H$ 随后基于截止半径 $r_c$ 定义：\n$$\nH[u,v] = \\begin{cases}\n1,  \\text{if } \\sqrt{u^2 + v^2} \\le r_c \\\\\n0,  \\text{if } \\sqrt{u^2 + v^2}  r_c\n\\end{cases}\n$$\n此掩模将应用于同样按此中心化配置排列的图像频谱。\n\n**步骤 3：滤波与逆变换**\n滤波操作是中心化的图像频谱 $F_{\\text{shifted}}$ 与滤波器掩模 $H$ 的逐点相乘。\n$$\nG_{\\text{shifted}}[u,v] = F_{\\text{shifted}}[u,v] \\cdot H[u,v]\n$$\n为了正确计算逆 DFT，得到的滤波后频谱 $G_{\\text{shifted}}$ 必须被移回标准 DFT 布局，即零频分量位于原点（索引 $(0,0)$）。设此为 $G$。然后，通过对 $G[u,v]$ 应用二维逆 DFT，可以获得空间域中的滤波后图像 $\\widehat{I}[i,j]$。\n$$\n\\widehat{I}_{\\text{complex}}[i,j] = \\mathcal{F}^{-1}\\{G\\} = \\frac{1}{N^2}\\sum_{u=0}^{N-1}\\sum_{v=0}^{N-1} G[u,v] \\, \\exp\\!\\left(2\\pi i \\left(\\frac{ui}{N} + \\frac{vj}{N}\\right)\\right)\n$$\n由于原始图像 $I$ 是实值的，且滤波器掩模 $H$ 具有共轭对称性（$H[u,v] = H[-u,-v]$），滤波后的频谱 $G$ 也将具有共轭对称性。因此，其逆 DFT $\\widehat{I}_{\\text{complex}}$ 应该是纯实数的，除去数值精度误差。我们只保留实部：$\\widehat{I}[i,j] = \\text{real}(\\widehat{I}_{\\text{complex}}[i,j])$。\n\n**步骤 4：伪影的量化**\n吉布斯现象表现为不连续点附近的振荡或“振铃”。我们在图像的中心行 $p[j] = \\widehat{I}[N/2, j]$（其中 $N=128$）上量化此效应。边缘位于列索引 $c_0 = N/2 = 64$ 处。\n- 峰值过冲 $\\Delta^+$ 测量在边缘亮侧，半宽为 $W=32$ 的窗口内，剖面 $p[j]$ 超过高电平渐近线（即 $1$）的最大值。\n$$\n\\Delta^+ = \\max\\left(0, \\max_{j \\in \\{64,\\dots,96\\}} \\big(p[j] - 1\\big)\\right)\n$$\n- 峰值下冲 $\\Delta^-$ 测量在边缘暗侧，窗口内 $p[j]$ 低于低电平渐近线（即 $0$）的最大偏差。\n$$\n\\Delta^- = \\max\\left(0, \\max_{j \\in \\{32,\\dots,63\\}} \\big(0 - p[j]\\big)\\right)\n$$\n- 整体重建质量通过滤波后图像 $\\widehat{I}$ 与原始图像 $I$ 之间的均方误差 (MSE) 来衡量。\n$$\n\\mathrm{MSE} = \\frac{1}{N^2} \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\big(\\widehat{I}[i,j] - I[i,j]\\big)^2\n$$\n\n**步骤 5：执行测试用例**\n对每个指定的截止半径 $r_c \\in \\{0, 8, 16, 128\\}$（使用 $N=128$ 和 $W=32$）执行上述过程。计算并格式化每个 $r_c$ 对应的三元组 $[\\Delta^+, \\Delta^-, \\mathrm{MSE}]$。\n\n- 对于 $r_c=0$，仅通过直流分量（$u=0,v=0$）。重建的图像 $\\widehat{I}$ 是均匀的，其值等于原始图像的平均强度，即 $0.5$。这导致 $\\Delta^+=0$，$\\Delta^-=0$，以及 $\\mathrm{MSE}=0.25$。\n- 对于 $r_c=128$，半径足够大，可以通过 $128 \\times 128$ 网格的所有频率分量。因此，$H$ 是一个全通滤波器，$\\widehat{I}$ 应与 $I$几乎相同，从而产生最小的伪影和误差。\n- 中间情况 $r_c=8$ 和 $r_c=16$ 将表现出典型的振铃伪影。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a 2D ideal low-pass filter and quantifies ringing artifacts.\n    \"\"\"\n    # Define the parameters from the problem statement.\n    N = 128\n    W = 32\n    test_rcs = [0, 8, 16, 128]\n    c0 = N // 2\n\n    # Step 1: Construct the synthetic binary step image I.\n    I = np.zeros((N, N), dtype=float)\n    I[:, c0:] = 1.0\n\n    # Step 2: Compute the 2D DFT of I.\n    F = np.fft.fft2(I)\n    \n    # Pre-calculate frequency grid for mask generation.\n    # The grid is created in the \"shifted\" or centered representation.\n    freqs_1d = np.fft.fftshift(np.fft.fftfreq(N) * N)\n    u, v = np.meshgrid(freqs_1d, freqs_1d, indexing='ij')\n    radius_grid = np.sqrt(u**2 + v**2)\n    \n    # Store the shifted spectrum of the image.\n    F_shifted = np.fft.fftshift(F)\n\n    results_data = []\n    \n    for r_c in test_rcs:\n        # Step 2 (cont.): Design the circular brick-wall low-pass mask H.\n        H = (radius_grid = r_c).astype(float)\n\n        # Step 3: Form the filtered spectrum and compute the inverse DFT.\n        # Apply the mask via pointwise multiplication in the frequency domain.\n        G_shifted = F_shifted * H\n        \n        # Shift the filtered spectrum back to the standard DFT layout.\n        G = np.fft.ifftshift(G_shifted)\n        \n        # Compute the inverse 2D DFT.\n        I_hat_complex = np.fft.ifft2(G)\n        \n        # Retain the real part of the reconstructed image.\n        I_hat = np.real(I_hat_complex)\n\n        # Step 4: Quantify ringing artifacts and MSE.\n        # Extract the center-row profile.\n        p = I_hat[N // 2, :]\n\n        # Calculate peak overshoot (Delta+).\n        # Interval: j from c0 to c0+W. Slice is [c0:c0+W+1].\n        bright_region_slice = p[c0 : c0 + W + 1]\n        overshoot = np.max(bright_region_slice - 1.0)\n        delta_plus = max(0.0, overshoot)\n\n        # Calculate peak undershoot (Delta-).\n        # Interval: j from c0-W to c0-1. Slice is [c0-W:c0].\n        dark_region_slice = p[c0 - W : c0]\n        undershoot = np.max(0.0 - dark_region_slice)\n        delta_minus = max(0.0, undershoot)\n\n        # Calculate Mean-Squared Error (MSE).\n        mse = np.mean((I_hat - I)**2)\n        \n        # Store the triplet of results for this test case.\n        results_data.append([delta_plus, delta_minus, mse])\n\n    # Step 5: Format the final output string exactly as specified.\n    outer_parts = []\n    for res_triple in results_data:\n        inner_parts = [f\"{val:.6f}\" for val in res_triple]\n        outer_parts.append(f\"[{','.join(inner_parts)}]\")\n    \n    final_output_string = f\"[{','.join(outer_parts)}]\"\n    \n    # The final print statement produces a single line in the required format.\n    print(final_output_string)\n\nsolve()\n```", "id": "3222771"}]}