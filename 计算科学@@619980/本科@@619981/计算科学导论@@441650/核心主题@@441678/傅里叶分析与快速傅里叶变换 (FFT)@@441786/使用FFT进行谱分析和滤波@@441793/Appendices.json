{"hands_on_practices": [{"introduction": "傅里叶分析是表示信号的强大工具，但在处理具有尖锐不连续性的信号（如方波）时，截断的傅里叶级数会在不连续点附近产生过冲和振荡，即吉布斯现象。本练习将引导你通过FFT亲手复现这一现象，并学习如何应用谱滤波器来抑制这些伪影。掌握这项技能对于在频域中准确地表示和处理信号至关重要。[@problem_id:3282429]", "problem": "考虑一个 $2\\pi$ 周期函数 $f(\\theta)$，其定义为：当 $0 \\le \\theta  \\pi$ 时，$f(\\theta)=1$；当 $\\pi \\le \\theta  2\\pi$ 时，$f(\\theta)=-1$，并进行周期性延拓。任务是使用通过快速傅里叶变换 (FFT) 算法计算的傅里叶部分和 $S_N(\\theta)$ 来分析吉布斯现象，并应用谱指数滤波器来减少间断点附近的过冲。所有计算均使用弧度制。\n\n使用以下基本依据和约束条件：\n\n- $2\\pi$ 周期函数 $f(\\theta)$ 的傅里叶级数由复傅里叶系数构成，截断部分和 $S_N(\\theta)$ 保留频率指数绝对值最大为 $N$ 的模式。\n- 采样数据的离散傅里叶变换 (DFT) 在等距网格上为傅里叶系数提供了一致的数值近似，而快速傅里叶变换 (FFT) 算法对 $M$ 个样本点计算 DFT 的时间复杂度为 $\\mathcal{O}(M \\log M)$。\n- 谱指数滤波器的定义为：将每个保留的、对应于频率指数 $k$（其中 $1 \\le |k| \\le N$）的复傅里叶系数乘以因子 $\\exp\\!\\left(-\\alpha \\left(\\frac{|k|}{N}\\right)^{p}\\right)$，并保持零频模式不变。使用 $\\alpha=36$ 和 $p=8$。\n\n实现以下步骤：\n\n1. 在一个包含 $M=4096$ 个点的均匀网格上对 $f(\\theta)$ 进行采样，采样点为 $\\theta_j = \\frac{2\\pi j}{M}$，其中 $j=0,1,2,\\dots,M-1$。\n2. 使用快速傅里叶变换 (FFT) 从样本计算离散谱。通过将频率大小（绝对值）大于 $N$ 的所有 DFT 系数置零来构建 $S_N(\\theta)$（对称地保留正负频率，并包括零频模式）。在同一网格上通过逆变换重构 $S_N(\\theta)$。\n3. 在进行逆变换之前，对保留的系数应用参数为 $\\alpha=36$ 和 $p=8$ 的指数滤波器，构建滤波后的部分和 $S_N^{\\mathrm{filt}}(\\theta)$，并保持零频模式不变。\n4. 对于每个 $N$，量化以下两项：\n   - 过冲幅度，定义为 $\\max_{\\theta} S_N(\\theta) - 1$，并从下方以 0 截断，以确保报告的幅度为非负值。\n   - 均方根 (RMS) 误差，定义为 $\\sqrt{\\frac{1}{M}\\sum_{j=0}^{M-1} \\left(S_N(\\theta_j) - f(\\theta_j)\\right)^2}$。\n   对 $S_N^{\\mathrm{filt}}(\\theta)$ 执行相同的两项测量。\n5. 使用测试集 $N \\in \\{0,1,8,32,128,512\\}$，并报告该测试集中每个 $N$ 对应的未滤波过冲幅度、滤波后过冲幅度、未滤波 RMS 误差和滤波后 RMS 误差。\n\n您的程序应生成单行输出，其中包含一个由五个列表组成的逗号分隔列表，列表之间无空格，并严格按照以下顺序：$N$ 值列表、未滤波过冲幅度列表、滤波后过冲幅度列表、未滤波 RMS 误差列表和滤波后 RMS 误差列表。例如，要求的格式为 `[[N_list],[unfiltered_overshoots],[filtered_overshoots],[unfiltered_rms],[filtered_rms]]`，其中每个方括号内的项都是一个数字列表。所有角度均以弧度为单位，所有报告的数值均为无单位浮点数。", "solution": "该问题要求对一个 $2\\pi$ 周期方波的吉布斯现象及其通过谱指数滤波器进行的缓解进行数值研究。分析将使用快速傅里叶变换 (FFT) 算法来计算截断的傅里叶级数近似。\n\n所考虑的函数是在区间 $[0, 2\\pi)$ 上定义的 $2\\pi$ 周期方波：\n$$\nf(\\theta) = \\begin{cases}\n    1  \\text{for } 0 \\le \\theta  \\pi \\\\\n    -1 \\text{for } \\pi \\le \\theta  2\\pi\n\\end{cases}\n$$\n对于任意整数 $n$，该函数在 $\\theta = n\\pi$ 处有跳跃间断点。当用截断的傅里叶级数来近似时，这些间断点会导致吉布斯现象，其特征是在跳跃点附近存在持续的过冲。\n\n分析的核心依赖于通过 FFT 高效计算的离散傅里叶变换 (DFT)。过程如下：\n\n首先，我们将域 $[0, 2\\pi)$ 离散化。在 $M=4096$ 个点的均匀网格上对函数 $f(\\theta)$ 进行采样，采样点为 $\\theta_j = \\frac{2\\pi j}{M}$，其中 $j=0, 1, \\dots, M-1$。这将产生一个样本向量 $f_j = f(\\theta_j)$。根据函数定义，结果是当 $j=0, \\dots, M/2-1$ 时 $f_j = 1$，当 $j=M/2, \\dots, M-1$ 时 $f_j = -1$。\n\n其次，我们计算采样信号 $\\{f_j\\}$ 的 DFT，以获得其频谱 $\\{\\hat{f}_k\\}$。DFT 定义为 $\\hat{f}_k = \\sum_{j=0}^{M-1} f_j \\exp(-i 2\\pi jk/M)$。对于 FFT 算法的输出数组，可以获得相应的整数频率模式（波数）$k$。对于长度为 $M$ 的输入，频率对应于序列 $k = 0, 1, \\dots, M/2-1, -M/2, \\dots, -1$。\n\n第三，对于测试集 $\\{0, 1, 8, 32, 128, 512\\}$ 中的每个截断参数 $N$，我们构建两种对 $f(\\theta)$ 的不同近似。\n\n未滤波的傅里叶部分和 $S_N(\\theta)$ 由截断谱 $\\hat{S}_{N}$ 构建。该谱通过将所有频率指数绝对值 $|k|$ 超过截断限 $N$ 的系数 $\\hat{f}_k$ 置零得到：\n$$\n\\hat{S}_{N,k} = \\begin{cases}\n    \\hat{f}_k  \\text{if } |k| \\le N \\\\\n    0          \\text{if } |k|  N\n\\end{cases}\n$$\n然后，通过对谱系数 $\\{\\hat{S}_{N,k}\\}$ 应用离散傅里叶逆变换 (IDFT) 来恢复其空间表示 $S_N(\\theta_j)$。IDFT 由 $S_N(\\theta_j) = \\frac{1}{M} \\sum_{k=0}^{M-1} \\hat{S}_{N,k} \\exp(i 2\\pi jk/M)$ 给出。\n\n滤波后的部分和 $S_N^{\\mathrm{filt}}(\\theta)$ 是为了减少吉布斯振荡而构建的。这通过在逆变换之前对截断谱应用谱滤波器来实现。滤波后的谱 $\\hat{S}_{N,k}^{\\mathrm{filt}}$ 的定义是将保留的系数乘以一个滤波因子 $\\sigma_k$：\n$$\n\\hat{S}_{N,k}^{\\mathrm{filt}} = \\sigma_k \\hat{S}_{N,k} \\quad \\text{where} \\quad \\sigma_k = \\begin{cases}\n    1  \\text{if } k=0 \\\\\n    \\exp\\!\\left(-\\alpha \\left(\\frac{|k|}{N}\\right)^{p}\\right)  \\text{if } 1 \\le |k| \\le N \\\\\n    1  \\text{if } |k|  N \\text{ (but } \\hat{S}_{N,k}=0 \\text{ anyway)}\n\\end{cases}\n$$\n滤波器参数给定为 $\\alpha=36$ 和 $p=8$。然后通过对 $\\{\\hat{S}_{N,k}^{\\mathrm{filt}}\\}$ 应用 IDFT 来恢复其空间表示 $S_N^{\\mathrm{filt}}(\\theta_j)$。对于 $N=0$ 的特殊情况，滤波条件 $1 \\le |k| \\le N$ 永远不会满足，因此没有模式会被滤波因子修改。\n\n第四，我们量化两种近似的性能。对每个 $N$ 值计算两个指标：\n1. 过冲幅度，定义为重构信号的最大值减去函数的真实最大值（$1$），并从下方以零截断以确保结果为非负：\n   $$ \\text{Overshoot} = \\max\\left(0, \\left(\\max_j S(\\theta_j)\\right) - 1\\right) $$\n2. 均方根 (RMS) 误差，它衡量了在整个网格上与真实函数的平均偏差：\n   $$ \\text{RMS Error} = \\sqrt{\\frac{1}{M}\\sum_{j=0}^{M-1} \\left(S(\\theta_j) - f(\\theta_j)\\right)^2} $$\n这两个指标分别对未滤波和 $S_N(\\theta_j)$ 和滤波后和 $S_N^{\\mathrm{filt}}(\\theta_j)$ 进行计算。\n\n该算法通过遍历指定的 $N$ 值，执行这些计算，并收集结果以用于最终的格式化输出。数据将表明，虽然未滤波的和表现出显著且持续的过冲（吉布斯现象），但谱滤波器有效地抑制了这些振荡，从而使过冲幅度大大减小。然而，这种在减少局部误差方面的改进，可能会以全局误差（由 RMS 值衡量）的轻微增加为代价。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes unfiltered and filtered Fourier partial sums for a square wave\n    to analyze the Gibbs phenomenon and the effect of a spectral filter.\n    \"\"\"\n    # Define the parameters and test cases from the problem statement.\n    M = 4096\n    alpha = 36\n    p = 8\n    test_cases = [0, 1, 8, 32, 128, 512] # These are the values for N\n\n    # --- Main Logic ---\n\n    # Step 1: Sample the function f(theta)\n    # The function is f(theta) = 1 for 0 = theta  pi and f(theta) = -1 for pi = theta  2pi.\n    # On a grid of M points theta_j = 2*pi*j/M, this corresponds to\n    # f_j = 1 for j=0..M/2-1 and f_j = -1 for j=M/2..M-1.\n    f_samples = np.ones(M)\n    f_samples[M // 2:] = -1.0\n\n    # Step 2: Compute the DFT of the sampled signal\n    f_hat = np.fft.fft(f_samples)\n    # Get the corresponding integer frequency modes k for the DFT output array.\n    # np.fft.fftfreq(M) * M gives [0, 1, ..., M/2-1, -M/2, ..., -1]\n    k_freqs = np.fft.fftfreq(M) * M\n\n    # Store results for each N\n    results_unfiltered_overshoot = []\n    results_filtered_overshoot = []\n    results_unfiltered_rms = []\n    results_filtered_rms = []\n\n    for N in test_cases:\n        # Construct unfiltered partial sum S_N by truncating the spectrum\n        S_N_hat = f_hat.copy()\n        # Zero out coefficients for frequencies with magnitude  N\n        S_N_hat[np.abs(k_freqs)  N] = 0.0\n        \n        # Reconstruct S_N via inverse FFT\n        # The result should be real-valued; .real discards negligible imaginary parts from numerical error.\n        S_N = np.fft.ifft(S_N_hat).real\n\n        # Construct filtered partial sum S_N_filt\n        S_N_filt_hat = S_N_hat.copy() # Start with the same truncated spectrum\n        if N  0:\n            # Create a mask for modes to be filtered (1 = |k| = N)\n            filter_mask = (np.abs(k_freqs)  0)  (np.abs(k_freqs) = N)\n            \n            # Get the k values of the modes to be filtered\n            k_vals_to_filter = np.abs(k_freqs[filter_mask])\n            \n            # Calculate the exponential filter factors\n            sigma_k = np.exp(-alpha * (k_vals_to_filter / N)**p)\n            \n            # Apply the filter by element-wise multiplication\n            S_N_filt_hat[filter_mask] *= sigma_k\n        \n        # Reconstruct S_N_filt via inverse FFT\n        S_N_filt = np.fft.ifft(S_N_filt_hat).real\n\n        # Quantify overshoot and RMS error for both cases\n        # For S_N (unfiltered)\n        overshoot_unfiltered = np.maximum(0.0, np.max(S_N) - 1.0)\n        rms_unfiltered = np.sqrt(np.mean((S_N - f_samples)**2))\n        \n        # For S_N_filt (filtered)\n        overshoot_filtered = np.maximum(0.0, np.max(S_N_filt) - 1.0)\n        rms_filtered = np.sqrt(np.mean((S_N_filt - f_samples)**2))\n\n        # Append results to lists\n        results_unfiltered_overshoot.append(overshoot_unfiltered)\n        results_filtered_overshoot.append(overshoot_filtered)\n        results_unfiltered_rms.append(rms_unfiltered)\n        results_filtered_rms.append(rms_filtered)\n\n    # Final print statement in the exact required format.\n    all_results = [\n        test_cases,\n        results_unfiltered_overshoot,\n        results_filtered_overshoot,\n        results_unfiltered_rms,\n        results_filtered_rms\n    ]\n    \n    # Convert each inner list of numbers into a comma-separated string, enclosed in brackets.\n    stringified_lists = [f\"[{','.join(map(str, lst))}]\" for lst in all_results]\n    \n    # Join these stringified lists into the final output format: [[list1],[list2],...]\n    print(f\"[{','.join(stringified_lists)}]\")\n\nsolve()\n```", "id": "3282429"}, {"introduction": "在许多实际应用中，信号会经过非线性系统，从而产生原始信号中不存在的谐波失真。本练习模拟了这一过程，并教你如何利用FFT的正交投影特性，像使用手术刀一样精确地识别和移除这些不必要的谐波分量。通过这种方式，你可以“净化”信号，或者反过来分析残留分量，以研究噪声和高阶非线性效应。[@problem_id:3196001]", "problem": "您将使用快速傅里叶变换 (FFT) 来实现谐波移除和残差分析，其理论基础是离散傅里叶变换 (DFT) 和复指数的正交性。目的是将一个实值离散时间信号投影到由指定基频的整数次谐波的正弦分量所张成的子空间上，移除这些谐波，重构时域残差，并量化残差能量中有多大比例可归因于超出已移除集合的非线性谐波生成。\n\n基本原理：\n- 设 $x[n]$ (其中 $n \\in \\{0,1,\\dots,N-1\\}$) 为一个实值序列。离散傅里叶变换 (DFT) 定义为\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] e^{-j 2 \\pi \\frac{k n}{N}}, \\quad k \\in \\{0,1,\\dots,N-1\\}.\n$$\n逆离散傅里叶变换 (IDFT) 为\n$$\nx[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] e^{j 2 \\pi \\frac{k n}{N}}.\n$$\n- 在内积 $\\langle u, v \\rangle = \\sum_{n=0}^{N-1} u[n] \\overline{v[n]}$ 下，集合 $\\{e^{j 2 \\pi \\frac{k n}{N}} : k = 0,1,\\dots,N-1\\}$ 构成一个正交基。当 $k \\neq m$ 时，有 $\\sum_{n=0}^{N-1} e^{j 2 \\pi \\frac{(k-m) n}{N}} = 0$。\n- 将 $x[n]$ 投影到索引集 $\\mathcal{K} \\subset \\{0,1,\\dots,N-1\\}$ 对应的复指数所张成的空间上，可通过保留 $k \\in \\mathcal{K}$ 的 $X[k]$ 并将其余系数置零，然后通过逆 DFT 获得时域分量来实现。\n\n问题要求：\n- 您将合成一个信号，该信号包含一个频率为 $f_0$、振幅为 $A_1$ 的基波正弦信号，将其通过一个静态多项式非线性环节以生成谐波，加入零均值高斯噪声，然后使用 FFT 进行谐波移除和残差分析。\n- 信号模型：以采样率 $f_s$（单位 $\\mathrm{Hz}$）采样，持续时间 $T$（单位 $\\mathrm{s}$），共 $N = f_s \\cdot T$ 个样本。令 $t[n] = \\frac{n}{f_s}$，其中 $n = 0,1,\\dots,N-1$。定义基波正弦信号为\n$$\nx_0[n] = A_1 \\sin(2 \\pi f_0 t[n]).\n$$\n将 $x_0[n]$ 通过一个无记忆非线性环节\n$$\nx_{\\text{nl}}[n] = x_0[n] + \\alpha\\, x_0[n]^2 + \\beta\\, x_0[n]^3,\n$$\n并加入使用指定伪随机数种子生成的独立同分布高斯噪声 $w[n] \\sim \\mathcal{N}(0,\\sigma^2)$，得到\n$$\ny[n] = x_{\\text{nl}}[n] + w[n].\n$$\n- 使用 FFT 通过正交投影进行谐波移除：\n  1. 计算 $y[n]$ 的 DFT $Y[k]$。\n  2. 对于给定的谐波数量 $H \\in \\mathbb{N}$，使用 $k_n = \\left\\lfloor \\frac{n f_0 N}{f_s} + \\tfrac{1}{2} \\right\\rfloor$（最近整数取整）来确定与频率 $\\{n f_0 : n = 1,2,\\dots,H\\}$ 对应的 DFT 频点索引。对于每个严格介于 $0$ 和 $N/2$ 之间的 $k_n$，包含其共轭对称的频点 $N-k_n$。选择时排除直流 (DC) 频点 $k=0$ 和奈奎斯特频点 $k=N/2$（当 $N$ 为偶数时）。\n  3. 通过仅在选定的频点 $\\{k_n, N-k_n\\}$ 处保留 $Y[k]$ 并将所有其他频点置零，来构成 $Y_{\\text{harm}}[k]$。\n  4. 通过 IDFT 从 $Y_{\\text{harm}}[k]$ 获得时域谐波分量 $y_{\\text{harm}}[n]$。\n  5. 时域残差为 $r[n] = y[n] - y_{\\text{harm}}[n]$。\n- 非线性噪声贡献分析：\n  - 计算残差能量 $E_{\\text{tot}} = \\sum_{n=0}^{N-1} r[n]^2$。\n  - 为估计可归因于超出已移除集合的谐波的残差能量分数，构建一个频率掩码，该掩码选择围绕着对应于频率 $\\{n f_0 : n = H+1, H+2, \\dots\\}$（这些频率严格低于奈奎斯特频率 $\\frac{f_s}{2}$）的 DFT 索引的三频点邻域（中心频点及其两侧各一个频点）。对于每个这样的中心索引 $k_n = \\left\\lfloor \\frac{n f_0 N}{f_s} + \\tfrac{1}{2} \\right\\rfloor$，包括频点 $\\{k_n-1, k_n, k_n+1\\}$（裁剪到有效的正频率、非直流、非奈奎斯特范围内），并在适用时也包括它们的共轭对称对应项 $\\{N-(k_n-1), N-k_n, N-(k_n+1)\\}$。\n  - 设 $R[k]$ 是 $r[n]$ 的 DFT。通过仅保留高阶谐波掩码所选的频点并将所有其他频点置零来定义 $R_{\\text{hh}}[k]$。反变换到时域以获得 $r_{\\text{hh}}[n]$。\n  - 计算 $E_{\\text{hh}} = \\sum_{n=0}^{N-1} r_{\\text{hh}}[n]^2$。所需标量指标是分数\n$$\n\\phi = \\frac{E_{\\text{hh}}}{E_{\\text{tot}}}.\n$$\n这是一个在区间 $[0,1]$ 内的无量纲量。\n\n实现约束：\n- 算法必须使用快速傅里叶变换 (FFT) 来计算 DFT 及其逆变换。\n- 您必须使用上述离散傅里叶变换 (DFT) 的定义作为基础。除了 DFT 基的正交性和重构属性外，不允许使用任何其他用于投影的快捷公式。\n\n测试套件：\n对于每个测试用例，设置 $A_1 = 1.0$，使用指定的种子生成噪声，并计算如上定义的标量 $\\phi$。最终的标量没有物理单位，是无量纲的。程序必须处理以下四种情况：\n\n- 情况 1（理想路径，频点对齐，部分移除）：\n  - $f_s = 8192$, $T = 1.0$, $f_0 = 256.0$, $H = 1$, $\\alpha = 0.2$, $\\beta = 0.05$, $\\sigma = 0.01$, 种子 $= 2021$。\n- 情况 2（频点对齐，更深度移除）：\n  - $f_s = 8192$, $T = 1.0$, $f_0 = 256.0$, $H = 3$, $\\alpha = 0.2$, $\\beta = 0.05$, $\\sigma = 0.01$, 种子 $= 2021$。\n- 情况 3（频率未对齐导致频谱泄漏）：\n  - $f_s = 8000$, $T = 1.0$, $f_0 = 255.5$, $H = 3$, $\\alpha = 0.2$, $\\beta = 0.05$, $\\sigma = 0.01$, 种子 $= 7$。\n- 情况 4（仅噪声边界条件，频点对齐）：\n  - $f_s = 8192$, $T = 0.5$, $f_0 = 300.0$, $H = 2$, $\\alpha = 0.0$, $\\beta = 0.0$, $\\sigma = 0.02$, 种子 $= 999$。\n\n要求的最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个 Python 风格的列表，内含四个标量结果 $[\\phi_1,\\phi_2,\\phi_3,\\phi_4]$，每个 $\\phi_i$ 对应于情况 $i \\in \\{1,2,3,4\\}$。每个值必须精确到小数点后六位，且无空格。例如，一个可接受的格式是 $[0.123456,0.234567,0.345678,0.456789]$。", "solution": "这个问题是有效的，因为它科学地基于数字信号处理的原理，问题定义良好，具有通向唯一解的清晰算法路径，并且其表述是客观的。解决方案通过实施指定的信号合成、滤波和分析步骤来进行。\n\n方法论基础在于离散傅里叶变换 (DFT) 的性质。一个长度为 $N$ 的离散时间信号 $y[n]$ 可以表示为 $N$ 个正交复指数基函数 $\\{e^{j 2 \\pi \\frac{k n}{N}}\\}_{k=0}^{N-1}$ 的线性组合。DFT 系数 $Y[k]$ 是信号在这个基中的坐标：\n$$\nY[k] = \\sum_{n=0}^{N-1} y[n] e^{-j 2 \\pi \\frac{k n}{N}}\n$$\n这实际上是将 $y[n]$ 投影到每个基向量上。由于正交性，信号可以通过逆离散傅里叶变换 (IDFT) 从其系数中完美重构：\n$$\ny[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} Y[k] e^{j 2 \\pi \\frac{k n}{N}}\n$$\n\n问题的核心是执行理想的频域滤波，这是一个到由所选 DFT 基向量子集张成的子空间上的正交投影。算法流程如下：\n\n1.  **信号合成**：根据提供的模型合成信号 $y[n]$。一个纯正弦波 $x_0[n] = A_1 \\sin(2 \\pi f_0 t[n])$ 通过一个多项式非线性环节 $x_{\\text{nl}}[n] = x_0[n] + \\alpha\\, x_0[n]^2 + \\beta\\, x_0[n]^3$。使用三角恒等式，例如 $\\sin^2(\\theta) = \\frac{1}{2}(1-\\cos(2\\theta))$ 和 $\\sin^3(\\theta) = \\frac{3}{4}\\sin(\\theta)-\\frac{1}{4}\\sin(3\\theta)$，可以证明这种非线性除了基波 ($f_0$) 外，还会在直流 ($0$ Hz)、二次谐波 ($2 f_0$) 和三次谐波 ($3 f_0$) 处产生分量。最后，加入零均值高斯噪声 $w[n]$，得到复合信号 $y[n] = x_{\\text{nl}}[n] + w[n]$。\n\n2.  **通过投影进行谐波移除**：为了移除前 $H$ 个谐波，我们将信号 $y[n]$ 投影到与这些谐波频率对应的基向量所张成的子空间上。\n    -   首先，使用快速傅里叶变换 (FFT) 算法计算信号 $y[n]$ 的 DFT $Y[k]$。\n    -   识别出与谐波频率 $\\{f_n = n f_0 : n=1, \\dots, H\\}$ 对应的 DFT 频点索引集 $\\mathcal{K}_{\\text{harm}}$。对于每个频率 $f_n$，最近的整数频点索引计算为 $k_n = \\lfloor \\frac{f_n N}{f_s} + \\frac{1}{2} \\rfloor$。由于输入信号 $y[n]$ 是实数，其 DFT 是共轭对称的，即 $Y[k] = \\overline{Y[N-k]}$。为了在滤波后的信号中保持此属性，对于正频率范围（$1 \\le k_n  N/2$）中的每个索引 $k_n$，其对称的对应项 $N-k_n$ 也必须包含在 $\\mathcal{K}_{\\text{harm}}$ 中。\n    -   通过保留 $\\mathcal{K}_{\\text{harm}}$ 中索引的原始系数，并将所有其他系数置零，来形成新的频谱 $Y_{\\text{harm}}[k]$：如果 $k \\in \\mathcal{K}_{\\text{harm}}$，则 $Y_{\\text{harm}}[k] = Y[k]$，否则为 $0$。\n    -   时域残差 $r[n]$ 是信号中与谐波子空间正交的部分。它可以通过在频域中创建残差频谱 $R[k] = Y[k] - Y_{\\text{harm}}[k]$，然后变换回时域来直接计算：$r[n] = \\text{IDFT}(R[k])$。\n\n3.  **残差能量分析**：计算残差的总能量为 $E_{\\text{tot}} = \\sum_{n=0}^{N-1} r[n]^2$。此残差包含高阶谐波（频率大于 $H f_0$）、噪声，以及由于频谱泄漏而未被移除的前 $H$ 个谐波的任何能量。\n\n4.  **高阶谐波的量化**：为了估计超出已移除集合的谐波的能量贡献，对残差执行第二次投影。\n    -   使用残差的 DFT $R[k]$。\n    -   构建一个新的频率掩码，以选择围绕着低于奈奎斯特频率 $f_s/2$ 的高阶谐波 $\\{n f_0 : n=H+1, H+2, \\dots\\}$ 对应的频点索引的三频点邻域。这将创建一个索引集 $\\mathcal{K}_{\\text{hh}}$。\n    -   通过保留 $\\mathcal{K}_{\\text{hh}}$ 中索引的 $R[k]$ 系数并将其他系数置零来形成新的频谱 $R_{\\text{hh}}[k]$。\n    -   将此频谱变换回时域以获得 $r_{\\text{hh}}[n] = \\text{IDFT}(R_{\\text{hh}}[k])$。\n    -   该分量的能量计算为 $E_{\\text{hh}} = \\sum_{n=0}^{N-1} r_{\\text{hh}}[n]^2$。\n    -   最终的度量指标 $\\phi = E_{\\text{hh}} / E_{\\text{tot}}$ 表示残差能量中集中在后续谐波频带内的部分。根据 Parseval 定理，这个能量比也可以在频域中计算，但本实现遵循指定的时域计算方法。\n\n此过程被系统地应用于每个测试用例，从而得出无量纲的标量度量 $\\phi$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    def calculate_phi(fs, T, f0, H, alpha, beta, sigma, seed, A1=1.0):\n        \"\"\"\n        Calculates the scalar metric phi for a single test case.\n        \"\"\"\n        # Step 1: Signal Generation\n        N = int(fs * T)\n        t = np.arange(N) / fs\n        \n        rng = np.random.default_rng(seed)\n        \n        x0_n = A1 * np.sin(2 * np.pi * f0 * t)\n        x_nl_n = x0_n + alpha * x0_n**2 + beta * x0_n**3\n        w_n = rng.normal(loc=0.0, scale=sigma, size=N)\n        y_n = x_nl_n + w_n\n        \n        # Step 2: Harmonic Removal by Orthogonal Projection\n        Y_k = np.fft.fft(y_n)\n        \n        harmonic_indices = set()\n        nyquist_idx = N // 2\n        \n        for n_h in range(1, H + 1):\n            freq = n_h * f0\n            # Implement k_n = floor(v + 0.5) for nearest-integer rounding\n            k = int((freq * N / fs) + 0.5)\n            \n            # Exclude DC (k=0) and Nyquist (k=N/2) bins from selection\n            if 1 = k  nyquist_idx:\n                harmonic_indices.add(k)\n                harmonic_indices.add(N - k)\n\n        # The residual spectrum is formed by zeroing out the harmonic bins.\n        R_k = np.copy(Y_k)\n        for k in harmonic_indices:\n            R_k[k] = 0.0\n            \n        # The time-domain residual is the inverse DFT of the residual spectrum.\n        # .real is taken as the input is real and the filter is symmetric.\n        r_n = np.fft.ifft(R_k).real\n        \n        # Step 3: Nonlinear Noise Contribution Analysis\n        E_tot = np.sum(r_n**2)\n        \n        # DFT of the residual is R_k, which we already have.\n        \n        # Build frequency mask for higher-order harmonics\n        hh_indices = set()\n        nyquist_freq = fs / 2.0\n        n_h = H + 1\n        while True:\n            freq = n_h * f0\n            if freq = nyquist_freq:\n                break\n            \n            k_center = int((freq * N / fs) + 0.5)\n            \n            # Create a 3-bin neighborhood\n            for dk in [-1, 0, 1]:\n                k = k_center + dk\n                # Clip to valid positive-frequency, non-DC, non-Nyquist range\n                if 1 = k  nyquist_idx:\n                    hh_indices.add(k)\n                    # Add conjugate symmetric bin\n                    hh_indices.add(N - k)\n            \n            n_h += 1\n            \n        # Create high-harmonic residual spectrum from the residual's spectrum\n        R_hh_k = np.zeros_like(R_k)\n        for k in hh_indices:\n            R_hh_k[k] = R_k[k]\n            \n        # Reconstruct time-domain high-harmonic residual and compute its energy\n        r_hh_n = np.fft.ifft(R_hh_k).real\n        E_hh = np.sum(r_hh_n**2)\n        \n        # Avoid division by zero, although unlikely with noise\n        if E_tot == 0.0:\n            return 0.0\n        \n        phi = E_hh / E_tot\n        \n        return phi\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, aligned bins, partial removal):\n        {'fs': 8192, 'T': 1.0, 'f0': 256.0, 'H': 1, 'alpha': 0.2, 'beta': 0.05, 'sigma': 0.01, 'seed': 2021},\n        # Case 2 (aligned bins, deeper removal):\n        {'fs': 8192, 'T': 1.0, 'f0': 256.0, 'H': 3, 'alpha': 0.2, 'beta': 0.05, 'sigma': 0.01, 'seed': 2021},\n        # Case 3 (misaligned frequency causing spectral leakage):\n        {'fs': 8000, 'T': 1.0, 'f0': 255.5, 'H': 3, 'alpha': 0.2, 'beta': 0.05, 'sigma': 0.01, 'seed': 7},\n        # Case 4 (noise-only boundary, aligned bins):\n        {'fs': 8192, 'T': 0.5, 'f0': 300.0, 'H': 2, 'alpha': 0.0, 'beta': 0.0, 'sigma': 0.02, 'seed': 999}\n    ]\n\n    results = []\n    for case in test_cases:\n        phi = calculate_phi(**case)\n        results.append(phi)\n    \n    # Format each result to exactly six digits after the decimal point\n    formatted_results = [f\"{res:.6f}\" for res in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3196001"}, {"introduction": "数据采集过程中经常会遇到样本丢失的问题，导致信号不完整。简单地用零填充缺失的样本会在频谱中引入严重的干扰伪影。本练习介绍了一种先进的迭代修复技术，即“谱域修复”（spectral inpainting）。该方法利用信号在频域中的稀疏性先验知识，智能地重建缺失的数据，这正是现代信号恢复和压缩感知领域的核心思想之一。[@problem_id:3195883]", "problem": "你的任务是分析离散时间信号中缺失样本的频谱效应，然后使用基于快速傅里叶变换 (FFT) 的修复方法来减轻这些效应。请完全在离散时间域中进行操作，并使用定义明确的数学结构来表达所有步骤。使用离散傅里叶变换 (DFT) 的定义作为你的基本依据。\n\n从离散傅里叶变换 (DFT) 的基本定义开始：对于一个长度为 $N$ 的信号 $x[n]$，其 DFT 为\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] e^{-j 2\\pi k n / N}, \\quad k = 0,1,\\dots,N-1.\n$$\n设 $m[n]$ 是一个取值为 $\\{0,1\\}$ 的二进制采样掩码，其中 $m[n]=1$ 表示观测到的样本，而 $m[n]=0$ 表示缺失的样本。观测到的信号为 $x_{\\mathrm{mask}}[n] = x[n] \\cdot m[n]$。DFT 的卷积性质意味着时域中的乘法对应于频域中的循环卷积：如果 $M[k]$ 是 $m[n]$ 的 DFT，那么 $x_{\\mathrm{mask}}[n]$ 的频谱为 $X_{\\mathrm{mask}}[k] = (X * M)[k]$，这会重新分配能量到各个频率，可能产生频谱伪影。\n\n设计并实现一个程序，对下面指定的每个测试用例执行以下步骤：\n\n1.  构造一个长度为 $N$ 的合成实值信号 $x[n]$，作为具有整数频率仓的余弦信号之和：\n    $$\n    x[n] = \\sum_{i=1}^{K} A_i \\cos\\!\\left( \\frac{2\\pi f_i n}{N} \\right), \\quad n = 0,1,\\dots,N-1,\n    $$\n    其中 $K$ 是音调数量，$A_i$ 是振幅，$f_i$ 是不同的整数频率仓，满足 $0  f_i  \\frac{N}{2}$。\n\n2.  使用指定的随机种子以保证可复现性，随机选择一部分比例为 $p_{\\mathrm{miss}}$ 的索引设置为缺失 ($m[n]=0$)。通过对缺失样本进行补零来形成 $x_{\\mathrm{mask}}[n]$，即如果 $m[n]=1$，则 $x_{\\mathrm{mask}}[n] = x[n]$；如果 $m[n]=0$，则 $x_{\\mathrm{mask}}[n]=0$。\n\n3.  使用快速傅里叶变换 (FFT) 计算 $x_{\\mathrm{mask}}[n]$ 的 DFT $X_{\\mathrm{mask}}[k]$。定义真实频谱支撑集 $\\mathcal{S}$ 为与已知音调频率及其对于实信号的对称分量相对应的频率仓集合：\n    $$\n    \\mathcal{S} = \\{ f_1, f_2, \\dots, f_K \\} \\cup \\{ (-f_1) \\bmod N, \\dots, (-f_K) \\bmod N \\}.\n    $$\n    计算修复前的伪影能量比\n    $$\n    r_{\\mathrm{zero}} = \\frac{\\sum_{k \\notin \\mathcal{S}} |X_{\\mathrm{mask}}[k]|^2}{\\sum_{k=0}^{N-1} |X_{\\mathrm{mask}}[k]|^2},\n    $$\n    并约定如果分母为 $0$，则该比值为 $0$。\n\n4.  通过迭代 FFT 阈值处理进行频谱修复：\n    - 初始化 $y^{(0)}[n] = x_{\\mathrm{mask}}[n]$。\n    - 在每次迭代 $t = 0,1,2,\\dots$ 时：\n      - 计算 $Y^{(t)}[k] = \\mathrm{FFT}(y^{(t)}[n])$。\n      - 在频域进行硬阈值处理，保留 $K_{\\mathrm{keep}}$ 个最大幅值系数，并将其余系数置零，得到 $\\tilde{Y}^{(t)}[k]$。\n      - 计算逆 DFT $\\tilde{y}^{(t)}[n] = \\mathrm{IFFT}(\\tilde{Y}^{(t)}[k])$，取其实部，并在观测样本上强制执行数据一致性：\n        $$\n        y^{(t+1)}[n] = \\begin{cases}\n        x[n]  \\text{if } m[n]=1, \\\\\n        \\tilde{y}^{(t)}[n]  \\text{if } m[n]=0.\n        \\end{cases}\n        $$\n      - 当相对变化 $\\frac{\\|y^{(t+1)} - y^{(t)}\\|_2}{\\|y^{(t)}\\|_2}$ 小于容差 $\\varepsilon$，或达到最大迭代次数 $T_{\\max}$ 时停止。\n\n5.  计算最终修复信号 $y^{(\\ast)}[n]$ 的 DFT $X_{\\mathrm{rec}}[k]$ 和相应的伪影能量比\n    $$\n    r_{\\mathrm{inpaint}} = \\frac{\\sum_{k \\notin \\mathcal{S}} |X_{\\mathrm{rec}}[k]|^2}{\\sum_{k=0}^{N-1} |X_{\\mathrm{rec}}[k]|^2},\n    $$\n    约定同上。同时计算归一化重建误差\n    $$\n    e = \\frac{\\|y^{(\\ast)} - x\\|_2}{\\|x\\|_2}.\n    $$\n\n你的实现必须使用下面指定的测试套件。对于每个测试用例，返回一个包含三个浮点数的列表 $[r_{\\mathrm{zero}}, r_{\\mathrm{inpaint}}, e]$，每个浮点数四舍五入到 $6$ 位小数。最终程序输出必须是单行文本，包含所有测试用例的结果，形式为一个逗号分隔的列表并用方括号括起，其中每个元素本身是对应测试用例的三个浮点数的列表，例如 $[[a_1,b_1,c_1],[a_2,b_2,c_2]]$。\n\n测试套件：\n- 用例 1（正常情况）：$N=1024$，$K=3$，频率 $[50, 123, 300]$，振幅 $[1.0, 0.8, 0.6]$，缺失比例 $p_{\\mathrm{miss}}=0.2$，$K_{\\mathrm{keep}}=6$，容差 $\\varepsilon=10^{-8}$，最大迭代次数 $T_{\\max}=200$，随机种子 $1$。\n- 用例 2（边界情况，无缺失样本）：$N=1024$，$K=3$，频率 $[50, 123, 300]$，振幅 $[1.0, 0.8, 0.6]$，缺失比例 $p_{\\mathrm{miss}}=0.0$，$K_{\\mathrm{keep}}=6$，容差 $\\varepsilon=10^{-8}$，最大迭代次数 $T_{\\max}=200$，随机种子 $2$。\n- 用例 3（边缘情况，大量缺失）：$N=2048$，$K=5$，频率 $[15, 77, 221, 400, 650]$，振幅 $[1.0, 0.5, 0.7, 0.9, 0.4]$，缺失比例 $p_{\\mathrm{miss}}=0.5$，$K_{\\mathrm{keep}}=10$，容差 $\\varepsilon=10^{-8}$，最大迭代次数 $T_{\\max}=300$，随机种子 $3$。\n- 用例 4（边缘情况，单音和严重缺失）：$N=512$，$K=1$，频率 $[64]$，振幅 $[1.0]$，缺失比例 $p_{\\mathrm{miss}}=0.7$，$K_{\\mathrm{keep}}=2$，容差 $\\varepsilon=10^{-8}$，最大迭代次数 $T_{\\max}=300$，随机种子 $42$。\n\n最终输出格式：\n你的程序应生成单行输出，包含所有结果，形式为一个逗号分隔的列表并用方括号括起，其中每个元素是对应一个测试用例的列表 $[r_{\\mathrm{zero}}, r_{\\mathrm{inpaint}}, e]$，每个浮点数四舍五入到 $6$ 位小数，例如：\n$[[0.123456,0.000789,0.012345],[\\dots],[\\dots],[\\dots]]$。", "solution": "用户提供的问题陈述已经过仔细验证，被确定为是合理的、定义明确且具有科学依据的。它提出了一个计算信号处理中的明确任务，具体来说是使用迭代频谱方法从不完整的测量中恢复稀疏信号。所有参数、定义和过程都以足够的严谨性进行了规定，从而能够得出一个唯一且可验证的解。\n\n解决方案通过实现所述算法来推进。问题的核心在于认识到由少数正弦波组成的信号在频域中具有稀疏表示。离散傅里叶变换 (DFT)——通过快速傅里叶变换 (FFT) 高效计算——是在时域和频域之间转换的工具。\n\n初始信号 $x[n]$ 被构造为 $K$ 个余弦函数之和，其频率 $f_i$ 是基频 $1/N$ 的整数倍。这确保了信号在频域中的能量完全集中在对应于 $\\pm f_i$ 的 DFT 频率仓中。这个实值信号的 DFT $X[k]$ 将有 $2K$ 个非零系数，这是由于共轭对称性 $X[k] = X[N-k]^*$。这些非零频率仓的集合表示为 $\\mathcal{S}$。\n\n当样本缺失时，这通过将信号 $x[n]$ 与一个二进制掩码 $m[n]$ 相乘来建模，得到的信号是 $x_{\\mathrm{mask}}[n] = x[n] \\cdot m[n]$。根据 DFT 的卷积定理，时域中的这种乘法对应于频域中的循环卷积：$X_{\\mathrm{mask}}[k] = (X * M)[k]$，其中 $M[k]$ 是掩码的 DFT。掩码的频谱 $M[k]$ 通常不是稀疏的，并且在所有频率上都有显著的能量。卷积将 $X[k]$ 的稀疏能量扩散到整个频谱，从而产生伪影。初始伪影能量比 $r_{\\mathrm{zero}}$ 量化了这种频谱泄漏。\n\n解决方案的核心是迭代修复算法，它是迭代硬阈值 (IHT) 的一个变体。该算法利用了原始信号在频域中是稀疏的先验知识。过程如下：\n\n1.  **初始化**：算法从补零信号开始，$y^{(0)}[n] = x_{\\mathrm{mask}}[n]$。\n\n2.  **迭代**：对于每一步 $t$：\n    a.  **变换到频域**：计算当前估计的 DFT，$Y^{(t)}[k] = \\mathrm{FFT}(y^{(t)}[n])$。在此阶段，由于数据缺失，$Y^{(t)}[k]$ 通常不是稀疏的。\n    b.  **硬阈值处理**：算法通过仅保留 $K_{\\mathrm{keep}}$ 个具有最大幅值的系数并将所有其他系数置零来强制执行稀疏性假设。$K_{\\mathrm{keep}}$ 设置为 $2K$，即原始信号中已知的非零频谱分量的数量。此步骤 $\\tilde{Y}^{(t)}[k] = \\mathrm{Threshold}(Y^{(t)}[k])$ 是到频域稀疏信号集合上的投影。\n    c.  **返回时域**：对经过阈值处理的频谱应用逆 FFT，$\\tilde{y}^{(t)}[n] = \\mathrm{IFFT}(\\tilde{Y}^{(t)}[k])$。由于数值误差可能会引入一个小的虚部，我们取结果的实部。\n    d.  **强制数据一致性**：这是一个关键步骤。解决方案必须与已知的测量值一致。下一个迭代 $y^{(t+1)}[n]$ 的值通过在掩码 $m[n]$ 为 1 的位置重新插入来自 $x[n]$ 的原始已知样本来更新。对于缺失的样本（其中 $m[n]=0$），我们使用来自我们的稀疏估计 $\\tilde{y}^{(t)}[n]$ 的值。\n        $$\n        y^{(t+1)}[n] = m[n] \\cdot x[n] + (1 - m[n]) \\cdot \\tilde{y}^{(t)}[n]\n        $$\n\n3.  **终止**：重复该过程，直到解稳定（通过连续迭代之间的相对变化低于容差 $\\varepsilon = 10^{-8}$ 来衡量），或者直到达到最大迭代次数 $T_{\\max}$。\n\n最后，评估重建的质量。修复后的伪影能量比 $r_{\\mathrm{inpaint}}$ 衡量了该算法将频谱能量重新集中到真实支撑集 $\\mathcal{S}$ 中的成功程度。归一化重建误差 $e$ 测量了重建信号 $y^{(\\ast)}[n]$ 和原始信号 $x[n]$ 之间的欧几里得距离，提供了时域精度的直接度量。该实现使用 `NumPy` 进行高效的数组操作、FFT 计算和线性代数范数计算。", "answer": "```python\nimport numpy as np\n\ndef run_case(N, K, freqs, amps, p_miss, K_keep, epsilon, T_max, seed):\n    \"\"\"\n    Runs a single test case for spectral inpainting.\n    \"\"\"\n    # Step 1: Construct the synthetic signal x[n]\n    n_space = np.arange(N)\n    x = np.zeros(N, dtype=np.float64)\n    for i in range(K):\n        x += amps[i] * np.cos(2 * np.pi * freqs[i] * n_space / N)\n\n    # Step 2: Create the masked signal x_mask[n]\n    rng = np.random.default_rng(seed)\n    num_missing = int(np.round(p_miss * N))\n    if num_missing  0:\n        missing_indices = rng.choice(N, size=num_missing, replace=False)\n    else:\n        missing_indices = np.array([], dtype=int)\n        \n    m = np.ones(N)\n    m[missing_indices] = 0\n    x_mask = x * m\n\n    # Step 3: Compute artifact energy ratio before inpainting (r_zero)\n    X_mask = np.fft.fft(x_mask)\n    \n    # Define the true spectral support S\n    S = set(freqs) | set((N - f) % N for f in freqs)\n    \n    is_in_S = np.zeros(N, dtype=bool)\n    is_in_S[list(S)] = True\n    \n    total_energy_mask = np.sum(np.abs(X_mask)**2)\n    if total_energy_mask == 0:\n        r_zero = 0.0\n    else:\n        artifact_energy_mask = np.sum(np.abs(X_mask[~is_in_S])**2)\n        r_zero = artifact_energy_mask / total_energy_mask\n\n    # Step 4: Perform spectral inpainting via iterative FFT thresholding\n    y_current = x_mask.copy()\n    y_rec = y_current\n    \n    for _ in range(T_max):\n        Y_current = np.fft.fft(y_current)\n        \n        # Hard-threshold in the frequency domain\n        largest_indices = np.argsort(np.abs(Y_current))[-K_keep:]\n        Y_tilde = np.zeros_like(Y_current, dtype=complex)\n        Y_tilde[largest_indices] = Y_current[largest_indices]\n        \n        # Inverse transform and take real part\n        y_tilde_real = np.real(np.fft.ifft(Y_tilde))\n        \n        # Create next iterate\n        y_next = y_tilde_real.copy()\n        # Enforce data consistency on observed samples\n        y_next[m == 1] = x[m == 1]\n        \n        # Check for convergence\n        norm_y_current = np.linalg.norm(y_current)\n        if norm_y_current  0:\n            relative_change = np.linalg.norm(y_next - y_current) / norm_y_current\n            if relative_change  epsilon:\n                y_rec = y_next\n                break\n        elif np.linalg.norm(y_next) == 0: # y_current is zero, check if y_next is also zero\n            y_rec = y_next\n            break\n        \n        y_current = y_next\n    else: # Loop finished without break\n        y_rec = y_current\n\n    # Step 5: Compute metrics for the inpainted signal (r_inpaint, e)\n    X_rec = np.fft.fft(y_rec)\n    \n    total_energy_rec = np.sum(np.abs(X_rec)**2)\n    if total_energy_rec == 0:\n        r_inpaint = 0.0\n    else:\n        artifact_energy_rec = np.sum(np.abs(X_rec[~is_in_S])**2)\n        r_inpaint = artifact_energy_rec / total_energy_rec\n        \n    norm_x = np.linalg.norm(x)\n    if norm_x == 0:\n        e = 0.0 if np.linalg.norm(y_rec) == 0 else np.inf\n    else:\n        e = np.linalg.norm(y_rec - x) / norm_x\n        \n    return [r_zero, r_inpaint, e]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N': 1024, 'K': 3, 'freqs': [50, 123, 300], 'amps': [1.0, 0.8, 0.6], 'p_miss': 0.2, 'K_keep': 6, 'epsilon': 1e-8, 'T_max': 200, 'seed': 1},\n        {'N': 1024, 'K': 3, 'freqs': [50, 123, 300], 'amps': [1.0, 0.8, 0.6], 'p_miss': 0.0, 'K_keep': 6, 'epsilon': 1e-8, 'T_max': 200, 'seed': 2},\n        {'N': 2048, 'K': 5, 'freqs': [15, 77, 221, 400, 650], 'amps': [1.0, 0.5, 0.7, 0.9, 0.4], 'p_miss': 0.5, 'K_keep': 10, 'epsilon': 1e-8, 'T_max': 300, 'seed': 3},\n        {'N': 512, 'K': 1, 'freqs': [64], 'amps': [1.0], 'p_miss': 0.7, 'K_keep': 2, 'epsilon': 1e-8, 'T_max': 300, 'seed': 42},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(\n            N=case['N'],\n            K=case['K'],\n            freqs=case['freqs'],\n            amps=case['amps'],\n            p_miss=case['p_miss'],\n            K_keep=case['K_keep'],\n            epsilon=case['epsilon'],\n            T_max=case['T_max'],\n            seed=case['seed']\n        )\n        results.append(result)\n\n    # Format the final output string as specified.\n    inner_strs = []\n    for res_list in results:\n        formatted_nums = [f'{v:.6f}' for v in res_list]\n        inner_strs.append(f\"[{','.join(formatted_nums)}]\")\n    \n    final_output = f\"[{','.join(inner_strs)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3195883"}]}