{"hands_on_practices": [{"introduction": "在现实世界的工程问题中，材料很少是完全均匀的。有限元方法的一个核心优势在于它能够通过逐个单元积分来自然地处理由不同材料组成的非均质区域。本练习将引导你解决一个包含材料界面的一维问题，并直接比较“界面感知”和“界面忽略”两种组装策略的准确性，从而深刻理解在不连续处进行精确数值积分的重要性。[@problem-id:3129650]", "problem": "考虑区间 $[0,1]$ 上的一个一维边值问题，其具有非均匀材料属性，由偏微分方程 $- \\dfrac{d}{dx}\\big(k(x)\\,u'(x)\\big) = f(x)$ 描述，并服从狄利克雷边界条件 $u(0) = 0$ 和 $u(1) = 0$。假设导热系数 $k(x)$ 是分段常数，在界面位置 $\\xi \\in (0,1)$ 处有一个跳跃间断点，具体由下式给出：\n$$\nk(x) = \\begin{cases}\nk_1, & x  \\xi, \\\\\nk_2,  x \\ge \\xi,\n\\end{cases}\n$$\n并且右端项为常数 $f(x) = 1$。\n\n从问题的变分形式出发（即乘以一个测试函数 $v(x)$ 并进行分部积分），使用 Sobolev 空间 $H_0^1([0,1])$ 推导弱形式中的双线性形式和线性泛函。在一个具有 $N$ 个单元的均匀网格上，使用标准的分段线性（帽）函数来构建伽辽金近似。在对齐情况下，即 $\\xi$ 与一个网格节点重合时，单元积分 $\\int k(x)\\,dx$ 简化为 $k_e\\,h$，其中 $k_e$ 在该单元上为常数，$h$ 为单元长度。在未对齐情况下，即界面完全位于一个单元内部时，实现两种组装策略：\n- 一种界面感知策略，它通过在 $x=\\xi$ 处分割单元，并对具有 $k_1$ 和 $k_2$ 的子段上的贡献求和，来精确计算单元积分 $\\int k(x)\\,dx$。\n- 一种界面非感知策略，它使用中点求积法则来近似单元积分，即 $\\int k(x)\\,dx \\approx k(x_m)\\,h$，其中 $x_m$ 是单元中点，因此不在单元内部强制施加界面条件。\n\n从基本原理出发，证明界面条件，即 $u(x)$ 的连续性和在 $x=\\xi$ 处通量 $k(x)\\,u'(x)$ 的连续性，可以从弱形式中自然地导出。利用这些原理，实现一个有限元法（FEM; Finite Element Method）求解器，该求解器能够：\n1. 根据从 $\\int k(x)\\,dx$ 和基函数的导数推导出的单元矩阵，组装全局刚度矩阵。\n2. 对每个基函数 $N_i(x)$，使用 $\\int f(x)\\,N_i(x)\\,dx$ 组装全局载荷向量。\n3. 在 $x=0$ 和 $x=1$ 处施加狄利克雷边界条件。\n\n为了进行验证，通过求解常微分方程 $u''(x) = -\\dfrac{1}{k_1}$（在 $[0,\\xi)$ 上）和 $u''(x) = -\\dfrac{1}{k_2}$（在 $[\\xi,1]$ 上），并应用 $u(0)=0$、$u(1)=0$ 以及界面条件 $u(\\xi^-)=u(\\xi^+)$ 和 $k_1\\,u'(\\xi^-)=k_2\\,u'(\\xi^+)$，推导出当 $f(x)=1$ 且 $k(x)$ 为分段常数时的精确解 $u(x)$。使用这个精确解，通过足够精确的数值积分计算有限元近似解与精确解之间误差的 $L^2$ 范数：\n$$\n\\|u - u_h\\|_{L^2(0,1)} = \\left( \\int_0^1 \\big(u(x) - u_h(x)\\big)^2\\,dx \\right)^{1/2},\n$$\n\n您的程序必须对以下测试套件评估 $L^2$ 误差，该套件探讨了对齐与未对齐网格以及界面感知与非感知策略，包括一个 $k(x)$ 具有高对比度的边缘案例和一个界面非常接近网格节点的案例：\n- 测试 1：$N=20$，$\\xi=0.5$，$k_1=1$，$k_2=5$，界面感知组装 $\\text{True}$。\n- 测试 2：$N=20$，$\\xi=0.47$，$k_1=1$，$k_2=5$，界面感知组装 $\\text{True}$。\n- 测试 3：$N=20$，$\\xi=0.47$，$k_1=1$，$k_2=5$，界面感知组装 $\\text{False}$。\n- 测试 4：$N=40$，$\\xi=0.3$，$k_1=0.01$，$k_2=100$，界面感知组装 $\\text{False}$。\n- 测试 5：$N=40$，$\\xi=0.025$，$k_1=2$，$k_2=3$，界面感知组装 $\\text{True}$。\n\n所有量均为无量纲。您的程序应生成单行输出，其中包含五个测试用例的 $L^2$ 误差，格式为一个由逗号分隔的浮点数列表，四舍五入到六位小数，并用方括号括起来，即格式为 $[e_1,e_2,e_3,e_4,e_5]$，其中每个 $e_i$ 是一个浮点数。", "solution": "用户提供的问题已经过验证，被确定为计算科学领域中一个适定、有科学依据且客观的问题。所有必要的数据和条件均已提供，不存在矛盾或歧义。\n\n### 1. 弱形式\n边值问题的强形式由下式给出：\n$$\n- \\frac{d}{dx}\\left(k(x) \\frac{du}{dx}\\right) = f(x), \\quad x \\in (0,1)\n$$\n并带有狄利克雷边界条件 $u(0) = 0$ 和 $u(1) = 0$。解 $u(x)$ 和测试函数 $v(x)$ 在 Sobolev 空间 $H_0^1([0,1])$ 中寻求，该空间由满足齐次边界条件、函数本身平方可积且其弱导数也平方可积的函数组成。\n\n为推导弱形式，我们将偏微分方程乘以一个测试函数 $v \\in H_0^1([0,1])$，并在定义域 $[0,1]$ 上积分：\n$$\n-\\int_0^1 \\frac{d}{dx}\\left(k(x) u'(x)\\right) v(x) \\, dx = \\int_0^1 f(x) v(x) \\, dx\n$$\n其中 $u'(x) = \\frac{du}{dx}$。我们对左侧项应用分部积分：\n$$\n\\int_0^1 k(x) u'(x) v'(x) \\, dx - \\left[ k(x) u'(x) v(x) \\right]_0^1 = \\int_0^1 f(x) v(x) \\, dx\n$$\n由于测试函数 $v \\in H_0^1([0,1])$，我们有 $v(0) = v(1) = 0$，这使得边界项消失。最终的弱形式为：求 $u \\in H_0^1([0,1])$，使得\n$$\na(u,v) = L(v) \\quad \\forall v \\in H_0^1([0,1])\n$$\n其中双线性形式 $a(u,v)$ 和线性泛函 $L(v)$ 定义为：\n$$\na(u,v) = \\int_0^1 k(x) u'(x) v'(x) \\, dx\n$$\n$$\nL(v) = \\int_0^1 f(x) v(x) \\, dx\n$$\n\n### 2. 界面条件\n弱形式自然地包含了物理界面条件。如果我们假设解 $u$ 在子域 $[0, \\xi)$ 和 $(\\xi, 1]$ 上是二次可微的，并且我们分别在这些子域上进行分部积分，我们得到：\n$$\n\\int_0^\\xi k_1 u' v' dx - [k_1 u' v]_0^{\\xi^-} + \\int_\\xi^1 k_2 u' v' dx - [k_2 u' v]_{\\xi^+}^1 = \\int_0^1 f v dx\n$$\n使用 $v(0)=v(1)=0$，上式简化为：\n$$\n\\int_0^1 k u' v' dx + [k_2 u'(\\xi^+) - k_1 u'(\\xi^-)] v(\\xi) = \\int_0^1 f v dx\n$$\n将此与弱形式进行比较，我们发现，要使二者对于每一个 $v \\in H_0^1([0,1])$ 都等价，$[k_2 u'(\\xi^+) - k_1 u'(\\xi^-)] v(\\xi)$ 项必须为零。由于我们可以选择一个使 $v(\\xi) \\neq 0$ 的测试函数 $v$，因此必须有 $k_1 u'(\\xi^-) = k_2 u'(\\xi^+)$。这就是通量连续性条件，它是作为自然边界条件从弱形式中产生的。解的连续性 $u(\\xi^-) = u(\\xi^+)$ 是一个本质条件，通过在空间 $H^1([0,1])$ 中寻求解答 $u$ 来强制施加。\n\n### 3. 有限元离散化\n我们将域 $[0,1]$ 离散为 $N$ 个长度为 $h = 1/N$ 的均匀单元。节点为 $x_i = i h$，其中 $i=0, 1, \\dots, N$。有限元解 $u_h(x)$ 被近似为分段线性基（帽）函数 $N_j(x)$ 的线性组合：\n$$\nu_h(x) = \\sum_{j=0}^{N} U_j N_j(x)\n$$\n其中 $U_j$ 是未知的节点值。边界条件 $u(0)=0$ 和 $u(1)=0$ 意味着 $U_0 = 0$ 和 $U_N = 0$，因此求和实际上是对 $N-1$ 个内部节点进行的。\n\n将 $u_h(x)$ 代入弱形式，并选择测试函数为基函数本身（即 $v(x) = N_i(x)$，对于 $i=1, \\dots, N-1$），我们得到伽辽金线性方程组 $K \\mathbf{U} = \\mathbf{F}$：\n$$\n\\sum_{j=1}^{N-1} U_j \\underbrace{\\left( \\int_0^1 k(x) N'_j(x) N'_i(x) \\, dx \\right)}_{K_{ij}} = \\underbrace{\\int_0^1 f(x) N_i(x) \\, dx}_{F_i}\n$$\n其中 $\\mathbf{U}$ 是未知节点值的向量 $[U_1, \\dots, U_{N-1}]^T$。\n\n### 4. 系统组装\n刚度矩阵 $K$ 和载荷向量 $\\mathbf{F}$ 由单元贡献组装而成。对于一个跨越 $[x_e, x_{e+1}]$ 的单元 $e$，局部基函数的导数为 $\\pm 1/h$。$2 \\times 2$ 的单元刚度矩阵 $K^e$ 为：\n$$\nK^e = \\frac{1}{h^2} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} \\int_{x_e}^{x_{e+1}} k(x) \\, dx\n$$\n关键项是导热系数的积分，$I_e = \\int_{x_e}^{x_{e+1}} k(x) \\, dx$。\n- **界面感知策略**：$I_e$ 被精确计算。如果界面 $\\xi$ 位于 $(x_e, x_{e+1})$ 内，积分被分割：$I_e = \\int_{x_e}^{\\xi} k_1 dx + \\int_{\\xi}^{x_{e+1}} k_2 dx = k_1(\\xi-x_e) + k_2(x_{e+1}-\\xi)$。否则，$I_e$ 为 $k_1 h$ 或 $k_2 h$。\n- **界面非感知策略**：$I_e$ 使用中点法则近似：$I_e \\approx k(x_m)h$，其中 $x_m = (x_e+x_{e+1})/2$。这会根据单元中点的值为整个单元分配一个单一的导热系数值，忽略了任何子单元内的变化。\n\n对于载荷向量，当 $f(x)=1$ 时，内部节点 $i$ 对应的项为 $F_i = \\int_0^1 N_i(x) dx$。一个帽函数在其支集上的积分即为其面积，即 $\\frac{1}{2} \\times \\text{底} \\times \\text{高} = \\frac{1}{2} \\times 2h \\times 1 = h$。因此，对所有内部节点，$F_i = h$。\n\n组装后，求解 $(N-1) \\times (N-1)$ 的三对角系统 $K \\mathbf{U} = \\mathbf{F}$ 以得到节点值 $\\mathbf{U}$。\n\n### 5. 精确解\n对于分段常数 $k(x)$ 和常数强迫项 $f(x)=1$，常微分方程为 $u_1''(x) = -1/k_1$（对于 $x \\in [0, \\xi)$）和 $u_2''(x) = -1/k_2$（对于 $x \\in [\\xi, 1]$）。二次积分得到：\n$$\nu_1(x) = -\\frac{x^2}{2k_1} + C_1 x + D_1\n$$\n$$\nu_2(x) = -\\frac{x^2}{2k_2} + C_2 x + D_2\n$$\n应用四个条件（$u(0)=0$，$u(1)=0$，$u(\\xi^-)=u(\\xi^+)$，$k_1 u'(\\xi^-)=k_2 u'(\\xi^+)$）可以确定四个积分常数 $C_1, C_2, D_1, D_2$。解为：\n$$\nu(x) = \\begin{cases}\n-\\dfrac{x^2}{2k_1} + C_1 x,  x  \\xi \\\\\n-\\dfrac{x^2}{2k_2} + C_2 x + D_2,  x \\ge \\xi\n\\end{cases}\n$$\n其中 $D_1=0$ 且\n$$\nC_1 = \\frac{k_1(1-\\xi^2) + k_2 \\xi^2}{2k_1(k_1(1-\\xi) + k_2 \\xi)}, \\quad C_2 = \\frac{k_1(1-\\xi^2) + k_2 \\xi^2}{2k_2(k_1(1-\\xi) + k_2 \\xi)}, \\quad D_2 = \\frac{(\\xi^2-\\xi)(k_1-k_2)}{2k_2(k_1(1-\\xi) + k_2 \\xi)}\n$$\n\n### 6. 误差计算\n有限元解 $u_h(x)$ 的精度通过误差的 $L^2$ 范数 $\\|u - u_h\\|_{L^2(0,1)}$ 来衡量：\n$$\n\\|u - u_h\\|_{L^2(0,1)} = \\left( \\int_0^1 \\big(u(x) - u_h(x)\\big)^2\\,dx \\right)^{1/2}\n$$\n该积分使用高阶求积法则进行数值计算。此处，在一个包含 $10000$ 个点的精细网格上应用梯形法则，以确保求积误差与有限元离散误差相比可以忽略不计。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # N, xi, k1, k2, is_aware\n        (20, 0.5, 1, 5, True),\n        (20, 0.47, 1, 5, True),\n        (20, 0.47, 1, 5, False),\n        (40, 0.3, 0.01, 100, False),\n        (40, 0.025, 2, 3, True),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_fem_bvp(*case)\n        results.append(error)\n\n    # Format the output as specified\n    formatted_results = [\"{:.6f}\".format(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef solve_fem_bvp(N, xi, k1, k2, is_aware):\n    \"\"\"\n    Solves the 1D BVP using FEM for a given set of parameters.\n\n    Args:\n        N (int): Number of elements.\n        xi (float): Interface location.\n        k1 (float): Conductivity for x  xi.\n        k2 (float): Conductivity for x >= xi.\n        is_aware (bool): Flag for interface-aware assembly strategy.\n\n    Returns:\n        float: The L2 norm of the error.\n    \"\"\"\n    h = 1.0 / N\n    nodes = np.linspace(0, 1, N + 1)\n    num_dof = N - 1\n\n    # 1. Assemble Stiffness Matrix K and Load Vector F\n    K = np.zeros((num_dof, num_dof))\n    F = np.full(num_dof, h)\n\n    # Pre-calculate all element integrals of k(x), denoted I_e\n    I_e = np.zeros(N)\n    for e in range(N):\n        x_e = nodes[e]\n        x_e_plus_1 = nodes[e+1]\n\n        if is_aware:\n            # Interface-aware assembly (exact integral)\n            if xi = x_e:\n                I_e[e] = k2 * h\n            elif xi > x_e_plus_1:\n                I_e[e] = k1 * h\n            else:  # Interface is inside the element\n                I_e[e] = k1 * (xi - x_e) + k2 * (x_e_plus_1 - xi)\n        else:\n            # Interface-unaware assembly (midpoint rule)\n            x_m = (x_e + x_e_plus_1) / 2.0\n            k_mid = k1 if x_m  xi else k2\n            I_e[e] = k_mid * h\n\n    # Assemble K for interior nodes (DoFs 1 to N-1)\n    for i in range(num_dof):  # Matrix index i from 0 to N-2\n        # Diagonal entry K[i, i] corresponds to node i+1\n        # Contribution from element i and element i+1\n        K[i, i] = (I_e[i] + I_e[i+1]) / (h ** 2)\n        # Off-diagonal entries\n        if i > 0:\n            K[i, i - 1] = -I_e[i] / (h ** 2)\n        if i  num_dof - 1:\n            K[i, i + 1] = -I_e[i+1] / (h ** 2)\n\n    # 2. Solve the linear system for interior node values\n    U_interior = np.linalg.solve(K, F)\n\n    # Reconstruct full solution vector including boundary conditions\n    U_full = np.zeros(N + 1)\n    U_full[1:N] = U_interior\n\n    # 3. Calculate L2 error\n    # Define exact solution function\n    def get_exact_solution(xi_p, k1_p, k2_p):\n        A = k1_p * (1 - xi_p) + k2_p * xi_p\n        if np.isclose(A, 0): # Should not happen with positive k values\n            return lambda x: 0.0\n\n        C1_num = k1_p * (1 - xi_p**2) + k2_p * xi_p**2\n        C1 = C1_num / (2 * k1_p * A)\n        C2 = C1_num / (2 * k2_p * A)\n        D2 = ((xi_p**2 - xi_p) * (k1_p - k2_p)) / (2 * k2_p * A)\n\n        def u_exact(x):\n            if x  xi_p:\n                return -x**2 / (2 * k1_p) + C1 * x\n            else:\n                return -x**2 / (2 * k2_p) + C2 * x + D2\n        return u_exact\n\n    u_exact_func = get_exact_solution(xi, k1, k2)\n\n    # Define FEM solution function\n    def u_h(x, nodes_h, U_sol, h_val):\n        if x = 0.0: return 0.0\n        if x >= 1.0: return 0.0\n        \n        i = int(np.floor(x / h_val))\n        x_i = nodes_h[i]\n        # Linear interpolation within element i\n        val = U_sol[i] * (nodes_h[i+1] - x) / h_val + U_sol[i+1] * (x - x_i) / h_val\n        return val\n\n    # Numerical integration for L2 norm using a fine grid\n    num_quad_points = 10000\n    quad_points = np.linspace(0, 1, num_quad_points + 1)\n    \n    # Vectorized evaluation over the fine grid\n    exact_vals = np.array([u_exact_func(x) for x in quad_points])\n    fem_vals = np.array([u_h(x, nodes, U_full, h) for x in quad_points])\n\n    squared_errors = (exact_vals - fem_vals)**2\n    \n    # Trapezoidal rule for integration\n    integral = np.trapz(squared_errors, quad_points)\n\n    l2_error = np.sqrt(integral)\n    \n    return l2_error\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3129650"}, {"introduction": "物理系统通过其边界与周围环境相互作用。本练习将探讨如何使用 Robin 边界条件来模拟更复杂的边界现象，例如对流冷却。你将学习如何从偏微分方程的强形式出发，推导出包含边界积分项的弱形式，并观察这些“自然”边界条件如何优雅地融入有限元框架中。[@problem_id:3129727]", "problem": "考虑区间 $[0,1]$ 上的一个一维稳态扩散模型，该模型具有恒定的传导系数 $k$ 和空间均匀的源 $f(x)$，由守恒定律 $-\\dfrac{d}{dx}\\!\\left(k \\dfrac{du}{dx}\\right) = f(x)$ 控制。在左端点 $x=0$ 施加一个 Dirichlet 边界条件，在右端点 $x=1$ 施加一个模拟对流冷却的 Robin 边界条件 (RBC)，表示为 $k \\nabla u \\cdot n + \\alpha u = g$，其中 $n$ 是 $x=1$ 处的外法线。在一维情况下，当 $x=1$ 处的外法线 $n=+1$ 时，该条件简化为 $k \\dfrac{du}{dx}(1) + \\alpha u(1) = g$。对于对流冷却至环境水平 $u_{\\infty}$ 的情况，通常设置 $g = \\alpha u_{\\infty}$，等价于 $k \\dfrac{du}{dx}(1) + \\alpha \\big(u(1) - u_{\\infty}\\big) = 0$。所有量均为无量纲。\n\n从守恒定律 $-\\dfrac{d}{dx}\\!\\left(k \\dfrac{du}{dx}\\right) = f(x)$ 和边界条件出发，通过虚功原理推导弱形式：将方程乘以一个合适的检验函数，在 $[0,1]$ 上积分，并应用分部积分以暴露代表 Robin 边界条件的边界积分。然后，在一个具有 $N$ 个单元的均匀网格上，使用分段线性基函数设计一个协调的 Galerkin 有限元方法，并通过边界积分项弱施加 Robin 边界条件。组装与此弱施加一致的全局线性系统，在 $x=0$ 处强制施加 Dirichlet 边界条件，并求解所得系统以获得 $u$ 的节点近似值。\n\n模型使用以下固定参数：\n- 区间长度 $L = 1$，\n- 均匀单元数量 $N = 40$（因此网格尺寸为 $h = L/N$），\n- 恒定传导系数 $k = 2$，\n- 均匀源 $f(x) \\equiv 1$，\n- $x=0$ 处的 Dirichlet 边界数据：$u(0) = U_0$，其中 $U_0 = 2$，\n- $x=1$ 处的环境水平 $u_{\\infty} = 1$，\n- Robin 系数 $\\alpha$ 在一个测试套件中变化，以模拟不同的对流冷却强度。\n\n测试套件：\n- 情况 1：$\\alpha = 0.0$（当 $g=\\alpha u_{\\infty}=0$ 时的纯 Neumann 极限），\n- 情况 2：$\\alpha = 0.5$，\n- 情况 3：$\\alpha = 5.0$，\n- 情况 4：$\\alpha = 100.0$（接近于固定到环境值的类 Dirichlet 条件）。\n\n对于每种情况，设置 $g = \\alpha u_{\\infty}$ 并计算有限元解。提取并报告每种情况下右端点温度 $u(1)$ 的值（即网格中 $x=1$ 处的节点值）。\n\n最终输出规格：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按测试套件的顺序 $\\big[\\alpha=\\text{情况 }1, \\alpha=\\text{情况 }2, \\alpha=\\text{情况 }3, \\alpha=\\text{情况 }4\\big]$ 排列。例如，一个可接受的格式是 $[u_1,u_2,u_3,u_4]$，其中每个 $u_i$ 是对应 $\\alpha$ 情况下计算出的右端点值 $u(1)$。\n- 所有量均为无量纲，因此输出中不需要物理单位。\n- 每个报告的量必须是实数（浮点数）。", "solution": "该问题是有效的。这是一个源于数学物理领域的适定的边界值问题，基于稳态扩散的标准理论。所有参数和条件都已完全指定，科学上合理，且没有矛盾或歧义。\n\n### 1. 弱形式\n\n控制偏微分方程 (PDE) 或强形式，是定义在域 $\\Omega = [0,1]$ 上的一维稳态扩散方程：\n$$-\\dfrac{d}{dx}\\!\\left(k \\dfrac{du}{dx}\\right) = f(x) \\quad \\text{for } x \\in (0,1)$$\n边界条件是：\n1.  $x=0$ 处的 Dirichlet 条件：$u(0) = U_0$。\n2.  $x=1$ 处的 Robin 条件：$k \\dfrac{du}{dx}(1) + \\alpha u(1) = g$。\n\n为推导弱形式，我们遵循虚功原理。我们将偏微分方程乘以一个任意的检验函数 $v(x)$，并在域 $\\Omega$ 上积分。检验函数 $v$ 属于求解空间，但带有齐次的本质（Dirichlet）边界条件。在这里，该空间为 $V = \\{ v \\in H^1(0,1) \\mid v(0)=0 \\}$，其中 $H^1(0,1)$ 是具有平方可积一阶导数的函数的 Sobolev 空间。\n\n$$-\\int_0^1 \\dfrac{d}{dx}\\!\\left(k \\dfrac{du}{dx}\\right) v(x) \\, dx = \\int_0^1 f(x) v(x) \\, dx$$\n\n我们对左侧项应用分部积分，以降低试探函数 $u$ 的导数阶数，并将一个导数转移到检验函数 $v$ 上：\n$$\\int_0^1 k \\dfrac{du}{dx} \\dfrac{dv}{dx} \\, dx - \\left[ k \\dfrac{du}{dx} v(x) \\right]_0^1 = \\int_0^1 f(x) v(x) \\, dx$$\n\n接下来，我们计算边界项 $\\left[ k \\frac{du}{dx} v \\right]_0^1 = k \\frac{du}{dx}(1) v(1) - k \\frac{du}{dx}(0) v(0)$。因为检验函数 $v$ 必须满足齐次 Dirichlet 条件 $v(0)=0$，所以 $x=0$ 处的项消失。剩下：\n$$\\int_0^1 k \\dfrac{du}{dx} \\dfrac{dv}{dx} \\, dx - k \\dfrac{du}{dx}(1) v(1) = \\int_0^1 f(x) v(x) \\, dx$$\n\n这就是 Robin 边界条件被自然地引入的地方。该条件是 $k \\frac{du}{dx}(1) = g - \\alpha u(1)$。将通量项 $k \\frac{du}{dx}(1)$ 的这个表达式代入我们的方程，得到：\n$$\\int_0^1 k \\dfrac{du}{dx} \\dfrac{dv}{dx} \\, dx - (g - \\alpha u(1)) v(1) = \\int_0^1 f(x) v(x) \\, dx$$\n\n将所有包含未知解 $u$ 的表达式移到左侧（LHS），所有其他项移到右侧（RHS），我们得到弱形式：寻找 $u(x)$ 使得 $u(0) = U_0$ 且对于所有检验函数 $v \\in V$：\n$$\\int_0^1 k \\dfrac{du}{dx} \\dfrac{dv}{dx} \\, dx + \\alpha u(1) v(1) = \\int_0^1 f(x) v(x) \\, dx + g v(1)$$\n\n这是标准形式 $a(u,v) = L(v)$，其中：\n-   双线性形式为 $a(u,v) = \\int_0^1 k u'v' \\, dx + \\alpha u(1)v(1)$。\n-   线性泛函为 $L(v) = \\int_0^1 fv \\, dx + gv(1)$。\n\n### 2. Galerkin 有限元离散化\n\n我们将域 $[0,1]$ 离散化为 $N$ 个长度为 $h = 1/N$ 的均匀单元。这创建了 $N+1$ 个位于 $x_i = i h$（$i=0, 1, \\dots, N$）的节点。我们将解 $u(x)$ 近似为分段线性基函数 $\\phi_j(x)$ 的线性组合：\n$$u_h(x) = \\sum_{j=0}^{N} U_j \\phi_j(x)$$\n其中 $U_j$ 是未知的节点值，$U_j \\approx u(x_j)$，而 $\\phi_j(x)$ 是“帽子”函数，它在节点 $x_j$ 处等于 $1$，在所有其他节点 $x_i$（$i \\neq j$）处等于 $0$。\n\nGalerkin 方法使用基函数本身作为检验函数，即 $v(x) = \\phi_i(x)$，其中 $i=0, 1, \\dots, N$。将近似解 $u_h(x)$ 和检验函数 $v(x) = \\phi_i(x)$ 代入弱形式，得到一个包含 $N+1$ 个线性代数方程的系统：\n$$\\sum_{j=0}^{N} U_j \\left( \\int_0^1 k \\phi_j'(x) \\phi_i'(x) \\,dx + \\alpha \\phi_j(1) \\phi_i(1) \\right) = \\int_0^1 f(x) \\phi_i(x) \\, dx + g \\phi_i(1)$$\n这可以写成矩阵形式 $\\mathbf{K} \\mathbf{U} = \\mathbf{F}$，其中 $\\mathbf{U} = [U_0, U_1, \\dots, U_N]^T$ 是节点未知量向量。全局刚度矩阵 $\\mathbf{K}$ 和力向量 $\\mathbf{F}$ 的项为：\n$$K_{ij} = a(\\phi_j, \\phi_i) = \\int_0^1 k \\phi_j' \\phi_i' \\,dx + \\alpha \\phi_j(1) \\phi_i(1)$$\n$$F_i = L(\\phi_i) = \\int_0^1 f \\phi_i \\, dx + g \\phi_i(1)$$\n\n### 3. 系统组装和边界条件\n\n全局系统通过对每个单元的贡献求和来组装。对于一个跨越 $[x_{e-1}, x_e]$、长度为 $h$ 的通用单元 $e$，在 $k$ 和 $f$ 为常数的情况下，其单元刚度矩阵 $\\mathbf{k}^e$ 和单元力向量 $\\mathbf{f}^e$ 为：\n$$\\mathbf{k}^e = \\frac{k}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}, \\quad \\mathbf{f}^e = \\frac{fh}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$$\n\n**组装：** 全局矩阵 $\\mathbf{K}$ 和向量 $\\mathbf{F}$ 初始为零。对于每个单元，$\\mathbf{k}^e$ 和 $\\mathbf{f}^e$ 被加到相应的全局项上。组装后，$\\mathbf{K}$ 是一个三对角矩阵，$\\mathbf{F}$ 由单元贡献构成。\n\n**Robin 边界条件：** $x=1$ 处的 Robin 条件影响涉及 $u(1)$ 和 $v(1)$ 的项。由于 $\\phi_j(1) = \\delta_{jN}$ 和 $\\phi_i(1) = \\delta_{iN}$，边界项的贡献仅在 $i=N$ 且 $j=N$ 时非零。\n-   项 $\\alpha \\phi_j(1) \\phi_i(1)$ 将 $\\alpha$ 加到矩阵项 $K_{N,N}$ 上。\n-   项 $g \\phi_i(1)$ 将 $g$ 加到向量项 $F_N$ 上。\n-   当 $g = \\alpha u_\\infty$ 时，在应用 Dirichlet 条件之前的最终系统具有 $K_{N,N} = k/h + \\alpha$ 和 $F_N = fh/2 + \\alpha u_\\infty$。\n\n**Dirichlet 边界条件：** 条件 $u(0) = U_0$ 固定了 $U_0$ 的值。这是一个本质边界条件。我们通过对系统进行分区来强制施加它。第一个节点 $U_0$ 的方程被移除，其已知值被代入剩余的方程中。未知量是 $U_1, \\dots, U_N$。完整系统的第 $i$ 个方程（对于 $i \\in \\{1, \\dots, N\\}$）是 $\\sum_{j=0}^{N} K_{ij} U_j = F_i$。这可以重写为：\n$$K_{i0} U_0 + \\sum_{j=1}^{N} K_{ij} U_j = F_i \\implies \\sum_{j=1}^{N} K_{ij} U_j = F_i - K_{i0} U_0$$\n由于基函数 $\\phi_0$ 仅与 $\\phi_1$ 重叠，项 $K_{i0}$ 仅在 $i=1$ 时非零。因此，只有简化系统（对应于节点 $U_1$）的第一个方程的右侧被修改。\n我们求解简化的 $N \\times N$ 系统 $\\mathbf{A} \\mathbf{U}_{\\text{unknown}} = \\mathbf{b}$，其中：\n-   $\\mathbf{U}_{\\text{unknown}} = [U_1, \\dots, U_N]^T$。\n-   $\\mathbf{A}$ 是 $\\mathbf{K}$ 中对应于索引 $1, \\dots, N$ 的子矩阵。\n-   $\\mathbf{b}$ 是 $\\mathbf{F}$ 中对应于索引 $1, \\dots, N$ 的子向量，其第一个元素被修改为：$b_0 = F_1 - K_{1,0} U_0$。\n\n### 4. 数值实现\n提供的参数是 $L=1$，$N=40$，$k=2$，$f=1$，$U_0=2$ 和 $u_\\infty=1$。网格尺寸为 $h=1/40$。程序将如上所述构建矩阵和向量，对测试套件中的每个 $\\alpha$ 值求解线性系统，并提取右端点处的解的值 $U_N = U_{40}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a 1D steady diffusion problem using the Finite Element Method.\n\n    The problem is -d/dx(k * du/dx) = f on [0,1] with u(0)=U0\n    and a Robin condition k*du/dx(1) + alpha*u(1) = g at x=1.\n    \"\"\"\n    #\n    # 1. Define model parameters and test cases\n    #\n    L = 1.0        # Length of the domain\n    N = 40         # Number of elements\n    k = 2.0        # Thermal conductivity\n    f = 1.0        # Uniform source term\n    U0 = 2.0       # Dirichlet BC value at x=0\n    u_inf = 1.0    # Ambient level for Robin BC\n    \n    alpha_cases = [0.0, 0.5, 5.0, 100.0]\n\n    #\n    # 2. Derived parameters for FEM\n    #\n    h = L / N                  # Element size\n    num_nodes = N + 1          # Total number of nodes\n    \n    results = []\n\n    for alpha in alpha_cases:\n        #\n        # 3. Assemble the global stiffness matrix K and force vector F\n        #\n        K = np.zeros((num_nodes, num_nodes))\n        F = np.zeros(num_nodes)\n\n        # Element-level matrices\n        k_e = (k / h) * np.array([[1, -1], [-1, 1]])\n        f_e = (f * h / 2) * np.array([1, 1])\n\n        # Loop over elements to assemble global system\n        for i in range(N):\n            # Global indices for the two nodes of element i\n            node1_idx, node2_idx = i, i + 1\n            \n            # Add element stiffness contribution to global matrix\n            K[node1_idx:node2_idx+1, node1_idx:node2_idx+1] += k_e\n            \n            # Add element force contribution to global vector\n            F[node1_idx:node2_idx+1] += f_e\n\n        #\n        # 4. Apply boundary conditions\n        #\n\n        # 4.1 Apply Robin boundary condition at x=1 (node N)\n        # The weak form naturally adds terms to the last equation.\n        # a(u,v) term: alpha * u(1) * v(1) -- adds alpha to K[N,N]\n        # L(v) term: g * v(1) -- adds g to F[N]\n        g = alpha * u_inf\n        K[N, N] += alpha\n        F[N] += g\n\n        # 4.2 Apply Dirichlet boundary condition at x=0 (node 0)\n        # We partition the system to solve only for the unknown nodal values U_1, ..., U_N.\n        # The system for these N unknowns is A * U_unknown = b.\n        \n        # A is the submatrix of K corresponding to the unknown nodes (1 to N)\n        A = K[1:, 1:]\n        \n        # b is the corresponding subvector of F, modified by the known U0.\n        # The full equation for node 1 is K[1,0]*U0 + K[1,1]*U1 + ... = F[1]\n        # So, the modified RHS for the U1 equation is F[1] - K[1,0]*U0\n        b = F[1:]\n        b[0] -= K[1, 0] * U0\n        \n        #\n        # 5. Solve the linear system\n        #\n        U_unknown = np.linalg.solve(A, b)\n        \n        # The desired result is the value at the right endpoint, u(1),\n        # which corresponds to the last element of the solution vector.\n        u_at_1 = U_unknown[-1]\n        results.append(u_at_1)\n\n    #\n    # 6. Format and print the final output\n    #\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3129727"}, {"introduction": "真实世界的物体通常具有弯曲的表面，而非简单的直线和平面。这个练习将带你探索有限元方法中的一个基本概念：如何表示这些弯曲的几何形状，以及在计算精度和模型简化之间做出的权衡。通过直接计算和比较弯曲边界与直线近似下的通量积分，你将能定量地理解几何近似所引入的误差。[@problem_id:3129704]", "problem": "在有限元法 (FEM) 原理的背景下，考虑一个二维边界段，该边界段要么是弯曲的，要么由直边近似。目标是量化几何近似对通量线积分的影响。从通量穿过曲线的基本定义开始：向量场 $\\mathbf{F}(x,y)$ 穿过边界曲线 $\\Gamma$（单位法向量为 $\\hat{\\mathbf{n}}$）的通量是线积分 $\\int_{\\Gamma} \\mathbf{F} \\cdot \\hat{\\mathbf{n}} \\, ds$。对于一个参数 $\\xi \\in [-1,1]$ 的可微参数化 $\\mathbf{x}(\\xi)$，切向量为 $\\mathbf{t}(\\xi) = \\dfrac{d\\mathbf{x}}{d\\xi}$，一个长度为 $\\|\\mathbf{t}(\\xi)\\|$ 的法向量是 $\\mathbf{n}(\\xi) = \\mathbf{R}\\,\\mathbf{t}(\\xi)$，其中 $\\mathbf{R} = \\begin{bmatrix} 0  -1 \\\\ 1  0 \\end{bmatrix}$（旋转 $+90^\\circ$），且 $ds = \\|\\mathbf{t}(\\xi)\\| \\, d\\xi$。因此，通量积分可以表示为 $\\int_{-1}^{1} \\mathbf{F}(\\mathbf{x}(\\xi)) \\cdot \\mathbf{n}(\\xi) \\, d\\xi$。\n\n您需要比较：\n- 使用二次等参映射的曲边通量积分，节点位于 $\\xi=-1$、$\\xi=0$ 和 $\\xi=1$。\n- 使用端点之间的线性映射的直边近似（忽略中间节点）。\n\n设向量场为 $\\mathbf{F}(x,y) = \\big[x^2 y,\\; x - y^2\\big]$。\n\n曲边映射：在 $[-1,1]$ 上使用二次拉格朗日形函数，节点位置在 $\\xi=-1$、$\\xi=0$ 和 $\\xi=1$：\n- $N_{-1}(\\xi) = \\dfrac{\\xi(\\xi - 1)}{2}$，\n- $N_{0}(\\xi) = 1 - \\xi^2$，\n- $N_{1}(\\xi) = \\dfrac{\\xi(\\xi + 1)}{2}$。\n给定物理节点坐标 $\\mathbf{P}_{-1}$、$\\mathbf{P}_0$、$\\mathbf{P}_{1}$，定义 $\\mathbf{x}(\\xi) = N_{-1}(\\xi)\\,\\mathbf{P}_{-1} + N_{0}(\\xi)\\,\\mathbf{P}_{0} + N_{1}(\\xi)\\,\\mathbf{P}_{1}$，以及 $\\mathbf{t}(\\xi) = \\dfrac{d\\mathbf{x}}{d\\xi}$，其导数为 $N_{-1}'(\\xi) = \\xi - \\dfrac{1}{2}$、$N_0'(\\xi) = -2\\xi$、$N_1'(\\xi) = \\xi + \\dfrac{1}{2}$。曲边通量为 $I_{\\mathrm{curved}} = \\int_{-1}^{1} \\mathbf{F}(\\mathbf{x}(\\xi)) \\cdot \\big(\\mathbf{R}\\,\\mathbf{t}(\\xi)\\big) \\, d\\xi$。\n\n直边近似：通过 $\\mathbf{x}_s(p) = \\dfrac{1-p}{2}\\,\\mathbf{P}_{-1} + \\dfrac{1+p}{2}\\,\\mathbf{P}_{1}$（对于 $p \\in [-1,1]$）来参数化从 $\\mathbf{P}_{-1}$ 到 $\\mathbf{P}_{1}$ 的直线段。那么 $\\mathbf{t}_s = \\dfrac{d\\mathbf{x}_s}{dp} = \\dfrac{\\mathbf{P}_{1} - \\mathbf{P}_{-1}}{2}$ 是常数，直边通量为 $I_{\\mathrm{straight}} = \\int_{-1}^{1} \\mathbf{F}(\\mathbf{x}_s(p)) \\cdot \\big(\\mathbf{R}\\,\\mathbf{t}_s\\big) \\, dp$。\n\n使用高斯-勒让德求积法在 $[-1,1]$ 上实现这两个积分，至少使用 $n_q = 16$ 个点，以确保对给定的多项式向量场和映射具有高精度。\n\n测试套件：对于以下每种情况，计算 $I_{\\mathrm{curved}}$、$I_{\\mathrm{straight}}$，并报告绝对差 $\\Delta = \\big|I_{\\mathrm{curved}} - I_{\\mathrm{straight}}\\big|$。\n- 情况 1（轻度曲率，水平弦）：$\\mathbf{P}_{-1} = (0,0)$，$\\mathbf{P}_0 = (0.5, 0.2)$，$\\mathbf{P}_{1} = (1,0)$。\n- 情况 2（强曲率，水平弦）：$\\mathbf{P}_{-1} = (0,0)$，$\\mathbf{P}_0 = (0.5, -0.6)$，$\\mathbf{P}_{1} = (1,0)$。\n- 情况 3（带曲率的对角弦）：$\\mathbf{P}_{-1} = (0,0)$，$\\mathbf{P}_0 = (0.7, 0.4)$，$\\mathbf{P}_{1} = (1,1)$。\n- 情况 4（零曲率，完全笔直）：$\\mathbf{P}_{-1} = (0,0)$，$\\mathbf{P}_0 = (0.5, 0.5)$，$\\mathbf{P}_{1} = (1,1)$。\n\n您的程序必须：\n- 实现上述定义，通过数值求积计算 $I_{\\mathrm{curved}}$ 和 $I_{\\mathrm{straight}}$。\n- 为这四种情况，按给定顺序，生成绝对差 $\\Delta$ 的列表。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔的四个浮点数列表，每个数字四舍五入到恰好 $8$ 位小数，例如 $[\\Delta_1,\\Delta_2,\\Delta_3,\\Delta_4]$。", "solution": "该问题要求对向量场穿过二次定义的弯曲边界的通量与其线性（直边）近似进行定量比较。此分析对于理解有限元法（FEM）中的几何误差至关重要。向量场 $\\mathbf{F}$ 穿过曲线 $\\Gamma$ 的通量由线积分 $\\int_{\\Gamma} \\mathbf{F} \\cdot \\hat{\\mathbf{n}} \\, ds$ 给出，其中 $\\hat{\\mathbf{n}}$ 是单位法向量，ds 是微分弧长。\n\n我们给定了一种使用边界的参数表示 $\\mathbf{x}(\\xi)$（其中 $\\xi \\in [-1, 1]$）来计算此通量的方法。通量积分被转换为参考域 $[-1, 1]$ 上的积分：\n$$I = \\int_{-1}^{1} \\mathbf{F}(\\mathbf{x}(\\xi)) \\cdot \\mathbf{n}(\\xi) \\, d\\xi$$\n这里，$\\mathbf{t}(\\xi) = \\frac{d\\mathbf{x}}{d\\xi}$ 是切向量，$\\mathbf{n}(\\xi) = \\mathbf{R}\\,\\mathbf{t}(\\xi)$ 是一个法向量，其中 $\\mathbf{R} = \\begin{bmatrix} 0  -1 \\\\ 1  0 \\end{bmatrix}$ 是用于 $+90^\\circ$ 旋转的旋转矩阵。向量场指定为 $\\mathbf{F}(x,y) = \\begin{bmatrix} x^2 y \\\\ x - y^2 \\end{bmatrix}$。\n\n目标是为四组不同的控制点计算绝对差 $\\Delta = |I_{\\mathrm{curved}} - I_{\\mathrm{straight}}|$。两个积分都将使用 $n_q$ 点的高斯-勒让德求积法则在区间 $[-1, 1]$ 上进行数值近似：\n$$\\int_{-1}^{1} g(\\xi) \\, d\\xi \\approx \\sum_{i=1}^{n_q} w_i g(\\xi_i)$$\n其中 $\\xi_i$ 是求积点（$n_q$ 次勒让德多项式的根），$w_i$ 是对应的权重。我们将使用 $n_q = 16$，这确保了高精度。\n\n**1. 曲边通量, $I_{\\mathrm{curved}}$**\n\n曲边由使用三个节点 $\\mathbf{P}_{-1}$、$\\mathbf{P}_0$ 和 $\\mathbf{P}_{1}$ 的二次等参映射定义。位置向量 $\\mathbf{x}(\\xi)$ 由下式给出：\n$$\\mathbf{x}(\\xi) = N_{-1}(\\xi)\\,\\mathbf{P}_{-1} + N_{0}(\\xi)\\,\\mathbf{P}_{0} + N_{1}(\\xi)\\,\\mathbf{P}_{1}$$\n其中 $N_{-1}(\\xi)$、$N_0(\\xi)$ 和 $N_1(\\xi)$ 是二次拉格朗日形函数：\n- $N_{-1}(\\xi) = \\dfrac{\\xi(\\xi - 1)}{2}$\n- $N_{0}(\\xi) = 1 - \\xi^2$\n- $N_{1}(\\xi) = \\dfrac{\\xi(\\xi + 1)}{2}$\n\n切向量 $\\mathbf{t}(\\xi) = \\frac{d\\mathbf{x}}{d\\xi}$ 通过对形函数求导得到：\n$$\\mathbf{t}(\\xi) = N_{-1}'(\\xi)\\,\\mathbf{P}_{-1} + N_{0}'(\\xi)\\,\\mathbf{P}_{0} + N_{1}'(\\xi)\\,\\mathbf{P}_{1}$$\n其导数如下：\n- $N_{-1}'(\\xi) = \\xi - \\dfrac{1}{2}$\n- $N_0'(\\xi) = -2\\xi$\n- $N_1'(\\xi) = \\xi + \\dfrac{1}{2}$\n\n设 $\\mathbf{P}_j = \\begin{bmatrix} P_{jx} \\\\ P_{jy} \\end{bmatrix}$。那么切向量 $\\mathbf{t}(\\xi) = \\begin{bmatrix} t_x(\\xi) \\\\ t_y(\\xi) \\end{bmatrix}$ 的分量是：\n$$t_x(\\xi) = N_{-1}'(\\xi)P_{-1x} + N_{0}'(\\xi)P_{0x} + N_{1}'(\\xi)P_{1x}$$\n$$t_y(\\xi) = N_{-1}'(\\xi)P_{-1y} + N_{0}'(\\xi)P_{0y} + N_{1}'(\\xi)P_{1y}$$\n法向量是 $\\mathbf{n}(\\xi) = \\mathbf{R}\\,\\mathbf{t}(\\xi) = \\begin{bmatrix} -t_y(\\xi) \\\\ t_x(\\xi) \\end{bmatrix}$。\n\n曲边通量的被积函数是 $g(\\xi) = \\mathbf{F}(\\mathbf{x}(\\xi)) \\cdot \\mathbf{n}(\\xi)$。计算 $I_{\\mathrm{curved}}$ 的算法如下：\n1. 获取 $n_q$ 个高斯-勒让德点 $\\xi_i$ 和权重 $w_i$。\n2. 初始化积分 $I_{\\mathrm{curved}} = 0$。\n3. 对于每个求积点 $\\xi_i$：\n    a. 计算形函数 $N_j(\\xi_i)$ 及其对 $j \\in \\{-1, 0, 1\\}$ 的导数 $N_j'(\\xi_i)$。\n    b. 计算物理坐标 $\\mathbf{x}(\\xi_i) = \\begin{bmatrix} x_i \\\\ y_i \\end{bmatrix}$。\n    c. 计算切向量 $\\mathbf{t}(\\xi_i) = \\begin{bmatrix} t_{x,i} \\\\ t_{y,i} \\end{bmatrix}$ 和法向量 $\\mathbf{n}(\\xi_i) = \\begin{bmatrix} -t_{y,i} \\\\ t_{x,i} \\end{bmatrix}$。\n    d. 在此点计算向量场：$\\mathbf{F}(x_i, y_i) = \\begin{bmatrix} x_i^2 y_i \\\\ x_i - y_i^2 \\end{bmatrix}$。\n    e. 计算点积：$d_i = \\mathbf{F}(x_i, y_i) \\cdot \\mathbf{n}(\\xi_i)$。\n    f. 将加权贡献加到积分中：$I_{\\mathrm{curved}} = I_{\\mathrm{curved}} + w_i d_i$。\n\n**2. 直边通量, $I_{\\mathrm{straight}}$**\n\n直边近似用线性段连接端点 $\\mathbf{P}_{-1}$ 和 $\\mathbf{P}_{1}$。$p \\in [-1, 1]$ 上的参数化为：\n$$\\mathbf{x}_s(p) = \\dfrac{1-p}{2}\\,\\mathbf{P}_{-1} + \\dfrac{1+p}{2}\\,\\mathbf{P}_{1}$$\n切向量是恒定的：\n$$\\mathbf{t}_s = \\frac{d\\mathbf{x}_s}{dp} = \\dfrac{\\mathbf{P}_{1} - \\mathbf{P}_{-1}}{2}$$\n设 $\\mathbf{t}_s = \\begin{bmatrix} t_{sx} \\\\ t_{sy} \\end{bmatrix}$。法向量 $\\mathbf{n}_s = \\mathbf{R}\\,\\mathbf{t}_s = \\begin{bmatrix} -t_{sy} \\\\ t_{sx} \\end{bmatrix}$ 也是恒定的。\n\n被积函数是 $h(p) = \\mathbf{F}(\\mathbf{x}_s(p)) \\cdot \\mathbf{n}_s$。计算 $I_{\\mathrm{straight}}$ 的算法如下：\n1. 获取 $n_q$ 个高斯-勒让德点 $p_i$（与 $\\xi_i$ 相同）和权重 $w_i$。\n2. 计算恒定的切向量 $\\mathbf{t}_s$ 和法向量 $\\mathbf{n}_s$。\n3. 初始化积分 $I_{\\mathrm{straight}} = 0$。\n4. 对于每个求积点 $p_i$：\n    a. 计算物理坐标 $\\mathbf{x}_s(p_i) = \\begin{bmatrix} x_{s,i} \\\\ y_{s,i} \\end{bmatrix}$。\n    b. 计算向量场：$\\mathbf{F}(x_{s,i}, y_{s,i}) = \\begin{bmatrix} x_{s,i}^2 y_{s,i} \\\\ x_{s,i} - y_{s,i}^2 \\end{bmatrix}$。\n    c. 计算点积：$d_{s,i} = \\mathbf{F}(x_{s,i}, y_{s,i}) \\cdot \\mathbf{n}_s$。\n    d. 将加权贡献加到积分中：$I_{\\mathrm{straight}} = I_{\\mathrm{straight}} + w_i d_{s,i}$。\n\n最后，对每个测试用例，计算绝对差 $\\Delta = |I_{\\mathrm{curved}} - I_{\\mathrm{straight}}|$。对于情况4，三个节点共线，且 $\\mathbf{P}_0$ 是线段 $\\mathbf{P}_{-1}\\mathbf{P}_{1}$ 的中点。在这种特殊情况下，二次映射精确地再现了线性路径，因此我们预期 $I_{\\mathrm{curved}} = I_{\\mathrm{straight}}$，从而 $\\Delta = 0$（或由于浮点运算而得到一个非常接近零的值）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Computes the absolute difference in flux integrals between a curved quadratic edge\n    and its straight-line approximation for a given vector field and several geometries.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (mild curvature, horizontal chord)\n        (np.array([0.0, 0.0]), np.array([0.5, 0.2]), np.array([1.0, 0.0])),\n        # Case 2 (strong curvature, horizontal chord)\n        (np.array([0.0, 0.0]), np.array([0.5, -0.6]), np.array([1.0, 0.0])),\n        # Case 3 (diagonal chord with curvature)\n        (np.array([0.0, 0.0]), np.array([0.7, 0.4]), np.array([1.0, 1.0])),\n        # Case 4 (zero curvature, exactly straight)\n        (np.array([0.0, 0.0]), np.array([0.5, 0.5]), np.array([1.0, 1.0])),\n    ]\n\n    # Use n_q=16 points for Gauss-Legendre quadrature as required.\n    n_q = 16\n    xi_q, w_q = roots_legendre(n_q)\n    \n    # Rotation matrix R for a +90 degree rotation.\n    R = np.array([[0, -1], [1, 0]])\n\n    # Vector field F(x, y) = [x^2*y, x - y^2]\n    def F_field(x, y):\n        return np.array([x**2 * y, x - y**2])\n\n    results = []\n    for case in test_cases:\n        p_m1, p_0, p_1 = case\n\n        # --- Calculate I_curved ---\n        I_curved = 0.0\n        for i in range(n_q):\n            xi = xi_q[i]\n            w = w_q[i]\n            \n            # Quadratic shape functions and their derivatives\n            N_m1 = 0.5 * xi * (xi - 1)\n            N_0 = 1 - xi**2\n            N_1 = 0.5 * xi * (xi + 1)\n            \n            dN_m1 = xi - 0.5\n            dN_0 = -2 * xi\n            dN_1 = xi + 0.5\n\n            # Physical coordinates x(xi)\n            x_vec = N_m1 * p_m1 + N_0 * p_0 + N_1 * p_1\n            \n            # Tangent vector t(xi)\n            t_vec = dN_m1 * p_m1 + dN_0 * p_0 + dN_1 * p_1\n            \n            # Normal vector n(xi) = R * t(xi)\n            n_vec = R @ t_vec\n            \n            # Evaluate vector field F at x(xi)\n            F_val = F_field(x_vec[0], x_vec[1])\n            \n            # Integrand value\n            integrand = np.dot(F_val, n_vec)\n            \n            I_curved += w * integrand\n            \n        # --- Calculate I_straight ---\n        I_straight = 0.0\n        \n        # Constant tangent and normal for the straight edge\n        t_s_vec = 0.5 * (p_1 - p_m1)\n        n_s_vec = R @ t_s_vec\n\n        for i in range(n_q):\n            p = xi_q[i] # Use same quadrature points for parameter 'p'\n            w = w_q[i]\n            \n            # Linear shape functions for the straight segment\n            M_m1 = 0.5 * (1 - p)\n            M_1 = 0.5 * (1 + p)\n            \n            # Physical coordinates x_s(p)\n            xs_vec = M_m1 * p_m1 + M_1 * p_1\n            \n            # Evaluate vector field F at x_s(p)\n            Fs_val = F_field(xs_vec[0], xs_vec[1])\n            \n            # Integrand value\n            integrand_s = np.dot(Fs_val, n_s_vec)\n            \n            I_straight += w * integrand_s\n\n        delta = abs(I_curved - I_straight)\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3129704"}]}