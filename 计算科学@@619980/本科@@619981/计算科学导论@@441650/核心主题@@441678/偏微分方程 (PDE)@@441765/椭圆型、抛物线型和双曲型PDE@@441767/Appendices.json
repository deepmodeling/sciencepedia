{"hands_on_practices": [{"introduction": "双曲型偏微分方程，如平流方程，描述了物理量的输运过程。相比于简单的一阶格式，像Lax-Wendroff这样的高阶数值格式能提供更高的精度。然而，这种精度是有代价的：在解的急剧变化（例如不连续处）附近，它会引入非物理的数值振荡，这种现象与吉布斯现象（Gibbs phenomenon）有关。这个练习将让你亲手实现Lax-Wendroff格式，并量化其在求解不连续初值问题时产生的色散误差。[@problem_id:2393549]", "problem": "考虑一维线性平流方程 $u_t + a\\,u_x = 0$，定义在周期域 $x \\in [0,1)$ 上，具有恒定的平流速度 $a > 0$。设 $a = 1$。初始条件为不连续阶跃函数\n$$\nu(x,0) = \\begin{cases}\n1,  x \\ge 0.5,\\\\\n0,  x  0.5.\n\\end{cases}\n$$\n使用 $N$ 个均匀的单元中心点 $x_j = (j + 0.5)\\,\\Delta x$（其中 $j \\in \\{0,1,\\dots,N-1\\}$，$\\Delta x = 1/N$）对空间进行离散化，并施加周期性。使用由以下更新公式定义的 Lax–Wendroff 有限差分格式来演化离散解\n$$\nu_j^{n+1} = u_j^n - \\tfrac{1}{2}\\sigma\\left(u_{j+1}^n - u_{j-1}^n\\right) + \\tfrac{1}{2}\\sigma^2\\left(u_{j+1}^n - 2u_j^n + u_{j-1}^n\\right),\n$$\n其中索引是周期性的，Courant–Friedrichs–Lewy (CFL) 数 $\\sigma$ 为 $\\sigma = a\\,\\Delta t / \\Delta x$，$\\Delta t$ 是时间步长。对于下面的每个案例，使用指定的 $N$、$\\sigma$ 和终止时间 $t_{\\mathrm{end}}$ 来构造 $\\Delta t = \\sigma\\,\\Delta x/a$，并演化最大的整数步数 $n$，使得 $t_n = n\\,\\Delta t \\le t_{\\mathrm{end}}$。将此演化时间记为 $t_n$。\n\n为量化平流间断点附近的类吉布斯振荡，将时间 $t_n$ 的理论间断点位置定义为 $x_d(t_n) = \\mathrm{mod}(0.5 + a\\,t_n,\\,1)$。提取一个以 $x_d(t_n)$ 为中心、半宽为 $w_x = 0.1$ 的对称空间窗口，即所有满足其到 $x_d(t_n)$ 的最短周期距离不超过 $w_x$ 的网格点 $x_j$。在此窗口内，计算时间 $t_n$ 离散解的以下三个量：\n- 过冲幅度 $O = \\max\\{0,\\,\\max_{\\text{window}} u - 1\\}$。\n- 下冲幅度 $U = \\max\\{0,\\,0 - \\min_{\\text{window}} u\\}$。\n- 总变差比率 $R = \\mathrm{TV}(u(\\cdot,t_n)) / \\mathrm{TV}(u(\\cdot,0))$，其中离散总变差为 $\\mathrm{TV}(v) = \\sum_{j=0}^{N-1} |v_{j+1} - v_j|$（使用周期性索引）。\n\n您的程序必须对以下五个测试案例中的每一个进行评估 $(O,U,R)$：\n1. $N=200$, $\\sigma=0.5$, $t_{\\mathrm{end}}=0.2$。\n2. $N=200$, $\\sigma=0.9$, $t_{\\mathrm{end}}=0.2$。\n3. $N=50$, $\\sigma=0.5$, $t_{\\mathrm{end}}=0.2$。\n4. $N=200$, $\\sigma=0.2$, $t_{\\mathrm{end}}=0.2$。\n5. $N=800$, $\\sigma=0.5$, $t_{\\mathrm{end}}=0.2$。\n\n所有量都是无量纲的。您的程序应生成单行输出，其中包含结果，格式为逗号分隔的列表的列表，其中第 $k$ 个内部列表是测试案例 $k$ 的 $[O_k,U_k,R_k]$，每个浮点数都四舍五入到恰好六位小数。例如，所需的格式是\n$$\n[\\,[O_1,U_1,R_1],\\,[O_2,U_2,R_2],\\,\\dots,\\,[O_5,U_5,R_5]\\,].\n$$", "solution": "该问题要求使用 Lax-Wendroff 有限差分格式对一维线性平流方程进行数值求解。主要目标是量化将此二阶非单调格式应用于不连续初始剖面时产生的数值伪影，特别是类吉布斯振荡。\n\n控制偏微分方程是线性平流方程：\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0\n$$\n其中 $u(x, t)$ 是守恒量，$x \\in [0, 1)$ 是具有周期性边界条件的空间坐标，$t$ 是时间，$a$ 是恒定的平流速度，给定为 $a=1$。该方程的解析解是初始剖面的简单平移，$u(x,t) = u_0(x-at)$，其中 $u_0(x) = u(x,0)$。对于给定的阶跃函数初始条件：\n$$\nu(x,0) = \\begin{cases}\n1,  x \\ge 0.5 \\\\\n0,  x  0.5\n\\end{cases}\n$$\n初始位于 $x=0.5$ 的间断点以速度 $a=1$ 平流，其在时间 $t$ 的理论位置是 $x_d(t) = \\mathrm{mod}(0.5 + at, 1)$。\n\n计算域被离散化为 $N$ 个均匀的单元中心网格点 $x_j = (j + 0.5)\\Delta x$（$j \\in \\{0, 1, \\dots, N-1\\}$），空间步长为 $\\Delta x = 1/N$。周期性意味着索引按模 $N$ 处理，因此 $x_{j+N} = x_j$。\n\n时间演化由显式的 Lax-Wendroff 格式控制，该格式在空间和时间上都是二阶精确的。解 $u_j^n \\approx u(x_j, t_n)$ 的离散更新公式由下式给出：\n$$\nu_j^{n+1} = u_j^n - \\frac{1}{2}\\sigma(u_{j+1}^n - u_{j-1}^n) + \\frac{1}{2}\\sigma^2(u_{j+1}^n - 2u_j^n + u_{j-1}^n)\n$$\n在这里，$\\sigma = a\\Delta t / \\Delta x$ 是 Courant-Friedrichs-Lewy (CFL) 数，它关联了时间步长 $\\Delta t$、空间步长 $\\Delta x$ 和平流速度 $a$。该格式在 $|\\sigma| \\le 1$ 时是稳定的。问题指定 $\\Delta t = \\sigma \\Delta x / a$。模拟运行最大的整数步数 $n_{\\text{steps}}$，使得总演化时间 $t_n = n_{\\text{steps}} \\Delta t$ 不超过给定的终止时间 $t_{\\mathrm{end}}$。\n\nLax-Wendroff 格式通过引入一个与空间二阶导数成比例的项来实现二阶精度，该项抵消了一阶迎风格式的数值耗散。然而，这会引入数值色散，在陡峭梯度或不连续点附近引起非物理振荡（过冲和下冲），这种现象与吉布斯效应有关。\n\n为了量化这些振荡，我们分析最终时间 $t_n$ 的数值解 $u_j^{n}$。在平流间断点的理论位置 $x_d(t_n)$ 周围定义一个半宽为 $w_x = 0.1$ 的空间窗口。此窗口包含所有网格点 $x_j$，使得其到 $x_d(t_n)$ 的最短周期距离（由 $\\min(|x_j - x_d(t_n)|, 1 - |x_j - x_d(t_n)|)$ 给出）不大于 $w_x$。在此窗口内，我们计算：\n1.  过冲幅度 $O = \\max\\{0, \\max_{\\text{window}} u - 1\\}$。这衡量了窗口内解超过初始最大值 1 的最大值。\n2.  下冲幅度 $U = \\max\\{0, 0 - \\min_{\\text{window}} u\\}$。这衡量了窗口内解低于初始最小值 0 的最大值。\n\n此外，我们通过计算时间 $t_n$ 的总变差 (TV) 与初始总变差之比来评估振荡的增长。网格函数 $v$ 的离散总变差定义为 $\\mathrm{TV}(v) = \\sum_{j=0}^{N-1} |v_{j+1} - v_j|$，其中周期性索引为 $v_N = v_0$。初始条件是周期域上的阶跃函数，它有两个跳跃（从 0 到 1，以及从 1 回到 0），因此其理论总变差为 $\\mathrm{TV}(u(\\cdot,0)) = 2$。该比率为 $R = \\mathrm{TV}(u(\\cdot,t_n)) / \\mathrm{TV}(u(\\cdot,0))$。对于像 Lax-Wendroff 这样非总变差递减 (TVD) 的格式，该比率预计会大于 1，表明产生了新的极值，即振荡。\n\n每个测试案例的算法步骤如下：\n1.  初始化参数：$N, \\sigma, t_{\\mathrm{end}}$，以及 $a=1$ 和 $w_x=0.1$。\n2.  计算模拟参数：$\\Delta x = 1/N$，$\\Delta t = \\sigma \\Delta x / a$，以及 $n_{\\text{steps}} = \\lfloor t_{\\mathrm{end}} / \\Delta t \\rfloor$。最终时间为 $t_n = n_{\\text{steps}} \\Delta t$。\n3.  设置网格 $x_j$ 和初始条件 $u^0$，其中如果 $x_j \\ge 0.5$，则 $u_j^0 = 1$，否则 $u_j^0 = 0$。\n4.  计算初始总变差 $\\mathrm{TV}(u^0)$。\n5.  对 $n_{\\text{steps}}$ 步迭代应用 Lax-Wendroff 更新公式，以获得最终数值解 $u^{n_{\\text{steps}}}$。为提高效率，使用向量化数组操作，并采用循环移位来处理周期性边界条件。\n6.  确定理论间断点位置 $x_d(t_n) = (0.5 + a t_n) \\pmod 1$。\n7.  识别位于 $x_d(t_n)$ 周围半宽为 $w_x$ 的分析窗口内的网格点。\n8.  在此窗口内计算解的最大值和最小值，以求得过冲 $O$ 和下冲 $U$。\n9.  计算最终解的总变差 $\\mathrm{TV}(u^{n_{\\text{steps}}})$ 和比率 $R$。\n10. 存储该案例计算出的三元组 $(O, U, R)$。\n对所有五个指定的测试案例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation using the Lax-Wendroff scheme for\n    multiple test cases and quantifies numerical oscillations.\n    \"\"\"\n    test_cases = [\n        (200, 0.5, 0.2),\n        (200, 0.9, 0.2),\n        (50, 0.5, 0.2),\n        (200, 0.2, 0.2),\n        (800, 0.5, 0.2),\n    ]\n\n    results = []\n    a = 1.0  # Advection speed\n    w_x = 0.1  # Window half-width for analysis\n\n    for N, sigma, t_end in test_cases:\n        # 1. Setup simulation parameters\n        dx = 1.0 / N\n        dt = sigma * dx / a\n        if dt == 0:\n            num_steps = 0\n        else:\n            num_steps = int(t_end / dt)\n        t_n = num_steps * dt\n\n        # 2. Initialize grid and solution\n        x = (np.arange(N) + 0.5) * dx\n        u = np.where(x >= 0.5, 1.0, 0.0)\n\n        # 3. Calculate initial total variation\n        # TV(v) = sum(|v_{j+1} - v_j|) with periodic indexing\n        # np.roll(u, -1) gives u_{j+1} at index j\n        tv_initial = np.sum(np.abs(np.roll(u, -1) - u))\n        if tv_initial == 0: tv_initial = 1.0 # Avoid division by zero, though not expected here.\n\n        # 4. Time evolution loop (Lax-Wendroff)\n        for _ in range(num_steps):\n            u_jp1 = np.roll(u, -1)  # u_{j+1}\n            u_jm1 = np.roll(u, 1)   # u_{j-1}\n            \n            # Central difference term (first derivative)\n            term1 = -0.5 * sigma * (u_jp1 - u_jm1)\n            \n            # Central difference term (second derivative)\n            term2 = 0.5 * sigma**2 * (u_jp1 - 2.0 * u + u_jm1)\n            \n            u = u + term1 + term2\n        \n        u_final = u\n\n        # 5. Analyze the final solution\n        # Theoretical discontinuity location\n        x_d = (0.5 + a * t_n) % 1.0\n\n        # Identify the analysis window\n        dist = np.abs(x - x_d)\n        periodic_dist = np.minimum(dist, 1.0 - dist)\n        window_mask = periodic_dist = w_x\n        \n        u_window = u_final[window_mask]\n\n        # Handle case where window might be empty, though unlikely with given params\n        if u_window.size > 0:\n            max_u_window = np.max(u_window)\n            min_u_window = np.min(u_window)\n        else:\n            max_u_window = 1.0\n            min_u_window = 0.0\n\n        # Calculate overshoot and undershoot\n        overshoot = max(0.0, max_u_window - 1.0)\n        undershoot = max(0.0, 0.0 - min_u_window)\n\n        # Calculate total variation ratio\n        tv_final = np.sum(np.abs(np.roll(u_final, -1) - u_final))\n        tv_ratio = tv_final / tv_initial\n        \n        results.append([overshoot, undershoot, tv_ratio])\n\n    # 6. Format and print the final output\n    formatted_results = []\n    for O, U, R in results:\n        formatted_results.append(f\"[{O:.6f},{U:.6f},{R:.6f}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2393549"}, {"introduction": "抛物型偏微分方程的典型代表是热传导方程，它模拟了扩散过程，具有“平滑”解的特性。Crank-Nicolson格式是一种求解抛物型方程的强大隐式方法，因其无条件稳定性而广受欢迎。然而，这个练习将揭示一个重要但微妙的陷阱：当时间步长较大且初始条件包含尖锐梯度时，即使是无条件稳定的格式也可能产生违反物理直觉的振荡。通过这个实践，你将深入理解数值稳定性和解的物理真实性之间的区别。[@problem_id:2393571]", "problem": "考虑区间 $[0,1]$ 上带均匀狄利克雷边界条件的一维热（扩散）方程，\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in (0,1), \\ t  0, \\quad u(0,t) = 0, \\ u(1,t) = 0,\n$$\n以及一个不连续的初始条件\n$$\nu(x,0) = \\begin{cases}\n1,  x \\in [0.45, 0.55],\\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n所有量均为无量纲。使用包含 $N=201$ 个等距点（包括边界）的均匀空间网格，因此 $\\Delta x = 1/(N-1)$。令 $\\alpha = 1$。\n\n令 $u_i^n$ 表示在内部网格点 $x_i = i \\, \\Delta x$（其中 $i=1,2,\\dots,N-2$）和时间层 $t_n = n \\, \\Delta t$ 处对 $u(x_i,t_n)$ 的数值近似。将从 $t_n$ 到 $t_{n+1}$ 推进一个时间步长的 Crank–Nicolson 有限差分格式定义为下式的唯一解 $u^{n+1}$：\n$$\n\\left( I - \\frac{r}{2} L \\right) u^{n+1} = \\left( I + \\frac{r}{2} L \\right) u^{n}, \\quad r = \\frac{\\alpha \\, \\Delta t}{(\\Delta x)^2},\n$$\n其中 $I$ 是内部网格上的单位算子，而 $L$ 是作用于内部网格值的带均匀狄利克雷边界条件的标准二阶差分算子：\n$$\n(L u)_i = u_{i+1} - 2 u_i + u_{i-1}, \\quad i=1,2,\\dots,N-2,\n$$\n根据边界条件，我们有 $u_0 = 0$ 和 $u_{N-1} = 0$。\n\n对于给定的时间步长 $\\Delta t$，将一个 Crank–Nicolson 时间步长后的振荡幅度定义为\n$$\nA(\\Delta t) = \\max\\!\\left(0, \\ \\max_{1 \\le i \\le N-2} u_i^{1} - 1 \\right) \\;+\\; \\max\\!\\left(0, \\ 0 - \\min_{1 \\le i \\le N-2} u_i^{1} \\right).\n$$\n这个量是从 $t=0$ 时的指定不连续初始条件出发，经过单个时间步长后，内部解超过物理上界 $1$ 的过冲量与低于物理下界 $0$ 的下冲量之和。\n\n测试套件：\n- 按规定使用 $N=201$ 和 $\\alpha = 1$。\n- 令 $\\Delta x = 1/(N-1)$。\n- 考虑以下四个时间步长\n  1. $\\Delta t_1 = 0.2 \\, (\\Delta x)^2 / \\alpha$,\n  2. $\\Delta t_2 = 1.0 \\, (\\Delta x)^2 / \\alpha$,\n  3. $\\Delta t_3 = 5.0 \\, (\\Delta x)^2 / \\alpha$,\n  4. $\\Delta t_4 = 25.0 \\, (\\Delta x)^2 / \\alpha$.\n  \n对于每个 $\\Delta t_k$，计算如上定义的 $A(\\Delta t_k)$。您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[A(\\Delta t_1), A(\\Delta t_2), A(\\Delta t_3), A(\\Delta t_4)]$，每个值四舍五入到六位小数。输出是无量纲的，且只包含浮点数。", "solution": "我们从区间 $[0,1]$ 上的热方程 $\\partial_t u = \\alpha \\partial_{xx} u$ 开始，该方程具有均匀狄利克雷边界条件和一个限制在 $[0.45,0.55]$ 内的不连续阶梯初始条件。连续问题的极值原理意味着，对于 $t0$，解将保持在 $0$ 和 $1$ 之间。然而，某些时间离散化方法，虽然在某种范数下是稳定的，但并非单调的，并且当初始数据具有急剧的不连续性时，可能会产生非物理振荡，如下冲（值低于 $0$）或过冲（值高于 $1$）。Crank–Nicolson 格式是一种在 $\\ell^2$ 意义下二阶精确、隐式、无条件稳定的方法，但它既不是总变差递减的，也不是保单调性的，因此对于足够大的时间步长，可能会产生此类振荡。\n\n我们用 $N=201$ 个均匀分布的节点（包括边界）对空间域进行离散化，因此 $\\Delta x = 1/(N-1)$。我们用 $i=1,2,\\dots,N-2$ 索引内部节点，并用 $u_i^n$ 表示在 $x_i=i\\Delta x$ 和时间 $t_n=n\\Delta t$ 处的数值近似。带均匀狄利克雷边界条件的标准中心二阶差分算子在内部索引上定义为\n$$\n(Lu)_i = u_{i+1} - 2u_i + u_{i-1}, \\quad i=1,\\dots,N-2,\n$$\n并强制边界值 $u_0=0$ 和 $u_{N-1}=0$。\n\n对于半离散系统 $\\dot{u}=\\alpha \\Delta_x u$ 的 Crank–Nicolson 时间步进格式为\n$$\n\\left( I - \\frac{r}{2} L \\right) u^{n+1} = \\left( I + \\frac{r}{2} L \\right) u^{n}, \\quad r = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}.\n$$\n在一维均匀网格上，这成为一个关于内部索引处 $u^{n+1}$ 的三对角线性系统。对 $i=1,\\dots,N-2$ 写出分量形式，\n$$\n-\\frac{r}{2} \\, u_{i-1}^{n+1} + (1+r) \\, u_i^{n+1} - \\frac{r}{2} \\, u_{i+1}^{n+1}\n=\n\\frac{r}{2} \\, u_{i-1}^{n} + (1-r) \\, u_i^{n} + \\frac{r}{2} \\, u_{i+1}^{n},\n$$\n由于 $u_0^n=u_{N-1}^n=0$，边界贡献项消失。\n\n初始数据由下式设定\n$$\nu_i^0 = \\begin{cases}\n1,  x_i \\in [0.45,0.55],\\\\\n0,  \\text{otherwise},\n\\end{cases}\n\\qquad x_i = i \\Delta x, \\quad i=1,\\dots,N-2.\n$$\n\n为了量化一个时间步长后的非物理振荡，我们定义振幅\n$$\nA(\\Delta t) = \\max\\!\\left(0, \\ \\max_{1 \\le i \\le N-2} u_i^{1} - 1 \\right) \\;+\\; \\max\\!\\left(0, \\ 0 - \\min_{1 \\le i \\le N-2} u_i^{1} \\right).\n$$\n第一项衡量超过物理界限 $1$ 的过冲，第二项衡量低于 $0$ 的下冲。对于具有非负有界初始数据的热方程，精确解保持在 $[0,1]$ 区间内，因此任何正的 $A(\\Delta t)$ 都表示由离散格式引起的非物理振荡。\n\n我们现在讨论为什么大的 $r$ 会导致振荡。均匀网格上的离散拉普拉斯算子 $L$ 具有类似于离散正弦的本征模。对于波数为 $\\theta$ 的 Fourier 分量，离散拉普拉斯算子的特征值为 $\\lambda_d(\\theta) = -4\\sin^2(\\theta/2)$。该模式的 Crank–Nicolson 放大因子是\n$$\ng(\\theta; r) = \\frac{1 + \\frac{r}{2}\\lambda_d(\\theta)}{1 - \\frac{r}{2}\\lambda_d(\\theta)}\n= \\frac{1 - 2 r \\sin^2(\\theta/2)}{1 + 2 r \\sin^2(\\theta/2)}.\n$$\n对于任何 $r0$，我们有 $|g(\\theta;r)| \\le 1$，这确保了在 $\\ell^2$ 意义下的无条件稳定性。然而，如果 $2 r \\sin^2(\\theta/2)  1$，那么 $g(\\theta;r)  0$，这会在单个时间步长内翻转那些 Fourier 分量的符号，从而在存在高频内容的急剧不连续点附近产生振荡。$\\sin^2(\\theta/2)$ 的最大值为 $1$，因此对于 $r > 1/2$，最高频率的模式在一个步长后符号会反转。因此，我们预计对于 $r=0.2$，振荡可以忽略不计；对于 $r=1$，振荡性下冲/过冲会增加；而对于 $r=5$ 和 $r=25$，振荡会更加显著。\n\n在算法上，对于每个指定的 $\\Delta t_k$（等效于 $r_k$），我们：\n1. 根据内部网格上的阶梯初始条件构造 $u^0$。\n2. 构造三对角系统，其副对角线元为 $-r_k/2$，主对角线元为 $1+r_k$，超对角线元为 $-r_k/2$。\n3. 使用内部值和边界上的 $0$ 来组装右端项 $(I + \\frac{r_k}{2} L) u^0$。\n4. 求解三对角系统以获得 $u^1$。\n5. 根据 $u^1$ 的内部值计算如上定义的 $A(\\Delta t_k)$。\n6. 对测试套件中的四个 $\\Delta t_k$ 测试值重复以上步骤。\n\n最后，我们输出列表 $[A(\\Delta t_1), A(\\Delta t_2), A(\\Delta t_3), A(\\Delta t_4)]$，每个值四舍五入到六位小数，以单行、方括号内逗号分隔的形式。此过程直接反映了 Crank–Nicolson 方法的数学结构，并量化了对于不连续初始数据，当时间步长较大时可能出现的非物理振荡。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef thomas_tridiagonal(lower, diag, upper, rhs):\n    \"\"\"\n    Solve a tridiagonal system Ax = rhs with A having\n    lower (a), diagonal (b), and upper (c) diagonals.\n    All inputs are 1D numpy arrays:\n      lower: length n-1\n      diag:  length n\n      upper: length n-1\n      rhs:   length n\n    Returns x of length n.\n    \"\"\"\n    n = diag.size\n    # Copy to avoid modifying inputs\n    a = lower.astype(float).copy()\n    b = diag.astype(float).copy()\n    c = upper.astype(float).copy()\n    d = rhs.astype(float).copy()\n\n    # Forward elimination\n    for i in range(1, n):\n        w = a[i-1] / b[i-1]\n        b[i] = b[i] - w * c[i-1]\n        d[i] = d[i] - w * d[i-1]\n\n    # Back substitution\n    x = np.empty(n, dtype=float)\n    x[-1] = d[-1] / b[-1]\n    for i in range(n-2, -1, -1):\n        x[i] = (d[i] - c[i] * x[i+1]) / b[i]\n\n    return x\n\ndef crank_nicolson_first_step_amplitude(N, alpha, dt):\n    \"\"\"\n    Compute the oscillation amplitude A(dt) after one Crank-Nicolson step\n    for the 1D heat equation on [0,1] with homogeneous Dirichlet BCs and\n    discontinuous initial condition: u(x,0)=1 on [0.45,0.55], 0 otherwise.\n    \"\"\"\n    # Grid setup\n    L = 1.0\n    dx = L / (N - 1)\n    r = alpha * dt / (dx * dx)\n\n    # Interior indices: 1..N-2 (Python 0..M-1)\n    M = N - 2\n    x_interior = np.linspace(dx, L - dx, M)\n\n    # Initial condition on interior: 1 on [0.45,0.55], else 0\n    u0 = np.where((x_interior >= 0.45)  (x_interior = 0.55), 1.0, 0.0)\n\n    # Build Crank-Nicolson matrices (implicit LHS tridiagonal, RHS vector)\n    # LHS: (I - r/2 * L) => diag: 1 + r; off-diag: -r/2\n    lower = -0.5 * r * np.ones(M - 1)\n    diag = (1.0 + r) * np.ones(M)\n    upper = -0.5 * r * np.ones(M - 1)\n\n    # RHS: (I + r/2 * L) u0 => (1 - r) * u0 + (r/2) * (u0_{i-1} + u0_{i+1})\n    rhs = (1.0 - r) * u0.copy()\n    rhs[:-1] += 0.5 * r * u0[1:]     # contribution from u0_{i+1}\n    rhs[1:]  += 0.5 * r * u0[:-1]    # contribution from u0_{i-1}\n    # Boundary contributions are zero due to homogeneous Dirichlet BCs.\n\n    # Solve for u1\n    u1 = thomas_tridiagonal(lower, diag, upper, rhs)\n\n    # Compute amplitude A(dt) over interior values\n    max_val = float(np.max(u1))\n    min_val = float(np.min(u1))\n    overshoot = max(0.0, max_val - 1.0)\n    undershoot = max(0.0, -min_val)\n    A = overshoot + undershoot\n    return A\n\ndef solve():\n    # Parameters from the problem statement\n    N = 201\n    alpha = 1.0\n    L = 1.0\n    dx = L / (N - 1)\n\n    # Test suite time steps: dt_k = [0.2, 1.0, 5.0, 25.0] * dx^2 / alpha\n    r_values = [0.2, 1.0, 5.0, 25.0]\n    test_dts = [r * dx * dx / alpha for r in r_values]\n\n    results = []\n    for dt in test_dts:\n        A = crank_nicolson_first_step_amplitude(N, alpha, dt)\n        results.append(f\"{A:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2393571"}, {"introduction": "椭圆型偏微分方程，如泊松方程，通常用于描述处于平衡或稳态的系统。标准的五点差分格式是求解这类问题的常用工具。本练习采用“人造解法”（method of manufactured solutions），一种强大的数值验证技术，来揭示五点格式的一个关键局限性：其离散误差具有各向异性。这意味着格式的精度依赖于求解特征相对于计算网格的方向，这对于理解和选择合适的数值方法至关重要。[@problem_id:2393578]", "problem": "考虑单位正方形域上的二维泊松方程，其解具有强但平滑的特征，主方向与网格轴对齐或呈对角线方向。数学模型是标量场 $u(x,y)$ 在 $[0,1]\\times[0,1]$ 上的边值问题，\n$$- \\nabla^2 u(x,y) = f(x,y), \\quad (x,y)\\in (0,1)\\times(0,1),$$\n边界条件为狄利克雷边界条件 $u(x,y) = u_{\\text{exact}}(x,y)$，作用于边界 $\\partial([0,1]\\times[0,1])$ 上。拉普拉斯算子 $\\nabla^2$ 定义为 $\\nabla^2 u = \\partial^2 u / \\partial x^2 + \\partial^2 u / \\partial y^2$。您必须在均匀网格上使用标准的五点中心差分有限差分法来近似算子 $\\nabla^2$，并求解所得的线性系统以得到内部网格点上的 $u(x,y)$。\n\n使用人造解方法定义两个精确解 $u_{\\text{exact}}(x,y)$，其尖锐度由宽度参数 $\\sigma  0$ 控制，其方向为：\n- 与直线 $x=y$ 对齐的对角脊：\n  $$u_{\\mathrm{diag}}(x,y;\\sigma) = \\exp\\!\\left(-\\frac{(x-y)^2}{2\\sigma^2}\\right)。$$\n- 沿 $x$ 轴方向、中心在 $x=0.5$ 的轴对齐脊：\n  $$u_{\\mathrm{axis}}(x,y;\\sigma) = \\exp\\!\\left(-\\frac{(x-0.5)^2}{2\\sigma^2}\\right)。$$\n\n对每个人造解，通过将连续拉普拉斯算子 $\\nabla^2$ 应用于 $u_{\\text{exact}}$ 来计算其连续的右端项 $f(x,y)$，并设 $f(x,y) = -\\nabla^2 u_{\\text{exact}}(x,y)$。对于对角脊，请注意 $u_{\\mathrm{diag}}(x,y;\\sigma)$ 仅依赖于 $s=x-y$；对于函数 $g(s)$，使用恒等式 $\\partial^2 g/\\partial x^2 = g''(s)$ 和 $\\partial^2 g/\\partial y^2 = g''(s)$，这两个式子共同意味着 $\\nabla^2 g(s) = 2 g''(s)$。对于轴对齐脊，请注意 $u_{\\mathrm{axis}}(x,y;\\sigma)$ 仅依赖于 $x$，因此 $\\nabla^2 u_{\\mathrm{axis}} = \\partial^2 u_{\\mathrm{axis}}/\\partial x^2$。这些运算都是连续导数；不要使用离散近似来构造 $f(x,y)$。\n\n使用一个 $N\\times N$ 个点的均匀笛卡尔网格对区域进行离散化，网格间距为 $h = 1/(N-1)$，其中 $N$ 是一个奇数，以确保直线 $y=0.5$ 是一行网格。在内部点 $(i,j)$ 上为拉普拉斯算子构建标准的五点模板，通过将边界设置为精确的人造解来强制施加狄利克雷边界条件。仅使用标准的五点模板为内部未知数构建并求解线性系统；不要使用任何高阶或九点模板。\n\n在相同的网格和相同的 $\\sigma$ 下，为对角和轴对齐的人造解计算出数值解后，通过插入精确的边界值来重构整个网格。然后，评估以下两个逐行最大绝对误差：\n- 对角线误差 $E_{\\mathrm{diag}}$：沿着离散对角网格线 $x=y$（即索引为 $i=j$ 的节点）的数值解与精确解之间的最大绝对差，并用该线上的精确最大振幅进行归一化。对于 $u_{\\mathrm{diag}}$，沿 $x=y$ 的精确值在该线上所有点均为 $1$。\n- 轴线误差 $E_{\\mathrm{axis}}$：沿着水平线 $y=0.5$（即索引为 $j=(N-1)/2$ 的节点）的数值解与精确解之间的最大绝对差，并用该线上的精确最大振幅进行归一化。对于 $u_{\\mathrm{axis}}$，沿 $y=0.5$ 的精确峰值出现在 $x=0.5$ 处，其值为 $1$。\n\n定义失效比\n$$R(N,\\sigma) = \\frac{E_{\\mathrm{diag}}}{E_{\\mathrm{axis}}}。$$\n$R(N,\\sigma)  1$ 的值表明，五点模板对于对角对齐的尖锐特征表现出比轴对齐特征更大的误差，这证明了其网格对齐的各向异性，以及在相当分辨率下无法解析对角尖锐特征的失效。\n\n您的程序必须：\n- 实现五点中心差分法，使用相同的网格和 $\\sigma$ 求解 $u_{\\mathrm{diag}}$ 和 $u_{\\mathrm{axis}}$ 的泊松问题。\n- 为每个测试用例计算 $E_{\\mathrm{diag}}$、$E_{\\mathrm{axis}}$ 和 $R(N,\\sigma)$。\n- 按照下文规定，将所有比率作为单个列表在一行中输出。\n\n不涉及物理单位。不使用角度。所有浮点输出均以普通十进制表示法表示。\n\n用于评估覆盖范围的测试套件：\n- 用例 1（分辨率不足的对角特征）：$N=33$，$\\sigma=0.02$。\n- 用例 2（分辨率提高）：$N=65$，$\\sigma=0.02$。\n- 用例 3（粗网格上的较宽特征）：$N=33$，$\\sigma=0.04$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含与上述用例相对应的三个比率 $R(N,\\sigma)$，格式为方括号内的逗号分隔列表，每个值四舍五入到 $6$ 位小数（例如 $[r_1,r_2,r_3]$）。", "solution": "所提出的问题是一个有效且适定的数值分析练习。它涉及使用五点有限差分法求解二维泊松方程，并利用人造解方法来分析模板的各向异性误差特性。所有必需的信息都已提供，物理和数学基础稳固，目标明确且可验证。\n\n问题是在单位正方形域 $\\Omega = [0,1]\\times[0,1]$ 上求解泊松方程：\n$$ - \\nabla^2 u(x,y) = f(x,y), \\quad (x,y) \\in (0,1)\\times(0,1) $$\n边界条件为狄利克雷边界条件 $u(x,y) = u_{\\text{exact}}(x,y)$，适用于 $(x,y) \\in \\partial\\Omega$。算子 $\\nabla^2$ 是拉普拉斯算子，$\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$。\n\n这里采用了人造解方法。我们定义两个精确解 $u_{\\mathrm{diag}}$ 和 $u_{\\mathrm{axis}}$，并通过应用连续算子来推导相应的强迫函数 $f(x,y)$：$f = -\\nabla^2 u_{\\text{exact}}$。\n\n对于对角脊，$u_{\\mathrm{diag}}(x,y;\\sigma) = \\exp(-\\frac{(x-y)^2}{2\\sigma^2})$。令 $g(s) = \\exp(-s^2/(2\\sigma^2))$，其中 $s=x-y$。其导数为 $g'(s) = -\\frac{s}{\\sigma^2}g(s)$ 和 $g''(s) = (\\frac{s^2}{\\sigma^4} - \\frac{1}{\\sigma^2})g(s)$。使用恒等式 $\\nabla^2 g(x-y) = 2g''(x-y)$，强迫函数为：\n$$ f_{\\mathrm{diag}}(x,y;\\sigma) = -2 g''(x-y) = -2 \\left(\\frac{(x-y)^2}{\\sigma^4} - \\frac{1}{\\sigma^2}\\right) \\exp\\left(-\\frac{(x-y)^2}{2\\sigma^2}\\right) = 2\\left(\\frac{1}{\\sigma^2} - \\frac{(x-y)^2}{\\sigma^4}\\right) \\exp\\left(-\\frac{(x-y)^2}{2\\sigma^2}\\right) $$\n\n对于轴对齐脊，$u_{\\mathrm{axis}}(x,y;\\sigma) = \\exp(-\\frac{(x-0.5)^2}{2\\sigma^2})$。该函数仅依赖于 $x$。令 $h(x) = \\exp(-(x-0.5)^2/(2\\sigma^2))$。拉普拉斯算子为 $\\nabla^2 h(x) = \\frac{d^2h}{dx^2}$。二阶导数为 $\\frac{d^2h}{dx^2} = (\\frac{(x-0.5)^2}{\\sigma^4} - \\frac{1}{\\sigma^2})h(x)$。强迫函数为：\n$$ f_{\\mathrm{axis}}(x,y;\\sigma) = -\\frac{d^2u_{\\mathrm{axis}}}{dx^2} = -\\left(\\frac{(x-0.5)^2}{\\sigma^4} - \\frac{1}{\\sigma^2}\\right) \\exp\\left(-\\frac{(x-0.5)^2}{2\\sigma^2}\\right) = \\left(\\frac{1}{\\sigma^2} - \\frac{(x-0.5)^2}{\\sigma^4}\\right) \\exp\\left(-\\frac{(x-0.5)^2}{2\\sigma^2}\\right) $$\n\n该域使用一个具有 $N \\times N$ 个点的均匀笛卡尔网格进行离散化，其中 $N$ 是一个奇数。网格间距为 $h = 1/(N-1)$。设网格点为 $(x_i, y_j) = (ih, jh)$，其中 $i,j \\in \\{0, 1, \\dots, N-1\\}$。设 $U_{i,j}$ 为 $u(x_i, y_j)$ 的数值近似。\n\n在内部网格点 $(x_i, y_j)$ (其中 $i,j \\in \\{1, \\dots, N-2\\}$) 处，负拉普拉斯算子的标准 $5$ 点中心差分近似为：\n$$ -\\nabla^2 u(x_i, y_j) \\approx \\frac{-U_{i+1,j} - U_{i-1,j} - U_{i,j+1} - U_{i,j-1} + 4U_{i,j}}{h^2} $$\n将其设为等于强迫项 $f(x_i, y_j) = f_{i,j}$，得到离散方程：\n$$ 4U_{i,j} - U_{i+1,j} - U_{i-1,j} - U_{i,j+1} - U_{i,j-1} = h^2 f_{i,j} $$\n必须求解这个线性方程组，以得到 $(N-2) \\times (N-2)$ 个未知的内部值 $U_{i,j}$。边界上的值（其中 $i=0, i=N-1, j=0$ 或 $j=N-1$）由狄利克雷条件给出，即 $U_{i,j} = u_{\\text{exact}}(x_i, y_j)$。这些已知的边界值被移到与边界相邻的内部点方程的右侧。\n\n这导出了一个形式为 $A\\mathbf{u} = \\mathbf{b}$ 的线性系统，其中 $\\mathbf{u}$ 是一个包含 $(N-2)^2$ 个未知内部网格值的向量，$A$ 是一个大小为 $(N-2)^2 \\times (N-2)^2$ 的稀疏、对称正定、块三对角矩阵，而 $\\mathbf{b}$ 是一个包含了强迫项 $f$ 和边界条件的右端向量。矩阵 $A$ 的主对角线元素为 $4$，对应于 $5$ 点模板中四个邻居的元素为 $-1$。这个稀疏系统通过数值方法求解。\n\n在求解出内部值之后，通过将内部解嵌入到已知的精确边界值中，重构出完整的数值解网格。\n\n然后，沿特定线评估误差。对角线误差 $E_{\\mathrm{diag}}$ 是为 $u_{\\mathrm{diag}}$ 情况计算的：\n$$ E_{\\mathrm{diag}} = \\frac{\\max_{i \\in \\{0, \\dots, N-1\\}} |U_{i,i} - u_{\\mathrm{diag}}(x_i, x_i)|}{\\max_{i} u_{\\mathrm{diag}}(x_i, x_i)} = \\max_{i} |U_{i,i} - 1| $$\n轴线误差 $E_{\\mathrm{axis}}$ 是为 $u_{\\mathrm{axis}}$ 情况沿直线 $y=0.5$ 计算的，该直线对应于网格索引 $j_{\\text{mid}} = (N-1)/2$：\n$$ E_{\\mathrm{axis}} = \\frac{\\max_{i \\in \\{0, \\dots, N-1\\}} |U_{i,j_{\\text{mid}}} - u_{\\mathrm{axis}}(x_i, y_{j_{\\text{mid}}})|}{\\max_{i} u_{\\mathrm{axis}}(x_i, y_{j_{\\text{mid}}})} = \\max_{i} |U_{i,j_{\\text{mid}}} - u_{\\mathrm{axis}}(x_i, y_{j_{\\text{mid}}})| $$\n在这两种情况下，沿各自线的精确解的归一化最大振幅均为 $1$。\n\n最后，计算失效比 $R(N,\\sigma) = E_{\\mathrm{diag}} / E_{\\mathrm{axis}}$ 以量化模板的各向异性误差。提供的程序为每个指定的测试用例实现了这整个过程。", "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef u_diag_func(X, Y, sigma):\n    \"\"\"Computes the exact solution for the diagonal ridge case.\"\"\"\n    s_sq = (X - Y)**2\n    sigma_sq = sigma**2\n    return np.exp(-s_sq / (2 * sigma_sq))\n\ndef f_diag_func(X, Y, sigma):\n    \"\"\"Computes the forcing term for the diagonal ridge case.\"\"\"\n    s_sq = (X - Y)**2\n    sigma_sq = sigma**2\n    sigma_4 = sigma**4\n    exp_term = np.exp(-s_sq / (2 * sigma_sq))\n    return 2 * (1 / sigma_sq - s_sq / sigma_4) * exp_term\n\ndef u_axis_func(X, Y, sigma):\n    \"\"\"Computes the exact solution for the axis-aligned ridge case.\"\"\"\n    z_sq = (X - 0.5)**2\n    sigma_sq = sigma**2\n    return np.exp(-z_sq / (2 * sigma_sq))\n\ndef f_axis_func(X, Y, sigma):\n    \"\"\"Computes the forcing term for the axis-aligned ridge case.\"\"\"\n    z_sq = (X - 0.5)**2\n    sigma_sq = sigma**2\n    sigma_4 = sigma**4\n    exp_term = np.exp(-z_sq / (2 * sigma_sq))\n    return (1 / sigma_sq - z_sq / sigma_4) * exp_term\n\ndef solve_poisson(N, sigma, u_exact_func, f_func):\n    \"\"\"\n    Solves the 2D Poisson equation using a 5-point finite difference stencil.\n    \"\"\"\n    h = 1.0 / (N - 1)\n    x = np.linspace(0.0, 1.0, N)\n    y = np.linspace(0.0, 1.0, N)\n    X, Y = np.meshgrid(x, y, indexing='xy')\n\n    # Evaluate exact solution and forcing term on the full grid\n    u_exact = u_exact_func(X, Y, sigma)\n    f = f_func(X, Y, sigma)\n    \n    # Number of interior points in one dimension\n    M = N - 2\n    \n    # Construct the sparse matrix A for the linear system\n    main_diag = np.ones(M) * 4\n    off_diag = np.ones(M - 1) * -1\n    T = sparse.diags([off_diag, main_diag, off_diag], [-1, 0, 1], shape=(M, M), format='csr')\n    I_M = sparse.eye(M, format='csr')\n    A = sparse.kron(I_M, T) + sparse.diags([np.ones(M*(M-1))*-1, np.ones(M*(M-1))*-1], [-M, M], format='csr')\n    A = A.tocsc()\n\n    # Construct the right-hand side vector b\n    b_2d = h**2 * f[1:-1, 1:-1]\n    \n    # Add boundary condition contributions to b\n    # Note: U[j, i] corresponds to u at (x_i, y_j)\n    b_2d[:, 0] += u_exact[1:-1, 0]   # Left boundary (x=0)\n    b_2d[:, -1] += u_exact[1:-1, -1] # Right boundary (x=1)\n    b_2d[0, :] += u_exact[0, 1:-1]   # Bottom boundary (y=0)\n    b_2d[-1, :] += u_exact[-1, 1:-1] # Top boundary (y=1)\n    \n    b = b_2d.flatten(order='F') # Flatten column-major, for (i,j) -> k=(i-1)*M+(j-1)\n\n    # Solve the linear system\n    u_vec = spsolve(A, b)\n    \n    # Reshape solution vector to grid and insert into full solution grid\n    U_interior = u_vec.reshape((M, M), order='F')\n    U_numerical = np.copy(u_exact)\n    U_numerical[1:-1, 1:-1] = U_interior\n    \n    return U_numerical, u_exact\n\ndef solve():\n    test_cases = [\n        (33, 0.02),\n        (65, 0.02),\n        (33, 0.04),\n    ]\n\n    results = []\n    for N, sigma in test_cases:\n        # Diagonal case\n        U_diag_numerical, u_exact_diag_grid = solve_poisson(N, sigma, u_diag_func, f_diag_func)\n        diag_numerical = np.diag(U_diag_numerical)\n        diag_exact = np.diag(u_exact_diag_grid)\n        E_diag = np.max(np.abs(diag_numerical - diag_exact))\n\n        # Axis-aligned case\n        U_axis_numerical, u_exact_axis_grid = solve_poisson(N, sigma, u_axis_func, f_axis_func)\n        j_mid = (N - 1) // 2\n        axis_numerical_row = U_axis_numerical[j_mid, :]\n        axis_exact_row = u_exact_axis_grid[j_mid, :]\n        E_axis = np.max(np.abs(axis_numerical_row - axis_exact_row))\n        \n        # Failure ratio\n        R = E_diag / E_axis\n        results.append(R)\n\n    # Format results for printing\n    formatted_results = [f'{r:.6f}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2393578"}]}