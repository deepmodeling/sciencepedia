{"hands_on_practices": [{"introduction": "在我们将数值代码用于科学探索之前，必须严格验证其正确性。制造解法（Method of Manufactured Solutions, MMS）是实现这一目标的一项强大技术：我们首先“制造”一个解析解，将其代入偏微分方程（如热方程 $u_t = \\alpha u_{xx} + f$）以确定一个源项 $f$，然后检查我们的代码能否准确地重现这个已知解并达到理论收敛阶。本练习 [@problem_id:3229592] 将引导你应用MMS来验证求解热方程的Crank-Nicolson格式的正确性，这是计算科学中的一项基本技能。", "problem": "考虑在一维空间区间和有限时间区间上带有制造源项的一维热方程。设热扩散率为正常数 $\\,\\alpha  0\\,$，并考虑在 $\\,x \\in [0,1]\\,$ 和 $\\,t \\in [0,T]\\,$ 上的问题，其边界条件为齐次狄利克雷（Dirichlet）边界条件。按如下方式使用制造解方法。\n\n1. 选择制造解 $\\,u(x,t) = \\exp(t)\\,\\sin(\\pi x)\\,$。定义源项 $\\,f(x,t)\\,$，使得 $\\,u\\,$ 精确满足偏微分方程 $\\,u_t = \\alpha u_{xx} + f\\,$。施加从此 $\\,u\\,$ 导出的初始条件和边界条件，即对所有 $\\,t\\,$，有 $\\,u(x,0) = \\sin(\\pi x)\\,$ 和 $\\,u(0,t) = u(1,t) = 0\\,$。\n\n2. 将 $\\,[0,1]\\,$ 离散化为 $\\,N_x\\,$ 个等宽子区间，宽度为 $\\,\\Delta x = 1/N_x\\,$，网格点为 $\\,x_i = i\\,\\Delta x\\,$，其中 $\\,i = 0,1,\\dots,N_x\\,$。将 $\\, [0,T]\\,$ 离散化为 $\\,N_t\\,$ 个等长时间步，步长为 $\\,\\Delta t = T/N_t\\,$，时间点为 $\\,t^n = n\\,\\Delta t\\,$，其中 $\\,n = 0,1,\\dots,N_t\\,$。令 $\\,u_i^n \\approx u(x_i,t^n)\\,$ 表示在内部索引 $\\,i = 1,2,\\dots,N_x-1\\,$ 和时间点 $\\,n = 0,1,\\dots,N_t\\,$ 上的数值近似解。\n\n3. 使用克兰克-尼科尔森（Crank–Nicolson）方法，即时间上的梯形法则结合空间上的二阶中心差分，来离散化内部节点处的热方程。在 $\\,x=0\\,$ 和 $\\,x=1\\,$ 处使用由制造解所确定的精确狄利克雷边界值。从精确初始条件 $\\,u_i^0 = \\sin(\\pi x_i)\\,$ 开始进行时间步进。\n\n4. 计算在最终时间 $\\,t = T\\,$ 时的离散 $\\,L^2\\,$ 误差，其定义为\n$$\nE(N_x,N_t) \\;=\\; \\left( \\Delta x \\sum_{i=0}^{N_x} \\bigl(u_i^{N_t} - u(x_i,T)\\bigr)^2 \\right)^{1/2},\n$$\n约定 $\\,u_0^{N_t} = u_{N_x}^{N_t} = 0\\,$。\n\n您的程序必须通过制造解方法估计观测到的收敛阶，从而验证在时间和空间上的二阶精度。使用以下固定参数和测试套件。\n\n- 使用 $\\,\\alpha = 1\\,$ 和 $\\,T = 0.1\\,$。\n\n- 时间阶测试套件：固定一个足够精细的空间网格 $\\,N_x = 300\\,$，并改变时间步数 $\\,N_t \\in \\{50,100,200,400,800\\}\\,$。对于每个 $\\,N_t\\,$，计算 $\\,E(N_x,N_t)\\,$，然后通过对这五个案例中 $\\,\\log E\\,$ 与 $\\,\\log \\Delta t\\,$ 的最小二乘线性拟合来估计观测到的时间阶 $\\,p_t\\,$，其中 $\\,\\Delta t = T/N_t\\,$。报告 $\\,p_t\\,$，四舍五入到两位小数。\n\n- 空间阶测试套件：固定一个足够小的时间步 $\\,N_t = 1000\\,$，并改变空间子区间数 $\\,N_x \\in \\{10,20,40,80,160\\}\\,$。对于每个 $\\,N_x\\,$，计算 $\\,E(N_x,N_t)\\,$，然后通过对这五个案例中 $\\,\\log E\\,$ 与 $\\,\\log \\Delta x\\,$ 的最小二乘线性拟合来估计观测到的空间阶 $\\,p_x\\,$，其中 $\\,\\Delta x = 1/N_x\\,$。报告 $\\,p_x\\,$，四舍五入到两位小数。\n\n- 此外，计算一个布尔类型的通过标志 `pass`，当且仅当 $\\,p_t \\ge 1.90\\,$ 和 $\\,p_x \\ge 1.90\\,$ 同时成立时，该标志为真（true）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，格式为 $[p_t,p_x,pass]$。前两个条目必须是四舍五入到两位小数的浮点数，第三个条目必须是布尔字面量，例如 $[1.99,2.01,True]$。", "solution": "用户提供的问题经评估有效。这是一个在偏微分方程数值分析领域中适定、科学上合理且完整的问题。任务是使用制造解方法验证克兰克-尼科尔森（Crank-Nicolson）方法求解一维热方程的收敛阶。\n\n分析和求解过程如下。\n\n首先，我们确定源项 $f(x,t)$，以使制造解 $u(x,t) = \\exp(t)\\sin(\\pi x)$ 精确满足控制偏微分方程 (PDE) $u_t = \\alpha u_{xx} + f(x,t)$。\n\n我们计算 $u(x,t)$ 的偏导数：\n-   关于时间 $t$ 的偏导数为：\n    $$ u_t = \\frac{\\partial}{\\partial t} \\left( \\exp(t)\\sin(\\pi x) \\right) = \\exp(t)\\sin(\\pi x) $$\n-   关于空间 $x$ 的二阶偏导数为：\n    $$ u_x = \\frac{\\partial}{\\partial x} \\left( \\exp(t)\\sin(\\pi x) \\right) = \\pi \\exp(t)\\cos(\\pi x) $$\n    $$ u_{xx} = \\frac{\\partial^2}{\\partial x^2} \\left( \\exp(t)\\sin(\\pi x) \\right) = -\\pi^2 \\exp(t)\\sin(\\pi x) $$\n\n将这些导数代入 PDE 中，得到：\n$$ \\exp(t)\\sin(\\pi x) = \\alpha \\left( -\\pi^2 \\exp(t)\\sin(\\pi x) \\right) + f(x,t) $$\n求解源项 $f(x,t)$，可得：\n$$ f(x,t) = \\exp(t)\\sin(\\pi x) + \\alpha \\pi^2 \\exp(t)\\sin(\\pi x) = (1 + \\alpha \\pi^2) \\exp(t)\\sin(\\pi x) $$\n\n接下来，我们使用克兰克-尼科尔森方法对 PDE 进行离散化。空间域 $[0,1]$ 被离散化为 $N_x$ 个宽度为 $\\Delta x = 1/N_x$ 的子区间，时间域 $[0,T]$ 被离散化为 $N_t$ 个步长为 $\\Delta t = T/N_t$ 的时间步。令 $u_i^n$ 为 $u(x_i, t^n)$ 的数值近似，其中 $x_i = i\\Delta x$ 且 $t^n = n\\Delta t$。\n\n克兰克-尼科尔森格式在空间上使用中心差分，在时间上使用梯形法则，并都在中点 $t^{n+1/2} = t^n + \\Delta t/2$ 处进行计算。这样得到的格式在时间和空间上都是二阶精确的。在内部网格点 $(x_i, t^{n+1/2})$ 处的离散方程为：\n$$ \\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\frac{\\alpha}{2} \\left( \\frac{u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}}{(\\Delta x)^2} + \\frac{u_{i+1}^{n} - 2u_i^{n} + u_{i-1}^{n}}{(\\Delta x)^2} \\right) + f(x_i, t^{n+1/2}) $$\n将源项近似为 $f(x_i, t^{n+1/2}) \\approx \\frac{1}{2}(f_i^{n+1} + f_i^n)$，其中 $f_i^n = f(x_i, t^n)$，我们得到：\n$$ \\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\frac{\\alpha}{2} \\left( D_{xx} u_i^{n+1} + D_{xx} u_i^{n} \\right) + \\frac{1}{2}(f_i^{n+1} + f_i^n) $$\n其中 $D_{xx}$ 表示二阶中心差分算子。\n\n为了求解在时间 $t^{n+1}$ 时的未知值，我们重新整理方程，将 $n+1$ 步的项移到左侧（LHS），将 $n$ 步的项移到右侧（RHS）。令 $\\nu = \\frac{\\alpha \\Delta t}{2(\\Delta x)^2}$。对于每个内部节点 $i \\in \\{1, 2, \\dots, N_x-1\\}$，方程变为：\n$$ -\\nu u_{i-1}^{n+1} + (1+2\\nu)u_i^{n+1} - \\nu u_{i+1}^{n+1} = \\nu u_{i-1}^n + (1-2\\nu)u_i^n + \\nu u_{i+1}^n + \\frac{\\Delta t}{2}(f_i^{n+1} + f_i^n) $$\n\n这个包含 $N_x-1$ 个线性方程的系统必须在每个时间步进行求解。令 $U^n = [u_1^n, u_2^n, \\dots, u_{N_x-1}^n]^T$ 为时间 $t^n$ 时内部节点的解向量。该系统可以写成矩阵形式：\n$$ A U^{n+1} = B U^n + d^n $$\n其中 $A$ 和 $B$ 是 $(N_x-1) \\times (N_x-1)$ 的三对角矩阵：\n$$ A = \\begin{pmatrix} 1+2\\nu  -\\nu   \\\\ -\\nu  1+2\\nu  -\\nu  \\\\  \\ddots  \\ddots  \\ddots \\\\   -\\nu  1+2\\nu  -\\nu \\\\    -\\nu  1+2\\nu \\end{pmatrix} $$\n$$ B = \\begin{pmatrix} 1-2\\nu  \\nu   \\\\ \\nu  1-2\\nu  \\nu  \\\\  \\ddots  \\ddots  \\ddots \\\\   \\nu  1-2\\nu  \\nu \\\\    \\nu  1-2\\nu \\end{pmatrix} $$\n向量 $d^n$ 包含离散化的源项：\n$$ d^n = \\frac{\\Delta t}{2} [f_1^{n+1}+f_1^n, \\dots, f_{N_x-1}^{n+1}+f_{N_x-1}^n]^T $$\n齐次狄利克雷边界条件 $u(0,t) = u(1,t) = 0$ 意味着对所有 $n$ 都有 $u_0^n = u_{N_x}^n = 0$。这些条件被并入系统中，因为在 $i=1$ 和 $i=N_x-1$ 的差分格式边界上，涉及 $u_0$ 和 $u_{N_x}$ 的项为零。\n\n数值模拟按以下步骤进行：\n1.  使用精确初始条件初始化 $t=0$ 时的解：$u_i^0 = u(x_i, 0) = \\sin(\\pi x_i)$，其中 $i=0, \\dots, N_x$。\n2.  对于从 $0$ 到 $N_t-1$ 的每个时间步 $n$：\n    a.  构建右侧向量 $RHS = B U^n + d^n$。\n    b.  求解线性系统 $A U^{n+1} = RHS$ 以得到未知向量 $U^{n+1}$。\n3.  在最后一个时间步之后，得到时间 $T=t^{N_t}$ 时的数值解。\n\n误差使用最终时间 $T$ 的离散 $L^2$ 范数计算：\n$$ E(N_x, N_t) = \\left( \\Delta x \\sum_{i=0}^{N_x} (u_i^{N_t} - u(x_i,T))^2 \\right)^{1/2} $$\n由于边界条件是精确施加的，求和中 $i=0$ 和 $i=N_x$ 的项为零。\n\n为了验证精度阶，我们假设误差遵循 $E \\approx C (\\Delta x)^{p_x} + D (\\Delta t)^{p_t}$ 的形式。\n-   对于时间阶测试（$p_t$），我们将 $N_x$ 固定在一个较大的值（$N_x=300$），使得空间误差项可以忽略不计。此时误差近似为 $E \\approx D (\\Delta t)^{p_t}$。取对数后，我们得到 $\\log(E) \\approx \\log(D) + p_t \\log(\\Delta t)$。我们对一系列 $N_t$ 值所对应的点 $(\\log(\\Delta t), \\log(E))$ 进行线性最小二乘拟合。所得直线的斜率即为估计的收敛阶 $p_t$。\n-   类似地，对于空间阶测试（$p_x$），我们将 $N_t$ 固定在一个较大的值（$N_t=1000$），以使时间误差项可以忽略不计。此时 $E \\approx C (\\Delta x)^{p_x}$，且 $\\log(E) \\approx \\log(C) + p_x \\log(\\Delta x)$。我们对一系列 $N_x$ 值所对应的点 $(\\log(\\Delta x), \\log(E))$ 进行线性拟合，以求得斜率 $p_x$。\n\n给定的参数为 $\\alpha=1$ 和 $T=0.1$。实现将执行这两项收敛性研究，计算 $p_t$ 和 $p_x$，并根据两个阶数均不小于 $1.90$ 的条件来确定一个通过/失败标志。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D heat equation with a manufactured solution using the Crank-Nicolson method,\n    and computes the observed orders of convergence in time and space.\n    \"\"\"\n    \n    # --- Fixed Parameters ---\n    alpha = 1.0\n    T = 0.1\n\n    # --- Manufactured Solution and Source Term ---\n    # u(x,t) = exp(t) * sin(pi*x)\n    # f(x,t) = (1 + alpha*pi*pi) * exp(t) * sin(pi*x)\n    \n    def u_exact(x, t):\n        return np.exp(t) * np.sin(np.pi * x)\n\n    def f_source(x, t, alpha_val):\n        return (1.0 + alpha_val * np.pi**2) * np.exp(t) * np.sin(np.pi * x)\n\n    def run_simulation(Nx, Nt, alpha_val, T_final):\n        \"\"\"\n        Runs a single simulation for a given Nx, Nt and returns the L2 error.\n        \"\"\"\n        # Discretization parameters\n        dx = 1.0 / Nx\n        dt = T_final / Nt\n        x = np.linspace(0, 1, Nx + 1)\n        \n        # Grid for interior points\n        x_interior = x[1:Nx]\n\n        # Initial condition\n        u_current = u_exact(x_interior, 0)\n        \n        # Crank-Nicolson matrices A (LHS) and B (RHS) for interior points\n        nu = alpha_val * dt / (2.0 * dx**2)\n        M_interior = Nx - 1\n\n        # Matrix A\n        A = np.zeros((M_interior, M_interior))\n        np.fill_diagonal(A, 1.0 + 2.0 * nu)\n        if M_interior  1:\n            A_upper = np.diag(-nu * np.ones(M_interior - 1), 1)\n            A_lower = np.diag(-nu * np.ones(M_interior - 1), -1)\n            A += A_upper + A_lower\n\n        # Matrix B\n        B = np.zeros((M_interior, M_interior))\n        np.fill_diagonal(B, 1.0 - 2.0 * nu)\n        if M_interior  1:\n            B_upper = np.diag(nu * np.ones(M_interior - 1), 1)\n            B_lower = np.diag(nu * np.ones(M_interior - 1), -1)\n            B += B_upper + B_lower\n        \n        # Time-stepping loop\n        for n in range(Nt):\n            t_current = n * dt\n            t_next = (n + 1) * dt\n            \n            # Source term vector\n            f_curr_vals = f_source(x_interior, t_current, alpha_val)\n            f_next_vals = f_source(x_interior, t_next, alpha_val)\n            d = (dt / 2.0) * (f_curr_vals + f_next_vals)\n            \n            # RHS vector\n            rhs = B @ u_current + d\n            \n            # Solve the linear system: A * u_next = rhs\n            u_next = np.linalg.solve(A, rhs)\n            \n            u_current = u_next\n            \n        # At this point, u_current is the numerical solution at t=T\n        u_numerical_final = np.zeros(Nx + 1)\n        u_numerical_final[1:Nx] = u_current\n        \n        # Exact solution at t=T\n        u_exact_final = u_exact(x, T_final)\n        \n        # Compute L2 error\n        error_vec = u_numerical_final - u_exact_final\n        l2_error = np.sqrt(dx * np.sum(error_vec**2))\n        \n        return l2_error\n\n    # --- Temporal Order Test ---\n    Nx_temp_test = 300\n    Nt_temp_list = [50, 100, 200, 400, 800]\n    \n    log_dt_temp = []\n    log_E_temp = []\n    \n    for Nt in Nt_temp_list:\n        error = run_simulation(Nx_temp_test, Nt, alpha, T)\n        dt = T / Nt\n        log_dt_temp.append(np.log(dt))\n        log_E_temp.append(np.log(error))\n        \n    # Least-squares fit to find the slope (order of convergence)\n    p_t = np.polyfit(log_dt_temp, log_E_temp, 1)[0]\n    \n    # --- Spatial Order Test ---\n    Nt_spatial_test = 1000\n    Nx_spatial_list = [10, 20, 40, 80, 160]\n    \n    log_dx_spatial = []\n    log_E_spatial = []\n    \n    for Nx in Nx_spatial_list:\n        error = run_simulation(Nx, Nt_spatial_test, alpha, T)\n        dx = 1.0 / Nx\n        log_dx_spatial.append(np.log(dx))\n        log_E_spatial.append(np.log(error))\n        \n    # Least-squares fit to find the slope\n    p_x = np.polyfit(log_dx_spatial, log_E_spatial, 1)[0]\n    \n    # --- Pass Flag ---\n    pass_flag = (p_t = 1.90) and (p_x = 1.90)\n    \n    # --- Final Output ---\n    # Format: [p_t (2dp), p_x (2dp), pass_flag]\n    print(f\"[{p_t:.2f},{p_x:.2f},{pass_flag}]\")\n\nsolve()\n\n```", "id": "3229592"}, {"introduction": "即使一个数值方法在理论上是高阶准确的，它也可能在求解如对流-扩散方程 $u_t + a u_x = \\epsilon u_{xx}$ 这类特定问题时表现不佳，特别是在对流占主导地位时。本练习 [@problem_id:3128259] 介绍了网格佩克莱数（cell Peclet number）的概念，并展示了中心差分格式如何产生非物理的数值振荡。你将通过亲手实现并比较中心差分与迎风格式，直观地理解迎风格式在保证数值解稳定性方面的重要性。", "problem": "要求您研究一维线性对流扩散偏微分方程 (PDE) $u_t + a\\,u_x = \\epsilon\\,u_{xx}$，该方程定义在域 $x \\in [0,1]$ 上，具有恒定的正平流速度 $a  0$ 和正扩散率 $\\epsilon  0$。重点关注由稳态问题产生的稳态边界层结构，该稳态问题通过设置 $u_t = 0$ 得到，即 $\\epsilon\\,u_{xx} - a\\,u_x = 0$，并带有狄利克雷边界条件 $u(0) = 1$ 和 $u(1) = 0$。您将分析随着网格佩克莱特数的增加，不同的空间有限差分离散格式的表现如何，并量化数值解中是否出现离散振荡。\n\n仅从基本定义出发，在包含 $[0,1]$ 区间上 $N$ 个点的均匀网格上，推导空间导数的一致二阶精确有限差分，网格间距为 $h = 1/(N-1)$：\n- 使用中心差分格式 (CDS) 来近似一阶导数 $u_x(x_i) \\approx \\left(u_{i+1} - u_{i-1}\\right)/(2h)$ 和二阶导数 $u_{xx}(x_i) \\approx \\left(u_{i+1} - 2u_i + u_{i-1}\\right)/h^2$。\n- 当 $a  0$ 时，对一阶导数使用迎风差分格式 (UDS) $u_x(x_i) \\approx \\left(u_i - u_{i-1}\\right)/h$，同时保持与上述相同的二阶导数近似。\n\n对于每种情况，根据稳态方程 $\\epsilon\\,u_{xx} - a\\,u_x = 0$ 在内部网格点 $x_i$ (其中 $i = 1,\\dots,N-2$) 上为内部未知数 $u_1,\\dots,u_{N-2}$ 构建三对角线性系统，并将狄利克雷边界条件 $u_0 = 1$ 和 $u_{N-1} = 0$ 直接施加到右端项中。求解该线性系统以获得离散稳态剖面 $u_i$ (其中 $i=0,\\dots,N-1$）。\n\n将网格佩克莱特数定义为 $Pe_h = \\dfrac{a\\,h}{\\epsilon}$。如果满足以下任一条件，则定义离散解是振荡的：\n- 它不是从 $x=0$ 到 $x=1$ 单调递减的，即对于所有的 $i=0,\\dots,N-2$，$\\Delta_i = u_{i+1} - u_i \\le \\tau$ 不成立，其中 $\\tau = 10^{-10}$。\n- 它在边界条件所暗示的物理一致区间之外表现出过冲或下冲，即 $\\min_i u_i  -\\tau$ 或 $\\max_i u_i  1 + \\tau$。\n\n对于下面的每个测试用例，使用 CDS 和 UDS 计算稳态解。然后使用以下整数代码对两种方法的结果进行分类：\n- $0$ 如果 CDS 无振荡且 UDS 无振荡，\n- $1$ 如果 CDS 有振荡且 UDS 无振荡，\n- $2$ 如果 CDS 有振荡且 UDS 有振荡，\n- $3$ 如果 CDS 无振荡且 UDS 有振荡。\n\n测试套件（所有参数均为无量纲）：\n- 用例 A：$a = 1$, $\\epsilon = 0.1$, $N = 41$。\n- 用例 B：$a = 5$, $\\epsilon = 0.01$, $N = 41$。\n- 用例 C：$a = 50$, $\\epsilon = 0.01$, $N = 41$。\n- 用例 D：$a = 1$, $\\epsilon = 0.0125$, $N = 41$。\n\n您的程序必须输出一行，其中包含按 A、B、C、D 顺序排列的各用例的整数代码，以逗号分隔，并用方括号括起来（例如，$[0,1,1,0]$）。在这个问题中没有需要报告的物理单位，因为参数和变量都是无量纲的。角度单位不适用。所有最终的数值输出必须是指定列表格式的整数。", "solution": "用户提供的问题是有效的，因为它有科学依据、适定且客观。它构成了偏微分方程数值分析中的一个标准练习，特别是检验用于对流扩散方程的有限差分方法的稳定性和精度。\n\n该问题研究一维稳态线性对流扩散方程：\n$$\n\\epsilon u_{xx} - a u_x = 0\n$$\n该方程定义在空间域 $x \\in [0, 1]$ 上，具有恒定的正平流速度 $a  0$ 和扩散率 $\\epsilon  0$。该方程服从狄利克雷边界条件 $u(0) = 1$ 和 $u(1) = 0$。这个边值问题的解析解已知为：\n$$\nu(x) = \\frac{e^{ax/\\epsilon} - e^{a/\\epsilon}}{1 - e^{a/\\epsilon}}\n$$\n该精确解是单调的，从 $u(0)=1$ 递减到 $u(1)=0$。因此，在数值解中观察到的任何振荡都是离散化方法产生的伪影。\n\n我们使用一个包含 $N$ 个点的均匀网格对域进行离散化，$x_i = i h$，其中 $i = 0, 1, \\dots, N-1$，网格间距为 $h = 1/(N-1)$。在这些网格点上求解数值解 $u_i \\approx u(x_i)$。边界条件固定了端点处的值：$u_0 = 1$ 和 $u_{N-1} = 0$。内部点 $u_1, \\dots, u_{N-2}$ 的解通过求解从离散化PDE导出的线性方程组得到。\n\n我们考虑在内部网格点 $x_i$ 处使用两种不同的有限差分格式来处理空间导数：\n\n1.  **中心差分格式 (CDS)**\n    该格式对一阶和二阶导数均采用二阶精确的中心差分：\n    $$\n    u_x(x_i) \\approx \\frac{u_{i+1} - u_{i-1}}{2h}, \\quad u_{xx}(x_i) \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\n    $$\n    将这些代入控制方程 $\\epsilon u_{xx} - a u_x = 0$ 中，得到：\n    $$\n    \\epsilon \\left( \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} \\right) - a \\left( \\frac{u_{i+1} - u_{i-1}}{2h} \\right) = 0\n    $$\n    乘以 $h^2$ 并合并关于 $u_{i-1}$、$u_i$ 和 $u_{i+1}$ 的项，我们得到每个内部节点 $i=1, \\dots, N-2$ 的离散方程：\n    $$\n    \\left(\\epsilon + \\frac{ah}{2}\\right) u_{i-1} - 2\\epsilon u_i + \\left(\\epsilon - \\frac{ah}{2}\\right) u_{i+1} = 0\n    $$\n    通过定义无量纲的网格佩克莱特数 $Pe_h = \\frac{ah}{\\epsilon}$（它比较了单个网格单元上对流与扩散的强度），该方程可以改写为：\n    $$\n    \\epsilon \\left( \\left(1 + \\frac{Pe_h}{2}\\right) u_{i-1} - 2 u_i + \\left(1 - \\frac{Pe_h}{2}\\right) u_{i+1} \\right) = 0\n    $$\n    一个与离散极值原理相关的关键稳定性准则要求所得矩阵的非对角线系数的符号不会导致非物理极值。对于这个方程，$u_{i+1}$ 的系数是 $(1 - Pe_h/2)$，如果 $Pe_h  2$，它将变为负数。众所周知，这种情况会导致数值解中出现伪振荡，尤其是在梯度较大的区域。\n\n2.  **迎风差分格式 (UDS)**\n    该格式对对流项采用一阶精确的后向差分（因为 $a0$，所以“迎风”方向是 $x$ 值较小的方向），对扩散项则使用相同的二阶中心差分：\n    $$\n    u_x(x_i) \\approx \\frac{u_i - u_{i-1}}{h}, \\quad u_{xx}(x_i) \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\n    $$\n    将这些近似代入控制方程得到：\n    $$\n    \\epsilon \\left( \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} \\right) - a \\left( \\frac{u_i - u_{i-1}}{h} \\right) = 0\n    $$\n    乘以 $h^2$ 并合并项，得到离散方程：\n    $$\n    (\\epsilon + ah) u_{i-1} - (2\\epsilon + ah) u_i + \\epsilon u_{i+1} = 0\n    $$\n    在这种形式下，相邻点 $u_{i-1}$ 和 $u_{i+1}$ 的系数分别为 $(\\epsilon + ah)$ 和 $\\epsilon$。由于 $a, \\epsilon, h$ 均为正数，这些系数始终为正。所得矩阵是对角占优的，并且该格式保证对于任何网格佩克莱特数值都能产生非振荡解，但代价是其精度只有一阶。\n\n对于这两种格式，都为内部未知数向量 $\\mathbf{u}_{\\text{int}} = [u_1, u_2, \\dots, u_{N-2}]^T$ 形成一个三对角线性方程组 $M \\mathbf{u}_{\\text{int}} = \\mathbf{b}$。边界条件被并入右端向量 $\\mathbf{b}$ 中。对于第一个内部节点（$i=1$），涉及 $u_0=1$ 的项被移到右侧；对于最后一个内部节点（$i=N-2$），涉及 $u_{N-1}=0$ 的项消失了。这导致一个系统中只有 $\\mathbf{b}$ 的第一个元素非零。\n\n如果解不是单调递减的（具体来说，如果对于任何 $i$ 有 $u_{i+1} - u_i  \\tau$，其中 $\\tau=10^{-10}$），或者如果它在由边界条件设定的物理界限之外表现出过冲/下冲（即 $\\min_i u_i  -\\tau$ 或 $\\max_i u_i  1 + \\tau$），则认为该解是振荡的。\n\n具体步骤是：对每个测试用例，使用 CDS 和 UDS 求解这些线性系统，检查所得解是否存在振荡，并根据两种方法的结果对分配相应的整数代码。这在提供的 Python 代码中实现，该代码使用 `scipy.linalg.solve_banded` 来高效求解三对角系统。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the 1D steady convection-diffusion equation for specified test cases\n    using Central Difference Scheme (CDS) and Upwind Difference Scheme (UDS),\n    and classifies the results based on the presence of numerical oscillations.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, epsilon, N)\n        (1.0, 0.1, 41),    # Case A\n        (5.0, 0.01, 41),   # Case B\n        (50.0, 0.01, 41),  # Case C\n        (1.0, 0.0125, 41), # Case D\n    ]\n\n    # Tolerance for oscillation checks\n    tau = 1e-10\n\n    def check_oscillatory(u_sol, tau_val):\n        \"\"\"\n        Checks if a numerical solution is oscillatory.\n\n        A solution is defined as oscillatory if:\n        1. It is not monotone decreasing, i.e., u[i+1]  u[i] + tau for some i.\n        2. It has overshoot or undershoot outside the physical bounds [0, 1].\n        \"\"\"\n        # Check for non-monotonicity\n        if np.any(np.diff(u_sol)  tau_val):\n            return True\n            \n        # Check for overshoot/undershoot\n        if np.min(u_sol)  0.0 - tau_val or np.max(u_sol)  1.0 + tau_val:\n            return True\n            \n        return False\n\n    def solve_system(a, epsilon, N, scheme):\n        \"\"\"\n        Constructs and solves the tridiagonal linear system for a given scheme.\n        \"\"\"\n        h = 1.0 / (N - 1)\n        N_int = N - 2  # Number of interior points\n        \n        # Define matrix coefficients based on the scheme\n        if scheme == 'CDS':\n            # A*u_{i-1} + B*u_i + C*u_{i+1} = 0\n            A = epsilon + a * h / 2.0\n            B = -2.0 * epsilon\n            C = epsilon - a * h / 2.0\n        elif scheme == 'UDS':\n            # A*u_{i-1} + B*u_i + C*u_{i+1} = 0\n            A = epsilon + a * h\n            B = -(2.0 * epsilon + a * h)\n            C = epsilon\n        else:\n            raise ValueError(\"Unknown scheme specified.\")\n            \n        # Create tridiagonal matrix in banded format for scipy.linalg.solve_banded\n        # For a tridiagonal matrix, (l, u) = (1, 1), so matrix `ab` has shape (3, N_int).\n        # ab[0, 1:] = upper diagonal (C)\n        # ab[1, :] = main diagonal (B)\n        # ab[2, :-1] = lower diagonal (A)\n        ab = np.zeros((3, N_int))\n        ab[0, 1:] = C\n        ab[1, :] = B\n        ab[2, :-1] = A\n        \n        # Create the right-hand side vector b\n        # For i=1: A*u_0 + B*u_1 + C*u_2 = 0 = B*u_1 + C*u_2 = -A*u_0\n        # Since u_0 = 1, the first element of b is -A.\n        # For i=N-2: A*u_{N-3} + B*u_{N-2} + C*u_{N-1} = 0\n        # Since u_{N-1} = 0, the last element remains 0.\n        b = np.zeros(N_int)\n        b[0] = -A * 1.0\n        \n        # Solve the linear system for interior points\n        u_interior = solve_banded((1, 1), ab, b)\n        \n        # Assemble the full solution vector including boundaries u_0=1 and u_{N-1}=0\n        u_full = np.concatenate(([1.0], u_interior, [0.0]))\n        \n        return u_full\n\n    results = []\n    for case in test_cases:\n        a_val, eps_val, N_val = case\n        \n        # Solve for CDS and check for oscillations\n        u_cds = solve_system(a_val, eps_val, N_val, 'CDS')\n        cds_oscillatory = check_oscillatory(u_cds, tau)\n        \n        # Solve for UDS and check for oscillations\n        u_uds = solve_system(a_val, eps_val, N_val, 'UDS')\n        uds_oscillatory = check_oscillatory(u_uds, tau)\n        \n        # Classify the outcome based on the problem's integer codes\n        code = -1\n        if not cds_oscillatory and not uds_oscillatory:\n            code = 0  # Both non-oscillatory\n        elif cds_oscillatory and not uds_oscillatory:\n            code = 1  # CDS oscillatory, UDS non-oscillatory\n        elif cds_oscillatory and uds_oscillatory:\n            code = 2  # Both oscillatory\n        elif not cds_oscillatory and uds_oscillatory:\n            code = 3  # CDS non-oscillatory, UDS oscillatory\n        \n        results.append(code)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3128259"}, {"introduction": "数值不稳定性不仅源于空间离散，时间推进格式的选择同样至关重要。备受推崇的Crank-Nicolson方法，在处理包含刚性反应项的方程（如 $u_t = \\kappa u_{xx} - \\lambda u$）或不连续初始条件时，会引入虚假的瞬时振荡。本练习 [@problem_id:3128239] 旨在揭示这一缺陷，并探索一种名为Rannacher启动的实用修正方案，从而强调了针对问题的具体特性选择合适数值方法的重要性。", "problem": "考虑一维扩散-反应偏微分方程 (PDE) $$u_t=\\kappa\\,u_{xx}-\\lambda\\,u$$，该方程定义在空间域 $$x\\in[0,1]$$ 和时间域 $$t\\in[0,T]$$ 上，带有齐次狄利克雷边界条件 $$u(0,t)=0$$ 和 $$u(1,t)=0$$，以及一个不连续的初始条件 $$u(x,0)=\\begin{cases}1,  x=0.5 \\\\ 0,  \\text{其他情况}\\end{cases}$$。由于最大值原理，对于 $\\lambda \\ge 0$，解应始终保持在 $[0,1]$ 区间内。您的任务是确定在给定参数下，数值解是否会产生违反此原理的振荡。\n\n您将比较两种时间离散化方案：\n1.  **纯克兰克-尼科尔森 (Crank-Nicolson, CN) 方法**: 从 $t=0$ 开始，全程使用标准的Crank-Nicolson格式。\n2.  **带Rannacher启动的CN方法**: 在前两个时间半步（即从 $t=0$ 到 $t=\\Delta t$），使用两次后向欧拉 (Backward Euler, BE) 格式，每次步长为 $\\Delta t/2$。之后，从 $t=\\Delta t$ 到 $T$，切换为标准的CN格式。\n\n对于空间离散化，在所有情况下都使用 $N$ 个点上的标准二阶中心差分。\n\n如果在一个时间步之后，解向量 $u^n$ 中的任何元素的值小于 $-10^{-3}$ 或大于 $1+10^{-3}$，则认为解是振荡的。\n\n您的程序必须对以下四种测试用例进行模拟，并确定每种情况下是否出现振荡。\n\n-   **用例 1**: $\\kappa=1.0$, $\\lambda=400.0$, $N=51$, $\\Delta t = 0.005$, $T=0.1$, **不使用**Rannacher启动。\n-   **用例 2**: $\\kappa=1.0$, $\\lambda=400.0$, $N=51$, $\\Delta t = 0.005$, $T=0.1$, **使用**Rannacher启动。\n-   **用例 3**: $\\kappa=1.0$, $\\lambda=0.0$, $N=51$, $\\Delta t = 0.0001$, $T=0.1$, **不使用**Rannacher启动。\n-   **用例 4**: $\\kappa=1.0$, $\\lambda=0.0$, $N=51$, $\\Delta t = 0.005$, $T=0.1$, **不使用**Rannacher启动。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的布尔值列表，格式为 `[result1,result2,result3,result4]`。如果检测到振荡，则结果为 `True`，否则为 `False`。例如 `[True,False,False,True]`。", "solution": "这个问题的目标是数值求解一维扩散-反应方程，并研究在使用克兰克-尼科尔森（Crank-Nicolson, CN）方法处理不连续初始条件时可能出现的数值振荡，以及如何通过Rannacher启动程序来抑制这些振荡。\n\n#### 1. 空间半离散化 (线方法)\n\n我们首先对空间域进行离散化。将区间 $[0,1]$ 划分为 $N$ 个点，网格间距为 $\\Delta x = 1/(N-1)$。内部格点为 $x_i = i\\Delta x$，$i=1, 2, \\dots, N-2=M$。\n我们使用二阶中心差分来近似空间二阶导数：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x_i} \\approx \\frac{u_{i-1}(t) - 2u_i(t) + u_{i+1}(t)}{(\\Delta x)^2}\n$$\n将此近似代入原偏微分方程 $u_t = \\kappa u_{xx} - \\lambda u$，并将解表示为内部节点上的向量 $\\mathbf{u}(t) = [u_1(t), u_2(t), \\dots, u_M(t)]^T$。这样，原PDE就被转化为了一个常微分方程（ODE）组：\n$$\n\\frac{d\\mathbf{u}}{dt} = \\mathbf{L}\\mathbf{u}\n$$\n其中，$\\mathbf{L}$ 是一个 $M \\times M$ 的三对角矩阵，代表了离散化的空间算子 $\\kappa \\frac{\\partial^2}{\\partial x^2} - \\lambda$。具体来说，$\\mathbf{L} = \\kappa \\mathbf{A} - \\lambda \\mathbf{I}$，其中 $\\mathbf{I}$ 是单位矩阵，$\\mathbf{A}$ 是代表二阶中心差分的矩阵：\n$$\n\\mathbf{A} = \\frac{1}{(\\Delta x)^2}\n\\begin{pmatrix}\n-2  1    \\\\\n1  -2  1   \\\\\n \\ddots  \\ddots  \\ddots  \\\\\n  1  -2  1 \\\\\n   1  -2\n\\end{pmatrix}\n$$\n齐次狄利克雷边界条件 $u(0,t)=u(1,t)=0$ 已被包含在这个矩阵的结构中。\n\n#### 2. 时间全离散化\n\n接下来，我们对上述ODE系统进行时间积分。\n\n-   **克兰克-尼科尔森 (CN) 方法**: 该方法在时间上采用梯形法则，是二阶精确且无条件稳定的。其离散格式为：\n    $$\n    \\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2}(\\mathbf{L}\\mathbf{u}^{n+1} + \\mathbf{L}\\mathbf{u}^n)\n    $$\n    整理后，得到在每个时间步需要求解的线性方程组：\n    $$\n    (\\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{L})\\mathbf{u}^{n+1} = (\\mathbf{I} + \\frac{\\Delta t}{2}\\mathbf{L})\\mathbf{u}^n\n    $$\n    尽管CN方法是无条件稳定的，但它不是L-稳定的，这意味着对于由不连续初始条件引入的高频误差分量，其衰减作用很弱，可能导致在初始阶段产生持续的、非物理的数值振荡。\n\n-   **后向欧拉 (BE) 方法**: 该方法是一阶精确、无条件稳定且L-稳定的。其离散格式为：\n    $$\n    \\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\mathbf{L}\\mathbf{u}^{n+1}\n    $$\n    整理后得到线性方程组：\n    $$\n    (\\mathbf{I} - \\Delta t \\mathbf{L})\\mathbf{u}^{n+1} = \\mathbf{u}^n\n    $$\n    BE方法的强耗散特性（L-稳定性）能够有效地抑制高频振荡，但其精度仅为一阶。\n\n-   **Rannacher启动**: 该策略结合了BE和CN的优点。在模拟的最初几个时间步（本题中为两个半步，即总共一个 $\\Delta t$ 的时间），使用强耗散的后向欧拉方法来快速平滑由不连续初始条件引起的振荡。之后，再切换到二阶精确的Crank-Nicolson方法进行后续的时间演化，以保证整体的计算精度。\n\n#### 3. 初始条件和振荡检测\n\n初始条件是一个在 $x=0.5$ 处的离散狄拉克δ函数。在离散网格上，这意味着只有位于或最接近 $x=0.5$ 的那个内部格点 $u_j$ 的初始值为1，其余所有点（包括边界）的初始值均为0。\n\n根据最大值原理，对于 $\\lambda \\ge 0$，该PDE的解应始终保持在初始值的范围 $[0, 1]$ 内。任何超出这个区间的数值解（考虑到浮点误差，设定一个小的容差，如 $10^{-3}$）都被认为是数值振荡。代码通过检查 `min(u)  -1e-3` 或 `max(u) > 1 + 1e-3` 来检测振荡。\n\n#### 4. 算法流程\n\n对于每个测试用例：\n1.  根据给定的参数 $\\kappa, \\lambda, N, \\Delta t, T$ 设置网格和矩阵 $\\mathbf{L}$。\n2.  根据离散狄拉克δ函数设置初始解向量 $\\mathbf{u}^0$。\n3.  如果 `use_rannacher` 为真：\n    a.  执行两步时间步长为 $\\Delta t/2$ 的后向欧拉方法。\n    b.  在每半步后检查解是否出现振荡。如果出现，则记录并终止该用例。\n    c.  将时间推进到 $t=\\Delta t$。\n4.  从 $t=0$ （如果未使用Rannacher）或 $t=\\Delta t$ （如果使用了Rannacher）开始，使用Crank-Nicolson方法迭代直到最终时间 $T$。\n5.  在每个CN时间步后，检查解是否出现振荡。如果出现，则记录并终止。\n6.  如果整个模拟过程都没有检测到振荡，则该用例的结果为无振荡。\n7.  最后，根据每个用例是否检测到振荡，输出一个布尔值列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, identity\nfrom scipy.sparse.linalg import spsolve\n\ndef run_simulation(kappa, lambda_val, N, dt, T, use_rannacher):\n    \"\"\"\n    Solves the 1D diffusion-reaction equation and detects oscillations.\n\n    Args:\n        kappa (float): Diffusion coefficient.\n        lambda_val (float): Reaction coefficient.\n        N (int): Number of spatial grid points.\n        dt (float): Time step size.\n        T (float): Final time.\n        use_rannacher (bool): Flag to enable/disable Rannacher startup.\n\n    Returns:\n        bool: True if oscillations are detected, False otherwise.\n    \"\"\"\n    # Grid setup\n    dx = 1.0 / (N - 1)\n    M = N - 2  # Number of interior points\n    x_interior = np.linspace(dx, 1.0 - dx, M)\n\n    # Initial condition for interior points\n    u_current = np.zeros(M)\n    # Find the index closest to x=0.5\n    mid_idx = np.abs(x_interior - 0.5).argmin()\n    u_current[mid_idx] = 1.0\n\n    # The maximum principle for this PDE with lambda = 0 implies the solution\n    # should remain between 0 and 1. We check for violations of this principle beyond a tolerance.\n    oscillation_min_thresh = -1.0e-3\n    oscillation_max_thresh = 1.0 + 1.0e-3\n\n    def check_oscillation(u_vec):\n        return np.min(u_vec)  oscillation_min_thresh or np.max(u_vec)  oscillation_max_thresh\n\n    # Spatial discretization matrix A for u_xx using second-order central differences.\n    # The matrix is of size (M x M) for the M interior points.\n    diagonals = [np.ones(M - 1), -2 * np.ones(M), np.ones(M - 1)]\n    A = diags(diagonals, [-1, 0, 1], shape=(M, M), format='csc') / (dx**2)\n\n    # Full semi-discrete system matrix L = kappa*A - lambda*I\n    Id = identity(M, format='csc')\n    L = kappa * A - lambda_val * Id\n\n    # Time-stepping\n    num_steps = int(round(T / dt))\n    \n    start_step_cn = 0\n    if use_rannacher:\n        # Rannacher startup: two Backward Euler half-steps\n        dt_half = dt / 2.0\n        M_BE_half = Id - dt_half * L\n\n        # First half-step from t=0 to t=dt/2\n        u_half = spsolve(M_BE_half, u_current, use_umfpack=False)\n        if check_oscillation(u_half):\n            return True\n        \n        # Second half-step from t=dt/2 to t=dt\n        u_next = spsolve(M_BE_half, u_half, use_umfpack=False)\n        if check_oscillation(u_next):\n            return True\n        \n        u_current = u_next\n        start_step_cn = 1 # CN loop will start from the second full time step\n    \n    # Crank-Nicolson for the remaining steps\n    M_CN_lhs = Id - (dt / 2.0) * L\n    M_CN_rhs = Id + (dt / 2.0) * L\n    \n    for _ in range(start_step_cn, num_steps):\n        rhs_vector = M_CN_rhs.dot(u_current)\n        u_next = spsolve(M_CN_lhs, rhs_vector, use_umfpack=False)\n        \n        if check_oscillation(u_next):\n            return True\n            \n        u_current = u_next\n\n    return False\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Stiff reaction, large dt, CN only - Expect oscillations\n        {'kappa': 1.0, 'lambda_val': 400.0, 'N': 51, 'dt': 0.005, 'T': 0.1, 'use_rannacher': False},\n        # Case 2: Stiff reaction, large dt, CN with Rannacher - Expect no oscillations\n        {'kappa': 1.0, 'lambda_val': 400.0, 'N': 51, 'dt': 0.005, 'T': 0.1, 'use_rannacher': True},\n        # Case 3: No reaction, small dt, CN only - Expect no oscillations\n        {'kappa': 1.0, 'lambda_val': 0.0, 'N': 51, 'dt': 0.0001, 'T': 0.1, 'use_rannacher': False},\n        # Case 4: No reaction, large dt, CN only - Expect oscillations\n        {'kappa': 1.0, 'lambda_val': 0.0, 'N': 51, 'dt': 0.005, 'T': 0.1, 'use_rannacher': False},\n    ]\n\n    results = []\n    for case in test_cases:\n        # A small correction to the provided code to handle the IC correctly.\n        # The original code had an issue with `x_interior == 0.5` which fails with floating point inaccuracies\n        # if the grid is not perfectly centered. `argmin` is more robust.\n        # The provided code seems to implicitly rely on N=51 where x=0.5 is a grid point.\n        # I will keep the original logic but add this note. The provided code is being corrected here.\n        \n        # Correction in run_simulation:\n        # u_current = np.zeros(M)\n        # u_current[x_interior == 0.5] = 1.0 \n        # is replaced by a more robust version:\n        # mid_idx = np.abs(x_interior - 0.5).argmin()\n        # u_current[mid_idx] = 1.0\n        # For N=51, this gives the same result. The code in this file is updated.\n        result = run_simulation(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3128239"}]}