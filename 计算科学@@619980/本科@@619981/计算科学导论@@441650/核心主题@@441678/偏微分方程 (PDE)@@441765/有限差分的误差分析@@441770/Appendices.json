{"hands_on_practices": [{"introduction": "在数值微分中，选择步长 $h$ 是一个核心挑战。一方面，减小 $h$ 可以降低截断误差，使近似更接近真实导数；另一方面，过小的 $h$ 会导致舍入误差急剧增加，因为计算机在处理两个几乎相等的数的减法时会丢失精度。这个练习 [@problem_id:2389525] 让你通过一个简化的误差模型，亲手计算出平衡这两种误差的最佳步长 $h_{\\mathrm{opt}}$，从而直观地理解数值计算中的这一基本权衡。", "problem": "考虑使用中心差分公式对一个足够光滑的标量函数 $f(x)$ 在点 $x_0$ 处的一阶导数进行近似\n$$\nD_h f(x_0) \\equiv \\frac{f(x_0+h)-f(x_0-h)}{2h}.\n$$\n假设 $D_h f(x_0)$ 的绝对误差具有以下主阶误差模型：\n$$\nE(h) = K_t h^2 + \\frac{K_r u}{h},\n$$\n其中 $K_t = \\frac{\\lvert f^{(3)}(x_0)\\rvert}{6}$，$K_r = \\lvert f(x_0)\\rvert$，$u$ 是用于计算 $f$ 的浮点运算的单位舍入误差。使用以下单位舍入误差值：对于双精度（IEEE 754 binary64），$u_{\\mathrm{double}} = 2^{-53}$；对于四倍精度（IEEE 754 binary128），$u_{\\mathrm{quad}} = 2^{-113}$。角度必须以弧度为单位进行解释。\n\n对于下面列出的每个测试用例，分别针对双精度和四倍精度，计算在所述模型下最小化 $E(h)$ 的步长 $h_{\\mathrm{opt}}$。您的程序必须以指定的格式输出这些值。\n\n测试套件（每个用例指定了 $f$、$x_0$ 以及适用的角度单位）：\n- 用例 $1$：$f(x) = \\sin(x)$，$x_0 = 1$（弧度）。\n- 用例 $2$：$f(x) = \\sin(x)$，$x_0 = 10^{-12}$（弧度）。\n- 用例 $3$：$f(x) = \\cosh(x)$，$x_0 = 3$。\n\n要求的最终输出格式：\n- 生成一个单行，其中包含一个用方括号括起来的逗号分隔列表，顺序如下\n$$\n[h_{\\mathrm{double},1},h_{\\mathrm{quad},1},h_{\\mathrm{double},2},h_{\\mathrm{quad},2},h_{\\mathrm{double},3},h_{\\mathrm{quad},3}],\n$$\n其中 $h_{\\mathrm{double},k}$ 和 $h_{\\mathrm{quad},k}$ 分别表示用例 $k$ 在双精度和四倍精度下的最小化步长。\n- 将每个数字以科学记数法表示，并精确到 $10$ 位有效数字（例如，$1.234567890\\times 10^{-5}$ 必须打印为类似于 $1.2345678900e-05$ 的形式）。", "solution": "提交分析的问题陈述经过了严格的验证。\n\n**步骤 1：提取已知条件**\n- **近似公式**：一阶导数的中心差分，$D_h f(x_0) \\equiv \\frac{f(x_0+h)-f(x_0-h)}{2h}$。\n- **误差模型**：绝对误差 $E(h) = K_t h^2 + \\frac{K_r u}{h}$。\n- **误差系数**：$K_t = \\frac{\\lvert f^{(3)}(x_0)\\rvert}{6}$ 和 $K_r = \\lvert f(x_0)\\rvert$。\n- **单位舍入误差值**：\n    - 双精度：$u_{\\mathrm{double}} = 2^{-53}$。\n    - 四倍精度：$u_{\\mathrm{quad}} = 2^{-113}$。\n- **角度单位**：角度以弧度为单位。\n- **任务**：对于每个测试用例，分别计算双精度和四倍精度下最小化 $E(h)$ 的步长 $h_{\\mathrm{opt}}$。\n- **测试用例**：\n    1. $f(x) = \\sin(x)$ 于 $x_0 = 1$。\n    2. $f(x) = \\sin(x)$ 于 $x_0 = 10^{-12}$。\n    3. $f(x) = \\cosh(x)$ 于 $x_0 = 3$。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题在根本上是合理的。它探讨了数值分析中的一个经典主题：数值微分中截断误差和舍入误差之间的权衡。所提供的误差模型 $E(h)$ 是一个标准的一阶近似，其中 $h^2$ 项代表中心差分格式的截断误差，$u/h$ 项代表舍入误差。中心差分公式的泰勒级数展开证实了截断误差是 $O(h^2)$ 阶的，而舍入误差模型是一个被广泛接受的简化模型。\n- **适定性**：存在唯一且有意义的解。对于 $h>0$，函数 $E(h)$ 是两个正项之和，其中一项随 $h$ 增加而增加，另一项则减少。这种结构保证了在 $h \\in (0, \\infty)$ 区间内存在唯一的最小值，可以通过微积分求得。\n- **客观性**：该问题使用精确的数学语言陈述，没有任何主观性或歧义。\n\n**步骤 3：结论与行动**\n该问题具有科学依据，适定、客观且自成体系。它是一个有效的计算物理和数值分析问题。因此，我将着手解决它。\n\n目标是找到最小化总绝对误差函数 $E(h)$ 的步长，我们将其表示为 $h_{\\mathrm{opt}}$。误差函数给出如下：\n$$\nE(h) = K_t h^2 + \\frac{K_r u}{h}\n$$\n为了找到最小值，我们必须计算 $E(h)$ 对 $h$ 的导数，并将其设为零。这将给出函数的临界点。\n$$\n\\frac{dE}{dh} = \\frac{d}{dh} \\left( K_t h^2 + K_r u h^{-1} \\right) = 2 K_t h - K_r u h^{-2}\n$$\n将导数设为零，得到最优步长 $h_{\\mathrm{opt}}$：\n$$\n2 K_t h_{\\mathrm{opt}} - \\frac{K_r u}{h_{\\mathrm{opt}}^2} = 0\n$$\n假定 $h_{\\mathrm{opt}} \\neq 0$，我们可以重新整理方程：\n$$\n2 K_t h_{\\mathrm{opt}}^3 = K_r u\n$$\n$$\nh_{\\mathrm{opt}}^3 = \\frac{K_r u}{2 K_t}\n$$\n求解 $h_{\\mathrm{opt}}$ 得：\n$$\nh_{\\mathrm{opt}} = \\left( \\frac{K_r u}{2 K_t} \\right)^{1/3}\n$$\n为确认这是一个最小值，我们检查二阶导数：\n$$\n\\frac{d^2E}{dh^2} = 2 K_t + 2 K_r u h^{-3}\n$$\n由于 $K_t = \\frac{\\lvert f^{(3)}(x_0)\\rvert}{6} \\ge 0$，$K_r = \\lvert f(x_0)\\rvert \\ge 0$，$u > 0$ 且 $h > 0$，因此对于所有有效的测试用例（其中 $K_t$ 和 $K_r$ 不会同时为零），$\\frac{d^2E}{dh^2} > 0$ 成立。因此，该临界点对应一个局部最小值。\n\n现在，我们代入 $K_t$ 和 $K_r$ 的表达式：\n$$\nh_{\\mathrm{opt}} = \\left( \\frac{\\lvert f(x_0)\\rvert u}{2 \\left( \\frac{\\lvert f^{(3)}(x_0)\\rvert}{6} \\right)} \\right)^{1/3} = \\left( \\frac{3 \\lvert f(x_0)\\rvert u}{\\lvert f^{(3)}(x_0)\\rvert} \\right)^{1/3}\n$$\n只要 $f^{(3)}(x_0) \\neq 0$，此公式就有效。我们将此公式应用于每个测试用例。\n\n**用例 1：$f(x) = \\sin(x)$ 于 $x_0 = 1$**\n函数及其三阶导数分别为 $f(x) = \\sin(x)$ 和 $f^{(3)}(x) = -\\cos(x)$。在 $x_0=1$ 处：\n- $\\lvert f(x_0) \\rvert = \\lvert\\sin(1)\\rvert$\n- $\\lvert f^{(3)}(x_0) \\rvert = \\lvert-\\cos(1)\\rvert = \\lvert\\cos(1)\\rvert$\n由于 $1$ 弧度在第一象限，$\\sin(1)$ 和 $\\cos(1)$ 均为正。\n$$\nh_{\\mathrm{opt}} = \\left( \\frac{3 \\sin(1) u}{\\cos(1)} \\right)^{1/3} = \\left( 3 u \\tan(1) \\right)^{1/3}\n$$\n计算 $u = u_{\\mathrm{double}} = 2^{-53}$ 和 $u = u_{\\mathrm{quad}} = 2^{-113}$ 时的值。\n\n**用例 2：$f(x) = \\sin(x)$ 于 $x_0 = 10^{-12}$**\n导数与用例 1 相同。在 $x_0=10^{-12}$ 处：\n- $\\lvert f(x_0) \\rvert = \\lvert\\sin(10^{-12})\\rvert \\approx 10^{-12} > 0$\n- $\\lvert f^{(3)}(x_0) \\rvert = \\lvert-\\cos(10^{-12})\\rvert = \\cos(10^{-12}) \\approx 1$\n条件 $f^{(3)}(x_0) \\neq 0$ 得到满足。\n$$\nh_{\\mathrm{opt}} = \\left( \\frac{3 \\sin(10^{-12}) u}{\\cos(10^{-12})} \\right)^{1/3} = \\left( 3 u \\tan(10^{-12}) \\right)^{1/3}\n$$\n计算 $u = u_{\\mathrm{double}}$ 和 $u = u_{\\mathrm{quad}}$ 时的值。\n\n**用例 3：$f(x) = \\cosh(x)$ 于 $x_0 = 3$**\n函数及其三阶导数分别为 $f(x) = \\cosh(x)$ 和 $f^{(3)}(x) = \\sinh(x)$。在 $x_0=3$ 处：\n- $\\lvert f(x_0) \\rvert = \\lvert\\cosh(3)\\rvert = \\cosh(3)$\n- $\\lvert f^{(3)}(x_0) \\rvert = \\lvert\\sinh(3)\\rvert = \\sinh(3)$\n$\\cosh(3)$ 和 $\\sinh(3)$ 均为正，且 $\\sinh(3) \\neq 0$。\n$$\nh_{\\mathrm{opt}} = \\left( \\frac{3 \\cosh(3) u}{\\sinh(3)} \\right)^{1/3} = \\left( 3 u \\coth(3) \\right)^{1/3}\n$$\n计算 $u = u_{\\mathrm{double}}$ 和 $u = u_{\\mathrm{quad}}$ 时的值。\n\n最后一步是对这六个值进行编程计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the optimal step size h_opt that minimizes the error in the\n    central difference approximation of the first derivative, based on a\n    leading-order error model.\n    \"\"\"\n\n    # Define unit roundoff values for double and quadruple precision\n    u_double = 2**-53\n    u_quad = 2**-113\n\n    # The general formula for the optimal step size is derived as:\n    # h_opt = (3 * |f(x0)| * u / |f'''(x0)|)^(1/3)\n\n    # Test suite: each tuple contains (function_name, function, third_derivative, x0)\n    test_cases = [\n        (\"sin(x) at x=1\", np.sin, lambda x: -np.cos(x), 1.0),\n        (\"sin(x) at x=1e-12\", np.sin, lambda x: -np.cos(x), 1e-12),\n        (\"cosh(x) at x=3\", np.cosh, np.sinh, 3.0),\n    ]\n\n    results = []\n    precisions = [u_double, u_quad]\n\n    for name, f, f3, x0 in test_cases:\n        # Evaluate the absolute values of the function and its third derivative at x0\n        # The problem statement guarantees f'''(x0) is not zero for the given cases.\n        abs_f_x0 = np.abs(f(x0))\n        abs_f3_x0 = np.abs(f3(x0))\n        \n        # Check for division by zero, although not expected for these cases.\n        if abs_f3_x0 == 0:\n            # If f'''(x0) is zero, the error model is inappropriate.\n            # Handle this as an invalid case within the computation.\n            # For this problem, we rely on the problem setter's guarantee.\n            # For a more robust solver, this would raise an error.\n            h_opt_double = np.nan\n            h_opt_quad = np.nan\n        else:\n            # Ratio of function value to third derivative value\n            ratio = abs_f_x0 / abs_f3_x0\n\n            # Calculate h_opt for double precision\n            arg_double = 3 * ratio * u_double\n            h_opt_double = np.cbrt(arg_double)\n\n            # Calculate h_opt for quadruple precision\n            arg_quad = 3 * ratio * u_quad\n            h_opt_quad = np.cbrt(arg_quad)\n        \n        results.append(h_opt_double)\n        results.append(h_opt_quad)\n\n    # Format the output as a comma-separated list in brackets,\n    # with each number in scientific notation with 10 significant digits.\n    # The format specifier \"{:.9e}\" provides 1 digit before the decimal\n    # and 9 digits after, for a total of 10 significant digits.\n    formatted_results = [f\"{val:.9e}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2389525"}, {"introduction": "有限差分法的误差不仅取决于步长 $h$，还与被微分函数本身的特性密切相关。一个方法的收敛阶数（例如 $O(h^2)$）告诉我们误差如何随 $h$ 变化，但误差的实际大小还依赖于函数的高阶导数。这个练习 [@problem_id:2389561] 通过比较低频函数 $\\sin(x)$ 和高频函数 $\\sin(100x)$ 的数值微分误差，生动地展示了为什么快速变化的函数更难精确近似，这是在科学计算实践中必须考虑的关键点。", "problem": "你需要分析和比较有限差分导数近似在应用于两个不同频率的正弦函数时的数值误差。考虑函数 $f_1(x) = \\sin(x)$ 和 $f_2(x) = \\sin(100x)$。角度必须以弧度为单位进行解释。对于一个点 $x$ 和一个步长 $h$，使用中心有限差分公式来近似导数 $f'(x)$：\n$$\nD_h[f](x) = \\frac{f(x+h) - f(x-h)}{2h}.\n$$\n对于下面列出的每个测试用例，通过将数值近似与精确导数进行比较，计算每个函数的绝对误差。精确导数为 $f_k'(x) = k \\cos(kx)$，其中 $f_k(x) = \\sin(kx)$ 且 $k \\in \\{1, 100\\}$。将函数 $f_k$ 在 $(x,h)$ 处的绝对误差定义为\n$$\nE_k(x,h) = \\left| D_h[f_k](x) - f_k'(x) \\right|.\n$$\n对于每个测试用例，计算并报告比率\n$$\nR(x,h) = \\frac{E_{100}(x,h)}{E_{1}(x,h)}.\n$$\n使用以下 $(x,h)$ 对的测试套件，其中所有 $x$ 均以弧度为单位，所有 $h$ 均为无量纲：\n- 测试 $1$：$x = 0$，$h = 10^{-1}$。\n- 测试 $2$：$x = 0$，$h = 10^{-6}$。\n- 测试 $3$：$x = 1.0$，$h = 10^{-3}$。\n- 测试 $4$：$x = \\frac{\\pi}{3}$，$h = 10^{-5}$。\n- 测试 $5$：$x = 2.0$，$h = 10^{-4}$。\n- 测试 $6$：$x = \\frac{\\pi}{8}$，$h = 10^{-8}$。\n\n你的程序必须按给定顺序为每个测试用例计算 $R(x,h)$，并生成单行输出，其中包含用方括号括起来的、以逗号分隔的十进制数列表，每个数四舍五入到八位有效数字。例如，输出格式必须为\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5,\\text{result}_6].\n$$\n每个 $\\text{result}_i$ 必须是一个实数（浮点数）。不应打印任何其他文本。", "solution": "所陈述的问题具有科学依据、提法恰当、客观，并包含得出唯一解所需的所有必要信息。这是一个计算物理学中的标准问题，涉及有限差分近似的误差分析。因此，该问题是有效的，我们着手进行求解。\n\n该问题要求比较在使用中心有限差分公式近似两个函数 $f_1(x) = \\sin(x)$ 和 $f_{100}(x) = \\sin(100x)$ 的导数时的数值误差：\n$$\nD_h[f](x) = \\frac{f(x+h) - f(x-h)}{2h}\n$$\n分析的核心在于理解此近似的截断误差。我们通过考虑 $f(x+h)$ 和 $f(x-h)$ 在点 $x$ 附近的泰勒级数展开来推导此误差：\n$$\nf(x+h) = f(x) + hf'(x) + \\frac{h^2}{2!}f''(x) + \\frac{h^3}{3!}f'''(x) + \\frac{h^4}{4!}f^{(4)}(x) + \\frac{h^5}{5!}f^{(5)}(x) + O(h^6)\n$$\n$$\nf(x-h) = f(x) - hf'(x) + \\frac{h^2}{2!}f''(x) - \\frac{h^3}{3!}f'''(x) + \\frac{h^4}{4!}f^{(4)}(x) - \\frac{h^5}{5!}f^{(5)}(x) + O(h^6)\n$$\n从第一个展开式中减去第二个展开式，得到：\n$$\nf(x+h) - f(x-h) = 2hf'(x) + \\frac{2h^3}{3!}f'''(x) + \\frac{2h^5}{5!}f^{(5)}(x) + O(h^7)\n$$\n除以 $2h$ 得到数值导数的表达式：\n$$\nD_h[f](x) = f'(x) + \\frac{h^2}{6}f'''(x) + \\frac{h^4}{120}f^{(5)}(x) + O(h^6)\n$$\n因此，截断误差 $E(x,h) = |D_h[f](x) - f'(x)|$ 为：\n$$\nE(x,h) = \\left| \\frac{h^2}{6}f'''(x) + \\frac{h^4}{120}f^{(5)}(x) + \\dots \\right|\n$$\n对于足够小的步长 $h$，误差由首项主导，我们可以将其近似为：\n$$\nE(x,h) \\approx \\left| \\frac{h^2}{6}f'''(x) \\right|\n$$\n这表明中心差分格式具有 $O(h^2)$ 阶的截断误差。\n\n让我们将这个一般结果应用于函数 $f_k(x) = \\sin(kx)$，其中 $k \\in \\{1, 100\\}$。\n其导数为：\n- $f_k'(x) = k \\cos(kx)$\n- $f_k''(x) = -k^2 \\sin(kx)$\n- $f_k'''(x) = -k^3 \\cos(kx)$\n将三阶导数代入误差近似公式，得到 $f_k$ 的误差：\n$$\nE_k(x,h) \\approx \\left| \\frac{h^2}{6}(-k^3 \\cos(kx)) \\right| = \\frac{h^2 k^3}{6}|\\cos(kx)|\n$$\n我们需要计算比率 $R(x,h) = E_{100}(x,h) / E_1(x,h)$。使用上述近似：\n$$\nR(x,h) \\approx \\frac{\\frac{h^2 (100^3)}{6}|\\cos(100x)|}{\\frac{h^2 (1^3)}{6}|\\cos(x)|} = 100^3 \\frac{|\\cos(100x)|}{|\\cos(x)|}\n$$\n该近似预测，比率 $R(x,h)$ 的数量级应为 $100^3 = 1,000,000$，并受三角函数项的调制，前提是 $\\cos(x)$ 不接近于零，并且 $O(h^2)$ 误差项确实占主导地位。后一个条件成立的条件是，总误差不由机器精度（舍入）效应主导，且自变量 $kh$ 足够小以使泰勒级数快速收敛。\n\n无需泰勒展开即可找到误差的精确表达式。对于 $f_k(x) = \\sin(kx)$：\n$$\nD_h[f_k](x) = \\frac{\\sin(k(x+h)) - \\sin(k(x-h))}{2h} = \\frac{\\sin(kx+kh) - \\sin(kx-kh)}{2h}\n$$\n使用恒等式 $\\sin(A) - \\sin(B) = 2\\cos\\left(\\frac{A+B}{2}\\right)\\sin\\left(\\frac{A-B}{2}\\right)$，我们发现：\n$$\nD_h[f_k](x) = \\frac{2\\cos(kx)\\sin(kh)}{2h} = \\cos(kx) \\frac{\\sin(kh)}{h}\n$$\n于是，精确误差为：\n$E_k(x,h) = |D_h[f_k](x) - f_k'(x)| = \\left| \\cos(kx) \\frac{\\sin(kh)}{h} - k \\cos(kx) \\right| = |\\cos(kx)| \\left| \\frac{\\sin(kh)}{h} - k \\right|$。\n这个公式对于截断误差是精确的。然而，计算机上的数值计算会受到有限精度的影响。\n\n这对测试套件带来了两个重要的考虑因素：\n1.  **$O(h^2)$ 近似的有效性：** $\\frac{\\sin(y)}{y}$ 的泰勒展开是 $1 - \\frac{y^2}{6} + \\dots$。近似 $E \\propto h^2$ 仅在 $y=kh$ 很小（$kh \\ll 1$）时有效。对于测试 1，其中 $k=100$ 且 $h=10^{-1}$，我们有 $kh=10$，这并不小。因此，简单的比率预测 $100^3$ 将不成立。对于所有其他测试，$kh \\le 0.1$，该近似预计会更准确。\n2.  **舍入误差：** 对于非常小的 $h$，例如测试 6 中的 $h=10^{-8}$，计算 $f(x+h)-f(x-h)$ 会遭受灾难性抵消，因为它是两个几乎相等的数之差。舍入误差的量级为 $\\epsilon_m/h$（其中 $\\epsilon_m$ 是机器精度），它可能变得比量级为 $h^2$ 的截断误差更大。\n\n我们来具体分析测试 6（$x = \\pi/8$，$h=10^{-8}$）。\n对于 $f_{100}(x)$，截断误差与 $f_{100}'''(x) = -100^3 \\cos(100x)$ 成正比。在 $x=\\pi/8$ 处，$100x = 100\\pi/8 = 25\\pi/2$。由于 $\\cos(25\\pi/2) = \\cos(12\\pi + \\pi/2) = 0$，截断误差的首项 $O(h^2)$ 消失了。事实上，$f_{100}(x)$ 在 $x=\\pi/8$ 处的所有奇数阶导数都为零。这意味着解析截断误差恰好为零。\n因此，整个计算误差 $E_{100}(\\pi/8, h)$ 均由舍入误差构成。该误差近似为 $E_{100, RO} \\approx \\frac{\\epsilon_m |\\sin(100\\pi/8)|}{h} = \\frac{\\epsilon_m}{h}$。\n对于 $f_1(x)$，截断误差为 $E_{1, trunc} \\approx \\frac{h^2}{6}|\\cos(\\pi/8)| = \\frac{(10^{-8})^2}{6}|\\cos(\\pi/8)| \\approx O(10^{-17})$。舍入误差为 $E_{1, RO} \\approx \\frac{\\epsilon_m |\\sin(\\pi/8)|}{h} \\approx \\frac{10^{-16} \\times 0.38}{10^{-8}} \\approx O(10^{-9})$。\n对于两个函数，在 $h=10^{-8}$ 时，舍入误差显然占主导地位。因此，比率可近似为舍入误差的比率：\n$$\nR(\\pi/8, 10^{-8}) \\approx \\frac{E_{100, RO}}{E_{1, RO}} \\approx \\frac{\\epsilon_m |\\sin(100\\pi/8)|/h}{\\epsilon_m |\\sin(\\pi/8)|/h} = \\frac{|\\sin(25\\pi/2)|}{|\\sin(\\pi/8)|} = \\frac{1}{\\sin(\\pi/8)} \\approx 2.613\n$$\n下面的代码实现了对每个测试用例的误差 $E_1(x,h)$ 和 $E_{100}(x,h)$ 及其比率 $R(x,h)$ 的直接计算，使用的是标准的双精度浮点运算。其结果将反映上述理论考量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes and compares the numerical error of a finite difference\n    derivative approximation for two sinusoidal functions.\n    \"\"\"\n\n    # Define the two functions as per the problem statement.\n    # f_k(x) = sin(k*x)\n    def f1(x):\n        return np.sin(x)\n\n    def f100(x):\n        return np.sin(100 * x)\n\n    # Define the exact derivatives.\n    # f_k'(x) = k*cos(k*x)\n    def df1_exact(x):\n        return np.cos(x)\n\n    def df100_exact(x):\n        return 100 * np.cos(100 * x)\n\n    # Define the centered finite difference formula.\n    def centered_difference(f, x, h):\n        \"\"\"\n        Computes the numerical derivative of function f at point x with step size h.\n        \"\"\"\n        return (f(x + h) - f(x - h)) / (2 * h)\n\n    # List of test cases (x, h)\n    test_cases = [\n        (0.0, 1e-1),\n        (0.0, 1e-6),\n        (1.0, 1e-3),\n        (np.pi / 3, 1e-5),\n        (2.0, 1e-4),\n        (np.pi / 8, 1e-8),\n    ]\n\n    results = []\n    for x, h in test_cases:\n        # Compute numerical derivatives\n        d1_num = centered_difference(f1, x, h)\n        d100_num = centered_difference(f100, x, h)\n\n        # Compute exact derivatives\n        d1_true = df1_exact(x)\n        d100_true = df100_exact(x)\n        \n        # Compute absolute errors for each function\n        E1 = np.abs(d1_num - d1_true)\n        E100 = np.abs(d100_num - d100_true)\n\n        # Check for division by zero, although analysis suggests it won't occur.\n        if E1 == 0.0:\n            # If E1 is zero, the ratio is ill-defined.\n            # This could happen if the numerical derivative is perfect.\n            # However, with finite h and non-special x, this is unlikely.\n            # If E100 is also zero, ratio is 1, otherwise it is infinity.\n            # We handle this case by appending a placeholder if it ever occurs.\n            if E100 == 0.0:\n                R = 1.0 # Or another sensible value like 0/0 -> NaN\n            else:\n                R = np.inf\n        else:\n            # Compute the ratio of the errors\n            R = E100 / E1\n        \n        results.append(R)\n\n    # Format the final output string as a comma-separated list of numbers\n    # rounded to 8 significant digits, enclosed in brackets.\n    output_str = \"[\" + \",\".join(f\"{res:.8g}\" for res in results) + \"]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```", "id": "2389561"}, {"introduction": "理解了误差的来源后，下一步自然是设计更精确的数值方法来减小误差。这个高级练习 [@problem_id:3125013] 将指导你使用“待定系数法”来构建一个更高阶的有限差分格式。通过要求该格式对更高次数的多项式精确成立，我们可以系统地推导出其系数，并获得一个比标准中心差分法收敛更快的四阶精度方法，这为你将来设计和分析自定义数值方案奠定了基础。", "problem": "考虑一个在包含点 $x_0 \\in \\mathbb{R}$ 的开区间上的实解析函数 $u$，以及一个间距为 $h > 0$ 的均匀网格。您需要构建一个线性有限差分格式，仅使用四个邻近点 $x_0 \\pm h$ 和 $x_0 \\pm 2h$ 处的函数值来近似一阶导数 $u'(x_0)$。该格式必须对所有次数最高为 $m=4$ 的多项式都精确。从导数的定义和解析函数存在收敛泰勒级数出发，仅使用对称性和多项式精确性要求来确定您的格式的系数。\n\n然后，通过将 $u$ 在 $x_0$ 周围展开成泰勒级数，并识别残差中的第一个非零项，来推导您对解析函数 $u$ 的有限差分近似的截断误差。将截断误差的主阶项表示为关于 $h$ 和在 $x_0$ 处求值的 $u$ 的导数的单个闭式解析表达式。\n\n最后，解释在何种条件下，增加多项式精确度 $m$ 会提高对解析函数 $u$ 的近似准确性，以及何时这种增加可能不会带来实际的准确性提升。您的解释必须依赖于截断误差关于 $h$ 的阶数和 $u$ 的光滑性，而不能引用任何快捷公式。\n\n作为最终答案，请提供您的格式的截断误差主阶项，用关于 $h$ 和在 $x_0$ 处求值的 $u$ 的导数的符号表示。", "solution": "该问题要求构建和分析一个有限差分格式。在继续之前，我们必须验证问题陈述的有效性。\n\n首先，我们从问题陈述中逐字提取给定的信息：\n- 函数：在包含点 $x_0 \\in \\mathbb{R}$ 的开区间上的一个实解析函数 $u$。\n- 网格：一个间距为 $h > 0$ 的均匀网格。\n- 格式点：$x_0 \\pm h$ 和 $x_0 \\pm 2h$。\n- 目标：近似一阶导数 $u'(x_0)$。\n- 约束：格式必须是线性的。\n- 约束：格式必须对所有次数最高为 $m=4$ 的多项式都精确。\n- 方法论：使用对称性和多项式精确性。\n- 任务 1：确定格式的系数。\n- 任务 2：推导截断误差的主阶项。\n- 任务 3：解释当增加多项式精确度 $m$ 时，准确性提高的条件。\n\n接下来，我们验证这些给定的信息和问题结构。\n- **科学基础**：该问题牢固地植根于数值分析和微积分的原理，特别是泰勒定理和用于有限差分格式的待定系数法。这些都是标准的、完善的概念。\n- **适定性**：该问题是适定的。我们为四个指定点寻求四个未知系数。问题指定使用对称性。对于近似奇数阶导数的中心格式，系数必须是反对称的，这将独立未知数的数量减少到两个。对次数最高为 $m=4$ 的多项式精确的要求提供了足够的约束来唯一确定这些系数。随后的截断误差推导是一个直接的解析过程。\n- **客观性**：该问题使用精确、无歧义的数学语言陈述，不含主观或基于意见的内容。\n- **完备性与一致性**：该问题提供了推导唯一解所需的所有必要信息和约束，没有任何内部矛盾。\n\n问题陈述在科学上是合理的、适定的、客观的和完备的。它没有违反任何无效性标准。因此，该问题被认为是有效的。\n\n我们现在开始求解。一个使用点 $x_0 \\pm h$ 和 $x_0 \\pm 2h$ 来近似一阶导数 $u'(x_0)$ 的线性有限差分格式可以写为：\n$$ D_h u(x_0) = c_{-2} u(x_0 - 2h) + c_{-1} u(x_0 - h) + c_1 u(x_0 + h) + c_2 u(x_0 + 2h) $$\n问题指定了点围绕 $x_0$ 的对称排列。为了近似一阶导数（如果函数本身是偶数或奇数，一阶导数在关于微分点的反射下是奇函数），我们对格式系数施加反对称性：$c_{-k} = -c_k$。这得到 $c_{-1} = -c_1$ 和 $c_{-2} = -c_2$。格式简化为：\n$$ D_h u(x_0) = c_1 (u(x_0+h) - u(x_0-h)) + c_2 (u(x_0+2h) - u(x_0-2h)) $$\n我们有两个未知系数，$c_1$ 和 $c_2$。为了确定它们，我们强制要求该格式对次数最高为 $m=4$ 的多项式 $p(x)$ 精确。根据线性性质，只需对一组多项式基（例如 $\\{x^k\\}_{k=0}^4$）进行测试。由于导数算子具有平移不变性，我们可以不失一般性地设 $x_0=0$。精确的导数值是 $p'(0)$。\n\n对于 $p(x)=x^k$，$p'(0) = 1$ 当 $k=1$ 时成立，$p'(0)=0$ 当 $k \\neq 1$ 时成立。\n对于 $k=0$ ($p(x)=1$): $D_h p(0) = c_1(1-1) + c_2(1-1) = 0$。这与 $p'(0)=0$ 相匹配。\n对于 $k=2$ ($p(x)=x^2$): $D_h p(0) = c_1(h^2 - (-h)^2) + c_2((2h)^2 - (-2h)^2) = 0$。这与 $p'(0)=0$ 相匹配。\n由于格式的反对称形式，对于任何偶数次幂 $k=2n$，同样的结果都成立。因此，该格式自动对 $p(x)=x^0$、$p(x)=x^2$ 和 $p(x)=x^4$ 精确。\n\n我们只需要考虑奇数次幂。\n对于 $k=1$ ($p(x)=x$): $p'(0)=1$。我们要求 $D_h p(0) = 1$。\n$$ c_1(h - (-h)) + c_2(2h - (-2h)) = 1 \\implies 2h c_1 + 4h c_2 = 1 $$\n$$ 2 c_1 + 4 c_2 = \\frac{1}{h} \\quad (1) $$\n对于 $k=3$ ($p(x)=x^3$): $p'(0)=0$。我们要求 $D_h p(0) = 0$。\n$$ c_1(h^3 - (-h)^3) + c_2((2h)^3 - (-2h)^3) = 0 \\implies c_1(2h^3) + c_2(16h^3) = 0 $$\n$$ c_1 + 8 c_2 = 0 \\implies c_1 = -8 c_2 \\quad (2) $$\n将 $(2)$ 代入 $(1)$：\n$$ 2(-8 c_2) + 4 c_2 = \\frac{1}{h} \\implies -16 c_2 + 4 c_2 = \\frac{1}{h} \\implies -12 c_2 = \\frac{1}{h} $$\n这得到 $c_2 = -\\frac{1}{12h}$。\n从 $(2)$，我们得到 $c_1 = -8(-\\frac{1}{12h}) = \\frac{8}{12h} = \\frac{2}{3h}$。\n这些系数是 $c_1 = \\frac{2}{3h}$，$c_{-1} = -\\frac{2}{3h}$，$c_2 = -\\frac{1}{12h}$，以及 $c_{-2} = \\frac{1}{12h}$。\n该有限差分格式为：\n$$ D_h u(x_0) = \\frac{1}{12h} [ u(x_0-2h) - 8u(x_0-h) + 8u(x_0+h) - u(x_0+2h) ] $$\n\n接下来，我们推导截断误差 $\\tau = D_h u(x_0) - u'(x_0)$。由于 $u$ 是解析函数，我们可以使用其在 $x_0$ 附近的泰勒级数展开。令 $u^{(k)}_0 = u^{(k)}(x_0)$。\n$$ u(x_0 \\pm \\delta) = u(x_0) \\pm \\delta u^{(1)}_0 + \\frac{\\delta^2}{2!} u^{(2)}_0 \\pm \\frac{\\delta^3}{3!} u^{(3)}_0 + \\frac{\\delta^4}{4!} u^{(4)}_0 \\pm \\frac{\\delta^5}{5!} u^{(5)}_0 + O(\\delta^6) $$\n我们计算格式所需的差分：\n$$ u(x_0+\\delta) - u(x_0-\\delta) = 2\\delta u^{(1)}_0 + \\frac{2\\delta^3}{3!} u^{(3)}_0 + \\frac{2\\delta^5}{5!} u^{(5)}_0 + O(\\delta^7) $$\n将此代入形式 $D_h u(x_0) = c_1 [u(x_0+h) - u(x_0-h)] + c_2 [u(x_0+2h) - u(x_0-2h)]$：\n$$ D_h u(x_0) = \\frac{2}{3h} \\left( 2h u^{(1)}_0 + \\frac{h^3}{3} u^{(3)}_0 + \\frac{h^5}{60} u^{(5)}_0 \\right) - \\frac{1}{12h} \\left( 4h u^{(1)}_0 + \\frac{8h^3}{3} u^{(3)}_0 + \\frac{32h^5}{60} u^{(5)}_0 \\right) + O(h^6) $$\n我们按 $u$ 的导数阶数收集项：\n$u^{(1)}_0$ 的系数：$\\frac{2}{3h}(2h) - \\frac{1}{12h}(4h) = \\frac{4}{3} - \\frac{1}{3} = 1$。格式已正确归一化。\n$u^{(3)}_0$ 的系数：$\\frac{2}{3h}\\left(\\frac{h^3}{3}\\right) - \\frac{1}{12h}\\left(\\frac{8h^3}{3}\\right) = \\frac{2h^2}{9} - \\frac{8h^2}{36} = \\frac{2h^2}{9} - \\frac{2h^2}{9} = 0$。这证实了格式对三次多项式是精确的。\n$u^{(5)}_0$ 的系数：这将是主误差项。\n$$ \\frac{2}{3h}\\left(\\frac{h^5}{60}\\right) - \\frac{1}{12h}\\left(\\frac{32h^5}{60}\\right) = \\frac{2h^4}{180} - \\frac{32h^4}{720} = \\frac{h^4}{90} - \\frac{4h^4}{90} = -\\frac{3h^4}{90} = -\\frac{h^4}{30} $$\n所以，该格式的展开式为：\n$$ D_h u(x_0) = u^{(1)}_0 - \\frac{h^4}{30} u^{(5)}_0 + O(h^6) $$\n截断误差为 $\\tau = D_h u(x_0) - u^{(1)}_0$。因此，主阶项为 $-\\frac{1}{30}h^4 u^{(5)}(x_0)$。这表明该方法是四阶精确的，这对于一个对次数最高为 $m=4$ 的多项式精确的对称格式是符合预期的。\n\n最后，我们解释在何种条件下，增加多项式精确度 $m$ 会提高准确性。\n增加 $m$ 通常会提高有限差分格式的精度阶数 $p$。对于一阶导数的中心格式，阶数 $p$ 是偶数，截断误差的形式为 $\\tau \\approx C_p h^p u^{(p+1)}(x_0) + O(h^{p+2})$，其中 $C_p$ 是一个常数。对于我们的格式，$m=4$ 得到 $p=4$。一个低阶格式，例如 $m=2$ 的格式，其精度阶数 $p=2$，误差为 $\\tau \\approx C_2 h^2 u^{(3)}(x_0)$。\n增加 $m$ (从而增加 $p$) 的主要优点是，当网格间距 $h$ 趋近于零时，由于 $h$ 的更高次幂，误差项会急剧减小。对于足够小的 $h$，高阶方法总是更精确。\n\n然而，对于任意的 $h$，并不能保证实际准确性的提高。实际误差的大小取决于整个项 $C_p h^p u^{(p+1)}(x_0)$。\n- **$u$ 的光滑性**：在此背景下，“光滑性”一词指的是 $u$ 的导数的行为。如果解析函数 $u$ 的高阶导数在量级上增长非常快，那么 $h^p$ 因子的优势可能会被抵消。例如，将一个二阶方法（误差 $\\propto h^2 u^{(3)}(x_0)$）与我们的四阶方法（误差 $\\propto h^4 u^{(5)}(x_0)$）进行比较，如果 $|u^{(5)}(x_0)| \\gg |u^{(3)}(x_0)|$，那么对于一个中等大小的 $h$ 值，四阶方法可能反而不那么精确。只有当 $h$ 小到足以使 $h^4$ 因子能够克服 $u^{(5)}(x_0)$ 的巨大数值时，高阶方法才会变得更优越。\n- **渐近区域**：对于紧区间上的任何解析函数，其导数是有界的。因此，总存在一个足够小的 $h$ 值，使得高阶方法更为精确。然而，如果函数的导数增长迅速，这个“渐近区域”可能需要一个不切实际的小 $h$ 值。例如，对于高振荡函数，其导数可能非常大，这使得低阶方法更可取，除非将 $h$ 做得极小以解析这些振荡。\n\n总而言之，当 $h$ 小到足以使代数收敛率 $h^p$ 超过与高阶导数 $u^{(p+1)}(x_0)$ 的量级相关的解析因子时，增加多项式精确度 $m$ 才能提高准确性。对于更光滑的函数（那些具有良好性态、不会急剧增大的导数的函数），此条件在更宽的实际 $h$ 值范围内都得到满足。", "answer": "$$\\boxed{-\\frac{1}{30}h^4 u^{(5)}(x_0)}$$", "id": "3125013"}]}