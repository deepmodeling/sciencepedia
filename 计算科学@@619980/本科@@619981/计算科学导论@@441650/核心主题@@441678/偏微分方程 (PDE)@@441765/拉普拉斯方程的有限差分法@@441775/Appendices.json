{"hands_on_practices": [{"introduction": "将拉普拉斯方程离散化后，我们会得到一个大型线性方程组。虽然可以直接求解，但迭代法（如雅可比法）提供了一种概念上更简单、执行上更循序渐进的求解路径。本练习旨在让你通过一次亲手计算，直观地体验迭代法如何通过不断取其邻近点的平均值来逐步逼近问题的解，从而掌握有限差分迭代求解的核心机制。[@problem_id:2172039]", "problem": "考虑一个确定方形无电荷区域内静电势 $u(x,y)$ 的问题。该电势满足二维拉普拉斯方程：\n$$\n\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = 0\n$$\n该区域被离散化为一个由点 $(x_i, y_j)$ 组成的均匀网格，其中对于 $i,j \\in \\{0, 1, 2, 3\\}$，有 $x_i = i \\cdot h$ 和 $y_j = j \\cdot h$。网格间距 $h$ 是恒定的。该网格产生四个内部点：$(x_1, y_1)$、$(x_1, y_2)$、$(x_2, y_1)$ 和 $(x_2, y_2)$。设这些网格点上的电势表示为 $u_{ij} = u(x_i, y_j)$。\n\n边界上的电势是固定的。与内部网格点相邻的边界点上的值如下所示：\n- 在左边界上：$u_{0,1} = 21.0$ V 和 $u_{0,2} = 21.0$ V。\n- 在右边界上：$u_{3,1} = 41.0$ V 和 $u_{3,2} = 41.0$ V。\n- 在下边界上：$u_{1,0} = 9.0$ V 和 $u_{2,0} = 9.0$ V。\n- 在上边界上：$u_{1,3} = 81.0$ V 和 $u_{2,3} = 81.0$ V。\n\n使用标准的五点中心差分公式来近似拉普拉斯方程，该公式将一个内部点的电势与其四个最近邻点联系起来。使用 Jacobi 方法来求解所得的线性方程组。\n\n对于所有四个内部点（其中 $i,j \\in \\{1,2\\}$），从初始猜测 $u_{ij}^{(0)} = 0$ V 开始，计算经过一次完整的 Jacobi 方法迭代后这些点的电势数值。\n\n按此特定顺序提供 $u_{11}, u_{12}, u_{21}, u_{22}$ 的更新电势值。最终答案应为一组四个数字。最终答案中不要包含单位。", "solution": "在均匀网格上使用标准五点中心差分格式离散化的二维拉普拉斯方程，对于内部节点 $(i,j)$，可得：\n$$\n\\frac{u_{i+1,j}-2u_{i,j}+u_{i-1,j}}{h^{2}}+\\frac{u_{i,j+1}-2u_{i,j}+u_{i,j-1}}{h^{2}}=0,\n$$\n这可以简化为平均关系式\n$$\nu_{i,j}=\\frac{1}{4}\\left(u_{i+1,j}+u_{i-1,j}+u_{i,j+1}+u_{i,j-1}\\right).\n$$\nJacobi 迭代使用前一次迭代的邻近点值来更新每个内部点：\n$$\nu_{i,j}^{(k+1)}=\\frac{1}{4}\\left(u_{i+1,j}^{(k)}+u_{i-1,j}^{(k)}+u_{i,j+1}^{(k)}+u_{i,j-1}^{(k)}\\right),\n$$\n边界值保持不变。对于 $i,j\\in\\{1,2\\}$，初始猜测为 $u_{ij}^{(0)}=0$ 并结合给定的边界数据，第一次迭代的更新如下：\n\n对于 $u_{11}$：\n$$\nu_{11}^{(1)}=\\frac{1}{4}\\left(u_{21}^{(0)}+u_{01}+u_{12}^{(0)}+u_{10}\\right)=\\frac{1}{4}\\left(0+21+0+9\\right)=7.5.\n$$\n\n对于 $u_{12}$：\n$$\nu_{12}^{(1)}=\\frac{1}{4}\\left(u_{22}^{(0)}+u_{02}+u_{13}+u_{11}^{(0)}\\right)=\\frac{1}{4}\\left(0+21+81+0\\right)=25.5.\n$$\n\n对于 $u_{21}$：\n$$\nu_{21}^{(1)}=\\frac{1}{4}\\left(u_{31}+u_{11}^{(0)}+u_{22}^{(0)}+u_{20}\\right)=\\frac{1}{4}\\left(41+0+0+9\\right)=12.5.\n$$\n\n对于 $u_{22}$：\n$$\nu_{22}^{(1)}=\\frac{1}{4}\\left(u_{32}+u_{12}^{(0)}+u_{23}+u_{21}^{(0)}\\right)=\\frac{1}{4}\\left(41+0+81+0\\right)=30.5.\n$$\n\n因此，从零开始经过一次 Jacobi 迭代后，按 $(u_{11},u_{12},u_{21},u_{22})$ 顺序排列的更新电势为 $(7.5,25.5,12.5,30.5)$。", "answer": "$$\\boxed{\\begin{pmatrix} 7.5 & 25.5 & 12.5 & 30.5 \\end{pmatrix}}$$", "id": "2172039"}, {"introduction": "迭代法虽然强大，但如果其背后的数学问题本身是“病态”的，求解过程仍可能会失败。本练习将引导你探讨一个经典案例：一个在全部边界上只规定了法向导数（即诺伊曼条件）的拉普拉斯问题。通过诊断为何一个看似合理的数值求解器会停滞不前，你将深入理解解的唯一性和相容性条件等关键概念，并认识到这些抽象的数学原理与物理守恒定律之间深刻的内在联系。[@problem_id:3128839]", "problem": "一个团队正在方形域 $\\Omega = [0,1]\\times[0,1]$ 上使用有限差分法 (FDM) 求解拉普拉斯方程。他们在一个间距为 $h$ 的均匀笛卡尔网格上，使用标准的 $5$ 点模板对内部区域离散化 $\\nabla^2 u = 0$，并通过使用带鬼点的二阶精度单边差分在所有边界上施加 Neumann 边界条件 $\\frac{\\partial u}{\\partial n} = g$。得到的线性系统形式为 $A u = b$，其中 $A$ 由离散拉普拉斯算子组装而成，$b$ 通过 Neumann 条件的施加包含了边界通量数据 $g$。\n\n当他们对边界 $\\partial\\Omega$ 上规定了非平凡边界通量 $g$ 的情况运行迭代求解器时，求解器报告系数矩阵是奇异的，或者残差停滞不收敛。任务是诊断为何求解器在全 Neumann 边界条件下会失败，找出缺失的相容性要求，并提出在保留原控制方程和物理模型的前提下的最小修复方案。\n\n下列哪个陈述正确地诊断了该问题并提出了可接受的补救措施？选择所有适用项。\n\nA. 由 $5$ 点拉普拉斯算子和纯 Neumann 边界条件构建的线性系统是奇异的，因为常数向量位于其零空间中；为保证唯一性，需要固定一个可加常数。\n\nB. 失败是由于网格间距 $h$ 太大；简单地细化网格将消除奇异性并保证收敛。\n\nC. 可解性的一个必要相容性条件是，沿边界 $\\partial\\Omega$ 的法向通量净积分必须为零；如果边界数据违反了此条件，则解不存在。\n\nD. 在保留控制方程的前提下，一个最小的修复方案是施加一个线性约束，例如 $\\int_{\\Omega} u \\,\\mathrm{d}\\Omega = 0$ 或固定一个节点的值，从而使矩阵 $A$ 变为非奇异。\n\nE. 添加一个小的反应项并求解 $\\nabla^2 u - \\varepsilon u = 0$（其中 $\\varepsilon > 0$）既能确保唯一性，又能保持原始物理模型不变；这是一个可接受的修复方案。\n\nF. 如果边界数据违反了可解性条件，可以通过减去其平均通量，将其投影到相容子空间上，以使离散净通量为零；这将为原始的拉普拉斯方程产生一个可解的问题。", "solution": "对问题陈述的有效性进行评估。\n\n**步骤 1：提取已知条件**\n- 控制方程：拉普拉斯方程，$\\nabla^2 u = 0$。\n- 区域：方形域，$\\Omega = [0,1]\\times[0,1]$。\n- 离散化：在间距为 $h$ 的均匀笛卡尔网格上使用有限差分法 (FDM)。\n- 内部模板：标准 $5$ 点模板。\n- 边界条件：在所有边界 $\\partial\\Omega$ 上施加 Neumann 边界条件，$\\frac{\\partial u}{\\partial n} = g$。\n- 边界实现：使用带鬼点的二阶精度单边差分。\n- 线性系统：$A u = b$，其中 $A$ 来自离散拉普拉斯算子，$b$ 来自边界通量 $g$。\n- 观察到的现象：对于非平凡通量 $g$，迭代求解器失败（奇异矩阵或残差停滞）。\n- 目标：诊断失败原因，确定相容性要求，并提出在保留原控制方程和物理模型的前提下的最小修复方案。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题是偏微分方程数值分析中的一个标准问题。带有纯 Neumann 边界条件的拉普拉斯方程是一个经典的椭圆问题，其可解性和唯一性问题是其理论的基础。所有概念在数学和计算科学中都已成熟。\n- **适定性：** 问题陈述是适定的。它清晰地描述了一个物理和数值设置以及由此导致的失败，并要求基于已建立的理论进行正确诊断。\n- **客观性：** 语言正式、技术性强，没有任何主观或模糊的术语。\n- **完整性和一致性：** 所提供的信息是充分且一致的。关于拉普拉斯方程的纯 Neumann 问题导致奇异矩阵的描述是一个众所周知且预期的结果。\n\n**步骤 3：结论与行动**\n问题陈述内部一致、科学上合理且适定。它是一个有效的待分析问题。\n\n**控制原理推导**\n\n该问题涉及在区域 $\\Omega$ 上求解拉普拉斯方程 $\\nabla^2 u = 0$，其边界 $\\partial\\Omega$ 上具有纯 Neumann 边界条件 $\\frac{\\partial u}{\\partial n} = g$。\n\n这个连续问题表述存在两个基本问题，这些问题会传递到其离散形式中。\n\n1.  **解的非唯一性：** 如果 $u(x,y)$ 是一个解，那么对于任意常数 $C$，函数 $v(x,y) = u(x,y) + C$ 也是一个解。这是因为拉普拉斯算子作用于常数结果为零，即 $\\nabla^2(u+C) = \\nabla^2 u + \\nabla^2 C = 0 + 0 = 0$，并且法向导数也不受影响，即 $\\frac{\\partial(u+C)}{\\partial n} = \\frac{\\partial u}{\\partial n} = g$。因此，纯 Neumann 问题的解只在相差一个可加常数的意义下是唯一的。\n\n2.  **可解性条件：** 边界数据 $g$ 必须满足一个约束条件，解才可能存在。将散度定理（或 Green 第一恒等式）应用于控制方程，我们得到：\n    $$ \\int_\\Omega \\nabla^2 u \\, d\\Omega = \\int_{\\partial\\Omega} \\nabla u \\cdot \\mathbf{n} \\, dS = \\int_{\\partial\\Omega} \\frac{\\partial u}{\\partial n} \\, dS $$\n    由于在 $\\Omega$ 内处处有 $\\nabla^2 u = 0$，所以左边为零。代入边界条件，我们得到一个必要相容性条件：\n    $$ \\int_{\\partial\\Omega} g \\, dS = 0 $$\n    这意味着穿过边界的总净通量必须为零。如果不满足这个条件，该偏微分方程没有解。\n\n当使用有限差分法将问题离散化后，这两个问题在线性系统 $A u = b$ 中表现出来。\n\n1.  **矩阵 $A$ 的奇异性：** 由 $5$ 点模板和指定的 Neumann 边界条件构建的离散拉普拉斯算子具有这样的性质：矩阵 $A$ 的每一行系数之和为零。这意味着如果 $\\mathbf{1}$ 是一个所有分量都为 1 的向量，那么 $A\\mathbf{1} = \\mathbf{0}$。这表明常数向量 $\\mathbf{1}$ 位于 $A$ 的零空间中，因此 $\\det(A) = 0$，矩阵 $A$ 是奇异的。这直接对应于连续解的非唯一性。\n\n2.  **线性系统的相容性：** 线性系统 $A u = b$ 有解的充要条件是向量 $b$ 位于 $A$ 的列空间（值域）中。对于像 $A$ 这样的对称矩阵，这等价于 $b$ 与 $A$ 的零空间正交。由于零空间包含向量 $\\mathbf{1}$，可解性条件变为 $\\mathbf{1}^T b = 0$，即 $\\sum_i b_i = 0$。向量 $b$ 是由边界通量数据 $g$ 构建的。这个离散求和是连续积分条件 $\\int_{\\partial\\Omega} g \\, dS = 0$ 的数值模拟。如果 $\\mathbf{1}^T b \\neq 0$，系统就是不相容的，迭代求解器通常会表现出不收敛或残差停滞。\n\n**选项评估**\n\n**A. 由 $5$ 点拉普拉斯算子和纯 Neumann 边界条件构建的线性系统是奇异的，因为常数向量位于其零空间中；为保证唯一性，需要固定一个可加常数。**\n该陈述是对唯一性问题的精确且正确的诊断。如上所述，离散算子作用于常数向量结果为零，这意味着矩阵 $A$ 存在一个包含全1向量的非平凡零空间。具有非平凡零空间的矩阵是奇异的。这种奇异性反映了解决方案仅在相差一个可加常数的意义下是确定的，必须固定这个常数以确保唯一性。\n**结论：正确**\n\n**B. 失败是由于网格间距 $h$ 太大；简单地细化网格将消除奇异性并保证收敛。**\n该陈述是错误的。矩阵 $A$ 的奇异性是在纯 Neumann 条件下离散拉普拉斯算子的一个内在代数性质。$A\\mathbf{1} = \\mathbf{0}$ 这个性质无论网格间距 $h$ 的值是多少都成立。细化网格会增大矩阵 $A$ 的尺寸，但新的、更大的矩阵同样会因为相同的根本原因而奇异。网格细化不会改变零空间的结构。\n**结论：错误**\n\n**C. 可解性的一个必要相容性条件是，沿边界 $\\partial\\Omega$ 的法向通量净积分必须为零；如果边界数据违反了此条件，则解不存在。**\n该陈述正确地指出了从散度定理推导出的可解性条件。条件 $\\int_{\\partial\\Omega} g \\, dS = 0$ 是对数据 $g$ 的一个基本约束。如果违反了这个物理守恒定律，数学问题就是不适定的，解不存在。求解器残差的停滞是试图求解这样一个不相容系统的数值表现。\n**结论：正确**\n\n**D. 在保留控制方程的前提下，一个最小的修复方案是施加一个线性约束，例如 $\\int_{\\Omega} u \\,\\mathrm{d}\\Omega = 0$ 或固定一个节点的值，从而使矩阵 $A$ 变为非奇异。**\n该陈述为非唯一性问题提出了标准且有效的补救措施。固定单个节点的值（例如，$u_{i_0, j_0} = C$）和对解强制施加零均值条件（$\\int_{\\Omega} u \\,d\\Omega = 0$ 的离散形式）都是单一的线性约束，它们能从解空间中移除常数项。这有效地从修正后系统的矩阵的零空间中移除了常数向量，使其变为非奇异，从而使解唯一。关键是，这些修复方法不改变原始的控制方程 $\\nabla^2 u = 0$。\n**结论：正确**\n\n**E. 添加一个小的反应项并求解 $\\nabla^2 u - \\varepsilon u = 0$（其中 $\\varepsilon > 0$）既能确保唯一性，又能保持原始物理模型不变；这是一个可接受的修复方案。**\n该陈述部分正确，但其结论最终是有缺陷的。求解修正后的 Helmholtz 方程 $\\nabla^2 u - \\varepsilon u = 0$ 确实能得到唯一解，因为对于 $\\varepsilon > 0$，算子 $(\\nabla^2 - \\varepsilon I)$ 会产生一个可逆的（负定的）离散矩阵。然而，声称这“保持原始物理模型不变”是错误的。控制方程已从拉普拉斯方程根本性地变为亥姆霍兹方程。这代表了一个不同的物理模型（例如，带有反应项或体积汇的稳态扩散）。问题要求修复方案应保留原始的控制方程，而此方法没有做到这一点。\n**结论：错误**\n\n**F. 如果边界数据违反了可解性条件，可以通过减去其平均通量，将其投影到相容子空间上，以使离散净通量为零；这将为原始的拉普拉斯方程产生一个可解的问题。**\n该陈述准确地描述了处理违反相容性条件的不一致边界数据的标准程序。如果离散净通量非零（$\\mathbf{1}^T b \\neq 0$），原始系统是不可解的。通过修改边界数据（从而修改向量 $b$），使得新数据满足该条件（例如，$g' = g - \\text{mean}(g)$），可以得到一个新的、可解的问题。这种投影修改了边界条件，但保持了控制偏微分方程 $\\nabla^2 u = 0$ 不变。对于原始偏微分方程算子，这是一种正确且实用的方法来获得一个有物理意义的解。\n**结论：正确**", "answer": "$$\\boxed{ACDF}$$", "id": "3128839"}, {"introduction": "在解决了“能否求解”的问题后，我们必须面对“求解成本有多高”的现实考量。在真实的科学与工程应用中，计算网格的规模可能极其庞大，使得算法效率成为决定项目成败的关键。本练习将引导你从第一性原理出发，分析和比较两种典型求解器（一种直接法和一种先进的迭代法）的计算复杂度，让你体会到算法的“阶” ($O(N^2)$ vs $O(N^3)$) 如何直接影响求解大规模问题的可行性，这是连接数值理论与高性能计算实践的重要一课。[@problem_id:3128786]", "problem": "考虑单位正方形域上的二维拉普拉斯方程，其狄利克雷边界条件指定为在 $[0,1]\\times[0,1]$ 上 $\\nabla^2 u = 0$ 且在边界上 $u=0$。在均匀网格上使用标准的五点有限差分格式，假设每个轴上有 $N$ 个内部网格点，从而产生 $M=N^2$ 个未知数。离散后的线性系统形式为 $A \\mathbf{u} = \\mathbf{b}$，其中 $A$ 是稀疏对称正定（SPD）矩阵。\n\n我们考虑计算科学实验室中常用的两种求解器系列：\n\n- 一种基于嵌套剖分和 Cholesky 分解的直接求解器，专为结构化二维网格定制。\n- 一种在每一层级上都进行平滑操作的多重网格V循环迭代求解器。\n\n您的任务是从第一性原理出发，推导每种求解器系列的浮点运算次数随网格参数 $N$ 变化的标度关系，然后利用这些标度关系来预测求解时间和实际限制。假设以下模型常数用于描述实现开销和每次操作的成本：\n- 直接求解器的比例常数 $\\alpha = 40$。\n- 多重网格求解器的比例常数 $\\beta = 10$。\n两个常数都是您推导出的主阶标度关系上的无量纲乘数。\n\n将硬件的持续浮点执行速率定义为 $r$（单位：浮点运算/秒），并将每次求解允许的最大墙上时钟时间定义为 $T_{\\max}$（单位：秒）。对于给定的求解器模型，求解时间 $t$ 通过将总运算次数除以 $r$ 计算得出，并且必须以秒为单位表示。\n\n对于每个测试用例，您的程序必须：\n1. 计算直接求解器的预测求解时间 $t_{\\mathrm{direct}}$，单位为 $\\mathrm{s}$。\n2. 计算多重网格求解器的预测求解时间 $t_{\\mathrm{mg}}$，单位为 $\\mathrm{s}$。\n3. 计算使得直接求解器的预测时间不超过 $T_{\\max}$ 的最大整数 $N_{\\max,\\mathrm{direct}}$。\n4. 计算使得多重网格求解器的预测时间不超过 $T_{\\max}$ 的最大整数 $N_{\\max,\\mathrm{mg}}$。\n\n您必须以秒为单位表示所有时间，并四舍五入到六位小数。输出不得包含任何单位符号，只包含数值。不涉及角度，因此不需要角度单位。\n\n使用以下测试套件，每个用例以三元组 $(N,r,T_{\\max})$ 的形式给出：\n- 用例A：$(N = 8,\\ r = 2\\times 10^{10},\\ T_{\\max} = 2)$。\n- 用例B：$(N = 64,\\ r = 2\\times 10^{10},\\ T_{\\max} = 2)$。\n- 用例C：$(N = 256,\\ r = 2\\times 10^{10},\\ T_{\\max} = 2)$。\n- 用例D：$(N = 512,\\ r = 1\\times 10^{11},\\ T_{\\max} = 1)$。\n- 用例E（边界情况）：$(N = 1,\\ r = 1\\times 10^{9},\\ T_{\\max} = 0.1)$。\n\n您的程序应生成单行输出，其中包含一个由逗号分隔的列表，列表被方括号括起。每个测试用例的结果本身是一个四元素列表，顺序为 $[t_{\\mathrm{direct}},t_{\\mathrm{mg}},N_{\\max,\\mathrm{direct}},N_{\\max,\\mathrm{mg}}]$。例如，总体输出格式必须为\n$[[t_{\\mathrm{direct},A},t_{\\mathrm{mg},A},N_{\\max,\\mathrm{direct},A},N_{\\max,\\mathrm{mg},A}],[t_{\\mathrm{direct},B},t_{\\mathrm{mg},B},N_{\\max,\\mathrm{direct},B},N_{\\max,\\mathrm{mg},B}],\\dots]$，\n所有数值条目都应显示，时间四舍五入到六位小数，并且没有多余的空格。\n\n您需要从有限差分法和求解器结构的基础属性出发，设计算法并计算答案，而不是使用提供给您的快捷公式。所有数值输出必须是指定的整数或浮点数。", "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于计算科学的既定原则，特别是偏微分方程的数值解法。该问题是适定的，提供了推导唯一、有意义解所需的所有数据和定义。其语言客观，约束条件一致且在物理上是合理的。\n\n任务是分析用于求解二维拉普拉斯方程 $\\nabla^2 u = 0$ 有限差分离散化所产生的线性系统的两种不同求解器算法的计算复杂度。求解域为单位正方形 $[0,1]\\times[0,1]$，边界条件为齐次狄利克雷条件（即在边界上 $u=0$）。离散化在均匀网格上使用标准的五点格式，每个轴上有 $N$ 个内部点，从而得到一个包含 $M = N^2$ 个线性方程的系统 $A \\mathbf{u} = \\mathbf{b}$。已知矩阵 $A$ 是稀疏对称正定（SPD）的。\n\n我们首先推导每种求解器系列的浮点运算次数（FLOPS）随网格参数 $N$ 变化的标度关系。\n\n**1. 直接求解器：嵌套剖分与 Cholesky 分解**\n\n直接求解器通过对矩阵 $A$ 进行分解来找到精确解（在机器精度范围内）。对于SPD矩阵，Cholesky 分解（$A=LL^T$）是首选方法。Cholesky 分解的计算成本高度依赖于未知数的排序，排序会影响“填充”（fill-in）的数量——即 $A$ 中的零元素在因子 $L$ 中变为非零元素。\n\n对网格点进行简单的字典序排序会导致矩阵 $A$ 的带宽约为 $N$。带状 Cholesky 分解的浮点运算次数标度为 $O(M \\cdot (\\text{bandwidth})^2) = O(N^2 \\cdot N^2) = O(N^4)$。\n\n然而，题目指定使用**嵌套剖分**。对于由基于网格的问题产生的矩阵，这是一种效率高得多的排序策略。该方法递归地划分网格。对于二维网格，选择一个网格点的“分隔符”将网格分成两个子域。与分隔符相关的未知数排在最后。这个过程被递归地应用于子域。由此产生的矩阵结构可以最小化填充。\n\n对于一个有 $M=N^2$ 个未知数的二维问题，George 和 Liu 的开创性工作表明，使用嵌套剖分的 Cholesky 分解的运算次数标度为 $O(M^{3/2})$。用 $N$ 来表示：\n$$\n\\text{FLOPS}_{\\mathrm{direct}} \\propto M^{3/2} = (N^2)^{3/2} = N^3\n$$\n题目提供了一个无量纲比例常数 $\\alpha = 40$ 来模拟与具体实现相关的开销。因此，总运算次数 $C_{\\mathrm{direct}}$ 为：\n$$\nC_{\\mathrm{direct}}(N) = \\alpha N^3 = 40 N^3\n$$\n\n**2. 迭代求解器：多重网格V循环**\n\n多重网格是一种以其最优效率而闻名的高级迭代方法。其基本原理是，简单的松弛平滑器（如 Jacobi 或 Gauss-Seidel）能有效减少误差的高频分量，但在衰减低频（光滑）误差分量方面非常缓慢。多重网格方法通过在更粗的网格上表示光滑误差来克服这个问题，在粗网格上，光滑误差变得相对高频，从而可以被有效消除。\n\n单个多重网格V循环包括：\n- 在细网格上进行几次预平滑步骤。\n- 将残差限制到更粗的网格上。\n- 在粗网格问题上递归调用求解器。这个过程一直持续到达到一个非常粗的网格，此时问题可以直接求解，成本可忽略不计。\n- 将粗网格校正量延长（插值）回细网格。\n- 在细网格上进行几次后平滑步骤。\n\n在具有 $M$ 个点的网格上进行平滑、限制和延长的成本与 $M$ 成正比。如果在每个层级，网格大小都以一个恒定的因子减小（对于二维网格通常是因子4），那么一个V循环的总工作量 $W(M)$ 遵循递推关系 $W(M) \\approx cM + W(M/4)$。其解是一个几何级数：\n$$\nW(M) \\approx cM + \\frac{cM}{4} + \\frac{cM}{16} + \\dots = cM \\sum_{k=0}^{\\infty} \\left(\\frac{1}{4}\\right)^k = cM \\frac{1}{1 - 1/4} = \\frac{4}{3}cM\n$$\n因此，每个V循环的工作量是 $O(M)$。多重网格的一个关键理论结果是，对于像拉普拉斯方程这样的椭圆问题，每个V循环的收敛率是一个与网格大小 $M$ 无关的常数。这意味着固定且少量的V循环就足以将问题求解到给定的精度。\n\n因此，多重网格求解器的总运算次数与未知数数量 $M$ 成正比。\n$$\n\\text{FLOPS}_{\\mathrm{mg}} \\propto M = N^2\n$$\n使用题目提供的比例常数 $\\beta = 10$，总运算次数 $C_{\\mathrm{mg}}$ 为：\n$$\nC_{\\mathrm{mg}}(N) = \\beta N^2 = 10 N^2\n$$\n\n**3. 求解时间与最大问题规模**\n\n给定硬件的持续浮点执行速率 $r$，求解时间 $t$ 是总运算次数除以 $r$。\n\n对于直接求解器：\n$$\nt_{\\mathrm{direct}}(N, r) = \\frac{C_{\\mathrm{direct}}(N)}{r} = \\frac{40 N^3}{r}\n$$\n对于多重网格求解器：\n$$\nt_{\\mathrm{mg}}(N, r) = \\frac{C_{\\mathrm{mg}}(N)}{r} = \\frac{10 N^2}{r}\n$$\n\n在最大墙上时钟时间 $T_{\\max}$ 内可解的最大整数网格尺寸 $N_{\\max}$，可以通过设置 $t \\le T_{\\max}$ 并求解 $N$ 来找到。\n\n对于直接求解器，我们在 $\\frac{40 N^3}{r} \\le T_{\\max}$ 中求解 $N$：\n$$\nN^3 \\le \\frac{r T_{\\max}}{40} \\implies N \\le \\left( \\frac{r T_{\\max}}{40} \\right)^{1/3}\n$$\n由于 $N$ 必须是整数，我们对结果取整：\n$$\nN_{\\max,\\mathrm{direct}} = \\left\\lfloor \\left( \\frac{r T_{\\max}}{40} \\right)^{1/3} \\right\\rfloor\n$$\n\n对于多重网格求解器，我们在 $\\frac{10 N^2}{r} \\le T_{\\max}$ 中求解 $N$：\n$$\nN^2 \\le \\frac{r T_{\\max}}{10} \\implies N \\le \\sqrt{\\frac{r T_{\\max}}{10}}\n$$\n作为一个整数，$N$ 是结果的向下取整：\n$$\nN_{\\max,\\mathrm{mg}} = \\left\\lfloor \\sqrt{\\frac{r T_{\\max}}{10}} \\right\\rfloor\n$$\n\n现在将这些公式应用于每个测试用例，以计算所需的数值结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes time-to-solution predictions and practical limits for direct\n    and multigrid solvers for the 2D Laplace equation.\n    \"\"\"\n    # Define the test cases from the problem statement as tuples of (N, r, T_max).\n    test_cases = [\n        # Case A\n        (8, 2e10, 2),\n        # Case B\n        (64, 2e10, 2),\n        # Case C\n        (256, 2e10, 2),\n        # Case D\n        (512, 1e11, 1),\n        # Case E\n        (1, 1e9, 0.1),\n    ]\n\n    # Proportionality constants from the problem.\n    # alpha for the direct solver (scaling with N^3).\n    alpha = 40.0\n    # beta for the multigrid solver (scaling with N^2).\n    beta = 10.0\n\n    all_results = []\n    for case in test_cases:\n        N, r, T_max = case\n\n        # 1. Compute predicted time-to-solution for the direct solver.\n        # Operation count C_direct = alpha * N^3.\n        # Time t_direct = C_direct / r.\n        t_direct = (alpha * N**3) / r\n\n        # 2. Compute predicted time-to-solution for the multigrid solver.\n        # Operation count C_mg = beta * N^2.\n        # Time t_mg = C_mg / r.\n        t_mg = (beta * N**2) / r\n\n        # 3. Compute the largest integer N_max,direct.\n        # We need t_direct = T_max, which is (alpha * N^3) / r = T_max.\n        # This simplifies to N = (r * T_max / alpha)^(1/3).\n        # Since N must be an integer, we take the floor.\n        N_max_direct = int(((r * T_max) / alpha)**(1/3))\n\n        # 4. Compute the largest integer N_max,mg.\n        # We need t_mg = T_max, which is (beta * N^2) / r = T_max.\n        # This simplifies to N = sqrt(r * T_max / beta).\n        # Since N must be an integer, we take the floor.\n        N_max_mg = int(((r * T_max) / beta)**(0.5))\n\n        # Format the case result as a string to exactly match the required output format,\n        # avoiding spaces that str(list) would introduce.\n        # Times are formatted to six decimal places.\n        case_result_str = f\"[{t_direct:.6f},{t_mg:.6f},{N_max_direct},{N_max_mg}]\"\n        all_results.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    # The output is a single line: a list of lists, represented as a string.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3128786"}]}