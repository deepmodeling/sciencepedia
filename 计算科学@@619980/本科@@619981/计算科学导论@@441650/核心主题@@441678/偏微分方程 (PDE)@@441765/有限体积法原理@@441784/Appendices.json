{"hands_on_practices": [{"introduction": "有限体积法 (Finite Volume Method, FVM) 的基石在于其内在的守恒特性，这是通过确保每个控制体积的通量精确平衡来实现的。本练习旨在通过直接的编程实践来验证这一核心属性。通过在一个标准的扩散问题中测试变化的非均匀网格和异质性材料属性 ([@problem_id:3130123])，你将亲手确认守恒性源于该方法的“流入减流出”基本结构，而非依赖于特定的理想化条件。", "problem": "考虑域 $[0,1]$ 上守恒形式的一维扩散方程：\n$$\nu_t = (k(x)\\,u_x)_x,\n$$\n其中 $u(x,t)$ 是标量场，$k(x) > 0$ 是一个给定的、足够光滑的扩散率场。设在具有 $N$ 个单元的通用非均匀网格上使用单元中心有限体积法 (FVM)。将单元交界面表示为 $\\{x_{i-\\tfrac{1}{2}}\\}_{i=1}^{N+1}$，其中 $x_{\\tfrac{1}{2}} = 0$ 且 $x_{N+\\tfrac{1}{2}} = 1$；单元中心表示为 $x_i = \\tfrac{1}{2}(x_{i-\\tfrac{1}{2}}+x_{i+\\tfrac{1}{2}})$；单元宽度表示为 $\\Delta x_i = x_{i+\\tfrac{1}{2}}-x_{i-\\tfrac{1}{2}}$。设单元平均值为 $\\bar{u}_i(t) = \\frac{1}{\\Delta x_i}\\int_{x_{i-\\tfrac{1}{2}}}^{x_{i+\\tfrac{1}{2}}} u(x,t)\\,dx$。定义离散总质量为\n$$\nM(t) = \\sum_{i=1}^N \\bar{u}_i(t)\\,\\Delta x_i.\n$$\n\n仅从每个控制体积上的积分平衡和散度（高斯）定理出发，为单元 $\\{C_i\\}_{i=1}^N$ 推导出一个形式如下的守恒半离散有限体积法\n$$\n\\frac{d}{dt}\\left(\\bar{u}_i \\Delta x_i\\right) = F_{i-\\tfrac{1}{2}} - F_{i+\\tfrac{1}{2}},\n$$\n其中 $F_{i\\pm\\tfrac{1}{2}}$ 是交界面上物理扩散通量的一致性数值近似。然后使用时间步长为 $\\Delta t > 0$ 的一阶隐式（后向）欧拉法在时间上进行离散化，从而在每个时间步为 $\\{\\bar{u}_i^{n+1}\\}_{i=1}^N$ 获得一个线性系统。在每个内部交界面上使用一种两点通量近似，该近似仅依赖于相邻单元以及单元中心到交界面的距离，并在相邻单元中心之间的距离上近似通量梯度。对于非均匀扩散率，使用一个与一维串联电阻一致的交界面系数。\n\n施加齐次诺伊曼边界条件（在 $x=0$ 和 $x=1$ 处通量为零）或周期性边界条件（通过识别首尾单元，使通过 $x=0$ 和 $x=1$ 的通量相互抵消）。在下文所有指定齐次诺伊曼条件的情况下，要求边界通量在离散意义上精确为零。对于周期性边界条件，通过边界耦合第一个和最后一个单元。\n\n对所有测试用例使用以下初始条件，通过精确的单元平均值指定：\n$$\nu(x,0) = 1 + \\sin(2\\pi x),\n$$\n因此对于每个边为 $a = x_{i-\\tfrac{1}{2}}$ 和 $b = x_{i+\\tfrac{1}{2}}$ 的单元 $i$：\n$$\n\\bar{u}_i(0) = 1 + \\frac{1}{b-a}\\int_a^b \\sin(2\\pi x)\\,dx = 1 + \\frac{-\\cos(2\\pi b) + \\cos(2\\pi a)}{2\\pi (b-a)}.\n$$\n区域长度为 $1$，因此在 $t=0$ 时的精确连续质量等于 $1$。根据单元平均值和宽度计算离散质量 $M(0)$。\n\n实现全隐式有限体积法时间步进，并对以下测试套件测试离散总质量 $M(t)$ 在隐式欧拉法下是否守恒。对于每个测试，将解推进 $n_{\\text{steps}}$ 步，步长为 $\\Delta t$，并将 $M(n_{\\text{steps}}\\Delta t)$与 $M(0)$进行比较。\n\n- 测试 $1$ (理想路径): $N=50$，均匀网格，$\\Delta x_i = 1/N$，齐次诺伊曼边界条件，常数扩散率 $k(x) \\equiv 1$，$\\Delta t = 0.1$, $n_{\\text{steps}} = 5$。\n- 测试 $2$ (非均匀与非均质): $N=37$，非均匀网格，宽度与 $1 + 0.6\\sin(2\\pi \\tfrac{i-0.5}{N})$ 成正比（$i=1,\\dots,N$），然后归一化以使 $\\sum_i \\Delta x_i = 1$，齐次诺伊曼边界条件，非均匀扩散率 $k(x) = 1 + 0.4 x$，$\\Delta t = 0.05$, $n_{\\text{steps}} = 10$。\n- 测试 $3$ (周期性，强分级网格): $N=41$，非均匀网格，呈等比级数 $\\Delta x_i \\propto r^{i-1}$（$i=1,\\dots,N$，$r=1.3$），归一化以使 $\\sum_i \\Delta x_i = 1$，周期性边界条件，非均匀扩散率 $k(x) = 2 + 0.5\\cos(2\\pi x)$，$\\Delta t = 0.05$, $n_{\\text{steps}} = 7$。\n\n您的程序必须：\n- 根据指定的 $\\Delta x_i$ 显式构造网格，以使 $\\sum_i \\Delta x_i = 1$，使用相邻单元中心间的两点通量来组装用于内部交界面的守恒有限体积法线性系统，强制执行指定的边界条件，并使用隐式欧拉法进行推进。\n- 计算每个测试的离散总质量 $M(0)$ 和 $M(n_{\\text{steps}}\\Delta t)$。\n- 对于每个测试，确定一个布尔结果：如果 $\\left|M(n_{\\text{steps}}\\Delta t) - M(0)\\right| \\le 10^{-12}$，则返回 $\\,\\text{True}\\,$，否则返回 $\\,\\text{False}\\,$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的三个布尔结果列表（例如，$[\\,\\text{True},\\text{False},\\text{True}\\,]$）。不应打印任何额外文本。由于问题是无量纲的，因此不需要物理单位。问题不涉及角度。程序中的所有数值都应视为无量纲标量。", "solution": "该问题要求针对一维扩散方程，推导并实现一个单元中心有限体积法（FVM），然后检验其在不同条件下的质量守恒特性。\n\n### 1. 有限体积公式化\n控制偏微分方程（PDE）以守恒形式给出：\n$$ u_t = (k(x)\\,u_x)_x $$\n我们通过对此方程在一个控制体积 $C_i = [x_{i-\\frac{1}{2}}, x_{i+\\frac{1}{2}}]$ 上积分来应用有限体积法：\n$$ \\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u_t \\,dx = \\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} (k(x)\\,u_x)_x \\,dx $$\n左侧（LHS），使用单元平均值 $\\bar{u}_i(t) = \\frac{1}{\\Delta x_i}\\int_{C_i} u(x,t)\\,dx$ 的定义和莱布尼茨积分法则，变为：\n$$ \\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u_t \\,dx = \\frac{d}{dt}\\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u(x,t)\\,dx = \\frac{d}{dt}\\left(\\bar{u}_i(t) \\Delta x_i\\right) $$\n右侧（RHS）使用微积分基本定理（散度定理的一维形式）进行积分：\n$$ \\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} (k(x)\\,u_x)_x \\,dx = \\left[ k(x)u_x \\right]_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} = (k u_x)\\Big|_{x_{i+\\frac{1}{2}}} - (k u_x)\\Big|_{x_{i-\\frac{1}{2}}} $$\n令 $G(x,t) = k(x)u_x$ 为物理扩散通量。单元 $i$ 的精确平衡方程为：\n$$ \\frac{d}{dt}\\left(\\bar{u}_i \\Delta x_i\\right) = G(x_{i+\\frac{1}{2}}, t) - G(x_{i-\\frac{1}{2}}, t) $$\n然后，通过用数值通量（表示为 $G_{i\\pm\\frac{1}{2}}$，是单元平均值 $\\bar{u}_j$ 的函数）来近似单元交界面（面）上的通量 $G$，对此方程进行半离散化。这得到了半离散有限体积法系统：\n$$ \\frac{d}{dt}\\left(\\bar{u}_i \\Delta x_i\\right) = G_{i+\\frac{1}{2}} - G_{i-\\frac{1}{2}} $$\n注意，问题陈述中使用 F 表示数值通量，但其符号约定与积分直接得到的结果不同。为避免歧义，我们使用此处定义的 G。关键在于守恒的“通量入减通量出”结构，在重新排列以匹配问题形式后，会产生相同的底层模板。\n\n### 2. 数值通量近似\n单元 $i$ 和 $i+1$ 之间交界面上的通量 $G_{i+\\frac{1}{2}}$ 使用一个涉及 $\\bar{u}_i$ 和 $\\bar{u}_{i+1}$ 的两点模板来近似。交界面处的导数 $u_x$ 通过单元中心 $x_i$ 和 $x_{i+1}$ 之间的有限差分来近似：\n$$ G_{i+\\frac{1}{2}} \\approx k_{i+\\frac{1}{2}} \\frac{\\bar{u}_{i+1} - \\bar{u}_i}{x_{i+1} - x_i} $$\n其中 $k_{i+\\frac{1}{2}}$ 是交界面上的有效扩散率。按照规定，对于非均质介质，该值的选取應与串联电阻一致。长度为 $L$、扩散率为 $k$ 的段的扩散“阻力”是 $L/k$。单元中心 $x_i$ 和 $x_{i+1}$ 之间的总阻力是从 $x_i$ 到 $x_{i+\\frac{1}{2}}$ 的阻力与从 $x_{i+\\frac{1}{2}}$ 到 $x_{i+1}$ 的阻力之和。这导致有效电导率 $k_{i+\\frac{1}{2}} / (x_{i+1}-x_i)$ 的调和平均值：\n$$ \\frac{1}{\\text{Total Resistance}} = \\frac{1}{\\frac{x_{i+1}-x_i}{k_{i+\\frac{1}{2}}}} = \\frac{1}{\\frac{x_{i+\\frac{1}{2}}-x_i}{k(x_i)} + \\frac{x_{i+1}-x_{i+\\frac{1}{2}}}{k(x_{i+1})}} $$\n对于 $x_i = \\frac{1}{2}(x_{i-\\frac{1}{2}}+x_{i+\\frac{1}{2}})$ 和 $\\Delta x_i = x_{i+\\frac{1}{2}}-x_{i-\\frac{1}{2}}$，我们有 $x_{i+1}-x_i = \\frac{1}{2}(\\Delta x_i + \\Delta x_{i+1})$，$x_{i+\\frac{1}{2}}-x_i = \\frac{1}{2}\\Delta x_i$ 以及 $x_{i+1}-x_{i+\\frac{1}{2}} = \\frac{1}{2}\\Delta x_{i+1}$。那么，项 $(\\bar{u}_{i+1} - \\bar{u}_i)$ 的通量系数为：\n$$ \\beta_{i+\\frac{1}{2}} = \\frac{k_{i+\\frac{1}{2}}}{x_{i+1} - x_i} = \\frac{1}{\\frac{\\frac{1}{2}\\Delta x_i}{k(x_i)} + \\frac{\\frac{1}{2}\\Delta x_{i+1}}{k(x_{i+1})}} = \\frac{2}{\\frac{\\Delta x_i}{k(x_i)} + \\frac{\\Delta x_{i+1}}{k(x_{i+1})}} $$\n数值通量为 $G_{i+\\frac{1}{2}} = \\beta_{i+\\frac{1}{2}}(\\bar{u}_{i+1} - \\bar{u}_i)$。内部单元 $i$ 的半离散方程为：\n$$ \\Delta x_i \\frac{d\\bar{u}_i}{dt} = \\beta_{i+\\frac{1}{2}}(\\bar{u}_{i+1} - \\bar{u}_i) - \\beta_{i-\\frac{1}{2}}(\\bar{u}_i - \\bar{u}_{i-1}) $$\n\n### 3. 隐式时间离散化\n使用一阶隐式（后向）欧拉法，我们近似 $\\frac{d\\bar{u}_i}{dt} \\approx \\frac{\\bar{u}_i^{n+1} - \\bar{u}_i^n}{\\Delta t}$ 并在新的时间层 $n+1$ 上计算空间项：\n$$ \\Delta x_i \\frac{\\bar{u}_i^{n+1} - \\bar{u}_i^n}{\\Delta t} = \\beta_{i+\\frac{1}{2}}(\\bar{u}_{i+1}^{n+1} - \\bar{u}_i^{n+1}) - \\beta_{i-\\frac{1}{2}}(\\bar{u}_i^{n+1} - \\bar{u}_{i-1}^{n+1}) $$\n重新排列这些项，得到关于未知向量 $\\mathbf{u}^{n+1} = [\\bar{u}_1^{n+1}, \\dots, \\bar{u}_N^{n+1}]^T$ 的线性系统：\n$$ -\\frac{\\Delta t}{\\Delta x_i}\\beta_{i-\\frac{1}{2}}\\bar{u}_{i-1}^{n+1} + \\left(1 + \\frac{\\Delta t}{\\Delta x_i}(\\beta_{i-\\frac{1}{2}} + \\beta_{i+\\frac{1}{2}})\\right)\\bar{u}_i^{n+1} - \\frac{\\Delta t}{\\Delta x_i}\\beta_{i+\\frac{1}{2}}\\bar{u}_{i+1}^{n+1} = \\bar{u}_i^n $$\n此方程定义了线性系统 $A\\mathbf{u}^{n+1} = \\mathbf{u}^n$ 的第 $i$ 行。对于内部单元，矩阵 $A$ 是三对角的。\n\n### 4. 边界条件\n**齐次诺伊曼条件**：边界通量为零，$G_{\\frac{1}{2}} = G_{N+\\frac{1}{2}} = 0$。\n对于单元 $i=1$：$\\Delta x_1 \\frac{d\\bar{u}_1}{dt} = G_{\\frac{3}{2}} - G_{\\frac{1}{2}} = G_{\\frac{3}{2}}$。系统的第一行变为：\n$$ \\left(1 + \\frac{\\Delta t}{\\Delta x_1}\\beta_{\\frac{3}{2}}\\right)\\bar{u}_1^{n+1} - \\frac{\\Delta t}{\\Delta x_1}\\beta_{\\frac{3}{2}}\\bar{u}_2^{n+1} = \\bar{u}_1^n $$\n对于单元 $i=N$：$\\Delta x_N \\frac{d\\bar{u}_N}{dt} = G_{N+\\frac{1}{2}} - G_{N-\\frac{1}{2}} = -G_{N-\\frac{1}{2}}$。最后一行变为：\n$$ -\\frac{\\Delta t}{\\Delta x_N}\\beta_{N-\\frac{1}{2}}\\bar{u}_{N-1}^{n+1} + \\left(1 + \\frac{\\Delta t}{\\Delta x_N}\\beta_{N-\\frac{1}{2}}\\right)\\bar{u}_N^{n+1} = \\bar{u}_N^n $$\n得到的系统矩阵 $A$ 是三对角的。\n\n**周期性条件**：单元 $1$ 和 $N$ 相邻。我们定义 $\\bar{u}_0 \\equiv \\bar{u}_N$ 和 $\\bar{u}_{N+1} \\equiv \\bar{u}_1$。\n对于单元 $i=1$：$G_{\\frac{1}{2}} = \\beta_{\\frac{1}{2}}(\\bar{u}_1 - \\bar{u}_N)$。第一行包含一个关于 $\\bar{u}_N$ 的项：\n$$ -\\frac{\\Delta t}{\\Delta x_1}\\beta_{\\frac{1}{2}}\\bar{u}_N^{n+1} + \\left(1 + \\frac{\\Delta t}{\\Delta x_1}(\\beta_{\\frac{1}{2}} + \\beta_{\\frac{3}{2}})\\right)\\bar{u}_1^{n+1} - \\frac{\\Delta t}{\\Delta x_1}\\beta_{\\frac{3}{2}}\\bar{u}_2^{n+1} = \\bar{u}_1^n $$\n对于单元 $i=N$：$G_{N+\\frac{1}{2}} = \\beta_{N+\\frac{1}{2}}(\\bar{u}_1 - \\bar{u}_N) = \\beta_{\\frac{1}{2}}(\\bar{u}_1 - \\bar{u}_N)$。最后一行包含一个关于 $\\bar{u}_1$ 的项：\n$$ -\\frac{\\Delta t}{\\Delta x_N}\\beta_{\\frac{1}{2}}\\bar{u}_1^{n+1} -\\frac{\\Delta t}{\\Delta x_N}\\beta_{N-\\frac{1}{2}}\\bar{u}_{N-1}^{n+1} + \\left(1 + \\frac{\\Delta t}{\\Delta x_N}(\\beta_{N-\\frac{1}{2}} + \\beta_{\\frac{1}{2}})\\right)\\bar{u}_N^{n+1} = \\bar{u}_N^n $$\n矩阵 $A$ 是循环三对角的。\n\n### 5. 质量守恒\n离散总质量为 $M(t) = \\sum_{i=1}^N \\bar{u}_i(t)\\,\\Delta x_i$。对半离散系统取时间导数并对所有单元求和：\n$$ \\frac{dM}{dt} = \\sum_{i=1}^N \\frac{d}{dt}(\\bar{u}_i \\Delta x_i) = \\sum_{i=1}^N (G_{i+\\frac{1}{2}} - G_{i-\\frac{1}{2}}) $$\n这是一个伸缩求和，其结果为 $G_{N+\\frac{1}{2}} - G_{\\frac{1}{2}}$，即穿过区域边界的净通量。\n- 对于齐次诺伊曼边界条件，$G_{N+\\frac{1}{2}} = G_{\\frac{1}{2}} = 0$，因此 $\\frac{dM}{dt} = 0$。\n- 对于周期性边界条件，区域没有边界，且 $G_{N+\\frac{1}{2}} = G_{\\frac{1}{2}}$ 代表的是同一个内部通量，所以它们的差为零，且 $\\frac{dM}{dt} = 0$。\n\n半离散化的这一性质延续到了全离散隐式欧拉格式。将全离散方程对所有 $i$ 求和：\n$$ \\sum_{i=1}^N \\Delta x_i (\\bar{u}_i^{n+1} - \\bar{u}_i^n) = \\Delta t \\sum_{i=1}^N (G_{i+\\frac{1}{2}}^{n+1} - G_{i-\\frac{1}{2}}^{n+1}) $$\n$$ M^{n+1} - M^n = \\Delta t (G_{N+\\frac{1}{2}}^{n+1} - G_{\\frac{1}{2}}^{n+1}) $$\n对于诺伊曼和周期性边界条件，右侧均为零。因此，$M^{n+1} = M^n$。所实现的格式是精确质量守恒的。计算结果中的任何偏差将完全由浮点运算误差引起。考虑到 $10^{-12}$ 的容差，我们预期测试会通过。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the FVM simulation for all test cases.\n    \"\"\"\n\n    def run_one_case(N, mesh_type, bc_type, k_func, dt, n_steps):\n        \"\"\"\n        Sets up and runs a single test case for the FVM simulation.\n        \"\"\"\n        # 1. Mesh Generation\n        if mesh_type == 'uniform':\n            dx_unnormalized = np.ones(N)\n        elif mesh_type == 'proportional':\n            i_vals = np.arange(1, N + 1)\n            dx_unnormalized = 1.0 + 0.6 * np.sin(2.0 * np.pi * (i_vals - 0.5) / N)\n        elif mesh_type == 'geometric':\n            r = 1.3\n            i_vals = np.arange(N)\n            dx_unnormalized = r**i_vals\n        else:\n            raise ValueError(\"Unknown mesh type\")\n\n        # Normalize dx so that the domain length is 1\n        dx = dx_unnormalized / np.sum(dx_unnormalized)\n\n        # Calculate interface and center positions\n        x_interfaces = np.zeros(N + 1)\n        x_interfaces[1:] = np.cumsum(dx)\n        x_centers = 0.5 * (x_interfaces[:-1] + x_interfaces[1:])\n\n        # 2. Initial Condition\n        a = x_interfaces[:-1]\n        b = x_interfaces[1:]\n        \n        # The original code for this calculation was buggy.\n        # It is corrected here to properly and safely calculate the cell averages.\n        num = -np.cos(2.0 * np.pi * b) + np.cos(2.0 * np.pi * a)\n        den = 2.0 * np.pi * (b - a)\n        # Use np.divide for robust division. If den is near zero (which shouldn't happen\n        # for a valid mesh), the integral is zero, so frac is zero.\n        frac = np.divide(num, den, out=np.zeros_like(den), where=np.abs(den) > 1e-12)\n        u_initial = 1.0 + frac\n\n        # 3. Initial Mass\n        mass_initial = np.dot(u_initial, dx)\n\n        # 4. Time Stepping\n        u_current = np.copy(u_initial)\n        k_vals = k_func(x_centers)\n\n        for _ in range(n_steps):\n            A = np.zeros((N, N))\n            b_vec = u_current\n\n            # 5. Assemble matrix A\n            # Internal cells (i in 1..N-2)\n            # This loop is technically redundant if N is small but is correct for N>2\n            for i in range(1, N - 1):\n                beta_left = 2.0 / (dx[i - 1] / k_vals[i - 1] + dx[i] / k_vals[i])\n                beta_right = 2.0 / (dx[i] / k_vals[i] + dx[i + 1] / k_vals[i + 1])\n                c_i = dt / dx[i]\n                A[i, i - 1] = -c_i * beta_left\n                A[i, i] = 1.0 + c_i * (beta_left + beta_right)\n                A[i, i + 1] = -c_i * beta_right\n\n            # Boundary Conditions\n            if bc_type == 'neumann':\n                # First row (i=0)\n                if N > 1:\n                    beta_right_0 = 2.0 / (dx[0] / k_vals[0] + dx[1] / k_vals[1])\n                    c_0 = dt / dx[0]\n                    A[0, 0] = 1.0 + c_0 * beta_right_0\n                    A[0, 1] = -c_0 * beta_right_0\n                else: # N=1 case\n                    A[0,0] = 1.0\n                \n                # Last row (i=N-1)\n                if N > 1:\n                    beta_left_N = 2.0 / (dx[N - 2] / k_vals[N - 2] + dx[N - 1] / k_vals[N - 1])\n                    c_N = dt / dx[N - 1]\n                    A[N - 1, N - 2] = -c_N * beta_left_N\n                    A[N - 1, N - 1] = 1.0 + c_N * beta_left_N\n                # else N=1, already handled\n\n            elif bc_type == 'periodic':\n                if N > 1:\n                    beta_periodic = 2.0 / (dx[N - 1] / k_vals[N - 1] + dx[0] / k_vals[0])\n                    # First row (i=0)\n                    beta_right_0 = 2.0 / (dx[0] / k_vals[0] + dx[1] / k_vals[1])\n                    c_0 = dt / dx[0]\n                    A[0, 0] = 1.0 + c_0 * (beta_periodic + beta_right_0)\n                    A[0, 1] = -c_0 * beta_right_0\n                    A[0, N - 1] = -c_0 * beta_periodic\n                    # Last row (i=N-1)\n                    beta_left_N = 2.0 / (dx[N - 2] / k_vals[N - 2] + dx[N - 1] / k_vals[N - 1])\n                    c_N = dt / dx[N - 1]\n                    A[N - 1, N - 1] = 1.0 + c_N * (beta_left_N + beta_periodic)\n                    A[N - 1, N - 2] = -c_N * beta_left_N\n                    A[N - 1, 0] = -c_N * beta_periodic\n                else: # N=1 case\n                     beta_periodic = 2.0 / (dx[0] / k_vals[0] + dx[0] / k_vals[0])\n                     c_0 = dt/dx[0]\n                     A[0,0] = 1.0 + c_0 * (beta_periodic + beta_periodic)\n\n\n            # 6. Solve the linear system\n            u_next = linalg.solve(A, b_vec)\n            u_current = u_next\n\n        # 7. Final Mass and comparison\n        mass_final = np.dot(u_current, dx)\n\n        return np.abs(mass_final - mass_initial) = 1e-12\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1\n        (50, 'uniform', 'neumann', lambda x: np.ones_like(x), 0.1, 5),\n        # Test 2\n        (37, 'proportional', 'neumann', lambda x: 1.0 + 0.4 * x, 0.05, 10),\n        # Test 3\n        (41, 'geometric', 'periodic', lambda x: 2.0 + 0.5 * np.cos(2.0 * np.pi * x), 0.05, 7),\n    ]\n\n    results = []\n    for params in test_cases:\n        N, mesh_t, bc_t, k_f, dt, n_s = params\n        result = run_one_case(N, mesh_t, bc_t, k_f, dt, n_s)\n        results.append(result)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3130123"}, {"introduction": "在验证了基本的守恒特性后，我们现在将这一概念扩展到一个更复杂的系统中，该系统同时涉及物质的输运和化学反应。这个实践的挑战在于展示，即使单个化学物质（例如 $c_A$ 和 $c_B$）由于反应而被消耗或生成，其总浓度 $c_A + c_B$ 仍是守恒的。通过这个练习 ([@problem_id:3130189])，你将领略有限体积法在追踪多物理场动态系统中守恒量的强大能力，并接触到算子分裂法这一实用的数值技术。", "problem": "一个一维平流-反应系统模拟了两种化学物质（标记为$A$和$B$），它们进行可逆反应，并被均匀流输运。设空间域在区间$[0,L]$上是周期的，其中$L$为正数，时间$t \\ge 0$。浓度$c_A(x,t)$和$c_B(x,t)$是非负无量纲的。可逆反应为$A \\leftrightarrow B$，其正向反应速率为$k_1$（单位：时间倒数），逆向反应速率为$k_2$（单位：时间倒数），平流速度$u$（单位：长度/时间）为常数。其基础是宽度为$\\Delta x$的任意控制体积$V$上的积分守恒律，该定律指出，控制体积内某物质数量的变化率等于穿过其边界的净平流通量加上内部反应的净生成量：\n$$\n\\frac{d}{dt}\\int_{V} c_A(x,t)\\,dx = -\\int_{\\partial V} \\left(u\\, c_A\\right)\\cdot n \\, dS + \\int_{V} \\left(-k_1 c_A + k_2 c_B\\right)\\, dx,\n$$\n$$\n\\frac{d}{dt}\\int_{V} c_B(x,t)\\,dx = -\\int_{\\partial V} \\left(u\\, c_B\\right)\\cdot n \\, dS + \\int_{V} \\left(k_1 c_A - k_2 c_B\\right)\\, dx.\n$$\n总浓度$c_T(x,t) \\equiv c_A(x,t) + c_B(x,t)$预计在局部会因反应而守恒，因为反应在物质之间转移，没有净生成或销毁；当使用有限体积离散化时，在周期性边界条件下，总浓度会因平流而在全局守恒。\n\n您的任务是从第一性原理出发，为该系统推导一个守恒型有限体积法。该方法作用于一个包含$N$个宽度为$\\Delta x = L/N$的单元的均匀网格上，平流项使用一阶迎风数值通量，可逆反应项则通过求解每个单元中的线性常微分方程(ODE)组得到精确的局域更新。具体来说：\n- 从积分守恒律出发，阐明有限体积法如何通过平衡单元界面间的数值通量和局域源项来近似单元平均浓度的时间演化。\n- 使用恒定的平流速度$u$和周期性边界条件，在每个界面上构造一个守恒的、一阶迎风格式的通量，确保离散的平流更新在浮点舍入误差范围内能精确保持$c_A + c_B$的全局总和。\n- 对于反应项，推导每个单元中在时间步长$\\Delta t$内的局域ODE系统的精确解，并用它来更新$c_A$和$c_B$，避免引入与反应相关的质量误差。\n- 在代码中实现完整的算法，采用算子分裂法，在每个时间步长内先进行平流更新，再进行反应更新。根据Courant-Friedrichs-Lewy (CFL)条件选择$\\Delta t$以维持显式平流格式的稳定性。当$|u|=0$时，由于平流没有限制，您可以选择任意$\\Delta t$。\n- 假设浓度和区域长度为无量纲变量，并指明时间和速率也都是无量纲的。\n\n初始条件在单元中心定义，并且在所有测试中都相同，由光滑函数给出：\n$$\nc_A(x,0) = 1 + 0.5 \\sin\\!\\left(\\frac{2\\pi x}{L}\\right), \\quad c_B(x,0) = 0.5 + 0.25 \\cos\\!\\left(\\frac{2\\pi x}{L}\\right).\n$$\n这些是无量纲且对所有$x$严格非负的。\n\n定义以下参数集的测试套件，均采用周期性边界：\n- 测试 1（正常可逆反应与正向平流）：$N = 200$，$L = 1$，$u = 1$，$k_1 = 1$，$k_2 = 1$，最终时间 $T = 0.5$。\n- 测试 2（纯平流，无反应，负向速度）：$N = 200$，$L = 1$，$u = -0.7$，$k_1 = 0$，$k_2 = 0$，最终时间 $T = 0.5$。\n- 测试 3（刚性可逆反应与中等平流）：$N = 200$，$L = 1$，$u = 0.3$，$k_1 = 50$，$k_2 = 20$，最终时间 $T = 0.2$。\n- 测试 4（纯反应，无平流）：$N = 200$，$L = 1$，$u = 0$，$k_1 = 3$，$k_2 = 2$，最终时间 $T = 1$。\n\n对于每个测试，计算$t=0$和$t=T$之间$c_A + c_B$总质量的绝对相对变化：\n$$\n\\varepsilon = \\frac{\\left|\\int_{0}^{L} \\left(c_A(x,T) + c_B(x,T)\\right)\\, dx - \\int_{0}^{L} \\left(c_A(x,0) + c_B(x,0)\\right)\\, dx \\right|}{\\int_{0}^{L} \\left(c_A(x,0) + c_B(x,0)\\right)\\, dx}.\n$$\n所有积分都通过单元平均值乘以$\\Delta x$再求和的方式来近似，这与有限体积法一致。预期结果是$\\varepsilon$极小（接近机器精度），这表明在守恒型有限体积平流和精确的局域反应更新下，$c_A+c_B$是守恒的。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4]$），其中每个$r_i$是对应测试的$\\varepsilon$的浮点数值。由于所有量都是无量纲的，因此不需要单位。程序必须是自包含的，不需要任何输入，并使用指定的测试运行至完成。", "solution": "该问题要求推导并实现一个用于一维平流-反应系统的守恒型有限体积法。该方法必须从第一性原理构建，采用算子分裂法、用于平流的一阶迎风格式以及用于局域反应动力学的精确解析解。目标是验证所提出的数值格式对总浓度$c_A + c_B$的守恒特性。\n\n**1. 有限体积格式**\n该系统由物种A和B的积分守恒律控制：\n$$\n\\frac{d}{dt}\\int_{V} c_A(x,t)\\,dx = -\\int_{\\partial V} \\left(u\\, c_A\\right)\\cdot n \\, dS + \\int_{V} \\left(-k_1 c_A + k_2 c_B\\right)\\, dx\n$$\n$$\n\\frac{d}{dt}\\int_{V} c_B(x,t)\\,dx = -\\int_{\\partial V} \\left(u\\, c_B\\right)\\cdot n \\, dS + \\int_{V} \\left(k_1 c_A - k_2 c_B\\right)\\, dx\n$$\n我们将空间域$[0, L]$离散化为$N$个均匀单元$V_i = [x_{i-1/2}, x_{i+1/2}]$，每个单元的宽度为$\\Delta x = L/N$。单元中心为$x_i = (i-1/2)\\Delta x$，其中$i=1, \\dots, N$。\n单元$i$中物种$c$的单元平均浓度定义为：\n$$\n\\bar{c}_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} c(x,t)\\,dx\n$$\n将物种A的积分定律应用于单元$V_i$，我们得到：\n$$\n\\frac{d}{dt} \\left( \\Delta x \\, \\bar{c}_{A,i} \\right) = \\left[ (u c_A) n \\right]_{x_{i-1/2}} - \\left[ (u c_A) n \\right]_{x_{i+1/2}} + \\int_{V_i} (-k_1 c_A + k_2 c_B) \\, dx\n$$\n在一维情况下，外法向量$n$在左边界$x_{i-1/2}$处为$-1$，在右边界$x_{i+1/2}$处为$+1$。平流通量为$F_A(x,t) = u c_A(x,t)$。因此，方程简化为：\n$$\n\\Delta x \\frac{d\\bar{c}_{A,i}}{dt} = F_A(x_{i-1/2}, t) - F_A(x_{i+1/2}, t) + \\int_{V_i} (-k_1 c_A + k_2 c_B) \\, dx\n$$\n两边除以$\\Delta x$并近似积分，我们得到半离散有限体积格式。通量项被数值通量函数$F^*_{A, i\\pm1/2}$替代，源项积分近似为$\\Delta x$乘以在单元平均浓度处计算的源项：\n$$\n\\frac{d\\bar{c}_{A,i}}{dt} = -\\frac{F^*_{A,i+1/2} - F^*_{A,i-1/2}}{\\Delta x} + (-k_1 \\bar{c}_{A,i} + k_2 \\bar{c}_{B,i})\n$$\n对于$\\bar{c}_{B,i}$也存在一个类似的方程。\n\n**2. 数值方法：算子分裂法**\n为求解该半离散系统，我们采用算子分裂法。在一个小的时间步长$\\Delta t$内，单元平均浓度$\\bar{\\mathbf{c}}_i = (\\bar{c}_{A,i}, \\bar{c}_{B,i})^T$从时间$t_n$到$t_{n+1} = t_n + \\Delta t$的演化被分成两个步骤：\n1.  **平流步**：求解$\\frac{\\partial \\mathbf{c}}{\\partial t} + u \\frac{\\partial \\mathbf{c}}{\\partial x} = 0$，持续时间为$\\Delta t$。这会产生一个中间状态$\\bar{\\mathbf{c}}^*$。\n2.  **反应步**：以$\\bar{\\mathbf{c}}^*$为初始条件，求解$\\frac{d \\mathbf{c}}{dt} = \\mathbf{R}(\\mathbf{c})$，持续时间为$\\Delta t$。这给出了最终状态$\\bar{\\mathbf{c}}^{n+1}$。\n符号上表示为：$\\bar{\\mathbf{c}}^{n+1} = \\mathcal{L}_{react}(\\Delta t) \\mathcal{L}_{adv}(\\Delta t) \\bar{\\mathbf{c}}^n$。\n\n**3. 平流步：一阶迎风法**\n对于平流方程，我们使用向前欧拉时间离散化。任意物种$c$的更新方程为：\n$$\n\\bar{c}_i^* = \\bar{c}_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F^*_{i+1/2} - F^*_{i-1/2} \\right)\n$$\n一阶迎风数值通量$F^*_{i+1/2}$取决于速度$u$的符号：\n- 若$u > 0$，信息从左向右流动，因此界面$x_{i+1/2}$处的通量由单元$i$的状态决定：$F^*_{i+1/2} = u \\bar{c}_i^n$。\n- 若$u  0$，信息从右向左流动，因此通量由单元$i+1$的状态决定：$F^*_{i+1/2} = u \\bar{c}_{i+1}^n$。\n\n将这些通量代入更新方程得到：\n- 对于$u > 0$：$\\bar{c}_i^* = \\bar{c}_i^n - \\frac{u \\Delta t}{\\Delta x} \\left( \\bar{c}_i^n - \\bar{c}_{i-1}^n \\right)$。\n- 对于$u  0$：$\\bar{c}_i^* = \\bar{c}_i^n - \\frac{u \\Delta t}{\\Delta x} \\left( \\bar{c}_{i+1}^n - \\bar{c}_i^n \\right)$。\n施加周期性边界条件，即对于单元$i=1$，其“左”邻居是单元$i=N$；对于单元$i=N$，其“右”邻居是单元$i=1$。该格式是守恒的；所有单元的通量之和会伸缩相消，并且由于周期性，净和为零，从而保持总质量$\\sum_i \\bar{c}_i \\Delta x$守恒。\n\n**4. 反应步：精确解**\n反应步涉及在每个单元$i$中求解常微分方程组(ODE)，持续时间为$\\Delta t$，从平流步之后的值$(\\bar{c}_{A,i}^*, \\bar{c}_{B,i}^*)$开始。对于一个给定的单元，设该步骤的初始浓度为$c_A(0)$和$c_B(0)$。控制ODE为：\n$$\n\\frac{dc_A}{dt} = -k_1 c_A + k_2 c_B\n$$\n$$\n\\frac{dc_B}{dt} = k_1 c_A - k_2 c_B\n$$\n将这两个方程相加得到$\\frac{d}{dt}(c_A + c_B) = 0$。这证实了总浓度$S = c_A(t) + c_B(t)$在反应期间是恒定的。因此，$c_B(t) = S - c_A(t)$。将此代入第一个ODE：\n$$\n\\frac{dc_A}{dt} = -k_1 c_A + k_2 (S - c_A) = -(k_1+k_2)c_A + k_2 S\n$$\n这是一个标准的一阶线性ODE。如果$k_1+k_2 > 0$，其解为：\n$$\nc_A(t) = c_{A,eq} + (c_A(0) - c_{A,eq}) e^{-(k_1+k_2)t}\n$$\n其中$c_{A,eq} = S \\frac{k_2}{k_1+k_2}$是物种A的平衡浓度。物种B的浓度则为$c_B(t) = S - c_A(t)$。这个解析解为时间步长$\\Delta t$内的单元平均值提供了精确更新。\n如果$k_1+k_2=0$（意味着$k_1=0$且$k_2=0$），ODE变为$\\frac{dc_A}{dt}=0$和$\\frac{dc_B}{dt}=0$，因此浓度保持不变。\n此反应更新在每个单元中独立执行，并且根据其推导过程，它精确地保持每个单元中的局部质量$c_A+c_B$守恒，因此也保持全局总质量守恒。\n\n**5. 稳定性与算法总结**\n显式平流格式的稳定性受Courant-Friedrichs-Lewy (CFL)条件的制约，该条件要求数值依赖域必须包含物理依赖域。对于一阶迎风格式，此条件为：\n$$\nC_{cfl} = \\frac{|u|\\Delta t}{\\Delta x} \\le 1\n$$\n为确保稳定性，我们选择一个小于1的库朗数，例如$C_{num} = 0.9$，当$u \\ne 0$时，它决定了时间步长大小$\\Delta t = C_{num} \\frac{\\Delta x}{|u|}$。当$u=0$时，没有平流，因此也没有来自平流的CFL约束；可以选择任何足够小的$\\Delta t$来解析反应动力学。\n\n完整的算法如下：\n1.  初始化网格、浓度$\\bar{c}_{A,i}(0)$、$\\bar{c}_{B,i}(0)$，并计算初始总质量。\n2.  根据CFL条件确定$\\Delta t$。\n3.  循环执行时间步，直到达到最终时间$T$。\n    a. 使用迎风格式和周期性边界对$\\bar{c}_A$和$\\bar{c}_B$数组进行平流更新，得到中间数组$\\bar{c}_A^*$和$\\bar{c}_B^*$。\n    b. 对每个单元$i$，使用以$(\\bar{c}_{A,i}^*, \\bar{c}_{B,i}^*)$为初始条件的局域ODE系统的精确解进行反应更新，以找到新的浓度$(\\bar{c}_{A,i}^{n+1}, \\bar{c}_{B,i}^{n+1})$。\n4.  在最后一个时间步之后，计算最终总质量和相对变化$\\varepsilon$。\n\n这个组合格式被设计为对总质量$c_A+c_B$守恒，这意味着任何变化都应仅归因于浮点精度误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D advection-reaction problem for four test cases\n    using a conservative finite volume method with operator splitting.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, L, u, k1, k2, T)\n        (200, 1.0, 1.0, 1.0, 1.0, 0.5),   # Test 1\n        (200, 1.0, -0.7, 0.0, 0.0, 0.5),  # Test 2\n        (200, 1.0, 0.3, 50.0, 20.0, 0.2), # Test 3\n        (200, 1.0, 0.0, 3.0, 2.0, 1.0),   # Test 4\n    ]\n\n    results = []\n\n    for N, L, u, k1, k2, T in test_cases:\n        # --- 1. Initialization ---\n        dx = L / N\n        x = np.linspace(dx / 2.0, L - dx / 2.0, N)\n\n        # Initial conditions for cA and cB\n        cA = 1.0 + 0.5 * np.sin(2.0 * np.pi * x / L)\n        cB = 0.5 + 0.25 * np.cos(2.0 * np.pi * x / L)\n\n        # Calculate initial total mass\n        initial_total_mass = np.sum(cA + cB) * dx\n\n        # --- 2. Time Stepping Setup ---\n        cfl_number = 0.9\n        \n        if u == 0:\n            # For pure reaction, advection CFL is not applicable.\n            # Choose a dt small enough to resolve reaction dynamics well.\n            # Time scale for reaction is ~1/(k1+k2).\n            # For Test 4, 1/(3+2) = 0.2. dt=0.001 is small enough.\n            dt = 0.001\n        else:\n            dt = cfl_number * dx / abs(u)\n\n        num_steps = int(np.ceil(T / dt))\n        dt = T / num_steps  # Adjust dt to hit T exactly\n        \n        t = 0.0\n\n        # --- 3. Time-Stepping Loop ---\n        for _ in range(num_steps):\n            # A. Advection Step (using operator splitting)\n            if u != 0:\n                # First-order upwind scheme with periodic boundaries\n                # np.roll(arr, 1) gets the i-1 element\n                # np.roll(arr, -1) gets the i+1 element\n                \n                courant = u * dt / dx\n                \n                if u > 0:\n                    # Upwind nodes are from the left (i-1)\n                    cA_star = cA - courant * (cA - np.roll(cA, 1))\n                    cB_star = cB - courant * (cB - np.roll(cB, 1))\n                else: # u  0\n                    # Upwind nodes are from the right (i+1)\n                    cA_star = cA - courant * (np.roll(cA, -1) - cA)\n                    cB_star = cB - courant * (np.roll(cB, -1) - cB)\n            else:\n                cA_star = cA.copy()\n                cB_star = cB.copy()\n\n            # B. Reaction Step (using exact solution)\n            k_sum = k1 + k2\n            if k_sum > 0:\n                # Total concentration in each cell (conserved by reaction)\n                S = cA_star + cB_star\n                \n                # Equilibrium concentration for cA\n                cA_eq = S * k2 / k_sum\n                \n                # Initial deviation from equilibrium\n                cA_dev_initial = cA_star - cA_eq\n                \n                # Evolve deviation for time dt\n                cA_dev_final = cA_dev_initial * np.exp(-k_sum * dt)\n                \n                # Final concentrations after reaction\n                cA = cA_eq + cA_dev_final\n                cB = S - cA\n            else: # k1 = 0, k2 = 0, no reaction\n                cA = cA_star\n                cB = cB_star\n            \n            t += dt\n\n        # --- 4. Finalization ---\n        # Calculate final total mass\n        final_total_mass = np.sum(cA + cB) * dx\n        \n        # Calculate absolute relative change in total mass\n        if initial_total_mass == 0:\n            # Avoid division by zero, though unlikely with given ICs\n            relative_change = 0.0 if final_total_mass == 0 else np.inf\n        else:\n            relative_change = abs(final_total_mass - initial_total_mass) / initial_total_mass\n        \n        results.append(relative_change)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3130189"}, {"introduction": "掌握了理想情况下的应用后，我们转向一个在实际工程中普遍存在的挑战：几何复杂性。当计算网格与物理边界不完全对齐时，数值误差便可能产生。本练习 ([@problem_id:3130102]) 旨在探讨这一问题，通过分析一个角单元中错位的面法线，你将能够量化有限体积法中一个主要的误差来源，并深刻理解网格质量在确保计算精度方面的重要性。", "problem": "考虑一个由积分形式的守恒定律和本构关系控制的标量场的稳态扩散。守恒定律指出，穿过一个闭合控制体表面的向外通量的面积分等于该控制体内部源项的积分。对于无源情况，这简化为总向外通量为零的陈述。具有恒定标量传导率的扩散的本构关系由负的传导率与标量场梯度的乘积给出。具体来说，对于一个具有恒定传导率 $k$ 的标量场 $u(x,y)$，其通量矢量为 $-k \\nabla u$，无源稳态方程为 $\\nabla \\cdot (-k \\nabla u) = 0$。有限体积法离散化通过将通量投影到外向面法线上来强制通量平衡，因此面法线的对齐情况直接影响边界通量的施加。\n\n考虑一个邻近两个边界面的角落控制体，其边界条件在此处发生变化：一个面施加狄利克雷边界条件，而相邻的面施加诺伊曼边界条件。设该控制体位于单位正方形域的角落，位于 $x=0$ 上的面的外向法线为 $n_{x}^{\\text{true}} = (-1, 0)$，位于 $y=0$ 上的面的外向法线为 $n_{y}^{\\text{true}} = (0, -1)$。假设由于网格的偏斜或非正交性，离散施加中使用的面法线与真实法线未对齐：用于 $x=0$ 面的数值法线为 $n_{x}^{\\text{approx}} = R(\\theta_x) \\, n_{x}^{\\text{true}}$，用于 $y=0$ 面的数值法线为 $n_{y}^{\\text{approx}} = R(\\theta_y) \\, n_{y}^{\\text{true}}$，其中 $R(\\theta)$ 是由矩阵定义的按角度 $\\theta$ 旋转的平面旋转算子\n$$\nR(\\theta) = \\begin{bmatrix}\n\\cos \\theta  -\\sin \\theta \\\\\n\\sin \\theta  \\cos \\theta\n\\end{bmatrix}.\n$$\n假设精确解是线性的，$u(x,y) = a x + b y$，其中 $(a,b)$ 是常数，因此梯度 $\\nabla u = (a,b)$ 是恒定的，精确通量为 $q = -k \\nabla u = (-k a, -k b)$。在无源稳态下，投影到每个真实边界面法线上的精确向外通量是 $q \\cdot n^{\\text{true}}$，而使用未对齐法线的离散施加则将 $q$ 投影到 $n^{\\text{approx}}$上。\n\n将仅由面法线未对齐引起的角落施加误差定义为：在使用近似法线而非真实法线时，施加在两个相邻边界面上的向外通量之间的差值之和。具体而言，误差度量为\n$$\n\\Delta \\Phi = \\left( q \\cdot n_{x}^{\\text{approx}} - q \\cdot n_{x}^{\\text{true}} \\right) + \\left( q \\cdot n_{y}^{\\text{approx}} - q \\cdot n_{y}^{\\text{true}} \\right),\n$$\n这是角落面因法线未对齐而产生的总向外通量差异。由于每个通量投影都是单位面积上的值，该量应以瓦特每平方米 (W/m$^2$) 为单位报告。\n\n任务：从积分守恒定律和本构关系出发，使用旋转算子和矢量点积，推导出用 $k$、$a$、$b$、$\\theta_x$ 和 $\\theta_y$ 表示的 $\\Delta \\Phi$ 表达式。然后，实现一个程序，为以下每个测试用例计算 $\\Delta \\Phi$。角度以度为单位给出，计算时必须转换为弧度。传导率 $k$ 的单位是瓦特每米开尔文 (W/(m·K))。标量场梯度分量 $a$ 和 $b$ 的单位是开尔文每米 (K/m)。报告每个 $\\Delta \\Phi$ 的值，单位为瓦特每平方米 (W/m$^2$)。\n\n测试套件：\n- 案例 1：$k=1$, $a=1$, $b=1$, $\\theta_x=0$ 度, $\\theta_y=0$ 度。\n- 案例 2：$k=1$, $a=1$, $b=0.5$, $\\theta_x=5$ 度, $\\theta_y=5$ 度。\n- 案例 3：$k=2.5$, $a=0$, $b=1$, $\\theta_x=20$ 度, $\\theta_y=0$ 度。\n- 案例 4：$k=1.7$, $a=-0.8$, $b=0.3$, $\\theta_x=30$ 度, $\\theta_y=-15$ 度。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个值四舍五入到六位小数（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$）。角度必须解释为度并在内部转换为弧度；最终值为通量差异，单位为 W/m$^2$。", "solution": "问题陈述已经过验证，被认为是具有科学依据、适定且自洽的。它基于矢量微积分和计算物理学中有限体积法的基本原理，提出了一个明确的任务，即具体分析由几何非正交性引入的误差。因此，我们可以继续进行推导和求解。\n\n目标是推导角落施加误差 $\\Delta \\Phi$ 的解析表达式，并为一组给定的参数计算其值。该误差定义为，由于使用未对齐（近似）的面法线代替真实几何法线，而导致的穿过角落控制体两个相邻边界面向外通量的总差异。其定义如下：\n$$\n\\Delta \\Phi = \\left( q \\cdot n_{x}^{\\text{approx}} - q \\cdot n_{x}^{\\text{true}} \\right) + \\left( q \\cdot n_{y}^{\\text{approx}} - q \\cdot n_{y}^{\\text{true}} \\right)\n$$\n其中 $q$ 是热通量矢量，$n$ 表示 $x=0$ 和 $y=0$ 边界上各面的外指法向矢量。每一项（如 $q \\cdot n$）代表一个法向通量，单位为瓦特每平方米 (W/m$^2$)。\n\n让我们进行逐步推导。\n\n首先，我们定义基本矢量。标量场由 $u(x,y) = ax + by$ 给出，因此其梯度是恒定的：$\\nabla u = (a, b)$。本构关系给出通量矢量 $q$ 为：\n$$\nq = -k \\nabla u = -k \\begin{pmatrix} a \\\\ b \\end{pmatrix} = \\begin{pmatrix} -ka \\\\ -kb \\end{pmatrix}\n$$\n在边界 $x=0$ 和 $y=0$ 上的面的真实外向法线为：\n$$\nn_{x}^{\\text{true}} = \\begin{pmatrix} -1 \\\\ 0 \\end{pmatrix}, \\quad n_{y}^{\\text{true}} = \\begin{pmatrix} 0 \\\\ -1 \\end{pmatrix}\n$$\n\n其次，我们确定近似法线 $n_{x}^{\\text{approx}}$ 和 $n_{y}^{\\text{approx}}$。它们是通过使用提供的旋转矩阵，将真实法线分别旋转角度 $\\theta_x$ 和 $\\theta_y$ 得到的：\n$$\nR(\\theta) = \\begin{bmatrix} \\cos \\theta  -\\sin \\theta \\\\ \\sin \\theta  \\cos \\theta \\end{bmatrix}\n$$\n应用此旋转：\n$$\nn_{x}^{\\text{approx}} = R(\\theta_x) n_{x}^{\\text{true}} = \\begin{pmatrix} \\cos \\theta_x  -\\sin \\theta_x \\\\ \\sin \\theta_x  \\cos \\theta_x \\end{pmatrix} \\begin{pmatrix} -1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} -\\cos \\theta_x \\\\ -\\sin \\theta_x \\end{pmatrix}\n$$\n$$\nn_{y}^{\\text{approx}} = R(\\theta_y) n_{y}^{\\text{true}} = \\begin{pmatrix} \\cos \\theta_y  -\\sin \\theta_y \\\\ \\sin \\theta_y  \\cos \\theta_y \\end{pmatrix} \\begin{pmatrix} 0 \\\\ -1 \\end{pmatrix} = \\begin{pmatrix} \\sin \\theta_y \\\\ -\\cos \\theta_y \\end{pmatrix}\n$$\n\n第三，我们计算投影通量，即通量矢量 $q$ 与法向矢量的点积。\n投影到真实法线上的通量为：\n$$\nq \\cdot n_{x}^{\\text{true}} = \\begin{pmatrix} -ka \\\\ -kb \\end{pmatrix} \\cdot \\begin{pmatrix} -1 \\\\ 0 \\end{pmatrix} = (-ka)(-1) + (-kb)(0) = ka\n$$\n$$\nq \\cdot n_{y}^{\\text{true}} = \\begin{pmatrix} -ka \\\\ -kb \\end{pmatrix} \\cdot \\begin{pmatrix} 0 \\\\ -1 \\end{pmatrix} = (-ka)(0) + (-kb)(-1) = kb\n$$\n投影到近似法线上的通量为：\n$$\nq \\cdot n_{x}^{\\text{approx}} = \\begin{pmatrix} -ka \\\\ -kb \\end{pmatrix} \\cdot \\begin{pmatrix} -\\cos \\theta_x \\\\ -\\sin \\theta_x \\end{pmatrix} = (-ka)(-\\cos \\theta_x) + (-kb)(-\\sin \\theta_x) = ka \\cos \\theta_x + kb \\sin \\theta_x\n$$\n$$\nq \\cdot n_{y}^{\\text{approx}} = \\begin{pmatrix} -ka \\\\ -kb \\end{pmatrix} \\cdot \\begin{pmatrix} \\sin \\theta_y \\\\ -\\cos \\theta_y \\end{pmatrix} = (-ka)(\\sin \\theta_y) + (-kb)(-\\cos \\theta_y) = -ka \\sin \\theta_y + kb \\cos \\theta_y\n$$\n\n最后，我们将这些表达式代入 $\\Delta \\Phi$ 的定义中：\n$$\n\\Delta \\Phi = (ka \\cos \\theta_x + kb \\sin \\theta_x - ka) + (-ka \\sin \\theta_y + kb \\cos \\theta_y - kb)\n$$\n这个表达式可以通过提取公因式 $ka$ 和 $kb$ 来重新整理：\n$$\n\\Delta \\Phi = ka(\\cos \\theta_x - 1) + kb \\sin \\theta_x - ka \\sin \\theta_y + kb(\\cos \\theta_y - 1)\n$$\n对 $k$、$a$ 和 $b$ 进行进一步因式分解，得到角落施加误差的最终紧凑表达式：\n$$\n\\Delta \\Phi = k \\left[ a(\\cos \\theta_x - 1 - \\sin \\theta_y) + b(\\sin \\theta_x + \\cos \\theta_y - 1) \\right]\n$$\n这就是将用于解决给定测试用例问题的解析公式。以度为单位提供的角度 $\\theta_x$ 和 $\\theta_y$ 必须转换为弧度，才能在三角函数中使用。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and computes the corner flux enforcement error due to misaligned face normals\n    in a Finite Volume Method context.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'k': 1.0, 'a': 1.0, 'b': 1.0, 'theta_x_deg': 0.0, 'theta_y_deg': 0.0},\n        {'k': 1.0, 'a': 1.0, 'b': 0.5, 'theta_x_deg': 5.0, 'theta_y_deg': 5.0},\n        {'k': 2.5, 'a': 0.0, 'b': 1.0, 'theta_x_deg': 20.0, 'theta_y_deg': 0.0},\n        {'k': 1.7, 'a': -0.8, 'b': 0.3, 'theta_x_deg': 30.0, 'theta_y_deg': -15.0}\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract parameters for the current test case.\n        k = case['k']\n        a = case['a']\n        b = case['b']\n        theta_x_deg = case['theta_x_deg']\n        theta_y_deg = case['theta_y_deg']\n\n        # Convert angles from degrees to radians for trigonometric functions.\n        theta_x_rad = np.radians(theta_x_deg)\n        theta_y_rad = np.radians(theta_y_deg)\n\n        # Compute the components of the derived error formula:\n        # Delta_Phi = k * [ a*(cos(theta_x)-1-sin(theta_y)) + b*(sin(theta_x)+cos(theta_y)-1) ]\n        \n        # Calculate cos and sin values\n        cos_tx = np.cos(theta_x_rad)\n        sin_tx = np.sin(theta_x_rad)\n        cos_ty = np.cos(theta_y_rad)\n        sin_ty = np.sin(theta_y_rad)\n        \n        # Calculate term associated with gradient component 'a'\n        term_a = a * (cos_tx - 1.0 - sin_ty)\n        \n        # Calculate term associated with gradient component 'b'\n        term_b = b * (sin_tx + cos_ty - 1.0)\n        \n        # Combine terms to get the total flux error\n        delta_phi = k * (term_a + term_b)\n        \n        results.append(delta_phi)\n\n    # Format the results to six decimal places for the final output.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3130102"}]}