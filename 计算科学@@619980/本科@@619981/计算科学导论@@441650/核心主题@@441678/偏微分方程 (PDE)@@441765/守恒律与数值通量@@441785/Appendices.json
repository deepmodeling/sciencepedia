{"hands_on_practices": [{"introduction": "选择合适的数值通量是构建稳定数值格式的第一步，也是最关键的一步。本练习将探讨两种最基本的数值通量选择：迎风格式和中心格式，并应用于线性平流方程。通过亲手实现这两种格式并观察初始微小扰动的增长或衰减，您将深刻理解数值稳定性的核心概念，并明白为何迎风格式在双曲守恒律的数值方法中扮演着如此基础性的角色。[@problem_id:3111406]", "problem": "给定线性守恒律 $u_t + (f(u))_x = 0$，其中 $f(u) = c\\,u$，$c$ 是一个严格为正的常数。考虑一个在长度为 $L$ 的周期性区域上的均匀网格，该网格包含 $N$ 个单元。设 $U_i^n$ 表示在时间层 $n$ 时单元 $i$ 内的单元平均值，单元宽度为 $\\Delta x = L/N$，时间步长为 $\\Delta t$，库朗数为 $\\nu = c\\,\\Delta t/\\Delta x$。设 $\\mathcal{F}_{i+\\frac{1}{2}}$ 表示在单元 $i$ 和 $i+1$ 之间的界面上的一个相容的数值通量。显式前向欧拉有限体积更新格式为\n$$\nU_i^{n+1} \\;=\\; U_i^n \\;-\\;\\frac{\\Delta t}{\\Delta x}\\,\\Big(\\mathcal{F}_{i+\\frac{1}{2}} - \\mathcal{F}_{i-\\frac{1}{2}}\\Big), \n$$\n并采用周期性边界条件。\n\n需要比较两种通量：\n\n- 对于 $c>0$ 的迎风格式通量：$\\mathcal{F}_{i+\\frac{1}{2}}^{\\mathrm{up}} = c\\,U_i^n$。\n- 中心格式通量：$\\mathcal{F}_{i+\\frac{1}{2}}^{\\mathrm{ce}} = \\tfrac{1}{2}\\,c\\,(U_i^n + U_{i+1}^n)$。\n\n从离散守恒律的基本定义和这些通量选择出发，根据基本原理推导以下性质。\n\n1) 离散稳态：离散稳态是指任何一个网格函数 $U_i$，使得对于所有 $i$，显式更新都得到 $U_i^{n+1} = U_i^n$。找出给定方程和通量的离散稳态，并确定常数状态 $U_i \\equiv U_0$ 在每种格式下是否保持不变。\n\n2) 关于稳态的线性稳定性：对于常数稳态附近的一个小微扰 $U_i^n = U_0 + \\varepsilon\\,\\phi_i^n$（其中 $0  \\varepsilon \\ll 1$），确定微扰振幅是否会随时间增长。使用 Courant–Friedrichs–Lewy (CFL) 数 $\\nu$ 作为无量纲控制参数。您的推理必须从离散更新格式和周期性网格上的容许傅里叶模态开始。\n\n3) 数值验证：实现这两种有限体积格式，以说明：\n- 在迎风格式通量下，离散稳态在微扰不增长（对于 $0 \\le \\nu \\le 1$）的意义下是保持的；与稳态的距离是非增的。\n- 在中心格式通量下，离散稳态在临界的 CFL 选择下会发生漂移，也就是说，任何非零的 $\\nu$ 都会导致非平凡微扰的增长。\n\n您必须通过测量最终时刻的微扰范数与初始值的比率来量化“保持”与“漂移”。\n\n实现要求：\n\n- 区域与参数：使用长度为 $L = 1$ 的周期性区域，波速 $c = 1$，单元数 $N = 128$，单元中心位于 $x_i = (i+\\tfrac{1}{2})\\,\\Delta x$ 且 $\\Delta x = L/N$，时间步数 $M = 200$。\n- 初始数据：$U_i^0 = U_0 + \\varepsilon \\sin(2\\pi k x_i)$，其中 $U_0 = 1$，波数 $k = 1$，微扰振幅 $\\varepsilon = 10^{-3}$。\n- 时间步长：对于每次测试，根据指定的 $\\nu$ 选择 $\\Delta t = \\nu\\,\\Delta x / c$。\n- 微扰范数：对于任意向量 $U$，将其相对于其空间平均值 $\\bar U = \\frac{1}{N}\\sum_i U_i$ 的微扰定义为 $\\delta U = U - \\bar U\\,\\mathbf{1}$，离散 $L^2$ 范数定义为 $\\|\\delta U\\|_2 = \\sqrt{\\sum_i (\\delta U_i)^2}$。对于每种格式和每次测试，计算比率 $R = \\|\\delta U^{M}\\|_2/\\|\\delta U^{0}\\|_2$。\n- 测试组 (CFL 数)：对 $\\nu \\in \\{0.1,\\,0.5,\\,0.9\\}$ 运行测试。\n- 程序需要检查的预期行为：对于迎风格式通量，$R \\le 1$；对于中心格式通量，$R  1$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含六个比率，按以下顺序以逗号分隔，并用方括号括起来：\n$$\n[\\;R_{\\mathrm{up}}(\\nu{=}0.1),\\;R_{\\mathrm{ce}}(\\nu{=}0.1),\\;R_{\\mathrm{up}}(\\nu{=}0.5),\\;R_{\\mathrm{ce}}(\\nu{=}0.5),\\;R_{\\mathrm{up}}(\\nu{=}0.9),\\;R_{\\mathrm{ce}}(\\nu{=}0.9)\\;].\n$$\n将每个比率表示为小数（无单位），四舍五入到小数点后六位。不应打印任何其他文本。", "solution": "该问题要求对用于求解线性平流方程 $u_t + c u_x = 0$（其中 $c  0$ 为常数）的两种有限体积格式进行基本原理分析。该方程是形式为 $u_t + (f(u))_x = 0$ 的守恒律，其通量函数是线性的 $f(u) = c\\,u$。有限体积法近似该定律的积分形式。对于单元宽度为 $\\Delta x$、时间步长为 $\\Delta t$ 的均匀网格，单元 $i$ 在时间 $n$ 的单元平均值 $U_i^n$ 使用显式前向欧拉格式进行更新：\n$$\nU_i^{n+1} \\;=\\; U_i^n \\;-\\;\\frac{\\Delta t}{\\Delta x}\\,\\Big(\\mathcal{F}_{i+\\frac{1}{2}} - \\mathcal{F}_{i-\\frac{1}{2}}\\Big)\n$$\n其中 $\\mathcal{F}_{i+\\frac{1}{2}}$ 是单元 $i$ 和 $i+1$ 之间界面上的数值通量。我们分析两种通量选择：迎风格式通量 $\\mathcal{F}_{i+\\frac{1}{2}}^{\\mathrm{up}} = c\\,U_i^n$ (因为 $c0$) 和中心格式通量 $\\mathcal{F}_{i+\\frac{1}{2}}^{\\mathrm{ce}} = \\frac{1}{2}\\,c\\,(U_i^n + U_{i+1}^n)$。库朗数定义为 $\\nu = c\\,\\Delta t/\\Delta x$。\n\n1) 离散稳态。\n离散稳态是一个不随时间变化的网格函数 $U_i$，即对所有网格索引 $i$ 都有 $U_i^{n+1} = U_i^n$。将此条件代入更新方程可得：\n$$\n0 \\;=\\; -\\frac{\\Delta t}{\\Delta x}\\,\\Big(\\mathcal{F}_{i+\\frac{1}{2}} - \\mathcal{F}_{i-\\frac{1}{2}}\\Big)\n$$\n因为 $\\Delta t  0$ 和 $\\Delta x  0$，这意味着对所有 $i$ 都有 $\\mathcal{F}_{i+\\frac{1}{2}} = \\mathcal{F}_{i-\\frac{1}{2}}$。由于采用周期性边界条件，这意味着数值通量在所有单元界面上必须是恒定的：$\\mathcal{F}_{i+\\frac{1}{2}} = F_{const}$，其中 $F_{const}$ 是某个常数。\n\n对于迎风格式通量，$\\mathcal{F}_{i+\\frac{1}{2}}^{\\mathrm{up}} = c\\,U_i$。稳态条件变为 $c\\,U_i = F_{const}$。由于 $c$ 是一个严格为正的常数，这要求 $U_i = F_{const} / c$。因此，任何常数网格函数 $U_i = U_{const}$ 都是迎风格式的离散稳态。具体来说，常数状态 $U_i \\equiv U_0$ 是不变的。如果对所有 $i$ 都有 $U_i^n = U_0$，那么 $\\mathcal{F}_{i+\\frac{1}{2}}^{\\mathrm{up}} = c\\,U_0$ 且 $\\mathcal{F}_{i-\\frac{1}{2}}^{\\mathrm{up}} = c\\,U_0$，使得更新项为零。\n\n对于中心格式通量，$\\mathcal{F}_{i+\\frac{1}{2}}^{\\mathrm{ce}} = \\frac{1}{2}\\,c\\,(U_i + U_{i+1})$。稳态条件是 $\\frac{1}{2}\\,c\\,(U_i + U_{i+1}) = F_{const}$，或 $U_i + U_{i+1} = C_{const}$，其中 $C_{const} = 2F_{const}/c$。任何常数网格函数 $U_i = U_0$（此时 $C_{const} = 2U_0$）都满足这个递推关系，因此常数状态 $U_i \\equiv U_0$ 在中心格式下也是不变的。然而，这个条件也允许非恒定的解。例如，形式为 $U_i = A(-1)^i + B$（其中 $A$ 和 $B$ 是常数）的周期为2的波是一个稳态，因为 $U_i + U_{i+1} = (A(-1)^i + B) + (A(-1)^{i+1} + B) = 2B = C_{const}$。这些非恒定的解通常被称为伪稳态。\n\n2) 关于稳态的线性稳定性。\n我们通过考虑小微扰 $U_i^n = U_0 + \\varepsilon\\,\\phi_i^n$（其中 $0  \\varepsilon \\ll 1$）的演化来分析常数稳态 $U_0$ 的稳定性。由于两种格式都是线性的，控制微扰 $\\phi_i^n$ 的方程与控制 $U_i^n$ 的方程相同。我们通过将微扰分解为周期性网格上的傅里叶模态来应用冯·诺依曼稳定性分析。单个傅里叶模态的形式为 $\\phi_i^n = (g(\\xi))^n e^{\\mathrm{j} i \\xi}$，其中 $\\xi = k_g \\Delta x$ 是无量纲波数，$k_g$ 是物理波数，$\\mathrm{j} = \\sqrt{-1}$，$g(\\xi)$ 是复放大因子。如果对于所有容许的波数 $\\xi$，都有 $|g(\\xi)| \\le 1$，则该格式是稳定的。\n\n对于迎风格式，更新方程可以写为：\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x}(c\\,U_i^n - c\\,U_{i-1}^n) = U_i^n - \\nu(U_i^n - U_{i-1}^n) = (1-\\nu)U_i^n + \\nu U_{i-1}^n\n$$\n将傅里叶模态 $\\phi_i^n = g^n e^{\\mathrm{j} i \\xi}$ 代入微扰方程得到：\n$$\ng^{n+1}e^{\\mathrm{j} i \\xi} = (1-\\nu)g^n e^{\\mathrm{j} i \\xi} + \\nu g^n e^{\\mathrm{j} (i-1) \\xi}\n$$\n两边同除以 $g^n e^{\\mathrm{j} i \\xi}$ 得到放大因子：\n$$\ng(\\xi) = 1 - \\nu + \\nu e^{-\\mathrm{j}\\xi} = 1 - \\nu + \\nu(\\cos\\xi - \\mathrm{j}\\sin\\xi)\n$$\n其模的平方为：\n$$\n|g(\\xi)|^2 = (1 - \\nu + \\nu\\cos\\xi)^2 + (-\\nu\\sin\\xi)^2 = 1 - 2\\nu(1-\\nu)(1-\\cos\\xi)\n$$\n为了保证稳定性，我们需要 $|g(\\xi)|^2 \\le 1$，这意味着 $2\\nu(1-\\nu)(1-\\cos\\xi) \\ge 0$。由于对于所有实数 $\\xi$ 都有 $1-\\cos\\xi \\ge 0$，该条件简化为 $\\nu(1-\\nu) \\ge 0$。这在 $0 \\le \\nu \\le 1$ 时成立。因此，迎风格式是条件稳定的。对于此范围内的 $\\nu$，微扰不会增长。此外，对于 $\\nu \\in (0, 1)$ 和 $\\xi \\ne 0$，我们有 $|g(\\xi)|  1$，这表明该格式是耗散的，并且会随时间衰减微扰。\n\n对于中心格式，更新方程为：\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x}\\left(\\frac{c}{2}(U_i^n+U_{i+1}^n) - \\frac{c}{2}(U_{i-1}^n+U_i^n)\\right) = U_i^n - \\frac{\\nu}{2}(U_{i+1}^n - U_{i-1}^n)\n$$\n代入傅里叶模态得到：\n$$\ng^{n+1}e^{\\mathrm{j} i \\xi} = g^n e^{\\mathrm{j} i \\xi} - \\frac{\\nu}{2}(g^n e^{\\mathrm{j} (i+1) \\xi} - g^n e^{\\mathrm{j} (i-1) \\xi})\n$$\n放大因子为：\n$$\ng(\\xi) = 1 - \\frac{\\nu}{2}(e^{\\mathrm{j}\\xi} - e^{-\\mathrm{j}\\xi}) = 1 - \\frac{\\nu}{2}(2\\mathrm{j}\\sin\\xi) = 1 - \\mathrm{j}\\nu\\sin\\xi\n$$\n其模的平方为：\n$$\n|g(\\xi)|^2 = 1^2 + (-\\nu\\sin\\xi)^2 = 1 + \\nu^2\\sin^2\\xi\n$$\n稳定性条件 $|g(\\xi)|^2 \\le 1$ 要求 $1 + \\nu^2\\sin^2\\xi \\le 1$，这简化为 $\\nu^2\\sin^2\\xi \\le 0$。由于 $\\nu^2 \\ge 0$ 和 $\\sin^2\\xi \\ge 0$，这个条件只在 $\\nu=0$ 或 $\\sin\\xi=0$ 时满足。对于任何 $\\nu0$ 和任何具有 $\\sin\\xi \\ne 0$ 的模态，我们有 $|g(\\xi)|  1$。因此，对于任何 $\\nu0$，该格式都是无条件不稳定的。任何包含不稳定傅里叶分量的非平凡微扰都将随时间增长。\n\n3) 数值验证。\n数值实验说明了这些稳定性性质。微扰是相对于空间平均值 $\\delta U = U - \\bar U \\mathbf{1}$ 定义的。对于一个守恒格式，平均值 $\\bar U$ 随时间保持不变。分析 $\\|\\delta U\\|_2$ 等同于分析所有非零波数模态（$\\xi \\ne 0$）的演化。\n\n对于迎风格式，在测试的库朗数 $\\nu \\in \\{0.1, 0.5, 0.9\\}$ 都落在稳定范围 $[0, 1]$ 内的情况下，对于初始正弦微扰的所有非零波数分量，放大因子满足 $|g(\\xi)|  1$。因此，预计微扰的振幅会随时间减小。比率 $R = \\|\\delta U^M\\|_2 / \\|\\delta U^0\\|_2$ 应小于或等于 $1$，从而证实了离散稳态在微扰被衰减的意义下是保持的。\n\n对于中心格式，稳定性分析表明，对于任何非零的 $\\nu$，都存在 $|g(\\xi)|  1$ 的不稳定模态。初始的正弦微扰包含这类模态。它们的振幅将随时间增长，导致微扰的整体范数增加。因此，比率 $R$ 预计将大于 $1$，这证明了常数稳态是不稳定的，并且由于任何小微扰的增长而“漂移”。程序将计算这些比率以验证这一理论预测。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the linear advection equation using upwind and central finite volume schemes\n    to demonstrate stability properties.\n    \"\"\"\n    # Define parameters from the problem statement\n    L = 1.0\n    c = 1.0\n    N = 128\n    U0 = 1.0\n    epsilon = 1e-3\n    k_wave = 1\n    M = 200\n    \n    # Test cases are the different Courant numbers (nu)\n    test_cases_nu = [0.1, 0.5, 0.9]\n\n    # Set up the computational grid\n    dx = L / N\n    x = (np.arange(N, dtype=np.float64) + 0.5) * dx\n\n    # Define the initial condition\n    U_initial = U0 + epsilon * np.sin(2 * np.pi * k_wave * x)\n\n    # Calculate the norm of the initial perturbation\n    # The perturbation is defined relative to the spatial mean.\n    U_mean_initial = np.mean(U_initial)\n    delta_U_initial = U_initial - U_mean_initial\n    norm_delta_U_initial = np.linalg.norm(delta_U_initial)\n\n    results = []\n    # Loop over the specified Courant-Friedrichs-Lewy (CFL) numbers\n    for nu in test_cases_nu:\n        \n        # --- Upwind Scheme ---\n        U_up = np.copy(U_initial)\n        for _ in range(M):\n            # U_i^{n+1} = U_i^n - nu * (U_i^n - U_{i-1}^n)\n            # Periodic boundary conditions are handled by np.roll\n            U_up = U_up - nu * (U_up - np.roll(U_up, 1, axis=0))\n\n        # Calculate the ratio R for the upwind scheme\n        U_mean_final_up = np.mean(U_up)\n        delta_U_final_up = U_up - U_mean_final_up\n        norm_delta_U_final_up = np.linalg.norm(delta_U_final_up)\n        R_up = norm_delta_U_final_up / norm_delta_U_initial\n        results.append(R_up)\n\n        # --- Central Flux Scheme ---\n        U_ce = np.copy(U_initial)\n        for _ in range(M):\n            # U_i^{n+1} = U_i^n - (nu/2) * (U_{i+1}^n - U_{i-1}^n)\n            # Periodic boundary conditions are handled by np.roll\n            U_ce = U_ce - (nu / 2.0) * (np.roll(U_ce, -1, axis=0) - np.roll(U_ce, 1, axis=0))\n        \n        # Calculate the ratio R for the central scheme\n        U_mean_final_ce = np.mean(U_ce)\n        delta_U_final_ce = U_ce - U_mean_final_ce\n        norm_delta_U_final_ce = np.linalg.norm(delta_U_final_ce)\n        R_ce = norm_delta_U_final_ce / norm_delta_U_initial\n        results.append(R_ce)\n    \n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3111406"}, {"introduction": "在确保了格式的稳定性之后，提升计算精度便成为下一个核心目标。本练习旨在引导您从一阶方法迈向二阶方法，通过引入高阶的MUSCL（Monotonic Upstream-centered Schemes for Conservation Laws）空间重构来求解带有稀疏波的 Burgers 方程。您将把它与简单的一阶分段常数重构进行对比，从而直观地量化高阶方法在解析光滑流动特征（如稀疏波）时所带来的显著精度优势。[@problem_id:3111448]", "problem": "考虑一维空间域上的标量守恒律 $u_t + f(u)_x = 0$，其中通量由 $f(u) = \\tfrac{1}{2} u^2$ 给出（无粘伯格斯方程）。从控制体的积分守恒形式出发，设计一种有限体积法，通过跨网格界面的净数值通量来推进网格平均值的时间演化。您必须使用一个包含 $N_x$ 个网格的均匀网格，覆盖域 $[x_{\\min}, x_{\\max}] = [-1, 1]$，并采用透射（流出）边界条件。两种重构方法必须使用相同的数值通量，特别是与指定 $f(u)$ 相关的局部 Lax-Friedrichs 通量（也称为 Rusanov 通量），并且时间步长必须满足 Courant-Friedrichs-Lewy (CFL) 稳定性条件。\n\n研究两种不同的空间重构方法如何与相同的数值通量 $\\hat f$ 相互作用，以影响稀疏波附近的精度：\n- 分段常数重构（一阶有限体积法）。\n- 使用守恒律单调上游中心格式 (Monotonic Upstream-centered Schemes for Conservation Laws, MUSCL) 的分段线性重构，并配以保持单调性的斜率限制器（使用一个能防止产生新极值的限制器）。\n\n使用能够产生伯格斯方程中心稀疏波的黎曼型初始条件：\n$$\nu(x,0) =\n\\begin{cases}\nu_L,  x  x_0, \\\\\nu_R,  x \\ge x_0,\n\\end{cases}\n$$\n其中 $u_L = 0$，$u_R = 1$，且 $x_0 = 0$。将解演化至 $t_{\\text{final}} = 0.2$，使用固定的 Courant-Friedrichs-Lewy (CFL) 数 $\\text{CFL} = 0.45$，并在 $x_{\\min}$ 和 $x_{\\max}$ 处采用透射边界条件。对于每种重构方法，在时间 $t_{\\text{final}}$ 时，计算网格中心处的数值解与无粘伯格斯方程精确中心稀疏波解的误差。使用离散 $L^1$ 范数来量化误差：\n$$\nE_{L^1} = \\Delta x \\sum_{i=1}^{N_x} \\left| u_i^{\\text{num}}(t_{\\text{final}}) - u^{\\text{exact}}(x_i, t_{\\text{final}}) \\right|.\n$$\n\n测试套件：\n- 情况 1：$N_x = 40$。\n- 情况 2：$N_x = 80$。\n- 情况 3：$N_x = 160$。\n\n对于每种情况，计算并报告两个 $L^1$ 误差：分段常数重构的误差和分段线性 MUSCL 重构的误差。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：\n$$\n[\\;E_{\\text{PC},40},\\;E_{\\text{MUSCL},40},\\;E_{\\text{PC},80},\\;E_{\\text{MUSCL},80},\\;E_{\\text{PC},160},\\;E_{\\text{MUSCL},160}\\;].\n$$\n所有输出必须是实数（浮点数），无物理单位。角度单位不适用于此问题。研究必须纯粹在数学和算法层面进行，从积分守恒律和一致的数值通量推导得出，不依赖于问题陈述中未说明的捷径或预定公式。", "solution": "用户要求使用有限体积法对无粘伯格斯方程进行数值求解。该问题旨在比较一阶（分段常数）重构与二阶 MUSCL（带斜率限制器的分段线性）重构的精度，特别是在稀疏波的情况下。两种格式的数值通量都固定为局部 Lax-Friedrichs (Rusanov) 通量。\n\n任务的核心是基于标量守恒律 $u_t + f(u)_x = 0$ 的第一性原理，实现一个有限体积求解器。\n\n**1. 有限体积框架**\n对于一个控制体（网格）$[x_{i-1/2}, x_{i+1/2}]$，守恒律的积分形式为\n$$\n\\frac{d}{dt} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) \\,dx + f(u(x_{i+1/2},t)) - f(u(x_{i-1/2},t)) = 0.\n$$\n定义网格平均值为 $\\bar{u}_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) \\,dx$，其中 $\\Delta x$ 是均匀的网格宽度，我们得到\n$$\n\\frac{d\\bar{u}_i}{dt} = -\\frac{1}{\\Delta x} \\left( f(u(x_{i+1/2},t)) - f(u(x_{i-1/2},t)) \\right).\n$$\n使用前向欧拉格式对时间进行离散，并用数值通量函数 $\\hat{f}$ 替换界面处的精确通量，得到更新公式：\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x} \\left( \\hat{f}_{i+1/2} - \\hat{f}_{i-1/2} \\right).\n$$\n这里，$\\hat{f}_{i+1/2} = \\hat{f}(u_{i+1/2}^L, u_{i+1/2}^R)$ 依赖于界面 $x_{i+1/2}$ 左侧（L）和右侧（R）的重构状态。\n\n**2. 数值通量：Rusanov 通量**\n问题指定了局部 Lax-Friedrichs 通量，即 Rusanov 通量：\n$$\n\\hat{f}(u_L, u_R) = \\frac{1}{2} [f(u_L) + f(u_R)] - \\frac{\\alpha}{2} (u_R - u_L).\n$$\n对于通量函数 $f(u) = \\frac{1}{2}u^2$，特征速度为 $f'(u) = u$。耗散系数 $\\alpha$ 是局部最大特征速度，即 $\\alpha = \\max(|u_L|, |u_R|)$。\n\n**3. 空间重构**\n-   **分段常数 (PC)**：这种一阶方法假设解在每个网格内是常数 $\\bar{u}_i$。因此，界面 $x_{i+1/2}$ 处的状态为：\n    $$\n    u_{i+1/2}^L = \\bar{u}_i, \\quad u_{i+1/2}^R = \\bar{u}_{i+1}.\n    $$\n\n-   **分段线性 (MUSCL)**：这种二阶方法在每个网格内重构一个线性剖面：$u(x) = \\bar{u}_i + \\sigma_i \\frac{x-x_i}{\\Delta x}$。斜率 $\\sigma_i$ 受到限制以防止振荡。问题要求使用一个能防止产生新极值的限制器；`minmod` 限制器是满足此总变差减小 (TVD) 属性的标准选择。受限斜率由相邻网格平均值之间的差值计算得出：\n    $$\n    \\sigma_i = \\text{minmod}(\\bar{u}_{i+1} - \\bar{u}_i, \\bar{u}_i - \\bar{u}_{i-1}).\n    $$\n    界面 $x_{i+1/2}$ 处的状态是通过在该位置评估网格 $i$ 和 $i+1$ 的线性重构得到的：\n    $$\n    u_{i+1/2}^L = \\bar{u}_i + \\frac{1}{2}\\sigma_i, \\quad u_{i+1/2}^R = \\bar{u}_{i+1} - \\frac{1}{2}\\sigma_{i+1}.\n    $$\n\n**4. 边界和初始条件**\n-   **初始条件**：对于 $x_0 = 0$ 处 $u_L = 0$ 和 $u_R = 1$ 的黎曼问题，通过将网格平均值 $\\bar{u}_i$ 设置为初始函数在网格中心 $x_i$ 处的值来初始化。\n-   **边界条件**：透射（流出）条件通过使用虚拟网格来处理。虚拟网格中的值被设置为物理域中最近网格的值。在每侧使用两个虚拟网格，以便为 MUSCL 格式在边界附近正确计算斜率。\n\n**5. 时间步长和误差**\n-   **时间步长**：时间步长 $\\Delta t$ 由 CFL 条件控制，CFL 数固定为 $0.45$：$\\Delta t = \\text{CFL} \\frac{\\Delta x}{\\max|\\bar{u}_i|}$。\n-   **精确解**：初始条件产生一个中心稀疏波，其在时间 $t$ 的精确解为：\n    $$\n    u(x,t) = \\begin{cases} 0  \\text{if } x/t  0 \\\\ x/t  \\text{if } 0 \\le x/t \\le 1 \\\\ 1  \\text{if } x/t  1 \\end{cases}\n    $$\n-   **误差计算**：数值误差使用离散 $L^1$ 范数来衡量，$E_{L^1} = \\Delta x \\sum_{i=1}^{N_x} | \\bar{u}_i^{\\text{num}}(t_{\\text{final}}) - u^{\\text{exact}}(x_i, t_{\\text{final}}) |$。\n\n**实现**\n该解法在 Python 中实现。一个主函数为给定的网格大小 $N_x$ 和重构类型组织模拟。该函数管理时间步进循环，通过虚拟网格应用边界条件，调用适当的重构和通量函数，更新解，并最终计算与精确解的误差。主脚本为测试套件中的每种情况（$N_x=40, 80, 160$）调用此函数，并按规定格式化所得误差。为了性能，使用了 `numpy` 的向量化操作。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    X_MIN, X_MAX = -1.0, 1.0\n    T_FINAL = 0.2\n    CFL = 0.45\n    U_L, U_R = 0.0, 1.0\n    X0 = 0.0\n    TEST_CASES_NX = [40, 80, 160]\n    RECONSTRUCTIONS = ['PC', 'MUSCL']\n\n    def flux_function(u):\n        \"\"\"Physical flux for Burgers' equation.\"\"\"\n        return 0.5 * u**2\n\n    def rusanov_flux(u_l, u_r):\n        \"\"\"Rusanov (local Lax-Friedrichs) numerical flux.\"\"\"\n        f_l = flux_function(u_l)\n        f_r = flux_function(u_r)\n        alpha = np.maximum(np.abs(u_l), np.abs(u_r))\n        return 0.5 * (f_l + f_r) - 0.5 * alpha * (u_r - u_l)\n\n    def minmod(a, b):\n        \"\"\"Element-wise minmod function for slope limiting.\"\"\"\n        # Note: np.sign(0) is 0, so this handles zero-valued arguments correctly.\n        return np.where(a * b > 0, np.sign(a) * np.minimum(np.abs(a), np.abs(b)), 0)\n\n    def get_exact_solution(x, t):\n        \"\"\"Exact solution for the centered rarefaction wave.\"\"\"\n        if t == 0:\n            return np.where(x  X0, U_L, U_R)\n        \n        # To avoid division by zero if t=0, although problem is for t > 0.\n        s = x / t if t > 0 else np.full_like(x, np.inf) * np.sign(x)\n        u = np.zeros_like(x)\n        \n        left_mask = s  U_L\n        right_mask = s > U_R\n        rarefaction_mask = (~left_mask)  (~right_mask)\n        \n        u[left_mask] = U_L\n        u[right_mask] = U_R\n        u[rarefaction_mask] = s[rarefaction_mask]\n        return u\n\n    def solve_fvm(Nx, reconstruction_type):\n        \"\"\"\n        Solves the inviscid Burgers' equation using a finite volume method.\n        \"\"\"\n        dx = (X_MAX - X_MIN) / Nx\n        x_centers = X_MIN + (np.arange(Nx) + 0.5) * dx\n        \n        u = get_exact_solution(x_centers, 0.0)\n        \n        t = 0.0\n        num_ghost = 2\n        \n        while t  T_FINAL:\n            max_abs_u = np.max(np.abs(u))\n            dt = CFL * dx / max_abs_u if max_abs_u > 1e-9 else CFL * dx\n            if t + dt > T_FINAL:\n                dt = T_FINAL - t\n\n            # Create padded array and apply transmissive boundary conditions\n            u_padded = np.zeros(Nx + 2 * num_ghost)\n            u_padded[num_ghost:-num_ghost] = u\n            u_padded[:num_ghost] = u[0]\n            u_padded[-num_ghost:] = u[-1]\n            \n            # --- Reconstruction to find u_l and u_r at interfaces ---\n            if reconstruction_type == 'PC':\n                # Piecewise Constant: u_L = u_i, u_R = u_{i+1}\n                # Interfaces are between padded cells: (1,2), (2,3), ..., (Nx+1, Nx+2)\n                # These correspond to interfaces around domain cells 0 to Nx-1.\n                u_l = u_padded[num_ghost-1 : -num_ghost]\n                u_r = u_padded[num_ghost : -num_ghost+1]\n            \n            elif reconstruction_type == 'MUSCL':\n                # MUSCL: Calculate limited slopes\n                slopes = np.zeros_like(u_padded)\n                # Slopes calculated for cells including one layer of ghost cells\n                du_backward = u_padded[1:-2] - u_padded[0:-3]\n                du_forward = u_padded[2:-1] - u_padded[1:-2]\n                slopes[1:-2] = minmod(du_backward, du_forward)\n                \n                # Reconstruct values at interfaces\n                # u_L = u_i + 0.5*sigma_i, u_R = u_{i+1} - 0.5*sigma_{i+1}\n                u_l = u_padded[num_ghost-1 : -num_ghost] + 0.5 * slopes[num_ghost-1 : -num_ghost]\n                u_r = u_padded[num_ghost : -num_ghost+1] - 0.5 * slopes[num_ghost : -num_ghost+1]\n            \n            else:\n                raise ValueError(\"Invalid reconstruction type specified.\")\n            \n            # Compute numerical flux at interfaces\n            flux_at_interfaces = rusanov_flux(u_l, u_r)\n            \n            # Update cell averages\n            u = u - (dt / dx) * (flux_at_interfaces[1:] - flux_at_interfaces[:-1])\n            \n            t += dt\n\n        # Compute L1 error against the exact solution\n        u_exact = get_exact_solution(x_centers, T_FINAL)\n        error_l1 = dx * np.sum(np.abs(u - u_exact))\n        return error_l1\n\n    results = []\n    for nx_val in TEST_CASES_NX:\n        for recon in RECONSTRUCTIONS:\n            error = solve_fvm(nx_val, recon)\n            results.append(error)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3111448"}, {"introduction": "尽管高阶格式在处理光滑解时表现出色，但它们在间断（如激波）附近会产生非物理的吉布斯振荡。本练习将直面这一挑战，您需要在一个二阶MUSCL格式中实现一个斜率限制器（minmod limiter），以构建一个总变差不增（TVD）的稳健格式。通过量化不同通量函数在间断附近产生的过冲和下冲，您将掌握一项关键技术，学会如何构建能够同时精确捕捉光滑与间断流动的数值方法。[@problem_id:3111412]", "problem": "考虑一维标量守恒律 $u_t + f(u)_x = 0$ 在周期性区域 $x \\in [0,L]$ 上的情况，其线性通量为 $f(u) = a\\,u$，其中 $a$ 是一个恒定的平流速度。初始数据是一个间断阶跃（一种黎曼型数据），形式如下：\n$$\nu(x,0) = \\begin{cases}\nu_L,  x  x_0,\\\\\nu_R,  x \\ge x_0,\n\\end{cases}\n$$\n该数据在具有 $N$ 个单元的均匀有限体积网格上进行解释，单元中心为 $x_i = \\left(i + \\tfrac{1}{2}\\right)\\Delta x$（其中 $i=0,\\dots,N-1$，$\\Delta x = L/N$），并采用周期性边界。本题要求推导并实现两种仅在数值通量函数上有所不同的二阶有限体积格式，然后量化平流间断附近的类 Gibbs 过冲和下冲。\n\n从第一性原理出发。您必须使用以下基本要素，然后推导所需的一切其他内容。\n\n- 单元 $i$ 上的守恒（积分）形式：单元平均值的变化率等于通过其界面的净通量。\n- 在每个单元内使用带有总变差递减（TVD）斜率限制器的分段线性重构。对斜率使用 minmod 限制器。\n- 针对常微分方程组法的半离散系统，采用二阶的两阶段强稳定保持（SSP）Runge-Kutta 时间积分器。\n\n您的任务是：\n\n1) 有限体积半离散化。从单元平均值的守恒出发，推导半离散更新式\n$$\n\\frac{d \\bar u_i}{dt} = -\\frac{1}{\\Delta x}\\left(F_{i+\\tfrac{1}{2}} - F_{i-\\tfrac{1}{2}}\\right),\n$$\n其中 $F_{i+\\tfrac{1}{2}}$ 是在界面 $x_{i+\\tfrac{1}{2}}$ 处，根据重构的左右界面状态 $u_{i+\\tfrac{1}{2}}^{-}$ 和 $u_{i+\\tfrac{1}{2}}^{+}$ 计算得到的一致性数值通量。\n\n2) 斜率限制的 MUSCL 重构。根据相邻单元的平均值 $\\bar u_{i-1},\\bar u_i,\\bar u_{i+1}$，构建具有斜率\n$$\ns_i = \\operatorname{minmod}\\!\\left(\\bar u_i - \\bar u_{i-1},\\, \\bar u_{i+1} - \\bar u_i\\right),\n$$\n和界面状态\n$$\nu_{i+\\tfrac{1}{2}}^{-} = \\bar u_i + \\tfrac{1}{2} s_i,\\qquad\nu_{i+\\tfrac{1}{2}}^{+} = \\bar u_{i+1} - \\tfrac{1}{2} s_{i+1}\n$$\n的分段线性重构。此处，若 $\\alpha\\beta \\le 0$，则 $\\operatorname{minmod}(\\alpha,\\beta)$ 返回 $0$，否则返回 $\\operatorname{sign}(\\alpha)\\min(|\\alpha|,|\\beta|)$。周期性地处理索引。\n\n3) 使用相同重构的两种数值通量：\n- 用于线性平流的迎风-Godunov 通量。对于 $a0$，精确的黎曼求解器给出 $F_{i+\\tfrac{1}{2}}^{\\text{up}} = a\\,u_{i+\\tfrac{1}{2}}^{-}$。对于 $a  0$，它给出 $F_{i+\\tfrac{1}{2}}^{\\text{up}} = a\\,u_{i+\\tfrac{1}{2}}^{+}$。\n- 用于线性平流的二阶中心 Lax-Wendroff 通量。基于时间上的泰勒展开，并利用偏微分方程替换 $u_t$，推导界面上的单步二阶中心通量。证明对于左右界面状态 $u_{i+\\tfrac{1}{2}}^{-}$ 和 $u_{i+\\tfrac{1}{2}}^{+}$ 以及 Courant-Friedrichs-Lewy (CFL) 数 $\\lambda = a\\,\\Delta t/\\Delta x$，一个一致的二阶中心数值通量可以写为\n$$\nF_{i+\\tfrac{1}{2}}^{\\text{LW}} = a\\left[\\tfrac{1}{2}\\left(u_{i+\\tfrac{1}{2}}^{-} + u_{i+\\tfrac{1}{2}}^{+}\\right) - \\tfrac{1}{2}\\lambda \\left(u_{i+\\tfrac{1}{2}}^{+} - u_{i+\\tfrac{1}{2}}^{-}\\right)\\right].\n$$\n\n4) 时间积分。使用二阶的两阶段强稳定保持（SSP）Runge-Kutta 方法对半离散常微分方程组进行时间积分，时间步长 $\\Delta t$ 遵循用户指定的 CFL 数 $0  \\text{CFL} \\le 1$，其中 $\\Delta t$ 选择为 $\\Delta t = \\text{CFL}\\,\\Delta x/|a|$，并可能在最后一步减小以精确达到最终时间 $T$。\n\n5) 量化过冲与下冲。令 $U_{\\min} = \\min(u_L,u_R)$ 和 $U_{\\max} = \\max(u_L,u_R)$。在最终时间 $T$，对每种格式计算：\n- 过冲幅度 $M_{\\text{over}} = \\max\\{0,\\, \\max_i \\bar u_i(T) - U_{\\max}\\}$。\n- 下冲幅度 $M_{\\text{under}} = \\max\\{0,\\, U_{\\min} - \\min_i \\bar u_i(T)\\}$。\n两者均为非负实数。\n\n6) 实现与输出。实现一个程序，对下面的每个测试用例，模拟两种格式（相同的网格、相同的重构、相同的时间步长规则），然后对每个测试用例，输出列表\n$$\n\\big[ M_{\\text{over}}^{\\text{central}},\\; M_{\\text{under}}^{\\text{central}},\\; M_{\\text{over}}^{\\text{upwind}},\\; M_{\\text{under}}^{\\text{upwind}}\\big],\n$$\n并四舍五入到小数点后六位。将所有测试用例的结果聚合为单行，形式为无空格、逗号分隔的列表之列表，例如\n$$\n\\big[\\,[0.123456,0.000000,0.000000,0.000000],[\\dots]\\,\\big].\n$$\n您的程序必须严格按照此格式生成单行输出。\n\n使用以下测试套件，它涵盖了分辨率和稳定性的典型条件与边缘条件，所有数值均采用国际单位制（此处为无量纲）：\n- 测试 A（正常路径，中等分辨率）：$L=1.0$, $N=200$, $a=1.0$, $u_L=1.0$, $u_R=0.0$, $x_0=0.3$, $\\text{CFL}=0.45$, $T=0.20$。\n- 测试 B（粗网格）：$L=1.0$, $N=40$, $a=1.0$, $u_L=1.0$, $u_R=0.0$, $x_0=0.3$, $\\text{CFL}=0.45$, $T=0.20$。\n- 测试 C（CFL 接近稳定性极限）：$L=1.0$, $N=200$, $a=1.0$, $u_L=1.0$, $u_R=0.0$, $x_0=0.3$, $\\text{CFL}=0.95$, $T=0.20$。\n- 测试 D（小跳跃）：$L=1.0$, $N=200$, $a=1.0$, $u_L=0.6$, $u_R=0.4$, $x_0=0.3$, $\\text{CFL}=0.60$, $T=0.20$。\n\n不涉及角度单位。每个测试用例报告所有四个数字，形式为小数，小数点后精确到六位。最终输出格式是一个单行字符串，包含一个无空格的列表之列表：例如，$[\\,[0.000001,0.000000,0.000000,0.000000],[\\dots]\\,]$。", "solution": "该问题是有效的，因为它在科学上基于双曲守恒律和数值方法的理论，其定义和参数完整一致，问题设定适定，并且陈述客观。我们着手求解。\n\n该问题要求推导、实现并比较两种用于线性平流方程 $u_t + (au)_x = 0$ 的二阶有限体积格式。这两种格式仅在数值通量函数上有所不同。\n\n### 1) 有限体积半离散化\n\n我们从一维标量守恒律的积分形式开始。对于宽度为 $\\Delta x = x_{i+\\frac{1}{2}} - x_{i-\\frac{1}{2}}$ 的“单元”或控制体 $C_i = [x_{i-\\frac{1}{2}}, x_{i+\\frac{1}{2}}]$，该定律指出，单元内守恒量 $u$ 总量的变化率等于穿过其边界的净通量：\n$$\n\\frac{d}{dt} \\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u(x,t) \\, dx = f(u(x_{i-\\frac{1}{2}},t)) - f(u(x_{i+\\frac{1}{2}},t)).\n$$\n我们将单元 $i$ 中 $u$ 的单元平均值定义为 $\\bar{u}_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u(x,t) \\, dx$。将其代入积分形式可得：\n$$\n\\frac{d}{dt} (\\Delta x \\bar{u}_i) = \\Delta x \\frac{d\\bar{u}_i}{dt} = f(u(x_{i-\\frac{1}{2}},t)) - f(u(x_{i+\\frac{1}{2}},t)).\n$$\n在有限体积法中，界面处通量 $f(u)$ 的精确点值是未知的。它们被一个数值通量函数 $F$ 所替代，该函数依赖于界面左右两侧解的状态。令 $F_{i+\\frac{1}{2}}$ 表示界面 $x_{i+\\frac{1}{2}}$ 处的数值通量。单元平均值的演化方程变为：\n$$\n\\frac{d\\bar{u}_i}{dt} = -\\frac{1}{\\Delta x} \\left( F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}} \\right).\n$$\n这就是常微分方程组法的半离散形式。右侧代表空间离散化，从而得到关于单元平均值 $\\bar{u}_i(t)$ 的一个常微分方程组（ODE）。\n\n### 2) 斜率限制的 MUSCL 重构\n\n为了达到二阶空间精度，数值通量 $F_{i+\\frac{1}{2}}$ 必须使用界面 $x_{i+\\frac{1}{2}}$ “左侧”和“右侧”解的二阶精确估计来计算。这通过从单元平均值对解进行分段多项式重构来实现。MUSCL (Monotone Upstream-centered Schemes for Conservation Laws，即单调上游中心守恒律格式)方法在每个单元 $i$ 内使用分段线性重构：\n$$\nu_i(x) = \\bar{u}_i + s_i \\frac{x-x_i}{\\Delta x} \\quad \\text{for} \\quad x \\in C_i,\n$$\n其中 $x_i$ 是单元中心， $s_i$ 是一个受限的斜率。为了保持总变差递减（TVD）性质并避免引入新的振荡，斜率 $s_i$ 使用限制器计算。题目指定了 `minmod` 限制器，它比较后向和前向差分：\n$$\ns_i = \\operatorname{minmod}(\\bar{u}_i - \\bar{u}_{i-1}, \\bar{u}_{i+1} - \\bar{u}_i).\n$$\n函数 $\\operatorname{minmod}(\\alpha, \\beta)$ 定义为：\n$$\n\\operatorname{minmod}(\\alpha, \\beta) = \\begin{cases} \\operatorname{sign}(\\alpha)\\min(|\\alpha|, |\\beta|)  \\text{if } \\alpha\\beta  0 \\\\ 0  \\text{if } \\alpha\\beta \\le 0 \\end{cases}\n$$\n如果两个斜率符号相同，此限制器选择其中较小者；如果符号不同（即在极值点处），则返回零。\n\n在单元 $i$ 的右边界（$x=x_{i+\\frac{1}{2}}$）和单元 $i+1$ 的左边界（$x=x_{i+\\frac{1}{2}}$）处的重构值，为该界面上的黎曼问题提供了左、右状态：\n$$\nu_{i+\\frac{1}{2}}^{-} = u_i(x_{i+\\frac{1}{2}}) = \\bar{u}_i + s_i \\frac{(x_i + \\Delta x/2) - x_i}{\\Delta x} = \\bar{u}_i + \\frac{1}{2}s_i.\n$$\n$$\nu_{i+\\frac{1}{2}}^{+} = u_{i+1}(x_{i+\\frac{1}{2}}) = \\bar{u}_{i+1} + s_{i+1} \\frac{(x_{i+1} - \\Delta x/2) - x_{i+1}}{\\Delta x} = \\bar{u}_{i+1} - \\frac{1}{2}s_{i+1}.\n$$\n这些就是提供给数值通量函数的界面状态。对于周期性边界，索引以 $N$ 为模进行处理。\n\n### 3) 数值通量函数\n\n这两种格式通过其数值通量 $F_{i+\\frac{1}{2}} = F(u_{i+\\frac{1}{2}}^{-}, u_{i+\\frac{1}{2}}^{+})$ 来区分。\n\n**a) 迎风-Godunov 通量**\nGodunov 通量基于界面处初始状态为 $u_{i+\\frac{1}{2}}^{-}$ 和 $u_{i+\\frac{1}{2}}^{+}$ 的黎曼问题的精确解。对于线性平流方程 $u_t + a u_x = 0$，解是一个以速度 $a$ 传播的接触间断。因此，在界面位置 $x=x_{i+\\frac{1}{2}}$ 处的解的值，如果 $a  0$（信息从左侧传播），则为 $u_{i+\\frac{1}{2}}^{-}$；如果 $a  0$（信息从右侧传播），则为 $u_{i+\\frac{1}{2}}^{+}$。物理通量是 $f(u) = au$。因此 Godunov 数值通量为 $F_{i+\\frac{1}{2}}^{\\text{up}} = f(u_{\\text{Riemann}}(0,t))$，即：\n$$\nF_{i+\\frac{1}{2}}^{\\text{up}} = \\begin{cases} a\\,u_{i+\\frac{1}{2}}^{-}  \\text{if } a  0 \\\\ a\\,u_{i+\\frac{1}{2}}^{+}  \\text{if } a  0 \\end{cases}\n$$\n这可以紧凑地写为 $F_{i+\\frac{1}{2}}^{\\text{up}} = \\frac{a}{2}(u_{i+\\frac{1}{2}}^{-} + u_{i+\\frac{1}{2}}^{+}) - \\frac{|a|}{2}(u_{i+\\frac{1}{2}}^{+} - u_{i+\\frac{1}{2}}^{-})$。\n\n**b) 二阶中心 Lax-Wendroff 通量**\n对于 $u_t + f_x = 0$ 的经典单步 Lax-Wendroff 格式可以写成守恒形式 $u_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}})$，其中数值通量被确定为：\n$$\nF_{i+\\frac{1}{2}} = \\frac{1}{2}\\left( f(u_i) + f(u_{i+1}) \\right) - \\frac{\\Delta t}{2\\Delta x} A_{i+\\frac{1}{2}}\\left( f(u_{i+1}) - f(u_i) \\right),\n$$\n其中 $A_{i+\\frac{1}{2}}$ 是通量雅可比矩阵 $f'(u)$ 的某种平均。对于线性平流方程，$f(u) = au$，雅可比矩阵就是常数 $a$。通量变为：\n$$\nF_{i+\\frac{1}{2}} = \\frac{1}{2}\\left( au_i + au_{i+1} \\right) - \\frac{a\\Delta t}{2\\Delta x}\\left( au_{i+1} - au_i \\right) = a \\left[ \\frac{1}{2}(u_i + u_{i+1}) - \\frac{a\\Delta t}{2\\Delta x}(u_{i+1} - u_i) \\right].\n$$\n为了构建所要求的二阶中心格式，此通量形式不应用于单元平均值 $\\bar{u}_i, \\bar{u}_{i+1}$，而是应用于重构的界面状态 $u_{i+\\frac{1}{2}}^{-}, u_{i+\\frac{1}{2}}^{+}$。将它们分别替换 $u_i$ 和 $u_{i+1}$，并定义有符号的 CFL 数 $\\lambda = a \\Delta t / \\Delta x$，我们得到指定的通量：\n$$\nF_{i+\\frac{1}{2}}^{\\text{LW}} = a\\left[\\tfrac{1}{2}\\left(u_{i+\\frac{1}{2}}^{-} + u_{i+\\frac{1}{2}}^{+}\\right) - \\tfrac{1}{2}\\lambda \\left(u_{i+\\frac{1}{2}}^{+} - u_{i+\\frac{1}{2}}^{-}\\right)\\right].\n$$\n该通量是中心的，因为它对称地使用了来自两侧的信息，但它包含一个与 $\\lambda$ 成正比的二阶修正项，该项近似了为保证稳定性和精度所需的耗散。\n\n### 4) 时间积分\n\n半离散系统 $\\frac{d\\bar{\\mathbf{u}}}{dt} = \\mathcal{L}(\\bar{\\mathbf{u}})$，其中 $\\mathcal{L}_i(\\bar{\\mathbf{u}}) = -\\frac{1}{\\Delta x}(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}})$，使用一种两阶段、二阶的强稳定保持（SSP）Runge-Kutta 方法在时间上推进，通常表示为 SSP(2,2)。给定时刻 $t_n$ 的解 $\\bar{\\mathbf{u}}^n$，在 $t_{n+1} = t_n + \\Delta t$ 的解通过以下方式求得：\n\\begin{align*}\n\\bar{\\mathbf{u}}^{(1)} = \\bar{\\mathbf{u}}^n + \\Delta t \\, \\mathcal{L}(\\bar{\\mathbf{u}}^n) \\\\\n\\bar{\\mathbf{u}}^{n+1} = \\frac{1}{2}\\bar{\\mathbf{u}}^n + \\frac{1}{2}\\left(\\bar{\\mathbf{u}}^{(1)} + \\Delta t \\, \\mathcal{L}(\\bar{\\mathbf{u}}^{(1)})\\right)\n\\end{align*}\nSSP 方法旨在当向前欧拉步在合适的 CFL 条件下满足 TVD 性质时，保持空间离散的 TVD 性质。时间步长 $\\Delta t$ 基于用户指定的 CFL 数选择，$\\Delta t = \\text{CFL} \\frac{\\Delta x}{|a|}$。\n\n### 5) 量化过冲和下冲\n\n对于值由 $U_{\\min} = \\min(u_L, u_R)$ 和 $U_{\\max} = \\max(u_L, u_R)$ 界定的初始条件，TVD 格式保证解在任何后续时间都将保持在这些界限内。非 TVD 格式可能会在间断附近产生虚假振荡（类 Gibbs 现象），其中解会超过 $U_{\\max}$（过冲）或低于 $U_{\\min}$（下冲）。这些量在最终时间 $T$ 被量化为：\n$$\nM_{\\text{over}} = \\max\\{0, \\max_i \\bar{u}_i(T) - U_{\\max}\\}\n$$\n$$\nM_{\\text{under}} = \\max\\{0, U_{\\min} - \\min_i \\bar{u}_i(T)\\}\n$$\n\n### 6) 算法实现\n\n实现过程如下：\n- 对每个测试用例，定义网格参数（$N$, $\\Delta x$, $x_i$）和模拟参数（$a$, $\\text{CFL}$, $T$）。\n- 通过在单元中心 $x_i$ 处计算给定的阶跃函数，创建初始条件向量 $\\bar{\\mathbf{u}}(0)$。\n- 一个时间步进循环将解从 $t=0$ 推进到 $t=T$。计算时间步长 $\\Delta t$，并可能在最后一步减小以精确到达 $T$。\n- 时间积分器的每一步都需要计算右端项 $\\mathcal{L}(\\bar{\\mathbf{u}})$。这包括：\n    1. 为所有单元计算斜率 $s_i$，处理周期性边界。\n    2. 为所有界面计算左、右界面状态 $u_{i+\\frac{1}{2}}^{-}, u_{i+\\frac{1}{2}}^{+}$。\n    3. 使用迎风或中心 Lax-Wendroff 公式计算数值通量向量 $F_{i+\\frac{1}{2}}$。\n    4. 对通量进行差分以得到 $\\mathcal{L}(\\bar{\\mathbf{u}})$。\n- 对迎风和中心通量格式都执行此过程。\n- 在最终时间 $T$，找到每种格式解向量 $\\bar{\\mathbf{u}}(T)$ 的全局最小值和最大值，并计算和记录 $M_{\\text{over}}$ 和 $M_{\\text{under}}$。\n- 将所有测试用例的结果聚合为指定的列表之列表格式以供输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Test A (happy path, moderate resolution)\n        {'L': 1.0, 'N': 200, 'a': 1.0, 'u_L': 1.0, 'u_R': 0.0, 'x_0': 0.3, 'CFL': 0.45, 'T': 0.20},\n        # Test B (coarse grid)\n        {'L': 1.0, 'N': 40, 'a': 1.0, 'u_L': 1.0, 'u_R': 0.0, 'x_0': 0.3, 'CFL': 0.45, 'T': 0.20},\n        # Test C (CFL near stability limit)\n        {'L': 1.0, 'N': 200, 'a': 1.0, 'u_L': 1.0, 'u_R': 0.0, 'x_0': 0.3, 'CFL': 0.95, 'T': 0.20},\n        # Test D (small jump)\n        {'L': 1.0, 'N': 200, 'a': 1.0, 'u_L': 0.6, 'u_R': 0.4, 'x_0': 0.3, 'CFL': 0.60, 'T': 0.20},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        case_results = []\n        \n        # Run for central Lax-Wendroff flux\n        u_final_lw = run_simulation(params, flux_type='central')\n        U_min = min(params['u_L'], params['u_R'])\n        U_max = max(params['u_L'], params['u_R'])\n        M_over_lw = max(0, np.max(u_final_lw) - U_max)\n        M_under_lw = max(0, U_min - np.min(u_final_lw))\n        case_results.extend([M_over_lw, M_under_lw])\n        \n        # Run for upwind Godunov flux\n        u_final_up = run_simulation(params, flux_type='upwind')\n        M_over_up = max(0, np.max(u_final_up) - U_max)\n        M_under_up = max(0, U_min - np.min(u_final_up))\n        case_results.extend([M_over_up, M_under_up])\n        \n        all_results.append([f\"{val:.6f}\" for val in case_results])\n\n    # Final print statement in the exact required format.\n    formatted_results = \",\".join([f\"[{','.join(res)}]\" for res in all_results])\n    print(f\"[{formatted_results}]\")\n\ndef minmod(alpha, beta):\n    \"\"\"Vectorized minmod function.\"\"\"\n    return np.where(alpha * beta = 0, 0, np.sign(alpha) * np.minimum(np.abs(alpha), np.abs(beta)))\n\ndef get_rhs(u, dx, a, dt, flux_type):\n    \"\"\"\n    Computes the right-hand side of the semi-discrete system du/dt = L(u).\n    This involves slope calculation, reconstruction, and flux evaluation.\n    \"\"\"\n    # 1. Compute slopes s_i with periodic boundaries\n    u_fwd = np.roll(u, -1) - u\n    u_bwd = u - np.roll(u, 1)\n    s = minmod(u_bwd, u_fwd)\n\n    # 2. Reconstruct interface states u_{i+1/2}^{-} and u_{i+1/2}^{+}\n    # u_minus corresponds to u_{i+1/2}^{-}\n    u_minus = u + 0.5 * s\n    # u_plus corresponds to u_{i+1/2}^{+}\n    # To get s_{i+1} for all i, we roll s by -1\n    u_plus = np.roll(u, -1) - 0.5 * np.roll(s, -1)\n\n    # 3. Calculate numerical fluxes F_{i+1/2}\n    if flux_type == 'upwind':\n        # Godunov flux for linear advection\n        if a > 0:\n            F = a * u_minus\n        else:\n            F = a * u_plus\n            \n    elif flux_type == 'central':\n        # Second-order central Lax-Wendroff type flux\n        # Note: lambda (CFL number) can be signed.\n        lamb = a * dt / dx\n        F = a * (0.5 * (u_minus + u_plus) - 0.5 * lamb * (u_plus - u_minus))\n    else:\n        raise ValueError(\"Invalid flux type specified.\")\n\n    # 4. Compute the flux divergence\n    # F_{i-1/2} is obtained by rolling F by 1\n    F_minus_half = np.roll(F, 1)\n    rhs = -(F - F_minus_half) / dx\n    \n    return rhs\n\ndef run_simulation(params, flux_type):\n    \"\"\"\n    Runs a single finite volume simulation.\n    \"\"\"\n    L = params['L']\n    N = params['N']\n    a = params['a']\n    u_L = params['u_L']\n    u_R = params['u_R']\n    x_0 = params['x_0']\n    CFL = params['CFL']\n    T = params['T']\n\n    # Grid setup\n    dx = L / N\n    x = np.linspace(dx/2, L - dx/2, N)\n\n    # Initial condition (cell-centered evaluation)\n    u0 = np.where(x  x_0, u_L, u_R)\n    \n    u = u0.copy()\n    t = 0.0\n    \n    # Time stepping\n    dt_nominal = CFL * dx / np.abs(a)\n    \n    while t  T:\n        dt = min(dt_nominal, T - t)\n        \n        # SSP(2,2) Runge-Kutta integrator\n        # Stage 1\n        L_u = get_rhs(u, dx, a, dt, flux_type)\n        u1 = u + dt * L_u\n        \n        # Stage 2\n        L_u1 = get_rhs(u1, dx, a, dt, flux_type)\n        u = 0.5 * u + 0.5 * (u1 + dt * L_u1)\n        \n        t += dt\n        \n    return u\n\nsolve()\n```", "id": "3111412"}]}