{"hands_on_practices": [{"introduction": "显式方法在实际应用中面临的首要挑战是其条件稳定性。这个练习 [@problem_id:3126925] 将引导您从第一性原理出发，通过保证格式在物理上能保持温度的非负性来推导稳定性条件。您将设计一个数值实验，亲眼见证违反此条件所导致的不符合物理规律的后果，从而将抽象的数值稳定性概念与直观的极值原理联系起来。", "problem": "考虑在有限区间上的具有齐次狄利克雷边界条件的一维热传导方程，采用无量纲单位：\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in [0,L], \\ t \\ge 0, \\quad u(0,t)=0,\\ u(L,t)=0,\n$$\n其中 $u(x,t)$ 是温度，$\\alpha > 0$ 是热扩散系数，$L>0$ 是区域长度。你将从基本原理出发，构建一个显式有限差分方法，并设计一个数值实验，以展示当 Courant–Friedrichs–Lewy (CFL) 条件被违反时，正性（离散温度的非负性）何时会丧失，并量化保持离散极值原理的最大时间步长。\n\n将空间域离散为 $N$ 个内部点和两个边界点，使得空间网格的索引为 $i=0,1,2,\\dots,N,N+1$，其中 $i=0$ 和 $i=N+1$ 是边界。设空间步长为 $\\Delta x = L/(N+1)$。对于时间，使用步数 $n=0,1,2,\\dots$，时间步长为 $\\Delta t$。通过使用向前差分近似时间导数来构建显式格式，\n$$\n\\frac{\\partial u}{\\partial t}(x_i,t_n) \\approx \\frac{u_i^{n+1}-u_i^n}{\\Delta t},\n$$\n并使用中心差分近似空间二阶导数，\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x_i,t_n) \\approx \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{\\Delta x^2}.\n$$\n使用得到的完全显式方法在每个时间步 $n \\to n+1$ 更新内部节点 $i=1,2,\\dots,N$。\n\n将离散温度初始化为非负且高度局部化的：除了单个内部索引 $i^\\star$ 外，对所有 $i$ 设置 $u_i^0=0$，而在该点 $u_{i^\\star}^0 = 1$。选择 $i^\\star$ 为最接近区间中点的内部点，即：\n$$\ni^\\star = \\left\\lfloor \\frac{N+1}{2} \\right\\rfloor.\n$$\n这模拟了一根原本冷却的杆中的单个热点，并且是一个有效的非负初始条件。\n\n你的任务：\n1. 根据上述显式构造，确定关于 $\\Delta t$（作为 $\\alpha$ 和 $\\Delta x$ 的函数）的精确条件，该条件保证在初始状态非负的情况下，每个内部节点的更新都是非负值的凸组合，从而在所有后续时间层保持非负性。将临界时间步长 $\\Delta t_\\star$ 定义为仍能保持此离散极值原理的最大时间步长。\n2. 设计一个数值实验，对于每个给定的参数集 $(\\alpha,L,N,K)$，从上述相同的初始状态开始，进行以下三次运行：\n   - 一个违背条件的时间步长 $\\Delta t_{\\text{bad}} = 1.1 \\, \\Delta t_\\star$（超出阈值）。\n   - 一个边界时间步长 $\\Delta t_{\\text{border}} = \\Delta t_\\star$（恰好在阈值上）。\n   - 一个安全的时间步长 $\\Delta t_{\\text{good}} = 0.9 \\, \\Delta t_\\star$（低于阈值）。\n   对于这三种选择中的每一种，将显式格式演化恰好 $K$ 步，并在每一步之后检查是否有任何分量变得严格为负（即小于 $0$）。为每次运行记录一个布尔值，指示在这 $K$ 步期间是否在任何时候观察到负值。\n3. 从基本原理出发，根据给定的参数 $(\\alpha,L,N)$，用 $\\alpha$ 和 $\\Delta x$ 来量化 $\\Delta t_\\star$。在每次测试中，将此值与三个布尔值一起报告。\n\n测试套件：\n- 情况 1：$(\\alpha,L,N,K) = (1,1,50,5)$。\n- 情况 2：$(\\alpha,L,N,K) = (0.5,2,1,3)$。\n- 情况 3：$(\\alpha,L,N,K) = (3,1,20,5)$。\n\n最终输出规范：\n- 对于每种情况，按顺序输出一个包含四个条目的列表：$[\\text{neg\\_bad}, \\text{neg\\_border}, \\text{neg\\_good}, \\Delta t_\\star]$，其中 $\\text{neg\\_bad}$、$\\text{neg\\_border}$ 和 $\\text{neg\\_good}$ 是布尔值，分别指示是否在 $\\Delta t_{\\text{bad}}$、$\\Delta t_{\\text{border}}$ 和 $\\Delta t_{\\text{good}}$ 的情况下观察到负值，而 $\\Delta t_\\star$ 是一个浮点数。\n- 最终的程序输出应为单行，包含按顺序排列的三个情况的结果列表，形式为用方括号括起来的逗号分隔列表，例如：\n$$\n[\\,[\\text{neg\\_bad}_1,\\text{neg\\_border}_1,\\text{neg\\_good}_1,\\Delta t_{\\star,1}],\\ [\\text{neg\\_bad}_2,\\text{neg\\_border}_2,\\text{neg\\_good}_2,\\Delta t_{\\star,2}],\\ [\\text{neg\\_bad}_3,\\text{neg\\_border}_3,\\text{neg\\_good}_3,\\Delta t_{\\star,3}]\\,].\n$$\n不需要物理单位，因为所有量都是无量纲的。不涉及角度。不得使用百分比；任何分数因子（如 $0.9$ 或 $1.1$）在输出中需要时应表示为小数。", "solution": "该问题要求推导一维热传导方程显式有限差分格式的稳定性条件，并设计一个数值实验来验证它。\n\n### 步骤 1：推导稳定性条件和临界时间步长 $\\Delta t_\\star$\n\n控制性一维热传导方程由下式给出：\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}\n$$\n其中参数热扩散系数 $\\alpha > 0$，区域长度 $L > 0$。边界条件是齐次狄利克雷条件：$u(0,t) = 0$ 和 $u(L,t) = 0$。\n\n问题指定在时间上使用向前差分，在空间上使用中心差分。令 $u_i^n$ 近似解 $u(x_i, t_n)$，其中 $x_i = i \\Delta x$ 和 $t_n = n \\Delta t$。空间域 $x \\in [0,L]$ 被离散为 $N$ 个内部点，总共得到 $N+2$ 个网格点，索引为 $i=0, 1, \\dots, N+1$。空间步长为 $\\Delta x = L/(N+1)$。\n\n指定的有限差分近似为：\n$$\n\\frac{\\partial u}{\\partial t}(x_i,t_n) \\approx \\frac{u_i^{n+1}-u_i^n}{\\Delta t}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x_i,t_n) \\approx \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{\\Delta x^2}\n$$\n将这些近似代入热传导方程，得到完全显式的 FTCS (Forward-Time Centered-Space) 格式：\n$$\n\\frac{u_i^{n+1}-u_i^n}{\\Delta t} = \\alpha \\left( \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{\\Delta x^2} \\right)\n$$\n为了找到 $u_i^{n+1}$ 的更新规则，我们对其求解：\n$$\nu_i^{n+1} = u_i^n + \\frac{\\alpha \\Delta t}{\\Delta x^2} (u_{i+1}^n - 2 u_i^n + u_{i-1}^n)\n$$\n让我们定义无量纲参数 $\\mu$，通常称为热传导方程的 Courant 数：\n$$\n\\mu = \\frac{\\alpha \\Delta t}{\\Delta x^2}\n$$\n更新方程可以通过组合时间层 $n$ 上对应空间模板的项来重写：\n$$\nu_i^{n+1} = \\mu u_{i-1}^n + (1 - 2\\mu) u_i^n + \\mu u_{i+1}^n\n$$\n此方程适用于所有内部节点，$i=1, 2, \\dots, N$。\n\n问题要求的是保证非负性得以保持的条件。如果初始状态 $u^0$ 是非负的，即对所有 $i$ 都有 $u_i^0 \\ge 0$，我们希望确保对所有后续时间步 $n > 0$ 都有 $u_i^n \\ge 0$。从更新公式来看，$u_i^{n+1}$ 是其邻点在上一时间步长值的线性组合。如果所有值 $u_j^n$ 都是非负的，那么要保证 $u_i^{n+1}$ 也是非负的，当且仅当线性组合中的所有系数都是非负的。这是离散极值原理的一个充分条件。\n\n系数是 $\\mu$ 和 $(1 - 2\\mu)$。\n1.  参数 $\\mu = \\alpha \\Delta t / \\Delta x^2$ 是非负量（$\\alpha>0, \\Delta t>0$）的乘积，所以 $\\mu \\ge 0$ 总是满足的。\n2.  系数 $(1 - 2\\mu)$ 必须是非负的：\n    $$\n    1 - 2\\mu \\ge 0 \\implies 1 \\ge 2\\mu \\implies \\mu \\le \\frac{1}{2}\n    $$\n这个条件 $\\mu \\le 1/2$ 是热传导方程 FTCS 格式的稳定性条件。它确保解不会无界增长，并且在这种情况下，保持非负性。\n\n将 $\\mu$ 的定义代入不等式，我们得到关于时间步长 $\\Delta t$ 的条件：\n$$\n\\frac{\\alpha \\Delta t}{\\Delta x^2} \\le \\frac{1}{2} \\implies \\Delta t \\le \\frac{\\Delta x^2}{2\\alpha}\n$$\n问题将临界时间步长 $\\Delta t_\\star$ 定义为仍能保持此原理的最大时间步长。这对应于条件中的等式情况：\n$$\n\\Delta t_\\star = \\frac{\\Delta x^2}{2\\alpha}\n$$\n其中 $\\Delta x = L/(N+1)$。\n\n### 步骤 2：数值实验设计\n\n该实验通过测试时间步长 $\\Delta t$ 相对于 $\\Delta t_\\star$ 的三种情况来验证推导出的条件：\n-   $\\Delta t_{\\text{bad}} = 1.1 \\, \\Delta t_\\star$：这对应于 $\\mu = 1.1 \\times 0.5 = 0.55$，违反了条件 $\\mu \\le 0.5$。\n-   $\\Delta t_{\\text{border}} = 1.0 \\, \\Delta t_\\star$：这对应于 $\\mu = 0.5$，位于稳定区域的边界上。\n-   $\\Delta t_{\\text{good}} = 0.9 \\, \\Delta t_\\star$：这对应于 $\\mu = 0.9 \\times 0.5 = 0.45$，安全地位于稳定区域内。\n\n对于每个参数集 $(\\alpha, L, N, K)$：\n1.  计算空间步长 $\\Delta x = L / (N+1)$。\n2.  计算临界时间步长 $\\Delta t_\\star = \\Delta x^2 / (2\\alpha)$。\n3.  对于三个时间步长（$\\Delta t_{\\text{bad}}$、$\\Delta t_{\\text{border}}$、$\\Delta t_{\\text{good}}$）中的每一个，进行一次模拟：\n    a. 初始化一个大小为 $N+2$ 的一维数组 `u`，以表示网格点 $i=0, \\dots, N+1$ 处的温度。\n    b. 设置初始条件：`u` 在各处均为零，除了内部索引 $i^\\star = \\lfloor (N+1)/2 \\rfloor$ 处，$u_{i^\\star} = 1$。边界点 $u_0$ 和 $u_{N+1}$ 始终为零。\n    c. 初始化一个布尔标志 `negativity_observed = False`。\n    d. 将系统演化 $K$ 个时间步。在每一步 $n=0, \\dots, K-1$ 中：\n        i.  使用更新规则 $u_i^{n+1} = \\mu u_{i-1}^n + (1 - 2\\mu) u_i^n + \\mu u_{i+1}^n$ 从当前状态 $u^n$ 计算下一个状态 $u^{n+1}$，适用于所有内部点 $i=1, \\dots, N$。\n        ii. 计算出 $u^{n+1}$ 后，检查其是否有任何分量 $u_i^{n+1}$（对于 $i=1, \\dots, N$）是严格为负的。\n        iii. 如果有任何分量小于 $0$，则设置 `negativity_observed = True` 并终止此次时间步长的模拟。\n    e. 记录 `negativity_observed` 的最终值。\n\n4.  一个参数集的结果是一个列表，包含三个布尔标志和计算出的 $\\Delta t_\\star$ 值：$[\\text{neg\\_bad}, \\text{neg\\_border}, \\text{neg\\_good}, \\Delta t_\\star]$。\n\n对于初始条件 $u_i^0 = \\delta_{i, i^\\star}$，第一个时间步将点 $u_{i^\\star}$ 更新为 $u_{i^\\star}^1 = (1 - 2\\mu)u_{i^\\star}^0 = 1 - 2\\mu$。如果 $\\mu > 0.5$，这个值将是负的，并且在第一步中就会观察到负值。如果 $\\mu \\le 0.5$，所有系数都是非负的，并且由于初始状态是非负的，在精确算术下，所有后续状态都将保持非负。因此，我们预期对于所有测试用例，布尔结果都将是 `[True, False, False]`。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(alpha, L, N, K, dt):\n    \"\"\"\n    Runs a single simulation for the 1D heat equation.\n\n    Args:\n        alpha (float): Thermal diffusivity.\n        L (float): Domain length.\n        N (int): Number of interior spatial points.\n        K (int): Number of time steps.\n        dt (float): Time step size.\n\n    Returns:\n        bool: True if negativity is observed, False otherwise.\n    \"\"\"\n    dx = L / (N + 1)\n    \n    # Initialize temperature array u of size N+2 for indices 0 to N+1\n    u = np.zeros(N + 2)\n    \n    # Set initial condition: a single hot spot\n    # Note: problem statement's i_star=floor((N+1)/2) is a 1-based index if interior\n    # points are 1...N. For a 0-indexed array, this corresponds to array index i_star.\n    i_star = int(np.floor((N + 1) / 2))\n    if 1 = i_star = N:\n        u[i_star] = 1.0\n\n    mu = alpha * dt / (dx**2)\n    negativity_observed = False\n\n    for _ in range(K):\n        # Create a copy to store the next state\n        u_new = u.copy()\n        \n        # Update interior points using a vectorized operation\n        u_new[1:-1] = mu * u[:-2] + (1 - 2 * mu) * u[1:-1] + mu * u[2:]\n        \n        # The boundary conditions u[0]=0 and u[N+1]=0 are implicitly handled\n        # as u_new is a copy of u and these values don't change.\n        \n        u = u_new\n        \n        # Check for negativity\n        if np.any(u  0):\n            negativity_observed = True\n            break\n            \n    return negativity_observed\n\ndef analyze_case(alpha, L, N, K):\n    \"\"\"\n    Analyzes one test case for the heat equation stability.\n\n    Args:\n        alpha (float): Thermal diffusivity.\n        L (float): Domain length.\n        N (int): Number of interior spatial points.\n        K (int): Number of time steps.\n\n    Returns:\n        list: A list containing [neg_bad, neg_border, neg_good, dt_star].\n    \"\"\"\n    # 1. Calculate the critical time step dt_star\n    dx = L / (N + 1)\n    dt_star = dx**2 / (2 * alpha)\n    \n    # 2. Define the three time steps for the experiment\n    dt_bad = 1.1 * dt_star\n    dt_border = dt_star\n    dt_good = 0.9 * dt_star\n    \n    # 3. Run simulations and record results\n    neg_bad = run_simulation(alpha, L, N, K, dt_bad)\n    neg_border = run_simulation(alpha, L, N, K, dt_border)\n    neg_good = run_simulation(alpha, L, N, K, dt_good)\n    \n    return [neg_bad, neg_border, neg_good, dt_star]\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 1, 50, 5),    # Case 1: (alpha, L, N, K)\n        (0.5, 2, 1, 3),   # Case 2\n        (3, 1, 20, 5)     # Case 3\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, L, N, K = case\n        result = analyze_case(alpha, L, N, K)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) will correctly format each inner list.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3126925"}, {"introduction": "在确保了计算格式的稳定性之后，下一个关键步骤是验证程序实现的正确性并量化其精度。这个练习 [@problem_id:3126907] 介绍了一种标准的“制造解方法”，您需要将数值结果与一个已知的精确解进行比较来衡量误差。通过分析误差如何随着网格的加密而减小，您将计算出该方法的收敛阶，这是验证任何科学计算代码的基本技能。", "problem": "考虑基于能量守恒和傅里叶热传导定律的一维热传导模型，该模型可导出以下抛物型偏微分方程（PDE）\n$$\n\\frac{\\partial u}{\\partial t} = \\nu \\frac{\\partial^2 u}{\\partial x^2},\n$$\n其中 $u(x,t)$ 是温度，$x \\in [0,1]$ 是空间坐标，$t \\in [0,T]$ 是时间，$\\nu$ 是热扩散系数。施加齐次 Dirichlet 边界条件，$u(0,t) = 0$ 和 $u(1,t) = 0$，并选择在 $[0,1]$ 上的有限傅里叶正弦级数作为初始条件。对于此类初始数据，每个正弦模态独立演化，精确解仍然是一个系数呈指数衰减的正弦级数。具体而言，对于初始数据\n$$\nu(x,0) = \\sum_{k \\in \\mathcal{K}} a_k \\sin(k\\pi x),\n$$\n其精确解为\n$$\nu(x,t) = \\sum_{k \\in \\mathcal{K}} a_k \\exp\\!\\big(-\\nu (k\\pi)^2 t\\big)\\,\\sin(k\\pi x).\n$$\n\n您的任务是使用均匀显式有限差分法实现一个数值基准测试，该方法采用前向差分进行时间推进，并用中心差分近似空间二阶导数。这种方法通常被称为前向时间中心空间（Forward Time Centered Space, FTCS）法。在 $[0,1]$ 上使用包含 $N_x$ 个区间的均匀空间网格（即网格间距 $\\Delta x = 1/N_x$），并通过一个稳定性参数选择时间步长 $\\Delta t$\n$$\nr = \\frac{\\nu \\,\\Delta t}{(\\Delta x)^2},\n$$\n为保持显式方法的数值稳定性，该参数必须满足 $0  r  \\tfrac{1}{2}$。通过重复显式更新，将数值解从 $t=0$ 演化到 $t=T$。如果 $T$ 不是 $\\Delta t$ 的整数倍，则使用大小为 $\\Delta t_{\\text{last}} \\in (0,\\Delta t)$ 的最后一个部分时间步，以使最终时间恰好为 $t=T$，并使用相同的显式方法进行更新，此时 $r_{\\text{last}} = \\nu \\,\\Delta t_{\\text{last}} / (\\Delta x)^2$。\n\n对于每次计算，在最终时间 $t=T$ 使用 $[0,1]$ 上的离散 $L^2$ 范数和离散 $L^\\infty$ 范数测量误差：\n$$\n\\|e\\|_{L^2} \\approx \\left(\\sum_{j=0}^{N_x} |e_j|^2\\,\\Delta x\\right)^{1/2},\\qquad\n\\|e\\|_{L^\\infty} \\approx \\max_{0 \\le j \\le N_x} |e_j|,\n$$\n其中 $e_j$ 是在网格节点 $x_j = j\\,\\Delta x$ 处的逐点误差，计算方式为数值解与 $t=T$ 时精确解之差。使用一系列空间分辨率，通过将 $N_x$ 加倍来使网格间距减半。使用两个最精细分辨率计算观测到的收敛阶：\n$$\np_{L^2} = \\frac{\\log\\left(\\|e\\|_{L^2}(\\Delta x_{\\text{coarse}}) / \\|e\\|_{L^2}(\\Delta x_{\\text{fine}})\\right)}{\\log\\left(\\Delta x_{\\text{coarse}} / \\Delta x_{\\text{fine}}\\right)},\\quad\np_{L^\\infty} = \\frac{\\log\\left(\\|e\\|_{L^\\infty}(\\Delta x_{\\text{coarse}}) / \\|e\\|_{L^\\infty}(\\Delta x_{\\text{fine}})\\right)}{\\log\\left(\\Delta x_{\\text{coarse}} / \\Delta x_{\\text{fine}}\\right)}.\n$$\n\n为以下测试套件实现基准测试。在所有情况下，空间域为 $x \\in [0,1]$，边界条件为 $u(0,t)=u(1,t)=0$，初始条件为具有振幅 $a_k$ 的指定正弦级数：\n\n- 测试用例 $1$ （单模态的一般情况）：$\\nu = 1$，$T = 0.05$，$\\mathcal{K} = \\{1\\}$，$a_1 = 1$，$r = 0.4$，以及空间分辨率 $N_x \\in \\{20, 40, 80, 160\\}$。\n- 测试用例 $2$ （更高频率的模态）：$\\nu = 1$，$T = 0.05$，$\\mathcal{K} = \\{2\\}$，$a_2 = 1$，$r = 0.4$，以及空间分辨率 $N_x \\in \\{20, 40, 80, 160\\}$。\n- 测试用例 $3$ （接近稳定性极限的模态叠加）：$\\nu = 0.75$，$T = 0.05$，$\\mathcal{K} = \\{1, 2\\}$，$a_1 = 1$，$a_2 = 0.5$，$r = 0.49$，以及空间分辨率 $N_x \\in \\{20, 40, 80, 160\\}$。\n\n您的程序必须：\n- 根据每个测试用例指定的正弦级数构建精确解。\n- 根据 $t=0$ 时的精确初始条件初始化数值解。\n- 使用给定的 $r$ 值，通过显式 FTCS 方法将数值解推进到 $t=T$，必要时包括一个较短的最后时间步。\n- 对每个空间分辨率，计算 $t=T$ 时的离散 $L^2$ 和 $L^\\infty$ 误差。\n- 仅使用该测试用例集合中两个最精细的分辨率来计算观测到的收敛阶 $p_{L^2}$ 和 $p_{L^\\infty}$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，包含六个结果，顺序为 $[p_{L^2}^{(1)}, p_{L^\\infty}^{(1)}, p_{L^2}^{(2)}, p_{L^\\infty}^{(2)}, p_{L^2}^{(3)}, p_{L^\\infty}^{(3)}]$，其中上标表示测试用例编号。\n- 每个收敛阶以浮点数表示。由于该基准测试是无量纲的，因此不需要物理单位。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$）。", "solution": "经评估，用户提供的问题是**有效的**。它在科学上基于热传递和数值分析的原理，问题适定、客观，并为一维热方程的前向时间中心空间（FTCS）方法的标准收敛性研究提供了一套完整且一致的要求。\n\n求解过程如下：首先，我们对控制偏微分方程（PDE）进行离散化，然后实现数值格式，最后，执行指定的基准测试以计算收敛阶。\n\n### 1. 热方程的离散化\n\n一维热方程由下式给出\n$$\n\\frac{\\partial u}{\\partial t} = \\nu \\frac{\\partial^2 u}{\\partial x^2}\n$$\n定义在域 $x \\in [0, 1]$ 和 $t \\in [0, T]$ 上，其中 $\\nu$ 为热扩散系数。我们引入一个包含 $N_x$ 个区间的均匀空间网格，网格间距为 $\\Delta x = 1/N_x$。网格点为 $x_j = j \\Delta x$，其中 $j = 0, 1, \\dots, N_x$。时间域用均匀时间步长 $\\Delta t$ 进行离散化，使得 $t_n = n \\Delta t$。我们将解 $u(x_j, t_n)$ 的数值近似表示为 $u_j^n$。\n\nFTCS 方法对时间和空间导数的近似如下：\n- 时间导数 $\\frac{\\partial u}{\\partial t}$ 使用一阶前向差分进行近似：\n$$\n\\frac{\\partial u}{\\partial t}\\bigg|_{(x_j, t_n)} \\approx \\frac{u_j^{n+1} - u_j^n}{\\Delta t}\n$$\n- 空间二阶导数 $\\frac{\\partial^2 u}{\\partial x^2}$ 使用二阶中心差分进行近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_j, t_n)} \\approx \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2}\n$$\n\n将这些近似代入热方程，得到 FTCS 格式的显式更新公式：\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} = \\nu \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2}\n$$\n对 $u_j^{n+1}$ 进行整理，我们得到下一时间步温度的更新规则：\n$$\nu_j^{n+1} = u_j^n + \\frac{\\nu \\Delta t}{(\\Delta x)^2} \\left( u_{j+1}^n - 2u_j^n + u_{j-1}^n \\right)\n$$\n引入稳定性参数 $r = \\frac{\\nu \\Delta t}{(\\Delta x)^2}$，方程简化为：\n$$\nu_j^{n+1} = u_j^n + r \\left( u_{j+1}^n - 2u_j^n + u_{j-1}^n \\right)\n$$\n此公式应用于所有内部网格点，即对于 $j = 1, 2, \\dots, N_x-1$。\n\n### 2. 边界条件和初始状态的实现\n\n问题指定了齐次 Dirichlet 边界条件，$u(0,t) = 0$ 和 $u(1,t) = 0$。在我们的离散框架中，这转化为在所有时间步长上固定网格端点的值：\n$$\nu_0^n = 0 \\quad \\text{和} \\quad u_{N_x}^n = 0 \\quad \\forall n \\ge 0\n$$\n初始条件是一个有限傅里叶正弦级数：\n$$\nu(x,0) = \\sum_{k \\in \\mathcal{K}} a_k \\sin(k\\pi x)\n$$\n通过在时间 $t=0$ 时对每个网格点 $x_j$ 计算该函数值来初始化数值解：\n$$\nu_j^0 = \\sum_{k \\in \\mathcal{K}} a_k \\sin(k\\pi x_j)\n$$\n\n### 3. 时间步进算法\n\n数值解从 $t=0$ 推进到最终时间 $t=T$。时间步长 $\\Delta t$ 由给定的稳定性参数 $r$ 和空间分辨率 $N_x$ 决定：$\\Delta t = r (\\Delta x)^2 / \\nu$。\n\n由于 $T$ 可能不是 $\\Delta t$ 的整数倍，该过程包括两个阶段：\n1.  计算完整时间步的数量，$N_{\\text{steps}} = \\lfloor T/\\Delta t \\rfloor$。使用标准的 FTCS 更新规则，模拟运行 $N_{\\text{steps}}$ 次迭代。\n2.  计算剩余时间，$\\Delta t_{\\text{last}} = T - N_{\\text{steps}} \\Delta t$。如果 $\\Delta t_{\\text{last}}  0$，则执行一个最终的、较短的时间步。此最后一步的更新规则使用一个修正的稳定性参数，$r_{\\text{last}} = \\frac{\\nu \\Delta t_{\\text{last}}}{(\\Delta x)^2}$。\n\n### 4. 误差分析和收敛阶\n\n将数值解 $u_j^{N_{\\text{final}}}$ 演化到 $t=T$ 后，我们通过将其与在相同网格点和最终时间计算的精确解析解进行比较来计算误差：\n$$\nu_{\\text{exact}}(x_j, T) = \\sum_{k \\in \\mathcal{K}} a_k \\exp(-\\nu (k\\pi)^2 T) \\sin(k\\pi x_j)\n$$\n逐点误差为 $e_j = u_j^{N_{\\text{final}}} - u_{\\text{exact}}(x_j, T)$。误差使用两种离散范数进行量化：\n- **离散 $L^2$ 范数：** $\\|e\\|_{L^2} = \\left(\\sum_{j=0}^{N_x} |e_j|^2 \\Delta x\\right)^{1/2}$\n- **离散 $L^\\infty$ 范数：** $\\|e\\|_{L^\\infty} = \\max_{0 \\le j \\le N_x} |e_j|$\n\n对于每个测试用例，我们为一系列空间分辨率 $N_x$ 计算这些误差。FTCS 格式的截断误差为 $O(\\Delta t + (\\Delta x)^2)$。由于我们固定了 $r$，我们有 $\\Delta t \\propto (\\Delta x)^2$，这使得该方法在空间上是二阶精确的，即全局误差预期表现为 $O((\\Delta x)^2)$。\n\n观测到的收敛阶 $p$ 是使用两个最精细分辨率（网格间距为 $\\Delta x_{\\text{coarse}}$ 和 $\\Delta x_{\\text{fine}}$，其中 $\\Delta x_{\\text{coarse}} = 2 \\Delta x_{\\text{fine}}$）的误差计算得出的：\n$$\np = \\frac{\\log(\\text{error}_{\\text{coarse}} / \\text{error}_{\\text{fine}})}{\\log(\\Delta x_{\\text{coarse}} / \\Delta x_{\\text{fine}})} = \\frac{\\log(\\text{error}_{\\text{coarse}} / \\text{error}_{\\text{fine}})}{\\log(2)}\n$$\n这对 $L^2$ 和 $L^\\infty$ 范数都进行计算。$p$ 的期望值约为 $2$。\n\n最终的程序为三个指定的测试用例实现了这整个过程，并收集六个收敛阶作为最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(nu, T, r, initial_cond_coeffs, Nx):\n    \"\"\"\n    Runs a single simulation of the 1D heat equation using the FTCS method.\n\n    Args:\n        nu (float): Thermal diffusivity.\n        T (float): Final time.\n        r (float): Stability parameter r = nu * dt / dx^2.\n        initial_cond_coeffs (dict): Dictionary of {k: a_k} for the initial sine series.\n        Nx (int): Number of spatial intervals.\n\n    Returns:\n        tuple: A tuple containing the discrete L2 error and L-infinity error.\n    \"\"\"\n    # 1. Setup grid and time step\n    dx = 1.0 / Nx\n    x = np.linspace(0.0, 1.0, Nx + 1)\n    dt = r * dx**2 / nu\n\n    # 2. Define exact solution for verification\n    def exact_solution(x_grid, t):\n        sol = np.zeros_like(x_grid, dtype=np.float64)\n        for k, a_k in initial_cond_coeffs.items():\n            sol += a_k * np.exp(-nu * (k * np.pi)**2 * t) * np.sin(k * np.pi * x_grid)\n        return sol\n\n    # 3. Initialize numerical solution from IC\n    u_num = exact_solution(x, 0.0)\n\n    # 4. Time-stepping loop\n    num_steps = int(T / dt)\n    t_current = num_steps * dt\n    \n    # Vectorized FTCS update for full steps\n    for _ in range(num_steps):\n        # u_new = u_num.copy() # Avoids aliasing\n        # u_new[1:-1] = u_num[1:-1] + r * (u_num[:-2] - 2 * u_num[1:-1] + u_num[2:])\n        # u_num = u_new\n        # The following is a slightly more memory-efficient version\n        u_num[1:-1] += r * (u_num[:-2] - 2 * u_num[1:-1] + u_num[2:])\n\n\n    # Handle final partial time step\n    dt_last = T - t_current\n    if dt_last > 1e-12: # Use a small tolerance to check for non-zero last step\n        r_last = nu * dt_last / dx**2\n        # u_new = u_num.copy()\n        # u_new[1:-1] = u_num[1:-1] + r_last * (u_num[:-2] - 2 * u_num[1:-1] + u_num[2:])\n        # u_num = u_new\n        u_num[1:-1] += r_last * (u_num[:-2] - 2 * u_num[1:-1] + u_num[2:])\n\n\n    # 5. Compute error at final time T\n    u_ex = exact_solution(x, T)\n    error_vec = u_num - u_ex\n    \n    # Calculate discrete L2 and L-infinity norms\n    err_l2 = np.sqrt(np.sum(error_vec**2) * dx)\n    err_linf = np.max(np.abs(error_vec))\n    \n    return err_l2, err_linf\n\ndef solve():\n    \"\"\"\n    Main function to run the benchmark for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"nu\": 1.0, \"T\": 0.05, \"r\": 0.4, \n            \"coeffs\": {1: 1.0}, \n            \"Nx_list\": [20, 40, 80, 160]\n        },\n        {\n            \"nu\": 1.0, \"T\": 0.05, \"r\": 0.4, \n            \"coeffs\": {2: 1.0}, \n            \"Nx_list\": [20, 40, 80, 160]\n        },\n        {\n            \"nu\": 0.75, \"T\": 0.05, \"r\": 0.49, \n            \"coeffs\": {1: 1.0, 2: 0.5},\n            \"Nx_list\": [20, 40, 80, 160]\n        }\n    ]\n\n    all_rates = []\n    \n    for case in test_cases:\n        errors_l2 = []\n        errors_linf = []\n        \n        for Nx in case[\"Nx_list\"]:\n            err_l2, err_linf = run_simulation(\n                case[\"nu\"], case[\"T\"], case[\"r\"], case[\"coeffs\"], Nx\n            )\n            errors_l2.append(err_l2)\n            errors_linf.append(err_linf)\n        \n        # Compute convergence rates using the two finest resolutions\n        # p = log(error_coarse / error_fine) / log(dx_coarse / dx_fine)\n        # Since dx_coarse / dx_fine = 2, the denominator is log(2).\n        \n        # error_coarse is at index -2 (e.g., Nx=80)\n        # error_fine is at index -1 (e.g., Nx=160)\n        p_l2 = np.log(errors_l2[-2] / errors_l2[-1]) / np.log(2.0)\n        p_linf = np.log(errors_linf[-2] / errors_linf[-1]) / np.log(2.0)\n        \n        all_rates.extend([p_l2, p_linf])\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{rate:.6f}' for rate in all_rates)}]\")\n\nsolve()\n```", "id": "3126907"}, {"introduction": "从物理角度看，热方程描述的扩散过程会“抹平”初始分布中的不规则和尖锐变化。这个练习 [@problem_id:3126921] 将利用傅里叶分析（冯·诺依曼稳定性分析的核心技术）来探究数值格式如何捕捉这一行为。您将计算不同傅里叶模式的增长因子并测量它们的衰减速率，从而更深入地理解显式格式的耗散特性及其在模拟不同空间尺度上的扩散过程时的表现。", "problem": "您将实现并使用一种用于一维热方程的显式前向时间、中心空间有限差分格式，以测量离散傅里叶模态被平滑的速度。从热方程这一基本出发点开始：温度场在长度为 $L$ 的空间区间上满足 $u_t = \\alpha u_{xx}$，并具有周期性边界条件，其中 $\\alpha$ 是热扩散系数。考虑一个包含 $N$ 个点的均匀网格，空间步长为 $\\Delta x = L/N$，时间步长为 $\\Delta t$，使用显式前向时间更新方法，并结合空间二阶导数的中心二阶差分近似来进行时间推进。将初始数据视为具有整数索引 $m \\in \\{0,1,\\dots,\\lfloor N/2 \\rfloor\\}$ 的单个离散傅里叶模态。\n\n基于这些基本原理，推导离散傅里叶模态的每时间步放大因子，然后构建一个计算方法，以确定该模态的幅值衰减至其初始幅值 $e^{-1}$ 倍或更少所需的时间步数。在此背景下，根据幅值来解释衰减，因此振荡性的符号变化是无关紧要的。对于每种情况，要输出的量是最小的整数步数 $n$，使得经过 $n$ 次显式步骤后模态的幅值小于或等于其初始幅值的 $e^{-1}$ 倍。如果在给定参数下，幅值不会衰减至 $e^{-1}$ 或更少（例如，每步的幅值因子等于 $1$），则输出 IEEE 浮点无穷大值。如果幅值在一步内降至零，则输出 $1$。所有输入参数都必须使用国际单位制（SI units）处理：$L$ 的单位是米，$\\alpha$ 的单位是平方米/秒，$\\Delta t$ 的单位是秒。输出值为无量纲整数或浮点无穷大值。\n\n您的程序必须在没有用户输入的情况下运行，并处理以下参数集测试套件，每个参数集以 $(L, N, \\alpha, \\Delta t, m)$ 的形式给出：\n\n- 案例 $1$：$(L, N, \\alpha, \\Delta t, m) = (\\,1,\\,64,\\,10^{-4},\\,0.5,\\,8\\,)$。\n- 案例 $2$：$(L, N, \\alpha, \\Delta t, m) = (\\,1,\\,64,\\,10^{-4},\\,1.220703125,\\,32\\,)$。\n- 案例 $3$：$(L, N, \\alpha, \\Delta t, m) = (\\,1,\\,64,\\,10^{-4},\\,0.5,\\,0\\,)$。\n- 案例 $4$：$(L, N, \\alpha, \\Delta t, m) = (\\,1,\\,64,\\,10^{-4},\\,0.01,\\,30\\,)$。\n- 案例 $5$：$(L, N, \\alpha, \\Delta t, m) = (\\,2,\\,100,\\,1.5\\times 10^{-4},\\,0.2,\\,25\\,)$。\n- 案例 $6$：$(L, N, \\alpha, \\Delta t, m) = (\\,1,\\,64,\\,10^{-4},\\,0.6103515625,\\,32\\,)$。\n\n这些案例测试了：平滑效果明显的一般中频模态、最高频率的稳定性边界情况、不衰减的常数模态、导致非常缓慢平滑的小时间步长、不同的网格和参数集，以及最高频率在一步内被消除的情况。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果（例如 $[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_6]$）。列表中的条目必须是按规定计算出的每个案例的最小整数 $n$，或者是在该案例下幅值永远不会衰减至 $e^{-1}$ 或更少时的浮点无穷大值。", "solution": "我们从具有周期性边界条件的空间区间上的热方程 $u_t = \\alpha u_{xx}$ 开始。在一个有 $N$ 个点、空间步长为 $\\Delta x = L/N$、时间步长为 $\\Delta t$ 的均匀网格上，显式前向时间、中心空间有限差分格式由核心定义构建：时间上使用前向欧拉法，拉普拉斯算子使用中心二阶差分。将网格索引为 $j$、时间层为 $n$ 的数值近似记为 $u_j^n$，则更新法则是\n$$\nu_j^{n+1} = u_j^n + \\alpha \\Delta t \\,\\frac{u_{j+1}^n - 2 u_j^n + u_{j-1}^n}{(\\Delta x)^2}.\n$$\n定义无量纲比率\n$$\nr = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}.\n$$\n在周期性边界条件下，离散傅里叶模态 $u_j^n = A^n \\exp\\!\\left(i \\frac{2\\pi m}{N} j\\right)$ 是离散拉普拉斯算子 $u_{j+1} - 2 u_j + u_{j-1}$ 的特征函数。对此模态作用，得到特征值\n$$\n\\lambda_m = -4 \\sin^2\\!\\left(\\frac{\\pi m}{N}\\right),\n$$\n这可由恒等式 $\\exp(i\\theta) + \\exp(-i\\theta) - 2 = -4 \\sin^2(\\theta/2)$（其中 $\\theta = \\frac{2\\pi m}{N}$）得出。将此代入更新式，即可得到模态 $m$ 的每步放大因子：\n$$\nG_m = 1 + r \\lambda_m = 1 - 4 r \\sin^2\\!\\left(\\frac{\\pi m}{N}\\right).\n$$\n因此，经过 $n$ 步后，该模态的振幅幅值乘以 $\\lvert G_m \\rvert^n$。为求得幅值衰减至其初始值的 $e^{-1}$ 倍或更少所需的步数，我们需要满足\n$$\n\\lvert G_m \\rvert^n \\le e^{-1}.\n$$\n当 $0  \\lvert G_m \\rvert  1$ 时，取自然对数可得\n$$\nn \\ge \\frac{1}{-\\ln \\lvert G_m \\rvert}.\n$$\n由于该格式以整数时间步推进，满足该不等式的最小整数是\n$$\nn_{\\min} = \\left\\lceil \\frac{1}{-\\ln \\lvert G_m \\rvert} \\right\\rceil.\n$$\n必须仔细处理特殊情况：\n- 如果 $m = 0$，则 $\\sin^2\\!\\left(\\frac{\\pi m}{N}\\right) = 0$ 且 $G_0 = 1$，意味着没有衰减；我们输出浮点无穷大值。\n- 如果 $\\lvert G_m \\rvert = 1$ （例如，当 $r = \\tfrac{1}{2}$ 且 $m = \\tfrac{N}{2}$ 时），则没有衰减；我们输出浮点无穷大值。\n- 如果 $G_m = 0$，则模态在一步内被消除；使 $\\lvert G_m \\rvert^n \\le e^{-1}$ 成立的最小整数 $n$ 是 $n=1$。\n\n针对每个测试案例 $(L, N, \\alpha, \\Delta t, m)$ 的算法步骤：\n1. 计算 $\\Delta x = L/N$ 和 $r = \\alpha \\Delta t / (\\Delta x)^2$。\n2. 计算 $s = \\sin^2\\!\\left(\\frac{\\pi m}{N}\\right)$ 和 $G_m = 1 - 4 r s$。\n3. 设置 $g = \\lvert G_m \\rvert$。\n4. 如果 $g$ 在一个小的容差范围内数值上为 $1$，则返回浮点无穷大值。\n5. 如果 $g$ 在一个小的容差范围内数值上为 $0$，则返回 $1$。\n6. 否则，计算 $n_{\\min} = \\left\\lceil \\frac{1}{-\\ln g} \\right\\rceil$ 并返回该整数。\n\n提供的测试套件确保了覆盖范围：\n- 案例 $1$ 测试一个具有明显平滑效果的中频模态 ($0  \\lvert G_m \\rvert  1$）。\n- 案例 $2$ 设置 $r=\\tfrac{1}{2}$ 和 $m=\\tfrac{N}{2}$，得到 $\\lvert G_m \\rvert = 1$，无衰减。\n- 案例 $3$ 使用 $m=0$（常数模态），该模态不衰减。\n- 案例 $4$ 使用一个非常小的 $\\Delta t$，产生缓慢的平滑效果和一个大的 $n_{\\min}$。\n- 案例 $5$ 改变 $L$、$N$ 和 $\\alpha$ 来演示参数敏感性。\n- 案例 $6$ 设置 $r=\\tfrac{1}{4}$ 和 $m=\\tfrac{N}{2}$，得到 $G_m=0$，模态在一步内立即被消除。\n\n最终的程序计算这些量，并在一行内打印出六个结果，结果为方括号内的逗号分隔列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef steps_to_e_minus_one(L, N, alpha, dt, m):\n    \"\"\"\n    Compute the smallest integer number of explicit time steps required\n    to attenuate the magnitude of discrete Fourier mode m by at most e^{-1}.\n    Special cases:\n      - If |G| == 1 (no attenuation), return float('inf').\n      - If |G| == 0 (annihilated in one step), return 1.\n    \"\"\"\n    dx = L / N\n    r = alpha * dt / (dx * dx)\n    s = np.sin(np.pi * m / N) ** 2\n    G = 1.0 - 4.0 * r * s\n    gmag = abs(G)\n\n    # Numerical tolerances to handle floating-point edge cases\n    # Treat values extremely close to 1 as no attenuation and close to 0 as annihilation.\n    if np.isclose(gmag, 1.0, rtol=1e-12, atol=1e-15):\n        return float('inf')\n    if np.isclose(gmag, 0.0, rtol=0.0, atol=1e-15):\n        return 1\n\n    # For 0  gmag  1, compute smallest integer n such that gmag^n = e^{-1}\n    # i.e., n >= 1 / (-ln(gmag)).\n    ln_g = np.log(gmag)\n    if ln_g >= 0.0:\n        # Unstable or no decay (shouldn't occur in our test suite if parameters are stable),\n        # conservatively return infinity.\n        return float('inf')\n\n    n_min = int(np.ceil(1.0 / (-ln_g)))\n    # Ensure at least 1 step when attenuation happens immediately (guard against pathological roundoff).\n    return max(1, n_min)\n\ndef solve():\n    # Define the test cases from the problem statement:\n    # Each case is a tuple: (L [m], N, alpha [m^2/s], dt [s], m)\n    test_cases = [\n        (1.0, 64, 1e-4, 0.5, 8),\n        (1.0, 64, 1e-4, 1.220703125, 32),\n        (1.0, 64, 1e-4, 0.5, 0),\n        (1.0, 64, 1e-4, 0.01, 30),\n        (2.0, 100, 1.5e-4, 0.2, 25),\n        (1.0, 64, 1e-4, 0.6103515625, 32),\n    ]\n\n    results = []\n    for L, N, alpha, dt, m in test_cases:\n        result = steps_to_e_minus_one(L, N, alpha, dt, m)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3126921"}]}