{"hands_on_practices": [{"introduction": "将线方法应用于平流-扩散方程时，可能会遇到数值不稳定性，尤其是在平流占主导地位的情况下。本实践旨在通过一个具体的计算实验，展示不同的空间离散格式（中心差分与迎风格式）如何影响解的稳定性，并揭示为何在处理此类问题时，迎风格式通常是更稳健的选择。[@problem_id:2444647]", "problem": "考虑具有周期性边界条件的一维线性平流-扩散偏微分方程 (PDE)，\n$$\n\\frac{\\partial u}{\\partial t}(x,t) + a \\,\\frac{\\partial u}{\\partial x}(x,t) = \\nu \\,\\frac{\\partial^2 u}{\\partial x^2}(x,t), \\quad x \\in [0,1], \\quad t \\in [0,T],\n$$\n其空间周期性为 $u(0,t) = u(1,t)$（对于所有 $t \\in [0,T]$），初始条件为\n$$\nu(x,0) = \\sin(2\\pi x) + 0.1 \\sin(16\\pi x).\n$$\n设空间网格是均匀的，有 $N$ 个点，间距为 $\\Delta x = 1/N$，并采用周期性索引。在网格值 $u_j(t) \\approx u(x_j,t)$（其中 $x_j = j \\,\\Delta x$）上定义两个半离散空间算子：\n- 采用二阶中心差分的中心平流和二阶导数扩散，\n$$\n\\left.\\frac{\\mathrm{d}u_j}{\\mathrm{d}t}\\right|_{\\text{centered}} = -a \\,\\frac{u_{j+1} - u_{j-1}}{2\\Delta x} + \\nu \\,\\frac{u_{j+1} - 2u_j + u_{j-1}}{\\Delta x^2}.\n$$\n- 迎风平流（与 $a$ 的符号一致的一阶迎风）和二阶导数扩散，\n$$\n\\left.\\frac{\\mathrm{d}u_j}{\\mathrm{d}t}\\right|_{\\text{upwind}} =\n\\begin{cases}\n-a \\,\\frac{u_j - u_{j-1}}{\\Delta x} + \\nu \\,\\frac{u_{j+1} - 2u_j + u_{j-1}}{\\Delta x^2},  a \\ge 0,\\\\[6pt]\n-a \\,\\frac{u_{j+1} - u_j}{\\Delta x} + \\nu \\,\\frac{u_{j+1} - 2u_j + u_{j-1}}{\\Delta x^2},  a  0.\n\\end{cases}\n$$\n使用显式前向欧拉法，以时间步长 $\\Delta t$ 向前推进至最终时间 $T$。对于每次模拟，将时间层 $n$ 的离散 $L^2$ 范数定义为\n$$\n\\|u^n\\|_2 = \\left( \\Delta x \\sum_{j=0}^{N-1} \\left(u_j^n\\right)^2 \\right)^{1/2}.\n$$\n如果所有时间步中的最大范数满足\n$$\n\\max_{0 \\le n \\le N_t} \\|u^n\\|_2 \\le G_{\\max} \\,\\|u^0\\|_2,\n$$\n则声明一次运行为“稳定”，否则为“不稳定”，其中 $G_{\\max} = 5$ 是固定值，$N_t$ 是达到 $T$ 所需的时间步数。根据无量纲因子 $C_{\\mathrm{adv}}$ 和 $C_{\\mathrm{diff}}$ 确定的平流和扩散界限的最小值来选择时间步长，如下所示：\n$$\n\\Delta t =\n\\min\\!\\left(\n\\begin{array}{l}\nC_{\\mathrm{adv}} \\,\\frac{\\Delta x}{|a|} \\quad \\text{if } |a|>0, \\text{ otherwise } +\\infty,\\\\\nC_{\\mathrm{diff}} \\,\\frac{\\Delta x^2}{2\\nu} \\quad \\text{if } \\nu>0, \\text{ otherwise } +\\infty\n\\end{array}\n\\right).\n$$\n如果 $|a|=0$ 和 $\\nu=0$ 同时成立，则此设置不在测试中考虑。\n\n您的任务是实现上述定义，并对下面的每个测试用例，判断在根据给定参数计算出的相同 $\\Delta t$ 下，中心格式和迎风格式是否稳定。该区域是无量纲的，输出中不需要物理单位。\n\n使用以下测试套件，其中每个用例指定了 $(a,\\nu,N,C_{\\mathrm{adv}},C_{\\mathrm{diff}},T)$：\n- 测试 $1$：$(a,\\nu,N,C_{\\mathrm{adv}},C_{\\mathrm{diff}},T) = (\\,1.0,\\,0.001,\\,200,\\,0.5,\\,0.4,\\,0.5\\,)$。\n- 测试 $2$：$(a,\\nu,N,C_{\\mathrm{adv}},C_{\\mathrm{diff}},T) = (\\,20.0,\\,0.0001,\\,400,\\,0.8,\\,0.2,\\,0.2\\,)$。\n- 测试 $3$：$(a,\\nu,N,C_{\\mathrm{adv}},C_{\\mathrm{diff}},T) = (\\,0.0,\\,0.01,\\,100,\\,0.5,\\,0.4,\\,0.5\\,)$。\n- 测试 $4$：$(a,\\nu,N,C_{\\mathrm{adv}},C_{\\mathrm{diff}},T) = (\\,1.0,\\,0.0,\\,200,\\,0.99,\\,0.0,\\,0.5\\,)$。\n\n您的程序必须：\n- 在每个测试用例中，对中心格式和迎风格式使用相同的 $\\Delta t$，该值需严格按照上述定义计算。\n- 积分到指定的最终时间 $T$（如果 $\\Delta t$ 不能整除 $T$，则取 $N_t = \\lceil T/\\Delta t \\rceil$ 并使用大小为 $T/N_t$ 的均匀时间步长）。\n- 对于每个测试，根据 $G_{\\max} = 5$ 的准则，按 $\\big[$中心格式稳定性, 迎风格式稳定性$\\big]$ 的顺序返回两个布尔值。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。按测试顺序连接四个测试的结果，将布尔值平展成一个单一列表。例如，输出格式应如下所示\n$$\n[\\text{c}_1,\\text{u}_1,\\text{c}_2,\\text{u}_2,\\text{c}_3,\\text{u}_3,\\text{c}_4,\\text{u}_4],\n$$\n其中 $\\text{c}_k$ 和 $\\text{u}_k$ 分别是测试 $k$ 中中心格式和迎风格式的布尔稳定性结果。", "solution": "所提出的问题已经过验证，并被认定为有效。它具有科学依据，问题适定，客观，并包含获得唯一、可验证解所需的所有必要信息。因此，我们可以着手推导和实现该解法。\n\n该问题要求对一维线性平流-扩散方程进行数值求解，\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = \\nu \\frac{\\partial^2 u}{\\partial x^2},\n$$\n在具有周期性边界条件的域 $x \\in [0,1]$上。解将使用线方法 (Method of Lines, MOL) 获得，该方法首先对空间导数进行离散化，将偏微分方程 (PDE) 转化为一个耦合常微分方程组 (ODEs)。然后对该系统进行时间积分。\n\n首先，我们定义离散空间网格。将域 $[0,1]$ 离散化为 $N$ 个长度为 $\\Delta x = 1/N$ 的均匀段。网格点为 $x_j = j\\Delta x$，其中 $j = 0, 1, \\dots, N-1$。此网格上的解由一个向量 $\\vec{u}(t)$ 表示，其第 $j$ 个分量为 $u_j(t) \\approx u(x_j, t)$。周期性边界条件意味着对于任何整数 $j$，都有 $u_{j+N} = u_j$。\n\nMOL 将 PDE 转换为 $\\frac{d\\vec{u}}{dt} = \\mathbf{L}\\vec{u}$ 的形式，其中 $\\mathbf{L}$ 是一个表示离散化空间算子的矩阵。我们被要求评估平流项 $\\frac{\\partial u}{\\partial x}$ 的两种不同离散化方法，而扩散项 $\\frac{\\partial^2 u}{\\partial x^2}$ 则统一使用标准的二阶中心差分进行离散化。\n\n二阶导数的二阶中心差分近似为：\n$$\n\\left.\\frac{\\partial^2 u}{\\partial x^2}\\right|_{x_j} \\approx \\frac{u_{j+1} - 2u_j + u_{j-1}}{\\Delta x^2}.\n$$\n该算子应用于两种格式。\n\n格式 1：中心平流\n平流项使用二阶中心差分近似：\n$$\n\\left.\\frac{\\partial u}{\\partial x}\\right|_{x_j} \\approx \\frac{u_{j+1} - u_{j-1}}{2\\Delta x}.\n$$\n结合这些，中心格式的半离散系统为：\n$$\n\\frac{d u_j}{d t} = -a \\left(\\frac{u_{j+1} - u_{j-1}}{2\\Delta x}\\right) + \\nu \\left(\\frac{u_{j+1} - 2u_j + u_{j-1}}{\\Delta x^2}\\right).\n$$\n\n格式 2：迎风平流\n平流项使用一阶迎风差分近似，其模板取决于平流速度 $a$ 的符号。做出此选择是为了引入能够增强稳定性的数值耗散。\n如果 $a \\ge 0$，则使用后向差分：\n$$\n\\left.\\frac{\\partial u}{\\partial x}\\right|_{x_j} \\approx \\frac{u_j - u_{j-1}}{\\Delta x}.\n$$\n如果 $a  0$，则使用前向差分：\n$$\n\\left.\\frac{\\partial u}{\\partial x}\\right|_{x_j} \\approx \\frac{u_{j+1} - u_j}{\\Delta x}.\n$$\n因此，迎风格式对应的半离散系统为：\n$$\n\\frac{d u_j}{d t} =\n\\begin{cases}\n-a \\left(\\frac{u_j - u_{j-1}}{\\Delta x}\\right) + \\nu \\left(\\frac{u_{j+1} - 2u_j + u_{j-1}}{\\Delta x^2}\\right),  a \\ge 0 \\\\\n-a \\left(\\frac{u_{j+1} - u_j}{\\Delta x}\\right) + \\nu \\left(\\frac{u_{j+1} - 2u_j + u_{j-1}}{\\Delta x^2}\\right),  a  0\n\\end{cases}\n$$\n\n对于时间积分，指定了显式前向欧拉法。给定时间 $t_n$ 的解向量 $\\vec{u}^n$，下一个时间步 $t_{n+1} = t_n + \\Delta t$ 的解计算如下：\n$$\n\\vec{u}^{n+1} = \\vec{u}^n + \\Delta t \\cdot \\frac{d\\vec{u}}{dt}\\bigg|_{\\vec{u}=\\vec{u}^n}.\n$$\n必须仔细选择时间步长 $\\Delta t$ 以确保数值稳定性。前向欧拉法只是条件稳定的。问题基于平流和扩散的 Courant-Friedrichs-Lewy (CFL) 条件，为初步时间步长 $\\Delta t_{cfl}$ 提供了一个特定公式：\n$$\n\\Delta t_{cfl} = \\min\\left( C_{\\mathrm{adv}} \\frac{\\Delta x}{|a|}, \\; C_{\\mathrm{diff}} \\frac{\\Delta x^2}{2\\nu} \\right).\n$$\n如果分母（$|a|$ 或 $\\nu$）为零，则这些项被视为无穷大。为确保模拟在时间 $T$ 准时结束，步数固定为 $N_t = \\lceil T/\\Delta t_{cfl} \\rceil$，并使用一个均匀的实际时间步长 $\\Delta t = T/N_t$ 进行积分。这确保了 $\\Delta t \\le \\Delta t_{cfl}$，从而保留了稳定性约束。\n\n每次模拟运行的稳定性都进行定量评估。如果在整个模拟过程中观察到的最大离散 $L^2$ 范数不超过初始范数的某个倍数，则该次运行被声明为“稳定”。时间步 $n$ 的离散 $L^2$ 范数为：\n$$\n\\|u^n\\|_2 = \\left( \\Delta x \\sum_{j=0}^{N-1} (u_j^n)^2 \\right)^{1/2}.\n$$\n稳定性准则为：\n$$\n\\max_{0 \\le n \\le N_t} \\|u^n\\|_2 \\le G_{\\max} \\|u^0\\|_2,\n$$\n其中增长因子给定为 $G_{\\max} = 5$。初始条件由 $u(x,0) = \\sin(2\\pi x) + 0.1 \\sin(16\\pi x)$ 给出，在网格上对其求值以提供初始向量 $\\vec{u}^0$。\n\n每个测试用例的算法流程如下：\n1.  设置参数 $(a, \\nu, N, C_{\\mathrm{adv}}, C_{\\mathrm{diff}}, T)$。\n2.  计算网格间距 $\\Delta x = 1/N$ 并创建网格点 $x_j$。\n3.  通过计算 $u(x_j, 0)$ 生成初始条件向量 $\\vec{u}^0$。\n4.  计算初始范数 $\\|u^0\\|_2$ 和稳定性阈值 $G_{\\max} \\|u^0\\|_2$。\n5.  计算 $\\Delta t_{cfl}$，然后计算实际时间步长 $\\Delta t = T/\\lceil T/\\Delta t_{cfl} \\rceil$。\n6.  对于每种格式（中心和迎风）：\n    a. 初始化解向量 $\\vec{u} = \\vec{u}^0$ 并设置 $\\text{max\\_norm} = \\|u^0\\|_2$。\n    b. 循环 $N_t$ 次：\n        i.   使用适当的有限差分公式计算右侧向量 $\\frac{d\\vec{u}}{dt}$。\n        ii.  使用前向欧拉步更新解：$\\vec{u} \\leftarrow \\vec{u} + \\Delta t \\frac{d\\vec{u}}{dt}$。\n        iii. 计算当前范数 $\\|\\vec{u}\\|_2$ 并在必要时更新 $\\text{max\\_norm}$。如果解变为非有限值，$\\text{max\\_norm}$ 变为无穷大。\n    c. 将最终的 $\\text{max\\_norm}$ 与阈值进行比较，以确定稳定性（真/假）。\n7.  收集两种格式的布尔稳定性结果，并将其附加到全局列表中。\n\n该流程将为所有提供的测试用例实现，最终的布尔结果列表将按指定格式进行格式化。使用向量化操作，特别是周期性移位，可以高效地在周期性网格上实现有限差分。", "answer": "```python\nimport numpy as np\nimport math\n\ndef get_rhs_calculator(a, nu, N, scheme):\n    \"\"\"\n    Returns a function that computes the right-hand side of the semi-discretized PDE.\n    This corresponds to the spatial operator applied to the solution vector u.\n    \"\"\"\n    dx = 1.0 / N\n    d2udx2_term_func = lambda u: (np.roll(u, -1) - 2 * u + np.roll(u, 1)) / (dx**2)\n\n    if scheme == 'centered':\n        def rhs_centered(u):\n            dudx_adv = (np.roll(u, -1) - np.roll(u, 1)) / (2 * dx)\n            return -a * dudx_adv + nu * d2udx2_term_func(u)\n        return rhs_centered\n    elif scheme == 'upwind':\n        def rhs_upwind(u):\n            if a >= 0:\n                dudx_adv = (u - np.roll(u, 1)) / dx\n            else:  # a  0\n                dudx_adv = (np.roll(u, -1) - u) / dx\n            return -a * dudx_adv + nu * d2udx2_term_func(u)\n        return rhs_upwind\n    else:\n        raise ValueError(\"Unknown scheme type\")\n\ndef check_stability(params, scheme, G_max):\n    \"\"\"\n    Runs a single simulation for a given test case and scheme, then reports its stability.\n    \"\"\"\n    a, nu, N, C_adv, C_diff, T = params\n\n    # 1. Grid and Initial Condition\n    dx = 1.0 / N\n    x = np.arange(N, dtype=float) / N\n    u = np.sin(2 * np.pi * x) + 0.1 * np.sin(16 * np.pi * x)\n\n    # 2. Initial norm and stability threshold\n    norm_initial = np.sqrt(dx * np.sum(u**2))\n    if norm_initial == 0:\n        return True  # Trivial case: zero initial condition is always stable\n    max_norm = norm_initial\n\n    # 3. Time step calculation\n    dt_adv = C_adv * dx / abs(a) if abs(a) > 0 else float('inf')\n    dt_diff = C_diff * dx**2 / (2 * nu) if nu > 0 else float('inf')\n    dt_cfl = min(dt_adv, dt_diff)\n\n    if T == 0:\n        return True\n    if dt_cfl == float('inf'): # Corresponds to a=0 and nu=0 case, u(x,t) is constant.\n      return True\n\n    num_steps = math.ceil(T / dt_cfl)\n    dt = T / num_steps\n    \n    # 4. Get the appropriate RHS function for the scheme\n    rhs_calculator = get_rhs_calculator(a, nu, N, scheme)\n\n    # 5. Time integration loop\n    for _ in range(num_steps):\n        u = u + dt * rhs_calculator(u)\n        \n        current_norm = np.sqrt(dx * np.sum(u**2))\n        \n        if np.isnan(current_norm) or np.isinf(current_norm):\n            max_norm = float('inf')\n            break\n            \n        if current_norm > max_norm:\n            max_norm = current_norm\n            \n    # 6. Check stability criterion\n    return max_norm = G_max * norm_initial\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (a,      nu,       N,   C_adv, C_diff, T)\n        (1.0,    0.001,    200, 0.5,   0.4,    0.5),\n        (20.0,   0.0001,   400, 0.8,   0.2,    0.2),\n        (0.0,    0.01,     100, 0.5,   0.4,    0.5),\n        (1.0,    0.0,      200, 0.99,  0.0,    0.5),\n    ]\n\n    G_max = 5.0\n    results = []\n\n    for i, case in enumerate(test_cases):\n        is_stable_cen = check_stability(case, 'centered', G_max)\n        is_stable_upw = check_stability(case, 'upwind', G_max)\n        results.extend([is_stable_cen, is_stable_upw])\n\n    # Final print statement in the exact required format.\n    # str(True) -> 'True', str(False) -> 'False'\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2444647"}, {"introduction": "线方法求解的整体精度往往受限于离散化中最不精确的部分，而这通常发生在边界处。本实践将探讨处理诺伊曼（Neumann）边界条件的两种常用方法——“幽灵网格”法和高阶单边差分法，并通过数值实验来检验它们如何影响全局解的收敛阶。[@problem_id:3159236]", "problem": "考虑一维热方程，它是在有限区间上的一个典型的抛物线型偏微分方程，\n$$\nu_t(x,t) = \\alpha\\,u_{xx}(x,t), \\quad 0 \\le x \\le L,\\quad 0 \\le t \\le T,\n$$\n其具有齐次 Neumann 边界条件\n$$\nu_x(0,t)=0,\\quad u_x(L,t)=0,\n$$\n以及由余弦模态叠加形成的初始条件，\n$$\nu(x,0)=\\cos\\!\\Big(\\frac{n_1\\pi x}{L}\\Big)+\\frac{1}{2}\\cos\\!\\Big(\\frac{n_2\\pi x}{L}\\Big),\n$$\n其中 $n_1$ 和 $n_2$ 是正整数。对于这样的数据，精确解为\n$$\nu(x,t)=\\exp\\!\\Big(-\\alpha\\Big(\\frac{n_1\\pi}{L}\\Big)^2 t\\Big)\\cos\\!\\Big(\\frac{n_1\\pi x}{L}\\Big)+\\frac{1}{2}\\exp\\!\\Big(-\\alpha\\Big(\\frac{n_2\\pi}{L}\\Big)^2 t\\Big)\\cos\\!\\Big(\\frac{n_2\\pi x}{L}\\Big).\n$$\n\n您的任务是使用线方法 (Method of Lines, MOL) 在一个包含 $N$ 个点（包括边界）的均匀网格上进行空间半离散化，网格间距为 $h=L/(N-1)$，从而形成一个形如下式的线性常微分方程组\n$$\n\\frac{d\\mathbf{u}}{dt}=\\mathbf{A}\\,\\mathbf{u},\n$$\n其中 $\\mathbf{u}(t)\\in\\mathbb{R}^N$ 是在网格节点 $x_i=i\\,h$（$i=0,1,\\dots,N-1$）处对 $u(x_i,t)$ 的近似。在内部节点 $i=1,\\dots,N-2$ 处，使用标准的二阶中心有限差分近似来处理 $u_{xx}$。在边界处，实现并比较以下两种用于 Neumann 条件 $u_x(0,t)=u_x(L,t)=0$ 的封闭方法：\n\n- 虚单元反射 (Ghost-cell reflection, GC)：通过将解以与法向导数为零相一致的方式扩展到域外的虚拟节点来强制施加 Neumann 条件，然后消除这些虚值以在物理节点上获得一个封闭的半离散系统。\n\n- 单边边界封闭 (One-sided boundary closure, OS)：在 $x=0$ 和 $x=L$ 处，通过使用受 $u_x=0$ 约束的泰勒展开来消除任何虚值，推导出一个关于 $u_{xx}$ 的单边边界公式，该公式在 $h$ 上至少是二阶精确的。\n\n通过矩阵指数对半离散系统进行精确的时间积分，以分离空间离散化误差。您可以数值上实现 $\\mathbf{u}(T)=\\exp(T\\mathbf{A})\\,\\mathbf{u}(0)$。\n\n对于每种方法（GC 和 OS），对于每个网格尺寸 $N$，计算在时间 $T$ 的最大范数误差，\n$$\ne(N)=\\max_{0\\le i\\le N-1}\\big|u_{\\text{num}}(x_i,T)-u_{\\text{exact}}(x_i,T)\\big|.\n$$\n使用间距为 $h_1$ 和 $h_2$ 的两次连续细化，报告观察到的精度阶数\n$$\np=\\frac{\\log\\big(e(N_1)/e(N_2)\\big)}{\\log\\big(h_1/h_2\\big)}.\n$$\n\n测试套件。使用 $L=1$ 和模态对 $(n_1,n_2)=(2,3)$。对于下面的每种情况，使用网格尺寸 $\\{N\\}=\\{21,41,81,161\\}$，并从两个最精细的网格 $N=81$ 和 $N=161$ 计算 $p$ 时定义 $h(L,N)=L/(N-1)$：\n\n- 情况 A (理想情况)：$\\alpha=1$, $T=0.03$。\n- 情况 B (不同扩散系数)：$\\alpha=0.1$, $T=0.03$。\n- 情况 C (更长时间)：$\\alpha=1$, $T=0.2$。\n\n对于每种情况，产生三个输出：\n- 在 $N=81$ 和 $N=161$ 之间，虚单元反射法观察到的阶数 $p_{\\text{GC}}$，\n- 在 $N=81$ 和 $N=161$ 之间，单边边界封闭法观察到的阶数 $p_{\\text{OS}}$，\n- 一个布尔值，指示是否 $p_{\\text{OS}}>1.5$ 且 $p_{\\text{GC}}1.5$。\n\n将报告的每个阶数四舍五入到三位小数。您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,...]”），结果按以下顺序排列：情况 A 的三元组、情况 B 的三元组、情况 C 的三元组。不应打印任何其他文本。", "solution": "该问题是有效的，因为它提出了一个适定的一维热方程初边值问题，并要求使用线方法 (Method of Lines, MOL) 进行标准的数值分析研究。该问题具有科学依据，内容自洽且客观。\n\n问题的核心是构造和比较热方程的两种不同的半离散化方法，\n$$\nu_t = \\alpha u_{xx},\n$$\n该离散化是在一个由 $N$ 个点 $x_i = ih$（$i=0, 1, \\dots, N-1$）组成的均匀网格上进行的，其中网格间距为 $h=L/(N-1)$。MOL 方法将偏微分方程 (PDE) 简化为一个耦合的常微分方程 (ODE) 组，\n$$\n\\frac{d\\mathbf{u}}{dt} = \\mathbf{A} \\mathbf{u}(t),\n$$\n其中 $\\mathbf{u}(t) = [u_0(t), u_1(t), \\dots, u_{N-1}(t)]^T$ 是在网格点上的近似解值的向量，而 $\\mathbf{A}$ 是一个常数矩阵，用于近似空间算子 $\\alpha \\frac{\\partial^2}{\\partial x^2}$。\n\n对于内部网格点 $i=1, \\dots, N-2$，两种方法都使用标准的二阶中心差分来近似二阶导数：\n$$\nu_{xx}(x_i) \\approx \\frac{u(x_{i-1}) - 2u(x_i) + u(x_{i+1})}{h^2} = \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2}.\n$$\n这定义了离散化矩阵 $\\mathbf{A}$ 的第 $i=1, \\dots, N-2$ 行具有 $\\frac{\\alpha}{h^2}[\\dots, 1, -2, 1, \\dots]$ 的形式。这两种方法的不同之处在于它们如何构造 $\\mathbf{A}$ 的第一行 ($i=0$) 和最后一行 ($i=N-1$) 以包含齐次 Neumann 边界条件 $u_x(0,t)=0$ 和 $u_x(L,t)=0$。\n\n**1. 虚单元 (GC) 反射法**\n\n该方法通过在域外引入一个虚构的“虚”点来施加 Neumann 条件。在左边界 $x_0=0$ 处，我们在 $x_{-1}=-h$ 处引入一个虚点。我们使用二阶中心差分来近似边界条件 $u_x(0,t)=0$：\n$$\n\\frac{u_1 - u_{-1}}{2h} = 0 \\implies u_{-1} = u_1.\n$$\n这个关系将第一个内部点的解值反射到虚点上。我们现在可以在边界点 $x_0$ 处使用标准的中心差分格式来计算 $u_{xx}$：\n$$\nu_{xx}(x_0) \\approx \\frac{u_{-1} - 2u_0 + u_1}{h^2} = \\frac{u_1 - 2u_0 + u_1}{h^2} = \\frac{2u_1 - 2u_0}{h^2}.\n$$\n根据对称性，在右边界 $x_{N-1}=L$ 处的近似为：\n$$\nu_{xx}(x_{N-1}) \\approx \\frac{2u_{N-2} - 2u_{N-1}}{h^2}.\n$$\n关键步骤是分析此边界近似的局部截断误差 (LTE)。使用 $u(h)$ 在 $x=0$ 附近的泰勒展开，并结合条件 $u_x(0)=0$：\n$$\nu(h) = u(0) + h u_x(0) + \\frac{h^2}{2}u_{xx}(0) + \\frac{h^3}{6}u_{xxx}(0) + O(h^4) = u(0) + \\frac{h^2}{2}u_{xx}(0) + \\frac{h^3}{6}u_{xxx}(0) + O(h^4).\n$$\n我们对 $u_{xx}(0)$ 的近似的 LTE 是：\n$$\n\\text{LTE}_{\\text{GC}} = \\frac{2(u(h)-u(0))}{h^2} - u_{xx}(0) = \\frac{2}{h^2}\\left(\\frac{h^2}{2}u_{xx}(0) + \\frac{h^3}{6}u_{xxx}(0) + O(h^4)\\right) - u_{xx}(0) = \\frac{h}{3}u_{xxx}(0) + O(h^2).\n$$\nLTE 是 $O(h)$ 阶的。边界上的这个一阶误差会污染整个解，导致该方法的全局误差为一阶，即 $p_{\\text{GC}} \\approx 1$。\n\n**2. 单边 (OS) 边界封闭法**\n\n该方法使用域内的点 ($u_0, u_1, u_2$) 推导出一个 $u_{xx}(0)$ 的单边公式，该公式通过利用 $u_x(0)=0$ 的条件被专门构造成二阶精确。我们使用 $u_1=u(h)$ 和 $u_2=u(2h)$ 在 $x=0$ 附近的泰勒级数，其中 $u_x(0)=0$：\n$$\nu_1 - u_0 = \\frac{h^2}{2} u_{xx}(0) + \\frac{h^3}{6} u_{xxx}(0) + \\frac{h^4}{24} u_{xxxx}(0) + O(h^5)\n$$\n$$\nu_2 - u_0 = \\frac{(2h)^2}{2} u_{xx}(0) + \\frac{(2h)^3}{6} u_{xxx}(0) + \\frac{(2h)^4}{24} u_{xxxx}(0) + O(h^5) = 2h^2 u_{xx}(0) + \\frac{4h^3}{3} u_{xxx}(0) + \\frac{2h^4}{3} u_{xxxx}(0) + O(h^5)\n$$\n我们寻求一个线性组合 $A(u_1-u_0) + B(u_2-u_0)$ 以消除 $u_{xxx}(0)$ 项。$h^3 u_{xxx}(0)$ 的系数是 $(\\frac{A}{6} + \\frac{4B}{3})$。将其设为零可得 $A = -8B$。为了恢复 $u_{xx}(0)$，我们需要 $h^2 u_{xx}(0)$ 的系数 $(\\frac{A}{2} + 2B)$ 为 $1$。代入 $A=-8B$ 得到 $-4B+2B=1 \\implies B=-1/2$，因此 $A=4$。所以，$4(u_1-u_0) - \\frac{1}{2}(u_2-u_0) = h^2 u_{xx}(0) + O(h^4)$。两边乘以 $2$ 得到 $8(u_1-u_0) - (u_2-u_0) = 2h^2 u_{xx}(0) + O(h^4)$。这提供了以下近似：\n$$\nu_{xx}(0) \\approx \\frac{8u_1 - u_2 - 7u_0}{2h^2}.\n$$\n此近似的 LTE 是：\n$$\n\\text{LTE}_{\\text{OS}} = \\frac{-7u_0 + 8u_1 - u_2}{2h^2} - u_{xx}(0),\n$$\n根据我们的推导，它是 $O(h^2)$ 阶的。由于内部和边界的近似都是二阶的，该方法的全局误差预期为二阶，即 $p_{\\text{OS}} \\approx 2$。在右边界对应的公式是 $u_{xx}(x_{N-1}) \\approx \\frac{-7u_{N-1} + 8u_{N-2} - u_{N-3}}{2h^2}$。\n\n**数值步骤**\n\n这两种方法产生两个不同的系统矩阵，$\\mathbf{A}_{\\text{GC}}$ 和 $\\mathbf{A}_{\\text{OS}}$。ODE 系统使用矩阵指数从 $t=0$ 到 $t=T$ 进行精确积分，$\\mathbf{u}(T) = \\exp(T\\mathbf{A})\\mathbf{u}(0)$，其中 $\\mathbf{u}(0)$ 是初始条件向量。这样可以分离出空间离散化误差。然后通过将数值解与在时间 $T$ 的给定精确解进行比较，来计算最大范数误差 $e(N)$。观察到的精度阶数 $p$ 是使用来自两个网格细化 ($N_1=81$ 和 $N_2=161$) 的误差计算的：\n$$\np=\\frac{\\log\\big(e(N_1)/e(N_2)\\big)}{\\log\\big(h_1/h_2\\big)},\n$$\n其中 $h_1=L/(N_1-1)$ 且 $h_2=L/(N_2-1)$。由于 $h_1/h_2 = 160/80=2$，这可以简化为 $p = \\log_2(e_{81}/e_{161})$。\n我们的分析预测 $p_{\\text{GC}} \\approx 1$ 和 $p_{\\text{OS}} \\approx 2$。因此，对于所有测试用例，条件 $p_{\\text{OS}} > 1.5$ 且 $p_{\\text{GC}}  1.5$ 预计都将成立。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef build_matrix(N, L, alpha, method):\n    \"\"\"Constructs the spatial discretization matrix A for du/dt = A*u.\"\"\"\n    h = L / (N - 1)\n    A = np.zeros((N, N))\n    \n    # Interior points (common to both methods)\n    # u_xx approx is (u_i-1 - 2u_i + u_i+1) / h^2\n    for i in range(1, N - 1):\n        A[i, i - 1] = 1.0\n        A[i, i]     = -2.0\n        A[i, i + 1] = 1.0\n        \n    if method == \"GC\":\n        # Ghost-cell reflection: u_{-1}=u_1 and u_{N}=u_{N-2}\n        # u_xx(0) approx is (2u_1 - 2u_0) / h^2\n        A[0, 0] = -2.0\n        A[0, 1] = 2.0\n        # u_xx(L) approx is (2u_{N-2} - 2u_{N-1}) / h^2\n        A[N - 1, N - 2] = 2.0\n        A[N - 1, N - 1] = -2.0\n        A *= alpha / h**2\n        \n    elif method == \"OS\":\n        # One-sided 2nd-order closure\n        # u_xx(0) approx is (-7u_0 + 8u_1 - u_2) / (2h^2)\n        A[0, 0] = -7.0\n        A[0, 1] = 8.0\n        A[0, 2] = -1.0\n        # u_xx(L) approx is (-u_{N-3} + 8u_{N-2} - 7u_{N-1}) / (2h^2)\n        A[N - 1, N - 3] = -1.0\n        A[N - 1, N - 2] = 8.0\n        A[N - 1, N - 1] = -7.0\n        A[0,:] /= 2.0\n        A[N-1,:] /= 2.0\n        A *= alpha / h**2\n        \n    else:\n        raise ValueError(\"Unknown method specified\")\n        \n    return A\n\ndef get_exact_solution(x, t, alpha, n1, n2, L):\n    \"\"\"Computes the exact solution at given points x and time t.\"\"\"\n    term1 = np.exp(-alpha * (n1 * np.pi / L)**2 * t) * np.cos(n1 * np.pi * x / L)\n    term2 = 0.5 * np.exp(-alpha * (n2 * np.pi / L)**2 * t) * np.cos(n2 * np.pi * x / L)\n    return term1 + term2\n\ndef run_case(alpha, T, n1, n2, L, N_vals):\n    \"\"\"Runs a single test case for both GC and OS methods.\"\"\"\n    errors_gc = {}\n    errors_os = {}\n\n    for N in N_vals:\n        h = L / (N - 1)\n        x = np.linspace(0, L, N)\n        \n        # Initial condition\n        u0 = get_exact_solution(x, 0, alpha, n1, n2, L)\n        \n        # Exact solution at time T\n        u_exact_T = get_exact_solution(x, T, alpha, n1, n2, L)\n        \n        # --- Ghost-Cell Method ---\n        A_gc = build_matrix(N, L, alpha, \"GC\")\n        u_num_gc = expm(T * A_gc) @ u0\n        errors_gc[N] = np.max(np.abs(u_num_gc - u_exact_T))\n        \n        # --- One-Sided Method ---\n        A_os = build_matrix(N, L, alpha, \"OS\")\n        u_num_os = expm(T * A_os) @ u0\n        errors_os[N] = np.max(np.abs(u_num_os - u_exact_T))\n\n    # Compute order of accuracy using the two finest grids\n    N1, N2 = sorted(N_vals)[-2:]\n    h1 = L / (N1 - 1)\n    h2 = L / (N2 - 1)\n    \n    p_gc = np.log(errors_gc[N1] / errors_gc[N2]) / np.log(h1 / h2)\n    p_os = np.log(errors_os[N1] / errors_os[N2]) / np.log(h1 / h2)\n    \n    # Check the boolean condition\n    bool_check = (p_os > 1.5) and (p_gc  1.5)\n    \n    return round(p_gc, 3), round(p_os, 3), bool_check\n\ndef solve():\n    # Problem definition\n    L = 1.0\n    n1, n2 = 2, 3\n    N_vals = [21, 41, 81, 161]\n    \n    test_cases = [\n        {'alpha': 1.0, 'T': 0.03},  # Case A\n        {'alpha': 0.1, 'T': 0.03},  # Case B\n        {'alpha': 1.0, 'T': 0.2},   # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        p_gc, p_os, bool_check = run_case(case['alpha'], case['T'], n1, n2, L, N_vals)\n        results.extend([p_gc, p_os, bool_check])\n\n    # Format output as a single comma-separated string in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3159236"}, {"introduction": "在科学与工程领域，许多物理系统（如化学反应）在使用线方法离散后，会产生刚性常微分方程组（stiff ODEs）。本实践将处理一个典型的刚性反应-扩散问题，通过比较一种隐-显（IMEX）方法和一种基于牛顿法的全隐式求解器，来揭示不同时间积分策略在实现复杂性与计算效率之间的权衡。[@problem_id:3159311]", "problem": "要求您设计、实现并测试一种线方法 (MOL)，用于求解一个因其非线性反应项而表现出刚性的反应扩散偏微分方程 (PDE)。MOL 框架通过空间离散化将偏微分方程的空间导数转换为代数算子，从而留下一个关于时间的常微分方程组 (ODE) 进行数值积分。您的数值实验将比较两种时间积分策略：一种是隐式-显式 (IMEX) 格式，该格式对扩散项进行隐式处理，对刚性反应项进行显式处理；另一种是全隐式格式，该格式对两项都进行隐式处理，并使用牛顿法求解由此产生的非线性方程组。\n\n从以下一维空间中的适定偏微分方程问题开始：\n$$\nu_t = D u_{xx} + f(u), \\quad x \\in [0,1], \\quad t \\in [0,T],\n$$\n边界条件为齐次狄利克雷边界条件\n$$\nu(0,t) = 0, \\quad u(1,t) = 0,\n$$\n以及光滑的初始条件\n$$\nu(x,0) = \\sin(\\pi x).\n$$\n非线性反应项为\n$$\nf(u) = \\lambda(u - u^3),\n$$\n其中 $D$ 和 $\\lambda$ 是正实数参数。当 $ \\lambda $ 很大时，源项 $ f(u) $ 会导致刚性。\n\n通过在 $[0,1]$ 上设置 $N$ 个等距网格点（间距为 $ h = 1/(N-1) $）来构建 MOL 离散化，对 $N-2$ 个内部点上的 $u_{xx}$ 应用标准二阶中心差分近似，并在边界处强制施加 $ u(0,t) = u(1,t) = 0 $。将内部未知向量记为 $ y(t) \\in \\mathbb{R}^{N-2} $。空间离散化产生一个线性算子 $ A \\in \\mathbb{R}^{(N-2)\\times(N-2)} $，该算子代表具有三对角模板 $ (1,-2,1)/h^2 $ 的 $ D u_{xx} $，因此半离散 ODE 系统为\n$$\n\\dot{y}(t) = A y(t) + f(y(t)),\n$$\n其中 $ f $ 逐分量作用，即 $ f(y)_i = \\lambda \\big(y_i - y_i^3\\big) $。\n\n实现两种时间积分格式，将时间从 $ t=0 $ 推进到 $ t=T $：\n\n- 隐式-显式 (IMEX) 格式：对扩散项使用后向欧拉法，对反应项使用前向欧拉法。设时间步长为 $ \\Delta t $，对于步 $ n \\rightarrow n+1 $：\n$$\n\\big(I - \\Delta t \\, A\\big) y^{n+1} = y^{n} + \\Delta t \\, f(y^{n}),\n$$\n其中 $ I $ 是单位矩阵。\n\n- 全隐式格式：对两项均使用后向欧拉法。对于步 $ n \\rightarrow n+1 $：\n$$\ny^{n+1} - \\Delta t \\, A y^{n+1} - \\Delta t \\, f(y^{n+1}) = y^{n}.\n$$\n使用牛顿法求解该非线性系统。令\n$$\nF(v) = v - \\Delta t \\, A v - \\Delta t \\, f(v) - y^{n}.\n$$\n牛顿迭代通过求解以下方程来更新 $ v $：\n$$\n\\Big(I - \\Delta t \\, A - \\Delta t \\, \\operatorname{diag}\\big(f'(v)\\big)\\Big) \\, \\delta = -F(v), \\quad v \\leftarrow v + \\delta,\n$$\n直到残差范数 $ \\|F(v)\\|_2 $ 低于选定的容差。此处 $ f'(u) = \\lambda(1 - 3 u^2) $。\n\n您的程序必须是这两种格式的一个完整的、可运行的实现，使用上述离散化和时间推进规则。它必须执行以下包含三个案例的测试套件，每个案例由参数 $ (N, D, \\lambda, T, \\Delta t_{\\mathrm{IMEX}}, \\Delta t_{\\mathrm{IMP}}) $ 指定：\n\n- 案例 $1$：$ N = 50 $，$ D = 0.01 $，$ \\lambda = 200 $，$ T = 0.02 $，$ \\Delta t_{\\mathrm{IMEX}} = 2\\times 10^{-5} $，$ \\Delta t_{\\mathrm{IMP}} = 2\\times 10^{-4} $。\n- 案例 $2$：$ N = 70 $，$ D = 0.005 $，$ \\lambda = 700 $，$ T = 0.01 $，$ \\Delta t_{\\mathrm{IMEX}} = 1\\times 10^{-5} $，$ \\Delta t_{\\mathrm{IMP}} = 2\\times 10^{-4} $。\n- 案例 $3$：$ N = 30 $，$ D = 0.02 $，$ \\lambda = 100 $，$ T = 0.05 $，$ \\Delta t_{\\mathrm{IMEX}} = 1\\times 10^{-4} $，$ \\Delta t_{\\mathrm{IMP}} = 1\\times 10^{-3} $。\n\n对于每个案例，计算以下三个指标：\n\n- $m_1$：在最终时间 $ T $ 时，IMEX 解与全隐式解之差的离散 $L^2$ 范数，即：\n$$\nm_1 = \\big\\| y_{\\mathrm{IMEX}}(T) - y_{\\mathrm{IMP}}(T) \\big\\|_2.\n$$\n- $m_2$：IMEX 格式所用的时间步数与全隐式格式所用的时间步数的比率，\n$$\nm_2 = \\frac{N_{\\mathrm{steps,IMEX}}}{N_{\\mathrm{steps,IMP}}}.\n$$\n- $m_3$：全隐式求解器在整个积分过程中为达到时间 $ T $ 所使用的牛顿迭代总次数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含九个浮点数结果 $[m_1^{(1)}, m_2^{(1)}, m_3^{(1)}, m_1^{(2)}, m_2^{(2)}, m_3^{(2)}, m_1^{(3)}, m_2^{(3)}, m_3^{(3)}]$，其中上标对应案例编号。每个浮点数必须四舍五入到六位小数。此问题不涉及物理单位，因此不要在输出中附加任何单位。", "solution": "该问题要求设计并实现两种基于线方法 (MOL) 的数值格式，用于求解一个刚性的一维反应扩散偏微分方程 (PDE)。我们将比较一个隐式-显式 (IMEX) 格式与一个全隐式格式。\n\n控制偏微分方程由下式给出：\n$$\nu_t = D u_{xx} + f(u), \\quad x \\in [0,1], \\quad t \\in [0,T]\n$$\n其边界条件为齐次狄利克雷边界条件 $u(0,t) = u(1,t) = 0$，初始条件为 $u(x,0) = \\sin(\\pi x)$。非线性反应项为 $f(u) = \\lambda(u - u^3)$，当 $\\lambda > 0$ 较大时会引起刚性。\n\n线方法的第一步是离散化空间域。我们定义一个包含 $N$ 个点的均匀网格 $x_j = j \\cdot h$，$j=0, 1, \\dots, N-1$，其中网格间距为 $h = 1/(N-1)$。内部网格点 $x_1, \\dots, x_{N-2}$ 处的解由一个随时间变化的向量 $y(t) \\in \\mathbb{R}^{N-2}$ 表示，其中 $y_i(t) \\approx u(x_{i+1}, t)$。边界条件意味着 $u(x_0,t) = 0$ 且 $u(x_{N-1},t) = 0$。\n\n内部点 $x_j$ 处的空间二阶导数 $u_{xx}$ 使用二阶中心差分公式近似：\n$$\nu_{xx}(x_j, t) \\approx \\frac{u(x_{j-1}, t) - 2u(x_j, t) + u(x_{j+1}, t)}{h^2}\n$$\n将此公式应用于所有 $N-2$ 个内部点并结合边界条件，得到一个常微分方程 (ODE) 组。扩散项 $D u_{xx}$ 的离散化形成一个由矩阵 $A \\in \\mathbb{R}^{(N-2)\\times(N-2)}$ 表示的线性算子。矩阵 $A$ 是三对角的，其对角元素等于 $-2D/h^2$，次对角线和超对角线元素等于 $D/h^2$。\n\n该半离散 ODE 系统为：\n$$\n\\frac{d y}{d t} = \\dot{y}(t) = A y(t) + f(y(t))\n$$\n其中函数 $f$ 逐元素地应用于向量 $y(t)$，即 $[f(y(t))]_i = \\lambda(y_i(t) - y_i(t)^3)$。此 ODE 系统的初始条件来自在内部网格点上的初始 PDE 条件。在 Python 实现中，我们使用一个长度为 $N-2$ 的向量 $y$ 来表示内部解，其索引为 $i=0, \\dots, N-3$。该向量与物理网格点 $x_1, \\dots, x_{N-2}$ 相对应。因此，向量的第 $i$ 个元素对应于网格点 $x_{i+1}$，初始条件为 $y_i(0) = \\sin(\\pi x_{i+1})$。\n\n接下来，我们进行时间离散化。我们将实现并比较两种一阶格式。设 $y^n$ 为时间 $t_n = n \\Delta t$ 时的数值解。\n\n**格式1：隐式-显式 (IMEX) 欧拉法**\n该格式对刚性线性扩散项进行隐式处理（使用后向欧拉法），对非线性反应项进行显式处理（使用前向欧拉法）。选择这种组合通常是为了在每一步中无需解非线性系统即可处理由扩散引起的刚性。从 $y^n$ 到 $y^{n+1}$ 的更新为：\n$$\n\\frac{y^{n+1} - y^n}{\\Delta t} = A y^{n+1} + f(y^n)\n$$\n重新整理以求解 $y^{n+1}$，我们得到一个线性系统：\n$$\n(I - \\Delta t A) y^{n+1} = y^n + \\Delta t f(y^n)\n$$\n其中 $I$ 是单位矩阵。左侧的矩阵 $M_{\\mathrm{IMEX}} = (I - \\Delta t A)$ 在整个积分过程中是恒定的。为了提高效率，我们可以在时间步进循环之前计算一次其 LU 分解，然后在每个步骤中使用前向/后向代入法来求解 $y^{n+1}$。\n\n**格式2：全隐式欧拉法**\n该格式对扩散项和反应项都进行隐式处理：\n$$\n\\frac{y^{n+1} - y^n}{\\Delta t} = A y^{n+1} + f(y^{n+1})\n$$\n这是一个关于 $y^{n+1}$ 的非线性代数方程组。我们定义一个残差函数 $F(v)$，其中 $v$ 是 $y^{n+1}$ 的一个候选解：\n$$\nF(v) = v - \\Delta t A v - \\Delta t f(v) - y^n = 0\n$$\n我们使用牛顿法求解此系统。从一个初始猜测（例如，$v_0 = y^n$）开始，我们迭代地优化解。第 $k$ 次牛顿迭代为：\n$$\nJ_F(v_k) \\delta_k = -F(v_k), \\quad v_{k+1} = v_k + \\delta_k\n$$\n其中 $J_F(v)$ 是 $F(v)$ 的雅可比矩阵：\n$$\nJ_F(v) = \\frac{\\partial F}{\\partial v} = I - \\Delta t A - \\Delta t \\frac{\\partial f(v)}{\\partial v}\n$$\n逐分量函数 $f(v)$ 的导数是一个对角矩阵：$\\frac{\\partial f(v)}{\\partial v} = \\operatorname{diag}(f'(v_i))$，其中 $f'(u) = \\lambda(1 - 3u^2)$。雅可比矩阵 $J_F(v)$ 是一个三对角矩阵，因为它是一个三对角矩阵 $(I - \\Delta t A)$ 和一个对角矩阵的和。这种结构使得在每次牛顿迭代中，求解 $\\delta_k$ 的线性系统可以非常高效地完成，例如使用带状矩阵求解器。迭代将持续进行，直到残差的 L2 范数 $\\|F(v)\\|_2$ 小于指定的容差。\n\n最后，对于每个测试案例，我们计算指定的指标：\n- $m_1 = \\| y_{\\mathrm{IMEX}}(T) - y_{\\mathrm{IMP}}(T) \\|_2$：最终解之间差异的离散 L2 范数。\n- $m_2 = N_{\\mathrm{steps,IMEX}} / N_{\\mathrm{steps,IMP}} = (T/\\Delta t_{\\mathrm{IMEX}}) / (T/\\Delta t_{\\mathrm{IMP}}) = \\Delta t_{\\mathrm{IMP}} / \\Delta t_{\\mathrm{IMEX}}$：时间步数的比率。\n- $m_3$：全隐式求解器在所有时间步中为达到时间 $T$ 所执行的牛顿迭代总次数。\n\n实现将精确遵循这些数学和算法公式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import lu_factor, lu_solve, solve_banded\n\n# from scipy import ...\n\ndef create_diffusion_matrix(N, D):\n    \"\"\"Constructs the diffusion matrix A for the interior grid points.\"\"\"\n    num_interior = N - 2\n    h = 1.0 / (N - 1)\n    \n    diag_val = -2.0 * D / h**2\n    offdiag_val = D / h**2\n    \n    # Using np.diag to build the sparse matrix as a dense numpy array\n    A = np.diag(diag_val * np.ones(num_interior)) + np.diag(offdiag_val * np.ones(num_interior - 1), k=1) + np.diag(offdiag_val * np.ones(num_interior - 1), k=-1)\n    return A\n\ndef run_imex(N, D, lam, T, dt):\n    \"\"\"\n    Solves the reaction-diffusion PDE using the IMEX scheme.\n    (Implicit Euler for diffusion, Explicit Euler for reaction)\n    \"\"\"\n    num_interior = N - 2\n    \n    # Grid and initial condition for interior points\n    x = np.linspace(0, 1, N)\n    y = np.sin(np.pi * x[1:-1])\n    \n    # Diffusion matrix A\n    A = create_diffusion_matrix(N, D)\n    \n    # IMEX system matrix (I - dt*A)\n    I = np.identity(num_interior)\n    LHS = I - dt * A\n    \n    # Pre-compute LU factorization for efficiency\n    lu, piv = lu_factor(LHS)\n    \n    # Reaction function\n    def f(u):\n        return lam * (u - u**3)\n        \n    num_steps = int(round(T / dt))\n    \n    for _ in range(num_steps):\n        RHS = y + dt * f(y)\n        y = lu_solve((lu, piv), RHS)\n        \n    return y\n\ndef run_implicit(N, D, lam, T, dt):\n    \"\"\"\n    Solves the reaction-diffusion PDE using the fully implicit Euler scheme\n    with Newton's method for the nonlinear system.\n    \"\"\"\n    num_interior = N - 2\n    h = 1.0 / (N - 1)\n    \n    # Grid and initial condition for interior points\n    x = np.linspace(0, 1, N)\n    y_n = np.sin(np.pi * x[1:-1])  # Solution at step n\n    \n    # Diffusion matrix A components\n    A_diag_vals = -2.0 * D / h**2 * np.ones(num_interior)\n    A_offdiag_vals = D / h**2 * np.ones(num_interior - 1)\n    A = np.diag(A_diag_vals) + np.diag(A_offdiag_vals, k=1) + np.diag(A_offdiag_vals, k=-1)\n\n    # Reaction function and its derivative\n    def f(u):\n        return lam * (u - u**3)\n    def f_prime(u):\n        return lam * (1 - 3 * u**2)\n        \n    num_steps = int(round(T / dt))\n    total_newton_iters = 0\n    newton_tol = 1e-10\n    max_newton_iters = 20\n\n    for _ in range(num_steps):\n        v = y_n.copy()  # Initial guess for y^{n+1}\n        \n        for k in range(max_newton_iters):\n            total_newton_iters += 1\n            \n            # Calculate residual F(v) = v - dt*(A@v + f(v)) - y_n\n            F_v = v - dt * (A @ v + f(v)) - y_n\n            \n            if np.linalg.norm(F_v)  newton_tol:\n                break\n            \n            # Calculate Jacobian J(v) = I - dt*A - dt*diag(f'(v))\n            # J is tridiagonal, so we construct it in banded form for solve_banded\n            J_diag = 1.0 - dt * A_diag_vals - dt * f_prime(v)\n            J_offdiag = -dt * A_offdiag_vals\n            \n            J_banded = np.zeros((3, num_interior))\n            J_banded[0, 1:] = J_offdiag\n            J_banded[1, :] = J_diag\n            J_banded[2, :-1] = J_offdiag\n            \n            # Solve the linear system J * delta = -F(v)\n            delta = solve_banded((1, 1), J_banded, -F_v)\n            v += delta\n        \n        y_n = v  # Update solution for next time step\n   \n    return y_n, total_newton_iters\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute metrics.\n    \"\"\"\n    test_cases = [\n        # (N, D, lambda, T, dt_imex, dt_imp)\n        (50, 0.01, 200, 0.02, 2e-5, 2e-4),\n        (70, 0.005, 700, 0.01, 1e-5, 2e-4),\n        (30, 0.02, 100, 0.05, 1e-4, 1e-3),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, D, lam, T, dt_imex, dt_imp = case\n        \n        # Run IMEX solver\n        y_imex_final = run_imex(N, D, lam, T, dt_imex)\n        \n        # Run Fully Implicit solver\n        y_imp_final, total_newton_iters = run_implicit(N, D, lam, T, dt_imp)\n        \n        # Metric 1: L2 norm of the difference\n        m1 = np.linalg.norm(y_imex_final - y_imp_final)\n        \n        # Metric 2: Ratio of time steps\n        m2 = dt_imp / dt_imex\n        \n        # Metric 3: Total Newton iterations\n        m3 = float(total_newton_iters)\n        \n        results.extend([m1, m2, m3])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "3159311"}]}