{"hands_on_practices": [{"introduction": "Crank-Nicolson (CN) 方法以其无条件稳定性而著称，但它有一个显著的缺点：当初始数据不光滑时（例如阶跃函数），它可能会产生非物理性的振荡。本练习将探讨这一现象，并研究一种实用的补救措施：在切换到更精确的 CN 方法之前，使用单个、更具耗散性的后向欧拉步骤来“抑制”初始的高频误差。这项实践对于开发稳健的数值求解器至关重要，它教你如何诊断和减轻数值格式中的常见伪影。[@problem_id:3115233]", "problem": "考虑在有限区间上定义的具有齐次 Dirichlet 边界条件的一维热扩散初边值问题。该物理模型是热扩散的偏微分方程，其中温度场满足 $u_t = \\alpha u_{xx}$，定义域为 $x \\in [0,L]$，时间为 $t \\ge 0$，边界条件为 $u(0,t) = 0$ 和 $u(L,t) = 0$，初始条件为 $u(x,0) = u_0(x)$。设 $u$ 为无量纲温度，$x$ 为以米为单位的位置，$t$ 为以秒为单位的时间，$L$ 为以米为单位的长度，$\\alpha$ 为以平方米/秒为单位的热扩散系数。\n\n从空间微分和时间积分梯形法则的基本定义出发，实现两种全隐式时间推进策略，以演化通过空间二阶中心差分得到的半离散系统：\n- 策略 A (纯 Crank–Nicolson)：从 $t=0$ 开始，在每个时间步应用梯形法则。\n- 策略 B (后向欧拉启动，后接 Crank–Nicolson)：应用一个初始的后向欧拉步（也称为隐式欧拉），然后在其后所有剩余步骤中切换到 Crank–Nicolson。\n\n空间网格应使用 $M$ 个点（包括两个边界），均匀分布，间距为 $\\Delta x = L/(M-1)$；只有内部未知数随时间推进。初始条件是一个矩形阶跃，定义为：当 $x \\in [0.4L, 0.6L]$ 时，$u_0(x) = 1$，否则 $u_0(x) = 0$，并通过 $u(0,0) = 0$ 和 $u(L,0) = 0$ 强制执行边界条件。这些值是无量纲的。\n\n在给定的最终时间 $T$，定义以下伪振荡的标量度量：构建包含两个边界值和内部解的完整向量，并令 $u_{\\max}$ 为其最大值，$u_{\\min}$ 为其最小值。由连续模型的极值原理以及初始和边界数据的选择所隐含的物理界限是 $0 \\le u \\le 1$。通过以下公式量化对这些界限的违反程度：\n$$\n\\mathcal{M} = \\max(0, u_{\\max} - 1) + \\max(0, 0 - u_{\\min}),\n$$\n这是一个非负实数。$\\mathcal{M}$ 的值越大，表示伪振荡越严重。对于每个测试用例，计算策略 A 下的 $\\mathcal{M}_{\\mathrm{CN}}$ 和策略 B 下的 $\\mathcal{M}_{\\mathrm{BE}\\rightarrow\\mathrm{CN}}$，并报告其减少量\n$$\nR = \\mathcal{M}_{\\mathrm{CN}} - \\mathcal{M}_{\\mathrm{BE}\\rightarrow\\mathrm{CN}}.\n$$\n正值 $R$ 表示单步后向欧拉启动减少了伪振荡。\n\n您的程序必须从第一性原理出发实现有限差分半离散模型和两种隐式时间积分器，确保使用科学上真实的参数。使用以下参数集测试套件，所有这些参数集都满足 $N_t = T/\\Delta t$ 是整数个时间步：\n- 测试 $1$：$\\alpha = 1.0\\,\\mathrm{m^2/s}$，$L = 1.0\\,\\mathrm{m}$，$M = 101$，$\\Delta t = 1\\times 10^{-4}\\,\\mathrm{s}$，$T = 2\\times 10^{-3}\\,\\mathrm{s}$。\n- 测试 $2$：$\\alpha = 1.0\\,\\mathrm{m^2/s}$，$L = 1.0\\,\\mathrm{m}$，$M = 101$，$\\Delta t = 1\\times 10^{-5}\\,\\mathrm{s}$，$T = 2\\times 10^{-4}\\,\\mathrm{s}$。\n- 测试 $3$：$\\alpha = 1.0\\,\\mathrm{m^2/s}$，$L = 1.0\\,\\mathrm{m}$，$M = 51$，$\\Delta t = 5\\times 10^{-4}\\,\\mathrm{s}$，$T = 1\\times 10^{-2}\\,\\mathrm{s}$。\n- 测试 $4$：$\\alpha = 1.0\\,\\mathrm{m^2/s}$，$L = 1.0\\,\\mathrm{m}$，$M = 101$，$\\Delta t = 1\\times 10^{-3}\\,\\mathrm{s}$，$T = 2\\times 10^{-2}\\,\\mathrm{s}$。\n\n对于每个测试用例，计算 $R$ 并将其表示为小数点后六位四舍五入的小数。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4]$），其中 $r_i$ 是测试 $i$ 的 $R$ 值。所有涉及物理单位的量必须完全按照规定进行解释；输出是无量纲的实数。", "solution": "所提出的问题是有效的，因为它在科学上基于热扩散和数值分析的原理，其定义和参数完整一致，表述客观，因此是一个适定问题。我们可以着手提供完整的解决方案。\n\n该问题要求实现并比较两种用于一维热方程 $u_t = \\alpha u_{xx}$ 的时间积分方案。我们将首先在空间上对该方程进行半离散化，然后将指定的时间推进方法应用于所得到的常微分方程组。\n\n控制偏微分方程 (PDE) 是：\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}\n$$\n对于位置 $x \\in [0, L]$ 和时间 $t \\ge 0$。该问题受齐次 Dirichlet 边界条件 $u(0,t) = 0$ 和 $u(L,t) = 0$ 以及不连续初始条件 $u(x,0) = u_0(x)$ 的约束，其中当 $x \\in [0.4L, 0.6L]$ 时 $u_0(x) = 1$，否则 $u_0(x) = 0$。\n\n**1. 空间离散化**\n\n我们首先将空间域 $[0,L]$ 离散化为 $M$ 个均匀分布的点 $x_j = j \\Delta x$，$j = 0, 1, \\dots, M-1$，其中网格间距为 $\\Delta x = L/(M-1)$。设 $u_j(t)$ 为 $u(x_j, t)$ 的数值近似。边界条件固定了 $u_0(t) = 0$ 和 $u_{M-1}(t) = 0$。求解针对 $M-2$ 个内部点，$j=1, 2, \\dots, M-2$。\n\n内部节点 $x_j$ 处的二阶空间导数 $u_{xx}$ 使用二阶中心差分格式进行近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x=x_j} \\approx \\frac{u_{j+1}(t) - 2u_j(t) + u_{j-1}(t)}{(\\Delta x)^2}\n$$\n将此式代入每个内部节点的热方程，得到一个包含 $M-2$ 个耦合常微分方程 (ODE) 的系统：\n$$\n\\frac{du_j}{dt} = \\frac{\\alpha}{(\\Delta x)^2} (u_{j-1} - 2u_j + u_{j+1}) \\quad \\text{for } j = 1, \\dots, M-2\n$$\n设 $\\mathbf{u}(t)$ 为内部未知数的列向量，$\\mathbf{u}(t) = [u_1(t), u_2(t), \\dots, u_{M-2}(t)]^T$。该常微分方程组可以写成矩阵形式：\n$$\n\\frac{d\\mathbf{u}}{dt} = A \\mathbf{u}(t)\n$$\n其中 $A$ 是一个 $(M-2) \\times (M-2)$ 的三对角矩阵，代表离散化的拉普拉斯算子，并按热扩散系数进行了缩放。给定齐次边界条件 ($u_0=0, u_{M-1}=0$)，矩阵 $A$ 为：\n$$\nA = \\frac{\\alpha}{(\\Delta x)^2}\n\\begin{pmatrix}\n-2  & 1  & 0  & \\cdots  & 0 \\\\\n1  & -2 & 1  & \\cdots  & 0 \\\\\n0  & \\ddots  & \\ddots & \\ddots  & 0 \\\\\n0  & \\cdots & 1  & -2 & 1 \\\\\n0  & \\cdots & 0  & 1  & -2\n\\end{pmatrix}\n$$\n\n**2. 时间积分**\n\n设 $\\mathbf{u}^n$ 为在时间 $t_n = n \\Delta t$ 时 $\\mathbf{u}(t)$ 的近似值。我们分析所要求的两种时间积分策略。\n\n**策略 A：纯 Crank-Nicolson**\n\nCrank-Nicolson 方法等效于对半离散系统 $\\frac{d\\mathbf{u}}{dt} = A\\mathbf{u}$ 应用梯形法则：\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2} (A \\mathbf{u}^n + A \\mathbf{u}^{n+1})\n$$\n重新整理各项以求解未知数 $\\mathbf{u}^{n+1}$：\n$$\n\\mathbf{u}^{n+1} - \\frac{\\Delta t}{2} A \\mathbf{u}^{n+1} = \\mathbf{u}^n + \\frac{\\Delta t}{2} A \\mathbf{u}^n\n$$\n$$\n\\left(I - \\frac{\\Delta t}{2} A\\right) \\mathbf{u}^{n+1} = \\left(I + \\frac{\\Delta t}{2} A\\right) \\mathbf{u}^n\n$$\n其中 $I$ 是单位矩阵。设扩散数 (diffusion number) 为 $s = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$。线性系统中的矩阵变为：\n- 左侧矩阵：$C_{\\text{mat}} = I - \\frac{\\Delta t}{2} A = I - \\frac{s}{2} \\text{Tridiag}(1, -2, 1)$，即三对角矩阵 $\\text{Tridiag}(-\\frac{s}{2}, 1+s, -\\frac{s}{2})$。\n- 右侧矩阵：$D_{\\text{mat}} = I + \\frac{\\Delta t}{2} A = I + \\frac{s}{2} \\text{Tridiag}(1, -2, 1)$，即三对角矩阵 $\\text{Tridiag}(\\frac{s}{2}, 1-s, \\frac{s}{2})$。\n\n在每个时间步，我们求解三对角线性系统 $C_{\\text{mat}} \\mathbf{u}^{n+1} = D_{\\text{mat}} \\mathbf{u}^n$ 以得到 $\\mathbf{u}^{n+1}$。\n\n**策略 B：后向欧拉启动，后接 Crank-Nicolson**\n\n此策略在第一个时间步使用不同的方法，以抑制由不连续初始条件引起的高频分量。\n\n- **步骤 1 (从 $t_0$ 到 $t_1$)：后向欧拉**\n后向（或隐式）欧拉方法为：\n$$\n\\frac{\\mathbf{u}^1 - \\mathbf{u}^0}{\\Delta t} = A \\mathbf{u}^1\n$$\n重新整理以求解 $\\mathbf{u}^1$：\n$$\n(I - \\Delta t A) \\mathbf{u}^1 = \\mathbf{u}^0\n$$\n系统矩阵为 $B_{\\text{mat}} = I - \\Delta t A = I - s \\cdot \\text{Tridiag}(1, -2, 1)$，即三对角矩阵 $\\text{Tridiag}(-s, 1+2s, -s)$。我们求解线性系统 $B_{\\text{mat}} \\mathbf{u}^1 = \\mathbf{u}^0$。\n\n- **后续步骤 (对于 $n \\ge 1$)：Crank-Nicolson**\n对于所有后续的时间步，我们回到策略 A 中描述的 Crank-Nicolson 格式：\n$$\nC_{\\text{mat}} \\mathbf{u}^{n+1} = D_{\\text{mat}} \\mathbf{u}^n \\quad \\text{for } n=1, 2, \\dots, N_t-1\n$$\n\n**3. 振荡度量与减少量**\n\n对于每种策略，在将解演化到最终时间 $T$ 后，我们得到内部未知数的向量 $\\mathbf{u}^{N_t}$。然后我们通过包含边界值来构造完整的解向量：$\\mathbf{u}_{\\text{full}} = [0, (\\mathbf{u}^{N_t})^T, 0]^T$。最大值 $u_{\\max}$ 和最小值 $u_{\\min}$ 从这个完整向量中找到。\n\n伪振荡的度量 $\\mathcal{M}$ 量化了对极值原理界限 $[0, 1]$ 的违反程度：\n$$\n\\mathcal{M} = \\max(0, u_{\\max} - 1) + \\max(0, 0 - u_{\\min})\n$$\n我们为策略 A ($\\mathcal{M}_{\\mathrm{CN}}$) 和策略 B ($\\mathcal{M}_{\\mathrm{BE}\\rightarrow\\mathrm{CN}}$) 计算此度量。每个测试用例的最终结果是振荡的减少量：\n$$\nR = \\mathcal{M}_{\\mathrm{CN}} - \\mathcal{M}_{\\mathrm{BE}\\rightarrow\\mathrm{CN}}\n$$\n$R$ 的正值表示单步后向欧拉启动成功地减轻了纯 Crank-Nicolson 格式中存在的伪振荡。实现过程将涉及建立三对角矩阵，并在每个时间步使用高效的线性求解器。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef compute_reduction(alpha: float, L: float, M: int, dt: float, T: float) -> float:\n    \"\"\"\n    Solves the 1D heat equation using two different time-marching strategies\n    and computes the reduction in spurious oscillations.\n\n    Args:\n        alpha: Thermal diffusivity (m^2/s).\n        L: Length of the domain (m).\n        M: Number of spatial grid points.\n        dt: Time step size (s).\n        T: Final time (s).\n\n    Returns:\n        The reduction R = M_CN - M_BE_CN, rounded to 6 decimal places.\n    \"\"\"\n    # 1. Setup Grid and Parameters\n    dx = L / (M - 1)\n    x = np.linspace(0, L, M)\n    Nt = int(round(T / dt))\n    num_interior = M - 2\n    \n    # Dimensionless diffusion number\n    s = alpha * dt / (dx**2)\n\n    # 2. Initial Condition\n    u0_full = np.zeros(M)\n    u0_full[(x >= 0.4 * L) & (x <= 0.6 * L)] = 1.0\n    # Boundary conditions u(0,t)=0 and u(L,t)=0 are already set by np.zeros\n    u0_interior = u0_full[1:-1]\n\n    # 3. Strategy A: Pure Crank-Nicolson\n    # System: C_mat * u^{n+1} = D_mat * u^n\n    # C_mat = Tridiag(-s/2, 1+s, -s/2)\n    # D_mat = Tridiag(s/2, 1-s, s/2)\n    \n    # Matrix for the left-hand side (banded format for scipy)\n    C_mat_banded = np.zeros((3, num_interior))\n    C_mat_banded[0, 1:] = -s / 2.0  # Super-diagonal\n    C_mat_banded[1, :] = 1.0 + s      # Main diagonal\n    C_mat_banded[2, :-1] = -s / 2.0 # Sub-diagonal\n\n    # Diagonals for the right-hand side matrix D_mat\n    D_mat_main_diag = 1.0 - s\n    D_mat_off_diag = s / 2.0\n\n    u_cn = u0_interior.copy()\n    for _ in range(Nt):\n        # Build RHS vector: b = D_mat * u_cn\n        b = np.zeros(num_interior)\n        if num_interior > 1:\n            b[1:-1] = (D_mat_off_diag * u_cn[:-2] +\n                       D_mat_main_diag * u_cn[1:-1] +\n                       D_mat_off_diag * u_cn[2:])\n            b[0] = D_mat_main_diag * u_cn[0] + D_mat_off_diag * u_cn[1]\n            b[-1] = D_mat_main_diag * u_cn[-1] + D_mat_off_diag * u_cn[-2]\n        elif num_interior == 1:\n            b[0] = D_mat_main_diag * u_cn[0]\n\n        # Solve C_mat * u_n+1 = b for u_n+1\n        u_cn = solve_banded((1, 1), C_mat_banded, b)\n\n    u_full_cn = np.concatenate(([0], u_cn, [0]))\n    u_max_cn = np.max(u_full_cn)\n    u_min_cn = np.min(u_full_cn)\n    M_cn = max(0, u_max_cn - 1.0) + max(0, -u_min_cn)\n\n    # 4. Strategy B: Backward Euler start-up, then Crank-Nicolson\n    \n    # First step: Backward Euler\n    # System: B_mat * u^1 = u^0\n    # B_mat = Tridiag(-s, 1+2s, -s)\n    B_mat_banded = np.zeros((3, num_interior))\n    B_mat_banded[0, 1:] = -s\n    B_mat_banded[1, :] = 1.0 + 2.0 * s\n    B_mat_banded[2, :-1] = -s\n    \n    u_be_cn = solve_banded((1, 1), B_mat_banded, u0_interior)\n\n    # Subsequent steps: Crank-Nicolson\n    if Nt > 1:\n        for _ in range(Nt - 1):\n            b = np.zeros(num_interior)\n            if num_interior > 1:\n                b[1:-1] = (D_mat_off_diag * u_be_cn[:-2] +\n                           D_mat_main_diag * u_be_cn[1:-1] +\n                           D_mat_off_diag * u_be_cn[2:])\n                b[0] = D_mat_main_diag * u_be_cn[0] + D_mat_off_diag * u_be_cn[1]\n                b[-1] = D_mat_main_diag * u_be_cn[-1] + D_mat_off_diag * u_be_cn[-2]\n            elif num_interior == 1:\n                b[0] = D_mat_main_diag * u_be_cn[0]\n\n            u_be_cn = solve_banded((1, 1), C_mat_banded, b)\n\n    u_full_be_cn = np.concatenate(([0], u_be_cn, [0]))\n    u_max_be_cn = np.max(u_full_be_cn)\n    u_min_be_cn = np.min(u_full_be_cn)\n    M_be_cn = max(0, u_max_be_cn - 1.0) + max(0, -u_min_be_cn)\n\n    # 5. Calculate Reduction R\n    R = M_cn - M_be_cn\n    return round(R, 6)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (alpha, L, M, dt, T)\n        (1.0, 1.0, 101, 1e-4, 2e-3),\n        (1.0, 1.0, 101, 1e-5, 2e-4),\n        (1.0, 1.0, 51, 5e-4, 1e-2),\n        (1.0, 1.0, 101, 1e-3, 2e-2),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, L, M, dt, T = case\n        result = compute_reduction(alpha, L, M, dt, T)\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3115233"}, {"introduction": "现实世界中的扩散过程通常发生在非均匀材料中，其中扩散系数随空间变化。标准的有限差分法可能难以在材料界面上保持物理守恒律。这个问题将指导你在一个守恒的有限体积框架内实现 Crank-Nicolson 格式，并使用调和平均法计算界面扩散率以确保通量守恒。这项动手练习展示了如何正确地为具有可变属性的系统建模，这是计算物理和工程学中的一项基本技能，并验证了质量守恒这一关键属性。[@problem_id:3115317]", "problem": "考虑周期性域上的一维扩散方程，由守恒律 $u_t = \\partial_x \\left( D(x) \\, u_x \\right)$ 给出，其中 $x \\in [0,L]$，$t \\ge 0$，$u(x,t)$ 是标量场，$D(x)$ 是严格为正且空间变化的扩散系数。该问题的基本依据是每个控制体积上的积分守恒形式、散度定理和通量的定义。使用有限体积法进行离散化，包含 $N$ 个宽度为 $\\Delta x = L/N$ 的均匀单元，单元中心为 $x_j = (j+1/2)\\Delta x$，$j = 0,1,\\dots,N-1$。令 $U_j^n$ 表示在时间层 $t_n = n \\,\\Delta t$ 时对 $u(x,t_n)$ 的单元平均近似。\n\n您的任务是推导并实现一种在离散层面保持通量守恒的 Crank–Nicolson (CN) 隐式方法。按以下步骤进行：\n\n1. 从控制体积 $V_j = [x_{j-1/2}, x_{j+1/2}]$ 上的积分守恒形式出发：\n   $$\\frac{d}{dt} \\int_{V_j} u(x,t)\\,dx = \\left. - D(x) \\, u_x(x,t) \\right|_{x_{j-1/2}}^{x_{j+1/2}}.$$\n   使用散度定理和扩散通量的定义来证明此方程。定义面通量 $F_{j+1/2}(t) = - D_{j+1/2} \\, \\left. u_x \\right|_{x_{j+1/2}}$ 和 $F_{j-1/2}(t) = - D_{j-1/2} \\, \\left. u_x \\right|_{x_{j-1/2}}$，使得\n   $$\\frac{d U_j}{dt} = \\frac{F_{j+1/2}(t) - F_{j-1/2}(t)}{\\Delta x},$$\n   其中 $U_j(t) = \\frac{1}{\\Delta x} \\int_{V_j} u(x,t)\\,dx$。\n\n2. 使用能确保通量守恒的一致二阶有限体积近似对空间上的面通量进行离散化：\n   - 用中心差分近似面梯度：\n     $$\\left. u_x \\right|_{x_{j+1/2}} \\approx \\frac{U_{j+1} - U_j}{\\Delta x}.$$\n   - 使用单元中心值 $D_j = D(x_j)$ 和 $D_{j+1} = D(x_{j+1})$ 的调和平均来定义面扩散系数：\n     $$D_{j+1/2} = \\frac{2}{\\frac{1}{D_j} + \\frac{1}{D_{j+1}}}.$$\n   当 $D(x)$ 可变时，这种选择是串联传导的标准做法，并能确保跨界面的通量一致。\n\n3. 使用上述空间离散格式，将半离散系统写成以下形式\n   $$\\frac{d U_j}{dt} = \\frac{-D_{j+1/2}\\,(U_{j+1} - U_j) + D_{j-1/2}\\,(U_j - U_{j-1})}{\\Delta x^2},$$\n   其中周期性边界条件为 $U_{-1} \\equiv U_{N-1}$，$U_N \\equiv U_0$。将其表示为作用于向量 $\\mathbf{U} = (U_0,\\dots,U_{N-1})^\\top$ 的线性算子 $\\mathbf{L}$：\n   $$\\frac{d \\mathbf{U}}{dt} = \\mathbf{L} \\, \\mathbf{U}.$$\n\n4. 应用 Crank–Nicolson 时间离散格式，得到一个全离散方法：\n   $$\\frac{\\mathbf{U}^{n+1} - \\mathbf{U}^n}{\\Delta t} = \\frac{1}{2}\\left( \\mathbf{L}\\,\\mathbf{U}^{n+1} + \\mathbf{L}\\,\\mathbf{U}^{n} \\right),$$\n   这导出了线性系统\n   $$\\left( \\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{L} \\right)\\mathbf{U}^{n+1} = \\left( \\mathbf{I} + \\frac{\\Delta t}{2}\\mathbf{L} \\right)\\mathbf{U}^{n}.$$\n   此处，$\\mathbf{I}$ 是大小为 $N \\times N$ 的单位矩阵。\n\n5. 通过在单元中心 $x_j$ 处对 $u(x,0)$ 采样来初始化 $U_j^0$。在本作业中，所有三角函数必须使用以弧度为单位的角度。\n\n验证要求：\n- 在使用周期性边界条件的粗网格上，通过多个 CN 时间步长，验证总质量 $M^n = \\sum_{j=0}^{N-1} U_j^n \\,\\Delta x$ 的离散守恒性。具体来说，验证 $|M^{\\text{final}} - M^0| < \\tau$，容差为 $\\tau = 10^{-10}$。\n\n实现一个完整的程序，该程序通过使用调和平均面扩散系数的有限体积通量差分来构造 $\\mathbf{L}$，执行 CN 时间步进，并对以下测试集检查离散质量守恒。所有域的长度均为 $L = 1$ 并使用周期性边界条件：\n\n- 测试用例 1 (标准情况)：$N = 4$，$\\Delta t = 0.2$，步数 $= 8$，$D(x) \\equiv 1$，初始条件 $u(x,0) = 1 + \\sin(2\\pi x)$。\n- 测试用例 2 (可变扩散)：$N = 5$，$\\Delta t = 0.15$，步数 $= 12$，$D(x) = 1 + 0.5 \\sin(2\\pi x)$，初始条件 $u(x,0) = 0.8 + \\cos(2\\pi x)$。\n- 测试用例 3 (不连续扩散)：$N = 3$，$\\Delta t = 0.5$，步数 $= 5$，分段扩散 $D(x) = 0.1$ 对于 $x \\in [0,0.5)$ 且 $D(x) = 1.0$ 对于 $x \\in [0.5,1)$，初始条件 $u(x,0) = 1.2 + \\sin(4\\pi x)$。\n\n所有角度均以弧度为单位。您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，列表中的每个条目都是一个布尔值，指示相应测试用例的质量守恒是否得到验证，例如 $[{\\text{result}_1},{\\text{result}_2},{\\text{result}_3}]$。", "solution": "该问题要求针对周期性域 $x \\in [0,L]$ 上具有空间变化扩散系数的一维扩散方程 $u_t = \\partial_x ( D(x) \\, u_x )$，推导并实现一种保通量的 Crank-Nicolson 隐式方法。求解过程将遵循指定步骤构建，以确保其在有限体积法和数值线性代数原理方面有坚实的理论基础。\n\n守恒数值格式的基础是守恒律的积分形式。对于任意控制体积 $V_j = [x_{j-1/2}, x_{j+1/2}]$，体积内物理量 $u$ 的总量变化率等于穿过其边界的净通量。将偏微分方程在 $V_j$ 上积分可得：\n$$ \\frac{d}{dt} \\int_{x_{j-1/2}}^{x_{j+1/2}} u(x,t) \\, dx = \\int_{x_{j-1/2}}^{x_{j+1/2}} \\partial_x \\left( D(x) \\, u_x \\right) \\, dx $$\n对右侧应用微积分基本定理（一维散度定理）可得到通量差：\n$$ \\frac{d}{dt} \\int_{x_{j-1/2}}^{x_{j+1/2}} u(x,t) \\, dx = \\left. D(x) \\, u_x(x,t) \\right|_{x_{j-1/2}}^{x_{j+1/2}} $$\n将扩散通量定义为 $F(x,t) = -D(x) \\, u_x(x,t)$，我们可以将其写为：\n$$ \\frac{d}{dt} \\int_{V_j} u(x,t) \\, dx = F(x_{j-1/2}, t) - F(x_{j+1/2}, t) = -\\left. F(x,t)\\right|_{x_{j-1/2}}^{x_{j+1/2}} $$\n在考虑了通量的符号约定后，这与问题的第一个方程相匹配。令 $U_j(t) = \\frac{1}{\\Delta x} \\int_{V_j} u(x,t) \\, dx$ 为 $u$ 在宽度为 $\\Delta x = L/N$ 的单元 $V_j$ 上的单元平均值。那么，单元平均值的时间演化由以下半离散方程给出：\n$$ \\frac{d U_j}{dt} = \\frac{F_{j+1/2}(t) - F_{j-1/2}(t)}{\\Delta x} $$\n其中 $F_{j \\pm 1/2}(t)$ 是在单元面 $x_{j \\pm 1/2}$ 处计算的通量。这种形式保证了离开单元 $V_j$ 并穿过面 $x_{j+1/2}$ 的通量与进入相邻单元 $V_{j+1}$ 的通量相同，从而确保了离散守恒。\n\n为了在空间上完全离散化，我们必须对通量进行近似。在面 $x_{j+1/2}$ 处的通量为 $F_{j+1/2} = - D_{j+1/2} \\, \\left. u_x \\right|_{x_{j+1/2}}$，其中 $D_{j+1/2}$ 是单元面上的扩散系数。基于单元平均值 $U_j$ 和 $U_{j+1}$，面上梯度的二阶精度中心差分近似为：\n$$ \\left. u_x \\right|_{x_{j+1/2}} \\approx \\frac{U_{j+1} - U_j}{\\Delta x} $$\n对于空间变化的 $D(x)$，必须仔细选择 $D_{j+1/2}$ 的值以保持物理一致性。问题指定了使用单元中心扩散系数 $D_j = D(x_j)$ 和 $D_{j+1} = D(x_{j+1})$ 的调和平均值：\n$$ D_{j+1/2} = \\frac{2 D_j D_{j+1}}{D_j + D_{j+1}} = \\left( \\frac{1/D_j + 1/D_{j+1}}{2} \\right)^{-1} $$\n这一选择的物理动机是考虑通过两个串联层的稳态扩散，其中有效热导率（或扩散率）由各层电导率的调和平均值导出。它能正确确保通量的连续性，尤其是在 $D(x)$ 的急剧变化界面处。\n\n将这些空间近似代入半离散方程可得：\n$$ \\frac{d U_j}{dt} = \\frac{1}{\\Delta x} \\left[ -D_{j+1/2} \\frac{U_{j+1} - U_j}{\\Delta x} - \\left(-D_{j-1/2} \\frac{U_j - U_{j-1}}{\\Delta x}\\right) \\right] $$\n$$ \\frac{d U_j}{dt} = \\frac{1}{\\Delta x^2} \\left[ D_{j-1/2}U_{j-1} - (D_{j+1/2} + D_{j-1/2})U_j + D_{j+1/2}U_{j+1} \\right] $$\n这个常微分方程组可以表示为矩阵形式 $\\frac{d\\mathbf{U}}{dt} = \\mathbf{L}\\mathbf{U}$，其中 $\\mathbf{U} = (U_0, U_1, \\dots, U_{N-1})^\\top$ 且 $\\mathbf{L}$ 是一个 $N \\times N$ 矩阵。对于单元 $j$，$\\mathbf{L}$ 的第 $j$ 行中的非零项为：\n$$ L_{j, j-1} = \\frac{D_{j-1/2}}{\\Delta x^2}, \\quad L_{j, j} = -\\frac{D_{j+1/2} + D_{j-1/2}}{\\Delta x^2}, \\quad L_{j, j+1} = \\frac{D_{j+1/2}}{\\Delta x^2} $$\n周期性边界条件（$U_{-1} \\equiv U_{N-1}$，$U_N \\equiv U_0$）要求索引在模 $N$ 的意义下进行解释。这使得 $\\mathbf{L}$ 成为一个循环三对角矩阵。这种构造的一个重要性质是 $\\mathbf{L}$ 的每行元素之和为零，这意味着 $\\mathbf{L}$ 会零化常数向量。此外，详细分析表明 $\\mathbf{L}$ 的每列元素之和也为零。这意味着 $\\mathbf{v}^\\top \\mathbf{L} = \\mathbf{0}^\\top$，其中 $\\mathbf{v}^\\top = (1, 1, \\dots, 1)$，这个性质保证了总质量的离散守恒，因为 $\\frac{d}{dt} \\sum_j U_j = \\sum_j (\\mathbf{L}\\mathbf{U})_j = (\\mathbf{v}^\\top \\mathbf{L}) \\mathbf{U} = 0$。\n\n对于时间离散化，我们应用 Crank-Nicolson 方法，该方法对扩散方程是时间二阶精确且无条件稳定的。它对当前时间层 $t_n$ 和下一个时间层 $t_{n+1}$ 的空间算子 $\\mathbf{L}$ 进行平均：\n$$ \\frac{\\mathbf{U}^{n+1} - \\mathbf{U}^n}{\\Delta t} = \\frac{1}{2} \\left( \\mathbf{L}\\mathbf{U}^{n+1} + \\mathbf{L}\\mathbf{U}^{n} \\right) $$\n其中 $\\mathbf{U}^n$ 是时间 $t_n = n \\Delta t$ 时的数值解向量。重新整理各项以求解未知状态 $\\mathbf{U}^{n+1}$，可得到以下线性系统：\n$$ \\mathbf{U}^{n+1} - \\frac{\\Delta t}{2}\\mathbf{L}\\mathbf{U}^{n+1} = \\mathbf{U}^{n} + \\frac{\\Delta t}{2}\\mathbf{L}\\mathbf{U}^{n} $$\n$$ \\left( \\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{L} \\right) \\mathbf{U}^{n+1} = \\left( \\mathbf{I} + \\frac{\\Delta t}{2}\\mathbf{L} \\right) \\mathbf{U}^{n} $$\n在每个时间步，我们构造矩阵 $\\mathbf{A} = \\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{L}$ 和 $\\mathbf{B} = \\mathbf{I} + \\frac{\\Delta t}{2}\\mathbf{L}$，计算右侧向量 $\\mathbf{b} = \\mathbf{B}\\mathbf{U}^n$，并使用标准线性求解器求解线性系统 $\\mathbf{A}\\mathbf{U}^{n+1} = \\mathbf{b}$。该格式保留了半离散化的质量守恒性质，如通过左乘 $\\mathbf{v}^\\top$ 所示：\n$$ \\mathbf{v}^\\top \\left( \\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{L} \\right) \\mathbf{U}^{n+1} = \\mathbf{v}^\\top \\left( \\mathbf{I} + \\frac{\\Delta t}{2}\\mathbf{L} \\right) \\mathbf{U}^{n} $$\n由于 $\\mathbf{v}^\\top \\mathbf{L} = \\mathbf{0}^\\top$，这可以简化为 $\\mathbf{v}^\\top \\mathbf{U}^{n+1} = \\mathbf{v}^\\top \\mathbf{U}^{n}$，从而证实了 $\\sum_j U_j^{n+1} = \\sum_j U_j^n$。因此，总质量 $M^n = \\sum_j U_j^n \\Delta x$ 在各个时间步之间是守恒的，仅因浮点精度误差而有所不同。\n\n实现时将首先通过在单元中心 $x_j = (j+1/2)\\Delta x$ 处对给定的初始条件 $u(x,0)$ 进行采样来初始化解向量 $\\mathbf{U}^0$。然后，它将基于单元中心的 $D(x)$ 值的调和平均值来构造矩阵 $\\mathbf{L}$。最后，它将循环遍历所需的时间步数，在每一步求解线性系统。通过将初始质量 $M^0$ 与最终质量 $M^{\\text{final}}$ 对比，并与指定的容差 $\\tau = 10^{-10}$ 进行比较，来验证总质量 $M^n$ 的守恒性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D diffusion equation using a Crank-Nicolson finite-volume scheme\n    and verifies mass conservation for a suite of test cases.\n    \"\"\"\n    \n    # Define test cases as specified in the problem statement\n    test_cases = [\n        {\n            \"N\": 4, \"dt\": 0.2, \"steps\": 8, \"L\": 1.0,\n            \"D_func\": lambda x: np.ones_like(x),\n            \"u_init_func\": lambda x: 1.0 + np.sin(2 * np.pi * x)\n        },\n        {\n            \"N\": 5, \"dt\": 0.15, \"steps\": 12, \"L\": 1.0,\n            \"D_func\": lambda x: 1.0 + 0.5 * np.sin(2 * np.pi * x),\n            \"u_init_func\": lambda x: 0.8 + np.cos(2 * np.pi * x)\n        },\n        {\n            \"N\": 3, \"dt\": 0.5, \"steps\": 5, \"L\": 1.0,\n            \"D_func\": lambda x: np.piecewise(x, [x % 1.0 < 0.5, x % 1.0 >= 0.5], [0.1, 1.0]),\n            \"u_init_func\": lambda x: 1.2 + np.sin(4 * np.pi * x)\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N = case[\"N\"]\n        dt = case[\"dt\"]\n        num_steps = case[\"steps\"]\n        L = case[\"L\"]\n        D_func = case[\"D_func\"]\n        u_init_func = case[\"u_init_func\"]\n        \n        # 1. Define grid and initialize state vector U\n        dx = L / N\n        # Cell centers\n        x_j = (np.arange(N) + 0.5) * dx\n        \n        # Initial condition\n        U_current = u_init_func(x_j)\n        \n        # 2. Calculate initial total mass\n        M_initial = np.sum(U_current) * dx\n        \n        # 3. Construct the spatial operator L\n        # Cell-centered diffusion coefficients\n        D_j = D_func(x_j)\n        \n        # Face diffusion coefficients using harmonic mean\n        # D_face[j] stores D_{j+1/2} (interface between cell j and j+1)\n        # np.roll(D_j, -1) handles periodic boundary for D_{j+1}\n        D_j_plus_1 = np.roll(D_j, -1)\n        # Avoid division by zero if D_j + D_j_plus_1 is zero, although D(x) > 0\n        D_face = np.divide(2 * D_j * D_j_plus_1, D_j + D_j_plus_1, \n                           out=np.zeros_like(D_j), where=(D_j + D_j_plus_1) != 0)\n\n        # Construct L matrix\n        L_matrix = np.zeros((N, N))\n        inv_dx2 = 1.0 / (dx * dx)\n        for j in range(N):\n            # D_{j+1/2} is at the right face of cell j\n            D_plus_half = D_face[j]\n            # D_{j-1/2} is at the left face of cell j (which is right face of cell j-1)\n            D_minus_half = D_face[(j - 1 + N) % N]\n            \n            # Indices for periodic boundaries\n            j_minus_1 = (j - 1 + N) % N\n            j_plus_1 = (j + 1) % N\n            \n            # Fill the j-th row of L\n            L_matrix[j, j_minus_1] = D_minus_half * inv_dx2\n            L_matrix[j, j] = -(D_plus_half + D_minus_half) * inv_dx2\n            L_matrix[j, j_plus_1] = D_plus_half * inv_dx2\n            \n        # 4. Construct Crank-Nicolson system matrices A and B\n        I = np.identity(N)\n        A = I - (dt / 2.0) * L_matrix\n        B = I + (dt / 2.0) * L_matrix\n        \n        # 5. Perform time stepping\n        for _ in range(num_steps):\n            # Calculate right-hand side: b = B * U^n\n            rhs = B @ U_current\n            # Solve for next time step: A * U^{n+1} = b\n            U_next = np.linalg.solve(A, rhs)\n            U_current = U_next\n            \n        # 6. Calculate final total mass\n        M_final = np.sum(U_current) * dx\n        \n        # 7. Verify mass conservation\n        conservation_tolerance = 1e-10\n        is_conserved = np.abs(M_final - M_initial) < conservation_tolerance\n        results.append(is_conserved)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3115317"}, {"introduction": "许多高级科学问题涉及不同物理域的相互作用和耦合，例如两种连接材料之间的热传递。求解此类系统需要我们将数值方法扩展到处理分块结构的矩阵。本练习要求你为一个耦合扩散系统构建一个分块 Crank-Nicolson 格式，并通过计算增长算子的谱半径 $\\rho$ 来分析其稳定性。通过解决这个问题，你将学习如何将隐式方法应用于耦合系统，并使用强大的线性代数工具来分析复杂多域数值算法的稳定性。[@problem_id:3115280]", "problem": "本题要求您推导并实现一个全耦合分块 Crank–Nicolson (CN) 格式，用于求解代表两种材料共享一个界面的​​一维耦合扩散系统，并通过计算单步放大算子的谱半径来研究其耦合稳定性。整个过程完全使用无量纲变量，不涉及物理单位。\n\n从以下基本概念出发：\n- 在具有空间变化的热扩散系数的一维杆中，热量扩散由偏微分方程 (PDE) $\\partial_t u(x,t) = \\partial_x \\left( \\alpha(x) \\, \\partial_x u(x,t) \\right)$ 建模，其中 $u(x,t)$ 是温度场，$\\alpha(x) \\ge 0$ 是热扩散系数。\n- 在内部区域，使用间距为 $h$ 的均匀网格进行守恒有限差分（或等效的有限体积）半离散化，得到一个常微分方程 (ODE) 系统 $\\frac{d\\mathbf{u}}{dt} = A \\, \\mathbf{u}$，其中 $A$ 是一个三对角矩阵。该矩阵通过使用面心通量构建，并在面上采用调和平均的扩散系数，以保证在材料界面上温度和热通量的连续性。\n- Crank–Nicolson (CN) 方法是一种时间积分器，定义为将梯形法则应用于半离散 ODE，为齐次问题生成形如 $\\left(I - \\frac{\\Delta t}{2} A\\right) \\mathbf{u}^{n+1} = \\left(I + \\frac{\\Delta t}{2} A\\right) \\mathbf{u}^{n}$ 的线性单步法。\n\n问题设置：\n- 考虑区域 $x \\in [0,L]$，其中 $L = L_1 + L_2$。左子区域 $[0,L_1]$ 为材料 1，其扩散系数为常数 $\\alpha_1$；右子区域 $[L_1, L]$ 为材料 2，其扩散系数为常数 $\\alpha_2$。\n- 施加齐次 Dirichlet 边界条件 $u(0,t)=0$ 和 $u(L,t)=0$。\n- 使用一个包含 $N$ 个内部节点、间距为 $h = \\frac{L}{N+1}$ 的均匀网格，并假设选择的 $N$ 使得界面位置 $x=L_1$ 与一个网格节点重合，即 $k = \\frac{(N+1)L_1}{L}$ 是一个满足 $1 \\le k \\le N$ 的整数。这将半离散未知向量分裂为分块形式 $\\mathbf{u} = \\begin{bmatrix} \\mathbf{u}_1 \\\\ \\mathbf{u}_2 \\end{bmatrix}$，其中 $\\mathbf{u}_1 \\in \\mathbb{R}^{k}$ 对应于材料 1 中的节点（包括界面节点），而 $\\mathbf{u}_2 \\in \\mathbb{R}^{N-k}$ 对应于材料 2 中的节点。\n- 使用守恒面通量形式，为具有分段常数 $\\alpha(x)$ 和齐次 Dirichlet 边界的半离散算子 $\\partial_x(\\alpha \\partial_x u)$ 构建三对角矩阵 $A \\in \\mathbb{R}^{N \\times N}$。对于每个内部节点索引 $i \\in \\{1,\\dots,N\\}$（为便于说明，此处使用基于 1 的索引），通过在每个面上进行调和平均来定义面系数 $\\alpha_{i+1/2}$ 和 $\\alpha_{i-1/2}$：\n  $$ \\alpha_{i+1/2} = \\begin{cases}\n  \\alpha_1  &\\text{若面完全位于材料 1 内部,} \\\\\n  \\alpha_2  &\\text{若面完全位于材料 2 内部,} \\\\\n  \\dfrac{2 \\alpha_1 \\alpha_2}{\\alpha_1 + \\alpha_2}  &\\text{若面与界面重合,}\n  \\end{cases} $$\n  $\\alpha_{i-1/2}$ 的定义类似。那么节点 $i$ 处的离散算子为\n  $$ (A \\mathbf{u})_i = \\frac{1}{h^2} \\left( \\alpha_{i+1/2} (u_{i+1} - u_i) - \\alpha_{i-1/2} (u_i - u_{i-1}) \\right), $$\n  其中 $u_0 = 0$ 和 $u_{N+1} = 0$ 由 Dirichlet 边界条件强制施加。这确保了界面处的温度和通量连续性。\n- 使用界面分割索引 $k$ 将 $A$ 分块：$A = \\begin{bmatrix} A_{11} & A_{12} \\\\ A_{21} & A_{22} \\end{bmatrix}$。\n\n任务：\n1. 使用带有调和平均的守恒面通量离散化方法，从第一性原理推导耦合系统的半离散矩阵 $A$。解释为什么这种方法能够在不增加额外未知数的情况下，保证界面处温度和热通量的连续性。\n2. 推导齐次系统的整体式 Crank–Nicolson 单步放大算子 $G$，该算子将 $\\mathbf{u}^n$ 映射到 $\\mathbf{u}^{n+1}$。请仅用先前步骤中精确定义的 $A$、时间步长 $\\Delta t$ 和单位矩阵 $I$ 来表示它。\n3. 考虑一种分块迭代变体，其中材料内部的块被隐式处理，而材料间的耦合则通过从 $\\mathbf{u}^{n+1,(0)} = \\mathbf{u}^n$ 开始的单次 Jacobi 迭代来处理。请仅使用 $A_{11}$、$A_{22}$、$A_{12}$、$A_{21}$、$\\Delta t$ 和分块单位矩阵，以分块形式推导相应的将 $\\mathbf{u}^n$ 映射到 $\\mathbf{u}^{n+1}$ 的单次迭代分块放大算子 $J$。清晰地陈述所使用的任何线性代数步骤。\n4. 对于每个算子 $X \\in \\{G, J\\}$，将谱半径 $\\rho(X)$ 定义为其特征值的最大模，并解释为什么它是评估应用于齐次系统的单步法线性稳定性的一个有用指标。\n\n编程要求：\n- 在一个程序中实现上述推导的矩阵 $A$ 的构建以及 $\\rho(G)$ 和 $\\rho(J)$ 的计算。\n- 使用以下固定的测试套件，其中区域长度 $L_1 = 1$，$L_2 = 1$，总长度 $L = 2$，并通过选择奇数 $N$ 以使 $k = \\frac{N+1}{2}$ 来对齐界面：\n  - 测试 1（整体式 CN，理想情况）：$\\alpha_1 = 1$，$\\alpha_2 = 10$，$N=41$，$\\Delta t = 2.0$；计算 $\\rho(G)$。\n  - 测试 2（整体式 CN，极大时间步长）：$\\alpha_1 = 1$，$\\alpha_2 = 100$，$N=81$，$\\Delta t = 50.0$；计算 $\\rho(G)$。\n  - 测试 3（单次迭代分块-Jacobi CN，强对比度和大时间步长）：$\\alpha_1 = 1$，$\\alpha_2 = 100$，$N=41$，$\\Delta t = 200.0$；计算 $\\rho(J)$。\n  - 测试 4（单次迭代分块-Jacobi CN，小时间步长边界情况）：$\\alpha_1 = 0.5$，$\\alpha_2 = 2.0$，$N=21$，$\\Delta t = 0.1$；计算 $\\rho(J)$。\n- 您的程序必须为每个测试用例计算谱半径（作为一个浮点数），并按顺序汇总这四个结果。\n- 最终输出格式：您的程序应生成单行文本，其中包含一个 Python 风格的列表，内含四个谱半径值，每个值都四舍五入到小数点后恰好六位，不得包含任何额外文本。例如，输出行的形式为 $\\left[ r_1, r_2, r_3, r_4 \\right]$，其中每个 $r_i$ 都打印出小数点后恰好六位。\n\n约束和说明：\n- 仅使用从推导出的公式中明确定义的线性代数运算；不要使用任何预先计算好的稳定性公式。\n- 不涉及角度，也没有物理单位；所有量都是无量纲的。\n- 确保您的实现通过使用奇数 $N$ 以使 $k = \\frac{N+1}{2}$ 为整数，从而遵守界面对齐约束。", "solution": "所述问题具有科学依据、是适定的且内容自洽。它提出了一个计算科学中标准而全面的问题，要求为耦合 PDE 系统推导和实现一个数值格式，并分析其稳定性。所有参数和方法都得到了明确定义，从而可以得到唯一且可验证的解。\n\n### 任务 1：半离散矩阵 $A$ 的推导与通量连续性\n\n控制偏微分方程 (PDE) 为 $\\partial_t u = \\partial_x (\\alpha(x) \\partial_x u)$。将此方程在一个以网格节点 $x_i$ 为中心、范围从 $x_{i-1/2} = x_i - h/2$ 到 $x_{i+1/2} = x_i + h/2$ 的控制体积（或单元）上积分，其中 $h$ 是均匀的网格间距，可得：\n$$ \\int_{x_{i-1/2}}^{x_{i+1/2}} \\partial_t u \\, dx = \\int_{x_{i-1/2}}^{x_{i+1/2}} \\partial_x (\\alpha(x) \\partial_x u) \\, dx $$\n用节点值 $u_i(t) = u(x_i, t)$ 的时间导数来近似单元平均值 $\\bar{u}_i(t) = \\frac{1}{h} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) dx$ 的时间导数，我们得到 $h \\frac{du_i}{dt}$。根据微积分基本定理，右侧是单元面上的通量 $F(x,t) = -\\alpha(x) \\partial_x u(x,t)$ 之差：\n$$ \\int_{x_{i-1/2}}^{x_{i+1/2}} \\partial_x (-\\alpha(x) \\partial_x u) \\, dx = -[F(x_{i+1/2}) - F(x_{i-1/2})] = F(x_{i-1/2}) - F(x_{i+1/2}) $$\n通过近似这些通量，可以得到有限差分半离散化。对于节点 $i$ 和 $i+1$ 之间位于 $x_{i+1/2}$ 的面，通量近似为 $F_{i+1/2} \\approx -\\alpha_{i+1/2} \\frac{u_{i+1} - u_i}{h}$。将这些结合起来，得到每个内部节点 $i$ 的半离散 ODE：\n$$ \\frac{du_i}{dt} = \\frac{1}{h} (F_{i-1/2} - F_{i+1/2}) \\approx \\frac{1}{h} \\left( -\\alpha_{i-1/2} \\frac{u_i - u_{i-1}}{h} - \\left(-\\alpha_{i+1/2} \\frac{u_{i+1} - u_i}{h}\\right) \\right) $$\n$$ \\frac{du_i}{dt} = \\frac{1}{h^2} \\left( \\alpha_{i+1/2}(u_{i+1} - u_i) - \\alpha_{i-1/2}(u_i - u_{i-1}) \\right) $$\n这与题目中给出的 $(A \\mathbf{u})_i$ 的表达式相符。该格式是守恒的，因为在面 $i+1/2$ 处离开单元 $i$ 的通量（即 $-F_{i+1/2}$）与进入同一面上单元 $i+1$ 的通量完全相同。\n\n在材料界面上，物理条件是温度连续，$u(x^*) = u(x^*-) = u(x^*+)$，以及热通量连续，$F(x^*) = F(x^*-) = F(x^*+)$，这意味着 $-\\alpha(x^*-)\\partial_x u|_{x^*-} = -\\alpha(x^*+)\\partial_x u|_{x^*+}$。\n在我们的离散化中，通过在每个节点上使用单一未知数 $u_i$ 而不在界面上分裂数值，温度连续性得到了内在地满足。通量连续性是通过在界面面上选择合适的 $\\alpha_{i+1/2}$ 来强制实现的。在材料 1 和 2 之间的界面（例如位于 $x_{k+1/2}$），我们有 $\\alpha(x_{k+1/2}-) = \\alpha_1$ 和 $\\alpha(x_{k+1/2}+) = \\alpha_2$。为了找到能正确模拟通量的有效扩散系数 $\\alpha_{k+1/2}$，考虑节点 $k$ 和 $k+1$ 之间的稳态通量。热流阻是可加的。从 $x_k$到 $x_{k+1/2}$ 的热阻是 $\\frac{h/2}{\\alpha_1}$，从 $x_{k+1/2}$ 到 $x_{k+1}$ 的热阻是 $\\frac{h/2}{\\alpha_2}$。在距离 $h$ 上的总热阻是 $\\frac{h/2}{\\alpha_1} + \\frac{h/2}{\\alpha_2}$。有效扩散系数 $\\alpha_{k+1/2}$ 应满足 $\\frac{h}{\\alpha_{k+1/2}} = \\frac{h/2}{\\alpha_1} + \\frac{h/2}{\\alpha_2}$，这给出 $\\frac{1}{\\alpha_{k+1/2}} = \\frac{1}{2}\\left(\\frac{1}{\\alpha_1} + \\frac{1}{\\alpha_2}\\right)$。这就是调和平均：\n$$ \\alpha_{k+1/2} = \\frac{2 \\alpha_1 \\alpha_2}{\\alpha_1 + \\alpha_2} $$\n使用这个值可以确保离散通量 $F_{k+1/2} = -\\alpha_{k+1/2} \\frac{u_{k+1}-u_k}{h}$ 能够正确地模拟跨越材料不连续处的物理通量连续性。\n\n矩阵 $A$ 是一个由该算子定义的 $N \\times N$ 三对角矩阵。对于第 $j$ 行（使用基于 1 的索引，$j \\in \\{1,\\dots,N\\}$），其元素为：\n$$ A_{j,j-1} = \\frac{\\alpha_{j-1/2}}{h^2}, \\quad A_{j,j} = -\\frac{\\alpha_{j-1/2} + \\alpha_{j+1/2}}{h^2}, \\quad A_{j,j+1} = \\frac{\\alpha_{j+1/2}}{h^2} $$\n边界条件为 $u_0=0$ 和 $u_{N+1}=0$。如果节点 $j$ 和 $j+1$ 都在材料 1 中，面系数 $\\alpha_{j+1/2}$ 为 $\\alpha_1$；如果都在材料 2 中，则为 $\\alpha_2$；如果节点 $j$ 在材料 1 中而节点 $j+1$ 在材料 2 中，则为调和平均值。鉴于界面位于节点 $k$ 和 $k+1$ 之间，$\\alpha_{k+1/2}$ 是调和平均值。\n\n### 任务 2：整体式 Crank-Nicolson 放大算子 $G$\n\n用于半离散系统 $\\frac{d\\mathbf{u}}{dt} = A \\mathbf{u}$ 的 Crank-Nicolson (CN) 方法源于时间积分的梯形法则：\n$$ \\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2} (A \\mathbf{u}^{n+1} + A \\mathbf{u}^n) $$\n重新整理此方程，将含 $\\mathbf{u}^{n+1}$ 的项归到左侧，含 $\\mathbf{u}^n$ 的项归到右侧，可得：\n$$ \\mathbf{u}^{n+1} - \\frac{\\Delta t}{2} A \\mathbf{u}^{n+1} = \\mathbf{u}^n + \\frac{\\Delta t}{2} A \\mathbf{u}^n $$\n提出向量 $\\mathbf{u}^{n+1}$ 和 $\\mathbf{u}^n$：\n$$ \\left(I - \\frac{\\Delta t}{2} A\\right) \\mathbf{u}^{n+1} = \\left(I + \\frac{\\Delta t}{2} A\\right) \\mathbf{u}^n $$\n单步放大算子 $G$ 由关系式 $\\mathbf{u}^{n+1} = G \\mathbf{u}^n$ 定义。为了求得 $G$，我们通过在等式两边左乘左侧矩阵的逆来求解 $\\mathbf{u}^{n+1}$。对于扩散问题，矩阵 $A$ 是对称负半定的，因此其特征值为非正数。从而，$I - \\frac{\\Delta t}{2}A$ 的特征值均大于或等于 1，这保证了其可逆性。\n$$ \\mathbf{u}^{n+1} = \\left(I - \\frac{\\Delta t}{2} A\\right)^{-1} \\left(I + \\frac{\\Delta t}{2} A\\right) \\mathbf{u}^n $$\n通过观察，整体式放大算子为：\n$$ G = \\left(I - \\frac{\\Delta t}{2} A\\right)^{-1} \\left(I + \\frac{\\Delta t}{2} A\\right) $$\n\n### 任务 3：单次迭代分块-Jacobi CN 放大算子 $J$\n\n我们从根据分块 $\\mathbf{u} = \\begin{bmatrix} \\mathbf{u}_1 \\\\ \\mathbf{u}_2 \\end{bmatrix}$ 和 $A = \\begin{bmatrix} A_{11} & A_{12} \\\\ A_{21} & A_{22} \\end{bmatrix}$ 写成的分块形式 CN 格式开始：\n$$ \\left(\\begin{bmatrix} I_1 & 0 \\\\ 0 & I_2 \\end{bmatrix} - \\frac{\\Delta t}{2} \\begin{bmatrix} A_{11} & A_{12} \\\\ A_{21} & A_{22} \\end{bmatrix}\\right) \\begin{bmatrix} \\mathbf{u}_1^{n+1} \\\\ \\mathbf{u}_2^{n+1} \\end{bmatrix} = \\left(\\begin{bmatrix} I_1 & 0 \\\\ 0 & I_2 \\end{bmatrix} + \\frac{\\Delta t}{2} \\begin{bmatrix} A_{11} & A_{12} \\\\ A_{21} & A_{22} \\end{bmatrix}\\right) \\begin{bmatrix} \\mathbf{u}_1^{n} \\\\ \\mathbf{u}_2^{n} \\end{bmatrix} $$\n这展开为关于 $\\mathbf{u}_1^{n+1}$ 和 $\\mathbf{u}_2^{n+1}$ 的一个耦合系统：\n$$ \\begin{cases} (I_1 - \\frac{\\Delta t}{2} A_{11}) \\mathbf{u}_1^{n+1} - \\frac{\\Delta t}{2} A_{12} \\mathbf{u}_2^{n+1} = (I_1 + \\frac{\\Delta t}{2} A_{11}) \\mathbf{u}_1^n + \\frac{\\Delta t}{2} A_{12} \\mathbf{u}_2^n \\\\ -\\frac{\\Delta t}{2} A_{21} \\mathbf{u}_1^{n+1} + (I_2 - \\frac{\\Delta t}{2} A_{22}) \\mathbf{u}_2^{n+1} = \\frac{\\Delta t}{2} A_{21} \\mathbf{u}_1^n + (I_2 + \\frac{\\Delta t}{2} A_{22}) \\mathbf{u}_2^n \\end{cases} $$\n求解此线性系统的分块 Jacobi 迭代法将非对角耦合项（涉及 $A_{12}$ 和 $A_{21}$）移到右侧，并使用上一次迭代的值进行计算。从 $\\mathbf{u}^{n+1,(0)} = \\mathbf{u}^n$ 开始进行单次迭代，我们在时间层 $n$ 上计算非对角项：\n$$ \\begin{cases} (I_1 - \\frac{\\Delta t}{2} A_{11}) \\mathbf{u}_1^{n+1} = (I_1 + \\frac{\\Delta t}{2} A_{11}) \\mathbf{u}_1^n + \\frac{\\Delta t}{2} A_{12} \\mathbf{u}_2^n + \\frac{\\Delta t}{2} A_{12} \\mathbf{u}_2^n \\\\ (I_2 - \\frac{\\Delta t}{2} A_{22}) \\mathbf{u}_2^{n+1} = (I_2 + \\frac{\\Delta t}{2} A_{22}) \\mathbf{u}_2^n + \\frac{\\Delta t}{2} A_{21} \\mathbf{u}_1^n + \\frac{\\Delta t}{2} A_{21} \\mathbf{u}_1^n \\end{cases} $$\n简化右侧：\n$$ \\begin{cases} (I_1 - \\frac{\\Delta t}{2} A_{11}) \\mathbf{u}_1^{n+1} = (I_1 + \\frac{\\Delta t}{2} A_{11}) \\mathbf{u}_1^n + \\Delta t A_{12} \\mathbf{u}_2^n \\\\ (I_2 - \\frac{\\Delta t}{2} A_{22}) \\mathbf{u}_2^{n+1} = \\Delta t A_{21} \\mathbf{u}_1^n + (I_2 + \\frac{\\Delta t}{2} A_{22}) \\mathbf{u}_2^n \\end{cases} $$\n通过对左侧的分块对角矩阵求逆，我们解出 $\\mathbf{u}_1^{n+1}$ 和 $\\mathbf{u}_2^{n+1}$：\n$$ \\mathbf{u}_1^{n+1} = (I_1 - \\frac{\\Delta t}{2} A_{11})^{-1} (I_1 + \\frac{\\Delta t}{2} A_{11}) \\mathbf{u}_1^n + (I_1 - \\frac{\\Delta t}{2} A_{11})^{-1} (\\Delta t A_{12}) \\mathbf{u}_2^n $$\n$$ \\mathbf{u}_2^{n+1} = (I_2 - \\frac{\\Delta t}{2} A_{22})^{-1} (\\Delta t A_{21}) \\mathbf{u}_1^n + (I_2 - \\frac{\\Delta t}{2} A_{22})^{-1} (I_2 + \\frac{\\Delta t}{2} A_{22}) \\mathbf{u}_2^n $$\n将其写成矩阵形式 $\\mathbf{u}^{n+1} = J \\mathbf{u}^n$，我们便可确定分块放大算子 $J$：\n$$ J = \\begin{bmatrix}\n(I_1 - \\frac{\\Delta t}{2} A_{11})^{-1}(I_1 + \\frac{\\Delta t}{2} A_{11}) & \\Delta t (I_1 - \\frac{\\Delta t}{2} A_{11})^{-1} A_{12} \\\\\n\\Delta t (I_2 - \\frac{\\Delta t}{2} A_{22})^{-1} A_{21} & (I_2 - \\frac{\\Delta t}{2} A_{22})^{-1}(I_2 + \\frac{\\Delta t}{2} A_{22})\n\\end{bmatrix} $$\n\n### 任务 4：谱半径与稳定性分析\n\n对于形式为 $\\mathbf{u}^{n+1} = X \\mathbf{u}^n$ 的线性单步数值方法，其中 $X$ 是放大算子（或矩阵），经过 $n$ 个时间步后的解由 $\\mathbf{u}^n = X^n \\mathbf{u}^0$ 给出。方法的稳定性取决于当 $n \\to \\infty$ 时矩阵幂 $X^n$ 的行为。\n\n$X^n$ 的行为由 $X$ 的特征值决定。设 $\\{\\lambda_i\\}$ 为 $X$ 的特征值，$\\{\\mathbf{v}_i\\}$ 为对应的特征向量，它们构成一组基（假设 $X$ 可对角化）。任何初始条件 $\\mathbf{u}^0$ 都可以写成这些特征向量的线性组合：$\\mathbf{u}^0 = \\sum_i c_i \\mathbf{v}_i$。将算子作用 $n$ 次可得：\n$$ \\mathbf{u}^n = X^n \\mathbf{u}^0 = X^n \\left(\\sum_i c_i \\mathbf{v}_i\\right) = \\sum_i c_i (X^n \\mathbf{v}_i) = \\sum_i c_i (\\lambda_i^n \\mathbf{v}_i) $$\n为使解在 $n$ 增加时保持有界，不允许任何分量无界增长。这要求对于所有特征值 $\\lambda_i$，其 $|\\lambda_i^n| = |\\lambda_i|^n$ 必须保持有界。此条件当且仅当对所有 $i$ 都有 $|\\lambda_i| \\le 1$ 时才满足。如果任何特征值的模大于 1，其在解中对应的分量将呈指数级增长，导致数值不稳定性。\n\n矩阵 $X$ 的谱半径，记作 $\\rho(X)$，定义为其特征值的绝对值（或复数特征值的模）的最大值：$\\rho(X) = \\max_i |\\lambda_i|$。因此，单步法 $\\mathbf{u}^{n+1} = X \\mathbf{u}^n$ 的线性稳定性条件是其谱半径必须满足：\n$$ \\rho(X) \\le 1 $$\n这使得放大算子的谱半径成为评估数值格式线性稳定性的主要指标。对于整体式 Crank-Nicolson 方法，已知当 $A$ 为负半定时，$\\rho(G) \\le 1$ 无条件成立，从而保证了稳定性。而对于分块迭代格式，其稳定性并无保证，且依赖于参数，因此计算 $\\rho(J)$ 变得至关重要。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef construct_A(N, L1, L2, alpha1, alpha2):\n    \"\"\"\n    Constructs the semi-discrete matrix A for the coupled diffusion problem.\n    \"\"\"\n    L = L1 + L2\n    h = L / (N + 1)\n    k = int(round((N + 1) * L1 / L))  # 1-based index of the interface node\n\n    # Face diffusivity coefficients alpha_{j+1/2}.\n    # The interface is between node k and k+1 (1-based).\n    # This corresponds to the face between index k-1 and k (0-based).\n    alpha_h = (2 * alpha1 * alpha2) / (alpha1 + alpha2)\n    \n    # 0-based indexing for arrays\n    k0 = k - 1 # 0-based index of the interface node\n    \n    # alpha_half[i] stores alpha at the face between node i and i+1\n    alpha_half = np.zeros(N - 1)\n    if k0 > 0:\n        alpha_half[:k0] = alpha1\n    if k0 < N-1:\n        alpha_half[k0] = alpha_h\n        alpha_half[k0+1:] = alpha2\n\n    h2 = h * h\n    \n    # Construct tridiagonal matrix A components\n    # Upper diagonal: A[i, i+1] corresponds to alpha_{i+1/2}\n    v_upper = alpha_half / h2\n    # Lower diagonal: A[i, i-1] corresponds to alpha_{i-1/2}\n    v_lower = alpha_half / h2\n\n    # Main diagonal: A[i, i] is -(alpha_{i+1/2} + alpha_{i-1/2})\n    v_main = np.zeros(N)\n    # At node 0, alpha_{-1/2} is for face at x=h/2 from boundary, which is in material 1.\n    v_main[0] = -(alpha1 + alpha_half[0])\n    # For internal nodes\n    if N > 2:\n        v_main[1:N-1] = -(alpha_half[0:N-2] + alpha_half[1:N-1])\n    # At node N-1, alpha_{N-1/2} is alpha_half[N-2].\n    # alpha_{N+1/2} is for face at x=L-h/2 from boundary, in material 2.\n    if N > 1:\n        v_main[N-1] = -(alpha_half[N-2] + alpha2)\n    \n    v_main /= h2\n    \n    A = np.diag(v_main) + np.diag(v_upper, 1) + np.diag(v_lower, -1)\n    \n    return A, k\n\ndef compute_rho_G(A, dt):\n    \"\"\"\n    Computes the spectral radius of the monolithic Crank-Nicolson operator G.\n    \"\"\"\n    N = A.shape[0]\n    I = np.identity(N)\n    \n    M_left = I - (dt / 2.0) * A\n    M_right = I + (dt / 2.0) * A\n    \n    # G = inv(M_left) @ M_right\n    G = np.linalg.solve(M_left, M_right) # More stable than explicit inverse\n    \n    eigenvalues = np.linalg.eigvals(G)\n    spectral_radius = np.max(np.abs(eigenvalues))\n    \n    return spectral_radius\n\ndef compute_rho_J(A, k, dt):\n    \"\"\"\n    Computes the spectral radius of the one-iteration block-Jacobi CN operator J.\n    \"\"\"\n    N = A.shape[0]\n    \n    # Partition A into blocks\n    A11 = A[0:k, 0:k]\n    A12 = A[0:k, k:N]\n    A21 = A[k:N, 0:k]\n    A22 = A[k:N, k:N]\n    \n    I1 = np.identity(k)\n    I2 = np.identity(N - k)\n    \n    # Calculate terms for the blocks of J\n    # M1_inv = inv(I1 - dt/2 * A11)\n    # M2_inv = inv(I2 - dt/2 * A22)\n    M1_left = I1 - (dt / 2.0) * A11\n    M2_left = I2 - (dt / 2.0) * A22\n    \n    # Construct blocks of J\n    # J11 = M1_inv @ (I1 + dt/2 * A11)\n    J11 = np.linalg.solve(M1_left, I1 + (dt / 2.0) * A11)\n    # J12 = dt * M1_inv @ A12\n    J12 = np.linalg.solve(M1_left, dt * A12)\n    # J21 = dt * M2_inv @ A21\n    J21 = np.linalg.solve(M2_left, dt * A21)\n    # J22 = M2_inv @ (I2 + dt/2 * A22)\n    J22 = np.linalg.solve(M2_left, I2 + (dt / 2.0) * A22)\n\n    # Assemble the full matrix J\n    J = np.block([[J11, J12], [J21, J22]])\n    \n    eigenvalues = np.linalg.eigvals(J)\n    spectral_radius = np.max(np.abs(eigenvalues))\n    \n    return spectral_radius\n    \ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # Fixed parameters\n    L1, L2 = 1.0, 1.0\n\n    test_cases = [\n        {'alpha1': 1.0, 'alpha2': 10.0, 'N': 41, 'dt': 2.0, 'type': 'G'},\n        {'alpha1': 1.0, 'alpha2': 100.0, 'N': 81, 'dt': 50.0, 'type': 'G'},\n        {'alpha1': 1.0, 'alpha2': 100.0, 'N': 41, 'dt': 200.0, 'type': 'J'},\n        {'alpha1': 0.5, 'alpha2': 2.0, 'N': 21, 'dt': 0.1, 'type': 'J'}\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case['N']\n        alpha1 = case['alpha1']\n        alpha2 = case['alpha2']\n        dt = case['dt']\n        \n        A, k = construct_A(N, L1, L2, alpha1, alpha2)\n        \n        if case['type'] == 'G':\n            spectral_radius = compute_rho_G(A, dt)\n        elif case['type'] == 'J':\n            spectral_radius = compute_rho_J(A, k, dt)\n        \n        results.append(spectral_radius)\n\n    # Format results to exactly six decimal places\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3115280"}]}