{"hands_on_practices": [{"introduction": "显式差分格式的数值稳定性是其能否成功应用的关键。CFL (Courant-Friedrichs-Lewy) 条件为我们提供了一个简单而强大的准则，用以确定保证数值解不会发散的最大时间步长。这个练习将帮助你通过一个直接的计算，来理解和应用这个至关重要的稳定性判据 [@problem_id:2172272]。", "problem": "一位计算物理学家正在模拟声波在一维管道中的传播，该过程由波动方程 $\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}$ 建模。介质中的声速为 $c = 320$ m/s。该模拟在空间网格上采用显式有限差分格式，步长为 $\\Delta x = 0.8$ m。为使此数值方法稳定，所选择的时间步长 $\\Delta t$ 必须满足 Courant-Friedrichs-Lewy (CFL) 稳定性条件，该条件由关系式 $c \\frac{\\Delta t}{\\Delta x} \\le 1$ 给出。确定能确保模拟稳定性的最大可能时间步长 $\\Delta t$ 的值。以秒为单位表示您的答案。", "solution": "应用于一维波动方程的显式有限差分格式的 Courant-Friedrichs-Lewy (CFL) 稳定性条件由下式给出\n$$\nc \\frac{\\Delta t}{\\Delta x} \\le 1.\n$$\n为确保使用最大可能的时间步长时仍能保持稳定，我们将该不等式设为等式：\n$$\nc \\frac{\\Delta t_{\\max}}{\\Delta x} = 1 \\quad \\Rightarrow \\quad \\Delta t_{\\max} = \\frac{\\Delta x}{c}.\n$$\n代入给定值 $\\Delta x = 0.8$ 和 $c = 320$：\n$$\n\\Delta t_{\\max} = \\frac{0.8}{320}.\n$$\n化简该分数：\n$$\n\\frac{0.8}{320} = \\frac{8}{3200} = \\frac{1}{400} = 0.0025.\n$$\n因此，以秒为单位的最大稳定时间步长是 $0.0025$。", "answer": "$$\\boxed{0.0025}$$", "id": "2172272"}, {"introduction": "理论上的差分格式通常针对无限大或周期性的区域，但在实际问题中，我们必须处理各种边界。这个练习将指导你如何为靠近固定边界的格点推导专用的更新方程。掌握这项技能对于正确模拟具有物理边界（如固定的弦端）的系统至关重要 [@problem_id:2172248]。", "problem": "考虑一维波动方程，这是一个偏微分方程（PDE），它模拟了像弦振动这样的现象：\n$$ \\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2} $$\n其中 $u(x,t)$ 是位置 $x$ 和时间 $t$ 处的位移，而 $c$ 是恒定的波速。\n\n为了数值求解这个方程，我们可以使用有限差分法。我们在一个网格上对区域进行离散化，空间步长为 $\\Delta x$，时间步长为 $\\Delta t$。令 $u_i^j$ 表示 $u(i\\Delta x, j\\Delta t)$ 的数值近似。通过用二阶中心差分近似代替导数，我们得到内部网格点 $(i, j)$ 的标准显式更新格式：\n$$ u_i^{j+1} = 2(1-r^2)u_i^j + r^2(u_{i+1}^j + u_{i-1}^j) - u_i^{j-1} $$\n这个方程允许我们使用当前和前一个时间步 $j$ 和 $j-1$ 的值来计算下一个时间步 $j+1$ 的位移。参数 $r = \\frac{c \\Delta t}{\\Delta x}$ 被称为库朗数（Courant number）。\n\n现在，考虑一个定义在空间域 $x \\in [0, L]$ 上的弦。网格点由 $i=0, 1, 2, \\dots, N$ 索引，其中 $x_i = i\\Delta x$ 且 $x_N=L$。弦在 $x=0$ 处的一端是固定的，这施加了边界条件 $u(0, t) = 0$（对所有时间 $t$）。在我们的离散表示法中，这等价于 $u_0^j = 0$（对所有时间索引 $j \\ge 0$）。\n\n您的任务是推导与此固定边界相邻的网格点 $i=1$ 处的特定更新方程。将新的位移 $u_1^{j+1}$ 表示为时间步 $j$ 和 $j-1$ 处位移的函数。", "solution": "我们从给定的一维波动方程内部点的显式有限差分更新格式开始：\n$$\nu_{i}^{j+1}=2(1-r^{2})u_{i}^{j}+r^{2}\\left(u_{i+1}^{j}+u_{i-1}^{j}\\right)-u_{i}^{j-1},\n$$\n其中库朗数 $r=\\frac{c\\Delta t}{\\Delta x}$ 并且 $u_{i}^{j}$ 近似于 $u(i\\Delta x,j\\Delta t)$。\n\n为了获得与固定边界相邻点的更新，设 $i=1$：\n$$\nu_{1}^{j+1}=2(1-r^{2})u_{1}^{j}+r^{2}\\left(u_{2}^{j}+u_{0}^{j}\\right)-u_{1}^{j-1}.\n$$\n\n固定端的边界条件是 $u(0,t)=0$（对所有 $t$），其离散形式为 $u_{0}^{j}=0$（对所有 $j\\ge 0$）。将 $u_{0}^{j}=0$ 代入方程，得到\n$$\nu_{1}^{j+1}=2(1-r^{2})u_{1}^{j}+r^{2}u_{2}^{j}-u_{1}^{j-1}.\n$$\n\n这使用在 $i=0$ 处的已知边界值，将新的位移 $u_{1}^{j+1}$ 表示为时间步 $j$ 和 $j-1$ 处的值的函数。", "answer": "$$\\boxed{u_{1}^{j+1}=2(1-r^{2})u_{1}^{j}+r^{2}u_{2}^{j}-u_{1}^{j-1}}$$", "id": "2172248"}, {"introduction": "将理论知识转化为可工作的代码是计算科学的核心。这个综合性练习要求你从基本原理出发，完整地实现一个一维波动方程的求解器，并用它来亲身验证CFL条件的有效性。通过这个实践，你将把关于更新格式、边界条件和稳定性的离散概念整合在一起，观察理论预测与计算结果的直接对应 [@problem_id:3129202]。", "problem": "考虑在区间 $[0,L]$ 上，一根两端固定的拉紧弦的位移 $u(x,t)$ 所满足的一维波动方程，该方程由以下偏微分方程给出：$$u_{tt}(x,t) = c^2 u_{xx}(x,t),$$ 其中 $c$ 为波速。弦的两端保持固定，意味着边界条件为 $u(0,t) = 0$ 和 $u(L,t) = 0$ 对所有 $t \\ge 0$ 成立。初始位移规定为 $$u(x,0) = \\sin\\left(\\frac{\\pi x}{L}\\right),$$ 初始速度为 $$u_t(x,0) = 0.$$ 所有距离单位必须为米，时间单位为秒，波速 $c$ 的单位为米/秒。按照惯例，正弦函数使用弧度制。\n\n您的任务是，使用均匀网格间距，为该方程推导并实现一个在时间和空间上均为二阶精度的显式有限差分方法。从泰勒展开和中心差分的基本定义出发，在均匀网格上近似 $u_{tt}$ 和 $u_{xx}$，并推导出将解从离散时间层 $n$推进到 $n+1$ 所需的更新规则。不要假设任何现成的格式：直接从定义构建该方法。对于所有时间层，使用固定的边界条件处理两个端点。对于第一个时间步，使用一个基于给定初始位置和初始速度的一致的二阶精度公式，以获得时间层 $n=1$ 处的解。\n\n通过运行一系列参数值的格式来根据 Courant–Friedrichs–Lewy (CFL) 条件凭经验评估稳定性，并观察数值解是保持有界还是发散。定义一个经验性发散检测器如下：令 $M_0$ 为空间网格上 $u(x,0)$ 的最大绝对值。在时间步进过程中，计算 $M_n$，即时间层 $n$ 上所有空间点的最大绝对值。如果在任何时刻 $M_n$ 变为未定义（非数字）、无穷大或超过 $10 M_0$，则声明模拟不稳定（发散）；否则，声明其稳定。该检测器必须在您的程序中实现。\n\n对于空间离散化，在 $[0,L]$ 上使用一个包含 $N_x$ 个点的均匀网格，间距为 $\\Delta x = L/(N_x - 1)$ 米。对于时间离散化，使用均匀的时间步长 $\\Delta t$ 秒，并模拟到最终时间 $T$ 秒。对于每个测试用例，计算布尔稳定性结果，其中 $True$ 表示稳定，$False$ 表示发散。\n\n实现您的程序以运行以下测试套件，该套件涵盖了典型情况、接近 CFL 极限的边界情况以及超出极限的情况：\n- 测试 1：$c = 1.0$ 米/秒, $L = 1.0$ 米, $N_x = 101$, $\\Delta t = 0.008$ 秒, $T = 0.5$ 秒。\n- 测试 2：$c = 1.0$ 米/秒, $L = 1.0$ 米, $N_x = 101$, $\\Delta t = 0.010$ 秒, $T = 0.5$ 秒。\n- 测试 3：$c = 1.0$ 米/秒, $L = 1.0$ 米, $N_x = 101$, $\\Delta t = 0.015$ 秒, $T = 1.0$ 秒。\n- 测试 4：$c = 2.0$ 米/秒, $L = 1.0$ 米, $N_x = 101$, $\\Delta t = 0.010$ 秒, $T = 0.5$ 秒。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result_1,result_2,result_3,result_4]$），其中每个 $result_k$ 是您的经验性发散检测器为测试 $k$ 计算出的布尔稳定性结果。不应打印任何额外的文本。输出的布尔值没有物理单位。涉及 $c$、$L$、$\\Delta x$、$\\Delta t$ 和 $T$ 的输入和计算必须按规定一致使用米和秒。", "solution": "我们从通过泰勒展开获得中心差分的基本定义开始。在空间间距为 $\\Delta x$ 的均匀空间网格和时间间距为 $\\Delta t$ 的均匀时间网格上，令 $x_i = i \\Delta x$（对于 $i = 0,1,\\dots,N_x-1$）和 $t^n = n \\Delta t$（对于 $n = 0,1,2,\\dots$）。令 $u_i^n$ 表示对 $u(x_i,t^n)$ 的数值近似。\n\n在点 $(x_i,t^n)$ 处，二阶时间导数的二阶中心差分近似源于泰勒展开式\n$$u(x_i,t^{n\\pm 1}) = u(x_i,t^n) \\pm \\Delta t \\, u_t(x_i,t^n) + \\frac{\\Delta t^2}{2} u_{tt}(x_i,t^n) \\pm \\frac{\\Delta t^3}{6} u_{ttt}(x_i,t^n) + \\cdots,$$\n这可以得到\n$$u_{tt}(x_i,t^n) \\approx \\frac{u_i^{n+1} - 2 u_i^n + u_i^{n-1}}{\\Delta t^2}。$$\n类似地，对于二阶空间导数，使用空间上的泰勒展开式\n$$u(x_{i\\pm 1},t^n) = u(x_i,t^n) \\pm \\Delta x \\, u_x(x_i,t^n) + \\frac{\\Delta x^2}{2} u_{xx}(x_i,t^n) \\pm \\frac{\\Delta x^3}{6} u_{xxx}(x_i,t^n) + \\cdots,$$\n我们得到\n$$u_{xx}(x_i,t^n) \\approx \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{\\Delta x^2}。$$\n\n将这些近似值代入内部点 $i = 1,2,\\dots,N_x-2$ 的波动方程 $u_{tt} = c^2 u_{xx}$，得到离散方程\n$$\\frac{u_i^{n+1} - 2 u_i^n + u_i^{n-1}}{\\Delta t^2} = c^2 \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{\\Delta x^2}。$$\n整理以得到从时间层 $n$ 到 $n+1$ 的更新规则，即显式格式\n$$u_i^{n+1} = 2 u_i^n - u_i^{n-1} + r^2 \\left(u_{i+1}^n - 2 u_i^n + u_{i-1}^n\\right),$$\n其中我们定义了无量纲的库朗数（Courant number）\n$$r = \\frac{c \\, \\Delta t}{\\Delta x}。$$\n\n边界条件为 $u_0^n = 0$ 和 $u_{N_x-1}^n = 0$ 对所有 $n$ 成立。初始条件提供了 $u_i^0 = \\sin\\left(\\frac{\\pi x_i}{L}\\right)$ 对所有 $i$ 成立，这与固定端点一致，因为 $\\sin(0) = 0$ 和 $\\sin(\\pi) = 0$。为了初始化该格式，我们还需要 $u_i^1$。使用在 $t=0$ 附近关于时间的二阶精度泰勒展开，并利用给定的初始速度 $u_t(x,0) = 0$，我们得到\n$$u(x_i,\\Delta t) \\approx u(x_i,0) + \\Delta t \\, u_t(x_i,0) + \\frac{\\Delta t^2}{2} u_{tt}(x_i,0)。$$\n将 $u_{tt}(x_i,0)$ 替换为 $c^2 u_{xx}(x_i,0)$，并在时间 $n=0$ 应用中心空间差分，得到\n$$u_i^1 = u_i^0 + \\Delta t \\cdot 0 + \\frac{1}{2} r^2 \\left(u_{i+1}^0 - 2 u_i^0 + u_{i-1}^0\\right), \\quad \\text{对于 } i=1,\\dots,N_x-2,$$\n并有 $u_0^1 = 0$ 和 $u_{N_x-1}^1 = 0$。\n\nCourant–Friedrichs–Lewy (CFL) 条件源于稳定性分析（例如，通过冯·诺依曼傅里叶模态分析(von Neumann Fourier mode analysis)）。对于上述显式二阶中心差分格式，应用于单个傅里叶模态的放大因子 $G$ 满足一个稳定性约束，该约束导致以下要求\n$$r \\le 1。$$\n当 $r \\le 1$ 时，所有傅里叶模态都有 $|G| \\le 1$，方法是稳定的；当 $r > 1$ 时，某些模态有 $|G| > 1$，这会导致指数增长和数值发散。\n\n算法设计原则：\n- 使用米和秒定义物理和数值参数 $c$、$L$、$N_x$、$\\Delta t$、$T$。\n- 计算网格间距 $\\Delta x = L/(N_x-1)$ 和库朗数 $r = c \\Delta t / \\Delta x$。\n- 初始化 $u_i^0 = \\sin(\\pi x_i / L)$ 对于 $i=0,\\dots,N_x-1$ 和 $u_t(x,0) = 0$。\n- 使用包含 $u_{tt}(x,0) = c^2 u_{xx}(x,0)$ 的二阶公式计算 $u^1$。\n- 对于 $n \\ge 1$，在内部点使用显式更新推进 $u^{n+1}$，并在端点强制执行边界条件。\n- 在每个时间步，计算 $M_n = \\max_i |u_i^n|$ 并应用经验性发散检测器：如果 $M_n$ 变为非数字、无穷大或超过 $10 M_0$（其中 $M_0 = \\max_i |u_i^0|$），则声明不稳定；否则继续直到最终时间 $T$。\n- 返回一个表示稳定性的布尔值。\n\n测试套件的基本原理：\n- 测试 1 选择 $r = 0.8$（$c = 1.0$, $\\Delta t = 0.008$, $\\Delta x = 0.01$）作为典型的稳定情况。\n- 测试 2 设置 $r = 1.0$ 作为边界情况，对于此格式应保持稳定。\n- 测试 3 使用 $r = 1.5$ 和更长的最终时间，以确保不稳定性在经验上显现。\n- 测试 4 使用 $r = 2.0$，远超 CFL 极限，并会迅速发散。\n\n基于 CFL 条件和经验检测的预期结果：\n- 测试 1：$True$（稳定）。\n- 测试 2：$True$（稳定）。\n- 测试 3：$False$（发散）。\n- 测试 4：$False$（发散）。\n\n最终程序聚合这些布尔值，并按要求将它们打印为单个方括号括起来的逗号分隔列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_wave_1d_stability(c, L, Nx, dt, T):\n    \"\"\"\n    Simulate the 1D wave equation u_tt = c^2 u_xx with fixed ends using\n    second-order central differences in space and time. Empirically detect\n    instability (blow-up) via amplitude growth and NaN/Inf checks.\n\n    Parameters:\n        c  (float): wave speed (m/s)\n        L  (float): domain length (m)\n        Nx (int):   number of spatial grid points\n        dt (float): time step (s)\n        T  (float): final time (s)\n\n    Returns:\n        bool: True if stable (no blow-up detected), False otherwise.\n    \"\"\"\n    # Spatial discretization\n    dx = L / (Nx - 1)\n    x = np.linspace(0.0, L, Nx)\n\n    # Courant number\n    r = c * dt / dx\n\n    # Initial displacement u(x,0) = sin(pi x / L), initial velocity = 0\n    u0 = np.sin(np.pi * x / L)\n    # Boundary conditions are fixed ends: u(0,t) = 0, u(L,t) = 0\n    u0[0] = 0.0\n    u0[-1] = 0.0\n\n    # Prepare arrays for time stepping\n    u_prev = u0.copy()\n\n    # Compute u^1 using second-order accurate initialization:\n    # u^1 = u^0 + dt * v^0 + (dt^2 / 2) * c^2 * u_xx^0\n    # with v^0 = 0 and u_xx^0 approximated by central differences\n    u_curr = u0.copy()\n    # interior update for the first step\n    # u_curr[i] = u_prev[i] + 0 + 0.5 * r^2 * (u_prev[i+1] - 2*u_prev[i] + u_prev[i-1])\n    for i in range(1, Nx - 1):\n        u_curr[i] = u_prev[i] + 0.5 * (r ** 2) * (u_prev[i + 1] - 2.0 * u_prev[i] + u_prev[i - 1])\n    # Enforce boundary conditions\n    u_curr[0] = 0.0\n    u_curr[-1] = 0.0\n\n    # Empirical blow-up detector thresholds\n    M0 = np.max(np.abs(u0))\n    if not np.isfinite(M0):\n        return False  # pathological, treat as blow-up\n    threshold = 10.0 * (M0 if M0 > 0 else 1.0)  # avoid zero threshold\n\n    # Number of time steps\n    n_steps = int(np.floor(T / dt))\n\n    # Time stepping\n    for _ in range(1, n_steps):\n        u_next = u_curr.copy()\n        # Explicit update for interior points:\n        # u_next[i] = 2*u_curr[i] - u_prev[i] + r^2 * (u_curr[i+1] - 2*u_curr[i] + u_curr[i-1])\n        for i in range(1, Nx - 1):\n            u_next[i] = (\n                2.0 * u_curr[i]\n                - u_prev[i]\n                + (r ** 2) * (u_curr[i + 1] - 2.0 * u_curr[i] + u_curr[i - 1])\n            )\n        # Enforce boundary conditions\n        u_next[0] = 0.0\n        u_next[-1] = 0.0\n\n        # Check for blow-up\n        M_n = np.max(np.abs(u_next))\n        if not np.isfinite(M_n) or M_n > threshold:\n            return False\n\n        # Rotate time levels\n        u_prev, u_curr = u_curr, u_next\n\n    # If reached final time without blow-up, declare stable\n    return True\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple: (c, L, Nx, dt, T)\n    test_cases = [\n        (1.0, 1.0, 101, 0.008, 0.5),  # r = 0.8, expected stable\n        (1.0, 1.0, 101, 0.010, 0.5),  # r = 1.0, expected stable\n        (1.0, 1.0, 101, 0.015, 1.0),  # r = 1.5, expected unstable\n        (2.0, 1.0, 101, 0.010, 0.5),  # r = 2.0, expected unstable\n    ]\n\n    results = []\n    for c, L, Nx, dt, T in test_cases:\n        result = simulate_wave_1d_stability(c, L, Nx, dt, T)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3129202"}]}