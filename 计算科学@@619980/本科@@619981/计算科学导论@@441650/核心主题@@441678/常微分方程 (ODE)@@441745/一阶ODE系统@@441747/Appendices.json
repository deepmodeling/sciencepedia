{"hands_on_practices": [{"introduction": "数值求解常微分方程（ODEs）是计算科学中的一项基本技能。然而，不同的数值方法在精度、计算成本和稳定性之间存在权衡。本练习将带领您实现并比较两种经典的积分方法——显式欧拉法和四阶龙格-库塔（RK4）法，并将其应用于著名的洛伦兹混沌系统。通过将数值解与高精度参考解进行比较，您将亲身体验数值误差在混沌系统中是如何迅速累积的，从而深刻理解选择合适积分方法的重要性。[@problem_id:2444905]", "problem": "考虑一个耦合一阶常微分方程组的初值问题，该问题由向量场 $\\mathbf{f}(\\mathbf{x}, t)$ 定义为 $\\dfrac{d\\mathbf{x}}{dt} = \\mathbf{f}(\\mathbf{x}, t)$，并带有初始条件 $\\mathbf{x}(0) = \\mathbf{x}_0$。洛伦兹系统是一个典型的混沌流，由以下三维系统给出\n$$\n\\frac{dx}{dt} = \\sigma (y - x), \\quad\n\\frac{dy}{dt} = x (\\rho - z) - y, \\quad\n\\frac{dz}{dt} = x y - \\beta z,\n$$\n其参数为 $\\sigma = 10$、$\\rho = 28$ 和 $\\beta = 8/3$，初始条件为 $\\mathbf{x}_0 = (1, 1, 1)$。本问题中的所有量均为无量纲，因此不需要物理单位。\n\n仅从初值问题、数值时间步进以及以对初始条件的敏感依赖性为特征的决定性混沌概念的定义出发，为 $\\dfrac{d\\mathbf{x}}{dt} = \\mathbf{f}(\\mathbf{x}, t)$ 实现两种显式时间积分器：\n- 显式欧拉法，以及\n- 经典四阶龙格-库塔法。\n\n对于每种积分器，在步长为 $\\Delta t$ 的均匀时间网格上，在一个有限时间域 $[0, T]$ 内推进洛伦兹系统。为了量化混沌系统中由离散化引起的数值误差增长，我们定义一个高精度参考轨迹 $\\mathbf{x}_{\\text{ref}}(t)$，该轨迹通过具有严格容差的自适应显式方法计算得出，并在相同的均匀时间网格上进行求值。在每个网格时间 $t_n$，将瞬时误差定义为欧几里得范数 $e_n = \\lVert \\mathbf{x}_{\\text{num}}(t_n) - \\mathbf{x}_{\\text{ref}}(t_n) \\rVert_2$。对于给定的阈值 $\\varepsilon  0$，将首次阈值穿越时间 $t_{\\text{cross}}$ 定义为使得 $e_n \\ge \\varepsilon$ 成立的最小网格时间 $t_n$。如果在 $[0, T]$ 上不存在这样的索引，则定义 $t_{\\text{cross}} = T$。\n\n你的程序必须：\n- 根据其算法定义实现显式欧拉法和经典四阶龙格-库塔法；\n- 使用严格的误差容差计算高精度参考解，并在均匀网格上进行插值或精确求值；\n- 对于下方的每个测试用例，使用该测试用例相同的网格和参考，计算两个首次阈值穿越时间，一个用于显式欧拉法，另一个用于经典四阶龙格-库塔法。\n\n测试套件规范：\n- 系统：洛伦兹系统，参数为 $\\sigma = 10$，$\\rho = 28$，$\\beta = 8/3$，初始条件为 $\\mathbf{x}_0 = (1, 1, 1)$，在 $t=0$ 到 $t=T$ 的时间段内，在步长为 $\\Delta t$ 的均匀网格上进行积分。\n- 高精度参考：采用自适应显式方法，相对容差 $\\mathrm{rtol} = 10^{-12}$，绝对容差 $\\mathrm{atol} = 10^{-12}$，在被测方法所用的均匀网格上求值。\n- 阈值定义：欧几里得范数阈值 $\\varepsilon$，按各用例指定。\n\n提供以下四个测试用例的结果，每个用例由 $(\\Delta t, T, \\varepsilon)$ 标识：\n- 用例 1: $(0.001, 20.0, 0.01)$\n- 用例 2: $(0.002, 20.0, 0.01)$\n- 用例 3: $(0.005, 20.0, 0.01)$\n- 用例 4: $(0.001, 5.0, 1.0)$\n\n对于每个用例，计算并报告两个浮点数：显式欧拉法的 $t_{\\text{cross}}$，后跟经典四阶龙格-库塔法的 $t_{\\text{cross}}$，两者都使用与 $t$ 相同的时间单位，并表示为普通十进制数。如果未发生穿越，则为该方法和用例返回 $T$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$[t_{\\text{cross}}^{\\text{Euler},1}, t_{\\text{cross}}^{\\text{RK4},1}, t_{\\text{cross}}^{\\text{Euler},2}, t_{\\text{cross}}^{\\text{RK4},2}, t_{\\text{cross}}^{\\text{Euler},3}, t_{\\text{cross}}^{\\text{RK4},3}, t_{\\text{cross}}^{\\text{Euler},4}, t_{\\text{cross}}^{\\text{RK4},4}]$。\n唯一允许的输出是此严格符合指定格式的单行内容。不应打印任何额外文本。", "solution": "该问题要求实现并比较两种用于常微分方程（ODE）的基本数值积分器：显式欧拉法和经典四阶龙格-库塔法（RK4）。本次数值实验的对象是洛伦兹系统，一个决定性混沌的典型例子。我们的目标是，对于每种积分器和一组给定的参数，确定数值解的轨迹与高精度参考轨迹的偏差达到指定误差阈值 $\\varepsilon$ 的时间。\n\n该问题被表述为一个耦合一阶常微分方程组的初值问题（IVP），其通用形式为：\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{f}(\\mathbf{x}, t), \\quad \\mathbf{x}(t_0) = \\mathbf{x}_0\n$$\n对于本问题，状态向量为 $\\mathbf{x}(t) = [x(t), y(t), z(t)]^T$，向量场 $\\mathbf{f}(\\mathbf{x}, t)$ 由洛伦兹方程给出：\n$$\n\\mathbf{f}(\\mathbf{x}) = \\begin{pmatrix} \\sigma (y - x) \\\\ x (\\rho - z) - y \\\\ xy - \\beta z \\end{pmatrix}\n$$\n该系统是自治的，因此 $\\mathbf{f}$ 不显式依赖于 $t$。参数固定在其经典混沌值：$\\sigma = 10$，$\\rho = 28$ 和 $\\beta = 8/3$。初始条件为 $\\mathbf{x}(0) = \\mathbf{x}_0 = [1, 1, 1]^T$。\n\n数值积分方法在离散时间网格 $t_n = n \\Delta t$ 上近似连续解 $\\mathbf{x}(t)$，其中 $\\Delta t$ 是时间步长。\n\n首先，我们考虑显式欧拉法。这是一种一阶方法，源于对导数的简单向前差分近似。将解从时间 $t_n$ 推进到 $t_{n+1} = t_n + \\Delta t$ 的更新规则是：\n$$\n\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\Delta t \\cdot \\mathbf{f}(\\mathbf{x}_n)\n$$\n其中 $\\mathbf{x}_n$ 是 $\\mathbf{x}(t_n)$ 的数值近似。该方法实现简单，但精度较低（局部截断误差为 $\\mathcal{O}(\\Delta t^2)$ 阶），且稳定性有限。\n\n其次，我们实现经典四阶龙格-库塔（RK4）法。这是一种更复杂的单步法，它通过在时间步内评估多个中间点的向量场 $\\mathbf{f}$ 来实现更高的精度。其更新规则由以下公式给出：\n$$\n\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n其中中间阶段为：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{x}_n) \\\\\n\\mathbf{k}_2 = \\mathbf{f}(\\mathbf{x}_n + \\frac{\\Delta t}{2} \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = \\mathbf{f}(\\mathbf{x}_n + \\frac{\\Delta t}{2} \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = \\mathbf{f}(\\mathbf{x}_n + \\Delta t \\cdot \\mathbf{k}_3)\n\\end{aligned}\n$$\nRK4 方法的局部截断误差为 $\\mathcal{O}(\\Delta t^5)$ 阶，这使得它在相同步长 $\\Delta t$ 下比欧拉法精确得多。\n\n为了量化这些固定步长法的误差，我们必须首先计算一个高精度的参考解 $\\mathbf{x}_{\\text{ref}}(t)$。这是通过使用一个自适应步长积分器来实现的，具体来说，就是使用 `scipy.integrate` 库中的 `solve_ivp` 函数，并将其相对和绝对误差容差配置得非常严格（$\\mathrm{rtol} = 10^{-12}$，$\\mathrm{atol} = 10^{-12}$）。我们指示此求解器在我们固定步长法将要使用的相同均匀时间网格 $\\{t_n\\}$ 上评估参考解。\n\n有了来自欧拉法或 RK4 法的数值解 $\\mathbf{x}_{\\text{num}}(t_n)$ 和参考解 $\\mathbf{x}_{\\text{ref}}(t_n)$，每一步的瞬时误差定义为它们之间差值的欧几里得范数：\n$$\ne_n = \\lVert \\mathbf{x}_{\\text{num}}(t_n) - \\mathbf{x}_{\\text{ref}}(t_n) \\rVert_2\n$$\n我们主要关注的量是首次阈值穿越时间 $t_{\\text{cross}}$，定义为网格中误差 $e_n$ 达到或超过给定阈值 $\\varepsilon$ 的第一个时间点 $t_n$。\n$$\nt_{\\text{cross}} = \\min \\{ t_n \\mid e_n \\ge \\varepsilon, n  0 \\}\n$$\n如果在整个积分区间 $[0, T]$ 内误差始终未达到阈值，则取 $t_{\\text{cross}}$ 为 $T$。\n\n计算流程如下：对于每个由 $(\\Delta t, T, \\varepsilon)$ 定义的测试用例：\n1.  构建从 $t=0$ 到 $t=T$ 步长为 $\\Delta t$ 的均匀时间网格 $\\{t_n\\}$。\n2.  在所有网格点上计算并存储参考解 $\\mathbf{x}_{\\text{ref}}(t_n)$。\n3.  使用显式欧拉法模拟该系统。在每一步 $n$，计算 $\\mathbf{x}_{\\text{Euler}}(t_{n+1})$，并与 $\\mathbf{x}_{\\text{ref}}(t_{n+1})$ 比较以计算误差 $e_{n+1}$，然后检查是否有 $e_{n+1} \\ge \\varepsilon$。第一个满足此条件的 $t_{n+1}$ 被记录为 $t_{\\text{cross}}^{\\text{Euler}}$。如果循环结束时仍未满足条件，则 $t_{\\text{cross}}^{\\text{Euler}} = T$。\n4.  对 RK4 方法独立重复此过程，以找到 $t_{\\text{cross}}^{\\text{RK4}}$。\n\n整个过程被封装在所提供的 Python 代码中，该代码会遍历指定的测试用例，并以要求的格式报告得出的首次阈值穿越时间。结果将证明 RK4 方法具有更高的精度，因为它与欧拉法相比，能在更长的时间内保持较小的误差，并且结果也将展示误差的增长对步长 $\\Delta t$ 的敏感性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the Lorenz system problem as specified.\n\n    This function implements the explicit Euler and classical RK4 methods to\n    integrate the Lorenz system. It compares their solutions against a\n    high-accuracy reference solution to find the time at which the numerical\n    error first exceeds a given threshold. This is performed for several\n    test cases.\n    \"\"\"\n\n    # Define the Lorenz system of ODEs\n    def lorenz(t, x, sigma, rho, beta):\n        \"\"\"\n        The vector field for the Lorenz system.\n        The 't' argument is required by scipy.integrate.solve_ivp.\n        \"\"\"\n        dxdt = sigma * (x[1] - x[0])\n        dydt = x[0] * (rho - x[2]) - x[1]\n        dzdt = x[0] * x[1] - beta * x[2]\n        return np.array([dxdt, dydt, dzdt])\n\n    # System parameters and initial condition\n    sigma = 10.0\n    rho = 28.0\n    beta = 8.0 / 3.0\n    x0 = np.array([1.0, 1.0, 1.0])\n    lorenz_params = (sigma, rho, beta)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (delta_t, T, epsilon)\n        (0.001, 20.0, 0.01),\n        (0.002, 20.0, 0.01),\n        (0.005, 20.0, 0.01),\n        (0.001, 5.0, 1.0),\n    ]\n\n    results = []\n    for dt, T, epsilon in test_cases:\n        # 1. Setup time grid\n        # Use round to prevent floating point inaccuracies in calculating num_steps\n        num_steps = int(round(T / dt))\n        t_points = np.linspace(0, T, num_steps + 1)\n\n        # 2. Compute high-accuracy reference solution\n        ref_sol = solve_ivp(\n            fun=lorenz,\n            t_span=(0, T),\n            y0=x0,\n            method='RK45',\n            t_eval=t_points,\n            rtol=1e-12,\n            atol=1e-12,\n            args=lorenz_params\n        )\n        x_ref = ref_sol.y.T  # Transpose to shape (num_steps+1, 3)\n\n        # 3. Compute t_cross for Explicit Euler\n        x_euler = np.zeros_like(x_ref)\n        x_euler[0] = x0\n        t_cross_euler = T\n        for n in range(num_steps):\n            t_n = t_points[n]\n            x_n = x_euler[n]\n            # Euler step\n            x_euler[n + 1] = x_n + dt * lorenz(t_n, x_n, *lorenz_params)\n\n            # Check error against reference\n            error = np.linalg.norm(x_euler[n + 1] - x_ref[n + 1])\n            if error >= epsilon:\n                t_cross_euler = t_points[n + 1]\n                break\n        results.append(t_cross_euler)\n\n        # 4. Compute t_cross for Fourth-Order Runge-Kutta (RK4)\n        x_rk4 = np.zeros_like(x_ref)\n        x_rk4[0] = x0\n        t_cross_rk4 = T\n        for n in range(num_steps):\n            t_n = t_points[n]\n            x_n = x_rk4[n]\n            # RK4 stages\n            k1 = lorenz(t_n, x_n, *lorenz_params)\n            k2 = lorenz(t_n + dt / 2.0, x_n + dt / 2.0 * k1, *lorenz_params)\n            k3 = lorenz(t_n + dt / 2.0, x_n + dt / 2.0 * k2, *lorenz_params)\n            k4 = lorenz(t_n + dt, x_n + dt * k3, *lorenz_params)\n            # RK4 step\n            x_rk4[n + 1] = x_n + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n            # Check error against reference\n            error = np.linalg.norm(x_rk4[n + 1] - x_ref[n + 1])\n            if error >= epsilon:\n                t_cross_rk4 = t_points[n + 1]\n                break\n        results.append(t_cross_rk4)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2444905"}, {"introduction": "在掌握了数值积分的基本方法之后，我们来探讨一个更高级但至关重要的概念：数值刚度（numerical stiffness）。当一个系统包含在截然不同的时间尺度上发生的过程时，它就变得“刚性”，这对许多标准积分器构成了严峻挑战。本练习通过一个巧妙的力学模型，使用罚函数法来近似一个圆形约束，您将看到增加罚刚度系数 $k$ 如何使一个简单的系统演变为一个刚性系统，并最终导致像我们在上一个练习中使用的显式RK4积分器出现数值不稳定。[@problem_id:3199683]", "problem": "考虑一个平面力学系统，该系统被建模为一个质点，受一个完整约束的作用，理想情况下该约束会将其运动限制在一个圆周上。我们不精确地施加该约束，而是使用一个罚函数势来近似它，该罚函数势会对偏离约束的行为进行惩罚。该系统必须严格地作为一个一阶常微分方程（ODE）组来建立公式和进行仿真，并且数值实验必须评估增加罚函数刚度如何影响积分器的稳定性和约束违反的幅度。\n\n基础和建模。从牛顿第二定律开始，该定律指出总力等于质量乘以加速度，即 $m \\,\\ddot{\\mathbf{q}}(t) = \\mathbf{F}(\\mathbf{q}(t))$，其中 $\\mathbf{q}(t) = [x(t), y(t)]^\\top$ 是位置向量，$m$ 是质量。设完整约束为由 $g(\\mathbf{q}) = x^2 + y^2 - R^2 = 0$ 定义的圆。使用罚函数势 $U(\\mathbf{q}) = \\frac{k}{2}\\, g(\\mathbf{q})^2$ 来近似此约束，其中 $k$ 是罚函数刚度。由此势产生的保守力由 $\\mathbf{F}(\\mathbf{q}) = -\\nabla U(\\mathbf{q})$ 给出。通过引入速度 $\\mathbf{v}(t) = \\dot{\\mathbf{q}}(t) = [v_x(t), v_y(t)]^\\top$ 并定义状态向量 $\\mathbf{z}(t) = [x(t), y(t), v_x(t), v_y(t)]^\\top$，将得到的二阶常微分方程转换为一个一阶常微分方程组。\n\n初始条件和单位。使用 $m = 1\\,\\mathrm{kg}$，$R = 1\\,\\mathrm{m}$，以及初始条件 $x(0) = R$，$y(0) = 0$，$v_x(0) = 0$，$v_y(0) = v_0$，其中 $v_0 = 1\\,\\mathrm{m/s}$。所有位置单位必须是 $\\mathrm{m}$，速度单位是 $\\mathrm{m/s}$，时间单位是 $\\mathrm{s}$，罚函数刚度 $k$ 的单位是 $\\mathrm{N/m^3}$。\n\n积分器和仿真协议。实现一个显式定步长四阶龙格－库塔法（RK4）来积分该一阶常微分方程组。使用恒定的时间步长 $h = 0.005\\,\\mathrm{s}$，在总时间 $T = 5.0\\,\\mathrm{s}$ 内进行仿真。在每个时间步，计算瞬时约束违反量，即径向偏差 $\\delta r(t) = \\left| \\sqrt{x(t)^2 + y(t)^2} - R \\right|$（单位为 $\\mathrm{m}$），并跟踪整个仿真过程中的最大值。\n\n稳定性判据。为此测试目的，积分器的数值稳定性定义如下：当且仅当在整个 $t \\in [0,T]$ 时间内，状态保持有限和有界，即 $\\mathbf{z}(t)$ 的所有分量均为有限且 $\\lVert \\mathbf{z}(t) \\rVert_2  M_{\\mathrm{th}}$（其中 $M_{\\mathrm{th}} = 10^3$），仿真才是稳定的；否则为不稳定。如果检测到不稳定性，应立即停止该情况的仿真。\n\n测试套件。对以下罚函数刚度值进行系统仿真：\n- 情况 1：$k = 100\\,\\mathrm{N/m^3}$ (理想情况，相对较软的惩罚)\n- 情况 2：$k = 1{,}000\\,\\mathrm{N/m^3}$ (中等惩罚)\n- 情况 3：$k = 10{,}000\\,\\mathrm{N/m^3}$ (刚性惩罚)\n- 情况 4：$k = 50{,}000\\,\\mathrm{N/m^3}$ (非常刚性，接近显式定步长积分器的稳定性边界)\n\n要求输出。对于每种情况，计算：\n- 最大约束违反量 $\\max_{t \\in [0,T]} \\delta r(t)$，表示为以 $\\mathrm{m}$ 为单位的浮点数。\n- 稳定性标志，一个布尔值，指示仿真是否根据所述判据保持稳定。\n\n最终输出格式。您的程序应生成单行输出，其中包含四种情况的结果，格式为一个用方括号括起来的逗号分隔列表，按顺序交错排列每个情况的最大违反量和稳定性标志：$[\\delta r_1, s_1, \\delta r_2, s_2, \\delta r_3, s_3, \\delta r_4, s_4]$，其中每个 $\\delta r_i$ 是一个以 $\\mathrm{m}$ 为单位的浮点数，每个 $s_i$ 是 $\\mathrm{True}$ 或 $\\mathrm{False}$。", "solution": "该问题要求对一个平面力学系统进行公式化和数值仿真，其中圆形的完整约束通过罚函数法进行近似。问题的核心在于将控制该系统的二阶微分方程转换为一个一阶常微分方程（ODE）组，并对其进行数值积分，以研究罚函数刚度参数的影响。\n\n首先，我们建立物理模型。该系统是一个质量为 $m$ 的质点，其位置向量为 $\\mathbf{q}(t) = [x(t), y(t)]^\\top$。根据牛顿第二定律，运动方程为 $m\\ddot{\\mathbf{q}}(t) = \\mathbf{F}(\\mathbf{q}(t))$，其中 $\\mathbf{F}$ 是作用在质点上的总力。\n\n理想约束是一个半径为 $R$ 的圆，由方程 $g(\\mathbf{q}) = x(t)^2 + y(t)^2 - R^2 = 0$ 描述。罚函数法通过引入一个势能函数 $U(\\mathbf{q})$ 来近似此约束，该函数会对偏离约束曲面的行为进行惩罚。指定的势为 $U(\\mathbf{q}) = \\frac{k}{2} g(\\mathbf{q})^2$，其中 $k$ 是罚函数刚度。当约束被满足时（$g(\\mathbf{q})=0$），此势为零，并随着偏差的增加呈二次方增长。\n\n该势产生的力是保守力，由势的负梯度给出：$\\mathbf{F}(\\mathbf{q}) = -\\nabla U(\\mathbf{q})$。我们计算该力的分量：\n$$\n\\mathbf{F}(\\mathbf{q}) = -\\nabla \\left[ \\frac{k}{2} (x^2 + y^2 - R^2)^2 \\right]\n$$\n力的 $x$ 分量为：\n$$\nF_x = -\\frac{\\partial U}{\\partial x} = -\\frac{k}{2} \\cdot 2(x^2 + y^2 - R^2) \\cdot \\frac{\\partial}{\\partial x}(x^2 + y^2 - R^2) = -k(x^2 + y^2 - R^2)(2x) = -2kx(x^2 + y^2 - R^2)\n$$\n类似地，力的 $y$ 分量为：\n$$\nF_y = -\\frac{\\partial U}{\\partial y} = -k(x^2 + y^2 - R^2)(2y) = -2ky(x^2 + y^2 - R^2)\n$$\n因此，二阶运动方程为：\n$$\n\\ddot{x}(t) = \\frac{F_x}{m} = -\\frac{2k}{m} x(t) \\left(x(t)^2 + y(t)^2 - R^2\\right)\n$$\n$$\n\\ddot{y}(t) = \\frac{F_y}{m} = -\\frac{2k}{m} y(t) \\left(x(t)^2 + y(t)^2 - R^2\\right)\n$$\n为了对该系统进行数值求解，我们将其转换为一个一阶常微分方程组。我们定义状态向量为 $\\mathbf{z}(t) = [x(t), y(t), v_x(t), v_y(t)]^\\top$，其中 $v_x(t) = \\dot{x}(t)$ 和 $v_y(t) = \\dot{y}(t)$ 是速度分量。状态向量的时间导数 $\\dot{\\mathbf{z}}(t) = f(\\mathbf{z}(t))$ 由下式给出：\n$$\n\\dot{\\mathbf{z}}(t) = \n\\begin{bmatrix}\n\\dot{x} \\\\\n\\dot{y} \\\\\n\\dot{v}_x \\\\\n\\dot{v}_y\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nv_x \\\\\nv_y \\\\\n-\\frac{2k}{m} x (x^2 + y^2 - R^2) \\\\\n-\\frac{2k}{m} y (x^2 + y^2 - R^2)\n\\end{bmatrix}\n$$\n这是一个形式为 $\\dot{\\mathbf{z}} = f(\\mathbf{z})$ 的四个耦合一阶常微分方程组。我们给定的初始条件为 $\\mathbf{z}(0) = [R, 0, 0, v_0]^\\top$。\n\n问题指定使用显式四阶龙格－库塔（RK4）法进行数值积分，步长固定为 $h$。给定时间 $t_n$ 时的状态 $\\mathbf{z}_n$，时间 $t_{n+1} = t_n + h$ 时的状态 $\\mathbf{z}_{n+1}$ 计算如下：\n$$\n\\mathbf{z}_{n+1} = \\mathbf{z}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n其中中间斜率为：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = f(\\mathbf{z}_n) \\\\\n\\mathbf{k}_2 = f(\\mathbf{z}_n + \\frac{h}{2} \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = f(\\mathbf{z}_n + \\frac{h}{2} \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = f(\\mathbf{z}_n + h \\mathbf{k}_3)\n\\end{aligned}\n$$\n仿真从 $t=0$ 到 $t=T=5.0\\,\\mathrm{s}$ 进行，时间步长为 $h=0.005\\,\\mathrm{s}$。在每一步，我们计算瞬时约束违反量 $\\delta r(t) = \\left| \\sqrt{x(t)^2 + y(t)^2} - R \\right|$，并记录其最大值。我们还监测数值不稳定性，其定义为状态向量的L2范数 $\\lVert \\mathbf{z}(t) \\rVert_2$ 超过阈值 $M_{\\mathrm{th}} = 10^3$，或任何分量变为非有限值。如果检测到不稳定性，针对该特定 $k$ 值的仿真将终止，并将稳定性标志设置为 `False`。\n\n对四个指定的罚函数刚度 $k$ 值（$100\\,\\mathrm{N/m^3}$、$1000\\,\\mathrm{N/m^3}$、$10000\\,\\mathrm{N/m^3}$ 和 $50000\\,\\mathrm{N/m^3}$）重复此过程。\n预期的行为是一种权衡：随着 $k$ 的增加，偏离圆周的惩罚变得更严厉，因此最大约束违反量 $\\delta r$ 应该减小。然而，更高的 $k$ 值会给系统动力学引入高频振荡，使得常微分方程系统在数值上变得“刚性”。像 RK4 这样的具有固定步长的显式积分器，当时间步长 $h$ 不够小以解析这些快速动态时，可能会变得不稳定，导致数值解的灾难性发散。我们预计最后一种情况，$k=50000\\,\\mathrm{N/m^3}$，在给定的时间步长 $h=0.005\\,\\mathrm{s}$ 下可能会表现出这种不稳定性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the specified mechanical system problem using the RK4 method.\n    \"\"\"\n    # Define physical constants and simulation parameters\n    m = 1.0  # mass in kg\n    R = 1.0  # radius in m\n    v0 = 1.0 # initial tangential velocity in m/s\n    \n    h = 0.005 # time step in s\n    T = 5.0   # total simulation time in s\n    M_th = 1000.0 # stability threshold\n\n    # Define the test cases for the penalty stiffness k\n    test_cases = [\n        100.0,    # Case 1: k in N/m^3\n        1000.0,   # Case 2: k in N/m^3\n        10000.0,  # Case 3: k in N/m^3\n        50000.0   # Case 4: k in N/m^3\n    ]\n\n    results = []\n\n    def f(z, k_val):\n        \"\"\"\n        Computes the time derivative of the state vector z.\n        z = [x, y, vx, vy]\n        \"\"\"\n        x, y, vx, vy = z\n        # Constraint function g(q) = x^2 + y^2 - R^2\n        g = x**2 + y**2 - R**2\n        \n        # Accelerations from penalty force F = -nabla(U)\n        ax = (-2.0 * k_val * x * g) / m\n        ay = (-2.0 * k_val * y * g) / m\n        \n        return np.array([vx, vy, ax, ay])\n\n    for k in test_cases:\n        # Initial state vector z = [x, y, vx, vy]\n        z = np.array([R, 0.0, 0.0, v0])\n        \n        # Initialize metrics for this case\n        max_violation = 0.0\n        stable = True\n        \n        # Calculate violation at the initial state (t=0)\n        violation = np.abs(np.sqrt(z[0]**2 + z[1]**2) - R)\n        max_violation = max(max_violation, violation)\n\n        # Determine the number of steps\n        num_steps = int(round(T / h))\n\n        # Time-stepping loop\n        for _ in range(num_steps):\n            # RK4 integration step\n            k1 = f(z, k)\n            k2 = f(z + 0.5 * h * k1, k)\n            k3 = f(z + 0.5 * h * k2, k)\n            k4 = f(z + h * k3, k)\n            z = z + (h / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n            # Check for instability\n            norm_z = np.linalg.norm(z)\n            if not np.isfinite(norm_z) or norm_z >= M_th:\n                stable = False\n                break  # Terminate simulation for this k value\n\n            # Calculate constraint violation and update the maximum\n            violation = np.abs(np.sqrt(z[0]**2 + z[1]**2) - R)\n            max_violation = max(max_violation, violation)\n        \n        # Store the results for this case\n        results.append(max_violation)\n        results.append(stable)\n\n    # Format and print the final output\n    # Example format: [0.0123,True,-0.0045,True,...]\n    # The str() for a boolean correctly produces 'True' or 'False'\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3199683"}, {"introduction": "许多物理定律最初都是以高阶常微分方程的形式出现的，例如振动、波动和扩散等现象。然而，大多数通用的数值求解器都要求将问题表述为一阶ODE系统。本练习将指导您完成这一关键转化过程，将描述振动梁的四阶欧拉-伯努利方程转换为一个等效的一阶ODE系统。与前面的初值问题不同，您将把这个系统作为一个边值问题（BVP）来解决，这是结构工程和许多其他物理科学领域中的一项核心计算任务。[@problem_id:2444880]", "problem": "考虑一根细长的棱柱形Euler–Bernoulli梁，在分布载荷作用下进行小振幅、时谐横向振动。令 $x \\in [0,L]$ 表示沿梁的轴向坐标，$t$ 表示时间，$w(x,t)$ 表示横向挠度。假设对分布载荷 $q(x,t) = \\Re\\{q(x)\\,\\mathrm{e}^{\\mathrm{i}\\,\\omega t}\\}$ 的稳态谐波响应形式为 $w(x,t) = \\Re\\{Y(x)\\,\\mathrm{e}^{\\mathrm{i}\\,\\omega t}\\}$，其中 $Y(x)$ 和 $q(x)$ 是实值振幅，$\\omega$ 是角频率，单位为弧度/秒。忽略阻尼和转动惯量。在这些假设下，控制方程简化为关于 $x$ 的四阶常微分方程\n$$\nE I\\,\\frac{\\mathrm{d}^{4} Y}{\\mathrm{d} x^{4}}(x) - \\rho A\\,\\omega^{2} Y(x) = q(x),\n$$\n悬臂梁的边界条件为（在 $x=0$ 处夹紧，在 $x=L$ 处自由）\n$$\nY(0)=0,\\quad Y'(0)=0,\\quad Y''(L)=0,\\quad Y'''(L)=0.\n$$\n此处，$E$ 是杨氏模量，$I$ 是截面二次矩，$\\rho$ 是材料的质量密度，$A$ 是横截面积，$L$ 是梁的长度。分布载荷的振幅指定为 $q(x) = q_{0}\\,\\sin\\!\\big(\\pi x/L\\big)$。\n\n任务：\n- 将关于 $x$ 的单个四阶常微分方程转换为一个等效的、包含四个耦合一阶常微分方程的方程组。\n- 对下面测试套件中的每一组参数，在区间 $x \\in [0,L]$ 上求解得到的边界值问题以获得 $Y(x)$。\n- 对每种情况，报告梁尖端的挠度振幅 $Y(L)$。\n\n所有输入参数均使用国际单位制 (SI)。报告所有梁尖端挠度振幅，单位为米，使用科学记数法，并四舍五入到小数点后六位。\n\n测试套件：\n- 情况1（一般情况）：$E = 210\\times 10^{9}\\,\\mathrm{Pa}$，$I = 1.0\\times 10^{-6}\\,\\mathrm{m}^{4}$，$\\rho = 7800\\,\\mathrm{kg/m^{3}}$，$A = 1.0\\times 10^{-3}\\,\\mathrm{m}^{2}$，$L = 2.0\\,\\mathrm{m}$，$q_{0} = 100.0\\,\\mathrm{N/m}$，$\\omega = 50.0\\,\\mathrm{rad/s}$。\n- 情况2（零载荷边缘情况）：$E = 210\\times 10^{9}\\,\\mathrm{Pa}$，$I = 1.0\\times 10^{-6}\\,\\mathrm{m}^{4}$，$\\rho = 7800\\,\\mathrm{kg/m^{3}}$，$A = 1.0\\times 10^{-3}\\,\\mathrm{m}^{2}$，$L = 2.0\\,\\mathrm{m}$，$q_{0} = 0.0\\,\\mathrm{N/m}$，$\\omega = 50.0\\,\\mathrm{rad/s}$。\n- 情况3（准静态状态）：$E = 70\\times 10^{9}\\,\\mathrm{Pa}$，$I = 5.0\\times 10^{-6}\\,\\mathrm{m}^{4}$，$\\rho = 2700\\,\\mathrm{kg/m^{3}}$，$A = 2.0\\times 10^{-3}\\,\\mathrm{m}^{2}$，$L = 1.0\\,\\mathrm{m}$，$q_{0} = 1000.0\\,\\mathrm{N/m}$，$\\omega = 0.01\\,\\mathrm{rad/s}$。\n- 情况4（刚性梁）：$E = 210\\times 10^{9}\\,\\mathrm{Pa}$，$I = 5.0\\times 10^{-5}\\,\\mathrm{m}^{4}$，$\\rho = 7800\\,\\mathrm{kg/m^{3}}$，$A = 1.0\\times 10^{-3}\\,\\mathrm{m}^{2}$，$L = 2.0\\,\\mathrm{m}$，$q_{0} = 100.0\\,\\mathrm{N/m}$，$\\omega = 20.0\\,\\mathrm{rad/s}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含四个尖端挠度振幅，以逗号分隔的列表形式，并用方括号括起来，例如，“[v1,v2,v3,v4]”。\n- 每个条目使用科学记数法，小数点后精确到六位，且无空格，例如，“[1.234567e-03,0.000000e+00, ...]”。\n- 数值单位必须是米。", "solution": "第一步是将单个四阶常微分方程（ODE）转换为一个等效的一阶ODE系统。这是一种标准技术。我们定义一个包含四个分量的状态向量 $\\mathbf{y}(x)$：\n$$\n\\begin{aligned}\n    y_1(x) = Y(x)    \\text{（挠度）} \\\\\n    y_2(x) = Y'(x)    \\text{（转角）} \\\\\n    y_3(x) = Y''(x)    \\text{（与弯矩成正比，$M=EIY''$）} \\\\\n    y_4(x) = Y'''(x)    \\text{（与剪力成正比，$V=EIY'''$）}\n\\end{aligned}\n$$\n通过对每个分量关于 $x$ 求导，我们可以用状态向量分量本身来表示它们的导数：\n$$\n\\begin{aligned}\n    y_1'(x) = y_2(x) \\\\\n    y_2'(x) = y_3(x) \\\\\n    y_3'(x) = y_4(x)\n\\end{aligned}\n$$\n第四个分量的导数 $y_4'(x) = Y''''(x)$ 可通过重新整理控制ODE得到：\n$$\n\\frac{\\mathrm{d}^{4} Y}{\\mathrm{d} x^{4}}(x) = \\frac{\\rho A \\omega^2}{EI} Y(x) + \\frac{q(x)}{EI}\n$$\n代入状态向量分量和给定的载荷函数 $q(x) = q_0\\sin(\\pi x/L)$：\n$$\ny_4'(x) = \\frac{\\rho A \\omega^2}{EI} y_1(x) + \\frac{q_0}{EI} \\sin\\left(\\frac{\\pi x}{L}\\right)\n$$\n这构成了一个线性一阶ODE系统，可以写成矩阵形式 $\\mathbf{y}'(x) = \\mathbf{F}(x, \\mathbf{y}(x))$：\n$$\n\\frac{d}{dx}\n\\begin{pmatrix}\ny_1 \\\\\ny_2 \\\\\ny_3 \\\\\ny_4\n\\end{pmatrix}\n=\n\\begin{pmatrix}\ny_2 \\\\\ny_3 \\\\\ny_4 \\\\\n\\frac{\\rho A \\omega^2}{EI} y_1 + \\frac{q_0}{EI} \\sin\\left(\\frac{\\pi x}{L}\\right)\n\\end{pmatrix}\n$$\n该系统必须在满足边界条件的约束下求解。用状态向量表示，悬臂梁的条件为：\n-   在夹紧端，$x=0$： $y_1(0) = 0$, $y_2(0) = 0$\n-   在自由端，$x=L$： $y_3(L) = 0$, $y_4(L) = 0$\n\n这构成了一个两点边界值问题（BVP）。我们将使用合适的数值算法对此BVP进行求解，例如`scipy.integrate.solve_bvp`函数，该函数实现了一种对此类问题既高效又准确的配置法。\n\n数值计算步骤如下：\n1.  定义一个函数来表示ODE系统，该函数以 $x$ 和 $\\mathbf{y}$ 作为输入，并返回 $\\mathbf{y}'$。\n2.  定义一个用于边界条件的函数，该函数计算四个条件的残差：$[y_1(0), y_2(0), y_3(L), y_4(L)]$。\n3.  为定义域 $[0,L]$ 创建一个初始点网格，并在该网格上为解 $\\mathbf{y}(x)$ 提供一个初始猜测（例如，全零）。\n4.  使用ODE函数、边界条件函数、初始网格和初始猜测调用数值求解器。\n5.  一旦找到解，就可以从得到的解对象中评估出梁尖端的挠度值，$Y(L) = y_1(L)$。\n\n对问题陈述中提供的四个测试用例中的每一个重复此过程，即可得到所需的结果。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_bvp\n\ndef solve():\n    \"\"\"\n    Solves the Euler-Bernoulli beam BVP for four test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (general)\n        {\n            \"E\": 210.0e9, \"I\": 1.0e-6, \"rho\": 7800.0, \"A\": 1.0e-3,\n            \"L\": 2.0, \"q0\": 100.0, \"omega\": 50.0\n        },\n        # Case 2 (zero load edge case)\n        {\n            \"E\": 210.0e9, \"I\": 1.0e-6, \"rho\": 7800.0, \"A\": 1.0e-3,\n            \"L\": 2.0, \"q0\": 0.0, \"omega\": 50.0\n        },\n        # Case 3 (quasi-static regime)\n        {\n            \"E\": 70.0e9, \"I\": 5.0e-6, \"rho\": 2700.0, \"A\": 2.0e-3,\n            \"L\": 1.0, \"q0\": 1000.0, \"omega\": 0.01\n        },\n        # Case 4 (stiff beam)\n        {\n            \"E\": 210.0e9, \"I\": 5.0e-5, \"rho\": 7800.0, \"A\": 1.0e-3,\n            \"L\": 2.0, \"q0\": 100.0, \"omega\": 20.0\n        }\n    ]\n\n    def ode_system(x, y, p):\n        \"\"\"\n        Defines the system of 4 first-order ODEs.\n        y is a vector [y1, y2, y3, y4]\n        y1 = Y, y2 = Y', y3 = Y'', y4 = Y'''\n        p is a tuple of parameters (E, I, rho, A, L, q0, omega)\n        \"\"\"\n        E, I, rho, A, L, q0, omega = p\n        \n        dy1_dx = y[1]\n        dy2_dx = y[2]\n        dy3_dx = y[3]\n\n        q_x = q0 * np.sin(np.pi * x / L)\n        \n        # From EI Y'''' - rho*A*omega^2*Y = q(x)\n        dy4_dx = (rho * A * omega**2 * y[0] + q_x) / (E * I)\n\n        return np.vstack((dy1_dx, dy2_dx, dy3_dx, dy4_dx))\n\n    def boundary_conditions(ya, yb, p):\n        \"\"\"\n        Defines the boundary conditions for the cantilever beam.\n        ya: solution at x=0\n        yb: solution at x=L\n        BCs: Y(0)=0, Y'(0)=0, Y''(L)=0, Y'''(L)=0\n        In state vector terms: y1(0)=0, y2(0)=0, y3(L)=0, y4(L)=0\n        \"\"\"\n        return np.array([ya[0], ya[1], yb[2], yb[3]])\n\n    results = []\n\n    for case in test_cases:\n        p = (\n            case[\"E\"], case[\"I\"], case[\"rho\"], case[\"A\"],\n            case[\"L\"], case[\"q0\"], case[\"omega\"]\n        )\n        L = case[\"L\"]\n\n        # Set up the initial mesh and guess for the solution\n        x_mesh = np.linspace(0, L, 201)  # 201 points for good resolution\n        y_guess = np.zeros((4, x_mesh.size))\n\n        # Solve the boundary value problem\n        sol = solve_bvp(\n            lambda x, y: ode_system(x, y, p),\n            lambda ya, yb: boundary_conditions(ya, yb, p),\n            x_mesh,\n            y_guess,\n            tol=1e-8\n        )\n        \n        # As a check, for q0=0 and omega != natural frequency, solution must be trivial\n        if case[\"q0\"] == 0.0:\n            tip_deflection = 0.0\n        else:\n            if sol.success:\n                # Evaluate the solution at the tip of the beam (x=L)\n                # sol.sol(L)[0] corresponds to y1(L) = Y(L)\n                tip_deflection = sol.sol(L)[0]\n            else:\n                # This should not happen for the given test cases\n                tip_deflection = np.nan\n\n        # Format the result to scientific notation with 6 decimal places\n        results.append(f\"{tip_deflection:.6e}\")\n    \n    # Print the final result in the specified format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2444880"}]}