{"hands_on_practices": [{"introduction": "本练习旨在帮助你掌握欧拉方法的基本计算流程。通过手动执行几个迭代步骤，你将具体地感受到该方法如何利用每一点的切线来预测解曲线上的下一个点。这个基础练习是理解更复杂数值方法的关键第一步 [@problem_id:2172203]。", "problem": "在一个特定电气元件动力学的简化模型中，某个相位角 $y(t)$（以弧度为单位）的时间演化由微分方程 $y' = t + \\sin(y)$ 描述。这里，$t$ 是时间，单位是秒。系统在 $t=0$ 时的初始状态由 $y(0) = \\pi$ 给出。\n\n你的任务是近似计算在 $t=0.2$ 秒时相位角的值。使用步长为 $h=0.1$ 的欧拉方法来进行此近似计算。\n\n你的最终答案以弧度为单位给出，并四舍五入到五位有效数字。", "solution": "我们对初值问题 $y' = f(t,y) = t + \\sin(y)$（其中 $y(0) = \\pi$ 且步长 $h = 0.1$）应用前向欧拉方法。迭代公式为\n$$\ny_{n+1} = y_{n} + h\\,f(t_{n}, y_{n}), \\quad t_{n+1} = t_{n} + h.\n$$\n初始化 $t_{0} = 0$ 和 $y_{0} = \\pi$。\n\n第一步，计算至 $t_{1} = 0.1$：\n$$\nf(t_{0}, y_{0}) = f(0, \\pi) = 0 + \\sin(\\pi) = 0,\n$$\n$$\ny_{1} = y_{0} + h\\,f(t_{0}, y_{0}) = \\pi + 0.1 \\cdot 0 = \\pi.\n$$\n\n第二步，计算至 $t_{2} = 0.2$：\n$$\nf(t_{1}, y_{1}) = f(0.1, \\pi) = 0.1 + \\sin(\\pi) = 0.1,\n$$\n$$\ny_{2} = y_{1} + h\\,f(t_{1}, y_{1}) = \\pi + 0.1 \\cdot 0.1 = \\pi + 0.01.\n$$\n因此，在 $t=0.2$ 时的欧拉近似值为 $y(0.2) \\approx \\pi + 0.01$。以小数形式表示，$\\pi + 0.01 \\approx 3.1515926535\\ldots$，四舍五入到五位有效数字为 $3.1516$。", "answer": "$$\\boxed{3.1516}$$", "id": "2172203"}, {"introduction": "本练习探讨了数值方法中最关键的方面之一：步长 $h$ 的选择。通过对同一问题使用不同步长进行求解并比较结果，我们可以直接观察到步长的选择如何影响近似的准确性。这有助于我们建立关于计算成本与精度之间权衡的直观理解 [@problem_id:2172241]。", "problem": "考虑由常微分方程 $y'(t) = -2y(t)$ 和初始条件 $y(0) = 1$ 给出的初值问题（IVP）。我们希望使用欧拉方法来近似 $y(1)$ 的值。\n\n设 $A_1$ 是使用欧拉方法，步长为 $h=1$ 进行单步计算得到的 $y(1)$ 的近似值。\n设 $A_{0.5}$ 是使用欧拉方法，每步步长为 $h=0.5$ 进行两步计算得到的 $y(1)$ 的近似值。\n\n计算表达式 $3A_1 - 2A_{0.5}$ 的值。", "solution": "我们应用显式欧拉方法，对于一个初值问题 $y'(t)=f(t,y)$，步长为 $h$ 的更新公式为\n$$\ny_{n+1}=y_{n}+h\\,f(t_{n},y_{n}).\n$$\n这里 $f(t,y)=-2y$，所以\n$$\ny_{n+1}=y_{n}+h(-2y_{n})=y_{n}(1-2h).\n$$\n\n使用 $h=1$ 从 $t_{0}=0$ 到 $t_{1}=1$ 进行单步计算：\n$$\ny_{1}=y_{0}(1-2\\cdot 1)=1\\cdot(-1)=-1,\n$$\n所以 $A_{1}=-1$。\n\n使用 $h=0.5$ 从 $t_{0}=0$ 到 $t_{2}=1$ 进行两步计算：\n第一步到 $t_{1}=0.5$：\n$$\ny_{1}=y_{0}(1-2\\cdot 0.5)=1\\cdot(1-1)=0.\n$$\n第二步到 $t_{2}=1$：\n$$\ny_{2}=y_{1}(1-2\\cdot 0.5)=0\\cdot(1-1)=0,\n$$\n所以 $A_{0.5}=0$。\n\n因此，\n$$\n3A_{1}-2A_{0.5}=3(-1)-2(0)=-3.\n$$", "answer": "$$\\boxed{-3}$$", "id": "2172241"}, {"introduction": "从手动计算到计算思维的转变，这个高级练习挑战你高效地实现欧拉方法。你将利用向量化技术同时求解数千个微分方程——这是现代科学计算的核心技术，并在此过程中直面数值稳定性的实际问题。这个练习将理论与大规模计算实践联系起来 [@problem_id:3226233]。", "problem": "要求您设计并实现一个全向量化的显式欧拉求解器，用于求解一族独立的线性常微分方程。目标是利用数组操作同时推进数千个独立的初值问题，而无需为每个方程编写循环。\n\n基本原理是初值问题和导数的定义。一个初值问题指定了一个满足微分方程和初始条件的函数 $y(t)$：$y'(t) = f(t,y(t))$，其中 $y(0) = y_0$。导数的定义为 $y'(t) = \\lim_{h \\to 0} \\dfrac{y(t+h) - y(t)}{h}$。显式欧拉方法基于 $y(t)$ 的一阶泰勒展开，它使用在当前时间点计算的导数来近似前向增量。\n\n为以下由 $i \\in \\{0,1,\\dots,N-1\\}$ 索引的一族独立标量方程实现该方法：\n$$\n\\frac{d y_i}{d t} = a_i\\, y_i + b_i, \\quad y_i(0) = y_{0,i}, \\quad t \\in [0, T].\n$$\n您必须：\n- 严格按照下面测试套件中的规定，构建参数数组 $\\{a_i\\}_{i=0}^{N-1}$、$\\{b_i\\}_{i=0}^{N-1}$ 和 $\\{y_{0,i}\\}_{i=0}^{N-1}$。\n- 使用统一的步长 $h$ 和 $M = T/h$ 个步数，同步推进所有 $N$ 个方程，并计算在 $t=T$ 时的数值近似解 $\\{y_i^{E}(T)\\}_{i=0}^{N-1}$。\n- 计算解析解 $\\{y_i^{\\ast}(T)\\}_{i=0}^{N-1}$ 以进行比较。对于 $a_i \\neq 0$，微分方程 $\\dfrac{d y}{dt} = a_i y + b_i$ 在初始条件 $y(0) = y_{0,i}$ 下的解为\n$$\ny_i^{\\ast}(t) = \\left(y_{0,i} + \\frac{b_i}{a_i}\\right) e^{a_i t} - \\frac{b_i}{a_i}.\n$$\n对于 $a_i = 0$，解简化为\n$$\ny_i^{\\ast}(t) = y_{0,i} + b_i t.\n$$\n精确处理 $a_i = 0$ 的情况，而不是通过极限近似。\n\n误差度量：\n- 将每个方程在最终时刻的绝对误差定义为 $e_i = \\left| y_i^{E}(T) - y_i^{\\ast}(T) \\right|$。\n- 对于每个测试用例，根据指定的度量标准对 $\\{e_i\\}$ 进行汇总。\n\n测试套件（四个用例）以确保覆盖率：\n1. 正常路径，参数平滑变化：\n   - $N = 2048$，$T = 1$，$h = 0.001$（因此 $M = 1000$）。\n   - 对于 $i \\in \\{0,1,\\dots,N-1\\}$，\n     - $a_i = -1 + \\dfrac{2 i}{N - 1}$，\n     - $b_i = 0.3 \\sin\\!\\left(\\dfrac{3 i}{N}\\right)$，\n     - $y_{0,i} = 1.0 + 0.2 \\cos\\!\\left(\\dfrac{5 i}{N}\\right)$。\n   - 输出最大绝对误差 $\\max_i e_i$（浮点数）。\n\n2. 边界情况，$a_i$ 中存在精确的零值：\n   - $N = 1024$，$T = 1$，$h = 0.01$（因此 $M = 100$）。\n   - 对于 $i \\in \\{0,1,\\dots,N-1\\}$，令 $r_i = i \\bmod 4$，\n     - $a_i = 0.5 (r_i - 2)$，其值在 $-1.0, -0.5, 0.0, 0.5$ 之间循环，\n     - $b_i = 0.25 \\cos(\\pi i)$，\n     - $y_{0,i} = 0.75 + 0.1 \\sin\\!\\left(\\dfrac{2\\pi i}{N}\\right)$。\n   - 输出平均绝对误差 $\\dfrac{1}{N} \\sum_{i=0}^{N-1} e_i$（浮点数）。\n\n3. 稳定性挑战用例：\n   - $N = 512$，$T = 1$，$h = 0.25$（因此 $M = 4$）。\n   - 对于所有 $i$，$a_i = -10.0$，$b_i = 0.0$，以及 $y_{0,i} = 1.0 + \\dfrac{i}{N}$。\n   - 输出最大绝对误差 $\\max_i e_i$（浮点数）。\n\n4. 单方程检验：\n   - $N = 1$，$T = 1$，$h = 0.05$（因此 $M = 20$）。\n   - 参数：$a_0 = 0.3$，$b_0 = -0.1$，$y_{0,0} = 2.0$。\n   - 输出绝对误差 $e_0$（浮点数）。\n\n实现要求：\n- 该方法必须使用数组操作对 $N$ 个方程进行向量化；不要编写关于 $i$ 的循环。\n- 仅使用一个关于时间步的循环，在每个步长将显式欧拉增量同时应用于所有 $N$ 个方程。\n- 使用分段向量化表达式计算精确解，以正确处理 $a_i = 0$ 的情况。\n- 您的程序应生成单行输出，其中包含按测试用例 1 到 4 的顺序排列的结果，格式为逗号分隔的列表并用方括号括起（例如，“[result1,result2,result3,result4]”）。", "solution": "用户希望使用向量化的显式欧拉方法求解一个独立线性常微分方程组。\n\n### 步骤 1：提取已知条件\n- **ODE 族**：$\\dfrac{d y_i}{d t} = a_i\\, y_i + b_i$，其中 $i \\in \\{0, 1, \\dots, N-1\\}$。\n- **初始条件**：$y_i(0) = y_{0,i}$。\n- **时间区间**：$t \\in [0, T]$。\n- **数值方法**：采用统一时间步长 $h$ 的显式欧拉方法。步数为 $M = T/h$。\n- **T 时刻的数值解**：$\\{y_i^{E}(T)\\}_{i=0}^{N-1}$。\n- **$a_i \\neq 0$ 时的解析解**：$y_i^{\\ast}(t) = \\left(y_{0,i} + \\frac{b_i}{a_i}\\right) e^{a_i t} - \\frac{b_i}{a_i}$。\n- **$a_i = 0$ 时的解析解**：$y_i^{\\ast}(t) = y_{0,i} + b_i t$。\n- **误差度量**：绝对误差 $e_i = \\left| y_i^{E}(T) - y_i^{\\ast}(T) \\right|$。按 $\\max_i e_i$ 或 $\\frac{1}{N} \\sum_{i=0}^{N-1} e_i$ 汇总。\n\n- **测试用例 1**：\n    - $N = 2048$，$T = 1$，$h = 0.001$。\n    - $a_i = -1 + \\dfrac{2 i}{N - 1}$。\n    - $b_i = 0.3 \\sin\\!\\left(\\dfrac{3 i}{N}\\right)$。\n    - $y_{0,i} = 1.0 + 0.2 \\cos\\!\\left(\\dfrac{5 i}{N}\\right)$。\n    - 输出：$\\max_i e_i$。\n\n- **测试用例 2**：\n    - $N = 1024$，$T = 1$，$h = 0.01$。\n    - $r_i = i \\bmod 4$。\n    - $a_i = 0.5 (r_i - 2)$。\n    - $b_i = 0.25 \\cos(\\pi i)$。\n    - $y_{0,i} = 0.75 + 0.1 \\sin\\!\\left(\\dfrac{2\\pi i}{N}\\right)$。\n    - 输出：$\\dfrac{1}{N} \\sum_{i=0}^{N-1} e_i$。\n\n- **测试用例 3**：\n    - $N = 512$，$T = 1$，$h = 0.25$。\n    - $a_i = -10.0$。\n    - $b_i = 0.0$。\n    - $y_{0,i} = 1.0 + \\dfrac{i}{N}$。\n    - 输出：$\\max_i e_i$。\n\n- **测试用例 4**：\n    - $N = 1$，$T = 1$，$h = 0.05$。\n    - $a_0 = 0.3$，$b_0 = -0.1$，$y_{0,0} = 2.0$。\n    - 输出：$e_0$。\n\n- **实现要求**：使用数组操作进行向量化实现，无关于索引 $i$ 的循环。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学性**：该问题基于一阶线性常微分方程的成熟理论及其数值解的标准显式欧拉方法。所有概念都是微积分和数值分析的基础。\n- **适定性**：指定的每个初值问题都有唯一解。所有测试用例的参数和初始条件都明确定义，确保了结果的唯一性和可计算性。评估一种数值方法（包括在不稳定的情况下，如用例3）是科学计算中的一个标准且适定的任务。\n- **客观性**：该问题使用精确的数学语言和定义进行陈述。要求是定量且可验证的。没有主观或模棱两可的陈述。\n\n该问题没有违反任何无效标准。它在科学上是合理的，形式上是明确的，并且是客观的。测试用例经过精心设计，用于验证实现的不同方面，例如参数变化的处理、$a_i=0$ 的特殊情况以及数值稳定性。\n\n### 步骤 3：结论与行动\n该问题是有效的。将提供一个合理的解决方案。\n\n该问题要求实现一个向量化的显式欧拉求解器，用于求解 $N$ 个独立的线性常微分方程组。核心原则是用数组操作代替对单个方程的循环，这在像 `NumPy` 这样的计算环境中效率要高得多。\n\nODE 族由以下公式给出：\n$$\n\\frac{d y_i}{d t} = a_i y_i + b_i, \\quad y_i(0) = y_{0,i}\n$$\n在向量表示法中，其中 $\\mathbf{y}(t) = [y_0(t), y_1(t), \\dots, y_{N-1}(t)]^T$，$\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{y}_0$ 的表示类似，该方程组可以写成：\n$$\n\\frac{d \\mathbf{y}}{d t} = \\mathbf{a} \\odot \\mathbf{y} + \\mathbf{b}\n$$\n其中 $\\odot$ 表示逐元素（哈达玛）积。\n\n显式欧拉方法使用在当前时间 $t_k$ 周围的一阶泰勒展开来近似下一个时间步 $t_{k+1} = t_k + h$ 的解：\n$$\ny(t_{k+1}) \\approx y(t_k) + h \\frac{d y}{d t}\\bigg|_{t_k}\n$$\n令 $\\mathbf{y}^k$ 为 $\\mathbf{y}(t_k)$ 的数值近似。将 ODE 系统代入泰勒近似，得到整个解向量的更新规则：\n$$\n\\mathbf{y}^{k+1} = \\mathbf{y}^k + h (\\mathbf{a} \\odot \\mathbf{y}^k + \\mathbf{b})\n$$\n此更新在循环中执行 $M = T/h$ 个时间步，从初始条件向量 $\\mathbf{y}^0 = \\mathbf{y}_0$ 开始。这种方法是完全向量化的，避免了任何对索引 $i$ 的显式循环。\n\n为了评估数值解的准确性，我们将其与最终时间 $T$ 的精确解析解进行比较。问题提供了闭式解，它取决于 $a_i$ 是否为零。\n对于 $a_i \\neq 0$：\n$$\ny_i^{\\ast}(T) = \\left(y_{0,i} + \\frac{b_i}{a_i}\\right) e^{a_i T} - \\frac{b_i}{a_i}\n$$\n对于 $a_i = 0$，ODE 简化为 $\\frac{d y_i}{d t} = b_i$，积分后得到：\n$$\ny_i^{\\ast}(T) = y_{0,i} + b_i T\n$$\n在向量化实现中，必须正确处理这两种情况，而不能中断基于数组的计算。通过使用条件数组操作（例如 `numpy.where`）可以高效地实现这一点，它根据布尔条件从两个数组中选择元素，从而避免了在 $a_i=0$ 时出现除以零的情况。\n\n每个测试用例的最后一步是计算绝对误差向量 $\\mathbf{e} = |\\mathbf{y}^{E}(T) - \\mathbf{y}^{\\ast}(T)|$，然后按指定方式对其分量进行汇总，即取最大值或平均值。\n\n该实现将包含一个主函数，该函数会遍历四个测试用例。将设计一个辅助函数来执行单个用例的计算，其中包括：\n1. 根据特定用例的规则生成参数向量 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{y}_0$。\n2. 使用 $\\mathbf{y}_0$ 初始化解向量 $\\mathbf{y}$。\n3. 迭代 $M$ 次，在每一步应用向量化的欧拉更新。\n4. 使用条件逻辑为 $a_i=0$ 的情况计算精确解向量 $\\mathbf{y}^{\\ast}(T)$。\n5. 计算误差向量和所需的汇总度量。\n\n一个值得注意的方面是测试用例3，其中 $a_i = -10$ 且 $h = 0.25$。对于显式欧拉方法，方程 $y' = \\lambda y$（其中 $\\lambda  0$）的稳定性条件是 $|1 + h\\lambda| \\le 1$，可简化为 $h\\lambda \\ge -2$。在这种情况下，$h a_i = 0.25 \\times (-10) = -2.5$，这违反了稳定性条件。我们预计数值解会表现出大的、振荡的误差，这是关于该方法局限性的一个正确且重要的观察。算法仍必须按要求计算出这个不稳定的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    def run_euler_test_case(N, T, h, a_func, b_func, y0_func, metric):\n        \"\"\"\n        Solves a single test case for the vectorized Euler method.\n\n        Args:\n            N (int): Number of independent equations.\n            T (float): Final time.\n            h (float): Step size.\n            a_func (function): Function to generate parameter vector 'a'.\n            b_func (function): Function to generate parameter vector 'b'.\n            y0_func (function): Function to generate initial conditions 'y0'.\n            metric (str): The error aggregation metric ('max' or 'mean').\n\n        Returns:\n            float: The aggregated error metric.\n        \"\"\"\n        # 1. Construct parameter arrays\n        i = np.arange(N, dtype=float)\n        a = a_func(i, N)\n        b = b_func(i, N)\n        y0 = y0_func(i, N)\n\n        # 2. Advance all N equations using explicit Euler method\n        y_euler = y0.copy()\n        num_steps = int(round(T / h))\n\n        for _ in range(num_steps):\n            # Vectorized update rule: y_new = y_old + h * (a * y_old + b)\n            y_euler += h * (a * y_euler + b)\n\n        # 3. Compute the closed-form solution\n        y_exact = np.zeros(N, dtype=float)\n        \n        # Mask for a_i == 0 to handle cases separately\n        mask_zero_a = (a == 0)\n        \n        # Case a_i != 0\n        a_nonzero = a[~mask_zero_a]\n        y0_nonzero = y0[~mask_zero_a]\n        b_nonzero = b[~mask_zero_a]\n        y_exact[~mask_zero_a] = \\\n            (y0_nonzero + b_nonzero / a_nonzero) * np.exp(a_nonzero * T) - (b_nonzero / a_nonzero)\n        \n        # Case a_i == 0\n        y0_zero = y0[mask_zero_a]\n        b_zero = b[mask_zero_a]\n        y_exact[mask_zero_a] = y0_zero + b_zero * T\n        \n        # 4. Compute error metrics\n        errors = np.abs(y_euler - y_exact)\n        \n        if metric == 'max':\n            return np.max(errors)\n        elif metric == 'mean':\n            return np.mean(errors)\n        elif metric == 'single':\n            return errors[0]\n        else:\n            raise ValueError(\"Invalid metric specified\")\n\n    # Define test cases from the problem statement\n    test_cases = [\n        {\n            \"N\": 2048, \"T\": 1.0, \"h\": 0.001,\n            \"a_func\": lambda i, N: -1.0 + 2.0 * i / (N - 1) if N > 1 else np.array([-1.0]),\n            \"b_func\": lambda i, N: 0.3 * np.sin(3.0 * i / N),\n            \"y0_func\": lambda i, N: 1.0 + 0.2 * np.cos(5.0 * i / N),\n            \"metric\": \"max\"\n        },\n        {\n            \"N\": 1024, \"T\": 1.0, \"h\": 0.01,\n            \"a_func\": lambda i, N: 0.5 * ((i % 4) - 2.0),\n            \"b_func\": lambda i, N: 0.25 * np.cos(np.pi * i),\n            \"y0_func\": lambda i, N: 0.75 + 0.1 * np.sin(2.0 * np.pi * i / N),\n            \"metric\": \"mean\"\n        },\n        {\n            \"N\": 512, \"T\": 1.0, \"h\": 0.25,\n            \"a_func\": lambda i, N: np.full(N, -10.0),\n            \"b_func\": lambda i, N: np.zeros(N),\n            \"y0_func\": lambda i, N: 1.0 + i / N,\n            \"metric\": \"max\"\n        },\n        {\n            \"N\": 1, \"T\": 1.0, \"h\": 0.05,\n            \"a_func\": lambda i, N: np.array([0.3]),\n            \"b_func\": lambda i, N: np.array([-0.1]),\n            \"y0_func\": lambda i, N: np.array([2.0]),\n            \"metric\": \"single\"\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_euler_test_case(\n            case[\"N\"], case[\"T\"], case[\"h\"],\n            case[\"a_func\"], case[\"b_func\"], case[\"y0_func\"],\n            case[\"metric\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```", "id": "3226233"}]}