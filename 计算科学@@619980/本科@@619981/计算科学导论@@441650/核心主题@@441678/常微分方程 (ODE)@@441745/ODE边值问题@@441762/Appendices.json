{"hands_on_practices": [{"introduction": "要掌握任何数值方法，最好的起点都是通过一个已知精确解的问题来验证我们的代码。这个练习将指导你完成这个基本过程。我们将使用“制造解法”，从一个给定的精确解 $u(x) = \\exp(x) - x$ 出发，反向推导出它所满足的边值问题，然后用有限差分法求解并验证我们程序的准确性 [@problem_id:3104017]。这个过程是计算科学中验证和确认数值算法的基石。", "problem": "考虑以下针对区间 $[0,1]$ 上常微分方程 (ODE) 的线性两点边值问题 (BVP) 的制造解基准问题。指定精确解为 $u(x)=e^{x}-x$，狄利克雷边界条件为 $u(0)=1$ 和 $u(1)=e-1$。您的任务是：\n\n1) 推导一个线性的、常系数的、右侧为多项式的二阶常微分方程，使得精确解 $u(x)=e^{x}-x$ 满足该常微分方程和边界条件。从一阶和二阶导数的定义出发，计算 $u'(x)$ 和 $u''(x)$ 以构建形式为 $u''(x)-u(x)=g(x)$ 的常微分方程，然后确定使 $u(x)$ 成为精确解的 $g(x)$。\n\n2) 在均匀网格 $x_{i}=ih$（其中 $i\\in\\{0,1,\\dots,N+1\\}$，$N$ 是内部点数，$h=1/(N+1)$）上离散化所得的边值问题。使用从泰勒展开推导出的二阶导数的中心差分近似，为未知数 $\\{u_{1},u_{2},\\dots,u_{N}\\}$ 建立相应的三对角线性系统，并强制执行边界条件 $u_{0}=1$ 和 $u_{N+1}=e-1$。\n\n3) 实现一个完整的、可运行的程序，该程序：\n- 对测试集 $N\\in\\{1,10,20,40\\}$ 中的每个 $N$ 值，构建并求解三对角线性系统。\n- 重建包含边界值的网格函数，并计算所有网格点 $x_{i}$（$i\\in\\{0,1,\\dots,N+1\\}$）上与精确解 $u(x)=e^{x}-x$ 相比的最大绝对误差。\n- 对每个 $N$，报告最大绝对误差，该误差为一个四舍五入到八位小数的浮点数。\n\n您可以使用的基础知识：\n- 一阶导数 $u'(x)=\\lim_{h\\to 0}\\dfrac{u(x+h)-u(x)}{h}$ 和二阶导数 $u''(x)=\\lim_{h\\to 0}\\dfrac{u(x+h)-2u(x)+u(x-h)}{h^{2}}$ 的定义。\n- 足够光滑的函数在点 $x$ 处的泰勒展开。\n- 求解线性系统的标准线性代数。\n\n科学真实性要求：\n- 纯粹在数学术语下工作，不涉及物理单位。\n- 不涉及角度和百分比。\n\n测试集和输出规范：\n- 使用测试集 $N\\in\\{1,10,20,40\\}$。\n- 对每个 $N$，计算包括端点在内的整个网格上的最大绝对误差。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为按测试集 $N$ 值顺序排列的结果。每个条目必须四舍五入到八位小数。例如，一个包含三个假设结果的输出应如下所示：[$r_{1},$ $r_{2},$ $r_{3}$]，其中每个 $r_{k}$ 都是一个四舍五入到八位小数的十进制数。\n- 程序必须是自包含的，并且不需要用户输入。", "solution": "用户提供的问题是数值分析领域一个定义明确的练习，具体涉及有限差分法在两点边值问题 (BVP) 中的应用。该问题是有效的，因为它在数学上是合理的、自包含的且客观的。它基于微积分和数值方法的既定原理。所有提供的数据，包括制造解和边界条件，都是一致的。\n$u(x) = e^x - x$\n$u(0) = e^0 - 0 = 1$\n$u(1) = e^1 - 1 = e-1$\n边界条件陈述正确。问题将按要求分三部分解决。\n\n### 第一部分：边值问题的推导\n\n问题要求推导一个形式为 $u''(x) - u(x) = g(x)$ 的线性的、常系数的二阶常微分方程，其精确解为 $u(x) = e^x - x$。\n\n首先，我们计算给定解 $u(x)$ 的一阶和二阶导数。\n精确解为：\n$$u(x) = e^x - x$$\n\n一阶导数 $u'(x)$ 为：\n$$u'(x) = \\frac{d}{dx}(e^x - x) = e^x - 1$$\n\n二阶导数 $u''(x)$ 为：\n$$u''(x) = \\frac{d}{dx}(e^x - 1) = e^x$$\n\n现在，我们将 $u(x)$ 和 $u''(x)$ 代入指定形式的常微分方程 $u''(x) - u(x) = g(x)$，以求出右端函数 $g(x)$：\n$$g(x) = u''(x) - u(x) = (e^x) - (e^x - x)$$\n$$g(x) = e^x - e^x + x = x$$\n\n函数 $g(x) = x$ 是一个多项式，符合要求。因此，完整的边值问题是：\n$$\n\\begin{cases}\nu''(x) - u(x) = x,  x \\in [0, 1] \\\\\nu(0) = 1 \\\\\nu(1) = e - 1\n\\end{cases}\n$$\n\n### 第二部分：离散化与线性系统的构建\n\n接下来，我们使用有限差分法在均匀网格上对推导出的边值问题进行离散化。定义域 $[0, 1]$ 被划分为 $N+1$ 个等宽的子区间，宽度为 $h = 1/(N+1)$。网格点为 $x_i = ih$，其中 $i = 0, 1, \\dots, N+1$。解在这些网格点上的值表示为 $u_i = u(x_i)$。\n\n常微分方程 $u''(x) - u(x) = x$ 必须在每个内部网格点 $x_i$（$i = 1, 2, \\dots, N$）上成立：\n$$u''(x_i) - u(x_i) = x_i$$\n\n我们使用二阶中心差分公式来近似二阶导数 $u''(x_i)$：\n$$u''(x_i) \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}$$\n\n将此近似代入常微分方程，得到一个关于未知内部值 $\\{u_1, u_2, \\dots, u_N\\}$ 的代数方程组：\n$$\\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} - u_i = x_i, \\quad \\text{for } i = 1, 2, \\dots, N$$\n\n为构建线性系统，我们重新整理方程，将包含未知数的项归到左侧：\n$$u_{i-1} - 2u_i - h^2 u_i + u_{i+1} = h^2 x_i$$\n$$1 \\cdot u_{i-1} + (-2 - h^2)u_i + 1 \\cdot u_{i+1} = h^2 (ih) = ih^3$$\n\n这组 $N$ 个方程构成一个三对角线性系统 $A\\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u} = [u_1, u_2, \\dots, u_N]^T$。\n\n$N \\times N$ 矩阵 $A$ 具有以下结构：\n- 主对角线元素：$A_{ii} = -2 - h^2$\n- 次对角线元素：$A_{i, i-1} = 1$\n- 超对角线元素：$A_{i, i+1} = 1$\n\n$$A = \\begin{pmatrix}\n-2-h^2  1  0  \\dots  0 \\\\\n1  -2-h^2  1  \\dots  0 \\\\\n0  1  -2-h^2  \\ddots  \\vdots \\\\\n\\vdots  \\ddots  \\ddots  \\ddots  1 \\\\\n0  \\dots  0  1  -2-h^2\n\\end{pmatrix}$$\n\n右端向量 $\\mathbf{b}$ 是一个 $N \\times 1$ 的列向量。我们必须并入给定的狄利克雷边界条件 $u_0 = 1$ 和 $u_{N+1} = e-1$。\n\n对于第一个方程 ($i=1$)：\n$$u_0 + (-2 - h^2)u_1 + u_2 = 1 \\cdot h^3$$\n由于 $u_0 = 1$ 是已知的，我们将其移到右侧：\n$$(-2 - h^2)u_1 + u_2 = h^3 - u_0 = h^3 - 1$$\n因此，向量 $\\mathbf{b}$ 的第一个元素是 $b_1 = h^3 - 1$。\n\n对于最后一个方程 ($i=N$)：\n$$u_{N-1} + (-2 - h^2)u_N + u_{N+1} = N h^3$$\n由于 $u_{N+1} = e-1$ 是已知的，我们将其移到右侧：\n$$u_{N-1} + (-2 - h^2)u_N = Nh^3 - u_{N+1} = Nh^3 - (e-1)$$\n因此，向量 $\\mathbf{b}$ 的最后一个元素是 $b_N = Nh^3 - e + 1$。\n\n对于一般的内部方程 ($i=2, \\dots, N-1$)：\n$$u_{i-1} + (-2-h^2)u_i + u_{i+1} = ih^3$$\n$\\mathbf{b}$ 的相应元素是 $b_i = ih^3$。\n\n总之，右端向量 $\\mathbf{b} = [b_1, b_2, \\dots, b_N]^T$ 是：\n$$b_i = \\begin{cases}\nh^3 - 1  & \\text{if } i=1 \\\\\nih^3  & \\text{if } 2 \\le i \\le N-1 \\\\\nNh^3 - (e-1)  & \\text{if } i=N\n\\end{cases}$$\n此构造能正确处理 $N=1$ 的情况。此时，唯一的方程 $i=1$ 同时是第一个和最后一个，因此右侧项 $b_1$ 必须包含两个边界条件的影响，即 $b_1 = h^3 - u_0 - u_2 = h^3 - 1 - (e-1) = h^3-e$。\n\n### 第三部分：实现算法\n\n对于测试集 $\\{1, 10, 20, 40\\}$ 中的每个 $N$ 值，实现将执行以下步骤：\n1.  **初始化参数**：计算步长 $h = 1/(N+1)$ 和 $e$ 的值。\n2.  **构建线性系统**：\n    -   以适合高效求解器（例如，`scipy.linalg.solve_banded`）的带状格式创建三对角矩阵 $A$。这需要创建一个 $3 \\times N$ 的数组，其中各行分别代表超对角线、主对角线和次对角线。\n    -   根据第二部分推导的公式构造大小为 $N$ 的右端向量 $\\mathbf{b}$。\n3.  **求解系统**：求解线性系统 $A\\mathbf{u} = \\mathbf{b}$，得到内部解的向量 $\\mathbf{u} = [u_1, \\dots, u_N]^T$。\n4.  **重建完整解**：组装完整的数值解向量，包括边界值：$U_{num} = [u_0, u_1, \\dots, u_N, u_{N+1}] = [1, \\mathbf{u}^T, e-1]^T$。\n5.  **计算精确解**：创建网格点向量 $X = [x_0, x_1, \\dots, x_{N+1}]$，其中 $x_i = ih$。在每个网格点上评估精确解 $u(x) = e^x - x$，得到向量 $U_{exact}$。\n6.  **计算误差**：计算所有网格点上数值解与精确解之间的最大绝对误差：$E_{max} = \\max_{i \\in \\{0, \\dots, N+1\\}} |U_{num, i} - U_{exact, i}|$.\n7.  **存储并格式化结果**：将计算出的最大误差四舍五入到八位小数并存储。处理完所有 $N$ 值后，将收集到的结果格式化为指定的字符串格式。\n\n此过程将按要求封装在一个使用 `numpy` 和 `scipy` 库的 Python 程序中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the BVP u''(x) - u(x) = x on [0,1] with u(0)=1, u(1)=e-1\n    using a finite difference scheme for a given set of N values.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [1, 10, 20, 40]\n\n    results = []\n    for N in test_cases:\n        # Step 1: Initialize Parameters\n        # N: number of interior points\n        # There are N+2 total points (including boundaries)\n        h = 1.0 / (N + 1)\n        \n        # Exact boundary values\n        u0 = 1.0\n        uN_plus_1 = np.e - 1.0\n\n        # Step 2: Construct the tridiagonal linear system A*u = b\n        \n        # Construct the tridiagonal matrix A in banded format for SciPy.\n        # The format is a (3, N) array:\n        # Row 0: Super-diagonal (padded with a 0 at the start)\n        # Row 1: Main diagonal\n        # Row 2: Sub-diagonal (padded with a 0 at the end)\n        ab = np.zeros((3, N))\n        ab[0, 1:] = 1.0  # Super-diagonal\n        ab[1, :] = -2.0 - h**2  # Main diagonal\n        ab[2, :-1] = 1.0  # Sub-diagonal\n\n        # Construct the right-hand side vector b\n        # Start with the base value b_i = i * h^3\n        b = np.array([(i + 1) * h**3 for i in range(N)])\n        \n        # Incorporate boundary conditions\n        b[0] -= u0\n        b[-1] -= uN_plus_1\n        \n        # Step 3: Solve the system for the interior points u\n        u_interior = solve_banded((1, 1), ab, b)\n        \n        # Step 4: Reconstruct the full numerical solution grid function\n        u_numerical = np.concatenate(([u0], u_interior, [uN_plus_1]))\n\n        # Step 5: Compute the exact solution at grid points\n        # Grid points x_i = i*h for i = 0, ..., N+1\n        x = np.linspace(0, 1, N + 2)\n        u_exact = np.exp(x) - x\n\n        # Step 6: Calculate the maximum absolute error\n        # The error at the boundaries is zero by construction (up to float precision)\n        max_error = np.max(np.abs(u_numerical - u_exact))\n        \n        # Add the rounded result to the list\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    # Each result is formatted to eight decimal places.\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3104017"}, {"introduction": "在物理和工程问题中，边界上的条件常常涉及解的导数，例如热通量或应力，这被称为诺伊曼(Neumann)边界条件。与直接指定解的值（狄利克雷(Dirichlet)条件）相比，处理这些条件需要更巧妙的离散化技术。本练习将介绍一种强大的技术——“幽灵点法”，它通过在边界外引入一个虚拟的计算点来保持中心差分格式的二阶精度 [@problem_id:3211343]。这确保了我们整个求解区域的数值解都具有一致的高精度。", "problem": "您的任务是为带诺伊曼边界条件的常微分方程一维边值问题设计并实现一个二阶有限差分求解器。数学模型是线性泊松方程\n$$\nu''(x) = f(x), \\quad x \\in [0,1],\n$$\n左端点为诺伊曼边界条件，右端点为狄利克雷边界条件：\n$$\nu'(0) = \\alpha, \\quad u(1) = \\beta.\n$$\n您必须使用一个均匀网格，将区间 $[0,1]$ 进行 $m$ 次等分，网格点为 $x_i = i h$，其中 $h = 1/m$ 且 $i = 0,1,\\dots,m$。您的数值方法必须：\n- 对内部节点处的二阶导数使用标准的二阶中心差分近似。\n- 在 $x=0$ 处使用“虚拟点”实现诺伊曼条件，使得边界处的导数通过中心差分进行近似，并通过调用常微分方程 $u''(x)=f(x)$ 和适当的泰勒展开来消除虚拟点，以保持二阶精度。设计必须从基本定义（网格、泰勒展开和常微分方程）出发，避免使用特定的临时公式。\n- 以在最后一个内部节点处保持二阶精度的方式，引入 $x=1$ 处的狄利克雷边界条件。\n\n您的程序必须求解离散线性系统以得到内部未知数 $u(x_i)$（其中 $i=1,2,\\dots,m-1$），然后计算内部网格点 $\\{x_i\\}_{i=1}^{m-1}$ 上相对于精确解析解的最大绝对误差。\n\n为了进行验证，通过对 $u''(x)=f(x)$ 进行两次积分并使用边界条件来确定积分常数，从而推导出精确的解析解。对于下方的每个测试用例，程序必须计算：\n- 使用您在 $x=0$ 处采用虚拟点处理的二阶格式计算出的内部网格点上的数值解。\n- 相同内部网格点上的精确解。\n- 内部点上的最大绝对误差（逐点误差向量的无穷范数），表示为一个实数。\n\n此外，对于收敛性评估测试，计算由下式定义的观测精度阶 $p$\n$$\np = \\log_2\\left(\\frac{E_{h}}{E_{h/2}}\\right),\n$$\n其中 $E_{h}$ 和 $E_{h/2}$ 分别是具有 $m$ 和 $2m$ 个子区间的网格的最大绝对误差。\n\n使用以下测试套件：\n1. 理想情况：$f(x) = 2$，$\\alpha = 1$，$\\beta = 0$，$$m = 50$$。精确解通过求解给定边界条件的 $u''(x)=2$ 得到。\n2. 边界条件主导的粗网格：$f(x) = 0$，$\\alpha = 0$，$\\beta = 1$，$$m = 4$$。精确解为常数。\n3. 振荡强迫项：$f(x) = -\\pi^2 \\sin(\\pi x)$，$\\alpha = 0$，$\\beta = 0$，$m = 64$。精确解通过求解给定边界条件的 $u''(x) = -\\pi^2 \\sin(\\pi x)$ 得到。\n4. 收敛阶：$f(x) = x$，$\\alpha = 0$，$\\beta = 0$，使用两个网格 $m=20$ 和 $m=40$。按上文定义计算观测阶 $p$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述测试套件的顺序列出结果。前三个条目必须是表示每种情况下最大绝对误差的实数，最后一个条目必须是表示收敛性测试的观测阶的实数。例如，输出应类似于 $[e_1,e_2,e_3,p]$，其中每个 $e_i$ 和 $p$ 都是实数。", "solution": "用户提供的问题是有效的，因为它在科学上基于常微分方程数值方法的理论，在数学上是适定的，并以客观、形式化的标准定义。本文档为验证提供了数值方法和解析解的完整推导。\n\n问题是在区间 $x \\in [0,1]$ 上求解一维泊松方程，这是一个线性的二阶常微分方程（ODE）：\n$$\nu''(x) = f(x)\n$$\n在 $x=0$ 处有诺伊曼边界条件，在 $x=1$ 处有狄利克雷边界条件：\n$$\nu'(0) = \\alpha, \\quad u(1) = \\beta.\n$$\n\n我们将构造一个二阶有限差分格式来近似解。\n\n**1. 区域离散化**\n\n将区域 $[0,1]$ 离散化为一个有 $m$ 个子区间的均匀网格。网格间距为 $h = 1/m$。网格点定义为 $x_i = i h$，其中 $i = 0, 1, \\dots, m$。设 $U_i$ 为网格点 $x_i$ 处精确解 $u(x_i)$ 的数值近似值。$x=1$ 处的边界条件给出 $U_m = u(1) = \\beta$。待求解的值为 $U_0, U_1, \\dots, U_{m-1}$。\n\n**2. 内部点的有限差分近似**\n\n对于任何内部网格点 $x_i$（其中 $i = 1, 2, \\dots, m-1$），我们使用二阶中心差分公式来近似二阶导数 $u''(x_i)$。这是通过 $u(x_{i+1})$ 和 $u(x_{i-1})$ 在 $x_i$ 点的泰勒级数展开推导出来的：\n$$\nu(x_{i+1}) = u(x_i+h) = u(x_i) + h u'(x_i) + \\frac{h^2}{2} u''(x_i) + \\frac{h^3}{6} u'''(x_i) + O(h^4)\n$$\n$$\nu(x_{i-1}) = u(x_i-h) = u(x_i) - h u'(x_i) + \\frac{h^2}{2} u''(x_i) - \\frac{h^3}{6} u'''(x_i) + O(h^4)\n$$\n将这两个展开式相加并整理得到 $u''(x_i)$：\n$$\nu''(x_i) = \\frac{u(x_{i+1}) - 2u(x_i) + u(x_{i-1})}{h^2} - \\frac{h^2}{12} u^{(4)}(x_i) + \\dots\n$$\n该近似是二阶精度的，局部截断误差为 $O(h^2)$。将 $u(x_i)$ 替换为 $U_i$，并根据 ODE 将 $u''(x_i)$ 替换为 $f(x_i)$，我们得到内部节点的离散方程：\n$$\n\\frac{U_{i-1} - 2U_i + U_{i+1}}{h^2} = f(x_i), \\quad \\text{for } i = 1, 2, \\dots, m-1.\n$$\n\n**3. $x=0$ 处诺伊曼边界条件的离散化**\n\n该问题要求使用一个虚拟点来保持二阶精度。我们在 $x_{-1} = -h$ 处引入一个虚拟点。\n首先，我们使用在 $x_0 = 0$ 处的二阶中心差分来近似导数 $u'(0) = \\alpha$：\n$$\nu'(0) = \\frac{u(x_1) - u(x_{-1})}{2h} + O(h^2) \\implies \\frac{U_1 - U_{-1}}{2h} = \\alpha\n$$\n这给出了虚拟值 $U_{-1}$ 的表达式：\n$$\nU_{-1} = U_1 - 2h\\alpha\n$$\n接下来，我们假设 ODE $u''(x) = f(x)$ 在边界点 $x_0=0$ 处也成立。我们对 $u''(0)$ 应用中心差分公式：\n$$\n\\frac{U_{-1} - 2U_0 + U_1}{h^2} = f(x_0)\n$$\n现在，我们通过将其表达式代入此方程来消除虚拟点 $U_{-1}$：\n$$\n\\frac{(U_1 - 2h\\alpha) - 2U_0 + U_1}{h^2} = f(x_0)\n$$\n化简此表达式得到节点 $i=0$ 的方程：\n$$\n\\frac{-2U_0 + 2U_1 - 2h\\alpha}{h^2} = f(x_0) \\implies -2U_0 + 2U_1 = h^2 f(x_0) + 2h\\alpha\n$$\n这个边界格式的局部截断误差是 $O(h)$，这足以保证整个方法的全局误差为 $O(h^2)$。\n\n**4. 线性系统的组装**\n\n我们有一个包含 $m$ 个未知数 $U_0, U_1, \\dots, U_{m-1}$ 的 $m$ 元线性方程组。设 $\\mathbf{U} = [U_0, U_1, \\dots, U_{m-1}]^T$ 为未知量向量。该系统可以写成 $A \\mathbf{U} = \\mathbf{b}$。\n\n方程如下：\n- 对于 $i=0$：$-2U_0 + 2U_1 = h^2 f(x_0) + 2h\\alpha$\n- 对于 $i=1, \\dots, m-2$：$U_{i-1} - 2U_i + U_{i+1} = h^2 f(x_i)$\n- 对于 $i=m-1$：$U_{m-2} - 2U_{m-1} + U_m = h^2 f(x_{m-1})$。由于 $U_m = \\beta$，该方程变为 $U_{m-2} - 2U_{m-1} = h^2 f(x_{m-1}) - \\beta$。\n\n$m \\times m$ 的系数矩阵 $A$ 是：\n$$\nA = \\begin{pmatrix}\n-2  2  0  \\cdots  \\cdots  0 \\\\\n1  -2  1  \\ddots   \\vdots \\\\\n0  1  -2  1  \\ddots  \\vdots \\\\\n\\vdots  \\ddots  \\ddots  \\ddots  \\ddots  0 \\\\\n\\vdots   \\ddots  1  -2  1 \\\\\n0  \\cdots  \\cdots  0  1  -2\n\\end{pmatrix}\n$$\n大小为 $m$ 的右端向量 $\\mathbf{b}$ 是：\n$$\n\\mathbf{b} = \\begin{pmatrix}\nh^2 f(x_0) + 2h\\alpha \\\\\nh^2 f(x_1) \\\\\n\\vdots \\\\\nh^2 f(x_{m-2}) \\\\\nh^2 f(x_{m-1}) - \\beta\n\\end{pmatrix}\n$$\n这个线性系统 $A \\mathbf{U} = \\mathbf{b}$ 是非奇异的，可以求解以找到数值解 $\\mathbf{U}$。\n\n**5. 误差计算与收敛阶**\n\n最大绝对误差 $E_h$ 是在内部网格点 $\\{x_i\\}_{i=1}^{m-1}$ 上计算的，作为误差向量的无穷范数：\n$$\nE_h = \\max_{i=1,\\dots,m-1} |U_i - u(x_i)|\n$$\n对于一个二阶精度的方法，误差预计表现为 $E_h \\approx C h^2$，其中 $C$ 是某个常数。精度阶 $p$ 可以通过比较来自两种不同网格尺寸 $h$ 和 $h/2$ 的误差来数值地观测。\n$$\nE_h \\approx C h^p \\quad \\text{and} \\quad E_{h/2} \\approx C (h/2)^p\n$$\n取其比值得到 $\\frac{E_h}{E_{h/2}} \\approx 2^p$。求解 $p$ 得到：\n$$\np = \\log_2\\left(\\frac{E_{h}}{E_{h/2}}\\right)\n$$\n\n**6. 测试用例的解析解**\n\n精确解 $u(x)$ 是通过对 $u''(x) = f(x)$ 进行两次积分，并应用边界条件 $u'(0) = \\alpha$ 和 $u(1) = \\beta$ 来确定积分常数得到的。\n\n- **情况 1：** $f(x) = 2$, $\\alpha = 1$, $\\beta = 0$.\n$u'' = 2 \\implies u'(x) = 2x+C_1$。$u'(0)=C_1=1$。所以 $u'(x)=2x+1$。\n$u(x) = x^2+x+C_2$。$u(1)=1+1+C_2=0 \\implies C_2=-2$。\n$u(x) = x^2+x-2$。\n\n- **情况 2：** $f(x) = 0$, $\\alpha = 0$, $\\beta = 1$.\n$u'' = 0 \\implies u'(x) = C_1$。$u'(0)=C_1=0$。所以 $u'(x)=0$。\n$u(x) = C_2$。$u(1)=C_2=1$。\n$u(x) = 1$。\n\n- **情况 3：** $f(x) = -\\pi^2 \\sin(\\pi x)$, $\\alpha = 0$, $\\beta = 0$.\n$u''(x) = -\\pi^2 \\sin(\\pi x) \\implies u'(x) = \\pi \\cos(\\pi x)+C_1$。$u'(0)=\\pi+C_1=0 \\implies C_1=-\\pi$。\n$u'(x) = \\pi \\cos(\\pi x) - \\pi$。\n$u(x) = \\sin(\\pi x) - \\pi x + C_2$。$u(1)=\\sin(\\pi)-\\pi+C_2=0 \\implies C_2=\\pi$。\n$u(x) = \\sin(\\pi x) - \\pi x + \\pi$。\n\n- **情况 4：** $f(x) = x$, $\\alpha = 0$, $\\beta = 0$.\n$u''(x) = x \\implies u'(x) = x^2/2+C_1$。$u'(0)=C_1=0$。所以 $u'(x)=x^2/2$。\n$u(x) = x^3/6+C_2$。$u(1)=1/6+C_2=0 \\implies C_2=-1/6$。\n$u(x) = \\frac{x^3}{6} - \\frac{1}{6}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the finite difference solver.\n    \"\"\"\n\n    def run_solver(f, alpha, beta, m):\n        \"\"\"\n        Solves u''(x) = f(x) with u'(0)=alpha, u(1)=beta on a grid with m subdivisions.\n        \n        Args:\n            f (callable): The forcing function f(x).\n            alpha (float): The Neumann boundary condition value at x=0.\n            beta (float): The Dirichlet boundary condition value at x=1.\n            m (int): The number of grid subdivisions.\n            \n        Returns:\n            tuple: A tuple containing:\n                - np.ndarray: Grid points for the interior, x_1, ..., x_{m-1}.\n                - np.ndarray: Numerical solution at the interior points, U_1, ..., U_{m-1}.\n        \"\"\"\n        # Grid setup\n        h = 1.0 / m\n        # We solve for unknowns at x_0, x_1, ..., x_{m-1}\n        x_nodes = np.linspace(0, 1, m + 1)\n        \n        # Assemble the m x m matrix A\n        A = np.zeros((m, m))\n        \n        # Fill diagonals for the standard interior stencil (1, -2, 1)\n        np.fill_diagonal(A, -2.0)\n        # Lower diagonal (k=-1): A[i, i-1] = 1 for i=1,...,m-1\n        np.fill_diagonal(A[1:], 1.0)\n        # Upper diagonal (k=1): A[i, i+1] = 1 for i=0,...,m-2\n        np.fill_diagonal(A[:, 1:], 1.0)\n        \n        # Modify the first row for the Neumann condition: -2*U_0 + 2*U_1 = ...\n        A[0, 1] = 2.0\n        \n        # Assemble the right-hand side vector b of size m\n        # We evaluate f at x_0, ..., x_{m-1}\n        b = h**2 * f(x_nodes[0:m])\n        \n        # Modify first and last elements of b for boundary conditions\n        # b_0 = h^2*f(x_0) + 2*h*alpha\n        b[0] += 2.0 * h * alpha\n        # b_{m-1} = h^2*f(x_{m-1}) - beta\n        b[m-1] -= beta\n        \n        # Solve the linear system A*U = b for U = [U_0, ..., U_{m-1}]\n        U = np.linalg.solve(A, b)\n        \n        # Return interior grid points and corresponding solution values\n        return x_nodes[1:m], U[1:]\n\n    results = []\n\n    # Test Case 1: Happy path\n    f1 = lambda x: 2.0 * np.ones_like(x)\n    u_exact1 = lambda x: x**2 + x - 2.0\n    alpha1, beta1, m1 = 1.0, 0.0, 50\n    x_interior1, U_interior1 = run_solver(f1, alpha1, beta1, m1)\n    u_exact_vals1 = u_exact1(x_interior1)\n    error1 = np.max(np.abs(U_interior1 - u_exact_vals1))\n    results.append(error1)\n\n    # Test Case 2: Boundary-condition-dominant coarse grid\n    f2 = lambda x: np.zeros_like(x)\n    u_exact2 = lambda x: np.ones_like(x)\n    alpha2, beta2, m2 = 0.0, 1.0, 4\n    x_interior2, U_interior2 = run_solver(f2, alpha2, beta2, m2)\n    u_exact_vals2 = u_exact2(x_interior2)\n    error2 = np.max(np.abs(U_interior2 - u_exact_vals2))\n    results.append(error2)\n\n    # Test Case 3: Oscillatory forcing\n    f3 = lambda x: -np.pi**2 * np.sin(np.pi * x)\n    u_exact3 = lambda x: np.sin(np.pi * x) - np.pi * x + np.pi\n    alpha3, beta3, m3 = 0.0, 0.0, 64\n    x_interior3, U_interior3 = run_solver(f3, alpha3, beta3, m3)\n    u_exact_vals3 = u_exact3(x_interior3)\n    error3 = np.max(np.abs(U_interior3 - u_exact_vals3))\n    results.append(error3)\n\n    # Test Case 4: Convergence order\n    f4 = lambda x: x\n    u_exact4 = lambda x: x**3 / 6.0 - 1.0 / 6.0\n    alpha4, beta4 = 0.0, 0.0\n    \n    # Solve on grid with m=20\n    m_h = 20\n    x_h, U_h = run_solver(f4, alpha4, beta4, m_h)\n    u_h = u_exact4(x_h)\n    E_h = np.max(np.abs(U_h - u_h))\n    \n    # Solve on grid with m=40\n    m_h2 = 40\n    x_h2, U_h2 = run_solver(f4, alpha4, beta4, m_h2)\n    u_h2 = u_exact4(x_h2)\n    E_h2 = np.max(np.abs(U_h2 - u_h2))\n    \n    order_p = np.log2(E_h / E_h2)\n    results.append(order_p)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3211343"}, {"introduction": "现实世界中的许多问题，如流体动力学中的边界层或半导体物理学，都表现出“奇异摄动”特性，即解在极窄的区域内发生剧烈变化。用标准数值方法求解这类问题通常会产生严重的数值振荡或不准确的结果。这个练习将让你直面这一挑战，通过求解一个奇异摄动问题，你将亲眼看到标准均匀网格的失效，并学会如何设计一个自适应的“什什金(Shishkin)网格”来准确地捕捉边界层 [@problem_id:3211184]。这个实践突显了根据问题本身的物理特性来调整数值方法的重要性。", "problem": "考虑闭区间 $[0,1]$ 上的一个奇异摄动常微分方程的边值问题：\n$$\n\\varepsilon\\, u''(x) + u'(x) = 0,\\quad x\\in(0,1),\\qquad u(0)=1,\\quad u(1)=0,\n$$\n其中 $\\varepsilon > 0$ 是一个给定的参数。您的任务是实现并评估一个有限差分求解器来处理该问题形成的边界层。为此，您需要：1) 在可能非均匀的网格上，使用后向差分（迎风格式）近似一阶导数，并使用二阶中心差分近似二阶导数，从而构建一个三对角线性系统。2) 实现两种网格生成策略：一个标准的均匀网格，以及一个分段均匀的什什金（Shishkin）网格，该网格将节点集中在边界层内。3) 对于以下四种情况，计算并报告数值解与精确解析解（$u(x) = (e^{-x/\\varepsilon} - e^{-1/\\varepsilon})/(1 - e^{-1/\\varepsilon})$）在所有网格点上的最大绝对误差：a) $\\varepsilon=10^{-1}$，均匀网格，$N=128$；b) $\\varepsilon=10^{-3}$，均匀网格，$N=128$；c) $\\varepsilon=10^{-6}$，均匀网格，$N=128$；d) $\\varepsilon=10^{-6}$，什什金网格，$N=128$。您的程序应生成一个单行输出，其中包含一个用方括号括起来的、以科学记数法表示并保留6位小数的逗号分隔列表，按顺序报告这四个误差值。", "solution": "用户提供的问题陈述是来自常微分方程数值分析领域的一个适定边值问题。它在奇异摄动理论中有科学依据，是自包含的，并且是客观陈述的。所有参数、离散化方法、网格生成规则和测试用例都得到了清晰明确的定义。因此，该问题被认为是有效的，下面提供了完整的解决方案。\n\n问题的核心是求解奇异摄动对流扩散方程，并分析不同网格下的数值误差。求解过程包括四个主要步骤：推导解析解，构建有限差分格式，建立并求解得到的线性系统，以及实现指定的网格生成策略。\n\n首先，我们推导边值问题的精确解析解，它将作为衡量数值误差的基准。给定的常微分方程 (ODE) 是\n$$\n\\varepsilon\\, u''(x) + u'(x) = 0, \\quad x \\in (0,1).\n$$\n这是一个二阶线性齐次常系数 ODE。其对应的特征方程是 $\\varepsilon r^2 + r = 0$，可因式分解为 $r(\\varepsilon r + 1) = 0$。根为 $r_1 = 0$ 和 $r_2 = -1/\\varepsilon$。因此，该 ODE 的通解是\n$$\nu(x) = C_1 e^{r_1 x} + C_2 e^{r_2 x} = C_1 + C_2 e^{-x/\\varepsilon},\n$$\n其中 $C_1$ 和 $C_2$ 是待定常数，由边界条件 $u(0)=1$ 和 $u(1)=0$ 确定。\n在 $x=0$ 处应用边界条件：\n$$\nu(0) = C_1 + C_2 e^0 = C_1 + C_2 = 1.\n$$\n在 $x=1$ 处应用边界条件：\n$$\nu(1) = C_1 + C_2 e^{-1/\\varepsilon} = 0.\n$$\n求解这个关于 $C_1$ 和 $C_2$ 的 $2 \\times 2$ 系统，我们得到\n$$\nC_2 = \\frac{1}{1 - e^{-1/\\varepsilon}}, \\quad C_1 = -C_2 e^{-1/\\varepsilon} = \\frac{-e^{-1/\\varepsilon}}{1 - e^{-1/\\varepsilon}}.\n$$\n将这些常数代回通解，得到精确解：\n$$\nu(x) = \\frac{-e^{-1/\\varepsilon} + e^{-x/\\varepsilon}}{1 - e^{-1/\\varepsilon}} = \\frac{e^{-x/\\varepsilon} - e^{-1/\\varepsilon}}{1 - e^{-1/\\varepsilon}}.\n$$\n该解证实了在 $x=0$ 附近存在一个宽度为 $O(\\varepsilon)$ 的指数边界层。\n\n接下来，我们在节点网格 $0=x_0  x_1  \\dots  x_N=1$ 上构建有限差分格式。设 $U_i$ 是 $u(x_i)$ 的数值近似。网格可以是非均匀的，因此我们定义局部步长为 $h_i = x_i - x_{i-1}$，其中 $i=1, \\dots, N$。\n问题指定了在内部节点 $x_i$ 处每个导数项的离散化方法：\n对于二阶导数 $u''(x_i)$，我们使用一种适用于非均匀网格的二阶中心差分，该差分由围绕 $x_i$ 的泰勒级数展开推导而来：\n$$\nu''(x_i) \\approx \\frac{2}{h_i + h_{i+1}} \\left( \\frac{U_{i+1} - U_i}{h_{i+1}} - \\frac{U_i - U_{i-1}}{h_i} \\right),\n$$\n其中 $h_{i+1} = x_{i+1} - x_i$。\n对于一阶导数 $u'(x_i)$，我们使用迎风格式。对流项 $u'(x)$ 的系数为 $1 > 0$，表示“风”从左向右吹。因此，使用后向差分是合适的：\n$$\nu'(x_i) \\approx \\frac{U_i - U_{i-1}}{h_i}.\n$$\n将这些离散近似代入每个内部节点 $x_i$（其中 $i=1, \\dots, N-1$）处的 ODE $\\varepsilon u''(x) + u'(x)=0$，得到有限差分方程：\n$$\n\\varepsilon \\left( \\frac{2}{h_i + h_{i+1}} \\left( \\frac{U_{i+1} - U_i}{h_{i+1}} - \\frac{U_i - U_{i-1}}{h_i} \\right) \\right) + \\left( \\frac{U_i - U_{i-1}}{h_i} \\right) = 0.\n$$\n我们通过收集节点值 $U_{i-1}$、$U_i$ 和 $U_{i+1}$ 的系数来重排这个方程，形成一个线性方程 $L_i U_{i-1} + D_i U_i + R_i U_{i+1} = 0$，其中：\n$$\nL_i = \\frac{2\\varepsilon}{h_i(h_i+h_{i+1})} - \\frac{1}{h_i}, \\quad D_i = \\frac{1}{h_i} - \\frac{2\\varepsilon}{h_i h_{i+1}}, \\quad R_i = \\frac{2\\varepsilon}{h_{i+1}(h_i+h_{i+1})}.\n$$\n这组关于 $N-1$ 个未知内部节点值 $U_1, \\dots, U_{N-1}$ 的 $N-1$ 个方程构成了一个三对角线性系统。边界条件 $U_0 = 1$ 和 $U_N = 0$ 被并入第一个和最后一个内部节点的方程中。\n对于 $i=1$：$D_1 U_1 + R_1 U_2 = -L_1 U_0 = -L_1(1) = \\frac{1}{h_1} - \\frac{2\\varepsilon}{h_1(h_1+h_2)}$。\n对于 $i=N-1$：$L_{N-1} U_{N-2} + D_{N-1} U_{N-1} = -R_{N-1} U_N = -R_{N-1}(0) = 0$。\n然后数值求解得到的 $(N-1) \\times (N-1)$ 三对角系统 $\\mathbf{A}\\mathbf{U} = \\mathbf{b}$，其中 $\\mathbf{U} = [U_1, \\dots, U_{N-1}]^T$。\n\n该问题要求使用两种类型的网格：\n1.  一个包含 $N$ 个子区间的均匀网格，得到 $N+1$ 个节点 $x_i = i/N$，其中 $i=0, \\dots, N$。步长是恒定的：对于所有 $i$，$h_i=h=1/N$。\n2.  一个当 $N$ 为偶数时定义的 Shishkin 型分段均匀网格。一个转换点 $\\sigma = \\min\\left(\\frac{1}{2}, 2\\varepsilon \\ln N\\right)$ 将区域划分为 $[0, \\sigma]$ 和 $[\\sigma, 1]$。细网格区域 $[0, \\sigma]$ 被划分为 $N/2$ 个宽度为 $h_{fine} = \\sigma / (N/2)$ 的区间，而粗网格区域 $[\\sigma, 1]$ 被划分为 $N/2$ 个宽度为 $h_{coarse} = (1-\\sigma) / (N/2)$ 的区间。这种网格将节点集中在边界层区域。\n\n通过求解线性系统并包含边界值，可以得到数值解 $\\mathbf{U} = \\{U_i\\}_{i=0}^N$。通过计算与在网格节点上求值的精确解相比的最大绝对点态误差来评估其精度：\n$$\n\\text{Error} = \\max_{i=0, \\dots, N} |U_i - u(x_i)|.\n$$\n以下程序为指定的测试用例实现了这整个过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    def exact_solution(x, eps):\n        \"\"\"\n        Computes the exact solution of the BVP.\n        u(x) = (exp(-x/eps) - exp(-1/eps)) / (1 - exp(-1/eps))\n        \"\"\"\n        numerator = np.exp(-x / eps) - np.exp(-1.0 / eps)\n        denominator = 1.0 - np.exp(-1.0 / eps)\n        # Avoid division by zero if denominator is zero (theoretically only for eps=inf)\n        if denominator == 0:\n            return np.zeros_like(x) # Should not happen for eps > 0\n        return numerator / denominator\n\n    def create_uniform_mesh(N):\n        \"\"\"\n        Generates a uniform mesh with N subintervals.\n        \"\"\"\n        x = np.linspace(0.0, 1.0, N + 1)\n        return x\n\n    def create_shishkin_mesh(eps, N):\n        \"\"\"\n        Generates a Shishkin piecewise-uniform mesh.\n        \"\"\"\n        if N % 2 != 0:\n            raise ValueError(\"N must be an even integer for Shishkin mesh.\")\n        \n        sigma = min(0.5, 2.0 * eps * np.log(N))\n        \n        n_half = N // 2\n        \n        x_fine = np.linspace(0.0, sigma, n_half + 1)\n        x_coarse = np.linspace(sigma, 1.0, n_half + 1)\n        \n        # Concatenate, removing the duplicate transition point sigma\n        x = np.concatenate((x_fine[:-1], x_coarse))\n        return x\n\n    def solve_bvp(eps, N, mesh_type):\n        \"\"\"\n        Solves the BVP for a given epsilon, N, and mesh type.\n        \"\"\"\n        if mesh_type == 'uniform':\n            x = create_uniform_mesh(N)\n        elif mesh_type == 'Shishkin':\n            x = create_shishkin_mesh(eps, N)\n        else:\n            raise ValueError(\"Unknown mesh type.\")\n\n        h_spacings = np.diff(x)\n        \n        num_unknowns = N - 1\n        A = np.zeros((num_unknowns, num_unknowns))\n        b = np.zeros(num_unknowns)\n        \n        # Populate the tridiagonal matrix A and vector b\n        # Loop over interior nodes i = 1, ..., N-1\n        for i in range(1, N):\n            matrix_row_idx = i - 1\n            \n            # h_i = x_i - x_{i-1} corresponds to h_spacings[i-1]\n            # h_{i+1} = x_{i+1} - x_i corresponds to h_spacings[i]\n            h_i = h_spacings[i-1]\n            h_i_plus_1 = h_spacings[i]\n            \n            # Coefficients of the equation at node i: L_i*U_{i-1} + D_i*U_i + R_i*U_{i+1} = 0\n            # L_i: sub-diagonal, D_i: main diagonal, R_i: super-diagonal\n            \n            L_i = (2.0 * eps) / (h_i * (h_i + h_i_plus_1)) - 1.0 / h_i\n            D_i = 1.0 / h_i - (2.0 * eps) / (h_i * h_i_plus_1)\n            R_i = (2.0 * eps) / (h_i_plus_1 * (h_i + h_i_plus_1))\n            \n            if i > 1:\n                A[matrix_row_idx, matrix_row_idx - 1] = L_i\n            \n            A[matrix_row_idx, matrix_row_idx] = D_i\n            \n            if i  N - 1:\n                A[matrix_row_idx, matrix_row_idx + 1] = R_i\n\n        # Apply boundary conditions\n        # For i=1 (first row, index 0): D_1*U_1 + R_1*U_2 = -L_1*U_0\n        # Since U_0 = 1, RHS = -L_1\n        h1 = h_spacings[0]\n        h2 = h_spacings[1]\n        L1 = (2.0 * eps) / (h1 * (h1 + h2)) - 1.0 / h1\n        b[0] = -L1 * 1.0\n        \n        # For i=N-1 (last row, index N-2): L_{N-1}*U_{N-2} + D_{N-1}*U_{N-1} = -R_{N-1}*U_N\n        # Since U_N = 0, RHS is 0, which is the default value in b.\n\n        # Solve the linear system for internal nodes\n        U_internal = np.linalg.solve(A, b)\n        \n        # Assemble the full solution vector, including boundary values\n        U = np.concatenate(([1.0], U_internal, [0.0]))\n        \n        # Calculate maximum absolute error\n        U_ex = exact_solution(x, eps)\n        max_error = np.max(np.abs(U - U_ex))\n        \n        return max_error\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1e-1, 'uniform', 128),\n        (1e-3, 'uniform', 128),\n        (1e-6, 'uniform', 128),\n        (1e-6, 'Shishkin', 128)\n    ]\n\n    results = []\n    for eps, mesh_type, N in test_cases:\n        error = solve_bvp(eps, N, mesh_type)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6e}' for r in results])}]\")\n\nsolve()\n```", "id": "3211184"}]}