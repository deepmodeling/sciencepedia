{"hands_on_practices": [{"introduction": "理解稳定性区域不仅仅是理论上的追求，更是为了在实践中做出明智的决策。本练习将指导你完成一项基本任务：对于给定的数值方法和常微分方程组，如何确定保证数值稳定性的最大时间步长。通过从 Butcher 盘推导稳定函数并将其应用于具体的线性系统，本练习将理论与实践联系起来，让你亲手实践如何将抽象的稳定性概念应用于解决实际问题。[@problem_id:3197733]", "problem": "给定初值问题 $y'(t)=A_{\\text{sys}}\\,y(t)$，其中 $A_{\\text{sys}}$ 是一个复值矩阵，$y(t)$ 是一个复值向量函数。考虑使用一个由布彻表 (Butcher tableau) 描述的固定步长显式龙格－库塔方法来对该系统进行积分。时间积分的稳定性由该方法在线性检验方程 $y'(t)=\\lambda\\,y(t)$（其中 $\\lambda\\in\\mathbb{C}$）上的行为决定。对于一个显式龙格－库塔方法，其稳定区域是 $z\\in\\mathbb{C}$ 的集合，使得应用于 $y'(t)=\\lambda\\,y(t)$ 的相应标量放大因子满足 $\\lvert R(z)\\rvert\\leq 1$，其中 $z=\\Delta t\\,\\lambda$，$\\Delta t$ 是时间步长。如果一个方法的稳定区域包含整个左半平面 $\\{z\\in\\mathbb{C}:\\Re(z)\\leq 0\\}$，则称该方法为代数稳定 (A-稳定)；如果它在 A-稳定的基础上还满足当 $z$ 沿着实轴趋于 $-\\infty$ 时 $R(z)\\to 0$，则称其为极限稳定 (L-稳定)。显式龙格－库塔方法不是代数稳定的 (A-稳定)，因此即使当 $\\Re(\\lambda)0$ 时，最大稳定步长 $\\Delta t$ 通常也是有限的。\n\n从线性检验方程的基本原理和通过布彻表定义的龙格－库塔方法出发，推导给定方法的稳定性函数 $R(z)$，为系统矩阵 $A_{\\text{sys}}$ 的每个特征值 $\\lambda$ 证明稳定性判据 $\\lvert R(\\Delta t\\,\\lambda)\\rvert\\leq 1$ 的合理性，并构建一个数值搜索过程。该过程针对一个固定的龙格－库塔方法和给定的系统矩阵 $A_{\\text{sys}}$，寻找最大的 $\\Delta t0$，使得所有缩放后的特征值 $z_i=\\Delta t\\,\\lambda_i$ 都位于稳定区域内，即对于 $A_{\\text{sys}}$ 的所有特征值 $\\lambda_i$，都有 $\\lvert R(z_i)\\rvert\\leq 1$。你的程序不能假定一个预先制表的稳定性多项式；它必须直接从布彻表和应用于 $y'(t)=\\lambda\\,y(t)$ 的方法定义中获得 $R(z)$。\n\n使用经典的四阶显式龙格－库塔方法 (通常称为“RK4”)，其布彻表如下：\n$$\nA_{\\text{RK}}=\\begin{bmatrix}\n0  0  0  0\\\\\n\\frac{1}{2}  0  0  0\\\\\n0  \\frac{1}{2}  0  0\\\\\n0  0  1  0\n\\end{bmatrix},\\quad\nb=\\begin{bmatrix}\n\\frac{1}{6}\\\\\n\\frac{1}{3}\\\\\n\\frac{1}{3}\\\\\n\\frac{1}{6}\n\\end{bmatrix},\\quad\nc=\\begin{bmatrix}\n0\\\\\n\\frac{1}{2}\\\\\n\\frac{1}{2}\\\\\n1\n\\end{bmatrix}.\n$$\n\n设计你的程序，将这同一个 RK 方法应用于以下每个测试矩阵 $A_{\\text{sys}}^{(k)}$，并为每个矩阵计算一个浮点数值：使得稳定性条件 $\\lvert R(\\Delta t\\,\\lambda_i)\\rvert\\leq 1$ 对 $A_{\\text{sys}}^{(k)}$ 的所有特征值 $\\lambda_i$ 同时成立的最大 $\\Delta t$。搜索必须沿着 $\\mathbb{C}$ 中 $\\Delta t\\geq 0$ 的射线 $z=\\Delta t\\,\\lambda_i$ 进行，并应返回满足约束的最大 $\\Delta t$。如果约束仅在 $\\Delta t=0$ 时成立，你的程序必须在该情况下返回 $0.0$。所有数值输出必须四舍五入到 $8$ 位小数。\n\n测试集：\n- 测试 1 (一般负实特征值)：\n$$\nA_{\\text{sys}}^{(1)}=\\begin{bmatrix}\n-2  0\\\\\n0  -5\n\\end{bmatrix}.\n$$\n- 测试 2 (正实特征值)：\n$$\nA_{\\text{sys}}^{(2)}=\\begin{bmatrix}\n1  0\\\\\n0  \\frac{1}{2}\n\\end{bmatrix}.\n$$\n- 测试 3 (实部为负的共轭复数对)：\n$$\nA_{\\text{sys}}^{(3)}=\\begin{bmatrix}\n-1  -4\\\\\n1  -1\n\\end{bmatrix}.\n$$\n- 测试 4 (高度振荡且小阻尼)：\n$$\nA_{\\text{sys}}^{(4)}=\\begin{bmatrix}\n-0.1  10\\\\\n-10  -0.1\n\\end{bmatrix}.\n$$\n\n最终输出格式要求：\n- 你的程序应生成单行输出，其中包含四个测试用例的结果，格式为方括号内以逗号分隔的列表，每个浮点数四舍五入到 8 位小数，且不含空格。例如，输出必须类似于 $[d_1,d_2,d_3,d_4]$，其中每个 $d_k$ 是小数点后恰好有 8 位数字的十进制字符串。", "solution": "用户提供的问题已经过验证，被确定为常微分方程数值分析领域中一个适定且具有科学依据的问题。所有必要信息均已提供，问题没有矛盾或含糊之处。我现在将着手提供一个完整的解决方案。\n\n### 1. 显式龙格－库塔方法与稳定性函数\n\n求解初值问题 $y'(t) = f(t, y(t))$ 的一个 $s$ 阶显式龙格－库塔 (ERK) 方法由以下方程定义：\n$$\ny_{n+1} = y_n + \\Delta t \\sum_{i=1}^s b_i k_i \\\\\nk_i = f\\left(t_n + c_i \\Delta t, y_n + \\Delta t \\sum_{j=1}^{i-1} a_{ij} k_j\\right)\n$$\n系数 $a_{ij}$、$b_i$ 和 $c_i$ 由布彻表给出，对于显式方法，其矩阵 $A = (a_{ij})$ 是一个严格下三角矩阵。\n\n为分析该方法的稳定性，我们将其应用于达尔奎斯特 (Dahlquist) 检验方程 $y'(t) = \\lambda y(t)$，其中 $\\lambda \\in \\mathbb{C}$。在这种情况下，$f(t, y) = \\lambda y$。阶段值 $k_i$ 变为：\n$$\nk_i = \\lambda \\left(y_n + \\Delta t \\sum_{j=1}^{i-1} a_{ij} k_j\\right)\n$$\n我们定义缩放后的时间步长 $z = \\Delta t \\lambda$。可以观察到，每个阶段向量 $k_i$ 必定与 $\\lambda y_n$ 成比例。设 $k_i = K_i(z) \\lambda y_n$，其中 $K_i(z)$ 是某个函数。将此代入阶段方程：\n$$\nK_i(z) \\lambda y_n = \\lambda \\left(y_n + \\Delta t \\sum_{j=1}^{i-1} a_{ij} (K_j(z) \\lambda y_n)\\right)\n$$\n两边除以 $\\lambda y_n$ (假设 $\\lambda, y_n \\neq 0$)，我们得到阶段多项式 $K_i(z)$ 的一个递推关系：\n$$\nK_i(z) = 1 + z \\sum_{j=1}^{i-1} a_{ij} K_j(z)\n$$\n当 $i=1$ 时，求和为空，因此 $K_1(z) = 1$。因为 $A$ 是严格下三角矩阵，我们可以依次计算每个 $K_i(z)$。$K_i(z)$ 是一个关于 $z$ 的 $i-1$ 次多项式。\n\n数值解按如下方式更新：\n$$\ny_{n+1} = y_n + \\Delta t \\sum_{i=1}^s b_i (K_i(z) \\lambda y_n) = y_n \\left(1 + z \\sum_{i=1}^s b_i K_i(z)\\right)\n$$\n括号中的项是放大因子，它将 $y_n$ 映射到 $y_{n+1}$。这就是稳定性函数 $R(z)$：\n$$\nR(z) = 1 + z \\sum_{i=1}^s b_i K_i(z)\n$$\n对于一个 $s$ 阶 ERK 方法，$R(z)$ 是一个关于 $z$ 的次数最高为 $s$ 的多项式。\n\n### 2. 经典 RK4 方法的稳定性函数\n\n问题提供了经典的四阶龙格－库塔方法 ($s=4$) 的布彻表：\n$$\nA_{\\text{RK}}=\\begin{bmatrix}\n0  0  0  0\\\\\n\\frac{1}{2}  0  0  0\\\\\n0  \\frac{1}{2}  0  0\\\\\n0  0  1  0\n\\end{bmatrix},\\quad\nb=\\begin{bmatrix}\n\\frac{1}{6}\\\\\n\\frac{1}{3}\\\\\n\\frac{1}{3}\\\\\n\\frac{1}{6}\n\\end{bmatrix}\n$$\n我们推导阶段多项式 $K_i(z)$：\n\\begin{align*}\nK_1(z) = 1 \\\\\nK_2(z) = 1 + z a_{21} K_1(z) = 1 + z \\left(\\frac{1}{2}\\right)(1) = 1 + \\frac{z}{2} \\\\\nK_3(z) = 1 + z (a_{31} K_1(z) + a_{32} K_2(z)) = 1 + z \\left(0 + \\frac{1}{2}\\left(1 + \\frac{z}{2}\\right)\\right) = 1 + \\frac{z}{2} + \\frac{z^2}{4} \\\\\nK_4(z) = 1 + z (a_{41} K_1 + a_{42} K_2 + a_{43} K_3) = 1 + z \\left(0 + 0 + 1\\left(1 + \\frac{z}{2} + \\frac{z^2}{4}\\right)\\right) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{4}\n\\end{align*}\n现在，我们构造稳定性函数 $R(z)$：\n$$\nR(z) = 1 + z \\left( b_1 K_1(z) + b_2 K_2(z) + b_3 K_3(z) + b_4 K_4(z) \\right)\n$$\n代入 $b_i$ 的值和多项式 $K_i(z)$：\n$$\nR(z) = 1 + z \\left[ \\frac{1}{6}(1) + \\frac{1}{3}\\left(1+\\frac{z}{2}\\right) + \\frac{1}{3}\\left(1+\\frac{z}{2}+\\frac{z^2}{4}\\right) + \\frac{1}{6}\\left(1+z+\\frac{z^2}{2}+\\frac{z^3}{4}\\right) \\right]\n$$\n将括号内的项按 $z$ 的幂次合并：\n\\begin{itemize}\n    \\item 常数项： $\\frac{1}{6} + \\frac{1}{3} + \\frac{1}{3} + \\frac{1}{6} = 1$\n    \\item $z$ 的一次项： $\\frac{1}{3}\\left(\\frac{1}{2}\\right) + \\frac{1}{3}\\left(\\frac{1}{2}\\right) + \\frac{1}{6}(1) = \\frac{1}{6} + \\frac{1}{6} + \\frac{1}{6} = \\frac{1}{2}$\n    \\item $z$ 的二次项： $\\frac{1}{3}\\left(\\frac{1}{4}\\right) + \\frac{1}{6}\\left(\\frac{1}{2}\\right) = \\frac{1}{12} + \\frac{1}{12} = \\frac{1}{6}$\n    \\item $z$ 的三次项： $\\frac{1}{6}\\left(\\frac{1}{4}\\right) = \\frac{1}{24}$\n\\end{itemize}\n将括号内的表达式乘以 $z$ 再加上 $1$，我们得到：\n$$\nR(z) = 1 + z\\left(1 + \\frac{1}{2}z + \\frac{1}{6}z^2 + \\frac{1}{24}z^3\\right) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24} = \\sum_{k=0}^{4} \\frac{z^k}{k!}\n$$\n这是 $e^z$ 的泰勒级数展开式在四阶截断的结果。\n\n### 3. 线性系统的稳定性判据\n\n对于常微分方程组 $y'(t) = A_{\\text{sys}} y(t)$，假设 $A_{\\text{sys}}$ 是可对角化的，则存在一个可逆矩阵 $P$ 使得 $A_{\\text{sys}} = P \\Lambda P^{-1}$，其中 $\\Lambda$ 是由 $A_{\\text{sys}}$ 的特征值 $\\lambda_i$ 构成的对角矩阵。\n通过变量替换 $u(t) = P^{-1} y(t)$，系统解耦为一组独立的标量方程：$u_i'(t) = \\lambda_i u_i(t)$。\n将龙格－库塔方法应用于原系统 $y' = A_{\\text{sys}} y$ 等价于将相同的方法应用于每个标量方程。变换后变量的更新规则是：\n$u_{i, n+1} = R(\\Delta t \\lambda_i) u_{i, n}$。\n为了使数值解 $y_n$ 在 $n \\to \\infty$ 时保持有界，所有分量 $u_{i,n}$ 都必须保持有界。这要求每个分量的放大因子模长不大于一：\n$$\n|R(\\Delta t \\lambda_i)| \\leq 1 \\quad \\text{for all eigenvalues } \\lambda_i \\text{ of } A_{\\text{sys}}\n$$\n这就是数值稳定性的条件。\n\n### 4. 最大稳定时间步长 $\\Delta t_{\\max}$ 的算法\n\n我们寻求满足所有特征值的稳定性条件的最大 $\\Delta t \\geq 0$。即 $\\Delta t_{\\max} = \\sup\\{\\Delta t \\geq 0 \\mid |R(\\Delta t \\lambda_i)| \\leq 1 \\text{ for all } i\\}$。\n\n算法如下：\n1.  计算矩阵 $A_{\\text{sys}}$ 的特征值集合 $\\{\\lambda_i\\}$。\n2.  对于每个特征值 $\\lambda_i$：\n    a. 如果 $\\Re(\\lambda_i)  0$，物理系统是不稳定的。对于任何 $\\Delta t  0$，数值方法也将不稳定，因为对于小的 $z=\\Delta t \\lambda_i$，$|R(z)| \\approx |1+z| = \\sqrt{(1+\\Delta t \\Re(\\lambda_i))^2 + (\\Delta t \\Im(\\lambda_i))^2}  1$。因此，$\\Delta t_{\\max} = 0$。\n    b. 如果 $\\lambda_i=0$，$R(0)=1$，所以该特征值对 $\\Delta t$ 没有限制。\n    c. 如果 $\\Re(\\lambda_i) \\leq 0$ 且 $\\lambda_i \\neq 0$，我们必须找到最小的正数 $\\Delta t_i^*$ 使得 $|R(\\Delta t_i^* \\lambda_i)| = 1$。这个值代表了沿 $\\lambda_i$ 定义的射线方向上稳定区域的边界。\n3.  最终的最大稳定时间步长是这些单个极限中的最小值：$\\Delta t_{\\max} = \\min_{i} \\{\\Delta t_i^*\\}$。\n\n为了找到 $\\Delta t_i^*$，我们求解方程 $|R(\\Delta t \\lambda_i)| - 1 = 0$ 的最小正根 $\\Delta t$。这是一个非线性方程，我们可以用数值方法求解。一个稳健的方法是首先确定根所在的区间，然后使用像布伦特 (Brent) 方法这样的求根算法。\n-   **根的区间限定**：对于一个给定的 $\\Re(\\lambda_i) \\le 0$ 的特征值 $\\lambda_i$，函数 $h(\\Delta t) = |R(\\Delta t \\lambda_i)| - 1$ 对于小的 $\\Delta t  0$ 是非正的。由于任何显式 RK 方法的稳定区域都是有界的，我们可以通过从一个猜测值开始并逐步增大它（例如，每次加倍），直到满足条件 $h(b)  0$，从而找到一个上界 $b$。这提供了一个包含根的区间 $[a, b]$。\n-   **求根**：在将根限定在区间 $[a, b]$ 内后，`scipy.optimize.brentq` 可以高效地找到 $\\Delta t_i^*$ 的精确值。\n\n该实现将根据推导出的布彻表计算 $R(z)$，然后对每个测试矩阵执行此数值搜索。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It computes the maximum stable time step for the classical RK4 method\n    for several linear systems.\n    \"\"\"\n    # Butcher tableau for the classical 4-stage Runge-Kutta method (RK4)\n    A_rk4 = np.array([\n        [0.0, 0.0, 0.0, 0.0],\n        [0.5, 0.0, 0.0, 0.0],\n        [0.0, 0.5, 0.0, 0.0],\n        [0.0, 0.0, 1.0, 0.0]\n    ], dtype=float)\n    b_rk4 = np.array([1/6, 1/3, 1/3, 1/6], dtype=float)\n\n    # Test suite of system matrices A_sys\n    test_cases = [\n        # Case 1: general negative real eigenvalues\n        np.array([[-2.0, 0.0], [0.0, -5.0]], dtype=float),\n        # Case 2: positive real eigenvalues\n        np.array([[1.0, 0.0], [0.0, 0.5]], dtype=float),\n        # Case 3: complex-conjugate pair with negative real part\n        np.array([[-1.0, -4.0], [1.0, -1.0]], dtype=float),\n        # Case 4: highly oscillatory with small damping\n        np.array([[-0.1, 10.0], [-10.0, -0.1]], dtype=float)\n    ]\n\n    results = []\n    for A_sys in test_cases:\n        max_dt = find_max_dt(A_sys, A_rk4, b_rk4)\n        results.append(f\"{max_dt:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef compute_R_from_tableau(z, A, b):\n    \"\"\"\n    Computes the value of the stability function R(z) for a given z\n    and a Runge-Kutta method specified by its Butcher tableau (A, b).\n    \"\"\"\n    s = len(b)\n    K = np.zeros(s, dtype=np.complex128)\n    for i in range(s):\n        # K_i(z) = 1 + z * sum(a[i,j] * K_j(z) for j  i)\n        stage_sum = np.dot(A[i, :i], K[:i])\n        K[i] = 1.0 + z * stage_sum\n    \n    # R(z) = 1 + z * sum(b_i * K_i(z))\n    return 1.0 + z * np.dot(b, K)\n\ndef find_max_dt(A_sys, butcher_A, butcher_b):\n    \"\"\"\n    Finds the maximum stable time step dt for a system y'(t) = A_sys*y(t)\n    using the stability function derived from the provided Butcher tableau.\n    \"\"\"\n    try:\n        eigenvalues = np.linalg.eigvals(A_sys)\n    except np.linalg.LinAlgError:\n        return 0.0\n\n    # If any eigenvalue has a positive real part, the system is unstable,\n    # and the time integration will be unstable for any dt > 0.\n    if any(lam.real > 1e-9 for lam in eigenvalues):\n        return 0.0\n        \n    min_dt_root = float('inf')\n    \n    for lam in eigenvalues:\n        if abs(lam)  1e-9:  # An eigenvalue of 0 imposes no stability constraint.\n            continue\n\n        def h(dt):\n            \"\"\"Target function for root finding: |R(dt*lam)| - 1.\"\"\"\n            z = dt * lam\n            R_val = compute_R_from_tableau(z, butcher_A, butcher_b)\n            return abs(R_val) - 1.0\n\n        # Search for the smallest positive root of h(dt) = 0.\n        # This determines the stability limit for this eigenvalue.\n        \n        # Step 1: Bracket the root. Find an interval [a, b] such that\n        # h(a) = 0 and h(b) > 0.\n        # For stable/neutral eigenvalues, h(dt) = 0 for small dt > 0.\n        a = 1e-9 # Small positive number to start the search interval.\n        b = 1e-3 # Initial guess for the upper bound.\n        \n        # Exponentially increase b until h(b) > 0.\n        while h(b) = 0:\n            b *= 2.0\n            if b > 1e6: # Safety break to avoid infinite loops\n                b = float('inf')\n                break\n        \n        if b == float('inf'):\n            # This eigenvalue does not seem to impose a stability constraint\n            # within a reasonable range. This shouldn't happen for explicit methods.\n            continue\n            \n        a = b / 2.0\n        if a == 0: a = 1e-9\n\n        # Step 2: Use Brent's method to find the root within the bracketed interval.\n        try:\n            root = brentq(h, a, b)\n            min_dt_root = min(min_dt_root, root)\n        except ValueError:\n            # Should not happen with the bracketing logic above.\n            # If it does, it implies immediate instability for this eigenvalue.\n            min_dt_root = 0.0\n            break\n\n    if min_dt_root == float('inf'):\n        # This case would occur if all eigenvalues were zero.\n        # Any dt would be stable, so there's no finite maximum.\n        # The problem cases avoid this scenario. Returning 0.0 as a safe default.\n        return 0.0\n        \n    return min_dt_root\n\nsolve()\n```", "id": "3197733"}, {"introduction": "在掌握了如何为单个方法寻找稳定性极限后，下一步自然是比较不同方法的优劣。本练习通过对比两种基础的隐式方法，深入探讨了在求解刚性问题时，计算精度与数值阻尼之间至关重要的权衡关系。通过研究它们在不同刚度下的行为，你将更深刻地理解为什么像 $A$ 稳定性和 $L$ 稳定性这样的性质在科学计算实践中如此重要。[@problem_id:3197729]", "problem": "考虑一个用于模拟化学动力学中单步刚性衰减的标量线性常微分方程，其形式为 $y'(t) = \\lambda y(t)$，其中 $\\lambda \\in \\mathbb{C}$ 且 $\\operatorname{Re}(\\lambda)  0$。当 $\\lambda$ 的幅值很大且为负时，该模型能捕捉到一个刚性化学动力学步骤的基本行为。设初始条件为 $y(0) = 1$。设在时间 $t=h$ 处计算步长为 $h  0$ 的单步数值解，并定义无量纲刚性参数 $z = h \\lambda$。\n\n绝对稳定性（$A$-稳定性）定义为数值方法对于任何满足 $\\operatorname{Re}(z) \\le 0$ 的 $z$ 保持稳定的性质，即方法的稳定性函数 $R(z)$ 对所有此类 $z$ 满足 $\\lvert R(z) \\rvert \\le 1$。$L$-稳定性（通常称为“刚性衰减”稳定性）加强了这一性质，它额外要求 $\\lim_{\\lvert z \\rvert \\to \\infty, \\operatorname{Re}(z) \\lt 0} R(z) = 0$，从而使得极刚性分量被积分器强力衰减。\n\n您的任务是分析两种隐式时间积分方法在应用于标量测试方程 $y'(t) = \\lambda y(t)$ 时，在精度和阻尼之间的权衡：\n- 一阶后向欧拉法，已知其是 $L$-稳定的。\n- 二阶梯形法则（也称为 Crank–Nicolson 方法），已知其是 $A$-稳定但非 $L$-稳定的。\n\n仅从方法定义和标量测试方程 $y'(t) = \\lambda y(t)$ 出发，在您的程序中执行以下步骤：\n\n1. 推导每种方法在步长为 $h$ 的单步中应用于 $y'(t) = \\lambda y(t)$ 时的单步更新公式，并由此推导出每种方法对应的稳定性函数 $R(z)$，其中 $z = h \\lambda$。\n2. 使用推导出的 $R(z)$，从 $y(0) = 1$ 开始，分别计算后向欧拉法和梯形法则的单步数值解 $y_{\\text{BE}}(h)$ 和 $y_{\\text{TR}}(h)$。\n3. 计算在 $t = h$ 时的精确解，即 $y_{\\text{exact}}(h) = \\exp(z)$，以及绝对误差 $\\lvert y_{\\text{BE}}(h) - y_{\\text{exact}}(h) \\rvert$ 和 $\\lvert y_{\\text{TR}}(h) - y_{\\text{exact}}(h) \\rvert$。\n4. 计算阻尼因子 $\\lvert R_{\\text{BE}}(z) \\rvert$ 和 $\\lvert R_{\\text{TR}}(z) \\rvert$，作为衡量每种方法在单步中抑制刚性模式强弱的度量。\n5. 对每个测试用例，确定两个布尔陈述：\n   - 梯形法则的单步解是否更精确，即 $\\lvert y_{\\text{TR}}(h) - y_{\\text{exact}}(h) \\rvert  \\lvert y_{\\text{BE}}(h) - y_{\\text{exact}}(h) \\rvert$ 是否成立。\n   - 后向欧拉法在单步中是否阻尼更强，即 $\\lvert R_{\\text{BE}}(z) \\rvert  \\lvert R_{\\text{TR}}(z) \\rvert$ 是否成立。\n\n报告的所有量都是无量纲的，所有浮点数输出必须四舍五入到 $6$ 位小数。\n\n使用以下参数值测试套件，其覆盖了轻度刚性、中度刚性和严重刚性：\n- 测试用例 1：$\\lambda = -1000$ 且 $h = 0.01$，因此 $z = -10$。\n- 测试用例 2：$\\lambda = -10^6$ 且 $h = 0.01$，因此 $z = -10^4$。\n- 测试用例 3：$\\lambda = -5$ 且 $h = 0.2$，因此 $z = -1$。\n- 测试用例 4：$\\lambda = -0.5$ 且 $h = 0.2$，因此 $z = -0.1$。\n\n您的程序应生成单行输出，其中包含所有测试用例的结果，形式为方括号括起来的逗号分隔列表，每个测试用例按以下顺序提供一个子列表：\n$[\\lvert y_{\\text{BE}}(h) - y_{\\text{exact}}(h) \\rvert, \\lvert y_{\\text{TR}}(h) - y_{\\text{exact}}(h) \\rvert, \\lvert R_{\\text{BE}}(z) \\rvert, \\lvert R_{\\text{TR}}(z) \\rvert, \\text{TR\\_more\\_accurate}, \\text{BE\\_damps\\_stronger}]$\n其中最后两项是布尔值。确切的所需输出格式为：\n$[[e_{\\text{BE},1}, e_{\\text{TR},1}, d_{\\text{BE},1}, d_{\\text{TR},1}, b_{1}, c_{1}],[e_{\\text{BE},2}, e_{\\text{TR},2}, d_{\\text{BE},2}, d_{\\text{TR},2}, b_{2}, c_{2}],[e_{\\text{BE},3}, e_{\\text{TR},3}, d_{\\text{BE},3}, d_{\\text{TR},3}, b_{3}, c_{3}],[e_{\\text{BE},4}, e_{\\text{TR},4}, d_{\\text{BE},4}, d_{\\text{TR},4}, b_{4}, c_{4}]]$\n其中没有任何空格，所有浮点值都四舍五入到 $6$ 位小数。", "solution": "该问题要求分析两种数值时间积分方法——后向欧拉法和梯形法则——在应用于一个刚性标量常微分方程（ODE）时，在精度和阻尼之间的权衡。该分析基于标准测试方程 $y'(t) = \\lambda y(t)$ 和初始条件 $y(0) = 1$。步长为 $h$ 的单步数值解记为 $y_1$。无量纲刚性参数为 $z = h\\lambda$。\n\n对于此线性测试方程，单步后的数值解可以表示为 $y_1 = R(z) y_0$ 的形式，其中 $R(z)$ 是该方法的稳定性函数。给定 $y_0 = y(0) = 1$，单步数值解就是 $y_1 = R(z)$。\n\n首先，我们推导每种方法的稳定性函数 $R(z)$。\n\n**1. 后向欧拉法 (BE)**\n\n后向欧拉法是一种一阶隐式方法，其更新公式定义为：\n$$\ny_{n+1} = y_n + h f(t_{n+1}, y_{n+1})\n$$\n将其应用于测试方程 $f(t, y) = \\lambda y$，我们得到：\n$$\ny_1 = y_0 + h (\\lambda y_1)\n$$\n我们求解 $y_1$：\n$$\ny_1 - h \\lambda y_1 = y_0\n$$\n$$\ny_1 (1 - h \\lambda) = y_0\n$$\n$$\ny_1 = \\frac{1}{1 - h \\lambda} y_0\n$$\n代入 $z = h\\lambda$，我们得到后向欧拉法的稳定性函数：\n$$\nR_{\\text{BE}}(z) = \\frac{1}{1 - z}\n$$\n此方法已知是 $L$-稳定的，因为对于 $\\operatorname{Re}(z) \\le 0$，我们有 $\\lvert 1-z \\rvert \\ge 1$，这意味着 $\\lvert R_{\\text{BE}}(z) \\rvert = \\frac{1}{\\lvert 1-z \\rvert} \\le 1$。此外，当 $\\lvert z \\rvert \\to \\infty$ 且 $\\operatorname{Re}(z)  0$ 时，我们有 $\\lvert R_{\\text{BE}}(z) \\rvert \\to 0$。\n\n**2. 梯形法则 (TR)**\n\n梯形法则（或 Crank–Nicolson 方法）是一种二阶隐式方法，定义为：\n$$\ny_{n+1} = y_n + \\frac{h}{2} \\left[ f(t_n, y_n) + f(t_{n+1}, y_{n+1}) \\right]\n$$\n将其应用于测试方程 $f(t, y) = \\lambda y$：\n$$\ny_1 = y_0 + \\frac{h}{2} (\\lambda y_0 + \\lambda y_1)\n$$\n我们求解 $y_1$：\n$$\ny_1 - \\frac{h \\lambda}{2} y_1 = y_0 + \\frac{h \\lambda}{2} y_0\n$$\n$$\ny_1 \\left(1 - \\frac{h \\lambda}{2}\\right) = y_0 \\left(1 + \\frac{h \\lambda}{2}\\right)\n$$\n$$\ny_1 = \\frac{1 + h \\lambda / 2}{1 - h \\lambda / 2} y_0\n$$\n代入 $z = h\\lambda$，我们得到梯形法则的稳定性函数：\n$$\nR_{\\text{TR}}(z) = \\frac{1 + z/2}{1 - z/2}\n$$\n此方法是 $A$-稳定的，因为对于任何满足 $\\operatorname{Re}(z) \\le 0$ 的 $z$，我们有 $\\lvert 1 + z/2 \\rvert \\le \\lvert 1 - z/2 \\rvert$，这意味着 $\\lvert R_{\\text{TR}}(z) \\rvert \\le 1$。然而，它不是 $L$-稳定的，因为当 $\\lvert z \\rvert \\to \\infty$ 且 $\\operatorname{Re}(z)  0$ 时：\n$$\n\\lim_{\\lvert z \\rvert \\to \\infty, \\operatorname{Re}(z)  0} \\lvert R_{\\text{TR}}(z) \\rvert = \\lim_{\\lvert z \\rvert \\to \\infty} \\left\\lvert \\frac{z/2(2/z + 1)}{z/2(2/z - 1)} \\right\\rvert = \\left\\lvert \\frac{1}{-1} \\right\\rvert = 1\n$$\n这意味着极刚性分量不会被梯形法则衰减掉。\n\n**3. 分析指标**\n\n对于每个由 $z$ 值定义的测试用例，我们计算以下量：\n\n- **精确解**：$y'(t) = \\lambda y(t)$ 且 $y(0) = 1$ 的精确解是 $y(t) = e^{\\lambda t}$。在时间 $t=h$ 时，解为 $y_{\\text{exact}}(h) = e^{\\lambda h} = e^z$。\n- **数值解**：由于 $y(0)=1$，单步数值解为 $y_{\\text{BE}}(h) = R_{\\text{BE}}(z)$ 和 $y_{\\text{TR}}(h) = R_{\\text{TR}}(z)$。\n- **绝对误差**：单步后的误差为 $e_{\\text{BE}} = \\lvert y_{\\text{BE}}(h) - y_{\\text{exact}}(h) \\rvert = \\lvert R_{\\text{BE}}(z) - e^z \\rvert$ 和 $e_{\\text{TR}} = \\lvert y_{\\text{TR}}(h) - y_{\\text{exact}}(h) \\rvert = \\lvert R_{\\text{TR}}(z) - e^z \\rvert$。\n- **阻尼因子**：单步中数值解的阻尼由稳定性函数的幅值来量化，即 $d_{\\text{BE}} = \\lvert R_{\\text{BE}}(z) \\rvert$ 和 $d_{\\text{TR}} = \\lvert R_{\\text{TR}}(z) \\rvert$。\n\n最后，我们确定以下布尔值：\n- $\\text{TR\\_more\\_accurate}$: $e_{\\text{TR}}  e_{\\text{BE}}$\n- $\\text{BE\\_damps\\_stronger}$: $d_{\\text{BE}}  d_{\\text{TR}}$\n\n程序现在将为给定的测试用例系统地计算这些量。测试用例对应于 $z = -10$、$z = -10^4$、$z = -1$ 和 $z = -0.1$。结果说明了这种权衡：由于其阶数更高，梯形法则在 $\\lvert z \\rvert$ 较小时通常更精确；而由于其 $L$-稳定性，后向欧拉法在 $\\lvert z \\rvert$ 较大时提供更优越的阻尼。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes the accuracy and damping properties of Backward Euler and Trapezoidal Rule\n    for a stiff scalar ODE.\n    \"\"\"\n    # The problem provides lambda and h, but the calculations only depend on z = h*lambda.\n    # Test case 1: lambda = -1000, h = 0.01  => z = -10.0\n    # Test case 2: lambda = -10^6,  h = 0.01  => z = -10000.0\n    # Test case 3: lambda = -5,    h = 0.2   => z = -1.0\n    # Test case 4: lambda = -0.5,   h = 0.2   => z = -0.1\n    test_cases_z = [-10.0, -10000.0, -1.0, -0.1]\n\n    all_results = []\n    \n    for z in test_cases_z:\n        # 1. Derive/Use stability functions R(z)\n        # For backward Euler: y_1 = y_0 + h * lambda * y_1 => y_1(1-h*lambda) = y_0 => y_1 = y_0 / (1-z)\n        # So, R_BE(z) = 1 / (1 - z)\n        R_be = 1.0 / (1.0 - z)\n\n        # For trapezoidal rule: y_1 = y_0 + h/2 * (lambda*y_0 + lambda*y_1) => y_1(1 - z/2) = y_0(1 + z/2)\n        # So, R_TR(z) = (1 + z/2) / (1 - z/2)\n        R_tr = (1.0 + z / 2.0) / (1.0 - z / 2.0)\n\n        # 2. Compute the one-step numerical solutions (y(0)=1, so y_1 = R(z))\n        y_be = R_be\n        y_tr = R_tr\n\n        # 3. Compute the exact solution and absolute errors\n        # Exact solution to y'=lambda*y is y(t)=y(0)*exp(lambda*t).\n        # At t=h, y(h) = 1 * exp(h*lambda) = exp(z)\n        y_exact = np.exp(z)\n        \n        # Absolute errors\n        e_be = np.abs(y_be - y_exact)\n        e_tr = np.abs(y_tr - y_exact)\n        \n        # 4. Compute the damping factors\n        d_be = np.abs(R_be)\n        d_tr = np.abs(R_tr)\n\n        # 5. Determine boolean statements\n        tr_more_accurate = e_tr  e_be\n        be_damps_stronger = d_be  d_tr\n\n        # Store the results for the current test case.\n        # [e_BE, e_TR, d_BE, d_TR, TR_more_accurate, BE_damps_stronger]\n        case_results = [e_be, e_tr, d_be, d_tr, tr_more_accurate, be_damps_stronger]\n        all_results.append(case_results)\n\n    # Format the final output string exactly as required.\n    # No spaces, 6 decimal places for floats, Python booleans as strings.\n    formatted_sublists = []\n    for case in all_results:\n        e_be_str = f\"{case[0]:.6f}\"\n        e_tr_str = f\"{case[1]:.6f}\"\n        d_be_str = f\"{case[2]:.6f}\"\n        d_tr_str = f\"{case[3]:.6f}\"\n        bool1_str = str(case[4])\n        bool2_str = str(case[5])\n        \n        sublist_str = f\"[{e_be_str},{e_tr_str},{d_be_str},{d_tr_str},{bool1_str},{bool2_str}]\"\n        formatted_sublists.append(sublist_str)\n\n    # Join the sublists with commas and enclose in brackets.\n    final_output = f\"[{','.join(formatted_sublists)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "3197729"}, {"introduction": "现实世界中的科学计算，本质上是在各种约束下做出最优选择的艺术。最后一个练习将挑战你从“分析者”转变为“设计者”：为特定任务挑选最合适的积分器。这需要你综合运用关于稳定性、精度和计算成本的知识，解决一个模拟真实计算科学家所面临挑战的工程设计问题，从而将所有学到的概念融会贯通。[@problem_id:3197721]", "problem": "给定一个线性初值问题，其空间半离散化后得到一个形式为 $y^{\\prime}(t) = J y(t)$ 的常微分方程，其中 $J \\in \\mathbb{C}^{n \\times n}$ 是一个有限差分雅可比矩阵。对于一个使用固定步长 $h  0$ 应用于标量线性测试方程 $y^{\\prime} = \\lambda y$ 的单步时间积分方法，其更新形式为 $y_{k+1} = R(z) y_{k}$，其中 $z = h \\lambda$，$R(z)$ 是与方法相关的稳定性函数。绝对稳定域定义为集合 $\\{ z \\in \\mathbb{C} : |R(z)| \\le 1 \\}$。一个A-稳定方法的绝对稳定域包含整个左半平面 $\\{ z \\in \\mathbb{C} : \\operatorname{Re}(z) \\le 0 \\}$。一个L-稳定方法是A-稳定方法，并额外满足沿负实轴 $\\lim_{z \\to -\\infty} R(z) = 0$ 的性质。您的任务是为每个测试用例选择一个时间积分器，并验证对于 $J$ 的所有特征值 $\\lambda$，缩放后的值 $z = h \\lambda$ 都位于该方法的绝对稳定域内，并且总计算功不超过给定的预算。\n\n您必须从以下方法中进行选择，其索引如下：\n- 索引 $0$：显式 Euler 法。\n- 索引 $1$：4 阶经典 Runge–Kutta 法。\n- 索引 $2$：后向 Euler 法。\n- 索引 $3$：梯形法则 (Crank–Nicolson)。\n\n成本模型和选择策略：\n- 总模拟时间为 $T  0$，固定步长为 $h  0$。步数为 $N_{\\text{steps}} = \\lceil T / h \\rceil$。\n- 每步成本（以抽象工作单位计）对每种方法都是常数：显式 Euler 法成本为 $1$，经典 Runge–Kutta 法为 $4$，后向 Euler 法为 $30$，梯形法则为 $50$。总功为 $W = N_{\\text{steps}} \\times \\text{(每步成本)}$。\n- 一个方法对于某个测试用例是可行的，当且仅当以下两条都成立：\n  1. 对于该用例提供的每个特征值 $\\lambda$，其对应的 $z = h \\lambda$ 位于该方法的绝对稳定域内（即 $|R(z)| \\le 1$）。\n  2. 总功 $W$ 不超过该用例给定的工作预算 $W_{\\max}$。\n- 刚性问题的偏好规则：定义刚性指标 $\\sigma = \\max_{\\lambda} \\left( -\\operatorname{Re}(h \\lambda) \\right)$。如果 $\\sigma \\ge \\tau$（该用例提供的阈值），则在可行方法中必须优先选择 L-稳定方法。如果不存在可行的 L-稳定方法，则退而求其次选择任何可行方法。如果 $\\sigma  \\tau$，则忽略对 L-稳定性的偏好。\n- 在偏好集合中的方法里（当 $\\sigma \\ge \\tau$ 时仅包括 L-稳定方法，或当 $\\sigma  \\tau$ 时包括所有可行方法），选择总功 $W$ 最小的那个。如果总功相同，选择精度阶数更高的方法。如果仍然相同，选择索引更小的方法。\n\n您必须使用的基础理论：\n- 应用于 $y^{\\prime} = \\lambda y$ 的单步方法的绝对稳定域定义为 $\\{ z \\in \\mathbb{C} : |R(z)| \\le 1 \\}$。\n- 时间步长到 $z$ 的映射为 $z = h \\lambda$，对每个特征值 $\\lambda$ 都适用。\n- 对于 A-稳定性和 L-稳定性的分类，您必须基于上述定义进行推理。\n\n实现一个程序，该程序：\n- 对每个测试用例，使用从所列各方法的标准定义推导出的精确稳定性函数 $R(z)$ 来评估可行性并应用选择策略。\n- 输出所选方法的索引（整数），如果无方法可行则输出 $-1$。\n\n测试套件：\n为以下 $5$ 个测试用例提供输出。在每个用例中，都明确列出了特征值，$T$、$h$、$W_{\\max}$ 和 $\\tau$ 也已给定，如果进行任何复数运算需要，角度单位为弧度。\n\n- 用例 $1$：\n  - 特征值：$\\{-1.0, -2.0\\}$。\n  - $T = 1.0$。\n  - $h = 0.2$。\n  - $W_{\\max} = 6$。\n  - $\\tau = 25$。\n- 用例 $2$：\n  - 特征值：$\\{-100.0, -200.0\\}$。\n  - $T = 1.0$。\n  - $h = 0.1$。\n  - $W_{\\max} = 400$。\n  - $\\tau = 25$。\n- 用例 $3$：\n  - 特征值：$\\{-1.0 + 1.0 i, -1.0 - 1.0 i\\}$，其中 $i = \\sqrt{-1}$。\n  - $T = 2.0$。\n  - $h = 0.2$。\n  - $W_{\\max} = 8$。\n  - $\\tau = 25$。\n- 用例 $4$：\n  - 特征值：$\\{-25.0\\}$。\n  - $T = 1.0$。\n  - $h = 0.1$。\n  - $W_{\\max} = 50$。\n  - $\\tau = 25$。\n- 用例 $5$：\n  - 特征值：$\\{-800.0\\}$。\n  - $T = 1.0$。\n  - $h = 0.05$。\n  - $W_{\\max} = 1000$。\n  - $\\tau = 25$。\n\n最终输出格式：您的程序应生成单行输出，其中包含按顺序排列的各用例所选方法的索引，格式为逗号分隔的列表并用方括号括起，例如 $[a,b,c,d,e]$，其中每个条目是整数索引，如果无方法可行则为 $-1$。输出中不应出现空格。", "solution": "该问题要求为一系列形式为 $y'(t) = Jy(t)$ 的线性初值问题，根据稳定性、计算成本和刚性标准选择最合适的时间积分方法。此选择过程必须对五个不同的测试用例执行。\n\n问题的核心在于绝对稳定性的概念。对于标量测试方程 $y' = \\lambda y$，一个步长为 $h$ 的单步法产生迭代 $y_{k+1} = R(z) y_k$，其中 $z = h\\lambda$，$R(z)$ 是该方法的稳定性函数。对于给定的 $z$，该方法是稳定的，当且仅当 $|R(z)| \\le 1$。所有此类 $z \\in \\mathbb{C}$ 的集合构成了绝对稳定域。\n\n首先，我们必须确定四种候选方法的属性。这些属性包括方法的索引、精度阶数、每步计算成本、稳定性函数 $R(z)$，以及其关于 A-稳定性和 L-稳定性的分类。\n\n四种方法是：\n- 索引 $0$：显式 Euler 法 (EE)，1 阶，成本 $1$。\n- 索引 $1$：4 阶经典 Runge-Kutta 法 (RK4)，4 阶，成本 $4$。\n- 索引 $2$：后向 Euler 法 (BE)，1 阶，成本 $30$。\n- 索引 $3$：梯形法则 (TR)，2 阶，成本 $50$。\n\n稳定性函数 $R(z)$ 是通过将每种方法应用于测试方程 $y'=\\lambda y$ 推导出来的。\n1.  **显式 Euler 法（方法 0）**：更新为 $y_{k+1} = y_k + h (\\lambda y_k) = (1+h\\lambda)y_k$。\n    $$R_0(z) = 1 + z$$\n    其稳定域为 $\\{z \\in \\mathbb{C} : |1+z| \\le 1\\}$，这是一个以 $z=-1$ 为中心、半径为 $1$ 的圆盘。该区域不包含左半平面 $\\{z \\in \\mathbb{C} : \\operatorname{Re}(z) \\le 0\\}$，因此该方法 **不是 A-稳定的**。\n\n2.  **经典 Runge-Kutta 法（方法 1）**：该方法的稳定性函数是指数函数的截断泰勒级数，截到方法的阶数。对于 4 阶，我们有：\n    $$R_1(z) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24}$$\n    其稳定域是有界的，不包含整个左半平面。例如，对于 $z = -10$，有 $|R_1(-10)| \\approx 301  1$。因此，RK4 **不是 A-稳定的**。\n\n3.  **后向 Euler 法（方法 2）**：隐式更新为 $y_{k+1} = y_k + h (\\lambda y_{k+1})$。解出 $y_{k+1}$ 得 $y_{k+1}(1-h\\lambda) = y_k$，所以 $y_{k+1} = (1-h\\lambda)^{-1}y_k$。\n    $$R_2(z) = \\frac{1}{1 - z}$$\n    对于任何 $z = x+iy$ 且 $x = \\operatorname{Re}(z) \\le 0$，我们有 $|R_2(z)|^2 = |\\frac{1}{1-x-iy}|^2 = \\frac{1}{(1-x)^2 + y^2}$。因为 $x \\le 0$，所以 $1-x \\ge 1$，因此 $(1-x)^2 \\ge 1$。分母总是大于或等于 $1$，所以 $|R_2(z)| \\le 1$。该方法是 **A-稳定的**。\n    对于 L-稳定性，我们考察沿负实轴 $z \\to -\\infty$ 时的极限：$\\lim_{z \\to -\\infty} R_2(z) = \\lim_{z \\to -\\infty} \\frac{1}{1-z} = 0$。条件满足，所以该方法是 **L-稳定的**。\n\n4.  **梯形法则（方法 3）**：隐式更新为 $y_{k+1} = y_k + \\frac{h}{2}(\\lambda y_k + \\lambda y_{k+1})$。解出 $y_{k+1}$ 得 $y_{k+1}(1 - \\frac{h\\lambda}{2}) = y_k(1 + \\frac{h\\lambda}{2})$。\n    $$R_3(z) = \\frac{1 + z/2}{1 - z/2}$$\n    对于任何 $z=x+iy$ 且 $x = \\operatorname{Re}(z) \\le 0$，有 $|R_3(z)|^2 = \\frac{|1+x/2+iy/2|^2}{|1-x/2-iy/2|^2} = \\frac{(1+x/2)^2+(y/2)^2}{(1-x/2)^2+(y/2)^2} = \\frac{1+x+x^2/4+y^2/4}{1-x+x^2/4+y^2/4}$。因为 $x \\le 0$，分子小于或等于分母，所以 $|R_3(z)| \\le 1$。该方法是 **A-稳定的**。\n    对于 L-稳定性，我们检查其极限：$\\lim_{z \\to -\\infty} R_3(z) = \\lim_{z \\to -\\infty} \\frac{1+z/2}{1-z/2} = -1$。由于极限不为 $0$，该方法 **不是 L-稳定的**。\n\n每个测试用例的选择过程如下：\n1.  计算时间步数 $N_{\\text{steps}} = \\lceil T/h \\rceil$。\n2.  对提供的每个特征值 $\\lambda$，计算相应的稳定性参数 $z = h\\lambda$。\n3.  评估刚性指标 $\\sigma = \\max_{\\lambda}(-\\operatorname{Re}(z))$。\n4.  对每种方法（索引 $i=0, 1, 2, 3$）：\n    a. 计算总功 $W_i = N_{\\text{steps}} \\times \\text{cost}_i$。\n    b. 检查预算约束：$W_i \\le W_{\\max}$。\n    c. 检查稳定性约束：对所有计算出的 $z$ 值，验证 $|R_i(z)| \\le 1$。\n    d. 如果两个约束都满足，则该方法是可行的。\n5.  从所有可行方法的集合中，构建一个偏好集合。\n    a. 如果 $\\sigma \\ge \\tau$，偏好集合由所有可行的 L-稳定方法组成。如果该集合为空，则偏好集合默认为所有可行方法。\n    b. 如果 $\\sigma  \\tau$，偏好集合就是所有可行方法的集合。\n6.  如果偏好集合为空，则不存在解决方案，结果为 $-1$。否则，使用一个决胜层级规则从偏好集合中选择一个方法：\n    a. 选择总功 $W$ 最小的方法。\n    b. 如果功相同，选择精度阶数最高的方法。\n    c. 如果仍然相同，选择索引最小的方法。\n\n现在我们将此过程应用于每个测试用例。\n\n**用例 1**：$\\lambda \\in \\{-1.0, -2.0\\}$，$T=1.0$，$h=0.2$，$W_{\\max}=6$，$\\tau=25$。\n- $N_{\\text{steps}} = \\lceil 1.0/0.2 \\rceil = 5$。\n- $z \\in \\{0.2(-1.0), 0.2(-2.0)\\} = \\{-0.2, -0.4\\}$。\n- $\\sigma = \\max(0.2, 0.4) = 0.4$。由于 $\\sigma  \\tau$，对 L-稳定性没有偏好。\n- **方法 0 (EE)**：$W_0=5 \\times 1=5 \\le 6$ (满足)。$|R_0(-0.2)|=0.8 \\le 1$ 且 $|R_0(-0.4)|=0.6 \\le 1$ (满足)。可行。\n- **方法 1 (RK4)**：$W_1=5 \\times 4=20  6$ (不可行)。\n- **方法 2 (BE)**：$W_2=5 \\times 30=150  6$ (不可行)。\n- **方法 3 (TR)**：$W_3=5 \\times 50=250  6$ (不可行)。\n唯一可行的方法是方法 $0$。\n**选择的索引：$0$**\n\n**用例 2**：$\\lambda \\in \\{-100.0, -200.0\\}$，$T=1.0$，$h=0.1$，$W_{\\max}=400$，$\\tau=25$。\n- $N_{\\text{steps}} = \\lceil 1.0/0.1 \\rceil = 10$。\n- $z \\in \\{0.1(-100.0), 0.1(-200.0)\\} = \\{-10.0, -20.0\\}$。\n- $\\sigma = \\max(10.0, 20.0) = 20.0$。由于 $\\sigma  \\tau$，对 L-稳定性没有偏好。\n- **方法 0 (EE)**：仅在 $[-2, 0]$ 上稳定。对于 $z=-10, -20$ 不稳定。(不可行)。\n- **方法 1 (RK4)**：仅在约 $[-2.785, 0]$ 上稳定。对于 $z=-10, -20$ 不稳定。(不可行)。\n- **方法 2 (BE)**：$W_2=10 \\times 30=300 \\le 400$ (满足)。A-稳定，因此对于 $z=-10, -20$ 稳定 (满足)。可行。\n- **方法 3 (TR)**：$W_3=10 \\times 50=500  400$ (不可行)。\n唯一可行的方法是方法 $2$。\n**选择的索引：$2$**\n\n**用例 3**：$\\lambda \\in \\{-1.0+1.0i, -1.0-1.0i\\}$，$T=2.0$，$h=0.2$，$W_{\\max}=8$，$\\tau=25$。\n- $N_{\\text{steps}} = \\lceil 2.0/0.2 \\rceil = 10$。\n- 方法 0 的可能最小功为：$W_0=10 \\times 1 = 10$。\n- 由于 $W_0  W_{\\max}=8$，没有方法能满足预算约束。\n**选择的索引：$-1$**\n\n**用例 4**：$\\lambda \\in \\{-25.0\\}$，$T=1.0$，$h=0.1$，$W_{\\max}=50$，$\\tau=25$。\n- $N_{\\text{steps}} = \\lceil 1.0/0.1 \\rceil = 10$。\n- $z = 0.1(-25.0) = -2.5$。\n- $\\sigma = 2.5$。由于 $\\sigma  \\tau$，对 L-稳定性没有偏好。\n- **方法 0 (EE)**：对于 $z=-2.5$ 不稳定。(不可行)。\n- **方法 1 (RK4)**：$W_1=10 \\times 4=40 \\le 50$ (满足)。$|R_1(-2.5)| \\approx |-0.352| \\le 1$ (满足)。可行。\n- **方法 2 (BE)**：$W_2=10 \\times 30=300  50$ (不可行)。\n- **方法 3 (TR)**：$W_3=10 \\times 50=500  50$ (不可行)。\n唯一可行的方法是方法 $1$。\n**选择的索引：$1$**\n\n**用例 5**：$\\lambda \\in \\{-800.0\\}$，$T=1.0$，$h=0.05$，$W_{\\max}=1000$，$\\tau=25$。\n- $N_{\\text{steps}} = \\lceil 1.0/0.05 \\rceil = 20$。\n- $z = 0.05(-800.0) = -40.0$。\n- $\\sigma = 40.0$。由于 $\\sigma \\ge \\tau$，优先选择 L-稳定方法。\n- **方法 0 (EE)**：对于 $z=-40$ 不稳定。(不可行)。\n- **方法 1 (RK4)**：对于 $z=-40$ 不稳定。(不可行)。\n- **方法 2 (BE)**：$W_2=20 \\times 30=600 \\le 1000$ (满足)。A-稳定 (满足)。可行。是 L-稳定的。\n- **方法 3 (TR)**：$W_3=20 \\times 50=1000 \\le 1000$ (满足)。A-稳定 (满足)。可行。不是 L-稳定的。\n可行的方法是 $\\{2, 3\\}$。由于 $\\sigma \\ge \\tau$，偏好集合由可行的 L-稳定方法组成。只有方法 2 是 L-稳定的。因此，偏好集合是 $\\{2\\}$。\n**选择的索引：$2$**\n\n最终结果：五个用例选择的索引是 $[0, 2, -1, 1, 2]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other non-standard libraries are used.\nimport math\n\ndef solve():\n    \"\"\"\n    Solves for the optimal time integrator for a series of test cases based on\n    stability, cost, and stiffness criteria.\n    \"\"\"\n\n    # Define the properties of the four candidate methods.\n    # index, name, order, per_step_cost, is_L_stable, stability_function R(z)\n    methods = [\n        (0, \"Explicit Euler\", 1, 1, False, lambda z: 1 + z),\n        (1, \"RK4\", 4, 4, False, lambda z: 1 + z + z**2/2 + z**3/6 + z**4/24),\n        (2, \"Backward Euler\", 1, 30, True, lambda z: 1 / (1 - z)),\n        (3, \"Trapezoidal Rule\", 2, 50, False, lambda z: (1 + z/2) / (1 - z/2))\n    ]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        { \"eigenvalues\": [-1.0, -2.0], \"T\": 1.0, \"h\": 0.2, \"W_max\": 6, \"tau\": 25 },\n        { \"eigenvalues\": [-100.0, -200.0], \"T\": 1.0, \"h\": 0.1, \"W_max\": 400, \"tau\": 25 },\n        { \"eigenvalues\": [-1.0 + 1.0j, -1.0 - 1.0j], \"T\": 2.0, \"h\": 0.2, \"W_max\": 8, \"tau\": 25 },\n        { \"eigenvalues\": [-25.0], \"T\": 1.0, \"h\": 0.1, \"W_max\": 50, \"tau\": 25 },\n        { \"eigenvalues\": [-800.0], \"T\": 1.0, \"h\": 0.05, \"W_max\": 1000, \"tau\": 25 },\n    ]\n\n    final_results = []\n    \n    for case in test_cases:\n        T = case[\"T\"]\n        h = case[\"h\"]\n        W_max = case[\"W_max\"]\n        tau = case[\"tau\"]\n        eigenvalues = np.array(case[\"eigenvalues\"], dtype=complex)\n\n        n_steps = math.ceil(T / h)\n        \n        # Calculate z values and stiffness indicator sigma\n        z_values = h * eigenvalues\n        if len(z_values) == 0:\n            sigma = 0.0\n        else:\n            sigma = np.max(-np.real(z_values))\n\n        feasible_methods = []\n        for index, name, order, cost, is_l_stable, R_func in methods:\n            # 1. Check budget constraint\n            total_work = n_steps * cost\n            if total_work > W_max:\n                continue\n\n            # 2. Check stability constraint\n            is_stable = True\n            for z in z_values:\n                # Using a small tolerance for floating point comparison |R(z)| = 1\n                if abs(R_func(z)) > 1.0 + 1e-9:\n                    is_stable = False\n                    break\n            \n            if is_stable:\n                feasible_methods.append({\n                    \"index\": index,\n                    \"work\": total_work,\n                    \"order\": order,\n                    \"l_stable\": is_l_stable\n                })\n\n        if not feasible_methods:\n            final_results.append(-1)\n            continue\n        \n        # Apply selection logic\n        preferred_set = []\n        if sigma >= tau:\n            l_stable_feasible = [m for m in feasible_methods if m[\"l_stable\"]]\n            if l_stable_feasible:\n                preferred_set = l_stable_feasible\n            else:\n                # Fallback rule\n                preferred_set = feasible_methods\n        else:\n            preferred_set = feasible_methods\n            \n        # Apply tie-breaking rules by sorting\n        # 1. Smallest total work (ascending)\n        # 2. Highest order of accuracy (descending, so use negative order)\n        # 3. Smallest index (ascending)\n        preferred_set.sort(key=lambda m: (m[\"work\"], -m[\"order\"], m[\"index\"]))\n        \n        best_method_index = preferred_set[0][\"index\"]\n        final_results.append(best_method_index)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "3197721"}]}