{"hands_on_practices": [{"introduction": "理解数值方法的精确度始于分析其局部截断误差（Local Truncation Error, LTE）。这个练习将引导你通过一个具体的符号演算实例，为二阶Adams-Bashforth（AB2）方法推导局部截断误差的精确表达式。通过将理论定义付诸实践，这个练习旨在将抽象的误差概念变得具体可感，并加深你对方法阶数的理解。[@problem_id:3153704]", "problem": "考虑初值问题 $y'(t) = f(t) = t^{2}$，其中 $y(0) = 0$，其精确反导数是已知的。使用两步 Adams–Bashforth (AB2) 方法，将第 $(n+1)$ 步的局部截断误差定义为，在先前值都是精确的情况下，精确单步增量与方法预测的增量之差。从基本恒等式 $y(t+h) - y(t) = \\int_{t}^{t+h} f(s)\\,ds$ 出发，以闭合形式推导局部截断误差 $\\tau_{n+1}$ 作为步长 $h$ 和网格点 $t_{n}$ 的函数的符号表达式。然后，通过在任意 $t_{n}$ 处对 $h = 0.2$ 数值计算 $\\tau_{n+1}$ 来验证其阶数，并将您的数值结果四舍五入到五位有效数字。提供 $\\tau_{n+1}$ 的精确符号表达式作为您的最终答案（无单位）。", "solution": "该问题要求推导应用于初值问题 $y'(t) = f(t) = t^2$（其中 $y(0) = 0$）的两步 Adams-Bashforth (AB2) 方法的局部截断误差。\n\n首先，我们建立必要的定义。网格点定义为 $t_k = k h$，其中 $h  0$ 是一个恒定的步长。给定的常微分方程是 $y'(t) = f(t, y(t))$，其中函数 $f$ 与 $y$ 无关，由 $f(t) = t^2$ 给出。\n\n两步 Adams-Bashforth (AB2) 方法使用以下公式生成精确解 $y(t_{n+1})$ 的近似值 $y_{n+1}$：\n$$y_{n+1} = y_n + h \\left( \\frac{3}{2} f_n - \\frac{1}{2} f_{n-1} \\right)$$\n其中 $f_k = f(t_k, y_k)$。对于给定的特定问题，$f_k = t_k^2$。\n\n第 $n+1$ 步的局部截断误差（记为 $\\tau_{n+1}$）被定义为精确单步增量与方法预测的增量之差，前提是假设所有先前值都是精确的。也就是说，我们假设 $y_n = y(t_n)$ 和 $y_{n-1} = y(t_{n-1})$。因此误差为：\n$$\\tau_{n+1} = \\left( y(t_{n+1}) - y(t_n) \\right) - \\left( y_{n+1} - y_n \\right)$$\n将 AB2 公式的数值增量 $(y_{n+1} - y_n)$ 代入，我们得到：\n$$\\tau_{n+1} = \\left( y(t_{n+1}) - y(t_n) \\right) - h \\left( \\frac{3}{2} f(t_n) - \\frac{1}{2} f(t_{n-1}) \\right)$$\n其中我们使用 $f(t_k)$，因为我们假设过去的点位于精确解曲线上。\n\n题目要求从精确增量的基本恒等式出发进行推导，该恒等式通过将微分方程 $y'(s) = f(s)$ 从 $t_n$ 积分到 $t_{n+1}$ 得到：\n$$y(t_{n+1}) - y(t_n) = \\int_{t_n}^{t_{n+1}} f(s) \\, ds$$\n对于 $f(s) = s^2$，精确增量为：\n$$y(t_{n+1}) - y(t_n) = \\int_{t_n}^{t_{n+1}} s^2 \\, ds = \\left[ \\frac{s^3}{3} \\right]_{t_n}^{t_{n+1}} = \\frac{t_{n+1}^3 - t_n^3}{3}$$\n使用 $t_{n+1} = t_n + h$，我们展开该表达式：\n$$y(t_{n+1}) - y(t_n) = \\frac{(t_n + h)^3 - t_n^3}{3} = \\frac{(t_n^3 + 3t_n^2h + 3t_nh^2 + h^3) - t_n^3}{3} = t_n^2h + t_nh^2 + \\frac{h^3}{3}$$\n\n接下来，我们计算 AB2 方法预测的数值增量。\nAB2 增量为 $h \\left( \\frac{3}{2} f(t_n) - \\frac{1}{2} f(t_{n-1}) \\right)$。当 $f(t) = t^2$, $t_n$ 和 $t_{n-1} = t_n - h$ 时，这变为：\n$$\\text{AB2 increment} = h \\left( \\frac{3}{2} t_n^2 - \\frac{1}{2} (t_n - h)^2 \\right)$$\n展开平方项：\n$$\\text{AB2 increment} = h \\left( \\frac{3}{2} t_n^2 - \\frac{1}{2} (t_n^2 - 2t_nh + h^2) \\right) = h \\left( \\frac{3}{2} t_n^2 - \\frac{1}{2} t_n^2 + t_nh - \\frac{1}{2} h^2 \\right)$$\n化简括号内的项：\n$$\\text{AB2 increment} = h \\left( t_n^2 + t_nh - \\frac{1}{2}h^2 \\right) = t_n^2h + t_nh^2 - \\frac{h^3}{2}$$\n\n现在，我们通过从精确增量中减去数值增量来计算局部截断误差 $\\tau_{n+1}$：\n$$\\tau_{n+1} = \\left( t_n^2h + t_nh^2 + \\frac{h^3}{3} \\right) - \\left( t_n^2h + t_nh^2 - \\frac{h^3}{2} \\right)$$\n涉及 $t_n$ 的项相互抵消：\n$$\\tau_{n+1} = \\frac{h^3}{3} - \\left(-\\frac{h^3}{2}\\right) = \\frac{h^3}{3} + \\frac{h^3}{2} = \\left(\\frac{2+3}{6}\\right)h^3 = \\frac{5}{6}h^3$$\n局部截断误差的符号表达式为 $\\tau_{n+1} = \\frac{5}{6}h^3$。值得注意的是，对于这个特定问题，其中 $y'''(t) = f''(t)$ 是一个常数，局部截断误差与网格点 $t_n$ 无关。\n\n为了数值验证此结果，我们按要求使用 $h = 0.2$。符号公式给出：\n$$\\tau_{n+1} = \\frac{5}{6}(0.2)^3 = \\frac{5}{6}(0.008) = \\frac{0.04}{6} = \\frac{0.02}{3} \\approx 0.0066666...$$\n让我们在一个任意的网格点（例如 $t_n = 1.0$）通过直接计算来证实这一点。这意味着 $t_{n-1} = 0.8$ 且 $t_{n+1} = 1.2$。\n精确增量为：\n$$y(1.2)-y(1.0) = \\int_{1.0}^{1.2} s^2 \\, ds = \\frac{1.2^3 - 1.0^3}{3} = \\frac{1.728 - 1.0}{3} = \\frac{0.728}{3}$$\nAB2 增量为：\n$$h \\left( \\frac{3}{2} t_n^2 - \\frac{1}{2} t_{n-1}^2 \\right) = 0.2 \\left( \\frac{3}{2}(1.0)^2 - \\frac{1}{2}(0.8)^2 \\right) = 0.2 \\left( 1.5 - \\frac{1}{2}(0.64) \\right) = 0.2(1.5 - 0.32) = 0.2(1.18) = 0.236$$\n数值误差为：\n$$\\tau_{n+1} = \\frac{0.728}{3} - 0.236 = \\frac{0.728 - 3 \\times 0.236}{3} = \\frac{0.728 - 0.708}{3} = \\frac{0.02}{3}$$\n这个数值计算结果与符号公式的结果完全匹配。四舍五入到五位有效数字，其数值为 $0.0066667$。误差与 $h^3$ 成正比这一事实证实了该方法是二阶的，这是 AB2 方法的一个特性。\n最终要求的答案是局部截断误差的符号表达式。", "answer": "$$\\boxed{\\frac{5}{6}h^{3}}$$", "id": "3153704"}, {"introduction": "局部截断误差和全局误差之间的关系是理解线性多步法收敛性的核心。本练习通过一个编程任务，让你亲手验证一个重要的理论结果：一个局部截断误差为 $O(h^{p+1})$ 的方法，其全局误差的收敛阶为 $O(h^p)$。通过数值实验，你将直观地观察到这一阶数差异，从而巩固对方法收敛性的深刻理解。[@problem_id:2410045]", "problem": "编写一个程序，该程序针对一系列均匀步长和方法阶数，数值地验证 $p$ 步 Adams-Bashforth (AB) 方法的全局误差和局部截断误差的渐近阶。考虑初值问题 $y^{\\prime}(t)=-y(t)$，$t \\in [0,1]$，$y(0)=1$，其精确解为 $y(t)=e^{-t}$。对于给定的整数阶 $p \\in \\{1,2,3,4\\}$，定义均匀网格 $t_n=n h$，其中 $h \\in \\{1/8,1/16,1/32,1/64\\}$ 且 $n=0,1,\\dots,N$，其中 $N=1/h$。对于每一对 $(p,h)$，在此网格上应用一个 $p$ 步 Adams-Bashforth 方法，计算 $y(1)$ 的一个数值近似值 $y_N$，并使用前 $p$ 个网格点上的精确解值进行初始化，即 $y(t_0),y(t_1),\\dots,y(t_{p-1})$。对于相同的 $(p,h)$，为精确解定义局部单步残差，对于索引 $n=p-1,p,\\dots,N-1$，其定义为\n$$\nr_{n+1} \\equiv y(t_{n+1}) - y(t_n) - h \\sum_{j=0}^{p-1} \\beta_j f\\!\\left(t_{n-j}, y(t_{n-j})\\right),\n$$\n其中 $f(t,y)=-y$ 且 $\\{\\beta_j\\}_{j=0}^{p-1}$ 是与该方法相关的 $p$ 步 Adams-Bashforth 权重。对于每个固定的 $p$，将观测到的全局误差阶计算为 $\\log(E(h))$ 相对于 $\\log(h)$ 在所有步长集合上的最佳拟合线的斜率，其中 $E(h)=\\lvert y_N - y(1)\\rvert$；并计算观测到的局部截断误差阶为 $\\log(R(h))$ 相对于 $\\log(h)$ 的最佳拟合线的斜率，其中 $R(h)=\\max_{n=p-1,\\dots,N-1} \\lvert r_{n+1}\\rvert$。报告每个 $p \\in \\{1,2,3,4\\}$ 的这些观测阶，以数值地验证全局误差为 $O(h^p)$ 且局部截断误差为 $O(h^{p+1})$。\n\n测试套件和答案规范：\n- 待测试参数：\n  - 阶数 $p \\in \\{1,2,3,4\\}$。\n  - 步长 $h \\in \\{1/8,1/16,1/32,1/64\\}$。\n- 对于每个 $p$，输出两个浮点数：\n  - 基于四个 $E(h)$ 值的观测全局误差阶。\n  - 基于四个 $R(h)$ 值的观测局部截断误差阶。\n- 要求的最终输出格式：\n  - 您的程序应生成一行包含一个用方括号括起来的逗号分隔列表，其中包含对应于 $p=1,2,3,4$ 的八个数字，按顺序展平为 $[g_1,\\ell_1,g_2,\\ell_2,g_3,\\ell_3,g_4,\\ell_4]$，其中 $g_p$ 是阶数为 $p$ 的方法的观测全局误差阶，$\\ell_p$ 是阶数为 $p$ 的方法的观测局部截断误差阶。每个数字必须四舍五入到三位小数。\n- 本问题中没有需要报告的物理单位或角度。\n\n您的程序必须是自包含的，且不得读取任何输入。它必须按上述规定计算并打印结果。", "solution": "所提出的问题是常微分方程数值分析中的一个标准练习。它在科学上是合理的、适定的，并包含了继续研究所需的所有必要信息。任务是数值地验证 $p$ 步 Adams-Bashforth 方法在阶数 $p=1, 2, 3, 4$ 时，其全局误差和局部截断误差的理论收敛阶。该问题是有效的。\n\n指定的初值问题 (IVP) 由下式给出\n$$\ny^{\\prime}(t) = -y(t), \\quad t \\in [0, 1]\n$$\n初始条件为 $y(0) = 1$。右侧的函数是 $f(t,y) = -y$。此 IVP 的解析解已知为 $y(t) = e^{-t}$。\n\n在均匀网格 $t_n = n h$ 上，用于逼近 IVP $y^{\\prime} = f(t,y)$ 解的 $p$ 步 Adams-Bashforth (AB) 方法的一般形式为\n$$\ny_{n+1} = y_n + h \\sum_{j=0}^{p-1} \\beta_j f(t_{n-j}, y_{n-j})\n$$\n此公式适用于 $n \\geq p-1$。该方法需要 $p$ 个起始值，$y_0, y_1, \\dots, y_{p-1}$。问题规定这些值应取自精确解，即 $y_k = y(t_k) = e^{-kh}$，其中 $k=0, 1, \\dots, p-1$。对于阶数 $p=1, 2, 3, 4$ 的方法，其系数 $\\{\\beta_j\\}_{j=0}^{p-1}$ 是标准的：\n对于 $p=1$ (向前欧拉法)：\n$$\n\\beta_0 = 1\n$$\n对于 $p=2$：\n$$\n\\beta_0 = \\frac{3}{2}, \\quad \\beta_1 = -\\frac{1}{2}\n$$\n对于 $p=3$：\n$$\n\\beta_0 = \\frac{23}{12}, \\quad \\beta_1 = -\\frac{16}{12}, \\quad \\beta_2 = \\frac{5}{12}\n$$\n对于 $p=4$：\n$$\n\\beta_0 = \\frac{55}{24}, \\quad \\beta_1 = -\\frac{59}{24}, \\quad \\beta_2 = \\frac{37}{24}, \\quad \\beta_3 = -\\frac{9}{24}\n$$\n对于每对 $(p,h)$，必须计算两个量。首先是最终时间 $t=1$ 处的全局误差。其定义为 $E(h) = \\lvert y_N - y(1)\\rvert$，其中 $N=1/h$，$y_N$ 是在 $t_N=1$ 处的数值近似，而 $y(1)=e^{-1}$ 是精确值。已知一个 $p$ 步 AB 方法的全局误差阶为 $p$，因此我们期望 $E(h) \\propto h^p$。\n\n其次，我们分析局部单步残差，它是通过将精确解 $y(t)$ 代入单步公式来定义的：\n$$\nr_{n+1} \\equiv y(t_{n+1}) - y(t_n) - h \\sum_{j=0}^{p-1} \\beta_j f(t_{n-j}, y(t_{n-j}))\n$$\n问题将局部截断误差的度量定义为 $R(h) = \\max_{n=p-1,\\dots,N-1} \\lvert r_{n+1}\\rvert$。对于一个 $p$ 步 AB 方法，该残差理论上是 $p+1$ 阶的，意味着 $r_{n+1} = O(h^{p+1})$。因此，我们期望观测到 $R(h) \\propto h^{p+1}$。请注意，这与局部截断误差的标准定义不同，后者的定义是 $T_{n+1} = r_{n+1}/h$，其阶数为 $p$。该问题在其定义上是自洽的。\n\n为了数值验证这些收敛阶，我们假设关系式 $E(h) \\approx C_g h^{g_p}$ 和 $R(h) \\approx C_l h^{\\ell_p}$ 成立，其中 $g_p$ 和 $\\ell_p$ 是阶数为 $p$ 的方法的观测收敛阶。通过取自然对数，我们得到线性关系：\n$$\n\\log(E(h)) \\approx \\log(C_g) + g_p \\log(h)\n$$\n$$\n\\log(R(h)) \\approx \\log(C_l) + \\ell_p \\log(h)\n$$\n对于每个固定的 $p$，我们计算步长集合 $h \\in \\{1/8, 1/16, 1/32, 1/64\\}$ 中每个 $h$ 对应的 $E(h)$ 和 $R(h)$ 的值。然后，我们对点集 $(\\log(h), \\log(E(h)))$ 和 $(\\log(h), \\log(R(h)))$ 进行线性回归。这些最佳拟合线的斜率分别提供了观测阶 $g_p$ 和 $\\ell_p$ 的估计值。对于一组点 $(x_i, y_i)$，其最佳拟合线的斜率 $m$ 使用最小二乘回归的公式计算：\n$$\nm = \\frac{M \\sum_{i=1}^M x_i y_i - (\\sum_{i=1}^M x_i)(\\sum_{i=1}^M y_i)}{M \\sum_{i=1}^M x_i^2 - (\\sum_{i=1}^M x_i)^2}\n$$\n其中 $M=4$ 是对应于四个步长的四个数据点的数量。\n\n算法流程如下：对于每个阶数 $p \\in \\{1, 2, 3, 4\\}$，我们遍历给定的步长 $h$。对于每个 $h$，我们计算直到 $t=1$ 的数值解以找到 $E(h)$，并计算残差集 $\\{r_{n+1}\\}$ 以找到 $R(h)$。在收集完所有步长的数据后，我们计算斜率 $g_p$ 和 $\\ell_p$。最终输出将包含这八个计算值的序列，并按规定四舍五入。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes the observed orders of convergence for global and local truncation\n    errors for Adams-Bashforth methods of orders p=1, 2, 3, 4.\n    \"\"\"\n    p_orders = [1, 2, 3, 4]\n    h_steps = np.array([1/8, 1/16, 1/32, 1/64], dtype=np.float64)\n\n    # Pre-computed Adams-Bashforth coefficients (beta_0, beta_1, ...)\n    ab_coeffs = {\n        1: np.array([1.0], dtype=np.float64),\n        2: np.array([3/2, -1/2], dtype=np.float64),\n        3: np.array([23/12, -16/12, 5/12], dtype=np.float64),\n        4: np.array([55/24, -59/24, 37/24, -9/24], dtype=np.float64)\n    }\n\n    # The IVP is y' = -y, so f(t, y) = -y.\n    # The exact solution is y(t) = exp(-t).\n    y_exact_func = lambda t: np.exp(-t)\n    f = lambda t, y: -y\n    \n    final_results = []\n\n    for p in p_orders:\n        log_h_vals = []\n        log_global_errors = []\n        log_local_errors = []\n\n        for h in h_steps:\n            N = int(1/h)\n            # Grid points: t_0, t_1, ..., t_N\n            t = np.linspace(0.0, 1.0, N + 1, dtype=np.float64)\n\n            # --- Global Error Calculation ---\n            y_numerical = np.zeros(N + 1, dtype=np.float64)\n            # Initialize first p values with the exact solution\n            y_numerical[:p] = y_exact_func(t[:p])\n\n            for n in range(p - 1, N):\n                # History of f(t,y) values: f_n, f_{n-1}, ..., f_{n-p+1}\n                # Since f(t,y)=-y, values are -y_numerical[n], -y_numerical[n-1],...\n                f_history = -y_numerical[n - p + 1 : n + 1]\n                # Invert for correct order in dot product with betas\n                f_history_reversed = f_history[::-1]\n                \n                y_numerical[n + 1] = y_numerical[n] + h * np.sum(ab_coeffs[p] * f_history_reversed)\n\n            global_error = np.abs(y_numerical[N] - y_exact_func(1.0))\n            \n            log_h_vals.append(np.log(h))\n            log_global_errors.append(np.log(global_error))\n\n            # --- Local Truncation Error (Residual) Calculation ---\n            y_exact_vals = y_exact_func(t)\n            residuals = []\n            for n in range(p - 1, N):\n                # History of f(t, y(t)) values based on exact solution\n                f_exact_history = f(None, y_exact_vals[n - p + 1 : n + 1])\n                f_exact_history_reversed = f_exact_history[::-1]\n                \n                # Definition of residual r_{n+1}\n                r_n_plus_1 = (y_exact_vals[n + 1] - y_exact_vals[n] - \n                              h * np.sum(ab_coeffs[p] * f_exact_history_reversed))\n                residuals.append(r_n_plus_1)\n            \n            # Max norm of the residual vector\n            local_error_norm = np.max(np.abs(np.array(residuals)))\n            log_local_errors.append(np.log(local_error_norm))\n        \n        # --- Order Calculation using Linear Regression ---\n        # np.polyfit(_x, _y, 1) returns [slope, intercept] of the best-fit line\n        # The slope corresponds to the order of convergence.\n        global_order = np.polyfit(log_h_vals, log_global_errors, 1)[0]\n        local_order = np.polyfit(log_h_vals, log_local_errors, 1)[0]\n        \n        final_results.extend([global_order, local_order])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{val:.3f}' for val in final_results)}]\")\n\nsolve()\n```", "id": "2410045"}, {"introduction": "在求解常微分方程时，精度并非唯一考量，方法的稳定性也至关重要，尤其是在处理包含极大和极小时间尺度的“刚性”问题时。这个练习将引导你分析和比较两种广泛使用的隐式方法——二阶Adams-Moulton（AM2）和二阶向后差分格式（BDF2）——在求解一个典型的刚性测试方程时的表现。通过这个实践，你将揭示A-稳定性和L-稳定性之间的关键差异，并理解为何在刚性问题中，一种看似可靠的方法可能会失效，而另一种则表现优异。[@problem_id:3153724]", "problem": "考虑初值问题 $y'(t)=\\lambda\\,y(t)$，其中 $y(0)=1$，$\\lambda\\in\\mathbb{R}$ 为一个数量级很大的负数，用以模拟突发的灾难性衰减。目标是分析和比较二阶 Adams–Moulton (AM2) 方法和二阶向后差分格式 (BDF2) 在此测试方程上的表现，重点关注每种方法捕捉刚性衰减的效果。\n\n本问题的基础知识：\n- 该初值问题及其精确解 $y(t)=e^{\\lambda t}$。\n- 线性多步法的定义，以及通过在线性测试方程 $y'=\\lambda y$ 上的放大来理解稳定性的概念。\n- 对于大的负数 $\\lambda$ 的刚性概念，以及捕捉衰减的重要性。\n\n任务：\n1. 从线性多步法的一般定义出发，将其应用于测试方程 $y'=\\lambda y$，推导二阶 Adams–Moulton (AM2) 方法的更新关系。根据此更新关系，推导单步放大因子作为刚性比 $z=h\\lambda$ 的函数，其中 $h$ 是固定时间步长。以此为基础，完全从基本原理出发，解释当 $z\\to -\\infty$ 且 $z\\in\\mathbb{R}$ 时 AM2 方法的行为。\n2. 从线性多步法的一般定义出发，推导应用于 $y'=\\lambda y$ 且步长为常数 $h$ 的 BDF2 递推关系。将其表示为关于 $y_{n+1}$、$y_n$ 和 $y_{n-1}$ 的齐次线性递推关系，并写出关于放大变量的相应特征多项式。以此为基础，完全从基本原理出发，解释当 $z\\to -\\infty$ 且 $z\\in\\mathbb{R}$ 时，主放大因子的幅值行为。\n3. 为求解 $y'=\\lambda y$，实现 AM2 和 BDF2 的固定步长求解器：\n   - 使用 $y(0)=1$。\n   - 对于 AM2，通过以固定步长 $h$ 迭代 AM2 更新关系，生成最终时间 $T$ 处的 $y_N$。\n   - 对于需要两个起始值的 BDF2，使用精确值 $y_0=1$ 和 $y_1=e^{\\lambda h}$ 来启动递推，然后以固定步长 $h$ 进行迭代，以获得 $T$ 处的 $y_N$。\n4. 对每个测试用例，计算每种方法的刚性衰减捕捉度量，其定义为在同一最终时间，数值解的幅值与精确解的幅值之比的以 10 为底的对数：\n   $$M_{\\text{AM2}}=\\log_{10}\\left(\\frac{|y_{\\text{AM2}}(T)|}{|e^{\\lambda T}|}\\right),\\quad M_{\\text{BDF2}}=\\log_{10}\\left(\\frac{|y_{\\text{BDF2}}(T)|}{|e^{\\lambda T}|}\\right)。$$\n   将较大的正值 $M$ 解释为较差的刚性衰减捕捉（数值解的衰减远小于精确解），而接近 $0$ 的值则表示良好的刚性衰减捕捉。\n\n实现约束：\n- 使用固定时间步长 $h$，使得步数 $N=T/h$ 为整数。\n- 在所有计算中，将所有量视为无量纲实数；不涉及物理单位。\n\n测试套件：\n使用以下参数集 $(\\lambda,h,T)$ 来探测试不同的区域。\n- 情况 A（中等刚性，理想路径）：$(\\lambda,h,T)=(-50,\\,0.1,\\,1.0)$，因此 $N=10$。\n- 情况 B（非常刚性）：$(\\lambda,h,T)=(-1000,\\,0.05,\\,0.5)$，因此 $N=10$。\n- 情况 C（轻度刚性，边界情况）：$(\\lambda,h,T)=(-2,\\,0.1,\\,1.0)$，因此 $N=10$。\n- 情况 D（极端刚性，时间域极短）：$(\\lambda,h,T)=(-4000,\\,0.05,\\,0.1)$，因此 $N=2$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表。每个元素按 A、B、C、D 的顺序对应一个测试用例，并且本身是一个包含 $[M_{\\text{AM2}},M_{\\text{BDF2}}]$ 的双元素列表，其中每个浮点数格式化为六位小数。例如：\n$$\\text{输出行： }[[M_{\\text{AM2,A}},M_{\\text{BDF2,A}}],[M_{\\text{AM2,B}},M_{\\text{BDF2,B}}],[M_{\\text{AM2,C}},M_{\\text{BDF2,C}}],[M_{\\text{AM2,D}},M_{\\text{BDF2,D}}]]。$$", "solution": "该问题要求对刚性测试方程 $y'(t) = \\lambda y(t)$（其中 $y(0)=1$，$\\lambda \\in \\mathbb{R}$ 是一个大的负数）分析和比较二阶 Adams–Moulton (AM2) 方法和二阶向后差分格式 (BDF2)。\n\n求解初值问题 $y'(t) = f(t, y(t))$ 的线性 $k$-步法由以下递推关系定义：\n$$ \\sum_{j=0}^k \\alpha_j y_{n+j} = h \\sum_{j=0}^k \\beta_j f_{n+j} $$\n其中 $y_n \\approx y(t_n)$，$f_n = f(t_n, y_n)$，$h$ 是固定步长，$\\alpha_j, \\beta_j$ 是方法的系数。按照惯例，$\\alpha_k=1$。对于刚性方程，方法的稳定性通过将其应用于测试方程 $y' = \\lambda y$（其中 $f_n = \\lambda y_n$）来进行分析。\n\n### 任务 1：二阶 Adams–Moulton (AM2) 方法分析\n\nAM2 方法，也称为梯形法则，是一种单步（$k=1$）隐式方法。其公式为：\n$$ y_{n+1} - y_n = \\frac{h}{2} (f_{n+1} + f_n) $$\n对于测试方程 $y'=\\lambda y$，该公式变为：\n$$ y_{n+1} - y_n = \\frac{h}{2} (\\lambda y_{n+1} + \\lambda y_n) $$\n为了推导更新关系，我们求解 $y_{n+1}$：\n$$ y_{n+1} - \\frac{h\\lambda}{2} y_{n+1} = y_n + \\frac{h\\lambda}{2} y_n $$\n$$ y_{n+1} \\left(1 - \\frac{h\\lambda}{2}\\right) = y_n \\left(1 + \\frac{h\\lambda}{2}\\right) $$\n令 $z = h\\lambda$ 为刚性比。更新关系为 $y_{n+1} = R_{\\text{AM2}}(z) y_n$，其中放大因子 $R_{\\text{AM2}}(z)$ 为：\n$$ R_{\\text{AM2}}(z) = \\frac{1 + z/2}{1 - z/2} $$\n为分析刚性衰减行为，我们考察当 $z \\to -\\infty$ 时（因为 $\\lambda$ 是大的负数且 $h0$）该放大因子的极限。\n$$ \\lim_{z \\to -\\infty} R_{\\text{AM2}}(z) = \\lim_{z \\to -\\infty} \\frac{1 + z/2}{1 - z/2} = \\lim_{z \\to -\\infty} \\frac{z(1/z + 1/2)}{z(1/z - 1/2)} = \\frac{0 + 1/2}{0 - 1/2} = -1 $$\n这个结果至关重要。对于高度刚性的问题（大的负 $z$），AM2 方法的每一步都将解乘以约 $-1$。这意味着数值解 $|y_n|$ 不会衰减到零；相反，它会以几乎恒定的幅值振荡（$y_{n+1} \\approx -y_n$）。而对于大的负 $\\lambda$，精确解 $y(t) = e^{\\lambda t}$ 会极快地衰减到零。因此，AM2 未能捕捉到刚性衰减的定性行为，使其不适用于此类问题。放大因子在无穷远处趋近于 $-1$ 而不是 $0$ 的这一性质，是 A-稳定 但非 L-稳定 方法的特征。\n\n### 任务 2：二阶向后差分格式 (BDF2) 分析\n\nBDF2 方法是一种两步（$k=2$）隐式方法。其标准形式为：\n$$ y_{n+1} - \\frac{4}{3} y_n + \\frac{1}{3} y_{n-1} = \\frac{2}{3} h f_{n+1} $$\n将其应用于测试方程 $y' = \\lambda y$，其中 $f_{n+1} = \\lambda y_{n+1}$，我们得到：\n$$ y_{n+1} - \\frac{4}{3} y_n + \\frac{1}{3} y_{n-1} = \\frac{2}{3} h \\lambda y_{n+1} $$\n令 $z=h\\lambda$。整理各项，得到所要求的齐次线性递推关系：\n$$ \\left(1 - \\frac{2}{3}z\\right) y_{n+1} - \\frac{4}{3} y_n + \\frac{1}{3} y_{n-1} = 0 $$\n为分析稳定性，我们寻找形如 $y_n = \\xi^n$ 的解。将此代入递推关系，得到放大因子 $\\xi$ 的特征多项式：\n$$ \\left(1 - \\frac{2}{3}z\\right) \\xi^2 - \\frac{4}{3} \\xi + \\frac{1}{3} = 0 $$\n我们关心的是当 $z \\to -\\infty$ 时该多项式根 $\\xi$ 的行为。递推关系的解是包含这些根的项的线性组合。为保证稳定性，所有根的幅值必须小于或等于 $1$。对于刚性衰减，当 $z \\to -\\infty$ 时，根的幅值应趋于 $0$。\n\n我们来分析这些根。当 $z \\to -\\infty$ 时，$\\xi^2$ 的系数 $(1 - \\frac{2}{3}z)$ 变得非常大。我们可以使用韦达定理来研究这些根。设根为 $\\xi_1$ 和 $\\xi_2$。\n$$ \\xi_1 + \\xi_2 = \\frac{4/3}{1 - 2z/3} $$\n$$ \\xi_1 \\xi_2 = \\frac{1/3}{1 - 2z/3} $$\n当 $z \\to -\\infty$ 时，根的和与积都趋近于 $0$。这意味着两个根本身都必须趋近于 $0$。更正式地，我们来解这个二次方程，并分析在 $z \\to -\\infty$ 极限下的根：\n$$ \\xi^2 - \\frac{4/3}{1-2z/3} \\xi + \\frac{1/3}{1-2z/3} = 0 $$\n根为 $\\xi = \\frac{a \\pm \\sqrt{a^2 - 4b}}{2}$，其中 $a = \\frac{4/3}{1-2z/3}$ 且 $b = \\frac{1/3}{1-2z/3}$。\n当 $z \\to -\\infty$ 时，$a \\sim \\frac{4/3}{-2z/3} = -2/z$ 且 $b \\sim \\frac{1/3}{-2z/3} = -1/(2z)$。与 $-4b \\sim 2/z$ 相比，$a^2 \\sim 4/z^2$ 这一项可以忽略不计。令 $z = -|z|$。\n$$ \\sqrt{a^2-4b} \\approx \\sqrt{-4b} = \\sqrt{2/|z|} $$\n对于大的 $|z|$，此近似是有效的。因此，根约等于：\n$$ \\xi \\approx \\frac{-2/z \\pm \\sqrt{-2/z}}{2} = -1/z \\pm \\frac{1}{2}\\sqrt{-2/z} $$\n当 $z \\to -\\infty$ 时，我们有 $|-1/z| \\to 0$ 和 $|\\frac{1}{2}\\sqrt{-2/z}| \\to 0$。因此，两个放大因子的幅值都趋于零：\n$$ \\lim_{z \\to -\\infty} |\\xi(z)| = 0 $$\n这个性质被称为 L-稳定性。这意味着对于非常刚性的问题，BDF2 方法会强力地衰减数值解，迫使其趋于零。这正确地模仿了精确解 $y(t) = e^{\\lambda t}$ 的行为，使得 BDF2 在捕捉刚性衰减方面非常有效。\n\n### 任务 3 和 4：实现与度量计算\n\n实现直接遵循推导出的递推关系。\n\n对于 AM2，从 $y_0 = 1$ 开始，我们迭代 $y_{n+1} = R_{\\text{AM2}}(z) y_n$ 共 $N=T/h$ 步以求得 $y_N$。\n\n对于 BDF2，我们给定起始值 $y_0 = 1$ 和 $y_1 = e^{\\lambda h}$。然后我们对 $n=1, \\dots, N-1$ 迭代递推关系 $y_{n+1} = \\frac{4/3 y_n - 1/3 y_{n-1}}{1-2z/3}$ 来求得 $y_N$。\n\n每种方法的刚性衰减捕捉度量 $M$ 计算如下：\n$$ M = \\log_{10}\\left(\\frac{|y_N|}{|e^{\\lambda T}|}\\right) $$\n其中 $y_N$ 是在最终时间 $T$ 的数值解。$M$ 值接近 $0$ 表示数值解的衰减速率与精确解相当，表明性能良好。大的正值 $M$ 表示数值解未能适当地衰减。根据我们的分析，我们预期在刚性情况下，$M_{\\text{AM2}}$ 将是大的正数，而 $M_{\\text{BDF2}}$ 应保持在接近 $0$ 的水平。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the given problem by comparing AM2 and BDF2 methods\n    on a stiff test equation.\n    \"\"\"\n\n    # (lambda, h, T)\n    test_cases = [\n        (-50.0, 0.1, 1.0),\n        (-1000.0, 0.05, 0.5),\n        (-2.0, 0.1, 1.0),\n        (-4000.0, 0.05, 0.1),\n    ]\n\n    results = []\n\n    for lam, h, T in test_cases:\n        N = int(round(T / h))\n        z = h * lam\n\n        # --- AM2 Solver ---\n        # y_n+1 = R(z) * y_n, where R(z) = (1+z/2)/(1-z/2)\n        # y_N = R(z)^N * y_0\n        y_0_am2 = 1.0\n        # The denominator can be zero if z=2, but problem constraints have z  0.\n        R_am2 = (1.0 + z / 2.0) / (1.0 - z / 2.0)\n        y_N_am2 = (R_am2 ** N) * y_0_am2\n\n        # --- BDF2 Solver ---\n        # (1 - 2z/3)y_n+1 - (4/3)y_n + (1/3)y_n-1 = 0\n        # y_n+1 = ( (4/3)y_n - (1/3)y_n-1 ) / (1 - 2z/3)\n        y_0_bdf2 = 1.0\n        y_1_bdf2 = np.exp(lam * h)\n        \n        y_prev = y_0_bdf2\n        y_curr = y_1_bdf2\n        \n        # This handles N>=2. If N=1, the loop range is empty, y_curr=y_1.\n        # Problem statement implies N>=2 for BDF2. Smallest N is 2.\n        for _ in range(N - 1):\n            y_next = ( (4.0/3.0) * y_curr - (1.0/3.0) * y_prev ) / (1.0 - (2.0/3.0) * z)\n            y_prev = y_curr\n            y_curr = y_next\n            \n        y_N_bdf2 = y_curr\n\n        # --- Metric Calculation (Task 4) ---\n        # M = log10( |y_numerical(T)| / |y_exact(T)| )\n        # Using np.exp for precision with large negative exponents.\n        exact_sol_at_T = np.exp(lam * T)\n\n        # The exact solution is always positive, so abs is for formality.\n        # The numerical solution can be negative.\n        M_am2 = np.log10(np.abs(y_N_am2) / np.abs(exact_sol_at_T))\n        M_bdf2 = np.log10(np.abs(y_N_bdf2) / np.abs(exact_sol_at_T))\n        \n        results.append([f\"{M_am2:.6f}\", f\"{M_bdf2:.6f}\"])\n\n    # --- Format final output ---\n    output_str = \"[\" + \",\".join([f\"[{m_am2},{m_bdf2}]\" for m_am2, m_bdf2 in results]) + \"]\"\n    print(output_str)\n\nsolve()\n\n```", "id": "3153724"}]}