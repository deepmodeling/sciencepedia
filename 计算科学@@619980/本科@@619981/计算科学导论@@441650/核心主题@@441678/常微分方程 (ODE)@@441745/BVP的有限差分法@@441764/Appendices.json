{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。本节的第一个练习将为我们打下坚实的基础。我们将为一维泊松方程实现标准的中心差分格式。通过使用光滑和非光滑的精确解来测试代码，我们将通过实验验证该方法的理论收敛阶，更重要的是，观察当解缺乏足够的光滑性时，收敛阶如何降低——这是应用数值方法时的一个关键教训。[@problem_id:3127793]", "problem": "考虑闭区间 $[0,1]$ 上标量函数 $u(x)$ 的一维边值问题 (BVP)，其边界条件为齐次狄利克雷边界条件：\n$$\n-u''(x) = f(x), \\quad x \\in (0,1), \\quad u(0) = 0, \\quad u(1) = 0.\n$$\n仅从光滑函数在某点周围的泰勒展开和二阶导数的定义出发，您必须：\n- 在一个包含 $N$ 个内部点、网格间距为 $h = \\frac{1}{N+1}$ 的均匀网格上，推导经典的二阶中心有限差分 (FD) 格式。使用三点格式来近似 $u''(x)$。在间断点附近不引入任何特殊处理；在每个内部网格点上应用相同的格式。\n- 实现用于近似 $-u''(x) = f(x)$ 且满足给定狄利克雷边界条件的线性系统。\n- 计算定义在内部网格节点 $\\{x_i = i h\\}_{i=1}^{N}$ 上的离散 $\\ell_{\\infty}$ 误差，其定义为\n$$\n\\|e\\|_{\\infty} = \\max_{1 \\le i \\le N} \\left|u_{\\text{num}}(x_i) - u_{\\text{exact}}(x_i)\\right|,\n$$\n其中 $u_{\\text{num}}$ 是数值解，$u_{\\text{exact}}$ 是在相同网格节点上求值的连续边值问题的精确解。\n- 对于由网格间距 $h_1 > h_2 > \\cdots$ 表征的一系列网格加密，通过以下公式计算两次连续加密之间的观测收敛阶：\n$$\np = \\frac{\\log\\left(\\|e(h_1)\\|_{\\infty} / \\|e(h_2)\\|_{\\infty}\\right)}{\\log\\left(h_1/h_2\\right)}.\n$$\n目标是证明当连续解仅为 $C^1$（一阶连续可导）但非 $C^2$ 时，标准的二阶中心有限差分方法的观测收敛阶会从大约 $2$ 降低到大约 $1$。\n\n使用三个测试用例，它们共享相同的算子，但右端项 $f(x)$ 不同，这样选择是为了控制精确解的正则性：\n\n- 用例 A（光滑的“理想情况”）：$f(x) = \\sin(2\\pi x)$。精确解为 $u(x) = \\dfrac{\\sin(2\\pi x)}{(2\\pi)^2}$，满足 $u(0) = 0$ 和 $u(1) = 0$。使用 $N \\in \\{32, 64, 128, 256\\}$。\n\n- 用例 B（阶梯右端项与网格节点对齐）：令 $s = \\tfrac{1}{2}$，$f_{\\text{L}} = 1$，$f_{\\text{R}} = 2$。定义\n$$\nf(x) = \n\\begin{cases}\nf_{\\text{L}},  0 \\le x  s, \\\\\nf_{\\text{R}},  s \\le x \\le 1.\n\\end{cases}\n$$\n此时，精确解 $u(x)$ 是分段二次的，$C^1$ 但非 $C^2$，通过施加 $u(0) = 0$、$u(1) = 0$ 以及 $u$ 和 $u'$ 在 $x=s$ 处的连续性来确定。具体来说，对于 $0 \\le x  s$，\n$$\nu(x) = -\\frac{f_{\\text{L}}}{2} x^2 + A x,\n$$\n对于 $s \\le x \\le 1$，\n$$\nu(x) = -\\frac{f_{\\text{R}}}{2} x^2 + C x + D,\n$$\n其中常数 $A, C, D$ 由界面条件和边界条件确定。使用 $N \\in \\{31, 63, 127, 255\\}$，使得 $s = \\tfrac{1}{2}$ 恰好落在网格节点 $x_i = i h$ 上。\n\n- 用例 C（阶梯右端项不在网格上）：令 $s = \\tfrac{3}{10}$，$f_{\\text{L}} = 1$，$f_{\\text{R}} = 2$，$f(x)$ 的定义如用例 B。精确解同样是分段二次的，$C^1$ 但非 $C^2$，其形式和常数确定方法与用例 B 相同，但界面位置不同，为 $s = \\tfrac{3}{10}$。使用 $N \\in \\{32, 64, 128, 256\\}$。\n\n对于用例 B 和 C，您的实现必须基于以下方程所蕴含的分段精确解：\n$$\n-u''(x) =\n\\begin{cases}\nf_{\\text{L}},  0 \\le x  s,\\\\\nf_{\\text{R}},  s \\le x \\le 1,\n\\end{cases}\n$$\n以及界面条件（$u$ 在 $x=s$ 处连续，$u'$ 在 $x=s$ 处连续）和边界条件 $u(0) = 0$, $u(1) = 0$。这些条件唯一地确定了分段二次精确解中的常数。\n\n您的程序必须：\n- 对每个测试用例，计算指定集合中每个 $N$ 对应的离散 $\\ell_{\\infty}$ 误差，然后仅使用该用例中两次最密网格加密的结果计算观测阶 $p$。\n- 生成单行输出，包含一个含三个浮点数的列表 $[p_{\\text{A}}, p_{\\text{B}}, p_{\\text{C}}]$，其中 $p_{\\text{A}}$ 对应于用例 A，$p_{\\text{B}}$ 对应于用例 B，$p_{\\text{C}}$ 对应于用例 C。每个数字表示为四舍五入到两位小数。\n\n本问题不涉及物理单位。三角函数中出现的所有角度，均视为以弧度为单位。\n\n最终输出格式：\n- 单行内容，包含三个结果，以逗号分隔的列表形式并用方括号括起来，例如 $[1.98,1.03,1.01]$。", "solution": "所呈现的问题是一个适定的一维边值问题（BVP），需要使用有限差分法求其数值解。任务是推导数值格式，针对三个具有不同解正则性的独特案例进行实现，并分析计算收敛阶，以展示解光滑性降低带来的影响。该问题在科学上是合理的、自成体系的，并且在数学上是严谨的。\n\n### 1. 中心有限差分格式的推导\n\n有限差分法的基础在于使用泰勒级数展开来近似导数。考虑一个足够光滑的标量函数 $u(x)$。其在点 $x_i$ 附近的泰勒展开式为：\n$$\nu(x_i + h) = u(x_i) + h u'(x_i) + \\frac{h^2}{2} u''(x_i) + \\frac{h^3}{6} u'''(x_i) + \\frac{h^4}{24} u^{(4)}(x_i) + O(h^5)\n$$\n$$\nu(x_i - h) = u(x_i) - h u'(x_i) + \\frac{h^2}{2} u''(x_i) - \\frac{h^3}{6} u'''(x_i) + \\frac{h^4}{24} u^{(4)}(x_i) + O(h^5)\n$$\n其中 $h$ 是一个小的步长。\n\n将这两个展开式相加，带有奇数次幂导数（$u'$, $u'''$ 等）的项会相互抵消：\n$$\nu(x_i + h) + u(x_i - h) = 2u(x_i) + h^2 u''(x_i) + \\frac{h^4}{12} u^{(4)}(x_i) + O(h^6)\n$$\n重新整理此方程以求解二阶导数 $u''(x_i)$，得到：\n$$\nh^2 u''(x_i) = u(x_i + h) - 2u(x_i) + u(x_i - h) - \\frac{h^4}{12} u^{(4)}(x_i) + O(h^6)\n$$\n两边同除以 $h^2$，我们得到 $u''(x_i)$ 的表达式：\n$$\nu''(x_i) = \\frac{u(x_i + h) - 2u(x_i) + u(x_i - h)}{h^2} - \\frac{h^2}{12} u^{(4)}(x_i) + O(h^4)\n$$\n表达式 $\\frac{u(x_i + h) - 2u(x_i) + u(x_i - h)}{h^2}$ 是二阶导数的经典三点中心有限差分近似。项 $-\\frac{h^2}{12} u^{(4)}(\\xi)$（对于某个 $\\xi \\in (x_i-h, x_i+h)$）是局部截断误差的主项。因此，只要解 $u(x)$ 至少是四阶连续可导的（$u \\in C^4$），该近似就是二阶精度的，记为 $O(h^2)$。\n\n### 2. 边值问题的离散化\n\n待解的边值问题是 $-u''(x) = f(x)$ 在 $x \\in (0,1)$ 上，且满足 $u(0)=0$ 和 $u(1)=0$。我们引入一个有 $N$ 个内部点的均匀网格。网格间距为 $h = \\frac{1}{N+1}$，网格点为 $x_i = i h$，其中 $i=0, 1, \\dots, N+1$。在这些点上的数值解记为 $u_i \\approx u(x_i)$。\n\n我们在每个内部网格点 $x_i$（$i=1, \\dots, N$）处，用其有限差分近似替换BVP中的连续二阶导数：\n$$\n- \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} = f(x_i)\n$$\n乘以 $h^2$ 并重新整理，得到每个内部节点的离散方程：\n$$\n-u_{i-1} + 2u_i - u_{i+1} = h^2 f_i, \\quad \\text{对于 } i = 1, 2, \\dots, N,\n$$\n其中 $f_i = f(x_i)$。\n\n这组 $N$ 个线性方程必须结合齐次狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$。在我们的离散记法中，这意味着 $u_0 = 0$ 和 $u_{N+1} = 0$。\n\n对于第一个内部点（$i=1$）：\n$$\n-u_0 + 2u_1 - u_2 = h^2 f_1 \\implies 2u_1 - u_2 = h^2 f_1\n$$\n对于最后一个内部点（$i=N$）：\n$$\n-u_{N-1} + 2u_N - u_{N+1} = h^2 f_N \\implies -u_{N-1} + 2u_N = h^2 f_N\n$$\n这些方程构成一个线性系统 $A\\mathbf{u}_{\\text{num}} = \\mathbf{b}$，其中 $\\mathbf{u}_{\\text{num}} = [u_1, u_2, \\dots, u_N]^T$ 是内部点处未知解值的向量。矩阵 $A$ 是一个 $N \\times N$ 的对称、三对角、正定矩阵：\n$$\nA = \\begin{pmatrix}\n2  -1  0  \\cdots  0 \\\\\n-1  2  -1  \\cdots  0 \\\\\n0  \\ddots  \\ddots  \\ddots  0 \\\\\n\\vdots  \\cdots  -1  2  -1 \\\\\n0  \\cdots  0  -1  2\n\\end{pmatrix}\n$$\n右端向量 $\\mathbf{b}$ 由下式给出：\n$$\n\\mathbf{b} = h^2 \\begin{pmatrix} f(x_1) \\\\ f(x_2) \\\\ \\vdots \\\\ f(x_N) \\end{pmatrix}\n$$\n求解这个线性系统即可得到数值解 $\\mathbf{u}_{\\text{num}}$。\n\n### 3. 收敛性分析与解的正则性\n\n该方法的全局误差 $\\|u_{\\text{num}} - u_{\\text{exact}}\\|_\\infty$ 预期为 $O(h^2)$，这意味着观测到的收敛阶 $p$ 应约等于 $2$。这一结论在解 $u(x)$ 足够光滑（具体来说，$u \\in C^4[0,1]$）时成立。\n\n本问题研究了当此光滑性条件被破坏时的情景。如果解 $u(x)$ 仅为 $C^1$，那么其二阶导数 $u''(x)$ 是连续但不可导的，其三阶导数 $u'''(x)$ 存在跳跃间断。当源项 $f(x)$ 是分段连续的（例如，阶梯函数）时，就会发生这种情况。在 $f(x)$ 不连续的点或其附近，用于证明 $O(h^2)$ 截断误差合理性的泰勒级数论证会失效。如果在不连续点处计算，局部截断误差会变为 $O(1)$ 或 $O(h^{-1})$；如果格式跨越了该点，则为 $O(h)$。这个较大的局部误差会污染全局解，通常导致整体收敛率降低到 $p \\approx 1$。\n\n三个测试用例旨在展示这一现象：\n- **用例 A**：$f(x)$ 是 $C^\\infty$，因此精确解 $u(x)$ 也是 $C^\\infty$。我们预期观测到 $p \\approx 2$。\n- **用例 B**：$f(x)$ 在 $x=1/2$ 处有阶跃间断。选择的网格使得该间断点始终与一个网格点对齐。有限差分格式被简单地应用于该点上。\n- **用例 C**：$f(x)$ 在 $x=3/10$ 处有阶跃间断。网格的设置使得该间断点位于网格点之间。\n\n对于用例 B 和 C，精确解是分段二次且为 $C^1$ 的。分段解中的常数通过施加边界条件 $u(0)=u(1)=0$ 以及在界面点 $s$ 处 $u$ 和 $u'$ 的连续性来找到。这得到了一般形式：\n对于 $x  s$：$u(x) = -\\frac{f_{\\text{L}}}{2}x^2 + C_1 x$\n对于 $x \\ge s$：$u(x) = -\\left(f_{\\text{L}}sx - \\frac{f_{\\text{L}}}{2}s^2 + \\frac{f_{\\text{R}}}{2}(x-s)^2\\right) + C_1 x$\n其中 $C_1 = f_{\\text{L}}s - \\frac{f_{\\text{L}}}{2}s^2 + \\frac{f_{\\text{R}}}{2}(1-s)^2$。\n\n数值实验将计算一系列网格加密的离散 $\\ell_\\infty$ 误差，然后使用两个最密网格的结果计算观测收敛阶 $p$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve_bvp(N, f_func):\n    \"\"\"\n    Solves the BVP -u'' = f(x) on [0,1] with u(0)=u(1)=0\n    using a central finite difference scheme with N interior points.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    x = np.linspace(h, 1.0 - h, N)\n    \n    # Construct the right-hand side vector b\n    b = h**2 * f_func(x)\n    \n    # Construct the tridiagonal matrix A in banded format for solve_banded.\n    # The matrix ab has 3 rows.\n    # ab[0, :] = super-diagonal (not used at index 0)\n    # ab[1, :] = main diagonal\n    # ab[2, :] = sub-diagonal (not used at last index)\n    ab = np.zeros((3, N))\n    ab[0, 1:] = -1.0\n    ab[1, :] = 2.0\n    ab[2, :-1] = -1.0\n    \n    # Solve the linear system Au = b\n    u_num = linalg.solve_banded((1, 1), ab, b)\n    \n    return x, u_num\n\ndef calculate_order(errors, h_values):\n    \"\"\"\n    Calculates the order of convergence p from the last two refinements.\n    \"\"\"\n    # Use data from the two finest grids\n    e1 = errors[-2]  # Error on coarser grid\n    e2 = errors[-1]  # Error on finer grid\n    h1 = h_values[-2]  # Coarser grid spacing\n    h2 = h_values[-1]  # Finer grid spacing\n\n    p = np.log(e1 / e2) / np.log(h1 / h2)\n    return p\n\ndef run_case(f_func, u_exact_func, N_values):\n    \"\"\"\n    Runs a test case for a given f, u_exact, and list of N values.\n    Returns the observed order of convergence.\n    \"\"\"\n    errors = []\n    h_values = []\n    \n    for N in N_values:\n        h = 1.0 / (N + 1)\n        x_grid, u_num = solve_bvp(N, f_func)\n        u_exact = u_exact_func(x_grid)\n        \n        # Calculate discrete l-infinity error\n        l_inf_error = np.max(np.abs(u_num - u_exact))\n        \n        errors.append(l_inf_error)\n        h_values.append(h)\n        \n    # Compute order of convergence from the two finest grids\n    order = calculate_order(errors, h_values)\n    return order\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run them, and print the final results.\n    \"\"\"\n    # --- Case A: Smooth solution ---\n    f_A = lambda x: np.sin(2 * np.pi * x)\n    u_exact_A = lambda x: np.sin(2 * np.pi * x) / (2 * np.pi)**2\n    N_A = [32, 64, 128, 256]\n\n    # --- Case B: C^1 solution, discontinuity on grid node ---\n    s_B, fL_B, fR_B = 0.5, 1.0, 2.0\n    f_B = lambda x: np.where(x  s_B, fL_B, fR_B)\n    C1_B = fL_B * s_B - fL_B / 2 * s_B**2 + fR_B / 2 * (1 - s_B)**2\n    u_exact_B = lambda x: np.where(\n        x  s_B,\n        -0.5 * fL_B * x**2 + C1_B * x,\n        -(fL_B * s_B * x - 0.5 * fL_B * s_B**2 + 0.5 * fR_B * (x - s_B)**2) + C1_B * x\n    )\n    N_B = [31, 63, 127, 255]\n\n    # --- Case C: C^1 solution, discontinuity off-grid ---\n    s_C, fL_C, fR_C = 0.3, 1.0, 2.0\n    f_C = lambda x: np.where(x  s_C, fL_C, fR_C)\n    C1_C = fL_C * s_C - fL_C / 2 * s_C**2 + fR_C / 2 * (1 - s_C)**2\n    u_exact_C = lambda x: np.where(\n        x  s_C,\n        -0.5 * fL_C * x**2 + C1_C * x,\n        -(fL_C * s_C * x - 0.5 * fL_C * s_C**2 + 0.5 * fR_C * (x - s_C)**2) + C1_C * x\n    )\n    N_C = [32, 64, 128, 256]\n\n    test_cases = [\n        (f_A, u_exact_A, N_A),\n        (f_B, u_exact_B, N_B),\n        (f_C, u_exact_C, N_C),\n    ]\n\n    results = []\n    for f_func, u_exact_func, N_values in test_cases:\n        p = run_case(f_func, u_exact_func, N_values)\n        results.append(p)\n    \n    # Format the final output string with results rounded to two decimal places.\n    formatted_results = [f\"{r:.2f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3127793"}, {"introduction": "现实世界的问题常常涉及超出简单狄利克雷（Dirichlet）类型的复杂边界条件。本练习将探讨如何实现混合（Robin）边界条件，并展示一个至关重要的原则：数值格式的全局精度受限于其在整个区域内的最低精度阶，而这通常发生在边界上。我们将通过比较一阶和二阶精度的边界离散格式，亲眼见证这一效应。[@problem_id:3127744]", "problem": "考虑线性二阶常微分方程边值问题（BVP）：寻找一个足够光滑的函数 $u(x)$，使得对于 $x \\in [0,1]$，有 $-u''(x) + u(x) = f(x)$，该问题受混合边界条件约束，包括左端点的 Robin 条件和右端点的 Dirichlet 条件。在 $x=0$ 处的 Robin 边界条件为 $u'(0) + \\beta\\,u(0) = g$，在 $x=1$ 处的 Dirichlet 边界条件为 $u(1) = u_{R}$。使用精确解 $u(x) = \\sin(\\pi x)$ 来一致地定义数据：设 $f(x) = (\\pi^2 + 1)\\sin(\\pi x)$，选择固定参数 $\\beta = 1$，则设 $g = u'(0) + \\beta\\,u(0) = \\pi$ 且 $u_{R} = u(1) = \\sin(\\pi) = 0$。采用有限差分法（FDM），内部使用由 Taylor 级数展开和二阶导数定义推导的二阶中心差分。对于 $x=0$ 处的 Robin 边界，实现两种闭合方案：一种是一阶单边导数近似，另一种是通过 Taylor 级数展开推导的二阶单边导数近似。同时考虑两端均为 Dirichlet 边界条件的情况。对于每种情况，构建离散线性系统，并使用直接法求解网格函数。通过计算在一系列 $N$ 值上加密网格间距 $h = 1/N$ 所得的经验收敛率，来量化全局精度阶。使用在包含两个端点的网格上定义的数值解与精确函数 $u(x)$ 之间误差的无穷范数。目标是展示即使内部格式为二阶，单个边界上的一阶截断误差如何降低全局精度。\n\n使用的基本原理：二阶导数的定义、围绕一点的 Taylor 级数展开以推导有限差分近似，以及截断误差的定义，即连续算子作用于 $u(x)$ 与离散算子作用于其网格表示之间的差异。经验收敛率应计算为对数坐标系下误差与网格间距关系的斜率。\n\n实现一个单一程序，为以下四个测试用例构建并求解离散系统：\n- 情况 1（理想情况，混合边界与一阶左侧闭合）：在 $x=0$ 处为 Robin 条件，使用一阶单边导数近似；在 $x=1$ 处为 Dirichlet 条件；加密级别 $N \\in \\{16,32,64,128\\}$。\n- 情况 2（混合边界与二阶左侧闭合）：在 $x=0$ 处为 Robin 条件，使用二阶单边导数近似；在 $x=1$ 处为 Dirichlet 条件；加密级别 $N \\in \\{16,32,64,128\\}$。\n- 情况 3（两端均为 Dirichlet 条件）：在 $x=0$ 和 $x=1$ 处均为 Dirichlet 条件；加密级别 $N \\in \\{16,32,64,128\\}$。\n- 情况 4（边缘情况，粗网格上的混合边界与一阶左侧闭合）：在 $x=0$ 处为 Robin 条件，使用一阶单边导数近似；在 $x=1$ 处为 Dirichlet 条件；加密级别 $N \\in \\{4,8,16,32\\}$。\n\n对于每种情况，通过对序列中连续加密获得的成对收敛率进行平均，计算经验全局精度阶，结果为一个实数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述情况的顺序列出结果，每个数字四舍五入到三位小数（例如 $[p_1,p_2,p_3,p_4]$）。此问题不涉及物理单位；报告纯数字。角度（如有）应以弧度为单位，但此问题不直接涉及角度。测试用例的最终答案必须是您的程序计算出的实数。", "solution": "在尝试求解之前，对问题进行验证。\n\n### 第 1 步：提取已知条件\n- **微分方程：** $-u''(x) + u(x) = f(x)$，对于 $x \\in [0,1]$。\n- **精确解：** $u(x) = \\sin(\\pi x)$。\n- **强迫函数（从精确解推导）：** $f(x) = (\\pi^2 + 1)\\sin(\\pi x)$。\n- **边界条件（混合）：**\n    - $x=0$ 处的 Robin 条件：$u'(0) + \\beta\\,u(0) = g$，其中 $\\beta=1$，$g=\\pi$。\n    - $x=1$ 处的 Dirichlet 条件：$u(1) = u_{R}$，其中 $u_R=0$。\n- **数值方法：** 在具有 $N$ 个子区间、步长 $h=1/N$ 的均匀网格上使用有限差分法（FDM）。\n    - 内部节点：二阶中心差分。\n    - $x=0$ 处的 Robin 边界：$u'(0)$ 的一阶和二阶单边近似。\n- **误差分析：** 通过在一系列网格加密上使用误差的无穷范数 $\\| \\mathbf{U} - \\mathbf{u} \\|_{\\infty}$，从经验收敛率中得到全局精度阶。\n- **测试用例：**\n    1.  混合边界条件（一阶 Robin 闭合），$N \\in \\{16,32,64,128\\}$。\n    2.  混合边界条件（二阶 Robin 闭合），$N \\in \\{16,32,64,128\\}$。\n    3.  两端均为 Dirichlet 边界条件，$N \\in \\{16,32,64,128\\}$。\n    4.  混合边界条件（一阶 Robin 闭合），$N \\in \\{4,8,16,32\\}$。\n- **输出：** 每种情况的平均经验收敛率，四舍五入到三位小数，以列表 `[p1, p2, p3, p4]` 形式表示。\n\n### 第 2 步：使用提取的已知条件进行验证\n1.  **科学或事实上的不合理性：** 该问题在数学上是合理的。BVP、使用给定精确解以确保一致性、FDM 以及制造解方法都是数值分析中标准且正确的概念。从 $u(x)=\\sin(\\pi x)$ 推导问题数据（$f(x)$, $g$, $u_R$）是正确的：\n    - $u'(x) = \\pi \\cos(\\pi x)$, $u''(x) = -\\pi^2 \\sin(\\pi x)$。\n    - $-u''(x) + u(x) = -(-\\pi^2 \\sin(\\pi x)) + \\sin(\\pi x) = (\\pi^2+1)\\sin(\\pi x) = f(x)$。\n    - $u'(0) + \\beta u(0) = \\pi \\cos(0) + (1)\\sin(0) = \\pi = g$。\n    - $u(1) = \\sin(\\pi) = 0 = u_R$。\n2.  **适定性：** 该问题是适定的。具有指定 Dirichlet 和 Robin 边界条件的亥姆霍兹型方程保证了唯一、稳定解的存在。\n3.  **客观性：** 问题以精确、客观的数学语言陈述，没有歧义或主观论断。\n4.  **完整性：** 问题是自洽的。数值实验所需的所有方程、参数和步骤都已指定。它正确地暗示了必须推导或已知标准的有限差分公式。\n5.  **核心概念演示：** 该问题设计精良，旨在演示微分方程数值方法的一个基本原理：全局精度阶受整个离散系统中最低阶局部截断误差的限制，而这种最低阶误差通常出现在边界处。\n\n### 第 3 步：结论与行动\n该问题是**有效的**，因为它构成了一个适定、科学合理且计算科学领域的标准练习。详细解答如下。\n\n### 解法\n\n任务是使用有限差分法求解一个线性二阶边值问题，并分析不同边界条件实现下的经验精度阶。\n\n**1. 区域和方程的离散化**\n将区域 $[0,1]$ 离散化为 $N$ 个宽度为 $h = 1/N$ 的均匀子区间。网格点为 $x_i = ih$，其中 $i=0, 1, \\dots, N$。设 $U_i$ 是精确解 $u(x_i)$ 的数值近似。\n\n控制性常微分方程为 $-u''(x) + u(x) = f(x)$。在内部网格点 $x_i$（对于 $i=1, \\dots, N-1$），我们使用由 Taylor 级数展开推导的二阶中心差分公式来近似二阶导数 $u''(x_i)$：\n$$ u''(x_i) = \\frac{u(x_{i-1}) - 2u(x_i) + u(x_{i+1})}{h^2} + O(h^2) $$\n将其代入常微分方程，并用 $U_i$ 替换 $u(x_i)$，得到内部节点的离散方程：\n$$ -\\frac{U_{i-1} - 2U_i + U_{i+1}}{h^2} + U_i = f(x_i) $$\n整理后得到一个涉及三个相邻网格值的线性代数方程：\n$$ -U_{i-1} + (2 + h^2)U_i - U_{i+1} = h^2 f(x_i), \\quad \\text{对于 } i=1, \\dots, N-1 $$\n这 $N-1$ 个方程构成了我们线性系统的核心。系统的第一个和最后一个方程由边界条件决定。\n\n**2. 边界条件的离散化**\n\n**情况 1、2 和 4：混合边界条件**\n在 $x=1$ 处的边界条件是 Dirichlet 条件 $u(1)=0$，其精确实现为 $U_N = 0$。这固定了一个网格点的值。\n在 $x=0$ 处的边界条件是 Robin 条件 $u'(0) + \\beta u(0) = g$，其中 $\\beta=1$，$g=\\pi$。我们必须近似导数 $u'(0)$。系统中的未知数是 $U_0, U_1, \\dots, U_{N-1}$，这导出一个 $N \\times N$ 的线性系统。\n\n*   **情况 1 和 4（一阶闭合）：** 我们使用一阶向前差分来近似 $u'(0)$。Taylor 展开 $u(h) = u(0) + h u'(0) + O(h^2)$ 给出：\n    $$ u'(0) = \\frac{u(h) - u(0)}{h} + O(h) $$\n    离散的 Robin 条件变为：\n    $$ \\frac{U_1 - U_0}{h} + \\beta U_0 = g $$\n    当 $\\beta=1$ 时，这简化为 $(h-1)U_0 + U_1 = hg$。这是线性系统的第一个方程（第 0 行）。此近似的局部截断误差为 $O(h)$，预计它将主导全局误差，从而导致一阶精度的数值方法。\n\n*   **情况 2（二阶闭合）：** 为保持内部格式的二阶精度，我们对 $u'(0)$ 使用二阶单边近似。这可以通过组合 $u(h)$ 和 $u(2h)$ 在 $x=0$ 附近的 Taylor 展开式，消去 $u''(0)$ 项并求解 $u'(0)$ 来推导：\n    $$ u'(0) = \\frac{-3u(0) + 4u(h) - u(2h)}{2h} + O(h^2) $$\n    离散的 Robin 条件是：\n    $$ \\frac{-3U_0 + 4U_1 - U_2}{2h} + \\beta U_0 = g $$\n    当 $\\beta=1$ 时，这简化为 $(2h-3)U_0 + 4U_1 - U_2 = 2hg$。这是系统的第一个方程。由于所有离散化（内部和边界）的局部截断误差至少为 $O(h^2)$，预计全局误差将为 $O(h^2)$。\n\n**情况 3：Dirichlet-Dirichlet 边界条件**\n这里，我们在两端都有 Dirichlet 条件：$u(0)=0$ 和 $u(1)=0$。它们被精确地实现为 $U_0 = 0$ 和 $U_N = 0$。未知数是内部点 $U_1, \\dots, U_{N-1}$。系统是 $(N-1) \\times (N-1)$ 的。对于第一个内部节点 $i=1$，方程是 $-U_0 + (2+h^2)U_1 - U_2 = h^2f(x_1)$。由于 $U_0=0$，它变为 $(2+h^2)U_1 - U_2 = h^2f(x_1)$。类似地，对于最后一个内部节点 $i=N-1$，已知 $U_N=0$ 给出 $-U_{N-2} + (2+h^2)U_{N-1} = h^2f(x_{N-1})$。得到的矩阵是一个对称、正定、三对角矩阵。该格式是一致的二阶格式，因此预计全局精度为 $O(h^2)$。\n\n**3. 系统组装与求解**\n对于每种情况，我们组装系统 $A\\mathbf{U} = \\mathbf{b}$ 的矩阵 $A$ 和右端向量 $\\mathbf{b}$。\n-   **对于情况 1、2、4：** $A$ 是一个 $N \\times N$ 矩阵，$\\mathbf{U}=[U_0, \\dots, U_{N-1}]^T$。最终解向量通过追加 $U_N=0$ 构成。\n-   **对于情况 3：** $A$ 是一个 $(N-1) \\times (N-1)$ 矩阵，$\\mathbf{U}=[U_1, \\dots, U_{N-1}]^T$。最终解向量通过前置 $U_0=0$ 和追加 $U_N=0$ 构成。\n\n该系统使用直接线性求解器求解。\n\n**4. 经验收敛率**\n全局误差在无穷范数下度量：$E_N = \\max_{0 \\le i \\le N} |U_i - u(x_i)|$。如果方法的精度阶为 $p$，那么对于某个常数 $C$ 和较小的 $h$，有 $E_N \\approx C h^p$。\n给定具有 $N_1$ 和 $N_2$ 个区间的网格上的误差 $E_{N_1}$ 和 $E_{N_2}$，其中 $N_2 = 2N_1$，收敛率 $p$ 可以估计为：\n$$ p \\approx \\log_2\\left(\\frac{E_{N_1}}{E_{N_2}}\\right) $$\n问题要求计算给定 $N$ 序列中连续加密得到的成对收敛率的平均值。\n\n分析将表明，在情况 1 和 4 中，尽管内部格式是二阶的，但边界处的一阶近似会将全局收敛率降低到 $p \\approx 1$。情况 2 和 3 完全使用二阶近似，将表现出 $p \\approx 2$ 的收敛率。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve_bvp(N, case_type):\n    \"\"\"\n    Constructs and solves the finite difference system for the BVP.\n\n    Args:\n        N (int): The number of intervals in the grid.\n        case_type (str): The type of case to solve. One of \n                         'mixed_1st', 'mixed_2nd', 'dirichlet'.\n\n    Returns:\n        float: The infinity norm of the error between the numerical\n               and exact solutions.\n    \"\"\"\n    h = 1.0 / N\n    x_full = np.linspace(0, 1, N + 1)\n\n    # Problem data from the exact solution u(x) = sin(pi*x)\n    pi = np.pi\n    beta = 1.0\n    g = pi\n    u_R = 0.0\n\n    def f(x):\n        return (pi**2 + 1) * np.sin(pi * x)\n\n    exact_solution = np.sin(pi * x_full)\n\n    if case_type == 'dirichlet':\n        num_unknowns = N - 1\n        if num_unknowns = 0:\n            return np.max(np.abs(np.array([0.0, 0.0]) - np.sin(pi * np.array([0.0, 1.0]))))\n\n        A = np.zeros((num_unknowns, num_unknowns))\n        b = np.zeros(num_unknowns)\n        \n        # Grid for interior points\n        x_interior = x_full[1:-1]\n        \n        # Fill matrix A\n        # Diagonal\n        np.fill_diagonal(A, 2 + h**2)\n        # Off-diagonals\n        np.fill_diagonal(A[1:], -1)\n        np.fill_diagonal(A[:, 1:], -1)\n\n        # Fill vector b\n        b = h**2 * f(x_interior)\n        \n        # Dirichlet conditions are handled by adjusting the RHS,\n        # but here u(0)=0 and u(1)=0, so no adjustments needed.\n        # U_0 = 0, U_N = 0.\n\n        # Solve system\n        U_interior = np.linalg.solve(A, b)\n        U_full = np.concatenate(([0.0], U_interior, [u_R]))\n\n    elif case_type in ('mixed_1st', 'mixed_2nd'):\n        num_unknowns = N\n        A = np.zeros((num_unknowns, num_unknowns))\n        b = np.zeros(num_unknowns)\n        \n        # Interior equations (rows 1 to N-1)\n        for i in range(1, num_unknowns):\n            x_i = x_full[i]\n            if i > 0:\n                A[i, i-1] = -1\n            A[i, i] = 2 + h**2\n            if i  num_unknowns - 1:\n                A[i, i+1] = -1\n            b[i] = h**2 * f(x_i)\n        \n        # Handle U_N = u_R = 0 in the last equation (row N-1)\n        # The term -U_N is 0, so no change to b[N-1] needed.\n\n        # Boundary equation at x=0 (row 0)\n        if case_type == 'mixed_1st':\n            A[0, 0] = h * beta - 1\n            A[0, 1] = 1\n            b[0] = h * g\n        elif case_type == 'mixed_2nd':\n            A[0, 0] = 2 * h * beta - 3\n            A[0, 1] = 4\n            A[0, 2] = -1\n            b[0] = 2 * h * g\n        \n        # Solve system\n        U_unknowns = np.linalg.solve(A, b)\n        U_full = np.concatenate((U_unknowns, [u_R]))\n    \n    else:\n        raise ValueError(\"Invalid case type\")\n        \n    error = np.max(np.abs(U_full - exact_solution))\n    return error\n\ndef compute_avg_rate(case_type, N_list):\n    \"\"\"\n    Computes the average empirical convergence rate for a given case.\n\n    Args:\n        case_type (str): The type of case.\n        N_list (list of int): A sequence of refinement levels N.\n\n    Returns:\n        float: The average convergence rate.\n    \"\"\"\n    errors = [solve_bvp(N, case_type) for N in N_list]\n    rates = []\n    for i in range(len(N_list) - 1):\n        # Assuming N_list[i+1] is a refinement of N_list[i], typically N*2\n        ratio_h = N_list[i] / N_list[i+1]\n        rate = math.log(errors[i] / errors[i+1]) / math.log(1/ratio_h)\n        rates.append(rate)\n    return np.mean(rates)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define test cases\n    case1_N = [16, 32, 64, 128]\n    case2_N = [16, 32, 64, 128]\n    case3_N = [16, 32, 64, 128]\n    case4_N = [4, 8, 16, 32]\n    \n    # Compute rates\n    p1 = compute_avg_rate('mixed_1st', case1_N)\n    p2 = compute_avg_rate('mixed_2nd', case2_N)\n    p3 = compute_avg_rate('dirichlet', case3_N)\n    p4 = compute_avg_rate('mixed_1st', case4_N)\n    \n    results = [p1, p2, p3, p4]\n    \n    # Format and print output\n    formatted_results = [f\"{r:.3f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3127744"}, {"introduction": "许多物理现象是由非线性微分方程描述的。最后的这个练习将我们的有限差分框架扩展到处理非线性边值问题。我们将实现牛顿法来求解由此产生的非线性代数方程组，并使用参数连续策略来追踪当非线性项变化时解的行为，展示一种探索复杂系统的强大技术。[@problem_id:3127756]", "problem": "考虑在区间 $[0,1]$ 上的非线性边值问题（BVP），其带有齐次狄利克雷边界条件：寻找一个函数 $u:[0,1]\\to\\mathbb{R}$ 满足 $$-u''(x)+\\lambda\\,u(x)^3=f(x),\\quad x\\in(0,1),\\qquad u(0)=0,\\quad u(1)=0,$$ 其中 $f(x)$ 是一个给定的源函数，$\\lambda\\in\\mathbb{R}$ 是一个延拓参数。目标是通过有限差分法（FDM）近似解 $u(x)$，并使用离散牛顿延拓法在 $\\lambda$ 变化时追踪解分支。\n\n从基本原理开始：\n- 使用由导数定义推导出的标准中心差分来近似二阶导数，$$u''(x_i)\\approx\\frac{u(x_{i-1})-2u(x_i)+u(x_{i+1})}{h^2},$$ 其中 $x_i$ 是网格点，$h$ 是均匀网格间距。\n- 通过在内部网格点上强制满足微分方程来构建离散非线性系统。\n- 使用牛顿法，该方法源于非线性方程 $F(y)=0$ 的求根原理，它在每次迭代中通过雅可比矩阵对系统进行线性化，并求解牛顿更新量。\n\n需实现的离散化细节：\n- 使用一个包含 $N$ 个内部点的均匀网格，网格间距为 $h=\\frac{1}{N+1}$，内部节点为 $x_i=i\\,h$，其中 $i=1,2,\\dots,N$。\n- 令 $u_i\\approx u(x_i)$，并按分量定义离散残差向量 $F(u;\\lambda)\\in\\mathbb{R}^N$ 为 $$F_i(u;\\lambda)=\\frac{2u_i-u_{i-1}-u_{i+1}}{h^2}+\\lambda\\,u_i^3-f(x_i),\\quad i=1,\\dots,N,$$ 按照约定，由边界条件可知 $u_0=0$ 和 $u_{N+1}=0$。\n- 对于牛顿法，使用雅可比矩阵 $$J(u;\\lambda)=L+\\operatorname{diag}\\big(3\\lambda\\,u_1^2,\\dots,3\\lambda\\,u_N^2\\big),$$ 其中 $L\\in\\mathbb{R}^{N\\times N}$ 是表示离散算子 $-\\frac{d^2}{dx^2}$ 在内部节点上的三对角矩阵，即，$L$ 的对角线元素为 $\\frac{2}{h^2}$，次对角线和超对角线元素为 $-\\frac{1}{h^2}$。\n\n需实现的延拓策略：\n- 在 $\\lambda=0$ 时，精确求解线性系统 $L\\,u=f$ 以获得初始解。\n- 对于预定序列中的后续 $\\lambda$ 值，使用先前收敛的解作为牛顿法的初始猜测，并迭代至收敛，采用合适的停止准则。\n\n源函数规格：\n- 使用力函数 $f(x)=\\sin(\\pi x)$，该函数光滑且与边界条件兼容。\n\n需实现的收敛性和数值细节：\n- 对牛顿法收敛，使用残差的欧几里得范数上的容差 $10^{-10}$。\n- 将牛顿迭代次数限制为 $50$ 次。\n- 在牛顿步长上采用简单的回溯线搜索以增强稳健性：如果一个完整的牛顿步未能充分减小残差范数，则几何级数般地减小步长，直到观察到足够的减小或达到最小步长阈值。\n\n确保覆盖率的测试套件：\n- 情况 1（理想路径）：$N=50$，$\\lambda$ 序列 $[0.0,\\,0.5,\\,1.0]$。\n- 情况 2（粗网格，更强非线性）：$N=10$，$\\lambda$ 序列 $[0.0,\\,2.0]$。\n- 情况 3（细网格，中等非线性）：$N=150$，$\\lambda$ 序列 $[0.0,\\,1.5]$。\n- 情况 4（负参数分支）：$N=50$，$\\lambda$ 序列 $[0.0,\\,-1.0]$。\n\n要求的最终输出：\n- 对每种情况，沿指定的 $\\lambda$ 序列执行离散牛顿延拓。在每个 $\\lambda$ 值处，当牛顿法收敛后，计算解的离散 $\\ell_\\infty$ 范数，即 $\\max_i |u_i|$。\n- 按照上面列出的顺序汇总所有情况的结果，并在每种情况下按照 $\\lambda$ 序列的顺序汇总。\n- 将每个报告的 $\\ell_\\infty$ 范数四舍五入到 $6$ 位小数。\n- 您的程序应产生单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果（例如，$[r_1,r_2,\\dots]$），其中每个 $r_k$ 是一个四舍五入到 $6$ 位小数的浮点数。不应打印任何额外文本。", "solution": "该问题要求使用有限差分法（FDM）对一个非线性边值问题（BVP）进行数值求解。由此产生的非线性代数方程组将使用牛顿法求解。为了处理问题的参数依赖性，采用了一种简单的延拓方法，即从 $\\lambda=0$ 处的已知解开始，追踪一系列参数值 $\\lambda$ 对应的解。\n\n该 BVP 由以下公式给出：\n$$\n-u''(x) + \\lambda u(x)^3 = f(x), \\quad x \\in (0, 1)\n$$\n其带有齐次狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$。源函数指定为 $f(x) = \\sin(\\pi x)$。\n\n**1. 有限差分离散化**\n\n我们首先对域 $[0,1]$ 进行离散化。我们引入一个包含 $N$ 个内部点的均匀网格，由节点 $x_i = i h$ 定义，其中 $i=0, 1, \\dots, N+1$，$h = \\frac{1}{N+1}$ 是网格间距。边界点是 $x_0=0$ 和 $x_{N+1}=1$。我们寻求在内部网格点 $x_i$ 处的近似解 $u_i \\approx u(x_i)$，其中 $i=1, \\dots, N$。未知量向量为 $u = [u_1, u_2, \\dots, u_N]^T \\in \\mathbb{R}^N$。\n\n二阶导数 $u''(x)$ 在每个内部节点 $x_i$ 处使用二阶中心差分公式进行近似：\n$$\nu''(x_i) \\approx \\frac{u(x_{i-1}) - 2u(x_i) + u(x_{i+1})}{h^2} \\approx \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2}\n$$\n将此近似代入微分方程，并在每个内部节点 $x_i$ 处进行计算，得到一个包含 $N$ 个代数方程的系统：\n$$\n-\\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} + \\lambda u_i^3 = f(x_i), \\quad i=1, \\dots, N\n$$\n通过设置 $u_0=0$ 和 $u_{N+1}=0$ 来并入边界条件 $u(0)=0$ 和 $u(1)=0$。该方程组可以重写为：\n$$\n\\frac{2u_i - u_{i-1} - u_{i+1}}{h^2} + \\lambda u_i^3 = f_i, \\quad i=1, \\dots, N\n$$\n其中 $f_i = f(x_i) = \\sin(\\pi x_i)$。必须求解该系统以获得未知向量 $u$。\n\n我们定义一个残差函数 $F: \\mathbb{R}^N \\to \\mathbb{R}^N$，我们寻求其根 $u$ 使得 $F(u; \\lambda) = 0$。残差的第 $i$ 个分量是：\n$$\nF_i(u; \\lambda) = \\frac{2u_i - u_{i-1} - u_{i+1}}{h^2} + \\lambda u_i^3 - f_i\n$$\n该系统可以表示为紧凑的矩阵-向量形式：\n$$\nF(u; \\lambda) = L u + \\lambda u^{\\circ 3} - f = 0\n$$\n此处，$u^{\\circ 3}$ 表示向量 $u$ 的逐元素立方，即 $(u^{\\circ 3})_i = u_i^3$。向量 $f \\in \\mathbb{R}^N$ 的分量为 $f_i = f(x_i)$。矩阵 $L \\in \\mathbb{R}^{N \\times N}$ 是带有齐次狄利克雷边界条件的负二阶导数算子 $-\\frac{d^2}{dx^2}$ 的离散表示。它是一个对称的三对角矩阵，其元素为：\n$$\nL_{ij} = \\begin{cases}\n2/h^2  \\text{若 } i=j \\\\\n-1/h^2  \\text{若 } |i-j|=1 \\\\\n0  \\text{其他情况}\n\\end{cases}\n$$\n\n**2. 牛顿法**\n\n为了求解非线性系统 $F(u;\\lambda)=0$，我们采用牛顿法。从一个初始猜测 $u^{(0)}$ 开始，我们生成一系列迭代 $u^{(k)}$，并希望它们能收敛到解。从 $u^{(k)}$ 到 $u^{(k+1)}$ 的更新由下式给出：\n$$\nu^{(k+1)} = u^{(k)} + \\Delta u^{(k)}\n$$\n其中牛顿步 $\\Delta u^{(k)}$ 是以下线性系统的解：\n$$\nJ(u^{(k)}; \\lambda) \\Delta u^{(k)} = -F(u^{(k)}; \\lambda)\n$$\n$J(u^{(k)}; \\lambda)$ 是 $F$ 相对于 $u$ 的雅可比矩阵，在 $u^{(k)}$ 处求值。雅可比矩阵的元素为 $J_{ij}(u; \\lambda) = \\frac{\\partial F_i}{\\partial u_j}$。\n$$\n\\frac{\\partial F_i}{\\partial u_j} = \\frac{\\partial}{\\partial u_j} \\left( \\frac{2u_i - u_{i-1} - u_{i+1}}{h^2} + \\lambda u_i^3 - f_i \\right) =\n\\begin{cases}\n2/h^2 + 3\\lambda u_i^2  \\text{若 } i=j \\\\\n-1/h^2  \\text{若 } |i-j|=1 \\\\\n0  \\text{其他情况}\n\\end{cases}\n$$\n因此，雅可比矩阵是常数矩阵 $L$ 和一个依赖于 $u$ 的对角矩阵之和：\n$$\nJ(u; \\lambda) = L + \\operatorname{diag}(3\\lambda u_1^2, 3\\lambda u_2^2, \\dots, 3\\lambda u_N^2)\n$$\n当残差向量的欧几里得范数低于指定容差 $\\|F(u^{(k)}; \\lambda)\\|_2  10^{-10}$ 时，或者达到最大迭代次数（$50$ 次）时，牛顿迭代终止。\n\n**3. 延拓法和线搜索**\n\n我们使用一种简单的参数延拓方法来为一系列 $\\lambda$ 值找到解。\n- **初始步骤 ($\\lambda=0$):** 对于 $\\lambda_0 = 0$，BVP 变为线性的：$-u''(x)=f(x)$。离散系统为 $L u = f$。该系统有唯一解，可以通过直接线性求解找到。\n- **延拓步骤：** 对于序列中的每个后续参数值 $\\lambda_k$，我们使用先前计算的解 $u(\\lambda_{k-1})$ 作为牛顿法的初始猜测 $u^{(0)}$ 来找到 $u(\\lambda_k)$。\n\n为了提高牛顿法的稳健性，特别是在初始猜测远离解时，我们引入了回溯线搜索。一个完整的牛顿步 $\\Delta u^{(k)}$ 可能不会减小残差范数。因此，更新被修改为 $u^{(k+1)} = u^{(k)} + \\alpha \\Delta u^{(k)}$，其中 $\\alpha \\in (0, 1]$ 是一个步长参数。我们从 $\\alpha=1$ 开始，如果条件 $\\|F(u^{(k)} + \\alpha \\Delta u^{(k)})\\|_2 \\ge \\|F(u^{(k)})\\|_2$ 成立，我们就将 $\\alpha$ 按一个固定因子减小（例如，$\\alpha \\leftarrow \\alpha/2$）并重新检查。重复此过程，直到残差范数实现充分减小或达到最小步长。\n\n**4. 算法摘要**\n\n对于由 $(N, \\{\\lambda_k\\})$ 指定的每个测试用例：\n1.  设置网格间距 $h = 1/(N+1)$。创建网格点 $x_i = i h$，其中 $i=1,\\dots,N$。\n2.  构造源向量 $f$，其分量为 $f_i = \\sin(\\pi x_i)$。\n3.  构造常数三对角矩阵 $L$。\n4.  处理 $\\lambda_0=0$：求解线性系统 $Lu = f$ 以获得初始解 $u_{sol}$。计算并存储其离散 $\\ell_\\infty$-范数，$\\max_i |(u_{sol})_i|$。\n5.  遍历剩余的 $\\lambda_k$ 值：\n    a. 使用上一步的 $u_{sol}$ 作为牛顿法的初始猜测 $u_{current}$。\n    b. 开始牛顿循环（对于 $j=0, 1, \\dots, 49$）：\n        i.   计算残差向量 $F_{current} = L u_{current} + \\lambda_k u_{current}^{\\circ 3} - f$。\n        ii.  如果 $\\|F_{current}\\|_2  10^{-10}$，则方法已收敛。中断循环。\n        iii. 计算雅可比矩阵 $J_{current} = L + \\operatorname{diag}(3\\lambda_k u_{current}^{\\circ 2})$。\n        iv.  求解线性系统 $J_{current} \\Delta u = -F_{current}$ 以获得牛顿步 $\\Delta u$。\n        v.   执行回溯线搜索以找到合适的步长 $\\alpha$。\n        vi.  更新解：$u_{current} \\leftarrow u_{current} + \\alpha \\Delta u$。\n    c. 收敛的解即为最终的 $u_{current}$。设置 $u_{sol} = u_{current}$。\n    d. 计算并存储 $u_{sol}$ 的 $\\ell_\\infty$-范数。\n6.  收集所有计算出的范数，将它们四舍五入到 $6$ 位小数，并格式化以用于最终输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the nonlinear BVP using FDM and Newton continuation for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        (50, [0.0, 0.5, 1.0]),\n        (10, [0.0, 2.0]),\n        (150, [0.0, 1.5]),\n        (50, [0.0, -1.0])\n    ]\n\n    all_results = []\n    \n    for N, lambdas in test_cases:\n        # 1. Grid and problem setup\n        h = 1.0 / (N + 1)\n        x = np.linspace(h, 1.0 - h, N)\n        f = np.sin(np.pi * x)\n\n        # 2. Assemble the discrete Laplacian matrix L\n        diag_val = 2.0 / h**2\n        off_diag_val = -1.0 / h**2\n        L = np.diag(np.full(N, diag_val)) + \\\n            np.diag(np.full(N - 1, off_diag_val), k=1) + \\\n            np.diag(np.full(N - 1, off_diag_val), k=-1)\n\n        # 3. Continuation loop\n        u_sol = None\n        for lambd in lambdas:\n            if lambd == 0.0:\n                # 4. For lambda=0, solve the linear system\n                u_sol = np.linalg.solve(L, f)\n            else:\n                # 5. For lambda != 0, use Newton's method\n                u_current = u_sol.copy()  # Use previous solution as initial guess\n                \n                max_iter = 50\n                tol = 1e-10\n\n                for _ in range(max_iter):\n                    # a. Compute residual F(u)\n                    residual = L @ u_current + lambd * u_current**3 - f\n                    res_norm = np.linalg.norm(residual)\n\n                    if res_norm  tol:\n                        break\n\n                    # b. Compute Jacobian J(u)\n                    jacobian_diag = 3.0 * lambd * u_current**2\n                    jacobian = L + np.diag(jacobian_diag)\n\n                    # c. Solve for Newton step\n                    try:\n                        newton_step = np.linalg.solve(jacobian, -residual)\n                    except np.linalg.LinAlgError:\n                        # Jacobian is singular, convergence fails\n                        # For the purposes of this problem, we can expect this not to happen.\n                        # Marking the result as NaN if it does.\n                        u_current.fill(np.nan)\n                        break\n\n                    # d. Backtracking line search\n                    alpha = 1.0\n                    for _ in range(10): # max 10 backtracking steps\n                        u_next = u_current + alpha * newton_step\n                        next_residual = L @ u_next + lambd * u_next**3 - f\n                        if np.linalg.norm(next_residual)  res_norm:\n                            break\n                        alpha *= 0.5\n                    \n                    u_current = u_current + alpha * newton_step\n                \n                u_sol = u_current\n\n            # 6. Compute and store the l_infinity norm of the solution\n            l_inf_norm = np.max(np.abs(u_sol))\n            all_results.append(round(l_inf_norm, 6))\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3127756"}]}