{"hands_on_practices": [{"introduction": "理论学习之后，最好的巩固方式莫过于亲手实践。本练习将指导你从零开始构建一个完整的自适应步长求解器[@problem_id:3259704]。通过实现一个嵌入式龙格-库塔方法（具体为 Bogacki-Shampine $2(3)$ 对），你将深入理解误差估计和步长控制的核心机制，从而揭开科学计算库中那些“黑箱”函数的神秘面纱。", "problem": "考虑一个由常微分方程 (ODE) $y'(t) = f(t,y)$ 和初始条件 $y(t_0) = y_0$ 定义的初值问题 (IVP)。单步法仅使用当前步的信息将解从 $(t,y)$ 推进到 $(t+h, y_{\\text{new}})$。在显式龙格-库塔 (RK) 方法中，增量由级导数的加权组合构成。一个嵌入式 RK 对提供由相同级计算出的两个不同阶的近似值，从而能够进行局部误差估计以实现自适应步长控制。\n\n您的任务是实现一个与 Bogacki–Shampine $2(3)$ 构造一致的嵌入式龙格-库塔对，并用它来驱动一个自适应步长选择算法。该算法必须：\n\n- 在每一步计算级导数，并产生一个高阶近似 $y^{[p]}$ 和一个低阶近似 $y^{[q]}$，其中 $p>q$。\n- 根据差值 $y^{[p]} - y^{[q]}$ 估计局部截断误差。\n- 当一个缩放误差范数小于或等于 $1$ 时接受一个步长，否则拒绝。\n- 利用误差和步长之间的渐近缩放关系来调整步长 $h$，通过应用一个安全因子并限制 $h$ 的增长和衰减来确保数值稳定性。\n- 通过在必要时减小最后一步以使 $t$ 恰好达到 $t_f$，来确保最终时间 $t_f$ 被精确满足。\n\n您必须为标量 ODE 实现自适应积分器，其每步的缩放误差范数如下：\n$$\nE = \\frac{|y^{[p]} - y^{[q]}|}{\\mathrm{atol} + \\mathrm{rtol}\\,\\max(|y|,|y^{[p]}|)},\n$$\n其中 $\\mathrm{atol}$ 是绝对容差，$\\mathrm{rtol}$ 是相对容差。如果 $E \\le 1$，则接受该步。步长控制器必须基于以下原理：阶数为 $h^{m}$ 的误差意味着 $h_{\\text{new}} \\propto h E^{-1/m}$，其中某个整数 $m$ 与误差估计器的阶数相匹配。控制器应包含一个乘法安全因子，并将增长和衰减限制在预设的界限内。\n\n当出现三角函数时，角度量必须解释为弧度。\n\n请实现该自适应求解器，并将其应用于以下 IVP 测试套件。对于每种情况，返回 $y(t_f)$ 的数值近似值，形式为浮点数。\n\n- 情况 $1$ (理想情况，指数稳定)：\n  - $y'(t) = -y$，$y(0) = 1$，$t_0 = 0$，$t_f = 5$。\n  - 容差：$\\mathrm{rtol} = 10^{-6}$，$\\mathrm{atol} = 10^{-9}$。\n  - 理由：测试在光滑问题上的一般性能和稳定性。\n\n- 情况 $2$ (带三角函数强迫项的含时增长，弧度)：\n  - $y'(t) = y\\sin(t)$，$y(0) = 1$，$t_0 = 0$，$t_f = 3$。\n  - 容差：$\\mathrm{rtol} = 10^{-7}$，$\\mathrm{atol} = 10^{-10}$。\n  - 理由：测试对含时系数的处理，并要求角度以弧度为单位。\n\n- 情况 $3$ (中度类刚性线性衰减)：\n  - $y'(t) = -15y$，$y(0) = 1$，$t_0 = 0$，$t_f = 1$。\n  - 容差：$\\mathrm{rtol} = 10^{-6}$，$\\mathrm{atol} = 10^{-9}$。\n  - 理由：测试在较快衰减下的步长自适应能力。\n\n- 情况 $4$ (奇异点附近的非线性增长)：\n  - $y'(t) = y^2$，$y(0) = 1$，$t_0 = 0$，$t_f = 0.9$。\n  - 容差：$\\mathrm{rtol} = 10^{-6}$，$\\mathrm{atol} = 10^{-9}$。\n  - 理由：测试在 $t = 1$ 处发生爆破附近的鲁棒性。\n\n- 情况 $5$ (零动态，边界情况)：\n  - $y'(t) = 0$，$y(0) = 5$，$t_0 = 0$，$t_f = 10$。\n  - 容差：$\\mathrm{rtol} = 10^{-8}$，$\\mathrm{atol} = 10^{-12}$。\n  - 理由：测试当估计误差恒为零时控制器的行为。\n\n所有情况共用的控制器参数：\n- 安全因子 $s = 0.9$，\n- 最小增长因子 $g_{\\min} = 0.2$，\n- 最大增长因子 $g_{\\max} = 5.0$，\n- 初始步长 $h_0 = 10^{-3}$，\n- 最小步长 $h_{\\min} = 10^{-12}$，\n- 最大步长 $h_{\\max} = (t_f - t_0)$。\n\n您的程序必须生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，按情况 $1$ 到 $5$ 的顺序排列结果，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是情况 $i$ 中 $y(t_f)$ 的浮点近似值。", "solution": "此任务的核心是基于初值问题 (IVP)、龙格-库塔 (RK) 方法和局部截断误差的定义，从头构建一个自适应单步积分器。\n\n一个 IVP 指定了 $y'(t) = f(t,y)$ 及 $y(t_0) = y_0$。单步法使用单个步长 $h_n$ 从 $(t_n,y_n)$ 计算 $y_{n+1}$，而无需参考更早的历史记录。在显式龙格-库塔 (RK) 方法中，新值是级导数的加权组合。通用的显式 RK 构造如下：\n$$\nk_1 = f(t_n, y_n),\\quad\nk_2 = f(t_n + c_2 h, y_n + h a_{21} k_1),\\quad \\dots,\\quad\nk_s = f(t_n + c_s h, y_n + h \\sum_{j=1}^{s-1} a_{sj} k_j),\n$$\n一个 $p$ 阶近似为\n$$\ny^{[p]}_{n+1} = y_n + h \\sum_{j=1}^s b_j k_j.\n$$\n一个嵌入式对提供两组权重 $(b_j)$ 和 $(\\hat b_j)$，它们用相同的级进行评估，以得到 $y^{[p]}$ 和 $y^{[q]}$，其中 $p>q$。差值\n$$\n\\Delta = y^{[p]}_{n+1} - y^{[q]}_{n+1}\n$$\n可以以微不足道的额外成本计算出来，并且其缩放行为与一个已知的 $h$ 的幂次有关，该幂次由构造决定。\n\n对于 Bogacki–Shampine $2(3)$ 对，该方法使用 $s=4$ 个级，节点为 $c_2 = \\tfrac{1}{2}$，$c_3 = \\tfrac{3}{4}$，$c_4 = 1$。内部系数为 $a_{21} = \\tfrac{1}{2}$，$a_{32} = \\tfrac{3}{4}$ (其中 $a_{31} = 0$)，以及 $a_{41} = \\tfrac{2}{9}$，$a_{42} = \\tfrac{1}{3}$，$a_{43} = \\tfrac{4}{9}$。高阶权重 (阶数 $p=3$) 为\n$$\nb_1 = \\tfrac{2}{9},\\quad b_2 = \\tfrac{1}{3},\\quad b_3 = \\tfrac{4}{9},\\quad b_4 = 0,\n$$\n低阶权重 (阶数 $q=2$) 为\n$$\n\\hat b_1 = \\tfrac{7}{24},\\quad \\hat b_2 = \\tfrac{1}{4},\\quad \\hat b_3 = \\tfrac{1}{3},\\quad \\hat b_4 = \\tfrac{1}{8}.\n$$\n级和近似值的计算如下\n$$\n\\begin{aligned}\nk_1 &= f(t, y),\\\\\nk_2 &= f\\Big(t + \\tfrac{1}{2}h,\\, y + h\\,\\tfrac{1}{2}\\,k_1\\Big),\\\\\nk_3 &= f\\Big(t + \\tfrac{3}{4}h,\\, y + h\\,\\tfrac{3}{4}\\,k_2\\Big),\\\\\ny^{[3]} &= y + h\\Big(\\tfrac{2}{9}k_1 + \\tfrac{1}{3}k_2 + \\tfrac{4}{9}k_3\\Big),\\\\\nk_4 &= f\\Big(t + h,\\, y^{[3]}\\Big),\\\\\ny^{[2]} &= y + h\\Big(\\tfrac{7}{24}k_1 + \\tfrac{1}{4}k_2 + \\tfrac{1}{3}k_3 + \\tfrac{1}{8}k_4\\Big).\n\\end{aligned}\n$$\n嵌入式差值 $\\Delta = y^{[3]} - y^{[2]}$ 提供了一个误差估计器，其主导行为为 $O(h^3)$；也就是说，对于光滑的 $f$，它的缩放行为像 $C h^3$。这种缩放特性证明了以下形式的控制器的合理性：\n$$\nh_{\\text{new}} = h \\cdot s \\cdot E^{-1/3},\n$$\n其中 $s$ 是一个安全因子，$E$ 是一个缩放误差范数。为确保数值鲁棒性，我们将乘法增长/衰减因子限制在 $g_{\\min} \\le s E^{-1/3} \\le g_{\\max}$ 范围内，并且我们还将 $h_{\\text{new}}$ 剪裁到 $[h_{\\min}, h_{\\max}]$ 区间。当 $E \\le 1$ 时，步长被接受，$y$ 前进到 $y^{[3]}$；否则，步长被拒绝，并用一个更小的 $h$ 重新计算。\n\n对于标量问题，缩放误差范数被选择来平衡绝对和相对容差：\n$$\nE = \\frac{|\\Delta|}{\\mathrm{atol} + \\mathrm{rtol}\\,\\max(|y|,|y^{[3]}|)}.\n$$\n这确保了接受标准 $E \\le 1$ 控制了相对于解的大小的误差，同时防止了当 $y$ 接近零时出现除以极小数的情况。\n\n从 $t_0$ 到 $t_f$ 的积分算法步骤：\n- 初始化 $t = t_0$，$y = y_0$，在 $[h_{\\min}, h_{\\max}]$ 内选择 $h$ (例如，使用给定的 $h_0$)，并设置控制器参数 $s, g_{\\min}, g_{\\max}$。\n- 当 $t < t_f$ 时：\n  - 如果 $t + h > t_f$，则设置 $h = t_f - t$ 以精确地在 $t_f$ 处结束。\n  - 计算 $k_1, k_2, k_3, y^{[3]}, k_4$ 和 $y^{[2]}$。\n  - 从 $y, y^{[3]}, y^{[2]}, \\mathrm{atol}$ 和 $\\mathrm{rtol}$ 计算 $E$。\n  - 如果 $E \\le 1$，接受该步：设置 $t \\gets t + h$，$y \\gets y^{[3]}$。\n  - 计算候选增长因子 $g = s \\cdot E^{-1/3}$；如果 $E=0$，则设置 $g = g_{\\max}$。\n  - 将 $g$ 限制在 $[g_{\\min}, g_{\\max}]$ 内，然后更新 $h \\gets \\mathrm{clip}(h \\cdot g, h_{\\min}, h_{\\max})$。\n  - 如果一步被拒绝 ($E > 1$)，如上更新 $h$ 并重新计算，但不推进 $t$ 或 $y$。\n- 返回 $y(t_f)$。\n\n我们现在简要分析每个测试用例及其预期行为：\n- 情况 1：$y'(t) = -y$，精确解为 $y(t) = e^{-t}$，因此 $y(5) = e^{-5}$。该方法应该采取适中的步长并快速收敛。\n- 情况 2：$y'(t) = y\\sin(t)$（弧度），精确解为 $y(t) = \\exp(1 - \\cos t)$，给出 $y(3) = \\exp(1 - \\cos 3)$。算法必须平滑地处理含时强迫项。\n- 情况 3：$y'(t) = -15y$，精确解为 $y(1) = e^{-15}$，由于快速衰减，初始时需要较小的步长，但随着 $y$ 的减小，控制器将增加 $h$。\n- 情况 4：$y'(t) = y^2$，对于 $t<1$，精确解为 $y(t) = \\frac{1}{1 - t}$，因此 $y(0.9) = 10$。当 $t$ 接近 $t=1$ 处的爆破点时，该方法必须自适应地减小 $h$。\n- 情况 5：$y'(t) = 0$ 产生常数解 $y(t) = 5$；误差估计器恒为零，控制器将把 $h$ 增大到 $h_{\\max}$。\n\n通过实现 Bogacki–Shampine $2(3)$ 的各级计算和从 $O(h^3)$ 误差估计推导出的控制器，该自适应求解器将为所有情况提供 $y(t_f)$，并以指定格式打印。", "answer": "```python\n# Python 3.12, numpy 1.23.5 allowed; no other libraries.\nimport numpy as np\n\ndef rk23_bogacki_shampine_step(f, t, y, h):\n    \"\"\"\n    Perform one Bogacki-Shampine 2(3) step for a scalar ODE y' = f(t,y).\n    Returns (y_high, y_low) where y_high is the 3rd-order solution, y_low is the 2nd-order embedded solution.\n    \"\"\"\n    k1 = f(t, y)\n    k2 = f(t + 0.5 * h, y + h * 0.5 * k1)\n    k3 = f(t + 0.75 * h, y + h * 0.75 * k2)\n    # 3rd-order solution\n    y3 = y + h * ( (2.0/9.0) * k1 + (1.0/3.0) * k2 + (4.0/9.0) * k3 )\n    # Stage 4 evaluated at t+h, y3\n    k4 = f(t + h, y3)\n    # 2nd-order embedded solution\n    y2 = y + h * ( (7.0/24.0) * k1 + (1.0/4.0) * k2 + (1.0/3.0) * k3 + (1.0/8.0) * k4 )\n    return y3, y2\n\ndef integrate_adaptive(f, t0, tf, y0, rtol, atol,\n                       h0=1e-3, hmin=1e-12, hmax=None,\n                       safety=0.9, growth_min=0.2, growth_max=5.0):\n    \"\"\"\n    Adaptive integrator using Bogacki-Shampine 2(3) pair for scalar ODEs.\n    \"\"\"\n    t = float(t0)\n    y = float(y0)\n    if hmax is None:\n        hmax = abs(tf - t0)\n    \n    direction = 1.0 if tf >= t0 else -1.0\n    h = direction * max(hmin, min(h0, hmax))\n    \n    max_iter = 1000000  # Safety break\n    for _ in range(max_iter):\n        if direction * t >= direction * tf:\n            break\n\n        # Ensure the last step hits tf exactly\n        if direction * (t + h) > direction * tf:\n            h = tf - t\n\n        # Retry loop for the current step\n        while True:\n            y3, y2 = rk23_bogacki_shampine_step(f, t, y, h)\n            \n            # Scaled error norm\n            scale = atol + rtol * max(abs(y), abs(y3))\n            err = abs(y3 - y2) / scale if scale > 0 else 0.0\n\n            if err <= 1.0:\n                # Step accepted, break retry loop\n                break\n            \n            # Step rejected, compute smaller h for retry\n            g = safety * err**(-1.0/3.0)\n            h_new = h * max(growth_min, min(g, growth_max))\n            \n            # If h is already at minimum and step is rejected, break retry to avoid infinite loop.\n            if abs(h) <= hmin:\n                break\n            \n            h = direction * max(hmin, abs(h_new))\n            if direction < 0:\n                h = -h\n\n        # Update state with the accepted step\n        t += h\n        y = y3\n\n        # Compute step size for the next step\n        if err == 0.0:\n            g = growth_max\n        else:\n            g = safety * err**(-1.0/3.0)\n        \n        g = max(growth_min, min(g, growth_max))\n        h_new = h * g\n        h = direction * min(hmax, max(hmin, abs(h_new)))\n        if direction < 0:\n            h = -h\n    else: # If loop finishes due to max_iter\n        # This part is for handling failure cases, though not required by the problem's output format.\n        # print(\"Warning: Maximum iterations reached.\")\n        pass\n\n    return y\n\ndef solve():\n    # Define the test cases\n    # Case 1: y' = -y, y(0) = 1, tf = 5\n    def f1(t, y): return -y\n\n    # Case 2: y' = y*sin(t), radians, y(0) = 1, tf = 3\n    def f2(t, y): return y * np.sin(t)\n\n    # Case 3: y' = -15 y, y(0) = 1, tf = 1\n    def f3(t, y): return -15.0 * y\n\n    # Case 4: y' = y^2, y(0) = 1, tf = 0.9\n    def f4(t, y): return y * y\n\n    # Case 5: y' = 0, y(0) = 5, tf = 10\n    def f5(t, y): return 0.0\n\n    test_cases = [\n        # (f, t0, tf, y0, rtol, atol)\n        (f1, 0.0, 5.0, 1.0, 1e-6, 1e-9),\n        (f2, 0.0, 3.0, 1.0, 1e-7, 1e-10),\n        (f3, 0.0, 1.0, 1.0, 1e-6, 1e-9),\n        (f4, 0.0, 0.9, 1.0, 1e-6, 1e-9),\n        (f5, 0.0, 10.0, 5.0, 1e-8, 1e-12),\n    ]\n\n    results = []\n    for f, t0, tf, y0, rtol, atol in test_cases:\n        ytf = integrate_adaptive(\n            f=f, t0=t0, tf=tf, y0=y0, rtol=rtol, atol=atol,\n            h0=1e-3, hmin=1e-12, hmax=abs(tf - t0),\n            safety=0.9, growth_min=0.2, growth_max=5.0\n        )\n        results.append(ytf)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3259704"}, {"introduction": "拥有一个求解器后，下一个关键问题是如何有效地使用它。本练习将理论与一个具体的物理问题（热力学冷却模型）联系起来，旨在弥合抽象的数值容差与实际物理精度要求之间的鸿沟[@problem_id:3095862]。你将学习如何把一个可接受的物理测量误差，系统地转换成求解器所需的绝对容差（$\\epsilon_{\\text{abs}}$）和相对容差（$\\epsilon_{\\text{rel}}$）参数，这是所有真实世界模拟任务中一项至关重要的技能。", "problem": "给定一个线性热模型，它由常微分方程 (ODE) $T'(t) = -k\\,(T(t) - T_{\\infty})$ 表示，其中 $T(t)$ 是时间 $t$（秒）时的温度（摄氏度），$k$ 是冷却系数（$\\mathrm{s}^{-1}$），$T_{\\infty}$ 是环境温度（摄氏度）。您必须设计并实现一种方法，根据物理单位和允许的温度测量误差来调整自适应步长控制器的容差 $\\epsilon_{\\text{abs}}$（绝对容差）和 $\\epsilon_{\\text{rel}}$（相对容差），然后根据已知的精确解来验证该方法。\n\n推导必须从一个适用于 ODE 自适应步长控制的有效基础开始：常微分方程的定义、线性冷却模型精确解的存在性、嵌入式 Runge–Kutta 方法中局部误差估计器的概念，以及将估计的局部误差与绝对容差和相对容差的组合进行比较的广泛使用的自适应误差接受准则。您不能假设任何捷径公式；相反，您必须通过量纲分析和误差接受准则的结构来论证从物理测量极限到求解器容差的映射关系是合理的。\n\n任务要求：\n- 使用摄氏度作为温度单位，秒作为时间单位。任何测量误差极限都必须遵守：绝对误差以摄氏度为单位，相对误差以无量纲的小数形式表示（例如，相对误差为 $\\delta$ 意味着误差必须被限制在 $\\delta \\cdot |T|$ 以内，并且您必须将 $\\delta$ 写成如 $0.002$ 的小数，而不是百分比）。\n- 建立一个从允许的测量误差到求解器容差 $\\epsilon_{\\text{abs}}$ 和 $\\epsilon_{\\text{rel}}$ 的有原则的映射关系，该映射关系应与单位一致，并考虑安全裕度，以确保求解器的数值误差在整个积分区间内严格低于允许的测量误差。\n- 使用带有嵌入式局部误差估计的方法，以及根据您的方法调整的容差 $\\epsilon_{\\text{abs}}$ 和 $\\epsilon_{\\text{rel}}$，对 ODE 从 $t = 0$到 $t = t_{\\text{end}}$ 进行自适应数值积分。\n- 使用精确解析解计算整个积分网格上的数值误差，并检查是否符合测量极限。精确解为 $T(t) = T_{\\infty} + (T(0) - T_{\\infty})\\, e^{-k t}$，这是通过求解线性一阶常微分方程得出的。\n- 对于每个测试用例，在积分区间上计算量 $q(t) = |T_{\\text{num}}(t) - T_{\\text{exact}}(t)| - \\left(A_{\\text{abs}} + R_{\\text{rel}}\\,|T_{\\text{exact}}(t)|\\right)$ 的最大值，其中 $A_{\\text{abs}}$ 是允许的绝对测量误差（摄氏度），$R_{\\text{rel}}$ 是以小数形式表示的允许的相对测量误差。报告一个布尔值，指示 $\\max_{t \\in [0, t_{\\text{end}}]} q(t) \\le 0$ 是否成立。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如，$[\\text{True},\\text{False},\\text{True}]$）。\n\n测试套件：\n- 用例 1（正常路径）：$k = 0.05\\,\\mathrm{s}^{-1}$，$T_{\\infty} = 20\\,^{\\circ}\\mathrm{C}$，$T(0) = 100\\,^{\\circ}\\mathrm{C}$，$t_{\\text{end}} = 100\\,\\mathrm{s}$，$A_{\\text{abs}} = 0.05\\,^{\\circ}\\mathrm{C}$，$R_{\\text{rel}} = 0.002$（小数），安全系数 $s = 0.1$（小数）。\n- 用例 2（快速冷却，温差小）：$k = 0.5\\,\\mathrm{s}^{-1}$，$T_{\\infty} = 20\\,^{\\circ}\\mathrm{C}$，$T(0) = 25\\,^{\\circ}\\mathrm{C}$，$t_{\\text{end}} = 10\\,\\mathrm{s}$，$A_{\\text{abs}} = 0.01\\,^{\\circ}\\mathrm{C}$，$R_{\\text{rel}} = 0.001$（小数），安全系数 $s = 0.1$（小数）。\n- 用例 3（接近平衡，缓慢冷却）：$k = 0.02\\,\\mathrm{s}^{-1}$，$T_{\\infty} = 30\\,^{\\circ}\\mathrm{C}$，$T(0) = 31\\,^{\\circ}\\mathrm{C}$，$t_{\\text{end}} = 60\\,\\mathrm{s}$，$A_{\\text{abs}} = 0.02\\,^{\\circ}\\mathrm{C}$，$R_{\\text{rel}} = 0.002$（小数），安全系数 $s = 0.1$（小数）。\n- 用例 4（大动态范围）：$k = 0.2\\,\\mathrm{s}^{-1}$，$T_{\\infty} = 25\\,^{\\circ}\\mathrm{C}$，$T(0) = 1000\\,^{\\circ}\\mathrm{C}$，$t_{\\text{end}} = 30\\,\\mathrm{s}$，$A_{\\text{abs}} = 0.1\\,^{\\circ}\\mathrm{C}$，$R_{\\text{rel}} = 0.001$（小数），安全系数 $s = 0.1$（小数）。\n\n输出规范：\n- 您的程序必须实现该方法，运行四个用例，并输出包含四个布尔值的单行列表 $[\\text{b}_{1},\\text{b}_{2},\\text{b}_{3},\\text{b}_{4}]$，其中，对于第 $i$ 个测试用例，当且仅当对于所有 $t \\in [0, t_{\\text{end}}]$，数值解满足 $|T_{\\text{num}}(t) - T_{\\text{exact}}(t)| \\le A_{\\text{abs}} + R_{\\text{rel}}\\,|T_{\\text{exact}}(t)|$ 时，$\\text{b}_{i}$ 为 $\\text{True}$，否则为 $\\text{False}$。$A_{\\text{abs}}$ 的单位是摄氏度，时间的单位是秒，$R_{\\text{rel}}$ 是一个无量纲的小数。", "solution": "该问题要求设计并验证一种方法，用以根据指定的物理测量误差限额 $A_{\\text{abs}}$ 和 $R_{\\text{rel}}$ 来设定自适应 ODE 求解器容差 $\\epsilon_{\\text{abs}}$ 和 $\\epsilon_{\\text{rel}}$。其背景是线性热模型，由以下常微分方程 (ODE) 描述：\n$$\nT'(t) = -k(T(t) - T_{\\infty})\n$$\n其中 $T(t)$ 是时间 $t$ 时的温度，$k$ 是冷却系数，$T_{\\infty}$ 是环境温度。初始条件给定为 $T(0)$。这是一个标准的初值问题 (IVP)。\n\n推导始于常微分方程数值方法中自适应步长控制的基本原理。一个自适应求解器，例如嵌入式 Runge-Kutta 方法，会在每个积分步中估计局部误差 $E_{\\text{local}}$。这个估计误差会与一个容差 $\\tau$ 进行比较，以决定是否接受该步并调整下一步的步长。标准的容差准则是绝对容差 $\\epsilon_{\\text{abs}}$ 和相对容差 $\\epsilon_{\\text{rel}}$ 的加权组合：\n$$\n\\text{准则: } E_{\\text{local}} \\le \\tau = \\epsilon_{\\text{abs}} + \\epsilon_{\\text{rel}} |y_{\\text{current}}|\n$$\n其中 $|y_{\\text{current}}|$ 是步长开始时数值解的大小。$\\epsilon_{\\text{abs}}$ 的单位必须与解变量的单位（本例中为摄氏度）相匹配，而 $\\epsilon_{\\text{rel}}$ 是一个无量纲的分数。\n\n问题的核心要求是确保*全局数值误差*，定义为 $E_{\\text{global}}(t) = |T_{\\text{num}}(t) - T_{\\text{exact}}(t)|$，在整个积分区间 $t \\in [0, t_{\\text{end}}]$ 内保持在一个具有物理意义的界限之下。该界限由允许的测量误差定义：\n$$\nE_{\\text{global}}(t) \\le A_{\\text{abs}} + R_{\\text{rel}}|T_{\\text{exact}}(t)|\n$$\n此处，$A_{\\text{abs}}$ 是允许的绝对误差（摄氏度），$R_{\\text{rel}}$ 是允许的相对误差，以无量纲小数形式给出。\n\n必须做出一个关键区分：自适应求解器控制的是每一步的*局部误差*，而不是在整个区间上累积的*全局误差*。全局误差是所有步骤的局部误差的累积结果。对于一个稳定的问题，全局误差与局部误差相关，但通常更大。为保证全局误差保持在其规定的界限内，局部误差必须被更严格地控制。\n\n这就引出了从物理限额 $(A_{\\text{abs}}, R_{\\text{rel}})$到求解器容差 $(\\epsilon_{\\text{abs}}, \\epsilon_{\\text{rel}})$ 的有原则的映射。我们引入一个安全系数 $s$，其中 $0 < s < 1$。该系数代表了我们将允许的全局误差预算中分配给每一步局部误差控制的部分。通过将求解器容差设置为物理限额的一小部分 $s$，我们创建了一个严格的局部误差目标，期望这些微小局部误差的累积不会超过更大的全局误差限额。\n\n求解器容差公式与所要求的全局误差界限之间的结构相似性，为分量式缩放提供了依据。这在量纲上也是一致的。绝对容差 $\\epsilon_{\\text{abs}}$ 与允许的绝对误差 $A_{\\text{abs}}$ 具有相同的单位，而相对容差 $\\epsilon_{\\text{rel}}$ 与允许的相对误差 $R_{\\text{rel}}$ 一样是无量纲的。因此，映射定义为：\n$$\n\\epsilon_{\\text{abs}} = s \\cdot A_{\\text{abs}}\n$$\n$$\n\\epsilon_{\\text{rel}} = s \\cdot R_{\\text{rel}}\n$$\n给定安全系数 $s = 0.1$，求解器将被指示维持一个比目标全局误差界限小十倍的局部误差。\n\n验证过程包括每个测试用例的以下步骤：\n1.  使用指定的 $A_{\\text{abs}}$、$R_{\\text{rel}}$ 和 $s$ 计算求解器容差 $\\epsilon_{\\text{abs}}$ 和 $\\epsilon_{\\text{rel}}$。\n2.  使用自适应求解器（如 `scipy.integrate.solve_ivp`），并配置这些容差，对 ODE $T'(t) = -k(T - T_{\\infty})$ 从 $t=0$ 到 $t=t_{\\text{end}}$ 使用初始条件 $T(0)$ 进行数值积分。\n3.  在求解器返回的每个时间点 $t_i$ 上，计算精确解：$T_{\\text{exact}}(t_i) = T_{\\infty} + (T(0) - T_{\\infty}) e^{-kt_i}$。\n4.  对于每个点，计算验证量：$q(t_i) = |T_{\\text{num}}(t_i) - T_{\\text{exact}}(t_i)| - (A_{\\text{abs}} + R_{\\text{rel}}|T_{\\text{exact}}(t_i)|)$。\n5.  确定在所有时间点上 $q(t)$ 的最大值。当且仅当 $\\max_i q(t_i) \\le 0$ 时，该用例的方法才算成功。正值表示数值误差在某个点上超过了允许的物理误差界限。\n6.  报告每个用例的布尔结果。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# Make sure to use the specified versions:\n# numpy>=1.23.5\n# scipy>=1.11.4\n# Python>=3.12\n\ndef solve():\n    \"\"\"\n    Implements and validates a methodology for tuning adaptive ODE solver \n    tolerances based on physical measurement error limits.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1: k, T_inf, T0, t_end, A_abs, R_rel, s\n        (0.05, 20.0, 100.0, 100.0, 0.05, 0.002, 0.1),\n        # Case 2\n        (0.5, 20.0, 25.0, 10.0, 0.01, 0.001, 0.1),\n        # Case 3\n        (0.02, 30.0, 31.0, 60.0, 0.02, 0.002, 0.1),\n        # Case 4\n        (0.2, 25.0, 1000.0, 30.0, 0.1, 0.001, 0.1),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        k, T_inf, T0, t_end, A_abs, R_rel, s = case\n\n        # Step 1: Develop principled mapping from physical error to solver tolerances\n        # The solver's local error tolerances are set to be a fraction `s` of the\n        # global physical error allowances to provide a safety margin.\n        eps_abs = s * A_abs\n        eps_rel = s * R_rel\n\n        # Step 2: Define the ODE right-hand side function\n        def thermal_model(t, T):\n            return -k * (T - T_inf)\n\n        # Step 3: Implement adaptive numerical integration\n        # Use solve_ivp, which employs an adaptive step-size method (default 'RK45').\n        # dense_output=True is not strictly needed here as we check against the\n        # output grid, which is sufficient for this problem's validation.\n        sol = solve_ivp(\n            fun=thermal_model,\n            t_span=(0, t_end),\n            y0=[T0],\n            method='RK45',\n            rtol=eps_rel,\n            atol=eps_abs\n        )\n        \n        t_num = sol.t\n        T_num = sol.y[0]\n\n        # Step 4: Use the exact solution to compute numerical error and check compliance\n        def exact_solution(t, T0, T_inf, k):\n            return T_inf + (T0 - T_inf) * np.exp(-k * t)\n\n        T_exact_vals = exact_solution(t_num, T0, T_inf, k)\n\n        # Step 5: Compute the maximum of the validation quantity q(t)\n        # q(t) = |T_num(t) - T_exact(t)| - (A_abs + R_rel * |T_exact(t)|)\n        # The condition q(t) <= 0 must hold for all t.\n        \n        # Absolute numerical error at each time step\n        numerical_error = np.abs(T_num - T_exact_vals)\n        \n        # Allowable physical error bound at each time step\n        allowed_error = A_abs + R_rel * np.abs(T_exact_vals)\n        \n        # The quantity q(t) measures by how much the numerical error exceeds the allowance\n        q_values = numerical_error - allowed_error\n        \n        # Check if the maximum of q(t) is non-positive.\n        is_compliant = np.max(q_values) <= 0.0\n        \n        results.append(is_compliant)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3095862"}, {"introduction": "在掌握了实现与应用之后，我们来挑战一个更高级的问题：如何为特定任务选择“正确”的数值方法？本练习引导你进行一场成本效益分析，定量比较一个低阶方法与一个高阶方法的效率[@problem_id:3095889]。通过模拟求解过程并计算函数评估的总次数，你将亲身体会到在精度、每步计算量和稳定性之间的根本权衡，尤其是在面对刚性问题时，这种权衡显得尤为重要。", "problem": "你必须编写一个完整且可运行的程序，从常微分方程（ODE）自适应步长控制的基本原理出发，构建一个简单的、定量的成本模型，以便在固定的绝对局部误差容限下，从两种显式嵌入式龙格-库塔（RK）方法中进行选择。该模型必须通过显式模拟一个自适应控制器，并计算在一个固定的时间区间内积分一个标量线性常微分方程所需的右端函数求值总次数，从而平衡每一步的局部工作量与总步数。这两种方法必须在一个刚性线性测试方程和一个非刚性线性测试方程上进行评估。\n\n基本基础。仅使用以下基础：常微分方程（ODE）$y'(t)=f(t,y(t))$ 的定义，一个 $p$ 阶方法的局部截断误差表现为 $O(h^{p+1})$ 的概念，以及显式 RK 方法在线性测试方程 $y'=-\\lambda y$ 上的绝对稳定性概念。对于自适应控制器，你必须从局部误差的渐近缩放推导出步长更新规则。对于刚性问题，你必须引入一个绝对稳定性约束，强制 $h \\le r/\\lambda$，其中 $r$ 是给定方法在负实轴上稳定区间的近似长度。\n\n目标 ODE。考虑在有限时间域 $t \\in [0,T]$ 上的标量线性 ODE $y'=-\\lambda y$，初值为 $y(0)=1$：\n- 非刚性：$\\lambda=1$。\n- 刚性：$\\lambda=1000$。\n\n待比较的嵌入式方法。实现两种显式嵌入式 RK 对，其绝对局部误差控制基于该对中高阶解和低阶解之间的差异。\n- 方法 A（低阶）：一个 $\\{2,1\\}$ 阶的嵌入对，基于二阶 Heun 方法（显式梯形法），并以前向一阶欧拉法作为嵌入式估计器。每次尝试步进计算 $2$ 次右端函数求值。对于线性测试方程，在负实轴上的近似稳定半径取 $r_A=2.0$。\n- 方法 B（高阶）：Cash–Karp $\\{5,4\\}$ 阶嵌入对，具有 $6$ 个阶段。每次尝试步进计算 $6$ 次右端函数求值。对于线性测试方程，在负实轴上的近似稳定半径取 $r_B=2.8$。\n\n自适应控制器规范。对于每次大小为 $h$ 的尝试步进，计算绝对局部误差估计 $e=\\lvert y_{\\text{high}}-y_{\\text{low}}\\rvert$。如果 $e \\le \\text{tol}$，则接受该步，否则拒绝。每次尝试后，通过以下公式提议新的步长：\n$$\nh_{\\text{new}} = h \\cdot \\mathrm{clip}\\Big(s \\cdot \\big(\\tfrac{\\text{tol}}{\\max(e,\\varepsilon)}\\big)^{1/p},\\, f_{\\min},\\, f_{\\max}\\Big),\n$$\n其中 $p$ 是嵌入对中较高阶成员的阶数（方法 A 为 $p=2$，方法 B 为 $p=5$），$s$ 是一个安全因子，$\\varepsilon$ 是一个非常小的正数以避免除以零，$\\mathrm{clip}(x,f_{\\min},f_{\\max})=\\min(\\max(x,f_{\\min}),f_{\\max})$。你必须对每次尝试的步进强制执行绝对稳定性上限 $h \\le 0.95\\, r/\\lambda$，并且最后一步不能超过 $T$。使用固定的控制器常数 $s=0.9$、$f_{\\min}=0.2$、$f_{\\max}=5.0$ 和 $\\varepsilon=10^{-30}$。以 $t=0$、$y=1$ 和一个同时满足稳定性上限和区间长度的正初始步长进行初始化；一个合理的选择是对于相应的方法取 $h_0=\\min\\big(T,\\,0.1\\,\\text{tol}^{1/p},\\,0.8\\,r/\\lambda\\big)$。\n\n成本模型和决策规则。对于每次运行，成本是右端函数求值的总次数，即尝试的步数（无论接受或拒绝）乘以每步的求值次数（方法 A 为 $2$，方法 B 为 $6$）。对于每个测试用例，选择总成本严格较小的方法。如果成本完全相等，则选择方法 A。\n\n角度单位和物理单位。不涉及物理单位或角度单位。所有量均为无量纲实数。\n\n测试套件。你的程序必须评估以下四个参数集：\n- 情况 1：$\\lambda=1$, $T=5$, $\\text{tol}=10^{-6}$ (非刚性，紧容限)。\n- 情况 2：$\\lambda=1$, $T=5$, $\\text{tol}=10^{-1}$ (非刚性，松容限)。\n- 情况 3：$\\lambda=1000$, $T=1$, $\\text{tol}=10^{-6}$ (刚性，紧容限)。\n- 情况 4：$\\lambda=1000$, $T=1$, $\\text{tol}=10^{-2}$ (刚性，中等容限)。\n\n要求的最终输出格式。你的程序应生成单行输出，其中包含四个情况的决策，按顺序排列，形式为一个逗号分隔的列表，并用方括号括起来，其中每个条目是一个整数方法标识符：$0$ 代表方法 A（低阶），$1$ 代表方法 B（高阶）。例如，一个有效的输出形如 $[1,0,0,0]$。", "solution": "问题陈述已经过严格评估，并被确定为有效。它在科学上基于常微分方程（ODE）数值分析的原理，问题设定良好，具有清晰确定的算法，并且自洽，提供了所有必要的参数和定义。因此，我们可以着手解决。\n\n任务是构建一个成本模型，以决定在积分一个标量线性 ODE 时，应选用两种显式嵌入式龙格-库塔（RK）方法中的哪一种。决策依据是自适应步长控制器在给定区间内以指定容限积分 ODE 所需的函数求值总次数。该成本模型必须在 ODE 的一个非刚性实例和一个刚性实例上进行模拟。\n\n### 1. 理论基础\n\n**ODE 和测试方程：**\n问题考虑的是标量线性测试方程，这是分析数值 ODE 求解器稳定性和准确性的基本模型：\n$$\ny'(t) = -\\lambda y(t), \\quad y(0) = 1, \\quad t \\in [0, T]\n$$\n其精确解为 $y(t) = e^{-\\lambda t}$。参数 $\\lambda > 0$ 决定了方程的刚性；大的 $\\lambda$ 对应于解快速衰减的刚性问题。\n\n**嵌入式龙格-库塔方法：**\n一个嵌入式 RK 对在每一步提供两个解，一个为较高阶 $p$（$y_{\\text{high}}$），一个为较低阶 $q$（$y_{\\text{low}}$）。这两个解之间的差异提供了对低阶方法局部截断误差（LTE）的估计：\n$$\ne = |y_{\\text{high}} - y_{\\text{low}}|\n$$\n该误差估计用于控制步长 $h$。待考虑的两种方法是：\n- **方法 A：** 一个 $\\{2,1\\}$ 阶对，使用二阶 Heun 方法（$p=2$）和一阶前向欧拉法（$q=1$）。每步需要对右端函数 $f(t,y)$ 进行 $2$ 次求值。其在负实轴上的稳定半径给定为 $r_A=2.0$。\n- **方法 B：** Cash-Karp $\\{5,4\\}$ 阶对（$p=5$, $q=4$）。每步需要 $6$ 次函数求值。其稳定半径给定为 $r_B=2.8$。\n\n**从第一性原理进行误差估计：**\n对于一个 $q$ 阶 RK 方法，应用于 $y'=-\\lambda y$，从精确解上的点 $y_n$ 出发，一步之后的 LTE 约等于泰勒级数差中的第一个非零项。来自嵌入对的误差估计 $e$ 被设计用来逼近这个 LTE。\n$$\ne \\approx \\left| \\frac{d^{q+1}y}{dt^{q+1}} \\frac{h^{q+1}}{(q+1)!} \\right|\n$$\n对于 $y(t)=e^{-\\lambda t}$，其 $(q+1)$ 阶导数为 $y^{(q+1)}(t) = (-\\lambda)^{q+1} e^{-\\lambda t} = (-\\lambda)^{q+1} y(t)$。因此，误差估计可以表示为：\n$$\ne \\approx \\frac{(h\\lambda)^{q+1}}{(q+1)!} |y(t)|\n$$\n对于方法 A，其中 $q=1$，误差估计为 $e \\approx \\frac{1}{2}(h\\lambda)^2 |y|$。对于方法 B，其中 $q=4$，误差估计为 $e \\approx \\frac{1}{120}(h\\lambda)^5 |y|$。\n\n**状态传播：**\n当一个步长被接受时，数值解使用高阶近似进行推进。对于任何应用于 $y'=-\\lambda y$ 的显式 RK 方法，更新形式为 $y_{n+1} = R(-h\\lambda) y_n$，其中 $R(z)$ 是方法的稳定函数。对于一个 $p$ 阶方法，$R(z)$ 是一个多项式，它与 $e^z$ 的泰勒级数匹配到 $z^p$ 项：\n$$\nR_p(z) = \\sum_{k=0}^{p} \\frac{z^k}{k!}\n$$\n- 对于方法 A（$p=2$）：$y_{n+1} = y_n \\left(1 - h\\lambda + \\frac{1}{2}(h\\lambda)^2\\right)$。\n- 对于方法 B（$p=5$）：$y_{n+1} = y_n \\sum_{k=0}^{5} \\frac{(-h\\lambda)^k}{k!}$。\n\n### 2. 自适应控制算法\n\n自适应积分器的模拟从 $t=0$ 到 $T$ 迭代进行。\n\n**初始化：**\n- 模拟从 $t=0$ 和 $y=1$ 开始。\n- 初始步长 $h_0$ 被保守地选择，以同时满足积分区间 $T$、容限 $\\text{tol}$ 和方法的稳定性限制：\n$$\nh_0 = \\min\\left(T, 0.1 \\cdot \\text{tol}^{1/p}, 0.8 \\cdot \\frac{r}{\\lambda}\\right)\n$$\n其中 $p$ 是高阶方法的阶数，$r$ 是其稳定半径。\n\n**主循环：**\n在每次迭代中，对于一个提议的步长 $h$，执行以下步骤：\n1.  **步长约束：** 实际尝试的步长 $h_{\\text{current}}$ 受限于稳定性要求和剩余的区间长度：\n    $$\n    h_{\\text{current}} = \\min\\left(h, 0.95 \\frac{r}{\\lambda}, T-t\\right)\n    $$\n2.  **尝试步进并估计误差：** 函数求值总数增加。使用上面推导的公式计算局部误差估计 $e$。\n3.  **接受/拒绝：**\n    - 如果 $e \\le \\text{tol}$，步长被接受。时间和解 $t$ 和 $y$ 使用 $h_{\\text{current}}$ 和高阶更新规则进行推进。\n    - 如果 $e > \\text{tol}$，步长被拒绝。状态 $(t, y)$ 保持不变。\n4.  **提议下一步长：** 使用指定的 PI 控制器公式计算下一次尝试的新步长：\n    $$\n    h_{\\text{new}} = h_{\\text{current}} \\cdot \\mathrm{clip}\\left(s \\cdot \\left(\\frac{\\text{tol}}{\\max(e, \\varepsilon)}\\right)^{1/p}, f_{\\min}, f_{\\max}\\right)\n    $$\n    给定的参数为安全因子 $s=0.9$，裁剪因子 $f_{\\min}=0.2$ 和 $f_{\\max}=5.0$，以及一个小的正则化数 $\\varepsilon=10^{-30}$。阶数 $p$ 是该对中高阶方法的阶数。\n\n### 3. 成本模型与决策\n\n对于给定的方法和测试用例，总成本是整个模拟过程中累积的函数求值总数。决策规则是选择成本严格较小的方法。如果成本相同，则选择方法 A。对问题陈述中指定的所有四个测试用例重复此过程。", "answer": "```python\nimport math\nimport numpy as np\n\ndef run_simulation(lambda_val, T, tol, p, q, evals_per_step, r):\n    \"\"\"\n    Simulates an adaptive step-size ODE solver to calculate the total cost.\n\n    Args:\n        lambda_val (float): The lambda parameter of the ODE y' = -lambda*y.\n        T (float): The final integration time.\n        tol (float): The absolute local error tolerance.\n        p (int): The order of the higher-order method in the embedded pair.\n        q (int): The order of the lower-order method in the embedded pair.\n        evals_per_step (int): The number of RHS evaluations per step.\n        r (float): The stability radius of the higher-order method.\n\n    Returns:\n        int: The total number of RHS evaluations (cost).\n    \"\"\"\n    # Controller constants\n    s = 0.9\n    f_min = 0.2\n    f_max = 5.0\n    epsilon = 1.0e-30\n\n    # Initial conditions\n    t = 0.0\n    y = 1.0\n    total_evals = 0\n\n    # Stability cap\n    h_stab_max = (0.95 * r / lambda_val) if lambda_val > 0 else float('inf')\n\n    # Initial step size h\n    h0_acc = 0.1 * (tol**(1.0/p))\n    h0_stab = (0.8 * r / lambda_val) if lambda_val > 0 else float('inf')\n    h = min(T, h0_acc, h0_stab)\n    \n    # Pre-calculate factorials for the stability function\n    factorials = [math.factorial(i) for i in range(p + 1)]\n    \n    q_factorial = math.factorial(q + 1)\n\n    while t < T:\n        # Guard against floating-point issues near the end of the interval\n        if T - t < 1e-14 * T:\n            break\n\n        # Apply stability and interval-end constraints to the step size\n        h_current = min(h, h_stab_max, T - t)\n        \n        # An attempt costs function evaluations regardless of acceptance\n        total_evals += evals_per_step\n\n        # Calculate error estimate based on first principles for y'=-lambda*y\n        # e ~ |y| * |(-h*lambda)^(q+1) / (q+1)!|\n        e = abs(y) * (h_current * lambda_val)**(q + 1) / q_factorial\n\n        # Accept or reject the step\n        if e <= tol:\n            # Step accepted: update time and solution\n            t += h_current\n            # Update y using the stability function R_p(z) of the higher-order method\n            z = -h_current * lambda_val\n            R_p_z = sum((z**k) / factorials[k] for k in range(p + 1))\n            y *= R_p_z\n        # If rejected, t and y do not change.\n\n        # Propose the next step size based on the current attempt\n        # Use a small number epsilon to avoid division by zero\n        ratio = tol / max(e, epsilon)\n        scale_factor = s * (ratio**(1.0/p))\n        \n        # Clip the scaling factor to prevent overly aggressive changes\n        clipped_scale_factor = min(max(scale_factor, f_min), f_max)\n        \n        h = h_current * clipped_scale_factor\n        \n    return total_evals\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and determine the optimal method for each case.\n    \"\"\"\n    test_cases = [\n        # (lambda, T, tol)\n        (1.0, 5.0, 1.0e-6),      # Case 1: Nonstiff, tight tolerance\n        (1.0, 5.0, 1.0e-1),      # Case 2: Nonstiff, loose tolerance\n        (1000.0, 1.0, 1.0e-6),   # Case 3: Stiff, tight tolerance\n        (1000.0, 1.0, 1.0e-2),   # Case 4: Stiff, moderate tolerance\n    ]\n\n    # Method A: Heun(2)/Euler(1) embedded pair\n    method_A_params = {'p': 2, 'q': 1, 'evals_per_step': 2, 'r': 2.0}\n    # Method B: Cash-Karp 5(4) embedded pair\n    method_B_params = {'p': 5, 'q': 4, 'evals_per_step': 6, 'r': 2.8}\n\n    results = []\n    for lambda_val, T, tol in test_cases:\n        cost_A = run_simulation(lambda_val, T, tol, **method_A_params)\n        cost_B = run_simulation(lambda_val, T, tol, **method_B_params)\n\n        # Decision rule: Choose method with strictly smaller cost.\n        # If costs are equal, choose Method A.\n        # 0 for Method A, 1 for Method B.\n        if cost_B < cost_A:\n            decision = 1\n        else:\n            decision = 0\n        results.append(decision)\n    \n    # Print the final output in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3095889"}]}