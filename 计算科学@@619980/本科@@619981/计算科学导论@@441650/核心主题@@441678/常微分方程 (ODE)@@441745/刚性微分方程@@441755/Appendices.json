{"hands_on_practices": [{"introduction": "理论是基础，但真正的理解来自于实践。本节的第一个练习旨在让你亲身体验刚性问题的核心挑战。我们将使用一个经典的刚性常微分方程，并分别采用简单的显式（前向欧拉）和隐式（后向欧拉）方法进行求解。通过对比结果，你将清晰地看到为何显式方法在处理刚性问题时，即使步长看似合理，也会彻底失效，以及为何隐式方法是不可或缺的。这个练习 [@problem_id:3198039] 为我们后续的学习奠定了坚实的实践基础。", "problem": "考虑常微分方程 (ODE) 的初值问题 (IVP)：$y^{\\prime}(t) = -\\dfrac{1}{\\epsilon} y(t) + \\sin(t)$，区间为 $t \\in [0, 10]$，初始条件为 $y(0) = 0$。参数 $\\epsilon$ 是一个小的正常数，给定为 $\\epsilon = 10^{-6}$，且正弦函数中 $t$ 的角度单位是弧度。由于项 $-\\dfrac{1}{\\epsilon} y(t)$ 的存在，该初值问题表现出刚性，这一项在解中引入了一个快速衰减的分量。\n\n从基本定义和经过检验的事实出发，完成以下任务：\n\n1. 基于线性 ODE 结构，使用积分因子法推导给定 IVP 的精确解析解 $y(t)$。您的推导必须从一阶线性 ODE 的定义和积分因子的构造开始，并且不得依赖任何提供给您的快捷公式。\n\n2. 使用导数的差商极限定义以及使用固定步长 $h$ 进行时间离散化的思想，推导：\n   - 通过在每个时间步的左端点近似 $y^{\\prime}(t)$ 来推导显式前向欧拉更新法则。\n   - 通过在每个时间步的右端点近似 $y^{\\prime}(t)$ 来推导隐式后向欧拉更新法则。\n   两个推导都必须源于定义 $y^{\\prime}(t) = \\lim_{h \\to 0} \\dfrac{y(t+h) - y(t)}{h}$，并且不得假定任何预先形成的离散更新公式。\n\n3. 使用 Dahlquist 测试方程 $y^{\\prime} = \\lambda y$ 的线性稳定性分析，解释为什么当 $\\epsilon$ 很小时该 IVP 是刚性的，以及这对允许的显式步长有何影响。特别地，从第一性原理出发，确定对显式方法的 $h$ 的约束，并将其与隐式方法的行为进行对比。\n\n4. 实现所推导的两种方法，对一组固定的时间步长 $h$，在 $t \\in [0, 10]$ 上数值近似 $y(t)$。对于每种方法和每个时间步长，计算离散网格点上与您推导的精确解相比的最大绝对误差。如果在显式积分过程中数值解变为非有限值（例如由于溢出），则将该情况下的最大误差视为 $+\\infty$。\n\n角度单位说明：所有三角函数求值必须使用弧度。\n\n测试套件：\n- 参数：$\\epsilon = 10^{-6}$。\n- 初始条件：$y(0) = 0$。\n- 区间：$[0, 10]$。\n- 步长：$h \\in \\{0.001, 0.01, 0.1, 1.0\\}$。\n\n对于上述集合中的每个步长 $h$，评估：\n- 显式前向欧拉方法在离散时间网格 $\\{0, h, 2h, \\dots, 10\\}$ 上的最大绝对误差。\n- 隐式后向欧拉方法在同一网格上的最大绝对误差。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,...]”）。该列表必须按以下顺序汇总结果：对于每个按升序排列的 $h$，首先是显式方法的最大误差，然后是隐式方法的最大误差，因此最终输出有八个条目，按顺序对应于 $h = 0.001、h = 0.01、h = 0.1$ 和 $h = 1.0$。", "solution": "该问题被评估为有效，因为它具有科学依据、问题适定、客观且自洽。它提出了一个刚性常微分方程 (ODE) 的典型示例，并要求进行计算科学领域基础的推导和分析。问题陈述没有矛盾或谬误。\n\n解决方案分为四个部分，与问题描述中列出的任务相对应。\n\n### 1. 精确解析解的推导\n\n给定的初值问题 (IVP) 是：\n$$\ny^{\\prime}(t) = -\\frac{1}{\\epsilon} y(t) + \\sin(t), \\quad y(0) = 0, \\quad t \\in [0, 10]\n$$\n这是一个一阶线性 ODE。此类方程的标准形式为 $y' + p(t)y = q(t)$。通过重新整理给定的 ODE，我们确定相应的项：\n$$\ny^{\\prime}(t) + \\frac{1}{\\epsilon} y(t) = \\sin(t)\n$$\n此处，$p(t) = \\frac{1}{\\epsilon}$ 且 $q(t) = \\sin(t)$。\n\n为了求解此方程，我们使用积分因子法。积分因子 $I(t)$ 定义为：\n$$\nI(t) = e^{\\int p(t) dt}\n$$\n对于本问题，积分为：\n$$\n\\int p(t) dt = \\int \\frac{1}{\\epsilon} dt = \\frac{t}{\\epsilon}\n$$\n因此，积分因子是 $I(t) = e^{t/\\epsilon}$。我们将 ODE 的标准形式乘以 $I(t)$：\n$$\ne^{t/\\epsilon} y^{\\prime}(t) + \\frac{1}{\\epsilon} e^{t/\\epsilon} y(t) = e^{t/\\epsilon} \\sin(t)\n$$\n根据微分的乘法法则，左侧是 $y(t)I(t)$ 的导数：\n$$\n\\frac{d}{dt} \\left( y(t) e^{t/\\epsilon} \\right) = e^{t/\\epsilon} \\sin(t)\n$$\n为了求得 $y(t)$，我们对两边关于 $t$ 进行积分：\n$$\n\\int \\frac{d}{dt} \\left( y(t) e^{t/\\epsilon} \\right) dt = \\int e^{t/\\epsilon} \\sin(t) dt\n$$\n$$\ny(t) e^{t/\\epsilon} = \\int e^{t/\\epsilon} \\sin(t) dt\n$$\n右侧的积分可以使用分部积分法两次求解。形式为 $\\int e^{at}\\sin(bt)dt$ 的积分通解是 $\\frac{e^{at}}{a^2+b^2}(a\\sin(bt) - b\\cos(bt))$。当 $a = 1/\\epsilon$ 和 $b = 1$ 时，我们有：\n$$\n\\int e^{t/\\epsilon} \\sin(t) dt = \\frac{e^{t/\\epsilon}}{(1/\\epsilon)^2 + 1^2} \\left( \\frac{1}{\\epsilon}\\sin(t) - 1\\cos(t) \\right) + C\n$$\n其中 $C$ 是积分常数。简化此表达式：\n$$\n\\int e^{t/\\epsilon} \\sin(t) dt = \\frac{e^{t/\\epsilon}}{(1+\\epsilon^2)/\\epsilon^2} \\left( \\frac{\\sin(t) - \\epsilon\\cos(t)}{\\epsilon} \\right) + C = \\frac{\\epsilon^2 e^{t/\\epsilon}}{1+\\epsilon^2} \\frac{\\sin(t) - \\epsilon\\cos(t)}{\\epsilon} + C\n$$\n$$\n= \\frac{\\epsilon e^{t/\\epsilon}}{1+\\epsilon^2} (\\sin(t) - \\epsilon\\cos(t)) + C = \\frac{e^{t/\\epsilon}}{1+\\epsilon^2} (\\epsilon\\sin(t) - \\epsilon^2\\cos(t)) + C\n$$\n将此结果代回到关于 $y(t)e^{t/\\epsilon}$ 的方程中：\n$$\ny(t) e^{t/\\epsilon} = \\frac{e^{t/\\epsilon}}{1+\\epsilon^2} (\\epsilon\\sin(t) - \\epsilon^2\\cos(t)) + C\n$$\n通过乘以 $e^{-t/\\epsilon}$ 来求解 $y(t)$：\n$$\ny(t) = \\frac{\\epsilon\\sin(t) - \\epsilon^2\\cos(t)}{1+\\epsilon^2} + C e^{-t/\\epsilon}\n$$\n现在，我们应用初始条件 $y(0) = 0$ 来求积分常数 $C$：\n$$\ny(0) = 0 = \\frac{\\epsilon\\sin(0) - \\epsilon^2\\cos(0)}{1+\\epsilon^2} + C e^{0}\n$$\n$$\n0 = \\frac{0 - \\epsilon^2(1)}{1+\\epsilon^2} + C \\implies C = \\frac{\\epsilon^2}{1+\\epsilon^2}\n$$\n将 $C$ 的值代回，得到 IVP 的精确解析解：\n$$\ny(t) = \\frac{\\epsilon\\sin(t) - \\epsilon^2\\cos(t)}{1+\\epsilon^2} + \\frac{\\epsilon^2}{1+\\epsilon^2} e^{-t/\\epsilon}\n$$\n\n### 2. 数值方法的推导\n\n我们从导数的极限定义 $y^{\\prime}(t) = \\lim_{h \\to 0} \\frac{y(t+h) - y(t)}{h}$ 推导数值更新法则。我们考虑一个离散时间网格 $t_n = n h$，其中 $n=0, 1, 2, \\dots$，$h$ 是步长。设 $y_n$ 为 $y(t_n)$ 的数值近似。\n\n**显式前向欧拉法**\n前向欧拉法在时间步的开始处 $t_n$ 近似导数 $y'(t)$。使用基于极限定义的一阶前向差商：\n$$\ny^{\\prime}(t_n) \\approx \\frac{y(t_{n+1}) - y(t_n)}{h}\n$$\n将此近似代入 $t_n$ 时刻的 ODE $y'(t) = f(t, y(t)) = -\\frac{1}{\\epsilon} y(t) + \\sin(t)$ 中：\n$$\n\\frac{y_{n+1} - y_n}{h} = -\\frac{1}{\\epsilon} y_n + \\sin(t_n)\n$$\n求解 $y_{n+1}$ 得到显式前向欧拉更新法则：\n$$\ny_{n+1} = y_n + h \\left( -\\frac{1}{\\epsilon} y_n + \\sin(t_n) \\right)\n$$\n该法则是“显式”的，因为 $y_{n+1}$ 是直接由 $t_n$ 时刻的已知值计算得出的。\n\n**隐式后向欧拉法**\n后向欧拉法通过在时间步的结束处 $t_{n+1}$ 评估 ODE 来近似导数。导数 $y'(t_{n+1})$ 使用后向差商进行近似：\n$$\ny^{\\prime}(t_{n+1}) \\approx \\frac{y(t_{n+1}) - y(t_n)}{h}\n$$\n将此近似代入 $t_{n+1}$ 时刻的 ODE 中：\n$$\n\\frac{y_{n+1} - y_n}{h} = -\\frac{1}{\\epsilon} y_{n+1} + \\sin(t_{n+1})\n$$\n该方程是“隐式”的，因为未知数 $y_{n+1}$ 出现在方程两侧。我们必须求解 $y_{n+1}$：\n$$\ny_{n+1} - y_n = h \\left( -\\frac{1}{\\epsilon} y_{n+1} + \\sin(t_{n+1}) \\right)\n$$\n$$\ny_{n+1} - y_n = -\\frac{h}{\\epsilon} y_{n+1} + h\\sin(t_{n+1})\n$$\n合并含有 $y_{n+1}$ 的项：\n$$\ny_{n+1} + \\frac{h}{\\epsilon} y_{n+1} = y_n + h\\sin(t_{n+1})\n$$\n$$\ny_{n+1} \\left( 1 + \\frac{h}{\\epsilon} \\right) = y_n + h\\sin(t_{n+1})\n$$\n最后，求解 $y_{n+1}$ 得到隐式后向欧拉更新法则：\n$$\ny_{n+1} = \\frac{y_n + h\\sin(t_{n+1})}{1 + h/\\epsilon}\n$$\n\n### 3. 稳定性分析与刚性\n\n刚性概念使用 Dahlquist 测试方程 $y' = \\lambda y$ 进行分析，其中 $\\text{Re}(\\lambda) < 0$。对于给定的 ODE，其动态主要由齐次部分 $y' = -\\frac{1}{\\epsilon} y$ 决定。因此，我们确定 $\\lambda = -1/\\epsilon$。由于 $\\epsilon = 10^{-6}$ 是一个小的正常数，所以 $\\lambda = -10^6$ 是一个大的负实数。\n\n**前向欧拉法的稳定性**\n将前向欧拉法则应用于 $y'=\\lambda y$：\n$$\ny_{n+1} = y_n + h(\\lambda y_n) = (1+h\\lambda) y_n\n$$\n为了使数值解保持有界（即稳定），放大因子 $R(h\\lambda) = 1+h\\lambda$ 必须满足 $|R(h\\lambda)| \\le 1$。\n$$\n|1 + h\\lambda| \\le 1\n$$\n当 $\\lambda = -1/\\epsilon$ 时，这变为 $|1 - h/\\epsilon| \\le 1$。此不等式等价于 $-1 \\le 1 - h/\\epsilon \\le 1$。\n右侧不等式 $1 - h/\\epsilon \\le 1$ 意味着 $h/\\epsilon \\ge 0$，对于正的 $h$ 和 $\\epsilon$ 这总是成立的。\n左侧不等式 $-1 \\le 1 - h/\\epsilon$ 意味着 $h/\\epsilon \\le 2$，即 $h \\le 2\\epsilon$。\n对于 $\\epsilon=10^{-6}$，步长必须满足 $h \\le 2 \\times 10^{-6}$。这是一个非常严格的限制。对于任何步长 $h > 2\\epsilon$，数值解将变得无界，并表现出指数增长的振荡。\n\n**后向欧拉法的稳定性**\n将后向欧拉法则应用于 $y'=\\lambda y$：\n$$\ny_{n+1} = y_n + h(\\lambda y_{n+1}) \\implies y_{n+1}(1 - h\\lambda) = y_n \\implies y_{n+1} = \\frac{1}{1-h\\lambda} y_n\n$$\n放大因子为 $R(h\\lambda) = \\frac{1}{1-h\\lambda}$。为保证稳定性，我们要求 $|R(h\\lambda)| \\le 1$。\n$$\n\\left| \\frac{1}{1-h\\lambda} \\right| \\le 1\n$$\n当 $\\lambda = -1/\\epsilon$ 时，这变为 $\\left| \\frac{1}{1+h/\\epsilon} \\right|$。由于 $h > 0$ 且 $\\epsilon > 0$，分母 $1+h/\\epsilon$ 总是大于 1。因此，其倒数的绝对值总是小于 1。该方法对于任何 $h > 0$ 的选择都是稳定的。此性质被称为 A-稳定性。\n\n**刚性解释**\n该 IVP 是刚性的，因为其精确解 $y(t) = \\frac{\\epsilon\\sin(t) - \\epsilon^2\\cos(t)}{1+\\epsilon^2} + \\frac{\\epsilon^2}{1+\\epsilon^2} e^{-t/\\epsilon}$ 包含两个时间尺度差异巨大的分量。\n1. 一个与 $e^{-t/\\epsilon}$ 成正比的快速衰减的瞬态分量，其特征时间尺度为 $\\tau_{fast} = \\epsilon = 10^{-6}$。该分量几乎瞬间变得可以忽略不计。\n2. 一个缓慢变化的分量，其振荡时间尺度为 $\\tau_{slow} \\approx 2\\pi$。\n\n刚性的产生是因为像前向欧拉法这样的显式方法的稳定性受最快时间尺度 ($\\tau_{fast}$) 的制约，即使在快速分量消失很久之后，仍强制使用不切实际的小步长 ($h \\le 2\\epsilon$)。而像后向欧拉法这样的隐式方法，由于对此问题是无条件稳定的，其稳定性不受 $\\tau_{fast}$ 的限制。它可以使用由捕捉慢分量的精度要求决定的更大的步长 $h$，这使其在处理刚性问题时效率要高得多。\n\n### 4. 实现与误差分析\n\n我们实现前向和后向欧拉法，使用步长 $h \\in \\{0.001, 0.01, 0.1, 1.0\\}$ 在 $t \\in [0, 10]$ 上求解该 IVP。由于所有这些步长都违反了前向欧拉法的稳定性条件 ($h > 2 \\times 10^{-6}$)，显式方法预计会产生无界增长的数值不稳定解，从而导致无穷大的最大误差。而隐式方法是稳定的，应该会产生准确的结果，其误差随着 $h$ 的减小而减小。对于每种情况，都在网格点上计算数值解与精确解之间的最大绝对误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a stiff ODE using Forward and Backward Euler methods,\n    and calculates the maximum absolute error against the exact solution.\n    \"\"\"\n    \n    # Define problem parameters from the statement\n    epsilon = 1e-6\n    t_end = 10.0\n    y0 = 0.0\n    \n    # Test suite of step sizes, in increasing order as required for output.\n    h_values = [0.001, 0.01, 0.1, 1.0]\n    \n    # List to store the results in the specified order.\n    results = []\n\n    # Exact solution derived via integrating factor\n    # y(t) = (epsilon*sin(t) - epsilon^2*cos(t))/(1 + epsilon^2) \n    #        + (epsilon^2 / (1 + epsilon^2)) * exp(-t/epsilon)\n    def y_exact(t, eps):\n        term1 = (eps * np.sin(t) - eps**2 * np.cos(t)) / (1 + eps**2)\n        term2 = (eps**2 / (1 + eps**2)) * np.exp(-t / eps)\n        return term1 + term2\n\n    # Loop over each step size\n    for h in h_values:\n        # Create a stable time grid from 0 to t_end\n        # Using np.linspace is more robust against floating point errors than np.arange\n        num_steps = int(round(t_end / h))\n        t_points = np.linspace(0, t_end, num_steps + 1)\n        \n        # --- Explicit Forward Euler Method ---\n        y_fe = np.zeros(num_steps + 1)\n        y_fe[0] = y0\n        is_finite_fe = True\n        \n        for n in range(num_steps):\n            # y_{n+1} = y_n + h * f(t_n, y_n)\n            # f(t,y) = -y/epsilon + sin(t)\n            y_fe[n+1] = y_fe[n] + h * (-y_fe[n] / epsilon + np.sin(t_points[n]))\n            # Check for overflow at each step to prevent warnings and handle correctly.\n            if not np.isfinite(y_fe[n+1]):\n                is_finite_fe = False\n                break\n        \n        # Calculate maximum absolute error for Forward Euler\n        if is_finite_fe:\n            y_true = y_exact(t_points, epsilon)\n            error_fe = np.max(np.abs(y_fe - y_true))\n        else:\n            # As per problem, if solution is non-finite, error is +inf\n            error_fe = float('inf')\n        \n        results.append(error_fe)\n        \n        # --- Implicit Backward Euler Method ---\n        y_be = np.zeros(num_steps + 1)\n        y_be[0] = y0\n        \n        for n in range(num_steps):\n            # y_{n+1} = (y_n + h*sin(t_{n+1})) / (1 + h/epsilon)\n            numerator = y_be[n] + h * np.sin(t_points[n+1])\n            denominator = 1 + h / epsilon\n            y_be[n+1] = numerator / denominator\n\n        # Calculate maximum absolute error for Backward Euler\n        y_true = y_exact(t_points, epsilon)\n        error_be = np.max(np.abs(y_be - y_true))\n        results.append(error_be)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3198039"}, {"introduction": "在认识到隐式方法的稳定性优势后，我们面临一个新的实际问题：对于非线性常微分方程，每个隐式时间步都要求我们解一个非线性代数方程。本次练习 [@problem_id:2442982] 将指导你解决这一挑战，你需要在后向欧拉法的框架内，实现牛顿法作为迭代求解器。掌握这项技能对于将隐式方法应用于现实世界中的非线性刚性问题至关重要。", "problem": "给定一个标量常微分方程（ODE）\n$$\n\\frac{dy}{dt} = f(t,y) = -k\\,(y - \\sin t) - b\\,y^3,\n$$\n其初始条件为\n$$\ny(0) = y_0,\n$$\n该方程定义在区间\n$$\nt \\in [0,T], \\quad t_n = n\\,h, \\quad n=0,1,\\dots,N, \\quad \\text{with } Nh = T \\text{ and } h>0.\n$$\n上的均匀时间网格上。函数 $\\sin t$ 中的角度必须以弧度为单位进行解释。在每一步中，使用隐式单步更新公式\n$$\ny_{n+1} = y_n + h\\,f(t_{n+1}, y_{n+1}),\n$$\n并使用牛顿法求解得到的关于 $y_{n+1}$ 的非线性代数方程。牛顿法的绝对停止容差为 $10^{-12}$（应用于残差或牛顿步长），每个时间步最多迭代 $50$ 次。在每一步中，使用 $y_{n}$ 初始化牛顿法。\n\n请实现一个程序，对于下面测试套件中的每一组参数，使用上述方法将数值解从 $t=0$ 推进到 $t=T$，并返回 $y(T)$ 的近似值。\n\n测试套件（每个元组为 $(k,b,y_0,T,h)$）：\n- 情况 A（刚性，非线性，带强迫项）：$(1000, 10, 0, 0.1, 0.001)$。\n- 情况 B（刚性，线性，带强迫项）：$(1000, 0, 1, 0.1, 0.001)$。\n- 情况 C（单大步长，刚性，非线性）：$(1000, 5, 1, 0.05, 0.05)$。\n- 情况 D（非刚性，纯非线性）：$(0, 50, 1, 0.02, 0.005)$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的条目依次为情况 A, B, C, D 的 $y(T)$ 近似值，每个值都四舍五入到恰好 $8$ 位小数。例如，包含四个结果的输出必须如下所示\n$$\n[\\text{res}_A,\\text{res}_B,\\text{res}_C,\\text{res}_D].\n$$", "solution": "所给出的问题是一个形式为 $\\frac{dy}{dt} = f(t,y)$ 的标量常微分方程（ODE），需要进行数值求解。该问题定义明确，科学上可靠，并包含了通过指定算法获得唯一解所需的所有信息。因此，我将着手解决此问题。\n\n控制方程为：\n$$\n\\frac{dy}{dt} = f(t,y) = -k\\,(y - \\sin t) - b\\,y^3, \\quad y(0) = y_0\n$$\n该方程描述了一个系统，其中包含一个以速率 $k$ 向正弦驱动函数 $\\sin t$ 弛豫的线性项，以及一个与 $y^3$ 成正比的非线性阻尼项。$k$ 的大小决定了方程的刚性。对于较大的 $k$，显式数值方法需要极小的时间步长 $h \\ll 1/k$ 来维持稳定性。该问题正确地指定了使用隐式方法来处理这种刚性。\n\n数值积分采用隐式单步后向欧拉法进行。对于均匀时间网格 $t_n = n\\,h$，从时间 $t_n$ 到 $t_{n+1}$ 的更新规则如下：\n$$\ny_{n+1} = y_n + h\\,f(t_{n+1}, y_{n+1})\n$$\n其中 $y_n$ 是 $y(t_n)$ 的近似值。该方程是隐式的，因为未知值 $y_{n+1}$ 出现在等式两边。为了在每个时间步求解 $y_{n+1}$，我们必须求解一个非线性代数方程。该方程可以通过定义一个我们寻求其根的残差函数 $R(x)$ 来表示：\n$$\nR(x) = x - y_n - h\\,f(t_{n+1}, x) = 0\n$$\n其中 $x$ 代表未知数 $y_{n+1}$。\n\n为了找到 $R(x)=0$ 的根，我们采用牛顿法，这是一个迭代过程，定义如下：\n$$\nx^{(j+1)} = x^{(j)} - \\frac{R(x^{(j)})}{R'(x^{(j)})}\n$$\n其中 $x^{(j)}$ 是第 $j$ 次迭代时对根的猜测值，而 $R'(x) = \\frac{dR}{dx}$ 是残差函数关于 $x$ 的导数。每个时间步的初始猜测值被指定为上一步的值，即 $x^{(0)} = y_n$。\n\n导数 $R'(x)$ 的计算如下：\n$$\nR'(x) = \\frac{d}{dx} \\left( x - y_n - h\\,f(t_{n+1}, x) \\right) = 1 - h\\,\\frac{\\partial f}{\\partial y}(t_{n+1}, x)\n$$\n对于给定的函数 $f(t,y)$，其关于 $y$ 的偏导数为：\n$$\n\\frac{\\partial f}{\\partial y}(t,y) = \\frac{\\partial}{\\partial y} \\left( -k\\,(y - \\sin t) - b\\,y^3 \\right) = -k - 3\\,b\\,y^2\n$$\n将此代入 $R'(x)$ 的表达式中，我们得到：\n$$\nR'(x) = 1 - h\\,(-k - 3\\,b\\,x^2) = 1 + h\\,k + 3\\,h\\,b\\,x^2\n$$\n因此，求解 $y_{n+1}$ 的牛顿迭代是一个循环过程，不断更新猜测值 $x^{(j)}$ 直到满足停止准则。该准则为残差的绝对值 $|R(x^{(j)})|$ 或牛顿步长的绝对值 $|x^{(j+1)} - x^{(j)}|$ 小于绝对容差 $10^{-12}$。如果在 $50$ 次迭代内未达到收敛，则终止该过程。\n\n每个测试用例的总体算法如下：\n1.  初始化参数 $(k, b, y_0, T, h)$ 并计算总步数 $N = T/h$。\n2.  设置初始解 $y = y_0$ 和初始时间 $t = 0$。\n3.  从 $n=0$ 循环到 $N-1$：\n    a.  确定下一个时间点 $t_{n+1} = (n+1)h$。\n    b.  将 $y_{n+1}$ 的牛顿法初始猜测值设为 $x^{(0)} = y_n$。\n    c.  使用牛顿法迭代最多 $50$ 步来寻找解 $R(x)=0$ 的 $x$。在每次迭代 $j$ 中：\n        i.  计算残差 $R(x^{(j)})$。如果其绝对值小于 $10^{-12}$，则达到收敛。该时间步的结果为 $x^{(j)}$。\n        ii. 计算导数 $R'(x^{(j)})$。\n        iii. 计算牛顿步长 $\\Delta x = -R(x^{(j)}) / R'(x^{(j)})$。\n        iv. 更新猜测值：$x^{(j+1)} = x^{(j)} + \\Delta x$。\n        v. 如果步长的绝对值 $|\\Delta x|$ 小于 $10^{-12}$，则达到收敛。该时间步的结果为 $x^{(j+1)}$。\n    d.  更新下一个时间步的解：$y_{n+1} = x_{converged}$。\n4.  经过 $N$ 步后 $y$ 的最终值即为所求的 $y(T)$ 的近似值。对所有指定的测试用例重复此过程。", "answer": "```python\nimport numpy as np\n\ndef run_simulation(k, b, y0, T, h):\n    \"\"\"\n    Solves the ODE dy/dt = -k*(y - sin(t)) - b*y^3 using Backward Euler\n    with Newton's method for the nonlinear solve.\n    \n    Args:\n        k (float): Stiffness parameter.\n        b (float): Nonlinearity parameter.\n        y0 (float): Initial condition y(0).\n        T (float): Final time.\n        h (float): Time step size.\n\n    Returns:\n        float: The numerical solution y(T).\n    \"\"\"\n\n    # Define the ODE function f(t, y)\n    def f(t, y, k, b):\n        return -k * (y - np.sin(t)) - b * y**3\n\n    # Define the partial derivative of f with respect to y, df/dy\n    def df_dy(t, y, k, b):\n        return -k - 3 * b * y**2\n\n    # Ensure n_steps is integer\n    n_steps = int(round(T / h))\n    if not np.isclose(n_steps * h, T):\n        # This case is not expected based on the problem statement's test cases\n        # but is good practice.\n        raise ValueError(\"T must be an integer multiple of h.\")\n\n    y_current = y0\n\n    # Main time-stepping loop\n    for n in range(n_steps):\n        t_next = (n + 1) * h\n        y_guess = y_current\n        \n        # Newton's method to solve y_next = y_current + h * f(t_next, y_next)\n        # This is equivalent to finding the root of R(y_next) = 0 where\n        # R(y_next) = y_next - y_current - h * f(t_next, y_next)\n        for _ in range(50): # Maximum of 50 iterations\n            \n            # Calculate residual at the current guess\n            residual = y_guess - y_current - h * f(t_next, y_guess, k, b)\n\n            # Check for convergence on residual\n            if abs(residual) < 1e-12:\n                break\n                \n            # Calculate Jacobian of the residual function\n            # R'(y) = 1 - h * df/dy\n            jac_residual = 1.0 - h * df_dy(t_next, y_guess, k, b)\n            \n            # Avoid division by zero, although not an issue for this problem's parameters\n            if jac_residual == 0:\n                break\n\n            # Calculate Newton step\n            step = -residual / jac_residual\n            \n            # Update the guess\n            y_guess += step\n            \n            # Check for convergence on the step size\n            if abs(step) < 1e-12:\n                break\n        \n        y_current = y_guess\n\n    return y_current\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test suite: (k, b, y0, T, h)\n    test_cases = [\n        (1000, 10, 0, 0.1, 0.001),     # Case A\n        (1000, 0, 1, 0.1, 0.001),      # Case B\n        (1000, 5, 1, 0.05, 0.05),       # Case C\n        (0, 50, 1, 0.02, 0.005)        # Case D\n    ]\n\n    results = []\n    for params in test_cases:\n        y_final = run_simulation(*params)\n        results.append(y_final)\n\n    # Format output as specified\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2442982"}, {"introduction": "现代的常微分方程求解器并非一成不变，它们会根据问题的局部特性在显式和隐式方法间智能切换，以达到效率和稳定性的最佳平衡。本章的最后一个练习将让你扮演求解器设计师的角色，构建一个“刚性探测器”来实现这种决策自动化。通过数值方法估计雅可比矩阵并分析其特征值，你将把所学的稳定性理论 [@problem_id:3279238] 应用于一个实用的工具中，从而学会在求解过程中实时诊断问题的刚性。", "problem": "要求您设计并实现一个程序，该程序能为一个给定形式为 $\\frac{d y}{d t} = f(y)$ 的自治常微分方程（ODE）系统，在指定的点 $(t, y)$ 和时间步长 $h$ 处，构建一个局部的“刚性检测器”。该检测器必须在点 $(t, y)$ 处数值上估计雅可比矩阵 $J = \\frac{\\partial f}{\\partial y}$，并基于显式单步法的绝对稳定性要求，使用一个有原则的稳定性测试来决定是使用显式求解器还是隐式求解器。决策标准必须从基本定义推导得出（不使用问题陈述中提供的快捷公式）：对系统进行局部线性化，描述该方法下各模式的放大情况，并确定确保所有模式衰减而非增长的条件。\n\n您的程序必须：\n- 在点 $(t, y)$ 使用有限差分实现一个数值雅可比估计器。您可以假设 $f$ 在 $(t, y)$ 的邻域内足够平滑，并且系统维数等于状态维数，因此 $J$ 是方阵。\n- 计算估计的雅可比矩阵的特征值，并通过检查由局部线性化和显式更新所隐含的模式放大因子，应用显式方法的绝对稳定性要求。使用一个保守的决策规则：如果任何模式在给定的 $h$ 下违反了严格的稳定性要求，检测器必须选择隐式求解器；否则，它必须选择显式求解器。\n- 为每个测试用例返回一个布尔决策，其中 $\\text{True}$ 表示“选择隐式求解器”，$\\text{False}$ 表示“选择显式求解器”。\n\n在以下测试套件上实现并评估您的检测器，该套件涵盖了标量、线性多维和非线性系统，包括正常情况、边界情况和边缘情况。在下述所有情况中，系统都是自治的，因此 $f$ 仅依赖于 $y$；但为了接口一致性，您仍需将 $t$ 传递给函数，不过 $t$ 在计算中并未使用。\n\n测试用例：\n1. 标量线性衰减（正常情况，显式稳定性成立）：\n   - 系统：$\\frac{d y}{d t} = -1000\\, y$\n   - 评估点：$t = 0$，$y = 1$\n   - 时间步长：$h = 10^{-3}$\n   - 预期检测器决策：显式求解器可接受。\n2. 标量线性衰减（边界/显式不稳定；保守决策选择隐式）：\n   - 系统：$\\frac{d y}{d t} = -1000\\, y$\n   - 评估点：$t = 0$，$y = 1$\n   - 时间步长：$h = 2\\times 10^{-3}$\n   - 预期检测器决策：在此 $h$ 下，显式求解器违反严格稳定性；选择隐式。\n3. 二维阻尼振荡器（小步长下显式稳定性成立）：\n   - 系统：$\\frac{d}{dt}\\begin{bmatrix} y_1 \\\\ y_2 \\end{bmatrix} = \\begin{bmatrix} y_2 \\\\ -\\omega^2 y_1 - 2 \\zeta \\omega y_2 \\end{bmatrix}$，其中 $\\omega = 50$ 且 $\\zeta = 0.05$\n   - 评估点：$t = 0$，$y = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$\n   - 时间步长：$h = 10^{-3}$\n   - 预期检测器决策：显式求解器可接受。\n4. 二维阻尼振荡器（大步长下显式不稳定性）：\n   - 系统：与情况3相同\n   - 评估点：$t = 0$，$y = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$\n   - 时间步长：$h = 5\\times 10^{-2}$\n   - 预期检测器决策：选择隐式求解器。\n5. 二维非线性反应模型（小步长下显式稳定性成立）：\n   - 系统：$\\frac{d}{dt}\\begin{bmatrix} y_1 \\\\ y_2 \\end{bmatrix} = \\begin{bmatrix} -k_1 y_1 + k_2 y_2^2 \\\\ k_1 y_1 - k_2 y_2^2 - k_3 y_2 \\end{bmatrix}$，其中 $k_1 = 1$，$k_2 = 1$，$k_3 = 1000$\n   - 评估点：$t = 0$，$y = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$\n   - 时间步长：$h = 10^{-3}$\n   - 预期检测器决策：显式求解器可接受。\n6. 二维非线性反应模型（大步长下显式不稳定性）：\n   - 系统：与情况5相同\n   - 评估点：$t = 0$，$y = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$\n   - 时间步长：$h = 10^{-2}$\n   - 预期检测器决策：选择隐式求解器。\n\n数值雅可比估计要求：\n- 对 $J$ 的每一列 $j$ 使用中心有限差分近似，将 $y_j$ 扰动一个小的增量 $\\delta_j$，其选择为 $\\delta_j = \\sqrt{\\varepsilon}\\,\\max\\{1, |y_j|\\}$，其中 $\\varepsilon$ 是双精度浮点运算的机器$\\epsilon$。\n\n求解器决策规则：\n- 在 $(t, y)$ 处对系统进行形式上的线性化，并对所有特征模式应用显式单步法的绝对稳定性要求。如果在给定的 $h$ 下有任何模式未能满足严格稳定性要求，则返回 $\\text{True}$（选择隐式）；否则返回 $\\text{False}$（选择显式）。在检测器中，将等于稳定性边界的情况视为显式方法的不稳定情况。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3,result4,result5,result6]\"），其中每个结果是按上述顺序列出的相应测试用例的布尔决策。", "solution": "该问题要求设计并实现一个用于自治常微分方程（ODE）系统 $\\frac{d y}{d t} = f(y)$ 的数值刚性检测器。该检测器的目的是在给定的点 $(t, y)$ 和特定的时间步长 $h$ 下，决定使用显式求解器还是隐式求解器更为合适。该决策必须基于应用于 ODE 系统局部线性化的原型显式单步法的绝对稳定性特性。\n\n### 原理1：局部线性化\n一个一般的非线性 ODE 系统 $\\frac{d y}{d t} = f(y)$ 可以在点 $y_0$ 附近通过考虑一个效应很小的扰动 $\\delta y(t) = y(t) - y_0$ 的演化来进行局部分析。$f(y)$ 在 $y_0$ 附近的一阶泰勒展开为：\n$$ f(y) = f(y_0) + \\frac{\\partial f}{\\partial y}\\bigg|_{y_0} (y - y_0) + \\mathcal{O}(\\|y - y_0\\|^2) $$\n令 $J(y_0) = \\frac{\\partial f}{\\partial y}\\big|_{y_0}$ 为 $f$ 在 $y_0$ 处求值的雅可比矩阵。那么扰动的变化率为：\n$$ \\frac{d(\\delta y)}{dt} = \\frac{d y}{dt} = f(y) \\approx f(y_0) + J(y_0) \\delta y $$\n对于在特定状态 $y_0$ 下求值的自治系统，我们可以通过分析扰动的齐次方程来研究线性化系统的稳定性：\n$$ \\frac{d(\\delta y)}{dt} \\approx J(y_0) \\delta y $$\n原始非线性系统的局部稳定性和刚性特征由这个线性系统的性质决定，特别是雅可比矩阵 $J(y_0)$ 的特征值。\n\n### 原理2：显式方法的绝对稳定性\n我们考虑使用前向欧拉法作为代表性的显式单步法来求解 ODE。其更新规则为：\n$$ y_{n+1} = y_n + h f(y_n) $$\n其中 $h$ 是时间步长。将此方法应用于线性化的扰动方程，可以得到扰动 $\\delta y_n$ 从一步到下一步的更新规则：\n$$ \\delta y_{n+1} = \\delta y_n + h (J \\cdot \\delta y_n) = (I + hJ) \\delta y_n $$\n这里，$I$ 是单位矩阵，$J$ 是在关注点处求值的雅可比矩阵。矩阵 $G = I + hJ$ 被称为放大矩阵，因为它决定了扰动在从一步到下一步的过程中是如何被放大或衰减的。\n\n为了分析 $G$ 的行为，我们考虑它对 $J$ 的特征向量的作用。令 $\\{\\lambda_k\\}$ 为 $J$ 的特征值，对应的特征向量为 $\\{v_k\\}$。如果我们将扰动 $\\delta y_n$ 表示为这些特征向量的线性组合 $\\delta y_n = \\sum_k c_k v_k$，其演化过程为：\n$$ \\delta y_{n+1} = (I + hJ) \\sum_k c_k v_k = \\sum_k c_k (I + hJ) v_k = \\sum_k c_k (v_k + h \\lambda_k v_k) = \\sum_k c_k (1 + h\\lambda_k) v_k $$\n为了使数值解稳定，任何扰动都必须随时间衰减。这要求每个模式的放大因子 $g_k = 1 + h\\lambda_k$ 的模严格小于 1。这就给出了绝对稳定性要求：\n$$ |1 + h\\lambda_k| < 1 \\quad \\text{对于所有 } J \\text{ 的特征值 } \\lambda_k $$\n满足 $|1+z| < 1$ 的复数集合 $z = h\\lambda$ 构成了绝对稳定域。这个不等式描述了复平面上以 $(-1, 0)$ 为中心、半径为 1 的圆的内部。\n\n### 刚性检测器算法\n该检测器将此稳定性检查形式化为一个决策规则。如果给定的步长 $h$ 太大，以至于无法用显式方法稳定地解析系统中最快衰减的模式，则认为该系统相对于 $h$ 是“刚性”的。\n\n1.  **决策标准：** 给定系统 $f$、点 $(t, y_0)$ 和步长 $h$，检测器将计算雅可比矩阵 $J(y_0)$ 的特征值 $\\{\\lambda_k\\}$。然后它将检查是否满足稳定性条件。问题指定了一个保守规则：如果任何模式违反了条件，包括在边界上，都应选择隐式方法。因此，如果存在以下情况，检测器将返回 `True`（选择隐式）：\n    $$ \\exists k \\text{ 使得 } |1 + h\\lambda_k| \\ge 1 $$\n    否则，如果对于所有的 $k$ 都有 $|1 + h\\lambda_k| < 1$，它将返回 `False`（选择显式）。\n\n2.  **数值雅可比估计：** 由于解析雅可比矩阵可能无法获得，因此需要进行数值估计。对于雅可比矩阵 $J$ 的每一列 $j$，我们使用中心有限差分近似。这涉及将状态向量 $y$ 的第 $j$ 个分量在两个方向上扰动一个很小的量 $\\delta_j$。\n    $$ J_{:,j} = \\frac{\\partial f}{\\partial y_j} \\approx \\frac{f(y + \\delta_j \\mathbf{e}_j) - f(y - \\delta_j \\mathbf{e}_j)}{2 \\delta_j} $$\n    其中 $\\mathbf{e}_j$ 是第 $j$ 个标准基向量。扰动大小 $\\delta_j$ 的选择是为了平衡截断误差（来自泰勒近似）和舍入误差（来自浮点运算）。如问题所指定，一个鲁棒的选择是：\n    $$ \\delta_j = \\sqrt{\\varepsilon} \\cdot \\max\\{1, |y_j|\\} $$\n    其中 $\\varepsilon$ 是双精度浮点数的机器$\\epsilon$。\n\n3.  **总体步骤：**\n    a. 给定 $f$，$t_0$，$y_0$ 和 $h$。\n    b. 使用中心差分公式为每一列在 $y_0$ 处构造数值雅可比矩阵 $J_{num}$。\n    c. 计算 $J_{num}$ 的特征值 $\\{\\lambda_k\\}$。这些特征值可能是复数。\n    d. 对每个特征值 $\\lambda_k$，计算复数 $z_k = h\\lambda_k$ 的值。\n    e. 检查是否有 $|1 + z_k| \\ge 1$。如果对于任何 $k$ 此条件成立，则决策为 `True`。\n    f. 如果对于任何特征值，(e) 中的条件都不满足，则决策为 `False`。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef numerical_jacobian(f, t, y, machine_eps):\n    \"\"\"\n    Computes the Jacobian of f at (t, y) using central finite differences.\n\n    Args:\n        f (callable): The RHS function of the ODE, f(t, y).\n        t (float): The current time.\n        y (np.ndarray or float): The current state.\n        machine_eps (float): The machine epsilon for float precision.\n\n    Returns:\n        np.ndarray: The estimated Jacobian matrix.\n    \"\"\"\n    y = np.atleast_1d(y).astype(float)\n    n = len(y)\n    J = np.zeros((n, n), dtype=float)\n    \n    for j in range(n):\n        # Create a perturbation vector\n        pert_vec = np.zeros_like(y)\n        \n        # Calculate optimal perturbation size\n        delta = np.sqrt(machine_eps) * max(1.0, abs(y[j]))\n        pert_vec[j] = delta\n        \n        # Central difference formula\n        f_plus = f(t, y + pert_vec)\n        f_minus = f(t, y - pert_vec)\n        \n        J[:, j] = (f_plus - f_minus) / (2 * delta)\n        \n    return J\n\ndef stiffness_detector(f, t, y, h):\n    \"\"\"\n    Decides whether to use an implicit or explicit solver based on stability.\n    \n    Args:\n        f (callable): The RHS function of the ODE, f(t, y).\n        t (float): The evaluation time.\n        y (np.ndarray or float): The evaluation point.\n        h (float): The time step.\n        \n    Returns:\n        bool: True if an implicit solver is recommended, False otherwise.\n    \"\"\"\n    machine_eps = np.finfo(float).eps\n    J = numerical_jacobian(f, t, y, machine_eps)\n    eigenvalues = np.linalg.eigvals(J)\n    \n    # Check the absolute stability condition for Forward Euler for each eigenvalue.\n    # The region of absolute stability is |1 + h*lambda| < 1.\n    # If any eigenvalue falls outside or on the boundary, we need an implicit method.\n    for lam in eigenvalues:\n        amplification_factor = 1 + h * lam\n        if np.abs(amplification_factor)  1.0:\n            return True  # Choose implicit solver\n\n    return False  # Explicit solver is acceptable\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the ODE functions for the test cases\n    def f1(t, y):\n        return -1000.0 * y\n\n    def f3(t, y):\n        omega = 50.0\n        zeta = 0.05\n        # y is a numpy array [y1, y2]\n        return np.array([y[1], -omega**2 * y[0] - 2 * zeta * omega * y[1]])\n\n    def f5(t, y):\n        k1 = 1.0\n        k2 = 1.0\n        k3 = 1000.0\n        # y is a numpy array [y1, y2]\n        return np.array([\n            -k1 * y[0] + k2 * y[1]**2,\n            k1 * y[0] - k2 * y[1]**2 - k3 * y[1]\n        ])\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. Scalar linear decay (happy path)\n        (f1, 0.0, 1.0, 1e-3),\n        # 2. Scalar linear decay (boundary)\n        (f1, 0.0, 1.0, 2e-3),\n        # 3. Damped oscillator (stable)\n        (f3, 0.0, np.array([1.0, 0.0]), 1e-3),\n        # 4. Damped oscillator (unstable)\n        (f3, 0.0, np.array([1.0, 0.0]), 5e-2),\n        # 5. Nonlinear reaction (stable)\n        (f5, 0.0, np.array([1.0, 1.0]), 1e-3),\n        # 6. Nonlinear reaction (unstable)\n        (f5, 0.0, np.array([1.0, 1.0]), 1e-2),\n    ]\n\n    results = []\n    for f, t, y, h in test_cases:\n        decision = stiffness_detector(f, t, y, h)\n        results.append(decision)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3279238"}]}