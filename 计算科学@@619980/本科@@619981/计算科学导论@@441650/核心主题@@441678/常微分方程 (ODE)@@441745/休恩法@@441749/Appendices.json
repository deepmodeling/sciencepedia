{"hands_on_practices": [{"introduction": "一个数值方法最重要的理论特性是其收敛阶。在本实践中，我们将通过数值实验来验证霍恩方法 ([@problem_id:3259641]) 确实具有我们所期望的二阶精度 ($p=2$)。通过在对数-对数坐标下绘制全局误差与步长的关系图，我们可以从拟合直线的斜率中直接估计出收敛阶，这是检验任何数值方法实现是否正确的基本步骤。", "problem": "考虑初值问题 (IVP) $y'(t) = f(t,y(t))$，其中 $y(t_0) = y_0$，函数 $f$ 在闭区间 $[t_0,T]$ 上关于两个参数均连续可微。对于一个采用均匀步长 $h$ 和 $N = (T - t_0)/h$ 步的单步法，其在时间 $T$ 的全局离散误差定义为 $E(h) = \\lvert y_N - y(T) \\rvert$，其中 $y_N$ 是该方法产生的对 $y(T)$ 的数值近似。\n\nHeun 法（也称为显式梯形法）是一种单步法，它通过对积分表达式 $y(t_{n+1}) = y(t_n) + \\int_{t_n}^{t_{n+1}} f(s,y(s)) \\, ds$ 应用梯形求积法则，并使用前向欧拉预测来近似第二个函数求值得到。对于均匀步长 $h$，从 $(t_n,y_n)$ 到 $(t_{n+1},y_{n+1})$ 的单步迭代公式为\n$$\ny_{n+1} = y_n + \\frac{h}{2}\\left(f(t_n,y_n) + f\\!\\left(t_{n+1}, y_n + h\\,f(t_n,y_n)\\right)\\right).\n$$\n假设 $f$ 和精确解 $y$ 足够光滑，使得 Heun 法的局部截断误差是良定义的。\n\n你的任务是通过一组光滑问题的测试集，在数值上验证 Heun 法在最终时间 $T$ 的全局误差 $E(h)$ 具有 $\\mathcal{O}(h^2)$ 的阶。为此，对于下面的每个测试用例：\n- 对 $[t_0,T]$ 区间上的一系列 $N$ 值，使用均匀步长 $h = (T - t_0)/N$ 实现 Heun 法。\n- 使用已知的精确解 $y(T)$ 计算在 $T$ 处的全局误差 $E(h)$。\n- 在给定步长集合上，将观测到的阶 $p$ 估计为点对 $\\big(\\log(h), \\log(E(h))\\big)$ 在最小二乘意义下的最佳拟合直线的斜率。具体来说，如果 $(x_i,y_i) = \\big(\\log(h_i),\\log(E(h_i))\\big)$，找到使 $\\sum_i (y_i - \\alpha - p\\,x_i)^2$ 最小化的直线 $y \\approx \\alpha + p\\,x$，并返回其斜率 $p$。\n\n使用以下测试集。当出现三角函数时，所有角度均以弧度为单位。\n\n- 测试用例 1（线性，指数衰减）：$f(t,y) = -y$，$t_0 = 0$，$y_0 = 1$，$T = 1$，精确解 $y(t) = e^{-t}$，步数 $N \\in \\{10, 20, 40, 80\\}$。\n- 测试用例 2（乘性振荡）：$f(t,y) = y\\cos(t)$，$t_0 = 0$，$y_0 = 1$，$T = \\pi$，精确解 $y(t) = \\exp(\\sin(t))$，步数 $N \\in \\{20, 40, 80, 160\\}$。\n- 测试用例 3（短区间上的非线性增长）：$f(t,y) = y^2$，$t_0 = 0$，$y_0 = 1$，$T = 0.5$，精确解 $y(t) = \\frac{1}{1 - t}$，步数 $N \\in \\{20, 40, 80, 160\\}$。\n- 测试用例 4（纯外力）：$f(t,y) = \\sin(t)$，$t_0 = 0$，$y_0 = 0$，$T = 2$，精确解 $y(t) = 1 - \\cos(t)$，步数 $N \\in \\{20, 40, 80, 160\\}$。\n\n你的程序必须：\n- 按前述说明实现 Heun 法。\n- 对每个测试用例，使用指定的 $N$ 值计算 $(h, E(h))$ 值列表，按前述方法估计斜率 $p$，并收集这四个斜率。\n- 生成单行输出，其中包含这四个斜率，格式为方括号内以逗号分隔的列表，例如 $[p_1,p_2,p_3,p_4]$。每个 $p_i$ 必须是浮点数。\n\n不涉及任何物理单位。所有三角函数求值必须使用弧度制。程序必须是自包含的，且不要求任何输入。最终输出是对应四个测试用例的四个浮点数斜率。", "solution": "该问题要求对几个初值问题 (IVP) 数值上验证 Heun 法的收敛阶。对于一个 $p$ 阶单步法，在固定时间 $T$ 和使用步长 $h$ 的情况下，其理论全局误差在 $h \\to 0$ 时应表现为 $E(h) \\approx C h^p$，其中 $C$ 为某个常数。已知 Heun 法是二阶方法，因此我们预期会得到 $p \\approx 2$。\n\n为了在数值上验证这一点，我们可以分析误差 $E(h)$ 和步长 $h$ 之间的关系。对误差表达式取自然对数可得：\n$$ \\log(E(h)) \\approx \\log(C) + p \\log(h) $$\n该方程具有直线 $y = \\alpha + p x$ 的形式，其中 $y = \\log(E(h))$，$x = \\log(h)$，截距为 $\\alpha = \\log(C)$。这条直线的斜率就是收敛阶 $p$。问题指定我们必须通过对一系列步长 $h_i$ 生成的数据点集 $(\\log(h_i), \\log(E(h_i)))$ 进行线性最小二乘回归来估计这个斜率 $p$。\n\n对于每个测试用例，总体算法如下：\n1.  定义 IVP 参数：函数 $f(t,y)$、初始时间 $t_0$、初始值 $y_0$、终止时间 $T$ 以及精确解 $y(t)$。\n2.  对于给定的步数列表 $\\{N_1, N_2, \\dots, N_m\\}$：\n    a. 对每个 $N_i$，计算步长 $h_i = (T - t_0) / N_i$。\n    b. 使用 Heun 法从 $t_0$ 到 $T$ 求解 IVP，步数为 $N_i$，以获得数值近似解 $y_{N_i}$。Heun 法的迭代公式为：\n    $$ y_{n+1} = y_n + \\frac{h}{2}\\left(f(t_n,y_n) + f\\!\\left(t_{n+1}, y_n + h f(t_n,y_n)\\right)\\right) $$\n    其中 $t_{n+1} = t_n + h$。此公式从 $(t_0, y_0)$ 开始，应用 $N_i$ 次。\n    c. 计算在最终时间 $T$ 处的真实解 $y(T)$。\n    d. 计算全局误差 $E(h_i) = |y_{N_i} - y(T)|$。\n    e. 存储点对 $(h_i, E(h_i))$。\n3.  生成 $m$ 个数据点 $\\{(h_i, E(h_i))\\}$ 的集合后，通过取对数将其转换为 $\\{(\\log(h_i), \\log(E(h_i)))\\}$。令 $x_i = \\log(h_i)$ 和 $y_i = \\log(E(h_i))$。\n4.  估计通过点 $(x_i, y_i)$ 的最佳拟合直线的斜率 $p$。对于一个简单的线性回归模型 $y = \\alpha + px$，使误差平方和 $\\sum_{i=1}^m (y_i - (\\alpha + px_i))^2$ 最小化的斜率 $p$ 由以下公式给出：\n$$ p = \\frac{\\sum_{i=1}^m (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i=1}^m (x_i - \\bar{x})^2} $$\n其中 $\\bar{x} = \\frac{1}{m}\\sum_{i=1}^m x_i$ 和 $\\bar{y} = \\frac{1}{m}\\sum_{i=1}^m y_i$ 分别是 $x$ 和 $y$ 数据的样本均值。此公式等价于计算 $x$ 和 $y$ 的协方差除以 $x$ 的方差。\n\n为所提供的四个测试用例均执行此过程。该实现使用 Python 及其 `numpy` 库。`numpy` 提供了必要的数学函数（例如 `exp`、`sin`、`cos`、`log`、`pi`）的实现，并方便了用于最小二乘计算的数组操作。程序创建了一个函数来实现 Heun 法，另一个函数用于计算最小二乘斜率。程序的主体部分遍历所有测试用例，为指定的步数计算误差，为每个案例估计收敛阶 $p$，并收集这些值作为最终输出。估计的 $p$ 值预期接近 2，从而证实 Heun 法对于这些光滑问题具有二阶精度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing Heun's method, calculating global errors,\n    and estimating the order of convergence for four different IVPs.\n    \"\"\"\n\n    def heun_solver(f, t0, y0, T, N):\n        \"\"\"\n        Solves an IVP y'(t) = f(t, y) using Heun's method.\n\n        Args:\n            f: The function f(t, y).\n            t0: Initial time.\n            y0: Initial value.\n            T: Final time.\n            N: Number of steps.\n\n        Returns:\n            The numerical approximation of y(T).\n        \"\"\"\n        h = (T - t0) / N\n        t = float(t0)\n        y = float(y0)\n        for _ in range(N):\n            k1 = f(t, y)\n            k2 = f(t + h, y + h * k1)\n            y = y + (h / 2.0) * (k1 + k2)\n            t = t + h\n        return y\n\n    def estimate_order(h_values, E_values):\n        \"\"\"\n        Estimates the order of convergence p from step sizes h and errors E.\n        This is done by finding the slope of the best-fit line for log(E) vs. log(h).\n\n        Args:\n            h_values: A numpy array of step sizes.\n            E_values: A numpy array of corresponding global errors.\n\n        Returns:\n            The estimated order of convergence p.\n        \"\"\"\n        # Take the natural logarithm of step sizes and errors\n        log_h = np.log(h_values)\n        log_E = np.log(E_values)\n        \n        # We want to find the slope p of the line y = alpha + p*x that best fits\n        # the data (x, y) = (log_h, log_E) in the least-squares sense.\n        # The formula for the slope is p = Cov(x, y) / Var(x).\n        x = log_h\n        y = log_E\n        x_mean = np.mean(x)\n        y_mean = np.mean(y)\n        \n        numerator = np.sum((x - x_mean) * (y - y_mean))\n        denominator = np.sum((x - x_mean)**2)\n        \n        p = numerator / denominator\n        return p\n\n    # Define the test suite from the problem statement.\n    test_cases = [\n        {\n            \"f\": lambda t, y: -y,\n            \"y_exact\": lambda t: np.exp(-t),\n            \"t0\": 0.0,\n            \"y0\": 1.0,\n            \"T\": 1.0,\n            \"N_values\": [10, 20, 40, 80]\n        },\n        {\n            \"f\": lambda t, y: y * np.cos(t),\n            \"y_exact\": lambda t: np.exp(np.sin(t)),\n            \"t0\": 0.0,\n            \"y0\": 1.0,\n            \"T\": np.pi,\n            \"N_values\": [20, 40, 80, 160]\n        },\n        {\n            \"f\": lambda t, y: y**2,\n            \"y_exact\": lambda t: 1.0 / (1.0 - t),\n            \"t0\": 0.0,\n            \"y0\": 1.0,\n            \"T\": 0.5,\n            \"N_values\": [20, 40, 80, 160]\n        },\n        {\n            \"f\": lambda t, y: np.sin(t),\n            \"y_exact\": lambda t: 1.0 - np.cos(t),\n            \"t0\": 0.0,\n            \"y0\": 0.0,\n            \"T\": 2.0,\n            \"N_values\": [20, 40, 80, 160]\n        }\n    ]\n\n    estimated_orders = []\n    \n    # Process each test case\n    for case in test_cases:\n        h_values = []\n        errors = []\n        \n        # Calculate the exact solution at the final time T once\n        y_exact_at_T = case[\"y_exact\"](case[\"T\"])\n        \n        # Run the simulation for each specified number of steps N\n        for N in case[\"N_values\"]:\n            t0, y0, T = case[\"t0\"], case[\"y0\"], case[\"T\"]\n            \n            # Calculate step size\n            h = (T - t0) / N\n            \n            # Get numerical solution using Heun's method\n            y_numerical_at_T = heun_solver(case[\"f\"], t0, y0, T, N)\n            \n            # Calculate global error\n            error = np.abs(y_numerical_at_T - y_exact_at_T)\n            \n            h_values.append(h)\n            errors.append(error)\n        \n        # Estimate the order of convergence p\n        p = estimate_order(np.array(h_values), np.array(errors))\n        estimated_orders.append(p)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, estimated_orders))}]\")\n\nsolve()\n```", "id": "3259641"}, {"introduction": "验证了霍恩方法的精度后，一个自然的问题是：它是否是解决问题的最佳工具？本实践 ([@problem_id:2428159]) 将霍恩方法（二阶）与经典的四阶龙格-库塔（RK4）方法进行效率对比。我们将探索每个方法为达到相同精度目标所需的总计算成本（函数求值次数），从而揭示高阶方法虽然每步计算更复杂，但对于高精度要求问题通常效率更高的重要思想。", "problem": "单变量初值问题 (Initial Value Problem, IVP) 由一个形如 $y^{\\prime}(t) = f(t,y(t))$ 的常微分方程 (Ordinary Differential Equation, ODE) 和一个初始条件 $y(t_{0}) = y_{0}$ 指定。其精确解 $y(t)$ 满足积分恒等式 $y(t_{n+1}) = y(t_{n}) + \\int_{t_{n}}^{t_{n+1}} f(\\tau,y(\\tau)) \\, d\\tau$。数值单步法在离散网格 $t_{n} = t_{0} + n h$上近似 $y(t)$，其中步长 $h = (T - t_{0})/N$ 为常数，并生成近似值 $y_{n} \\approx y(t_{n})$。在最终时间 $T$ 的全局误差定义为 $e_{\\mathrm{global}} = |y_{N} - y(T)|$。\n\n你的任务是实现并比较两种用于求解 IVP 的时间积分方法的效率：\n- 通常称为 Heun 方法的显式预测-校正格式。\n- 经典的四阶龙格-库塔方法（Fourth-Order Runge–Kutta, RK4）。\n\n效率必须根据在最终时间 $T$ 达到目标全局误差容限 $\\varepsilon$ 所需的右端函数 $f(t,y)$ 的总求值次数来衡量，其中使用均匀时间步长。对于每种方法，确定最小步数 $N$ 使得 $e_{\\mathrm{global}} \\le \\varepsilon$。然后，计算总函数求值次数，对于 Heun 方法为 $2N$，对于 RK4 方法为 $4N$。\n\n你必须：\n1. 为标量 IVP 实现这两种使用恒定步长的方法。\n2. 对每种方法，通过以下方式找到满足 $e_{\\mathrm{global}} \\le \\varepsilon$ 的最小 $N$：\n   - 从 $N = 1$（因此 $h = (T - t_{0})/N$）开始，重复将 $N$ 加倍，直到不等式成立。\n   - 然后，在最后一个不满足条件的 $N$ 和第一个满足条件的 $N$ 之间执行整数二分搜索，以找到满足 $e_{\\mathrm{global}} \\le \\varepsilon$ 的最小 $N$。\n   - 如果在安全上限 $N_{\\max}$ 内没有 $N$ 满足容限，你必须报告失败。使用 $N_{\\max} = 2^{20}$。\n3. 对每个测试案例，计算效率比 $R = \\dfrac{\\text{Heun 方法的函数求值次数}}{\\text{RK4 方法的函数求值次数}}$，结果四舍五入到 $3$ 位小数。\n\n使用以下带有精确解的测试套件。在所有情况下，使用 $t_{0} = 0$，状态变量是无量纲的。对于三角函数，使用弧度。\n\n- 测试 A (指数衰减): $f(t,y) = -2 y$, $y(0) = 1$, 精确解 $y(t) = e^{-2 t}$, $T = 1$, $\\varepsilon = 10^{-6}$。\n- 测试 B (指数增长): $f(t,y) = y$, $y(0) = 1$, 精确解 $y(t) = e^{t}$, $T = 1$, $\\varepsilon = 10^{-6}$。\n- 测试 C (受力线性): $f(t,y) = \\cos(t) - y$, $y(0) = 1$, 精确解 $y(t) = \\dfrac{1}{2}\\left(\\sin t + \\cos t + e^{-t}\\right)$, $T = 10$, $\\varepsilon = 10^{-5}$。\n- 测试 D (逻辑斯谛): $f(t,y) = y\\,(1 - y)$, $y(0) = 0.1$, 精确解 $y(t) = \\dfrac{1}{1 + 9 e^{-t}}$, $T = 5$, $\\varepsilon = 10^{-6}$。\n\n最终输出规格：\n- 对于每个测试案例，输出效率比 $R$，为一个四舍五入到 $3$ 位小数的浮点数。\n- 你的程序应产生单行输出，包含一个用逗号分隔并用方括号括起来的结果列表（例如，$[r_{A},r_{B},r_{C},r_{D}]$）。\n\n没有物理单位，因此不需要单位转换。角度（如果存在）以弧度为单位。", "solution": "该问题要求对两种求解一阶常微分方程 (ODE) 的数值格式——Heun 方法和经典的四阶龙格-库塔 (RK4) 方法——的计算效率进行定量比较。效率定义为在最终时间 $T$ 达到预定的全局误差容限 $\\varepsilon$ 所需的右端函数 $f(t,y)$ 的总求值次数。这是一个计算科学中的标准问题，旨在说明方法的复杂度（以每步的函数求值次数衡量）与其精度（以其收敛阶表征）之间的权衡。\n\n我们考虑由 $y'(t) = f(t,y(t))$ 及其初始条件 $y(t_0)=y_0$ 在时间区间 $[t_0, T]$ 上给出的初值问题 (IVP)。数值解在均匀网格 $t_n = t_0 + n h$（其中 $n \\in \\{0, 1, \\dots, N\\}$）上计算，步长 $h = (T - t_0)/N$ 为常数。在最终时间 $T$ 的全局误差定义为 $e_{\\mathrm{global}} = |y_N - y(T)|$，其中 $y_N$ 是数值近似解，$y(T)$ 是精确解。\n\nHeun 方法是一种二阶预测-校正格式。对于从 $t_n$ 到 $t_{n+1}$ 的每一步，它包含两个阶段：\n1.  **预测 (Predictor)：** 一个显式欧拉步为下一个时间点的解提供一个一阶精确的猜测值：$\\tilde{y}_{n+1} = y_n + h f(t_n, y_n)$。\n2.  **校正 (Corrector)：** 这个初步结果被用来评估区间末端的斜率 $f(t_{n+1}, \\tilde{y}_{n+1})$。最终的更新值使用步长起点和预测终点的斜率平均值来计算，这在几何上等价于应用梯形积分法则：$y_{n+1} = y_n + \\frac{h}{2} [f(t_n, y_n) + f(t_{n+1}, \\tilde{y}_{n+1})]$。\n该方法每个时间步恰好执行 $2$ 次函数求值。其全局误差为 $2$ 阶，即 $e_{\\mathrm{global}} = O(h^2)$。\n\n经典的四阶龙格-库塔 (RK4) 方法是一种更复杂的单步法，它通过在每步内使用四个斜率评估的加权平均来获得更高的精度。从 $y_n$ 到 $y_{n+1}$ 的更新规则如下：\n$$y_{n+1} = y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)$$\n其中中间斜率的计算方式如下：\n$$k_1 = f(t_n, y_n)$$\n$$k_2 = f\\left(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_1\\right)$$\n$$k_3 = f\\left(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_2\\right)$$\n$$k_4 = f(t_n + h, y_n + h k_3)$$\n该方法每个时间步需要恰好 $4$ 次函数求值。其全局误差为 $4$ 阶，因此 $e_{\\mathrm{global}} = O(h^4)$。\n\n为了确定每种方法的效率，我们必须找到满足全局误差条件 $|y_N - y(T)| \\le \\varepsilon$ 的最小步数 $N$。问题为此指定了一个两阶段搜索算法。\n1.  **阶段 1：指数搜索。** 我们从 $N=1$ 开始，并重复将 $N$ 加倍（即 $N=1, 2, 4, 8, \\dots$），直到找到一个值（记为 $N_{\\mathrm{pass}}$）使得误差容限得到满足。前一次迭代中 $N$ 的值 $N_{\\mathrm{fail}}$ 也被记录下来。此过程可以高效地确定一个区间 $[N_{\\mathrm{fail}}, N_{\\mathrm{pass}}]$，该区间保证包含所需的最小 $N$。如果对于任何 $N$ 直到最大值 $N_{\\max} = 2^{20}$ 都无法满足容限，则搜索被视为失败。\n2.  **阶段 2：二分搜索。** 接着在由上一个失败和第一个成功的步数构成的区间内执行标准的整数二分搜索，以精确定位使全局误差不大于 $\\varepsilon$ 的最小整数 $N_{\\min}$。\n\n对于一个 $p$ 阶方法，其全局误差的理论行为是 $e_{\\mathrm{global}} \\approx C h^p = C \\left(\\frac{T-t_0}{N}\\right)^p$，其中 $C$ 是一个取决于 ODE、其导数以及具体方法的常数。为了满足容限 $\\varepsilon$，我们需要 $C \\left(\\frac{T-t_0}{N}\\right)^p \\le \\varepsilon$，这意味着步数必须满足 $N \\ge (T-t_0) \\left(\\frac{C}{\\varepsilon}\\right)^{1/p}$ 的缩放关系。\n对于 Heun 方法 ($p=2$)，函数求值总次数为 $E_{\\mathrm{Heun}} = 2 N_{\\mathrm{Heun}} \\propto \\varepsilon^{-1/2}$。\n对于 RK4 方法 ($p=4$)，函数求值总次数为 $E_{\\mathrm{RK4}} = 4 N_{\\mathrm{RK4}} \\propto \\varepsilon^{-1/4}$。\n因此，效率比为 $R = \\frac{E_{\\mathrm{Heun}}}{E_{\\mathrm{RK4}}} \\propto \\frac{\\varepsilon^{-1/2}}{\\varepsilon^{-1/4}} = \\varepsilon^{-1/4}$。这一关系表明，对于较小的 $\\varepsilon$，比率 $R$ 预计将显著大于 $1$。这揭示了尽管高阶 RK4 方法每步的计算成本更高，但在达到高精度要求时，其效率更优。$R$ 的确切值取决于体现在 $C$ 中的特定于问题的常数，这些常数通过为每个测试案例执行指定算法来数值确定。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem, implementing and comparing Heun's and RK4 methods.\n    \"\"\"\n\n    def heun_solver(f, y0, t0, T, N):\n        \"\"\"\n        Solves a scalar IVP y'=f(t,y) using Heun's method with a constant step size.\n        \"\"\"\n        h = (T - t0) / N\n        t = t0\n        y = y0\n        for _ in range(N):\n            # Predictor step\n            f1 = f(t, y)\n            y_tilde = y + h * f1\n            # Corrector step\n            t_next = t + h\n            f2 = f(t_next, y_tilde)\n            y = y + (h / 2.0) * (f1 + f2)\n            t = t_next\n        return y\n\n    def rk4_solver(f, y0, t0, T, N):\n        \"\"\"\n        Solves a scalar IVP y'=f(t,y) using the classical RK4 method with a constant step size.\n        \"\"\"\n        h = (T - t0) / N\n        t = t0\n        y = y0\n        for _ in range(N):\n            k1 = f(t, y)\n            k2 = f(t + h / 2.0, y + h * k1 / 2.0)\n            k3 = f(t + h / 2.0, y + h * k2 / 2.0)\n            k4 = f(t + h, y + h * k3)\n            y = y + (h / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n            t += h\n        return y\n\n    def find_min_N(solver, f, y0, t0, T, y_exact_T, tol, N_max):\n        \"\"\"\n        Finds the minimum number of steps N for a given solver to achieve the desired tolerance.\n        \"\"\"\n        \n        # Helper function to compute error for a given N\n        def get_error(num_steps):\n            y_approx = solver(f, y0, t0, T, num_steps)\n            return np.abs(y_approx - y_exact_T)\n\n        # First, check if N=1 is sufficient\n        if get_error(1) = tol:\n            return 1\n            \n        # Exponential search to find the bracketing interval for N\n        n_fail = 1\n        n_pass = 2\n        while n_pass = N_max:\n            if get_error(n_pass) = tol:\n                break\n            n_fail = n_pass\n            n_pass *= 2\n        else:\n            # This 'else' belongs to the 'while' loop, executed if the loop finishes without a break.\n            return -1 # Indicates failure to meet tolerance within N_max\n\n        # Binary search to find the minimal N\n        low = n_fail + 1\n        high = n_pass\n        min_N = n_pass\n\n        while low = high:\n            mid = low + (high - low) // 2\n            if mid == 0:  # Safety check, should not be reached with low starting  0\n                low = 1\n                continue\n                \n            if get_error(mid) = tol:\n                min_N = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n        \n        return min_N\n\n    # Test cases as defined in the problem statement.\n    test_cases = [\n        # Test A (exponential decay)\n        {\n            \"f\": lambda t, y: -2.0 * y, \"y0\": 1.0, \"t0\": 0.0, \"T\": 1.0,\n            \"y_exact_func\": lambda t: np.exp(-2.0 * t), \"tol\": 1e-6, \"name\": \"A\"\n        },\n        # Test B (exponential growth)\n        {\n            \"f\": lambda t, y: y, \"y0\": 1.0, \"t0\": 0.0, \"T\": 1.0,\n            \"y_exact_func\": lambda t: np.exp(t), \"tol\": 1e-6, \"name\": \"B\"\n        },\n        # Test C (forced linear)\n        {\n            \"f\": lambda t, y: np.cos(t) - y, \"y0\": 1.0, \"t0\": 0.0, \"T\": 10.0,\n            \"y_exact_func\": lambda t: 0.5 * (np.sin(t) + np.cos(t) + np.exp(-t)), \"tol\": 1e-5, \"name\": \"C\"\n        },\n        # Test D (logistic)\n        {\n            \"f\": lambda t, y: y * (1.0 - y), \"y0\": 0.1, \"t0\": 0.0, \"T\": 5.0,\n            \"y_exact_func\": lambda t: 1.0 / (1.0 + 9.0 * np.exp(-t)), \"tol\": 1e-6, \"name\": \"D\"\n        }\n    ]\n\n    N_max = 2**20\n    results = []\n\n    for case in test_cases:\n        f = case[\"f\"]\n        y0 = case[\"y0\"]\n        t0 = case[\"t0\"]\n        T = case[\"T\"]\n        y_exact_func = case[\"y_exact_func\"]\n        tol = case[\"tol\"]\n        \n        y_exact_T = y_exact_func(T)\n\n        # Find minimal N for Heun's method\n        N_heun = find_min_N(heun_solver, f, y0, t0, T, y_exact_T, tol, N_max)\n        if N_heun == -1:\n            raise RuntimeError(f\"Heun's method failed to converge for case {case['name']}\")\n        evals_heun = 2 * N_heun\n\n        # Find minimal N for RK4 method\n        N_rk4 = find_min_N(rk4_solver, f, y0, t0, T, y_exact_T, tol, N_max)\n        if N_rk4 == -1:\n            raise RuntimeError(f\"RK4 method failed to converge for case {case['name']}\")\n        evals_rk4 = 4 * N_rk4\n\n        # Calculate and round the efficiency ratio\n        ratio = evals_heun / evals_rk4\n        results.append(round(ratio, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2428159"}, {"introduction": "一个优秀的工程师不仅知道工具如何工作，更了解其失效的边界。本实践 ([@problem_id:2428217]) 将探讨一个特殊情况：当常微分方程的精确解在有限时间内“爆破”（趋于无穷大）时，霍恩方法的表现。通过观察数值解在奇点附近的行为，我们将学习到盲目应用数值格式的风险，并理解在进行数值模拟前分析问题数学特性的重要性。", "problem": "考虑由常微分方程 $y' = y^2$ 和初始条件 $y(0) = y_0$（其中 $y_0  0$）定义的初值问题。通过预测-校正更新定义数值单步法\n$$\ny^\\ast = y_n + h\\,f(t_n,y_n), \\quad y_{n+1} = y_n + \\frac{h}{2}\\big(f(t_n,y_n) + f(t_n + h, y^\\ast)\\big),\n$$\n其中 $f(t,y) = y^2$，均匀时间步长 $h  0$，且 $t_{n+1} = t_n + h$。该方法从 $t_0 = 0$，$y_0$ 开始应用，并重复所需的步数。令 $t_s$ 表示该初值问题精确解的（有限）爆破时间。\n\n您的任务是实现一个程序，对于每个指定的测试用例 $(y_0, T, h)$，生成下列输出之一，形式为一个包含两个实数的列表：\n- 如果 $T  t_s$ 且 $T$ 是 $h$ 的整数倍，则精确执行 $N = T/h$ 步该方法来计算在 $t_N = T$ 时的 $y_N$，并输出双元素列表 $[y_N,\\; |y_N - y_{\\text{exact}}(T)|]$，其中 $y_{\\text{exact}}(T)$ 是从该初值问题得到的在时间 $T$ 的精确解。\n- 如果 $T \\ge t_s$，不要尝试在 $t_s$ 或超过 $t_s$ 的时间点进行积分。而是积分到严格小于 $t_s$ 的最后一个时间点 $t_{\\text{last}} = n h$（即，满足 $n h  t_s$ 的最大非负整数 $n \\in \\mathbb{Z}_{\\ge 0}$），并输出双元素列表 $[t_{\\text{last}},\\; y_{\\text{last}}]$，其中 $y_{\\text{last}}$ 是该方法在 $t_{\\text{last}}$ 处产生的数值。\n\n不涉及角度。不涉及物理单位。所有数值答案均为实数。不允许在网格点之间进行插值。\n\n使用以下参数测试套件，每个参数以三元组 $(y_0, T, h)$ 的形式给出：\n1. $(1.0,\\; 0.9,\\; 0.1)$\n2. $(1.0,\\; 0.99,\\; 0.01)$\n3. $(1.0,\\; 1.1,\\; 0.05)$\n4. $(2.0,\\; 0.49,\\; 0.07)$\n5. $(0.5,\\; 2.1,\\; 0.4)$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为按测试套件顺序排列的结果。此外层列表的每个元素本身都必须是如上定义的双元素列表。例如，输出格式必须类似于\n$[[a_1,b_1],[a_2,b_2],\\dots,[a_5,b_5]]$\n，其中每个 $a_i$ 和 $b_i$ 均为实数。", "solution": "任务是求解由常微分方程 $y' = f(t,y) = y^2$ 和初始条件 $y(0) = y_0$（其中 $y_0  0$）给出的初值问题（IVP）。解将使用指定的预测-校正方法进行数值求解，具体过程取决于目标时间 $T$ 与精确解的有限爆破时间 $t_s$ 之间的关系。\n\n首先，我们求该初值问题的精确解。该方程是可分离的：\n$$\n\\frac{dy}{dt} = y^2 \\implies \\frac{dy}{y^2} = dt\n$$\n将两边从初始状态 $(0, y_0)$ 积分到一般状态 $(t, y(t))$，得到：\n$$\n\\int_{y_0}^{y(t)} \\frac{d\\tilde{y}}{\\tilde{y}^2} = \\int_0^t d\\tilde{t} \\implies \\left[-\\frac{1}{\\tilde{y}}\\right]_{y_0}^{y(t)} = [\\tilde{t}]_0^t\n$$\n$$\n-\\frac{1}{y(t)} + \\frac{1}{y_0} = t \\implies \\frac{1}{y(t)} = \\frac{1}{y_0} - t = \\frac{1 - t y_0}{y_0}\n$$\n因此，精确解为：\n$$\ny_{\\text{exact}}(t) = \\frac{y_0}{1 - t y_0}\n$$\n该解表现出有限时间爆破，意味着它在一个有限时间 $t_s$ 趋于无穷大。这发生在解的分母为零时：\n$$\n1 - t_s y_0 = 0 \\implies t_s = \\frac{1}{y_0}\n$$\n由于 $y_0  0$，爆破时间 $t_s$ 是正的有限值。\n\n指定的数值方法是Heun法，一种二阶预测-校正格式。对于函数 $f(t,y) = y^2$，从时间 $t_n$到 $t_{n+1} = t_n + h$ 的更新由以下公式给出：\n预测步：\n$$\ny^\\ast = y_n + h f(t_n, y_n) = y_n + h y_n^2\n$$\n校正步：\n$$\ny_{n+1} = y_n + \\frac{h}{2} \\left( f(t_n, y_n) + f(t_{n+1}, y^\\ast) \\right) = y_n + \\frac{h}{2} \\left( y_n^2 + (y^\\ast)^2 \\right)\n$$\n将预测步的表达式代入校正步，得到完整的单步公式：\n$$\ny_{n+1} = y_n + \\frac{h}{2} \\left( y_n^2 + \\left(y_n + h y_n^2\\right)^2 \\right)\n$$\n\n问题根据参数 $(y_0, T, h)$ 定义了两种不同的处理流程：\n\n情况1：$T  t_s$。问题指明，对于这些情况，$T$ 是步长 $h$ 的整数倍。我们必须执行 $N = T/h$ 步数值方法。从 $t_0 = 0$ 时的 $y_0$ 开始，该格式被迭代应用 $N$ 次，以求得在最终时间 $t_N = T$ 时的数值近似解 $y_N$。要求的输出是包含数值解及其与精确解的绝对误差的双元素列表：$[y_N, |y_N - y_{\\text{exact}}(T)|]$。\n\n情况2：$T \\ge t_s$。在这种情况下，数值积分不得进行到或超过爆破时间 $t_s$。我们必须积分到严格小于 $t_s$ 的最后一个可能的时间步 $t_{\\text{last}} = n h$。这对应于找到满足 $n h  t_s$ 的最大非负整数 $n$。该方法被应用 $n$ 次，以获得在时间 $t_{\\text{last}} = t_n$ 时的数值 $y_{\\text{last}} = y_n$。要求的输出是双元素列表 $[t_{\\text{last}}, y_{\\text{last}}]$。如果第一个时间步 $h$ 已经大于或等于 $t_s$（即 $h \\ge t_s$），那么最大的此类 $n$ 为 $0$，从而得到 $t_{\\text{last}}=0$ 和 $y_{\\text{last}}=y_0$。\n\n该算法的实现首先是为每个测试用例计算 $t_s=1/y_0$。然后，根据 $T$ 和 $t_s$ 的比较，遵循适当的计算路径。对于情况1，执行一个固定循环 $N=T/h$ 次迭代。对于情况2，只要下一个时间步严格小于 $t_s$，就执行循环。每个测试用例的结果被收集到一个列表中，然后格式化为最终所需的输出字符串。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the given initial value problem for a suite of test cases\n    using Heun's predictor-corrector method.\n    \"\"\"\n    test_cases = [\n        (1.0, 0.9, 0.1),\n        (1.0, 0.99, 0.01),\n        (1.0, 1.1, 0.05),\n        (2.0, 0.49, 0.07),\n        (0.5, 2.1, 0.4)\n    ]\n\n    results = []\n    for y0, T, h in test_cases:\n        results.append(compute_one_case(y0, T, h))\n\n    # Format the output as a string representation of a list of lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_one_case(y0, T, h):\n    \"\"\"\n    Computes the solution for a single test case (y0, T, h).\n    \"\"\"\n    # Define the ODE function f(y) = y^2\n    f = lambda y: y**2\n\n    # Calculate the exact blow-up time\n    ts = 1.0 / y0\n\n    # Case 1: Target time T is before the blow-up time ts.\n    if T  ts:\n        # The problem guarantees T is an integer multiple of h for this case.\n        # Use round() to robustly handle potential floating-point inaccuracies.\n        num_steps = int(round(T / h))\n        \n        y_n = y0\n        for _ in range(num_steps):\n            # Predictor step\n            y_star = y_n + h * f(y_n)\n            # Corrector step\n            y_n = y_n + (h / 2.0) * (f(y_n) + f(y_star))\n        \n        y_N = y_n\n        \n        # Calculate exact solution and absolute error\n        y_exact_T = y0 / (1.0 - T * y0)\n        error = np.abs(y_N - y_exact_T)\n        \n        return [y_N, error]\n        \n    # Case 2: Target time T is at or after the blow-up time ts.\n    else:\n        y_n = y0\n        t_n = 0.0\n        \n        # We need to find the result at the last time step strictly before ts.\n        # Initialize last valid results with the initial conditions.\n        t_last = t_n\n        y_last = y_n\n        \n        while True:\n            t_next = t_n + h\n            # Stop if the next time step is not strictly less than ts\n            if t_next = ts:\n                break\n            \n            # Perform one step of Heun's method\n            y_star = y_n + h * f(y_n)\n            y_n = y_n + (h / 2.0) * (f(y_n) + f(y_star))\n            t_n = t_next\n            \n            # Update the last valid results\n            t_last = t_n\n            y_last = y_n\n            \n        return [t_last, y_last]\n\nsolve()\n```", "id": "2428217"}]}