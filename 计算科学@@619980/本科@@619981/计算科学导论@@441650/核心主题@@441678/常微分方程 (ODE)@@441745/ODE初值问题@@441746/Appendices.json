{"hands_on_practices": [{"introduction": "数值求解常微分方程（ODE）意味着需要从众多方法中做出选择，而不同方法在实现复杂度、计算成本和精度之间存在权衡。本练习将引导你实现并比较两种经典的四阶方法：泰勒级数法和四阶龙格-库塔（$RK4$）法。通过这个过程，你将深入理解数值格式是如何构建与评估的，并体会到精度和效率之间的权衡。[@problem_id:3282712]", "problem": "实现一个独立的程序，该程序针对由常微分方程 (ODE) $$\\frac{dy}{dt} = \\cos(t) + y,$$ 和初始条件 $$y(0) = 1,$$ 定义的初值问题 (IVP)，在一个固定的时间区间内，构建并比较两种单步数值方法。这两种方法是：\n- 一种 4 阶泰勒级数方法，通过计算 $$y_{n+1} = y_n + h\\,y^{(1)}(t_n) + \\frac{h^2}{2!}\\,y^{(2)}(t_n) + \\frac{h^3}{3!}\\,y^{(3)}(t_n) + \\frac{h^4}{4!}\\,y^{(4)}(t_n),$$ 从 $t_n$ 推进到 $t_{n+1}=t_n+h$。其中 $y^{(k)}(t)$ 表示 $y(t)$ 在 $t=t_n$ 处求值的 $k$ 阶全时间导数。您必须仅使用基本法则来获得 $k=1,2,3,4$ 时的 $y^{(k)}(t)$：链式法则和恒等式 $$\\frac{d}{dt}g(t,y(t)) = \\frac{\\partial g}{\\partial t}(t,y) + \\frac{\\partial g}{\\partial y}(t,y)\\,\\frac{dy}{dt},$$ 并应用于 $$g(t,y)=\\cos(t)+y.$$ 不要使用任何预先推导的快捷公式；在步进过程中，符号化地计算所需的导数，然后在 $(t_n,y_n)$ 处进行数值求值。\n- 应用于相同右端项的经典的 4 阶显式龙格－库塔方法（常称为 RK4）。\n\n两种方法都必须使用统一的步长 $h$ 从 $t=0$ 积分到 $t=T$，其中 $T$ 和 $h$ 将由测试组指定。角度必须以弧度为单位。\n\n使用通过解析求解线性 ODE 推导出的、有科学依据的参考解。从线性一阶 ODE 的积分因子定义出发，通过使用积分因子法求解 $$\\frac{dy}{dt} - y = \\cos(t)$$ 得到的精确解具有 $$y(t) = \\text{一个关于 }t\\text{ 的函数}$$ 的形式。您的程序必须实现这个精确解，并用它来计算每种数值方法在不同步长 $h$ 下于 $t=T$ 时的绝对误差。\n\n为了比较计算成本，将成本定义为在数值积分器内执行的三角函数求值的总次数。具体来说，在数值方法内部，每次对 $\\cos(\\cdot)$ 或 $\\sin(\\cdot)$ 的求值计为 1 个单位的成本；为此成本模型之目的，所有其他操作均不计成本。您必须对您的实现进行插桩（instrument），以便为泰勒方法和 RK4 分别精确地测量这些计数。精确解的求值不得计入成本。\n\n测试组：\n- 固定终止时间：$T=2$。\n- 初始条件：$y(0)=1$。\n- 要测试的步长 $h$：$h\\in\\{2.0,\\,1.0,\\,0.5,\\,0.2,\\,0.1,\\,0.05\\}$。对于每个 $h$，精确执行 $N=T/h$ 步（选择这些 $h$ 值是为了使 $N$ 为整数）。\n- 角度单位：弧度。\n\n对于测试组中的每个 $h$ 值，使用相同的 $h$ 运行两种方法，并计算：\n- 4 阶泰勒方法在 $t=T$ 时的绝对误差，记为 $E_{\\mathrm{T4}}(h) = \\lvert y_{\\mathrm{T4}}(T;h) - y_{\\mathrm{exact}}(T)\\rvert$。\n- RK4 在 $t=T$ 时的绝对误差，记为 $E_{\\mathrm{RK4}}(h) = \\lvert y_{\\mathrm{RK4}}(T;h) - y_{\\mathrm{exact}}(T)\\rvert$。\n- 泰勒方法使用的三角函数求值次数，记为 $C_{\\mathrm{T4}}(h)$。\n- RK4 使用的三角函数求值次数，记为 $C_{\\mathrm{RK4}}(h)$。\n\n您的程序应生成单行输出，其中包含所有测试用例的聚合结果，形成一个扁平化列表，并严格按照每个步长 $h$ 的以下顺序排列：\n$$[E_{\\mathrm{T4}}(2.0),\\,E_{\\mathrm{RK4}}(2.0),\\,C_{\\mathrm{T4}}(2.0),\\,C_{\\mathrm{RK4}}(2.0),\\,E_{\\mathrm{T4}}(1.0),\\,E_{\\mathrm{RK4}}(1.0),\\,C_{\\mathrm{T4}}(1.0),\\,C_{\\mathrm{RK4}}(1.0),\\,E_{\\mathrm{T4}}(0.5),\\,E_{\\mathrm{RK4}}(0.5),\\,C_{\\mathrm{T4}}(0.5),\\,C_{\\mathrm{RK4}}(0.5),\\,E_{\\mathrm{T4}}(0.2),\\,E_{\\mathrm{RK4}}(0.2),\\,C_{\\mathrm{T4}}(0.2),\\,C_{\\mathrm{RK4}}(0.2),\\,E_{\\mathrm{T4}}(0.1),\\,E_{\\mathrm{RK4}}(0.1),\\,C_{\\mathrm{T4}}(0.1),\\,C_{\\mathrm{RK4}}(0.1),\\,E_{\\mathrm{T4}}(0.05),\\,E_{\\mathrm{RK4}}(0.05),\\,C_{\\mathrm{T4}}(0.05),\\,C_{\\mathrm{RK4}}(0.05)].$$\n\n程序必须精确输出一行，格式化为由方括号括起来的逗号分隔列表，其中的值按上述顺序排列。所有数值答案均为标量（误差为浮点数，计数为整数）。在整个过程中，角度必须以弧度为单位，除角度单位外，此处不适用任何物理单位。", "solution": "我们从初值问题 (IVP) $$\\frac{dy}{dt} = f(t,y),\\quad y(0)=y_0,$$ 开始，其中 $$f(t,y) = \\cos(t)+y.$$ 在步长为 $h$、围绕 $(t_n,y_n)$ 的 4 阶泰勒级数单步法定义为 $$y_{n+1} = y_n + \\sum_{k=1}^{4} \\frac{h^k}{k!} y^{(k)}(t_n),$$ 其中 $y^{(k)}(t)$ 表示 $y(t)$ 的 $k$ 阶全时间导数，即 $$y^{(1)}(t) = \\frac{dy}{dt}(t),\\quad y^{(2)}(t) = \\frac{d^2 y}{dt^2}(t),\\quad \\ldots.$$ 为计算一个通用右端项 $f(t,y)$ 的这些导数，我们使用全导数算子形式的链式法则 $$\\frac{d}{dt} g(t,y(t)) = \\frac{\\partial g}{\\partial t}(t,y) + \\frac{\\partial g}{\\partial y}(t,y)\\,\\frac{dy}{dt}(t) = g_t(t,y) + g_y(t,y)\\,f(t,y).$$ 将此应用于我们特定的 $f(t,y)=\\cos(t)+y$，可以逐步得到在 $(t,y)$ 处求值的导数表达式。\n\n一阶导数： $$y^{(1)} = f(t,y) = \\cos(t) + y.$$\n\n二阶导数： $$y^{(2)} = \\frac{d}{dt}y^{(1)} = \\frac{d}{dt} f(t,y) = f_t(t,y) + f_y(t,y)\\,f(t,y).$$ 对于 $f(t,y)=\\cos(t)+y$，我们有 $$f_t(t,y) = -\\sin(t),\\quad f_y(t,y)=1,$$ 因此 $$y^{(2)} = -\\sin(t) + \\left(\\cos(t)+y\\right).$$\n\n三阶导数： $$y^{(3)} = \\frac{d}{dt} y^{(2)} = \\frac{d}{dt}\\left(-\\sin(t) + \\cos(t) + y\\right) = -\\cos(t) - \\sin(t) + y^{(1)}.$$ 代入 $y^{(1)} = \\cos(t)+y$ 得到 $$y^{(3)} = -\\sin(t) + y.$$\n\n四阶导数： $$y^{(4)} = \\frac{d}{dt} y^{(3)} = \\frac{d}{dt}\\left(-\\sin(t) + y\\right) = -\\cos(t) + y^{(1)}.$$ 代入 $y^{(1)} = \\cos(t)+y$ 得到 $$y^{(4)} = y.$$\n\n这些表达式使得仅通过在当前时间和当前值 $y$ 处对 $\\sin(t)$ 和 $\\cos(t)$ 进行求值，即可高效实现 4 阶泰勒方法。\n\n对于经典的 4 阶显式龙格－库塔方法 (RK4)，在步长为 $h$ 时，我们定义阶段值 $$k_1 = f(t_n,y_n),$$ $$k_2 = f\\!\\left(t_n+\\frac{h}{2}, y_n + \\frac{h}{2}k_1\\right),$$ $$k_3 = f\\!\\left(t_n+\\frac{h}{2}, y_n + \\frac{h}{2}k_2\\right),$$ $$k_4 = f(t_n+h, y_n + hk_3),$$ 并通过 $$y_{n+1} = y_n + \\frac{h}{6}\\left(k_1 + 2k_2 + 2k_3 + k_4\\right)$$ 进行推进。\n\n接下来，我们推导用作参考的精确解。ODE $$\\frac{dy}{dt} - y = \\cos(t)$$ 是线性的。使用积分因子，标准方法是两边乘以 $e^{-t}$ 以得到 $$\\frac{d}{dt}\\left(e^{-t} y\\right) = e^{-t}\\cos(t).$$ 积分 $$\\int e^{-t}\\cos(t)\\,dt$$ 是一种众所周知的形式，其结果为 $$\\int e^{-t}\\cos(t)\\,dt = \\frac{e^{-t}}{2}\\left(-\\cos(t) + \\sin(t)\\right) + C.$$ 因此， $$e^{-t} y(t) = \\frac{e^{-t}}{2}\\left(-\\cos(t) + \\sin(t)\\right) + C,$$ 并且两边乘以 $e^{t}$ 得到 $$y(t) = \\frac{-\\cos(t) + \\sin(t)}{2} + C e^{t}.$$ 应用初始条件 $y(0)=1$ 可得 $$1 = \\frac{-\\cos(0) + \\sin(0)}{2} + C = \\frac{-1+0}{2} + C \\implies C = \\frac{3}{2}.$$ 因此，精确解为 $$y_{\\mathrm{exact}}(t) = \\frac{-\\cos(t) + \\sin(t)}{2} + \\frac{3}{2} e^{t}.$$\n\n成本模型：我们将计算成本定义为在数值积分器内部执行的三角函数求值的次数。具体来说，在数值积分过程中，每次调用 $\\cos(\\cdot)$ 或 $\\sin(\\cdot)$ 都计为 1 个单位的成本。在这里，对于泰勒方法，每步使用一次 $\\cos(t_n)$ 和 $\\sin(t_n)$，因此每步的理论成本为 2。在这里，对于 RK4，每步在四个不同的阶段时间点上使用 $\\cos(\\cdot)$，因此每步的理论成本为 4。我们对代码进行插桩以直接测量计数，确保只计算积分器中的三角函数调用；精确解的求值不计入此计数。\n\n精度预期：两种方法都是 4 阶的，因此对于足够小的 $h$，在 $t=T$ 时的全局截断误差应按 $\\mathcal{O}(h^4)$ 的阶数缩放。两种方法的常数不同，因此对于相同的 $h$，它们的实际误差不会相同，而且此处的泰勒方法受益于每一步的精确局部导数。\n\n算法结构：\n- 实现一个三角函数包装器，为每种方法和每个测试用例分别对 $\\cos(\\cdot)$ 和 $\\sin(\\cdot)$ 的调用进行计数。\n- 使用链式法则和推导出的 $y^{(k)}(t)$ 来实现泰勒-4 步：在 $(t_n,y_n)$ 处计算 $y^{(1)}$, $y^{(2)}$, $y^{(3)}$, $y^{(4)}$，然后使用直到 4 阶的泰勒多项式进行推进。\n- 在标准节点上，通过对 $f(t,y)=\\cos(t)+y$ 进行阶段求值来实现 RK4。\n- 对于测试组中的每个步长 $h$，执行 $N=T/h$ 步以达到 $t=T$，计算两种方法相对于 $y_{\\mathrm{exact}}(T)$ 的绝对误差，并记录三角函数计数。\n- 以指定顺序输出一个扁平化的列表：对于 $\\{2.0,1.0,0.5,0.2,0.1,0.05\\}$ 中的每个 $h$，依次附加 $E_{\\mathrm{T4}}(h)$、$E_{\\mathrm{RK4}}(h)$、$C_{\\mathrm{T4}}(h)$ 和 $C_{\\mathrm{RK4}}(h)$。\n\n这种有原则的构建方法遵循了全导数和通过积分因子求解线性 ODE 的基本定义，并对指定的 IVP 上的两种四阶方法的准确性和成本得出了清晰、可测试的比较。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass TrigCounter:\n    \"\"\"\n    Wrapper to count trigonometric function evaluations (cos and sin).\n    \"\"\"\n    def __init__(self):\n        self.cos_calls = 0\n        self.sin_calls = 0\n\n    def cos(self, x):\n        self.cos_calls += 1\n        return float(np.cos(x))\n\n    def sin(self, x):\n        self.sin_calls += 1\n        return float(np.sin(x))\n\n    @property\n    def total_trig_calls(self):\n        return self.cos_calls + self.sin_calls\n\ndef exact_solution(t):\n    # y(t) = (-cos t + sin t)/2 + (3/2) e^t\n    return (-np.cos(t) + np.sin(t)) / 2.0 + 1.5 * np.exp(t)\n\ndef f_rhs(t, y, trig: TrigCounter):\n    # f(t, y) = cos(t) + y; counts only cos in this RHS\n    return trig.cos(t) + y\n\ndef taylor4_step(t, y, h, trig: TrigCounter):\n    \"\"\"\n    One step of the fourth-order Taylor method for y' = cos(t) + y.\n    Uses derivatives:\n      y'   = cos(t) + y\n      y''  = -sin(t) + cos(t) + y\n      y''' = -sin(t) + y\n      y''''= y\n    \"\"\"\n    ct = trig.cos(t)\n    st = trig.sin(t)\n    y1 = ct + y\n    y2 = -st + ct + y\n    y3 = -st + y\n    y4 = y\n    return y + h * y1 + (h**2) * y2 / 2.0 + (h**3) * y3 / 6.0 + (h**4) * y4 / 24.0\n\ndef rk4_step(t, y, h, trig: TrigCounter):\n    \"\"\"\n    One step of classical RK4 for y' = cos(t) + y.\n    Each f evaluation counts a cos() call through the trig wrapper.\n    \"\"\"\n    k1 = f_rhs(t, y, trig)\n    k2 = f_rhs(t + 0.5*h, y + 0.5*h*k1, trig)\n    k3 = f_rhs(t + 0.5*h, y + 0.5*h*k2, trig)\n    k4 = f_rhs(t + h, y + h*k3, trig)\n    return y + (h/6.0) * (k1 + 2.0*k2 + 2.0*k3 + k4)\n\ndef integrate_taylor4(h, T, y0):\n    trig = TrigCounter()\n    N = int(round(T / h))\n    t = 0.0\n    y = y0\n    for _ in range(N):\n        y = taylor4_step(t, y, h, trig)\n        t += h\n    return y, trig.total_trig_calls\n\ndef integrate_rk4(h, T, y0):\n    trig = TrigCounter()\n    N = int(round(T / h))\n    t = 0.0\n    y = y0\n    for _ in range(N):\n        y = rk4_step(t, y, h, trig)\n        t += h\n    return y, trig.total_trig_calls\n\ndef solve():\n    # Define the test cases from the problem statement.\n    T = 2.0\n    y0 = 1.0\n    test_steps = [2.0, 1.0, 0.5, 0.2, 0.1, 0.05]  # h values\n\n    exact_T = float(exact_solution(T))\n\n    results = []\n    for h in test_steps:\n        # Taylor-4 integration\n        yT_taylor, trig_taylor = integrate_taylor4(h, T, y0)\n        err_taylor = abs(yT_taylor - exact_T)\n\n        # RK4 integration\n        yT_rk4, trig_rk4 = integrate_rk4(h, T, y0)\n        err_rk4 = abs(yT_rk4 - exact_T)\n\n        # Append in the specified order:\n        # E_T4(h), E_RK4(h), C_T4(h), C_RK4(h)\n        results.append(err_taylor)\n        results.append(err_rk4)\n        results.append(int(trig_taylor))\n        results.append(int(trig_rk4))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3282712"}, {"introduction": "高阶方法看似强大，但某些被称为“刚性”（stiff）的常微分方程会给标准显式方法带来巨大挑战，无论其阶数多高。本练习将通过一个经典的刚性方程，对比应用一阶显式（前向）和隐式（后向）欧拉法的效果，从而揭示数值稳定性的关键作用。你会发现，对于刚性问题，方法的稳定性选择有时远比其精度阶数更为重要。[@problem_id:3282680]", "problem": "考虑一个常微分方程 (ODE) 的初值问题\n$$\n\\frac{dy}{dt} = -100\\,(y - \\cos t), \\quad y(0) = 1,\n$$\n其中 $t$ 的单位是弧度。您将比较两种单步时间积分方法——显式前向欧拉法和隐式后向欧拉法——以阐释刚性问题。您的任务是从第一性原理出发推导更新规则，然后编写一个程序来量化它们在不同时间步长下的行为差异。\n\n从导数的基本定义出发，即\n$$\n\\frac{dy}{dt} = \\lim_{h \\to 0} \\frac{y(t+h) - y(t)}{h},\n$$\n并用适合每种方法的有限差分来近似它。仅使用此定义以及在已知时间（对于显式步）或在推进后的时间（对于隐式步）评估右侧函数 $f(t,y)$ 的思想，通过代数运算构建各自的单步更新规则，该规则将 $y_n \\approx y(t_n)$ 映射到 $y_{n+1} \\approx y(t_{n+1})$，其中 $t_{n+1} = t_n + h$。不要套用任何预制公式。\n\n然后，对每种方法，应用您推导出的更新规则，使用固定的步长 $h$（使得 $T/h$ 为整数）将数值解从 $t=0$ 推进到 $t=T$。请使用以下规范：\n\n- 模型是给定的 ODE，其中 $f(t,y) = -100\\,(y - \\cos t)$，$t$ 的单位是弧度，初始条件为 $y(0)=1$。\n- 时间范围是 $T=1$。\n- 对于下面测试套件中的每个 $h$，从 $y_0 = 1$ 开始，执行恰好 $N = T/h$ 步。\n\n通过积分因子法解析求解该线性 ODE，得到精确解 $y(t)$。使用此精确解计算两种方法在最终时间 $t=T$ 时的绝对误差：\n$$\nE_{\\mathrm{FE}}(h) = \\left|y_{\\mathrm{FE}}(T;h) - y(T)\\right|, \\quad E_{\\mathrm{BE}}(h) = \\left|y_{\\mathrm{BE}}(T;h) - y(T)\\right|.\n$$\n对于每个测试用例，报告其比率\n$$\nR(h) = \\frac{E_{\\mathrm{FE}}(h)}{E_{\\mathrm{BE}}(h)}.\n$$\n\n测试套件：\n- 用例 1：$h=0.005$，$T=1$。\n- 用例 2：$h=0.02$，$T=1$（对于特征值 $-100$，此前向欧拉法线性稳定的边界）。\n- 用例 3：$h=0.05$，$T=1$（前向欧拉法不稳定区域）。\n- 用例 4：$h=0.1$，$T=1$（前向欧拉法强不稳定）。\n\n您的程序必须：\n- 仅使用您从导数定义推导出的更新规则来实现这两种方法。\n- 以闭合形式实现 ODE 的精确解。\n- 对于每个用例，以浮点数形式返回 $R(h)$。\n\n最终输出格式：\n- 生成单行输出，其中包含四个结果，按上述用例顺序排列，以逗号分隔，并用方括号括起来，无空格，例如 $[r_1,r_2,r_3,r_4]$。\n- 每个 $r_k$ 必须四舍五入到 $6$ 位有效数字，必要时使用科学记数法。\n\n所有数值输出都是无量纲的，因为问题是以无量纲形式提出的，且角度单位是弧度。唯一可接受的输出类型是按规定格式化的浮点数，并汇集成所要求的单个列表。", "solution": "该问题陈述是常微分方程（ODE）数值方法的一个有效练习。它具有科学依据，问题适定，客观，并包含了推导和实现解决方案所需的所有必要信息。\n\n该问题需要三部分分析：首先，推导给定初值问题（IVP）的解析解；其次，从第一性原理推导前向和后向欧拉法的更新规则；第三，实现这些方法，以计算它们在给定时间步长集上的数值误差之比。\n\n### 1. ODE 的解析解\n\n给定的 ODE 是一阶线性非齐次微分方程：\n$$\n\\frac{dy}{dt} = -100(y - \\cos t)\n$$\n它可以重写为标准形式 $\\frac{dy}{dt} + P(t)y = Q(t)$：\n$$\n\\frac{dy}{dt} + 100y = 100\\cos t\n$$\n这里，$P(t) = 100$ 且 $Q(t) = 100\\cos t$。我们使用积分因子 $\\mu(t)$ 来求解。\n$$\n\\mu(t) = \\exp\\left(\\int P(t) dt\\right) = \\exp\\left(\\int 100 dt\\right) = e^{100t}\n$$\n将 ODE 的标准形式乘以 $\\mu(t)$ 得：\n$$\ne^{100t}\\frac{dy}{dt} + 100e^{100t}y = 100e^{100t}\\cos t\n$$\n左边是乘积 $y(t)\\mu(t)$ 的导数：\n$$\n\\frac{d}{dt}\\left(y \\cdot e^{100t}\\right) = 100e^{100t}\\cos t\n$$\n对两边关于 $t$ 积分：\n$$\ny \\cdot e^{100t} = \\int 100e^{100t}\\cos t \\,dt + C\n$$\n积分 $\\int e^{at}\\cos(bt) dt$ 有一个标准形式：\n$$\n\\int e^{at}\\cos(bt) dt = \\frac{e^{at}}{a^2+b^2}(a\\cos(bt) + b\\sin(bt))\n$$\n在我们的例子中，$a=100$，$b=1$。代入这些值：\n$$\n\\int 100e^{100t}\\cos t \\,dt = 100 \\left[ \\frac{e^{100t}}{100^2+1^2}(100\\cos t + 1\\sin t) \\right] = \\frac{100e^{100t}}{10001}(100\\cos t + \\sin t)\n$$\n将此结果代回 $y \\cdot e^{100t}$ 的方程中：\n$$\ny \\cdot e^{100t} = \\frac{100e^{100t}}{10001}(100\\cos t + \\sin t) + C\n$$\n两边除以 $e^{100t}$ 以解出 $y(t)$：\n$$\ny(t) = \\frac{10000}{10001}\\cos t + \\frac{100}{10001}\\sin t + Ce^{-100t}\n$$\n我们使用初始条件 $y(0)=1$ 来求常数 $C$：\n$$\n1 = y(0) = \\frac{10000}{10001}\\cos(0) + \\frac{100}{10001}\\sin(0) + Ce^{0}\n$$\n$$\n1 = \\frac{10000}{10001}(1) + \\frac{100}{10001}(0) + C(1) \\implies C = 1 - \\frac{10000}{10001} = \\frac{1}{10001}\n$$\n因此，精确的解析解是：\n$$\ny(t) = \\frac{10000}{10001}\\cos t + \\frac{100}{10001}\\sin t + \\frac{1}{10001}e^{-100t}\n$$\n\n### 2. 数值更新规则的推导\n\n我们从导数的有限差分近似开始，其中 $h$ 是一个有限的时间步长：\n$$\n\\frac{dy}{dt}\\bigg|_{t=t_n} \\approx \\frac{y(t_{n+1}) - y(t_n)}{h} \\approx \\frac{y_{n+1} - y_n}{h}\n$$\n其中 $y_n \\approx y(t_n)$ 且 $t_{n+1} = t_n + h$。设 ODE 为 $\\frac{dy}{dt} = f(t,y)$，其中 $f(t,y) = -100(y - \\cos t)$。\n\n#### 前向欧拉（显式）法\n前向欧拉法使用当前时间步 $t_n$ 的函数值 $f(t_n, y_n)$ 来近似导数。\n$$\n\\frac{y_{n+1} - y_n}{h} = f(t_n, y_n)\n$$\n解出 $y_{n+1}$ 得到通用的更新规则：\n$$\ny_{n+1} = y_n + h f(t_n, y_n)\n$$\n代入我们具体的函数 $f(t,y)$：\n$$\ny_{n+1} = y_n + h(-100(y_n - \\cos(t_n)))\n$$\n$$\ny_{n+1} = y_n - 100h y_n + 100h \\cos(t_n)\n$$\n$$\ny_{n+1} = (1 - 100h)y_n + 100h \\cos(t_n)\n$$\n这就是前向欧拉法的显式更新规则。\n\n#### 后向欧拉（隐式）法\n后向欧拉法使用下一个时间步 $t_{n+1}$ 的函数值 $f(t_{n+1}, y_{n+1})$ 来近似导数。\n$$\n\\frac{y_{n+1} - y_n}{h} = f(t_{n+1}, y_{n+1})\n$$\n这产生了一个关于未知数 $y_{n+1}$ 的隐式方程：\n$$\ny_{n+1} = y_n + h f(t_{n+1}, y_{n+1})\n$$\n代入我们具体的函数 $f(t,y)$：\n$$\ny_{n+1} = y_n + h(-100(y_{n+1} - \\cos(t_{n+1})))\n$$\n我们现在必须解这个方程以求出 $y_{n+1}$：\n$$\ny_{n+1} = y_n - 100h y_{n+1} + 100h \\cos(t_{n+1})\n$$\n$$\ny_{n+1} + 100h y_{n+1} = y_n + 100h \\cos(t_{n+1})\n$$\n$$\ny_{n+1}(1 + 100h) = y_n + 100h \\cos(t_{n+1})\n$$\n$$\ny_{n+1} = \\frac{y_n + 100h \\cos(t_{n+1})}{1 + 100h}\n$$\n对于这个线性 ODE，这就是（原本是隐式的）后向欧拉法更新规则的显式形式。\n\n### 3. 计算策略\n\n对于每个给定的时间步长 $h$，我们将执行以下步骤：\n1.  设置初始条件 $y_0 = 1$ 和最终时间 $T=1$。\n2.  计算步数 $N = T/h$。\n3.  使用推导出的前向欧拉更新规则，模拟系统从 $t=0$ 到 $t=T$ 的演化，以找到最终时间的数值解 $y_{\\mathrm{FE}}(T;h)$。\n4.  再次使用推导出的后向欧拉更新规则，模拟系统从 $t=0$ 到 $t=T$ 的演化，以找到其数值解 $y_{\\mathrm{BE}}(T;h)$。\n5.  使用解析公式计算最终时间的精确解 $y(T)$。\n6.  计算两种方法的绝对误差：$E_{\\mathrm{FE}}(h) = |y_{\\mathrm{FE}}(T;h) - y(T)|$ 和 $E_{\\mathrm{BE}}(h) = |y_{\\mathrm{BE}}(T;h) - y(T)|$。\n7.  计算比率 $R(h) = E_{\\mathrm{FE}}(h) / E_{\\mathrm{BE}}(h)$。\n8.  将所有测试用例计算出的比率收集起来，并按规定格式化。大的类特征值项（$-100$）使问题变得刚性，我们预计当 $h > 2/100 = 0.02$ 时，前向欧拉法会变得不稳定，导致其误差和比率 $R(h)$ 急剧增加。后向欧拉法是 A-稳定的，不会表现出这种不稳定性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the stiff ODE problem by comparing forward and backward Euler methods.\n    \"\"\"\n    \n    # Test cases defined by the problem statement.\n    # Each case is a specific value for the time step h.\n    test_cases = [\n        0.005,  # Case 1: h=0.005\n        0.02,   # Case 2: h=0.02 (stability boundary)\n        0.05,   # Case 3: h=0.05 (unstable FE)\n        0.1,    # Case 4: h=0.1 (strongly unstable FE)\n    ]\n\n    T = 1.0  # Final time\n    y0 = 1.0  # Initial condition y(0) = 1\n\n    def y_exact(t):\n        \"\"\"\n        Computes the analytical solution of the ODE at time t.\n        y(t) = (1/10001) * [10000*cos(t) + 100*sin(t) + exp(-100t)]\n        \"\"\"\n        return (10000.0 * np.cos(t) + 100.0 * np.sin(t) + np.exp(-100.0 * t)) / 10001.0\n\n    y_true_at_T = y_exact(T)\n    results = []\n\n    for h in test_cases:\n        # Number of steps N must be an integer, as T/h is guaranteed to be one.\n        N = int(round(T / h))\n\n        # 1. Forward Euler Method\n        # y_{n+1} = (1 - 100h)y_n + 100h*cos(t_n)\n        y_fe = y0\n        t = 0.0\n        for _ in range(N):\n            y_fe = (1.0 - 100.0 * h) * y_fe + 100.0 * h * np.cos(t)\n            t += h\n        y_fe_final = y_fe\n\n        # 2. Backward Euler Method\n        # y_{n+1} = (y_n + 100h*cos(t_{n+1})) / (1 + 100h)\n        y_be = y0\n        t = 0.0\n        for _ in range(N):\n            t += h # t is now t_{n+1}\n            y_be = (y_be + 100.0 * h * np.cos(t)) / (1.0 + 100.0 * h)\n        y_be_final = y_be\n\n        # 3. Error Calculation\n        err_fe = np.abs(y_fe_final - y_true_at_T)\n        err_be = np.abs(y_be_final - y_true_at_T)\n\n        # 4. Ratio Calculation\n        # The problem might imply a case where err_be is zero.\n        # However, for these first-order methods on this problem, it won't be exactly zero.\n        ratio = err_fe / err_be\n        results.append(ratio)\n        \n    # Format the results to 6 significant digits and join them into a single string.\n    # The 'g' format specifier is ideal for handling significant digits and\n    # automatically choosing between fixed-point and scientific notation.\n    formatted_results = [f\"{r:.6g}\" for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3282680"}, {"introduction": "许多现实世界的模拟任务并非在预设的固定时间点结束，而是在某个特定条件满足时终止，例如模拟抛射体击中地面。本练习将介绍“事件检测”（event detection）这一概念，它是构建通用ODE求解器的关键功能。你将实现并比较两种策略，以在积分过程中精确定位事件发生的时间，从而增强求解器的实用性。[@problem_id:3144072]", "problem": "您需要编写一个完整、可运行的程序，该程序能对带事件检测的常微分方程（ODE）初值问题（IVP）进行数值积分。当事件函数达到零时，即当 $g(t, y(t)) = 0$ 时，程序必须停止积分。您必须实现并比较两种事件定位策略：\n- 固定步长策略：在检测到 $g(t, y)$ 在一个步长内发生符号变化后，在第一个网格点处停止。\n- 插值策略：在发生符号变化的步长内，通过定位 $g(t, y)$ 的连续近似的零点来精确化事件时间。\n\n您的实现必须使用四阶经典显式单步 Runge–Kutta 方法，以从 $t$ 步进到 $t + h$，且不进行步长自适应。事件检测必须对事件流形的向上和向下穿越都具有鲁棒性。如果 $g(t_0, y_0) = 0$，则必须在 $t = t_0$ 处立即检测到事件，误差为零。所有时间单位必须是秒，角频率单位是弧度/秒。如果您的逻辑涉及任何角度，请以弧度为单位进行解释。您的代码不得要求任何输入。\n\n可用于您设计的基础理论：\n- IVP 定义：给定 $\\dfrac{dy}{dt} = f(t, y)$ 和 $y(t_0) = y_0$，求解 $t \\ge t_0$ 时的 $y(t)$。\n- 事件定义：事件发生在满足 $g(t, y(t)) = 0$ 的最小时间 $t \\ge t_0$ 处。\n\n按如下方式实现两种事件定位策略：\n- 固定步长：当在一个步长 $\\left[g(t_k, y_k), g(t_{k+1}, y_{k+1})\\right]$ 内检测到 $g$ 的符号变化，或当 $g(t_{k+1}, y_{k+1}) = 0$ 时，终止并将事件时间报告为 $t_{k+1}$。\n- 插值：当在一个步长内检测到 $g$ 的符号变化（或 $g(t_{k+1}, y_{k+1}) = 0$ 时），使用步长端点之间 $g$ 的线性插值计算 $\\left[t_k, t_{k+1}\\right]$ 内的精确事件时间，然后终止。\n\n设计程序，通过与下面每个测试用例的精确事件时间进行比较，来评估检测到的事件时间的绝对误差。如果在指定的时间范围内未找到事件，程序应为该情况返回 NaN；然而，所有提供的测试用例都在时间范围内确实存在事件。\n\n测试套件（每个用例定义了 $f(t, y)$、$g(t, y)$、$t_0$、$y_0$、最大时间 $t_{\\max}$ 和一个精确事件时间公式，您必须在程序内部使用该公式来计算基准真相）：\n1. 指数增长穿过阈值（递增穿越）：\n   - 微分方程：$\\dfrac{dy}{dt} = r y$。\n   - 参数：$r = 1.5$，$t_0 = 0$，$y_0 = 0.7$。\n   - 事件：$g(t, y) = y - T$，其中 $T = 5.0$。\n   - 最大时间：$t_{\\max} = 5.0$。\n   - 精确事件时间：满足 $y(t) = T$ 的最小 $t \\ge 0$。\n2. 谐振子穿过阈值（递减穿越）：\n   - 微分方程（二阶方程写成一阶系统）：$\\dfrac{d}{dt}\\begin{bmatrix} y \\\\ v \\end{bmatrix} = \\begin{bmatrix} v \\\\ -\\omega^2 y \\end{bmatrix}$。\n   - 参数：$\\omega = 1.3$，$t_0 = 0$，$y_0 = 1.0$，$v_0 = 0.0$。\n   - 事件：$g(t, y, v) = y - T$，其中 $T = 0.2$。\n   - 最大时间：$t_{\\max} = 5.0$。\n   - 精确事件时间：满足 $y(t) = T$ 的最小 $t \\ge 0$。\n3. 逻辑斯谛增长穿过阈值（非线性递增穿越）：\n   - 微分方程：$\\dfrac{dy}{dt} = r y \\left(1 - \\dfrac{y}{K}\\right)$。\n   - 参数：$r = 1.2$，$K = 10.0$，$t_0 = 0$，$y_0 = 0.5$。\n   - 事件：$g(t, y) = y - T$，其中 $T = 7.5$。\n   - 最大时间：$t_{\\max} = 10.0$。\n   - 精确事件时间：满足 $y(t) = T$ 的最小 $t \\ge 0$。\n4. 初始时刻的即时事件（边界条件）：\n   - 微分方程：$\\dfrac{dy}{dt} = r y$。\n   - 参数：$r = 0.8$，$t_0 = 0$，$y_0 = 2.0$。\n   - 事件：$g(t, y) = y - T$，其中 $T = 2.0$。\n   - 最大时间：$t_{\\max} = 1.0$。\n   - 精确事件时间：$t = 0$。\n\n对所有用例使用相同的两种步长：$h \\in \\{0.1, 0.01\\}$。\n\n对于每个测试用例和每个步长，计算两个绝对误差（单位为秒）：一个使用固定步长事件时间，另一个使用插值事件时间，每个都与该用例的精确事件时间进行比较。按以下顺序将结果汇总到一个扁平列表中：\n- 用例 1：$[\\text{err}_{\\text{fixed}, h=0.1}, \\text{err}_{\\text{interp}, h=0.1}, \\text{err}_{\\text{fixed}, h=0.01}, \\text{err}_{\\text{interp}, h=0.01}]$，\n- 然后是用例 2，模式相同，\n- 然后是用例 3，模式相同，\n- 然后是用例 4，模式相同。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[\\text{result}_1,\\text{result}_2,\\dots]$）。", "solution": "问题陈述经评估有效。它在科学上基于常微分方程（ODE）理论和数值分析，给出了所有必要的条件和参数，问题设定良好，并且表述客观。它提出了一个计算科学领域的标准且非平凡的任务：实现并比较用于求解带事件检测的初值问题（IVP）的数值方法。\n\n任务是数值求解由 $\\dfrac{dY}{dt} = f(t, Y)$ 定义的、带有初始条件 $Y(t_0) = Y_0$ 的 IVP，并找到事件函数 $g(t, Y(t))$ 变为零的最小时间 $t^* \\ge t_0$。状态 $Y(t)$ 可以是标量或向量。积分将使用固定步长 $h$ 的经典四阶 Runge-Kutta（RK4）方法执行。我们将实现并比较两种定位事件时间 $t^*$ 的策略。\n\n**1. 数值积分：经典四阶 Runge-Kutta（RK4）方法**\n\nRK4 方法是一种显式单步积分器，用于近似求解 IVP。给定时间 $t_k$ 时的状态 $Y_k$，在时间 $t_{k+1} = t_k + h$ 的状态 $Y_{k+1}$ 按如下方式计算：\n\n$$ Y_{k+1} = Y_k + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4) $$\n\n其中中间斜率为：\n\\begin{align*}\nk_1 = f(t_k, Y_k) \\\\\nk_2 = f(t_k + h/2, Y_k + \\frac{h}{2}k_1) \\\\\nk_3 = f(t_k + h/2, Y_k + \\frac{h}{2}k_2) \\\\\nk_4 = f(t_k + h, Y_k + hk_3)\n\\end{align*}\n该方法的局部截断误差为 $O(h^5)$ 阶，全局误差为 $O(h^4)$ 阶。\n\n**2. 事件检测与定位**\n\n该算法的核心是一个积分循环，它在监控事件函数 $g(t, Y(t))$ 的同时，逐步推进求解过程。\n\n首先，我们处理即时事件的情况。我们计算 $g_0 = g(t_0, Y_0)$。如果 $g_0 = 0$，则事件在 $t_0$ 发生，过程终止。\n\n如果没有检测到即时事件，则开始积分循环。在每一步 $k$，我们有状态 $(t_k, Y_k)$ 和事件函数值 $g_k = g(t_k, Y_k)$。我们使用一个 RK4 步长计算下一个状态 $(t_{k+1}, Y_{k+1})$ 并评估 $g_{k+1} = g(t_{k+1}, Y_{k+1})$。如果事件函数穿过零点，则认为在区间 $[t_k, t_{k+1}]$ 内发生了事件。这通过检查符号变化来检测，即，如果满足条件 $g_k \\cdot g_{k+1} \\le 0$。包含等号是为了处理事件恰好落在网格点上的情况。\n\n一旦事件被界定在 $[t_k, t_{k+1}]$ 内，就使用两种策略之一来确定其精确时间 $t^*$。\n\n**策略 A：固定步长事件定位**\n这是最简单的策略。在区间 $[t_k, t_{k+1}]$ 内检测到事件后，积分终止，并将事件时间报告为该区间的结束时间：\n$$ t^*_{fixed} = t_{k+1} $$\n该方法的误差以步长为界，即 $|t^*_{fixed} - t_{exact}| \\le h$。\n\n**策略 B：插值事件定位**\n该策略通过在区间 $[t_k, t_{k+1}]$ 内近似 $g(t, Y(t))$ 的行为来精确化事件时间。我们对事件函数值 $g_k$ 和 $g_{k+1}$ 进行线性插值。我们找到时间 $t^* \\in [t_k, t_{k+1}]$，使得通过 $(t_k, g_k)$ 和 $(t_{k+1}, g_{k+1})$ 的直线为零。该时间的公式推导如下：\n$$ 0 = g_k + \\frac{g_{k+1} - g_k}{t_{k+1} - t_k}(t^* - t_k) $$\n求解 $t^*$ 得：\n$$ t^*_{interp} = t_k - g_k \\frac{t_{k+1} - t_k}{g_{k+1} - g_k} = t_k - g_k \\frac{h}{g_{k+1} - g_k} = t_k + h \\frac{g_k}{g_k - g_{k+1}} $$\n这种方法通常比固定步长策略产生更精确的事件时间估计，因为其误差与步长内 $g$ 的线性近似的准确性有关。\n\n**3. 测试用例的解析解**\n\n为了评估数值方法的准确性，我们将计算出的事件时间与每个测试用例的精确解析解进行比较。\n\n**用例 1：指数增长**\n- ODE：$\\dfrac{dy}{dt} = ry$，其中 $y(0) = y_0$。解为 $y(t) = y_0 e^{rt}$。\n- 事件：$y(t) = T$。\n- 精确时间：$y_0 e^{rt^*} = T \\implies t^* = \\frac{1}{r} \\ln\\left(\\frac{T}{y_0}\\right)$。\n\n**用例 2：谐振子**\n- ODE 系统：$\\dfrac{dy}{dt} = v$，$\\dfrac{dv}{dt} = -\\omega^2 y$。当 $y(0) = y_0=1$ 且 $v(0)=v_0=0$ 时，解为 $y(t) = y_0 \\cos(\\omega t)$。\n- 事件：$y(t) = T$。\n- 精确时间：$y_0 \\cos(\\omega t^*) = T$。由于我们寻求最小的 $t^* \\ge 0$，可得 $\\omega t^* = \\arccos(T/y_0)$，即 $t^* = \\frac{1}{\\omega} \\arccos\\left(\\frac{T}{y_0}\\right)$。\n\n**用例 3：逻辑斯谛增长**\n- ODE：$\\dfrac{dy}{dt} = ry \\left(1 - \\dfrac{y}{K}\\right)$，其中 $y(0) = y_0$。解为 $y(t) = \\frac{K}{1 + \\left(\\frac{K}{y_0} - 1\\right)e^{-rt}}$。\n- 事件：$y(t) = T$。\n- 精确时间：求解 $t^*$ 得 $t^* = \\frac{1}{r} \\ln\\left(\\frac{\\frac{K}{y_0} - 1}{\\frac{K}{T} - 1}\\right)$。\n\n**用例 4：即时事件**\n- ODE：$\\dfrac{dy}{dt} = ry$。\n- 事件：$y(t) = T$。\n- 参数：$y_0 = 2.0$，$T = 2.0$。\n- 精确时间：事件条件为 $g(t_0, y_0) = y_0 - T = 2.0 - 2.0 = 0$。事件发生在初始时刻，因此 $t^*=0$。\n\n程序将为每个用例、步长和策略计算绝对误差 $|t^*_{computed} - t^*_{exact}|$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rk4_step(f, t, y, h, params):\n    \"\"\"\n    Performs a single step of the classical 4th-order Runge-Kutta method.\n    \"\"\"\n    k1 = f(t, y, params)\n    k2 = f(t + 0.5 * h, y + 0.5 * h * k1, params)\n    k3 = f(t + 0.5 * h, y + 0.5 * h * k2, params)\n    k4 = f(t + h, y + h * k3, params)\n    return y + (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\ndef find_event(f, g, t0, y0, h, t_max, strategy, params):\n    \"\"\"\n    Integrates an ODE with event detection.\n\n    Args:\n        f: The ODE function dy/dt = f(t, y, params).\n        g: The event function g(t, y, params) = 0.\n        t0: Initial time.\n        y0: Initial state vector.\n        h: Fixed step size.\n        t_max: Maximum integration time.\n        strategy: 'fixed' or 'interpolatory'.\n        params: Dictionary of parameters for f and g.\n\n    Returns:\n        The detected event time, or np.nan if no event is found.\n    \"\"\"\n    t = t0\n    y = np.array(y0, dtype=float)\n\n    g_current = g(t, y, params)\n\n    # Check for immediate event at t0\n    if np.isclose(g_current, 0.0):\n        return t0\n\n    while t  t_max:\n        current_h = h\n        if t + current_h > t_max:\n            current_h = t_max - t\n            if current_h = 0: break\n\n        y_next = rk4_step(f, t, y, current_h, params)\n        t_next = t + current_h\n        g_next = g(t_next, y_next, params)\n\n        # Check for sign change or zero crossing\n        if g_current * g_next = 0:\n            if strategy == 'fixed':\n                return t_next\n            elif strategy == 'interpolatory':\n                # Linear interpolation to find refined event time\n                # Avoid division by zero if g_current == g_next\n                if np.isclose(g_current, g_next):\n                    return t_next\n                else:\n                    return t + current_h * g_current / (g_current - g_next)\n            else:\n                raise ValueError(\"Unknown strategy\")\n        \n        t = t_next\n        y = y_next\n        g_current = g_next\n\n    return np.nan\n\n# Test Suite Definition\ntest_cases = [\n    # Case 1: Exponential growth\n    {\n        \"f\": lambda t, y, p: p['r'] * y,\n        \"g\": lambda t, y, p: y[0] - p['T'],\n        \"y0\": [0.7],\n        \"t0\": 0.0,\n        \"t_max\": 5.0,\n        \"params\": {'r': 1.5, 'T': 5.0},\n        \"exact_time_func\": lambda p: (1.0 / p['r']) * np.log(p['T'] / 0.7)\n    },\n    # Case 2: Harmonic oscillator\n    {\n        \"f\": lambda t, y, p: np.array([y[1], -p['omega']**2 * y[0]]),\n        \"g\": lambda t, y, p: y[0] - p['T'],\n        \"y0\": [1.0, 0.0],\n        \"t0\": 0.0,\n        \"t_max\": 5.0,\n        \"params\": {'omega': 1.3, 'T': 0.2},\n        \"exact_time_func\": lambda p: (1.0 / p['omega']) * np.arccos(p['T'] / 1.0)\n    },\n    # Case 3: Logistic growth\n    {\n        \"f\": lambda t, y, p: p['r'] * y * (1.0 - y / p['K']),\n        \"g\": lambda t, y, p: y[0] - p['T'],\n        \"y0\": [0.5],\n        \"t0\": 0.0,\n        \"t_max\": 10.0,\n        \"params\": {'r': 1.2, 'K': 10.0, 'T': 7.5},\n        \"exact_time_func\": lambda p: (1.0 / p['r']) * np.log(((p['K'] / 0.5) - 1.0) / ((p['K'] / p['T']) - 1.0))\n    },\n    # Case 4: Immediate event\n    {\n        \"f\": lambda t, y, p: p['r'] * y,\n        \"g\": lambda t, y, p: y[0] - p['T'],\n        \"y0\": [2.0],\n        \"t0\": 0.0,\n        \"t_max\": 1.0,\n        \"params\": {'r': 0.8, 'T': 2.0},\n        \"exact_time_func\": lambda p: 0.0\n    }\n]\n\nstep_sizes = [0.1, 0.01]\nall_results = []\n\nfor case in test_cases:\n    exact_time = case[\"exact_time_func\"](case[\"params\"])\n    \n    for h in step_sizes:\n        # Fixed-step strategy\n        t_fixed = find_event(\n            f=case[\"f\"], g=case[\"g\"], t0=case[\"t0\"], y0=case[\"y0\"],\n            h=h, t_max=case[\"t_max\"], strategy=\"fixed\", params=case[\"params\"]\n        )\n        err_fixed = abs(t_fixed - exact_time) if not np.isnan(t_fixed) else np.nan\n        all_results.append(err_fixed)\n\n        # Interpolatory strategy\n        t_interp = find_event(\n            f=case[\"f\"], g=case[\"g\"], t0=case[\"t0\"], y0=case[\"y0\"],\n            h=h, t_max=case[\"t_max\"], strategy=\"interpolatory\", params=case[\"params\"]\n        )\n        err_interp = abs(t_interp - exact_time) if not np.isnan(t_interp) else np.nan\n        all_results.append(err_interp)\n\nprint(f\"[{','.join(map(str, all_results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3144072"}]}