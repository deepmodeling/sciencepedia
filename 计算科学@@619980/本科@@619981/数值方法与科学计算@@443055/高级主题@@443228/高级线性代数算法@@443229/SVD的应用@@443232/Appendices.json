{"hands_on_practices": [{"introduction": "我们首先从一个基础练习开始，这个练习将帮助你巩固对 SVD 基本定义的理解。通过从给定的 SVD 组件 $U$、$Σ$ 和 $V^T$ 出发，手动重构原始矩阵 $A$，你将能直观地看到旋转、缩放和再次旋转这三个几何变换是如何组合起来形成一个线性变换的 [@problem_id:16521]。这个练习是掌握 SVD 如何将复杂变换分解为简单、可解释步骤的基础。", "problem": "一个实 $2 \\times 2$ 矩阵 $A$ 的奇异值分解 (SVD) 提供了一种 $A = U\\Sigma V^T$ 形式的分解，其中 $U$ 和 $V$ 是 $2 \\times 2$ 的正交矩阵，而 $\\Sigma$ 是一个 $2 \\times 2$ 的对角矩阵。\n\n考虑一个矩阵 $A$，其 SVD 分解的各部分如下所示：\n- $U$ 是一个由角度 $\\theta$ 定义的旋转矩阵：\n$$\nU = \\begin{pmatrix} \\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta \\end{pmatrix}\n$$\n- $\\Sigma$ 是一个包含奇异值 $\\sigma_1$ 和 $\\sigma_2$ 的对角矩阵：\n$$\n\\Sigma = \\begin{pmatrix} \\sigma_1  0 \\\\ 0  \\sigma_2 \\end{pmatrix}\n$$\n- $V$ 是一个由角度 $\\phi$ 定义的旋转矩阵：\n$$\nV = \\begin{pmatrix} \\cos\\phi  -\\sin\\phi \\\\ \\sin\\phi  \\cos\\phi \\end{pmatrix}\n$$\n\n请用参数 $\\theta$、$\\phi$、$\\sigma_1$ 和 $\\sigma_2$ 推导矩阵 $A$ 的元素 $A_{21}$（即第二行第一列的元素）的表达式。", "solution": "我们有\n$$A \\;=\\; U\\,\\Sigma\\,V^T.$$\n首先计算\n$$V^T=\\begin{pmatrix}\\cos\\phi  \\sin\\phi\\\\-\\sin\\phi  \\cos\\phi\\end{pmatrix}.$$\n然后\n$$\\Sigma V^T\n=\\begin{pmatrix}\\sigma_1  0\\\\0  \\sigma_2\\end{pmatrix}\n\\begin{pmatrix}\\cos\\phi  \\sin\\phi\\\\-\\sin\\phi  \\cos\\phi\\end{pmatrix}\n=\\begin{pmatrix}\\sigma_1\\cos\\phi  \\sigma_1\\sin\\phi\\\\-\\sigma_2\\sin\\phi  \\sigma_2\\cos\\phi\\end{pmatrix}.$$\n接下来乘以\n$$U=\\begin{pmatrix}\\cos\\theta  -\\sin\\theta\\\\\\sin\\theta  \\cos\\theta\\end{pmatrix}$$\n得到\n$$A=U(\\Sigma V^T)\n=\\begin{pmatrix}\\cos\\theta  -\\sin\\theta\\\\\\sin\\theta  \\cos\\theta\\end{pmatrix}\n\\begin{pmatrix}\\sigma_1\\cos\\phi  \\sigma_1\\sin\\phi\\\\-\\sigma_2\\sin\\phi  \\sigma_2\\cos\\phi\\end{pmatrix}.$$\n第 $(2,1)$ 个元素是 $U$ 的第二行与 $\\Sigma V^T$ 的第一列的点积：\n$$A_{21}\n=\\bigl(\\sin\\theta,\\;\\cos\\theta\\bigr)\\cdot\\begin{pmatrix}\\sigma_1\\cos\\phi\\\\-\\sigma_2\\sin\\phi\\end{pmatrix}\n=\\sigma_1\\sin\\theta\\cos\\phi-\\sigma_2\\cos\\theta\\sin\\phi.$$", "answer": "$$\\boxed{\\sigma_1\\sin\\theta\\cos\\phi-\\sigma_2\\cos\\theta\\sin\\phi}$$", "id": "16521"}, {"introduction": "掌握了 SVD 的基本构造后，我们可以用它来解决一个在标准线性代数中颇具挑战性的问题：计算伪逆。对于不可逆或非方阵的矩阵，SVD 提供了一种稳健且通用的方法来定义和计算其伪逆，这在解决最小二乘问题和推荐系统中至关重要 [@problem_id:1049204]。这个练习将向你展示如何利用 SVD 来处理奇异矩阵，突显其在扩展矩阵求逆概念方面的强大功能。", "problem": "使用奇异值分解 (SVD) 计算矩阵 $ A = \\begin{bmatrix} 2  0 \\\\ 0  0 \\end{bmatrix} $ 的伪逆。回顾一下，矩阵 $ A $ 的 SVD 由 $ A = U \\Sigma V^T $ 给出，其中 $ U $ 和 $ V $ 是正交矩阵，而 $ \\Sigma $ 是一个包含奇异值的对角矩阵。伪逆 $ A^+ $ 则计算为 $ A^+ = V \\Sigma^+ U^T $，其中 $ \\Sigma^+ $ 是通过将 $ \\Sigma $ 中的每个非零奇异值 $ \\sigma_i $ 替换为 $ \\sigma_i^{-1} $，然后转置得到的。", "solution": "1. 奇异值 $\\sigma_i$ 是 $AA^T$ 的特征值的平方根。我们有\n$$AA^T = \\begin{bmatrix}2  0\\\\0  0\\end{bmatrix}\\begin{bmatrix}2  0\\\\0  0\\end{bmatrix}^T\n=\\begin{bmatrix}4  0\\\\0  0\\end{bmatrix},$$\n所以 $\\sigma_1=\\sqrt{4}=2$，$\\sigma_2=0$。\n\n2. 我们选择正交矩阵 $U=I_2$，$V=I_2$ 以及\n$$\\Sigma=\\begin{bmatrix}2  0\\\\0  0\\end{bmatrix}。$$\n\n3. $\\Sigma$ 的伪逆是\n$$\\Sigma^+=\\begin{bmatrix}2^{-1}  0\\\\0  0\\end{bmatrix}\n=\\begin{bmatrix}\\frac{1}{2}  0\\\\0  0\\end{bmatrix}。$$\n\n4. 最后，\n$$A^+=V\\,\\Sigma^+\\,U^T\n=I_2\\begin{bmatrix}\\frac{1}{2}  0\\\\0  0\\end{bmatrix}I_2^T\n=\\begin{bmatrix}\\frac{1}{2}  0\\\\0  0\\end{bmatrix}。$$", "answer": "$$\\boxed{\\begin{bmatrix}\\frac{1}{2}  0\\\\0  0\\end{bmatrix}}$$", "id": "1049204"}, {"introduction": "最后，我们将通过一个经典且极具影响力的实际应用来展示 SVD 的强大威力：图像压缩。这个练习要求你编写代码，对图像的每个颜色通道进行奇异值分解，并通过截断 SVD 来探索近似秩与图像质量、存储大小之间的关系 [@problem_id:3206004]。通过这个动手实践，你将把抽象的低秩近似理论转化为具体可见的结果，深刻体会 SVD 在数据降维和高效存储中的核心作用。", "problem": "您的任务是研究使用奇异值分解 (SVD) 压缩彩色图像，SVD 分别应用于红色 (R)、绿色 (G) 和蓝色 (B) 三个通道。目标是从奇异值分解 (SVD) 的形式化定义和矩阵范数的性质出发，量化截断 SVD 近似如何影响重建质量和存储空间。\n\n通过将每个通道定义为在归一化空间网格 $x \\in [0,1]$（行）和 $y \\in [0,1]$（列）上的确定性一维函数的外积之和，构造一个高为 $H$、宽为 $W$ 的合成彩色图像。具体来说，对于任何给定的对 $(H,W)$，令 $x$ 为一个 $H$ 维向量，其中 $x_i = \\frac{i}{H-1}$（$i = 0,1,\\dots,H-1$），令 $y$ 为一个 $W$ 维向量，其中 $y_j = \\frac{j}{W-1}$（$j = 0,1,\\dots,W-1$）。通过以下外积构造定义三个通道：\n- 红色通道 $R \\in \\mathbb{R}^{H \\times W}$：\n$$\nR = 0.5 \\cdot (x \\, (1-y)^\\top) \\;+\\; 0.35 \\cdot (\\sin(2\\pi x) \\, \\cos(2\\pi y)^\\top) \\;+\\; 0.15 \\cdot \\left(\\exp\\!\\left(-\\frac{(x-0.3)^2}{0.05}\\right) \\, (y^{1/2})^\\top\\right).\n$$\n- 绿色通道 $G \\in \\mathbb{R}^{H \\times W}$：\n$$\nG = 0.4 \\cdot (\\sin(\\pi x) \\, \\sin(\\pi y)^\\top) \\;+\\; 0.4 \\cdot (\\mathbf{1}_H \\, \\exp\\!\\left(-\\frac{(y-0.5)^2}{0.08}\\right)^\\top) \\;+\\; 0.2 \\cdot (\\cos(3\\pi x) \\, y^\\top),\n$$\n其中 $\\mathbf{1}_H$ 表示全为 1 的 $H$ 维向量。\n- 蓝色通道 $B \\in \\mathbb{R}^{H \\times W}$：\n$$\nB = 0.45 \\cdot (\\cos(2\\pi x) \\, (y^2)^\\top) \\;+\\; 0.35 \\cdot (x^{1/2} \\, (1-y)^{0.3}^\\top) \\;+\\; 0.2 \\cdot (\\sin(4\\pi x) \\, \\cos(2\\pi y)^\\top).\n$$\n\n构建每个通道后，通过以下公式将其线性缩放到区间 $[0,1]$：\n$$\n\\widetilde{C} = \\frac{C - \\min(C)}{\\max(C) - \\min(C) + 10^{-12}},\n$$\n该公式逐元素应用于 $C \\in \\{R,G,B\\}$，并约定如果 $\\max(C) = \\min(C)$，则 $\\widetilde{C}$ 被设为同样大小的零矩阵。这确保了合成图像的强度值有良好定义且有界。\n\n对于给定的非负整数 $k$，对每个通道 $\\widetilde{C}$ 单独执行截断奇异值分解 (SVD)，并重建其最佳 $k$ 阶近似 $\\widetilde{C}_k$。如果 $k  \\min(H,W)$，则将 $k$ 视为 $k = \\min(H,W)$。使用 Frobenius 范数定义三个通道的相对重建误差：\n$$\ne(H,W,k) \\;=\\; \\frac{\\sqrt{\\lVert \\widetilde{R} - \\widetilde{R}_k \\rVert_F^2 + \\lVert \\widetilde{G} - \\widetilde{G}_k \\rVert_F^2 + \\lVert \\widetilde{B} - \\widetilde{B}_k \\rVert_F^2}}{\\sqrt{\\lVert \\widetilde{R} \\rVert_F^2 + \\lVert \\widetilde{G} \\rVert_F^2 + \\lVert \\widetilde{B} \\rVert_F^2}}.\n$$\n同时，计算截断 SVD 的每个通道的存储压缩比（假设存储每个通道的截断因子），定义为\n$$\nr(H,W,k) \\;=\\; \\frac{Hk + Wk + k}{HW} \\;=\\; \\frac{(H+W+1)k}{HW},\n$$\n并且对所有三个通道使用相同的 $r(H,W,k)$，因为它们的维度相同。\n\n实现一个程序，该程序：\n- 为每个测试用例构建合成图像 $(\\widetilde{R}, \\widetilde{G}, \\widetilde{B})$。\n- 使用给定的 $k$ 计算截断 SVD 重建 $(\\widetilde{R}_k, \\widetilde{G}_k, \\widetilde{B}_k)$。\n- 对每个测试用例，输出数对 $[e(H,W,k), r(H,W,k)]$，作为四舍五入到 6 位小数的浮点数。\n\n测试套件：\n使用以下测试用例来评估不同情况：\n- 情况 1：$(H,W,k) = (48,64,5)$，一个一般的中等秩近似。\n- 情况 2：$(H,W,k) = (48,64,0)$，0 阶（全零重建）的边界情况。\n- 情况 3：$(H,W,k) = (48,64,48)$，对于每个通道的高矩阵，$k=\\min(H,W)$ 的满秩情况。\n- 情况 4：$(H,W,k) = (32,20,3)$，一个具有小秩的矩形图像。\n- 情况 5：$(H,W,k) = (2,2,1)$，一个具有 1 阶近似的极小图像。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素是对应测试用例的一个双元素列表 $[e,r]$，其中两个值都四舍五入到 6 位小数，例如 $[[e_1,r_1],[e_2,r_2],\\dots]$。", "solution": "此问题是一个定义明确的数值线性代数问题，核心是应用奇异值分解（SVD）实现图像压缩。问题中给出的所有公式和参数在科学上是合理的，在数学上也是一致的。我们将通过实现指定的算法来解决这个问题。\n\n解决方案的关键在于矩阵的奇异值分解（SVD）。对于任意实矩阵 $A \\in \\mathbb{R}^{H \\times W}$，其 SVD 分解形式为 $A = U \\Sigma V^\\top$，其中 $U \\in \\mathbb{R}^{H \\times H}$ 和 $V \\in \\mathbb{R}^{W \\times W}$ 是正交矩阵，$\\Sigma \\in \\mathbb{R}^{H \\times W}$ 是一个对角元素为非负实数的矩形对角矩阵。$\\Sigma$ 的对角元素 $\\sigma_i$ 称为 $A$ 的奇异值，通常按降序排列：$\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_{\\min(H,W)} \\ge 0$。$U$ 的各列是左奇异向量，$V$ 的各列是右奇异向量。\n\nSVD 提供了矩阵的最佳低秩近似。根据 Eckart-Young-Mirsky 定理，在弗罗贝尼乌斯范数（Frobenius norm）下，$A$ 的最佳 $k$ 阶近似（记为 $A_k$）是通过截断 SVD 得到的。具体来说，$A_k = U_k \\Sigma_k V_k^\\top$，其中 $U_k$ 和 $V_k$ 分别包含 $U$ 和 $V$ 的前 $k$ 列，$\\Sigma_k$ 是一个 $k \\times k$ 的对角矩阵，其对角线元素为前 $k$ 个奇异值 $\\sigma_1, \\dots, \\sigma_k$。\n\n对于本问题，一个关键性质是弗罗贝尼乌斯范数和奇异值之间的关系。矩阵的弗罗贝尼乌斯范数的平方等于其奇异值的平方和：\n$$\n\\lVert A \\rVert_F^2 = \\sum_{i=1}^{\\min(H,W)} \\sigma_i^2.\n$$\n$k$ 阶近似的误差也可以直接用奇异值表示，这比构造矩阵差在计算上更高效：\n$$\n\\lVert A - A_k \\rVert_F^2 = \\sum_{i=k+1}^{\\min(H,W)} \\sigma_i^2.\n$$\n这使得可以直接计算相对重建误差 $e(H,W,k)$，而无需显式地构建近似矩阵 $\\widetilde{R}_k, \\widetilde{G}_k, \\widetilde{B}_k$。令 $s_{R,i}, s_{G,i}, s_{B,i}$ 分别为重缩放后通道 $\\widetilde{R}, \\widetilde{G}, \\widetilde{B}$ 的奇异值。误差公式的平方分子为 $\\sum_{i=k'+1} s_{R,i}^2 + \\sum_{i=k'+1} s_{G,i}^2 + \\sum_{i=k'+1} s_{B,i}^2$，平方分母为 $\\sum_{i=1} s_{R,i}^2 + \\sum_{i=1} s_{G,i}^2 + \\sum_{i=1} s_{B,i}^2$，其中 $k' = \\min(k, H, W)$。\n\n存储压缩比 $r(H,W,k)$ 是通过比较存储原始矩阵与其 $k'$ 阶近似所需空间得出的。原始 $H \\times W$ 矩阵需要存储 $HW$ 个值。$k'$ 阶近似需要存储截断的 $U_k$（一个 $H \\times k'$ 矩阵）、奇异值 $\\sigma_1, \\dots, \\sigma_{k'}$（一个 $k'$ 维向量）和截断的 $V_k$（一个 $W \\times k'$ 矩阵，其转置 $V_k^T$ 是 $k' \\times W$）。这总共需要 $Hk' + k' + Wk' = (H+W+1)k'$ 个值。因此，该比率为 $\\frac{(H+W+1)k'}{HW}$。\n\n对于每个测试用例 $(H,W,k)$，求解算法如下：\n1.  根据问题的钳位规则，定义有效秩 $k' = \\min(k, H, W)$。\n2.  生成归一化的空间网格 $x$（大小为 $H$）和 $y$（大小为 $W$）。\n3.  使用提供的公式构建红色 ($R$)、绿色 ($G$) 和蓝色 ($B$) 通道的矩阵，利用向量化的外积运算以提高效率。\n4.  将每个通道矩阵 $C \\in \\{R,G,B\\}$ 通过应用指定公式 $\\widetilde{C} = \\frac{C - \\min(C)}{\\max(C) - \\min(C) + 10^{-12}}$ 缩放到 $[0,1]$ 范围，以获得 $\\widetilde{C}$。对于通道为常数（$\\max(C) = \\min(C)$）的特殊情况，将其重缩放版本设置为零矩阵来处理。\n5.  对于每个重缩放后的通道 $\\widetilde{R}, \\widetilde{G}, \\widetilde{B}$，使用 SVD 计算其奇异值。令奇异值向量分别为 $s_R, s_G, s_B$。\n6.  如上所述，通过对奇异值的平方求和来计算相对误差 $e(H,W,k)$。分子是从索引 $k'$ 到末尾的奇异值的平方和，分母是所有奇异值的平方和。如果总范数为零，则误差为 $0$。\n7.  使用公式 $r = \\frac{(H+W+1)k'}{HW}$ 计算压缩比 $r(H,W,k)$。\n8.  将结果对 $[e, r]$ 存储起来，两个值都四舍五入到 6 位小数。\n对所有测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the synthetic image compression problem using SVD for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (H, W, k)\n        (48, 64, 5),\n        (48, 64, 0),\n        (48, 64, 48),\n        (32, 20, 3),\n        (2, 2, 1),\n    ]\n\n    results = []\n    for H, W, k in test_cases:\n        # 1. Define effective rank k'\n        k_eff = min(k, H, W)\n\n        # 2. Generate spatial grids\n        x = np.linspace(0, 1, H)\n        y = np.linspace(0, 1, W)\n\n        # 3. Construct raw channel matrices R, G, B\n        # Red channel\n        R = (\n            0.5 * np.outer(x, 1 - y) +\n            0.35 * np.outer(np.sin(2 * np.pi * x), np.cos(2 * np.pi * y)) +\n            0.15 * np.outer(np.exp(-((x - 0.3)**2) / 0.05), y**0.5)\n        )\n\n        # Green channel\n        one_H = np.ones(H)\n        G = (\n            0.4 * np.outer(np.sin(np.pi * x), np.sin(np.pi * y)) +\n            0.4 * np.outer(one_H, np.exp(-((y - 0.5)**2) / 0.08)) +\n            0.2 * np.outer(np.cos(3 * np.pi * x), y)\n        )\n\n        # Blue channel\n        B = (\n            0.45 * np.outer(np.cos(2 * np.pi * x), y**2) +\n            0.35 * np.outer(x**0.5, (1 - y)**0.3) +\n            0.2 * np.outer(np.sin(4 * np.pi * x), np.cos(2 * np.pi * y))\n        )\n\n        # 4. Rescale channels to [0, 1]\n        def rescale(C):\n            c_min, c_max = np.min(C), np.max(C)\n            if np.isclose(c_max, c_min):\n                return np.zeros_like(C, dtype=float)\n            return (C - c_min) / (c_max - c_min + 1e-12)\n\n        Rt = rescale(R)\n        Gt = rescale(G)\n        Bt = rescale(B)\n\n        # 5. Compute singular values for each channel\n        s_r = np.linalg.svd(Rt, compute_uv=False)\n        s_g = np.linalg.svd(Gt, compute_uv=False)\n        s_b = np.linalg.svd(Bt, compute_uv=False)\n\n        # 6. Calculate relative reconstruction error e(H,W,k)\n        num_sq_err = (\n            np.sum(s_r[k_eff:]**2) +\n            np.sum(s_g[k_eff:]**2) +\n            np.sum(s_b[k_eff:]**2)\n        )\n        den_sq_err = (\n            np.sum(s_r**2) +\n            np.sum(s_g**2) +\n            np.sum(s_b**2)\n        )\n\n        if den_sq_err  1e-12: # Handles case of all-zero rescaled image\n            e = 0.0\n        else:\n            e = np.sqrt(num_sq_err / den_sq_err)\n\n        # 7. Calculate compression ratio r(H,W,k)\n        if H * W == 0:\n            r = 0.0\n        else:\n            r = (H + W + 1) * k_eff / (H * W)\n\n        # 8. Append rounded results\n        results.append([round(e, 6), round(r, 6)])\n\n    # Final print statement in the exact required format.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3206004"}]}