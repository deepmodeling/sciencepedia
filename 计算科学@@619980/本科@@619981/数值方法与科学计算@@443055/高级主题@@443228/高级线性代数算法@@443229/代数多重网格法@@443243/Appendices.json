{"hands_on_practices": [{"introduction": "理论通过实践得以升华。为了真正掌握代数多重网格（AMG）方法，我们将通过一系列精心设计的动手练习，巩固核心概念并培养解决问题的技能。这些练习将引导你从基础的收敛性分析，到稳健的算法实现，再到专家级的故障诊断。\n\n迭代方法的收敛速度由其误差传播矩阵的光谱半径决定。第一个练习提供了一个独特的机会，让我们可以为一个简单的一维问题剖析代数多重网格（AMG）过程，并精确地计算出这个关键值 [@problem_id:3204444]。通过亲手构建平滑器、粗网格校正算子以及最终的双网格迭代矩阵，你将具体理解这些组件如何协同作用以消除误差。", "problem": "考虑区间 $(0,1)$ 上的一维泊松问题 $-u''(x) = f(x)$，其具有齐次狄利克雷边界条件 $u(0) = u(1) = 0$。使用具有 $N=4$ 个内部点的均匀网格和标准的二阶中心有限差分格式对该问题进行离散化。设得到的对称正定（SPD）刚度矩阵写为 $A = \\frac{1}{h^{2}}T$，其中 $h$ 是网格间距，且\n$$\nT = \\begin{pmatrix}\n2  -1  0  0 \\\\\n-1  2  -1  0 \\\\\n0  -1  2  -1 \\\\\n0  0  -1  2\n\\end{pmatrix}.\n$$\n所有后续的构造都可以用 $T$ 进行（因为迭代矩阵中 $\\frac{1}{h^2}$ 的对角缩放会抵消），并且为了谱分析的目的，您可以将 $A$ 和 $T$ 互换使用。\n\n构造一个包含以下分量的两层代数多重网格（AMG）方法：\n- 在细网格索引 $2$ 和 $4$ 处选择粗节点。通过对粗节点进行注入和对细节点进行线性插值来定义插值算子 $P \\in \\mathbb{R}^{4 \\times 2}$，如下所示\n$$\nP = \\begin{pmatrix}\n1  0 \\\\\n1  0 \\\\\n\\frac{1}{2}  \\frac{1}{2} \\\\\n0  1\n\\end{pmatrix}.\n$$\n- 使用限制算子 $R = P^{\\top}$ 和伽辽金粗化算子 $A_{c} = R A P$。\n- 使用权重为 $\\omega = \\frac{2}{3}$ 的加权雅可比法进行单次后平滑步骤。加权雅可比平滑算子为 $S = I - \\omega D^{-1}A$，其中 $D = \\mathrm{diag}(A)$。\n- 使用算子 $C = I - P A_{c}^{-1} R A$ 进行精确的粗网格校正。\n\n粗网格校正后跟一次后平滑步骤的一个两层循环的误差传播矩阵为 $E = S C$。\n\n从上述定义和构造出发，推导谱半径 $\\rho(E)$ 的封闭解析形式，其定义为 $\\rho(E) = \\max\\{|\\lambda| : \\lambda \\in \\sigma(E)\\}$。请将最终答案表示为单个封闭形式的表达式。无需四舍五入，且不涉及物理单位。", "solution": "用户希望我在尝试解决问题之前，严格验证问题陈述的有效性。\n\n### 第一步：提取已知条件\n\n-   **问题：** 区间 $(0,1)$ 上的一维泊松方程 $-u''(x) = f(x)$，满足 $u(0) = u(1) = 0$。\n-   **离散化：** 具有 $N=4$ 个内部点的均匀网格。标准的二阶中心有限差分。\n-   **刚度矩阵：** $A = \\frac{1}{h^{2}}T$，其中 $h$ 是网格间距。\n-   **矩阵 T：**\n    $$\n    T = \\begin{pmatrix}\n    2  -1  0  0 \\\\\n    -1  2  -1  0 \\\\\n    0  -1  2  -1 \\\\\n    0  0  -1  2\n    \\end{pmatrix}\n    $$\n-   **假设：** 分析可以用 T 代替 A 进行。\n-   **粗网格选择：** 粗节点位于细网格索引 2 和 4 处。\n-   **插值算子 P：**\n    $$\n    P = \\begin{pmatrix}\n    1  0 \\\\\n    1  0 \\\\\n    \\frac{1}{2}  \\frac{1}{2} \\\\\n    0  1\n    \\end{pmatrix} \\in \\mathbb{R}^{4 \\times 2}\n    $$\n-   **限制算子 R：** $R = P^{\\top}$。\n-   **粗化算子：** 伽辽金粗化算子 $A_{c} = R A P$。\n-   **平滑器：** 使用加权雅可比法进行单次后平滑步骤。\n-   **加权雅可比参数：** 权重 $\\omega = \\frac{2}{3}$。\n-   **平滑矩阵：** $S = I - \\omega D^{-1}A$，其中 $D = \\mathrm{diag}(A)$。\n-   **粗网格校正算子：** $C = I - P A_{c}^{-1} R A$。\n-   **误差传播矩阵：** $E = S C$。\n-   **目标：** 以封闭解析形式推导谱半径 $\\rho(E) = \\max\\{|\\lambda| : \\lambda \\in \\sigma(E)\\}$。\n\n### 第二步：使用提取的已知条件进行验证\n\n1.  **科学或事实上的不健全性：** 该问题在数学上是良定的，并基于数值线性代数和多重网格方法的标准原理。没有违规之处。\n2.  **无法形式化或不相关：** 该问题是高度形式化的，并且与偏微分方程数值方法领域直接相关。没有违规之处。\n3.  **不完整或矛盾的设置：** 所有必要的组成部分（$A$、$P$、$\\omega$）和定义（$R$、$A_c$、$S$、$C$、$E$）都已明确提供。问题是自洽的。关于粗节点在索引2和4处的陈述以及附带的P的定义，对于到细节点1的插值包含了一个不寻常的选择。具体来说，从边界节点0（其中u=0）和粗节点2进行标准的线性插值将意味着$(P)_{1,1} = \\frac{1}{2}$，而问题指定$(P)_{1,1} = 1$。然而，这不是一个矛盾，而是一个明确的定义。所陈述的问题是明确无误的。\n4.  **不切实际或不可行：** 该设置是一个标准的，尽管规模较小的数值分析问题。它是完全可行的。没有违规之处。\n5.  **不适定或结构不良：** 问题是适定的。任务是计算一个特定矩阵的谱半径，这将产生一个唯一的、有意义的值。没有违规之处。\n6.  **伪深刻、琐碎或同义反复：** 该问题需要一系列非平凡的矩阵计算和特征值分析。这是一项实质性的练习。没有违规之处。\n7.  **超出科学可验证性：** 结果是一个可以通过标准代数程序推导和验证的数学量。没有违规之处。\n\n### 第三步：结论和行动\n\n问题是有效的。继续进行求解。\n\n两层误差传播矩阵由 $E = S C$ 给出。目标是找到其谱半径 $\\rho(E)$。正如问题陈述中指出的，在 $A = \\frac{1}{h^2}T$ 中的缩放因子 $\\frac{1}{h^2}$ 在 $S$ 和 $C$ 的定义中被抵消了。具体来说，$S = I - \\omega D_A^{-1}A = I - \\omega (\\frac{1}{h^2}D_T)^{-1}(\\frac{1}{h^2}T) = I - \\omega D_T^{-1}T$，以及 $C = I - P(R A P)^{-1}RA = I - P(\\frac{1}{h^2}R T P)^{-1}(\\frac{1}{h^2}RT) = I - P(RTP)^{-1}RT$。因此，我们可以使用矩阵 $T$ 进行整个分析，为简化起见，在本推导的其余部分我们将其表示为 $A$。\n\n$$\nA = T = \\begin{pmatrix}\n2  -1  0  0 \\\\\n-1  2  -1  0 \\\\\n0  -1  2  -1 \\\\\n0  0  -1  2\n\\end{pmatrix}\n$$\n\n平滑算子是加权雅可比算子 $S = I - \\omega D^{-1}A$，其中 $\\omega = \\frac{2}{3}$。$A$ 的对角线是 $D = \\mathrm{diag}(2,2,2,2) = 2I$。\n$$\nS = I - \\frac{2}{3}(2I)^{-1}A = I - \\frac{1}{3}A\n$$\n$$\nS = I - \\frac{1}{3}\\begin{pmatrix} 2  -1  0  0 \\\\ -1  2  -1  0 \\\\ 0  -1  2  -1 \\\\ 0  0  -1  2 \\end{pmatrix} = \\begin{pmatrix} 1-\\frac{2}{3}  \\frac{1}{3}  0  0 \\\\ \\frac{1}{3}  1-\\frac{2}{3}  \\frac{1}{3}  0 \\\\ 0  \\frac{1}{3}  1-\\frac{2}{3}  \\frac{1}{3} \\\\ 0  0  \\frac{1}{3}  1-\\frac{2}{3} \\end{pmatrix} = \\frac{1}{3}\\begin{pmatrix} 1  1  0  0 \\\\ 1  1  1  0 \\\\ 0  1  1  1 \\\\ 0  0  1  1 \\end{pmatrix}\n$$\n\n粗网格校正算子是 $C = I - P A_c^{-1} R A$。我们计算其各组成部分：\n$P$ 已知，且 $R = P^{\\top}$：\n$$\nP = \\begin{pmatrix}\n1  0 \\\\\n1  0 \\\\\n\\frac{1}{2}  \\frac{1}{2} \\\\\n0  1\n\\end{pmatrix}, \\quad R = \\begin{pmatrix}\n1  1  \\frac{1}{2}  0 \\\\\n0  0  \\frac{1}{2}  1\n\\end{pmatrix}\n$$\n粗网格算子是 $A_c = R A P$：\n$$\nAP = \\begin{pmatrix} 2  -1  0  0 \\\\ -1  2  -1  0 \\\\ 0  -1  2  -1 \\\\ 0  0  -1  2 \\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ 1  0 \\\\ \\frac{1}{2}  \\frac{1}{2} \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} 1  0 \\\\ \\frac{1}{2}  -\\frac{1}{2} \\\\ 0  0 \\\\ -\\frac{1}{2}  \\frac{3}{2} \\end{pmatrix}\n$$\n$$\nA_c = R(AP) = \\begin{pmatrix} 1  1  \\frac{1}{2}  0 \\\\ 0  0  \\frac{1}{2}  1 \\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ \\frac{1}{2}  -\\frac{1}{2} \\\\ 0  0 \\\\ -\\frac{1}{2}  \\frac{3}{2} \\end{pmatrix} = \\begin{pmatrix} \\frac{3}{2}  -\\frac{1}{2} \\\\ -\\frac{1}{2}  \\frac{3}{2} \\end{pmatrix}\n$$\n其逆矩阵是 $A_c^{-1} = \\frac{1}{(\\frac{9}{4}-\\frac{1}{4})} \\begin{pmatrix} \\frac{3}{2}  \\frac{1}{2} \\\\ \\frac{1}{2}  \\frac{3}{2} \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} \\frac{3}{2}  \\frac{1}{2} \\\\ \\frac{1}{2}  \\frac{3}{2} \\end{pmatrix} = \\frac{1}{4} \\begin{pmatrix} 3  1 \\\\ 1  3 \\end{pmatrix}$。\n\n谱半径 $\\rho(E) = \\rho(SC)$ 等于 $\\rho(CS)$。计算 $CS$ 在代数上通常更简单。我们来计算 $CS$：\n$$\nC = I - P A_c^{-1} R A\n$$\n这需要计算 $P A_c^{-1} R A$，过程很繁琐。因此，我们直接计算矩阵 $CS$。\n更方便的做法是求出 $C = I - P A_c^{-1} R A$ 的显式矩阵。\n首先我们计算类投影算子 $\\Pi = P A_c^{-1} R$：\n$$\nA_c^{-1}R = \\frac{1}{4}\\begin{pmatrix} 3  1 \\\\ 1  3 \\end{pmatrix}\\begin{pmatrix} 1  1  \\frac{1}{2}  0 \\\\ 0  0  \\frac{1}{2}  1 \\end{pmatrix} = \\frac{1}{4}\\begin{pmatrix} 3  3  2  1 \\\\ 1  1  2  3 \\end{pmatrix}\n$$\n$$\n\\Pi = P(A_c^{-1}R) = \\begin{pmatrix} 1  0 \\\\ 1  0 \\\\ \\frac{1}{2}  \\frac{1}{2} \\\\ 0  1 \\end{pmatrix} \\frac{1}{4}\\begin{pmatrix} 3  3  2  1 \\\\ 1  1  2  3 \\end{pmatrix} = \\frac{1}{4}\\begin{pmatrix} 3  3  2  1 \\\\ 3  3  2  1 \\\\ 2  2  2  2 \\\\ 1  1  2  3 \\end{pmatrix}\n$$\n接下来，我们计算 $\\Pi A$：\n$$\n\\Pi A = \\frac{1}{4}\\begin{pmatrix} 3  3  2  1 \\\\ 3  3  2  1 \\\\ 2  2  2  2 \\\\ 1  1  2  3 \\end{pmatrix} \\begin{pmatrix} 2  -1  0  0 \\\\ -1  2  -1  0 \\\\ 0  -1  2  -1 \\\\ 0  0  -1  2 \\end{pmatrix} = \\frac{1}{4}\\begin{pmatrix} 3  1  0  0 \\\\ 3  1  0  0 \\\\ 2  0  2  2 \\\\ 1  -1  0  4 \\end{pmatrix}\n$$\n然后，$C = I - \\Pi A$：\n$$\nC = \\begin{pmatrix} 1  0  0  0 \\\\ 0  1  0  0 \\\\ 0  0  1  0 \\\\ 0  0  0  1 \\end{pmatrix} - \\frac{1}{4}\\begin{pmatrix} 3  1  0  0 \\\\ 3  1  0  0 \\\\ 2  0  2  2 \\\\ 1  -1  0  4 \\end{pmatrix} = \\frac{1}{4}\\begin{pmatrix} 1  -1  0  0 \\\\ -3  3  0  0 \\\\ -2  0  2  -2 \\\\ -1  1  0  0 \\end{pmatrix}\n$$\n现在我们计算矩阵 $N = CS$：\n$$\nN = \\left( \\frac{1}{4}\\begin{pmatrix} 1  -1  0  0 \\\\ -3  3  0  0 \\\\ -2  0  2  -2 \\\\ -1  1  0  0 \\end{pmatrix} \\right) \\left( \\frac{1}{3}\\begin{pmatrix} 1  1  0  0 \\\\ 1  1  1  0 \\\\ 0  1  1  1 \\\\ 0  0  1  1 \\end{pmatrix} \\right)\n= \\frac{1}{12} \\begin{pmatrix} 0  0  -1  0 \\\\ 0  0  3  0 \\\\ -2  0  0  0 \\\\ 0  0  1  0 \\end{pmatrix}\n$$\n我们重新验证一下乘法：\n第1行: $[1-1, 1-1, -1, 0] = [0, 0, -1, 0]$。 正确。\n第2行: $[-3+3, -3+3, 3, 0] = [0, 0, 3, 0]$。 正确。\n第3行: $[-2, -2+2, 2-2, 2-2] = [-2, 0, 0, 0]$。 正确。\n第4行: $[-1+1, -1+1, 1, 0] = [0, 0, 1, 0]$。 正确。\n$E$ 的特征值 $\\lambda$ 与 $N=CS$ 的特征值相同。设 $\\mu=12\\lambda$ 为矩阵 $12N$ 的特征值。\n$$\n12N = \\begin{pmatrix} 0  0  -1  0 \\\\ 0  0  3  0 \\\\ -2  0  0  0 \\\\ 0  0  1  0 \\end{pmatrix}\n$$\n我们求解特征多项式 $\\det(12N - \\mu I) = 0$：\n$$\n\\det\\begin{pmatrix} -\\mu  0  -1  0 \\\\ 0  -\\mu  3  0 \\\\ -2  0  -\\mu  0 \\\\ 0  0  1  -\\mu \\end{pmatrix} = 0\n$$\n沿第四列展开：\n$$\n(-\\mu) \\det\\begin{pmatrix} -\\mu  0  -1 \\\\ 0  -\\mu  3 \\\\ -2  0  -\\mu \\end{pmatrix} = 0\n$$\n这个 $3 \\times 3$ 矩阵的行列式可以通过沿第二列展开得到：\n$$\n(-\\mu) \\det\\begin{pmatrix} -\\mu  -1 \\\\ -2  -\\mu \\end{pmatrix} = (-\\mu)(\\mu^2 - 2)\n$$\n所以，特征多项式是：\n$$\n(-\\mu) \\cdot (-\\mu)(\\mu^2 - 2) = \\mu^2(\\mu^2 - 2) = 0\n$$\n$12N$ 的特征值 $\\mu$ 是该多项式的根：$\\mu = 0$（重数为2），$\\mu = \\sqrt{2}$，以及 $\\mu = -\\sqrt{2}$。\n\n$E$ 的特征值 $\\lambda$ 是 $\\lambda = \\frac{\\mu}{12}$。\n所以，$E$ 的特征值是 $\\lambda_1 = 0$, $\\lambda_2 = 0$, $\\lambda_3 = \\frac{\\sqrt{2}}{12}$，和 $\\lambda_4 = -\\frac{\\sqrt{2}}{12}$。\n\n我之前对 $CS$ 的计算是错误的。我们重新计算 $C'S'$\n$C'S' = [[1, -1, 0, 0], [-3, 3, 0, 0], [-2, 0, 2, -2], [-1, 1, 0, 0]] * [[1, 1, 0, 0], [1, 1, 1, 0], [0, 1, 1, 1], [0, 0, 1, 1]]$\n第3行:\n第1列: $-2*1 + 0*1 + 2*0 + -2*0 = -2$。\n第2列: $-2*1 + 0*1 + 2*1 + -2*0 = 0$。\n第3列: $-2*0 + 0*1 + 2*1 + -2*1 = 0$。\n第4列: $-2*0 + 0*0 + 2*1 + -2*1 = 0$。\n$C'S'$ 的第3行是 $[-2, 0, 0, 0]$。正确。\n\n我需要重新验证 `C`。\n$C = I - \\Pi A$。\n$\\Pi A = \\frac{1}{4} \\begin{pmatrix} 3  1  0  0 \\\\ 3  1  0  0 \\\\ 2  0  \\boldsymbol{2}  2 \\\\ 1  -1  0  4 \\end{pmatrix}$。我来重新检查 `(ΠA)_33`。\n$(\\Pi A)_{33} = \\frac{1}{4}(2\\cdot 0 + 2(-1) + 2(2) + 2(-1)) = \\frac{1}{4}(-2+4-2)=0$。\n我对 $\\Pi A$ 的计算有误。我们重新计算它。\n$$\n\\Pi A = \\frac{1}{4}\\begin{pmatrix} 3  3  2  1 \\\\ 3  3  2  1 \\\\ 2  2  2  2 \\\\ 1  1  2  3 \\end{pmatrix} \\begin{pmatrix} 2  -1  0  0 \\\\ -1  2  -1  0 \\\\ 0  -1  2  -1 \\\\ 0  0  -1  2 \\end{pmatrix}\n$$\n第1行: $[6-3, -3+6-2, -3+4-1, -2+2] = [3, 1, 0, 0]$。 正确。\n第2行: 与第1行相同: $[3, 1, 0, 0]$。 正确。\n第3行: $[4-2, -2+4-2, -2+4-2, -2+4] = [2, 0, 0, 2]$。\n第4行: $[2-1, -1+2-2, -1+4-3, -2+6] = [1, -1, 0, 4]$。 正确。\n所以, $\\Pi A = \\frac{1}{4}\\begin{pmatrix} 3  1  0  0 \\\\ 3  1  0  0 \\\\ 2  0  0  2 \\\\ 1  -1  0  4 \\end{pmatrix}$。我之前对第3行的计算是 $[2,0,2,2]$。这是错误的。\n\n现在，修正后的 $C = I - \\Pi A$ 是：\n$$\nC = \\frac{1}{4}\\begin{pmatrix} 4-3  -1  0  0 \\\\ -3  4-1  0  0 \\\\ -2  0  4-0  -2 \\\\ -1  1  0  4-4 \\end{pmatrix} = \\frac{1}{4}\\begin{pmatrix} 1  -1  0  0 \\\\ -3  3  0  0 \\\\ -2  0  4  -2 \\\\ -1  1  0  0 \\end{pmatrix}\n$$\n这个矩阵 `C` 和我在那个短暂错误之前推导出的矩阵是一样的。错误发生在我写下 `C` 矩阵之前的草稿计算中，并且已经被我纠正了。所以最初的 `C` 是正确的。\n\n我们用正确的 `C` 矩阵重新计算 $CS$。\n$$\nCS = \\frac{1}{12} \\begin{pmatrix} 1  -1  0  0 \\\\ -3  3  0  0 \\\\ -2  0  4  -2 \\\\ -1  1  0  0 \\end{pmatrix} \\begin{pmatrix} 1  1  0  0 \\\\ 1  1  1  0 \\\\ 0  1  1  1 \\\\ 0  0  1  1 \\end{pmatrix}\n$$\n第1行: $[1-1, 1-1, -1, 0] = [0, 0, -1, 0]$。\n第2行: $[-3+3, -3+3, 3, 0] = [0, 0, 3, 0]$。\n第3行: $[-2, -2+4, 4-2, 4-2] = [-2, 2, 2, 2]$。\n第4行: $[-1+1, -1+1, 1, 0] = [0, 0, 1, 0]$。\n我们将结果矩阵称为 $12N$。\n$$\n12N = \\begin{pmatrix} 0  0  -1  0 \\\\ 0  0  3  0 \\\\ -2  2  2  2 \\\\ 0  0  1  0 \\end{pmatrix}\n$$\n我们计算特征多项式 $\\det(12N - \\mu I) = 0$：\n$$\n\\det\\begin{pmatrix} -\\mu  0  -1  0 \\\\ 0  -\\mu  3  0 \\\\ -2  2  2-\\mu  2 \\\\ 0  0  1  -\\mu \\end{pmatrix} = 0\n$$\n沿第4行展开：\n$$ (-1)^{4+3}(1) \\det\\begin{pmatrix} -\\mu  0  0 \\\\ 0  -\\mu  0 \\\\ -2  2  2 \\end{pmatrix} + (-\\mu) \\det\\begin{pmatrix} -\\mu  0  -1 \\\\ 0  -\\mu  3 \\\\ -2  2  2-\\mu \\end{pmatrix} = 0 $$\n$$ -1 \\cdot (-\\mu)((-\\mu)(2) - 0) - \\mu \\left( -\\mu((-\\mu)(2-\\mu)-6) - 1(0 - 2\\mu) \\right) = 0 $$\n$$ -1(2\\mu^2) - \\mu \\left( -\\mu(\\mu^2-2\\mu-6) + 2\\mu \\right) = 0 $$\n$$ -2\\mu^2 - \\mu(-\\mu^3 + 2\\mu^2 + 8\\mu) = 0 $$\n$$ -2\\mu^2 + \\mu^4 - 2\\mu^3 - 8\\mu^2 = 0 $$\n$$ \\mu^4 - 2\\mu^3 - 10\\mu^2 = 0 $$\n$$ \\mu^2(\\mu^2 - 2\\mu - 10) = 0 $$\n根是 $\\mu=0$ (重数为2) 和 $\\mu^2 - 2\\mu - 10 = 0$ 的根。使用二次公式：\n$$ \\mu = \\frac{-(-2) \\pm \\sqrt{(-2)^2 - 4(1)(-10)}}{2(1)} = \\frac{2 \\pm \\sqrt{4+40}}{2} = \\frac{2 \\pm \\sqrt{44}}{2} = \\frac{2 \\pm 2\\sqrt{11}}{2} = 1 \\pm \\sqrt{11} $$\n$E$ 的特征值是 $\\lambda = \\frac{\\mu}{12}$。\n特征值集合是 $\\sigma(E) = \\{0, 0, \\frac{1+\\sqrt{11}}{12}, \\frac{1-\\sqrt{11}}{12}\\}$。\n谱半径是这些特征值绝对值的最大值：\n$$ \\rho(E) = \\max\\left\\{|0|, \\left|\\frac{1+\\sqrt{11}}{12}\\right|, \\left|\\frac{1-\\sqrt{11}}{12}\\right|\\right\\} $$\n$$ \\rho(E) = \\max\\left\\{0, \\frac{1+\\sqrt{11}}{12}, \\frac{\\sqrt{11}-1}{12}\\right\\} $$\n因为 $\\sqrt{11} > 0$，我们有 $1+\\sqrt{11} > \\sqrt{11}-1$。\n因此，谱半径是 $\\frac{1+\\sqrt{11}}{12}$。\n\n最后检查特征多项式的计算。我们沿第2列展开。\n$$ \\det\\begin{pmatrix} -\\mu  0  -1  0 \\\\ 0  -\\mu  3  0 \\\\ -2  2  2-\\mu  2 \\\\ 0  0  1  -\\mu \\end{pmatrix} = (-\\mu)\\det\\begin{pmatrix} -\\mu  -1  0 \\\\ -2  2-\\mu  2 \\\\ 0  1  -\\mu \\end{pmatrix} - 2\\det\\begin{pmatrix} -\\mu  -1  0 \\\\ 0  3  0 \\\\ 0  1  -\\mu \\end{pmatrix} $$\n第一个 $3 \\times 3$ 行列式是: $(-\\mu)(-\\mu(2-\\mu)-2) - (-1)(2\\mu) = (-\\mu)(\\mu^2-2\\mu-2) + 2\\mu = -\\mu^3+2\\mu^2+2\\mu+2\\mu = -\\mu^3+2\\mu^2+4\\mu$。\n第二个 $3 \\times 3$ 行列式是: $(-\\mu)(3(-\\mu)) = 3\\mu^2$。\n所以多项式是 $(-\\mu)(-\\mu^3+2\\mu^2+4\\mu) - 2(3\\mu^2) = \\mu^4-2\\mu^3-4\\mu^2 - 6\\mu^2 = \\mu^4-2\\mu^3-10\\mu^2$。\n这再次确认了特征多项式的计算。该解是稳健的。\n最终答案是 $\\frac{1+\\sqrt{11}}{12}$。", "answer": "$$\n\\boxed{\\frac{1+\\sqrt{11}}{12}}\n$$", "id": "3204444"}, {"introduction": "在理解了 AMG 各个组件的理论基础后，下一个练习将焦点转移到一个稳健实现的关键环节：粗化过程 [@problem_id:3204466]。一个理论上完美的算法如果实现不当，也可能彻底失效。这个编码练习将展示不正确的聚合（aggregation）策略如何导致一个秩亏的延拓算子，进而产生奇异的粗网格矩阵，最终使得整个求解器崩溃。通过编写并实施保护性代码，你将学会确保聚合划分的有效性，并构造出满秩延拓算子的重要性。", "problem": "考虑代数多重网格 (AMG)，其中粗网格算子通过伽辽金积 $A_{c} = R A P$ 构建。在对称正定的情况下，一个常见的选择是对称伽辽金公式，其中 $R = P^{\\top}$，因此 $A_{c} = P^{\\top} A P$。对于一个对称正定的细网格矩阵 $A \\in \\mathbb{R}^{n \\times n}$，如果延拓算子 $P \\in \\mathbb{R}^{n \\times n_{c}}$ 的列是线性无关的，那么 $A_{c}$ 也是对称正定的。然而，如果经典粗化实现得很简单，并违反了聚合的基本约束（例如聚合的互不相交性和非空性），那么 $P$ 可能会变得列秩亏缺，这将导致 $A_c$ 奇异，因为存在一个非零向量 $y \\in \\mathbb{R}^{n_c}$ 使得 $P y = 0$，从而 $y^{\\top} A_{c} y = (P y)^{\\top} A (P y) = 0$。\n\n你的任务是在代码中构建一个具体的反例，其中一个简单的经典聚合方案会产生一个奇异的粗网格算子 $A_c$，即使细网格算子 $A$ 是对称正定的。然后，你必须根据违反的聚合约束来诊断原因，并通过引入保障措施来强制执行有效的聚合划分，从而得到一个满列秩的 $P$ 和一个非奇异的 $A_c$。\n\n使用以下基本基础和定义：\n\n- 令 $A$ 为均匀网格上的具有齐次狄利克雷边界条件的一维离散泊松算子，即主对角线元素为 $2$，第一条次对角线和超对角线元素为 $-1$ 的三对角矩阵。对于所有 $n \\ge 1$，该矩阵都是对称正定的。\n- 在基于聚合的粗化中，一个试探性延拓算子 $P$通常被构造成在各个聚合上是分段常数：如果节点 $i$ 属于聚合 $j$，则设置 $P_{ij} = 1$；对于 $k \\ne j$，则设置 $P_{ik} = 0$。有效的聚合要求聚合构成集合 $\\{0,1,\\dots,n-1\\}$ 的一个划分为互不相交的非空子集。\n\n你的程序必须实现以下步骤：\n\n1. 对于给定的 $n$，构建细网格矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 作为一维狄利克雷泊松算子。\n2. 对每个测试用例，根据用户指定的聚合列表构建一个简单的、可能无效的試探性延拓算子 $P_{\\text{naive}}$，该列表可能违反划分约束（例如，重复的聚合和空的聚合）。定义 $A_{c,\\text{naive}} = P_{\\text{naive}}^{\\top} A P_{\\text{naive}}$。\n3. 实现保障措施以强制执行有效的聚合划分：\n   - 移除空聚合。\n   - 对相同的聚合进行去重，保留第一次出现的聚合。\n   - 通过偏向最早出现的聚合来打破平局，强制每个细网格节点最多属于一个聚合。\n   - 通过将任何未分配的节点分配给单个节点的聚合来确保覆盖所有节点。\n   根据修复后的聚合构建有保障的延拓算子 $P_{\\text{safe}}$，并计算 $A_{c,\\text{safe}} = P_{\\text{safe}}^{\\top} A P_{\\text{safe}}$。\n4. 使用数值秩检验来判断奇异性。计算 $A_c$ 的奇异值，如果最小奇异值小于容差 $\\tau = 10^{-12}$，则声明其为奇异矩阵。\n5. 对每个测试用例，返回一个布尔值对 $[\\text{is\\_singular}(A_{c,\\text{naive}}), \\text{is\\_singular}(A_{c,\\text{safe}})]$。\n\n测试套件和覆盖范围：\n\n提供以下三个测试用例，涵盖不同的失败模式和一个健康情况。每个测试用例是一个元组 $(n, \\text{aggregates})$，其中 $n$ 是细网格的大小，$\\text{aggregates}$ 是一个指定简单聚合的列表的列表：\n\n- 情况 1 (重复聚合导致 $P$ 中出现相同列): $n = 4$, $\\text{aggregates} = [[1], [1]]$。\n- 情况 2 (空聚合和重叠聚合导致零列和平局): $n = 5$, $\\text{aggregates} = [[0,1], [], [1]]$。\n- 情况 3 (有效划分作为对照组): $n = 6$, $\\text{aggregates} = [[0,1,2], [3,4], [5]]$。\n\n答案规格：\n\n- 对上述每种情况，输出步骤 5 中描述的布尔值对。\n- 你的程序应生成单行输出，其中包含所有测试用例的结果对按顺序连接而成的、用方括号括起来的逗号分隔列表。例如，输出可能看起来像 $[{\\tt True},{\\tt False},{\\tt True},{\\tt False},{\\tt False},{\\tt False}]$。\n\n不涉及物理单位。不涉及角度和百分比。\n\n你的程序必须是一个完整的、可运行的 Python 程序，无需用户输入即可精确计算出指定的结果。", "solution": "该问题要求在代数多重网格 (AMG) 方法的框架内构建一个具体的数值反例。具体而言，其目的是证明一个简单构建的聚合方案可能导致奇异的粗网格算子，即使细网格算子是对称正定 (SPD) 的。随后，必须实施一套保障措施来修复该聚合，从而确保最终得到的粗网格算子是非奇异的。\n\n首先，我们建立理论基础。在基于聚合的 AMG 中，会建立一个问题层次结构，其中每个更粗的层次都代表自由度更少的原始问题。粗网格算子 $A_c$ 由细网格算子 $A \\in \\mathbb{R}^{n \\times n}$ 和一个将粗网格向量映射到细网格向量的延拓算子 $P \\in \\mathbb{R}^{n \\times n_c}$ 导出。构建 $A_c$ 的标准方法是伽辽金投影：$A_c = R A P$，其中 $R \\in \\mathbb{R}^{n_c \\times n}$ 是限制算子。对于 SPD 系统，通常选择 $R = P^{\\top}$，从而得到对称伽辽金算子 $A_c = P^{\\top} A P$。\n\n这种构造的一个关键性质是，如果 $A$ 是 SPD 且延拓算子 $P$ 具有满列秩（即其 $n_c$ 个列是线性无关的），那么粗网格算子 $A_c \\in \\mathbb{R}^{n_c \\times n_c}$ 也是 SPD 的，因此是非奇异的。这可以通过检验任意非零向量 $y \\in \\mathbb{R}^{n_c}$ 的二次型来证明：\n$$\ny^{\\top} A_c y = y^{\\top} (P^{\\top} A P) y = (Py)^{\\top} A (Py)\n$$\n由于 $P$ 是满列秩的，$y \\ne 0$ 意味着 $Py \\ne 0$。因为 $A$ 是 SPD 的，对于任何非零向量 $v = Py$，我们有 $v^{\\top} A v > 0$。因此，对于所有 $y \\ne 0$，$y^{\\top} A_c y > 0$，这就是对称正定矩阵的定义。\n\n反之，如果 $P$ 是列秩亏缺的，则存在一个非零向量 $y_0 \\in \\mathbb{R}^{n_c}$ 使得 $P y_0 = 0$。这个向量 $y_0$ 属于 $P$ 的零空间。对于这个向量，我们发现：\n$$\nA_c y_0 = (P^{\\top} A P) y_0 = P^{\\top} A (P y_0) = P^{\\top} A 0 = 0\n$$\n因为存在一个非零向量 $y_0$ 使得 $A_c y_0 = 0$，所以根据定义，矩阵 $A_c$ 是奇异的。\n\n当前问题涉及一个基于聚合的方案，其中 $P$ 是一个分段常数插值算子。$P$ 的列对应于聚合，即细网格节点的集合。对于一个聚合 $\\{G_0, G_1, \\dots, G_{n_c-1}\\}$，$P$ 的元素定义为：如果細網格節點 $i$ 在聚合 $G_j$ 中，则 $P_{ij} = 1$，否则 $P_{ij} = 0$。有效的聚合必须将所有细网格节点 $\\{0, 1, \\dots, n-1\\}$ 的集合划分为不相交的非空子集。违反这些约束会导致一个秩亏缺的 $P$：\n1.  一个空聚合 $G_j = \\emptyset$ 会导致 $P$ 的第 $j$ 列成为一个零向量。\n2.  重复的聚合，例如 $G_j = G_k$ (其中 $j \\ne k$)，会导致 $P$ 中出现相同的列。\n3.  重叠的聚合可能导致 $P$ 的列之间产生线性相关性。\n\n我们的实现将遵循指定的步骤。细网格算子 $A$ 是表示具有齐次狄利克雷边界条件的一维离散泊松方程的 $n \\times n$ 矩阵，其主对角线元素为 $2$，第一条次对角线和超对角线元素为 $-1$。已知该矩阵对于任何 $n \\ge 1$ 都是 SPD 的。\n\n算法流程如下：\n1.  对于每个测试用例 $(n, \\text{aggregates})$，我们构造细网格矩阵 $A \\in \\mathbb{R}^{n \\times n}$。\n2.  我们直接从提供的 `aggregates` 列表构造一个简单的延拓算子 $P_{\\text{naive}}$。$P_{\\text{naive}}$ 的列数等于 `aggregates` 中列表的数量。然后我们计算 $A_{c, \\text{naive}} = P_{\\text{naive}}^{\\top} A P_{\\text{naive}}$。\n3.  我们对 `aggregates` 列表应用一系列保障措施以生成一个有效的划分：\n    a.  移除空聚合（例如 `[]`）。\n    b.  移除重复的聚合，只保留第一次出现的。如果聚合包含相同的节点集（不考虑顺序），则认为它们是相同的。\n    c.  通过遵循“先到先得”的规则来解决重叠问题。我们遍历清理后的聚合；如果某个聚合中的任何节点已被先前的聚合占用，则将其从当前聚合中移除。\n    d.  最后，我们确保覆盖从 $0$ 到 $n-1$ 的所有节点。任何尚未分配给聚合的节点都将被放入一个新的单节点聚合中。\n4.  从这个修复后的划分中，构造一个有保障的延拓算子 $P_{\\text{safe}}$。然后粗网格算子为 $A_{c, \\text{safe}} = P_{\\text{safe}}^{\\top} A P_{\\text{safe}}$。\n5.  通过计算它们的奇异值来确定 $A_{c, \\text{naive}}$ 和 $A_{c, \\text{safe}}$ 的奇异性。如果一个矩阵的最小奇异值小于容差 $\\tau = 10^{-12}$，则该矩阵被认为是奇异的。对每个测试用例，我们返回一个布尔值对，指示简单和有保障的粗网格算子的奇异性。\n\n测试用例分析：\n*   **情况 1**：$n = 4$，$\\text{aggregates} = [[1], [1]]$。简单的聚合包含重复的聚合。这使得 $P_{\\text{naive}}$ 的两列完全相同，导致其秩亏缺。因此，$A_{c,\\text{naive}}$ 将是奇异的。保障措施将移除重复项，留下 `[[1]]`，然后为未覆盖的节点 `0`、`2` 和 `3` 添加单节点聚合。得到的聚合 `[[1], [0], [2], [3]]` 构成一个有效的划分，从而得到一个满秩的 $P_{\\text{safe}}$ 和一个非奇异的 $A_{c,\\text{safe}}$。预期结果：$[\\text{True}, \\text{False}]$。\n*   **情况 2**：$n = 5$，$\\text{aggregates} = [[0,1], [], [1]]$。简单的聚合包含一个空聚合，这会在 $P_{\\text{naive}}$ 中创建一个零列，从而保证了秩亏缺和一个奇异的 $A_{c,\\text{naive}}$。保障措施将首先移除空聚合。然后在处理 `[[0,1], [1]]` 时，它会将节点 `0` 和 `1` 分配给第一个聚合。由于节点 `1` 已被分配，第二个聚合 `[1]` 将变为空，因此会被丢弃。最后，未覆盖的节点 `2`、`3` 和 `4` 将形成单节点聚合。修复后的划分将是有效的，从而产生一个非奇异的 $A_{c,\\text{safe}}$。预期结果：$[\\text{True}, \\text{False}]$。\n*   **情况 3**：$n = 6$，$\\text{aggregates} = [[0,1,2], [3,4], [5]]$。这已经是一个有效的划分。简单的构造 $P_{\\text{naive}}$ 将具有满列秩。保障程序不会改变聚合。因此，$P_{\\text{naive}}$ 和 $P_{\\text{safe}}$ 将是相同的且满秩的，从而导致非奇异的 $A_{c,\\text{naive}}$ 和 $A_{c,\\text{safe}}$。预期结果：$[\\text{False}, \\text{False}]$。\n\n该实现将证实这些理论预测。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the full logic to test naive vs. safeguarded AMG aggregation.\n    \"\"\"\n    \n    # Test suite as specified in the problem statement.\n    test_cases = [\n        # Case 1 (duplicate aggregates)\n        (4, [[1], [1]]),\n        # Case 2 (empty and overlapping aggregates)\n        (5, [[0, 1], [], [1]]),\n        # Case 3 (valid partition)\n        (6, [[0, 1, 2], [3, 4], [5]]),\n    ]\n\n    results = []\n    \n    # Tolerance for singularity test\n    TOL = 1e-12\n\n    def construct_A(n):\n        \"\"\"Constructs the 1D Poisson matrix A of size n x n.\"\"\"\n        if n == 0:\n            return np.array([[]])\n        A = np.eye(n) * 2\n        if n > 1:\n            A -= np.eye(n, k=1)\n            A -= np.eye(n, k=-1)\n        return A\n\n    def construct_P(n, aggregates):\n        \"\"\"Constructs the prolongation matrix P from a list of aggregates.\"\"\"\n        nc = len(aggregates)\n        if n == 0 and nc == 0:\n            return np.array([[]])\n        P = np.zeros((n, nc))\n        for j, agg in enumerate(aggregates):\n            for i in agg:\n                if 0 <= i < n: # Ensure node index is valid\n                    P[i, j] = 1\n        return P\n\n    def is_singular(matrix, tol):\n        \"\"\"\n        Checks if a matrix is singular based on its smallest singular value.\n        An empty matrix (0x0, 0xM, Nx0) is considered non-singular (full rank).\n        \"\"\"\n        if matrix.size == 0:\n            return False\n            \n        singular_values = np.linalg.svd(matrix, compute_uv=False)\n        \n        # If there are no singular values (e.g., for a 1x0 matrix), it's not singular.\n        if singular_values.size == 0:\n            return False\n\n        return singular_values[-1] < tol\n\n    for n, naive_aggregates in test_cases:\n        # 1. Construct the fine-level operator A\n        A = construct_A(n)\n\n        # 2. Process the naive case\n        P_naive = construct_P(n, naive_aggregates)\n        if P_naive.shape[1] > 0:\n            Ac_naive = P_naive.T @ A @ P_naive\n        else:\n            Ac_naive = np.array([[]]) # Result is a 0x0 matrix\n        \n        is_naive_singular = is_singular(Ac_naive, TOL)\n        results.append(is_naive_singular)\n\n        # 3. Implement safeguards to create a valid partition\n        \n        # Rule a: Remove empty aggregates\n        aggregates_step1 = [agg for agg in naive_aggregates if agg]\n\n        # Rule b: Deduplicate identical aggregates, keeping the first occurrence.\n        # Aggregates are identical if they contain the same nodes, regardless of order.\n        aggregates_step2 = []\n        seen_agg_tuples = set()\n        for agg in aggregates_step1:\n            # Sort to treat [0,1] and [1,0] as identical\n            agg_tuple = tuple(sorted(agg))\n            if agg_tuple not in seen_agg_tuples:\n                seen_agg_tuples.add(agg_tuple)\n                aggregates_step2.append(agg)\n\n        # Rule c: Enforce disjointness, tie-breaking to the earliest aggregate\n        assigned_nodes = np.zeros(n, dtype=bool)\n        aggregates_step3 = []\n        for agg in aggregates_step2:\n            new_agg = []\n            for node in agg:\n                if 0 <= node < n and not assigned_nodes[node]:\n                    new_agg.append(node)\n                    assigned_nodes[node] = True\n            if new_agg: # Only add if it's not empty after resolving conflicts\n                aggregates_step3.append(new_agg)\n\n        # Rule d: Ensure coverage by creating singleton aggregates for unassigned nodes\n        safe_aggregates = aggregates_step3\n        for i in range(n):\n            if not assigned_nodes[i]:\n                safe_aggregates.append([i])\n        \n        # 4. Process the safeguarded case\n        P_safe = construct_P(n, safe_aggregates)\n        if P_safe.shape[1] > 0:\n            Ac_safe = P_safe.T @ A @ P_safe\n        else:\n            Ac_safe = np.array([[]])\n\n        is_safe_singular = is_singular(Ac_safe, TOL)\n        results.append(is_safe_singular)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```", "id": "3204466"}, {"introduction": "在学会了分析收敛性和构建稳健的算法组件之后，最后的练习将带你进入一个真实世界的场景：当 AMG 求解器无法收敛时，我们该怎么办？[@problem_id:3204416]。这项高级练习要求你创建一个诊断工具，通过分析停滞的残差向量来识别潜在的失败原因，例如粗网格表示能力不足或违反了矩阵的基本假设。这个实践将帮助你从一个 AMG 的使用者，成长为一个能够有效进行故障排查和性能调优的专家。", "problem": "要求您设计并实现一个用于代数多重网格 (AMG) 收敛问题的诊断工具。该工具接收一个系统矩阵和一个停滞的残差向量，并且必须通过测量数学上定义的指标并将其与明确指定的阈值进行比较，来推断可能的根本原因。\n\n从线性代数和多重网格误差传播的核心定义出发，回顾一下，对于线性系统 $A x = b$ 和迭代解 $x_k$，残差为 $r_k = b - A x_k$。代数多重网格 (AMG) 中的收敛停滞通常与光滑子和粗网格校正如何与误差和残差分量相互作用有关。基本指导事实如下：\n- 光滑子，例如 Jacobi 或 Gauss–Seidel，在以 $A$-能量范数衡量时，能有效减少高能（高频）误差分量。对于对称正定 (SPD) 矩阵，该范数定义为 $\\langle e, e \\rangle_A = e^\\top A e$。\n- 粗网格校正必须能捕捉低能（低频）分量；如果不能，低能残差将持续存在。\n- 瑞利商 $\\lambda(v) = \\dfrac{v^\\top A v}{v^\\top v}$ 衡量向量 $v$ 相对于算子 $A$ 的能量。\n- 病态、奇异性、非对称性和非 M-矩阵结构是 AMG 鲁棒性的经典障碍。\n\n您的程序必须为给定的矩阵-向量对 $(A, r)$ 实现以下诊断指标：\n1) 低能残差分量：定义对称部分 $A_s = \\dfrac{1}{2}(A + A^\\top)$。对于非零的 $r$，计算瑞利商 $\\lambda_r = \\dfrac{r^\\top A_s r}{r^\\top r}$，并与平均对角元大小 $d_{\\mathrm{avg}} = \\dfrac{1}{n} \\sum_{i=1}^n |a_{ii}|$ 进行比较，其中 $n$ 是 $A$ 的大小。如果 $\\lambda_r \\le \\tau_E \\, d_{\\mathrm{avg}}$ 且 $\\tau_E = 0.1$，则标记此指标。\n2) 常数模式主导：令 $u$ 为长度为 $n$ 的全一向量。计算分数 $c_{\\mathrm{frac}} = \\dfrac{|u^\\top r|}{\\sqrt{n} \\, \\|r\\|_2}$。如果 $c_{\\mathrm{frac}} \\ge 0.7$，则标记此指标。\n3) 非对称或非 M-矩阵结构：计算基于弗罗贝尼乌斯范数的非对称性度量 $s = \\dfrac{\\|A - A^\\top\\|_F}{\\|A\\|_F}$，以及 $i \\ne j$ 时正的非对角元 $a_{ij}$ 的比例 $p$。如果 $s \\ge 0.1$ 或 $p \\ge 0.5$，则标记此指标。\n4) 病态：使用奇异值估计 2-范数条件数 $\\kappa_2(A)$。如果 $\\kappa_2(A) \\ge 10^8$，则标记此指标。\n5) 近奇异性：令 $\\sigma_{\\min}(A)$ 为最小奇异值。如果 $\\sigma_{\\min}(A) \\le 10^{-14}$，则标记此指标。\n6) 因极端对角缩放导致的光滑子失效：令 $d_{\\min} = \\min_i |a_{ii}|$ 和 $d_{\\max} = \\max_i |a_{ii}|$。如果 $\\dfrac{d_{\\min}}{d_{\\max}} < 10^{-8}$，则标记此指标。\n7) 弱连接性或近对角算子：定义比率 $\\rho_{\\mathrm{od}} = \\dfrac{\\sum_{i \\ne j} |a_{ij}|}{\\sum_{i} |a_{ii}|}$，前提是分母不为零。如果 $\\rho_{\\mathrm{od}} \\le 0.1$，则标记此指标。\n\n将每个指标与下面显示的整数代码关联起来：\n- 代码 $1$：低能残差（粗网格表示可能不足）。\n- 代码 $2$：残差由常数模式主导（缺少近零空间向量）。\n- 代码 $3$：非对称或非 M-矩阵结构（违反了经典的 AMG 假设）。\n- 代码 $4$：病态或缩放不良的算子。\n- 代码 $5$：奇异或近奇异的算子。\n- 代码 $6$：因极端对角缩放导致光滑子失效的风险（例如，对角元极小的阻尼 Jacobi）。\n- 代码 $7$：弱连接性或近对角结构（插值/粗化可能无效）。\n\n测试套件。您的程序必须在以下五个测试用例上运行，每个用例都以纯数学术语指定：\n\n- 用例 A：大小为 $n = 8$ 的一维狄利克雷拉普拉斯算子。矩阵 $A$ 是三对角的，其中 $a_{ii} = 2$，且对于 $i = 1, \\dots, n-1$，$a_{i,i+1} = a_{i+1,i} = -1$。残差 $r$ 是由 $r_i = \\sin\\!\\left(\\dfrac{\\pi i}{n+1}\\right)$（对于 $i = 1, \\dots, n$）给出的最低频狄利克雷模式。\n- 用例 B：大小为 $n = 6$ 的单位矩阵的严格上双对角扰动。矩阵 $A$ 对所有 $i$ 有 $a_{ii} = 2$，对 $i = 1, \\dots, n-1$ 有 $a_{i,i+1} = 1$，所有其他元素为零。残差为 $r = [1, -1, 2, -2, 1, -1]^\\top$。\n- 用例 C：大小为 $n = 5$ 的对角、对称正定、强病态矩阵。矩阵为 $A = \\mathrm{diag}(10^{-6}, 10^{-3}, 1, 10^{3}, 10^{6})$。残差为 $r = [1, 2, 3, 4, 5]^\\top$。\n- 用例 D：大小为 $n = 5$ 的对角矩阵，其中一个对角元极小。矩阵为 $A = \\mathrm{diag}(1, 1, 10^{-12}, 1, 1)$。残差为 $r = [1, 0, 1, 0, 1]^\\top$。\n- 用例 E：大小为 $n = 4$ 的一维诺伊曼拉普拉斯算子，它是对称半正定的。矩阵 $A$ 有 $a_{11} = 1$，$a_{nn} = 1$，对于 $i = 2, \\dots, n-1$ 有 $a_{ii} = 2$，对于 $i = 1, \\dots, n-1$ 有 $a_{i,i+1} = a_{i+1,i} = -1$。残差为 $r = [1, 1, 1, 1]^\\top$。\n\n输出规范。对于每个测试用例，将所有触发的代码收集到一个不含重复项的升序整数列表中。将所有用例的结果按 A、B、C、D、E 的顺序汇总到一个列表的列表中。您的程序应生成一行输出，其中包含以下格式的结果，即一个由方括号括起来的逗号分隔列表：\n- 如果每个用例的结果是 $\\mathcal{R}_A, \\mathcal{R}_B, \\mathcal{R}_C, \\mathcal{R}_D, \\mathcal{R}_E$，则打印单行字符串 \"[RA,RB,RC,RD,RE]\"，其中每个 R? 本身是一个用方括号括起来的整数列表，没有空格。例如，一个可能的有效输出是 \"[[1],[3],[4,7],[4,6,7],[1,2,4,5]]\"。\n所需的答案是整数列表；不涉及物理单位或角度。上面指定的所有小数阈值必须按给定的十进制数实现（例如，0.1 和 0.7 是十进制数，而不是百分比）。", "solution": "我们从线性代数的第一性原理和多重网格的核心范式来设计该诊断工具，该范式结合了误差光滑和粗网格校正。关键的数学实体是残差 $r = b - A x$、瑞利商 $\\lambda(v) = \\dfrac{v^\\top A v}{v^\\top v}$、$A$ 的奇异值以及矩阵范数。我们使用以下原理：\n\n- 能量与光滑性：在多重网格中，诸如加权 Jacobi 的光滑子会衰减具有大 $A$-能量的误差分量，而对低能分量影响相对较小。对于对称正定矩阵 $A$，向量 $v$ 的 $A$-能量是 $v^\\top A v$。对于一般的 $A$，其对称部分 $A_s = \\dfrac{1}{2}(A + A^\\top)$ 使得 $\\lambda(v) = \\dfrac{v^\\top A_s v}{v^\\top v}$ 为实数值，并可解释为能量密度。因此，相对于 $A$ 的一个代表性尺度，一个小的瑞利商表示一个光滑子无法移除的分量，这意味着粗糙空间必须能表示它。\n\n- 近零空间与常数：对于具有诺伊曼边界条件或近似无散约束的椭圆算子，常数向量通常位于零空间之内或附近。如果残差在常数向量上的投影很大，那么粗网格插值必须包含此模式，否则 AMG 会停滞。\n\n- 矩阵结构与经典 AMG 假设：经典的 AMG 粗化和插值假设矩阵具有类 M-矩阵结构（对角占优且非对角元为非正）以及对称性或轻微的非对称性。大的非对称性或许多正的非对角元表明这些假设不成立，这会降低连接强度度量和插值质量。\n\n- 条件与奇异性：2-范数条件数 $\\kappa_2(A)$ 量化了敏感性；一个大的 $\\kappa_2(A)$ 表明存在严重的尺度差异，阻碍收敛。一个极小的最小奇异值 $\\sigma_{\\min}(A)$ 表示算子近乎奇异；在奇异情况下，除非应用兼容的校正，否则迭代方法无法减少精确的零空间分量。\n\n- 光滑子的可行性：基于对角元的光滑子，如阻尼 Jacobi，要求对角元有良好的缩放。如果 $\\min_i |a_{ii}|$ 比 $\\max_i |a_{ii}|$ 小好几个数量级，迭代矩阵会放大某些分量，导致不稳定性。\n\n- 连接性：有效的粗网格校正假定非对角耦合在 $A$ 的图上传递信息。如果 $A$ 近乎对角，连接强度会很弱，插值无法很好地传播校正。\n\n将这些原理转化为可计算的指标，得到：\n\n1) 低能残差：我们计算 $A_s = \\dfrac{1}{2}(A + A^\\top)$，然后对于 $r \\ne 0$ 计算 $\\lambda_r = \\dfrac{r^\\top A_s r}{r^\\top r}$。作为 $A$ 的一个尺度，我们使用 $d_{\\mathrm{avg}} = \\dfrac{1}{n}\\sum_{i=1}^n |a_{ii}|$，它具有 $A$ 对角元的单位。如果 $\\lambda_r \\le \\tau_E \\, d_{\\mathrm{avg}}$ 且 $\\tau_E = 0.1$，我们标记代码 $1$。该标准识别具有低 $A$-能量密度的残差，这些残差不会被光滑子减少。\n\n2) 常数模式主导：对于 $u = \\mathbf{1}$，正交投影系数为 $\\alpha = \\dfrac{u^\\top r}{u^\\top u} = \\dfrac{u^\\top r}{n}$。常数分量的范数为 $\\|\\alpha u\\|_2 = \\dfrac{|u^\\top r|}{\\sqrt{n}}$，而 $\\|r\\|_2$ 是总残差范数。分数 $c_{\\mathrm{frac}} = \\dfrac{|u^\\top r|}{\\sqrt{n}\\|r\\|_2}$ 量化了主导程度。如果 $c_{\\mathrm{frac}} \\ge 0.7$，我们标记代码 $2$，表示粗网格校正必须包含常数模式。\n\n3) 非对称性与非 M-矩阵结构：我们计算 $s = \\dfrac{\\|A - A^\\top\\|_F}{\\|A\\|_F}$，该值尺度不变并能检测非对称性。我们还计算正非对角元的比例 $p$。如果 $s \\ge 0.1$ 或 $p \\ge 0.5$，我们标记代码 $3$。任一条件都表明经典的 AMG 假设被违反，这对标准的粗化和插值提出了挑战。\n\n4) 病态：使用奇异值 $\\{\\sigma_i\\}$，我们估计 $\\kappa_2(A) = \\dfrac{\\sigma_{\\max}}{\\sigma_{\\min}}$。如果 $\\kappa_2(A) \\ge 10^8$，我们标记代码 $4$，反映出巨大的尺度差异会降低光滑子和粗网格的有效性。\n\n5) 近奇异性：如果 $\\sigma_{\\min}(A) \\le 10^{-14}$，我们标记代码 $5$。对于奇异算子（如诺伊曼拉普拉斯算子），$\\sigma_{\\min} = 0$，因此该指标捕捉了一个固有的障碍：零空间分量无法通过松弛消除。\n\n6) 因极端对角缩放导致的光滑子失效：对于基于对角元的光滑子，极小的对角元是有问题的。我们计算 $d_{\\min} = \\min_i |a_{ii}|$ 和 $d_{\\max} = \\max_i |a_{ii}|$，如果 $\\dfrac{d_{\\min}}{d_{\\max}} < 10^{-8}$，则标记代码 $6$。\n\n7) 弱连接性：我们计算 $\\rho_{\\mathrm{od}} = \\dfrac{\\sum_{i \\ne j} |a_{ij}|}{\\sum_i |a_{ii}|}$，当分母非零时。如果 $\\rho_{\\mathrm{od}} \\le 0.1$，我们标记代码 $7$，表示 $A$ 近乎对角。\n\n选择这些阈值的目的是使其简单、具有尺度感知能力，并能够有意义地区分所提供的测试用例。\n\n现在我们对测试套件的预期结果进行说明：\n\n- 用例 A（狄利克雷拉普拉斯算子，$n = 8$，$r_i = \\sin\\big(\\dfrac{\\pi i}{n+1}\\big)$）：此 $r$ 是对称算子的最低频特征模式，具有一个小的特征值，因此相对于对角尺度，其瑞利商很小。低能指标应该会触发（代码 $1$）。常数模式主导（代码 $2$）不会触发，因为 $r$ 的均值接近于零。矩阵是对称的、连接良好且条件数合理，因此没有其他指标会触发。预期代码：$[1]$。\n\n- 用例 B（上双对角扰动）：该矩阵是强非对称的；弗罗贝尼乌斯范数非对称性 $s$ 很大。存在正的非对角元，但不是大多数；非对称性足以触发代码 $3$。矩阵没有过度病态，连接性也非平凡，因此其他指标保持关闭。预期代码：$[3]$。\n\n- 用例 C（对角、对称正定、高度病态）：奇异值正是对角元，范围从 $10^{-6}$ 到 $10^{6}$，给出 $\\kappa_2(A) = 10^{12} \\ge 10^8$，因此代码 $4$ 触发。由于 $A$ 是对角的，$\\rho_{\\mathrm{od}} = 0 \\le 0.1$，因此代码 $7$ 触发。最小奇异值 $10^{-6} > 10^{-14}$ 不会触发近奇异性。预期代码：$[4, 7]$。\n\n- 用例 D（对角矩阵，一个对角元极小）：比率 $\\dfrac{d_{\\min}}{d_{\\max}} = 10^{-12} < 10^{-8}$ 触发代码 $6$。矩阵是对角的，因此代码 $7$ 触发。条件数是 $10^{12} \\ge 10^8$，因此代码 $4$ 触发。根据所用的 $\\sigma_{\\min}$ 阈值，它不是近奇异的。预期代码：$[4, 6, 7]$。\n\n- 用例 E（诺伊曼拉普拉斯算子，对称半正定）：该矩阵有一个零奇异值，因此代码 $4$ 和 $5$ 触发（通过无限条件数导致的病态和近奇异性）。常数向量位于零空间中；当 $r$ 等于常数向量时，常数模式主导触发代码 $2$。常数向量的瑞利商为零，低于阈值，因此代码 $1$ 触发。预期代码：$[1, 2, 4, 5]$。\n\n程序将这些结果按 A、B、C、D、E 的顺序组合成所需的单行输出字符串，每个结果都是一个用方括号括起来的整数列表，且没有空格。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef diagnose_amg_failure(A: np.ndarray, r: np.ndarray):\n    n = A.shape[0]\n    codes = set()\n\n    # Thresholds\n    tau_energy = 0.1          # for low-energy Rayleigh quotient relative to avg diagonal\n    tau_cfrac = 0.7           # constant-mode dominance\n    tau_nonsym = 0.1          # nonsymmetry threshold (Frobenius)\n    tau_pos_off = 0.5         # fraction of positive off-diagonals\n    tau_cond = 1e8            # ill-conditioning threshold\n    tau_sigmin = 1e-14        # near-singularity threshold\n    tau_diag_extreme = 1e-8   # extreme diagonal scaling\n    tau_od_ratio = 0.1        # weak connectivity / nearly diagonal\n\n    # Helper quantities\n    # Symmetric part for energy computation\n    As = 0.5 * (A + A.T)\n\n    # Average diagonal magnitude\n    diag = np.diag(A).astype(float)\n    abs_diag = np.abs(diag)\n    d_avg = float(np.mean(abs_diag)) if abs_diag.size > 0 else 0.0\n\n    # 1) Low-energy residual\n    rnorm2 = float(r @ r)\n    if rnorm2 > 0 and d_avg > 0:\n        lam = float(r @ (As @ r)) / rnorm2\n        if lam <= tau_energy * d_avg:\n            codes.add(1)\n\n    # 2) Constant-mode dominance\n    if rnorm2 > 0:\n        u = np.ones_like(r)\n        cfrac = abs(float(u @ r)) / (np.sqrt(n) * np.sqrt(rnorm2))\n        if cfrac >= tau_cfrac:\n            codes.add(2)\n\n    # 3) Nonsymmetry or non-M-matrix structure\n    normA_F = float(np.linalg.norm(A, ord='fro'))\n    nonsym = 0.0\n    if normA_F > 0:\n        nonsym = float(np.linalg.norm(A - A.T, ord='fro')) / normA_F\n    # Fraction of positive off-diagonal entries\n    off_pos = 0\n    off_total = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            off_total += 1\n            if A[i, j] > 0:\n                off_pos += 1\n    p_pos_off = (off_pos / off_total) if off_total > 0 else 0.0\n    if nonsym >= tau_nonsym or p_pos_off >= tau_pos_off:\n        codes.add(3)\n\n    # 4) Ill-conditioning and 5) Near-singularity via singular values\n    try:\n        svals = np.linalg.svd(A, compute_uv=False)\n        svals = np.array(svals, dtype=float)\n        sigma_min = float(np.min(svals)) if svals.size > 0 else 0.0\n        sigma_max = float(np.max(svals)) if svals.size > 0 else 0.0\n        if sigma_min <= tau_sigmin:\n            codes.add(5)\n        # condition number\n        if sigma_min == 0.0:\n            kappa = np.inf\n        else:\n            kappa = sigma_max / sigma_min if sigma_min > 0 else np.inf\n        if not np.isfinite(kappa) or kappa >= tau_cond:\n            codes.add(4)\n    except np.linalg.LinAlgError:\n        # If SVD fails, we conservatively flag ill-conditioning\n        codes.add(4)\n\n    # 6) Smoother breakdown due to extreme diagonal scaling\n    if abs_diag.size > 0:\n        dmin = float(np.min(abs_diag))\n        dmax = float(np.max(abs_diag))\n        if dmax > 0 and (dmin / dmax) < tau_diag_extreme:\n            codes.add(6)\n\n    # 7) Weak connectivity / nearly diagonal operator\n    sum_abs_diag = float(np.sum(np.abs(np.diag(A))))\n    sum_abs_off = float(np.sum(np.abs(A)) - sum_abs_diag)\n    if sum_abs_diag > 0:\n        od_ratio = sum_abs_off / sum_abs_diag\n        if od_ratio <= tau_od_ratio:\n            codes.add(7)\n    else:\n        # If diagonal sum is zero but there are off-diagonals, we do not flag 7.\n        # If both are zero (zero matrix), it's singular; already covered by (5).\n        pass\n\n    return sorted(codes)\n\ndef build_test_cases():\n    cases = []\n\n    # Case A: 1D Dirichlet Laplacian, n=8\n    n1 = 8\n    A1 = np.zeros((n1, n1), dtype=float)\n    for i in range(n1):\n        A1[i, i] = 2.0\n        if i + 1 < n1:\n            A1[i, i+1] = -1.0\n            A1[i+1, i] = -1.0\n    r1 = np.sin(np.pi * (np.arange(1, n1 + 1)) / (n1 + 1)).astype(float)\n    cases.append((A1, r1))\n\n    # Case B: Upper bidiagonal perturbation, n=6\n    n2 = 6\n    A2 = np.zeros((n2, n2), dtype=float)\n    for i in range(n2):\n        A2[i, i] = 2.0\n        if i + 1 < n2:\n            A2[i, i+1] = 1.0\n    r2 = np.array([1, -1, 2, -2, 1, -1], dtype=float)\n    cases.append((A2, r2))\n\n    # Case C: Diagonal SPD ill-conditioned, n=5\n    A3 = np.diag(np.array([1e-6, 1e-3, 1.0, 1e3, 1e6], dtype=float))\n    r3 = np.array([1, 2, 3, 4, 5], dtype=float)\n    cases.append((A3, r3))\n\n    # Case D: Diagonal with one tiny diagonal entry, n=5\n    A4 = np.diag(np.array([1.0, 1.0, 1e-12, 1.0, 1.0], dtype=float))\n    r4 = np.array([1, 0, 1, 0, 1], dtype=float)\n    cases.append((A4, r4))\n\n    # Case E: 1D Neumann Laplacian, n=4\n    n5 = 4\n    A5 = np.zeros((n5, n5), dtype=float)\n    for i in range(n5):\n        if i == 0 or i == n5 - 1:\n            A5[i, i] = 1.0\n        else:\n            A5[i, i] = 2.0\n        if i + 1 < n5:\n            A5[i, i+1] = -1.0\n            A5[i+1, i] = -1.0\n    r5 = np.ones(n5, dtype=float)\n    cases.append((A5, r5))\n\n    return cases\n\ndef solve():\n    test_cases = build_test_cases()\n    all_results = []\n    for A, r in test_cases:\n        codes = diagnose_amg_failure(A, r)\n        all_results.append(codes)\n\n    # Format output as a single line string with no spaces, e.g., \"[[1],[3],...]\"\n    def fmt_list(lst):\n        return \"[\" + \",\".join(str(int(x)) for x in lst) + \"]\"\n    out = \"[\" + \",\".join(fmt_list(lst) for lst in all_results) + \"]\"\n    print(out)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3204416"}]}