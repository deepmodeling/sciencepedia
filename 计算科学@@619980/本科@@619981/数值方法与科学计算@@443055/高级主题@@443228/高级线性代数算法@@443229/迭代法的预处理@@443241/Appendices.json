{"hands_on_practices": [{"introduction": "预处理最直接的应用之一是改善矩阵的行或列尺度特性。在许多科学与工程问题中，由于物理量的单位或方程的性质不同，线性系统矩阵 $A$ 的不同行可能具有截然不同的数量级。本练习将通过一个具体的例子，向您展示如何构造一个简单的对角预处理器来进行“行均衡”，使预处理后矩阵的每一行都具有相似的“大小”，从而为迭代求解器创造一个更友好的环境。[@problem_id:2194457]", "problem": "考虑线性方程组 $Ax = b$，其中矩阵 $A$ 和向量 $b$ 由下式给出：\n$$\nA = \\begin{pmatrix} 2  & -1 & 0 \\\\ 1000 & 2000 & -1000 \\\\ 0 & -1 & 2 \\end{pmatrix}, \\quad b = \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix}\n$$\n我们观察到，许多迭代求解器的收敛性可以通过将系统转换为一个等价系统 $A'x = b'$ 来改善，其中新矩阵 $A'$ 的各行具有更一致的“大小”。这个变换是通过使用一个可逆矩阵 $P$ 来实现的，使得 $A' = PA$ 和 $b' = Pb$。\n\n你的任务是找到一个形式如下的对角矩阵 $P$\n$$\nP = \\begin{pmatrix} p_1 & 0 & 0 \\\\ 0 & p_2 & 0 \\\\ 0 & 0 & p_3 \\end{pmatrix}\n$$\n该矩阵对 $A$ 进行行平衡。具体来说，确定 $p_1, p_2,$ 和 $p_3$ 的值，使得所得矩阵 $A'$ 中每个行向量的无穷范数都等于 1。一个向量 $v = (v_1, v_2, \\dots, v_n)$ 的无穷范数定义为 $\\|v\\|_{\\infty} = \\max_{i} |v_i|$。为简单起见，你可以假设 $P$ 的对角元素是正的。\n\n将你的最终答案表示为 3x3 矩阵 $P$。", "solution": "我们寻求一个对角缩放矩阵 $P=\\operatorname{diag}(p_{1},p_{2},p_{3})$，使得 $A' = PA$ 的每一行的无穷范数都等于 $1$。令 $a_{i}^{T}$ 表示 $A$ 的第 $i$ 行。那么 $A'$ 的第 $i$ 行为 $p_{i}a_{i}^{T}$。由于 $p_{i} > 0$，无穷范数按如下方式缩放\n$$\n\\|p_{i}a_{i}^{T}\\|_{\\infty} = p_{i}\\|a_{i}^{T}\\|_{\\infty}.\n$$\n施加条件 $\\|p_{i}a_{i}^{T}\\|_{\\infty} = 1$ 可得\n$$\np_{i} = \\frac{1}{\\|a_{i}^{T}\\|_{\\infty}} \\quad \\text{对于 } i=1,2,3.\n$$\n计算 $A$ 的行无穷范数：\n- 第 1 行：$a_{1}^{T}=(2,-1,0)$，因此 $\\|a_{1}^{T}\\|_{\\infty}=\\max\\{|2|,|{-1}|,|0|\\}=2$，所以 $p_{1}=\\frac{1}{2}$。\n- 第 2 行：$a_{2}^{T}=(1000,2000,-1000)$，因此 $\\|a_{2}^{T}\\|_{\\infty}=\\max\\{1000,2000,1000\\}=2000$，所以 $p_{2}=\\frac{1}{2000}$。\n- 第 3 行：$a_{3}^{T}=(0,-1,2)$，因此 $\\|a_{3}^{T}\\|_{\\infty}=\\max\\{|0|,|{-1}|,|2|\\}=2$，所以 $p_{3}=\\frac{1}{2}$。\n\n因此，\n$$\nP=\\begin{pmatrix}\n\\frac{1}{2}  & 0 & 0 \\\\\n0 & \\frac{1}{2000} & 0 \\\\\n0 & 0 & \\frac{1}{2}\n\\end{pmatrix}.\n$$\n这个选择确保了 $A' = PA$ 的每一行的无穷范数都等于 $1$。", "answer": "$$\\boxed{\\begin{pmatrix}\\frac{1}{2}  & 0 & 0 \\\\ 0 & \\frac{1}{2000} & 0 \\\\ 0 & 0 & \\frac{1}{2}\\end{pmatrix}}$$", "id": "2194457"}, {"introduction": "预处理的理论目标是使预处理后系统的条件数尽可能接近 1。一个条件数为 1 的矩阵在数值上表现得像一个完美的“球体”，迭代方法对其求解通常非常高效。这个练习是一个理想化的思想实验，旨在揭示预处理的核心目标：通过构造一个特定的对角预处理器，我们将一个给定的 $2 \\times 2$ 矩阵精确地转换为一个条件数为 1 的新矩阵，从而直观地理解预处理如何从根本上改变问题的几何特性。[@problem_id:2194479]", "problem": "在数值线性代数中，迭代法常用于求解形如 $A\\mathbf{x} = \\mathbf{b}$ 的大型线性方程组的近似解。许多这类方法的效率高度依赖于系数矩阵 $A$ 的性质，特别是其条件数 $\\kappa(A)$。为了改善收敛性，使用了一种称为预处理的技术。原始系统被转化为一个等价系统 $M\\mathbf{x} = \\mathbf{c}$，其中 $M = P^{-1}A$ 且 $\\mathbf{c} = P^{-1}\\mathbf{b}$。矩阵 $P$ 被称为预处理矩阵，选择它的目的是使预处理后的矩阵 $M$ 的条件数 $\\kappa(M)$ 尽可能接近1，同时确保 $P^{-1}$ 易于计算。\n\n考虑由下式给出的矩阵 $A$：\n$$A = \\begin{pmatrix} 1  & 2 \\\\ -4 & 2 \\end{pmatrix}$$\n我们寻找一个形式如下的对角预处理矩阵 $P$：\n$$P = \\begin{pmatrix} p_1 & 0 \\\\ 0 & p_2 \\end{pmatrix}$$\n其中 $p_1$ 和 $p_2$ 是正实数。\n\n求比值 $p_2/p_1$ 的值，使得预处理后的矩阵 $P^{-1}A$ 关于矩阵2-范数的条件数 $\\kappa_2(P^{-1}A)$ 恰好为1。", "solution": "我们希望 $\\kappa_{2}(P^{-1}A)=1$。对于矩阵2-范数，$\\kappa_{2}(M)=1$ 当且仅当存在 $\\alpha>0$ 使得 $M^{T}M=\\alpha I$。设 $M=P^{-1}A$，其中 $P=\\operatorname{diag}(p_{1},p_{2})$ 且 $p_{1},p_{2}>0$。那么\n$$\nM^{T}M=A^{T}P^{-T}P^{-1}A=A^{T}P^{-2}A,\n$$\n因为 $P$ 是对角元为正的对角矩阵。记 $D=P^{-2}=\\operatorname{diag}(d_{1},d_{2})$，其中 $d_{1}=p_{1}^{-2}$ 且 $d_{2}=p_{2}^{-2}$。我们寻找 $d_{1},d_{2}>0$ 和 $\\alpha>0$ 使得\n$$\nA^{T}DA=\\alpha I.\n$$\n对于 $A = \\begin{pmatrix} 1 & 2 \\\\ -4 & 2 \\end{pmatrix}$，首先计算\n$$\nDA=\\begin{pmatrix}d_{1} & 2d_{1}\\\\ -4d_{2} & 2d_{2}\\end{pmatrix},\n$$\n然后计算\n$$\nA^{T}DA=\\begin{pmatrix}1 & -4\\\\ 2 & 2\\end{pmatrix}\\begin{pmatrix}d_{1} & 2d_{1}\\\\ -4d_{2} & 2d_{2}\\end{pmatrix}\n=\\begin{pmatrix}d_{1}+16d_{2} & 2d_{1}-8d_{2}\\\\ 2d_{1}-8d_{2} & 4d_{1}+4d_{2}\\end{pmatrix}.\n$$\n为了使该矩阵等于 $\\alpha I$，非对角元必须为零，且对角元必须相等。非对角元条件给出\n$$\n2d_{1}-8d_{2}=0 \\quad \\Longrightarrow \\quad d_{1}=4d_{2}.\n$$\n根据这个关系，对角元自动相等：\n$$\nd_{1}+16d_{2}=4d_{2}+16d_{2}=20d_{2}, \\quad 4d_{1}+4d_{2}=16d_{2}+4d_{2}=20d_{2}.\n$$\n因此 $D$ 必须满足 $d_{1}=4d_{2}$。用 $p_{1},p_{2}$ 表示，这等价于\n$$\np_{1}^{-2}=4p_{2}^{-2} \\quad \\Longrightarrow \\quad \\frac{p_{1}^{-2}}{p_{2}^{-2}}=4 \\quad \\Longrightarrow \\quad \\frac{p_{2}^{2}}{p_{1}^{2}}=4 \\quad \\Longrightarrow \\quad \\frac{p_{2}}{p_{1}}=2,\n$$\n其中利用了 $p_{1},p_{2}>0$。因此，$\\kappa_{2}(P^{-1}A)=1$ 当且仅当 $p_{2}/p_{1}=2$。", "answer": "$$\\boxed{2}$$", "id": "2194479"}, {"introduction": "高级预处理技术通常会利用问题的内在结构来提升效率。本练习将理论与实际应用相结合，探讨了高斯-赛德尔 (Gauss-Seidel) 方法作为对流扩散问题预处理器的有效性。通过编程实践，您将发现一个深刻的见解：预处理器的性能，特别是像高斯-赛德尔这类依赖于计算顺序的方法，与问题的物理特性（如此处的对流方向）紧密相关。选择与信息传播方向一致的求解顺序，可以极大地加速收敛，反之则会严重影响效率。[@problem_id:3263468]", "problem": "考虑区间 $[0,1]$ 上的齐次狄利克雷边界条件的一维稳态对流扩散边值问题：寻找一个函数 $u(x)$，使得\n$$\n-\\epsilon \\, \\frac{d^2 u}{dx^2} + \\beta \\, \\frac{d u}{dx} = f(x), \\quad x \\in (0,1), \\quad u(0) = 0, \\quad u(1) = 0,\n$$\n其中 $\\epsilon > 0$ 是扩散系数，$\\beta$ 是对流速度。使用具有 $n$ 个内部点、网格间距为 $h = \\frac{1}{n+1}$ 的均匀网格来离散化此问题，并构建线性系统 $A \\, x = b$，其中 $x \\in \\mathbb{R}^n$。对扩散项使用标准的二阶中心差分，对对流项使用根据 $\\beta$ 符号调整的一阶迎风差分：\n- 若 $\\beta \\ge 0$，则用 $\\frac{u_i - u_{i-1}}{h}$ 来近似 $\\frac{d u}{dx}$。\n- 若 $\\beta < 0$，则用 $\\frac{u_{i+1} - u_i}{h}$ 来近似 $\\frac{d u}{dx}$。\n\n将 $f(x)$ 离散化为常数强迫项，并将 $b$ 设置为 $\\mathbb{R}^n$ 中的全一向量。由此产生的矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是一个三对角矩阵，其元素由 $\\epsilon$、$\\beta$ 和 $h$ 决定。\n\n使用左预处理广义最小残差法 (GMRES) 求解该线性系统，其中左预处理器 $M^{-1}$ 选择为高斯-赛德尔预处理器。根据未知数的排列（排序）$\\pi$ 定义高斯-赛德尔预处理器如下：\n- 令 $P_\\pi$ 为与排序 $\\pi$ 相关联的排列矩阵，因此 $P_\\pi^\\top A P_\\pi$ 是根据 $\\pi$ 重排后的矩阵。\n- 定义 $M_\\pi$ 为 $P_\\pi^\\top A P_\\pi$ 的下三角部分（包括对角线）。\n- 预处理操作将 $M_\\pi^{-1}$ 应用于排列后坐标中的向量，然后通过 $P_\\pi$ 将结果映射回去。\n\n实现左预处理 GMRES 来求解系统 $M_\\pi^{-1} A x = M_\\pi^{-1} b$，使用由 $M_\\pi^{-1} A$ 和初始残差 $M_\\pi^{-1} b$ 生成的克雷洛夫子空间，并从零初始猜测开始。在每次迭代 $k$ 中，从克雷洛夫基构建近似解 $x_k$ 并计算相对残差\n$$\n\\rho_k = \\frac{\\|b - A x_k\\|_2}{\\|b\\|_2}.\n$$\n当 $\\rho_k \\le 10^{-8}$ 或迭代次数达到 $200$ 时终止，以先发生者为准。对于给定的排序 $\\pi$，预处理器的有效性度量是达到容差 $10^{-8}$ 所需的迭代次数；如果在 $200$ 次迭代内未达到收敛，则报告迭代次数为 $200$。\n\n通过运行以下测试套件，展示高斯-赛德尔预处理器的有效性如何依赖于未知数排序相对于对流方向的关系。固定 $n = 80$。对于每个测试用例，使用指定的 $(\\epsilon,\\beta,\\pi)$：\n- 测试用例 1：$(\\epsilon, \\beta, \\pi) = (0.01, 20, \\text{natural})$，其中 $\\pi$ 是自然的从左到右排序。\n- 测试用例 2：$(\\epsilon, \\beta, \\pi) = (0.01, 20, \\text{reversed})$，其中 $\\pi$ 是反向的从右到左排序。\n- 测试用例 3：$(\\epsilon, \\beta, \\pi) = (0.01, -20, \\text{natural})$。\n- 测试用例 4：$(\\epsilon, \\beta, \\pi) = (0.01, -20, \\text{reversed})$。\n- 测试用例 5：$(\\epsilon, \\beta, \\pi) = (1.0, 2, \\text{natural})$。\n- 测试用例 6：$(\\epsilon, \\beta, \\pi) = (1.0, 2, \\text{reversed})$。\n\n你的程序必须：\n- 根据上述离散化规则为每个 $(\\epsilon,\\beta)$ 构建 $A$。\n- 根据指定的排序 $\\pi$ 构建高斯-赛德尔预处理器。\n- 运行左预处理 GMRES 并记录达到 $\\rho_k \\le 10^{-8}$ 所需的迭代次数（如果未达到则为 $200$）。\n- 生成单行输出，其中包含六个迭代次数，按测试用例 1 到 6 的顺序以逗号分隔的列表形式，并用方括号括起来（例如，$[i_1,i_2,i_3,i_4,i_5,i_6]$），其中每个 $i_j$ 是一个整数。", "solution": "该问题的核心是实现一个数值实验，以验证高斯-赛德尔预处理器的性能与未知数排序及物理问题（对流方向）之间的关系。解决方案的逻辑遵循以下步骤：\n\n1.  **矩阵构建**：根据问题描述，针对每个 $(\\epsilon, \\beta)$ 对，使用迎风格式离散化一维对流扩散方程，构建三对角矩阵 $A$。\n    *   当 $\\beta \\ge 0$（对流向右）时，矩阵 $A$ 的对角线、次对角线和超对角线元素由 $-\\epsilon/h^2 - \\beta/h$, $2\\epsilon/h^2 + \\beta/h$, $-\\epsilon/h^2$ 确定。\n    *   当 $\\beta < 0$（对流向左）时，元素由 $-\\epsilon/h^2$, $2\\epsilon/h^2 - \\beta/h$, $-\\epsilon/h^2 + \\beta/h$ 确定。\n\n2.  **预处理器构建**：根据指定的排序（\"natural\" 或 \"reversed\"），构建高斯-赛德尔预处理器。\n    *   定义一个排列向量 `pi`。\n    *   根据 `pi` 对矩阵 $A$ 进行重排，得到 `A_perm`。\n    *   预处理器矩阵 `M_pi` 定义为 `A_perm` 的下三角部分（包括对角线）。\n    *   预处理操作 $y = M^{-1}z$ 的实现包括：排列 $z$，用前向替换求解下三角系统，然后将结果反向排列回原始顺序。\n\n3.  **GMRES 求解**：实现左预处理的 GMRES 算法。该算法从零向量开始，迭代构建克雷洛夫子空间，并在每一步求解一个最小二乘问题来更新解。收敛判断基于真实的相对残差 $\\|b - Ax_k\\|_2 / \\|b\\|_2$。\n\n4.  **执行测试**：对六个指定的测试用例，依次执行上述步骤，记录达到收敛容差所需的迭代次数。如果迭代超过200次，则记为200。\n\n以下 Python 代码实现了上述求解过程。\n\n```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the convection-diffusion problem for a suite of test cases\n    using left-preconditioned GMRES with an ordering-dependent\n    Gauss-Seidel preconditioner.\n    \"\"\"\n\n    def _solve_lower_triangular(L, b):\n        \"\"\"\n        Solves the lower triangular system L*x = b via forward substitution.\n        \"\"\"\n        n = len(b)\n        x = np.zeros(n, dtype=float)\n        for i in range(n):\n            s = np.dot(L[i, :i], x[:i])\n            if abs(L[i, i]) < 1e-16:\n                raise ValueError(\"Matrix is singular or near-singular.\")\n            x[i] = (b[i] - s) / L[i, i]\n        return x\n\n    def _run_preconditioned_gmres(A, b, precon_M_pi, precon_pi, tol, max_iter):\n        \"\"\"\n        Implementation of the left-preconditioned GMRES algorithm.\n        \"\"\"\n        n = A.shape[0]\n\n        def apply_preconditioner(z):\n            \"\"\"\n            Applies the Gauss-Seidel preconditioner M_inv.\n            y = M_inv * z\n            \"\"\"\n            z_perm = z[precon_pi]\n            y_perm = _solve_lower_triangular(precon_M_pi, z_perm)\n            y = np.zeros_like(y_perm)\n            y[precon_pi] = y_perm\n            return y\n\n        x = np.zeros(n, dtype=float)\n        norm_b = np.linalg.norm(b)\n\n        if norm_b == 0:\n            return 0\n        \n        r0 = b - A @ x\n        if np.linalg.norm(r0) / norm_b <= tol:\n            return 0\n\n        r_tilde = apply_preconditioner(r0)\n        beta_gmres = np.linalg.norm(r_tilde)\n        \n        if beta_gmres < 1e-16:\n            return 0\n\n        V = np.zeros((n, max_iter + 1), dtype=float)\n        H = np.zeros((max_iter + 1, max_iter), dtype=float)\n        V[:, 0] = r_tilde / beta_gmres\n\n        for k in range(max_iter):\n            w = A @ V[:, k]\n            w_tilde = apply_preconditioner(w)\n            \n            for j in range(k + 1):\n                H[j, k] = np.dot(w_tilde, V[:, j])\n                w_tilde -= H[j, k] * V[:, j]\n            \n            H[k + 1, k] = np.linalg.norm(w_tilde)\n            \n            if H[k + 1, k] < 1e-16:\n                # Breakdown: solution is in the current subspace\n                k_eff = k + 1\n                break\n            \n            V[:, k + 1] = w_tilde / H[k + 1, k]\n            \n            k_eff = k + 1\n            H_k_sub = H[:k_eff + 1, :k_eff]\n            g0 = np.zeros(k_eff + 1)\n            g0[0] = beta_gmres\n            \n            y, _, _, _ = np.linalg.lstsq(H_k_sub, g0, rcond=None)\n            \n            x = V[:, :k_eff] @ y\n            rel_res = np.linalg.norm(b - A @ x) / norm_b\n            \n            if rel_res <= tol:\n                return k_eff\n        \n        return max_iter\n\n    test_cases = [\n        (0.01, 20.0, \"natural\"),\n        (0.01, 20.0, \"reversed\"),\n        (0.01, -20.0, \"natural\"),\n        (0.01, -20.0, \"reversed\"),\n        (1.0, 2.0, \"natural\"),\n        (1.0, 2.0, \"reversed\"),\n    ]\n\n    n = 80\n    tol = 1e-8\n    max_iter = 200\n    h = 1.0 / (n + 1)\n    b = np.ones(n, dtype=float)\n    \n    results = []\n\n    for epsilon, beta, ordering_str in test_cases:\n        A = np.zeros((n, n), dtype=float)\n        \n        if beta >= 0:\n            diag_val = 2 * epsilon / h**2 + beta / h\n            sub_diag_val = -epsilon / h**2 - beta / h\n            super_diag_val = -epsilon / h**2\n        else:\n            diag_val = 2 * epsilon / h**2 - beta / h\n            sub_diag_val = -epsilon / h**2\n            super_diag_val = -epsilon / h**2 + beta / h\n        \n        np.fill_diagonal(A, diag_val)\n        np.fill_diagonal(A[1:], sub_diag_val)\n        np.fill_diagonal(A[:, 1:], super_diag_val)\n        \n        if ordering_str == \"natural\":\n            pi = np.arange(n)\n        else:\n            pi = np.arange(n - 1, -1, -1)\n            \n        A_perm = A[np.ix_(pi, pi)]\n        M_pi = np.tril(A_perm)\n\n        iterations = _run_preconditioned_gmres(A, b, M_pi, pi, tol, max_iter)\n        results.append(iterations)\n\n    return f\"[{','.join(map(str, results))}]\"\n\n# The final answer is generated by running the code.\n# print(solve())\n```", "answer": "[3,200,200,3,10,10]", "id": "3263468"}]}