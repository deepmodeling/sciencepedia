{"hands_on_practices": [{"introduction": "算法的性能不仅取决于算法本身的设计，还与数据的表示方式密切相关。本练习将通过一个经典的图遍历问题来阐明这一点。我们将比较广度优先搜索 (BFS) 在邻接表和邻接矩阵这两种不同图表示下的性能，但我们不使用易受环境影响的“墙上时间”作为衡量标准，而是采用一种更具确定性的度量——统计“邻接检查”的基本操作次数。这种基于原则的基准测试方法，能让我们清晰地看到图的稀疏性如何影响每种表示法的效率 [@problem_id:3209872]。", "problem": "要求您设计并实现一个有原则的基准测试，用于比较在两种常见图表示（邻接矩阵和邻接表）上的广度优先搜索（BFS）。该基准测试必须基于基本操作模型，而非挂钟时间，以确保在不同环境下的可复现性和数值确定性。具体来说，您需要根据明确定义的规则，测量 BFS 在每种表示中执行的邻接检查次数，并为提供的一组测试图报告这些计数。\n\n基本基础和定义：\n- 一个图有 $V$ 个顶点和 $E$ 条边。本问题中的所有图都是无向、简单图（无自环，无平行边）。\n- 广度优先搜索（BFS）从一个指定的源顶点开始，逐层探索图。\n- 邻接表表示：每个顶点 $v$ 存储其邻居的列表。顶点 $v$ 的度是 $\\deg(v)$。\n- 邻接矩阵表示：一个二元矩阵 $A \\in \\{0,1\\}^{V \\times V}$，其中 $A_{ij} = 1$ 当且仅当顶点 $i$ 和顶点 $j$ 之间存在一条边。\n- 需要计数的性能指标：\n  1. 在邻接表 BFS 中，对于每个出队顶点，在迭代其邻居列表时，每遇到一个邻居就计为一次邻接检查。形式上，当 BFS 将顶点 $u$ 出队时，计数增加 $\\lvert \\text{Adj}(u) \\rvert$，其中 $\\text{Adj}(u)$ 是 $u$ 的邻居列表。\n  2. 在邻接矩阵 BFS 中，对于每个出队顶点，在扫描其对应行时，每扫描一个矩阵条目就计为一次邻接检查。形式上，当 BFS 将顶点 $u$ 出队时，计数增加 $V$，因为它扫描了所有 $V$ 个条目 $A_{u,0},A_{u,1},\\ldots,A_{u,V-1}$。\n\n科学真实性和基本原理：\n- 对于邻接表，BFS 执行的邻接检查总数等于 $\\sum_{v \\in R} \\deg(v)$，其中 $R$ 是出队的顶点集合（从源点可达）。对于无向图，这个总和等于 $2\\lvert E_R \\rvert$，其中 $E_R$ 是可达分量内部的边。\n- 对于邻接矩阵，BFS 为每个出队的顶点扫描一整行，产生恰好 $V \\cdot \\lvert R \\rvert$ 次检查，这与图的稀疏性无关。\n\n程序要求：\n- 对每种表示、每个图和源点，恰好实现一次 BFS。维护一个 `visited` 集合以防止重复访问顶点。\n- 按照上述定义计算邻接检查次数；不要计算其他操作。\n- 程序必须是自包含的，并且能够确定性地产生结果，不含随机性或外部输入。\n\n测试套件（所有图均为无向图）：\n- 测试用例 1（稀疏路径图）：\n  - $V = 10$。\n  - 边：$\\{(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9)\\}$。\n  - 源点：$0$。\n- 测试用例 2（稠密完全图）：\n  - $V = 8$。\n  - 边：所有满足 $0 \\le i  j \\le 7$ 的点对 $(i,j)$。\n  - 源点：$0$。\n- 测试用例 3（星形图）：\n  - $V = 10$。\n  - 边：$\\{(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9)\\}$。\n  - 源点：$0$。\n- 测试用例 4（不连通图：一个路径图、一个三角形和一些孤立点）：\n  - $V = 12$。\n  - 边：路径 $\\{(0,1),(1,2),(2,3)\\}$ 和三角形 $\\{(4,5),(5,6),(4,6)\\}$；顶点 $\\{7,8,9,10,11\\}$ 是孤立的。\n  - 源点：$4$。\n- 测试用例 5（无边图）：\n  - $V = 12$。\n  - 边：$\\varnothing$。\n  - 源点：$3$。\n\n最终输出规范：\n- 对于每个测试用例，计算序对 $[\\text{list\\_count}, \\text{matrix\\_count}]$，其中 $\\text{list\\_count}$ 是邻接表 BFS 中的邻接检查总数，$\\text{matrix\\_count}$ 是邻接矩阵 BFS 中的邻接检查总数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例表示为一个双元素列表。例如，输出格式必须类似于 $\\texttt{[[l_1,m_1],[l_2,m_2],\\ldots]}$，不含任何额外文本。\n\n本任务旨在评估对图表示如何影响算法复杂度和数据访问模式的理解，强调基于计算基本操作而非时间测量的确定性基准测试。", "solution": "问题陈述已经过严格验证，被认为是**有效的**。它具有科学依据，问题定义明确，客观且自包含。该问题通过定义一个确定性的、与机器无关的性能指标（即“邻接检查”次数），为基准测试广度优先搜索（BFS）在邻接表与邻接矩阵表示上的性能提供了一个严谨且可形式化的框架。所有定义、约束和测试用例都清晰、一致，并足以推导出一个唯一的、可验证的解决方案。\n\n该解决方案基于图论和算法分析的基本原理设计。我们将为两种表示实现 BFS，并为一组测试图计算指定的操作次数。\n\n### 算法设计与原理\n\n任务的核心是比较广度优先搜索的两种实现，它们的区别在于底层的图数据结构。性能不是通过时间来衡量，而是通过计算一个基本操作：检查邻接关系。\n\n**1. 广度优先搜索（BFS）框架**\n\nBFS 从给定的源顶点 $s$ 开始系统地探索图。它使用一个队列来管理待访问的顶点，确保逐层探索图。维护一个 `visited` 集合以防止循环和冗余处理。通用算法如下：\n1. 初始化一个队列，并将源顶点 $s$ 加入队列。\n2. 初始化一个仅包含 $s$ 的 `visited` 集合。\n3. 初始化一个检查计数器为 $0$。\n4. 当队列不为空时：\n   a. 从队列中取出一个顶点 $u$。\n   b. **根据特定于表示的规则增加检查计数器**。\n   c. 对于 $u$ 的每个邻居 $v$：\n      i. 如果 $v$ 未被访问过：\n         - 标记 $v$ 为已访问。\n         - 将 $v$ 入队。\n5. 返回最终的检查计数值。\n\n**2. 邻接表实现**\n\n- **表示**：一个有 $V$ 个顶点的图表示为一个列表数组。数组索引为 $u$ 的元素是一个包含所有与 $u$ 相邻的顶点的列表。对于无向图，如果存在边 $(u,v)$，则 $v$ 出现在 $u$ 的列表中，$u$ 也出现在 $v$ 的列表中。顶点 $u$ 的列表长度即为其度 $\\deg(u)$。\n\n- **成本模型**：根据问题定义，查找出队顶点 $u$ 的邻居需要遍历其邻接表。此操作的成本定义为该列表的长度。因此，当 $u$ 出队时，检查计数增加 $\\deg(u)$。\n\n- **总检查次数**：BFS 算法对从源点可达的分量中的每个顶点恰好处理一次。设 $R$ 为从源点可达的顶点集合。总检查次数是该集合中所有顶点度的总和：\n$$\n\\text{list\\_count} = \\sum_{u \\in R} \\deg(u)\n$$\n对于无向图，这个总和等于 $2|E_R|$，其中 $E_R$ 是两个端点都在 $R$ 中的边的集合。这突显了性能与所探索分量中的边数成正比，使其对于稀疏图是高效的。时间复杂度为 $O(|R| + |E_R|)$。\n\n**3. 邻接矩阵实现**\n\n- **表示**：一个有 $V$ 个顶点的图由一个 $V \\times V$ 的二元矩阵 $A$ 表示，其中如果顶点 $i$ 和顶点 $j$ 之间有边，则 $A_{ij} = 1$，否则 $A_{ij} = 0$。对于无向图，该矩阵是对称的（$A_{ij} = A_{ji}$）。\n\n- **成本模型**：要查找出队顶点 $u$ 的邻居，必须扫描矩阵 $A$ 的第 $u$ 整行。问题将此扫描的成本形式化为 $V$ 次检查，无论实际找到多少邻居。\n\n- **总检查次数**：BFS 算法将 $|R|$ 个可达顶点中的每一个出队一次。对于每个这样的顶点，它会产生 $V$ 次检查的成本。因此，总检查次数为：\n$$\n\\text{matrix\\_count} = |R| \\cdot V\n$$\n该模型表明，性能取决于图中的总顶点数，而不是边数。这对于稀疏图（其中 $|E|$ 远小于 $V^2$）可能是低效的，因为算法仍然必须为每个处理的顶点执行与 $V$ 成比例的工作。时间复杂度为 $O(|R| \\cdot V)$，或者如果考虑整个分量，则为 $O(V^2)$。\n\n**4. 实现细节**\n\n所提供的解决方案实现了两个函数 `bfs_adj_list` 和 `bfs_adj_matrix`，它们根据上述各自的成本模型执行 BFS 算法。`collections.deque` 对象用于高效的队列实现。一个主函数 `solve` 定义了测试套件，为每个用例调用 BFS 函数，并将输出格式化为 $[\\text{list\\_count}, \\text{matrix\\_count}]$ 序对的列表，严格遵守指定的输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef bfs_adj_list(V, edges, source):\n    \"\"\"\n    Performs BFS on an adjacency list representation and counts adjacency examinations.\n    \n    An examination is counted for each neighbor of a dequeued vertex, effectively summing\n    the degrees of all reachable vertices.\n    \"\"\"\n    if V == 0:\n        return 0\n        \n    adj = [[] for _ in range(V)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    queue = deque([source])\n    # A set is used for O(1) average time complexity for additions and checks.\n    visited = {source}\n    list_count = 0\n\n    while queue:\n        u = queue.popleft()\n        \n        # Per the problem definition, increment count by degree of the dequeued vertex.\n        list_count += len(adj[u])\n\n        for v in adj[u]:\n            if v not in visited:\n                visited.add(v)\n                queue.append(v)\n                \n    return list_count\n\ndef bfs_adj_matrix(V, edges, source):\n    \"\"\"\n    Performs BFS on an adjacency matrix representation and counts adjacency examinations.\n    \n    An examination of V entries is counted for each dequeued vertex, reflecting the\n    cost of scanning an entire matrix row.\n    \"\"\"\n    if V == 0:\n        return 0\n\n    matrix = np.zeros((V, V), dtype=int)\n    for u, v in edges:\n        matrix[u, v] = 1\n        matrix[v, u] = 1\n\n    queue = deque([source])\n    visited = {source}\n    matrix_count = 0\n\n    while queue:\n        u = queue.popleft()\n\n        # Per the problem definition, increment count by V for scanning the row.\n        matrix_count += V\n\n        for v in range(V):\n            if matrix[u, v] == 1:\n                if v not in visited:\n                    visited.add(v)\n                    queue.append(v)\n                    \n    return matrix_count\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the benchmarks, and prints the results in the\n    specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Sparse path graph\n        (10, [(i, i + 1) for i in range(9)], 0),\n        # Case 2: Dense complete graph\n        (8, [(i, j) for i in range(8) for j in range(i + 1, 8)], 0),\n        # Case 3: Star graph\n        (10, [(0, i) for i in range(1, 10)], 0),\n        # Case 4: Disconnected graph\n        (12, [(0, 1), (1, 2), (2, 3), (4, 5), (5, 6), (4, 6)], 4),\n        # Case 5: Edgeless graph\n        (12, [], 3)\n    ]\n\n    results = []\n    for V, edges, source in test_cases:\n        list_count = bfs_adj_list(V, edges, source)\n        matrix_count = bfs_adj_matrix(V, edges, source)\n        results.append([list_count, matrix_count])\n\n    # Format each result pair as '[l,m]' without spaces.\n    formatted_results = [f\"[{r[0]},{r[1]}]\" for r in results]\n    \n    # Final print statement in the exact required format '[[l1,m1],[l2,m2],...]'.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3209872"}, {"introduction": "现在，我们转向数值线性代数领域，许多科学计算问题最终都归结为求解大型线性方程组 $A x = b$。共轭梯度法 (CG) 是一种高效的迭代求解器，但其收敛速度受到矩阵 $A$ 性质的影响。本练习将通过实验探索矩阵的“条件数” $\\kappa(A)$（衡量问题“病态”程度的指标）与 CG 方法收敛性能之间的直接关系。通过人工构造具有精确可控条件数的矩阵，我们可以量化地观察到，随着问题变得越来越病态，求解器的迭代次数是如何增加的 [@problem_id:3209858]。", "problem": "您将研究一个迭代求解器的迭代次数如何随着系统矩阵条件数的增加而恶化。请完全使用精确、无量纲、纯数学的术语进行操作。\n\n从以下基本基础开始：\n- 对于一个实对称正定矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其在谱范数下的谱条件数为 $\\kappa_2(A) = \\lambda_{\\max}(A)/\\lambda_{\\min}(A)$，其中 $\\lambda_{\\max}(A)$ 和 $\\lambda_{\\min}(A)$ 分别表示 $A$ 的最大和最小特征值。\n- 用于求解 $A$ 为对称正定矩阵的方程组 $A x = b$ 的共轭梯度法（简称 CG），通过在一个克雷洛夫子空间上迭代地最小化 A-范数下的误差，并在残差 $r_k = b - A x_k$ 满足指定的停止准则时终止。\n\n任务。实现一个完整、可运行的程序，该程序能够：\n1. 对于每个指定的目标条件数 $\\kappa$，通过指定特征值并与一个固定的正交矩阵混合，构建一个大小为 $n \\times n$ 的实对称正定矩阵族成员 $A(\\kappa)$，使其满足 $\\kappa_2(A(\\kappa)) = \\kappa$：\n   - 使用 $n = 64$。\n   - 令特征值 $\\lambda_i$ 在 $1$ 和 $\\kappa$ 之间线性分布，其中 $i = 1, \\dots, n$。\n   - 构造 $A(\\kappa) = Q^\\top \\operatorname{diag}(\\lambda_1,\\dots,\\lambda_n) Q$，其中 $Q$ 是一个固定的正交矩阵，按如下方式可复现地生成：使用固定的种子 $0$ 构建一个稠密矩阵 $M \\in \\mathbb{R}^{n \\times n}$，其元素为独立同分布的标准正态分布；计算 $M$ 的简约 QR 分解 $M = \\widehat{Q} R$；根据约定 $\\operatorname{sign}(0)=1$ 定义 $D = \\operatorname{diag}(\\operatorname{sign}(R_{11}), \\dots, \\operatorname{sign}(R_{nn}))$，并设置 $Q = \\widehat{Q} D$。这保证了 $R$ 的对角线元素为正，并确定性地固定了 $Q$ 的列符号。\n2. 使用共轭梯度法求解 $A(\\kappa) x = b$，参数如下：\n   - 右端项 $b = \\mathbf{1} \\in \\mathbb{R}^n$（全为 1）。\n   - 初始猜测值 $x_0 = 0$。\n   - 停止准则为 $\\lVert r_k \\rVert_2 \\le \\text{tol} \\cdot \\lVert b \\rVert_2$，其中 $\\text{tol} = 10^{-8}$，$\\lVert \\cdot \\rVert_2$ 是欧几里得范数。\n   - 最大迭代次数等于 $n$。\n3. 对于每个测试用例，报告共轭梯度法满足停止准则所需的迭代次数 $k$，如果在 $n$ 次迭代内未满足停止准则，则报告最大值 $n$。\n\n测试套件。针对以下参数值运行程序：\n- 用例 1：$(n, \\kappa, \\text{tol}) = (64, 1, 10^{-8})$。\n- 用例 2：$(n, \\kappa, \\text{tol}) = (64, 10, 10^{-8})$。\n- 用例 3：$(n, \\kappa, \\text{tol}) = (64, 100, 10^{-8})$。\n- 用例 4：$(n, \\kappa, \\text{tol}) = (64, 1000, 10^{-8})$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，该列表的结果顺序与测试套件的顺序相同，例如 $[k_1,k_2,k_3,k_4]$，其中每个 $k_i$ 是用例 $i$ 的整数迭代次数。\n\n您的实现不得读取任何输入，也不得使用任何外部文件或网络访问。所有计算必须使用双精度算术。不涉及物理单位，也不使用角度。报告的量均为整数。", "solution": "该问题是有效的。它提出了一个适定且科学上合理的数值实验，以探究矩阵条件数对共轭梯度法收敛性的影响。所有参数和过程都得到了精确而明确的规定。\n\n目标是量化一个实对称正定 (SPD) 矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的谱条件数 $\\kappa_2(A)$ 与共轭梯度 (CG) 法求解线性系统 $A x = b$ 所需迭代次数之间的关系。该实验被设计为完全可复现的，并针对一系列条件数逐渐增加的矩阵进行。\n\n首先，我们必须构造一个大小为 $n \\times n$、条件数 $\\kappa$ 被精确控制的矩阵族 $A(\\kappa)$。问题指定 $n=64$。实现这一目标的标准方法是通过其特征分解来定义矩阵，$A(\\kappa) = Q \\Lambda(\\kappa) Q^\\top$，或者等价地，由于 $Q$ 是正交的，$A(\\kappa) = Q^\\top \\Lambda(\\kappa) Q$。矩阵 $\\Lambda(\\kappa) = \\operatorname{diag}(\\lambda_1, \\dots, \\lambda_n)$ 是一个包含 $A(\\kappa)$ 特征值的对角矩阵。条件数定义为 $\\kappa_2(A) = \\lambda_{\\max}(A)/\\lambda_{\\min}(A)$。为了达到目标条件数 $\\kappa$，我们可以设置 $\\lambda_{\\min} = 1$ 和 $\\lambda_{\\max} = \\kappa$。问题规定 $n$ 个特征值 $\\lambda_i$ 在 $1$ 和 $\\kappa$ 之间线性分布。因此，特征值集合为 $\\{\\lambda_i\\}_{i=1}^n$，其中 $\\lambda_i = 1 + (i-1)\\frac{\\kappa-1}{n-1}$。由于所有 $\\kappa \\ge 1$，所有特征值 $\\lambda_i$ 都大于或等于 $1$，这确保了生成的矩阵 $A(\\kappa)$ 是正定的。构造 $A(\\kappa) = Q^\\top \\Lambda(\\kappa) Q$ 保证了 $A(\\kappa)$ 是对称的。\n\n正交矩阵 $Q$ 对所有测试用例都是固定的，以确保对特征系统施加一致的旋转变换。这隔离了特征值分布的影响。矩阵 $Q$ 是确定性地生成的，以确保可复现性。这是通过首先使用固定的随机种子 $0$ 创建一个稠密矩阵 $M \\in \\mathbb{R}^{n \\times n}$ 来实现的，其条目从标准正态分布中抽取。然后计算 $M$ 的 QR 分解，$M = \\widehat{Q}R$。矩阵 $\\widehat{Q}$ 是正交的，但 QR 分解不是唯一的；$\\widehat{Q}$ 的列和 $R$ 的相应行的符号可以翻转。为了获得一个唯一的、确定性的 $Q$，我们强制执行一个约定，即 $R$ 的对角线元素必须为非负。这是通过创建对角矩阵 $D = \\operatorname{diag}(\\operatorname{sign}(R_{11}), \\dots, \\operatorname{sign}(R_{nn}))$ 来实现的，并遵循指定的约定 $\\operatorname{sign}(0)=1$。最终的固定正交矩阵即为 $Q = \\widehat{Q}D$。\n\n构建好矩阵 $A(\\kappa)$ 后，我们使用共轭梯度法求解线性系统 $A(\\kappa)x = b$。求解器的参数为：右端向量 $b = \\mathbf{1} \\in \\mathbb{R}^n$（一个全为 1 的向量），初始猜测值 $x_0 = 0 \\in \\mathbb{R}^n$，以及最大迭代次数 $n=64$。CG 算法迭代地生成一系列解的近似值。该过程从初始残差 $r_0 = b - Ax_0 = b$ 和初始搜索方向 $p_0 = r_0$ 开始。对于每次迭代 $k = 0, 1, 2, \\dots$，算法计算：\n$$ \\alpha_k = \\frac{r_k^\\top r_k}{p_k^\\top A p_k} $$\n$$ x_{k+1} = x_k + \\alpha_k p_k $$\n$$ r_{k+1} = r_k - \\alpha_k A p_k $$\n当残差的欧几里得范数 $\\lVert r_{k+1} \\rVert_2$ 满足停止准则 $\\lVert r_{k+1} \\rVert_2 \\le \\text{tol} \\cdot \\lVert b \\rVert_2$ 时，迭代终止，其中容差为 $\\text{tol} = 10^{-8}$。如果在第 $k+1$ 步达到收敛，则迭代次数记录为 $k+1$。为了继续迭代，计算新的搜索方向：\n$$ \\beta_k = \\frac{r_{k+1}^\\top r_{k+1}}{r_k^\\top r_k} $$\n$$ p_{k+1} = r_{k+1} + \\beta_k p_k $$\n\n对每个指定的测试用例（对应于 $\\kappa \\in \\{1, 10, 100, 1000\\}$）执行这整个过程。收集并报告每个用例的迭代次数。对于 $\\kappa=1$，$A(1)=I$，预计 CG 方法将在单次迭代中收敛。随着 $\\kappa$ 的增加，问题变得更加病态，预计迭代次数会增加，可能达到最大限制 $n=64$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef conjugate_gradient(A, b, tol, max_iter):\n    \"\"\"\n    Solves the system Ax=b using the Conjugate Gradient method.\n\n    Args:\n        A (np.ndarray): The symmetric positive definite matrix of the system.\n        b (np.ndarray): The right-hand side vector.\n        tol (float): The relative tolerance for the stopping criterion.\n        max_iter (int): The maximum number of iterations.\n\n    Returns:\n        int: The number of iterations performed.\n    \"\"\"\n    n = A.shape[0]\n    x = np.zeros(n, dtype=np.float64)\n\n    r = b - A @ x  # Since x is zero, r = b\n    p = r.copy()\n    rs_old = np.dot(r, r)\n\n    norm_b = np.linalg.norm(b)\n    # Handle the trivial case where b is the zero vector.\n    if norm_b == 0.0:\n        return 0\n\n    stop_threshold = tol * norm_b\n\n    # The initial residual r_0 is b. If it already meets the criterion,\n    # 0 iterations are needed. This is unlikely for the given problem.\n    if np.linalg.norm(r) = stop_threshold:\n        return 0\n\n    for k in range(1, max_iter + 1):\n        Ap = A @ p\n        \n        # Numerator for alpha is r_k^T * r_k\n        # Denominator is p_k^T * A * p_k\n        alpha = rs_old / np.dot(p, Ap)\n        \n        # Update solution and residual\n        x = x + alpha * p\n        r = r - alpha * Ap\n        \n        # Check for convergence using the L2-norm of the residual\n        if np.linalg.norm(r) = stop_threshold:\n            return k\n            \n        rs_new = np.dot(r, r)\n        \n        # Update search direction\n        beta = rs_new / rs_old\n        p = r + beta * p\n        \n        rs_old = rs_new\n        \n    # If the loop completes, the method did not converge within max_iter.\n    return max_iter\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiment and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (n, kappa, tol)\n        (64, 1.0, 1e-8),\n        (64, 10.0, 1e-8),\n        (64, 100.0, 1e-8),\n        (64, 1000.0, 1e-8),\n    ]\n\n    results = []\n    \n    # Common parameters\n    n = test_cases[0][0]\n    seed = 0\n\n    # 1. Construct the fixed orthogonal matrix Q, as per the problem description.\n    # Use the modern, preferred way of seeding for reproducibility.\n    rng = np.random.default_rng(seed)\n    M = rng.normal(size=(n, n))\n    \n    # Compute the QR factorization. For a square matrix, 'reduced' is default.\n    Q_hat, R = np.linalg.qr(M)\n    \n    # Create the sign-correction diagonal matrix D to ensure Q is unique.\n    # The problem specifies sign(0) = 1. numpy.sign(0) is 0, so we correct for it.\n    signs = np.sign(np.diag(R))\n    signs[signs == 0] = 1.0\n    # The final fixed orthogonal matrix Q.\n    Q = Q_hat @ np.diag(signs)\n\n    for n_case, kappa, tol in test_cases:\n        # 2. Construct the SPD matrix A(kappa) for the current case.\n        # Eigenvalues are linearly spaced between 1 and kappa.\n        eigenvalues = np.linspace(1.0, kappa, n, dtype=np.float64)\n        Lambda = np.diag(eigenvalues)\n        \n        # Form A = Q^T * Lambda * Q\n        A = Q.T @ Lambda @ Q\n\n        # 3. Define the linear system and solve it.\n        # Right-hand side is a vector of all ones.\n        b = np.ones(n, dtype=np.float64)\n        \n        # The maximum number of iterations is n.\n        max_iterations = n_case\n        \n        # Run the Conjugate Gradient solver.\n        iterations_count = conjugate_gradient(A, b, tol, max_iterations)\n        results.append(iterations_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3209858"}, {"introduction": "最后，我们探讨科学计算的另一个核心领域：常微分方程 (ODE) 求解。本练习聚焦于“刚性”系统，即解的各个分量在极不相同的时间尺度上进行演化。我们将对一个显式方法（4阶龙格-库塔法, RK4）和一个隐式方法（向后欧拉法）进行基准测试，揭示一个关键的权衡：对于刚性问题，显式方法虽然每步计算简单，但为了保持稳定必须采用极小的时间步长 $\\Delta t$；而隐式方法虽然每步计算更复杂，却允许使用大得多的步长。这个实践将帮助你探索稳定性、精度和步长之间的相互作用，并理解为特定问题选择合适工具的重要性 [@problem_id:3209907]。", "problem": "考虑一个二维解耦线性刚性常微分方程组 (ODEs) 的初值问题：\n$$\n\\frac{d}{dt}\n\\begin{bmatrix}\ny_1(t) \\\\\ny_2(t)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\lambda_{\\text{slow}}  0 \\\\\n0  \\lambda_{\\text{fast}}\n\\end{bmatrix}\n\\begin{bmatrix}\ny_1(t) \\\\\ny_2(t)\n\\end{bmatrix}, \\quad\n\\begin{bmatrix}\ny_1(0) \\\\\ny_2(0)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 \\\\\n1\n\\end{bmatrix},\n$$\n其中 $\\lambda_{\\text{slow}}  0$，$\\lambda_{\\text{fast}}  0$，刚性比定义为 $S = \\left|\\lambda_{\\text{fast}}\\right| / \\left|\\lambda_{\\text{slow}}\\right|$。精确解为 $y_i(t) = \\exp\\left(\\lambda_i t\\right)$，其中 $i \\in \\{\\text{slow}, \\text{fast}\\}$。您将在此系列问题上，对显式经典四阶 Runge–Kutta 方法 (RK4) 和隐式后向 Euler 方法进行基准测试。\n\n使用的基本定义：\n- 应用于标量线性测试方程 $y'(t) = \\lambda y(t)$ 的单步法会产生形如 $y_{n+1} = R(z)\\,y_n$ 的更新，其中 $z = \\lambda \\Delta t$ 且 $R(z)$ 是与方法相关的稳定性函数。\n- 对于给定的步长 $\\Delta t$，如果对于系统矩阵的所有特征值 $\\lambda$ 都有 $\\left|R(\\lambda \\Delta t)\\right| \\leq 1$，则称该方法是线性稳定的。对于上述二维对角系统，这简化为要求对 $\\lambda_{\\text{slow}}$ 和 $\\lambda_{\\text{fast}}$ 都稳定。\n- 经过 $N$ 个大小为 $\\Delta t$ 的完整步长和一个大小为 $\\Delta t_{\\text{last}} \\in [0,\\Delta t)$ 的最终部分步长后的数值解满足 $t_N + \\Delta t_{\\text{last}} = T$，并且可以按分量表示为 $y_i^{\\text{num}}(T) = R\\!\\left(\\lambda_i \\Delta t\\right)^N \\, R\\!\\left(\\lambda_i \\Delta t_{\\text{last}}\\right) \\, y_i(0)$，而精确解为 $y_i^{\\text{exact}}(T) = \\exp\\!\\left(\\lambda_i T\\right)\\,y_i(0)$。\n\n您的任务：\n1. 为上述对角线性系统实现显式四阶 Runge–Kutta 方法 (RK4) 和隐式后向 Euler 方法。\n2. 对于每个求解器和每个测试用例，确定同时满足以下条件的最大步长 $\\Delta t_{\\max}$：\n   - 所有分量的线性稳定性，即 $\\left|R\\!\\left(\\lambda_{\\text{slow}} \\Delta t\\right)\\right| \\leq 1$ 和 $\\left|R\\!\\left(\\lambda_{\\text{fast}} \\Delta t\\right)\\right| \\leq 1$。\n   - 在最终时间 $T$ 的精度约束，由误差的无穷范数给出，\n     $$\n     \\left\\| y^{\\text{num}}(T) - y^{\\text{exact}}(T) \\right\\|_{\\infty}\n     =\n     \\max\\left(\n       \\left| y_1^{\\text{num}}(T) - y_1^{\\text{exact}}(T) \\right|,\n       \\left| y_2^{\\text{num}}(T) - y_2^{\\text{exact}}(T) \\right|\n     \\right)\n     \\leq \\varepsilon.\n     $$\n   最终时间用 $T$ 表示，容差用 $\\varepsilon$ 表示。使用 $N = \\left\\lfloor T / \\Delta t \\right\\rfloor$ 个完整步长和一个大小为 $\\Delta t_{\\text{last}} = T - N\\,\\Delta t$ 的最终部分步长（可能为零）。您必须通过在 $\\Delta t \\in (0, \\Delta t_{\\text{upper}}]$ 上进行单调搜索（例如，二分法）来确定 $\\Delta t_{\\max}$，其中 $\\Delta t_{\\text{upper}}$ 是一个安全的上界。对于刚性问题上的 RK4，通过稳定性来限制 $\\Delta t_{\\text{upper}}$；对于后向 Euler 方法，限制为 $\\Delta t_{\\text{upper}} \\leq T$。\n3. 使用以下测试套件。每个测试用例指定 $(\\lambda_{\\text{slow}}, S, T, \\varepsilon)$；设置 $\\lambda_{\\text{fast}} = -S \\left|\\lambda_{\\text{slow}}\\right|$。\n   - 测试 A (理想情况)：$(\\lambda_{\\text{slow}}, S, T, \\varepsilon) = (-1, 100, 1, 10^{-6})$。\n   - 测试 B (强刚性，较宽松的精度)：$(\\lambda_{\\text{slow}}, S, T, \\varepsilon) = (-1, 1000, 1, 10^{-4})$。\n   - 测试 C (长时域，中等刚性，高精度)：$(\\lambda_{\\text{slow}}, S, T, \\varepsilon) = (-0.1, 50, 10, 10^{-8})$。\n4. 对于每个测试用例，计算两个浮点数：RK4 的最大稳定且精确的步长 $\\Delta t_{\\max}^{\\text{RK4}}$，以及后向 Euler 方法的最大稳定且精确的步长 $\\Delta t_{\\max}^{\\text{BE}}$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含六个结果，以逗号分隔的列表形式包含在方括号中，顺序如下\n$$\n\\left[\n\\Delta t_{\\max}^{\\text{RK4}}(\\text{A}),\n\\Delta t_{\\max}^{\\text{BE}}(\\text{A}),\n\\Delta t_{\\max}^{\\text{RK4}}(\\text{B}),\n\\Delta t_{\\max}^{\\text{BE}}(\\text{B}),\n\\Delta t_{\\max}^{\\text{RK4}}(\\text{C}),\n\\Delta t_{\\max}^{\\text{BE}}(\\text{C})\n\\right].\n$$\n所有值必须是浮点数。在这个纯数学设置中不涉及单位。", "solution": "问题陈述已经过严格审查，并被确定为 **有效**。这是一个适定 (well-posed) 的、有科学依据的数值分析练习，旨在对显式和隐式数值方法在刚性常微分方程组 (ODEs) 上的性能进行基准测试。所有参数、定义和约束都已明确给出，从而可以得到唯一且有意义的解。\n\n任务是为两种数值方法——四阶 Runge-Kutta 方法 (RK4) 和后向 Euler 方法 (BE)——找到最大步长 $\\Delta t_{\\max}$，该步长对于给定的二维线性系统同时满足稳定性和精度约束。该系统定义为\n$$\n\\frac{d\\mathbf{y}}{dt} = \\mathbf{A}\\mathbf{y}, \\quad \\mathbf{A} = \\begin{bmatrix} \\lambda_{\\text{slow}}  0 \\\\ 0  \\lambda_{\\text{fast}} \\end{bmatrix}, \\quad \\mathbf{y}(0) = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}.\n$$\n求解过程涉及在每个测试用例的定义区间上对 $\\Delta t_{\\max}$ 进行单调搜索（特别是二分搜索）。\n\n首先，我们必须为每种方法定义稳定性函数 $R(z)$，其中 $z = \\lambda \\Delta t$。对于标量测试方程 $y' = \\lambda y$，数值格式给出 $y_{n+1} = R(\\lambda \\Delta t) y_n$。\n\n对于隐式后向 Euler 方法，更新规则是 $y_{n+1} = y_n + \\Delta t (\\lambda y_{n+1})$。求解 $y_{n+1}$ 可得 $y_{n+1} = (1 - \\lambda \\Delta t)^{-1} y_n$。因此，稳定性函数为：\n$$\nR_{\\text{BE}}(z) = \\frac{1}{1 - z}\n$$\n\n对于显式经典四阶 Runge-Kutta 方法，其稳定性函数是指数函数到四阶的截断泰勒级数：\n$$\nR_{\\text{RK4}}(z) = 1 + z + \\frac{z^2}{2!} + \\frac{z^3}{3!} + \\frac{z^4}{4!}\n$$\n\n接下来，我们分析对步长 $\\Delta t$ 的约束。\n\n第一个约束是线性稳定性，要求对系统的所有特征值都有 $|R(\\lambda \\Delta t)| \\leq 1$。由于 $\\lambda_{\\text{slow}}$ 和 $\\lambda_{\\text{fast}}$ 都是实数且为负，所以 $z = \\lambda \\Delta t$ 是实数且为负。对于后向 Euler 方法，当 $z  0$ 时，我们有 $1 - z  1$，所以 $|R_{\\text{BE}}(z)| = \\frac{1}{1-z}$ 总是在 $0$ 和 $1$ 之间。因此，后向 Euler 方法是 A-稳定的，对此问题不施加步长 $\\Delta t$ 的稳定性限制。因此，对 BE 的 $\\Delta t_{\\max}$ 的搜索上限由积分时间 $T$ 确定，如题目所规定。\n\n对于 RK4 方法，实轴上的绝对稳定域大约是 $[-2.785, 0]$。对于 $z  0$，条件 $|R_{\\text{RK4}}(z)| \\leq 1$ 要求 $z \\geq z_{\\text{stab}}$，其中 $z_{\\text{stab}} \\approx -2.785287335359$。这必须对 $z_{\\text{slow}} = \\lambda_{\\text{slow}} \\Delta t$ 和 $z_{\\text{fast}} = \\lambda_{\\text{fast}} \\Delta t$ 都成立。由于 $|\\lambda_{\\text{fast}}| \\geq |\\lambda_{\\text{slow}}|$，更严格的条件是 $\\lambda_{\\text{fast}} \\Delta t \\geq z_{\\text{stab}}$，这意味着 $\\Delta t \\leq \\frac{z_{\\text{stab}}}{\\lambda_{\\text{fast}}} = \\frac{|z_{\\text{stab}}|}{|\\lambda_{\\text{fast}}|}$。该值作为 RK4 二分搜索的上界 $\\Delta t_{\\text{upper}}$。\n\n第二个约束是精度。在最终时间 $T$ 的误差的无穷范数不得超过容差 $\\varepsilon$：\n$$\n\\left\\| \\mathbf{y}^{\\text{num}}(T) - \\mathbf{y}^{\\text{exact}}(T) \\right\\|_{\\infty} \\leq \\varepsilon\n$$\n问题提供了精确解和数值解的显式公式。分量上的精确解为 $y_i^{\\text{exact}}(T) = \\exp(\\lambda_i T) y_i(0)$。考虑到最终的部分步长，数值解为 $y_i^{\\text{num}}(T) = R(\\lambda_i \\Delta t)^N R(\\lambda_i \\Delta t_{\\text{last}}) y_i(0)$，其中 $N = \\lfloor T / \\Delta t \\rfloor$ 且 $\\Delta t_{\\text{last}} = T - N \\Delta t$。由于 $y_i(0)=1$，对每个分量 $i$ 的条件是：\n$$\n\\left| R(\\lambda_i \\Delta t)^N \\, R(\\lambda_i \\Delta t_{\\text{last}}) - \\exp(\\lambda_i T) \\right| \\leq \\varepsilon\n$$\n\n总体任务是找到满足两个约束的最大 $\\Delta t  0$。对于给定的方法和问题参数，我们定义一个函数 `is_valid(Δt)`，当且仅当稳定性和精度约束都满足时返回 true。对于 RK4，稳定性约束通过将搜索空间限制在 $\\Delta t \\in (0, \\Delta t_{\\text{upper}}]$ 来处理。对于 BE，稳定性总是满足的。通过计算给定 $\\Delta t$ 的误差并将其与 $\\varepsilon$ 比较来检查精度约束。\n\n函数 `is_valid(Δt)` 预期是单调的：如果步长 $\\Delta t$ 有效，任何更小的步长 $\\Delta t'  \\Delta t$ 也将有效，因为对于稳定积分，数值误差通常随步长减小而减小。这种单调性使我们能够使用二分搜索来高效地找到 $\\Delta t_{\\max}$。\n\n二分算法过程如下：\n1. 初始化一个搜索区间 $[\\Delta t_{\\text{low}}, \\Delta t_{\\text{high}}]$，其中 $\\Delta t_{\\text{low}} = 0$ 且 $\\Delta t_{\\text{high}} = \\Delta t_{\\text{upper}}$。\n2. 迭代固定次数（例如，100 次，足以达到双精度准确度）：\n   a. 计算中点 $\\Delta t_{\\text{mid}} = (\\Delta t_{\\text{low}} + \\Delta t_{\\text{high}}) / 2$。\n   b. 如果 `is_valid(Δt_mid)` 为 true，意味着步长 $\\Delta t_{\\text{mid}}$ 是可接受的，我们或许可以找到更大的步长。我们设置 $\\Delta t_{\\text{low}} = \\Delta t_{\\text{mid}}$。\n   c. 如果 `is_valid(Δt_mid)` 为 false，则步长过大。我们设置 $\\Delta t_{\\text{high}} = \\Delta t_{\\text{mid}}$。\n3. 迭代结束后，$\\Delta t_{\\text{low}}$ 是所需 $\\Delta t_{\\max}$ 的一个非常精确的近似值。\n\n将此过程应用于 RK4 和 BE 方法的三个测试用例中的每一个，以计算所需的六个值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the maximum stable and accurate step size for RK4 and Backward Euler\n    methods on a stiff ODE system for a suite of test cases.\n    \"\"\"\n\n    # The stability boundary for the RK4 method on the negative real axis.\n    # Root of 1 + z + z^2/2 + z^3/6 + z^4/24 = -1.\n    RK4_STABILITY_BOUNDARY = 2.785287335359041\n\n    def R_rk4(z: float) - float:\n        \"\"\"Stability function for the classical 4th order Runge-Kutta method.\"\"\"\n        return 1.0 + z * (1.0 + z * (1/2.0 + z * (1/6.0 + z / 24.0)))\n\n    def R_be(z: float) - float:\n        \"\"\"Stability function for the implicit Backward Euler method.\"\"\"\n        return 1.0 / (1.0 - z)\n\n    def find_max_dt(params: tuple, method_type: str) - float:\n        \"\"\"\n        Finds the largest step size dt for a given method and problem parameters\n        that satisfies both stability and accuracy constraints, using bisection search.\n        \"\"\"\n        lambda_slow, S, T, epsilon = params\n        lambda_fast = -S * abs(lambda_slow)\n\n        if method_type == 'RK4':\n            stability_func = R_rk4\n            # For RK4, the step size is limited by the stability region.\n            # |lambda_fast * dt| = RK4_STABILITY_BOUNDARY\n            dt_upper = RK4_STABILITY_BOUNDARY / abs(lambda_fast)\n        elif method_type == 'BE':\n            stability_func = R_be\n            # Backward Euler is A-stable, no stability restriction for these lambda  0.\n            # The problem specifies using T as the upper bound for the search.\n            dt_upper = T\n        else:\n            raise ValueError(f\"Unknown method type: {method_type}\")\n\n        def is_valid(dt: float) - bool:\n            \"\"\"\n            Checks if a given step size dt satisfies the accuracy constraint.\n            Stability is enforced by the search range of the bisection method.\n            \"\"\"\n            if dt = 1e-15:  # Effectively zero dt, considered valid but we search for dt > 0.\n                return True\n\n            N = np.floor(T / dt)\n            dt_last = T - N * dt\n\n            # Component 1 (slow)\n            z_slow = lambda_slow * dt\n            z_slow_last = lambda_slow * dt_last\n            y1_num = (stability_func(z_slow)**N) * stability_func(z_slow_last)\n            y1_exact = np.exp(lambda_slow * T)\n            err1 = abs(y1_num - y1_exact)\n\n            # Component 2 (fast)\n            z_fast = lambda_fast * dt\n            z_fast_last = lambda_fast * dt_last\n            y2_num = (stability_func(z_fast)**N) * stability_func(z_fast_last)\n            y2_exact = np.exp(lambda_fast * T)\n            err2 = abs(y2_num - y2_exact)\n            \n            return max(err1, err2) = epsilon\n\n        # Bisection search to find the boundary of the valid dt region.\n        low = 0.0\n        high = dt_upper\n\n        # Bisection loop for a fixed number of iterations for high precision.\n        for _ in range(100):\n            mid = (low + high) / 2.0\n            if mid == low or mid == high: # Reached floating point precision limit\n                break\n            \n            if is_valid(mid):\n                low = mid  # mid is valid, so it's a candidate. Try for a larger dt.\n            else:\n                high = mid # mid is invalid, dt must be smaller.\n        \n        return low\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (lambda_slow, S, T, epsilon)\n        (-1.0, 100.0, 1.0, 1e-6),    # Case A\n        (-1.0, 1000.0, 1.0, 1e-4),   # Case B\n        (-0.1, 50.0, 10.0, 1e-8),   # Case C\n    ]\n\n    results = []\n    for params in test_cases:\n        dt_max_rk4 = find_max_dt(params, 'RK4')\n        results.append(dt_max_rk4)\n        \n        dt_max_be = find_max_dt(params, 'BE')\n        results.append(dt_max_be)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3209907"}]}