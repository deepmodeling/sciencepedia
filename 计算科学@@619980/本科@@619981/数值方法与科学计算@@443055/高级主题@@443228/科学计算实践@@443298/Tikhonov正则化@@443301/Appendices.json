{"hands_on_practices": [{"introduction": "掌握新方法的第一步是在一个简单、透明的例子上理解其内在机制。本练习将引导你为一个小的病态系统推导蒂霍诺夫正则化解，并分析正则化参数 $\\lambda$ 如何影响解的各个分量。通过这种方式，你可以直观地理解正则化是如何重塑解向量的。[@problem_id:2223140]", "problem": "在许多科学和工程应用中，会遇到形如 $Ax=b$ 的“病态”线性方程组。这意味着测量向量 $b$ 的微小变化可能导致解向量 $x$ 的巨大变化。Tikhonov正则化是在这种情况下稳定解的一种常用方法。正则化解，记为 $x_{\\lambda}$，是通过求解一个修正的优化问题得到的，其公式如下：\n$$x_{\\lambda} = (A^T A + \\lambda^2 I)^{-1} A^T b$$\n在此，A 是系统矩阵，b 是测量向量，I 是单位矩阵，而 $\\lambda  0$ 是一个用户选择的正则化参数，用于控制拟合数据与稳定解之间的权衡。\n\n考虑一个简单的二维系统，其特征由下述矩阵 $A$ 和测量向量 $b$ 给出：\n$$A = \\begin{pmatrix} 1  0 \\\\ 0  0.1 \\end{pmatrix}, \\quad b = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}$$\n矩阵 A 中的小元素使得该系统对噪声敏感，因此是正则化的一个很好候选。您的任务是研究正则化解 $x_{\\lambda}$ 的行为。\n\n请确定正则化参数 $\\lambda$ 的具体值，使得解向量 $x_{\\lambda}$ 的两个分量相等。请将您的答案表示为一个四舍五入到三位有效数字的实数。", "solution": "我们使用 Tikhonov 公式来求解正则化解：\n$$\nx_{\\lambda}=(A^{T}A+\\lambda^2 I)^{-1}A^{T}b.\n$$\n对于给定的对角矩阵 $A = \\begin{pmatrix} 1  0 \\\\ 0  0.1 \\end{pmatrix}$，我们有 $A^{T}=A$，所以\n$$\nA^{T}A = \\begin{pmatrix} 1  0 \\\\ 0  1/100 \\end{pmatrix}, \\quad A^{T}b=\\begin{pmatrix}1\\\\ \\frac{1}{5}\\end{pmatrix}.\n$$\n因此，\n$$\nA^{T}A+\\lambda^2 I=\\begin{pmatrix} 1+\\lambda^2  0 \\\\ 0  \\lambda^2+\\frac{1}{100} \\end{pmatrix}, \\quad (A^{T}A+\\lambda^2 I)^{-1}=\\begin{pmatrix} \\frac{1}{1+\\lambda^2}  0 \\\\ 0  \\frac{1}{\\lambda^2+\\frac{1}{100}} \\end{pmatrix}.\n$$\n所以，\n$$\nx_{\\lambda}=\\begin{pmatrix} \\frac{1}{1+\\lambda^2}  0 \\\\ 0  \\frac{1}{\\lambda^2+\\frac{1}{100}} \\end{pmatrix}\\begin{pmatrix}1\\\\ \\frac{1}{5}\\end{pmatrix}=\\begin{pmatrix}\\frac{1}{1+\\lambda^2}\\\\ \\frac{\\frac{1}{5}}{\\lambda^2+\\frac{1}{100}}\\end{pmatrix}.\n$$\n我们寻找使两个分量相等的 $\\lambda$：\n$$\n\\frac{1}{1+\\lambda^2}=\\frac{\\frac{1}{5}}{\\lambda^2+\\frac{1}{100}}.\n$$\n注意，我们是在寻找 $\\lambda$ 的值，问题中的 $\\lambda^2$ 是公式的一部分。为了避免混淆，我们求解 $\\alpha = \\lambda^2$。\n$$\n\\frac{1}{1+\\alpha}=\\frac{\\frac{1}{5}}{\\alpha+\\frac{1}{100}}.\n$$\n交叉相乘得到\n$$\n\\alpha+\\frac{1}{100}=\\frac{1}{5}(1+\\alpha).\n$$\n两边乘以 $100$，\n$$\n100\\alpha+1=20+20\\alpha \\quad \\Rightarrow \\quad 80\\alpha=19 \\quad \\Rightarrow \\quad \\alpha=\\frac{19}{80}.\n$$\n因此 $\\lambda^2 = 19/80$，$ \\lambda = \\sqrt{19/80} \\approx 0.4873$。\n等一下，题目中的公式是 $x_{\\lambda} = (A^T A + \\lambda I)^{-1} A^T b$ 并且 $\\lambda > 0$。我将遵循题目中给出的公式。\n$$\n\\frac{1}{1+\\lambda}=\\frac{\\frac{1}{5}}{\\lambda+\\frac{1}{100}}.\n$$\n交叉相乘得到\n$$\n\\lambda+\\frac{1}{100}=\\frac{1}{5}(1+\\lambda).\n$$\n两边乘以 $100$，\n$$\n100\\lambda+1=20+20\\lambda \\quad \\Rightarrow \\quad 80\\lambda=19 \\quad \\Rightarrow \\quad \\lambda=\\frac{19}{80}.\n$$\n数值上，$\\lambda=\\frac{19}{80}=0.2375$，四舍五入到三位有效数字是 $0.238$。", "answer": "$$\\boxed{0.238}$$", "id": "2223140"}, {"introduction": "在理解了如何为给定的 $\\lambda$ 计算正则化解之后，下一个关键问题是如何选择一个“合适”的 $\\lambda$ 值。本练习介绍差异原则，这是一种广泛使用的启发式方法，它将 $\\lambda$ 的选择与数据中的噪声水平联系起来。你将求解一个特定的 $\\lambda$，使得解的残差范数与已知的误差水平相匹配，这是应用正则化时的一项核心任务。[@problem_id:2223147]", "problem": "在逆问题的研究中，人们经常遇到形如 $Ax=b$ 的不适定线性系统。一个常见的例子是当试图从一组观测效应 $b$ 中确定一组因果参数 $x$ 时。对于此类系统，矩阵 $A$ 通常是病态的或奇异的，这意味着测量向量 $b$ 中的微小噪声可能导致解向量 $x$ 中出现大的、无物理意义的振荡。\n\n吉洪诺夫正则化是解决此问题的一种广泛使用的技术。它不是直接求解 $Ax=b$，而是寻求一个解 $x_{\\lambda}$，该解能最小化一个同时包含残差范数和解的范数的复合目标函数：\n$$ \\min_{x} \\left( \\|Ax - b\\|_2^2 + \\lambda^2 \\|x\\|_2^2 \\right) $$\n在此，$\\lambda  0$ 是正则化参数，它控制着数据拟合与惩罚解的幅度之间的权衡。\n\n这个过程的一个关键部分是为 $\\lambda$ 选择一个合适的值。偏差原理为此选择提供了一个启发式准则。它假定，如果数据向量 $b$ 中的噪声水平已知或可估计为 $\\delta = \\|b - b_{\\text{true}}\\|_2$，那么 $\\lambda$ 的一个好的选择是使正则化解的残差范数等于这个噪声水平。\n\n考虑一个由矩阵 $A$ 和测量数据向量 $b$ 描述的不适定系统：\n$$ A = \\begin{pmatrix} 1  1 \\\\ 1  1 \\end{pmatrix}, \\quad b = \\begin{pmatrix} 5 \\\\ 3 \\end{pmatrix} $$\n测量 $b$ 中的噪声水平已被估计为 $\\delta = 3\\sqrt{2}$。\n\n通过应用偏差原理来确定正则化参数 $\\lambda$ 的值，在本例中，这意味着找到满足方程 $\\|A x_{\\lambda} - b\\|_2 = \\delta$ 的 $\\lambda  0$ 的值。请将你的最终答案表示为一个精确的、闭式解析表达式。", "solution": "我们寻求吉洪诺夫正则化解\n$$\nx_{\\lambda}=\\arg\\min_{x}\\left(\\|Ax-b\\|_{2}^{2}+\\lambda^{2}\\|x\\|_{2}^{2}\\right),\n$$\n它满足正规方程\n$$\n(A^{T}A+\\lambda^{2}I)x_{\\lambda}=A^{T}b.\n$$\n对于给定的矩阵和向量，\n$$\nA=\\begin{pmatrix} 1  1 \\\\ 1  1 \\end{pmatrix},\\quad b=\\begin{pmatrix}5\\\\3\\end{pmatrix},\n$$\n我们计算\n$$\nA^{T}A=\\begin{pmatrix} 2  2 \\\\ 2  2 \\end{pmatrix},\\quad A^{T}b=Ab=\\begin{pmatrix}8\\\\8\\end{pmatrix}.\n$$\n令 $M= A^{T}A+\\lambda^{2}I=2J+\\lambda^{2}I$，其中 $J$ 是 $2\\times 2$ 的全1矩阵。向量 $u=(1,1)^{T}$ 是 $J$ 的一个特征向量，满足 $J u=2u$，因此 $M u=(4+\\lambda^{2})u$，而任何与 $u$ 正交的向量都是特征值为 $\\lambda^{2}$ 的特征向量。由于 $A^{T}b$ 与 $u$ 成正比，我们得到\n$$\nx_{\\lambda}=\\frac{8}{4+\\lambda^{2}}\\,u=\\frac{8}{4+\\lambda^{2}}\\begin{pmatrix}1\\\\1\\end{pmatrix}.\n$$\n残差为\n$$\nr_{\\lambda}=Ax_{\\lambda}-b=Jx_{\\lambda}-b=\\frac{16}{4+\\lambda^{2}}\\begin{pmatrix}1\\\\1\\end{pmatrix}-\\begin{pmatrix}5\\\\3\\end{pmatrix}.\n$$\n定义 $t=\\dfrac{16}{4+\\lambda^{2}}$。那么\n$$\nr_{\\lambda}=\\begin{pmatrix}t-5\\\\ t-3\\end{pmatrix},\\quad \\|r_{\\lambda}\\|_{2}^{2}=(t-5)^{2}+(t-3)^{2}=2t^{2}-16t+34.\n$$\n偏差原理要求 $\\|r_{\\lambda}\\|_{2}=\\delta=3\\sqrt{2}$，即 $\\|r_{\\lambda}\\|_{2}^{2}=18$，\n$$\n2t^{2}-16t+34=18 \\quad\\Longrightarrow\\quad 2t^{2}-16t+16=0 \\quad\\Longrightarrow\\quad t^{2}-8t+8=0.\n$$\n解此二次方程得到\n$$\nt=4\\pm 2\\sqrt{2}.\n$$\n由于 $t=\\dfrac{16}{4+\\lambda^{2}}$ 且 $\\lambda > 0$，我们有 $4+\\lambda^2 > 4$，因此 $0  t  4$。由于 $4+2\\sqrt{2} \\approx 6.828 > 4$，该解被舍弃。因此我们选择 $t=4-2\\sqrt{2}$。\n$$\n\\frac{16}{4+\\lambda^{2}}=4-2\\sqrt{2} \\quad\\Longrightarrow\\quad 4+\\lambda^{2}=\\frac{16}{4-2\\sqrt{2}}=\\frac{16(4+2\\sqrt{2})}{16-8}=2(4+2\\sqrt{2})=8+4\\sqrt{2}.\n$$\n因此，\n$$\n\\lambda^{2}=4+4\\sqrt{2}=4(1+\\sqrt{2}) \\quad\\Longrightarrow\\quad \\lambda=2\\sqrt{1+\\sqrt{2}}.\n$$", "answer": "$$\\boxed{2\\sqrt{1+\\sqrt{2}}}$$", "id": "2223147"}, {"introduction": "为了获得对解的全面认识，我们通常不是只计算单个 $\\lambda$ 对应的解，而是计算一系列 $\\lambda$ 值下的解。这条“正则化路径”展示了从无正则化的（可能充满噪声的）估计到过度平滑的（接近于零的）解，解的系数是如何演变的。这最后一个综合性练习要求你使用奇异值分解（SVD）实现一个数值稳定的算法，为各种类型的系统计算完整的正则化路径，并在此过程中验证关键的理论性质。[@problem_id:3200591]", "problem": "给定一个带噪声观测的线性系统，其中观测向量 $b \\in \\mathbb{R}^m$ 通过矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 和一个未知的系数向量 $x^\\star \\in \\mathbb{R}^n$ 近似建模为 $b \\approx A x^\\star$。当矩阵 $A$ 是病态或秩亏时，为稳定估计，考虑以下Tikhonov正则化目标\n$$\nJ_\\lambda(x) = \\lVert A x - b \\rVert_2^2 + \\lambda^2 \\lVert x \\rVert_2^2,\n$$\n其中 $\\lambda \\ge 0$ 是正则化参数，$\\lVert \\cdot \\rVert_2$ 表示欧几里得范数。通过改变 $\\lambda$ 并观察系数如何收缩，可以得到统计岭回归路径。\n\n从上述基本定义和关于线性代数的公认事实（包括奇异值分解（SVD）和Moore–Penrose伪逆的存在性及性质）出发，推导一个数值稳定的算法。该算法用于对一个对数间隔的正则化强度 $\\lambda$ 网格，计算 $J_\\lambda(x)$ 相应的最小化子 $x_\\lambda$，并沿此路径跟踪系数的收缩情况。请勿依赖本问题陈述中给出的任何快捷公式。\n\n您的程序必须实现该算法，并将其应用于以下测试套件。为保证可复现性，所有随机抽样必须按指示使用指定的种子和标准正态分布。\n\n- 测试用例1（病态条件良好，超定）：\n  - 维度：$m = 80$，$n = 20$。\n  - 随机种子：$42$。\n  - 构建方法：\n    - 抽取 $A \\in \\mathbb{R}^{80 \\times 20}$，其元素为独立的标准正态分布。\n    - 抽取 $x^\\text{true} \\in \\mathbb{R}^{20}$，其元素为独立的标准正态分布。\n    - 抽取 $\\epsilon \\in \\mathbb{R}^{80}$，其元素为独立的标准正态分布，然后按 $\\sigma = 0.01$ 进行缩放。\n    - 设置 $b = A x^\\text{true} + \\epsilon$。\n- 测试用例2（欠定，宽设计）：\n  - 维度：$m = 50$，$n = 100$。\n  - 随机种子：$123$。\n  - 构建方法：\n    - 抽取 $A \\in \\mathbb{R}^{50 \\times 100}$、$x^\\text{true} \\in \\mathbb{R}^{100}$ 和 $\\epsilon \\in \\mathbb{R}^{50}$，其元素为独立的标准正态分布，其中 $\\epsilon$ 按 $\\sigma = 0.01$ 进行缩放。\n    - 设置 $b = A x^\\text{true} + \\epsilon$。\n- 测试用例3（秩亏设计）：\n  - 维度：$m = 40$，$n = 40$。\n  - 随机种子：$7$。\n  - 构建方法：\n    - 抽取 $A \\in \\mathbb{R}^{40 \\times 40}$，其元素为独立的标准正态分布。\n    - 通过精确的列复制来强制秩亏：将索引为10的列设置为与索引为5的列相等，将索引为15的列设置为与索引为5的列相等。\n    - 抽取 $x^\\text{true} \\in \\mathbb{R}^{40}$ 和 $\\epsilon \\in \\mathbb{R}^{40}$，其元素为独立的标准正态分布，其中 $\\epsilon$ 按 $\\sigma = 0.01$ 进行缩放。\n    - 设置 $b = A x^\\text{true} + \\epsilon$。\n- 测试用例4（具有相关列的高度病态设计）：\n  - 维度：$m = 60$，$n = 20$。\n  - 随机种子：$314$。\n  - 构建方法：\n    - 抽取 $G \\in \\mathbb{R}^{60 \\times 20}$，其元素为独立的标准正态分布。\n    - 通过缩放创建相关且病态的列：对于列索引 $j \\in \\{0,1,\\dots,19\\}$，将 $A$ 的第 $j$ 列设置为 $G$ 的第 $j$ 列乘以 $10^{-\\frac{j}{3}}$。\n    - 抽取 $x^\\text{true} \\in \\mathbb{R}^{20}$ 和 $\\epsilon \\in \\mathbb{R}^{60}$，其元素为独立的标准正态分布，其中 $\\epsilon$ 按 $\\sigma = 0.01$ 进行缩放。\n    - 设置 $b = A x^\\text{true} + \\epsilon$。\n\n对于每个测试用例，使用一个包含60个值的对数间隔网格\n$$\n\\lambda \\in \\{\\lambda_k \\mid \\lambda_k = 10^{\\ell_k},\\ \\ell_k \\text{ equispaced in } [-10,6]\\},\n$$\n即从 $10^{-10}$ 到 $10^{6}$。\n\n对于每个测试用例，计算正则化路径 $\\{x_{\\lambda_k}\\}$ 并评估以下三个布尔属性：\n\n1. 系数欧几里得范数的单调收缩：序列 $\\{\\lVert x_{\\lambda_k} \\rVert_2\\}_{k=1}^{60}$ 在一个小的数值容差范围内是非递增的，即对所有 $k$ 满足 $\\lVert x_{\\lambda_{k}} \\rVert_2 \\le \\lVert x_{\\lambda_{k-1}} \\rVert_2 + \\tau$，其中 $\\tau = 10^{-12} \\cdot \\max(1, \\lVert x_{\\lambda_{k-1}} \\rVert_2)$。\n2. 在小正则化下与最小范数最小二乘解的近似一致性：令 $x_{\\mathrm{lsq}}$ 为最小化 $\\lVert A x - b \\rVert_2$ 且具有最小 $\\lVert x \\rVert_2$ 的Moore–Penrose伪逆解。检查 $x_{\\lambda_{\\min}}$ 和 $x_{\\mathrm{lsq}}$ 之间的相对差异是否满足\n$$\n\\frac{\\lVert x_{\\lambda_{\\min}} - x_{\\mathrm{lsq}} \\rVert_2}{\\max(1,\\lVert x_{\\mathrm{lsq}} \\rVert_2)}  10^{-6}.\n$$\n3. 在非常大的正则化下系数趋近于零：检查是否\n$$\n\\frac{\\lVert x_{\\lambda_{\\max}} \\rVert_2}{\\max(1,\\lVert x_{\\mathrm{lsq}} \\rVert_2)}  10^{-6}.\n$$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的条目按上述顺序针对每个测试用例分组，并跨所有测试用例展开。具体来说，输出必须是一个包含12个布尔值的列表\n$$\n[\\text{m1\\_t1},\\text{m2\\_t1},\\text{m3\\_t1},\\ \\text{m1\\_t2},\\text{m2\\_t2},\\text{m3\\_t2},\\ \\text{m1\\_t3},\\text{m2\\_t3},\\text{m3\\_t3},\\ \\text{m1\\_t4},\\text{m2\\_t4},\\text{m3\\_t4}],\n$$\n其中，对于测试用例 $i$，$\\text{m1\\_t}i$ 是单调收缩检查，$\\text{m2\\_t}i$ 是小 $\\lambda$ 一致性检查，$\\text{m3\\_t}i$ 是大 $\\lambda$ 近零检查。", "solution": "用户提供的问题是计算科学领域一个有效的练习，具体是关于Tikhonov正则化。它要求推导并实现一个数值稳定的算法，为一组明确定义的测试用例计算正则化路径，并验证解的关键理论性质。该问题具有科学依据，是适定的、客观的，并包含了解决它所需的所有必要信息。\n\n### 数值稳定算法的推导\n\nTikhonov正则化目标函数由下式给出：\n$$\nJ_\\lambda(x) = \\lVert A x - b \\rVert_2^2 + \\lambda^2 \\lVert x \\rVert_2^2\n$$\n其中 $A \\in \\mathbb{R}^{m \\times n}$，$b \\in \\mathbb{R}^m$，$x \\in \\mathbb{R}^n$，$\\lambda \\ge 0$ 是正则化参数。函数 $J_\\lambda(x)$ 对于 $x$ 是凸函数。当 $\\lambda  0$ 时，它是严格凸的，保证了唯一最小化子的存在。通过将 $J_\\lambda(x)$ 对 $x$ 的梯度设为零，可以找到最小化子 $x_\\lambda$。\n\n首先，我们展开目标函数：\n$$\nJ_\\lambda(x) = (A x - b)^T (A x - b) + \\lambda^2 x^T x = x^T A^T A x - 2 b^T A x + b^T b + \\lambda^2 x^T I x\n$$\n关于 $x$ 的梯度是：\n$$\n\\nabla_x J_\\lambda(x) = 2 A^T A x - 2 A^T b + 2 \\lambda^2 I x\n$$\n将梯度设为零，$\\nabla_x J_\\lambda(x) = 0$，得到Tikhonov正规方程：\n$$\n(A^T A + \\lambda^2 I) x = A^T b\n$$\n解的形式为 $x_\\lambda = (A^T A + \\lambda^2 I)^{-1} A^T b$。然而，直接构建矩阵 $A^T A$ 在数值上是不稳定的，特别是当 $A$ 是病态矩阵时。$A^T A$ 的条件数是 $A$ 的条件数的平方，这可能导致严重的精度损失。\n\n使用 $A$ 的奇异值分解（SVD）可以推导出一种数值稳定的算法。设 $A$ 的SVD为：\n$$\nA = U \\Sigma V^T\n$$\n这里，$U \\in \\mathbb{R}^{m \\times m}$ 和 $V \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵（$U^T U = I_m$，$V^T V = I_n$），而 $\\Sigma \\in \\mathbb{R}^{m \\times n}$ 是一个矩形对角矩阵，其对角线上是按降序排列的非负奇异值 $\\sigma_i$。令 $k = \\min(m, n)$。奇异值为 $(\\Sigma)_{ii} = \\sigma_i$，其中 $i=1, \\dots, k$。\n\n我们将SVD代入目标函数的第一项。利用欧几里得范数在正交变换下不变的性质（即 $\\lVert U z \\rVert_2 = \\lVert z \\rVert_2$），我们有：\n$$\n\\lVert A x - b \\rVert_2^2 = \\lVert U \\Sigma V^T x - b \\rVert_2^2 = \\lVert U^T (U \\Sigma V^T x - b) \\rVert_2^2 = \\lVert \\Sigma V^T x - U^T b \\rVert_2^2\n$$\n我们引入变量替换。定义 $y = V^T x$ 和 $c = U^T b$。由于 $V$ 是正交的，因此 $x = V y$，并且范数得以保留：$\\lVert x \\rVert_2^2 = \\lVert V y \\rVert_2^2 = \\lVert y \\rVert_2^2$。目标函数在 $y$ 的表示下变换为一个更简单的形式：\n$$\nJ_\\lambda(y) = \\lVert \\Sigma y - c \\rVert_2^2 + \\lambda^2 \\lVert y \\rVert_2^2\n$$\n这种形式是可分离的。我们可以将其写成关于 $y$ 和 $c$ 各分量的和：\n$$\nJ_\\lambda(y) = \\sum_{i=1}^m \\left( (\\Sigma y)_i - c_i \\right)^2 + \\lambda^2 \\sum_{j=1}^n y_j^2\n$$\n考虑到 $\\Sigma$ 的结构：\n- 对于 $i \\le k = \\min(m, n)$，$(\\Sigma y)_i = \\sigma_i y_i$。\n- 对于 $i  k$，$(\\Sigma y)_i = 0$。\n目标函数变为：\n$$\nJ_\\lambda(y) = \\sum_{i=1}^k (\\sigma_i y_i - c_i)^2 + \\sum_{i=k+1}^m c_i^2 + \\lambda^2 \\left( \\sum_{i=1}^k y_i^2 + \\sum_{i=k+1}^n y_i^2 \\right)\n$$\n项 $\\sum_{i=k+1}^m c_i^2$ 是一个相对于 $y$ 的常数。为了最小化 $J_\\lambda(y)$，我们可以对每个分量 $y_i$ 独立地最小化其余部分。\n对于 $i \\in \\{1, \\dots, k\\}$：我们最小化 $(\\sigma_i y_i - c_i)^2 + \\lambda^2 y_i^2$。将其对 $y_i$ 的导数设为零，得到：\n$$\n2(\\sigma_i y_i - c_i)\\sigma_i + 2\\lambda^2 y_i = 0 \\implies (\\sigma_i^2 + \\lambda^2) y_i = \\sigma_i c_i\n$$\n$y_i$ 的解是：\n$$\ny_i = \\frac{\\sigma_i c_i}{\\sigma_i^2 + \\lambda^2}\n$$\n即使 $\\sigma_i = 0$，这个公式也是良定义的，在这种情况下 $y_i=0$（对于 $\\lambda  0$）。\n对于 $i \\in \\{k+1, \\dots, n\\}$（这种情况仅在 $nm$ 时发生，此时 $k=m$）：我们最小化 $\\lambda^2 y_i^2$。对于 $\\lambda  0$，在 $y_i = 0$ 处达到最小值。\n\n因此，解向量 $y_\\lambda \\in \\mathbb{R}^n$ 的分量为：\n$$\n(y_\\lambda)_i =\n\\begin{cases}\n\\frac{\\sigma_i (U^T b)_i}{\\sigma_i^2 + \\lambda^2}  \\text{对于 } 1 \\le i \\le k \\\\\n0  \\text{对于 } k  i \\le n\n\\end{cases}\n$$\n最后，我们使用 $x = V y$ 将解 $y_\\lambda$ 转换回原始变量 $x_\\lambda$：\n$$\nx_\\lambda = V y_\\lambda = \\sum_{i=1}^k (y_\\lambda)_i v_i\n$$\n其中 $v_i$ 是 $V$ 的列（或 $V^T$ 的行）。\n\n这导出了以下数值稳定的算法：\n1. 计算 $A = U \\Sigma V^T$ 的完全SVD。\n2. 计算变换后的向量 $c = U^T b$。\n3. 对于网格中每个所需的 $\\lambda$：\n    a. 初始化一个 $n$ 维零向量 $y_\\lambda$。\n    b. 对于 $i=1, \\dots, k=\\min(m,n)$，计算 $(y_\\lambda)_i = \\frac{\\sigma_i c_i}{\\sigma_i^2 + \\lambda^2}$。\n    c. 计算解 $x_\\lambda = V y_\\lambda$。\n该算法避免了 $A^T A$ 的形成，并依赖于稳健的SVD计算，使其在数值上更优越。它能正确处理秩亏和病态矩阵。\n\n### 性质验证\n\n问题要求检查三个性质：\n1.  **范数的单调收缩**：我们必须验证 $\\lVert x_\\lambda \\rVert_2$ 是 $\\lambda$ 的一个非递增函数。从解析上看，$\\lVert x_\\lambda \\rVert_2^2 = \\lVert y_\\lambda \\rVert_2^2 = \\sum_{i=1}^k \\left(\\frac{\\sigma_i c_i}{\\sigma_i^2 + \\lambda^2}\\right)^2$。和中的每一项都是 $\\lambda \\ge 0$ 的非递增函数，因此它们的和也是非递增的。因此，该性质预计在数值精度范围内成立。\n\n2.  **小 $\\lambda$ 极限**：当 $\\lambda \\to 0$ 时，$x_\\lambda$ 应趋近于最小范数最小二乘解 $x_{\\mathrm{lsq}} = A^+ b$，其中 $A^+$ 是 $A$ 的Moore-Penrose伪逆。根据我们的推导，当 $\\lambda \\to 0$ 时：\n    $$\n    (y_\\lambda)_i \\to\n    \\begin{cases}\n    c_i / \\sigma_i  \\text{如果 } \\sigma_i  0 \\\\\n    0  \\text{如果 } \\sigma_i = 0\n    \\end{cases}\n    $$\n    这个极限向量恰好是 $\\Sigma^+ c$。因此，$x_0 = V \\Sigma^+ c = V \\Sigma^+ U^T b = A^+ b$。该性质预计成立。\n\n3.  **大 $\\lambda$ 极限**：当 $\\lambda \\to \\infty$ 时，分母 $\\sigma_i^2 + \\lambda^2$ 增大，导致每个 $(y_\\lambda)_i \\to 0$。因此，$y_\\lambda \\to 0$ 且 $x_\\lambda = V y_\\lambda \\to 0$。系数预计将收缩至零。\n\n该实现将生成测试用例，应用基于SVD的算法，并凭经验验证这三个性质。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import svd\n\ndef solve():\n    \"\"\"\n    Solves the Tikhonov regularization problem for four test cases\n    and verifies theoretical properties of the regularization path.\n    \"\"\"\n    test_cases_params = [\n        # (m, n, seed)\n        (80, 20, 42),\n        (50, 100, 123),\n        (40, 40, 7),\n        (60, 20, 314),\n    ]\n\n    all_results = []\n\n    for i, params in enumerate(test_cases_params):\n        m, n, seed = params\n        rng = np.random.default_rng(seed)\n\n        if i == 0:  # Case 1: well-conditioned, overdetermined\n            A = rng.standard_normal((m, n))\n            x_true = rng.standard_normal(n)\n            epsilon = rng.standard_normal(m) * 0.01\n            b = A @ x_true + epsilon\n        elif i == 1:  # Case 2: underdetermined\n            A = rng.standard_normal((m, n))\n            x_true = rng.standard_normal(n)\n            epsilon = rng.standard_normal(m) * 0.01\n            b = A @ x_true + epsilon\n        elif i == 2:  # Case 3: rank-deficient\n            A = rng.standard_normal((m, n))\n            A[:, 10] = A[:, 5]\n            A[:, 15] = A[:, 5]\n            x_true = rng.standard_normal(n)\n            epsilon = rng.standard_normal(m) * 0.01\n            b = A @ x_true + epsilon\n        elif i == 3:  # Case 4: ill-conditioned\n            G = rng.standard_normal((m, n))\n            A = np.zeros_like(G)\n            for j in range(n):\n                A[:, j] = G[:, j] * (10**(-j / 3.0))\n            x_true = rng.standard_normal(n)\n            epsilon = rng.standard_normal(m) * 0.01\n            b = A @ x_true + epsilon\n\n        # Regularization path calculation\n        lambda_grid = np.logspace(-10, 6, 60)\n        \n        # SVD-based solution\n        U, s, Vt = svd(A, full_matrices=True)\n        k = len(s)\n        V = Vt.T\n        c = U.T @ b\n\n        x_path = []\n        for lam in lambda_grid:\n            y = np.zeros(n)\n            y[:k] = (s * c[:k]) / (s**2 + lam**2)\n            x_lam = V @ y\n            x_path.append(x_lam)\n\n        x_path_norms = [np.linalg.norm(x) for x in x_path]\n\n        # Verification checks\n        \n        # 1. Monotone shrinkage of the coefficient Euclidean norm\n        is_monotone = True\n        for k_idx in range(1, len(x_path_norms)):\n            norm_prev = x_path_norms[k_idx - 1]\n            norm_curr = x_path_norms[k_idx]\n            # Since lambda grid is increasing, norm should be non-increasing\n            tolerance = 1e-12 * max(1, norm_prev)\n            if norm_curr > norm_prev + tolerance:\n                is_monotone = False\n                break\n        \n        # 2. Near-agreement with least squares at small lambda\n        x_lsq = np.linalg.pinv(A) @ b\n        norm_x_lsq = np.linalg.norm(x_lsq)\n        x_lambda_min = x_path[0]\n        \n        rel_diff_small_lambda = np.linalg.norm(x_lambda_min - x_lsq) / max(1, norm_x_lsq)\n        agrees_at_small_lambda = rel_diff_small_lambda  1e-6\n        \n        # 3. Near-zero coefficients at very large lambda\n        x_lambda_max = x_path[-1]\n        norm_x_lambda_max = np.linalg.norm(x_lambda_max)\n        \n        ratio_large_lambda = norm_x_lambda_max / max(1, norm_x_lsq)\n        zero_at_large_lambda = ratio_large_lambda  1e-6\n\n        all_results.extend([is_monotone, agrees_at_small_lambda, zero_at_large_lambda])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3200591"}]}