{"hands_on_practices": [{"introduction": "从连续的偏微分方程到可解的数值模型，第一步就是离散化。本节的第一个练习将带你完成一项基础训练：将微积分的语言翻译成代数的语言。通过为对流扩散方程推导Crank-Nicolson格式 [@problem_id:2139864]，你将掌握应用有限差分近似来构建稳定、精确数值方法的“纸上”核心技能，为后续所有编程实践打下坚实基础。", "problem": "考虑一维对流扩散方程，该方程可用于模拟诸如污染物在河道中输运等现象。该方程由下式给出：\n$$ \\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = D \\frac{\\partial^2 u}{\\partial x^2} $$\n其中，$u(x,t)$ 是物质在位置 $x$ 和时间 $t$ 的浓度，$c$ 是恒定的对流速度，$D$ 是恒定的扩散系数。\n\n我们希望构建一个有限差分格式，在空间步长为 $\\Delta x$、时间步长为 $\\Delta t$ 的均匀网格上对该方程进行数值求解。我们将 $u(j\\Delta x, n\\Delta t)$ 的数值近似值记为 $u_j^n$。\n\n该格式将通过应用 Crank-Nicolson 方法来建立，该方法涉及将有限差分中心化在半时间步 $t_{n+1/2} = (n + 1/2)\\Delta t$ 上。具体的离散化规则如下：\n1.  时间导数 $\\frac{\\partial u}{\\partial t}$ 用在时间 $t_{n+1/2}$ 处的中心差分来近似。\n2.  扩散项 $D \\frac{\\partial^2 u}{\\partial x^2}$ 用时间层 $n$ 和 $n+1$ 上二阶空间导数的标准中心差分近似值的平均值来近似。\n3.  对流项 $c \\frac{\\partial u}{\\partial x}$ 用空间中心差分来近似。然后通过对时间层 $n$ 和 $n+1$ 上的值进行平均，在半时间步 $t_{n+1/2}$ 处计算该空间差分。\n\n遵循这些规则，推导出有限差分方程，并将其整理为标准的隐式三对角形式：\n$$ A u_{j-1}^{n+1} + B u_j^{n+1} + C u_{j+1}^{n+1} = E u_{j-1}^{n} + F u_j^{n} + G u_{j+1}^{n} $$\n确定系数 $A, B, C, E, F,$ 和 $G$ 关于无量纲 Courant 数 $\\nu = \\frac{c \\Delta t}{\\Delta x}$ 和扩散数 $\\mu = \\frac{D \\Delta t}{(\\Delta x)^2}$ 的表达式。\n\n将您的最终答案表示为一个单行矩阵，其中包含按顺序排列的六个系数 $\\begin{pmatrix} A  B  C  E  F  G \\end{pmatrix}$。", "solution": "我们从对流扩散方程开始\n$$\n\\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = D \\frac{\\partial^{2} u}{\\partial x^{2}}.\n$$\n在一个均匀网格上，其中 $u_{j}^{n} \\approx u(j\\Delta x,n\\Delta t)$，在半时间步 $t_{n+1/2}$ 处的 Crank-Nicolson 离散化使用：\n- 时间导数使用中心时间差分，\n- 一阶和二阶空间导数均使用时间 $n$ 和 $n+1$ 处的中心空间差分的平均值。\n\n因此，\n$$\n\\frac{u_{j}^{n+1} - u_{j}^{n}}{\\Delta t}\n+ c \\cdot \\frac{1}{2} \\left[ \\frac{u_{j+1}^{n} - u_{j-1}^{n}}{2\\Delta x} + \\frac{u_{j+1}^{n+1} - u_{j-1}^{n+1}}{2\\Delta x} \\right]\n= D \\cdot \\frac{1}{2} \\left[ \\frac{u_{j+1}^{n} - 2u_{j}^{n} + u_{j-1}^{n}}{(\\Delta x)^{2}} + \\frac{u_{j+1}^{n+1} - 2u_{j}^{n+1} + u_{j-1}^{n+1}}{(\\Delta x)^{2}} \\right].\n$$\n两边乘以 $\\Delta t$ 并引入 Courant 数 $\\nu = \\frac{c \\Delta t}{\\Delta x}$ 和扩散数 $\\mu = \\frac{D \\Delta t}{(\\Delta x)^{2}}$，得到\n$$\nu_{j}^{n+1} - u_{j}^{n}\n+ \\frac{\\nu}{4} \\left[ \\left(u_{j+1}^{n} - u_{j-1}^{n}\\right) + \\left(u_{j+1}^{n+1} - u_{j-1}^{n+1}\\right) \\right]\n= \\frac{\\mu}{2} \\left[ \\left(u_{j+1}^{n} - 2u_{j}^{n} + u_{j-1}^{n}\\right) + \\left(u_{j+1}^{n+1} - 2u_{j}^{n+1} + u_{j-1}^{n+1}\\right) \\right].\n$$\n将时间层 $n+1$ 的项收集到左边，时间层 $n$ 的项收集到右边：\n$$\nu_{j}^{n+1}\n+ \\frac{\\nu}{4}\\left(u_{j+1}^{n+1} - u_{j-1}^{n+1}\\right)\n- \\frac{\\mu}{2}\\left(u_{j+1}^{n+1} - 2u_{j}^{n+1} + u_{j-1}^{n+1}\\right)\n= u_{j}^{n}\n- \\frac{\\nu}{4}\\left(u_{j+1}^{n} - u_{j-1}^{n}\\right)\n+ \\frac{\\mu}{2}\\left(u_{j+1}^{n} - 2u_{j}^{n} + u_{j-1}^{n}\\right).\n$$\n展开并收集左边 $u_{j-1}^{n+1}$, $u_{j}^{n+1}$, $u_{j+1}^{n+1}$ 的系数，以及右边 $u_{j-1}^{n}$, $u_{j}^{n}$, $u_{j+1}^{n}$ 的系数。这就得到了三对角形式\n$$\nA u_{j-1}^{n+1} + B u_{j}^{n+1} + C u_{j+1}^{n+1} = E u_{j-1}^{n} + F u_{j}^{n} + G u_{j+1}^{n},\n$$\n其中\n$$\nA = -\\frac{\\mu}{2} - \\frac{\\nu}{4}, \\quad\nB = 1 + \\mu, \\quad\nC = -\\frac{\\mu}{2} + \\frac{\\nu}{4}, \\quad\nE = \\frac{\\mu}{2} + \\frac{\\nu}{4}, \\quad\nF = 1 - \\mu, \\quad\nG = \\frac{\\mu}{2} - \\frac{\\nu}{4}.\n$$\n当 $c=0$ 时，这些系数正确地简化为标准的 Crank-Nicolson 扩散格式；当 $D=0$ 时，简化为中心梯形对流格式。", "answer": "$$\\boxed{\\begin{pmatrix}-\\frac{\\mu}{2}-\\frac{\\nu}{4}  1+\\mu  -\\frac{\\mu}{2}+\\frac{\\nu}{4}  \\frac{\\mu}{2}+\\frac{\\nu}{4}  1-\\mu  \\frac{\\mu}{2}-\\frac{\\nu}{4}\\end{pmatrix}}$$", "id": "2139864"}, {"introduction": "均匀网格虽然简单，但往往效率不高。许多物理问题在特定区域（如边界层）会出现解的剧烈变化，需要更密的网格才能精确捕捉。本练习将从理论推导走向编程实现，向你展示如何设计并应用静态的非均匀网格来求解一个包含边界层的问题 [@problem_id:3223740]。你将亲手验证一个经过精心“拉伸”的网格相比于简单的均匀网格，能够在精度上带来多么显著的提升，从而体会到使离散化适应问题结构的强大威力。", "problem": "你将通过在非均匀网格上推导一个稳定的有限差分格式、实现它，并凭经验选择一个能使精确误差度量最小化的网格加密参数，来研究奇异摄动边值问题的非均匀网格设计。考虑常微分方程 (ODE)\n$$\n\\varepsilon\\,u''(x) + u'(x) = 0,\\quad x\\in(0,1),\n$$\n其边界条件为\n$$\nu(0)=0,\\qquad u(1)=1,\n$$\n其中 $\\varepsilon>0$ 是一个给定参数。当 $\\varepsilon$ 很小时，该问题在 $x=0$ 附近表现出边界层。\n\n你必须完成以下任务：\n\n1) 在一个严格递增的非均匀网格 $\\{x_j\\}_{j=0}^{N}$（其中 $x_0=0$, $x_N=1$）上，为该 ODE 推导一个相容且稳定的有限差分格式，需使用：\n- 一种二阶导数的守恒型三点逼近，该逼近在非均匀网格上通过相邻子区间上扩散通量的差分得到，以及\n- 一种一阶导数的迎风（后向）差分，该差分遵循对流项的方向。\n\n推导必须从导数作为差商极限的定义以及控制体上的积分守恒出发，并且除了严格单调性外，不得对网格的任何特殊规律性做出假设。设 $h_{j-1/2}=x_j-x_{j-1}$ 且 $h_{j+1/2}=x_{j+1}-x_j$，对于 $j\\in\\{1,\\dots,N-1\\}$。在 $x_0$ 和 $x_N$ 处强加边界条件。\n\n2) 设非均匀网格由一个单参数指数映射 $\\varphi_\\alpha:[0,1]\\to[0,1]$ 生成，对于 $\\alpha>0$ 定义为\n$$\n\\varphi_\\alpha(t)=\\frac{e^{\\alpha t}-1}{e^{\\alpha}-1},\n$$\n对于 $\\alpha=0$ 定义为 $\\varphi_0(t)=t$。通过 $x_j=\\varphi_\\alpha\\!\\left(\\frac{j}{N}\\right)$ 定义网格节点，其中 $j\\in\\{0,1,\\dots,N\\}$。参数 $\\alpha$ 控制在 $x=0$ 附近的加密程度；越大的 $\\alpha$ 产生越强的加密。\n\n3) 对于给定的 $(\\varepsilon,N)$ 对，定义候选加密参数集\n$$\n\\mathcal{A}=\\{0,2,4,6,8,10\\}。\n$$\n对于每个 $\\alpha\\in\\mathcal{A}$，构建网格 $\\{x_j\\}$，组装并求解离散系统，并计算相对于 ODE 精确解 $u_{\\text{exact}}(x)$ 的无穷范数下的最大节点误差。精确解由 ODE 和边界条件唯一确定。\n\n设离散解为 $\\{u_j\\}_{j=0}^{N}$，定义误差为\n$$\nE(\\alpha;\\varepsilon,N)=\\max_{0\\le j\\le N}\\,\\left|u_j - u_{\\text{exact}}(x_j)\\right|。\n$$\n定义 $(\\varepsilon,N)$ 的经验最优加密参数为\n$$\n\\alpha^\\star(\\varepsilon,N)=\\arg\\min_{\\alpha\\in\\mathcal{A}} E(\\alpha;\\varepsilon,N),\n$$\n若存在相同结果，则选择最小的 $\\alpha$。\n\n4) 实现一个程序，对以下测试套件中的每个测试用例执行上述过程：\n- 测试 $1$：$(\\varepsilon,N)=\\left(10^{-1},\\,64\\right)$。\n- 测试 $2$：$(\\varepsilon,N)=\\left(5\\cdot 10^{-2},\\,64\\right)$。\n- 测试 $3$：$(\\varepsilon,N)=\\left(10^{-2},\\,32\\right)$。\n- 测试 $4$：$(\\varepsilon,N)=\\left(10^{-3},\\,64\\right)$。\n\n5) 你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须是\n$$\n[\\alpha^\\star(\\varepsilon_1,N_1),\\alpha^\\star(\\varepsilon_2,N_2),\\alpha^\\star(\\varepsilon_3,N_3),\\alpha^\\star(\\varepsilon_4,N_4)],\n$$\n按测试 $1$ 到 $4$ 的顺序排列，每个条目都是来自 $\\mathcal{A}$ 的一个整数。例如，格式应如 [$x$,$y$,$z$,$w$]。\n\n注意和约束：\n- 不涉及物理单位。\n- 不涉及角度。\n- 唯一允许的库是标准库和数值数组库，并且程序必须是自包含的，没有用户输入。\n- 对于所有 $\\alpha\\in\\mathcal{A}$ 和 $N\\in\\{32,64\\}$，网格必须是严格递增的。\n- 离散线性系统应对每个网格进行精确求解（在浮点运算精度内），并且必须在所有网格节点（包括端点）上计算误差。", "solution": "用户要求使用非均匀网格上的有限差分法求解一个奇异摄动边值问题（BVP）。核心任务是推导数值格式，实现它，并用它为几个测试用例找到经验最优的网格加密参数。\n\n### 第 1 部分：有限差分格式的推导\n\n给定的 BVP 是：\n$$\n\\varepsilon\\,u''(x) + u'(x) = 0, \\quad x \\in (0,1)\n$$\n边界条件为 $u(0)=0$ 和 $u(1)=1$。\n\n我们需要在一个严格递增的非均匀网格 $\\{x_j\\}_{j=0}^{N}$（其中 $x_0=0$，$x_N=1$）上离散化这个方程。步长定义为 $h_{j-1/2} = x_j - x_{j-1}$ 和 $h_{j+1/2} = x_{j+1} - x_j$。离散化是针对内部节点 $j=1, \\dots, N-1$。\n\n**二阶导数 ($u''$) 的离散化**\n\n问题要求使用一种守恒型三点逼近来近似二阶导数，该逼近从扩散通量的差分推导而来。这通常通过在以 $x_j$ 为中心的控制体（例如 $[(x_{j-1}+x_j)/2, (x_j+x_{j+1})/2]$）上使用有限体积法来实现。该控制体的长度为 $\\frac{1}{2}(h_{j-1/2} + h_{j+1/2})$。项 $\\varepsilon u''$ 对应于扩散通量 $\\varepsilon u'$ 的散度。在控制体上对 $\\varepsilon u''$ 进行积分得到 $\\varepsilon[u']_{(x_{j-1}+x_j)/2}^{(x_j+x_{j+1})/2}$。用中心差分逼近控制体边界上的导数：\n$$\nu'\\left(\\frac{x_j+x_{j+1}}{2}\\right) \\approx \\frac{u_{j+1}-u_j}{x_{j+1}-x_j} = \\frac{u_{j+1}-u_j}{h_{j+1/2}}\n$$\n$$\nu'\\left(\\frac{x_{j-1}+x_j}{2}\\right) \\approx \\frac{u_j-u_{j-1}}{x_j-x_{j-1}} = \\frac{u_j-u_{j-1}}{h_{j-1/2}}\n$$\n除以控制体的长度，节点 $x_j$ 处 $u''(x_j)$ 的逼近为：\n$$\nu''(x_j) \\approx \\frac{ \\frac{u_{j+1}-u_j}{h_{j+1/2}} - \\frac{u_j-u_{j-1}}{h_{j-1/2}} }{ \\frac{1}{2}(h_{j-1/2} + h_{j+1/2}) } = \\frac{2}{h_{j-1/2} + h_{j+1/2}} \\left( \\frac{u_{j+1}-u_j}{h_{j+1/2}} - \\frac{u_j-u_{j-1}}{h_{j-1/2}} \\right)\n$$\n\n**一阶导数 ($u'$) 的离散化**\n\n问题指定使用迎风（后向）差分来近似一阶导数。由于 $u'(x)$ 的系数为正（$+1$），“风”或输运方向是从左到右。因此，$x_j$ 处的迎风格式使用来自上游节点的信息，即 $x_j$ 和 $x_{j-1}$。后向差分逼近为：\n$$\nu'(x_j) \\approx \\frac{u_j - u_{j-1}}{x_j - x_{j-1}} = \\frac{u_j - u_{j-1}}{h_{j-1/2}}\n$$\n\n**组装离散方程**\n\n结合两个导数的逼近，内部节点 $x_j$ 处的离散方程为：\n$$\n\\varepsilon \\frac{2}{h_{j-1/2} + h_{j+1/2}} \\left( \\frac{u_{j+1}-u_j}{h_{j+1/2}} - \\frac{u_j-u_{j-1}}{h_{j-1/2}} \\right) + \\frac{u_j - u_{j-1}}{h_{j-1/2}} = 0\n$$\n为了形成一个线性系统，我们按未知数 $u_{j-1}$、$u_j$ 和 $u_{j+1}$ 对各项进行分组：\n$a_j u_{j-1} + b_j u_j + c_j u_{j+1} = 0$，其中：\n- $u_{j-1}$ 的系数：\n  $a_j = \\varepsilon \\frac{2}{(h_{j-1/2} + h_{j+1/2})h_{j-1/2}} - \\frac{1}{h_{j-1/2}}$\n- $u_{j+1}$ 的系数：\n  $c_j = \\varepsilon \\frac{2}{(h_{j-1/2} + h_{j+1/2})h_{j+1/2}}$\n- $u_j$ 的系数：\n  $b_j = -\\varepsilon \\frac{2}{h_{j-1/2} + h_{j+1/2}}\\left(\\frac{1}{h_{j+1/2}} + \\frac{1}{h_{j-1/2}}\\right) + \\frac{1}{h_{j-1/2}}$\n\n这些方程对 $j=1, \\dots, N-1$ 成立。通过强加边界条件 $u_0 = u(0) = 0$ 和 $u_N = u(1) = 1$，我们可以为内部未知数 $\\mathbf{u} = [u_1, u_2, \\dots, u_{N-1}]^T$ 构建一个线性系统。\n- 对于 $j=1$：$a_1 u_0 + b_1 u_1 + c_1 u_2 = 0 \\implies b_1 u_1 + c_1 u_2 = -a_1 u_0 = 0$。\n- 对于 $j=N-1$：$a_{N-1} u_{N-2} + b_{N-1} u_{N-1} + c_{N-1} u_N = 0 \\implies a_{N-1} u_{N-2} + b_{N-1} u_{N-1} = -c_{N-1} u_N = -c_{N-1}$。\n\n这将产生一个 $(N-1) \\times (N-1)$ 的三对角线性方程组 $A\\mathbf{u}=\\mathbf{f}$，可以求解得到内部节点的值。\n\n### 第 2 部分：精确解与数值求解过程\n\n**精确解**\n\n该 ODE 是一个二阶线性齐次常系数方程。其特征方程为 $\\varepsilon r^2 + r = 0$，根为 $r_1=0$ 和 $r_2=-1/\\varepsilon$。通解为 $u(x) = C_1 + C_2 e^{-x/\\varepsilon}$。应用边界条件 $u(0)=0$ 和 $u(1)=1$ 可得唯一解：\n$$\nu_{\\text{exact}}(x) = \\frac{1 - e^{-x/\\varepsilon}}{1 - e^{-1/\\varepsilon}}\n$$\n\n**数值过程**\n\n对于每个测试用例 $(\\varepsilon, N)$，我们执行以下优化：\n1. 初始化 $\\alpha^\\star = -1$ 和 $E_{min} = \\infty$。\n2. 遍历候选集 $\\mathcal{A}=\\{0, 2, 4, 6, 8, 10\\}$ 中的每个 $\\alpha$。\n3. 对于每个 $\\alpha$：\n    a. 使用映射 $x_j=\\varphi_\\alpha\\!\\left(j/N\\right)$ 生成非均匀网格 $\\{x_j\\}_{j=0}^N$，其中对于 $\\alpha>0$，$\\varphi_\\alpha(t)=\\frac{e^{\\alpha t}-1}{e^{\\alpha}-1}$，对于 $\\alpha=0$，$\\varphi_0(t)=t$。\n    b. 使用推导出的系数 $a_j, b_j, c_j$ 为未知数 $\\{u_j\\}_{j=1}^{N-1}$ 组装三对角矩阵 $A$ 和右端向量 $\\mathbf{f}$。\n    c. 求解线性系统 $A\\mathbf{u}=\\mathbf{f}$ 以找到内部节点的数值解。\n    d. 通过包含边界值 $u_0=0$ 和 $u_N=1$ 来构建完整的数值解向量 $\\{u_j\\}_{j=0}^N$。\n    e. 在每个网格节点上计算精确解 $u_{\\text{exact}}(x_j)$。\n    f. 计算最大节点误差 $E(\\alpha) = \\max_{0\\le j\\le N} |u_j - u_{\\text{exact}}(x_j)|$。\n    g. 如果 $E(\\alpha) < E_{min}$，则更新 $E_{min} = E(\\alpha)$ 和 $\\alpha^\\star = \\alpha$。\n4. 最终的 $\\alpha^\\star$ 是给定 $(\\varepsilon, N)$ 的经验最优参数。\n\n对问题中指定的所有测试用例重复此过程。最终输出是最优 $\\alpha^\\star$ 值的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and tests a finite difference scheme for a singularly\n    perturbed boundary value problem to find an optimal grid clustering parameter.\n    \"\"\"\n\n    def generate_mesh(N, alpha):\n        \"\"\"Generates a non-uniform mesh using an exponential mapping.\"\"\"\n        t = np.linspace(0, 1, N + 1)\n        if alpha == 0:\n            x = t\n        else:\n            x = (np.exp(alpha * t) - 1) / (np.exp(alpha) - 1)\n        return x\n\n    def solve_bvp(eps, N, x):\n        \"\"\"\n        Assembles and solves the tridiagonal linear system for the BVP.\n        \"\"\"\n        # We need to solve for N-1 interior unknowns u_1, ..., u_{N-1}.\n        # The system size is (N-1)x(N-1).\n        \n        # Calculate step sizes h (N elements).\n        # h[k] corresponds to x_{k+1}-x_k, which is h_{k+1/2}.\n        h = np.diff(x)\n        \n        # Diagonals of the matrix A\n        main_diag = np.zeros(N - 1)\n        lower_diag = np.zeros(N - 2)\n        upper_diag = np.zeros(N - 2)\n        \n        # Right-hand side vector f\n        f = np.zeros(N - 1)\n\n        # Loop over interior nodes j = 1, ..., N-1\n        # This corresponds to rows i = 0, ..., N-2 of the matrix.\n        for j in range(1, N):\n            i = j - 1 # Matrix row index\n            \n            h_prev = h[j - 1]  # h_{j-1/2}\n            h_next = h[j]      # h_{j+1/2}\n            h_sum = h_prev + h_next\n\n            # Coefficients a_j, b_j, c_j\n            a_j = eps * 2 / (h_sum * h_prev) - 1 / h_prev\n            c_j = eps * 2 / (h_sum * h_next)\n            b_j = -eps * 2 / h_sum * (1 / h_next + 1 / h_prev) + 1 / h_prev\n\n            main_diag[i] = b_j\n            if j > 1:\n                lower_diag[i - 1] = a_j\n            if j  N - 1:\n                upper_diag[i] = c_j\n        \n        # Build the tridiagonal matrix\n        A = np.diag(main_diag) + np.diag(lower_diag, k=-1) + np.diag(upper_diag, k=1)\n        \n        # Set the right-hand side vector f\n        # Boundary condition u_N = 1 affects the last equation (j = N-1)\n        # Calculate c_{N-1}\n        h_prev_N_minus_1 = h[N - 2]\n        h_next_N_minus_1 = h[N - 1]\n        h_sum_N_minus_1 = h_prev_N_minus_1 + h_next_N_minus_1\n        c_N_minus_1 = eps * 2 / (h_sum_N_minus_1 * h_next_N_minus_1)\n        \n        f[-1] = -c_N_minus_1 * 1.0  # u_N = 1\n\n        # Solve the linear system A*u_internal = f\n        u_internal = np.linalg.solve(A, f)\n        \n        # Construct full solution including boundaries\n        u_numerical = np.zeros(N + 1)\n        u_numerical[0] = 0.0\n        u_numerical[1:N] = u_internal\n        u_numerical[N] = 1.0\n        \n        return u_numerical\n\n    def get_exact_solution(x, eps):\n        \"\"\"Computes the exact solution of the ODE.\"\"\"\n        # The denominator can underflow to 1.0 for small eps, which is correct.\n        # np.exp(-1/eps) -> 0 for eps -> 0.\n        denominator = 1.0 - np.exp(-1.0 / eps)\n        if denominator == 0:\n             # This case is not expected for eps > 0 but is a safeguard.\n             return np.ones_like(x)\n        numerator = 1.0 - np.exp(-x / eps)\n        return numerator / denominator\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1e-1, 64),\n        (5e-2, 64),\n        (1e-2, 32),\n        (1e-3, 64),\n    ]\n\n    alpha_candidates = [0, 2, 4, 6, 8, 10]\n    \n    optimal_alphas = []\n\n    for eps, N in test_cases:\n        min_error = float('inf')\n        optimal_alpha = -1\n\n        for alpha in alpha_candidates:\n            # 1. Generate mesh\n            x_nodes = generate_mesh(N, alpha)\n            \n            # 2. Solve BVP numerically\n            u_numerical = solve_bvp(eps, N, x_nodes)\n            \n            # 3. Get exact solution\n            u_exact = get_exact_solution(x_nodes, eps)\n            \n            # 4. Compute error\n            error = np.max(np.abs(u_numerical - u_exact))\n            \n            # 5. Update optimal alpha\n            if error  min_error:\n                min_error = error\n                optimal_alpha = alpha\n        \n        optimal_alphas.append(optimal_alpha)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, optimal_alphas))}]\")\n\nsolve()\n\n```", "id": "3223740"}, {"introduction": "现在，我们将离散化技术推向一个更高的层次：如果网格能够根据计算出的解自动进行调整，会怎么样？本练习将介绍自适应网格加密（AMR）这一强大思想，它是现代科学计算的基石之一。你将亲手实现一个算法，该算法利用“后验”误差估计来动态地加密网格，将计算资源精确地投入到最需要的区域 [@problem_id:3223710]。通过这个实践，你将学会如何创建高效且精确的离散化方案，让解本身来引导最优网格的构建。", "problem": "实现一种自适应网格细化 (AMR) 策略，使用分段线性元在一维域上逼近一个光滑标量函数。细化准则必须基于形式为 $\\lvert u_{xx} \\rvert h^2$ 的后验误差估计，其中 $u$ 是目标函数，$u_{xx}$ 是其二阶导数，$h$ 是局部单元尺寸。\n\n您必须基于以下基本原理。对于区间 $[x_i,x_{i+1}]$（长度为 $h = x_{i+1}-x_i$）上的一个光滑函数 $u$，其1次Lagrange插值误差存在一个局部界，该界可由带Lagrange余项的Taylor定理推导得出：对于某个 $\\xi \\in (x_i,x_{i+1})$，\n$$\nu\\!\\left(\\tfrac{x_i+x_{i+1}}{2}\\right) - \\tfrac{u(x_i)+u(x_{i+1})}{2} \\;=\\; \\tfrac{u_{xx}(\\xi)}{8}\\,h^2.\n$$\n因此，中点值与线性插值中点值的偏差通过以下方式为 $\\lvert u_{xx} \\rvert h^2$ 提供了一个后验估计子：\n$$\n\\eta_i \\;=\\; 8\\,\\left\\lvert u\\!\\left(\\tfrac{x_i+x_{i+1}}{2}\\right) - \\tfrac{u(x_i)+u(x_{i+1})}{2} \\right\\rvert \\;\\approx\\; \\lvert u_{xx}(\\xi)\\rvert h^2.\n$$\n\n任务要求：\n- 定义域：$[0,1]$。\n- 待逼近函数：$u(x) = \\exp\\!\\big(-50\\,(x-0.3)^2\\big) + 0.1\\sin(4\\pi x)$。三角函数中的所有角度均以弧度为单位。\n- 初始网格：将 $[0,1]$ 均匀划分为4个等尺寸单元。\n- 细化策略：对于每个长度为 $h$ 的单元 $[x_i,x_{i+1}]$，计算中点 $m=\\tfrac{x_i+x_{i+1}}{2}$ 和估计子\n$$\n\\eta_i \\;=\\; 8\\,\\left\\lvert u(m) - \\tfrac{u(x_i)+u(x_{i+1})}{2} \\right\\rvert.\n$$\n如果 $\\eta_i$ 超过给定的容差 $\\tau$ 且 $h$ 超过最小尺寸 $h_{\\min}$，则通过二等分来细化该单元。重复此过程，直到没有单元被标记为需要细化，或者所有将被标记的单元尺寸已达到最小尺寸 $h_{\\min}$。\n- 最小单元尺寸：$h_{\\min} = 2^{-14}$。\n- 停止准则：没有被标记的单元，或单元总数达到硬性上限（使用一个足够大的上限以避免程序不终止，同时保持计算上的合理性）。\n\n您的程序必须实现上述AMR过程，并针对每个指定的容差，在细化终止后返回最终的单元数。\n\n测试集：\n- 使用以下容差 $\\tau \\in \\{10^{-1},\\,10^{-2},\\,10^{-3},\\,10\\}$。\n- 该测试集包括一个中等粗糙的容差、一个较细的容差、一个非常细的容差，以及一个非常大的容差（如果估计子在所有地方都低于该容差，则初始网格应该几乎不被细化）。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含按所列顺序排列的各个容差对应的最终单元数，格式为方括号内以逗号分隔的列表。例如，一个有效的输出形如 $[n_1,n_2,n_3,n_4]$，其中每个 $n_k$ 是一个整数。", "solution": "用户要求实现一个一维自适应网格细化 (AMR) 算法。该问题是有效的，因为它基于数值分析原理，是良构的，具有明确的目标和终止准则，并且所有必要的参数都已提供。\n\n问题的核心是使用分段线性函数在定义域 $[0, 1]$ 上逼近一个标量函数 $u(x)$。网格是函数求值的点集，它不是均匀的，而是在逼近误差估计较高的区域被选择性地细化。\n\n**问题详述**\n- **定义域**：区间 $[0, 1]$。\n- **函数**：$u(x) = \\exp\\big(-50\\,(x-0.3)^2\\big) + 0.1\\sin(4\\pi x)$。\n- **初始网格**：将 $[0, 1]$ 均匀划分为4个单元。这对应于包含5个节点的初始集合：$\\{0, 0.25, 0.5, 0.75, 1\\}$。\n- **误差估计子**：对于尺寸为 $h = x_{i+1} - x_i$ 的单元 $[x_i, x_{i+1}]$，误差通过 $\\eta_i = 8\\,\\left\\lvert u(m) - \\tfrac{u(x_i)+u(x_{i+1})}{2} \\right\\rvert$ 来估计，其中 $m = \\tfrac{x_i+x_{i+1}}{2}$ 是中点。该估计子是 $\\lvert u_{xx}(\\xi) \\rvert h^2$ 的一个近似，后者界定了线性插值的误差。\n- **细化准则**：如果满足以下两个条件，则单元 $[x_i, x_{i+1}]$ 被标记为需要细化：\n    1.  误差估计超过容差：$\\eta_i  \\tau$。\n    2.  单元尺寸大于最小阈值：$h  h_{\\min}$。\n- **细化操作**：任何被标记的单元都会被二等分。这意味着它的中点会被添加到网格节点的集合中。\n- **常量**：最小单元尺寸为 $h_{\\min} = 2^{-14}$。\n- **终止条件**：当在对整个网格的一次完整遍历中，没有单元被标记为需要细化时，迭代细化过程停止。\n- **任务**：对于集合 $\\{10^{-1}, 10^{-2}, 10^{-3}, 10\\}$ 中的每个容差 $\\tau$，必须确定网格中最终的单元数量。\n\n**算法设计**\n对于每个指定的容差 $\\tau$，执行一个独立的AMR过程。该算法可以按以下结构组织：\n\n1.  **初始化**：从一个表示网格节点的数据结构开始。一个已排序的NumPy数组是合适的。对于本问题，初始节点数组为 `[0.0, 0.25, 0.5, 0.75, 1.0]`。\n\n2.  **迭代细化循环**：一个 `while` 循环构成了算法的核心。只要在一次遍历中至少有一个单元被细化，该循环就会继续。\n    a. **标记阶段**：在每次迭代中，我们遍历当前网格，检查每个单元 $[x_i, x_{i+1}]$。对每个单元，我们执行以下检查：\n        i. 计算单元宽度 $h = x_{i+1} - x_i$。\n        ii. 如果 $h \\le h_{\\min}$，则该单元尺寸过小，不能再细化，因此我们继续处理下一个单元。\n        iii. 如果 $h  h_{\\min}$，我们计算后验误差估计子 $\\eta_i$。\n        iv. 如果 $\\eta_i  \\tau$，我们将此单元标记为需要细化。一个实用的方法是将中点 $m = (x_i + x_{i+1})/2$ 存储在一个待添加点的临时列表中。\n    b. **终止检查**：遍历所有单元后，如果待添加点的列表为空，则意味着没有单元被标记为需要细化。对于给定的容差 $\\tau$，网格此时已最终确定。循环终止。\n    c. **网格更新**：如果新点列表不为空，则必须更新网格。我们将当前的节点数组与新的中点合并。为了维护一个已排序且唯一的节点集合，我们可以拼接两组点，然后应用去重和排序操作。这个新的、更大的节点数组定义了下一次循环迭代的网格。\n\n3.  **最终确定**：一旦循环终止，最终网格中的单元数就是节点数减一。这个整数值就是特定容差 $\\tau$ 的结果。\n\n对 $\\{10^{-1}, 10^{-2}, 10^{-3}, 10\\}$ 中的每个 $\\tau$ 重复此过程。得到的单元数列表构成了最终答案。函数 $u(x)$ 由一个指数（类高斯）部分和一个正弦部分组成。高斯项在 $x=0.3$ 附近有很高的曲率，这将导致该区域的误差估计子 $\\eta_i$ 很大，从而引发显著的局部细化。正弦项将在整个定义域上引发细化。随着容差 $\\tau$ 变小，算法将需要更精细的网格以将局部误差估计保持在阈值以下，从而导致单元数量增多。相反，一个非常大的容差（如 $\\tau=10$）预计只会对初始网格进行很少或根本不进行细化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements an Adaptive Mesh Refinement (AMR) strategy and computes the\n    final number of cells for a suite of tolerances.\n    \"\"\"\n\n    # Define the scalar function to be approximated, as per the problem statement.\n    # u(x) = exp(-50*(x-0.3)^2) + 0.1*sin(4*pi*x)\n    def u(x: np.ndarray or float) -> np.ndarray or float:\n        \"\"\"\n        Calculates the value of the target function u at point(s) x.\n        All angles are in radians.\n        \"\"\"\n        return np.exp(-50.0 * (x - 0.3)**2) + 0.1 * np.sin(4.0 * np.pi * x)\n\n    def run_amr(tolerance: float, h_min: float, initial_nodes: np.ndarray) -> int:\n        \"\"\"\n        Executes the AMR algorithm for a given tolerance.\n\n        Args:\n            tolerance: The refinement threshold tau.\n            h_min: The minimum allowed cell size.\n            initial_nodes: A sorted NumPy array of the initial mesh node coordinates.\n\n        Returns:\n            The final number of cells in the mesh after refinement terminates.\n        \"\"\"\n        nodes = np.array(initial_nodes, dtype=np.float64)\n\n        # A practical cap on the number of cells to prevent accidental infinite loops.\n        # The h_min condition guarantees termination, so this is just a safeguard.\n        # Max cells would be 1/h_min = 2^14 = 16384. We set a slightly larger cap.\n        max_nodes = 20000\n\n        while True:\n            if len(nodes) > max_nodes:\n                break\n\n            # List to store the midpoints of cells that need to be refined.\n            midpoints_to_add = []\n\n            # Iterate through each cell in the current mesh.\n            for i in range(len(nodes) - 1):\n                x_i = nodes[i]\n                x_i_plus_1 = nodes[i+1]\n\n                h = x_i_plus_1 - x_i\n\n                # Condition 1: Cell must be larger than the minimum size.\n                if h = h_min:\n                    continue\n\n                # Calculate the a-posteriori error estimator eta_i.\n                m = (x_i + x_i_plus_1) / 2.0\n                u_m = u(m)\n                u_interp_at_m = (u(x_i) + u(x_i_plus_1)) / 2.0\n                eta_i = 8.0 * np.abs(u_m - u_interp_at_m)\n\n                # Condition 2: Error estimator must exceed the tolerance.\n                if eta_i > tolerance:\n                    midpoints_to_add.append(m)\n\n            # If no cells were flagged for refinement in this pass, the process is complete.\n            if not midpoints_to_add:\n                break\n\n            # Add the new midpoints to the mesh nodes and create a new sorted, unique array.\n            nodes = np.unique(np.concatenate((nodes, midpoints_to_add)))\n\n        # The number of cells is one less than the number of nodes.\n        return len(nodes) - 1\n\n    # Define the test cases from the problem statement.\n    test_tolerances = [10**-1, 10**-2, 10**-3, 10.0]\n    \n    # Define fixed parameters.\n    h_min = 2**-14\n    # Initial mesh: a uniform partition of [0,1] into 4 cells (5 nodes).\n    initial_nodes = np.linspace(0.0, 1.0, 5, dtype=np.float64)\n\n    results = []\n    for tau in test_tolerances:\n        final_cell_count = run_amr(tolerance=tau, h_min=h_min, initial_nodes=initial_nodes)\n        results.append(final_cell_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3223710"}]}