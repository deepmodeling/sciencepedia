{"hands_on_practices": [{"introduction": "在我们开始编写代码之前，通过一个理论练习来建立对谱方法核心原理的直观理解至关重要。本实践将引导你进行一次“纸上推演”，深入探究谱微分矩阵与待微分函数内在属性（如对称性）之间的深刻联系。通过分析一个具体的例子，你将看到傅里叶谱方法如何巧妙地利用并反映函数的解析特性，这也是其能够达到高精度的根本原因之一。[@problem_id:3277346]", "problem": "设 $N$ 是一个满足 $N \\geq 4$ 的偶数，考虑区间 $[0, 2\\pi)$ 上的 $N$ 个等距傅里叶配置点 $x_{j} = \\frac{2\\pi j}{N}$，其中 $j = 0, 1, \\dots, N-1$，所有角度均以弧度为单位。设 $f(x) = \\sin(\\cos(x))$。将 $f(x)$ 的三角插值函数 $p_{N}(x)$ 定义为在节点 $\\{x_{j}\\}_{j=0}^{N-1}$ 上对 $f$ 进行插值的、次数至多为 $\\frac{N}{2}$ 的唯一三角多项式。傅里叶谱微分矩阵 $D \\in \\mathbb{R}^{N \\times N}$ 的定义使得 $p_{N}$ 的节点导数向量满足 $(D\\boldsymbol{f})_{j} = p_{N}'(x_{j})$，其中 $\\boldsymbol{f} = \\big(f(x_{0}), \\dots, f(x_{N-1})\\big)^{\\mathsf{T}}$。\n\n仅使用三角插值和导出的谱微分矩阵的基本定义，计算 $(D\\boldsymbol{f})_{0}$ 的精确值，并验证其等于解析链式法则导数 $f'(0)$。请以单个精确数（无四舍五入）的形式提供最终答案。", "solution": "问题要求计算 $(D\\boldsymbol{f})_{0}$，即函数 $f(x) = \\sin(\\cos(x))$ 的三角插值函数 $p_{N}(x)$ 在节点 $x_{0}=0$ 处的导数。我们需要验证该值等于解析导数 $f'(0)$。\n\n一个函数 $f(x)$ 在 $N$ 个等距节点 $x_{j} = \\frac{2\\pi j}{N}$（其中 $j = 0, 1, \\dots, N-1$）上的三角插值函数 $p_{N}(x)$ 是满足对所有 $j$ 都有 $p_{N}(x_{j}) = f(x_{j})$ 的、次数至多为 $\\frac{N}{2}$ 的唯一三角多项式。对于偶数 $N$，该插值函数由以下复傅里叶级数表示给出：\n$$p_{N}(x) = \\sum_{k=-N/2}^{N/2} ' \\hat{f}_{k} e^{ikx}$$\n其中求和符号上的撇号表示 $k = -N/2$ 和 $k=N/2$ 的项乘以因子 $\\frac{1}{2}$。系数 $\\hat{f}_{k}$ 是采样函数值 $\\boldsymbol{f} = \\big(f(x_{0}), \\dots, f(x_{N-1})\\big)^{\\mathsf{T}}$ 的离散傅里叶系数，定义为：\n$$\\hat{f}_{k} = \\frac{1}{N} \\sum_{j=0}^{N-1} f(x_{j}) e^{-ikx_{j}}$$\n\n需要计算的量是 $(D\\boldsymbol{f})_{0}$，根据定义，它就是 $p_{N}'(x_{0})$。首先，我们通过逐项微分求出插值多项式的导数 $p_{N}'(x)$：\n$$p_{N}'(x) = \\frac{d}{dx} \\left( \\sum_{k=-N/2}^{N/2} ' \\hat{f}_{k} e^{ikx} \\right) = \\sum_{k=-N/2}^{N/2} ' (ik) \\hat{f}_{k} e^{ikx}$$\n在节点 $x_{0} = 0$ 处计算该式：\n$$(D\\boldsymbol{f})_{0} = p_{N}'(0) = \\sum_{k=-N/2}^{N/2} ' (ik) \\hat{f}_{k} e^{ik(0)} = i \\sum_{k=-N/2}^{N/2} ' k \\hat{f}_{k}$$\n\n为了计算这个和，我们必须首先分析系数 $\\hat{f}_{k}$ 的性质。这些性质由函数 $f(x) = \\sin(\\cos(x))$ 和网格 $\\{x_{j}\\}$ 的对称性决定。\n\n函数 $f(x)$ 是一个偶函数，因为 $f(-x) = \\sin(\\cos(-x)) = \\sin(\\cos(x)) = f(x)$。\n网格点在区间 $[0, 2\\pi)$ 上关于 $x=0$ 对称。对于任何节点 $x_{j}$，其中 $j \\in \\{1, \\dots, N-1\\}$，其对称点是 $x_{N-j} = \\frac{2\\pi(N-j)}{N} = 2\\pi - \\frac{2\\pi j}{N} = 2\\pi - x_{j}$。\n由于 $f(x)$ 是 $2\\pi$ 周期的，因此 $f(x_{N-j}) = f(2\\pi - x_{j}) = f(-x_{j})$。\n因为 $f(x)$ 是偶函数，所以 $f(-x_{j}) = f(x_{j})$。\n因此，采样函数值表现出对称性：$f(x_{N-j}) = f(x_{j})$，其中 $j=1, \\dots, N-1$。\n\n采样数据的这种对称性意味着离散傅里叶系数也具有对称性。具体来说，我们将证明 $\\hat{f}_{k}$ 是一个实值序列，因此 $\\hat{f}_{-k} = \\hat{f}_{k}$。\n\n对于实值函数 $f(x)$，我们有一般性质 $\\hat{f}_{-k} = \\overline{\\hat{f}_{k}}$：\n$$\\overline{\\hat{f}_{k}} = \\overline{\\frac{1}{N} \\sum_{j=0}^{N-1} f(x_{j}) e^{-ikx_{j}}} = \\frac{1}{N} \\sum_{j=0}^{N-1} \\overline{f(x_{j})} \\overline{e^{-ikx_{j}}} = \\frac{1}{N} \\sum_{j=0}^{N-1} f(x_{j}) e^{ikx_{j}} = \\hat{f}_{-k}$$\n现在我们证明对于我们这个特定的偶函数 $f(x)$，$\\hat{f}_k$ 是实数。$\\hat{f}_k$ 的虚部由下式给出：\n$$\\text{Im}(\\hat{f}_{k}) = -\\frac{1}{N} \\sum_{j=0}^{N-1} f(x_{j}) \\sin(kx_{j})$$\n我们可以拆分这个和：\n$$\\sum_{j=0}^{N-1} f(x_{j}) \\sin(kx_{j}) = f(x_{0})\\sin(kx_{0}) + \\sum_{j=1}^{N-1} f(x_{j})\\sin(kx_{j})$$\n第一项为零，因为 $x_{0}=0$。这个和可以配对。由于 $N$ 是偶数，存在 $j=N/2$ 这一项。\n$$\\sum_{j=1}^{N-1} (\\dots) = \\sum_{j=1}^{N/2-1} \\left[ f(x_{j})\\sin(kx_{j}) + f(x_{N-j})\\sin(kx_{N-j}) \\right] + f(x_{N/2})\\sin(kx_{N/2})$$\n使用 $f(x_{N-j})=f(x_{j})$ 和 $\\sin(kx_{N-j}) = \\sin(k(2\\pi-x_{j})) = \\sin(-kx_{j}) = -\\sin(kx_{j})$，求和中的每一对是：\n$$f(x_{j})\\sin(kx_{j}) + f(x_{j})(-\\sin(kx_{j})) = 0$$\n中点 $j=N/2$ 的项是 $f(x_{N/2})\\sin(kx_{N/2}) = f(\\pi)\\sin(k\\pi) = 0$，因为 $k$ 是整数。\n因此，$\\text{Im}(\\hat{f}_{k}) = 0$，这意味着 $\\hat{f}_{k}$ 是实数。\n由于 $\\hat{f}_{k}$ 是实数且 $\\hat{f}_{-k} = \\overline{\\hat{f}_{k}}$，可得 $\\hat{f}_{-k}=\\hat{f}_{k}$。\n\n现在我们可以计算 $p_{N}'(0)$ 的和。\n$$p_{N}'(0) = i \\sum_{k=-N/2}^{N/2} ' k \\hat{f}_{k}$$\n我们展开这个和，使用撇号表示法：\n$$ \\sum_{k=-N/2}^{N/2} ' k \\hat{f}_{k} = \\frac{1}{2}(-N/2)\\hat{f}_{-N/2} + \\sum_{k=1-N/2}^{-1} k\\hat{f}_{k} + (0)\\hat{f}_{0} + \\sum_{k=1}^{N/2-1} k\\hat{f}_{k} + \\frac{1}{2}(N/2)\\hat{f}_{N/2}$$\n我们可以通过令 $m=-k$ 来重写第一个求和：\n$$\\sum_{k=1-N/2}^{-1} k\\hat{f}_{k} = \\sum_{m=1}^{N/2-1} (-m)\\hat{f}_{-m}$$\n使用对称性 $\\hat{f}_{-m} = \\hat{f}_{m}$，这变成了 $-\\sum_{m=1}^{N/2-1} m\\hat{f}_{m}$。\n因此，和为：\n$$-\\frac{N}{4}\\hat{f}_{-N/2} - \\sum_{m=1}^{N/2-1} m\\hat{f}_{m} + \\sum_{k=1}^{N/2-1} k\\hat{f}_{k} + \\frac{N}{4}\\hat{f}_{N/2}$$\n两个求和相互抵消。剩下的项是：\n$$-\\frac{N}{4}\\hat{f}_{-N/2} + \\frac{N}{4}\\hat{f}_{N/2}$$\n由于对称性 $\\hat{f}_{-k} = \\hat{f}_{k}$ 对端点 $k=N/2$ 也成立，这个表达式为：\n$$-\\frac{N}{4}\\hat{f}_{N/2} + \\frac{N}{4}\\hat{f}_{N/2} = 0$$\n因此，整个和为 $0$，我们得到 $(D\\boldsymbol{f})_{0} = p_{N}'(0) = i \\cdot 0 = 0$。\n\n为了验证这个结果，我们使用链式法则计算 $f(x)=\\sin(\\cos(x))$ 的解析导数：\n$$f'(x) = \\frac{d}{dx}\\sin(\\cos(x)) = \\cos(\\cos(x)) \\cdot \\frac{d}{dx}(\\cos(x)) = \\cos(\\cos(x)) \\cdot (-\\sin(x))$$\n在 $x=0$ 处计算该导数：\n$$f'(0) = -\\sin(0) \\cos(\\cos(0)) = -0 \\cdot \\cos(1) = 0$$\n插值函数在 $x_{0}=0$ 处的导数值为 $0$，这与解析导数 $f'(0)$ 完全相同。这证实了在这种特殊情况下谱微分的正确性，这是一个已知的性质，即偶函数在其对称点处的导数值。\n\n所要求的精确值为 $0$。", "answer": "$$\\boxed{0}$$", "id": "3277346"}, {"introduction": "在建立了理论基础之后，让我们通过一个实际的编程挑战来揭示谱算子的多功能性。虽然名为“微分矩阵”，但我们可以巧妙地利用它来执行其逆运算——积分。本实践将指导你构建切比雪夫谱微分矩阵，并利用其摩尔-彭若斯伪逆（Moore-Penrose pseudo-inverse）来创建一个高精度的“谱积分”方案。这个练习不仅提供了一个强大的计算工具，还将加深你对线性算子及其零空间概念的理解。[@problem_id:3277283]", "problem": "你需要实现一个完整的、可运行的程序，该程序通过使用谱微分矩阵的 Moore–Penrose 伪逆，为切比雪夫-洛巴托节点构造一个谱积分矩阵，然后用它来近似定积分。背景是多项式插值和谱微分，并以纯数学术语进行阐述。\n\n起点和定义：\n- 考虑区间 $[-1,1]$ 和由 $x_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$ 给出的切比雪夫-洛巴托节点 $x_j$，其中 $j=0,1,\\dots,N$。\n- 设 $p_N(x)$ 表示满足 $p_N(x_j) = f_j$ 的至多 $N$ 次的唯一插值多项式，其中 $f_j = f(x_j)$ 是某个未知函数 $f$ 的节点值。\n- 定义谱微分矩阵 $D_N \\in \\mathbb{R}^{(N+1)\\times(N+1)}$，其规则为：对于一个表示在节点 $x_j$ 处对某个足够光滑的函数 $g$ 进行采样的节点向量 $v \\in \\mathbb{R}^{N+1}$，乘积 $D_N v$ 近似了 $g'(x)$ 在相同节点上的节点采样值，即 $\\left(D_N v\\right)_i \\approx \\frac{d}{dx}p_N(x)\\big|_{x=x_i}$，其中 $p_N$ 是 $g$ 在这些节点上的插值多项式。此定义必须从多项式插值和插值函数导数的基本概念导出；不得预先假设任何快捷公式。\n- 设 $I_N$ 是 $D_N$ 的 Moore–Penrose 伪逆，记作 $D_N^{+}$。这是满足 Moore–Penrose 条件 $D_N D_N^{+} D_N = D_N$、$D_N^{+} D_N D_N^{+} = D_N^{+}$、$(D_N D_N^{+})^\\top = D_N D_N^{+}$ 和 $(D_N^{+} D_N)^\\top = D_N^{+} D_N$ 的唯一矩阵。\n\n通过伪逆进行积分：\n- 对于表示函数 $f(x)$ 采样值的节点向量 $f \\in \\mathbb{R}^{N+1}$，定义 $g = I_N f$。那么 $g$ 表示 $f$ 的一个离散反导数（相差一个加法常数），其意义在于 $D_N g$ 在伪逆固有的最小二乘意义上近似于 $f$。为了从左端点获得定积分，通过将 $x=-1$ 处的积分值设为零来强制一个具有物理意义的常数：$\\int_{-1}^{x_j} f(x)\\,dx \\approx g_j - g_{N}$，因为 $x_N = -1$。\n- 整个区间的定积分则近似为 $\\int_{-1}^{1} f(x)\\,dx \\approx g_0 - g_N$，因为 $x_0 = 1$ 且 $x_N = -1$。\n\n角度单位约定：\n- 所有三角函数必须使用弧度作为角度单位。\n\n需要计算的精度指标：\n- 对每个测试用例，计算：\n  1. 从 $-1$ 到 $x_j$ 的累积定积分在所有节点上的最大绝对误差，即 $\\max_{0 \\le j \\le N} \\left|\\left(g_j - g_N\\right) - \\left(F(x_j) - F(-1)\\right)\\right|$，其中 $F$ 是 $f$ 的一个解析反导数，满足 $F'(x) = f(x)$。\n  2. 全区间积分的绝对误差，即 $\\left| \\left(g_0 - g_N\\right) - \\int_{-1}^{1} f(x)\\,dx \\right|$。\n\n测试套件：\n- 实现以下测试用例，每个用例由一个函数 $f(x)$ 和一个整数 $N$ 指定：\n  1. 指数增长的解析函数：$f(x) = e^{x}$，其中 $N = 8$。\n  2. 相同的解析函数以评估收敛性：$f(x) = e^{x}$，其中 $N = 16$。\n  3. 相同的解析函数用于进一步评估收敛性：$f(x) = e^{x}$，其中 $N = 32$。\n  4. 振荡解析函数：$f(x) = \\sin(7x)$，其中 $N = 16$。\n  5. 多项式函数：$f(x) = x^{5} - 2x^{3} + x$，其中 $N = 6$。\n  6. 常数函数（零空间边缘情况）：$f(x) = 3$，其中 $N = 10$。\n  7. 非光滑函数：$f(x) = |x|$，其中 $N = 64$。\n\n对于上述每个 $f(x)$，取其反导数 $F(x)$ 如下，以便进行精确误差评估：\n- 情况 $f(x) = e^{x}$：$F(x) = e^{x}$。\n- 情况 $f(x) = \\sin(7x)$：$F(x) = -\\frac{\\cos(7x)}{7}$。\n- 情况 $f(x) = x^{5} - 2x^{3} + x$：$F(x) = \\frac{x^{6}}{6} - \\frac{x^{4}}{2} + \\frac{x^{2}}{2}$。\n- 情况 $f(x) = 3$：$F(x) = 3x$。\n- 情况 $f(x) = |x|$：$F(x) = \\frac{1}{2}x|x|$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，格式为扁平顺序 $[E_{1,\\text{nodes}}, E_{1,\\text{interval}}, E_{2,\\text{nodes}}, E_{2,\\text{interval}}, \\dots]$，其中 $E_{k,\\text{nodes}}$ 是第 $k$ 个测试用例的最大节点累积积分误差，$E_{k,\\text{interval}}$ 是全区间积分误差。每个条目必须是浮点数。不应打印任何其他文本。", "solution": "问题陈述已经过分析并被确定为**有效**。它提出了一个在数值分析领域，特别是谱方法领域中，适定的、有科学依据的问题。定义清晰，测试用例适合评估所提出的数值方案，并且所要求的指标定义明确。该问题是自洽的，没有矛盾或主观因素。\n\n任务是为切比雪夫-洛巴托节点构造一个谱积分矩阵，方法是计算相应谱微分矩阵的 Moore–Penrose 伪逆。然后使用这个积分矩阵来为一套测试函数近似定积分。\n\n### 方法原理\n谱方法的核心原理是，在某个区间（此处为 $[-1, 1]$）上，用一个单一的高阶多项式 $p_N(x)$ 来近似一个函数 $f(x)$。这个多项式由它在一组 $N+1$ 个不同节点 $x_j$ 上对函数进行插值的条件唯一确定。为了获得高精度和稳定性，切比雪夫节点是首选。切比雪夫-洛巴托节点由 $x_j = \\cos\\left(\\frac{j\\pi}{N}\\right)$ 给出，其中 $j=0, 1, \\dots, N$。\n\n插值多项式 $p_N(x)$ 的导数 $p_N'(x)$ 可作为原始函数 $f(x)$ 导数 $f'(x)$ 的近似。由于微分是线性运算，从函数在节点上的值 $f_j = f(x_j)$ 到其近似导数在节点上的值 $p_N'(x_i)$ 的映射，可以通过一个矩阵-向量乘积来表示。这个矩阵就是谱微分矩阵 $D_N$。\n\n积分是微分的逆运算。因此，可以通过将矩阵 $D_N$ 的逆矩阵应用于节点值向量 $f_j$ 来获得 $f(x)$ 积分的近似值。然而，微分算子有一个由常数函数组成的一维零空间；任何常数向量 $\\mathbf{c} = (c, c, \\dots, c)^\\top$ 都会被映射到零。因此，$D_N$ 是奇异的，其标准逆矩阵不存在。\n\nMoore–Penrose 伪逆，记作 $D_N^+$，在这种情况下为逆矩阵提供了一个定义明确的替代品。对于一个节点值向量 $f$，向量 $g = D_N^+ f$ 表示 $f$ 的某个反导数的节点值。具体来说，$D_N g$ 是在 $D_N$ 的值域内对 $f$ 的最小二乘最佳逼近。得到的反导数 $g$ 在与 $D_N$ 的零空间正交的条件下是唯一的，对于切比雪夫微分来说，这意味着它的平均值为零。\n\n### 谱微分矩阵 $D_N$ 的构造\n通过点 $(x_j, f_j)$ 的插值多项式 $p_N(x)$ 的拉格朗日形式为 $p_N(x) = \\sum_{j=0}^{N} f_j L_j(x)$，其中 $L_j(x)$ 是拉格朗日基多项式。其导数为 $p_N'(x) = \\sum_{j=0}^{N} f_j L_j'(x)$。在节点 $x_i$ 处计算该导数，得到 $p_N'(x_i) = \\sum_{j=0}^{N} f_j L_j'(x_i)$。因此，微分矩阵 $D_N$ 的元素由 $(D_N)_{ij} = L_j'(x_i)$ 给出。\n\n虽然这些元素可以通过对 $L_j(x)$ 的显式公式求导得出，但利用切比雪夫多项式的性质可以导出一套更实用、更稳定的公式。在关于谱方法的教科书中可以找到这个标准推导，它为切比雪夫-洛巴托节点 $x_j = \\cos(j\\pi/N)$ 的 $D_N$ 矩阵元素提供了以下表达式：\n- 非对角线元素为：\n$$ (D_N)_{ij} = \\frac{c_i}{c_j} \\frac{(-1)^{i+j}}{x_i - x_j}, \\quad i \\neq j $$\n- 对角线元素为：\n$$ (D_N)_{ii} = -\\frac{x_i}{2(1-x_i^2)}, \\quad i=1, 2, \\dots, N-1 $$\n- 角点（对角线）元素是特殊情况：\n$$ (D_N)_{00} = \\frac{2N^2+1}{6} $$\n$$ (D_N)_{NN} = -\\frac{2N^2+1}{6} $$\n- 系数 $c_j$ 定义为：\n$$ c_j = \\begin{cases} 2  j=0 \\text{ 或 } j=N \\\\ 1  1 \\le j \\le N-1 \\end{cases} $$\n这些公式将用于构造矩阵 $D_N$。\n\n### 积分流程\n一旦构造了 $D_N$，就可以使用标准的数值线性代数算法（通常是基于奇异值分解(SVD)的算法）计算其 Moore–Penrose 伪逆 $I_N = D_N^+$。\n\n给定一个函数在节点上的值向量 $f$，我们计算向量 $g = I_N f$，它包含了某个特定反导数的节点值。为了计算定积分，例如 $\\int_{-1}^{x_j} f(t)dt$，我们必须考虑积分常数。我们可以强制积分在其下限 $x=-1$ 时为零。在我们的节点索引中，$x_N = \\cos(\\pi N/N) = \\cos(\\pi) = -1$。因此，累积积分 $F(x_j)-F(-1)$ 的近似值由 $g_j - g_N$ 给出。\n\n整个区间的定积分 $\\int_{-1}^{1} f(t)dt$ 则是通过在上限 $x=1$ 处评估累积积分来近似的。由于 $x_0 = \\cos(0) = 1$，这对应于 $g_0 - g_N$。\n\n### 算法摘要\n对于每个测试用例 $(f(x), F(x), N)$，实现将遵循以下步骤：\n1.  使用上述公式构造 $(N+1) \\times (N+1)$ 的切比雪夫微分矩阵 $D_N$。\n2.  使用 `numpy.linalg.pinv` 计算其 Moore–Penrose 伪逆 $I_N = D_N^+$。\n3.  生成切比雪夫-洛巴托节点向量 $x_j$。\n4.  在这些节点上计算函数 $f(x)$ 的值，以创建向量 $f$。\n5.  计算反导数的节点值：$g = I_N f$。\n6.  计算从 $-1$ 到每个 $x_j$ 的近似累积积分，即 $g_j - g_N$。\n7.  计算近似的全区间积分，即 $g_0 - g_N$。\n8.  使用提供的反导数 $F(x)$ 计算真实的累积积分值，即 $F(x_j) - F(-1)$。\n9.  计算真实的全区间积分，即 $F(1) - F(-1)$。\n10. 计算两个所需的误差指标：累积积分在所有节点上的最大绝对误差，以及全区间积分的绝对误差。\n\n测试用例 $f(x)=3$ 旨在突显此方法的一个关键特性。由于常数函数位于 $D_N$ 的零空间中，而 $D_N^+$ 映射的是零空间正交补中的向量，因此该方法实际上是对函数 $f(x) - \\bar{f}$ 进行积分，其中 $\\bar{f}$ 是平均值。对于 $f(x)=3$，平均值为 $3$，因此该过程将对 $f(x) - 3 = 0$ 进行积分，得到积分为 $0$。这将导致一个很大的误差，从而正确地展示了在没有校正的情况下使用 $D_N^+$ 对具有非零平均值的函数积分的局限性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef chebyshev_lobatto_differentiation_matrix(N):\n    \"\"\"\n    Constructs the (N+1)x(N+1) Chebyshev spectral differentiation matrix\n    for the Chebyshev-Lobatto nodes.\n    \"\"\"\n    if N == 0:\n        return np.array([[0.0]])\n    \n    n_plus_1 = N + 1\n    # Create nodes x_j = cos(j*pi/N)\n    j = np.arange(n_plus_1)\n    x = np.cos(np.pi * j / N)\n    \n    # Initialize differentiation matrix\n    D = np.zeros((n_plus_1, n_plus_1))\n    \n    # c_j coefficients\n    c = np.ones(n_plus_1)\n    c[0] = 2.0\n    c[N] = 2.0\n    \n    # Off-diagonal elements (vectorized for columns)\n    for i in range(n_plus_1):\n        # Create a view of x without x_i\n        x_diff = x[i] - x\n        # Avoid division by zero, it will be overwritten by the diagonal value\n        x_diff[i] = 1.0  \n        \n        term = (c[i] / c) * ((-1)**(i + j)) / x_diff\n        D[i, :] = term\n        \n    # Diagonal elements\n    # For i = 1, ..., N-1\n    for i in range(1, N):\n        D[i, i] = -x[i] / (2.0 * (1.0 - x[i]**2))\n    \n    # Corner elements\n    D[0, 0] = (2.0 * N**2 + 1.0) / 6.0\n    D[N, N] = -(2.0 * N**2 + 1.0) / 6.0\n    \n    return D\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute integration errors.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case: (function f, anti-derivative F, integer N)\n    test_cases = [\n        (lambda x: np.exp(x), lambda x: np.exp(x), 8),\n        (lambda x: np.exp(x), lambda x: np.exp(x), 16),\n        (lambda x: np.exp(x), lambda x: np.exp(x), 32),\n        (lambda x: np.sin(7.0 * x), lambda x: -np.cos(7.0 * x) / 7.0, 16),\n        (lambda x: x**5 - 2.0*x**3 + x, lambda x: x**6/6.0 - x**4/2.0 + x**2/2.0, 6),\n        (lambda x: 3.0 + 0.0*x, lambda x: 3.0 * x, 10), # 0.0*x for vectorization\n        (lambda x: np.abs(x), lambda x: 0.5 * x * np.abs(x), 64),\n    ]\n\n    results = []\n    \n    for f, F, N in test_cases:\n        # 1. Construct Chebyshev nodes\n        j_indices = np.arange(N + 1)\n        nodes = np.cos(np.pi * j_indices / N)\n        \n        # 2. Construct the spectral differentiation matrix D_N\n        D_N = chebyshev_lobatto_differentiation_matrix(N)\n        \n        # 3. Compute the Moore-Penrose pseudo-inverse I_N\n        I_N = np.linalg.pinv(D_N)\n        \n        # 4. Get nodal values of the function f\n        f_vec = f(nodes)\n        \n        # 5. Compute the discrete anti-derivative g = I_N * f\n        g_vec = I_N @ f_vec\n        \n        # 6. Compute approximate integrals\n        # Cumulative integral from -1 (node N) to x_j\n        approx_cumulative_integral = g_vec - g_vec[N]\n        # Whole-interval integral from -1 (node N) to 1 (node 0)\n        approx_total_integral = g_vec[0] - g_vec[N]\n        \n        # 7. Compute exact integrals\n        # Exact cumulative integral from -1 to x_j\n        exact_cumulative_integral = F(nodes) - F(-1.0)\n        # Exact whole-interval integral from -1 to 1\n        exact_total_integral = F(1.0) - F(-1.0)\n\n        # 8. Calculate errors\n        # Max absolute error for cumulative integrals\n        max_nodal_error = np.max(np.abs(approx_cumulative_integral - exact_cumulative_integral))\n        # Absolute error for the whole-interval integral\n        total_interval_error = np.abs(approx_total_integral - exact_total_integral)\n\n        results.append(max_nodal_error)\n        results.append(total_interval_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3277283"}, {"introduction": "现实世界中的许多物理系统是由非线性微分方程描述的。当我们将谱方法应用于这些问题时，一个微妙而关键的挑战便会出现：混叠误差（aliasing error）。本实践将直接面对这一核心问题。你将研究在物理空间中计算非线性项时如何产生虚假频率，并动手实现一种标准的去混叠技术——“$2/3$规则”——来抑制这种误差。掌握这一概念对于精确求解流体力学等领域的非线性偏微分方程至关重要。[@problem_id:3277414]", "problem": "考虑周期域 $[0,2\\pi)$，其中有 $N$ 个等距配置点 $x_j = \\frac{2\\pi j}{N}$，其中 $j=0,1,\\dots,N-1$。您将构建一个傅里叶谱微分矩阵来近似空间导数，并研究在计算无粘性伯格斯方程 $u_t + (u^2)_x = 0$ 中出现的非线性通量导数 $(u^2)_x$ 时的混叠与去混叠问题。角度必须以弧度为单位进行解释。\n\n仅从基本原理出发，利用以下事实：指数函数 $e^{i k x}$ 是微分算子的特征函数，对于整数 $k$，有 $ \\frac{d}{dx} e^{i k x} = i k e^{i k x}$；离散傅里叶变换通过其离散傅里叶系数来表示网格上的函数。基于这些原理：\n\n- 推导一阶微分算子在网格 $\\{x_j\\}$ 上，在傅里叶配置法中的矩阵表示 $D \\in \\mathbb{C}^{N \\times N}$。推导必须从离散傅里叶变换及其逆变换如何将节点值映射到离散傅里叶系数并返回开始，并利用 $e^{i k x}$ 的特征函数性质，而不假设任何预先给定的微分矩阵公式。最终得到的矩阵 $D$ 对于任意网格函数 $f \\in \\mathbb{C}^N$，应满足向量 $Df$ 在网格点上近似于 $\\frac{d f}{dx}$。\n- 解释为什么在物理空间中计算非线性乘积（例如，逐点计算 $u^2$）然后变换到傅里叶空间会引入混叠误差。使用离散卷积的解释来论证在具有 $N$ 个点的网格上，未解析的高频模式如何混入低频模式。\n- 实现 $(u^2)_x$ 的两种伪谱近似方法：\n  1. 一种朴素伪谱法：逐点计算 $f = u^2$，然后通过将谱微分矩阵 $D$ 应用于 $f$ 来近似 $(u^2)_x$，即 $(u^2)_x \\approx D f$。\n  2. 一种使用 $2/3$ 规则的去混叠方法：在物理空间中形成 $f = u^2$ 后，将 $f$ 变换到傅里叶空间以获得 $\\hat{f}_k$，将所有 $|k| > \\lfloor N/3 \\rfloor$ 的模式置零，在傅里叶空间中乘以 $i k$，然后变换回物理空间，以获得 $(u^2)_x$ 的去混叠近似。\n\n对于下面的每个测试用例，根据给定的 $u(x)$ 和 $u_x(x)$ 计算逐点精确导数 $(u^2)_x = 2 u u_x$，然后计算以下两种误差：\n- 朴素伪谱最大范数误差 $E_{\\text{naive}} = \\max_{0 \\le j \\le N-1} \\left| (D f)_j - 2 u(x_j) u_x(x_j) \\right|$。\n- $2/3$ 规则去混叠最大范数误差 $E_{2/3} = \\max_{0 \\le j \\le N-1} \\left| \\left[\\mathcal{F}^{-1}\\left( i k \\cdot \\chi_{|k| \\le \\lfloor N/3 \\rfloor} \\cdot \\hat{f}_k \\right)\\right]_j - 2 u(x_j) u_x(x_j) \\right|$，其中 $\\chi$ 是指示函数，$\\mathcal{F}^{-1}$ 是离散傅里叶逆变换。\n\n测试套件（所有角度均以弧度为单位）：\n- 用例 A（良好解析的平滑输入）：$N = 32$，$u(x) = \\sin(x) + 0.5 \\sin(2x)$，因此 $u_x(x) = \\cos(x) + \\cos(2x)$ 且 $(u^2)_x = 2 u u_x$。\n- 用例 B（欠采样以暴露混叠）：$N = 15$，$u(x) = \\sin(5x) + 0.4 \\cos(7x)$，因此 $u_x(x) = 5 \\cos(5x) - 2.8 \\sin(7x)$ 且 $(u^2)_x = 2 u u_x$。\n- 用例 C（$2/3$ 规则的临界内容）：$N = 12$，$u(x) = \\sin(4x)$，因此 $u_x(x) = 4 \\cos(4x)$ 且 $(u^2)_x = 2 u u_x$。\n\n您的程序必须：\n- 根据您的推导，从第一性原理构建傅里叶谱微分矩阵 $D$（您可以使用快速傅里叶变换例程来组装 $D$ 或应用它）。\n- 对于每个用例，计算上述定义的 $E_{\\text{naive}}$ 和 $E_{2/3}$。\n- 生成单行输出，包含按顺序排列的六个结果 $[E_{\\text{naive}}^{\\text{A}}, E_{2/3}^{\\text{A}}, E_{\\text{naive}}^{\\text{B}}, E_{2/3}^{\\text{B}}, E_{\\text{naive}}^{\\text{C}}, E_{2/3}^{\\text{C}}]$，作为一个用方括号括起来的逗号分隔列表。值必须是十进制浮点数。\n\n不需要用户输入。所有计算都是无量纲和无单位的，所有关于 $x$ 的函数都使用弧度。", "solution": "所陈述的问题在科学上是合理的、内容自洽且适定的。它提出了数值分析中的一个标准任务：研究非线性项的谱微分和混叠误差。所有参数、函数和误差度量都得到了清晰和客观的定义。因此，一个完整的解决方案是必要的。\n\n该解决方案分三部分呈现：首先，从基本原理推导傅里叶谱微分矩阵；其次，解释非线性项中的混叠；第三，分析待实现的两种伪谱方法。\n\n### 1. 傅里叶谱微分矩阵的推导\n\n定义在周期域 $[0, 2\\pi)$ 上的函数 $f(x)$，可以在由 $N$ 个等距点 $x_j = \\frac{2\\pi j}{N}$（其中 $j=0, 1, \\dots, N-1$）组成的网格上，由其节点值的向量 $\\mathbf{f} = [f(x_0), f(x_1), \\dots, f(x_{N-1})]^T$ 来表示。傅里叶谱方法的核心原理是使用一个截断的傅里叶级数作为函数的全局插值。\n\n离散傅里叶变换 (DFT) 将物理空间值向量 $\\mathbf{f}$ 映射到复傅里叶系数向量 $\\hat{\\mathbf{f}}$。正向DFT的常规定义是：\n$$\n\\hat{f}_k = \\sum_{j=0}^{N-1} f_j e^{-i k x_j} = \\sum_{j=0}^{N-1} f_j e^{-i 2\\pi k j / N}\n$$\n其中 $f_j = f(x_j)$，整数 $k$ 表示波数指数。逆DFT (IDFT) 将系数变换回物理空间值：\n$$\nf_j = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{f}_k e^{i k x_j} = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{f}_k e^{i 2\\pi k j / N}\n$$\n问题指出，复指数函数 $e^{ikx}$ 是微分算子的特征函数，即 $\\frac{d}{dx} e^{ikx} = ik e^{ikx}$。这个性质使得微分可以在傅里叶空间中通过简单的乘法来执行。$f(x)$ 的谱微分通过一个三步过程实现：\n1.  使用DFT将网格函数 $\\mathbf{f}$ 变换为其傅里叶系数 $\\hat{\\mathbf{f}}$。\n2.  将每个傅里叶系数 $\\hat{f}_k$ 乘以其对应的微分特征值 $ik'$，其中 $k'$ 是真实的角波数。\n3.  使用IDFT将得到的系数变换回物理空间。\n\n我们用 $\\hat{\\mathbf{g}}$ 表示微分后的傅里叶系数向量。那么，$\\hat{g}_k = ik' \\hat{f}_k$。在物理空间中得到的导数向量 $\\mathbf{g}$ 为 $\\mathbf{g} = \\mathcal{F}^{-1}(\\hat{\\mathbf{g}})$。\n\n必须建立从DFT指数 $k \\in \\{0, 1, \\dots, N-1\\}$ 到真实角波数 $k'$ 的映射。对于一个有 $N$ 个点的网格，可表示的波数是带限的。标准的波数集为 $k' \\in \\{0, \\pm 1, \\dots, \\pm (N/2-1), -N/2\\}$（对于偶数 $N$），以及 $k' \\in \\{0, \\pm 1, \\dots, \\pm (N-1)/2\\}$（对于奇数 $N$）。这对应于 `numpy.fft.fftfreq` 提供的顺序。\n\n对于偶数 $N$ 会出现一个特殊情况。奈奎斯特频率，对应于 $k'=N/2$（或 $-N/2$），代表了最高频率模式 $e^{i (N/2) x_j} = e^{i\\pi j} = (-1)^j$。将此模式微分为 $i(N/2)e^{i(N/2)x_j}$ 会从一个实函数产生一个复数结果，这破坏了微分算子的实数到实数性质。为了保持这个性质，奈奎斯特模式的导数通常被设为零。\n\n我们可以将整个过程表示为单个矩阵向量乘积 $\\mathbf{g} = D\\mathbf{f}$，其中 $D$ 是 $N \\times N$ 的谱微分矩阵。设 $\\mathcal{F}$ 和 $\\mathcal{F}^{-1}$ 是表示DFT和IDFT操作的矩阵，$\\Lambda$ 是由特征值 $ik'$ 构成的对角矩阵。那么微分矩阵就是 $D = \\mathcal{F}^{-1} \\Lambda \\mathcal{F}$。\n\n矩阵 $D$ 的元素 $D_{jl}$ 可以显式推导：\n$$\n(D\\mathbf{f})_j = \\frac{1}{N} \\sum_{k} (ik') \\left( \\sum_{l=0}^{N-1} f_l e^{-ik'x_l} \\right) e^{ik'x_j} = \\sum_{l=0}^{N-1} \\left( \\frac{1}{N} \\sum_{k} ik' e^{ik'(x_j - x_l)} \\right) f_l\n$$\n括号中的项是矩阵元素 $D_{jl}$，其中求和是对适当的波数集 $k'$ 进行的。这表明 $D$ 是一个循环矩阵，因为其元素仅取决于差值 $j-l$。虽然这个公式定义了 $D$，但在实践中，算子是通过高效的基于FFT的三步过程来应用的，而不是构建稠密矩阵 $D$。\n\n### 2. 非线性乘积产生的混叠误差\n\n当计算像 $u^2$ 这样的非线性项时，会产生新的频率。考虑一个带限函数 $u(x)$，其傅里叶级数表示 $u(x) = \\sum_{k=-K}^{K} \\hat{u}_k e^{ikx}$ 包含有限数量的模式。那么乘积 $u^2(x)$ 为：\n$$\nu^2(x) = \\left(\\sum_{p=-K}^{K} \\hat{u}_p e^{ipx}\\right) \\left(\\sum_{q=-K}^{K} \\hat{u}_q e^{iqx}\\right) = \\sum_{p=-K}^{K} \\sum_{q=-K}^{K} \\hat{u}_p \\hat{u}_q e^{i(p+q)x}\n$$\n得到的函数 $u^2(x)$ 的模式波数最高可达 $p+q = \\pm 2K$。\n\n在由 $N$ 个点组成的离散网格上，只有波数最高到奈奎斯特频率（大约 $N/2$）的模式才能被唯一表示。任何频率 $|k'| > N/2$ 都会被“混叠”，并且在网格上变得与一个较低的频率无法区分。这是因为对于任何整数 $m$：\n$$\ne^{i(k' + mN)x_j} = e^{i(k' + mN) \\frac{2\\pi j}{N}} = e^{ik' \\frac{2\\pi j}{N}} e^{i m N \\frac{2\\pi j}{N}} = e^{ik'x_j} e^{i 2\\pi mj} = e^{ik'x_j}\n$$\n因此，模式 $k'+mN$ 在网格上看起来与模式 $k'$ 相同。\n\n当我们在物理空间中逐点计算 $f_j = u(x_j)^2$ 时，我们隐式地创建了这些高频（最高到 $2K$）。如果 $2K > N/2$，这些高频就会被混叠到较低的频率上，从而污染了本应代表 $u^2(x)$ 真实低频内容的傅里叶系数。这种污染就是混叠误差。朴素伪谱法，即逐点计算 $u^2$ 然后微分，就容易受到这种误差的影响。\n\n### 3. 伪谱近似与去混叠\n\n该问题指定了两种近似 $(u^2)_x$ 的方法。\n\n**1. 朴素伪谱法：**\n该方法直接在物理空间中执行乘法。\n- 计算向量 $\\mathbf{f}$，其中 $f_j = u(x_j)^2$。如果 $u(x)$ 相对于网格大小 $N$ 不是充分带限的，这一步会引入混叠误差。\n- 将谱微分算子 $D$ 应用于 $\\mathbf{f}$。计算上，这通过 $(u^2)_x \\approx \\mathcal{F}^{-1}(ik' \\cdot \\mathcal{F}(\\mathbf{f}))$ 完成。\n得到的近似值既包含了真实信号的导数，也包含了混叠误差的导数。\n\n**2. 2/3规则去混叠法：**\n此方法试图减轻混叠。这个名称来源于完全防止混叠的条件：如果初始信号 $u(x)$ 的带限为 $|k|  N/3$，那么乘积 $u^2(x)$ 将包含最高达 $|k|  2N/3$ 的模式。由于对于 $N \\ge 0$ 有 $2N/3  N$，更重要的是避免了最高频率的混叠相互作用，因此傅里叶空间中的卷积可以计算而没有环绕误差。\n\n问题中指定的程序是基于这一原理的低通滤波方法：\n- 与朴素方法一样，计算 $\\mathbf{f}$，其中 $f_j = u(x_j)^2$。得到的网格函数是混叠的。\n- 变换到傅里叶空间，得到混叠的系数 $\\hat{\\mathbf{f}}$。\n- 假设真实的、未混叠的信号主要包含在波数的低三分之一部分。将所有 $|k'| > \\lfloor N/3 \\rfloor$ 的傅里叶系数 $\\hat{f}_k$ 置零。这定义了一组新的经过滤波的系数 $\\hat{\\mathbf{f}}_{\\text{filt}}$。\n- 通过计算 $ik' \\hat{\\mathbf{f}}_{\\text{filt}}$ 在傅里叶空间中进行微分。\n- 通过IDFT变换回物理空间。\n\n这种滤波移除了高频内容，这些内容被假定主要由混叠误差构成。然而，它无法纠正已经污染了被滤波器保留的低频模式的混叠误差。当真实信号在频谱上与混叠分量有很好的分离时，这种方法最有效。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the spectral differentiation problem for three test cases, computing\n    the maximum-norm error for a naive pseudospectral method and a de-aliased\n    method using the 2/3-rule.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"id\": \"A\",\n            \"N\": 32,\n            \"u_func\": lambda x: np.sin(x) + 0.5 * np.sin(2 * x),\n            \"ux_func\": lambda x: np.cos(x) + np.cos(2 * x),\n        },\n        {\n            \"id\": \"B\",\n            \"N\": 15,\n            \"u_func\": lambda x: np.sin(5 * x) + 0.4 * np.cos(7 * x),\n            \"ux_func\": lambda x: 5 * np.cos(5 * x) - 2.8 * np.sin(7 * x),\n        },\n        {\n            \"id\": \"C\",\n            \"N\": 12,\n            \"u_func\": lambda x: np.sin(4 * x),\n            \"ux_func\": lambda x: 4 * np.cos(4 * x),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        u_func = case[\"u_func\"]\n        ux_func = case[\"ux_func\"]\n\n        # 1. Set up the grid and evaluate the exact functions\n        x_grid = 2 * np.pi * np.arange(N) / N\n        u_vec = u_func(x_grid)\n        ux_vec = ux_func(x_grid)\n\n        # The exact derivative of the nonlinear flux: (u^2)_x = 2*u*u_x\n        d_u2_exact = 2 * u_vec * ux_vec\n\n        # The nonlinear flux evaluated on the grid\n        f_vec = u_vec**2\n        \n        # 2. Naive Pseudospectral Method\n        \n        # Wavenumbers for differentiation. For real-valued functions, the\n        # derivative of the Nyquist mode (for N even) is set to 0.\n        k_wave = N * np.fft.fftfreq(N)\n        if N % 2 == 0:\n            k_wave[N // 2] = 0.0\n\n        # Differentiate in Fourier space and transform back\n        f_hat = np.fft.fft(f_vec)\n        d_u2_naive = np.real(np.fft.ifft(1j * k_wave * f_hat))\n\n        # Compute max-norm error\n        E_naive = np.max(np.abs(d_u2_naive - d_u2_exact))\n        results.append(E_naive)\n\n        # 3. 2/3-Rule De-aliased Method\n        \n        # Wavenumbers for filtering and differentiation\n        k_wave_dealias = N * np.fft.fftfreq(N)\n        \n        # Apply the 2/3-rule filter mask in Fourier space\n        K_cut = np.floor(N / 3)\n        mask = np.abs(k_wave_dealias) = K_cut\n        \n        f_hat_filtered = f_hat * mask\n\n        # Differentiate the filtered coefficients and transform back.\n        # No special Nyquist handling is needed for k_wave_dealias here because\n        # for N>3, floor(N/3)  N/2, so the filter mask already sets the\n        # Nyquist mode coefficient to zero.\n        d_u2_dealias = np.real(np.fft.ifft(1j * k_wave_dealias * f_hat_filtered))\n\n        # Compute max-norm error\n        E_2_3 = np.max(np.abs(d_u2_dealias - d_u2_exact))\n        results.append(E_2_3)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n\n```", "id": "3277414"}]}