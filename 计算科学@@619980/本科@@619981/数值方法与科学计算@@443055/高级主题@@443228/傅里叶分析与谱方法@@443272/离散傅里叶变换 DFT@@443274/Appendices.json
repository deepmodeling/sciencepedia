{"hands_on_practices": [{"introduction": "这个入门练习将帮助你热身。我们将直接应用离散傅里叶变换 (DFT) 的定义来处理一个简单的两点信号，从最基础的层面理解其工作原理。本练习的目标是建立一种直观感受：DFT 如同一个棱镜，能将信号分解为其基本构成部分，例如信号的平均值（直流分量）和其主要振荡分量 [@problem_id:1759585]。", "problem": "一个微机电系统 (MEMS) 加速计被用于监测一个微型悬臂梁的高频振动。由于硬件限制，数据采集系统在其缓冲区满之前只能从悬臂梁的运动中捕获两个连续的位移测量值。该时域信号是一个包含两个样本的序列，记为 $x[n]$。\n\n测得的两个值为：\n$x[0] = A_0 + A_1$\n$x[1] = A_0 - A_1$\n\n此处，$A_0$ 代表悬臂梁的静态平衡位置（直流分量），而 $A_1$ 代表在采样频率下的主导振动模式的振幅。$A_0$ 和 $A_1$ 都是非零的实值物理常数。\n\n为了分析这个非常短的信号的频率内容，你需要计算其2点离散傅里叶变换 (DFT)。序列 $x[n]$ 的 N 点 DFT 定义为：\n$$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j \\frac{2\\pi}{N} kn\\right) \\quad \\text{for } k = 0, 1, \\dots, N-1$$\n其中 $j$ 是虚数单位，满足 $j^2 = -1$。\n\n找出两个 DFT 分量 $X[0]$ 和 $X[1]$ 关于常数 $A_0$ 和 $A_1$ 的表达式。将你的最终答案以一个行矩阵的形式呈现，该矩阵按顺序包含 $X[0]$ 和 $X[1]$ 的表达式。", "solution": "给定一个长度为2的序列，其样本为 $x[0]=A_{0}+A_{1}$ 和 $x[1]=A_{0}-A_{1}$，我们要使用以下公式计算其 $N=2$ 点的 DFT：\n$$\nX[k]=\\sum_{n=0}^{N-1}x[n]\\exp\\!\\left(-j\\frac{2\\pi}{N}kn\\right),\\quad k\\in\\{0,1\\}.\n$$\n当 $N=2$ 时，该公式变为\n$$\nX[k]=\\sum_{n=0}^{1}x[n]\\exp(-j\\pi kn).\n$$\n\n当 $k=0$ 时，对于 $n=0$ 和 $n=1$，指数因子均为 $\\exp(0)=1$，因此\n$$\nX[0]=x[0]+x[1]=(A_{0}+A_{1})+(A_{0}-A_{1})=2A_{0}.\n$$\n\n当 $k=1$ 时，我们有\n$$\nX[1]=x[0]\\exp(0)+x[1]\\exp(-j\\pi)=x[0]-x[1]=(A_{0}+A_{1})-(A_{0}-A_{1})=2A_{1}.\n$$\n\n因此，按 $(X[0],X[1])$ 顺序排列成一个行矩阵的两个 DFT 分量是 $2A_{0}$ 和 $2A_{1}$。", "answer": "$$\\boxed{\\begin{pmatrix}2A_{0} & 2A_{1}\\end{pmatrix}}$$", "id": "1759585"}, {"introduction": "掌握了基础知识后，我们将从手动计算转向编程实践。本练习要求你根据离散傅里叶变换 (DFT) 和循环卷积的数学定义，亲手实现它们。你将利用自己编写的代码，从数值上验证强大的卷积定理——这是信号处理领域的一块基石，它揭示了时域中的卷积等价于频域中的乘积这一优美关系 [@problem_id:3222895]。", "problem": "考虑有限长度的复数序列及其离散变换。您将从离散傅里叶变换 (DFT) 和离散傅里叶逆变换 (IDFT) 的定义开始，对于长度为 $N$ 的序列 $x[n]$，其 DFT $X[k]$ 和 IDFT $x[n]$ 由以下基本公式定义：$$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-\\mathrm{i}\\,\\frac{2\\pi}{N} n k\\right),\\quad k=0,1,\\dots,N-1,$$ $$x[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k] \\exp\\left(\\mathrm{i}\\,\\frac{2\\pi}{N} n k\\right),\\quad n=0,1,\\dots,N-1.$$ 两个长度同为 $N$ 的序列 $x[n]$ 和 $y[n]$ 的离散循环卷积定义为 $$z[n] = \\sum_{m=0}^{N-1} x[m]\\,y[(n-m)\\bmod N],\\quad n=0,1,\\dots,N-1.$$ 您的任务是直接根据这些定义实现 DFT 和 IDFT，并根据其定义实现直接循环卷积。仅使用这些基本公式，不使用任何专门用于变换或卷积的库函数，通过比较两条计算路径来数值验证离散序列的卷积定理等价性：(i) 时域中的直接循环卷积；(ii) 通过变换到频域，在该域中执行逐元素乘法，然后变换回时域获得的循环卷积。对于每个测试用例，计算两个结果序列之间最大的逐元素绝对差，并判断该差值是否小于或等于双精度浮点运算的机器 epsilon。使用复数双精度，并将所有量视为无单位。任何指数参数的角度单位均为弧度。每个测试用例的最终结果必须是一个布尔值，指示数值等价性是否在机器 epsilon 范围内成立。\n\n实现您的程序以运行以下测试套件，其中每个测试用例由 $(N, x, y)$ 给出，$N$ 是公共长度，$x$ 和 $y$ 是序列：\n- 测试 $1$：$N=1$，$x=[\\,3\\,]$，$y=[\\,-2\\,]$。\n- 测试 $2$：$N=2$，$x=[\\,1,\\,2\\,]$，$y=[\\,-1,\\,3\\,]$。\n- 测试 $3$：$N=4$，$x=[\\,1,\\,0,\\,-1,\\,0\\,]$，$y=[\\,0,\\,2,\\,0,\\,-2\\,]$。\n- 测试 $4$：$N=4$，$x=[\\,0,\\,0,\\,0,\\,0\\,]$，$y=[\\,5,\\,-7,\\,13,\\,-11\\,]$。\n- 测试 $5$：$N=4$，$x=[\\,\\mathrm{i},\\,0,\\,-\\mathrm{i},\\,0\\,]$，$y=[\\,2,\\,0,\\,-2,\\,0\\,]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按顺序包含上述五个测试的结果（例如 $[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_j$ 为 $True$ 或 $False$。", "solution": "## 问题验证\n\n### 第 1 步：提取已知信息\n\n问题提供了以下定义、数据和条件：\n- **离散傅里叶变换 (DFT)** 对于长度为 $N$ 的序列 $x[n]$：\n$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-\\mathrm{i}\\,\\frac{2\\pi}{N} n k\\right),\\quad k=0,1,\\dots,N-1$\n- **离散傅里叶逆变换 (IDFT)** 对于长度为 $N$ 的频域序列 $X[k]$：\n$x[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k] \\exp\\left(\\mathrm{i}\\,\\frac{2\\pi}{N} n k\\right),\\quad n=0,1,\\dots,N-1$\n- **离散循环卷积** 对于两个长度同为 $N$ 的序列 $x[n]$ 和 $y[n]$：\n$z[n] = \\sum_{m=0}^{N-1} x[m]\\,y[(n-m)\\bmod N],\\quad n=0,1,\\dots,N-1$\n- **任务**：通过比较两种方法来数值验证卷积定理：\n    1.  `(i)` 时域中的直接循环卷积。\n    2.  `(ii)` 通过 DFT、频域中的逐元素乘法和 IDFT 实现的循环卷积。\n- **比较标准**：两个结果序列之间最大的逐元素绝对差必须小于或等于双精度浮点运算的机器 epsilon。\n- **数值精度**：使用复数双精度。\n- **单位**：所有量均为无单位，角度单位为弧度。\n- **测试套件**：\n    - 测试 $1$：$N=1$，$x=[\\,3\\,]$，$y=[\\,-2\\,]$。\n    - 测试 $2$：$N=2$，$x=[\\,1,\\,2\\,]$，$y=[\\,-1,\\,3\\,]$。\n    - 测试 $3$：$N=4$，$x=[\\,1,\\,0,\\,-1,\\,0\\,]$，$y=[\\,0,\\,2,\\,0,\\,-2\\,]$。\n    - 测试 $4$：$N=4$，$x=[\\,0,\\,0,\\,0,\\,0\\,]$，$y=[\\,5,\\,-7,\\,13,\\,-11\\,]$。\n    - 测试 $5$：$N=4$，$x=[\\,\\mathrm{i},\\,0,\\,-\\mathrm{i},\\,0\\,]$，$y=[\\,2,\\,0,\\,-2,\\,0\\,]$。\n- **输出格式**：一个用方括号括起来的单行逗号分隔布尔结果列表，例如 $[r_1,r_2,r_3,r_4,r_5]$。\n\n### 第 2 步：使用提取的已知信息进行验证\n\n根据验证标准对问题进行评估：\n- **科学依据**：该问题基于卷积定理，这是离散傅里叶变换的一个基本且经过严格证明的性质。所提供的 DFT、IDFT 和循环卷积的定义都是标准且正确的。该问题是一个标准的数值验证任务。\n- **适定性**：问题定义清晰。输入已指定，计算过程有明确描述（或由公式定义），判断结果的标准是精确的。每个测试用例都存在唯一且有意义的布尔结果。\n- **客观性**：语言精确无歧义。指令具体，没有主观解释的余地。\n- **完整性**：提供了所有必要的信息（公式、测试数据、精度要求、输出格式）。问题是自洽的。\n\n### 第 3 步：结论与行动\n\n问题陈述是**有效**的。这是一个关于数值方法和数字信号处理的适定且科学合理的练习。我将继续提供完整的解决方案。\n\n## 解决方案\n\n目标是数值验证离散有限长度序列的卷积定理。该定理指出，时域中的循环卷积等价于频域中的逐元素乘法。我们将直接根据其数学定义实现 DFT、IDFT 和循环卷积的函数，然后用它们来比较每个测试用例的两条计算路径。\n\n### 1. 核心函数的实现\n\n我们将编写三个与问题陈述中提供的定义相对应的函数。所有计算都将使用复数双精度数（`complex128`）进行。\n\n#### 离散傅里叶变换 (DFT)\n长度为 $N$ 的序列 $x[n]$ 的 DFT 由下式给出：\n$$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-\\mathrm{i}\\,\\frac{2\\pi}{N} n k\\right)$$\n这可以转化为一个具有两个嵌套循环的算法。外层循环遍历频率索引 $k$（从 $0$ 到 $N-1$），内层循环计算时域索引 $n$（从 $0$ 到 $N-1$）上的和。对于每对 $(n,k)$，我们计算复指数项，乘以 $x[n]$，并累加到 $X[k]$ 的运行总和中。\n\n#### 离散傅里叶逆变换 (IDFT)\n频域序列 $X[k]$ 的 IDFT 为：\n$$x[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k] \\exp\\left(\\mathrm{i}\\,\\frac{2\\pi}{N} n k\\right)$$\n其实现与 DFT 类似，但指数的符号为正，并且每个 $x[n]$ 的最终和要乘以一个因子 $1/N$。\n\n#### 直接循环卷积\n两个长度为 $N$ 的序列 $x[n]$ 和 $y[n]$ 的循环卷积为：\n$$z[n] = \\sum_{m=0}^{N-1} x[m]\\,y[(n-m)\\bmod N]$$\n其算法同样涉及两个嵌套循环。外层循环遍历输出索引 $n$（从 $0$ 到 $N-1$）。内层循环遍历求和索引 $m$（从 $0$ 到 $N-1$）。一个关键步骤是计算序列 $y$ 的索引，即 $(n-m) \\pmod N$。这种模运算确保了卷积的周期性（循环）性质。\n\n### 2. 验证过程\n\n对于每个测试用例 $(N, x, y)$，执行双路计算：\n\n- **路径 (i)：时域中的直接卷积**\n使用输入序列 $x$ 和 $y$ 调用直接循环卷积函数，生成结果 $z_{\\text{direct}}$。\n$$z_{\\text{direct}}[n] = \\sum_{m=0}^{N-1} x[m]\\,y[(n-m)\\bmod N]$$\n\n- **路径 (ii)：通过频域进行卷积**\n该路径包括三个步骤：\n1.  计算两个输入序列的 DFT：$X = \\text{DFT}(x)$ 和 $Y = \\text{DFT}(y)$。\n2.  对得到的频域序列进行逐元素乘法：$Z[k] = X[k] \\cdot Y[k]$。\n3.  计算乘积序列 $Z$ 的 IDFT，将结果变换回时域：$z_{\\text{freq}} = \\text{IDFT}(Z)$。\n\n### 3. 比较与最终结果\n\n卷积定理保证，在无限精度算术下，$z_{\\text{direct}}$ 和 $z_{\\text{freq}}$ 将是完全相同的。然而，由于数值计算中的浮点表示和舍入误差，我们预计会存在微小差异。验证过程包括检查这些差异是否在可接受的容差范围内。\n\n问题将此容差指定为双精度浮点数的机器 epsilon，记为 $\\epsilon$。该值表示在浮点算术中，使 $1.0 + \\epsilon \\neq 1.0$ 成立的最小数。\n\n比较过程形式化如下：\n1.  计算两个结果向量之间的逐元素绝对差：$\\Delta[n] = |z_{\\text{direct}}[n] - z_{\\text{freq}}[n]|$。\n2.  找出该差分向量中的最大值：$\\Delta_{\\max} = \\max_{n} \\Delta[n]$。\n3.  如果此最大差值小于或等于机器 epsilon，则认为等价性得到验证：$\\Delta_{\\max} \\leq \\epsilon$。\n\n根据此条件为每个测试用例生成一个布尔结果（$True$ 或 $False$）。最终输出将这些布尔值汇总成指定的列表格式。", "answer": "```python\nimport numpy as np\n\ndef dft(x_seq: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the Discrete Fourier Transform (DFT) of a sequence.\n    \n    Args:\n        x_seq: A 1D numpy array of complex numbers representing the sequence.\n        \n    Returns:\n        A 1D numpy array representing the DFT of the sequence.\n    \"\"\"\n    N = len(x_seq)\n    X = np.zeros(N, dtype=np.complex128)\n    for k in range(N):\n        sum_val = np.complex128(0)\n        for n in range(N):\n            angle = -1j * 2 * np.pi * n * k / N\n            sum_val += x_seq[n] * np.exp(angle)\n        X[k] = sum_val\n    return X\n\ndef idft(X_seq: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the Inverse Discrete Fourier Transform (IDFT) of a sequence.\n    \n    Args:\n        X_seq: A 1D numpy array of complex numbers representing the frequency-domain sequence.\n        \n    Returns:\n        A 1D numpy array representing the IDFT of the sequence.\n    \"\"\"\n    N = len(X_seq)\n    x = np.zeros(N, dtype=np.complex128)\n    for n in range(N):\n        sum_val = np.complex128(0)\n        for k in range(N):\n            angle = 1j * 2 * np.pi * n * k / N\n            sum_val += X_seq[k] * np.exp(angle)\n        x[n] = sum_val / N\n    return x\n\ndef circular_conv(x_seq: np.ndarray, y_seq: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the direct circular convolution of two sequences.\n    \n    Args:\n        x_seq: The first 1D numpy array of complex numbers.\n        y_seq: The second 1D numpy array of complex numbers.\n        \n    Returns:\n        A 1D numpy array representing the circular convolution of the two sequences.\n    \"\"\"\n    N = len(x_seq)\n    z = np.zeros(N, dtype=np.complex128)\n    for n in range(N):\n        sum_val = np.complex128(0)\n        for m in range(N):\n            y_index = (n - m) % N\n            sum_val += x_seq[m] * y_seq[y_index]\n        z[n] = sum_val\n    return z\n\ndef solve():\n    \"\"\"\n    Runs the test suite to verify the convolution theorem and prints the results.\n    \"\"\"\n    test_cases = [\n        (1, [3], [-2]),\n        (2, [1, 2], [-1, 3]),\n        (4, [1, 0, -1, 0], [0, 2, 0, -2]),\n        (4, [0, 0, 0, 0], [5, -7, 13, -11]),\n        (4, [1j, 0, -1j, 0], [2, 0, -2, 0])\n    ]\n\n    results = []\n    machine_epsilon = np.finfo(np.float64).eps\n\n    for N, x_list, y_list in test_cases:\n        x = np.array(x_list, dtype=np.complex128)\n        y = np.array(y_list, dtype=np.complex128)\n\n        # Route (i): Direct circular convolution\n        z_direct = circular_conv(x, y)\n\n        # Route (ii): Convolution via frequency domain\n        X = dft(x)\n        Y = dft(y)\n        Z = X * Y\n        z_freq = idft(Z)\n\n        # Compare the two results\n        max_abs_diff = np.max(np.abs(z_direct - z_freq))\n        \n        is_equivalent = max_abs_diff = machine_epsilon\n        results.append(is_equivalent)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3222895"}, {"introduction": "现实世界中的信号在时间上总是有限的，这会在 DFT 频谱中引入一种被称为“频谱泄漏”的失真。这个高级练习将深入探讨这一实际挑战，探索如何应用“窗函数”来抑制泄漏，从而提高我们分辨相近频率的能力。你将学会量化不同窗函数之间的优劣权衡，这是任何严肃频谱分析应用中的一项关键技能 [@problem_id:3222838]。", "problem": "考虑一个实值的离散时间信号，它由两个归一化频率相近的正弦波组成。设 $x[n] = A_1 \\sin(2\\pi f_1 n) + A_2 \\sin(2\\pi f_2 n)$，其中 $n = 0, 1, \\dots, N-1$，$f_1$ 和 $f_2$ 的单位是每样本周期数（无量纲），并且正弦波的参数使用弧度。您将分析加窗对离散傅里叶变换 (DFT) 的影响，主要关注频谱泄漏以及两个音调的可分辨性。\n\n请使用以下基本原理作为您推理和算法设计的基础：\n\n- 长度为 $N$ 的序列 $y[n]$ 的离散傅里叶变换 (DFT) 定义为 $Y[k] = \\sum_{n=0}^{N-1} y[n] e^{-j 2\\pi k n / N}$，其中 $k = 0, 1, \\dots, N-1$，$j$ 是虚数单位。\n- 时域加窗是将信号与窗函数 $w[n]$ 相乘，这对应于频域的卷积：如果 $y[n] = x[n] w[n]$，那么 $Y[k]$ 是 $x[n]$ 的频谱与 $w[n]$ 的频谱的采样卷积。当窗函数的频谱存在非零旁瓣时，这会将能量扩散到其他 DFT 频点。\n- 使用两种窗函数：\n  - 矩形窗定义为 $w_\\mathrm{rect}[n] = 1$，其中 $0 \\le n \\le N-1$。\n  - Hann 窗定义为 $w_\\mathrm{Hann}[n] = \\tfrac{1}{2}\\left(1 - \\cos\\left(\\tfrac{2\\pi n}{N-1}\\right)\\right)$，其中 $0 \\le n \\le N-1$。\n\n定义以下定量指标：\n\n1. 对于给定窗函数 $w$ 的频谱泄漏比：\n   - 计算加窗信号 $x[n] w[n]$ 的 DFT $X_w[k]$ 和功率谱 $P_w[k] = |X_w[k]|^2$，其中 $k = 0, 1, \\dots, N-1$。\n   - 对于每个正弦波 $f_i$（其中 $i \\in \\{1,2\\}$），找到其最近的正频率 DFT 频点索引 $k_i = \\mathrm{round}(f_i N)$ 和对应的负频率索引 $k_i^- = (N - k_i) \\bmod N$。\n   - 对于这两个索引（正频率和负频率），通过在索引周围的小邻域内搜索 $P_w[k]$ 的局部最大值来修正峰值位置。设修正后的峰值索引为 $k_i^{(+)}$ 和 $k_i^{(-)}$。\n   - 将主瓣半宽度（以频点数为单位）定义为 $M_w$，对于矩形窗，$M_\\mathrm{rect} = 1$，对于 Hann 窗，$M_\\mathrm{Hann} = 2$。对于 $i=1,2$，构建闭合索引区间 $[k_i^{(+)} - M_w, \\, k_i^{(+)} + M_w]$ 和 $[k_i^{(-)} - M_w, \\, k_i^{(-)} + M_w]$ 的并集，并将其裁剪到有效索引范围 $\\{0,1,\\dots,N-1\\}$ 内，同时合并任何重叠部分。\n   - 设 $E_\\mathrm{main}(w)$ 为这些区间并集上 $P_w[k]$ 的总和，设 $E_\\mathrm{tot}(w) = \\sum_{k=0}^{N-1} P_w[k]$ 为总频谱能量。泄漏比为 $\\mathrm{LR}(w) = \\dfrac{E_\\mathrm{tot}(w) - E_\\mathrm{main}(w)}{E_\\mathrm{tot}(w)}$，该值为无量纲。\n\n2. 对于给定窗函数 $w$ 的双音调可分辨性准则：\n   - 将注意力集中在正半频频谱索引 $k \\in \\{0,1,\\dots,\\lfloor N/2 \\rfloor\\}$ 上。\n   - 使用上面找到的修正后的峰值索引 $k_1^{(+)}$ 和 $k_2^{(+)}$，检查它们之间是否严格存在至少一个频点。如果不存在，则它们不可分辨。\n   - 设 $k_\\mathrm{low} = \\min(k_1^{(+)}, k_2^{(+)})$ 和 $k_\\mathrm{high} = \\max(k_1^{(+)}, k_2^{(+)})$。计算谷底功率 $V = \\min\\{P_w[k] : k_\\mathrm{low}  k  k_\\mathrm{high}\\}$，以及较弱峰值功率 $P_\\mathrm{weak} = \\min(P_w[k_1^{(+)}], P_w[k_2^{(+)}])$。\n   - 使用阈值参数 $\\alpha = 0.5$，如果 $V  \\alpha \\, P_\\mathrm{weak}$，则声明音调可分辨；否则，声明它们不可分辨。将此结果以布尔值形式输出。\n\n您的程序必须精确实现这些定义，并评估以下测试套件。所有频率 $f$ 都以每样本周期数进行归一化，正弦波参数中的所有角度都以弧度为单位。输出为指定的无量纲浮点数或布尔值。\n\n测试套件参数集 $(N, f_1, f_2, A_1, A_2)$：\n\n- 案例 1（一般的非整数倍频点，频率相近）：$(1024, \\, 0.100, \\, 0.100 + \\tfrac{1.5}{1024}, \\, 1.0, \\, 1.0)$\n- 案例 2（精确频点，相邻频点）：$(1024, \\, \\tfrac{100}{1024}, \\, \\tfrac{102}{1024}, \\, 1.0, \\, 1.0)$\n- 案例 3（亚频点间隔）：$(1024, \\, 0.200, \\, 0.200 + \\tfrac{0.6}{1024}, \\, 1.0, \\, 1.0)$\n- 案例 4（幅度不等，在更高的 $N$ 下间隔一个频点）：$(2048, \\, 0.123, \\, 0.123 + \\tfrac{1}{2048}, \\, 1.0, \\, 0.2)$\n\n对于每个测试案例，计算并返回一个包含四个元素的列表：$\\mathrm{LR}(\\mathrm{rect})$（浮点数），$\\mathrm{LR}(\\mathrm{Hann})$（浮点数），$\\mathrm{R}(\\mathrm{rect})$（布尔值），和 $\\mathrm{R}(\\mathrm{Hann})$（布尔值）。\n\n最终输出格式：您的程序应生成一行输出，其中包含所有测试案例的结果，格式为一个包含在方括号内的逗号分隔列表，每个测试案例的结果本身也是一个按上述顺序排列的列表。例如，输出应类似于 $[[\\dots],[\\dots],[\\dots],[\\dots]]$，不含任何附加文本。", "solution": "问题陈述已经过仔细审查，并被确定为有效。它在科学上基于数字信号处理的原理，问题定义适定，包含了所有必要的数据和定义，并且其表述是客观的。任务是分析一个双音调信号在不同窗函数下的频谱特性，这是数值方法中一个标准且信息丰富的练习。因此，我们可以继续进行解答。\n\n此问题的核心在于加窗引入的频谱分析中的基本权衡。有限长度信号的离散傅里叶变换 (DFT) 内在地假设信号以其长度 $N$ 为周期。如果信号的频率不是基本频率分辨率 $\\frac{1}{N}$ 的整数倍，就会发生称为频谱泄漏的现象。这相当于将无限长信号乘以一个矩形窗，该窗函数具有类似 sinc 函数的频谱和高旁瓣。这些旁瓣会将信号真实频率分量的能量扩散到所有其他 DFT 频点上。\n\n矩形窗以外的窗函数旨在通过在信号端点处平滑地衰减至零来减轻这种泄漏。这会降低频谱旁瓣，但代价是加宽了主瓣。Hann 窗是一个经典的例子：它提供的旁瓣比矩形窗低得多，但其主瓣大约宽两倍。这导致了一个直接的权衡：更高的幅度精度和更少的泄漏（更适合检测强信号旁的弱信号）与更低的频率分辨率（更难区分两个频率相近的音调）。\n\n我们的算法将通过实现两个指定的指标来为给定的测试案例量化这种权衡：频谱泄漏比 ($\\mathrm{LR}$) 和双音调可分辨性准则 ($\\mathrm{R}$) 。\n\n每个测试案例的算法流程如下：\n\n1.  信号生成：对于给定的参数集 $(N, f_1, f_2, A_1, A_2)$，根据模型生成离散时间信号 $x[n]$，其中 $n = 0, 1, \\dots, N-1$：\n    $$x[n] = A_1 \\sin(2\\pi f_1 n) + A_2 \\sin(2\\pi f_2 n)$$\n    对两种指定的窗函数，重复此过程。\n\n2.  加窗和 DFT：\n    - 将信号 $x[n]$ 与所选窗函数 $w[n]$ 按元素相乘，得到加窗信号 $y[n] = x[n] w[n]$。这两种窗函数是：\n      - 矩形窗：$w_\\mathrm{rect}[n] = 1$\n      - Hann 窗：$w_\\mathrm{Hann}[n] = \\frac{1}{2}\\left(1 - \\cos\\left(\\frac{2\\pi n}{N-1}\\right)\\right)$\n    - 使用以下公式计算加窗信号的 $N$ 点 DFT $X_w[k]$：\n      $$X_w[k] = \\sum_{n=0}^{N-1} y[n] e^{-j 2\\pi k n / N}$$\n      其中 $j$ 是虚数单位。然后计算功率谱 $P_w[k] = |X_w[k]|^2$。\n\n3.  频谱泄漏比 ($\\mathrm{LR}$) 计算：\n    - 对于每个频率分量 $f_i$（其中 $i \\in \\{1, 2\\}$），其在频谱正半频和负半频中的预期频点位置分别估计为 $k_i = \\mathrm{round}(f_i N)$ 和 $k_i^- = (N - k_i) \\bmod N$。\n    - 通过在每个估计位置周围 $\\pm 2$ 个频点的小邻域内搜索功率谱 $P_w[k]$ 的局部最大值来修正这些估计位置。这会得到修正后的峰值索引 $\\{ k_1^{(+)}, k_1^{(-)}, k_2^{(+)}, k_2^{(-)} \\}$。\n    - 通过对这四个修正后峰值周围的定义区间内的功率谱值求和来计算主瓣能量 $E_\\mathrm{main}(w)$。这些区间是 $[k_\\mathrm{peak} - M_w, k_\\mathrm{peak} + M_w]$，其中主瓣半宽度 $M_w$ 对于矩形窗为 $M_\\mathrm{rect} = 1$，对于 Hann 窗为 $M_\\mathrm{Hann} = 2$。为了处理来自两个正弦波的频谱分量和潜在的重叠，将这四个区间中所有频点的并集形成，并将索引裁剪到有效范围 $[0, N-1]$。\n    - 同时计算总能量 $E_\\mathrm{tot}(w) = \\sum_{k=0}^{N-1} P_w[k]$。然后，泄漏比由以下公式给出：\n      $$\\mathrm{LR}(w) = \\frac{E_\\mathrm{tot}(w) - E_\\mathrm{main}(w)}{E_\\mathrm{tot}(w)}$$\n      该值表示“泄漏”到定义的主瓣之外的总能量的比例。\n\n4.  双音调可分辨性 ($\\mathrm{R}$) 计算：\n    - 该指标专注于正频频谱，$k \\in \\{0, 1, \\dots, \\lfloor N/2 \\rfloor\\}$，使用修正后的正频峰值 $k_1^{(+)}$ 和 $k_2^{(+)}$。\n    - 设 $k_\\mathrm{low} = \\min(k_1^{(+)}, k_2^{(+)})$ 和 $k_\\mathrm{high} = \\max(k_1^{(+)}, k_2^{(+)})$。\n    - 如果两个峰值之间没有严格存在的 DFT 频点，即 $k_\\mathrm{high} \\le k_\\mathrm{low} + 1$，则认为这两个音调不可分辨。\n    - 如果存在间隔，则找到峰值之间谷底的最小功率：$V = \\min\\{P_w[k] \\mid k_\\mathrm{low}  k  k_\\mathrm{high}\\}$。\n    - 同时确定两个峰值中较弱者的功率：$P_\\mathrm{weak} = \\min(P_w[k_1^{(+)}], P_w[k_2^{(+)}])$。\n    - 如果谷底相对于较弱峰值足够深，即满足以下条件（使用给定阈值 $\\alpha = 0.5$），则声明音调可分辨：\n      $$V  \\alpha \\, P_\\mathrm{weak}$$\n      结果是一个布尔值（True 表示可分辨，False 表示不可分辨）。\n\n通过对每个测试案例的两种窗函数类型应用此完整流程，我们生成了所需的四个指标集：$\\mathrm{LR}(\\mathrm{rect})$、$\\mathrm{LR}(\\mathrm{Hann})$、$\\mathrm{R}(\\mathrm{rect})$ 和 $\\mathrm{R}(\\mathrm{Hann})$。", "answer": "```python\n# 完整且可运行的 Python 3 代码如下。\n# 导入必须遵守指定的执行环境。\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    为一组测试案例解决 DFT 加窗分析问题。\n    \"\"\"\n    # 定义来自问题陈述的测试案例。\n    test_cases = [\n        # 案例 1：一般的非整数倍频点，频率相近\n        (1024, 0.100, 0.100 + 1.5/1024, 1.0, 1.0),\n        # 案例 2：精确频点，相邻频点\n        (1024, 100/1024, 102/1024, 1.0, 1.0),\n        # 案例 3：亚频点间隔\n        (1024, 0.200, 0.200 + 0.6/1024, 1.0, 1.0),\n        # 案例 4：幅度不等，在更高的 N 下间隔一个频点\n        (2048, 0.123, 0.123 + 1/2048, 1.0, 0.2),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        N, f1, f2, A1, A2 = case\n        \n        # 生成时间向量和信号\n        n = np.arange(N)\n        x = A1 * np.sin(2 * np.pi * f1 * n) + A2 * np.sin(2 * np.pi * f2 * n)\n        \n        # 定义窗函数参数\n        window_params = {\n            'rect': {'func': np.ones(N), 'M_w': 1},\n            'hann': {'func': 0.5 * (1 - np.cos(2 * np.pi * n / (N - 1))), 'M_w': 2}\n        }\n        \n        case_results = []\n\n        for name in ['rect', 'hann']:\n            params = window_params[name]\n            w = params['func']\n            M_w = params['M_w']\n            \n            # 应用窗函数\n            y = x * w\n            \n            # 计算 DFT 和功率谱\n            X_w = np.fft.fft(y)\n            P_w = np.abs(X_w)**2\n            \n            # --- 指标计算 ---\n            \n            def find_peak(k_est, P, search_radius=2):\n                \"\"\"在估计的频点周围寻找局部最大值的索引。\"\"\"\n                start = max(0, k_est - search_radius)\n                end = min(len(P), k_est + search_radius + 1)\n                \n                # 检查空的搜索范围\n                if start >= end:\n                    return k_est\n                \n                local_P = P[start:end]\n                local_max_idx = np.argmax(local_P)\n                return start + local_max_idx\n\n            # 估计初始频点位置\n            k1_est = int(np.round(f1 * N))\n            k2_est = int(np.round(f2 * N))\n            \n            # 修正正负频率的峰值位置\n            k1_p = find_peak(k1_est, P_w)\n            k2_p = find_peak(k2_est, P_w)\n            k1_n = find_peak((N - k1_est) % N, P_w)\n            k2_n = find_peak((N - k2_est) % N, P_w)\n            \n            # --- 频谱泄漏比 (LR) ---\n            \n            refined_peak_indices = {k1_p, k1_n, k2_p, k2_n}\n            main_lobe_indices = set()\n            for k_peak in refined_peak_indices:\n                for d in range(-M_w, M_w + 1):\n                    idx = k_peak + d\n                    if 0 = idx  N:\n                        main_lobe_indices.add(idx)\n\n            E_main = np.sum(P_w[list(main_lobe_indices)])\n            E_tot = np.sum(P_w)\n            \n            lr = (E_tot - E_main) / E_tot if E_tot > 0 else 0.0\n            \n            # --- 双音调可分辨性 (R) ---\n            \n            k_low = min(k1_p, k2_p)\n            k_high = max(k1_p, k2_p)\n            \n            resolved = False\n            # 检查峰值之间是否严格存在至少一个频点\n            if k_high > k_low + 1:\n                V = np.min(P_w[k_low + 1 : k_high])\n                P_weak = min(P_w[k_low], P_w[k_high])\n                alpha = 0.5\n                if P_weak > 0:\n                    if V  alpha * P_weak:\n                        resolved = True\n            \n            # 存储此窗函数的结果\n            case_results.extend([lr, resolved])\n\n        # 按指定顺序排列结果：LR(rect), LR(hann), R(rect), R(hann)\n        final_case_results = [case_results[0], case_results[2], case_results[1], case_results[3]]\n        all_results.append(final_case_results)\n\n    # 最终的打印语句采用确切的所需格式。\n    formatted_results = []\n    for res_list in all_results:\n        # 格式：浮点数，浮点数，布尔值，布尔值\n        r1 = f\"{res_list[0]:.6f}\"\n        r2 = f\"{res_list[1]:.6f}\"\n        r3 = str(res_list[2])\n        r4 = str(res_list[3])\n        formatted_results.append(f\"[{r1},{r2},{r3},{r4}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3222838"}]}