{"hands_on_practices": [{"introduction": "理论学习之后，最好的巩固方式莫过于亲自动手计算。二维离散小波变换（2D DWT）是图像压缩（如JPEG2000标准）等应用的核心技术，其基本原理是对图像的行和列分别应用一维变换。这个练习将指导你对一个小的 $4 \\times 4$ 图像矩阵进行手动哈尔小波变换，让你直观地感受图像是如何被分解为近似分量（LL）和不同方向的细节分量（LH, HL, HH）的。[@problem_id:3286415]", "problem": "考虑对由矩阵表示的小灰度图像进行二维（2D）离散小波变换（DWT），使用正交Haar小波\n$$\nX \\;=\\;\n\\begin{pmatrix}\n12  14  10  8 \\\\\n9  11  7  5 \\\\\n6  4  2  0 \\\\\n15  13  9  3\n\\end{pmatrix}.\n$$\n使用以下基本定义。对于一个长度为偶数的一维离散信号 $x$，第一级Haar变换通过与Haar尺度滤波器和小波滤波器进行卷积并进行$2$倍下采样来计算近似（低通）系数 $a_{k}$ 和细节（高通）系数 $d_{k}$：\n$$\nh = \\left[ \\frac{1}{\\sqrt{2}}, \\; \\frac{1}{\\sqrt{2}} \\right], \\qquad\ng = \\left[ \\frac{1}{\\sqrt{2}}, \\; -\\frac{1}{\\sqrt{2}} \\right],\n$$\n$$\na_{k} \\;=\\; \\sum_{n=0}^{1} h_{n} \\, x_{2k+n}, \\qquad\nd_{k} \\;=\\; \\sum_{n=0}^{1} g_{n} \\, x_{2k+n},\n$$\n其中 $k$ 是下采样后位置的索引。对于二维变换，首先对 $X$ 的每一行应用一维变换，每行产生长度为$2$的行低通和行高通输出。将这些输出排列成一个中间矩阵，其中左两列为行低通输出，右两列为行高通输出。然后，对左两列块的每一列和右两列块的每一列应用一维变换，同样进行$2$倍下采样。将四个子带定义如下：\n- $LL$：对左两列块（行低通）应用列低通滤波，\n- $LH$：对左两列块（行低通）应用列高通滤波，\n- $HL$：对右两列块（行高通）应用列低通滤波，\n- $HH$：对右两列块（行高通）应用列高通滤波。\n假设没有边界扩展；在这一级上，沿每行和每列将样本配对为 $\\{(0,1),(2,3)\\}$。手动计算 $X$ 的完整一级二维Haar DWT，并识别出 $LL$、$LH$、$HL$ 和 $HH$ 子带。然后，作为一个单一的标量总结，计算 $LL$ 子带的行列式。将最终答案表示为一个精确的整数，无需四舍五入。", "solution": "问题陈述经过严格验证，确认有效。这是一个数值方法中适定的问题，为使用Haar小波计算一级二维离散小波变换（DWT）提供了一套清晰完整的定义、数据和步骤。该问题具有科学依据，客观且内部一致。因此，我们可以开始求解。\n\n问题要求我们计算矩阵 $X$ 的一级二维Haar DWT，然后求出得到的低通/低通（$LL$）子带的行列式。\n\n给定的输入矩阵是：\n$$\nX \\;=\\;\n\\begin{pmatrix}\n12  14  10  8 \\\\\n9  11  7  5 \\\\\n6  4  2  0 \\\\\n15  13  9  3\n\\end{pmatrix}\n$$\n一维（1D）Haar变换由低通滤波器 $h = \\left[ \\frac{1}{\\sqrt{2}}, \\; \\frac{1}{\\sqrt{2}} \\right]$ 和高通滤波器 $g = \\left[ \\frac{1}{\\sqrt{2}}, \\; -\\frac{1}{\\sqrt{2}} \\right]$ 定义。对于一个4元素离散信号 $x = [x_0, x_1, x_2, x_3]$，近似系数（$a_k$）和细节系数（$d_k$）计算如下：\n$$\na_0 = \\frac{1}{\\sqrt{2}} (x_0 + x_1), \\quad a_1 = \\frac{1}{\\sqrt{2}} (x_2 + x_3)\n$$\n$$\nd_0 = \\frac{1}{\\sqrt{2}} (x_0 - x_1), \\quad d_1 = \\frac{1}{\\sqrt{2}} (x_2 - x_3)\n$$\n二维DWT是可分离执行的，首先沿行进行，然后沿列进行。\n\n步骤1：对 $X$ 的每一行应用一维DWT。\n每行的输出按 $[a_0, a_1, d_0, d_1]$ 排列。\n\n对于行1：$[12, 14, 10, 8]$\n$a_0 = \\frac{1}{\\sqrt{2}}(12+14) = \\frac{26}{\\sqrt{2}}$, $a_1 = \\frac{1}{\\sqrt{2}}(10+8) = \\frac{18}{\\sqrt{2}}$\n$d_0 = \\frac{1}{\\sqrt{2}}(12-14) = \\frac{-2}{\\sqrt{2}}$, $d_1 = \\frac{1}{\\sqrt{2}}(10-8) = \\frac{2}{\\sqrt{2}}$\n\n对于行2：$[9, 11, 7, 5]$\n$a_0 = \\frac{1}{\\sqrt{2}}(9+11) = \\frac{20}{\\sqrt{2}}$, $a_1 = \\frac{1}{\\sqrt{2}}(7+5) = \\frac{12}{\\sqrt{2}}$\n$d_0 = \\frac{1}{\\sqrt{2}}(9-11) = \\frac{-2}{\\sqrt{2}}$, $d_1 = \\frac{1}{\\sqrt{2}}(7-5) = \\frac{2}{\\sqrt{2}}$\n\n对于行3：$[6, 4, 2, 0]$\n$a_0 = \\frac{1}{\\sqrt{2}}(6+4) = \\frac{10}{\\sqrt{2}}$, $a_1 = \\frac{1}{\\sqrt{2}}(2+0) = \\frac{2}{\\sqrt{2}}$\n$d_0 = \\frac{1}{\\sqrt{2}}(6-4) = \\frac{2}{\\sqrt{2}}$, $d_1 = \\frac{1}{\\sqrt{2}}(2-0) = \\frac{2}{\\sqrt{2}}$\n\n对于行4：$[15, 13, 9, 3]$\n$a_0 = \\frac{1}{\\sqrt{2}}(15+13) = \\frac{28}{\\sqrt{2}}$, $a_1 = \\frac{1}{\\sqrt{2}}(9+3) = \\frac{12}{\\sqrt{2}}$\n$d_0 = \\frac{1}{\\sqrt{2}}(15-13) = \\frac{2}{\\sqrt{2}}$, $d_1 = \\frac{1}{\\sqrt{2}}(9-3) = \\frac{6}{\\sqrt{2}}$\n\n根据问题描述，我们将行低通输出（$a_0, a_1$）作为左两列，行高通输出（$d_0, d_1$）作为右两列，形成一个中间矩阵，我们称之为 $Y$：\n$$\nY \\;=\\;\n\\frac{1}{\\sqrt{2}}\n\\begin{pmatrix}\n26  18  -2  2 \\\\\n20  12  -2  2 \\\\\n10  2    2  2 \\\\\n28  12   2  6\n\\end{pmatrix}\n$$\n\n步骤2：对 $Y$ 的每一列应用一维DWT。\n变换应用于每个列向量，得到的近似系数构成最终列的上半部分，而细节系数构成下半部分。我们先对未缩放的矩阵部分进行此操作，最后再应用总的缩放因子 $\\frac{1}{\\sqrt{2}} \\times \\frac{1}{\\sqrt{2}} = \\frac{1}{2}$。\n\n对于 $\\sqrt{2}Y$ 的第1列：$[26, 20, 10, 28]$\n$a_0 = \\frac{1}{\\sqrt{2}}(26+20) = \\frac{46}{\\sqrt{2}}$, $a_1 = \\frac{1}{\\sqrt{2}}(10+28) = \\frac{38}{\\sqrt{2}}$\n$d_0 = \\frac{1}{\\sqrt{2}}(26-20) = \\frac{6}{\\sqrt{2}}$, $d_1 = \\frac{1}{\\sqrt{2}}(10-28) = \\frac{-18}{\\sqrt{2}}$\n\n对于 $\\sqrt{2}Y$ 的第2列：$[18, 12, 2, 12]$\n$a_0 = \\frac{1}{\\sqrt{2}}(18+12) = \\frac{30}{\\sqrt{2}}$, $a_1 = \\frac{1}{\\sqrt{2}}(2+12) = \\frac{14}{\\sqrt{2}}$\n$d_0 = \\frac{1}{\\sqrt{2}}(18-12) = \\frac{6}{\\sqrt{2}}$, $d_1 = \\frac{1}{\\sqrt{2}}(2-12) = \\frac{-10}{\\sqrt{2}}$\n\n对于 $\\sqrt{2}Y$ 的第3列：$[-2, -2, 2, 2]$\n$a_0 = \\frac{1}{\\sqrt{2}}(-2-2) = \\frac{-4}{\\sqrt{2}}$, $a_1 = \\frac{1}{\\sqrt{2}}(2+2) = \\frac{4}{\\sqrt{2}}$\n$d_0 = \\frac{1}{\\sqrt{2}}(-2-(-2)) = 0$, $d_1 = \\frac{1}{\\sqrt{2}}(2-2) = 0$\n\n对于 $\\sqrt{2}Y$ 的第4列：$[2, 2, 2, 6]$\n$a_0 = \\frac{1}{\\sqrt{2}}(2+2) = \\frac{4}{\\sqrt{2}}$, $a_1 = \\frac{1}{\\sqrt{2}}(2+6) = \\frac{8}{\\sqrt{2}}$\n$d_0 = \\frac{1}{\\sqrt{2}}(2-2) = 0$, $d_1 = \\frac{1}{\\sqrt{2}}(2-6) = \\frac{-4}{\\sqrt{2}}$\n\n步骤3：组合最终的变换矩阵 $W$ 并识别子带。\n将这些列组合起来，并应用总的归一化因子 $\\frac{1}{2}$，得到最终矩阵 $W$。\n$$\nW = \\frac{1}{2}\n\\begin{pmatrix}\n46  30  -4  4 \\\\\n38  14  4  8 \\\\\n6  6  0  0 \\\\\n-18  -10  0  -4\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n23  15  -2  2 \\\\\n19  7  2  4 \\\\\n3  3  0  0 \\\\\n-9  -5  0  -2\n\\end{pmatrix}\n$$\n根据操作顺序，可以识别出四个 $2 \\times 2$ 的子带：\n- $LL$（左上）：行低通，然后列低通。\n- $LH$（左下）：行低通，然后列高通。\n- $HL$（右上）：行高通，然后列低通。\n- $HH$（右下）：行高通，然后列高通。\n\n因此，$LL$ 子带是 $W$ 的左上角 $2 \\times 2$ 块：\n$$\nLL \\;=\\;\n\\begin{pmatrix}\n23  15 \\\\\n19  7\n\\end{pmatrix}\n$$\n\n步骤4：计算 $LL$ 子带的行列式。\n一个 $2 \\times 2$ 矩阵 $\\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix}$ 的行列式是 $ad - bc$。\n$$\n\\det(LL) = (23)(7) - (15)(19)\n$$\n$$\n\\det(LL) = 161 - 285\n$$\n$$\n\\det(LL) = -124\n$$\n$LL$ 子带的行列式恰好为 $-124$。", "answer": "$$\\boxed{-124}$$", "id": "3286415"}, {"introduction": "理解了小波变换的基本计算步骤后，下一步是思考如何在计算机上高效地实现它。快速小波变换（FWT）正是实现离散小波变换的标准高效算法，其计算复杂度为 $O(N)$。在这个实践中，你将通过编写递归和迭代两种方式的FWT算法，不仅能加深对变换背后递归结构的理解，还能体会到算法设计与性能分析在科学计算中的重要性。[@problem_id:3286474]", "problem": "设 $N$ 是2的幂，即 $N = 2^J$，其中整数 $J \\geq 1$。考虑在一维空间 $L^2(\\mathbb{R})$ 上，由一个尺度函数 $\\phi$ 及其关联的小波函数 $\\psi$ 生成的多分辨率分析（MRA）所构建的一维离散小波变换（DWT）。在一个标准正交MRA中，空间 $V_j$ 满足 $V_j \\subset V_{j+1}$、$\\bigcap_j V_j = \\{0\\}$ 和 $\\overline{\\bigcup_j V_j} = L^2(\\mathbb{R})$，并且双尺度关系对 $\\phi$ 和 $\\psi$ 成立。在整数点上采样有限长度信号 $x[n]$，并通过分析滤波器组对其进行处理，是计算DWT的标准方法。对于Haar（Daubechies-1）小波，尺度函数 $\\phi$ 是区间 $[0,1)$ 上的指示函数，其相关的分析滤波器以其短且正交而著称。\n\n任务：以两种方式实现Haar小波的快速小波变换（FWT）：递归版本和迭代版本。两种实现都必须是原地变换，将一个实值输入向量 $x \\in \\mathbb{R}^N$ 映射到一个小波系数向量。该向量的排列方式为：首先是尺度 $J$ 的粗略近似系数，其后是尺度从 $J$ 到 $1$ 的细节系数，按连续块排列。通过计算执行的原始算术运算次数来确定性地量化性能。其中，原始算术运算定义为单次加法或减法（共同计为一个类别，称为“add”），以及单次乘法（单独计为“mult”）。您必须对两种实现进行插桩，以计算其原始算术运算次数并报告这些计数。\n\n用于推导和验证正确性的基本依据包括：标准正交MRA的定义、$\\phi$ 和 $\\psi$ 的双尺度关系，以及DWT的滤波器组解释（与分析滤波器进行卷积，然后进行二进下采样）。当出现三角函数时，角度必须以弧度为单位。本问题不涉及物理单位。\n\n测试套件规范：\n-   案例 A（正常路径）：$N = 2^3 = 8$。信号为 $x[n] = \\sin\\left(2\\pi n / N\\right)$，其中 $n = 0,1,\\dots,N-1$，角度以弧度为单位。\n-   案例 B（大 $N$）：$N = 2^{10} = 1024$。信号是使用固定种子 $0$ 从 $[-1,1]$ 均匀抽取的伪随机向量，以保证可复现性。\n-   案例 C（边界长度）：$N = 2^1 = 2$。信号为 $x = [1.0, -1.0]$。\n-   案例 D（边缘信号）：$N = 2^4 = 16$。信号为零向量。\n\n对于每个测试案例，使用递归实现和迭代实现计算前向FWT。对于每个案例，生成：\n1.  一个布尔值，表示两个系数向量是否逐元素完全相等。\n2.  一个浮点数，等于两个系数向量之间的最大绝对差。\n3.  一个整数，等于递归实现中计数的“add”运算次数。\n4.  一个整数，等于递归实现中计数的“mult”运算次数。\n5.  一个整数，等于迭代实现中计数的“add”运算次数。\n6.  一个整数，等于迭代实现中计数的“mult”运算次数。\n\n您的程序应生成单行输出，包含一个由逗号分隔的列表，并用方括号括起来。其中每个元素对应一个测试案例，并且本身是按上述顺序排列的列表。例如，输出格式必须完全如下：\n\"[[boolean_A,float_A,int_A1,int_A2,int_A3,int_A4],[boolean_B,float_B,int_B1,int_B2,int_B3,int_B4],[boolean_C,float_C,int_C1,int_C2,int_C3,int_C4],[boolean_D,float_D,int_D1,int_D2,int_D3,int_D4]]\"。", "solution": "该问题要求实现Haar小波的快速小波变换（FWT）并进行性能分析。需要实现递归和迭代两个版本。两者都必须对输入向量 $x \\in \\mathbb{R}^N$（其中 $N=2^J$）执行原地变换，并且必须计算其原始算术运算（加/减法和乘法）的次数。\n\n**1. 理论基础：Haar FWT**\n\n一维离散小波变换（DWT）将信号分解为近似系数和细节系数。对于基于标准正交多分辨率分析（MRA）的Haar小波，其分析过程使用一个低通滤波器 $h$ 和一个高通滤波器 $g$。归一化Haar小波的系数为：\n$$\nh = \\left[\\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}\\right]\n$$\n$$\ng = \\left[\\frac{1}{\\sqrt{2}}, -\\frac{1}{\\sqrt{2}}\\right]\n$$\n单级DWT将一个长度为 $M$ 的近似系数向量 $c_j$ 转换为一个长度为 $M/2$ 的近似系数向量 $c_{j-1}$ 和一个长度为 $M/2$ 的细节系数向量 $d_{j-1}$。对于一对输入值 $(c_j[2k], c_j[2k+1])$，变换如下：\n$$\nc_{j-1}[k] = \\frac{c_j[2k] + c_j[2k+1]}{\\sqrt{2}}\n$$\n$$\nd_{j-1}[k] = \\frac{c_j[2k] - c_j[2k+1]}{\\sqrt{2}}\n$$\n快速小波变换（FWT）是一种高效的算法，它递归地应用这种分解。从长度为 $N=2^J$ 的输入信号 $x$ 开始，FWT首先计算整个信号的近似系数和细节系数。细节系数被存储起来，然后对近似系数重复此过程。这个过程持续 $J = \\log_2(N)$ 级，直到只剩下一个近似系数为止。\n\n对于原地变换，系数在原始向量内部被重新排列。一种标准的排列方式是将新的近似系数放在正在处理的子数组的前半部分，将细节系数放在后半部分。经过 $J$ 级变换后，长度为 $N$ 的输入向量 $x$ 被替换为小波系数，其组织方式为：$[c_0, d_0, d_1, \\dots, d_{J-1}]$，其中 $c_0$ 是最终的单个近似系数， $d_0$ 是最后一级分解得到的单个细节系数， $d_1$ 是倒数第二级得到的包含2个细节系数的块，依此类推，直到 $d_{J-1}$，它是第一级得到的包含 $N/2$ 个细节系数的块。\n\n**2. 算法设计与运算计数**\n\n为了在不损坏数据的情况下正确实现原地变换，需要临时存储空间。对于一个大小为 $M$ 的子问题，我们可以使用一个大小为 $M/2$ 的临时数组来存储新的近似系数，同时用细节系数覆盖原始子数组的后半部分。\n\n可以在每一步计算原始算术运算的次数。对于每对输入值 $(a, b)$：\n- 计算 $(a+b)/\\sqrt{2}$ 涉及1次加法和1次乘法（乘以 $1/\\sqrt{2}$）。\n- 计算 $(a-b)/\\sqrt{2}$ 涉及1次减法和1次乘法。\n\n因此，对于一个长度为 $M$ 的子数组（包含 $M/2$ 对），一级变换执行 $M/2 \\times (1 \\text{ 次加法} + 1 \\text{ 次减法}) = M$ 次“add”运算，以及 $M/2 \\times (1 \\text{ 次乘法} + 1 \\text{ 次乘法}) = M$ 次“mult”运算。\n由于变换应用于尺寸递减的数组 $N, N/2, N/4, \\dots, 2$，对长度为 $N$ 的向量进行完整FWT的总运算次数为：\n$$\n\\text{总加法次数} = \\sum_{k=1}^{J} \\frac{N}{2^{k-1}} = N \\sum_{i=0}^{J-1} \\left(\\frac{1}{2}\\right)^i = N \\frac{1 - (1/2)^J}{1 - 1/2} = 2N(1 - 1/N) = 2(N-1)\n$$\n总乘法次数也为 $2(N-1)$。这个理论计数可用于验证插桩实现的正确性。\n\n**3. 实现：递归与迭代**\n\n**递归实现 (`fwt_recursive`):**\n定义一个辅助函数 `_fwt_recursive_helper`，对输入数组的视图进行操作。\n- **基本情况：** 如果数组长度为1或更小，递归终止。\n- **递归步骤：** 对于长度为 $n$ 的数组，它使用一个大小为 $n/2$ 的临时数组来计算一级的变换以获得近似系数。在用当前级别的近似和细节系数更新输入数组后，它对数组的前半部分（现在包含新的近似系数）进行递归调用。\n\n**迭代实现 (`fwt_iterative`):**\n此版本使用 `while` 循环代替递归。\n- 一个变量 `m` 跟踪当前待变换子数组的大小，初始化为 $N$。\n- 循环只要 `m > 1` 就继续。\n- 在循环内部，对子数组 `signal[:m]` 应用一级Haar FWT，使用与递归步骤相同的逻辑和临时存储。\n- 每次迭代后，`m` 减半，使下一次变换集中在新的、更小的近似系数块上。\n\n两种实现都旨在执行完全相同的算术运算序列，确保它们的数值输出和运算计数将是相同的。在每个主函数的开头创建输入信号的副本，以确保原始测试数据不被修改，并且每个函数都在相同的输入上操作。\n\n**4. 测试案例与验证**\n\n针对四个指定的案例（正弦波、随机、简单对和零向量）对实现进行测试。对每个案例，生成以下输出：\n1.  来自 `np.array_equal` 的布尔值，比较递归和迭代方法得到的最终系数向量。\n2.  使用 `np.max(np.abs(res_rec - res_iter))` 计算的两个系数向量之间的最大绝对差。\n3.  递归方法的“add”运算计数。\n4.  递归方法的“mult”运算计数。\n5.  迭代方法的“add”运算计数。\n6.  迭代方法的“mult”运算计数。\n\n结果被格式化为一个列表的列表，然后转换为所需的紧凑字符串格式作为最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _fwt_recursive_helper(arr_view, counts, inv_sqrt2):\n    \"\"\"\n    Helper function for the recursive FWT. Operates in-place on a numpy array view.\n    \"\"\"\n    n = len(arr_view)\n    if n == 1:\n        return\n\n    half = n // 2\n    \n    # Use temporary storage for the approximation coefficients to allow in-place\n    # calculation without overwriting data needed for detail coefficients.\n    apx_temp = np.empty(half, dtype=float)\n\n    for i in range(half):\n        a = arr_view[2 * i]\n        b = arr_view[2 * i + 1]\n        \n        # Approximation coefficient\n        apx_temp[i] = (a + b) * inv_sqrt2\n        counts['add'] += 1\n        counts['mult'] += 1\n        \n        # Detail coefficient (placed in the second half of the current view)\n        arr_view[i + half] = (a - b) * inv_sqrt2\n        counts['add'] += 1\n        counts['mult'] += 1\n\n    # Copy the new approximation coefficients to the first half of the view\n    arr_view[:half] = apx_temp\n    \n    # Recurse on the first half (the new approximation coefficients)\n    _fwt_recursive_helper(arr_view[:half], counts, inv_sqrt2)\n\ndef fwt_recursive(x):\n    \"\"\"\n    Computes the forward Fast Wavelet Transform (FWT) for the Haar wavelet\n    using a recursive approach.\n    \n    Returns the transformed signal and counts of arithmetic operations.\n    \"\"\"\n    counts = {'add': 0, 'mult': 0}\n    signal = x.copy()\n    inv_sqrt2 = 1.0 / np.sqrt(2.0)\n    _fwt_recursive_helper(signal, counts, inv_sqrt2)\n    return signal, counts['add'], counts['mult']\n\ndef fwt_iterative(x):\n    \"\"\"\n    Computes the forward Fast Wavelet Transform (FWT) for the Haar wavelet\n    using an iterative approach.\n\n    Returns the transformed signal and counts of arithmetic operations.\n    \"\"\"\n    counts = {'add': 0, 'mult': 0}\n    signal = x.copy()\n    n = len(signal)\n    \n    inv_sqrt2 = 1.0 / np.sqrt(2.0)\n    \n    m = n\n    while m > 1:\n        half_m = m // 2\n        \n        apx_temp = np.empty(half_m, dtype=float)\n\n        # Process the current active part of the signal, signal[:m]\n        for i in range(half_m):\n            a = signal[2 * i]\n            b = signal[2 * i + 1]\n            \n            # Approximation coefficient\n            apx_temp[i] = (a + b) * inv_sqrt2\n            counts['add'] += 1\n            counts['mult'] += 1\n            \n            # Detail coefficient\n            signal[i + half_m] = (a - b) * inv_sqrt2\n            counts['add'] += 1\n            counts['mult'] += 1\n        \n        # Copy approximation coefficients to the first half\n        signal[:half_m] = apx_temp\n        \n        m = half_m\n    \n    return signal, counts['add'], counts['mult']\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs the FWT implementations, and formats the output.\n    \"\"\"\n    # Define test cases\n    # Case A: Happy path\n    N_A = 8\n    x_A = np.sin(2 * np.pi * np.arange(N_A) / N_A)\n\n    # Case B: Large N\n    N_B = 1024\n    rng_B = np.random.default_rng(seed=0)\n    x_B = rng_B.uniform(-1.0, 1.0, N_B)\n\n    # Case C: Boundary length\n    N_C = 2\n    x_C = np.array([1.0, -1.0])\n\n    # Case D: Edge signal (zero vector)\n    N_D = 16\n    x_D = np.zeros(N_D)\n    \n    test_cases = [x_A, x_B, x_C, x_D]\n    \n    all_results = []\n    \n    for x in test_cases:\n        # Run recursive implementation\n        rec_res, rec_adds, rec_muls = fwt_recursive(x)\n        \n        # Run iterative implementation\n        iter_res, iter_adds, iter_muls = fwt_iterative(x)\n        \n        # Compare results\n        are_equal = np.array_equal(rec_res, iter_res)\n        max_diff = np.max(np.abs(rec_res - iter_res))\n        \n        case_result = [\n            are_equal,\n            float(max_diff),\n            rec_adds,\n            rec_muls,\n            iter_adds,\n            iter_muls\n        ]\n        all_results.append(case_result)\n\n    # Format the final output string exactly as required\n    case_strings = []\n    for case_res in all_results:\n        # str(list) adds spaces, which are forbidden.\n        # Create the comma-separated string manually.\n        str_items = []\n        for item in case_res:\n            if isinstance(item, bool):\n                # Python's bool __str__ is 'True'/'False'. Required format is not specified\n                # as lowercase, so this is correct.\n                str_items.append(str(item)) \n            else:\n                str_items.append(str(item))\n        case_strings.append(f\"[{','.join(str_items)}]\")\n        \n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3286474"}, {"introduction": "掌握了如何计算DWT之后，一个更深层次的问题是：我们为什么以及如何选择特定的小波？这个练习旨在揭示小波变换最强大的特性之一——基相关稀疏性，即一个合适的小波基能用极少数的非零系数来精确表示一个信号。通过构建一个在哈尔小波基下是稀疏的、但在另一个小波基（如Daubechies-4）下却是稠密的信号，你将获得关于小波压缩和去噪背后核心原理的宝贵实践经验。[@problem_id:3286372]", "problem": "您需要实现并使用一维正交离散小波变换（DWT），以设计和评估在某个小波基中稀疏但在另一个小波基中稠密的信号。所有工作应在离散时间域内对有限周期信号进行。您只能依赖以下基本事实：(i) 一个正交小波基由母小波的伸缩和平移生成，并产生一个正交变换；(ii) 根据Parseval恒等式，正交变换保持能量；(iii) 正交DWT可以通过一个双通道完美重构滤波器组计算，该滤波器组使用由一个低通分析滤波器和一个高通分析滤波器组成的“正交镜像滤波器”（QMF）对，其相应的重构滤波器通过对分析滤波器进行时间反转得到。您不得使用任何外部小波库。\n\n定义与假设：\n- 设信号为一个长度为 $N$ 的实数向量，具有周期性边界条件。\n- 设分解层数为 $L = \\log_2 N$，假设 $N$ 是2的幂。\n- 令 $h[n]$ 表示低通分析滤波器，$g[n]$ 表示高通分析滤波器，它们构成一个正交镜像滤波器（QMF）对。对于正交小波，$g[n] = (-1)^n h[L_f - 1 - n]$，其中 $L_f$ 是滤波器长度，重构滤波器为 $h_r[n] = h[L_f - 1 - n]$ 和 $g_r[n] = g[L_f - 1 - n]$。\n- 对于Haar小波（也称为Daubechies-1），使用 $h = \\left[\\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}\\right]$ 和 $g = \\left[\\frac{1}{\\sqrt{2}}, -\\frac{1}{\\sqrt{2}}\\right]$。\n- 对于Daubechies-4小波（具有4个消失矩，滤波器长度为8），使用以下低通分析滤波器系数\n$$\nh = \\big[-0.010597401785069032,\\; 0.0328830116668852,\\; 0.030841381835986965,\\; -0.18703481171888114,\\; -0.027983769416859854,\\; 0.6308807679298589,\\; 0.7148465705529154,\\; 0.23037781330885523\\big],\n$$\n并定义 $g[n] = (-1)^n h[7 - n]$。\n- 第$\\ell$层细节子带的长度为 $N / 2^\\ell$（其中 $\\ell \\in \\{1,2,\\dots,L\\}$），当$N$是2的幂时，第$L$层近似子带的长度为 $N / 2^L = 1$。\n\n在给定层级的DWT分析步骤：给定一个长度为$M$的信号$x[n]$，通过以下公式计算长度为$M/2$的近似$a[n]$和细节$d[n]$\n$$\na[n] = \\sum_{k=0}^{L_f-1} h[k]\\; x[(2n + k) \\bmod M],\\quad\nd[n] = \\sum_{k=0}^{L_f-1} g[k]\\; x[(2n + k) \\bmod M].\n$$\n对近似输出迭代此分裂过程$L$层，以获得细节带 $\\{d_1, d_2, \\dots, d_L\\}$ 和最终的粗略近似 $a_L$。\n\n逆DWT合成步骤：给定长度为$M$的$a[n]$和$d[n]$，通过在样本之间插入零来进行上采样，然后与重构滤波器$h_r$和$g_r$进行周期性卷积，并将结果相加，以重构出长度为$2M$的下一层更精细的信号。\n\n您的任务：\n1. 使用上述滤波器，为Haar和Daubechies-4小波实现具有周期性边界条件的正交DWT分析和合成。当$N$是2的幂时，您的实现必须能处理恰好$L = \\log_2 N$层。\n2. 定义能量捕获率为$p$时的稀疏度度量：给定一个总能量为$E = \\sum_i c_i^2$的系数向量$c$，令$k(p)$为最小整数，使得$k(p)$个最大平方幅值系数之和至少为$p E$。您必须通过将平方幅值按降序排序并累加直至达到阈值来计算$k(p)$。\n3. 构建以下四个长度为$N$的测试信号，并使用$p = 0.99$在Haar和Daubechies-4两种基中评估它们的稀疏度：\n   - 测试 A：$N = 256$。单个Haar细节原子：为Haar基构建DWT系数数组，其中除第3层位置5的单个细节系数设置为幅度1.0外，所有其他频带均为零，然后通过在Haar基中进行逆DWT来合成信号。\n   - 测试 B：$N = 256$。两个Haar细节原子之和：与测试A类似，但有两个非零系数，一个在第2层，位置17，幅度2.0；另一个在第5层，位置3，幅度-1.0。通过在Haar基中进行逆DWT来合成。\n   - 测试 C：$N = 256$。单个Daubechies-4细节原子：为Daubechies-4基构建DWT系数数组，其中除第4层位置11的单个细节系数设置为幅度1.0外，所有其他频带均为零，然后通过在Daubechies-4基中进行逆DWT来合成信号。\n   - 测试 D：$N = 32$。单位冲激信号：在索引0处$x[n] = 1$，其他位置$x[n] = 0$。\n4. 对于每个测试信号，使用Haar DWT计算$k_{\\text{Haar}}(p)$，使用Daubechies-4 DWT计算$k_{\\text{Db4}}(p)$，并计算比率$r = k_{\\text{Db4}}(p) / k_{\\text{Haar}}(p)$。\n5. 最终输出格式：您的程序应生成单行输出，包含测试A、B、C和D的结果（按此顺序），形式为一个包含四个列表的逗号分隔列表，每个内部列表的形式为 $[k_{\\text{Haar}}, k_{\\text{Db4}}, r]$，并用方括号括起来。例如，打印的行必须看起来像 $[\\,[k_{A,\\text{Haar}},k_{A,\\text{Db4}},r_A],[k_{B,\\text{Haar}},k_{B,\\text{Db4}},r_B],[k_{C,\\text{Haar}},k_{C,\\text{Db4}},r_C],[k_{D,\\text{Haar}},k_{D,\\text{Db4}},r_D]\\,]$，所有条目均为整数或浮点数。不应打印任何额外文本。\n\n关于科学原理的说明：\n- 因为Haar小波是分段常数函数，具有长度为2的紧支撑，所以在固定层级合成的单个Haar小波原子在Haar基中是精确稀疏的（只有一个非零系数），但在更平滑、支撑更长的基（如Daubechies-4）中，它通常会分散到许多系数上，从而在该基中变得稠密。\n- 反之，单个Daubechies-4原子在Daubechies-4基中是精确稀疏的，但在Haar基中是稠密的。\n- 冲激信号说明了局部不连续性如何与滤波器支撑长度相互作用。\n- 由于正交变换下的能量守恒，跨基比较$k(p)$是有意义的。", "solution": "我们从核心原理出发：一个正交小波系统为$L^2$（在离散有限长度设置中为$\\mathbb{R}^N$）提供了一个正交基，这确保了由与基元素做内积定义的离散小波变换（DWT）是一个正交变换。对于任何正交变换$T$，Parseval恒等式给出了能量守恒，即 $\\|x\\|_2^2 = \\|Tx\\|_2^2$。这一事实允许我们使用系数能量分布来定义一个在指定捕获水平下与基无关的稀疏性概念。\n\n为了高效计算DWT，我们使用一个具有分析和合成阶段的双通道完美重构滤波器组。令$h[n]$为低通分析滤波器，$g[n]$为高通分析滤波器。在每个层级，我们通过将输入分别与$h$和$g$进行周期性卷积，然后以因子2进行下采样，来计算近似系数$a[n]$和细节系数$d[n]$。形式上，对于一个长度为$M$的输入$x[n]$，\n$$\na[n] = \\sum_{k=0}^{L_f-1} h[k]\\; x[(2n + k) \\bmod M], \\quad\nd[n] = \\sum_{k=0}^{L_f-1} g[k]\\; x[(2n + k) \\bmod M],\n$$\n其中$L_f$是滤波器长度，周期性边界条件通过模索引强制执行。对近似输出迭代此过程，会产生细节带$\\{d_1, d_2, \\dots, d_L\\}$和最终近似$a_L$，其中对于$N=2^L$有$L=\\log_2 N$个层级。\n\n对于合成，我们通过对近似和细节序列进行上采样（在样本间插入零），然后与时间反转的分析滤波器进行周期性卷积并求和，来反转一个层级。对于正交小波，合成低通滤波器是 $h_r[n] = h[L_f - 1 - n]$，合成高通滤波器是 $g_r[n] = g[L_f - 1 - n]$。如果$a[n]$和$d[n]$的长度为$M$，则通过以下方式定义长度为$2M$的上采样序列$\\tilde{a}[m]$和$\\tilde{d}[m]$：\n$$\n\\tilde{a}[2n] = a[n],\\ \\tilde{a}[2n+1] = 0,\\quad\n\\tilde{d}[2n] = d[n],\\ \\tilde{d}[2n+1] = 0,\n$$\n并计算重构信号：\n$$\nx[n] = \\sum_{k=0}^{L_f-1} h_r[k]\\; \\tilde{a}[(n - k) \\bmod 2M] + \\sum_{k=0}^{L_f-1} g_r[k]\\; \\tilde{d}[(n - k) \\bmod 2M].\n$$\n从第$L$层向上迭代至第1层，可重构出长度为$N$的信号。这些公式实现了一个具有周期性边界的完美重构正交DWT。\n\n对于Haar小波（Daubechies-1），低通分析滤波器为 $h = \\left[\\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}\\right]$，高通分析滤波器为 $g = \\left[\\frac{1}{\\sqrt{2}}, -\\frac{1}{\\sqrt{2}}\\right]$。对于Daubechies-4小波，低通分析滤波器为\n$$\nh = \\big[-0.010597401785069032,\\; 0.0328830116668852,\\; 0.030841381835986965,\\; -0.18703481171888114,\\; -0.027983769416859854,\\; 0.6308807679298589,\\; 0.7148465705529154,\\; 0.23037781330885523\\big],\n$$\n根据正交镜像滤波器的构造，高通分析滤波器为\n$$\ng[n] = (-1)^n h[7 - n]\\quad \\text{for}\\ n=0,1,\\dots,7.\n$$\n两种小波对应的合成滤波器是时间反转后的 $h_r[n] = h[7 - n]$ 和 $g_r[n] = g[7 - n]$（对于滤波器长度为2的Haar情况，则是 $h_r[n] = h[1 - n]$ 和 $g_r[n] = g[1 - n]$）。变换的正交性确保了精确的能量守恒。\n\n通过从一个基中合成单个原子，然后在两个基中对其进行分析，可以保证构造出一个在一个基中稀疏而在另一个基中稠密的信号。具体来说，如果我们通过将Haar基中所有DWT系数设为零，除了在选定层级和位置的一个细节系数外，那么根据线性和正交性，这个信号就等于一个单一的Haar小波原子。在Haar基中，其分析系数将在相同位置和层级有且仅有一个非零项（不计浮点舍入误差），因此只要数值噪声可忽略不计，在任何$p \\le 1$下的稀疏度度量$k(p)$都将是1。然而，在Daubechies-4基中，同一个信号不再是单个基元素，由于平滑度和滤波器支撑的不匹配，其表示将分散到许多系数上，从而增加了$k(p)$。如果我们合成一个单一的Daubechies-4原子，则情况相反。\n\n我们如下定义能量捕获率为$p$的稀疏度度量。令$c \\in \\mathbb{R}^N$为通过连接所有细节带和最终近似值得到的所有DWT系数的向量。令 $E = \\sum_{i=1}^N c_i^2$。将平方幅值$\\{|c_i|^2\\}$按降序排序，得到序列$\\{s_1 \\ge s_2 \\ge \\dots \\ge s_N\\}$。定义\n$$\nk(p) = \\min\\left\\{k \\in \\{1,2,\\dots,N\\} : \\sum_{i=1}^k s_i \\ge p\\, E \\right\\}.\n$$\n由于能量守恒，$E$对于同一信号的任何正交基表示都是相同的，这使得$k(p)$的跨基比较有意义。\n\n代码中实现的算法规划：\n1. 实现周期性卷积和分析步骤，为Haar和Daubechies-4滤波器在从1到$L$的每个层级$\\ell$计算$(a_\\ell, d_\\ell)$。\n2. 实现逆步骤，通过上采样和与重构滤波器进行周期性卷积，从$(a_\\ell, d_\\ell)$重构信号，迭代从$\\ell=L$到$\\ell=1$。\n3. 实现系数的打包和解包，以便从给定的系数（除了特定的细节项外全为零）合成信号，并将系数展平为单个向量用于稀疏度评估。\n4. 实现稀疏度度量$k(p)$，通过对平方幅值进行排序并累加，直到达到阈值$p E$。\n5. 构建四个测试信号：\n   - 测试 A：$N = 256$，在第3层，位置5，幅度为1.0的Haar原子。\n   - 测试 B：$N = 256$，两个Haar原子之和：第2层，位置17，幅度2.0；以及第5层，位置3，幅度-1.0。\n   - 测试 C：$N = 256$，在第4层，位置11，幅度为1.0的Daubechies-4原子。\n   - 测试 D：$N = 32$，在索引0处，幅度为1.0的冲激信号。\n6. 对于每个测试，使用$p=0.99$计算$k_{\\text{Haar}}(p)$和$k_{\\text{Db4}}(p)$，以及比率$r = k_{\\text{Db4}}(p)/k_{\\text{Haar}}(p)$。\n7. 按照 $[\\,[k_{\\text{Haar}},k_{\\text{Db4}},r],\\dots]$ 的格式将四个测试的结果打印为单行，不包含任何额外文本。\n\n这为什么能证明所要求的现象：一个合成为单个Haar原子的信号在Haar基中是精确稀疏的（一个显著系数），但由于Daubechies-4小波更平滑且支撑更长，同一个信号会投影到许多Daubechies-4基函数上，需要更大的$k(0.99)$来捕获相同比例的能量。反之，单个Daubechies-4原子在它自己的基中是稀疏的，但在Haar基中是稠密的。冲激信号高度局部化且不连续，通常在较长的滤波器中产生更广泛的扩散，这说明了滤波器支撑长度的影响。所有计算都依赖于正交性、滤波器组的完美重构和能量守恒，确保$k(p)$的差异反映了基相关的稀疏性，而不是数值伪影。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef qmf_highpass_from_lowpass(h):\n    # g[n] = (-1)^n h[L-1-n]\n    L = len(h)\n    g = np.array([((-1)**n) * h[L - 1 - n] for n in range(L)], dtype=float)\n    return g\n\ndef analysis_step(x, h, g):\n    # One-level analysis with periodic boundary, downsampling by 2\n    N = len(x)\n    Lf = len(h)\n    M = N // 2\n    a = np.zeros(M, dtype=float)\n    d = np.zeros(M, dtype=float)\n    for n in range(M):\n        s_a = 0.0\n        s_d = 0.0\n        base = 2 * n\n        for k in range(Lf):\n            idx = (base + k) % N\n            xv = x[idx]\n            s_a += h[k] * xv\n            s_d += g[k] * xv\n        a[n] = s_a\n        d[n] = s_d\n    return a, d\n\ndef synthesis_step(a, d, hr, gr):\n    # One-level synthesis with periodic boundary from a,d (length M) to x (length 2M)\n    M = len(a)\n    N = 2 * M\n    Lf = len(hr)\n    up_a = np.zeros(N, dtype=float)\n    up_d = np.zeros(N, dtype=float)\n    up_a[::2] = a\n    up_d[::2] = d\n    # Periodic convolution\n    x = np.zeros(N, dtype=float)\n    for n in range(N):\n        s = 0.0\n        for k in range(Lf):\n            idx = (n - k) % N\n            s += hr[k] * up_a[idx] + gr[k] * up_d[idx]\n        x[n] = s\n    return x\n\ndef dwt(x, h, g, levels):\n    # Full multilevel analysis\n    a = x.copy()\n    details = []\n    for _ in range(levels):\n        a, d = analysis_step(a, h, g)\n        details.append(d)\n    # details[0] is level-1, ..., details[L-1] is level-L\n    return a, details\n\ndef idwt(aL, details, hr, gr):\n    # Full multilevel synthesis\n    a = aL.copy()\n    # details are [d1, d2, ..., dL]\n    for lev in range(len(details)-1, -1, -1):\n        d = details[lev]\n        a = synthesis_step(a, d, hr, gr)\n    return a\n\ndef flatten_coeffs(aL, details):\n    # Concatenate all detail bands followed by final approx\n    # Order: d1, d2, ..., dL, aL\n    parts = []\n    for d in details:\n        parts.append(d.ravel())\n    parts.append(np.array([aL]).ravel()) if np.ndim(aL) == 0 else parts.append(aL.ravel())\n    return np.concatenate(parts)\n\ndef energy_capture_k(coeffs, p):\n    # coeffs is 1D array of all coefficients\n    magsq = coeffs**2\n    total = float(np.sum(magsq))\n    if total == 0.0:\n        return 0\n    magsq_sorted = -np.sort(-magsq)  # descending\n    cumsum = np.cumsum(magsq_sorted)\n    threshold = p * total\n    k = int(np.searchsorted(cumsum, threshold, side='left')) + 1\n    # Cap at length\n    if k > len(coeffs):\n        k = len(coeffs)\n    return k\n\ndef haar_filters():\n    inv_sqrt2 = 1.0 / np.sqrt(2.0)\n    h = np.array([inv_sqrt2, inv_sqrt2], dtype=float)\n    g = np.array([inv_sqrt2, -inv_sqrt2], dtype=float)\n    return h, g\n\ndef db4_filters():\n    h = np.array([\n        -0.010597401785069032,\n         0.0328830116668852,\n         0.030841381835986965,\n        -0.18703481171888114,\n        -0.027983769416859854,\n         0.6308807679298589,\n         0.7148465705529154,\n         0.23037781330885523\n    ], dtype=float)\n    g = qmf_highpass_from_lowpass(h)\n    return h, g\n\ndef reconstruction_filters_from_analysis(h, g):\n    # For orthonormal wavelets, synthesis filters are time-reversed analysis filters\n    hr = h[::-1].copy()\n    gr = g[::-1].copy()\n    return hr, gr\n\ndef build_atom_signal(N, basis, level, position, amplitude=1.0):\n    # basis: 'haar' or 'db4'\n    # Build coefficients arrays with one nonzero detail coefficient at given level and position, synthesize signal\n    if basis == 'haar':\n        h, g = haar_filters()\n    elif basis == 'db4':\n        h, g = db4_filters()\n    else:\n        raise ValueError(\"Unknown basis\")\n    hr, gr = reconstruction_filters_from_analysis(h, g)\n    L = int(np.log2(N))\n    # Initialize all details to zeros with appropriate lengths\n    details = []\n    for ell in range(1, L+1):\n        details.append(np.zeros(N // (2**ell), dtype=float))\n    # Set specified coefficient; level is 1..L\n    details[level - 1][position % len(details[level - 1])] = amplitude\n    # Final approximation at level L is zero\n    aL = np.array([0.0]) if (N // (2**L) == 1) else np.zeros(N // (2**L), dtype=float)\n    # Synthesize\n    x = idwt(aL, details, hr, gr)\n    return x\n\ndef impulse_signal(N, index=0, amplitude=1.0):\n    x = np.zeros(N, dtype=float)\n    x[index % N] = amplitude\n    return x\n\ndef sparsity_in_both_bases(x, p):\n    # Compute k for Haar and Db4 for signal x\n    # Haar\n    hH, gH = haar_filters()\n    hrH, grH = reconstruction_filters_from_analysis(hH, gH)\n    L = int(np.log2(len(x)))\n    aH, dH = dwt(x, hH, gH, L)\n    coeffsH = flatten_coeffs(aH, dH)\n    kH = energy_capture_k(coeffsH, p)\n    # Db4\n    hD, gD = db4_filters()\n    hrD, grD = reconstruction_filters_from_analysis(hD, gD)\n    aD, dD = dwt(x, hD, gD, L)\n    coeffsD = flatten_coeffs(aD, dD)\n    kD = energy_capture_k(coeffsD, p)\n    ratio = float(kD) / float(kH) if kH != 0 else float('inf')\n    return kH, kD, ratio\n\ndef solve():\n    p = 0.99\n\n    # Test A: N=256, single Haar atom at level 3, position 5\n    N_A = 256\n    xA = build_atom_signal(N_A, basis='haar', level=3, position=5, amplitude=1.0)\n\n    # Test B: N=256, sum of two Haar atoms: (level2,pos17,amp2.0) + (level5,pos3,amp-1.0)\n    xB = build_atom_signal(N_A, basis='haar', level=2, position=17, amplitude=2.0) + \\\n         build_atom_signal(N_A, basis='haar', level=5, position=3, amplitude=-1.0)\n\n    # Test C: N=256, single Db4 atom at level 4, position 11\n    xC = build_atom_signal(N_A, basis='db4', level=4, position=11, amplitude=1.0)\n\n    # Test D: N=32, unit impulse at index 0\n    N_D = 32\n    xD = impulse_signal(N_D, index=0, amplitude=1.0)\n\n    tests = [xA, xB, xC, xD]\n\n    results = []\n    for x in tests:\n        kH, kD, r = sparsity_in_both_bases(x, p)\n        results.append([int(kH), int(kD), r])\n\n    # Final print statement in the exact required format.\n    # Ensure floats are printed in standard Python repr; inner lists as described.\n    print(f\"[{','.join(['[' + ','.join([str(e) for e in res]) + ']' for res in results])}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3286372"}]}