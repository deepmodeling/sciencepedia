{"hands_on_practices": [{"introduction": "快速傅里叶变换（FFT）不仅仅是计算离散傅里叶变换（DFT）的另一种方法；因其惊人的效率，它是一项革命性的算法。第一个实践将通过直接比较直接DFT与Cooley-Tukey FFT算法所需的操作数量，让您对这种效率有一个具体的理解。通过完成这个计算，您将能亲自量化FFT之所以被广泛使用的性能优势，从而深刻理解其在计算复杂度上从 $O(N^2)$ 到 $O(N \\log N)$ 的飞跃。[@problem_id:3282537]", "problem": "一位软件工程师必须决定是直接实现离散傅里叶变换（DFT），还是通过基-2 Cooley–Tukey 快速傅里叶变换（FFT）来处理一个大小为 $N=1024$ 的数据集。该工程师仅通过浮点乘法次数来衡量成本，其定义如下：\n- 一次复数乘法被朴素地实现为 $4$ 次实数乘法。\n- 忽略旋转因子的预计算时间。\n- 不应用特殊旋转因子值（如 $1$, $-1$, $\\mathrm{i}$, $-\\mathrm{i}$）的代数简化；每次出现旋转因子都被视为一次常规复数乘法并相应计数。\n\n仅使用 DFT 的定义和 Cooley–Tukey FFT 底层的基-2 抽取原理，确定对于 $N=1024$，直接 DFT 计算所有 $N$ 个输出与基-2 Cooley–Tukey FFT 计算所有 $N$ 个输出之间，实数浮点乘法总次数的精确差值。请以整数形式给出最终答案，无需四舍五入。", "solution": "我们将首先提取给定信息，然后评估其科学性和逻辑的完整性，以此来验证问题。\n\n### 第1步：提取已知条件\n- 数据集大小为 $N=1024$。\n- 成本度量是实数浮点乘法的总次数。\n- 一次复数乘法定义为消耗 $4$ 次实数乘法。\n- 忽略预计算旋转因子的时间。\n- 不考虑特殊旋转因子值（例如，$1$, $-1$, $\\mathrm{i}$, $-\\mathrm{i}$）的代数简化。每次旋转因子乘法都计为一次常规复数乘法。\n- 目标是找出直接离散傅里叶变换（DFT）计算与基-2 Cooley–Tukey 快速傅里叶变换（FFT）计算之间实数乘法总次数的差异。\n\n### 第2步：使用提取的已知条件进行验证\n- **科学依据：** 该问题是计算复杂性分析中的一个标准练习，比较 DFT 和 FFT 算法的性能。这是数值方法和信号处理中的一个基本主题。所提供的假设，例如复数乘法的朴素成本和忽略特殊情况优化，虽然是简化的，但表述清晰，并且对于理论分析而言在科学上是一致的。\n- **适定性：** 该问题是适定的。输入大小 $N=1024$ 是 $2$ 的幂（$N=2^{10}$），这是标准基-2 Cooley–Tukey 算法的一个要求。成本函数有明确定义。预期会有一个唯一的整数值解，并且可以从所提供的信息中确定。\n- **客观性：** 问题陈述是客观的，并使用了精确、无歧义的语言。\n- **完整性和一致性：** 问题是自洽的，提供了所有必要的数据和定义。没有矛盾之处。\n\n### 第3步：结论与行动\n问题有效。现在将推导完整解法。\n\n### 解法推导\n\n目标是计算对于长度为 $N=1024$ 的信号，直接 DFT 和基-2 FFT 在实数浮点乘法次数上的差异。\n\n**1. 直接 DFT 的成本**\n\n长度为 $N$ 的序列 $x_n$ 的离散傅里叶变换（DFT）由 $N$ 个复数 $X_k$ 的集合定义：\n$$\nX_k = \\sum_{n=0}^{N-1} x_n e^{-i \\frac{2\\pi kn}{N}} \\quad \\text{for } k = 0, 1, \\dots, N-1\n$$\n我们来分析单个输出系数 $X_k$ 的计算成本。该计算涉及 $N$ 个项的和。和中的每一项都是 $x_n \\cdot e^{-i \\frac{2\\pi kn}{N}}$ 的形式。这是两个复数的乘积（输入样本 $x_n$，在一般情况下为复数，以及旋转因子 $e^{-i \\frac{2\\pi kn}{N}}$）。根据问题陈述，我们必须将每个这样的运算计为一次常规复数乘法。\n\n因此，对于 $N$ 个输出系数 $X_k$ 中的每一个，我们都必须执行 $N$ 次复数乘法。因此，直接 DFT 的复数乘法总次数为：\n$$\n\\text{Cost}_{\\text{complex, DFT}} = N \\times N = N^2\n$$\n问题规定，一次复数乘法消耗 $4$ 次实数乘法。因此，直接 DFT 的实数乘法总次数为：\n$$\n\\text{Cost}_{\\text{real, DFT}} = 4 \\times N^2\n$$\n\n**2. 基-2 Cooley–Tukey FFT 的成本**\n\n基-2 Cooley–Tukey 算法是一种计算 DFT 的递归方法。它通过将一个大小为 $N$ 的 DFT 分解为两个大小为 $N/2$ 的 DFT 来工作。设 $C_{\\text{complex}}(N)$ 是大小为 $N$ 的 FFT 所需的复数乘法次数。其递推关系为：\n$$\nC_{\\text{complex}}(N) = 2 \\cdot C_{\\text{complex}}(N/2) + (\\text{组合步骤中的乘法次数})\n$$\n组合步骤，或称“蝶形”阶段，根据两个子问题的输出计算最终输出。对于 $k = 0, 1, \\dots, N/2 - 1$，计算如下：\n$$\nX_k = E_k + e^{-i \\frac{2\\pi k}{N}} O_k\n$$\n$$\nX_{k+N/2} = E_k - e^{-i \\frac{2\\pi k}{N}} O_k\n$$\n其中 $E_k$ 和 $O_k$ 分别是输入信号偶数索引部分和奇数索引部分的 DFT。\n\n乘法发生在项 $e^{-i \\frac{2\\pi k}{N}} O_k$ 中。对于从 $0$ 到 $N/2 - 1$ 的每个 $k$ 值，都必须执行此乘法。这总计为 $N/2$ 次复数乘法。问题明确指出，不对特殊值进行简化，因此即使对于 $k=0$（此时旋转因子为 $1$），我们也必须将其计为一次完整的复数乘法。\n\n因此，递推关系变为：\n$$\nC_{\\text{complex}}(N) = 2 C_{\\text{complex}}(N/2) + \\frac{N}{2}\n$$\n递归的基例是大小为 $N=1$ 的 DFT，它就是恒等变换（$X_0 = x_0$），需要 $0$ 次乘法。所以，$C_{\\text{complex}}(1) = 0$。\n\n由于 $N$ 是 $2$ 的幂，设 $N = 2^m$。递归共有 $m = \\log_2(N)$ 个阶段。在每个阶段，所有蝶形运算总共执行 $N/2$ 次复数乘法。因此，FFT 的复数乘法总次数为：\n$$\nC_{\\text{complex, FFT}}(N) = (\\log_2 N) \\times \\frac{N}{2} = \\frac{N}{2} \\log_2(N)\n$$\n实数乘法的总次数是这个数量的 $4$ 倍：\n$$\n\\text{Cost}_{\\text{real, FFT}} = 4 \\times \\left(\\frac{N}{2} \\log_2(N)\\right) = 2N \\log_2(N)\n$$\n\n**3. 计算差值**\n\n我们需要求直接 DFT 和 FFT 之间实数乘法次数的差值。设这个差值为 $\\Delta M$。\n$$\n\\Delta M = \\text{Cost}_{\\text{real, DFT}} - \\text{Cost}_{\\text{real, FFT}}\n$$\n$$\n\\Delta M = 4N^2 - 2N \\log_2(N)\n$$\n代入给定值 $N = 1024$。我们首先注意到 $1024 = 2^{10}$，所以 $\\log_2(1024) = 10$。\n$$\n\\Delta M = 4(1024)^2 - 2(1024)(10)\n$$\n$$\n\\Delta M = 4(1048576) - 20(1024)\n$$\n$$\n\\Delta M = 4194304 - 20480\n$$\n$$\n\\Delta M = 4173824\n$$\n或者，我们可以在计算前对表达式进行因式分解：\n$$\n\\Delta M = 2N(2N - \\log_2(N))\n$$\n$$\n\\Delta M = 2(1024)(2(1024) - 10)\n$$\n$$\n\\Delta M = 2048(2048 - 10)\n$$\n$$\n\\Delta M = 2048 \\times 2038\n$$\n$$\n\\Delta M = (2040+8)(2040-2) = 2040^2 - 4080 + 16320 - 16 = 4161600 + 12240 - 16 = 4173840 - 16 = 4173824\n$$\n实数浮点乘法总次数的差值为 $4,173,824$。", "answer": "$$\n\\boxed{4173824}\n$$", "id": "3282537"}, {"introduction": "FFT最强大的应用之一是能够分析和操纵信号的频率分量。这个动手练习将指导您构建一个频域滤波器，以从信号中去除不希望的噪声。您将把一个含噪信号转换到频域，识别并消除高频噪声分量，然后将信号变换回来观察结果，从而掌握数字信号处理中的一项基本技术。[@problem_id:3282556]", "problem": "给定一个离散时间有限长度实值信号，要求您实现一个基于离散傅里叶变换 (DFT) 的去噪程序。您的程序必须构造合成信号，添加高频干扰，通过 DFT 变换到频域，将幅值小的高频系数置零，进行逆变换，并量化去噪效果。\n\n您的推理应基于以下基本定义和事实。\n\n1. 离散傅里叶变换 (DFT) 和离散傅里叶逆变换 (IDFT)。对于一个序列 $\\{x_n\\}_{n=0}^{N-1}$，其中 $N \\in \\mathbb{N}$，\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, n k / N}, \\quad k = 0,1,\\dots,N-1,\n$$\n逆变换可重构信号：\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{2\\pi i \\, n k / N}, \\quad n = 0,1,\\dots,N-1.\n$$\n2. 对于实值时域序列，其 DFT 表现出厄米对称性。在不考虑归一化的情况下，能量在时域和频域之间是守恒的（这是帕塞瓦尔定理的一个推论），这证明了在时域中使用均方误差来衡量失真是合理的。\n\n需要实现的去噪算子。令 $X_k$ 表示长度为 $N$ 的含噪信号的 DFT。定义对称归一化频率半径\n$$\n\\rho(k) = \\frac{\\min\\{k,\\,N-k\\}}{N/2}, \\quad k = 0,1,\\dots,N-1.\n$$\n给定参数 $\\gamma \\in [0,1]$ 和 $\\tau \\in [0,1]$，以及 $M = \\max_{0 \\le k \\le N-1} |X_k|$，将同时满足以下两个条件的每个频率系数置零：\n$$\n\\rho(k) \\ge \\gamma \\quad \\text{和} \\quad |X_k| \\le \\tau \\, M.\n$$\n然后，计算修正后频谱的离散傅里叶逆变换，以获得去噪后的序列。所有三角函数中的角度必须以弧度为单位。\n\n用于测试的信号模型。对于每个测试用例，纯净信号是与 DFT 频点索引对齐的正弦波的有限和，因此对于幅值 $A_j > 0$ 和整数频点索引 $b_j \\in \\{0,1,\\dots,N-1\\}$，\n$$\nx^{(\\mathrm{clean})}_n = \\sum_{j} A_j \\, \\sin\\!\\left(2\\pi \\, \\frac{b_j}{N} \\, n\\right), \\quad n = 0,1,\\dots,N-1.\n$$\n噪声是以相同方式定义的高频正弦波之和（具有指定的幅值和频点索引）。含噪信号为 $x^{(\\mathrm{noisy})}_n = x^{(\\mathrm{clean})}_n + x^{(\\mathrm{noise})}_n$。\n\n质量度量。令\n$$\n\\mathrm{MSE}_{\\mathrm{before}} = \\frac{1}{N}\\sum_{n=0}^{N-1} \\left(x^{(\\mathrm{noisy})}_n - x^{(\\mathrm{clean})}_n\\right)^2,\n$$\n$$\n\\mathrm{MSE}_{\\mathrm{after}} = \\frac{1}{N}\\sum_{n=0}^{N-1} \\left(\\hat{x}_n - x^{(\\mathrm{clean})}_n\\right)^2,\n$$\n其中 $\\hat{x}_n$ 是通过逆 DFT 获得的去噪序列。为避免在退化情况下出现除以零的错误，定义一个小的正则化项 $\\varepsilon = 10^{-12}$，并报告改善因子\n$$\nI = \\frac{\\mathrm{MSE}_{\\mathrm{before}} + \\varepsilon}{\\mathrm{MSE}_{\\mathrm{after}} + \\varepsilon}.\n$$\n\n您的任务。实现一个程序，对于下述每个测试用例，该程序需构造纯净信号和含噪信号，使用提供的 $(\\gamma,\\tau)$ 应用指定的去噪算子，计算 $I$，并报告四舍五入到六位小数的结果。\n\n测试套件。使用以下四种情况。在每种情况中，纯净信号的参数均相同，而噪声、阈值和高频参数则不同。所有幅值和参数都是无量纲的。\n\n- 所有情况的纯净信号：$N = 256$，幅值和频点\n  - $(A_1, b_1) = (1.0, 10)$，\n  - $(A_2, b_2) = (0.8, 30)$，\n  - $(A_3, b_3) = (0.6, 50)$。\n\n- 情况 1（理想情况）：噪声幅值和频点\n  - $(0.3, 100)$、$(0.25, 110)$、$(0.1, 90)$，\n  其中 $\\gamma = 0.7$，$\\tau = 0.5$。\n\n- 情况 2（无噪声边界情况）：无噪声分量，其中 $\\gamma = 0.7$，$\\tau = 0.5$。\n\n- 情况 3（未被标记为“小”的强高频噪声）：噪声幅值和频点\n  - $(1.2, 120)$、$(0.4, 100)$，\n  其中 $\\gamma = 0.7$，$\\tau = 0.6$。\n\n- 情况 4（高频阈值过接近奈奎斯特频率）：噪声幅值和频点\n  - $(0.3, 100)$、$(0.25, 110)$，\n  其中 $\\gamma = 0.99$，$\\tau = 0.5$。\n\n最终输出格式。您的程序应生成单行输出，其中包含四个改善因子，四舍五入到六位小数，并聚合成一个用方括号括起来的逗号分隔列表，不含空格。例如：“[v1,v2,v3,v4]”。", "solution": "问题陈述经过正式评估，被认定为有效。它在科学上基于数字信号处理的原理，其参数集完整且一致，问题定义明确，并且表述客观。任务是实现一个特定的频域去噪算法，并在系列明确定义的测试用例上量化其性能。\n\n解决方案通过为每个测试用例实现指定的程序来推进。其核心原理是，一个由少数主导正弦波组成的信号在频域中将具有稀疏表示，而噪声通常分布更广或位于高频区域。该算法试图通过将信号变换到频域，将特定系数置零，然后变换回时域，来分离并移除这些噪声分量。\n\n详细步骤如下：\n\n1.  **信号合成**：对于每个测试用例，我们构造三个长度为 $N=256$ 的离散时间信号，采样索引为 $n = 0, 1, \\dots, N-1$。\n    -   纯净信号 $x^{(\\mathrm{clean})}_n$ 根据公式 $x^{(\\mathrm{clean})}_n = \\sum_{j} A_j \\, \\sin(2\\pi \\frac{b_j}{N} n)$，使用提供的幅值 $A_j$ 和频点索引 $b_j$ 生成。\n    -   噪声信号 $x^{(\\mathrm{noise})}_n$ 使用给定情况指定的幅值和频点参数，以类似方式构造。\n    -   待处理的信号 $x^{(\\mathrm{noisy})}_n$ 是纯净信号和噪声信号之和：$x^{(\\mathrm{noisy})}_n = x^{(\\mathrm{clean})}_n + x^{(\\mathrm{noise})}_n$。\n\n2.  **频率变换**：使用离散傅里叶变换 (DFT) 将含噪信号变换到频域，得到一个复值频谱 $X_k$：\n    $$\n    X_k = \\sum_{n=0}^{N-1} x^{(\\mathrm{noisy})}_n \\, e^{-2\\pi i \\, n k / N}, \\quad k = 0,1,\\dots,N-1.\n    $$\n    这在计算上通过快速傅里叶变换 (FFT) 算法实现。\n\n3.  **频域去噪**：直接在复数频谱 $X_k$ 上执行去噪。通过应用一个阈值规则来创建滤波后的频谱 $\\hat{X}_k$。对于每个频率系数 $X_k$，我们评估两个条件：\n    -   **高频条件**：归一化频率半径 $\\rho(k) = \\frac{\\min\\{k, N-k\\}}{N/2}$ 必须大于或等于给定的阈值 $\\gamma$。此条件分离出远离直流分量 ($k=0$) 的频率。\n    -   **小幅值条件**：系数的幅值 $|X_k|$ 必须小于或等于与整个频谱中最大幅值 $M = \\max_{j} |X_j|$ 成比例的阈值。该条件为 $|X_k| \\le \\tau M$。此举旨在保留强的信号分量（即使它们位于高频），同时衰减弱的（假定的噪声）分量。\n\n    当且仅当两个条件都满足时，系数 $X_k$ 在滤波后的频谱 $\\hat{X}_k$ 中被置零。否则，$\\hat{X}_k = X_k$。\n\n4.  **信号重构**：通过对滤波后的频谱 $\\hat{X}_k$ 应用离散傅里叶逆变换 (IDFT)，得到去噪后的时域信号 $\\hat{x}_n$：\n    $$\n    \\hat{x}_n = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{X}_k \\, e^{2\\pi i \\, n k / N}, \\quad n = 0,1,\\dots,N-1.\n    $$\n    由于原始信号 $x^{(\\mathrm{noisy})}_n$ 是实值的，并且滤波规则保持了厄米对称性（如果 $X_k$ 被置零，其共轭对称对应项 $X_{N-k}$ 也会被置零），因此得到的 $\\hat{x}_n$ 也必须是实数。我们取 IDFT 输出的实部，以舍弃由数值浮点误差引起的微小虚部。\n\n5.  **性能评估**：通过比较滤波前后的均方误差 (MSE) 来量化去噪过程的有效性。\n    -   初始误差为 $\\mathrm{MSE}_{\\mathrm{before}} = \\frac{1}{N}\\sum_{n=0}^{N-1} \\left(x^{(\\mathrm{noisy})}_n - x^{(\\mathrm{clean})}_n\\right)^2 = \\frac{1}{N}\\sum_{n=0}^{N-1} \\left(x^{(\\mathrm{noise})}_n\\right)^2$。\n    -   去噪后的误差为 $\\mathrm{MSE}_{\\mathrm{after}} = \\frac{1}{N}\\sum_{n=0}^{N-1} \\left(\\hat{x}_n - x^{(\\mathrm{clean})}_n\\right)^2$。\n    -   最终度量是改善因子 $I$，定义为这些误差的比率，并通过一个小的常数 $\\varepsilon = 10^{-12}$ 进行正则化，以确保数值稳定性：\n    $$\n    I = \\frac{\\mathrm{MSE}_{\\mathrm{before}} + \\varepsilon}{\\mathrm{MSE}_{\\mathrm{after}} + \\varepsilon}.\n    $$\n    改善因子 $I > 1$ 表示去噪成功，$I \\approx 1$ 表示无显著变化，而 $I  1$ 则表示该过程引入的误差多于其移除的误差。\n\n将这个完整的程序应用于所提供的四个测试用例中的每一个，并计算和报告所得的改善因子。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs signals, applies a DFT-based denoising filter, and computes\n    the performance improvement for a suite of test cases.\n    \"\"\"\n    # Define constants and test parameters from the problem statement.\n    N = 256\n    epsilon = 1e-12\n    \n    clean_components = [\n        (1.0, 10),\n        (0.8, 30),\n        (0.6, 50)\n    ]\n\n    test_suite = [\n        {\n            # Case 1: Standard denoising scenario\n            \"noise_components\": [(0.3, 100), (0.25, 110), (0.1, 90)],\n            \"gamma\": 0.7,\n            \"tau\": 0.5\n        },\n        {\n            # Case 2: No noise, to test filter's effect on clean signal\n            \"noise_components\": [],\n            \"gamma\": 0.7,\n            \"tau\": 0.5\n        },\n        {\n            # Case 3: Strong high-frequency noise that exceeds magnitude threshold\n            \"noise_components\": [(1.2, 120), (0.4, 100)],\n            \"gamma\": 0.7,\n            \"tau\": 0.6\n        },\n        {\n            # Case 4: High-frequency threshold is too restrictive (close to Nyquist)\n            \"noise_components\": [(0.3, 100), (0.25, 110)],\n            \"gamma\": 0.99,\n            \"tau\": 0.5\n        }\n    ]\n\n    results = []\n\n    # Pre-calculate arrays that are common across all test cases for efficiency\n    n = np.arange(N)\n    k_indices = np.arange(N)\n    rho = np.minimum(k_indices, N - k_indices) / (N / 2.0)\n\n    # Generate the clean signal once, as it's the same for all cases\n    x_clean = np.zeros(N, dtype=float)\n    for A, b in clean_components:\n        x_clean += A * np.sin(2 * np.pi * b * n / N)\n\n    for case in test_suite:\n        # Unpack parameters for the current test case\n        noise_components = case['noise_components']\n        gamma = case['gamma']\n        tau = case['tau']\n\n        # Step 1: Synthesize the noise and noisy signals\n        x_noise = np.zeros(N, dtype=float)\n        if noise_components:\n            for A, b in noise_components:\n                x_noise += A * np.sin(2 * np.pi * b * n / N)\n        x_noisy = x_clean + x_noise\n\n        # Calculate the initial Mean Squared Error\n        mse_before = np.mean(x_noise**2)\n\n        # Step 2: Transform to the frequency domain\n        X_noisy = np.fft.fft(x_noisy)\n        M = np.max(np.abs(X_noisy))\n\n        # Step 3: Apply frequency-domain denoising\n        # Identify coefficients that meet both filtering conditions\n        high_freq_mask = rho >= gamma\n        small_mag_mask = np.abs(X_noisy) = tau * M\n        zero_mask = high_freq_mask  small_mag_mask\n\n        # Create the filtered spectrum by setting identified coefficients to zero\n        X_filtered = X_noisy.copy()\n        X_filtered[zero_mask] = 0.0\n\n        # Step 4: Reconstruct the signal via Inverse DFT\n        # Use np.real to discard negligible imaginary parts from numerical error\n        x_denoised = np.real(np.fft.ifft(X_filtered))\n\n        # Step 5: Evaluate performance\n        # Calculate the Mean Squared Error after denoising\n        mse_after = np.mean((x_denoised - x_clean)**2)\n\n        # Compute the regularized improvement factor\n        improvement = (mse_before + epsilon) / (mse_after + epsilon)\n        results.append(f\"{improvement:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3282556"}, {"introduction": "FFT为计算卷积提供了一种高效的方法，而卷积是信号处理和系统分析中的一个基本操作。然而，适用于DFT的卷积定理实际上对应的是*循环*卷积，而非我们通常更需要的*线性*卷积。本实践旨在探讨这种差异所导致的“环绕”（wrap-around）失真，并展示零填充（zero-padding）在使用FFT正确计算线性卷积时所起的关键作用。[@problem_id:3282547]", "problem": "您被要求探究快速傅里叶变换 (FFT) 算法中固有的周期性假设如何影响卷积，以及补零如何减轻环绕失真。请完全在离散时间内进行操作。您的程序必须从核心定义开始，实现以下内容。\n\n设一个有限长度的非周期离散时间信号定义为 $x[n] = n + 1$，$n \\in \\{0,1,\\dots,N-1\\}$，其他情况下 $x[n] = 0$，其中 $N = 10$。设一个有限长度的非周期平均核定义为 $h[n] = \\frac{1}{M}$，$n \\in \\{0,1,\\dots,M-1\\}$，其他情况下 $h[n] = 0$，其中 $M = 4$。定义线性卷积 $y_{\\mathrm{lin}}[n]$ 为\n$$\ny_{\\mathrm{lin}}[n] = \\sum_{k=-\\infty}^{\\infty} x[k]\\,h[n-k],\n$$\n其中 $x[n]$ 和 $h[n]$ 在其指定的支撑集之外均被视为零。该求和是有限的，且 $y_{\\mathrm{lin}}[n]$ 的长度为 $N+M-1 = 13$。\n\n定义一个支撑集为 $\\{0,1,\\dots,L-1\\}$ 的序列 $a[n]$ 的长度为 $L$ 的离散傅里叶变换 (DFT) 为\n$$\nA_L[m] = \\sum_{n=0}^{L-1} a[n]\\,e^{-2\\pi i \\frac{mn}{L}},\\quad m=0,1,\\dots,L-1,\n$$\n及其逆变换为\n$$\na[n] = \\frac{1}{L}\\sum_{m=0}^{L-1} A_L[m]\\,e^{2\\pi i \\frac{mn}{L}}.\n$$\n对于给定的长度 $L$，通过以下方式构成补零版本 $x_L[n]$ 和 $h_L[n]$\n$$\nx_L[n] = \\begin{cases}\nx[n], 0\\le n\\le N-1\\\\\n0, \\text{otherwise}\n\\end{cases},\\quad\nh_L[n] = \\begin{cases}\nh[n], 0\\le n\\le M-1\\\\\n0, \\text{otherwise}\n\\end{cases},\n$$\n对于 $n\\in\\{0,1,\\dots,L-1\\}$。通过在 DFT 域中使用快速傅里叶变换 (FFT) 进行逐点相乘，计算长度为 $L$ 的循环卷积\n$$\ny_{\\mathrm{circ},L}[n] = \\sum_{k=0}^{L-1} x_L[k]\\,h_L[(n-k)\\bmod L],\\quad n=0,1,\\dots,L-1。\n$$\nDFT 的乘积对应于时域中的循环卷积，这是一个经过充分验证的事实。\n\n为量化环绕失真，对每个 $L$ 定义误差\n$$\nE(L) = \\max_{0\\le n \\le L-1} \\left| y_{\\mathrm{circ},L}[n] - y_{\\mathrm{lin},L}[n] \\right|,\n$$\n其中 $y_{\\mathrm{lin},L}[n]$ 是线性卷积 $y_{\\mathrm{lin}}[n]$，如果 $L \\le N+M-1$，则截断为其前 $L$ 个样本，如果 $L \\ge N+M-1$，则用 $L-(N+M-1)$ 个尾随零进行补零。这个公共的比较长度确保了对 $L$ 个样本的逐点误差。如果 $E(L)$ 显著大于数值舍入误差，则表明存在环绕失真。\n\n您的任务是：\n- 实现上述定义，并为一组测试补零长度 $L \\in \\{10,12,13,16,64\\}$ 计算 $E(L)$。\n- 解释结果以评估三种补零策略 $L$：不补零 $L=N$，最小补零 $L=N+M-1$，以及2的幂次补零 $L=\\min\\{2^p: 2^p\\ge N+M-1\\}$，并使用一个额外的超大补零 $L=64$ 来探究数值稳定性。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的浮点误差列表，按测试组的顺序排列，并用方括号括起来，例如 $[e_{10},e_{12},e_{13},e_{16},e_{64}]$，其中每个 $e_L$ 是为该 $L$ 计算出的 $E(L)$。不允许有任何其他输出。\n\n请确保您的实现是自包含的，不使用任何用户输入，并遵循上述定义。根据定义，复指数中的角度以弧度为单位。不涉及任何物理单位。目标受众是学习数值方法和科学计算的高年级本科生。", "solution": "该问题要求探究如何使用快速傅里叶变换 (FFT) 来计算两个离散时间信号的线性卷积。被检验的核心原理是离散傅里叶变换 (DFT) 的卷积定理，该定理指出，两个序列的循环卷积的 DFT 是它们各自 DFT 的逐点乘积。只有当信号被补零到足够长的长度以防止时域混叠（也称为环绕误差）时，才能通过此方法正确计算线性卷积。本练习旨在展示并量化这种效应。\n\n过程结构如下：\n\n首先，我们定义输入信号。主信号是一个有限长度的斜坡序列 $x[n] = n + 1$，$n \\in \\{0, 1, \\dots, N-1\\}$，其中 $N=10$，其他情况下 $x[n]=0$。第二个信号是一个有限长度的平均核 $h[n] = \\frac{1}{M}$，$n \\in \\{0, 1, \\dots, M-1\\}$，其中 $M=4$，其他情况下 $h[n]=0$。\n\n其次，我们计算真实的线性卷积，记作 $y_{\\mathrm{lin}}[n]$，它将作为我们的基准。它由卷积和定义：\n$$\ny_{\\mathrm{lin}}[n] = \\sum_{k=-\\infty}^{\\infty} x[k]\\,h[n-k]\n$$\n对于长度为 $N$ 的信号和长度为 $M$ 的核，得到的序列 $y_{\\mathrm{lin}}[n]$ 的长度为 $N+M-1$。在本例中，长度为 $10+4-1=13$。该计算直接在时域中执行。\n\n第三，对于集合 $\\{10, 12, 13, 16, 64\\}$ 中的每个指定变换长度 $L$，我们计算长度为 $L$ 的循环卷积 $y_{\\mathrm{circ},L}[n]$。这是通过利用卷积定理来完成的。步骤如下：\n1.  通过将原始信号 $x[n]$ 和 $h[n]$ 补零至长度 $L$，创建输入信号的长度为 $L$ 的版本 $x_L[n]$ 和 $h_L[n]$。\n2.  使用 FFT 算法高效地计算补零信号的长度为 $L$ 的 DFT，$X_L[m] = \\text{DFT}\\{x_L[n]\\}$ 和 $H_L[m] = \\text{DFT}\\{h_L[n]\\}$，其中 DFT 定义为 $A_L[m] = \\sum_{n=0}^{L-1} a[n]\\,e^{-2\\pi i \\frac{mn}{L}}$。\n3.  在频域中执行逐点相乘：$Y_{\\mathrm{circ},L}[m] = X_L[m] \\cdot H_L[m]$。\n4.  计算乘积的逆 DFT，$y_{\\mathrm{circ},L}[n] = \\text{IDFT}\\{Y_{\\mathrm{circ},L}[m]\\}$，以在时域中获得循环卷积的结果，其中逆 DFT 定义为 $a[n] = \\frac{1}{L}\\sum_{m=0}^{L-1} A_L[m]\\,e^{2\\pi i \\frac{mn}{L}}$。\n\n第四，我们量化循环卷积和线性卷积之间的差异。通过将基准信号 $y_{\\mathrm{lin}}[n]$ 截断或用零填充以匹配长度 $L$，创建一个比较信号 $y_{\\mathrm{lin},L}[n]$。然后，给定长度 $L$ 的误差定义为两个结果在所有采样点上的最大绝对差：\n$$\nE(L) = \\max_{0\\le n \\le L-1} \\left| y_{\\mathrm{circ},L}[n] - y_{\\mathrm{lin},L}[n] \\right|\n$$\n$E(L)$ 的一个不可忽略的值表示存在环绕失真。\n\n此分析的理论基础是，当且仅当 $L \\ge N+M-1$ 时，以长度 $L$ 计算的循环卷积等价于线性卷积。\n- 如果 $L  N+M-1$，线性卷积结果的尾部（延伸到索引 $N+M-2$）会“环绕”并加到循环卷积结果的初始样本上，从而导致混叠。因此，对于 $L=10$ 和 $L=12$，我们预期 $E(L)$ 会显著大于零。\n- 如果 $L \\ge N+M-1$，则有足够的补零来包含整个线性卷积结果而不会发生环绕。在这种情况下，$y_{\\mathrm{circ},L}[n]$ 将与 $y_{\\mathrm{lin},L}[n]$ 完全相同。因此，对于 $L=13$、$L=16$ 和 $L=64$，我们预期误差 $E(L)$ 将在机器浮点精度的数量级上。\n\n选择这些测试用例是为了说明关键的补零策略：$L=10$（补零不足）、$L=13$（最小足够补零）和 $L=16$（2的幂次补零，通常为了 FFT 效率而选择）。$L=64$ 的情况进一步证实了超大补零的稳定性。该实现为每个这些情况计算了 $E(L)$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes convolution error E(L) to demonstrate the effect of zero-padding.\n    \"\"\"\n    # Define signal and kernel parameters as per the problem statement.\n    N = 10\n    M = 4\n\n    # Define the discrete-time signal x[n] = n + 1.\n    x = np.arange(1, N + 1, dtype=float)\n\n    # Define the averaging kernel h[n] = 1/M.\n    h = np.ones(M, dtype=float) / M\n\n    # Compute the ground-truth linear convolution y_lin[n].\n    # The length of the result is N + M - 1 = 13.\n    L_lin = N + M - 1\n    y_lin = np.convolve(x, h)\n\n    # Define the test suite of padding lengths L.\n    test_Ls = [10, 12, 13, 16, 64]\n    \n    results = []\n\n    # Iterate through each padding length L to compute the error E(L).\n    for L in test_Ls:\n        # Step 1: Create the comparison linear convolution y_lin_L[n] of length L.\n        # This is done by truncating or padding y_lin to length L.\n        y_lin_L = np.zeros(L)\n        len_to_copy = min(L, L_lin)\n        y_lin_L[:len_to_copy] = y_lin[:len_to_copy]\n\n        # Step 2: Create zero-padded versions of x and h to length L.\n        x_L = np.zeros(L)\n        x_L[:N] = x\n        \n        h_L = np.zeros(L)\n        h_L[:M] = h\n\n        # Step 3: Compute circular convolution via FFT.\n        # This uses the convolution theorem: IDFT{DFT{x} * DFT{h}}.\n        X_L = np.fft.fft(x_L)\n        H_L = np.fft.fft(h_L)\n        Y_circ_L = X_L * H_L\n        y_circ_L = np.fft.ifft(Y_circ_L)\n\n        # Step 4: Calculate the error E(L) as the maximum absolute difference.\n        # np.abs handles the case where y_circ_L has a tiny imaginary part\n        # due to numerical precision.\n        error = np.max(np.abs(y_circ_L - y_lin_L))\n        results.append(error)\n\n    # Print the results in the specified single-line format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3282547"}]}