{"hands_on_practices": [{"introduction": "谱方法不仅适用于周期性问题。对于定义在有限区间上的函数，切比雪夫多项式提供了一个强大的函数基。本练习将探索配置点法，即在特定的网格点（切比雪夫节点）上强制满足微分方程。其核心工具是切比雪夫微分矩阵，它近似了微分算子。通过构建该矩阵并求解一个边值问题 [@problem_id:3277690]，您将亲身体验谱方法的“微分矩阵”视角，并理解其在非周期性区域上的应用。", "problem": "考虑使用切比雪夫谱配置法，在区间 $[-1,1]$ 上使用切比雪夫–高斯–洛巴托点来近似导数。目标是构建一个基于这些点的一阶切比雪夫微分矩阵，用它来组装一个满足齐次狄利克雷边界条件的离散二阶导数算子，然后针对一个模型问题，研究由此产生的线性系统的条件数和精度。\n\n从以下基本概念出发：\n- 第一类切比雪夫多项式满足 $T_k(x) = \\cos(k \\arccos x)$，其中整数 $k \\ge 0$。\n- 在 $[-1,1]$ 上的切比雪夫–高斯–洛巴托配置点定义为 $x_j = \\cos\\left(\\frac{\\pi j}{N-1}\\right)$，其中整数索引 $j = 0,1,\\dots,N-1$，$N$ 是配置点的数量。\n- 在拉格朗日基中的多项式插值将一个近似函数表示为 $p(x) = \\sum_{j=0}^{N-1} u_j \\ell_j(x)$，其中 $\\ell_j(x)$ 是在配置点处的拉格朗日基多项式，而节点上的微分通过一个微分矩阵 $D$ 来实现，其元素来自于对插值函数求导并在节点处求值。\n- 用于二阶导数的谱配置法构建了一个矩阵 $D^{(2)} = D D$，该矩阵将节点值映射到插值函数在节点处的二阶导数值。\n- 一个非奇异矩阵 $A$ 的 $2$-范数条件数为 $\\kappa_2(A) = \\|A\\|_2 \\|A^{-1}\\|_2$。\n- 三角函数应以弧度为单位进行解释。\n\n任务：\n1. 对于给定的整数 $N \\ge 3$，构建在 $[-1,1]$ 上的切比雪夫–高斯–洛巴托配置点 $x_j$，其中 $j = 0,1,\\dots,N-1$。\n2. 利用拉格朗日插值的定义以及插值函数在节点处的导数可以通过微分矩阵表示这一恒等式，推导并实现一阶切比雪夫微分矩阵 $D \\in \\mathbb{R}^{N \\times N}$，其非对角线元素是节点的有理函数，其对角线元素通过要求每行总和为零来确保插值函数在节点处的精确微分。\n3. 形成离散二阶导数矩阵 $D^{(2)} = D D$，并通过限制到内部索引 $1,2,\\dots,N-2$ 来施加齐次狄利克雷边界条件 $u(-1) = 0$ 和 $u(1) = 0$，从而得到内部算子 $A \\in \\mathbb{R}^{(N-2)\\times(N-2)}$，该算子是通过删除 $D^{(2)}$ 的第一行和最后一行以及第一列和最后一列得到的。\n4. 考虑在 $[-1,1]$ 上的边值问题 $u''(x) = f(x)$，其中 $u(-1)=0$ 和 $u(1)=0$，$f(x) = \\pi^2 \\sin(\\pi x)$，精确解为 $u(x) = \\sin(\\pi x)$。通过在内部节点 $x_j$（$j=1,2,\\dots,N-2$）处计算 $f(x)$ 的值来组装内部右端向量，并求解线性系统 $A \\mathbf{u}_{\\mathrm{int}} = \\mathbf{f}_{\\mathrm{int}}$ 以获得内部节点值 $\\mathbf{u}_{\\mathrm{int}}$。通过将端点值设为零并将内部解放置在相应索引处来恢复完整的节点向量。\n5. 计算 $2$-范数条件数 $\\kappa_2(A)$ 和最大绝对节点误差 $\\max_{0 \\le j \\le N-1} |u(x_j) - u_j|$，其中 $u(x) = \\sin(\\pi x)$ 是精确解，$u_j$ 是计算出的节点值。所有三角函数求值必须使用弧度。\n6. 为以下 $N$ 值的测试集提供结果：$N \\in \\{3,8,20,64\\}$，这些值共同探讨了一个具有最小内部点的边界情况（$N=3$）、一个小问题（$N=8$）、一个中等问题（$N=20$）和一个较大问题（$N=64$），以考察条件数的增长和精度的趋势。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。该列表必须按顺序为测试集中的每个 $N$ 汇总结果，首先是作为浮点数的条件数 $\\kappa_2(A)$，然后是作为浮点数的最大绝对节点误差。最终列表的长度应为 $2 \\times 4 = 8$，并遵循以下顺序：$[\\kappa_2(A;N{=}3), \\mathrm{err}(N{=}3), \\kappa_2(A;N{=}8), \\mathrm{err}(N{=}8), \\kappa_2(A;N{=}20), \\mathrm{err}(N{=}20), \\kappa_2(A;N{=}64), \\mathrm{err}(N{=}64)]$。", "solution": "用户提供了一个在数值分析领域中定义明确的计算问题，具体涉及应用切比雪夫谱配置法来求解一个二阶边值问题。该问题具有科学依据，内容自洽，逻辑一致。在验证过程中未发现任何缺陷。\n\n该问题要求构建一个切比雪夫微分矩阵，并用其离散化一个微分算子，然后求解所得线性系统以解决一个模型问题，并对一系列指定问题规模分析其条件数和精度。\n\n解决方案通过执行问题陈述中概述的步骤来进行。\n\n**步骤 1：切比雪夫-高斯-洛巴托配置点**\n\n对于给定的配置点数 $N$，在区间 $[-1, 1]$ 上的切比雪夫-高斯-洛巴托（CGL）点被定义为 $(N-1)$ 阶切比雪夫多项式 $T_{N-1}(x)$ 的极值点。这些点由以下公式给出：\n$$\nx_j = \\cos\\left(\\frac{\\pi j}{N-1}\\right) \\quad \\text{for } j = 0, 1, \\dots, N-1.\n$$\n这些点的索引方式使得 $x_0 = 1$ 和 $x_{N-1} = -1$。点集 $\\{x_j\\}$ 关于原点对称。为了应用齐次狄利克雷边界条件，内部点为 $\\{x_j\\}_{j=1}^{N-2}$。\n\n**步骤 2：一阶切比雪夫微分矩阵 ($D$)**\n\n在 CGL 网格 $\\{x_j\\}$ 上近似的函数 $u(x)$ 由一个唯一的、次数最多为 $N-1$ 的多项式插值函数 $p(x)$ 表示，该插值函数穿过节点值 $\\{u_j\\}$，其中 $u_j = u(x_j)$。该插值函数的导数在网格点处求值时，可以表示为矩阵-向量乘积 $\\mathbf{p}' = D\\mathbf{u}$，其中 $\\mathbf{u} = [u_0, u_1, \\dots, u_{N-1}]^T$，$\\mathbf{p}' = [p'(x_0), p'(x_1), \\dots, p'(x_{N-1})]^T$。矩阵 $D \\in \\mathbb{R}^{N \\times N}$ 是一阶切比雪夫微分矩阵。\n\n$D$ 的元素，记为 $D_{kj}$，由标准公式给出。非对角线元素 ($k \\neq j$) 为：\n$$\nD_{kj} = \\frac{c_k}{c_j} \\frac{(-1)^{k+j}}{x_k - x_j}, \\quad k, j = 0, \\dots, N-1,\n$$\n其中权重 $c_k$ 定义为：\n$$\nc_k = \\begin{cases} 2  &\\text{if } k=0 \\text{ or } k=N-1 \\\\ 1  &\\text{otherwise} \\end{cases}\n$$\n问题规定，对角线元素 $D_{kk}$ 由微分矩阵必须将常数函数映射为其零导数的性质来确定。这意味着对于任意行 $k$，其元素之和必须为零：$\\sum_{j=0}^{N-1} D_{kj} = 0$。因此，对角线元素可以计算为：\n$$\nD_{kk} = - \\sum_{j=0, j \\neq k}^{N-1} D_{kj}.\n$$\n这个过程可以稳健地构建微分矩阵 $D$。\n\n**步骤 3：用于狄利克雷边界条件的二阶算子 ($A$)**\n\n插值函数的二阶导数可以通过两次应用一阶微分矩阵来获得。相应的二阶微分矩阵是 $D^{(2)} = D \\cdot D$。微分方程 $u''(x) = f(x)$ 在节点处的离散化变成线性系统 $D^{(2)} \\mathbf{u} = \\mathbf{f}$。\n\n问题指定了齐次狄利克雷边界条件 $u(-1) = 0$ 和 $u(1) = 0$。在我们的网格中，这对应于 $u(x_{N-1})=0$ 和 $u(x_0)=0$，即 $u_{N-1}=0$ 和 $u_0=0$。这些条件被施加于代数系统上。我们只需要求解内部节点 $\\{u_j\\}_{j=1}^{N-2}$ 处的未知值。\n\n对于内部节点 $i=1, \\dots, N-2$，方程为：\n$$\n\\sum_{j=0}^{N-1} (D^{(2)})_{ij} u_j = f_i\n$$\n代入已知的边界值 $u_0 = 0$ 和 $u_{N-1} = 0$，系统简化为：\n$$\n\\sum_{j=1}^{N-2} (D^{(2)})_{ij} u_j = f_i\n$$\n这可以写成一个更小的线性系统 $A \\mathbf{u}_{\\mathrm{int}} = \\mathbf{f}_{\\mathrm{int}}$，其中：\n- $A$ 是通过选取索引为 $1, \\dots, N-2$ 的行和列从 $D^{(2)}$ 中得到的 $(N-2) \\times (N-2)$ 子矩阵。\n- $\\mathbf{u}_{\\mathrm{int}} = [u_1, u_2, \\dots, u_{N-2}]^T$ 是未知内部节点值的向量。\n- $\\mathbf{f}_{\\mathrm{int}} = [f_1, f_2, \\dots, f_{N-2}]^T$ 是在内部节点处求值的强制函数 $f(x)$ 的向量。\n\n**步骤 4：求解模型边值问题**\n\n具体的边值问题是在 $[-1, 1]$ 上的 $u''(x) = \\pi^2 \\sin(\\pi x)$，满足 $u(-1) = u(1) = 0$。其精确解为 $u(x) = \\sin(\\pi x)$。\n强制函数是 $f(x) = \\pi^2 \\sin(\\pi x)$。向量 $\\mathbf{f}_{\\mathrm{int}}$ 是通过在内部 CGL 点处计算 $f(x)$ 来构建的：\n$$\nf_j = \\pi^2 \\sin(\\pi x_j) \\quad \\text{for } j = 1, \\dots, N-2.\n$$\n然后求解线性系统 $A \\mathbf{u}_{\\mathrm{int}} = \\mathbf{f}_{\\mathrm{int}}$ 以找到内部节点处的数值解 $\\mathbf{u}_{\\mathrm{int}}$。完整的解向量 $\\mathbf{u}$ 是通过用零边界值扩充 $\\mathbf{u}_{\\mathrm{int}}$ 来组装的：$\\mathbf{u} = [0, u_1, \\dots, u_{N-2}, 0]^T$。\n\n**步骤 5：计算条件数和误差**\n\n计算两个量来分析该方法的性能：\n1.  **条件数：** 内部算子 $A$ 的 $2$-范数条件数 $\\kappa_2(A) = \\|A\\|_2 \\|A^{-1}\\|_2$。这衡量了线性系统解对右端项扰动的敏感性。大的条件数表示潜在的数值不稳定性。\n2.  **最大节点误差：** 谱方法的精度是通过将计算出的节点值 $u_j$ 与精确解的值 $u(x_j) = \\sin(\\pi x_j)$ 进行比较来评估的。所有节点上的最大绝对误差计算如下：\n    $$\n    E_{\\max} = \\max_{0 \\le j \\le N-1} |u(x_j) - u_j|.\n    $$\n\n**步骤 6：执行测试集**\n\n对测试集 $\\{3, 8, 20, 64\\}$ 中的每个 $N$ 值执行步骤 1-5 中描述的过程。对于每个 $N$，计算并存储结果对 $(\\kappa_2(A), E_{\\max})$。最终输出是这些结果对按指定顺序的聚合。对于 $N=3$，内部算子 $A$ 是一个 $1 \\times 1$ 的矩阵（一个标量），因此其条件数为 $1$。在唯一的内部点 $x_1=0$ 处的右端项是 $f(0)=0$，这导致数值解 $u_1=0$，这个解是精确的，因此误差为 $0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Chebyshev spectral collocation problem for a set of N values.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [3, 8, 20, 64]\n    results = []\n\n    for N in test_cases:\n        # Step 1: Construct Chebyshev–Gauss–Lobatto collocation points\n        j = np.arange(N)\n        x = np.cos(np.pi * j / (N - 1))\n\n        # Step 2: Construct the Chebyshev first-order differentiation matrix D\n        D = np.zeros((N, N))\n        c = np.ones(N)\n        c[0] = 2.0\n        c[-1] = 2.0\n\n        for k in range(N):\n            for i in range(N):\n                if k != i:\n                    D[k, i] = (c[k] / c[i]) * ((-1)**(k + i)) / (x[k] - x[i])\n        \n        # Enforce zero row sums by setting diagonal elements\n        for k in range(N):\n            D[k, k] = -np.sum(D[k, :])\n\n        # Step 3: Form the discrete second derivative matrix and interior operator A\n        D2 = D @ D\n        A = D2[1:-1, 1:-1]\n\n        # Step 4: Assemble the RHS and solve the linear system for the BVP\n        # BVP: u''(x) = pi^2 * sin(pi*x) with u(-1)=0, u(1)=0\n        x_int = x[1:-1]\n        f_int = (np.pi**2) * np.sin(np.pi * x_int)\n        \n        # For N=3, the interior is one point (x=0), so f_int is a scalar 0.\n        # np.linalg.solve handles 1x1 systems correctly.\n        u_int = np.linalg.solve(A, f_int)\n        \n        # Recover the full nodal solution vector\n        u_computed = np.zeros(N)\n        u_computed[1:-1] = u_int\n\n        # Step 5: Compute the condition number of A and the maximum nodal error\n        # For N=3, A is a scalar, so cond(A) is 1.0.\n        if N == 3:\n            cond_A = 1.0\n        else:\n            cond_A = np.linalg.cond(A, 2)\n            \n        u_exact = np.sin(np.pi * x)\n        max_error = np.max(np.abs(u_exact - u_computed))\n\n        # Append results for the current N\n        results.append(cond_A)\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3277690"}, {"introduction": "对于周期性问题，傅里叶级数和快速傅里叶变换（FFT）为计算导数提供了一种异常高效的方法。然而，在求解瞬态方程时，这种高效性也带来了挑战。谱方法产生的常微分方程组通常是“刚性”的，即不同模式在截然不同的时间尺度上进行演化。本练习旨在研究这种刚性如何影响常用时间积分格式的稳定性 [@problem_id:3277778]。通过比较一个显式方法（RK4）和一个隐式方法（Crank-Nicolson）在求解热传导方程时的表现，您将学会识别和管理数值稳定性，这是模拟瞬态物理现象的一项关键技能。", "problem": "你需要实现并比较两种结合了空间傅里叶谱离散化的时间积分方案，用以求解一维扩散方程\n$$\nu_t(x,t) = \\nu\\,u_{xx}(x,t), \\quad x \\in [0,2\\pi), \\ t \\ge 0,\n$$\n该方程具有周期性边界条件和光滑的周期性初始条件。这两种方案分别是经典的四阶龙格—库塔 (RK4) 方法和 Crank–Nicolson 方法，两者都应用于通过傅里叶谱方法得到的空间离散化系统。目标是量化并比较在小粘性系数值下，这两种方法的精度和实际稳定性行为。\n\n基本基础与设置：\n- 在周期性域上使用标准的傅里叶级数表示，其中微分对应于傅里叶空间中的乘法。具体而言，对于波数为 $k$ 的模式，二阶导数算子对应于乘以 $-k^2$。使用快速傅里叶变换 (FFT) 实现空间离散化。\n- 使用 RK4 方法和 Crank–Nicolson 方法的经典定义作为时间积分器，应用于半离散系统。不要假定任何预先推导出的傅里叶空间中的闭合形式更新公式；从定义中推导出必要的内容。\n- 空间域为 $[0,2\\pi)$，具有周期性边界条件。角度以弧度为单位。\n- 初始条件为\n$$\nu(x,0) = \\sin(3x) + 0.5\\cos(5x) + 0.25\\sin(16x).\n$$\n\n实现要求：\n- 在 $[0,2\\pi)$ 上使用包含 $N$ 个点的均匀网格，其中 $x_j = \\frac{2\\pi j}{N}$，$j \\in \\{0,1,\\dots,N-1\\}$。\n- 使用傅里叶谱离散化来评估 $u_{xx}$，具体如下：若 $\\widehat{u}$ 表示 $u$ 的离散傅里叶变换，则 $u_{xx}$ 的傅里叶变换为 $-(k^2)\\widehat{u}$，其中 $k$ 是与根据 $[0,2\\pi)$ 上的 FFT 频率约定得到的每个傅里叶模式相关联的整数值波数。\n- 为半离散系统实现两种时间步进器：\n  1. 经典的四阶龙格—库塔 (RK4) 方法，使用通过谱方法求导评估的半离散右端项 $f(u) = \\nu u_{xx}$。\n  2. Crank–Nicolson 方法，应用于线性半离散系统，在每一步利用傅里叶谱方法产生的傅里叶空间对角化，对每个傅里叶模式进行精确求解。\n- 对于每次运行，从时间 $t=0$ 推进到时间 $t=T$，使用大小为 $\\Delta t = T/n$ 的步长，共 $n$ 步。对于下面给出的测试套件，$T/\\Delta t$ 是一个整数，因此不需要调整 $\\Delta t$。\n- 通过在精确线性流下逐模式演化初始谱，以谱方法的闭合形式计算 $t=T$ 时的参考解。具体来说，如果 $\\widehat{u}_k(0)$ 表示初始条件在模式 $k$ 处的傅里叶系数，则使用线性常微分方程的基本解来获得 $\\widehat{u}_k(T)$，然后通过逆变换得到 $u(x,T)$。\n- 将每种方法的误差度量为最终时间的相对离散 $L^2$ 误差，\n$$\nE = \\frac{\\left\\| u_{\\text{num}}(\\cdot,T) - u_{\\text{exact}}(\\cdot,T) \\right\\|_2}{\\left\\| u_{\\text{exact}}(\\cdot,T) \\right\\|_2},\n$$\n其中离散 $L^2$ 范数是在网格点上计算的。使用一致的归一化，以便任何公共比例常数在比率中被抵消。\n- 如果 RK4 数值解表现出不稳定性（例如，时间步进过程中的非有限值或明显非物理的无界增长），则报告一个大的有限误差，例如 $10^{99}$，而不是一个非有限值。\n\n测试套件：\n对于下面的每个参数集 $(N,\\nu,\\Delta t,T)$，计算两个数值：RK4 的相对误差和 Crank–Nicolson 的相对误差，按此顺序排列。\n\n- 测试 1: $N=64$, $\\nu=10^{-3}$, $\\Delta t=5\\times 10^{-3}$, $T=5\\times 10^{-2}$。\n- 测试 2: $N=64$, $\\nu=10^{-5}$, $\\Delta t=5\\times 10^{-2}$, $T=5\\times 10^{-1}$。\n- 测试 3: $N=256$, $\\nu=10^{-3}$, $\\Delta t=5\\times 10^{-3}$, $T=5\\times 10^{-2}$。\n- 测试 4: $N=512$, $\\nu=10^{-3}$, $\\Delta t=4\\times 10^{-2}$, $T=2\\times 10^{-1}$。\n- 测试 5: $N=512$, $\\nu=10^{-3}$, $\\Delta t=6\\times 10^{-2}$, $T=3\\times 10^{-1}$。\n\n最终输出规范：\n- 您的程序必须按顺序运行所有五个测试，并生成一行输出，其中包含一个由 $10$ 个浮点数组成的逗号分隔的扁平列表，该列表用方括号括起来，顺序如下：\n$$\n[\\ E_{\\text{RK4}}^{(1)},\\ E_{\\text{CN}}^{(1)},\\ E_{\\text{RK4}}^{(2)},\\ E_{\\text{CN}}^{(2)},\\ E_{\\text{RK4}}^{(3)},\\ E_{\\text{CN}}^{(3)},\\ E_{\\text{RK4}}^{(4)},\\ E_{\\text{CN}}^{(4)},\\ E_{\\text{RK4}}^{(5)},\\ E_{\\text{CN}}^{(5)}\\ ].\n$$\n- 所有角度都必须以弧度处理。\n- 每个浮点数应以标准十进制或科学记数法打印。不要在指定的列表格式之外打印任何额外的文本或字符。", "solution": "我们从周期性扩散方程开始\n$$\nu_t(x,t) = \\nu\\,u_{xx}(x,t), \\quad x \\in [0,2\\pi), \\ t \\ge 0,\n$$\n具有周期性边界条件和初始条件\n$$\nu(x,0) = \\sin(3x) + 0.5\\cos(5x) + 0.25\\sin(16x),\n$$\n其中所有角度都以弧度为单位。傅里叶谱方法将 $u(x,t)$ 表示为在 $N$ 个均匀网格点 $x_j = 2\\pi j/N$，$j \\in \\{0,1,\\dots,N-1\\}$ 上的有限傅里叶级数。设 $\\widehat{u}_k(t)$ 表示波数为 $k$ 的离散傅里叶系数，其中整数 $k$ 由快速傅里叶变换 (FFT) 的约定确定。对于足够光滑的解，物理空间中的微分对应于傅里叶空间中乘以 $ik$ 的幂。特别地，\n$$\n\\mathcal{F}\\{u_{xx}\\}(k,t) = -(k^2)\\widehat{u}_k(t),\n$$\n因此傅里叶系数满足线性常微分方程 (ODE)\n$$\n\\frac{d}{dt}\\widehat{u}_k(t) = -\\nu k^2 \\widehat{u}_k(t).\n$$\n这使得每个模式解耦。根据线性常微分方程的基本定理，每个模式的精确解由下式给出：\n$$\n\\widehat{u}_k(t) = e^{-\\nu k^2 t}\\,\\widehat{u}_k(0).\n$$\n因此，时间 $T$ 的精确解可以通过计算 $u(x,0)$ 的 FFT 得到 $\\widehat{u}_k(0)$，将每个系数乘以 $e^{-\\nu k^2 T}$，然后通过逆 FFT 变换回来得到。\n\n为了在物理空间中对半离散系统进行时间步进，我们以谱方法评估 $u_{xx}$。给定一个网格函数 $u$，我们计算其离散傅里叶变换 $\\widehat{u}$，逐模式乘以 $-(k^2)$ 以获得 $u_{xx}$ 的傅里叶表示，然后变换回实数空间。这以谱精确的方式实现了半离散右端项\n$$\nf(u) = \\nu\\,u_{xx},\n$$\n对于足够光滑的 $u$。\n\n时间积分器：\n\n1. 经典的四阶龙格—库塔 (RK4) 方法：给定 $u^n \\approx u(\\cdot,t_n)$ 和时间步长 $\\Delta t$，RK4 计算\n$$\n\\begin{aligned}\nk_1 &= f(u^n),\\\\\nk_2 &= f\\!\\left(u^n + \\tfrac{\\Delta t}{2} k_1\\right),\\\\\nk_3 &= f\\!\\left(u^n + \\tfrac{\\Delta t}{2} k_2\\right),\\\\\nk_4 &= f\\!\\left(u^n + \\Delta t\\, k_3\\right),\\\\\nu^{n+1} &= u^n + \\tfrac{\\Delta t}{6}\\left(k_1 + 2k_2 + 2k_3 + k_4\\right).\n\\end{aligned}\n$$\n对于线性模式 $y'=\\lambda y$，RK4 的放大因子是\n$$\nG_{\\text{RK4}}(z) = 1 + z + \\tfrac{z^2}{2} + \\tfrac{z^3}{6} + \\tfrac{z^4}{24}, \\quad z=\\lambda \\Delta t.\n$$\n在我们的例子中，$\\lambda_k = -\\nu k^2$ 是实数且非正，稳定性要求对所有相关 $k$ 都有 $|G_{\\text{RK4}}(z_k)| \\le 1$。沿着负实轴，这对 $\\Delta t$ 施加了一个与 $1/(\\nu k_{\\max}^2)$ 成比例的上限。如果 $\\Delta t$ 太大，数值解可能会因为超出稳定域而爆炸；在这种情况下，我们检测非有限值或爆炸性增长，并报告一个大的有限误差替代值。\n\n2. Crank–Nicolson 方法：将梯形法则应用于线性常微分方程 $u_t = \\nu u_{xx}$ 得到\n$$\n\\left(I - \\tfrac{\\Delta t}{2}\\nu \\partial_{xx}\\right) u^{n+1} = \\left(I + \\tfrac{\\Delta t}{2}\\nu \\partial_{xx}\\right) u^n.\n$$\n在傅里叶空间中，由于 $\\partial_{xx}$ 以符号 $-k^2$ 对角化，逐模式更新变为\n$$\n\\widehat{u}^{\\,n+1}_k = \\frac{1 - \\tfrac{\\Delta t}{2}\\nu k^2}{1 + \\tfrac{\\Delta t}{2}\\nu k^2}\\,\\widehat{u}^{\\,n}_k.\n$$\n对于扩散方程，这是无条件稳定的，因为对于 $\\nu > 0$ 和 $k \\ne 0$，因子的绝对值严格小于或等于 $1$。该方法在时间上是二阶精确的。\n\n参考解与误差：\n精确的最终谱为 $\\widehat{u}_k(T) = e^{-\\nu k^2 T}\\widehat{u}_k(0)$。逆变换得到 $u_{\\text{exact}}(\\cdot,T)$。对于一个数值解 $u_{\\text{num}}(\\cdot,T)$，定义相对离散 $L^2$ 误差\n$$\nE = \\frac{\\left(\\sum_{j=0}^{N-1} \\left|u_{\\text{num}}(x_j,T) - u_{\\text{exact}}(x_j,T)\\right|^2\\right)^{1/2}}{\\left(\\sum_{j=0}^{N-1} \\left|u_{\\text{exact}}(x_j,T)\\right|^2\\right)^{1/2}}.\n$$\n因为在分子和分母中使用了相同的网格和均匀权重，所以求和中的任何公共因子都在比率中抵消了。\n\n算法设计：\n- 在 $[0,2\\pi)$ 上构建具有 $N$ 个点的均匀网格，并使用 FFT 频率约定预先计算波数数组 $k$，将其缩放为角波数，使得 $\\partial_x$ 的傅里叶符号为 $ik$，$\\partial_{xx}$ 的傅里叶符号为 $-k^2$。\n- 实现一个函数，通过 FFT、与 $-k^2$ 的对角乘法以及逆 FFT（取实部），将实数网格函数 $u$ 映射到 $u_{xx}$。\n- 实现一个 RK4 步进，该步进调用谱方法右端项 $f(u)=\\nu u_{xx}$。\n- 实现一个 Crank–Nicolson 步进，该步进通过乘以上面推导的有理因子，在傅里葉空间中逐模式操作。\n- 对于每个测试用例 $(N,\\nu,\\Delta t,T)$，构造 $u(x,0)$，通过使用 $e^{-\\nu k^2 T}$ 演化初始谱来计算 $u_{\\text{exact}}(\\cdot,T)$，使用 RK4 和 Crank–Nicolson 方法推进 $n=T/\\Delta t$ 步，并计算两种方法的相对误差。如果 RK4 表现出不稳定性（非有限值或与扩散不符的爆炸性增长），则将其误差设置为一个大的有限替代值，例如 $10^{99}$。\n- 按照规定的顺序和格式，以扁平列表的形式输出五个测试的 $10$ 个误差。\n\n预期定性结果：\n- 对于 $\\Delta t$ 足够小的测试，两种方法都应稳定，RK4 表现出四阶时间精度，Crank–Nicolson 表现出二阶时间精度；因此，当稳定时，RK4 在相同的 $\\Delta t$ 下应该更精确。\n- 在 RK4 稳定性边界附近，RK4 误差通常会增加，如果 $\\Delta t$ 相对于 $\\nu$ 和最大可分辨波数过大，可能会发生不稳定性。Crank–Nicolson 由于其对线性扩散的无条件稳定性，对所有步长都保持稳定，尽管其时间精度仍然是二阶。\n\n这完成了傅里葉譜方法和两种时间积分器性质一致的推导和算法规划。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef spectral_wavenumbers(N, L=2*np.pi):\n    # Angular wavenumbers on [0, L) so that d/dx -> i*k and d2/dx2 -> -(k^2)\n    k = 2.0 * np.pi * np.fft.fftfreq(N, d=L / N)\n    return k\n\ndef laplacian_spectral(u, k2):\n    # Compute u_xx via FFT: F(u_xx) = -(k^2) * F(u)\n    u_hat = np.fft.fft(u)\n    lap_hat = -(k2) * u_hat\n    lap = np.fft.ifft(lap_hat).real\n    return lap\n\ndef rk4_step(u, dt, nu, k2):\n    # One RK4 step for u_t = nu * u_xx, spatial operator via spectral method\n    k1 = nu * laplacian_spectral(u, k2)\n    k2v = nu * laplacian_spectral(u + 0.5 * dt * k1, k2)\n    k3v = nu * laplacian_spectral(u + 0.5 * dt * k2v, k2)\n    k4v = nu * laplacian_spectral(u + dt * k3v, k2)\n    return u + (dt / 6.0) * (k1 + 2.0 * k2v + 2.0 * k3v + k4v)\n\ndef cn_step(u, dt, nu, k2):\n    # One Crank–Nicolson step in Fourier space\n    u_hat = np.fft.fft(u)\n    # Per-mode factor: (1 - 0.5*dt*nu*k^2)/(1 + 0.5*dt*nu*k^2)\n    factor_num = 1.0 - 0.5 * dt * nu * k2\n    factor_den = 1.0 + 0.5 * dt * nu * k2\n    G = factor_num / factor_den\n    u_hat_new = G * u_hat\n    return np.fft.ifft(u_hat_new).real\n\ndef exact_solution(u0, T, nu, k2):\n    # Exact spectral evolution: u_hat(T) = exp(-nu*k^2*T) * u_hat(0)\n    u0_hat = np.fft.fft(u0)\n    decay = np.exp(-nu * k2 * T)\n    uT_hat = decay * u0_hat\n    uT = np.fft.ifft(uT_hat).real\n    return uT\n\ndef rel_l2_error(u_num, u_ref):\n    num = np.linalg.norm(u_num - u_ref)\n    den = np.linalg.norm(u_ref)\n    # Guard against den = 0 (should not happen for given IC and parameters)\n    if den == 0.0:\n        return float('inf') if num != 0.0 else 0.0\n    return num / den\n\ndef initial_condition(x):\n    # Angles in radians\n    return np.sin(3.0 * x) + 0.5 * np.cos(5.0 * x) + 0.25 * np.sin(16.0 * x)\n\ndef run_case(N, nu, dt, T):\n    L = 2.0 * np.pi\n    x = np.linspace(0.0, L, N, endpoint=False)\n    k = spectral_wavenumbers(N, L=L)\n    k2 = k * k\n\n    u0 = initial_condition(x)\n    u_exact = exact_solution(u0, T, nu, k2)\n\n    # Time stepping parameters (T/dt is integer by construction in test suite)\n    nsteps = int(round(T / dt))\n    dt_eff = T / nsteps  # exactly equals dt for provided test cases\n\n    # RK4 time stepping\n    u_rk4 = u0.copy()\n    rk4_unstable = False\n    for _ in range(nsteps):\n        u_rk4 = rk4_step(u_rk4, dt_eff, nu, k2)\n        # Detect instability: non-finite or explosive growth (non-physical for diffusion)\n        if not np.all(np.isfinite(u_rk4)) or np.max(np.abs(u_rk4)) > 1e12:\n            rk4_unstable = True\n            break\n    if rk4_unstable:\n        err_rk4 = 1e99\n    else:\n        err_rk4 = rel_l2_error(u_rk4, u_exact)\n\n    # Crank–Nicolson time stepping\n    u_cn = u0.copy()\n    for _ in range(nsteps):\n        u_cn = cn_step(u_cn, dt_eff, nu, k2)\n    err_cn = rel_l2_error(u_cn, u_exact)\n\n    return err_rk4, err_cn\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N, nu, dt, T)\n    test_cases = [\n        (64, 1e-3, 5e-3, 5e-2),   # Test 1\n        (64, 1e-5, 5e-2, 5e-1),   # Test 2\n        (256, 1e-3, 5e-3, 5e-2),  # Test 3\n        (512, 1e-3, 4e-2, 2e-1),  # Test 4\n        (512, 1e-3, 6e-2, 3e-1),  # Test 5 (RK4 expected near/over stability limit)\n    ]\n\n    results = []\n    for N, nu, dt, T in test_cases:\n        err_rk4, err_cn = run_case(N, nu, dt, T)\n        results.append(err_rk4)\n        results.append(err_cn)\n\n    # Final print statement in the exact required format.\n    # Use scientific notation for reproducibility.\n    print(\"[\" + \",\".join(f\"{val:.12e}\" for val in results) + \"]\")\n\nsolve()\n```", "id": "3277778"}, {"introduction": "许多重要的物理系统，如流体湍流，是由非线性方程控制的。伪谱法是解决这类问题的常用选择，但它会引入一种独特的数值假象。本练习使用伯格斯方程作为湍流的简化模型，以探索“混叠误差”。这种误差源于在有限网格上表示非线性乘积，可能导致非物理行为，例如能量从小さい尺度反向流向大尺度 [@problem_id:3277726]。通过本次模拟，您将学会诊断由混叠驱动的不稳定性，并实践去混叠和超粘性等标准稳定化技术，这些技术对于可靠地进行非线性偏微分方程的谱方法模拟至关重要。", "problem": "考虑一个在一维周期性区域上，带有可选超粘性稳定项的，作为湍流代理的一维无粘性伯格斯方程。其控制方程为\n$$\n\\partial_t u(x,t) + \\partial_x \\left(\\tfrac{1}{2} u(x,t)^2\\right) \\;=\\; - \\nu_p \\, (-\\Delta)^p u(x,t),\n$$\n该方程定义在区间 $[0,2\\pi]$ 上，具有周期性边界条件，其中 $x \\in [0,2\\pi]$（角度以弧度为单位），$t \\ge 0$，$\\nu_p \\ge 0$ 是一个超粘性系数，$p \\in \\mathbb{N}$ 控制超粘性的阶数。区域长度为 $2\\pi$。初始条件为\n$$\nu(x,0) \\;=\\; \\sin(x) + \\tfrac{1}{2}\\sin(2x).\n$$\n你的任务是基于以下基本原理和定义，设计并实现一个全谱伪谱求解器。\n\n1) 基本谱表示与微分。用截断的复傅里叶级数表示 $u(x,t)$，使用 $N$ 个等距网格点 $x_j = 2\\pi j/N$，$j = 0,1,\\dots,N-1$。离散傅里叶变换记为 $\\widehat{u}_k(t)$，由整数波数 $k \\in \\{-N/2+1,\\dots,-1,0,1,\\dots,N/2\\}$ 索引（当 $N$ 为偶数时，采用通常的环绕处理）。空间导数遵循谱法则\n$$\n\\widehat{\\partial_x u}_k(t) = i k \\, \\widehat{u}_k(t),\n$$\n因为在 $[0,2\\pi]$ 上 $\\partial_x e^{i k x} = i k e^{i k x}$。\n\n2) 非线性项与混叠。非线性项为保守形式 $-\\partial_x \\left(\\tfrac{1}{2} u^2\\right)$。在伪谱方法中，通过逆变换计算 $u(x_j,t)$，逐点形成 $q(x_j,t) = \\tfrac{1}{2} u(x_j,t)^2$，然后变换为 $\\widehat{q}_k(t)$，最后将非线性谱项设置为\n$$\n\\widehat{\\mathcal{N}}_k(t) = - i k \\, \\widehat{q}_k(t).\n$$\n在有限分辨率 $N$ 下，这种逐点乘积会引起混叠误差，可能破坏能量传递并导致非物理的反向散射。一种经典的稳定化方法是 $2/3$ 反混叠规则：定义一个谱掩模，在计算非线性项时，将所有 $|k| > N/3$ 的模式置零。具体来说，当启用反混叠时，在非线性项的计算中使用该掩模两次：首先在变换到物理空间之前将 $\\widehat{u}_k$ 的高频模式置零，然后在乘以 $i k$ 之前将 $\\widehat{q}_k$ 的高频模式置零。\n\n3) 超粘性稳定项。超粘性算子在谱空间中定义为\n$$\n-\\nu_p \\left(-\\Delta\\right)^p u \\;\\;\\Longleftrightarrow\\;\\; - \\nu_p \\, |k|^{2p}\\, \\widehat{u}_k \\quad \\text{for each mode } k,\n$$\n因为在一维空间 $[0,2\\pi]$ 上，$-\\Delta$ 的傅里叶符号为 $|k|^2$。该项提供了尺度选择性阻尼，用以抑制高波数的振荡。\n\n4) 时间离散化。使用四阶显式龙格-库塔方法（经典龙格-库塔法），以固定的时间步长 $\\Delta t$ 在区间 $[0,T]$ 上对半离散系统 $\\partial_t \\widehat{u}_k = \\widehat{\\mathcal{N}}_k - \\nu_p |k|^{2p} \\widehat{u}_k$ 进行时间推进。所有变换都应在同一网格上一致地进行计算。当启用反混叠时，在每个完整的时间步之后，还需通过将所有 $|k| > N/3$ 的模式置零，把更新后的 $\\widehat{u}_k$ 投影到 $2/3$ 保留的模式集上。\n\n5) 能量诊断。将时间 $t$ 的总能量定义为空间平均值\n$$\nE(t) = \\tfrac{1}{2} \\,\\frac{1}{2\\pi}\\int_{0}^{2\\pi} u(x,t)^2 \\, dx,\n$$\n在具有 $N$ 个点的离散伪谱方法中，其计算方式为\n$$\nE(t) = \\tfrac{1}{2} \\cdot \\frac{1}{N} \\sum_{j=0}^{N-1} u(x_j,t)^2.\n$$\n同时定义一个低波数带能量\n$$\nE_{\\mathrm{low}}(t) = \\tfrac{1}{2} \\sum_{1 \\le |k| \\le k_{\\ast}} \\mathcal{E}_k(t),\n$$\n其中 $\\mathcal{E}_k(t)$ 是与帕萨瓦尔定理一致的离散谱能量密度。为避免歧义，使用离散傅里叶系数 $\\widehat{u}_k(t)$ 计算 $E_{\\mathrm{low}}(t)$：\n$$\nE_{\\mathrm{low}}(t) = \\tfrac{1}{2} \\cdot \\frac{1}{N^2} \\sum_{1 \\le |k| \\le k_{\\ast}} \\left|\\widehat{u}_k(t)\\right|^2,\n$$\n根据离散帕萨瓦尔定理，这与 $E(t) = \\tfrac{1}{2} \\cdot \\frac{1}{N^2}\\sum_k |\\widehat{u}_k(t)|^2$ 和 $E(t) = \\tfrac{1}{2}\\cdot \\frac{1}{N}\\sum_j u(x_j,t)^2$ 一致。使用 $k_{\\ast} = 4$。\n\n6) 研究目标。你将通过比较几种不同配置下总能量的漂移和低波数带能量的漂移，来研究混叠驱动的反向散射以及超粘性的稳定效应。对于每种配置，计算以下两个量化诊断指标：\n- $\\Delta E = E(T) - E(0)$，\n- $\\Delta E_{\\mathrm{low}} = E_{\\mathrm{low}}(T) - E_{\\mathrm{low}}(0)$。\n\n7) 实现与测试套件。实现上述完整程序，并使用以下参数集运行它。所有角度均以弧度为单位。在所有情况下，均使用 $N=64$，$T=0.4$ 和 $\\Delta t = 5\\times 10^{-4}$，并采用相同的初始条件 $u(x,0) = \\sin(x) + \\tfrac{1}{2}\\sin(2x)$。\n- 情况 A（有混叠，无超粘性）：禁用反混叠；$\\nu_p = 0$。\n- 情况 B（反混叠，无超粘性）：启用 $2/3$ 规则的反混叠；$\\nu_p = 0$。\n- 情况 C（有混叠，有超粘性）：禁用反混叠；启用超粘性，$p=4$ 且 $\\nu_p = 10^{-18}$。\n- 情况 D（反混叠，有超粘性）：启用 $2/3$ 规则的反混叠；启用超粘性，$p=4$ 且 $\\nu_p = 10^{-18}$。\n\n8) 最终输出格式。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含以下八个浮点数\n$$\n[\\Delta E_{\\mathrm{A}}, \\Delta E_{\\mathrm{low},\\mathrm{A}}, \\Delta E_{\\mathrm{B}}, \\Delta E_{\\mathrm{low},\\mathrm{B}}, \\Delta E_{\\mathrm{C}}, \\Delta E_{\\mathrm{low},\\mathrm{C}}, \\Delta E_{\\mathrm{D}}, \\Delta E_{\\mathrm{low},\\mathrm{D}}].\n$$\n每个数字必须呈现为最多包含10位有效数字的十进制浮点值。不得打印任何其他文本。\n\n你的实现必须是一个完整的、可运行的程序，该程序在内部执行所有计算，无需外部输入，遵循上述原则，并严格遵守指定的输出格式。", "solution": "该问题要求实现一个用于求解一维周期性域上带有超粘性项的一维无粘性伯格斯方程的伪谱求解器。该解将在四种不同配置下进行验证，以研究混叠和超粘性对能量守恒的影响。以下阐述了该求解器的理论和数值基础。\n\n控制方程为：\n$$\n\\partial_t u(x,t) + \\partial_x \\left(\\tfrac{1}{2} u(x,t)^2\\right) \\;=\\; - \\nu_p \\, (-\\Delta)^p u(x,t)\n$$\n在域 $x \\in [0,2\\pi]$ 上，具有周期性边界条件和初始条件 $u(x,0) = \\sin(x) + \\tfrac{1}{2}\\sin(2x)$。\n\n### 步骤1：问题验证\n根据指定标准对问题陈述进行了严格评估。\n\n-   **提取的已知条件：** 所有参数、方程、初始条件、数值程序（离散化、时间积分、反混叠）和诊断定义均被逐字提取。这包括控制偏微分方程、初始条件 $u(x,0) = \\sin(x) + \\tfrac{1}{2}\\sin(2x)$、数值参数 $N=64$，$T=0.4$，$\\Delta t = 5\\times 10^{-4}$、超粘性参数 $p=4, \\nu_p \\in \\{0, 10^{-18}\\}$，以及由反混叠和超粘性状态定义的四个模拟案例（A、B、C、D）。伪谱方法、龙格-库塔时间步进、$2/3$ 反混叠规则和能量诊断的定义都已明确提供。\n-   **验证检查：**\n    1.  **科学依据：** 该问题基于伯格斯方程，这是流体动力学中的一个标准模型，并采用了成熟的数值技术（伪谱方法、RK4、超粘性、反混叠）。它在科学上是合理的。\n    2.  **适定性：** 该问题构成了一个适定的初边值问题。数值任务明确指定了所有必要的参数和定义，确保了对于给定算法存在唯一且可计算的解。\n    3.  **客观性：** 问题陈述精确、量化，并且没有主观或含糊不清的语言。\n-   **结论：** 该问题是**有效的**。它是在偏微分方程数值方法领域中一个结构良好、有科学依据且计算上可行的的问题。\n\n### 步骤2：方法与实现\n求解方法在空间上采用伪谱方法，在时间上采用四阶龙格-库塔方法。\n\n**空间离散化与傅里叶表示**\n空间域 $[0,2\\pi]$ 被离散化为 $N=64$ 个等距点，$x_j = 2\\pi j/N$，$j=0, 1, \\dots, N-1$。函数 $u(x,t)$ 由其在该网格上的值 $u_j(t) = u(x_j, t)$ 表示。谱表示基于截断的傅里叶级数。离散傅里叶系数 $\\widehat{u}_k(t)$ 通过离散傅里叶变换（DFT）及其逆变换与网格点值 $u_j(t)$ 相关联：\n$$\n\\widehat{u}_k(t) = \\sum_{j=0}^{N-1} u_j(t) e^{-i k x_j}, \\quad u_j(t) = \\frac{1}{N} \\sum_{k} \\widehat{u}_k(t) e^{i k x_j}\n$$\n$k$ 的求和遍及整数波数集合。对于偶数点数 $N$，这些波数通常取为 $k \\in \\{-N/2, -N/2+1, \\dots, N/2-1\\}$。在实现中，我们使用标准的 `numpy.fft` 约定，其中波数的排序为 $k=0, 1, \\dots, N/2-1, -N/2, \\dots, -1$，并通过 `k = numpy.fft.fftfreq(N) * N` 获得。\n\n在傅里叶空间中，空间导数 $\\partial_x$ 变为与 $ik$ 的简单乘法：\n$$\n\\widehat{\\partial_x u}_k = ik \\widehat{u}_k\n$$\n\n**偏微分方程的半离散化**\n对控制方程应用傅里叶变换，得到一个关于系数 $\\widehat{u}_k(t)$ 的常微分方程（ODE）组：\n$$\n\\frac{d\\widehat{u}_k}{dt} = \\widehat{\\mathcal{N}}_k[\\widehat{u}] + \\widehat{\\mathcal{L}}_k[\\widehat{u}]\n$$\n其中 $\\widehat{\\mathcal{N}}_k$ 是非线性项的傅里叶变换，$\\widehat{\\mathcal{L}}_k$ 是超粘性项。\n\n**超粘性项（线性部分）**\n超粘性算子 $-\\nu_p(-\\Delta)^p$ 在傅里叶空间中有简单的表示。由于拉普拉斯算子 $\\Delta = \\partial_{xx}$ 对应于乘以 $(ik)^2 = -k^2$，算子 $-\\Delta$ 对应于乘以 $k^2 = |k|^2$。因此，超粘性项为：\n$$\n\\widehat{\\mathcal{L}}_k[\\widehat{u}] = -\\nu_p |k|^{2p} \\widehat{u}_k\n$$\n该项在 $\\widehat{u}_k$ 中是线性的，并施加了对大波数（小尺度）具有高度选择性的阻尼。\n\n**非线性项（伪谱部分）**\n非线性项为 $\\mathcal{N}(u) = -\\partial_x (\\frac{1}{2} u^2)$。其傅里叶系数通过伪谱方法计算：\n1.  使用快速傅里叶逆变换（IFFT）将 $\\widehat{u}_k(t)$ 变换到物理空间，得到 $u_j(t)$。\n2.  在每个网格点上计算 $q_j(t) = \\frac{1}{2}u_j(t)^2$。\n3.  使用快速傅里叶变换（FFT）将 $q_j(t)$ 变换回傅里叶空间，得到 $\\widehat{q}_k(t)$。\n4.  应用谱导数来找到非线性贡献：$\\widehat{\\mathcal{N}}_k = -ik \\widehat{q}_k(t)$。\n\n**反混叠**\n逐点乘积 $u_j \\cdot u_j$ 会产生混叠误差，其中高波数分量伪装成低波数分量。$2/3$ 反混叠规则可以减轻此问题。创建一个谱滤波器（掩模），将所有波数 $|k| > K_{\\text{max}}$ 的傅里叶模式置零，其中 $K_{\\text{max}} = \\lfloor N/3 \\rfloor$。对于 $N=64$，$K_{\\text{max}}=21$。当启用反混叠时，非线性项的处理程序修改如下：\n1.  在 IFFT 之前，对 $\\widehat{u}_k$ 应用反混叠掩模。\n2.  像之前一样计算 $u_j$ 和 $q_j$。\n3.  通过 FFT 计算出 $\\widehat{q}_k$ 后，在乘以 $-ik$ 之前再次应用反混叠掩模。\n此外，在每个完整的时间步之后，通过应用掩模将解 $\\widehat{u}_k$ 投影回未混叠的模式上。\n\n**时间积分**\n半离散系统 $\\frac{d\\widehat{u}}{dt} = F(\\widehat{u})$ 使用经典的四阶龙格-库塔（RK4）方法以固定的时间步长 $\\Delta t$ 进行时间推进：\n$$\n\\begin{align*}\n\\mathbf{k}_1 &= F(\\widehat{u}_n) \\\\\n\\mathbf{k}_2 &= F(\\widehat{u}_n + \\tfrac{1}{2}\\Delta t \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 &= F(\\widehat{u}_n + \\tfrac{1}{2}\\Delta t \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 &= F(\\widehat{u}_n + \\Delta t \\mathbf{k}_3) \\\\\n\\widehat{u}_{n+1} &= \\widehat{u}_n + \\tfrac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n\\end{align*}\n$$\n这里，$\\widehat{u}$ 是所有傅里叶系数的向量，$F(\\widehat{u})$ 是计算右侧项（非线性项和超粘性项之和）的函数。\n\n**初始条件**\n初始条件为 $u(x,0) = \\sin(x) + \\tfrac{1}{2}\\sin(2x)$。使用恒等式 $\\sin(\\theta) = (e^{i\\theta} - e^{-i\\theta})/(2i)$，我们可以找到精确的连续傅里叶级数系数。离散傅里叶变换系数 $\\widehat{u}_k(0)$ 与这些系数成正比，并且可以从正交关系中推导得出：\n$$\n\\widehat{u}_k(0) = \\begin{cases} -iN/2  &\\text{if } k=1 \\\\ iN/2  &\\text{if } k=-1 \\\\ -iN/4  &\\text{if } k=2 \\\\ iN/4  &\\text{if } k=-2 \\\\ 0  &\\text{otherwise} \\end{cases}\n$$\n这允许在傅里叶空间中进行精确、无采样误差的初始化。\n\n**能量诊断**\n计算总能量 $E(t)$ 和低波数带能量 $E_{\\mathrm{low}}(t)$。根据帕萨瓦尔定理，能量可以从傅里叶系数计算得出，这通常更准确，且与谱方法一致。公式为：\n$$\nE(t) = \\frac{1}{2 N^2} \\sum_{k} |\\widehat{u}_k(t)|^2\n$$\n$$\nE_{\\mathrm{low}}(t) = \\frac{1}{2 N^2} \\sum_{1 \\le |k| \\le k_{\\ast}} |\\widehat{u}_k(t)|^2, \\quad \\text{with } k_{\\ast}=4\n$$\n需要报告的诊断量是每种情况下的 $\\Delta E = E(T) - E(0)$ 和 $\\Delta E_{\\mathrm{low}} = E_{\\mathrm{low}}(T) - E_{\\mathrm{low}}(0)$。对于无粘性、无外力的伯格斯方程，总能量应该是守恒的。数值解中的任何偏差都表明存在误差，例如由混叠引起的误差。低频带能量的变化可以追踪能量在大尺度和小尺度之间的传递情况。\n\n总体算法的流程是：在傅里叶空间中设置初始状态，计算初始能量，然后对所需的步数迭代 RK4 时间步进循环。对于四种情况中的每一种，相应地配置反混叠和超粘性的参数。最后，计算最终能量，并计算和组装所需的诊断数据以供输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D inviscid Burgers' equation with optional hyperviscosity\n    using a pseudospectral method and investigates aliasing effects.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    N = 64\n    T = 0.4\n    dt = 5e-4\n    k_star = 4\n\n    test_cases = [\n        {'name': 'A', 'dealias': False, 'nu_p': 0.0, 'p': 4},\n        {'name': 'B', 'dealias': True,  'nu_p': 0.0, 'p': 4},\n        {'name': 'C', 'dealias': False, 'nu_p': 1e-18, 'p': 4},\n        {'name': 'D', 'dealias': True,  'nu_p': 1e-18, 'p': 4},\n    ]\n\n    # --- Grid and Wavenumber Setup ---\n    # Wavenumbers corresponding to numpy's FFT output order\n    k = np.fft.fftfreq(N) * N\n\n    # --- De-aliasing Mask (2/3 rule) ---\n    k_cutoff = int(np.floor(N / 3.0))\n    dealias_mask = np.ones_like(k, dtype=bool)\n    dealias_mask[np.abs(k) > k_cutoff] = False\n    \n    # --- Energy Calculation Functions ---\n    def calc_E(u_hat):\n        \"\"\"Computes total energy from spectral coefficients.\"\"\"\n        return 0.5 / (N**2) * np.sum(np.abs(u_hat)**2)\n\n    def calc_E_low(u_hat):\n        \"\"\"Computes low-wavenumber band energy.\"\"\"\n        mask = (np.abs(k) >= 1) & (np.abs(k) <= k_star)\n        return 0.5 / (N**2) * np.sum(np.abs(u_hat[mask])**2)\n\n    # --- RHS of the ODE in Fourier space: d(u_hat)/dt = F(u_hat) ---\n    def rhs(u_hat, hypervisc_op, dealias_flag):\n        \"\"\"\n        Computes the right-hand side of the semi-discrete equation.\n        F(u_hat) = NonlinearTerm(u_hat) + LinearTerm(u_hat)\n        \"\"\"\n        # Linear (hyperviscosity) term\n        du_dt_linear = hypervisc_op * u_hat\n        \n        # Nonlinear (pseudospectral) term\n        u_hat_dealiased = u_hat.copy()\n        if dealias_flag:\n            u_hat_dealiased[~dealias_mask] = 0.0\n            \n        u_phys = np.fft.ifft(u_hat_dealiased)\n        \n        # Ensure physical space solution is real before squaring\n        # Small imaginary parts can arise from floating point errors\n        q_phys = 0.5 * np.real(u_phys)**2 \n        \n        q_hat = np.fft.fft(q_phys)\n        \n        if dealias_flag:\n            q_hat[~dealias_mask] = 0.0\n            \n        du_dt_nonlinear = -1j * k * q_hat\n        \n        return du_dt_nonlinear + du_dt_linear\n\n    # --- Main Simulation Loop ---\n    all_results = []\n    num_steps = int(round(T / dt))\n\n    for case in test_cases:\n        dealias_flag = case['dealias']\n        nu_p = case['nu_p']\n        p = case['p']\n\n        # --- Initial Condition in Fourier Space ---\n        u_hat0 = np.zeros(N, dtype=complex)\n        # Using numpy's array indexing for negative wavenumbers\n        u_hat0[1] = -1j * N / 2.0\n        u_hat0[N-1] = 1j * N / 2.0  # k = -1\n        u_hat0[2] = -1j * N / 4.0\n        u_hat0[N-2] = 1j * N / 4.0  # k = -2\n        \n        u_hat = u_hat0.copy()\n\n        # --- Calculate Initial Energies ---\n        E0 = calc_E(u_hat)\n        E_low0 = calc_E_low(u_hat)\n\n        # Pre-compute the hyperviscosity operator for efficiency\n        hypervisc_op = -nu_p * np.abs(k)**(2*p)\n\n        # --- Time-stepping with RK4 ---\n        for _ in range(num_steps):\n            k1 = rhs(u_hat, hypervisc_op, dealias_flag)\n            k2 = rhs(u_hat + dt / 2.0 * k1, hypervisc_op, dealias_flag)\n            k3 = rhs(u_hat + dt / 2.0 * k2, hypervisc_op, dealias_flag)\n            k4 = rhs(u_hat + dt * k3, hypervisc_op, dealias_flag)\n            u_hat += dt / 6.0 * (k1 + 2*k2 + 2*k3 + k4)\n\n            # Post-step projection for de-aliased runs\n            if dealias_flag:\n                u_hat[~dealias_mask] = 0.0\n        \n        # --- Calculate Final Energies and Diagnostics ---\n        ET = calc_E(u_hat)\n        E_lowT = calc_E_low(u_hat)\n\n        delta_E = ET - E0\n        delta_E_low = E_lowT - E_low0\n\n        all_results.extend([delta_E, delta_E_low])\n\n    # --- Final Output Formatting ---\n    # Format numbers to specifications (up to 10 significant digits)\n    formatted_results = [f\"{val:.10g}\" for val in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3277726"}]}