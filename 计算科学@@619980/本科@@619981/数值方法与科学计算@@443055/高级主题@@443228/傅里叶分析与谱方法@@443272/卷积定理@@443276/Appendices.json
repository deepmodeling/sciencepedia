{"hands_on_practices": [{"introduction": "在运用卷积定理之前，首先必须对卷积运算本身有扎实的理解。本练习将通过一个经典的连续时间信号示例，带你动手实践卷积积分的计算。我们将计算两个指数衰减信号的卷积，这个过程不仅能加深你对“翻转、平移、相乘、积分”这一核心思想的理解，其结果本身也是系统分析中一个常见的函数形式。[@problem_id:539910]", "problem": "计算两个相同的因果指数衰减信号的卷积：$f(t) = e^{-a t} u(t)$ 和 $g(t) = e^{-a t} u(t)$，其中 $a  0$ 是一个常数，$u(t)$ 是单位阶跃函数，定义如下：\n$$\nu(t) = \n\\begin{cases} \n1,  t \\ge 0 \\\\\n0,  t  0 \n\\end{cases}\n$$\n将卷积结果表示为 $t$ 的闭合形式函数。两个函数 $f$ 和 $g$ 的卷积定义为：\n$$\n(f * g)(t) = \\int_{-\\infty}^{\\infty} f(\\tau) g(t - \\tau)  d\\tau\n$$\n确保你的答案明确显示了对于所有实数 $t$ 的行为。", "solution": "我们希望计算 \n$$\n(f * g)(t) \\;=\\;\\int_{-\\infty}^{\\infty} f(\\tau)\\,g(t-\\tau)\\,d\\tau\n$$\n其中 $f(t)=e^{-a t}u(t)$ 且 $g(t)=e^{-a t}u(t)$。\n\n1.  被积函数的支撑域：  \n    $f(\\tau)\\neq0$ 仅当 $\\tau\\ge0$ 时成立，且 $g(t-\\tau)\\neq0$ 仅当 $t-\\tau\\ge0\\,$ 时成立。  \n    因此积分上下限变为 \n    $$\n    \\tau\\ge0,\\quad\\tau\\le t\n    \\quad\\Longrightarrow\\quad\n    0\\le\\tau\\le t.\n    $$\n\n2.  在 $0\\le\\tau\\le t$ 上的积分 (对于 $t\\ge0$)：  \n    $$\n    (f*g)(t)\n    =\\int_{0}^{t}e^{-a\\tau}\\,e^{-a(t-\\tau)}\\,d\\tau\n    =e^{-a t}\\int_{0}^{t}d\\tau\n    =t\\,e^{-a t}.\n    $$\n\n3.  对于所有实数 $t$ 的行为：  \n    对于 $t0$，由于支撑域没有重叠，积分为零。 因此\n    $$\n    (f*g)(t)=\n    \\begin{cases}\n    t e^{-a t},  t \\ge 0 \\\\\n    0,  t  0\n    \\end{cases}\n    $$\n    或者更紧凑地写为 $(f*g)(t)=t\\,e^{-a t}u(t)\\,. $", "answer": "$$\\boxed{t\\,e^{-a t}\\,u(t)}$$", "id": "539910"}, {"introduction": "卷积定理的核心思想是“时域卷积等价于频域乘积”，但这一深刻见解如何通过实践来验证呢？本练习将指导你通过编写代码，对一个信号分别进行时域卷积和频域滤波两种操作。通过比较这两种方法的结果，你将亲手验证卷积定理的正确性，并直观地体会到它为何是数字信号处理中一个革命性的工具。[@problem_id:3219731]", "problem": "考虑一个离散时间、长度为 $N$ 的信号 $x_n$ 和一个定义在索引 $k \\in \\{0,1,\\dots,N-1\\}$ 上的频域滤波器 $H_k$。请使用离散傅里叶变换 (DFT) 及其逆变换的基础定义，以及循环卷积的定义，设计一个程序来证明频域中的乘法滤波与时域中相应冲激响应的卷积是等效的。您必须使用的基础理论包括：离散傅里叶变换 (DFT) 的定义、离散傅里叶逆变换 (IDFT) 的定义，以及循环卷积的定义。不得假定任何其他简化公式或定理。这些定义是：\n- 离散傅里叶变换 (DFT) 定义为 $X_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2 \\pi i \\, nk/N}$。\n- 离散傅里叶逆变换 (IDFT) 定义为 $x_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{2 \\pi i \\, nk/N}$。\n- 循环卷积定义为 $(x * h)_n = \\sum_{m=0}^{N-1} x_m \\, h_{(n-m) \\bmod N}$。\n\n您的程序必须：\n- 为每个测试用例构建一个噪声测试信号 $x_n = \\sin\\!\\left(2 \\pi m n / N\\right) + \\sigma_{\\text{noise}} \\cdot \\eta_n$，其中 $\\eta_n$ 是独立的标准正态样本。\n- 为每个测试用例直接在频域中设计一个滤波器 $H_k$。\n- 通过对 $H_k$ 应用离散傅里叶逆变换 (IDFT) 来计算冲激响应 $h_n$。\n- 通过两种方式计算滤波后的输出：\n    1. 频域方法：计算 $x_n$ 的 DFT，与 $H_k$ 相乘，然后应用 IDFT，从而计算 $\\widehat{y}_n$。\n    2. 时域方法：通过将 $x_n$ 与 $h_n$ 进行循环卷积来计算 $y_n$。\n- 通过计算 $\\Delta = \\max_{0 \\le n \\le N-1} \\left|y_n - \\widehat{y}_n\\right|$ 来量化差异，必要时使用复数绝对值。\n\n测试套件：\n实现并评估以下四个测试用例，涵盖典型场景和边界情况。使用固定的随机种子以确保可复现性。\n1. 正常路径低通滤波：$N=256$，正弦波索引 $m=5$，噪声标准差 $\\sigma_{\\text{noise}}=0.4$，以及高斯低通幅度响应 $H_k = \\exp\\!\\left(-\\frac{d(k)^2}{2 \\sigma_f^2}\\right)$，其中 $d(k) = \\min(k, N-k)$ 且 $\\sigma_f=10$。\n2. 全通滤波器边界情况：$N=128$，$m=12$，$\\sigma_{\\text{noise}}=0.6$，且对所有 $k$ 都有 $H_k = 1$。\n3. 零滤波器边界情况：$N=128$，$m=12$，$\\sigma_{\\text{noise}}=0.6$，且对所有 $k$ 都有 $H_k = 0$。\n4. 针对目标正弦波的陷波滤波器：$N=256$，$m=40$，$\\sigma_{\\text{noise}}=0.5$，且对所有 $k$ 都有 $H_k = 1$，除了 $H_{m}=0$ 和 $H_{N-m}=0$。\n\n算法和数值要求：\n- 直接在时域中使用定义 $(x * h)_n = \\sum_{m=0}^{N-1} x_m \\, h_{(n-m) \\bmod N}$ 实现循环卷积，在卷积步骤中不使用频域乘法。\n- 使用离散傅里叶变换 (DFT) 和离散傅里叶逆变换 (IDFT) 作为可用的数值例程来计算频谱和冲激响应。\n- 使用固定的随机数生成种子，以确保在重复运行时噪声信号完全相同。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须按上述顺序列出四个 $\\Delta$ 值（每个测试用例一个），例如：$[\\Delta_1,\\Delta_2,\\Delta_3,\\Delta_4]$。所有数字都是无单位的，根据正弦函数的定义，正弦波中的角度以弧度为单位。在标准双精度算术下，输出必须是可复现且数值稳定的。", "solution": "该问题要求对离散傅里叶变换 (DFT) 的卷积定理进行数值验证。这个基本定理指出，时域中的循环卷积对应于频域中的逐元素相乘。我们的任务是为一组测试用例实现这两种程序，并通过计算其输出之间的最大绝对差（记为 $\\Delta$）来验证它们的等效性。由于浮点运算的性质，这个差异预计不为零，但接近于机器精度。\n\n所提供的基础定义如下：\n-   离散傅里叶变换 (DFT)：$X_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2 \\pi i \\, nk/N}$，针对离散频率 $k \\in \\{0, 1, \\dots, N-1\\}$。\n-   离散傅里叶逆变换 (IDFT)：$x_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{2 \\pi i \\, nk/N}$，针对离散时间点 $n \\in \\{0, 1, \\dots, N-1\\}$。\n-   两个长度为 $N$ 的信号 $x_n$ 和 $h_n$ 的循环卷积：$(x * h)_n = \\sum_{m=0}^{N-1} x_m \\, h_{(n-m) \\bmod N}$。\n\n我们首先正式建立支撑该问题的关系。设 $y_n$ 是 $x_n$ 和 $h_n$ 的循环卷积，即 $y_n = (x * h)_n$。我们对 $y_n$ 进行 DFT：\n$$Y_k = \\text{DFT}\\{y_n\\} = \\sum_{n=0}^{N-1} y_n e^{-2 \\pi i nk/N}$$\n代入 $y_n$ 的定义：\n$$Y_k = \\sum_{n=0}^{N-1} \\left( \\sum_{m=0}^{N-1} x_m h_{(n-m) \\bmod N} \\right) e^{-2 \\pi i nk/N}$$\n交换求和顺序，这对于有限和是允许的：\n$$Y_k = \\sum_{m=0}^{N-1} x_m \\sum_{n=0}^{N-1} h_{(n-m) \\bmod N} e^{-2 \\pi i nk/N}$$\n我们可以通过在指数中加上和减去 $mk$ 来重写复指数项：$e^{-2 \\pi i nk/N} = e^{-2 \\pi i (n-m+m)k/N} = e^{-2 \\pi i (n-m)k/N} e^{-2 \\pi i mk/N}$。\n$$Y_k = \\sum_{m=0}^{N-1} x_m e^{-2 \\pi i mk/N} \\left( \\sum_{n=0}^{N-1} h_{(n-m) \\bmod N} e^{-2 \\pi i (n-m)k/N} \\right)$$\n让我们分析内部的求和。我们引入变量替换 $p = (n-m) \\bmod N$。当原始索引 $n$ 从 $0$ 遍历到 $N-1$ 时，新索引 $p$ 也会遍历从 $0$ 到 $N-1$ 的一个完整周期。因此，内部求和变为：\n$$\\sum_{p=0}^{N-1} h_p e^{-2 \\pi i pk/N} = \\text{DFT}\\{h_n\\} = H_k$$\n将此结果代回 $Y_k$ 的表达式中：\n$$Y_k = \\left( \\sum_{m=0}^{N-1} x_m e^{-2 \\pi i mk/N} \\right) H_k$$\n根据定义，剩余的求和是信号 $x_n$ 的 DFT，即 $X_k$。因此，我们得到了卷积定理：\n$$Y_k = X_k H_k$$\n对两边应用 IDFT 得到 $y_n = \\text{IDFT}\\{X_k H_k\\}$。这证明了时域循环卷积 $y_n = (x*h)_n$ 在理论上等同于以下频域处理流程：对 $x_n$ 进行 DFT，与 $H_k$ 相乘，然后对乘积进行 IDFT。本问题要求对此恒等式进行数值验证。\n\n算法计划如下。对于每个测试用例，我们生成一个信号 $x_n$ 和一个滤波器 $H_k$，然后通过两条不同的路径计算滤波后的信号。\n\n1.  **频域方法 (计算 $\\widehat{y}_n$)**：此方法直接应用卷积定理的推论。\n    a.  计算输入信号 $x_n$ 的 DFT，以获得其频谱 $X_k = \\text{DFT}\\{x_n\\}$。\n    b.  将信号频谱与滤波器的频率响应相乘：$\\widehat{Y}_k = X_k \\cdot H_k$。\n    c.  对得到的频谱进行 IDFT，将信号转换回时域：$\\widehat{y}_n = \\text{IDFT}\\{\\widehat{Y}_k\\}$。\n\n2.  **时域方法 (计算 $y_n$)**：此方法使用卷积的基本定义。\n    a.  首先，必须找到滤波器的冲激响应 $h_n$，即其时域表示。这通过计算频率响应 $H_k$ 的 IDFT 来实现：$h_n = \\text{IDFT}\\{H_k\\}$。\n    b.  使用提供的显式求和公式，对输入信号 $x_n$ 和冲激响应 $h_n$ 执行直接循环卷积：$y_n = (x * h)_n = \\sum_{m=0}^{N-1} x_m h_{(n-m) \\bmod N}$。根据问题的要求，这是通过算法实现的，不借助频域的快捷方式。\n\n最后，我们通过计算所有信号点上的最大绝对差来量化两种方法之间的数值差异，为了一般性使用复数绝对值：\n$$\\Delta = \\max_{0 \\le n \\le N-1} |y_n - \\widehat{y}_n|$$\n这个值 $\\Delta$ 作为每个测试用例的最终结果。由于数值计算中使用的浮点算术精度有限，我们预计 $\\Delta$ 会是一个非常小的正数（例如，数量级在 $10^{-14}$ 或更小），这在数值精度的限制内证实了该定理的有效性。\n\n实现将使用 `numpy` 库，因为它提供了高效且标准的 DFT/IDFT 实现（通过快速傅里叶变换算法）以及数组操作功能。直接循环卷积将使用嵌套循环手动实现。使用固定的随机种子以确保生成的噪声信号在不同运行中是可复现的。", "answer": "```python\nimport numpy as np\n\ndef circular_convolution(x: np.ndarray, h: np.ndarray) - np.ndarray:\n    \"\"\"\n    Computes the circular convolution of two signals x and h based on the definition.\n    (x * h)_n = sum_{m=0}^{N-1} x_m * h_{(n-m) mod N}\n    \"\"\"\n    N = len(x)\n    if len(h) != N:\n        raise ValueError(\"Signals must have the same length for circular convolution.\")\n    \n    y = np.zeros(N, dtype=np.complex128)\n    for n in range(N):\n        accumulator = 0.0 + 0.0j\n        for m in range(N):\n            # The modulo operator % in Python correctly handles negative results,\n            # which is suitable for (n-m) mod N.\n            h_index = (n - m) % N\n            accumulator += x[m] * h[h_index]\n        y[n] = accumulator\n    return y\n\ndef solve_case(N: int, m: int, sigma_noise: float, filter_type: str, sigma_f: float = None):\n    \"\"\"\n    Solves a single test case for demonstrating the convolution theorem.\n    \"\"\"\n    # 1. Construct the noisy test signal\n    n_indices = np.arange(N)\n    signal_component = np.sin(2 * np.pi * m * n_indices / N)\n    noise_component = sigma_noise * np.random.standard_normal(N)\n    x_n = signal_component + noise_component\n\n    # 2. Design the filter H_k\n    k_indices = np.arange(N)\n    if filter_type == 'gaussian':\n        d_k = np.minimum(k_indices, N - k_indices)\n        H_k = np.exp(-(d_k**2) / (2 * sigma_f**2))\n    elif filter_type == 'all-pass':\n        H_k = np.ones(N)\n    elif filter_type == 'zero':\n        H_k = np.zeros(N)\n    elif filter_type == 'notch':\n        H_k = np.ones(N)\n        H_k[m] = 0\n        H_k[N - m] = 0\n    else:\n        raise ValueError(f\"Unknown filter type: {filter_type}\")\n\n    # 3. Compute the filtered output in two ways\n\n    # Method 1: Frequency-domain multiplication\n    X_k = np.fft.fft(x_n)\n    Y_hat_k = X_k * H_k\n    y_hat_n = np.fft.ifft(Y_hat_k)\n\n    # Method 2: Time-domain circular convolution\n    h_n = np.fft.ifft(H_k)\n    y_n = circular_convolution(x_n, h_n)\n\n    # 4. Quantify the difference\n    delta = np.max(np.abs(y_n - y_hat_n))\n    return delta\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Fixed seed for reproducibility as required\n    np.random.seed(0)\n\n    test_cases = [\n        {'N': 256, 'm': 5, 'sigma_noise': 0.4, 'filter_type': 'gaussian', 'sigma_f': 10.0},\n        {'N': 128, 'm': 12, 'sigma_noise': 0.6, 'filter_type': 'all-pass'},\n        {'N': 128, 'm': 12, 'sigma_noise': 0.6, 'filter_type': 'zero'},\n        {'N': 256, 'm': 40, 'sigma_noise': 0.5, 'filter_type': 'notch'}\n    ]\n\n    results = []\n    for case in test_cases:\n        delta = solve_case(\n            N=case['N'], \n            m=case['m'], \n            sigma_noise=case['sigma_noise'], \n            filter_type=case['filter_type'],\n            sigma_f=case.get('sigma_f') # Pass sigma_f only if it exists\n        )\n        results.append(delta)\n\n    # Format the output as specified\n    print(f\"[{','.join(f'{r:.17e}' for r in results)}]\")\n\nsolve()\n```", "id": "3219731"}, {"introduction": "卷积定理的威力远不止于简化计算，它更是一个强大的分析工具，尤其是在解决逆问题时。本练习提出了一个“解卷积”问题：已知一个系统的输出信号和其冲激响应，如何反推出原始的输入信号？这个问题在时域中是一个复杂的积分方程，但借助卷积定理，它在频域中可以被转化为简单的代数除法，清晰地展示了该定理解决实际工程问题的强大能力。[@problem_id:540096]", "problem": "考虑一个线性时不变 (LTI) 系统，其输入-输出关系由卷积积分 $y(t) = (x * h)(t) = \\int_{-\\infty}^{\\infty} x(\\tau) h(t-\\tau) d\\tau$ 描述，其中 $x(t)$ 是输入信号，$h(t)$ 是系统的冲激响应，$y(t)$ 是输出信号。\n\n分析将在连续时间域中使用傅里叶变换进行，其定义为 $F(\\omega) = \\mathcal{F}\\{f(t)\\} = \\int_{-\\infty}^{\\infty} f(t) e^{-i\\omega t} dt$。其逆变换由下式给出 $f(t) = \\mathcal{F}^{-1}\\{F(\\omega)\\} = \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} F(\\omega) e^{i\\omega t} d\\omega$。\n\n我们定义两种基本脉冲形状：\n1. 单位矩形脉冲：$\\Pi(t) = \\begin{cases} 1,  |t|  1/2 \\\\ 0,  |t|  1/2 \\end{cases}$\n2. 单位三角脉冲：$\\Lambda(t) = \\begin{cases} 1 - |t|,  |t|  1 \\\\ 0,  |t|  1 \\end{cases}$\n\n该LTI系统的冲激响应是一个幅度为 $A$、宽度为 $W$ 的矩形脉冲：\n$$h(t) = A \\cdot \\Pi\\left(\\frac{t}{W}\\right)$$\n当某个未知的输入信号 $x(t)$ 应用于该系统时，观测到的输出是一个幅度为 $B$、总基底宽度为 $4W$ 的三角脉冲：\n$$y(t) = B \\cdot \\Lambda\\left(\\frac{t}{2W}\\right)$$\n在此，$A$、$B$ 和 $W$ 是正常数。\n\n您的任务是确定产生此输出的输入信号 $x(t)$。请用 $A$、$B$、$W$ 和单位矩形脉冲函数 $\\Pi(t)$ 将您的最终答案表示为单个闭式解析表达式。", "solution": "LTI系统的输入 $x(t)$、冲激响应 $h(t)$ 和输出 $y(t)$ 之间的关系由卷积 $y(t) = (x*h)(t)$ 给出。\n\n根据卷积定理，两个信号卷积的傅里叶变换是它们各自傅里叶变换的乘积。设 $X(\\omega)$、$H(\\omega)$ 和 $Y(\\omega)$ 分别是 $x(t)$、$h(t)$ 和 $y(t)$ 的傅里叶变换。那么，\n$$Y(\\omega) = X(\\omega) H(\\omega)$$\n为了找到输入信号 $x(t)$，我们可以首先求解其傅里叶变换 $X(\\omega)$：\n$$X(\\omega) = \\frac{Y(\\omega)}{H(\\omega)}$$\n然后，通过对 $X(\\omega)$ 进行傅里叶逆变换来找到 $x(t)$。\n\n**步骤1：计算冲激响应 $h(t)$ 的傅里叶变换**\n冲激响应为 $h(t) = A \\cdot \\Pi\\left(\\frac{t}{W}\\right)$。\n首先，我们求单位矩形脉冲 $\\Pi(t)$ 的傅里叶变换：\n$$\\mathcal{F}\\{\\Pi(t)\\} = \\int_{-1/2}^{1/2} 1 \\cdot e^{-i\\omega t} dt = \\left[\\frac{e^{-i\\omega t}}{-i\\omega}\\right]_{-1/2}^{1/2} = \\frac{e^{-i\\omega/2} - e^{i\\omega/2}}{-i\\omega} = \\frac{2\\sin(\\omega/2)}{\\omega} = \\text{sinc}\\left(\\frac{\\omega}{2}\\right)$$\n使用傅里叶变换的尺度变换性质 $\\mathcal{F}\\{f(at)\\} = \\frac{1}{|a|}F(\\frac{\\omega}{a})$，其中 $a=1/W$：\n$$\\mathcal{F}\\left\\{\\Pi\\left(\\frac{t}{W}\\right)\\right\\} = W \\cdot \\frac{2\\sin(W\\omega/2)}{W\\omega} = W \\cdot \\text{sinc}\\left(\\frac{W\\omega}{2}\\right)$$\n因此，$h(t)$ 的傅里叶变换是：\n$$H(\\omega) = \\mathcal{F}\\left\\{A \\cdot \\Pi\\left(\\frac{t}{W}\\right)\\right\\} = A W \\cdot \\text{sinc}\\left(\\frac{W\\omega}{2}\\right) = A W \\frac{\\sin(W\\omega/2)}{W\\omega/2}$$\n\n**步骤2：计算输出信号 $y(t)$ 的傅里叶变换**\n输出信号为 $y(t) = B \\cdot \\Lambda\\left(\\frac{t}{2W}\\right)$。\n单位三角脉冲可以表示为单位矩形脉冲与自身的卷积：$\\Lambda(t) = \\Pi(t) * \\Pi(t)$。\n使用卷积定理，其傅里叶变换为：\n$$\\mathcal{F}\\{\\Lambda(t)\\} = \\mathcal{F}\\{\\Pi(t)\\} \\cdot \\mathcal{F}\\{\\Pi(t)\\} = \\left(\\text{sinc}\\left(\\frac{\\omega}{2}\\right)\\right)^2$$\n现在，我们应用尺度变换性质，其中 $a = 1/(2W)$：\n$$\\mathcal{F}\\left\\{\\Lambda\\left(\\frac{t}{2W}\\right)\\right\\} = 2W \\cdot \\left(\\text{sinc}\\left(\\frac{2W\\omega}{2}\\right)\\right)^2 = 2W \\cdot \\text{sinc}^2(W\\omega)$$\n因此，输出 $y(t)$ 的傅里叶变换为：\n$$Y(\\omega) = \\mathcal{F}\\left\\{B \\cdot \\Lambda\\left(\\frac{t}{2W}\\right)\\right\\} = 2BW \\cdot \\text{sinc}^2(W\\omega) = 2BW \\left(\\frac{\\sin(W\\omega)}{W\\omega}\\right)^2$$\n\n**步骤3：求解 $X(\\omega)$**\n$$X(\\omega) = \\frac{Y(\\omega)}{H(\\omega)} = \\frac{2BW \\left(\\frac{\\sin(W\\omega)}{W\\omega}\\right)^2}{AW \\frac{\\sin(W\\omega/2)}{W\\omega/2}} = \\frac{2B}{A} \\frac{\\sin^2(W\\omega)}{(W\\omega)^2} \\frac{W\\omega/2}{\\sin(W\\omega/2)}$$\n$$X(\\omega) = \\frac{B}{A} \\frac{\\sin^2(W\\omega)}{W\\omega \\sin(W\\omega/2)}$$\n使用倍角公式 $\\sin(2\\theta) = 2\\sin(\\theta)\\cos(\\theta)$，我们有 $\\sin(W\\omega) = 2\\sin(W\\omega/2)\\cos(W\\omega/2)$。\n$$X(\\omega) = \\frac{B}{A} \\frac{\\left(2\\sin(W\\omega/2)\\cos(W\\omega/2)\\right)^2}{W\\omega \\sin(W\\omega/2)} = \\frac{B}{A} \\frac{4\\sin^2(W\\omega/2)\\cos^2(W\\omega/2)}{W\\omega \\sin(W\\omega/2)}$$\n$$X(\\omega) = \\frac{4B}{A} \\frac{\\sin(W\\omega/2)\\cos^2(W\\omega/2)}{W\\omega} = \\frac{2B}{A} \\frac{\\sin(W\\omega/2)}{W\\omega/2} \\cos^2(W\\omega/2)$$\n使用恒等式 $\\cos^2(\\theta) = \\frac{1+\\cos(2\\theta)}{2}$：\n$$X(\\omega) = \\frac{2B}{A} \\frac{\\sin(W\\omega/2)}{W\\omega/2} \\left(\\frac{1+\\cos(W\\omega)}{2}\\right) = \\frac{B}{A} \\left( \\frac{\\sin(W\\omega/2)}{W\\omega/2} + \\frac{\\sin(W\\omega/2)\\cos(W\\omega)}{W\\omega/2} \\right)$$\n使用积化和差恒等式 $\\sin(\\alpha)\\cos(\\beta) = \\frac{1}{2}[\\sin(\\alpha+\\beta) + \\sin(\\alpha-\\beta)]$：\n$$\\sin(W\\omega/2)\\cos(W\\omega) = \\frac{1}{2}[\\sin(3W\\omega/2) + \\sin(-W\\omega/2)] = \\frac{1}{2}[\\sin(3W\\omega/2) - \\sin(W\\omega/2)]$$\n将此代回 $X(\\omega)$ 的表达式中：\n$$X(\\omega) = \\frac{B}{A} \\left( \\frac{\\sin(W\\omega/2)}{W\\omega/2} + \\frac{\\frac{1}{2}[\\sin(3W\\omega/2) - \\sin(W\\omega/2)]}{W\\omega/2} \\right)$$\n$$X(\\omega) = \\frac{B}{A} \\left( \\frac{2\\sin(W\\omega/2)}{W\\omega} + \\frac{\\sin(3W\\omega/2)}{W\\omega} - \\frac{\\sin(W\\omega/2)}{W\\omega} \\right)$$\n$$X(\\omega) = \\frac{B}{A W} \\left( \\frac{\\sin(W\\omega/2)}{\\omega} + \\frac{\\sin(3W\\omega/2)}{\\omega} \\right)$$\n\n**步骤4：计算 $X(\\omega)$ 的傅里叶逆变换以求得 $x(t)$**\n我们需要找到形如 $\\frac{\\sin(k\\omega)}{\\omega}$ 的项的傅里叶逆变换。从矩形脉冲的变换对可知：\n$$\\mathcal{F}\\left\\{\\Pi\\left(\\frac{t}{2k}\\right)\\right\\} = 2k \\frac{\\sin(k\\omega)}{k\\omega} = \\frac{2\\sin(k\\omega)}{\\omega}$$\n因此，逆变换为：\n$$\\mathcal{F}^{-1}\\left\\{\\frac{\\sin(k\\omega)}{\\omega}\\right\\} = \\frac{1}{2}\\Pi\\left(\\frac{t}{2k}\\right)$$\n对于 $X(\\omega)$ 中的第一项，$k_1 = W/2$：\n$$\\mathcal{F}^{-1}\\left\\{\\frac{\\sin(W\\omega/2)}{\\omega}\\right\\} = \\frac{1}{2}\\Pi\\left(\\frac{t}{2(W/2)}\\right) = \\frac{1}{2}\\Pi\\left(\\frac{t}{W}\\right)$$\n对于第二项，$k_2 = 3W/2$：\n$$\\mathcal{F}^{-1}\\left\\{\\frac{\\sin(3W\\omega/2)}{\\omega}\\right\\} = \\frac{1}{2}\\Pi\\left(\\frac{t}{2(3W/2)}\\right) = \\frac{1}{2}\\Pi\\left(\\frac{t}{3W}\\right)$$\n结合这些结果：\n$$x(t) = \\mathcal{F}^{-1}\\{X(\\omega)\\} = \\frac{B}{AW} \\left[ \\frac{1}{2}\\Pi\\left(\\frac{t}{W}\\right) + \\frac{1}{2}\\Pi\\left(\\frac{t}{3W}\\right) \\right]$$\n$$x(t) = \\frac{B}{2AW} \\left[ \\Pi\\left(\\frac{t}{W}\\right) + \\Pi\\left(\\frac{t}{3W}\\right) \\right]$$\n这个表达式是两个中心对齐、宽度不同的矩形脉冲之和。$\\Pi(t/W)$ 的宽度为 $W$，$\\Pi(t/3W)$ 的宽度为 $3W$。\n得到的信号是一个两级或‘婚礼蛋糕’脉冲。\n- 对于 $|t|  W/2$，$\\Pi(t/W)$ 和 $\\Pi(t/3W)$ 均为 1。高度为 $\\frac{B}{2AW}(1+1) = \\frac{B}{AW}$。\n- 对于 $W/2 \\le |t|  3W/2$，$\\Pi(t/W)=0$ 且 $\\Pi(t/3W)=1$。高度为 $\\frac{B}{2AW}(0+1) = \\frac{B}{2AW}$。\n- 对于 $|t| \\ge 3W/2$，两项都为零。\n最终的表达式是最紧凑的解析形式。", "answer": "$$ \\boxed{\\frac{B}{2AW} \\left[ \\Pi\\left(\\frac{t}{W}\\right) + \\Pi\\left(\\frac{t}{3W}\\right) \\right]} $$", "id": "540096"}]}