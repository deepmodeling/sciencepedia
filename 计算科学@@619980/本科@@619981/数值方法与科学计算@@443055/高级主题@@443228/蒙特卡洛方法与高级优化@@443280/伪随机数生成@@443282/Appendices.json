{"hands_on_practices": [{"introduction": "构建伪随机数生成器（PRNG）只是第一步；验证其输出的质量同样至关重要。本练习将引导你从零开始实现一个线性同余生成器（LCG），并应用统计学中最基本的工具之一——皮尔逊卡方检验（Pearson's chi-squared test），来评估其序列的均匀性 [@problem_id:3264207]。通过亲手实现整个检验过程，你将不仅学会一种重要的质量评估方法，还会深化对计算背景下统计检验核心机制的理解。", "problem": "要求您从基本原理出发，实现一个皮尔逊卡方检验，以测试自定义伪随机数生成器 (PRNG) 输出的均匀性。伪随机数生成器 (PRNG) 是指任何一种确定性算法，其生成的序列旨在模拟来自某个目标分布的独立样本。在本任务中，PRNG 将是一个线性同余生成器 (LCG)，目标分布是区间 $\\left[0,1\\right)$ 上的连续均匀分布。\n\n从核心定义和经过充分检验的事实出发，实现以下内容：\n\n- 构建一个线性同余生成器 (LCG)，其整数状态的更新规则定义为：下一个状态等于 (当前状态乘以乘数加上增量) 对模数取模的结果。通过将每个整数状态除以模数，将其映射到 $\\left[0,1\\right)$ 区间内的一个实数。LCG 状态更新使用整数算术，并生成恰好 $n$ 个样本。\n- 将区间 $\\left[0,1\\right)$ 划分为 $k$ 个等宽的子区间（或称“箱”）。根据生成的样本，计算观测到的各箱频数。在完全均匀的假设下，每个箱的期望频数是总样本数除以箱数。\n- 根据观测频数和期望频数计算皮尔逊卡方统计量。为卡方分布使用正确的自由度。\n- 使用正则化上不完全伽马函数计算卡方分布的上尾 $p$ 值。您必须通过数值方法实现此计算，不得使用黑盒式的统计检验函数。为了提高数值稳定性，可以使用伽马函数的自然对数。\n- 通过将 $p$ 值与给定的十进制显著性水平 $\\alpha$ 进行比较，来决定是否接受均匀性假设。当 $p$ 值大于或等于 $\\alpha$ 时，接受均匀性假设，否则拒绝。\n\n实现约束：\n\n- 程序必须是一个完整、可运行的程序，且仅使用 Python 标准库和指定版本的 Numerical Python (NumPy) 库。\n- PRNG 必须是自行构建的，不得使用任何外部随机源。\n- $p$ 值的计算必须通过对正则化上不完全伽马函数进行数值稳定的求值来实现，避免使用任何外部统计库。\n\n测试套件：\n\n请提供以下参数集的结果。每个集合是一个元组 $\\left(m,a,c,s,n,k,\\alpha\\right)$，包含模数 $m$、乘数 $a$、增量 $c$、种子 $s$、样本大小 $n$、箱数 $k$ 和显著性水平 $\\alpha$。\n\n- 案例 1 (理想情况，广泛使用的参数)：$\\left(2^{31}-1,16807,0,1,100000,100,0.01\\right)$。\n- 案例 2 (退化生成器，常数序列)：$\\left(2^{16},1,0,12345,10000,50,0.01\\right)$。\n- 案例 3 (乘法 LCG 的退化种子)：$\\left(2^{31}-1,16807,0,0,10000,50,0.01\\right)$。\n- 案例 4 (临界可靠性：每箱期望频数较小)：$\\left(2^{31}-1,16807,0,1,200,50,0.05\\right)$。\n- 案例 5 (模数过小导致短周期)：$\\left(8,5,0,1,1000,10,0.01\\right)$。\n\n最终输出规范：\n\n- 对每个案例，输出一个布尔值，表示在显著性水平 $\\alpha$ 下是否接受均匀性假设。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内无空格，并按上述案例的顺序排列结果。例如：$\\left[\\text{result1},\\text{result2},\\text{result3},\\text{result4},\\text{result5}\\right]$，其中每个结果为 $\\text{True}$ 或 $\\text{False}$。", "solution": "我们通过整合将 PRNG 输出与统计决策过程联系起来的定义和性质来构建解决方案。\n\n首先，定义一个线性同余生成器 (LCG)。给定整数 $m$、$a$、$c$ 和一个初始种子 $s$，LCG 的状态通过以下方式演变\n$$\nX_{n+1} = \\left(a X_n + c\\right) \\bmod m,\n$$\n其中 $X_0 = s$。每个状态 $X_n \\in \\{0,1,\\ldots,m-1\\}$ 被映射到一个实数样本\n$$\nU_n = \\frac{X_n}{m},\n$$\n该样本位于区间 $\\left[0,1\\right)$ 内。\n\n为了评估 $\\{U_n\\}$ 的均匀性，我们将区间 $\\left[0,1\\right)$ 划分为 $k$ 个等宽的不相交区间（箱）。设这些箱为\n$$\nB_i = \\left[\\frac{i}{k}, \\frac{i+1}{k}\\right), \\quad i = 0,1,\\ldots,k-1.\n$$\n通过计算落入 $B_i$ 的样本数量来定义观测频数 $O_i$。在完全均匀分布的假设下，样本落入任何一个箱的概率是 $1/k$，因此每个箱的期望频数是\n$$\nE = \\frac{n}{k},\n$$\n其中 $n$ 是总样本数。\n\n用于检验均匀性的皮尔逊卡方统计量是\n$$\n\\chi^2 = \\sum_{i=0}^{k-1} \\frac{\\left(O_i - E\\right)^2}{E}.\n$$\n在均匀性原假设下，只要 $n$ 足够大且期望频数不太小，该统计量近似服从自由度为\n$$\n\\nu = k - 1\n$$\n的卡方分布。卡方分布是伽马分布的一个特例：如果 $X \\sim \\chi^2_\\nu$，那么 $X$ 服从形状参数为 $\\nu/2$、尺度参数为 $2$ 的伽马分布。因此，对于一个观测值 $\\chi^2$，其上尾 $p$ 值与正则化上不完全伽马函数相关。具体来说，\n$$\np = Q\\left(\\frac{\\nu}{2},\\frac{\\chi^2}{2}\\right),\n$$\n其中 $Q(a,x)$ 是正则化上不完全伽马函数，定义为\n$$\nQ(a,x) = \\frac{\\Gamma(a,x)}{\\Gamma(a)},\n$$\n而 $\\Gamma(a,x)$ 是上不完全伽马函数，$\\Gamma(a)$ 是伽马函数。\n\n为了在不使用黑盒函数的情况下数值计算 $Q(a,x)$，我们使用两种互补的展开式以确保数值稳定性（如标准数值分析文献中所述）。设 $a>0$ 且 $x \\ge 0$。引入公共前置因子\n$$\n\\mathrm{pref}(a,x) = \\exp\\left(a \\ln x - x - \\ln \\Gamma(a)\\right).\n$$\n然后使用：\n- 当 $x < a+1$ 时，使用正则化下不完全伽马函数 $P(a,x)$ 的收敛级数\n$$\nP(a,x) = \\mathrm{pref}(a,x) \\sum_{n=0}^{\\infty} \\frac{x^n}{a (a+1) \\cdots (a+n)},\n$$\n该级数通过其项的递推关系实现，并返回 $Q(a,x) = 1 - P(a,x)$。\n- 当 $x \\ge a+1$ 时，使用 $Q(a,x)$ 的连分式\n$$\nQ(a,x) = \\mathrm{pref}(a,x) \\cdot \\left[ \\cfrac{1}{x+1-a - \\cfrac{1 \\cdot (1-a)}{x+3-a - \\cfrac{2 \\cdot (2-a)}{x+5-a - \\cdots}}} \\right],\n$$\n该连分式通过使用标准保护措施（微小值初始化和收敛容差）的稳定前向迭代进行求值。\n\n给定计算出的 $p$ 值，应用在显著性水平 $\\alpha$ 下的决策规则：\n$$\n\\text{接受均匀性假设} \\quad \\Leftrightarrow \\quad p \\ge \\alpha.\n$$\n\n算法设计：\n\n- 在 LCG 中使用整数算术生成 $n$ 个样本。通过除以 $m$ 将状态映射到 $\\left[0,1\\right)$ 内的实数。\n- 通过 $b(U_n) = \\min\\left(\\left\\lfloor k U_n \\right\\rfloor, k-1\\right)$ 计算箱索引，以确保索引在 $\\{0,1,\\ldots,k-1\\}$ 范围内。\n- 通过类似直方图的计算累积观测频数 $O_i$。\n- 计算 $E = n/k$，然后通过归一化偏差的平方和计算 $\\chi^2$。\n- 令 $\\nu = k-1$，计算 $a = \\nu/2$ 和 $x = \\chi^2/2$，使用上述分段策略计算 $Q(a,x)$，并将 $p$ 与 $\\alpha$ 比较。\n\n边界情况考虑：\n\n- 退化生成器（例如 $a=1, c=0$）会产生一个常数序列，将所有样本集中在一个箱中，这会导致极大的 $\\chi^2$ 值和 $p \\approx 0$，因此假设被拒绝。\n- 种子 $s=0$ 的乘法 LCG 会对所有 $n$ 产生 $U_n=0$ 的结果，同样导致假设被拒绝。\n- 当 $n$ 较小而 $k$ 较大时，期望频数 $E=n/k$ 可能很小，导致卡方近似的准确性降低。算法仍然会计算出一个有效的统计量和 $p$ 值，但在这种情况下应谨慎解释决策结果。\n\n该程序评估五个指定案例，并输出一行由五个布尔值组成的、用方括号括起来的、以逗号分隔且无空格的字符串，这些布尔值按顺序对应于每个案例的接受决策。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef lcg_generate(m: int, a: int, c: int, seed: int, n: int) -> np.ndarray:\n    \"\"\"\n    Generate n samples in [0,1) using a Linear Congruential Generator (LCG):\n    X_{n+1} = (a * X_n + c) mod m, with X_0 = seed.\n    Returns a NumPy array of floats in [0,1).\n    \"\"\"\n    samples = np.empty(n, dtype=np.float64)\n    state = seed % m\n    for i in range(n):\n        # Map current state to [0,1)\n        samples[i] = state / m\n        # Advance state\n        state = (a * state + c) % m\n    return samples\n\ndef chi_square_uniformity(samples: np.ndarray, k: int):\n    \"\"\"\n    Compute Pearson chi-squared statistic for uniformity over k equal bins on [0,1).\n    Returns (chi2_stat, p_value).\n    \"\"\"\n    n = samples.size\n    # Bin indices: floor(k * x), clipped to k-1 to guard against edge\n    bin_indices = np.minimum((samples * k).astype(np.int64), k - 1)\n    counts = np.bincount(bin_indices, minlength=k)\n    expected = n / k\n    # Chi-squared statistic: sum((O_i - E)^2 / E)\n    diffs = counts - expected\n    chi2 = np.sum((diffs * diffs) / expected)\n    # Degrees of freedom\n    v = k - 1\n    # Upper-tail p-value using regularized upper incomplete gamma:\n    # p = Q(v/2, chi2/2)\n    a = 0.5 * v\n    x = 0.5 * chi2\n    p = gammaincc(a, x)\n    return chi2, p\n\ndef gammaincc(a: float, x: float) -> float:\n    \"\"\"\n    Regularized upper incomplete gamma function Q(a, x) = Gamma(a, x) / Gamma(a).\n    Implements the Numerical Recipes-style algorithm with series for P(a, x) when x < a+1,\n    and continued fraction for Q(a, x) when x >= a+1.\n    \"\"\"\n    if a <= 0.0 or x < 0.0:\n        raise ValueError(\"Invalid arguments for gammaincc: require a > 0 and x >= 0.\")\n    if x == 0.0:\n        return 1.0\n    # Common prefactor: exp(a*ln(x) - x - lnGamma(a))\n    ln_gamma_a = math.lgamma(a)\n    lnpref = a * math.log(x) - x - ln_gamma_a\n    pref = math.exp(lnpref)\n    # Switch by x relative to a+1\n    if x < a + 1.0:\n        # Compute P(a, x) via series\n        return 1.0 - _gammainc_lower_reg_series(a, x, pref)\n    else:\n        # Compute Q(a, x) via continued fraction\n        return _gammainc_upper_reg_cf(a, x, pref)\n\ndef _gammainc_lower_reg_series(a: float, x: float, pref: float) -> float:\n    \"\"\"\n    Regularized lower incomplete gamma P(a, x) via series expansion.\n    Returns P(a, x).\n    \"\"\"\n    eps = 1e-14\n    max_iter = 100000\n    sum_term = 1.0 / a\n    term = sum_term\n    ap = a\n    for n in range(1, max_iter + 1):\n        ap += 1.0\n        term *= x / ap\n        sum_term += term\n        if abs(term) < abs(sum_term) * eps:\n            break\n    return pref * sum_term\n\ndef _gammainc_upper_reg_cf(a: float, x: float, pref: float) -> float:\n    \"\"\"\n    Regularized upper incomplete gamma Q(a, x) via continued fraction.\n    Returns Q(a, x).\n    \"\"\"\n    eps = 1e-14\n    max_iter = 100000\n    tiny = 1e-300\n    b = x + 1.0 - a\n    c = 1.0 / tiny\n    d = 1.0 / b\n    h = d\n    for i in range(1, max_iter + 1):\n        an = -i * (i - a)\n        b += 2.0\n        d = 1.0 / (an * d + b)\n        c = b + an / c\n        if c == 0.0:\n            c = tiny\n        del_cf = d * c\n        h *= del_cf\n        if abs(del_cf - 1.0) < eps:\n            break\n    return pref * h\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (m, a, c, seed, n, k, alpha)\n    test_cases = [\n        (2**31 - 1, 16807, 0, 1, 100000, 100, 0.01),   # Case 1: Park-Miller minimal standard\n        (2**16, 1, 0, 12345, 10000, 50, 0.01),         # Case 2: Degenerate generator (constant)\n        (2**31 - 1, 16807, 0, 0, 10000, 50, 0.01),     # Case 3: Seed zero degeneracy\n        (2**31 - 1, 16807, 0, 1, 200, 50, 0.05),       # Case 4: Borderline small expected count\n        (8, 5, 0, 1, 1000, 10, 0.01),                  # Case 5: Very small modulus, short cycle\n    ]\n\n    results = []\n    for case in test_cases:\n        m, a, c, seed, n, k, alpha = case\n        samples = lcg_generate(m, a, c, seed, n)\n        chi2, pval = chi_square_uniformity(samples, k)\n        accept = pval >= alpha\n        results.append(accept)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3264207"}, {"introduction": "一个伪随机数生成器即便通过了一维均匀性检验（如卡方检验），也可能隐藏着更深层次的缺陷。本练习将揭示简单生成器的一个著名“阿喀琉斯之踵”：高维度的相关性 [@problem_id:3264088]。你将通过生成和分析序列的连续点对 $(U_i, U_{i+1})$，亲眼见证并量化线性同余生成器固有的晶格结构（lattice structure），这是任何依赖PRNG进行多维模拟的科学家都必须警惕的陷阱。", "problem": "考虑由整数模的剩余类上的确定性映射产生的序列，以及它们在归一化到单位区间后的行为。设 $m \\in \\mathbb{N}$，并设 $(X_i)_{i \\ge 0}$ 是一个序列，其中 $X_i \\in \\{0,1,\\dots,m-1\\}$，其归一化形式为 $U_i = X_i / m \\in [0,1)$。一维边际均匀性被离散地定义为在一个完整周期内恰好访问每个剩余类一次，而二维结构则通过连续对 $(U_i, U_{i+1})$ 的几何形状来评估。\n\n从模算术和剩余类双射的基本定义出发，设计并实现能够产生具有以下性质的序列的生成器：\n- 一个生成器，其在 $\\{0,1,\\dots,m-1\\}$ 上的一维边际分布是完全均匀的，即在一个周期内每个剩余类都恰好出现一次。\n- 一个生成器，其连续对 $(X_i, X_{i+1})$ 满足一个线性模关系，使得归一化后的 $(U_i,U_{i+1})$ 在二维空间中展示出易于检测的几何结构。\n\n你的程序必须：\n1. 生成每个测试用例所需的序列。\n2. 为每个测试用例计算以下定量指标，所有指标都基于归一化对 $(U_i, U_{i+1})$：\n    - 一维均匀性比率，定义为 $|\\mathrm{VisitedStates}| / m$，其中 $|\\mathrm{VisitedStates}|$ 是在一个检测到的周期内观察到的 $\\{X_i\\}$ 中不同值的数量。该比率为 $[0,1]$ 内的一个实数。\n    - 在 $[0,1) \\times [0,1)$ 上大小为 $G \\times G$ 的均匀网格的占据数，定义为由点对集合 $(U_i, U_{i+1})$ 所击中的不同网格单元的数量，单元格索引为 $(\\lfloor G U_i \\rfloor, \\lfloor G U_{i+1} \\rfloor)$。该计数是一个整数。\n    - 点对云 $(U_i,U_{i+1})$ 各分量之间的皮尔逊相关系数，基于所有可用的点对计算。该系数是一个实数。\n    - 在宽度为 $m/G$ 的粗略分箱下，模差 $(X_{i+1} - X_i) \\bmod m$ 的不同仓位数量，即 $\\left\\lfloor \\frac{(X_{i+1} - X_i) \\bmod m}{m/G} \\right\\rfloor$ 的不同值的计数。该计数是一个整数。\n\n仅使用模算术和剩余类双射的定义作为基本依据。不要依赖任何未经证明的快捷公式。你必须从第一性原理推导出为什么一维边际分布可以完全均匀，并同时解释为什么二维连续对图可以显示出可见的结构。\n\n实现以下测试套件，其设计旨在覆盖一般情况、边界情况和比较情况。对于所有情况，使用 $G = 64$：\n- 情况 A（加法同余满周期）：模数 $m = 4096$，增量 $c = 5$，种子 $X_0 = 0$。通过连续模 $m$ 加 $c$ 来生成序列，直到状态重复，然后在第一次重复时停止。\n- 情况 B（加法同余短周期边界情况）：模数 $m = 4096$，增量 $c = 512$，种子 $X_0 = 0$。通过连续模 $m$ 加法生成序列，直到状态重复，然后停止。\n- 情况 C（线性同余一般情况）：模数 $m = 4096$，乘数 $a = 5$，增量 $c = 1$，种子 $X_0 = 1$。通过重复应用模 $m$ 的线性映射来生成序列，直到状态重复，然后停止。\n- 情况 D（独立均匀基线）：模数 $m = 4096$，种子 $s = 12345$。生成 $m$ 个独立样本 $U_i \\in [0,1)$，设置 $X_i = \\lfloor m U_i \\rfloor$，并使用前 $m$ 个值，不进行周期检测。\n\n对于每种情况，使用所有可用的连续对 $(U_i, U_{i+1})$ 计算上述四个指标，其中索引 $i$ 遍历该情况下生成的序列位置，并且在对不环绕时，在最后一个元素前停止。将所有量表示为无单位的纯数。\n\n你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个情况的结果是一个四元列表，顺序为：[均匀性比率, 占据数, 相关系数, 差值分箱数]。例如，输出应类似于 $[[r_1,o_1,\\rho_1,b_1],[r_2,o_2,\\rho_2,b_2],[r_3,o_3,\\rho_3,b_3],[r_4,o_4,\\rho_4,b_4]]$，不含多余的空格或文本。", "solution": "该问题要求分析和实现通过模算术生成的确定性序列，这种序列常用于伪随机数生成。任务的核心是从第一性原理出发，理解这些序列的性质，特别是一维均匀性和二维结构。\n\n## 基本原理\n\n### 模算术与 LCG\n序列 $(X_i)_{i \\ge 0}$ 在模 $m$ 的剩余类集合 $\\mathbb{Z}_m = \\{0, 1, \\dots, m-1\\}$ 中生成。这类生成器中被广泛研究的一类是线性同余生成器 (LCG)，由以下递推关系定义：\n$$X_{i+1} = (a X_i + c) \\bmod m$$\n其中 $m > 0$ 是模数，$a$ 是乘数，$c$ 是增量，$X_0$ 是种子。当 $a=1$ 时，该生成器称为加法同余生成器 (ACG)。归一化序列由 $U_i = X_i/m \\in [0, 1)$ 给出。\n\n### 一维均匀性与周期性\n一个好的生成器的一个关键属性是长周期。周期是满足对于所有 $i$ 都有 $X_{i+p} = X_i$ 的最小正整数 $p$。为了使生成器最大限度地有用，我们希望周期尽可能大。一个 LCG 具有满周期 $m$ 当且仅当它在重复之前恰好生成 $\\{0, 1, \\dots, m-1\\}$ 中的每个整数一次。这赋予了完美的一维边际均匀性，意味着均匀性比率 $|\\mathrm{VisitedStates}|/m$ 恰好为 $1$。\n\n达到满周期的条件取决于参数 $a$、$c$ 和 $m$。\n1.  **对于 ACG ($a=1$)：** 递推关系为 $X_{i+1} = (X_i + c) \\bmod m$。状态序列是一个模 $m$ 的算术级数。该序列具有满周期 $m$ 当且仅当增量 $c$ 是加法群 $\\mathbb{Z}_m$ 的一个生成元，这要求 $c$ 与 $m$ 互质。即 $\\gcd(c, m) = 1$。如果 $\\gcd(c, m) = d > 1$，则周期缩短为 $m/d$。\n\n2.  **对于 LCG ($a>1$)：** 当模数 $m$ 是 2 的幂时，比如对于 $k \\ge 2$ 有 $m = 2^k$，著名的 Hull-Dobell 定理指出，LCG 具有满周期 $m$ 当且仅当：\n    -   $c$ 是奇数（即 $\\gcd(c, m) = 1$）。\n    -   $a \\equiv 1 \\pmod 4$。\n\n### 二维结构\nLCG 的确定性性质为连续对 $(X_i, X_{i+1})$ 强加了一个刚性结构。对 LCG 递推关系进行归一化，我们得到：\n$$m U_{i+1} = (a m U_i + c) \\pmod m$$\n两边同除以 $m$ 得到：\n$$U_{i+1} = (a U_i + c/m) \\pmod 1$$\n这个方程揭示了所有连续对 $(U_i, U_{i+1})$ 都位于有限数量的平行超平面上。在二维空间中，这些是直线。具体来说，这些点落在由 $y = ax + c/m - k$ 定义的线段上，其中 $k$ 为整数，使得该直线与单位正方形 $[0,1) \\times [0,1)$ 相交。这种内在的晶格结构是一种“易于检测的几何结构”，也是 LCG 的一个众所周知的弱点，而指定的指标就是为了量化这一点。\n\n## 测试用例分析\n\n对于所有情况，用于占据指标的网格大小为 $G=64$。\n\n**情况 A：加法同余，满周期**\n($m=4096$, $c=5$, $X_0=0$, $a=1$)\n-   **均匀性：** $m=4096=2^{12}$ 且 $c=5$。因为 $5$ 是一个奇数，它与 2 的幂没有公因子，所以 $\\gcd(5, 4096)=1$。该 ACG 具有 $m=4096$ 的满周期。序列会恰好访问 $\\{0, \\dots, 4095\\}$ 中的每个状态一次。均匀性比率为 $4096/4096 = 1.0$。\n-   **结构：** 点对 $(U_i, U_{i+1})$ 满足 $U_{i+1} = (U_i + 5/4096) \\pmod 1$。这些点位于两条平行线上。预计会存在强正相关。模差 $(X_{i+1} - X_i) \\bmod m$ 恒为 $5$。这个单一值落入仓位 $\\lfloor 5 / (4096/64) \\rfloor = \\lfloor 5/64 \\rfloor = 0$。因此，差值分箱数为 $1$。\n\n**情况 B：加法同余，短周期**\n($m=4096$, $c=512$, $X_0=0$, $a=1$)\n-   **均匀性：** 这里，$c=512=2^9$。最大公约数为 $\\gcd(512, 4096) = 512$。周期是 $m/\\gcd(c,m) = 4096/512 = 8$。序列只访问 $8$ 个状态。均匀性比率为 $8/4096 = 1/512$。\n-   **结构：** 这 $8$ 个状态都是 $512$ 的倍数。点对 $(U_i, U_{i+1})$ 位于一条直线 $y=x+1/8$ 上。相关性将是完美的。模差恒为 $512$，落入仓位 $\\lfloor 512 / 64 \\rfloor = 8$。差值分箱数为 $1$。\n\n**情况 C：线性同余，一般情况**\n($m=4096$, $a=5$, $c=1$, $X_0=1$)\n-   **均匀性：** Hull-Dobell 条件被满足：$m=2^{12}$，$c=1$ 是奇数，且 $a=5 \\equiv 1 \\pmod 4$。该 LCG 具有 $m=4096$ 的满周期。均匀性比率为 $1.0$。\n-   **结构：** 点对 $(U_i, U_{i+1})$ 位于由 $U_{i+1} = (5 U_i + 1/4096) \\pmod 1$ 定义的 $a=5$ 条平行线上。模差为 $(X_{i+1} - X_i) \\bmod m = (4X_i + 1) \\bmod m$。由于 $X_i$ 遍历所有剩余类，且 $\\gcd(4, 4096)=4$，差值会取 $4096/4=1024$ 个不同的值，所有值都模 4 同余于 1。这些值是 $\\{1, 5, 9, \\dots\\}$。这 $1024$ 个值在 $[0, 4096)$ 上分布良好，将落入所有宽度为 $m/G=64$ 的 $G=64$ 个仓位中。差值分箱数将为 $64$。\n\n**情况 D：独立均匀基线**\n($m=4096$, $s=12345$)\n-   这种情况作为“好的”随机性的基准，其中连续值是独立的。\n-   **均匀性：** 抽取 $m=4096$ 个值。访问的唯一状态数量与赠券收集者问题有关。唯一值的期望数量是 $m(1-(1-1/m)^m) \\approx m(1-1/e) \\approx 0.632m$。因此比率应接近 $0.632$。\n-   **结构：** 对于独立的点对 $(U_i, U_{i+1})$，这些点应该均匀地散布在单位正方形上，没有可辨别的线性结构。皮尔逊相关系数应接近 $0$。这些点应占据许多网格单元，其期望计数与均匀性结果相似，约为 $m(1-e^{-1}) \\approx 2588$。模差 $(X_{i+1}-X_i)\\bmod m$ 将在 $\\{0, \\dots, m-1\\}$ 上近似均匀分布。对于 $4095$ 个这样的差值，所有 $64$ 个仓位都极有可能被访问到。差值分箱数应为 $64$。\n\n## 定量指标\n问题定义了需要计算的四个指标：\n1.  **均匀性比率：** $R_U = \\frac{|\\{X_i\\}|}{m}$，其中 $|\\{X_i\\}|$ 是一个周期内访问的不同状态的数量。\n2.  **占据数：** $N_{occ} = |\\{(\\lfloor G U_i \\rfloor, \\lfloor G U_{i+1} \\rfloor)\\}|$，即点对 $(U_i, U_{i+1})$ 在一个 $G \\times G$ 网格中击中的唯一单元格的数量。\n3.  **皮尔逊相关系数：** $\\rho(U_i, U_{i+1}) = \\frac{\\mathrm{Cov}(U_i, U_{i+1})}{\\sigma_{U_i}\\sigma_{U_{i+1}}}$，用于衡量连续归一化值之间的线性相关性。\n4.  **差值分箱数：** $N_{db} = |\\{\\lfloor \\frac{(X_{i+1}-X_i)\\bmod m}{m/G} \\rfloor\\}|$，即模差所击中的唯一粗略仓位的数量。\n\n现在，实现将遵循这些原理来生成序列并为每种情况计算指定的指标。", "answer": "```python\nimport numpy as np\n\ndef generate_sequence_lcg(m, a, c, x0):\n    \"\"\"\n    Generates a sequence from a Linear Congruential Generator (LCG)\n    X_{i+1} = (a * X_i + c) mod m, until the first state repeats.\n    \"\"\"\n    seq = []\n    # Use a dictionary for fast lookups and to store the first occurrence index.\n    visited = {}\n    x = x0\n    i = 0\n    while x not in visited:\n        visited[x] = i\n        seq.append(x)\n        x = (a * x + c) % m\n        i += 1\n    return np.array(seq, dtype=np.int64)\n\ndef calculate_metrics(X, m, G):\n    \"\"\"\n    Calculates the four specified metrics for a given sequence X.\n    \"\"\"\n    # 1. One-dimensional uniformity ratio\n    # Using np.unique is a robust way to count distinct elements.\n    num_distinct_states = len(np.unique(X))\n    uniformity_ratio = num_distinct_states / m\n\n    if len(X) < 2:\n        # Cannot compute pair-based metrics if sequence length is less than 2.\n        return [uniformity_ratio, 0, 0.0, 0]\n\n    # Create consecutive pairs from the sequence\n    X_i = X[:-1]\n    X_ip1 = X[1:]\n\n    # Normalize pairs to the unit interval [0, 1)\n    U_i = X_i / m\n    U_ip1 = X_ip1 / m\n\n    # 2. Occupancy count of a uniform grid\n    grid_indices = np.floor(np.vstack([U_i * G, U_ip1 * G]).T).astype(np.int32)\n    # Using a set of tuples is an efficient way to count unique 2D integer points.\n    unique_cells = set(map(tuple, grid_indices))\n    occupancy_count = len(unique_cells)\n\n    # 3. Pearson correlation coefficient\n    # Check for constant series to avoid NaN from division by zero in correlation formula.\n    if np.std(U_i) == 0 or np.std(U_ip1) == 0:\n        correlation = 1.0 if np.array_equal(U_i, U_ip1) else 0.0\n    else:\n        correlation = np.corrcoef(U_i, U_ip1)[0, 1]\n\n    # 4. Number of distinct bins of the modular difference\n    # np.mod ensures the result is in [0, m), correctly handling negative differences.\n    diff = np.mod(X_ip1 - X_i, m)\n    bin_width = m / G\n    diff_bins = np.floor(diff / bin_width)\n    diff_bin_count = len(np.unique(diff_bins))\n    \n    return [uniformity_ratio, occupancy_count, correlation, diff_bin_count]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (name, (m, a, c, x0), G) or (name, (m, seed), G)\n    test_cases = [\n        ('A', (4096, 1, 5, 0), 64),\n        ('B', (4096, 1, 512, 0), 64),\n        ('C', (4096, 5, 1, 1), 64),\n        ('D', (4096, 12345), 64)\n    ]\n\n    results = []\n    for case in test_cases:\n        name, params, G = case\n        \n        if name == 'D':\n            m, seed = params\n            # Generate sequence for Case D (independent uniform baseline)\n            rng = np.random.default_rng(seed=seed)\n            U = rng.random(size=m)\n            X = np.floor(m * U).astype(np.int64)\n        else:\n            # Generate sequence for Cases A, B, C (LCGs)\n            m, a, c, x0 = params\n            X = generate_sequence_lcg(m, a, c, x0)\n            \n        metrics = calculate_metrics(X, m, G)\n        results.append(metrics)\n\n    # The final print statement must produce the exact single-line format.\n    # repr() creates a string representation of the list, and replace() removes spaces.\n    print(repr(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3264088"}, {"introduction": "在了解了如何评估PRNG的基本质量和识别其潜在缺陷后，是时候将它们投入实际应用了。本练习将使用伪随机数来驱动一个经典的蒙特卡洛模拟——“优惠券收集者问题” [@problem_id:3264193]。通过这次实践，你将体验如何利用随机抽样来估算一个理论上可以推导的数学期望值，并比较模拟结果与理论值的差异，这是计算科学中验证模型和理解随机过程的基石。", "problem": "你需要使用伪随机数生成器实现一个赠券收集过程的模拟，并将试验次数的蒙特卡洛估计值与从第一性原理推导出的理论值进行比较。考虑以下模型：有 $n$ 种不同的赠券类型，标记为 $0,1,\\dots,n-1$。每次试验恰好抽取一张赠券，且每种赠券类型被抽到的可能性均等。各次试验是独立的。设 $T$ 为直到所有 $n$ 种类型的赠券都至少被收集过一次为止的总试验次数。\n\n此任务必须基于试验独立性、均匀离散选择以及几何随机变量期望的定义。伪随机数生成器（PRNG）是一种确定性算法，其生成的数列可近似于一个离散集上的独立均匀随机变量。你必须实例化一个线性同余生成器（LCG），其定义由递推关系\n$$\nx_{t+1} = (a x_t + c) \\bmod m,\n$$\n给出，其中 $a$、$c$ 和 $m$ 是固定整数，$x_t$ 是在步骤 $t$ 的内部状态。你必须使用以下已知能产生长周期序列的参数：$a=16807$，$c=0$ 和 $m=2^{31}-1$。使用满足 $0 < s < m$ 的种子 $s$ 初始化状态。基于此生成器，通过应用无偏拒绝抽样来消除模偏差，从而在 $\\{0,1,\\dots,n-1\\}$ 中构建一个均匀整数抽取：如果 $y = x_t - 1 \\in \\{0,1,\\dots,m-2\\}$ 且 $t^\\star = \\left\\lfloor \\frac{m-1}{n} \\right\\rfloor \\cdot n$，那么当 $y < t^\\star$ 时接受 $y$ 并返回 $y \\bmod n$；否则，推进生成器并重试直到样本被接受。\n\n对于每个测试用例，使用你的 PRNG 驱动赠券收集过程，执行 $M$ 次独立的蒙特卡洛复制，计算所有复制的经验均值 $\\hat{E}[T]$，并计算从第一性原理推导出的理论期望 $E[T]$（在本问题陈述中不要使用快捷公式）。报告绝对误差 $|\\hat{E}[T] - E[T]|$。\n\n你的程序必须实现所述的 PRNG 和模拟，并生成单行输出，其中包含所有测试用例的结果，形式为一个用方括号括起来的逗号分隔列表，每个测试用例产生一个列表 $[\\hat{E}[T],E[T],|\\hat{E}[T]-E[T]|]$。所有输出均为实数（浮点数），以标准十进制表示法表示，不带任何物理单位。\n\n使用以下测试套件，覆盖正常路径和边界条件：\n-   用例 A (边界)：$n=1$, $M=100$, $s=12345$。\n-   用例 B (正常路径-小)：$n=5$, $M=10000$, $s=987654321$。\n-   用例 C (中等)：$n=50$, $M=2000$, $s=42$。\n-   用例 D (较大)：$n=200$, $M=800$, $s=20231107$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[[\\hat{E}_A,E_A,|e_A|],[\\hat{E}_B,E_B,|e_B|],[\\hat{E}_C,E_C,|e_C|],[\\hat{E}_D,E_D,|e_D|]]$），其中每个内部列表按给定顺序对应于相应的测试用例。", "solution": "该问题要求为优惠券收集者问题实现一个蒙特卡洛模拟，并将其经验结果与理论期望进行比较。这涉及三个主要部分：从第一性原理推导理论期望，实现一个指定的伪随机数生成器（PRNG），以及设计模拟逻辑。\n\n### 1. 试验次数的理论期望 $E[T]$\n\n问题的核心是确定收集所有 $n$ 种不同类型赠券所需的期望试验次数 $E[T]$。设 $T$ 为表示总试验次数的随机变量。我们可以将 $T$ 分解为一系列更简单的随机变量之和。\n\n设 $T_i$ 为在已收集到 $i-1$ 种不同类型赠券的条件下，为获得第 $i$ 种新赠券类型所需的额外试验次数。总试验次数是为获得每一种新赠券所需试验次数的总和：\n$$\nT = T_1 + T_2 + \\dots + T_n\n$$\n根据期望的线性性质，总试验次数的期望是这些单个阶段期望值的总和：\n$$\nE[T] = E\\left[\\sum_{i=1}^{n} T_i\\right] = \\sum_{i=1}^{n} E[T_i]\n$$\n现在，我们来求每个阶段 $i$ 的期望 $E[T_i]$。在阶段 $i$ 开始时，我们已经收集了 $i-1$ 种不同的赠券类型。赠券总类型数为 $n$。因此，尚未收集到的赠券类型数量为 $n - (i-1)$。由于 $n$ 种类型中的每一种都以等概率 $1/n$ 被抽到，抽到任何一种特定的未收集类型的概率是 $1/n$。因此，在单次试验中抽到任何一种新的（未收集的）类型的概率是：\n$$\np_i = \\frac{n - (i-1)}{n}\n$$\n在一系列独立的伯努利试验中等待首次成功（抽到一种新类型的赠券）的过程由几何分布描述。随机变量 $T_i$ 服从成功概率为 $p_i$ 的几何分布。对于参数为 $p$ 的几何分布，直到首次成功所需的期望试验次数是 $1/p$。因此，阶段 $i$ 的期望试验次数是：\n$$\nE[T_i] = \\frac{1}{p_i} = \\frac{n}{n - i + 1}\n$$\n将此代入 $E[T]$ 的求和式中：\n$$\nE[T] = \\sum_{i=1}^{n} \\frac{n}{n - i + 1}\n$$\n为了简化这个表达式，我们可以进行换元。令 $k = n - i + 1$。当 $i=1$ 时，$k=n$。当 $i=n$ 时，$k=1$。求和式变为：\n$$\nE[T] = \\sum_{k=1}^{n} \\frac{n}{k} = n \\sum_{k=1}^{n} \\frac{1}{k}\n$$\n求和 $\\sum_{k=1}^{n} \\frac{1}{k}$ 是第 $n$ 个调和数，记为 $H_n$。因此，$E[T] = n H_n$。此公式将用于计算理论期望。\n\n### 2. 算法设计\n\n解决方案围绕一个处理每个测试用例的主函数构建。对于每个用例，它通过蒙特卡洛模拟计算理论期望和经验估计，然后求出绝对误差。\n\n**A. 伪随机数生成器（PRNG）**\n\n实现了一个线性同余生成器（LCG）作为随机性的来源。\n-   **状态与递推：** 生成器维护一个内部状态 $x_t$。下一个状态通过递推关系 $x_{t+1} = (a x_t + c) \\bmod m$ 计算。问题指定了参数 $a=16807$，$c=0$ 和 $m=2^{31}-1$。状态由给定的种子 $s$ 初始化。\n-   **实现：** 一个 `LCG` 类封装了状态和参数。一个 `_next_raw()` 方法计算并返回序列中的下一个值，同时更新内部状态。计算 $(a \\cdot x_t)$ 可能会超过 $2^{31}-1$，因此在执行模运算之前，需要使用 64 位整数算术（或 Python 的任意精度整数）来防止溢出。\n\n**B. 无偏均匀整数采样器**\n\n如果简单地对 LCG 的原始输出取模 $n$，其结果在 $\\{0, 1, \\dots, n-1\\}$ 上不是均匀分布的。为了纠正这种偏差，我们采用指定的拒绝抽样方法。\n-   **拒绝阈值：** 首先，计算一个阈值 $t^\\star$：$t^\\star = \\lfloor \\frac{m-1}{n} \\rfloor \\cdot n$。该值是小于或等于 $m-1$ 的 $n$ 的最大倍数。\n-   **采样逻辑：** 一个采样方法按如下方式生成整数：\n    1.  从 LCG 生成一个原始值 $x_t$。\n    2.  通过计算 $y = x_t - 1$ 将其映射到范围 $\\{0, 1, \\dots, m-2\\}$。\n    3.  如果 $y < t^\\star$，则接受该样本。函数返回 $y \\bmod n$。因为接受的 $y$ 值范围 $[0, t^\\star-1]$ 的长度是 $n$ 的倍数，所以 $\\{0, 1, \\dots, n-1\\}$ 中的每个输出值都以相等的频率产生。\n    4.  如果 $y \\ge t^\\star$，则拒绝该样本，并从步骤 1 开始重复该过程，直到一个样本被接受。\n\n**C. 蒙特卡洛模拟**\n\n经验估计的核心是赠券收集过程的模拟。\n-   **单次复制：** 一个函数 `run_single_collection(n, prng)` 执行一次完整的实验运行。\n    1.  初始化一个大小为 $n$ 的布尔数组 `collected` 为 `False`，用以跟踪哪些赠券类型已被见过。\n    2.  初始化 `distinct_coupons_count = 0` 和 `trials = 0`。\n    3.  循环直到 `distinct_coupons_count` 等于 $n$：\n        - 增加 `trials`。\n        - 使用无偏采样器从 $\\{0, 1, \\dots, n-1\\}$ 中抽取一张赠券 `c`。\n        - 如果 `collected[c]` 为 `False`，说明这是一张新的赠券。将 `collected[c]` 设置为 `True` 并增加 `distinct_coupons_count`。\n    4.  返回最终的 `trials` 计数。\n-   **主模拟循环：** 对于每个测试用例 $(n, M, s)$：\n    1.  使用种子 $s$ 实例化 `LCG`。\n    2.  运行一个循环 $M$ 次。在每次迭代中，调用 `run_single_collection` 并存储得出的试验次数。\n    3.  通过对 $M$ 次试验计数取平均值来计算经验均值 $\\hat{E}[T]$。\n\n**D. 最终计算与输出**\n\n对于每个测试用例，程序执行以下最终步骤：\n1.  计算理论期望 $E[T] = n \\sum_{k=1}^{n} \\frac{1}{k}$。\n2.  运行蒙特卡洛模拟以获得经验均值 $\\hat{E}[T]$。\n3.  计算绝对误差 $|\\hat{E}[T] - E[T]|$。\n4.  将三个浮点数值 $[\\hat{E}[T], E[T], |\\hat{E}[T]-E[T]|]$ 存储在一个结果列表中。\n5.  处理完所有测试用例后，将结果列表格式化为指定的字符串格式 `[[...],[...],...]` 并打印到标准输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass LCG:\n    \"\"\"\n    Implements a Linear Congruential Generator (LCG) with rejection sampling.\n    x_{t+1} = (a * x_t + c) mod m\n    \"\"\"\n    def __init__(self, seed: int, a: int, c: int, m: int):\n        if not (0 < seed < m):\n            raise ValueError(\"Seed must be in the range (0, m-1)\")\n        self.state = seed\n        self.a = a\n        self.c = c\n        self.m = m\n\n    def _next_raw(self) -> int:\n        \"\"\"\n        Generates the next integer in the LCG sequence.\n        \"\"\"\n        self.state = (self.a * self.state + self.c) % self.m\n        return self.state\n\n    def get_uniform_draw(self, n: int, t_star: int) -> int:\n        \"\"\"\n        Generates a uniform integer in {0, ..., n-1} using unbiased rejection sampling.\n        \"\"\"\n        while True:\n            # Generate a raw value from the LCG.\n            raw_val = self._next_raw()\n            \n            # Map to the range {0, ..., m-2}\n            y = raw_val - 1\n            \n            # Accept if y is in the valid range [0, t_star - 1]\n            if y < t_star:\n                return y % n\n            # Otherwise, reject and retry.\n\ndef run_single_collection(n: int, prng: LCG) -> int:\n    \"\"\"\n    Simulates one full coupon collection process for n coupons.\n\n    Args:\n        n (int): The number of distinct coupon types.\n        prng (LCG): An initialized LCG instance.\n\n    Returns:\n        int: The total number of trials to collect all n coupons.\n    \"\"\"\n    if n == 1:\n        return 1\n\n    # Pre-calculate the rejection sampling threshold t_star\n    t_star = ((prng.m - 1) // n) * n\n    \n    collected_coupons = [False] * n\n    distinct_coupons_count = 0\n    trials = 0\n\n    while distinct_coupons_count < n:\n        trials += 1\n        coupon = prng.get_uniform_draw(n, t_star)\n        \n        if not collected_coupons[coupon]:\n            collected_coupons[coupon] = True\n            distinct_coupons_count += 1\n    \n    return trials\n\ndef calculate_theoretical_e(n: int) -> float:\n    \"\"\"\n    Calculates the theoretical expected number of trials E[T] = n * H_n.\n\n    Args:\n        n (int): The number of distinct coupon types.\n\n    Returns:\n        float: The theoretical expectation E[T].\n    \"\"\"\n    if n == 0:\n        return 0.0\n    \n    harmonic_sum = sum(1.0 / k for k in range(1, n + 1))\n    return n * harmonic_sum\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # LCG parameters from the problem statement\n    a = 16807\n    c = 0\n    m = 2**31 - 1\n    \n    # Test cases from the problem statement\n    test_cases = [\n        # (n, M, seed)\n        (1, 100, 12345),\n        (5, 10000, 987654321),\n        (50, 2000, 42),\n        (200, 800, 20231107),\n    ]\n\n    all_results = []\n\n    for n, M, s in test_cases:\n        # 1. Calculate theoretical expectation\n        e_t = calculate_theoretical_e(n)\n\n        # 2. Run Monte Carlo simulation\n        prng = LCG(seed=s, a=a, c=c, m=m)\n        \n        trial_counts = np.empty(M, dtype=int)\n        for i in range(M):\n            # The PRNG state is carried over between replications\n            trial_counts[i] = run_single_collection(n, prng)\n        \n        hat_e_t = np.mean(trial_counts)\n\n        # 3. Calculate absolute error\n        abs_error = abs(hat_e_t - e_t)\n\n        # 4. Store results as floats\n        all_results.append([float(hat_e_t), float(e_t), float(abs_error)])\n\n    # Final print statement in the exact required format.\n    # Using str() on a list creates the [item1, item2, ...] representation.\n    # Joining these string representations with a comma creates the desired output.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3264193"}]}