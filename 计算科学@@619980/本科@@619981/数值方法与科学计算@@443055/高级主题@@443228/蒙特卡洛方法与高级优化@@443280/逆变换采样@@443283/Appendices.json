{"hands_on_practices": [{"introduction": "我们的第一个实践练习是从零开始，为一个常见但非均匀的分布构建一个采样器。三角分布是一个绝佳的起点，因为其分段线性的概率密度函数（PDF）要求我们仔细处理不同区间上的积分和反函数求解。这项练习将强化从推导累积分布函数（CDF）到其反函数（即分位数函数）的核心机制。[@problem_id:2403851]", "problem": "要求您为具有有限支撑的三角概率分布实现逆变换采样。三角分布由三个实数参数 $a$、$c$ 和 $b$ 定义，其中 $a  b$ 且 $a \\le c \\le b$，$a$ 是左端点，$b$ 是右端点，$c$ 是众数（峰值的位置）。其概率密度函数在 $[a, c]$ 和 $[c, b]$ 上是连续的分段线性函数，在 $[a, b]$ 之外为零。您的任务是从第一性原理出发推导出采样器，并将其实现为一个程序。\n\n基本原理：\n- 概率密度函数 (PDF)：一个非负函数 $f(x)$，其在其支撑集上的积分为 $1$。\n- 累积分布函数 (CDF)：$F(x) = \\mathbb{P}(X \\le x) = \\int_{-\\infty}^{x} f(t)\\, dt$。\n- 逆变换采样：如果 $U$ 是一个在 $[0,1]$ 上均匀分布的随机变量，并且 $F$ 是一个连续、严格递增的 CDF，则 $X = F^{-1}(U)$ 的 CDF 为 $F$。\n\n要求：\n1) 仅从上述定义出发，推导在 $[a, c, b]$ 上的三角分布的分段 CDF $F(x)$，并通过解析方式对其求逆，以获得对于 $u \\in [0,1]$ 的分位数函数 $F^{-1}(u)$。确保您的推导覆盖了一般情况 $a  c  b$，并能正确处理极限情况 $c = a$ 和 $c = b$。\n\n2) 实现一个程序，给定 $(a, c, b)$ 和一个 $u$ 值列表（每个 $u \\in [0,1]$），使用您推导出的逆函数返回相应的样本 $x = F^{-1}(u)$。您必须处理以下细节：\n- 为保证数值稳健性，在应用逆函数之前，将每个 $u$ 限定在 $[0,1]$ 区间内。\n- 您的实现必须在 $c = a$ 和 $c = b$ 的情况下正常工作，不得出现除以零或无效分支的问题。\n- 对于每个计算出的样本，将结果四舍五入到 $10$ 位小数。\n\n3) 您不得依赖任何库中预打包的三角分布。您可以使用允许库中的基本数值运算，但采样器必须直接实现您推导出的逆函数。\n\n此挑战的输入和输出是固定的；没有用户输入。您的程序必须在给定的参数集和 $u$ 值（见下文测试套件）下评估逆函数，并打印包含所有结果的单行输出。\n\n测试套件：\n- 情况 $1$ (一般“理想”情况)：$(a, c, b) = (0, 2, 5)$， $u$ 值为 $[0, 0.1, 0.4, 0.5, 0.9, 1]$。\n- 情况 $2$ (边界情况 $c = a$)：$(a, c, b) = (3, 3, 7)$， $u$ 值为 $[0, 0.25, 0.999999, 1]$。\n- 情况 $3$ (边界情况 $c = b$)：$(a, c, b) = (-2, 1, 1)$， $u$ 值为 $[0, 0.25, 0.8, 1]$。\n- 情况 $4$ (边界稳健性)：$(a, c, b) = (0, 1, 2)$， $u$ 值为 $[0, 10^{-12}, 0.5, 1 - 10^{-12}, 1]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个以逗号分隔的列表，列表用方括号括起来，每个测试用例对应一个包含四舍五入后样本的列表。具体来说，输出必须是形如\n$[[x_{1,1},x_{1,2},\\dots],[x_{2,1},\\dots],[x_{3,1},\\dots],[x_{4,1},\\dots]]$ 的单行字符串，不含空格。每个 $x_{i,j}$ 必须是四舍五入到 $10$ 位小数的浮点数。\n- 此问题不涉及任何物理单位；所有量均为无量纲实数。", "solution": "用户提供了一个问题陈述。我将首先对其进行验证。\n\n### 步骤1：提取给定信息\n- **分布**：三角概率分布。\n- **参数**：实数 $a$、$c$、$b$ 满足 $a  b$ 且 $a \\le c \\le b$。$a$ 是最小值，$b$ 是最大值，$c$ 是众数。\n- **概率密度函数 (PDF)**：$f(x)$ 是连续的分段线性函数，支撑集为 $[a, b]$。\n- **累积分布函数 (CDF)**：$F(x) = \\mathbb{P}(X \\le x) = \\int_{-\\infty}^{x} f(t)\\, dt$。\n- **核心任务**：使用逆变换采样，其中样本 $X$ 由均匀随机变量 $U \\sim \\text{Uniform}[0,1]$ 通过 $X = F^{-1}(U)$ 生成。\n- **推导要求**：从第一性原理出发，推导分段 CDF $F(x)$ 及其逆函数，即分位数函数 $F^{-1}(u)$。推导必须覆盖一般情况 $a  c  b$ 和极限情况 $c = a$ 及 $c = b$。\n- **实现要求**：\n    1. 实现推导出的 $F^{-1}(u)$ 函数。\n    2. 不使用库中预打包的三角分布函数。\n    3. 输入的 $u$ 值必须被限定在 $[0,1]$ 区间内。\n    4. 实现必须能正确处理 $c=a$ 和 $c=b$ 的情况。\n    5. 输出样本必须四舍五入到 $10$ 位小数。\n- **测试套件**：\n    - 情况 1：$(a, c, b) = (0, 2, 5)$，$u = [0, 0.1, 0.4, 0.5, 0.9, 1]$。\n    - 情况 2：$(a, c, b) = (3, 3, 7)$，$u = [0, 0.25, 0.999999, 1]$。\n    - 情况 3：$(a, c, b) = (-2, 1, 1)$，$u = [0, 0.25, 0.8, 1]$。\n    - 情况 4：$(a, c, b) = (0, 1, 2)$，$u = [0, 10^{-12}, 0.5, 1 - 10^{-12}, 1]$。\n- **输出格式**：一个表示结果列表的列表的单行字符串，不含空格：`[[...],[...],[...],[...]]`。\n\n### 步骤2：使用提取的给定信息进行验证\n- **科学基础**：问题基于概率论（PDF、CDF）和计算统计学（逆变换采样）的基本、公认原理。三角分布是一个标准的、无争议的概率分布。此标准已满足。\n- **问题定义良好**：问题提供了所有必要的定义、约束条件（$a  b$，$a \\le c \\le b$）和明确的目标。CDF 及其逆函数（对于连续、严格递增的函数）的存在性和唯一性由数学原理保证。此标准已满足。\n- **客观性**：问题以精确的数学语言陈述，没有任何主观性或歧义。此标准已满足。\n- **缺陷检查**：问题不违反任何科学定律，是可形式化、完整且可验证的。约束条件一致，要求的任务定义明确。\n\n### 步骤3：结论与行动\n问题陈述是**有效**的。我将继续进行推导和求解。\n\n任务是推导三角分布的分位数函数并实现它。这分三个阶段进行：首先，定义概率密度函数 (PDF)；其次，对 PDF 进行积分以求得累积分布函数 (CDF)；第三，对 CDF 求逆以获得分位数函数 $F^{-1}(u)$。\n\n**1. 概率密度函数 (PDF), $f(x)$**\n\nPDF $f(x)$ 描述了一个顶点为 $(a, 0)$、$(c, h)$ 和 $(b, 0)$ 的三角形，其中 $h$ 是三角形的高。PDF 下的总面积必须为 $1$。三角形的面积由 $\\frac{1}{2} \\times \\text{底} \\times \\text{高}$ 给出。\n$$\n\\text{面积} = \\frac{1}{2} (b-a) h = 1 \\implies h = \\frac{2}{b-a}\n$$\nPDF 是一个分段线性函数。\n对于 $a \\le x \\le c$，直线经过 $(a, 0)$ 和 $(c, h)$。方程为：\n$$\nf(x) = \\frac{h-0}{c-a} (x-a) = \\frac{2(x-a)}{(b-a)(c-a)}\n$$\n对于 $c  x \\le b$，直线经过 $(c, h)$ 和 $(b, 0)$。方程为：\n$$\nf(x) = h + \\frac{0-h}{b-c} (x-c) = \\frac{2}{b-a} - \\frac{2(x-c)}{(b-a)(b-c)} = \\frac{2(b-c) - 2(x-c)}{(b-a)(b-c)} = \\frac{2(b-x)}{(b-a)(b-c)}\n$$\n综合起来，PDF 是：\n$$\nf(x) = \\begin{cases}\n\\frac{2(x-a)}{(b-a)(c-a)}  \\text{若 } a \\le x \\le c \\\\\n\\frac{2(b-x)}{(b-a)(b-c)}  \\text{若 } c  x \\le b \\\\\n0  \\text{其他情况}\n\\end{cases}\n$$\n这些表达式是在假设 $a  c  b$ 的情况下定义的。我们将看到，最终的分位数函数能正确处理边界情况 $c=a$ 和 $c=b$。\n\n**2. 累积分布函数 (CDF), $F(x)$**\n\nCDF 是 PDF 的积分，$F(x) = \\int_{a}^{x} f(t) \\,dt$。\n对于 $x  a$，$F(x)=0$。对于 $x > b$，$F(x)=1$。\n\n对于 $a \\le x \\le c$：\n$$\nF(x) = \\int_{a}^{x} \\frac{2(t-a)}{(b-a)(c-a)} \\,dt = \\frac{2}{(b-a)(c-a)} \\left[ \\frac{(t-a)^2}{2} \\right]_{a}^{x} = \\frac{(x-a)^2}{(b-a)(c-a)}\n$$\n在众数 $c$ 处，CDF 的值为 $F(c) = \\frac{(c-a)^2}{(b-a)(c-a)} = \\frac{c-a}{b-a}$。这个值是区间 $[a, c]$ 内的总概率质量。\n\n对于 $c  x \\le b$：\n$$\nF(x) = F(c) + \\int_{c}^{x} \\frac{2(b-t)}{(b-a)(b-c)} \\,dt \\\\\nF(x) = \\frac{c-a}{b-a} + \\frac{2}{(b-a)(b-c)} \\left[ -\\frac{(b-t)^2}{2} \\right]_{c}^{x} \\\\\nF(x) = \\frac{c-a}{b-a} + \\frac{-(b-x)^2 - (-(b-c)^2)}{(b-a)(b-c)} \\\\\nF(x) = \\frac{c-a}{b-a} + \\frac{(b-c)^2 - (b-x)^2}{(b-a)(b-c)}\n$$\n通过化简可以得到一个更优雅的形式：\n$$\nF(x) = \\frac{(c-a)(b-c) + (b-c)^2 - (b-x)^2}{(b-a)(b-c)} = \\frac{(b-c)(c-a+b-c) - (b-x)^2}{(b-a)(b-c)} \\\\\nF(x) = \\frac{(b-c)(b-a) - (b-x)^2}{(b-a)(b-c)} = 1 - \\frac{(b-x)^2}{(b-a)(b-c)}\n$$\n所以，完整的 CDF 是：\n$$\nF(x) = \\begin{cases}\n0  \\text{若 } x  a \\\\\n\\frac{(x-a)^2}{(b-a)(c-a)}  \\text{若 } a \\le x \\le c \\\\\n1 - \\frac{(b-x)^2}{(b-a)(b-c)}  \\text{若 } c  x \\le b \\\\\n1  \\text{若 } x > b\n\\end{cases}\n$$\n\n**3. 逆 CDF (分位数函数), $F^{-1}(u)$**\n\n为了实现逆变换采样，我们必须从方程 $u = F(x)$ 中解出 $x$，其中 $u \\in [0, 1]$。\n逆函数的形式取决于 $u$ 是落在对应于 $x \\le c$ 的范围内还是 $x > c$ 的范围内。区分这两种情况的 $u$ 的临界值是 $u_c = F(c) = \\frac{c-a}{b-a}$。\n\n情况 1：$0 \\le u \\le u_c$ (对应于 $a \\le x \\le c$)\n$$\nu = \\frac{(x-a)^2}{(b-a)(c-a)} \\\\\n(x-a)^2 = u(b-a)(c-a) \\\\\nx-a = \\sqrt{u(b-a)(c-a)} \\quad (\\text{取正根因为 } x \\ge a) \\\\\nx = a + \\sqrt{u(b-a)(c-a)}\n$$\n\n情况 2：$u_c  u \\le 1$ (对应于 $c  x \\le b$)\n$$\nu = 1 - \\frac{(b-x)^2}{(b-a)(b-c)} \\\\\n(b-x)^2 = (1-u)(b-a)(b-c) \\\\\nb-x = \\sqrt{(1-u)(b-a)(b-c)} \\quad (\\text{取正根因为 } x \\le b) \\\\\nx = b - \\sqrt{(1-u)(b-a)(b-c)}\n$$\n\n最终得到的分位数函数 $F^{-1}(u)$ 是：\n$$\nF^{-1}(u) = \\begin{cases}\na + \\sqrt{u (b-a) (c-a)}  \\text{若 } 0 \\le u \\le \\frac{c-a}{b-a} \\\\\nb - \\sqrt{(1-u) (b-a) (b-c)}  \\text{若 } \\frac{c-a}{b-a}  u \\le 1\n\\end{cases}\n$$\n这个单一、统一的公式是稳健的，并且能正确处理边界情况。\n- 如果 $c=a$，那么 $u_c = \\frac{c-a}{b-a} = 0$。条件 $0 \\le u \\le 0$ 仅对 $u=0$ 成立。对于任何 $u > 0$，使用第二分支：$x = b - \\sqrt{(1-u) (b-a) (b-a)} = b - (b-a)\\sqrt{1-u}$。这对应于一个峰值在 $a$ 的直角三角形。\n- 如果 $c=b$，那么 $u_c = \\frac{c-a}{b-a} = 1$。条件 $0 \\le u \\le 1$ 对所有 $u$ 成立，所以总是使用第一分支：$x = a + \\sqrt{u (b-a) (b-a)} = a + (b-a)\\sqrt{u}$。这对应于一个峰值在 $b$ 的直角三角形。\n\n推导完整且合理。实现将遵循此最终公式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements the inverse transform sampling for a triangular distribution.\n    The final output is printed in the exact required format.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: General case\n        {'params': (0, 2, 5), 'u_values': [0, 0.1, 0.4, 0.5, 0.9, 1]},\n        # Case 2: Edge case c = a\n        {'params': (3, 3, 7), 'u_values': [0, 0.25, 0.999999, 1]},\n        # Case 3: Edge case c = b\n        {'params': (-2, 1, 1), 'u_values': [0, 0.25, 0.8, 1]},\n        # Case 4: Boundary robustness\n        {'params': (0, 1, 2), 'u_values': [0, 10**-12, 0.5, 1 - 10**-12, 1]},\n    ]\n    \n    all_results = []\n\n    for case in test_cases:\n        a, c, b = case['params']\n        u_values = case['u_values']\n        \n        case_results = []\n        \n        # Pre-calculate terms for efficiency and clarity\n        # The problem states a  b, so b - a > 0 is guaranteed.\n        range_ab = b - a\n        range_ac = c - a\n        range_cb = b - c\n        \n        # Calculate the CDF value at the mode, which is the threshold for u\n        # This handles the case where b-a might equal 0 if the problem constraints were different,\n        # but here it's safe.\n        if range_ab == 0:\n            # Degenerate case, not covered by problem statement a  b\n            # but good practice for robustness. All samples are at 'a'.\n            fc = 0.5 # A reasonable default.\n        else:\n            fc = range_ac / range_ab\n        \n        for u in u_values:\n            # Per requirement, clamp u into [0, 1] for numerical robustness.\n            u_clamped = max(0.0, min(1.0, u))\n            \n            x = 0.0\n            # The logic directly implements the derived piecewise inverse CDF.\n            # The comparison u_clamped = fc correctly selects the formula branch,\n            # naturally handling the edge cases c=a (fc=0) and c=b (fc=1).\n            if u_clamped = fc:\n                # This branch corresponds to the interval [a, c]\n                # x = a + sqrt(u * (b-a) * (c-a))\n                # Handle c=a case where range_ac is 0 to avoid sqrt of negative from precision errors\n                if range_ac > 0:\n                    term = u_clamped * range_ab * range_ac\n                    x = a + np.sqrt(term)\n                else:\n                    x = a # If c=a, fc=0, this branch only runs for u=0, x should be a.\n            else:\n                # This branch corresponds to the interval (c, b]\n                # x = b - sqrt((1-u) * (b-a) * (b-c))\n                # Handle c=b case where range_cb is 0\n                if range_cb > 0:\n                    term = (1 - u_clamped) * range_ab * range_cb\n                    x = b - np.sqrt(term)\n                else:\n                    x = b # If c=b, fc=1, this branch only runs for u=1, x should be b.\n            \n            # Round the result to 10 decimal places as required.\n            case_results.append(round(x, 10))\n            \n        all_results.append(case_results)\n\n    # Format the final output string to the exact required format.\n    # e.g., [[x11,x12,...],[x21,...],[x31,...],[x41,...]] with no spaces.\n    # Convert list of lists to string and remove whitespace.\n    output_string = str(all_results).replace(\" \", \"\")\n    \n    print(output_string)\n\nsolve()\n```", "id": "2403851"}, {"introduction": "在前一个练习的基础上，我们现在探索一个更复杂的场景，即概率分布在多个不相连的区间上。这个问题挑战你正确推导其累积分布函数（CDF），你会发现它在概率密度为零的区域会呈现“平台期”，并需要你理解其广义反函数。这个练习至关重要，它能让你认识到逆变换采样不仅限于简单的连通域，并引出了强大的复合方法思想。[@problem_id:3244485]", "problem": "给定一个实轴上的连续目标分布，其支撑集为不相交的区间集合 $[0,1] \\cup [3,4]$。其未归一化密度为\n$$\ng(x) = \n\\begin{cases}\nx,  x \\in [0,1],\\\\\n2,  x \\in [3,4],\\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n令 $f(x) = g(x)/Z$ 为归一化的概率密度函数 (PDF)，其中归一化常数 $Z$ 满足 $\\int_{-\\infty}^{\\infty} f(x)\\,dx = 1$。令 $F(x) = \\int_{-\\infty}^{x} f(t)\\,dt$ 表示累积分布函数 (CDF)，并定义广义逆 CDF 为 $F^{-1}(u) = \\inf\\{x \\in \\mathbb{R} : F(x) \\ge u\\}$，其中 $u \\in (0,1)$。仅使用 PDF、CDF 和逆变换采样（抽取 $U \\sim \\mathrm{Uniform}(0,1)$ 并返回 $F^{-1}(U)$）的定义，判断下列哪个程序正确地实现了针对此目标分布的逆变换采样。选择所有适用的选项。\n\nA. 抽取 $U \\sim \\mathrm{Uniform}(0,1)$。如果 $U \\le 1/5$，则令 $X = \\sqrt{5U}$；否则令 $X = (5U + 11)/4$。\n\nB. 抽取 $B \\sim \\mathrm{Bernoulli}(1/5)$。如果 $B = 1$，抽取 $U_1 \\sim \\mathrm{Uniform}(0,1)$ 并令 $X = \\sqrt{U_1}$。如果 $B = 0$，抽取 $U_2 \\sim \\mathrm{Uniform}(0,1)$ 并令 $X = 3 + U_2$。\n\nC. 抽取 $U \\sim \\mathrm{Uniform}(0,1)$，并令 $X$ 为方程 $F(x) = U$ 的唯一解 $x$，其中 $F$ 是通过在间隙 $(1,3)$ 上进行线性插值构造的，以使 $F$ 在 $[0,4]$ 上严格递增。\n\nD. 抽取 $U \\sim \\mathrm{Uniform}(0,1)$ 并令 $X = 4U$。如果 $X \\in (1,3)$，则丢弃 $X$ 并重复此过程，直到 $X \\in [0,1] \\cup [3,4]$。\n\nE. 抽取 $B \\sim \\mathrm{Bernoulli}(1/2)$。如果 $B = 1$，抽取 $U_1 \\sim \\mathrm{Uniform}(0,1)$ 并令 $X = \\sqrt{U_1}$。如果 $B = 0$，抽取 $U_2 \\sim \\mathrm{Uniform}(0,1)$ 并令 $X = 3 + U_2$。", "solution": "用户提供了一个关于具有不相交支撑集的连续分布的逆变换采样问题。我的职责是首先验证问题陈述，然后提供一个严谨的解决方案。\n\n### 步骤 1：提取已知条件\n\n问题陈述中逐字提供的数据和定义如下：\n1.  连续目标分布的支撑集是区间的不相交集合 $[0,1] \\cup [3,4]$。\n2.  未归一化密度由下式给出\n    $$\n    g(x) = \n    \\begin{cases}\n    x,  x \\in [0,1],\\\\\n    2,  x \\in [3,4],\\\\\n    0,  \\text{otherwise}.\n    \\end{cases}\n    $$\n3.  归一化概率密度函数 (PDF) 为 $f(x) = g(x)/Z$，其中 $Z$ 是归一化常数。\n4.  累积分布函数 (CDF) 为 $F(x) = \\int_{-\\infty}^{x} f(t)\\,dt$。\n5.  广义逆 CDF 为 $F^{-1}(u) = \\inf\\{x \\in \\mathbb{R} : F(x) \\ge u\\}$，其中 $u \\in (0,1)$。\n6.  任务是识别哪个程序正确地实现了逆变换采样，定义为抽取 $U \\sim \\mathrm{Uniform}(0,1)$ 并返回 $F^{-1}(U)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n1.  **科学或事实不健全性**：该问题基于概率论和数值方法中标准的、明确定义的概念，包括 PDF、CDF、归一化和逆变换采样。没有违反科学原理之处。\n2.  **非形式化或不相关**：该问题是一个与逆变换采样主题直接相关的形式化数学练习。\n3.  **不完整或矛盾的设置**：未归一化密度 $g(x)$ 定义良好且非负。其积分为有限正数，确保了唯一的归一化常数 $Z$ 的存在。推导 PDF、CDF 和逆 CDF 所需的所有信息均已提供。设置是完整且一致的。\n4.  **不切实际或不可行**：该问题描述了一个有效的、尽管是自定义的概率分布。不存在物理或科学上的不可能性。\n5.  **不适定或结构不良**：该问题是适定的。PDF、CDF 和广义逆 CDF 都可以根据给定信息唯一确定。问题是明确的。\n6.  **伪深刻、琐碎或同义反复**：该问题需要仔细的推导，涉及具有不相交支撑集的分段函数以及对广义逆 CDF 的正确理解，是该主题下一个标准的、非平凡的练习。\n7.  **超出科学可验证性**：该问题是一个标准的数学问题，其解可通过数学推导完全验证。\n\n### 步骤 3：结论与行动\n\n问题陈述是**有效的**。现在开始求解过程。\n\n### 正确采样器的推导\n\n首先，我们通过对未归一化密度 $g(x)$ 在其支撑集上积分来计算归一化常数 $Z$。\n$$ Z = \\int_{-\\infty}^{\\infty} g(x)\\,dx = \\int_0^1 x\\,dx + \\int_3^4 2\\,dx $$\n$$ Z = \\left[ \\frac{x^2}{2} \\right]_0^1 + \\left[ 2x \\right]_3^4 = \\left( \\frac{1^2}{2} - 0 \\right) + (2(4) - 2(3)) = \\frac{1}{2} + (8-6) = \\frac{1}{2} + 2 = \\frac{5}{2} $$\n归一化 PDF $f(x) = g(x)/Z = \\frac{2}{5}g(x)$ 为：\n$$\nf(x) = \n\\begin{cases}\n\\frac{2}{5}x,  x \\in [0,1],\\\\\n\\frac{4}{5},  x \\in [3,4],\\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n接下来，我们推导 CDF $F(x) = \\int_{-\\infty}^{x} f(t)\\,dt$。\n- 对于 $x  0$，$F(x) = 0$。\n- 对于 $x \\in [0,1]$，$F(x) = \\int_0^x \\frac{2}{5}t\\,dt = \\frac{2}{5} \\left[\\frac{t^2}{2}\\right]_0^x = \\frac{1}{5}x^2$。\n- 对于 $x \\in (1,3)$，密度为 $0$，所以 CDF 是常数：$F(x) = F(1) = \\frac{1}{5}(1)^2 = \\frac{1}{5}$。\n- 对于 $x \\in [3,4]$，$F(x) = F(3) + \\int_3^x \\frac{4}{5}\\,dt = \\frac{1}{5} + \\frac{4}{5}[t]_3^x = \\frac{1}{5} + \\frac{4}{5}(x-3) = \\frac{1 + 4x - 12}{5} = \\frac{4x - 11}{5}$。\n- 对于 $x > 4$，$F(x) = F(4) = \\frac{4(4) - 11}{5} = \\frac{16 - 11}{5} = 1$。\n\n总结起来，CDF 为：\n$$\nF(x) = \n\\begin{cases}\n0,  x  0, \\\\\n\\frac{1}{5}x^2,  x \\in [0,1], \\\\\n\\frac{1}{5},  x \\in (1,3), \\\\\n\\frac{4x - 11}{5},  x \\in [3,4], \\\\\n1,  x > 4.\n\\end{cases}\n$$\n逆变换采样需要找到 $X = F^{-1}(U)$，其中 $U \\sim \\mathrm{Uniform}(0,1)$。我们必须解方程 $F(X)=U$ 来求 $X$。\n- **情况 1：$U \\in (0, 1/5]$**。\nCDF 的相关部分是 $F(x) = \\frac{1}{5}x^2$，适用于 $x \\in [0,1]$。\n$$ U = \\frac{1}{5}X^2 \\implies 5U = X^2 \\implies X = \\sqrt{5U} $$\n对于这个 $U$ 的范围，$X$ 在 $[0,1]$ 内，这与条件一致。\n\n- **情况 2：$U \\in (1/5, 1)$**。\n对于 $x \\in [1,3]$，CDF 在 $1/5$ 处是平坦的。因此，任何大于 $1/5$ 的 $U$ 都必须对应于一个大于或等于 $3$ 的 $X$ 值。CDF 的相关部分是 $F(x) = \\frac{4x - 11}{5}$，适用于 $x \\in [3,4]$。\n$$ U = \\frac{4X - 11}{5} \\implies 5U = 4X - 11 \\implies 4X = 5U + 11 \\implies X = \\frac{5U + 11}{4} $$\n对于这个 $U$ 的范围，$X$ 在 $(3,4]$ 内，这与条件一致。\n\n完整的逆变换采样算法是：\n1. 抽取 $U \\sim \\mathrm{Uniform}(0,1)$。\n2. 如果 $U \\le 1/5$，则令 $X = \\sqrt{5U}$。\n3. 如果 $U > 1/5$，则令 $X = \\frac{5U + 11}{4}$。\n由于 $U$ 是一个连续随机变量，概率 $P(U=1/5)=0$，因此边界条件可以是严格的 ($$) 或非严格的 ($\\le$)，而不会改变最终的分布。\n\n### 逐项分析\n\n**A. 抽取 $U \\sim \\mathrm{Uniform}(0,1)$。如果 $U \\le 1/5$，则令 $X = \\sqrt{5U}$；否则令 $X = (5U + 11)/4$。**\n这个程序与我们推导出的逆变换采样算法完全匹配。`otherwise`（否则）条件对应于 $U > 1/5$。如前所述，对于连续变量，在 $U=1/5$ 处的边界处理不影响结果。此程序是 $X=F^{-1}(U)$ 的直接应用。\n**结论：正确**\n\n**B. 抽取 $B \\sim \\mathrm{Bernoulli}(1/5)$。如果 $B = 1$，抽取 $U_1 \\sim \\mathrm{Uniform}(0,1)$ 并令 $X = \\sqrt{U_1}$。如果 $B = 0$，抽取 $U_2 \\sim \\mathrm{Uniform}(0,1)$ 并令 $X = 3 + U_2$。**\n这个程序描述了一种基于混合分解的采样方法，通常称为复合方法。我们来分析一下。\n$[0,1]$ 上的总概率质量为 $P(X \\in [0,1]) = F(1) - F(0) = 1/5$。\n$[3,4]$ 上的总概率质量为 $P(X \\in [3,4]) = F(4) - F(3) = 1 - 1/5 = 4/5$。\n该程序以 $1/5$ 的概率正确选择了第一个区间（因为 $B \\sim \\mathrm{Bernoulli}(1/5)$ 意味着 $P(B=1)=1/5$），并以 $4/5$ 的概率选择了第二个区间（$P(B=0)=1-1/5=4/5$）。\n- 当从第一个分量采样时（概率为 $1/5$），我们需要从条件密度 $f(x | x \\in [0,1]) = \\frac{f(x)}{P(X \\in [0,1])} = \\frac{(2/5)x}{1/5} = 2x$ (对于 $x \\in [0,1]$) 中采样。相应的 CDF 为 $F_1(x) = \\int_0^x 2t\\,dt = x^2$。对其求逆得到 $x = \\sqrt{u_1}$，这与程序相符。\n- 当从第二个分量采样时（概率为 $4/5$），条件密度为 $f(x | x \\in [3,4]) = \\frac{f(x)}{P(X \\in [3,4])} = \\frac{4/5}{4/5} = 1$ (对于 $x \\in [3,4]$)。这是一个在 $[3,4]$ 上的均匀分布。在 $[a,b]$ 上的均匀分布的 CDF 是 $(x-a)/(b-a)$，所以这里是 $(x-3)/(4-3) = x-3$。对其求逆得到 $x = 3+u_2$，这与程序相符。\n对于混合分布或具有不相交支撑集的分布，这种复合方法是一种标准且正确的实现逆变换采样的方式。它可以被证明与 A 中的直接方法等价（可以从单个 $U$ 构造出 $B$、$U_1$ 和 $U_2$）。\n**结论：正确**\n\n**C. 抽取 $U \\sim \\mathrm{Uniform}(0,1)$，并令 $X$ 为方程 $F(x) = U$ 的唯一解 $x$，其中 $F$ 是通过在间隙 $(1,3)$ 上进行线性插值构造的，以使 $F$ 在 $[0,4]$ 上严格递增。**\n真实的 CDF 满足 $F(1) = 1/5$ 和 $F(3) = 1/5$。在点 $(1, 1/5)$ 和 $(3, 1/5)$ 之间进行线性插值会得到一条恒定的水平线段，这并非“严格递增”。该选项的前提在逻辑上是有缺陷的。此外，任何将 CDF 在区间 $(1,3)$ 上修改为非常数的做法都意味着在该区间内存在非零的概率密度。这将从一个不同于目标分布的分布中生成样本，而目标分布在 $(1,3)$ 上的密度为零。\n**结论：不正确**\n\n**D. 抽取 $U \\sim \\mathrm{Uniform}(0,1)$ 并令 $X = 4U$。如果 $X \\in (1,3)$，则丢弃 $X$ 并重复此过程，直到 $X \\in [0,1] \\cup [3,4]$。**\n这描述的是一种拒绝采样，而非逆变换采样。我们来看看它生成的分布。初始样本 $X$ 来自 $\\mathrm{Uniform}(0,4)$，其 PDF 在 $[0,4]$ 上为 $p(x) = 1/4$。该程序接受落在 $[0,1] \\cup [3,4]$ 内的样本。被接受样本的分布，我们称之为 $h(x)$，是原始 PDF 在接受域上的条件分布。\n$$ h(x) = \\frac{p(x)}{\\int_0^1 p(t)dt + \\int_3^4 p(t)dt} = \\frac{1/4}{\\int_0^1 (1/4)dt + \\int_3^4 (1/4)dt} = \\frac{1/4}{1/4 + 1/4} = \\frac{1/4}{1/2} = \\frac{1}{2} $$\n最终得到的分布在 $[0,1]$ 上的 PDF 为 $h(x)=1/2$，在 $[3,4]$ 上的 PDF 也为 $h(x)=1/2$。这与目标 PDF $f(x)$ 不同，目标 PDF 在 $[0,1]$ 上是 $f(x) = (2/5)x$，在 $[3,4]$ 上是 $f(x) = 4/5$。\n**结论：不正确**\n\n**E. 抽取 $B \\sim \\mathrm{Bernoulli}(1/2)$。如果 $B = 1$，抽取 $U_1 \\sim \\mathrm{Uniform}(0,1)$ 并令 $X = \\sqrt{U_1}$。如果 $B = 0$，抽取 $U_2 \\sim \\mathrm{Uniform}(0,1)$ 并令 $X = 3 + U_2$。**\n这是另一种混合采样程序，与 B 类似。然而，它使用了一个 $\\mathrm{Bernoulli}(1/2)$ 变量。这意味着它以 $1/2$ 的概率选择第一个分量（在 $[0,1]$ 上采样），并以 $1/2$ 的概率选择第二个分量（在 $[3,4]$ 上采样）。根据对选项 B 的计算，这些分量的正确概率应分别为 $1/5$ 和 $4/5$。使用不正确的混合权重会从错误的分布中生成样本。\n**结论：不正确**", "answer": "$$\\boxed{AB}$$", "id": "3244485"}, {"introduction": "我们最后的实践将从解析分布转向科学计算中的一个常见实际任务：从一个由直方图表示的经验分布中采样。这个练习展示了如何将逆变换采样应用于数据驱动的模型，其中概率密度函数是分段常数。掌握这项技术使你能够生成模拟观测数据的样本，这是仿真和建模中的一项基本技能。[@problem_id:3244347]", "problem": "考虑一个实数区间上的概率分布，该分布由一个具有非均匀组距宽度的直方图指定。该直方图由一个严格递增的组距边界序列 $E = [e_0, e_1, \\dots, e_m]$ 和正的组距高度序列 $H = [h_0, h_1, \\dots, h_{m-1}]$ 给出。其解释是，概率密度函数 $f(x)$ 在每个组距 $[e_i, e_{i+1})$ 上是分段常数，在该组距上 $f(x)$ 与 $h_i$ 成正比，而在 $[e_0, e_m]$ 之外为零。累积分布函数 $F(x)$ 由基本关系 $F(x) = \\int_{-\\infty}^{x} f(t) \\, dt$ 定义，而逆变换采样法利用累积分布函数的定义来生成样本：如果 $U$ 是 $[0,1)$ 上的一个均匀随机变量，则通过求解 $F(x) = U$ 得到 $x$，即可获得目标分布的一个样本。\n\n您的任务是：\n\n- 从第一性原理出发，推导并实现一个数值稳定的采样器，该采样器使用逆变换采样法从由 $(E, H)$ 描述的分布中生成独立样本。利用 $f(x)$ 在每个组距 $[e_i, e_{i+1})$ 上是分段常数这一性质，并回顾概率密度函数的积分必须为 $1$，这决定了一个归一化常数。\n- 构建一个函数，用于在任意查询点 $x$ 处评估累积分布函数 $F(x)$，该函数需与分段常数的 $f(x)$ 和基本定义 $F(x) = \\int_{-\\infty}^x f(t)\\,dt$ 保持一致。\n- 使用逆变换采样法生成随机样本。为保证可复现性，您必须对每个测试用例使用指定的固定伪随机数生成器种子。本问题不涉及角度，也不涉及任何物理单位。\n\n实现要求：\n\n- 将组距高度 $h_i$ 视为相对密度高度，即组距 $i$ 上的未归一化密度为 $h_i$，归一化因子确保 $\\int f(x)\\,dx = 1$。\n- 确保 $h_i = 0$ 的组距不贡献概率质量；采样器不应选择这些组距。\n- 处理 $F(x)$ 的边界条件，使得当 $x \\le e_0$ 时 $F(x) = 0$，当 $x \\ge e_m$ 时 $F(x) = 1$。\n\n测试套件：\n\n提供以下三个测试用例的结果。对于每个用例，按顺序计算并输出：\n\n1. 归一化常数 $c$，使得在组距 $i$ 上 $f(x) = c \\cdot h_i$。\n\n2. 在第一个查询点 $q_1$ 处的累积分布函数值 $F(q_1)$。\n\n3. 在第二个查询点 $q_2$ 处的累积分布函数值 $F(q_2)$。\n\n4. 使用指定种子，通过您的逆变换采样器生成的 $N$ 个独立样本的样本均值 $\\bar{x}$。样本均值必须是实值浮点数。\n\n三个用例如下：\n\n- 用例 1：$E = [0,1,3,4]$，$H = [2,1,3]$，查询点 $Q = [0.5, 3.2]$，样本量 $N = 1000$，种子 $S = 314159$。\n- 用例 2：$E = [-2,0,0.5,2.5]$，$H = [0,4,1]$，查询点 $Q = [-1.0, 2.0]$，样本量 $N = 800$，种子 $S = 271828$。\n- 用例 3：$E = [0,0.1,1.0]$，$H = [10,0.1]$，查询点 $Q = [0.05, 0.5]$，样本量 $N = 1200$，种子 $S = 1618033$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按上述顺序包含 $12$ 个浮点数，汇总三个用例的结果，例如 $[c_1,F_1(q_{1}),F_1(q_{2}),\\bar{x}_1,c_2,F_2(q_{1}),F_2(q_{2}),\\bar{x}_2,c_3,F_3(q_{1}),F_3(q_{2}),\\bar{x}_3]$，不含任何额外文本。所有数字都必须以标准十进制浮点数格式打印。不需要任何物理单位或角度单位，结果不应以百分号表示。输出列表的每个元素都必须是浮点数。", "solution": "为分段常数概率密度函数构建逆变换采样器，始于概率论的核心定义。实线上的概率密度函数 $f(x)$ 必须满足 $\\int_{-\\infty}^{\\infty} f(x)\\,dx = 1$，累积分布函数定义为 $F(x) = \\int_{-\\infty}^{x} f(t)\\,dt$。逆变换采样法利用以下原理：如果 $U$ 是一个在 $[0,1)$ 上均匀分布的随机变量，且 $F$ 是一个连续、非递减函数，满足 $F(e_0) = 0$ 和 $\\lim_{x\\to\\infty}F(x) = 1$，则求解 $F(x) = U$ 得到的随机样本 $x$ 服从 $f$ 的分布。\n\n我们给定一个具有非均匀组距宽度的直方图，由严格递增的组距边界 $E = [e_0, e_1, \\dots, e_m]$ 和组距高度 $H = [h_0, h_1, \\dots, h_{m-1}]$（其中 $h_i \\ge 0$）描述。其解释是，未归一化的概率密度函数是分段常数：对于 $x \\in [e_i, e_{i+1})$，我们有 $f(x) \\propto h_i$，而在 $[e_0, e_m]$ 之外，我们有 $f(x) = 0$。令 $w_i = e_{i+1} - e_i$ 表示组距 $i$ 的宽度。归一化常数 $c$ 由 $f(x)$ 在其支撑集上的积分等于 $1$ 这一要求确定：\n$$\n\\int_{-\\infty}^{\\infty} f(x)\\,dx = \\sum_{i=0}^{m-1} \\int_{e_i}^{e_{i+1}} c \\cdot h_i \\, dx = c \\sum_{i=0}^{m-1} h_i \\cdot (e_{i+1} - e_i) = 1.\n$$\n因此，\n$$\nc = \\left( \\sum_{i=0}^{m-1} h_i \\cdot (e_{i+1} - e_i) \\right)^{-1}.\n$$\n$h_i = 0$ 的组距贡献零质量，除了通过边界影响外，不影响采样器。\n\n累积分布函数 $F(x)$ 源于其定义 $F(x) = \\int_{-\\infty}^{x} f(t)\\,dt$。对于 $x \\le e_0$，我们有 $F(x) = 0$。对于 $x \\ge e_m$，我们有 $F(x) = 1$。对于 $x \\in [e_i, e_{i+1})$，\n$$\nF(x) = \\sum_{j=0}^{i-1} \\int_{e_j}^{e_{j+1}} c h_j \\, dt + \\int_{e_i}^{x} c h_i \\, dt = \\sum_{j=0}^{i-1} c h_j (e_{j+1} - e_j) + c h_i (x - e_i).\n$$\n因此，它是一个在支撑集上从 $0$ 增加到 $1$ 的连续分段线性函数。\n\n为构建逆变换采样器，我们首先预计算累积的组距末端质量：\n$$\nM_i^{\\text{end}} = \\sum_{j=0}^{i} c h_j (e_{j+1} - e_j), \\quad i = 0,1,\\dots,m-1,\n$$\n根据归一化，有 $M_{m-1}^{\\text{end}} = 1$。令 $M_i^{\\text{start}} = \\sum_{j=0}^{i-1} c h_j (e_{j+1} - e_j)$ 表示到组距 $i$ 起始处的累积质量（其中 $M_0^{\\text{start}} = 0$）。给定一个均匀随机变量 $U \\in [0,1)$，我们确定唯一的组距索引 $i$，使得 $M_i^{\\text{start}} \\le U  M_i^{\\text{end}}$。这个选择步骤可以通过对 $M_i^{\\text{end}}$ 数组进行二分查找来高效实现。在组距 $i$ 内，方程 $F(x) = U$ 变为\n$$\nM_i^{\\text{start}} + c h_i (x - e_i) = U,\n$$\n可以直接解出 $x$：\n$$\nx = e_i + \\frac{U - M_i^{\\text{start}}}{c h_i}.\n$$\n该公式在 $h_i > 0$ 的条件下有效，这一点是有保证的，因为 $h_i = 0$ 的组距质量为零，因此不会被搜索步骤选中。数值稳定性的考虑包括确保 $U$ 位于 $[0,1)$ 内（由于浮点舍入不等于 $1$），以及使用稳健的搜索过程来处理因组距质量为零而导致的重复累积质量值。\n\n分布的解析均值对于验证很有用，它直接从期望值的定义中导出：\n$$\n\\mathbb{E}[X] = \\int_{-\\infty}^{\\infty} x f(x)\\,dx = \\sum_{i=0}^{m-1} \\int_{e_i}^{e_{i+1}} x \\cdot c h_i \\, dx = c \\sum_{i=0}^{m-1} h_i \\left( \\frac{e_{i+1}^2 - e_i^2}{2} \\right).\n$$\n尽管程序只要求输出归一化常数、选定的累积分布函数值和样本均值，但这个表达式是实现正确性的基础，并在内部用于验证。\n\n算法步骤：\n\n- 验证 $E$ 是严格递增的，并且所有 $h_i \\ge 0$。\n- 计算组距宽度 $w_i = e_{i+1} - e_i$ 和归一化常数 $c = \\left( \\sum_i h_i w_i \\right)^{-1}$。\n- 计算组距末端的累积质量 $M_i^{\\text{end}} = \\sum_{j=0}^{i} c h_j w_j$。\n- 通过以下方式实现 $F(x)$：\n  - 如果 $x \\le e_0$，返回 $0$，\n  - 如果 $x \\ge e_m$，返回 $1$，\n  - 否则，定位满足 $e_i \\le x  e_{i+1}$ 的组距 $i$，并计算 $F(x) = M_i^{\\text{start}} + c h_i (x - e_i)$。\n- 通过以下方式实现逆变换采样：\n  - 从一个 Uniform$(0,1)$ 生成器中抽取 $U$，\n  - 如有必要，将 $U$ 截断为一个严格小于 $1$ 的值，\n  - 通过对 $M_i^{\\text{end}}$ 进行二分查找，定位满足 $U  M_i^{\\text{end}}$ 的组距 $i$，\n  - 恢复起始质量 $M_i^{\\text{start}}$ 并计算 $x = e_i + \\frac{U - M_i^{\\text{start}}}{c h_i}$。\n- 对每个测试用例，计算 $c$，在两个查询点处评估 $F$，并使用指定的种子计算 $N$ 个样本的样本均值以保证可复现性。\n- 将 $12$ 个浮点数按指定顺序作为单个方括号括起的逗号分隔列表输出。\n\n此方法完全遵循从概率密度函数和累积分布函数的基本定义推导出的逆变换采样法，并正确处理了非均匀组距宽度和零高度组距的情况。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_normalization_constant(edges, heights):\n    # edges: list of bin edges, strictly increasing\n    # heights: list of nonnegative bin heights (relative densities)\n    widths = np.diff(edges)\n    total = np.dot(heights, widths)\n    if total = 0:\n        raise ValueError(\"Total unnormalized mass must be positive.\")\n    return 1.0 / total\n\ndef compute_cumulative_end_masses(edges, heights, c):\n    widths = np.diff(edges)\n    bin_masses = c * heights * widths\n    cum_end = np.cumsum(bin_masses)\n    return cum_end  # end-of-bin cumulative masses\n\ndef cdf_from_histogram(edges, heights, c, x):\n    # Piecewise linear CDF consistent with piecewise constant PDF\n    e = np.array(edges)\n    h = np.array(heights)\n    if x = e[0]:\n        return 0.0\n    if x >= e[-1]:\n        return 1.0\n    # Find bin i such that e[i] = x  e[i+1]\n    i = np.searchsorted(e, x, side='right') - 1\n    # Compute cumulative mass up to start of bin i\n    widths = np.diff(e)\n    bin_masses = c * h * widths\n    if i > 0:\n        start_mass = float(np.sum(bin_masses[:i]))\n    else:\n        start_mass = 0.0\n    # Contribution within bin i\n    return start_mass + c * h[i] * (x - e[i])\n\ndef inverse_transform_sample(edges, heights, size, seed):\n    # Build cumulative end-of-bin masses to locate bins\n    e = np.array(edges, dtype=float)\n    h = np.array(heights, dtype=float)\n    if np.any(np.diff(e) = 0):\n        raise ValueError(\"Edges must be strictly increasing.\")\n    if np.any(h  0):\n        raise ValueError(\"Heights must be nonnegative.\")\n    c = compute_normalization_constant(e, h)\n    cum_end = compute_cumulative_end_masses(e, h, c)\n    rng = np.random.default_rng(seed)\n    # Draw uniforms in [0,1)\n    u = rng.random(size=size)\n    # Clip any values that are numerically 1.0 (extremely unlikely) to just below 1.0\n    u = np.minimum(u, np.nextafter(1.0, 0.0))\n    # Locate bin index for each u: find first cum_end > u\n    idx = np.searchsorted(cum_end, u, side='right')\n    # Compute start mass for each selected bin\n    # For idx == 0, start_mass = 0; else start_mass = cum_end[idx-1]\n    start_mass = np.where(idx > 0, cum_end[idx - 1], 0.0)\n    # Compute x for each sample: e[idx] + (u - start_mass)/(c * h[idx])\n    # Ensure heights for selected bins are positive; bins with zero height have zero mass and won't be selected.\n    selected_heights = h[idx]\n    # To be safe, handle any potential zero height (shouldn't occur) by leaving x at left edge\n    denom = c * selected_heights\n    # Avoid divide-by-zero by assigning any zero denom to 1 (and zero numerator), though should not happen.\n    safe_denom = np.where(denom == 0.0, 1.0, denom)\n    offset = (u - start_mass) / safe_denom\n    x = e[idx] + offset\n    return x\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"edges\": [0.0, 1.0, 3.0, 4.0],\n            \"heights\": [2.0, 1.0, 3.0],\n            \"queries\": [0.5, 3.2],\n            \"N\": 1000,\n            \"seed\": 314159\n        },\n        {\n            \"edges\": [-2.0, 0.0, 0.5, 2.5],\n            \"heights\": [0.0, 4.0, 1.0],\n            \"queries\": [-1.0, 2.0],\n            \"N\": 800,\n            \"seed\": 271828\n        },\n        {\n            \"edges\": [0.0, 0.1, 1.0],\n            \"heights\": [10.0, 0.1],\n            \"queries\": [0.05, 0.5],\n            \"N\": 1200,\n            \"seed\": 1618033\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        edges = case[\"edges\"]\n        heights = case[\"heights\"]\n        queries = case[\"queries\"]\n        N = case[\"N\"]\n        seed = case[\"seed\"]\n\n        c = compute_normalization_constant(edges, heights)\n        # Compute CDF values at queries\n        Fq1 = cdf_from_histogram(edges, heights, c, queries[0])\n        Fq2 = cdf_from_histogram(edges, heights, c, queries[1])\n        # Generate samples and compute sample mean\n        samples = inverse_transform_sample(edges, heights, N, seed)\n        sample_mean = float(np.mean(samples))\n\n        results.extend([float(c), float(Fq1), float(Fq2), sample_mean])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3244347"}]}