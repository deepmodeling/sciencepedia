{"hands_on_practices": [{"introduction": "内点法（Interior Point Method）这个名称并非偶然。它精确地描述了算法的核心思想：所有迭代点都严格保持在可行域的“内部”。本练习 [@problem_id:3242666] 是一个关键的思想实验，它挑战您思考：如果一个迭代点不慎落在了可行域的边界上，将会发生什么？通过分析这一失效场景，您将深刻理解为何算法必须维持变量的严格正性，以及这一要求是如何从构建牛顿法搜索方向的代数结构中自然产生的。", "problem": "考虑标准形式的线性规划，其变量为 $x \\in \\mathbb{R}^n$，对偶变量为 $y \\in \\mathbb{R}^m$，对偶松弛变量为 $s \\in \\mathbb{R}^n$：\n最小化 $c^\\top x$，约束条件为 $A x = b$ 和 $x \\ge 0$，其中 $A \\in \\mathbb{R}^{m \\times n}$，$b \\in \\mathbb{R}^m$，$c \\in \\mathbb{R}^n$。原始-对偶内点法强制执行 Karush–Kuhn–Tucker (KKT) 条件 $A x = b$，$A^\\top y + s = c$，$X S e = \\mu e$，以及 $x  0$，$s  0$，其中 $X = \\mathrm{diag}(x)$，$S = \\mathrm{diag}(s)$，$e \\in \\mathbb{R}^n$ 是全1向量，$\\mu  0$ 是一个控制互补性的标量。在每次迭代中，通过线性化 KKT 条件来计算牛顿步 $(\\Delta x, \\Delta y, \\Delta s)$，并使用步长 $0  \\alpha \\le 1$ 更新新的迭代点 $x^+ = x + \\alpha \\Delta x$，$y^+ = y + \\alpha \\Delta y$ 和 $s^+ = s + \\alpha \\Delta s$。选择步长 $\\alpha$ 以保持 $x$ 和 $s$ 的严格正性。\n\n假设步长规则 $\\alpha$ 存在缺陷，并允许某个分量，例如 $x_j^+$ 或 $s_j^+$，在下一个迭代点变为恰好为 $0$。仅以 KKT 结构和牛顿线性化为基础，确定在下一次迭代中，形成后续牛顿系统所需的代数运算必然在何处失效。选择最精确的陈述。\n\nA. 形成下一个牛顿系统需要计算由 $x$ 和 $s$ 构成的对角矩阵的逆和平方根，例如 $X^{-1}$，$S^{-1}$ 和 $D = S^{-1/2} X^{1/2}$；当 $x_j = 0$ 或 $s_j = 0$ 时，这些运算是未定义的，因此法方程矩阵 $A S^{-1} X A^\\top$ 无法被构建。\n\nB. 牛顿系统仍然是良定的，因为方程仅涉及 $X$ 和 $S$（而非它们的逆），所以零元素不影响可解性；仅需对残差进行微小调整。\n\nC. 互补性残差 $r_\\mu = X S e - \\sigma \\mu e$ 仍然是可计算的，因此下一次迭代的代数运算是完整的；如果有失效，也只发生在达到精确最优性时。\n\nD. 当任何分量为零时，中心路径参数 $\\mu = \\frac{x^\\top s}{n}$ 会变为负数，因此算法因 $\\mu  0$ 不被允许而失败；牛顿系统本身在代数上仍然是良定的。", "solution": "我们从线性规划的 Karush–Kuhn–Tucker (KKT) 条件开始：$A x = b$，$A^\\top y + s = c$，$x \\ge 0$，$s \\ge 0$，以及在最优性条件下对所有 $i$ 都有的互补性条件 $x_i s_i = 0$。在内点法中，我们用 $X S e = \\mu e$（其中 $x  0$，$s  0$ 和 $\\mu  0$）来替代严格的互补性条件，从而保持迭代点严格位于可行域内部。牛顿系统是通过线性化原始可行性、对偶可行性和互补性的残差来导出的。设残差为\n$r_b = A x - b$，\n$r_c = A^\\top y + s - c$，\n$r_\\mu = X S e - \\sigma \\mu e$，\n其中 $0 \\le \\sigma \\le 1$ 是一个中心化参数。\n\n线性化得到系统\n$A \\Delta x = - r_b$，\n$A^\\top \\Delta y + \\Delta s = - r_c$，\n$S \\Delta x + X \\Delta s = - r_\\mu$。\n从第二个方程中消去 $\\Delta s$，我们得到 $\\Delta s = - r_c - A^\\top \\Delta y$。将其代入第三个方程得到\n$S \\Delta x + X(- r_c - A^\\top \\Delta y) = - r_\\mu$，\n整理后得到\n$S \\Delta x - X A^\\top \\Delta y = - r_\\mu + X r_c$。\n为了消去 $\\Delta x$，求解 $S \\Delta x = - r_\\mu + X r_c + X A^\\top \\Delta y$ 并左乘 $S^{-1}$，得到\n$\\Delta x = S^{-1}(- r_\\mu + X r_c + X A^\\top \\Delta y)$。\n将此结果代入 $A \\Delta x = - r_b$ 给出关于 $\\Delta y$ 的法方程：\n$A S^{-1}(- r_\\mu + X r_c + X A^\\top \\Delta y) = - r_b$，\n或等价地，\n$A S^{-1} X A^\\top \\Delta y = - r_b + A S^{-1}(r_\\mu - X r_c)$。\n\n这个推导过程展示了一个关键的结构性要求：对角矩阵 $X$ 和 $S$ 的对角元素必须是严格正的，这样它们的逆矩阵 $X^{-1}$ 和 $S^{-1}$ 才存在。许多实现还使用对称缩放 $D = S^{-1/2} X^{1/2}$ 来稳定地分解法方程。此外，如果从原始障碍函数的角度来看，对数障碍函数 $- \\sum_{i=1}^n \\ln x_i$ 的梯度是 $- X^{-1} e$，这在 $x_j = 0$ 时是未定义的。\n\n如果步长 $\\alpha$ 允许 $x_j^+ = 0$ 或 $s_j^+ = 0$，那么在下一次迭代中，$X$ 或 $S$ 将会有一个零对角元素。在形成牛顿方向（通过消元）或进行常用缩放时所需的代数运算 $X^{-1}$，$S^{-1}$，$S^{-1/2}$ 和 $X^{1/2}$ 将变得未定义。特别是，法方程矩阵 $A S^{-1} X A^\\top$ 无法形成，因为当任何 $s_j = 0$ 时 $S^{-1}$ 不存在；类似地，涉及 $X^{-1}$ 的其他消元方法在任何 $x_j = 0$ 时也会失败。因此，失效恰好发生在为下一个牛顿步构建线性系统的时刻。\n\n逐项分析：\n\nA. 该选项陈述，下一个牛顿系统需要 $X$ 和 $S$ 的逆和平方根，例如 $X^{-1}$，$S^{-1}$ 和 $D = S^{-1/2} X^{1/2}$，并且当某个分量为零时，这些运算是未定义的，从而无法构建法方程 $A S^{-1} X A^\\top$。这与推导相符：消元法明确地使用了 $S^{-1}$（或在另一种形式中，使用了 $X^{-1}$），而对称缩放使用了正元素的平方根。当 $x_j = 0$ 或 $s_j = 0$ 时，这些运算没有定义，因此代数运算失败。结论：正确。\n\nB. 该选项声称牛顿系统只涉及 $X$ 和 $S$ 而不涉及它们的逆，因此零值不影响可解性。推导过程显示了相反的情况：为了形成一个简化的系统，消元法使用了 $S^{-1}$（通常也使用 $X^{-1}$），如果试图避免使用逆矩阵，当对角线元素为零时，包含 $S$ 和 $X$ 的分块系统会变得奇异。因此，可解性和系统的构建都依赖于严格正性。结论：不正确。\n\nC. 该选项断言，因为 $r_\\mu$ 可以被计算，所以代数运算是完整的，失效只发生在达到最优性时。虽然即使某些元素为零，$r_\\mu = X S e - \\sigma \\mu e$ 仍然可以被计算（它会产生有限的数值），但计算牛顿方向需要 $S^{-1}$ 或 $X^{-1}$。因此，代数失效发生在达到最优性之前，即在形成下一个牛顿系统时立即发生。结论：不正确。\n\nD. 该选项陈述，当任何分量为零时，$\\mu = \\frac{x^\\top s}{n}$ 会变为负数。如果任何分量为零，$x^\\top s$ 可能会减小，可能减至 $0$，但它仍然是一个非负实数；除以 $n$ 会得到一个非负标量。符号问题是错误的，并且无论如何，核心问题是未定义的逆矩阵，而不是 $\\mu$ 的符号。结论：不正确。", "answer": "$$\\boxed{A}$$", "id": "3242666"}, {"introduction": "在理解了为何必须停留在可行域内部之后，下一个问题自然是：在内部我们具体做什么？本练习 [@problem_id:3242579] 通过一个半定规划（Semidefinite Program, SDP）的具体例子，展示了内点法的单步迭代过程。您将亲手计算一个完整的原始-对偶迭代步骤，从建立线性化系统到求解搜索方向并更新变量，从而揭开所有内点法核心的迭代过程的神秘面纱。", "problem": "您将完成一个分为两部分的任务，该任务将约束特征值最小化问题与半定规划 (SDP) 联系起来，然后使用 Nesterov–Todd (NT) 缩放执行一次原始-对偶内点法的单次迭代。\n\n第一部分（公式化）。考虑以下约束特征值最小化问题：\n- 最小化对称矩阵 $Z \\in \\mathbb{S}^{2}$ 的最大特征值，\n- 满足线性约束 $\\operatorname{tr}(Z) = 2$。\n\n从最大特征值 $\\lambda_{\\max}(Z)$ 的定义（即满足 $t I - Z \\succeq 0$ 的最小实数 $t$）出发，推导出一个以 $(t, Z)$ 为决策变量的等价线性矩阵不等式 (LMI) 公式，作为一种 SDP，并明确陈述其锥形式约束。\n\n第二部分（一次 NT 缩放的原始-对偶迭代和中心对称性）。考虑与锥块 $X \\in \\mathbb{S}^{2}$ 相关的标准形式 SDP：\n- 最小化 $C \\bullet X$，\n- 满足 $A \\bullet X = b$，\n- 且 $X \\succ 0$，\n其中 $C = 0 \\cdot I \\in \\mathbb{S}^{2}$，$A = I \\in \\mathbb{S}^{2}$，$b = 2 \\in \\mathbb{R}$，且 $\\bullet$ 表示 Frobenius 内积。其对偶问题是：\n- 最大化 $b y$，\n- 满足 $A^{*}(y) + S = C$，\n- 且 $S \\succ 0$，\n其中 $A^{*}(y) = y I$ 且 $S \\in \\mathbb{S}^{2}$。\n\n从给定的严格可行的原始-对偶点 $(X_{0}, y_{0}, S_{0})$ 开始，其中 $X_{0} = I$，$y_{0} = -2$，$S_{0} = 2 I$。设置中心化参数为 $\\sigma = \\tfrac{1}{2}$。使用 Nesterov–Todd (NT) 缩放的原始-对偶方向，计算一次迭代。如果完整步长能保持正定性，则使用完整步长；否则，使用能保持 $X \\succ 0$ 和 $S \\succ 0$ 的最大步长。然后：\n- 计算更新后的对偶测度 $\\mu_{1} = \\tfrac{1}{n} \\operatorname{tr}(X_{1} S_{1})$，其中 $n = 2$，\n- 并验证中心对称条件 $X_{1} S_{1} = \\mu_{1} I$。\n\n报告标量值 $\\mu_{1}$ 作为您的最终答案。无需四舍五入；请提供精确值。", "solution": "首先验证问题陈述，以确保其科学上合理、适定且客观。\n\n### 步骤 1：提取已知条件\n**第一部分：**\n- 目标：最小化对称矩阵 $Z \\in \\mathbb{S}^{2}$ 的最大特征值 $\\lambda_{\\max}(Z)$。\n- 约束：$\\operatorname{tr}(Z) = 2$。\n- 定义：$\\lambda_{\\max}(Z)$ 是满足 $t I - Z \\succeq 0$ 的最小实数 $t$。\n- 任务：推导一个以 $(t, Z)$ 为决策变量的等价半定规划 (SDP)，并陈述其锥形式约束。\n\n**第二部分：**\n- 原始 SDP：最小化 $C \\bullet X$，满足 $A \\bullet X = b$ 和 $X \\succ 0$。\n- 原始数据：$X \\in \\mathbb{S}^{2}$，$C = 0 \\cdot I \\in \\mathbb{S}^{2}$，$A = I \\in \\mathbb{S}^{2}$，$b = 2 \\in \\mathbb{R}$。\n- 对偶 SDP：最大化 $b y$，满足 $A^{*}(y) + S = C$ 和 $S \\succ 0$。\n- 对偶数据：$S \\in \\mathbb{S}^{2}$，$A^{*}(y) = y I$。\n- 初始点：$(X_{0}, y_{0}, S_{0})$，其中 $X_{0} = I$，$y_{0} = -2$，$S_{0} = 2 I$。\n- 中心化参数：$\\sigma = \\frac{1}{2}$。\n- 方法：Nesterov–Todd (NT) 缩放的原始-对偶方向。\n- 任务：\n  1. 计算一次迭代，找到 $(X_1, S_1, y_1)$，若可行则使用完整步长，否则使用最大可行步长。\n  2. 计算更新后的对偶测度 $\\mu_{1} = \\frac{1}{n} \\operatorname{tr}(X_{1} S_{1})$，其中 $n = 2$。\n  3. 验证中心对称条件 $X_{1} S_{1} = \\mu_{1} I$。\n  4. 报告 $\\mu_1$ 的值。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题定义明确，包含两个部分。\n\n第一部分是凸优化领域中一个标准的重新公式化任务，将一个特征值最小化问题转化为一个 SDP。所提供的定义是正确的。\n\n第二部分建立了一个特定的 SDP，并要求进行一次原始-对偶内点法的迭代。我们来验证初始点 $(X_0, y_0, S_0)$ 的可行性。\n- 原始严格可行性 ($X_0 \\succ 0$)：$X_0 = I$，即 $\\mathbb{S}^2$ 中的单位矩阵，是正定的。此条件成立。\n- 原始约束满足情况 ($A \\bullet X_0 = b$)：$A \\bullet X_0 = I \\bullet I = \\operatorname{tr}(I^T I) = \\operatorname{tr}(I) = 2$。给定的 $b=2$。约束得到满足。\n- 对偶严格可行性 ($S_0 \\succ 0$)：$S_0 = 2I$ 是正定的。此条件成立。\n- 对偶约束满足情况 ($A^{*}(y_0) + S_0 = C$)：$A^{*}(y_0) + S_0 = y_0 I + S_0 = (-2)I + 2I = 0$。给定的 $C = 0 \\cdot I = 0$。约束得到满足。\n\n所有数据都是自洽和一致的。该问题在数值优化方面具有科学依据，是客观且适定的。未检测到任何缺陷。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整解答。\n\n### 第一部分：公式化\n\n问题是最小化对称矩阵 $Z \\in \\mathbb{S}^{2}$ 的最大特征值，并满足其迹的线性约束。\n$$\n\\begin{array}{ll}\n\\text{最小化}  \\lambda_{\\max}(Z) \\\\\n\\text{满足}  \\operatorname{tr}(Z) = 2, \\\\\n Z \\in \\mathbb{S}^{2}.\n\\end{array}\n$$\n我们引入一个辅助标量变量 $t \\in \\mathbb{R}$。目标可以被重新表述为最小化 $t$，并附加约束 $t \\ge \\lambda_{\\max}(Z)$。问题变为：\n$$\n\\begin{array}{ll}\n\\text{最小化}  t \\\\\n\\text{满足}  \\lambda_{\\max}(Z) \\le t, \\\\\n \\operatorname{tr}(Z) = 2, \\\\\n Z \\in \\mathbb{S}^{2}, t \\in \\mathbb{R}.\n\\end{array}\n$$\n问题陈述提供了关键的等价关系：$\\lambda_{\\max}(Z) \\le t$ 等价于线性矩阵不等式 (LMI) $t I - Z \\succeq 0$，其中 $\\succeq 0$ 表示矩阵是半正定的，而 $I$ 是 $2 \\times 2$ 的单位矩阵。\n\n代入此等价关系，得到以决策变量 $(t, Z)$ 表示的 SDP 公式：\n$$\n\\begin{array}{ll}\n\\text{最小化}  t \\\\\n\\text{满足}  \\operatorname{tr}(Z) = 2, \\\\\n t I - Z \\succeq 0.\n\\end{array}\n$$\n由此产生的约束明确如下：\n1.  一个线性等式约束：$\\operatorname{tr}(Z) = 2$。\n2.  一个锥约束（具体来说，是一个 LMI）：矩阵 $t I - Z$ 必须是半正定的。\n\n### 第二部分：一次 NT 缩放的原始-对偶迭代\n\n给定 SDP 的原始-对偶对以及一个初始严格可行点 $(X_0, y_0, S_0) = (I, -2, 2I)$。矩阵维度为 $n=2$。\n\n首先，我们计算初始对偶测度 $\\mu_0$：\n$$ \\mu_0 = \\frac{1}{n} \\operatorname{tr}(X_0 S_0) = \\frac{1}{2} \\operatorname{tr}(I \\cdot 2I) = \\frac{1}{2} \\operatorname{tr}(2I) = \\frac{1}{2}(2+2) = 2. $$\n我们观察到 $X_0 S_0 = I (2I) = 2I$ 且 $\\mu_0 I = 2I$。因此，$X_0 S_0 = \\mu_0 I$，这意味着初始点位于中心路径上。\n\nNesterov-Todd (NT) 方向 $(\\Delta X, \\Delta y, \\Delta S)$ 是通过求解扰动障碍问题的线性化 KKT 系统找到的。由于初始点是可行的，可行性残差为零。求解方向的系统是：\n1.  原始可行性：$A \\bullet \\Delta X = 0 \\implies \\operatorname{tr}(\\Delta X) = 0$。\n2.  对偶可行性：$A^{*}(\\Delta y) + \\Delta S = 0 \\implies (\\Delta y)I + \\Delta S = 0$。\n3.  中心性条件：$\\Delta X S_0 + X_0 \\Delta S = \\sigma \\mu_0 I - X_0 S_0$。\n\n对于中心路径上的起始点，其中 $X_0$ 和 $S_0$ 是单位矩阵的倍数，它们是可交换的，因此 $X_0 S_0 = S_0 X_0$。在这种情况下，NT 方向系统得以简化，并且等价于其他常见的原始-对偶方向。\n\n我们来解这个系统。\n从 (2) 可得 $\\Delta S = -(\\Delta y)I$。\n\n现在，我们计算方程 (3) 的右侧：\n$$ \\sigma \\mu_0 I - X_0 S_0 = \\frac{1}{2}(2)I - 2I = I - 2I = -I. $$\n将 $X_0 = I$, $S_0 = 2I$ 以及右侧的表达式代入 (3)：\n$$ \\Delta X (2I) + I (\\Delta S) = -I \\implies 2\\Delta X + \\Delta S = -I. $$\n现在代入 $\\Delta S = -(\\Delta y)I$：\n$$ 2\\Delta X - (\\Delta y)I = -I. $$\n为了求解 $\\Delta y$，我们对该方程取迹，并使用来自 (1) 的条件 $\\operatorname{tr}(\\Delta X)=0$：\n$$ \\operatorname{tr}(2\\Delta X - (\\Delta y)I) = \\operatorname{tr}(-I) $$\n$$ 2\\operatorname{tr}(\\Delta X) - \\Delta y \\operatorname{tr}(I) = -2 $$\n$$ 2(0) - \\Delta y(2) = -2 $$\n$$ -2\\Delta y = -2 \\implies \\Delta y = 1. $$\n有了 $\\Delta y = 1$，我们求 $\\Delta S$：\n$$ \\Delta S = -(\\Delta y)I = -I. $$\n然后我们求 $\\Delta X$：\n$$ 2\\Delta X - (1)I = -I \\implies 2\\Delta X = 0 \\implies \\Delta X = 0. $$\n计算出的原始-对偶方向是 $(\\Delta X, \\Delta y, \\Delta S) = (0, 1, -I)$。\n\n接下来，我们求步长 $\\alpha$。问题要求如果能保持正定性 ($X_1 \\succ 0, S_1 \\succ 0$) 则使用完整步长 $\\alpha=1$，否则使用最大可行步长。我们检查 $\\alpha  0$ 的可行性。\n下一次的迭代值由以下公式给出：\n$X(\\alpha) = X_0 + \\alpha \\Delta X = I + \\alpha(0) = I$。\n$S(\\alpha) = S_0 + \\alpha \\Delta S = 2I + \\alpha(-I) = (2-\\alpha)I$。\n\n对于 $X(\\alpha) \\succ 0$：由于 $X(\\alpha) = I$ 是正定的，此条件对任何 $\\alpha$ 都成立。\n对于 $S(\\alpha) \\succ 0$：我们需要 $(2-\\alpha)I \\succ 0$，这要求 $2-\\alpha  0$，即 $\\alpha  2$。\n\n因为最大可行步长为 2，所以完整步长 $\\alpha = 1$ 是可行的。我们使用 $\\alpha=1$。\n\n我们计算新的迭代点 $(X_1, y_1, S_1)$：\n$y_1 = y_0 + \\alpha \\Delta y = -2 + 1(1) = -1$。\n$X_1 = X_0 + \\alpha \\Delta X = I + 1(0) = I$。\n$S_1 = S_0 + \\alpha \\Delta S = 2I + 1(-I) = I$。\n\n现在，我们计算更新后的对偶测度 $\\mu_1$：\n$$ \\mu_1 = \\frac{1}{n} \\operatorname{tr}(X_1 S_1) = \\frac{1}{2} \\operatorname{tr}(I \\cdot I) = \\frac{1}{2} \\operatorname{tr}(I) = \\frac{1}{2}(2) = 1. $$\n最后，我们验证中心对称条件 $X_1 S_1 = \\mu_1 I$：\n$X_1 S_1 = I \\cdot I = I$。\n$\\mu_1 I = 1 \\cdot I = I$。\n条件 $X_1 S_1 = \\mu_1 I$ 得到满足。\n\n最终要求的值是 $\\mu_1$。", "answer": "$$\n\\boxed{1}\n$$", "id": "3242579"}, {"introduction": "本章的最终实践 [@problem_id:3242648] 是一个综合性的编程项目，旨在将所有理论知识融会贯通。您的任务是实现一个完整的齐次自对偶嵌入（Homogeneous Self-Dual Embedding, HSDE）求解器，这是一种功能强大且鲁棒的内点法变体。这项练习将引导您从单个计算步骤走向构建一个完整的优化工具，该工具不仅能找到最优解，还能准确地诊断出无解或无界问题，这是解决实际应用问题的关键能力。", "problem": "实现一个完整的、可运行的程序，该程序使用内点法构建并求解一小组线性规划的齐次自对偶嵌入（HSDE），并将每个问题分类为可行最优、原问题不可行或对偶问题不可行（原问题无界）。该程序必须生成单行输出，即一个用方括号括起来的逗号分隔的整数列表，其中每个整数对应一个测试用例的分类：$0$ 表示可行最优（找到解），$1$ 表示原问题不可行，$2$ 表示对偶问题不可行（原问题无界）。\n\n标准形式的线性规划（LP）原对偶问题对定义如下。原问题是\n$$\n\\min_{x \\in \\mathbb{R}^n} \\; c^\\top x \\quad \\text{subject to} \\quad A x = b, \\; x \\ge 0,\n$$\n对偶问题是\n$$\n\\max_{y \\in \\mathbb{R}^m} \\; b^\\top y \\quad \\text{subject to} \\quad A^\\top y + s = c, \\; s \\ge 0,\n$$\n其中 $A \\in \\mathbb{R}^{m \\times n}$，$b \\in \\mathbb{R}^m$，$c \\in \\mathbb{R}^n$，$x \\in \\mathbb{R}^n$ 是原变量，$y \\in \\mathbb{R}^m$ 是对偶变量，$s \\in \\mathbb{R}^n$ 是对偶松弛变量。齐次自对偶嵌入（HSDE）引入了两个额外的非负标量 $\\tau \\ge 0$ 和 $\\kappa \\ge 0$，以创建一个单一的可行性问题，其解编码了所有可能的结果：可行最优性、原问题不可行性或对偶问题不可行性。\n\n从凸优化中的核心定义和 Karush–Kuhn–Tucker (KKT) 条件出发，使用 HSDE 形成一个系统，该系统通过标量互补性条件和中心性来强制实现原问题和对偶问题的可行性。具体来说，包含变量 $(x, s, y, \\tau, \\kappa)$，它们服从齐次约束\n$$\nA x - b \\tau = 0, \\quad A^\\top y + s - c \\tau = 0, \\quad c^\\top x - b^\\top y + \\kappa = 0,\n$$\n以及非负性约束 $x \\ge 0$，$s \\ge 0$，$ \\tau \\ge 0$，$ \\kappa \\ge 0$，同时还有一个耦合原问题和对偶问题松弛变量的互补性条件，该条件定义了内点法的中心路径。为一个增广了障碍的系统推导牛顿步，该系统将这些方程以及 $(x, s)$ 和 $(\\tau, \\kappa)$ 的互补关系线性化，并使用回溯法来维持严格的正性。\n\n您的实现必须：\n- 将 $(x, s, y, \\tau, \\kappa)$ 初始化为严格正值，通过障碍参数强制中心性，并迭代求解线性化的 KKT 系统，直到满足终止准则。\n- 使用残差\n$$\nr_p = A x - b \\tau,\\quad r_d = A^\\top y + s - c \\tau,\\quad r_g = c^\\top x - b^\\top y + \\kappa\n$$\n和一个平均互补性\n$$\n\\mu = \\frac{x^\\top s + \\tau \\kappa}{n+1}\n$$\n来引导进程。始终保持 $x$、$s$、$\\tau$ 和 $\\kappa$ 的严格正性。\n- 根据 HSDE 的结果实现分类规则：\n    - 可行最优 ($0$)：当 $\\tau$ 显著大于 $0$，$\\kappa/\\tau$ 很小，且缩放后的残差 $\\|r_p\\|/\\tau$ 和 $\\|r_d\\|/\\tau$ 很小时。\n    - 原问题不可行 ($1$)：当 $\\tau$ 接近 $0$，$\\kappa$ 为正，并且通过对偶变量 $y$ 检测到原问题不可行性的 Farkas 证书，即 $A^\\top y \\ge 0$ 和 $b^\\top y  0$。\n    - 对偶问题不可行 ($2$)：当 $\\tau$ 接近 $0$，$\\kappa$ 为正，并且检测到证书 $x \\ge 0$，$A x = 0$，$c^\\top x  0$（原问题无界）。\n\n测试套件：\n提供三个 LP 实例 $(A, b, c)$，用于共同测试可行性、原问题不可行性和对偶问题不可行性。使用以下具体案例：\n1. 案例 F (可行最优):\n   $$\n   A = \\begin{bmatrix} 1  2 \\\\ 1  -1 \\end{bmatrix},\\quad b = \\begin{bmatrix} 4 \\\\ 1 \\end{bmatrix},\\quad c = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}.\n   $$\n   该系统允许一个严格可行的解，满足 $x \\ge 0$。\n2. 案例 PI (原问题不可行):\n   $$\n   A = \\begin{bmatrix} 1  0 \\end{bmatrix},\\quad b = \\begin{bmatrix} -1 \\end{bmatrix},\\quad c = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}.\n   $$\n   等式 $x_1 = -1$ 与 $x \\ge 0$ 矛盾，因此不存在原问题的可行点。\n3. 案例 DI (对偶问题不可行，原问题无界):\n   $$\n   A = \\begin{bmatrix} 1  -1 \\end{bmatrix},\\quad b = \\begin{bmatrix} 0 \\end{bmatrix},\\quad c = \\begin{bmatrix} -1 \\\\ -1 \\end{bmatrix}.\n   $$\n   约束 $A x = 0$ 与 $x \\ge 0$ 结合，允许存在满足 $c^\\top x  0$ 的非平凡方向，这意味着原问题是无界的。\n\n您的程序应按顺序运行这三个案例，并生成一个单行输出，包含一个由三个整数组成的列表 $[r_F, r_{PI}, r_{DI}]$，其中每个 $r$ 是根据上述分类规则从 $\\{0,1,2\\}$ 中取值。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，\"[0,1,2]\"）。不应打印任何其他文本。", "solution": "用户要求实现一个齐次自对偶嵌入（HSDE）内点法，用于求解一组线性规划（LP）。该解决方案必须能够将每个 LP 分类为可行最优、原问题不可行或对偶问题不可行。\n\n### 步骤 1：提取已知信息\n\n-   **原问题 LP**: $\\min_{x \\in \\mathbb{R}^n} \\; c^\\top x \\quad \\text{subject to} \\quad A x = b, \\; x \\ge 0$.\n-   **对偶问题 LP**: $\\max_{y \\in \\mathbb{R}^m} \\; b^\\top y \\quad \\text{subject to} \\quad A^\\top y + s = c, \\; s \\ge 0$.\n-   **HSDE 变量**: $(x, s, y, \\tau, \\kappa)$，其中 $x \\in \\mathbb{R}^n, s \\in \\mathbb{R}^n, y \\in \\mathbb{R}^m, \\tau \\in \\mathbb{R}, \\kappa \\in \\mathbb{R}$。\n-   **HSDE 齐次约束**:\n    1.  $A x - b \\tau = 0$\n    2.  $A^\\top y + s - c \\tau = 0$\n    3.  $c^\\top x - b^\\top y + \\kappa = 0$\n-   **非负性约束**: $x \\ge 0, s \\ge 0, \\tau \\ge 0, \\kappa \\ge 0$。\n-   **残差定义**:\n    -   $r_p = A x - b \\tau$\n    -   $r_d = A^\\top y + s - c \\tau$\n    -   $r_g = c^\\top x - b^\\top y + \\kappa$\n-   **平均互补性**: $\\mu = \\frac{x^\\top s + \\tau \\kappa}{n+1}$。\n-   **分类规则**:\n    1.  **可行最优 (0)**：$\\tau$ 显著大于 $0$，$\\kappa/\\tau$ 很小，缩放后的残差很小。\n    2.  **原问题不可行 (1)**：$\\tau$ 接近 $0$，$\\kappa > 0$，且有证书 $A^\\top y \\ge 0, b^\\top y  0$。\n    3.  **对偶问题不可行 (2)**：$\\tau$ 接近 $0$，$\\kappa > 0$，且有证书 $x \\ge 0, A x = 0, c^\\top x  0$。\n-   **测试用例**:\n    1.  **案例 F (可行最优)**: $A = \\begin{bmatrix} 1  2 \\\\ 1  -1 \\end{bmatrix}, b = \\begin{bmatrix} 4 \\\\ 1 \\end{bmatrix}, c = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}$。\n    2.  **案例 PI (原问题不可行)**: $A = \\begin{bmatrix} 1  0 \\end{bmatrix}, b = \\begin{bmatrix} -1 \\end{bmatrix}, c = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$。\n    3.  **案例 DI (对偶问题不可行)**: $A = \\begin{bmatrix} 1  -1 \\end{bmatrix}, b = \\begin{bmatrix} 0 \\end{bmatrix}, c = \\begin{bmatrix} -1 \\\\ -1 \\end{bmatrix}$。\n-   **最终输出格式**: 一个逗号分隔的整数列表（例如，`[0,1,2]`）。\n\n### 步骤 2：使用提取的已知信息进行验证\n\n问题陈述在科学上是合理的、适定的和客观的。\n-   **科学依据**：该问题描述了齐次自对偶嵌入，这是凸优化和求解线性规划的数值方法领域中一种标准的、经过严格证明的技术。所有的数学公式都是正确的，并基于优化理论的基本原理，特别是内点法和 KKT 条件。\n-   **适定性**：该问题是适定的。HSDE 框架专门设计用于拥有一个严格可行的起始点，并保证得到一个能够明确分类原始 LP 状态的解。所提供的测试用例旨在演示三种可能结果（可行最优、原问题不可行、对偶问题不可行）中的每一种。\n-   **客观性**：语言精确且正式。所有术语都是该领域的标准术语。目标是可量化的，分类规则基于可验证的数学条件。\n-   **完整性**：问题是自洽的。它提供了模型的完整数学规范、算法的核心组件（牛顿步、回溯法）、终止和分类逻辑，以及一套完整的测试数据。\n\n### 步骤 3：结论与行动\n\n问题有效。我们将继续提供解决方案。\n\n### 算法推导与实施计划\n\n内点法的核心是迭代求解扰动后的 Karush-Kuhn-Tucker (KKT) 条件的线性化版本，这些条件定义了一条收敛到解的“中心路径”。对于 HSDE，KKT 条件通过一个由 $\\mu$ 参数化的障碍项进行增广。目标是找到一个牛顿步 $(\\Delta x, \\Delta y, \\Delta s, \\Delta \\tau, \\Delta \\kappa)$，它将当前迭代点移向中心路径上一个具有更小障碍参数的点。\n\n每次迭代需要求解的方程组是 HSDE 可行性和中心性条件的线性化：\n1.  $A(x + \\Delta x) - b(\\tau + \\Delta \\tau) = 0 \\implies A\\Delta x - b\\Delta\\tau = -r_p$\n2.  $A^\\top(y + \\Delta y) + (s + \\Delta s) - c(\\tau + \\Delta \\tau) = 0 \\implies A^\\top\\Delta y + \\Delta s - c\\Delta\\tau = -r_d$\n3.  $c^\\top(x + \\Delta x) - b^\\top(y + \\Delta y) + (\\kappa + \\Delta \\kappa) = 0 \\implies c^\\top\\Delta x - b^\\top\\Delta y + \\Delta \\kappa = -r_g$\n4.  $(X + \\Delta X)(S + \\Delta S)e = \\sigma\\mu e \\implies S\\Delta x + X\\Delta s = \\sigma\\mu e - XSe$\n5.  $(\\tau + \\Delta \\tau)(\\kappa + \\Delta \\kappa) = \\sigma\\mu \\implies \\kappa\\Delta\\tau + \\tau\\Delta\\kappa = \\sigma\\mu - \\tau\\kappa$\n\n这里，$X$ 和 $S$ 分别是其对角线元素为 $x$ 和 $s$ 的对角矩阵，$e$ 是全一向量，而 $\\sigma \\in [0, 1]$ 是一个中心化参数，用于平衡向可行性/最优性（`\\sigma=0`，仿射缩放步）和中心性（`\\sigma=1`，中心化步）的进展。\n\n为了高效求解此系统，我们消去 $\\Delta s$ 和 $\\Delta \\kappa$：\n由 (4) 得：$\\Delta s = X^{-1}(\\sigma\\mu e - XSe - S\\Delta x)$\n由 (5) 得：$\\Delta\\kappa = \\tau^{-1}(\\sigma\\mu - \\tau\\kappa - \\kappa\\Delta\\tau)$\n\n将这些代入剩下的方程 (1, 2, 3) 中，得到一个关于 $(\\Delta x, \\Delta y, \\Delta \\tau)$ 的简化线性系统。我们来构建这个系统：\n将 $\\Delta s$ 代入 (2)：\n$A^\\top\\Delta y + X^{-1}(\\sigma\\mu e - XSe - S\\Delta x) - c\\Delta\\tau = -r_d$\n$\\implies -X^{-1}S\\Delta x + A^\\top\\Delta y - c\\Delta\\tau = -r_d - X^{-1}(\\sigma\\mu e - XSe) = -r_d - s + \\sigma\\mu X^{-1}e$\n\n将 $\\Delta \\kappa$ 代入 (3)：\n$c^\\top\\Delta x - b^\\top\\Delta y + \\tau^{-1}(\\sigma\\mu - \\tau\\kappa - \\kappa\\Delta\\tau) = -r_g$\n$\\implies c^\\top\\Delta x - b^\\top\\Delta y - (\\kappa/\\tau)\\Delta\\tau = -r_g - \\tau^{-1}(\\sigma\\mu - \\tau\\kappa) = -r_g - \\sigma\\mu/\\tau + \\kappa$\n\n这给出了以下 $(n+m+1) \\times (n+m+1)$ 的线性系统：\n$$\n\\begin{pmatrix}\n    -X^{-1}S   A^\\top   -c \\\\\n    A   0   -b \\\\\n    c^\\top   -b^\\top   -\\kappa/\\tau\n\\end{pmatrix}\n\\begin{pmatrix}\n    \\Delta x \\\\ \\Delta y \\\\ \\Delta \\tau\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n    -r_d + s - \\sigma \\mu X^{-1} e \\\\\n    -r_p \\\\\n    -r_g - \\sigma \\mu/\\tau + \\kappa\n\\end{pmatrix}\n$$\n该系统可以使用标准线性求解器求解。一旦找到 $(\\Delta x, \\Delta y, \\Delta \\tau)$，就可以从代换公式中计算出 $(\\Delta s, \\Delta \\kappa)$。\n\n使用回溯线搜索来寻找步长 $\\alpha \\in (0, 1]$，以确保严格维持非负性约束 ($x, s, \\tau, \\kappa  0$)。然后新的迭代点为 $(x, y, s, \\tau, \\kappa) \\leftarrow (x, y, s, \\tau, \\kappa) + \\alpha (\\Delta x, \\Delta y, \\Delta s, \\Delta \\tau, \\Delta \\kappa)$。\n\n算法流程如下：\n1.  使用一个严格正点进行初始化，例如，$x=e, s=e, y=0, \\tau=1, \\kappa=1$。\n2.  迭代直到互补间隙 $\\mu  \\text{TOL}$：\n    a. 计算残差 $r_p, r_d, r_g$。\n    b. 计算间隙 $\\mu$。\n    c. 构建并求解关于 $(\\Delta x, \\Delta y, \\Delta \\tau)$ 的简化牛顿系统。\n    d. 计算 $\\Delta s$ 和 $\\Delta \\kappa$。\n    e. 找到保持正性的最大步长 $\\alpha$，并乘以一个因子 $\\eta  1$。\n    f. 更新所有变量。\n3.  终止时，根据 $\\tau$ 和 $\\kappa$ 的最终值对结果进行分类：\n    - 如果 $\\tau > \\kappa$ (近似于 $\\tau > 0, \\kappa \\approx 0$)，则原始 LP 是可行最优的（代码 0）。\n    - 如果 $\\tau \\le \\kappa$ (近似于 $\\tau \\approx 0, \\kappa > 0$)，则原始 LP 是不可行的。\n        - 如果 $b^\\top y  0$，则为原问题不可行（代码 1）。\n        - 否则，为对偶问题不可行（原问题无界，代码 2）。\n\n下面针对给定的测试用例实现了此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define and solve the test cases using the HSDE-IPM.\n    \"\"\"\n\n    def _solve_lp_hsde(A, b, c):\n        \"\"\"\n        Solves a linear program standard form using a Homogeneous Self-Dual\n        Embedding Interior-Point Method.\n        \n        Args:\n            A (np.ndarray): The m x n constraint matrix.\n            b (np.ndarray): The m x 1 constraint vector.\n            c (np.ndarray): The n x 1 objective vector.\n            \n        Returns:\n            int: 0 for feasible-optimal, 1 for primal infeasible, \n                 2 for dual infeasible.\n        \"\"\"\n        m, n = A.shape\n\n        # --- Parameters ---\n        MAX_ITER = 100\n        TOL = 1e-9  # Tolerance for complementarity gap\n        SIGMA = 0.1  # Centering parameter\n        ETA = 0.9995 # Backtracking step-size factor\n\n        # --- Initialization ---\n        x = np.ones(n)\n        s = np.ones(n)\n        y = np.zeros(m)\n        tau = 1.0\n        kappa = 1.0\n\n        for _ in range(MAX_ITER):\n            # --- Calculate Residuals and Gap ---\n            r_p = A @ x - b * tau\n            r_d = A.T @ y + s - c * tau\n            r_g = c @ x - b @ y + kappa\n            \n            mu = (x @ s + tau * kappa) / (n + 1)\n\n            if mu  TOL:\n                break\n\n            # --- Form the Newton System M*dz = R ---\n            # Matrix M\n            M_size = n + m + 1\n            M = np.zeros((M_size, M_size))\n            \n            D_inv_sq = -s / x\n            \n            M[:n, :n] = np.diag(D_inv_sq)\n            M[:n, n:n+m] = A.T\n            M[:n, n+m] = -c\n            \n            M[n:n+m, :n] = A\n            # M[n:n+m, n:n+m] is already zero\n            M[n:n+m, n+m] = -b\n            \n            M[n+m, :n] = c\n            M[n+m, n:n+m] = -b.T\n            M[n+m, n+m] = -kappa / tau\n\n            # RHS vector R\n            R = np.zeros(M_size)\n            R[:n] = -r_d + s - SIGMA * mu / x\n            R[n:n+m] = -r_p\n            R[n+m] = -r_g - (SIGMA * mu / tau) + kappa\n\n            # --- Solve the linear system for the step direction ---\n            try:\n                # Solve for primary step components\n                sol = np.linalg.solve(M, R)\n                dx = sol[:n]\n                dy = sol[n:n+m]\n                dtau = sol[n+m]\n                \n                # Compute remaining step components\n                ds = (SIGMA * mu - x * s - s * dx) / x\n                dkappa = (SIGMA * mu - tau * kappa - kappa * dtau) / tau\n            except np.linalg.LinAlgError:\n                # If matrix is singular, likely numerical issues. Stop iterating.\n                break\n\n            # --- Backtracking Line Search ---\n            alpha = 1.0\n            \n            neg_dx_indices = dx  -1e-12\n            if np.any(neg_dx_indices):\n                alpha = min(alpha, np.min(-x[neg_dx_indices] / dx[neg_dx_indices]))\n            \n            neg_ds_indices = ds  -1e-12\n            if np.any(neg_ds_indices):\n                alpha = min(alpha, np.min(-s[neg_ds_indices] / ds[neg_ds_indices]))\n\n            if dtau  -1e-12:\n                alpha = min(alpha, -tau / dtau)\n            \n            if dkappa  -1e-12:\n                alpha = min(alpha, -kappa / dkappa)\n\n            alpha *= ETA\n            \n            # --- Update variables ---\n            x += alpha * dx\n            y += alpha * dy\n            s += alpha * ds\n            tau += alpha * dtau\n            kappa += alpha * dkappa\n\n        # --- Classification ---\n        if tau > kappa:\n            # Feasible-Optimal case: tau > 0, kappa ~ 0\n            return 0\n        else:\n            # Infeasible case: tau ~ 0, kappa > 0\n            # A certificate for primal infeasibility is y s.t. A'y >= 0 and b'y  0\n            if b @ y  0:\n                return 1 # Primal Infeasible\n            else:\n                # Otherwise, it must be dual infeasible (primal unbounded)\n                # A certificate is x s.t. Ax = 0, x >= 0, c'x  0\n                return 2 # Dual Infeasible\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Feasible-optimal\n        (\n            np.array([[1.0, 2.0], [1.0, -1.0]]),\n            np.array([4.0, 1.0]),\n            np.array([1.0, 2.0])\n        ),\n        # Case 2: Primal infeasible\n        (\n            np.array([[1.0, 0.0]]),\n            np.array([-1.0]),\n            np.array([1.0, 1.0])\n        ),\n        # Case 3: Dual infeasible (primal unbounded)\n        (\n            np.array([[1.0, -1.0]]),\n            np.array([0.0]),\n            np.array([-1.0, -1.0])\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        A, b, c = case\n        result = _solve_lp_hsde(A, b, c)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3242648"}]}