{"hands_on_practices": [{"introduction": "本练习是应用后向时间中心空间（BTCS）格式的基石。我们将从理论走向实践，为一维扩散方程编写一个求解器。一个关键的重点将是如何正确处理不同类型的边界条件——狄利克雷（Dirichlet）和诺伊曼（Neumann）条件，这对于模拟真实世界的物理系统至关重要。这项练习将巩固您对如何构建任何隐式方法核心的线性系统的理解。[@problem_id:3241116]", "problem": "你需要设计并实现一个程序，使用隐式向后时间中心空间（BTCS）格式求解一维扩散方程。该程序应能根据一个配置对象，在任一边界上灵活切换狄利克雷（Dirichlet）和诺伊曼（Neumann）边界条件。其控制偏微分方程为有界区间上的线性抛物线模型，\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\alpha \\frac{\\partial^2 u}{\\partial x^2}(x,t), \\quad x \\in [0,L], \\ t \\in (0,T],\n$$\n其中 $u=u(x,t)$ 是我们关注的标量场，$\\alpha>0$ 是扩散系数。初始条件为\n$$\nu(x,0)=u_0(x), \\quad x \\in [0,L],\n$$\n并且在 $x=0$ 和 $x=L$ 的每个边界上独立地满足狄利克雷（Dirichlet）条件，\n$$\nu(0,t)=g_L(t) \\ \\text{or} \\ u(L,t)=g_R(t),\n$$\n或诺伊曼（Neumann）条件，\n$$\n\\frac{\\partial u}{\\partial x}(0,t)=q_L(t) \\ \\text{or} \\ \\frac{\\partial u}{\\partial x}(L,t)=q_R(t).\n$$\n你的离散化必须从以下基本出发点开始：(i) 在步长为 $\\Delta t$ 的均匀时间网格上，将时间导数定义为向后时间差分；(ii) 在网格间距为 $\\Delta x$ 的均匀空间网格上，将空间二阶导数定义为中心二阶差分；以及 (iii) 狄利克雷和诺伊曼边界条件的精确含义。你可以假设解具有足够的平滑性，以保证二阶空间精度和一阶时间精度。不要假设或使用任何不能从这些基础推导出的公式。\n\n你必须推导并实现一个完全隐式的格式，该格式在内部网格点上与向后时间差分和中心空间差分相一致。在边界上，施加狄利克雷或诺伊曼条件的方式必须与内部离散化具有相同的精度阶数，并且在最终的线性系统中不引入虚拟未知数。你的推导必须清楚地展示边界方程与内部方程有何不同，以及边界数据 $g_L(t)$、$g_R(t)$、$q_L(t)$、$q_R(t)$ 如何进入方程的右侧。在 $[0,L]$ 上使用一个包含 $M$ 个节点的均匀空间网格（即，$M$ 包括两个边界节点），使得 $\\Delta x = L/(M-1)$。使用均匀的时间步长 $\\Delta t$，从时间 $t^n=n\\Delta t$推进到 $t^{n+1}=(n+1)\\Delta t$。\n\n你的程序必须：\n- 在每个时间步，为时间 $t^{n+1}$ 处所有节点未知量组成的向量构建一个单一的线性系统，其系数由 BTCS 离散化以及左右两端的边界条件类型决定。\n- 允许任一边界为狄利克雷或诺伊曼条件，并使用在 $t^{n+1}$ 处求值的相应数据函数 $g_L(t)$、$g_R(t)$、$q_L(t)$、$q_R(t)$。\n- 接受一个类似配置的数据结构（硬编码在程序中；不允许文件或外部输入），用于指定 $L$、$\\alpha$、$M$、$\\Delta t$、$T$、边界条件类型和数据，以及初始条件函数 $u_0(x)$。\n- 为了验证，使用制造的精确解 $u_{\\text{exact}}(x,t)$，对于该解，内部方程和所选的边界条件在所有 $t\\in[0,T]$ 上均成立。使用 $u_0(x)=u_{\\text{exact}}(x,0)$ 进行初始化。\n\n测试套件。在你的程序中实现并运行以下五个测试用例，每个用例都由一个配置对象指定。在每个用例中，除非另有说明，取扩散系数 $\\alpha=1$，并报告在最终时间 $T$ 时，数值解与精确解在所有网格节点上的最大绝对误差。这五个用例是：\n- 用例 $1$ (狄利克雷–狄利克雷，齐次，正弦模式)：$L=\\pi$，$M=101$，$\\Delta t=5\\times 10^{-4}$，$T=5\\times 10^{-2}$，左边界为狄利克雷条件，$g_L(t)=0$，右边界为狄利克雷条件，$g_R(t)=0$，精确解为 $u_{\\text{exact}}(x,t)=\\exp(-\\alpha \\lambda^2 t)\\sin(\\lambda x)$，其中 $\\lambda=1$。\n- 用例 $2$ (诺伊曼–诺伊曼，齐次，余弦模式)：$L=\\pi$，$M=101$，$\\Delta t=5\\times 10^{-4}$，$T=5\\times 10^{-2}$，左边界为诺伊曼条件，$q_L(t)=0$，右边界为诺伊曼条件，$q_R(t)=0$，精确解为 $u_{\\text{exact}}(x,t)=\\exp(-\\alpha \\lambda^2 t)\\cos(\\lambda x)$，其中 $\\lambda=1$。\n- 用例 $3$ (狄利克雷–诺伊曼，齐次，半整数正弦模式)：$L=\\pi$，$M=101$，$\\Delta t=5\\times 10^{-4}$，$T=5\\times 10^{-2}$，左边界为狄利克雷条件，$g_L(t)=0$，右边界为诺伊曼条件，$q_R(t)=0$，精确解为 $u_{\\text{exact}}(x,t)=\\exp(-\\alpha \\lambda^2 t)\\sin(\\lambda x)$，其中 $\\lambda=\\tfrac{1}{2}$。\n- 用例 $4$ (诺伊曼–狄利克雷，齐次，半整数余弦模式)：$L=\\pi$，$M=101$，$\\Delta t=5\\times 10^{-4}$，$T=5\\times 10^{-2}$，左边界为诺伊曼条件，$q_L(t)=0$，右边界为狄利克雷条件，$g_R(t)=0$，精确解为 $u_{\\text{exact}}(x,t)=\\exp(-\\alpha \\lambda^2 t)\\cos(\\lambda x)$，其中 $\\lambda=\\tfrac{1}{2}$。\n- 用例 $5$ (稳态线性解，混合非齐次)：$L=1$，$M=51$，$\\Delta t=10^{-2}$，$T=10^{-1}$，左边界为狄利克雷条件，$g_L(t)=2$，右边界为诺伊曼条件，$q_R(t)=-\\tfrac{3}{2}$，精确解为 $u_{\\text{exact}}(x,t)=ax+b$，其中 $a=-\\tfrac{3}{2}$ 且 $b=2$（不依赖于时间）。\n\n最终输出格式。你的程序应生成单行输出，其中包含五个用例中每个用例在时间 $T$ 的最大绝对误差，格式为一个逗号分隔的十进制数列表，用方括号括起来，并按用例 $1$ 到 $5$ 的顺序排列。例如，三个假设用例的输出应如下所示\n$$\n[\\text{err}_1,\\text{err}_2,\\text{err}_3]\n$$\n但你的程序必须输出与上述五个用例相对应的五个条目。", "solution": "任务是为一维扩散方程 $\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}$ 在有界域 $x \\in [0,L]$ 上推导并实现隐式向后时间中心空间（BTCS）格式，并提供在每个端点选择狄利克雷（Dirichlet）或诺伊曼（Neumann）边界条件的选项。推导将按规定从第一性原理出发。\n\n将空间域 $[0,L]$ 离散化为一个包含 $M$ 个节点的均匀网格，节点索引为 $i=0, 1, \\dots, M-1$。网格点为 $x_i = i\\Delta x$，其中网格间距为 $\\Delta x = L/(M-1)$。时间域以均匀步长 $\\Delta t$ 进行离散化，时间层记为 $t^n = n\\Delta t$。解 $u(x_i, t^n)$ 的数值近似记为 $u_i^n$。\n\nBTCS 格式的构建方法是：使用一阶向后有限差分来近似时间导数，使用二阶中心有限差分来近似空间二阶导数，两者都在未来的时间层 $t^{n+1}$ 上进行计算。因此，控制偏微分方程（PDE）离散化为：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\alpha \\frac{u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}}{(\\Delta x)^2}\n$$\n该方程建立了时间 $t^n$ 的已知解与时间 $t^{n+1}$ 的未知解之间的关系。\n\n让我们定义无量纲参数 $s = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$。重新整理离散方程，将未知项（在 $n+1$ 层）分组到左侧（LHS），将已知项（在 $n$ 层）分组到右侧（RHS），得到内部节点 $i \\in \\{1, 2, \\dots, M-2\\}$ 的方程：\n$$\n-s u_{i-1}^{n+1} + (1+2s) u_i^{n+1} - s u_{i+1}^{n+1} = u_i^n\n$$\n这些方程为未知向量 $\\mathbf{u}^{n+1} = [u_0^{n+1}, u_1^{n+1}, \\dots, u_{M-1}^{n+1}]^T$ 构成了一个线性方程组。系统中第一个（$i=0$）和最后一个（$i=M-1$）方程的具体形式取决于边界条件。\n\n边界条件的离散化必须具有与内部格式一致的精度，即空间上为二阶精度。我们现在将在不向最终线性系统中引入虚拟节点的情况下，推导每个边界的方程。\n\n**左边界（$x=0$，节点 $i=0$）**\n\n1.  **狄利克雷条件**: $u(0,t) = g_L(t)$。\n    该条件直接应用于新的时间层 $t^{n+1}$。未知数 $u_0^{n+1}$ 的值被明确给出：\n    $$\n    u_0^{n+1} = g_L(t^{n+1})\n    $$\n    这在线性系统中转化为第一行 $1 \\cdot u_0^{n+1} = g_L(t^{n+1})$。\n\n2.  **诺伊曼条件**: $\\frac{\\partial u}{\\partial x}(0,t) = q_L(t)$。\n    为达到二阶精度，我们在 $x_0$ 周围使用中心差分来计算空间导数。这需要一个位于 $x_{-1} = -\\Delta x$ 的“虚拟”节点。在 $t^{n+1}$ 处的导数近似为：\n    $$\n    \\frac{u_1^{n+1} - u_{-1}^{n+1}}{2\\Delta x} = q_L(t^{n+1})\n    $$\n    由此，我们可以将虚拟节点的值 $u_{-1}^{n+1}$ 表示为 $u_{-1}^{n+1} = u_1^{n+1} - 2\\Delta x q_L(t^{n+1})$。然后，我们在边界节点 $i=0$ 处应用通用的 PDE 离散格式：\n    $$\n    -s u_{-1}^{n+1} + (1+2s) u_0^{n+1} - s u_1^{n+1} = u_0^n\n    $$\n    代入 $u_{-1}^{n+1}$ 的表达式以消除虚拟节点：\n    $$\n    -s (u_1^{n+1} - 2\\Delta x q_L(t^{n+1})) + (1+2s) u_0^{n+1} - s u_1^{n+1} = u_0^n\n    $$\n    合并各项，得到系统第一行的最终方程：\n    $$\n    (1+2s) u_0^{n+1} - 2s u_1^{n+1} = u_0^n - 2s\\Delta x q_L(t^{n+1})\n    $$\n    注意到 $2s\\Delta x = 2 \\frac{\\alpha \\Delta t}{(\\Delta x)^2} \\Delta x = \\frac{2\\alpha\\Delta t}{\\Delta x}$，方程为 $(1+2s) u_0^{n+1} - 2s u_1^{n+1} = u_0^n - \\frac{2\\alpha\\Delta t}{\\Delta x} q_L(t^{n+1})$。\n\n**右边界（$x=L$，节点 $i=M-1$）**\n\n1.  **狄利克雷条件**: $u(L,t) = g_R(t)$。\n    与左边界类似，在 $t^{n+1}$ 处的条件直接给出了 $u_{M-1}^{n+1}$ 的值：\n    $$\n    u_{M-1}^{n+1} = g_R(t^{n+1})\n    $$\n    这定义了线性系统的最后一行 $1 \\cdot u_{M-1}^{n+1} = g_R(t^{n+1})$。\n\n2.  **诺伊曼条件**: $\\frac{\\partial u}{\\partial x}(L,t) = q_R(t)$。\n    在 $x_{M-1}$ 周围使用中心差分需要一个位于 $x_M = L+\\Delta x$ 的虚拟节点：\n    $$\n    \\frac{u_M^{n+1} - u_{M-2}^{n+1}}{2\\Delta x} = q_R(t^{n+1})\n    $$\n    这给出了虚拟节点的值 $u_M^{n+1} = u_{M-2}^{n+1} + 2\\Delta x q_R(t^{n+1})$。在 $i=M-1$ 处应用 PDE 离散格式：\n    $$\n    -s u_{M-2}^{n+1} + (1+2s) u_{M-1}^{n+1} - s u_M^{n+1} = u_{M-1}^n\n    $$\n    代入 $u_M^{n+1}$ 的表达式：\n    $$\n    -s u_{M-2}^{n+1} + (1+2s) u_{M-1}^{n+1} - s (u_{M-2}^{n+1} + 2\\Delta x q_R(t^{n+1})) = u_{M-1}^n\n    $$\n    合并各项，得到系统最后一行的最终方程：\n    $$\n    -2s u_{M-2}^{n+1} + (1+2s) u_{M-1}^{n+1} = u_{M-1}^n + 2s\\Delta x q_R(t^{n+1})\n    $$\n    涉及边界数据的项是 $\\frac{2\\alpha\\Delta t}{\\Delta x} q_R(t^{n+1})$。\n\n**矩阵系统构建**\n\n在每个时间步，我们求解线性系统 $\\mathbf{A} \\mathbf{u}^{n+1} = \\mathbf{b}$ 以得到未知向量 $\\mathbf{u}^{n+1}$。矩阵 $\\mathbf{A}$ 和向量 $\\mathbf{b}$ 的构造如下：\n\n令 $s = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$。\n矩阵 $\\mathbf{A}$ 是一个 $M \\times M$ 矩阵，$\\mathbf{b}$ 是一个大小为 $M$ 的向量。\n\n**内部行（$i = 1, \\dots, M-2$）：**\n-   $A_{i,i-1} = -s$\n-   $A_{i,i} = 1+2s$\n-   $A_{i,i+1} = -s$\n-   $b_i = u_i^n$\n\n**第一行（$i=0$）：**\n-   如果左边界是狄利克雷条件：$A_{0,0}=1$，且所有其他 $A_{0,j}=0$。$b_0 = g_L(t^{n+1})$。\n-   如果左边界是诺伊曼条件：$A_{0,0}=1+2s$，$A_{0,1}=-2s$。$b_0 = u_0^n - \\frac{2\\alpha\\Delta t}{\\Delta x} q_L(t^{n+1})$。\n\n**最后一行（$i=M-1$）：**\n-   如果右边界是狄利克雷条件：$A_{M-1,M-1}=1$，且所有其他 $A_{M-1,j}=0$。$b_{M-1} = g_R(t^{n+1})$。\n-   如果右边界是诺伊曼条件：$A_{M-1,M-2}=-2s$，$A_{M-1,M-1}=1+2s$。$b_{M-1} = u_{M-1}^n + \\frac{2\\alpha\\Delta t}{\\Delta x} q_R(t^{n+1})$。\n\n**总体算法：**\n\n1.  从测试用例配置中初始化参数。\n2.  建立空间网格 $x_i$（$i=0, \\dots, M-1$）。\n3.  使用 $u_i^0 = u_{\\text{exact}}(x_i, 0)$ 计算初始解向量 $\\mathbf{u}^0$。\n4.  从 $n=0$ 开始迭代时间步，直到达到最终时间 $T$。在每个步骤中：\n    a. 确定当前时间 $t^{n+1} = (n+1)\\Delta t$。\n    b. 根据指定的边界条件和上面推导的公式构造矩阵 $\\mathbf{A}$ 和向量 $\\mathbf{b}$。\n    c. 求解线性系统 $\\mathbf{A} \\mathbf{u}^{n+1} = \\mathbf{b}$ 以找到新时间层的解。\n    d. 为下一次迭代更新解：$\\mathbf{u}^n \\leftarrow \\mathbf{u}^{n+1}$。\n5.  在最后一个时间步之后，计算在时间 $T$ 时的精确解 $\\mathbf{u}_{\\text{exact}}$。\n6.  计算最终数值解与精确解之间的最大绝对误差：$\\max_i |u_i^{\\text{final}} - u_{\\text{exact}}(x_i, T)|$。\n对每个测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the BTCS diffusion solver.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Dirichlet-Dirichlet\n        {\n            \"L\": np.pi, \"alpha\": 1.0, \"M\": 101, \"dt\": 5e-4, \"T\": 5e-2,\n            \"bc_left_type\": \"dirichlet\", \"bc_right_type\": \"dirichlet\",\n            \"g_L\": lambda t: 0.0, \"g_R\": lambda t: 0.0,\n            \"q_L\": lambda t: 0.0, \"q_R\": lambda t: 0.0,\n            \"u_exact\": lambda x, t, alpha: np.exp(-alpha * 1**2 * t) * np.sin(1 * x)\n        },\n        # Case 2: Neumann-Neumann\n        {\n            \"L\": np.pi, \"alpha\": 1.0, \"M\": 101, \"dt\": 5e-4, \"T\": 5e-2,\n            \"bc_left_type\": \"neumann\", \"bc_right_type\": \"neumann\",\n            \"g_L\": lambda t: 0.0, \"g_R\": lambda t: 0.0,\n            \"q_L\": lambda t: 0.0, \"q_R\": lambda t: 0.0,\n            \"u_exact\": lambda x, t, alpha: np.exp(-alpha * 1**2 * t) * np.cos(1 * x)\n        },\n        # Case 3: Dirichlet-Neumann\n        {\n            \"L\": np.pi, \"alpha\": 1.0, \"M\": 101, \"dt\": 5e-4, \"T\": 5e-2,\n            \"bc_left_type\": \"dirichlet\", \"bc_right_type\": \"neumann\",\n            \"g_L\": lambda t: 0.0, \"g_R\": lambda t: 0.0,\n            \"q_L\": lambda t: 0.0, \"q_R\": lambda t: 0.0,\n            \"u_exact\": lambda x, t, alpha: np.exp(-alpha * 0.5**2 * t) * np.sin(0.5 * x)\n        },\n        # Case 4: Neumann-Dirichlet\n        {\n            \"L\": np.pi, \"alpha\": 1.0, \"M\": 101, \"dt\": 5e-4, \"T\": 5e-2,\n            \"bc_left_type\": \"neumann\", \"bc_right_type\": \"dirichlet\",\n            \"g_L\": lambda t: 0.0, \"g_R\": lambda t: 0.0,\n            \"q_L\": lambda t: 0.0, \"q_R\": lambda t: 0.0,\n            \"u_exact\": lambda x, t, alpha: np.exp(-alpha * 0.5**2 * t) * np.cos(0.5 * x)\n        },\n        # Case 5: Dirichlet-Neumann, non-homogeneous steady state\n        {\n            \"L\": 1.0, \"alpha\": 1.0, \"M\": 51, \"dt\": 1e-2, \"T\": 1e-1,\n            \"bc_left_type\": \"dirichlet\", \"bc_right_type\": \"neumann\",\n            \"g_L\": lambda t: 2.0, \"g_R\": lambda t: 0.0,  # g_R not used\n            \"q_L\": lambda t: 0.0, \"q_R\": lambda t: -1.5, # q_L not used\n            \"u_exact\": lambda x, t, alpha: -1.5 * x + 2.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_btcs_simulation(case)\n        results.append(f\"{error:.15e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef run_btcs_simulation(params):\n    \"\"\"\n    Executes a single simulation run for the 1D diffusion equation using BTCS.\n\n    Args:\n        params (dict): A dictionary containing all parameters for the simulation.\n\n    Returns:\n        float: The maximum absolute error at the final time T.\n    \"\"\"\n    # Unpack parameters\n    L = params[\"L\"]\n    alpha = params[\"alpha\"]\n    M = params[\"M\"]\n    dt = params[\"dt\"]\n    T = params[\"T\"]\n    \n    # Grid setup\n    dx = L / (M - 1)\n    x = np.linspace(0, L, M)\n    \n    # Dimensionless parameter\n    s = alpha * dt / (dx**2)\n    \n    # Time stepping\n    num_steps = int(round(T / dt))\n    \n    # Initial condition\n    u = params[\"u_exact\"](x, 0, alpha)\n\n    # Time evolution loop\n    for n in range(num_steps):\n        t_next = (n + 1) * dt\n        \n        # Setup the linear system A u_next = b\n        A = np.zeros((M, M))\n        b = np.zeros(M)\n        \n        # Interior points\n        for i in range(1, M - 1):\n            A[i, i-1] = -s\n            A[i, i]   = 1 + 2*s\n            A[i, i+1] = -s\n            b[i]      = u[i]\n            \n        # Boundary conditions\n        # Left boundary (i=0)\n        if params[\"bc_left_type\"] == \"dirichlet\":\n            A[0, 0] = 1.0\n            b[0] = params[\"g_L\"](t_next)\n        elif params[\"bc_left_type\"] == \"neumann\":\n            A[0, 0] = 1 + 2*s\n            A[0, 1] = -2*s\n            b[0] = u[0] - (2 * alpha * dt / dx) * params[\"q_L\"](t_next)\n\n        # Right boundary (i=M-1)\n        if params[\"bc_right_type\"] == \"dirichlet\":\n            A[M-1, M-1] = 1.0\n            b[M-1] = params[\"g_R\"](t_next)\n        elif params[\"bc_right_type\"] == \"neumann\":\n            A[M-1, M-2] = -2*s\n            A[M-1, M-1] = 1 + 2*s\n            b[M-1] = u[M-1] + (2 * alpha * dt / dx) * params[\"q_R\"](t_next)\n        \n        # Solve the system for the next time step\n        u_next = np.linalg.solve(A, b)\n        u = u_next\n\n    # Calculate final error\n    u_final_exact = params[\"u_exact\"](x, T, alpha)\n    max_error = np.max(np.abs(u - u_final_exact))\n    \n    return max_error\n\nsolve()\n```", "id": "3241116"}, {"introduction": "仅仅有一个能运行的代码是不够的；我们还需要确信它是正确的。本练习介绍了一种强大的验证技术，称为“人造解方法”（Method of Manufactured Solutions）。通过设计一个已知精确解的问题，我们可以凭经验测量求解器的误差，并确认它是否与 BTCS 格式的理论精度——时间上的一阶精度和空间上的二阶精度——相匹配。[@problem_id:3241236]", "problem": "考虑定义在空间区间 $[0,1]$ 和时间区间 $[0,T]$ 上的一维热传导模型，\n$$\n\\frac{\\partial u}{\\partial t}(x,t) \\;=\\; \\alpha \\,\\frac{\\partial^2 u}{\\partial x^2}(x,t) \\;+\\; f(x,t),\n$$\n其狄利克雷 (Dirichlet) 边界条件为 $u(0,t)=0$ 和 $u(1,t)=0$（对于所有 $t \\in [0,T]$），初始条件为 $u(x,0)=\\sin(\\pi x)$。使用制造解方法 (method of manufactured solutions) 来验证隐式时间后向中心空间 (Implicit Backward-Time Central-Space, BTCS) 差分格式（正式名称为时间后向中心空间 (BTCS) 格式）的准确性。\n\n您将从以下基本概念出发：\n- 热方程和中心有限差分的定义：对于一个足够光滑的函数 $u$，空间二阶导数可近似为\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x_i,t) \\approx \\frac{u(x_{i-1},t) - 2u(x_i,t) + u(x_{i+1},t)}{(\\Delta x)^2},\n$$\n而后向欧拉 (backward Euler) 时间导数可近似为\n$$\n\\frac{\\partial u}{\\partial t}(x_i,t_{n+1}) \\approx \\frac{u(x_i,t_{n+1}) - u(x_i,t_n)}{\\Delta t}.\n$$\n- 制造解方法：选择一个光滑函数 $\\tilde{u}(x,t)$，将其代入偏微分方程，并定义 $f(x,t)$，使得 $\\tilde{u}(x,t)$ 成为该强制问题的精确解。\n\n任务：\n1. 选择制造解 $\\tilde{u}(x,t)=e^{t}\\sin(\\pi x)$，并利用微积分推导出相应的源项 $f(x,t)$，使得 $\\tilde{u}(x,t)$ 精确满足模型方程。\n2. 将空间域离散化为网格点 $x_i = i\\,\\Delta x$（其中 $i=0,1,\\dots,N_x-1$，$\\Delta x = 1/(N_x-1)$），将时间域离散化为时间层 $t_n = n\\,\\Delta t$（其中 $n=0,1,\\dots,N_t$）。施加狄利克雷边界条件 $u_0^n = 0$ 和 $u_{N_x-1}^n=0$（对所有 $n$），以及初始条件 $u_i^0 = \\sin(\\pi x_i)$（对 $i=1,\\dots,N_x-2$）。\n3. 通过结合后向欧拉时间近似和中心空间近似，并在时间 $t_{n+1}$ 处计算源项 $f$，推导并实现在每个时间步 $t_{n+1}$ 针对内部节点 $i=1,\\dots,N_x-2$ 的 BTCS 线性系统。\n4. 通过在每个时间步求解所得到的三对角线性系统，将解从 $t=0$推进到 $t=T$。通过将数值解 $u_i^{N_t}$ 与精确解 $\\tilde{u}(x_i,T)$进行比较，使用离散 $L^2$ 范数计算最终时间 $t=T$ 的误差\n$$\nE_{L^2} \\;=\\; \\left(\\Delta x\\sum_{i=1}^{N_x-2}\\left(u_i^{N_t}-\\tilde{u}(x_i,T)\\right)^2\\right)^{1/2}\n$$\n和离散 $L^\\infty$ 范数\n$$\nE_{L^\\infty} \\;=\\; \\max_{1\\le i \\le N_x-2}\\left|u_i^{N_t}-\\tilde{u}(x_i,T)\\right|.\n$$\n\n经验性收敛验证：\n- 为验证时间精度阶 $O(\\Delta t)$，使用非常精细的空间网格以使空间误差可以忽略不计，并进行时间加密研究。固定 $\\alpha=0.1$，设置 $T=0.2$，选择 $N_x=1001$，并针对四种时间步数 $N_t\\in\\{10,20,40,80\\}$（对应 $\\Delta t\\in\\{0.02,0.01,0.005,0.0025\\}$）运行 BTCS 格式。对每次运行，计算在 $t=T$ 时的 $E_{L^2}$。通过对 $(\\log(\\Delta t),\\log(E_{L^2}))$ 进行最小二乘法线性拟合，并取其斜率，来估计观测到的时间收敛阶 $p_t$。\n- 为验证空间精度阶 $O((\\Delta x)^2)$，使用非常小的时间步以使时间误差可以忽略不计，并进行空间加密研究。固定 $\\alpha=0.1$，设置 $T=0.01$，选择 $N_t=1000$（因此 $\\Delta t=0.00001$），并针对 $N_x\\in\\{33,65,129,257\\}$（对应每次加密空间步长减半）运行 BTCS 格式。对每次运行，计算在 $t=T$ 时的 $E_{L^2}$。通过对 $(\\log(\\Delta x),\\log(E_{L^2}))$ 进行最小二乘法线性拟合，并取其斜率，来估计观测到的空间收敛阶 $p_x$。\n- 边缘情况稳健性检查：使用非常粗糙的网格进行测试，以确保线性系统组装和边界处理是正确的。固定 $\\alpha=0.1$，设置 $T=0.1$，选择 $N_x=5$ 和 $N_t=5$（因此 $\\Delta t=0.02$）。计算最终时间的离散无穷范数误差 $E_{L^\\infty}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的精确顺序为 $[p_t,p_x,E_{L^\\infty}]$。所有三个条目都必须是实数。不应打印任何其他文本。\n\n测试套件摘要：\n- 时间加密（预期为 $O(\\Delta t)$）：$\\alpha=0.1$, $T=0.2$, $N_x=1001$, $N_t\\in\\{10,20,40,80\\}$。\n- 空间加密（预期为 $O((\\Delta x)^2)$）：$\\alpha=0.1$, $T=0.01$, $N_t=1000$, $N_x\\in\\{33,65,129,257\\}$。\n- 边缘情况：$\\alpha=0.1$, $T=0.1$, $N_x=5$, $N_t=5$。\n\n所有量均为无量纲；不需要物理单位。", "solution": "该问题要求使用制造解方法推导、实现和验证用于一维热方程的时间后向中心空间 (BTCS) 格式。解决方案分为四个部分：解析源项的推导、离散数值格式的推导、经验性验证过程的概述以及算法摘要。\n\n**步骤 1：源项的推导**\n\n制造解方法用于创建一个具有已知解析解的问题，该解可作为验证数值代码的基准。控制性偏微分方程 (PDE) 为：\n$$\n\\frac{\\partial u}{\\partial t}(x,t) \\;=\\; \\alpha \\,\\frac{\\partial^2 u}{\\partial x^2}(x,t) \\;+\\; f(x,t)\n$$\n我们选择制造解 $\\tilde{u}(x,t) = e^{t}\\sin(\\pi x)$。该函数满足边界条件 $u(0,t)=e^t\\sin(0)=0$ 和 $u(1,t)=e^t\\sin(\\pi)=0$，以及初始条件 $u(x,0)=e^0\\sin(\\pi x)=\\sin(\\pi x)$。为了找到相应的源项 $f(x,t)$，我们计算 $\\tilde{u}(x,t)$ 的偏导数：\n时间导数为：\n$$\n\\frac{\\partial \\tilde{u}}{\\partial t} = \\frac{\\partial}{\\partial t} \\left( e^t \\sin(\\pi x) \\right) = e^t \\sin(\\pi x)\n$$\n空间二阶导数为：\n$$\n\\frac{\\partial^2 \\tilde{u}}{\\partial x^2} = \\frac{\\partial^2}{\\partial x^2} \\left( e^t \\sin(\\pi x) \\right) = \\frac{\\partial}{\\partial x} \\left( \\pi e^t \\cos(\\pi x) \\right) = -\\pi^2 e^t \\sin(\\pi x)\n$$\n将这些导数代入 PDE，即可求解 $f(x,t)$：\n$$\ne^t \\sin(\\pi x) = \\alpha \\left( -\\pi^2 e^t \\sin(\\pi x) \\right) + f(x,t)\n$$\n$$\nf(x,t) = e^t \\sin(\\pi x) + \\alpha \\pi^2 e^t \\sin(\\pi x) = (1 + \\alpha \\pi^2)e^t \\sin(\\pi x)\n$$\n此推导出的源项确保了 $\\tilde{u}(x,t)$ 是该问题的精确解。\n\n**步骤 2：BTCS 离散化的推导**\n\nBTCS 格式通过在具有空间点 $x_i = i\\Delta x$ 和时间层 $t_n = n\\Delta t$ 的网格上离散化 PDE 来构建。我们使用一阶后向欧拉差分近似时间导数，使用二阶中心差分近似空间导数，两者都在未来的时间层 $t_{n+1}$ 进行计算：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} \\approx \\alpha \\left( \\frac{u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}}{(\\Delta x)^2} \\right) + f(x_i, t_{n+1})\n$$\n其中 $u_i^n \\approx u(x_i, t_n)$。该格式是隐式的，因为它耦合了时间层 $n+1$ 上的多个未知数值。为求解该方程，我们将其重排为一个线性系统。设 $c = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$ 为扩散数。我们将所有未知项（在时间 $n+1$）归到左侧 (LHS)，将已知项（在时间 $n$）归到右侧 (RHS)：\n$$\nu_i^{n+1} - c (u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}) = u_i^n + \\Delta t f_i^{n+1}\n$$\n$$\n-c u_{i-1}^{n+1} + (1 + 2c)u_i^{n+1} - c u_{i+1}^{n+1} = u_i^n + \\Delta t f_i^{n+1}\n$$\n该方程对所有内部网格点 $i = 1, 2, \\dots, N_x-2$ 均有效。给定狄利克雷边界条件 $u_0^{n+1}=0$ 和 $u_{N_x-1}^{n+1}=0$，这些方程构成一个关于内部未知量向量 $\\mathbf{u}^{n+1} = [u_1^{n+1}, \\dots, u_{N_x-2}^{n+1}]^T$ 的三对角线性系统 $A \\mathbf{u}^{n+1} = \\mathbf{b}^n$。这个 $(N_x-2) \\times (N_x-2)$ 的矩阵 $A$ 是：\n$$\nA = \\begin{pmatrix}\n1+2c & -c & 0 & \\dots & 0 \\\\\n-c & 1+2c & -c & \\dots & 0 \\\\\n0 & \\ddots & \\ddots & \\ddots & 0 \\\\\n\\vdots & \\ddots & -c & 1+2c & -c \\\\\n0 & \\dots & 0 & -c & 1+2c\n\\end{pmatrix}\n$$\n右侧向量 $\\mathbf{b}^n$ 取决于前一个时间步 $n$ 的解和时间步 $n+1$ 的源项。在每个时间步，必须求解该系统以找到下一个时间层的解。\n\n**步骤 3：经验性收敛验证**\n\nBTCS 格式的理论精度在时间上为 $O(\\Delta t)$，在空间上为 $O((\\Delta x)^2)$。总误差 $E$ 近似为 $E \\approx C_t (\\Delta t)^{p_t} + C_x (\\Delta x)^{p_x}$，其中 $p_t=1$ 和 $p_x=2$ 是收敛阶。\n为了经验性地测量 $p_t$，我们进行时间加密研究。通过使用一个非常精细的空间网格（$N_x=1001$），空间误差项 $C_x (\\Delta x)^2$ 变得可以忽略不计。此时，误差主要由时间离散化决定，即 $E \\approx C_t (\\Delta t)^{p_t}$。取对数可得 $\\log(E) \\approx \\log(C_t) + p_t \\log(\\Delta t)$。阶数 $p_t$ 是对 $(\\log(\\Delta t), \\log(E))$ 数据点进行线性拟合得到的直线的斜率。\n同样地，为了测量 $p_x$，我们进行空间加密研究。通过使用一个非常小的时间步（$N_t=1000$），时间误差项 $C_t (\\Delta t)^{p_t}$ 变得可以忽略不计，因此 $E \\approx C_x (\\Delta x)^{p_x}$。阶数 $p_x$ 则是对 $(\\log(\\Delta x), \\log(E))$ 数据进行线性拟合得到的直线的斜率。\n\n**步骤 4：算法实现**\n\n数值解按以下步骤计算：\n1.  初始化参数 $\\alpha$、$T$、$N_x$、$N_t$ 并计算网格间距 $\\Delta x$ 和 $\\Delta t$。\n2.  建立空间网格 $x$ 并使用初始条件 $u(x,0)=\\sin(\\pi x)$ 初始化解向量 $u$。\n3.  根据给定参数构建常数三对角矩阵 $A$。\n4.  从 $n=0$ 迭代到 $N_t-1$。在每次迭代中：\n    a. 计算下一个时间层 $t_{n+1}$。\n    b. 使用上一步的解 $u^n$ 和源项 $f(x,t_{n+1})$ 组装右侧向量 $\\mathbf{b}^n$。\n    c. 求解线性系统 $A \\mathbf{u}^{n+1} = \\mathbf{b}^n$ 以获得下一个时间步的内部点的解。\n    d. 更新完整的解向量，同时保持边界值为 $0$。\n5.  循环结束后，通过将最终数值解与精确制造解进行比较，根据要求使用 $L^2$ 或 $L^\\infty$ 范数计算在 $t=T$ 时的最终误差。\n6.  对于收敛性研究，对每组加密参数重复此过程，收集误差，并对对数-对数数据进行线性最小二乘拟合，以求得斜率 $p_t$ 和 $p_x$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_btcs_and_get_error(alpha, T, Nx, Nt, error_norm_type):\n    \"\"\"\n    Runs the BTCS simulation for the 1D heat equation with a source term\n    and returns the specified error norm against the manufactured solution.\n\n    Args:\n        alpha (float): Thermal diffusivity constant.\n        T (float): Final time.\n        Nx (int): Number of spatial grid points.\n        Nt (int): Number of time steps.\n        error_norm_type (str): Type of error norm to compute ('L2' or 'L_inf').\n\n    Returns:\n        float: The computed error value.\n    \"\"\"\n    # Define the manufactured solution and the corresponding source term\n    def u_exact(x, t):\n        return np.exp(t) * np.sin(np.pi * x)\n\n    def f_source(x, t, alpha_val):\n        return (1.0 + alpha_val * np.pi**2) * np.exp(t) * np.sin(np.pi * x)\n\n    # Discretization parameters\n    dx = 1.0 / (Nx - 1)\n    dt = T / Nt\n    x = np.linspace(0, 1, Nx)\n    \n    # Grid for interior points\n    x_interior = x[1:-1]\n    M = Nx - 2  # Number of interior points\n\n    # Diffusion number\n    c = alpha * dt / (dx**2)\n\n    # Initial condition. The vector u_current includes boundary points.\n    u_current = u_exact(x, 0.0)\n    \n    # Construct the tridiagonal matrix A for a single time step.\n    # The matrix is constant for fixed parameters.\n    A = np.zeros((M, M))\n    np.fill_diagonal(A, 1.0 + 2.0 * c)\n    np.fill_diagonal(A[1:], -c)\n    np.fill_diagonal(A[:, 1:], -c)\n\n    # Time-stepping loop\n    for n in range(Nt):\n        t_next = (n + 1) * dt\n        \n        # Get the solution at interior points from the previous time step\n        u_current_interior = u_current[1:-1]\n        \n        # Construct the RHS vector b = u_current_interior + dt * f(t_next)\n        f_vec = f_source(x_interior, t_next, alpha)\n        b = u_current_interior + dt * f_vec\n        \n        # Dirichlet boundary conditions u(0,t)=0 and u(1,t)=0 are handled implicitly\n        # because the terms involving u_0 and u_{Nx-1} are zero and do not\n        # contribute to the RHS vector for the interior problem.\n        \n        # Solve the linear system A * u_next_interior = b\n        u_next_interior = np.linalg.solve(A, b)\n        \n        # Update solution vector for the next time step. Boundaries remain zero.\n        u_current[1:-1] = u_next_interior\n        \n    # At t=T, u_current holds the final numerical solution\n    u_numerical_final = u_current\n    \n    # Calculate the exact solution at the final time T\n    u_exact_final = u_exact(x, T)\n\n    # Calculate the error vector at interior points\n    error_vec = u_numerical_final[1:-1] - u_exact_final[1:-1]\n    \n    # Compute the requested error norm\n    if error_norm_type == 'L2':\n        error_val = np.sqrt(dx * np.sum(error_vec**2))\n    elif error_norm_type == 'L_inf':\n        error_val = np.max(np.abs(error_vec))\n    else:\n        raise ValueError(\"Invalid error_norm_type specified.\")\n        \n    return error_val\n\ndef solve():\n    \"\"\"\n    Performs the three specified tasks: time refinement, space refinement,\n    and an edge case test, printing the results in the required format.\n    \"\"\"\n    # --- Task 1: Time refinement study to find p_t ---\n    alpha_t = 0.1\n    T_t = 0.2\n    Nx_t = 1001\n    Nt_t_vals = [10, 20, 40, 80]\n    \n    dt_vals = [T_t / N for N in Nt_t_vals]\n    errors_t = []\n    for Nt_t in Nt_t_vals:\n        error = run_btcs_and_get_error(alpha_t, T_t, Nx_t, Nt_t, 'L2')\n        errors_t.append(error)\n        \n    # Fit a line to (log(dt), log(error)) to find the convergence order p_t\n    log_dt = np.log(dt_vals)\n    log_errors_t = np.log(errors_t)\n    p_t = np.polyfit(log_dt, log_errors_t, 1)[0]\n\n    # --- Task 2: Spatial refinement study to find p_x ---\n    alpha_x = 0.1\n    T_x = 0.01\n    Nt_x = 1000\n    Nx_x_vals = [33, 65, 129, 257]\n    \n    dx_vals = [1.0 / (N - 1) for N in Nx_x_vals]\n    errors_x = []\n    for Nx_x in Nx_x_vals:\n        error = run_btcs_and_get_error(alpha_x, T_x, Nx_x, Nt_x, 'L2')\n        errors_x.append(error)\n        \n    # Fit a line to (log(dx), log(error)) to find the convergence order p_x\n    log_dx = np.log(dx_vals)\n    log_errors_x = np.log(errors_x)\n    p_x = np.polyfit(log_dx, log_errors_x, 1)[0]\n\n    # --- Task 3: Edge case robustness check ---\n    alpha_e = 0.1\n    T_e = 0.1\n    Nx_e = 5\n    Nt_e = 5\n    E_Linf = run_btcs_and_get_error(alpha_e, T_e, Nx_e, Nt_e, 'L_inf')\n\n    # Final print statement in the exact required format\n    print(f\"[{p_t},{p_x},{E_Linf}]\")\n\nsolve()\n```", "id": "3241236"}, {"introduction": "数值格式有时会产生非物理的结果，例如负的浓度或温度。本练习探讨了保正性这一重要属性。我们将把 BTCS 格式与更高阶的 Crank-Nicolson 格式进行比较，使用一个具有尖锐梯度的初始条件，亲眼看看 BTCS 格式的鲁棒稳定性如何防止可能困扰其他方法的非物理下冲。[@problem_id:3241221]", "problem": "考虑单位区间上具有齐次狄利克雷边界条件的一维热方程，该方程被建模为纯扩散过程。设 $u(x,t)$ 满足 $u_t = \\alpha u_{xx}$（其中 $x \\in (0,1)$ 且 $t > 0$），边界条件为 $u(0,t) = 0$ 和 $u(1,t) = 0$，初始条件为非负且急剧局部化。您需要比较该问题的两种时间步进格式的正性行为：后向时间中心空间（BTCS）格式和 Crank-Nicolson（CN）格式，此时初始数据具有陡峭梯度。\n\n您的任务是在一个包含 $N$ 个内部点的均匀网格上实现一个全离散格式，网格间距为 $\\Delta x = 1/(N+1)$，并使用单个时间步长。使用以下基本方法：\n- 偏微分方程 $u_t = \\alpha u_{xx}$。\n- 用后向差分近似时间导数，即用后向有限差分替换新时间层上的 $u_t$。\n- 用空间上的中心差分近似二阶导数，即用最近邻上的二阶中心差分格式替换 $u_{xx}$。\n- Crank-Nicolson 时间离散化是通过对空间算子在时间上应用梯形法则，即取其在旧时间层和新时间层上的值的平均值来获得的。\n\n使用一种包含 $N$ 个内部点的标准空间离散格式，并将齐次狄利克雷边界条件直接整合到离散算子中。在内部网格上，使用经典的三点中心差分格式来表示二阶空间导数。\n\n将两种格式都实现为求解新时间层的线性系统：\n- BTCS（采用中心空间差分的隐式后向欧拉时间步）。\n- CN（对采用相同中心空间差分法的空间算子进行时间上的梯形平均）。\n\n为探究正性，选择一个具有陡峭梯度的离散初始条件：在恰好一个内部节点上（当 $N$ 为奇数时为唯一的中心索引）设置 $u_i^0 = 1$，而在所有其他内部节点上设置 $u_i^0 = 0$。这是一个具有零边界值的离散非负尖峰。使用无量纲变量，并设 $\\alpha = 1$。\n\n定义无量纲网格傅里叶数 $r = \\alpha \\Delta t / \\Delta x^2$。对于每个测试，使用固定的网格和 $\\alpha = 1$，选择 $\\Delta t$ 以精确实现指定的 $r$ 值。对于每种格式，从该初始数据演化恰好一个时间步。\n\n对于每个测试用例 $r$，确定每种格式在一个时间步后的最小值。如果最小值在严格的数值容差内为严格负值（使用 $10^{-12}$ 的绝对容差），则声明该格式出现下冲。对于每个测试用例 $r$，返回一个布尔值，当且仅当 BTCS 避免了下冲而 CN 出现了下冲时，该值为真。\n\n测试组：\n- 使用 $N = 99$ 个内部点（因此存在唯一的中心尖峰）。\n- 使用 $\\alpha = 1$（无量纲）。\n- 仅使用一个时间步（$1$ 步）。\n- 使用集合 $\\{0.2, 1.0, 1.2, 2.5\\}$ 中的 $r$ 值。\n\n输出规范：\n- 对于按上述顺序列出的每个 $r$，计算一个布尔值，当且仅当 BTCS 没有下冲（最小值在容差范围内大于或等于零）且 CN 有下冲（最小值在容差范围内严格小于零）时，该值为真。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，不含空格，其顺序与测试组中的 $r$ 值相同。例如，输出可能看起来像 $[True,False,True,True]$。\n\n所有量均为无量纲；不需要物理单位。不涉及角度。不涉及百分比；此任务中不出现基于百分比的量。", "solution": "用户希望我解决一个数值分析问题。\n\n计划如下：\n1.  **验证问题**：我将仔细检查问题陈述是否适定、科学上合理且完整。\n2.  **解构数学原理**：我需要将问题描述转化为 BTCS 和 Crank-Nicolson 格式的精确数学公式。\n3.  **构建线性系统**：两种格式都会产生形如 `A * u_new = b` 的线性方程组。我需要为 BTCS 和 CN 推导出矩阵 `A` 和右侧向量 `b`。\n4.  **实现解法**：我将使用 `numpy` 编写 Python 代码，为每个测试用例建立并求解这些线性系统。\n5.  **检查下冲**：对于每种格式和每个 `r` 值，我将找到解向量 `u_new` 的最小值，并将其与负容差进行比较，以确定是否发生下冲。\n6.  **生成最终输出**：我将把结果合并为指定的布尔值列表格式。\n\n### 步骤 1：问题验证\n\n**1.1. 提取已知条件：**\n-   **偏微分方程 (PDE)**：$u_t = \\alpha u_{xx}$，其中 $x \\in (0,1)$，$t > 0$。\n-   **边界条件 (BCs)**：$u(0,t) = 0$, $u(1,t) = 0$（齐次狄利克雷）。\n-   **网格**：均匀网格，$N$ 个内部点。\n-   **网格间距**：$\\Delta x = 1/(N+1)$。\n-   **时间离散化 (BTCS)**：对 $u_t$ 采用时间上的后向差分。\n-   **空间离散化**：对 $u_{xx}$ 采用中心差分。\n-   **时间离散化 (CN)**：对空间算子在时间上采用梯形法则。\n-   **初始条件 (IC)**：在唯一的中心索引处（对于奇数 $N$）$u_i^0 = 1$，其他位置为 $u_i^0 = 0$。\n-   **扩散系数**：$\\alpha = 1$。\n-   **网格傅里叶数**：$r = \\alpha \\Delta t / \\Delta x^2$。\n-   **演化**：演化恰好一个时间步。\n-   **下冲定义**：解的最小值是严格负数，绝对容差为 $10^{-12}$。\n-   **任务**：对于每个 $r$，如果（BTCS 无下冲）且（CN 有下冲），则返回 `True`。\n-   **测试组**：\n    -   $N = 99$。\n    -   $\\alpha = 1$。\n    -   一个时间步。\n    -   $r \\in \\{0.2, 1.0, 1.2, 2.5\\}$。\n-   **输出格式**：`[True,False,True,True]`（示例）。\n\n**1.2. 使用提取的已知条件进行验证：**\n-   **科学依据**：该问题描述了一维热方程，这是物理学和工程学中的一个基本偏微分方程。BTCS 和 Crank-Nicolson 格式是求解抛物型偏微分方程的标准、成熟的数值方法。数值稳定性与保正性（或其缺失，即下冲）的概念是数值分析的核心课题。整个设定在科学和数学上都是合理的。\n-   **适定性**：该问题是适定的。具有狄利克雷边界条件和指定初始条件的热方程有唯一解。数值格式的定义也很明确。对于任何合理的 $r > 0$，隐式格式（BTCS 和 CN）中涉及的矩阵都是可逆的，从而得到唯一的数值解。\n-   **客观性**：问题以精确的数学语言陈述。“下冲”、“BTCS”、“CN” 和初始条件等术语都有明确的定义。任务是客观的：基于清晰的数值标准计算布尔值。\n-   **缺陷检查清单**：\n    1.  **科学/事实不合理**：否。所涉及的物理（热扩散）和数学（数值方法）都是标准的。\n    2.  **无法形式化/不相关**：否。这是一个与指定主题直接相关的经典数值分析问题。\n    3.  **不完整/矛盾**：否。所有必要的参数（$N$、$\\alpha$、$r$ 值、初始条件）都已提供。定义是一致的。\n    4.  **不现实/不可行**：否。该设置是数值格式的标准测试用例。参数是无量纲且一致的。\n    5.  **不适定/结构不良**：否。问题结构导致每个测试用例都有唯一解。\n    6.  **伪深刻/琐碎**：否。它测试了数值格式的一个众所周知但并非微不足道的性质：对于陡峭梯度，特别是在较大时间步长（较大的 $r$）下，Crank-Nicolson 会产生振荡（从而从正数据产生负值），而 BTCS 是 L-稳定的且保持正性。这需要实际的实现和计算。\n    7.  **超出科学可验证范围**：否。结果完全可以通过计算来验证。\n\n**1.3. 结论与行动：**\n问题是**有效的**。我将继续进行求解。\n\n### 步骤 2：解构数学原理与构建线性系统\n\n设 $u_i^n$ 是 $u(x_i, t_n)$ 的数值近似，其中 $x_i = i \\Delta x$ 且 $t_n = n \\Delta t$。内部网格点对应于索引 $i = 1, 2, \\dots, N$。齐次狄利克雷边界条件强制为对所有时间步 $n$，都有 $u_0^n = 0$ 和 $u_{N+1}^n = 0$。\n\n控制偏微分方程是一维热方程：\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}\n$$\n\n我们在均匀网格上离散化该方程。设 $\\mathbf{u}^n = [u_1^n, u_2^n, \\dots, u_N^n]^T$ 为在时间层 $t_n$ 上 $N$ 个内部网格点处的解向量。二阶空间导数使用二阶中心差分格式进行近似。这可以表示为矩阵向量乘积 $\\alpha \\frac{\\partial^2 u}{\\partial x^2} \\approx \\alpha \\mathbf{L} \\mathbf{u}$，其中 $\\mathbf{L}$ 是 $N \\times N$ 的离散拉普拉斯矩阵：\n$$\n\\mathbf{L} = \\frac{1}{\\Delta x^2} \\begin{pmatrix}\n-2 & 1 & 0 & \\dots & 0 \\\\\n1 & -2 & 1 & \\dots & 0 \\\\\n0 & 1 & -2 & \\ddots & \\vdots \\\\\n\\vdots &  & \\ddots & \\ddots & 1 \\\\\n0 & \\dots & \\dots & 1 & -2\n\\end{pmatrix}\n$$\n半离散系统为 $\\frac{d\\mathbf{u}}{dt} = \\alpha \\mathbf{L} \\mathbf{u}$。我们现在将应用两种不同的时间步进格式。\n\n**1. 后向时间中心空间 (BTCS) 格式**\nBTCS 格式对时间导数使用一阶后向差分（隐式欧拉法），在新时间层 $n+1$ 上进行计算：\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\alpha \\mathbf{L} \\mathbf{u}^{n+1}\n$$\n重新整理以求解未知向量 $\\mathbf{u}^{n+1}$：\n$$\n(\\mathbf{I} - \\alpha \\Delta t \\mathbf{L}) \\mathbf{u}^{n+1} = \\mathbf{u}^n\n$$\n其中 $\\mathbf{I}$ 是单位矩阵。使用无量纲网格傅里叶数 $r = \\alpha \\Delta t / \\Delta x^2$，该系统变为：\n$$\n\\mathbf{A}_{\\text{BTCS}} \\mathbf{u}^{n+1} = \\mathbf{u}^n\n$$\n矩阵 $\\mathbf{A}_{\\text{BTCS}}$ 是一个三对角矩阵，定义如下：\n$$\n\\mathbf{A}_{\\text{BTCS}} = (\\mathbf{I} - r \\Delta x^2 \\mathbf{L}) = \\begin{pmatrix}\n1+2r & -r & 0 & \\dots & 0 \\\\\n-r & 1+2r & -r & \\dots & 0 \\\\\n0 & \\ddots & \\ddots & \\ddots & \\vdots \\\\\n\\vdots & \\dots & -r & 1+2r & -r \\\\\n0 & \\dots & 0 & -r & 1+2r\n\\end{pmatrix}\n$$\n右侧项就是前一个时间步的解，即 $\\mathbf{b}_{\\text{BTCS}} = \\mathbf{u}^n$。对于任何 $r > 0$，$\\mathbf{A}_{\\text{BTCS}}$ 都是一个 M-矩阵，这保证了如果初始数据 $\\mathbf{u}^n$ 是非负的，那么解 $\\mathbf{u}^{n+1}$ 也将是非负的。因此，BTCS 格式是无条件保正的。\n\n**2. Crank-Nicolson (CN) 格式**\nCrank-Nicolson 格式是一种二阶精度方法，它对空间算子在旧时间层和新时间层上取平均（梯形法则）：\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2} \\left( \\alpha \\mathbf{L} \\mathbf{u}^{n+1} + \\alpha \\mathbf{L} \\mathbf{u}^n \\right)\n$$\n重新整理以求解 $\\mathbf{u}^{n+1}$：\n$$\n\\left(\\mathbf{I} - \\frac{\\alpha \\Delta t}{2} \\mathbf{L}\\right) \\mathbf{u}^{n+1} = \\left(\\mathbf{I} + \\frac{\\alpha \\Delta t}{2} \\mathbf{L}\\right) \\mathbf{u}^n\n$$\n使用傅里叶数 $r$，这会产生以下线性系统：\n$$\n\\mathbf{A}_{\\text{CN}} \\mathbf{u}^{n+1} = \\mathbf{B}_{\\text{CN}} \\mathbf{u}^n\n$$\n左侧矩阵 $\\mathbf{A}_{\\text{CN}}$ 是：\n$$\n\\mathbf{A}_{\\text{CN}} = \\left(\\mathbf{I} - \\frac{r}{2} \\Delta x^2 \\mathbf{L}\\right) = \\begin{pmatrix}\n1+r & -r/2 & 0 & \\dots & 0 \\\\\n-r/2 & 1+r & -r/2 & \\dots & 0 \\\\\n0 & \\ddots & \\ddots & \\ddots & \\vdots \\\\\n\\vdots & \\dots & -r/2 & 1+r & -r/2 \\\\\n0 & \\dots & 0 & -r/2 & 1+r\n\\end{pmatrix}\n$$\n右侧项是向量 $\\mathbf{b}_{\\text{CN}} = \\mathbf{B}_{\\text{CN}} \\mathbf{u}^n$，其中矩阵 $\\mathbf{B}_{\\text{CN}}$ 是：\n$$\n\\mathbf{B}_{\\text{CN}} = \\left(\\mathbf{I} + \\frac{r}{2} \\Delta x^2 \\mathbf{L}\\right) = \\begin{pmatrix}\n1-r & r/2 & 0 & \\dots & 0 \\\\\nr/2 & 1-r & r/2 & \\dots & 0 \\\\\n0 & \\ddots & \\ddots & \\ddots & \\vdots \\\\\n\\vdots & \\dots & r/2 & 1-r & r/2 \\\\\n0 & \\dots & 0 & r/2 & 1-r\n\\end{pmatrix}\n$$\nCN 格式的保正性取决于右侧算子 $\\mathbf{B}_{\\text{CN}}$。要使 $\\mathbf{B}_{\\text{CN}}$ 将非负向量映射到非负向量，其所有元素必须为非负。这要求 $1-r \\ge 0$，即 $r \\le 1$。如果 $r > 1$，对角元素 $1-r$ 会变为负数。对于像指定的尖峰这样具有陡峭梯度的初始条件，这个负的对角线元素会在右侧向量 $\\mathbf{b}_{\\text{CN}}$ 中引入负值，这可能导致解 $\\mathbf{u}^{n+1}$ 中出现负值（下冲）。\n\n**实现策略**\n对于每个测试用例的 $r$ 值，我们执行以下步骤：\n1. 建立大小为 $N=99$ 的初始条件向量 $\\mathbf{u}^0$。除了中心元素（索引为 $k = (99-1)/2 = 49$）$u_k^0 = 1$ 外，其他位置均为零。\n2. 对于 BTCS 格式，构造矩阵 $\\mathbf{A}_{\\text{BTCS}}$ 并求解系统 $\\mathbf{A}_{\\text{BTCS}} \\mathbf{u}^1 = \\mathbf{u}^0$ 以得到 $\\mathbf{u}^1$。\n3. 对于 CN 格式，构造矩阵 $\\mathbf{A}_{\\text{CN}}$ 和 $\\mathbf{B}_{\\text{CN}}$。计算右侧向量 $\\mathbf{b}_{\\text{CN}} = \\mathbf{B}_{\\text{CN}} \\mathbf{u}^0$ 并求解系统 $\\mathbf{A}_{\\text{CN}} \\mathbf{u}^1 = \\mathbf{b}_{\\text{CN}}$ 以得到 $\\mathbf{u}^1$。\n4. 对于每种格式，在得到的解向量 $\\mathbf{u}^1$ 中找到最小值。\n5. 如果该最小值小于 $-10^{-12}$，则声明出现下冲。\n6. 对于给定的 $r$，如果 BTCS 没有下冲且 CN 出现下冲，则最终的布尔结果为 `True`。对所有指定的 $r$ 值重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Compares the positivity of BTCS and Crank-Nicolson schemes for the 1D heat equation.\n    \"\"\"\n\n    # --- Test Suite Parameters ---\n    N = 99  # Number of interior grid points\n    alpha = 1.0  # Diffusion coefficient\n    r_values = [0.2, 1.0, 1.2, 2.5]  # Dimensionless mesh Fourier numbers\n    tolerance = 1e-12\n\n    # --- Initial Condition ---\n    # Sharply localized spike at the center of the grid.\n    # N=99 is odd, so there is a unique center index.\n    u0 = np.zeros(N)\n    center_index = (N - 1) // 2\n    u0[center_index] = 1.0\n\n    results = []\n    for r in r_values:\n        # --- BTCS (Backward-Time Central-Space) Scheme ---\n        # The system is A_btcs * u1 = u0\n        \n        # Construct the tridiagonal matrix A_btcs\n        diag_main_btcs = (1 + 2 * r) * np.ones(N)\n        diag_off_btcs = -r * np.ones(N - 1)\n        A_btcs = np.diag(diag_main_btcs) + np.diag(diag_off_btcs, k=1) + np.diag(diag_off_btcs, k=-1)\n\n        # Right-hand side is simply the initial condition\n        b_btcs = u0\n\n        # Solve for the new time step\n        u1_btcs = np.linalg.solve(A_btcs, b_btcs)\n\n        # Check for undershoot\n        min_btcs = np.min(u1_btcs)\n        btcs_no_undershoot = (min_btcs >= -tolerance)\n\n        # --- Crank-Nicolson (CN) Scheme ---\n        # The system is A_cn * u1 = B_cn * u0\n        \n        # Construct the left-hand side matrix A_cn\n        diag_main_cn = (1 + r) * np.ones(N)\n        diag_off_cn = -r / 2.0 * np.ones(N - 1)\n        A_cn = np.diag(diag_main_cn) + np.diag(diag_off_cn, k=1) + np.diag(diag_off_cn, k=-1)\n        \n        # Construct the right-hand side vector b_cn = B_cn * u0.\n        # Since u0 is a spike at center_index, b_cn is just the center_index'th\n        # column of B_cn, where B_cn has diagonals (1-r) and off-diagonals (r/2).\n        b_cn = np.zeros(N)\n        b_cn[center_index] = 1.0 - r\n        if center_index > 0:\n            b_cn[center_index - 1] = r / 2.0\n        if center_index  N - 1:\n            b_cn[center_index + 1] = r / 2.0\n\n        # Solve for the new time step\n        u1_cn = np.linalg.solve(A_cn, b_cn)\n\n        # Check for undershoot\n        min_cn = np.min(u1_cn)\n        cn_undershoot = (min_cn  -tolerance)\n\n        # --- Evaluate Condition ---\n        # The condition is True if BTCS has no undershoot AND CN has an undershoot.\n        final_result = btcs_no_undershoot and cn_undershoot\n        results.append(final_result)\n\n    # Final print statement in the exact required format.\n    # Python's str(True) is 'True', which matches the format implied by the example.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3241221"}]}