{"hands_on_practices": [{"introduction": "当我们使用数值方法模拟随机微分方程（SDE）时，一个核心问题是评估我们近似的“好坏”程度。强收敛性衡量的是模拟路径与真实解路径的贴近程度。这项练习旨在通过比较最基础的欧拉-丸山（EM）方法和更高级的米尔斯坦（Milstein）方法，让你直观地看到它们在强收敛阶上的差异，这是理解和评估 SDE 数值方法性能的经典入门实践。[@problem_id:3226794]", "problem": "要求您比较两种数值格式对随机微分方程 (SDE) 的强收敛行为：欧拉-丸山 (Euler–Maruyama) 方法和米尔斯坦 (Milstein) 方法。研究完全在标量情形下针对几何布朗运动进行，其动态由以下伊东 (Itô) SDE 给出\n$$\ndX_t = \\mu X_t \\, dt + \\sigma X_t \\, dW_t,\n$$\n初始条件为 $X_0 = x_0$，其中 $\\mu \\in \\mathbb{R}$ 是漂移项，$\\sigma \\in \\mathbb{R}$ 是扩散系数，而 $W_t$ 是一个标准维纳过程。其精确解具有众所周知的闭式形式\n$$\nX_T = X_0 \\exp\\big((\\mu - \\tfrac{1}{2}\\sigma^2) T + \\sigma W_T\\big).\n$$\n您的任务是实现一个蒙特卡洛研究，以估计在终端时间 $T$ 时以下两种方法的强收敛阶：\n- 欧拉-丸山方法（欧拉-丸山方法是基于伊东积分的最简单离散化，用增量 $\\,\\Delta W_n\\,$ 替代伊东积分），以及\n- 米尔斯坦方法（米尔斯坦方法是用于标量SDE的一阶伊东-泰勒方法，它通过引入涉及扩散导数 $\\,b'(x)\\,$（其中 $\\,b(x)=\\sigma x\\,$）的主要随机泰勒校正项来增强欧拉-丸山增量）。\n\n从伊东积分、伊东公式和伊东-泰勒展开的核心定义出发，利用这些来设计两种时间步进更新方案。使用上述精确解来计算终端强误差。对于每种方法和每个时间步长，估计在时间 $T$ 的均方根 (RMS) 强误差：\n$$\n\\varepsilon_{\\mathrm{RMS}}(h) = \\Big(\\mathbb{E}\\big[|X_T^{(h)} - X_T|^2\\big]\\Big)^{1/2},\n$$\n其中 $X_T^{(h)}$ 表示使用均匀步长 $h$ 的数值近似解。\n\n为了估计收敛阶，考虑一组均匀步长 $h_k = T/N_k$ 并拟合模型\n$$\n\\log \\varepsilon_{\\mathrm{RMS}}(h_k) \\approx p \\log h_k + C\n$$\n通过在对数-对数尺度上进行最小二乘法拟合，以获得估计的强收敛阶 $p$。\n\n蒙特卡洛要求：\n- 使用 $M = 10000$ 条独立的样本路径。\n- 为了减少方差并确保不同步长之间的公平比较，应在最精细的网格上生成布朗增量，并通过对连续的精细网格增量求和来获得较粗糙网格的增量（即，使用一致的细化，使得 $N_{\\max}/N_k \\in \\mathbb{N}$，并且所有分辨率都由相同的底层噪声驱动）。\n- 为了可复现性，每个测试用例使用指定的伪随机种子。\n\n使用以下测试套件。对于每个测试，使用公共的时间分区集合 $N_k \\in \\{16, 32, 64, 128\\}$（因此 $h_k = T/N_k$），以及给定的路径数和种子进行模拟：\n- 测试 A（常规情况，中等噪声）：$x_0 = 1.0$, $\\mu = 1.0$, $\\sigma = 0.5$, $T = 1.0$, 种子 $= 314159$。\n- 测试 B（边缘情况，小噪声）：$x_0 = 2.0$, $\\mu = 0.3$, $\\sigma = 0.05$, $T = 2.0$, 种子 $= 271828$。\n- 测试 C（负漂移，强噪声）：$x_0 = 1.0$, $\\mu = -1.0$, $\\sigma = 1.0$, $T = 1.0$, 种子 $= 161803$。\n\n您的程序必须：\n- 基于伊东积分的原理构建，为给定的SDE实现欧拉-丸山方法和米尔斯坦方法。\n- 对于每个测试用例和每个 $N_k \\in \\{16, 32, 64, 128\\}$，使用 $M = 10000$ 条模拟路径和所述的耦合布朗增量计算RMS强误差，然后分别为欧拉-丸山和米尔斯坦方法在对数-对数模型中拟合斜率 $p$。\n- 对于每个测试用例，返回估计的强收敛阶对 $[p_{\\mathrm{EM}}, p_{\\mathrm{Mil}}]$，每个值四舍五入到两位小数。\n\n最终输出格式：\n- 您的程序应打印单行，其中包含一个含三个条目的列表，每个测试用例一个，按A、B、C的顺序排列。每个条目是该测试的双元素列表 $[p_{\\mathrm{EM}}, p_{\\mathrm{Mil}}]$。\n- 具体来说，您的程序应精确生成如下格式的一行：\n$$\n[[p_{\\mathrm{EM,A}}, p_{\\mathrm{Mil,A}}],[p_{\\mathrm{EM,B}}, p_{\\mathrm{Mil,B}}],[p_{\\mathrm{EM,C}}, p_{\\mathrm{Mil,C}}]]\n$$\n其中所有六个值为四舍五入到两位小数的浮点数，除了逗号、方括号和数字外，没有多余的字符或空格。", "solution": "问题陈述已经过分析，并被确定为有效。它在随机微积分和SDE数值方法理论方面具有科学依据，所有必要参数均已定义，问题阐述清晰，并且其表述和要求是客观的。\n\n此问题要求对应用于几何布朗运动 (GBM) 随机微分方程 (SDE) 的欧拉-丸山和米尔斯坦数值方法的强收敛阶进行比较研究。该SDE由下式给出：\n$$\ndX_t = \\mu X_t \\, dt + \\sigma X_t \\, dW_t, \\quad X(0) = x_0\n$$\n其中 $\\mu \\in \\mathbb{R}$ 是漂移参数，$\\sigma \\in \\mathbb{R}$ 是扩散参数，而 $W_t$ 是标准维纳过程。这是一个伊东过程，其漂移系数为 $a(x) = \\mu x$，扩散系数为 $b(x) = \\sigma x$。问题给出了在时间 $T$ 的精确解：\n$$\nX_T = X_0 \\exp\\left((\\mu - \\tfrac{1}{2}\\sigma^2) T + \\sigma W_T\\right)\n$$\n其中 $W_T = \\int_0^T dW_s$ 是维纳过程在 $[0, T]$ 上的总增量。\n\n解决方案涉及推导数值格式，在蒙特卡洛模拟中实现它们，计算强误差，并最终通过回归估计收敛阶。\n\n**1. 数值格式的推导**\n\n数值格式是通过将SDE的积分形式在长度为 $h = t_{n+1} - t_n$ 的时间区间 $[t_n, t_{n+1}]$ 上离散化得到的。积分形式为：\n$$\nX_{t_{n+1}} = X_{t_n} + \\int_{t_n}^{t_{n+1}} a(X_s) \\, ds + \\int_{t_n}^{t_{n+1}} b(X_s) \\, dW_s\n$$\n\n**欧拉-丸山 (EM) 方法：**\nEM方法是最简单的离散化，通过将被积函数 $a(X_s)$ 和 $b(X_s)$ 在区间上近似为常数，等于它们在区间开始时的值 $X_n \\equiv X_{t_n}$。\n$$\nX_{n+1} \\approx X_n + a(X_n) \\int_{t_n}^{t_{n+1}} \\, ds + b(X_n) \\int_{t_n}^{t_{n+1}} \\, dW_s\n$$\n积分计算结果为 $\\int_{t_n}^{t_{n+1}} ds = h$ 和 $\\int_{t_n}^{t_{n+1}} dW_s = \\Delta W_n = W_{t_{n+1}} - W_{t_n}$。项 $\\Delta W_n$ 表示从一个均值为 $0$、方差为 $h$ 的正态分布中随机抽取的值，即 $\\Delta W_n \\sim \\mathcal{N}(0, h)$。EM更新规则为：\n$$\nX_{n+1} = X_n + a(X_n) h + b(X_n) \\Delta W_n\n$$\n对于给定的GBM SDE，其中 $a(x) = \\mu x$ 和 $b(x) = \\sigma x$，EM格式为：\n$$\nX_{n+1} = X_n + \\mu X_n h + \\sigma X_n \\Delta W_n = X_n (1 + \\mu h + \\sigma \\Delta W_n)\n$$\n对于一般的SDE，EM方法的强收敛阶为 $0.5$。\n\n**米尔斯坦 (Milstein) 方法：**\n米尔斯坦方法通过包含伊东-泰勒展开中的一个附加项来改进EM方法。对于标量SDE，展开式为：\n$$\nX_{t_{n+1}} = X_{t_n} + a(X_n) h + b(X_n) \\Delta W_n + \\frac{1}{2} b(X_n) b'(X_n) \\left((\\Delta W_n)^2 - h\\right) + \\mathcal{O}(h^{3/2})\n$$\n其中 $b'(x)$ 是扩散系数关于 $x$ 的导数。此格式是通过在随机积分近似中包含下一阶项得到的。\n米尔斯坦方法的更新规则是：\n$$\nX_{n+1} = X_n + a(X_n) h + b(X_n) \\Delta W_n + \\frac{1}{2} b(X_n) b'(X_n) \\left((\\Delta W_n)^2 - h\\right)\n$$\n对于GBM SDE，我们有 $b(x) = \\sigma x$ 及其导数 $b'(x) = \\sigma$。将这些代入米尔斯坦格式得到：\n$$\nX_{n+1} = X_n + \\mu X_n h + \\sigma X_n \\Delta W_n + \\frac{1}{2} (\\sigma X_n) (\\sigma) \\left((\\Delta W_n)^2 - h\\right)\n$$\n$$\nX_{n+1} = X_n \\left(1 + \\mu h + \\sigma \\Delta W_n + \\frac{1}{2} \\sigma^2 \\left((\\Delta W_n)^2 - h\\right)\\right)\n$$\n米尔斯坦方法通常具有 $1.0$ 的强收敛阶。\n\n**2. 蒙特卡洛模拟框架**\n\n目标是根据关系 $\\varepsilon_{\\mathrm{RMS}}(h) \\propto h^p$ 估计强收敛阶 $p$。均方根 (RMS) 强误差定义为：\n$$\n\\varepsilon_{\\mathrm{RMS}}(h) = \\left( \\mathbb{E}\\left[|X_T^{(h)} - X_T|^2\\right] \\right)^{1/2}\n$$\n其中 $X_T^{(h)}$ 是步长为 $h$ 的数值解在时间 $T$ 的值，而 $X_T$ 是精确解。期望 $\\mathbb{E}[\\cdot]$ 通过在 $M = 10000$ 条独立模拟路径上的样本均值来近似：\n$$\n\\varepsilon_{\\mathrm{RMS}}(h) \\approx \\sqrt{ \\frac{1}{M} \\sum_{i=1}^{M} \\left|X_{T,i}^{(h)} - X_{T,i}\\right|^2 }\n$$\n为了确保公平比较并减少方差，对于不同的步长 $h_k = T/N_k$（其中 $N_k \\in \\{16, 32, 64, 128\\}$）的模拟是由相同的底层噪声驱动的。这是通过首先为最精细的网格 $N_{\\max} = 128$（步长 $h_{\\text{fine}} = T/N_{\\max}$）生成布朗增量来实现的。对于一个较粗的网格 $N_k  N_{\\max}$，其粗增量 $\\Delta W_n^{(k)}$ 是通过将 $R_k = N_{\\max}/N_k$ 个连续的细增量相加得到的。这确保了所有模拟的总维纳路径 $W_T$ 是相同的。\n\n**3. 收敛阶的估计**\n\n收敛阶 $p$ 是通过对对数转换后的误差和步长拟合一个线性模型来估计的：\n$$\n\\log \\varepsilon_{\\mathrm{RMS}}(h_k) = p \\log h_k + C\n$$\n这是一个针对数据点 $(\\log h_k, \\log \\varepsilon_{\\mathrm{RMS}}(h_k))$ 的简单线性回归问题。最佳拟合线的斜率 $p$ 就是估计的收敛阶。这对欧拉-丸山和米尔斯坦方法分别在每个测试用例中进行计算。\n\n每个测试用例的总体算法如下：\n1.  初始化参数（$\\mu, \\sigma, x_0, T$）和模拟设置（$M, N_k, \\text{seed}$）。\n2.  为 $N_{\\max}=128$ 个步骤生成 $M$ 条细网格布朗增量路径 $\\{\\Delta W_n^{\\text{fine}}\\}$。\n3.  使用总维纳增量 $W_{T,i} = \\sum_n \\Delta W_{n,i}^{\\text{fine}}$ 计算每条路径 $i$ 的精确解 $X_{T,i}$。\n4.  对于每个步数 $N_k \\in \\{16, 32, 64, 128\\}$：\n    a. 确定步长 $h_k = T/N_k$。\n    b. 通过对细网格增量求和来构建粗网格的布朗增量。\n    c. 使用EM和米尔斯坦格式模拟从 $t=0$ 到 $t=T$ 的 $M$ 条路径。\n    d. 计算两种方法的RMS强误差 $\\varepsilon_{\\mathrm{RMS}}(h_k)$。\n5.  使用计算出的误差集合，对 $(\\log h_k, \\log \\varepsilon_k)$ 进行线性回归，以找到欧拉-丸山方法的斜率 $p_{\\mathrm{EM}}$ 和米尔斯坦方法的斜率 $p_{\\mathrm{Mil}}$。\n6.  将估计的阶数四舍五入到两位小数，并存储结果对。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs a Monte Carlo study to estimate the strong convergence orders of the\n    Euler-Maruyama and Milstein methods for the Geometric Brownian Motion SDE.\n    \"\"\"\n    test_cases = [\n        # (x0, mu, sigma, T, seed)\n        (1.0, 1.0, 0.5, 1.0, 314159),  # Test A\n        (2.0, 0.3, 0.05, 2.0, 271828), # Test B\n        (1.0, -1.0, 1.0, 1.0, 161803), # Test C\n    ]\n\n    all_results = []\n\n    M = 10000  # Number of Monte Carlo paths\n    N_steps_list = [16, 32, 64, 128]\n    N_max = max(N_steps_list)\n\n    for x0, mu, sigma, T, seed in test_cases:\n        rng = np.random.default_rng(seed)\n        \n        # Step 1: Generate fine-grained Brownian increments for all paths\n        h_fine = T / N_max\n        # (M, N_max) matrix of increments\n        fine_increments = rng.normal(0, np.sqrt(h_fine), (M, N_max))\n        \n        # Step 2: Calculate the exact solution at time T\n        # Total Wiener increment for each path\n        W_T_paths = np.sum(fine_increments, axis=1)\n        X_exact_T = x0 * np.exp((mu - 0.5 * sigma**2) * T + sigma * W_T_paths)\n        \n        log_h_values = []\n        log_em_errors = []\n        log_mil_errors = []\n\n        # Step 3: Loop over different step sizes\n        for N_k in N_steps_list:\n            h_k = T / N_k\n            log_h_values.append(np.log(h_k))\n            \n            # Step 3a: Construct coarse Brownian increments from fine ones\n            refinement_ratio = N_max // N_k\n            coarse_increments = fine_increments.reshape(M, N_k, refinement_ratio).sum(axis=2)\n            \n            # Initialize numerical solutions at t=0\n            X_em = np.full(M, x0)\n            X_mil = np.full(M, x0)\n            \n            # Step 3b: Simulate paths for both schemes\n            for n in range(N_k):\n                dW = coarse_increments[:, n]\n                \n                # Euler-Maruyama update\n                X_em = X_em * (1 + mu * h_k + sigma * dW)\n                \n                # Milstein update\n                mil_correction = 0.5 * sigma**2 * (dW**2 - h_k)\n                X_mil = X_mil * (1 + mu * h_k + sigma * dW + mil_correction)\n            \n            # Step 3c: Calculate RMS strong error for this step size\n            em_error_sq = np.mean((X_em - X_exact_T)**2)\n            mil_error_sq = np.mean((X_mil - X_exact_T)**2)\n            \n            log_em_errors.append(0.5 * np.log(em_error_sq))\n            log_mil_errors.append(0.5 * np.log(mil_error_sq))\n\n        # Step 4: Perform log-log regression to find the convergence order\n        # np.polyfit returns [slope, intercept]\n        p_em = np.polyfit(log_h_values, log_em_errors, 1)[0]\n        p_mil = np.polyfit(log_h_values, log_mil_errors, 1)[0]\n        \n        # Round results to two decimal places\n        p_em_rounded = round(p_em, 2)\n        p_mil_rounded = round(p_mil, 2)\n        \n        all_results.append([p_em_rounded, p_mil_rounded])\n\n    # Step 5: Format the final output string\n    inner_strings = [f\"[{p_em},{p_mil}]\" for p_em, p_mil in all_results]\n    print(f\"[{','.join(inner_strings)}]\")\n\nsolve()\n```", "id": "3226794"}, {"introduction": "在许多应用中，我们更关心解的统计特性（如均值、方差），而非单条路径的精确性。弱收敛性正是衡量数值解在统计矩上逼近真实解的程度。通过这项练习，你将通过计算解的不同测试函数期望值的误差，来量化欧拉-丸山方法的弱收敛性，并验证其弱收敛阶为 $1$ 的重要结论，这通常优于其 $0.5$ 的强收敛阶。[@problem_id:3226701]", "problem": "考虑由下式给出的 Ornstein–Uhlenbeck (OU) 随机微分方程 (SDE)：\n$$\ndX_t = a\\,(m - X_t)\\,dt + \\sigma\\,dW_t,\\quad X_0 = x_0,\\quad t \\in [0,T],\n$$\n其中，$a0$ 是均值回归速率，$m \\in \\mathbb{R}$ 是长期均值，$\\sigma0$ 是扩散系数，$W_t$ 是标准维纳过程，$X_t$ 是状态变量。时间步长为 $\\Delta t$ 的 Euler–Maruyama (EM) 方法通过以下递推关系将该 SDE 离散化：\n$$\nX_{n+1}^{\\text{EM}} = X_n^{\\text{EM}} + a\\,(m - X_n^{\\text{EM}})\\,\\Delta t + \\sigma\\,\\sqrt{\\Delta t}\\,\\xi_n,\n$$\n其中，$\\xi_n \\sim \\mathcal{N}(0,1)$ 是独立同分布的标准正态随机变量，$n=0,1,\\dots,N-1$，$N = T/\\Delta t$ 是一个整数。\n\n您的任务如下，每一项都必须用代码实现：\n\n1. 从期望的线性性质和 Euler–Maruyama 方法定义的递推关系出发，推导 Euler–Maruyama 近似解 $X_T^{\\text{EM}}$ 在终端时刻 $T$ 的均值和方差的精确表达式，用 $a$、$m$、$\\sigma$、$x_0$、$T$ 和 $\\Delta t$ 表示。另外，利用常系数线性 Itô SDE 具有高斯解这一事实，推导 OU SDE 真实解 $X_T$ 的精确均值和方差。您的推导必须基于期望、方差、Itô 等距性和线性递推的定义；不得在没有论证的情况下引用任何现成的结果。\n\n2. 仅利用 $X_T$ 和 $X_T^{\\text{EM}}$ 都是高斯随机变量这一事实，对下列平滑测试函数 $f$ 精确地（而不是通过蒙特卡洛方法）表达期望 $\\mathbb{E}[f(X_T)]$ 和 $\\mathbb{E}[f(X_T^{\\text{EM}})]$：\n   - $f_1(x) = x$，\n   - $f_2(x) = \\sin(x)$，\n   - $f_3(x) = x^2$。\n   您可以使用从矩生成函数和特征函数得到的关于高斯随机变量函数期望的标准恒等式。\n\n3. 对于时间步长网格 $\\Delta t \\in \\{T/10,\\,T/20,\\,T/40,\\,T/80\\}$，计算弱误差\n$$\n\\left|\\mathbb{E}[f(X_T)] - \\mathbb{E}[f(X_T^{\\text{EM}})]\\right|\n$$\n对于每个 $f \\in \\{f_1,f_2,f_3\\}$。在该网格上使用对数-对数尺度上的最小二乘线性拟合，估计由以下斜率定义的经验弱阶 $p$：\n$$\n\\log\\left(\\text{weak error}\\right) \\approx p\\,\\log(\\Delta t) + C,\n$$\n并报告每个测试函数的 $p$ 值，保留三位小数。\n\n4. 对于特殊情况 $f_1(x)=x$，通过分析 $\\left|\\mathbb{E}[X_T] - \\mathbb{E}[X_T^{\\text{EM}}]\\right|$ 在 $\\Delta t \\to 0^+$ 时的行为来量化其主阶差异，并从第一性原理确认其为 $\\mathcal{O}(\\Delta t)$。\n\n用一个程序实现以上所有任务，该程序通过评估下面列出的两个独立参数集（一个测试套件）来确定性地执行，无需任何外部输入。对于每个参数集，使用测试函数 $f_1$、$f_2$ 和 $f_3$，以及四个时间步长 $\\Delta t \\in \\{T/10,\\,T/20,\\,T/40,\\,T/80\\}$。\n\n测试套件：\n- 情况 1：$a = 1.3$，$m = 0.5$，$\\sigma = 0.7$，$x_0 = -0.4$，$T = 1.0$。\n- 情况 2：$a = 3.0$，$m = -0.2$，$\\sigma = 0.5$，$x_0 = 1.1$，$T = 0.8$。\n\n您的程序必须：\n- 对每种情况，使用四个 $\\Delta t$ 值计算 $f_1$、$f_2$ 和 $f_3$ 的经验弱阶 $p$。\n- 将每个 $p$ 值四舍五入到三位小数，并按以下顺序汇总结果：情况 1 的 $f_1$，情况 1 的 $f_2$，情况 1 的 $f_3$，情况 2 的 $f_1$，情况 2 的 $f_2$，情况 2 的 $f_3$。\n- 生成单行输出，其中包含六个结果，格式为方括号内以逗号分隔的列表，不含空格，例如 $[p_{11},p_{12},p_{13},p_{21},p_{22},p_{23}]$。\n\n此问题不涉及物理单位。正弦函数内的角度以弧度为单位。不使用百分比；任何速率都应以小数形式报告。您的实现不得读取任何输入。", "solution": "该问题是有效的，因为它是随机微分方程数值分析中一个适定问题。它具有科学依据、内容自洽、客观，并且提供了所有必要的参数和条件。我们可以继续进行完整求解。\n\n解答分为四个部分呈现：(1) 推导 Euler-Maruyama 近似解 ($X_T^{\\text{EM}}$) 和真实解 ($X_T$) 的均值和方差的精确表达式，(2) 推导一组测试函数的精确期望，(3) 对均值误差的渐近分析，以及 (4) 经验性估计弱收敛阶的方法概述。\n\n**$1$. 解的均值和方差**\n\n**A. Euler-Maruyama 格式 ($X_T^{\\text{EM}}$)**\nOrnstein-Uhlenbeck 过程的 Euler-Maruyama 递推关系由下式给出：\n$$\nX_{n+1}^{\\text{EM}} = X_n^{\\text{EM}} + a\\,(m - X_n^{\\text{EM}})\\,\\Delta t + \\sigma\\,\\sqrt{\\Delta t}\\,\\xi_n\n$$\n其中 $\\xi_n \\sim \\mathcal{N}(0,1)$ 是独立同分布的标准正态随机变量。这个线性递推关系可以重写为：\n$$\nX_{n+1}^{\\text{EM}} = (1 - a\\Delta t)X_n^{\\text{EM}} + am\\Delta t + \\sigma\\sqrt{\\Delta t}\\xi_n\n$$\n初始条件为 $X_0^{\\text{EM}} = x_0$。\n\n**$X_T^{\\text{EM}}$ 的均值：**\n令 $\\mu_n^{\\text{EM}} = \\mathbb{E}[X_n^{\\text{EM}}]$。根据期望的线性性质以及 $\\mathbb{E}[\\xi_n] = 0$，对递推关系取期望可得：\n$$\n\\mathbb{E}[X_{n+1}^{\\text{EM}}] = \\mathbb{E}[(1 - a\\Delta t)X_n^{\\text{EM}} + am\\Delta t + \\sigma\\sqrt{\\Delta t}\\xi_n]\n$$\n$$\n\\mu_{n+1}^{\\text{EM}} = (1 - a\\Delta t)\\mathbb{E}[X_n^{\\text{EM}}] + am\\Delta t + \\sigma\\sqrt{\\Delta t}\\mathbb{E}[\\xi_n]\n$$\n$$\n\\mu_{n+1}^{\\text{EM}} = (1 - a\\Delta t)\\mu_n^{\\text{EM}} + am\\Delta t\n$$\n这是一个关于均值的一阶线性递推关系，其中 $\\mu_0^{\\text{EM}} = x_0$。该递推关系的不动点是 $m$。通过定义 $\\delta_n = \\mu_n^{\\text{EM}} - m$，该关系简化为几何级数 $\\delta_{n+1} = (1 - a\\Delta t)\\delta_n$，其解为 $\\delta_n = (1 - a\\Delta t)^n \\delta_0$。由于 $\\delta_0 = x_0 - m$，我们得到 $\\mu_n^{\\text{EM}} = m + (x_0 - m)(1 - a\\Delta t)^n$。\n在终端时刻 $T$，我们有 $n = N = T/\\Delta t$。因此，Euler-Maruyama 近似解在时刻 $T$ 的均值为：\n$$\n\\mathbb{E}[X_T^{\\text{EM}}] = m + (x_0 - m)(1 - a\\Delta t)^{T/\\Delta t}\n$$\n\n**$X_T^{\\text{EM}}$ 的方差：**\n令 $V_n^{\\text{EM}} = \\text{Var}(X_n^{\\text{EM}})$。由于 $\\xi_n$ 独立于 $X_n^{\\text{EM}}$（它只依赖于 $\\xi_0, \\dots, \\xi_{n-1}$），它们和的方差等于方差的和：\n$$\n\\text{Var}(X_{n+1}^{\\text{EM}}) = \\text{Var}((1 - a\\Delta t)X_n^{\\text{EM}}) + \\text{Var}(\\sigma\\sqrt{\\Delta t}\\xi_n)\n$$\n$$\nV_{n+1}^{\\text{EM}} = (1 - a\\Delta t)^2 V_n^{\\text{EM}} + \\sigma^2 \\Delta t \\text{Var}(\\xi_n)\n$$\n使用 $\\text{Var}(\\xi_n) = 1$，我们得到递推关系 $V_{n+1}^{\\text{EM}} = (1 - a\\Delta t)^2 V_n^{\\text{EM}} + \\sigma^2 \\Delta t$，初始条件为 $V_0^{\\text{EM}} = \\text{Var}(x_0) = 0$。这是一个形式为 $y_{n+1} = \\alpha y_n + \\beta$ 的线性递推关系，其中 $\\alpha = (1 - a\\Delta t)^2$ 且 $\\beta = \\sigma^2 \\Delta t$。其解为 $V_n^{\\text{EM}} = \\beta \\sum_{k=0}^{n-1} \\alpha^k = \\beta \\frac{1-\\alpha^n}{1-\\alpha}$。\n分母为 $1 - \\alpha = 1 - (1-2a\\Delta t + a^2(\\Delta t)^2) = a\\Delta t(2-a\\Delta t)$。\n代入 $\\alpha$ 和 $\\beta$：\n$$\nV_n^{\\text{EM}} = \\sigma^2 \\Delta t \\frac{1 - (1 - a\\Delta t)^{2n}}{a\\Delta t(2 - a\\Delta t)} = \\frac{\\sigma^2}{a(2 - a\\Delta t)}[1 - (1 - a\\Delta t)^{2n}]\n$$\n在时刻 $T$，当 $n=N=T/\\Delta t$ 时，方差为：\n$$\n\\text{Var}(X_T^{\\text{EM}}) = \\frac{\\sigma^2}{a(2 - a\\Delta t)}[1 - (1 - a\\Delta t)^{2T/\\Delta t}]\n$$\n由于 $X_n^{\\text{EM}}$ 在每一步都是由高斯随机变量的线性变换和求和构成的，所以 $X_N^{\\text{EM}}$ 是一个高斯随机变量。\n\n**B. 真实 SDE 解 ($X_T$)**\nSDE $dX_t = a(m - X_t)dt + \\sigma dW_t$ 可重写为 $dX_t + aX_t dt = am dt + \\sigma dW_t$。使用积分因子 $e^{at}$，我们得到 $d(e^{at}X_t) = am e^{at} dt + \\sigma e^{at} dW_t$。从 $0$ 到 $t$ 积分得到：\n$$\ne^{at}X_t - X_0 = \\int_0^t am e^{as}ds + \\int_0^t \\sigma e^{as}dW_s\n$$\n求解 $X_t$ 得到精确解：\n$$\nX_t = X_0 e^{-at} + m(1 - e^{-at}) + \\sigma \\int_0^t e^{-a(t-s)} dW_s = m + (x_0-m)e^{-at} + \\sigma \\int_0^t e^{-a(t-s)} dW_s\n$$\n\n**$X_T$ 的均值：**\n为了求均值，我们对 $t=T$ 时的解取期望。Itô 积分的期望为零，即对于一个确定性被积函数 $f(s)$，有 $\\mathbb{E}[\\int_0^T f(s)dW_s] = 0$。\n$$\n\\mathbb{E}[X_T] = \\mathbb{E}[m + (x_0-m)e^{-aT}] + \\sigma \\mathbb{E}\\left[\\int_0^T e^{-a(T-s)} dW_s\\right]\n$$\n$$\n\\mathbb{E}[X_T] = m + (x_0 - m)e^{-aT}\n$$\n\n**$X_T$ 的方差：**\n方差完全由随机项决定。使用 Itô 等距性质，该性质表明 $\\text{Var}(\\int_0^T f(s) dW_s) = \\int_0^T f(s)^2 ds$：\n$$\n\\text{Var}(X_T) = \\text{Var}\\left(\\sigma \\int_0^T e^{-a(T-s)}dW_s\\right) = \\sigma^2 \\int_0^T (e^{-a(T-s)})^2 ds = \\sigma^2 \\int_0^T e^{-2a(T-s)}ds\n$$\n计算该积分：\n$$\n\\int_0^T e^{-2a(T-s)}ds = \\left[\\frac{e^{-2a(T-s)}}{2a}\\right]_0^T = \\frac{1}{2a}(e^0 - e^{-2aT}) = \\frac{1-e^{-2aT}}{2a}\n$$\n因此，真实解的方差为：\n$$\n\\text{Var}(X_T) = \\frac{\\sigma^2}{2a}(1 - e^{-2aT})\n$$\n真实解 $X_T$ 是一个高斯随机变量，因为它是一个常数加上一个具有确定性被积函数的 Itô 积分。\n\n**$2$. 测试函数的期望**\n对于一个高斯随机变量 $Y \\sim \\mathcal{N}(\\mu, v)$，测试函数 $f_1, f_2, f_3$ 的期望推导如下：\n- $f_1(x) = x$：$\\mathbb{E}[f_1(Y)] = \\mathbb{E}[Y] = \\mu$。\n- $f_3(x) = x^2$：根据方差的定义 $\\text{Var}(Y) = \\mathbb{E}[Y^2] - (\\mathbb{E}[Y])^2$，我们得到 $\\mathbb{E}[f_3(Y)] = \\mathbb{E}[Y^2] = v + \\mu^2$。\n- $f_2(x) = \\sin(x)$：这个期望可以使用高斯分布的特征函数 $\\phi_Y(k) = \\mathbb{E}[e^{ikY}] = e^{ik\\mu - \\frac{1}{2}vk^2}$ 来计算：\n$$\n\\mathbb{E}[\\sin(Y)] = \\mathbb{E}\\left[\\frac{e^{iY}-e^{-iY}}{2i}\\right] = \\frac{1}{2i}(\\phi_Y(1) - \\phi_Y(-1)) = \\frac{1}{2i}\\left(e^{i\\mu - \\frac{v}{2}} - e^{-i\\mu - \\frac{v}{2}}\\right) = e^{-\\frac{v}{2}}\\sin(\\mu)\n$$\n通过将 $(\\mu, v)$ 分别替换为 $X_T$ 和 $X_T^{\\text{EM}}$ 的均值-方差对，使用这些公式来计算精确期望。\n\n**$3$. 均值误差的渐近分析**\n我们分析当 $\\Delta t \\to 0^+$ 时，对于 $f_1(x)=x$ 的主阶差异 $|\\mathbb{E}[X_T] - \\mathbb{E}[X_T^{\\text{EM}}]|$。该误差正比于 $|e^{-aT} - (1 - a\\Delta t)^{T/\\Delta t}|$。我们对小的 $\\Delta t$ 展开离散项：\n$$\n(1 - a\\Delta t)^{T/\\Delta t} = \\exp\\left(\\frac{T}{\\Delta t}\\log(1 - a\\Delta t)\\right)\n$$\n使用泰勒展开 $\\log(1-x) = -x - x^2/2 - O(x^3)$，其中 $x=a\\Delta t$：\n$$\n\\frac{T}{\\Delta t}\\log(1 - a\\Delta t) = \\frac{T}{\\Delta t}\\left(-a\\Delta t - \\frac{(a\\Delta t)^2}{2} - O((\\Delta t)^3)\\right) = -aT - \\frac{a^2T\\Delta t}{2} - O((\\Delta t)^2)\n$$\n将其代回指数函数并对小的 $y$ 使用 $e^{y} = 1+y+O(y^2)$：\n$$\n(1-a\\Delta t)^{T/\\Delta t} = e^{-aT} e^{-a^2T\\Delta t/2 - O((\\Delta t)^2)} = e^{-aT}\\left(1 - \\frac{a^2T\\Delta t}{2} + O((\\Delta t)^2)\\right)\n$$\n那么均值的差异为：\n$$\n\\mathbb{E}[X_T] - \\mathbb{E}[X_T^{\\text{EM}}] = (x_0-m)\\left[e^{-aT} - \\left(e^{-aT} - e^{-aT}\\frac{a^2T\\Delta t}{2} + \\dots\\right)\\right] = (x_0-m)e^{-aT}\\frac{a^2T}{2}\\Delta t + O((\\Delta t)^2)\n$$\n这表明均值的误差是 $\\mathcal{O}(\\Delta t)$ 阶的，从而从第一性原理证实了均值的弱收敛阶为 $1$。\n\n**$4$. 经验弱阶估计方法**\n对于一个测试函数 $f$ 和时间步长 $\\Delta t$，弱误差为 $E(\\Delta t) = |\\mathbb{E}[f(X_T)] - \\mathbb{E}[f(X_T^{\\text{EM}})]|$。弱收敛阶 $p$ 由渐近关系 $E(\\Delta t) \\approx C(\\Delta t)^p$ 定义，其中 $C$ 为某个常数。对两边取自然对数得到一个线性模型：\n$$\n\\log(E(\\Delta t)) \\approx p \\log(\\Delta t) + \\log(C)\n$$\n这条线的斜率就是弱阶 $p$。给定时间步长网格 $\\{\\Delta t_i\\}$ 上的一组 $k$ 个误差 $\\{E_i\\}$，我们计算 $y_i = \\log(E_i)$ 和 $x_i = \\log(\\Delta t_i)$。然后通过对点 $(x_i, y_i)$ 进行线性最小二乘回归来估计参数 $p$。斜率由以下公式给出：\n$$\np = \\frac{k \\sum (x_i y_i) - (\\sum x_i)(\\sum y_i)}{k \\sum (x_i^2) - (\\sum x_i)^2}\n$$\n将此过程应用于每个参数集的每个测试函数（$f_1, f_2, f_3$），以找到经验弱阶，预期该值接近 $1$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the empirical weak order of the Euler-Maruyama method for the\n    Ornstein-Uhlenbeck SDE for two parameter sets and three test functions.\n    \"\"\"\n    # Test Suite\n    test_cases = [\n        # Case 1: a=1.3, m=0.5, sigma=0.7, x0=-0.4, T=1.0\n        (1.3, 0.5, 0.7, -0.4, 1.0),\n        # Case 2: a=3.0, m=-0.2, sigma=0.5, x0=1.1, T=0.8\n        (3.0, -0.2, 0.5, 1.1, 0.8),\n    ]\n\n    all_orders = []\n\n    for case_params in test_cases:\n        a, m, sigma, x0, T = case_params\n\n        # Calculate mean and variance of the true solution X_T\n        mean_true = m + (x0 - m) * np.exp(-a * T)\n        var_true = (sigma**2 / (2 * a)) * (1 - np.exp(-2 * a * T))\n\n        # Test functions: a lambda to compute expectation from mean (mu) and variance (var)\n        test_functions = [\n            lambda mu, var: mu,                            # f1(x) = x\n            lambda mu, var: np.sin(mu) * np.exp(-var / 2), # f2(x) = sin(x)\n            lambda mu, var: var + mu**2,                   # f3(x) = x^2\n        ]\n\n        for func_exp in test_functions:\n            # Calculate true expectation for the current test function\n            exp_true = func_exp(mean_true, var_true)\n\n            dt_values = np.array([T / 10.0, T / 20.0, T / 40.0, T / 80.0])\n            errors = []\n\n            for dt in dt_values:\n                # Number of steps N=T/dt is an integer for the chosen dt values\n                N = T / dt\n                \n                # Calculate mean and variance of the Euler-Maruyama approximation\n                term_mean = (1 - a * dt)**N\n                mean_em = m + (x0 - m) * term_mean\n\n                term_var = (1 - a * dt)**(2 * N)\n                # Handle the case where 2 - a*dt is very close to zero or negative, although unlikely for these params\n                if (2 - a * dt) = 0:\n                    var_em = float('inf')\n                else:\n                    var_em = (sigma**2 / (a * (2 - a * dt))) * (1 - term_var)\n                \n                # Calculate EM expectation for the current test function\n                exp_em = func_exp(mean_em, var_em)\n                \n                # Calculate and store the weak error\n                errors.append(np.abs(exp_true - exp_em))\n\n            errors = np.array(errors)\n            \n            # Perform log-log linear regression to find the order p.\n            # The model is log(error) = p * log(dt) + C.\n            # np.polyfit(x, y, 1) returns [slope, intercept], so we take the first element.\n            log_dt = np.log(dt_values)\n            log_errors = np.log(errors)\n            \n            p = np.polyfit(log_dt, log_errors, 1)[0]\n            \n            all_orders.append(round(p, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_orders))}]\")\n\nsolve()\n```", "id": "3226701"}, {"introduction": "在应用欧拉-丸山这类基于伊藤（Itô）积分的数值格式之前，我们必须确保面对的是一个伊藤 SDE。然而，许多物理和金融模型自然地以斯特拉托诺维奇（Stratonovich）积分形式出现，这两种形式并不总能直接互换。这项练习将指导你动手实践伊藤-斯特拉托诺维奇转换，让你明白直接将 EM 方法用于斯特拉托诺维奇 SDE 会导致错误，必须先进行转换才能获得正确的模拟结果。[@problem_id:3226843]", "problem": "令 $W_t$ 表示一个标准布朗运动（维纳过程）。考虑一个一维 Stratonovich 随机微分方程（SDE），\n$$\ndX_t \\;=\\; a(X_t)\\,dt \\;+\\; b(X_t)\\circ dW_t,\n$$\n其中 $a(\\cdot)$ 和 $b(\\cdot)$ 是充分光滑的函数。仅从 Itô 和 Stratonovich 随机积分的基础定义及其满足的链式法则出发，推导等价的 Itô SDE，并识别出由转换产生的额外漂移项。然后设计一个程序，使用欧拉-丸山（EM）格式模拟所得 Itô SDE 的样本路径，并根据理论推导的基准验证路径统计数据。\n\n您的程序必须以基于原理的方式实现以下任务。\n\n- 推导任务：\n  - 从链式法则以及 Itô 和 Stratonovich 积分的定义极限出发，证明形如\n    $$\n    dX_t \\;=\\; a(X_t)\\,dt \\;+\\; b(X_t)\\circ dW_t\n    $$\n    的 Stratonovich SDE 等价于形如\n    $$\n    dX_t \\;=\\; f(X_t)\\,dt \\;+\\; g(X_t)\\,dW_t\n    $$\n    的 Itô SDE，其中 $f(\\cdot)$ 和 $g(\\cdot)$ 需要用 $a(\\cdot)$、$b(\\cdot)$ 及其导数来表示。不要假设任何预先推导出的转换公式；您必须从积分及其链式法则的基本定义进行推理。\n\n- 离散化任务：\n  - 对时间步长为 $h$ 的均匀网格，为 Itô SDE $dX_t=f(X_t)\\,dt+g(X_t)\\,dW_t$ 实现欧拉-丸山（EM）方法，即\n    $$\n    X_{n+1} \\;=\\; X_n \\;+\\; f(X_n)\\,h \\;+\\; g(X_n)\\,\\Delta W_n,\\qquad \\Delta W_n \\sim \\mathcal{N}(0,h),\n    $$\n    其中 $X_0$ 是给定的。在不同时间和不同路径上使用独立的高斯增量。使用下面每个测试用例中指定的 $h$。\n\n- 统计验证任务：\n  - 对于每个指定的测试用例，使用 EM 模拟一个包含 $N$ 条独立路径的系综，直至时间 $T$，计算终端时间 $T$ 处的所请求的统计数据，并与从 Itô SDE 推导出的精确理论值进行比较。每次比较都必须根据一个绝对容差进行评估，并将结果记录为一个布尔值，指示经验统计值是否在理论值的容差范围内。所请求的统计数据和容差在下面的测试套件中提供。\n\n测试套件。对于每种情况，您必须首先通过原理推导将给定的 Stratonovich SDE 转换为其 Itô 形式，然后使用 EM 进行模拟，最后验证所述的统计数据。所有时间都使用相同的抽象单位；不涉及物理单位，也不需要角度单位。\n\n- 情况 A（线性漂移与常数扩散；零修正的边界测试）：\n  - Stratonovich SDE: $dX_t \\,=\\, a(X_t)\\,dt + b(X_t)\\circ dW_t$，其中 $a(x)= -k\\,x$ 和 $b(x)=\\sigma$。\n  - 参数: $k=1.1$, $\\sigma=0.6$, $X_0=1.3$, $T=1.0$, $h=0.005$, $N=30000$, seed $=12345$。\n  - Itô SDE 在时间 $T$ 的理论统计数据：\n    - 均值: $\\mathbb{E}[X_T] \\,=\\, X_0\\,e^{-kT}$。\n    - 方差: $\\mathrm{Var}(X_T) \\,=\\, \\dfrac{\\sigma^2}{2k}\\left(1-e^{-2kT}\\right)$。\n  - 容差: 均值容差 $\\tau_{\\text{mean}}=0.04$，方差容差 $\\tau_{\\text{var}}=0.05$。\n  - 此情况的验证输出：按顺序排列的两个布尔值，mean-within-tolerance, variance-within-tolerance。\n\n- 情况 B（乘性噪声；非零转换修正；几何增长）：\n  - Stratonovich SDE: $dX_t \\,=\\, a(X_t)\\,dt + b(X_t)\\circ dW_t$，其中 $a(x)=\\mu_{\\mathrm{S}}\\,x$ 和 $b(x)=\\sigma\\,x$。\n  - 参数: $\\mu_{\\mathrm{S}}=0.10$, $\\sigma=0.50$, $X_0=1.2$, $T=1.0$, $h=0.005$, $N=30000$, seed $=54321$。\n  - Itô SDE 在时间 $T$ 的理论统计数据：\n    - 均值: $\\mathbb{E}[X_T] \\,=\\, X_0\\,\\exp\\!\\big(\\mu_{\\mathrm{I}}\\,T\\big)$，其中 $\\mu_{\\mathrm{I}}$ 是您必须通过转换推导出的乘以 $x$ 的 Itô 漂移系数。\n  - 容差: 均值容差 $\\tau_{\\text{mean}}=0.04$。\n  - 此情况的验证输出：一个布尔值，mean-within-tolerance。\n\n- 情况 C（平方根扩散；状态依赖噪声与奇异导数；正性挑战）：\n  - Stratonovich SDE: $dX_t \\,=\\, a(X_t)\\,dt + b(X_t)\\circ dW_t$，其中 $a(x)=0$ 和 $b(x)=2\\sqrt{x}$。\n  - 参数: $X_0=0.4$, $T=1.0$, $h=0.005$, $N=30000$, seed $=20231102$。\n  - Itô SDE 在时间 $T$ 的理论统计数据：\n    - 均值: $\\mathbb{E}[X_T] \\,=\\, X_0 + T$。\n  - 容差: 均值容差 $\\tau_{\\text{mean}}=0.05$。\n  - 数值稳定性说明：在数值格式内部计算 $b(x)$ 时，使用 $\\sqrt{\\max(x,0)}$ 来确保平方根有定义；这可以防止由离散化引入的罕见的负值偏移。\n  - 此情况的验证输出：一个布尔值，mean-within-tolerance。\n\n需要满足的实现细节：\n- 严格按照所述使用欧拉-丸山方法。\n- 使用独立的标准正态随机变量乘以 $\\sqrt{h}$ 作为增量 $\\Delta W_n$。\n- 对于每种情况，使用给定的随机种子以保证可复现性。\n- 按顺序生成所有请求的布尔值：情况 A 均值，情况 A 方差，情况 B 均值，情况 C 均值。\n\n要求的最终输出格式：\n- 您的程序必须打印单行，其中包含一个用方括号括起来的、由逗号分隔的四个布尔结果列表，例如 $[{\\rm True},{\\rm False},{\\rm True},{\\rm True}]$。\n\n不需要外部输入；所有参数均已在上方指定。答案必须不带单位，也不带任何附加文本。最终打印的行必须与格式完全匹配。", "solution": "该问题是有效的，因为它在科学上基于随机微积分理论，问题设定良好，所有必要的参数和条件都已指定，并且使用客观、正式的语言表述。我们将首先从基本原理推导 Stratonovich 和 Itô SDE 之间的关系，然后将其应用于具体案例，最后设计一个数值模拟来验证理论结果。\n\n### 第1部分：Itô-Stratonovich 转换公式的推导\n\n核心任务是将一个 Stratonovich SDE\n$$\ndX_t = a(X_t)\\,dt + b(X_t)\\circ dW_t\n$$\n转换为其等价的 Itô 形式\n$$\ndX_t = f(X_t)\\,dt + g(X_t)\\,dW_t.\n$$\n这需要将用 `$\\circ$` 表示的 Stratonovich 积分与 Itô 积分联系起来。根本区别在于定义它们的黎曼-斯蒂尔切斯和中被积函数的求值点。Itô 积分使用时间区间的左端点，而 Stratonovich 积分使用中点。\n\n对于一个一般过程 $Y_t$，两种积分之间的关系由下式给出：\n$$\n\\int_0^T Y_t \\circ dW_t = \\int_0^T Y_t \\,dW_t + \\frac{1}{2} [Y, W]_T\n$$\n其中 $[Y, W]_T$ 是过程 $Y_t$ 和 $W_t$ 在区间 $[0, T]$ 上的二次协变差。用微分形式表示为：\n$$\nY_t \\circ dW_t = Y_t \\,dW_t + \\frac{1}{2} d[Y, W]_t.\n$$\n在我们的问题中，过程 $Y_t$ 是 $X_t$ 的一个函数，具体为 $Y_t = b(X_t)$。我们需要找到协变差 $d[b(X), W]_t$。二次协变差是根据微分项的乘积计算的，遵循 Itô 微积分的规则：$dt \\cdot dt = 0$，$dt \\cdot dW_t = 0$，以及 $dW_t \\cdot dW_t = dt$。协变差微分为 $d[b(X), W]_t = d(b(X_t)) \\cdot dW_t$。\n\n为了找到 $d(b(X_t))$，我们对函数 $b(x)$ 应用 Itô 引理（Itô 过程的链式法则），假设 $X_t$ 遵循目标 Itô SDE $dX_t = f(X_t)dt + g(X_t)dW_t$：\n$$\nd(b(X_t)) = b'(X_t) dX_t + \\frac{1}{2} b''(X_t) (dX_t)^2\n$$\n代入 $dX_t = f(X_t)dt + g(X_t)dW_t$ 并应用 Itô 乘法规则：\n\\begin{align*}\nd(b(X_t)) = b'(X_t) (f(X_t)dt + g(X_t)dW_t) + \\frac{1}{2} b''(X_t) (f(X_t)dt + g(X_t)dW_t)^2 \\\\\n= b'(X_t)f(X_t)dt + b'(X_t)g(X_t)dW_t + \\frac{1}{2} b''(X_t) g(X_t)^2 dt\n\\end{align*}\n现在，我们计算协变差微分：\n$$\nd[b(X), W]_t = d(b(X_t)) \\cdot dW_t = (b'(X_t)g(X_t)dW_t) \\cdot dW_t = b'(X_t)g(X_t)dt.\n$$\n我们现在可以将此代回积分关系中：\n$$\nb(X_t) \\circ dW_t = b(X_t) \\,dW_t + \\frac{1}{2} b'(X_t)g(X_t)dt.\n$$\n让我们将此插入到原始的 Stratonovich SDE 中：\n$$\ndX_t = a(X_t)dt + \\left( b(X_t) \\,dW_t + \\frac{1}{2}b'(X_t)g(X_t)dt \\right).\n$$\n通过将此方程中的 $dW_t$ 项与目标 Itô 形式 $dX_t = f(X_t)dt + g(X_t)dW_t$进行比较，我们必须有 $g(X_t) = b(X_t)$。\n\n将 $g(x) = b(x)$ 代入我们推导的表达式中，得到：\n$$\ndX_t = a(X_t)dt + b(X_t) \\,dW_t + \\frac{1}{2}b'(X_t)b(X_t)dt.\n$$\n最后，将 $dt$ 项组合在一起，得到等价的 Itô SDE：\n$$\ndX_t = \\left( a(X_t) + \\frac{1}{2}b(X_t)b'(X_t) \\right)dt + b(X_t)dW_t.\n$$\n由此，我们确定 Itô 形式的函数：\n$$\nf(x) = a(x) + \\frac{1}{2}b(x)b'(x)\n$$\n$$\ng(x) = b(x)\n$$\n项 $\\frac{1}{2}b(x)b'(x)$ 是 Itô-Stratonovich 修正项。\n\n### 第2部分：应用于测试案例和离散化\n\n我们现在将此转换公式应用于每个案例，并定义欧拉-丸山格式。对于时间步长为 $h$ 的 Itô SDE $dX_t = f(X_t)dt + g(X_t)dW_t$，该格式为：\n$$\nX_{n+1} = X_n + f(X_n)h + g(X_n)\\Delta W_n,\n$$\n其中 $X_n \\approx X(nh)$ 且 $\\Delta W_n \\sim \\mathcal{N}(0,h)$ 是维纳过程的独立增量。\n\n**情况A：线性漂移，常数扩散**\n- Stratonovich SDE: $a(x) = -k x$, $b(x) = \\sigma$。\n- $b(x)$ 的导数: $b'(x) = 0$。\n- 修正项: $\\frac{1}{2}b(x)b'(x) = \\frac{1}{2}(\\sigma)(0) = 0$。\n- Itô SDE: $dX_t = (-k X_t + 0)dt + \\sigma dW_t = -k X_t dt + \\sigma dW_t$。\n- 这是一个 Ornstein-Uhlenbeck 过程。Itô 和 Stratonovich 形式是相同的。\n- 用于模拟：$f(x) = -k x$, $g(x) = \\sigma$。\n- 理论均值 $\\mathbb{E}[X_T] = X_0 e^{-kT}$ 和方差 $\\mathrm{Var}(X_T) = \\frac{\\sigma^2}{2k}(1-e^{-2kT})$ 是此过程的已知矩。\n\n**情况B：乘性噪声，几何增长**\n- Stratonovich SDE: $a(x) = \\mu_{\\mathrm{S}} x$, $b(x) = \\sigma x$。\n- $b(x)$ 的导数: $b'(x) = \\sigma$。\n- 修正项: $\\frac{1}{2}b(x)b'(x) = \\frac{1}{2}(\\sigma x)(\\sigma) = \\frac{1}{2}\\sigma^2 x$。\n- Itô SDE 漂移项: $f(x) = a(x) + \\frac{1}{2}b(x)b'(x) = \\mu_{\\mathrm{S}} x + \\frac{1}{2}\\sigma^2 x = (\\mu_{\\mathrm{S}} + \\frac{1}{2}\\sigma^2) x$。\n- Itô SDE: $dX_t = (\\mu_{\\mathrm{S}} + \\frac{1}{2}\\sigma^2) X_t dt + \\sigma X_t dW_t$。\n- 这是一个几何布朗运动。Itô 漂移系数为 $\\mu_{\\mathrm{I}} = \\mu_{\\mathrm{S}} + \\frac{1}{2}\\sigma^2$。\n- 用于模拟：$f(x) = \\mu_{\\mathrm{I}} x$, $g(x) = \\sigma x$。\n- 理论均值为 $\\mathbb{E}[X_T] = X_0 \\exp(\\mu_{\\mathrm{I}}T)$，与问题陈述相符。\n\n**情况C：平方根扩散**\n- Stratonovich SDE: $a(x) = 0$, $b(x) = 2\\sqrt{x}$。\n- $b(x)$ 的导数: $b'(x) = 2 \\cdot \\frac{1}{2}x^{-1/2} = \\frac{1}{\\sqrt{x}}$。\n- 修正项: $\\frac{1}{2}b(x)b'(x) = \\frac{1}{2}(2\\sqrt{x})(\\frac{1}{\\sqrt{x}}) = 1$。令人惊讶的是，修正项是一个常数。\n- Itô SDE 漂移项: $f(x) = a(x) + \\frac{1}{2}b(x)b'(x) = 0 + 1 = 1$。\n- Itô SDE: $dX_t = 1 \\cdot dt + 2\\sqrt{X_t} dW_t$。\n- 用于模拟：$f(x) = 1$, $g(x) = 2\\sqrt{x}$。\n- 为求理论均值，我们对 Itô SDE 取期望：$d\\mathbb{E}[X_t] = \\mathbb{E}[1]dt + \\mathbb{E}[2\\sqrt{X_t}dW_t]$。Itô 积分的期望为零，所以 $d\\mathbb{E}[X_t] = dt$。\n- 从 $0$ 到 $T$ 积分得到 $\\mathbb{E}[X_T] - \\mathbb{E}[X_0] = T$。由于 $X_0$ 是常数，这给出 $\\mathbb{E}[X_T] = X_0 + T$，与问题相符。\n\n模拟将通过为每个推导出的 Itô SDE 实现欧拉-丸山格式，生成 $N$ 条路径，并计算时间 $T$ 时的样本均值和方差，以便与这些理论基准进行比较。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives Itô SDEs from Stratonovich SDEs, simulates them using the\n    Euler-Maruyama method, and validates path statistics.\n    \"\"\"\n    results = []\n\n    # --- Case A: Ornstein-Uhlenbeck Process ---\n    # Parameters\n    k = 1.1\n    sigma = 0.6\n    X0 = 1.3\n    T = 1.0\n    h = 0.005\n    N = 30000\n    seed = 12345\n    \n    # Stratonovich: a(x) = -k*x, b(x) = sigma\n    # b'(x) = 0. Correction term is 0.\n    # Itô: f(x) = -k*x, g(x) = sigma\n    f_A = lambda x: -k * x\n    g_A = lambda x: sigma\n\n    # Simulation\n    rng = np.random.default_rng(seed)\n    num_steps = int(T / h)\n    X = np.full(N, X0, dtype=np.float64)\n    # Pre-generate all random increments for efficiency\n    dW = rng.standard_normal(size=(num_steps, N)) * np.sqrt(h)\n\n    for i in range(num_steps):\n        X = X + f_A(X) * h + g_A(X) * dW[i, :]\n\n    # Statistical Validation\n    theo_mean_A = X0 * np.exp(-k * T)\n    theo_var_A = (sigma**2 / (2 * k)) * (1 - np.exp(-2 * k * T))\n    emp_mean_A = np.mean(X)\n    emp_var_A = np.var(X)\n    \n    tau_mean_A = 0.04\n    tau_var_A = 0.05\n\n    results.append(np.abs(emp_mean_A - theo_mean_A)  tau_mean_A)\n    results.append(np.abs(emp_var_A - theo_var_A)  tau_var_A)\n\n    # --- Case B: Geometric Brownian Motion ---\n    # Parameters\n    mu_S = 0.10\n    sigma_B = 0.50\n    X0_B = 1.2\n    # T, h, N are the same\n    seed_B = 54321\n\n    # Stratonovich: a(x) = mu_S*x, b(x) = sigma*x\n    # b'(x) = sigma. Correction term is 0.5 * b(x) * b'(x) = 0.5 * (sigma*x) * sigma = 0.5 * sigma^2 * x.\n    # Itô drift coefficient: mu_I = mu_S + 0.5 * sigma^2\n    mu_I = mu_S + 0.5 * sigma_B**2\n    f_B = lambda x: mu_I * x\n    g_B = lambda x: sigma_B * x\n\n    # Simulation\n    rng_B = np.random.default_rng(seed_B)\n    X_B = np.full(N, X0_B, dtype=np.float64)\n    dW_B = rng_B.standard_normal(size=(num_steps, N)) * np.sqrt(h)\n    \n    for i in range(num_steps):\n        X_B = X_B + f_B(X_B) * h + g_B(X_B) * dW_B[i, :]\n    \n    # Statistical Validation\n    theo_mean_B = X0_B * np.exp(mu_I * T)\n    emp_mean_B = np.mean(X_B)\n    \n    tau_mean_B = 0.04\n    \n    results.append(np.abs(emp_mean_B - theo_mean_B)  tau_mean_B)\n\n    # --- Case C: Square-Root Diffusion ---\n    # Parameters\n    X0_C = 0.4\n    # T, h, N are the same\n    seed_C = 20231102\n\n    # Stratonovich: a(x) = 0, b(x) = 2*sqrt(x)\n    # b'(x) = 1/sqrt(x). Correction term is 0.5 * b(x) * b'(x) = 0.5 * (2*sqrt(x)) * (1/sqrt(x)) = 1.\n    # Itô: f(x) = 1, g(x) = 2*sqrt(x)\n    f_C = lambda x: 1.0\n    # Use np.maximum to handle potential negative values from discretization noise\n    g_C = lambda x: 2.0 * np.sqrt(np.maximum(x, 0))\n\n    # Simulation\n    rng_C = np.random.default_rng(seed_C)\n    X_C = np.full(N, X0_C, dtype=np.float64)\n    dW_C = rng_C.standard_normal(size=(num_steps, N)) * np.sqrt(h)\n\n    for i in range(num_steps):\n        X_C = X_C + f_C(X_C) * h + g_C(X_C) * dW_C[i, :]\n\n    # Statistical Validation\n    theo_mean_C = X0_C + T\n    emp_mean_C = np.mean(X_C)\n    \n    tau_mean_C = 0.05\n    \n    results.append(np.abs(emp_mean_C - theo_mean_C)  tau_mean_C)\n\n    # Print a single line with the comma-separated list of booleans\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3226843"}]}