{"hands_on_practices": [{"introduction": "这个练习是您进入迎风格式世界的第一步。模拟最简单形式的平流方程 $u_t + a u_x = 0$，可以说是计算流体动力学的“Hello, World!”。通过这个实践，您将掌握一阶迎风格式的核心机制，并亲眼观察其最显著的特性——数值耗散（numerical diffusion），当模拟像阶跃函数这样的尖锐特征时，这一特性会变得尤为明显。[@problem_id:2448567]", "problem": "考虑一维线性平流方程，其标量场为 $u(x,t)$，平流速度 $a$ 为常数，\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\\quad x \\in [x_{\\min},x_{\\max}],\\ t \\ge 0,\n$$\n其初始条件由亥维赛德阶跃函数给出\n$$\nu(x,0) = H(x - x_0),\\quad H(\\xi) = \\begin{cases}\n1,  \\xi \\ge 0,\\\\\n0,  \\xi  0.\n\\end{cases}\n$$\n施加与初始数据的远场状态一致的入流边界条件：如果 $a > 0$，则对所有 $t \\ge 0$ 强制 $u(x_{\\min},t)=0$；如果 $a  0$，则对所有 $t \\ge 0$ 强制 $u(x_{\\max},t)=1$。所有量均为无量纲。\n\n在 $[x_{\\min},x_{\\max}]$ 上的一个包含 $N$ 个点的均匀空间网格上，将解在时间上推进至最终时间 $T$。时间步长 $\\Delta t$ 的选择应满足指定的 Courant–Friedrichs–Lewy (CFL) 数 $C$，其中\n$$\nC = \\frac{|a|\\,\\Delta t}{\\Delta x},\\quad \\Delta x = \\frac{x_{\\max} - x_{\\min}}{N-1}.\n$$\n使用与 $a$ 的符号一致的一阶迎风离散格式。对于下方的每个测试用例，计算在时间 $T$ 的离散 $\\ell^1$ 误差，其定义为\n$$\nE_1 = \\sum_{i=0}^{N-1} \\left| u_i^{\\text{num}}(T) - u^{\\text{exact}}(x_i,T) \\right|\\,\\Delta x,\n$$\n其中 $x_i$ 是网格点，$u_i^{\\text{num}}(T)$ 是在时间 $T$ 的数值解，而解析解是平移后的阶跃函数\n$$\nu^{\\text{exact}}(x,T) = H\\!\\left( x - (x_0 + a\\,T) \\right),\n$$\n该解对于下面给出的时间和参数是有效的，因为平流带来的间断点严格保持在区间 $[x_{\\min},x_{\\max}]$ 内部，且不与边界相互作用。\n\n测试套件（每个测试用例是一个元组 $(a,x_{\\min},x_{\\max},x_0,N,T,C)$）：\n- 测试 1：$(1.0,\\,0.0,\\,1.0,\\,0.25,\\,401,\\,0.2,\\,0.5)$。\n- 测试 2：$(-0.7,\\,0.0,\\,1.0,\\,0.8,\\,401,\\,0.15,\\,0.8)$。\n- 测试 3：$(1.0,\\,0.0,\\,1.0,\\,0.3,\\,201,\\,0.3,\\,1.0)$。\n\n您的程序必须按所列顺序为每个测试计算 $E_1$，并生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个数字四舍五入到六位小数（例如，$[0.123456,0.000000,1.234568]$）。", "solution": "该问题是有效的，因为它具有科学依据、是适定的且客观的。它提出了计算物理学中的一个标准任务：使用一阶迎风格式求解线性平流方程并评估数值误差。所有参数和条件都已明确定义。\n\n控制方程是标量场 $u(x,t)$ 的一维线性平流方程，其平流速度 $a$ 为常数：\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0\n$$\n为了对该方程进行数值求解，我们对时空域进行离散化。空间域 $[x_{\\min}, x_{\\max}]$ 被划分为一个包含 $N$ 个点的均匀网格，$x_i = x_{\\min} + i\\Delta x$，其中 $i=0, 1, \\dots, N-1$，网格间距为 $\\Delta x = (x_{\\max} - x_{\\min}) / (N-1)$。时间以离散的步长推进，我们将 $u(x_i, t^n)$ 的数值近似值表示为 $u_i^n$。\n\n时间导数 $\\partial_t u$ 使用一阶向前差分（前向欧拉法）进行近似：\n$$\n\\partial_t u(x_i, t^n) \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}\n$$\n一阶迎风格式使用单边有限差分来近似空间导数 $\\partial_x u$。单边模板的选择取决于信息传播的方向，该方向由平流速度 $a$ 的符号给出。这确保了数值方法从“迎风”方向获取信息，这是双曲型求解器稳定性的一个关键属性。\n\n情况 1：$a  0$\n信息从左向右（沿 $x$ 正方向）传播。在 $x_i$ 处的空间导数使用后向差分进行近似，这涉及迎风点 $x_{i-1}$：\n$$\n\\partial_x u(x_i, t^n) \\approx \\frac{u_i^n - u_{i-1}^n}{\\Delta x}\n$$\n将这些离散近似值代入偏微分方程，得到更新规则：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\frac{u_i^n - u_{i-1}^n}{\\Delta x} = 0\n$$\n求解下一个时间步的解 $u_i^{n+1}$：\n$$\nu_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x} (u_i^n - u_{i-1}^n) = u_i^n - C (u_i^n - u_{i-1}^n)\n$$\n其中 $C = \\frac{a \\Delta t}{\\Delta x}$ 是 Courant–Friedrichs–Lewy (CFL) 数，因为 $a0$。该格式应用于 $i=1, \\dots, N-1$。\n\n情况 2：$a  0$\n信息从右向左（沿 $x$ 负方向）传播。空间导数使用前向差分进行近似，这涉及迎风点 $x_{i+1}$：\n$$\n\\partial_x u(x_i, t^n) \\approx \\frac{u_{i+1}^n - u_i^n}{\\Delta x}\n$$\n相应的更新规则是：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\frac{u_{i+1}^n - u_i^n}{\\Delta x} = 0\n$$\n求解 $u_i^{n+1}$：\n$$\nu_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x} (u_{i+1}^n - u_i^n) = u_i^n + C (u_{i+1}^n - u_i^n)\n$$\n这里，CFL 数定义为 $C = \\frac{|a| \\Delta t}{\\Delta x} = \\frac{-a \\Delta t}{\\Delta x}$，这意味着 $\\frac{a \\Delta t}{\\Delta x} = -C$。该格式应用于 $i=0, \\dots, N-2$。\n\n如果满足 CFL 条件 $C \\le 1$，则该显式时间步进格式的稳定性得到保证。提供的所有测试用例都满足此条件。\n\n仿真过程如下：\n1.  **初始化**：对于每个测试用例 $(a, x_{\\min}, x_{\\max}, x_0, N, T, C)$，计算网格间距 $\\Delta x$ 和名义时间步长 $\\Delta t = C \\Delta x / |a|$。解数组 $u$ 使用亥维赛德函数 $u(x,0) = H(x - x_0)$ 进行初始化。\n2.  **时间演化**：通过一个循环将解从 $t=0$ 推进到 $T$。为确保精确达到最终时间 $T$，每次迭代的时间步长计算为 $\\Delta t_{\\text{curr}} = \\min(\\Delta t, T - t)$。这处理了 $T$ 不是 $\\Delta t$ 整数倍的情况。\n3.  **更新步骤**：在循环内部，创建解 $u^n$ 的一个副本。使用适当的迎风公式为所有内部点计算新解 $u^{n+1}$，其更新系数按 $\\Delta t_{\\text{curr}}$ 进行缩放。\n4.  **边界条件**：在计算完内部点的更新后，强制执行入流边界条件。如果 $a > 0$，则设置左边界的值：$u_0^{n+1} = 0$。如果 $a  0$，则设置右边界的值：$u_{N-1}^{n+1} = 1$。出流边界无需特殊处理，因为它由迎风模板的单边性质处理。\n5.  **误差计算**：一旦仿真达到 $t=T$，就获得了最终的数值解 $u_i^{\\text{num}}(T)$。在同一网格上计算解析解 $u^{\\text{exact}}(x_i,T) = H(x_i - (x_0 + aT))$。然后使用以下公式计算离散 $\\ell^1$ 误差：\n    $$\n    E_1 = \\sum_{i=0}^{N-1} \\left| u_i^{\\text{num}}(T) - u^{\\text{exact}}(x_i,T) \\right|\\,\\Delta x\n    $$\n对于 $C=1.0$ 的测试用例，该格式（对于 $a0$）简化为 $u_i^{n+1} = u_{i-1}^n$。这对应于每个时间步长将离散数据精确平移一个网格单元。由于总时间 $T$ 的选择使得总平流距离 $aT$ 是 $\\Delta x$ 的整数倍，网格上的数值解与精确解相同，从而导致零误差。对于 $C  1$，该格式会引入数值耗散，这会使尖锐的阶跃变得模糊，并产生非零误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation for multiple test cases\n    using a first-order upwind scheme and computes the l1 error.\n    \"\"\"\n    test_cases = [\n        # (a, x_min, x_max, x_0, N, T, C)\n        (1.0, 0.0, 1.0, 0.25, 401, 0.2, 0.5),\n        (-0.7, 0.0, 1.0, 0.8, 401, 0.15, 0.8),\n        (1.0, 0.0, 1.0, 0.3, 201, 0.3, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_case(*case)\n        # Append result formatted to six decimal places.\n        results.append(f\"{error:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef solve_case(a, x_min, x_max, x_0, N, T, C):\n    \"\"\"\n    Runs a single simulation case for the 1D linear advection equation.\n\n    Args:\n        a (float): Advection speed.\n        x_min (float): Minimum of the spatial domain.\n        x_max (float): Maximum of the spatial domain.\n        x_0 (float): Initial position of the step in the Heaviside function.\n        N (int): Number of grid points.\n        T (float): Final time.\n        C (float): Courant–Friedrichs–Lewy (CFL) number.\n\n    Returns:\n        float: The discrete l1 error at the final time T.\n    \"\"\"\n    # 1. Setup grid and initial condition\n    dx = (x_max - x_min) / (N - 1)\n    x = np.linspace(x_min, x_max, N)\n    # The problem defines H(xi) = 1 for xi >= 0. np.heaviside with second arg 1.0 does this.\n    u = np.heaviside(x - x_0, 1.0)\n\n    # 2. Setup time stepping\n    # The advection speed 'a' is non-zero in all test cases.\n    dt_nominal = C * dx / abs(a)\n    \n    # 3. Time integration loop\n    t = 0.0\n    # Use a small tolerance for floating point comparison to ensure loop termination.\n    while t  T:\n        # Determine current time step to not step over T.\n        current_dt = min(dt_nominal, T - t)\n        \n        # Make a copy of the solution at the current time step 'n'.\n        u_n = u.copy()\n        \n        # The update coefficient nu = a * dt / dx\n        nu = a * current_dt / dx\n        \n        if a > 0:\n            # FTBS (Forward-Time, Backward-Space) for a > 0\n            # u_i^{n+1} = u_i^n - nu * (u_i^n - u_{i-1}^n)\n            u[1:] = u_n[1:] - nu * (u_n[1:] - u_n[:-1])\n            # Apply inflow boundary condition at x_min\n            u[0] = 0.0\n        else: # a  0\n            # FTFS (Forward-Time, Forward-Space) for a  0\n            # u_i^{n+1} = u_i^n - nu * (u_{i+1}^n - u_i^n)\n            u[:-1] = u_n[:-1] - nu * (u_n[1:] - u_n[:-1])\n            # Apply inflow boundary condition at x_max\n            u[-1] = 1.0\n            \n        t += current_dt\n\n    # 4. Calculate exact solution at time T\n    x_final_discontinuity = x_0 + a * T\n    u_exact = np.heaviside(x - x_final_discontinuity, 1.0)\n    \n    # 5. Compute the discrete l1 error\n    error = np.sum(np.abs(u - u_exact)) * dx\n    \n    return error\n\nsolve()\n```", "id": "2448567"}, {"introduction": "在掌握了匀速平流的情形后，我们将进入一个更接近现实的场景，其中平流速度 $a(x)$ 会随空间变化。这个练习将挑战您实现一个真正“局部”的迎风格式，它能根据每个网格点上信息流动的方向自动调整其计算模板。这对于模拟具有前向和后向传播波的复杂流动至关重要，例如在汇合或发散的通道中。[@problem_id:3285398]", "problem": "考虑具有空间相关速度的一维线性平流方程，\n$$\nu_t(x,t) + a(x)\\,u_x(x,t) = 0,\\quad x\\in[0,1],\\ t\\ge 0,\n$$\n其中 $u(x,t)$ 是一个被输运的标量场，$a(x)$ 是一个预设的、足够光滑且在空间域上可能变号的速度。对于双曲输运方程，信息沿由 $a(x)$ 符号决定的特征线传播，稳定的离散化必须使用来自迎风方向的值。您的任务是实现一个一阶显式迎风有限差分法，该方法根据 $a(x)$ 的局部符号切换差分格式，并量化此切换过程及所得离散解的属性。\n\n在一个完整的程序中实现以下设计：\n- 使用包含 $N$ 个点的均匀网格离散化 $[0,1]$，其中 $x_i = i\\,\\Delta x$，$i=0,1,\\dots,N-1$，$\\Delta x = 1/(N-1)$。\n- 使用单个显式欧拉时间步进器，其时间步长 $\\Delta t$ 满足 Courant-Friedrichs-Lewy (CFL) 稳定性条件，具体为\n$$\n\\Delta t = \\lambda\\,\\frac{\\Delta x}{\\max_{0\\le i\\le N-1} |a(x_i)|},\n$$\n其中 $0  \\lambda \\le 1$ 是库朗数。\n- 在每个内部网格点 $i=1,2,\\dots,N-2$，使用取自迎风方向的单边差分来近似 $u_x(x_i,t)$，该方向由 $a(x_i)$ 的符号选择：如果 $a(x_i)0$ 使用后向差分，如果 $a(x_i)0$ 使用前向差分，当 $a(x_i)=0$ 时（无输运）将导数项的贡献设置为零。\n- 对所有 $t\\ge 0$ 施加狄利克雷边界值 $u(0,t) = u_L$ 和 $u(1,t) = u_R$。请注意，对于双曲流，在特征信息进入区域的地方，这些值充当入流值；在出流边界上，它们不影响内部点的更新，因为迎风格式不会引用它们。\n- 将数值解推进 $K$ 个显式欧拉步。\n\n从第一性原理出发，该方法必须基于双曲输运方程的因果性以及由 $a(x)$ 符号所暗示的特征线方向性来推导。特别地，后向差分与 $a(x)>0$ 一致，因为 $x_i$ 处的信息来自 $x_{i-1}$；而前向差分与 $a(x)0$ 一致，因为 $x_i$ 处的信息来自 $x_{i+1}$。\n\n定义以下由您的程序为每个测试用例计算的离散诊断量：\n1. 方法使用后向差分的内部点（即 $a(x_i)0$ 的点）的整数数量 $i=1,\\dots,N-2$。\n2. 方法使用前向差分的内部点（即 $a(x_i)0$ 的点）的整数数量 $i=1,\\dots,N-2$。\n3. 离散速度场中符号变化界面的整数数量，定义为满足 $\\operatorname{sign}(a(x_i))\\ne \\operatorname{sign}(a(x_{i+1}))$ 的索引 $i=0,\\dots,N-2$ 的计数，约定 $\\operatorname{sign}(0)=0$。\n4. 一个布尔值，指示经过 $K$ 步后，离散解是否相对于初始数据和边界数据的包络满足离散极值原理，即是否满足\n$$\n\\min_{0\\le i\\le N-1} u^K_i \\ge \\min\\left(\\min_{0\\le i\\le N-1} u^0_i,\\ u_L,\\ u_R\\right)\n\\quad\\text{和}\\quad\n\\max_{0\\le i\\le N-1} u^K_i \\le \\max\\left(\\max_{0\\le i\\le N-1} u^0_i,\\ u_L,\\ u_R\\right),\n$$\n其中 $u^n_i$ 表示经过 $n$ 个时间步后在网格点 $x_i$ 的数值解。\n\n使用以下参数值测试套件来检验该方法的不同方面：\n- 测试用例 A（具有单个跳跃和不同量值的通用情况）：\n  - $N=51$，$\\lambda=0.9$，$K=25$，\n  - $a(x)=\\begin{cases}1,  x0.5\\\\ -0.5,  x\\ge 0.5\\end{cases}$，\n  - $u_L=0$，$u_R=1$，\n  - $u_0(x)=\\sin(2\\pi x)$。\n- 测试用例 B（边界对齐的零速度，在网格点处精确符号反转）：\n  - $N=51$，$\\lambda=0.9$，$K=30$，\n  - $a(x)=x-0.5$，\n  - $u_L=0.5$，$u_R=-0.5$，\n  - $u_0(x)=1-2|x-0.5|$。\n- 测试用例 C（具有快速变化过渡的平滑符号变化）：\n  - $N=101$，$\\lambda=0.9$，$K=40$，\n  - $a(x)=\\tanh\\big(20(0.7-x)\\big)$，\n  - $u_L=1$，$u_R=-1$，\n  - $u_0(x)=\\cos(4\\pi x)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个测试用例的结果本身必须是按上述顺序排列的、用方括号括起来的逗号分隔列表。例如，输出格式必须为\n$$\n[\\,[n_{\\text{back}},n_{\\text{fwd}},n_{\\text{sign}},\\text{mp}],\\,[\\dots],\\,[\\dots]\\,],\n$$\n其中 $n_{\\text{back}}$ 和 $n_{\\text{fwd}}$ 是整数，$n_{\\text{sign}}$ 是整数，$\\text{mp}$ 是一个布尔值。", "solution": "用户提供的问题被评估为有效。这是一个在偏微分方程数值分析领域中定义良好、具有科学依据的问题，所有必要组成部分都已明确定义。\n\n该问题要求为具有空间相关、符号可变的平流速度 $a(x)$ 的一维线性平流方程实现一个一阶显式迎风有限差分法：\n$$\nu_t(x,t) + a(x)\\,u_x(x,t) = 0\n$$\n支配该问题的基本原理是双曲因果性。对于双曲方程（如平流方程），信息沿特征线传播。这些曲线在 $(x,t)$ 平面上的轨迹由常微分方程 $dx/dt = a(x)$ 定义。速度 $a(x)$ 的符号决定了信息流动的方向：如果 $a(x)0$，信息从左向右传播；如果 $a(x)0$，则从右向左传播。一个稳定的数值格式必须通过在“迎风”方向（即信息来源的方向）进行差分来尊重这种物理因果性。\n\n解在一个包含 $N$ 个点的均匀空间网格上进行离散化，$x_i = i\\,\\Delta x$，$i=0, 1, \\dots, N-1$，网格间距为 $\\Delta x = 1/(N-1)$。时间使用显式欧拉法推进，时间步长为 $\\Delta t$。在网格点 $x_i$ 的半离散方程为：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a(x_i) (u_x)_i^n = 0\n$$\n这给出了更新公式 $u_i^{n+1} = u_i^n - \\Delta t \\, a(x_i) (u_x)_i^n$。\n\n迎风方法的核心在于空间导数 $(u_x)_i^n$ 的近似。差分格式的选择由平流速度 $a(x_i)$ 的局部符号决定：\n1.  如果 $a(x_i)  0$，流动从左到右。$x_i$ 处的信息来自 $x_{i-1}$。空间导数使用一阶后向差分近似：\n    $$\n    (u_x)_i^n \\approx \\frac{u_i^n - u_{i-1}^n}{\\Delta x}\n    $$\n2.  如果 $a(x_i)  0$，流动从右到左。$x_i$ 处的信息来自 $x_{i+1}$。空间导数使用一阶前向差分近似：\n    $$\n    (u_x)_i^n \\approx \\frac{u_{i+1}^n - u_i^n}{\\Delta x}\n    $$\n3.  如果 $a(x_i) = 0$，在 $x_i$ 处没有输运。平流项 $a(x_i)u_x$ 为零，解不发生变化：$u_i^{n+1} = u_i^n$。\n\n综合这些，内部点 $i=1, \\dots, N-2$ 的完整更新格式为：\n$$\nu_i^{n+1} = \\begin{cases}\nu_i^n - \\frac{a(x_i)\\Delta t}{\\Delta x}(u_i^n - u_{i-1}^n),  \\text{若 } a(x_i)  0 \\\\\nu_i^n - \\frac{a(x_i)\\Delta t}{\\Delta x}(u_{i+1}^n - u_i^n),  \\text{若 } a(x_i)  0 \\\\\nu_i^n,  \\text{若 } a(x_i) = 0\n\\end{cases}\n$$\n此显式格式在 Courant-Friedrichs-Lewy (CFL) 条件下是稳定的，该条件要求数值依赖域必须包含物理依赖域。这可转化为约束条件 $|a(x_i)|\\Delta t / \\Delta x \\le 1$ 对所有 $i$ 成立。为确保整个网格的稳定性，时间步长 $\\Delta t$ 根据最大速度选择：\n$$\n\\Delta t = \\lambda \\frac{\\Delta x}{\\max_{i} |a(x_i)|}\n$$\n其中 $\\lambda \\in (0, 1]$ 是库朗数。\n\n狄利克雷边界条件 $u(0,t) = u_L$ 和 $u(1,t) = u_R$ 通过在所有时间步 $n$ 中设置 $u_0^n = u_L$ 和 $u_{N-1}^n = u_R$ 来施加。当流动指向域内时，这些值为邻近边界的内部点提供了必要的迎风数据。例如，在 $i=1$ 处，如果 $a(x_1)0$，则差分格式需要 $u_0^n = u_L$。反之，如果流动指向域外（例如，$a(x_1)0$），边界值 $u_L$ 不用于 $u_1^n$ 的更新，这正确地反映了出流的物理特性。\n\n实现过程首先定义离散网格并计算所有网格点上的速度场 $a(x_i)$ 和初始条件 $u_i^0$。与速度场相关的诊断量（$n_{\\text{back}}$、$n_{\\text{fwd}}$、$n_{\\text{sign}}$）计算一次。然后，将解推进 $K$ 个时间步，每一步都涉及根据上述迎风逻辑更新所有内部点。经过 $K$ 步后，最终解 $u_i^K$ 用于检验离散极值原理。该原理指出格式不会产生新的极值，是此方法的一个关键属性，并且在CFL条件满足时成立。通过将最终解的最小值和最大值与初始数据和边界值的包络进行比较来验证它。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, lambda_cfl, K, a_func, u_L, u_R, u0_func):\n    \"\"\"\n    Solves the 1D advection equation with a space-dependent speed\n    using a first-order upwind scheme and computes specified diagnostics.\n    \"\"\"\n    # 1. Grid and Field Setup\n    x = np.linspace(0.0, 1.0, N)\n    dx = 1.0 / (N - 1)\n    \n    a = a_func(x)\n    u = u0_func(x)\n    u_initial = u.copy()\n\n    # 2. Pre-computation of Diagnostics\n    # Number of interior points with backward/forward differences\n    interior_a = a[1:-1]\n    n_back = int(np.sum(interior_a > 0))\n    n_fwd = int(np.sum(interior_a  0))\n\n    # Number of sign-change interfaces in the discrete speed field\n    signs = np.sign(a)\n    n_sign = int(np.sum(signs[:-1] != signs[1:]))\n\n    # 3. Time Step Calculation\n    a_max = np.max(np.abs(a))\n    if a_max == 0:\n        # Avoid division by zero if a(x) is identically zero.\n        # dt can be anything, as nothing will change.\n        dt = 1.0\n    else:\n        dt = lambda_cfl * dx / a_max\n\n    # 4. Time-stepping Loop\n    for _ in range(K):\n        u_old = u.copy()\n        \n        # Apply boundary conditions at the beginning of each step\n        u_old[0] = u_L\n        u_old[N - 1] = u_R\n        \n        # Vectorized update for interior points, can be slow. A loop is clearer and sufficient for these N.\n        for i in range(1, N - 1):\n            a_i = a[i]\n            if a_i > 0:\n                # Backward difference for u_x\n                grad_u = (u_old[i] - u_old[i-1]) / dx\n                u[i] = u_old[i] - dt * a_i * grad_u\n            elif a_i  0:\n                # Forward difference for u_x\n                grad_u = (u_old[i+1] - u_old[i]) / dx\n                u[i] = u_old[i] - dt * a_i * grad_u\n            # If a_i == 0, u[i] remains u_old[i], so no operation needed.\n        \n        # Re-apply boundary conditions to the new solution u\n        u[0] = u_L\n        u[N-1] = u_R\n    \n    # 5. Post-computation of Diagnostics (Maximum Principle)\n    min_bound = min(np.min(u_initial), u_L, u_R)\n    max_bound = max(np.max(u_initial), u_L, u_R)\n    \n    # Use a small tolerance for floating-point comparisons\n    tol = 1e-9\n    mp = bool((np.min(u) >= min_bound - tol) and (np.max(u) = max_bound + tol))\n\n    return [n_back, n_fwd, n_sign, mp]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 51, \"lambda_cfl\": 0.9, \"K\": 25,\n            \"a_func\": lambda x: np.where(x  0.5, 1.0, -0.5),\n            \"u_L\": 0.0, \"u_R\": 1.0,\n            \"u0_func\": lambda x: np.sin(2 * np.pi * x)\n        },\n        {\n            \"N\": 51, \"lambda_cfl\": 0.9, \"K\": 30,\n            \"a_func\": lambda x: x - 0.5,\n            \"u_L\": 0.5, \"u_R\": -0.5,\n            \"u0_func\": lambda x: 1.0 - 2.0 * np.abs(x - 0.5)\n        },\n        {\n            \"N\": 101, \"lambda_cfl\": 0.9, \"K\": 40,\n            \"a_func\": lambda x: np.tanh(20 * (0.7 - x)),\n            \"u_L\": 1.0, \"u_R\": -1.0,\n            \"u0_func\": lambda x: np.cos(4 * np.pi * x)\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = run_simulation(\n            case[\"N\"], case[\"lambda_cfl\"], case[\"K\"],\n            case[\"a_func\"], case[\"u_L\"], case[\"u_R\"], case[\"u0_func\"]\n        )\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    inner_results_str = []\n    for res in all_results:\n        # res is a list like [n_back, n_fwd, n_sign, mp_bool]\n        inner_str = f\"[{res[0]},{res[1]},{res[2]},{str(res[3]).lower()}]\"\n        inner_results_str.append(inner_str)\n    \n    final_output_str = f\"[{','.join(inner_results_str)}]\"\n    print(final_output_str.replace(\"'\", \"\"))\n\nsolve()\n```", "id": "3285398"}, {"introduction": "现实世界中的物理系统很少只涉及单一过程。本实践将我们的模型扩展到包含扩散项，从而得到平流-扩散方程，它描述了从流体中的热量传递到污染物输运等无数现象。您将学习如何将用于平流项的迎风格式与用于扩散项的中心差分格式相结合，并推导出一个组合的稳定性条件。这个练习还引入了佩克莱数（Péclet number），一个关键的无量纲参数，用以量化平流与扩散的相对重要性。[@problem_id:3285468]", "problem": "考虑一个定义在周期性空间域上的线性平流-扩散初值问题，由偏微分方程 $u_t + a\\,u_x = \\nu\\,u_{xx}$ 定义，其中 $x \\in [0,L]$ 且 $t \\ge 0$，具有恒定的平流速度 $a$ 和恒定的扩散系数 $\\nu$。初始条件为 $u(x,0) = \\sin\\!\\left(\\frac{2\\pi m}{L}\\,x\\right)$，其中整数模 $m \\ge 1$，且对于所有 $t \\ge 0$ 均满足周期性边界条件 $u(0,t) = u(L,t)$。所有物理量使用的单位如下：$x$ 的单位是米，$t$ 的单位是秒，$a$ 的单位是米/秒，$\\nu$ 的单位是平方米/秒。输出是无量纲的实数和布尔值，应不带单位。\n\n您的任务是为平流项推导一个显式迎风离散格式，为扩散项推导一个二阶中心离散格式，然后实现该方法以探索由佩克莱数（Péclet number, Pe）定义的区域。具体来说：\n\n1. 从守恒形式和均匀网格上一阶导数的单边有限差分以及二阶导数的中心有限差分的定义出发，在具有周期性索引的均匀网格 $x_j = j\\,\\Delta x$（其中 $j=0,1,\\dots,N-1$）和时间层 $t^n = n\\,\\Delta t$ 上，推导一个全离散的显式时间步进格式。该格式必须对平流项使用根据 $a$ 的符号选择的迎风空间差分，对扩散项使用中心二阶差分。使用前向欧拉时间积分。用依赖于库朗数（Courant number）和扩散数（diffusion number）的系数来表示离散更新，并确定一个基于单调性的充分稳定性条件，以确保所有更新系数均为非负。\n\n2. 使用推导出的离散格式，实现一个程序，对下面列出的每个测试用例，在具有 $N$ 个点的均匀网格上（空间步长 $\\Delta x = L/N$），使用给定的时间步长 $\\Delta t$，将数值解从 $t=0$ 演化到 $t=T$。通过周期性索引实现周期性边界条件。离散解应使用第1部分中的显式格式进行推进。如果最终时间 $T$ 不是 $\\Delta t$ 的整数倍，则使用一个调整后的最终时间步长，以使总模拟时间恰好等于 $T$。\n\n3. 对每个测试用例，计算：\n   - 佩克莱数 $P_e = \\dfrac{a\\,L}{\\nu}$。\n   - 一个布尔标志，指示第1部分中基于单调性的充分稳定性条件对于给定的 $\\Delta t$ 和 $\\Delta x$ 是否成立。\n   - 在时间 $T$ 时，相对于平流-扩散方程在周期性边界条件 $[0,L]$ 上，初始条件为 $u(x,0) = \\sin\\!\\left(\\frac{2\\pi m}{L}\\,x\\right)$ 的精确解的离散 $\\ell^2$ 误差。精确解由以速度 $a$ 的平移和傅里叶模式的指数衰减给出，其函数形式为 $u_{\\text{exact}}(x,T) = \\exp\\!\\big(-\\nu\\,k^2\\,T\\big)\\,\\sin\\!\\big(k\\,(x - a\\,T)\\big)$，其中 $k = \\dfrac{2\\pi m}{L}$。离散 $\\ell^2$ 误差为 $\\left(\\Delta x \\sum_{j=0}^{N-1} \\big(u_j^{n_T} - u_{\\text{exact}}(x_j,T)\\big)^2\\right)^{1/2}$，其中 $n_T$ 表示最终时间层。\n\n4. 使用以下测试套件，该套件探索了不同的佩克莱区域和稳定性边界情况。每个测试用例是一个元组 $(a,\\nu,L,N,\\Delta t,T,m)$，其中 $a$ 的单位是米/秒，$\\nu$ 的单位是平方米/秒，$L$ 的单位是米，$N$ 是网格点数的整数，$\\Delta t$ 的单位是秒，$T$ 的单位是秒，$m$ 是正整数：\n   - 测试 1：$(1.0,\\,0.1,\\,1.0,\\,100,\\,4\\times 10^{-4},\\,2\\times 10^{-2},\\,1)$。\n   - 测试 2：$(0.2,\\,0.5,\\,1.0,\\,100,\\,8\\times 10^{-5},\\,2\\times 10^{-2},\\,1)$。\n   - 测试 3：$(5.0,\\,0.01,\\,1.0,\\,100,\\,1.4\\times 10^{-3},\\,2\\times 10^{-2},\\,1)$。\n   - 测试 4：$(1.0,\\,0.1,\\,1.0,\\,100,\\,\\Delta t^*,\\,2\\times 10^{-2},\\,1)$，其中 $\\Delta t^* = \\left(\\dfrac{a}{\\Delta x} + \\dfrac{2\\,\\nu}{\\Delta x^2}\\right)^{-1}$ 且 $\\Delta x = L/N$。\n   - 测试 5：$(1.0,\\,0.1,\\,1.0,\\,100,\\,6\\times 10^{-4},\\,2\\times 10^{-2},\\,1)$。\n   - 测试 6：$(-1.0,\\,0.05,\\,1.0,\\,100,\\,0.9\\times\\left(\\dfrac{|a|}{\\Delta x} + \\dfrac{2\\,\\nu}{\\Delta x^2}\\right)^{-1},\\,2\\times 10^{-2},\\,1)$，其中 $\\Delta x = L/N$。\n\n5. 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身应是一个包含三个元素的列表，顺序为 $[P_e,\\text{stability\\_flag},\\ell^2\\text{\\_error}]$。例如，输出格式应与 $[[P_{e,1},\\text{flag}_1,\\text{err}_1],[P_{e,2},\\text{flag}_2,\\text{err}_2],\\dots]$ 完全一样。\n\n确保数值的稳健性和科学的真实性。推导必须从均匀网格上的空间有限差分和前向欧拉时间积分的定义开始，不得假设或引用任何预先推导出的离散化或稳定性公式。佩克莱数与所观察到的区域之间的联系应从定义和最终的离散格式中得出。最终输出是无单位的实数和布尔值，表示为基本类型。", "solution": "该问题是有效的。这是一个来自数值分析领域的适定初边值问题，具体涉及偏微分方程的离散化。所有参数都已明确定义，任务具体且可形式化。\n\n以下是根据要求进行的数值格式推导和稳定性分析。\n\n控制偏微分方程(PDE)是线性平流-扩散方程：\n$$ u_t + a\\,u_x = \\nu\\,u_{xx} $$\n其中 $u(x,t)$ 是所关注的量，$a$ 是恒定的平流速度，$\\nu$ 是恒定的扩散系数。空间域为 $x \\in [0,L]$，具有周期性边界条件，时间域为 $t \\ge 0$。\n\n我们在一个均匀的时空网格上离散化该方程。空间网格点为 $x_j = j\\,\\Delta x$，其中 $j=0, 1, \\dots, N-1$，$\\Delta x = L/N$。时间层为 $t^n = n\\,\\Delta t$，其中 $n=0, 1, \\dots$。在 $(x_j, t^n)$ 处的数值解记为 $u_j^n$。\n\n我们使用前向欧拉方法进行时间积分。在 $(x_j, t^n)$ 处的时间导数 $u_t$ 由前向差分近似：\n$$ u_t \\approx \\frac{u_j^{n+1} - u_j^n}{\\Delta t} $$\n将此代入PDE，我们得到一个显式更新格式：\n$$ \\frac{u_j^{n+1} - u_j^n}{\\Delta t} = -a\\,(u_x)_j^n + \\nu\\,(u_{xx})_j^n $$\n$$ u_j^{n+1} = u_j^n - a\\,\\Delta t\\,(u_x)_j^n + \\nu\\,\\Delta t\\,(u_{xx})_j^n $$\n这里，$(u_x)_j^n$ 和 $(u_{xx})_j^n$ 是在时间层 $n$ 的空间差分近似。\n\n扩散项 $\\nu\\,u_{xx}$ 使用标准的二阶中心差分格式进行离散化：\n$$ (u_{xx})_j^n \\approx \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2} $$\n\n平流项 $a\\,u_x$ 使用一阶迎风格式进行离散化。单边差分的选用取决于平流速度 $a$ 的符号，它决定了信息传播的方向。\n1.  如果 $a \\ge 0$，“风”或信息从左向右传播（$x$ 增加）。因此，我们使用后向差分，它使用位于 $x_{j-1}$ 的“迎风”点：\n    $$ (u_x)_j^n \\approx \\frac{u_j^n - u_{j-1}^n}{\\Delta x} \\quad (\\text{对于 } a \\ge 0) $$\n2.  如果 $a  0$，风从右向左传播（$x$ 减少）。我们使用前向差分，它使用位于 $x_{j+1}$ 的“迎风”点：\n    $$ (u_x)_j^n \\approx \\frac{u_{j+1}^n - u_j^n}{\\Delta x} \\quad (\\text{对于 } a  0) $$\n\n我们来为这两种情况构建全离散更新公式。\n\n**情况1：$a \\ge 0$**\n将 $u_x$ 的后向差分和 $u_{xx}$ 的中心差分代入前向欧拉公式：\n$$ u_j^{n+1} = u_j^n - a\\,\\Delta t\\left(\\frac{u_j^n - u_{j-1}^n}{\\Delta x}\\right) + \\nu\\,\\Delta t\\left(\\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2}\\right) $$\n我们按时间层 $n$ 的空间索引对各项进行分组：\n$$ u_j^{n+1} = \\left(\\frac{a\\,\\Delta t}{\\Delta x} + \\frac{\\nu\\,\\Delta t}{(\\Delta x)^2}\\right) u_{j-1}^n + \\left(1 - \\frac{a\\,\\Delta t}{\\Delta x} - \\frac{2\\nu\\,\\Delta t}{(\\Delta x)^2}\\right) u_j^n + \\left(\\frac{\\nu\\,\\Delta t}{(\\Delta x)^2}\\right) u_{j+1}^n $$\n我们定义无量纲的库朗数 $C = \\frac{a\\,\\Delta t}{\\Delta x}$ 和扩散数 $d = \\frac{\\nu\\,\\Delta t}{(\\Delta x)^2}$。由于 $a \\ge 0$，$C$ 是非负的。\n更新格式变为：\n$$ u_j^{n+1} = (C+d) u_{j-1}^n + (1 - C - 2d) u_j^n + d u_{j+1}^n $$\n\n**情况2：$a  0$**\n代入 $u_x$ 的前向差分和 $u_{xx}$ 的中心差分：\n$$ u_j^{n+1} = u_j^n - a\\,\\Delta t\\left(\\frac{u_{j+1}^n - u_j^n}{\\Delta x}\\right) + \\nu\\,\\Delta t\\left(\\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2}\\right) $$\n分组各项：\n$$ u_j^{n+1} = \\left(\\frac{\\nu\\,\\Delta t}{(\\Delta x)^2}\\right) u_{j-1}^n + \\left(1 + \\frac{a\\,\\Delta t}{\\Delta x} - \\frac{2\\nu\\,\\Delta t}{(\\Delta x)^2}\\right) u_j^n + \\left(-\\frac{a\\,\\Delta t}{\\Delta x} + \\frac{\\nu\\,\\Delta t}{(\\Delta x)^2}\\right) u_{j+1}^n $$\n我们根据速度定义库朗数，$C = \\frac{|a|\\,\\Delta t}{\\Delta x} = \\frac{-a\\,\\Delta t}{\\Delta x}$（因为 $a0$），以及扩散数 $d = \\frac{\\nu\\,\\Delta t}{(\\Delta x)^2}$。\n更新格式变为：\n$$ u_j^{n+1} = d u_{j-1}^n + (1 - C - 2d) u_j^n + (C+d) u_{j+1}^n $$\n\n**基于单调性的稳定性条件**\n此显式格式稳定的一个充分条件是它是单调的，这意味着新值 $u_j^{n+1}$ 是旧值的凸组合。这要求乘以 $u_{j-1}^n$、$u_j^n$ 和 $u_{j+1}^n$ 的所有系数都为非负。\n\n在两种情况下（$a \\ge 0$ 和 $a  0$），系数均为 $(C+d)$、$(1-C-2d)$ 和 $d$，其中 $C = \\frac{|a|\\Delta t}{\\Delta x}$ 且 $d = \\frac{\\nu \\Delta t}{(\\Delta x)^2}$。\n- 系数 $d$ 和 $C+d$ 是非负的，因为 $\\Delta t, \\Delta x, \\nu$ 均为非负，且 $C$ 是用 $|a|$ 定义的。\n- $u_j^n$ 的系数的非负性提供了稳定性约束：\n$$ 1 - C - 2d \\ge 0 $$\n代入 $C$ 和 $d$ 的定义：\n$$ 1 - \\frac{|a|\\,\\Delta t}{\\Delta x} - \\frac{2\\nu\\,\\Delta t}{(\\Delta x)^2} \\ge 0 $$\n将 $\\Delta t$ 提取出来：\n$$ 1 \\ge \\Delta t \\left( \\frac{|a|}{\\Delta x} + \\frac{2\\nu}{(\\Delta x)^2} \\right) $$\n这给出了时间步长 $\\Delta t$ 的充分稳定性条件：\n$$ \\Delta t \\le \\frac{1}{\\frac{|a|}{\\Delta x} + \\frac{2\\nu}{(\\Delta x)^2}} $$\n该条件确保了数值格式是单调的，并且根据极值原理是稳定的。它结合了方程的双曲（平流）部分和抛物（扩散）部分的 Courant-Friedrichs-Lewy (CFL) 条件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the advection-diffusion problem for a suite of test cases.\n\n    This function implements an explicit finite difference scheme (upwind for\n    advection, central for diffusion, forward Euler in time) to solve the\n    1D linear advection-diffusion equation on a periodic domain. It then\n    computes the Péclet number, checks a sufficient stability condition, and\n    calculates the L2 error against the exact solution for several test cases.\n    \"\"\"\n\n    # Pre-calculate dt for cases 4 and 6, as they depend on other parameters.\n    # Case 4 parameters: a=1.0, nu=0.1, L=1.0, N=100\n    dx4 = 1.0 / 100\n    dt_star4 = (1.0 / dx4 + 2 * 0.1 / dx4**2)**-1\n\n    # Case 6 parameters: a=-1.0, nu=0.05, L=1.0, N=100\n    dx6 = 1.0 / 100\n    dt_crit6 = (abs(-1.0) / dx6 + 2 * 0.05 / dx6**2)**-1\n    dt6 = 0.9 * dt_crit6\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (a, nu, L, N, dt, T, m)\n    test_cases = [\n        (1.0, 0.1, 1.0, 100, 4e-4, 2e-2, 1),\n        (0.2, 0.5, 1.0, 100, 8e-5, 2e-2, 1),\n        (5.0, 0.01, 1.0, 100, 1.4e-3, 2e-2, 1),\n        (1.0, 0.1, 1.0, 100, dt_star4, 2e-2, 1),\n        (1.0, 0.1, 1.0, 100, 6e-4, 2e-2, 1),\n        (-1.0, 0.05, 1.0, 100, dt6, 2e-2, 1),\n    ]\n\n    results = []\n    for case in test_cases:\n        a, nu, L, N, dt, T, m = case\n        dx = L / N\n\n        # 1. Compute Péclet number\n        # If nu is zero, Pe is infinite. Handle this to avoid division by zero.\n        if nu == 0:\n            Pe = np.inf * np.sign(a) if a != 0 else 0\n        else:\n            Pe = a * L / nu\n\n        # 2. Check the sufficient monotonicity-based stability condition\n        # The condition is dt = 1 / ( |a|/dx + 2*nu/dx^2 )\n        # Rearranged to avoid division by a potentially zero denominator:\n        # dt * ( |a|/dx + 2*nu/dx^2 ) = 1\n        stability_term = abs(a) / dx + 2 * nu / dx**2\n        # Use a small tolerance for floating point comparison\n        is_stable = dt * stability_term = 1.0 + 1e-9\n\n        # 3. Set up the grid and initial condition\n        x = np.linspace(0, L, N, endpoint=False)\n        k = 2 * np.pi * m / L\n        u = np.sin(k * x)\n\n        # 4. Define the time-stepping function\n        def step(u_current, time_step):\n            \"\"\"Applies one step of the finite difference scheme.\"\"\"\n            u_jp1 = np.roll(u_current, -1)\n            u_jm1 = np.roll(u_current, 1)\n\n            # Upwind scheme for advection\n            if a >= 0:\n                advection_term = (a * time_step / dx) * (u_current - u_jm1)\n            else: # a  0\n                advection_term = (a * time_step / dx) * (u_jp1 - u_current)\n            \n            # Central difference for diffusion\n            diffusion_term = (nu * time_step / dx**2) * (u_jp1 - 2 * u_current + u_jm1)\n            \n            return u_current - advection_term + diffusion_term\n\n        # 5. Evolve the solution in time\n        num_full_steps = int(T / dt)\n        \n        for _ in range(num_full_steps):\n            u = step(u, dt)\n        \n        # Adjust for a final partial time step to reach T exactly\n        last_dt = T - num_full_steps * dt\n        if last_dt > 1e-12: # Check to avoid negligible or negative steps\n            u = step(u, last_dt)\n        \n        u_numerical = u\n\n        # 6. Compute the exact solution and the discrete l2 error\n        u_exact = np.exp(-nu * k**2 * T) * np.sin(k * (x - a * T))\n        l2_error = np.sqrt(dx * np.sum((u_numerical - u_exact)**2))\n\n        # 7. Store the results for this test case\n        results.append([Pe, is_stable, l2_error])\n\n    # 8. Format and print the final output string\n    # Build the string manually to match the required format without extra spaces\n    output_parts = []\n    for pe_val, flag_val, err_val in results:\n        # Format the numbers to a reasonable precision for clean output\n        pe_str = f\"{pe_val:.10g}\"\n        flag_str = str(flag_val).lower()\n        err_str = f\"{err_val:.10g}\"\n        output_parts.append(f\"[{pe_str},{flag_str},{err_str}]\")\n    \n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output.replace(\"'\", \"\"))\n\nsolve()\n```", "id": "3285468"}]}