{"hands_on_practices": [{"introduction": "要将Crank-Nicolson方法付诸实践，第一步是将抽象的偏微分方程和离散格式转化为一个具体的、可求解的线性代数系统。这个练习将指导你完成这一关键步骤。通过为一个简单的一维热方程网格构建矩阵 $A$ 和 $B$，你将亲手体验离散化过程的核心，并加深对该方法结构基础的理解。[@problem_id:2139888]", "problem": "考虑一维热方程 $u_t = \\alpha u_{xx}$，其中函数 $u(x, t)$ 定义在空间域 $x \\in [0, L]$ 和时间 $t \\geq 0$ 上。该方程满足齐次狄利克雷边界条件 $u(0, t) = u(L, t) = 0$。\n\n我们希望使用 Crank-Nicolson 方法对此方程进行数值求解。空间域被离散化为一个间距为 $\\Delta x$ 的均匀网格，使得恰好有三个内部网格点。设 $\\Delta t$ 为时间步长。该方法得到一个形如 $A\\mathbf{u}^{n+1} = B\\mathbf{u}^{n}$ 的矩阵系统，其中 $\\mathbf{u}^{k}$ 是在时间步 $k$ 时三个内部网格点上数值解的列向量。\n\n定义参数 $\\lambda$ 为 $\\lambda = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$。\n\n以下哪个选项正确地给出了 $3 \\times 3$ 矩阵 $A$ 和 $B$？\n\nA. $A = \\begin{pmatrix} 1+\\lambda & -\\frac{\\lambda}{2} & 0 \\\\ -\\frac{\\lambda}{2} & 1+\\lambda & -\\frac{\\lambda}{2} \\\\ 0 & -\\frac{\\lambda}{2} & 1+\\lambda \\end{pmatrix}$, $B = \\begin{pmatrix} 1-\\lambda & \\frac{\\lambda}{2} & 0 \\\\ \\frac{\\lambda}{2} & 1-\\lambda & \\frac{\\lambda}{2} \\\\ 0 & \\frac{\\lambda}{2} & 1-\\lambda \\end{pmatrix}$\n\nB. $A = \\begin{pmatrix} 1-\\lambda & \\frac{\\lambda}{2} & 0 \\\\ \\frac{\\lambda}{2} & 1-\\lambda & \\frac{\\lambda}{2} \\\\ 0 & \\frac{\\lambda}{2} & 1-\\lambda \\end{pmatrix}$, $B = \\begin{pmatrix} 1+\\lambda & -\\frac{\\lambda}{2} & 0 \\\\ -\\frac{\\lambda}{2} & 1+\\lambda & -\\frac{\\lambda}{2} \\\\ 0 & -\\frac{\\lambda}{2} & 1+\\lambda \\end{pmatrix}$\n\nC. $A = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}$, $B = \\begin{pmatrix} 1-2\\lambda & \\lambda & 0 \\\\ \\lambda & 1-2\\lambda & \\lambda \\\\ 0 & \\lambda & 1-2\\lambda \\end{pmatrix}$\n\nD. $A = \\begin{pmatrix} 1+2\\lambda & -\\lambda & 0 \\\\ -\\lambda & 1+2\\lambda & -\\lambda \\\\ 0 & -\\lambda & 1+2\\lambda \\end{pmatrix}$, $B = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}$", "solution": "我们将空间区间以均匀间距 $\\Delta x$ 离散化，并记内部索引为 $i=1,2,3$。齐次狄利克雷边界条件要求对所有 $n$ 都有 $u_{0}^{n}=0$ 和 $u_{4}^{n}=0$。\n\n设 $u_{i}^{n}$ 是 $u(x_{i}, t^{n})$ 的近似值。在内部点 $i$ 处，$u_{t}=\\alpha u_{xx}$ 的 Crank-Nicolson 离散格式为\n$$\n\\frac{u_{i}^{n+1}-u_{i}^{n}}{\\Delta t}\n=\\frac{\\alpha}{2}\\left(\\frac{u_{i+1}^{n}-2u_{i}^{n}+u_{i-1}^{n}}{(\\Delta x)^{2}}+\\frac{u_{i+1}^{n+1}-2u_{i}^{n+1}+u_{i-1}^{n+1}}{(\\Delta x)^{2}}\\right).\n$$\n当 $\\lambda=\\frac{\\alpha\\Delta t}{(\\Delta x)^{2}}$ 时，两边同乘以 $\\Delta t$ 可得\n$$\nu_{i}^{n+1}-u_{i}^{n}\n=\\frac{\\lambda}{2}\\left[(u_{i+1}^{n}-2u_{i}^{n}+u_{i-1}^{n})+(u_{i+1}^{n+1}-2u_{i}^{n+1}+u_{i-1}^{n+1})\\right].\n$$\n重新整理，将未知的时间层 $n+1$ 的项收集到左边，时间层 $n$ 的项收集到右边，得到\n$$\n\\left(1+\\lambda\\right)u_{i}^{n+1}-\\frac{\\lambda}{2}u_{i+1}^{n+1}-\\frac{\\lambda}{2}u_{i-1}^{n+1}\n=\\left(1-\\lambda\\right)u_{i}^{n}+\\frac{\\lambda}{2}u_{i+1}^{n}+\\frac{\\lambda}{2}u_{i-1}^{n}.\n$$\n由于边界值为零，没有出现额外的边界项。将这个系统对 $i=1,2,3$ 写成矩阵形式 $A\\mathbf{u}^{n+1}=B\\mathbf{u}^{n}$，其中 $\\mathbf{u}^{k}=(u_{1}^{k},u_{2}^{k},u_{3}^{k})^{T}$，矩阵为\n$$\nA=\\begin{pmatrix}\n1+\\lambda & -\\frac{\\lambda}{2} & 0 \\\\\n-\\frac{\\lambda}{2} & 1+\\lambda & -\\frac{\\lambda}{2} \\\\\n0 & -\\frac{\\lambda}{2} & 1+\\lambda\n\\end{pmatrix},\\quad\nB=\\begin{pmatrix}\n1-\\lambda & \\frac{\\lambda}{2} & 0 \\\\\n\\frac{\\lambda}{2} & 1-\\lambda & \\frac{\\lambda}{2} \\\\\n0 & \\frac{\\lambda}{2} & 1-\\lambda\n\\end{pmatrix}.\n$$\n这与选项 A 一致。", "answer": "$$\\boxed{A}$$", "id": "2139888"}, {"introduction": "Crank-Nicolson方法的一大理论优势是其时间上的二阶精度。但在实践中我们如何验证这一点呢？本练习将引导你设计一个计算实验，通过傅里叶谱方法消除空间误差的干扰，从而精确地测量和验证该方法的时间收敛阶。完成这个练习能让你掌握一种严谨的数值方法验证技术，并对“二阶精度”的含义有更深刻的体会。[@problem_id:3220441]", "problem": "要求您通过计算验证 Crank–Nicolson 方法（Crank–Nicolson (CN) 是时间上的梯形法则）对于线性常系数偏微分方程 (PDE) 的时间二阶精度，同时确保空间离散误差可以忽略不计。工作将在一维周期性域 $[0,2\\pi]$ 上进行，并对空间算子使用 Fourier 谱表示，以便每个 Fourier 模态独立演化，并且对于所选的初始数据，空间微分是精确的。\n\n出发点和基本基础：在周期性域上，一个足够光滑的函数可以展开为 Fourier 级数，并且常系数空间微分算子在 Fourier 基中是对角的。对于任何线性时不变系统 $u_t = \\mathcal{L} u$，其中 $\\mathcal{L}$ 是一个具有常系数的线性空间算子，每个 Fourier 模态振幅 $a_k(t)$ 都满足常微分方程 (ODE) $a_k'(t) = \\lambda_k a_k(t)$，其中 $\\lambda_k$ 是算子 $\\mathcal{L}$ 对应波数 $k$ 的特征值。单个模态的精确解为 $a_k(t) = e^{\\lambda_k t} a_k(0)$。对于具有连续可微右端的 ODE，Crank–Nicolson 时间离散化的局部截断误差为 $\\mathcal{O}(\\Delta t^3)$ 阶，在标准光滑性假设下，这导致时间上的全局误差为 $\\mathcal{O}(\\Delta t^2)$ 阶。\n\n您的任务：\n\n1) 空间模型与对角化。考虑在 $[0,2\\pi]$ 上的以下三个具有周期性边界条件和初始条件 $u(x,0) = e^{\\mathrm{i} k x}$（对于指定的整数模态 $k$）的 PDE：\n   - 扩散方程：$u_t = \\nu u_{xx}$，扩散系数 $\\nu > 0$。\n   - 自由 Schrödinger 方程：$\\mathrm{i} \\psi_t = -\\alpha \\psi_{xx}$，色散系数 $\\alpha > 0$。\n   - 对流扩散方程：$u_t + c u_x = \\nu u_{xx}$，对流速度 $c \\in \\mathbb{R}$ 且扩散系数 $\\nu > 0$。\n\n   在 $[0,2\\pi]$ 上使用 Fourier 级数，为每个 PDE 中的 Fourier 模态 $e^{\\mathrm{i} k x}$ 的振幅 $a_k(t)$ 推导相关的模态 ODE，并确定 $a_k'(t) = \\lambda_k a_k(t)$ 中的模态增长/衰减率 $\\lambda_k$。\n\n2) 时间离散化。将 Crank–Nicolson 时间离散化应用于模态 ODE $a_k'(t) = \\lambda_k a_k(t)$。用前一步 $a_k^n$ 和时间步长 $\\Delta t$ 表示单步更新，并获得单步放大因子关于 $\\lambda_k$ 和 $\\Delta t$ 的闭式公式。使用此公式推进 $M$ 步以在时间 $T$ 处近似 $a_k(T)$。\n\n3) 误差测量与观测阶数。对于每个 PDE，使用时间步长 $\\Delta t = T/M$ 进行时间加密研究，其中加密级别为 $M \\in \\{10,20,40,80,160\\}$。对于每个 $\\Delta t$，计算在时间 $T$ 时的数值振幅，并将其与精确振幅 $e^{\\lambda_k T}$ 进行比较，测量绝对误差 $E(\\Delta t) = \\lvert a_k^{\\text{num}}(T) - e^{\\lambda_k T} \\rvert$。通过最小二乘法将直线拟合到 $(\\log(\\Delta t), \\log(E(\\Delta t)))$ 并取其斜率来估计观测阶数 $p$。如果方法在时间上是二阶的，该斜率应接近 $2$。由于初始条件是在网格上精确表示的单个 Fourier 模态，且空间算子在 Fourier 空间中是对角的，因此该测试的空间离散误差可以忽略不计。\n\n测试套件规范：\n\n- 域：$[0,2\\pi]$，具有周期性边界条件。\n- 所有情况的初始条件：$u(x,0) = e^{\\mathrm{i} k x}$，其中整数 $k$ 如下指定。\n- 加密级别：$M \\in \\{10,20,40,80,160\\}$，使得 $\\Delta t = T/M$。\n- 待测试用例：\n  1) 扩散：$\\nu = 0.5$, $k = 3$, $T = 1.0$。\n  2) 自由 Schrödinger：$\\alpha = 0.7$, $k = 4$, $T = 2.0$。\n  3) 对流扩散：$c = 2.0$, $\\nu = 0.1$, $k = 5$, $T = 1.5$。\n\n答案规范和输出格式：\n\n- 对于每个用例，返回观测阶数 $p$，它是一个浮点数，通过 $\\log(E(\\Delta t))$ 对 $\\log(\\Delta t)$ 的最小二乘斜率计算得出。\n- 您的程序应生成单行输出，其中包含按上述顺序列出的三个观测阶数，四舍五入到三位小数，并格式化为逗号分隔的 Python 风格列表，例如：`[2.000,2.001,1.999]`。\n- 此任务不涉及物理单位。由于选择了域 $[0,2\\pi]$，角度（若有）根据构造以弧度为单位。\n\n您的最终交付物必须是一个完整、可运行的程序，该程序能为上述测试套件精确执行这些计算，并以所需的单行格式打印结果。不允许用户输入或外部文件。仅使用指定的库。", "solution": "问题陈述已经过验证，被认为是合理、适定和完整的。我们现在开始解答。这个问题的核心是，为几个线性偏微分方程 (PDE) 计算验证 Crank-Nicolson 方法的二阶时间精度。问题的结构设计旨在消除空间离散误差，从而可以纯粹地评估时间误差。这是通过使用单个 Fourier 模态作为初始条件来实现的，该模态是所涉及的常系数线性空间算子的特征函数。\n\n**1. 模态分析与特征值推导**\n\n我们考虑在周期性域 $[0, 2\\pi]$ 上，对于一个整数波数 $k$，形式为 $u(x,t) = a_k(t) e^{\\mathrm{i} k x}$ 的解。初始条件 $u(x,0) = e^{\\mathrm{i} k x}$ 意味着第 $k$ 个模态的初始振幅为 $a_k(0) = 1$，而所有其他模态振幅均为零。由于控制性 PDE 是线性的，各模态独立演化。我们可以通过将解的形式代入每个 PDE 来分析单个非零模态 $a_k(t)$ 的演化。\n\n空间导数为：\n$$\n\\frac{\\partial u}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( a_k(t) e^{\\mathrm{i} k x} \\right) = \\mathrm{i} k a_k(t) e^{\\mathrm{i} k x}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial x^2} = \\frac{\\partial^2}{\\partial x^2} \\left( a_k(t) e^{\\mathrm{i} k x} \\right) = (\\mathrm{i} k)^2 a_k(t) e^{\\mathrm{i} k x} = -k^2 a_k(t) e^{\\mathrm{i} k x}\n$$\n时间导数为 $\\frac{\\partial u}{\\partial t} = a_k'(t) e^{\\mathrm{i} k x}$。\n\n对于每个形式为 $u_t = \\mathcal{L}u$ 的 PDE，代入模态形式可得 $a_k'(t) e^{\\mathrm{i} k x} = \\mathcal{L}(a_k(t) e^{\\mathrm{i} k x}) = a_k(t) \\mathcal{L}(e^{\\mathrm{i} k x})$。由于 $e^{\\mathrm{i} k x}$ 是空间算子 $\\mathcal{L}$ 的一个特征函数，我们有 $\\mathcal{L}(e^{\\mathrm{i} k x}) = \\lambda_k e^{\\mathrm{i} k x}$，其中 $\\lambda_k$ 是特征值。这将 PDE 简化为关于振幅 $a_k(t)$ 的线性常微分方程 (ODE)：\n$$\na_k'(t) = \\lambda_k a_k(t)\n$$\n该 ODE 在初始条件 $a_k(0)=1$ 下的精确解为 $a_k(t) = e^{\\lambda_k t}$。\n\n我们现在为每个指定的 PDE 确定 $\\lambda_k$。\n\n- **扩散方程**：$u_t = \\nu u_{xx}$\n  $a_k'(t) e^{\\mathrm{i} k x} = \\nu (-k^2 a_k(t) e^{\\mathrm{i} k x})$。两边同除以 $e^{\\mathrm{i} k x}$ 得到 $a_k'(t) = (-\\nu k^2) a_k(t)$。\n  因此，特征值为 $\\lambda_k = -\\nu k^2$。\n\n- **自由 Schrödinger 方程**：$\\mathrm{i} \\psi_t = -\\alpha \\psi_{xx}$。设解为 $\\psi(x,t) = a_k(t) e^{\\mathrm{i} k x}$。\n  该方程等价于 $\\psi_t = \\frac{-\\alpha}{\\mathrm{i}} \\psi_{xx} = \\mathrm{i} \\alpha \\psi_{xx}$。\n  $a_k'(t) e^{\\mathrm{i} k x} = \\mathrm{i} \\alpha (-k^2 a_k(t) e^{\\mathrm{i} k x})$。这得到 $a_k'(t) = (-\\mathrm{i} \\alpha k^2) a_k(t)$。\n  因此，特征值为 $\\lambda_k = -\\mathrm{i} \\alpha k^2$。\n  （注：问题陈述为 $\\mathrm{i} \\psi_t = -\\alpha \\psi_{xx}$。代入可得 $\\mathrm{i} a_k' = -\\alpha (-k^2) a_k = \\alpha k^2 a_k$，因此 $a_k' = \\frac{\\alpha k^2}{\\mathrm{i}} a_k = -\\mathrm{i} \\alpha k^2 a_k$。结果是相同的）。\n\n- **对流扩散方程**：$u_t + c u_x = \\nu u_{xx}$，或 $u_t = -c u_x + \\nu u_{xx}$。\n  $a_k'(t) e^{\\mathrm{i} k x} = -c (\\mathrm{i} k a_k(t) e^{\\mathrm{i} k x}) + \\nu (-k^2 a_k(t) e^{\\mathrm{i} k x})$。\n  这得到 $a_k'(t) = (-\\mathrm{i} c k - \\nu k^2) a_k(t)$。\n  因此，特征值为 $\\lambda_k = -\\nu k^2 - \\mathrm{i} c k$。\n\n**2. Crank-Nicolson 时间离散化**\n\nCrank-Nicolson 方法是一种用于积分 ODE 的隐式方法，等价于梯形法则。对于 ODE $a' = \\lambda a$，在从 $t_n$ 到 $t_{n+1}$ 的一个时间步长 $\\Delta t$ 上的离散化是：\n$$\n\\frac{a^{n+1} - a^n}{\\Delta t} = \\frac{1}{2} \\left( \\lambda a^{n+1} + \\lambda a^n \\right)\n$$\n其中 $a^n \\approx a(t_n)$。我们求解 $a^{n+1}$：\n$$\na^{n+1} \\left( 1 - \\frac{\\lambda \\Delta t}{2} \\right) = a^n \\left( 1 + \\frac{\\lambda \\Delta t}{2} \\right)\n$$\n这给出了单步的显式更新公式：\n$$\na^{n+1} = \\left( \\frac{1 + \\lambda \\Delta t / 2}{1 - \\lambda \\Delta t / 2} \\right) a^n\n$$\n项 $G(\\lambda, \\Delta t) = \\frac{1 + \\lambda \\Delta t / 2}{1 - \\lambda \\Delta t / 2}$ 是单步放大因子。为了在 $M$ 步内从时间 $t=0$ 推进到 $T = M \\Delta t$，我们将此因子应用 $M$ 次。设 $a^0 = a_k(0) = 1$，则在时间 $T$ 的数值解为：\n$$\na_k^{\\text{num}}(T) = a^M = (G(\\lambda_k, \\Delta t))^M a^0 = \\left( \\frac{1 + \\lambda_k \\Delta t / 2}{1 - \\lambda_k \\Delta t / 2} \\right)^M\n$$\n\n**3. 误差分析与观测精度阶数**\n\n该方法的全局误差预计在时间上是二阶的，这意味着在固定时间 $T$ 的误差 $E(\\Delta t)$ 的行为类似于 $E(\\Delta t) \\approx C (\\Delta t)^p$，其中 $C$ 是某个常数，阶数 $p \\approx 2$。绝对误差定义为：\n$$\nE(\\Delta t) = \\lvert a_k^{\\text{num}}(T) - a_k(T) \\rvert = \\left| \\left( \\frac{1 + \\lambda_k \\Delta t / 2}{1 - \\lambda_k \\Delta t / 2} \\right)^M - e^{\\lambda_k T} \\right|\n$$\n为了确定观测阶数 $p$，我们对误差关系取对数：\n$$\n\\log(E(\\Delta t)) \\approx \\log(C) + p \\log(\\Delta t)\n$$\n这显示了 $\\log(E)$ 和 $\\log(\\Delta t)$ 之间的线性关系，其斜率即为精度阶数 $p$。我们将为一系列时间步长 $\\Delta t_i = T/M_i$（其中 $M_i \\in \\{10, 20, 40, 80, 160\\}$）计算误差。然后，我们对数据点 $(\\log(\\Delta t_i), \\log(E_i))$ 进行线性最小二乘拟合，以找到斜率 $p$。\n\n每个测试用例的计算过程如下：\n1.  使用给定参数计算特征值 $\\lambda_k$。\n2.  定义加密级别集合 $M_i$。\n3.  对于每个 $M_i$，计算时间步长 $\\Delta t_i = T/M_i$。\n4.  计算数值解 $a_k^{\\text{num}}(T) = \\left( \\frac{1 + \\lambda_k \\Delta t_i / 2}{1 - \\lambda_k \\Delta t_i / 2} \\right)^{M_i}$。\n5.  计算精确解 $a_k(T) = e^{\\lambda_k T}$。\n6.  计算绝对误差 $E_i = |a_k^{\\text{num}}(T) - a_k(T)|$。\n7.  构造两个向量：$x = [\\log(\\Delta t_i)]$ 和 $y = [\\log(E_i)]$。\n8.  计算 $(x, y)$ 的最佳拟合线的斜率 $p$，即为观测阶数。这将使用 `numpy.polyfit` 来完成。\n将为三个指定用例执行计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_observed_order(lambda_k, T, M_levels):\n    \"\"\"\n    Computes the observed order of accuracy for the Crank-Nicolson method.\n\n    Args:\n        lambda_k (complex): The eigenvalue of the spatial operator for mode k.\n        T (float): The final time for the simulation.\n        M_levels (np.ndarray): An array of integers representing the number of time steps.\n\n    Returns:\n        float: The observed order of accuracy, p.\n    \"\"\"\n    delta_ts = T / M_levels\n    errors = np.zeros_like(delta_ts, dtype=float)\n\n    # Calculate the exact solution at time T\n    exact_solution = np.exp(lambda_k * T)\n\n    for i, M in enumerate(M_levels):\n        dt = delta_ts[i]\n        \n        # Calculate the one-step amplification factor\n        z = lambda_k * dt / 2.0\n        amplification_factor = (1.0 + z) / (1.0 - z)\n        \n        # Compute the numerical solution at time T\n        # Initial condition a_k(0) = 1 is implicit\n        numerical_solution = amplification_factor**M\n        \n        # Compute the absolute error\n        errors[i] = np.abs(numerical_solution - exact_solution)\n\n    # Perform a least-squares fit on the log-log data to find the slope\n    log_delta_ts = np.log(delta_ts)\n    log_errors = np.log(errors)\n    \n    # np.polyfit returns [slope, intercept] for degree 1\n    p, _ = np.polyfit(log_delta_ts, log_errors, 1)\n    \n    return p\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Refinement levels for the temporal grid\n    M_levels = np.array([10, 20, 40, 80, 160])\n    \n    # --- Test Case 1: Diffusion Equation ---\n    # u_t = nu * u_xx\n    # Parameters: nu = 0.5, k = 3, T = 1.0\n    nu1 = 0.5\n    k1 = 3\n    T1 = 1.0\n    # Eigenvalue: lambda_k = -nu * k^2\n    lambda_k1 = -nu1 * k1**2\n    p1 = calculate_observed_order(lambda_k1, T1, M_levels)\n\n    # --- Test Case 2: Free Schrödinger Equation ---\n    # i * psi_t = -alpha * psi_xx  =>  psi_t = -i * alpha * psi_xx\n    # Parameters: alpha = 0.7, k = 4, T = 2.0\n    alpha2 = 0.7\n    k2 = 4\n    T2 = 2.0\n    # Eigenvalue: lambda_k = -i * alpha * k^2\n    lambda_k2 = -1j * alpha2 * k2**2\n    p2 = calculate_observed_order(lambda_k2, T2, M_levels)\n\n    # --- Test Case 3: Advection-Diffusion Equation ---\n    # u_t + c * u_x = nu * u_xx  => u_t = -c * u_x + nu * u_xx\n    # Parameters: c = 2.0, nu = 0.1, k = 5, T = 1.5\n    c3 = 2.0\n    nu3 = 0.1\n    k3 = 5\n    T3 = 1.5\n    # Eigenvalue: lambda_k = -nu * k^2 - i * c * k\n    lambda_k3 = -nu3 * k3**2 - 1j * c3 * k3\n    p3 = calculate_observed_order(lambda_k3, T3, M_levels)\n\n    results = [p1, p2, p3]\n\n    # Format the output as a list of strings with 3 decimal places\n    formatted_results = [f'{p:.3f}' for p in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3220441"}, {"introduction": "一个数值方法即使在理论上是稳定和高精度的，也可能存在实践中的陷阱。Crank-Nicolson方法的一个著名特点是，尽管它无条件稳定，但在处理非光滑初始条件（如阶跃函数）时会产生非物理的数值振荡。这个编程练习不仅要求你实现该方法，更挑战你设计一个实验来主动激发并量化这种振荡，从而培养你对数值方法实际性能的批判性分析能力。[@problem_id:3220540]", "problem": "考虑定义在有限区间上、具有齐次狄利克雷边界条件的一维热方程。令 $u(x,t)$ 满足方程 $u_t = \\nu u_{xx}$（其中 $x \\in (0,1)$, $t \\ge 0$），边界条件为 $u(0,t) = 0$, $u(1,t) = 0$，以及一个仅取 $0$ 或 $1$ 值的不连续初始条件 $u(x,0) = u_0(x)$。目标是使用 Crank-Nicolson 方法，在较大时间步长下刻意地生成并分析由不连续性引起的非物理振荡。\n\n从该偏微分方程以及时间一阶导数和空间二阶导数的标准定义出发，完成以下任务：\n\n1) 将空间域离散化为 $M$ 个内部点，均匀间距为 $\\Delta x = 1/(M+1)$，并使用内部网格上的中心有限差分算子来近似二阶导数。在时间上使用时间步长为 $\\Delta t > 0$ 的梯形法则（Crank-Nicolson 法则），以获得一个在每个时间步将 $u^n$推进到 $u^{n+1}$ 的线性系统。定义无量纲参数 $\\mu = \\nu \\Delta t / \\Delta x^2$。\n\n2) 在离散网格上设计一个不连续的初始条件 $u^0$，它是一个具有单个跳跃间断的二值向量（值为 $0$ 或 $1$），使得 Crank-Nicolson 方法在单个时间步后产生的非物理振荡的振幅最大化。设计空间被限制为离散 Heaviside 阶跃函数族，其形式为\n- $u_i^0 = 1$（对于 $i \\le m$）和 $u_i^0 = 0$（对于 $i > m$），其中 $i \\in \\{1,2,\\dots,M\\}$ 是内部点的索引，$m \\in \\{1,2,\\dots,M-1\\}$。\n您的任务是选择 $m$（即阶跃的位置），以在给定 $M$ 的情况下最大化振荡伪影。您的解答中必须从第一性原理出发对该选择进行论证，但您的程序必须实现一个体现您论证的、固定的单一设计。\n\n3) 使用离散化产生的三对角系统来实现 Crank-Nicolson 时间步，并在 $x=0$ 和 $x=1$ 处施加齐次狄利克雷边界条件。将解从您设计的初始条件 $u^0$ 推进恰好一个时间步，以获得下面定义的每个测试用例的 $u^1$。\n\n4) 使用从 $u^1$ 计算出的以下两个标量来量化非物理振荡：\n- 下冲幅度 $U = \\max(0,\\,-\\min_i u_i^1)$。\n- 上冲幅度 $O = \\max(0,\\,\\max_i u_i^1 - 1)$。\n这些值必须是非负实数。\n\n对所有测试使用以下固定参数：\n- $\\nu = 1$。\n- $M = 400$ 个内部点。\n- 网格是区间 $[0,1]$ 均匀划分的 $M$ 个内部点。\n- 对每个参数集，使用恰好一个时间步，并从 $u^0$ 计算 $u^1$。\n\n测试套件（改变无量纲时间步长 $\\mu$）：\n- 案例 A（亚阈值，预期振荡很小或没有振荡）：$\\mu = 0.2$。\n- 案例 B（略高于阈值，预期有可见振荡）：$\\mu = 0.6$。\n- 案例 C（高度刚性，预期有强烈振荡）：$\\mu = 5.0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个案例，按顺序输出下冲和上冲值，因此最终输出必须是展开列表 $[U_A, O_A, U_B, O_B, U_C, O_C]$。\n\n所有数值均为无量纲；无需进行物理单位转换。不涉及角度。不涉及百分比；任何分数量必须表示为小数值。结果列表中的元素必须打印为实数（浮点数）。", "solution": "该问题要求分析将 Crank-Nicolson 方法应用于具有不连续初始条件的一维热方程时产生的非物理振蕩。解决方案涉及推导数值格式、设计一个能最大化振荡伪影的初始条件、实现该格式进行单步时间推进，并量化由此产生的下冲和上冲。\n\n### 步骤 1：离散化与 Crank-Nicolson 格式\n\n控制偏微分方程 (PDE) 是热方程：\n$$\n\\frac{\\partial u}{\\partial t} = \\nu \\frac{\\partial^2 u}{\\partial x^2}\n$$\n定义域为 $x \\in (0, 1)$ 和 $t \\ge 0$，扩散系数为 $\\nu$。边界条件为齐次狄利克雷条件：\n$$\nu(0, t) = 0, \\quad u(1, t) = 0 \\quad \\text{for } t \\ge 0.\n$$\n空间域 $(0, 1)$ 被离散化为 $M$ 个内部点 $x_i = i \\Delta x$，$i = 1, 2, \\dots, M$，其中网格间距为 $\\Delta x = 1/(M+1)$。边界点为 $x_0 = 0$ 和 $x_{M+1} = 1$。令 $u_i(t)$ 为 $u(x_i, t)$ 的近似值。\n\n内部点 $x_i$ 处的空间二阶导数使用二阶中心差分公式近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x=x_i} \\approx \\frac{u_{i+1}(t) - 2u_i(t) + u_{i-1}(t)}{\\Delta x^2}\n$$\n将此应用于 PDE，得到一个常微分方程组 (ODEs)，每个内部点对应一个方程：\n$$\n\\frac{du_i}{dt} = \\frac{\\nu}{\\Delta x^2} (u_{i-1} - 2u_i + u_{i+1})\n$$\n\nCrank-Nicolson 方法应用梯形法则进行时间积分。令 $u_i^n$ 为时间 $t_n = n \\Delta t$ 时 $u(x_i, t_n)$ 的近似值。时间导数近似为 $(u_i^{n+1} - u_i^n) / \\Delta t$。空间导数项在时间 $t_n$ 和 $t_{n+1}$ 之间取平均：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\frac{\\nu}{2} \\left[ \\left(\\frac{u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}}{\\Delta x^2}\\right) + \\left(\\frac{u_{i+1}^{n} - 2u_i^{n} + u_{i-1}^{n}}{\\Delta x^2}\\right) \\right]\n$$\n引入无量纲参数 $\\mu = \\nu \\Delta t / \\Delta x^2$，我们可以重新整理方程，将时间步 $n+1$ 的项（未知数）和时间步 $n$ 的项（已知数）分开：\n$$\nu_i^{n+1} - \\frac{\\mu}{2}(u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}) = u_i^n + \\frac{\\mu}{2}(u_{i-1}^n - 2u_i^n + u_{i+1}^n)\n$$\n对每个网格点 $i = 1, \\dots, M$ 收集项：\n$$\n-\\frac{\\mu}{2}u_{i-1}^{n+1} + (1+\\mu)u_i^{n+1} - \\frac{\\mu}{2}u_{i+1}^{n+1} = \\frac{\\mu}{2}u_{i-1}^n + (1-\\mu)u_i^n + \\frac{\\mu}{2}u_{i+1}^n\n$$\n边界条件 $u_0^n = u_0^{n+1} = 0$ 和 $u_{M+1}^n = u_{M+1}^{n+1} = 0$ 在 $i=1$ 和 $i=M$ 处被纳入。\n这可以写成一个线性方程组 $A \\mathbf{u}^{n+1} = B \\mathbf{u}^n$，其中 $\\mathbf{u}^n = [u_1^n, u_2^n, \\dots, u_M^n]^T$ 是时间 $t_n$ 处的解向量。矩阵 $A$ 和 $B$ 是 $M \\times M$ 的三对角矩阵：\n$$\nA = \\begin{pmatrix}\n1+\\mu & -\\frac{\\mu}{2} & &  \\\\\n-\\frac{\\mu}{2} & 1+\\mu & -\\frac{\\mu}{2} &  \\\\\n & \\ddots & \\ddots & \\ddots \\\\\n & & -\\frac{\\mu}{2} & 1+\\mu & -\\frac{\\mu}{2} \\\\\n & & & -\\frac{\\mu}{2} & 1+\\mu\n\\end{pmatrix}\n$$\n$$\nB = \\begin{pmatrix}\n1-\\mu & \\frac{\\mu}{2} & &  \\\\\n\\frac{\\mu}{2} & 1-\\mu & \\frac{\\mu}{2} &  \\\\\n & \\ddots & \\ddots & \\ddots \\\\\n & & \\frac{\\mu}{2} & 1-\\mu & \\frac{\\mu}{2} \\\\\n & & & \\frac{\\mu}{2} & 1-\\mu\n\\end{pmatrix}\n$$\n为了将解从 $\\mathbf{u}^0$ 推进到 $\\mathbf{u}^1$，我们首先计算右端向量 $\\mathbf{d} = B \\mathbf{u}^0$，然后求解线性系统 $A \\mathbf{u}^1 = \\mathbf{d}$。\n\n### 步骤 2：初始条件的设计\n\n问题要求设计一个离散的 Heaviside 初始条件 $\\mathbf{u}^0$，以最大化一步时间推进后产生的非物理振荡。其形式被指定为 $u_i^0 = 1$（对于 $i \\le m$）和 $u_i^0 = 0$（对于 $i > m$），其中 $m \\in \\{1, \\dots, M-1\\}$。\n\nCrank-Nicolson 方法对于所有 $\\mu > 0$ 都是 $L_2$-稳定的，但它并非沒有伪振荡，特别是在初始数据不光滑和 $\\mu$ 较大时。离散拉普拉斯算子的第 $k$ 个特征模 $\\phi_k(i) = \\sin(k \\pi x_i)$ 的放大因子由下式给出：\n$$\ng_k = \\frac{1 - 2\\mu \\sin^2(k\\pi\\Delta x/2)}{1 + 2\\mu \\sin^2(k\\pi\\Delta x/2)}\n$$\n对于较大的 $\\mu$，高频模式（大 $k$）的放大因子 $g_k$ 趋近于 $-1$。这意味着初始条件中的高频分量不会被衰减，而是被反相并持续存在，从而引起振荡。最高频率模式（$k=M$）对应于棋盘状的模式。\n\n阶跃间断富含高频分量。为了最大化 $\\mathbf{u}^1 = A^{-1}B\\mathbf{u}^0$ 中产生的振荡，我们应将此间断放置在其与格式动力学相互作用最显著且受边界阻尼影响最小的位置。齐次狄利克雷边界条件在定义域两端强制 $u=0$，这对振荡行为具有局部衰减效应。为了以其最不受抑制的形式观察数值伪影，间断点应尽可能远离两个边界。\n\n空间域的中心 $x=0.5$ 是距离 $x=0$ 和 $x=1$ 两端最远的点。在我们包含 $M$ 个内部点的离散网格上，这对应于索引 $\\{1, \\dots, M\\}$ 的中点。对于 $M=400$，中点位于索引 $i=200$ 和 $i=201$ 之間。因此，将跳跃设置在此位置可以最大化其与边界影响的“距离”。\n\n所选择的设计是将间断设置在点 $i=200$ 和 $i=201$ 之间。这对应于选择 $m=M/2=200$。\n因此，初始条件向量 $\\mathbf{u}^0$ 定义为：\n$$\nu_i^0 = \\begin{cases} 1 & \\text{if } 1 \\le i \\le 200 \\\\ 0 & \\text{if } 201 \\le i \\le 400 \\end{cases}\n$$\n这种布局确保了由阶跃引入的高频内容在定义域内部对称地被最大程度激发，从而导致格式产生最强的振荡响应。\n\n### 步骤 3：单时间步的实现\n\n给定 $\\mathbf{u}^0$ 和 $\\mu$，我们通过求解 $A\\mathbf{u}^1 = \\mathbf{d}$ 来计算 $\\mathbf{u}^1$，其中 $\\mathbf{d} = B \\mathbf{u}^0$。\n\n1.  **构造 $\\mathbf{d}$**：分量 $d_i$ 使用 $B$ 作用于 $\\mathbf{u}^0$ 的公式计算。\n    $$ d_i = \\frac{\\mu}{2}u_{i-1}^0 + (1-\\mu)u_i^0 + \\frac{\\mu}{2}u_{i+1}^0 $$\n    边界条件为 $u_0^0=0$ 和 $u_{M+1}^0=0$。由于 $\\mathbf{u}^0$ 的阶跃形式，$\\mathbf{d}$ 的大多数元素将是常数，非平凡值仅出现在 $i=m=200$ 的跳跃点附近。具体来说：\n    - 对于 $i < 200$：$d_i = \\frac{\\mu}{2}(1) + (1-\\mu)(1) + \\frac{\\mu}{2}(1) = 1$。\n    - 对于 $i = 200$：$d_{200} = \\frac{\\mu}{2}(1) + (1-\\mu)(1) + \\frac{\\mu}{2}(0) = 1-\\frac{\\mu}{2}$。\n    - 对于 $i = 201$：$d_{201} = \\frac{\\mu}{2}(1) + (1-\\mu)(0) + \\frac{\\mu}{2}(0) = \\frac{\\mu}{2}$。\n    - 对于 $i > 201$：$d_i = \\frac{\\mu}{2}(0) + (1-\\mu)(0) + \\frac{\\mu}{2}(0) = 0$。\n    （对于 $i=1$ 且 $u_0^0=0$ 的情况需要特殊处理，但由于 $u_1^0=1$， $d_1$ 仍然是 $1$。）\n\n2.  **求解 $A\\mathbf{u}^1 = \\mathbf{d}$**：矩阵 $A$ 是一个对称正定三对角矩阵。求解此类系统的最有效方法是 Thomas 算法（一种针对三对角系统的高斯消元法的特例）。该算法具有线性时间复杂度 $\\mathcal{O}(M)$，并且对于此类矩阵是数值稳定的。该算法包括一个用于修改矩阵系数和右端项的前向消元过程，以及一个用于求解向量 $\\mathbf{u}^1$ 的后向代入过程。\n\n### 步骤 4：量化振荡\n\n在为测试套件中的每个 $\\mu$ 值计算出解向量 $\\mathbf{u}^1$ 后，我们使用指定的度量标准来量化非物理振荡。初始状态有界，即 $0 \\le u_i^0 \\le 1$。根据极值原理，热方程的精确解也应保持在这些界限内。$\\mathbf{u}^1$ 中任何超出区间 $[0, 1]$ 的值都是数值伪影。\n\n-   **下冲 ($U$)**：任何低于物理最小值 $0$ 的值的最大幅度。\n    $$ U = \\max(0, -\\min_i u_i^1) $$\n-   **上冲 ($O$)**：任何超过物理最大值 $1$ 的值的最大幅度。\n    $$ O = \\max(0, \\max_i u_i^1 - 1) $$\n\n我们将为对应于 $\\mu = 0.2, 0.6, 5.0$ 的三个测试用例（A, B, C）分别计算这两个标量。预期结果是，随着 $\\mu$ 的增加，$U$ 和 $O$ 的值也将增加，反映出更剧烈的振荡。对于 $\\mu  0.5$，振荡通常很小或不存在。对于 $\\mu > 0.5$，振荡变得明显。对于大的 $\\mu$，振荡则非常显著。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef thomas_solver(a, b, c, d):\n    \"\"\"\n    Solves a tridiagonal system of equations Ax = d using the Thomas algorithm.\n    a: sub-diagonal vector (length n-1)\n    b: main diagonal vector (length n)\n    c: super-diagonal vector (length n-1)\n    d: right-hand side vector (length n)\n    \"\"\"\n    n = len(d)\n    if n == 0:\n        return np.array([])\n    if n == 1:\n        return np.array([d[0] / b[0]])\n\n    # Create copies to avoid modifying input arrays\n    c_prime = np.zeros(n)\n    d_prime = np.zeros(n)\n    x = np.zeros(n)\n\n    # Forward elimination\n    c_prime[0] = c[0] / b[0]\n    d_prime[0] = d[0] / b[0]\n    for i in range(1, n - 1):\n        denominator = b[i] - a[i - 1] * c_prime[i - 1]\n        c_prime[i] = c[i] / denominator\n        d_prime[i] = (d[i] - a[i - 1] * d_prime[i - 1]) / denominator\n    \n    # Last element of d_prime\n    denominator = b[n - 1] - a[n - 2] * c_prime[n - 2]\n    d_prime[n-1] = (d[n - 1] - a[n - 2] * d_prime[n - 2]) / denominator\n\n    # Backward substitution\n    x[n - 1] = d_prime[n - 1]\n    for i in range(n - 2, -1, -1):\n        x[i] = d_prime[i] - c_prime[i] * x[i + 1]\n\n    return x\n\ndef run_crank_nicolson_step(M, mu):\n    \"\"\"\n    Performs one step of the Crank-Nicolson method for the 1D heat equation.\n    \n    Args:\n        M (int): Number of interior grid points.\n        mu (float): Nondimensional parameter nu * dt / dx^2.\n        \n    Returns:\n        tuple: (undershoot, overshoot)\n    \"\"\"\n    # 1. Design the initial condition u0\n    # The jump is placed at the center of the grid to maximize oscillations.\n    m = M // 2\n    u0 = np.zeros(M)\n    # Python's slicing u0[:m] modifies indices 0 to m-1, which corresponds\n    # to grid points i=1 to m. For m=200, this is points 1 to 200.\n    u0[:m] = 1.0\n\n    # 2. Construct the right-hand side vector d = B * u0\n    d = np.zeros(M)\n    \n    # General interior points using vectorization\n    if M > 2:\n        d[1:-1] = (mu / 2) * u0[:-2] + (1 - mu) * u0[1:-1] + (mu / 2) * u0[2:]\n\n    # Boundary points (incorporating u_(-1) = 0 and u_(M) = 0)\n    # Using 0-based indexing for arrays u0[0]...u0[M-1]\n    # For i=1 (index 0): d[0] = (mu/2)*u_0 + (1-mu)*u_1 + (mu/2)*u_2\n    # with u_0=0 => d[0] = (1-mu)*u_1 + (mu/2)*u_2\n    if M > 0:\n        d[0] = (1 - mu) * u0[0] + (mu / 2) * (u0[1] if M > 1 else 0)\n    \n    # For i=M (index M-1): d[M-1] = (mu/2)*u_{M-1} + (1-mu)*u_M + (mu/2)*u_{M+1}\n    # with u_{M+1}=0 => d[M-1] = (mu/2)*u_{M-1} + (1-mu)*u_M\n    if M > 1:\n        d[M - 1] = (mu / 2) * u0[M - 2] + (1 - mu) * u0[M - 1]\n\n    # 3. Define the tridiagonal matrix A and solve A * u1 = d\n    # A = tridiag(-mu/2, 1+mu, -mu/2)\n    sub_diag_a = np.full(M - 1, -mu / 2)\n    main_diag_b = np.full(M, 1 + mu)\n    super_diag_c = np.full(M - 1, -mu / 2)\n\n    u1 = thomas_solver(sub_diag_a, main_diag_b, super_diag_c, d)\n\n    # 4. Quantify oscillations\n    undershoot = max(0.0, -np.min(u1)) if u1.size > 0 else 0.0\n    overshoot = max(0.0, np.max(u1) - 1.0) if u1.size > 0 else 0.0\n    \n    return undershoot, overshoot\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Fixed parameters from the problem statement\n    M = 400\n    \n    # Test cases for the nondimensional time step mu\n    test_cases = [\n        0.2,  # Case A: subthreshold\n        0.6,  # Case B: just above threshold\n        5.0,  # Case C: highly stiff\n    ]\n\n    results = []\n    for mu in test_cases:\n        U, O = run_crank_nicolson_step(M=M, mu=mu)\n        results.append(U)\n        results.append(O)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.8f}' for x in results)}]\")\n\nsolve()\n```", "id": "3220540"}]}