{"hands_on_practices": [{"introduction": "我们从最基本的一维线性平流方程 $u_t + a u_x = 0$ 开始。这个练习将引导你实现一个“迎风格式”方案，它是一种必须考虑信息传播方向的数值方法。通过这个实践，你将深刻理解双曲型方程的一个核心特征：解的传播特性，以及数值格式必须如何设计才能正确地捕捉这种物理行为。[@problem_id:3229222]", "problem": "考虑在周期性空间域 $x \\in [0,1)$ 上的线性一阶平流方程 $u_t + a\\,u_x = 0$，其初始剖面是光滑、局部化且无量纲的。二阶波动方程 $u_{tt} = c^2\\,u_{xx}$ 允许使用 D'Alembert 表示法 $u(x,t) = f(x - c t) + g(x + c t)$，这可以解释为两个一阶平流方程解的叠加，这两个解分别以速度 $a = +c$ 和 $a = -c$ 传播。在本问题中，您将通过算法模拟负速和正速下的平流过程，并根据波动方程的左行和右行分量来解释所产生的传播方向。\n\n从基本原理出发，使用周期性域 $[0,1)$ 和以下无量纲初始条件：\n$$\nu(x,0) \\equiv u_0(x) = \\exp\\!\\big(-50\\,d(x)^2\\big),\\quad d(x) = \\left[(x - 0.5) - \\mathrm{round}(x - 0.5)\\right],\n$$\n其中 $\\mathrm{round}(\\cdot)$ 将实数映射到最近的整数，因此 $d(x)$ 是到 $0.5$ 的最小周期距离。这会产生一个以 $x=0.5$ 为中心、具有周期性延拓的光滑、局部化“凸起”。\n\n您的任务是：\n- 从适用于双曲守恒律和特征线法的基本原理出发，推导一种为 $u_t + a\\,u_x = 0$ 定制的一阶精度、单调的迎风有限差分法，该方法需满足在 $[0,1)$ 上的周期性边界条件。该离散化方法必须根据 $a$ 的符号选择正确的空间差分方向，并满足 Courant–Friedrichs–Lewy (CFL) 条件。\n- 在一个包含 $N=400$ 个点的均匀网格上实现此方法，网格间距为 $\\Delta x = 1/N$。时间步长 $\\Delta t$ 通过指定的 CFL 数 $\\nu$ 来选择，当 $|a|>0$ 时，需满足 $|a|\\,\\Delta t / \\Delta x = \\nu$ 的要求。当 $|a|=0$ 时，取 $\\Delta t = \\nu\\,\\Delta x$。通过使用整数个时间步，将解精确推进到最终时间 $T$。\n- 使用周期性边界条件，通过在移位的坐标上（进行周期性包裹）逐点计算 $u_0$ 来计算解析解 $u(x,T) = u_0(x - a T \\,\\mathrm{mod}\\, 1)$，然后计算离散 $L^2$ 误差\n$$\nE = \\left(\\Delta x \\sum_{i=0}^{N-1} \\big(u_i^{\\text{num}} - u_i^{\\text{exact}}\\big)^2\\right)^{1/2}.\n$$\n- 通过比较数值解在 $t=0$ 和 $t=T$ 时的质心（一阶矩）来推断模拟的传播方向。令\n$$\nx_{\\mathrm{cm}}(t) = \\frac{\\sum_{i} x_i\\,u_i(t)}{\\sum_{i} u_i(t)}.\n$$\n定义方向标志 $D$ 为 $D=\\mathrm{sign}\\big(x_{\\mathrm{cm}}(T) - x_{\\mathrm{cm}}(0)\\big)$，并约定 $D \\in \\{-1,0,+1\\}$，其中 $-1$ 表示向左传播，$+1$ 表示向右传播，$0$ 表示静止行为（使用一个小的阈值将可忽略的位移视为 $0$）。\n\n所有量均为无量纲。不涉及角度。无需物理单位。\n\n测试组：\n- 案例 1：$a=-1.0$，$\\nu=0.9$，$T=0.25$。\n- 案例 2：$a=-2.0$，$\\nu=0.8$，$T=0.10$。\n- 案例 3：$a=+1.0$，$\\nu=0.9$，$T=0.25$。\n- 案例 4：$a=0.0$，$\\nu=0.9$，$T=0.25$。\n- 案例 5：$a=-1.0$，$\\nu=1.0$，$T=0.25$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，格式为 $[E_1,D_1,E_2,D_2,E_3,D_3,E_4,D_4,E_5,D_5]$。其中 $E_k$ 是浮点数，$D_k$ 是整数，它们是针对相应案例，在指定的网格上使用指定的方法和参数，计算到精确最终时间 $T$ 的结果。", "solution": "该问题要求对一维线性平流方程 $u_t + a u_x = 0$ 在周期性域上进行数值模拟，并对结果进行分析。问题陈述经核实是自洽、科学上合理且适定的。\n\n### 一阶迎风法的推导\n\n控制偏微分方程 (PDE) 是线性平流方程：\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0\n$$\n其中 $u(x,t)$ 是守恒量，$a$ 是恒定的平流速度。\n\n该方程属于双曲型偏微分方程。其解可以通过特征线法来理解。特征线是 $(x,t)$ 平面中的一些曲线，沿着这些曲线解 $u$ 是常数。这些曲线由以下常微分方程定义：\n$$\n\\frac{dx}{dt} = a\n$$\n沿着这些曲线，$u$ 的全导数为：\n$$\n\\frac{d}{dt} u(x(t), t) = \\frac{\\partial u}{\\partial t} + \\frac{dx}{dt} \\frac{\\partial u}{\\partial x} = u_t + a u_x = 0\n$$\n这意味着 $u$ 沿着特征线是不变的。因此，点 $(x_i, t_n + \\Delta t)$ 处的解值等于上一个时间步长上位于同一特征线上的点 $(x_i - a\\Delta t, t_n)$ 处的解值。\n$$\nu(x_i, t_n + \\Delta t) = u(x_i - a\\Delta t, t_n)\n$$\n为了建立一个有限差分格式，我们必须使用时间 $t_n$ 时网格点 $\\{x_j\\}$ 上的已知值来近似 $u(x_i - a\\Delta t, t_n)$ 的值。迎风法源于一种尊重信息流方向的一阶插值。\n\n我们使用空间步长为 $\\Delta x$、时间步长为 $\\Delta t$ 的均匀网格。令 $u_i^n \\approx u(x_i, t_n)$。\n\n**情况 1：$a > 0$（向右传播）**\n信息从左向右传播。点 $x_i - a\\Delta t$ 位于 $x_i$ 的左侧。对于一个稳定的格式，Courant–Friedrichs–Lewy (CFL) 条件要求数值格式的依赖域必须包含偏微分方程的依赖域。这导致了条件 $a \\frac{\\Delta t}{\\Delta x} \\le 1$。因此，点 $x_i - a\\Delta t$ 位于区间 $[x_{i-1}, x_i]$ 内。\n\n迎风原理要求使用来自“迎风”方向的值来近似 $x_i$ 处的空间导数 $\\frac{\\partial u}{\\partial x}$，在这种情况下是负 $x$ 方向。我们使用一阶后向差分近似：\n$$\n\\frac{\\partial u}{\\partial x} \\bigg|_{x_i, t_n} \\approx \\frac{u_i^n - u_{i-1}^n}{\\Delta x}\n$$\n用前向欧拉步对时间导数进行离散化，$\\frac{\\partial u}{\\partial t} \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}$，偏微分方程变为：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\left( \\frac{u_i^n - u_{i-1}^n}{\\Delta x} \\right) = 0\n$$\n求解 $u_i^{n+1}$：\n$$\nu_i^{n+1} = u_i^n - a \\frac{\\Delta t}{\\Delta x} (u_i^n - u_{i-1}^n)\n$$\n当 $a > 0$ 时，定义 CFL 数为 $\\nu = |a|\\frac{\\Delta t}{\\Delta x} = a\\frac{\\Delta t}{\\Delta x}$，则格式为：\n$$\nu_i^{n+1} = u_i^n - \\nu (u_i^n - u_{i-1}^n)\n$$\n\n**情况 2：$a  0$（向左传播）**\n信息从右向左传播。点 $x_i - a\\Delta t$ 位于 $x_i$ 的右侧。现在的迎风方向是正 $x$ 方向。我们对空间导数使用一阶前向差分：\n$$\n\\frac{\\partial u}{\\partial x} \\bigg|_{x_i, t_n} \\approx \\frac{u_{i+1}^n - u_i^n}{\\Delta x}\n$$\n半离散方程为：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\left( \\frac{u_{i+1}^n - u_i^n}{\\Delta x} \\right) = 0\n$$\n求解 $u_i^{n+1}$：\n$$\nu_i^{n+1} = u_i^n - a \\frac{\\Delta t}{\\Delta x} (u_{i+1}^n - u_i^n)\n$$\n在此，CFL 数为 $\\nu = |a|\\frac{\\Delta t}{\\Delta x} = -a\\frac{\\Delta t}{\\Delta x}$，所以 $a\\frac{\\Delta t}{\\Delta x} = -\\nu$。格式变为：\n$$\nu_i^{n+1} = u_i^n - (-\\nu) (u_{i+1}^n - u_i^n) = u_i^n + \\nu (u_{i+1}^n - u_i^n)\n$$\n\n**情况 3：$a = 0$（静止）**\n偏微分方程简化为 $u_t = 0$。解在时间上是恒定的。数值格式应反映这一点：\n$$\nu_i^{n+1} = u_i^n\n$$\n当 $a=0$ 时（因此根据问题对 $a \\neq 0$ 的 CFL 定义，$\\nu=0$），两个推导出的公式都能正确地简化为此结果（尽管对于 $a=0$，我们的更新逻辑只会执行 $u_i^{n+1} = u_i^n$）。\n\n这种显式一阶迎风格式的稳定性条件是 $0 \\le \\nu \\le 1$。\n\n### 实现细节\n\n**数值网格和时间步进：**\n空间域 $[0,1)$ 被离散为 $N=400$ 个点，$x_i = i \\Delta x$（$i=0, \\dots, N-1$），其中 $\\Delta x = 1/N$。通过对索引取模 $N$ 来实施周期性边界条件。\n必须通过整数步数达到最终时间 $T$。给定 CFL 数 $\\nu$，当 $a \\neq 0$ 时，基本时间步长计算为 $\\Delta t_{base} = \\nu \\Delta x / |a|$；当 $a=0$ 时，$\\Delta t_{base} = \\nu \\Delta x$。整数步数是 $N_t = \\lceil T / \\Delta t_{base} \\rceil$。然后，用于模拟的实际时间步长被调整为 $\\Delta t = T / N_t$，这确保了模拟在精确的时间 $T$ 结束，同时满足 CFL 稳定性条件，因为 $\\Delta t \\le \\Delta t_{base}$。\n\n**初始条件：**\n初始条件是 $u(x,0) = \\exp(-50\\,d(x)^2)$。函数 $d(x) = (x-0.5) - \\mathrm{round}(x-0.5)$ 表示从 $x$ 到域中心 $0.5$ 的带符号周期性距离。对于 $x \\in [0,1)$，这可以简化为 $d(x) = x-0.5$。因此，初始剖面为 $u_i^0 = \\exp(-50 (x_i - 0.5)^2)$。\n\n**解析解：**\n平流方程的解析解是初始剖面的简单平移：$u(x,t) = u_0(x-at)$。在周期性域上，这变为 $u(x,t) = u_0((x-at) \\pmod 1)$。网格点上的精确解是：\n$$\nu_i^{\\text{exact}} = \\exp\\left(-50 \\left( ((x_i - aT) \\pmod 1) - 0.5 \\right)^2\\right)\n$$\n\n**误差和方向计算：**\n离散 $L^2$ 误差按指定方式计算：\n$$\nE = \\left(\\Delta x \\sum_{i=0}^{N-1} \\big(u_i^{\\text{num}}(T) - u_i^{\\text{exact}}(T)\\big)^2\\right)^{1/2}\n$$\n传播方向通过分布的质心（一阶矩）的变化来推断，$x_{\\mathrm{cm}}(t) = \\frac{\\sum_i x_i u_i(t)}{\\sum_i u_i(t)}$。方向标志 $D$ 是：\n$$\nD = \\mathrm{sign}\\big(x_{\\mathrm{cm}}(T) - x_{\\mathrm{cm}}(0)\\big)\n$$\n使用一个小的阈值将可忽略的位移设置为 $D=0$，以考虑浮点不精确性和静止情况。\n\n对每个测试案例实施该算法，并收集得到的结果误差 $E$ 和方向标志 $D$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation using a first-order upwind scheme\n    for a set of test cases and computes the L2 error and propagation direction.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, nu, T)\n        (-1.0, 0.9, 0.25),\n        (-2.0, 0.8, 0.10),\n        (+1.0, 0.9, 0.25),\n        ( 0.0, 0.9, 0.25),\n        (-1.0, 1.0, 0.25),\n    ]\n\n    results = []\n    \n    # Grid parameters\n    N = 400\n    dx = 1.0 / N\n    x = np.linspace(0.0, 1.0, N, endpoint=False)\n\n    for a, nu, T in test_cases:\n        # 1. Initial Condition\n        # The definition d(x) = (x-0.5) - round(x-0.5) for x in [0,1) simplifies\n        # to d(x) = x - 0.5 because round(x-0.5) is 0 in this range.\n        u = np.exp(-50.0 * (x - 0.5)**2)\n        u_initial = np.copy(u)\n\n        # 2. Time-stepping parameters\n        if a == 0.0:\n            # For a=0, time step is defined differently.\n            # The equation is u_t = 0, so the solution is stationary.\n            # We still set up time steps to match final time T.\n            dt_base = nu * dx if nu * dx  0 else 1e-9 # Avoid division by zero if T=0\n        else:\n            # CFL condition: nu = |a| * dt / dx\n            dt_base = nu * dx / abs(a)\n\n        # Calculate number of steps to reach T exactly\n        # Note: If T=0, n_steps=0. The loop won't run, u remains u_initial.\n        n_steps = math.ceil(T / dt_base) if T  0 else 0\n        dt = T / n_steps if n_steps  0 else 0.0\n        \n        # 3. Compute initial centroid\n        x_cm0 = np.sum(x * u_initial) / np.sum(u_initial)\n\n        # 4. Time evolution loop\n        # The update uses vectorized numpy operations for efficiency.\n        # np.roll(u, 1) gets u_{i-1} at index i (periodic)\n        # np.roll(u, -1) gets u_{i+1} at index i (periodic)\n        \n        cfl_factor = a * dt / dx\n\n        for _ in range(n_steps):\n            if a  0:\n                # Backward difference for u_x: (u_i - u_{i-1}) / dx\n                # u_new = u - (a*dt/dx) * (u - np.roll(u,1))\n                u = u - cfl_factor * (u - np.roll(u, 1))\n            elif a  0:\n                # Forward difference for u_x: (u_{i+1} - u_i) / dx\n                # u_new = u - (a*dt/dx) * (np.roll(u,-1) - u)\n                u = u - cfl_factor * (np.roll(u, -1) - u)\n            # If a == 0.0, u is unchanged.\n        \n        u_numerical = u\n\n        # 5. Compute final centroid and propagation direction\n        x_cmT = np.sum(x * u_numerical) / np.sum(u_numerical)\n        \n        delta_cm = x_cmT - x_cm0\n        # Use a small threshold for determining stationary behavior\n        if abs(delta_cm)  1e-9:\n            D = 0\n        else:\n            D = int(np.sign(delta_cm))\n        \n        # Correct for periodic wrapping in direction calculation.\n        # The provided test cases do not involve wrapping, so simple sign suffices.\n        # A more robust method would check the shortest periodic distance.\n        # For example: if delta_cm > 0.5, D should be -1. if delta_cm  -0.5, D should be 1.\n        # This is not needed for the given test values of a and T.\n            \n        # 6. Compute analytical solution and error\n        x_shifted = (x - a * T) % 1.0\n        # The simplified form of d(x) applies here as well.\n        u_exact = np.exp(-50.0 * (x_shifted - 0.5)**2)\n\n        # Discrete L2 error\n        error = np.sqrt(dx * np.sum((u_numerical - u_exact)**2))\n\n        results.extend([error, D])\n\n    # Final print statement in the exact required format.\n    # Convert results to string with desired formatting\n    formatted_results = []\n    for item in results:\n        if isinstance(item, int):\n            formatted_results.append(str(item))\n        else:\n            # Standard float formatting for consistency\n            formatted_results.append(f\"{item:.15g}\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3229222"}, {"introduction": "在掌握了基本数值格式后，探索其局限性同样重要。本练习旨在揭示一种被称为“数值色散”的现象，即在数值模拟中，不同频率的波会以错误的速度传播。通过构造一个由网格能表示的最高频率（奈奎斯特频率）组成的“恶意”初始条件，我们将清晰地观察到这一效应，并理解为何精确模拟通常需要高分辨率的网格。[@problem_id:3229319]", "problem": "考虑定义在周期区间 $[0,L)$ 上的一维线性波偏微分方程 (PDE) $u_{tt} = c^2 u_{xx}$，其中 $u(x,t)$ 在时间和空间上是二阶可微的，$c$ 是恒定的波速，$L$ 是域的长度。数值任务是研究一种标准的二阶显式有限差分法的色散性质，其初始条件被特意选择为给定空间网格上可以表示的最高频率。\n\n您将使用一个包含 $N$ 个点的均匀网格，空间步长为 $\\Delta x = L/N$，时间步长为 $\\Delta t$。设网格点为 $x_i = i \\,\\Delta x$（其中 $i = 0,1,\\dots,N-1$），时间层为 $t^n = n \\,\\Delta t$（其中整数 $n \\ge 0$）。使用周期性边界条件，这意味着索引以 $N$ 为模进行循环。此网格上可表示的最高波数（奈奎斯特模式）为 $k_{\\max} = \\pi/\\Delta x$。定义“恶意”初始位移为 $u(x,0) = \\cos(k_{\\max} x)$，初始速度为 $u_t(x,0) = 0$。此初始条件最大限度地暴露了数值色散的敏感性，因为它位于离散谱的边缘。\n\n在上述网格上，使用时间和空间上的中心差分，实现一个与 $u_{tt} = c^2 u_{xx}$ 一致的二阶精度显式有限差分法。在近似空间导数时，使用周期性边界条件。从 $u(x,0)$ 初始化 $u^0$，并利用 $u_t(x,0)$ 以及该方法与 PDE 的一致性来构造 $u^1$，以使整个格式在时间上保持二阶精度。\n\n对于每次模拟，通过利用固定网格点上模式的离散时间行为，或者通过将演化解 $u^n$ 与初始空间模式 $\\phi_i = \\cos(k_{\\max} x_i)$ 进行相关性分析，来估计与奈奎斯特模式相关的数值角频率 $\\omega_{\\text{num}}$。具体来说，对于近似单模的时间序列，使用余弦序列的恒等式从序列 $\\{u^n\\}$ 中估计 $\\cos(\\omega_{\\text{num}} \\Delta t)$，并在多个时间层上对此估计值进行平均以减少数值噪声。计算由连续 PDE 对此模式产生的精确角频率 $\\omega_{\\text{exact}} = c\\,k_{\\max}$。将色散误差度量定义为无量纲浮点数\n$$\nE = \\left| \\frac{\\omega_{\\text{num}}}{\\omega_{\\text{exact}}} - 1 \\right|.\n$$\n\n所有物理量必须使用适当的单位处理：选择 $L$ 的单位为米，$c$ 的单位为米/秒，$\\Delta t$ 的单位为秒；三角函数中的角度单位为弧度。为保证稳定性，应遵守 Courant–Friedrichs–Lewy (CFL) 条件；定义无量纲的库朗数 $s = \\frac{c\\,\\Delta t}{\\Delta x}$，并使用 $s \\le 1$ 的值。\n\n您的程序必须：\n- 使用 $k_{\\max} = \\pi/\\Delta x$ 构造恶意初始条件。\n- 在周期性边界条件下，使用二阶显式中心有限差分法推进求解。\n- 根据时间序列估计 $\\omega_{\\text{num}}$，并为每个测试用例计算 $E$。\n- 将每个 $E$ 四舍五入到 $8$ 位小数。\n\n使用以下测试套件，该套件在保持 $L$ 和 $c$ 固定的情况下，通过改变库朗数 $s$ 来探究不同区域的色散：\n- 用例 1：$L = 1$ (米)，$c = 1$ (米/秒)，$N = 128$，$s = 0.2$，$n_{\\text{steps}} = 200$。\n- 用例 2：$L = 1$ (米)，$c = 1$ (米/秒)，$N = 128$，$s = 0.5$，$n_{\\text{steps}} = 200$。\n- 用例 3：$L = 1$ (米)，$c = 1$ (米/秒)，$N = 128$，$s = 0.9$，$n_{\\text{steps}} = 200$。\n- 用例 4：$L = 1$ (米)，$c = 1$ (米/秒)，$N = 128$，$s = 1.0$，$n_{\\text{steps}} = 200$。\n\n您的程序应生成单行输出，其中包含按上述测试用例顺序排列的结果，结果为逗号分隔的列表并用方括号括起。例如，输出格式必须为\n$[E_1,E_2,E_3,E_4]$,\n其中每个 $E_j$ 是用例 $j$ 的色散误差，四舍五入到 $8$ 位小数。", "solution": "该问题要求研究用于一维线性波方程 $u_{tt} = c^2 u_{xx}$ 的标准二阶显式有限差分法的数值色散。分析的重点是一个特定的初始条件，即奈奎斯特模式，这是离散网格上可表示的最高频率模式。这个选择最大限度地暴露了该格式的色散误差。\n\n首先，我们定义计算域和离散化。空间域是一个周期区间 $[0,L)$，被离散化为 $N$ 个点 $x_i = i \\Delta x$（$i=0, 1, \\dots, N-1$），网格间距为 $\\Delta x = L/N$。时间被离散化为多个时间层 $t^n = n \\Delta t$，其中 $\\Delta t$ 是时间步长。在网格点 $x_i$ 和时间 $t^n$ 处的解表示为 $u_i^n \\approx u(x_i, t^n)$。\n\n偏微分方程 $u_{tt} = c^2 u_{xx}$ 使用对时间和空间导数的二阶精度中心有限差分进行近似：\n$$\n\\frac{\\partial^2 u}{\\partial t^2}\\bigg|_{i,n} \\approx \\frac{u_i^{n+1} - 2u_i^n + u_i^{n-1}}{(\\Delta t)^2}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{i,n} \\approx \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2}\n$$\n将这些表达式代入 PDE 并重新整理，得到显式时间推进格式，通常称为蛙跳法：\n$$\nu_i^{n+1} = 2u_i^n - u_i^{n-1} + \\left(\\frac{c \\Delta t}{\\Delta x}\\right)^2 (u_{i+1}^n - 2u_i^n + u_{i-1}^n)\n$$\n令 $s = \\frac{c \\Delta t}{\\Delta x}$ 为无量纲的库朗数。该格式可以写成：\n$$\nu_i^{n+1} = 2(1-s^2)u_i^n + s^2(u_{i+1}^n + u_{i-1}^n) - u_i^{n-1}\n$$\n强制施加周期性边界条件，意味着索引以 $N$ 为模进行取值，使得 $u_N^n = u_0^n$ 且 $u_{-1}^n = u_{N-1}^n$。当 $s \\le 1$ 时，此格式是稳定的。\n\n初始条件被指定为一种“恶意”模式，旨在探究最坏情况下的色散。初始位移为 $u(x,0) = \\cos(k_{\\max}x)$，其中 $k_{\\max} = \\pi/\\Delta x$ 是奈奎斯特波数。在离散网格上，这变为：\n$$\nu_i^0 = u(x_i, 0) = \\cos(k_{\\max} x_i) = \\cos\\left(\\frac{\\pi}{\\Delta x} i \\Delta x\\right) = \\cos(i\\pi) = (-1)^i\n$$\n这个初始条件对应于锯齿状或棋盘状的模式，是网格上可以表示的最高频率波。初始速度为 $u_t(x,0)=0$。\n\n蛙跳法是一种三层方法，需要前两个时间步 $u^n$ 和 $u^{n-1}$ 的数据来计算 $u^{n+1}$。为了找到第一个时间步的解 $u^1$，我们必须使用一种不同的方法来保持格式的二阶精度。使用 $u(x,t)$ 在 $t=0$ 附近的 Taylor 级数展开：\n$$\nu(x, \\Delta t) = u(x,0) + \\Delta t \\, u_t(x,0) + \\frac{(\\Delta t)^2}{2} u_{tt}(x,0) + O((\\Delta t)^3)\n$$\n利用初始条件 $u_t(x,0)=0$ 和 PDE 本身 $u_{tt}(x,0) = c^2 u_{xx}(x,0)$，我们得到：\n$$\nu(x, \\Delta t) \\approx u(x,0) + \\frac{c^2 (\\Delta t)^2}{2} u_{xx}(x,0)\n$$\n在空间上对此表达式进行离散化，得到 $u_i^1$ 的公式：\n$$\nu_i^1 = u_i^0 + \\frac{s^2}{2} (u_{i+1}^0 - 2u_i^0 + u_{i-1}^0) = (1-s^2)u_i^0 + \\frac{s^2}{2}(u_{i+1}^0 + u_{i-1}^0)\n$$\n在 $u^0$ 和 $u^1$ 确定后，主蛙跳循环可以对所有后续时间步进行。\n\n为了量化色散误差，我们必须估计数值角频率 $\\omega_{\\text{num}}$，并将其与精确角频率 $\\omega_{\\text{exact}}$ 进行比较。对于波数为 $k$ 的波，连续 PDE 意味着线性色散关系 $\\omega = c k$。对于奈奎斯特模式，这给出：\n$$\n\\omega_{\\text{exact}} = c k_{\\max} = \\frac{c \\pi}{\\Delta x}\n$$\n对于指定的初始条件，数值解预期会按 $u_i^n \\approx (-1)^i \\cos(\\omega_{\\text{num}} n \\Delta t)$ 的形式演化。此模式随时间变化的振幅 $A_n = \\cos(\\omega_{\\text{num}} n \\Delta t)$，可以通过将数值解向量 $U^n = \\{u_i^n\\}_{i=0}^{N-1}$ 投影到初始模式形状向量 $\\phi = \\{(-1)^i\\}_{i=0}^{N-1}$ 上来分离出来：\n$$\nA_n = \\frac{1}{N} \\sum_{i=0}^{N-1} u_i^n \\phi_i\n$$\n序列 $\\{A_n\\}$ 遵循余弦的三项递推关系：$A_{n+1} + A_{n-1} = 2 A_n \\cos(\\omega_{\\text{num}} \\Delta t)$。我们可以重新整理这个关系式来估计相位步长的余弦值：\n$$\n\\cos(\\omega_{\\text{num}} \\Delta t) = \\frac{A_{n+1} + A_{n-1}}{2 A_n}\n$$\n通过为每个时间步 $n$ 计算此量（其中 $A_n$ 不接近于零）并对结果进行平均，我们得到一个稳健的估计值 $\\cos_{\\text{est}}$。然后通过以下方式恢复数值角频率：\n$$\n\\omega_{\\text{num}} = \\frac{1}{\\Delta t} \\arccos(\\cos_{\\text{est}})\n$$\n最后，色散误差度量 $E$ 计算为数值频率与精确频率之间的相对差异：\n$$\nE = \\left| \\frac{\\omega_{\\text{num}}}{\\omega_{\\text{exact}}} - 1 \\right|\n$$\n对每一组给定的参数重复此过程，以分析色散误差如何随库朗数 $s$ 变化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the wave equation for the Nyquist mode to analyze numerical dispersion.\n    \"\"\"\n    # test_cases: (L, c, N, s, n_steps)\n    test_cases = [\n        (1.0, 1.0, 128, 0.2, 200),\n        (1.0, 1.0, 128, 0.5, 200),\n        (1.0, 1.0, 128, 0.9, 200),\n        (1.0, 1.0, 128, 1.0, 200),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        L, c, N, s, n_steps = case\n\n        # Grid and simulation parameters\n        dx = L / N\n        dt = s * dx / c\n        \n        # Store solution history\n        u_history = np.zeros((n_steps + 1, N))\n\n        # Initial condition u^0: Nyquist mode u(x,0) = cos(pi*x/dx)\n        # u_i^0 = cos(pi * i*dx / dx) = cos(i*pi) = (-1)^i\n        u_curr = np.array([(-1)**i for i in range(N)], dtype=float)\n        u_history[0, :] = u_curr\n        \n        # First time step u^1, using u_t(x,0) = 0\n        # u_i^1 = (1-s^2)u_i^0 + (s^2/2)(u_{i+1}^0 + u_{i-1}^0)\n        u_prev = np.copy(u_curr) # This will be u^0\n        u_ip1 = np.roll(u_curr, -1)\n        u_im1 = np.roll(u_curr, 1)\n        u_curr = (1 - s**2) * u_curr + (s**2 / 2.0) * (u_ip1 + u_im1)\n        u_history[1, :] = u_curr\n\n        # Main loop (leapfrog scheme)\n        for n in range(1, n_steps):\n            u_ip1 = np.roll(u_curr, -1)\n            u_im1 = np.roll(u_curr, 1)\n            u_next = 2.0 * (1.0 - s**2) * u_curr + s**2 * (u_ip1 + u_im1) - u_prev\n            \n            u_prev = np.copy(u_curr)\n            u_curr = np.copy(u_next)\n            u_history[n + 1, :] = u_curr\n\n        # Post-processing: Estimate numerical frequency\n        # Initial mode shape\n        phi = np.array([(-1)**i for i in range(N)], dtype=float)\n        \n        # Project solution onto the mode shape to get amplitudes A_n\n        # A_n = dot(u_n, phi) / N\n        amplitudes = np.dot(u_history, phi) / N\n\n        cos_estimates = []\n        # Estimate cos(omega_num * dt) from the amplitude recurrence\n        # cos(theta) = (A_{n+1} + A_{n-1}) / (2 * A_n)\n        for n in range(1, n_steps):\n            # Avoid division by zero or small numbers\n            if abs(amplitudes[n])  1e-10:\n                cos_est = (amplitudes[n+1] + amplitudes[n-1]) / (2.0 * amplitudes[n])\n                cos_estimates.append(cos_est)\n\n        if not cos_estimates:\n             # Fallback if no valid estimates could be made (highly unlikely)\n             # Use the analytical dispersion relation for the Nyquist mode\n             avg_cos_est = 1.0 - 2.0 * s**2\n        else:\n             avg_cos_est = np.mean(cos_estimates)\n\n        # Clip to handle potential floating-point errors pushing value outside [-1, 1]\n        avg_cos_est = np.clip(avg_cos_est, -1.0, 1.0)\n        \n        omega_num = np.arccos(avg_cos_est) / dt\n\n        # Calculate exact frequency and dispersion error\n        k_max = np.pi / dx\n        omega_exact = c * k_max\n        \n        # Ensure omega_exact is not zero to avoid division errors\n        if abs(omega_exact)  1e-12:\n            dispersion_error = 0.0 if abs(omega_num)  1e-12 else np.inf\n        else:\n            dispersion_error = abs(omega_num / omega_exact - 1.0)\n            \n        results.append(round(dispersion_error, 8))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3229319"}, {"introduction": "最后，我们将把所学知识应用于一个经典的物理问题：模拟一根被拨动的琴弦的振动。这个综合性练习不仅要求你求解波动方程，还挑战你将数值模拟结果与基于傅里叶级数的理论频谱进行比较。通过这个实践，你将把数值方法、解析理论和像离散傅里叶变换（DFT）这样的数据分析技术联系起来，从而获得一个更完整的视角。[@problem_id:3229336]", "problem": "考虑描述理想弦横向位移的一维波动方程，其两端固定，\n$$\nu_{tt}(x,t) = c^2\\, u_{xx}(x,t), \\qquad 0  x  L, \\quad t  0,\n$$\n服从固定端点的边界条件\n$$\nu(0,t) = 0, \\qquad u(L,t) = 0,\n$$\n以及“拨动”后的初始位移\n$$\nu(x,0) = u_0(x) = \n\\begin{cases}\n\\dfrac{A_0}{p L}\\, x,  0 \\le x \\le p L, \\\\\n\\dfrac{A_0}{(1-p) L}\\,(L - x),  p L \\le x \\le L,\n\\end{cases}\n\\qquad u_t(x,0) = 0,\n$$\n其中 $L$ 是弦长（单位：$\\mathrm{m}$），$c$ 是波速（单位：$\\mathrm{m/s}$），$A_0$ 是拨弦振幅（单位：$\\mathrm{m}$），$p \\in (0,1)$ 是从 $x=0$ 处测量的归一化拨弦位置。\n\n您将使用空间和时间上的均匀有限差分网格来近似求解。设空间网格点有 $N_x$ 个，间距为 $\\Delta x = L/(N_x-1)$，时间步长为 $\\Delta t$。使用显式二阶中心差分格式，\n$$\nu_j^{n+1} = 2 u_j^n - u_j^{n-1} + \\lambda^2 \\left(u_{j+1}^n - 2 u_j^n + u_{j-1}^n\\right),\n$$\n其中 $u_j^n$ 近似于 $u(x_j, t_n)$ 在 $x_j = j\\,\\Delta x$ 和 $t_n = n\\,\\Delta t$ 处的值，且 $\\lambda = \\dfrac{c\\,\\Delta t}{\\Delta x}$。使用针对零初始速度的二阶精度泰勒展开进行初始化，\n$$\nu_j^1 = u_j^0 + \\frac{1}{2}\\,\\lambda^2 \\left(u_{j+1}^0 - 2 u_j^0 + u_{j-1}^0\\right).\n$$\n\n固定端点边界条件的解析模态展开为\n$$\nu(x,t) = \\sum_{n=1}^{\\infty} A_n \\sin\\!\\left(\\frac{n\\pi x}{L}\\right)\\cos\\!\\left(\\omega_n t\\right),\n\\qquad \\omega_n = \\frac{n\\pi c}{L}, \\qquad f_n = \\frac{\\omega_n}{2\\pi} = \\frac{n c}{2L},\n$$\n其中 $A_n$ 是初始剖面 $u_0(x)$ 的正弦级数系数：\n$$\nA_n = \\frac{2}{L}\\int_0^L u_0(x) \\sin\\!\\left(\\frac{n\\pi x}{L}\\right)\\,dx.\n$$\n\n任务1（推导）：从上述 $A_n$ 的定义和拨动后的初始形状 $u_0(x)$ 出发，推导出 $A_n$ 关于 $A_0$、$p$、$L$ 和 $n$ 的闭式表达式，然后推导出在观测点 $x_\\mathrm{obs}$ 处模态 $n$ 的解析振幅为\n$$\nB_n^\\mathrm{(theory)} = \\left|A_n \\sin\\!\\left(\\frac{n\\pi x_\\mathrm{obs}}{L}\\right)\\right|.\n$$\n角度使用弧度制。\n\n任务2（算法设计）：从波动方程和上面给出的显式格式出发，解释如何选择 $\\Delta t$ 和总模拟时间 $T_\\mathrm{total}$，以获得一个数值上良好解析的频谱，该频谱能将离散傅里叶变换 (DFT) 的频箱与解析模态频率 $f_n$ 对齐。使用 Courant–Friedrichs–Lewy (CFL) 数定义 $\\lambda = \\dfrac{c\\,\\Delta t}{\\Delta x}$，并确保 $\\lambda = 1$，从而\n$$\n\\Delta t = \\frac{\\Delta x}{c}, \\qquad T_\\mathrm{total} = M\\,T_1 = \\frac{M}{f_1} = M\\,\\frac{2L}{c},\n$$\n对于一个选定的整数 $M \\ge 1$。通过这种选择，第 $n$ 个模态的 DFT 频箱将是一个整数索引，从而可以直接比较不同模态的谱幅度。\n\n任务3（实现与比较）：实现一个程序，该程序\n- 构建空间网格，并用拨动形状 $u_0(x)$ 初始化 $u_j^0$，以及使用给定公式初始化 $u_j^1$。\n- 使用显式更新规则将解在时间上推进，其中 $n=1,2,\\dots,N_t-1$，且 $N_t = \\lfloor T_\\mathrm{total}/\\Delta t\\rfloor$。\n- 通过选择最近的网格索引，记录固定观测点 $x_\\mathrm{obs}$ 处的时间序列 $u(x_\\mathrm{obs}, t)$。\n- 计算记录的时间序列的 DFT，并通过读取 DFT 在频箱索引 $k_n = n M$（其中 $n=1,\\dots,K$，$K$ 是要比较的模态数）处的值，提取解析模态频率处的数值谱幅度。\n- 根据任务1为 $n=1,\\dots,K$ 构建理论振幅向量 $B_n^\\mathrm{(theory)}$。\n- 通过将每个向量除以其自身的最大值来归一化数值和理论振幅向量，以关注相对频谱形状。\n- 计算归一化后的数值向量和理论向量之间的平均绝对差，为测试用例生成一个单一的浮点误差度量：\n$$\nE = \\frac{1}{K}\\sum_{n=1}^K \\left| \\frac{B_n^\\mathrm{(num)}}{\\max_m B_m^\\mathrm{(num)}} - \\frac{B_n^\\mathrm{(theory)}}{\\max_m B_m^\\mathrm{(theory)}} \\right|.\n$$\n\n物理单位：$L$ 的单位必须是 $\\mathrm{m}$，$c$ 的单位是 $\\mathrm{m/s}$，$A_0$ 的单位是 $\\mathrm{m}$，$T_\\mathrm{total}$ 的单位是 $\\mathrm{s}$。正弦函数中的所有角度都以弧度为单位。最终的误差度量 $E$ 是无量纲的。\n\n测试套件：您的程序必须评估以下三种情况，并为每种情况输出一个浮点数，每个浮点数都按上述方法计算。\n- 情况1（中心拨弦，奇次谐波主导）：$L = 1.0\\,\\mathrm{m}$，$c = 1.0\\,\\mathrm{m/s}$，$A_0 = 1.0\\,\\mathrm{m}$，$N_x = 129$，$p = 0.5$，$x_\\mathrm{obs} = 0.31\\,\\mathrm{m}$，$M = 32$，$K = 8$。\n- 情况2（偏心拨弦，混合谐波）：$L = 1.0\\,\\mathrm{m}$，$c = 2.0\\,\\mathrm{m/s}$，$A_0 = 1.0\\,\\mathrm{m}$，$N_x = 129$，$p = 0.3$，$x_\\mathrm{obs} = 0.37\\,\\mathrm{m}$，$M = 32$，$K = 10$。\n- 情况3（近端拨弦，高频分量更强）：$L = 1.0\\,\\mathrm{m}$，$c = 1.5\\,\\mathrm{m/s}$，$A_0 = 1.0\\,\\mathrm{m}$，$N_x = 257$，$p = 0.1$，$x_\\mathrm{obs} = 0.83\\,\\mathrm{m}$，$M = 16$，$K = 12$。\n\n最终输出格式：您的程序应生成单行输出，其中包含上述三种情况的三个误差度量，格式为方括号内以逗号分隔的列表，例如 `\"[e_1,e_2,e_3]\"`，其中每个 $e_i$ 是一个浮点数。", "solution": "此问题被评估为有效。它在科学上基于波传播物理学以及偏微分方程和傅里叶分析的数学原理。该问题是适定的，具有一套完整且一致的方程、边界条件、初始条件和参数。这些任务是客观、明确的，并能导出一个可验证的数值结果。\n\n### 任务1：解析模态振幅的推导\n\n第一个任务是为初始位移剖面 $u_0(x)$ 的傅里叶正弦级数系数 $A_n$ 推导出一个闭式表达式。系数 $A_n$ 定义为：\n$$\nA_n = \\frac{2}{L}\\int_0^L u_0(x) \\sin\\!\\left(\\frac{n\\pi x}{L}\\right)\\,dx\n$$\n初始形状 $u_0(x)$ 是一个分段线性函数：\n$$\nu_0(x) = \n\\begin{cases}\n\\dfrac{A_0}{p L}\\, x,  0 \\le x \\le p L, \\\\\n\\dfrac{A_0}{(1-p) L}\\,(L - x),  p L \\le x \\le L,\n\\end{cases}\n$$\n我们将 $u_0(x)$ 代入 $A_n$ 的积分中，并根据分段定义将积分分成两部分：\n$$\nA_n = \\frac{2}{L} \\left[ \\int_0^{pL} \\frac{A_0}{pL} x \\sin\\!\\left(\\frac{n\\pi x}{L}\\right) dx + \\int_{pL}^{L} \\frac{A_0}{(1-p)L} (L-x) \\sin\\!\\left(\\frac{n\\pi x}{L}\\right) dx \\right]\n$$\n我们来计算这两个积分，记为 $I_1$ 和 $I_2$。为简便起见，设 $k = \\frac{n\\pi}{L}$。\n\n第一个积分是：\n$$\nI_1 = \\frac{2A_0}{pL^2} \\int_0^{pL} x \\sin(kx) \\,dx\n$$\n使用分部积分法，$\\int x \\sin(kx) \\,dx = -\\frac{x}{k}\\cos(kx) + \\frac{1}{k^2}\\sin(kx) + C$：\n$$\nI_1 = \\frac{2A_0}{pL^2} \\left[ -\\frac{x}{k}\\cos(kx) + \\frac{1}{k^2}\\sin(kx) \\right]_0^{pL}\n$$\n$$\nI_1 = \\frac{2A_0}{pL^2} \\left( \\left(-\\frac{pL}{k}\\cos(kpL) + \\frac{1}{k^2}\\sin(kpL)\\right) - (0) \\right)\n$$\n代入 $k = \\frac{n\\pi}{L}$ 和 $kpL = n\\pi p$：\n$$\nI_1 = \\frac{2A_0}{pL^2} \\left( -\\frac{pL^2}{n\\pi}\\cos(n\\pi p) + \\frac{L^2}{(n\\pi)^2}\\sin(n\\pi p) \\right) = \\frac{2A_0 \\sin(n\\pi p)}{p(n\\pi)^2} - \\frac{2A_0 \\cos(n\\pi p)}{n\\pi}\n$$\n第二个积分是：\n$$\nI_2 = \\frac{2A_0}{(1-p)L^2} \\int_{pL}^{L} (L-x) \\sin(kx) \\,dx = \\frac{2A_0}{(1-p)L^2} \\left[ L\\int_{pL}^L \\sin(kx)dx - \\int_{pL}^L x\\sin(kx)dx \\right]\n$$\n计算各项：\n$$\n\\int \\sin(kx)dx = -\\frac{1}{k}\\cos(kx)\n$$\n$$\n\\int (L-x)\\sin(kx)dx = -\\frac{L}{k}\\cos(kx) - \\left(-\\frac{x}{k}\\cos(kx) + \\frac{1}{k^2}\\sin(kx)\\right) = \\frac{x-L}{k}\\cos(kx) - \\frac{1}{k^2}\\sin(kx)\n$$\n因此，对于 $A_n$ 的第二部分积分：\n$$\nI_2 = \\frac{2A_0}{(1-p)L^2} \\left[ \\frac{x-L}{k}\\cos(kx) - \\frac{1}{k^2}\\sin(kx) \\right]_{pL}^L\n$$\n在上限 $x=L$ 处：$\\left[ 0 - \\frac{1}{k^2}\\sin(n\\pi) \\right] = 0$。\n在下限 $x=pL$ 处：$\\left[ \\frac{pL-L}{k}\\cos(n\\pi p) - \\frac{1}{k^2}\\sin(n\\pi p) \\right] = \\left[ -\\frac{(1-p)L}{k}\\cos(n\\pi p) - \\frac{1}{k^2}\\sin(n\\pi p) \\right]$。\n$$\nI_2 = \\frac{2A_0}{(1-p)L^2} \\left( 0 - \\left( -\\frac{(1-p)L^2}{n\\pi}\\cos(n\\pi p) - \\frac{L^2}{(n\\pi)^2}\\sin(n\\pi p) \\right) \\right)\n$$\n$$\nI_2 = \\frac{2A_0}{(1-p)L^2} \\left( \\frac{(1-p)L^2}{n\\pi}\\cos(n\\pi p) + \\frac{L^2}{(n\\pi)^2}\\sin(n\\pi p) \\right) = \\frac{2A_0 \\cos(n\\pi p)}{n\\pi} + \\frac{2A_0 \\sin(n\\pi p)}{(1-p)(n\\pi)^2}\n$$\n现在，我们将两部分的贡献相加：$A_n = I_1 + I_2$。\n$$\nA_n = \\left( \\frac{2A_0 \\sin(n\\pi p)}{p(n\\pi)^2} - \\frac{2A_0 \\cos(n\\pi p)}{n\\pi} \\right) + \\left( \\frac{2A_0 \\cos(n\\pi p)}{n\\pi} + \\frac{2A_0 \\sin(n\\pi p)}{(1-p)(n\\pi)^2} \\right)\n$$\n余弦项相互抵消，得到：\n$$\nA_n = \\frac{2A_0 \\sin(n\\pi p)}{(n\\pi)^2} \\left( \\frac{1}{p} + \\frac{1}{1-p} \\right) = \\frac{2A_0 \\sin(n\\pi p)}{(n\\pi)^2} \\left( \\frac{1-p+p}{p(1-p)} \\right)\n$$\n这可以简化为 $A_n$ 的最终闭式表达式：\n$$\nA_n = \\frac{2A_0 \\sin(n\\pi p)}{n^2\\pi^2 p(1-p)}\n$$\n在观测点 $x_\\mathrm{obs}$ 处模态 $n$ 的解析振幅，记为 $B_n^\\mathrm{(theory)}$，是级数展开式中第 $n$ 项在 $t=0$ 时的幅值（因为如果我们只考虑时间包络，$\\cos(\\omega_n t)$ 在 $t=0$ 时达到最大值）：\n$$\nB_n^\\mathrm{(theory)} = \\left|A_n \\sin\\!\\left(\\frac{n\\pi x_\\mathrm{obs}}{L}\\right)\\right| = \\left| \\frac{2A_0 \\sin(n\\pi p)}{n^2\\pi^2 p(1-p)} \\sin\\!\\left(\\frac{n\\pi x_\\mathrm{obs}}{L}\\right) \\right|\n$$\n\n### 任务2：频谱分析的算法设计\n\n目标是选择数值参数 $\\Delta t$ 和 $T_\\mathrm{total}$，以便于将离散傅里叶变换（DFT）得到的数值频谱与解析模态频率进行直接比较。\n\n解析模态频率为 $f_n = n \\frac{c}{2L}$（$n=1, 2, \\dots$）。基频为 $f_1 = c/(2L)$，对应的周期为 $T_1 = 1/f_1 = 2L/c$。\n\n总时长为 $T_\\mathrm{total}$ 的时间序列的 DFT 频率分辨率为 $\\Delta f = 1/T_\\mathrm{total}$。对应第 $k$ 个 DFT 频箱（其中 $k$ 为整数索引）的频率是 $f^\\mathrm{(DFT)}_k = k \\cdot \\Delta f = k/T_\\mathrm{total}$。\n\n为确保解析频率 $f_n$ 与特定的 DFT 频箱对齐，我们需要对于某组整数频箱索引 $k_n$ 满足 $f_n = f^\\mathrm{(DFT)}_{k_n}$。\n$$\nn \\frac{c}{2L} = \\frac{k_n}{T_\\mathrm{total}} \\implies T_\\mathrm{total} = k_n \\frac{2L}{nc}\n$$\n为了使频箱索引 $k_n$ 成为模态数 $n$ 的简单整数倍，我们可以设置 $k_n = n M$，其中 $M \\ge 1$ 为某个整数。这导出了总模拟时间的选择：\n$$\nT_\\mathrm{total} = (nM) \\frac{2L}{nc} = M \\frac{2L}{c} = M T_1\n$$\n这种选择确保了模拟运行整数个基频周期，即 $M$ 个。对于这个 $T_\\mathrm{total}$，第 $n$ 个模态的频率 $f_n = n \\frac{c}{2L}$ 对应于 DFT 频箱频率 $f^\\mathrm{(DFT)}_{nM} = (nM) / T_\\mathrm{total} = (nM) / (M \\frac{2L}{c}) = n \\frac{c}{2L} = f_n$。因此，第 $n$ 个模态的振幅可以从 DFT 在频箱索引 $k_n = nM$ 处提取。\n\n问题指定使用 Courant–Friedrichs–Lewy (CFL) 数 $\\lambda = \\frac{c\\Delta t}{\\Delta x} = 1$。该值处于显式格式的稳定性极限，并且对于一维波动方程，它在网格上提供了精确解（达朗贝尔解）。这个选择决定了时间步长：\n$$\n\\Delta t = \\frac{\\Delta x}{c} = \\frac{L/(N_x-1)}{c} = \\frac{L}{c(N_x-1)}\n$$\n然后确定模拟所需的总时间步数 $N_t$：\n$$\nN_t = \\left\\lfloor \\frac{T_\\mathrm{total}}{\\Delta t} \\right\\rfloor = \\left\\lfloor \\frac{M \\frac{2L}{c}}{\\frac{L}{c(N_x-1)}} \\right\\rfloor = \\lfloor 2M(N_x-1) \\rfloor = 2M(N_x-1)\n$$\n由于 $M$ 和 $N_x$ 是整数，向下取整操作并非严格必要。\n\n### 任务3：实现与比较\n\n实现过程如下：\n1.  **网格与参数设置：** 对于每个测试用例，定义 $L, c, A_0, N_x, p, x_\\mathrm{obs}, M, K$。根据这些参数计算 $\\Delta x = L/(N_x-1)$，$\\Delta t = \\Delta x/c$，以及 $N_t = 2M(N_x-1)$。空间网格为 $x_j = j\\Delta x$，其中 $j=0, \\dots, N_x-1$。观测点 $x_\\mathrm{obs}$ 映射到最近的网格索引 $j_\\mathrm{obs}$。\n\n2.  **理论振幅：** 计算一个长度为 $K$ 的向量 $B^\\mathrm{(theory)}$。对于每个模态 $n=1,\\dots,K$，使用任务1中推导的公式计算元素 $B_n^\\mathrm{(theory)}$。\n\n3.  **初始化：**\n    *   时间 $n=0$ 时的解 $u_j^0$ 根据分段函数 $u_0(x_j)$ 在网格上初始化。\n    *   时间 $n=1$ 时的解 $u_j^1$ 使用二阶精度的启动公式计算：$u_j^1 = u_j^0 + \\frac{1}{2}\\lambda^2 (u_{j+1}^0 - 2 u_j^0 + u_{j-1}^0)$。由于我们设置了 $\\lambda=1$，这变为 $u_j^1 = u_j^0 + \\frac{1}{2} (u_{j+1}^0 - 2 u_j^0 + u_{j-1}^0)$。边界条件 $u_0^n = u_{N_x-1}^n = 0$ 对所有 $n$ 强制执行。\n\n4.  **时间演化：** 对 $n=1, 2, \\dots, N_t-1$ 将解在时间上推进。内部点（$j=1, \\dots, N_x-2$）的更新规则是：\n    $$\n    u_j^{n+1} = 2 u_j^n - u_j^{n-1} + \\lambda^2 (u_{j+1}^n - 2 u_j^n + u_{j-1}^n)\n    $$\n    当 $\\lambda=1$ 时，这显著简化为：\n    $$\n    u_j^{n+1} = u_{j+1}^n + u_{j-1}^n - u_j^{n-1}\n    $$\n    在每个时间步 $n$，将观测点处的解的值 $u_{j_\\mathrm{obs}}^n$ 存储在一个时间序列数组中。\n\n5.  **频谱分析：**\n    *   计算记录的时间序列的 DFT。\n    *   DFT 通常是复数值。模态 $n$ 的数值谱幅度 $B_n^\\mathrm{(num)}$ 是从 DFT 在频箱索引 $k_n = nM$ 处的幅值中提取的。需要一个归一化因子。对于长度为 $N_t$ 的实数信号，正弦分量的振幅由 $2|\\mathrm{DFT}[k]|/N_t$ 给出。因此，$B_n^\\mathrm{(num)} = \\frac{2}{N_t} |\\mathrm{DFT}[nM]|$。构建一个长度为 $K$ 的向量 $B^\\mathrm{(num)}$。\n\n6.  **归一化与误差计算：**\n    *   两个向量 $B^\\mathrm{(theory)}$ 和 $B^\\mathrm{(num)}$ 都通过各自除以自身的最大元素来进行归一化。记它们为 $\\hat{B}^\\mathrm{(theory)}$ 和 $\\hat{B}^\\mathrm{(num)}$。\n    *   误差度量 $E$ 按这些归一化向量之间的平均绝对差计算：\n    $$\n    E = \\frac{1}{K}\\sum_{n=1}^K \\left| \\hat{B}_n^\\mathrm{(num)} - \\hat{B}_n^\\mathrm{(theory)} \\right|\n    $$\n对所提供的三个测试用例中的每一个都重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D wave equation using a finite difference method and compares\n    the numerical frequency spectrum to the analytical solution for three test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: center pluck, odd-harmonic dominance\n        {'L': 1.0, 'c': 1.0, 'A0': 1.0, 'Nx': 129, 'p': 0.5, 'x_obs': 0.31, 'M': 32, 'K': 8},\n        # Case 2: off-center pluck, mixed harmonics\n        {'L': 1.0, 'c': 2.0, 'A0': 1.0, 'Nx': 129, 'p': 0.3, 'x_obs': 0.37, 'M': 32, 'K': 10},\n        # Case 3: near-end pluck, stronger high-frequency content\n        {'L': 1.0, 'c': 1.5, 'A0': 1.0, 'Nx': 257, 'p': 0.1, 'x_obs': 0.83, 'M': 16, 'K': 12},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract parameters for the current case\n        L = case['L']\n        c = case['c']\n        A0 = case['A0']\n        Nx = case['Nx']\n        p = case['p']\n        x_obs = case['x_obs']\n        M = case['M']\n        K = case['K']\n\n        # --- Task 1: Theoretical Amplitudes ---\n        n_modes = np.arange(1, K + 1)\n        \n        # Derived formula for An\n        # An = (2 * A0 * sin(n*pi*p)) / ( (n*pi)^2 * p * (1-p) )\n        numerator = 2 * A0 * np.sin(n_modes * np.pi * p)\n        denominator = (n_modes * np.pi)**2 * p * (1 - p)\n        # Handle cases where sin(n*pi*p) is zero, to avoid 0/0 if p makes denominator zero\n        An = np.divide(numerator, denominator, out=np.zeros_like(numerator), where=denominator!=0)\n\n        # Theoretical amplitude at observation point\n        B_theory = np.abs(An * np.sin(n_modes * np.pi * x_obs / L))\n        \n        # --- Task 2  3: Numerical Simulation and Comparison ---\n        \n        # Grid and time parameters\n        dx = L / (Nx - 1)\n        # CFL lambda = 1 is specified\n        dt = dx / c\n        # Total simulation time T_total = M * 2*L/c\n        # Total number of time steps Nt = T_total / dt\n        Nt = 2 * M * (Nx - 1)\n        \n        x_grid = np.linspace(0, L, Nx)\n        j_obs = np.argmin(np.abs(x_grid - x_obs))\n\n        # Initial condition u(x,0)\n        u0 = np.zeros(Nx)\n        pluck_pos = p * L\n        mask1 = x_grid = pluck_pos\n        mask2 = x_grid  pluck_pos\n        \n        # Apply piecewise definition\n        if p  0:\n             u0[mask1] = (A0 / pluck_pos) * x_grid[mask1]\n        if (1-p)  0:\n             u0[mask2] = (A0 / (L - pluck_pos)) * (L - x_grid[mask2])\n\n        # Initial condition for the first time step u(x, dt)\n        # using u_j^1 = u_j^0 + 0.5 * lambda^2 * (u_{j+1}^0 - 2*u_j^0 + u_{j-1}^0)\n        # for lambda = 1\n        u1 = u0.copy()\n        u1[1:-1] = u0[1:-1] + 0.5 * (u0[2:] - 2*u0[1:-1] + u0[:-2])\n        # Boundaries are fixed at 0, which is naturally handled.\n\n        # Time evolution\n        u_prev = u0.copy()\n        u_curr = u1.copy()\n        time_series = np.zeros(Nt)\n        time_series[0] = u_prev[j_obs]\n        time_series[1] = u_curr[j_obs]\n\n        # FDM loop with lambda=1 simplified update rule\n        # u_j^{n+1} = u_{j+1}^n + u_{j-1}^n - u_j^{n-1}\n        for n in range(1, Nt - 1):\n            u_next = np.zeros(Nx)\n            u_next[1:-1] = u_curr[2:] + u_curr[:-2] - u_prev[1:-1]\n            u_prev, u_curr = u_curr, u_next\n            time_series[n + 1] = u_curr[j_obs]\n\n        # Spectral analysis of the numerical result\n        dft_result = np.fft.fft(time_series)\n        k_indices = n_modes * M\n        \n        # DFT amplitude normalization for a real signal\n        B_num = (2.0 / Nt) * np.abs(dft_result[k_indices])\n\n        # Normalization and error calculation\n        max_B_theory = np.max(B_theory)\n        if max_B_theory  0:\n            B_theory_norm = B_theory / max_B_theory\n        else: # Handle case where all theoretical values are zero\n            B_theory_norm = B_theory\n            \n        max_B_num = np.max(B_num)\n        if max_B_num  0:\n            B_num_norm = B_num / max_B_num\n        else: # Handle case where all numerical values are zero\n            B_num_norm = B_num\n\n        error = np.mean(np.abs(B_num_norm - B_theory_norm))\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "3229336"}]}