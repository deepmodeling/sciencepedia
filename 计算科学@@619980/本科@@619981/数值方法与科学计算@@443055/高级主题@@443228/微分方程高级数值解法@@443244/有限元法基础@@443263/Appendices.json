{"hands_on_practices": [{"introduction": "掌握有限元方法 (FEM) 的第一步，也是最重要的一步，就是亲手编写一个简单的求解器。这个实践将引导你将抽象的理论转化为具体、可运行的代码，涵盖从参考单元、形函数到全局组装和边界条件施加的全过程。通过为每个模块设计单元测试，你将不仅构建一个求解器，更会深刻理解其每个组件的工作原理 [@problem_id:3230085]。", "problem": "从第一性原理出发，实现一个一维有限元方法（FEM）代码，用于求解模型边值问题：在闭区间 $[0,1]$ 上求 $u$ 使得 $-u'' = f$，并满足齐次 Dirichlet 边界条件 $u(0)=0$ 和 $u(1)=0$。从核心的变分定义开始：在 Sobolev 空间 $H_0^1(0,1)$ 中求 $u$，使得双线性形式和线性泛函满足\n$$\n\\int_0^1 u'(x)\\,v'(x)\\,dx = \\int_0^1 f(x)\\,v(x)\\,dx \\quad \\text{for all } v \\in H_0^1(0,1).\n$$\n使用一个包含 $N$ 个均匀子区间的 $[0,1]$ 网格，参考单元上的线性 Lagrange 基函数，从参考单元到每个物理单元的等参映射，以及一个对最高3次多项式精确的高斯-勒让德求积法则来近似单元积分。组装全局线性系统，并通过消除边界自由度来施加齐次 Dirichlet 边界条件。您的实现必须是模块化的，并且必须展示每个步骤：参考单元定义、形函数求值、数值积分、局部单元矩阵和向量计算、全局组装、边界条件应用以及线性求解器。\n\n仅从以下基本依据出发，推导您实现中所需的所有公式：\n- 上文给出的弱（变分）形式。\n- 在参考单元 $[0,1]$ 上，线性基函数 $\\{\\hat{\\varphi}_1,\\hat{\\varphi}_2\\}$ 在参考节点 $\\xi_1=0$ 和 $\\xi_2=1$ 处满足 Lagrange 插值条件 $\\hat{\\varphi}_i(\\xi_j)=\\delta_{ij}$。\n- 从参考单元到物理单元的仿射映射下的积分变量替换公式。\n- 在 $[-1,1]$ 上的高斯-勒让德求积节点和权重的定义，以及它们到 $[0,1]$ 的仿射变换。\n\n设计您的程序以计算一个诊断测试套件，用于验证单个组件和端到端解决方案。使用以下测试和约定：\n- 所有理论上精确的比较都应在 $10^{-14}$ 的绝对容差内进行验证。\n- 对于要求浮点误差的测试，如果可能，请解析地计算精确值，并以非负实数形式报告绝对误差。\n- 对于矩阵对称性，使用矩阵与其转置之差的 Frobenius 范数来量化对称性误差。\n\n需要实现并按此确切顺序报告的测试套件：\n1. 参考形函数：验证参考单元 $[0,1]$ 上线性 Lagrange 基的节点插值性质和单位分解性。具体而言，检查 $\\hat{\\varphi}_1(0)=1$, $\\hat{\\varphi}_2(0)=0$, $\\hat{\\varphi}_1(1)=0$, $\\hat{\\varphi}_2(1)=1$, $\\hat{\\varphi}_1(1/2)=\\hat{\\varphi}_2(1/2)$，以及对于 $\\xi \\in \\{0,1/2,1\\}$ 都有 $\\hat{\\varphi}_1(\\xi)+\\hat{\\varphi}_2(\\xi)=1$。输出一个布尔值，当且仅当所有这些检查都在规定的容差内通过时，该值为真。\n2. 求积精确性：在 $[0,1]$ 上使用2点高斯-勒让德法则，对 $k \\in \\{0,1,2,3\\}$ 的 $x^k$ 进行数值积分，并报告这4种情况下的最大绝对误差（精确积分为 $\\int_0^1 x^k\\,dx = 1/(k+1)$）。\n3. 单位单元上的局部刚度矩阵：对于物理单元 $[0,1]$，使用您的参考基、映射和求积法则计算局部刚度矩阵。同时，通过对 $[0,1]$ 上形函数的梯度进行解析积分，计算精确的局部刚度矩阵。以非负实数形式报告数值计算和精确计算的局部刚度矩阵之差的 Frobenius 范数。\n4. 粗网格上的端到端求解精度：设 $f(x) = \\pi^2 \\sin(\\pi x)$，此时精确解为 $u(x) = \\sin(\\pi x)$。在包含 $N=2$ 个单元的均匀网格上求解有限元系统。以非负实数形式报告最大绝对节点误差 $\\max_i |u_h(x_i) - u(x_i)|$。\n5. 细网格上的端到端求解精度：使用 $N=10$ 个单元重复测试4，并以非负实数形式报告最大绝对节点误差。\n6. 对称性与正定性：对于 $N=4$ 和 $f(x)=1$，在施加齐次 Dirichlet 边界条件后，组装简化的全局刚度矩阵。输出一个布尔值，当且仅当简化后的矩阵在规定容差内对称且其所有特征值均为严格正数时，该值为真。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起，按测试1到6的顺序排列结果，例如 $\\texttt{[result1,result2,result3,result4,result5,result6]}$。\n- 所有布尔值必须是字面量 $\\texttt{True}$ 或 $\\texttt{False}$，所有实数必须以标准十进制表示法打印。任何输出都不需要单位。", "solution": "用户要求从第一性原理出发，为泊松方程实现一个一维有限元方法（FEM）求解器。本文档概述了所需公式的理论推导，并遵循了指定的约束条件。\n\n### 1. 变分形式与离散化\n\n模型问题是定义域 $\\Omega = [0,1]$ 上的边值问题（BVP）：\n$$ -u''(x) = f(x) \\quad \\text{for } x \\in (0,1) $$\n$$ u(0) = 0, \\quad u(1) = 0 $$\n有限元方法从弱（或变分）形式开始。我们将微分方程乘以一个来自合适函数空间的检验函数 $v$，然后在整个定义域上进行积分：\n$$ -\\int_0^1 u''(x) v(x) \\,dx = \\int_0^1 f(x) v(x) \\,dx $$\n对左侧应用分部积分法得到：\n$$ \\int_0^1 u'(x) v'(x) \\,dx - [u'(x)v(x)]_0^1 = \\int_0^1 f(x) v(x) \\,dx $$\n我们在 Sobolev 空间 $H_0^1(0,1)$ 中寻找解 $u$，该空间是平方可积、一阶导数平方可积且满足齐次 Dirichlet 边界条件的函数空间。通过从同一空间 $H_0^1(0,1)$ 中选择检验函数 $v$，边界项 $[u'(x)v(x)]_0^1$ 因为 $v(0)=v(1)=0$ 而消失。这得到了所需的弱形式：求 $u \\in H_0^1(0,1)$ 使得\n$$ \\int_0^1 u'(x) v'(x) \\,dx = \\int_0^1 f(x) v(x) \\,dx \\quad \\text{for all } v \\in H_0^1(0,1) $$\n有限元方法通过在有限维子空间 $V_h \\subset H_0^1(0,1)$ 中寻找近似解 $u_h$ 来离散化此问题。定义域 $[0,1]$ 被划分为 $N$ 个长度为 $h=1/N$ 的均匀子区间（单元）$K_e = [x_e, x_{e+1}]$。该网格的节点为 $x_i = i h$，$i=0, \\dots, N$。子空间 $V_h$ 由连续的分段线性基函数（“帽函数”）$\\phi_i(x)$ 张成，其定义为 $\\phi_i(x_j) = \\delta_{ij}$。近似解表示为这些基函数的线性组合：\n$$ u_h(x) = \\sum_{j=0}^{N} U_j \\phi_j(x) $$\n其中 $U_j=u_h(x_j)$ 是未知的节点值。Galerkin 方法将检验函数 $v$ 设置为基函数 $\\phi_i$，$i=0, \\dots, N$。这导出一个线性方程组 $AU=F$，其中 $A_{ij} = \\int_0^1 \\phi_j'(x) \\phi_i'(x) \\,dx$ 且 $F_i = \\int_0^1 f(x) \\phi_i(x) \\,dx$。\n\n### 2. 参考单元、基函数和映射\n\n为了标准化计算，所有在物理单元 $K_e = [x_e, x_{e+1}]$ 上的积分都被变换到参考单元 $\\hat{K}=[0,1]$ 上。\n\n**参考基函数**：在 $\\hat{K}$ 上，我们为对应于局部节点 $\\xi_1=0$ 和 $\\xi_2=1$ 的 $i=1,2$ 定义局部线性基函数 $\\hat{\\varphi}_i(\\xi)$。它们由 Lagrange 插值条件 $\\hat{\\varphi}_i(\\xi_j) = \\delta_{ij}$ 定义。\n对于 $\\hat{\\varphi}_1(\\xi) = a\\xi+b$：\n条件 $\\hat{\\varphi}_1(0)=1$ 和 $\\hat{\\varphi}_1(1)=0$ 得到 $b=1$ 和 $a=-1$。因此，$\\hat{\\varphi}_1(\\xi) = 1-\\xi$。\n对于 $\\hat{\\varphi}_2(\\xi) = c\\xi+d$：\n条件 $\\hat{\\varphi}_2(0)=0$ 和 $\\hat{\\varphi}_2(1)=1$ 得到 $d=0$ 和 $c=1$。因此，$\\hat{\\varphi}_2(\\xi) = \\xi$。\n这些参考基函数的导数是常数：$\\frac{d\\hat{\\varphi}_1}{d\\xi} = -1$ 和 $\\frac{d\\hat{\\varphi}_2}{d\\xi} = 1$。\n\n**等参映射**：仿射映射 $F_e: \\hat{K} \\to K_e$ 使用相同的基函数定义：$x(\\xi) = x_e \\hat{\\varphi}_1(\\xi) + x_{e+1} \\hat{\\varphi}_2(\\xi) = x_e(1-\\xi) + x_{e+1}\\xi$。对于均匀网格，这简化为 $x(\\xi) = x_e + h\\xi$。\n该变换的雅可比行列式是 $J_e = \\frac{dx}{d\\xi} = h$。根据链式法则，关于 $x$ 的导数通过 $\\frac{d}{dx} = \\frac{d\\xi}{dx}\\frac{d}{d\\xi} = \\frac{1}{J_e}\\frac{d}{d\\xi} = \\frac{1}{h}\\frac{d}{d\\xi}$ 与关于 $\\xi$ 的导数相关联。\n\n### 3. 数值积分\n\n问题要求在 $[0,1]$ 上使用一个对最高3次多项式精确的高斯-勒让德求积法则。一个 $n$ 点高斯-勒让德法则对次数为 $2n-1$ 的多项式是精确的。因此，我们需要 $2n-1 \\geq 3$，这意味着 $n \\geq 2$。我们选择一个2点法则。标准节点 $\\hat{z}_k$ 和权重 $\\hat{w}_k$ 定义在 $[-1,1]$ 上：\n$$ \\hat{z}_1 = -1/\\sqrt{3}, \\quad \\hat{z}_2 = 1/\\sqrt{3} \\qquad \\hat{w}_1 = 1, \\quad \\hat{w}_2 = 1 $$\n我们使用仿射映射 $\\xi(\\hat{z}) = \\frac{1}{2}(\\hat{z}+1)$ 将它们变换到参考单元 $\\hat{K}=[0,1]$。这个映射的雅可比行列式是 $\\frac{d\\xi}{d\\hat{z}} = 1/2$。$[0,1]$ 上的求积节点 $\\xi_q$ 是 $\\hat{z}_k$ 的像，权重 $w_q$ 按雅可比行列式进行缩放：\n$$ \\xi_q = \\frac{1}{2}(\\hat{z}_q+1), \\quad w_q = \\hat{w}_q \\cdot \\frac{1}{2} $$\n这给出了法则 $\\int_0^1 g(\\xi) d\\xi \\approx \\sum_{q=1}^2 w_q g(\\xi_q)$，其中：\n- 节点: $\\xi_1 = \\frac{1}{2}(1 - 1/\\sqrt{3})$, $\\xi_2 = \\frac{1}{2}(1 + 1/\\sqrt{3})$。\n- 权重: $w_1 = 1/2$, $w_2 = 1/2$。\n\n### 4. 单元刚度矩阵和载荷向量\n\n全局刚度矩阵 $A$ 和载荷向量 $F$ 的项是由单元级的贡献组装而成的。\n\n**局部刚度矩阵**：对于单元 $K_e$，$2 \\times 2$ 的局部刚度矩阵 $A^{(e)}$ 的项为 $A_{ij}^{(e)} = \\int_{K_e} (\\varphi_j^{(e)})'(x) (\\varphi_i^{(e)})'(x) \\,dx$，其中 $\\varphi_i^{(e)}$ 是局部基函数。变换到参考单元：\n$$ A_{ij}^{(e)} = \\int_0^1 \\left(\\frac{1}{h}\\frac{d\\hat{\\varphi}_j}{d\\xi}\\right) \\left(\\frac{1}{h}\\frac{d\\hat{\\varphi}_i}{d\\xi}\\right) h \\,d\\xi = \\frac{1}{h} \\int_0^1 \\frac{d\\hat{\\varphi}_i}{d\\xi} \\frac{d\\hat{\\varphi}_j}{d\\xi} \\,d\\xi $$\n由于参考基函数的导数是常数，被积函数是一个常数（0次多项式）。我们的2点求积法则对该积分是精确的。解析地进行积分：\n$A_{11}^{(e)} = \\frac{1}{h} \\int_0^1 (-1)(-1) d\\xi = \\frac{1}{h}$，\n$A_{12}^{(e)} = A_{21}^{(e)} = \\frac{1}{h} \\int_0^1 (-1)(1) d\\xi = -\\frac{1}{h}$，\n$A_{22}^{(e)} = \\frac{1}{h} \\int_0^1 (1)(1) d\\xi = \\frac{1}{h}$。\n因此，局部刚度矩阵是 $A^{(e)} = \\frac{1}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$。\n\n**局部载荷向量**：$2 \\times 1$ 的局部载荷向量 $F^{(e)}$ 的项为 $F_i^{(e)} = \\int_{K_e} f(x) \\varphi_i^{(e)}(x) \\,dx$。变换到参考单元并应用求积法则：\n$$ F_i^{(e)} = \\int_0^1 f(x(\\xi)) \\hat{\\varphi}_i(\\xi) h \\,d\\xi \\approx h \\sum_{q=1}^2 w_q f(x_e + h \\xi_q) \\hat{\\varphi}_i(\\xi_q) $$\n\n### 5. 组装、边界条件和求解\n\n全局矩阵 $A$（大小为 $(N+1) \\times (N+1)$）和 $F$（大小为 $(N+1) \\times 1$）是通过对所有局部矩阵 $A^{(e)}$ 和向量 $F^{(e)}$ 的贡献求和来构建的。单元 $e$ 上的局部索引 $(1, 2)$ 映射到全局索引 $(e, e+1)$。\n\n齐次 Dirichlet 边界条件 $u(0)=0$ 和 $u(1)=0$ 意味着节点值 $U_0$ 和 $U_N$ 为零。这些自由度从线性系统中被消除。这通过从全局刚度矩阵 $A$ 中移除第一行和最后一行以及第一列和最后一列，并从全局载荷向量 $F$ 中移除第一个和最后一个条目来实现。这产生一个大小为 $(N-1) \\times (N-1)$ 的简化线性系统 $A_{red} U_{red} = F_{red}$，其中 $U_{red}=[U_1, \\dots, U_{N-1}]^T$。简化的刚度矩阵 $A_{red}$ 是对称且正定的，保证了唯一解的存在。求解该系统以获得未知的内部节点值。然后将完整的解向量组装为 $U = [0, U_1, \\dots, U_{N-1}, 0]^T$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a 1D FEM solver and runs a diagnostic test suite.\n    \"\"\"\n    TOL = 1e-14\n\n    # ------------------ Core FEM Components ------------------\n\n    def get_reference_element_data():\n        \"\"\"\n        Defines basis functions and quadrature on the reference element [0,1].\n        \"\"\"\n        # Linear Lagrange basis functions and their derivatives on [0,1]\n        phi_hat = [lambda xi: 1 - xi, lambda xi: xi]\n        d_phi_hat = [lambda xi: -1.0, lambda xi: 1.0]\n\n        # 2-point Gauss-Legendre quadrature on [0,1]\n        # Transformed from standard rule on [-1,1]\n        quad_points = [0.5 * (1 - 1/np.sqrt(3)), 0.5 * (1 + 1/np.sqrt(3))]\n        quad_weights = [0.5, 0.5]\n\n        return phi_hat, d_phi_hat, quad_points, quad_weights\n\n    def compute_local_stiffness(h, d_phi_hat, quad_points, quad_weights):\n        \"\"\"\n        Numerically computes the 2x2 local stiffness matrix.\n        \"\"\"\n        A_local = np.zeros((2, 2))\n        for i in range(2):\n            for j in range(2):\n                integrand_val = 0\n                for q_idx in range(len(quad_points)):\n                    xi = quad_points[q_idx]\n                    w = quad_weights[q_idx]\n                    integrand_val += d_phi_hat[i](xi) * d_phi_hat[j](xi) * w\n                A_local[i, j] = (1/h) * integrand_val\n        return A_local\n\n    def compute_local_load(f, xe, h, phi_hat, quad_points, quad_weights):\n        \"\"\"\n        Numerically computes the 2x1 local load vector.\n        \"\"\"\n        F_local = np.zeros(2)\n        for i in range(2):\n            integrand_val = 0\n            for q_idx in range(len(quad_points)):\n                xi = quad_points[q_idx]\n                w = quad_weights[q_idx]\n                # Map reference coordinate xi to physical coordinate x\n                x = xe + h * xi\n                integrand_val += f(x) * phi_hat[i](xi) * w\n            F_local[i] = h * integrand_val\n        return F_local\n\n    def solve_bvp(N, f):\n        \"\"\"\n        Solves -u'' = f on [0,1] with u(0)=u(1)=0 using N elements.\n        \"\"\"\n        h = 1.0 / N\n        nodes = np.linspace(0, 1, N + 1)\n\n        phi_hat, d_phi_hat, quad_points, quad_weights = get_reference_element_data()\n\n        # Assembly\n        A_global = np.zeros((N + 1, N + 1))\n        F_global = np.zeros(N + 1)\n\n        for e in range(N):\n            xe = nodes[e]\n            A_local = compute_local_stiffness(h, d_phi_hat, quad_points, quad_weights)\n            F_local = compute_local_load(f, xe, h, phi_hat, quad_points, quad_weights)\n            \n            # Add local contributions to global matrices\n            global_indices = [e, e + 1]\n            for i in range(2):\n                for j in range(2):\n                    A_global[global_indices[i], global_indices[j]] += A_local[i, j]\n                F_global[global_indices[i]] += F_local[i]\n\n        # Apply homogeneous Dirichlet boundary conditions\n        interior_indices = slice(1, N)\n        A_reduced = A_global[interior_indices, interior_indices]\n        F_reduced = F_global[interior_indices]\n\n        # Solve the linear system\n        if A_reduced.shape[0] > 0:\n            U_reduced = np.linalg.solve(A_reduced, F_reduced)\n        else: # Case N=1, no interior nodes\n            U_reduced = np.array([])\n            \n        # Construct full solution vector\n        U_full = np.zeros(N + 1)\n        U_full[interior_indices] = U_reduced\n\n        return nodes, U_full, A_reduced\n\n    # ------------------ Test Suite ------------------\n    \n    results = []\n\n    # Test 1: Reference shape functions\n    def test_1():\n        phi_hat, _, _, _ = get_reference_element_data()\n        ph1, ph2 = phi_hat[0], phi_hat[1]\n        \n        c1 = abs(ph1(0.0) - 1.0) < TOL\n        c2 = abs(ph2(0.0) - 0.0) < TOL\n        c3 = abs(ph1(1.0) - 0.0) < TOL\n        c4 = abs(ph2(1.0) - 1.0) < TOL\n        c5 = abs(ph1(0.5) - ph2(0.5)) < TOL\n        \n        partition_of_unity_ok = True\n        for xi_test in [0.0, 0.5, 1.0]:\n            if abs(ph1(xi_test) + ph2(xi_test) - 1.0) > TOL:\n                partition_of_unity_ok = False\n                break\n        \n        return all([c1, c2, c3, c4, c5, partition_of_unity_ok])\n    results.append(test_1())\n\n    # Test 2: Quadrature exactness\n    def test_2():\n        _, _, quad_points, quad_weights = get_reference_element_data()\n        errors = []\n        for k in range(4): # k=0, 1, 2, 3\n            g = lambda x: x**k\n            exact_integral = 1.0 / (k + 1)\n            \n            numeric_integral = 0.0\n            for i in range(len(quad_points)):\n                numeric_integral += quad_weights[i] * g(quad_points[i])\n            \n            errors.append(abs(numeric_integral - exact_integral))\n        return max(errors)\n    results.append(test_2())\n\n    # Test 3: Local stiffness matrix on the unit element\n    def test_3():\n        _, d_phi_hat, quad_points, quad_weights = get_reference_element_data()\n        A_num = compute_local_stiffness(1.0, d_phi_hat, quad_points, quad_weights)\n        A_exact = np.array([[1.0, -1.0], [-1.0, 1.0]])\n        diff_norm = np.linalg.norm(A_num - A_exact, 'fro')\n        return diff_norm\n    results.append(test_3())\n\n    # Test 4  5: End-to-end solution accuracy\n    f_test = lambda x: np.pi**2 * np.sin(np.pi * x)\n    u_exact_func = lambda x: np.sin(np.pi * x)\n\n    def run_e2e_test(N, f, u_exact):\n        nodes, U_h, _ = solve_bvp(N, f)\n        u_exact_vals = u_exact(nodes)\n        nodal_errors = np.abs(U_h - u_exact_vals)\n        return np.max(nodal_errors)\n    \n    # Test 4\n    results.append(run_e2e_test(N=2, f=f_test, u_exact=u_exact_func))\n\n    # Test 5\n    results.append(run_e2e_test(N=10, f=f_test, u_exact=u_exact_func))\n\n    # Test 6: Symmetry and positive definiteness\n    def test_6():\n        _, _, A_red = solve_bvp(N=4, f=lambda x: 1.0)\n        \n        # Symmetry check\n        symmetry_error = np.linalg.norm(A_red - A_red.T, 'fro')\n        is_symmetric = symmetry_error  TOL\n        \n        # Positive definiteness check\n        eigenvalues = np.linalg.eigvalsh(A_red)\n        is_pd = np.all(eigenvalues  0)\n        \n        return is_symmetric and is_pd\n    results.append(test_6())\n    \n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3230085"}, {"introduction": "在实现了一维求解器后，我们将从编程转向解析推导，这是理解有限元数学核心的关键一步。本实践要求你为最常用的二维单元——线性三角形单元——手动推导其刚度矩阵和质量矩阵。通过这个过程，你将清晰地看到单元的几何形状和基函数是如何转化为离散线性系统的，而这在现成软件中通常是“黑箱”操作 [@problem_id:3229959]。", "problem": "考虑在有限元法（FEM）中使用的参考三角形，其顶点位于 $ (0,0) $、$ (1,0) $ 和 $ (0,1) $。令 $ T $ 表示此三角形，并令 $ \\{N_1(x,y), N_2(x,y), N_3(x,y)\\} $ 为与三个顶点相关联的线性 Lagrange 形函数，其定义满足基本插值性质，即 $ N_i $ 在顶点 $ i $ 处等于 $ 1 $，在另外两个顶点处等于 $ 0 $。仅使用第一性原理和核心定义，按如下步骤进行：\n\n1. 推导 $ N_1(x,y) $、$ N_2(x,y) $ 和 $ N_3(x,y) $ 的符号表达式，并验证单位分解性质 $ N_1 + N_2 + N_3 = 1 $ 和线性完备性（即 $ x $ 和 $ y $ 可以通过形函数的适当线性组合被精确再生）。\n\n2. 使用解析积分 $ \\int_T 1 \\, \\mathrm{d}A $ 计算 $ T $ 的面积 $ A $，并确认其值。\n\n3. 计算 $ T $ 上的常梯度 $ \\nabla N_1 $、$ \\nabla N_2 $ 和 $ \\nabla N_3 $，并通过直接积分验证由下式定义的单元刚度矩阵 $ K \\in \\mathbb{R}^{3 \\times 3} $ 的元素：\n$$\nK_{ij} \\;=\\; \\int_T \\nabla N_i \\cdot \\nabla N_j \\, \\mathrm{d}A \\quad \\text{for } i,j \\in \\{1,2,3\\}.\n$$\n解释为什么 $ K $ 有一个一维零空间。\n\n4. 通过解析积分计算由下式定义的一致单元质量矩阵 $ M \\in \\mathbb{R}^{3 \\times 3} $ 的元素：\n$$\nM_{ij} \\;=\\; \\int_T N_i \\, N_j \\, \\mathrm{d}A \\quad \\text{for } i,j \\in \\{1,2,3\\}.\n$$\n\n你的最终任务是给出该三角形的质量矩阵 $ M $ 的行列式的精确值。将最终答案表示为单个无单位的实数。无需四舍五入。", "solution": "该问题是适定的，并且是有限元法中的一个基本练习。我们按照要求进行系统的推导和计算。\n\n设参考三角形 $T$ 的顶点为 $P_1 = (0,0)$、$P_2 = (1,0)$ 和 $P_3 = (0,1)$。\n\n**1. 形函数的推导与性质验证**\n\n线性 Lagrange 形函数 $N_i(x,y)$ 的一般形式为 $N_i(x,y) = a_i + b_i x + c_i y$。系数 $a_i, b_i, c_i$ 由基本插值性质 $N_i(P_j) = \\delta_{ij}$ 决定，其中 $\\delta_{ij}$ 是 Kronecker δ。\n\n对于与顶点 $P_1=(0,0)$ 相关联的 $N_1(x,y)$：\n- $N_1(0,0) = a_1 = 1$\n- $N_1(1,0) = a_1 + b_1(1) + c_1(0) = 1 + b_1 = 0 \\implies b_1 = -1$\n- $N_1(0,1) = a_1 + b_1(0) + c_1(1) = 1 + c_1 = 0 \\implies c_1 = -1$\n因此，$N_1(x,y) = 1 - x - y$。\n\n对于与顶点 $P_2=(1,0)$ 相关联的 $N_2(x,y)$：\n- $N_2(0,0) = a_2 = 0$\n- $N_2(1,0) = a_2 + b_2(1) + c_2(0) = b_2 = 1$\n- $N_2(0,1) = a_2 + b_2(0) + c_2(1) = a_2 + c_2 = 0 \\implies c_2 = 0$\n因此，$N_2(x,y) = x$。\n\n对于与顶点 $P_3=(0,1)$ 相关联的 $N_3(x,y)$：\n- $N_3(0,0) = a_3 = 0$\n- $N_3(1,0) = a_3 + b_3(1) + c_3(0) = a_3 + b_3 = 0 \\implies b_3 = 0$\n- $N_3(0,1) = a_3 + b_3(0) + c_3(1) = c_3 = 1$\n因此，$N_3(x,y) = y$。\n\n推导出的形函数为 $N_1(x,y) = 1-x-y$，$N_2(x,y) = x$ 和 $N_3(x,y) = y$。这些是该三角形的重心坐标。\n\n单位分解性质验证：\n$$ N_1(x,y) + N_2(x,y) + N_3(x,y) = (1-x-y) + x + y = 1 $$\n该和在整个平面上恒等于 $1$，因此验证了单位分解性质。\n\n线性完备性验证：\n一个线性场 $f(x,y)=c_0 + c_1 x + c_2 y$ 可以表示为形函数的线性组合，$f(x,y) = \\sum_{i=1}^3 f(P_i) N_i(x,y)$。\n为再生坐标函数 $x$，令 $f(x,y) = x$。节点值为 $f(P_1)=0$、$f(P_2)=1$、$f(P_3)=0$。\n$$ \\sum_{i=1}^3 x_i N_i(x,y) = (0)N_1(x,y) + (1)N_2(x,y) + (0)N_3(x,y) = N_2(x,y) = x $$\n为再生坐标函数 $y$，令 $f(x,y) = y$。节点值为 $f(P_1)=0$、$f(P_2)=0$、$f(P_3)=1$。\n$$ \\sum_{i=1}^3 y_i N_i(x,y) = (0)N_1(x,y) + (0)N_2(x,y) + (1)N_3(x,y) = N_3(x,y) = y $$\n这证实了线性基能够精确表示任何线性函数，满足线性完备性。\n\n**2. T 的面积计算**\n\n三角形 $T$ 的面积 $A$ 由在其域上对 $1$ 的积分给出。该域由 $0 \\le x \\le 1$ 和 $0 \\le y \\le 1-x$ 描述。\n$$ A = \\int_T 1 \\, \\mathrm{d}A = \\int_0^1 \\left( \\int_0^{1-x} 1 \\, \\mathrm{d}y \\right) \\mathrm{d}x $$\n$$ A = \\int_0^1 [y]_0^{1-x} \\, \\mathrm{d}x = \\int_0^1 (1-x) \\, \\mathrm{d}x = \\left[x - \\frac{x^2}{2}\\right]_0^1 = 1 - \\frac{1}{2} = \\frac{1}{2} $$\n面积为 $A = 1/2$，这与底为 $1$、高为 $1$ 的三角形的标准面积公式一致。\n\n**3. 单元刚度矩阵 K 的计算**\n\n首先，我们计算形函数的梯度：\n$$ \\nabla N_1 = \\begin{pmatrix} \\frac{\\partial N_1}{\\partial x} \\\\ \\frac{\\partial N_1}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix} $$\n$$ \\nabla N_2 = \\begin{pmatrix} \\frac{\\partial N_2}{\\partial x} \\\\ \\frac{\\partial N_2}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} $$\n$$ \\nabla N_3 = \\begin{pmatrix} \\frac{\\partial N_3}{\\partial x} \\\\ \\frac{\\partial N_3}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} $$\n梯度是常向量。刚度矩阵的元素为 $K_{ij} = \\int_T \\nabla N_i \\cdot \\nabla N_j \\, \\mathrm{d}A$。由于被积函数 $\\nabla N_i \\cdot \\nabla N_j$ 在 $T$ 上是常数，该积分就是这个常数与面积 $A$ 的乘积。\n$$ K_{ij} = (\\nabla N_i \\cdot \\nabla N_j) A = \\frac{1}{2}(\\nabla N_i \\cdot \\nabla N_j) $$\n我们计算必要的点积：\n- $\\nabla N_1 \\cdot \\nabla N_1 = (-1)^2 + (-1)^2 = 2$\n- $\\nabla N_2 \\cdot \\nabla N_2 = 1^2 + 0^2 = 1$\n- $\\nabla N_3 \\cdot \\nabla N_3 = 0^2 + 1^2 = 1$\n- $\\nabla N_1 \\cdot \\nabla N_2 = (-1)(1) + (-1)(0) = -1$\n- $\\nabla N_1 \\cdot \\nabla N_3 = (-1)(0) + (-1)(1) = -1$\n- $\\nabla N_2 \\cdot \\nabla N_3 = (1)(0) + (0)(1) = 0$\n使用这些值，以及对称性 $K_{ij}=K_{ji}$：\n$$ K = \\frac{1}{2} \\begin{pmatrix} 2  -1  -1 \\\\ -1  1  0 \\\\ -1  0  1 \\end{pmatrix} = \\begin{pmatrix} 1  -1/2  -1/2 \\\\ -1/2  1/2  0 \\\\ -1/2  0  1/2 \\end{pmatrix} $$\n矩阵 $K$ 有一个一维零空间。如果 $K\\mathbf{u}=\\mathbf{0}$，则向量 $\\mathbf{u} = (u_1, u_2, u_3)^T$ 在 $K$ 的零空间中。这对应于一个离散函数 $u_h(x,y) = \\sum_{i=1}^3 u_i N_i(x,y)$，其 Dirichlet 能量为零：\n$$ \\mathbf{u}^T K \\mathbf{u} = \\int_T \\nabla u_h \\cdot \\nabla u_h \\, \\mathrm{d}A = \\int_T |\\nabla u_h|^2 \\, \\mathrm{d}A = 0 $$\n由于被积函数是非负的，积分仅在 $\\nabla u_h = \\mathbf{0}$ 在 $T$ 中处处成立时才为零。这意味着 $u_h(x,y)$ 必须是一个常数函数，例如 $u_h(x,y) = c$。在顶点处求值，我们得到 $u_1=c$、$u_2=c$ 和 $u_3=c$。因此，零空间中的任何向量都必须是 $\\mathbf{u}=c(1,1,1)^T$ 的形式。这描述了一个由向量 $(1,1,1)^T$ 张成的一维子空间。这个零空间对应于具有零梯度的常数函数（例如，常数势、刚体平移）。\n\n**4. 单元质量矩阵 M 的计算**\n\n质量矩阵的元素为 $M_{ij} = \\int_T N_i N_j \\, \\mathrm{d}A$。我们使用三角形上重心坐标的积分公式：\n$$ \\int_T N_1^\\alpha N_2^\\beta N_3^\\gamma \\, \\mathrm{d}A = (2A) \\frac{\\alpha! \\beta! \\gamma!}{(\\alpha+\\beta+\\gamma+2)!} $$\n由于 $A = 1/2$，所以 $2A = 1$，该公式简化为 $\\int_T N_1^\\alpha N_2^\\beta N_3^\\gamma \\, \\mathrm{d}A = \\frac{\\alpha! \\beta! \\gamma!}{(\\alpha+\\beta+\\gamma+2)!}$。\n\n对角元素：\n- $M_{11} = \\int_T N_1^2 \\, \\mathrm{d}A = \\frac{2!0!0!}{(2+0+0+2)!} = \\frac{2}{4!} = \\frac{2}{24} = \\frac{1}{12}$\n- $M_{22} = \\int_T N_2^2 \\, \\mathrm{d}A = \\frac{0!2!0!}{(0+2+0+2)!} = \\frac{2}{4!} = \\frac{2}{24} = \\frac{1}{12}$\n- $M_{33} = \\int_T N_3^2 \\, \\mathrm{d}A = \\frac{0!0!2!}{(0+0+2+2)!} = \\frac{2}{4!} = \\frac{2}{24} = \\frac{1}{12}$\n\n非对角元素（根据对称性 $M_{ij}=M_{ji}$）：\n- $M_{12} = \\int_T N_1 N_2 \\, \\mathrm{d}A = \\frac{1!1!0!}{(1+1+0+2)!} = \\frac{1}{4!} = \\frac{1}{24}$\n- $M_{13} = \\int_T N_1 N_3 \\, \\mathrm{d}A = \\frac{1!0!1!}{(1+0+1+2)!} = \\frac{1}{4!} = \\frac{1}{24}$\n- $M_{23} = \\int_T N_2 N_3 \\, \\mathrm{d}A = \\frac{0!1!1!}{(0+1+1+2)!} = \\frac{1}{4!} = \\frac{1}{24}$\n\n组装矩阵 $M$：\n$$ M = \\begin{pmatrix} 1/12  1/24  1/24 \\\\ 1/24  1/12  1/24 \\\\ 1/24  1/24  1/12 \\end{pmatrix} = \\frac{1}{24} \\begin{pmatrix} 2  1  1 \\\\ 1  2  1 \\\\ 1  1  2 \\end{pmatrix} $$\n\n**最终任务：M 的行列式计算**\n\n为求 $M$ 的行列式，我们使用对于 $n \\times n$ 矩阵的性质 $\\det(c \\cdot A) = c^n \\det(A)$。这里，$c = 1/24$ 且 $n=3$。\n$$ \\det(M) = \\det\\left(\\frac{1}{24} \\begin{pmatrix} 2  1  1 \\\\ 1  2  1 \\\\ 1  1  2 \\end{pmatrix}\\right) = \\left(\\frac{1}{24}\\right)^3 \\det\\begin{pmatrix} 2  1  1 \\\\ 1  2  1 \\\\ 1  1  2 \\end{pmatrix} $$\n内部矩阵的行列式为：\n$$ \\det\\begin{pmatrix} 2  1  1 \\\\ 1  2  1 \\\\ 1  1  2 \\end{pmatrix} = 2(2 \\cdot 2 - 1 \\cdot 1) - 1(1 \\cdot 2 - 1 \\cdot 1) + 1(1 \\cdot 1 - 2 \\cdot 1) $$\n$$ = 2(3) - 1(1) + 1(-1) = 6 - 1 - 1 = 4 $$\n因此，质量矩阵的行列式为：\n$$ \\det(M) = \\left(\\frac{1}{24}\\right)^3 \\cdot 4 = \\frac{4}{24^3} = \\frac{4}{13824} = \\frac{1}{3456} $$", "answer": "$$\\boxed{\\frac{1}{3456}}$$", "id": "3229959"}, {"introduction": "本节将带你探索一个结构力学中的经典挑战：Timoshenko 梁的剪切自锁现象。这个高级实践表明，直接的有限元实现并非总是有效的，你将通过实现“完全积分”和“选择性减缩积分”两种策略，学会诊断并修正数值问题。这个练习不仅展示了有限元分析的威力，也揭示了其应用的艺术性和技巧性 [@problem_id:3230075]。", "problem": "您将实现一个简单的一维、双节点 Timoshenko 梁有限元，并对剪切项使用带有选择性减缩积分的高斯求积 (GQ)，以演示剪切自锁的缓解效果。剪切自锁是指在细长梁极限情况下，由于离散插值无法在表示弯曲曲率的同时处处强制零剪切约束，导致 Timoshenko 梁单元变得过度刚硬的现象。对剪切项进行选择性欠积分可以降低与这种不兼容性相关的人为刚度。您的程序必须计算几个测试案例的尖端挠度，并比较两种积分策略。所有数学实体，包括符号、变量、函数、算子和数字，都必须用 LaTeX 书写。\n\n从 Timoshenko 梁的能量泛函开始。对于一根占据 $x \\in [0,L]$、横向位移为 $w(x)$、转角为 $\\varphi(x)$ 的梁，其应变度量为曲率 $\\kappa(x) = \\varphi'(x)$ 和剪切应变 $\\gamma(x) = w'(x) - \\varphi(x)$。总应变能为\n$$\nU = \\int_0^L \\left( E I \\, \\kappa(x)^2 + k \\, A \\, G \\, \\gamma(x)^2 \\right) \\, dx,\n$$\n其中 $E$ 是杨氏模量，$I$ 是面积二次矩，$k$ 是剪切修正因子，$A$ 是横截面积，$G$ 是剪切模量。\n\n使用有限元法 (FEM) 将梁离散化为 $n$ 个等长单元。每个单元的范围是 $x \\in [x_e, x_e + L_e]$，其中 $L_e = L/n$。对 $w(x)$ 和 $\\varphi(x)$ 均使用带有线性形函数的双节点单元。在母坐标 $\\xi \\in [-1,1]$ 中，形函数为 $N_1(\\xi) = \\frac{1}{2}(1-\\xi)$ 和 $N_2(\\xi) = \\frac{1}{2}(1+\\xi)$，映射为 $x(\\xi) = \\frac{L_e}{2}\\xi + x_{\\text{mid}}$，其中 $dx/d\\xi = L_e/2$。插值为\n$$\nw(\\xi) = N_1(\\xi) \\, w_1 + N_2(\\xi) \\, w_2, \\quad\n\\varphi(\\xi) = N_1(\\xi) \\, \\varphi_1 + N_2(\\xi) \\, \\varphi_2,\n$$\n因此\n$$\nw'(x) = \\frac{w_2 - w_1}{L_e}, \\quad\n\\varphi'(x) = \\frac{\\varphi_2 - \\varphi_1}{L_e}, \\quad\n\\gamma(\\xi) = \\frac{w_2 - w_1}{L_e} - N_1(\\xi)\\varphi_1 - N_2(\\xi)\\varphi_2.\n$$\n对单元刚度的弯曲贡献来自曲率项，并为转动自由度产生一个常数矩阵，而剪切贡献则需要对 $\\gamma(\\xi)^2$进行积分。使用高斯求积 (GQ)，您将通过两种策略计算剪切刚度：\n- 完全积分：在 $\\xi \\in [-1,1]$ 上使用标准的双点 GQ，积分点为 $\\xi = \\pm \\frac{1}{\\sqrt{3}}$，权重为 $w = 1$，并包含雅可比 $dx/d\\xi = L_e/2$。\n- 减缩积分：在 $\\xi \\in [-1,1]$ 上使用单点 GQ，积分点为中点 $\\xi = 0$，权重为 $w = 2$，并包含雅可比 $dx/d\\xi = L_e/2$；这仅应用于剪切项，而弯曲项则被精确积分。\n\n为悬臂梁组装全局刚度矩阵，该悬臂梁在 $x=0$ 处被夹紧（施加 $w(0)=0$ 和 $\\varphi(0)=0$），并在 $x=L$ 处由一个尖端剪切力 $P$（单位：牛顿）加载（施加在最右侧节点的横向位移自由度上）。求解线性系统以获得两种积分策略下的尖端挠度 $w(L)$（单位：米）。\n\n对于每个测试案例，按如下方式计算一个参考尖端挠度（单位：米）：\n- 对于剪切可忽略不计的细长梁，使用 Euler–Bernoulli 参考解 $\\delta_{\\mathrm{EB}} = \\dfrac{P L^3}{3 E I}$。\n- 对于包含剪切效应的普通梁，使用 Timoshenko 参考解 $\\delta_{\\mathrm{T}} = \\dfrac{P L^3}{3 E I} + \\dfrac{P L}{k A G}$。\n\n对于每个测试案例，您的程序必须产生两个浮点数：\n- 比率 $\\rho_{\\text{full}} = \\dfrac{\\delta_{\\text{full}}}{\\delta_{\\text{ref}}}$，其中 $\\delta_{\\text{full}}$ 是在剪切项上使用完全积分计算出的尖端挠度，$\\delta_{\\text{ref}}$ 是所选的参考挠度。\n- 比率 $\\rho_{\\text{red}} = \\dfrac{\\delta_{\\text{reduced}}}{\\delta_{\\text{ref}}}$，其中 $\\delta_{\\text{reduced}}$ 是在剪切项上使用减缩积分计算出的尖端挠度。\n\n输出必须是单行文本，包含一个扁平化列表，按顺序包含所有测试案例的这些比率，格式为逗号分隔的列表并用方括号括起，例如 $[r_1, r_2, r_3, r_4]$。\n\n物理单位必须一致使用：$L$ 单位为米，$b$ 和 $t$ 单位为米，$A = b \\, t$ 单位为平方米，$I = \\dfrac{b t^3}{12}$ 单位为米的四次方，$E$ 和 $G$ 单位为帕斯卡，$P$ 单位为牛顿，所有挠度单位为米。\n\n根据上述描述从第一性原理实现计算，除了经过充分测试的高斯求积规则和标准有限元组装方法外，不使用任何简化推导路径的公式。除了直接从给定的应变-位移关系和能量泛函得出的结果外，不要硬编码任何解析刚度矩阵。\n\n测试套件：\n使用以下测试套件来评估和演示减缩积分对剪切自锁的影响：\n- 案例 $1$（细长梁，粗网格，Euler–Bernoulli 参考解）：$L = 10$，$b = 0.1$，$t = 0.01$，$n = 1$，$P = 1000$，$E = 210\\times 10^9$，$G = 80\\times 10^9$，$k = \\dfrac{5}{6}$，参考类型 $\\mathrm{EB}$。\n- 案例 $2$（细长梁，细化网格，Euler–Bernoulli 参考解）：$L = 10$，$b = 0.1$，$t = 0.01$，$n = 20$，$P = 1000$，$E = 210\\times 10^9$，$G = 80\\times 10^9$，$k = \\dfrac{5}{6}$，参考类型 $\\mathrm{EB}$。\n- 案例 $3$（中厚梁，Timoshenko 参考解）：$L = 1$，$b = 0.1$，$t = 0.5$，$n = 4$，$P = 1000$，$E = 210\\times 10^9$，$G = 80\\times 10^9$，$k = \\dfrac{5}{6}$，参考类型 $\\mathrm{T}$。\n\n您的程序应生成单行输出，其中包含精确格式 $[\\rho_{\\text{full,1}},\\rho_{\\text{red,1}},\\rho_{\\text{full,2}},\\rho_{\\text{red,2}},\\rho_{\\text{full,3}},\\rho_{\\text{red,3}}]$ 的扁平化比率，每个条目都是一个浮点数。", "solution": "用户的要求是验证并解决一个关于实现一维 Timoshenko 梁有限元的问题。问题的核心是演示剪切自锁现象以及如何使用选择性减缩积分来缓解它。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n- **控制理论**：Timoshenko 梁理论。\n- **域**：长度为 $L$ 的梁，从 $x \\in [0,L]$。\n- **状态变量**：横向位移 $w(x)$，横截面转角 $\\varphi(x)$。\n- **应变度量**：曲率 $\\kappa(x) = \\varphi'(x)$，剪切应变 $\\gamma(x) = w'(x) - \\varphi(x)$。\n- **应变能泛函**：$U = \\int_0^L \\left( E I \\, \\kappa(x)^2 + k \\, A \\, G \\, \\gamma(x)^2 \\right) \\, dx$。\n- **材料/几何属性**：杨氏模量 $E$，面积二次矩 $I$，剪切修正因子 $k$，横截面积 $A$，剪切模量 $G$。\n- **有限元离散化**：\n    - $n$ 个等长单元，长度为 $L_e = L/n$。\n    - 双节点线性单元。\n    - 母坐标 $\\xi \\in [-1,1]$ 中的形函数：$N_1(\\xi) = \\frac{1}{2}(1-\\xi)$，$N_2(\\xi) = \\frac{1}{2}(1+\\xi)$。\n    - 坐标映射的雅可比：$dx/d\\xi = L_e/2$。\n    - 位移 $w(\\xi) = N_1(\\xi)w_1 + N_2(\\xi)w_2$ 和转角 $\\varphi(\\xi) = N_1(\\xi)\\varphi_1 + N_2(\\xi)\\varphi_2$ 的节点插值。\n- **离散应变-位移关系**：$w'(x) = \\frac{w_2 - w_1}{L_e}$，$\\varphi'(x) = \\frac{\\varphi_2 - \\varphi_1}{L_e}$，$\\gamma(\\xi) = \\frac{w_2 - w_1}{L_e} - N_1(\\xi)\\varphi_1 - N_2(\\xi)\\varphi_2$。\n- **数值积分**：\n    - **弯曲项**：精确积分。\n    - **剪切项**：\n        - **完全积分**：双点高斯求积 (GQ)，积分点为 $\\xi = \\pm \\frac{1}{\\sqrt{3}}$，权重为 $w = 1$。\n        - **减缩积分**：单点 GQ，积分点为 $\\xi = 0$，权重为 $w = 2$。\n- **边界条件**：悬臂梁。\n    - 在 $x=0$ 处夹紧：$w(0)=0$，$\\varphi(0)=0$。\n    - 在 $x=L$ 处加载：横向点力 $P$。\n- **参考解**：\n    - Euler-Bernoulli：$\\delta_{\\mathrm{EB}} = \\frac{P L^3}{3 E I}$。\n    - Timoshenko：$\\delta_{\\mathrm{T}} = \\frac{P L^3}{3 E I} + \\frac{P L}{k A G}$。\n- **输出度量**：对于每个案例，计算比率 $\\rho_{\\text{full}} = \\delta_{\\text{full}}/\\delta_{\\text{ref}}$ 和 $\\rho_{\\text{red}} = \\delta_{\\text{reduced}}/\\delta_{\\text{ref}}$。\n- **物理属性**：宽度为 $b$、厚度为 $t$ 的矩形截面，因此 $A = b t$ 且 $I = \\frac{b t^3}{12}$。\n- **测试案例**：提供了三组特定的参数。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n- **科学基础**：该问题是计算固体力学中的一个典型案例研究，植根于已建立的 Timoshenko 梁理论和有限元方法。剪切自锁和选择性减缩积分的概念是高级有限元课程中的标准和基础主题。\n- **适定性**：该问题是适定的。它描述了一个带有足够边界条件的线性椭圆偏微分方程的离散化，以确保存在唯一解。由此产生的线性代数系统 $\\mathbf{K}\\mathbf{D}=\\mathbf{F}$ 是可解的。\n- **客观性**：该问题以完全客观的方式陈述，使用了精确的数学和工程术语。所有参数都已定义和量化，并且明确指定了所需的输出。\n- **完整性与一致性**：问题陈述是自洽的，提供了进行完整求解所需的所有必要数据、方程、边界条件和测试参数。没有内部矛盾。\n- **真实性**：材料（$E$，$G$）的物理参数代表了钢材。几何和加载条件是结构分析基准测试的标准条件。\n\n**步骤 3：结论与行动**\n\n该问题是**有效的**。它是工程数值方法中一个定义明确、科学合理的问题。将按要求进行求解。\n\n### 求解\n\n求解需要实现 Timoshenko 梁的有限元模型。该过程涉及推导单元刚度矩阵，组装全局系统，应用边界条件，并求解节点位移。这将针对剪切项的两种不同数值积分方案进行，以研究剪切自锁。\n\n**1. 单元公式**\n应变能 $U$ 是弯曲能 $U_b$ 和剪切能 $U_s$ 的总和：\n$U = U_b + U_s = \\frac{1}{2}\\int_0^{L_e} EI (\\varphi')^2 dx + \\frac{1}{2}\\int_0^{L_e} kAG \\gamma^2 dx$。\n单元刚度矩阵 $\\mathbf{K}^e$ 是弯曲刚度 $\\mathbf{K}_b^e$ 和剪切刚度 $\\mathbf{K}_s^e$ 的和。单元节点自由度 (DOF) 为 $\\mathbf{d}^e = [w_1, \\varphi_1, w_2, \\varphi_2]^T$。\n\n**2. 弯曲刚度矩阵 $\\mathbf{K}_b^e$**\n对于线性形函数，转角梯度 $\\varphi'(x) = (\\varphi_2 - \\varphi_1)/L_e$ 在单元内是常数。弯曲能积分是精确的：\n$U_b = \\frac{1}{2} EI \\left(\\frac{\\varphi_2 - \\varphi_1}{L_e}\\right)^2 L_e = \\frac{1}{2} \\frac{EI}{L_e} (\\varphi_2 - \\varphi_1)^2$。\n该能量对应于弯曲刚度矩阵 $\\mathbf{K}_b^e$：\n$$\n\\mathbf{K}_b^e = \\frac{E I}{L_e}\n\\begin{bmatrix}\n0  0  0  0 \\\\\n0  1  0  -1 \\\\\n0  0  0  0 \\\\\n0  -1  0  1\n\\end{bmatrix}\n$$\n\n**3. 剪切刚度矩阵 $\\mathbf{K}_s^e$**\n剪切应变为 $\\gamma(\\xi) = \\frac{w_2 - w_1}{L_e} - (N_1(\\xi)\\varphi_1 + N_2(\\xi)\\varphi_2)$。剪切能通过数值积分计算：\n$U_s = \\frac{1}{2} \\int_{-1}^{1} kAG (\\gamma(\\xi))^2 \\frac{L_e}{2} d\\xi$。\n剪切刚度矩阵为 $\\mathbf{K}_s^e = \\int_{-1}^1 \\mathbf{B}_s(\\xi)^T (kAG) \\mathbf{B}_s(\\xi) \\frac{L_e}{2} d\\xi$，其中 $\\mathbf{B}_s(\\xi)$ 是剪切的应变-位移矩阵。\n\n- **完全积分（双点 GQ）**：双点高斯求积对于最高 3 次的多项式是精确的。$\\mathbf{K}_s^e$ 的被积函数包含最高到 $\\xi^2$ 的项（来自 $N_i(\\xi)N_j(\\xi)$），因此双点 GQ 对此公式产生精确积分。这导致：\n$$\n\\mathbf{K}_{s, \\text{full}}^e = k A G\n\\begin{bmatrix}\n1/L_e  1/2  -1/L_e  1/2 \\\\\n1/2  L_e/3  -1/2  L_e/6 \\\\\n-1/L_e  -1/2  1/L_e  -1/2 \\\\\n1/2  L_e/6  -1/2  L_e/3\n\\end{bmatrix}\n$$\n对于细长梁，此公式过于刚硬，这种现象称为剪切自锁。单元试图在两个不同的点上强制实施无剪切条件（$\\gamma=0$），这过度约束了运动学场，并妨碍了适当的弯曲变形。\n\n- **减缩积分（单点 GQ）**：单点 GQ 仅使用中点 $\\xi=0$，其中 $\\gamma(0) = \\frac{w_2-w_1}{L_e} - \\frac{\\varphi_1+\\varphi_2}{2}$。积分是近似的，仅在该点评估被积函数。这产生了一个不同的刚度矩阵：\n$$\n\\mathbf{K}_{s, \\text{red}}^e = k A G\n\\begin{bmatrix}\n 1/L_e  1/2  -1/L_e  1/2 \\\\\n 1/2  L_e/4  -1/2  L_e/4 \\\\\n-1/L_e  -1/2  1/L_e  -1/2 \\\\\n 1/2  L_e/4  -1/2  L_e/4\n\\end{bmatrix}\n$$\n该矩阵是秩亏的且刚度较小。通过仅在单元中心施加剪切约束，它允许了否则会被惩罚的弯曲变形，从而缓解了剪切自锁。\n\n**4. 全局组装与求解**\n总单元刚度矩阵为 $\\mathbf{K}^e = \\mathbf{K}_b^e + \\mathbf{K}_s^e$（使用 $\\mathbf{K}_{s, \\text{full}}^e$ 或 $\\mathbf{K}_{s, \\text{red}}^e$）。这些单元矩阵被组装成整个梁（$n$ 个单元，$n+1$ 个节点）的全局刚度矩阵 $\\mathbf{K}$。\n全局系统是 $\\mathbf{K}\\mathbf{D} = \\mathbf{F}$，其中 $\\mathbf{D}$ 是所有节点自由度的向量，$\\mathbf{F}$ 是全局力向量。\n- **边界条件**：对于悬臂梁，夹紧端（$x=0$）的自由度是固定的：$w(0)=0$，$\\varphi(0)=0$。这通过修改全局矩阵 $\\mathbf{K}$ 和力向量 $\\mathbf{F}$ 来实施。\n- **荷载**：在自由端（$x=L$）的横向位移自由度上施加点力 $P$。\n修改后，求解该系统以获得位移向量 $\\mathbf{D}$。尖端挠度是最后一个节点的横向位移。\n\n**5. 测试案例分析**\n代码对每个指定的测试案例执行此过程，一次使用完全积分，一次使用减缩积分。\n- **案例 1（细长梁，$n=1$）**：一个非常细长的梁（$L/t = 1000$），只有一个单元。这是剪切自锁的原型案例。完全积分预计会产生极其刚硬的响应（挠度远小于实际值，因此 $\\rho_{\\text{full}} \\ll 1$），而减缩积分应提供更合理的结果（$\\rho_{\\text{red}}$ 更接近 $1$）。\n- **案例 2（细长梁，$n=20$）**：同样的细长梁，但网格更细（$L_e/t = 50$）。通过使用更小的单元，即使是完全积分的单元也能更好地近似弯曲行为。剪切自锁将显著减少，$\\rho_{\\text{full}}$ 和 $\\rho_{\\text{red}}$ 都应接近 $1$。\n- **案例 3（厚梁，$n=4$）**：一个短而厚的梁（$L/t=2$），其中剪切变形显著且必须精确建模。Timoshenko 理论在这里是合适的。由于剪切效应是真实的，更精确的完全积分预计会表现良好，减缩积分也是如此。两个比率都应接近 $1$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes tip deflections for a cantilevered Timoshenko beam using Finite Element Method\n    with both full and selective reduced integration to demonstrate shear locking.\n    \"\"\"\n\n    def _compute_tip_deflection(L, b, t, n_elements, P, E, G, k, integration_type):\n        \"\"\"\n        Calculates the tip deflection of a cantilever beam for a given integration scheme.\n\n        Args:\n            L (float): Beam length (m)\n            b (float): Cross-section width (m)\n            t (float): Cross-section thickness (m)\n            n_elements (int): Number of finite elements\n            P (float): Tip load (N)\n            E (float): Young's modulus (Pa)\n            G (float): Shear modulus (Pa)\n            k (float): Shear correction factor\n            integration_type (str): 'full' or 'reduced'\n\n        Returns:\n            float: Tip deflection (m)\n        \"\"\"\n        # 1. Geometric and Material Properties\n        A = b * t\n        I = (b * t**3) / 12.0\n        Le = L / n_elements\n\n        # 2. Element Stiffness Matrix Formulation\n        # Bending stiffness matrix (constant for both integration schemes)\n        K_b_e = (E * I / Le) * np.array([\n            [0.,  0., 0.,  0.],\n            [0.,  1., 0., -1.],\n            [0.,  0., 0.,  0.],\n            [0., -1., 0.,  1.]\n        ])\n\n        # Shear stiffness matrix (dependent on integration scheme)\n        if integration_type == 'full':\n            # Full (2-point) Gaussian Quadrature\n            K_s_e = (k * A * G) * np.array([\n                [1. / Le,   0.5,      -1. / Le,   0.5],\n                [0.5,       Le / 3.0, -0.5,       Le / 6.0],\n                [-1. / Le,  -0.5,      1. / Le,  -0.5],\n                [0.5,       Le / 6.0, -0.5,       Le / 3.0]\n            ])\n        elif integration_type == 'reduced':\n            # Reduced (1-point) Gaussian Quadrature\n            K_s_e = (k * A * G) * np.array([\n                [1. / Le,   0.5,      -1. / Le,   0.5],\n                [0.5,       Le / 4.0, -0.5,       Le / 4.0],\n                [-1. / Le,  -0.5,      1. / Le,  -1. / Le],\n                [0.5,       Le / 4.0, -0.5,       Le / 4.0]\n            ])\n        else:\n            raise ValueError(\"integration_type must be 'full' or 'reduced'\")\n\n        # Total element stiffness matrix\n        K_e = K_b_e + K_s_e\n\n        # 3. Global Matrix Assembly\n        n_nodes = n_elements + 1\n        n_dof = 2 * n_nodes\n        K_global = np.zeros((n_dof, n_dof))\n\n        for i in range(n_elements):\n            dof_indices = [2 * i, 2 * i + 1, 2 * (i + 1), 2 * (i + 1) + 1]\n            for r_local, r_global in enumerate(dof_indices):\n                for c_local, c_global in enumerate(dof_indices):\n                    K_global[r_global, c_global] += K_e[r_local, c_local]\n\n        # 4. Global Force Vector and Boundary Conditions\n        F_global = np.zeros(n_dof)\n        \n        # Apply tip load P at the transverse DOF of the last node\n        tip_dof_idx = 2 * n_elements\n        F_global[tip_dof_idx] = P\n\n        # Apply clamped boundary conditions at x=0 (w(0)=0, phi(0)=0)\n        # We modify the matrix to enforce D[0]=0 and D[1]=0\n        K_global[0, :] = 0.0\n        K_global[:, 0] = 0.0\n        K_global[0, 0] = 1.0\n        F_global[0] = 0.0\n\n        K_global[1, :] = 0.0\n        K_global[:, 1] = 0.0\n        K_global[1, 1] = 1.0\n        F_global[1] = 0.0\n\n        # 5. Solve the Linear System\n        displacements = np.linalg.solve(K_global, F_global)\n\n        # 6. Return Tip Deflection\n        return displacements[tip_dof_idx]\n\n    # --- Main Execution Logic ---\n    test_cases = [\n        # (L, b, t, n_elements, P, E, G, k, ref_type)\n        (10.0, 0.1, 0.01, 1, 1000.0, 210e9, 80e9, 5.0/6.0, 'EB'),\n        (10.0, 0.1, 0.01, 20, 1000.0, 210e9, 80e9, 5.0/6.0, 'EB'),\n        (1.0, 0.1, 0.5, 4, 1000.0, 210e9, 80e9, 5.0/6.0, 'T'),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, b, t, n, P, E, G, k, ref_type = case\n\n        # Calculate properties\n        I = (b * t**3) / 12.0\n        A = b * t\n\n        # Calculate reference deflection\n        delta_EB = (P * L**3) / (3.0 * E * I)\n        if ref_type == 'EB':\n            delta_ref = delta_EB\n        elif ref_type == 'T':\n            delta_T = delta_EB + (P * L) / (k * A * G)\n            delta_ref = delta_T\n        else:\n            raise ValueError(f\"Invalid reference type: {ref_type}\")\n\n        # Compute FEM solutions\n        delta_full = _compute_tip_deflection(L, b, t, n, P, E, G, k, 'full')\n        delta_reduced = _compute_tip_deflection(L, b, t, n, P, E, G, k, 'reduced')\n        \n        # Compute and store the ratios\n        rho_full = delta_full / delta_ref\n        rho_red = delta_reduced / delta_ref\n        results.extend([rho_full, rho_red])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3230075"}]}