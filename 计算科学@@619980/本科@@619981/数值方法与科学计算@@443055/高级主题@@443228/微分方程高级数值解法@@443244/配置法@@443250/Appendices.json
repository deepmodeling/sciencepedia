{"hands_on_practices": [{"introduction": "配置法的核心思想极其优雅：我们构造一个包含未知参数的试验解，然后通过强制该解在特定点（即配置点）上精确满足微分方程，来反解这些参数。这个过程巧妙地将一个复杂的微分方程问题转化为了一个更易于处理的代数方程问题。本练习 [@problem_id:2159883] 将引导你亲手实践这一基本流程，为一个线性边值问题确定未知参数，并学习如何通过分析残差来评估近似解的质量。", "problem": "一位工程师正在对一根侧向绝热的单位长度细杆上的稳态温度分布 $y(x)$ 进行建模。该杆受到一个与位置 $x$ 的平方成正比的内部热源作用，且其两端温度是固定的。该系统的控制微分方程是一个二阶线性非齐次边值问题 (BVP)：\n\n$$y''(x) - y(x) = -x^2, \\quad \\text{for } x \\in [0, 1]$$\n\n边界条件为：\n\n$$y(0) = 0, \\quad y(1) = 2$$\n\n为了求得一个近似解，采用了配置法。提出了一个单参数试函数 $\\tilde{y}(x)$，该函数被构造成自动满足边界条件：\n\n$$\\tilde{y}(x) = 2x + c \\cdot x(1-x)$$\n\n其中 $c$ 是一个待定的未知常数系数。\n\n您的任务是使用位于 $x_c = 1/2$ 的单个配置点来确定参数 $c$ 的值。然后，利用这个 $c$ 值，计算绝对残差的最大值 $\\max_{x \\in [0, 1]} |R(x)|$，其中残差函数 $R(x)$ 定义为 $R(x) = \\tilde{y}''(x) - \\tilde{y}(x) + x^2$。\n\n将您的最终答案表示为一个实数，四舍五入到三位有效数字。", "solution": "试函数为 $\\tilde{y}(x) = 2x + c\\,x(1-x) = (2+c)x - c x^{2}$，它满足边界条件 $\\tilde{y}(0)=0$ 和 $\\tilde{y}(1)=2$。其导数为\n$$\n\\tilde{y}'(x) = (2+c) - 2c x, \\qquad \\tilde{y}''(x) = -2c.\n$$\n残差由 $R(x) = \\tilde{y}''(x) - \\tilde{y}(x) + x^{2}$ 定义，因此\n$$\nR(x) = -2c - \\big[(2+c)x - c x^{2}\\big] + x^{2} = -2c - (2+c)x + (c+1)x^{2}.\n$$\n使用在 $x_{c}=\\frac{1}{2}$ 处的配置条件，令 $R\\!\\left(\\frac{1}{2}\\right)=0$：\n$$\n-2c - \\frac{2+c}{2} + \\frac{c+1}{4} = 0.\n$$\n通分，以 $4$ 为公分母，可得\n$$\n\\frac{-8c - 2(2+c) + (c+1)}{4} = \\frac{-8c - 4 - 2c + c + 1}{4} = \\frac{-9c - 3}{4} = 0,\n$$\n所以 $-9c - 3 = 0$，因此 $c = -\\frac{1}{3}$。\n\n将 $c=-\\frac{1}{3}$ 代入 $R(x)$：\n$$\nR(x) = -2\\!\\left(-\\frac{1}{3}\\right) - \\left(2 - \\frac{1}{3}\\right)x + \\left(1 - \\frac{1}{3}\\right)x^{2} = \\frac{2}{3} - \\frac{5}{3}x + \\frac{2}{3}x^{2} = \\frac{1}{3}\\big(2 - 5x + 2x^{2}\\big).\n$$\n令 $q(x) = 2 - 5x + 2x^{2}$。则 $R(x) = \\frac{1}{3}q(x)$。函数 $q$ 是一个二次函数，其导数为 $q'(x) = -5 + 4x$，该导数在 $[0,1]$ 上为负，因此 $q$ 在 $[0,1]$ 上单调递减。此外，$q\\!\\left(\\frac{1}{2}\\right)=0$ (与配置条件一致)。因此在 $[0,\\frac{1}{2}]$ 上，$q \\ge 0$ 且 $|q|=q$ 从 $q(0)=2$ 递减到 $0$，而在 $[\\frac{1}{2},1]$ 上，$q \\le 0$ 且 $|q|=-q$ 从 $0$ 递增到 $|q(1)|=1$。因此\n$$\n\\max_{x \\in [0,1]} |q(x)| = 2 \\quad \\Rightarrow \\quad \\max_{x \\in [0,1]} |R(x)| = \\frac{1}{3} \\cdot 2 = \\frac{2}{3}.\n$$\n四舍五入到三位有效数字，结果为 $0.667$。", "answer": "$$\\boxed{0.667}$$", "id": "2159883"}, {"introduction": "从单点配置过渡到多点配置，我们便踏入了伪谱法的领域，这是一种功能强大的数值方法。在伪谱法中，配置点的选择并非随意，而是决定方法稳定性和收敛性的关键，对于求解含有边界层等剧烈变化特征的问题尤其重要。本练习 [@problem_id:3179398] 将要求你实现并对比两种切比雪夫节点，从而揭示为何在高精度计算中，像切比雪夫-高斯-洛巴托节点那样在边界附近加密布点，能更有效地捕捉边界层效应。这是对切比雪夫谱配置法强大能力背后原理的一次深度探索。", "problem": "你将实现一个伪谱配置法，研究在区间 $[-1,1]$ 上，当使用边界条件 $u(1)=1$ (无量纲) 来近似常微分方程 (ODE) $u'(x)=\\alpha\\,u(x)$ 的解时，端点聚集如何影响边界层的解析度。其精确解为 $u(x)=\\exp\\!\\big(\\alpha\\,(x-1)\\big)$。你必须对比 Chebyshev–Gauss 节点 $x_k=\\cos\\!\\big(\\frac{(2k-1)\\pi}{2N}\\big)$ (其中 $k=1,2,\\dots,N$) 和 Chebyshev–Gauss–Lobatto 节点 $x_k=\\cos\\!\\big(\\frac{k\\pi}{N}\\big)$ (其中 $k=0,1,\\dots,N$)，所有角度均以弧度为单位。目标是评估当 $\\alpha$ 为大的正数时，在 $x=\\pm 1$ 处的端点包含与聚集如何影响 $x=1$ 附近薄边界层的解析度。\n\n从以下基本原理开始：\n- 多项式插值与配置：用一个多项式 $p(x)$ 来近似 $u(x)$，该多项式在不同的节点 $\\{x_k\\}$ 上进行插值；在选定的配置节点上强制满足常微分方程，并在 $x=1$ 处强制满足边界条件。\n- 重心插值公式：对于具有重心权重 $\\{w_k\\}$ 的不同节点 $\\{x_k\\}$，在点 $x$ 处求值的插值多项式为 $$p(x)=\\frac{\\sum_{k=0}^{M-1}\\frac{w_k\\,u_k}{x-x_k}}{\\sum_{k=0}^{M-1}\\frac{w_k}{x-x_k}},$$ 其中 $u_k=p(x_k)$，$M$ 是节点数。\n- 重心微分矩阵 $D\\in\\mathbb{R}^{M\\times M}$ 定义为 $$D_{ij}=\\begin{cases}\\dfrac{w_j}{w_i\\,(x_i-x_j)},  i\\neq j \\\\ -\\sum_{j\\neq i}D_{ij},  i=j\\end{cases}$$ 由此可得 $p'(x_i)=\\sum_{j=0}^{M-1}D_{ij}\\,u_j$。\n\n实现以下伪谱配置设计：\n- 对于具有 $N+1$ 个节点 ($k=0,\\dots,N$) 的 Chebyshev–Gauss–Lobatto 节点，直接在节点 $x_0=1$ 处强制施加 $u(1)=1$；在内部节点 $x_k$ ($k=1,\\dots,N$) 处强制施加常微分方程 $u'(x)=\\alpha\\,u(x)$。这将产生一个包含 $N+1$ 个方程的线性系统，用于求解节点值 $\\{u_k\\}_{k=0}^N$。\n- 对于具有 $N$ 个节点 ($k=1,\\dots,N$) 且不包含端点的 Chebyshev–Gauss 节点，通过在 $N-1$ 个节点上强制施加常微分方程，并将其中一个 ODE 行替换为通过重心求值表示的边界条件 $u(1)=1$，来构建一个方形系统。具体来说，对于 $x^\\ast=1$，定义 $$\\phi_k=\\frac{w_k}{x^\\ast-x_k},\\qquad \\beta_k=\\frac{\\phi_k}{\\sum_{j=1}^N \\phi_j},$$ 并强制施加 $\\sum_{k=1}^N \\beta_k\\,u_k=1$ 作为边界条件。在其余的 $N-1$ 个节点上通过 $p'(x_i)-\\alpha\\,p(x_i)=0$ 施加常微分方程。选择 $x_k$ 值最大的节点对应的 ODE 行进行替换，以便将边界约束与最近的节点对齐。\n\n对 Chebyshev 族使用已知的重心权重：\n- 对于 Chebyshev–Gauss 节点 $x_k=\\cos\\!\\big(\\frac{(2k-1)\\pi}{2N}\\big)$ ($k=1,\\dots,N$)，令 $w_k=(-1)^{k-1}$。\n- 对于 Chebyshev–Gauss–Lobatto 节点 $x_k=\\cos\\!\\big(\\frac{k\\pi}{N}\\big)$ ($k=0,\\dots,N$)，令 $w_k=(-1)^k\\,c_k$，其中 $c_0=c_N=\\tfrac{1}{2}$ 且 $c_k=1$ ($k=1,\\dots,N-1$)。\n\n为量化 $x=1$ 附近边界层的解析度，定义一个包含 $m$ 个点的聚焦于边界层的评估网格，$$\\delta=\\min\\!\\Big(0.5,\\frac{8}{\\alpha}\\Big),\\qquad x_j=1-\\delta+\\frac{j}{m-1}\\,\\delta,\\quad j=0,1,\\dots,m-1,$$ 其中 $m=400$。通过重心公式在此网格上评估多项式近似 $p_{\\text{Gauss}}(x)$ 和 $p_{\\text{Lobatto}}(x)$，并计算最大绝对误差 $$E_{\\text{Gauss}}=\\max_j\\left|p_{\\text{Gauss}}(x_j)-\\exp\\!\\big(\\alpha(x_j-1)\\big)\\right|,\\qquad E_{\\text{Lobatto}}=\\max_j\\left|p_{\\text{Lobatto}}(x_j)-\\exp\\!\\big(\\alpha(x_j-1)\\big)\\right|.$$ 报告每个测试案例的误差比的以 10 为底的对数 $\\log_{10}\\!\\big(E_{\\text{Gauss}}/E_{\\text{Lobatto}}\\big)$。\n\n测试套件：\n- 案例 1：$(N,\\alpha)=(16,20)$。\n- 案例 2：$(N,\\alpha)=(16,100)$。\n- 案例 3：$(N,\\alpha)=(8,50)$。\n- 案例 4：$(N,\\alpha)=(32,100)$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个浮点数采用科学记数法，小数点后保留六位数字（例如，$[1.234567e-02,-3.210000e+00]$）。该行必须按上面列出的顺序汇总四个测试案例的结果。", "solution": "用户提供了一个有效的问题陈述。我将继续提供完整的解决方案。\n\n该问题要求对两种伪谱配置法进行比较分析，以求解在定义域 $x \\in [-1, 1]$ 上带有边界条件 $u(1) = 1$ 的常微分方程 (ODE) $u'(x) = \\alpha u(x)$。其精确解为 $u(x) = \\exp(\\alpha(x-1))$。对于大的正数 $\\alpha$，该解在 $x=1$ 附近呈现一个薄边界层，函数值在此处急剧变化。目标是评估两种不同的配置节点选择——Chebyshev–Gauss 和 Chebyshev–Gauss–Lobatto——如何影响解析该边界层的数值精度。\n\n伪谱法的核心思想是用一个 $M-1$ 次的全局多项式 $p(x)$ 来近似未知函数 $u(x)$，其中 $M$ 是配置节点的数量。该多项式由其在一组不同节点 $\\{x_k\\}$ 上的值 $\\{u_k = p(x_k)\\}$ 定义。多项式在这些节点处的导数 $p'(x_i)$ 可以计算为节点值的线性组合，$p'(x_i) = \\sum_{j} D_{ij} u_j$，其中 $D$ 是谱微分矩阵。通过在这些节点上强制施加常微分方程和边界条件，我们可以为未知的节点值 $\\{u_k\\}$ 构建一个线性系统。\n\n问题指定使用重心插值公式来表示多项式及其导数。微分矩阵 $D$ 基于节点 $\\{x_k\\}$ 及其对应的重心权重 $\\{w_k\\}$ 定义如下：\n$$\nD_{ij} = \\begin{cases}\n\\dfrac{w_j}{w_i(x_i - x_j)},  i \\neq j \\\\\n-\\sum_{j \\neq i} D_{ij},  i=j\n\\end{cases}\n$$\n一旦通过求解线性系统找到节点值 $\\{u_k\\}$，就可以使用重心公式在任意点 $x$ 处评估多项式近似：\n$$\np(x) = \\frac{\\sum_{k} \\frac{w_k u_k}{x - x_k}}{\\sum_{k} \\frac{w_k}{x - x_k}}\n$$\n\n我们现在将详细说明每组节点的实现。\n\n### 1. Chebyshev–Gauss–Lobatto 方法\n\n此方法使用 $M = N+1$ 个节点，包括端点 $x=\\pm 1$。\n- **节点**：$x_k = \\cos\\left(\\frac{k\\pi}{N}\\right)$，其中 $k = 0, 1, \\dots, N$。注意 $x_0 = 1$ 且 $x_N = -1$。\n- **重心权重**：$w_k = (-1)^k c_k$，其中 $c_0 = c_N = \\frac{1}{2}$ 且 $c_k = 1$ ($k=1, \\dots, N-1$)。\n\n一个用于求解 $N+1$ 个未知节点值 $\\{u_k\\}_{k=0}^N$ 的包含 $N+1$ 个方程的线性系统按如下方式构建：\n- **边界条件**：在节点 $x_0 = 1$ 处直接强制施加条件 $u(1)=1$。这提供了第一个方程：$u_0 = 1$。\n- **ODE 配置**：将形式为 $u'(x) - \\alpha u(x) = 0$ 的常微分方程在节点 $x_k$ ($k=1,\\dots,N$) 处强制施加。对于每个这样的节点 $x_k$，我们得到一个方程：\n$$\np'(x_k) - \\alpha p(x_k) = 0 \\implies \\sum_{j=0}^{N} D_{kj} u_j - \\alpha u_k = 0\n$$\n这给出了 $N$ 个方程。与边界条件结合，我们得到一个方形线性系统 $A_L u = b_L$，其中 $u = [u_0, u_1, \\dots, u_N]^T$。矩阵 $A_L$ 的第一行为 $[1, 0, \\dots, 0]$，后续行由微分矩阵 $(D - \\alpha I)$ 导出。右端项为 $b_L = [1, 0, \\dots, 0]^T$。求解该系统可得到 Lobatto 近似 $p_{\\text{Lobatto}}(x)$ 的节点值。\n\n### 2. Chebyshev–Gauss 方法\n\n此方法使用 $M=N$ 个节点，这些节点位于区间 $[-1, 1]$ 的内部。\n- **节点**：$x_k = \\cos\\left(\\frac{(2k-1)\\pi}{2N}\\right)$，其中 $k = 1, \\dots, N$。对于从 0 开始索引的实现 ($k=0, \\dots, N-1$)，公式变为 $x_k = \\cos\\left(\\frac{(2k+1)\\pi}{2N}\\right)$。\n- **重心权重**：$w_k = (-1)^{k-1}$，其中 $k=1, \\dots, N$。对于从 0 开始索引的实现，$w_k = (-1)^k$。\n\n构建一个包含 $N$ 个方程的线性系统，用于求解 $N$ 个未知节点值 $\\{u_k\\}_{k=1}^N$。由于边界点 $x=1$ 不是节点，必须通过插值来强制施加条件 $u(1)=1$。\n- **通过插值施加边界条件**：我们使用重心公式强制施加 $p(1) = 1$：\n$$\np(1) = \\frac{\\sum_{k=1}^{N} \\frac{w_k u_k}{1 - x_k}}{\\sum_{j=1}^{N} \\frac{w_j}{1 - x_j}} = 1 \\implies \\sum_{k=1}^{N} \\beta_k u_k = 1\n$$\n其中 $\\beta_k = \\frac{\\phi_k}{\\sum_{j=1}^N \\phi_j}$ 且 $\\phi_k = \\frac{w_k}{1 - x_k}$。这构成了一个线性方程。\n- **ODE 配置**：为保持一个方形系统，我们在 $N$ 个节点中的 $N-1$ 个节点上强制施加常微分方程 $p'(x_k) - \\alpha p(x_k) = 0$。问题指定，应将与 $x_k$ 值最大（即最接近 $x=1$）的节点相对应的常微分方程替换为边界条件方程。该节点是 $x_1 = \\cos(\\pi/(2N))$（或在从 0 开始索引的方案中为 $x_0$）。\n\n该设置给出了一个用于求解节点值 $u=[u_1, \\dots, u_N]^T$ 的方形线性系统 $A_G u = b_G$。求解该系统可得到 Gauss 近似 $p_{\\text{Gauss}}(x)$ 的节点值。\n\n### 3. 误差分析\n\n为了量化和比较这两种方法的精度，我们在边界层区域内评估每种近似的最大绝对误差。评估网格集中在 $x=1$ 附近，定义如下：\n- 边界层宽度参数：$\\delta = \\min(0.5, 8/\\alpha)$。\n- 评估点：$x_j = 1 - \\delta + \\frac{j}{m-1}\\delta$，其中 $j=0, \\dots, m-1$，且 $m=400$。\n\n最大误差计算如下：\n$$\nE_{\\text{Gauss}} = \\max_{j} |p_{\\text{Gauss}}(x_j) - u(x_j)|\n$$\n$$\nE_{\\text{Lobatto}} = \\max_{j} |p_{\\text{Lobatto}}(x_j) - u(x_j)|\n$$\n最终的比较指标是这些误差之比的以 10 为底的对数 $\\log_{10}(E_{\\text{Gauss}}/E_{\\text{Lobatto}})$。一个大的正值表明，对于给定的问题，Lobatto 方法的精度要高得多。这是符合预期的，因为包含边界节点 $x=1$ 允许直接强制施加边界条件，并在边界层中提供了更高的节点密度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# The problem allows for scipy, but numpy.linalg.solve is sufficient.\n# from scipy.linalg import solve as solve_linear_system\n\ndef bary_eval(x_eval, nodes, u_nodal, weights):\n    \"\"\"\n    Evaluates a polynomial given by nodal values using the barycentric formula.\n    Handles singularities where an evaluation point coincides with a node.\n    \"\"\"\n    p_eval = np.zeros_like(x_eval, dtype=float)\n    for i, x in enumerate(x_eval):\n        # Check if the evaluation point x is very close to one of the nodes.\n        match_indices = np.where(np.isclose(x, nodes))[0]\n        if len(match_indices)  0:\n            # If so, the interpolated value is simply the nodal value.\n            p_eval[i] = u_nodal[match_indices[0]]\n            continue\n\n        # Otherwise, use the standard barycentric formula.\n        diffs = x - nodes\n        numer_terms = weights * u_nodal / diffs\n        denom_terms = weights / diffs\n        \n        numer = np.sum(numer_terms)\n        denom = np.sum(denom_terms)\n\n        # The ratio gives the interpolated value.\n        # Add a small epsilon to avoid division by zero in pathological cases.\n        if abs(denom)  1e-100:\n           # This case is unlikely if x is not a node but handled for robustness.\n           closest_node_idx = np.argmin(np.abs(diffs))\n           p_eval[i] = u_nodal[closest_node_idx]\n        else:\n           p_eval[i] = numer / denom\n    return p_eval\n\ndef solve_case(N, alpha):\n    \"\"\"\n    Solves the ODE for a given (N, alpha) pair and returns the log10 error ratio.\n    \"\"\"\n    # ====== Part 1: Chebyshev-Gauss-Lobatto Method ======\n    M_L = N + 1\n    # Nodes and weights (0-indexed: k=0, ..., N)\n    k_L = np.arange(M_L)\n    nodes_L = np.cos(k_L * np.pi / N)\n    weights_L = (-1.0)**k_L\n    weights_L[0] *= 0.5\n    weights_L[N] *= 0.5\n\n    # Differentiation matrix D_L using a direct loop for clarity\n    D_L = np.zeros((M_L, M_L))\n    for i in range(M_L):\n        for j in range(M_L):\n            if i != j:\n                D_L[i, j] = (weights_L[j] / weights_L[i]) / (nodes_L[i] - nodes_L[j])\n    np.fill_diagonal(D_L, -np.sum(D_L, axis=1))\n\n    # Construct linear system A_L u_L = b_L\n    A_L = np.identity(M_L)\n    b_L = np.zeros(M_L)\n    \n    ode_matrix_L = D_L - alpha * np.identity(M_L)\n    \n    # First row: Boundary condition u(1)=1 = u_0 = 1\n    A_L[0, :] = 0.0\n    A_L[0, 0] = 1.0\n    b_L[0] = 1.0\n    \n    # Rows 1 to N: ODE u' - alpha*u = 0 at nodes x_1, ..., x_N\n    A_L[1:, :] = ode_matrix_L[1:, :]\n\n    u_L = np.linalg.solve(A_L, b_L)\n\n    # ====== Part 2: Chebyshev-Gauss Method ======\n    M_G = N\n    # Nodes and weights (0-indexed: k=0, ..., N-1)\n    k_G = np.arange(M_G)\n    nodes_G = np.cos((2 * k_G + 1) * np.pi / (2 * N))\n    weights_G = (-1.0)**k_G\n\n    # Differentiation matrix D_G\n    D_G = np.zeros((M_G, M_G))\n    for i in range(M_G):\n        for j in range(M_G):\n            if i != j:\n                D_G[i, j] = (weights_G[j] / weights_G[i]) / (nodes_G[i] - nodes_G[j])\n    np.fill_diagonal(D_G, -np.sum(D_G, axis=1))\n\n    # Construct linear system A_G u_G = b_G\n    A_G = np.identity(M_G)\n    b_G = np.zeros(M_G)\n    \n    ode_matrix_G = D_G - alpha * np.identity(M_G)\n\n    # First row: BC u(1)=1 implemented via barycentric interpolation.\n    # This replaces the ODE at the node closest to x=1 (k=0).\n    x_star = 1.0\n    phi_G = weights_G / (x_star - nodes_G)\n    beta_G = phi_G / np.sum(phi_G)\n    A_G[0, :] = beta_G\n    b_G[0] = 1.0\n    \n    # Rows 1 to N-1: ODE at remaining nodes\n    A_G[1:, :] = ode_matrix_G[1:, :]\n    \n    u_G = np.linalg.solve(A_G, b_G)\n\n    # ====== Part 3: Error Analysis ======\n    m = 400\n    delta = min(0.5, 8.0 / alpha)\n    x_eval = np.linspace(1.0 - delta, 1.0, m)\n\n    # Evaluate numerical and exact solutions on the fine grid\n    p_L_eval = bary_eval(x_eval, nodes_L, u_L, weights_L)\n    p_G_eval = bary_eval(x_eval, nodes_G, u_G, weights_G)\n    u_exact_eval = np.exp(alpha * (x_eval - 1.0))\n\n    # Compute maximum absolute errors\n    E_Gauss = np.max(np.abs(p_G_eval - u_exact_eval))\n    E_Lobatto = np.max(np.abs(p_L_eval - u_exact_eval))\n\n    # Return log10 of the error ratio, handling E_Lobatto=0\n    if E_Lobatto  1e-100:\n        return np.inf if E_Gauss  0 else -np.inf\n    \n    return np.log10(E_Gauss / E_Lobatto)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (16, 20),\n        (16, 100),\n        (8, 50),\n        (32, 100),\n    ]\n\n    results = []\n    for N, alpha in test_cases:\n        result = solve_case(N, alpha)\n        results.append(result)\n\n    # Format results to scientific notation with 6 decimal places.\n    formatted_results = [\"{:.6e}\".format(r) for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3179398"}, {"introduction": "构建近似解不仅要选择合适的配置点，还需选择恰当的基函数。我们可以使用在整个求解域上都有定义的全局基函数（如多项式），也可以使用仅在局部子区间非零的局部基函数（如B样条）。本练习 [@problem_id:3214198] 将这两种策略置于一个包含尖锐内部层的挑战性问题中进行直接对抗。通过实践，你将发现这两种方法的各自优劣，并理解为何具有局域支撑特性的B样条在捕捉全局多项式难以处理的局部剧变现象时，展现出更强的灵活性和效率。", "problem": "考虑闭区间 $[0,1]$ 上的线性边值问题，该问题由奇异摄动反应扩散算子 $-\\varepsilon \\frac{d^2}{dx^2} + I$ 作用于未知函数 $u(x)$ 给出：\n$$\n-\\varepsilon\\, u''(x) + u(x) = f(x), \\quad x \\in (0,1), \\quad u(0)=g_0, \\quad u(1)=g_1,\n$$\n其中 $\\varepsilon  0$ 是一个小参数，$I$ 表示单位算子。右端项 $f(x)$ 和边界数据 $g_0,g_1$ 的选择是为了满足一个具有尖锐内层的给定精确解。具体来说，对于给定的 $\\varepsilon$，定义精确解\n$$\nu_{\\mathrm{exact}}(x;\\varepsilon) := x + a \\tanh\\!\\Big(\\frac{x-x_0}{\\delta(\\varepsilon)}\\Big),\n$$\n其参数为 $a=0.5$，$x_0=0.5$，层宽度 $\\delta(\\varepsilon) = \\sqrt{\\varepsilon}$。令 $z(x;\\varepsilon) := \\frac{x-x_0}{\\delta(\\varepsilon)}$。其导数为\n$$\nu'_{\\mathrm{exact}}(x;\\varepsilon) = 1 + \\frac{a}{\\delta(\\varepsilon)} \\,\\mathrm{sech}^2\\!\\big(z(x;\\varepsilon)\\big), \\quad\nu''_{\\mathrm{exact}}(x;\\varepsilon) = -\\frac{2a}{\\delta(\\varepsilon)^2}\\,\\mathrm{sech}^2\\!\\big(z(x;\\varepsilon)\\big)\\,\\tanh\\!\\big(z(x;\\varepsilon)\\big).\n$$\n通过以下方式定义右端项和边界数据\n$$\nf(x) := -\\varepsilon\\, u''_{\\mathrm{exact}}(x;\\varepsilon) + u_{\\mathrm{exact}}(x;\\varepsilon), \\quad g_0 := u_{\\mathrm{exact}}(0;\\varepsilon), \\quad g_1 := u_{\\mathrm{exact}}(1;\\varepsilon).\n$$\n这种构造确保了对于每个 $\\varepsilon$，精确解 $u_{\\mathrm{exact}}(x;\\varepsilon)$ 都满足该边值问题。\n\n您的任务是实现两种配置求解器并比较它们的精度：\n\n- 一种局部支撑配置法，使用次数为 $p=3$（三次）的B样条基函数，并在 $[0,1]$ 上使用开放均匀节点向量。假设有 $M$ 个均匀单元（板）。使用 Greville 横坐标作为内部方程的配置点，并在 $x=0$ 和 $x=1$ 处施加两个狄利克雷边界条件。在B样条基中表示解，并在选定的配置点上强制满足微分方程，以获得关于基函数系数的线性系统。\n\n- 一种全局多项式配置法，使用次数为 $n_{\\mathrm{poly}}-1$ 的多项式，并以 $[0,1]$ 上的 Chebyshev–Lobatto 点作为配置节点。基于拉格朗日插值的基本定义，构造一个表示节点处一阶导数算子的微分矩阵。然后，形成离散二阶导数并在内部节点处强制满足微分方程；通过相应地替换第一个和最后一个方程来施加端点处的狄利克雷边界条件，从而得到一个关于节点值的线性系统。\n\n根据基本定义，您的实现应按如下方式构建配置系统：\n- 根据配置法的定义，如果 $u_h(x)$ 表示近似解，则在每个内部配置节点 $x_j$ 处，强制满足 $-\\varepsilon\\, u_h''(x_j) + u_h(x_j) = f(x_j)$。边界方程通过 $u_h(0)=g_0$ 和 $u_h(1)=g_1$ 强制满足。\n- 在B样条方法中，将 $u_h(x)$ 表示为B样条基函数的线性组合，并使用它们的一阶和二阶导数（这些导数可由 Cox–de Boor 递归及其导数关系得出）来组装线性系统。\n- 在全局多项式方法中，在 Chebyshev–Lobatto 节点上用拉格朗日基表示 $u_h(x)$；使用其重心表示法对插值函数进行微分以获得微分矩阵，然后将其平方以近似节点处的二阶导数。\n\n通过在 $[0,1]$ 上的一个精细均匀网格上计算 $L^2$ 误差，来数值评估和比较两种方法的精度：\n$$\n\\|u_h - u_{\\mathrm{exact}}\\|_{L^2(0,1)} \\approx \\sqrt{\\int_0^1 \\big(u_h(x) - u_{\\mathrm{exact}}(x;\\varepsilon)\\big)^2\\,dx},\n$$\n使用复合梯形法则在 $[0,1]$ 的一个足够精细的均匀划分上进行近似。本问题中没有物理单位。\n\n测试套件。您的程序必须运行以下三组参数，并报告两种方法的 $L^2$ 误差：\n- 情况1：$\\varepsilon = 10^{-2}$，$M = 8$，$n_{\\mathrm{poly}} = 10$。\n- 情况2：$\\varepsilon = 10^{-3}$，$M = 8$，$n_{\\mathrm{poly}} = 10$。\n- 情况3：$\\varepsilon = 10^{-3}$，$M = 16$，$n_{\\mathrm{poly}} = 20$。\n\n您的程序必须输出一行，其中包含按以下顺序连接的六个浮点数结果列表\n$$\n[\\mathrm{err}^{\\mathrm{B\\!-\\!spline}}_1,\\ \\mathrm{err}^{\\mathrm{poly}}_1,\\ \\mathrm{err}^{\\mathrm{B\\!-\\!spline}}_2,\\ \\mathrm{err}^{\\mathrm{poly}}_2,\\ \\mathrm{err}^{\\mathrm{B\\!-\\!spline}}_3,\\ \\mathrm{err}^{\\mathrm{poly}}_3],\n$$\n其中 $\\mathrm{err}^{\\mathrm{B\\!-\\!spline}}_k$ 和 $\\mathrm{err}^{\\mathrm{poly}}_k$ 分别是测试用例 $k \\in \\{1,2,3\\}$ 中，B样条配置法和全局多项式配置法的 $L^2$ 误差。输出必须是格式化为 Python 风格列表的单行，用逗号分隔值，例如 $[0.1,0.2,0.3,0.4,0.5,0.6]$。\n\n实现约束：\n- 仅使用编程语言 Python $3.12$ 和库 NumPy $1.23.5$，不得使用其他外部库。\n- 您的代码必须完全自包含，不得读取输入，也不得访问任何文件或网络资源。", "solution": "用户希望使用两种配置方法来求解一个奇异摄动反应扩散边值问题：B样条配置法和全局多项式配置法。\n\n### **1. 问题表述**\n\n该边值问题在区间 $[0,1]$ 上定义如下：\n$$\n-\\varepsilon\\, u''(x) + u(x) = f(x), \\quad x \\in (0,1)\n$$\n边界条件为狄利克雷边界条件 $u(0)=g_0$ 和 $u(1)=g_1$。参数 $\\varepsilon  0$ 很小，表明这是一个奇异摄动问题。\n\n该问题是使用人造解方法构造的。给定精确解 $u_{\\mathrm{exact}}(x;\\varepsilon)$，然后由它定义右端项 $f(x)$ 和边界数据 $g_0, g_1$。\n\n精确解由下式给出：\n$$\nu_{\\mathrm{exact}}(x;\\varepsilon) = x + a \\tanh\\!\\left(\\frac{x-x_0}{\\delta(\\varepsilon)}\\right)\n$$\n其中 $a=0.5$，$x_0=0.5$，层宽度为 $\\delta(\\varepsilon) = \\sqrt{\\varepsilon}$。该函数在 $x=0.5$ 处具有一个宽度与 $\\sqrt{\\varepsilon}$ 成正比的内层。\n\n由此，强迫函数 (forcing function) $f(x)$ 定义为：\n$$\nf(x) = -\\varepsilon\\, u''_{\\mathrm{exact}}(x;\\varepsilon) + u_{\\mathrm{exact}}(x;\\varepsilon)\n$$\n边界数据为：\n$$\ng_0 = u_{\\mathrm{exact}}(0;\\varepsilon), \\quad g_1 = u_{\\mathrm{exact}}(1;\\varepsilon)\n$$\n计算 $f(x)$ 所需的精确解的二阶导数为：\n$$\nu''_{\\mathrm{exact}}(x;\\varepsilon) = -\\frac{2a}{\\delta(\\varepsilon)^2}\\,\\mathrm{sech}^2\\!\\left(\\frac{x-x_0}{\\delta(\\varepsilon)}\\right)\\,\\tanh\\!\\left(\\frac{x-x_0}{\\delta(\\varepsilon)}\\right)\n$$\n\n### **2. B样条配置法**\n\n此方法将解 $u(x)$ 近似为三次B样条基函数的线性组合，$u_h(x) = \\sum_{i=0}^{N-1} c_i B_{i,3}(x)$。\n\n-   **基函数与节点**: 我们在 $M$ 个单元的均匀网格上使用三次B样条（$p=3$）。这需要在 $[0,1]$ 上使用一个开放的均匀节点向量。对于次数 $p$ 和 $M$ 个单元，基函数的数量为 $N=M+p$。节点向量 $t$ 的大小为 $M+2p+1$，其构造方式是在两个端点处具有 $p+1$ 的重数，例如，$t = \\{ \\underbrace{0, \\dots, 0}_{p+1}, \\frac{1}{M}, \\dots, \\frac{M-1}{M}, \\underbrace{1, \\dots, 1}_{p+1} \\}$。\n\n-   **配置点**: 微分方程在内部 Greville 横坐标处强制满足。Greville 横坐标定义为 $\\xi_j = \\frac{1}{p}\\sum_{k=j+1}^{j+p} t_k$，其中 $j=0, \\dots, N-1$。点 $\\xi_0=0$ 和 $\\xi_{N-1}=1$ 是边界点，因此内部配置点为 $\\xi_1, \\dots, \\xi_{N-2}$。共有 $N-2 = M+p-2$ 个这样的点。对于 $p=3$，这是 $M+1$ 个点。\n\n-   **线性系统**: 我们需要求解 $N=M+p$ 个系数 $c_i$。\n    1.  **边界条件**: 在 $x=0$ 和 $x=1$ 处施加狄利克雷边界条件。由于开放节点向量的B样条性质，$B_{0,p}(0)=1$（所有其他基函数为零）且 $B_{N-1,p}(1)=1$（所有其他基函数为零）。这直接确定了第一个和最后一个系数：\n        $$ c_0 = u_h(0) = g_0, \\quad c_{N-1} = u_h(1) = g_1 $$\n    2.  **内部方程**: 对于每个内部配置点 $x_j = \\xi_j$（$j=1, \\dots, N-2$），我们强制满足微分方程：\n        $$ -\\varepsilon u_h''(x_j) + u_h(x_j) = f(x_j) $$\n        将 $u_h(x) = \\sum_{i=0}^{N-1} c_i B_{i,p}(x)$ 代入可得：\n        $$ \\sum_{i=0}^{N-1} c_i \\left( -\\varepsilon B''_{i,p}(x_j) + B_{i,p}(x_j) \\right) = f(x_j) $$\n        由于 $c_0$ 和 $c_{N-1}$ 已知，我们可以将其贡献移到右侧，从而得到一个大小为 $(N-2) \\times (N-2)$ 的线性系统，用于求解未知的内部系数 $c_1, \\dots, c_{N-2}$。\n\n-   **实现**: 基函数 $B_{i,p}(x)$ 及其导数使用 Cox-de Boor 递归及其导数公式计算。这些递归函数通过记忆化（memoization）实现，以避免重复计算。\n\n### **3. 全局多项式配置法**\n\n此方法使用在整个域上的单个次数为 $n_{\\mathrm{poly}}-1$ 的多项式来近似解。\n\n-   **基函数与节点**: 解由其在一组 $n_{\\mathrm{poly}}$ 个配置点上的值 $U_j = u_h(x_j)$ 表示。我们使用 Chebyshev-Lobatto 点，这些点是 Chebyshev 多项式 $T_{n_{\\mathrm{poly}}-1}(x)$ 的极值点，从 $[-1,1]$ 映射到 $[0,1]$：\n    $$ x_j = \\frac{1}{2}\\left(1 - \\cos\\left(\\frac{j\\pi}{n_{\\mathrm{poly}}-1}\\right)\\right), \\quad j=0, \\dots, n_{\\mathrm{poly}}-1 $$\n    这些节点包括端点 $x_0=0$ 和 $x_{n_{\\mathrm{poly}}-1}=1$。\n\n-   **微分矩阵**: 该方法的核心是微分矩阵 $D$，它根据节点值近似函数在这些节点上的导数。然后二阶导数由 $D^2$ 近似。对于 $[-1,1]$ 上的节点，Chebyshev 微分矩阵的元素有解析形式。我们构造这个矩阵，然后根据从 $[-1,1]$ 到 $[0,1]$ 的映射链式法则，将其乘以一个因子 $2$，从而得到我们在 $[0,1]$ 上节点所对应的微分矩阵。\n\n-   **线性系统**: 微分方程在配置节点处被离散化，产生一个矩阵系统：\n    $$ (-\\varepsilon D^2 + I) U = F $$\n    其中 $U = [U_0, \\dots, U_{n_{\\mathrm{poly}}-1}]^T$ 是未知节点值的向量，$I$ 是单位矩阵，$F = [f(x_0), \\dots, f(x_{n_{\\mathrm{poly}}-1})]^T$ 是在节点处求值的强迫函数向量。\n\n    狄利克雷边界条件 $U_0 = g_0$ 和 $U_{n_{\\mathrm{poly}}-1} = g_1$ 通过替换此线性系统的第一行和最后一行来施加。\n    然后求解修改后的系统以获得节点值 $U$。\n\n### **4. 误差评估**\n\n对于这两种方法，在求出近似解 $u_h(x)$ 后，我们计算其与精确解的 $L^2$ 误差：\n$$\n\\|u_h - u_{\\mathrm{exact}}\\|_{L^2(0,1)} = \\sqrt{\\int_0^1 \\left(u_h(x) - u_{\\mathrm{exact}}(x;\\varepsilon)\\right)^2 dx}\n$$\n该积分使用复合梯形法则在 $[0,1]$ 上的一个包含 $2001$ 个点的精细均匀网格上进行数值近似。\n\n-   对于B样条解，$u_h(x)$ 在任意点 $x$ 的值通过其基函数展开式进行评估。\n-   对于多项式解，$u_h(x)$ 使用重心拉格朗日插值进行评估，这是一种在给定节点值的情况下评估插值多项式的稳定且高效的公式。\n\n### **5. 测试用例总结**\n程序对三个指定的测试用例执行此过程，比较局部支撑的B样条方法与全局多项式（谱）方法的精度，特别是在解决奇异摄动问题特有的尖锐内层方面的能力。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the singularly perturbed reaction-diffusion BVP using B-spline and\n    global polynomial collocation methods, and reports the L2 errors.\n    \"\"\"\n    \n    # --- Problem Definition ---\n    # Constants for the exact solution\n    A_PARAM = 0.5\n    X0_PARAM = 0.5\n\n    def u_exact(x, eps):\n        delta = np.sqrt(eps)\n        z = (x - X0_PARAM) / delta\n        # Using np.tanh for vectorization\n        return x + A_PARAM * np.tanh(z)\n\n    def u_exact_d2(x, eps):\n        delta = np.sqrt(eps)\n        z = (x - X0_PARAM) / delta\n        cosh_z = np.cosh(z)\n        sech_z_sq = (1.0 / cosh_z)**2\n        tanh_z = np.tanh(z)\n        return -2.0 * A_PARAM / (delta**2) * sech_z_sq * tanh_z\n\n    def f_rhs(x, eps):\n        return -eps * u_exact_d2(x, eps) + u_exact(x, eps)\n\n    # --- B-Spline Method Implementation ---\n\n    memo_b, memo_b_d1, memo_b_d2 = {}, {}, {}\n\n    def safe_div(num, den):\n        return np.divide(num, den, out=np.zeros_like(num, dtype=float), where=(den != 0))\n\n    def bspline_basis(i, p, x, t):\n        if (i, p, x) in memo_b:\n            return memo_b[(i, p, x)]\n        \n        if p == 0:\n            is_last_interval = (t[i]  t[i+1]) and np.isclose(t[i+1], t[-1])\n            val = 1.0 if (t[i] = x  t[i+1]) or (is_last_interval and np.isclose(x, t[i+1])) else 0.0\n            memo_b[(i, p, x)] = val\n            return val\n\n        term1_coeff = safe_div(x - t[i], t[i+p] - t[i])\n        term1 = term1_coeff * bspline_basis(i, p - 1, x, t)\n\n        term2_coeff = safe_div(t[i+p+1] - x, t[i+p+1] - t[i+1])\n        term2 = term2_coeff * bspline_basis(i + 1, p - 1, x, t)\n        \n        val = term1 + term2\n        memo_b[(i, p, x)] = val\n        return val\n\n    def bspline_deriv1(i, p, x, t):\n        if (i, p, x) in memo_b_d1:\n            return memo_b_d1[(i, p, x)]\n        \n        term1_val = safe_div(p, t[i+p] - t[i]) * bspline_basis(i, p - 1, x, t)\n        term2_val = safe_div(p, t[i+p+1] - t[i+1]) * bspline_basis(i + 1, p - 1, x, t)\n        val = term1_val - term2_val\n        memo_b_d1[(i, p, x)] = val\n        return val\n\n    def bspline_deriv2(i, p, x, t):\n        if (i, p, x) in memo_b_d2:\n            return memo_b_d2[(i, p, x)]\n        if p  2:\n            return 0.0\n\n        term1_val = safe_div(p, t[i+p] - t[i]) * bspline_deriv1(i, p - 1, x, t)\n        term2_val = safe_div(p, t[i+p+1] - t[i+1]) * bspline_deriv1(i + 1, p - 1, x, t)\n        val = term1_val - term2_val\n        memo_b_d2[(i, p, x)] = val\n        return val\n\n    def solve_bspline(eps, M):\n        p = 3\n        knots = np.concatenate([\n            np.zeros(p), \n            np.linspace(0, 1, M + 1), \n            np.ones(p)\n        ])\n        num_basis_funcs = M + p\n\n        greville_pts = np.array([np.mean(knots[i+1:i+p+1]) for i in range(num_basis_funcs)])\n        interior_coll_pts = greville_pts[1:-1]\n        \n        num_interior_coeffs = num_basis_funcs - 2\n        A = np.zeros((num_interior_coeffs, num_interior_coeffs))\n        b = np.zeros(num_interior_coeffs)\n\n        g0, g1 = u_exact(0.0, eps), u_exact(1.0, eps)\n        c0, c_last = g0, g1\n\n        for j, x_coll in enumerate(interior_coll_pts):\n            memo_b.clear(); memo_b_d1.clear(); memo_b_d2.clear()\n            b[j] = f_rhs(x_coll, eps)\n            \n            b0_val, b0_d2_val = bspline_basis(0, p, x_coll, knots), bspline_deriv2(0, p, x_coll, knots)\n            b[j] -= c0 * (-eps * b0_d2_val + b0_val)\n            \n            blast_val, blast_d2_val = bspline_basis(num_basis_funcs - 1, p, x_coll, knots), bspline_deriv2(num_basis_funcs - 1, p, x_coll, knots)\n            b[j] -= c_last * (-eps * blast_d2_val + blast_val)\n            \n            for k in range(num_interior_coeffs):\n                i = k + 1\n                b_val, b_d2_val = bspline_basis(i, p, x_coll, knots), bspline_deriv2(i, p, x_coll, knots)\n                A[j, k] = -eps * b_d2_val + b_val\n        \n        c_interior = np.linalg.solve(A, b)\n        coeffs = np.concatenate(([c0], c_interior, [c_last]))\n        return coeffs, knots, p\n\n    # --- Global Polynomial Method Implementation ---\n    def chebyshev_lobatto_nodes(n_poly):\n        N = n_poly - 1\n        return 0.5 * (1.0 - np.cos(np.pi * np.arange(0, N + 1) / N))\n\n    def chebyshev_lobatto_diff_matrix(n_poly):\n        N = n_poly - 1\n        if N == 0: return np.zeros((1, 1))\n        \n        x = np.cos(np.pi * np.arange(0, N + 1) / N) # Nodes on [-1,1] decreasing\n        c = np.full(N + 1, 1.0); c[0] = c[N] = 2.0\n        \n        D = np.zeros((N + 1, N + 1))\n        for i in range(N + 1):\n            for j in range(N + 1):\n                if i == j:\n                    if i == 0: D[i, j] = (2 * N**2 + 1) / 6.0\n                    elif i == N: D[i, j] = -(2 * N**2 + 1) / 6.0\n                    else: D[i, j] = -x[i] / (2 * (1 - x[i]**2))\n                else:\n                    D[i, j] = (c[i] / c[j]) * ((-1)**(i + j)) / (x[i] - x[j])\n\n        # Matrix for increasing nodes on [0,1]\n        return D[::-1, ::-1] * 2.0\n\n    def solve_poly(eps, n_poly):\n        nodes = chebyshev_lobatto_nodes(n_poly)\n        D = chebyshev_lobatto_diff_matrix(n_poly)\n        D2 = D @ D\n        \n        A = -eps * D2 + np.eye(n_poly)\n        b = f_rhs(nodes, eps)\n        \n        g0, g1 = u_exact(0.0, eps), u_exact(1.0, eps)\n        \n        A[0, :] = 0.0; A[0, 0] = 1.0; b[0] = g0\n        A[-1, :] = 0.0; A[-1, -1] = 1.0; b[-1] = g1\n        \n        U = np.linalg.solve(A, b)\n        return U, nodes\n\n    # --- Error Calculation ---\n    def get_uh_bspline(coeffs, knots, p):\n        def u_h(x_eval):\n            x_eval_arr = np.atleast_1d(x_eval)\n            y = np.zeros_like(x_eval_arr, dtype=float)\n            for i, x in enumerate(x_eval_arr):\n                memo_b.clear(); memo_b_d1.clear(); memo_b_d2.clear()\n                y[i] = sum(c * bspline_basis(j, p, x, knots) for j, c in enumerate(coeffs))\n            return y[0] if isinstance(x_eval, (int, float)) else y\n        return u_h\n\n    def get_uh_poly(nodal_vals, nodes):\n        n_poly = len(nodes)\n        weights = np.ones(n_poly); weights[1::2] = -1\n        weights[0] *= 0.5; weights[-1] *= 0.5\n        \n        def u_h(x_eval):\n            x_eval_arr = np.atleast_1d(x_eval)\n            y = np.zeros_like(x_eval_arr, dtype=float)\n            for i, x in enumerate(x_eval_arr):\n                match = np.isclose(x, nodes)\n                if np.any(match):\n                    y[i] = nodal_vals[np.where(match)[0][0]]\n                else:\n                    terms = weights / (x - nodes)\n                    y[i] = np.sum(terms * nodal_vals) / np.sum(terms)\n            return y[0] if isinstance(x_eval, (int, float)) else y\n        return u_h\n    \n    def calculate_l2_error(u_h_func, eps, N_fine=2000):\n        x_fine = np.linspace(0.0, 1.0, N_fine + 1)\n        u_h_vals = u_h_func(x_fine)\n        u_exact_vals = u_exact(x_fine, eps)\n        squared_errors = (u_h_vals - u_exact_vals)**2\n        return np.sqrt(np.trapz(squared_errors, x_fine))\n\n    # --- Main Execution Loop ---\n    test_cases = [\n        (1e-2, 8, 10),\n        (1e-3, 8, 10),\n        (1e-3, 16, 20),\n    ]\n    \n    results = []\n    \n    for eps, M, n_poly in test_cases:\n        # B-spline\n        coeffs_b, knots_b, p_b = solve_bspline(eps, M)\n        uh_bspline_func = get_uh_bspline(coeffs_b, knots_b, p_b)\n        err_b = calculate_l2_error(uh_bspline_func, eps)\n        results.append(err_b)\n        \n        # Polynomial\n        U_poly, nodes_poly = solve_poly(eps, n_poly)\n        uh_poly_func = get_uh_poly(U_poly, nodes_poly)\n        err_p = calculate_l2_error(uh_poly_func, eps)\n        results.append(err_p)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3214198"}]}