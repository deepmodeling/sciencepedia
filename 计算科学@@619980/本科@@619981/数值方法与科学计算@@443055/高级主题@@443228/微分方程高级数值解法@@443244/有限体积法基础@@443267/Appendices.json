{"hands_on_practices": [{"introduction": "最简单的一阶迎风格式虽然易于实现，但其固有的数值扩散是主要缺点。本练习将通过模拟一个阶梯函数在平流方程下的演化，直观地展示数值扩散如何模糊尖锐的间断，并引导你动手量化这一“抹平”效应的宽度。通过这个实践，你将对一阶格式的精度限制有更深刻的理解。[@problem_id:2394306]", "problem": "考虑一维空间中的线性平流方程\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0\n$$\n，定义在一个长度为 $L$ 的周期性区域上，即 $x \\in [0,L)$，并采用周期性边界条件。平流速度 $a$ 是一个正常数。从积分守恒律和均匀网格上的有限体积平均的定义出发，推导一个与 $a>0$ 时信息传播的物理特性一致的一阶、显式、守恒的有限体积法。\n\n你将通过模拟一个块状阶跃函数的平流过程来研究数值扩散，并量化界面随时间的模糊程度。使用一个包含 $N$ 个网格单元的均匀网格，空间步长为 $\\Delta x = L/N$，网格中心为 $x_i = (i+\\tfrac{1}{2})\\Delta x$，其中 $i=0,1,\\dots,N-1$。设初始条件为块状函数\n$$\nu(x,0) = \\begin{cases}\n1,  x \\in [x_L, x_R),\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n其中 $x_L = 0.2\\,L$ 且 $x_R = 0.7\\,L$。使用一阶有限体积格式演化解，其中显式时间步长 $\\Delta t$ 的选择应满足预设的 Courant–Friedrichs–Lewy (CFL) 数 $\\nu = a\\,\\Delta t/\\Delta x$。在单次模拟的所有时间步中，使用相同的常数 $\\nu$。设模拟运行至一个预设的最终时间 $T$；使用整数个时间步 $n = \\text{round}(T/\\Delta t)$，使得模拟时间为 $t_n = n\\,\\Delta t$。\n\n将时间 $t_n$ 时某个下降界面的“模糊宽度”定义为：网格中心剖面从向下穿过 $\\theta_{\\text{hi}} = 0.9$ 水平线的点，到其后向下穿过 $\\theta_{\\text{lo}} = 0.1$ 水平线的点之间的最小空间距离（沿周期性区域测量）。使用相邻网格中心的网格中心值进行线性插值来计算这些穿越点。当存在多个下降界面时（由于周期性），计算每个下降界面周围的模糊宽度，并报告最小宽度值。该宽度以与 $L$ 相同的无量纲长度单位表示。\n\n在单个程序中实现模拟和宽度测量。对于下方的每个测试用例，输出在时间 $t_n$ 测得的模糊宽度，并四舍五入到 $8$ 位小数。\n\n使用以下测试套件，参数为 $(N,\\ \\nu,\\ T,\\ a,\\ L)$：\n- 用例 1：$(200,\\ 0.5,\\ 0.2,\\ 1.0,\\ 1.0)$。\n- 用例 2：$(200,\\ 0.9,\\ 0.2,\\ 1.0,\\ 1.0)$。\n- 用例 3：$(200,\\ 0.2,\\ 0.2,\\ 1.0,\\ 1.0)$。\n- 用例 4：$(50,\\ 0.5,\\ 0.2,\\ 1.0,\\ 1.0)$。\n- 用例 5：$(200,\\ 1.0,\\ 0.2,\\ 1.0,\\ 1.0)$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。例如，其形式应为\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]\n$$\n，其中每个 $\\text{result}_k$ 是用例 $k$ 的模糊宽度，四舍五入到 $8$ 位小数。不允许有其他任何输出。", "solution": "我们从平流方程的积分守恒形式开始：\n$$\n\\partial_t u(x,t) + \\partial_x f(u) = 0,\\quad f(u) = a u,\\quad a>0\n$$\n设 $\\mathcal{C}_i = [x_{i-\\tfrac{1}{2}}, x_{i+\\tfrac{1}{2}}]$ 是一个宽度均匀的控制体积，其宽度为 $\\Delta x = x_{i+\\tfrac{1}{2}} - x_{i-\\tfrac{1}{2}}$，网格中心为 $x_i = (i+\\tfrac{1}{2})\\Delta x$，并采用周期性索引。定义网格平均值\n$$\n\\bar{u}_i(t) = \\frac{1}{\\Delta x}\\int_{\\mathcal{C}_i} u(x,t)\\,dx.\n$$\n将守恒律在 $\\mathcal{C}_i$ 上积分可得\n$$\n\\frac{d}{dt}\\left( \\int_{\\mathcal{C}_i} u(x,t)\\,dx \\right) + \\left[ f(u(x_{i+\\tfrac{1}{2}},t)) - f(u(x_{i-\\tfrac{1}{2}},t)) \\right] = 0,\n$$\n或等价地，\n$$\n\\frac{d\\bar{u}_i}{dt} = -\\frac{1}{\\Delta x}\\left( f_{i+\\tfrac{1}{2}} - f_{i-\\tfrac{1}{2}} \\right),\n$$\n其中 $f_{i\\pm \\tfrac{1}{2}}$ 是通过网格单元面的通量。使用时间步长 $\\Delta t$ 的一阶显式时间离散得到\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x}\\left( \\hat{f}_{i+\\tfrac{1}{2}}^n - \\hat{f}_{i-\\tfrac{1}{2}}^n \\right),\n$$\n其中数值通量 $\\hat{f}_{i+\\tfrac{1}{2}}^n$ 与物理特性一致。对于 $a>0$ 的线性平流，信息从左向右传播，每个界面上的精确黎曼解仅取决于左侧状态。因此，Godunov 迎风数值通量为\n$$\n\\hat{f}_{i+\\tfrac{1}{2}}^n = a\\,\\bar{u}_i^n\\quad\\text{for }a>0.\n$$\n引入 Courant–Friedrichs–Lewy (CFL) 数 $\\nu = a\\,\\Delta t/\\Delta x$，更新方程简化为一阶迎风格式\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\nu\\left(\\bar{u}_i^n - \\bar{u}_{i-1}^n\\right),\\quad a>0,\n$$\n其中 $i$ 采用周期性索引。\n\n为了将此离散方法与连续过程联系起来并揭示数值扩散，我们进行修正方程分析。记 $\\bar{u}_i^n \\approx u(x_i,t^n)$，其中 $t^n = n\\Delta t$。在时间上进行泰勒展开得到\n$$\n\\bar{u}_i^{n+1} - \\bar{u}_i^n = \\Delta t\\,u_t(x_i,t^n) + \\mathcal{O}(\\Delta t^2).\n$$\n对后向差分在空间上进行泰勒展开得到\n$$\n\\bar{u}_i^n - \\bar{u}_{i-1}^n = \\Delta x\\,u_x(x_i,t^n) - \\frac{\\Delta x^2}{2}u_{xx}(x_i,t^n) + \\frac{\\Delta x^3}{6}u_{xxx}(x_i,t^n) + \\mathcal{O}(\\Delta x^4).\n$$\n代入格式中可得\n$$\n\\Delta t\\,u_t = -\\nu\\left[ \\Delta x\\,u_x - \\frac{\\Delta x^2}{2}u_{xx} + \\frac{\\Delta x^3}{6}u_{xxx} + \\cdots \\right] + \\mathcal{O}(\\Delta t^2).\n$$\n两边除以 $\\Delta t$ 并回顾 $\\nu = a\\Delta t/\\Delta x$，可得\n$$\nu_t + a\\,u_x = \\frac{a\\,\\Delta x}{2}(1 - \\nu)\\,u_{xx} - \\frac{a\\,\\Delta x^2}{6}\\left(1 - 3\\nu + 2\\nu^2\\right)u_{xxx} + \\cdots.\n$$\n首项修正是一个扩散项，其有效（人工）扩散系数为\n$$\nD_{\\text{num}} = \\frac{a\\,\\Delta x}{2}(1 - \\nu).\n$$\n因此，对于 $0  \\nu  1$，一阶迎风法会引入数值扩散，这种扩散会将不连续性模糊化，其模糊宽度随 $\\sqrt{D_{\\text{num}}\\,t}$ 增长；而当 $\\nu=1$ 时，首项扩散项消失，该方法简化为网格上的纯粹移位算子。\n\n为量化阶跃的模糊程度，我们定义 $10$–$90$ 厚度。考虑一个下降界面，其中 $u$ 的值从接近 $1$ 降至接近 $0$。设 $\\theta_{\\text{hi}} = 0.9$ 和 $\\theta_{\\text{lo}} = 0.1$。在分段常数的网格中心剖面 $\\{\\bar{u}_i^n\\}$ 上，我们通过在相邻网格中心之间进行线性插值来确定 $u=\\theta$ 的近似位置。具体来说，对于下降前沿上的一对相邻索引 $(i,i+1)$，且满足 $\\bar{u}_i^n \\ge \\theta  \\bar{u}_{i+1}^n$，\n$$\nx(\\theta) \\approx x_i + \\Delta x \\frac{\\bar{u}_i^n - \\theta}{\\bar{u}_i^n - \\bar{u}_{i+1}^n}.\n$$\n我们收集整个区域内所有向下的 $\\theta_{\\text{hi}}$ 穿越点和所有向下的 $\\theta_{\\text{lo}}$ 穿越点（考虑周期性环绕），然后对于每个 $\\theta_{\\text{hi}}$ 穿越点，我们确定沿周期性坐标到其后的 $\\theta_{\\text{lo}}$ 穿越点的距离。此类距离中的最小值，记为 $w_{10\\text{–}90}$，即为测得的模糊宽度。此宽度以与 $L$ 相同的长度单位报告。\n\n算法设计：\n- 空间离散：均匀网格，周期性边界条件，对于 $a0$ 使用一阶迎风通量 $\\hat{f}_{i+\\tfrac{1}{2}}^n = a\\,\\bar{u}_i^n$。\n- 时间步进：采用前向欧拉法，固定时间步长 $\\Delta t$ 以满足预设的 $\\nu = a\\,\\Delta t/\\Delta x$；推进 $n=\\text{round}(T/\\Delta t)$ 步。\n- 初始化：在 $[0.2L, 0.7L)$ 区间上 $u(x,0)=1$，在 $[0,L)$ 的其他位置为 $0$，在网格中心进行采样。\n- 宽度测量：使用网格中心值的线性插值计算 $w_{10\\text{–}90}$，并取下降界面上 $\\theta_{\\text{hi}}$ 和 $\\theta_{\\text{lo}}$ 穿越点之间的最小下游距离；使用周期性展开处理靠近 $x=0$ 的界面。\n\n基于 $D_{\\text{num}}$ 的定性预期：对于固定的 $a$、$L$ 和 $T$，更精细的网格（更小的 $\\Delta x$）会减小 $D_{\\text{num}}$，从而减少模糊；更大的 $\\nu$（更接近 $1$）也会减小 $D_{\\text{num}}$，产生更窄的界面；当 $\\nu=1$ 时，首项扩散项消失，界面厚度基本上被限制在网格尺度。程序精确地实现了该格式和测量方法，并对每个指定的测试用例 $(N,\\nu,T,a,L)$，输出模糊宽度 $w_{10\\text{–}90}(t_n)$（四舍五入到 $8$ 位小数），并按要求将结果汇总为单行列表。", "answer": "```python\nimport numpy as np\n\ndef upwind_fvm_step(u, nu):\n    \"\"\"\n    First-order upwind finite volume update for a > 0:\n    u_i^{n+1} = u_i^n - nu * (u_i^n - u_{i-1}^n), with periodic indexing.\n    \"\"\"\n    return u - nu * (u - np.roll(u, 1))\n\ndef initialize_block(N, L, xL_frac=0.2, xR_frac=0.7):\n    \"\"\"\n    Initialize u(x,0) = 1 on [x_L, x_R) and 0 elsewhere on [0,L), sampled at cell centers.\n    x_L = xL_frac * L, x_R = xR_frac * L.\n    \"\"\"\n    dx = L / N\n    x = (np.arange(N) + 0.5) * dx\n    xL = xL_frac * L\n    xR = xR_frac * L\n    u0 = np.where((x >= xL)  (x  xR), 1.0, 0.0)\n    return x, u0\n\ndef interpolate_crossing_pos(x_i, x_ip1, u_i, u_ip1, theta, L):\n    \"\"\"\n    Linear interpolation between (x_i, u_i) and (x_ip1, u_ip1) to find x where u=theta.\n    The positions x_i and x_ip1 are assumed to be neighbors on a uniform periodic grid.\n    Returns position wrapped into [0, L).\n    \"\"\"\n    # Handle periodic wrap for positions if necessary (assume uniform spacing)\n    # For uniform grid, x_ip1 - x_i = dx and we do not need special position handling for periodicity;\n    # after computing the position, wrap into [0, L).\n    denom = (u_i - u_ip1)\n    if denom == 0.0:\n        return None\n    frac = (u_i - theta) / denom\n    # x along the straight line between centers\n    xi = x_i + (x_ip1 - x_i) * frac\n    # Wrap into [0, L)\n    xi_wrapped = xi % L\n    return xi_wrapped\n\ndef measure_smearing_width(u, x, L, theta_hi=0.9, theta_lo=0.1):\n    \"\"\"\n    Measure the 10-90 smearing width on descending interfaces using linear interpolation\n    between neighboring cell centers. Returns the minimal width among all descending interfaces.\n    \"\"\"\n    N = len(u)\n    dx = L / N\n    # Build arrays of theta_hi and theta_lo crossing positions for descending fronts\n    hi_positions = []\n    lo_positions = []\n    for i in range(N):\n        ip1 = (i + 1) % N\n        u_i = u[i]\n        u_ip1 = u[ip1]\n        # Descending segment if u_i > u_ip1 (strict to avoid degenerate flat segments)\n        if u_i > u_ip1:\n            # theta_hi crossing: u_i >= theta_hi > u_ip1\n            if (u_i >= theta_hi) and (u_ip1  theta_hi):\n                xi = interpolate_crossing_pos(x[i], x[ip1], u_i, u_ip1, theta_hi, L)\n                if xi is not None:\n                    hi_positions.append(xi)\n            # theta_lo crossing: u_i >= theta_lo > u_ip1\n            if (u_i >= theta_lo) and (u_ip1  theta_lo):\n                xl = interpolate_crossing_pos(x[i], x[ip1], u_i, u_ip1, theta_lo, L)\n                if xl is not None:\n                    lo_positions.append(xl)\n\n    # Sort positions\n    hi_positions = np.sort(np.array(hi_positions, dtype=float)) if len(hi_positions) > 0 else np.array([], dtype=float)\n    lo_positions = np.sort(np.array(lo_positions, dtype=float)) if len(lo_positions) > 0 else np.array([], dtype=float)\n\n    if hi_positions.size == 0 or lo_positions.size == 0:\n        # No descending interfaces detected; width undefined. Return 0.0 as fallback.\n        return 0.0\n\n    # For each hi crossing, find the next downstream lo crossing (with periodicity)\n    widths = []\n    for h in hi_positions:\n        # Compute downstream distances to all lo positions with periodic wrap\n        dists = []\n        for l in lo_positions:\n            d = l - h\n            if d  0:\n                d += L\n            dists.append(d)\n        if len(dists) > 0:\n            widths.append(min(dists))\n    if len(widths) == 0:\n        return 0.0\n    return float(min(widths))\n\ndef simulate_and_measure(N, nu, T, a, L):\n    \"\"\"\n    Run the first-order upwind FVM for linear advection with given parameters and\n    measure the 10-90 smearing width at time ~ T.\n    \"\"\"\n    dx = L / N\n    dt = nu * dx / a\n    # Number of steps to approximate T with fixed dt\n    nsteps = int(np.round(T / dt))\n    # Initialize\n    x, u = initialize_block(N, L, xL_frac=0.2, xR_frac=0.7)\n    # Time-stepping\n    for _ in range(nsteps):\n        u = upwind_fvm_step(u, nu)\n    # Measure width\n    width = measure_smearing_width(u, x, L, theta_hi=0.9, theta_lo=0.1)\n    return width\n\ndef solve():\n    # Define the test cases: (N, nu, T, a, L)\n    test_cases = [\n        (200, 0.5, 0.2, 1.0, 1.0),  # Case 1\n        (200, 0.9, 0.2, 1.0, 1.0),  # Case 2\n        (200, 0.2, 0.2, 1.0, 1.0),  # Case 3\n        (50,  0.5, 0.2, 1.0, 1.0),  # Case 4\n        (200, 1.0, 0.2, 1.0, 1.0),  # Case 5\n    ]\n\n    results = []\n    for N, nu, T, a, L in test_cases:\n        width = simulate_and_measure(N, nu, T, a, L)\n        # Round to 8 decimal places as required\n        results.append(width)\n\n    # Final print statement in the exact required format with rounding\n    print(\"[\" + \",\".join(f\"{w:.8f}\" for w in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2394306"}, {"introduction": "面对一阶格式的数值扩散，一个自然的想法是采用更高阶的格式来提升精度。然而，本练习将揭示一个关键的权衡：未经限制的高阶格式在间断附近会产生非物理的伪振荡。通过直接比较一阶和二阶格式在处理光滑与非光滑解时的 $L^1$ 误差，你将认识到“高阶”并不总是等同于“高精度”，从而理解通量限制器（flux limiters）等技术的重要性。[@problem_id:2394314]", "problem": "您需要比较线性平流方程的两种保守有限体积离散化方法，并量化在何种情况下，由于间断附近的伪振荡，二阶线性重构的表现会比一阶方法更差。\n\n考虑线性平流方程\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0\n$$\n，在一个周期性域 $[0,1)$ 上，平流速度 $a0$ 为常数。设一个划分为 $N$ 个单元的均匀剖分由交界面 $x_{i\\pm \\frac{1}{2}}$ 给出，其中 $x_{i+\\frac{1}{2}}-x_{i-\\frac{1}{2}}=\\Delta x$，单元中心为 $x_i = \\frac{1}{2}\\left(x_{i-\\frac{1}{2}}+x_{i+\\frac{1}{2}}\\right)$。令单元平均值为\n$$\nu_i^n \\equiv \\frac{1}{\\Delta x}\\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u(x,t^n)\\,dx.\n$$\n保守更新公式为\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right),\n$$\n其中，当 $a0$ 时，迎风数值通量为 $F_{i+\\frac{1}{2}}^n = a\\,u_{i+\\frac{1}{2}}^{-,n}$，$u_{i+\\frac{1}{2}}^{-,n}$ 是在 $x_{i+\\frac{1}{2}}$ 处根据单元 $i$ 的数据重构出的左侧迹。假设索引是周期性的，因此 $u_{i+N}^n = u_i^n$ 且 $u_{i-N}^n = u_i^n$。\n\n您必须实现并比较：\n- 一阶重构（分片常数），定义为 $u_{i+\\frac{1}{2}}^{-,n} = u_i^n$。\n- 无任何限制器的二阶线性重构，由斜率 $s_i^n = \\frac{1}{2}\\left(u_{i+1}^n - u_{i-1}^n\\right)$ 定义，且 $u_{i+\\frac{1}{2}}^{-,n} = u_i^n + \\frac{1}{2}s_i^n$。\n\n使用固定的 Courant-Friedrichs-Lewy (CFL) 数 $\\nu \\in (0,1)$ 通过以下公式设置时间步长\n$$\n\\Delta t = \\nu \\frac{\\Delta x}{a}.\n$$\n如果最终时间 $T$ 不是 $\\Delta t$ 的整数倍，则最后一步采用一个缩减的 $\\Delta t$，以使总积分时间恰好等于 $T$。\n\n对于下方的每个测试用例，用每种方法计算在时间 $T$ 的数值解，然后计算在时间 $T$ 的单元平均精确解，其由下式给出\n$$\nu(x,T) = u_0\\big((x - a T) \\bmod 1\\big),\n$$\n及其单元平均值\n$$\n\\bar{u}_i^{\\text{exact}}(T) = \\frac{1}{\\Delta x}\\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u(y,T)\\,dy.\n$$\n使用单元平均值的离散 $L^1$ 范数来量化误差：\n$$\nE_1 = \\Delta x \\sum_{i=0}^{N-1} \\left| u_i(T) - \\bar{u}_i^{\\text{exact}}(T) \\right|.\n$$\n\n所有情况下均使用 $a = 1$ 和 $\\nu = 0.9$。所有情况下的域均为 $[0,1)$，带有周期性边界条件。测试套件的初始条件 $u_0(x)$、单元数 $N$ 和最终时间 $T$ 如下：\n\n- 测试用例 1（间断方帽，非对齐）：$N=200$，$T=0.25$，以及\n  $$\n  u_0(x) = \\begin{cases}\n  1,  x \\in [0.2, 0.4),\\\\\n  0,  \\text{otherwise,}\n  \\end{cases}\n  $$\n  在 $[0,1)$ 上周期性地解释。\n\n- 测试用例 2（平滑波）：$N=80$，$T=0.5$，以及\n  $$\n  u_0(x) = \\sin(2\\pi x).\n  $$\n\n- 测试用例 3（与网格间距相关的窄方帽）：$N=80$，$T=0.3$，以及\n  $$\n  u_0(x) = \\begin{cases}\n  1,  x \\in [x_0, x_0 + 3\\Delta x),\\\\\n  0,  \\text{otherwise,}\n  \\end{cases}\n  $$\n  其中 $x_0 = 0.33$ 且 $\\Delta x = 1/N$；将 $[x_0, x_0+3\\Delta x)$ 解释为模 $1$。\n\n对于每个测试用例，计算一阶方法的 $E_1^{(1)}$ 和无限制器二阶线性重构的 $E_1^{(2)}$。如果 $E_1^{(2)}  E_1^{(1)}$，则为该测试用例返回整数 $1$，否则返回整数 $0$。\n\n您的程序应生成一行输出，其中包含按顺序排列的三个测试用例的整数，形式为方括号括起来的逗号分隔列表（例如，$[1,0,1]$）。不应产生任何其他输出。", "solution": "所提出的问题要求对一维线性平流方程 $\\partial_t u + a\\,\\partial_x u = 0$ 的两种有限体积法离散化进行比较分析。该比较基于离散 $L^1$ 误差范数，针对平滑初始剖面和间断初始剖面，与精确解进行对比。该分析旨在说明守恒律数值方法中的一个基本权衡：高阶格式在平滑解上的准确性，与其在没有配备斜率限制器时在间断附近产生伪振荡的倾向。\n\n首先，我们建立离散框架。空间域 $[0,1)$ 被划分为 $N$ 个均匀单元，每个单元的宽度为 $\\Delta x = 1/N$。单元 $i$ 覆盖区间 $[x_{i-1/2}, x_{i+1/2}]$，其中对于 $i=-1, \\dots, N-1$，有 $x_{i+1/2} = (i+1)\\Delta x$。单元中心是 $x_i = (i+1/2)\\Delta x$。函数 $f(x)$ 在单元 $i$ 上的单元平均值记为 $f_i = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} f(x) \\, dx$。\n\n有限体积法通过以下保守公式将时间 $t^n$ 的单元平均值 $u_i^n$ 演化到 $t^{n+1}=t^n+\\Delta t$：\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2}^n - F_{i-1/2}^n \\right)\n$$\n这里，$F_{i+1/2}^n$ 是交界面 $x_{i+1/2}$ 处的数值通量。对于速度 $a0$ 的线性平流方程，通量是纯迎风的，这意味着它仅取决于交界面左侧的状态。这得到 $F_{i+1/2}^n = a \\cdot u_{i+1/2}^{-,n}$，其中 $u_{i+1/2}^{-,n}$ 是根据单元 $i$ 中的数据在交界面 $x_{i+1/2}$ 左侧重构的解的值。时间步长 $\\Delta t$ 由固定的 CFL 数 $\\nu = a \\Delta t / \\Delta x$ 决定，因此 $\\Delta t = \\nu \\Delta x / a$。问题指定 $a=1$ 和 $\\nu=0.9$。更新方程简化为：\n$$\nu_i^{n+1} = u_i^n - \\nu \\left( u_{i+1/2}^{-,n} - u_{i-1/2}^{-,n} \\right)\n$$\n施加周期性边界条件，因此索引按模 $N$ 处理。\n\n我们研究两种用于 $u_{i+1/2}^{-,n}$ 的重构方法：\n\n1.  **一阶迎风法**：此方法在每个单元内使用分片常数重构，$u(x) = u_i^n$ for $x \\in [x_{i-1/2}, x_{i+1/2}]$。交界面 $x_{i+1/2}$ 左侧的值就是单元 $i$ 的单元平均值：\n    $$\n    u_{i+1/2}^{-,n} = u_i^n\n    $$\n    将此代入更新公式，得到经典的一阶迎风格式：\n    $$\n    u_i^{n+1} = u_i^n - \\nu \\left( u_i^n - u_{i-1}^n \\right)\n    $$\n    已知该格式对于 $\\nu \\in [0,1]$ 是总变差递减 (TVD) 的，这可以防止新振荡的产生。然而，其精度只有一阶，导致显著的数值耗散，这会抹平尖锐特征。\n\n2.  **二阶线性重构（无限制）**：此方法在每个单元内使用分片线性重构，$u(x) = u_i^n + s_i^n(x - x_i)$。问题中根据一个指定的斜率公式定义了交界面处的重构，我们将其解释为无量纲斜率。重构值由 $u_{i+1/2}^{-,n} = u_i^n + \\frac{1}{2}s_i^n$ 给出，其中 $s_i^n = \\frac{1}{2}(u_{i+1}^n - u_{i-1}^n)$。将它们结合起来得到：\n    $$\n    u_{i+1/2}^{-,n} = u_i^n + \\frac{1}{4}\\left( u_{i+1}^n - u_{i-1}^n \\right)\n    $$\n    对于平滑解，该重构在空间上以二阶精度逼近点值 $u(x_{i+1/2})$。更新公式变为：\n    $$\n    u_i^{n+1} = u_i^n - \\nu \\left[ \\left( u_i^n + \\frac{1}{4}(u_{i+1}^n - u_{i-1}^n) \\right) - \\left( u_{i-1}^n + \\frac{1}{4}(u_i^n - u_{i-2}^n) \\right) \\right]\n    $$\n    $$\n    u_i^{n+1} = u_i^n - \\nu \\left( \\frac{3}{4}u_i^n - \\frac{5}{4}u_{i-1}^n + \\frac{1}{4}u_{i+1}^n + \\frac{1}{4}u_{i-2}^n \\right)\n    $$\n    这是一个涉及单元 $i-2, i-1, i, i+1$ 的四点模板的线性格式。虽然它在平滑解上达到了二阶精度，但它不是 TVD，并且已知是色散的，会在间断附近产生伪振荡（吉布斯现象）。本练习的目的是量化这些振荡何时会导致比耗散性的一阶格式更大的误差。\n\n为了进行分析，我们首先通过在每个单元上对初始条件 $u_0(x)$ 进行积分来计算初始单元平均值 $u_i^0$。\n- 对于方帽函数 $u_0(x) = 1$ 在区间 $[b_1, b_2)$ 上，否则为 $0$，单元平均值为 $u_i^0 = \\frac{1}{\\Delta x} \\text{length}([x_{i-1/2}, x_{i+1/2}] \\cap [b_1, b_2))$。\n- 对于平滑函数 $u_0(x) = \\sin(2\\pi x)$，积分可以解析计算：\n  $$\n  u_i^0 = \\frac{1}{\\Delta x} \\int_{i\\Delta x}^{(i+1)\\Delta x} \\sin(2\\pi x) dx = \\frac{\\cos(2\\pi i\\Delta x) - \\cos(2\\pi(i+1)\\Delta x)}{2\\pi\\Delta x} = \\frac{\\sin(\\pi\\Delta x)}{\\pi\\Delta x}\\sin(2\\pi x_i)\n  $$\n\n平流方程的精确解是 $u(x,T) = u_0((x-aT)\\pmod 1)$。在最终时间 $T$ 的精确单元平均值是通过在每个单元上积分此精确解来计算的：\n$$\n\\bar{u}_i^{\\text{exact}}(T) = \\frac{1}{\\Delta x}\\int_{x_{i-1/2}}^{x_{i+1/2}} u_0((x-aT)\\pmod 1) \\,dx\n$$\n此计算类似于求初始单元平均值，但初始剖面被平移了 $aT$。\n\n时间积分以固定时间步长 $\\Delta t = \\nu \\Delta x / a$ 进行若干个完整步长 $N_{\\text{steps}} = \\lfloor T/\\Delta t \\rfloor$。如果存在剩余时间 $\\Delta t_{\\text{final}} = T - N_{\\text{steps}}\\Delta t  0$，则采用一个最终的、更小的时间步长，以精确达到时间 $T$。\n\n最后，使用离散 $L^1$ 范数量化每种方法的误差：\n$$\nE_1 = \\Delta x \\sum_{i=0}^{N-1} \\left| u_i(T) - \\bar{u}_i^{\\text{exact}}(T) \\right|\n$$\n对于每个测试用例，我们计算一阶方法的误差 $E_1^{(1)}$ 和二阶方法的误差 $E_1^{(2)}$。然后我们确定是否 $E_1^{(2)}  E_1^{(1)}$。\n\n- **测试用例 1（间断方帽）**：初始条件是间断的。二阶方法将在方帽的边缘产生显著的过冲和下冲。一阶方法将抹平边缘。与耗散但无振荡的一阶格式相比，二阶格式产生的大且不衰减的振荡预计会导致更大的 $L^1$ 误差。因此，我们预期 $E_1^{(2)}  E_1^{(1)}$。\n- **测试用例 2（平滑波）**：初始条件是 $C^\\infty$。对于此类解，二阶方法的卓越精度将显而易见。与高耗散性的一阶方法相比，它将以小得多的误差逼近正弦波。我们预期 $E_1^{(2)}  E_1^{(1)}$。\n- **测试用例 3（窄方帽）**：这是另一个间断情况，由于特征的宽度只有几个网格单元（$3\\Delta x$），因此更具挑战性。这突显了无限制线性重构的缺陷，因为用于计算斜率的模板跨越了特征的很大一部分。我们再次预期会出现大振荡且 $E_1^{(2)}  E_1^{(1)}$。\n\n实现将通过创建一个可配置为任一方法的通用有限体积求解器来进行。该求解器将应用于每个测试用例，计算误差，并按要求进行比较。", "answer": "```python\nimport numpy as np\n\ndef get_box_averages(N, box_start, box_end):\n    \"\"\"\n    Computes cell averages for a function that is 1 on [box_start, box_end)\n    and 0 otherwise, on a periodic domain [0,1).\n    \"\"\"\n    dx = 1.0 / N\n    cell_starts = np.arange(N) * dx\n    cell_ends = (np.arange(N) + 1) * dx\n    u_avg = np.zeros(N)\n\n    # Handle multiple integer wrappings of the interval\n    num_wraps = np.floor(box_end) - np.floor(box_start)\n    s_mod = box_start % 1.0\n    e_mod = box_end % 1.0\n\n    if num_wraps == 0: # Interval does not cross an integer\n        s, e = s_mod, e_mod\n        if e = s: # e.g. [0.2, 0.1) or [0.2, 0.2)\n            return u_avg\n        overlap = np.maximum(0, np.minimum(cell_ends, e) - np.maximum(cell_starts, s))\n        u_avg += overlap\n    else: # Interval crosses at least one integer\n        # Part from start to 1.0\n        overlap1 = np.maximum(0, np.minimum(cell_ends, 1.0) - np.maximum(cell_starts, s_mod))\n        u_avg += overlap1\n        # Part from 0.0 to end\n        overlap2 = np.maximum(0, np.minimum(cell_ends, e_mod) - np.maximum(cell_starts, 0.0))\n        u_avg += overlap2\n        # Full wraps\n        if num_wraps > 1:\n            u_avg += (num_wraps - 1) * dx\n\n    return u_avg / dx\n\ndef run_fvm(u_initial, N, T, a, nu_fixed, method):\n    \"\"\"\n    Solves the linear advection equation using the finite volume method.\n    \"\"\"\n    u = u_initial.copy()\n    dx = 1.0 / N\n    \n    dt_fixed = nu_fixed * dx / a\n    if dt_fixed = 0:\n        return u\n        \n    num_steps = int(T / dt_fixed) if T > 0 else 0\n    t = 0.0\n\n    # Perform full time steps\n    for _ in range(num_steps):\n        nu = nu_fixed\n        if method == 'first':\n            # First-order upwind\n            u = u - nu * (u - np.roll(u, 1))\n        elif method == 'second':\n            # Second-order unlimited linear reconstruction\n            u_p1 = np.roll(u, -1)\n            u_m1 = np.roll(u, 1)\n            s = 0.5 * (u_p1 - u_m1)\n            u_interface = u + 0.5 * s\n            flux_diff = u_interface - np.roll(u_interface, 1)\n            u = u - nu * flux_diff\n        t += dt_fixed\n    \n    # Perform final, smaller time step if needed\n    dt_final = T - t\n    if dt_final > 1e-12:\n        nu_final = a * dt_final / dx\n        if method == 'first':\n            u = u - nu_final * (u - np.roll(u, 1))\n        elif method == 'second':\n            u_p1 = np.roll(u, -1)\n            u_m1 = np.roll(u, 1)\n            s = 0.5 * (u_p1 - u_m1)\n            u_interface = u + 0.5 * s\n            flux_diff = u_interface - np.roll(u_interface, 1)\n            u = u - nu_final * flux_diff\n            \n    return u\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        # (N, T, initial_condition_type, params)\n        (200, 0.25, 'top-hat', {'start': 0.2, 'end': 0.4}),\n        (80, 0.5, 'sine-wave', {}),\n        (80, 0.3, 'narrow-top-hat', {'x0': 0.33}),\n    ]\n\n    a = 1.0\n    nu_fixed = 0.9\n    results = []\n\n    for N, T, u0_type, params in test_cases:\n        dx = 1.0 / N\n        x_centers = (np.arange(N) + 0.5) * dx\n\n        # --- Initial Conditions ---\n        if u0_type == 'top-hat':\n            start, end = params['start'], params['end']\n            u_initial = get_box_averages(N, start, end)\n        elif u0_type == 'sine-wave':\n            # Use analytical formula for cell-averaged sine\n            factor = np.sinc(dx) # np.sinc(x) = sin(pi*x)/(pi*x)\n            u_initial = factor * np.sin(2 * np.pi * x_centers)\n        elif u0_type == 'narrow-top-hat':\n            x0 = params['x0']\n            start = x0\n            end = x0 + 3 * dx\n            u_initial = get_box_averages(N, start, end)\n\n        # --- Run Simulations ---\n        u_final_1st = run_fvm(u_initial, N, T, a, nu_fixed, 'first')\n        u_final_2nd = run_fvm(u_initial, N, T, a, nu_fixed, 'second')\n        \n        # --- Exact Solution ---\n        shift = (a * T) % 1.0\n        if u0_type == 'top-hat':\n            start, end = params['start'], params['end']\n            u_exact = get_box_averages(N, start + shift, end + shift)\n        elif u0_type == 'sine-wave':\n            # u(x,T) = sin(2*pi*(x-aT)) = sin(2*pi*x - 2*pi*aT)\n            # For T=0.5, a=1, this is sin(2*pi*x - pi) = -sin(2*pi*x)\n            factor = np.sinc(dx)\n            u_exact = -factor * np.sin(2 * np.pi * x_centers)\n        elif u0_type == 'narrow-top-hat':\n            x0 = params['x0']\n            start = x0\n            end = x0 + 3 * dx\n            u_exact = get_box_averages(N, start + shift, end + shift)\n\n        # --- Compute Errors and Compare ---\n        e1_1st = dx * np.sum(np.abs(u_final_1st - u_exact))\n        e1_2nd = dx * np.sum(np.abs(u_final_2nd - u_exact))\n        \n        results.append(1 if e1_2nd > e1_1st else 0)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2394314"}, {"introduction": "真实的物理世界充满了非线性现象，例如激波的形成，这为数值模拟带来了新的挑战。在本练习中，我们将从线性平流方程迈向非线性的无粘伯格斯方程。你将亲手实现并比较一个简单的迎风格式和一个更强大的 HLL 近似黎曼求解器，通过对比它们捕捉激波和稀疏波的能力，理解为何处理非线性守恒律需要更精巧的数值通量设计。[@problem_id:2394328]", "problem": "实现一个用于求解无粘伯格斯方程的一维有限体积求解器，使用两种不同的数值通量，并比较它们捕捉激波和稀疏波的能力。出发点是守恒律及其积分形式。从基本守恒声明开始：对于密度为 $u(x,t)$、通量为 $f(u)$ 的守恒量，其局部守恒律为 $u_t + f(u)_x = 0$。在一个控制体积 $[x_{i-\\frac{1}{2}}, x_{i+\\frac{1}{2}}]$ 上，其积分形式为 $\\frac{d}{dt}\\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u(x,t)\\,dx + \\left.f(u)\\right|_{x_{i+\\frac{1}{2}}} - \\left.f(u)\\right|_{x_{i-\\frac{1}{2}}} = 0$。将其离散化，以获得在时间 $t^n$、时间步长为 $\\Delta t$、单元宽度为 $\\Delta x$ 的条件下，对单元平均值 $U_i^n$ 的一阶有限体积更新。这需要用近似局部黎曼问题解的数值通量来替代界面上的物理通量。问题陈述中未提供其他公式；您必须根据这些原理推导出离散更新和数值通量。\n\n使用特定的守恒律 $u_t + \\left(\\frac{1}{2}u^2\\right)_x = 0$，即无粘伯格斯方程，其通量为 $f(u)=\\frac{1}{2}u^2$。在每个单元界面上，根据左、右状态 $u_L$ 和 $u_R$ 实现两种数值通量：\n- 一种 Harten–Lax–van Leer (HLL) 近似黎曼求解器，其推导方法是通过最小和最大特征速度来限定信号速度，并对近似黎曼扇进行积分。对于标量情况，当波被左、右特征速度正确定界时，该方法可简化为一种 Godunov 型通量。\n- 一种基本的迎风通量，其获得方法是使用根据界面状态计算出的单一平流速度对非线性通量进行局部线性化，并根据该速度的符号应用施主单元迎风法则。\n\n算法要求：\n- 在域 $[x_L,x_R] = [-1,1]$ 上使用包含 $N$ 个单元的均匀网格，单元中心位于 $x_i = x_L + \\left(i + \\frac{1}{2}\\right)\\Delta x$，其中 $i=0,1,\\dots,N-1$，$\\Delta x = \\frac{x_R - x_L}{N}$。\n- 初始化一个在 $x=0$ 处存在间断的黎曼问题：当 $x  0$ 时，$u(x,0) = u_L$；当 $x \\ge 0$ 时，$u(x,0) = u_R$。\n- 使用显式前向欧拉方法对有限体积进行时间推进，直至最终时间 $T$。在每个时间步长，基于域中的最大特征速度 $|f'(u)| = |u|$ 强制执行 Courant–Friedrichs–Lewy (CFL) 稳定性条件。使用 $\\Delta t \\le \\nu \\frac{\\Delta x}{\\max_i |u_i|}$，并选择一个严格小于 $1$ 的 CFL 数 $\\nu$。\n- 应用透射（零梯度）边界条件，通过在每侧设置一个虚拟单元来实现，并在每个时间步将最近的内部值复制到相应的虚拟单元中。\n\n用于误差评估的参考解：\n- 推导并使用无粘伯格斯方程的精确自相似黎曼解，以计算单元中心处的参考值 $u(x_i,T)$。对于 $u_L  u_R$ 的情况，解是一个激波，其传播速度由 Rankine–Hugoniot 条件给出。对于 $u_L  u_R$ 的情况，解是一个中心稀疏扇，在左、右特征速度之间具有线性剖面。\n\n测试套件和输出：\n- 所有测试均使用 $N=400$，$\\nu=0.9$，域 $[x_L,x_R]=[-1,1]$，间断点在 $x=0$，最终时间为 $T=0.3$。定义三种初始状态 $(u_L,u_R)$：\n  1. $u_L=2.0$, $u_R=0.0$（激波主导情况）。\n  2. $u_L=0.0$, $u_R=2.0$（膨胀稀疏波情况）。\n  3. $u_L=-1.0$, $u_R=1.0$（跨音速稀疏波情况）。\n- 对于每个测试用例 $k \\in \\{1,2,3\\}$，计算每种数值通量格式相对于精确解的离散 $L^1$ 误差：\n  $$E_{\\mathrm{HLL}}^{(k)} = \\Delta x \\sum_{i=0}^{N-1} \\left| U_{i,\\mathrm{HLL}}(T) - u_{\\mathrm{exact}}(x_i,T) \\right|,$$\n  $$E_{\\mathrm{UP}}^{(k)} = \\Delta x \\sum_{i=0}^{N-1} \\left| U_{i,\\mathrm{UP}}(T) - u_{\\mathrm{exact}}(x_i,T) \\right|.$$\n- 对于每个测试，还需计算一个指示符 $I^{(k)}$，如果 $E_{\\mathrm{HLL}}^{(k)}  E_{\\mathrm{UP}}^{(k)}$，则该整数为 $1$，否则为 $0$。\n\n单位：所有量均为无量纲；仅报告无量纲数。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按以下顺序包含九个结果\n  $$\\left[ E_{\\mathrm{HLL}}^{(1)}, E_{\\mathrm{UP}}^{(1)}, I^{(1)}, E_{\\mathrm{HLL}}^{(2)}, E_{\\mathrm{UP}}^{(2)}, I^{(2)}, E_{\\mathrm{HLL}}^{(3)}, E_{\\mathrm{UP}}^{(3)}, I^{(3)} \\right],$$\n  其中每个误差 $E_{\\mathrm{HLL}}^{(k)}$ 和 $E_{\\mathrm{UP}}^{(k)}$ 必须精确到六位小数，每个指示符 $I^{(k)}$ 都是一个整数。例如，打印的字符串应类似于 $[\\dots]$，包含九个逗号分隔的条目，且无其他文本。", "solution": "问题陈述已经过严谨分析，并被认定为有效。它在计算物理学领域内构成了一个适定且有科学依据的问题。所有必要的参数和定义均已提供，从而可以明确地构建和验证数值解。要求从第一性原理推导基本公式是一项标准的教学练习，旨在检验基础理解，并非问题规范中的缺陷。\n\n我们继续进行解的推导和实现。\n\n**1. 有限体积离散化**\n\n出发点是守恒量 $u$ 在宽度为 $\\Delta x = x_{i+1/2} - x_{i-1/2}$ 的控制体积（或单元）$C_i = [x_{i-1/2}, x_{i+1/2}]$ 上的积分形式守恒律：\n$$\n\\frac{d}{dt}\\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t)\\,dx + f(u(x_{i+1/2},t)) - f(u(x_{i-1/2},t)) = 0\n$$\n我们将单元 $C_i$ 上 $u$ 的单元平均值定义为 $U_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x, t) dx$。将此定义代入积分守恒律，可得到一个关于单元平均值演化的精确方程：\n$$\n\\frac{d}{dt} (\\Delta x U_i(t)) + f_{i+1/2} - f_{i-1/2} = 0\n$$\n其中 $f_{i \\pm 1/2}$ 表示在单元界面 $x_{i \\pm 1/2}$ 处的瞬时物理通量 $f(u)$。假设网格均匀，$\\Delta x$ 为常数，则上式可简化为：\n$$\n\\frac{dU_i}{dt} = - \\frac{1}{\\Delta x} (f_{i+1/2} - f_{i-1/2})\n$$\n有限体积方法的核心原理是用数值通量 $\\hat{f}_{i \\pm 1/2}$ 替代未知的逐点物理通量 $f_{i \\pm 1/2}$。在单元 $i$ 和单元 $i+1$ 之间的界面上的数值通量，记为 $\\hat{f}_{i+1/2}$，是相邻单元中单元平均状态的函数，即 $\\hat{f}_{i+1/2} = \\hat{f}(U_i, U_{i+1})$。由此产生的半离散格式为：\n$$\n\\frac{dU_i}{dt} = - \\frac{1}{\\Delta x} \\left( \\hat{f}(U_i, U_{i+1}) - \\hat{f}(U_{i-1}, U_i) \\right)\n$$\n为了获得全离散格式，我们使用显式前向欧拉方法对时间进行离散化。对于时间步长 $\\Delta t$，在时间步 $n+1$ 处的单元平均值由时间步 $n$ 处的值给出：\n$$\n\\frac{U_i^{n+1} - U_i^n}{\\Delta t} = - \\frac{1}{\\Delta x} \\left( \\hat{f}(U_i^n, U_{i+1}^n) - \\hat{f}(U_{i-1}^n, U_i^n) \\right)\n$$\n这给出了一阶精度的更新公式：\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x} \\left( \\hat{f}(U_i^n, U_{i+1}^n) - \\hat{f}(U_{i-1}^n, U_i^n) \\right)\n$$\n\n**2. 数值通量函数**\n\n该问题指定了无粘伯格斯方程，$u_t + \\left(\\frac{1}{2}u^2\\right)_x = 0$。其通量为 $f(u) = \\frac{1}{2}u^2$，代表特征速度的雅可比矩阵为 $f'(u) = u$。我们推导所需的两种数值通量 $\\hat{f}(u_L, u_R)$，其中 $u_L$ 和 $u_R$ 是单元界面左侧和右侧的重构状态。对于我们的一阶格式，这些状态就是相邻单元的单元平均值。\n\n**2.1. 基本迎风通量**\n该通量基于线性平流方程 $u_t + a u_x = 0$ 的解，其中信息以速度 $a$ 传播。对于非线性伯格斯方程，我们在界面处定义一个单一的局部平流速度 $a(u_L, u_R)$。一个常见的选择是算术平均值，它对应于该方程的 Roe 平均：\n$$\na(u_L, u_R) = \\frac{u_L + u_R}{2}\n$$\n这个速度也是 Rankine-Hugoniot 激波速度。迎风通量根据此平流速度的符号从“上游”侧选择通量：\n$$\n\\hat{f}_{\\text{upwind}}(u_L, u_R) = \\begin{cases} f(u_L)  \\text{if } a(u_L, u_R) \\ge 0 \\\\ f(u_R)  \\text{if } a(u_L, u_R)  0 \\end{cases}\n$$\n\n**2.2. Harten-Lax-van Leer (HLL) 通量**\nHLL 通量由一个近似黎曼求解器构建，该求解器假设一个双波模型。它假定界面处的解由三个恒定状态（$u_L$、$u^*$、$u_R$）组成，由两个速度为 $S_L$ 和 $S_R$ 的波分隔。这些速度必须界定真实黎曼解的所有特征速度。对于标量伯格斯方程，真实的波速被 $\\min(u_L, u_R)$ 和 $\\max(u_L, u_R)$ 界定。因此，我们选择这些作为我们的信号速度估计值：\n$$\nS_L = \\min(u_L, u_R) \\quad \\text{and} \\quad S_R = \\max(u_L, u_R)\n$$\n通过在包含波结构的控制体积上应用积分守恒律，可以推导出 HLL 通量。该公式取决于波相对于单元界面（其中 $x/t = 0$）的传播方向：\n- 如果 $S_L \\ge 0$，整个波结构向右传播。界面处的状态是 $u_L$，通量为 $\\hat{f}_{\\text{HLL}} = f(u_L)$。\n- 如果 $S_R \\le 0$，整个结构向左传播。界面处的状态是 $u_R$，通量为 $\\hat{f}_{\\text{HLL}} = f(u_R)$。\n- 如果 $S_L  0  S_R$，界面位于两个波之间。通量是一个确保守恒的加权平均值：\n  $$\n  \\hat{f}_{\\text{HLL}}(u_L, u_R) = \\frac{S_R f(u_L) - S_L f(u_R) + S_L S_R (u_R - u_L)}{S_R - S_L}\n  $$\n这个组合公式提供了一个鲁棒且守恒的数值通量。\n\n**3. 无粘伯格斯方程的精确黎曼解**\n\n伯格斯方程的黎曼问题的精确解是自相似的，仅取决于变量 $\\xi = x/t$。解的性质由初始左、右状态 $u_L$ 和 $u_R$ 之间的关系决定。\n\n- **激波 ($u_L  u_R$)**：形成一个单一间断，并以由 Rankine-Hugoniot 条件给出的恒定速度 $s$ 传播：\n  $$\n  s = \\frac{f(u_R) - f(u_L)}{u_R - u_L} = \\frac{\\frac{1}{2}u_R^2 - \\frac{1}{2}u_L^2}{u_R - u_L} = \\frac{u_L + u_R}{2}\n  $$\n  解是一个阶跃函数：\n  $$\n  u(x,t) = \\begin{cases} u_L,  \\text{if } x/t  s \\\\ u_R,  \\text{if } x/t  s \\end{cases}\n  $$\n\n- **稀疏波 ($u_L  u_R$)**：解是一个连接左、右状态的连续“扇”。在扇内，解由 $u(x,t) = x/t$ 给出。该扇跨越特征速度 $\\lambda(u_L)=u_L$ 和 $\\lambda(u_R)=u_R$ 之间的区域。完整的解是：\n  $$\n  u(x,t) = \\begin{cases} u_L,  \\text{if } x/t \\le u_L \\\\ x/t,  \\text{if } u_L  x/t  u_R \\\\ u_R,  \\text{if } x/t \\ge u_R \\end{cases}\n  $$\n该精确解将作为计算数值格式 $L^1$ 误差的参考。\n\n**4. 数值算法摘要**\n\n求解器根据以下规范实现：\n- **域和网格**：$[x_L, x_R] = [-1, 1]$，包含 $N=400$ 个单元，因此 $\\Delta x = (1 - (-1))/400 = 0.005$。\n- **状态向量**：使用一个大小为 $N+2$ 的 NumPy 数组，其中索引 $1, \\dots, N$ 代表上述单元，索引 $0$ 和 $N+1$ 分别代表左、右虚拟单元。\n- **初始条件**：根据单元中心相对于 $x=0$ 处间断的位置来初始化单元平均值。\n- **边界条件**：在每个时间步通过将虚拟单元的值设置为相邻内部单元的值来强制执行透射（零梯度）条件：$U_0^n = U_1^n$ 和 $U_{N+1}^n = U_N^n$。\n- **时间步进**：模拟从 $t=0$ 运行到 $T=0.3$。在每一步动态计算时间步长 $\\Delta t$ 以满足 Courant-Friedrichs-Lewy (CFL) 条件：$\\Delta t = \\nu \\frac{\\Delta x}{\\max_i |U_i^n|}$，CFL 数 $\\nu=0.9$。调整最后的时间步长以确保模拟在 $T$ 时刻精确结束。\n- **误差计算**：对于每个测试用例和通量类型，离散 $L^1$ 误差计算为 $E = \\Delta x \\sum_{i=0}^{N-1} |U_{i,\\text{num}}(T) - u_{\\text{exact}}(x_i,T)|$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final results.\n    \"\"\"\n    \n    # --- Problem Parameters ---\n    N = 400\n    x_L, x_R = -1.0, 1.0\n    T_final = 0.3\n    nu = 0.9  # CFL number\n    \n    test_cases = [\n        (2.0, 0.0),  # Case 1: Shock\n        (0.0, 2.0),  # Case 2: Rarefaction\n        (-1.0, 1.0), # Case 3: Transonic Rarefaction\n    ]\n\n    all_results = []\n\n    for k, (u_L, u_R) in enumerate(test_cases):\n        \n        # --- Run simulation with HLL flux ---\n        u_hll = run_simulation(N, x_L, x_R, T_final, nu, u_L, u_R, 'hll')\n        \n        # --- Run simulation with Upwind flux ---\n        u_upwind = run_simulation(N, x_L, x_R, T_final, nu, u_L, u_R, 'upwind')\n        \n        # --- Compute L1 errors ---\n        dx = (x_R - x_L) / N\n        x_centers = x_L + (np.arange(N) + 0.5) * dx\n\n        # Error for HLL\n        u_exact_vals = exact_solution(x_centers, T_final, u_L, u_R)\n        e_hll = dx * np.sum(np.abs(u_hll - u_exact_vals))\n        \n        # Error for Upwind\n        e_upwind = dx * np.sum(np.abs(u_upwind - u_exact_vals))\n\n        # Indicator\n        indicator = 1 if e_hll  e_upwind else 0\n\n        # Append results for this test case\n        all_results.extend([round(e_hll, 6), round(e_upwind, 6), indicator])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef run_simulation(N, x_L, x_R, T_final, nu, u_L, u_R, flux_type):\n    \"\"\"\n    Runs a single 1D FVM simulation for the Burgers equation.\n    \n    Args:\n        N (int): Number of cells.\n        x_L (float): Left boundary of the domain.\n        x_R (float): Right boundary of the domain.\n        T_final (float): Final simulation time.\n        nu (float): CFL number.\n        u_L (float): Initial left state.\n        u_R (float): Initial right state.\n        flux_type (str): 'hll' or 'upwind'.\n        \n    Returns:\n        numpy.ndarray: The solution array u_n at the final time in the physical domain.\n    \"\"\"\n    dx = (x_R - x_L) / N\n    x_centers = x_L + (np.arange(N) + 0.5) * dx\n\n    # Initialize solution array with 1 ghost cell on each side\n    u_n = np.zeros(N + 2)\n    u_n[1:-1] = np.where(x_centers  0, u_L, u_R)\n\n    t = 0.0\n    \n    flux_func = get_flux_function(flux_type)\n\n    while t  T_final:\n        # Apply transmissive (zero-gradient) boundary conditions\n        u_n[0] = u_n[1]\n        u_n[-1] = u_n[-2]\n\n        # Calculate time step based on CFL condition\n        max_abs_u = np.max(np.abs(u_n))\n        if max_abs_u  1e-9:\n            max_abs_u = 1e-9 # Avoid division by zero\n            \n        dt = nu * dx / max_abs_u\n        if t + dt > T_final:\n            dt = T_final - t\n\n        # Calculate fluxes at interfaces\n        # F[j] is the flux at the interface between cell j and j+1 (in the padded array)\n        fluxes = np.zeros(N + 1)\n        for j in range(N + 1):\n            fluxes[j] = flux_func(u_n[j], u_n[j+1])\n        \n        # Update solution using first-order finite volume scheme\n        u_np1 = np.copy(u_n)\n        for i in range(1, N + 1): # Iterate over physical cells\n            u_np1[i] = u_n[i] - (dt / dx) * (fluxes[i] - fluxes[i-1])\n\n        u_n = u_np1\n        t += dt\n\n    return u_n[1:-1] # Return only the physical domain\n\ndef get_flux_function(flux_type):\n    \"\"\"Returns the chosen numerical flux function.\"\"\"\n    if flux_type == 'hll':\n        return hll_flux\n    elif flux_type == 'upwind':\n        return upwind_flux\n    else:\n        raise ValueError(\"Invalid flux type specified.\")\n\ndef flux(u):\n    \"\"\"Physical flux for Burgers' equation.\"\"\"\n    return 0.5 * u**2\n\ndef upwind_flux(u_l, u_r):\n    \"\"\"Computes the basic upwind flux.\"\"\"\n    a = 0.5 * (u_l + u_r) # Roe average speed\n    if a >= 0:\n        return flux(u_l)\n    else:\n        return flux(u_r)\n\ndef hll_flux(u_l, u_r):\n    \"\"\"Computes the HLL flux.\"\"\"\n    if np.isclose(u_l, u_r):\n        return flux(u_l)\n        \n    f_l = flux(u_l)\n    f_r = flux(u_r)\n    \n    # Estimate signal speeds\n    s_l = min(u_l, u_r)\n    s_r = max(u_l, u_r)\n    \n    if s_l >= 0:\n        return f_l\n    elif s_r = 0:\n        return f_r\n    else: # s_l  0  s_r\n        return (s_r * f_l - s_l * f_r + s_l * s_r * (u_r - u_l)) / (s_r - s_l)\n\ndef exact_solution(x, t, u_l, u_r):\n    \"\"\"Computes the exact Riemann solution for the Burgers equation.\"\"\"\n    if np.isclose(t, 0):\n        return np.where(x  0, u_l, u_r)\n    \n    if u_l > u_r:  # Shock\n        s = 0.5 * (u_l + u_r)\n        return np.where(x / t  s, u_l, u_r)\n    else:  # Rarefaction\n        xi = x / t\n        solution = np.piecewise(xi, [xi = u_l, (xi > u_l)  (xi  u_r), xi >= u_r],\n                                [u_l, lambda val: val, u_r])\n        return solution\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2394328"}]}