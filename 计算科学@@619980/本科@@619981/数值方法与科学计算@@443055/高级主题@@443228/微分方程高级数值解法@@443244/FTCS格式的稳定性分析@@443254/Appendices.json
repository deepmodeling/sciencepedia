{"hands_on_practices": [{"introduction": "理解数值稳定性的第一步是进行冯·诺依曼稳定性分析。本练习将引导你完成FTCS格式的核心计算，推导其放大因子。通过使用一个略高于稳定性阈值的 $r$ 值，我们可以精确定位出数值解中是哪个分量——即高频模态——首先导致模拟失败。这项实践旨在建立诊断数值不稳定性所需的基础分析技能。[@problem_id:3278053]", "problem": "考虑一维热方程 $u_{t}=\\kappa\\,u_{xx}$，该方程定义在长度为 $L$ 的周期性域上，并在具有 $N=8$ 个点和间距 $\\Delta x=L/N$ 的均匀网格上进行离散化。前向时间中心空间 (FTCS) 格式通过以下方式推进解：\n$$\nu_{i}^{n+1}=u_{i}^{n}+r\\left(u_{i+1}^{n}-2u_{i}^{n}+u_{i-1}^{n}\\right),\n$$\n其中 $r=\\kappa\\,\\Delta t/\\Delta x^{2}$。给定离散傅里叶模的单步增长因子定义为一个时间步后模的振幅与该步前其振幅之比。\n\n设 $r=0.51$，并考虑由 $m=0,1,2,3,4$ 索引的离散傅里叶模，其相位为 $\\theta_{m}=2\\pi m/N$。从控制方程和 FTCS 更新出发，推导一般离散傅里叶模的单步增长因子，并计算 $m=0,1,2,3,4$ 的增长因子。找出第一个发散的模态，即在这些模态中，其单步增长因子绝对值大于1且绝对值最大的那个模态。以模态指数 $m$ 的形式报告你的最终答案。无需四舍五入。", "solution": "首先验证问题，以确保其是适定的、有科学依据的，并包含唯一解所需的所有信息。\n\n**问题验证**\n\n*   **提取的已知条件：**\n    *   控制方程: $u_{t}=\\kappa\\,u_{xx}$\n    *   域: 长度为 $L$ 的一维周期性域\n    *   离散化: 均匀网格, $N=8$ 个点, 间距 $\\Delta x=L/N$\n    *   数值格式: FTCS, $u_{i}^{n+1}=u_{i}^{n}+r\\left(u_{i+1}^{n}-2u_{i}^{n}+u_{i-1}^{n}\\right)$\n    *   无量纲参数定义: $r=\\kappa\\,\\Delta t/\\Delta x^{2}$\n    *   特定参数值: $r=0.51$\n    *   用于分析的模态: 由 $m=0,1,2,3,4$ 索引的离散傅里叶模\n    *   模态相位定义: $\\theta_{m}=2\\pi m/N$\n    *   目标: 推导单步增长因子，为指定的模态计算该因子，并找出第一个发散的模态（定义为增长因子绝对值大于1且最大的模态）。\n\n*   **验证结论：**\n    该问题是**有效的**。这是有限差分格式的 von Neumann 稳定性分析中的一个标准练习，是数值分析中的一个核心课题。所有参数和定义都清晰、一致，并足以推导出唯一答案。所选的 $r=0.51$ 值略高于 FTCS 格式的理论稳定性阈值 $r=0.5$，这是研究数值不稳定性时一个合理且常见的情景。\n\n**求解推导**\n\n为了确定单步增长因子，我们进行 von Neumann 稳定性分析。我们将单个离散傅里叶模视为有限差分方程的解。对应于指数 $m$ 的一般模态可以写成：\n$$\nu_i^n = A_m^n \\exp(I i \\theta_m)\n$$\n其中 $A_m^n$ 是模态 $m$ 在时间步 $n$ 的振幅，$i$ 是空间网格指数，$I$ 是虚数单位 ($I^2 = -1$)，$\\theta_m$ 是模态 $m$ 的相位。我们记作 $G_m$ 的单步增长因子是连续时间步长中振幅的比率，即 $G_m = A_m^{n+1} / A_m^n$。因此，我们可以将 $u_i^{n+1}$ 写成：\n$$\nu_i^{n+1} = A_m^{n+1} \\exp(I i \\theta_m) = G_m A_m^n \\exp(I i \\theta_m)\n$$\n我们将 $u_i^n$ 和 $u_i^{n+1}$ 的这些形式代入 FTCS 格式：\n$$\nu_{i}^{n+1}=u_{i}^{n}+r\\left(u_{i+1}^{n}-2u_{i}^{n}+u_{i-1}^{n}\\right)\n$$\n$$\nG_m A_m^n \\exp(I i \\theta_m) = A_m^n \\exp(I i \\theta_m) + r \\left[ A_m^n \\exp(I (i+1) \\theta_m) - 2 A_m^n \\exp(I i \\theta_m) + A_m^n \\exp(I (i-1) \\theta_m) \\right]\n$$\n将整个方程除以公共的非零因子 $A_m^n \\exp(I i \\theta_m)$，得到增长因子 $G_m$ 的表达式：\n$$\nG_m = 1 + r \\left[ \\exp(I \\theta_m) - 2 + \\exp(-I \\theta_m) \\right]\n$$\n使用欧拉公式 $\\exp(I\\theta) + \\exp(-I\\theta) = 2\\cos(\\theta)$，我们简化括号中的表达式：\n$$\nG_m = 1 + r \\left[ 2\\cos(\\theta_m) - 2 \\right] = 1 - 2r \\left[ 1 - \\cos(\\theta_m) \\right]\n$$\n我们应用半角三角恒等式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$：\n$$\nG_m = 1 - 4r \\sin^2\\left(\\frac{\\theta_m}{2}\\right)\n$$\n这就是相位为 $\\theta_m$ 的离散傅里叶模的单步增长因子的一般表达式。\n\n问题给出了具体参数 $r=0.51$, $N=8$，并要求分析模态 $m \\in \\{0,1,2,3,4\\}$。相角为 $\\theta_m = 2\\pi m/N = 2\\pi m/8 = \\pi m/4$。\n将这些值代入 $G_m$ 的表达式中：\n$$\nG_m = 1 - 4(0.51) \\sin^2\\left(\\frac{\\pi m/4}{2}\\right) = 1 - 2.04 \\sin^2\\left(\\frac{\\pi m}{8}\\right)\n$$\n一个模态是稳定的当且仅当其增长因子的绝对值小于或等于一，即 $|G_m| \\le 1$。我们现在为每个指定的模态计算 $G_m$ 及其绝对值。\n\n*   **模态 $m=0$:**\n    $\\theta_0 = 0$。\n    $G_0 = 1 - 2.04 \\sin^2(0) = 1 - 0 = 1$。\n    $|G_0| = 1$。该模态是中性稳定的。\n\n*   **模态 $m=1$:**\n    $\\theta_1 = \\pi/4$。\n    $G_1 = 1 - 2.04 \\sin^2(\\pi/8)$。使用 $\\sin^2(x) = (1-\\cos(2x))/2$，我们得到 $\\sin^2(\\pi/8) = (1-\\cos(\\pi/4))/2 = (1-\\sqrt{2}/2)/2 = (2-\\sqrt{2})/4$。\n    $G_1 = 1 - 2.04 \\left(\\frac{2-\\sqrt{2}}{4}\\right) = 1 - 0.51(2 - \\sqrt{2}) = 1 - 1.02 + 0.51\\sqrt{2} = -0.02 + 0.51\\sqrt{2}$。\n    因为 $\\sqrt{2} \\approx 1.414$，所以 $G_1 \\approx -0.02 + 0.51(1.414) \\approx 0.701$。显然，$|G_1|1$。该模态是稳定的。\n\n*   **模态 $m=2$:**\n    $\\theta_2 = 2\\pi/4 = \\pi/2$。\n    $G_2 = 1 - 2.04 \\sin^2(\\pi/4) = 1 - 2.04 (\\frac{\\sqrt{2}}{2})^2 = 1 - 2.04(\\frac{1}{2}) = 1 - 1.02 = -0.02$。\n    $|G_2| = 0.021$。该模态是稳定的。\n\n*   **模态 $m=3$:**\n    $\\theta_3 = 3\\pi/4$。\n    $G_3 = 1 - 2.04 \\sin^2(3\\pi/8)$。使用 $\\sin^2(x) = (1-\\cos(2x))/2$，我们得到 $\\sin^2(3\\pi/8) = (1-\\cos(3\\pi/4))/2 = (1-(-\\sqrt{2}/2))/2 = (2+\\sqrt{2})/4$。\n    $G_3 = 1 - 2.04 \\left(\\frac{2+\\sqrt{2}}{4}\\right) = 1 - 0.51(2 + \\sqrt{2}) = 1 - 1.02 - 0.51\\sqrt{2} = -0.02 - 0.51\\sqrt{2}$。\n    $|G_3| = |-0.02 - 0.51\\sqrt{2}| = 0.02 + 0.51\\sqrt{2}$。因为 $0.51\\sqrt{2} \\approx 0.72$，所以 $|G_3| \\approx 0.741$。该模态是稳定的。\n\n*   **模态 $m=4$:**\n    $\\theta_4 = 4\\pi/4 = \\pi$。\n    $G_4 = 1 - 2.04 \\sin^2(\\pi/2) = 1 - 2.04 (1)^2 = 1 - 2.04 = -1.04$。\n    $|G_4| = |-1.04| = 1.04 > 1$。该模态是不稳定的。\n\n问题要求在 $m=0,1,2,3,4$ 中找出第一个发散的模态，定义为 $|G_m| > 1$ 且其绝对值最大的模态。回顾我们的计算：\n*   $|G_0| = 1$\n*   $|G_1|  1$\n*   $|G_2|  1$\n*   $|G_3|  1$\n*   $|G_4| = 1.04$\n\n在所考虑的模态中，$m=4$ 是唯一一个增长因子绝对值大于1的模态。因此，根据问题的定义，它是第一个发散的模态。这个结果与 FTCS 格式的一般稳定性分析相符，该分析表明不稳定性首先出现在最高频率（或最短波长）的模态上，对于有 $N$ 个点的网格，这是奈奎斯特 (Nyquist) 模态，即 $m=N/2$。此处，$N=8$，所以最不稳定的模态是 $m=4$。", "answer": "$$\\boxed{4}$$", "id": "3278053"}, {"introduction": "在推导出理论上的稳定性条件后，下一步自然是在完整的模拟中观察其效果。本练习要求你编写FTCS格式的代码，并追踪一个包含所有可能波长的初始扰动的演化。通过在稳定、临界稳定和不稳定三种机制下运行模拟，你将对数值误差如何衰减、持续或爆炸性增长有一个具体而直观的理解。这项实践将抽象的数学分析与计算实验的实际结果联系起来。[@problem_id:3278097]", "problem": "考虑一个定义在均匀周期性网格上、具有恒定扩散系数的一维热传导方程。设 $u(x,t)$ 在周期性域上满足 $u_t=\\alpha u_{xx}$，空间网格为 $x_i=i\\Delta x$，其中整数 $i$ 模 $N$，$ \\Delta x>0$ 且 $N\\in\\mathbb{N}$。前向时间中心空间（FTCS）离散化根据带有周期性环绕索引的三点格式，将网格函数值 $u_i^n\\approx u(x_i,t_n)$ 从时间层 $t_n$ 更新到 $t_{n+1}=t_n+\\Delta t$。定义无量纲参数 $r=\\alpha\\,\\Delta t/\\Delta x^2$。初始条件为一个单点扰动（离散 delta 函数），即当 $i=0$ 时 $u_i^0=1$，否则 $u_i^0=0$。\n\n您的任务是编写一个完整的程序，该程序能够：\n- 使用周期性边界条件，将 FTCS 格式按给定的时间步数向前演化。\n- 量化解的零均值分量的增长或衰减。具体来说，将初始条件的均值定义为 $\\bar{u}^0=\\frac{1}{N}\\sum_{i=0}^{N-1}u_i^0$，并将零均值部分定义为 $v_i^n=u_i^n-\\bar{u}^0$。设 $\\|\\cdot\\|_2$ 表示网格上的离散 $\\ell^2$ 范数。对于给定的步数 $T\\in\\mathbb{N}$，计算\n$$\nG_{\\max}=\\max_{1\\le n\\le T}\\frac{\\|v^n\\|_2}{\\|v^0\\|_2}.\n$$\n- 报告下面测试套件中每个参数集的 $G_{\\max}$ 值。\n\n您可以假定的基本原理：\n- 周期性域上的热方程 $u_t=\\alpha u_{xx}$ 的平均值随时间守恒。\n- FTCS 更新使用带有周期性环绕索引的三点离散拉普拉斯算子。\n- 离散 $\\ell^2$ 范数为 $\\|w\\|_2=\\left(\\sum_{i=0}^{N-1} w_i^2\\right)^{1/2}$。\n\n不要使用任何直接提供现成放大因子的稳定性分析结果；相反，您的实现和推理应基于这些核心定义。\n\n对所有网格索引 $i$ 模 $N$ 实现如下的 FTCS 更新：\n- 设 $u_i^{n+1}=u_i^n + r\\left(u_{i-1}^n - 2u_i^n + u_{i+1}^n\\right)$，使用周期性环绕索引，使得 $u_{-1}^n=u_{N-1}^n$ 且 $u_{N}^n=u_{0}^n$。\n\n测试套件：\n- 情况 1（稳定）：$N=128$，$r=0.25$，$T=200$。\n- 情况 2（临界稳定）：$N=128$，$r=0.5$，$T=200$。\n- 情况 3（不稳定）：$N=128$，$r=0.6$，$T=50$。\n- 情况 4（临界，奇数网格）：$N=129$，$r=0.5$，$T=200$。\n\n数值细节要求：\n- 使用双精度浮点运算。\n- 如果内部出现角度，则不需要；不需要角度单位。\n- 不需要物理单位；将所有量视为无量纲。\n\n程序输入和输出：\n- 您的程序必须是完全自包含的，并且不接受任何外部输入。\n- 您的程序必须生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。第 $k$ 个条目必须是情况 $k$ 的 $G_{\\max}$ 值，四舍五入到恰好 6 位小数。例如，一个有效的输出格式是 $[x_1,x_2,x_3,x_4]$，其中每个 $x_k$ 是一个小数点后有 6 位数字的小数。\n\n覆盖性设计：\n- 情况 1 测试 $r  \\frac{1}{2}$ 的稳定区域。\n- 情况 2 测试 $r = \\frac{1}{2}$ 且网格点数为偶数的临界区域。\n- 情况 3 测试 $r > \\frac{1}{2}$ 的不稳定区域。\n- 情况 4 测试 $r = \\frac{1}{2}$ 且网格点数为奇数的临界区域，以探查最高波数的表示。\n\n您的最终程序应计算并以 $[G_{\\max}^{(1)},G_{\\max}^{(2)},G_{\\max}^{(3)},G_{\\max}^{(4)}]$ 的确切格式输出。", "solution": "该问题已经过验证，被认为是有效的。这是一个在数值分析领域内适定的、有科学依据的问题，提供了所有必要信息且无内部矛盾。\n\n任务是使用前向时间中心空间（FTCS）数值格式在周期性域上模拟一维热传导方程 $u_t = \\alpha u_{xx}$。我们需要计算一个特定的度量 $G_{\\max}$，它量化了解的零均值分量在给定时间步数 $T$ 内的最大瞬态增长。\n\n解决方案是通过对每个指定的测试用例执行直接模拟过程来找到的。\n\n**1. 状态初始化**\n\n模拟在具有 $N$ 个点的离散空间网格上进行，索引为 $i = 0, 1, \\dots, N-1$。在时间步 $n$ 时系统的状态由长度为 $N$ 的向量 $u^n$ 表示。\n\n在时间 $t_0$（即 $n=0$）时的初始条件是一个离散 delta 函数：\n$$ u_i^0 = \\begin{cases} 1  \\text{若 } i=0 \\\\ 0  \\text{若 } i \\neq 0 \\end{cases} $$\n问题要求分析解的零均值部分。初始条件的均值为：\n$$ \\bar{u}^0 = \\frac{1}{N} \\sum_{i=0}^{N-1} u_i^0 = \\frac{1}{N} $$\n用于周期性域上热方程的 FTCS 格式会使总和 $\\sum_i u_i^n$ 守恒，因此平均值也随时间守恒。所以，对于所有 $n \\ge 0$，有 $\\bar{u}^n = \\bar{u}^0$。\n\n初始零均值分量是 $v^0$，其元素为 $v_i^0 = u_i^0 - \\bar{u}^0$。我们必须计算其离散 $\\ell^2$ 范数 $\\|v^0\\|_2$，该范数用作衡量增长的参考。\n$$ \\|v^0\\|_2^2 = \\sum_{i=0}^{N-1} (v_i^0)^2 = (u_0^0 - \\bar{u}^0)^2 + \\sum_{i=1}^{N-1} (u_i^0 - \\bar{u}^0)^2 $$\n$$ \\|v^0\\|_2^2 = \\left(1 - \\frac{1}{N}\\right)^2 + (N-1)\\left(0 - \\frac{1}{N}\\right)^2 = \\left(1 - \\frac{2}{N} + \\frac{1}{N^2}\\right) + \\frac{N-1}{N^2} = 1 - \\frac{2}{N} + \\frac{1 + N - 1}{N^2} = 1 - \\frac{2}{N} + \\frac{1}{N} = 1 - \\frac{1}{N} $$\n因此，初始范数为 $\\|v^0\\|_2 = \\sqrt{1 - \\frac{1}{N}}$。\n\n**2. 时间演化**\n\n解向量 $u^n$ 通过对 $n=0, 1, \\dots, T-1$ 使用 FTCS 更新规则在时间上向前演化：\n$$ u_i^{n+1} = u_i^n + r \\left( u_{i-1}^n - 2u_i^n + u_{i+1}^n \\right) $$\n此处，$r = \\alpha \\Delta t / \\Delta x^2$ 是给定的无量纲参数。索引通过周期性环绕处理，即 $u_{-1}^n = u_{N-1}^n$ 且 $u_N^n = u_0^n$。此更新同时应用于所有网格点 $i=0, \\dots, N-1$，以获得下一个时间层 $u^{n+1}$ 的解。\n\n**3. 增长度量 $G_{\\max}$ 的计算**\n\n核心任务是计算 $G_{\\max} = \\max_{1 \\le n \\le T} \\frac{\\|v^n\\|_2}{\\|v^0\\|_2}$。这通过在时间演化循环中执行以下步骤来实现：\n- 对于从 $1$ 到 $T$ 的每个时间步 $n$：\n    - 从 $u^{n-1}$ 计算出新状态 $u^n$。\n    - 计算零均值分量 $v^n$：$v_i^n = u_i^n - \\bar{u}^0$。\n    - 计算 $\\ell^2$ 范数 $\\|v^n\\|_2 = \\left(\\sum_{i=0}^{N-1} (v_i^n)^2\\right)^{1/2}$。\n    - 计算此步的增长因子 $G_n = \\|v^n\\|_2 / \\|v^0\\|_2$。\n- 将 $G_{\\max}$ 的值维持为所有已计算出的 $G_n$ 值的动态最大值。\n\n**4. 实现策略**\n\n设计一个程序来为每个提供的测试用例执行此模拟。\n- 状态向量 $u$ 表示为一个双精度浮点数的一维数组。\n- 具有周期性边界的 FTCS 更新可以使用向量化操作高效实现。项 $(u_{i-1}^n - 2u_i^n + u_{i+1}^n)$ 可以使用数组滚动或移位操作一次性为整个网格计算。\n- 一个主循环迭代 $T$ 次。在每次迭代中，更新状态向量 $u$，并计算零均值分量的范数以更新 $G_{\\max}$。\n- 对测试套件中的每个参数集 $(N, r, T)$ 重复该过程。存储每个情况最终计算出的 $G_{\\max}$。\n\n这些测试用例旨在探查 FTCS 格式众所知的稳定性极限 $r \\le 0.5$。\n- 情况 1 ($r=0.25$)：稳定。所有非恒定模态都会衰减。\n- 情况 2 ($r=0.5$，$N=128$ 为偶数)：临界稳定。在偶数网格上可表示的最高频率模态的放大因子为 $-1$，因此会持续存在而不衰减，从而引起振荡。\n- 情况 3 ($r=0.6$)：不稳定。最高频率模态呈指数级增长。\n- 情况 4 ($r=0.5$，$N=129$ 为奇数)：临界稳定，但在奇数网格上。最高频率模态 $u_j \\propto (-1)^j$ 不是周期性的，因此不是该离散算子的本征模。所有可表示的模态（对于非恒定模态）的放大因子幅值都严格小于 $1$，导致衰减。\n\n最终输出将是一个包含每个情况计算出的 $G_{\\max}$ 值的列表，并按指定格式进行格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    This function simulates the FTCS scheme for the 1D heat equation and\n    calculates the maximum growth of the zero-mean component of the solution.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (stable)\n        {'N': 128, 'r': 0.25, 'T': 200},\n        # Case 2 (critically stable, even grid)\n        {'N': 128, 'r': 0.5, 'T': 200},\n        # Case 3 (unstable)\n        {'N': 128, 'r': 0.6, 'T': 50},\n        # Case 4 (critically stable, odd grid)\n        {'N': 129, 'r': 0.5, 'T': 200},\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case['N']\n        r = case['r']\n        T = case['T']\n\n        # 1. Set up the initial condition u^0 (discrete delta function).\n        # Use np.float64 for double-precision arithmetic.\n        u = np.zeros(N, dtype=np.float64)\n        u[0] = 1.0\n\n        # 2. Calculate the mean of the initial condition (conserved in time).\n        u_mean_0 = np.mean(u)\n\n        # 3. Calculate the zero-mean part of the initial condition, v^0,\n        #    and its L2 norm.\n        v_0 = u - u_mean_0\n        norm_v0 = np.linalg.norm(v_0)\n\n        # The norm of v^0 can't be zero for N > 1, but this is good practice.\n        if norm_v0  1e-15:\n            results.append(0.0)\n            continue\n            \n        g_max = 0.0\n\n        # 4. Evolve the solution for T time steps.\n        for n in range(T):\n            # Apply the FTCS update rule with periodic boundary conditions.\n            # np.roll(u, 1) gets u_{i-1} and np.roll(u, -1) gets u_{i+1}.\n            u_laplacian = np.roll(u, 1) - 2 * u + np.roll(u, -1)\n            u = u + r * u_laplacian\n\n            # 5. Calculate the growth factor at the current step n+1.\n            # The loop runs for n=0,...,T-1, so u is now u^{n+1}.\n            v_n = u - u_mean_0\n            norm_vn = np.linalg.norm(v_n)\n            g_n = norm_vn / norm_v0\n            \n            # Update the maximum growth factor found so far.\n            if g_n > g_max:\n                g_max = g_n\n        \n        results.append(g_max)\n\n    # Final print statement in the exact required format.\n    # The result for each case is rounded to 6 decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3278097"}, {"introduction": "一个稳定的格式只是最低要求，但它并不能保证准确性。这项高级实践超越了稳定性的二元概念，旨在探索稳定区域内数值误差的细微差别。通过比较同样稳定 ($r \\lt 0.5$) 但使用不同 $r$ 值的模拟结果，你将量化时间步长的选择如何影响准确性，并引入“数值扩散”这一重要概念。本练习揭示了计算科学家在计算效率和结果的物理保真度之间所面临的实际权衡。[@problem_id:3278125]", "problem": "考虑一维热扩散方程 $u_t = \\nu u_{xx}$，定义在长度为 $L$ 的周期性空间域上。其中，$u(x,t)$ 是温度场，$t$ 是时间（单位：秒），$x$ 是位置（单位：米），$\\nu$ 是热扩散系数（单位：$\\mathrm{m^2/s}$）。使用前向时间中心空间 (FTCS) 格式，在具有 $N_x$ 个点、间距为 $\\Delta x = L/N_x$ 的均匀网格上，以时间步长 $\\Delta t$ 来近似求解。定义无量纲参数 $r = \\nu \\Delta t / \\Delta x^2$。FTCS 更新在周期性边界条件下进行，并使用下面指定的固定 $r$ 值。初始条件为单个傅里叶模式 $u(x,0) = \\sin(k x)$，其中波数 $k = 2\\pi m / L$， $m$ 为给定的整数模式指数。对于此初始条件，热方程的精确解析解为 $u_{\\mathrm{exact}}(x,t) = \\sin(k x)\\,\\exp(-\\nu k^2 t)$。\n\n你的任务是建立一个关于误差与稳定性的参数化研究，方法是在固定的物理时间 $T$ 后，比较 $r=0.49$ 和 $r=0.1$ 时的 FTCS 数值解，并量化额外数值扩散。对于下述测试套件中的每种情况，实施 FTCS 格式，直到精确达到物理时间 $T$。使用周期性边界条件。对于每种情况，计算两个量：\n\n1. 在时间 $T$ 时相对于解析解的 $L^2$ 误差，定义为 $E = \\left(\\int_0^L (u_{\\mathrm{num}}(x,T) - u_{\\mathrm{exact}}(x,T))^2\\,dx\\right)^{1/2}$，表示为一个无单位的浮点数（由于 $u$ 是无量纲的，因此误差也是无量纲的）。\n\n2. 额外数值扩散 $\\Delta \\nu_{\\mathrm{num}}$（单位：$\\mathrm{m^2/s}$），其定义为：通过数值计算出的基模振幅衰减来估计有效扩散系数 $\\nu_{\\mathrm{eff}}$，然后报告 $\\Delta \\nu_{\\mathrm{num}} = \\nu_{\\mathrm{eff}} - \\nu$。使用网格上内积的离散近似，将 $u(x,t)$ 投影到 $\\sin(kx)$ 上，以估计振幅 $A(t)$。使用 $A(0)$ 和 $A(T)$，通过公式 $\\nu_{\\mathrm{eff}} = -\\frac{1}{k^2 T}\\ln\\left(\\left|\\frac{A(T)}{A(0)}\\right|\\right)$ 来计算 $\\nu_{\\mathrm{eff}}$。将 $\\Delta \\nu_{\\mathrm{num}}$ 以 $\\mathrm{m^2/s}$ 为单位报告为一个浮点数。请注意，对数内的绝对值确保了在离散放大导致符号变化但仍保持稳定的情况下，衰减率具有物理意义。\n\n使用的科学和数值参数为 $L = 1.0$ 米，$\\nu = 0.01$ $\\mathrm{m^2/s}$，$T = 0.49$ 秒。角度（例如，在三角函数中）必须以弧度处理。\n\n为每种情况实施 FTCS 格式的时间更新，并计算所要求的量。FTCS 更新必须使用每种情况指定的无量纲参数 $r$、周期性边界条件和均匀网格。对于每种情况，根据定义 $r = \\nu \\Delta t / \\Delta x^2$ 选择时间步长 $\\Delta t$，并确保时间步数使总模拟时间恰好等于 $T$ 秒。\n\n测试套件：\n- 情况 1（理想情况）：$N_x = 100$，$m = 1$，$r = 0.1$。\n- 情况 2（接近稳定性边界）：$N_x = 100$，$m = 1$，$r = 0.49$。\n- 情况 3（高波数接近离散稳定性边缘）：$N_x = 100$，$m = 45$，$r = 0.49$。\n\n对于每种情况，按规定计算数据对 $\\left[E, \\Delta \\nu_{\\mathrm{num}}\\right]$。你的程序应生成单行输出，其中包含三种情况的结果，格式为用方括号括起来的逗号分隔列表，其中每个元素本身是一个包含两个元素的列表。例如，输出格式应类似于 \"[[E1,DN1],[E2,DN2],[E3,DN3]]\"，其中 $E1$ 是情况 1 的 $L^2$ 误差，$DN1$ 是情况 1 的额外数值扩散（单位：$\\mathrm{m^2/s}$），依此类推。所有数字都必须打印为标准的 Python 浮点数。输出行中不应打印任何单位。", "solution": "该问题已经过验证，被确定为数值分析领域中一个适定且科学合理​​的练习。\n\n该问题要求在周期性空间域 $x \\in [0, L]$ 上数值求解一维热扩散方程：\n$$\n\\frac{\\partial u}{\\partial t} = \\nu \\frac{\\partial^2 u}{\\partial x^2}\n$$\n此处，$u(x,t)$ 表示温度，$\\nu$ 是热扩散系数，$x$ 是空间坐标，$t$ 是时间。初始条件为单个傅里叶模式 $u(x,0) = \\sin(k x)$，其中波数 $k = 2\\pi m / L$，$m$ 为给定的整数模式指数。\n\n使用的数值方法是前向时间中心空间 (FTCS) 格式。我们用 $N_x$ 个网格点对区域进行离散化，使得网格间距为 $\\Delta x = L/N_x$，空间坐标为 $x_j = j \\Delta x$，$j = 0, 1, \\dots, N_x-1$。时间以步长 $\\Delta t$ 进行离散化，因此 $t_n = n \\Delta t$。在网格点 $j$ 和时间步 $n$ 的数值解表示为 $u_j^n \\approx u(x_j, t_n)$。\n\nFTCS 格式用前向差分来离散化时间导数，用中心差分来离散化空间导数：\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} = \\nu \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{\\Delta x^2}\n$$\n重新整理该方程，得到下一个时间步 $u_j^{n+1}$ 处数值解的显式更新规则：\n$$\nu_j^{n+1} = u_j^n + r (u_{j+1}^n - 2u_j^n + u_{j-1}^n)\n$$\n其中 $r = \\frac{\\nu \\Delta t}{\\Delta x^2}$ 是无量纲稳定性参数。FTCS 格式的稳定性由 von Neumann 稳定性条件决定，该条件规定，为获得稳定解，参数 $r$ 必须满足 $r \\le 1/2$。所考虑的 $r=0.1$ 和 $r=0.49$ 的情况均满足此条件。\n\n每种测试情况的步骤如下：\n\n1.  **设置模拟参数**：根据提供的案例数据（$N_x, m, r$）和全局常量（$L=1.0$, $\\nu=0.01$, $T=0.49$），我们计算必要的参数：\n    *   空间网格间距：$\\Delta x = L / N_x$。\n    *   波数：$k = 2\\pi m / L$。\n    *   时间步长：$\\Delta t = r \\Delta x^2 / \\nu$。\n    *   总时间步数：$N_t = T / \\Delta t$。问题参数的选择使得 $N_t$ 为一个整数，从而确保模拟在时间 $T$ 精确结束。\n\n2.  **初始化解**：根据初始条件 $u(x,0) = \\sin(kx)$，初始化一个表示解 $u$ 的一维数组。空间网格定义为 $x_j = j \\Delta x$，$j \\in \\{0, \\dots, N_x-1\\}$。因此，初始数值解为 $u_j^0 = \\sin(k x_j)$。\n\n3.  **执行时间积分**：循环从 $n=0$ 迭代到 $N_t-1$。在每次迭代中，将 FTCS 更新规则应用于所有网格点 $j$，从 $u^n$ 计算 $u^{n+1}$。实施周期性边界条件，意味着在 $j=0$ 处的计算中，“左”邻居 $u_{-1}^n$ 取为 $u_{N_x-1}^n$，而在 $j=N_x-1$ 处的计算中，“右”邻居 $u_{N_x}^n$ 取为 $u_0^n$。\n\n4.  **计算最终量**：经过 $N_t$ 个时间步后，获得最终数值解 $u_{\\mathrm{num}}(x,T)$。然后我们计算两个所需的指标：\n\n    a. **$L^2$ 误差 ($E$)**：对于给定的初始条件，精确解析解为 $u_{\\mathrm{exact}}(x,t) = \\sin(k x) e^{-\\nu k^2 t}$。我们在数值网格上计算其在 $t=T$ 时的值。$L^2$ 误差定义为 $E = \\left(\\int_0^L (u_{\\mathrm{num}}(x,T) - u_{\\mathrm{exact}}(x,T))^2\\,dx\\right)^{1/2}$。该积分使用网格上的黎曼和进行数值近似：\n    $$\n    E \\approx \\left( \\sum_{j=0}^{N_x-1} (u_j^{N_t} - u_{\\mathrm{exact}}(x_j,T))^2 \\Delta x \\right)^{1/2}\n    $$\n\n    b. **额外数值扩散 ($\\Delta \\nu_{\\mathrm{num}}$)**：FTCS 格式会引入数值误差，通常表现为额外的扩散。为了量化这一点，我们根据解的振幅衰减计算有效扩散系数 $\\nu_{\\mathrm{eff}}$。数值解 $u(x,t)$ 中模式 $\\sin(kx)$ 的振幅 $A(t)$ 通过投影求得：\n    $$\n    A(t) = \\frac{\\langle u(x,t), \\sin(kx) \\rangle}{\\langle \\sin(kx), \\sin(kx) \\rangle} = \\frac{\\int_0^L u(x,t) \\sin(kx) dx}{\\int_0^L \\sin^2(kx) dx} = \\frac{2}{L} \\int_0^L u(x,t) \\sin(kx) dx\n    $$\n    我们通过数值近似该积分来计算初始振幅 $A(0)$ 和最终振幅 $A(T)$。由于所选网格上离散傅里叶基的特性，$A(0)$ 将精确为 $1$。最终振幅由下式给出：\n    $$\n    A(T) \\approx \\frac{2}{L} \\sum_{j=0}^{N_x-1} u_j^{N_t} \\sin(k x_j) \\Delta x = \\frac{2}{N_x} \\sum_{j=0}^{N_x-1} u_j^{N_t} \\sin(k x_j)\n    $$\n    然后，假设为指数定律，根据振幅衰减计算有效扩散系数 $\\nu_{\\mathrm{eff}}$：\n    $$\n    \\nu_{\\mathrm{eff}} = -\\frac{1}{k^2 T}\\ln\\left(\\left|\\frac{A(T)}{A(0)}\\right|\\right)\n    $$\n    使用绝对值使得计算对于数值格式中可能出现的符号翻转振荡具有鲁棒性。额外数值扩散是有效扩散系数与真实扩散系数之差：\n    $$\n    \\Delta \\nu_{\\mathrm{num}} = \\nu_{\\mathrm{eff}} - \\nu\n    $$\n\n对三种测试情况中的每一种都执行此过程，并将得到的结果对 $[E, \\Delta \\nu_{\\mathrm{num}}]$ 收集并格式化以供最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_case(Nx, m, r):\n    \"\"\"\n    Solves the 1D heat equation with FTCS for a given parameter set.\n\n    Args:\n        Nx (int): Number of spatial grid points.\n        m (int): Wavenumber index for the initial condition.\n        r (float): Nondimensional stability parameter.\n\n    Returns:\n        list: A list containing the L2 error [E] and the excess numerical \n              diffusion [delta_nu_num].\n    \"\"\"\n    # Scientific and numerical parameters\n    L = 1.0  # meters\n    nu = 0.01  # m^2/s\n    T = 0.49  # seconds\n\n    # 1. Grid and Parameters Setup\n    dx = L / Nx\n    k = 2 * np.pi * m / L\n    \n    # Calculate time step and number of steps to reach T exactly\n    dt = r * dx**2 / nu\n    # Use np.round to handle potential floating point inaccuracies ensuring an integer\n    Nt = int(np.round(T / dt)) \n    \n    # Check if simulation time is exactly T\n    if not np.isclose(Nt * dt, T):\n        raise ValueError(\"Simulation time T is not an integer multiple of dt.\")\n\n    # Spatial grid\n    x = np.linspace(0, L, Nx, endpoint=False)\n\n    # 2. Initial Condition\n    u = np.sin(k * x)\n    u_initial = u.copy()\n\n    # 3. Time Evolution (FTCS)\n    for _ in range(Nt):\n        # Use np.roll for efficient periodic boundary conditions\n        u_jp1 = np.roll(u, -1)\n        u_jm1 = np.roll(u, 1)\n        u = u + r * (u_jp1 - 2 * u + u_jm1)\n    \n    u_final = u\n\n    # 4. Post-processing\n    # Analytical solution at time T\n    u_exact_T = np.sin(k * x) * np.exp(-nu * k**2 * T)\n\n    # 5. Compute L2 Error (E)\n    # The integral is approximated by a sum over the discrete grid points.\n    error_integrand = (u_final - u_exact_T)**2\n    L2_error = np.sqrt(np.sum(error_integrand) * dx)\n\n    # 6. Compute Excess Numerical Diffusion (delta_nu_num)\n    # The amplitude is computed by projecting the solution onto sin(kx).\n    # The discrete projection integral: (2/L) * sum(f(x)*sin(kx)*dx)\n    # A_0 = (2/L) * np.sum(u_initial * np.sin(k*x)) * dx which simplifies to\n    # A_0 = (2/Nx) * np.sum(u_initial * np.sin(k*x))\n    # For a perfect sine wave on the grid, this sum is exactly Nx/2, so A_0 is 1.0.\n    # We compute it numerically for robustness.\n    \n    # Inner product helper function\n    def inner_product(f, g, dx_val):\n        return np.sum(f * g) * dx_val\n\n    # Basis function for projection\n    sin_kx = np.sin(k*x)\n\n    # Normalization factor is integral of sin^2(kx) over [0,L], approximately L/2\n    norm_factor = inner_product(sin_kx, sin_kx, dx)\n\n    # Initial amplitude\n    A0 = inner_product(u_initial, sin_kx, dx) / norm_factor\n\n    # Final amplitude\n    AT = inner_product(u_final, sin_kx, dx) / norm_factor\n    \n    # Handle the case k=0 (m=0), where k^2 T is zero.\n    if k == 0:\n        nu_eff = 0.0 # No diffusion for a constant initial condition\n    else:\n        # The formula given in the problem\n        nu_eff = (-1 / (k**2 * T)) * np.log(np.abs(AT / A0))\n\n    delta_nu_num = nu_eff - nu\n    \n    return [L2_error, delta_nu_num]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (100, 1, 0.1),   # Case 1: happy path\n        (100, 1, 0.49),  # Case 2: near stability boundary\n        (100, 45, 0.49), # Case 3: high wavenumber near stability edge\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, m, r = case\n        result = run_case(Nx, m, r)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The str() function on a list correctly formats it as '[item1, item2]'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3278125"}]}