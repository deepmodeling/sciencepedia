{"hands_on_practices": [{"introduction": "在我们开始计算之前，让我们先来检验一下直觉。刚度矩阵的组装过程依赖于一个如同地址簿般的“局部-全局”索引映射。这个练习 [@problem_id:3206774] 探讨了当这个地址簿出现一个简单的拼写错误时会发生什么，从而揭示了网格连接性与最终矩阵结构之间的深刻联系。理解这一点对于调试真实世界的有限元代码至关重要。", "problem": "考虑在有界域上，对线性椭圆模型问题 $-\\nabla \\cdot (\\kappa \\nabla u) = f$ 使用协调单元的有限元法（FEM）来组装全局刚度矩阵 $K$。全局矩阵 $K$ 是通过根据一个局部到全局的映射来累加单元刚度矩阵 $k^{e}$ 的贡献而形成的，该映射将每个单元的局部自由度与全局索引关联起来。假设每个 $k^{e}$ 都是对称半正定的，并且尚未对 $K$ 施加任何边界条件。\n\n假设由于一个编程错误，局部到全局的映射程序在网格中任何出现全局索引 $p$ 和 $q$ 的地方都将它们系统地交换。也就是说，每当正确的映射应返回全局索引 $p$ 时，有错误的版本会返回 $q$；而每当它应返回 $q$ 时，它会返回 $p$。所有其他索引都正确返回。与正确组装的矩阵 $K_{\\mathrm{true}}$ 相比，这个错误将如何体现在组装后的矩阵 $K$ 中？\n\n选择最佳描述。\n\nA. $K$ 变得非对称，因为只有行 $p$ 和 $q$ 被置换，而相应的列保持不变。\n\nB. $K$ 等于 $P K_{\\mathrm{true}} P^{\\top}$，其中 $P$ 是交换索引 $p$ 和 $q$ 的置换矩阵；因此 $K$ 保持对称，其特征值与 $K_{\\mathrm{true}}$ 的特征值匹配，稀疏模式除了行和列 $p$ 与 $q$ 被交换外是相同的。\n\nC. 只有对角线元素 $K_{pp}$ 和 $K_{qq}$ 被交换；所有非对角线元素与 $K_{\\mathrm{true}}$ 中的保持相同。\n\nD. $K$ 的行 $p$ 和列 $p$ 中的所有元素都变为零，而行 $q$ 和列 $q$ 中的元素相对于 $K_{\\mathrm{true}}$ 增加了一倍。", "solution": "用户希望我分析一个特定的编程错误对有限元法（FEM）中全局刚度矩阵组装过程的影响。\n\n### 第一步：提取已知信息\n- **问题类型**：有界域上的线性椭圆模型问题 $-\\nabla \\cdot (\\kappa \\nabla u) = f$。\n- **数值方法**：采用协调单元的有限元法（FEM）。\n- **矩阵组装**：全局刚度矩阵 $K$ 通过累加单元刚度矩阵 $k^{e}$ 组装而成。\n- **映射**：一个局部到全局的映射将局部自由度关联到全局索引。\n- **单元矩阵**：每个单元刚度矩阵 $k^{e}$ 都是对称半正定的。\n- **边界条件**：尚未对全局矩阵 $K$ 施加边界条件。\n- **错误**：一个局部到全局映射程序中的编程错误会系统地交换两个全局索引 $p$ 和 $q$。\n- **错误行为**：\n    - 如果一个局部自由度的正确映射是全局索引 $p$，错误的程序会返回 $q$。\n    - 如果正确的映射是 $q$，错误的程序会返回 $p$。\n    - 所有其他全局索引都映射正确。\n- **问题**：描述错误组装的矩阵 $K$ 与正确组装的矩阵 $K_{\\mathrm{true}}$ 之间的关系。\n\n### 第二步：使用提取的信息进行验证\n问题陈述在科学和数学上是合理的。它描述了计算工程中的一个标准流程（有限元组装），并假设了一个现实的编程错误。\n\n- **科学基础**：该问题基于用于求解偏微分方程的成熟的有限元方法。单元矩阵、全局矩阵和局部到全局映射等概念是有限元法的基础。对于给定的椭圆问题，假设单元矩阵 $k^{e}$ 是对称且半正定是正确的。由此产生的全局矩阵 $K$（在施加边界条件之前）也是对称且半正定的。没有违反任何科学原理。\n- **适定性**：所述算法错误的影响是确定性的。给定一个正确的矩阵 $K_{\\mathrm{true}}$，该错误会产生一个唯一的、定义明确的矩阵 $K$。问题要求描述这种关系，这是一个适定的数学问题。\n- **客观性**：语言精确且技术性强。对错误的描述是明确的。\n- **完整性**：问题提供了所有必要的信息，以确定最终矩阵 $K$ 相对于 $K_{\\mathrm{true}}$ 的结构。\n- **未检测到其他缺陷**：该问题并非无关紧要、不切实际或自相矛盾。\n\n### 第三步：结论与行动\n该问题是**有效的**。现在开始求解过程。\n\n### 推导\n全局刚度矩阵 $K$ 的组装基本上是一个累加过程，其中局部单元矩阵 $k^e$ 的元素被添加到 $K$ 中的适当位置。位置由一个局部到全局的索引映射函数决定，我们称之为 $\\text{map}(e, \\alpha)$，它返回单元 $e$ 的第 $\\alpha$ 个局部自由度的全局索引。\n\n正确组装的全局刚度矩阵 $K_{\\mathrm{true}}$ 的元素 $(I, J)$ 由所有单元矩阵贡献的总和给出：\n$$ (K_{\\mathrm{true}})_{IJ} = \\sum_{e} \\sum_{\\alpha, \\beta} (k^e)_{\\alpha\\beta} \\, \\delta_{I, \\text{map}_{\\mathrm{true}}(e, \\alpha)} \\, \\delta_{J, \\text{map}_{\\mathrm{true}}(e, \\beta)} $$\n其中 $(k^e)_{\\alpha\\beta}$ 是单元 $e$ 的局部刚度矩阵的元素，$\\text{map}_{\\mathrm{true}}$ 是正确的映射函数，$\\delta_{ij}$ 是克罗内克δ函数。\n\n由于每个 $k^e$ 都是对称的，即 $(k^e)_{\\alpha\\beta} = (k^e)_{\\beta\\alpha}$，所以得到的矩阵 $K_{\\mathrm{true}}$ 也是对称的，即 $(K_{\\mathrm{true}})_{IJ} = (K_{\\mathrm{true}})_{JI}$。\n\n该错误引入了一个错误的映射函数 $\\text{map}_{\\mathrm{bug}}$，它交换了全局索引 $p$ 和 $q$。令 $\\pi$ 为交换 $p$ 和 $q$ 并保持所有其他索引不变的置换算子：\n$$ \\pi(i) = \\begin{cases} q  \\text{if } i = p \\\\ p  \\text{if } i = q \\\\ i  \\text{otherwise} \\end{cases} $$\n错误的映射可以表示为 $\\text{map}_{\\mathrm{bug}}(e, \\alpha) = \\pi(\\text{map}_{\\mathrm{true}}(e, \\alpha))$。\n\n因此，错误组装的矩阵 $K$ 的构造如下：\n$$ K_{IJ} = \\sum_{e} \\sum_{\\alpha, \\beta} (k^e)_{\\alpha\\beta} \\, \\delta_{I, \\text{map}_{\\mathrm{bug}}(e, \\alpha)} \\, \\delta_{J, \\text{map}_{\\mathrm{bug}}(e, \\beta)} $$\n代入错误映射的表达式：\n$$ K_{IJ} = \\sum_{e} \\sum_{\\alpha, \\beta} (k^e)_{\\alpha\\beta} \\, \\delta_{I, \\pi(\\text{map}_{\\mathrm{true}}(e, \\alpha))} \\, \\delta_{J, \\pi(\\text{map}_{\\mathrm{true}}(e, \\beta))} $$\n让我们分析错误矩阵的任意元素 $K_{IJ}$。令 $I' = \\pi^{-1}(I)$ 和 $J' = \\pi^{-1}(J)$。由于 $\\pi$ 是其自身的逆（$\\pi(\\pi(i)) = i$），我们有 $\\pi^{-1} = \\pi$。因此，$I' = \\pi(I)$ 和 $J' = \\pi(J)$。\n克罗内克δ函数具有性质 $\\delta_{a, \\pi(b)} = \\delta_{\\pi^{-1}(a), b} = \\delta_{\\pi(a), b}$。应用此性质，我们得到：\n$$ K_{IJ} = \\sum_{e} \\sum_{\\alpha, \\beta} (k^e)_{\\alpha\\beta} \\, \\delta_{\\pi(I), \\text{map}_{\\mathrm{true}}(e, \\alpha)} \\, \\delta_{\\pi(J), \\text{map}_{\\mathrm{true}}(e, \\beta)} $$\n将此与 $K_{\\mathrm{true}}$ 的公式进行比较，我们发现这恰好是真实矩阵的 $(\\pi(I), \\pi(J))$ 元素：\n$$ K_{IJ} = (K_{\\mathrm{true}})_{\\pi(I), \\pi(J)} $$\n这种关系意味着错误的矩阵 $K$ 是通过根据 $\\pi$ 置换其行和列从真实矩阵 $K_{\\mathrm{true}}$ 获得的。具体来说，$K$ 的第 $i$ 行是 $K_{\\mathrm{true}}$ 的第 $\\pi(i)$ 行，$K$ 的第 $j$ 列是 $K_{\\mathrm{true}}$ 的第 $\\pi(j)$ 列。例如，$K$ 的第 $p$ 行是 $K_{\\mathrm{true}}$ 的第 $q$ 行，$K$ 的第 $p$ 列是 $K_{\\mathrm{true}}$ 的第 $q$ 列。\n\n在矩阵表示法中，此操作对应于相似变换。令 $P$ 为与 $\\pi$ 关联的置换矩阵。置换矩阵是正交的，所以 $P^{-1} = P^{\\top}$。变换由下式给出：\n$$ K = P^{\\top} K_{\\mathrm{true}} P $$\n或者等价地（因为用于交换的 $P$ 是对称的，$P=P^\\top$）：\n$$ K = P K_{\\mathrm{true}} P $$\n等等，导致 $A'_{ij} = A_{\\pi(i)\\pi(j)}$ 的相似变换惯例是 $A' = P A P^\\top$，其中 $P_{ij} = \\delta_{i, \\pi(j)}$。让我们重新验证。令 $K' = P K_{\\mathrm{true}} P^{\\top}$。\n$ (K')_{ij} = \\sum_r \\sum_s P_{ir} (K_{\\mathrm{true}})_{rs} (P^{\\top})_{sj} $。\n$P_{ir} = \\delta_{i, \\pi(r)}$，所以 $r=\\pi^{-1}(i)$。\n$(P^{\\top})_{sj} = P_{js} = \\delta_{j, \\pi(s)}$，所以 $s=\\pi^{-1}(j)$。\n则 $(K')_{ij} = (K_{\\mathrm{true}})_{\\pi^{-1}(i), \\pi^{-1}(j)}$。\n我最初的推导给出了 $K_{IJ} = (K_{\\mathrm{true}})_{\\pi(I), \\pi(J)}$。让我们重新检查矩阵变换的定义。\n如果我们将基向量重新标记为 $e'_i = e_{\\pi(i)}$，新的矩阵表示 $A'$ 与旧的表示 $A$ 的关系是 $A'_{ij} = A_{\\pi(i),\\pi(j)}$。这对应于共轭 $A' = P^{-1}AP$，其中 $(Pe_i) = e_{\\pi(i)}$。\n让我们坚持具体的公式 $K_{IJ} = (K_{\\mathrm{true}})_{\\pi(I), \\pi(J)}$。\n让我们检查关系 $K = P K_{\\mathrm{true}} P^{\\top}$，其中 $P$ 是交换行/列 $p$ 和 $q$ 的置换矩阵。该矩阵作用于向量 $v$ 为 $(Pv)_i = v_{\\pi(i)}$。\n那么 $(P K_{\\mathrm{true}})_{ij} = (K_{\\mathrm{true}})_{\\pi(i), j}$。\n然后 $( (P K_{\\mathrm{true}}) P^{\\top} )_{ij} = \\sum_k (P K_{\\mathrm{true}})_{ik} (P^{\\top})_{kj} = \\sum_k (K_{\\mathrm{true}})_{\\pi(i), k} P_{jk}$。唯一的非零项是当 $k=\\pi(j)$ 时，所以这是 $(K_{\\mathrm{true}})_{\\pi(i), \\pi(j)}$。\n这证实了 $K_{ij} = (K_{\\mathrm{true}})_{\\pi(i), \\pi(j)}$ 等价于 $K = P K_{\\mathrm{true}} P^{\\top}$。注意，对于交换置换，$P=P^\\top$，所以这也是 $K = P K_{\\mathrm{true}} P$。\n\n此变换的性质：\n1.  **对称性**：如果 $K_{\\mathrm{true}}$ 是对称的，那么 $K_{\\mathrm{true}}^{\\top} = K_{\\mathrm{true}}$。变换后的矩阵是 $K^{\\top} = (P K_{\\mathrm{true}} P^{\\top})^{\\top} = (P^{\\top})^{\\top} K_{\\mathrm{true}}^{\\top} P^{\\top} = P K_{\\mathrm{true}} P^{\\top} = K$。因此，$K$ 保持对称。这是合理的，因为在组装过程中，该错误对称地应用于行和列索引。\n2.  **特征值**：$K$ 和 $K_{\\mathrm{true}}$ 通过相似变换相关联，因为 $P$ 是一个正交矩阵 ($P^{\\top} = P^{-1}$)。相似变换保持特征值不变。\n3.  **稀疏性**：该变换只是置换了行和列。$K_{\\mathrm{true}}$ 的第 $p$ 行被移到 $K$ 的第 $q$ 行，第 $q$ 行被移到第 $p$ 行，列也类似。非零元素的集合被置换了，但总体数量和模式（在这种重新索引下）是相同的。\n\n### 逐项分析\n\n**A. $K$ 变得非对称，因为只有行 $p$ 和 $q$ 被置换，而相应的列保持不变。**\n这是不正确的。局部到全局映射用于确定单元贡献添加到的全局矩阵项的行索引和列索引。此映射中的错误会对两者产生对称影响。如上所述，如果 $K_{\\mathrm{true}}$ 是对称的，则生成的矩阵 $K$ 也是对称的。一个只置换行的操作将导致 $K = P K_{\\mathrm{true}}$，这通常不是对称的。\n**结论：不正确。**\n\n**B. $K$ 等于 $P K_{\\mathrm{true}} P^{\\top}$，其中 $P$ 是交换索引 $p$ 和 $q$ 的置换矩阵；因此 $K$ 保持对称，其特征值与 $K_{\\mathrm{true}}$ 的特征值匹配，稀疏模式除了行和列 $p$ 与 $q$ 被交换外是相同的。**\n这个陈述准确地描述了错误的后果。该变换是一个相似变换 $K = P K_{\\mathrm{true}} P^{\\top}$（或 $P K_{\\mathrm{true}} P$，因为对于交换操作，$P=P^\\top$）。正如在推导中确立的，这样的变换保持对称性和特征值。对矩阵影响的描述（“稀疏模式除了行和列 $p$ 与 $q$ 被交换外是相同的”）是对这种置换的正确定性描述。\n**结论：正确。**\n\n**C. 只有对角线元素 $K_{pp}$ 和 $K_{qq}$ 被交换；所有非对角线元素与 $K_{\\mathrm{true}}$ 中的保持相同。**\n这是不正确的。从关系式 $K_{IJ} = (K_{\\mathrm{true}})_{\\pi(I), \\pi(J)}$，我们可以检查各种元素：\n- $K_{pp} = (K_{\\mathrm{true}})_{\\pi(p), \\pi(p)} = (K_{\\mathrm{true}})_{qq}$。（对角线元素交换）\n- $K_{qq} = (K_{\\mathrm{true}})_{\\pi(q), \\pi(q)} = (K_{\\mathrm{true}})_{pp}$。（对角线元素交换）\n- 对于一个索引 $i \\ne p, q$，元素 $K_{pi}$ 由 $K_{pi} = (K_{\\mathrm{true}})_{\\pi(p), \\pi(i)} = (K_{\\mathrm{true}})_{qi}$ 给出。这通常不等于 $(K_{\\mathrm{true}})_{pi}$。因此，非对角线元素也发生了变化。具体来说，$K$ 的整个第 $p$ 行是 $K_{\\mathrm{true}}$ 的第 $q$ 行的置换，反之亦然。\n**结论：不正确。**\n\n**D. $K$ 的行 $p$ 和列 $p$ 中的所有元素都变为零，而行 $q$ 和列 $q$ 中的元素相对于 $K_{\\mathrm{true}}$ 增加了一倍。**\n这在物理上和算法上都是没有根据的。该错误不会消除或复制贡献；它只是重新路由它们。任何本应贡献给 $K_{\\mathrm{true}}$ 中涉及索引 $p$ 的元素的贡献都被重定向到 $K$ 中涉及索引 $q$ 的元素。反之，$K_{\\mathrm{true}}$ 中索引 $q$ 的贡献被发送到索引 $p$。除非它们本来就是零，或者矩阵具有非常特定的、巧合的结构，否则没有元素会变为零或加倍。\n**结论：不正确。**", "answer": "$$\\boxed{B}$$", "id": "3206774"}, {"introduction": "现在，让我们卷起袖子，从零开始构建一个刚度矩阵。这个练习 [@problem_id:3206749] 将引导你走完为一根由不同材料制成的杆件（一个常见的工程场景）构建矩阵的全过程。通过手动计算每个矩阵元，并分析最终矩阵的条件数，你将具体地理解材料属性如何直接影响我们需要求解的数值问题的稳定性。", "problem": "考虑定义域 $[0, 3h]$ 上的一个一维扩散偏微分方程 (PDE) $- \\frac{d}{dx}\\left(k(x) \\frac{du}{dx}\\right) = f(x)$，其边界条件为齐次狄利克雷边界条件 $u(0) = 0$ 和 $u(3h) = 0$。材料系数 $k(x)$ 是分段常数，在一个由3个单元和4个节点（$x_1 = 0, x_2 = h, x_3 = 2h, x_4 = 3h$）组成的均匀网格上交替变化，具体如下：在 $[0, h]$ 上 $k(x) = k_1$，在 $[h, 2h]$ 上 $k(x) = k_2$，在 $[2h, 3h]$ 上 $k(x) = k_1$，其中 $k_1 \\gg k_2 > 0$。使用标准的伽辽金有限元法 (FEM)，配以与节点相关的连续分段线性基函数，从弱形式和单元刚度项的定义出发，组装全局刚度矩阵。然后，在施加齐次狄利克雷边界条件以消除节点 $x_1$ 和 $x_4$ 处的边界自由度后，提取与内部节点 $x_2$ 和 $x_3$ 相关的简化全局刚度矩阵。\n\n从第一性原理出发，不使用预先组装好的公式，计算该简化刚度矩阵在矩阵2-范数下的精确谱条件数，并以 $k_1$ 和 $k_2$ 的闭式表达式表示。请以单个简化的解析表达式给出最终答案。无需四舍五入，最终表达式中不应包含任何单位。", "solution": "用户提供了一个问题，要求推导由一维有限元问题产生的简化刚度矩阵的谱条件数。\n\n### 步骤1：问题验证\n\n**提取的已知条件：**\n- **偏微分方程(PDE):** $- \\frac{d}{dx}\\left(k(x) \\frac{du}{dx}\\right) = f(x)$\n- **定义域:** $x \\in [0, 3h]$\n- **边界条件(BCs):** $u(0) = 0$ 和 $u(3h) = 0$ (齐次狄利克雷)。\n- **网格:** 均匀网格，包含3个单元和4个节点：$x_1 = 0$, $x_2 = h$, $x_3 = 2h$, $x_4 = 3h$。\n- **材料系数:** $k(x)$ 是分段常数：\n  - 当 $x \\in [0, h]$ 时，$k(x) = k_1$\n  - 当 $x \\in [h, 2h]$ 时，$k(x) = k_2$\n  - 当 $x \\in [2h, 3h]$ 时，$k(x) = k_1$\n- **系数约束:** $k_1 \\gg k_2 > 0$。\n- **方法:** 标准的伽辽金有限元法 (FEM)，采用连续分段线性基函数。\n- **任务:**\n  1. 推导弱形式。\n  2. 组装全局刚度矩阵。\n  3. 施加边界条件以获得与内部节点 $x_2$ 和 $x_3$ 相关的简化全局刚度矩阵。\n  4. 计算该简化矩阵在矩阵2-范数下的精确谱条件数，并以 $k_1$ 和 $k_2$ 的闭式表达式表示。\n\n**使用提取的已知条件进行验证：**\n1.  **科学性：** 该问题是使用有限元法进行偏微分方程数值分析的一个标准练习。所有概念——扩散方程、弱形式、伽辽金方法、刚度矩阵和条件数——在数学和工程领域都是基础且公认的。\n2.  **适定性：** 该问题提供了构建刚度矩阵和计算其条件数所需的所有信息。问题设置清晰，目标是找到一个特定的解析表达式，这是一个适定的数学任务。\n3.  **客观性：** 问题以精确的技术语言陈述，没有任何主观或模糊的术语。\n4.  **完整性与一致性：** 问题是自洽的。定义域、边界条件、网格、基函数和材料属性都已指定，没有内部矛盾。\n5.  **现实性：** 该设置对应一个物理系统，例如热传导或通过多孔介质的流体流动，该系统由三层材料组成，其中外层的属性（如电导率）与内层不同。\n\n**结论：** 该问题有效、科学合理、适定且完整。我将继续进行求解。\n\n### 步骤2：推导与求解\n\n**弱形式**\n我们从控制偏微分方程开始：\n$$ - \\frac{d}{dx}\\left(k(x) \\frac{du}{dx}\\right) = f(x) \\quad \\text{for } x \\in (0, 3h) $$\n我们将其乘以一个在狄利克雷边界上为零的函数空间（即 $H_0^1(0, 3h)$）中的测试函数 $v(x)$。在整个定义域上积分得到：\n$$ -\\int_{0}^{3h} v(x) \\frac{d}{dx}\\left(k(x) \\frac{du}{dx}\\right) dx = \\int_{0}^{3h} v(x) f(x) dx $$\n对左侧应用分部积分：\n$$ \\int_{0}^{3h} \\frac{dv}{dx} k(x) \\frac{du}{dx} dx - \\left[ v(x) k(x) \\frac{du}{dx} \\right]_{0}^{3h} = \\int_{0}^{3h} v(x) f(x) dx $$\n由于测试函数 $v(x)$ 必须满足齐次狄利克雷边界条件，即 $v(0) = v(3h) = 0$，边界项消失。弱形式为：求 $u \\in H_0^1(0, 3h)$，使得对于所有 $v \\in H_0^1(0, 3h)$：\n$$ \\int_{0}^{3h} k(x) \\frac{du}{dx} \\frac{dv}{dx} dx = \\int_{0}^{3h} f(x) v(x) dx $$\n左侧定义了双线性形式 $a(u,v)$，刚度矩阵由此导出。\n\n**有限元离散化**\n我们使用与每个节点 $x_i$ 相关的连续分段线性基函数（帽函数）$\\phi_i(x)$，使得 $\\phi_i(x_j) = \\delta_{ij}$。近似解为 $u_h(x) = \\sum_{j=1}^{4} U_j \\phi_j(x)$。\n基函数的导数是分段常数。在一个长度为 $h$ 的单元上，导数为 $\\pm 1/h$。\n- $\\phi'_1(x) = -1/h$ on $[0, h]$\n- $\\phi'_2(x) = 1/h$ on $[0, h]$ and $-1/h$ on $[h, 2h]$\n- $\\phi'_3(x) = 1/h$ on $[h, 2h]$ and $-1/h$ on $[2h, 3h]$\n- $\\phi'_4(x) = 1/h$ on $[2h, 3h]$\n\n**组装全局刚度矩阵**\n全局刚度矩阵 $K$ 的项由 $K_{ij} = a(\\phi_j, \\phi_i) = \\int_{0}^{3h} k(x) \\phi'_i(x) \\phi'_j(x) dx$ 给出。我们通过在导数乘积非零的每个单元上积分来计算非零项。\n\n- **单元1：$[0, h]$，其中 $k(x) = k_1$**\n  - $K_{11}^{(1)} = \\int_{0}^{h} k_1 (\\phi'_1)^2 dx = \\int_{0}^{h} k_1 (-1/h)^2 dx = \\frac{k_1}{h}$\n  - $K_{22}^{(1)} = \\int_{0}^{h} k_1 (\\phi'_2)^2 dx = \\int_{0}^{h} k_1 (1/h)^2 dx = \\frac{k_1}{h}$\n  - $K_{12}^{(1)} = K_{21}^{(1)} = \\int_{0}^{h} k_1 \\phi'_1 \\phi'_2 dx = \\int_{0}^{h} k_1 (-1/h)(1/h) dx = -\\frac{k_1}{h}$\n\n- **单元2：$[h, 2h]$，其中 $k(x) = k_2$**\n  - $K_{22}^{(2)} = \\int_{h}^{2h} k_2 (\\phi'_2)^2 dx = \\int_{h}^{2h} k_2 (-1/h)^2 dx = \\frac{k_2}{h}$\n  - $K_{33}^{(2)} = \\int_{h}^{2h} k_2 (\\phi'_3)^2 dx = \\int_{h}^{2h} k_2 (1/h)^2 dx = \\frac{k_2}{h}$\n  - $K_{23}^{(2)} = K_{32}^{(2)} = \\int_{h}^{2h} k_2 \\phi'_2 \\phi'_3 dx = \\int_{h}^{2h} k_2 (-1/h)(1/h) dx = -\\frac{k_2}{h}$\n\n- **单元3：$[2h, 3h]$，其中 $k(x) = k_1$**\n  - $K_{33}^{(3)} = \\int_{2h}^{3h} k_1 (\\phi'_3)^2 dx = \\int_{2h}^{3h} k_1 (-1/h)^2 dx = \\frac{k_1}{h}$\n  - $K_{44}^{(3)} = \\int_{2h}^{3h} k_1 (\\phi'_4)^2 dx = \\int_{2h}^{3h} k_1 (1/h)^2 dx = \\frac{k_1}{h}$\n  - $K_{34}^{(3)} = K_{43}^{(3)} = \\int_{2h}^{3h} k_1 \\phi'_3 \\phi'_4 dx = \\int_{2h}^{3h} k_1 (-1/h)(1/h) dx = -\\frac{k_1}{h}$\n\n全局刚度矩阵 $K$ 是通过对每个单元的贡献求和来组装的：\n- $K_{11} = K_{11}^{(1)} = \\frac{k_1}{h}$\n- $K_{22} = K_{22}^{(1)} + K_{22}^{(2)} = \\frac{k_1}{h} + \\frac{k_2}{h} = \\frac{k_1+k_2}{h}$\n- $K_{33} = K_{33}^{(2)} + K_{33}^{(3)} = \\frac{k_2}{h} + \\frac{k_1}{h} = \\frac{k_1+k_2}{h}$\n- $K_{44} = K_{44}^{(3)} = \\frac{k_1}{h}$\n- $K_{12} = K_{21} = -\\frac{k_1}{h}$\n- $K_{23} = K_{32} = -\\frac{k_2}{h}$\n- $K_{34} = K_{43} = -\\frac{k_1}{h}$\n\n最终得到的 $4 \\times 4$ 全局刚度矩阵是：\n$$ K = \\frac{1}{h} \\begin{pmatrix} k_1  -k_1  0  0 \\\\ -k_1  k_1+k_2  -k_2  0 \\\\ 0  -k_2  k_1+k_2  -k_1 \\\\ 0  0  -k_1  k_1 \\end{pmatrix} $$\n\n**施加边界条件并提取简化矩阵**\n齐次狄利克雷边界条件 $u(0)=0$ 和 $u(3h)=0$ 对应于设置节点值 $U_1=0$ 和 $U_4=0$。这等效于从全局矩阵 $K$ 中移除第一行和第四行以及第一列和第四列，以获得关于内部未知自由度 $U_2$ 和 $U_3$ 的简化系统。简化刚度矩阵 $K_{red}$ 是对应于节点2和3的 $2 \\times 2$ 子矩阵：\n$$ K_{red} = \\frac{1}{h} \\begin{pmatrix} k_1+k_2  -k_2 \\\\ -k_2  k_1+k_2 \\end{pmatrix} $$\n\n**计算谱条件数**\n一个对称正定矩阵的谱条件数（在2-范数下）是其最大特征值与最小特征值之比：$\\kappa_2(A) = \\frac{\\lambda_{\\max}(A)}{\\lambda_{\\min}(A)}$。\n\n我们通过求解特征方程 $\\det(K_{red} - \\lambda I) = 0$ 来找到 $K_{red}$ 的特征值。\n$$ \\det \\begin{pmatrix} \\frac{k_1+k_2}{h} - \\lambda  -\\frac{k_2}{h} \\\\ -\\frac{k_2}{h}  \\frac{k_1+k_2}{h} - \\lambda \\end{pmatrix} = 0 $$\n$$ \\left(\\frac{k_1+k_2}{h} - \\lambda\\right)^2 - \\left(-\\frac{k_2}{h}\\right)^2 = 0 $$\n$$ \\left(\\frac{k_1+k_2}{h} - \\lambda\\right)^2 = \\frac{k_2^2}{h^2} $$\n两边取平方根：\n$$ \\frac{k_1+k_2}{h} - \\lambda = \\pm \\frac{k_2}{h} $$\n这给出了 $\\lambda$ 的两个可能值：\n1.  $\\lambda_a = \\frac{k_1+k_2}{h} - \\frac{k_2}{h} = \\frac{k_1}{h}$\n2.  $\\lambda_b = \\frac{k_1+k_2}{h} + \\frac{k_2}{h} = \\frac{k_1+2k_2}{h}$\n\n由于 $k_1 > 0$ 且 $k_2 > 0$，显然 $\\lambda_b > \\lambda_a$。因此：\n- $\\lambda_{\\min}(K_{red}) = \\frac{k_1}{h}$\n- $\\lambda_{\\max}(K_{red}) = \\frac{k_1+2k_2}{h}$\n\n$K_{red}$ 的谱条件数是：\n$$ \\kappa_2(K_{red}) = \\frac{\\lambda_{\\max}(K_{red})}{\\lambda_{\\min}(K_{red})} = \\frac{\\frac{k_1+2k_2}{h}}{\\frac{k_1}{h}} $$\n$$ \\kappa_2(K_{red}) = \\frac{k_1+2k_2}{k_1} $$\n简化表达式得到最终答案：\n$$ \\kappa_2(K_{red}) = 1 + \\frac{2k_2}{k_1} $$", "answer": "$$\\boxed{1 + \\frac{2k_2}{k_1}}$$", "id": "3206749"}, {"introduction": "有限元方法的真正威力在于其处理复杂二维和三维几何体的能力。最后一个练习 [@problem_id:3206634] 将挑战你为由四面体单元构成的三维物体实现组装过程。你将需要使用雅可比矩阵处理几何变换，并施加边界条件来求解一个完整的问题，从而将我们在一维示例中学到的概念转化为一个更通用、更强大的计算工具。", "problem": "考虑一个多面体域 $\\Omega \\subset \\mathbb{R}^3$ 上的标量扩散偏微分方程（PDE）$- \\nabla \\cdot (\\kappa \\nabla u) = f$，其在边界 $\\partial \\Omega$ 上具有 Dirichlet 边界数据 $u = g$。使用标准的 Galerkin 有限元法（FEM），采用一阶（分片线性）四面体单元，组装全局刚度矩阵。组装过程必须源自从该偏微分方程推导出的弱形式，不得使用任何快捷公式。\n\n从弱形式出发：求解 $u \\in H^1(\\Omega)$，使得在 $\\partial \\Omega$ 上有 $u = g$，并且\n$$\na(u,v) = \\ell(v) \\quad \\text{对于所有 } v \\in H_0^1(\\Omega),\n$$\n其中\n$$\na(u,v) = \\int_{\\Omega} \\kappa \\, \\nabla u \\cdot \\nabla v \\, \\mathrm{d}x, \\qquad \\ell(v) = \\int_{\\Omega} f \\, v \\, \\mathrm{d}x.\n$$\n使用 $N$ 个节点和 $M$ 个四面体进行离散化。对于每个顶点为 $\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{x}_3, \\mathbf{x}_4 \\in \\mathbb{R}^3$ 的四面体，通过 Jacobian 矩阵定义从参考四面体（顶点为 $(0,0,0)$, $(1,0,0)$, $(0,1,0)$, $(0,0,1)$）到该四面体的仿射映射\n$$\nJ = \\begin{bmatrix} \\mathbf{x}_2 - \\mathbf{x}_1  \\mathbf{x}_3 - \\mathbf{x}_1  \\mathbf{x}_4 - \\mathbf{x}_1 \\end{bmatrix} \\in \\mathbb{R}^{3 \\times 3}.\n$$\n令 $\\nabla \\hat{N}_1 = (-1,-1,-1)^\\top$, $\\nabla \\hat{N}_2 = (1,0,0)^\\top$, $\\nabla \\hat{N}_3 = (0,1,0)^\\top$, $\\nabla \\hat{N}_4 = (0,0,1)^\\top$ 为参考形函数的梯度。物理梯度为\n$$\n\\nabla N_i = J^{-\\top} \\nabla \\hat{N}_i, \\quad i \\in \\{1,2,3,4\\},\n$$\n物理四面体的体积为\n$$\n|T| = \\frac{|\\det(J)|}{6}.\n$$\n利用这些，单元刚度矩阵的项为\n$$\nK_e(i,j) = \\kappa_e \\, |T| \\, \\nabla N_i \\cdot \\nabla N_j, \\quad i,j \\in \\{1,2,3,4\\},\n$$\n其中 $\\kappa_e$ 是该四面体上的常数扩散系数。通过根据所有单元的连接关系，对它们的贡献求和，来组装全局刚度矩阵 $K \\in \\mathbb{R}^{N \\times N}$。\n\n为在一组边界节点 $G$ 上施加具有给定值 $\\{g_k\\}_{k \\in G}$ 的 Dirichlet 边界条件，将节点的索引集划分为自由节点 $F$ 和边界节点 $G$，并求解从离散弱形式中获得的简化线性系统：\n$$\nK_{FF} \\, u_F = b_F - K_{FG} \\, u_G,\n$$\n其中 $b$ 是全局载荷向量，其项为 $b_i = \\int_{\\Omega} f N_i \\, \\mathrm{d}x$。在本问题中，使用 $f \\equiv 0$，因此 $b = 0$。自由节点上的最终内部解是 $u_F$，而完整的节点场则通过将 $u_F$ 与给定的 $u_G$ 组合得到。\n\n请实现所述的组装和 Dirichlet 条件施加过程，并为以下测试套件生成特定的量化输出。在整个过程中，使用解析函数 $u^\\star(x,y,z) = x + y + z$ 来定义边界节点上的 Dirichlet 数据 $g(\\mathbf{x}) = u^\\star(\\mathbf{x})$。\n\n测试套件：\n- 情况 A（单个四面体）：\n  - 节点（索引 0 到 3）：$\\mathbf{x}_0 = (0,0,0)$，$\\mathbf{x}_1 = (1,0,0)$，$\\mathbf{x}_2 = (0,1,0)$，$\\mathbf{x}_3 = (0,0,1)$。\n  - 单元：一个四面体，连接关系为 $[0,1,2,3]$。\n  - 单元扩散系数：$\\kappa = 2$。\n  - Dirichlet 边界节点：$G = \\{0,1,2,3\\}$，其值为 $u_G = \\{u^\\star(\\mathbf{x}_k)\\}_{k \\in G}$。\n  - 右端项：$f \\equiv 0$。\n  - 需要计算的输出：\n    1. 组装的全局刚度矩阵 $K$ 的 Frobenius 范数 $\\|K\\|_F$。\n    2. 自由节点上的最大绝对误差，定义为 $\\max_{i \\in F} |u_F(i) - u^\\star(\\mathbf{x}_i)|$。如果 $F$ 为空集，则该值为 $0$。\n\n- 情况 B（一个由一个内部节点细分的四面体）：\n  - 节点（索引 0 到 4）：$\\mathbf{x}_0 = (0,0,0)$，$\\mathbf{x}_1 = (1,0,0)$，$\\mathbf{x}_2 = (0,1,0)$，$\\mathbf{x}_3 = (0,0,1)$，$\\mathbf{x}_4 = (0.25,0.25,0.25)$。\n  - 单元：四个四面体，连接关系为 $[4,1,2,3]$，$[4,0,2,3]$，$[4,0,1,3]$，$[4,0,1,2]$。\n  - 单元扩散系数：每个四面体均为 $\\kappa = 1$。\n  - Dirichlet 边界节点：$G = \\{0,1,2,3\\}$，其值为 $u_G = \\{u^\\star(\\mathbf{x}_k)\\}_{k \\in G}$；内部节点为 $4$。\n  - 右端项：$f \\equiv 0$。\n  - 需要计算的输出：\n    1. 组装的全局刚度矩阵 $K$ 的 Frobenius 范数 $\\|K\\|_F$。\n    2. 自由节点 $F = \\{4\\}$ 上的最大绝对误差，定义为 $|u_F(4) - u^\\star(\\mathbf{x}_4)|$。\n\n- 情况 C（一个近乎退化的薄片四面体）：\n  - 节点（索引 0 到 3）：$\\mathbf{x}_0 = (0,0,0)$，$\\mathbf{x}_1 = (10^{-6},0,0)$，$\\mathbf{x}_2 = (0,1,0)$，$\\mathbf{x}_3 = (0,0,1)$。\n  - 单元：一个四面体，连接关系为 $[0,1,2,3]$。\n  - 单元扩散系数：$\\kappa = 1$。\n  - Dirichlet 边界节点：$G = \\{0,1,2,3\\}$，其值为 $u_G = \\{u^\\star(\\mathbf{x}_k)\\}_{k \\in G}$。\n  - 右端项：$f \\equiv 0$。\n  - 需要计算的输出：\n    1. 组装的全局刚度矩阵 $K$ 的 Frobenius 范数 $\\|K\\|_F$。\n    2. 自由节点上的最大绝对误差；由于 $F$ 为空，此值定义为 $0$。\n\n你的程序必须实现所述的三维四面体有限元组装，构建全局刚度矩阵，通过系统分区施加 Dirichlet 边界条件，在适用时求解内部节点值，并为每种情况计算上述的一对输出。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\|K\\|_F^{(A)}, \\mathrm{err}^{(A)}, \\|K\\|_F^{(B)}, \\mathrm{err}^{(B)}, \\|K\\|_F^{(C)}, \\mathrm{err}^{(C)}]$。不涉及物理单位；所有量均为无量纲实数。不使用角度。输出为实值浮点数。", "solution": "问题陈述已经过仔细验证，并被确定为有效。它在科学上基于求解偏微分方程的有限元法（FEM）原理，是适定的，具有完整且一致的数据和定义集，并以客观、正式的语言表述。所提供的仿射映射、物理梯度、单元体积和单元刚度矩阵的公式对于一阶（P1）四面体单元是标准且正确的。测试用例定义明确，用于验证实现是否能正确处理参考单元、带内部节点的网格以及几何上退化的单元。\n\n任务是为标量扩散方程 $- \\nabla \\cdot (\\kappa \\nabla u) = f$ 实现全局刚度矩阵的组装，该方程在四面体网格上使用分片线性基函数通过有限元法进行离散化。组装后的矩阵随后用于在施加 Dirichlet 边界条件后求解未知的节点值。要求的具体输出是全局刚度矩阵的 Frobenius 范数以及三种不同测试用例下内部节点的最大误差。\n\n一般步骤如下：\n1.  初始化一个 $N \\times N$ 的全局刚度矩阵 $K$，所有项均设为零，其中 $N$ 是网格中节点的总数。\n2.  遍历网格中的每个四面体（单元）$T_e$。对于每个单元：\n    a. 从单元连接关系列表中，识别其四个顶点的全局索引 $[n_1, n_2, n_3, n_4]$。\n    b. 获取这些顶点的坐标：$\\mathbf{x}_{n_1}, \\mathbf{x}_{n_2}, \\mathbf{x}_{n_3}, \\mathbf{x}_{n_4}$。\n    c. 构造从参考四面体到物理四面体 $T_e$ 的仿射映射的 Jacobian 矩阵 $J_e$。问题将其定义为 $J_e = \\begin{bmatrix} \\mathbf{x}_{n_2} - \\mathbf{x}_{n_1}  \\mathbf{x}_{n_3} - \\mathbf{x}_{n_1}  \\mathbf{x}_{n_4} - \\mathbf{x}_{n_1} \\end{bmatrix}$。\n    d. 计算单元的体积 $|T_e| = \\frac{|\\det(J_e)|}{6}$。\n    e. 计算 Jacobian 矩阵的逆转置 $J_e^{-\\top}$。\n    f. 通过使用关系式 $\\nabla N_i = J_e^{-\\top} \\nabla \\hat{N}_i$ 变换参考梯度 $\\nabla \\hat{N}_i$，来确定四个物理基函数的梯度 $\\nabla N_i$。给定的参考梯度为 $\\nabla \\hat{N}_1 = (-1,-1,-1)^\\top$, $\\nabla \\hat{N}_2 = (1,0,0)^\\top$, $\\nabla \\hat{N}_3 = (0,1,0)^\\top$, $\\nabla \\hat{N}_4 = (0,0,1)^\\top$。\n    g. 计算 $4 \\times 4$ 的单元刚度矩阵 $K_e$，其项由 $K_e(i,j) = \\kappa_e |T_e| (\\nabla N_i \\cdot \\nabla N_j)$ 给出，其中 $\\kappa_e$ 是单元 $T_e$ 上的常数扩散系数。以矩阵形式，这可以写为 $K_e = \\kappa_e |T_e| G_e^\\top G_e$，其中 $G_e = \\begin{bmatrix} \\nabla N_1  \\nabla N_2  \\nabla N_3  \\nabla N_4 \\end{bmatrix}$ 是物理基函数梯度的 $3 \\times 4$ 矩阵。\n    h. 将 $K_e$ 的贡献累加到全局刚度矩阵 $K$ 中。对于每个项 $K_e(i,j)$，其值被加到全局项 $K(n_i, n_j)$ 上。\n3.  遍历完所有单元后，计算组装好的全局矩阵 $K$ 的 Frobenius 范数 $\\|K\\|_F = \\sqrt{\\sum_{i,j=1}^N |K_{ij}|^2}$。\n4.  为求解，将节点划分为自由（内部）节点集 $F$ 和 Dirichlet 边界节点集 $G$。本问题使用源项 $f \\equiv 0$，因此载荷向量为零。为求解自由节点值 $u_F$ 所需解的方程组是 $K_{FF} u_F = -K_{FG} u_G$，其中 $K_{FF}$ 和 $K_{FG}$ 是 $K$ 的子矩阵，而 $u_G$ 是边界节点上给定值的向量。给定值由解析函数 $u^\\star(x,y,z) = x+y+z$ 导出。\n5.  求解出 $u_F$ 后，计算自由节点上的最大绝对误差：$\\max_{i \\in F} |u_F(i) - u^\\star(\\mathbf{x}_i)|$。如果集合 $F$ 为空，则此误差定义为 $0$。\n\n**情况 A：单个参考四面体**\n-   节点：$\\mathbf{x}_0 = (0,0,0)$, $\\mathbf{x}_1 = (1,0,0)$, $\\mathbf{x}_2 = (0,1,0)$, $\\mathbf{x}_3 = (0,0,1)$。$N=4$。\n-   连接关系：$[0,1,2,3]$。\n-   Jacobian 矩阵是 $J = [\\mathbf{x}_1-\\mathbf{x}_0 \\ \\ \\mathbf{x}_2-\\mathbf{x}_0 \\ \\ \\mathbf{x}_3-\\mathbf{x}_0] = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} = I_3$。\n-   单元体积为 $|T| = |\\det(I_3)|/6 = 1/6$。\n-   由于 $J^{-\\top} = I_3$，物理梯度与参考梯度相同。\n-   单元刚度矩阵为 $K_e(i,j) = \\kappa_e |T| (\\nabla \\hat{N}_i \\cdot \\nabla \\hat{N}_j)$。当 $\\kappa=2$ 且 $|T|=1/6$ 时，此式为 $K_e(i,j) = \\frac{1}{3} (\\nabla \\hat{N}_i \\cdot \\nabla \\hat{N}_j)$。\n-   点积矩阵 $(\\nabla \\hat{N}_i \\cdot \\nabla \\hat{N}_j)$ 是 $\\begin{pmatrix} 3  -1  -1  -1 \\\\ -1  1  0  0 \\\\ -1  0  1  0 \\\\ -1  0  0  1 \\end{pmatrix}$。\n-   因此，$K_e = \\frac{1}{3} \\begin{pmatrix} 3  -1  -1  -1 \\\\ -1  1  0  0 \\\\ -1  0  1  0 \\\\ -1  0  0  1 \\end{pmatrix} = \\begin{pmatrix} 1  -1/3  -1/3  -1/3 \\\\ -1/3  1/3  0  0 \\\\ -1/3  0  1/3  0 \\\\ -1/3  0  0  1/3 \\end{pmatrix}$。\n-   由于只有一个单元，全局矩阵 $K$ 等于 $K_e$。\n-   Frobenius 范数是 $\\|K\\|_F = \\sqrt{1^2 + 4 \\times (-1/3)^2 + 3 \\times (1/3)^2} = \\sqrt{1 + 4/9 + 3/9} = \\sqrt{16/9} = 4/3$。\n-   所有节点都是 Dirichlet 节点，因此自由节点集 $F$ 为空。误差为 $0$。\n-   结果：$\\|K\\|_F = 4/3 \\approx 1.3333$，误差 $= 0.0$。\n\n**情况 B：细分的四面体**\n-   区域与情况 A 中的参考四面体相同，但通过一个内部节点 $\\mathbf{x}_4 = (0.25, 0.25, 0.25)$ 将其细分为四个较小的四面体。\n-   共有 $N=5$ 个节点。节点 $4$ 是唯一的自由节点（$F=\\{4\\}$），而节点 $0, 1, 2, 3$ 是 Dirichlet 节点（$G=\\{0,1,2,3\\}$）。\n-   全局刚度矩阵 $K$ 是一个 $5 \\times 5$ 的矩阵，由四个单元的贡献组装而成。四个单元刚度矩阵的计算及其到 $K$ 的求和是通过计算完成的。\n-   该偏微分方程的解析解是 $u^\\star(x,y,z) = x+y+z$。由于 $u^\\star$ 是一个线性函数，它可以被分片线性有限元基完美表示。因此，有限元解必须是精确的，这意味着在内部节点 $u_4$ 处的计算值必须等于解析值 $u^\\star(\\mathbf{x}_4)$。\n-   $u^\\star(\\mathbf{x}_4) = 0.25 + 0.25 + 0.25 = 0.75$。\n-   $u_4$ 的解从单个方程 $K_{44}u_4 = -(K_{40}u_0 + K_{41}u_1 + K_{42}u_2 + K_{43}u_3)$ 获得。当 $u_0=0, u_1=1, u_2=1, u_3=1$ 时，该方程为 $K_{44}u_4 = -(K_{41}+K_{42}+K_{43})$。由于重心细分和网格对称性，可以证明 $K_{40} = K_{41} = K_{42} = K_{43}$，并且行和为零（$K_{40}+K_{41}+K_{42}+K_{43}+K_{44}=0$）。这些性质导致 $u_4 = 0.75$。\n-   因此，误差预计为 $0$（在浮点精度范围内）。Frobenius 范数 $\\|K\\|_F$ 是通过数值计算得出的。\n\n**情况 C：薄片四面体**\n-   节点：$\\mathbf{x}_0 = (0,0,0)$, $\\mathbf{x}_1 = (\\epsilon,0,0)$, $\\mathbf{x}_2 = (0,1,0)$, $\\mathbf{x}_3 = (0,0,1)$，其中 $\\epsilon=10^{-6}$。\n-   Jacobian 矩阵是一个对角矩阵 $J = \\text{diag}(\\epsilon, 1, 1)$。其行列式为 $\\det(J) = \\epsilon$。\n-   单元体积为 $|T| = |\\det(J)|/6 = \\epsilon/6$。\n-   逆转置是 $J^{-\\top} = \\text{diag}(1/\\epsilon, 1, 1)$。\n-   物理梯度被各向异性地缩放。例如，$\\nabla N_2 = J^{-\\top}(1,0,0)^\\top = (1/\\epsilon, 0, 0)^\\top$。\n-   当 $\\kappa=1$ 时，单元刚度矩阵为 $K_e = \\frac{\\epsilon}{6} G_e^\\top G_e$，其计算结果为：\n$$ K = K_e = \\begin{pmatrix} \\frac{1}{6\\epsilon} + \\frac{\\epsilon}{3}  -\\frac{1}{6\\epsilon}  -\\frac{\\epsilon}{6}  -\\frac{\\epsilon}{6} \\\\ -\\frac{1}{6\\epsilon}  \\frac{1}{6\\epsilon}  0  0 \\\\ -\\frac{\\epsilon}{6}  0  \\frac{\\epsilon}{6}  0 \\\\ -\\frac{\\epsilon}{6}  0  0  \\frac{\\epsilon}{6} \\end{pmatrix} $$\n-   Frobenius 范数的平方是 $\\|K\\|_F^2 = \\sum_{i,j} K_{ij}^2 = \\frac{1}{9\\epsilon^2} + \\frac{1}{9} + \\frac{2\\epsilon^2}{9} = \\frac{1}{9}(\\frac{1}{\\epsilon^2} + 1 + 2\\epsilon^2)$。\n-   对于 $\\epsilon=10^{-6}$，$\\|K\\|_F = \\frac{1}{3}\\sqrt{10^{12} + 1 + 2 \\times 10^{-12}} \\approx 10^6/3$。\n-   与情况 A 一样，所有节点都是 Dirichlet 边界节点，因此 $F$ 为空，误差为 $0$。\n-   结果：$\\|K\\|_F \\approx 333333.3333$，误差 $= 0.0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef process_case(nodes, elements, kappas, dirichlet_nodes):\n    \"\"\"\n    Assembles the global stiffness matrix and solves the FEM system for a given case.\n\n    Args:\n        nodes (list of tuples): Coordinates of the mesh nodes.\n        elements (list of lists): Connectivity of the mesh elements (tetrahedra).\n        kappas (list of floats): Diffusion coefficient for each element.\n        dirichlet_nodes (set): Set of global indices for nodes with Dirichlet BCs.\n\n    Returns:\n        tuple: A tuple containing (Frobenius norm of K, max absolute error at free nodes).\n    \"\"\"\n    num_nodes = len(nodes)\n    K = np.zeros((num_nodes, num_nodes))\n    node_coords = np.array(nodes)\n\n    # Gradients of the basis functions on the reference tetrahedron\n    grad_N_hat = np.array([\n        [-1, 1, 0, 0],\n        [-1, 0, 1, 0],\n        [-1, 0, 0, 1]\n    ])\n\n    for i, conn in enumerate(elements):\n        # Get element properties\n        kappa_e = kappas[i]\n        \n        # Get coordinates of the element's nodes\n        x0, x1, x2, x3 = node_coords[conn]\n\n        # Form the Jacobian matrix\n        # Note: The problem statement has an unconventional Jacobian definition.\n        # Standard FEM uses J = [x1-x0, x2-x0, x3-x0].T for mapping gradients.\n        # The problem states J = [x1-x0, x2-x0, x3-x0].\n        # Let's follow the problem's definition for consistency.\n        # It seems the problem has an error in its definition, as the mapping from\n        # reference coordinates (^) to physical coordinates (x) is x = F(x_hat) = x0 + B * x_hat,\n        # where B = [x1-x0, x2-x0, x3-x0].\n        # The Jacobian of this mapping is J_F = B.\n        # The transformation of gradients is grad(N) = (J_F^-1).T * grad_hat(N) = (B^-1).T * grad_hat(N).\n        # The problem statement defines J = B, so J_inv_T = (J^-1).T. This is consistent.\n        # Let's check the volume formula. Standard is |det(B)|/6. Problem uses |det(J)|/6.\n        # So we can follow the problem as stated.\n        J = np.array([x1 - x0, x2 - x0, x3 - x0]).T\n\n        if np.linalg.det(J) == 0:\n            # Handle degenerate element if necessary, though not expected in tests\n            continue\n\n        # Compute volume and inverse transpose of Jacobian\n        volume = np.abs(np.linalg.det(J)) / 6.0\n        J_inv_T = np.linalg.inv(J).T\n        \n        # Compute gradients of physical basis functions\n        # The problem states grad(N_i) = J_inv_T * grad_hat(N_i)\n        # However, the reference gradients provided seem to be the columns of grad_hat matrix\n        # grad_hat_N1 = [-1,-1,-1], grad_hat_N2 = [1,0,0], etc.\n        # My grad_N_hat is transposed wrt this convention. Let's fix.\n        grad_N_hat_cols = np.array([\n            [-1, -1, -1],\n            [1, 0, 0],\n            [0, 1, 0],\n            [0, 0, 1]\n        ]).T\n        \n        grad_N_phys = J_inv_T @ grad_N_hat_cols\n\n        # Compute element stiffness matrix\n        # Ke_ij = kappa * volume * (grad_N_phys_i . grad_N_phys_j)\n        Ke = kappa_e * volume * (grad_N_phys.T @ grad_N_phys)\n\n        # Assemble Ke into the global stiffness matrix K\n        for r_local in range(4):\n            r_global = conn[r_local]\n            for c_local in range(4):\n                c_global = conn[c_local]\n                K[r_global, c_global] += Ke[r_local, c_local]\n    \n    # --- 1. Compute Frobenius norm ---\n    frobenius_norm = np.linalg.norm(K, 'fro')\n\n    # --- 2. Compute solution and error ---\n    all_nodes = set(range(num_nodes))\n    free_nodes = sorted(list(all_nodes - dirichlet_nodes))\n    \n    if not free_nodes:\n        error = 0.0\n    else:\n        # Define the exact solution function\n        def u_star(coord):\n            return sum(coord)\n\n        # Partition the system\n        G = sorted(list(dirichlet_nodes))\n        \n        K_FF = K[np.ix_(free_nodes, free_nodes)]\n        K_FG = K[np.ix_(free_nodes, G)]\n\n        # Get prescribed boundary values from exact solution\n        u_G = np.array([u_star(node_coords[i]) for i in G])\n        \n        # The source term f is zero, so the load vector b is zero\n        # The right-hand side for the reduced system comes from boundary values\n        rhs = -K_FG @ u_G\n        \n        # Solve for the interior nodes\n        u_F = np.linalg.solve(K_FF, rhs)\n\n        # Compute error\n        u_star_F = np.array([u_star(node_coords[i]) for i in free_nodes])\n        error = np.max(np.abs(u_F - u_star_F))\n\n    return frobenius_norm, error\n\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the FEM stiffness matrix assembly problem.\n    \"\"\"\n    # Note on connectivity: The problem statement uses 1-based indexing for Jacobian, but 0-based for node lists.\n    # The reference tetrahedron is (0,0,0), (1,0,0), (0,1,0), (0,0,1).\n    # The Jacobian is defined using x1, x2, x3, x4 relative to x1.\n    # This implies a local indexing {1, 2, 3, 4}.\n    # The code follows standard FEM practice where local nodes are {0,1,2,3} and maps them\n    # to the global connectivity list. The Jacobian is formed from the global coordinates\n    # corresponding to these local nodes.\n    # Jacobian is J = [x_g1-x_g0, x_g2-x_g0, x_g3-x_g0].T for a connectivity [g0,g1,g2,g3].\n    # This is the standard definition and matches the problem's intent.\n    \n    test_cases = [\n        # Case A: single tetrahedron\n        {\n            \"nodes\": [(0,0,0), (1,0,0), (0,1,0), (0,0,1)],\n            \"elements\": [[0,1,2,3]],\n            \"kappas\": [2.0],\n            \"dirichlet_nodes\": {0,1,2,3}\n        },\n        # Case B: a tetrahedron subdivided by one interior node\n        {\n            \"nodes\": [(0,0,0), (1,0,0), (0,1,0), (0,0,1), (0.25,0.25,0.25)],\n            \"elements\": [\n                [4,1,2,3], [4,0,2,3], [4,0,1,3], [4,0,1,2]\n            ],\n            \"kappas\": [1.0, 1.0, 1.0, 1.0],\n            \"dirichlet_nodes\": {0,1,2,3}\n        },\n        # Case C: a near-degenerate sliver tetrahedron\n        {\n            \"nodes\": [(0,0,0), (1e-6,0,0), (0,1,0), (0,0,1)],\n            \"elements\": [[0,1,2,3]],\n            \"kappas\": [1.0],\n            \"dirichlet_nodes\": {0,1,2,3}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        norm, err = process_case(**case)\n        results.append(norm)\n        results.append(err)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3206634"}]}