{"hands_on_practices": [{"introduction": "在科学计算中，编写代码只是第一步；验证其正确性至关重要。本练习将介绍“人造解方法” (Method of Manufactured Solutions)，这是一种通过构造具有已知精确解的问题来严格测试代码正确性和收敛阶的黄金标准。通过这个实践[@problem_id:3228560]，你将学会如何系统地验证你的非线性边界值问题求解器，确保其计算结果的可靠性。", "problem": "您将在一维域上实现一个用于非线性边值问题 (BVP) 的人造解法，以验证一个使用牛顿法求解非线性系统的有限差分解算器的正确性和经验收敛阶。控制方程为区间 $[0,1]$ 上的二阶常微分方程：\n$$\nu''(x) + g(u(x)) = f(x), \\quad x \\in (0,1),\n$$\n附带狄利克雷边界条件\n$$\nu(0) = \\beta_0, \\quad u(1) = \\beta_1.\n$$\n所有三角函数必须使用弧度制角度。本问题不涉及物理单位。计算方法的基础必须从以下经过充分检验的事实出发：(i) 中心有限差分在均匀网格上提供了导数的近似，(ii) 牛顿法通过迭代地线性化残差来求解非线性代数系统，以及 (iii) 人造解法通过将一个精确的光滑函数代入微分方程并计算左侧项，来构造一个一致的右侧项 $f(x)$。\n\n您将通过选择一个光滑精确解 $u_{\\text{exact}}(x)$ 和一个非线性函数 $g(u)$ 来设计三个人造测试用例，然后定义强迫项 $f(x)$，使得 $u_{\\text{exact}}$ 精确满足方程。您的解算器除了设置狄利克雷边界值外，不得使用关于 $u_{\\text{exact}}(x)$ 的任何知识；它必须通过在具有 $N$ 个节点的均匀网格上求解离散化后的非线性系统来计算近似数值解 $u_{\\text{num}}(x)$。对于每个测试用例，计算最大范数误差\n$$\nE(N) = \\max_{0 \\le i \\le N-1} \\left| u_{\\text{num}}(x_i) - u_{\\text{exact}}(x_i) \\right|,\n$$\n其中 $x_i$ 是网格节点。在一系列加密的网格 $N \\in \\{33, 65, 129, 257\\}$ 上评估 $E(N)$，然后使用最后两次加密的结果报告观测到的收敛阶：\n$$\np = \\frac{\\log\\!\\left(E(N_3)/E(N_4)\\right)}{\\log\\!\\left(h_3/h_4\\right)},\n$$\n其中 $N_3 = 129$，$N_4 = 257$，$h_k = 1/(N_k-1)$，且 $\\log$ 表示自然对数。\n\n实现以下人造解的测试套件：\n\n- 测试用例 1（正常路径，非零狄利克雷边界）：\n  - 精确解 $u_{\\text{exact}}(x) = 1 + 0.1 \\sin(2\\pi x)$。\n  - 非线性项 $g(u) = u^3$。\n  - 定义 $f(x) = u_{\\text{exact}}''(x) + \\big(u_{\\text{exact}}(x)\\big)^3$。\n  - 边界值 $\\beta_0 = u_{\\text{exact}}(0)$ 和 $\\beta_1 = u_{\\text{exact}}(1)$。\n\n- 测试用例 2（带有指数项的非线性，零狄利克雷边界）：\n  - 精确解 $u_{\\text{exact}}(x) = 0.1 \\sin(3\\pi x)$。\n  - 非线性项 $g(u) = e^{u} - 1$。\n  - 定义 $f(x) = u_{\\text{exact}}''(x) + e^{u_{\\text{exact}}(x)} - 1$。\n  - 边界值 $\\beta_0 = u_{\\text{exact}}(0)$ 和 $\\beta_1 = u_{\\text{exact}}(1)$。\n\n- 测试用例 3（更强的光滑非线性，零狄利克雷边界）：\n  - 精确解 $u_{\\text{exact}}(x) = 0.15 \\sin(\\pi x) + 0.05 \\sin(4\\pi x)$。\n  - 非线性项 $g(u) = \\alpha \\sin(u)$，其中 $\\alpha = 2.5$。\n  - 定义 $f(x) = u_{\\text{exact}}''(x) + \\alpha \\sin\\!\\big(u_{\\text{exact}}(x)\\big)$。\n  - 边界值 $\\beta_0 = u_{\\text{exact}}(0)$ 和 $\\beta_1 = u_{\\text{exact}}(1)$。\n\n算法要求：\n\n- 在 $[0,1]$ 上使用具有 $N$ 个节点和间距 $h = 1/(N-1)$ 的均匀网格。\n- 使用中心差分近似来离散化二阶导数。\n- 通过组合离散二阶导数、在节点上求值的 $g(u)$ 和强迫项 $f(x)$ 来形成内部节点的非线性残差。\n- 使用牛顿法求解得到的非线性系统。使用导数 $g'(u)$ 和来自二阶导数的三对角模板来构建雅可比矩阵。\n- 用一个简单的猜测（例如，边界值之间的线性插值或零）来初始化内部未知数，并进行迭代，直到残差的无穷范数低于一个小的容差。\n\n输出规格：\n\n- 对于三个测试用例中的每一个，如上所述使用 $N \\in \\{33, 65, 129, 257\\}$ 计算观测到的收敛阶 $p$。\n- 您的程序应产生单行输出，其中包含三个观测到的收敛阶，形式为用方括号括起来的逗号分隔列表（例如，$[p_1,p_2,p_3]$）。条目必须是浮点数。\n\n您的实现必须是一个现代编程语言的完整、可运行的程序，并且不得要求任何用户输入。所有三角函数计算必须使用弧度制角度。", "solution": "用户提供了一个数值分析领域的适定问题，要求我使用人造解法来验证一个用于非线性边值问题 (BVP) 的有限差分解算器。该问题有科学依据，形式化指定，且内部一致。我现在将进行详细的解答。\n\n### 1. 问题公式化与离散化\n\n控制非线性二阶常微分方程 (ODE) 定义在域 $x \\in [0,1]$ 上：\n$$\nu''(x) + g(u(x)) = f(x)\n$$\n满足狄利克雷边界条件：\n$$\nu(0) = \\beta_0, \\quad u(1) = \\beta_1\n$$\n为了数值求解此 BVP，我们将连续域 $[0,1]$ 离散化为一个具有 $N$ 个节点的均匀网格。网格点表示为 $x_i = i h$，其中 $i=0, 1, \\dots, N-1$，网格间距为 $h = 1/(N-1)$。设 $u_i$ 为每个网格节点上精确解 $u(x_i)$ 的数值近似。边界上的值是已知的：$u_0 = \\beta_0$ 和 $u_{N-1} = \\beta_1$。剩下的 $N-2$ 个内部值 $u_1, u_2, \\dots, u_{N-2}$ 是待确定的未知数。\n\n在内部节点 $x_i$ (其中 $1 \\le i \\le N-2$) 处的二阶导数 $u''(x)$ 使用二阶精度的中心有限差分公式进行近似：\n$$\nu''(x_i) \\approx \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2}\n$$\n将此近似代入 ODE，得到一个关于内部未知数的包含 $N-2$ 个耦合非线性代数方程的方程组：\n$$\n\\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} + g(u_i) = f(x_i), \\quad \\text{for } i = 1, 2, \\dots, N-2.\n$$\n这些方程与给定的边界值一起构成了离散问题。\n\n### 2. 求解非线性系统的牛顿法\n\n该离散方程组可以写成求根问题的形式。令 $\\mathbf{U} = [u_1, u_2, \\dots, u_{N-2}]^T$ 为 $M = N-2$ 个内部未知数组成的向量。我们定义一个大小为 $M$ 的残差向量函数 $\\mathbf{R}(\\mathbf{U})$，其分量 $R_i$ 对应于第 $i$ 个内部网格点（向量分量使用索引 $i=1, \\dots, M$，对应于网格索引 $i, \\dots, i+M-1$）。为了与编程中的数组索引保持一致，我们使用 $j = 0, \\dots, M-1$ 作为向量索引，其中 $u_j^{\\text{vec}} = u_{j+1}^{\\text{grid}}$。残差的第 $j$ 个分量是：\n$$\nR_j(\\mathbf{U}) = \\frac{u_{j} - 2u_{j+1} + u_{j+2}}{h^2} + g(u_{j+1}) - f(x_{j+1}), \\quad \\text{for } j = 0, \\dots, M-1.\n$$\n在此表示法中，$u_0$ 和 $u_{N-1}$ 是已知的边界值 $\\beta_0$ 和 $\\beta_1$。问题是找到向量 $\\mathbf{U}$ 使得 $\\mathbf{R}(\\mathbf{U}) = \\mathbf{0}$。\n\n我们使用牛顿法来求解这个非线性系统。从一个初始猜测 $\\mathbf{U}^{(0)}$ 开始，该方法使用以下更新规则迭代地改进解：\n$$\n\\mathbf{U}^{(k+1)} = \\mathbf{U}^{(k)} + \\Delta \\mathbf{U}^{(k)}\n$$\n其中更新向量 $\\Delta \\mathbf{U}^{(k)}$ 是以下线性系统的解：\n$$\nJ(\\mathbf{U}^{(k)}) \\Delta \\mathbf{U}^{(k)} = -\\mathbf{R}(\\mathbf{U}^{(k)})\n$$\n这里，$J(\\mathbf{U}^{(k)})$ 是在当前迭代值 $\\mathbf{U}^{(k)}$ 处求值的残差函数 $\\mathbf{R}$ 的雅可比矩阵。迭代持续进行，直到残差的范数 $\\|\\mathbf{R}(\\mathbf{U}^{(k)})\\|_{\\infty}$ 小于指定的容差。\n\n### 3. 雅可比矩阵的推导\n\n雅可比矩阵 $J$ 是一个 $M \\times M$ 矩阵，其元素为 $J_{ij} = \\frac{\\partial R_i}{\\partial U_j}$，其中 $R_i$ 是残差向量的第 $i$ 个分量，$U_j$ 是未知向量 $\\mathbf{U}$ 的第 $j$ 个分量（对应于网格未知数 $u_{i+1}$ 和 $u_{j+1}$）。第 $i$ 个残差方程（对于网格点 $i$，$1 \\le i \\le N-2$）是：\n$$\nR_i(u_1, \\dots, u_{N-2}) = \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} + g(u_i) - f_i\n$$\n关于未知数 $u_j$ 的偏导数仅在 $j$ 为 $i-1$、$i$ 或 $i+1$ 时非零。\n- 对角线元素 ($j=i$):\n  $$\n  \\frac{\\partial R_i}{\\partial u_i} = -\\frac{2}{h^2} + g'(u_i)\n  $$\n- 次对角线元素 ($j=i-1$，对于 $i>1$):\n  $$\n  \\frac{\\partial R_i}{\\partial u_{i-1}} = \\frac{1}{h^2}\n  $$\n- 超对角线元素 ($j=i+1$，对于 $i<N-2$):\n  $$\n  \\frac{\\partial R_i}{\\partial u_{i+1}} = \\frac{1}{h^2}\n  $$\n所有其他偏导数均为零。这使得雅可比矩阵成为一个三对角矩阵，从而可以使用一种高效的线性求解器（例如 Thomas 算法）在 $O(M)$ 时间内求解 Newton 更新步骤。\n\n### 4. 收敛阶的计算\n\n该方法使用中心差分对二阶导数进行近似，其截断误差为 $O(h^2)$。因此，预计解的全局误差 $E(N)$ 会表现出二阶收敛性，即 $E(N) \\approx C h^2$，其中 $C$ 是一个常数，$h = 1/(N-1)$。收敛阶 $p$ 可以通过在两个不同网格尺寸 $h_1$ 和 $h_2$ 上计算的误差 $E_1$ 和 $E_2$ 来经验性地估计：\n$$\np = \\frac{\\log(E_1/E_2)}{\\log(h_1/h_2)}\n$$\n如果 $h_2 = h_1/2$，则该公式简化为 $p = \\log_2(E_1/E_2)$。对于 $p=2$，我们期望每次将网格间距减半时，误差会减少四倍。\n\n### 5. 实现策略\n\nPython 脚本将实现以下功能：\n1.  一个主函数，遍历所有三个测试用例。\n2.  对于每个测试用例，它将遍历指定的 $N$ 值。\n3.  一个核心求解器函数 `solve_bvp_newton`，它接收网格大小 $N$、精确解和非线性函数的规范。\n4.  在求解器内部：\n    a.  设置网格、边界条件和根据人造解构造的强迫项 $f(x)$。\n    b.  使用线性插值作为内部未知数的初始猜测。\n    c.  执行牛顿法迭代循环。在每次迭代中，构建残差向量和三对角雅可比矩阵。\n    d.  使用 `numpy.linalg.solve` 求解线性系统以获得更新步长（对于三对角系统，这是一个可接受的选择，尽管专门的 Thomas 算法会更高效）。\n    e.  更新解并检查收敛性。\n5.  求解器返回数值解和精确解之间的最大范数误差。\n6.  收集一系列 $N$ 值的误差后，使用最后两次加密的结果计算观测到的收敛阶。\n7.  将所有三个测试用例的收敛阶收集起来，并以指定的格式打印。所有三角函数将使用 `numpy` 函数，这些函数默认使用弧度。\n\n这个实现将严格遵循问题陈述中的算法要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_bvp_newton(N, u_exact, u_pp_exact, g, g_prime, tol=1e-12, max_iter=50):\n    \"\"\"\n    Solves the nonlinear BVP u'' + g(u) = f using a finite difference\n    method with Newton's method for the resulting nonlinear system.\n\n    Args:\n        N (int): Number of grid points.\n        u_exact (callable): The exact solution function u(x).\n        u_pp_exact (callable): The second derivative of the exact solution u''(x).\n        g (callable): The nonlinear function g(u).\n        g_prime (callable): The derivative of the nonlinear function g'(u).\n        tol (float): Tolerance for Newton's method convergence.\n        max_iter (int): Maximum number of Newton iterations.\n\n    Returns:\n        float: The maximum norm error between the numerical and exact solutions.\n    \"\"\"\n    # 1. Grid and problem setup\n    h = 1.0 / (N - 1)\n    x = np.linspace(0, 1, N)\n    \n    # Boundary conditions from the exact solution\n    beta0 = u_exact(x[0])\n    beta1 = u_exact(x[-1])\n    \n    # Forcing function f(x) is manufactured from the exact solution\n    f_vals = u_pp_exact(x) + g(u_exact(x))\n    \n    # Interior grid points and corresponding forcing function values\n    x_int = x[1:-1]\n    f_int = f_vals[1:-1]\n    M = N - 2\n    \n    if M == 0:\n        # Trivial case with no interior points\n        u_num = np.array([beta0, beta1]) if N == 2 else np.array([beta0])\n        u_ex_vals = u_exact(x)\n        return np.linalg.norm(u_num - u_ex_vals, np.inf)\n\n    # 2. Initial guess for interior unknowns\n    # Use linear interpolation between boundary values\n    u_int = beta0 + (beta1 - beta0) * x_int\n    \n    # 3. Newton's method iterations\n    h_sq = h * h\n    \n    for k in range(max_iter):\n        # Build residual vector R\n        R = np.zeros(M)\n        \n        # First interior point (i=1)\n        R[0] = (beta0 - 2 * u_int[0] + u_int[1]) / h_sq + g(u_int[0]) - f_int[0]\n        \n        # Central interior points (1  i  N-2)\n        if M  2:\n            R[1:-1] = (u_int[:-2] - 2 * u_int[1:-1] + u_int[2:]) / h_sq + g(u_int[1:-1]) - f_int[1:-1]\n\n        # Last interior point (i=N-2)\n        if M  1:\n            R[-1] = (u_int[-2] - 2 * u_int[-1] + beta1) / h_sq + g(u_int[-1]) - f_int[-1]\n\n        residual_norm = np.linalg.norm(R, np.inf)\n        if residual_norm  tol:\n            break\n            \n        # Build Jacobian matrix J (tridiagonal)\n        diag = -2.0 / h_sq + g_prime(u_int)\n        sup_diag = np.ones(M - 1) / h_sq\n        sub_diag = np.ones(M - 1) / h_sq\n        \n        J = np.diag(diag) + np.diag(sup_diag, k=1) + np.diag(sub_diag, k=-1)\n        \n        # Solve the linear system J * delta_u = -R\n        delta_u = np.linalg.solve(J, -R)\n        \n        # Update solution for interior points\n        u_int += delta_u\n        \n    # 4. Construct full numerical solution and compute error\n    u_num = np.concatenate(([beta0], u_int, [beta1]))\n    u_ex_vals = u_exact(x)\n    error = np.linalg.norm(u_num - u_ex_vals, np.inf)\n    \n    return error\n\ndef solve():\n    \"\"\"\n    Main function to run the verification for all test cases and print the results.\n    \"\"\"\n    pi = np.pi\n    alpha = 2.5\n\n    test_cases = [\n        {\n            \"name\": \"Case 1\",\n            \"u_exact\": lambda x: 1 + 0.1 * np.sin(2 * pi * x),\n            \"u_pp_exact\": lambda x: -0.1 * (2*pi)**2 * np.sin(2 * pi * x),\n            \"g\": lambda u: u**3,\n            \"g_prime\": lambda u: 3 * u**2\n        },\n        {\n            \"name\": \"Case 2\",\n            \"u_exact\": lambda x: 0.1 * np.sin(3 * pi * x),\n            \"u_pp_exact\": lambda x: -0.1 * (3*pi)**2 * np.sin(3 * pi * x),\n            \"g\": lambda u: np.exp(u) - 1.0,\n            \"g_prime\": lambda u: np.exp(u)\n        },\n        {\n            \"name\": \"Case 3\",\n            \"u_exact\": lambda x: 0.15 * np.sin(pi * x) + 0.05 * np.sin(4 * pi * x),\n            \"u_pp_exact\": lambda x: -0.15 * pi**2 * np.sin(pi * x) - 0.05 * (4*pi)**2 * np.sin(4 * pi * x),\n            \"g\": lambda u: alpha * np.sin(u),\n            \"g_prime\": lambda u: alpha * np.cos(u)\n        }\n    ]\n    \n    N_values = [33, 65, 129, 257]\n    observed_orders = []\n\n    for case in test_cases:\n        errors = []\n        for N in N_values:\n            error = solve_bvp_newton(N, \n                                     case[\"u_exact\"], \n                                     case[\"u_pp_exact\"], \n                                     case[\"g\"], \n                                     case[\"g_prime\"])\n            errors.append(error)\n        \n        # Compute the observed order of accuracy 'p' using the last two refinements\n        # p = log(E_3/E_4) / log(h_3/h_4)\n        E3 = errors[2]  # Error for N=129\n        E4 = errors[3]  # Error for N=257\n        N3 = N_values[2]\n        N4 = N_values[3]\n        h3 = 1.0 / (N3 - 1)\n        h4 = 1.0 / (N4 - 1)\n        \n        # Note: log(h3/h4) = log((1/128)/(1/256)) = log(2)\n        p = np.log(E3 / E4) / np.log(h3 / h4)\n        observed_orders.append(p)\n        \n    print(f\"[{','.join(map(str, observed_orders))}]\")\n\nsolve()\n\n```", "id": "3228560"}, {"introduction": "在掌握了求解器的验证方法之后，我们现在将其应用于一个源于物理学的更复杂的非线性问题。许多物理过程（如依赖于温度的热传导）的扩散系数本身就是解的函数，本练习[@problem_id:3228466]将指导你如何使用基于“通量”的保守格式来离散化这类问题。这种方法不仅能求解方程，而且能更好地保证物理量的守恒，是计算物理中的一项核心技能。", "problem": "考虑由下式给出的非线性二阶常微分方程（ODE）边值问题（BVP）：\n$$\\frac{d}{dx}\\Big((1+u(x)^2)\\,u'(x)\\Big) = \\sin(x), \\quad x \\in [a,b],$$\n附带狄利克雷（Dirichlet）边界条件\n$$u(a) = \\alpha,\\qquad u(b) = \\beta.$$\n强迫函数 $\\sin(x)$ 中的角度必须以弧度为单位进行解释。\n\n你的任务是基于以下第一性原理基础，构建一个二阶精度的有限差分方法，并实现一个稳健的非线性求解器：\n- 从守恒形式出发，引入通量 $q(x) = (1+u(x)^2)\\,u'(x)$，从而得到 $q'(x) = \\sin(x)$。\n- 使用均匀网格，节点为 $x_i = a + i h$（$i=0,1,\\dots,N$），网格宽度为 $h = (b-a)/N$。\n- 使用半节点通量的中心差分来近似内部节点处的通量散度，并使用相邻节点值的算术平均值来计算半节点处依赖于 $u$ 的系数。\n- 在端点节点直接施加狄利克雷（Dirichlet）边界条件。\n- 对内部未知数，集成得到的非线性残差方程组，并使用针对非线性方程组的 Newton 方法求解，其雅可比（Jacobian）矩阵基于半节点处通量的线性化解析推导得出。\n- 在 Newton 方法中使用保证残差下降的线搜索全局化策略。\n\n从导数和通量平衡的基本定义出发，逐步设计你的方法。除这些定义外，不要使用任何预先封装的离散化公式。当内部节点上的非线性残差范数低于用户选择的容差或达到最大 Newton 迭代次数时，实现必须终止。\n\n测试套件和要求输出：\n- 实现一个程序，对下面的每一组参数求解该 BVP。对于每种情况，报告在指定的网格对齐位置 $x^\\star$ 处 $u(x^\\star)$ 的数值近似解。\n- 在每种情况下，网格大小 $N$ 的选择都使得 $x^\\star$ 与一个网格节点重合（即，对于某个整数 $i^\\star$，$x^\\star = a + i^\\star h$）。你的代码应使用 $a$、$h$ 和 $x^\\star$ 通过算术运算确定相应的节点索引。\n\n提供以下四种情况的结果：\n- 情况 1（理想路径）：\n  - $a = 0$, $b = 1$, $\\alpha = 0$, $\\beta = 0$, $N = 100$, $x^\\star = 0.5$。\n- 情况 2（不同定义域长度，对称边界）：\n  - $a = 0$, $b = \\pi$, $\\alpha = 0$, $\\beta = 0$, $N = 200$, $x^\\star = \\pi/2$。\n- 情况 3（非零狄利克雷数据）：\n  - $a = 0$, $b = 1$, $\\alpha = 1$, $\\beta = -1$, $N = 120$, $x^\\star = 0.25$。\n- 情况 4（包含原点的平移定义域）：\n  - $a = -1$, $b = 2$, $\\alpha = 0$, $\\beta = 0$, $N = 150$, $x^\\star = 0$。\n\n最终输出格式：\n- 你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述情况的顺序排列，例如 $[r_1,r_2,r_3,r_4]$。\n- 每个条目必须是该情况下计算出的 $u(x^\\star)$ 的浮点数，并精确到小数点后六位。\n- 不应打印额外的空格或文本。\n\n角度单位要求：\n- 所有 $\\sin(x)$ 的计算都必须使用以弧度表示的 $x$。\n\n你的解决方案必须是完全自包含的，并且不得读取任何输入。它必须能够在现代编程环境中直接编译和运行。", "solution": "用户提供的问题是一个非线性二阶常微分方程（ODE），被表述为一个边值问题（BVP）。\n\n### 第 1 步：提取已知条件\n- **控制方程**：$\\frac{d}{dx}\\Big((1+u(x)^2)\\,u'(x)\\Big) = \\sin(x)$，$x \\in [a,b]$。\n- **边界条件**：$u(a) = \\alpha$，$u(b) = \\beta$。\n- **离散网格**：均匀网格 $x_i = a + i h$，$i=0,1,\\dots,N$，网格宽度 $h = (b-a)/N$。\n- **离散化方法**：\n    - ODE以守恒形式 $q'(x) = \\sin(x)$ 给出，其中通量为 $q(x) = (1+u(x)^2)u'(x)$。\n    - 在内部节点 $x_i$ 处，$q'(x)$ 项通过在半节点处计算的通量的中心差分来近似：$q'(x_i) \\approx (q_{i+1/2} - q_{i-1/2})/h$。\n    - 通量 $q_{i+1/2}$ 通过对导数 $u'(x_{i+1/2})$ 使用中心差分以及对涉及 $u(x_{i+1/2})$ 的非线性系数项使用算术平均值来近似。\n- **非线性求解器**：Newton 方法，配合解析推导的雅可比矩阵和线搜索全局化策略。\n- **测试用例**：提供了四组特定的参数 $(a, b, \\alpha, \\beta, N, x^\\star)$ 用于测试。\n- **输出要求**：对于每种情况，报告数值解 $u(x^\\star)$ 的值，四舍五入到六位小数。\n\n### 第 2 步：使用提取的已知条件进行验证\n对问题进行了严格的验证检查。\n\n- **科学性（关键）**：该问题是一个标准的非线性泊松型方程，是物理和工程各个领域（例如，具有随温度变化的电导率的热传导，非线性扩散）中的常见模型。其表述在数学上和物理上都是合理的，没有违反任何科学原理。\n- **适定性**：该问题是二阶椭圆型 ODE 的狄利克雷（Dirichlet）BVP。其算子是单调的，这通常保证了解的存在性和唯一性。指定的离散化方法（一种以单元为中心的有限体积/差分方法）是标准的，并且已知是稳定和收敛的。因此，预期会得到一个有意义的解。\n- **客观性（关键）**：问题陈述是精确、定量的，没有任何主观或模棱两可的语言。所有参数、方程和方法都得到了明确的定义。\n- **完整性**：提供了所有必要的信息：ODE、边界条件、定义域、离散化策略、求解算法和具体的测试参数。问题是自包含的。\n- **一致性**：给定的条件内部是一致的。每个测试用例中参数的选择确保了 $x^\\star$ 落在网格节点上的要求。\n- **其他缺陷**：该问题不是隐喻性的、琐碎的或超出科学可验证范围的。\n\n### 第 3 步：结论与行动\n问题是**有效的**。将提供一个遵循所有指定约束的、分步推理的解决方案。\n\n### 求解推导\n\n求解过程包括将 BVP 离散化，形成一个非线性代数方程组，然后使用 Newton 方法求解该系统。\n\n**1. 有限差分离散化**\n控制 ODE 以守恒形式给出，$q'(x) = \\sin(x)$，其中通量定义为 $q(x) = D(u)u'(x)$，其中 $D(u) = 1+u(x)^2$。我们定义一个均匀网格 $x_i = a + i h$，$i=0, 1, \\dots, N$，其中 $h = (b-a)/N$。设 $U_i$ 是 $u(x_i)$ 的数值近似解。边界条件直接施加：$U_0 = \\alpha$ 和 $U_N = \\beta$。\n\n根据问题的指示，我们对每个内部网格节点 $x_i$（$i=1, 2, \\dots, N-1$）的通量散度进行离散化，使用一个涉及半节点 $x_{i\\pm1/2}$ 处通量的中心差分格式：\n$$\n\\frac{q_{i+1/2} - q_{i-1/2}}{h} = \\sin(x_i)\n$$\n此处，$q_{i+1/2}$ 是中点 $x_{i+1/2} = x_i + h/2$ 处通量的数值近似。该通量按如下方式离散化：\n- 导数 $u'(x_{i+1/2})$ 通过二阶中心差分来近似：\n$$ u'(x_{i+1/2}) \\approx \\frac{U_{i+1} - U_i}{h} $$\n- 非线性系数 $D(u(x_{i+1/2}))$ 使用相邻节点处解的算术平均值来计算：\n$$ D(u(x_{i+1/2})) \\approx 1 + \\left(\\frac{U_i + U_{i+1}}{2}\\right)^2 $$\n结合这些，半节点 $x_{i+1/2}$ 处的数值通量为：\n$$ q_{i+1/2} = \\left(1 + \\left(\\frac{U_i + U_{i+1}}{2}\\right)^2\\right) \\frac{U_{i+1} - U_i}{h} $$\n类似地，$x_{i-1/2}$ 处的通量为：\n$$ q_{i-1/2} = \\left(1 + \\left(\\frac{U_{i-1} + U_i}{2}\\right)^2\\right) \\frac{U_i - U_{i-1}}{h} $$\n\n**2. 非线性残差方程**\n将数值通量表达式代入离散化的守恒定律，得到一个关于 $N-1$ 个内部未知数 $\\{U_1, U_2, \\dots, U_{N-1}\\}$ 的 $N-1$ 个非线性方程组。对于每个内部节点 $i=1, \\dots, N-1$，我们定义一个残差函数 $F_i$：\n$$ F_i(\\vec{U}) = \\frac{1}{h^2} \\left[ \\left(1 + \\left(\\frac{U_i + U_{i+1}}{2}\\right)^2\\right) (U_{i+1} - U_i) - \\left(1 + \\left(\\frac{U_{i-1} + U_i}{2}\\right)^2\\right) (U_i - U_{i-1}) \\right] - \\sin(x_i) = 0 $$\n其中 $\\vec{U} = [U_1, U_2, \\dots, U_{N-1}]^T$。当 $i=1$ 时，$U_0$ 被替换为 $\\alpha$。当 $i=N-1$ 时，$U_N$ 被替换为 $\\beta$。我们的目标是找到向量 $\\vec{U}$，使得它解方程组 $\\vec{F}(\\vec{U}) = \\vec{0}$。\n\n**3. Newton 方法**\nNewton 方法是求解非线性方程组的一种迭代过程。从一个初始猜测 $\\vec{U}^{(0)}$ 开始，我们生成一系列收敛到解的近似值 $\\vec{U}^{(k)}$。每次迭代都涉及求解线性系统：\n$$ J(\\vec{U}^{(k)}) \\Delta\\vec{U}^{(k)} = -\\vec{F}(\\vec{U}^{(k)}) $$\n其中 $J(\\vec{U}^{(k)})$ 是在 $\\vec{U}^{(k)}$ 处计算的 $\\vec{F}$ 的雅可比矩阵，$\\Delta\\vec{U}^{(k)}$ 是更新步长。然后使用线搜索找到下一个迭代值：\n$$ \\vec{U}^{(k+1)} = \\vec{U}^{(k)} + \\lambda \\Delta\\vec{U}^{(k)} $$\n选择参数 $\\lambda \\in (0, 1]$ 以确保残差范数有足够的下降。\n\n**4. 雅可比矩阵推导**\n雅可比矩阵 $J$ 的元素为 $J_{ij} = \\frac{\\partial F_i}{\\partial U_j}$。由于残差 $F_i$ 只依赖于 $U_{i-1}$、$U_i$ 和 $U_{i+1}$，因此雅可比矩阵是一个三对角矩阵。\n为了简化推导，我们定义缩放后的数值通量项：\n$$ g(u_L, u_R) = \\left(1 + \\left(\\frac{u_L + u_R}{2}\\right)^2\\right) (u_R - u_L) $$\n残差方程（乘以 $h^2$）为 $h^2 F_i = g(U_i, U_{i+1}) - g(U_{i-1}, U_i) - h^2 \\sin(x_i)$。雅可比矩阵的元素是 $J_{ij} = \\frac{1}{h^2}\\frac{\\partial(h^2 F_i)}{\\partial U_j}$。所需的 $g$ 的偏导数为：\n$$ \\frac{\\partial g}{\\partial u_L} = -1 + \\frac{1}{4}(u_R + u_L)(u_R - 3u_L) = \\frac{1}{4}(u_R^2 - 2u_L u_R - 3u_L^2 - 4) $$\n$$ \\frac{\\partial g}{\\partial u_R} = 1 + \\frac{1}{4}(u_R + u_L)(3u_R - u_L) = \\frac{1}{4}(3u_R^2 + 2u_L u_R - u_L^2 + 4) $$\n雅可比矩阵第 $i$ 行的非零元素是：\n- **次对角线（$j = i-1$）：**\n$$ J_{i, i-1} = -\\frac{1}{h^2} \\frac{\\partial g}{\\partial u_L}(U_{i-1}, U_i) = -\\frac{1}{4h^2}(U_i^2 - 2U_{i-1}U_i - 3U_{i-1}^2 - 4) = \\frac{1}{4h^2}(4 - U_i^2 + 2U_{i-1}U_i + 3U_{i-1}^2) $$\n- **主对角线（$j = i$）：**\n$$ J_{i, i} = \\frac{1}{h^2} \\left[ \\frac{\\partial g}{\\partial u_L}(U_i, U_{i+1}) - \\frac{\\partial g}{\\partial u_R}(U_{i-1}, U_i) \\right] = \\frac{1}{4h^2} [ (U_{i+1}^2 - 2U_iU_{i+1} - 3U_i^2 - 4) - (3U_i^2 + 2U_{i-1}U_i - U_{i-1}^2 + 4) ] $$\n$$ J_{i, i} = \\frac{1}{4h^2} (U_{i+1}^2 + U_{i-1}^2 - 6U_i^2 - 2U_i(U_{i+1} + U_{i-1}) - 8) $$\n- **超对角线（$j = i+1$）：**\n$$ J_{i, i+1} = \\frac{1}{h^2} \\frac{\\partial g}{\\partial u_R}(U_i, U_{i+1}) = \\frac{1}{4h^2}(3U_{i+1}^2 + 2U_i U_{i+1} - U_i^2 + 4) $$\n这些表达式用于在每次 Newton 迭代中构建雅可比矩阵。\n\n**5. 线搜索算法**\n采用回溯线搜索来全局化 Newton 方法的收敛性。在计算出 Newton 步长 $\\Delta\\vec{U}^{(k)}$ 后，我们寻找一个阻尼因子 $\\lambda$。\n1.  从 $\\lambda = 1$ 开始。\n2.  计算候选的下一个迭代值 $\\vec{U}_{cand} = \\vec{U}^{(k)} + \\lambda \\Delta\\vec{U}^{(k)}$。\n3.  在候选点评估残差范数 $\\|\\vec{F}(\\vec{U}_{cand})\\|$。\n4.  如果 $\\|\\vec{F}(\\vec{U}_{cand})\\|  \\|\\vec{F}(\\vec{U}^{(k)})\\|$，则接受该步长并设置 $\\vec{U}^{(k+1)} = \\vec{U}_{cand}$。\n5.  否则，减小 $\\lambda$（例如，$\\lambda \\leftarrow \\lambda / 2$）并从第 2 步重复。如果 $\\lambda$ 变得小于预定义的最小值，则终止该过程，这表示未能找到合适的下降方向。\n\n这种二阶有限差分格式和稳健的 Newton-Krylov 求解器的组合为求解给定的非线性 BVP 提供了一种有效的方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the BVP for the specified test cases and print results.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1 (happy path)\n        {'a': 0, 'b': 1, 'alpha': 0, 'beta': 0, 'N': 100, 'x_star': 0.5},\n        # Case 2 (different domain length with symmetric bounds)\n        {'a': 0, 'b': np.pi, 'alpha': 0, 'beta': 0, 'N': 200, 'x_star': np.pi/2},\n        # Case 3 (nonzero Dirichlet data)\n        {'a': 0, 'b': 1, 'alpha': 1, 'beta': -1, 'N': 120, 'x_star': 0.25},\n        # Case 4 (shifted domain including the origin)\n        {'a': -1, 'b': 2, 'alpha': 0, 'beta': 0, 'N': 150, 'x_star': 0},\n    ]\n\n    results = []\n    for case in test_cases:\n        solution = solve_bvp(case['a'], case['b'], case['alpha'], case['beta'], case['N'])\n        \n        h = (case['b'] - case['a']) / case['N']\n        # Find index i_star such that x_star = a + i_star * h\n        # Use a small tolerance for floating point comparison\n        i_star = int(round((case['x_star'] - case['a']) / h))\n        \n        result_val = solution[i_star]\n        results.append(f\"{result_val:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\n\ndef solve_bvp(a, b, alpha, beta, N, tol=1e-9, max_iter=50):\n    \"\"\"\n    Solves the nonlinear BVP using Newton's method.\n    \"\"\"\n    h = (b - a) / N\n    x = np.linspace(a, b, N + 1)\n    \n    # Interior grid points and unknowns\n    x_int = x[1:-1]\n    num_unknowns = N - 1\n    \n    # Initial guess for interior nodes: linear interpolation\n    U_int = alpha + (beta - alpha) * (x_int - a) / (b - a)\n    \n    # --- Newton's Method Loop ---\n    for k in range(max_iter):\n        # Full solution vector including boundary conditions\n        U_full = np.concatenate(([alpha], U_int, [beta]))\n        \n        # --- 1. Assemble Residual Vector F ---\n        F = np.zeros(num_unknowns)\n        \n        # Flux term g(uL, uR)\n        def g_flux(uL, uR):\n            return (1 + ((uL + uR) / 2)**2) * (uR - uL)\n\n        for i in range(1, N): # Corresponds to F[i-1]\n            u_left = U_full[i-1]\n            u_mid = U_full[i]\n            u_right = U_full[i+1]\n            \n            q_iph = g_flux(u_mid, u_right) / h\n            q_imh = g_flux(u_left, u_mid) / h\n            \n            F[i-1] = (q_iph - q_imh) / h - np.sin(x[i])\n\n        # Check for convergence\n        res_norm = np.linalg.norm(F)\n        if res_norm  tol:\n            break\n            \n        # --- 2. Assemble Jacobian Matrix J ---\n        J = np.zeros((num_unknowns, num_unknowns))\n        h2 = h * h\n\n        # Partial derivatives of scaled flux g\n        def dg_duL(uL, uR):\n            return 0.25 * (uR**2 - 2*uL*uR - 3*uL**2 - 4)\n\n        def dg_duR(uL, uR):\n            return 0.25 * (3*uR**2 + 2*uL*uR - uL**2 + 4)\n\n        # Diagonal entries\n        for i in range(1, N): # Row i-1 of Jacobian\n            u_left = U_full[i-1]\n            u_mid = U_full[i]\n            u_right = U_full[i+1]\n            \n            diag_val = (dg_duL(u_mid, u_right) - dg_duR(u_left, u_mid)) / h2\n            J[i-1, i-1] = diag_val\n        \n        # Super-diagonal entries\n        for i in range(1, N-1): # Row i-1, Col i\n             J[i-1, i] = dg_duR(U_full[i], U_full[i+1]) / h2\n             \n        # Sub-diagonal entries\n        for i in range(2, N): # Row i-1, Col i-2\n            J[i-1, i-2] = -dg_duL(U_full[i-1], U_full[i]) / h2\n\n        # --- 3. Solve linear system for update step ---\n        delta_U = np.linalg.solve(J, -F)\n        \n        # --- 4. Line Search ---\n        lambda_val = 1.0\n        min_lambda = 1e-8\n        \n        while lambda_val > min_lambda:\n            U_new = U_int + lambda_val * delta_U\n            U_full_new = np.concatenate(([alpha], U_new, [beta]))\n            \n            F_new = np.zeros(num_unknowns)\n            for i in range(1, N):\n                u_left = U_full_new[i-1]\n                u_mid = U_full_new[i]\n                u_right = U_full_new[i+1]\n                q_iph = g_flux(u_mid, u_right) / h\n                q_imh = g_flux(u_left, u_mid) / h\n                F_new[i-1] = (q_iph - q_imh) / h - np.sin(x[i])\n            \n            if np.linalg.norm(F_new)  res_norm:\n                break\n            \n            lambda_val /= 2.0\n            \n        if lambda_val = min_lambda:\n             # If line search fails, maybe it already converged\n             if res_norm > tol:\n                 # In a real application, one might raise an error here.\n                 # For this problem, we assume convergence will be achieved.\n                 pass\n\n        U_int += lambda_val * delta_U\n\n    return np.concatenate(([alpha], U_int, [beta]))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3228466"}, {"introduction": "非线性方程与线性方程的一个根本区别在于其解可能不唯一。本练习以物理摆这样一个经典的非线性系统为例，展示如何通过提供不同的初始猜测来驱动牛顿法收敛到不同的稳定解[@problem_id:3228545]。这项实践揭示了初始条件在非线性问题求解中的关键作用，并将你的求解器从一个计算工具转变为一个探索复杂系统行为的强大实验平台。", "problem": "考虑在区间 $[0,L]$ 上的一个两点边值问题 (BVP)，该问题针对一个二次连续可微函数 $u(x)$，由非线性常微分方程 $u''(x)+\\sin(u(x))=0$ 以及 Dirichlet 边界条件 $u(0)=0$ 和 $u(L)=0$ 给出。任务是构建一个有限差分法和一个 Newton–Raphson 方法（牛顿法）来求解近似解，然后演示当 $L=2\\pi$ 时，不同的初始猜测如何导致不同的解，计算中使用弧度制角。您的解答必须从以下基本原理出发。\n\n1. 从二阶导数的定义开始，使用泰勒展开获得在具有 $N$ 个子区间和网格间距 $h=L/N$ 的均匀网格上对 $u''(x)$ 的二阶精度中心有限差分近似。将内部未知数的离散非线性系统组装成向量形式，其中每个内部方程是通过将 $u''(x)$ 替换为其中心有限差分近似，并将 $u(x)$ 替换为相应的网格值而形成的。精确使用边界条件 $u(0)=0$ 和 $u(L)=0$。\n\n2. 通过雅可比矩阵 $\\mathbf{J}(\\mathbf{u})$ 对 $\\mathbf{F}$ 进行线性化，为得到的非线性代数系统 $\\mathbf{F}(\\mathbf{u})=\\mathbf{0}$ 推导牛顿法，并在每次迭代中求解线性系统 $\\mathbf{J}(\\mathbf{u}^{(k)})\\Delta\\mathbf{u}^{(k)}=-\\mathbf{F}(\\mathbf{u}^{(k)})$ 来更新 $\\mathbf{u}^{(k+1)}=\\mathbf{u}^{(k)}+\\alpha^{(k)}\\Delta\\mathbf{u}^{(k)}$，其中 $\\alpha^{(k)}$ 是一个阻尼因子，选择该因子以确保残差的某个适当范数减小。使用链式法则和 $\\sin(\\cdot)$ 的导数来证明雅可比矩阵的形式。\n\n3. 将雅可比矩阵实现为一个三对角矩阵，该矩阵捕捉了中心差分的最近邻耦合以及在每次迭代中计算的 $\\sin(u)$ 的局部导数。解释如何高效地求解每次牛顿迭代中产生的三对角线性系统。\n\n4. 提供基于残差范数和/或牛顿步长范数的明确停止准则，以确保收敛到具有明确定义的数值容差的解。\n\n5. 所有三角函数求值均使用弧度制角。除了区间长度 $L$ 之外，此问题中没有量纲物理单位。\n\n您的程序必须普适性地实现上述方法，适用于任何 $L>0$ 和任何整数 $N \\ge 2$，然后运行以下测试套件。对于每个测试用例，应用牛顿法，并将指定的初始猜测函数 $u_0(x)$ 映射到网格上。收敛后，报告计算解的 $L^\\infty$-范数（在包括端点的离散网格上的最大绝对值），四舍五入到六位小数。\n\n测试套件（所有角度单位均为弧度）：\n- 用例 1（理想情况，长区间上的平凡解）：$L=2\\pi$，$N=400$，初始猜测 $u_0(x)\\equiv 0$。\n- 用例 2（理想情况，长区间上的正非平凡解）：$L=2\\pi$，$N=400$，初始猜测 $u_0(x)=2.5\\sin\\!\\big(\\pi x/L\\big)$。\n- 用例 3（对称性检查，长区间上的负非平凡解）：$L=2\\pi$，$N=400$，初始猜测 $u_0(x)=-2.5\\sin\\!\\big(\\pi x/L\\big)$。\n- 用例 4（边界情况，区间太短，无法容纳与小振幅周期一致的非平凡解）：$L=\\pi$，$N=400$，初始猜测 $u_0(x)=2.5\\sin\\!\\big(\\pi x/L\\big)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述用例的顺序列出结果，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是第 $i$ 个用例计算解的 $L^\\infty$-范数，四舍五入到六位小数（例如，$[0.000000,2.800000,2.800000,0.000000]$）。不要打印任何附加文本。", "solution": "经评估，用户提供的问题是**有效的**。这是一个适定的、有科学依据的数值分析问题，具体涉及使用有限差分法和牛顿法求解非线性两点边值问题。所有必要的数据、方程和条件都已提供，不存在内部矛盾、歧义或事实错误。\n\n### 1. 边值问题的离散化\n\n问题是求解非线性常微分方程 (ODE)\n$$\nu''(x) + \\sin(u(x)) = 0\n$$\n在区间 $x \\in [0, L]$ 上，其齐次 Dirichlet 边界条件为 $u(0)=0$ 和 $u(L)=0$。\n\n我们使用一个包含 $N$ 个子区间的均匀网格对定义域 $[0, L]$ 进行离散化。网格点为 $x_i = i h$，其中 $i = 0, 1, \\dots, N$，网格间距为 $h = L/N$。我们旨在寻找这些网格点上的近似值 $u_i \\approx u(x_i)$。边界条件给出 $u_0 = 0$ 和 $u_N = 0$。未知值为内部网格点 $u_1, u_2, \\dots, u_{N-1}$。我们将这些未知数的向量表示为 $\\mathbf{u} = [u_1, u_2, \\dots, u_{N-1}]^T \\in \\mathbb{R}^{N-1}$。\n\n为离散化二阶导数项 $u''(x)$，我们使用二阶精度中心有限差分近似。这可以从 $u(x)$ 在点 $x_i$ 附近的 Taylor 级数展开推导得出：\n$$\nu(x_i+h) = u(x_i) + h u'(x_i) + \\frac{h^2}{2} u''(x_i) + \\frac{h^3}{6} u'''(x_i) + O(h^4)\n$$\n$$\nu(x_i-h) = u(x_i) - h u'(x_i) + \\frac{h^2}{2} u''(x_i) - \\frac{h^3}{6} u'''(x_i) + O(h^4)\n$$\n将这两个展开式相加可以消去奇数阶导数项：\n$$\nu(x_i+h) + u(x_i-h) = 2u(x_i) + h^2 u''(x_i) + O(h^4)\n$$\n解出 $u''(x_i)$ 得到近似式：\n$$\nu''(x_i) = \\frac{u(x_i+h) - 2u(x_i) + u(x_i-h)}{h^2} + O(h^2)\n$$\n用我们的离散变量 $u_i$ 表示，即为 $u''(x_i) \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}$。\n\n通过在每个内部网格点 $x_i$ (其中 $i=1, \\dots, N-1$) 处，用它们的离散对应项替换常微分方程中的连续导数和函数，我们得到一个包含 $N-1$ 个非线性代数方程的系统：\n$$\n\\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} + \\sin(u_i) = 0, \\quad \\text{for } i = 1, 2, \\dots, N-1\n$$\n我们可以将此系统写成向量形式 $\\mathbf{F}(\\mathbf{u}) = \\mathbf{0}$，其中 $\\mathbf{F}: \\mathbb{R}^{N-1} \\to \\mathbb{R}^{N-1}$ 且其第 $i$ 个分量 $F_i(\\mathbf{u})$ 为：\n$$\nF_i(\\mathbf{u}) = \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} + \\sin(u_i)\n$$\n边界条件 $u_0=0$ 和 $u_N=0$ 被整合到系统的端点中。对于 $i=1$，方程为 $\\frac{u_2 - 2u_1 + u_0}{h^2} + \\sin(u_1) = 0$，变成 $\\frac{u_2 - 2u_1}{h^2} + \\sin(u_1) = 0$。对于 $i=N-1$，方程为 $\\frac{u_N - 2u_{N-1} + u_{N-2}}{h^2} + \\sin(u_{N-1}) = 0$，变成 $\\frac{-2u_{N-1} + u_{N-2}}{h^2} + \\sin(u_{N-1}) = 0$。\n\n### 2. 求解非线性系统的牛顿法\n\n牛顿法是用于寻找非线性方程组 $\\mathbf{F}(\\mathbf{u}) = \\mathbf{0}$ 根的迭代过程。从一个初始猜测 $\\mathbf{u}^{(0)}$ 开始，该方法生成一个理想情况下会收敛到解的近似序列 $\\mathbf{u}^{(k)}$。更新规则通过在当前迭代值 $\\mathbf{u}^{(k)}$ 附近对 $\\mathbf{F}(\\mathbf{u})$ 进行线性化得到：\n$$\n\\mathbf{F}(\\mathbf{u}) \\approx \\mathbf{F}(\\mathbf{u}^{(k)}) + \\mathbf{J}(\\mathbf{u}^{(k)})(\\mathbf{u} - \\mathbf{u}^{(k)})\n$$\n其中 $\\mathbf{J}(\\mathbf{u}^{(k)})$ 是 $\\mathbf{F}$ 在 $\\mathbf{u}^{(k)}$ 处求值的雅可比矩阵。设 $\\mathbf{F}(\\mathbf{u}) = \\mathbf{0}$ 以求得下一个迭代值 $\\mathbf{u}^{(k+1)}$，我们求解更新步长 $\\Delta\\mathbf{u}^{(k)} = \\mathbf{u}^{(k+1)} - \\mathbf{u}^{(k)}$：\n$$\n\\mathbf{J}(\\mathbf{u}^{(k)}) \\Delta\\mathbf{u}^{(k)} = -\\mathbf{F}(\\mathbf{u}^{(k)})\n$$\n然后下一个迭代值即为 $\\mathbf{u}^{(k+1)} = \\mathbf{u}^{(k)} + \\Delta\\mathbf{u}^{(k)}$。为了改善收敛性和稳健性，引入了一个阻尼因子（或步长）$\\alpha^{(k)} \\in (0, 1]$：\n$$\n\\mathbf{u}^{(k+1)} = \\mathbf{u}^{(k)} + \\alpha^{(k)} \\Delta\\mathbf{u}^{(k)}\n$$\n$\\alpha^{(k)}$ 的值通常使用线搜索算法来选择，以确保残差的范数在每一步都减小，例如 $\\|\\mathbf{F}(\\mathbf{u}^{(k+1)})\\|  \\|\\mathbf{F}(\\mathbf{u}^{(k)})\\|$。\n\n雅可比矩阵 $\\mathbf{J}$ 是一个 $(N-1) \\times (N-1)$ 的矩阵，其元素为 $J_{ij} = \\frac{\\partial F_i}{\\partial u_j}$。我们从 $F_i(\\mathbf{u})$ 的表达式计算这些偏导数：\n$$\nJ_{ij} = \\frac{\\partial}{\\partial u_j} \\left( \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} + \\sin(u_i) \\right)\n$$\n有限差分项的导数仅在 $j$ 为 $i-1$、$i$ 或 $i+1$ 时非零：\n- 对于 $j = i-1$： $J_{i,i-1} = \\frac{\\partial F_i}{\\partial u_{i-1}} = \\frac{1}{h^2}$\n- 对于 $j = i+1$： $J_{i,i+1} = \\frac{\\partial F_i}{\\partial u_{i+1}} = \\frac{1}{h^2}$\n非线性项 $\\sin(u_i)$ 的导数，根据链式法则，仅对对角线元素有贡献：$\\frac{\\partial}{\\partial u_j} \\sin(u_i) = \\cos(u_i) \\frac{\\partial u_i}{\\partial u_j} = \\cos(u_i) \\delta_{ij}$，其中 $\\delta_{ij}$ 是克罗内克 δ (Kronecker delta)。\n- 对于 $j = i$： $J_{ii} = \\frac{\\partial F_i}{\\partial u_i} = -\\frac{2}{h^2} + \\cos(u_i)$\n- 对于 $|i-j|  1$： $J_{ij} = 0$\n\n### 3. 三对角雅可比系统\n\n得到的雅可比矩阵是一个对称的三对角矩阵：\n$$\n\\mathbf{J}(\\mathbf{u}) = \\begin{pmatrix}\n-\\frac{2}{h^2}+\\cos(u_1)  \\frac{1}{h^2}  0  \\dots  0 \\\\\n\\frac{1}{h^2}  -\\frac{2}{h^2}+\\cos(u_2)  \\frac{1}{h^2}  \\dots  0 \\\\\n0  \\ddots  \\ddots  \\ddots  0 \\\\\n\\vdots    \\frac{1}{h^2}  -\\frac{2}{h^2}+\\cos(u_{N-2})  \\frac{1}{h^2} \\\\\n0  \\dots  0  \\frac{1}{h^2}  -\\frac{2}{h^2}+\\cos(u_{N-1})\n\\end{pmatrix}\n$$\n在牛顿法的每次迭代中，我们必须求解线性系统 $\\mathbf{J}(\\mathbf{u}^{(k)}) \\Delta\\mathbf{u}^{(k)} = -\\mathbf{F}(\\mathbf{u}^{(k)})$。由于 $\\mathbf{J}$ 是三对角的，这个系统可以使用 Thomas 算法（也称为三对角矩阵算法，TDMA）非常高效地求解。Thomas 算法是 Gaussian elimination 的一种特殊形式，其计算复杂度为 $O(N)$，这比处理一般稠密矩阵所需的 $O(N^3)$ 复杂度快得多。对于具有大量网格点 $N$ 的问题，这种效率至关重要。\n\n### 4. 停止准则\n\n当解收敛到期望的精度时，迭代过程终止。一个常用且稳健的停止准则是检查残差向量 $\\mathbf{F}(\\mathbf{u}^{(k)})$ 的范数。当残差的无穷范数（最大绝对分量）低于一个小容差 $\\epsilon$ 时，我们停止迭代：\n$$\n\\|\\mathbf{F}(\\mathbf{u}^{(k)})\\|_\\infty = \\max_{i} |F_i(\\mathbf{u}^{(k)})|  \\epsilon\n$$\n$\\epsilon$ 的典型值为 $10^{-10}$ 或更小。此外，还会设置最大迭代次数，以防止在不收敛的情况下陷入无限循环。\n\n### 5. 最终解的评估\n\n在牛顿法收敛到离散解向量 $\\mathbf{u}_{\\text{sol}} = [u_1, \\dots, u_{N-1}]^T$ 后，通过包含边界点来构建网格上的完整解：\n$$\n\\mathbf{u}_{\\text{full}} = [u_0, u_1, \\dots, u_{N-1}, u_N]^T = [0, u_1, \\dots, u_{N-1}, 0]^T\n$$\n然后，计算解的 $L^\\infty$-范数是这个完整网格点集合上的最大绝对值：\n$$\n\\|\\mathbf{u}_{\\text{full}}\\|_\\infty = \\max_{i=0, \\dots, N} |u_i|\n$$\n每个测试用例都报告此值。所有三角函数求值都必须使用弧度，这是科学计算库的标准。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef thomas_solver(a, b, c, d):\n    \"\"\"\n    Solves a tridiagonal system of equations Ax = d.\n    a: sub-diagonal (size m-1)\n    b: main diagonal (size m)\n    c: super-diagonal (size m-1)\n    d: right-hand side (size m)\n    \"\"\"\n    m = len(b)\n    # Create copies to avoid modifying the original arrays\n    ac, bc, cc, dc = map(np.copy, (a, b, c, d))\n    \n    # Forward elimination\n    for i in range(1, m):\n        w = ac[i-1] / bc[i-1]\n        bc[i] = bc[i] - w * cc[i-1]\n        dc[i] = dc[i] - w * dc[i-1]\n        \n    # Backward substitution\n    x = np.zeros(m)\n    x[m-1] = dc[m-1] / bc[m-1]\n    for i in range(m-2, -1, -1):\n        x[i] = (dc[i] - cc[i] * x[i+1]) / bc[i]\n        \n    return x\n\ndef newton_bvp_solver(L, N, initial_guess_func, tol=1e-10, max_iter=50):\n    \"\"\"\n    Solves the BVP u'' + sin(u) = 0 with u(0)=u(L)=0 using Newton's method.\n    \n    Args:\n        L (float): Length of the interval [0, L].\n        N (int): Number of subintervals.\n        initial_guess_func (callable): A function u_0(x) for the initial guess.\n        tol (float): Convergence tolerance for the residual norm.\n        max_iter (int): Maximum number of Newton iterations.\n    \n    Returns:\n        numpy.ndarray: The solution vector for the interior grid points.\n    \"\"\"\n    h = L / N\n    m = N - 1  # Number of interior points (unknowns)\n    x_interior = np.linspace(0, L, N + 1)[1:-1]\n    \n    u = initial_guess_func(x_interior)\n    \n    h2_inv = 1.0 / (h * h)\n\n    def compute_residual(u_vec):\n        # Create a padded vector with boundary conditions u(0)=0, u(L)=0\n        u_padded = np.concatenate(([0.0], u_vec, [0.0]))\n        # Compute the finite difference approximation of u''\n        u_xx = (u_padded[2:] - 2 * u_padded[1:-1] + u_padded[:-2]) * h2_inv\n        # Compute the residual F(u) = u'' + sin(u)\n        return u_xx + np.sin(u_vec)\n\n    for k in range(max_iter):\n        # 1. Compute residual F(u)\n        F = compute_residual(u)\n        \n        # 2. Check for convergence\n        res_norm = np.max(np.abs(F))\n        if res_norm  tol:\n            return u\n        \n        # 3. Compute Jacobian diagonals\n        diag_b = -2.0 * h2_inv + np.cos(u)\n        diag_a = np.full(m - 1, h2_inv)\n        diag_c = np.full(m - 1, h2_inv)\n        \n        # 4. Solve J * delta_u = -F for the Newton step delta_u\n        # The Jacobian is symmetric, so sub-diagonal and super-diagonal are identical\n        delta_u = thomas_solver(diag_a, diag_b, diag_c, -F)\n        \n        # 5. Damped update using a simple backtracking line search\n        alpha = 1.0\n        u_new = u + alpha * delta_u\n        res_norm_new = np.max(np.abs(compute_residual(u_new)))\n        \n        # Reduce alpha until the residual norm decreases\n        while res_norm_new = res_norm and alpha  1e-4:\n            alpha /= 2.0\n            u_new = u + alpha * delta_u\n            res_norm_new = np.max(np.abs(compute_residual(u_new)))\n\n        # 6. Update solution\n        u = u_new\n        \n        # Check if the update step is too small\n        if np.max(np.abs(alpha * delta_u))  tol:\n            return u\n\n    raise RuntimeError(f\"Newton's method failed to converge for L={L}, N={N} within {max_iter} iterations.\")\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'L': 2 * np.pi, 'N': 400, 'u0_func': lambda x: np.zeros_like(x)},\n        {'L': 2 * np.pi, 'N': 400, 'u0_func': lambda x: 2.5 * np.sin(np.pi * x / (2 * np.pi))},\n        {'L': 2 * np.pi, 'N': 400, 'u0_func': lambda x: -2.5 * np.sin(np.pi * x / (2 * np.pi))},\n        {'L': np.pi,     'N': 400, 'u0_func': lambda x: 2.5 * np.sin(np.pi * x / np.pi)}\n    ]\n\n    results = []\n    for case in test_cases:\n        L = case['L']\n        N = case['N']\n        u0_func = case['u0_func']\n        \n        # Compute the numerical solution for the interior points\n        u_solution = newton_bvp_solver(L, N, u0_func)\n        \n        # Construct full solution including boundaries to calculate L-infinity norm\n        u_full = np.concatenate(([0.0], u_solution, [0.0]))\n        \n        # Calculate the L-infinity norm of the full solution\n        L_inf_norm = np.max(np.abs(u_full))\n        results.append(L_inf_norm)\n\n    # Format the final output string exactly as specified\n    # The f-string formatting automatically rounds to the specified number of decimal places.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "3228545"}]}