{"hands_on_practices": [{"introduction": "这个练习将抽象的数值稳定性概念落实到一个具体的计算中。我们将应用冯·诺依曼稳定性分析的结果，来确定在一维热传导方程中，给定空间分辨率（$\\Delta x$）和材料属性（$\\alpha$）时，所允许的最大时间步长（$\\Delta t_{\\max}$）。这是建立任何有效的显式格式模拟的关键第一步。[@problem_id:2483538]", "problem": "一个热扩散系数恒定的均匀、各向同性一维固体，其瞬态热方程由能量守恒和傅里叶定律导出，形式为 $\\frac{\\partial T}{\\partial t}=\\alpha\\,\\frac{\\partial^{2}T}{\\partial x^{2}}$，其中 $T$ 是温度，$t$ 是时间，$x$ 是沿杆的空间坐标，$\\alpha$ 是热扩散系数。考虑一个间距为 $\\Delta x$ 的均匀网格，并应用前向时间中心空间 (FTCS) 显式时间积分格式，该格式使用前向欧拉步在时间上推进 $T$，并用二阶中心差分近似空间二阶导数。使用 von Neumann (傅里叶) 稳定性分析，确定最大时间步长 $\\Delta t_{\\max}$，使得该格式对于所有空间傅里叶模式达到临界稳定。\n\n使用数据 $\\alpha=1.4\\times 10^{-5}\\,\\mathrm{m^{2}/s}$ 和 $\\Delta x=0.5\\,\\mathrm{mm}$，计算此一维FTCS离散化对应的 $\\Delta t_{\\max}$。将您的答案四舍五入到四位有效数字，并以秒为单位表示时间。", "solution": "该问题陈述具有科学依据、是适定的，并包含了获得唯一解所需的所有必要信息。因此，该问题被认为是有效的。我们着手求解。\n\n一维瞬态热传导的控制方程如下：\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}\n$$\n这里，$T(x, t)$ 是温度，$x$ 是空间坐标，$t$ 是时间，$\\alpha$ 是热扩散系数。我们要分析该方程的前向时间中心空间 (FTCS) 离散格式的稳定性。\n\n让我们定义一个空间步长为 $\\Delta x$、时间步长为 $\\Delta t$ 的均匀网格。在网格节点 $i$ 和时间层 $n$ 的温度记为 $T_i^n \\equiv T(i\\Delta x, n\\Delta t)$。\n\nFTCS 格式按如下方式近似偏导数：\n时间导数使用一阶前向差分近似：\n$$\n\\frac{\\partial T}{\\partial t} \\bigg|_{i,n} \\approx \\frac{T_i^{n+1} - T_i^n}{\\Delta t}\n$$\n空间二阶导数使用二阶中心差分近似：\n$$\n\\frac{\\partial^2 T}{\\partial x^2} \\bigg|_{i,n} \\approx \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{(\\Delta x)^2}\n$$\n将这些近似值代入控制方程，得到 FTCS 格式的离散形式：\n$$\n\\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\alpha \\left( \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{(\\Delta x)^2} \\right)\n$$\n我们可以重新整理这个方程，以显式求解下一个时间步的温度 $T_i^{n+1}$：\n$$\nT_i^{n+1} = T_i^n + \\frac{\\alpha \\Delta t}{(\\Delta x)^2} (T_{i+1}^n - 2T_i^n + T_{i-1}^n)\n$$\n我们定义无量纲傅里叶数 $Fo$（也称为扩散数）为：\n$$\nFo = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}\n$$\n离散方程简化为：\n$$\nT_i^{n+1} = T_i^n + Fo (T_{i+1}^n - 2T_i^n + T_{i-1}^n) = Fo \\, T_{i+1}^n + (1 - 2Fo)T_i^n + Fo \\, T_{i-1}^n\n$$\n为了确定此数值格式的稳定性，我们进行 von Neumann 稳定性分析。我们考虑解的单个傅里叶模式的行为。设时间层 $n$ 的温度分布由一个傅里叶分量表示：\n$$\nT_i^n = \\hat{T}^n(k) e^{I k x_i}\n$$\n其中 $k$ 是波数，$x_i = i\\Delta x$ 是节点 $i$ 的空间位置，$I = \\sqrt{-1}$ 是虚数单位。此模式在时间 $n$ 的振幅是 $\\hat{T}^n(k)$。经过一个时间步后，该模式将被一个因子 $G(k)$（放大因子）放大：\n$$\nT_i^{n+1} = \\hat{T}^{n+1}(k) e^{I k x_i} = G(k) \\hat{T}^n(k) e^{I k x_i}\n$$\n为使数值格式稳定，对任何波数 $k$，放大因子的模都不能超过1。稳定性条件是：\n$$\n|G(k)| \\le 1\n$$\n我们将傅里叶模式表示代入离散方程中：\n$$\nG(k) \\hat{T}^n(k) e^{I k (i\\Delta x)} = Fo \\, \\hat{T}^n(k) e^{I k ((i+1)\\Delta x)} + (1 - 2Fo) \\hat{T}^n(k) e^{I k (i\\Delta x)} + Fo \\, \\hat{T}^n(k) e^{I k ((i-1)\\Delta x)}\n$$\n用 $\\hat{T}^n(k) e^{I k (i\\Delta x)}$ 除，得到放大因子 $G(k)$ 的表达式：\n$$\nG(k) = Fo \\, e^{I k \\Delta x} + (1 - 2Fo) + Fo \\, e^{-I k \\Delta x}\n$$\n使用欧拉恒等式 $e^{I\\theta} + e^{-I\\theta} = 2\\cos(\\theta)$，我们可以简化此表达式：\n$$\nG(k) = 1 - 2Fo + Fo (e^{I k \\Delta x} + e^{-I k \\Delta x}) = 1 - 2Fo + 2Fo \\cos(k \\Delta x)\n$$\n$$\nG(k) = 1 - 2Fo(1 - \\cos(k \\Delta x))\n$$\n使用三角半角恒等式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$，我们得到：\n$$\nG(k) = 1 - 4Fo \\sin^2\\left(\\frac{k \\Delta x}{2}\\right)\n$$\n现在我们应用稳定性条件 $|G(k)| \\le 1$。由于 $Fo > 0$，项 $4Fo \\sin^2(k\\Delta x/2)$ 是非负的。因此，$G(k)$ 总是小于或等于 $1$。因此，稳定性由下界决定：\n$$\nG(k) \\ge -1\n$$\n$$\n1 - 4Fo \\sin^2\\left(\\frac{k \\Delta x}{2}\\right) \\ge -1\n$$\n$$\n2 \\ge 4Fo \\sin^2\\left(\\frac{k \\Delta x}{2}\\right)\n$$\n$$\n\\frac{1}{2} \\ge Fo \\sin^2\\left(\\frac{k \\Delta x}{2}\\right)\n$$\n这个不等式必须对所有可能的波数 $k$ 都成立。最严格的条件发生在项 $\\sin^2(k\\Delta x/2)$ 达到其最大值时。$\\sin^2(\\theta)$ 的最大值是 $1$。这对应于网格上可表示的最高频率（振荡最快）的模式，此时 $k \\Delta x = \\pi$。\n因此，稳定性条件变为：\n$$\nFo \\le \\frac{1}{2}\n$$\n在此条件的极限，即 $Fo = 1/2$ 时，达到临界稳定。最大允许时间步长 $\\Delta t_{\\max}$ 对应于此极限：\n$$\n\\frac{\\alpha \\Delta t_{\\max}}{(\\Delta x)^2} = \\frac{1}{2}\n$$\n求解 $\\Delta t_{\\max}$：\n$$\n\\Delta t_{\\max} = \\frac{(\\Delta x)^2}{2\\alpha}\n$$\n我们已知以下数据：\n$\\alpha = 1.4 \\times 10^{-5} \\, \\mathrm{m^2/s}$\n$\\Delta x = 0.5 \\, \\mathrm{mm} = 0.5 \\times 10^{-3} \\, \\mathrm{m}$\n\n将这些值代入 $\\Delta t_{\\max}$ 的表达式中：\n$$\n(\\Delta x)^2 = (0.5 \\times 10^{-3} \\, \\mathrm{m})^2 = 0.25 \\times 10^{-6} \\, \\mathrm{m^2}\n$$\n$$\n\\Delta t_{\\max} = \\frac{0.25 \\times 10^{-6} \\, \\mathrm{m^2}}{2 \\times (1.4 \\times 10^{-5} \\, \\mathrm{m^2/s})} = \\frac{0.25 \\times 10^{-6}}{2.8 \\times 10^{-5}} \\, \\mathrm{s}\n$$\n$$\n\\Delta t_{\\max} = \\frac{0.25}{2.8} \\times 10^{-1} \\, \\mathrm{s} \\approx 0.0892857 \\times 10^{-1} \\, \\mathrm{s} = 0.00892857 \\, \\mathrm{s}\n$$\n问题要求将答案四舍五入到四位有效数字。\n$$\n\\Delta t_{\\max} \\approx 0.008929 \\, \\mathrm{s}\n$$", "answer": "$$\n\\boxed{0.008929}\n$$", "id": "2483538"}, {"introduction": "从理论走向实践，这个练习要求我们编写程序，使用FTCS格式求解热传导方程。通过让稳定性参数 $r$ 在理论临界值 $0.5$ 上下浮动，我们可以通过实验观察到不稳定性的发生。这个实践还引入了数值精度的概念，并探讨了它与网格细化的关系。[@problem_id:3204666]", "problem": "考虑一维热方程 $u_t = \\alpha u_{xx}$，其空间区间为 $x \\in [0,1]$，时间为 $t \\ge 0$，其中 $\\alpha > 0$ 是一个常数。施加齐次狄利克雷边界条件 $u(0,t) = 0$ 和 $u(1,t) = 0$（对所有 $t \\ge 0$），以及初始条件 $u(x,0) = \\sin(\\pi x)$。此初边值问题的精确解为 $u(x,t) = e^{-\\alpha \\pi^2 t} \\sin(\\pi x)$。从偏导数和二阶中心差分的基本定义出发，实现一个显式前向时间结合二阶中心空间差分的格式。该格式在具有空间步长 $\\Delta x$ 和时间步长 $\\Delta t$ 的均匀网格上，用前向差分近似 $u_t$，用二阶中心差分近似 $u_{xx}$。使用无量纲参数 $r = \\alpha \\Delta t / (\\Delta x)^2$ 来参数化相对于空间分辨率的时间步长。\n\n你的程序必须：\n- 用 $N_x$ 个网格点离散化区域 $[0,1]$，使得 $\\Delta x = 1/(N_x-1)$。\n- 使用由指定 $r$ 决定的所选 $\\Delta t$，将显式格式演化到最终时间 $T$。\n- 对于每次运行，计算数值解在整个时间内的最大范数。如果整个模拟过程中的最大范数不超过初始条件最大范数的 $1.05$ 倍，则宣布其行为为“观测稳定”；否则，宣布为“观测不稳定”。\n- 将观测稳定性与基于 $r$ 的理论分类标准进行比较，并返回一个布尔值，指示该次运行的观测结果是否与理论相符。\n- 使用精确解 $u(x,t) = e^{-\\alpha \\pi^2 t} \\sin(\\pi x)$ 和网格误差的无穷范数，计算最终模拟时间的数值误差。\n\n测试套件和参数：\n- 在三种情况下验证稳定性，参数为 $\\alpha = 1.0$，$N_x = 51$，最终时间 $T = 0.1$：\n  - 情况1：$r = 0.45$。\n  - 情况2：$r = 0.5$。\n  - 情况3：$r = 0.55$。\n  对于每种情况，输出一个布尔值，说明观测到的稳定性是否与理论稳定性分类相符。\n- 在稳定运行条件下评估精度与效率：\n  - 使用 $\\alpha = 1.0$，$T = 0.1$，$r = 0.45$。\n  - 运行两次模拟：一次使用 $N_x = 51$ 的粗网格，一次使用 $N_x = 101$ 的细网格。\n  - 计算无穷范数误差之比 $E_{\\text{coarse}} / E_{\\text{fine}}$，结果为浮点数。此外，程序应在内部为每次运行计算操作代理 $W = N_t \\cdot (N_x - 2)$（其中 $N_t$ 是时间步数），以便从概念上讨论效率，但此计数无需打印。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内无空格。该列表必须按顺序包含四个条目：三个用于稳定性验证的布尔值，以及用于精度评估的浮点误差比。例如，输出应类似于“[True,True,False,3.85]”，其中最后一个数字是浮点数。\n- 本问题中没有物理单位；所有量纲均为无量纲。", "solution": "一维热方程 $u_t = \\alpha u_{xx}$ 模拟了扩散平滑过程。对于一个均匀网格 $x_i = i \\Delta x$（其中 $i = 0,\\dots,N_x-1$）和时间层 $t^n = n \\Delta t$，显式前向时间和二阶中心空间格式可由时间导数和二阶导数的定义得出。时间导数由前向差分近似 $u_t(x_i,t^n) \\approx \\left(u_i^{n+1} - u_i^n\\right)/\\Delta t$，二阶导数由中心差分近似 $u_{xx}(x_i,t^n) \\approx \\left(u_{i+1}^n - 2 u_i^n + u_{i-1}^n\\right)/(\\Delta x)^2$。将这些近似相等，得到显式更新公式\n$$\nu_i^{n+1} = u_i^n + r \\left(u_{i+1}^n - 2u_i^n + u_{i-1}^n\\right), \\quad r = \\frac{\\alpha \\Delta t}{(\\Delta x)^2},\n$$\n该公式适用于内部索引 $i = 1,\\dots,N_x-2$，并满足狄利克雷边界条件 $u_0^n = 0$ 和 $u_{N_x-1}^n = 0$（对所有 $n$）。\n\n基于原理的稳定性分析对线性常系数格式使用 Von Neumann 方法。考虑一个傅里叶模 $e^{\\mathrm{i} k x_i}$，并写出放大因子 $g(k)$，使得该模满足 $u_i^{n+1} = g(k) u_i^n$。代入中心差分可得\n$$\ng(k) = 1 - 4 r \\sin^2\\left(\\frac{k \\Delta x}{2}\\right).\n$$\n在所有模式的放大都有界的意义上，稳定性要求对所有波数 $k$ 都满足 $\\lvert g(k) \\rvert \\le 1$。最严格的情况是当 $\\sin^2\\left(k \\Delta x/2\\right) = 1$ 时，这导出了条件\n$$\n-1 \\le 1 - 4r \\le 1 \\quad \\Rightarrow \\quad r \\le \\frac{1}{2}.\n$$\n因此，显式前向时间中心空间格式是稳定的，当且仅当 $r \\le 1/2$。该格式在时间上是一阶精度（截断误差为 $\\mathcal{O}(\\Delta t)$），在空间上是二阶精度（截断误差为 $\\mathcal{O}((\\Delta x)^2)$）。如果在加密网格时保持 $r$ 不变，那么 $\\Delta t$ 将按 $(\\Delta x)^2$ 的比例缩放，时间和空间误差都将按 $\\mathcal{O}((\\Delta x)^2)$ 缩放，整体误差表现为 $\\mathcal{O}((\\Delta x)^2)$。在这种耦合下，将 $\\Delta x$ 减半会使误差大约减少为原来的 $1/4$。\n\n显式方法的效率考虑是直接的：每个时间步更新 $N_x-2$ 个内部点，且每个点的算术运算量是恒定的，因此计算工作量代理 $W$ 的缩放关系为 $W = N_t \\cdot (N_x - 2)$，其中 $N_t$ 是时间步数。对于固定的 $r$ 和最终时间 $T$，我们有 $\\Delta t = r (\\Delta x)^2/\\alpha$ 且 $N_t \\approx T/\\Delta t \\propto 1/(\\Delta x)^2$。因此，对于一维均匀网格，总工作量按 $W \\propto (N_x-2) \\cdot 1/(\\Delta x)^2 \\sim \\mathcal{O}(N_x^3)$ 的比例缩放（因为 $N_x \\sim 1/\\Delta x$），这反映了显式格式对时间步长的抛物线型限制。\n\n该程序实现了具有初始条件 $u(x,0) = \\sin(\\pi x)$ 和狄利克雷边界的显式格式，在指定的 $\\alpha$、$N_x$ 和 $r$ 下演化到最终时间 $T$，并通过监测整个时间上的最大范数来衡量观测稳定性。它使用精确解 $u(x,t) = e^{-\\alpha \\pi^2 t} \\sin(\\pi x)$ 计算最后模拟时刻的无穷范数误差。稳定性验证将观测分类与基于 $r$ 的理论分类进行比较，并为每个测试用例输出布尔值。对于精度评估，它在稳定耦合条件 $r = 0.45$ 下，比较 $N_x = 51$ 与 $N_x = 101$ 时的误差比 $E_{\\text{coarse}}/E_{\\text{fine}}$，预期比值接近 4，这与空间二阶精度以及时间一阶精度与 $\\Delta t \\propto (\\Delta x)^2$ 耦合的结果相符。\n\n最终输出为格式为“[b1,b2,b3,ratio]”的单行文本，其中 b1、b2 和 b3 分别是 $r = 0.45$、$r = 0.5$ 和 $r = 0.55$ 情况下的布尔值，而“ratio”是 $E_{\\text{coarse}}/E_{\\text{fine}}$ 的浮点数值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef explicit_heat(alpha: float, Nx: int, r: float, T: float):\n    \"\"\"\n    Run the explicit FTCS (Forward-Time, Central-Space) scheme for the 1D heat equation\n    u_t = alpha * u_xx with Dirichlet boundaries u(0,t)=u(1,t)=0 and initial condition\n    u(x,0) = sin(pi x).\n\n    Parameters\n    ----------\n    alpha : float\n        Diffusion coefficient (dimensionless).\n    Nx : int\n        Number of spatial grid points on [0,1].\n    r : float\n        Nondimensional parameter r = alpha * dt / dx^2.\n    T : float\n        Final simulation time.\n\n    Returns\n    -------\n    verify_match : bool\n        True if the observed stability classification matches the theoretical classification.\n    err_inf : float\n        Infinity-norm error at the final simulated time compared to the exact solution.\n    work_units : int\n        Proxy for computational work: number of interior updates performed.\n    \"\"\"\n    L = 1.0\n    x = np.linspace(0.0, L, Nx)\n    dx = x[1] - x[0]\n    dt = r * dx * dx / alpha\n    # Number of time steps to reach or slightly exceed T\n    Nt = int(np.ceil(T / dt)) if dt > 0 else 0\n    # Initialize u with the exact initial condition\n    u = np.sin(np.pi * x)\n    # Enforce Dirichlet boundaries explicitly (though sin(pi*x) already satisfies them)\n    u[0] = 0.0\n    u[-1] = 0.0\n    max_initial = np.max(np.abs(u))\n    max_over_time = max_initial\n    observed_stable = True\n\n    # Time stepping loop\n    for _ in range(Nt):\n        # Vectorized interior update\n        u_new = u.copy()\n        u_new[1:-1] = u[1:-1] + r * (u[2:] - 2.0 * u[1:-1] + u[:-2])\n        # Enforce Dirichlet boundaries\n        u_new[0] = 0.0\n        u_new[-1] = 0.0\n        u = u_new\n        current_max = np.max(np.abs(u))\n        # Detect numerical issues\n        if not np.isfinite(current_max):\n            observed_stable = False\n            max_over_time = np.inf\n            break\n        if current_max > max_over_time:\n            max_over_time = current_max\n\n    # Observational stability criterion: no growth beyond 5% of initial peak\n    if not (np.isfinite(max_over_time) and max_over_time = 1.05 * max_initial):\n        observed_stable = False\n\n    # Final time actually reached\n    t_end = Nt * dt\n    # Exact solution at final time\n    u_exact = np.exp(-alpha * (np.pi ** 2) * t_end) * np.sin(np.pi * x)\n    # Infinity-norm error\n    err_inf = float(np.max(np.abs(u - u_exact)))\n\n    # Theoretical stability classification for FTCS heat: r = 1/2\n    theoretical_stable = (r = 0.5 + 1e-12)\n    verify_match = (observed_stable == theoretical_stable)\n\n    # Work units proxy: number of interior updates\n    work_units = Nt * max(Nx - 2, 0)\n    return verify_match, err_inf, work_units\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Stability verification cases: alpha=1.0, Nx=51, T=0.1, r in {0.45, 0.5, 0.55}\n    stability_cases = [\n        (1.0, 51, 0.45, 0.1),\n        (1.0, 51, 0.5, 0.1),\n        (1.0, 51, 0.55, 0.1),\n    ]\n    # Accuracy ratio assessment: alpha=1.0, T=0.1, r=0.45, Nx in {51, 101}\n    accuracy_params = {\n        \"alpha\": 1.0,\n        \"T\": 0.1,\n        \"r\": 0.45,\n        \"Nx_coarse\": 51,\n        \"Nx_fine\": 101,\n    }\n\n    results = []\n\n    # Run stability verification cases\n    for alpha, Nx, r, T in stability_cases:\n        verify_match, _, _ = explicit_heat(alpha, Nx, r, T)\n        results.append(verify_match)\n\n    # Run accuracy ratio assessment\n    # Coarse grid\n    e_match_c, err_coarse, _ = explicit_heat(\n        accuracy_params[\"alpha\"], accuracy_params[\"Nx_coarse\"], accuracy_params[\"r\"], accuracy_params[\"T\"]\n    )\n    # Fine grid\n    e_match_f, err_fine, _ = explicit_heat(\n        accuracy_params[\"alpha\"], accuracy_params[\"Nx_fine\"], accuracy_params[\"r\"], accuracy_params[\"T\"]\n    )\n    # Compute error ratio; guard against zero to avoid division by zero\n    ratio = (err_coarse / err_fine) if err_fine != 0.0 else float(\"inf\")\n    results.append(ratio)\n\n    # Final print statement in the exact required format: single line, no spaces.\n    def fmt(x):\n        if isinstance(x, float):\n            # Format float with reasonable precision, remove spaces\n            return f\"{x:.12g}\"\n        else:\n            return str(x)\n\n    print(f\"[{','.join(fmt(r) for r in results)}]\")\n\nsolve()\n```", "id": "3204666"}, {"introduction": "为了真正理解FTCS格式为何会变得不稳定，这个练习将聚焦于“最坏情况”。我们将用网格所能表示的最高频率波作为初始条件来运行模拟，观察其行为如何戏剧性地展示数值误差的放大过程。这种方法能够直观地揭示违反稳定性条件所导致的爆炸性增长，并将其与冯·诺依曼分析的理论预测直接联系起来。[@problem_id:3227167]", "problem": "考虑单位区间上的带齐次狄利克雷边界条件的一维扩散方程，其表述如下。设 $u(x,t)$ 是一个定义在 $x \\in [0,1]$ 和 $t \\ge 0$ 上的足够光滑的无量纲场，满足偏微分方程 $u_t = \\alpha u_{xx}$，其中参数 $\\alpha  0$，$u(0,t) = 0$，$u(1,t) = 0$。将空间域离散化为 $M$ 个等长的子区间，间距为 $\\Delta x = 1/M$，网格点为 $x_j = j \\Delta x$，其中 $j = 0,1,\\dots,M$。使用前向时间中心空间（FTCS）显式格式，用均匀时间步长 $\\Delta t$ 上的前向差分来近似 $u_t$，并用空间网格上的二阶中心差分来近似 $u_{xx}$。定义无量纲参数 $r = \\alpha \\Delta t / \\Delta x^2$。内部更新应用于指标 $j = 1,2,\\dots,M-1$，而 $j = 0$ 和 $j = M$ 处的边界值在所有时间层上都保持为零。\n\n设计一个完全由可在网格上表示且满足齐次狄利克雷边界条件的最高频率离散正弦模态组成的初始条件。这个最高频率模态是指标为 $m = M - 1$ 的离散正弦模态，在内部点上由 $u_j^0 = \\sin\\!\\big( (M-1)\\pi x_j \\big)$ 给出（$j = 1,2,\\dots,M-1$），并且 $u_0^0 = 0$ 和 $u_M^0 = 0$。使用 FTCS 格式将此初始条件向前演化指定的时间步数 $N_t$。\n\n你的任务是定量地捕捉在参数 $r$ 的不同选择下解的增长或衰减。对于每个指定的测试用例，计算比率 $R$，定义为离散无穷范数增长因子：\n$$\nR = \\frac{\\max_{0 \\le j \\le M} \\big|u_j^{N_t}\\big|}{\\max_{0 \\le j \\le M} \\big|u_j^{0}\\big|}.\n$$\n所有量都是无量纲的。使用 $\\alpha = 1$ 和 $L = 1$，因此 $\\Delta x = 1/M$，并通过指定 $r$ 的值使用 $\\Delta t = r \\Delta x^2 / \\alpha$ 来设置时间步长 $\\Delta t$。使用这些值实现 FTCS 时间推进。\n\n测试套件：\n- 情况 1：$M = 64$，$N_t = 50$，$r = 0.49$。\n- 情况 2：$M = 64$，$N_t = 50$，$r = 0.50$。\n- 情况 3：$M = 64$，$N_t = 50$，$r = 0.51$。\n- 情况 4：$M = 64$，$N_t = 20$，$r = 1.00$。\n\n你的程序应生成单行输出，其中包含四个测试用例的结果，聚合为一个用方括号括起来的逗号分隔列表，每个元素是按上述顺序列出的相应浮点增长比率 $R$（例如，$[R_1,R_2,R_3,R_4]$）。由于变量是无量纲的，并且根据正弦模态的构造，角度以弧度为单位，因此不需要单位。", "solution": "该问题要求在空间域 $x \\in [0,1]$ 上对带齐次狄利克雷边界条件（$u(0,t) = 0$ 和 $u(1,t) = 0$）的一维扩散方程 $u_t = \\alpha u_{xx}$ 进行数值求解。我们将采用前向时间中心空间（FTCS）显式有限差分格式。\n\n首先，我们对偏微分方程进行离散化。空间域被划分为 $M$ 个宽度为 $\\Delta x = 1/M$ 的子区间，从而创建一个由点 $x_j = j \\Delta x$（$j = 0, 1, \\dots, M$）组成的网格。时间域被离散化为大小为 $\\Delta t$ 的步长。我们将解 $u(x_j, n\\Delta t)$ 的数值近似表示为 $u_j^n$。\n\n在点 $(x_j, t_n)$ 处的时间导数 $u_t$ 使用一阶前向差分进行近似：\n$$\nu_t \\approx \\frac{u_j^{n+1} - u_j^n}{\\Delta t}\n$$\n二阶空间导数 $u_{xx}$ 使用二阶中心差分进行近似：\n$$\nu_{xx} \\approx \\frac{u_{j-1}^n - 2u_j^n + u_{j+1}^n}{\\Delta x^2}\n$$\n将这些近似值代入扩散方程 $u_t = \\alpha u_{xx}$，得到：\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} = \\alpha \\frac{u_{j-1}^n - 2u_j^n + u_{j+1}^n}{\\Delta x^2}\n$$\n重新整理此方程以求解下一时间步的解 $u_j^{n+1}$，可得到显式 FTCS 更新规则：\n$$\nu_j^{n+1} = u_j^n + \\frac{\\alpha \\Delta t}{\\Delta x^2} \\left( u_{j-1}^n - 2u_j^n + u_{j+1}^n \\right)\n$$\n我们定义无量纲扩散数 $r = \\frac{\\alpha \\Delta t}{\\Delta x^2}$。更新规则简化为：\n$$\nu_j^{n+1} = u_j^n + r \\left( u_{j-1}^n - 2u_j^n + u_{j+1}^n \\right)\n$$\n该方程应用于所有内部网格点，即对 $j = 1, 2, \\dots, M-1$ 应用。边界条件规定，对于所有时间层 $n$，$u_0^n = 0$ 且 $u_M^n = 0$。\n\n问题指定了一个初始条件 $u(x,0)$，它由可在网格上表示并满足边界条件的最高频率离散正弦模态构成。该模态对应于指标 $m = M-1$，由 $u_j^0 = \\sin((M-1)\\pi x_j)$ 给出（$j=1,\\dots,M-1$）。选择此模态是因为它代表了数值格式稳定性的最具挑战性的情况。边界上的值为 $u_0^0 = \\sin(0) = 0$ 和 $u_M^0 = \\sin((M-1)\\pi \\cdot M/M) = \\sin((M-1)\\pi) = 0$，满足狄利克雷条件。\n\n像 FTCS 这样的显式格式的一个关键方面是条件稳定性。von Neumann 稳定性分析表明，对于扩散方程，FTCS 格式仅在 $r \\le 1/2$ 时稳定。对于包含多个频率模态的初始条件，如果 $r > 1/2$，高频分量将在每个时间步中被放大，导致数值解出现灾难性的、非物理的增长。对于指标为 $m$ 的特定离散模态，稳定性条件为 $r \\le \\frac{1}{2 \\sin^2(m\\pi / (2M))}$。最严格的条件来自最高频率模态 $m=M-1$，得出的临界值为 $r_c = \\frac{1}{2 \\sin^2((M-1)\\pi / (2M))}$。对于大的 $M$，$\\sin^2((M-1)\\pi / (2M)) \\approx 1$，因此 $r_c \\approx 0.5$。提供的测试用例中 $r=0.49$、$r=0.50$ 和 $r=0.51$ 就是为了探测这个稳定性边界。对于 $M=64$，临界值约为 $r_c \\approx 0.50096$。因此，我们预期当 $r \\le 0.50$ 时解会衰减（稳定），而当 $r = 0.51$ 时会增长（不稳定）。\n\n解决该问题的算法如下：\n1.  对于每个测试用例 $(M, N_t, r)$，初始化常数 $\\alpha=1$ 和网格。空间步长为 $\\Delta x = 1/M$。\n2.  创建一个大小为 $M+1$ 的数组 `u`，用于存储给定时间步的解。\n3.  设置初始条件：$u_j^0 = \\sin((M-1)\\pi x_j) = \\sin((M-1)\\pi j \\Delta x)$，其中 $j=1, \\dots, M-1$。边界点 $u_0^0$ 和 $u_M^0$ 为零。\n4.  计算初始离散无穷范数 $N_0 = \\max_{0 \\le j \\le M} |u_j^0|$。\n5.  迭代 $N_t$ 个时间步。在每一步中，使用 FTCS 更新规则，根据当前状态 $u^n$ 计算所有内部点的下一个状态 $u^{n+1}$。在更新解数组之前，必须使用第 $n$ 步的解的副本来计算第 $n+1$ 步的所有值。\n6.  经过 $N_t$ 步后，计算最终离散无穷范数 $N_{final} = \\max_{0 \\le j \\le M} |u_j^{N_t}|$。\n7.  计算所需的比率 $R = N_{final} / N_0$。\n\n对所有四个测试用例重复此过程。该实现将使用向量化的 `numpy` 操作以提高效率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D diffusion equation using the FTCS scheme for several\n    test cases and calculates the infinity-norm growth factor.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (M, N_t, r).\n    test_cases = [\n        (64, 50, 0.49),\n        (64, 50, 0.50),\n        (64, 50, 0.51),\n        (64, 20, 1.00),\n    ]\n\n    results = []\n    for case in test_cases:\n        M, N_t, r = case\n        \n        # Spatial discretization\n        # L=1, so dx = 1/M. Total points = M+1 (from j=0 to j=M)\n        M_int = int(M)\n        x = np.linspace(0.0, 1.0, M_int + 1)\n        \n        # Initial condition u(x,0)\n        # Highest frequency discrete sine mode: sin((M-1)*pi*x)\n        u = np.zeros(M_int + 1)\n        # Apply to interior points j = 1, ..., M-1\n        u[1:M_int] = np.sin((M_int - 1) * np.pi * x[1:M_int])\n        \n        # Calculate the initial discrete infinity-norm of the solution\n        u_norm_initial = np.max(np.abs(u))\n        \n        # Time-marching loop using the FTCS scheme\n        for _ in range(int(N_t)):\n            # Store the current state to use in the update step\n            u_old = u.copy()\n            \n            # Apply the FTCS update rule for all interior points j=1..M-1\n            # u_j^{n+1} = u_j^n + r * (u_{j-1}^n - 2*u_j^n + u_{j+1}^n)\n            # This is vectorized for efficiency.\n            u[1:M_int] = u_old[1:M_int] + r * (u_old[0:M_int-1] - 2 * u_old[1:M_int] + u_old[2:M_int+1])\n            \n            # Boundary conditions u(0,t)=0 and u(1,t)=0 are maintained\n            # as u[0] and u[M] are never updated and were initialized to 0.\n\n        # Calculate the final discrete infinity-norm of the solution\n        u_norm_final = np.max(np.abs(u))\n        \n        # Compute the growth factor ratio R\n        # Handle the case where the initial norm is zero to avoid division by zero.\n        if u_norm_initial == 0.0:\n            # If initial is zero, final should also be zero. Ratio is 1 if both are 0.\n            # If final is non-zero, it implies infinite growth, which 'inf' can represent.\n            growth_ratio = 1.0 if u_norm_final == 0.0 else np.inf\n        else:\n            growth_ratio = u_norm_final / u_norm_initial\n            \n        results.append(growth_ratio)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{res:.12f}' for res in results)}]\")\n\nsolve()\n```", "id": "3227167"}]}