{"hands_on_practices": [{"introduction": "在编写任何代码之前，首先理解线性打靶法背后的数学原理至关重要。这个练习将引导你运用叠加原理，为一个边值问题推导出初始斜率的精确解析表达式。通过这个过程，你将清楚地看到线性性质如何让我们能够直接求解，从而避免了非线性问题中常见的迭代试射过程 [@problem_id:3248440]。", "problem": "考虑线性常微分方程 (ODE) 的边值问题\n$$\ny''(x) + \\frac{1}{x}\\,y'(x) = 0,\\quad x \\in [1, L],\n$$\n其边界条件为\n$$\ny(1)=A,\\quad y(L)=B,\n$$\n其中 $L>1$ 且 $A,B \\in \\mathbb{R}$。仅从 ODE 算子的线性性质以及具有连续系数的初值问题 (IVP) 解的唯一性出发，应用线性打靶法来确定唯一的初始斜率 $s = y'(1)$，使得解满足在 $x=L$ 处的边界条件。用 $A$，$B$ 和 $L$ 显式地推导出 $s$ 的闭式表达式。你的最终答案必须是单一的闭式表达式。不要提供数值近似解。", "solution": "用户提供的问题已经过验证，被确定为一个有效的、适定的数学问题。\n\n该问题要求使用线性打靶法确定边值问题 (BVP)\n$$\ny''(x) + \\frac{1}{x}\\,y'(x) = 0,\\quad x \\in [1, L]\n$$\n的初始斜率 $s = y'(1)$，其边界条件为\n$$\ny(1)=A,\\quad y(L)=B\n$$\n推导过程需基于线性和初值问题 (IVP) 解的唯一性原理。\n\n线性打靶法通过猜测初始斜率 $s=y'(1)$ 将边值问题转化为一个初值问题。然后我们求解该初值问题，并调整 $s$ 的值，直到解满足在 $x=L$ 处的边界条件。对于线性常微分方程，这种调整可以解析地完成，无需迭代。\n\n让我们定义线性微分算子 $L$ 为\n$$\nL[y] = y''(x) + \\frac{1}{x}\\,y'(x)\n$$\n该边值问题可以写作 $L[y] = 0$，其中 $y(1)=A$ 且 $y(L)=B$。由于 $L>1$，该常微分方程的系数在区间 $[1, L]$ 上是连续的。\n\n我们考虑相关的初值问题，其中初始斜率 $s$ 是一个参数：\n$$\nL[y] = 0, \\quad y(1) = A, \\quad y'(1) = s\n$$\n记该初值问题的唯一解为 $y(x; s)$。我们的目标是找到使 $y(L; s) = B$ 成立的 $s$ 值。\n\n线性打靶法的核心在于叠加原理，该原理适用是因为算子 $L$ 是线性的。我们可以将解 $y(x; s)$ 表示为两个更简单的基本初值问题解的线性组合。\n\n令 $y_1(x)$ 为以下初值问题的解：\n$$\nL[y_1] = 0, \\quad y_1(1) = 1, \\quad y_1'(1) = 0\n$$\n并令 $y_2(x)$ 为以下初值问题的解：\n$$\nL[y_2] = 0, \\quad y_2(1) = 0, \\quad y_2'(1) = 1\n$$\n根据 Picard-Lindelöf 定理，$y_1(x)$ 和 $y_2(x)$ 在 $[1, L]$ 上的存在性和唯一性得到保证，因为常微分方程的系数在该区间上是连续的。\n\n现在，考虑函数 $Y(x) = A y_1(x) + s y_2(x)$。\n根据 $L$ 的线性性质：\n$$\nL[Y] = L[A y_1(x) + s y_2(x)] = A L[y_1(x)] + s L[y_2(x)] = A \\cdot 0 + s \\cdot 0 = 0\n$$\n$Y(x)$ 在 $x=1$ 处的初始条件为：\n$$\nY(1) = A y_1(1) + s y_2(1) = A \\cdot 1 + s \\cdot 0 = A\n$$\n$$\nY'(1) = A y_1'(1) + s y_2'(1) = A \\cdot 0 + s \\cdot 1 = s\n$$\n因此，$Y(x)$ 与 $y(x; s)$ 解的是同一个初值问题。根据初值问题解的唯一性，我们必有 $y(x; s) = Y(x) = A y_1(x) + s y_2(x)$。\n\n现在我们将第二个边界条件 $y(L; s) = B$ 应用于此解：\n$$\ny(L; s) = A y_1(L) + s y_2(L) = B\n$$\n这是一个关于未知斜率 $s$ 的线性代数方程。解出 $s$，我们得到：\n$$\ns y_2(L) = B - A y_1(L)\n$$\n假设 $y_2(L) \\neq 0$，我们发现\n$$\ns = \\frac{B - A y_1(L)}{y_2(L)}\n$$\n为了得到 $s$ 的显式闭式表达式，我们必须找到 $y_1(x)$ 和 $y_2(x)$ 的解析形式。给定的常微分方程是 $y'' + \\frac{1}{x}y' = 0$。这个方程可以看作是乘积法则求导的结果：\n$$\n\\frac{d}{dx}\\left(x y'(x)\\right) = 1 \\cdot y'(x) + x \\cdot y''(x) = x \\left( y'' + \\frac{1}{x} y' \\right) = 0\n$$\n将 $\\frac{d}{dx}(x y') = 0$ 对 $x$ 积分得到：\n$$\nx y'(x) = C_1\n$$\n其中 $C_1$ 是一个积分常数。两边除以 $x$（因为 $x \\ge 1$ 这是允许的），我们有：\n$$\ny'(x) = \\frac{C_1}{x}\n$$\n再次对 $x$ 积分，得到通解：\n$$\ny(x) = \\int \\frac{C_1}{x} dx = C_1 \\ln(x) + C_2\n$$\n\n现在我们将 $y_1(x)$ 和 $y_2(x)$ 的初始条件应用于这个通解。\n\n对于 $y_1(x)$：\n其一般形式为 $y_1(x) = C_1 \\ln(x) + C_2$。\n条件 $y_1(1) = 1$ 意味着 $C_1 \\ln(1) + C_2 = 1$，这给出 $C_2 = 1$。\n其导数为 $y_1'(x) = \\frac{C_1}{x}$。条件 $y_1'(1) = 0$ 意味着 $\\frac{C_1}{1} = 0$，所以 $C_1=0$。\n因此，解为 $y_1(x) = 1$。\n\n对于 $y_2(x)$：\n其一般形式为 $y_2(x) = D_1 \\ln(x) + D_2$。\n条件 $y_2(1) = 0$ 意味着 $D_1 \\ln(1) + D_2 = 0$，这给出 $D_2 = 0$。\n其导数为 $y_2'(x) = \\frac{D_1}{x}$。条件 $y_2'(1) = 1$ 意味着 $\\frac{D_1}{1} = 1$，所以 $D_1=1$。\n因此，解为 $y_2(x) = \\ln(x)$。\n\n现在我们在 $x=L$ 处计算这些解的值：\n$$\ny_1(L) = 1\n$$\n$$\ny_2(L) = \\ln(L)\n$$\n由于 $L>1$，我们有 $\\ln(L) > 0$，所以 $y_2(L) \\neq 0$，$s$ 的表达式是良定义的。\n\n将这些值代入 $s$ 的公式中：\n$$\ns = \\frac{B - A \\cdot y_1(L)}{y_2(L)} = \\frac{B - A \\cdot 1}{\\ln(L)}\n$$\n$$\ns = \\frac{B - A}{\\ln(L)}\n$$\n这就是所求的初始斜率 $s$ 的闭式表达式。", "answer": "$$\n\\boxed{\\frac{B-A}{\\ln(L)}}\n$$", "id": "3248440"}, {"introduction": "现在，是时候将理论付诸实践了。在本练习中，你将编写一个完整的程序，通过求解两个独立的初值问题并线性组合其解来解决一个边值问题 [@problem_id:3248457]。此问题还引入了一个在物理和工程学中常见的实际挑战：如何在数值计算中处理位于无穷远处的边界条件，这要求我们对问题进行合理的截断和近似。", "problem": "实现一个程序，使用线性打靶法来近似求解在半无限域上提出的作为边值问题 (BVP) 的线性二阶常微分方程 (ODE) 的解。其基本依据包括线性二阶常微分方程的定义和线性系统的叠加原理：齐次方程解的任意线性组合也是其解，并且通解可以通过将非齐次问题的一个特解相加来构造。目标边值问题具有以下形式\n$$\ny''(x) + p(x)\\,y'(x) + q(x)\\,y(x) = r(x), \\quad x \\in [a,\\infty),\n$$\n边界条件为\n$$\ny(a) = \\alpha, \\quad \\lim_{x\\to\\infty} y(x) = 0.\n$$\n为了处理无穷远处的边界，通过在一个大的有限点 $L$ 处进行截断来近似半无限域，并施加一个狄利克雷 (Dirichlet) 条件 $y(L)=0$ 或一个受渐近行为启发的罗宾 (Robin) 条件 $y'(L) + \\kappa\\,y(L) = 0$，其中 $\\kappa$ 是一个合适的正常数，在适用时可根据系数在 $x\\to\\infty$ 时的极限行为导出。\n\n您必须从第一性原理推导线性打靶法为何适用于此类问题，以及它如何利用线性叠加来避免非线性求根。然后，按如下方式实现该方法：\n- 将二阶常微分方程重构为关于 $y$ 和 $v=y'$ 的一阶系统。\n- 使用叠加原理，将解构造为一个特解与一个齐次解之和，其中齐次解乘以一个常数，该常数被选择以满足在 $x=L$ 处的边界条件。\n- 使用经典的四阶龙格-库塔 (Runge–Kutta) 方法，以固定的步长 $h$ 对初值问题 (IVP) 进行积分。\n\n您的程序必须能处理在 $x=L$ 处形式为\n$$\nc_1\\,y(L) + c_2\\,y'(L) = \\gamma,\n$$\n的线性泛函边界条件，其中 $c_1$、$c_2$ 和 $\\gamma$ 是给定常数。对于以速率 $\\kappa$ 近似衰减的罗宾条件，使用 $c_1=\\kappa$，$c_2=1$ 和 $\\gamma=0$。对于狄利克雷截断，使用 $c_1=1$，$c_2=0$ 和 $\\gamma=0$。\n\n为下面的每个测试用例计算 $y(x^\\star)$ 的近似值。在 $[a,L]$ 上使用相同的固定步长 $h$，并选择 $h$ 以使 $L$ 和 $x^\\star$ 都位于计算网格上。使用线性打靶法 (LSM)，其中包含一个特解初值问题和一个齐次解初值问题，并使用经典的四阶龙格-库塔 (RK4) 积分器求解初值问题。\n\n测试套件：\n- 情况 $1$ (常系数，罗宾近似):\n  - $a=0$, $L=8$, $h=0.01$, $x^\\star=1$, $\\alpha=1$,\n  - $p(x)=0$, $q(x)=-1$, $r(x)=0$,\n  - `L`处的边界: $y'(L)+\\kappa y(L)=0$ 其中 $\\kappa=1$。\n- 情况 $2$ (更快衰减，罗宾近似):\n  - $a=0$, $L=8$, $h=0.01$, $x^\\star=1$, $\\alpha=1$,\n  - $p(x)=0$, $q(x)=-4$, $r(x)=0$,\n  - `L`处的边界: $y'(L)+\\kappa y(L)=0$ 其中 $\\kappa=2$。\n- 情况 $3$ (变系数，罗宾近似):\n  - $a=0$, $L=8$, $h=0.01$, $x^\\star=1$, $\\alpha=1$,\n  - $p(x)=\\dfrac{2}{1+x}$, $q(x)=-1$, $r(x)=0$,\n  - `L`处的边界: $y'(L)+\\kappa y(L)=0$ 其中 $\\kappa=1$。\n- 情况 $4$ (在 $L$ 处的狄利克雷截断):\n  - $a=0$, $L=8$, $h=0.01$, $x^\\star=1$, $\\alpha=1$,\n  - $p(x)=0$, $q(x)=-1$, $r(x)=0$,\n  - `L`处的边界: $y(L)=0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。具体来说，打印\n$[y_1,y_2,y_3,y_4]$,\n其中 $y_k$ 是测试用例 $k$ 的 $y(x^\\star)$ 的数值近似值，按此顺序排列。", "solution": "所述问题具有科学依据、是适定的、客观且完整的。它提出了一个标准的数值任务——使用线性打靶法和四阶龙格-库塔积分器在半无限域上求解线性二阶边值问题 (BVP)。所有参数和函数都得到了明确定义，域截断方法是数值分析中一种有效且常用的技术。因此，该问题被认为是**有效的**。\n\n线性打靶法的理论基础依赖于线性常微分方程 (ODE) 的叠加原理。我们的任务是求解以下边值问题：\n$$\ny''(x) + p(x) y'(x) + q(x) y(x) = r(x), \\quad x \\in [a, \\infty)\n$$\n受以下边界条件约束：\n$$\ny(a) = \\alpha, \\quad \\lim_{x\\to\\infty} y(x) = 0\n$$\n在半无限域 $[a, \\infty)$ 上的问题通过在足够大的值 $x=L$ 处截断域并在此点施加一个近似的边界条件来近似。因此，该边值问题被转化为：\n$$\ny''(x) + p(x) y'(x) + q(x) y(x) = r(x), \\quad x \\in [a, L]\n$$\n$$\ny(a) = \\alpha\n$$\n$$\nc_1 y(L) + c_2 y'(L) = \\gamma\n$$\n其中常数 $c_1$、$c_2$ 和 $\\gamma$ 定义了在截断边界 $x=L$ 处的条件。\n\n线性打靶法将此边值问题重构为一对初值问题 (IVP)。这之所以可能，是由于控制常微分方程的线性性质。叠加原理指出，如果 $y_1(x)$ 和 $y_2(x)$ 是线性齐次常微分方程的解，那么任何线性组合 $C_1 y_1(x) + C_2 y_2(x)$ 也是一个解。此外，非齐次线性常微分方程的通解是该非齐次方程的任意一个特解与相应齐次方程的通解之和。\n\n我们将边值问题的解 $y(x)$ 构造为两个特定初值问题解的线性组合。令 $y_1(x)$ 为满足第一个边界条件及其导数上的一个方便、任意条件的非齐次常微分方程的解。一个标准的选择是：\n$$\n\\text{IVP 1:} \\quad y_1''(x) + p(x) y_1'(x) + q(x) y_1(x) = r(x), \\quad \\text{其中} \\quad y_1(a) = \\alpha, \\quad y_1'(a) = 0\n$$\n令 $y_2(x)$ 为相应齐次常微分方程的解，其初始条件的选择要确保它与任何平凡解线性无关，并且不干扰 $y(a)=\\alpha$ 条件。一个标准的选择是：\n$$\n\\text{IVP 2:} \\quad y_2''(x) + p(x) y_2'(x) + q(x) y_2(x) = 0, \\quad \\text{其中} \\quad y_2(a) = 0, \\quad y_2'(a) = 1\n$$\n现在，我们提出一个形式如下的边值问题的解：\n$$\ny(x) = y_1(x) + C y_2(x)\n$$\n其中 $C$ 是一个待定常数。让我们来验证这种形式是否满足该常微分方程和边界条件。\n首先，将 $y(x)$ 代入常微分方程：\n$$\ny'' + p y' + q y = (y_1'' + C y_2'') + p (y_1' + C y_2') + q (y_1 + C y_2)\n$$\n$$\n= (y_1'' + p y_1' + q y_1) + C (y_2'' + p y_2' + q y_2)\n$$\n$$\n= r(x) + C \\cdot 0 = r(x)\n$$\n因此，对于任何 $C$ 值，$y(x)$ 都是非齐次常微分方程的一个解。\n\n其次，我们检查在 $x=a$ 处的边界条件：\n$$\ny(a) = y_1(a) + C y_2(a) = \\alpha + C \\cdot 0 = \\alpha\n$$\n对于任何 $C$ 值，此条件都得到满足。两个初值问题的初始条件选择保证了这一结果。\n\n最后，通过施加在 $x=L$ 处的第二个边界条件来确定常数 $C$：\n$$\nc_1 y(L) + c_2 y'(L) = \\gamma\n$$\n代入 $y(L) = y_1(L) + C y_2(L)$ 和 $y'(L) = y_1'(L) + C y_2'(L)$：\n$$\nc_1 (y_1(L) + C y_2(L)) + c_2 (y_1'(L) + C y_2'(L)) = \\gamma\n$$\n这是一个关于 $C$ 的线性代数方程。重新整理各项以求解 $C$：\n$$\nc_1 y_1(L) + c_2 y_1'(L) + C (c_1 y_2(L) + c_2 y_2'(L)) = \\gamma\n$$\n$$\nC = \\frac{\\gamma - c_1 y_1(L) - c_2 y_1'(L)}{c_1 y_2(L) + c_2 y_2'(L)}\n$$\n这就确定了唯一的 $C$ 值，以确保解 $y(x)$ 满足在 $x=L$ 处的边界条件，前提是分母不为零。分母为零意味着齐次边值问题有非平凡解，这表明原始边值问题可能没有唯一解。\n\n对于数值实现，每个二阶常微分方程都被转化为一个包含两个一阶常微分方程的系统。令 $\\mathbf{u}(x) = [y(x), y'(x)]^T = [u_1(x), u_2(x)]^T$。该二阶常微分方程变为：\n$$\n\\frac{d\\mathbf{u}}{dx} = \\begin{pmatrix} u_1' \\\\ u_2' \\end{pmatrix} = \\begin{pmatrix} u_2 \\\\ r(x) - p(x)u_2 - q(x)u_1 \\end{pmatrix} = \\mathbf{f}(x, \\mathbf{u})\n$$\n这两个初值问题使用经典的四阶龙格-库塔 (RK4) 方法从 $x=a$ 到 $x=L$ 进行数值求解。对于步长 $h$，从 $x_i$ 到 $x_{i+1} = x_i + h$ 的通用系统 $\\mathbf{u}' = \\mathbf{f}(x, \\mathbf{u})$ 的更新规则是：\n$$\n\\mathbf{u}_{i+1} = \\mathbf{u}_i + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n其中\n$$\n\\mathbf{k}_1 = \\mathbf{f}(x_i, \\mathbf{u}_i), \\quad \\mathbf{k}_2 = \\mathbf{f}(x_i + h/2, \\mathbf{u}_i + h/2 \\cdot \\mathbf{k}_1), \\quad \\mathbf{k}_3 = \\mathbf{f}(x_i + h/2, \\mathbf{u}_i + h/2 \\cdot \\mathbf{k}_2), \\quad \\mathbf{k}_4 = \\mathbf{f}(x_i + h, \\mathbf{u}_i + h \\cdot \\mathbf{k}_3)\n$$\n算法流程如下：\n1.  将 $y_1$ 和 $y_2$ 的初值问题定义为一阶系统。对于 $y_1$，系统是 $\\mathbf{u}_1' = [u_{1,2}, r - p u_{1,2} - q u_{1,1}]^T$，初始条件为 $\\mathbf{u}_1(a) = [\\alpha, 0]^T$。对于 $y_2$，系统是 $\\mathbf{u}_2' = [u_{2,2}, -p u_{2,2} - q u_{2,1}]^T$，初始条件为 $\\mathbf{u}_2(a) = [0, 1]^T$。\n2.  使用 RK4 方法将两个系统从 $x=a$ 积分到 $x=L$。这将产生 $\\{y_1(L), y_1'(L)\\}$ 和 $\\{y_2(L), y_2'(L)\\}$ 的数值近似值。在积分过程中，也存储 $y_1(x^\\star)$ 和 $y_2(x^\\star)$ 的值。\n3.  使用推导出的公式和步骤 2 中的数值计算常数 $C$。\n4.  通过叠加计算在 $x=x^\\star$ 处的最终近似解：$y(x^\\star) \\approx y_1(x^\\star) + C y_2(x^\\star)$。\n\n此过程应用于问题中指定的每个测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the linear shooting method to solve a set of BVPs\n    and prints the results in the specified format.\n    \"\"\"\n\n    def linear_shooting(p_func, q_func, r_func, a, L, h, alpha, c1, c2, gamma, x_star):\n        \"\"\"\n        Solves a linear second-order BVP using the linear shooting method with RK4.\n\n        The method solves two IVPs:\n        1. y1'' + p*y1' + q*y1 = r,  with y1(a) = alpha, y1'(a) = 0\n        2. y2'' + p*y2' + q*y2 = 0,  with y2(a) = 0,     y2'(a) = 1\n\n        The solution is y = y1 + C*y2, where C is chosen to satisfy the BC at L.\n        \"\"\"\n        \n        N = int(round((L - a) / h))\n        x_grid = np.linspace(a, L, N + 1)\n        x_star_idx = int(round((x_star - a) / h))\n\n        def rk4_step(f, x, u, h_step):\n            k1 = f(x, u)\n            k2 = f(x + h_step / 2.0, u + (h_step / 2.0) * k1)\n            k3 = f(x + h_step / 2.0, u + (h_step / 2.0) * k2)\n            k4 = f(x + h_step, u + h_step * k3)\n            return u + (h_step / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\n        # System for IVP 1 (non-homogeneous)\n        def f1(x, u):\n            y, v = u\n            return np.array([v, r_func(x) - p_func(x) * v - q_func(x) * y])\n\n        # System for IVP 2 (homogeneous)\n        def f2(x, u):\n            y, v = u\n            return np.array([v, -p_func(x) * v - q_func(x) * y])\n\n        # Initial conditions\n        u1 = np.array([alpha, 0.0])  # [y1(a), y1'(a)]\n        u2 = np.array([0.0, 1.0])    # [y2(a), y2'(a)]\n\n        y1_at_x_star = 0.0\n        y2_at_x_star = 0.0\n\n        # Integrate both IVPs from a to L\n        for i in range(N):\n            if i == x_star_idx:\n                y1_at_x_star = u1[0]\n                y2_at_x_star = u2[0]\n\n            u1 = rk4_step(f1, x_grid[i], u1, h)\n            u2 = rk4_step(f2, x_grid[i], u2, h)\n\n        # Values at L are the final state of u1 and u2\n        y1_L, v1_L = u1\n        y2_L, v2_L = u2\n\n        # Calculate the constant C\n        # C = (gamma - c1*y1(L) - c2*y1'(L)) / (c1*y2(L) + c2*y2'(L))\n        numerator = gamma - c1 * y1_L - c2 * v1_L\n        denominator = c1 * y2_L + c2 * v2_L\n\n        if abs(denominator)  1e-15:\n            # This case corresponds to non-unique or no solutions.\n            # Return NaN for robustness, though not expected in this problem.\n            return float('nan')\n        \n        C = numerator / denominator\n\n        # Final solution at x_star by superposition\n        y_at_x_star = y1_at_x_star + C * y2_at_x_star\n\n        return y_at_x_star\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: y'' - y = 0, y(0)=1, y'(8)+y(8)=0\n        {\n            'p': lambda x: 0.0, 'q': lambda x: -1.0, 'r': lambda x: 0.0,\n            'a': 0.0, 'L': 8.0, 'h': 0.01, 'x_star': 1.0, 'alpha': 1.0,\n            'c1': 1.0, 'c2': 1.0, 'gamma': 0.0\n        },\n        # Case 2: y'' - 4y = 0, y(0)=1, y'(8)+2y(8)=0\n        {\n            'p': lambda x: 0.0, 'q': lambda x: -4.0, 'r': lambda x: 0.0,\n            'a': 0.0, 'L': 8.0, 'h': 0.01, 'x_star': 1.0, 'alpha': 1.0,\n            'c1': 2.0, 'c2': 1.0, 'gamma': 0.0\n        },\n        # Case 3: y'' + (2/(1+x))y' - y = 0, y(0)=1, y'(8)+y(8)=0\n        {\n            'p': lambda x: 2.0 / (1.0 + x), 'q': lambda x: -1.0, 'r': lambda x: 0.0,\n            'a': 0.0, 'L': 8.0, 'h': 0.01, 'x_star': 1.0, 'alpha': 1.0,\n            'c1': 1.0, 'c2': 1.0, 'gamma': 0.0\n        },\n        # Case 4: y'' - y = 0, y(0)=1, y(8)=0\n        {\n            'p': lambda x: 0.0, 'q': lambda x: -1.0, 'r': lambda x: 0.0,\n            'a': 0.0, 'L': 8.0, 'h': 0.01, 'x_star': 1.0, 'alpha': 1.0,\n            'c1': 1.0, 'c2': 0.0, 'gamma': 0.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = linear_shooting(\n            p_func=case['p'],\n            q_func=case['q'],\n            r_func=case['r'],\n            a=case['a'],\n            L=case['L'],\n            h=case['h'],\n            alpha=case['alpha'],\n            c1=case['c1'],\n            c2=case['c2'],\n            gamma=case['gamma'],\n            x_star=case['x_star']\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3248457"}, {"introduction": "标准的“单次打靶”法虽然强大，但它有一个致命的弱点：在求解长区间上的问题时，可能会出现数值不稳定性。本次练习将直面这一挑战，并介绍一种更为稳健的“多次打靶”法作为解决方案 [@problem_id:3248449]。通过亲手实现并比较这两种方法，你将深刻体会到单次打靶法的局限性，并理解为何以及何时需要采用这种更先进的技巧。", "problem": "您需要实现并测试一种用于线性两点边值问题的多重打靶法（multiple shooting，也称并行或分段打靶法），以克服标准单次打靶法在长区间上可能出现的不稳定性和病态问题。请处理以下边值问题：\n给定 $L \\in \\mathbb{R}_{0}$ 以及边界数据 $\\alpha, \\beta \\in \\mathbb{R}$，求 $y:[0,L] \\to \\mathbb{R}$ 使得\n$\ny''(x) - y(x) = 0,\\quad x \\in [0,L],\\quad y(0) = \\alpha,\\quad y(L) = \\beta.\n$\n为了验证，其精确解为\n$\ny(x) = \\alpha\\,\\frac{\\sinh(L-x)}{\\sinh(L)} + \\beta\\,\\frac{\\sinh(x)}{\\sinh(L)}.\n$\n\n从任何标量二阶线性常微分方程都可以重写为一阶系统的基本出发点，将该边值问题重构为一阶线性系统\n$\n\\mathbf{u}'(x) = A(x)\\,\\mathbf{u}(x),\\quad \\mathbf{u}(x) \\in \\mathbb{R}^2,\n$\n其中 $\\mathbf{u}(x) = \\begin{bmatrix}y(x)\\\\y'(x)\\end{bmatrix}$ 且 $A(x) = \\begin{bmatrix}0  1\\\\ 1  0\\end{bmatrix}$ 为常数。利用线性初值问题的流和状态转移矩阵，在 $[0,L]$ 的一个均匀划分上推导多重打靶法公式，该划分包含 $m$ 个子区间，节点为 $x_k = k\\,h$, $h = L/m$, $k=0,1,\\dots,m$。在每个子区间 $[x_k,x_{k+1}]$ 上，通过数值积分矩阵微分方程\n$\n\\frac{d}{dx}\\Phi(x) = A(x)\\,\\Phi(x),\\quad \\Phi(x_k) = I,\n$\n来近似计算将 $\\mathbf{u}(x_k)$ 映射到 $\\mathbf{u}(x_{k+1})$ 的状态转移矩阵 $\\Phi_k$。积分使用经典的 4 阶龙格-库塔方法，每个子区间的步数固定。构建一个线性块系统，该系统强制执行：\n- 内部节点间的连续性，即对于 $k=0,1,\\dots,m-1$，有 $\\mathbf{u}(x_{k+1}) - \\Phi_k\\,\\mathbf{u}(x_k) = \\mathbf{0}$，以及\n- 边界条件 $y(0) = \\alpha$ 和 $y(L) = \\beta$，\n并求解该系统以获得未知的节点状态 $\\mathbf{u}(x_k)$，$k=0,1,\\dots,m-1$。从这些状态和最后一个子区间上的最终传播中恢复网格节点 $x_k$ 处的 $y$ 值。通过比较数值解 $y(x_k)$ 和精确解 $y(x_k)$，计算在网格节点 $x_k$ 处的最大绝对误差。\n\n同时实现一个标准的单次打靶法作为基准。使用线性叠加原理：在 $[0,L]$ 上积分两个初值问题，初始数据分别为 $\\mathbf{u}^{(1)}(0) = \\begin{bmatrix}\\alpha\\\\0\\end{bmatrix}$ 和 $\\mathbf{u}^{(2)}(0) = \\begin{bmatrix}0\\\\1\\end{bmatrix}$，以确定满足 $y(L)=\\beta$ 所需的初始斜率，然后使用该初始斜率从 $x=0$ 到 $x=L$ 积分一次，并记录相同网格节点上的值 $y(x_k)$。使用相同的 4 阶龙格-库塔方法，每个子区间的步数固定，来为该基准构建状态转移矩阵。\n\n实现一个程序，对于每个测试用例，返回一个包含两个元素的列表：\n- 单次打靶法的最大绝对节点误差，以及\n- 多重打靶法的最大绝对节点误差，\n每个都为浮点数。\n\n测试套件：\n- 测试用例 1：$L=20$，$\\alpha=0$，$\\beta=1$，$m=10$，多重打靶法每个子区间的步数 $=40$，单次打靶法每个子区间的步数 $=40$。\n- 测试用例 2：$L=20$，$\\alpha=1$，$\\beta=2$，$m=1$，多重打靶法每个子区间的步数 $=2000$，单次打靶法每个子区间的步数 $=2000$。\n- 测试用例 3：$L=10$，$\\alpha=0.5$，$\\beta=1.5$，$m=5$，多重打靶法每个子区间的步数 $=50$，单次打靶法每个子区间的步数 $=50$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身必须是按上述顺序排列的含两个元素的列表。例如，一个有效的输出如下所示\n$\n[[e_{1,\\text{single}},e_{1,\\text{multi}}],[e_{2,\\text{single}},e_{2,\\text{multi}}],[e_{3,\\text{single}},e_{3,\\text{multi}}]].\n$", "solution": "用户希望使用单次和多重打靶法解决一个线性两点边值问题，并比较它们的精度。\n\n### 问题验证\n\n**第 1 步：提取已知信息**\n\n- **边值问题 (BVP):**\n  - 方程: $y''(x) - y(x) = 0$，对于 $x \\in [0,L]$。\n  - 边界条件: $y(0) = \\alpha$, $y(L) = \\beta$。\n  - 参数: $L \\in \\mathbb{R}_{0}$, $\\alpha, \\beta \\in \\mathbb{R}$。\n- **一阶系统:**\n  - 状态向量: $\\mathbf{u}(x) = [y(x), y'(x)]^T$。\n  - 系统: $\\mathbf{u}'(x) = A\\mathbf{u}(x)$，其中 $A = \\begin{bmatrix}0  1\\\\ 1  0\\end{bmatrix}$。\n- **数值方法:**\n  - 两种方法都必须使用经典的 4 阶龙格-库塔方法 (RK4)。\n  - **多重打靶法:** 将 $[0,L]$ 划分为 $m$ 个子区间 $[x_k, x_{k+1}]$，其中 $x_k = k(L/m)$。基于连续性条件 $\\mathbf{u}(x_{k+1}) = \\Phi_k \\mathbf{u}(x_k)$（其中 $\\Phi_k$ 是子区间上的状态转移矩阵）和边界条件，构建一个块线性系统。\n  - **单次打靶法:** 使用线性叠加原理，通过求解两个初值问题（或等效地，通过使用整个区间 $[0,L]$ 上的状态转移矩阵）来找到正确的初始斜率 $y'(0)$，然后在 $[0,L]$ 上执行单次积分。\n- **误差度量:**\n  - 在网格节点 $x_k$ 处（$k=0, \\dots, m$）的最大绝对误差。\n- **测试套件:**\n  - 用例 1: $L=20, \\alpha=0, \\beta=1, m=10$，每个子区间的步数 $=40$。\n  - 用例 2: $L=20, \\alpha=1, \\beta=2, m=1$，每个子区间的步数 $=2000$。\n  - 用例 3: $L=10, \\alpha=0.5, \\beta=1.5, m=5$，每个子区间的步数 $=50$。\n- **用于验证的精确解:**\n  - $y(x) = \\alpha\\,\\frac{\\sinh(L-x)}{\\sinh(L)} + \\beta\\,\\frac{\\sinh(x)}{\\sinh(L)}$。\n\n**第 2 步：使用提取的已知信息进行验证**\n\n- **科学上合理:** 该问题是一个具有常系数的、完善的线性边值问题。所提供的精确解是正确的，通过将其代入微分方程和边界条件可以验证。将其重构为一阶系统以及应用打靶法是数值分析中的标准技术。选择方程 $y''-y=0$ 是展示单次打靶法在长区间上失效的经典例子，因为它的基本解 $e^x$ 和 $e^{-x}$ 具有截然不同的增长率，导致病态问题。\n- **适定的:** 该边值问题是线性的且适定的。只要相关的基本解分量在右边界非零，单次打靶法就是适定的，这一点在此成立，因为对于 $L  0$，$\\sinh(L) \\ne 0$。多重打靶法会产生一个大型、稀疏、块结构的线性系统。对于一个适定的边值问题，这个系统是非奇异的。\n- **目标明确:** 问题使用精确的数学和计算语言陈述。\n- **完整性和一致性:** 问题提供了所有必要的数据和方法约束。测试用例被完全指定。在多重打靶系统组装的描述中存在轻微的模糊性，但一个标准的“一次性”公式（其中所有节点的状态都被视为未知数）是一个有效且稳健的解释。测试用例 2，其中 $m=1$，作为一个一致性检查，因为在这种配置下，多重打靶法的行为应与单次打靶法非常相似。\n\n**第 3 步：结论与行动**\n\n该问题是**有效的**。它是一个在微分方程数值方法领域内适定、科学合理且明确定义的任务。我现在将继续进行求解。\n\n### 基于原理的解决方案设计\n\n问题的核心在于边值问题的数值解，这与更直接的初值问题 (IVP) 的数值解形成对比。打靶法将一个边值问题转换为一个或多个初值问题。\n\n**1. 系统公式化与状态转移矩阵**\n\n二阶常微分方程 $y'' - y = 0$ 被转换为一阶系统 $\\mathbf{u}' = A\\mathbf{u}$，其中 $\\mathbf{u} = [y, y']^T$ 且 $A = \\begin{bmatrix}0  1\\\\ 1  0\\end{bmatrix}$。这个线性自治系统的解可以用状态转移矩阵（或基本矩阵）$\\Phi(x)$ 表示，它将一个解从初始点 $x_0$ 传播到点 $x$：$\\mathbf{u}(x) = \\Phi(x-x_0)\\mathbf{u}(x_0)$。矩阵 $\\Phi$ 本身满足矩阵微分方程 $\\Phi' = A\\Phi$，初始条件为 $\\Phi(0) = I$，其中 $I$ 是单位矩阵。\n\n我们将通过使用经典的四阶龙格-库塔 (RK4) 方法对其控制微分方程进行积分，来数值近似给定区间上的 $\\Phi$。这将是一个核心的效用函数 `compute_phi`。\n\n**2. 单次打靶法**\n\n单次打靶法的原理是找到正确的未知初始条件 $y'(0)$，使其“击中”在 $x=L$ 处的目标边界条件。\n在 $x=L$ 处的解通过整个区间 $[0,L]$ 上的状态转移矩阵 $\\Phi(L)$ 与在 $x=0$ 处的初始条件相关联：\n$$ \\begin{bmatrix} y(L) \\\\ y'(L) \\end{bmatrix} = \\Phi(L) \\begin{bmatrix} y(0) \\\\ y'(0) \\end{bmatrix} $$\n我们已知 $y(0) = \\alpha$ 并且要求 $y(L)=\\beta$。展开第一行得到：\n$$ \\beta = \\Phi_{11}(L)\\alpha + \\Phi_{12}(L)y'(0) $$\n我们可以解出未知的初始斜率：\n$$ y'(0) = \\frac{\\beta - \\Phi_{11}(L)\\alpha}{\\Phi_{12}(L)} $$\n一旦完整的初始向量 $\\mathbf{u}(0) = [\\alpha, y'(0)]^T$ 已知，边值问题就简化为单个初值问题。我们使用 RK4 从 $x=0$ 到 $x=L$ 求解这个初值问题，并在指定的网格节点处存储解 $y(x_k)$。\n该方法的主要弱点源于矩阵 $A$ 的性质。其特征值为 $\\pm 1$，导致解包含 $e^x$ 和 $e^{-x}$。对于大的 $L$，$\\Phi(L)$ 的元素会变得巨大（例如 $\\cosh(L)$），这使得 $y'(0)$ 的计算容易发生灾难性抵消，并使初值问题变得刚性且难以精确求解。\n\n**3. 多重打靶法**\n\n多重打靶法通过将长区间 $[0,L]$ 分割成 $m$ 个更小、更易于管理的子区间 $[x_k, x_{k+1}]$ 来缓解这个问题。\n在每个子区间上，我们通过一个局部状态转移矩阵 $\\Phi_k$ 将端点处的状态联系起来：\n$$ \\mathbf{u}(x_{k+1}) = \\Phi_k \\mathbf{u}(x_k), \\quad \\text{对于 } k=0, 1, \\dots, m-1 $$\n在这个问题中，由于 $A$ 是常数且子区间长度相等 $h=L/m$，所有的 $\\Phi_k$ 都是相同的。\n我们将状态向量 $\\mathbf{u}(x_0), \\mathbf{u}(x_1), \\dots, \\mathbf{u}(x_m)$ 视为未知数。这给出了 $2(m+1)$ 个标量变量。我们组装一个包含 $2(m+1)$ 个线性方程的系统：\n- **在 $x=0$ 处的边界条件**：$y(x_0) = \\alpha$。（1 个方程）\n- **内部节点间的连续性**：$\\mathbf{u}(x_{k+1}) - \\Phi_k \\mathbf{u}(x_k) = \\mathbf{0}$ 对于 $k=0, \\dots, m-1$。（$2m$ 个方程）\n- **在 $x=L$ 处的边界条件**：$y(x_m) = \\beta$。（1 个方程）\n\n这就形成了一个大型、稀疏、块结构的线性系统，形式为 $M\\mathbf{S} = \\mathbf{b}$，其中 $\\mathbf{S} = [\\mathbf{u}(x_0)^T, \\dots, \\mathbf{u}(x_m)^T]^T$。这个系统可以使用标准的线性代数库例程来求解。由于状态转移矩阵 $\\Phi_k$ 是在短区间上计算的，它们的元素保持较小，整个系统 $M$ 是良态的，从而避免了单次打靶法的数值稳定性问题。解向量 $\\mathbf{S}$ 直接提供了所有网格节点上 $y(x_k)$ 的数值近似。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    # This is the ODE system function u' = f(u) = A @ u\n    def ode_system_f(u, A):\n        return A @ u\n\n    # Generic RK4 stepper for a vector or matrix state Y, solving Y' = A @ Y\n    def rk4_step(A, Y, h):\n        k1 = h * ode_system_f(Y, A)\n        k2 = h * ode_system_f(Y + 0.5 * k1, A)\n        k3 = h * ode_system_f(Y + 0.5 * k2, A)\n        k4 = h * ode_system_f(Y + k3, A)\n        return Y + (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0\n\n    # Computes the state transition matrix Phi over an interval.\n    def compute_phi(A, interval_len, n_steps):\n        h_rk = interval_len / n_steps\n        # Start with the identity matrix\n        Phi = np.identity(A.shape[0], dtype=float)\n        for _ in range(n_steps):\n            Phi = rk4_step(A, Phi, h_rk)\n        return Phi\n\n    # Exact solution of the BVP for verification\n    def exact_solution(x, L, alpha, beta):\n        # The problem statement guarantees L > 0, so sinh(L) is not zero.\n        # numpy's sinh handles large arguments up to ~709, returning 'inf' beyond that.\n        # This is sufficient for the test cases provided.\n        sinh_L = np.sinh(L)\n        return alpha * np.sinh(L - x) / sinh_L + beta * np.sinh(x) / sinh_L\n\n    def solve_single_shooting(L, alpha, beta, m, steps_per_sub):\n        A = np.array([[0.0, 1.0], [1.0, 0.0]])\n        total_steps = m * steps_per_sub\n        x_nodes = np.linspace(0, L, m + 1)\n\n        # 1. Find the initial slope y'(0) using the shooting condition.\n        # This requires the state transition matrix over the full interval [0, L].\n        Phi_L = compute_phi(A, L, total_steps)\n        phi_11 = Phi_L[0, 0]\n        phi_12 = Phi_L[0, 1]\n        \n        # Check for singularity. For this problem, phi_12 = sinh(L) which is non-zero for L>0.\n        if abs(phi_12)  1e-15:\n            return np.inf\n\n        # From y(L) = beta = phi_11*y(0) + phi_12*y'(0), solve for y'(0).\n        y0_prime = (beta - phi_11 * alpha) / phi_12\n        u0 = np.array([alpha, y0_prime], dtype=float)\n\n        # 2. Integrate the IVP with the correct initial condition u0.\n        y_numeric = np.zeros(m + 1, dtype=float)\n        y_numeric[0] = alpha\n        h_rk = L / total_steps\n        u_current = u0.copy()\n        \n        for k in range(m):\n            # Integrate over one subinterval [x_k, x_{k+1}]\n            for _ in range(steps_per_sub):\n                u_current = rk4_step(A, u_current, h_rk)\n            y_numeric[k + 1] = u_current[0]\n            \n        # 3. Compute the maximum absolute error at the nodes.\n        y_exact = exact_solution(x_nodes, L, alpha, beta)\n        max_error = np.max(np.abs(y_numeric - y_exact))\n        \n        return max_error\n\n    def solve_multiple_shooting(L, alpha, beta, m, steps_per_sub):\n        if m == 0: return np.nan\n\n        A = np.array([[0.0, 1.0], [1.0, 0.0]])\n        h_sub = L / m\n        x_nodes = np.linspace(0, L, m + 1)\n        \n        # 1. Compute state transition matrix for a subinterval.\n        # Because A is constant, Phi is the same for all subintervals.\n        Phi = compute_phi(A, h_sub, steps_per_sub)\n        \n        # 2. Assemble and solve the block linear system M*S = b.\n        # Unknowns S = [u0, u1, ..., um]^T. Total size is 2*(m+1).\n        N = 2 * (m + 1)\n        M = np.zeros((N, N), dtype=float)\n        b = np.zeros(N, dtype=float)\n        I = np.identity(2, dtype=float)\n        \n        # BC at x=0: y(0) = alpha\n        M[0, 0] = 1.0\n        b[0] = alpha\n        \n        # Continuity conditions: u_{k+1} - Phi * u_k = 0\n        for k in range(m):\n            row_idx = 1 + 2 * k\n            col_idx_k = 2 * k\n            col_idx_k_plus_1 = 2 * (k + 1)\n            \n            M[row_idx:row_idx+2, col_idx_k:col_idx_k+2] = -Phi\n            M[row_idx:row_idx+2, col_idx_k_plus_1:col_idx_k_plus_1+2] = I\n        \n        # BC at x=L: y(L) = beta (which is y_m)\n        M[N-1, N-2] = 1.0\n        b[N-1] = beta\n        \n        try:\n            S = np.linalg.solve(M, b)\n        except np.linalg.LinAlgError:\n            return np.inf\n\n        # 3. Extract solution and compute error.\n        y_numeric = S[0::2] # Extract y_k values from solution vector\n        y_exact = exact_solution(x_nodes, L, alpha, beta)\n        max_error = np.max(np.abs(y_numeric - y_exact))\n        \n        return max_error\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, alpha, beta, m, steps_per_subinterval)\n        (20.0, 0.0, 1.0, 10, 40),\n        (20.0, 1.0, 2.0, 1, 2000),\n        (10.0, 0.5, 1.5, 5, 50),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, alpha, beta, m, steps = case\n        err_single = solve_single_shooting(L, alpha, beta, m, steps)\n        err_multi = solve_multiple_shooting(L, alpha, beta, m, steps)\n        results.append([err_single, err_multi])\n\n    # Final print statement in the exact required format.\n    # The format requires no spaces, which str() adds by default for lists.\n    # So we build the string manually.\n    formatted_results = []\n    for res_pair in results:\n        formatted_results.append(f\"[{res_pair[0]},{res_pair[1]}]\")\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3248449"}]}