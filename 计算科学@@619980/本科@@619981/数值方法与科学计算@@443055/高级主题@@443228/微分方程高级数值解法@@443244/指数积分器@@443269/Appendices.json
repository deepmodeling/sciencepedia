{"hands_on_practices": [{"introduction": "这项基础练习将指导你直接从常数变易公式出发，推导两种核心的一阶指数积分方法：Lawson 方法和指数欧拉方法。通过在一个具体的半线性测试问题上实现和比较这两种方法的结构与性能，你将为后续更深入的学习打下坚实的基础。这个过程不仅能加深你对指数积分法核心思想的理解，还能锻炼你分析数值方法收敛阶的实践能力。[@problem_id:3227424]", "problem": "你需要推导、实现并测试两种一阶指数积分子，用于求解形式为 $y' = A y + N(y)$ 的半线性常微分方程。这些推导基于常数变易公式和线性算子指数的基本定义。在标量情况下进行研究，其中 $A$ 由实标量参数 $-\\lambda$ 表示（$\\lambda > 0$），非线性项为 $N(y) = \\mu y - \\mu y^2$。初始值为 $y(0) = y_0$。\n\n1. 推导任务。从常数变易公式和线性算子指数的定义出发，推导：\n   - 一阶 Lawson 方法，该方法通过含时变量替换消除线性部分，然后在变换后的坐标系中应用显式欧拉法。\n   - 一阶指数欧拉法，该方法通过对常数变易积分应用一阶求积得到。\n\n   你的推导必须明确指出离散时间更新公式，用步长 $h$、A 的矩阵指数（在标量情况下为数的指数）以及非线性项 $N(\\cdot)$ 来表示。\n\n2. 精确参考解。对于标量问题 $y' = -\\lambda y + \\mu y - \\mu y^2$ 且 $y(0) = y_0$，求出一个闭式精确解 $y(t)$，你将用它作为误差计算的参考。用 $\\lambda$、$\\mu$、$y_0$ 和 $t$ 表示 $y(t)$。确保你的表达式既覆盖一般情况 $\\mu - \\lambda \\neq 0$，也覆盖极限情况 $\\mu - \\lambda = 0$。\n\n3. 实现任务。实现一个程序，该程序：\n   - 使用上述两种推导出的格式，在步长为 $h = T/m$（其中 $m$ 为指定的正整数）的均匀网格上对标量问题进行积分，直至最终时间 $T$，并返回在 $t = T$ 时的数值解。\n   - 通过与第 2 部分的精确解进行比较，计算在 $t = T$ 时的绝对全局误差。\n   - 使用两次步长减半的连续细化来计算观测阶估计：如果 $e(h)$ 和 $e(h/2)$ 分别是步长为 $h$ 和 $h/2$ 时的误差，则观测阶 $p$ 估计为 $p \\approx \\log\\left(e(h)/e(h/2)\\right) / \\log(2)$。\n\n4. 测试套件。使用以下三组参数和步数：\n   - 情况 A（理想情况，中等刚性）：$(\\lambda, \\mu, y_0, T) = (50, 1, 0.1, 1)$，步数 $m \\in \\{50, 100, 200, 400\\}$。\n   - 情况 B（边界情况，净线性增长消失）：$(\\lambda, \\mu, y_0, T) = (1, 1, 0.5, 1)$，步数 $m \\in \\{50, 100, 200, 400\\}$。\n   - 情况 C（高刚性，短时域）：$(\\lambda, \\mu, y_0, T) = (200, 2, 0.9, 0.5)$，步数 $m \\in \\{50, 100, 200, 400\\}$。\n\n   对于每种情况：\n   - 计算两种方法在 $m = 200$ 和 $m = 400$ 时于 $t=T$ 的绝对全局误差，并用这些误差如上所述为每种方法估计观测阶 $p$。\n   - 计算在最细步数 $m = 400$ 时，Lawson 方法误差与指数欧拉法误差的比率。\n\n5. 输出规范。你的程序必须生成单行输出，其中包含一个包含 9 个浮点数的扁平列表，顺序如下：\n   - 对于情况 A：使用 $(m=200, m=400)$ 计算的 Lawson 方法观测阶，使用 $(m=200, m=400)$ 计算的指数欧拉法观测阶，以及在 $m=400$ 时的 Lawson 误差与指数欧拉误差之比。\n   - 对于情况 B：使用 $(m=200, m=400)$ 计算的 Lawson 方法观测阶，使用 $(m=200, m=400)$ 计算的指数欧拉法观测阶，以及在 $m=400$ 时的 Lawson 误差与指数欧拉误差之比。\n   - 对于情况 C：使用 $(m=200, m=400)$ 计算的 Lawson 方法观测阶，使用 $(m=200, m=400)$ 计算的指数欧拉法观测阶，以及在 $m=400$ 时的 Lawson 误差与指数欧拉误差之比。\n\n   因此，最终输出行必须是 $[p_{L,A}, p_{E,A}, r_A, p_{L,B}, p_{E,B}, r_B, p_{L,C}, p_{E,C}, r_C]$ 的形式，其中每个条目都是一个浮点数。不涉及物理单位。不使用角度。\n\n程序必须是完整且可直接运行的，不得需要任何用户输入或外部文件。它必须实现你推导的算法，并且只使用执行环境中指定的库。程序打印的最后一行必须严格是上述描述的列表，条目以逗号分隔，并用方括号括起来，不得有任何附加文本。", "solution": "问题陈述经过审阅，被认为是有效的。它在科学上基于常微分方程数值方法理论，问题设定良好、客观，并为推导、实现和测试提供了一套完整且一致的要求。\n\n该问题围绕标量半线性常微分方程（ODE）展开：\n$$\ny'(t) = -\\lambda y(t) + (\\mu y(t) - \\mu y(t)^2)\n$$\n初始条件为 $y(0) = y_0$，其中 $\\lambda > 0$、$\\mu$ 和 $y_0$ 是实参数。该方程的形式为 $y' = Ay + N(y)$，其中线性算子 $A = -\\lambda$，非线性部分为 $N(y) = \\mu y - \\mu y^2$。\n\n### 1. 数值格式的推导\n\n指数积分子的基础是常数变易公式，它给出了 $y' = Ay + N(y)$ 在长度为 $h = t_{n+1} - t_n$ 的时间区间 $[t_n, t_{n+1}]$ 上的精确解：\n$$\ny(t_{n+1}) = e^{Ah} y(t_n) + \\int_{0}^{h} e^{A(h-s)} N(y(t_n+s)) ds\n$$\n其中 $y_n$ 是对 $y(t_n)$ 的近似。对积分项的不同近似会产生不同的指数积分格式。\n\n#### 1.1 一阶 Lawson 方法\nLawson 方法引入变量替换以消除刚性线性部分。令 $v(t) = e^{-At} y(t)$，这意味着 $y(t) = e^{At} v(t)$。对 $v(t)$ 关于时间求导：\n$$\nv'(t) = -A e^{-At} y(t) + e^{-At} y'(t)\n$$\n代入 $y'(t) = Ay(t) + N(y(t))$：\n$$\nv'(t) = -A e^{-At} y(t) + e^{-At} (Ay(t) + N(y(t))) = e^{-At} N(y(t))\n$$\n代入 $y(t) = e^{At} v(t)$：\n$$\nv'(t) = e^{-At} N(e^{At} v(t))\n$$\n一阶 Lawson 方法将显式（前向）欧拉法应用于这个变换后的 $v(t)$ 方程：\n$$\nv_{n+1} = v_n + h v'(t_n) = v_n + h e^{-At_n} N(e^{At_n}v_n)\n$$\n注意到 $y_n = e^{At_n} v_n$，我们有 $N(e^{At_n}v_n) = N(y_n)$。代入 $v_n = e^{-At_n} y_n$ 和 $v_{n+1} = e^{-At_{n+1}} y_{n+1}$：\n$$\ne^{-At_{n+1}} y_{n+1} = e^{-At_n} y_n + h e^{-At_n} N(y_n)\n$$\n两边乘以 $e^{At_n}$ 得到：\n$$\ne^{A(t_n - t_{n+1})} y_{n+1} = y_n + h N(y_n)\n$$\n由于 $t_n - t_{n+1} = -h$，我们得到 $e^{-Ah} y_{n+1} = y_n + h N(y_n)$。一阶 Lawson 方法的最终更新公式是：\n$$\ny_{n+1} = e^{Ah} (y_n + h N(y_n))\n$$\n对于给定的标量问题，$A = -\\lambda$ 且 $N(y_n) = \\mu y_n - \\mu y_n^2$。更新公式变为：\n$$\ny_{n+1} = e^{-\\lambda h} (y_n + h (\\mu y_n - \\mu y_n^2))\n$$\n\n#### 1.2 一阶指数欧拉法\n该方法通过对常数变易公式中的积分应用简单的一阶求积法推导得出。我们假设非线性项 $N(y(t_n+s))$ 在区间 $[0, h]$ 上是常数，并等于其在起点的值 $N(y_n)$，以此来近似被积函数。\n$$\ny_{n+1} \\approx e^{Ah} y_n + \\int_{0}^{h} e^{A(h-s)} N(y_n) ds\n$$\n由于 $N(y_n)$ 相对于积分变量 $s$ 是常数，我们可以将其从积分中提出：\n$$\ny_{n+1} = e^{Ah} y_n + \\left( \\int_{0}^{h} e^{A(h-s)} ds \\right) N(y_n)\n$$\n该积分可以精确计算。令 $u=h-s$，则 $du = -ds$。积分限从 $s$ 的 $(0, h)$ 变为 $u$ 的 $(h, 0)$。\n$$\n\\int_{0}^{h} e^{A(h-s)} ds = \\int_{h}^{0} e^{Au} (-du) = \\int_{0}^{h} e^{Au} du = A^{-1}(e^{Ah} - I)\n$$\n这要求 $A$ 是可逆的，因为 $A = -\\lambda$ 且 $\\lambda > 0$，所以该条件成立。该积分通常用 $\\phi_1$ 函数表示，$\\int_0^h e^{A(h-s)}ds = h \\phi_1(Ah)$，其中 $\\phi_1(z) = (e^z-1)/z$。\n指数欧拉法（也称为 ETD1）的更新公式为：\n$$\ny_{n+1} = e^{Ah} y_n + A^{-1}(e^{Ah} - I) N(y_n)\n$$\n对于标量问题，$e^{Ah} = e^{-\\lambda h}$ 且 $A^{-1}(e^{Ah}-I) = (-\\lambda)^{-1}(e^{-\\lambda h}-1) = \\frac{1-e^{-\\lambda h}}{\\lambda}$。更新公式为：\n$$\ny_{n+1} = e^{-\\lambda h} y_n + \\frac{1-e^{-\\lambda h}}{\\lambda} (\\mu y_n - \\mu y_n^2)\n$$\n\n### 2. 精确参考解\n给定的 ODE 是 $y' = (\\mu - \\lambda)y - \\mu y^2$。这是一个伯努利微分方程，形式为 $y' + P(t)y = Q(t)y^n$，其中 $P(t) = \\lambda - \\mu$，$Q(t) = -\\mu$，$n=2$。我们通过替换 $u(t) = y(t)^{1-n} = y(t)^{-1}$ 来求解。这得到 $u' = -y^{-2}y'$。\n原方程可以写成 $y' + (\\lambda-\\mu)y = -\\mu y^2$。两边除以 $y^2$ 得到：\n$$\ny^{-2}y' + (\\lambda-\\mu)y^{-1} = -\\mu\n$$\n代入 $u$ 和 $u'$：\n$$\n-u' + (\\lambda-\\mu)u = -\\mu \\implies u' - (\\lambda-\\mu)u = \\mu\n$$\n这是一个关于 $u(t)$ 的一阶线性 ODE。\n\n情况 1: $\\lambda \\neq \\mu$。\n积分因子为 $I(t) = \\exp\\left(-\\int (\\lambda-\\mu) dt\\right) = e^{-(\\lambda-\\mu)t}$。\n将关于 $u$ 的 ODE 乘以 $I(t)$ 得到 $(u e^{-(\\lambda-\\mu)t})' = \\mu e^{-(\\lambda-\\mu)t}$。从 $0$ 到 $t$ 积分：\n$$\nu(t)e^{-(\\lambda-\\mu)t} - u(0) = \\int_0^t \\mu e^{-(\\lambda-\\mu)\\tau} d\\tau = \\mu \\left[ \\frac{e^{-(\\lambda-\\mu)\\tau}}{-(\\lambda-\\mu)} \\right]_0^t = \\frac{\\mu}{-(\\lambda-\\mu)} (e^{-(\\lambda-\\mu)t} - 1)\n$$\n其中 $u(0) = y_0^{-1}$，解出 $u(t)$：\n$$\nu(t) = u(0)e^{(\\lambda-\\mu)t} + \\frac{\\mu}{\\lambda-\\mu}(e^{(\\lambda-\\mu)t} - 1) = \\left(\\frac{1}{y_0} + \\frac{\\mu}{\\lambda-\\mu}\\right)e^{(\\lambda-\\mu)t} - \\frac{\\mu}{\\lambda-\\mu}\n$$\n由于 $y(t) = u(t)^{-1}$，精确解为：\n$$\ny(t) = \\left( \\left(\\frac{1}{y_0} + \\frac{\\mu}{\\lambda-\\mu}\\right)e^{(\\lambda-\\mu)t} - \\frac{\\mu}{\\lambda-\\mu} \\right)^{-1}\n$$\n\n情况 2: $\\lambda = \\mu$。\n关于 $u$ 的 ODE 简化为 $u' = \\mu$。\n从 $0$ 到 $t$ 积分得到 $u(t) - u(0) = \\mu t$。\n其中 $u(0) = y_0^{-1}$，我们有 $u(t) = y_0^{-1} + \\mu t$。\n此情况下的精确解为：\n$$\ny(t) = \\frac{1}{y_0^{-1} + \\mu t} = \\frac{y_0}{1 + \\mu t y_0}\n$$\n\n### 3. 实现与分析\n实现将包括每种数值方法和精确解的函数。主程序将遍历所提供的测试用例。对于每个用例，它将以步数 $m=200$ 和 $m=400$ 运行模拟，以计算最终时间误差。观测收敛阶 $p$ 使用两次连续细化的误差 $e(h)$ 和 $e(h/2)$ 进行估计：\n$$\np \\approx \\frac{\\log(e(h) / e(h/2))}{\\log(2)}\n$$\n这里，$h$ 对应于 $m=200$，$h/2$ 对应于 $m=400$。Lawson 方法和指数欧拉法之间的误差比率将在最精细的分辨率（$m=400$）下计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and tests two first-order exponential integrators.\n    \"\"\"\n\n    def exact_solution(lam, mu, y0, t):\n        \"\"\"Computes the exact solution y(t).\"\"\"\n        if lam == mu:\n            if 1.0 + mu * t * y0 == 0:\n                return np.inf  # or handle as a singularity\n            return y0 / (1.0 + mu * t * y0)\n        else:\n            c = lam - mu\n            term1 = (1.0 / y0 + mu / c) * np.exp(c * t)\n            term2 = mu / c\n            denominator = term1 - term2\n            if denominator == 0:\n                return np.inf\n            return 1.0 / denominator\n\n    def integrate_lawson(lam, mu, y0, T, m):\n        \"\"\"Integrates the ODE using the first-order Lawson method.\"\"\"\n        h = T / m\n        y = y0\n        exp_term = np.exp(-lam * h)\n        \n        for _ in range(m):\n            N_y = mu * y - mu * y**2\n            y = exp_term * (y + h * N_y)\n        return y\n\n    def integrate_exp_euler(lam, mu, y0, T, m):\n        \"\"\"Integrates the ODE using the first-order exponential Euler method.\"\"\"\n        h = T / m\n        y = y0\n        exp_term = np.exp(-lam * h)\n        \n        # The phi_1 function term: (e^(Ah) - I) / A\n        # h * phi_1(Ah) = h * (e^(Ah)-1)/(Ah) = (e^(-lam*h)-1)/(-lam) = (1-e^(-lam*h))/lam\n        # Use np.expm1 for numerical stability for small lam*h\n        if lam == 0: # Should not happen based on problem spec (lam > 0)\n            phi1_term = h\n        else:\n            phi1_term = -np.expm1(-lam * h) / lam\n\n        for _ in range(m):\n            N_y = mu * y - mu * y**2\n            y = exp_term * y + phi1_term * N_y\n        return y\n\n    def calculate_metrics(params, m1, m2):\n        \"\"\"Calculates errors, order, and ratio for a given parameter set.\"\"\"\n        lam, mu, y0, T = params\n        \n        y_exact_T = exact_solution(lam, mu, y0, T)\n\n        # Lawson method calculations\n        y_L1 = integrate_lawson(lam, mu, y0, T, m1)\n        y_L2 = integrate_lawson(lam, mu, y0, T, m2)\n        error_L1 = np.abs(y_L1 - y_exact_T)\n        error_L2 = np.abs(y_L2 - y_exact_T)\n        \n        # Exponential Euler method calculations\n        y_E1 = integrate_exp_euler(lam, mu, y0, T, m1)\n        y_E2 = integrate_exp_euler(lam, mu, y0, T, m2)\n        error_E1 = np.abs(y_E1 - y_exact_T)\n        error_E2 = np.abs(y_E2 - y_exact_T)\n\n        # Observed order calculation\n        # p = log(e(h)/e(h/2)) / log(2)\n        p_L = np.log(error_L1 / error_L2) / np.log(2) if error_L2 > 0 else 0.0\n        p_E = np.log(error_E1 / error_E2) / np.log(2) if error_E2 > 0 else 0.0\n        \n        # Error ratio at finest grid (m2)\n        ratio = error_L2 / error_E2 if error_E2 > 0 else np.inf\n        \n        return p_L, p_E, ratio\n\n    # Define test cases from the problem statement\n    test_cases = [\n        # Case A: (lambda, mu, y0, T) = (50, 1, 0.1, 1)\n        (50.0, 1.0, 0.1, 1.0),\n        # Case B: (lambda, mu, y0, T) = (1, 1, 0.5, 1)\n        (1.0, 1.0, 0.5, 1.0),\n        # Case C: (lambda, mu, y0, T) = (200, 2, 0.9, 0.5)\n        (200.0, 2.0, 0.9, 0.5),\n    ]\n    \n    m_coarse = 200\n    m_fine = 400\n\n    results = []\n    for case in test_cases:\n        p_L, p_E, r = calculate_metrics(case, m_coarse, m_fine)\n        results.extend([p_L, p_E, r])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3227424"}, {"introduction": "指数积分法的稳健实现，关键在于能否精确计算其中核心的 $\\varphi$ 函数。本练习聚焦于一个常见的数值陷阱：当指数积分法的参数很小时，直接计算 $\\varphi$ 函数会遭遇灾难性的舍入误差。通过探索和比较泰勒级数展开与 Padé 近似这两种强大的技巧，你将学会如何确保计算的准确性，这是将理论方法转化为可靠代码的关键一步。[@problem_id:3227524]", "problem": "考虑在指数时间差分（ETD）积分器中处于核心地位的函数，它对任意复自变量 $z$ 定义为：当 $z \\neq 0$ 时，$\\varphi_1(z) = \\frac{e^z - 1}{z}$；根据连续性，$\\varphi_1(0) = 1$。在指数积分器中，对于小的 $|z|$，精确且稳定地计算 $\\varphi_1(z)$ 至关重要。当 $|z| \\ll 1$ 时，直接计算 $\\frac{e^z - 1}{z}$ 会遭受相消误差的影响，这会放大了浮点舍入误差。缓解此问题的两种常用策略是：从指数函数的幂级数推导出的 $\\varphi_1(z)$ 的截断泰勒级数，以及将 $\\varphi_1(z)$ 的级数匹配到指定阶数的有理帕德逼近。\n\n从基本定义和经过充分检验的公式出发：\n- 指数函数具有幂级数 $e^z = \\sum_{n=0}^{\\infty} \\frac{z^n}{n!}$，对所有复数 $z$ 均有效。\n- 函数 $\\varphi_1(z)$ 可以通过将 $\\sum_{n=1}^{\\infty} \\frac{z^n}{n!}$ 除以 $z$ 来表示为幂级数。\n- 一个 $[m/n]$ 型帕德逼近是一个有理函数，其级数与给定函数的级数在规定阶数内相匹配。\n\n你的任务：\n1. 从基本定义出发，利用上述 $e^z$ 的定义，推导 $\\varphi_1(z)$ 的截断泰勒级数表示。通过确定系数 $c_k$（用阶乘表示），将 $\\varphi_1(z)$ 表示为级数 $\\sum_{k=0}^{K} c_k z^k$，过程中不使用任何预先推导的快捷公式。\n2. 构建 $\\varphi_1(z)$ 的 $[2/2]$ 型有理帕德逼近，方法是将一个未知有理函数 $\\frac{a_0 + a_1 z + a_2 z^2}{1 + b_1 z + b_2 z^2}$ 的幂级数与 $\\varphi_1(z)$ 的级数（直到并包括 $z^4$ 阶项）进行相等匹配，并仅通过级数系数的代数匹配求解系数 $a_0$、$a_1$、$a_2$、$b_1$ 和 $b_2$。\n3. 通过为给定的计算方法 $M$ 和测试值 $z$ 定义放大因子来分析舍入放大\n$$A_M(z) = \\frac{\\left|\\varphi_{1,M}(z) - \\varphi_{1,\\text{ref}}(z)\\right|}{\\left|\\varphi_{1,\\text{ref}}(z)\\right|} \\cdot \\frac{1}{\\varepsilon},$$\n其中 $\\varphi_{1,M}(z)$ 是方法 $M$ 计算的值，$\\varphi_{1,\\text{ref}}(z)$ 是通过对泰勒级数求和至足够多项而计算出的高精度参考值，$\\varepsilon$ 是 IEEE-754 双精度的机器ε。在此计算中，所有量都是无量纲的，不涉及任何物理单位。\n4. 实现一个完整的程序，该程序：\n   - 使用具有 $N_{\\text{series}} = 12$ 项的截断级数来计算 $\\varphi_{1,\\text{series}}(z)$。\n   - 使用推导出的 $[2/2]$ 帕德逼近来计算 $\\varphi_{1,\\text{Padé}}(z)$。\n   - 使用具有 $N_{\\text{ref}} = 60$ 项的高精度参考级数来计算 $\\varphi_{1,\\text{ref}}(z)$。\n   - 为每个测试用例计算 $A_{\\text{series}}(z)$ 和 $A_{\\text{Padé}}(z)$。\n   - 为每个测试用例生成一个包含三项的列表 $[A_{\\text{series}}(z), A_{\\text{Padé}}(z), B(z)]$，其中 $B(z)$ 是一个布尔值，如果 $A_{\\text{series}}(z)  A_{\\text{Padé}}(z)$ 则为 true，否则为 false。\n\n测试套件：\n在以下六个测试输入上评估程序，这些输入旨在测试不同方面：\n- 一般的小实数：$z = 10^{-2}$。\n- 非常小的实数（相消误差分析的理想情况）：$z = 10^{-8}$。\n- 极小的实数（接近双精度尺度）：$z = 10^{-12}$。\n- 非常小的负实数：$z = -10^{-12}$。\n- 非常小的纯虚数：$z = i \\cdot 10^{-8}$。\n- 实部和虚部相等的极小复数：$z = \\frac{10^{-16}}{\\sqrt{2}} (1 + i)$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。该列表必须有六个条目，每个条目对应上面给出的一个测试用例。每个条目本身必须是 $[A_{\\text{series}}(z), A_{\\text{Padé}}(z), B(z)]$ 形式的列表，其中前两个条目是浮点数，第三个是布尔值。例如，输出应具有以下形式\n$[[a_1,p_1,b_1],[a_2,p_2,b_2],[a_3,p_3,b_3],[a_4,p_4,b_4],[a_5,p_5,b_5],[a_6,p_6,b_6]]$。", "solution": "该问题是有效的。它在科学上基于数值分析的原理，特别是指数积分器的研究和舍入误差的缓解。该问题是适定的、客观的且自包含的，提供了所有必要的定义、常数和测试用例，以获得唯一且可验证的解。\n\n核心任务是为小的 $|z|$ 计算函数 $\\varphi_1(z) = \\frac{e^z - 1}{z}$。直接计算会遭受灾难性相消的影响，因为当 $z \\approx 0$ 时，我们有 $e^z \\approx 1$，导致两个几乎相等的数相减。为了规避这个问题，我们可以使用基于该函数幂级数的逼近。我们将推导并比较两种这样的逼近：截断泰勒级数和帕德逼近。\n\n**1. $\\varphi_1(z)$ 的泰勒级数推导**\n\n我们从指数函数的基本幂级数表示开始，该级数对所有复数 $z$ 收敛：\n$$e^z = \\sum_{n=0}^{\\infty} \\frac{z^n}{n!} = 1 + z + \\frac{z^2}{2!} + \\frac{z^3}{3!} + \\dots$$\n由此，我们找到 $e^z - 1$ 的级数：\n$$e^z - 1 = \\left(\\sum_{n=0}^{\\infty} \\frac{z^n}{n!}\\right) - 1 = \\left(1 + \\sum_{n=1}^{\\infty} \\frac{z^n}{n!}\\right) - 1 = \\sum_{n=1}^{\\infty} \\frac{z^n}{n!}$$\n现在，我们可以通过除以 $z$ 来推导 $\\varphi_1(z)$ 的级数：\n$$\\varphi_1(z) = \\frac{e^z - 1}{z} = \\frac{1}{z} \\sum_{n=1}^{\\infty} \\frac{z^n}{n!} = \\sum_{n=1}^{\\infty} \\frac{z^{n-1}}{n!}$$\n为了将其表示为标准形式 $\\sum_{k=0}^{\\infty} c_k z^k$，我们通过设置 $k = n-1$ 来进行指标变换。当 $n$ 从 $1$ 趋于 $\\infty$ 时，$k$ 从 $0$ 趋于 $\\infty$。将 $n = k+1$ 代入级数中得到：\n$$\\varphi_1(z) = \\sum_{k=0}^{\\infty} \\frac{z^k}{(k+1)!}$$\n因此，截断泰勒级数表示为 $\\sum_{k=0}^{K} c_k z^k$，其系数为 $c_k = \\frac{1}{(k+1)!}$。前几项是：\n$$\\varphi_1(z) = \\frac{1}{1!} + \\frac{z}{2!} + \\frac{z^2}{3!} + \\frac{z^3}{4!} + \\dots = 1 + \\frac{z}{2} + \\frac{z^2}{6} + \\frac{z^3}{24} + \\dots$$\n\n**2. $[2/2]$ 帕德逼近的构建**\n\n函数 $f(z)$ 的 $[m/n]$ 型帕德逼近是一个有理函数 $R(z) = \\frac{P_m(z)}{Q_n(z)}$，其中 $P_m(z)$ 和 $Q_n(z)$ 分别是 $m$ 次和 $n$ 次多项式，其麦克劳林级数与 $f(z)$ 的级数在尽可能高的阶数（即 $m+n$ 阶）上一致。\n\n我们寻求 $\\varphi_1(z)$ 的 $[2/2]$ 帕德逼近，其形式为：\n$$R(z) = \\frac{a_0 + a_1 z + a_2 z^2}{1 + b_1 z + b_2 z^2}$$\n分母中 $z^0$ 的系数被归一化为 $1$。我们需要将 $R(z)$ 的级数展开式与 $\\varphi_1(z)$ 的泰勒级数匹配到 $z^{m+n} = z^4$ 项。这等价于条件：\n$$(1 + b_1 z + b_2 z^2) \\varphi_1(z) - (a_0 + a_1 z + a_2 z^2) = O(z^5)$$\n代入 $\\varphi_1(z)$ 的级数：\n$$(1 + b_1 z + b_2 z^2) \\left(1 + \\frac{z}{2} + \\frac{z^2}{6} + \\frac{z^3}{24} + \\frac{z^4}{120} + \\dots\\right) = a_0 + a_1 z + a_2 z^2$$\n我们展开左侧，并令等式两边 $z$ 的各次幂系数相等。\n\n- $z^0$ 的系数：$1 \\cdot 1 = a_0 \\implies a_0 = 1$。\n- $z^1$ 的系数：$1 \\cdot \\frac{1}{2} + b_1 \\cdot 1 = a_1 \\implies \\frac{1}{2} + b_1 = a_1$。\n- $z^2$ 的系数：$1 \\cdot \\frac{1}{6} + b_1 \\cdot \\frac{1}{2} + b_2 \\cdot 1 = a_2 \\implies \\frac{1}{6} + \\frac{b_1}{2} + b_2 = a_2$。\n- $z^3$ 的系数：$1 \\cdot \\frac{1}{24} + b_1 \\cdot \\frac{1}{6} + b_2 \\cdot \\frac{1}{2} = 0$。\n- $z^4$ 的系数：$1 \\cdot \\frac{1}{120} + b_1 \\cdot \\frac{1}{24} + b_2 \\cdot \\frac{1}{6} = 0$。\n\n$z^3$ 和 $z^4$ 的系数方程构成了关于 $b_1$ 和 $b_2$ 的线性方程组：\n1. $\\frac{b_1}{6} + \\frac{b_2}{2} = -\\frac{1}{24} \\implies 4b_1 + 12b_2 = -1$。\n2. $\\frac{b_1}{24} + \\frac{b_2}{6} = -\\frac{1}{120} \\implies 5b_1 + 20b_2 = -1$。\n\n将第一个方程乘以 $5$，第二个方程乘以 $4$ 得到：\n$20b_1 + 60b_2 = -5$\n$20b_1 + 80b_2 = -4$\n用第二个方程减去第一个方程得到 $20b_2 = 1$，所以 $b_2 = \\frac{1}{20}$。\n将 $b_2$ 代回 $4b_1 + 12b_2 = -1$：\n$4b_1 + 12\\left(\\frac{1}{20}\\right) = -1 \\implies 4b_1 + \\frac{3}{5} = -1 \\implies 4b_1 = -\\frac{8}{5} \\implies b_1 = -\\frac{2}{5}$。\n\n现在我们求解分子系数：\n- $a_0 = 1$。\n- $a_1 = \\frac{1}{2} + b_1 = \\frac{1}{2} - \\frac{2}{5} = \\frac{5 - 4}{10} = \\frac{1}{10}$。\n- $a_2 = \\frac{1}{6} + \\frac{b_1}{2} + b_2 = \\frac{1}{6} + \\frac{1}{2}\\left(-\\frac{2}{5}\\right) + \\frac{1}{20} = \\frac{1}{6} - \\frac{1}{5} + \\frac{1}{20} = \\frac{10 - 12 + 3}{60} = \\frac{1}{60}$。\n\n得到的 $\\varphi_1(z)$ 的 $[2/2]$ 帕德逼近是：\n$$R(z) = \\frac{1 + \\frac{1}{10}z + \\frac{1}{60}z^2}{1 - \\frac{2}{5}z + \\frac{1}{20}z^2}$$\n\n**3. 数值实现与分析**\n\n我们现在将实现数值比较。目标是计算舍入放大因子，\n$$A_M(z) = \\frac{\\left|\\varphi_{1,M}(z) - \\varphi_{1,\\text{ref}}(z)\\right|}{\\left|\\varphi_{1,\\text{ref}}(z)\\right|} \\cdot \\frac{1}{\\varepsilon}$$\n对于两种方法 $M$：截断泰勒级数和推导出的帕德逼近。\n- $\\varphi_{1,\\text{series}}(z)$ 将使用截断到 $N_{\\text{series}} = 12$ 项的泰勒级数计算。\n- $\\varphi_{1,\\text{Padé}}(z)$ 将使用上面推导的 $[2/2]$ 逼近计算。\n- 参考值 $\\varphi_{1,\\text{ref}}(z)$ 将使用具有大量项（$N_{\\text{ref}} = 60$）的泰勒级数来计算，以确保高保真度。对于测试套件中小的 $|z|$ 值，在双精度算术的限制内，此和是真实函数值的高度精确表示。\n- 机器ε $\\varepsilon$ 对应于 IEEE-754 双精度，约为 $2.22 \\times 10^{-16}$。\n\n该实现将以一个完整的 Python 程序提供。此程序将为每种计算方法定义函数，遍历指定的测试用例，并计算放大因子 $A_{\\text{series}}(z)$ 和 $A_{\\text{Padé}}(z)$，以及一个布尔值 $B(z)$，该布尔值指示对于该输入，级数方法是否比帕德方法更精确。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef phi1_series(z: complex, N: int) -> complex:\n    \"\"\"\n    Computes phi_1(z) using its Taylor series expansion up to N terms.\n    The series is phi_1(z) = sum_{k=0}^{N-1} z^k / (k+1)!.\n    This is implemented using an efficient and stable iterative method.\n    \"\"\"\n    total = complex(0.0, 0.0)\n    # The term for k=0 is z^0 / 1! = 1\n    term = complex(1.0, 0.0)\n    for k in range(N):\n        # At the start of iteration k, 'term' holds z^k / (k+1)!\n        total += term\n        # Update term for the next iteration (k+1).\n        # T_{k+1} = z^(k+1) / (k+2)!\n        # T_{k+1} = T_k * z * (k+1)! / (k+2)! = T_k * z / (k+2)\n        term *= z / (k + 2)\n    return total\n\ndef phi1_pade_2_2(z: complex) -> complex:\n    \"\"\"\n    Computes phi_1(z) using the derived [2/2] Padé approximant.\n    R(z) = (1 + (1/10)z + (1/60)z^2) / (1 - (2/5)z + (1/20)z^2).\n    \"\"\"\n    # Numerator coefficients derived as a_0=1, a_1=1/10, a_2=1/60\n    num = 1.0 + z / 10.0 + (z**2) / 60.0\n    # Denominator coefficients derived as b_1=-2/5, b_2=1/20\n    den = 1.0 - (2.0 * z) / 5.0 + (z**2) / 20.0\n    return num / den\n\ndef solve():\n    \"\"\"\n    Main function to execute the problem tasks.\n    It computes and compares the accuracy of the Taylor series and Padé\n    approximants for phi_1(z) for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        1e-2 + 0j,\n        1e-8 + 0j,\n        1e-12 + 0j,\n        -1e-12 + 0j,\n        1j * 1e-8,\n        (1e-16 / np.sqrt(2)) * (1 + 1j)\n    ]\n\n    N_series = 12\n    N_ref = 60\n    # Machine epsilon for IEEE-754 double precision float.\n    eps = np.finfo(float).eps\n\n    results = []\n    for z in test_cases:\n        # 1. Compute high-accuracy reference value\n        phi_ref = phi1_series(z, N_ref)\n\n        # 2. Compute values using the two methods under test\n        phi_series = phi1_series(z, N_series)\n        phi_pade = phi1_pade_2_2(z)\n\n        # 3. Compute the amplification factors\n        # A = (relative error) / (machine epsilon)\n        # Use np.abs for complex numbers. The denominator abs(phi_ref) is a\n        # safe operation as it will be very close to 1 for small z.\n        err_series = np.abs(phi_series - phi_ref)\n        err_pade = np.abs(phi_pade - phi_ref)\n        \n        # Handle cases where the error is numerically zero to avoid division by zero\n        # if phi_ref also happens to be zero, although unlikely here.\n        abs_phi_ref = np.abs(phi_ref)\n        if abs_phi_ref == 0:\n            # This case is not expected for the given test values.\n            # If both error and ref are 0, amplification is 0. If error is non-zero, it's infinite.\n            A_series = 0.0 if err_series == 0 else np.inf\n            A_pade = 0.0 if err_pade == 0 else np.inf\n        else:\n            A_series = (err_series / abs_phi_ref) / eps\n            A_pade = (err_pade / abs_phi_ref) / eps\n        \n        # 4. Perform the boolean comparison\n        is_series_better = A_series  A_pade\n\n        # 5. Format the result list for this test case\n        # The boolean must be formatted as lowercase \"true\" or \"false\".\n        results.append(f\"[{A_series},{A_pade},{str(is_series_better).lower()}]\")\n\n    # Final print statement in the exact required format.\n    # e.g., [[a1,p1,b1],[a2,p2,b2],...]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3227524"}, {"introduction": "指数积分法的威力在于其对一般线性算子的普适性，而不仅限于可对角化的情形。本练习将挑战你将指数时间差分 (ETD) 框架应用于一个线性部分含有亏损（不可对角化）矩阵的系统。这个实践将迫使你超越简单的标量特征值，深入理解矩阵函数的本质，从而掌握在更复杂、更一般情况下应用指数积分法的方法。[@problem_id:3227484]", "problem": "考虑自治常微分方程（ODE）系统 $u'(t) = L u(t) + G(u(t))$，其中 $u(t) \\in \\mathbb{R}^2$，线性算子 $L$ 是一个 $2 \\times 2$ 的亏损 Jordan 块，\n$$\nL = \\begin{pmatrix} \\lambda  s \\\\ 0  \\lambda \\end{pmatrix},\n$$\n其中 $\\lambda \\in \\mathbb{R}$ 且 $s \\in \\mathbb{R}$。非线性项 $G(u)$ 按分量定义为\n$$\nG(u) = \\begin{pmatrix} 0 \\\\ \\beta \\, u_1^2 \\end{pmatrix},\n$$\n其中 $u_1$ 表示 $u$ 的第一个分量，$\\beta \\in \\mathbb{R}$ 是一个给定参数。初始条件为 $u(0) = u_0 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$，最终时间为 $T  0$。\n\n你的任务是基于常数变易公式，为该系统实现一个一阶指数时间差分（ETD）格式（称为 ETD 欧拉格式）。从基本恒等式\n$$\nu(t+h) = e^{h L} u(t) + \\int_0^h e^{(h - \\tau) L} G(u(t + \\tau)) \\, d\\tau,\n$$\n出发，通过在每个时间步上将 $G(u)$ 视为常数（即，对于 $\\tau \\in [0,h]$，$G(u(t + \\tau)) \\approx G(u(t))$）来构建 ETD 欧拉近似。使用第一个 $\\varphi$-函数的积分定义，\n$$\n\\varphi_1(A) = \\int_0^1 e^{(1 - \\theta) A} \\, d\\theta,\n$$\n对于矩阵 $A$，用矩阵指数 $e^{hL}$ 和 $\\varphi_1(hL)$ 来表示 ETD 欧拉更新。你必须推导并实现适用于上述亏损矩阵 $L$ 的表达式，并确保当 $\\lambda = 0$ 时该方法仍是良定义的。\n\n为评估性能，使用经典的四阶 Runge-Kutta 方法（RK4）和均匀步长 $h_{\\text{ref}}$，应用于完整的 ODE $u'(t) = L u(t) + G(u(t))$，来近似参考解 $u_{\\text{ref}}(T)$。RK4 参考解应足够精确，以作为误差测量的基准真相。\n\n将给定参数集在最终时间的全局误差定义为\n$$\nE = \\| u_{\\text{ETD}}(T) - u_{\\text{ref}}(T) \\|_2,\n$$\n其中 $\\| \\cdot \\|_2$ 表示 $\\mathbb{R}^2$ 中的欧几里得范数。\n\n实现一个程序，为以下每个测试用例计算 $E$（这些值构成测试套件）：\n\n- 情况 1：$\\lambda = -2$, $s = 1$, $h = 0.05$, $T = 1.0$, $\\beta = 0.5$。\n- 情况 2：$\\lambda = -8$, $s = 1$, $h = 0.05$, $T = 1.0$, $\\beta = 0.5$。\n- 情况 3：$\\lambda = 0$, $s = 1$, $h = 0.05$, $T = 1.0$, $\\beta = 0.5$。\n- 情况 4：$\\lambda = -2$, $s = 0$, $h = 0.05$, $T = 1.0$, $\\beta = 0.5$ (非亏损边界)。\n- 情况 5：$\\lambda = -2$, $s = 1$, $h = 0.20$, $T = 1.0$, $\\beta = 0.5$ (较大步长压力测试)。\n\n在所有情况下，对 RK4 参考解使用 $h_{\\text{ref}} = 10^{-4}$，并确保 $T$ 是 $h$ 和 $h_{\\text{ref}}$ 的整数倍。\n\n你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，“[result1,result2,result3,result4,result5]”）。每个 $result_i$ 必须是一个实数（浮点数），等于按上述顺序列出的相应情况的最终时间误差 $E$。不涉及物理单位；报告原始数值。程序必须完全自包含，无需用户输入。", "solution": "用户希望使用一阶指数时间差分（ETD）方法求解一个常微分方程（ODE）组，并将其精度与高分辨率的经典四阶 Runge-Kutta（RK4）方法进行比较。\n\n### **问题陈述分析**\n\n该问题在数学和科学上是合理的。它提出了一个针对半线性 ODE 系统的良定义初值问题：\n$$\nu'(t) = L u(t) + G(u(t)), \\quad u(0) = u_0\n$$\n其中 $u(t) \\in \\mathbb{R}^2$，线性部分 $L$ 是一个 $2 \\times 2$ 的 Jordan 块，非线性部分 $G(u)$ 是其中一个分量的二次函数。任务是实现 ETD 欧拉格式，这需要为特定的亏损矩阵 $L$ 推导和计算矩阵函数（指数函数和第一个 $\\varphi$-函数）。该问题还明确要求稳健地处理 $L$ 的特征值 $\\lambda$ 为零的情况，这是研究 $\\varphi$-函数时的标准考虑。使用小步长的 RK4 方法生成参考解是数值误差分析的标准技术。所有参数都已指定，误差度量也已明确定义。该问题是有效的、适定的，并且需要对数值分析原理进行非平凡的应用。\n\n### **理论推导**\n\n**1. ETD 欧拉格式**\n\nETD 欧拉格式是从精确的常数变易公式推导而来的：\n$$\nu(t_{n+1}) = e^{hL} u(t_n) + \\int_0^h e^{(h - \\tau)L} G(u(t_n + \\tau)) \\, d\\tau\n$$\n通过将区间 $[t_n, t_{n+1}]$ 上的非线性项近似为常数，即 $G(u(t_n + \\tau)) \\approx G(u_n)$，可得：\n$$\nu_{n+1} = e^{hL} u_n + \\left( \\int_0^h e^{(h - \\tau)L} \\, d\\tau \\right) G(u_n)\n$$\n该积分可以用 $\\varphi_1$ 函数表示。通过变量替换 $\\theta = \\tau/h$，积分变为 $h \\int_0^1 e^{(1-\\theta)hL} d\\theta$。根据定义，此积分为 $h \\varphi_1(hL)$。\n因此，ETD 欧拉更新规则为：\n$$\nu_{n+1} = e^{hL} u_n + h \\varphi_1(hL) G(u_n)\n$$\n其中 $u_n$ 是 $u(t_n)$ 的数值近似，$h$ 是时间步长。\n\n**2. Jordan 块的矩阵函数**\n\n实现的核心在于计算矩阵 $A = hL = \\begin{pmatrix} h\\lambda  hs \\\\ 0  h\\lambda \\end{pmatrix}$ 的矩阵函数 $e^{A}$ 和 $\\varphi_1(A)$。对于一个函数 $f$ 和一个特征值为 $z$、非对角元素为 $c$ 的 $2 \\times 2$ Jordan 块，矩阵的函数由下式给出：\n$$\nf\\left(\\begin{pmatrix} z  c \\\\ 0  z \\end{pmatrix}\\right) = \\begin{pmatrix} f(z)  c f'(z) \\\\ 0  f(z) \\end{pmatrix}\n$$\n此公式依赖于函数 $f$ 在矩阵周围的泰勒展开。\n\n**a. 矩阵指数 $e^{hL}$**\n\n令 $A = hL$, $z = h\\lambda$, $c = hs$ 且 $f(z) = e^z$。则 $f'(z) = e^z$。\n$$\ne^{hL} = e^A = \\begin{pmatrix} e^{h\\lambda}  hs e^{h\\lambda} \\\\ 0  e^{h\\lambda} \\end{pmatrix}\n$$\n此公式对所有 $\\lambda \\in \\mathbb{R}$ 均有效。\n\n**b. 矩阵函数 $\\varphi_1(hL)$**\n\n令 $A = hL$, $z = h\\lambda$, $c = hs$ 且 $f(z) = \\varphi_1(z)$。我们需要 $\\varphi_1(z)$ 及其导数 $\\varphi_1'(z)$ 的表达式。\n\n对于 $z \\neq 0$:\n$$\n\\varphi_1(z) = \\frac{e^z - 1}{z}\n$$\n$$\n\\varphi_1'(z) = \\frac{d}{dz}\\left(\\frac{e^z - 1}{z}\\right) = \\frac{ze^z - (e^z - 1)}{z^2}\n$$\n因此，对于 $\\lambda \\neq 0$ (从而 $z \\neq 0$):\n$$\n\\varphi_1(hL) = \\begin{pmatrix} \\varphi_1(h\\lambda)  hs \\varphi_1'(h\\lambda) \\\\ 0  \\varphi_1(h\\lambda) \\end{pmatrix} = \\begin{pmatrix} \\frac{e^{h\\lambda}-1}{h\\lambda}  hs \\frac{h\\lambda e^{h\\lambda} - e^{h\\lambda} + 1}{(h\\lambda)^2} \\\\ 0  \\frac{e^{h\\lambda}-1}{h\\lambda} \\end{pmatrix}\n$$\n\n对于 $z = 0$ (即 $\\lambda = 0$)：\n上述公式是未定式。我们必须使用 $z \\to 0$ 时的极限，这可以从泰勒级数 $\\varphi_1(z) = 1 + \\frac{z}{2} + \\frac{z^2}{6} + \\dots$ 得到。\n$$\n\\varphi_1(0) = \\lim_{z \\to 0} \\frac{e^z - 1}{z} = 1\n$$\n$$\n\\varphi_1'(0) = \\lim_{z \\to 0} \\frac{ze^z - e^z + 1}{z^2} = \\lim_{z \\to 0} \\frac{e^z + ze^z - e^z}{2z} = \\lim_{z \\to 0} \\frac{e^z}{2} = \\frac{1}{2}\n$$\n所以，对于 $\\lambda = 0$ (从而 $z=0$)：\n$$\n\\varphi_1(hL) = \\begin{pmatrix} \\varphi_1(0)  hs \\varphi_1'(0) \\\\ 0  \\varphi_1(0) \\end{pmatrix} = \\begin{pmatrix} 1  hs/2 \\\\ 0  1 \\end{pmatrix}\n$$\n这种对 $\\lambda = 0$ 的特殊处理对保证正确性至关重要。\n\n### **数值实现计划**\n\n1.  **RK4 参考解**：为完整的 ODE 系统 $u' = f(u) = Lu + G(u)$ 实现一个标准的 RK4 求解器。该求解器将使用精细的步长 $h_{\\text{ref}} = 10^{-4}$ 来生成高精度的参考解 $u_{\\text{ref}}(T)$。\n\n2.  **ETD 欧拉解**：实现 ETD 欧拉格式。对于每个测试用例，在时间步进循环之前计算一次常数矩阵 $E = e^{hL}$ 和 $P = h\\varphi_1(hL)$。然后循环迭代地应用更新规则 $u_{n+1} = E u_n + P G(u_n)$。\n\n3.  **误差计算**：对于每个测试用例，计算两种方法得到的最终时间解之差的欧几里得范数：$E = \\| u_{\\text{ETD}}(T) - u_{\\text{ref}}(T) \\|_2$。\n\n4.  **主循环**：主函数遍历所提供的五个测试用例，调用求解器，计算每个用例的误差，并存储结果。\n\n5.  **输出**：最终的误差列表被格式化为指定的字符串 `\"[result1,result2,...]\"`。\n\n这种方法系统地将推导出的数学公式转化为计算算法，确保正确处理问题中指定的所有情况。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the global error of the ETD Euler method for a given ODE system\n    by comparing it to a high-resolution RK4 reference solution.\n    \"\"\"\n\n    # Define test cases: (lambda, s, h, T, beta)\n    test_cases = [\n        (-2.0, 1.0, 0.05, 1.0, 0.5), # Case 1\n        (-8.0, 1.0, 0.05, 1.0, 0.5), # Case 2\n        (0.0, 1.0, 0.05, 1.0, 0.5),  # Case 3\n        (-2.0, 0.0, 0.05, 1.0, 0.5), # Case 4\n        (-2.0, 1.0, 0.20, 1.0, 0.5)  # Case 5\n    ]\n\n    # Reference step size for RK4\n    h_ref = 1e-4\n\n    # Initial condition\n    u0 = np.array([1.0, 0.0])\n\n    # --- Helper function for the ODE's right-hand side f(u) = Lu + G(u) ---\n    def f_ode(u, lam, s, beta):\n        u1, u2 = u\n        du1_dt = lam * u1 + s * u2\n        du2_dt = lam * u2 + beta * u1**2\n        return np.array([du1_dt, du2_dt])\n\n    # --- Solver for the reference solution using RK4 ---\n    def compute_reference_solution(lam, s, T, beta):\n        \"\"\"Computes the solution at time T using the RK4 method.\"\"\"\n        u = u0.copy()\n        num_steps = int(T / h_ref)\n        for _ in range(num_steps):\n            k1 = f_ode(u, lam, s, beta)\n            k2 = f_ode(u + h_ref / 2.0 * k1, lam, s, beta)\n            k3 = f_ode(u + h_ref / 2.0 * k2, lam, s, beta)\n            k4 = f_ode(u + h_ref * k3, lam, s, beta)\n            u += (h_ref / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n        return u\n\n    # --- Solver for the ETD Euler solution ---\n    def compute_etd_solution(lam, s, h, T, beta):\n        \"\"\"Computes the solution at time T using the ETD Euler method.\"\"\"\n        u = u0.copy()\n        num_steps = int(T / h)\n\n        # Pre-compute the matrices for the ETD step, E = exp(hL) and P = h*phi_1(hL)\n        z = h * lam\n        exp_z = np.exp(z)\n        \n        # Matrix E = exp(hL)\n        E = exp_z * np.array([[1.0, h * s], [0.0, 1.0]])\n\n        # Matrix P = h * phi_1(hL)\n        # Handle the case lambda = 0 separately to avoid division by zero.\n        if lam == 0.0:\n            # For z=0, phi_1(z)=1 and phi_1'(z)=1/2.\n            # Thus, phi_1(hL) = I + 0.5*hL\n            phi1_mat = np.array([\n                [1.0, h * s / 2.0],\n                [0.0, 1.0]\n            ])\n        else:\n            # For z != 0, use standard formulas for phi_1(z) and its derivative.\n            phi1_val = (exp_z - 1.0) / z\n            phi1_prime_val = (z * exp_z - exp_z + 1.0) / z**2\n            phi1_mat = np.array([\n                [phi1_val, h * s * phi1_prime_val],\n                [0.0, phi1_val]\n            ])\n        \n        P = h * phi1_mat\n\n        # Time-stepping loop\n        for _ in range(num_steps):\n            u1, _ = u\n            G_u = np.array([0.0, beta * u1**2])\n            u = E @ u + P @ G_u\n            \n        return u\n\n    results = []\n    for params in test_cases:\n        lam, s, h, T, beta = params\n        \n        # Compute reference solution\n        u_ref = compute_reference_solution(lam, s, T, beta)\n        \n        # Compute ETD solution\n        u_etd = compute_etd_solution(lam, s, h, T, beta)\n        \n        # Calculate the L2 norm of the error\n        error = np.linalg.norm(u_etd - u_ref)\n        results.append(error)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3227484"}]}