{"hands_on_practices": [{"introduction": "第一个练习是基础热身。我们将应用相对条件数的正式定义，来分析一个看似简单的计算问题：从 $y = \\exp(x)$ 中求解 $x$。这项实践将锻炼你的分析能力，展示如何推导问题敏感性的符号表达式，并识别出哪些输入值会导致病态问题 [@problem_id:3216377]。", "problem": "一个标量测量到求解问题由模型 $y = \\exp(x)$（其中 $y > 0$）给出，其计算任务是根据给定的 $y$ 确定 $x$。请使用基于一阶微扰分析的相对条件数的定义，推导映射 $y \\mapsto x$ 的相对条件数 $\\kappa(y)$ 的显式表达式。明确说明您的表达式适用的定义域，并指出对于哪些 $y$ 值，此问题是病态的（即 $y$ 中的小相对扰动可能导致 $x$ 中的大相对扰动）。请将最终答案以 $\\kappa(y)$ 的单个符号表达式形式给出。", "solution": "该问题要求基于模型 $y = \\exp(x)$，为从给定 $y$ 确定 $x$ 的计算任务推导相对条件数。\n\n首先，我们必须将问题形式化。任务是计算作为 $y$ 的函数的 $x$。我们可以将这种关系表示为 $x = f(y)$。从给定的模型 $y = \\exp(x)$，我们可以通过对两边取自然对数来解出 $x$：\n$$x = \\ln(y)$$\n因此，我们正在分析的函数是 $f(y) = \\ln(y)$。该函数的定义域是 $y > 0$，这与问题陈述一致。\n\n问题 $x = f(y)$ 的相对条件数 $\\kappa(y)$ 是基于一阶微扰分析定义的。它量化了输出 $x$ 中的相对误差对输入 $y$ 中相对误差的敏感度。对于输入中的一个小的扰动 $\\delta y$，输出中相应的扰动 $\\delta x$ 可近似为 $\\delta x \\approx f'(y) \\delta y$。相对条件数是输出的相对变化与输入的相对变化之比的绝对值，在无穷小扰动的极限下：\n$$ \\kappa(y) = \\frac{|\\delta x / x|}{|\\delta y / y|} = \\left| \\frac{\\delta x}{\\delta y} \\frac{y}{x} \\right| $$\n在极限 $\\delta y \\to 0$ 时，比率 $\\frac{\\delta x}{\\delta y}$ 变为导数 $f'(y)$。代入 $x = f(y)$，公式变为：\n$$ \\kappa(y) = \\left| f'(y) \\frac{y}{f(y)} \\right| = \\left| \\frac{y f'(y)}{f(y)} \\right| $$\n为了应用此公式，我们需要计算 $f(y) = \\ln(y)$ 的导数。其导数为：\n$$ f'(y) = \\frac{d}{dy}(\\ln(y)) = \\frac{1}{y} $$\n现在我们将 $f(y) = \\ln(y)$ 和 $f'(y) = \\frac{1}{y}$ 代入条件数的表达式中：\n$$ \\kappa(y) = \\left| \\frac{y \\left(\\frac{1}{y}\\right)}{\\ln(y)} \\right| $$\n化简分子中的表达式得到：\n$$ \\kappa(y) = \\left| \\frac{1}{\\ln(y)} \\right| $$\n这就是映射 $y \\mapsto x$ 的相对条件数的显式表达式。\n\n此表达式适用的定义域由所涉及函数的定义域确定。函数 $f(y) = \\ln(y)$ 对所有 $y > 0$ 都有定义。$\\kappa(y)$ 的表达式分母中有 $\\ln(y)$，因此当 $\\ln(y) = 0$ 时，该表达式无定义。这在 $y = 1$ 时发生。因此，$\\kappa(y)$ 表达式的定义域是 $y \\in (0, 1) \\cup (1, \\infty)$。\n\n如果一个问题的条件数非常大，即 $\\kappa(y) \\gg 1$，则该问题被认为是病态的。这意味着输入 $y$ 中的小相对扰动可能导致输出 $x$ 中的大相对扰动。我们必须确定使 $\\kappa(y)$ 变大的 $y$ 值。\n$$ \\kappa(y) = \\left| \\frac{1}{\\ln(y)} \\right| $$\n当其分母的绝对值 $|\\ln(y)|$ 很小（接近 $0$）时，$\\kappa(y)$ 的值很大。当 $y$ 趋近于 $1$ 时，函数 $\\ln(y)$ 趋近于 $0$。\n$$ \\lim_{y \\to 1} \\kappa(y) = \\lim_{y \\to 1} \\left| \\frac{1}{\\ln(y)} \\right| = \\infty $$\n因此，对于接近 $1$ 的 $y$ 值，该问题是病态的。对于这些值，测量值 $y$ 中的一个小的相对误差将在计算出的 $x = \\ln(y)$ 值中被显著放大。这在直觉上是合理的：当 $y$ 接近 $1$ 时，$x$ 接近 $0$。当 $x$ 接近 $0$ 时，$x$ 中的相对误差 $\\frac{\\delta x}{x}$ 对任何非零的绝对误差 $\\delta x$ 都变得非常敏感。", "answer": "$$\\boxed{\\left| \\frac{1}{\\ln(y)} \\right|}$$", "id": "3216377"}, {"introduction": "从解析推导转向计算实验，本实践将解决科学计算中最常见的任务之一：求解线性方程组。你将使用臭名昭著的希尔伯特矩阵 (Hilbert matrix)——一个经典的病态矩阵范例——来亲眼见证巨大的条件数如何灾难性地放大微小的浮点误差。这个编程练习 [@problem_id:2428600] 将使条件数、前向误差和后向误差之间的理论关系变得具体而难忘。", "problem": "编写一个完整的程序，以经验性地展示在标准浮点运算中，问题条件对求解线性系统精度的影响。考虑线性系统 $A x = b$，其中 $A$ 是一个 $n \\times n$ 的希尔伯特矩阵，其元素为 $A_{i j} = \\dfrac{1}{i + j - 1}$，$1 \\le i,j \\le n$。对于每个测试用例，定义精确解向量 $x_{\\text{true}} \\in \\mathbb{R}^n$ 为 $x_{\\text{true}} = \\mathbf{1}$（全为1），并构造右端项 $b = A x_{\\text{true}}$。然后使用符合电气和电子工程师协会（IEEE）$754$ 双精度（binary$64$）语义的标准浮点运算计算数值解 $\\hat{x}$。使用 $\\hat{x}$，计算以下量值：\n- $2$-范数条件数 $\\kappa_2(A) = \\|A\\|_2 \\,\\|A^{-1}\\|_2$。\n- $2$-范数下的相对前向误差 $\\dfrac{\\|\\hat{x} - x_{\\text{true}}\\|_2}{\\|x_{\\text{true}}\\|_2}$。\n- 缩放残差（一个归一化的后向误差代理）$\\dfrac{\\|b - A \\hat{x}\\|_2}{\\|A\\|_2 \\,\\|\\hat{x}\\|_2 + \\|b\\|_2}$。\n- 估计解中的正确十进制位数，定义为 $\\max\\!\\bigl(0,\\,-\\log_{10}(\\max(\\text{相对前向误差}, \\varepsilon)))$，其中 $\\varepsilon$ 表示最小的正规格化 IEEE $754$ 双精度数。\n\n测试集：\n对以下问题规模 $n$ 进行上述评估：\n- $n = 3$,\n- $n = 6$,\n- $n = 10$,\n- $n = 12$。\n\n所有向量和矩阵范数均为谱范数（即矩阵 $2$-范数和向量 $2$-范数）。不涉及角度。不涉及物理单位。\n\n您的程序必须生成单行输出，其中包含所有测试结果，格式为一个用方括号括起来的逗号分隔列表，其中每个测试结果本身就是一个形如 $[n,\\;\\kappa_2(A),\\;\\text{相对前向误差},\\;\\text{缩放残差},\\;\\text{估计位数}]$ 的列表。因此，最终输出必须是表示列表的列表的单行，不含任何额外文本。例如，其结构必须类似于 $[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\ldots]$，但用实际计算出的数字代替占位符。", "solution": "该问题要求对病态条件对线性方程组 $A x = b$ 解的影响进行经验性研究。这是一个经典的数值线性代数练习，旨在演示问题条件、前向误差和后向误差等基本概念。矩阵 $A$ 被选为 $n \\times n$ 的希尔伯特矩阵，这是一个严重病态矩阵的经典例子。其元素由 $A_{i j} = \\frac{1}{i + j - 1}$ 给出，其中 $i, j$ 从 $1$ 到 $n$。\n\n数值分析的核心不仅在于计算解，还在于理解其精度。计算出的解（我们表示为 $\\hat{x}$）的精度受两个主要因素影响：所用算法的稳定性和问题本身的内在敏感性。这种敏感性由条件数来量化。\n\n对于线性系统 $A x = b$，矩阵 $A$ 的 $2$-范数条件数定义为：\n$$ \\kappa_2(A) = \\|A\\|_2 \\|A^{-1}\\|_2 $$\n其中 $\\| \\cdot \\|_2$ 是谱范数（最大奇异值）。一个大的条件数 $\\kappa_2(A) \\gg 1$ 表示一个病态问题，其中输入数据（$A$ 或 $b$）的微小相对扰动可能导致解 $x$ 的巨大相对变化。\n\n当我们使用浮点运算求解 $A x = b$ 时，不可避免地会引入舍入误差。一个后向稳定的算法，例如标准求解器所采用的 LU 分解，会产生一个计算解 $\\hat{x}$，它是某个微扰问题的精确解：\n$$ (A + \\delta A) \\hat{x} = b + \\delta b $$\n这些扰动 $\\delta A$ 和 $\\delta b$ 的“小性”是衡量算法后向稳定性的一个尺度。数值分析中的一个关键结果为相对前向误差建立了以下界限：\n$$ \\frac{\\|\\hat{x} - x_{\\text{true}}\\|_2}{\\|x_{\\text{true}}\\|_2} \\le \\kappa_2(A) \\left( \\frac{\\|\\delta A\\|_2}{\\|A\\|_2} + \\frac{\\|\\delta b\\|_2}{\\|b\\|_2} \\right) $$\n右侧括号中的项是相对后向误差。对于一个在机器精度 $\\varepsilon_{\\text{mach}}$ 下运行的后向稳定算法，后向误差通常为 $\\mathcal{O}(\\varepsilon_{\\text{mach}})$ 阶。IEEE $754$ 双精度的机器精度约为 $2.22 \\times 10^{-16}$。因此，我们预期相对前向误差的界限约为 $\\kappa_2(A) \\cdot \\varepsilon_{\\text{mach}}$。这表明，大的条件数会放大不可避免的舍入误差，可能完全破坏解的精度。\n\n残差向量定义为 $r = b - A \\hat{x}$。残差的范数 $\\|r\\|_2$ 与后向误差有关。问题要求计算一个特定的缩放残差：\n$$ \\frac{\\|b - A \\hat{x}\\|_2}{\\|A\\|_2 \\,\\|\\hat{x}\\|_2 + \\|b\\|_2} $$\n这个量可作为后向误差的一个归一化代理。由于求解器的后向稳定性，我们预期即使条件数增长、前向误差爆炸，这个值也应保持在 $\\varepsilon_{\\text{mach}}$ 的数量级上。这是一个至关重要的区别：小的残差不保证小的前向误差。\n\n最后，我们估计解中的正确十进制位数。这与相对前向误差直接相关。如果相对误差为 $10^{-k}$，那么解的精度大约为 $k$ 位十进制数。给定的公式 $\\max\\!\\bigl(0,\\,-\\log_{10}(\\max(\\text{相对前向误差}, \\varepsilon)))$ 将此概念形式化。项 $\\varepsilon$ 是最小的正规格化双精度数，约等于 $2.225 \\times 10^{-308}$，它能防止对零取对数，并处理误差小于可表示精度的情况。\n\n我们现在将对指定的矩阵规模测试集 $n \\in \\{3, 6, 10, 12\\}$ 执行这些计算。对于每个 $n$：\n1.  构造 $n \\times n$ 的希尔伯特矩阵 $A$。\n2.  将真实解 $x_{\\text{true}}$ 定义为包含 $n$ 个 1 的向量。\n3.  计算右端项 $b = A x_{\\text{true}}$。\n4.  使用标准线性求解器求解数值解 $\\hat{x}$。\n5.  计算四个指定的量：$\\kappa_2(A)$、相对前向误差、缩放残差和估计位数。\n\n结果将经验性地验证该理论。希尔伯特矩阵的条件数随 $n$ 的增长而急剧增大。对于小的 $n$（例如，$n=3$），$\\kappa_2(A)$ 适中，我们预期会得到一个相当精确的解。当 $n$ 增加到 $10$ 和 $12$ 时，$\\kappa_2(A)$ 将变得巨大（$> 10^{13}$），导致相对前向误差达到 $1$ 或更高，意味着精度完全丧失。在整个过程中，缩放残差应保持较小，这表明了算法的后向稳定性，与病态问题导致的前向精度差形成对比。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import hilbert\n\ndef solve():\n    \"\"\"\n    Empirically demonstrates the effect of problem conditioning on the accuracy\n    of solving linear systems Ax = b using the Hilbert matrix.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [3, 6, 10, 12]\n\n    results = []\n    \n    # Epsilon as defined in the problem: the smallest positive normalized\n    # IEEE 754 double-precision number.\n    smallest_norm_val = np.finfo(np.float64).smallest_normal\n\n    for n in test_cases:\n        # Step 1: Construct the n x n Hilbert matrix A.\n        A = hilbert(n)\n\n        # Step 2: Define the exact solution and construct the right-hand side.\n        x_true = np.ones(n)\n        b = A @ x_true\n\n        # Step 3: Compute the numerical solution using standard floating-point arithmetic.\n        x_hat = np.linalg.solve(A, b)\n\n        # Step 4: Compute the required quantities.\n        # 2-norm condition number\n        cond_A = np.linalg.cond(A, 2)\n        \n        # Relative forward error\n        norm_x_true = np.linalg.norm(x_true, 2)\n        forward_error = np.linalg.norm(x_hat - x_true, 2) / norm_x_true\n        \n        # Scaled residual (normalized backward error proxy)\n        norm_A = np.linalg.norm(A, 2)\n        norm_x_hat = np.linalg.norm(x_hat, 2)\n        norm_b = np.linalg.norm(b, 2)\n        residual_norm = np.linalg.norm(b - A @ x_hat, 2)\n        scaled_residual = residual_norm / (norm_A * norm_x_hat + norm_b)\n        \n        # Estimated number of correct decimal digits\n        # Clamp the argument of log10 to be at least smallest_norm_val\n        error_for_log = max(forward_error, smallest_norm_val)\n        est_digits = max(0.0, -np.log10(error_for_log))\n\n        results.append([n, cond_A, forward_error, scaled_residual, est_digits])\n\n    # Final print statement in the exact required format.\n    # [[n, kappa, fwd_err, scaled_res, digits], ...]\n    # The output format is a string representation of a list of lists.\n    # Using str() on a list handles the inner brackets.\n    output_str = f\"[{','.join([str(res) for res in results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2428600"}, {"introduction": "我们最后的实践将探讨另一个著名且引人入胜的极端病态案例：威尔金森多项式 (Wilkinson's polynomial)。尽管它的根是 $1$ 到 $20$ 这些简单且间隔良好的整数，但从其展开式的系数中求解这些根却是一个出了名的不稳定问题。通过这个编程练习 [@problem_id:3216312]，你将通过经验性研究发现，对单个系数的微小扰动如何导致根发生巨大的、甚至是复数的偏移，从而加深你对数值不稳定性可能出现的微妙方式的理解。", "problem": "考虑威尔金森 (Wilkinson) 多项式的求根问题，该多项式定义为 $p(x) = \\prod_{i=1}^{20} (x - i)$，其中输入是系数向量，输出是根向量。从问题条件数的基本定义出发：对于一个从输入到输出的映射 $F$，在输入 $u$ 处的（相对）条件数，量化了当 $u$ 受到任意小扰动时，相对输出变化与相对输入变化的极限比率。利用这一原理，分析 $p(x)$ 单个系数的扰动如何影响多项式的根。\n\n您的任务是实现一个程序，以经验性地估计 $p(x)$ 求根问题相对于 $x^{19}$ 系数扰动的相对条件数。分析应遵循以下要求：\n\n1. 从 $p(x)$ 的精确根 $[1,2,\\dots,20]$ 构建其系数。设系数向量为 $(c_{20}, c_{19}, \\dots, c_{0})$，按 $x$ 的降幂排列，其中 $c_{20} = 1$，$c_{19}$ 是 $x^{19}$ 的系数。\n\n2. 对于施加于 $x^{19}$ 系数的一个扰动 $\\varepsilon$，构造扰动后的多项式 $q_\\varepsilon(x)$，其系数向量与 $p(x)$ 的系数向量相同，除了 $x^{19}$ 的系数变为 $c_{19} + \\varepsilon$。\n\n3. 数值计算 $q_\\varepsilon(x)$ 的根。由于精确的、未受扰动的根是整数 $1,2,\\dots,20$，通过最小化绝对差 $|r_\\varepsilon - i|$，将每个扰动后的根与这些整数之一配对，确保一一对应。\n\n4. 对于每个匹配的根 $i \\in \\{1,2,\\dots,20\\}$ 及其配对的扰动根 $r_{\\varepsilon,i}$，计算根的经验相对变化为 $|r_{\\varepsilon,i} - i| / |i|$。计算系数的相对变化为 $|\\varepsilon| / |c_{19}|$。定义根 $i$ 在扰动 $\\varepsilon$ 下的经验相对条件数估计值为\n$$\n\\kappa_i(\\varepsilon) = \\frac{|r_{\\varepsilon,i} - i| / |i|}{|\\varepsilon| / |c_{19}|}.\n$$\n\n5. 对于每个 $\\varepsilon$，报告 20 个根中的最大经验相对条件数，即 $\\max_{i} \\kappa_i(\\varepsilon)$。\n\n使用以下扰动测试套件来探测不同的区间：\n- “理想路径”下的小扰动：$\\varepsilon = 10^{-10}$。\n- 一个较大的扰动以揭示更显著的敏感性：$\\varepsilon = 10^{-8}$。\n- 一个负的小扰动以测试符号敏感性：$\\varepsilon = -10^{-10}$。\n\n您的程序应生成单行输出，其中包含三个得到的最大经验相对条件数，按测试套件的顺序排列，形式为用方括号括起来的逗号分隔列表，例如 $[k_1,k_2,k_3]$，其中每个 $k_j$ 是一个浮点数，对应上面列出的相应 $\\varepsilon$。不涉及物理单位；所有量根据其构造都是无量纲的。", "solution": "这是一个经典的数值分析练习，旨在通过经验性地估计病态性，来探讨问题条件的概念。威尔金森 (Wilkinson) 多项式 $p(x) = \\prod_{i=1}^{20} (x - i)$ 是一个典型的例子，用于说明从系数求多项式根的问题可能是严重病态的。\n\n核心原理是问题相对条件数的定义。对于一个将输入 $x$ 映射到输出 $y = F(x)$ 的函数 $F$，在点 $x$ 处的相对条件数 $\\kappa(x)$ 定义为当输入扰动趋于零时，输出的相对变化与输入的相对变化之比的极限：\n$$\n\\kappa(x) = \\lim_{\\delta \\to 0} \\sup_{\\|\\delta x\\| \\le \\delta \\|x\\|} \\frac{\\|F(x+\\delta x) - F(x)\\| / \\|F(x)\\|}{\\|\\delta x\\| / \\|x\\|}\n$$\n在我们的情境中，问题是函数 $F$，它将多项式的系数向量 $\\mathbf{c} = (c_{20}, c_{19}, \\dots, c_0)$ 映射到其根向量 $\\mathbf{r} = (r_1, r_2, \\dots, r_{20})$。我们感兴趣的是根对于单个系数 $c_{19}$ 扰动的敏感性。问题提供了一个公式，用于在对 $c_{19}$ 施加有限扰动 $\\varepsilon$ 的情况下，对特定根 $i$ 的条件数进行经验估计：\n$$\n\\kappa_i(\\varepsilon) = \\frac{\\Delta r_i^{(rel)}}{\\Delta c_{19}^{(rel)}} = \\frac{|r_{\\varepsilon,i} - i| / |i|}{|\\varepsilon| / |c_{19}|}\n$$\n这里，$r_{\\varepsilon,i}$ 是对应于原始根 $i$ 的扰动根，而 $|\\varepsilon|/|c_{19}|$ 是 $x^{19}$ 系数的相对扰动。我们的目标是为几个给定的 $\\varepsilon$ 值计算 $\\max_i \\kappa_i(\\varepsilon)$。\n\n步骤如下：\n\n1.  **定义精确的根和系数**：威尔金森 (Wilkinson) 多项式的精确根是整数 $r_i = i$，其中 $i \\in \\{1, 2, \\dots, 20\\}$。该多项式为 $p(x) = \\prod_{i=1}^{20} (x - i)$。根据这些根，我们可以构建系数向量 $\\mathbf{c} = (c_{20}, c_{19}, \\dots, c_0)$，其中 $p(x) = \\sum_{k=0}^{20} c_k x^k$。系数 $c_{20}$ 为 $1$。根据韦达定理 (Vieta's formulas)，系数 $c_{19}$ 是所有根之和的相反数：\n    $$\n    c_{19} = -\\sum_{i=1}^{20} i = -\\frac{20(20+1)}{2} = -210\n    $$\n\n2.  **施加扰动**：对于测试套件中的每个给定扰动值 $\\varepsilon$（$\\varepsilon \\in \\{10^{-10}, 10^{-8}, -10^{-10}\\}$），我们构成一个新的、受扰动的系数向量 $\\mathbf{c}_\\varepsilon$。该向量与 $\\mathbf{c}$ 完全相同，除了 $x^{19}$ 的系数变为 $c_{19, \\varepsilon} = c_{19} + \\varepsilon$。这就定义了扰动后的多项式 $q_\\varepsilon(x)$。\n\n3.  **计算并匹配根**：我们数值计算 $q_\\varepsilon(x)$ 的根，记为集合 $\\{r_{\\varepsilon,j}\\}_{j=1}^{20}$。尽管原始根都是实数，但对系数的微小扰动可能导致复数根。问题规定，我们必须通过最小化距离 $|r_{\\varepsilon,j} - i|$ 来将每个原始根 $i$ 与一个扰动根 $r_{\\varepsilon,i}$ 配对，同时确保一一对应。对于所考虑的小扰动，扰动后的根会保持在其原始位置附近。通过按实部对计算出的根进行排序，并将它们与自然排序的原始根（$1, 2, \\dots, 20$）配对，可以提供一种鲁棒且正确的匹配方法。\n\n4.  **计算最大经验条件数**：对于每个原始根 $i$ 及其匹配的扰动根 $r_{\\varepsilon,i}$，我们使用提供的公式计算经验条件数估计值 $\\kappa_i(\\varepsilon)$。对于给定的 $\\varepsilon$，最终结果是在所有 20 个根中找到的最大值：\n    $$\n    \\kappa(\\varepsilon) = \\max_{i \\in \\{1, 2, \\dots, 20\\}} \\kappa_i(\\varepsilon)\n    $$\n\n对测试套件中的每个 $\\varepsilon$ 值执行此过程，以观察扰动的大小如何影响所测量的根的敏感性。该实现将使用数值库来处理多项式系数的生成和求根。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Empirically estimates the condition number of the root-finding problem\n    for the Wilkinson polynomial with respect to perturbations of the x^19 coefficient.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        1e-10,  # \"happy path\" small perturbation\n        1e-8,   # larger perturbation\n        -1e-10, # negative small perturbation\n    ]\n\n    # 1. Construct the polynomial from its exact roots.\n    # The exact roots are the integers from 1 to 20.\n    exact_roots = np.arange(1, 21, dtype=float)\n\n    # numpy.poly returns coefficients in descending order of power.\n    # For roots r_1, ..., r_n, it returns coeffs for (x-r_1)...(x-r_n).\n    # The first coefficient (for x^20) is 1.\n    p_coeffs = np.poly(exact_roots)\n\n    # The coefficient of x^19 is the second element of the array.\n    # From Vieta's formulas, c_19 = -sum(roots) = -210.\n    c19 = p_coeffs[1]\n\n    results = []\n    for eps in test_cases:\n        # 2. Form the perturbed polynomial q_eps(x).\n        q_coeffs = p_coeffs.copy()\n        # The perturbation is applied to the coefficient of x^19.\n        q_coeffs[1] += eps\n\n        # 3. Compute the roots of the perturbed polynomial.\n        # numpy.roots returns complex roots.\n        perturbed_roots = np.roots(q_coeffs)\n\n        # 3. Match perturbed roots to original roots.\n        # For small perturbations, the roots stay ordered by their real part.\n        # Sorting both sets of roots ensures a correct one-to-one matching.\n        # The exact roots are already sorted. We sort the perturbed roots.\n        # numpy.sort on a complex array sorts lexicographically (real then imag part).\n        perturbed_roots.sort()\n\n        # 4. Compute the empirical relative condition number for each root.\n        kappa_i_values = []\n        for i in range(len(exact_roots)):\n            exact_root = exact_roots[i]\n            perturbed_root = perturbed_roots[i]\n            \n            # The problem defines kappa_i relative to the original root i.\n            # abs() on a complex number computes its modulus.\n            rel_change_root = abs(perturbed_root - exact_root) / abs(exact_root)\n            \n            # The relative change in the coefficient is wrt to its original value.\n            rel_change_coeff = abs(eps) / abs(c19)\n            \n            # Handle the case where the relative change in coeff is zero, though\n            # test cases prevent this.\n            if rel_change_coeff == 0:\n                kappa_i = 0.0\n            else:\n                kappa_i = rel_change_root / rel_change_coeff\n            \n            kappa_i_values.append(kappa_i)\n\n        # 5. Report the maximum empirical relative condition number over the 20 roots.\n        max_kappa = np.max(kappa_i_values)\n        results.append(max_kappa)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3216312"}]}