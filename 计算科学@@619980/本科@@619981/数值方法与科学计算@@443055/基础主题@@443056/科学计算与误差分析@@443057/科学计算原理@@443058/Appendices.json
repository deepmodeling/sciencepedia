{"hands_on_practices": [{"introduction": "科学计算建立在浮点数之上，而浮点数仅仅是实数的近似。这项实践旨在揭示一个令人惊讶却又至关重要的后果：数字相加的顺序会改变最终结果。通过在一个简化的浮点系统中手动执行求和，我们能直观地理解舍入误差和“大数吃小数”（swamping）现象，这是编写稳健数值代码的关键第一步 [@problem_id:3271349]。", "problem": "考虑一个规格化的浮点系统，其基数 $\\beta = 10$，精度为 $t = 3$ 个有效数字，采用电气与电子工程师协会 (Institute of Electrical and Electronics Engineers, IEEE) 754 标准规定的“就近舍入，平局取偶”规则。在此系统中，每次基本加法运算后，结果都会被舍入到最接近的可表示的、具有 $3$ 位有效数字的浮点数。\n\n给定一个正实数列表：\n$$\n\\{10^{6},\\, 2400,\\, 1700,\\, 1600,\\, 1200,\\, 1100,\\, 800,\\, 500,\\, 400\\}。\n$$\n您将对该列表执行两次浮点求和，每次加法后都进行舍入以符合浮点模型：\n\n1. 从大到小求和。\n2. 从小到大求和。\n\n从浮点表示法的基本定义和舍入机制出发，解释为什么两种顺序会产生不同的累积舍入误差。然后，在该浮点系统内精确地执行这两种求和，将每个结果与精确的实数和进行比较，并计算从大到小求和的绝对误差与从小到大求和的绝对误差之比 $R$。\n\n请用最简分数的形式精确表达您对 $R$ 的最终答案。无需单位。", "solution": "该问题要求在一个指定的数值系统内分析浮点求和的顺序效应。该系统是一个规格化的浮点系统，基数 $\\beta = 10$，精度 $t = 3$，舍入规则为舍入到最接近的可表示数，平局时舍入到最低有效位为偶数的数。\n\n在此系统中，一个数 $x$ 表示为 $fl(x) = \\pm m \\times \\beta^{e}$，其中尾数 $m$ 是一个具有 $t$ 位数字的数，形式为 $d_1.d_2...d_t$，其中 $d_1 \\in \\{1, 2, ..., 9\\}$，$i>1$ 时 $d_i \\in \\{0, 1, ..., 9\\}$，$e$ 是一个整数指数。对于我们的系统，其形式为 $fl(x) = \\pm d_1.d_2d_3 \\times 10^{e}$。\n\n问题的核心在于浮点加法的性质。当两个量级不同的浮点数相加时，它们的指数必须对齐。让我们考虑一个大数 $L$ 和一个小数 $s$ 的相加。如果 $L = m_L \\times 10^{e_L}$ 且 $s = m_s \\times 10^{e_s}$，其中 $e_L > e_s$，则加法运算为 $(m_L + m_s \\times 10^{e_s - e_L}) \\times 10^{e_L}$。如果差值 $e_L - e_s$ 足够大，项 $m_s \\times 10^{e_s - e_L}$ 会变得非常小，以至于不影响 $m_L$ 的前 $t$ 位有效数字。舍入后，结果就只是 $fl(L+s) = L$。这种现象被称为“淹没”或“吸收”，它会导致信息丢失，因为 $s$ 的贡献被完全丢弃了。\n\n将一列数从大到小相加会加剧这个问题。累加和会迅速变得非常大，导致后续较小的数被“淹没”，其值丢失。相反，从小到大求和则允许较小的数累积起来。累加和增长得更缓慢。到加上最大的数时，小数的累加和可能已经足够大，相对于大数而言具有显著性，从而避免或减轻了信息丢失。\n\n首先，我们确定给定数字的精确实数和 $S_{exact}$，以便进行误差比较。\n数字列表为 $\\{10^{6}, 2400, 1700, 1600, 1200, 1100, 800, 500, 400\\}$。\n$$\nS_{exact} = 1000000 + 2400 + 1700 + 1600 + 1200 + 1100 + 800 + 500 + 400\n$$\n$$\nS_{exact} = 1000000 + 9700 = 1009700\n$$\n\n现在，我们在指定的浮点系统中执行这两种求和。设 $fl(\\cdot)$ 表示舍入到 $t=3$ 位尾数的操作。\n\n**1. 从大到小求和**\n列表按顺序为 $\\{10^{6}, 2400, 1700, 1600, 1200, 1100, 800, 500, 400\\}$。\n设 $S_{large,i}$ 为第 $i$ 次加法后的累加和。\n初始和：$S_{large,0} = 10^{6} = 1.00 \\times 10^{6}$。\n步骤 1：$S_{large,1} = fl(1.00 \\times 10^{6} + 2400) = fl(1.00 \\times 10^{6} + 2.40 \\times 10^{3})$。\n为了相加，我们对齐指数：\n$1.00 \\times 10^{6} + 0.00240 \\times 10^{6} = 1.00240 \\times 10^{6}$。\n尾数是 $1.00240$。为了舍入到3位有效数字，我们检查第四位数字，即 $2$。由于 $2  5$，我们向下舍入。\n$S_{large,1} = 1.00 \\times 10^{6}$。\n数字 $2400$ 由于淹没而被丢失了。\n\n步骤 2：$S_{large,2} = fl(1.00 \\times 10^{6} + 1700) = fl(1.00 \\times 10^{6} + 1.70 \\times 10^{3})$。\n$1.00 \\times 10^{6} + 0.00170 \\times 10^{6} = 1.00170 \\times 10^{6}$。\n向下舍入得到 $S_{large,2} = 1.00 \\times 10^{6}$。\n\n对于列表中余下的任何数 $x$，其量级小于或等于 $2400$。与累加和 $1.00 \\times 10^{6}$ 的加法将采用 $fl(1.00 \\times 10^{6} + x)$ 的形式。精确的和将是 $1.00... \\times 10^{6}$。尾数的第四位有效数字将始终小于5，因此舍入结果将始终是 $1.00 \\times 10^{6}$。\n因此，从大到小相加的最终和是：\n$$\nS_{large\\_first} = 1.00 \\times 10^{6} = 1000000\n$$\n\n**2. 从小到大求和**\n列表按顺序为 $\\{400, 500, 800, 1100, 1200, 1600, 1700, 2400, 10^{6}\\}$。\n设 $S_{small,i}$ 为累加和。所有数字都用 $t=3$ 位数字表示。\n$S_{small,0} = fl(400) = 4.00 \\times 10^{2}$。\n$S_{small,1} = fl(400 + 500) = fl(900) = 9.00 \\times 10^{2}$。\n$S_{small,2} = fl(900 + 800) = fl(1700) = 1.70 \\times 10^{3}$。\n$S_{small,3} = fl(1700 + 1100) = fl(2800) = 2.80 \\times 10^{3}$。\n$S_{small,4} = fl(2800 + 1200) = fl(4000) = 4.00 \\times 10^{3}$。\n$S_{small,5} = fl(4000 + 1600) = fl(5600) = 5.60 \\times 10^{3}$。\n$S_{small,6} = fl(5600 + 1700) = fl(7300) = 7.30 \\times 10^{3}$。\n$S_{small,7} = fl(7300 + 2400) = fl(9700) = 9.70 \\times 10^{3}$。\n到目前为止，所有的中间和在浮点系统中都是精确可表示的，所以尚未引入舍入误差。\n\n最后一步：\n$S_{small,8} = fl(9700 + 10^{6}) = fl(9.70 \\times 10^{3} + 1.00 \\times 10^{6})$。\n对齐指数：\n$0.00970 \\times 10^{6} + 1.00 \\times 10^{6} = 1.00970 \\times 10^{6}$。\n精确的尾数是 $1.00970$。我们必须将其舍入到3位有效数字。前三位是 $1.00$。第四位是 $9$。由于 $9 \\ge 5$，我们将第三位向上舍入。\n新的尾数是 $1.01$。\n因此，从小到大相加的最终和是：\n$$\nS_{small\\_first} = 1.01 \\times 10^{6} = 1010000\n$$\n\n**3. 误差计算与比率**\n现在我们计算两种求和顺序的绝对误差。\n从大到小求和的绝对误差：\n$$\nE_{large} = |S_{large\\_first} - S_{exact}| = |1000000 - 1009700| = |-9700| = 9700\n$$\n从小到大求和的绝对误差：\n$$\nE_{small} = |S_{small\\_first} - S_{exact}| = |1010000 - 1009700| = |300| = 300\n$$\n问题要求计算这些绝对误差的比率 $R$。\n$$\nR = \\frac{E_{large}}{E_{small}} = \\frac{9700}{300}\n$$\n化简该分数得到：\n$$\nR = \\frac{97}{3}\n$$\n分子 $97$ 是一个质数，且不能被 $3$ 整除。因此，这个分数是其最简形式。这个结果在数值上证明了，从小到大求和比从大到小求和得到了一个显著更精确的结果。", "answer": "$$\\boxed{\\frac{97}{3}}$$", "id": "3271349"}, {"introduction": "从静态的数值计算过渡到动态系统，我们常用常微分方程（ODEs）来模拟现实世界。本练习将探讨“刚性”系统，即系统中包含多个尺度差异巨大的过程，这在化学动力学和电路模拟等领域屡见不鲜。通过比较一个简单的显式方法（前向欧拉法）和一个隐式方法（后向欧拉法），你将亲眼见证为何刚性问题对数值稳定性构成巨大挑战，以及为何隐式方法是科学计算工具箱中不可或缺的利器 [@problem_id:3271344]。", "problem": "考虑一个线性、无量纲化学反应网络的初值问题，该网络由一个常微分方程（ODE）系统描述。设 $y_1$ 表示物质 A 的量， $y_2$ 表示物质 B 的量。物质 A 以一个快速率常数 $k_1$（单位为每秒）转化为物质 B，而物质 B 以一个慢速率常数 $k_2$（单位为每秒）衰减。控制方程为\n$$\n\\frac{d}{dt}\\begin{bmatrix} y_1(t) \\\\ y_2(t) \\end{bmatrix}\n=\n\\begin{bmatrix}\n-k_1  0 \\\\\nk_1  -k_2\n\\end{bmatrix}\n\\begin{bmatrix} y_1(t) \\\\ y_2(t) \\end{bmatrix},\n\\quad\n\\begin{bmatrix} y_1(0) \\\\ y_2(0) \\end{bmatrix}\n=\n\\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}.\n$$\n您必须编写一个完整的程序，使用两种时间步进方法来数值逼近最终时间 $T$ 的解：\n- 显式前向欧拉法（一阶显式），通过以步长 $\\Delta t$ 离散化时间来定义。\n- 隐式后向欧拉法（一阶隐式），通过以步长 $\\Delta t$ 离散化时间来定义。\n\n基本出发点是常微分方程初值问题的定义，以及应用于线性系统 $y' = A y$ 的数值方法的稳定性由与雅可比矩阵 $A$ 的特征值相关的放大因子决定的原理。概念上的目标是通过第一性原理的推理和计算，展示刚度是如何从相差悬殊的时间尺度中产生的，以及为什么隐式方法在较大的 $\\Delta t$ 值下可以保持稳定，而显式方法在相同条件下会失效。\n\n您的程序必须：\n- 对于每个测试用例，使用两种方法将系统积分到时间 $T$，并返回两种方法的最终值 $y_1(T)$ 和 $y_2(T)$。\n- 通过检查矩阵 $A$ 的特征值 $\\lambda_i$ 是否满足标量前向欧拉稳定性条件 $|1 + \\Delta t\\,\\lambda_i|  1$（对所有 $i$），来确定前向欧拉法的线性稳定性。返回一个布尔值，指示对于给定的 $\\Delta t$ 这个严格稳定性条件是否成立。\n- 所有返回的 $y_1(T)$ 和 $y_2(T)$ 值都是无量纲的。\n\n使用以下参数集 $(k_1, k_2, T, \\Delta t)$ 的测试套件：\n- 案例 1：$k_1 = 1000$， $k_2 = 1$， $T = 0.05$， $\\Delta t = 0.0001$。\n- 案例 2：$k_1 = 1000$， $k_2 = 1$， $T = 0.05$， $\\Delta t = 0.01$。\n- 案例 3：$k_1 = 1000$， $k_2 = 1$， $T = 0.05$， $\\Delta t = 0.002$。\n- 案例 4：$k_1 = 50$， $k_2 = 1$， $T = 0.05$， $\\Delta t = 0.01$。\n\n为覆盖率设计：\n- 案例 1 是一个使用小 $\\Delta t$ 的理想路径，两种方法都应该表现良好。\n- 案例 2 使用相对于快速时间尺度较大的 $\\Delta t$，旨在使显式方法不稳定，而隐式方法保持稳定。\n- 案例 3 将 $\\Delta t$ 设置在与快速模式相关的显式稳定性边界上，以说明不衰减的振荡和严格稳定性的失效。\n- 案例 4 减小了刚度（较小的 $k_1$），因此显式方法在所选的 $\\Delta t$ 下是稳定的。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。\n- 对于每个测试用例，返回一个形式为 $[y_1^{\\text{BE}}(T), y_2^{\\text{BE}}(T), y_1^{\\text{FE}}(T), y_2^{\\text{FE}}(T), \\text{FE\\_stable}]$ 的列表，其中 $y_1^{\\text{BE}}(T)$ 和 $y_2^{\\text{BE}}(T)$ 表示后向欧拉法的最终值， $y_1^{\\text{FE}}(T)$ 和 $y_2^{\\text{FE}}(T)$ 表示前向欧拉法的最终值，而 $\\text{FE\\_stable}$ 是一个布尔值。\n- 最终打印的行必须将所有案例的结果聚合到一个列表中，例如 $[[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$，输出行中没有空格。\n\n不涉及角度。所有返回的浓度都是无量纲数。速率常数的单位是每秒，时间的单位是秒，但您不需要打印单位。输出值必须是精确指定的浮点数或布尔值。", "solution": "用户提供的问题被评估为有效。它具有科学依据，是适定的、客观的且自洽的。该问题描述了一个经典的刚性常微分方程（ODE）系统，并要求使用标准方法对其进行数值求解，以演示数值稳定性中的核心概念。所有必要的数据和定义都已提供，没有矛盾或含糊之处。\n\n### 问题表述\n\n该问题描述了一个由两个线性一阶常微分方程组成的系统的初值问题（IVP）：\n$$\n\\frac{d\\mathbf{y}(t)}{dt} = A \\mathbf{y}(t), \\quad \\mathbf{y}(0) = \\mathbf{y}_0\n$$\n其中 $\\mathbf{y}(t) = \\begin{bmatrix} y_1(t) \\\\ y_2(t) \\end{bmatrix}$ 是物质浓度的向量，矩阵 $A$ 由下式给出\n$$\nA = \\begin{bmatrix} -k_1  0 \\\\ k_1  -k_2 \\end{bmatrix}\n$$\n初始条件为\n$$\n\\mathbf{y}_0 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}.\n$$\n参数 $k_1$ 和 $k_2$ 是正速率常数。问题指明 $k_1$ 是“快速”率，$k_2$ 是“慢速”率，意味着 $k_1 \\gg k_2$。\n\n### 系统分析与刚度\n\n线性系统 $\\mathbf{y}' = A\\mathbf{y}$ 的行为由矩阵 $A$ 的特征值决定。由于 $A$ 是一个下三角矩阵，其特征值就是其对角线上的元素：\n$$\n\\lambda_1 = -k_1\n$$\n$$\n\\lambda_2 = -k_2\n$$\n解析解是包含 $e^{\\lambda_1 t}$ 和 $e^{\\lambda_2 t}$ 项的线性组合。由于 $k_1, k_2  0$，两个特征值都是实数且为负，因此解的分量随时间衰减。该系统是稳定的。\n\n常微分方程系统中的“刚度”一词出现在存在两个或多个在截然不同的时间尺度上演化的过程时。在此系统中，时间尺度与特征值大小的倒数相关：$\\tau_1 = 1/|\\lambda_1| = 1/k_1$ 和 $\\tau_2 = 1/|\\lambda_2| = 1/k_2$。条件 $k_1 \\gg k_2$ 意味着 $\\tau_1 \\ll \\tau_2$。“刚度比”由 $|\\lambda_{\\max}|/|\\lambda_{\\min}| = k_1/k_2 \\gg 1$ 给出。一个非常快速衰减的分量（与 $\\lambda_1 = -k_1$ 相关）与一个缓慢衰减的分量（与 $\\lambda_2 = -k_2$ 相关）并存，是这个刚性系统的决定性特征。\n\n### 数值方法与稳定性\n\n我们将实现两种一阶数值方法，以在离散时间步长 $t_n = n\\Delta t$ 处近似解，其中 $\\Delta t$ 是时间步长。\n\n#### 前向欧拉（显式）法\n\n前向欧拉（FE）法是一种显式方法，由以下递推关系定义：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\Delta t f(t_n, \\mathbf{y}_n)\n$$\n对于我们的线性系统，这变为：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\Delta t (A \\mathbf{y}_n) = (I + \\Delta t A) \\mathbf{y}_n\n$$\n其中 $I$ 是 $2 \\times 2$ 的单位矩阵。矩阵 $G_{FE} = I + \\Delta t A$ 是放大矩阵。只有当 $G_{FE}$ 的所有特征值的模长小于或等于 $1$ 时，数值解才保持稳定。$G_{FE}$ 的特征值为 $1 + \\Delta t \\lambda_i$。问题指定了一个严格稳定性条件：\n$$\n|1 + \\Delta t \\lambda_i|  1 \\quad \\text{for all } i\n$$\n代入我们的特征值 $\\lambda_1 = -k_1$ 和 $\\lambda_2 = -k_2$：\n1.  $|1 - \\Delta t k_1|  1 \\implies -1  1 - \\Delta t k_1  1$。这可以简化为 $0  \\Delta t k_1  2$，或 $\\Delta t  2/k_1$。\n2.  $|1 - \\Delta t k_2|  1 \\implies -1  1 - \\Delta t k_2  1$。这可以简化为 $0  \\Delta t k_2  2$，或 $\\Delta t  2/k_2$。\n\n由于 $k_1 \\gg k_2$，我们有 $2/k_1 \\ll 2/k_2$。因此，该方法的稳定性受到系统最快时间尺度的限制：\n$$\n\\Delta t  \\frac{2}{k_1}\n$$\n这是一个严格的限制。为了保持稳定，时间步长 $\\Delta t$ 必须非常小，这使得该方法在长时间积分时计算成本高昂。\n\n#### 后向欧拉（隐式）法\n\n后向欧拉（BE）法是一种隐式方法，定义为：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\Delta t f(t_{n+1}, \\mathbf{y}_{n+1})\n$$\n对于我们的线性系统，这给出：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\Delta t (A \\mathbf{y}_{n+1})\n$$\n为了求得 $\\mathbf{y}_{n+1}$，我们必须求解一个线性系统：\n$$\n(I - \\Delta t A) \\mathbf{y}_{n+1} = \\mathbf{y}_n\n$$\n$$\n\\mathbf{y}_{n+1} = (I - \\Delta t A)^{-1} \\mathbf{y}_n\n$$\n放大矩阵是 $G_{BE} = (I - \\Delta t A)^{-1}$。其特征值为 $(1 - \\Delta t \\lambda_i)^{-1}$。对于我们系统的特征值 $\\lambda_i  0$，稳定性条件要求 $|(1 - \\Delta t \\lambda_i)^{-1}| \\le 1$。\n代入 $\\lambda_i = -k_i$：\n$$\n\\left|\\frac{1}{1 + \\Delta t k_i}\\right| \\le 1\n$$\n由于 $\\Delta t  0$ 且 $k_i  0$，分母 $1 + \\Delta t k_i$ 总是大于 $1$。因此，对于任何 $\\Delta t  0$ 的选择，放大因子的模长总是小于 $1$。后向欧拉法对于此问题是无条件稳定的（或 A-稳定），这意味着无论步长 $\\Delta t$ 如何，它都保持稳定。这一特性使其更适合于刚性系统，因为它不受快速时间尺度的限制。\n\n### 算法\n\n对于每个测试用例 $(k_1, k_2, T, \\Delta t)$：\n1.  初始化 $\\mathbf{y}_{FE} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$ 和 $\\mathbf{y}_{BE} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$。\n2.  计算步数，$N = \\text{round}(T / \\Delta t)$。\n3.  构造矩阵 $A = \\begin{bmatrix} -k_1  0 \\\\ k_1  -k_2 \\end{bmatrix}$。\n4.  构造 FE 更新矩阵 $M_{FE} = I + \\Delta t A$。\n5.  构造 BE 更新矩阵 $M_{BE} = (I - \\Delta t A)^{-1}$。\n6.  对两种方法执行 $N$ 个积分步骤：\n    -   对于 FE：每一步 $\\mathbf{y}_{FE} \\leftarrow M_{FE} \\mathbf{y}_{FE}$。\n    -   对于 BE：每一步 $\\mathbf{y}_{BE} \\leftarrow M_{BE} \\mathbf{y}_{BE}$。\n7.  检查严格的 FE 稳定性条件：如果 $\\Delta t  2/k_1$，则布尔值 `FE_stable` 为 `True`，否则为 `False`。\n8.  返回最终向量 $\\mathbf{y}_{FE}$ 和 $\\mathbf{y}_{BE}$ 以及稳定性布尔值 `FE_stable`。\n\n此过程将为所有提供的测试用例实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a stiff ODE system using Forward and Backward Euler methods\n    and analyzes the stability of the Forward Euler method.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (k1, k2, T, dt)\n        (1000.0, 1.0, 0.05, 0.0001), # Case 1: Stable FE\n        (1000.0, 1.0, 0.05, 0.01),   # Case 2: Unstable FE\n        (1000.0, 1.0, 0.05, 0.002),  # Case 3: FE at stability boundary\n        (50.0, 1.0, 0.05, 0.01),     # Case 4: Less stiff, stable FE\n    ]\n\n    all_results = []\n    \n    for k1, k2, T, dt in test_cases:\n        # Define the system matrix A\n        A = np.array([[-k1, 0.0], \n                      [k1, -k2]])\n\n        # Initial condition\n        y0 = np.array([1.0, 0.0])\n\n        # Number of time steps\n        num_steps = int(round(T / dt))\n\n        # --- Forward Euler Method ---\n        y_fe = y0.copy()\n        # Pre-compute the Forward Euler update matrix\n        I = np.identity(2)\n        M_fe = I + dt * A\n        for _ in range(num_steps):\n            y_fe = M_fe @ y_fe\n\n        # --- Backward Euler Method ---\n        y_be = y0.copy()\n        # Pre-compute the Backward Euler update matrix\n        # M_be = inv(I - dt * A)\n        M_be = np.linalg.inv(I - dt * A)\n        for _ in range(num_steps):\n            y_be = M_be @ y_be\n            \n        # --- Forward Euler Stability Check ---\n        # The eigenvalues of A are lambda_1 = -k1 and lambda_2 = -k2.\n        # Stability requires |1 + dt*lambda_i|  1 for all i.\n        # The condition simplifies to dt  2/k1.\n        # The problem asks for the result of the strict inequality.\n        fe_stable = dt  (2.0 / k1)\n\n        # Collect results for the current test case\n        case_results = [\n            y_be[0], y_be[1],\n            y_fe[0], y_fe[1],\n            fe_stable\n        ]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists is converted to a string\n    # and spaces are removed to match the required output format.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3271344"}, {"introduction": "从结构分析到量子力学，许多科学问题最终都归结为求解包含数百万变量的巨型线性方程组 $A x = b$。本练习将演示如何利用强大的迭代求解器——共轭梯度法（Conjugate Gradient method）来高效应对这一挑战。你将为一个由偏微分方程离散化后产生的系统实现该算法，并在此过程中学习关键的“免矩阵”思想，它避免了存储庞大的矩阵 $A$，从而使求解大规模问题成为可能 [@problem_id:3271471]。", "problem": "考虑求解线性方程组 $A x = b$，其中 $A$ 是单位正方形上的离散负拉普拉斯算子，带有齐次狄利克雷边界条件，通过在 $M \\times M$ 内部点的均匀网格上使用标准的 $5$ 点有限差分格式构建。设网格间距为 $h = 1/(M+1)$，并用 $(i,j)$ 索引内部点，其中 $i,j \\in \\{1,2,\\dots,M\\}$。对于内部网格函数 $u$，离散算子的作用如下：\n$$\n(A u)_{i,j} = \\frac{1}{h^2}\\left(4 u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}\\right),\n$$\n由于狄利克雷边界，来自内部区域以外的点的贡献被视为零。矩阵 $A$ 是对称正定 (SPD) 的。人工构造的精确解通过在内部网格点 $(x_i,y_j) = (i h, j h)$ 上对光滑函数 $u^*(x,y) = \\sin(\\pi x)\\sin(\\pi y)$ 进行采样来定义。右端项被一致地定义为 $b = A x^*$，其中 $x^*$ 是 $u^*$ 在内部网格上的向量化，确保 $x^*$ 是 $A x = b$ 的精确解。\n\n任务：从基本原理出发，实现共轭梯度 (CG) 法来求解此问题的 $A x = b$。不要显式构造矩阵 $A$；而是通过在 $M \\times M$ 网格上使用 $5$ 点格式来实现一个高效的矩阵向量乘积。可选地，使用 $A$ 的对角线（在每个内部点都等于 $4/h^2$）实现对角 (Jacobi) 预处理。\n\n使用的基本原理：\n- 欧几里得空间中内积的定义、$\\ell^2$ 范数，以及 SPD 矩阵 $A$ 诱导出 $A$-内积 $\\langle u, v \\rangle_A = u^\\top A v$ 和 $A$-范数 $\\|v\\|_A = \\sqrt{v^\\top A v}$ 的性质。\n- 求解 $A x = b$ 等价于最小化严格凸二次泛函 $\\phi(x) = \\frac{1}{2} x^\\top A x - b^\\top x$。\n- 在由残差和 $A$ 生成的 Krylov 子空间内进行搜索的迭代原理。\n\n收敛准则：设 $r_k = b - A x_k$ 是第 $k$ 次迭代的残差。当 $\\|r_k\\|_2 \\le \\text{tol} \\cdot \\|r_0\\|_2$（相对残差容差）时，或当达到预设的最大迭代次数时，您的实现必须终止。报告是否根据此准则收敛。\n\n每个测试用例的输出规格：\n- 执行的整数迭代次数 $k$。\n- 浮点数形式的最终残差二范数 $\\|r_k\\|_2$。\n- 浮点数形式的相对解误差 $\\|x_k - x^*\\|_2 / \\|x^*\\|_2$。\n- 一个布尔值，指示是否根据所述准则收敛。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个测试用例的结果必须是按 $[k,\\|r_k\\|_2,\\|x_k - x^*\\|_2 / \\|x^*\\|_2,\\text{converged}]$ 顺序排列的列表，总输出必须是这些列表的列表，例如 $[[k_1,r_1,e_1,c_1],[k_2,r_2,e_2,c_2],\\dots]$。\n\n测试套件：\n- 案例 1（通用，正常路径）：$M = 64$，$\\text{tol} = 10^{-8}$，$\\text{max\\_iter} = 1000$，无预处理。\n- 案例 2（边界大小）：$M = 1$，$\\text{tol} = 10^{-12}$，$\\text{max\\_iter} = 20$，无预处理。\n- 案例 3（有限迭代，可能不收敛）：$M = 128$，$\\text{tol} = 10^{-6}$，$\\text{max\\_iter} = 50$，无预处理。\n- 案例 4（预处理性能）：$M = 96$，$\\text{tol} = 10^{-10}$，$\\text{max\\_iter} = 1000$，使用对角 (Jacobi) 预处理。\n\n所有角度（如果适用）必须以弧度处理；不涉及物理单位。测试用例的最终答案必须完全按照规定表示为整数、浮点数和布尔值，不带百分号。", "solution": "所提出的问题要求使用共轭梯度 (CG) 法求解线性方程组 $A x = b$。矩阵 $A$ 代表单位正方形上均匀网格的离散负拉普拉斯算子，由带有齐次狄利克雷边界条件的 $5$ 点有限差分格式导出。这是数值偏微分方程中的一个经典问题。该问题是适定的，科学上合理的，并且所有参数都定义清晰。\n\n该系统定义在一个 $M \\times M$ 的内部点网格上。网格间距为 $h = 1/(M+1)$。一个表示为向量的未知网格函数 $u$ 受线性算子 $A$ 的作用。在一个由 $(i,j)$ 索引的内部网格点（其中 $i,j \\in \\{1,2,\\dots,M\\}$），$A$ 的作用由下式给出：\n$$\n(A u)_{i,j} = \\frac{1}{h^2}\\left(4 u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}\\right)\n$$\n与齐次狄利克雷边界条件一致，对应于内部区域以外的点的项为零。矩阵 $A$ 已知是对称正定 (SPD) 的，这是应用标准共轭梯度法的必要条件。\n\n为了验证其实现的正确性，我们采用了一个人工构造的解。精确解 $x^*$ 是通过将光滑函数 $u^*(x,y) = \\sin(\\pi x)\\sin(\\pi y)$ 在内部网格点 $(x_i, y_j) = (ih, jh)$ 上的求值结果进行向量化而构造的。然后，右端向量 $b$ 定义为 $b = A x^*$，这保证了已知的向量 $x^*$ 是系统 $A x = b$ 的精确解。\n\n该问题的一个关键约束是，大小为 $(M^2) \\times (M^2)$ 的矩阵 $A$ 不得在内存中显式构造。对于 $A$ 是稀疏的大规模问题，这是标准做法，因为显式存储的计算成本过高。取而代之的是，矩阵向量乘积 $v \\mapsto Av$ 必须实现为一个函数，该函数将向量 $v$ 重塑为 $M \\times M$ 网格后，直接对其应用 $5$ 点格式。在我们的实现中，一个长度为 $M^2$ 的向量使用行主序被重塑为一个对应于网格值的 $M \\times M$ 矩阵。然后使用 `numpy` 数组切片高效地应用格式操作，并将得到的 $M \\times M$ 网格重新展平为一个向量。\n\n共轭梯度算法是一种用于求解 SPD 线性系统的迭代法。它等价于最小化二次泛函 $\\phi(x) = \\frac{1}{2} x^\\top A x - b^\\top x$。从一个初始猜测值 $x_0$（通常是零向量）开始，该方法迭代地生成一系列近似解 $x_k$，这些近似解在逐步扩大的 Krylov 子空间 $\\mathcal{K}_k(A, r_0) = \\text{span}\\{r_0, Ar_0, \\dots, A^{k-1}r_0\\}$ 上最小化 $\\phi(x)$，其中 $r_0 = b - Ax_0$ 是初始残差。\n\n标准 CG 算法按以下步骤进行，从 $x_0 = \\vec{0}$、$r_0 = b$ 和 $p_0 = r_0$ 开始：\n对于 $k = 0, 1, 2, \\dots$：\n1.  计算矩阵向量乘积 $q_k = A p_k$。\n2.  计算步长：$\\alpha_k = \\frac{r_k^\\top r_k}{p_k^\\top q_k}$。\n3.  更新解：$x_{k+1} = x_k + \\alpha_k p_k$。\n4.  更新残差：$r_{k+1} = r_k - \\alpha_k q_k$。\n5.  检查收敛性。如果 $\\|r_{k+1}\\|_2 \\le \\text{tol} \\cdot \\|r_0\\|_2$，则过程终止，其中 $\\text{tol}$ 是指定的容差。\n6.  更新搜索方向：$p_{k+1} = r_{k+1} + \\frac{r_{k+1}^\\top r_{k+1}}{r_k^\\top r_k} p_k$。\n\n对于一个测试用例，需要进行对角 (Jacobi) 预处理。预条件子 $P$ 是一个近似于 $A$ 的矩阵，但系统 $Pz=r$ 易于求解。预处理共轭梯度 (PCG) 法求解修正后的系统 $P^{-1}Ax = P^{-1}b$。Jacobi 预条件子就是 $A$ 的对角线，$P = \\text{diag}(A)$。对于离散拉普拉斯算子，A 的所有对角元都等于 $4/h^2$。求解 $Pz=r$ 非常简单：$z = P^{-1}r$，这相当于逐元素相乘 $z_i = r_i / P_{ii} = r_i \\cdot (h^2/4)$。\n\nPCG 算法对标准 CG 算法作如下修改：\n从 $x_0 = \\vec{0}$，$r_0 = b$ 开始。求解 $P z_0 = r_0$。设 $p_0 = z_0$。\n对于 $k = 0, 1, 2, \\dots$：\n1.  计算 $q_k = A p_k$。\n2.  计算步长：$\\alpha_k = \\frac{r_k^\\top z_k}{p_k^\\top q_k}$。\n3.  更新解：$x_{k+1} = x_k + \\alpha_k p_k$。\n4.  更新残差：$r_{k+1} = r_k - \\alpha_k q_k$。\n5.  检查收敛性。\n6.  求解预处理系统：$P z_{k+1} = r_{k+1}$。\n7.  更新搜索方向：$p_{k+1} = z_{k+1} + \\frac{r_{k+1}^\\top z_{k+1}}{r_k^\\top z_k} p_k$。\n\n该实现将支持算法的标准版本和预处理版本。每个测试用例的最终输出将报告执行的迭代次数、最终残差二范数 $\\|r_k\\|_2$、解的相对误差 $\\|x_k - x^*\\|_2 / \\|x^*\\|_2$，以及一个指示是否在最大允许迭代次数内达到收敛的布尔值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef cg_solver(M, tol, max_iter, use_preconditioner):\n    \"\"\"\n    Solves the discretized Poisson equation using the Conjugate Gradient method.\n\n    Args:\n        M (int): Number of interior grid points in one dimension.\n        tol (float): Relative residual tolerance for convergence.\n        max_iter (int): Maximum number of iterations.\n        use_preconditioner (bool): If True, use diagonal (Jacobi) preconditioning.\n\n    Returns:\n        list: A list containing [iterations, final_residual_norm, relative_error, converged_flag].\n    \"\"\"\n    # 1. Problem Setup\n    N = M * M\n    h = 1.0 / (M + 1)\n    \n    # Grid and exact solution\n    x_coords = h * np.arange(1, M + 1)\n    y_coords = h * np.arange(1, M + 1)\n    xx, yy = np.meshgrid(x_coords, y_coords, indexing='xy')\n    \n    u_star_grid = np.sin(np.pi * xx) * np.sin(np.pi * yy)\n    x_star = u_star_grid.flatten(order='C')\n    norm_x_star = np.linalg.norm(x_star)\n\n    # Matrix-vector product function A*v using 5-point stencil\n    h2_inv = 1.0 / (h * h)\n    def mat_vec(v):\n        v_grid = v.reshape((M, M))\n        Av_grid = 4.0 * v_grid\n        if M > 1:\n            Av_grid[1:, :] -= v_grid[:-1, :]  # Neighbor from top (y-)\n            Av_grid[:-1, :] -= v_grid[1:, :]  # Neighbor from bottom (y+)\n            Av_grid[:, 1:] -= v_grid[:, :-1]  # Neighbor from left (x-)\n            Av_grid[:, :-1] -= v_grid[:, 1:]  # Neighbor from right (x+)\n        return (Av_grid * h2_inv).flatten(order='C')\n\n    # Right-hand side b = A*x_star\n    b = mat_vec(x_star)\n\n    # Preconditioner application function P_inv*r\n    h2_by_4 = (h * h) / 4.0\n    def apply_preconditioner(r):\n        return r * h2_by_4\n\n    # 2. CG/PCG Initialization and Iteration\n    x = np.zeros(N)\n    r = b.copy()  # Since x_0=0, r_0 = b - A*x_0 = b\n    norm_r0 = np.linalg.norm(r)\n\n    if norm_r0 == 0:\n        rel_err = 0.0 if norm_x_star == 0 else np.linalg.norm(x - x_star) / norm_x_star\n        return [0, 0.0, rel_err, True]\n        \n    tol_abs = tol * norm_r0\n    converged = False\n    k = 0\n\n    if use_preconditioner:\n        z = apply_preconditioner(r)\n        p = z.copy()\n        rho_old = np.dot(r, z)\n    else:  # Standard CG\n        z = r # z is not used, but for consistency in variable names\n        p = r.copy()\n        rho_old = np.dot(r, r)\n\n    if rho_old == 0: # initial residual is 0\n        converged = True\n    \n    for k_iter in range(max_iter):\n        k = k_iter + 1\n\n        q = mat_vec(p)\n        alpha = rho_old / np.dot(p, q)\n        \n        x += alpha * p\n        r -= alpha * q\n        \n        norm_r = np.linalg.norm(r)\n        if norm_r = tol_abs:\n            converged = True\n            break\n            \n        if use_preconditioner:\n            z = apply_preconditioner(r)\n            rho_new = np.dot(r, z)\n        else:  # Standard CG\n            rho_new = np.dot(r, r)\n            \n        beta = rho_new / rho_old\n        \n        if use_preconditioner:\n            p = z + beta * p\n        else:\n            p = r + beta * p\n            \n        rho_old = rho_new\n\n    # 3. Final calculations and return\n    final_residual_norm = np.linalg.norm(b - mat_vec(x))\n    relative_error = np.linalg.norm(x - x_star) / norm_x_star if norm_x_star > 0 else 0.0\n    \n    return [k, final_residual_norm, relative_error, converged]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        (64, 1e-8, 1000, False),\n        (1, 1e-12, 20, False),\n        (128, 1e-6, 50, False),\n        (96, 1e-10, 1000, True),\n    ]\n\n    results = []\n    for M, tol, max_iter, use_precon in test_cases:\n        result = cg_solver(M, tol, max_iter, use_precon)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default string representation of lists and booleans is used as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3271471"}]}