{"hands_on_practices": [{"introduction": "这个练习将经典物理学中的一个基本简化（小角度近似）作为切入点，来研究模型误差。通过对比精确解和近似解的周期，你将亲手量化一个看似微小的理论假设是如何在实践中产生可测量的差异的 [@problem_id:3252538]。这项实践旨在训练你从第一性原理出发推导物理量，并使用数值方法来评估理论模型的准确性边界。", "problem": "您将实现并分析平面单摆小角度近似所引入的建模误差。角位移的精确非线性运动方程为二阶常微分方程（ODE）$ \\ddot{\\theta}(t) + \\frac{g}{L} \\sin(\\theta(t)) = 0 $，其中 $ \\theta(t) $ 是与垂直方向的夹角，$ g $ 是重力加速度，$ L $ 是摆长。在小角度近似下，该模型将 $ \\sin(\\theta) $ 替换为 $ \\theta $，从而得到一个线性ODE。对于初始振幅为 $ \\theta_0 $、初始角速度为 $ \\dot{\\theta}(0) = 0 $ 的情况，将周期 $ T $ 定义为完成一次完整振荡所需的时间。\n\n您的任务：\n1. 从机械能守恒和精确的非线性ODE出发，推导精确周期 $ T_{\\text{exact}}(\\theta_0; L, g) $ 关于 $ \\theta_0 $、$ L $ 和 $ g $ 的正确积分表达式，不使用 $ \\sin(\\theta) \\approx \\theta $ 的近似。您的推导应从总能量 $ E = \\frac{1}{2} m L^2 \\dot{\\theta}^2 + m g L (1 - \\cos \\theta) $ 和初始条件 $ \\theta(0) = \\theta_0 $、$ \\dot{\\theta}(0) = 0 $ 开始，其中 $ m $ 是质量。\n2. 对于小角度模型，使用线性化ODE得到模型周期 $ T_{\\text{lin}}(L, g) $。\n3. 将建模误差定义为相对差异 $ \\varepsilon(\\theta_0) = \\frac{T_{\\text{lin}} - T_{\\text{exact}}}{T_{\\text{exact}}} $，以小数形式表示（而非百分比）。\n4. 实现一个程序，该程序：\n   - 通过对任何 $ \\theta_0 \\in [0, \\pi) $ 进行高精度数值计算，从您基于能量的积分中计算 $ T_{\\text{exact}} $。\n   - 从线性化模型中计算 $ T_{\\text{lin}} $。\n   - 对下面的每个测试值，返回 $ \\varepsilon(\\theta_0) $，四舍五入到 $ 12 $ 位小数。\n5. 使用 $g = 9.80665 \\, \\text{m/s}^2$ 和 $L = 1.0 \\, \\text{m}$。角度 $ \\theta_0 $ 以弧度为单位。周期必须以 $ \\text{s} $（秒）为单位。\n\n测试组：\n- $\\theta_0 = 0.0$\n- $\\theta_0 = 10^{-6}$\n- $\\theta_0 = 0.5$\n- $\\theta_0 = 1.0$\n- $\\theta_0 = 2.0$\n- $\\theta_0 = 3.0$\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个由方括号括起来的逗号分隔列表，列表中的每个条目对应相应测试用例的 $ \\varepsilon(\\theta_0) $，并四舍五入到 $ 12 $ 位小数。例如：$ [x_1,x_2,x_3,x_4,x_5,x_6] $，其中每个 $ x_i $ 是小数点后恰好有 $ 12 $ 位数字的小数。", "solution": "用户提供的问题被评估为有效。它在科学上基于经典力学，问题设定良好并提供了所有必要信息，且其表述是客观的。任务是通过推导和比较精确非线性模型与近似线性模型的周期，来分析单摆小角度近似的建模误差。\n\n解决方案分三个阶段进行：\n1.  推导精确周期 $T_{\\text{exact}}$ 和线性化周期 $T_{\\text{lin}}$ 的解析表达式。\n2.  构建相对建模误差 $\\varepsilon(\\theta_0)$ 的公式。\n3.  进行数值实现，以计算指定初始振幅下的 $\\varepsilon(\\theta_0)$。\n\n### 1. 精确周期 $T_{\\text{exact}}$ 的推导\n\n摆的运动遵循机械能守恒定律。总能量 $E$ 由动能和势能之和给出：\n$$\nE = \\frac{1}{2} m L^2 \\dot{\\theta}^2 + m g L (1 - \\cos \\theta)\n$$\n其中 $m$ 是质量，$L$ 是摆长，$g$ 是重力加速度，$\\theta$ 是角位移，$\\dot{\\theta}$ 是角速度。\n\n初始条件是 $\\theta(0) = \\theta_0$（初始振幅）和 $\\dot{\\theta}(0) = 0$。总能量 $E$ 是守恒的，可以在 $t=0$ 时进行计算：\n$$\nE = \\frac{1}{2} m L^2 (0)^2 + m g L (1 - \\cos \\theta_0) = m g L (1 - \\cos \\theta_0)\n$$\n将一般能量表达式与此常数值相等，我们得到：\n$$\n\\frac{1}{2} m L^2 \\dot{\\theta}^2 + m g L (1 - \\cos \\theta) = m g L (1 - \\cos \\theta_0)\n$$\n解出 $\\dot{\\theta}^2$：\n$$\n\\frac{1}{2} L^2 \\dot{\\theta}^2 = g L ((1 - \\cos \\theta_0) - (1 - \\cos \\theta)) = g L (\\cos \\theta - \\cos \\theta_0)\n$$\n$$\n\\dot{\\theta}^2 = \\left(\\frac{d\\theta}{dt}\\right)^2 = \\frac{2g}{L} (\\cos \\theta - \\cos \\theta_0)\n$$\n取平方根，我们得到角速度：\n$$\n\\frac{d\\theta}{dt} = \\pm \\sqrt{\\frac{2g}{L} (\\cos \\theta - \\cos \\theta_0)}\n$$\n周期 $T_{\\text{exact}}$ 是摆从其最大位移 $\\theta_0$ 摆动到垂直位置 $\\theta=0$ 所需时间的四倍。在这第一个四分之一周期内，$\\theta$ 是减小的，所以我们对 $\\frac{d\\theta}{dt}$ 取负根：\n$$\ndt = -\\frac{d\\theta}{\\sqrt{\\frac{2g}{L} (\\cos \\theta - \\cos \\theta_0)}}\n$$\n当 $\\theta$ 从 $\\theta_0$ 变化到 $0$ 时，对时间从 $t=0$ 积分到 $t=T_{\\text{exact}}/4$：\n$$\n\\frac{T_{\\text{exact}}}{4} = \\int_{\\theta_0}^{0} -\\sqrt{\\frac{L}{2g}} \\frac{d\\theta}{\\sqrt{\\cos \\theta - \\cos \\theta_0}} = \\sqrt{\\frac{L}{2g}} \\int_{0}^{\\theta_0} \\frac{d\\theta}{\\sqrt{\\cos \\theta - \\cos \\theta_0}}\n$$\n这个积分在 $\\theta = \\theta_0$ 处是瑕积分。为了得到适合数值计算的形式，我们进行一系列代换。首先，使用半角恒等式 $\\cos x = 1 - 2\\sin^2(x/2)$：\n$$\n\\cos \\theta - \\cos \\theta_0 = (1 - 2\\sin^2(\\theta/2)) - (1 - 2\\sin^2(\\theta_0/2)) = 2(\\sin^2(\\theta_0/2) - \\sin^2(\\theta/2))\n$$\n将此式代入周期积分中：\n$$\nT_{\\text{exact}} = 4 \\sqrt{\\frac{L}{2g}} \\int_{0}^{\\theta_0} \\frac{d\\theta}{\\sqrt{2(\\sin^2(\\theta_0/2) - \\sin^2(\\theta/2))}} = 2\\sqrt{\\frac{L}{g}} \\int_{0}^{\\theta_0} \\frac{d\\theta}{\\sqrt{\\sin^2(\\theta_0/2) - \\sin^2(\\theta/2)}}\n$$\n现在，我们引入一个新变量 $\\phi$，由关系 $\\sin(\\theta/2) = \\sin(\\phi) \\sin(\\theta_0/2)$ 定义。令 $k = \\sin(\\theta_0/2)$。该关系为 $\\sin(\\theta/2) = k \\sin(\\phi)$。\n微分得到 $\\frac{1}{2}\\cos(\\theta/2) d\\theta = k\\cos(\\phi)d\\phi$。\n因此，微分 $d\\theta$ 是 $d\\theta = \\frac{2k\\cos(\\phi)}{\\cos(\\theta/2)}d\\phi = \\frac{2k\\cos(\\phi)}{\\sqrt{1 - k^2\\sin^2(\\phi)}}d\\phi$。\n积分限发生变化：当 $\\theta=0$ 时，$\\sin(\\phi)=0 \\implies \\phi=0$；当 $\\theta=\\theta_0$ 时，$\\sin(\\theta_0/2) = k\\sin(\\phi) \\implies k = k\\sin(\\phi) \\implies \\sin(\\phi)=1 \\implies \\phi=\\pi/2$。\n将这些代入 $T_{\\text{exact}}$ 的表达式中：\n$$\nT_{\\text{exact}} = 2\\sqrt{\\frac{L}{g}} \\int_0^{\\pi/2} \\frac{1}{\\sqrt{k^2 - k^2\\sin^2(\\phi)}} \\cdot \\frac{2k\\cos(\\phi)}{\\sqrt{1 - k^2\\sin^2(\\phi)}}d\\phi\n$$\n$$\nT_{\\text{exact}} = 2\\sqrt{\\frac{L}{g}} \\int_0^{\\pi/2} \\frac{1}{k\\cos(\\phi)} \\cdot \\frac{2k\\cos(\\phi)}{\\sqrt{1 - k^2\\sin^2(\\phi)}}d\\phi = 4\\sqrt{\\frac{L}{g}} \\int_0^{\\pi/2} \\frac{d\\phi}{\\sqrt{1 - k^2\\sin^2(\\phi)}}\n$$\n其中 $k = \\sin(\\theta_0/2)$。该积分是第一类完全椭圆积分，$K(k)$。\n\n### 2. 线性化周期 $T_{\\text{lin}}$ 的推导\n\n小角度近似在原始运动方程 $ \\ddot{\\theta} + \\frac{g}{L} \\sin(\\theta) = 0 $ 中用 $\\theta$ 替换 $\\sin(\\theta)$，得到线性ODE：\n$$\n\\ddot{\\theta}(t) + \\frac{g}{L} \\theta(t) = 0\n$$\n这是简谐振子的方程，$\\ddot{x} + \\omega^2 x = 0$，其角频率为 $\\omega = \\sqrt{g/L}$。周期 $T$ 与 $\\omega$ 的关系为 $T = 2\\pi/\\omega$。因此，线性化模型的周期为：\n$$\nT_{\\text{lin}} = 2\\pi \\sqrt{\\frac{L}{g}}\n$$\n此周期与初始振幅 $\\theta_0$ 无关。\n\n### 3. 建模误差与数值实现\n\n建模误差定义为相对差异：\n$$\n\\varepsilon(\\theta_0) = \\frac{T_{\\text{lin}} - T_{\\text{exact}}}{T_{\\text{exact}}} = \\frac{2\\pi \\sqrt{L/g}}{4\\sqrt{L/g} K(\\sin(\\theta_0/2))} - 1 = \\frac{\\pi}{2K(\\sin(\\theta_0/2))} - 1\n$$\n对于特殊情况 $\\theta_0 = 0$，$k=\\sin(0)=0$，且 $K(0) = \\int_0^{\\pi/2} 1 d\\phi = \\pi/2$。因此，$T_{\\text{exact}}(0) = 4\\sqrt{L/g}(\\pi/2) = T_{\\text{lin}}$，这意味着 $\\varepsilon(0) = 0$。\n\n积分 $K(k)$ 没有以初等函数表示的闭式解，必须进行数值计算。我们使用辛普森法则，这是一种高精度的数值积分方法。对于区间 $[a, b]$ 上的函数 $f(x)$，将其划分为 $N$ 个偶数个宽度为 $h=(b-a)/N$ 的子区间，积分可近似为：\n$$\n\\int_a^b f(x) dx \\approx \\frac{h}{3} \\left[ f(x_0) + 4\\sum_{i=1,3,...}^{N-1} f(x_i) + 2\\sum_{i=2,4,...}^{N-2} f(x_i) + f(x_N) \\right]\n$$\n为了确保最终答案所需的精度，使用了大量的区间 $N$。给定的常数为 $g = 9.80665 \\, \\text{m/s}^2$ 和 $L = 1.0 \\, \\text{m}$。程序将实现这些公式来计算每个测试值的 $\\varepsilon(\\theta_0)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the modeling error for the small-angle approximation of a simple pendulum.\n    \"\"\"\n    # Define constants from the problem statement.\n    G = 9.80665  # Gravitational acceleration in m/s^2\n    L = 1.0      # Pendulum length in m\n\n    def simpson_rule(f, a, b, n):\n        \"\"\"\n        Numerically integrate a function f from a to b using Simpson's rule with n intervals.\n        \n        Args:\n            f: The function to integrate.\n            a: The lower limit of integration.\n            b: The upper limit of integration.\n            n: The number of intervals (must be even).\n        \n        Returns:\n            The approximate value of the integral.\n        \"\"\"\n        if n % 2 != 0:\n            raise ValueError(\"Number of intervals (n) must be even.\")\n        \n        h = (b - a) / n\n        x = np.linspace(a, b, n + 1)\n        y = f(x)\n        \n        # Simpson's rule formula: h/3 * (y_0 + 4y_1 + 2y_2 + ... + 4y_{n-1} + y_n)\n        integral = (h / 3.0) * (y[0] + y[-1] + 4.0 * np.sum(y[1:-1:2]) + 2.0 * np.sum(y[2:-2:2]))\n        return integral\n\n    def calculate_modeling_error(theta0, g, l):\n        \"\"\"\n        Computes the relative modeling error (T_lin - T_exact) / T_exact.\n        \n        Args:\n            theta0: The initial amplitude in radians.\n            g: Gravitational acceleration.\n            l: Pendulum length.\n\n        Returns:\n            The relative modeling error.\n        \"\"\"\n        # Calculate the period from the linearized model\n        T_lin = 2.0 * np.pi * np.sqrt(l / g)\n\n        # Handle the trivial case where the pendulum does not oscillate\n        if theta0 == 0.0:\n            return 0.0\n\n        # Number of intervals for Simpson's rule. A large number is chosen to ensure\n        # high accuracy (12 decimal places), especially for theta0 close to pi.\n        n_intervals = 2 * 10**7\n\n        # Calculate the exact period using the elliptic integral form\n        k = np.sin(theta0 / 2.0)\n        \n        # Define the integrand for the complete elliptic integral of the first kind, K(k)\n        def integrand(phi):\n            return 1.0 / np.sqrt(1.0 - k**2 * np.sin(phi)**2)\n\n        # Evaluate the integral K(k) from 0 to pi/2\n        integral_val = simpson_rule(integrand, 0.0, np.pi / 2.0, n_intervals)\n        \n        T_exact = 4.0 * np.sqrt(l / g) * integral_val\n        \n        # Calculate the relative modeling error\n        error = (T_lin - T_exact) / T_exact\n        \n        return error\n\n    # Define the test cases from the problem statement.\n    test_cases = [0.0, 1e-6, 0.5, 1.0, 2.0, 3.0]\n\n    results = []\n    for theta_0 in test_cases:\n        error_value = calculate_modeling_error(theta_0, G, L)\n        # Format the result to 12 decimal places as required.\n        # The f-string formatting handles rounding automatically.\n        results.append(f\"{error_value:.12f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3252538"}, {"introduction": "在混沌系统中，初始条件的微小改变会导致截然不同的结果，这便是著名的“蝴蝶效应”。然而，模型本身的不完美——例如参数的不确定性——同样是误差的重要来源。这个练习将带你进入洛伦兹系统的混沌世界，通过数值模拟来直接比较这两种误差来源的相对影响，从而深刻理解在复杂动力学建模中区分不同误差来源的重要性 [@problem_id:3252605]。", "problem": "考虑洛伦兹系统，它被建模为一个三维的自治常微分方程（ODE）。令状态为 $x(t) = (x(t), y(t), z(t)) \\in \\mathbb{R}^3$，参数向量为 $p = (\\sigma, \\rho, \\beta) \\in \\mathbb{R}^3$。向量场由下式给出：\n$$\n\\frac{d}{dt}\n\\begin{bmatrix}\nx \\\\\ny \\\\\nz\n\\end{bmatrix}\n=\nf(x,y,z;p) =\n\\begin{bmatrix}\n\\sigma (y - x) \\\\\nx(\\rho - z) - y \\\\\nxy - \\beta z\n\\end{bmatrix}.\n$$\n假设基线参数集为 $p_0 = (\\sigma_0, \\rho_0, \\beta_0)$，其中 $\\sigma_0 = 10$，$\\rho_0 = 28$，$\\beta_0 = \\frac{8}{3}$，基线初始条件为 $x_0 = (1, 1, 1)$。我们希望比较基线轨迹与两条受扰动轨迹之间的分离：一条带有微小建模误差（受扰动的参数），另一条带有微小初始条件误差。具体来说，对于给定的终端时间 $T > 0$ 和时间步长 $h > 0$，令 $x_{\\text{base}}(T)$ 表示使用参数 $p_0$ 和初始状态 $x_0$ 的常微分方程的基线数值解。定义另外两条轨迹：\n- 初始条件误差轨迹 $x_{\\text{IC}}(t)$ 求解具有相同参数 $p_0$ 的相同常微分方程，但初始条件为 $x_0 + \\delta x_0$，其中 $\\delta x_0 = (\\epsilon, 0, 0)$ 且 $\\epsilon > 0$ 很小。\n- 建模误差轨迹 $x_{\\text{model}}(t)$ 求解具有相同初始条件 $x_0$ 的常微分方程，但参数向量为 $p_0 + \\delta p$，其中 $\\delta p = (0, \\delta \\rho, 0)$ 且 $\\delta \\rho$ 很小。\n\n对于每条轨迹，将时间 $T$ 的欧几里得分离定义为\n$$\ns_{\\text{IC}}(T) = \\left\\| x_{\\text{IC}}(T) - x_{\\text{base}}(T) \\right\\|_2,\\quad\ns_{\\text{model}}(T) = \\left\\| x_{\\text{model}}(T) - x_{\\text{base}}(T) \\right\\|_2.\n$$\n您的任务是实现一个使用经典四阶龙格-库塔方法（RK4）的固定步长数值求解器，以对每个测试案例近似计算 $x_{\\text{base}}(T)$、$x_{\\text{IC}}(T)$ 和 $x_{\\text{model}}(T)$。然后，为每个测试案例计算比率\n$$\nR = \\frac{s_{\\text{model}}(T)}{s_{\\text{IC}}(T)},\n$$\n约定如果 $s_{\\text{IC}}(T) = 0$，则返回 $+\\infty$。\n\n使用以下测试套件，该套件通过改变终端时间 $T$、步长 $h$ 和扰动幅度来探究典型行为、边界条件和灵敏度：\n- 测试 $1$（正常路径，混沌区域，小的对称扰动）：$T = 20$, $h = 0.01$, $\\epsilon = 10^{-6}$, $\\delta \\rho = 10^{-6}$。\n- 测试 $2$（边界情况，零初始条件误差）：$T = 20$, $h = 0.01$, $\\epsilon = 0$, $\\delta \\rho = 10^{-6}$。\n- 测试 $3$（边界情况，零建模误差）：$T = 20$, $h = 0.01$, $\\epsilon = 10^{-6}$, $\\delta \\rho = 0$。\n- 测试 $4$（更长的时间范围，更精细的步长，极小的初始误差）：$T = 40$, $h = 0.005$, $\\epsilon = 10^{-12}$, $\\delta \\rho = 10^{-6}$。\n\n所有量都是无量纲的；不涉及物理单位。角度单位不适用。\n\n您的程序必须：\n- 实现具有固定步长 $h$ 的 RK4 方法，以计算洛伦兹常微分方程的数值解。\n- 对于每个测试案例，按照上述规定计算 $R$。\n- 生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序与测试套件相同，例如：$[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是一个浮点数（在适用的情况下允许 $+\\infty$）。", "solution": "用户希望根据一组提供的数据解决一个问题。\n\n### 第 1 步：提取已知信息\n- **常微分方程系统（洛伦兹系统）**：\n$$\n\\frac{d}{dt}\n\\begin{bmatrix}\nx \\\\\ny \\\\\nz\n\\end{bmatrix}\n=\nf(x,y,z;p) =\n\\begin{bmatrix}\n\\sigma (y - x) \\\\\nx(\\rho - z) - y \\\\\nxy - \\beta z\n\\end{bmatrix}\n$$\n- **状态向量**：$x(t) = (x(t), y(t), z(t)) \\in \\mathbb{R}^3$。\n- **参数向量**：$p = (\\sigma, \\rho, \\beta) \\in \\mathbb{R}^3$。\n- **基线参数**：$p_0 = (\\sigma_0, \\rho_0, \\beta_0)$，其中 $\\sigma_0 = 10$，$\\rho_0 = 28$，$\\beta_0 = \\frac{8}{3}$。\n- **基线初始条件**：$x_0 = (1, 1, 1)$。\n- **初始条件扰动**：$\\delta x_0 = (\\epsilon, 0, 0)$，其中 $\\epsilon > 0$。受扰动的初始条件为 $x_0 + \\delta x_0$。\n- **建模误差扰动**：$\\delta p = (0, \\delta \\rho, 0)$。受扰动的参数向量为 $p_0 + \\delta p$。\n- **要计算的轨迹**：\n    - $x_{\\text{base}}(t)$：使用参数 $p_0$ 和初始状态 $x_0$ 的解。\n    - $x_{\\text{IC}}(t)$：使用参数 $p_0$ 和初始状态 $x_0 + \\delta x_0$ 的解。\n    - $x_{\\text{model}}(t)$：使用参数 $p_0 + \\delta p$ 和初始状态 $x_0$ 的解。\n- **分离度量**：在终端时间 $T$ 时，\n$$\ns_{\\text{IC}}(T) = \\left\\| x_{\\text{IC}}(T) - x_{\\text{base}}(T) \\right\\|_2\n$$\n$$\ns_{\\text{model}}(T) = \\left\\| x_{\\text{model}}(T) - x_{\\text{base}}(T) \\right\\|_2\n$$\n- **目标量**：比率 $R = \\frac{s_{\\text{model}}(T)}{s_{\\text{IC}}(T)}$。如果 $s_{\\text{IC}}(T) = 0$，则 $R$ 返回为 $+\\infty$。\n- **数值方法**：具有固定步长 $h$ 的经典四阶龙格-库塔方法（RK4）。\n- **测试套件**：\n    1.  测试 1：$T = 20$, $h = 0.01$, $\\epsilon = 10^{-6}$, $\\delta \\rho = 10^{-6}$。\n    2.  测试 2：$T = 20$, $h = 0.01$, $\\epsilon = 0$, $\\delta \\rho = 10^{-6}$。\n    3.  测试 3：$T = 20$, $h = 0.01$, $\\epsilon = 10^{-6}$, $\\delta \\rho = 0$。\n    4.  测试 4：$T = 40$, $h = 0.005$, $\\epsilon = 10^{-12}$, $\\delta \\rho = 10^{-6}$。\n\n### 第 2 步：使用提取的已知信息进行验证\n1.  **科学依据**：该问题基于洛伦兹系统，这是混沌理论和动力系统中的一个基石模型。RK4 方法是一种标准、广泛使用的常微分方程数值积分器。对初始条件和模型参数敏感性的研究是混沌系统研究中的一个基本课题。该问题具有科学合理性。\n2.  **适定性**：该问题定义明确。它指定了控制方程、数值方法、所有必要的参数、初始条件，以及为一系列不同测试案例要计算的精确量。还提供了处理边界情况（例如，分母为零）的逻辑。可以为每种情况确定唯一的数值解。\n3.  **客观性**：该问题使用精确的数学语言和客观标准进行陈述。没有主观或基于意见的成分。\n4.  **不完整或矛盾的设置**：该问题是自洽的，并提供了所有必要的信息。在给定的数据或约束中没有矛盾。\n5.  **不切实际或不可行**：洛伦兹系统的参数值是已知能产生混沌行为的经典值。时间范围、步长和扰动幅度在计算上是可行的，并且是此类数值实验的标准配置。\n6.  **不适定或结构不良**：该问题结构清晰，能够为每个测试案例带来唯一且有意义的数值结果。\n7.  **伪深刻、琐碎或同义反复**：该问题探讨了一个非凡的概念——混沌系统中不同误差源的相对影响——并且需要一个标准但仔细的数值实现。\n8.  **超出科学可验证性**：通过重新实现指定的算法，结果是可以在数值上验证的。\n\n### 第 3 步：结论与行动\n该问题是有效的。将提供一个合理的解决方案。\n\n该问题要求比较洛伦兹混沌系统中初始条件的微小扰动与模型参数的微小扰动所产生的影响。这是通过对系统的控制常微分方程（ODE）进行数值积分，并分析所得轨迹的分离来实现的。指定的数值积分方案是经典的四阶龙格-库塔（RK4）方法。\n\n洛伦兹系统由以下一组针对状态向量 $x(t) = [x(t), y(t), z(t)]^T \\in \\mathbb{R}^3$ 的自治常微分方程定义：\n$$\n\\frac{d}{dt}x(t)\n=\nf(x(t); p) =\n\\begin{bmatrix}\n\\sigma (y - x) \\\\\nx(\\rho - z) - y \\\\\nxy - \\beta z\n\\end{bmatrix}\n$$\n其中 $p = (\\sigma, \\rho, \\beta)$ 是参数向量。\n\n数值解是通过使用固定时间步长 $h$ 的 RK4 方法获得的。对于一个一般的自治常微分方程 $\\frac{dx}{dt} = f(x)$，在时间 $t_{n+1} = t_n + h$ 的状态 $x_{n+1}$ 是从时间 $t_n$ 的状态 $x_n$ 通过以下公式近似得出的：\n$$\nx_{n+1} = x_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n$$\n中间斜率向量 $k_i \\in \\mathbb{R}^3$ 的计算如下：\n$$\n\\begin{aligned}\nk_1 = f(x_n; p) \\\\\nk_2 = f(x_n + \\frac{h}{2}k_1; p) \\\\\nk_3 = f(x_n + \\frac{h}{2}k_2; p) \\\\\nk_4 = f(x_n + hk_3; p)\n\\end{aligned}\n$$\n其中 $p$ 是特定模拟的参数向量。为了在终端时间 $T$ 获得解，从 $t=0$ 的给定初始条件开始，这个更新规则被迭代应用 $N = \\text{round}(T/h)$ 次。\n\n对于每个测试案例，模拟了三条轨迹：\n1.  **基线轨迹 ($x_{\\text{base}}$)**：使用基线初始条件 $x_0 = (1, 1, 1)$ 和基线参数 $p_0 = (10, 28, 8/3)$ 求解。\n2.  **初始条件扰动轨迹 ($x_{\\text{IC}}$)**：使用受扰动的初始条件 $x(0) = x_0 + \\delta x_0 = (1+\\epsilon, 1, 1)$ 和基线参数 $p_0$ 求解。\n3.  **模型扰动轨迹 ($x_{\\text{model}}$)**：使用基线初始条件 $x_0$ 和受扰动的参数 $p = p_0 + \\delta p = (10, 28+\\delta\\rho, 8/3)$ 求解。\n\n在将模拟运行到时间 $T$ 后，获得最终状态 $x_{\\text{base}}(T)$、$x_{\\text{IC}}(T)$ 和 $x_{\\text{model}}(T)$。由此，计算出欧几里得分离距离：\n$$\ns_{\\text{IC}}(T) = \\left\\| x_{\\text{IC}}(T) - x_{\\text{base}}(T) \\right\\|_2\n$$\n$$\ns_{\\text{model}}(T) = \\left\\| x_{\\text{model}}(T) - x_{\\text{base}}(T) \\right\\|_2\n$$\n最终感兴趣的量是比率 $R$：\n$$\nR = \\frac{s_{\\text{model}}(T)}{s_{\\text{IC}}(T)}\n$$\n根据规定，如果 $s_{\\text{IC}}(T) = 0$（这在 $\\epsilon=0$ 时发生），则 $R$ 的值取为正无穷大。如果 $s_{\\text{model}}(T) = 0$（当 $\\delta\\rho=0$ 时）且 $s_{\\text{IC}}(T) \\neq 0$，则比率 $R$ 的计算结果为 $0$。\n\n此过程被系统地应用于所提供的四个测试案例。所得的 $R$ 值被收集并以列表形式作为最终输出呈现。这些测试案例旨在探究系统在不同条件下的灵敏度，包括标准的混沌演化和其中一个扰动为空的边界情况。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the ratio of trajectory separation due to modeling error\n    versus initial condition error for the Lorenz system.\n    \"\"\"\n\n    def lorenz_f(state, sigma, rho, beta):\n        \"\"\"\n        Computes the Lorenz system vector field (the right-hand side of the ODE).\n\n        Args:\n            state (np.ndarray): The current state [x, y, z].\n            sigma (float): The sigma parameter.\n            rho (float): The rho parameter.\n            beta (float): The beta parameter.\n\n        Returns:\n            np.ndarray: The derivative [dx/dt, dy/dt, dz/dt].\n        \"\"\"\n        x, y, z = state\n        dx_dt = sigma * (y - x)\n        dy_dt = x * (rho - z) - y\n        dz_dt = x * y - beta * z\n        return np.array([dx_dt, dy_dt, dz_dt])\n\n    def rk4_solver(x0, T, h, sigma, rho, beta):\n        \"\"\"\n        Solves the Lorenz ODE using the classical 4th-order Runge-Kutta method.\n\n        Args:\n            x0 (np.ndarray): The initial state vector [x0, y0, z0].\n            T (float): The terminal time.\n            h (float): The fixed step size.\n            sigma (float): The sigma parameter.\n            rho (float): The rho parameter.\n            beta (float): The beta parameter.\n\n        Returns:\n            np.ndarray: The state vector at time T.\n        \"\"\"\n        num_steps = int(round(T / h))\n        x = np.copy(x0).astype(float)  # Use a copy to avoid modifying the input\n\n        for _ in range(num_steps):\n            k1 = lorenz_f(x, sigma, rho, beta)\n            k2 = lorenz_f(x + h * 0.5 * k1, sigma, rho, beta)\n            k3 = lorenz_f(x + h * 0.5 * k2, sigma, rho, beta)\n            k4 = lorenz_f(x + h * k3, sigma, rho, beta)\n            x += (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n        \n        return x\n\n    # Baseline parameters and initial condition from the problem statement.\n    sigma0 = 10.0\n    rho0 = 28.0\n    beta0 = 8.0 / 3.0\n    x0_base = np.array([1.0, 1.0, 1.0])\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (T, h, epsilon, delta_rho)\n        (20.0, 0.01, 1e-6, 1e-6),      # Test 1\n        (20.0, 0.01, 0.0, 1e-6),       # Test 2\n        (20.0, 0.01, 1e-6, 0.0),       # Test 3\n        (40.0, 0.005, 1e-12, 1e-6),    # Test 4\n    ]\n\n    results = []\n    for T, h, epsilon, delta_rho in test_cases:\n        # 1. Compute baseline trajectory final state\n        x_base_T = rk4_solver(x0_base, T, h, sigma0, rho0, beta0)\n\n        # 2. Compute initial condition error trajectory final state\n        x0_ic = x0_base + np.array([epsilon, 0.0, 0.0])\n        x_ic_T = rk4_solver(x0_ic, T, h, sigma0, rho0, beta0)\n\n        # 3. Compute modeling error trajectory final state\n        rho_model = rho0 + delta_rho\n        x_model_T = rk4_solver(x0_base, T, h, sigma0, rho_model, beta0)\n        \n        # Calculate Euclidean separation distances\n        s_ic = np.linalg.norm(x_ic_T - x_base_T)\n        s_model = np.linalg.norm(x_model_T - x_base_T)\n\n        # Calculate the ratio R\n        if s_ic == 0.0:\n            # As per problem specification, if s_IC(T) = 0, R is +infinity.\n            # This occurs in Test 2 where epsilon = 0.\n            R = float('inf')\n        else:\n            R = s_model / s_ic\n        \n        results.append(R)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3252605"}, {"introduction": "面对极其复杂的系统，我们常常需要构建“降阶模型”（Reduced-Order Model）来抓住其核心动态，这在工程和科学计算中是一种强大的技术。本练习将通过一个具体实例，指导你使用“本征正交分解”（Proper Orthogonal Decomposition, POD）这一数据驱动方法来构建降阶模型 [@problem_id:3252598]。你将学习如何量化模型降阶过程中“被忽略的能量”，并评估其对预测精度的直接影响，从而理解在模型简化与预测准确性之间的权衡。", "problem": "考虑线性时不变常微分方程 $u_t = A u + g$，其中 $A \\in \\mathbb{R}^{n \\times n}$ 为常数矩阵，$g \\in \\mathbb{R}^n$ 为常数向量。状态为 $u(t) \\in \\mathbb{R}^n$，时间 $t \\geq 0$。其解析解由基本解算子和叠加原理定义，即 $u(t) = e^{A t} u(0) + \\int_{0}^{t} e^{A (t - s)} g \\, ds$。设本征正交分解 (Proper Orthogonal Decomposition, POD) 从一个快照矩阵 $X \\in \\mathbb{R}^{n \\times m}$ 构建，该矩阵的列是在一组选定时间 $t_k$ 时的状态 $u(t_k)$。设阶数为 $r$ 的 POD 基是通过正交投影到由 $X$ 的前 $r$ 个左奇异向量所张成的子空间上获得的。快照矩阵的投影误差通过残差的欧几里得范数与 $X$ 的奇异值相关联。降阶模型通过将动力学伽辽金投影到 POD 子空间上获得，这会在预测给定时间的状态时引入模型降阶误差。\n\n您的任务是使用以下具体、完全指定的实例，严格地量化和计算被忽略的快照能量和最终时间的预测误差：\n\n- 维度 $n = 4$。\n- 矩阵 $A = \\operatorname{diag}(-1.0,\\,-0.6,\\,-2.5,\\,-0.2)$，表示 $A$ 是对角线元素为 $-1.0$、$-0.6$、$-2.5$ 和 $-0.2$ 的对角矩阵。\n- 常数向量 $g = [\\,0.2,\\;1.0,\\;-0.5,\\;0.1\\,]^\\top$。\n- 初始条件 $u(0) = [\\,1.0,\\;0.0,\\;0.5,\\;-1.0\\,]^\\top$。\n- 快照时间 $t_k \\in \\{\\,0.0,\\;0.5,\\;1.0,\\;1.5,\\;2.0\\,\\}$，最终时间 $T = 2.0$。\n- 快照矩阵 $X$ 由所列时间的列向量 $u(t_k)$ 构成。\n- POD 基是根据 $X$ 的奇异值分解构建的，使用前 $r$ 个左奇异向量作为阶数为 $r$ 的基。\n\n从这些定义出发，并且不依赖未经证明的简化公式，对每个指定的阶数 $r$ 执行以下操作：\n\n1.  计算 $X$ 的奇异值分解，以获得奇异值和相应的阶数为 $r$ 的 POD 基。\n2.  计算在阶数 $r$ 处截断所关联的被忽略的快照能量。使用快照矩阵中能量的奇异值分解定义，用奇异值精确表示该量，然后对本实例进行数值计算。\n3.  通过将动力学 $u_t = A u + g$ 投影到阶数为 $r$ 的 POD 子空间上来构建伽辽金降阶模型。通过求解带有投影后初始条件的降阶模型，预测时间 $T$ 的状态。\n4.  计算在时间 $T$ 的绝对预测误差，即全阶解 $u(T)$ 与在 $\\mathbb{R}^n$ 中提升后的降阶解 $u_r(T)$ 之间差值的欧几里得范数。\n5.  计算在时间 $T$ 的相对预测误差，即绝对误差除以 $u(T)$ 的欧几里得范数，表示为小数。\n\n本问题中不需要物理单位；所有量均为无量纲。如果存在任何角度，都将以弧度为单位，但此处未出现角度。快照能量分数应以小数报告，而不是百分比。\n\n测试套件和待评估的阶数：\n- 情况 1：$r = 0$。\n- 情况 2：$r = 1$。\n- 情况 3：$r = 2$。\n- 情况 4：$r = 4$。\n\n对于每种情况，生成一个包含四个值的列表 $[\\,E_{\\text{tail}},\\;f_{\\text{capture}},\\;e_{\\text{abs}},\\;e_{\\text{rel}}\\,]$，其中 $E_{\\text{tail}}$ 是被忽略的快照能量，$f_{\\text{capture}}$ 是快照矩阵的捕获能量分数（以小数表示），$e_{\\text{abs}}$ 是在时间 $T$ 的绝对预测误差，$e_{\\text{rel}}$ 是在时间 $T$ 的相对预测误差。\n\n您的程序应生成单行输出，其中包含结果，格式为一个以逗号分隔的列表，并用方括号括起来，每个子列表对应测试套件中的一种情况，并按顺序排列。例如，输出格式必须严格为 $[\\,[\\cdot,\\cdot,\\cdot,\\cdot],\\,[\\cdot,\\cdot,\\cdot,\\cdot],\\,[\\cdot,\\cdot,\\cdot,\\cdot],\\,[\\cdot,\\cdot,\\cdot,\\cdot]\\,]$，在适当位置使用小数，不含其他文本。", "solution": "任务是使用本征正交分解 (Proper Orthogonal Decomposition, POD) 和伽辽金投影 (Galerkin projection) 对给定的线性时不变 (LTI) 常微分方程 (ODE) 进行模型降阶。我们必须计算量化不同阶数 $r$ 下降阶模型 (ROM) 质量的指标。该过程涉及求解全阶模型 (FOM)、构建 POD 基、推导并求解 ROM，最后计算指定的误差和能量指标。\n\n### 1. 全阶模型 (FOM) 解\n控制动力学由以下 LTI 系统描述：\n$$u_t = A u + g$$\n其中 $u(t) \\in \\mathbb{R}^n$，$A \\in \\mathbb{R}^{n \\times n}$，$g \\in \\mathbb{R}^n$。具体参数如下：\n-   维度：$n = 4$。\n-   矩阵：$A = \\operatorname{diag}(\\lambda_1, \\lambda_2, \\lambda_3, \\lambda_4) = \\operatorname{diag}(-1.0, -0.6, -2.5, -0.2)$。\n-   常数向量：$g = [0.2, 1.0, -0.5, 0.1]^\\top$。\n-   初始条件：$u(0) = [1.0, 0.0, 0.5, -1.0]^\\top$。\n\n由于矩阵 $A$ 是对角矩阵，n 个耦合的常微分方程组解耦为 n 个独立的标量常微分方程，对应状态向量 $u(t)$ 的每个分量 $u_i(t)$：\n$$(u_i)_t = \\lambda_i u_i(t) + g_i, \\quad \\text{初始条件为 } u_i(0)$$\n这是一个标准的一阶线性常微分方程，其解析解由常数变易法公式给出：\n$$u_i(t) = e^{\\lambda_i t} u_i(0) + \\int_{0}^{t} e^{\\lambda_i(t - s)} g_i \\, ds$$\n由于 $\\lambda_i$ 和 $g_i$ 是常数，积分可以直接计算：\n$$\\int_{0}^{t} e^{\\lambda_i(t - s)} g_i \\, ds = g_i e^{\\lambda_i t} \\left[-\\frac{e^{-\\lambda_i s}}{\\lambda_i}\\right]_0^t = \\frac{g_i}{\\lambda_i} (e^{\\lambda_i t} - 1)$$\n因此，每个分量的解析解为：\n$$u_i(t) = e^{\\lambda_i t} u_i(0) + \\frac{g_i}{\\lambda_i}(e^{\\lambda_i t} - 1) = \\left(u_i(0) + \\frac{g_i}{\\lambda_i}\\right)e^{\\lambda_i t} - \\frac{g_i}{\\lambda_i}$$\n该公式为任何时间 $t \\geq 0$ 提供了 FOM 的精确“基准解”。\n\n### 2. 快照矩阵与本征正交分解 (POD)\nPOD 是一种数据驱动技术，用于为给定数据集寻找最优的低维基。数据集，即“快照”，由在选定时间点上的 FOM 解组成。\n-   快照时间：$t_k \\in \\{0.0, 0.5, 1.0, 1.5, 2.0\\}$。\n-   快照数量：$m = 5$。\n-   快照矩阵：$X = [u(t_0), u(t_1), \\dots, u(t_{m-1})] \\in \\mathbb{R}^{n \\times m}$。\n\nPOD 基通过计算快照矩阵 $X$ 的奇异值分解 (SVD) 找到：\n$$X = U \\Sigma V^\\top$$\n-   $U \\in \\mathbb{R}^{n \\times n}$ 是一个正交矩阵，其列 $v_i$ 是左奇异向量，也称为 POD 模态或基向量。\n-   $\\Sigma \\in \\mathbb{R}^{n \\times m}$ 是一个矩形对角矩阵，包含奇异值 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_{\\min(n,m)} \\ge 0$。\n-   $V \\in \\mathbb{R}^{m \\times m}$ 是一个正交矩阵，其列是右奇异向量。\n\n阶数为 $r$ 的 POD 基是矩阵 $U_r = [v_1, \\dots, v_r] \\in \\mathbb{R}^{n \\times r}$，它由前 $r$ 个 POD 模态组成。根据 Eckart-Young-Mirsky 定理，此基是最优的，因为它最小化了快照到任何阶数 $r$ 子空间的投影误差。\n\n### 3. 快照能量分析\n奇异值量化了每个 POD 模态对快照数据表示的贡献。快照的“能量”定义为 $X$ 的弗罗贝尼乌斯范数的平方，它等于奇异值平方和：\n$$E_{\\text{total}} = \\|X\\|_F^2 = \\sum_{i=1}^{\\min(n,m)} \\sigma_i^2$$\n当我们将基截断到阶数 $r$ 时，我们保留了与前 $r$ 个模态相关的能量，并丢弃其余部分。\n-   捕获的能量是 $E_{\\text{capture}} = \\sum_{i=1}^{r} \\sigma_i^2$。\n-   **被忽略的快照能量**，或尾部能量，是 $E_{\\text{tail}} = \\sum_{i=r+1}^{\\min(n,m)} \\sigma_i^2$。\n-   **捕获的能量分数**是 $f_{\\text{capture}} = \\frac{E_{\\text{capture}}}{E_{\\text{total}}}$。\n\n### 4. 伽辽金投影与降阶模型 (ROM)\n模型降阶的核心思想是寻找一个位于 POD 基所张成的低维子空间内的近似解：\n$$u(t) \\approx u_r(t) = U_r \\tilde{u}(t)$$\n其中 $\\tilde{u}(t) \\in \\mathbb{R}^r$ 是降阶坐标的向量。将此拟设代入 FOM 会产生一个残差：\n$$R(t) = U_r \\tilde{u}_t - (A U_r \\tilde{u} + g)$$\n伽辽金投影强制要求该残差与基向量正交，即 $U_r^\\top R(t) = 0$。\n$$U_r^\\top (U_r \\tilde{u}_t - A U_r \\tilde{u} - g) = 0$$\n利用 POD 基的标准正交性（$U_r^\\top U_r = I_r$，即 $r \\times r$ 单位矩阵），我们得到 ROM：\n$$\\tilde{u}_t = A_r \\tilde{u} + g_r$$\n其中降阶系统矩阵和向量为：\n-   $A_r = U_r^\\top A U_r \\in \\mathbb{R}^{r \\times r}$\n-   $g_r = U_r^\\top g \\in \\mathbb{R}^r$\n\nROM 的初始条件是 FOM 初始条件在 POD 子空间上的投影：\n$$\\tilde{u}(0) = U_r^\\top u(0)$$\n\n### 5. ROM 解与误差计算\nROM 本身也是一个 LTI 系统。其形式解由下式给出：\n$$\\tilde{u}(t) = e^{A_r t} \\tilde{u}(0) + \\int_{0}^{t} e^{A_r(t-s)} g_r \\, ds$$\n积分项可以计算为 $A_r^{-1}(e^{A_r t} - I_r) g_r$，前提是 $A_r$ 可逆。由于 $A$ 是对称负定的，且 $U_r$ 具有标准正交列，因此 $A_r = U_r^\\top A U_r$ 也是对称负定的，从而可逆。矩阵指数 $e^{A_r t}$ 通过对角化 $A_r$ 来计算。由于 $A_r$ 是对称的，它总是可对角化的：$A_r = P D P^{-1}$。则 $e^{A_r t} = P e^{D t} P^{-1}$。\n\n在最终时间 $T=2.0$ 求解出降阶状态 $\\tilde{u}(T)$ 后，我们将其“提升”回原始的 n 维空间，以获得 ROM 的预测：\n$$u_r(T) = U_r \\tilde{u}(T)$$\n该预测的误差由以下方式量化：\n-   **绝对预测误差**：$e_{\\text{abs}} = \\|u(T) - u_r(T)\\|_2$，其中 $u(T)$ 是真实的 FOM 解。\n-   **相对预测误差**：$e_{\\text{rel}} = \\frac{e_{\\text{abs}}}{\\|u(T)\\|_2}$。\n\n### 6. 特殊情况分析\n-   **情况 $r=0$**：基是空的。降维空间为 $\\{0\\}$，因此任何向量的投影都是零向量（维度为 0）。提升后的解在 $\\mathbb{R}^n$ 中恒为零向量，即 $u_0(t) = 0$。被忽略的能量是总能量，捕获分数为 0。绝对预测误差就是真实解的范数 $\\|u(T)\\|_2$。\n-   **情况 $r=n=4$**：POD 基 $U_4$ 是 $\\mathbb{R}^4$ 的一个完整标准正交基。投影是等距同构。ROM 在数学上等同于在不同坐标系下表示的 FOM。因此，$u_4(t) = u(t)$ 对所有 $t$ 成立，预测误差必须为零（在浮点精度范围内）。这可以作为对实现的一个重要的合理性检查。被忽略的能量为零，捕获分数为 1。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the POD model reduction problem.\n    \"\"\"\n    # Problem definition\n    n = 4\n    A_diag = np.array([-1.0, -0.6, -2.5, -0.2])\n    A = np.diag(A_diag)\n    g = np.array([0.2, 1.0, -0.5, 0.1])\n    u0 = np.array([1.0, 0.0, 0.5, -1.0])\n    snapshot_times = np.array([0.0, 0.5, 1.0, 1.5, 2.0])\n    T_final = 2.0\n    ranks = [0, 1, 2, 4]\n\n    def fom_solution(t):\n        \"\"\"\n        Computes the analytical solution of the full-order model u_t = Au + g.\n        \"\"\"\n        # Element-wise solution: u_i(t) = (u0_i + g_i/lambda_i) * exp(lambda_i*t) - g_i/lambda_i\n        # Handle lambda_i = 0 case, though not present here.\n        u_t = np.zeros(n)\n        for i in range(n):\n            if np.abs(A_diag[i])  1e-15: # Unlikely given the problem, but for robustness\n                 u_t[i] = u0[i] + g[i] * t\n            else:\n                 u_t[i] = (u0[i] + g[i] / A_diag[i]) * np.exp(A_diag[i] * t) - g[i] / A_diag[i]\n        return u_t\n\n    # 1. Generate snapshot matrix X\n    snapshots = [fom_solution(t) for t in snapshot_times]\n    X = np.stack(snapshots, axis=1)\n\n    # 2. Compute SVD of X to get POD basis and singular values\n    U, s, Vh = np.linalg.svd(X, full_matrices=False)\n    # The number of singular values is min(n, m) = min(4, 5) = 4. U is 4x4.\n\n    # 3. Compute total snapshot energy\n    sigma_sq = s**2\n    total_energy = np.sum(sigma_sq)\n    \n    # Get the true final state for error calculations\n    u_T_true = fom_solution(T_final)\n    norm_u_T_true = np.linalg.norm(u_T_true)\n\n    results = []\n\n    for r in ranks:\n        # Step 1: Compute snapshot energy metrics\n        if r == 0:\n            captured_energy = 0.0\n        else:\n            captured_energy = np.sum(sigma_sq[:r])\n        \n        neglected_energy = total_energy - captured_energy\n        capture_fraction = captured_energy / total_energy if total_energy > 0 else 1.0\n\n        # Step 2: Construct and solve the ROM to find u_r(T)\n        if r == 0:\n            # For r=0, the reduced space is trivial. The prediction is the zero vector.\n            u_r_T = np.zeros(n)\n        else:\n            Ur = U[:, :r]\n            \n            # Construct ROM\n            Ar = Ur.T @ A @ Ur\n            gr = Ur.T @ g\n            u0_tilde = Ur.T @ u0\n            \n            # Solve ROM: u_tilde(t) = exp(Ar*t)u0_tilde + Ar_inv*(exp(Ar*t)-I)*gr\n            # Since Ar is symmetric, it is diagonalizable.\n            eigvals, P = np.linalg.eigh(Ar)\n            P_inv = P.T # For an orthogonal matrix from eigh\n            \n            # Compute matrix exponential exp(Ar*T)\n            exp_Dr_T = np.diag(np.exp(eigvals * T_final))\n            exp_Ar_T = P @ exp_Dr_T @ P_inv\n            \n            # Compute the integral term\n            # Ar_inv can be computed via diagonalization as well\n            Ar_inv = P @ np.diag(1.0 / eigvals) @ P_inv\n            integral_term = Ar_inv @ (exp_Ar_T - np.identity(r)) @ gr\n\n            # Solve for u_tilde at T\n            u_tilde_T = exp_Ar_T @ u0_tilde + integral_term\n\n            # Lift solution back to full space\n            u_r_T = Ur @ u_tilde_T\n            \n        # Step 3: Compute prediction errors\n        abs_error = np.linalg.norm(u_T_true - u_r_T)\n        rel_error = abs_error / norm_u_T_true if norm_u_T_true > 0 else 0.0\n\n        results.append([neglected_energy, capture_fraction, abs_error, rel_error])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3252598"}]}