{"hands_on_practices": [{"introduction": "我们将从一个简单而熟悉的问题开始：计算斐波那契数列。这个练习将鲜明地对比两种实现方法——迭代法和朴素递归法——以揭示算法的结构，特别是其执行的算术运算数量，如何极大地影响其数值稳定性。通过这个实践[@problem_id:3205171]，你将直观地看到舍入误差是如何累积的，并理解为什么选择高效的算法不仅是为了速度，更是为了保证结果的准确性。", "problem": "要求您通过比较在受控舍入模型下，斐波那契数列的两种实现中舍入误差的传播方式，来研究算法的鲁棒性和稳定性。请使用以下基本框架来进行分析和实现。\n\n- 斐波那契数由递推关系定义：$F_0 = 0$, $F_1 = 1$，以及当 $n \\ge 2$ 时，$F_n = F_{n-1} + F_{n-2}$。\n- 采用标准的加法浮点舍入模型：每次加法都由一个运算符 $\\mathrm{fl}_t(\\cdot)$ 舍入到有限精度。该运算符使用“四舍六入五成双”（rounding-to-nearest with ties-to-even）的规则将任意实数舍入到 $t$ 位有效十进制数字。在分析形式中，可以写作 $\\mathrm{fl}_t(a+b) = (a+b)(1+\\delta)$，其中 $|\\delta| \\le u$，而 $u$（单位舍入误差）取决于 $t$。\n\n您的任务是实现两种算法，在每次加法后都使用相同的舍入运算符 $\\mathrm{fl}_t(\\cdot)$：\n\n1) 迭代实现：\n- 初始化 $x_0 = \\mathrm{fl}_t(0)$，$x_1 = \\mathrm{fl}_t(1)$。\n- 对于 $k = 2, 3, \\dots, n$，设置 $x_k = \\mathrm{fl}_t(x_{k-1} + x_{k-2})$。\n- 返回 $x_n$。\n\n2) 朴素递归实现：\n- 定义函数 $\\text{fib\\_rec}(n)$ 如下\n  - 如果 $n = 0$，返回 $\\mathrm{fl}_t(0)$。\n  - 如果 $n = 1$，返回 $\\mathrm{fl}_t(1)$。\n  - 否则，返回 $\\mathrm{fl}_t(\\text{fib\\_rec}(n-1) + \\text{fib\\_rec}(n-2))$。\n\n对于给定的数对 $(n,t)$，计算：\n- 使用无舍入的递推关系计算精确整数值 $F_n$。\n- 迭代舍入值 $X_n^{\\mathrm{iter}}$ 和递归舍入值 $X_n^{\\mathrm{rec}}$。\n- 相对误差（以小数形式表示，而非百分比，且无任何单位）：\n  - $r_{\\mathrm{iter}} = \\dfrac{|X_n^{\\mathrm{iter}} - F_n|}{|F_n|}$，\n  - $r_{\\mathrm{rec}} = \\dfrac{|X_n^{\\mathrm{rec}} - F_n|}{|F_n|}$，\n  - 以及它们的差值 $s = r_{\\mathrm{rec}} - r_{\\mathrm{iter}}$。\n\n测试套件：\n使用以下参数对 $(n,t)$：\n- 情况 A: $(n,t) = (1, 3)$，\n- 情况 B: $(n,t) = (12, 4)$，\n- 情况 C: $(n,t) = (20, 6)$，\n- 情况 D: $(n,t) = (24, 6)$，\n- 情况 E: $(n,t) = (24, 3)$。\n\n要求的最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的、逗号分隔的扁平列表。\n- 该列表必须按顺序包含每个测试用例的三元组 $[r_{\\mathrm{iter}}, r_{\\mathrm{rec}}, s]$，并将所有情况下的三元组连接成一个扁平列表：\n  - $[r_{\\mathrm{iter}}^{(A)}, r_{\\mathrm{rec}}^{(A)}, s^{(A)}, r_{\\mathrm{iter}}^{(B)}, r_{\\mathrm{rec}}^{(B)}, s^{(B)}, \\dots]$。\n- 将每个数字表示为小数，使用科学记数法或定点表示法，并确保恰好有 $12$ 位有效数字。\n- 答案中没有物理单位。\n\n科学真实性和约束条件：\n- 您必须将 $\\mathrm{fl}_t(\\cdot)$ 精确地实现为舍入到 $t$ 位有效十进制数字，并采用“四舍六入五成双”规则。\n- 不涉及角度；不需要角度单位。\n- 确保递归实现是上述的朴素版本（没有记忆化或动态规划），以便它会重新计算子问题，从而展现其自身的舍入误差传播特性。\n\n目标是在相同的舍入模型下，通过经验性比较两种方法的鲁棒性和稳定性。您的程序应生成单行输出，其中包含一个用方括号括起来的、逗号分隔的结果列表（例如，“[result1,result2,result3,...]”）。", "solution": "问题陈述已经过严格验证，被认为是有效的。这是一个数值分析领域的适定问题 (well-posed problem)，具体涉及算法稳定性及舍入误差传播的研究。该问题具有科学依据，内部逻辑一致，并包含了着手求解所需的所有必要信息。\n\n核心任务是在指定的舍入模型下，比较计算斐波那契数列的两种算法的数值稳定性。数值算法的稳定性取决于它如何传播输入误差和由浮点运算引入的误差（舍入误差）。一个稳定的算法不会过度放大这些误差。\n\n两种所提算法的根本区别在于执行的舍入操作次数。\n1.  迭代算法计算 $F_n$ 大约需要 $n-1$ 次加法，因此有 $n-1$ 次舍入操作。舍入次数随 $n$ 线性增长。\n2.  朴素递归算法会重新计算子问题，其执行的加法（及舍入）次数等于 $F_{n+1}-1$。这个数字随 $n$ 指数级增长，为解决此问题提供了一个典型的低效且数值不稳定的方法示例。与迭代方法相比，大量的舍入操作预计将导致更大的误差累积。\n\n实现将分几步进行：定义舍入模型，实现所需的三种斐波那T函数（精确、迭代、递归），然后为每个测试用例计算指定的误差度量。\n\n**1. 舍入模型 `fl_t(·)`**\n\n问题指定了一个舍入运算符 $\\mathrm{fl}_t(\\cdot)$，它使用“四舍六入五成双”（round-to-nearest, ties-to-even）规则将实数舍入到 $t$ 位有效十进制数字。在 Python 中实现这一功能最稳健的方法是使用标准库中的 `decimal` 模块。该模块专为十进制浮点运算设计，可以精确控制精度和舍入模式。\n\n`fl_t(x, t)` 函数将按以下方式实现：\n- 将 `decimal` 上下文的精度设置为 $t$。\n- 将上下文的舍入模式设置为 `ROUND_HALF_EVEN`，这对应于“四舍六入五成双”。\n- 将输入数字 $x$（一个标准的二进制浮点数）转换为 `Decimal` 对象。\n- 对此 `Decimal` 对象应用上下文的舍入规则。在 `Decimal` 对象上使用一元加号运算符 (`+`) 是执行此操作的规范方法。\n- 将得到的 `Decimal` 对象转换回标准浮点数，以用于后续计算。\n\n$$ \\mathrm{fl}_t(x) = \\text{float}(\\text{round}_{\\text{prec}=t, \\text{mode}=\\text{HALF\\_EVEN}}(\\text{Decimal}(x))) $$\n\n**2. 斐波那契算法实现**\n\n需要三个函数来计算斐波那契数。\n\n- **精确值 $F_n$**：将使用一个简单的迭代算法，利用 Python 的任意精度整数来计算精确值 $F_n$。这作为误差计算的基准真相 (ground truth)。\n    - $a, b \\leftarrow 0, 1$\n    - 对于 $k$ 从 $2$ 到 $n$：$a, b \\leftarrow b, a+b$\n    - 返回 $b$。\n\n- **迭代舍入值 $X_n^{\\mathrm{iter}}$**：该算法遵循与精确算法相同的迭代结构，但在每次加法后应用舍入运算符 $\\mathrm{fl}_t(\\cdot)$。\n    - $x_0 \\leftarrow \\mathrm{fl}_t(0, t)$, $x_1 \\leftarrow \\mathrm{fl}_t(1, t)$\n    - 对于 $k$ 从 $2$ 到 $n$：\n        - $s \\leftarrow x_{k-1} + x_{k-2}$\n        - $x_k \\leftarrow \\mathrm{fl}_t(s, t)$\n        - 更新存储值：$x_{k-2} \\leftarrow x_{k-1}$, $x_{k-1} \\leftarrow x_k$\n    - 返回 $x_n$。\n\n- **朴素递归舍入值 $X_n^{\\mathrm{rec}}$**：该算法是数学递推关系的直接转换，并在每一步都应用舍入。根据问题陈述，它必须是“朴素的”，意味着它会重新计算子问题的值，从而表现出其特有的误差传播特性。\n    - $\\text{fib\\_rec}(k, t)$:\n        - 如果 $k=0$，返回 $\\mathrm{fl}_t(0, t)$。\n        - 如果 $k=1$，返回 $\\mathrm{fl}_t(1, t)$。\n        - 否则，返回 $\\mathrm{fl}_t(\\text{fib\\_rec}(k-1, t) + \\text{fib\\_rec}(k-2, t), t)$。\n\n**3. 误差计算**\n\n对于每个测试对 $(n, t)$，我们计算以下量：\n- 精确值 $F_n$。\n- 迭代舍入结果 $X_n^{\\mathrm{iter}}$。\n- 递归舍入结果 $X_n^{\\mathrm{rec}}$。\n\n然后计算相对误差。由于测试用例的 $n \\ge 1$，精确值 $F_n$ 始终非零，因此无需担心除以零的问题。\n- 迭代相对误差：$r_{\\mathrm{iter}} = \\dfrac{|X_n^{\\mathrm{iter}} - F_n|}{|F_n|}$\n- 递归相对误差：$r_{\\mathrm{rec}} = \\dfrac{|X_n^{\\mathrm{rec}} - F_n|}{|F_n|}$\n- 误差之差：$s = r_{\\mathrm{rec}} - r_{\\mathrm{iter}}$\n\n对于每个测试用例，这三个值都使用科学记数法格式化为 $12$ 位有效数字，并连接成一个单一列表作为最终输出。使用格式字符串 `\"{:.11e}\"` 来实现这一点，它提供小数点前 $1$ 位和小数点后 $11$ 位，总共 $12$ 位有效数字。\n\n**4. 执行与分析**\n\n主程序遍历所提供的测试套件。对于每对 $(n, t)$，它调用三个斐波那契函数，计算误差 $r_{\\mathrm{iter}}$、$r_{\\mathrm{rec}}$ 和 $s$，格式化结果，并将它们附加到一个列表中。最后，它用逗号连接列表元素，并将它们打印在方括号内，以遵循指定的输出格式。预计结果将显示 $r_{\\mathrm{rec}}$ 显著大于 $r_{\\mathrm{iter}}$，尤其是在 $n$ 较大或 $t$ 较小的情况下，这证明了迭代算法优越的数值稳定性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom decimal import Decimal, getcontext, ROUND_HALF_EVEN\nimport sys\n\n# Increase recursion limit for larger n in the naive recursive implementation.\nsys.setrecursionlimit(2000)\n\ndef solve():\n    \"\"\"\n    Solves the Fibonacci rounding error comparison problem.\n    \"\"\"\n\n    def fl_t(x: float, t: int) -> float:\n        \"\"\"\n        Rounds a number x to t significant decimal digits using\n        rounding-to-nearest with ties-to-even.\n        \"\"\"\n        if x == 0.0:\n            return 0.0\n        \n        # Set the context for decimal arithmetic\n        getcontext().prec = t\n        getcontext().rounding = ROUND_HALF_EVEN\n        \n        # Convert to Decimal, apply rounding, and convert back to float\n        # The unary '+' applies the precision and rounding from the context.\n        rounded_decimal = +Decimal(x)\n        \n        return float(rounded_decimal)\n\n    def fib_exact(n: int) -> int:\n        \"\"\"\n        Computes the exact n-th Fibonacci number using integer arithmetic.\n        \"\"\"\n        if n = 1:\n            return n\n        a, b = 0, 1\n        for _ in range(n - 1):\n            a, b = b, a + b\n        return b\n\n    def fib_iterative(n: int, t: int) - float:\n        \"\"\"\n        Computes the n-th Fibonacci number using an iterative approach\n        with rounding after each addition.\n        \"\"\"\n        if n == 0:\n            return fl_t(0.0, t)\n        if n == 1:\n            return fl_t(1.0, t)\n        \n        x0 = fl_t(0.0, t)\n        x1 = fl_t(1.0, t)\n        \n        for _ in range(2, n + 1):\n            s = x1 + x0\n            xk = fl_t(s, t)\n            x0, x1 = x1, xk\n            \n        return x1\n\n    def fib_recursive(n: int, t: int) - float:\n        \"\"\"\n        Computes the n-th Fibonacci number using a naive recursive approach\n        with rounding after each addition.\n        \"\"\"\n        if n == 0:\n            return fl_t(0.0, t)\n        if n == 1:\n            return fl_t(1.0, t)\n        \n        # Recursive calls are made, and the sum is rounded.\n        fib_nm1 = fib_recursive(n - 1, t)\n        fib_nm2 = fib_recursive(n - 2, t)\n        \n        return fl_t(fib_nm1 + fib_nm2, t)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 3),   # Case A\n        (12, 4),  # Case B\n        (20, 6),  # Case C\n        (24, 6),  # Case D\n        (24, 3),  # Case E\n    ]\n\n    results = []\n    for n, t in test_cases:\n        # Calculate the exact value.\n        fn_exact = fib_exact(n)\n        \n        # Calculate the value using the iterative algorithm with rounding.\n        xn_iter = fib_iterative(n, t)\n        \n        # Calculate the value using the naive recursive algorithm with rounding.\n        xn_rec = fib_recursive(n, t)\n        \n        # Calculate relative errors. Denominator fn_exact is  0 for all n = 1.\n        if fn_exact != 0:\n            r_iter = abs(xn_iter - fn_exact) / abs(fn_exact)\n            r_rec = abs(xn_rec - fn_exact) / abs(fn_exact)\n        else: # This case is not hit by the provided test suite.\n            r_iter = 0.0 if xn_iter == 0.0 else float('inf')\n            r_rec = 0.0 if xn_rec == 0.0 else float('inf')\n            \n        s = r_rec - r_iter\n        \n        # Format results to 12 significant digits in scientific notation.\n        # Format specifier \".11e\" means 11 digits after the decimal point,\n        -        # plus one before, totaling 12 significant digits.\n        results.append(f\"{r_iter:.11e}\")\n        results.append(f\"{r_rec:.11e}\")\n        results.append(f\"{s:.11e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3205171"}, {"introduction": "在理解了误差累积的基本概念后，本实践将深入探讨浮点运算中的特定风险。通过计算一组接近机器精度极限的正数的算术平均值与几何平均值，你将亲身遇到两个常见问题：对大量小数求和时的精度损失，以及将它们相乘时发生的数值下溢。这个练习[@problem_id:3205191]将向你展示如何运用补偿求和与对数变换等稳健性技术，这些都是编写可靠数值代码的必备工具。", "problem": "您将研究计算算术平均值和几何平均值的数值鲁棒性与稳定性，这些计算针对的是一组其数量级非常接近双精度浮点运算机器 epsilon 的正实数。使用浮点运算的标准舍入模型作为基础：对于实数 $x$ 和 $y$ 上的每个基本运算，计算出的浮点结果 $\\mathrm{fl}(x \\,\\mathrm{op}\\, y)$ 满足 $\\mathrm{fl}(x \\,\\mathrm{op}\\, y) = (x \\,\\mathrm{op}\\, y)(1 + \\delta)$，其中 $|\\delta| \\le u$，$u$ 是单位舍入误差（机器 epsilon 的一半）。在遵循 IEEE $754$ 标准的双精度浮点数中，机器 epsilon 约为 $2^{-52}$，单位舍入误差 $u$ 约为 $2^{-53}$。\n\n正数 $x_1,\\dots,x_n$ 的算术平均值定义为 $(x_1 + \\cdots + x_n)/n$。几何平均值定义为 $(x_1 \\cdots x_n)^{1/n}$。您将评估每种平均值的两种计算策略：一种直接方法和一种从基本原理出发的数值鲁棒替代方法（例如，通过减轻误差累积，或通过减小动态范围的变换来避免下溢）。您将通过计算每种策略相对于高精度基准的相对误差来量化鲁棒性。该基准使用一种能显著减少算术和舍入误差的求和方法，以及一种能避免乘积下溢的变换来计算。\n\n使用以下定义。如果 $a_{\\text{approx}}$ 是正参考值 $a_{\\text{ref}}$ 的一个近似值，则相对误差为 $|a_{\\text{approx}} - a_{\\text{ref}}| / a_{\\text{ref}}$。对于算术平均值基准，如果语言标准库提供高精度求和例程，则使用它计算总和，然后除以 $n$。对于几何平均值基准，使用高精度求和例程计算自然对数的总和，除以 $n$，然后取指数。\n\n您的程序必须为每个测试用例实现以下内容：\n- 一种直接的算术平均值计算方法和一种数值鲁棒的算术平均值计算方法，每种都通过相对误差与算术基准进行比较。\n- 一种直接的几何平均值计算方法和一种数值鲁棒的几何平均值计算方法，每种都通过相对误差与几何基准进行比较。\n\n所有输入都是没有物理单位的纯数字。如果出现任何角度，则必须以弧度为单位，尽管此处不需要角度。\n\n测试套件。令 $\\varepsilon$ 表示 IEEE $754$ 双精度的机器 epsilon。构造以下四个正数的确定性测试用例：\n- 用例 1（普通情况，小 $n$）：$n = 5$，其中 $x_i = \\varepsilon\\,(1 + i \\cdot 10^{-12})$，$i = 0,1,2,3,4$。\n- 用例 2（乘积下溢压力测试）：$n = 300$，其中 $x_i = \\varepsilon$，$i = 1,2,\\dots,300$。\n- 用例 3（大 $n$，轻度异质性）：$n = 20000$，其中奇数 $i$ 对应 $x_i = \\varepsilon$，偶数 $i$ 对应 $x_i = 1.5\\,\\varepsilon$。\n- 用例 4（非常大的 $n$，微小确定性扰动）：$n = 100000$，其中 $x_i = \\varepsilon\\left(1 + \\left((i \\bmod 10) - 5\\right)\\cdot 10^{-16}\\right)$，$i = 0,1,2,\\dots,99999$。\n\n在这些定义中，所有 $x_i$ 均为严格正数。\n\n对于每个用例，计算以下四个量：\n- 直接计算的算术平均值相对于其基准的相对误差。\n- 鲁棒计算的算术平均值相对于其基准的相对误差。\n- 直接计算的几何平均值相对于其基准的相对误差。\n- 鲁棒计算的几何平均值相对于其基准的相对误差。\n\n最终输出格式。您的程序应生成单行输出，该输出是一个用方括号括起来的逗号分隔列表，每个测试用例对应一个条目，并按顺序排列。每个条目本身必须是按上述顺序排列的四个浮点数列表。例如，输出必须具有以下形式：\n\"[ [a11,a12,a13,a14],[a21,a22,a23,a24],[a31,a32,a33,a34],[a41,a42,a43,a44] ]\"\n此单行前后不应有任何附加文本。", "solution": "该问题要求研究在计算一组数量级接近机器 epsilon 的正数的算术平均值和几何平均值时的数值鲁棒性。该分析通过将直接计算方法与更鲁棒的替代方法进行比较来执行，并使用相对于高精度基准的相对误差来量化性能。\n\n该分析的基础是浮点运算的标准模型，其中对于实数 $x$ 和 $y$ 以及基本运算 $\\mathrm{op}$，计算结果 $\\mathrm{fl}(x \\,\\mathrm{op}\\, y)$ 由 $\\mathrm{fl}(x \\,\\mathrm{op}\\, y) = (x \\,\\mathrm{op}\\, y)(1 + \\delta)$ 给出，其中 $|\\delta| \\le u$。术语 $u$ 代表单位舍入误差，对于 IEEE $754$ 双精度，其值为 $u \\approx 2^{-53}$。机器 epsilon $\\varepsilon$ 是单位舍入误差的两倍，即 $\\varepsilon = 2u \\approx 2^{-52}$。\n\n**I. 算术平均值**\n\n一组 $n$ 个数 $\\{x_1, x_2, \\dots, x_n\\}$ 的算术平均值 (AM) 定义为 $A = \\frac{1}{n} \\sum_{i=1}^{n} x_i$。\n\n**1. 算术平均值的直接算法**\n\n最直接的方法是首先使用一个简单的循环计算总和 $S = \\sum_{i=1}^{n} x_i$，然后除以 $n$。在浮点运算中，这个和通过迭代计算得出，即 $\\hat{S}_k = \\mathrm{fl}(\\hat{S}_{k-1} + x_k)$，其中 $\\hat{S}_0 = 0$。每次加法都可能引入舍入误差。当对大量数值求和时，这些小误差会累积成最终和中的一个显著总误差。当相加的数字数量级差异很大时，这个问题尤其严重，但即使像本问题中这样数量级相似的数字，在一个长序列（例如，$n=100000$）上累积的误差也会降低精度。该方法使用 `numpy.sum()` 实现。\n\n**2. 算术平均值的鲁棒算法：Kahan 求和**\n\n为了减轻舍入误差的累积，一种补偿求和算法，特别是 Kahan 求和算法，是一种鲁棒的替代方案。该算法维护一个运行中的补偿变量 $c$，用于捕获每次加法中丢失的低位比特。然后将 $c$ 的值合并到求和的下一步中，从而有效地校正累积的和。\n\nKahan 求和算法对一个数字序列 $X = \\{x_1, \\dots, x_n\\}$ 的处理过程如下：\n1. 初始化和 $s = 0.0$ 及补偿 $c = 0.0$。\n2. 对于 $X$ 中的每个 $x_i$：\n   a. $y = x_i - c$\n   b. $t = s + y$\n   c. $c = (t - s) - y$\n   d. $s = t$\n3. 返回 $s$。\n\n关键步骤是 $c = (t - s) - y$。在精确算术中，这会是 $c = ((s+y)-s) - y = 0$。然而，在浮点算术中，如果 $s$ 远大于 $y$，$t = \\mathrm{fl}(s+y)$ 可能会丢失 $y$ 的低位比特。项 $(t-s)$ 恢复了已成功加到 $s$ 上的 $y$ 的高位部分，因此 $(t-s)-y$ 分离出了 $y$ 丢失部分的相反数。这个丢失的部分存储在 $c$ 中，并从下一项 $x_{i+1}$ 中减去，从而将丢失的精度重新引入计算。鲁棒平均值随后计算为 $A_{\\text{robust}} = \\text{KahanSum}(X) / n$。\n\n**3. 算术平均值的基准**\n\n算术平均值的参考值 $A_{\\text{ref}}$ 是按照规定使用高精度求和例程计算的。Python 的 `math.fsum()` 提供了这样一个例程。它使用一种由 Shewchuk 设计的算法，该算法跟踪多个部分和以保持高精度，从而有效地消除了除最病态的输入之外的所有舍入误差。因此，基准为 $A_{\\text{ref}} = \\mathrm{math.fsum}(X) / n$。\n\n**II. 几何平均值**\n\n一组正数 $\\{x_1, x_2, \\dots, x_n\\}$ 的几何平均值 (GM) 定义为 $G = (\\prod_{i=1}^{n} x_i)^{1/n}$。\n\n**1. 几何平均值的直接算法**\n\n直接实现是计算乘积 $P = \\prod_{i=1}^{n} x_i$，然后取 $n$ 次方根，$G_{\\text{sf}} = P^{1/n}$。这种方法非常容易出现数值下溢或上溢。测试用例涉及数量级为机器 epsilon ($\\varepsilon \\approx 2.22 \\times 10^{-16}$) 的数字 $x_i$。$n$ 个此类数字的乘积约为 $\\varepsilon^n$。对于中等大小的 $n$，例如用例 2 中的 $n=300$，这个值会变得极小（约 $(10^{-16})^{300} = 10^{-4800}$），远低于最小可表示的正双精度数（约 $5 \\times 10^{-324}$）。计算出的乘积会下溢为 $0.0$，导致几何平均值完全错误地变为 $0.0$。\n\n**2. 几何平均值的鲁棒算法：对数变换**\n\n一种数值稳定的方法是通过使用对数来避免大数乘积。基于恒等式 $\\ln(G) = \\frac{1}{n}\\sum_{i=1}^{n}\\ln(x_i)$，几何平均值可以计算为：\n$G_{\\text{robust}} = \\exp\\left(\\frac{1}{n} \\sum_{i=1}^{n} \\ln(x_i)\\right)$。\n这种变换将乘积转换为求和。对于 $x_i \\approx \\varepsilon$，$\\ln(x_i)$ 的值是中等大小的负数（约 $\\ln(2.22 \\times 10^{-16}) \\approx -36.0$）。对这些值求和在数值上是稳定的，并避免了直接乘法固有的下溢/上溢问题。对数和使用标准的 `numpy.sum()` 计算。\n\n**3. 几何平均值的基准**\n\n为了创建最准确的参考值 $G_{\\text{ref}}$，我们将鲁棒的对数变换与用于求和部分的高精度 `math.fsum()` 相结合：\n$G_{\\text{ref}} = \\exp\\left(\\frac{\\mathrm{math.fsum}(\\{\\ln(x_1), \\dots, \\ln(x_n)\\})}{n}\\right)$。\n这将作为“真实”值，用于与直接方法和鲁棒方法进行比较。\n\n**III. 误差量化**\n\n每种方法的鲁棒性通过其相对于相应基准值的相对误差来量化。对于一个近似值 $a_{\\text{approx}}$ 和一个参考值 $a_{\\text{ref}}$，相对误差计算为 $\\frac{|a_{\\text{approx}} - a_{\\text{ref}}|}{a_{\\text{ref}}}$。由于所有 $x_i$ 都是严格正数，所有平均值都将是正数，并且参考值将非零。\n\n程序将对四个指定的测试用例中的每一个执行此分析，这些用例旨在探究数值稳定性的不同方面，包括大 $n$ 和潜在下溢的影响。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef kahan_sum(arr: np.ndarray) - float:\n    \"\"\"\n    Computes the sum of an array of floats using Kahan's summation algorithm\n    to minimize numerical error.\n    \"\"\"\n    s = 0.0\n    c = 0.0  # A running compensation for lost low-order bits.\n    for x in arr:\n        y = x - c\n        t = s + y\n        # Algebraically, c should be 0.\n        # But in floating point, it recovers the lost low-order part of y.\n        c = (t - s) - y\n        s = t\n    return s\n\ndef relative_error(approx_val: float, ref_val: float) - float:\n    \"\"\"\n    Computes the relative error of an approximation.\n    \"\"\"\n    if ref_val == 0:\n        # Avoid division by zero. If ref is 0, any non-zero approx is infinite error.\n        # If both are 0, error is 0.\n        return 0.0 if approx_val == 0.0 else np.inf\n    return np.abs(approx_val - ref_val) / np.abs(ref_val)\n\ndef generate_test_cases():\n    \"\"\"\n    Generates the four deterministic test cases as specified in the problem.\n    \"\"\"\n    eps = np.finfo(np.float64).eps\n\n    # Case 1 (happy path, small n)\n    n1 = 5\n    x1 = np.array([eps * (1.0 + i * 1e-12) for i in range(n1)], dtype=np.float64)\n\n    # Case 2 (product underflow stress)\n    n2 = 300\n    x2 = np.full(n2, eps, dtype=np.float64)\n\n    # Case 3 (large n, mild heterogeneity)\n    n3 = 20000\n    x3 = np.full(n3, eps, dtype=np.float64)\n    x3[1::2] = 1.5 * eps  # even indices in 1-based counting\n\n    # Case 4 (very large n, tiny deterministic perturbations)\n    n4 = 100000\n    i = np.arange(n4)\n    perturbations = ((i % 10) - 5) * 1e-16\n    x4 = eps * (1.0 + perturbations)\n\n    return [(n1, x1), (n2, x2), (n3, x3), (n4, x4)]\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the results.\n    \"\"\"\n    test_cases = generate_test_cases()\n    all_results = []\n\n    for n, x in test_cases:\n        case_results = []\n\n        # --- Arithmetic Mean Analysis ---\n        # Baseline AM (high-accuracy sum)\n        am_ref = math.fsum(x) / n\n        \n        # Straightforward AM\n        am_sf = np.sum(x) / n\n        \n        # Robust AM (Kahan sum)\n        am_robust = kahan_sum(x) / n\n\n        # Relative errors for AM\n        err_am_sf = relative_error(am_sf, am_ref)\n        err_am_robust = relative_error(am_robust, am_ref)\n        case_results.extend([err_am_sf, err_am_robust])\n\n        # --- Geometric Mean Analysis ---\n        log_x = np.log(x)\n        \n        # Baseline GM (log-transform with high-accuracy sum)\n        gm_ref = np.exp(math.fsum(log_x) / n)\n        \n        # Straightforward GM (direct product)\n        # This is expected to underflow for large n\n        with np.errstate(under='ignore'): # Suppress underflow warnings for clean output\n            gm_sf = np.prod(x)**(1.0/n)\n        \n        # Robust GM (log-transform with standard sum)\n        gm_robust = np.exp(np.sum(log_x) / n)\n\n        # Relative errors for GM\n        err_gm_sf = relative_error(gm_sf, gm_ref)\n        err_gm_robust = relative_error(gm_robust, gm_ref)\n        case_results.extend([err_gm_sf, err_gm_robust])\n        \n        all_results.append(case_results)\n\n    # Format the final output string exactly as specified.\n    results_str_parts = []\n    for row in all_results:\n        # Use repr() for high-precision floating point string representation\n        # which is suitable for this numerical context.\n        row_str = \",\".join(map(repr, row))\n        results_str_parts.append(f\"[{row_str}]\")\n    \n    final_output = f\"[{','.join(results_str_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3205191"}, {"introduction": "最后的这个实践将我们从静态计算带入动态模拟的世界，通过测试常微分方程（ODE）的数值求解器来考察其稳定性。我们将使用一个具有已知解析解且解中存在奇点的 ODE 方程 $\\frac{dy}{dt} = y^2$ 来设计一个“压力测试”，以评估求解器在接近奇点时的稳健性。这个练习[@problem_id:3205101]超越了简单的精度检查，旨在评估求解器是否能保持解的重要定性特征，为你提供一个在极限条件下验证和理解复杂数值算法行为的实用框架。", "problem": "要求您在一个受控的测试框架内，为一个黑盒常微分方程（ODE）求解器设计并实现一个稳定性压力测试。其目标是评估求解器在积分一个解的奇点位置依赖于初始条件的 ODE 时的鲁棒性和稳定性。使用一个数学上可分析的模型来定义基准真相（ground truth）和明确的通过/失败标准。\n\n考虑标量 ODE 的初值问题\n$$\n\\frac{dy}{dt} = y^2,\\quad y(0)=y_0.\n$$\n从分离变量法和微积分基本定理出发，对于任何非零初始条件，其精确解为\n$$\ny(t) = \\frac{y_0}{1 - y_0 t},\n$$\n该解在以下时间点表现出有限时间爆破（解的奇点）\n$$\nt^\\star = \\frac{1}{y_0}\\quad \\text{当 } y_0  0.\n$$\n对于 $y_0  0$，爆破发生在负时间 $t^\\star = 1/y_0$，因此对于任何 $T \\ge 0$，在正向时间区间 $[0,T]$ 内不存在奇点；精确解是单调递增的，并且对于所有 $t \\ge 0$ 都保持为负值。\n\n利用这些基本事实来为数值 ODE 求解器构建一个压力测试。核心思想是，如果 $y_00$，则仅积分到奇点前的一个指定最终时间 $T$，即 $T = \\alpha \\, t^\\star$（其中 $0  \\alpha  1$），并检查一个可靠的求解器在奇点附近应满足的稳定性和鲁棒性属性。\n\n为在均匀步长 $t_k = k h$（其中 $N h = T$）下计算出的数值轨迹 $\\{y_k\\}_{k=0}^N$ 定义以下通过/失败标准：\n- 有限算术：每个 $y_k$ 都必须是有限浮点数（非“非数值(Not-a-Number)”或无穷大）。\n- 定性不变量：由于对所有 $y$ 都有 $\\frac{dy}{dt} = y^2 \\ge 0$，精确解在其定义域内的任何区间上都是单调递增的。一个鲁棒的算法应对于所有 $k$ 满足 $y_{k+1} - y_k \\ge -\\tau_{\\text{mono}}$，其中 $\\tau_{\\text{mono}}  0$ 是一个很小的容差。此外，在 $[0,T]$ 上应保持符号不变：如果 $y_00$，要求所有 $k$ 都有 $y_k0$；如果 $y_00$，要求所有 $k$ 都有 $y_k0$。\n- 终端时间精度：在时间 $T$ 的相对误差，\n$$\n\\mathrm{RE} = \\frac{\\lvert y_N - y_{\\mathrm{exact}}(T)\\rvert}{\\max(\\lvert y_{\\mathrm{exact}}(T)\\rvert,\\varepsilon)},\n$$\n必须低于容差 $\\tau_{\\mathrm{rel}}$，其中 $y_{\\mathrm{exact}}(t) = \\dfrac{y_0}{1 - y_0 t}$ 且 $\\varepsilon0$ 是一个用于防止除以零的小正则化常数。\n- 最后一步的后向误差代理：将最后一步的离散残差定义为\n$$\nr = \\frac{y_N - y_{N-1}}{h} - f(t_N, y_N),\\quad f(t,y)=y^2.\n$$\n一个鲁棒的解应满足其归一化残差\n$$\n\\rho = \\frac{\\lvert r \\rvert}{\\lvert f(t_N, y_N)\\rvert + \\varepsilon}\n$$\n低于容差 $\\tau_{\\mathrm{res}}$。\n\n在此任务中，通过将两种标准的显式方法封装为代理，将被测求解器视为黑盒：\n- 前向欧拉法 (Forward Euler, FE)，定义为 $y_{k+1} = y_k + h f(t_k,y_k)$。\n- 经典四阶龙格-库塔法 (Classical fourth-order Runge-Kutta, RK4)，定义为每步进行四次阶段求值，并将其组合到标准的四阶段公式中。\n\n实现一个程序，该程序：\n- 为以下情况构建 ODE $f(t,y) = y^2$ 和精确解 $y_{\\mathrm{exact}}(t) = \\dfrac{y_0}{1 - y_0 t}$。\n- 对每个测试用例，使用固定的步长 $h$（使得 $N = T/h$ 为整数），分别用 FE 和 RK4 方法从 $t=0$ 积分到 $t=T$。\n- 使用以下固定容差应用上述通过/失败标准：$\\tau_{\\text{mono}} = 10^{-12}$，$\\tau_{\\mathrm{rel}} = 0.2$，$\\tau_{\\mathrm{res}} = 0.5$ 和 $\\varepsilon = 10^{-15}$。\n- 为每种情况和每种方法，报告一个布尔值，指示是否所有标准都得到满足。\n\n使用以下测试套件，它涵盖了从良性到接近奇点的各种情况：\n- 情况 A（中等程度接近爆破）：$y_0 = 1.0$，$\\alpha = 0.90$，$T = \\alpha \\cdot t^\\star = 0.90 \\cdot \\frac{1}{1.0} = 0.9$，$h = 0.01$。\n- 情况 B（更接近爆破）：$y_0 = 1.0$，$\\alpha = 0.99$，$T = 0.99$，$h = 0.01$。\n- 情况 C1（非常接近爆破，粗糙步长）：$y_0 = 4.0$，$\\alpha = 0.99$，$t^\\star = \\frac{1}{4.0} = 0.25$，$T = 0.99 \\cdot 0.25 = 0.2475$，$h = 0.0275$。\n- 情况 C2（非常接近爆破，精细步长）：$y_0 = 4.0$，$\\alpha = 0.99$，$T = 0.2475$，$h = 0.0025$。\n- 情况 D（远离爆破）：$y_0 = 10^{-3}$，$\\alpha = 0.01$，$t^\\star = 1000.0$，$T = 10.0$，$h = 0.1$。\n- 情况 E（无正向时间奇点，负初始条件）：$y_0 = -1.0$，$T = 10.0$（此处不使用 $\\alpha$），$h = 0.1$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表应按顺序包含每个案例中 Forward Euler 法和 Runge-Kutta 法的通过布尔值：$[\\text{FE-A},\\text{RK4-A},\\text{FE-B},\\text{RK4-B},\\text{FE-C1},\\text{RK4-C1},\\text{FE-C2},\\text{RK4-C2},\\text{FE-D},\\text{RK4-D},\\text{FE-E},\\text{RK4-E}]$。此问题中没有物理单位或角度；所有量都是无量纲的实数。", "solution": "该问题要求为数值 ODE 求解器设计并实现一个稳定性和鲁棒性压力测试。该测试基于由以下常微分方程（ODE）给出的标量初值问题（IVP）：\n$$\n\\frac{dy}{dt} = f(t,y) = y^2\n$$\n其初始条件为 $y(0) = y_0$。这个问题是可解析的，为定义基准真相和客观性能指标提供了坚实的基础。\n\n该 IVP 的精确解由下式给出：\n$$\ny_{\\mathrm{exact}}(t) = \\frac{y_0}{1 - y_0 t}\n$$\n对于初始条件 $y_0  0$，解在时间 $t^\\star = 1/y_0$ 处表现出有限时间奇点（一个“爆破”现象，解趋于无穷大）。对于 $y_0  0$，奇点发生在负时间，这意味着解是良态的，并且对于所有 $t \\ge 0$ 都保持有限。这种二分法提供了一种自然的方式来构建测试用例，以探测求解器在良性和接近奇点两种情况下的行为。\n\n解决方案的核心是一个测试框架，它执行给定的数值求解器，并根据一组预定义的标准评估其输出。待测试的求解器是前向欧拉法（FE）和经典四阶龙格-库塔法（RK4），它们被视为黑盒组件。\n\n实现包括几个关键组件：\n\n1.  **问题定义**：ODE 函数 $f(t,y) = y^2$ 和精确解函数 $y_{\\mathrm{exact}}(t, y_0)$ 直接根据其数学公式实现。它们作为数值积分和误差计算的基础。\n\n2.  **数值求解器**：\n    -   **前向欧拉法 (Forward Euler, FE)**：一种一阶显式方法，由迭代式 $y_{k+1} = y_k + h f(t_k, y_k)$ 定义，其中 $h$ 是步长，$t_k = k h$，$y_k \\approx y(t_k)$。\n    -   **经典四阶龙格-库塔法 (Classical Fourth-Order Runge-Kutta, RK4)**：一种提供更高精度的更高阶显式方法。从 $y_k$ 到 $y_{k+1}$ 的单步计算通过四个中间阶段完成：\n        $$\n        \\begin{align*}\n        k_1 = f(t_k, y_k) \\\\\n        k_2 = f(t_k + h/2, y_k + h/2 \\cdot k_1) \\\\\n        k_3 = f(t_k + h/2, y_k + h/2 \\cdot k_2) \\\\\n        k_4 = f(t_k + h, y_k + h \\cdot k_3) \\\\\n        y_{k+1} = y_k + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n        \\end{align*}\n        $$\n    两种求解器都使用固定的步长 $h$ 将 ODE 从 $t_0=0$ 积分到最终时间 $T$，生成数值轨迹 $\\{y_k\\}_{k=0}^N$。\n\n3.  **测试框架和通过/失败标准**：设计一个函数来为一个给定的求解器和一组用例参数 $(y_0, T, h)$ 组织测试。该函数执行积分，然后依次应用四个检查。只有当所有标准都满足时，测试才被视为通过。\n\n    -   **标准 1：有限算术**：对鲁棒性最基本的检查是求解器不产生非物理值。计算出的轨迹中的每个点 $y_k$ 都必须是有限浮点数（即不是 `infinity` 或 `Not-a-Number`）。这可以防止灾难性故障，例如在接近奇点时发生的数值溢出。\n\n    -   **标准 2：定性不变量**：一个鲁棒的求解器应保留精确解的基本定性属性。对于此 ODE，由于 $\\frac{dy}{dt} = y^2 \\ge 0$，解是非递减的。我们用一个很小的容差来检查这一点：对于所有 $k$，$y_{k+1} - y_k \\ge -\\tau_{\\text{mono}}$，其中 $\\tau_{\\text{mono}} = 10^{-12}$。此外，解的符号不应改变。如果 $y_0  0$，那么对于所有 $t  t^\\star$，$y(t)  0$。如果 $y_0  0$，那么对于所有 $t \\ge 0$，$y(t)  0$。测试验证对于所有 $k$，$\\text{sign}(y_k) = \\text{sign}(y_0)$。\n\n    -   **标准 3：终端时间精度**：此标准评估数值解的定量正确性。在最终时间 $T$ 的相对误差（RE）计算如下：\n        $$\n        \\mathrm{RE} = \\frac{\\lvert y_N - y_{\\mathrm{exact}}(T)\\rvert}{\\max(\\lvert y_{\\mathrm{exact}}(T)\\rvert, \\varepsilon)}\n        $$\n        其中 $y_N$ 是在 $T$ 处的计算解，$y_{\\mathrm{exact}}(T)$ 是真实值，$\\varepsilon = 10^{-15}$ 是一个小的常数，用于在精确解接近零时防止除以零。如果 $\\mathrm{RE}  \\tau_{\\mathrm{rel}}$，测试通过，其中 $\\tau_{\\mathrm{rel}} = 0.2$。\n\n    -   **标准 4：后向误差代理**：此检查评估计算出的解在最后一步满足 ODE 的程度。离散残差 $r$ 使用后向差分近似导数来定义：\n        $$\n        r = \\frac{y_N - y_{N-1}}{h} - f(t_N, y_N)\n        $$\n        小的残差表示轨迹的最后一段与 ODE 的动力学一致。我们检查归一化残差 $\\rho$ 是否低于一个容差：\n        $$\n        \\rho = \\frac{\\lvert r \\rvert}{\\lvert f(t_N, y_N)\\rvert + \\varepsilon}  \\tau_{\\mathrm{res}}\n        $$\n        其中 $\\tau_{\\mathrm{res}} = 0.5$。\n\n最后，一个主循环遍历指定的测试用例（A, B, C1, C2, D, E）。对于每个用例，它通过测试框架运行 FE 和 RK4 求解器，并记录布尔值的通过/失败结果。结果被收集并格式化为指定的字符串输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to design, implement, and run the stability stress test\n    for numerical ODE solvers.\n    \"\"\"\n    \n    # Define constants, tolerances, and problem-specific functions\n    F_ODE = lambda t, y: y**2\n    EXACT_SOL = lambda t, y0: y0 / (1 - y0 * t) if (1 - y0 * t) != 0 else np.inf\n\n    TAU_MONO = 1e-12\n    TAU_REL = 0.2\n    TAU_RES = 0.5\n    EPSILON = 1e-15\n\n    def solver_fe(f, y0, t_span, h):\n        \"\"\"\n        Integrates an ODE using the Forward Euler method.\n        \"\"\"\n        t0, T = t_span\n        # Use np.round to mitigate floating point inaccuracies in T/h\n        num_steps = int(np.round(T / h))\n        t_values = np.linspace(t0, T, num_steps + 1)\n        y_values = np.zeros(num_steps + 1, dtype=np.float64)\n        y_values[0] = y0\n        \n        for k in range(num_steps):\n            try:\n                y_values[k+1] = y_values[k] + h * f(t_values[k], y_values[k])\n            except OverflowError:\n                y_values[k+1:] = np.inf\n                break\n        return t_values, y_values\n\n    def solver_rk4(f, y0, t_span, h):\n        \"\"\"\n        Integrates an ODE using the classical 4th-order Runge-Kutta method.\n        \"\"\"\n        t0, T = t_span\n        num_steps = int(np.round(T / h))\n        t_values = np.linspace(t0, T, num_steps + 1)\n        y_values = np.zeros(num_steps + 1, dtype=np.float64)\n        y_values[0] = y0\n        \n        for k in range(num_steps):\n            t_k = t_values[k]\n            y_k = y_values[k]\n            try:\n                k1 = f(t_k, y_k)\n                k2 = f(t_k + h / 2, y_k + h / 2 * k1)\n                k3 = f(t_k + h / 2, y_k + h / 2 * k2)\n                k4 = f(t_k + h, y_k + h * k3)\n                y_values[k+1] = y_k + h / 6 * (k1 + 2*k2 + 2*k3 + k4)\n            except OverflowError:\n                y_values[k+1:] = np.inf\n                break\n        return t_values, y_values\n\n    def run_test_harness(solver, y0, T, h):\n        \"\"\"\n        Runs a single test case for a given solver and evaluates against all criteria.\n        Returns a single boolean indicating pass or fail.\n        \"\"\"\n        t_span = (0, T)\n        t_values, y_values = solver(F_ODE, y0, t_span, h)\n        \n        # Criterion 1: Finite arithmetic\n        if not np.all(np.isfinite(y_values)):\n            return False\n            \n        # Criterion 2: Qualitative invariants\n        # Monotonicity\n        if not np.all(np.diff(y_values) = -TAU_MONO):\n            return False\n        # Sign preservation\n        if y0  0:\n            if not np.all(y_values  0):\n                return False\n        elif y0  0:\n            if not np.all(y_values  0):\n                return False\n                \n        # Criterion 3: Accuracy at terminal time\n        y_N = y_values[-1]\n        y_exact_T = EXACT_SOL(T, y0)\n        rel_err = np.abs(y_N - y_exact_T) / np.maximum(np.abs(y_exact_T), EPSILON)\n        if rel_err = TAU_REL:\n            return False\n            \n        # Criterion 4: Backward error proxy\n        y_N_minus_1 = y_values[-2]\n        t_N = t_values[-1]\n        f_at_yN = F_ODE(t_N, y_N)\n        residual = (y_N - y_N_minus_1) / h - f_at_yN\n        norm_residual = np.abs(residual) / (np.abs(f_at_yN) + EPSILON)\n        if norm_residual = TAU_RES:\n            return False\n            \n        # All criteria passed\n        return True\n\n    # Define the test suite from the problem statement.\n    test_cases = [\n        {'y0': 1.0, 'T': 0.9, 'h': 0.01},   # Case A\n        {'y0': 1.0, 'T': 0.99, 'h': 0.01},  # Case B\n        {'y0': 4.0, 'T': 0.2475, 'h': 0.0275}, # Case C1\n        {'y0': 4.0, 'T': 0.2475, 'h': 0.0025}, # Case C2\n        {'y0': 1e-3, 'T': 10.0, 'h': 0.1},  # Case D\n        {'y0': -1.0, 'T': 10.0, 'h': 0.1},  # Case E\n    ]\n\n    solvers_to_test = [solver_fe, solver_rk4]\n    results = []\n\n    for case in test_cases:\n        for solver in solvers_to_test:\n            result = run_test_harness(solver, case['y0'], case['T'], case['h'])\n            results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3205101"}]}