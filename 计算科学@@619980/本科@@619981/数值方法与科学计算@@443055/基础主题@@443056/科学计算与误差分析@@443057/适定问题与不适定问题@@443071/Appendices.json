{"hands_on_practices": [{"introduction": "在求解科学与工程问题时，我们经常遇到线性方程组 $Ax=b$。如果矩阵 $A$ 是病态的 (ill-conditioned)，那么输入数据 $b$ 中的微小扰动（例如，测量误差）可能会导致解 $x$ 出现巨大变化。这个练习 [@problem_id:2197153] 通过一个简单的 $2 \\times 2$ 系统，直观地展示了这种不稳定性，帮助你亲手量化一个微小的输入误差如何被放大，从而对病态问题建立起具体而深刻的认识。", "problem": "在许多科学和工程应用中，我们会遇到形如 $Ax = b$ 的线性方程组，其中我们需要在给定矩阵 $A$ 和向量 $b$ 的情况下求解向量 $x$。向量 $b$ 通常代表测量值，而测量值会受到微小误差的影响。病态系统是指 $b$ 中的微小误差可能导致解 $x$ 出现巨大误差的系统。\n\n考虑以下病态线性系统：\n$$\nA = \\begin{pmatrix} 1  1 \\\\ 1  1.001 \\end{pmatrix}\n$$\n我们首先考虑测量向量精确为以下值的情况：\n$$\nb_{orig} = \\begin{pmatrix} 2 \\\\ 2.001 \\end{pmatrix}\n$$\n相应的解向量为 $x_{orig}$，满足 $A x_{orig} = b_{orig}$。\n\n现在，假设出现了一个微小的测量误差，从而产生一个新的、受扰动的测量向量：\n$$\nb_{pert} = \\begin{pmatrix} 2 \\\\ 2.002 \\end{pmatrix}\n$$\n新的解向量为 $x_{pert}$，它满足 $A x_{pert} = b_{pert}$。\n\n你的任务是量化测量向量中这个微小扰动所产生的影响。计算解向量变化的幅度，该幅度由差值的欧几里得范数 $\\| x_{pert} - x_{orig} \\|_2$ 给出。将最终答案四舍五入至三位有效数字。", "solution": "我们使用 $x = A^{-1} b$ 来求解这两个线性系统。对于一个 $2 \\times 2$ 矩阵 $A = \\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix}$，其逆矩阵为 $A^{-1} = \\frac{1}{ad - bc} \\begin{pmatrix} d  -b \\\\ -c  a \\end{pmatrix}$。在本题中，\n$$\nA = \\begin{pmatrix} 1  1 \\\\ 1  \\frac{1001}{1000} \\end{pmatrix},\n\\quad \\det(A) = 1 \\cdot \\frac{1001}{1000} - 1 \\cdot 1 = \\frac{1}{1000}.\n$$\n因此，\n$$\nA^{-1} = 1000 \\begin{pmatrix} \\frac{1001}{1000}  -1 \\\\ -1  1 \\end{pmatrix} = \\begin{pmatrix} 1001  -1000 \\\\ -1000  1000 \\end{pmatrix}.\n$$\n对于 $b_{orig} = \\begin{pmatrix} 2 \\\\ \\frac{2001}{1000} \\end{pmatrix}$，\n$$\nx_{orig} = A^{-1} b_{orig} = \\begin{pmatrix} 1001  -1000 \\\\ -1000  1000 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ \\frac{2001}{1000} \\end{pmatrix}\n= \\begin{pmatrix} 1001 \\cdot 2 - 1000 \\cdot \\frac{2001}{1000} \\\\ -1000 \\cdot 2 + 1000 \\cdot \\frac{2001}{1000} \\end{pmatrix}\n= \\begin{pmatrix} 2002 - 2001 \\\\ -2000 + 2001 \\end{pmatrix}\n= \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}.\n$$\n对于 $b_{pert} = \\begin{pmatrix} 2 \\\\ \\frac{2002}{1000} \\end{pmatrix}$，\n$$\nx_{pert} = A^{-1} b_{pert} = \\begin{pmatrix} 1001  -1000 \\\\ -1000  1000 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ \\frac{2002}{1000} \\end{pmatrix}\n= \\begin{pmatrix} 1001 \\cdot 2 - 1000 \\cdot \\frac{2002}{1000} \\\\ -1000 \\cdot 2 + 1000 \\cdot \\frac{2002}{1000} \\end{pmatrix}\n= \\begin{pmatrix} 2002 - 2002 \\\\ -2000 + 2002 \\end{pmatrix}\n= \\begin{pmatrix} 0 \\\\ 2 \\end{pmatrix}.\n$$\n解的变化为\n$$\nx_{pert} - x_{orig} = \\begin{pmatrix} 0 \\\\ 2 \\end{pmatrix} - \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix},\n$$\n其欧几里得范数为\n$$\n\\|x_{pert} - x_{orig}\\|_{2} = \\sqrt{(-1)^{2} + 1^{2}} = \\sqrt{2}.\n$$\n将 $\\sqrt{2}$ 四舍五入至三位有效数字得到 $1.41$。", "answer": "$$\\boxed{1.41}$$", "id": "2197153"}, {"introduction": "数值微分是阐释不适定问题的经典范例，其核心困难在于微分算子会无限放大数据中存在的高频噪声，导致结果完全不可用。本练习 [@problem_id:3286744] 不仅揭示了这一问题，更引导你实践一种核心的解决方案：正则化。你将通过先平滑数据再进行差分的方法来稳定微分过程，并推导和实现一个优化的平滑宽度，从而深刻理解在解决不适定问题时至关重要的偏差-方差权衡 (bias-variance trade-off)。", "problem": "给定任务是从均匀采样且带噪的观测值 $y_i = f(x_i) + \\epsilon_i$ 中估算导数 $f'(x_0)$。这些观测值是在网格 $x_i = x_0 + i \\,\\Delta x$ 上得到的，其中噪声 $\\epsilon_i$ 是独立同分布的，均值为零，方差为 $\\sigma^2$。根据雅克·阿达马（Jacques Hadamard）提出的适定性定义（解的存在性、唯一性以及对数据的连续依赖性），将数值微分问题构建为一个反问题，并通过证明高频噪声在微分过程中被放大来解释其为何是不适定的。然后，为稳定估算，考虑使用以下两步线性估算器来估算 $f'(x_0)$：\n- 首先，使用宽度为 $h$ 的对称盒式（均匀）核平滑数据（因此平滑后的函数为 $f * K_h$，其中 $K_h$ 是偶函数且已归一化）。\n- 然后，对平滑后的信号应用中心差分公式，步长为 $\\Delta x$。\n\n仅从以下基本事实出发：\n- 卷积的导数满足 $(f * K_h)' = f' * K_h$。\n- 对称且归一化的盒式核的二阶矩为 $\\mu_2(K_h) = h^2/12$。\n- 对 $m \\approx h/\\Delta x$ 个独立样本进行移动平均，可将方差减小 $m$ 倍；对两个独立样本求差，其方差会相加。\n推导某一点的主阶均方误差，\n$$\n\\operatorname{MSE}(h) \\approx \\text{bias}^2(h) + \\text{var}(h),\n$$\n其中偏差由局部三阶导数 $f^{(3)}(x_0)$ 决定，而方差由 $\\sigma^2$、$\\Delta x$ 和 $h$ 决定。证明最小化此渐近表达式可得到最优宽度\n$$\nh_\\star \\;=\\; \\left(\\frac{72\\,\\sigma^2}{\\Delta x\\,\\big(f^{(3)}(x_0)\\big)^2}\\right)^{1/5}.\n$$\n在实践中，$h$ 不能小于 $\\Delta x$，并且不应超过由定义域或趋势尺度考量所决定的用户自定义最大值 $H_{\\max}$。此外，当 $\\lvert f^{(3)}(x_0)\\rvert$ 极小时，偏差可以忽略不计，最优宽度应饱和于 $H_{\\max}$。\n\n你的程序必须实现以下映射：\n$$\n(\\Delta x,\\;\\sigma,\\;H_{\\max},\\;x_0,\\;f)\\;\\longmapsto\\; h,\n$$\n使用以下规则：\n- 如果对于一个很小的阈值 $\\tau$，有 $\\lvert f^{(3)}(x_0)\\rvert \\le \\tau$，则设 $h = H_{\\max}$。\n- 否则，计算 $h_\\star = \\left(\\frac{72\\,\\sigma^2}{\\Delta x\\,[f^{(3)}(x_0)]^2}\\right)^{1/5}$，并将其裁剪到 $[\\Delta x,\\;H_{\\max}]$ 范围内。\n\n角度应以弧度为单位。本问题中没有物理单位。对于数值报告，将每个 $h$ 表示为四舍五入到小数点后六位的小数。\n\n测试套件。对于以下每种情况，使用上述规则计算 $h$。每个函数 $f$ 都是平滑的，其三阶导数 $f^{(3)}$ 已解析给出：\n- 情况 A: $f(x) = \\sin(x)$，因此 $f^{(3)}(x) = -\\cos(x)$。参数：$x_0 = 1.0$，$\\Delta x = 0.01$，$\\sigma = 0.02$，$H_{\\max} = 2.0$。\n- 情况 B: $f(x) = e^{x}$，因此 $f^{(3)}(x) = e^{x}$。参数：$x_0 = 0.0$，$\\Delta x = 0.005$，$\\sigma = 0.05$，$H_{\\max} = 2.0$。\n- 情况 C: $f(x) = x^3$，因此 $f^{(3)}(x) = 6$。参数：$x_0 = 0.2$，$\\Delta x = 0.1$，$\\sigma = 0.0001$，$H_{\\max} = 2.0$。\n- 情况 D: $f(x) = \\cos(5x)$，因此 $f^{(3)}(x) = 125\\,\\sin(5x)$。参数：$x_0 = 0.0$，$\\Delta x = 0.01$，$\\sigma = 0.1$，$H_{\\max} = 1.0$。\n\n最终输出格式。你的程序应生成单行输出，其中包含一个逗号分隔的列表，按 A、B、C、D 的顺序排列四个计算出的 $h$ 值，四舍五入到小数点后六位，并用方括号括起来，例如 $[h_A,h_B,h_C,h_D]$。", "solution": "该问题陈述经评估是有效的。它在科学上基于数值分析原理和反问题研究，特别是不适定问题的正则化。问题是适定的、自洽的，所有数据、定义和约束都已提供且相互一致。任务是首先为所用方法提供理论证明，然后根据推导出的结果实现一个特定的算法。\n\n### 数值微分的不适定性\n\n从一组数据点中求取函数 $f$ 的导数 $f'$ 的问题可以构建为一个反问题。设 $D$ 为微分算子，使得 $D(f) = f'$。我们的目标是在给定带噪数据 $y = f + \\epsilon$ 的情况下恢复 $f'$。将算子 $D$ 应用于数据，得到 $D(y) = D(f) + D(\\epsilon) = f' + \\epsilon'$。问题的症结在于噪声项 $D(\\epsilon) = \\epsilon'$ 的行为。\n\n根据雅克·阿达马（Jacques Hadamard）的理论，如果一个问题的解存在、唯一且连续地依赖于输入数据，则该问题是适定的。数值微分违反了第三个准则。为了说明这一点，考虑数据中的一个高频噪声分量，形式为 $\\epsilon(x) = A \\sin(\\omega x)$，其中振幅 $A$ 很小，频率 $\\omega$ 很大。对函数 $f$ 的这种扰动幅度最多为 $A$。然而，对导数 $f'$ 的扰动是 $\\epsilon'(x) = A \\omega \\cos(\\omega x)$，其幅度为 $A\\omega$。通过选择足够大的频率 $\\omega$，即使数据中的误差 $A$ 无穷小，导数中的误差 $A\\omega$ 也可以变得任意大。\n\n这表明解（导数）不连续地依赖于输入数据。输入中微小的高频扰动可以被放大为输出中任意大的扰动。因此，数值微分是一个不适定问题。为了获得稳定且有意义的解，需要一种正则化技术，这通常涉及在微分前对数据进行平滑处理。\n\n### 正则化估算器的分析\n\n所提出的估算器通过先平滑数据再应用有限差分公式来对问题进行正则化。这两个步骤是：\n1. 使用宽度为 $h$ 的对称盒式（均匀）核 $K_h$ 平滑带噪数据 $y$。平滑后的信号为 $\\tilde{y} = y * K_h$。\n2. 对平滑后的信号 $\\tilde{y}$ 应用步长为 $\\Delta x$ 的中心差分公式，以近似 $x_0$ 处的导数。\n\n因此，$f'(x_0)$ 的估算器由下式给出：\n$$\n\\hat{f}'(x_0) = \\frac{\\tilde{y}(x_0 + \\Delta x) - \\tilde{y}(x_0 - \\Delta x)}{2 \\Delta x} = \\frac{(y * K_h)(x_0 + \\Delta x) - (y * K_h)(x_0 - \\Delta x)}{2 \\Delta x}\n$$\n该估算器的性能由其均方误差（$\\operatorname{MSE}$）表征，均方误差可以分解为偏差的平方与方差之和：\n$$\n\\operatorname{MSE}(h) = \\text{bias}^2(h) + \\text{var}(h) = \\left( E[\\hat{f}'(x_0)] - f'(x_0) \\right)^2 + \\operatorname{Var}(\\hat{f}'(x_0))\n$$\n\n#### 偏差推导\n偏差是估算器的系统误差。由于噪声 $\\epsilon_i$ 的均值为零（$E[\\epsilon_i]=0$），估算器的期望值可以通过将其应用于无噪声函数 $f(x)$ 来找到：\n$$\nE[\\hat{f}'(x_0)] = \\frac{(f * K_h)(x_0 + \\Delta x) - (f * K_h)(x_0 - \\Delta x)}{2 \\Delta x}\n$$\n这是函数 $g(x) = (f * K_h)(x)$ 在 $x=x_0$ 处导数的中心差分近似。对于足够小的 $\\Delta x$，该表达式是 $g'(x_0)$ 的一个良好近似。利用给定的事实 $(f * K_h)' = f' * K_h$，我们有 $g'(x_0) = (f' * K_h)(x_0)$。中心差分公式本身引入的误差是 $O((\\Delta x)^2)$ 阶的，与平滑偏差相比被认为是更高阶的，因此对于主阶偏差，我们可以近似为 $E[\\hat{f}'(x_0)] \\approx (f' * K_h)(x_0)$。\n\n偏差即为期望的平滑导数与真实导数之差：\n$$\n\\text{bias}(h) = E[\\hat{f}'(x_0)] - f'(x_0) \\approx (f' * K_h)(x_0) - f'(x_0)\n$$\n为分析此式，我们在卷积积分内将 $f'$ 在 $x_0$ 附近作泰勒级数展开：\n$$\n(f' * K_h)(x_0) = \\int_{-\\infty}^{\\infty} f'(x_0 - u) K_h(u) du \\approx \\int_{-\\infty}^{\\infty} \\left[ f'(x_0) - u f''(x_0) + \\frac{u^2}{2} f^{(3)}(x_0) \\right] K_h(u) du\n$$\n由于核 $K_h$ 是归一化的（$\\int K_h(u) du = 1$）和对称的（$\\int u K_h(u) du = 0$），上式可简化为：\n$$\n(f' * K_h)(x_0) \\approx f'(x_0) \\int K_h(u) du - f''(x_0) \\int u K_h(u) du + \\frac{f^{(3)}(x_0)}{2} \\int u^2 K_h(u) du\n$$\n$$\n(f' * K_h)(x_0) \\approx f'(x_0) + \\frac{f^{(3)}(x_0)}{2} \\mu_2(K_h)\n$$\n其中 $\\mu_2(K_h)$ 是核的二阶矩。利用给定的事实 $\\mu_2(K_h) = h^2/12$，主阶偏差为：\n$$\n\\text{bias}(h) \\approx \\frac{h^2}{24} f^{(3)}(x_0)\n$$\n因此，偏差的平方为：\n$$\n\\text{bias}^2(h) \\approx \\frac{h^4}{576} \\left(f^{(3)}(x_0)\\right)^2\n$$\n\n#### 方差推导\n估算器的方差捕获了随机噪声 $\\epsilon_i$ 的影响。\n$$\n\\operatorname{Var}(\\hat{f}'(x_0)) = \\operatorname{Var}\\left( \\frac{(\\epsilon * K_h)(x_0 + \\Delta x) - (\\epsilon * K_h)(x_0 - \\Delta x)}{2 \\Delta x} \\right)\n$$\n令 $\\tilde{\\epsilon}(x) = (\\epsilon * K_h)(x)$ 为平滑后的噪声。方差为：\n$$\n\\operatorname{Var}(\\hat{f}'(x_0)) = \\frac{1}{4(\\Delta x)^2} \\operatorname{Var}\\left( \\tilde{\\epsilon}(x_0 + \\Delta x) - \\tilde{\\epsilon}(x_0 - \\Delta x) \\right)\n$$\n根据提供的提示，对 $m \\approx h/\\Delta x$ 个样本进行移动平均平滑，可将噪声方差从 $\\sigma^2$ 减小到 $\\sigma^2/m = \\sigma^2 \\Delta x / h$。\n因此，$\\operatorname{Var}(\\tilde{\\epsilon}(x)) \\approx \\sigma^2 \\Delta x / h$。\n第二个提示指出，对两个独立样本求差会使其方差相加。为了进行主阶分析，我们假设在 $x_0+\\Delta x$ 和 $x_0-\\Delta x$ 处的平滑噪声值是近似独立的，这在 $h \\gg \\Delta x$ 时是合理的。那么它们差的方差就是它们方差的和：\n$$\n\\operatorname{Var}\\left( \\tilde{\\epsilon}(x_0 + \\Delta x) - \\tilde{\\epsilon}(x_0 - \\Delta x) \\right) \\approx \\operatorname{Var}(\\tilde{\\epsilon}(x_0+\\Delta x)) + \\operatorname{Var}(\\tilde{\\epsilon}(x_0-\\Delta x)) \\approx 2 \\frac{\\sigma^2 \\Delta x}{h}\n$$\n将此代回估算器方差的表达式中：\n$$\n\\operatorname{var}(h) \\approx \\frac{1}{4(\\Delta x)^2} \\left( \\frac{2 \\sigma^2 \\Delta x}{h} \\right) = \\frac{\\sigma^2}{2 h \\Delta x}\n$$\n\n#### 均方误差最小化与最优宽度\n结合偏差的平方和方差，得到渐近均方误差：\n$$\n\\operatorname{MSE}(h) \\approx \\frac{h^4}{576} \\left(f^{(3)}(x_0)\\right)^2 + \\frac{\\sigma^2}{2 h \\Delta x}\n$$\n为了找到最小化此 $\\operatorname{MSE}$ 的最优核宽度 $h_\\star$，我们对 $h$ 求导并令其结果为零：\n$$\n\\frac{d}{dh}\\operatorname{MSE}(h) = \\frac{4h^3}{576} \\left(f^{(3)}(x_0)\\right)^2 - \\frac{\\sigma^2}{2 h^2 \\Delta x} = 0\n$$\n$$\n\\frac{h^3}{144} \\left(f^{(3)}(x_0)\\right)^2 = \\frac{\\sigma^2}{2 h^2 \\Delta x}\n$$\n求解 $h^5$：\n$$\nh^5 = \\frac{144 \\sigma^2}{2 \\Delta x \\left(f^{(3)}(x_0)\\right)^2} = \\frac{72 \\sigma^2}{\\Delta x \\left(f^{(3)}(x_0)\\right)^2}\n$$\n这给出了最优宽度 $h_\\star$：\n$$\nh_\\star = \\left(\\frac{72\\,\\sigma^2}{\\Delta x\\,\\big(f^{(3)}(x_0)\\big)^2}\\right)^{1/5}\n$$\n这个推导证实了问题陈述中提供的公式。用于实现的算法将计算该值，处理 $f^{(3)}(x_0)$ 接近零的情况，并确保所得的 $h$ 在物理和实践界限 $[\\Delta x, H_{\\max}]$ 内。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the optimal smoothing width h for numerical differentiation\n    based on a bias-variance trade-off analysis.\n    \"\"\"\n    \n    # A small threshold to handle cases where the third derivative is zero or very close to it.\n    # This prevents division by zero and implements the saturation logic described.\n    tau = 1e-9\n\n    # Define the test cases from the problem statement.\n    # Each case is a dictionary for clarity.\n    test_cases = [\n        # Case A\n        {\n            \"f_name\": \"sin(x)\",\n            \"f3\": lambda x: -np.cos(x),\n            \"x0\": 1.0,\n            \"dx\": 0.01,\n            \"sigma\": 0.02,\n            \"Hmax\": 2.0,\n        },\n        # Case B\n        {\n            \"f_name\": \"exp(x)\",\n            \"f3\": lambda x: np.exp(x),\n            \"x0\": 0.0,\n            \"dx\": 0.005,\n            \"sigma\": 0.05,\n            \"Hmax\": 2.0,\n        },\n        # Case C\n        {\n            \"f_name\": \"x^3\",\n            \"f3\": lambda x: 6.0,\n            \"x0\": 0.2,\n            \"dx\": 0.1,\n            \"sigma\": 0.0001,\n            \"Hmax\": 2.0,\n        },\n        # Case D\n        {\n            \"f_name\": \"cos(5x)\",\n            \"f3\": lambda x: 125 * np.sin(5 * x),\n            \"x0\": 0.0,\n            \"dx\": 0.01,\n            \"sigma\": 0.1,\n            \"Hmax\": 1.0,\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        dx = case[\"dx\"]\n        sigma = case[\"sigma\"]\n        Hmax = case[\"Hmax\"]\n        \n        # Calculate the third derivative at x0\n        f3_val = case[\"f3\"](case[\"x0\"])\n        \n        # Apply the rule specified in the problem statement\n        if abs(f3_val) = tau:\n            # If the third derivative is negligible, bias is negligible.\n            # We choose the maximum smoothing to minimize variance.\n            h = Hmax\n        else:\n            # Calculate the optimal width h_star based on the derived formula\n            numerator = 72 * sigma**2\n            denominator = dx * f3_val**2\n            h_star = (numerator / denominator)**(1/5)\n            \n            # Clip the result to the valid range [dx, Hmax]\n            # h cannot be smaller than the grid spacing, and should not exceed Hmax.\n            h = np.clip(h_star, dx, Hmax)\n            \n        results.append(h)\n\n    # Final print statement in the exact required format.\n    # Each h value is formatted to six decimal places.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "3286744"}, {"introduction": "作为正则化思想的延伸，平滑样条为从噪声数据中拟合光滑曲线提供了一种强大的工具。这个练习 [@problem_id:3286808] 将此问题构建为一个带惩罚项的优化问题，其中正则化参数 $\\lambda$ 明确地控制着数据保真度（拟合噪声数据）与解的光滑度之间的权衡。你将通过计算和分析，量化 $\\lambda$ 如何影响解的稳定性（噪声放大程度）和整体精度（均方误差），从而更深入地掌握正则化在实践中的应用与调节。", "problem": "要求您精确描述、量化并以计算方式展示平滑参数在经典平滑样条的离散模拟中的作用，并在数据被加性噪声破坏时，将其与原始插值进行比较。操作在一维均匀网格上进行，所有角度均以弧度表示。\n\n考虑在 $[0,1]$ 上的一个包含 $N$ 个点的均匀网格，由 $x_i = i h$ 定义，其中 $i \\in \\{0,1,\\dots,N-1\\}$，间距为 $h = 1/(N-1)$。令 $f^{\\star}(x) = \\sin(2\\pi x) + \\tfrac{1}{2}\\cos(5\\pi x)$ 为未知的真实信号，并假设我们观测到含噪样本 $y_i = f^{\\star}(x_i) + \\epsilon_i$，其中 $\\epsilon_i$ 是独立的零均值高斯扰动，标准差为 $\\sigma$。通过将生成器种子设为 $0$ 并抽取一个长度为 $N$ 的向量来使用确定性的伪随机序列，这样每个 $(N,\\sigma)$ 对都使用一个固定的噪声实现。\n\n将平滑样条估计量 $f_{\\lambda}$ 的离散模拟定义为 $\\mathbb{R}^N$ 中使惩罚最小二乘泛函最小化的向量\n$$\nJ_{\\lambda}(f) = \\sum_{i=0}^{N-1} (f_i - y_i)^2 + \\lambda \\lVert D_2 f \\rVert_2^2,\n$$\n其中 $D_2$ 是标准的二阶差分算子，在内部节点上使用中心差分来近似二阶导数。具体来说，对于每个内部索引 $i \\in \\{1,2,\\dots,N-2\\}$，\n$$\n(D_2 f)_{i-1} = \\frac{f_{i-1} - 2 f_{i} + f_{i+1}}{h^2},\n$$\n使得 $D_2 \\in \\mathbb{R}^{(N-2)\\times N}$ 且 $L = D_2^{\\top} D_2 \\in \\mathbb{R}^{N\\times N}$。证明最小化子满足正规方程\n$$\n(I + \\lambda L) f_{\\lambda} = y,\n$$\n其中 $I \\in \\mathbb{R}^{N\\times N}$ 是单位矩阵，且 $y \\in \\mathbb{R}^N$ 是由 $y_i$ 堆叠而成的向量。将 $\\lambda = 0$ 的情况解释为在网格节点上的原始插值（即对含噪数据进行精确拟合 $f_0 = y$）。对于 $\\lambda  0$，定义线性平滑算子 $S_{\\lambda} = (I + \\lambda L)^{-1}$，使得 $f_{\\lambda} = S_{\\lambda} y$。\n\n您的计算任务是量化平滑参数 $\\lambda$ 在 Hadamard 适定性意义上如何控制关于噪声的稳定性。具体而言，通过算子 $D_2 S_{\\lambda}$ 检验估计曲率的稳定性。对于下面指定的每个测试用例，计算三个标量诊断指标：\n\n- 曲率的谱噪声放大率，由诱导 $2$-范数给出\n$$\na_{\\mathrm{spec}}(\\lambda) = \\lVert D_2 S_{\\lambda} \\rVert_2,\n$$\n它衡量了噪声在估计的二阶导数中的最坏情况放大率。\n\n- 在固定噪声实现上的经验曲率放大率，\n$$\na_{\\mathrm{emp}}(\\lambda) = \\frac{\\lVert D_2 S_{\\lambda} \\epsilon \\rVert_2}{\\lVert \\epsilon \\rVert_2},\n$$\n其中 $\\epsilon$ 是用于构成 $y$ 的确定性噪声向量。\n\n- 重建信号的均方误差，\n$$\n\\mathrm{MSE}(\\lambda) = \\frac{1}{N} \\sum_{i=0}^{N-1} \\bigl(f_{\\lambda,i} - f^{\\star}(x_i)\\bigr)^2.\n$$\n\n使用以下参数三元组 $(N,\\lambda,\\sigma)$ 的测试套件，所有角度均以弧度表示：\n\n- 用例 1：$(N,\\lambda,\\sigma) = (50, 0, 0.05)$。\n- 用例 2：$(N,\\lambda,\\sigma) = (50, 0.01, 0.05)$。\n- 用例 3：$(N,\\lambda,\\sigma) = (50, 0.1, 0.05)$。\n- 用例 4：$(N,\\lambda,\\sigma) = (50, 1.0, 0.05)$。\n- 用例 5：$(N,\\lambda,\\sigma) = (200, 0, 0.05)$。\n- 用例 6：$(N,\\lambda,\\sigma) = (200, 0.1, 0.05)$。\n\n您的程序必须在每个用例中，构造 $x_i$，使用从标准差为 $\\sigma$ 且伪随机生成器种子为 $0$ 的高斯分布中抽取的单个固定噪声向量来形成 $y_i = f^{\\star}(x_i) + \\epsilon_i$，构建 $D_2$，计算 $S_{\\lambda}$，然后计算三个诊断指标 $(a_{\\mathrm{spec}}, a_{\\mathrm{emp}}, \\mathrm{MSE})$。所有计算都是无量纲的。将三个诊断指标中的每一个都报告为一个四舍五入到六位小数的浮点数。\n\n最终输出格式：您的程序应生成一行，其中包含一个长度为六的列表，每个测试用例对应一个条目。每个条目本身必须是一个三元素列表，顺序为 $[a_{\\mathrm{spec}}, a_{\\mathrm{emp}}, \\mathrm{MSE}]$。例如，输出必须看起来像\n$[\\,[a_{\\mathrm{spec}}^{(1)},a_{\\mathrm{emp}}^{(1)},\\mathrm{MSE}^{(1)}],\\dots,[a_{\\mathrm{spec}}^{(6)},a_{\\mathrm{emp}}^{(6)},\\mathrm{MSE}^{(6)}]\\,]$\n其中每个浮点数都四舍五入到六位小数。", "solution": "问题陈述已经过验证，并被认为是数值分析中一个有效、自洽且适定的问题。它提出了一个关于不适定反问题（数值微分）正则化的标准练习，该练习使用平滑样条的离散模拟。所有的定义、参数和目标标准都已明确指定。\n\n问题的核心在于最小化对于向量 $f \\in \\mathbb{R}^N$ 的惩罚最小二乘泛函：\n$$\nJ_{\\lambda}(f) = \\sum_{i=0}^{N-1} (f_i - y_i)^2 + \\lambda \\lVert D_2 f \\rVert_2^2\n$$\n其中 $y \\in \\mathbb{R}^N$ 是含噪观测向量，$\\lambda \\geq 0$ 是平滑参数，且 $D_2 \\in \\mathbb{R}^{(N-2)\\times N}$ 是二阶差分矩阵算子。\n\n首先，我们推导最小化子 $f_{\\lambda}$ 的正规方程。我们可以将泛函写成矩阵-向量形式：\n$$\nJ_{\\lambda}(f) = (f - y)^{\\top}(f - y) + \\lambda (D_2 f)^{\\top}(D_2 f)\n$$\n展开各项，我们得到：\n$$\nJ_{\\lambda}(f) = f^{\\top}f - 2y^{\\top}f + y^{\\top}y + \\lambda f^{\\top}D_2^{\\top}D_2 f\n$$\n为了找到最小值，我们计算这个二次型关于 $f$ 的梯度并将其设为零。令 $L = D_2^{\\top}D_2$。矩阵 $L$ 是对称的。\n$$\n\\nabla_f J_{\\lambda}(f) = 2f - 2y + 2\\lambda L f\n$$\n将梯度设为零，得到最小值的必要条件：\n$$\n2f_{\\lambda} - 2y + 2\\lambda L f_{\\lambda} = 0\n$$\n$$\n(I + \\lambda L) f_{\\lambda} = y\n$$\n这证实了问题陈述中给出的正规方程。对于 $\\lambda  0$，矩阵 $(I + \\lambda L)$ 是对称正定的（因为 $I$ 是正定的，而 $L$ 是半正定的），从而保证了唯一解 $f_{\\lambda}$ 的存在。对于 $\\lambda = 0$ 的情况，方程变为 $I f_0 = y$，这意味着 $f_0 = y$。这对应于对含噪数据的原始插值，因为没有应用平滑。因此，解由 $f_{\\lambda} = (I + \\lambda L)^{-1} y$ 给出。我们将线性平滑算子定义为 $S_{\\lambda} = (I + \\lambda L)^{-1}$。\n\n对每个测试用例 $(N, \\lambda, \\sigma)$ 的计算步骤如下：\n\n1.  **网格和信号生成**：在区间 $[0, 1]$ 上创建一个包含 $N$ 个点的均匀网格，$x_i = i h$，其中 $i \\in \\{0, 1, \\dots, N-1\\}$，间距为 $h = 1/(N-1)$。计算真实信号向量 $f^{\\star} \\in \\mathbb{R}^N$，其分量为 $f^{\\star}_i = \\sin(2\\pi x_i) + \\frac{1}{2}\\cos(5\\pi x_i)$。\n\n2.  **噪声生成**：为每个唯一的 $(N, \\sigma)$ 对生成一个确定性的噪声向量 $\\epsilon \\in \\mathbb{R}^N$。这是通过将伪随机数生成器的种子设为 $0$，并从均值为 $0$、标准差为 $\\sigma$ 的高斯分布中抽取 $N$ 个样本来完成的。然后将含噪观测值合成为 $y = f^{\\star} + \\epsilon$。\n\n3.  **算子构建**：构建二阶差分矩阵 $D_2 \\in \\mathbb{R}^{(N-2) \\times N}$。对于每一行 $j \\in \\{0, \\dots, N-3\\}$，对应于列 $\\{j, j+1, j+2\\}$ 的条目分别设为 $1/h^2, -2/h^2, 1/h^2$，从而实现中心差分公式 $(f_{j} - 2f_{j+1} + f_{j+2})/h^2$。注意，问题陈述中的索引有轻微不匹配，$(D_2f)_{i-1}$ 对应 $i \\in \\{1, \\dots, N-2\\}$，这等同于使用列 $j, j+1, j+2$ 的 $(D_2f)_j$ 对应 $j \\in \\{0, \\dots, N-3\\}$。我们遵循了后者更清晰的构造方式。然后计算惩罚矩阵 $L \\in \\mathbb{R}^{N \\times N}$ 为 $L = D_2^{\\top}D_2$。\n\n4.  **平滑算子计算**：计算平滑算子 $S_{\\lambda} \\in \\mathbb{R}^{N \\times N}$。如果 $\\lambda = 0$，$S_0$ 是单位矩阵 $I$。如果 $\\lambda  0$，$S_{\\lambda}$ 通过对矩阵 $(I + \\lambda L)$ 求逆来计算。\n\n5.  **诊断指标计算**：使用生成的算子和向量计算三个诊断指标：\n    -   谱噪声放大率 $a_{\\mathrm{spec}}(\\lambda) = \\lVert D_2 S_{\\lambda} \\rVert_2$，是矩阵 $D_2 S_{\\lambda}$ 的诱导 $2$-范数（或谱范数）。它量化了输入扰动在估计曲率中的最坏情况放大率。\n    -   经验曲率放大率 $a_{\\mathrm{emp}}(\\lambda) = \\frac{\\lVert D_2 S_{\\lambda} \\epsilon \\rVert_2}{\\lVert \\epsilon \\rVert_2}$，衡量了针对生成的噪声实现 $\\epsilon$ 的特定放大因子。\n    -   均方误差 $\\mathrm{MSE}(\\lambda) = \\frac{1}{N} \\lVert f_{\\lambda} - f^{\\star} \\rVert_2^2$，量化了重建信号 $f_{\\lambda} = S_{\\lambda}y$ 相对于真实信号 $f^{\\star}$ 的准确性。\n\n对六个指定的测试用例中的每一个都执行这整个过程。$\\lambda=0$ 的情况展示了对含噪数据进行微分的不适定性，其特点是 $a_{\\mathrm{spec}}$ 和 $a_{\\mathrm{emp}}$ 的值很大。$\\lambda  0$ 的情况说明了平滑样条的正则化效应，它稳定了微分过程（降低了放大因子），但代价是在信号估计中引入了偏差，这种权衡反映在均方误差（MSE）中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes diagnostics for a discrete smoothing spline problem across several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, lambda, sigma)\n        (50, 0, 0.05),\n        (50, 0.01, 0.05),\n        (50, 0.1, 0.05),\n        (50, 1.0, 0.05),\n        (200, 0, 0.05),\n        (200, 0.1, 0.05),\n    ]\n\n    all_results = []\n    \n    # Cache for noise vectors to ensure the same realization is used for each (N, sigma) pair.\n    noise_cache = {}\n\n    for N, lam, sigma in test_cases:\n        # 1. Grid and Signal Generation\n        h = 1.0 / (N - 1)\n        x = np.linspace(0, 1, N)\n        f_star = np.sin(2 * np.pi * x) + 0.5 * np.cos(5 * np.pi * x)\n\n        # 2. Noise Generation (with caching)\n        if (N, sigma) in noise_cache:\n            epsilon = noise_cache[(N, sigma)]\n        else:\n            np.random.seed(0)\n            epsilon = sigma * np.random.randn(N)\n            noise_cache[(N, sigma)] = epsilon\n\n        # 3. Noisy Data\n        y = f_star + epsilon\n\n        # 4. Operator Construction\n        D2 = np.zeros((N - 2, N))\n        for i in range(N - 2):\n            D2[i, i:i+3] = [1.0, -2.0, 1.0]\n        D2 /= (h**2)\n        \n        I = np.identity(N)\n\n        # 5. Smoother Calculation\n        if lam == 0:\n            S_lambda = I\n        else:\n            L = D2.T @ D2\n            # The matrix to invert is I + lambda * L\n            matrix_to_invert = I + lam * L\n            S_lambda = np.linalg.inv(matrix_to_invert)\n\n        # 6. Diagnostic Computation\n        \n        # Spectral noise amplification\n        a_spec = np.linalg.norm(D2 @ S_lambda, 2)\n\n        # Empirical curvature amplification\n        # Use the pre-computed noise vector epsilon\n        norm_epsilon = np.linalg.norm(epsilon, 2)\n        # Handle the theoretical case of zero noise\n        if norm_epsilon  0:\n            a_emp = np.linalg.norm(D2 @ S_lambda @ epsilon, 2) / norm_epsilon\n        else:\n            a_emp = 0.0\n\n        # Mean Squared Error\n        f_lambda = S_lambda @ y\n        mse = np.mean((f_lambda - f_star)**2)\n\n        # Append formatted results for the current case\n        all_results.append([\n            f\"{a_spec:.6f}\",\n            f\"{a_emp:.6f}\",\n            f\"{mse:.6f}\"\n        ])\n\n    # Format the final output string as a list of lists.\n    output_str = \"[\" + \",\".join([f\"[{','.join(res)}]\" for res in all_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3286808"}]}