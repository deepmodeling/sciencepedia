{"hands_on_practices": [{"introduction": "理论与实践相结合是掌握数值精度的关键。当两个几乎相等的数相减时，会发生灾难性相消，导致有效数字的严重损失。本练习 [@problem_id:3273448] 将通过一个经典的例子 $f(x) = \\sqrt{x+1} - \\sqrt{x}$ 来探讨这个问题，并引导你使用一个简单的代数技巧来重写表达式，从而在不改变其数学意义的前提下，显著提高其在大型 $x$ 值下的数值稳定性。", "problem": "在数值分析中广泛接受的标准浮点运算模型中，对实数 $y$ 的每次基本运算会产生一个浮点结果 $\\operatorname{fl}(y)$，它满足 $\\operatorname{fl}(y) = y(1+\\delta)$，其中 $|\\delta| \\leq u$，$u$ 表示单位舍入误差。当两个几乎相等的数相减时，会发生有效位损失，因为每一项的独立舍入所引入的相对误差可能会主导微小的真实差值。\n\n考虑函数 $f(x) = \\sqrt{x+1} - \\sqrt{x}$，其中 $x$ 为一个较大的正数。仅使用基本代数恒等式和上述误差模型作为基础，推导出一个与 $f(x)$ 代数等价的表达式，该表达式可以避免当 $x$ 很大时因相减抵消而导致的有效位损失。你的推导过程必须清楚地说明为什么新表达式对舍入误差不那么敏感。请将最终表达式以关于 $x$ 的单一闭式解析函数形式给出。不需要进行数值近似或舍入。你的最终答案应该是一个关于 $x$ 的单一解析表达式。", "solution": "出发点是浮点误差模型 $\\operatorname{fl}(y) = y(1+\\delta)$，其中 $|\\delta| \\leq u$，以及一个观察：相减几乎相等的量会放大相对误差。对于函数 $f(x) = \\sqrt{x+1} - \\sqrt{x}$，当 $x$ 很大时，$\\sqrt{x+1}$ 和 $\\sqrt{x}$ 的值非常接近：具体来说，对于大的 $x$，有\n$$\n\\sqrt{x+1} \\approx \\sqrt{x} + \\frac{1}{2\\sqrt{x}},\n$$\n因此 $f(x)$ 是一个小量，数量级为 $\\frac{1}{2\\sqrt{x}}$，而每一项 $\\sqrt{x+1}$ 和 $\\sqrt{x}$ 的数量级均为 $\\sqrt{x}$。两个大的、几乎相等的项相减会得到一个很小的结果，这个结果很容易因为每一项的舍入而产生较大的相对误差。\n\n为了避免相减抵消，我们寻找一个不需要减去两个几乎相等的量的代数等价形式。一个适合此变换的基本恒等式是平方差恒等式：\n$$\n(a - b)(a + b) = a^{2} - b^{2}.\n$$\n设 $a = \\sqrt{x+1}$ 和 $b = \\sqrt{x}$。则\n$$\n(\\sqrt{x+1} - \\sqrt{x})(\\sqrt{x+1} + \\sqrt{x}) = (x+1) - x = 1.\n$$\n假设 $x > 0$，这样所有的平方根和加和项都是正数且非零，我们可以在等式两边同时除以 $\\sqrt{x+1} + \\sqrt{x}$ 得到\n$$\n\\sqrt{x+1} - \\sqrt{x} = \\frac{1}{\\sqrt{x+1} + \\sqrt{x}}.\n$$\n这个表达式与原始表达式代数等价，但避免了几乎相等的量相减。在浮点运算中，计算 $\\sqrt{x+1}$ 和 $\\sqrt{x}$ 仍然会引入最多为 $u$ 的微小相对误差，但计算 $\\sqrt{x+1} + \\sqrt{x}$ 是将两个正项相加，得到一个量级约为 $2\\sqrt{x}$ 的结果，这个计算是良态的。随后的倒数运算不会重新引入相消问题。\n\n为了证明其数值行为的改善，我们考虑浮点模型下的误差传播。令 $\\widehat{a} = \\operatorname{fl}(\\sqrt{x+1}) = \\sqrt{x+1}(1+\\delta_{1})$ 和 $\\widehat{b} = \\operatorname{fl}(\\sqrt{x}) = \\sqrt{x}(1+\\delta_{2})$，其中 $|\\delta_{1}|, |\\delta_{2}| \\leq u$。在使用相减形式时，计算出的差值为\n$$\n\\operatorname{fl}(\\widehat{a} - \\widehat{b}) \\approx (\\sqrt{x+1} - \\sqrt{x}) + \\sqrt{x+1}\\,\\delta_{1} - \\sqrt{x}\\,\\delta_{2},\n$$\n因此绝对误差的数量级为 $\\sqrt{x}\\,u$，而真实值的数量级为 $\\frac{1}{2\\sqrt{x}}$，这导致相对误差的数量级为 $2x u$，它会随着 $x$ 的增大而增大，并且当 $x$ 很大时可能会变得非常大。相反，在改写后的形式中，\n$$\nf(x) = \\frac{1}{\\sqrt{x+1} + \\sqrt{x}},\n$$\n计算得到的分母 $\\operatorname{fl}(\\widehat{a} + \\widehat{b})$ 的相对误差被 $u$ 的一个小数倍所界定，且分母本身的数量级为 $2\\sqrt{x}$，因此分母的绝对误差的数量级为 $\\sqrt{x}\\,u$。最终倒数的相对误差的数量级则为 $u$，与 $x$ 无关，这对于大的 $x$ 而言是数值稳定的。\n\n因此，数值稳定且代数等价的表达式是\n$$\n\\frac{1}{\\sqrt{x+1} + \\sqrt{x}}.\n$$", "answer": "$$\\boxed{\\frac{1}{\\sqrt{x+1}+\\sqrt{x}}}$$", "id": "3273448"}, {"introduction": "在掌握了基本的相消问题后，我们来探究一个更为广泛应用的场景：二次方程求根。二次方程求根公式是代数学的基石，但在浮点数运算中，当 $b^{2} \\gg 4 a c$ 时，它会因为灾难性相消而导致其中一个根的计算出现巨大误差。本练习 [@problem_id:3273565] 旨在让你亲手推导出一个数值稳定的替代公式，从而深刻理解即使是基础数学公式，在计算实现时也必须仔细考虑其数值特性。", "problem": "考虑在浮点运算中计算二次方程 $a x^{2} + b x + c = 0$ 的根，其中 $b^{2} \\gg 4 a c$。假设采用四舍五入的浮点模型，其中任何基本算术运算或初等函数求值返回 $\\operatorname{fl}(z) = z (1 + \\delta)$，且 $|\\delta| \\leq u$，其中 $u$（单位舍入）很小。在要求最终数值计算之前，请使用精确符号进行运算。\n\n1. 从二次方程求根公式和上述浮点模型出发，解释为什么当 $b > 0$ 且 $b^{2} \\gg 4 a c$ 时，直接计算根\n$$\nx_{\\mathrm{small}} = \\frac{-b + \\sqrt{b^{2} - 4 a c}}{2 a}\n$$\n容易受到灾难性抵消的影响。以 $u$ 和 $4ac/b^{2}$ 的主导阶来量化分子中的减法如何放大了相对误差。\n\n2. 提出变量替换 $y = 1/x$，推导 $y$ 满足的二次方程，并确定当 $b > 0$ 且 $b^{2} \\gg 4 a c$ 时，$y$ 的求根公式中哪种符号选择可以避免灾难性抵消。利用这一点，得到一个可以减轻抵消效应的 $x_{\\mathrm{small}}$ 的代数表达式，仅用 $a$、$b$ 和 $c$ 表示。\n\n3. 将你的表达式应用于具体系数 $a = 1$，$b = 2 \\times 10^{8}$ 和 $c = 3$，计算绝对值较小的根。将最终答案四舍五入到 8 位有效数字。只提供绝对值较小的根的数值作为最终答案。", "solution": "1. 灾难性抵消分析\n\n我们被要求在条件 $b > 0$ 和 $b^{2} \\gg 4 a c$ 下，分析二次方程 $a x^{2} + b x + c = 0$ 的根 $x_{\\mathrm{small}} = \\frac{-b + \\sqrt{b^{2} - 4 a c}}{2 a}$ 的计算。条件 $b^{2} \\gg 4 a c$ 意味着项 $4ac$ 与 $b^2$ 相比非常小。\n\n让我们使用泰勒展开来分析项 $\\sqrt{b^{2} - 4 a c}$。我们可以从平方根中提出 $b^2$：\n$$\n\\sqrt{b^{2} - 4 a c} = \\sqrt{b^2 \\left(1 - \\frac{4ac}{b^2}\\right)} = |b|\\left(1 - \\frac{4ac}{b^2}\\right)^{1/2}\n$$\n由于 $b>0$，所以 $|b|=b$。设 $\\epsilon = \\frac{4ac}{b^2}$。条件 $b^2 \\gg 4ac$ 意味着 $|\\epsilon| \\ll 1$。对于小的 $z$，使用二项式近似 $(1-z)^{1/2} \\approx 1 - \\frac{1}{2}z$，我们得到：\n$$\n\\sqrt{b^{2} - 4 a c} \\approx b\\left(1 - \\frac{1}{2}\\frac{4ac}{b^2}\\right) = b\\left(1 - \\frac{2ac}{b^2}\\right) = b - \\frac{2ac}{b}\n$$\n$x_{\\mathrm{small}}$ 的分子是 $-b + \\sqrt{b^{2} - 4ac}$。代入近似值，我们看到：\n$$\n-b + \\sqrt{b^{2} - 4ac} \\approx -b + \\left(b - \\frac{2ac}{b}\\right) = -\\frac{2ac}{b}\n$$\n这表明分子是两个几乎相等的量相减的结果：$-b$ 和 $\\sqrt{b^{2} - 4ac} \\approx b$。这种情况被称为灾难性抵消。在浮点运算中，当两个几乎相等的数相减时，结果可能会有很大的相对误差，因为主要的有效数字被抵消掉了，留下的结果主要由原始数字中较不重要且可能错误的数字决定。\n\n为了量化误差放大，我们使用给定的浮点模型 $\\operatorname{fl}(z) = z(1+\\delta)$，其中 $|\\delta| \\leq u$。设 $d = \\sqrt{b^2-4ac}$。平方根的计算值为 $\\hat{d} = \\operatorname{fl}(d) = d(1+\\delta_1)$，其中某个 $|\\delta_1| \\leq u$。随后的减法计算为 $\\hat{N} = \\operatorname{fl}(-b + \\hat{d}) = (-b + \\hat{d})(1+\\delta_2)$，其中某个 $|\\delta_2| \\leq u$。我们假设 $b$ 被精确表示。\n\n精确的分子是 $N = -b+d$。计算出的分子是：\n$$\n\\hat{N} = (-b + d(1+\\delta_1))(1+\\delta_2) = (-b+d + d\\delta_1)(1+\\delta_2) = (N + d\\delta_1)(1+\\delta_2)\n$$\n展开并只保留 $\\delta_i$ 的一阶项：\n$$\n\\hat{N} \\approx N + d\\delta_1 + N\\delta_2\n$$\n分子的绝对误差是 $\\hat{N}-N \\approx d\\delta_1 + N\\delta_2$。相对误差是：\n$$\n\\frac{\\hat{N}-N}{N} \\approx \\frac{d\\delta_1}{N} + \\delta_2\n$$\n我们已经确定 $d \\approx b$ 和 $N \\approx -2ac/b$。将这些近似值代入相对误差表达式：\n$$\n\\frac{\\hat{N}-N}{N} \\approx \\frac{b}{-2ac/b}\\delta_1 + \\delta_2 = -\\frac{b^2}{2ac}\\delta_1 + \\delta_2\n$$\n来自平方根计算的相对误差 $\\delta_1$ 被放大了因子 $-\\frac{b^2}{2ac}$。设 $\\epsilon = \\frac{4ac}{b^2}$，这个因子就是 $-\\frac{2}{\\epsilon}$。由于 $\\epsilon$ 很小，放大因子非常大。这证实了在给定条件下，直接计算 $x_{\\mathrm{small}}$ 的公式是数值不稳定的。\n\n2. 推导稳定公式\n\n为了找到一个稳定的公式，我们进行变量替换 $y = 1/x$。将 $x=1/y$ 代入二次方程 $ax^2 + bx + c = 0$（假设 $x\\neq 0$，如果 $c\\neq 0$ 则该假设成立）：\n$$\na\\left(\\frac{1}{y}\\right)^2 + b\\left(\\frac{1}{y}\\right) + c = 0\n$$\n将整个方程乘以 $y^2$（假设 $y \\ne 0$）得到关于 $y$ 的二次方程：\n$$\nc y^{2} + b y + a = 0\n$$\n这个关于 $y$ 的方程的根由二次方程求根公式给出：\n$$\ny = \\frac{-b \\pm \\sqrt{b^{2} - 4ca}}{2c}\n$$\n$y$ 方程的根，比如说 $y_1$ 和 $y_2$，是原始 $x$ 方程的根 $x_1$ 和 $x_2$ 的倒数。我们感兴趣的根是 $x_{\\mathrm{small}}$，即绝对值较小的根。它的倒数 $y_{\\mathrm{large}} = 1/x_{\\mathrm{small}}$ 将是绝对值较大的根。\n\n我们需要在 $y$ 的公式中选择一个符号，使其对应于绝对值较大的根并且数值稳定。分子的两种选择是 $-b + \\sqrt{b^2-4ac}$ 和 $-b - \\sqrt{b^2-4ac}$。鉴于 $b>0$ 且 $\\sqrt{b^2-4ac} \\approx b > 0$，第一种选择涉及两个几乎相等的数相减（不稳定），而第二种选择 $-b - \\sqrt{b^2-4ac}$ 涉及两个负数相加。这个和是数值稳定的，因为没有主要数字的抵消。\n\n因此，我们选择减号来稳定地计算 $y$ 的一个根：\n$$\ny_{\\mathrm{stable}} = \\frac{-b - \\sqrt{b^{2} - 4ac}}{2c}\n$$\n由于（对于 $b>0$）分子是两个大的负项之和，这将是绝对值较大的根。因此，$y_{\\mathrm{stable}} = y_{\\mathrm{large}} = 1/x_{\\mathrm{small}}$。\n\n现在我们可以通过取倒数来找到所需的 $x_{\\mathrm{small}}$ 的稳定表达式：\n$$\nx_{\\mathrm{small}} = \\frac{1}{y_{\\mathrm{stable}}} = \\frac{2c}{-b - \\sqrt{b^{2} - 4ac}}\n$$\n这个公式避免了灾难性抵消，因为分母涉及两个同号数的加法。这在代数上等价于 $x_{\\mathrm{small}}$ 的原始公式，可以通过将原始公式的分子和分母乘以其共轭项 $-b - \\sqrt{b^2 - 4ac}$ 来证明。\n\n3. 数值应用\n\n我们给定的系数是 $a=1$，$b=2 \\times 10^8$ 和 $c=3$。条件 $b>0$ 得到满足。我们检查 $b^2 \\gg 4ac$：$b^2 = (2 \\times 10^8)^2 = 4 \\times 10^{16}$ 并且 $4ac = 4(1)(3)=12$。确实，$4 \\times 10^{16} \\gg 12$。\n\n我们必须使用数值稳定的公式来计算绝对值较小的根 $x_{\\mathrm{small}}$：\n$$\nx_{\\mathrm{small}} = \\frac{2c}{-b - \\sqrt{b^{2} - 4ac}}\n$$\n代入给定值：\n$$\nx_{\\mathrm{small}} = \\frac{2(3)}{-(2 \\times 10^{8}) - \\sqrt{(2 \\times 10^{8})^{2} - 4(1)(3)}} = \\frac{6}{-2 \\times 10^8 - \\sqrt{4 \\times 10^{16} - 12}}\n$$\n使用标准的双精度计算器直接计算可能会失败，因为 $\\operatorname{fl}(4 \\times 10^{16} - 12)$ 可能会计算为 $4 \\times 10^{16}$，导致分子为 $-b+b=0$。然而，使用稳定公式：\n分母约等于 $-2 \\times 10^8 - \\sqrt{4 \\times 10^{16}} = -2 \\times 10^8 - 2 \\times 10^8 = -4 \\times 10^8$。\n所以，$x_{\\mathrm{small}} \\approx \\frac{6}{-4 \\times 10^8} = -1.5 \\times 10^{-8}$。\n\n为了得到 8 位有效数字的结果，需要进行高精度计算。\n$$\nx_{\\mathrm{small}} = \\frac{6}{-200000000 - \\sqrt{39999999999999988}}\n$$\n计算此表达式得出：\n$$\nx_{\\mathrm{small}} \\approx -1.500000000000000075 \\times 10^{-8}\n$$\n将此值四舍五入到 8 位有效数字，得到：\n$$\nx_{\\mathrm{small}} \\approx -1.5000000 \\times 10^{-8}\n$$\n第一位有效数字是 $1$，第二位是 $5$，接下来的六位都是 $0$。第九位有效数字是 $0$，所以不需要向上舍入。", "answer": "$$\\boxed{-1.5000000 \\times 10^{-8}}$$", "id": "3273565"}, {"introduction": "现在，我们将数值稳定性的概念从代数公式扩展到实际的数据分析算法中。方差是统计学中的一个核心度量，但其计算方法对数值误差的敏感性差异巨大。本练习 [@problem_id:3273473] 要求你通过编程，实证对比两种不同的方差计算公式：一种是看似高效的“单遍”算法，另一种是更为稳健的“两遍”算法。通过处理精心设计的数据集，你将直观地看到不稳定的算法如何在实践中导致灾难性的精度损失，从而体会到算法选择在科学计算中的至关重要性。", "problem": "考虑在浮点运算中从有限数据集计算总体方差。总体方差的基本定义为 $$\\mathrm{Var}(x) = \\frac{1}{n}\\sum_{i=1}^{n}\\left(x_i - \\mu\\right)^2,\\quad \\mu = \\frac{1}{n}\\sum_{i=1}^{n}x_i,$$ 其中 $n$ 是数据点的数量。在遵循 IEEE 754 标准（电子电气工程师协会 754）的 binary64 格式（通常称为双精度）的浮点运算中，每个基本运算被建模为 $$\\mathrm{fl}(a \\circ b) = (a \\circ b)(1+\\delta),\\quad |\\delta| \\le u,$$ 其中 $u$ 是单位舍入误差。对于就近舍入，$u = 2^{-53}$。\n\n你的任务是编写一个完整的程序，当数据集具有较大的位置偏移和较小的离散度时，经验性地分析方差计算中的有效位丢失问题。具体要求如下：\n\n1) 在 binary64 运算中实现两种方差计算方法：\n   - 一种两遍扫描的“基于定义”的计算方法，直接计算 $$\\mathrm{Var}(x) = \\frac{1}{n}\\sum_{i=1}^{n}\\left(x_i - \\mu\\right)^2,$$ 其中 $\\mu$ 在第一遍扫描中计算，离差平方和在第二遍扫描中计算。\n   - 一种单遍扫描计算方法，在单次遍历中仅累加 $x_i$ 和 $x_i^2$ 的和，然后使用标准实数代数从这两个和构造代数上等价的总体方差。除了这次单次遍历和最终的代数组合之外，不要使用补偿求和或任何多遍扫描校正。\n\n2) 使用以下确定性数据集测试套件。对于每个测试，通过选择一个整数模式 $k_i \\in \\{-1,0,+1\\}$（每个值的数量相等，以使 $\\sum_{i=1}^{n} k_i = 0$）来构造 $x_i$，然后设置 $$x_i = M + d\\,k_i.$$ 具体地，取前 $n/3$ 个条目使 $k_i = -1$，接下来的 $n/3$ 个条目使 $k_i = 0$，最后的 $n/3$ 个条目使 $k_i = +1$。这在实数运算中得到的精确总体方差等于 $$V_{\\mathrm{true}} = \\mathbb{E}[d^2 k^2] = \\frac{2}{3}\\,d^2.$$\n\n   使用以下四个测试用例（每个用例的 $n$ 都能被 $3$ 整除）：\n   - 测试 A: $n = 6000$, $M = 0$, $d = 10^{-3}$。\n   - 测试 B: $n = 6000$, $M = 10^{6}$, $d = 1$。\n   - 测试 C: $n = 6000$, $M = 10^{12}$, $d = 1$。\n   - 测试 D: $n = 6000$, $M = 10^{16}$, $d = 1$。\n\n3) 对于每个测试用例，计算：\n   - 如上所述的朴素单遍扫描方差值 $V_{\\mathrm{naive}}$。\n   - 如上所述的两遍扫描方差值 $V_{\\mathrm{2pass}}$。\n   - 朴素方法相对于精确实数值方差 $V_{\\mathrm{true}}$ 的相对误差： $$\\varepsilon_{\\mathrm{rel}} = \\frac{|V_{\\mathrm{naive}} - V_{\\mathrm{true}}|}{V_{\\mathrm{true}}}.$$\n   - 朴素方法达到的正确有效位数，定义为 $$D_{\\mathrm{ach}} = \\max\\left(0,\\;\\min\\left(-\\log_{10}(\\varepsilon_{\\mathrm{rel}}),\\;-\\log_{10}(u)\\right)\\right),$$ 其中，以 $-\\log_{10}(u)$ 为上限反映了 binary64 运算中可能达到的最佳位数。\n   - 基于对消分析，对朴素方法保留的正确有效位数的第一性原理预测。当 $|M| \\gg |d|$ 时，朴素公式将两个数量级为 $\\Theta(n M^2)$ 的相近大数相减，以获得一个数量级为 $\\Theta(n d^2)$ 的结果，因此一个粗略模型给出 $$\\varepsilon_{\\mathrm{rel}} \\approx C\\,u\\left(\\frac{M}{d}\\right)^2,$$ 其中 $C$ 是某个数量级为 1 的、依赖于问题的常数。通过忽略 $C$ 并以 $-\\log_{10}(u)$ 设置上限，可将其转换为位数预测： $$D_{\\mathrm{pred}} = \\max\\left(0,\\;\\min\\left(-\\log_{10}(u) - 2\\log_{10}\\left(\\frac{|M|}{|d|}\\right),\\;-\\log_{10}(u)\\right)\\right),$$ 并约定如果 $M = 0$，则 $D_{\\mathrm{pred}} = -\\log_{10}(u)$。\n\n4) 最终输出格式。你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个测试用例贡献一个按 $[\\varepsilon_{\\mathrm{rel}}, D_{\\mathrm{ach}}, D_{\\mathrm{pred}}]$ 顺序排列的方括号三元组。因此，完整的输出是形如\n   $$[[e_A, dA_{\\mathrm{ach}}, dA_{\\mathrm{pred}}],[e_B, dB_{\\mathrm{ach}}, dB_{\\mathrm{pred}}],[e_C, dC_{\\mathrm{ach}}, dC_{\\mathrm{pred}}],[e_D, dD_{\\mathrm{ach}}, dD_{\\mathrm{pred}}]].$$\n\n约束和说明：\n- 仅使用 binary64 运算；不要使用扩展精度、任意精度、补偿求和或随机舍入。\n- 所有答案都是没有物理单位的纯数。\n- 不涉及角度。\n- 输出必须是严格一行的指定方括号列表格式，且不含空格。", "solution": "一个数据集 $\\{x_i\\}_{i=1}^{n}$ 的总体方差定义为各项与总体均值 $\\mu$ 的离差平方的均值：\n$$\n\\mathrm{Var}(x) = \\frac{1}{n}\\sum_{i=1}^{n}\\left(x_i - \\mu\\right)^2, \\quad \\text{where} \\quad \\mu = \\frac{1}{n}\\sum_{i=1}^{n}x_i\n$$\n\n我们被要求实现并比较两种计算方法：\n\n$1$. **两遍扫描算法 (Two-Pass Algorithm):** 该方法直接根据定义实现。\n    - **第一遍扫描:** 计算均值 $\\mu = \\frac{1}{n}\\sum_{i=1}^{n}x_i$。\n    - **第二遍扫描:** 使用预先计算的均值计算差的平方和，得到 $\\mathrm{Var}_{\\mathrm{2pass}}(x) = \\frac{1}{n}\\sum_{i=1}^{n}(x_i - \\mu)^2$。\n    该算法通常是数值稳定的。通过先计算均值再计算离差，它在求平方之前将数据中心化到 $0$ 附近。这可以防止在原始数据 $x_i$ 远离原点时，中间量 $(x_i - \\mu)^2$ 变得过大，从而保持精度。\n\n$2$. **朴素单遍扫描算法 (Naive Single-Pass Algorithm):** 该方法使用一个代数等价公式，推导如下：\n$$\n\\mathrm{Var}(x) = \\mathbb{E}[(x-\\mu)^2] = \\mathbb{E}[x^2 - 2x\\mu + \\mu^2] = \\mathbb{E}[x^2] - 2\\mu\\mathbb{E}[x] + \\mu^2 = \\mathbb{E}[x^2] - 2\\mu^2 + \\mu^2 = \\mathbb{E}[x^2] - \\mu^2\n$$\n用求和形式表示，即为：\n$$\n\\mathrm{Var}_{\\mathrm{naive}}(x) = \\left(\\frac{1}{n}\\sum_{i=1}^{n}x_i^2\\right) - \\left(\\frac{1}{n}\\sum_{i=1}^{n}x_i\\right)^2\n$$\n这允许通过同时累加 $\\sum x_i$ 和 $\\sum x_i^2$ 来在单遍扫描中计算方差。然而，如果标准差远小于均值，该方法是数值不稳定的。如果数据点 $x_i$ 都聚集在远离原点的地方，即对于一个大的 $M$ 有 $x_i \\approx M$，那么 $\\mathbb{E}[x^2] \\approx M^2$ 且 $\\mu^2 \\approx M^2$。该公式涉及到两个相近大数的相减，这个操作被称为 **灾难性抵消**，会导致严重的精度损失。\n\n该问题定义了一个特定的测试套件来展示这种效应。数据集构造为 $x_i = M + d\\,k_i$，其中 $n$ 是总点数，对于每个 $k_i \\in \\{-1, 0, +1\\}$ 都有 $n/3$ 个点。\n对于这种数据集结构，实数运算中的精确均值为：\n$$\n\\mu = \\mathbb{E}[M+d k] = M + d\\,\\mathbb{E}[k] = M + d\\left(\\frac{1}{3}(-1) + \\frac{1}{3}(0) + \\frac{1}{3}(+1)\\right) = M\n$$\n实数运算中的精确总体方差 $V_{\\mathrm{true}}$ 为：\n$$\nV_{\\mathrm{true}} = \\mathrm{Var}(x) = \\mathbb{E}[(x-\\mu)^2] = \\mathbb{E}[((M+dk) - M)^2] = \\mathbb{E}[(dk)^2] = d^2\\mathbb{E}[k^2]\n$$\n$k^2$ 的期望为：\n$$\n\\mathbb{E}[k^2] = \\frac{1}{3}(-1)^2 + \\frac{1}{3}(0)^2 + \\frac{1}{3}(+1)^2 = \\frac{1}{3} + 0 + \\frac{1}{3} = \\frac{2}{3}\n$$\n因此，所有测试用例的精确方差均为 $V_{\\mathrm{true}} = \\frac{2}{3}d^2$。\n\n这四个测试用例旨在改变比率 $|M/d|$：\n-   测试 A: $n = 6000$, $M = 0$, $d = 10^{-3}$。此处 $|M/d| = 0$。\n-   测试 B: $n = 6000$, $M = 10^{6}$, $d = 1$。此处 $|M/d| = 10^6$。\n-   测试 C: $n = 6000$, $M = 10^{12}$, $d = 1$。此处 $|M/d| = 10^{12}$。\n-   测试 D: $n = 6000$, $M = 10^{16}$, $d = 1$。此处 $|M/d| = 10^{16}$。\n\n对于每个测试，我们将为朴素方法计算以下量：\n$1$. 相对误差 $\\varepsilon_{\\mathrm{rel}} = \\frac{|V_{\\mathrm{naive}} - V_{\\mathrm{true}}|}{V_{\\mathrm{true}}}$。\n$2$. 达到的有效位数 $D_{\\mathrm{ach}} = \\max\\left(0,\\;\\min\\left(-\\log_{10}(\\varepsilon_{\\mathrm{rel}}),\\;-\\log_{10}(u)\\right)\\right)$。这个值量化了实际精度，其上限为 binary64 运算的理论最大精度，其中 $u = 2^{-53}$ 是单位舍入误差，且 $-\\log_{10}(u) \\approx 15.95$。\n$3$. 预测的有效位数 $D_{\\mathrm{pred}}$。这基于对灾难性抵消的一阶误差分析，该分析表明相对误差按 $\\varepsilon_{\\mathrm{rel}} \\propto u(M/d)^2$ 增长。忽略比例常数，丢失的位数约为 $2\\log_{10}(|M/d|)$。因此，预测值由 $D_{\\mathrm{pred}} = \\max\\left(0,\\;\\min\\left(-\\log_{10}(u) - 2\\log_{10}\\left(\\frac{|M|}{|d|}\\right),\\;-\\log_{10}(u)\\right)\\right)$ 给出。对于 $M=0$ 的情况，不会发生抵消，预测的位数为最大值 $-\\log_{10}(u)$。\n\n程序将遍历四个测试用例，为每个用例构建数据集，计算 $V_{\\mathrm{naive}}$，然后计算元组 $(\\varepsilon_{\\mathrm{rel}}, D_{\\mathrm{ach}}, D_{\\mathrm{pred}})$。最终输出将是这些元组的列表。\n正如预期的，结果将显示，对于测试 A（$M=0$），朴素方法是高度精确的。对于测试 B、C 和 D，随着比率 $|M/d|$ 的增加，灾难性抵消变得更加严重，导致相对误差急剧增加，以及相应的正确有效位数减少，且达到的位数与理论预测紧密匹配。测试 C 和 D 可能会导致有效位数完全丢失。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef naive_variance(x: np.ndarray) -> float:\n    \"\"\"\n    Computes variance using the unstable single-pass algorithm.\n    Var(x) = E[x^2] - (E[x])^2\n    \"\"\"\n    n = len(x)\n    sum_x = np.sum(x)\n    sum_x_sq = np.sum(x * x)\n    # Using float64 for all calculations to emulate binary64\n    mean_of_squares = sum_x_sq / n\n    square_of_mean = (sum_x / n)**2\n    return mean_of_squares - square_of_mean\n\ndef two_pass_variance(x: np.ndarray) -> float:\n    \"\"\"\n    Computes variance using the stable two-pass algorithm.\n    Var(x) = E[(x - E[x])^2]\n    \"\"\"\n    n = len(x)\n    # Pass 1: compute the mean\n    mu = np.sum(x) / n\n    # Pass 2: compute the sum of squared deviations\n    sum_sq_dev = np.sum((x - mu)**2)\n    return sum_sq_dev / n\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis and produce the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (n, M, d).\n    test_cases = [\n        (6000, 0.0, 1e-3),\n        (6000, 1e6, 1.0),\n        (6000, 1e12, 1.0),\n        (6000, 1e16, 1.0),\n    ]\n\n    # Unit roundoff for binary64 (double precision)\n    u = 2**-53\n    log10_u = np.log10(u)\n    \n    results = []\n    \n    for n, M, d in test_cases:\n        # 1. Construct the dataset x_i = M + d*k_i\n        n_div_3 = n // 3\n        # Ensure data is float64 (binary64)\n        x = np.concatenate([\n            np.full(n_div_3, M - d, dtype=np.float64),\n            np.full(n_div_3, M, dtype=np.float64),\n            np.full(n_div_3, M + d, dtype=np.float64),\n        ])\n\n        # 2. Compute true variance, V_naive, and V_2pass\n        V_true = (2.0 / 3.0) * d**2\n        V_naive = naive_variance(x)\n        # V_2pass is computed as required by the problem description,\n        # though not used in the final output values. It serves as a\n        # demonstration of a stable algorithm.\n        V_2pass = two_pass_variance(x)\n\n        # 3. Compute relative error of the naive method\n        # Handle the case where V_true is zero (not in this problem)\n        if V_true == 0.0:\n            epsilon_rel = 0.0 if V_naive == 0.0 else np.inf\n        else:\n            epsilon_rel = np.abs(V_naive - V_true) / V_true\n\n        # 4. Compute achieved significant digits\n        # Handle epsilon_rel = 0 to avoid log10(0)\n        if epsilon_rel == 0.0:\n            d_achieved = -log10_u\n        else:\n            d_achieved = np.max([0.0, np.min([-np.log10(epsilon_rel), -log10_u])])\n\n        # 5. Compute predicted significant digits\n        if M == 0.0:\n            d_predicted = -log10_u\n        else:\n            # Note: np.abs is used just in case of negative M or d.\n            log10_ratio = np.log10(np.abs(M) / np.abs(d))\n            pred_val = -log10_u - 2.0 * log10_ratio\n            d_predicted = np.max([0.0, np.min([pred_val, -log10_u])])\n        \n        results.append([epsilon_rel, d_achieved, d_predicted])\n\n    # Final print statement in the exact required format.\n    # Build the string representation manually to avoid spaces.\n    formatted_results = []\n    for res in results:\n        # e.g., res is [1.0, 2.0, 3.0]\n        # creates string \"[1.0,2.0,3.0]\"\n        formatted_results.append(f\"[{res[0]},{res[1]},{res[2]}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3273473"}]}