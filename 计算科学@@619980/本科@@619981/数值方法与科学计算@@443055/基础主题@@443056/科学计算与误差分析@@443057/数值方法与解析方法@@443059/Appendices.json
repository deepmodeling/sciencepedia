{"hands_on_practices": [{"introduction": "许多看似简单的方程，例如 $x = \\cos(x)$，实际上无法用标准的初等函数求得精确的解析解。这类超越方程凸显了分析方法的局限性，并为我们引入了功能强大的数值方法。在本实践中 [@problem_id:3259287]，我们将通过不动点迭代法来近似求解这个方程，并运用压缩映射定理从理论上证明解的存在性和唯一性，从而深刻体会数值方法在解决此类问题时的必要性与严谨性。", "problem": "考虑寻找一个实数 $x^{\\ast}$ 的不动点问题，该实数满足 $x^{\\ast} = \\cos(x^{\\ast})$，其中 $\\cos(\\cdot)$ 表示余弦函数，其参数以弧度为单位。您的任务是分析符号方法的局限性，使用第一性原理证明不动点的存在性和唯一性，并实现一个数值方法来对其进行近似，同时提供严格的后验误差界，所有这些都应以可由程序测试的方式进行。\n\n1. 解析局限性。解释为什么我们不期望也不在此处使用一个用于求解 $x = \\cos(x)$ 的符号初等闭式表达式。您应明确指出这是一个超越不动点方程，并以适合高年级本科生的高层次水平，论证为什么在初等函数范围内的代数操作无法得出 $x^{\\ast}$ 的显式公式。\n\n2. 通过压缩映射证明存在性和唯一性。令 $g(x) = \\cos(x)$。仅使用基本定义和经过充分检验的事实，证明 $g$ 在一个在 $g$ 作用下不变的闭区间内有唯一的不动点。具体而言：\n   - 确定一个闭区间 $I \\subset \\mathbb{R}$，使得 $g(I) \\subset I$。\n   - 在 $I$ 上为导数 $g'(x)$ 定界，以获得一个满足 $0 \\le L < 1$ 的利普希茨常数 $L$。\n   - 根据巴拿赫不动点定理（也称为压缩映射定理），得出结论：存在一个唯一的不动点 $x^{\\ast} \\in I$。\n\n3. 数值迭代与停止规则。考虑由 $x_{n+1} = g(x_n) = \\cos(x_n)$ 定义的简单不动点迭代，初始猜测值为 $x_0 \\in \\mathbb{R}$。设计一个仅基于连续迭代值的停止规则：\n   - 在第一个满足 $\\lvert x_{n+1} - x_n \\rvert \\le \\text{tol}$ 的索引 $n \\ge 0$ 处停止，其中 $\\text{tol} > 0$ 是用户指定的容差。\n   - 设置一个硬性迭代上限 $\\text{max\\_iter} \\in \\mathbb{N}$；如果到 $n = \\text{max\\_iter}$ 时仍未满足停止条件，则报告未收敛。\n\n4. 后验误差界。假设您的迭代值位于区间 $I$ 内，在该区间上 $g$ 是一个利普希茨常数为 $L$（满足 $0 \\le L < 1$）的压缩映射。推导并使用标准的后验误差界\n   $$\\lvert x_{n+1} - x^{\\ast} \\rvert \\le \\frac{L}{1 - L} \\lvert x_{n+1} - x_n \\rvert,$$\n   该界必须在最后一次可用的迭代中计算，无论停止规则是否已满足。您的程序应使用 $L = \\sin(1)$，这对应于在不变区间 $I = [-1, 1]$ 上的压缩分析。\n\n5. 单位。角度必须以弧度为单位。不涉及其他物理单位。\n\n6. 测试套件。您的程序必须在以下测试用例上运行该方法，每个用例由一个三元组 $(x_0, \\text{tol}, \\text{max\\_iter})$ 指定：\n   - 用例 A（理想路径）：$(0, 10^{-12}, 100)$，即 $x_0 = 0$，$\\text{tol} = 10^{-12}$，$\\text{max\\_iter} = 100$。\n   - 用例 B（不变集内的不同起始点）：$(1, 10^{-12}, 100)$。\n   - 用例 C（远离不变集的起始点，快速进入）：$(10, 10^{-12}, 100)$。\n   - 用例 D（边界条件：迭代次数不足）：$(0.5, 10^{-16}, 5)$。\n\n7. 要求的最终输出格式。对于每个测试用例，输出一个包含四项的列表：\n   - 在终止时（当满足停止规则或达到迭代上限时）$x^{\\ast}$ 的数值近似值。\n   - 执行的迭代次数。\n   - 一个布尔值，指示停止规则是否在迭代上限内被满足。\n   - 在最后一次可用迭代中计算的后验误差界 $\\dfrac{L}{1-L} \\lvert x_{n+1} - x_n \\rvert$，使用 $L = \\sin(1)$。\n\n   您的程序应生成单行输出，其中包含所有四个用例的结果，形式为一个用方括号括起来的逗号分隔列表，例如\n   $[ \\text{caseA\\_result}, \\text{caseB\\_result}, \\text{caseC\\_result}, \\text{caseD\\_result} ]$，\n   其中每个 $\\text{caseX\\_result}$ 本身就是一个列表 $[x\\_{\\text{approx}}, \\text{iterations}, \\text{converged}, \\text{bound}]$。\n\n8. 数值报告。每个用例中的两个浮点输出，即 $x^{\\ast}$ 的近似值和后验误差界，在打印前必须四舍五入到12位小数。迭代计数必须是整数，收敛标志必须是布尔值。\n\n所有角度都必须以弧度为单位，所有数值都应是无量纲的。任何地方都不得使用百分号；任何比率如果需要都应表示为小数。最终输出必须是严格符合指定格式的单行。", "solution": "问题陈述是数值分析中的一个有效练习。它要求对余弦函数的不动点 $x^{\\ast} = \\cos(x^{\\ast})$ 进行理论论证和数值近似。该问题有科学依据、是良定的、客观的，并包含了完整解答所需的所有信息。\n\n### 1. 解析局限性\n\n待解方程为 $x = \\cos(x)$。这是一个超越方程，因为它将一个多项式函数 $f(x)=x$ 与一个超越函数 $g(x) = \\cos(x)$ 相等。一个“初等闭式”解意味着使用算术运算、根式、指数、对数和三角函数的有限组合来表示不动点 $x^{\\ast}$。\n\n没有通用的代数程序来求解此类方程。对多项式方程有效的代数操作依赖于逆运算（例如，通过取平方根来反转 $x^2$）。余弦函数没有可以用来从表达式 $\\cos(x)$ 中分离出 $x$ 的初等反函数。虽然其反函数 $\\arccos(y)$ 存在，但将其应用于方程 $x = \\cos(x)$ 会得到 $\\arccos(x) = \\arccos(\\cos(x))$，这会导出诸如 $\\arccos(x) = x$ 或 $\\arccos(x) = -x + 2k\\pi$（其中 $k$ 为整数）之类的恒等式，而这些恒等式本身就是新的超越方程，并不能分离出 $x$。\n\n无法找到闭式解是与初等函数域的代数结构相关的深刻性质。证明不存在这样的解是一项非平凡的任务（与林德曼-魏尔斯特拉斯定理或微分伽罗瓦理论等结果相关，这些已超出此处的范围），但一个标准的结论是，混合了代数项和超越项的方程，如 $x = \\cos(x)$，通常没有可以用标准初等函数表示的解。因此，必须求助于数值方法来获得解的近似值。\n\n### 2. 通过巴拿赫不动点定理证明存在性和唯一性\n\n巴拿赫不动点定理（或压缩映射定理）为证明不动点的存在性和唯一性提供了一个强大的工具。该定理指出，如果一个函数 $g$ 将一个完备度量空间 $(X, d)$ 映射到其自身，并且是一个压缩映射，那么 $g$ 在 $X$ 中有唯一的不动点。\n\n设函数为 $g(x) = \\cos(x)$，空间为一个闭区间 $I \\subset \\mathbb{R}$，其度量为标准欧几里得度量 $d(x, y) = |x - y|$。$\\mathbb{R}$ 中的闭区间是一个完备度量空间。我们必须执行两个步骤：\n\n**步骤 2a：确定一个不变区间 $I$**\n\n我们需要找到一个闭区间 $I$，使得对于任何 $x \\in I$，值 $g(x)$ 也在 $I$ 中；即 $g(I) \\subset I$。对于任何实数输入，余弦函数的值域是 $[-1, 1]$。因此，对于任何 $x \\in \\mathbb{R}$，$g(x) = \\cos(x) \\in [-1, 1]$。如果我们选择区间 $I = [-1, 1]$，那么对于任何 $x \\in I$，$g(x) = \\cos(x)$ 保证在 $[-1, 1]$ 内。因此，$g([-1, 1]) \\subset [-1, 1]$，并且 $I = [-1, 1]$ 是 $g$ 的一个不变集。\n\n**步骤 2b：证明 $g$ 在 $I$ 上是一个压缩映射**\n\n如果存在一个利普希茨常数 $L$ 满足 $0 \\le L < 1$，并且对于所有 $x, y \\in I$，都有 $|g(x) - g(y)| \\le L|x - y|$，那么函数 $g$ 在 $I$ 上是一个压缩映射。\n\n根据中值定理，对于任意 $x, y \\in I$，在 $x$ 和 $y$ 之间存在一点 $c$，使得 $|g(x) - g(y)| = |g'(c)||x - y|$。为了找到最小可能的利普希茨常数，我们必须找到 $|g'(x)|$ 在 $I$ 上的最大值。\n\n$g(x)$ 的导数是 $g'(x) = -\\sin(x)$。在区间 $I = [-1, 1]$ 上，我们需要为 $|g'(x)| = |-\\sin(x)| = |\\sin(x)|$ 定界。函数 $|\\sin(x)|$ 是偶函数，并且在 $[0, 1]$ 上是递增的。因此，它在 $[-1, 1]$ 上的最大值出现在端点 $x = -1$ 和 $x = 1$ 处。最大值是 $L = \\sup_{x \\in [-1, 1]} |\\sin(x)| = \\sin(1)$。\n\n在数值上，$L = \\sin(1) \\approx 0.84147$。因为 $0 < 1 < \\pi/2$，我们知道 $0 < \\sin(1) < \\sin(\\pi/2) = 1$。因此，我们找到了一个利普希茨常数 $L = \\sin(1)$，满足 $0 \\le L < 1$。\n\n**步骤 2c：结论**\n\n函数 $g(x) = \\cos(x)$ 将完备度量空间 $I = [-1, 1]$ 映射到自身，并且是 $I$ 上的一个压缩映射，其常数 $L = \\sin(1) < 1$。因此，根据巴拿赫不动点定理，存在一个唯一的不动点 $x^{\\ast} \\in [-1, 1]$，使得 $x^{\\ast} = \\cos(x^{\\ast})$。\n\n### 3. 数值迭代与停止规则\n\n巴拿赫不动点定理的构造性证明为数值算法提供了基础。从任意初始猜测值 $x_0$ 开始，序列 $x_{n+1} = g(x_n) = \\cos(x_n)$（对于 $n \\ge 0$）保证会收敛到唯一的不动点 $x^{\\ast}$，这对任意 $x_0 \\in \\mathbb{R}$ 都成立。这是因为第一次迭代 $x_1 = \\cos(x_0)$ 会将迭代值置于不变区间 $I = [-1, 1]$ 内，而所有后续的迭代值都将保留在 $I$ 中，从而保证了收敛性。\n\n在实践中，迭代必须在有限步数后终止。算法如下：\n1. 初始化 $x_0$、一个容差 $\\text{tol} > 0$ 和最大迭代次数 $\\text{max\\_iter}$。\n2. 对于 $n = 0, 1, 2, \\dots, \\text{max\\_iter}-1$：\n   a. 计算下一个迭代值：$x_{n+1} = \\cos(x_n)$。\n   b. 检查停止条件：如果 $|x_{n+1} - x_n| \\le \\text{tol}$，则认为序列已收敛。过程终止，并将 $x_{n+1}$ 作为 $x^{\\ast}$ 的近似值。\n   c. 如果条件未满足，则继续下一次迭代。\n3. 如果循环完成而未满足停止条件，则该方法未能在给定的迭代预算内收敛。报告最终的迭代值 $x_{\\text{max\\_iter}}$。\n\n### 4. 后验误差界\n\n数值计算的一个重要部分是估计近似值的误差。后验误差界仅使用迭代本身可用的量，为当前迭代值到真实不动点的距离 $|x_{n+1} - x^{\\ast}|$ 提供了一个估计。\n\n推导如下，针对在区间 $I$ 内的迭代值，其中 $g$ 是一个常数为 $L$ 的压缩映射：\n不动点性质为 $x^{\\ast} = g(x^{\\ast})$。到不动点的距离为：\n$$|x_{n+1} - x^{\\ast}| = |g(x_n) - g(x^{\\ast})|$$\n根据压缩性质，我们有：\n$$|g(x_n) - g(x^{\\ast})| \\le L |x_n - x^{\\ast}|$$\n因此， $|x_{n+1} - x^{\\ast}| \\le L |x_n - x^{\\ast}|$。为了将其与已知量联系起来，我们对 $|x_n - x^{\\ast}|$ 使用三角不等式：\n$$|x_n - x^{\\ast}| = |x_n - x_{n+1} + x_{n+1} - x^{\\ast}| \\le |x_n - x_{n+1}| + |x_{n+1} - x^{\\ast}|$$\n将此代回到关于 $|x_{n+1} - x^{\\ast}|$ 的不等式中：\n$$|x_{n+1} - x^{\\ast}| \\le L (|x_n - x_{n+1}| + |x_{n+1} - x^{\\ast}|)$$\n重新整理各项以分离出 $|x_{n+1} - x^{\\ast}|$：\n$$|x_{n+1} - x^{\\ast}| - L|x_{n+1} - x^{\\ast}| \\le L|x_n - x_{n+1}|$$\n$$(1 - L)|x_{n+1} - x^{\\ast}| \\le L|x_{n+1} - x_n|$$\n由于 $L < 1$，$(1-L)$ 是正数，所以我们可以用它相除而不改变不等号的方向：\n$$|x_{n+1} - x^{\\ast}| \\le \\frac{L}{1 - L} |x_{n+1} - x_n|$$\n这就是所要求的后验误差界。实现时将在最后的迭代步骤计算此值，使用指定的常数 $L = \\sin(1)$，无论是否达到了收敛。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the fixed point problem x = cos(x) for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (x0, tol, max_iter).\n    test_cases = [\n        (0.0, 1e-12, 100),  # Case A\n        (1.0, 1e-12, 100),  # Case B\n        (10.0, 1e-12, 100), # Case C\n        (0.5, 1e-16, 5),   # Case D\n    ]\n\n    # The Lipschitz constant for g(x) = cos(x) on the interval [-1, 1].\n    L = np.sin(1)\n    \n    # List to store the results for each test case.\n    results = []\n    \n    for x0, tol, max_iter in test_cases:\n        x_current = float(x0)\n        n_iters = 0\n        converged = False\n        diff = 0.0\n\n        for i in range(max_iter):\n            n_iters = i + 1\n            x_next = np.cos(x_current)\n            diff = np.abs(x_next - x_current)\n            \n            if diff = tol:\n                converged = True\n                x_current = x_next\n                break\n            \n            x_current = x_next\n\n        # At this point, the loop has terminated.\n        # x_current holds the final approximation.\n        # n_iters holds the total number of iterations performed.\n        # converged indicates if the tolerance was met.\n        # diff holds the last computed |x_{n+1} - x_n|.\n        \n        # Calculate the a posteriori error bound\n        # The formula is |x_n+1 - x*| = (L / (1 - L)) * |x_n+1 - x_n|\n        # This is computed at the last available iteration step.\n        bound = (L / (1.0 - L)) * diff\n\n        # Round the floating-point results to 12 decimal places as required.\n        x_approx_rounded = round(x_current, 12)\n        bound_rounded = round(bound, 12)\n        \n        # Assemble the result for this test case.\n        case_result = [x_approx_rounded, n_iters, converged, bound_rounded]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a list of lists.\n    # Using str() on the list of lists naturally produces the desired format,\n    # including spaces after commas inside the sublist representations, which\n    # aligns with the visual layout of a standard Python list representation.\n    # Example: [[0.739..., 58, True, 0.0], [...]]\n    print(str(results))\n\nsolve()\n```", "id": "3259287"}, {"introduction": "找到一个问题的解析解（如一元二次方程的求根公式）通常被认为是解决了该问题。然而，当这些公式在计算机上用有限精度浮点数进行计算时，一个完美的解析解也可能变得并不可靠。本实践 [@problem_id:3259338] 将揭示一个经典的数值陷阱——“灾难性抵消” (catastrophic cancellation)，你将看到直接使用二次求根公式如何在特定情况下导致巨大误差，并学习如何通过一个数学上等价但数值上更稳定的形式来获得精确的结果。", "problem": "你需要编写一个完整的、可运行的程序，用于对比在发生灾难性抵消的情况下，解析二次方程求根公式的数值计算与一种数值稳定方法的差异。考虑实系数 $a$、$b$ 和 $c$ 的二次多项式 $a x^2 + b x + c = 0$。解析解（求根公式）用 $a$、$b$ 和 $c$ 表达了方程的根，但在有限精度算术中，当 $b^2 \\gg 4 a c$ 时，计算该解可能会遭受灾难性抵消。目标是展示、量化并减轻这种有效数字损失。\n\n使用的基本依据和事实：\n- 二次多项式 $a x^2 + b x + c$ 的形式解析根由求根公式给出。\n- 在电气与电子工程师协会 (IEEE) $754$ 双精度（$64$ 位二进制浮点）算术中，运算遵循就近舍入原则，机器ε约为 $2.22 \\times 10^{-16}$，对于量级为 $|y|$ 的值，其绝对舍入尺度为 $O(\\varepsilon |y|)$。\n- 韦达定理：对于 $a x^2 + b x + c = 0$ 的根 $x_1$ 和 $x_2$，有 $x_1 + x_2 = -b/a$ 和 $x_1 x_2 = c/a$。\n\n任务说明：\n- 对于每个测试用例，通过选择导致两个几乎相等的数相减的符号，来计算易受数值抵消影响的小模根。定义 $s = \\mathrm{sign}(b)$，其中如果 $b  0$ 则 $s = +1$，如果 $b  0$ 则 $s = -1$。需要在浮点数中计算的易受抵消影响的根是\n$$\nx_{\\text{small,naive}} = \\frac{-b + s \\sqrt{b^2 - 4 a c}}{2 a}.\n$$\n- 通过分子有理化，推导并实现同一个小根的数值稳定表达式，得到\n$$\nx_{\\text{small,stable}} = \\frac{2 c}{-b - s \\sqrt{b^2 - 4 a c}}.\n$$\n- 使用任意精度算术（至少$60$位有效数字）计算精确的解析表达式，为小根 $x_{\\text{small,true}}$ 获得一个高精度参考值\n$$\nx_{\\text{small,true}} = \\frac{-b + s \\sqrt{b^2 - 4 a c}}{2 a}.\n$$\n- 通过计算每种方法的相对误差（以十进制数表示）来量化数值误差：\n$$\n\\text{rel\\_err\\_naive} = \\frac{\\left|x_{\\text{small,naive}} - x_{\\text{small,true}}\\right|}{\\left|x_{\\text{small,true}}\\right|}, \\quad\n\\text{rel\\_err\\_stable} = \\frac{\\left|x_{\\text{small,stable}} - x_{\\text{small,true}}\\right|}{\\left|x_{\\text{small,true}}\\right|}.\n$$\n\n测试套件：\n- 情况1：$a = 1$, $b = 10^{10}$, $c = 1$ ($b  0$ 时严重抵消)。\n- 情况2：$a = 1$, $b = -10^{10}$, $c = 1$ ($b  0$ 时严重抵消)。\n- 情况3：$a = 1$, $b = 2$, $c = 1$ (判别式为零的边界, $b^2 = 4 a c$)。\n- 情况4：$a = 1$, $b = 100$, $c = 1$ (中等数值, $b^2 \\gg 4 a c$ 但抵消有限)。\n\n输出规格：\n- 对于每个测试用例，计算 $\\text{rel\\_err\\_naive}$ 和 $\\text{rel\\_err\\_stable}$，每个值都四舍五入到10位小数。\n- 你的程序应该生成一行输出，其中包含一个方括号括起来的逗号分隔列表形式的结果，顺序为 $[\\text{rel\\_err\\_naive}^{(1)}, \\text{rel\\_err\\_stable}^{(1)}, \\text{rel\\_err\\_naive}^{(2)}, \\text{rel\\_err\\_stable}^{(2)}, \\text{rel\\_err\\_naive}^{(3)}, \\text{rel\\_err\\_stable}^{(3)}, \\text{rel\\_err\\_naive}^{(4)}, \\text{rel\\_err\\_stable}^{(4)}]$，其中上标表示测试用例的索引。\n\n所有答案都必须是纯数字且为浮点数。不涉及物理单位。不涉及角度。不得使用百分比；误差必须以小数形式表示。程序必须是自包含的，不需要任何输入，并遵守指定的执行环境。", "solution": "用户希望分析用于计算二次方程 $a x^2 + b x + c = 0$ 根的两种不同公式的数值稳定性。\n\n该问题经验证具有科学依据、是适定且客观的。在数值分析中，演示浮点运算中的灾难性相消现象是一个经典的练习。所提供的公式、测试用例和误差度量均是标准且正确的。\n\n### 基于原理的设计\n该解决方案将用Python实现，利用`numpy`库进行标准的双精度浮点运算，并使用`decimal`标准库进行高精度参考计算。\n\n1.  **高精度参考 (`x_small_true`)**: 验证过程的核心依赖于一个“真实”值，浮点计算结果将与之进行比较。我们使用`decimal`模块并设置100位的精度（远超要求的60位），以高精度算术计算问题中定义的“易受影响的根”的公式，从而获得一个基准值。这最大限度地减少了舍入误差，使其对于本分析的目的可以忽略不计。\n\n2.  **标准精度计算 (`x_small_naive`)**: 使用标准的`numpy.float64`类型直接评估易受相消影响的公式 $x_{\\text{small,naive}} = \\frac{-b + s \\sqrt{b^2 - 4 a c}}{2 a}$。当 $b^2 \\gg 4ac$ 时，分母中的 $-b$ 和 $s \\sqrt{b^2-4ac}$ 是两个几乎相等的数，它们的相减会导致有效数字的严重损失。\n\n3.  **稳定精度计算 (`x_small_stable`)**: 第二个公式 $x_{\\text{small,stable}} = \\frac{2 c}{-b - s \\sqrt{b^2 - 4 a c}}$ 是通过对朴素公式的分子进行有理化推导出来的。在这个形式中，分母涉及两个同号数（$-b$ 和 $-s\\sqrt{D}$ 符号相同）的相加，从而避免了灾难性相消。此计算同样使用`numpy.float64`实现。\n\n4.  **误差计算**: 对于朴素方法和稳定方法，都将计算其结果相对于高精度参考值的相对误差。相对误差定义为 $|x_{\\text{computed}} - x_{\\text{true}}| / |x_{\\text{true}}|$。此计算将使用高精度的`Decimal`类型以保证误差计算本身的准确性，最终结果再转换为浮点数并按要求四舍五入。\n\n程序将遍历所有测试用例，为每个用例执行以上步骤，并将得到的相对误差整理成一个列表，用于最终的格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom decimal import Decimal, getcontext\n\ndef solve():\n    \"\"\"\n    Computes and compares the relative errors of a naive and a stable formula\n    for a quadratic root subject to catastrophic cancellation.\n    \"\"\"\n    \n    # Set precision for high-accuracy reference calculations.\n    # 60 digits are required, 100 provides a safe margin.\n    getcontext().prec = 100\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (a, b, c).\n    test_cases = [\n        (1, 10**10, 1),      # Case 1: Severe cancellation, b  0\n        (1, -10**10, 1),     # Case 2: Severe cancellation, b  0\n        (1, 2, 1),           # Case 3: Discriminant is zero\n        (1, 100, 1)          # Case 4: Moderate cancellation\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        a, b, c = case\n\n        # --- High-precision reference calculation (x_small_true) ---\n        a_d = Decimal(a)\n        b_d = Decimal(b)\n        c_d = Decimal(c)\n\n        s_d = Decimal(1) if b_d  0 else Decimal(-1)\n        \n        discriminant_d = b_d**2 - 4 * a_d * c_d\n        \n        # Problem assumes real coefficients leading to real roots.\n        if discriminant_d  0:\n            continue\n        \n        sqrt_discriminant_d = discriminant_d.sqrt()\n        \n        # x_small_true is computed using the high-precision Decimal objects\n        # following the 'naive' formula structure, as specified.\n        x_small_true = (-b_d + s_d * sqrt_discriminant_d) / (2 * a_d)\n\n        # --- Standard double-precision calculations (numpy.float64) ---\n        a_f = np.float64(a)\n        b_f = np.float64(b)\n        c_f = np.float64(c)\n\n        s_f = np.sign(b_f)\n        \n        discriminant_f = b_f**2 - 4 * a_f * c_f\n        sqrt_discriminant_f = np.sqrt(discriminant_f)\n        \n        # 1. Naive (cancellation-prone) formula\n        x_small_naive = (-b_f + s_f * sqrt_discriminant_f) / (2 * a_f)\n        \n        # 2. Stable (rationalized) formula\n        denominator_stable = -b_f - s_f * sqrt_discriminant_f\n        # Avoid division by zero.\n        if denominator_stable == 0:\n            # For case 3 (D=0), the stable formula is 2c/-2b = -c/b.\n            # The root is -b/2a.\n            # Since b^2=4ac, -c/b = -c / (+-sqrt(4ac)) = -c / (+-2sqrt(ac))\n            # and -b/2a = -(+-2sqrt(ac))/2a = -+sqrt(c/a).\n            # The formulas are equivalent under b^2=4ac.\n            # We can use the simpler form for the stable calculation.\n            x_small_stable = -b_f / (2 * a_f)\n        else:\n            x_small_stable = (2 * c_f) / denominator_stable\n\n        # --- Relative Error Calculation ---\n        # Convert float results to Decimal for accurate error computation\n        x_naive_d = Decimal(x_small_naive)\n        x_stable_d = Decimal(x_small_stable)\n        \n        # Avoid division by zero for relative error if true value is zero.\n        if x_small_true == 0:\n            rel_err_naive = Decimal(0) if x_naive_d == 0 else Decimal('inf')\n            rel_err_stable = Decimal(0) if x_stable_d == 0 else Decimal('inf')\n        else:\n            rel_err_naive = abs((x_naive_d - x_small_true) / x_small_true)\n            rel_err_stable = abs((x_stable_d - x_small_true) / x_small_true)\n            \n        # Round the final error values to 10 decimal places as specified\n        rounded_err_naive = round(float(rel_err_naive), 10)\n        rounded_err_stable = round(float(rel_err_stable), 10)\n        \n        results.append(rounded_err_naive)\n        results.append(rounded_err_stable)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3259338"}, {"introduction": "在分析方法和数值方法之间做选择，往往涉及在不同策略之间进行权衡。本实践 [@problem_id:3259327] 通过数据插值问题来探讨这种权衡：一个看似优雅的全局方法（高次多项式插值）与一个更具适应性的分段数值方法（三次样条插值）的对比。你将亲手实现这两种方法，并观察到高次多项式在处理某些函数时会出现剧烈振荡（即龙格现象），而样条插值却能保持稳定和精确，这揭示了选择与问题结构相匹配的近似方法的重要性。", "problem": "您将研究在闭区间上对从光滑函数采样的数据使用单一全局高次多项式插值和分段三次样条插值之间的权衡，重点关注全局插值在区间端点附近表现出大幅振荡（龙格现象）而数值构造的样条函数却保持表现良好的情况。\n\n使用的基本原理：\n- 唯一多项式插值的定义：对于 $n$ 个不同的节点 $\\{x_i\\}_{i=0}^{n-1}$ 和数据 $\\{y_i\\}_{i=0}^{n-1}$，存在一个次数至多为 $n-1$ 的唯一多项式 $p$，使得对所有 $i$ 都有 $p(x_i)=y_i$。\n- 自然三次样条的定义：一个在区间 $[a,b]$ 上的二次连续可微分段三次函数 $S$，它在节点处对给定数据进行插值，在内部节点处具有连续的一阶和二阶导数，并满足自然边界条件 $S''(a)=0$ 和 $S''(b)=0$。\n- Runge的观察：对于区间 $[-1,1]$ 上的解析函数 $f(x)=\\frac{1}{1+25x^2}$，当 $n$ 增加时，使用等距节点的 $(n-1)$ 次多项式插值的误差在端点附近可能会增长，而三次样条插值通常保持稳定。\n\n任务：\n- 考虑区间 $\\left[-1,1\\right]$ 上的函数 $f(x)=\\dfrac{1}{1+25x^2}$。\n- 对于每个指定的等距节点数 $n$，构造：\n  1. 在等距节点 $x_i=-1+\\dfrac{2i}{n-1}$（其中 $i=0,1,\\dots,n-1$）上，与采样数据 $\\left\\{(x_i,f(x_i))\\right\\}_{i=0}^{n-1}$ 完全匹配的唯一 $(n-1)$ 次插值多项式 $p_n$。\n  2. 对相同数据进行插值的自然三次样条 $S_n$，满足 $S_n''(-1)=0$ 和 $S_n''(1)=0$。\n- 在 $\\left[-1,1\\right]$ 区间上一个包含 $m=1001$ 个点的均匀评估网格 $\\{t_j\\}_{j=0}^{m-1}$ 上，为每个 $n$ 计算以下内容：\n  - 多项式插值的最大绝对误差，$E_p(n)=\\max_{0\\le j  m} |p_n(t_j) - f(t_j)|$。\n  - 样条插值的最大绝对误差，$E_s(n) = \\max_{0 \\le j  m} |S_n(t_j) - f(t_j)|$。\n  - 一个布尔指示符 $B(n)$，当且仅当 $E_p(n)  E_s(n)$ 时为真。\n\n测试套件：\n- 对于 $n \\in \\{5, 11, 21\\}$ 中的每个值，计算三元组 $[E_p(n), E_s(n), B(n)]$。\n\n输出规格：\n- 您的程序应生成一个单行输出，其中包含一个方括号括起来的列表，该列表包含按 $n$ 的顺序排列的三个结果列表。\n- 每个结果列表应包含 $[E_p, E_s, B]$，其中浮点数 $E_p$ 和 $E_s$ 四舍五入到8位小数，B是布尔值。\n- 最终格式应为 $[[E_p(5), E_s(5), B(5)],[E_p(11), E_s(11), B(11)],[E_p(21), E_s(21), B(21)]]$。", "solution": "该问题经验证具有科学依据、是适定且客观的。在数值分析中，比较全局多项式插值与分段样条插值的性能是一个标准的练习。\n\n问题的核心在于为从区间 $[-1, 1]$ 上的函数 $f(x) = \\dfrac{1}{1+25x^2}$ 采样的数据构造和评估两种不同类型的插值函数。对于给定的节点数 $n$，插值点为 $\\{(x_i, y_i)\\}_{i=0}^{n-1}$，其中节点 $x_i$ 是等距的，且 $y_i = f(x_i)$。\n\n节点定义为 $x_i = -1 + \\frac{2i}{n-1}$，其中 $i=0, 1, \\dots, n-1$。\n\n### 1. 全局多项式插值 ($p_n$)\n\n对于一组 $n$ 个不同的数据点，存在一个次数至多为 $n-1$ 的唯一插值多项式 $p_n(x)$，使得对所有 $i$ 都有 $p_n(x_i) = y_i$。虽然存在多种公式（例如，拉格朗日、牛顿），但重心插值公式因其更优的数值稳定性和计算效率而被选择，尤其是在多点评估多项式时。对于等距节点，其重心权重 $w_i = (-1)^i \\binom{n-1}{i}$ 可以预先计算。\n\n### 2. 自然三次样条插值 ($S_n$)\n\n三次样条 $S_n(x)$ 是一个对数据点进行插值的 $C^2$ 连续的分段三次函数。其构造涉及求解一个三对角线性方程组，以确定每个节点上的二阶导数 $M_i = S_n''(x_i)$。对于自然样条，边界条件为 $M_0 = 0$ 和 $M_{n-1} = 0$。一旦所有 $M_i$ 都已知，就可以在任意点评估样条。\n\n### 3. 误差分析\n\n为了比较这两种插值方法，多项式 $p_n(x)$ 和样条 $S_n(x)$ 都在一个密集的均匀网格上进行评估。然后计算每个插值函数相对于真实函数 $f(x)$ 的最大绝对误差：\n\n- 多项式误差：$E_p(n) = \\max_{j} |p_n(t_j) - f(t_j)|$\n- 样条误差：$E_s(n) = \\max_{j} |S_n(t_j) - f(t_j)|$\n\n然后确定一个布尔指示符 $B(n)$，当且仅当 $E_p(n) > E_s(n)$ 时为真。对测试套件 $\\{5, 11, 21\\}$ 中的每个 $n$ 值执行此分析。预计结果将显示，随着 $n$ 的增加，使用等距节点的全局多项式插值的误差显著增长（龙格现象），而三次样条误差保持很小并减小。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef runge_function(x):\n    \"\"\"The function f(x) = 1 / (1 + 25x^2).\"\"\"\n    return 1.0 / (1.0 + 25.0 * x**2)\n\ndef barycentric_poly_interp(nodes_x, nodes_y, eval_t):\n    \"\"\"\n    Evaluates the interpolating polynomial using the barycentric formula.\n    This implementation is for equally spaced nodes.\n    \"\"\"\n    n = len(nodes_x)\n    \n    # Pre-compute barycentric weights for equally spaced nodes.\n    # w_i = (-1)^i * C(n-1, i)\n    weights = np.zeros(n)\n    for i in range(n):\n        weights[i] = ((-1)**i) * math.comb(n - 1, i)\n\n    p_vals = np.zeros_like(eval_t, dtype=np.float64)\n\n    for j, t in enumerate(eval_t):\n        # Check if t is one of the nodes (within a small tolerance)\n        # Using np.isclose is robust for floating point comparison.\n        is_node = np.isclose(t, nodes_x)\n        if np.any(is_node):\n            p_vals[j] = nodes_y[np.where(is_node)[0][0]]\n        else:\n            # Barycentric formula\n            terms = weights / (t - nodes_x)\n            numerator = np.sum(terms * nodes_y)\n            denominator = np.sum(terms)\n            p_vals[j] = numerator / denominator\n            \n    return p_vals\n\ndef natural_cubic_spline_interp(nodes_x, nodes_y, eval_t):\n    \"\"\"\n    Constructs and evaluates a natural cubic spline interpolant.\n    \"\"\"\n    n = len(nodes_x)\n    h = nodes_x[1] - nodes_x[0]  # Assuming equally spaced nodes\n\n    # Set up the tridiagonal system for the second derivatives M_i = S''(x_i)\n    # The system is A*M_interior = b for interior M_i (i=1..n-2)\n    # Natural boundary conditions: M_0 = 0, M_{n-1} = 0\n    \n    num_interior_nodes = n - 2\n    if num_interior_nodes = 0: # For n=2, M is [0,0]. For n2, this is ill-defined.\n        M = np.zeros(n)\n    else:\n        # A is a (n-2)x(n-2) tridiagonal matrix with 4 on diag, 1 on off-diags\n        A = np.diag(np.full(num_interior_nodes, 4.0)) + \\\n            np.diag(np.ones(num_interior_nodes - 1), 1) + \\\n            np.diag(np.ones(num_interior_nodes - 1), -1)\n\n        # b is the right-hand side vector\n        # b_i = (6/h^2) * (y_{i+2} - 2y_{i+1} + y_i)\n        # Indices are shifted because we solve for M_1 to M_{n-2}.\n        y = nodes_y\n        b = (6.0 / h**2) * (y[0:n-2] - 2.0 * y[1:n-1] + y[2:n])\n        \n        # Solve for the interior second derivatives\n        M_interior = np.linalg.solve(A, b)\n        \n        # Form the full vector of second derivatives\n        M = np.concatenate(([0.0], M_interior, [0.0]))\n\n    # Evaluate the spline at points in eval_t\n    # Find the interval index for each evaluation point\n    indices = np.searchsorted(nodes_x, eval_t, side='right')\n    indices = np.clip(indices, 1, n) # Ensure indices are valid\n    indices = indices - 1\n    \n    # Correct handling for the rightmost point of the interval\n    indices[eval_t == nodes_x[-1]] = n - 2\n    \n    # Extract relevant values for vectorized calculation\n    x_i = nodes_x[indices]\n    x_i1 = nodes_x[indices + 1]\n    y_i = nodes_y[indices]\n    y_i1 = nodes_y[indices + 1]\n    M_i = M[indices]\n    M_i1 = M[indices + 1]\n    \n    # Terms in the spline evaluation formula\n    term_A = x_i1 - eval_t\n    term_B = eval_t - x_i\n    \n    # Spline evaluation formula S(t) on [x_i, x_{i+1}]\n    s_vals = (M_i / (6.0 * h)) * term_A**3 + \\\n             (M_i1 / (6.0 * h)) * term_B**3 + \\\n             (y_i / h - M_i * h / 6.0) * term_A + \\\n             (y_i1 / h - M_i1 * h / 6.0) * term_B\n\n    return s_vals\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the interpolation and error analysis.\n    \"\"\"\n    test_cases = [5, 11, 21]\n    m = 1001\n    interval = [-1.0, 1.0]\n\n    results = []\n    \n    # Uniform evaluation grid\n    eval_t = np.linspace(interval[0], interval[1], m)\n    true_f_vals = runge_function(eval_t)\n\n    for n in test_cases:\n        # Generate equally spaced nodes and corresponding function values\n        nodes_x = np.linspace(interval[0], interval[1], n)\n        nodes_y = runge_function(nodes_x)\n        \n        # 1. Polynomial Interpolation\n        p_vals = barycentric_poly_interp(nodes_x, nodes_y, eval_t)\n        E_p = np.max(np.abs(p_vals - true_f_vals))\n        \n        # 2. Cubic Spline Interpolation\n        s_vals = natural_cubic_spline_interp(nodes_x, nodes_y, eval_t)\n        E_s = np.max(np.abs(s_vals - true_f_vals))\n        \n        # 3. Boolean Indicator\n        B = E_p > E_s\n        \n        results.append([E_p, E_s, B])\n\n    # Format the final output string exactly as required\n    result_strings = []\n    for res in results:\n        e_p, e_s, b = res\n        # Format floats to 8 decimal places, bool as True/False string\n        result_strings.append(f\"[{e_p:.8f},{e_s:.8f},{str(b)}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3259327"}]}