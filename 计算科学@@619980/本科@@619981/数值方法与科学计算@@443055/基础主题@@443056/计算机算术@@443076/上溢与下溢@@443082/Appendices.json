{"hands_on_practices": [{"introduction": "直接计算一个数学表达式有时会因为中间步骤的数值超出浮点数的表示范围而失败。本练习将展示如何通过简单的代数变换，重构双曲正切函数 $\\tanh(x)$ 的表达式，从而在计算大数值输入时有效避免溢出。这个技巧是数值计算中最直接也最常见的稳定性策略之一。[@problem_id:3260871]", "problem": "你的任务是设计一个数值稳定的算法来计算实数输入下的双曲正切函数。目标是在广泛的输入量级范围内生成精确的函数值，同时避免上溢和下溢。此任务的基本基础是根据指数函数定义的双曲函数，以及由电气和电子工程师协会（IEEE）754标准规定的浮点运算属性。\n\n从基本定义出发，使用基于指数函数的定义：\n- 双曲正弦定义为 $$\\sinh(x) = \\frac{e^{x} - e^{-x}}{2}$$。\n- 双曲余弦定义为 $$\\cosh(x) = \\frac{e^{x} + e^{-x}}{2}$$。\n- 双曲正切定义为 $$\\tanh(x) = \\frac{\\sinh(x)}{\\cosh(x)}$$。\n\n你的任务是以一种能够避免因大正数 $$x$$ 导致 $$e^{x}$$ 项上溢，以及避免因大负数 $$x$$ 导致 $$e^{-x}$$ 项上溢的方式，重写 $$\\tanh(x)$$ 的表达式。然后，你必须在一个完整的、可运行的程序中实现这个稳定的表达式。\n\n最终程序必须：\n- 实现一个函数，该函数使用从上述定义和基于IEEE 754模型的合理浮点运算推理得出的数值稳定表达式来计算 $$\\tanh(x)$$。\n- 将该函数应用于以下覆盖典型和极端情况的测试输入套件：\n  1. $$x = 0.0$$\n  2. $$x = 10^{-12}$$\n  3. $$x = -10^{-12}$$\n  4. $$x = 1.0$$\n  5. $$x = -1.0$$\n  6. $$x = 709.0$$\n  7. $$x = -709.0$$\n  8. $$x = 750.0$$\n  9. $$x = -750.0$$\n- 以浮点数形式生成输出，不带单位（该量是无量纲的）。\n- 输出格式规范：你的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3]”）。不应打印任何其他文本。\n\n你的设计和实现应明确避免会引发大正数输入上溢或导致大负数输入不必要的上溢引发精度损失的表达式，并遵循浮点运算的限制。", "solution": "所述问题是有效的。它在科学上基于数值分析和浮点运算的原理，是适定的，并以客观和形式化的语言表述。因此，我们可以着手解决。\n\n目标是为计算实数输入 $x$ 的双曲正切函数 $\\tanh(x)$ 构建一个数值稳定的算法。推导从双曲正弦 $\\sinh(x)$ 和双曲余弦 $\\cosh(x)$ 以指数函数表示的基本定义开始。\n\n定义如下：\n$$ \\sinh(x) = \\frac{e^{x} - e^{-x}}{2} $$\n$$ \\cosh(x) = \\frac{e^{x} + e^{-x}}{2} $$\n\n由此，双曲正切被定义为它们的比值：\n$$ \\tanh(x) = \\frac{\\sinh(x)}{\\cosh(x)} = \\frac{\\frac{e^{x} - e^{-x}}{2}}{\\frac{e^{x} + e^{-x}}{2}} = \\frac{e^{x} - e^{-x}}{e^{x} + e^{-x}} $$\n\n这最后一个表达式 $\\tanh(x) = \\frac{e^{x} - e^{-x}}{e^{x} + e^{-x}}$ 构成了朴素计算公式。我们必须在有限精度浮点运算（特别是IEEE 754双精度数标准）的约束下分析其行为。\n\n浮点运算的一个关键限制是其有限的范围。对于标准的双精度浮点数，最大可表示值约为 $1.797 \\times 10^{308}$。指数函数 $e^x$ 增长非常迅速。使 $e^x$ 超过此最大值的 $x$ 值为 $x  \\ln(1.797 \\times 10^{308}) \\approx 709.78$。任何尝试计算超出此阈值的 $x$ 的 $e^x$ 都会导致数值上溢，通常表示为无穷大（$\\infty$）。\n\n让我们根据这一限制来分析朴素公式：\n1.  对于大的正数 $x$（例如，$x  709.78$）：项 $e^x$ 上溢为 $\\infty$。项 $e^{-x}$ 正确计算为一个非常小的正数（或下溢为 $0$）。表达式变为 $\\frac{\\infty - 0}{\\infty + 0}$，这是一个 $\\frac{\\infty}{\\infty}$ 的不定式，其计算结果为 `NaN`（非数值）。这在数值上是不正确的，因为数学极限是 $\\lim_{x \\to \\infty} \\tanh(x) = 1$。\n\n2.  对于大绝对值的负数 $x$（例如，$x  -709.78$）：设 $x = -y$，其中 $y$ 是大的正数。项 $e^x = e^{-y}$ 正确计算为一个非常小的正数（或 $0$）。然而，项 $e^{-x} = e^y$ 上溢为 $\\infty$。表达式变为 $\\frac{0 - \\infty}{0 + \\infty}$，一个 $\\frac{-\\infty}{\\infty}$ 的不定式，同样导致 `NaN`。这再次不正确，因为数学极限是 $\\lim_{x \\to -\\infty} \\tanh(x) = -1$。\n\n为了构建一个稳定的算法，我们必须重新构造表达式，以避免计算一个大的正数的指数。这可以通过代数变换来实现，从而得到一个基于 $x$ 符号的分段函数。\n\n**情况 1：$x \\ge 0$**\n对于非负数 $x$，项 $e^x$ 是潜在上溢的来源。我们可以通过将分子和分母同乘以 $e^{-x}$ 来消除它：\n$$ \\tanh(x) = \\frac{e^x - e^{-x}}{e^x + e^{-x}} \\cdot \\frac{e^{-x}}{e^{-x}} = \\frac{e^x e^{-x} - e^{-x} e^{-x}}{e^x e^{-x} + e^{-x} e^{-x}} = \\frac{1 - e^{-2x}}{1 + e^{-2x}} $$\n在这种形式 $\\tanh(x) = \\frac{1 - e^{-2x}}{1 + e^{-2x}}$ 中，指数函数的参数是 $-2x$。由于 $x \\ge 0$，参数 $-2x$ 总是非正数。计算 $e^{-2x}$ 永远不会上溢。对于大的正数 $x$，$-2x$ 变为一个大绝对值的负数，而 $e^{-2x}$ 将无害地向下溢出为 $0$。在此极限下，表达式正确地计算为 $\\frac{1 - 0}{1 + 0} = 1$。这种形式对于所有 $x \\ge 0$ 都是数值稳定的。\n\n**情况 2：$x  0$**\n对于负数 $x$，项 $e^{-x}$ 是潜在上溢的来源。我们可以通过将原始表达式的分子和分母同乘以 $e^x$ 来消除这一项：\n$$ \\tanh(x) = \\frac{e^x - e^{-x}}{e^x + e^{-x}} \\cdot \\frac{e^x}{e^x} = \\frac{e^x e^x - e^{-x} e^x}{e^x e^x + e^{-x} e^x} = \\frac{e^{2x} - 1}{e^{2x} + 1} $$\n在这种形式 $\\tanh(x) = \\frac{e^{2x} - 1}{e^{2x} + 1}$ 中，指数函数的参数是 $2x$。由于 $x  0$，参数 $2x$ 总是负数。计算 $e^{2x}$ 永远不会上溢。对于大绝对值的负数 $x$，$2x$ 变为一个大绝对值的负数，而 $e^{2x}$ 将无害地向下溢出为 $0$。在此极限下，表达式正确地计算为 $\\frac{0 - 1}{0 + 1} = -1$。这种形式对于所有 $x  0$ 都是数值稳定的。这个结果也与奇函数性质 $\\tanh(x) = -\\tanh(-x)$ 一致，该性质会产生相同的表达式。\n\n**最终算法**\n推导出的用于计算 $\\tanh(x)$ 的数值稳定算法是一个分段函数：\n$$\n\\tanh(x) =\n\\begin{cases}\n    \\frac{1 - e^{-2x}}{1 + e^{-2x}}   \\text{若 } x \\ge 0 \\\\\n    \\frac{e^{2x} - 1}{e^{2x} + 1}   \\text{若 } x  0\n\\end{cases}\n$$\n该算法通过确保指数函数的参数始终为非正数，避免了对所有实数输入 $x$ 的数值上溢。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef stable_tanh(x):\n    \"\"\"\n    Computes tanh(x) using a numerically stable algorithm to avoid\n    overflow and underflow issues for large magnitude inputs.\n\n    This function implements a piecewise expression for tanh(x) derived\n    from first principles to ensure that the argument to the exponential\n    function is always non-positive, thus preventing overflow.\n    \"\"\"\n    # Ensure the input is treated as a 64-bit float for consistency\n    # with standard double-precision floating-point arithmetic (IEEE 754).\n    x_f64 = np.float64(x)\n\n    # For non-negative x, use the form tanh(x) = (1 - exp(-2x)) / (1 + exp(-2x)).\n    # The exponent (-2x) is guaranteed to be non-positive, thus np.exp\n    # will not overflow. It may underflow to 0 for large x, which is\n    # the desired behavior, yielding a result of 1.0.\n    if x_f64 = 0.0:\n        exp_val = np.exp(-2.0 * x_f64)\n        return (1.0 - exp_val) / (1.0 + exp_val)\n    \n    # For negative x, use the form tanh(x) = (exp(2x) - 1) / (exp(2x) + 1).\n    # The exponent (2x) is guaranteed to be negative, thus np.exp\n    # will not overflow. It may underflow to 0 for large-magnitude\n    # negative x, which is the desired behavior, yielding a result of -1.0.\n    else:\n        exp_val = np.exp(2.0 * x_f64)\n        return (exp_val - 1.0) / (exp_val + 1.0)\n\ndef solve():\n    \"\"\"\n    Main function to execute the test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        0.0,\n        1e-12,\n        -1e-12,\n        1.0,\n        -1.0,\n        709.0,\n        -709.0,\n        750.0,\n        -750.0,\n    ]\n\n    results = []\n    for case in test_cases:\n        # Calculate the result for one case using the stable function.\n        result = stable_tanh(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) function converts each float in the results list\n    # to its string representation before joining them with commas.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main function.\nsolve()\n```", "id": "3260871"}, {"introduction": "当处理一连串的乘法时，例如计算阶乘 $n!$，结果会迅速增长并导致溢出。一个强大的解决方法是将计算转移到对数空间中，将乘法转化为加法，从而控制数值的增长。本练习将指导你使用对数伽马函数来安全地计算大数的阶乘，这是处理极大或极小数值的标准方法。[@problem_id:3260852]", "problem": "您的任务是在浮点数环境中设计并实现一个稳健的计算方法，用以在计算阶乘函数时避免溢出和下溢。您推导的基础是阶乘作为乘积的定义以及对数和伽马函数的一般性质。上下文环境为电气和电子工程师协会（IEEE）754 双精度浮点数算术标准。在此类系统中，规格化数的表示范围有限，对于较大的 $n$，直接计算 $n!$ 或其倒数可能会导致溢出或下溢。您的任务是从第一性原理出发，重构计算过程，以确保所有中间步骤的数值都保持在可表示范围内。\n\n从阶乘 $n!$ 对于整数 $n \\ge 0$ 的有限乘积定义 $\\prod_{k=1}^{n} k$ 出发，并利用伽马函数 $\\Gamma(x)$ 和对数 $\\log(x)$ 的一般性质，不假定任何快捷公式。您可以假设存在一个黑盒函数，该函数可返回 $x  0$ 时的 $\\log(\\Gamma(x))$，并且您可以认为它在双精度设置下是数值稳定的。您的算法必须在以 10 为底的对数表示下操作，以便在不引起数值溢出或下溢的情况下，概括 $n!$ 和 $1/n!$ 的值。\n\n规格说明：\n- 对于每个整数输入 $n \\ge 0$，计算 $n!$ 和 $1/n!$ 的以 10 为底的科学记数法表示形式 $m \\times 10^{e}$，其中 $m \\in [1,10)$ 且 $e \\in \\mathbb{Z}$。令 $m_f$ 和 $e_f$ 表示 $n!$ 的尾数和指数，令 $m_r$ 和 $e_r$ 表示 $1/n!$ 的尾数和指数。\n- 仅使用从 $\\log(\\Gamma(\\cdot))$ 和对数性质推导出的以 10 为底的对数值来获得 $m_f$、$e_f$、$m_r$ 和 $e_r$，而不要以标准浮点形式直接计算 $n!$ 或 $1/n!$。\n- 将尾数 $m_f$ 和 $m_r$ 四舍五入到 10 位小数，指数 $e_f$ 和 $e_r$ 保留为精确整数。\n\n测试套件：\n- 使用以下 $n$ 的测试值列表：$[0, 10, 170, 171, 100000]$。选择这些值是为了涵盖多个方面：\n  - $n = 0$ 用于检查阶乘恒等式的边界条件。\n  - $n = 10$ 是一个典型情况，朴素计算在此是安全的，可作为一致性检查。\n  - $n = 170$ 接近于 IEEE 754 双精度浮点数表示 $n!$ 的上限。\n  - $n = 171$ 超过了 IEEE 754 双精度浮点数表示 $n!$ 的溢出阈值。\n  - $n = 100000$ 是一个极大的数，用于对对数方法进行压力测试。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，并且其本身必须是按 $[m_f, e_f, m_r, e_r]$ 顺序排列的四个值的列表。例如，输出格式必须与此完全相同：\n  - $[[m_{f,0}, e_{f,0}, m_{r,0}, e_{r,0}], [m_{f,1}, e_{f,1}, m_{r,1}, e_{r,1}], \\dots]$\n- 所有尾数必须是四舍五入到 10 位小数的浮点数，所有指数必须是整数。\n\n答案中不要包含任何物理单位，也不要使用百分比。所有角度（如果出现的话，本任务中没有）将默认为弧度。", "solution": "该问题要求设计一个数值稳定的算法，用于计算非负整数 $n$ 的阶乘 $n!$ 及其倒数 $1/n!$ 的科学记数法表示 $m \\times 10^e$。核心挑战是避免在标准浮点数算术中直接计算 $n!$ 时出现的溢出和下溢问题，特别是对于较大的 $n$ 值。指定的方法是从第一性原理出发，利用对数的性质以及一个提供的用于计算伽马函数对数 $\\log(\\Gamma(x))$ 的稳定函数。为了本次推导，我们将假设 $\\log(x)$ 表示自然对数 $\\ln(x)$，这在科学计算环境和函数库中是标准做法。\n\n### 对数计算原理\n\n处理由乘积产生的极大或极小数字的基本策略是将计算转换到对数域。一项项的乘积变成了它们对数的和：\n$$ \\log\\left(\\prod_{i=1}^{n} x_i\\right) = \\sum_{i=1}^{n} \\log(x_i) $$\n对于阶乘函数，其定义为当 $n \\ge 1$ 时 $n! = \\prod_{k=1}^{n} k$，此性质意味着：\n$$ \\ln(n!) = \\ln\\left(\\prod_{k=1}^{n} k\\right) = \\sum_{k=1}^{n} \\ln(k) $$\n对数的和比相应数字本身的乘积增长得慢得多。例如，虽然 $171!$ 超过了 IEEE 754 双精度算术中的最大可表示值（约 $1.8 \\times 10^{308}$），但其自然对数 $\\ln(171!) \\approx 711.8$ 是一个完全可控的数字。这种从乘法到加法的转换是防止溢出的关键。同样，在处理倒数 $1/n!$ 时，它也能防止下溢。\n\n### 与伽马函数的联系\n\n问题提供了一个黑盒函数，用于以数值稳定的方式计算 $\\ln(\\Gamma(x))$。伽马函数 $\\Gamma(x)$ 是阶乘函数到复数的推广。对于任何非负整数 $n$，它满足以下恒等式：\n$$ \\Gamma(n+1) = n! $$\n对两边取自然对数，提供了一种直接求得 $\\ln(n!)$ 的方法，而无需计算可能不稳定的和：\n$$ \\ln(n!) = \\ln(\\Gamma(n+1)) $$\n因此，即使对于非常大的 $n$，我们也可以使用提供的稳定 `log-gamma` 函数来获得 $\\ln(n!)$ 的精确值。\n\n### 转换为以 10 为底的科学记数法\n\n目标是将一个数 $X$（即 $n!$ 或 $1/n!$）表示为以 10 为底的科学记数法 $X = m \\times 10^e$，其中尾数 $m$ 在范围 $[1, 10)$ 内，指数 $e$ 是一个整数。\n\n为了求出 $m$ 和 $e$，我们对该方程取以 10 为底的对数：\n$$ \\log_{10}(X) = \\log_{10}(m \\times 10^e) = \\log_{10}(m) + \\log_{10}(10^e) = \\log_{10}(m) + e $$\n对尾数的约束 $1 \\le m  10$ 意味着其以 10 为底的对数在范围 $0 \\le \\log_{10}(m)  1$ 内。这意味着 $\\log_{10}(m)$ 是 $\\log_{10}(X)$ 的小数部分，而 $e$ 是整数部分。\n\n设 $L = \\log_{10}(X)$。指数 $e$ 和尾数 $m$ 可以如下提取：\n- 指数是 $L$ 的向下取整：$e = \\lfloor L \\rfloor$。\n- 尾数由 $L$ 的小数部分导出：$m = 10^{(L - \\lfloor L \\rfloor)}$。\n\n### 计算 $n!$ 和 $1/n!$ 的算法\n\n现在我们将此分解方法应用于 $n!$ 和 $1/n!$。\n\n1.  **计算 $n!$ 以 10 为底的对数**：\n    首先，我们使用对数伽马函数求得 $\\ln(n!)$：$\\ln(n!) = \\ln(\\Gamma(n+1))$。\n    然后，我们使用换底公式 $\\log_{10}(x) = \\frac{\\ln(x)}{\\ln(10)}$ 将其转换为以 10 为底的对数。设此值为 $L_f$。\n    $$ L_f = \\log_{10}(n!) = \\frac{\\ln(\\Gamma(n+1))}{\\ln(10)} $$\n\n2.  **提取 $n!$ 的尾数和指数**：\n    利用上面推导的逻辑，$n!$ 的尾数 $m_f$ 和指数 $e_f$ 为：\n    $$ e_f = \\lfloor L_f \\rfloor $$\n    $$ m_f = 10^{(L_f - e_f)} = 10^{(L_f - \\lfloor L_f \\rfloor)} $$\n\n3.  **提取 $1/n!$ 的尾数和指数**：\n    对于倒数 $1/n!$，其以 10 为底的对数 $L_r$ 恰好是 $L_f$ 的负值：\n    $$ L_r = \\log_{10}(1/n!) = \\log_{10}(n!^{-1}) = - \\log_{10}(n!) = -L_f $$\n    我们对 $L_r$ 应用相同的分解方法来求得尾数 $m_r$ 和指数 $e_r$：\n    $$ e_r = \\lfloor L_r \\rfloor = \\lfloor -L_f \\rfloor $$\n    $$ m_r = 10^{(L_r - e_r)} = 10^{(-L_f - \\lfloor -L_f \\rfloor)} $$\n\n4.  **处理 $n=0$ 的情况**：\n    根据定义，$0! = 1$。算法也必须正确处理这个基准情况。\n    对于 $n=0$，我们有 $\\Gamma(0+1) = \\Gamma(1) = 1$。\n    则 $\\ln(\\Gamma(1)) = \\ln(1) = 0$。\n    这得出 $L_f = \\log_{10}(1) = 0$。\n    对于 $n!$：$e_f = \\lfloor 0 \\rfloor = 0$ 且 $m_f = 10^{(0-0)} = 1$。这对应于 $1 \\times 10^0$，是正确的。\n    对于 $1/n!$：$L_r = -0 = 0$。因此，$e_r = \\lfloor 0 \\rfloor = 0$ 且 $m_r = 10^{(0-0)} = 1$。这也是正确的。\n    因此，该算法对所有 $n \\ge 0$ 都有效。\n\n此过程仅使用对数域中对良态数的操作来计算 $n!$ 和 $1/n!$ 的尾数和指数，从而稳健地避免了任何溢出或下溢。最终的实现将按照要求将计算出的尾数四舍五入到 10 位小数。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes the scientific notation representation for n! and 1/n!\n    for a list of test cases, avoiding overflow and underflow.\n    \"\"\"\n\n    test_cases = [0, 10, 170, 171, 100000]\n    \n    # Pre-calculate the natural logarithm of 10 for change of base.\n    LN_10 = math.log(10)\n\n    def calculate_sci_notation(n: int) - list:\n        \"\"\"\n        Calculates m_f, e_f, m_r, e_r for a given integer n.\n        \n        Args:\n            n: A non-negative integer.\n\n        Returns:\n            A list containing [m_f, e_f, m_r, e_r], where m_f and m_r are\n            mantissas rounded to 10 decimal places, and e_f and e_r are\n            integer exponents.\n        \"\"\"\n        if n == 0:\n            # Base case: 0! = 1.\n            # 1 = 1.0 * 10^0. Reciprocal is the same.\n            return [1.0, 0, 1.0, 0]\n\n        # Use the identity ln(n!) = ln(Gamma(n+1)).\n        # math.lgamma(x) computes ln(|Gamma(x)|) stably.\n        ln_factorial = math.lgamma(n + 1)\n        \n        # Convert to base-10 logarithm: log10(x) = ln(x) / ln(10).\n        log10_factorial = ln_factorial / LN_10\n        \n        # --- For n! ---\n        # The exponent is the integer part of the base-10 logarithm.\n        e_f = math.floor(log10_factorial)\n        # The mantissa is 10 raised to the power of the fractional part.\n        m_f = 10**(log10_factorial - e_f)\n        \n        # --- For 1/n! ---\n        # log10(1/n!) = -log10(n!)\n        log10_reciprocal = -log10_factorial\n        \n        # The exponent is the integer part.\n        e_r = math.floor(log10_reciprocal)\n        # The mantissa is 10 raised to the power of the fractional part.\n        m_r = 10**(log10_reciprocal - e_r)\n        \n        # Return the results, rounded and typed as specified.\n        return [\n            round(m_f, 10),\n            int(e_f),\n            round(m_r, 10),\n            int(e_r)\n        ]\n\n    results = []\n    for n in test_cases:\n        results.append(calculate_sci_notation(n))\n\n    # The format requires no spaces inside the inner lists' string representation.\n    # Python's default str(list) includes spaces. This custom formatting avoids them.\n    formatted_results = []\n    for res in results:\n        # Format \"m_f\" as a float string, \"e_f\" as an int, etc.\n        # The rounding to 10 places is handled in the function, so we just format.\n        formatted_inner_list = f\"[{res[0]},{res[1]},{res[2]},{res[3]}]\"\n        formatted_results.append(formatted_inner_list)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3260852"}, {"introduction": "溢出并不仅仅发生在最终解本身巨大的情况下，它也可能是一个数值方法内在不稳定的表现。本练习通过一个简单的常微分方程揭示了这一现象：即使其精确解是有界且衰减的，不当选择步长的欧拉法也会导致数值解发散并溢出。通过这个例子，你将深刻理解数值稳定性和计算参数选择在科学计算中的重要性。[@problem_id:3260938]", "problem": "构建并分析一个标量常微分方程，在该方程中，即使解析解保持有界，一个朴素的前向显式欧拉方法也会出现数值上溢。请使用以下基本依据：标量线性常微分方程的定义，源自一阶泰勒近似的前向显式欧拉方法，以及电气与电子工程师协会 (IEEE) 754 双精度浮点算术关于上溢和下溢的行为。\n\n您必须处理标量线性测试问题 $$\\frac{dy}{dt}=\\lambda y,$$ 其中参数 $\\lambda\\in\\mathbb{R}$ 为常数，初始值为 $y(0)=y_0$。通过分离变量法得到的解析解为 $$y(t)=y_0 e^{\\lambda t}.$$ 在步长为 $h0$ 的均匀网格上应用前向显式欧拉方法，产生递推关系 $$y_{n+1}=y_n+h f(t_n,y_n)=y_n+h \\lambda y_n=(1+h\\lambda)\\,y_n,$$ 其中 $t_n=n h$。在有限精度算术中，如果 $|1+h\\lambda|1$ 且 $n$ 足够大，序列 $\\{y_n\\}$ 的量级会增长并超过 IEEE 754 双精度可表示的最大数，导致上溢为一个表示 $+\\infty$ 或 $-\\infty$ 的特殊值。相比之下，对于 $\\lambda  0$，解析解 $y(t)=y_0 e^{\\lambda t}$ 是有界的，并且当 $t\\to\\infty$ 时衰减到 $0$。您的程序必须演示这种现象并验证上溢条件。\n\n您的程序必须：\n- 使用标准的浮点类型，在 IEEE 754 双精度算术中实现显式欧拉方法更新 $y_{n+1}=(1+h\\lambda)\\,y_n$，$n=0,1,\\dots,N-1$。\n- 在欧拉迭代过程中，通过在每一步检查 $y_n$ 的有限性来检测数值上溢；将非有限值（无穷大或非数字）视作上溢。\n- 计算最终时间 $T=N h$ 时的解析值 $y(T)=y_0 e^{\\lambda T}$，并检查此解析值在 IEEE 754 双精度算术中是否是有限的（有界的）。\n- 对于每个测试用例，报告一个布尔值，指示欧拉迭代是否在上溢而解析解保持有界，即，当且仅当欧拉迭代在某一步产生了非有限值且解析值 $y(T)$ 是有限的时，报告 $\\text{True}$；否则报告 $\\text{False}$。\n\n使用以下测试套件，其旨在覆盖不同的行为：\n- 情况 1（不稳定的欧拉方法，上溢）：$\\lambda=-1000$, $y_0=1$, $h=0.01$, $N=400$。\n- 情况 2（稳定的欧拉方法，无上溢）：$\\lambda=-1$, $y_0=1$, $h=0.1$, $N=200$。\n- 情况 3（稳定性边界，无上溢）：$\\lambda=-1$, $y_0=1$, $h=2.0$, $N=1000$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,result_3]$），其中每个 $result_i$ 是按上述规定计算的布尔值。此问题不涉及物理单位，也不使用角度。所有参数和计算都是纯数值的。输出必须是确定性的，并且无需任何外部输入即可复现。", "solution": "该问题要求对一个特定的标量常微分方程 (ODE) 的前向显式欧拉方法进行分析，展示数值不稳定性如何在真实解析解有界的情况下导致上溢。我们将首先建立理论基础，然后将其应用于给定的测试用例。\n\n问题的核心是标量线性测试方程：\n$$\n\\frac{dy}{dt} = \\lambda y\n$$\n其中 $\\lambda$ 是一个实常数参数，初始条件为 $y(t=0) = y_0$。\n\n该常微分方程的解析解可以通过分离变量法找到：\n$$\n\\frac{dy}{y} = \\lambda dt \\implies \\int_{y_0}^{y(t)} \\frac{d\\tilde{y}}{\\tilde{y}} = \\int_0^t \\lambda d\\tilde{t} \\implies \\ln\\left(\\frac{y(t)}{y_0}\\right) = \\lambda t\n$$\n对两边取指数，得到精确解：\n$$\ny(t) = y_0 e^{\\lambda t}\n$$\n对于本问题中考虑的情况，$\\lambda  0$。在这种情况下，解析解 $y(t)$ 是一个指数衰减函数。当 $t \\to \\infty$ 时，$y(t) \\to 0$。对于任何有限时间 $T$，值 $y(T) = y_0 e^{\\lambda T}$ 是一个良定义的有限数。\n\n前向显式欧拉方法是用于近似常微分方程解的一种数值格式。它源自解 $y(t)$ 在时间 $t_n$ 附近的一阶泰勒级数展开：\n$$\ny(t_{n+1}) = y(t_n + h) \\approx y(t_n) + h y'(t_n)\n$$\n其中 $h$ 是时间步长。代入常微分方程 $y'(t_n) = f(t_n, y(t_n)) = \\lambda y(t_n)$，我们得到数值近似解 $y_n \\approx y(t_n)$ 的递推关系：\n$$\ny_{n+1} = y_n + h (\\lambda y_n) = (1 + h\\lambda) y_n\n$$\n这是一个几何级数。展开递推关系可得到 $y_n$ 的显式公式：\n$$\ny_n = (1 + h\\lambda)^n y_0\n$$\n数值解 $\\{y_n\\}$ 的行为完全取决于放大因子 $R = 1 + h\\lambda$。如果数值解的量级不无界增长，则认为它是稳定的。这当且仅当 $|R| \\le 1$ 时发生，这是前向欧拉方法对此测试问题的绝对稳定性条件。\n$$\n|1 + h\\lambda| \\le 1\n$$\n由于问题指定 $\\lambda  0$，我们可以将其写为：\n$$\n-1 \\le 1 + h\\lambda \\le 1\n$$\n右侧不等式 $1 + h\\lambda \\le 1$ 简化为 $h\\lambda \\le 0$，对于 $h > 0$ 和 $\\lambda  0$ 总是成立。关键条件来自左侧不等式：\n$$\n-1 \\le 1 + h\\lambda \\implies -2 \\le h\\lambda \\implies h \\le -\\frac{2}{\\lambda}\n$$\n如果步长 $h$ 违反此条件，即 $h > -2/\\lambda$，则该方法变得不稳定。在这种情况下，$1 + h\\lambda  -1$，因此放大因子 $R$ 的量级大于 $1$。数值解 $y_n = R^n y_0$ 将以指数增长的振幅振荡。在有限精度算术中，例如 IEEE 754 双精度，这种快速增长最终将导致 $|y_n|$ 的值超过可表示的最大有限数（约 $1.8 \\times 10^{308}$），导致数值上溢，通常表示为 `inf` 或 `-inf`。\n\n任务是识别出这种数值上溢（$y_n$ 变为非有限值）发生而解析解 $y(T)=y_0e^{\\lambda T}$ 保持有限的情况。这种现象凸显了一种纯粹的数值假象，其中所选的离散化（步长 $h$）不适用于问题的刚度（$\\lambda$ 的量级）。\n\n让我们分析给定的测试用例：\n\n情况 1：$\\lambda=-1000$, $y_0=1$, $h=0.01$, $N=400$。\n- 稳定性边界：$h \\le -2/\\lambda = -2/(-1000) = 0.002$。\n- 选择的步长为 $h=0.01$。由于 $0.01 > 0.002$，该方法是不稳定的。\n- 放大因子为 $R = 1 + (0.01)(-1000) = 1 - 10 = -9$。\n- 数值解为 $y_n = (-9)^n$。量级 $|y_n| = 9^n$ 增长得非常快。对于一个足够大的 $n  N$，$y_n$ 的值将会上溢。例如，$9^{324}$ 大于 $10^{308}$，因此上溢将在远未达到最终步 $N=400$ 之前发生。\n- 在最终时间 $T = N h = 400 \\times 0.01 = 4.0$ 时的解析解是 $y(4.0) = 1 \\cdot e^{-1000 \\times 4.0} = e^{-4000}$。这是一个极小的正数，它是有限且可表示的（在双精度中它会下溢到 $0.0$，但 $0.0$ 是一个有限数）。\n- 结论：欧拉方法上溢，而解析解是有限的。结果是 $\\text{True}$。\n\n情况 2：$\\lambda=-1$, $y_0=1$, $h=0.1$, $N=200$。\n- 稳定性边界：$h \\le -2/\\lambda = -2/(-1) = 2.0$。\n- 选择的步长为 $h=0.1$。由于 $0.1 \\le 2.0$，该方法是稳定的。\n- 放大因子为 $R = 1 + (0.1)(-1) = 0.9$。\n- 数值解为 $y_n = (0.9)^n$。由于 $|R|  1$，解会衰减到 $0$ 并且不会上溢。\n- 在 $T = N h = 200 \\times 0.1 = 20.0$ 时的解析解是 $y(20.0) = 1 \\cdot e^{-1 \\times 20.0} = e^{-20}$，这是一个虽小但有限的正数。\n- 结论：欧拉方法没有上溢，且解析解是有限的。结果是 $\\text{False}$。\n\n情况 3：$\\lambda=-1$, $y_0=1$, $h=2.0$, $N=1000$。\n- 稳定性边界：$h \\le -2/\\lambda = -2/(-1) = 2.0$。\n- 选择的步长为 $h=2.0$，正好在稳定性边界上。\n- 放大因子为 $R = 1 + (2.0)(-1) = -1$。\n- 数值解为 $y_n = (-1)^n y_0 = (-1)^n$。值将在 $1$ 和 $-1$ 之间交替。量级保持不变且不增长，因此不会发生上溢。\n- 在 $T = N h = 1000 \\times 2.0 = 2000.0$ 时的解析解是 $y(2000.0) = 1 \\cdot e^{-1 \\times 2000.0} = e^{-2000}$。这是一个极小的正数，在双精度算术中将计算为 $0.0$，这是一个有限值。\n- 结论：欧拉方法没有上溢，且解析解是有限的。结果是 $\\text{False}$。\n\n实现将遵循此逻辑，迭代欧拉步，检查非有限值，计算最终时间的解析解，并组合这些检查以产生所需的布尔输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(lambda_val, y0, h, N):\n    \"\"\"\n    Runs the forward Euler simulation for the ODE y' = lambda * y and checks for overflow.\n\n    Args:\n        lambda_val (float): The parameter lambda in the ODE.\n        y0 (float): The initial value y(0).\n        h (float): The time step size.\n        N (int): The number of steps.\n\n    Returns:\n        bool: True if Euler overflowed and the analytical solution is finite, False otherwise.\n    \"\"\"\n    # Use numpy.float64 for explicit IEEE 754 double-precision arithmetic.\n    y = np.float64(y0)\n    lambda_val_f64 = np.float64(lambda_val)\n    h_f64 = np.float64(h)\n\n    euler_overflowed = False\n    \n    # Calculate the amplification factor once.\n    amplification_factor = 1.0 + h_f64 * lambda_val_f64\n\n    # Perform the Euler iterations\n    for _ in range(N):\n        # Update the numerical solution\n        y = amplification_factor * y\n        \n        # Check for overflow (inf) or invalid number (nan)\n        if not np.isfinite(y):\n            euler_overflowed = True\n            break\n            \n    # Calculate the final time T\n    T = N * h_f64\n    \n    # Compute the analytical solution y(T) = y0 * exp(lambda * T)\n    # np.exp handles large negative exponents by underflowing to 0.0, which is finite.\n    analytical_val = np.float64(y0) * np.exp(lambda_val_f64 * T)\n    \n    # Check if the analytical solution is a finite number\n    analytical_is_finite = np.isfinite(analytical_val)\n    \n    # The problem asks to report True only if Euler overflowed AND the analytical solution is finite.\n    return euler_overflowed and analytical_is_finite\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases as tuples of (lambda, y0, h, N).\n    test_cases = [\n        # Case 1: Unstable Euler, should overflow\n        (-1000.0, 1.0, 0.01, 400),\n        # Case 2: Stable Euler, no overflow\n        (-1.0, 1.0, 0.1, 200),\n        # Case 3: Stability boundary, no overflow\n        (-1.0, 1.0, 2.0, 1000),\n    ]\n\n    results = []\n    for case in test_cases:\n        lambda_val, y0, h, N = case\n        result = run_simulation(lambda_val, y0, h, N)\n        # The output format requires lowercase booleans.\n        results.append(str(result).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3260938"}]}