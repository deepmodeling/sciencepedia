{"hands_on_practices": [{"introduction": "要真正掌握 IEEE 754 标准，最好的方法莫过于亲手解析其底层的二进制表示。这个练习将引导你扮演计算机的角色，通过位运算来解码一个给定的64位二进制模式。你将编写一个分类器，它能够判断任意一个比特序列所代表的究竟是正规数、非正规数、零、无穷大还是“非数”（NaN），从而深入理解指数和尾数字段如何共同定义一个浮点数的类型和值 [@problem_id:3240373]。", "problem": "你需要从基本原理出发，为电气与电子工程师协会 (IEEE) 754 binary64 编码（通常称为双精度）实现一个分类器。该分类器将以一组固定的无符号64位模式作为输入，并对每一个模式进行判断，确定其表示的是规格化有限数、非规格化数、带符号的零、带符号的无穷大，还是非数值 (NaN)。你必须从 binary64 的字段级定义出发，来阐明分类逻辑的合理性。\n\n从以下构成基本基础的核心定义开始：\n- 一个 binary64 数据由一个符号位 $s$（1 位）、一个指数场 $E$（11 位）和一个尾数场 $F$（52 位）组成。存储的指数使用 $1023$ 的偏置值。\n- 该编码根据标准组合 $s$、$E$ 和 $F$ 来定义数值解释。你的分类必须通过对这些字段定义以及指数场极端值 $E = 0$ 和 $E = 2^{11}-1$ 的含义进行推理得出。\n- 分类必须考虑到指数场全为零或全为一的边界情况，并且必须严格区分 $s$、$E$ 和 $F$ 的作用。\n\n你的程序必须：\n- 实现一个函数，该函数接收一个无符号64位整数模式，提取出 $s$、$E$ 和 $F$，并将数据分类为以下类别之一（编码为整数）：\n  - $0$: 规格化有限数\n  - $1$: 非规格化数\n  - $2$: $+0$\n  - $3$: $-0$\n  - $4$: $+\\infty$\n  - $5$: $-\\infty$\n  - $6$: NaN\n- 仅对64位模式进行位级操作；不要为了分类而将其转换为原生浮点数。\n\n在你的解决方案中解释每种分类是如何从 binary64 字段定义中得出的。特别是，解释 $E = 0$ 和 $E = 2^{11}-1$ 的边界情况，以及符号位 $s$ 如何只影响特定类别。\n\n测试套件：\n对以下十个以十六进制形式给出的无符号64位模式进行分类。根据 binary64 编码，将每个模式视为原始位模式。\n- `0x3FF0000000000000`\n- `0x0000000000000001`\n- `0x8000000000000001`\n- `0x0000000000000000`\n- `0x8000000000000000`\n- `0x7FF0000000000000`\n- `0xFFF0000000000000`\n- `0x7FF8000000000001`\n- `0x7FEFFFFFFFFFFFFF`\n- `0x0010000000000000`\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用逗号分隔的整数代码列表，顺序与测试套件相同，并用方括号括起来。例如，如果有三个测试用例，其代码分别为 $0$、$1$ 和 $6$，则输出将是 `[0,1,6]`。", "solution": "根据 IEEE 754 binary64 标准对给定的64位模式进行分类是一个明确定义的任务，它依赖于将位模式划分为三个不同的字段：符号位 ($s$)、指数场 ($E$) 和尾数场 ($F$)。位模式的解释由一组基于这些字段值的规则确定。该问题是有效的，因为它在科学上基于公认的 IEEE 754 标准，内容自洽，并为确定性分类提供了所有必要的信息。\n\n一个64位的 binary64 模式结构如下：\n- **符号位 ($s$)**: 1 位 (位 $63$)\n- **指数场 ($E$)**: 11 位 (位 $62$ 至 $52$)\n- **尾数场 ($F$)**: 52 位 (位 $51$ 至 $0$)\n\n给定模式所代表的数值 $v$ 是 $s$、$E$ 和 $F$ 的函数。将数值分类为规格化数、非规格化数、零、无穷大或非数值 (NaN)，主要取决于指数场 $E$ 的特殊值。$E$ 的两个关键情况是其所有位全为零 ($E=0$) 或全为一 ($E=2^{11}-1 = 2047$)。\n\n为了实现分类器，我们必须首先从给定的64位无符号整数模式（我们记为 $p$）中提取这三个字段。这可以通过位运算（掩码和右移）来实现。\n- 符号位 $s$ 是最高有效位 (MSB)。可以通过将模式右移 $63$ 位来提取：\n  $$s = (p \\gg 63) \\ 1$$\n- 指数场 $E$ 由接下来的 $11$ 位组成。我们可以通过先将模式右移 $52$ 位以移除尾数，然后应用一个掩码来仅保留结果的最低 $11$ 位，从而分离出这些位。$11$ 位的掩码是 $2^{11}-1$，十进制为 $2047$，十六进制为 $\\text{0x7FF}$。\n  $$E = (p \\gg 52) \\ \\text{0x7FF}$$\n- 尾数场 $F$ 包含最低有效的 $52$ 位。我们可以通过应用一个只保留这 $52$ 位的掩码来提取它。该掩码是 $2^{52}-1$，十六进制为 $\\text{0x000FFFFFFFFFFFFF}$。\n  $$F = p \\ \\text{0x000FFFFFFFFFFFFF}$$\n\n提取出 $s$、$E$ 和 $F$ 后，分类就按照 IEEE 754 标准定义的规则进行，这些规则构成了一个基于 $E$ 和 $F$ 值的决策树。\n\n**情况 1：$E$ 全为一 ($E = 2047$)**\n这种情况代表无穷大和 NaN 这两种特殊值。它们之间的选择取决于尾数场 $F$。\n- 如果 $F = 0$：该模式表示**无穷大**。无穷大的符号由符号位 $s$ 决定。\n    - 如果 $s=0$，则为正无穷大 ($+\\infty$)。这对应于代码 $4$。\n    - 如果 $s=1$，则为负无穷大 ($-\\infty$)。这对应于代码 $5$。\n    其值由 $v = (-1)^s \\times \\infty$ 给出。\n- 如果 $F \\neq 0$：该模式表示**非数值 (NaN)**。标准根据 $F$ 的最高有效位区分静默 NaN (qNaN) 和信号 NaN (sNaN)，但对于本问题，所有此类模式都简单地归类为 NaN。符号位 $s$ 是 NaN 负载的一部分，但不影响其作为 NaN 的分类。所有 $E=2047$ 且 $F \\neq 0$ 的模式都被归类为 NaN。这对应于代码 $6$。\n\n**情况 2：$E$ 全为零 ($E = 0$)**\n这种情况代表零和非规格化（或非正规化）数。区别基于尾数场 $F$。这些数的数值有不同的解释，其有效指数固定在最小值，且有效数中没有隐含的前导 $1$。\n- 如果 $F = 0$：该模式表示**零**。IEEE 754 标准包括正零和负零，由符号位 $s$ 区分。\n    - 如果 $s=0$，则为正零 ($+0$)。这对应于代码 $2$。\n    - 如果 $s=1$，则为负零 ($-0$)。这对应于代码 $3$。\n    其值为 $v = (-1)^s \\times 0$。\n- 如果 $F \\neq 0$：该模式表示**非规格化数**。这些数通过牺牲精度来实现渐进下溢。其值由 $v = (-1)^s \\times 2^{1-\\text{bias}} \\times (0.F)_2$ 给出，其中 $\\text{bias} = 1023$，而 $(0.F)_2$ 是将 $F$ 解释为二进制数的小数部分。符号由 $s$ 决定，但问题为所有非规格化数指定了一个单一类别。这对应于代码 $1$。\n\n**情况 3：$E$ 既不全为零也不全为一 ($0  E  2047$)**\n这是所有**规格化有限数**的情况。对于这些数，指数是通过从字段值 $E$ 中减去偏置值 $1023$ 来计算的。有效数（尾数场和隐含前导位的组合）是 $1.F$。规格化数的值由以下公式给出：\n$$v = (-1)^s \\times 2^{E-1023} \\times (1.F)_2$$\n符号位 $s$ 决定了数是正数还是负数，而字段 $E$ 和 $F$ 决定了其大小。然而，此范围内的所有数，无论其符号或大小如何，都属于“规格化有限数”这一个类别。这对应于代码 $0$。\n\n这套规则是完整且无歧义的，为 $2^{64}$ 种可能的位模式中的任意一种提供了唯一的分类。实现将直接遵循这一逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Classifies a set of IEEE 754 binary64 patterns and prints the results.\n    \"\"\"\n\n    def classify_binary64(pattern: np.uint64) - int:\n        \"\"\"\n        Classifies a 64-bit pattern according to IEEE 754 binary64 rules.\n\n        The classification logic is based on the field definitions:\n        - s: sign (1 bit)\n        - E: exponent (11 bits)\n        - F: fraction (52 bits)\n\n        The classification codes are:\n        - 0: normal finite\n        - 1: subnormal\n        - 2: +0\n        - 3: -0\n        - 4: +infinity\n        - 5: -infinity\n        - 6: NaN\n\n        Args:\n            pattern: An unsigned 64-bit integer representing the bit pattern.\n\n        Returns:\n            An integer code representing the classification.\n        \"\"\"\n        # Define masks to extract the fields from the 64-bit pattern.\n        # These are defined as uint64 to match the pattern type.\n        sign_mask = np.uint64(0x8000000000000000)\n        exponent_mask = np.uint64(0x7FF0000000000000)\n        fraction_mask = np.uint64(0x000FFFFFFFFFFFFF)\n\n        # Extract the sign bit 's'.\n        # s = 0 for positive, s = 1 for negative.\n        s = 1 if (pattern  sign_mask) != 0 else 0\n\n        # Extract the 11-bit exponent field 'E'.\n        # The exponent is bits 62-52. Shift right by 52.\n        E = np.uint64((pattern  exponent_mask)  np.uint64(52))\n\n        # Extract the 52-bit fraction field 'F'.\n        F = pattern  fraction_mask\n\n        # Maximum possible value for the 11-bit exponent field.\n        E_max = np.uint64(0x7FF)  # 2^11 - 1 = 2047\n\n        # Classification logic based on the values of E and F.\n\n        # Case 1: E is all ones (E = 2047). Special values: infinity or NaN.\n        if E == E_max:\n            if F == 0:\n                # Infinity\n                return 4 if s == 0 else 5  # +inf or -inf\n            else:\n                # Not-a-Number (NaN)\n                return 6\n\n        # Case 2: E is all zeros (E = 0). Special values: zero or subnormal.\n        elif E == 0:\n            if F == 0:\n                # Zero\n                return 2 if s == 0 else 3  # +0 or -0\n            else:\n                # Subnormal (denormalized) number\n                return 1\n\n        # Case 3: 0  E  2047. Normal finite numbers.\n        else:\n            return 0  # Normal finite number\n\n    # The test suite provided in the problem statement.\n    test_cases_hex = [\n        \"0x3FF0000000000000\", # 1.0 (normal)\n        \"0x0000000000000001\", # Smallest positive subnormal\n        \"0x8000000000000001\", # Smallest negative subnormal\n        \"0x0000000000000000\", # +0\n        \"0x8000000000000000\", # -0\n        \"0x7FF0000000000000\", # +infinity\n        \"0xFFF0000000000000\", # -infinity\n        \"0x7FF8000000000001\", # Quiet NaN\n        \"0x7FEFFFFFFFFFFFFF\", # Largest normal finite number\n        \"0x0010000000000000\", # Smallest positive normal number\n    ]\n\n    # Convert hex strings to numpy.uint64 integers.\n    test_cases = [np.uint64(int(h, 16)) for h in test_cases_hex]\n\n    # Classify each test case.\n    results = [classify_binary64(case) for case in test_cases]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3240373"}, {"introduction": "在学会如何“读”懂一个浮点数的二进制表示之后，下一步自然是学习如何“写”。这个练习将带你挑战一个看似简单但极具启发性的任务：将十进制小数 $0.2$ 转换为其最接近的 `binary64` 浮点数表示。你会发现，这个过程揭示了有限精度表示的内在局限性，并让你实践从基数转换、规格化到执行“舍入到最近，偶数优先”规则的全过程 [@problem_id:3240494]。", "problem": "一位工程师正在分析十进制小数如何在电气和电子工程师协会 (IEEE) 754 binary64 格式中表示和用于算术运算。在 binary64 中，一个规格化有限数由一个符号位 $s \\in \\{0,1\\}$、一个偏置值为 1023 的 11 位偏置指数 $E_{\\text{bias}} \\in \\{1,\\dots,2046\\}$，以及一个表示有效数 $1 + F/2^{52}$ 的 52 位小数域 $F \\in \\{0,1,\\dots,2^{52}-1\\}$ 编码。其值为\n$$\n(-1)^{s} \\left(1 + \\frac{F}{2^{52}}\\right) 2^{E_{\\text{bias}} - 1023},\n$$\n并且基本运算采用向最近值舍入、平局时取偶数的规则。\n\n仅使用这些定义以及基数转换和舍入的基本原理，完成以下任务：\n\n1. 确定十进制数 $0.2$ (即 $1/5$) 的精确 binary64 编码。确定符号位 $s$、11 位指数位和 52 位小数位，并给出这个 64 位字的合并后的 16 位十六进制编码。\n\n2. 现在考虑在 binary64 算术中计算 $5 \\times 0.2$。将该计算建模为：十进制字面量 $0.2$ 首先被转换为其精确的 binary64 值，然后乘以可精确表示的整数 $5$，最后根据“向最近值舍入，平局时取偶数”的规则进行一次舍入到 binary64 格式。假设精确的实数结果为 $1$。这个 binary64 计算的绝对误差是多少？其定义为 $\\left|\\operatorname{fl}(5 \\times 0.2) - 1\\right|$。\n\n给出所有推导过程。作为你的最终答案，仅报告绝对误差，它是一个实数。最终答案是精确值，无需舍入说明。", "solution": "该问题被评估为有效，因为其科学依据是 IEEE 754 标准，问题提法恰当、信息充分，并使用了客观、正式的语言。我们可以开始解题。\n\n该问题包含两个部分。首先，我们必须确定十进制数 $0.2$ 的 IEEE 754 binary64 表示。其次，我们必须计算浮点运算 $5 \\times 0.2$ 的绝对误差。\n\n### 第 1 部分：$0.2$ 的 Binary64 编码\n\n一个规格化的 binary64 数的值由公式 $v = (-1)^{s} \\left(1 + \\frac{F}{2^{52}}\\right) 2^{e}$ 给出，其中 $e = E_{\\text{bias}} - 1023$。\n\n1.  **转换为二进制：**\n    十进制数 $0.2$ 等价于分数 $\\frac{1}{5}$。为了将其转换为二进制，我们重复乘以 $2$ 并记录整数部分：\n    $0.2 \\times 2 = 0.4 \\implies 0$\n    $0.4 \\times 2 = 0.8 \\implies 0$\n    $0.8 \\times 2 = 1.6 \\implies 1$\n    $0.6 \\times 2 = 1.2 \\implies 1$\n    小数部分 $0.2$ 再次出现，因此二进制表示是一个循环小数：\n    $$0.2_{10} = 0.00110011..._{2} = 0.\\overline{0011}_{2}$$\n\n2.  **规格化：**\n    为了符合 IEEE 754 格式，我们将二进制数规格化为 $1.M \\times 2^e$ 的形式：\n    $$0.\\overline{0011}_{2} = 1.\\overline{1001}_{2} \\times 2^{-3}$$\n\n3.  **确定编码字段：**\n    -   **符号位 ($s$)：** 该数为正，所以 $s=0$。\n    -   **指数 ($e$)：** 真实指数为 $e = -3$。\n    -   **偏置指数 ($E_{\\text{bias}}$)：** 偏置值为 $1023$，则偏置指数为 $E_{\\text{bias}} = e + 1023 = -3 + 1023 = 1020$。在 11 位二进制中，其值为 $1020_{10} = 01111111100_{2}$。\n    -   **小数部分 ($F$)：** 有效数为 $1.\\overline{1001}_{2}$。小数域 $F$ 存储了隐含的前导 $1$ 之后的 52 位。未舍入的小数位是重复模式 `1001...` 的前 52 位，它由 13 次 `1001` 的重复组成。\n        $$1.\\underbrace{10011001...1001}_{52 \\text{ bits}} \\vert 1001...$$\n        第一个被截断的位（保护位，在第 53 位）是 $1$。后续的位（粘滞位）是 $001...$，它们不全为零。根据“向最近值舍入，平局时取偶数”的规则，当保护位为 $1$ 且粘滞位不全为零时，我们必须向上舍入（进位）。这涉及到对 52 位小数部分加 $1$。\n        未舍入的 52 位小数部分为 $(\\underbrace{1001...1001}_{13 \\text{ times}})_2$。对此二进制数加 $1$ 得：\n        $$(\\underbrace{1001...1001}_{12 \\text{ times}}1001)_2 + 1_2 = (\\underbrace{1001...1001}_{12 \\text{ times}}1010)_2$$\n        因此，小数域 $F$ 的最终 52 位是 12 次 `1001` 的重复，后跟 `1010`。\n\n4.  **组合成 64 位十六进制表示：**\n    我们将符号位、指数位和小数位连接起来：\n    -   符号位 (1位)：$0$\n    -   指数位 (11位)：$01111111100$\n    -   小数位 (52位)：$(1001)^{12}1010_2$\n\n    完整的 64 位字是：\n    $$0 \\underbrace{01111111100}_{\\text{指数}} \\underbrace{10011001...10011010}_{\\text{小数}}$$\n    从左到右将这些位分组为 4 位的半字节：\n    -   `0011` $\\rightarrow$ $3_{16}$\n    -   `1111` $\\rightarrow$ $F_{16}$\n    -   `1111` $\\rightarrow$ $F_{16}$\n    -   `1100` $\\rightarrow$ $C_{16}$\n    -   小数部分以 `1001` $\\rightarrow$ $9_{16}$ 开始。这个模式重复 12 次。\n    -   小数部分最后 4 位是 `1010` $\\rightarrow$ $A_{16}$。\n\n    合并后的 16 位十六进制编码是 `3FC999999999999A`。\n\n### 第 2 部分：$5 \\times 0.2$ 的绝对误差\n\n1.  **$\\operatorname{fl}(0.2)$ 的值：**\n    设 $x_{64} = \\operatorname{fl}(0.2)$ 是 $0.2$ 的 binary64 表示。其值由我们找到的字段决定。必须计算小数域 $F$ 的整数值。一种方法是意识到我们是从精确值向上舍入得到的。所需的精确有效数是 $1.6 = 1 + \\frac{3}{5}$。我们需要用 $\\frac{F}{2^{52}}$ 来近似 $\\frac{3}{5}$。\n    $$F \\approx \\frac{3}{5} \\times 2^{52}$$\n    精确值 $\\frac{3}{5} \\times 2^{52}$ 对于某个整数 $k$ 是 $k+0.6$。舍入到最近的整数得到 $k+1$。\n    $$F = \\text{round}\\left(\\frac{3}{5} \\times 2^{52}\\right) = \\left\\lfloor \\frac{3}{5} \\times 2^{52} \\right\\rfloor + 1 = \\frac{3 \\cdot 2^{52}-3}{5} + 1 = \\frac{3 \\cdot 2^{52}+2}{5}$$\n    $x_{64}$ 的值为：\n    $$x_{64} = \\left(1 + \\frac{F}{2^{52}}\\right) \\times 2^{-3} = \\left(1 + \\frac{(3 \\cdot 2^{52}+2)/5}{2^{52}}\\right) \\times 2^{-3}$$\n    $$x_{64} = \\left(1 + \\frac{3}{5} + \\frac{2}{5 \\cdot 2^{52}}\\right) \\times 2^{-3} = \\left(\\frac{8}{5} + \\frac{2}{5 \\cdot 2^{52}}\\right) \\times 2^{-3}$$\n    $$x_{64} = \\frac{8}{5 \\cdot 2^3} + \\frac{2}{5 \\cdot 2^{52} \\cdot 2^3} = \\frac{1}{5} + \\frac{2}{5 \\cdot 2^{55}} = \\frac{1}{5} + \\frac{1}{5 \\cdot 2^{54}}$$\n    因此，存储的值略大于 $0.2$ 的真实值。\n\n2.  **$\\operatorname{fl}(5)$ 的值：**\n    整数 $5$ 表示为 $5_{10} = 101_2 = 1.01_2 \\times 2^2$。这可以在 binary64 中精确表示，因为有效数只需要 3 位。因此，$\\operatorname{fl}(5) = 5$。\n\n3.  **执行乘法：**\n    该计算被建模为对 $\\operatorname{fl}(5)$ 和 $\\operatorname{fl}(0.2)$ 的精确乘积进行舍入。\n    设 $P$ 为精确乘积：\n    $$P = 5 \\times x_{64} = 5 \\times \\left(\\frac{1}{5} + \\frac{1}{5 \\cdot 2^{54}}\\right) = 1 + \\frac{5}{5 \\cdot 2^{54}} = 1 + 2^{-54}$$\n\n4.  **舍入乘积：**\n    我们必须将结果 $P = 1 + 2^{-54}$ 舍入到最接近的 binary64 数。数字 $1$ 是可以精确表示的。下一个更大的可表示数具有相同的指数 ($e=0$)，并且其小数域是最小的非零值，即 $1$。其有效数是 $1+2^{-52}$。\n    围绕 $P$ 的两个 binary64 数是：\n    -   $N_1 = 1$，其有效数为 $1.0$，指数为 $0$。\n    -   $N_2 = 1+2^{-52}$，其有效数为 $1.0...01$，指数为 $0$。\n\n    为了使用向最近值舍入的规则，我们将 $P$ 与 $N_1$ 和 $N_2$ 之间的中点 $M$ 进行比较：\n    $$M = \\frac{N_1 + N_2}{2} = \\frac{1 + (1+2^{-52})}{2} = 1 + \\frac{2^{-52}}{2} = 1 + 2^{-53}$$\n    我们将我们的乘积 $P$ 与这个中点进行比较：\n    $$P = 1 + 2^{-54}$$\n    因为 $2^{-54}  2^{-53}$，所以我们有 $P  M$。值 $P$ 比起 $N_2 = 1+2^{-52}$ 更接近 $N_1 = 1$。\n    因此，计算的最终舍入结果是：\n    $$\\operatorname{fl}(5 \\times 0.2) = \\operatorname{round}(1 + 2^{-54}) = 1$$\n\n5.  **计算绝对误差：**\n    问题要求计算计算结果与精确的数学结果（即 $1$）之间的绝对误差。\n    $$\\text{绝对误差} = |\\operatorname{fl}(5 \\times 0.2) - 1| = |1 - 1| = 0$$", "answer": "$$\\boxed{0}$$", "id": "3240494"}, {"introduction": "理解了浮点数的表示和舍入机制后，我们可以进一步探究其对算术运算的深刻影响。这个练习通过一个巧妙的思维实验，让你计算当与 $1.0$ 相加时，因精度限制而被“吸收”掉的最大正浮点数是多少。这个值，即单位舍入误差，是衡量浮点系统精度的核心指标，它精确地揭示了浮点数轴的离散特性以及算术运算中不可避免的精度损失 [@problem_id:3240413]。", "problem": "考虑在电气和电子工程师协会 (IEEE) 754 binary32 格式下，使用默认的舍入模式（即向最近偶数舍入）进行加法运算。一个规格化的 binary32 数的形式为 $m \\times 2^{E}$，其中 $m \\in [1,2)$ 且具有一个 $23$ 位的小数部分，$E$ 是一个整数指数，偏置为 $127$。令 $1.0$ 表示 $m = 1$ 和 $E = 0$ 的 binary32 数。定义 $x$ 为一个正的、有限的 binary32 数。仅使用 binary32 表示的结构特性和上述舍入规则，确定满足以下条件的最大 $x$：在 binary32 算术中计算 $1.0 + x$ 得到的最终舍入结果为 $1.0$。将你的答案表示为 2 的精确幂。此外，给出该值在标准数值分析中的术语名称。最终的数值必须写成一个单一的精确表达式；不需要舍入。", "solution": "用户希望找到最大的正有限 IEEE 754 binary32 数 $x$，使得在使用 binary32 算术和向最近偶数舍入模式执行运算 $1.0 + x$ 时，结果为 $1.0$。\n\n首先，我们分析 IEEE 754 binary32 格式中数字的表示方法。一个规格化数的形式为 $(-1)^s \\times m \\times 2^E$，其中 $s$ 是符号位，$m$ 是有效数（或尾数），$E$ 是指数。\n对于 binary32：\n- 有效数 $m$ 的精度为 $p=24$ 位（1 个隐含的前导位和 23 个显式的小数位）。对于一个规格化数，$m$ 的形式为 $1.f$，其中 $f$ 是 $23$ 位的小数部分，因此 $m \\in [1, 2)$。\n- 指数 $E$ 以偏置形式存储，偏置为 $127$。规格化数的真实指数 $E$ 的有效范围是 $[-126, 127]$。\n\n数字 $1.0$ 在此格式中表示。其值为 $1.0 \\times 2^0$。\n- 符号为正，所以 $s=0$。\n- 指数为 $E=0$。存储的偏置指数为 $0+127=127$。\n- 有效数为 $m=1.0$。在二进制中，这是 $1.000...0_2$。隐含位是 $1$，而 $23$ 个小数位全为 $0$。我们将 $1.0$ 的有效数记为 $m_1$。\n$m_1 = 1.\\underbrace{000...000}_{23 \\text{ bits}}$\n\n问题要求 $1.0$ 和 $x$ 的计算和能舍入回 $1.0$。将此计算和表示为 $\\text{fl}(1.0+x)$。我们在寻找最大的可表示数 $x  0$，使得 $\\text{fl}(1.0+x) = 1.0$。\n\n舍入模式是“向最近偶数舍入”。这意味着精确结果会被舍入到最近的可表示浮点数。如果精确结果恰好在两个可表示数的中间，它会被舍入到有效数最低有效位 (LSB) 为 $0$ 的那个（即“偶数”那个）。\n\n让我们确定与此问题相关的两个可表示数：\n1.  数字 $y_1 = 1.0$。\n2.  大于 $1.0$ 的下一个可表示数，我们称之为 $y_2$。\n\n为了找到 $y_2$，我们增加 $y_1$ 有效数的最低有效位。$23$ 位小数部分的最低有效位对应的值是 $2^{-23}$。\n所以，$y_2 = 1.0 + 2^{-23}$。\n其有效数为 $m_2 = 1.\\underbrace{000...001}_{23 \\text{ bits}}$。\n\n为了使运算结果舍入到 $y_1=1.0$，精确结果必须比 $y_2$ 更接近 $y_1$，或者恰好在中间点。让我们找到 $y_1$ 和 $y_2$ 之间的中点 $M$：\n$$M = \\frac{y_1 + y_2}{2} = \\frac{1.0 + (1.0 + 2^{-23})}{2} = \\frac{2.0 + 2^{-23}}{2} = 1.0 + 2^{-24}$$\n\n根据舍入规则：\n- 如果精确和 $1.0+x  M$，则向下舍入到 $y_1=1.0$。\n- 如果精确和 $1.0+x > M$，则向上舍入到 $y_2=1.0+2^{-23}$。\n- 如果精确和 $1.0+x = M$，则出现平局。在这种情况下，我们舍入到“偶数”。$y_1=1.0$ 的有效数以 $0$ 结尾，而 $y_2=1.0+2^{-23}$ 的有效数以 $1$ 结尾。因此，$y_1$ 是“偶数”，结果向下舍入到 $1.0$。\n\n综合这些条件，要使 $\\text{fl}(1.0+x)$ 为 $1.0$，精确和必须满足：\n$$1.0 + x \\le M$$\n$$1.0 + x \\le 1.0 + 2^{-24}$$\n这可以简化为：\n$$x \\le 2^{-24}$$\n\n问题要求的是满足此条件的最大的*可表示的 binary32 数* $x$。我们必须检查 $2^{-24}$ 本身是否是一个可表示的 binary32 数。\n我们可以将 $2^{-24}$ 写成规格化形式 $m \\times 2^E$：\n$$2^{-24} = 1.0 \\times 2^{-24}$$\n- 有效数是 $m=1.0$。这是一个规格化数的有效有效数（隐含位为 $1$，小数部分全为零）。\n- 指数是 $E=-24$。偏置指数为 $E_{biased} = -24 + 127 = 103$。该值在规格化数偏置指数的有效范围 $[1, 254]$ 之内。\n\n由于 $2^{-24}$ 是一个有效的规格化 binary32 数，并且我们要求 $x \\le 2^{-24}$，其中 $x$ 也必须是一个可表示的数，因此 $x$ 的最大可能值恰好是 $2^{-24}$。\n\n问题还要求该值在标准数值分析中的术语名称。这个值代表了 $1.0$ 与下一个可表示数之间间距的一半，被称为**单位舍入误差 (unit roundoff)**。它通常用 $u$ 表示。对于一个基数为 $\\beta$、精度为 $p$ 并使用向最近舍入的浮点系统，单位舍入误差定义为 $u = \\frac{1}{2}\\beta^{1-p}$。对于 binary32，$\\beta=2$ 且 $p=24$，所以 $u = \\frac{1}{2}(2)^{1-24} = 2^{-1} \\cdot 2^{-23} = 2^{-24}$。这个值表示将一个数舍入到最近的浮点表示时可能产生的最大相对误差。它是机器 epsilon $\\epsilon = 2^{-23}$ 的一半。\n\n因此，满足条件的最大 $x$ 是 $2^{-24}$。", "answer": "$$\\boxed{2^{-24}}$$", "id": "3240413"}]}