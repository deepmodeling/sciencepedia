{"hands_on_practices": [{"introduction": "循环是编程中的基本构件。我们通常期望一个通过迭代累加一个小的正数来实现递增的循环最终能够达到一个目标值。然而，在浮点数的世界里，这并非总是如此。[@problem_id:3250049] 这个实践将引导你编写一个程序，该程序会因为浮点数的精度限制而陷入无限循环。通过这个练习，你将亲身体验到，当增量相对于当前数值的“末位单位”(ULP)过小时，加法操作将无法改变数值，从而揭示了在循环条件中直接使用浮点数相等性判断的潜在风险。", "problem": "您必须编写一个完整、可运行的程序，该程序能演示并检测由于机器 epsilon 在接近相等时的影响，导致其条件使用浮点数相等性的循环出现不终止的情况。请在符合电气与电子工程师协会（IEEE）754 标准的标准二进制浮点模型下工作，使用向最近取整、偶数优先的舍入规则。从以下基础出发：\n\n- 机器 epsilon 的定义：最小的正实数 $\\varepsilon_{\\mathrm{mach}}$，使得在浮点算术中，$\\mathrm{fl}(1 + \\varepsilon_{\\mathrm{mach}}) \\neq 1$。\n- 末位单位（ULP）：对于给定的浮点数 $a$，到下一个更大的可表示浮点数的距离，记为 $\\mathrm{ulp}(a)$，即 $\\mathrm{nextafter}(a,+\\infty) - a$，这是浮点分析中一个经过广泛验证的事实。\n- 向最近取整，偶数优先：给定一个实数 $z$ 正好位于两个可表示的浮点数 $z_{-}$ 和 $z_{+}$ 的中间，舍入后的值是其尾数最低有效位为偶数的那个。\n\n您的程序将模拟一系列简单的更新循环，形式如下：\n- 初始化 $x \\leftarrow x_{0}$，\n- 固定一个目标值 $y$ 和一个常数增量 $\\delta  0$，\n- 迭代 $x \\leftarrow \\mathrm{fl}(x + \\delta)$ 直到条件 $x = y$ 满足。\n\n在精确的实数算术中，如果 $x_{0}  y$ 且 $\\delta  0$，则存在一个整数 $k$ 使得 $x_{0} + k \\delta = y$。然而，在浮点算术中，如果当前 $x$ 处的 $\\delta$ 小于 $\\frac{1}{2}\\,\\mathrm{ulp}(x)$，则 $\\mathrm{fl}(x + \\delta) = x$，循环将无法取得进展。特别地，如果 $x \\neq y$ 且 $\\mathrm{fl}(x + \\delta) = x$，那么循环体无法改变 $x$，循环条件 $x \\neq y$ 将永远为真，因此循环不终止。\n\n您的程序必须执行以下任务：\n\n1) 通过第一性原理的对半查找过程计算工作浮点类型的机器 epsilon $\\varepsilon_{\\mathrm{mach}}$。不要为 $\\varepsilon_{\\mathrm{mach}}$ 硬编码一个常数。\n2) 实现一个函数来计算任意有限数 $a$ 的 $\\mathrm{ulp}(a)$，定义为 $\\left|\\mathrm{nextafter}(a,+\\infty) - a\\right|$。\n3) 为循环“while $x \\neq y$ do $x \\leftarrow \\mathrm{fl}(x + \\delta)$”实现一个模拟器，其行为如下：\n   - 如果在一次迭代的开始时 $x = y$，则声明循环终止。\n   - 否则，计算 $x_{\\text{new}} \\leftarrow \\mathrm{fl}(x + \\delta)$。\n   - 如果 $x_{\\text{new}} = x$ 且 $x \\neq y$，则声明循环因状态停滞且循环条件保持为真而无法终止。\n   - 此外，通过在达到一个大的固定迭代次数 $N_{\\max}$ 后停止来防范病态情况，并在这种情况下声明不终止。您可以取 $N_{\\max} = 10^{7}$。\n4) 对于下面的每个测试用例，构造指定的 $x_{0}$、$y$ 和 $\\delta$，并报告一个布尔值，指示循环是终止（true）还是被停滞规则或迭代上限检测为不终止（false）。\n\n测试套件规范：\n\n令 $\\mathrm{prev}(a)$ 表示严格小于 $a$ 的最大可表示浮点数，即对于 $a  0$，$\\mathrm{prev}(a) = \\mathrm{nextafter}(a,0)$。\n\n为以下五个用例提供结果：\n\n- 用例 A（在接近 1 时因停滞而不终止）：$y = 1$，$x_{0} = \\mathrm{prev}(y)$，且 $\\delta = \\frac{1}{4}\\,\\mathrm{ulp}(y)$。预期行为：由于在 $x = x_{0}$ 时 $\\delta  \\frac{1}{2}\\,\\mathrm{ulp}(x)$，舍入导致 $\\mathrm{fl}(x + \\delta) = x$，因此当 $x \\neq y$ 时无法取得进展。\n- 用例 B（通过中点舍入在一次迭代中终止）：$y = 1$，$x_{0} = \\mathrm{prev}(y)$，且 $\\delta = \\frac{1}{2}\\,\\mathrm{ulp}(y)$。预期行为：由于向偶数舍入规则，$\\mathrm{fl}(x + \\delta)$ 会舍入到 $y$，因此循环在下一次条件检查时终止。\n- 用例 C（立即终止）：$y = 1$，$x_{0} = 1$，且 $\\delta = \\frac{1}{4}\\,\\mathrm{ulp}(y)$。预期行为：由于初始时 $x = y$，循环不会进入。\n- 用例 D（在数值较大时因增量过小而不终止）：$y = 2^{30}$，$x_{0} = \\mathrm{prev}(y)$，且 $\\delta = \\frac{1}{4}\\,\\mathrm{ulp}(1)$。预期行为：由于 $\\mathrm{ulp}(y) \\gg \\mathrm{ulp}(1)$，在 $x \\approx y$ 时有 $\\delta \\ll \\frac{1}{2}\\,\\mathrm{ulp}(x)$，因此 $\\mathrm{fl}(x + \\delta) = x$，循环无法取得进展。\n- 用例 E（在数值较大时通过足够大的增量终止）：$y = 2^{30}$，$x_{0} = \\mathrm{prev}(y)$，且 $\\delta = \\frac{1}{2}\\,\\mathrm{ulp}(y)$。预期行为：与用例 B 类似，一步操作就将 $x$ 移动到 $y$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。对于从 A 到 E 的五个用例，按顺序输出一个布尔值列表，例如，“[True,False,True,False,True]”。输出行中不得有任何额外文本。", "solution": "该问题要求研究浮点算术的特性，特别是其离散性如何导致依赖相等性检查的循环不终止。我们将构建一个程序来演示这一现象，方法是实现一个基于第一性原理的机器 epsilon 计算、一个用于计算末位单位（ULP）的函数，以及一个简单迭代循环的模拟器。分析基于二进制浮点算术的 IEEE 754 标准，使用向最近的可表示值舍入，当出现平局时则舍入到尾数最低有效位为偶数的值。\n\n问题的核心在于更新步骤 $x \\leftarrow \\mathrm{fl}(x + \\delta)$，其中 $\\mathrm{fl}(\\cdot)$ 表示一个实数的浮点表示。由于浮点数的精度有限，任何数 $x$ 与下一个更大的可表示数之间都存在一个最小间隙。这个间隙被称为末位单位，即 $\\mathrm{ulp}(x)$。如果增量 $\\delta$相对于此间隙过小，和 $x + \\delta$ 可能会被舍入回 $x$，导致循环停滞。\n\n分步解决方案如下：\n\n首先，我们必须计算工作浮点类型（我们在此使用64位双精度浮点数）的机器 epsilon，即 $\\varepsilon_{\\mathrm{mach}}$。$\\varepsilon_{\\mathrm{mach}}$ 被定义为满足 $\\mathrm{fl}(1 + \\varepsilon_{\\mathrm{mach}}) \\neq 1$ 的最小正数。它等价于 $\\mathrm{ulp}(1)$。我们可以通过算法确定 $\\varepsilon_{\\mathrm{mach}}$，方法是从一个值（比如 $\\varepsilon = 1$）开始，并反复将其减半。只要 `epsilon` 足够大，在加到 1 上时能被识别，循环 `while (1.0 + epsilon)  1.0` 就会继续。当 `1.0 + epsilon` 被向下舍入为 $1.0$ 时，循环终止。如果循环终止时 `epsilon` 的最终值为 $\\varepsilon_{f}$，这意味着 $\\mathrm{fl}(1 + \\varepsilon_{f}) = 1$，而之前的值 $2\\varepsilon_{f}$ 满足 $\\mathrm{fl}(1 + 2\\varepsilon_{f})  1$。因此，$\\varepsilon_{\\mathrm{mach}} = 2\\varepsilon_{f}$。\n\n其次，我们实现一个函数来计算浮点数 $a$ 的 $\\mathrm{ulp}(a)$。根据规定，这是到下一个更大的可表示浮点数的距离。它由表达式 $\\mathrm{ulp}(a) = |\\mathrm{nextafter}(a, +\\infty) - a|$ 给出。$\\mathrm{ulp}(a)$ 的值不是恒定的；它随 $a$ 的量级而变化。具体来说，对于一个在范围 $[2^k, 2^{k+1})$ 内的数 $a$，其 ULP 由 $\\mathrm{ulp}(a) = 2^k \\varepsilon_{\\mathrm{mach}}$ 给出。\n\n第三，我们分析循环停滞的条件。和 $x + \\delta$ 是一个必须舍入为可表示的浮点值的实数。最接近 $x$ 的可表示数是 $x$ 本身和 $\\mathrm{nextafter}(x, +\\infty) = x + \\mathrm{ulp}(x)$。这两者之间的中点是 $x + \\frac{1}{2}\\mathrm{ulp}(x)$。“向最近取整”规则规定：\n- 如果 $x + \\delta  x + \\frac{1}{2}\\mathrm{ulp}(x)$，和将被向下舍入到 $x$。这等价于 $\\delta  \\frac{1}{2}\\mathrm{ulp}(x)$。\n- 如果 $x + \\delta > x + \\frac{1}{2}\\mathrm{ulp}(x)$，和将被向上舍入到 $\\mathrm{nextafter}(x, +\\infty)$。这等价于 $\\delta > \\frac{1}{2}\\mathrm{ulp}(x)$。\n- 如果 $x + \\delta = x + \\frac{1}{2}\\mathrm{ulp}(x)$，和正好在中间。此时应用“偶数优先”规则，舍入到尾数最低有效位为 0 的那个邻近值。\n\n如果 $\\delta  \\frac{1}{2}\\mathrm{ulp}(x)$，则 $\\mathrm{fl}(x + \\delta) = x$。如果此时 $x \\neq y$，循环变量将不再改变，终止条件 $x=y$ 永远不会满足，导致无限循环。我们的模拟器必须检测到这种停滞。它还将包括一个 $N_{\\max} = 10^7$ 次迭代的安全限制。\n\n第四，我们设计循环模拟器函数。它接受初始值 $x_0$、$y$ 和 $\\delta$。它进行迭代，更新 $x \\leftarrow \\mathrm{fl}(x + \\delta)$。在每次迭代中，它首先检查是否 $x=y$（终止），然后计算新值 $x_{\\text{new}}$，最后检查是否 $x_{\\text{new}} = x$（停滞）。如果循环完成了 $N_{\\max}$ 次迭代而两个条件都未满足，它也被声明为不终止。\n\n最后，我们将此框架应用于五个指定的测试用例。我们记 $\\mathrm{prev}(a) = \\mathrm{nextafter}(a, 0)$ for $a>0$。\n\n用例 A：$y = 1$，$x_{0} = \\mathrm{prev}(y)$，且 $\\delta = \\frac{1}{4}\\,\\mathrm{ulp}(y)$。\n此处，$y=1$，所以 $\\mathrm{ulp}(y) = \\mathrm{ulp}(1) = \\varepsilon_{\\mathrm{mach}}$。增量为 $\\delta = \\frac{1}{4}\\varepsilon_{\\mathrm{mach}}$。初始值为 $x_0 = \\mathrm{prev}(1)$，非常接近于 1，所以 $\\mathrm{ulp}(x_0) \\approx \\mathrm{ulp}(1) = \\varepsilon_{\\mathrm{mach}}$。停滞条件为 $\\delta  \\frac{1}{2}\\mathrm{ulp}(x_0)$，即 $\\frac{1}{4}\\varepsilon_{\\mathrm{mach}}  \\frac{1}{2}\\varepsilon_{\\mathrm{mach}}$。这是成立的。因此，$\\mathrm{fl}(x_0 + \\delta) = x_0$。循环在第一次迭代时就停滞了。结果是不终止（False）。\n\n用例 B：$y = 1$，$x_{0} = \\mathrm{prev}(y)$，且 $\\delta = \\frac{1}{2}\\,\\mathrm{ulp}(y)$。\n此处，$\\delta = \\frac{1}{2}\\varepsilon_{\\mathrm{mach}}$。值 $x_0 + \\delta$ 正好在 $x_0$ 和 $y=1$ 的中间。我们必须应用“偶数优先”规则。数字 $1.0$ 的表示中，其尾数的最低有效位为 0（偶数）。数字 $x_0 = \\mathrm{prev}(1)$ 的尾数最低有效位为 1（奇数）。舍入到“偶数”邻近值，即 $y=1$。因此，$\\mathrm{fl}(x_0 + \\delta) = y$。循环在一次迭代后终止。结果是终止（True）。\n\n用例 C：$y = 1$，$x_{0} = 1$，且 $\\delta = \\frac{1}{4}\\,\\mathrm{ulp}(y)$。\n初始条件为 $x_0 = y$。循环条件 `while x != y` 从一开始就为假。循环体永远不会执行。结果是立即终止（True）。\n\n用例 D：$y = 2^{30}$，$x_{0} = \\mathrm{prev}(y)$，且 $\\delta = \\frac{1}{4}\\,\\mathrm{ulp}(1)$。\n目标 $y = 2^{30}$ 是一个大数。其 ULP 显著大于 1 的 ULP：$\\mathrm{ulp}(y) = \\mathrm{ulp}(2^{30}) = 2^{30}\\mathrm{ulp}(1) = 2^{30}\\varepsilon_{\\mathrm{mach}}$。增量为 $\\delta = \\frac{1}{4}\\mathrm{ulp}(1) = \\frac{1}{4}\\varepsilon_{\\mathrm{mach}}$。当前值为 $x_0 \\approx y$，所以 $\\mathrm{ulp}(x_0) \\approx \\mathrm{ulp}(y)$。停滞条件 $\\delta  \\frac{1}{2}\\mathrm{ulp}(x_0)$ 变为 $\\frac{1}{4}\\varepsilon_{\\mathrm{mach}}  \\frac{1}{2}(2^{30}\\varepsilon_{\\mathrm{mach}})$，即 $\\frac{1}{4}  2^{29}$。这显然是成立的。在此量级下，增量太小以至于没有任何效果。循环停滞。结果是不终止（False）。\n\n用例 E：$y = 2^{30}$，$x_{0} = \\mathrm{prev}(y)$，且 $\\delta = \\frac{1}{2}\\,\\mathrm{ulp}(y)$。\n这类似于用例 B，但在更大的量级上。增量 $\\delta = \\frac{1}{2}\\mathrm{ulp}(y)$ 将和 $x_0 + \\delta$ 置于 $x_0$ 和 $y$ 的正中间。数字 $y=2^{30}$ 是 2 的幂，其尾数的最低有效位是偶数。数字 $x_0 = \\mathrm{prev}(y)$ 的最低有效位是奇数。舍入到偶数邻近值 $y$。循环在一步内终止。结果是终止（True）。\n\n预期的结果是 [False, True, True, False, True]。以下程序将此分析形式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by setting up and running simulations for the five\n    specified test cases and printing the results.\n    \"\"\"\n\n    def compute_machine_epsilon():\n        \"\"\"\n        Computes machine epsilon for float64 using a first-principles halving procedure.\n        Machine epsilon is the smallest positive number eps such that 1.0 + eps != 1.0.\n        \"\"\"\n        # Start with a value that is guaranteed to be significant when added to 1.\n        epsilon = np.float64(1.0)\n        # Repeatedly halve epsilon until 1.0 + epsilon is indistinguishable from 1.0.\n        while np.float64(1.0) + epsilon > np.float64(1.0):\n            epsilon /= np.float64(2.0)\n        # The loop terminates when epsilon is too small. The machine epsilon is the\n        # previous value of epsilon, which is the current value multiplied by 2.\n        return epsilon * np.float64(2.0)\n\n    def compute_ulp(a: np.float64) -> np.float64:\n        \"\"\"\n        Computes the Unit in the Last Place (ULP) for a given float64 number 'a'.\n        Defined as the distance to the next larger representable floating-point number.\n        \"\"\"\n        # Ensure input is a float64 for consistent calculations.\n        a = np.float64(a)\n        # Use np.inf to find the next representable number in the positive direction.\n        # np.nextafter handles negative numbers and special cases correctly.\n        return np.abs(np.nextafter(a, np.inf) - a)\n\n    def simulate_loop(x0: np.float64, y: np.float64, delta: np.float64) -> bool:\n        \"\"\"\n        Simulates the loop 'while x != y: x = x + delta' and detects non-termination.\n\n        Returns:\n            bool: True if the loop terminates, False otherwise.\n        \"\"\"\n        N_MAX = 10**7\n        x = np.float64(x0)\n        y = np.float64(y)\n        delta = np.float64(delta)\n\n        for _ in range(N_MAX):\n            # Condition 1: Loop terminates if x reaches the target y.\n            if x == y:\n                return True\n\n            # Perform one step of the iteration.\n            x_new = x + delta\n\n            # Condition 2: Non-termination due to stagnation.\n            # If the value of x does not change, and x is not at the target,\n            # the loop will never terminate.\n            if x_new == x:\n                return False\n\n            x = x_new\n\n        # Condition 3: Non-termination due to exceeding max iterations.\n        return False\n\n    # Define a helper for prev(a) as specified in the problem\n    def prev(a: np.float64) -> np.float64:\n        return np.nextafter(a, np.float64(0.0))\n\n    # --- Test Case Construction ---\n    \n    # Common helper values\n    y1 = np.float64(1.0)\n    ulp1 = compute_ulp(y1)\n    \n    y2 = np.float64(2**30)\n    ulp2 = compute_ulp(y2)\n\n    test_cases = [\n        # Case A: Non-terminating by stagnation near one\n        (prev(y1), y1, np.float64(0.25) * ulp1),\n        \n        # Case B: Terminating in one iteration by midpoint rounding\n        (prev(y1), y1, np.float64(0.5) * ulp1),\n        \n        # Case C: Immediate termination\n        (y1, y1, np.float64(0.25) * ulp1),\n        \n        # Case D: Non-terminating at large magnitude with too-small increment\n        (prev(y2), y2, np.float64(0.25) * ulp1),\n        \n        # Case E: Terminating at large magnitude by adequate increment\n        (prev(y2), y2, np.float64(0.5) * ulp2),\n    ]\n\n    results = []\n    for x0, y, delta in test_cases:\n        terminates = simulate_loop(x0, y, delta)\n        results.append(terminates)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3250049"}, {"introduction": "计算像 $e^x - 1$ 这样的数学函数看似简单直接，但在数值计算中却隐藏着陷阱。[@problem_id:3250061] 这个实践将带你探索当 $x$ 趋近于零时，直接计算 $\\exp(x) - 1$ 如何导致“灾难性抵消”（catastrophic cancellation）——一种由于两个几乎相等的数相减而造成巨大相对误差的现象。你将通过编程找到朴素计算开始失效的临界点，并将其与经过优化的库函数（如 `expm1`）的精确结果进行对比，从而深刻理解数值稳定算法的重要性。", "problem": "您的任务是分析在浮点运算中计算实值映射 $x \\mapsto e^x - 1$ 函数值的数值稳定性。目标是检测在浮点运算中朴素地计算 $e^x - 1$ 为 $\\exp(x) - 1$ 何时会遭受灾难性抵消，并将其与一个无抵消地计算相同函数的数值稳定替代方法进行比较。\n\n您的推理应基于以下基本概念。\n- 标准双精度格式下的浮点舍入到最近、偶数取中规则，以及实数 $x$ 的指数函数 $x \\mapsto e^x$ 的单调性。\n- 机器 epsilon 的定义：在目标格式中，满足 $1 + \\varepsilon  1$ 的最小正浮点数 $\\varepsilon$。\n- 对于较小的 $x$，实数 $e^x$ 等于 $1 + x + \\frac{x^2}{2} + \\cdots$，因此满足 $e^x - 1 \\approx x$。\n- 灾难性抵消现象：两个几乎相等的浮点数相减会抹去前面的有效数字，从而导致巨大的相对误差。\n\n您的程序必须使用双精度浮点运算（即由 Numerical Python 库提供的语言标准64位浮点数）实现以下内容。\n1. 通过迭代减半法计算该浮点类型的机器 epsilon $\\varepsilon$。将结果表示为 $\\hat{\\varepsilon}$。\n2. 确定一个正实数 $x$，使得在浮点运算中，使用 $\\exp(x) - 1$ 对 $e^x - 1$ 进行的朴素浮点计算恰好返回 $0$。（具体来说，是找到使计算出的朴素差值保持为零的最大 $x$）。形式上，找到上确界 $x_{\\mathrm{crit}}  0$，使得在所选的浮点类型中，$\\exp(x) - 1 = 0$ 成立。使用单调性和二分搜索，在浮点类型的分辨率内近似 $x_{\\mathrm{crit}}$。\n3. 对于相同的 $x_{\\mathrm{crit}}$，计算一个为小 $x$ 设计的 $e^x - 1$ 的无抵消实现所产生的值。将此值表示为 $y_{\\mathrm{alt}}(x_{\\mathrm{crit}})$。该函数应为语言或库提供的实现，以避免在零附近区域发生抵消。\n4. 对于一组精心选择的输入，将朴素差值和无抵消实现的相对误差与一个高精度参考值进行比较。使用高精度实数运算工具计算每个 $x$ 的参考值 $\\operatorname{true}(x)$，然后计算相对误差\n$$\n\\operatorname{relerr}(y;\\operatorname{true}) = \\frac{|y - \\operatorname{true}|}{|\\operatorname{true}|}.\n$$\n用于评估的输入测试套件必须是列表\n$$\n\\left[ x_{\\mathrm{crit}}, \\frac{x_{\\mathrm{crit}}}{2}, \\hat{\\varepsilon}, \\frac{\\hat{\\varepsilon}}{2}, \\sqrt{\\hat{\\varepsilon}}, -x_{\\mathrm{crit}}, -\\frac{x_{\\mathrm{crit}}}{2}, -\\hat{\\varepsilon}, -\\frac{\\hat{\\varepsilon}}{2}, -\\sqrt{\\hat{\\varepsilon}} \\right].\n$$\n对于此列表中的每个输入 $x$，计算布尔值\n$$\nb(x) = \\left( \\operatorname{relerr}\\big(\\exp(x) - 1; \\operatorname{true}(x)\\big)  \\operatorname{relerr}\\big(\\text{alt}(x); \\operatorname{true}(x)\\big) \\right),\n$$\n该布尔值回答了在该输入上，朴素差值的相对误差是否严格大于无抵消实现的相对误差。\n假设不涉及物理单位。角度不相关。所有数值结果必须按照下文指定的方式报告为浮点数或布尔值。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果按以下确切顺序排列：\n- 首先是 $\\hat{\\varepsilon}$。\n- 其次是 $x_{\\mathrm{crit}}$。\n- 第三是 $y_{\\mathrm{alt}}(x_{\\mathrm{crit}})$。\n- 然后是与上述测试套件中输入相对应的10个布尔值 $b(x)$ 的序列，按该确切顺序排列。\n\n例如，输出必须形如\n$[r_1,r_2,r_3,b_1,b_2,\\dots,b_{10}]$\n其中 $r_1, r_2, r_3$是浮点数，$b_1,\\dots,b_{10}$是布尔值。不应打印任何额外文本。", "solution": "目标是分析当 $x$ 值接近零时，在双精度浮点运算中朴素地计算函数 $f(x) = e^x - 1$ 的数值不稳定性。这种不稳定性，即所谓的灾难性抵消，将与一种稳定的替代实现进行比较。该分析包括四个主要步骤：计算机器 epsilon，确定灾难性抵消的临界阈值，评估一种稳定的替代方法，以及在一组指定的测试输入上比较两种方法的相对误差。\n\n### 第 1 部分：计算机器 Epsilon ($\\hat{\\varepsilon}$)\n\n机器 epsilon，表示为 $\\varepsilon$，是满足 $1$ 与 $\\varepsilon$ 相加结果严格大于 $1$ 的最小正浮点数。形式上，在浮点运算中，$\\varepsilon = \\min \\{ y  0 \\mid 1 + y  1 \\}$。它量化了 $1$ 与下一个更大的可表示浮点数之间的间隙。\n\n为了计算标准64位双精度浮点类型的 $\\hat{\\varepsilon}$，我们按规定采用迭代减半法。我们从一个值（例如 $x_0 = 1$）开始，并重复将其除以 2。对于每个新值 $x_k = x_{k-1}/2$，我们测试条件 $1 + x_k  1$。当此条件不成立时，循环终止。使该条件成立的最后一个 $x_{k-1}$ 的值就是我们计算出的机器 epsilon，即 $\\hat{\\varepsilon}$。使用 NumPy 的 `float64` 类型可确保运算以双精度执行。\n\n### 第 2 部分：确定临界值 ($x_{\\mathrm{crit}}$)\n\n当 $x$ 接近 0 时，表达式 $e^x - 1$ 中会发生灾难性抵消。在这种情况下，$e^x$ 接近 1。$e^x$ 的浮点表示（记作 $\\mathrm{fl}(e^x)$）可能会损失精度。当我们再减去 1 时，$\\mathrm{fl}(e^x)$ 和 1 的前导位是相同的，它们的抵消导致结果由舍入误差主导。\n\n问题要求找到上确界 $x_{\\mathrm{crit}}  0$，使得朴素的浮点计算恰好产生零：\n$$\n\\mathrm{fl}(\\mathrm{fl}(e^x) - 1) = 0\n$$\n在标准浮点运算中，此等式成立当且仅当 $\\mathrm{fl}(e^x)$ 精确为 $1.0$。根据 IEEE 754 标准（舍入到最近，偶数取中），如果一个实数 $z$ 落在区间 $(1 - \\varepsilon/4, 1 + \\varepsilon/2]$ 内，它将被舍入为 $1.0$。由于我们考虑 $x  0$，因此有 $e^x  1$。所以，如果 $e^x \\le 1.0 + \\varepsilon/2$，则 $\\mathrm{fl}(e^x) = 1.0$。当 $e^x = 1.0 + \\varepsilon/2$ 时达到阈值，这意味着 $x = \\ln(1.0 + \\varepsilon/2)$。因此，使该条件成立的所有 $x$ 的集合的上确界是 $x_{\\mathrm{crit}} = \\ln(1 + \\varepsilon/2) \\approx \\varepsilon/2$。\n\n我们使用二分搜索来数值地找到这个值。我们搜索使得布尔表达式 `np.exp(x) - 1.0 == 0.0` 为真的最大正浮点数 $x$。搜索区间被初始化，例如，为 $[0, \\hat{\\varepsilon}]$，并进行迭代优化。如果对于一个中点 `mid`，条件 `np.exp(mid) - 1.0 == 0.0` 成立，我们就知道 $x_{\\mathrm{crit}}$ 至少是 `mid`，因此我们将搜索的下界设为 `mid`。否则，`mid` 太大，我们把上界设为 `mid`。经过足够次数的迭代后，搜索区间的下界会收敛到机器可表示的值，这个值就是我们对 $x_{\\mathrm{crit}}$ 的最佳近似。\n\n### 第 3 部分：稳定的替代实现 ($y_{\\mathrm{alt}}(x_{\\mathrm{crit}})$)\n\n存在专门的库函数可以为小的 $|x|$ 精确计算 $e^x - 1$。这些函数，例如 `numpy.expm1`，通常在 $|x|$ 很小时使用 $e^x - 1 = x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\cdots$ 的泰勒级数展开，当 $|x|$ 足够大以至于不需要担心抵消问题时，则回退到直接计算 $\\exp(x) - 1$。我们需要计算这个稳定函数在我们确定的临界点 $x_{\\mathrm{crit}}$ 处的值，即 $y_{\\mathrm{alt}}(x_{\\mathrm{crit}}) = \\mathrm{expm1}(x_{\\mathrm{crit}})$。\n\n### 第 4 部分：相对误差比较\n\n为了定量评估朴素方法与稳定方法的性能，我们计算它们相对于一个高精度参考值的相对误差。一个近似值 $y$ 相对于一个真值 $\\operatorname{true}$ 的相对误差由以下公式给出：\n$$\n\\operatorname{relerr}(y; \\operatorname{true}) = \\frac{|y - \\operatorname{true}|}{|\\operatorname{true}|}\n$$\n$e^x - 1$ 的“真”值是使用 Python 的 `decimal` 模块计算的，该模块配置了高精度（例如50位数字），以作为可靠的基准真相。\n\n比较是针对一个包含10个输入的测试套件进行的：$[ x_{\\mathrm{crit}}, \\frac{x_{\\mathrm{crit}}}{2}, \\hat{\\varepsilon}, \\frac{\\hat{\\varepsilon}}{2}, \\sqrt{\\hat{\\varepsilon}}, -x_{\\mathrm{crit}}, -\\frac{x_{\\mathrm{crit}}}{2}, -\\hat{\\varepsilon}, -\\frac{\\hat{\\varepsilon}}{2}, -\\sqrt{\\hat{\\varepsilon}} ]$。 这些输入被选择在预计会发生显著灾难性抵消的区域内。对于每个输入 $x$，我们计算布尔指示符：\n$$\nb(x) = \\left( \\operatorname{relerr}\\big(\\mathrm{fl}(\\exp(x) - 1); \\operatorname{true}(x)\\big)  \\operatorname{relerr}\\big(\\mathrm{expm1}(x); \\operatorname{true}(x)\\big) \\right)\n$$\n如果朴素计算的准确度严格低于稳定计算，则此布尔值为 `True`。对于所有指定的测试输入，它们的量级都很小，预计朴素方法会遭受严重的抵消，从而产生比 `expm1` 函数大得多的相对误差。因此，我们预期所有10个布尔结果都将为 `True`。\n\n最终输出是这些计算值的集合：$\\hat{\\varepsilon}$，$x_{\\mathrm{crit}}$，$y_{\\mathrm{alt}}(x_{\\mathrm{crit}})$，以及10个布尔结果 $b(x_i)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom decimal import Decimal, getcontext\n\ndef solve():\n    \"\"\"\n    Solves the numerical analysis problem as specified.\n    1. Computes machine epsilon.\n    2. Finds the critical value x_crit where exp(x)-1 underflows to 0.\n    3. Computes the stable alternative expm1(x_crit).\n    4. Compares relative errors for a test suite of inputs.\n    \"\"\"\n    \n    # Task 1: Compute machine epsilon (eps_hat) for float64 by iterative halving.\n    # We are looking for the smallest positive float64 'eps' such that 1.0 + eps  1.0.\n    eps = np.float64(1.0)\n    # The loop finds the largest power-of-two smaller than or equal to the true machine epsilon.\n    # The true epsilon is the *first* value that fails 1+eps  1, so the last one that passes is what we want.\n    # A more precise way is to check 1.0 + eps/2.0.\n    # Let `one = np.float64(1.0)`. Find eps s.t. `one + eps  one` and `one + eps/2 == one`.\n    current_eps = np.float64(1.0)\n    while np.float64(1.0) + current_eps / np.float64(2.0) > np.float64(1.0):\n        current_eps /= np.float64(2.0)\n    eps_hat = current_eps\n\n    # Task 2: Determine the critical value x_crit using a bisection search.\n    # We are looking for the supremum x  0 such that naive exp(x) - 1 == 0.\n    # This happens when exp(x) is rounded to 1.0.\n    # The search space is bounded by 0 and a value known to be too large, like eps_hat.\n    low = np.float64(0.0)\n    high = eps_hat\n    # 100 iterations are sufficient for double precision convergence.\n    for _ in range(100):\n        mid = low + (high - low) / np.float64(2.0)\n        # Check if the naive computation results in zero\n        if np.exp(mid) - np.float64(1.0) == np.float64(0.0):\n            # If so, mid is a candidate; try larger values.\n            low = mid\n        else:\n            # If not, mid is too large.\n            high = mid\n    x_crit = low\n\n    # Task 3: Compute the value using the cancellation-free implementation.\n    y_alt_x_crit = np.expm1(x_crit)\n\n    # Task 4: Compare relative errors for the test suite.\n    \n    # Set precision for the high-precision reference calculation.\n    getcontext().prec = 50\n\n    # Define the test suite of inputs.\n    test_inputs = [\n        x_crit,\n        x_crit / np.float64(2.0),\n        eps_hat,\n        eps_hat / np.float64(2.0),\n        np.sqrt(eps_hat),\n        -x_crit,\n        -x_crit / np.float64(2.0),\n        -eps_hat,\n        -eps_hat / np.float64(2.0),\n        -np.sqrt(eps_hat)\n    ]\n\n    boolean_results = []\n    for x_float in test_inputs:\n        x_dec = Decimal(x_float)\n        \n        # Compute high-precision \"true\" value\n        true_val = x_dec.exp() - Decimal(1)\n\n        # Compute values using naive and stable methods in float64\n        naive_val = np.exp(x_float) - np.float64(1.0)\n        alt_val = np.expm1(x_float)\n        \n        # Convert to Decimal for high-precision error calculation\n        naive_val_dec = Decimal(naive_val)\n        alt_val_dec = Decimal(alt_val)\n\n        # Avoid division by zero if true_val is zero (not possible for these inputs)\n        if true_val == Decimal(0):\n            # This case shouldn't be reached with the given test inputs.\n            # If it were, relative error is ill-defined. We could define error as absolute.\n            # For this problem, we assume it's non-zero.\n            rel_err_naive = Decimal('inf') if naive_val_dec != 0 else Decimal(0)\n            rel_err_alt = Decimal('inf') if alt_val_dec != 0 else Decimal(0)\n        else:\n            rel_err_naive = abs(naive_val_dec - true_val) / abs(true_val)\n            rel_err_alt = abs(alt_val_dec - true_val) / abs(true_val)\n        \n        # Compare relative errors\n        is_naive_worse = rel_err_naive > rel_err_alt\n        boolean_results.append(is_naive_worse)\n\n    # Assemble the final list of results.\n    final_results = [eps_hat, x_crit, y_alt_x_crit] + boolean_results\n    \n    # Format the final list as a string per problem specification.\n    # Booleans must be lowercase 'true' or 'false'.\n    str_results = []\n    for item in final_results:\n        if isinstance(item, bool):\n            str_results.append(str(item).lower())\n        else:\n            str_results.append(str(item))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```", "id": "3250061"}, {"introduction": "对一列数字求和是编程中最基本的操作之一。但你是否想过，加法的顺序会影响最终结果吗？在浮点数算术中，答案是肯定的，而且影响巨大。[@problem_id:3250053] 在这个综合性实践中，你将研究不同求和算法的误差累积行为。通过对顺序求和与成对求和（pairwise summation）进行编程实现和比较，你将亲眼见证算法结构如何从根本上改变舍入误差的增长速度。这个练习不仅验证了数值分析的理论，也为你编写处理大规模数据时保持数值稳定性的代码提供了宝贵的实践经验。", "problem": "考虑符合电气和电子工程师协会（IEEE）754 binary64（双精度）标准的浮点运算。将单位舍入 $u$ 定义为在“向最接近的偶数舍入”（ties to even）规则下，$1$ 与下一个更大的可表示浮点数之间距离的一半。对于 binary64，基数 $\\beta=2$，精度 $t=53$，因此单位舍入为 $u=\\frac{1}{2}\\beta^{1-t}=2^{-53}$。假设采用标准舍入模型：对于任意两个实数 $a$ 和 $b$，若其精确实数和 $a+b$ 是有限的，则单次浮点加法遵循\n$$\n\\operatorname{fl}(a+b) = (a+b)(1+\\delta), \\quad |\\delta| \\le u,\n$$\n其中 $\\operatorname{fl}(\\cdot)$ 表示加法计算出的浮点结果。\n\n任务 A（推导）：从该舍入模型出发，推导对 $n$ 个实数 $x_1,\\dots,x_n$ 求和时，两种算法的前向误差表现：\n- 顺序（从左到右）求和 $S_n = (((x_1+x_2)+x_3)+\\cdots)+x_n$，以及\n- 成对求和，即对 $n$ 个项构造一个平衡二叉加法树（假设 $n=2^k$ 以使树是完全平衡的）。\n\n证明顺序求和产生的误差增长量级为 $O(nu)$，而成对求和将增长量级减小到 $O(\\log n\\,u)$。\n\n任务 B（计算验证）：编写一个完整、可运行的程序，该程序：\n1. 使用固定的随机种子，为每个测试用例生成 $n=2^k$ 个在区间 $[-1,1]$ 上均匀分布的独立同分布实数 $x_i$，其类型为 binary64 ($\\text{float64}$) 值。\n2. 计算这 $n$ 个值的三个和：\n   - 一个基准和 $S^\\star$，使用数值稳定、高精度的求和程序（特别是 Python 用于浮点数的精确求和函数）来紧密逼近精确的实数和。将其视为误差测量的参考值。\n   - 一个顺序（从左到右）浮点和 $\\hat{S}_{\\text{seq}}$，通过在标准 binary64 算术中迭代累加得到。\n   - 一个成对浮点和 $\\hat{S}_{\\text{pair}}$，通过反复对相邻元素成对求和，形成一个平衡二叉加法树，直到只剩下一个值。\n3. 对每种算法，计算绝对前向误差\n$$\nE_{\\text{seq}} = \\left|\\hat{S}_{\\text{seq}} - S^\\star\\right|, \\quad E_{\\text{pair}} = \\left|\\hat{S}_{\\text{pair}} - S^\\star\\right|.\n$$\n4. 生成单行最终输出，该输出是一个用方括号括起来的逗号分隔列表，其中每个条目本身是对应一个测试用例的方括号三元组 $\\left[k, E_{\\text{seq}}, E_{\\text{pair}}\\right]$。浮点值使用科学记数法表示。\n\n使用以下指数 $k$ 的测试集以确保覆盖边界和增长区域：$k\\in\\{0,1,2,4,8,12,16\\}$，这样 $n=2^k$ 就包含了单项边界情况以及逐步增大的求和，最大可达 $n=65536$。\n\n你的程序必须是自包含的，并严格按照以下格式产生一行输出：\n$$\n\\big[\\,[k_1,E_{\\text{seq},1},E_{\\text{pair},1}],\\,[k_2,E_{\\text{seq},2},E_{\\text{pair},2}],\\,\\dots\\,\\big],\n$$\n浮点误差使用科学记数法，且每个三元组的方括号内没有多余的空格。", "solution": "此问题经评估有效。它在数值分析领域提出了一个关于基本求和算法误差传播特性的、定义明确且有科学依据的问题。该问题是自包含的，提供了必要的数学模型、具体的算法定义、明确的计算任务和精确的输出格式。\n\n在此，我提供所要求的推导（任务 A）和计算验证的设计（任务 B）。\n\n### 任务 A：前向误差界推导\n\n给定 binary64 算术中单次浮点加法的标准模型：\n$$\n\\operatorname{fl}(a+b) = (a+b)(1+\\delta), \\quad |\\delta| \\le u\n$$\n其中 `$u = 2^{-53}$` 是单位舍入。误差 `$\\delta$` 是一个取决于参数 `$a$` 和 `$b$` 的随机变量。对于随机数据的舍入误差进行统计分析时，通常将 `$\\delta$` 建模为在 `$\\left[-u, u\\right]$` 上均匀分布的随机变量，其均值为 `$E[\\delta] = 0$`，方差为 `$\\operatorname{Var}(\\delta) = E[\\delta^2] = \\frac{u^2}{3}$`。\n\n令 `$S_n = \\sum_{i=1}^n x_i$` 为 `$n$` 个实数的精确和。令 `$\\hat{S}_n$` 表示计算出的浮点和。绝对前向误差为 `$E = |\\hat{S}_n - S_n|$`。我们分析两种算法下该误差的增长情况。\n\n**1. 顺序（从左到右）求和**\n\n该算法将部分和 `$\\hat{s}_k$` 定义为：\n$$\n\\hat{s}_1 = x_1, \\quad \\hat{s}_k = \\operatorname{fl}(\\hat{s}_{k-1} + x_k) \\quad \\text{for } k=2, \\dots, n.\n$$\n在每一步应用舍入模型：\n$$\n\\hat{s}_k = (\\hat{s}_{k-1} + x_k)(1+\\delta_k), \\quad |\\delta_k| \\le u.\n$$\n令 `$s_k = \\sum_{i=1}^k x_i$` 为精确部分和，`$e_k = \\hat{s}_k - s_k$` 为第 `$k$` 步的误差。误差根据以下递推关系传播：\n$$\ne_k = \\hat{s}_k - s_k = (\\hat{s}_{k-1} + x_k)(1+\\delta_k) - (s_{k-1} + x_k) = (\\hat{s}_{k-1} - s_{k-1})(1+\\delta_k) + s_k \\delta_k = e_{k-1}(1+\\delta_k) + s_k \\delta_k.\n$$\n展开此递推式，并忽略 `$O(u^2)$` 及更高阶的项（即 `$\\delta_k$` 与 `$e_{k-1}$` 的乘积），我们得到：\n$$\ne_n \\approx e_{n-1} + s_n \\delta_n \\approx e_{n-2} + s_{n-1}\\delta_{n-1} + s_n \\delta_n \\approx \\sum_{k=2}^n s_k \\delta_k.\n$$\n这表明总误差 `$e_n$` 近似为中间精确部分和 `$s_k$` 的总和，其中每个 `$s_k$` 都被一个独立的随机舍入误差 `$\\delta_k$` 缩放。\n\n为了找到 `$e_n$` 的期望量级，我们计算其方差。假设 `$\\delta_k$` 是独立的，与部分和 `$s_k$` 不相关，且 `$E[\\delta_k]=0$`：\n$$\n\\operatorname{Var}(e_n) = \\operatorname{Var}\\left(\\sum_{k=2}^n s_k \\delta_k\\right) = \\sum_{k=2}^n \\operatorname{Var}(s_k \\delta_k) = \\sum_{k=2}^n E[s_k^2] E[\\delta_k^2] = \\sum_{k=2}^n E[s_k^2] \\frac{u^2}{3}.\n$$\n输入 `$x_i$` 是从 `$U[-1, 1]$` 中抽取的独立同分布样本，其均值为 `$0$`，方差为 `$\\sigma_x^2 = \\frac{(1 - (-1))^2}{12} = \\frac{1}{3}$`。精确部分和 `$s_k = \\sum_{i=1}^k x_i$` 是一系列独立同分布随机变量的和，因此其行为类似于随机游走。其均值为 `$E[s_k]=0$`，方差为 `$E[s_k^2] = \\operatorname{Var}(s_k) = k \\sigma_x^2$`。\n将此代入误差的方差公式中：\n$$\n\\operatorname{Var}(e_n) \\approx \\sum_{k=2}^n (k \\sigma_x^2) \\frac{u^2}{3} = \\frac{\\sigma_x^2 u^2}{3} \\sum_{k=2}^n k = \\frac{\\sigma_x^2 u^2}{3} \\left(\\frac{n(n+1)}{2} - 1\\right).\n$$\n对于大的 `$n$`，该式由 `$n^2$` 项主导：\n$$\n\\operatorname{Var}(e_n) \\approx \\frac{\\sigma_x^2 u^2 n^2}{6}.\n$$\n均方根（RMS）前向误差是 `$e_n$` 的标准差：\n$$\nE_{\\text{seq}}^{\\text{RMS}} = \\sqrt{\\operatorname{Var}(e_n)} \\approx \\frac{\\sigma_x u n}{\\sqrt{6}}.\n$$\n这表明，对于零均值的随机数据，期望绝对前向误差随 `$n$` 线性增长，即 `$E_{\\text{seq}} = O(nu)$`。\n\n**2. 成对求和**\n\n对于 `$n=2^k$`，成对求和分 `$k = \\log_2 n$` 个阶段进行。\n- **阶段 1**：计算 `$n/2$` 个和：`$\\operatorname{fl}(x_1+x_2), \\operatorname{fl}(x_3+x_4), \\dots$`。\n- **阶段 2**：使用阶段 1 的结果计算 `$n/4$` 个和。\n- ...\n- **阶段 k**：计算最终的和。\n\n令 `$e_{j,m}$` 为在阶段 `$j$` 计算的第 `$m$` 个和中的误差。总误差是二叉树所有节点产生并传播到最终结果的所有误差之和。使用相同的递推式 `e_new = e_left + e_right + S_new * delta`，最终误差近似为树中所有 `$n-1$` 个内部节点的误差之和：\n$$\ne_n \\approx \\sum_{\\text{nodes } p} S_p \\delta_p,\n$$\n其中 `$S_p$` 是对应于节点 `$p$` 的精确和，`$\\delta_p$` 是该节点的舍入误差。\n总误差的方差是每个节点舍入所贡献的方差之和：\n$$\n\\operatorname{Var}(e_n) \\approx \\sum_{\\text{nodes } p} \\operatorname{Var}(S_p \\delta_p) = \\sum_{\\text{nodes } p} E[S_p^2] E[\\delta_p^2] = \\frac{u^2}{3} \\sum_{\\text{nodes } p} E[S_p^2].\n$$\n这个和可以按树的阶段（层级）分组。在阶段 `$j$`（对于 `$j=1, \\dots, k=\\log_2 n$`），有 `$n/2^j$` 个和被计算。每个和都是对 `$2^j$` 个原始随机数 `$x_i$` 求和。\n这样一个和 `$S_p$` 的方差是 `$E[S_p^2] = \\operatorname{Var}(S_p) = 2^j \\sigma_x^2$`。\n来自阶段 `$j$` 对总误差方差的贡献是：\n$$\n\\operatorname{Var}_j(e_n) = (\\text{number of sums}) \\times (\\text{variance per sum}) \\times \\frac{u^2}{3} = \\left(\\frac{n}{2^j}\\right) \\times (2^j \\sigma_x^2) \\times \\frac{u^2}{3} = \\frac{n \\sigma_x^2 u^2}{3}.\n$$\n值得注意的是，每个阶段贡献的方差是恒定的。由于有 `$k = \\log_2 n$` 个阶段，总方差是所有阶段贡献的总和：\n$$\n\\operatorname{Var}(e_n) = \\sum_{j=1}^{\\log_2 n} \\operatorname{Var}_j(e_n) = (\\log_2 n) \\left(\\frac{n \\sigma_x^2 u^2}{3}\\right).\n$$\n因此，均方根（RMS）前向误差为：\n$$\nE_{\\text{pair}}^{\\text{RMS}} = \\sqrt{\\operatorname{Var}(e_n)} \\approx \\sqrt{\\frac{n \\log_2 n}{3}} \\sigma_x u.\n$$\n误差增长为 `$O(\\sqrt{n \\log n} \\cdot u)$`。\n\n**关于问题陈述的说明：** 问题要求证明成对求和误差的增长量级为 `$O(\\log n \\cdot u)$`。这在入门级教材中是一个常见的、略有不精确的说法。`$O(\\log n \\cdot u)$` 的界限正确地描述了成对求和的*后向误差*，意为计算出的和 `$\\hat{S}_{pair}$` 是一组微扰输入 `$\\hat{S}_{pair} = \\sum_{i=1}^n x_i(1+\\theta_i)` 的精确和，其中 `$|\\theta_i| \\le u \\log_2 n + O(u^2)$`。绝对前向误差 `$|\\hat{S}_{pair} - S_n| = |\\sum x_i \\theta_i|$` 通常不遵循此界限。上述统计分析得出的 `$O(\\sqrt{n \\log n} \\cdot u)$` 更准确地反映了随机数据下的行为，这一点将通过计算得到验证。尽管如此，成对求和相对于顺序求和的优越性仍然是成立的，因为 `$O(\\sqrt{n \\log n} \\cdot u)$` 的增长速度远慢于 `$O(nu)$`。\n\n### 任务 B：计算验证计划\n\n程序将实现问题陈述中指定的逻辑。\n1.  随机种子将固定为 `$42$` 以保证可复现性。\n2.  对于每个 `$k \\in \\{0, 1, 2, 4, 8, 12, 16\\}$`，我们计算 `$n=2^k$` 并生成一个包含 `$n$` 个在 `[$−1, 1]$` 上独立同分布的 `float64` 数的数组。\n3.  参考和 `$S^\\star$` 将使用 `math.fsum` 计算，该函数在很大程度上避免了中间舍入误差。\n4.  顺序和 `$\\hat{S}_{\\text{seq}}$` 将通过标准的 `for` 循环计算，以确保从左到右的累加。\n5.  成对和 `$\\hat{S}_{\\text{pair}}$` 将使用一个迭代辅助函数计算，该函数反复对工作数组的相邻对求和，直到只剩下一个值。由于 `$n=2^k$`，数组长度在每一步都将是偶数，这简化了实现。\n6.  计算绝对前向误差 `$E_{\\text{seq}} = |\\hat{S}_{\\text{seq}} - S^\\star|$` 和 `$E_{\\text{pair}} = |\\hat{S}_{\\text{pair}} - S^\\star|$`。\n7.  每个 `$k$` 的结果将被格式化为字符串 `f\"[{k},{E_seq:.16e},{E_pair:.16e}]\"`，内部没有空格，并收集到一个列表中。\n8.  最终输出是打印这些结果列表的单行文本，结果之间用逗号分隔并用方括号括起来。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef sequential_sum(arr: np.ndarray) -> np.float64:\n    \"\"\"\n    Computes the sum of array elements using sequential (left-to-right)\n    floating-point addition.\n    \"\"\"\n    s = np.float64(0.0)\n    for x_i in arr:\n        s += x_i\n    return s\n\ndef pairwise_sum(arr: np.ndarray) -> np.float64:\n    \"\"\"\n    Computes the sum of array elements using pairwise summation, assuming\n    the length of the array is a power of 2.\n    \"\"\"\n    # Handle boundary cases\n    if arr.size == 0:\n        return np.float64(0.0)\n    if arr.size == 1:\n        return arr[0]\n\n    # Use a copy to avoid modifying the original array if it's passed from\n    # a context where it's still needed.\n    current_arr = arr.copy()\n\n    # The problem guarantees n = 2^k, so len(current_arr) will always\n    # be even at each stage of reduction except the last.\n    while current_arr.size > 1:\n        # Sum adjacent pairs. This operation is performed in-place on\n        # a new array.\n        # e.g., for [a, b, c, d], this becomes [a+b, c+d]\n        current_arr = current_arr[0::2] + current_arr[1::2]\n    \n    return current_arr[0]\n\n\ndef solve():\n    \"\"\"\n    Main function to run the summation error comparison experiment.\n    \"\"\"\n    # Use a fixed random seed for reproducibility of the generated numbers.\n    np.random.seed(42)\n\n    # Test suite of exponents k, where n = 2^k.\n    test_cases_k = [0, 1, 2, 4, 8, 12, 16]\n\n    results = []\n    for k in test_cases_k:\n        n = 2**k\n        \n        # 1. Generate n i.i.d. real numbers from U[-1, 1] as binary64.\n        # np.random.uniform defaults to float64, which is binary64.\n        x = np.random.uniform(low=-1.0, high=1.0, size=n)\n\n        # 2. Compute the three sums.\n        # S_star: High-accuracy reference sum using math.fsum.\n        s_star = math.fsum(x)\n        \n        # S_seq: Standard sequential floating-point sum.\n        s_seq = sequential_sum(x)\n        \n        # S_pair: Pairwise floating-point sum.\n        s_pair = pairwise_sum(x)\n\n        # 3. Compute the absolute forward errors.\n        e_seq = abs(s_seq - s_star)\n        e_pair = abs(s_pair - s_star)\n\n        # 4. Format the result for this test case as a string triple.\n        # Using .16e for full double precision representation in scientific notation.\n        result_str = f\"[{k},{e_seq:.16e},{e_pair:.16e}]\"\n        results.append(result_str)\n\n    # Final print statement in the exact required format.\n    # The list of string results is joined by commas and enclosed in brackets.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "3250053"}]}