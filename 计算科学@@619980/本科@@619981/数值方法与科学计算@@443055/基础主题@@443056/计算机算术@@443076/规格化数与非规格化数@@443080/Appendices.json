{"hands_on_practices": [{"introduction": "理解像浮点运算这样复杂系统的最好方法，莫过于亲手构建一个简化版本。这项练习要求你设计一个玩具般的8位浮点格式。通过计算其关键属性，你将具体地理解位模式如何转换为规格化数和次规格化数，以及这两种类型的数是如何无缝衔接的。[@problem_id:3257655]", "problem": "您的任务是指定一个自洽的玩具二进制浮点格式，并使用基本定义来推导关于其规格化数和次规格化数的关键量。\n\n考虑一个玩具$8$位二进制浮点系统，其设计如下：\n- 该表示有$1$个符号位，$4$个指数位和$3$个尾数（小数部分）位。\n- 指数使用$7$的偏移量。\n- 当指数场全为零且尾数非零时，该数为次规格化数（也称非规格化数）；当指数场全为零且尾数也为零时，该数为带符号的零。\n- 当指数场全为一时，编码表示无穷大和非数值（NaN），这些情况不在此问题考虑范围内。\n- 对于规格化数（指数场既不全为零也不全为一），有效数（significand）被解释为带有一个隐含的前导1，即形式为$1.f_1 f_2 f_3$（二进制）。对于次规格化数（指数场全为零且尾数非零），有效数没有隐含的前导1，形式为$0.f_1 f_2 f_3$（二进制）。\n- 所表示的实数值为 $(-1)^{s} \\times m \\times 2^{e}$，其中$s$是符号位，$m$是如上所述的有效数，$e$是无偏指数。对于规格化数，无偏指数是存储的指数场值减去偏移量。对于次规格化数，无偏指数固定为在次规格化和规格化范围边界处保持连续性的最小指数。\n\n仅使用这些定义和二进制浮点表示的基本原理（由电气和电子工程师协会（IEEE）754在实践中标准化，但此处适用于上述玩具格式），确定：\n- 最小的正规格化数，记为$N_{\\min}$。\n- 最小的正次规格化数，记为$S_{\\min}$。\n- 可表示的次规格化数的总数（包括正负号），不包括两个带符号的零。\n\n将$N_{\\min}$和$S_{\\min}$精确地表示为$2$的幂，并将次规格化数的数量作为一个整数给出。以行矩阵 $\\big(N_{\\min},\\,S_{\\min},\\,C\\big)$ 的形式提供您的最终答案。不要四舍五入。不需要单位。", "solution": "用户提供了一个玩具$8$位二进制浮点系统的规范，并要求确定三个量：最小正规格化数（$N_{\\min}$）、最小正次规格化数（$S_{\\min}$）和次规格化数的总数（$C$）。\n\n该问题是自洽的，并与IEEE 754等标准所定义的浮点算术原理一致。所有必要的参数都已提供，问题表述清晰。因此，该问题是有效的，可以推导出解决方案。\n\n该系统由以下参数定义：\n- 总位数：$8$。\n- 符号位（$s$）：$1$。\n- 指数位（$k$）：$4$。\n- 尾数位（$p$）：$3$。\n- 指数偏移量（$B$）：$7$。\n\n一个浮点数的值$v$由公式 $v = (-1)^{s} \\times m \\times 2^{e}$ 给出，其中$s$是符号位，$m$是有效数，$e$是无偏指数。\n\n首先，我们确定规格化数的存储指数值（$E$）的范围。指数场有$k=4$位，因此其值范围可以从$0$到$2^4-1 = 15$。问题指出$E=0$（全零）保留给零和次规格化数，而$E=15$（全一）保留给特殊值（无穷大/NaN）。因此，规格化数的存储指数范围是$E \\in [1, 14]$。规格化数的无偏指数$e$计算为$e = E - B$。当偏移量$B=7$时，规格化数的无偏指数范围是：\n- $e_{\\min\\_norm} = 1 - 7 = -6$。\n- $e_{\\max\\_norm} = 14 - 7 = 7$。\n\n**1. 最小的正规格化数（$N_{\\min}$）**\n\n为了找到最小的正规格化数，我们必须满足三个条件：\n- 符号必须为正，所以符号位$s=0$。\n- 有效数$m$必须尽可能小。对于规格化数，有效数的形式为$m = 1.f_1 f_2 f_3$（二进制），带有一个隐含的前导$1$。当所有尾数位都为零时，其值最小：$f_1=0, f_2=0, f_3=0$。这给出的有效数为$m_{\\min\\_norm} = 1.000_2 = 1$。\n- 指数$e$必须尽可能小。如上所述，规格化数的最小无偏指数为$e_{\\min\\_norm} = -6$。\n\n结合这些，我们计算$N_{\\min}$：\n$$N_{\\min} = (-1)^0 \\times 1 \\times 2^{-6} = 2^{-6}$$\n\n**2. 最小的正次规格化数（$S_{\\min}$）**\n\n首先，我们必须确定次规格化数的固定无偏指数$e_{sub}$。问题规定，选择该指数是为了在次规格化和规格化范围之间的边界处保持连续性。这个边界位于最大的次规格化数$S_{\\max}$和最小的规格化数$N_{\\min}$之间。\n\n$N_{\\min}$的值是$1.000_2 \\times 2^{-6}$。具有该指数的可表示数之间的间距（或ulp，最后一位的单位）由尾数最低有效位的值决定，即$2^{-p} = 2^{-3}$。在该指数下的总步长为$2^{-3} \\times 2^{e_{\\min\\_norm}} = 2^{-3} \\times 2^{-6} = 2^{-9}$。\n\n为了实现连续过渡，最大的次规格化数必须比最小的规格化数小一个步长：\n$$S_{\\max} = N_{\\min} - (\\text{步长}) = 2^{-6} - 2^{-9} = 2^{-6}(1 - 2^{-3}) = 2^{-6}(1 - \\frac{1}{8}) = \\frac{7}{8} \\times 2^{-6}$$\n\n现在，我们使用次规格化数的定义来表示$S_{\\max}$。对于次规格化数，有效数是$m = 0.f_1 f_2 f_3$（二进制）。当所有尾数位都为一时，出现最大的次规格化有效数：$f_1=1, f_2=1, f_3=1$。\n$$m_{\\max\\_sub} = 0.111_2 = \\frac{1}{2} + \\frac{1}{4} + \\frac{1}{8} = \\frac{7}{8}$$\n最大次规格化数的值是$S_{\\max} = m_{\\max\\_sub} \\times 2^{e_{sub}} = \\frac{7}{8} \\times 2^{e_{sub}}$。\n\n将$S_{\\max}$的两个表达式相等，我们可以解出$e_{sub}$：\n$$\\frac{7}{8} \\times 2^{e_{sub}} = \\frac{7}{8} \\times 2^{-6}$$\n$$\\implies e_{sub} = -6$$\n这证实了标准约定，即次规格化指数为$e_{sub} = 1 - B = 1 - 7 = -6$。\n\n现在我们可以找到最小的正次规格化数，$S_{\\min}$。\n- 符号必须为正，所以$s=0$。\n- 指数是固定的次规格化指数，$e_{sub} = -6$。\n- 有效数$m = 0.f_1 f_2 f_3$必须是最小的*非零*值。这发生在只有最低有效位为一的情况下：$f_1=0, f_2=0, f_3=1$。\n$$m_{\\min\\_sub} = 0.001_2 = 0 \\times 2^{-1} + 0 \\times 2^{-2} + 1 \\times 2^{-3} = 2^{-3}$$\n\n结合这些，我们计算$S_{\\min}$：\n$$S_{\\min} = (-1)^0 \\times (2^{-3}) \\times 2^{-6} = 2^{-9}$$\n\n**3. 可表示的次规格化数的总数（$C$）**\n\n如果一个数的指数场全为零且其尾数场非零，则该数为次规格化数。我们需要计算所有这种可能的位模式。\n- 符号位（$s$）：$1$位，可以是$0$或$1$。这提供了$2$种选择。\n- 指数场（$E$）：$4$位，必须是$0000_2$。这提供了$1$种选择。\n- 尾数场（$f$）：$3$位，可以是除全零（$000_2$）外的任何模式。$3$位的模式总数为$2^3 = 8$。非零模式的数量为$2^3 - 1 = 7$。\n\n总数$C$是每个字段选择数的乘积：\n$$C = (\\text{符号选择数}) \\times (\\text{尾数选择数}) = 2 \\times (2^3 - 1) = 2 \\times 7 = 14$$\n\n这三个量是$N_{\\min} = 2^{-6}$，$S_{\\min} = 2^{-9}$和$C = 14$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2^{-6}  2^{-9}  14\n\\end{pmatrix}\n}\n$$", "id": "3257655"}, {"introduction": "次规格化数旨在处理“渐进下溢”（gradual underflow），但当用它们进行算术运算时会发生什么呢？本练习将探讨一个有趣的边界情况：两个次规格化数之和。通过在标准的半精度格式下完成一个具体例子，你将看到算术运算如何导致结果从次规格化数范围“溢出”到规格化数范围，从而凸显两者之间的边界。[@problem_id:3257753]", "problem": "考虑电子和电气工程师协会（IEEE）754 标准的半精度二进制浮点系统（binary16），该系统使用基数 $2$、$1$ 个符号位、$5$ 个指数位和 $10$ 个小数（尾数）位。指数偏移量为 $15$。在此系统中，指数域非零的数为规格化数，而指数域为 $0$ 且小数部分非零的数为次规格数。\n\n回答以下问题：两个正次规格数 $x$ 和 $y$ 的和是否可能超出次规格数范围，并能表示为该系统中的一个规格化数？请构造一个明确的例子，取 $x$ 为 binary16 中最大的正次规格数，$y$ 为最小的正次规格数，并计算 $x + y$ 的精确实数值。将最终答案表示为以整数为指数的 $2$ 的单一幂次形式。无需进行舍入。", "solution": "该问题是有效的，因为它科学地基于 IEEE 754 浮点运算标准，是适定的、客观的，并包含得出唯一解所需的所有必要信息。\n\n首先，我们分析指定的 IEEE 754 半精度二进制浮点系统 (binary16) 中数字的结构。该系统使用基数 $B=2$，$1$ 个符号位 ($s$)，$5$ 个指数位（构成指数域 $e$），以及 $10$ 个小数位（构成小数域 $f$）。给定的指数偏移量为 $15$。\n\n该系统中的一个数 $v$ 由公式 $v = (-1)^s \\times m \\times 2^E$ 表示，其中 $m$ 是尾数，$E$ 是真实指数。$m$ 和 $E$ 的值取决于指数域 $e$。\n\n对于次规格（或非规格化）数，指数域为 $e = 0$。真实指数固定为其最小值，$E = 1 - \\text{bias} = 1 - 15 = -14$。尾数有一个隐藏的前导位 $0$，由 $m = (0.f)_2 = \\sum_{i=1}^{10} f_i 2^{-i}$ 给出，其中 $f_i$ 是小数域 $f$ 的第 $i$ 位。要成为次规格数，小数域 $f$ 必须非零。\n因此，一个正次规格数的形式为 $v_{sub} = (\\sum_{i=1}^{10} f_i 2^{-i}) \\times 2^{-14}$。\n\n对于规格化数，指数域 $e$ 的范围是 $1 \\le e \\le 30$。真实指数是 $E = e - \\text{bias} = e - 15$。尾数有一个隐藏的前导位 $1$，由 $m = (1.f)_2 = 1 + \\sum_{i=1}^{10} f_i 2^{-i}$ 给出。\n因此，一个正规格化数的形式为 $v_{norm} = (1 + \\sum_{i=1}^{10} f_i 2^{-i}) \\times 2^{e-15}$。\n\n问题询问两个正次规格数的和是否能产生一个规格化数。我们按照要求构造一个明确的例子来研究这个问题。\n\n设 $x$ 为最大的正次规格数。这发生在小数域 $f$ 的所有位都为 $1$ 时。\n小数域为 $f = 1111111111_2$。\n尾数为 $m_x = (0.1111111111)_2 = \\sum_{i=1}^{10} 2^{-i}$。这是一个等比级数，其和为 $2^{-1} \\frac{1-(2^{-1})^{10}}{1-2^{-1}} = \\frac{1}{2} \\frac{1-2^{-10}}{1/2} = 1 - 2^{-10}$。\n指数为 $E = -14$。\n因此，$x$ 的值为：\n$$x = (1 - 2^{-10}) \\times 2^{-14}$$\n\n设 $y$ 为最小的正次规格数。这发生在小数域 $f$ 取最小非零值时，即 $f = 0000000001_2$。\n尾数为 $m_y = (0.0000000001)_2 = 2^{-10}$。\n指数为 $E = -14$。\n因此，$y$ 的值为：\n$$y = 2^{-10} \\times 2^{-14} = 2^{-24}$$\n\n现在，我们计算和 $x+y$：\n$$x + y = \\left( (1 - 2^{-10}) \\times 2^{-14} \\right) + \\left( 2^{-10} \\times 2^{-14} \\right)$$\n提取公因式 $2^{-14}$：\n$$x + y = (1 - 2^{-10} + 2^{-10}) \\times 2^{-14}$$\n$$x + y = 1 \\times 2^{-14} = 2^{-14}$$\n\n和为 $2^{-14}$。我们现在必须确定这个数是在次规格数范围内还是在规格化数范围内。\n次规格数的最大值为 $x = (1 - 2^{-10}) \\times 2^{-14}$，它严格小于 $2^{-14}$。\n由于 $x+y = 2^{-14}$，这个和大于最大的次规格数，因此它必定位于次规格数范围之外。\n\n我们来检查 $2^{-14}$ 是否可以在 binary16 系统中表示为规格化数。\n一个规格化数的形式为 $(1.f)_2 \\times 2^{e-15}$。我们想找到 $f$ 和 $e$ 使得该表达式等于 $2^{-14}$。\n$$(1.f)_2 \\times 2^{e-15} = 2^{-14}$$\n我们可以通过将尾数设为 $(1.0)_2 = 1$ 并将指数设为 $-14$ 来实现。\n对于为 $1$ 的尾数，小数域 $f$ 必须全为零：$f = 0000000000_2$。\n对于为 $-14$ 的真实指数 $E$，我们需要 $e-15 = -14$，这意味着 $e=1$。\n指数域 $e=1$ 是规格化数的一个有效值（范围是 $1 \\le e \\le 30$）。\n因此，$2^{-14}$ 是 binary16 系统中最小的正规格化数。其表示法为 $s=0$，$e=00001_2$，$f=0000000000_2$。\n\n这明确地证明了两个正次规格数 $x$ 和 $y$ 的和可以超出次规格数范围，并能表示为一个规格化数。所选的 $x$ 和 $y$ 的和的精确实数值是 $2^{-14}$。\n问题要求将答案表示为以整数为指数的 $2$ 的单一幂次形式，即 $2^{-14}$。", "answer": "$$\\boxed{2^{-14}}$$", "id": "3257753"}, {"introduction": "浮点数在计算机内存中最终只是一串位模式。最后的这个练习将抽象的数学定义与其具体实现联系起来。你将编写一个程序，仅使用位运算来将一个32位整数分类为零、次规格化数、规格化数、无穷大或非数（NaN）。这个实践任务揭示了计算机如何在不依赖内置浮点硬件的情况下解释这些特殊的数值类型，让其不再神秘。[@problem_id:3257791]", "problem": "给定一个无符号的 $32$ 位整数，它表示一个二进制浮点数，该浮点数遵循电气与电子工程师协会（IEEE）浮点算术标准（IEEE $754$）的 binary$32$ 格式。你的任务是编写一个程序，在不使用任何浮点运算的情况下，判断每个给定的 $32$ 位模式表示的是规格化有限数、非规格化（denormalized）有限数、零、无穷大还是非数字（NaN），并为每种分类输出一个整数代码。\n\n使用的基本原理：\n- IEEE $754$ binary$32$ 格式使用 $32$ 位编码一个实数值，这 $32$ 位被划分为：一个符号位 $s$（最高有效位）、一个 $8$ 位指数场 $e$ 和一个 $23$ 位小数部分（也称为尾数场）$f$。存储的指数 $e$ 是一个在 $\\{0,1,\\dots,255\\}$ 范围内的无符号整数，小数部分 $f$ 是一个在 $\\{0,1,\\dots,2^{23}-1\\}$ 范围内的无符号整数。指数偏移量为 $127$。\n- 对于规格化有限数，编码值（如果解释为实数）的形式为 $(-1)^s \\cdot (1.f)_2 \\cdot 2^{E}$，其中无偏指数 $E = e - 127$，且 $1 \\le e \\le 254$。\n- 对于非规格化有限数，编码值的形式为 $(-1)^s \\cdot (0.f)_2 \\cdot 2^{1-127}$，其中 $e = 0$ 且 $f \\ne 0$。\n- 对于零，$e = 0$ 且 $f = 0$（$+0$ 和 $-0$ 都被视为零）。\n- 对于无穷大，$e = 255$ 且 $f = 0$（$+\\infty$ 和 $-\\infty$ 都被视为无穷大）。\n- 对于非数字（NaN），$e = 255$ 且 $f \\ne 0$。\n\n你的程序必须：\n- 将每个输入视为一个无符号 $32$ 位整数 $x \\in \\{0,1,\\dots,2^{32}-1\\}$，并仅通过整数和位运算对其进行分类。\n- 使用对 $x$ 的位运算提取字段 $s$、$e$ 和 $f$。\n- 为每个输入输出一个分类代码 $c \\in \\{0,1,2,3,4\\}$，定义如下：\n  - $0$：零，\n  - $1$：非规格化有限数，\n  - $2$：规格化有限数，\n  - $3$：无穷大，\n  - $4$：非数字（NaN）。\n\n测试套件：\n请精确使用以下测试用例（每个都是一个为便于阅读而以十六进制表示的无符号 $32$ 位整数）：\n- $x_1 = \\texttt{0x00000000}$，\n- $x_2 = \\texttt{0x80000000}$，\n- $x_3 = \\texttt{0x00000001}$，\n- $x_4 = \\texttt{0x00012345}$，\n- $x_5 = \\texttt{0x00800000}$，\n- $x_6 = \\texttt{0x3F800000}$，\n- $x_7 = \\texttt{0x7F7FFFFF}$，\n- $x_8 = \\texttt{0x7F800000}$，\n- $x_9 = \\texttt{0xFF800000}$，\n- $x_{10} = \\texttt{0x7FC00000}$。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含 $10$ 个测试用例的分类代码，按顺序排列，形式为用方括号括起来的逗号分隔列表，例如：$[c_1,c_2,\\dots,c_{10}]$。\n- 每个 $c_i$ 都必须是如上定义的整数。", "solution": "这个问题是有效的，因为它定义明确，科学上基于 IEEE $754$ 标准，并且是自包含的。任务是使用仅整数和位运算，将一个给定的 $32$ 位无符号整数（表示一个单精度浮点数）分类到五个类别之一：零、非规格化、规格化、无穷大或非数字（NaN）。\n\n核心原理是根据 IEEE $754$ binary$32$ 标准的定义，将 $32$ 位整数 $x$ 分解为其三个组成部分：符号位 $s$、$8$ 位指数场 $e$ 和 $23$ 位小数场 $f$。该数字的分类由字段 $e$ 和 $f$ 的值唯一确定。\n\n一个 $32$ 位整数 $x$ 的结构如下，从最高有效位（MSB）到最低有效位（LSB）：\n- 位 $31$：符号位 $s$（$1$ 位）\n- 位 $30-23$：指数场 $e$（$8$ 位）\n- 位 $22-0$：小数场 $f$（$23$ 位）\n\n分类算法分为两个主要步骤：字段提取和逻辑规则应用。\n\n**第 1 步：使用位运算提取字段**\n\n我们可以使用位与（AND）运算和特定的掩码，然后进行位右移，从整数 $x$ 中分离出指数场和小数场。\n\n1.  **指数场 ($e$) 提取：**\n    指数场占据位 $23$ 到位 $30$。为了分离出这 $8$ 位，我们使用一个位掩码，它在这些位置为 $1$，在其他位置为 $0$。这个掩码的十六进制表示为 $\\texttt{0x7F800000}$，等同于二进制模式 `01111111100000000000000000000000`。\n    首先，我们对输入整数 $x$ 和指数掩码执行位与运算：\n    $$x_{exp} = x \\ \\text{AND} \\ \\texttt{0x7F800000}$$\n    此操作将除指数位之外的所有位都清零。结果 $x_{exp}$ 中的指数值向左偏移了 $23$ 个位置。为了获得 $e$ 的实际 $8$ 位值，我们必须执行 $23$ 位的逻辑右移：\n    $$e = (x \\ \\text{AND} \\ \\texttt{0x7F800000}) \\gg 23$$\n    得到的 $e$ 值将是范围在 $\\{0, 1, \\dots, 255\\}$ 内的整数。\n\n2.  **小数场 ($f$) 提取：**\n    小数场占据低 $23$ 位（位 $0$ 到位 $22$）。用于分离此字段的掩码在这些位置为 $1$，在其他位置为 $0$。这个掩码的十六进制表示为 $\\texttt{0x007FFFFF}$，对应于二进制模式 `00000000011111111111111111111111`。\n    我们对输入整数 $x$ 和小数掩码执行位与运算。由于该字段已与最低有效位对齐，因此不需要移位。\n    $$f = x \\ \\text{AND} \\ \\texttt{0x007FFFFF}$$\n    得到的 $f$ 值将是范围在 $\\{0, 1, \\dots, 2^{23}-1\\}$ 内的整数。\n\n对于此分类问题，符号位 $s$ 不是必需的，因为规则仅取决于 $e$ 和 $f$。例如，$+0$ 和 $-0$ 都被分类为零。\n\n**第 2 步：基于提取的字段进行分类**\n\n一旦获得 $e$ 和 $f$ 的值，我们就可以应用问题描述中提供的分类规则。这些规则构成了一组互斥的条件，涵盖了 $e$ 和 $f$ 的所有可能组合。该逻辑通过一系列条件检查来实现。一个稳健的方法是首先测试特殊的指数值（$e=0$ 和 $e=255$）。\n\n设 $E_{max} = 2^8 - 1 = 255$。\n\n- **情况 1：$e = E_{max} = 255_d = \\texttt{0xFF}_{h}$**\n  这种情况对应于无穷大和 NaN。\n  - 如果 $f = 0$，则该数字为**无穷大**。分类代码为 $3$。这对于正无穷大（$\\texttt{0x7F800000}$）和负无穷大（$\\texttt{0xFF800000}$）都成立。\n  - 如果 $f \\ne 0$，则该数字为**非数字（NaN）**。分类代码为 $4$。\n\n- **情况 2：$e = 0$**\n  这种情况对应于零和非规格化（denormalized）数。\n  - 如果 $f = 0$，则该数字为**零**。分类代码为 $0$。这对于正零（$\\texttt{0x00000000}$）和负零（$\\texttt{0x80000000}$）都成立。\n  - 如果 $f \\ne 0$，则该数字为**非规格化有限数**。分类代码为 $1$。\n\n- **情况 3：$1 \\le e \\le 254$**\n  如果指数 $e$ 不是 $0$ 也不是 $255$，则根据定义，该数字为**规格化有限数**。分类代码为 $2$。\n\n这套规则为根据 IEEE $754$ 标准对任何 $32$ 位模式进行分类提供了一个完整的决策过程。将此逻辑应用于提供的测试用例，即可得出最终的分类代码序列。\n\n例如，我们来分析 $x_4 = \\texttt{0x00012345}$：\n- $x = \\texttt{0x00012345}$\n- $e = (\\texttt{0x00012345} \\ \\text{AND} \\ \\texttt{0x7F800000}) \\gg 23 = 0 \\gg 23 = 0$。\n- $f = \\texttt{0x00012345} \\ \\text{AND} \\ \\texttt{0x007FFFFF} = \\texttt{0x00012345}$。\n- 由于 $e=0$ 且 $f \\ne 0$，该数字是非规格化的，其代码为 $1$。\n\n再举一个例子，我们来分析 $x_8 = \\texttt{0x7F800000}$：\n- $x = \\texttt{0x7F800000}$\n- $e = (\\texttt{0x7F800000} \\ \\text{AND} \\ \\texttt{0x7F800000}) \\gg 23 = \\texttt{0x7F800000} \\gg 23$。指数位的二进制模式是 `11111111`，其十进制值为 $255$。所以，$e=255$。\n- $f = \\texttt{0x7F800000} \\ \\text{AND} \\ \\texttt{0x007FFFFF} = 0$。\n- 由于 $e=255$ 且 $f=0$，该数字是无穷大，其代码为 $3$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Classifies 32-bit unsigned integers representing IEEE 754 single-precision\n    floating-point numbers using only bitwise integer operations.\n    \"\"\"\n    \n    # Define the test cases from the problem statement as unsigned 32-bit integers.\n    test_cases = [\n        0x00000000,  # x1: +0\n        0x80000000,  # x2: -0\n        0x00000001,  # x3: smallest positive subnormal\n        0x00012345,  # x4: a subnormal number\n        0x00800000,  # x5: smallest positive normalized\n        0x3F800000,  # x6: 1.0\n        0x7F7FFFFF,  # x7: largest normalized\n        0x7F800000,  # x8: +infinity\n        0xFF800000,  # x9: -infinity\n        0x7FC00000,  # x10: a quiet NaN\n    ]\n\n    results = []\n    \n    # Constants for bitwise field extraction based on the IEEE 754 binary32 format.\n    # Exponent field: bits 23-30\n    EXP_MASK = np.uint32(0x7F800000)\n    # Fraction/significand field: bits 0-22\n    FRAC_MASK = np.uint32(0x007FFFFF)\n    \n    # The maximum value for the 8-bit exponent field (all bits set to 1).\n    EXP_MAX = np.uint32(0xFF) # 255 in decimal\n\n    for x_int in test_cases:\n        # We work with numpy.uint32 to be explicit about the 32-bit nature of the data,\n        # aligning with common practices in numerical computing.\n        x = np.uint32(x_int)\n        \n        # Extract the 8-bit exponent field by masking and right-shifting.\n        exp_field = (x  EXP_MASK) >> np.uint32(23)\n        \n        # Extract the 23-bit fraction field by masking.\n        frac_field = x  FRAC_MASK\n        \n        # Apply the classification rules defined in the problem statement.\n        \n        # Case 1: Exponent bits are all 1s (e = 255)\n        # This corresponds to infinities and NaNs.\n        if exp_field == EXP_MAX:\n            if frac_field == 0:\n                # Code 3: infinity\n                results.append(3)\n            else:\n                # Code 4: not-a-number (NaN)\n                results.append(4)\n        \n        # Case 2: Exponent bits are all 0s (e = 0)\n        # This corresponds to zeros and subnormal numbers.\n        elif exp_field == 0:\n            if frac_field == 0:\n                # Code 0: zero\n                results.append(0)\n            else:\n                # Code 1: subnormal (denormalized)\n                results.append(1)\n        \n        # Case 3: Exponent is in the range [1, 254]\n        # This corresponds to normalized numbers.\n        else:\n            # Code 2: normalized\n            results.append(2)\n\n    # Format the final output as a comma-separated list in brackets.\n    # The problem asks for the output format: [c1,c2,...,c10]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3257791"}]}