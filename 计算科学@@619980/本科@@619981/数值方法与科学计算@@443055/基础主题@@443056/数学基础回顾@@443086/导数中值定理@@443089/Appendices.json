{"hands_on_practices": [{"introduction": "中值定理保证了点 $c$ 的存在性，但并未直接给出其求解方法。本练习将中值定理的陈述性结论转化为一个具体的计算任务。通过将中值定理方程 $f'(c) = \\frac{f(b) - f(a)}{b-a}$ 重新构造为一个多项式求根问题，你将开发一个算法来精确定位这些点 $c$，从而对该定理获得更深刻、更具操作性的理解。[@problem_id:3251031]", "problem": "设计并实现一个完整的、可运行的程序，对于一个给定的实数多项式 $f$ 和一个闭区间 $[a,b]$（其中 $a  b$），找到所有位于 $(a,b)$ 内且满足中值定理结论的值 $c$，并返回一个按升序排列的列表。", "solution": "该问题要求找到一个开区间 $(a,b)$ 内的所有值 $c$，这些值满足给定实数多项式 $f(x)$ 的中值定理 (MVT) 的结论。MVT 指出，对于一个在闭区间 $[a,b]$ 上连续且在开区间 $(a,b)$ 上可微的函数 $f$，必须存在至少一个数 $c \\in (a,b)$，使得在 $c$ 点的瞬时变化率等于在 $[a,b]$ 上的平均变化率。由于任何多项式函数在整个实数线上都是连续且可微的，因此 MVT 总是适用的。该定理的结论由以下方程表示：\n$$\nf'(c) = \\frac{f(b) - f(a)}{b-a}\n$$\n为了找到所有这样的 $c$ 值，我们可以将其转化为一个求根问题。令 $s$ 代表恒定的平均变化率（连接区间上 $f$ 图像端点的割线斜率）：\n$$\ns = \\frac{f(b) - f(a)}{b-a}\n$$\n我们寻求的 $c$ 值是方程 $f'(c) = s$ 的解中严格位于区间 $(a,b)$ 内的那些。这等价于找到一个新多项式 $g(x)$ 的根，定义为：\n$$\ng(x) = f'(x) - s\n$$\n解决此问题的算法步骤如下：\n\n1.  **多项式表示与微分**：一个 $n$ 次实数多项式，给定为 $f(x) = p_{n}x^{n} + p_{n-1}x^{n-1} + \\dots + p_{1}x + p_{0}$，由其系数向量 $[p_{n}, p_{n-1}, \\dots, p_{0}]$ 表示。其导数 $f'(x)$ 是一个 $n-1$ 次多项式：\n    $$\n    f'(x) = n p_{n}x^{n-1} + (n-1)p_{n-1}x^{n-2} + \\dots + p_{1}\n    $$\n    $f'(x)$ 的系数可从 $f(x)$ 的系数通过算法计算得出。\n\n2.  **构造求根方程**：首先根据定义计算标量值 $s$。由于保证 $a  b$，分母 $b-a$ 不为零，因此 $s$ 的定义是明确的。然后，通过从 $f'(x)$ 的系数中减去 $s$（即修改常数项）来形成多项式 $g(x) = f'(x) - s$。\n\n3.  **多项式求根**：使用一个数值上稳健的算法（例如，基于伴随矩阵特征值的方法）来找到 $g(x) = 0$ 的所有复数根。\n\n4.  **根的筛选**：对找到的根进行筛选，只保留那些满足以下所有条件的根：\n    a.  **实数根**：根的虚部在数值上接近于零（例如，小于一个小容差 $\\epsilon_{\\text{imag}}$）。\n    b.  **区间内**：根的实部严格位于开区间 $(a,b)$ 内。在数值比较中应使用一个小容差以避免边界问题。\n    c.  **残差验证**：为确保数值精度，通过将候选根代入原始方程 $f'(c) - s = 0$ 并检查残差的绝对值是否小于某个小容差 $\\epsilon_{\\text{res}}$ 来验证根的质量。\n\n5.  **输出**：收集所有通过筛选的实数根，对它们进行排序，并去除因数值计算而产生的重复项，最终输出一个按升序排列的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_mvt_case(coeffs, a, b):\n    \"\"\"\n    Finds all values c in (a,b) that satisfy the Mean Value Theorem for a polynomial.\n\n    Args:\n        coeffs (list of float): Coefficients of the polynomial f(x) in descending order.\n        a (float): The start of the interval [a,b].\n        b (float): The end of the interval [a,b].\n\n    Returns:\n        list of float: Sorted list of unique values of c satisfying the MVT.\n    \"\"\"\n    # Numerical tolerances from the problem statement\n    T_IMAG = 1e-9\n    T_RES = 1e-8\n    T_INT = 1e-12\n    T_MERGE = 1e-8\n\n    # 1. Represent f(x) as a polynomial object and compute its derivative f'(x)\n    f_poly = np.poly1d(coeffs)\n    f_prime_poly = f_poly.deriv()\n\n    # 2. Compute the average rate of change s on [a,b]\n    if b - a == 0:\n        return []  # Should not happen given a  b, but for robustness.\n    s = (f_poly(b) - f_poly(a)) / (b - a)\n\n    # 3. Form the polynomial g(x) = f'(x) - s\n    g_poly = f_prime_poly - s\n\n    # 4. Handle the special case of infinitely many solutions\n    # This occurs if g(x) is the zero polynomial (f'(x) is constant and equals s).\n    if np.allclose(g_poly.coeffs, 0):\n        return []\n\n    # 5. Find all complex roots of g(x) = 0\n    roots = np.roots(g_poly.coeffs)\n\n    # 6. Filter the roots based on the specified criteria\n    # 6.1. Keep only roots that are effectively real\n    real_candidates = [r.real for r in roots if abs(r.imag) = T_IMAG]\n\n    # 6.2. Keep only roots strictly within the interval (a, b) with a guard\n    interval_candidates = [x for x in real_candidates if a + T_INT = x = b - T_INT]\n\n    # 6.3. Keep only roots that satisfy the residual tolerance\n    accepted_roots = [x for x in interval_candidates if abs(f_prime_poly(x) - s) = T_RES]\n    \n    # 7. Sort and deduplicate the final list of roots\n    accepted_roots.sort()\n\n    if not accepted_roots:\n        return []\n\n    # Merge numerically close roots by keeping the first of each cluster\n    deduplicated_roots = [accepted_roots[0]]\n    last_kept_root = accepted_roots[0]\n    for i in range(1, len(accepted_roots)):\n        if abs(accepted_roots[i] - last_kept_root) > T_MERGE:\n            deduplicated_roots.append(accepted_roots[i])\n            last_kept_root = accepted_roots[i]\n\n    return deduplicated_roots\n\ndef solve():\n    \"\"\"\n    Main driver function to run the test suite and print the formatted output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([1, 0, -3, 0], -2.0, 2.0),\n        ([1, 0, 0, 0, 0], -1.0, 2.0),\n        ([1, 0, -2, 0, 0], -1.0, 1.0),\n        ([1, 0, -5, 0, 4, 0], -2.0, 2.0),\n        ([1, 0, 0], 0.0, 1e-8),\n    ]\n\n    all_results_formatted = []\n    for case in test_cases:\n        coeffs, a, b = case\n        c_values = solve_mvt_case(coeffs, a, b)\n        \n        # Format numbers to fixed-point with 12 decimal places\n        formatted_c_values = [f\"{c:.12f}\" for c in c_values]\n        \n        # Format the list of numbers as a string \"[num1,num2,...]\"\n        result_string = f\"[{','.join(formatted_c_values)}]\"\n        all_results_formatted.append(result_string)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_formatted)}]\")\n\nsolve()\n```", "id": "3251031"}, {"introduction": "微分中值定理不仅是一个抽象的存在性定理，它更是数值方法中误差分析的强大工具。在最后的这个实践中，你将运用中值定理（及其推论泰勒定理）来推导基本有限差分公式的截断误差。通过数值验证这些公式的精度阶，你将把微积分的核心概念与计算算法的实际性能及可靠性联系起来。[@problem_id:3251126]", "problem": "要求您将导数的中值定理 (MVT) 与有限差分公式的截断误差联系起来，并数值验证其精度阶。从微积分的核心定义开始：连续性、可微性、微积分基本定理和导数中值定理。中值定理 (MVT) 指出，对于一个在区间 $(a,b)$ 上可微且在 $[a,b]$ 上连续的函数 $f$，存在 $\\xi \\in (a,b)$ 使得 $f(b) - f(a) = (b-a) f'(\\xi)$。使用此原理来推断误差项。\n\n任务 A (推导)：使用中值定理 (MVT) 及其推论，为以下近似导数 $f'(x)$ 的有限差分公式推导主阶截断误差：\n- 前向差分 (单侧)：$\\displaystyle D^{+}_h f(x) = \\frac{f(x+h) - f(x)}{h}$。\n- 中心差分 (双侧)：$\\displaystyle D^{0}_h f(x) = \\frac{f(x+h) - f(x-h)}{2h}$。\n\n您的推导必须从中值定理 (MVT) 和可微性的基础出发，不得使用未经证明的快捷公式。使用标准且切合实际的假设：\n- 对于前向差分，假设 $f$ 在包含 $[x, x+h]$ 的区间上是二次连续可微的。\n- 对于中心差分，假设 $f$ 在包含 $[x-h, x+h]$ 的区间上是三次连续可微的。\n\n解释 MVT 如何引出给出主导误差行为的中间点的存在，并得出作为 $h$ 的函数的预期精度阶。\n\n任务 B (数值验证)：实现一个程序，使用指定的有限差分公式计算近似导数，评估与精确导数 $f'(x)$ 的绝对误差，并通过对一系列步长 $\\{h_i\\}$ 的数据 $\\left(\\log h_i, \\log \\text{error}_i\\right)$ 使用最小二乘法拟合一条直线来估计观测到的阶数 $p$。该直线的斜率即为测得的阶数 $p$。使用自然对数。如果对于给定的 $h_i$，误差在数值上为零，则在拟合中排除该 $h_i$。\n\n角度规定：对于任何三角函数，角度都必须以弧度为单位。\n\n测试套件：\n- 案例 $1$ (正常情况，单侧边界公式)：$f(x) = e^x$， $x_0 = 0.2$，方案 $D^{+}_h$， $h$ 值为 $\\{0.1, 0.05, 0.025, 0.0125, 0.00625\\}$。报告测得的阶数 $p$ (预期约为 $1$)。\n- 案例 $2$ (正常情况，双侧内部公式)：$f(x) = \\sin(x)$， $x_0 = 1.0$ (弧度)，方案 $D^{0}_h$， $h$ 值为 $\\{0.1, 0.05, 0.025, 0.0125, 0.00625\\}$。报告测得的阶数 $p$ (预期约为 $2$)。\n- 案例 $3$ (说明浮点舍入误差主导的边缘情况)：$f(x) = \\cos(x)$， $x_0 = 1.0$ (弧度)，方案 $D^{0}_h$， $h$ 值为 $\\{10^{-8}, 5\\times 10^{-9}, 2.5\\times 10^{-9}, 1.25\\times 10^{-9}\\}$。报告测得的阶数 $p$。在此范围内，相减抵消和机器$\\varepsilon \\approx 2.22 \\times 10^{-16}$ 的有限精度可能会占主导地位，因此 $p$ 可能会显著偏离理论截断阶。\n\n您的程序必须计算每种情况下的实测阶数 $p$，并生成一行输出，其中包含三个结果，以逗号分隔并用方括号括起，每个 $p$ 值四舍五入到三位小数 (例如，$\\left[1.001,1.998,-0.012\\right]$)。不应打印其他文本。\n\n所有计算都是无量纲的；不涉及物理单位。角度以弧度为单位。唯一允许使用的库是 Python 标准库和 NumPy。", "solution": "本任务旨在使用导数的中值定理 (MVT) 推导前向和中心有限差分公式的截断误差，并数值验证其精度阶。MVT 指出，对于一个在区间 $(a,b)$ 上可微且在 $[a,b]$ 上连续的函数 $f$，存在一点 $\\xi \\in (a,b)$ 使得 $f(b) - f(a) = (b-a) f'(\\xi)$。通过重复应用该定理得到的一个直接推论是带有拉格朗日余项形式的泰勒定理。我们将使用这个推论来进行推导。\n\n### 任务 A：截断误差的推导\n\n对于 $f'(x)$ 的有限差分近似 $D_h f(x)$，其截断误差 $E(x,h)$ 定义为精确导数与其近似值之间的差：$E(x,h) = f'(x) - D_h f(x)$。精度阶 $p$ 是误差主项中的指数，使得 $|E(x,h)| = O(h^p)$。\n\n#### 1. 前向差分公式\n\n前向差分公式由 $D^{+}_h f(x) = \\frac{f(x+h) - f(x)}{h}$ 给出。我们假设函数 $f$ 在包含 $[x, x+h]$ 的区间上是二次连续可微的，记作 $f \\in C^2$。\n\n根据带有拉格朗日余项的泰勒定理，我们可以在点 $x$ 附近展开 $f(x+h)$。对于 $C^2$ 中的函数，这给出：\n$$\nf(x+h) = f(x) + f'(x)h + \\frac{f''(\\xi_1)}{2!}h^2\n$$\n对于某个中间点 $\\xi_1 \\in (x, x+h)$。这个公式是对为分析泰勒多项式余项而构造的辅助函数应用中值定理（特别是中值定理的一个特例——罗尔定理）的直接结果。\n\n重新整理泰勒展开式以分离出前向差分公式中的项，我们得到：\n$$\nf(x+h) - f(x) = f'(x)h + \\frac{f''(\\xi_1)}{2}h^2\n$$\n两边除以 $h$ (其中 $h \\neq 0$)：\n$$\n\\frac{f(x+h) - f(x)}{h} = f'(x) + \\frac{f''(\\xi_1)}{2}h\n$$\n左边的项是前向差分近似 $D^{+}_h f(x)$。所以，我们有：\n$$\nD^{+}_h f(x) = f'(x) + \\frac{f''(\\xi_1)}{2}h\n$$\n因此，截断误差为：\n$$\nE(x,h) = f'(x) - D^{+}_h f(x) = - \\frac{f''(\\xi_1)}{2}h\n$$\n误差的量值为 $|E(x,h)| = \\left| \\frac{f''(\\xi_1)}{2} \\right| |h|$。由于 $f \\in C^2$，二阶导数 $f''$ 在 $[x, x+h]$ 上是连续且有界的。当 $h \\to 0$ 时，$\\xi_1 \\to x$，并且 $f''(\\xi_1) \\to f''(x)$。如果 $f''(x) \\neq 0$，则误差与 $h$ 成正比。因此，前向差分公式的主阶误差为 $O(h)$，其精度阶为 $p=1$。\n\n#### 2. 中心差分公式\n\n中心差分公式由 $D^{0}_h f(x) = \\frac{f(x+h) - f(x-h)}{2h}$ 给出。我们假设函数 $f$ 在包含 $[x-h, x+h]$ 的区间上是三次连续可微的，即 $f \\in C^3$。\n\n我们再次使用带有拉格朗日余项的泰勒定理，这次展开到更高阶。我们围绕点 $x$ 写出 $f(x+h)$ 和 $f(x-h)$ 的展开式：\n$$\nf(x+h) = f(x) + f'(x)h + \\frac{f''(x)}{2!}h^2 + \\frac{f'''(\\xi_1)}{3!}h^3 \\quad \\text{对于某个 } \\xi_1 \\in (x, x+h)\n$$\n$$\nf(x-h) = f(x) + f'(x)(-h) + \\frac{f''(x)}{2!}(-h)^2 + \\frac{f'''(\\xi_2)}{3!}(-h)^3 \\quad \\text{对于某个 } \\xi_2 \\in (x-h, x)\n$$\n简化第二个展开式：\n$$\nf(x-h) = f(x) - f'(x)h + \\frac{f''(x)}{2}h^2 - \\frac{f'''(\\xi_2)}{6}h^3\n$$\n为了构成中心差分，我们从第一个展开式中减去第二个展开式：\n$$\nf(x+h) - f(x-h) = (f(x)-f(x)) + (f'(x)h - (-f'(x)h)) + \\left(\\frac{f''(x)}{2}h^2 - \\frac{f''(x)}{2}h^2\\right) + \\left(\\frac{f'''(\\xi_1)}{6}h^3 - \\left(-\\frac{f'''(\\xi_2)}{6}h^3\\right)\\right)\n$$\n涉及 $f(x)$ 和 $f''(x)$ 的项相互抵消，剩下：\n$$\nf(x+h) - f(x-h) = 2f'(x)h + \\frac{h^3}{6} (f'''(\\xi_1) + f'''(\\xi_2))\n$$\n两边除以 $2h$ (其中 $h \\neq 0$)：\n$$\n\\frac{f(x+h) - f(x-h)}{2h} = f'(x) + \\frac{h^2}{12} (f'''(\\xi_1) + f'''(\\xi_2))\n$$\n左边是中心差分近似 $D^{0}_h f(x)$。截断误差为：\n$$\nE(x,h) = f'(x) - D^{0}_h f(x) = -\\frac{h^2}{12} (f'''(\\xi_1) + f'''(\\xi_2))\n$$\n由于 $f \\in C^3$，三阶导数 $f'''$ 在区间 $[x-h, x+h]$上是连续的，该区间包含 $\\xi_1$ 和 $\\xi_2$。根据介值定理，存在一点 $\\xi \\in (\\xi_2, \\xi_1) \\subset (x-h, x+h)$，使得 $f'''(\\xi) = \\frac{f'''(\\xi_1) + f'''(\\xi_2)}{2}$。因此我们可以简化误差表达式：\n$$\nE(x,h) = -\\frac{h^2}{6} f'''(\\xi)\n$$\n误差的量值为 $|E(x,h)| = \\left| \\frac{f'''(\\xi)}{6} \\right| h^2$。当 $h \\to 0$ 时，$\\xi \\to x$，并且 $f'''(\\xi) \\to f'''(x)$。如果 $f'''(x) \\neq 0$，则误差与 $h^2$ 成正比。因此，中心差分公式的主阶误差为 $O(h^2)$，其精度阶为 $p=2$。\n\n### 任务 B：数值验证\n\n对于一个 $p$ 阶方法，绝对误差 $|E|$ 和步长 $h$ 之间的理论关系是 $|E| \\approx C h^p$，其中 $C$ 是一个常数，且 $h$ 足够小。对两边取自然对数，得到一个线性关系：\n$$\n\\ln(|E|) \\approx \\ln(C) + p \\ln(h)\n$$\n这个方程的形式为 $y = c + mx$，其中 $y = \\ln(|E|)$，$x = \\ln(h)$，斜率 $m$ 是精度阶 $p$，截距 $c$ 是 $\\ln(C)$。通过为一系列递减的步长 $\\{h_i\\}$ 计算误差，我们可以生成一组数据点 $(\\ln(h_i), \\ln(|E_i|))$。对这些点应用线性最小二乘回归，可以数值估计斜率 $p$，即观测到的精度阶。以下程序为指定的测试案例实现了此过程。对于极小的 $h$ 值，当浮点舍入误差（其量级为 $O(h^{-1})$）超过截断误差并占主导地位时，这种关系便不再成立。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the observed order of accuracy for finite difference schemes.\n    \"\"\"\n    \n    # Define test cases as a list of dictionaries.\n    test_cases = [\n        {\n            \"f\": lambda x: np.exp(x),\n            \"f_prime\": lambda x: np.exp(x),\n            \"x0\": 0.2,\n            \"scheme\": \"D+\",\n            \"h_values\": np.array([0.1, 0.05, 0.025, 0.0125, 0.00625])\n        },\n        {\n            \"f\": lambda x: np.sin(x),\n            \"f_prime\": lambda x: np.cos(x),\n            \"x0\": 1.0,\n            \"scheme\": \"D0\",\n            \"h_values\": np.array([0.1, 0.05, 0.025, 0.0125, 0.00625])\n        },\n        {\n            \"f\": lambda x: np.cos(x),\n            \"f_prime\": lambda x: -np.sin(x),\n            \"x0\": 1.0,\n            \"scheme\": \"D0\",\n            \"h_values\": np.array([1e-8, 5e-9, 2.5e-9, 1.25e-9])\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        f = case[\"f\"]\n        f_prime = case[\"f_prime\"]\n        x0 = case[\"x0\"]\n        scheme = case[\"scheme\"]\n        h_values = case[\"h_values\"]\n        \n        log_h = []\n        log_error = []\n        \n        exact_derivative = f_prime(x0)\n        \n        for h in h_values:\n            if scheme == \"D+\":\n                # Forward difference formula\n                approx_derivative = (f(x0 + h) - f(x0)) / h\n            elif scheme == \"D0\":\n                # Central difference formula\n                approx_derivative = (f(x0 + h) - f(x0 - h)) / (2 * h)\n            else:\n                # Should not happen with given test cases\n                raise ValueError(\"Unknown scheme\")\n            \n            # Calculate absolute error\n            error = np.abs(exact_derivative - approx_derivative)\n            \n            # Exclude data points where error is numerically zero\n            if error > 0:\n                log_h.append(np.log(h))\n                log_error.append(np.log(error))\n\n        # Perform linear least-squares fit to find the order of accuracy (the slope)\n        if len(log_h) > 1:\n            log_h_np = np.array(log_h)\n            log_error_np = np.array(log_error)\n            \n            # We are fitting log_error = p * log_h + log_C\n            # This is a linear system Ax = b, where x = [p, log_C]^T\n            A = np.vstack([log_h_np, np.ones(len(log_h_np))]).T\n            p, _ = np.linalg.lstsq(A, log_error_np, rcond=None)[0]\n            results.append(p)\n        else:\n            # Handle cases with insufficient data for a fit\n            results.append(np.nan)\n\n    # Format output according to the problem specification\n    # e.g., [1.001,1.998,-0.012]\n    output_str = f\"[{','.join([f'{p:.3f}' for p in results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3251126"}]}