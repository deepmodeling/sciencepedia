{"hands_on_practices": [{"introduction": "要真正掌握二分法，我们必须将其应用于实际问题。第一个练习 [@problem_id:3210875] 将抽象的理论植根于一个真实的物理场景：计算辐射屏蔽所需的厚度。您不仅将应用该算法，还将使用介值定理来证明其使用的合理性，并预先计算达到所需精度所需的步骤数，从而将理论保证与实际执行联系起来。", "problem": "一束窄的伽马辐射束穿过一块厚度为 $x$ (单位：厘米) 的铅板，其穿过铅板后的强度由衰减定律 $I(x) = I_0 \\exp(-\\mu x)$ 建模，其中 $I_0$ 是入射强度，$\\mu$ 是铅在相应光子能量下的线性衰减系数。安全阈值要求透射强度满足 $I(x) = I_{\\text{safe}}$。考虑由 $f(x) = I(x) - I_{\\text{safe}}$ 定义的求根问题，因此目标厚度是 $f(x) = 0$ 的解。取 $I_0 = 8.0 \\times 10^{-3}$ Sv/h，$\\mu = 1.25$ cm$^{-1}$，以及 $I_{\\text{safe}} = 1.0 \\times 10^{-6}$ Sv/h。\n\n仅使用介值定理和二分法的定义，完成以下任务：\n- 在一个物理上合理的区间内，证明函数 $f(x)$ 的根的存在性和唯一性。\n- 在区间 $[0, 10]$ (单位：厘米) 上初始化二分法，并确定保证厚度的绝对误差小于 $\\varepsilon = 0.01$ cm 所需的最小二分迭代次数。\n- 执行该次数的二分迭代，以获得所需厚度的数值近似值。\n\n将最终厚度四舍五入到 $4$ 位有效数字。以厘米 (cm) 为单位表示最终厚度。", "solution": "该问题要求使用二分法分析将伽马辐射衰减到安全水平所需的铅板厚度。首先，该问题经过验证，是科学上合理且适定的。我们将按顺序解决问题的每个部分。\n\n求根问题是求解 $f(x) = 0$，其中函数 $f(x)$ 定义为：\n$$f(x) = I_0 \\exp(-\\mu x) - I_{\\text{safe}}$$\n给定的参数是入射强度 $I_0 = 8.0 \\times 10^{-3}$ Sv/h，线性衰减系数 $\\mu = 1.25$ cm$^{-1}$，以及安全强度阈值 $I_{\\text{safe}} = 1.0 \\times 10^{-6}$ Sv/h。变量 $x$ 代表铅板的厚度，单位是厘米。\n\n**根的存在性与唯一性证明**\n\n首先，我们在一个物理上合理的区间内确定根的存在性。厚度 $x$ 必须为非负值，因此感兴趣的定义域是 $[0, \\infty)$。问题建议的区间是 $[0, 10]$。\n\n1.  **连续性**：函数 $f(x)$ 是指数函数和线性函数的复合，这些函数对所有实数都是连续的。因此，$f(x)$ 在区间 $[0, \\infty)$ 上是连续的。\n\n2.  **介值定理 (IVT)**：我们在区间 $[0, 10]$ 的端点上计算函数 $f(x)$ 的值。\n    在 $x=0$ 处：\n    $$f(0) = I_0 \\exp(0) - I_{\\text{safe}} = I_0 - I_{\\text{safe}} = 8.0 \\times 10^{-3} - 1.0 \\times 10^{-6} = 7.999 \\times 10^{-3}$$\n    由于 $f(0) > 0$，函数在左端点为正。\n    在 $x=10$ 处：\n    $$f(10) = I_0 \\exp(-\\mu \\times 10) - I_{\\text{safe}} = (8.0 \\times 10^{-3}) \\exp(-1.25 \\times 10) - 1.0 \\times 10^{-6}$$\n    $$f(10) = (8.0 \\times 10^{-3}) \\exp(-12.5) - 1.0 \\times 10^{-6}$$\n    使用近似值 $\\exp(-12.5) \\approx 3.727 \\times 10^{-6}$：\n    $$f(10) \\approx (8.0 \\times 10^{-3})(3.727 \\times 10^{-6}) - 1.0 \\times 10^{-6} \\approx 2.981 \\times 10^{-8} - 1.0 \\times 10^{-6} \\approx -9.702 \\times 10^{-7}$$\n    由于 $f(10)  0$，函数在右端点为负。\n    因为 $f(x)$ 在 $[0, 10]$ 上是连续的，并且 $f(0) > 0$ 和 $f(10)  0$，所以介值定理保证在开区间 $(0, 10)$ 内至少存在一个根 $x^*$。\n\n3.  **唯一性**：为了证明唯一性，我们证明 $f(x)$ 是一个严格单调函数。设 $x_1$ 和 $x_2$ 是定义域 $[0, \\infty)$ 中任意两个不同的点，使得 $x_2 > x_1$。\n    由于系数 $\\mu = 1.25$ 是正数，将不等式乘以 $-\\mu$ 会反转其方向：\n    $$-\\mu x_2  -\\mu x_1$$\n    指数函数 $y(z) = \\exp(z)$ 对所有实数 $z$ 都是严格递增的。将其应用于不等式会保持方向不变：\n    $$\\exp(-\\mu x_2)  \\exp(-\\mu x_1)$$\n    入射强度 $I_0 = 8.0 \\times 10^{-3}$ 也是正数，所以再次乘以 $I_0$ 保持不等式不变：\n    $$I_0 \\exp(-\\mu x_2)  I_0 \\exp(-\\mu x_1)$$\n    最后，从两边减去常数 $I_{\\text{safe}}$ 不会改变不等式：\n    $$I_0 \\exp(-\\mu x_2) - I_{\\text{safe}}  I_0 \\exp(-\\mu x_1) - I_{\\text{safe}}$$\n    这等价于 $f(x_2)  f(x_1)$。\n    因此，对于任何 $x_2 > x_1$，我们有 $f(x_2)  f(x_1)$，这是严格递减函数的定义。一个严格单调的函数最多只能穿过任何水平线（包括 $y=0$）一次。由于我们已经确定了至少存在一个根，这证明了根是唯一的。\n\n**最小二分迭代次数**\n\n二分法从一个长度为 $L = b-a$ 的区间 $[a, b]$ 开始。经过 $n$ 次迭代后，近似值 $c_n$（第 $(n-1)$ 个区间的中点）相对于真根 $x^*$ 的绝对误差保证有界，其界限为：\n$$|c_n - x^*| \\leq \\frac{b-a}{2^n}$$\n我们给定的初始区间是 $[a, b] = [0, 10]$，要求的误差容限是 $\\varepsilon = 0.01$ cm。我们需要找到满足以下条件的最小整数 $n$：\n$$\\frac{10 - 0}{2^n}  0.01$$\n$$\\frac{10}{2^n}  \\frac{1}{100} \\implies 1000  2^n$$\n为了求解 $n$，我们对两边取以 $2$ 为底的对数：\n$$n > \\log_2(1000)$$\n我们可以计算这个值：\n$$n > \\frac{\\ln(1000)}{\\ln(2)} \\approx \\frac{6.907755}{0.693147} \\approx 9.96578$$\n由于迭代次数 $n$ 必须是整数，保证指定精度所需的最小迭代次数是 $n = 10$。\n\n**执行二分迭代**\n\n我们在区间 $[a_0, b_0] = [0, 10]$ 上执行 $10$ 次二分法迭代。在每一步 $k$，我们计算中点 $c_k = (a_{k-1} + b_{k-1})/2$。$f(c_k)$ 的符号决定了新的区间 $[a_k, b_k]$。$f(c_k) = I_0 \\exp(-\\mu c_k) - I_{\\text{safe}}$ 的符号，如果 $I_0 \\exp(-\\mu c_k) > I_{\\text{safe}}$ 则为正，否则为负。这等价于将 $c_k$ 与真根 $x^* = \\frac{1}{\\mu}\\ln(I_0/I_{\\text{safe}}) \\approx 7.1898$ 进行比较。如果 $c_k  x^*$，则 $f(c_k)>0$。如果 $c_k > x^*$，则 $f(c_k)0$。\n\n迭代过程总结如下：\n- **k=1**: $a_0 = 0, b_0 = 10$。$c_1 = 5.0$。$f(5.0) > 0$。新区间 $[a_1, b_1] = [5.0, 10.0]$。\n- **k=2**: $a_1 = 5.0, b_1 = 10.0$。$c_2 = 7.5$。$f(7.5)  0$。新区间 $[a_2, b_2] = [5.0, 7.5]$。\n- **k=3**: $a_2 = 5.0, b_2 = 7.5$。$c_3 = 6.25$。$f(6.25) > 0$。新区间 $[a_3, b_3] = [6.25, 7.5]$。\n- **k=4**: $a_3 = 6.25, b_3 = 7.5$。$c_4 = 6.875$。$f(6.875) > 0$。新区间 $[a_4, b_4] = [6.875, 7.5]$。\n- **k=5**: $a_4 = 6.875, b_4 = 7.5$。$c_5 = 7.1875$。$f(7.1875) > 0$。新区间 $[a_5, b_5] = [7.1875, 7.5]$。\n- **k=6**: $a_5 = 7.1875, b_5 = 7.5$。$c_6 = 7.34375$。$f(7.34375)  0$。新区间 $[a_6, b_6] = [7.1875, 7.34375]$。\n- **k=7**: $a_6 = 7.1875, b_6 = 7.34375$。$c_7 = 7.265625$。$f(7.265625)  0$。新区间 $[a_7, b_7] = [7.1875, 7.265625]$。\n- **k=8**: $a_7 = 7.1875, b_7 = 7.265625$。$c_8 = 7.2265625$。$f(7.2265625)  0$。新区间 $[a_8, b_8] = [7.1875, 7.2265625]$。\n- **k=9**: $a_8 = 7.1875, b_8 = 7.2265625$。$c_9 = 7.20703125$。$f(7.20703125)  0$。新区间 $[a_9, b_9] = [7.1875, 7.20703125]$。\n- **k=10**: $a_9 = 7.1875, b_9 = 7.20703125$。$c_{10} = 7.197265625$。\n\n经过 $10$ 次迭代后，根的数值近似值是最后计算的中点 $c_{10}$。\n所需厚度约为 $x \\approx 7.197265625$ cm。问题要求将此结果四舍五入到 $4$ 位有效数字。\n前四位有效数字是 $7, 1, 9, 7$。第五位数字是 $2$，小于 $5$，因此我们向下舍入。\n最终的数值近似值为 $7.197$ cm。", "answer": "$$\\boxed{7.197}$$", "id": "3210875"}, {"introduction": "虽然二分法保证在一个有效的区间内收敛到*一个*根，但当一个函数有多个根时会发生什么呢？这个练习 [@problem_id:3211006] 通过为一个具有多个零点的函数实现算法来探讨这个关键问题。通过测试不同的起始区间，您将亲身体会到初始区间的选择如何决定最终找到哪个根。", "problem": "考虑连续函数 $f(x) = \\sin(10x) - x$，其中正弦函数使用弧度制角。应用二分法（Bisection Method）在满足 $f(a) \\cdot f(b)  0$ 的闭区间 $[a,b]$ 内寻找 $f(x)$ 的一个实根。假设在计算过程中不会发生浮点数下溢或上溢。您的任务是实现一个完整的二分法程序，该程序针对测试套件中的每个区间，在不使用任何外部输入的情况下完成以下所有操作：\n- 在每次迭代中，选择中点 $m = \\frac{a+b}{2}$。\n- 通过保持变号条件来确定下一个区间。\n- 当 $f(m)$ 恰好等于 $0$ 或区间长度小于等于预设容差时终止。\n- 报告近似根以及由终止时的最终区间长度所隐含的最坏情况绝对误差界。\n\n推导和算法设计必须明确地从适用于二分法的基本数学原理开始，特别是闭区间上连续函数的介值定理（Intermediate Value Theorem）和区间套的基本性质。除了这些原理，您不得依赖任何特定领域的捷径。\n\n为以下测试套件实现该程序，该套件涵盖了标准情况、对称性检查和多根包围。在每种情况下，对区间长度使用 $10^{-12}$ 的终止容差，并设置最多 $1000$ 次迭代。\n- 测试 1：区间 $[-2,2]$。\n- 测试 2：区间 $[0.25,0.3]$。\n- 测试 3：区间 $[-0.3,-0.25]$。\n- 测试 4：区间 $[0.7,0.75]$。\n- 测试 5：区间 $[-1,1]$。\n\n对于每个测试，计算：\n- 算法返回的近似根 $r$。\n- 最坏情况绝对误差界 $E$，定义为终止时最终区间长度的一半。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试的结果本身就是一个列表 $[r,E]$。$r$ 和 $E$ 都必须表示为四舍五入到 $10$ 位小数的十进制浮点数。例如，输出应类似于 $[[r_1,E_1],[r_2,E_2],\\dots]$，不含空格。所有计算中角度必须以弧度处理。", "solution": "该问题要求实现二分法，以在给定的闭区间 $[a, b]$ 上找到连续函数 $f(x) = \\sin(10x) - x$ 的一个实根，前提是满足初始条件 $f(a) \\cdot f(b)  0$。当区间长度小于等于 $10^{-12}$ 的容差，或达到最多 $1000$ 次迭代后，过程必须终止。每个测试用例的最终输出必须包括近似根和最坏情况绝对误差界。\n\n该算法的设计基于介值定理和区间套性质。\n\n**基本原理：介值定理 (Intermediate Value Theorem, IVT)**\nIVT 指出，如果一个函数 $g(x)$ 在闭区间 $[a, b]$ 上是连续的，那么对于 $g(a)$ 和 $g(b)$ 之间的任何值 $k$，在开区间 $(a, b)$ 内至少存在一个数 $c$，使得 $g(c) = k$。\n\n为了求根，我们考虑 $k=0$ 的情况。如果一个在区间 $[a,b]$ 上的连续函数 $f(x)$ 的函数值 $f(a)$ 和 $f(b)$ 异号，即它们的乘积 $f(a) \\cdot f(b)  0$，那么 $0$ 就是 $f(a)$ 和 $f(b)$ 之间的一个值。IVT 于是保证在 $(a, b)$ 内存在至少一个根 $c$，使得 $f(c) = 0$。所提供的函数 $f(x) = \\sin(10x) - x$ 是一个正弦函数和一个线性函数的和，这两者对所有实数都是连续的。因此，$f(x)$ 在任何闭区间上都是连续的，并且 IVT 适用。\n\n**算法设计：二分法**\n二分法以迭代的方式利用 IVT 来缩小包含根的区间。\n\n1.  **初始化**：从一个给定的区间 $[a_0, b_0]$ 开始，并验证 $f(a_0) \\cdot f(b_0)  0$。这确保了在 $[a_0, b_0]$ 内至少存在一个根。问题陈述保证了所有测试用例都满足此条件。设置迭代计数器 $k=0$。\n\n2.  **迭代**：对于当前区间 $[a_k, b_k]$，执行以下步骤：\n    a.  **计算中点**：计算区间的中点 $m_k = \\frac{a_k + b_k}{2}$。该中点 $m_k$ 作为根的当前近似值。\n    b.  **函数求值**：计算函数在中点处的值 $f(m_k)$。\n    c.  **更新区间**：根据 $f(m_k)$ 的符号，决定保留区间 $[a_k, b_k]$ 的哪一半作为下一次迭代的区间 $[a_{k+1}, b_{k+1}]$，以保持变号性质。\n        i.  如果 $f(m_k) = 0$（在浮点数运算中极不可能发生），则已精确找到根。算法终止。\n        ii. 如果 $f(a_k) \\cdot f(m_k)  0$，根必定位于左子区间。下一次迭代的新区间变为 $[a_{k+1}, b_{k+1}] = [a_k, m_k]$。\n        iii. 如果 $f(a_k) \\cdot f(m_k) > 0$，则 $f(a_k)$ 和 $f(m_k)$ 同号。由于我们知道 $f(a_k)$ 和 $f(b_k)$ 异号，那么必然是 $f(m_k)$ 和 $f(b_k)$ 异号。因此，根必定位于右子区间。新区间变为 $[a_{k+1}, b_{k+1}] = [m_k, b_k]$。\n    d.  迭代计数器加一 $k \\leftarrow k+1$。\n\n3.  **终止**：迭代过程持续进行，直到满足终止准则。\n    a.  区间长度 $b_k - a_k$ 小于或等于指定的容差 $\\epsilon_{tol} = 10^{-12}$。\n    b.  找到了精确根，$f(m_k) = 0$。\n    c.  达到了最大迭代次数 $N_{max} = 1000$。这是一个安全措施。\n\n**收敛性与误差分析**\n区间序列 $[a_k, b_k]$ 构成一个区间套，即对于所有 $k \\geq 0$，都有 $[a_{k+1}, b_{k+1}] \\subset [a_k, b_k]$。在第 $k$ 次迭代时，区间长度记为 $L_k = b_k - a_k$，每一步减半：\n$$L_k = \\frac{L_{k-1}}{2} = \\dots = \\frac{L_0}{2^k}$$\n其中 $L_0 = b_0 - a_0$ 是初始区间长度。当 $k \\to \\infty$ 时，长度 $L_k \\to 0$。区间套定理（Nested Interval Theorem）确保这个闭区间套的无穷序列的交集收敛于一个单点。由于 IVT 保证在每个区间 $[a_k, b_k]$ 中都存在一个根，这个唯一的收敛点必定是函数的一个根。\n\n当算法终止时（例如在第 $N$ 次迭代），我们得到一个包含根 $r^*$ 的最终区间 $[a_N, b_N]$。该根的最佳估计值是这个最终区间的中点，我们将其报告为近似根 $r$：\n$$r = \\frac{a_N + b_N}{2}$$\n真根 $r^*$ 可以是 $[a_N, b_N]$ 内的任何点。我们近似值的绝对误差是 $|r - r^*|$。从中点 $r$ 到区间 $[a_N, b_N]$ 中任何点的最大可能距离出现在端点 $a_N$ 或 $b_N$ 处。这个最大距离是区间长度的一半。因此，绝对误差的一个保证上限，即最坏情况绝对误差 $E$，由下式给出：\n$$E = \\frac{b_N - a_N}{2}$$\n由于终止条件是 $b_N - a_N \\leq \\epsilon_{tol}$，所报告的根 $r$ 的误差界将满足 $E \\leq \\frac{\\epsilon_{tol}}{2}$，即 $E \\leq \\frac{10^{-12}}{2} = 5 \\times 10^{-13}$。程序将为所提供的每个测试用例计算并报告 $r$ 和 $E$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Bisection Method to find roots of f(x) = sin(10x) - x\n    for a given suite of test cases and formats the output as specified.\n    \"\"\"\n\n    # Define the function f(x)\n    def f(x: float) -> float:\n        return np.sin(10 * x) - x\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [-2.0, 2.0],        # Test 1\n        [0.25, 0.3],        # Test 2\n        [-0.3, -0.25],      # Test 3\n        [0.7, 0.75],        # Test 4\n        [-1.0, 1.0],        # Test 5\n    ]\n\n    # Define constants from the problem statement\n    TOLERANCE = 1e-12\n    MAX_ITER = 1000\n\n    results_list = []\n\n    for case in test_cases:\n        a, b = case[0], case[1]\n        \n        # Ensure the interval is correctly ordered\n        if a > b:\n            a, b = b, a\n\n        f_a = f(a)\n        \n        # The problem guarantees f(a) * f(b)  0, so no check is needed.\n\n        for _ in range(MAX_ITER):\n            # Check termination condition on interval length\n            if (b - a) = TOLERANCE:\n                break\n            \n            # Use this formulation for midpoint to avoid potential overflow with large a,b\n            # and maintain precision.\n            m = a + (b - a) / 2.0\n            f_m = f(m)\n\n            # Check for exact root found\n            if f_m == 0.0:\n                a, b = m, m\n                break\n\n            # Update the interval based on the sign change\n            if f_a * f_m  0:\n                b = m\n            else:\n                a = m\n                f_a = f_m # Update f_a since a has changed\n\n        # The final approximation is the midpoint of the last interval\n        approx_root = a + (b - a) / 2.0\n        \n        # The worst-case absolute error bound is half the final interval length\n        error_bound = (b - a) / 2.0\n\n        # Round results to 10 decimal places as specified\n        rounded_root = np.round(approx_root, 10)\n        rounded_error = np.round(error_bound, 10)\n        \n        # Format numbers to avoid scientific notation and ensure 10 decimal places\n        # This is for consistent string formatting, especially for very small errors\n        formatted_root = f\"{rounded_root:.10f}\"\n        formatted_error = f\"{rounded_error:.10f}\"\n        \n        results_list.append(f\"[{formatted_root},{formatted_error}]\")\n\n    # Final print statement in the exact required format: [[r1,E1],[r2,E2],...]\n    print(f\"[{','.join(results_list)}]\")\n\nsolve()\n```", "id": "3211006"}, {"introduction": "一个算法的力量通常在于其适应性。这最后一个练习 [@problem_id:3210918] 挑战您超越简单的求根思维，将二分法重新用于一个优化任务。您将修改算法，通过寻找函数导数的零点来找到函数的最小值，从而利用相同的符号检查逻辑来解决一类根本不同的问题。", "problem": "考虑一个可微的单峰实值函数 $f : \\mathbb{R} \\to \\mathbb{R}$，其在 $x^\\star$ 处有唯一的局部最小值。具有唯一局部最小值的单峰函数满足以下性质：其导数 $f'(x)$ 在所有 $x  x^\\star$ 处严格为负，在所有 $x > x^\\star$ 处严格为正，并在 $x^\\star$ 处等于零。如果导数 $f'(x)$ 是连续的且 $f'(a)  0  f'(b)$，则根据介值定理 (IVT)，可以保证 $f'(x)$ 在区间 $[a,b]$ 内存在一个根。根据关于驻点的 Fermat 定理，可微函数在开区间内的局部最小值出现在导数为零的点上。您的任务是设计并实现一种经典二分法的变体，该方法仅使用 $f'(x)$ 的符号检查来定位给定单峰函数的唯一局部最小值 $x^\\star$。\n\n算法要求：\n- 算法必须维护一个包围区间 $[a,b]$，并且仅依靠 $f'(x)$ 的符号来更新该区间。不得使用 $f'(x)$ 的大小或更高阶的导数。\n- 如果 $f'(a) = 0$，立即返回 $a$。如果 $f'(b) = 0$，立即返回 $b$。\n- 如果 $f'(a)  0  f'(b)$，则对 $f'(x)$ 执行二分法：在每次迭代中，计算 $m = \\frac{a+b}{2}$，评估 $f'(m)$ 的符号，如果 $f'(m)  0$ 则更新 $a \\leftarrow m$，如果 $f'(m) > 0$ 则更新 $b \\leftarrow m$。如果 $f'(m) = 0$，则返回 $m$。\n- 如果 $f'(a) \\ge 0$ 且 $f'(b) \\ge 0$，则函数在 $[a,b]$ 上是非递减的，在 $[a,b]$ 上的最小值在 $a$ 处取得；返回 $a$。\n- 如果 $f'(a) \\le 0$ 且 $f'(b) \\le 0$，则函数在 $[a,b]$ 上是非递增的，在 $[a,b]$ 上的最小值在 $b$ 处取得；返回 $b$。\n- 如果区间不满足上述单峰最小值的任何前提条件（例如，$f'(a) > 0$ 且 $f'(b)  0$），则返回一个特殊值，表示前提条件不满足。\n\n终止要求：\n- 使用一个容差 $\\varepsilon > 0$，并执行足够次数的迭代 $N$，以确保最终的区间长度最多为 $\\varepsilon$。二分法更新每次迭代都会将区间长度减半。\n\n收敛性分析目标：\n- 从基本原理出发，解释为什么在所述的单峰性和连续性假设下，修改后的二分法在区间长度上是线性收敛的，并能得到一个与 $x^\\star$ 相差在 $\\varepsilon$ 以内的近似值。\n\n测试套件：\n实现您的程序以运行以下测试用例。对于每个用例，返回一个表示近似最小值点的浮点数：\n- 用例 $1$ (正常路径)：$f(x) = (x - 2)^2 + 5$, $f'(x) = 2(x - 2)$, $[a,b] = [0,5]$, $\\varepsilon = 10^{-8}$。\n- 用例 $2$ (导数不平凡的正常路径)：$f(x) = e^{x} + (x - 3)^2$, $f'(x) = e^{x} + 2(x - 3)$, $[a,b] = [-5,5]$, $\\varepsilon = 10^{-8}$。不涉及角度；无需角度单位。\n- 用例 $3$ (由于端点导数为零导致的边界最小值)：$f(x) = x^2$, $f'(x) = 2x$, $[a,b] = [0,3]$, $\\varepsilon = 10^{-12}$。\n- 用例 $4$ (在区间上单调递增)：$f(x) = e^{x}$, $f'(x) = e^{x}$, $[a,b] = [-3,1]$, $\\varepsilon = 10^{-8}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与上面列出的用例一致（例如，$[x_1,x_2,x_3,x_4]$）。如果发生前提条件不满足的情况，则为该用例输出浮点值 $\\mathrm{nan}$。不涉及物理单位或角度单位；输出纯实数。", "solution": "### 基于原理的解决方案\n\n核心任务是找到一个可微、单峰函数 $f(x)$ 的唯一最小值点 $x^\\star$。这类函数的一个关键性质是其导数 $f'(x)$ 在最小值点处为零，即 $f'(x^\\star)=0$。此外，所提供的单峰性定义意味着对于 $x  x^\\star$ 有 $f'(x)  0$，对于 $x > x^\\star$ 有 $f'(x) > 0$。这意味着 $f'(x)$ 是一个严格递增的函数，它在 $x=x^\\star$ 处且仅在此处穿过x轴。\n\n这将 $f(x)$ 的最小化问题转化为 $f'(x)$ 的求根问题。二分法是此任务的理想选择，因为它仅依赖于所求根函数的符号，而这正是 $f'(x)$ 所提供的信息。\n\n所提出的算法首先根据 $f'(x)$ 在搜索区间 $[a,b]$ 边界上的行为处理边界情况和前提条件。\n\n1.  **直接根检查**：如果 $f'(a)=0$ 或 $f'(b)=0$，那么根据定义，某个端点就是最小值点 $x^\\star$。算法正确地返回 $a$ 或 $b$。\n\n2.  **单调性检查**：\n    - 如果 $f'(a) \\ge 0$ 且 $f'(b) \\ge 0$：由于 $f'(x)$ 是一个非递减函数（这是 $f$ 单峰性的一个推论），这意味着对于所有 $x \\ge a$ 都有 $f'(x) \\ge 0$。因此，$f(x)$ 在区间 $[a,b]$ 上是非递减的。该区间上 $f(x)$ 的最小值因此在左端点 $x=a$ 处。\n    - 如果 $f'(a) \\le 0$ 且 $f'(b) \\le 0$：这意味着根 $x^\\star$ 必须位于 $b$ 或其右侧，即 $x^\\star \\ge b$。因此，对于所有 $x \\in [a,b]$ 都有 $f'(x) \\le 0$，意味着 $f(x)$ 在该区间上是非递增的。该区间上 $f(x)$ 的最小值在右端点 $x=b$ 处。\n\n3.  **前提条件违规**：如果 $f'(a) > 0$ 且 $f'(b)  0$，这将意味着非递减函数 $f'(x)$ 在 $a$ 处的值大于其在 $b$ 处的值，这对于 $a  b$ 是一个矛盾。因此，这种情况违反了函数 $f(x)$ 必须是单峰的假设。算法将返回一个特殊值，例如 $\\mathrm{NaN}$。\n\n4.  **迭代二分**：如果 $f'(a)  0$ 且 $f'(b) > 0$，那么根据介值定理，在 $(a,b)$ 内保证存在一个根 $x^\\star$。这启动了核心的二分法循环：\n    - 计算中点 $m = (a+b)/2$。\n    - 如果 $f'(m)=0$，则已精确找到最小值点，返回 $m$。\n    - 如果 $f'(m)  0$，则 $m$ 位于根的左侧 ($m  x^\\star$)。这意味着符号变化（根）发生在区间 $[m, b]$ 中。因此，算法通过设置 $a \\leftarrow m$ 来更新左边界。\n    - 如果 $f'(m) > 0$，则 $m$ 位于根的右侧 ($m > x^\\star$)。符号变化发生在区间 $[a, m]$ 中。算法通过设置 $b \\leftarrow m$ 来更新右边界。\n\n**收敛性分析**\n\n该算法的收敛性直接继承自标准的二分法。在每次迭代中，包含 $f'(x)$ 的根的区间长度精确地减半。如果初始区间长度是 $L_0 = b-a$，那么经过 $N$ 次迭代后，区间长度将是 $L_N = \\frac{L_0}{2^N}$。这是一种**线性收敛**，收敛常数为 $\\frac{1}{2}$。\n\n算法在 $L_N \\le \\varepsilon$ 时终止。此时，我们得到的最终区间 $[a_N, b_N]$ 包含真最小值点 $x^\\star$。最终的近似值是该区间的中点 $x_{approx} = (a_N+b_N)/2$。这个近似值与真值 $x^\\star$ 之间的最大可能误差是区间长度的一半，即 $|x_{approx} - x^\\star| \\le \\frac{b_N-a_N}{2} \\le \\frac{\\varepsilon}{2}$。这保证了近似值在指定的容差范围内。\n\n该方法之所以有效，是因为 $f(x)$ 的单峰性保证了其导数 $f'(x)$ 是单调的，这正是应用二分法求根的完美条件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_minimum(fp, a, b, eps):\n    \"\"\"\n    Finds the minimizer of a unimodal function f by applying bisection to its derivative fp.\n\n    Args:\n        fp (callable): The derivative of the function f.\n        a (float): The left endpoint of the initial interval.\n        b (float): The right endpoint of the initial interval.\n        eps (float): The tolerance for the final interval length.\n\n    Returns:\n        float: The approximated minimizer x*, or np.nan if preconditions are violated.\n    \"\"\"\n    # Evaluate the derivative at the endpoints\n    fp_a = fp(a)\n    fp_b = fp(b)\n\n    # Case 1  2: Minimum is at an endpoint if the derivative is zero there.\n    if np.isclose(fp_a, 0):\n        return a\n    if np.isclose(fp_b, 0):\n        return b\n\n    # Case 6: Precondition violation (not unimodal with a minimum)\n    if fp_a > 0 and fp_b  0:\n        return np.nan\n\n    # Case 3: Function is non-decreasing on [a,b], min is at a.\n    if fp_a >= 0 and fp_b >= 0:\n        return a\n\n    # Case 4: Function is non-increasing on [a,b], min is at b.\n    if fp_a = 0 and fp_b = 0:\n        return b\n        \n    # Case 5: Root is bracketed, perform bisection.\n    # This is the only remaining case: fp_a  0 and fp_b > 0.\n    while (b - a) > eps:\n        m = a + (b - a) / 2.0\n        fp_m = fp(m)\n\n        if np.isclose(fp_m, 0):\n            return m\n        elif fp_m  0:\n            # The root is in the right half of the interval\n            a = m\n        else: # fp_m > 0\n            # The root is in the left half of the interval\n            b = m\n    \n    # Return the midpoint of the final interval\n    return a + (b - a) / 2.0\n\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'fp': lambda x: 2 * (x - 2), 'a': 0.0, 'b': 5.0, 'eps': 1e-8},\n        {'fp': lambda x: np.exp(x) + 2 * (x - 3), 'a': -5.0, 'b': 5.0, 'eps': 1e-8},\n        {'fp': lambda x: 2 * x, 'a': 0.0, 'b': 3.0, 'eps': 1e-12},\n        {'fp': lambda x: np.exp(x), 'a': -3.0, 'b': 1.0, 'eps': 1e-8},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_minimum(case['fp'], case['a'], case['b'], case['eps'])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3210918"}]}