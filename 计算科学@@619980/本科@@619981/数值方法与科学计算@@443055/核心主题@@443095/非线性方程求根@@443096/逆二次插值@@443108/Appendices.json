{"hands_on_practices": [{"introduction": "在将算法自动化之前，亲手动手计算是理解其核心机制的关键一步。本练习 [@problem_id:3244092] 旨在通过“纸和笔”的方式，让您从基本原理出发，对一个非平凡函数执行单步逆二次插值。通过手动计算，您将具体地掌握该方法如何利用三个初始点来生成一个更精确的根的估计值，从而为更复杂的编程实现打下坚实的基础。", "problem": "考虑函数 $f(x) = \\mathrm{sign}(x)\\sqrt{|x|}$ 的非线性求根问题，其唯一的实根位于 $x = 0$。反二次插值（IQI）通过构造一个唯一的二次多项式 $\\widehat{x}(y)$ 来生成新的迭代值，该多项式插值于数据点 $(y_i, x_i)$（其中 $y_i = f(x_i)$），然后将下一个迭代值设为 $x_{k+1} = \\widehat{x}(0)$。从初始横坐标 $x_0 = -1$，$x_1 = 2$ 和 $x_2 = 3$ 开始，执行以下操作：\n\n- 仅使用以下基本事实：存在一个唯一的二次多项式插值于三个不同的数据点，并且在指定纵坐标处对该插值多项式求值会得到插值模型下对应的横坐标。基于这一事实，从数据 $(y_0, x_0)$、$(y_1, x_1)$、$(y_2, x_2)$（其中 $y_i = f(x_i)$）构造 $\\widehat{x}(y)$，除了标准多项式插值原理外，不使用任何预先推导的快捷公式。\n- 计算 $\\widehat{x}(0)$ 以获得第一个 IQI 更新值 $x_3$。\n\n请以包含根式的精确封闭形式代数表达式给出您的最终答案；不要小数化或四舍五入。最终答案必须是关于 $x_3$ 的单个表达式。", "solution": "用户提供了一个在数值分析领域中定义明确的问题。\n\n### 步骤 1：提取已知条件\n- 函数：$f(x) = \\mathrm{sign}(x)\\sqrt{|x|}$\n- 求根问题：$f(x) = 0$\n- 方法：反二次插值（IQI）\n- 初始横坐标：$x_0 = -1$，$x_1 = 2$，$x_2 = 3$\n- IQI 更新值的定义：下一个迭代值 $x_{k+1}$ 是 $\\widehat{x}(0)$，其中 $\\widehat{x}(y)$ 是对点 $(y_i, x_i)$（$i=k-2, k-1, k$）进行插值的唯一二次多项式。\n- 任务：为初始点构造 $\\widehat{x}(y)$ 并计算 $\\widehat{x}(0)$ 以求得 $x_3$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在数值方法领域具有科学依据。函数 $f(x)$ 是良定义的。为使反二次插值良定义，三个纵坐标 $y_i = f(x_i)$ 必须是互不相同的。我们来计算它们：\n- $y_0 = f(x_0) = f(-1) = \\mathrm{sign}(-1)\\sqrt{|-1|} = (-1)\\sqrt{1} = -1$\n- $y_1 = f(x_1) = f(2) = \\mathrm{sign}(2)\\sqrt{|2|} = (1)\\sqrt{2} = \\sqrt{2}$\n- $y_2 = f(x_2) = f(3) = \\mathrm{sign}(3)\\sqrt{|3|} = (1)\\sqrt{3} = \\sqrt{3}$\n纵坐标 $y_0 = -1$，$y_1 = \\sqrt{2}$ 和 $y_2 = \\sqrt{3}$ 是互不相同的。因此，存在一个唯一的二次多项式 $\\widehat{x}(y)$ 插值于点 $(y_0, x_0)$、$(y_1, x_1)$ 和 $(y_2, x_2)$。该问题是自洽的、一致的且适定的。\n\n### 步骤 3：结论与行动\n问题有效。将提供解答。\n\n### 解答\n目标是使用反二次插值（IQI）方法，从初始值 $x_0 = -1$，$x_1 = 2$ 和 $x_2 = 3$ 开始，求解函数 $f(x) = \\mathrm{sign}(x)\\sqrt{|x|}$ 的根的下一个迭代值 $x_3$。\n\nIQI 方法用一个二次多项式来模拟反函数 $x = f^{-1}(y)$。我们已知函数 $f(x)$ 图像上的三个点：$(x_0, y_0)$、$(x_1, y_1)$、$(x_2, y_2)$。对于反函数，这些点对应于 $(y_0, x_0)$、$(y_1, x_1)$ 和 $(y_2, x_2)$。用于反插值的数据点是：\n- 点 $0$：$(y_0, x_0) = (-1, -1)$\n- 点 $1$：$(y_1, x_1) = (\\sqrt{2}, 2)$\n- 点 $2$：$(y_2, x_2) = (\\sqrt{3}, 3)$\n\n问题要求从基本原理出发构造插值多项式 $\\widehat{x}(y)$。我们将使用拉格朗日形式的插值多项式，它将通过这三个点的唯一二次多项式表示为：\n$$ \\widehat{x}(y) = x_0 L_0(y) + x_1 L_1(y) + x_2 L_2(y) $$\n其中 $L_0(y)$，$L_1(y)$ 和 $L_2(y)$ 是拉格朗日基多项式：\n$$ L_0(y) = \\frac{(y - y_1)(y - y_2)}{(y_0 - y_1)(y_0 - y_2)}, \\quad L_1(y) = \\frac{(y - y_0)(y - y_2)}{(y_1 - y_0)(y_1 - y_2)}, \\quad L_2(y) = \\frac{(y - y_0)(y - y_1)}{(y_2 - y_0)(y_2 - y_1)} $$\n下一个 IQI 迭代值 $x_3$ 是根的新近似值，通过在 $y=0$ 处对反插值多项式求值得到（因为根 $x$ 满足 $f(x)=0$，这意味着 $x = f^{-1}(0)$）。\n$$ x_3 = \\widehat{x}(0) = x_0 L_0(0) + x_1 L_1(0) + x_2 L_2(0) $$\n我们在 $y=0$ 处对基多项式求值：\n$$ L_0(0) = \\frac{y_1 y_2}{(y_0 - y_1)(y_0 - y_2)} $$\n$$ L_1(0) = \\frac{y_0 y_2}{(y_1 - y_0)(y_1 - y_2)} $$\n$$ L_2(0) = \\frac{y_0 y_1}{(y_2 - y_0)(y_2 - y_1)} $$\n将这些代入 $x_3$ 的表达式，得到 IQI 更新的一般公式：\n$$ x_3 = x_0 \\frac{y_1 y_2}{(y_0 - y_1)(y_0 - y_2)} + x_1 \\frac{y_0 y_2}{(y_1 - y_0)(y_1 - y_2)} + x_2 \\frac{y_0 y_1}{(y_2 - y_0)(y_2 - y_1)} $$\n现在，我们代入指定的值：$x_0 = -1$，$x_1 = 2$，$x_2 = 3$ 以及 $y_0 = -1$，$y_1 = \\sqrt{2}$，$y_2 = \\sqrt{3}$。\n$$ x_3 = (-1) \\frac{(\\sqrt{2})(\\sqrt{3})}{(-1 - \\sqrt{2})(-1 - \\sqrt{3})} + (2) \\frac{(-1)(\\sqrt{3})}{(\\sqrt{2} - (-1))(\\sqrt{2} - \\sqrt{3})} + (3) \\frac{(-1)(\\sqrt{2})}{(\\sqrt{3} - (-1))(\\sqrt{3} - \\sqrt{2})} $$\n$$ x_3 = - \\frac{\\sqrt{6}}{(1 + \\sqrt{2})(1 + \\sqrt{3})} - \\frac{2\\sqrt{3}}{(1 + \\sqrt{2})(\\sqrt{2} - \\sqrt{3})} - \\frac{3\\sqrt{2}}{(1 + \\sqrt{3})(\\sqrt{3} - \\sqrt{2})} $$\n为了简化，我们注意到 $\\sqrt{3}-\\sqrt{2} = -(\\sqrt{2}-\\sqrt{3})$。\n$$ x_3 = - \\frac{\\sqrt{6}}{(1 + \\sqrt{2})(1 + \\sqrt{3})} - \\frac{2\\sqrt{3}}{(1 + \\sqrt{2})(\\sqrt{2} - \\sqrt{3})} + \\frac{3\\sqrt{2}}{(1 + \\sqrt{3})(\\sqrt{2} - \\sqrt{3})} $$\n我们将各项通分，公分母为 $D = (1 + \\sqrt{2})(1 + \\sqrt{3})(\\sqrt{2} - \\sqrt{3})$：\n$$ D = (1+\\sqrt{2}) \\left( \\sqrt{2}-\\sqrt{3}+\\sqrt{6}-3 \\right) = \\sqrt{2}-\\sqrt{3}+\\sqrt{6}-3 + 2-\\sqrt{6}+\\sqrt{12}-3\\sqrt{2} = \\sqrt{3} - 2\\sqrt{2} - 1 $$\n分子 $N$ 为：\n$$ N = -\\sqrt{6}(\\sqrt{2} - \\sqrt{3}) - 2\\sqrt{3}(1+\\sqrt{3}) + 3\\sqrt{2}(1+\\sqrt{2}) $$\n$$ N = (-\\sqrt{12} + \\sqrt{18}) - (2\\sqrt{3} + 6) + (3\\sqrt{2} + 6) $$\n$$ N = -2\\sqrt{3} + 3\\sqrt{2} - 2\\sqrt{3} - 6 + 3\\sqrt{2} + 6 = 6\\sqrt{2} - 4\\sqrt{3} $$\n因此，我们有：\n$$ x_3 = \\frac{N}{D} = \\frac{6\\sqrt{2} - 4\\sqrt{3}}{\\sqrt{3} - 2\\sqrt{2} - 1} $$\n为了使分母有理化，我们将其分组为 $(\\sqrt{3}-1) - 2\\sqrt{2}$，并用其共轭式 $(\\sqrt{3}-1) + 2\\sqrt{2}$ 乘以分子和分母：\n$$ D_{\\text{rationalized}} = ((\\sqrt{3}-1) - 2\\sqrt{2})((\\sqrt{3}-1) + 2\\sqrt{2}) = (\\sqrt{3}-1)^2 - (2\\sqrt{2})^2 = (3 - 2\\sqrt{3} + 1) - 8 = -4 - 2\\sqrt{3} = -2(2+\\sqrt{3}) $$\n$$ N_{\\text{rationalized}} = (6\\sqrt{2} - 4\\sqrt{3})((\\sqrt{3}-1) + 2\\sqrt{2}) = (6\\sqrt{6} - 6\\sqrt{2} - 12 + 4\\sqrt{3}) + (24 - 8\\sqrt{6}) = 12 - 6\\sqrt{2} + 4\\sqrt{3} - 2\\sqrt{6} $$\n所以，\n$$ x_3 = \\frac{12 - 6\\sqrt{2} + 4\\sqrt{3} - 2\\sqrt{6}}{-2(2+\\sqrt{3})} = -\\frac{6 - 3\\sqrt{2} + 2\\sqrt{3} - \\sqrt{6}}{2+\\sqrt{3}} $$\n最后，我们通过将分子和分母乘以 $(2 - \\sqrt{3})$ 来对剩余的分母进行有理化：\n$$ \\text{Denominator} = (2+\\sqrt{3})(2-\\sqrt{3}) = 4-3 = 1 $$\n$$ \\text{Numerator} = -(6 - 3\\sqrt{2} + 2\\sqrt{3} - \\sqrt{6})(2 - \\sqrt{3}) $$\n$$ = -[ (12 - 6\\sqrt{3}) - (6\\sqrt{2} - 3\\sqrt{6}) + (4\\sqrt{3} - 6) - (2\\sqrt{6} - \\sqrt{18}) ] $$\n$$ = -[ 12 - 6\\sqrt{3} - 6\\sqrt{2} + 3\\sqrt{6} + 4\\sqrt{3} - 6 - 2\\sqrt{6} + 3\\sqrt{2} ] $$\n合并括号内的项：\n$$ (12-6) + (-6\\sqrt{2}+3\\sqrt{2}) + (-6\\sqrt{3}+4\\sqrt{3}) + (3\\sqrt{6}-2\\sqrt{6}) = 6 - 3\\sqrt{2} - 2\\sqrt{3} + \\sqrt{6} $$\n$x_3$ 的最终表达式是这个量的相反数：\n$$ x_3 = -(6 - 3\\sqrt{2} - 2\\sqrt{3} + \\sqrt{6}) = -6 + 3\\sqrt{2} + 2\\sqrt{3} - \\sqrt{6} $$\n这就是通过反二次插值得到的第一个迭代值 $x_3$。", "answer": "$$ \\boxed{-6 + 3\\sqrt{2} + 2\\sqrt{3} - \\sqrt{6}} $$", "id": "3244092"}, {"introduction": "掌握了单步计算的原理后，下一步自然是将其扩展为一个完整的迭代算法。本练习 [@problem_id:3243989] 将引导您从单个计算步骤过渡到一个功能完备的求解器。您需要编写一个包含稳健性回退策略的逆二次插值程序，并将其与另一种常见的无导数方法（定点迭代）进行性能比较。这项实践将帮助您把理论转化为可靠的代码，并学会通过实证分析来评估算法性能，这是计算科学中的一项核心技能。", "problem": "考虑标量非线性方程 $f(x)=0$，其中 $f(x)=x-\\exp(-x)$。该方程有唯一的实数解，因为 $f(x)$ 在 $\\mathbb{R}$ 上是连续且严格递增的，且有 $\\lim_{x\\to-\\infty}f(x)=-\\infty$ 和 $\\lim_{x\\to+\\infty}f(x)=+\\infty$。目标是为此方程构建并比较两种无导数求解器：逆二次插值法和不动点迭代法。\n\n您必须从插值和不动点迭代的核心定义出发，从第一性原理推导并实现以下两种迭代方法：\n\n1. 逆二次插值法 (IQI)：给定三个不同的迭代点 $x_0$、$x_1$ 和 $x_2$ 及其对应的函数值 $f(x_0)$、$f(x_1)$ 和 $f(x_2)$，构建一个关于变量 $y$ 的唯一二次多项式来插值其反函数关系，即一个多项式 $Q(y)$ 满足 $Q(f(x_i))=x_i$，其中 $i\\in\\{0,1,2\\}$。通过在 $y=0$ 处求值，使用此插值多项式生成下一个迭代点，即 $x_{\\text{new}}=Q(0)$。为了避免在构造是病态（例如，任意一对 $f(x_i)$ 的值几乎相等，导致插值公式中的分母变得极小）时出现数值不稳定性，您的实现必须检测到此类情况，并回退到使用最近的两个迭代点计算的割线更新，前提是它们的函数值差异足够大。如果由于函数值几乎相等而导致连割线更新都无法进行，则在该步骤中必须保持当前迭代点不变。\n\n2. 不动点迭代法：将方程重写为不动点形式 $x=g(x)$，其中 $g(x)=\\exp(-x)$。从一个初始猜测值 $x_0$ 开始，迭代 $x_{k+1}=g(x_k)$ 直至收敛。这是一种无导数方法，仅使用 $g(x)$ 的函数求值。\n\n对于这两种方法，使用相同的收敛逻辑。定义绝对函数容差 $\\varepsilon_f=10^{-12}$ 和步长容差 $\\varepsilon_x=10^{-12}$。如果迭代点 $x_k$ 满足 $|f(x_k)|\\le \\varepsilon_f$ 或 $|x_k-x_{k-1}|\\le \\varepsilon_x$（对于 $k\\ge 1$）中的任意一个条件，则认为其已收敛。设置最大迭代次数为 $N_{\\max}=1000$。计算直到首次满足停止准则时实际执行的迭代次数；如果达到最大迭代次数仍未满足准则，则报告最后的迭代点和迭代次数 $N_{\\max}$。\n\n您的程序必须实现这两种求解器，并将其应用于下面的测试套件。对于每个测试用例，使用指定的三个初始点 $(x_0,x_1,x_2)$ 运行 IQI，并使用指定的初始点 $x_0$ 运行不动点迭代。对于每种方法和每个测试用例，返回最终的近似根和所用的迭代次数。\n\n测试套件：\n- 用例 1：IQI 使用 $(x_0,x_1,x_2)=(0.0,1.0,0.5)$，不动点迭代法使用 $x_0=0.0$。\n- 用例 2：IQI 使用 $(x_0,x_1,x_2)=(0.55,0.57,0.60)$，不动点迭代法使用 $x_0=0.55$。\n- 用例 3：IQI 使用 $(x_0,x_1,x_2)=(-2.0,2.0,3.0)$，不动点迭代法使用 $x_0=3.0$。\n- 用例 4：IQI 使用 $(x_0,x_1,x_2)=(0.56,0.565,0.57)$，不动点迭代法使用 $x_0=0.56$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个用例，按以下严格顺序附加四个项目：\n- IQI 的最终根近似值，四舍五入到 $12$ 位小数。\n- IQI 的迭代次数，为整数。\n- 不动点迭代的最终根近似值，四舍五入到 $12$ 位小数。\n- 不动点迭代的迭代次数，为整数。\n\n因此，最终输出是包含 $16$ 个条目的单个列表，按用例 1 到 4 的顺序排列，每个用例贡献其四个条目，例如 $[x^{\\text{IQI}}_1,n^{\\text{IQI}}_1,x^{\\text{FP}}_1,n^{\\text{FP}}_1,\\dots,x^{\\text{IQI}}_4,n^{\\text{IQI}}_4,x^{\\text{FP}}_4,n^{\\text{FP}}_4]$。\n\n此问题不涉及物理单位或角度单位；所有量均为实数标量。数值容差 $\\varepsilon_f$ 和 $\\varepsilon_x$ 分别是 $f(x)$ 和步长的绝对容差。程序必须是自包含的，且不得需要任何用户输入或外部文件。", "solution": "该问题要求推导、实现和比较两种无导数数值方法——逆二次插值法 (IQI) 和不动点迭代法——用于求解非线性方程 $f(x) = x - \\exp(-x) = 0$ 的唯一实根。\n\n### **函数与根的分析**\n函数为 $f(x) = x - e^{-x}$。它对所有 $x \\in \\mathbb{R}$ 都是连续且可微的函数。其导数为 $f'(x) = 1 + e^{-x}$。由于对所有实数 $x$，$e^{-x} > 0$，我们有 $f'(x) > 1$，这意味着 $f(x)$ 是严格单调递增的。此外，$\\lim_{x\\to-\\infty} f(x) = -\\infty$ 且 $\\lim_{x\\to\\infty} f(x) = +\\infty$。根据介值定理，必然存在一个唯一的实根 $\\alpha$ 使得 $f(\\alpha)=0$。这个根是 $\\alpha = e^{-\\alpha}$ 的解，由 Lambert W 函数给出，$\\alpha = W(1) \\approx 0.56714329041$。\n\n### **方法 1：逆二次插值法 (IQI)**\n\n#### **从第一性原理推导**\n逆二次插值法是一种求根算法，它使用前三个迭代点来构建*反*函数的二次模型，然后利用该模型来估计根。设三个不同的点为 $(x_0, y_0)$、$(x_1, y_1)$ 和 $(x_2, y_2)$，其中 $y_i = f(x_i)$。我们寻求一个二次多项式 $Q(y)$ 使得 $Q(y_i) = x_i$，其中 $i \\in \\{0, 1, 2\\}$。这是一个标准的插值问题。唯一的二次插值多项式可以用拉格朗日基多项式表示：\n$$\nQ(y) = x_0 \\frac{(y-y_1)(y-y_2)}{(y_0-y_1)(y_0-y_2)} + x_1 \\frac{(y-y_0)(y-y_2)}{(y_1-y_0)(y_1-y_2)} + x_2 \\frac{(y-y_0)(y-y_1)}{(y_2-y_0)(y_2-y_1)}\n$$\n原始函数 $f(x)$ 的根对应于其反函数 $x=f^{-1}(y)$ 在 $y=0$ 处的值。我们通过在 $y=0$ 处计算我们的插值多项式 $Q(y)$ 来近似这个值。这给出了下一个迭代点 $x_{\\text{new}}$：\n$$\nx_{\\text{new}} = Q(0) = x_0 \\frac{(-y_1)(-y_2)}{(y_0-y_1)(y_0-y_2)} + x_1 \\frac{(-y_0)(-y_2)}{(y_1-y_0)(y_1-y_2)} + x_2 \\frac{(-y_0)(-y_1)}{(y_2-y_0)(y_2-y_1)}\n$$\n简化此表达式可得到 IQI 的更新公式：\n$$\nx_{\\text{new}} = x_0 \\frac{y_1 y_2}{(y_0-y_1)(y_0-y_2)} + x_1 \\frac{y_0 y_2}{(y_1-y_0)(y_1-y_2)} + x_2 \\frac{y_0 y_1}{(y_2-y_0)(y_2-y_1)}\n$$\n该公式要求函数值 $y_0, y_1, y_2$ 是互不相同的，否则分母将为零。\n\n#### **算法设计与回退策略**\n迭代过程从三个初始点 $(x_a, x_b, x_c)$ 及其函数值 $(y_a, y_b, y_c)$ 开始。在每次迭代中，计算一个新的点 $x_{\\text{new}}$，并丢弃最旧的点。下一次迭代的点集变为 $(x_b, x_c, x_{\\text{new}})$。\n\n一个稳健的 IQI 实现的关键部分是处理方法病态的情况，这种情况发生在任意两个函数值 $(y_a, y_b, y_c)$ 几乎相等时。问题指定了一个回退策略：\n1.  **尝试 IQI：** 使用上述公式计算 $x_{\\text{new}}$。仅当函数值 $y_a$、$y_b$ 和 $y_c$ 有足够大的差异时才这样做。在数值上，我们检查对于所有 $i \\neq j$，是否有 $|y_i - y_j|$ 大于一个很小的容差。\n2.  **回退到割线法：** 如果 IQI 更新不稳定（即函数值不互异），算法将回退到使用最近的两个点 $(x_b, y_b)$ 和 $(x_c, y_c)$ 的割线法。下一个迭代点的割线法公式是：\n    $$\n    x_{\\text{new}} = x_c - y_c \\frac{x_c - x_b}{y_c - y_b}\n    $$\n    仅当 $y_c$ 和 $y_b$ 有足够大的差异时才执行此操作。\n3.  **二次回退（保留迭代点）：** 如果 IQI 和割线法都不稳定（因为 $y_b \\approx y_c$），算法不计算新点，而是简单地将最近的迭代点继承下来：$x_{\\text{new}} = x_c$。这可以防止除以一个接近零的数并保持稳定性。\n\n### **方法 2：不动点迭代法**\n\n#### **从第一性原理推导**\n不动点迭代法是一种通过将方程 $f(x)=0$ 重新排列成 $x=g(x)$ 的形式来求根的方法。该方程的一个解是函数 $g$ 的一个“不动点”。给定一个初始猜测值 $x_0$，该方法使用递推关系 $x_{k+1} = g(x_k)$ 生成一个迭代点序列。\n\n对于给定的方程 $f(x) = x - e^{-x} = 0$，一个自然的重排是：\n$$\nx = e^{-x}\n$$\n这给出了迭代函数 $g(x) = e^{-x}$。因此，迭代格式为：\n$$\nx_{k+1} = g(x_k) = \\exp(-x_k)\n$$\n该方法的收敛性由压缩映射定理决定。如果在某个区间内对所有 $x$ 都有 $|g'(x)|  1$，则保证迭代收敛到该区间内的唯一不动点。对于我们的问题，$g'(x) = -e^{-x}$。根 $\\alpha \\approx 0.56714$ 位于区间 $[0, 1]$ 内。在此区间上，$|g'(x)| = e^{-x} \\le e^0 = 1$。在根处，$|g'(\\alpha)| = e^{-\\alpha} = \\alpha  1$。由于对所有 $x > 0$，我们有 $|g'(x)| = e^{-x}  1$，因此对于任何正的初始猜测值，都满足局部收敛的条件。例如，对于 $x_0 \\ge 0$，所有后续的迭代点都将保持非负，并且该方法将收敛到正根。\n\n#### **算法设计**\n该算法从一个初始值 $x_0$ 开始。然后迭代计算 $x_1 = g(x_0)$，$x_2=g(x_1)$，依此类推，直到满足停止准则。\n\n### **收敛与终止**\n两种方法使用相同的终止准则。对于给定的容差 $\\varepsilon_f = 10^{-12}$ 和 $\\varepsilon_x = 10^{-12}$，如果迭代点 $x_k$ 满足以下任一条件，则认为其为收敛解：\n1.  **函数值容差：** 残差接近于零：$|f(x_k)| \\leq \\varepsilon_f$。\n2.  **步长容差：** 连续迭代点之间的变化很小：$|x_k - x_{k-1}| \\leq \\varepsilon_x$ (对于 $k \\ge 1$)。\n\n如果在最多 $N_{\\max} = 1000$ 次迭代后仍未实现收敛，则过程终止，并返回最后计算的迭代点。迭代次数是生成的新点的计数。如果在计算任何新点之前初始猜测值就满足标准，则对应于 $0$ 次迭代。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares Inverse Quadratic Interpolation and Fixed-Point Iteration\n    for solving the nonlinear equation f(x) = x - exp(-x) = 0.\n    \"\"\"\n    \n    # Define the primary function f(x) and the fixed-point function g(x)\n    def f(x):\n        return x - np.exp(-x)\n\n    def g(x):\n        return np.exp(-x)\n\n    # Set common parameters for the solvers\n    EPS_F = 1e-12\n    EPS_X = 1e-12\n    N_MAX = 1000\n    DENOM_TOL = 1e-20 # A small tolerance for checking denominators\n\n    def iqi_solver(x0, x1, x2):\n        \"\"\"\n        Solves f(x) = 0 using Inverse Quadratic Interpolation with fallback.\n        \n        Args:\n            x0, x1, x2 (float): Three initial distinct guesses for the root.\n            \n        Returns:\n            tuple: (final root approximation, number of iterations).\n        \"\"\"\n        xa, xb, xc = x0, x1, x2\n\n        # Check initial points for convergence before starting iterations\n        # The prompt implies that n=0 if one of the initial points is the solution.\n        # Check the 'most recent' point x2 first.\n        if abs(f(xc)) = EPS_F or abs(xc - xb) = EPS_X:\n            return xc, 0\n\n        for n in range(1, N_MAX + 1):\n            ya, yb, yc = f(xa), f(xb), f(xc)\n\n            # Check for ill-conditioning: if any f-values are too close\n            if abs(ya - yb)  DENOM_TOL or abs(ya - yc)  DENOM_TOL or abs(yb - yc)  DENOM_TOL:\n                # IQI fails, fallback to secant method on the two most recent points\n                if abs(yc - yb)  DENOM_TOL:\n                    # Secant method also fails, retain the current iterate\n                    x_new = xc\n                else:\n                    x_new = xc - yc * (xc - xb) / (yc - yb)\n            else:\n                # IQI update formula derived from Lagrange interpolation Q(0)\n                term0 = xa * yb * yc / ((ya - yb) * (ya - yc))\n                term1 = xb * ya * yc / ((yb - ya) * (yb - yc))\n                term2 = xc * ya * yb / ((yc - ya) * (yc - yb))\n                x_new = term0 + term1 + term2\n\n            # Update points for the next iteration\n            xa, xb, xc = xb, xc, x_new\n\n            # Check for convergence on the newly computed point\n            if abs(f(xc)) = EPS_F or abs(xc - xb) = EPS_X:\n                return xc, n\n\n        return xc, N_MAX\n\n    def fp_solver(x0):\n        \"\"\"\n        Solves f(x) = 0 using Fixed-Point Iteration.\n        \n        Args:\n            x0 (float): Initial guess for the root.\n            \n        Returns:\n            tuple: (final root approximation, number of iterations).\n        \"\"\"\n        x_prev = x0\n        \n        # Check if the initial guess is already the solution\n        if abs(f(x_prev)) = EPS_F:\n            return x_prev, 0\n\n        for n in range(1, N_MAX + 1):\n            x_curr = g(x_prev)\n            \n            # Check for convergence\n            if abs(f(x_curr)) = EPS_F or abs(x_curr - x_prev) = EPS_X:\n                return x_curr, n\n            \n            x_prev = x_curr\n        \n        return x_curr, N_MAX\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # Case 1\n        {'iqi_initial': (0.0, 1.0, 0.5), 'fp_initial': 0.0},\n        # Case 2\n        {'iqi_initial': (0.55, 0.57, 0.60), 'fp_initial': 0.55},\n        # Case 3\n        {'iqi_initial': (-2.0, 2.0, 3.0), 'fp_initial': 3.0},\n        # Case 4\n        {'iqi_initial': (0.56, 0.565, 0.57), 'fp_initial': 0.56},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Run IQI solver\n        iqi_root, iqi_iters = iqi_solver(*case['iqi_initial'])\n        results.append(f\"{iqi_root:.12f}\")\n        results.append(str(iqi_iters))\n\n        # Run Fixed-Point solver\n        fp_root, fp_iters = fp_solver(case['fp_initial'])\n        results.append(f\"{fp_root:.12f}\")\n        results.append(str(fp_iters))\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3243989"}, {"introduction": "理论上等价的数学公式在有限精度的计算机上可能表现出截然不同的行为，这个问题在数值计算中至关重要。本练习 [@problem_id:3244093] 深入探讨了这一现象，通过一个精心设计的场景，您将见证标准逆二次插值公式如何因“灾难性抵消”而导致数值失败。与此同时，您将推导并实现一个代数上等价但经过重排的公式，并验证其如何显著提高数值稳定性，从而深刻理解算法设计中公式形式对计算精度的影响。", "problem": "考虑这样一个任务：使用三个先前计算出的点，通过单步反二次插值来近似一个标量函数的单根位置。反二次插值基于三个数据对 $(x_0,f_0)$, $(x_1,f_1)$, 和 $(x_2,f_2)$（其中 $f_i = f(x_i)$）为反函数 $x(f)$ 构造一个二次多项式，然后通过计算该多项式在 $f=0$ 处的值来估计根。该问题的基础是使用拉格朗日形式或牛顿形式表示的函数的多项式插值定义，以及拉格朗日基函数之和为一的事实。你必须从这些经过充分检验的事实和定义出发，自行推导出所需的计算公式。\n\n你的程序必须实现反二次插值步骤的两个版本，以从 $(x_0,f_0)$, $(x_1,f_1)$, $(x_2,f_2)$ 计算根的估计值 $\\hat{x}$：\n\n- 一种直接计算法，基于在 $f=0$ 处对 $x(f)$ 的二次插值多项式的标准构造，已知当函数值彼此非常接近时，该方法容易受到浮点抵消的影响。\n\n- 一种重排计算法，你需要从基本原理出发，利用 $x(f)$ 的拉格朗日基函数之和为一的性质推导得出，以减少在组合大的、几乎相反的项时发生的灾难性抵消。\n\n你必须通过一个科学合理的场景来证明，标准公式会因浮点抵消而导致数值计算失败，而重排后的公式则能提高数值稳定性。所有算术运算都应遵循电子电气工程师协会（Institute of Electrical and Electronics Engineers）的浮点标准（IEEE 754），以双精度进行。\n\n为以下测试套件实现这两个版本。在所有情况下，未知的精确根为 $r=0$，需要报告的误差是绝对误差 $|\\hat{x}-r|$，以浮点数形式表示：\n\n- 测试用例 1（小偏移量附近易于抵消的点簇）：设 $f(x)=x^3$。选择 $a=1\\times 10^{-8}$ 和 $h=1\\times 10^{-16}$。设 $x_0=a$，$x_1=a+h$，$x_2=a-h$，并定义 $f_i=f(x_i)$。此配置使得 $f_0$、$f_1$ 和 $f_2$ 极其接近，应当会在直接计算中引发浮点抵消。\n\n- 测试用例 2（良态线性映射）：设 $f(x)=x$。设 $x_0=-1$，$x_1=0.3$，$x_2=2$，并定义 $f_i=f(x_i)$。此配置应表现良好，并能产生精确的估计值，不会出现抵消问题。\n\n- 测试用例 3（一个点靠近根）：设 $f(x)=x^3$。设 $x_0=-1\\times 10^{-6}$，$x_1=1\\times 10^{-6}$，$x_2=1\\times 10^{-12}$，并定义 $f_i=f(x_i)$。此配置将一个函数值置于非常接近零的位置。\n\n对于每个测试用例，计算：\n- 直接计算的绝对误差，$E_{\\text{direct}}=|\\hat{x}_{\\text{direct}}-r|$。\n- 重排计算的绝对误差，$E_{\\text{rearr}}=|\\hat{x}_{\\text{rearr}}-r|$。\n\n你的程序应生成单行输出，其中包含三个测试用例的六个浮点数结果，按顺序以逗号分隔列表的形式放在方括号内：\n$[E_{\\text{direct},1},E_{\\text{rearr},1},E_{\\text{direct},2},E_{\\text{rearr},2},E_{\\text{direct},3},E_{\\text{rearr},3}]$。", "solution": "该问题要求实现并比较用于单步反二次插值的两个公式。目标是给定三个点 $(x_0, f_0), (x_1, f_1), (x_2, f_2)$（其中 $f_i = f(x_i)$），找到函数 $f(x)$ 的一个根的估计值 $\\hat{x}$。根的估计值是通过构造一个经过这三个点 $(f_i, x_i)$ 的二次多项式 $x(f)$，并计算其在 $f=0$ 处的值来找到的。\n\n分析将分两步进行：\n1.  推导所需的两个公式：“直接”公式和“重排”公式。\n2.  在提供的测试用例上实现和评估这些公式。\n\n### 插值公式的推导\n\n设给定的三个数据点为 $(f_0, x_0)$、$(f_1, x_1)$ 和 $(f_2, x_2)$。我们寻求经过这些点的唯一二次多项式 $x(f)$ 在 $f=0$ 处的值 $x(0)$。\n\n#### 1. 直接计算公式\n\n插值多项式的标准构造是拉格朗日形式。多项式 $x(f)$ 由下式给出：\n$$\nx(f) = x_0 L_0(f) + x_1 L_1(f) + x_2 L_2(f)\n$$\n其中 $L_i(f)$ 是拉格朗日基多项式：\n$$\nL_0(f) = \\frac{(f - f_1)(f - f_2)}{(f_0 - f_1)(f_0 - f_2)}, \\quad\nL_1(f) = \\frac{(f - f_0)(f - f_2)}{(f_1 - f_0)(f_1 - f_2)}, \\quad\nL_2(f) = \\frac{(f - f_0)(f - f_1)}{(f_2 - f_0)(f_2 - f_1)}\n$$\n根的估计值 $\\hat{x}$ 是通过计算 $x(f)$ 在 $f=0$ 处的值得到的：\n$$\n\\hat{x} = x(0) = x_0 L_0(0) + x_1 L_1(0) + x_2 L_2(0)\n$$\n将 $f=0$ 代入基多项式，得到：\n$$\nL_0(0) = \\frac{f_1 f_2}{(f_0 - f_1)(f_0 - f_2)}, \\quad\nL_1(0) = \\frac{f_0 f_2}{(f_1 - f_0)(f_1 - f_2)}, \\quad\nL_2(0) = \\frac{f_0 f_1}{(f_2 - f_0)(f_2 - f_1)}\n$$\n这导出了直接计算公式：\n$$\n\\hat{x}_{\\text{direct}} = x_0 \\frac{f_1 f_2}{(f_0 - f_1)(f_0 - f_2)} + x_1 \\frac{f_0 f_2}{(f_1 - f_0)(f_1 - f_2)} + x_2 \\frac{f_0 f_1}{(f_2 - f_0)(f_2 - f_1)}\n$$\n当函数值 $f_0, f_1, f_2$ 彼此接近但又不接近于零时，该公式在数值上是不稳定的。在这种情况下，分母 $(f_i - f_j)$ 会变得很小，导致各项的值变得很大。最终的估计值 $\\hat{x}$（本应接近于 $x_i$ 的值）是通过对这些大的、几乎相互抵消的项求和来计算的，这个过程被称为灾难性抵消，可能导致精度的严重损失。\n\n#### 2. 重排计算公式\n\n问题指出，可以利用拉格朗日基多项式之和为一的性质推导出一个更稳定的公式：\n$$\n\\sum_{i=0}^{2} L_i(f) = 1\n$$\n这个恒等式对任何 $f$ 值都成立，包括 $f=0$。我们可以用它来将估计值 $\\hat{x}$ 表示为对某个初始点（比如 $x_2$）的修正。我们写出：\n$$\n\\hat{x} = x_2 + (\\hat{x} - x_2)\n$$\n利用求和性质，我们可以写出 $x_2 = x_2 \\cdot 1 = x_2 \\sum_{i=0}^{2} L_i(0)$。将此式和 $\\hat{x}$ 的拉格朗日公式代入：\n$$\n\\hat{x} - x_2 = \\left( \\sum_{i=0}^{2} x_i L_i(0) \\right) - \\left( x_2 \\sum_{i=0}^{2} L_i(0) \\right)\n$$\n$$\n\\hat{x} - x_2 = \\sum_{i=0}^{2} (x_i - x_2) L_i(0) = (x_0 - x_2)L_0(0) + (x_1 - x_2)L_1(0) + (x_2 - x_2)L_2(0)\n$$\n当 $i=2$ 时，该项为零，从而留下修正项的公式：\n$$\n\\hat{x} - x_2 = (x_0 - x_2)L_0(0) + (x_1 - x_2)L_1(0)\n$$\n这给出了重排计算公式：\n$$\n\\hat{x}_{\\text{rearr}} = x_2 + (x_0 - x_2) \\frac{f_1 f_2}{(f_0 - f_1)(f_0 - f_2)} + (x_1 - x_2) \\frac{f_0 f_2}{(f_1 - f_0)(f_1 - f_2)}\n$$\n该表达式将估计值计算为一个基准值 $x_2$ 加上一个修正量。虽然在代数上它与直接公式等价，但其数值性质可能不同。在计算修正项时，仍然存在 $x_i$ 和 $f_i$ 的近似值相减的情况。然而，这种形式以不同的方式构造计算。在 $x_i$ 点簇集中的场景下，$(x_i - x_2)$ 项很小，公式通过将一个可能很小的修正量加到初始猜测 $x_2$ 上来计算最终结果。这可能比直接公式中对三个可能很大的、不相关的项求和要更稳健。\n\n### 实现与数值演示\n\n我们将实现两个公式 $\\hat{x}_{\\text{direct}}$ 和 $\\hat{x}_{\\text{rearr}}$，并用提供的测试套件进行测试。所有计算均采用标准的双精度浮点运算（IEEE 754）执行。对于所有测试用例，真实根为 $r=0$，因此绝对误差就是 $|\\hat{x}|$。\n\n测试用例如下：\n*   **测试用例 1（易发生抵消的点簇）：** $f(x)=x^3$，其中 $x_0=a$, $x_1=a+h$, $x_2=a-h$，参数为 $a=1\\times 10^{-8}$ 和 $h=1\\times 10^{-16}$。函数值 $f_i$ 极其接近，为灾难性抵消提供了条件。\n*   **测试用例 2（良态）：** $f(x)=x$，其中 $x_0=-1$, $x_1=0.3$, $x_2=2$。对于线性函数，插值是精确的，两个公式都应得出正确的根 $\\hat{x}=0$（在机器精度范围内）。\n*   **测试用例 3（一个点靠近根）：** $f(x)=x^3$，其中 $x_0=-1\\times 10^{-6}$, $x_1=1\\times 10^{-6}$, $x_2=1\\times 10^{-12}$。在这里，一个点 $(x_2, f_2)$ 极度接近根 $(0,0)$。构造为对 $x_2$ 进行修正的重排公式预计会表现得非常好。\n\n这些计算的结果将展示两种公式在数值稳定性上的差异。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef direct_evaluation(x0, x1, x2, f0, f1, f2):\n    \"\"\"\n    Computes the root estimate using the direct evaluation of the\n    Lagrange interpolation formula at f=0.\n    \"\"\"\n    # Check for non-distinct function values which would lead to division by zero.\n    if f0 == f1 or f0 == f2 or f1 == f2:\n        # This case is ill-defined for quadratic interpolation.\n        # In a real root-finder, one would fall back to a different method.\n        # For this problem's test cases, it indicates an issue if it occurs.\n        return np.nan\n\n    # Lagrange basis polynomials L_i(f) evaluated at f=0\n    term0 = x0 * f1 * f2 / ((f0 - f1) * (f0 - f2))\n    term1 = x1 * f0 * f2 / ((f1 - f0) * (f1 - f2))\n    term2 = x2 * f0 * f1 / ((f2 - f0) * (f2 - f1))\n    \n    return term0 + term1 + term2\n\ndef rearranged_evaluation(x0, x1, x2, f0, f1, f2):\n    \"\"\"\n    Computes the root estimate using the rearranged formula, derived\n    from the fact that the sum of Lagrange basis polynomials is 1.\n    \"\"\"\n    # Check for non-distinct function values.\n    if f0 == f1 or f0 == f2 or f1 == f2:\n        return np.nan\n\n    # Lagrange basis polynomials L_0(f) and L_1(f) evaluated at f=0\n    L0_at_0 = f1 * f2 / ((f0 - f1) * (f0 - f2))\n    L1_at_0 = f0 * f2 / ((f1 - f0) * (f1 - f2))\n    \n    # Correction term added to the base point x2\n    correction = (x0 - x2) * L0_at_0 + (x1 - x2) * L1_at_0\n    \n    return x2 + correction\n\ndef solve():\n    \"\"\"\n    Executes the inverse quadratic interpolation for the test suite\n    and prints the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1: Cancellation-prone cluster\n        {\n            \"f\": lambda x: x**3,\n            \"x_coords\": (1e-8, 1e-8 + 1e-16, 1e-8 - 1e-16),\n            \"root\": 0.0\n        },\n        # Test case 2: Well-conditioned linear mapping\n        {\n            \"f\": lambda x: x,\n            \"x_coords\": (-1.0, 0.3, 2.0),\n            \"root\": 0.0\n        },\n        # Test case 3: One point near the root\n        {\n            \"f\": lambda x: x**3,\n            \"x_coords\": (-1e-6, 1e-6, 1e-12),\n            \"root\": 0.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        func = case[\"f\"]\n        x0, x1, x2 = case[\"x_coords\"]\n        r = case[\"root\"]\n\n        # All computations use standard Python floats (IEEE 754 double precision)\n        f0 = func(x0)\n        f1 = func(x1)\n        f2 = func(x2)\n\n        # Calculate estimate using the direct formula\n        x_hat_direct = direct_evaluation(x0, x1, x2, f0, f1, f2)\n        error_direct = abs(x_hat_direct - r)\n        results.append(error_direct)\n\n        # Calculate estimate using the rearranged formula\n        x_hat_rearranged = rearranged_evaluation(x0, x1, x2, f0, f1, f2)\n        error_rearranged = abs(x_hat_rearranged - r)\n        results.append(error_rearranged)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3244093"}]}