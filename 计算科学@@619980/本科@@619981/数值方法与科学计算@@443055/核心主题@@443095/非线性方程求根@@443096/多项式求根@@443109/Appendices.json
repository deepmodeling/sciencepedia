{"hands_on_practices": [{"introduction": "许多求根算法的核心是迭代。我们将通过比较两种基本方法来开始我们的实践：可靠但收敛较慢的二分法，以及速度更快但收敛性不保证的割线法。这个练习将让您亲手计算，直观地感受这两种方法在初始迭代中的工作方式和性能差异[@problem_id:2199000]，从而理解不同数值策略之间的权衡。", "problem": "两种常见的求函数根的数值方法是二分法和割线法。考虑多项式函数 $p(x) = x^3 - 4x + 1$。我们感兴趣的是求该多项式的最大实根，已知该根位于区间 $[1, 2]$ 内。\n\n你的任务是比较两种方法前几次迭代的结果。\n\n首先，使用二分法，从区间 $[a_0, b_0] = [1, 2]$ 开始，进行两次迭代求根的近似值。将此近似值记为 $x_B$。\n\n其次，使用割线法，从初始猜测值 $x_0 = 1$ 和 $x_1 = 2$ 开始，进行两次迭代求根的近似值。将此近似值记为 $x_S$。\n\n计算这两个近似值之间的绝对差 $|x_B - x_S|$。报告你的最终答案，四舍五入到四位有效数字。", "solution": "给定多项式 $p(x)=x^{3}-4x+1$，且其最大实根位于区间 $[1,2]$ 内。首先，我们从 $[a_{0},b_{0}]=[1,2]$ 开始应用两次二分法迭代，然后从 $x_{0}=1$，$x_{1}=2$ 开始应用两次割线法迭代。最后，我们计算两个近似值之间的绝对差。\n\n二分法：\n- 计算端点处的值：$p(1)=1-4+1=-2  0$ 且 $p(2)=8-8+1=1>0$，因此在 $[1,2]$ 内有一个根。\n- 迭代 1：中点 $m_{1}=\\frac{1+2}{2}=\\frac{3}{2}$。那么\n$$\np\\!\\left(\\frac{3}{2}\\right)=\\left(\\frac{3}{2}\\right)^{3}-4\\cdot\\frac{3}{2}+1=\\frac{27}{8}-6+1=\\frac{27}{8}-\\frac{40}{8}=-\\frac{13}{8}  0.\n$$\n因为 $p(m_{1})  0$ 且 $p(2)>0$，所以新的区间是 $[a_{1},b_{1}]=\\left[\\frac{3}{2},2\\right]$。\n- 迭代 2：中点 $m_{2}=\\frac{\\frac{3}{2}+2}{2}=\\frac{7}{4}$。那么\n$$\np\\!\\left(\\frac{7}{4}\\right)=\\left(\\frac{7}{4}\\right)^{3}-4\\cdot\\frac{7}{4}+1=\\frac{343}{64}-7+1=\\frac{343}{64}-6=\\frac{343-384}{64}=-\\frac{41}{64}  0.\n$$\n同样 $p(m_{2})  0$ 且 $p(2)>0$，因此经过两次迭代后，二分法的近似值为\n$$\nx_{B}=m_{2}=\\frac{7}{4}.\n$$\n\n割线法：\n使用迭代公式 $x_{k+1}=x_{k}-p(x_{k})\\frac{x_{k}-x_{k-1}}{p(x_{k})-p(x_{k-1})}$。\n- 对于 $x_{0}=1$，$x_{1}=2$，我们有 $p(1)=-2$，$p(2)=1$。第一次迭代更新得到\n$$\nx_{2}=2-1\\cdot\\frac{2-1}{1-(-2)}=2-\\frac{1}{3}=\\frac{5}{3}.\n$$\n计算\n$$\np\\!\\left(\\frac{5}{3}\\right)=\\left(\\frac{5}{3}\\right)^{3}-4\\cdot\\frac{5}{3}+1=\\frac{125}{27}-\\frac{20}{3}+1=\\frac{125-180+27}{27}=-\\frac{28}{27}.\n$$\n- 第二次迭代更新使用 $x_{1}=2$，$x_{2}=\\frac{5}{3}$：\n$$\nx_{3}=\\frac{5}{3}-\\left(-\\frac{28}{27}\\right)\\frac{\\frac{5}{3}-2}{-\\frac{28}{27}-1}\n=\\frac{5}{3}-\\left(-\\frac{28}{27}\\right)\\frac{-\\frac{1}{3}}{-\\frac{55}{27}}\n=\\frac{5}{3}-\\frac{28}{81}\\cdot\\frac{27}{-55}\n=\\frac{5}{3}-\\left(-\\frac{28}{165}\\right)\n=\\frac{5}{3}+\\frac{28}{165}\n=\\frac{275}{165}+\\frac{28}{165}\n=\\frac{303}{165}\n=\\frac{101}{55}.\n$$\n因此，经过两次迭代后，割线法的近似值为\n$$\nx_{S}=\\frac{101}{55}.\n$$\n\n绝对差与四舍五入：\n计算\n$$\n|x_{B}-x_{S}|=\\left|\\frac{7}{4}-\\frac{101}{55}\\right|=\\left|\\frac{385-404}{220}\\right|=\\frac{19}{220}.\n$$\n换算成小数，$\\frac{19}{220}=0.0863636\\ldots$，四舍五入到四位有效数字为 $0.08636$。", "answer": "$$\\boxed{0.08636}$$", "id": "2199000"}, {"introduction": "牛顿法是求解非线性方程根的最著名和最常用的方法之一，通常以其二次收敛速度而著称。然而，其性能并非总是如此优越。本练习将引导您探索一个关键情况：当根是重根时会发生什么[@problem_id:2199030]？通过分析误差的递推关系，您将揭示牛顿法在这种情况下收敛速度从二次退化为线性的根本原因，这对于在实践中诊断收敛问题至关重要。", "problem": "考虑多项式函数 $p(x) = x^3 - 3x^2 + 4$。我们希望使用牛顿法求此多项式的根。其中一个根位于 $r=2$。牛顿法从一个初始猜测值 $x_0$ 开始，生成一个近似序列 $\\{x_n\\}$，其迭代公式定义为 $x_{n+1} = x_n - \\frac{p(x_n)}{p'(x_n)}$。\n\n设序列 $\\{x_n\\}$ 由牛顿法生成，其初始猜测值 $x_0$ 接近但不等于根 $r=2$。第 $n$ 次迭代的误差定义为 $\\epsilon_n = x_n - 2$。对于收敛的方法，误差在每一步都会减小。这种减小的特性由渐近误差比 $K$ 来刻画。\n\n求当牛顿法应用于给定多项式在根 $r=2$ 附近时，渐近误差比 $K = \\lim_{n \\to \\infty} \\frac{|\\epsilon_{n+1}|}{|\\epsilon_n|}$ 的精确值。", "solution": "我们已知 $p(x) = x^{3} - 3x^{2} + 4$ 以及牛顿迭代 $x_{n+1} = x_{n} - \\frac{p(x_{n})}{p'(x_{n})}$，且有一个根位于 $r=2$。首先，计算其导数：\n$$\np'(x) = 3x^{2} - 6x = 3x(x-2).\n$$\n对 $p(x)$ 进行因式分解，以确定根 $x=2$ 的重数：\n$$\np(x) = x^{3} - 3x^{2} + 4 = (x-2)^{2}(x+1),\n$$\n因此 $r=2$ 是一个二重根。定义误差 $\\epsilon_{n} = x_{n} - 2$，可得 $x_{n} = 2 + \\epsilon_{n}$。于是\n$$\np(x_{n}) = (x_{n}-2)^{2}(x_{n}+1) = \\epsilon_{n}^{2}(3 + \\epsilon_{n}),\n$$\n并且\n$$\np'(x_{n}) = 3x_{n}(x_{n}-2) = 3(2+\\epsilon_{n})\\epsilon_{n} = 6\\epsilon_{n} + 3\\epsilon_{n}^{2}.\n$$\n代入牛顿更新公式：\n$$\nx_{n+1} = x_{n} - \\frac{p(x_{n})}{p'(x_{n})}\n= 2 + \\epsilon_{n} - \\frac{\\epsilon_{n}^{2}(3+\\epsilon_{n})}{3(2+\\epsilon_{n})\\epsilon_{n}}\n= 2 + \\epsilon_{n} - \\frac{\\epsilon_{n}(3+\\epsilon_{n})}{3(2+\\epsilon_{n})}.\n$$\n因此下一次迭代的误差为\n$$\n\\epsilon_{n+1} = x_{n+1} - 2\n= \\epsilon_{n}\\left[1 - \\frac{3+\\epsilon_{n}}{3(2+\\epsilon_{n})}\\right]\n= \\epsilon_{n}\\,\\frac{3(2+\\epsilon_{n}) - (3+\\epsilon_{n})}{3(2+\\epsilon_{n})}\n= \\epsilon_{n}\\,\\frac{3 + 2\\epsilon_{n}}{3(2+\\epsilon_{n})}.\n$$\n由此可得渐近误差比为\n$$\nK = \\lim_{n\\to\\infty}\\frac{|\\epsilon_{n+1}|}{|\\epsilon_{n}|}\n= \\lim_{\\epsilon\\to 0}\\left|\\frac{3 + 2\\epsilon}{3(2+\\epsilon)}\\right|\n= \\frac{3}{3\\cdot 2}\n= \\frac{1}{2}.\n$$\n这与一般性结论相符：对于重数为 $m=2$ 的根，牛顿法以因子 $\\frac{m-1}{m} = \\frac{1}{2}$ 线性收敛。", "answer": "$$\\boxed{\\frac{1}{2}}$$", "id": "2199030"}, {"introduction": "前面的方法主要每次迭代逼近一个根。但是，我们能否一次性找到多项式的所有根（包括复数根）呢？本练习介绍了一种非常强大且通用的技术：伴随矩阵法[@problem_id:3268655]。该方法巧妙地将多项式求根问题转化为一个线性代数中的矩阵特征值问题，这也是许多专业科学计算库中求根函数的核心思想。通过编写代码实现该方法，您将深入理解如何构建稳健的数值工具来解决这一基本问题。", "problem": "您需要编写一个完整、可运行的程序，使用基于线性代数的数值方法计算复系数多项式的根。考虑一个次数为 $d \\ge 1$ 的多项式，\n$$\np(z) = c_d z^d + c_{d-1} z^{d-1} + \\cdots + c_1 z + c_0,\n$$\n其中每个系数 $c_k \\in \\mathbb{C}$ 且首项系数 $c_d \\ne 0$。根是任何满足 $p(z) = 0$ 的 $z \\in \\mathbb{C}$。您的程序必须为下面指定的测试套件中的每个多项式计算其所有 $d$ 个根。\n\n从数值线性代数的基本定义和经过检验的事实出发，但不要依赖本说明中提供的捷径公式。实现应当对复数值系数具有鲁棒性，并且必须设计为能够获得数值稳定的结果。\n\n排序、表示和输出要求：\n- 对每个多项式的根按模 $|z|$ 的升序排序，如果模相等，则按以弧度为单位的辐角 $\\arg(z)$ 的升序排序。\n- 将每个根表示为一对实数 $[\\mathrm{Re}(z), \\mathrm{Im}(z)]$，其中 $\\mathrm{Re}(z)$ 和 $\\mathrm{Im}(z)$ 分别是 $z$ 的实部和虚部，四舍五入到小数点后恰好 $10$ 位。\n- 按 $\\arg(z)$ 排序时，角度以弧度为单位。\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，且不含任何空格。每个测试用例的结果必须是该多项式根对的列表。具体来说，最终输出必须采用以下格式\n\"[[r_{11},r_{12},\\dots,r_{1d_1}],[r_{21},r_{22},\\dots,r_{2d_2}],\\dots]\"\n其中每个 $r_{jk}$ 本身都是 $[\\mathrm{Re},\\mathrm{Im}]$ 的形式，小数点后恰好有 $10$ 位数字。\n\n测试套件：\n- 案例 $1$（二次，复数首项系数）：\n  $$p_1(z) = (1+i) z^2 - 3 z + (4 - 2 i).$$\n- 案例 $2$（一次，复数首项系数）：\n  $$p_2(z) = (2 i) z + (1 - i).$$\n- 案例 $3$（三次，含复数重根）：\n  $$p_3(z) = (z - (2 - 3 i))^2 (z + 1),$$\n  其展开后的系数为\n  $$p_3(z) = z^3 + (-3 + 6 i) z^2 + (-9 - 6 i) z + (-5 - 12 i).$$\n- 案例 $4$（四次，乘以一个复数因子）：\n  $$p_4(z) = (1 + 2 i)\\big(z^4 - 3 z^2 - 4\\big),$$\n  其系数为\n  $$p_4(z) = (1 + 2 i) z^4 + 0 \\cdot z^3 + (-3 - 6 i) z^2 + 0 \\cdot z + (-4 - 8 i).$$\n- 案例 $5$（三次，含近似重根）：\n  $$p_5(z) = \\big(z - (1 + 10^{-3} i)\\big)\\big(z - (1 - 10^{-3} i)\\big)(z + 3 i),$$\n  其展开后的系数为\n  $$p_5(z) = z^3 + (-2 + 3 i) z^2 + (1.000001 - 6 i) z + 3.000003 i.$$\n\n最终输出格式：\n- 您的程序必须打印单行，其中包含所有测试用例的汇总结果，格式与上述完全一致，行内不含任何空格。\n- 每个测试用例的结果必须是一个包含 $d$ 个 $[\\mathrm{Re},\\mathrm{Im}]$ 对的列表，按 $|z|$ 升序排列，然后按 $\\arg(z)$（以弧度为单位）升序排列，每个数值部分四舍五入到小数点后恰好 $10$ 位。\n\n每个测试用例的答案将是列表内嵌浮点数列表的形式，以便于自动验证。此任务不涉及物理单位。如上文明确指定，角度以弧度为单位。", "solution": "该问题要求计算一组复系数多项式的所有根。该解决方案的指导原则是线性代数中的一个基本定理，它将多项式的根与一个特殊构造的矩阵（称为友矩阵）的特征值联系起来。这种方法将求根问题转化为特征值问题，后者可以使用成熟的数值算法进行稳健求解。\n\n设给定多项式的次数为 $d \\ge 1$：\n$$\np(z) = c_d z^d + c_{d-1} z^{d-1} + \\cdots + c_1 z + c_0\n$$\n其中系数 $c_k \\in \\mathbb{C}$（对于 $k \\in \\{0, 1, \\dots, d\\}$），且首项系数 $c_d \\neq 0$。$p(z)$ 的根是使得 $p(z)=0$ 的值 $z \\in \\mathbb{C}$。\n\n第一步是将 $p(z)$ 转换为其等价的首一多项式，即首项系数为 $1$ 的多项式。这可以通过将整个多项式除以 $c_d$ 来实现。多项式的根在此缩放操作下保持不变。\n$$\np_{mono}(z) = \\frac{p(z)}{c_d} = z^d + \\frac{c_{d-1}}{c_d} z^{d-1} + \\cdots + \\frac{c_1}{c_d} z + \\frac{c_0}{c_d}\n$$\n我们定义新系数 $a_k = c_k / c_d$（对于 $k \\in \\{0, 1, \\dots, d-1\\}$）。那么首一多项式为：\n$$\np_{mono}(z) = z^d + a_{d-1} z^{d-1} + \\cdots + a_1 z + a_0\n$$\n根 $z$ 必须满足方程 $p_{mono}(z) = 0$，可以重新排列为：\n$$\nz^d = -a_{d-1} z^{d-1} - a_{d-2} z^{d-2} - \\cdots - a_1 z - a_0\n$$\n这个方程为构造友矩阵提供了基础。考虑一个 $d \\times d$ 矩阵 $C(p)$，称为 $p_{mono}(z)$ 的弗罗贝尼乌斯友矩阵 (Frobenius companion matrix)，其定义如下：\n$$\nC(p) = \\begin{pmatrix}\n0  0  \\cdots  0  -a_0 \\\\\n1  0  \\cdots  0  -a_1 \\\\\n0  1  \\cdots  0  -a_2 \\\\\n\\vdots  \\vdots  \\ddots  \\vdots  \\vdots \\\\\n0  0  \\cdots  1  -a_{d-1}\n\\end{pmatrix}\n$$\n$C(p)$ 的特征值 $\\lambda$ 是特征方程 $\\det(C(p) - \\lambda I) = 0$ 的根，其中 $I$ 是 $d \\times d$ 的单位矩阵。通过展开 $(C(p) - \\lambda I)$ 的行列式，可以证明其特征多项式恰好是 $\\lambda^d + a_{d-1} \\lambda^{d-1} + \\cdots + a_0$，这与 $p_{mono}(z)$ 的形式完全相同。\n$$\n\\det(C(p) - \\lambda I) = \\det \\begin{pmatrix}\n-\\lambda  0  \\cdots  0  -a_0 \\\\\n1  -\\lambda  \\cdots  0  -a_1 \\\\\n0  1  \\cdots  0  -a_2 \\\\\n\\vdots  \\vdots  \\ddots  \\vdots  \\vdots \\\\\n0  0  \\cdots  1  -a_{d-1}-\\lambda\n\\end{pmatrix} = (-1)^d ( \\lambda^d + a_{d-1} \\lambda^{d-1} + \\cdots + a_0 )\n$$\n因此，特征方程 $\\det(C(p) - \\lambda I) = 0$ 的根与多项式 $p_{mono}(z)=0$ 的根相同。这就确定了友矩阵 $C(p)$ 的特征值就是原始多项式 $p(z)$ 的根。\n\n要实现的算法如下：\n$1$. 对于每个由复系数列表 $[c_d, c_{d-1}, \\dots, c_0]$ 表示的多项式，确定其次数 $d$。\n$2$. 构造 $d \\times d$ 的友矩阵 $C(p)$。这需要首先计算首一多项式的系数 $a_k = c_k / c_d$。$C(p)$ 的最后一列由取反的首一多项式系数填充，即 $[-a_0, -a_1, \\dots, -a_{d-1}]^\\intercal$。次对角线上的元素均为 $1$，所有其他元素均为 $0$。\n$3$. 利用一个标准的数值库（如 `numpy.linalg`）来计算所构造的友矩阵的特征值。函数 `numpy.linalg.eigvals` 非常适合此任务，并且是数值稳定的。\n$4$. 计算出的特征值就是多项式的 $d$ 个根。\n$5$. 根据指定标准对这些根进行排序：主要按模 $|z|$ 的升序排序，其次对于模相等的根，按辐角 $\\arg(z)$ 的升序排序。辐角应以弧度计算，通常在区间 $(-\\pi, \\pi]$ 内。\n$6$. 将每个复数根 $z$ 格式化为其虚实部对 $[\\mathrm{Re}(z), \\mathrm{Im}(z)]$。每个部分必须四舍五入到恰好 $10$ 位小数。\n$7$. 将所有测试用例的格式化结果汇总到一个具有指定嵌套列表结构的字符串中，确保不存在多余的空格。最终输出是一个表示列表的字符串，其中每个元素是给定多项式的格式化根列表。\n\n该过程提供了一种通用且稳健的方法，用于寻找具有复系数的多项式的所有根，其坚实基础是数值线性代数的原理。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the roots of complex-coefficient polynomials using the companion matrix method.\n    \"\"\"\n    # Define the test cases as lists of coefficients in descending order of power\n    # (c_d, c_{d-1}, ..., c_0) for p(z) = c_d*z^d + ... + c_0.\n    test_cases = [\n        # Case 1: (1+i)z^2 - 3z + (4-2i).\n        [(1 + 1j), -3 + 0j, (4 - 2j)],\n        # Case 2: (2i)z + (1-i).\n        [2j, (1 - 1j)],\n        # Case 3: z^3 + (-3+6i)z^2 + (-9-6i)z + (-5-12i).\n        [1 + 0j, (-3 + 6j), (-9 - 6j), (-5 - 12j)],\n        # Case 4: (1+2i)z^4 + 0z^3 + (-3-6i)z^2 + 0z + (-4-8i).\n        [(1 + 2j), 0 + 0j, (-3 - 6j), 0 + 0j, (-4 - 8j)],\n        # Case 5: z^3 + (-2+3i)z^2 + (1.000001-6i)z + 3.000003i.\n        [1 + 0j, (-2 + 3j), (1.000001 - 6j), 3.000003j]\n    ]\n\n    all_results_str = []\n    \n    for coeffs in test_cases:\n        coeffs = np.array(coeffs, dtype=complex)\n        degree = len(coeffs) - 1\n\n        if degree  1:\n            # The problem statement specifies degree d >= 1.\n            # This handles any deviation from that for robustness.\n            all_results_str.append(\"[]\")\n            continue\n\n        # Get the leading coefficient to normalize the polynomial.\n        leading_coeff = coeffs[0]\n        \n        # Coefficients of the monic polynomial p_mono(z) = z^d + a_{d-1}z^{d-1} + ... + a_0\n        # coeffs[1:] corresponds to [c_{d-1}, ..., c_0]\n        monic_coeffs_desc = coeffs[1:] / leading_coeff\n\n        # Construct the companion matrix.\n        # It's a d x d matrix.\n        companion_matrix = np.zeros((degree, degree), dtype=complex)\n        \n        # Set the subdiagonal to 1s.\n        if degree > 1:\n            companion_matrix[1:, :-1] = np.eye(degree - 1)\n        \n        # The last column is [-a_0, -a_1, ..., -a_{d-1}]^T.\n        # monic_coeffs_desc is [a_{d-1}, ..., a_0].\n        # Reversing it gives [a_0, ..., a_{d-1}].\n        companion_matrix[:, -1] = -monic_coeffs_desc[::-1]\n        \n        # The eigenvalues of the companion matrix are the roots of the polynomial.\n        roots = np.linalg.eigvals(companion_matrix)\n        \n        # Sort the roots: 1st by magnitude (abs), 2nd by argument (angle).\n        sorted_roots = sorted(roots, key=lambda z: (np.abs(z), np.angle(z)))\n        \n        # Format the roots as per the requirements.\n        formatted_roots = []\n        for r in sorted_roots:\n            re_part = f\"{r.real:.10f}\"\n            im_part = f\"{r.imag:.10f}\"\n            formatted_roots.append(f\"[{re_part},{im_part}]\")\n            \n        # Create the string for this test case's results, e.g., \"[[re1,im1],[re2,im2]]\"\n        case_result_str = f\"[{','.join(formatted_roots)}]\"\n        all_results_str.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    # The output is a string representing a list of lists of root pairs.\n    # e.g., \"[[[re,im],[re,im]],[[re,im]]]\"\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "3268655"}]}