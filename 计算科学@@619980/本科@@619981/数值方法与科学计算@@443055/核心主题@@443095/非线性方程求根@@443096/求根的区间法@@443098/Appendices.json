{"hands_on_practices": [{"introduction": "本练习将二分法置于一个实际的商业情境中：寻找公司的盈亏平衡点。通过将该分步算法应用于一个利润函数，你将亲身体验这种可靠的求根技术如何系统地缩小搜索区间。这个问题旨在巩固二分法的核心机制，这是数值分析中的一项基本技能。[@problem_id:2157541]", "problem": "一家小型制造公司希望确定其盈亏平衡的生产水平。生产和销售 $x$ 千单位某产品的利润 $P$ 由函数 $P(x) = -1.5x^2 + 140x - 1000$ 建模。该函数的一个根对应于利润为零的盈亏平衡点。公司分析师使用二分法来寻找这个盈亏平衡点。他们从初始区间 $[a_0, b_0] = [5, 10]$ 开始。在执行三次二分法迭代后，他们得到了一个新的、更小的包含根的区间 $[a_3, b_3]$。$a_3$ 和 $b_3$ 的值是多少？\n\n将你的答案表示为行矩阵 $\\begin{pmatrix} a_3  b_3 \\end{pmatrix}$。", "solution": "我们已知利润函数 $P(x) = -1.5x^{2} + 140x - 1000$，这是一个连续多项式。根据介值定理，如果 $P(a)$ 和 $P(b)$ 的符号相反，则在 $(a,b)$ 内存在一个根。二分法通过反复平分区间并选择符号变化持续存在的子区间来进行。我们从 $[a_{0},b_{0}] = [5,10]$ 开始。\n\n首先，计算端点处的符号：\n$$\nP(5) = -\\frac{3}{2}\\cdot 25 + 140\\cdot 5 - 1000 = -37.5 + 700 - 1000 = -337.5  0,\n$$\n$$\nP(10) = -\\frac{3}{2}\\cdot 100 + 140\\cdot 10 - 1000 = -150 + 1400 - 1000 = 250 > 0.\n$$\n因此，一个根位于 $[5,10]$ 内。\n\n第一次迭代：中点 $m_{1} = \\frac{a_{0}+b_{0}}{2} = \\frac{5+10}{2} = \\frac{15}{2}$。\n计算\n$$\nP\\!\\left(\\frac{15}{2}\\right) = -\\frac{3}{2}\\cdot \\frac{225}{4} + 140\\cdot \\frac{15}{2} - 1000 = -84.375 + 1050 - 1000 = -34.375  0.\n$$\n由于 $P(a_{0})0$ 且 $P(m_{1})0$，而 $P(b_{0})0$，符号变化发生在 $[m_{1},b_{0}]$ 内。因此 $[a_{1},b_{1}] = \\left[\\frac{15}{2}, 10\\right]$。\n\n第二次迭代：中点 $m_{2} = \\frac{a_{1}+b_{1}}{2} = \\frac{\\frac{15}{2}+10}{2} = \\frac{35}{4}$。\n计算\n$$\nP\\!\\left(\\frac{35}{4}\\right) = -\\frac{3}{2}\\cdot \\frac{1225}{16} + 140\\cdot \\frac{35}{4} - 1000 = -114.84375 + 1225 - 1000 = 110.15625 > 0.\n$$\n由于 $P(a_{1})0$ 且 $P(m_{2})0$，符号变化发生在 $[a_{1},m_{2}]$ 内。因此 $[a_{2},b_{2}] = \\left[\\frac{15}{2}, \\frac{35}{4}\\right]$。\n\n第三次迭代：中点 $m_{3} = \\frac{a_{2}+b_{2}}{2} = \\frac{\\frac{15}{2}+\\frac{35}{4}}{2} = \\frac{65}{8}$。\n计算\n$$\nP\\!\\left(\\frac{65}{8}\\right) = -\\frac{3}{2}\\cdot \\frac{4225}{64} + 140\\cdot \\frac{65}{8} - 1000 = -99.0234375 + 1137.5 - 1000 = 38.4765625 > 0.\n$$\n由于 $P(a_{2})0$ 且 $P(m_{3})0$，符号变化发生在 $[a_{2},m_{3}]$ 内。因此，经过三次迭代后，区间为\n$$\n[a_{3},b_{3}] = \\left[\\frac{15}{2}, \\frac{65}{8}\\right].\n$$", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{15}{2}  \\frac{65}{8} \\end{pmatrix}}$$", "id": "2157541"}, {"introduction": "掌握了二分法之后，我们很自然会问：是否存在更高效的替代方法？本练习将介绍试位法 (Regula Falsi)，并将其与二分法进行直接比较。通过计算两种方法对同一函数产生的首次近似值，你将直接观察到它们基本策略的差异，并深入了解它们的相对性能。[@problem_id:2157489]", "problem": "考虑在区间 $[1, 2]$ 内求函数 $f(x) = x^3 - 5$ 的一个根。\n\n完成此任务的两种常用迭代区间法是二分法和试位法（也称为伪位置法）。\n\n设 $c_B$ 是对初始区间 $[1, 2]$ 应用一次二分法迭代得到的根的第一个近似值。\n设 $c_{RF}$ 是对同一初始区间 $[1, 2]$ 应用一次试位法迭代得到的根的第一个近似值。\n\n该函数的真实根是 $x_{true} = \\sqrt[3]{5}$。为解决本题，您可以使用值 $x_{true} \\approx 1.709976$。\n\n计算这两种方法的近似误差之间的绝对差。即，计算 $| |c_B - x_{true}| - |c_{RF} - x_{true}| |$ 的值。将最终答案四舍五入到四位有效数字。", "solution": "给定函数 $f(x) = x^{3} - 5$ 在区间 $[1,2]$ 上，其中 $f(1) = -4$ 且 $f(2) = 3$，因此根位于 $[1,2]$ 内。\n\n对于一个二分法步骤，中点是\n$$\nc_{B} = \\frac{1 + 2}{2} = \\frac{3}{2}。\n$$\n\n对于从 $(a,f(a)) = (1,-4)$ 和 $(b,f(b)) = (2,3)$ 开始的一个试位法步骤，线性插值得到的根是\n$$\nc_{RF} = a - f(a)\\,\\frac{b - a}{f(b) - f(a)} = 1 - (-4)\\,\\frac{2 - 1}{3 - (-4)} = 1 + \\frac{4}{7} = \\frac{11}{7}。\n$$\n\n因为 $f$ 在 $[1,2]$ 上是严格递增的，且 $x_{true} \\in [1,2]$，我们有 $c_{B}  x_{true}$ 和 $c_{RF}  x_{true}$，因此\n$$\n|c_{B} - x_{true}| = x_{true} - \\frac{3}{2}, \\quad |c_{RF} - x_{true}| = x_{true} - \\frac{11}{7}。\n$$\n因此，误差的绝对差是\n$$\n\\left||c_{B} - x_{true}| - |c_{RF} - x_{true}|\\right| = \\left|(x_{true} - \\tfrac{3}{2}) - (x_{true} - \\tfrac{11}{7})\\right| = \\left|\\frac{11}{7} - \\frac{3}{2}\\right| = \\left|\\frac{22 - 21}{14}\\right| = \\frac{1}{14}。\n$$\n\n数值上，\n$$\n\\frac{1}{14} \\approx 0.071428571\\ldots,\n$$\n四舍五入到四位有效数字为 $0.07143$。", "answer": "$$\\boxed{0.07143}$$", "id": "2157489"}, {"introduction": "从手动计算到编程实现，是掌握数值方法的关键一步。这个高级练习将挑战你不仅实现经典的试位法，还要实现一个至关重要的改进——伊利诺伊算法。你将探索一个标准方法表现不佳的场景，并亲眼见证伊利诺伊算法如何有效解决“端点停滞”问题，从而得到一个更稳健、更高效的算法。[@problem_id:3211594]", "problem": "实现一个完整、可运行的程序，该程序从介值定理和线性插值出发，构建两种区间求根方法，并在一个精心挑选的测试集上比较它们的行为。这两种方法分别是经典试位法（也称为 regula falsi）和 Illinois 修正法。你的程序必须完成以下所有任务。\n\n首先，仅使用以下基础原理。\n- 介值定理：如果一个实值函数 $f$ 在闭区间 $[a,b]$ 上连续，且 $f(a)\\,f(b)\\le 0$，那么在 $[a,b]$ 中至少存在一个点 $x^\\star$ 使得 $f(x^\\star)=0$。\n- 线性插值：经过两点 $(x_0,y_0)$ 和 $(x_1,y_1)$ 的唯一仿射函数是一条与这两个值都匹配的直线。当其零点存在时，它为对应连续函数的一个根提供了近似值。\n\n其次，以纯粹的区间形式实现这两种算法。\n- 经典 regula falsi：在每次迭代中，给定一个满足 $f(a)\\,f(b)0$ 的区间 $[a,b]$，用穿过当前端点的割线的零点替换其中一个端点，以保持符号变化。当当前近似点处的函数绝对值不超过一个指定的阈值，或区间长度不超过一个指定的阈值，或已达到最大迭代次数时，终止迭代。\n- Illinois 修正法：使用与上述相同的区间和割线构造方法，但如果在连续两次迭代中替换了同一个端点，则在形成下一条割线之前，将对侧（未改变的）端点处的函数值乘以 $1/2$。此修正旨在避免经典 regula falsi 的“端点停滞”行为，即一个端点在许多步骤中保持固定，而另一个端点反复移动。\n\n第三，采用以下精确规范。\n- 每个测试用例的输入：一个连续函数 $f:\\mathbb{R}\\to\\mathbb{R}$，一个满足 $f(a)\\,f(b)0$ 的有效初始区间 $[a,b]$，一个区间长度绝对容差 $x_{\\text{tol}}0$，一个函数值绝对容差 $f_{\\text{tol}}0$，以及最大迭代次数 $N_{\\max}\\in\\mathbb{N}$。\n- 终止条件：对于任一种方法，在第 $k$ 次迭代得到近似值 $c_k$ 时，如果 $|f(c_k)|\\le f_{\\text{tol}}$ 或 $|b_k-a_k|\\le x_{\\text{tol}}$，则停止。如果在 $N_{\\max}$ 次迭代内两个条件都未满足，则返回最后的近似值和计数 $N_{\\max}$。\n- 每个测试用例的返回值：报告 Illinois 方法得到的根的近似值（四舍五入到 $12$ 位小数）、Illinois 方法所用的总迭代次数，以及在相同的停止准则和 $N_{\\max}$ 下经典 regula falsi 方法所用的总迭代次数。\n- 角度单位：当出现三角函数时，所有角度均以弧度为单位。\n\n第四，使用以下测试集。每个 $f_i$ 在所述区间上是连续的，并且满足区间条件。\n- 案例 1：$f_1(x)=\\cos(x)-x$ 在 $[0,1]$ 上，其中 $x_{\\text{tol}}=10^{-12}$，$f_{\\text{tol}}=10^{-12}$，$N_{\\max}=1000$。角度以弧度为单位。\n- 案例 2：$f_2(x)=x^2-2$ 在 $[0,2]$ 上，其中 $x_{\\text{tol}}=10^{-12}$，$f_{\\text{tol}}=10^{-12}$，$N_{\\max}=1000$。\n- 案例 3：$f_3(x)=e^{-x}-x$ 在 $[0,1]$ 上，其中 $x_{\\text{tol}}=10^{-12}$，$f_{\\text{tol}}=10^{-12}$，$N_{\\max}=1000$。该案例是平滑且单调的，用于测试在非多项式情况下的通用性能。\n- 案例 4：$f_4(x)=x^{10}-1$ 在 $[0,2]$ 上，其中 $x_{\\text{tol}}=10^{-12}$，$f_{\\text{tol}}=10^{-12}$，$N_{\\max}=10000$。此案例是专门构造的，旨在让经典 regula falsi 表现出“端点停滞”现象，而 Illinois 修正法通过重新加权来避免此现象。在经典方法下，左端点会反复移动，而右端点则倾向于保持固定，导致进展非常缓慢；Illinois 修正法通过在对侧连续更新后将未变端点的函数值减半来应对这种情况。\n\n第五，输出格式。你的程序应该生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。对于每个测试用例（按上述顺序），生成一个形式为 $[r, n_{\\mathrm{Ill}}, n_{\\mathrm{RF}}]$ 的子列表，其中 $r$ 是 Illinois 方法得到的根的近似值，四舍五入到 $12$ 位小数，$n_{\\mathrm{Ill}}$ 是 Illinois 方法的迭代次数，$n_{\\mathrm{RF}}$ 是经典 regula falsi 方法的迭代次数。因此，最终输出应为一个包含 4 个子列表的列表，其顺序与上述案例相同，无需单位。例如，一个语法上有效的形式是 $[[r_1,n_{\\mathrm{Ill},1},n_{\\mathrm{RF},1}],[r_2,n_{\\mathrm{Ill},2},n_{\\mathrm{RF},2}],[r_3,n_{\\mathrm{Ill},3},n_{\\mathrm{RF},3}],[r_4,n_{\\mathrm{Ill},4},n_{\\mathrm{RF},4}]]$.", "solution": "该问题要求实现并比较两种区间求根算法：经典试位法 (regula falsi) 及其 Illinois 修正法。解决方案按要求从第一性原理出发进行开发。\n\n任何区间法的理论基础都是**介值定理 (IVT)**。IVT 指出，对于一个在闭区间 $[a, b]$ 上连续的实值函数 $f$，如果 $f(a)$ 和 $f(b)$ 的值符号相反（即 $f(a)f(b) \\le 0$），那么在 $[a, b]$ 中必然存在至少一个点 $x^\\star$ 使得 $f(x^\\star) = 0$。该定理保证了在函数值于端点变号的任何区间内都存在一个根，从而为在该区间内搜索根提供了依据。两种算法都利用了这一点，确保在每一步中，更新后的区间都能继续将根包含在内。\n\n核心的构造原理是**线性插值**。给定函数 $y=f(x)$ 曲线上的两点 $(a, f(a))$ 和 $(b, f(b))$，我们可以用一条穿过这两点的直线（一条割线）来近似该函数。这个唯一的仿射函数 $L(x)$ 的方程是：\n$$L(x) = f(a) + \\frac{f(b) - f(a)}{b - a}(x - a)$$\n$f(x)$ 的根的近似值可以通过求解 $L(x)$ 的根来找到，即找到一个值 $c$ 使得 $L(c) = 0$。\n$$0 = f(a) + \\frac{f(b) - f(a)}{b - a}(c - a)$$\n求解 $c$ 可得到根近似的割线公式：\n$$c = a - f(a) \\frac{b - a}{f(b) - f(a)}$$\n一个代数上等价且通常在数值上更稳定的形式是：\n$$c = \\frac{a f(b) - b f(a)}{f(b) - f(a)}$$\n这个值 $c$ 成为根 $x^\\star$ 的新估计值。\n\n**1. 经典试位法 (Regula Falsi)**\n\nregula falsi 算法使用割线近似值 $c$ 来迭代地优化求根区间 $[a, b]$。\n在第 $k$ 次迭代，给定一个区间 $[a_k, b_k]$ 使得 $f(a_k)f(b_k)  0$：\n1.  使用割线公式计算根的近似值 $c_k$：$c_k = \\frac{a_k f(b_k) - b_k f(a_k)}{f(b_k) - f(a_k)}$。\n2.  计算 $f(c_k)$。\n3.  更新区间以保持符号变化，确保根仍被包含在内。\n    - 如果 $f(a_k)f(c_k)  0$，根位于 $[a_k, c_k]$ 中，因此新区间为 $[a_{k+1}, b_{k+1}] = [a_k, c_k]$。\n    - 否则，必然有 $f(c_k)f(b_k)  0$（假设 $f(c_k) \\ne 0$），因此新区间为 $[a_{k+1}, b_{k+1}] = [c_k, b_k]$。\n4.  当近似值足够精确时，过程终止。精确度由 $|f(c_k)| \\le f_{\\text{tol}}$ 或区间宽度 $|b_k - a_k| \\le x_{\\text{tol}}$ 来衡量，或者当达到最大迭代次数 $N_{\\max}$ 时终止。\n\nregula falsi 的一个已知弱点出现在根附近曲率符号不变的函数上（例如凸函数或凹函数）。在这种情况下，区间的一个端点可能会“卡住”，在多次迭代中保持不变。近似值 $c_k$ 随后将仅从一侧逼近根，导致收敛速度缓慢，为线性收敛，而不是预期的超线性收敛。\n\n**2. Illinois 修正法**\n\nIllinois 算法修改了 regula falsi 以解决“端点停滞”问题。它的操作与 regula falsi 完全相同，但增加了一条关键规则：\n- 如果一个端点（例如 $b$）被新的近似值 $c_k$ 替换，算法会记录下来。如果在接下来的迭代中，端点 $b$ 再次被替换（这意味着端点 $a$ 已经连续两步没有移动），算法会推断出 $a$ 是“停滞”的端点。\n- 为了打破这种停滞，在计算*下一个*割线近似值之前，人为地减小停滞端点的函数值。具体来说，如果端点 $a$ 停滞，我们设置 $f(a) \\leftarrow f(a)/2$。对称地，如果端点 $b$ 停滞，我们设置 $f(b) \\leftarrow f(b)/2$。\n\n这一修改有效地“拉平”了相对于静止端点的割线斜率，迫使下一个近似值 $c_{k+1}$ 更靠近该端点，从而提高了收敛速度。这种启发式方法有助于打破单边收敛的模式，并通常能恢复更高的收敛阶。\n\n实现将遵循这些原则，创建两个函数 `regula_falsi` 和 `illinois_method`，然后将它们应用于指定的测试集，以比较它们的性能，特别是在那些旨在突显经典方法缺陷的案例中。其结果——Illinois 方法的根近似值以及两种方法的迭代次数——将被收集并按要求格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares the classical regula falsi and Illinois methods for\n    root finding on a specified test suite, formatting the output as required.\n    \"\"\"\n\n    def regula_falsi(f, a, b, xtol, ftol, nmax):\n        \"\"\"\n        Implements the classical regula falsi (false position) method.\n        \"\"\"\n        fa = f(a)\n        fb = f(b)\n\n        if fa * fb >= 0:\n            # According to the problem statement, this path is not taken.\n            return (a + b) / 2, -1 \n\n        c = a  # Placeholder for the root approximation\n\n        for k in range(1, nmax + 1):\n            # The secant formula for the new approximation 'c'.\n            # This form is often more numerically stable than c = b - fb * (b - a) / (fb - fa).\n            c = (a * fb - b * fa) / (fb - fa)\n            fc = f(c)\n\n            # Termination condition 1: function value is close to zero\n            if abs(fc) = ftol:\n                return c, k\n\n            # Update the bracket [a, b] by replacing one endpoint\n            if fa * fc  0:\n                b = c\n                fb = fc\n            else:\n                a = c\n                fa = fc\n\n            # Termination condition 2: bracket width is small enough\n            if abs(b - a) = xtol:\n                return c, k\n\n        # If the loop completes, max iterations were reached\n        return c, nmax\n\n    def illinois_method(f, a, b, xtol, ftol, nmax):\n        \"\"\"\n        Implements the Illinois modification of the regula falsi method.\n        \"\"\"\n        fa = f(a)\n        fb = f(b)\n\n        if fa * fb >= 0:\n            return (a + b) / 2, -1\n\n        c = a\n        # A state variable to track which endpoint was last replaced.\n        # 0: initial state, 1: 'a' was replaced, 2: 'b' was replaced.\n        last_replaced = 0 \n\n        for k in range(1, nmax + 1):\n            # Calculate the new approximation 'c' using the secant formula.\n            c = (a * fb - b * fa) / (fb - fa)\n            fc = f(c)\n\n            # Termination condition 1\n            if abs(fc) = ftol:\n                return c, k\n\n            # Update the bracket and apply the Illinois modification heuristic.\n            if fa * fc  0:  # Root is in [a, c], so 'b' is the endpoint to be replaced\n                b = c\n                fb = fc\n                if last_replaced == 2:  # 'b' was also replaced last time, so 'a' is the stuck endpoint\n                    fa *= 0.5\n                last_replaced = 2\n            else:  # Root is in [c, b], so 'a' is the endpoint to be replaced\n                a = c\n                fa = fc\n                if last_replaced == 1:  # 'a' was also replaced last time, so 'b' is the stuck endpoint\n                    fb *= 0.5\n                last_replaced = 1\n\n            # Termination condition 2\n            if abs(b - a) = xtol:\n                return c, k\n        \n        return c, nmax\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'f': lambda x: np.cos(x) - x, 'a': 0.0, 'b': 1.0, 'xtol': 1e-12, 'ftol': 1e-12, 'nmax': 1000},\n        {'f': lambda x: x**2 - 2, 'a': 0.0, 'b': 2.0, 'xtol': 1e-12, 'ftol': 1e-12, 'nmax': 1000},\n        {'f': lambda x: np.exp(-x) - x, 'a': 0.0, 'b': 1.0, 'xtol': 1e-12, 'ftol': 1e-12, 'nmax': 1000},\n        {'f': lambda x: x**10 - 1, 'a': 0.0, 'b': 2.0, 'xtol': 1e-12, 'ftol': 1e-12, 'nmax': 10000}\n    ]\n\n    results_as_strings = []\n    for case in test_cases:\n        # Unpack parameters for the current test case\n        f, a, b, xtol, ftol, nmax = case['f'], case['a'], case['b'], case['xtol'], case['ftol'], case['nmax']\n\n        # Run the Illinois method to get root and iteration count\n        r_ill, n_ill = illinois_method(f, a, b, xtol, ftol, nmax)\n        \n        # Run the classical regula falsi method to get its iteration count\n        _, n_rf = regula_falsi(f, a, b, xtol, ftol, nmax)\n        \n        # Per problem specification, round Illinois root to 12 decimal places\n        r_ill_rounded = round(r_ill, 12)\n\n        # Format the sublist for this test case\n        results_as_strings.append(f\"[{str(r_ill_rounded)},{n_ill},{n_rf}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```", "id": "3211594"}]}