{"hands_on_practices": [{"introduction": "掌握一个数值算法最好的方式就是亲手计算一遍。本练习将引导你对一个具体的函数应用试位法，完成单步迭代。通过计算连接区间端点的割线与 $x$ 轴的交点，你将巩固对该方法基本几何原理和迭代公式的理解。[@problem_id:2217545]", "problem": "在一个自调节热力系统的简化模型中，非平凡平衡温度由超越方程 $f(x) = \\exp(-x) - x = 0$ 的正根描述，其中 $x$ 是一个无量纲的温度参数。根据物理约束可知，一个根位于区间 $[0, 1]$ 内。\n\n为了近似这个根，采用了一种数值单步法。第一次近似值（记为 $x_1$）通过找到连接曲线 $y=f(x)$ 上对应于区间端点的两点的割线的 x-截距来确定。\n\n计算此第一次近似值 $x_1$。将最终答案四舍五入至四位有效数字。", "solution": "我们已知 $f(x) = \\exp(-x) - x$ 和区间 $[0,1]$。穿过点 $(0,f(0))$ 和 $(1,f(1))$ 的割线斜率为\n$$\nm=\\frac{f(1)-f(0)}{1-0} = \\left(\\exp(-1)-1\\right) - 1 = \\exp(-1) - 2.\n$$\n这条割线的方程是\n$$\ny = f(0) + m(x-0) = 1 + \\left(\\exp(-1) - 2\\right)x.\n$$\n第一次近似值 $x_{1}$ 是这条线的 x-截距，通过令 $y=0$ 并解出 $x$ 得到：\n$$\n0 = 1 + \\left(\\exp(-1) - 2\\right)x \\quad \\Longrightarrow \\quad x_{1} = \\frac{1}{2 - \\exp(-1)}.\n$$\n为了求得所需的数值，计算\n$$\n\\exp(-1) \\approx 0.3678794412,\\quad 2 - \\exp(-1) \\approx 1.6321205588,\\quad x_{1} \\approx \\frac{1}{1.6321205588} \\approx 0.6126998368.\n$$\n四舍五入到四位有效数字得到 $x_{1} \\approx 0.6127$。", "answer": "$$\\boxed{0.6127}$$", "id": "2217545"}, {"introduction": "掌握了基本步骤之后，理解一个算法的性能和潜在缺陷至关重要。本练习旨在通过一个具体的案例来揭示标准试位法的一个著名弱点——端点停滞。你将需要分别使用试位法和二分法进行迭代计算并比较它们的收敛速度，从而亲身体验在特定条件下，该方法的性能为何会显著下降。[@problem_id:3251509]", "problem": "设 $f(x)$ 是定义在区间 $[a,b]$ 上的一个连续标量函数，且满足 $f(a)f(b)  0$。两种依赖于连续性和符号变化的区间求根方法是二分法和试位法 (regula falsi)。二分法在介值定理 (IVT) 的指导下，通过重复对分区间来求解；而试位法则是用连接函数 $f$ 图形上两端点的直线与 $x$ 轴的交点来取代中点。高曲率可能导致试位法的收敛速度慢于二分法，因为割线可能重复地在靠近同个端点的位置与 x 轴相交，使得一个端点实际上被固定，从而导致更新量很小。\n\n使用函数 $f(x) = \\exp(10x) - 2$ 在区间 $[0,1]$ 上具体地模拟这种情况。\n\n任务：\n- 使用介值定理 (IVT) 和单调性，证明方程 $f(x) = 0$ 在 $[0,1]$ 内有唯一根，并写出该根的精确符号表达式。\n- 从在有符号变化的区间 $[a,b]$ 上进行线性插值的第一性原理出发，推导二分法和试位法 (regula falsi) 的更新规则，不要引用任何已有的迭代公式。\n- 从 $a_0 = 0$ 和 $b_0 = 1$ 开始，对给定的函数 $f$ 使用两种方法各执行 5 次迭代。对于两种方法，在每次迭代中，将当前的根近似值定义为该方法为确定下一个子区间而计算的点：对于二分法，是当前区间的中点；对于试位法，是穿过 $(a_k,f(a_k))$ 和 $(b_k,f(b_k))$ 的割线的 $x$ 轴截距。\n- 设 $r$ 表示精确根。计算每种方法 5 次迭代后的绝对误差 $E_{\\mathrm{bisect}} = |x_{\\mathrm{bisect},5} - r|$ 和 $E_{\\mathrm{rf}} = |x_{\\mathrm{rf},5} - r|$，并报告 $E_{\\mathrm{rf}} / E_{\\mathrm{bisect}}$ 的值。\n\n将最终的比值四舍五入至四位有效数字。无需物理单位。", "solution": "问题陈述经核实具有科学依据、提法恰当、客观且完整。它描述了一个比较二分法和试位法收敛性的标准数值分析练习。所有必要的数据和定义均已提供。我们可以开始求解。\n\n所考虑的函数为 $f(x) = \\exp(10x) - 2$，定义在区间 $[0,1]$ 上。\n\n**唯一根的证明**\n\n首先，我们使用介值定理 (IVT) 来证明在区间 $[0,1]$ 内存在一个根。函数 $f(x)$ 是指数函数和线性函数的复合，这两者对所有实数都是连续的。因此，$f(x)$ 在 $[0,1]$ 上是连续的。我们计算函数在区间端点处的值：\n$f(0) = \\exp(10 \\cdot 0) - 2 = \\exp(0) - 2 = 1 - 2 = -1$。\n$f(1) = \\exp(10 \\cdot 1) - 2 = \\exp(10) - 2$。由于 $e \\approx 2.718$，$\\exp(10)$ 是一个非常大的正数，所以 $f(1) > 0$。\n具体来说，$f(1) \\approx 22026.466 - 2 = 22024.466$。\n由于 $f(0)  0$ 且 $f(1) > 0$，我们有 $f(0)f(1)  0$。根据介值定理，必然存在至少一个根 $r \\in (0,1)$ 使得 $f(r)=0$。\n\n为了证明该根的唯一性，我们考察函数的单调性。我们计算 $f(x)$ 的一阶导数：\n$$f'(x) = \\frac{d}{dx}(\\exp(10x) - 2) = 10\\exp(10x)$$\n对于任意 $x \\in [0,1]$，指数函数 $\\exp(10x)$ 严格为正。因此，对于所有 $x \\in [0,1]$，$f'(x) > 0$。这意味着 $f(x)$ 在该区间上是严格递增的。一个严格单调的函数最多与 x 轴相交一次。因此，根 $r$ 是唯一的。\n\n根的精确值（记为 $r$）可以通过求解 $f(x) = 0$ 得到：\n$$\\exp(10r) - 2 = 0$$\n$$\\exp(10r) = 2$$\n$$10r = \\ln(2)$$\n$$r = \\frac{\\ln(2)}{10}$$\n其数值约为 $r \\approx 0.069314718$。\n\n**更新规则的推导**\n\n设当前的求根区间为 $[a,b]$，且 $f(a)f(b)  0$。\n\n对于**二分法**，下一个近似值选择为区间的中点。这个选择源于希望以最大的保证因子（即2）来缩小区间。第 k+1 次迭代的近似值 $x_{k+1}$ 的更新规则是：\n$$x_{k+1} = c = \\frac{a_k + b_k}{2}$$\n然后，新的区间 $[a_{k+1}, b_{k+1}]$ 从 $[a_k, c]$ 或 $[c, b_k]$ 中选取，以保持符号变化，即 $f(a_{k+1})f(b_{k+1})0$。\n\n对于**试位法 (regula falsi)**，下一个近似值是连接点 $(a, f(a))$ 和 $(b, f(b))$ 的割线的 $x$ 轴截距。经过这两点的直线方程可以用点斜式写出：\n$$y - f(a) = \\frac{f(b) - f(a)}{b - a}(x - a)$$\n$x$ 轴截距是当 $y=0$ 时的 $x$ 值。我们称这个截距为 $c$。\n$$0 - f(a) = \\frac{f(b) - f(a)}{b - a}(c - a)$$\n解出 $c$：\n$$(c - a) = -f(a) \\frac{b - a}{f(b) - f(a)}$$\n$$c = a - f(a) \\frac{b - a}{f(b) - f(a)}$$\n这可以被重新整理成一个更对称的形式：\n$$c = \\frac{a(f(b) - f(a)) - f(a)(b - a)}{f(b) - f(a)} = \\frac{a f(b) - a f(a) - b f(a) + a f(a)}{f(b) - f(a)} = \\frac{a f(b) - b f(a)}{f(b) - f(a)}$$\n所以，近似值的更新规则是：\n$$x_{k+1} = c = \\frac{a_k f(b_k) - b_k f(a_k)}{f(b_k) - f(a_k)}$$\n与二分法类似，选择新区间以保持符号变化。\n\n**执行五次迭代**\n\n我们从区间 $[a_0, b_0] = [0,1]$ 开始。\n\n**二分法：**\n- 迭代 1：$x_{\\mathrm{bisect},1} = \\frac{0+1}{2} = 0.5$。$f(0.5) = \\exp(5)-2 > 0$。新区间为 $[0, 0.5]$。\n- 迭代 2：$x_{\\mathrm{bisect},2} = \\frac{0+0.5}{2} = 0.25$。$f(0.25) = \\exp(2.5)-2 > 0$。新区间为 $[0, 0.25]$。\n- 迭代 3：$x_{\\mathrm{bisect},3} = \\frac{0+0.25}{2} = 0.125$。$f(0.125) = \\exp(1.25)-2 > 0$。新区间为 $[0, 0.125]$。\n- 迭代 4：$x_{\\mathrm{bisect},4} = \\frac{0+0.125}{2} = 0.0625$。$f(0.0625) = \\exp(0.625)-2  0$。新区间为 $[0.0625, 0.125]$。\n- 迭代 5：$x_{\\mathrm{bisect},5} = \\frac{0.0625+0.125}{2} = 0.09375$。\n\n第五次近似值为 $x_{\\mathrm{bisect},5} = 0.09375$。\n\n**试位法：**\n我们从 $[a_0, b_0] = [0,1]$ 开始，$f(a_0)=-1$，$f(b_0)=\\exp(10)-2$。\n- 迭代 1：$x_{\\mathrm{rf},1} = \\frac{0 \\cdot f(1) - 1 \\cdot f(0)}{f(1)-f(0)} = \\frac{-(-1)}{\\exp(10)-2 - (-1)} = \\frac{1}{\\exp(10)-1} \\approx 0.00004540$。由于 $f(x_{\\mathrm{rf},1})  0$，新区间为 $[x_{\\mathrm{rf},1}, 1]$。\n- 迭代 2：$a_1=x_{\\mathrm{rf},1}, b_1=1$。$x_{\\mathrm{rf},2} = \\frac{a_1 f(b_1) - b_1 f(a_1)}{f(b_1)-f(a_1)} \\approx 0.00009078$。由于 $f(x_{\\mathrm{rf},2})  0$，新区间为 $[x_{\\mathrm{rf},2}, 1]$。\n- 迭代 3：$a_2=x_{\\mathrm{rf},2}, b_2=1$。$x_{\\mathrm{rf},3} \\approx 0.00013612$。由于 $f(x_{\\mathrm{rf},3})  0$，新区间为 $[x_{\\mathrm{rf},3}, 1]$。\n- 迭代 4：$a_3=x_{\\mathrm{rf},3}, b_3=1$。$x_{\\mathrm{rf},4} \\approx 0.00018144$。由于 $f(x_{\\mathrm{rf},4})  0$，新区间为 $[x_{\\mathrm{rf},4}, 1]$。\n- 迭代 5：$a_4=x_{\\mathrm{rf},4}, b_4=1$。$x_{\\mathrm{rf},5} \\approx 0.00022673$。\n\n注意试位法对此函数的典型慢收敛现象。由于高曲率，$f(x_{\\mathrm{rf},k})$ 始终为负，导致右端点 $b_k=1$ 保持固定（或“卡住”）。近似值从左侧非常缓慢地向根移动。\n使用高精度计算，第五次近似值为 $x_{\\mathrm{rf},5} \\approx 0.0002268285$。\n\n**误差比计算**\n\n精确根为 $r = \\frac{\\ln(2)}{10} \\approx 0.0693147181$。\n二分法的第五次近似值为 $x_{\\mathrm{bisect},5} = 0.09375$。\n二分法的绝对误差为：\n$E_{\\mathrm{bisect}} = |x_{\\mathrm{bisect},5} - r| = |0.09375 - 0.0693147181| \\approx 0.0244352819$。\n\n试位法的第五次近似值为 $x_{\\mathrm{rf},5} \\approx 0.0002268285$。\n试位法的绝对误差为：\n$E_{\\mathrm{rf}} = |x_{\\mathrm{rf},5} - r| = |0.0002268285 - 0.0693147181| \\approx 0.0690878896$。\n\n误差之比为：\n$$\\frac{E_{\\mathrm{rf}}}{E_{\\mathrm{bisect}}} = \\frac{0.0690878896}{0.0244352819} \\approx 2.827367468$$\n将此结果四舍五入至四位有效数字，得到 $2.827$。\n这证实了对于这个特定的函数和初始区间，5 次迭代后，试位法的误差明显大于二分法的误差。", "answer": "$$\n\\boxed{2.827}\n$$", "id": "3251509"}, {"introduction": "从分析问题到综合解决方案是迈向精通的关键一步。在认识到标准试位法的局限性之后，这个高级实践将挑战你设计并实现一个更强大的混合算法。你的任务是编写一个程序，该程序能智能地在试位法和二分法之间切换以克服端点停滞问题，从而创建一个在速度和稳健性之间达到更优平衡的求根工具。[@problem_id:3251464]", "problem": "设计并实现一个完整的、可运行的程序，该程序采用一种混合区间法计算连续实值函数的根。该方法主要使用试位法 (regula falsi)，并在包围区间的某个端点连续两次迭代保持不变时，临时切换到二分法步骤。该方法必须作用于闭区间 $[a,b]$ 上的一个连续函数 $f$，且满足 $f(a)\\cdot f(b)\\le 0$，因此根据介值定理，在 $[a,b]$ 中至少存在一个根。程序不得依赖任何用户输入。\n\n您必须从基本原理出发构建该算法。请从以下基础开始：\n- 当 $f(a)\\cdot f(b)\\le 0$ 时，函数 $f$ 在 $[a,b]$ 上的连续性以及介值定理保证了在 $[a,b]$ 中至少存在一个根 $x^\\star$ 满足 $f(x^\\star)=0$。\n- 对 $(a,f(a))$ 和 $(b,f(b))$ 进行线性插值的思想可以得出一个插值函数与横轴相交的 x 坐标，该坐标可作为 $[a,b]$ 内的一个候选点，用于以保持符号改变的方式更新区间。\n- 通过区间中点来划分区间（即二分法）可以保持一个符号改变的区间，并将区间宽度缩小为原来的一半。\n\n您设计的混合方法必须满足以下所有要求。\n- 初始化和区间设定：\n  - 接受一个连续函数 $f$、一个满足 $f(a)\\cdot f(b)\\le 0$ 的初始区间 $[a,b]$、一个绝对函数容差 $\\tau_f0$、一个绝对区间长度容差 $\\tau_x0$ 以及一个最大迭代次数 $N_{\\max}\\in\\mathbb{N}$。\n  - 如果在初始化时 $f(a)=0$ 或 $f(b)=0$，则立即返回对应的端点作为根的近似值。\n- 迭代和更新规则：\n  - 在每次迭代中，作为主要步骤，通过对 $(a,f(a))$ 和 $(b,f(b))$ 进行线性插值来计算 $[a,b]$ 内的一个候选点。利用候选点处 $f$ 的符号选择能保持符号改变的新子区间，并相应地更新包围区间的端点。\n  - 跟踪每次迭代中哪个端点被更新。如果在连续两次迭代中更新了同一个端点，则说明另一个端点已经连续两次保持不变。在这种情况下，下一次迭代必须执行一次二分法更新而非线性插值更新，并在这次二分法更新后，必须重置跟踪端点停滞状态的计数器。\n  - 为保证数值稳健性，如果因为分母实际上为零（例如， $|f(b)-f(a)|$ 小于机器精度）导致线性插值步骤变得病态，则在该次迭代中應改为执行一次二分法更新。\n- 终止条件和返回值：\n  - 当当前候选点 $c$ 满足 $|f(c)|\\le \\tau_f$，或当前包围区间宽度满足 $b-a\\le \\tau_x$，或迭代计数器达到 $N_{\\max}$ 时，算法终止。返回最近的候选点 $c$（如果在初始化时检测到端点即为精确根，则返回该端点）。\n- 角度单位：当使用三角函数时，角度应以弧度为单位。\n- 输出格式：对于下面测试套件中的每个测试用例，返回计算出的根的近似值，该值應为浮点数并四舍五入到 $10$ 位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，不含空格，例如 $[r_1,r_2,\\dots]$。\n\n测试套件。实现您的程序，使其严格按照以下顺序计算下列 $5$ 个案例的根近似值，每个案例均使用 $\\tau_x=10^{-10}$、$\\tau_f=10^{-12}$ 和 $N_{\\max}=100$。\n- 案例 1：$f(x)=x^3-x-2$ 在 $[1,2]$ 上。\n- 案例 2：$f(x)=e^{-x}-x$ 在 $[0,1]$ 上。\n- 案例 3：$f(x)=(x-1)(x-2)$ 在 $[1,3]$ 上。\n- 案例 4：$f(x)=\\cos(x)-x$ 在 $[0,1]$ 上；將 $x$ 解释为弧度。\n- 案例 5：$f(x)=x^3$ 在 $[-1,1]$ 上。\n\n您的程序必须按上述顺序计算五个根的近似值，并打印包含列表 $[r_1,r_2,r_3,r_4,r_5]$ 的单行输出，其中每个 $r_i$ 都按要求四舍五入到 $10$ 位小数。不得打印任何其他文本。", "solution": "问题陈述经评估是有效的。它在科学上基于数值分析的原理，特别是介值定理、试位法（regula falsi）和二分法。该问题是适定的，为设计混合求根算法提供了一套完整且一致的要求。其语言客观，测试用例定义明確，适合用于验证算法的实现。\n\n任务是为闭区间 $[a, b]$ 上的连续函数 $f(x)$ 设计并实现一种混合求根算法，其中保证 $f(a) \\cdot f(b) \\le 0$。因此，介值定理保证了在 $[a, b]$ 中至少存在一个根 $x^\\star$。该算法主要使用试位法，但结合了二分法步骤，以缓解当某个包围区间端点停滞时可能出现的收敛缓慢问题。\n\n试位法的核心是线性插值。给定两个包围一个根的点 $(a, f(a))$ 和 $(b, f(b))$，算法用连接这两点的直线（一条割线）来近似函数 $f(x)$。根的下一个近似值 $c$ 是这条直线的 x 轴截距。$c$ 的公式由直线的点斜式导出，形式如下：\n$$\nc = a - f(a) \\frac{b - a}{f(b) - f(a)}\n$$\n出于数值稳定性的考虑，通常首选此形式而非另一种形式 $c = \\frac{a f(b) - b f(a)}{f(b) - f(a)}$，因为当 $a$ 和 $b$ 的值很大且彼此接近时，前者不易受到灾难性抵消的影响。\n\n二分法提供了一种稳健但较慢的替代方案。它通过重复地将区间二等分并选择保持符号改变的子区间来保证收敛。中点 $c$ 的计算公式为：\n$$\nc = a + \\frac{1}{2}(b - a)\n$$\n\n问题中指定的混合算法结合了这两种方法。迭代过程如下：\n1.  **初始化**：给定函数 $f$、区间 $[a, b]$、容差 $\\tau_f  0$ 和 $\\tau_x  0$ 以及最大迭代次数 $N_{\\max}$。计算 $f_a = f(a)$ 和 $f_b = f(b)$。如果 $|f_a| \\le \\tau_f$ 或 $|f_b| \\le \\tau_f$，则返回相应的端点作为根。将两个计数器 `stagnant_a` 和 `stagnant_b` 初始化为 $0$，用于跟踪端点保持不变的连续迭代次数。\n\n2.  **迭代循环**：循环最多进行 $N_{\\max}$ 次迭代。在每次迭代中，计算一个新的候选根 $c$。\n\n3.  **步骤选择**：\n    -   **停滞检查**：如果 `stagnant_a` 或 `stagnant_b` 大于或等于 $2$，表明某个端点已连续两步保持不变。此时执行一次二分法步骤，并将两个停滞计数器都重置为 $0$。\n    -   **稳健性检查**：如果试位法公式中的分母 $|f(b) - f(a)|$ 接近于零（例如，小于机器浮点数精度），则执行一次二分法步骤以防止数值不稳定。在这种情况下，不重置停滞计数器。\n    -   **默认步骤**：如果以上两个条件都不满足，则执行标准的试位法步骤。\n\n4.  **候选点评估和终止**：在新候选点处计算函数值 $f_c = f(c)$。如果函数值足够接近于零，即 $|f_c| \\le \\tau_f$，算法终止并返回 $c$。\n\n5.  **区间更新和计数器管理**：如果算法未终止，则更新包围区间。\n    -   如果 $f_a$ 和 $f_c$ 符号相同（即 $f_a \\cdot f_c  0$），则根必定位于 $[c, b]$ 内。因此，将 $a$ 更新为 $c$，将 $f_a$ 更新为 $f_c$。由于 $b$ 保持不变，`stagnant_b` 递增，而 `stagnant_a` 重置为 $0$。\n    -   否则，根必定位于 $[a, c]$ 内。因此，将 $b$ 更新为 $c$，将 $f_b$ 更新为 $f_c$。由于 $a$ 保持不变，`stagnant_a` 递增，而 `stagnant_b` 重置为 $0$。\n\n6.  **区间宽度终止**：更新区间后，检查新区间的宽度 $b-a$。如果 $b-a \\le \\tau_x$，则认为区间足够小。算法终止并返回当前迭代的候选点 $c$。\n\n7.  **最大迭代次数**：如果循环完成了 $N_{\\max}$ 次迭代仍未满足任何其他终止准则，则算法终止并返回最后计算的候选点 $c$。\n\n这种结构化的方法通过利用试位法的速度优势，同时使用二分法来避免其性能不佳的情况，从而确保了稳健的收敛。指定的测试用例将验证此逻辑的实现，包括初始端点即为根以及容易导致停滞的函数等边缘情况。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef hybrid_root_finder(f, a, b, tau_f, tau_x, n_max):\n    \"\"\"\n    Computes a root of a function f on an interval [a, b] using a hybrid\n    of the method of false position and the bisection method.\n\n    Args:\n        f (callable): The function for which to find a root.\n        a (float): The lower bound of the bracketing interval.\n        b (float): The upper bound of the bracketing interval.\n        tau_f (float): The absolute function value tolerance for convergence.\n        tau_x (float): The absolute interval width tolerance for convergence.\n        n_max (int): The maximum number of iterations.\n\n    Returns:\n        float: The approximated root.\n    \"\"\"\n    fa = f(a)\n    fb = f(b)\n\n    # Initial check if endpoints are roots\n    if abs(fa) = tau_f:\n        return a\n    if abs(fb) = tau_f:\n        return b\n\n    # Ensure the initial interval brackets a root\n    if fa * fb  0:\n        raise ValueError(\"The initial interval [a, b] does not bracket a root.\")\n\n    stagnant_a_counter = 0\n    stagnant_b_counter = 0\n    \n    # Initialize c to a value within the interval for safety in case of early termination\n    c = a\n\n    for _ in range(n_max):\n        # 1. Determine step type and calculate the new candidate point 'c'\n        use_bisection_stagnation = stagnant_a_counter = 2 or stagnant_b_counter = 2\n        \n        denom = fb - fa\n        use_bisection_robustness = abs(denom)  np.finfo(float).eps\n\n        if use_bisection_stagnation:\n            c = a + 0.5 * (b - a)\n            # Reset counters after a stagnation-induced bisection step\n            stagnant_a_counter = 0\n            stagnant_b_counter = 0\n        elif use_bisection_robustness:\n            c = a + 0.5 * (b - a)\n        else:\n            # Method of False Position (Regula Falsi)\n            c = a - fa * (b - a) / denom\n\n        fc = f(c)\n\n        # 2. Check for convergence based on function value at c\n        if abs(fc) = tau_f:\n            return c\n\n        # 3. Update the bracketing interval and stagnation counters\n        if fa * fc  0:\n            # Root is in [c, b], so update the left endpoint 'a'\n            a, fa = c, fc\n            stagnant_b_counter += 1\n            stagnant_a_counter = 0\n        else:\n            # Root is in [a, c], so update the right endpoint 'b'\n            b, fb = c, fc\n            stagnant_a_counter += 1\n            stagnant_b_counter = 0\n            \n        # 4. Check for convergence based on the width of the new interval\n        if b - a = tau_x:\n            return c\n\n    # Return the last computed candidate if max iterations reached\n    return c\n\ndef solve():\n    \"\"\"\n    Solves the defined test cases and prints the results in the specified format.\n    \"\"\"\n    # Define common parameters for all test cases\n    tau_x = 1e-10\n    tau_f = 1e-12\n    n_max = 100\n\n    # Define the functions for the test cases\n    def f1(x): return x**3 - x - 2\n    def f2(x): return np.exp(-x) - x\n    def f3(x): return (x - 1) * (x - 2)\n    def f4(x): return np.cos(x) - x\n    def f5(x): return x**3\n\n    # Define the test cases as a list of tuples: (function, a, b)\n    test_cases = [\n        (f1, 1.0, 2.0),\n        (f2, 0.0, 1.0),\n        (f3, 1.0, 3.0),\n        (f4, 0.0, 1.0),\n        (f5, -1.0, 1.0),\n    ]\n\n    results = []\n    for func, a_val, b_val in test_cases:\n        root = hybrid_root_finder(func, a_val, b_val, tau_f, tau_x, n_max)\n        results.append(root)\n\n    # Format the results rounded to 10 decimal places\n    formatted_results = [f'{round(r, 10):.10f}' for r in results]\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3251464"}]}