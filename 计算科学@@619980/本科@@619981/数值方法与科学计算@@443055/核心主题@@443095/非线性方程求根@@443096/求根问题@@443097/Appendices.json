{"hands_on_practices": [{"introduction": "二分法因其收敛性有保证，是数值方法中最稳健的求根算法。通常我们分析的是根的位置 $x$ 的误差，但在实际应用中，我们可能更关心函数值 $f(x)$ 的误差是否足够小。这个练习将指导你如何利用中值定理，将对根的近似误差与对函数值的近似误差联系起来，从而为一个现实世界中的盈亏平衡分析问题建立一个更有意义的停止准则。[@problem_id:2219715]", "problem": "一家专业无人机部件精品制造商将其周利润 $P(x)$（以美元计）建模为生产和销售的部件数量 $x$ 的函数。利润函数由下式给出：\n$$P(x) = -0.000001x^3 + 0.002x^2 + 15x - 5000$$\n该公司的分析师已确定，在产量区间 $[300, 400]$ 内存在一个盈亏平衡点，即利润为零的点。为了优化生产目标，管理者需要确定这个盈亏平衡产量。他们计划在初始区间 $[300, 400]$ 上使用二分法，为真实的盈亏平衡产量 $x^*$ 寻找一个近似值 $x_{approx}$。\n\n为确保近似盈亏平衡点处的利润绝对值 $|P(x_{approx})|$ 小于 $0.01$，所需的最小二分法迭代次数 $n$ 是多少？", "solution": "我们已知连续的三次利润函数\n$$P(x)=-1 \\times 10^{-6}x^{3}+2 \\times 10^{-3}x^{2}+15x-5000,$$\n其在区间 $\\left[300,400\\right]$ 内有一个根。二分法在每次迭代中将区间长度减半。设 $[a,b]=[300,400]$，则初始长度为 $L_{0}=b-a=100$。经过 $n$ 次迭代后，区间长度为\n$$L_{n}=\\frac{100}{2^{n}},$$\n其中点 $x_{\\text{approx}}$ 满足关于 $x$ 的标准二分法误差界：\n$$|x_{\\text{approx}}-x^{*}|\\leq \\frac{L_{n}}{2}=\\frac{100}{2^{n+1}}.$$\n\n为确保函数值的界，应用中值定理。在 $x_{\\text{approx}}$ 和 $x^{*}$ 之间存在一个 $c$，使得\n$$|P(x_{\\text{approx}})-P(x^{*})|=|P'(c)|\\,|x_{\\text{approx}}-x^{*}|.$$\n因此，对于任何 $M \\geq \\max_{x \\in [300,400]}|P'(x)|$，我们有\n$$|P(x_{\\text{approx}})| \\leq M\\,|x_{\\text{approx}}-x^{*}|.$$\n因此，只需满足\n$$|x_{\\text{approx}}-x^{*}|\\leq \\frac{0.01}{M}.$$\n\n计算一个合适的 $M$。求导：\n$$P'(x)=-3 \\times 10^{-6}x^{2}+4 \\times 10^{-3}x+15,$$\n$$P''(x)=-6 \\times 10^{-6}x+4 \\times 10^{-3}.$$\n令 $P''(x)=0$ 以找到 $P'$ 的极值点：\n$$-6 \\times 10^{-6}x+4 \\times 10^{-3}=0 \\;\\Rightarrow\\; x=\\frac{4 \\times 10^{-3}}{6 \\times 10^{-6}}=\\frac{2}{3} \\times 10^{3}=\\frac{2000}{3},$$\n该点位于区间 $\\left[300,400\\right]$ 之外。由于在区间 $\\left[300,400\\right]$ 上 $P''(x)>0$，因此 $P'(x)$ 在该区间上是递增的。因此\n$$M=\\max_{x \\in [300,400]}|P'(x)|=P'(400)=-3 \\times 10^{-6}\\cdot 160000+4 \\times 10^{-3}\\cdot 400+15=-0.48+1.6+15=16.12.$$\n\n为了保证 $|P(x_{\\text{approx}})|  0.01$，我们只需满足\n$$\\frac{100}{2^{n+1}} \\leq \\frac{0.01}{16.12} \\;\\;\\Longleftrightarrow\\;\\; 2^{n+1} \\geq \\frac{100 \\cdot 16.12}{0.01}=161200.$$\n由于 $2^{17}=131072  161200$ 且 $2^{18}=262144 \\geq 161200$，满足该不等式的最小整数 $n$ 为 17。", "answer": "$$\\boxed{17}$$", "id": "2219715"}, {"introduction": "不动点迭代是许多求根方法的普适性框架，包括著名的牛顿法。然而，与二分法不同，不动点迭代的收敛性并非总能得到保证，它完全取决于迭代函数 $g(x)$ 的性质。本练习提供了一个动手机会，让你探索著名收敛条件 $|g'(x^*)| \\lt 1$ 的实际应用，并理解如何通过调整一个参数 $\\alpha$ 来控制迭代过程，从而确保算法收敛。[@problem_id:2219690]", "problem": "一位工程师正在使用一种数值方法来求解方程 $e^{x} = 3$。他们选择了一个由以下递推关系定义的不动点迭代格式：\n$$\nx_{k+1} = x_{k} - \\alpha (e^{x_{k}} - 3)\n$$\n其中 $k$ 是迭代指数（$k=0, 1, 2, \\dots$），$\\alpha$ 是一个用于控制该方法收敛性的实值常数参数。为了使迭代收敛到方程的真实根，参数 $\\alpha$ 必须位于一个特定的范围内。\n\n假设初始猜测值 $x_0$ 足够接近根，下列哪个开区间表示了保证收敛的 $\\alpha$ 的取值范围？\n\nA. $(0, 1/3)$\nB. $(0, 2/3)$\nC. $(-1/3, 1/3)$\nD. $(0, 1)$\nE. $(-2/3, 2/3)$", "solution": "我们寻求迭代 $x_{k+1}=g(x_{k})$ 的不动点，其中\n$$\ng(x)=x-\\alpha\\left(\\exp(x)-3\\right).\n$$\n不动点 $x^{\\ast}$ 满足 $\\exp(x^{\\ast})=3$，因此 $x^{\\ast}=\\ln(3)$。\n\n假设 $x_{0}$ 足够接近 $x^{\\ast}$ 且 $g$ 在 $x^{\\ast}$ 附近连续可微，不动点迭代局部收敛的一个充分条件是压缩条件\n$$\n|g'(x^{\\ast})|  1.\n$$\n计算导数：\n$$\ng'(x)=1-\\alpha\\exp(x),\n$$\n于是在不动点处，\n$$\ng'(x^{\\ast})=1-\\alpha\\exp(x^{\\ast})=1-3\\alpha.\n$$\n收敛条件变为\n$$\n|1-3\\alpha|  1.\n$$\n这等价于双重不等式\n$$\n-1  1-3\\alpha  1.\n$$\n由左边的不等式：$-1  1-3\\alpha\\implies -2  -3\\alpha\\implies 2 > 3\\alpha\\implies \\alpha  \\frac{2}{3}$。\n由右边的不等式：$1-3\\alpha  1\\implies -3\\alpha  0\\implies 3\\alpha > 0\\implies \\alpha > 0$。\n合并得到\n$$\n0  \\alpha  \\frac{2}{3},\n$$\n这对应于选项 B。", "answer": "$$\\boxed{B}$$", "id": "2219690"}, {"introduction": "在区间内找到一个根是一项基本任务，但要找到区间内*所有*的根，并确保没有遗漏，则是一个在科学和工程领域中更为常见且艰巨的挑战。本练习将引导你设计并实现一个精密的算法来完成这项任务。该算法巧妙地结合了用于探测根存在的介值定理和用于证明根不存在的微分中值定理，展示了如何将深刻的数学理论转化为强大而可靠的数值计算工具。[@problem_id:3283618]", "problem": "考虑连续函数 $f(x) = \\cos(10x) - x$ 的求根问题，其中余弦函数的角度以弧度为单位。任务是设计并实现一个程序，对于给定的闭区间 $[a,b]$，找出所有满足 $f(x) = 0$ 的实数 $x \\in [a,b]$，并提供严格的证明以确保没有遗漏任何根。您的设计必须从数值方法的基本原理出发：连续性、介值定理和中值定理。使用有界导数论证建立一个先验李普希茨界，并构建一个自适应网格划分过程，该过程根据需要细分区间 $[a,b]$，以便检测根并证明不存在其他根。该证明必须从这些原理进行逻辑推导，并应确保每个子区间要么被证明无根，要么被不断细化，直到其中的任何根都被包围并求解。\n\n在此问题中，您必须：\n- 确定一个一致界 $L$，使得在任何所考虑的区间内，对于所有 $x$ 都有 $\\lvert f'(x) \\rvert \\le L$。\n- 实现 $[a,b]$ 的自适应细分。当子区间端点处的函数值异号时，使用区间法来分离并逼近一个根。当它们同号时，使用有界导数论证来证明整个子区间不含根；否则，进一步细分。\n- 确保算法能检测到存在的多个根，并确保发现的根被唯一地报告。\n\n您的程序应将该方法应用于以下测试套件中的区间，并汇总结果：\n- 测试 1：$[0,1]$。\n- 测试 2：$[-1,0]$。\n- 测试 3：$[1.2,2.0]$。\n- 测试 4：$[-1,1]$。\n- 测试 5：$[0.14,0.18]$。\n\n对于每个测试，返回给定区间内所有根的列表，表示为四舍五入到十位小数的浮点数。最终输出必须是单行文本，包含所有测试的结果，形式为由方括号括起来的逗号分隔的列表。例如，格式应为 $[[r_{1,1},r_{1,2},\\dots],[r_{2,1},\\dots],\\dots]$，其中 $r_{i,j}$ 表示在第 $i$ 个测试中找到的第 $j$ 个根。如果一个区间不含根，则为该区间返回一个空列表。角度必须以弧度为单位，不涉及任何物理单位。\n\n您的算法必须足够鲁棒，以处理：\n- 多个孤立根的一般情况（测试 1）。\n- 覆盖负值的对称区间（测试 2）。\n- 无根的情况，以测试您的无根证明（测试 3）。\n- 包含正负范围、可能含有更多根的较大区间（测试 4）。\n- 根周围的狭窄区间，以测试精度和边界处理（测试 5）。\n\n您的程序应生成一行输出，其中包含按逗号分隔的列表形式的结果，并用方括号括起来（例如，[[r_{1,1},r_{1,2}],[\\dots],\\dots]）。", "solution": "该问题要求我们找到函数 $f(x) = \\cos(10x) - x$ 在给定闭区间 $[a, b]$ 内的所有实根。任务的一个关键组成部分是基于微积分的基本原理，提供一个严格的证明，以确保没有遗漏任何根。所规定的方法论涉及区间的自适应细分与基于导数的论证相结合。\n\n### 理论框架\n\n所讨论的函数是 $f(x) = \\cos(10x) - x$。对于所有 $x \\in \\mathbb{R}$，该函数都是连续且无限可微的。证明方法的核心依赖于界定其变化率。\n\n1.  **函数及其导数**：\n    函数为 $f(x) = \\cos(10x) - x$。\n    其关于 $x$ 的导数为 $f'(x) = \\frac{d}{dx}(\\cos(10x) - x) = -10\\sin(10x) - 1$。\n\n2.  **李普希茨常数（有界导数）**：\n    为了证明一个区域无根，我们需要一个函数导数绝对值的一致上界。这个界，称为李普希茨常数 $L$，满足条件 $|f'(x)| \\le L$ 对所有在目标域中的 $x$ 成立。\n    正弦函数有界，满足 $-1 \\le \\sin(10x) \\le 1$。\n    因此，导数 $f'(x)$ 的界如下：\n    $$ -10(1) - 1 \\le -10\\sin(10x) - 1 \\le -10(-1) - 1 $$\n    $$ -11 \\le f'(x) \\le 9 $$\n    因此，$f'(x)$ 的最大绝对值为 $\\max(|-11|, |9|) = 11$。于是我们可以选择一个全局李普希茨常数 $L=11$。这意味着对于任意两点 $x_1$ 和 $x_2$，中值定理 (MVT) 保证：\n    $$ |f(x_1) - f(x_2)| \\le L |x_1 - x_2| = 11 |x_1 - x_2| $$\n\n### 算法设计：带证明的自适应细分\n\n仅仅搜索符号变化的朴素方法是不够的，因为一个区间可能包含偶数个根而其端点之间没有符号变化。指定的方法通过系统地细分区间来克服此问题，直到每个子区间要么可以被证明无根，要么小到足以分离其中包含的任何根。\n\n该算法使用一个待处理区间的栈，初始时包含区间 $[a, b]$。\n\n1.  **证明原理**：\n    考虑一个子区间 $[c, d]$。我们计算其端点处的函数值 $f(c)$ 和 $f(d)$。\n    如果 $f(c)$ 和 $f(d)$ 同号（例如，均为正），则只有当函数下降到零再返回时才可能存在根。我们可以使用李普希茨常数 $L$ 在 $[c,d]$ 上构造 $f(x)$ 的一个下界。函数的图像必须位于从 $(c, f(c))$ 和 $(d, f(d))$ 出发、斜率为 $\\pm L$ 的两条直线的上方。具体来说，对于 $x \\in [c, d]$，$f(x)$ 必须在由 $y_1(x) = f(c) - L(x-c)$ 和 $y_2(x) = f(d) - L(d-x)$ 构成的包络之上。\n    该包络的最小值出现在这两条线的交点处，可计算为 $y_{min} = \\frac{f(c)+f(d)}{2} - \\frac{L(d-c)}{2}$。\n    如果该最小值为正，那么我们可以确定对于所有 $x \\in [c, d]$，$f(x) > 0$。\n    如果 $f(c)$ 和 $f(d)$ 均为负，则适用对称的论证。这导出了通用的证明条件：\n    如果 $f(c)$ 和 $f(d)$ 同号且 $|f(c) + f(d)| > L(d-c)$，则保证区间 $[c, d]$ 无根。\n\n2.  **递归细分算法**：\n    - 初始化一个栈，其中包含起始区间 $[a, b]$。\n    - 从栈中弹出一个区间 $[c, d]$。\n    - 如果区间小于预定义的 `SUBDIVISION_STOP_WIDTH`（例如 $10^{-9}$），则将其视为“原子”区间。我们通过检查 $f(c)f(d) \\le 0$ 来测试是否存在根。如果条件成立，介值定理 (IVT) 保证存在一个根，然后使用像二分法这样的区间数值方法找到它。否则，这个微小区间被舍弃。\n    - 对于较大的区间：\n        - **情况1：同号 ($f(c)f(d) > 0$)**：检验证明条件 $|f(c) + f(d)| > L(d-c)$。如果为真，则该区间被证明无根并被舍弃。如果为假，我们无法确定，因此将该区间在其中心点 $m=(c+d)/2$ 处细分，并将得到的两个子区间 $[c, m]$ 和 $[m, d]$ 推入栈中以供进一步研究。\n        - **情况2：异号 ($f(c)f(d) \\le 0$)**：介值定理保证至少存在一个根。然而，可能存在奇数个根（$3, 5, \\dots$）。由于我们无法证明不存在其他根，唯一严谨的做法是细分该区间。将 $[c, m]$ 和 $[m, d]$ 都推入栈中。\n\n3.  **根的分离与唯一性**：\n    - 当细分过程产生一个包含符号变化的非常小的区间时，我们采用二分法以高精度（例如，容差为 $10^{-15}$）逼近根。\n    - 整个过程会填充一个已找到根的列表。由于单个根可能在两个相邻小区间的边界处被检测到，因此需要一个最终的筛选步骤。对根列表进行排序，并通过迭代排序后的列表去除重复项，只保留与前一个根的差值大于一个小的容差（例如 $10^{-12}$）的根。\n    - 最后，将唯一的根四舍五入到所需的 $10$ 位小数。\n\n这个完整、系统的过程确保了对整个初始区间 $[a, b]$ 的穷尽搜索，并且无根证明测试与递归细分的结合保证了所有根都被找到。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants defining the problem and algorithm parameters.\nL = 11.0  # Lipschitz constant for f(x)\nTOLERANCE_BISECT = 1e-15  # Tolerance for the bisection root-finding method.\nTOLERANCE_UNIQUENESS = 1e-12  # Tolerance for distinguishing unique roots.\n# Subdivision stops when an interval's width is below this threshold.\n# On such small intervals, we check for a root using IVT directly.\nSUBDIVISION_STOP_WIDTH = 1e-9\n\ndef f(x):\n    \"\"\"The function for which we are finding roots.\"\"\"\n    return np.cos(10 * x) - x\n\ndef bisection(c, d):\n    \"\"\"\n    Finds a root in the interval [c, d] using the bisection method.\n    It is assumed that f(c) * f(d) = 0.\n    \"\"\"\n    low, high = c, d\n    f_low = f(low)\n    \n    # Safety check for roots at endpoints.\n    if abs(f_low)  TOLERANCE_BISECT:\n        return low\n    if abs(f(high))  TOLERANCE_BISECT:\n        return high\n\n    # Bisection guarantees convergence. 100 iterations is more than\n    # sufficient for standard double precision floating-point numbers.\n    for _ in range(100):\n        if high - low  TOLERANCE_BISECT:\n            break\n        \n        mid = low + (high - low) / 2  # Numerically stable midpoint calculation\n        f_mid = f(mid)\n\n        if abs(f_mid)  TOLERANCE_BISECT:\n            return mid\n\n        # If signs are different, root is in the lower half.\n        if np.sign(f_low) != np.sign(f_mid):\n            high = mid\n        else: # Otherwise, root is in the upper half.\n            low = mid\n            f_low = f_mid\n            \n    return low + (high - low) / 2\n\ndef find_all_roots_certified(a, b):\n    \"\"\"\n    Finds all roots of f(x) in the interval [a, b] using an adaptive\n    subdivision algorithm with a rigorous certification of absence.\n    \"\"\"\n    stack = [(a, b)]\n    roots = []\n\n    while stack:\n        c, d = stack.pop()\n\n        if d = c:\n            continue\n\n        f_c = f(c)\n        f_d = f(d)\n\n        # Base case for recursion: interval is small enough.\n        if (d - c)  SUBDIVISION_STOP_WIDTH:\n            # For this small interval, check for a root using the Intermediate Value Theorem.\n            if f_c * f_d = 0:\n                root = bisection(c, d)\n                roots.append(root)\n            # If no sign change, the small interval is discarded.\n            continue\n\n        # Subdivision Step:\n        # Case 1: No sign change. Attempt to certify that no roots exist.\n        if f_c * f_d > 0:\n            # Certification condition: |f(c) + f(d)| > L * (d-c)\n            if abs(f_c + f_d) > L * (d - c):\n                # Interval is certified to be root-free. Discard it.\n                continue\n            else:\n                # Certification failed. Subdivide and check both halves.\n                m = c + (d-c)/2\n                stack.append((c, m))\n                stack.append((m, d))\n        # Case 2: Sign change detected.\n        else:  # f_c * f_d = 0\n            # A root is guaranteed, but more may exist. Subdivide to find all.\n            m = c + (d-c)/2\n            stack.append((c, m))\n            stack.append((m, d))\n\n    # Post-processing: remove duplicates and round.\n    if not roots:\n        return []\n\n    roots.sort()\n    \n    # Filter for unique roots based on a proximity tolerance.\n    unique_roots = [roots[0]]\n    for i in range(1, len(roots)):\n        if abs(roots[i] - unique_roots[-1]) > TOLERANCE_UNIQUENESS:\n            unique_roots.append(roots[i])\n\n    # Round the final unique roots to the specified number of decimal places.\n    return [round(r, 10) for r in unique_roots]\n\ndef solve():\n    \"\"\"\n    Main function to run the root-finding algorithm on the given test cases\n    and print the results in the specified format.\n    \"\"\"\n    test_cases = [\n        (0.0, 1.0),\n        (-1.0, 0.0),\n        (1.2, 2.0),\n        (-1.0, 1.0),\n        (0.14, 0.18),\n    ]\n\n    results = []\n    for a, b in test_cases:\n        # The result for each case is the list of roots found in the interval.\n        roots_list = find_all_roots_certified(a, b)\n        results.append(roots_list)\n\n    # Format the final output string to match the problem specification\n    # e.g., \"[[root1,root2],[],[root3]]\" with no spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3283618"}]}