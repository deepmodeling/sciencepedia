{"hands_on_practices": [{"introduction": "为了真正掌握霍纳法，我们从一个基础练习开始。这个练习将引导你逐步完成多项式求值的过程，让你能够追踪中间值的序列，并亲眼见证算法的运作方式 [@problem_id:2177814]。这种动手计算是掌握这一高效方法的第一步。", "problem": "一个 $n$ 次多项式的一般形式为 $P(x) = \\sum_{i=0}^{n} a_i x^i = a_n x^n + a_{n-1} x^{n-1} + \\dots + a_1 x + a_0$。在特定点 $x=c$ 处计算该多项式值的一种计算上有效的方法是生成一系列中间值，这通常被称为霍纳法 (Horner's method)。这个序列记为 $y_0, y_1, \\dots, y_n$，是使用以下递推关系构建的：\n- $y_0 = a_n$\n- 对于 $k = 1, 2, \\dots, n$，$y_k = y_{k-1} \\cdot c + a_{n-k}$。\n\n该序列的最后一项 $y_n$ 是多项式在 $c$ 处的值，即 $y_n = P(c)$。\n\n对于多项式 $P(x) = 4x^3 - 2x^2 + 5x - 1$，请确定在点 $x=2$ 处计算 $P(x)$ 时，由该方法生成的完整数值序列 $(y_0, y_1, y_2, y_3)$。", "solution": "给定多项式 $P(x) = 4x^{3} - 2x^{2} + 5x - 1$，其次数为 $n=3$。因此系数为 $a_{3} = 4$，$a_{2} = -2$，$a_{1} = 5$ 以及 $a_{0} = -1$。我们使用霍纳递推法在 $c=2$ 处求值：\n$$\ny_{0} = a_{3} = 4,\n$$\n且对于 $k=1,2,3$，\n$$\ny_{k} = y_{k-1}\\cdot c + a_{3-k}.\n$$\n\n按步骤计算：\n$$\ny_{1} = y_{0}\\cdot 2 + a_{2} = 4\\cdot 2 + (-2) = 8 - 2 = 6,\n$$\n$$\ny_{2} = y_{1}\\cdot 2 + a_{1} = 6\\cdot 2 + 5 = 12 + 5 = 17,\n$$\n$$\ny_{3} = y_{2}\\cdot 2 + a_{0} = 17\\cdot 2 + (-1) = 34 - 1 = 33.\n$$\n\n因此，该序列是 $(y_{0}, y_{1}, y_{2}, y_{3}) = (4, 6, 17, 33)$，且 $y_{3} = P(2) = 33$。", "answer": "$$\\boxed{\\begin{pmatrix} 4  6  17  33 \\end{pmatrix}}$$", "id": "2177814"}, {"introduction": "熟悉了基本操作之后，让我们来探究霍纳法更深层次的理论威力。这个问题将证明，该算法不仅仅是一种计算捷径，它还是多项式余数定理的直接体现 [@problem_id:3239198]。通过这个练习，你将了解如何利用精确的整数算术来完成诸如寻找整数根之类的任务，这在许多计算场景中是一个关键优势。", "problem": "一个整数系数多项式可以在一个整数点上求值，而无需任何浮点运算，只需通过适当地对各项重新分组，使得每一步仅需要加法和乘法。考虑多项式\n$$\np(x) = 3x^{5} - 11x^{4} + x^{3} + 39x^{2} - 30x - 24\n$$\n以及整数候选根 $r = 2$。\n\n任务：\n1) 从多项式作为带系数的单项式的有限和的定义出发，仅使用加法和乘法的分配律与结合律，推导出一个嵌套求值程序。该程序通过一系列从最高次系数到常数项的“先乘后加”步骤来计算 $p(r)$。你的推导必须从一般形式 $p(x) = \\sum_{k=0}^{n} a_{k} x^{k}$ 开始，且不得预设任何现成的算法。\n2) 证明：如果所有系数 $a_{k}$ 均为整数且 $r$ 为整数，则你推导的嵌套程序所产生的每一个中间值也都是整数。你的证明必须仅依赖于整数集在加法和乘法运算下的封闭性。\n3) 将你推导的程序应用于给定的 $p(x)$ 和 $r$，仅使用整数运算来计算 $p(x)$ 除以 $x - r$ 的余数。将此余数报告为单个整数。不要使用任何浮点运算，也不要四舍五入；答案是精确的。", "solution": "### 任务 1：嵌套求值程序的推导\n\n设 $p(x)$ 是一个 $n$ 次多项式，其系数为 $a_k$，$k=0, 1, \\dots, n$。多项式的标准定义是单项式的有限和：\n$$\np(x) = \\sum_{k=0}^{n} a_{k} x^{k} = a_n x^n + a_{n-1} x^{n-1} + \\dots + a_1 x + a_0\n$$\n为了仅使用分配律和结合律推导出一个嵌套求值程序，我们可以有策略地、顺序地提出变量 $x$。一个关键的洞见是，霍纳法更自然地可以表示为一个递推关系。\n\n我们首先对 $p(x)$ 的项进行重新组合，从除常数项 $a_0$ 以外的所有项中提出 $x$：\n$$\np(x) = (a_n x^{n-1} + a_{n-1} x^{n-2} + \\dots + a_2 x + a_1)x + a_0\n$$\n这是分配律的直接应用。括号内的表达式本身是一个 $n-1$ 次多项式。我们可以重复这个过程。让我们从新的括号表达式中提出 $x$，不包括其常数项 $a_1$：\n$$\np(x) = ((a_n x^{n-2} + a_{n-1} x^{n-3} + \\dots + a_2)x + a_1)x + a_0\n$$\n继续这个过程，直到我们只剩下最高次系数 $a_n$，我们就得到了多项式的完全嵌套形式：\n$$\np(x) = (\\dots((a_n x + a_{n-1})x + a_{n-2})x + \\dots + a_1)x + a_0\n$$\n这种嵌套结构启发了一个顺序计算程序。为将其形式化，我们定义一个中间值序列，记为 $y_k$，这些值对应从最内层向外求值的嵌套括号的值。\n\n设待计算的值为 $p(r)$。我们如下定义该序列：\n1. 从最高次项的系数开始：\n   $$y_n = a_n$$\n2. 通过将前一个结果乘以 $r$ 并加上按降序排列的下一个系数，递归地计算下一个值：\n   $$y_{n-1} = y_n \\cdot r + a_{n-1} = a_n r + a_{n-1}$$\n3. 继续这个过程：\n   $$y_{n-2} = y_{n-1} \\cdot r + a_{n-2} = (a_n r + a_{n-1})r + a_{n-2} = a_n r^2 + a_{n-1} r + a_{n-2}$$\n在此序列中，对于从 $n-1$ 到 $0$ 的 $k$，一般步骤是：\n$$\ny_k = y_{k+1} \\cdot r + a_k\n$$\n通过反复代入 $y_{k+1}$ 的定义，我们可以看到最终值 $y_0$ 对应于在 $r$ 点求值的完整多项式：\n\\begin{align*} y_0 = y_1 \\cdot r + a_0 \\\\ = (y_2 \\cdot r + a_1)r + a_0 \\\\ = (\\dots(y_n \\cdot r + a_{n-1})r + \\dots + a_1)r + a_0 \\\\ = (\\dots((a_n)r + a_{n-1})r + \\dots + a_1)r + a_0 \\\\ = a_n r^n + a_{n-1} r^{n-1} + \\dots + a_1 r + a_0 \\\\ = p(r) \\end{align*}\n因此，计算 $p(r)$ 的嵌套求值程序如下：\n1. 初始化一个结果变量（我们称之为 $y$），其值为最高次系数 $a_n$。\n2. 从 $k = n-1$ 向下迭代到 $0$。在每一步中，使用规则 $y \\leftarrow y \\cdot r + a_k$ 来更新 $y$。\n3. 循环完成后（即在 $k=0$ 的步骤之后），$y$ 的最终值就是 $p(r)$。\n此程序如要求一样，仅使用了一系列“先乘后加”的步骤。\n\n### 任务 2：整数封闭性证明\n\n我们要证明，如果所有系数 $a_k$ 都是整数（$a_k \\in \\mathbb{Z}$），并且求值点 $r$ 是一个整数（$r \\in \\mathbb{Z}$），那么由任务 1 中推导的程序生成的每个中间值 $y_k$ 也都是整数。该证明依赖于整数集 $\\mathbb{Z}$ 在加法和乘法下的封闭性。\n\n该程序由以下递推关系定义：\n$$\ny_n = a_n\n$$\n$$\ny_k = y_{k+1} \\cdot r + a_k \\quad \\text{for } k = n-1, n-2, \\dots, 0\n$$\n\n我们将对计算序列使用归纳法进行证明，从 $y_n$ 开始，向下进行到 $y_0$。\n\n**基础情形：** 计算的第一个中间值是 $y_n$。根据程序，$y_n = a_n$。根据问题的假设，所有系数 $a_k$ 都是整数。因此，$a_n \\in \\mathbb{Z}$，这意味着 $y_n \\in \\mathbb{Z}$。基础情形成立。\n\n**归纳假设：** 假设对于某个整数 $j$（满足 $0  j \\le n$），中间值 $y_j$ 是一个整数，即 $y_j \\in \\mathbb{Z}$。\n\n**归纳步骤：** 我们必须证明序列中的下一个值 $y_{j-1}$ 也是一个整数。程序将 $y_{j-1}$ 定义为：\n$$\ny_{j-1} = y_j \\cdot r + a_{j-1}\n$$\n我们分析等式右边的各项：\n1. 根据归纳假设，$y_j$ 是一个整数（$y_j \\in \\mathbb{Z}$）。\n2. 根据问题的假设，$r$ 是一个整数（$r \\in \\mathbb{Z}$）。\n3. 整数集 $\\mathbb{Z}$ 在乘法下是封闭的。这意味着任意两个整数的乘积是一个整数。因此，项 $y_j \\cdot r$ 是一个整数。\n4. 根据问题的假设，系数 $a_{j-1}$ 是一个整数（$a_{j-1} \\in \\mathbb{Z}$）。\n5. 整数集 $\\mathbb{Z}$ 在加法下是封闭的。这意味着任意两个整数的和是一个整数。因此，和 $(y_j \\cdot r) + a_{j-1}$ 是一个整数。\n\n这意味着 $y_{j-1} \\in \\mathbb{Z}$。\n\n**结论：** 由于基础情形（$y_n \\in \\mathbb{Z}$）为真，且归纳步骤正确地证明了如果 $y_j \\in \\mathbb{Z}$ 则 $y_{j-1} \\in \\mathbb{Z}$，因此根据数学归纳法原理，所有中间值 $y_k$（对于 $k = n, n-1, \\dots, 0$）都是整数。\n\n### 任务 3：应用于给定多项式\n\n我们被要求应用推导出的程序来计算 $p(x)$ 除以 $x-r$ 的余数。根据多项式余数定理，这个余数等于 $p(r)$。\n\n给定的多项式为：\n$$\np(x) = 3x^{5} - 11x^{4} + 1x^{3} + 39x^{2} - 30x - 24\n$$\n系数从最高次到最低次分别为：\n$a_5 = 3$\n$a_4 = -11$\n$a_3 = 1$\n$a_2 = 39$\n$a_1 = -30$\n$a_0 = -24$\n\n整数候选根为 $r = 2$。\n\n我们现在应用该程序，仅使用整数运算计算中间值序列 $y_k$。\n\n第 1 步：用 $a_5$ 初始化。\n$y_5 = a_5 = 3$\n\n第 2 步：计算 $y_4$。\n$y_4 = y_5 \\cdot r + a_4 = 3 \\cdot 2 + (-11) = 6 - 11 = -5$\n\n第 3 步：计算 $y_3$。\n$y_3 = y_4 \\cdot r + a_3 = (-5) \\cdot 2 + 1 = -10 + 1 = -9$\n\n第 4 步：计算 $y_2$。\n$y_2 = y_3 \\cdot r + a_2 = (-9) \\cdot 2 + 39 = -18 + 39 = 21$\n\n第 5 步：计算 $y_1$。\n$y_1 = y_2 \\cdot r + a_1 = 21 \\cdot 2 + (-30) = 42 - 30 = 12$\n\n第 6 步：计算 $y_0$。\n$y_0 = y_1 \\cdot r + a_0 = 12 \\cdot 2 + (-24) = 24 - 24 = 0$\n\n最终值为 $y_0 = 0$。这个值是 $p(2)$，即 $p(x)$ 除以 $x-2$ 的余数。所有的中间值（$-5$、$-9$、$21$、$12$）都是整数，这与任务 2 中的证明预测的一致。\n\n余数为 $0$。", "answer": "$$\n\\boxed{0}\n$$", "id": "3239198"}, {"introduction": "现在，让我们将霍纳法推广到更高维度来扩展我们的工具箱，这在科学建模中是一个常见需求。本练习挑战你通过巧妙地重复应用一维方法来计算一个二元多项式的值 [@problem_id:3239322]。实现这种嵌套方案将揭示霍纳法作为科学计算中一个基本构建块的真正通用性。", "problem": "给定一个由索引到系数的映射定义的二元多项式。设 $P(x,y)$ 为有限和\n$$\nP(x,y) = \\sum_{i=0}^{m} \\sum_{j=0}^{n} a_{ij} \\, x^{i} y^{j},\n$$\n其中 $a_{ij} \\in \\mathbb{R}$ 且 $(m,n)$ 为非负整数。请仅从多项式的定义和为避免显式求幂而采用的重复因式分解原理出发，推导一种算法来计算 $P(x,y)$。该算法首先对一个变量应用单变量线性时间方案以获得中间系数，然后对另一个变量应用相同的方案。接着，将此算法实现为一个程序，用以计算 $P(x,y)$ 在若干指定输入下的值。\n\n要求与约束：\n- 你的推导必须基于多项式的基本定义以及通过对同类幂次项进行分组以避免通过重复乘法显式计算 $x^i$ 和 $y^j$ 的思想。你必须这样组织计算：首先将 $P(x,y)$ 视为一个变量的多项式和，其系数是另一个变量的多项式，然后按仅使用加法和乘法的顺序计算这些多项式。\n- 实现一个函数，该函数接受一个实系数的矩形数组 $(a_{ij})$，并遵循行索引 $i$ 对应于 $x$ 的幂、列索引 $j$ 对应于 $y$ 的幂的约定。这意味着位于第 $i$ 行和第 $j$ 列的条目等于 $a_{ij}$，即 $x^{i} y^{j}$ 的系数。\n- 通过避免对 $x$ 或 $y$ 进行显式求幂，并以嵌套求值顺序仅使用加法和乘法，来确保数值稳定性。\n- 你的实现必须采用一种嵌套求值顺序，该顺序首先对每个固定的 $i$ 在 $y$ 上进行求值以产生中间值 $b_i(y)$，然后使用这些 $b_i(y)$ 作为系数在 $x$ 上进行求值。\n\n测试套件：\n- 使用以下五个测试用例。对于每个测试用例，都指定了系数矩阵以及求值点 $(x,y)$。此处，矩阵按行给出。\n  - 测试用例 1：\n    $A^{(1)} = \\begin{bmatrix} 3  4  0 \\\\ 2  5  0 \\\\ 0  0  1 \\end{bmatrix}$，$x^{(1)} = 1.5$，$y^{(1)} = -0.75$。\n  - 测试用例 2：\n    $A^{(2)} = \\begin{bmatrix} 0  0  0 \\\\ 0  0  0 \\end{bmatrix}$，$x^{(2)} = -2.3$，$y^{(2)} = 4.1$。\n  - 测试用例 3：\n    $A^{(3)} = \\begin{bmatrix} 1  2  3 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix}$，$x^{(3)} = 0$，$y^{(3)} = 2$。\n  - 测试用例 4：\n    $A^{(4)} = \\begin{bmatrix} 1  -1 \\\\ 2  0.5 \\\\ -3  4 \\end{bmatrix}$，$x^{(4)} = 2$，$y^{(4)} = 0$。\n  - 测试用例 5：\n    $A^{(5)} = \\begin{bmatrix} 0.5  -1  0.25  -0.125 \\\\ 2  0  -0.5  0 \\\\ 0  1.5  0  -0.25 \\\\ -1  0  0  0.0625 \\end{bmatrix}$，$x^{(5)} = 0.75$，$y^{(5)} = -1.2$。\n\n输入和输出规范：\n- 无需读取输入。将上述测试套件硬编码在你的程序中。\n- 你的程序必须使用所描述的嵌套求值顺序为上述每个测试用例计算 $P(x,y)$ 的值。\n- 最终输出格式：你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。使用标准的四舍五入将每个数值结果保留到 $10$ 位小数，如果出现平分情况（即恰好为5），则舍入到最近的可表示的偶数小数。例如，格式必须为 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_k$ 都被舍入到 $10$ 位小数。\n- 此问题不涉及物理单位和角度。\n\n交付物：\n- 提供一个完整、可运行的程序，该程序实现所描述的算法，并以上述确切格式打印测试套件的结果。打印的最后一行必须是且仅是所描述的单一列表，不得包含任何附加文本。", "solution": "该问题要求推导并实现一个用于计算二元多项式 $P(x,y)$ 的高效算法，其定义为：\n$$\nP(x,y) = \\sum_{i=0}^{m} \\sum_{j=0}^{n} a_{ij} \\, x^{i} y^{j}\n$$\n推导过程必须基于重复因式分解的原理，类似于单变量的霍纳法（Horner's method），以避免高昂且可能不稳定的显式计算 $x^i$ 和 $y^j$ 的幂。该算法必须遵循一个特定的嵌套求值顺序：首先对 $y$ 求值，然后对 $x$ 求值。\n\n让我们从给定的多项式定义开始。核心思想是改变求和顺序并对项进行分组。问题指定将 $P(x,y)$ 视为一个关于某个变量（比如 $x$）的多项式，而其系数本身是关于另一个变量 $y$ 的多项式。我们可以通过提取 $x$ 的幂来重写这个双重求和：\n$$\nP(x,y) = \\sum_{i=0}^{m} \\left( \\sum_{j=0}^{n} a_{ij} y^j \\right) x^i\n$$\n这个表达式将 $P(x,y)$ 表示为一个关于变量 $x$ 的多项式。我们将括号中的项定义为 $b_i(y)$，它对于一个固定的索引 $i$ 来说是一个关于 $y$ 的多项式：\n$$\nb_i(y) = \\sum_{j=0}^{n} a_{ij} y^j = a_{i0} + a_{i1}y + a_{i2}y^2 + \\dots + a_{in}y^n\n$$\n对于从 $0$ 到 $m$ 的每个整数 $i$，$b_i(y)$ 都是一个关于 $y$ 的单变量多项式。$b_i(y)$ 的系数由系数矩阵 $A$ 的第 $i$ 行给出，即 $(a_{i0}, a_{i1}, \\dots, a_{in})$。\n\n有了这个定义，原始多项式 $P(x,y)$ 可以表示为：\n$$\nP(x,y) = \\sum_{i=0}^{m} b_i(y) x^i = b_0(y) + b_1(y)x^1 + b_2(y)x^2 + \\dots + b_m(y)x^m\n$$\n这种结构表明，对于给定的点 $(x,y)$，求值过程分为两个阶段。\n\n**阶段 1：计算中间系数**\n\n首先，对于给定的 $y$ 值，我们必须计算系数 $b_0(y), b_1(y), \\dots, b_m(y)$ 的数值。每个 $b_i(y)$ 都是一个单变量多项式，可以使用单变量霍纳法高效地求值。霍纳法（也称为嵌套乘法）通过将其因式分解来计算多项式 $Q(z) = c_k z^k + c_{k-1} z^{k-1} + \\dots + c_1 z + c_0$：\n$$\nQ(z) = c_0 + z(c_1 + z(c_2 + \\dots + z(c_{k-1} + c_k z)\\dots))\n$$\n在算法上，这是通过将结果初始化为最高次系数 $c_k$ 并向下迭代来计算的：\n`结果` $\\leftarrow$ $c_k$\n对于从 $k-1$ 到 $0$ 的 $l$：\n`结果` $\\leftarrow$ `结果` $\\times z + c_l$\n\n对于我们的问题，为了计算 $b_i(y) = \\sum_{j=0}^{n} a_{ij} y^j$，我们应用此方法，变量为 $y$，系数为 $(a_{i0}, a_{i1}, \\dots, a_{in})$。$y$ 的降幂系数为 $(a_{in}, a_{i,n-1}, \\dots, a_{i0})$。设 $B_i$ 表示计算出的数值 $b_i(y)$。我们对从 $0$ 到 $m$ 的每个 $i$ 执行此求值，得到一组中间数值系数 $\\{B_0, B_1, \\dots, B_m\\}$。\n\n**阶段 2：最终多项式求值**\n\n一旦计算出中间系数 $B_i = b_i(y)$，问题就简化为计算一个新的关于 $x$ 的单变量多项式：\n$$\nP(x,y) = \\sum_{i=0}^{m} B_i x^i = B_0 + B_1 x + B_2 x^2 + \\dots + B_m x^m\n$$\n我们再次应用霍纳法，这次是针对变量 $x$ 和刚刚计算出的系数 $\\{B_0, B_1, \\dots, B_m\\}$。对应于 $x$ 降幂的系数是 $(B_m, B_{m-1}, \\dots, B_0)$。求值过程如下：\n`最终结果` $\\leftarrow$ $B_m$\n对于从 $m-1$ 到 $0$ 的 $i$：\n`最终结果` $\\leftarrow$ `最终结果` $\\times x + B_i$\n\n`最终结果` 的最终值就是 $P(x,y)$ 的值。\n\n**算法总结**\n\n遵循指定嵌套求值顺序的完整算法如下：\n\n1.  输入：一个 $(m+1) \\times (n+1)$ 的系数矩阵 $A$，其中 $A_{ij} = a_{ij}$，以及一个点 $(x,y)$。\n2.  初始化一个大小为 $m+1$ 的数组 `B` 来存储中间系数。\n3.  对于从 $0$ 到 $m$ 的每个行索引 $i$：\n    a. 提取 $A$ 的第 $i$ 行，该行包含多项式 $b_i(y)$ 的系数 $(a_{i0}, a_{i1}, \\dots, a_{in})$。\n    b. 使用霍纳法在给定的 $y$ 处计算 $b_i(y)$ 的值。\n    c. 将结果存储在 `B[i]` 中。\n4.  数组 `B` 现在持有关于 $x$ 的多项式的数值系数 $(B_0, B_1, \\dots, B_m)$。\n5.  使用霍纳法在给定的 $x$ 处计算多项式 $\\sum_{i=0}^{m} B_i x^i$ 的值。\n6.  第二次求值的结果就是 $P(x,y)$ 的最终值。\n\n此过程仅以嵌套方式使用加法和乘法，完全避免了显式求幂，从而确保了更好的数值稳定性和效率，其时间复杂度为 $O(mn)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef evaluate_bivariate_poly(A, x, y):\n    \"\"\"\n    Evaluates a bivariate polynomial P(x, y) using a nested Horner's scheme.\n\n    The polynomial is defined as P(x,y) = sum_{i=0 to m} sum_{j=0 to n} a_ij * x^i * y^j.\n    The coefficient a_ij is located at A[i, j].\n\n    The evaluation first computes intermediate coefficients B_i(y) for each power of x,\n    and then evaluates the final polynomial in x with these coefficients.\n\n    Args:\n        A (np.ndarray): A 2D numpy array of shape (m+1, n+1) containing the\n                        coefficients a_ij. A[i, j] is the coefficient of x^i * y^j.\n        x (float): The value of x at which to evaluate the polynomial.\n        y (float): The value of y at which to evaluate the polynomial.\n\n    Returns:\n        float: The value of P(x, y).\n    \"\"\"\n    # The number of rows (m+1) corresponds to the degree of x plus 1.\n    # The number of columns (n+1) corresponds to the degree of y plus 1.\n    m_plus_1, n_plus_1 = A.shape\n\n    # Stage 1: Evaluate intermediate polynomials in y for each row i.\n    # Each row A[i, :] contains the coefficients (a_i0, a_i1, ..., a_in)\n    # for a polynomial in y: b_i(y) = a_i0 + a_i1*y + ... + a_in*y^n.\n    # np.polyval expects coefficients for decreasing powers, so we reverse each row.\n    B = []\n    for i in range(m_plus_1):\n        row_coeffs = A[i, :]\n        # Coefficients for np.polyval: [a_in, a_i(n-1), ..., a_i0]\n        b_i_y = np.polyval(row_coeffs[::-1], y)\n        B.append(b_i_y)\n\n    # Stage 2: Evaluate the final polynomial in x.\n    # The coefficients are the computed B_i values: [B_0, B_1, ..., B_m].\n    # This corresponds to the polynomial P(x,y) = B_0 + B_1*x + ... + B_m*x^m.\n    # np.polyval expects coefficients for decreasing powers of x, so we reverse B.\n    # Coefficients for np.polyval: [B_m, B_(m-1), ..., B_0]\n    final_value = np.polyval(B[::-1], x)\n    \n    return final_value\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the evaluation for each case, and prints\n    the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (np.array([[3, 4, 0], [2, 5, 0], [0, 0, 1]], dtype=float), 1.5, -0.75),\n        (np.array([[0, 0, 0], [0, 0, 0]], dtype=float), -2.3, 4.1),\n        (np.array([[1, 2, 3], [0, 0, 0], [0, 0, 0]], dtype=float), 0, 2),\n        (np.array([[1, -1], [2, 0.5], [-3, 4]], dtype=float), 2, 0),\n        (np.array([\n            [0.5, -1, 0.25, -0.125],\n            [2, 0, -0.5, 0],\n            [0, 1.5, 0, -0.25],\n            [-1, 0, 0, 0.0625]\n        ], dtype=float), 0.75, -1.2)\n    ]\n\n    results = []\n    for A, x, y in test_cases:\n        result = evaluate_bivariate_poly(A, x, y)\n        # Round the result to 10 decimal places.\n        rounded_result = round(result, 10)\n        results.append(str(rounded_result))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver.\nsolve()\n```", "id": "3239322"}]}