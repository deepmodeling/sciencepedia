{"hands_on_practices": [{"introduction": "本练习旨在探索割线法的一个关键优势：它能够在牛顿法因导数为零而失效的情况下继续求解。通过构造一个具体的函数 [@problem_id:3271725]，你将亲手计算并理解割线法如何通过近似导数来绕开牛顿法的“陷阱”，从而体会其在特定场景下的稳健性。", "problem": "要求您构建并分析一个标量非线性例子，用以区分割线法与牛顿法的鲁棒性。在具有实根的光滑函数 $f:\\mathbb{R}\\to\\mathbb{R}$ 的设定下进行。\n\n任务：\n- 从某点线性化的一阶泰勒展开定义出发，推导定义牛顿法的迭代式，并解释为何当当前迭代点的导数为零时，该迭代不是良定义的。\n- 设计一个具有单根 $r$ 的特定函数 $f(x)$，使得存在一点 $x_{0}$ 满足 $f^{\\prime}(x_{0})=0$ 和 $f(x_{0})\\neq 0$，从而若从 $x_{0}$ 开始，牛顿法会失败。然后，论证割线法仍然可以通过两个初始点 $x_{0}$ 和 $x_{1}$ 形成，方法是通过有限差分来近似导数，并在 $x_{1}$ 处应用相同的线性化逻辑。\n- 对于您的具体选择，取 $f(x)=x^{3}+1$，选择 $x_{0}=0$ 和 $x_{1}=-2$。仅使用上述构建原理，精确计算下一个割线法迭代点 $x_{2}$。\n- 为您的例子提供一个简要的、基于基本原理的收敛性分析，解释为何当按规定由 $x_{0}$ 和 $x_{1}$ 初始化时，割线法预期会收敛到 $f(x)=0$ 的唯一单根 $r$。您的解释应基于 $f$ 的单调性/凹凸性以及割线法更新的几何意义，并应说明在光滑性假设下，单根附近的局部收敛阶。\n\n仅报告 $x_{2}$ 的精确值作为您的最终答案。无需四舍五入。", "solution": "该问题要求对割线法进行全面分析，并使用一个特定的非线性标量例子将其与牛顿法进行对比。任务涉及推导、具体计算和收敛性分析。\n\n首先，我们从一阶泰勒展开推导牛顿法。对于一个光滑函数 $f:\\mathbb{R}\\to\\mathbb{R}$，其在点 $x_k$ 附近的线性化由一阶泰勒多项式给出：\n$$L_k(x) = f(x_k) + f'(x_k)(x - x_k)$$\n牛顿法通过求该线性近似的根来确定下一个迭代点 $x_{k+1}$，即求解 $L_k(x_{k+1}) = 0$。\n$$0 = f(x_k) + f'(x_k)(x_{k+1} - x_k)$$\n假设 $f'(x_k) \\neq 0$，我们可以解出 $x_{k+1}$：\n$$-f(x_k) = f'(x_k)(x_{k+1} - x_k)$$\n$$x_{k+1} = x_k - \\frac{f(x_k)}{f'(x_k)}$$\n这就是牛顿法的迭代公式。如果在某个迭代点 $x_k$ 处，导数 $f'(x_k)$ 为零，则该迭代不是良定义的。在这种情况下，更新项的分母变为零，导致除零错误，方法无法产生下一个迭代点。从几何上看，如果 $f'(x_k) = 0$ 且 $f(x_k) \\neq 0$，则函数 $f$ 在点 $(x_k, f(x_k))$ 处的切线是水平的，永不与 x 轴相交，因此无法提供根的下一个近似值。\n\n接下来，我们按要求设计一个特定函数。我们使用给定的函数 $f(x) = x^3 + 1$。该函数是光滑的（无限可微）。通过求解 $f(x) = 0$ 可以找到其唯一的实根，即 $x^3 = -1$，所以根为 $r = -1$。为了检查它是否为单根，我们计算导数：$f'(x) = 3x^2$。在根处，$f'(-1) = 3(-1)^2 = 3 \\neq 0$，所以 $r=-1$ 确实是一个单根。\n我们需要找到一个点 $x_0$ 使得 $f'(x_0) = 0$ 但 $f(x_0) \\neq 0$。我们令 $f'(x_0) = 3x_0^2 = 0$，解得 $x_0 = 0$。在该点，函数值为 $f(x_0) = f(0) = 0^3 + 1 = 1 \\neq 0$。因此，如果牛顿法从 $x_0 = 0$ 开始初始化，它会因为 $f'(0) = 0$ 而立即失败。\n\n割线法通过不要求解析导数来规避此问题。它基于相同的线性化逻辑，但使用当前迭代点 $x_k$ 和前一个迭代点 $x_{k-1}$ 之间的有限差分（割线的斜率）来近似导数 $f'(x_k)$：\n$$f'(x_k) \\approx \\frac{f(x_k) - f(x_{k-1})}{x_k - x_{k-1}}$$\n将此近似代入牛顿法的公式中，得到割线法的迭代式：\n$$x_{k+1} = x_k - \\frac{f(x_k)}{\\frac{f(x_k) - f(x_{k-1})}{x_k - x_{k-1}}} = x_k - f(x_k) \\frac{x_k - x_{k-1}}{f(x_k) - f(x_{k-1})}$$\n只要 $f(x_k) \\neq f(x_{k-1})$，该公式就是良定义的。对于给定的问题，尽管 $f'(x_0) = 0$，割线法仍然可以从初始点 $x_0=0$ 和 $x_1=-2$ 开始进行，因为 $f(x_0)=1$ 和 $f(x_1)=(-2)^3+1=-7$ 不相等。\n\n我们现在用初始点 $x_0 = 0$ 和 $x_1 = -2$ 计算函数 $f(x) = x^3 + 1$ 的下一个割线法迭代点 $x_2$。$x_2$ 的公式通过在通用公式中设置 $k=1$ 得到：\n$$x_2 = x_1 - f(x_1) \\frac{x_1 - x_0}{f(x_1) - f(x_0)}$$\n首先，我们计算初始点处的函数值：\n$$f(x_0) = f(0) = 0^3 + 1 = 1$$\n$$f(x_1) = f(-2) = (-2)^3 + 1 = -8 + 1 = -7$$\n现在我们将这些值代入 $x_2$ 的公式中：\n$$x_2 = -2 - (-7) \\frac{-2 - 0}{-7 - 1}$$\n$$x_2 = -2 + 7 \\frac{-2}{-8}$$\n$$x_2 = -2 + 7 \\left(\\frac{1}{4}\\right)$$\n$$x_2 = -2 + \\frac{7}{4} = -\\frac{8}{4} + \\frac{7}{4} = -\\frac{1}{4}$$\n下一个迭代点的精确值是 $x_2 = -1/4$。\n\n最后，我们为此例提供一个基于基本原理的收敛性分析。函数为 $f(x) = x^3+1$，根为 $r=-1$。一阶和二阶导数分别为 $f'(x) = 3x^2$ 和 $f''(x) = 6x$。\n函数 $f(x)$ 对所有 $x \\in \\mathbb{R}$ 都是严格单调递增的，因为 $f'(x) \\ge 0$ 且仅在孤立点 $x=0$ 处 $f'(x)=0$。\n函数的凹凸性在 $x=0$ 处改变。对于 $x  0$，$f''(x)  0$，所以函数是下凹的。对于 $x  0$，$f''(x)  0$，所以函数是上凸的。根 $r=-1$ 位于函数下凹的区域。\n\n我们的初始迭代点是 $x_0 = 0$ 和 $x_1 = -2$。根 $r=-1$ 位于这两点之间。函数值为 $f(0)=10$ 和 $f(-2)=-70$。\n计算出的第一个迭代点是 $x_2 = -1/4$。在该点，$f(-1/4) = (-1/4)^3+1 = 63/64  0$。\n下一次迭代将使用点 $x_1 = -2$ 和 $x_2 = -1/4$。根 $r=-1$ 再次被这两个最新的迭代点所包围。\n随后的迭代点 $x_3$ 由通过 $(-2, -7)$ 和 $(-1/4, 63/64)$ 的割线生成。因为根被包围，所以 $x_3$ 必定位于 $x_1$ 和 $x_2$ 之间。计算得出 $x_3 = -34/73 \\approx -0.466$。\n现在，最新的两个迭代点是 $x_2 = -1/4$ 和 $x_3 \\approx -0.466$。这两个点都在根 $r = -1$ 的右侧。\n这表明割线法与试位法 (regula falsi) 不同，不一定能保持对根的包围。\n我们来分析当两个连续迭代点，比如说 $x_k$ 和 $x_{k-1}$ (满足 $r  x_k  x_{k-1}$) 位于根的同一侧时的行为。在我们的例子中，这种情况发生在 $x_2$ 和 $x_3$（为下一步重新标记后），它们位于区间 $(-1, 0)$ 内。在此区间内，$f(x)$ 是单调递增且下凹的。\n从几何上看，对于一个下凹函数，连接其图像上两点的任意割线段都将位于这两点之间的函数图像下方。新的迭代点 $x_{k+1}$ 是这条割线的 x 轴截距。由于割线在曲线下方，而曲线本身在最左侧点 $(x_k, f(x_k))$ 处的切线下方，因此割线比 $x_k$ 处的切线更“平坦”。对于一个单调递增且下凹的函数，这会导致“过冲”，即下一个迭代点 $x_{k+1}$ 将位于根的左侧。\n这会产生一种振荡模式，迭代点倾向于在根的两侧交替出现。尽管存在振荡，只要初始点足够接近根（本例中即是如此），就可以证明误差的绝对值 $|x_k - r|$ 在每一步都会减小。迭代序列收敛于根 $r=-1$。\n通常，对于具有单根的 $C^2$ 函数，割线法的局部收敛阶为 $\\phi = \\frac{1+\\sqrt{5}}{2} \\approx 1.618$，这是超线性的，但低于牛顿法的二次收敛阶。", "answer": "$$\\boxed{-\\frac{1}{4}}$$", "id": "3271725"}, {"introduction": "为了建立对算法局限性的全面认识，下一个练习将引导你探索割线法的一种独特失效模式。当两个初始点对应的函数值恰好相等时，割线法将无法生成下一个迭代点 [@problem_id:3271767]。这个思想实验旨在揭示割线法的特定弱点，并与牛顿法的行为进行对比，从而加深你对不同求根方法适用范围的理解。", "problem": "考虑通过线性化原理构造更新的迭代求根方法。一种方法在单点使用局部微分近似，另一种方法使用穿过函数图像上两个不同点的割线。对于本问题，我们将割线法的失败定义为：由于构造的割线是水平的，导致更新未定义的情况。这种情况恰好在迭代步骤中使用的两个函数值相等时发生，从而导致除以零。同时，我们将牛顿法的收敛定义为：在通常的光滑性假设下，从给定的初始点开始，迭代序列趋近于一个真根。\n\n您的任务是确定一个选项，该选项提供一个函数 $f(x)$ 和初始点 $x_0, x_1$，使得割线法在第一次尝试更新时失败，但从 $x_1$ 开始的牛顿法收敛到一个根。\n\n哪个选项满足这些条件？\n\nA. $f(x) = (x - 1)^2$，其中 $x_0 = 0$ 且 $x_1 = 2$。\n\nB. $f(x) = x^{1/3}$，其中 $x_0 = -1$ 且 $x_1 = 1$。\n\nC. $f(x) = x^3 - x$，其中 $x_0 = 0$ 且 $x_1 = 2$。\n\nD. $f(x) = \\cos x - x$，其中 $x_0 = 0$ 且 $x_1 = \\pi$。", "solution": "首先验证问题陈述。\n\n### 步骤 1：提取已知条件\n- **方法 1 (牛顿法):** 一种在单点使用局部微分近似的迭代求根方法。\n- **方法 2 (割线法):** 一种使用穿过两个不同点的割线的迭代求根方法。\n- **割线法失败的定义:** 由于构造的割线是水平的，更新未定义。当用于更新的两点的函数值相等时，即 $f(x_k) = f(x_{k-1})$，这种情况就会发生，导致更新公式中出现除以零。\n- **牛顿法收敛的定义:** 假设有足够的平滑度和合适的起始点，迭代序列会趋近于一个真根。\n- **任务:** 确定一个提供函数 $f(x)$ 和初始点 $x_0, x_1$ 的选项，使得：\n    1. 割线法在第一次尝试更新时（使用点 $x_0$ 和 $x_1$）失败。\n    2. 从 $x_1$ 开始的牛顿法收敛到 $f(x)$ 的一个根。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据:** 该问题基于数值分析中公认的牛顿法和割线法。割线法失败（除以零）和牛顿法收敛的定义都是标准的。该问题在科学和数学上是合理的。\n- **适定性:** 任务定义清晰。对于每个选项，必须检查两个特定条件，这些条件可以通过直接计算来验证。这种结构可以唯一且稳定地确定正确答案。\n- **客观性:** 问题使用精确、客观的数学语言陈述。这些条件是定量的，不存在解释的空间。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。这是一个比较两种基本求根算法在特定初始条件下行为的标准练习。现在开始求解过程。\n\n### 解题推导\n\n割线法使用以下递推关系生成一个迭代序列来寻找 $f(x)$ 的根：\n$$x_{k+1} = x_k - f(x_k) \\frac{x_k - x_{k-1}}{f(x_k) - f(x_{k-1})}$$\n从 $x_0$ 和 $x_1$ 求 $x_2$ 的第一次更新由下式给出：\n$$x_2 = x_1 - f(x_1) \\frac{x_1 - x_0}{f(x_1) - f(x_0)}$$\n根据问题的定义，如果分母为零，即 $f(x_1) - f(x_0) = 0$，或 $f(x_1) = f(x_0)$，则该方法在第一步失败。\n\n牛顿法使用以下递推关系生成一个迭代序列：\n$$x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}$$\n我们需要检查当初始猜测值为 $x_1$ 时，此方法是否收敛到一个根。\n\n我们现在将分析每个选项。\n\n**A. $f(x) = (x - 1)^2$，其中 $x_0 = 0$ 且 $x_1 = 2$。**\n\n1.  **割线法失败：** 我们在初始点 $x_0 = 0$ 和 $x_1 = 2$ 处计算函数值。\n    $$f(x_0) = f(0) = (0 - 1)^2 = 1$$\n    $$f(x_1) = f(2) = (2 - 1)^2 = 1$$\n    由于 $f(x_0) = f(x_1)$，割线法更新公式的分母 $f(x_1) - f(x_0)$ 为 $1 - 1 = 0$。割线是水平的，该方法在第一步失败。此条件满足。\n\n2.  **牛顿法收敛：** 我们从 $x_{_N,0} = x_1 = 2$ 开始牛顿法。函数的导数是 $f'(x) = 2(x - 1)$。$f(x)$ 的唯一根在 $x=1$。\n    牛顿迭代公式为：\n    $$x_{_{N, n+1}} = x_{_{N, n}} - \\frac{f(x_{_{N, n}})}{f'(x_{_{N, n}})} = x_{_{N, n}} - \\frac{(x_{_{N, n}} - 1)^2}{2(x_{_{N, n}} - 1)}$$\n    对于任何迭代值 $x_{_{N, n}} \\neq 1$，我们可以将其简化为：\n    $$x_{_{N, n+1}} = x_{_{N, n}} - \\frac{x_{_{N, n}} - 1}{2} = \\frac{2x_{_{N, n}} - (x_{_{N, n}} - 1)}{2} = \\frac{x_{_{N, n}} + 1}{2}$$\n    让我们计算从 $x_{_{N,0}} = 2$ 开始的前几个迭代值：\n    $$x_{_{N,1}} = \\frac{2+1}{2} = 1.5$$\n    $$x_{_{N,2}} = \\frac{1.5+1}{2} = 1.25$$\n    $$x_{_{N,3}} = \\frac{1.25+1}{2} = 1.125$$\n    第 $n$ 步的误差是 $e_n = x_{_{N, n}} - 1$。误差的递推关系是 $e_{n+1} + 1 = \\frac{(e_n + 1) + 1}{2} = \\frac{e_n}{2} + 1$，这给出 $e_{n+1} = \\frac{1}{2} e_n$。由于误差在每一步都减半，$\\lim_{n \\to \\infty} e_n = 0$，并且迭代序列 $x_{_{N, n}}$ 收敛到根 $x=1$。此条件满足。\n\n此选项满足两个条件。因此，这个选项是一个有效的解。\n\n**选项 A 的结论：正确**\n\n**B. $f(x) = x^{1/3}$，其中 $x_0 = -1$ 且 $x_1 = 1$。**\n\n1.  **割线法失败：** 我们在初始点 $x_0 = -1$ 和 $x_1 = 1$ 处计算函数值。\n    $$f(x_0) = f(-1) = (-1)^{1/3} = -1$$\n    $$f(x_1) = f(1) = (1)^{1/3} = 1$$\n    由于 $f(x_0) \\neq f(x_1)$，割线法更新的分母非零（$1 - (-1) = 2$）。割线法在第一步不失败。此条件不满足。\n\n**选项 B 的结论：不正确**\n\n**C. $f(x) = x^3 - x$，其中 $x_0 = 0$ 且 $x_1 = 2$。**\n\n1.  **割线法失败：** 我们在初始点 $x_0 = 0$ 和 $x_1 = 2$ 处计算函数值。\n    $$f(x_0) = f(0) = 0^3 - 0 = 0$$\n    $$f(x_1) = f(2) = 2^3 - 2 = 8 - 2 = 6$$\n    由于 $f(x_0) \\neq f(x_1)$，割线法更新的分母非零（$6 - 0 = 6$）。割线法在第一步不失败。此条件不满足。\n\n**选项 C 的结论：不正确**\n\n**D. $f(x) = \\cos x - x$，其中 $x_0 = 0$ 且 $x_1 = \\pi$。**\n\n1.  **割线法失败：** 我们在初始点 $x_0 = 0$ 和 $x_1 = \\pi$ 处计算函数值。\n    $$f(x_0) = f(0) = \\cos(0) - 0 = 1$$\n    $$f(x_1) = f(\\pi) = \\cos(\\pi) - \\pi = -1 - \\pi$$\n    由于 $f(x_0) \\neq f(x_1)$，割线法更新的分母非零（$(-1 - \\pi) - 1 = -2 - \\pi$）。割线法在第一步不失败。此条件不满足。\n\n**选项 D 的结论：不正确**\n\n根据分析，只有选项 A 满足所有要求条件。", "answer": "$$\\boxed{A}$$", "id": "3271767"}, {"introduction": "在掌握了割线法的基本优缺点后，我们将通过一个实际的物理模型来应用并分析它。这个练习 [@problem_id:3271741] 要求你编写代码，使用割线法求解一个热平衡方程的根，并根据迭代数据凭经验估算收敛阶。通过处理包括重根导致收敛降速的多种情况，你将把理论知识付诸实践，并对算法的实际性能有更深刻的体会。", "problem": "一个物体与其环境进行热能交换，其过程可通过非线性标量方程 $f(T) = T^4 - c_1 T - c_2 = 0$ 来建模，其中 $T$ 是绝对温度， $c_1$ 和 $c_2$ 是给定的常数。具有物理意义的平衡温度对应于方程 $f(T) = 0$ 的非平凡解 $T  0$，以开尔文为单位。目标是使用割线法数值近似这个正根，并经验性地分析其收敛行为。\n\n从基础数值分析原理出发：\n- 任务是找到一个可微函数 $f(T)$ 的单根，其中在该根附近 $f'(T)$ 不恒等于零。\n- 可以通过有限差分近似导数，并沿着此近似所建议的方向推进 $T$ 来构造寻根迭代。\n\n你的程序必须：\n1. 实现割线法来近似 $f(T) = T^4 - c_1 T - c_2$ 的正根 $T^\\ast$，给定两个初始猜测值 $T_0$ 和 $T_1$、一个绝对停止容差 $\\varepsilon$ 以及一个最大迭代次数上限 $N_{\\max}$。如果相邻迭代值之差满足 $|T_{k} - T_{k-1}| \\le \\varepsilon$ 或残差满足 $|f(T_k)| \\le \\varepsilon$，则应声明收敛。如果迭代在割线法更新中遇到除零错误，或在 $N_{\\max}$ 次迭代内未能收敛，则将根视为未定义，并为根返回一个非数值。\n2. 记录所有迭代值，并在至少有四个迭代值可用的情况下，使用最后的迭代值估算经验收敛阶 $p$。具体方法如下：设 $r$ 为最终迭代值，定义误差 $e_{n-1} = |T_{n-1} - r|$、$e_{n-2} = |T_{n-2} - r|$ 和 $e_{n-3} = |T_{n-3} - r|$。如果这些误差都严格为正，则估算\n$$\np \\approx \\frac{\\ln\\left(e_{n-1} / e_{n-2}\\right)}{\\ln\\left(e_{n-2} / e_{n-3}\\right)}.\n$$\n如果由于迭代次数不足或误差非正而无法进行估算，则为 $p$ 返回一个非数值。\n3. 对于每个测试用例，输出一个由近似根 $T^\\ast$ （以开尔文为单位）和经验收敛阶 $p$ 组成的浮点数对。\n\n使用以下测试套件来检验正确性和收敛特性：\n- 情况A（良态，系数适中）：$c_1 = 5$，$c_2 = 1$，$T_0 = 1$，$T_1 = 2$，$\\varepsilon = 10^{-12}$，$N_{\\max} = 100$。\n- 情况B（常数项较大，正根在几个开尔文左右）：$c_1 = 1$，$c_2 = 100$，$T_0 = 2.5$，$T_1 = 3.5$，$\\varepsilon = 10^{-10}$，$N_{\\max} = 100$。\n- 情况C（系数较小，正根较小）：$c_1 = 0.1$，$c_2 = 0.001$，$T_0 = 0.2$，$T_1 = 0.6$，$\\varepsilon = 10^{-12}$，$N_{\\max} = 100$。\n- 情况D（在 $T = 1$ 附近有一个重根，收敛缓慢）：$c_1 = 4$，$c_2 = -3$，$T_0 = 0.8$，$T_1 = 1.2$，$\\varepsilon = 10^{-12}$，$N_{\\max} = 200$。\n- 情况E（边界情况，在 $T = 0$ 有一个平凡根，但需求解非平凡根）：$c_1 = 10$，$c_2 = 0$，$T_0 = 0.5$，$T_1 = 4.0$，$\\varepsilon = 10^{-12}$，$N_{\\max} = 100$。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个测试用例以 $[T^\\ast,p]$ 的形式报告，且无空格。例如，输出必须如下所示：\n$[[x_1,y_1],[x_2,y_2],[x_3,y_3]]$\n其中 $x_i$ 和 $y_i$ 是浮点数。所有温度均以开尔文为单位的浮点数报告。如果某个值不可用（例如，未收敛），则将其打印为非数值标记。", "solution": "该问题要求对非线性方程 $f(T) = T^4 - c_1 T - c_2 = 0$ 的一个正根 $T^*  0$ 进行数值近似。该方程模拟了物体的热平衡温度。解将使用割线法找到，并且必须对其收敛率进行经验性分析。\n\n首先，我们验证问题陈述的有效性。\n该问题具有科学依据，因为 $T^4$ 项让人联想到关于黑体辐射的斯蒂芬-玻尔兹曼定律，使得该模型对于热交换现象在物理上是合理的。该问题是适定的；它提供了一个特定的算法（割线法）、为几个测试用例定义了明确的初始条件，以及清晰的停止和失败标准。要求估算收敛阶是数值分析中的标准练习。对函数 $f(T) = T^4 - c_1 T - c_2$ 及其导数 $f'(T) = 4T^3 - c_1$ 的分析证实，对于测试用例中给出的参数，在单根情况下存在唯一的正根。情况D被明确设计用于测试重根附近的行为，这是一个有效且有指导意义的场景。所有术语都已定义，不存在矛盾。因此，该问题被认为是有效的。\n\n任务的核心是实现割线法。这是一种迭代寻根算法，它使用一系列割线的根来更好地逼近函数 $f$ 的根。给定两个温度的初始猜测值 $T_0$ 和 $T_1$，该方法通过以下递推关系生成迭代序列 $\\{T_k\\}_{k=0}^\\infty$：\n$$\nT_{k} = T_{k-1} - f(T_{k-1}) \\frac{T_{k-1} - T_{k-2}}{f(T_{k-1}) - f(T_{k-2})}, \\quad \\text{for } k \\ge 2.\n$$\n该公式可以从几何上解释为找到穿过点 $(T_{k-2}, f(T_{k-2}))$ 和 $(T_{k-1}, f(T_{k-1}))$ 的直线的x轴截距。该方法通过将导数 $f'(T_{k-1})$ 替换为有限差分近似 $\\frac{f(T_{k-1}) - f(T_{k-2})}{T_{k-1} - T_{k-2}}$ 来近似牛顿法。\n\n迭代过程持续进行，直到满足收敛准则或发生失败条件。指定的停止准则是：\n1.  相邻迭代值之间的绝对差在给定容差 $\\varepsilon$ 之内：$|T_k - T_{k-1}| \\le \\varepsilon$。\n2.  当前迭代值处函数值的绝对值在容差之内：$|f(T_k)| \\le \\varepsilon$。\n\n在两种情况下声明失败：\n1.  迭代次数超过指定的最大值 $N_{\\max}$。\n2.  割线法公式中的分母 $f(T_{k-1}) - f(T_{k-2})$ 变为零（或在数值上与零无法区分），这将导致除零错误。\n在任一失败场景中，根被视为未定义，并用一个非数值表示。\n\n问题的第二部分是经验性地估算收敛阶 $p$。对于一个收敛阶为 $p$ 的方法，第 $k$ 次迭代的误差 $e_k = |T_k - T^*|$ 通常满足关系 $e_{k+1} \\approx \\lambda e_k^p$，其中 $\\lambda$ 为某个常数。由此，可以使用三个连续的误差来推导 $p$ 的估算值。按照规定，我们使用最终计算出的迭代值 $r$ 作为真根 $T^*$ 的近似值。误差定义为 $e_{n-1} = |T_{n-1} - r|$、$e_{n-2} = |T_{n-2} - r|$ 和 $e_{n-3} = |T_{n-3} - r|$，其中 $T_{n-1}$、$T_{n-2}$ 和 $T_{n-3}$ 是最终结果 $r$ 之前的三个迭代值。然后通过以下公式估算收敛阶 $p$：\n$$\np \\approx \\frac{\\ln\\left(e_{n-1} / e_{n-2}\\right)}{\\ln\\left(e_{n-2} / e_{n-3}\\right)}\n$$\n此计算仅在至少有四个迭代值可用（即 $T_0, T_1, T_2, T_3, \\dots$）且误差 $e_{n-1}, e_{n-2}, e_{n-3}$ 都严格为正时才执行。否则，$p$ 也被视为未定义。\n\n对于单根（其中 $f(T^*) = 0$ 但 $f'(T^*) \\ne 0$），已知割线法的收敛阶是超线性的，为 $p = \\phi = \\frac{1+\\sqrt{5}}{2} \\approx 1.618$。对于重数为 $m  1$ 的重根（其中 $f(T^*) = f'(T^*) = \\dots = f^{(m-1)}(T^*) = 0$），收敛会退化为线性的，即 $p=1$。这些理论值可作为我们经验估算的基准。对于测试用例D，其中 $c_1=4$ 和 $c_2=-3$，函数 $f(T) = T^4 - 4T + 3$ 在 $T=1$ 处有一个二重根，因为 $f(1) = 1 - 4 + 3 = 0$ 且 $f'(1) = 4(1)^3 - 4 = 0$，而 $f''(1) = 12(1)^2=12 \\ne 0$。因此，我们预期在这种情况下会观察到 $p \\approx 1$。对于所有其他情况，根是单根，我们预期 $p \\approx 1.618$。\n\n实现将包括一个函数，该函数对一组给定的参数 $(c_1, c_2, T_0, T_1, \\varepsilon, N_{\\max})$ 执行割线法迭代，记录迭代值，并在收敛时计算根 $T^*$ 和经验收敛阶 $p$。此函数将应用于五个指定的测试用例中的每一个，以生成最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the result.\n    \"\"\"\n\n    def secant_solver(c1, c2, T0, T1, tol, n_max):\n        \"\"\"\n        Implements the secant method and computes the empirical order of convergence.\n\n        Args:\n            c1 (float): Coefficient c1 in the equation f(T) = T^4 - c1*T - c2.\n            c2 (float): Coefficient c2 in the equation.\n            T0 (float): First initial guess for the root.\n            T1 (float): Second initial guess for the root.\n            tol (float): Absolute tolerance for convergence.\n            n_max (int): Maximum number of iterations.\n\n        Returns:\n            tuple: A pair (root, p) containing the approximated root and the\n                   empirical order of convergence. Returns (np.nan, np.nan) on failure.\n        \"\"\"\n\n        def f(T):\n            \"\"\"The nonlinear function for which to find the root.\"\"\"\n            return T**4 - c1 * T - c2\n\n        iterates = [T0, T1]\n        tk_minus_1 = T1\n        tk_minus_2 = T0\n        root = np.nan\n        p = np.nan\n\n        # The loop starts from k=2, but Python's range is 0-indexed.\n        # This will run n_max times for the update step.\n        for _ in range(n_max):\n            f_prev = f(tk_minus_1)\n            f_prev2 = f(tk_minus_2)\n            \n            denominator = f_prev - f_prev2\n            \n            # Check for division by zero, as specified in failure conditions.\n            if abs(denominator)  1e-15:\n                return np.nan, np.nan\n            \n            # Secant method update formula\n            tk = tk_minus_1 - f_prev * (tk_minus_1 - tk_minus_2) / denominator\n            iterates.append(tk)\n\n            # Check stopping criteria\n            if abs(tk - tk_minus_1) = tol or abs(f(tk)) = tol:\n                root = tk\n                break\n            \n            # Update values for the next iteration\n            tk_minus_2 = tk_minus_1\n            tk_minus_1 = tk\n        else:\n            # This block executes if the for loop completes without a 'break',\n            # meaning convergence was not achieved within n_max iterations.\n            return np.nan, np.nan\n\n        # If converged, try to calculate the empirical order of convergence p.\n        # This requires at least 4 iterates to have been generated (T0, T1, T2, T3).\n        if len(iterates) >= 4:\n            r = root  # Use the final iterate as the approximation for the true root.\n            \n            # The last four iterates in the list are T_{n-3}, T_{n-2}, T_{n-1}, T_n (which is r).\n            e_n_minus_1 = abs(iterates[-2] - r)\n            e_n_minus_2 = abs(iterates[-3] - r)\n            e_n_minus_3 = abs(iterates[-4] - r)\n            \n            # The formula for p is valid only if errors are strictly positive.\n            if e_n_minus_1 > 0 and e_n_minus_2 > 0 and e_n_minus_3 > 0:\n                # np.log handles arguments properly. Check denominator to avoid division by zero.\n                log_ratio_den = np.log(e_n_minus_2 / e_n_minus_3)\n                if abs(log_ratio_den) > 1e-15:\n                    log_ratio_num = np.log(e_n_minus_1 / e_n_minus_2)\n                    p = log_ratio_num / log_ratio_den\n\n        return root, p\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {'c1': 5, 'c2': 1, 'T0': 1, 'T1': 2, 'tol': 1e-12, 'n_max': 100},\n        # Case B\n        {'c1': 1, 'c2': 100, 'T0': 2.5, 'T1': 3.5, 'tol': 1e-10, 'n_max': 100},\n        # Case C\n        {'c1': 0.1, 'c2': 0.001, 'T0': 0.2, 'T1': 0.6, 'tol': 1e-12, 'n_max': 100},\n        # Case D\n        {'c1': 4, 'c2': -3, 'T0': 0.8, 'T1': 1.2, 'tol': 1e-12, 'n_max': 200},\n        # Case E\n        {'c1': 10, 'c2': 0, 'T0': 0.5, 'T1': 4.0, 'tol': 1e-12, 'n_max': 100},\n    ]\n\n    results = []\n    for case in test_cases:\n        T_star, p = secant_solver(case['c1'], case['c2'], case['T0'], case['T1'], case['tol'], case['n_max'])\n        results.append([T_star, p])\n\n    # Format the final output string exactly as required, without spaces.\n    # str(np.nan) produces 'nan' as required.\n    output_parts = [f\"[{str(r)},{str(p)}]\" for r, p in results]\n    final_output = f\"[{','.join(output_parts)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3271741"}]}