{"hands_on_practices": [{"introduction": "理论学习之后，我们通过实践来巩固。掌握Broyden方法的第一步是理解其核心迭代过程。这个练习将带你完成一次完整的Broyden迭代计算，从一个初始点 $x_0$ 和初始雅可比矩阵近似 $B_0$ 出发，求得下一个迭代点 $x_1$。这有助于你熟悉求解线性系统以获得步长，然后更新解的基本流程。[@problem_id:2158069]", "problem": "考虑由 $F(x) = 0$ 给出的非线性方程组，其中 $x = (x_1, x_2)^T$ 且函数 $F: \\mathbb{R}^2 \\to \\mathbb{R}^2$ 定义为：\n$$\nF(x) = \\begin{pmatrix} x_1^2 - x_2 + 1 \\\\ x_1 + x_2^2 - 3 \\end{pmatrix}\n$$\n您需要执行一步称为 Broyden 方法的割线更新拟牛顿法，以找到根的一个改进的近似值。从初始猜测 $x_0 = (1, 1)^T$ 和雅可比矩阵的初始近似\n$$\nB_0 = \\begin{pmatrix} 2  0 \\\\ 0  2 \\end{pmatrix}\n$$\n开始，计算下一个迭代点 $x_1$。将您的答案表示为一个包含两个分量的向量。", "solution": "我们给定系统 $F(x) = 0$，其中 $F: \\mathbb{R}^{2} \\to \\mathbb{R}^{2}$ 定义为\n$$\nF(x) = \\begin{pmatrix} x_{1}^{2} - x_{2} + 1 \\\\ x_{1} + x_{2}^{2} - 3 \\end{pmatrix}\n$$\n初始猜测为 $x_{0} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$，以及初始雅可比矩阵近似为\n$$\nB_{0} = \\begin{pmatrix} 2  0 \\\\ 0  2 \\end{pmatrix}\n$$\n在 Broyden 方法中，下一个迭代点 $x_{1}$ 是通过首先求解线性系统\n$$\nB_{0} s_{0} = -F(x_{0})\n$$\n然后更新\n$$\nx_{1} = x_{0} + s_{0}\n$$\n来计算的。\n\n首先计算 $F(x_{0})$：\n$$\nF(x_{0}) = \\begin{pmatrix} 1^{2} - 1 + 1 \\\\ 1 + 1^{2} - 3 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix}\n$$\n使用 $B_{0} s_{0} = -F(x_{0})$ 求解 $s_{0}$。由于 $B_{0} = 2 I$，我们有\n$$\ns_{0} = B_{0}^{-1}\\big(-F(x_{0})\\big) = \\frac{1}{2} I \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} -\\frac{1}{2} \\\\ \\frac{1}{2} \\end{pmatrix}\n$$\n然后，\n$$\nx_{1} = x_{0} + s_{0} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} + \\begin{pmatrix} -\\frac{1}{2} \\\\ \\frac{1}{2} \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{2} \\\\ \\frac{3}{2} \\end{pmatrix}\n$$\n因此，下一个迭代点是分量为 $\\frac{1}{2}$ 和 $\\frac{3}{2}$ 的向量。", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{1}{2} \\\\ \\frac{3}{2} \\end{pmatrix}}$$", "id": "2158069"}, {"introduction": "完成了单步迭代后，下一个关键环节是更新雅可比矩阵的近似。这个练习专注于Broyden方法的“学习”部分：如何利用上一步的迭代信息（步长 $s_0$ 和函数值变化 $y_0$）来修正雅可比矩阵，得到一个更好的近似 $B_1$。通过这个练习，你将深入理解割线条件是如何被用来驱动矩阵更新的。[@problem_id:2158053]", "problem": "在数值求解非线性方程组 $F(x) = 0$（其中 $F: \\mathbb{R}^2 \\to \\mathbb{R}^2$）的过程中，采用了一种拟牛顿法。根的初始猜测向量为 $x_0 = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$。在该点，函数值为 $F(x_0) = \\begin{pmatrix} -1 \\\\ 2 \\end{pmatrix}$。\n\n雅可比矩阵的初始近似被选为 2x2 单位矩阵 $B_0 = I$。经过一步迭代，得到新的点为 $x_1 = \\begin{pmatrix} 2 \\\\ -1 \\end{pmatrix}$，其对应的函数值为 $F(x_1) = \\begin{pmatrix} 0.5 \\\\ 0.5 \\end{pmatrix}$。\n\n利用所提供的信息，通过应用一步 Broyden “好”方法，计算更新后的雅可比近似矩阵 $B_1$。请将答案表示为一个 2x2 矩阵。", "solution": "我们应用 Broyden “好”更新公式，该公式强制满足割线方程 $B_{1}s_{0}=y_{0}$，并在 Frobenius 范数下最小化 $B$ 的变化。更新公式为\n$$\nB_{1}=B_{0}+\\frac{\\left(y_{0}-B_{0}s_{0}\\right)s_{0}^{T}}{s_{0}^{T}s_{0}}.\n$$\n根据数据，计算步长和函数值差：\n$$\ns_{0}=x_{1}-x_{0}=\\begin{pmatrix}2 \\\\ -1\\end{pmatrix}-\\begin{pmatrix}1 \\\\ 1\\end{pmatrix}=\\begin{pmatrix}1 \\\\ -2\\end{pmatrix},\\quad\ny_{0}=F(x_{1})-F(x_{0})=\\begin{pmatrix}\\tfrac{1}{2} \\\\ \\tfrac{1}{2}\\end{pmatrix}-\\begin{pmatrix}-1 \\\\ 2\\end{pmatrix}=\\begin{pmatrix}\\tfrac{3}{2} \\\\ -\\tfrac{3}{2}\\end{pmatrix}.\n$$\n当 $B_{0}=I$ 时，我们有\n$$\nB_{0}s_{0}=s_{0}=\\begin{pmatrix}1 \\\\ -2\\end{pmatrix},\\quad y_{0}-B_{0}s_{0}=\\begin{pmatrix}\\tfrac{3}{2} \\\\ -\\tfrac{3}{2}\\end{pmatrix}-\\begin{pmatrix}1 \\\\ -2\\end{pmatrix}=\\begin{pmatrix}\\tfrac{1}{2} \\\\ \\tfrac{1}{2}\\end{pmatrix},\n$$\n以及\n$$\ns_{0}^{T}s_{0}=1^{2}+(-2)^{2}=5.\n$$\n构建秩一校正项：\n$$\n\\frac{\\left(y_{0}-B_{0}s_{0}\\right)s_{0}^{T}}{s_{0}^{T}s_{0}}=\\frac{1}{5}\\begin{pmatrix}\\tfrac{1}{2} \\\\ \\tfrac{1}{2}\\end{pmatrix}\\begin{pmatrix}1  -2\\end{pmatrix}\n=\\frac{1}{5}\\begin{pmatrix}\\tfrac{1}{2}  -1 \\\\ \\tfrac{1}{2}  -1\\end{pmatrix}\n=\\begin{pmatrix}\\tfrac{1}{10}  -\\tfrac{1}{5} \\\\ \\tfrac{1}{10}  -\\tfrac{1}{5}\\end{pmatrix}.\n$$\n因此，\n$$\nB_{1}=I+\\begin{pmatrix}\\tfrac{1}{10}  -\\tfrac{1}{5} \\\\ \\tfrac{1}{10}  -\\tfrac{1}{5}\\end{pmatrix}\n=\\begin{pmatrix}1+\\tfrac{1}{10}  -\\tfrac{1}{5} \\\\ \\tfrac{1}{10}  1-\\tfrac{1}{5}\\end{pmatrix}\n=\\begin{pmatrix}\\tfrac{11}{10}  -\\tfrac{1}{5} \\\\ \\tfrac{1}{10}  \\tfrac{4}{5}\\end{pmatrix}.\n$$\n快速检验表明 $B_{1}s_{0}=\\begin{pmatrix}\\tfrac{3}{2} \\\\ -\\tfrac{3}{2}\\end{pmatrix}=y_{0}$，这验证了割线条件。", "answer": "$$\\boxed{\\begin{pmatrix}\\tfrac{11}{10}  -\\tfrac{1}{5} \\\\ \\tfrac{1}{10}  \\tfrac{4}{5}\\end{pmatrix}}$$", "id": "2158053"}, {"introduction": "我们将单步计算和矩阵更新这两个基本操作结合起来，构建一个完整的Broyden方法求解器。这个高级编程练习旨在揭示Broyden方法一个深刻且有趣的特性：即使雅可比矩阵的近似序列 $B_k$ 没有收敛到解 $x^*$ 处的真实雅可比矩阵 $J(x^*)$，整个方法依然能够成功找到解。通过这个实践，你将体会到Broyden方法在理论上的精妙之处，并提升算法实现与分析的能力。[@problem_id:3211914]", "problem": "要求您设计并实现一个程序，以演示用于求解非线性方程组的 Broyden 方法的一个核心现象：对于一个非线性二维系统，近似雅可比矩阵序列（记为 $B_k$）可以收敛到一个与解 $x^*$ 处的真实雅可比矩阵 $J(x^*)$ 不同的矩阵，而迭代点 $x_k$ 仍然收敛到根。您必须使用的基本原理包括：通过迭代法求解向量值函数 $F:\\mathbb{R}^n \\to \\mathbb{R}^n$ 的方程 $F(x) = 0$ 的定义、使用雅可比矩阵的牛顿迭代，以及作为 Broyden 方法等拟牛顿方案基础的割线条件。在构建算法的推理过程中，除了这些核心定义之外，您不得假定任何特殊公式。您的程序必须实现标准的 Broyden 更新，该更新强制执行割线方程，并寻求在每次迭代中近似雅可比矩阵在弗罗贝尼乌斯范数意义下的最小变化。\n\n使用 Broyden 方法实现一个二维系统（即 $n = 2$）的求解器，并满足以下要求：\n- 使用迭代 $x_{k+1} = x_k + s_k$，其中 $s_k$ 是 $B_k s_k = -F(x_k)$ 的解，而 $B_k$ 是当前对雅可比矩阵的近似。如果 $B_k$ 是奇异或接近奇异的，则使用通过伪逆计算的最小二乘步，或在标准数值线性代数规则内的等效稳定回退方案。对步长使用简单的回溯策略，以确保序列 $\\|F(x_k)\\|_2$ 不会增加。\n- 在每一步中使用经典的（所谓的“好”）Broyden 公式来更新 $B_k$，该公式强制执行最新的割线方程，并在所有满足割线条件的秩一更新中，产生 $B_k$ 在弗罗贝尼乌斯范数下的最小变化。不要硬编码任何与特定 $F$ 相关的特殊情况代数简化。\n- 当 $\\|F(x_k)\\|_2 \\le \\varepsilon_f$ 或 $\\|s_k\\|_2 \\le \\varepsilon_s$（其中 $\\varepsilon_f$ 和 $\\varepsilon_s$ 为预设容差）时，或达到最大迭代次数 $N_{\\max}$ 时终止。所有范数对于向量是欧几里得范数，对于矩阵是弗罗贝尼乌斯范数。\n\n您将在以下小型测试套件上测试您的实现，每个测试套件都有完全指定的数据和用于比较的精确根。此任务不涉及任何物理单位。\n\n定义非线性系统 $F_{\\mathrm{nl}}:\\mathbb{R}^2 \\to \\mathbb{R}^2$ 如下\n$$\nF_{\\mathrm{nl}}(x) =\n\\begin{bmatrix}\nx_1^2 + x_2 - 1 \\\\\nx_1 + x_2^2 - 1\n\\end{bmatrix},\n$$\n其解析雅可比矩阵为\n$$\nJ_{\\mathrm{nl}}(x) =\n\\begin{bmatrix}\n2 x_1  1 \\\\\n1  2 x_2\n\\end{bmatrix}.\n$$\n该系统在 $x^*_{\\mathrm{nl}} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$ 处有一个精确根。\n\n定义线性系统 $F_{\\mathrm{lin}}:\\mathbb{R}^2 \\to \\mathbb{R}^2$ 如下\n$$\nF_{\\mathrm{lin}}(x) = A x - b, \\quad A = \\begin{bmatrix} 3  1 \\\\ 1  2 \\end{bmatrix}, \\quad b = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix},\n$$\n其常数雅可比矩阵为 $J_{\\mathrm{lin}}(x) \\equiv A$，精确根为 $x^*_{\\mathrm{lin}} = A^{-1} b$。\n\n您的程序必须按顺序运行以下三个测试用例，使用指定的 Broyden 方法：\n- 测试 $1$ (标准情况，非线性)：使用 $F_{\\mathrm{nl}}$，初始猜测值 $x_0 = \\begin{bmatrix} 0.5 \\\\ 0.5 \\end{bmatrix}$，初始近似雅可比矩阵 $B_0 = I_2$（$2 \\times 2$ 单位矩阵），残差容差 $\\varepsilon_f = 10^{-10}$，步长容差 $\\varepsilon_s = 10^{-12}$，以及最大迭代次数 $N_{\\max} = 200$。终止后，计算两个输出：\n  - $d_1 = \\|x_{\\mathrm{final}} - x^*_{\\mathrm{nl}}\\|_2$,\n  - $e_1 = \\|B_{\\mathrm{final}} - J_{\\mathrm{nl}}(x^*_{\\mathrm{nl}})\\|_F$.\n- 测试 $2$ (边界情况，从根开始)：使用 $F_{\\mathrm{nl}}$，初始猜测值 $x_0 = x^*_{\\mathrm{nl}} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$，初始近似雅可比矩阵 $B_0 = 2 I_2$，容差 $\\varepsilon_f = 10^{-10}$，$\\varepsilon_s = 10^{-12}$，以及最大迭代次数 $N_{\\max} = 200$。由于起始点是精确根，该方法应立即终止而无需更新。计算：\n  - $d_2 = \\|x_{\\mathrm{final}} - x^*_{\\mathrm{nl}}\\|_2$,\n  - $e_2 = \\|B_{\\mathrm{final}} - J_{\\mathrm{nl}}(x^*_{\\mathrm{nl}})\\|_F$.\n- 测试 $3$ (与线性系统对比)：使用 $F_{\\mathrm{lin}}$，初始猜测值 $x_0 = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$，初始近似雅可比矩阵 $B_0 = I_2$，容差 $\\varepsilon_f = 10^{-12}$，$\\varepsilon_s = 10^{-12}$，以及最大迭代次数 $N_{\\max} = 50$。计算：\n  - $d_3 = \\|x_{\\mathrm{final}} - x^*_{\\mathrm{lin}}\\|_2$,\n  - $e_3 = \\|B_{\\mathrm{final}} - A\\|_F$.\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，六个浮点值按此确切顺序排列：\n$$\n[d_1, e_1, d_2, e_2, d_3, e_3].\n$$\n输出中不要包含任何空格。这些值应表示为十进制浮点数（科学记数法是可接受的）。不应打印任何附加文本。", "solution": "该问题要求实现 Broyden 方法来求解非线性方程组 $F(x) = 0$，并展示该方法的一个关键特性：近似雅可比矩阵序列 $B_k$ 不一定会收敛到根 $x^*$ 处的真实雅可比矩阵 $J(x^*)$，即使迭代点 $x_k$ 收敛到根 $x^*$。\n\n**$1$. Broyden 方法：基础**\n\nBroyden 方法是一种拟牛顿法。求解 $F(x)=0$ 的牛顿法遵循迭代 $x_{k+1} = x_k - J(x_k)^{-1} F(x_k)$，其中 $J(x_k)$ 是 $F$ 在 $x_k$ 处的雅可比矩阵。这需要在每一步计算并求逆雅可比矩阵，计算成本可能很高。\n\n拟牛顿法用一个近似值 $B_k$ 替代真实的雅可比矩阵 $J(x_k)$。迭代过程变为：\n$1$. 求解线性系统 $B_k s_k = -F(x_k)$ 以得到步长 $s_k$。\n$2$. 更新解：$x_{k+1} = x_k + s_k$。\n\n核心思想是以一种计算上廉价的方式将 $B_k$ 更新为 $B_{k+1}$，并融入关于函数 $F$ 的新信息。该更新基于割线条件，这是一维求根割线法在多维的推广。割线条件要求新的近似雅可比矩阵 $B_{k+1}$ 能够正确地将最近一步中 $x$ 的变化与 $F$ 的变化关联起来：\n$$B_{k+1} s_k = y_k$$\n其中 $s_k = x_{k+1} - x_k$ 且 $y_k = F(x_{k+1}) - F(x_k)$。\n\n**$2$. “好” Broyden 更新**\n\n有无穷多个矩阵 $B_{k+1}$ 满足割线方程。Broyden 的“好”方法选择在满足割线条件的约束下，在弗罗贝尼乌斯范数意义上最接近前一个近似 $B_k$ 的矩阵 $B_{k+1}$。这是一个约束优化问题：\n$$\\min_{B} \\|B - B_k\\|_F \\quad \\text{subject to} \\quad B s_k = y_k$$\n这个问题的解是对 $B_k$ 的一个秩-1 更新：\n$$B_{k+1} = B_k + \\frac{(y_k - B_k s_k) s_k^T}{s_k^T s_k}$$\n这个公式是我们实现中雅可比矩阵近似更新的核心。项 $y_k - B_k s_k$ 表示 $F$ 的实际变化与当前近似 $B_k$ 预测的变化之间的差异。这个差异被用来沿步长 $s_k$ 的方向“校正”$B_k$。\n\n**$3$. 算法实现**\n\n求解器被构造为一个迭代循环，在每次迭代 $k$ 中包含以下关键组件：\n\n*   **步长计算**: 通过求解线性系统 $B_k s_k = -F(x_k)$ 来找到步长 $s_k$。为了对迭代过程中可能出现的奇异或病态矩阵 $B_k$ 保持稳健性，我们采用了一个最小二乘求解器。这等同于使用 Moore-Penrose 伪逆，找到解 $s_k = -B_k^\\dagger F(x_k)$，该解最小化 $\\|B_k s_k + F(x_k)\\|_2$。在 NumPy 中，`numpy.linalg.lstsq` 提供了此功能。\n\n*   **线搜索**: 一个完整的步长 $s_k$ 可能不会导致残差范数 $\\|F(x)\\|_2$ 减小。为确保稳健收敛，使用了一个简单的回溯线搜索。我们从步长 $\\alpha=1$ 开始，并相继减小它（例如，通过减半），直到满足条件 $\\|F(x_k + \\alpha s_k)\\|_2 < \\|F(x_k)\\|_2$。这确保了每一步都朝着解前进。最终采纳的步长是 $\\alpha s_k$。\n\n*   **雅可比矩阵更新**: 在采纳导致 $x_{k+1} = x_k + s_k$ 的步长 $s_k$ 后，使用上面提到的 Broyden 公式计算新的雅可比矩阵近似 $B_{k+1}$。为避免数值不稳定，如果步长范数 $\\|s_k\\|_2$ 接近 $0$，则跳过更新，因为这将涉及除以一个非常小的数。\n\n*   **终止条件**: 当满足以下标准之一时，迭代停止：\n    $1$. 残差的范数低于容差：$\\|F(x_k)\\|_2 \\le \\varepsilon_f$。\n    $2$. 步长的范数低于容差：$\\|s_k\\|_2 \\le \\varepsilon_s$。这表明迭代点不再有显著变化。\n    $3$. 达到了最大迭代次数 $N_{\\max}$。\n\n**$4$. 测试用例分析**\n\n将该算法应用于 `$3$` 个测试用例，以观察其行为。\n\n*   **测试 $1$ (非线性系统)**: 从 $x_0 = \\begin{bmatrix} 0.5 \\\\ 0.5 \\end{bmatrix}$ 和 $B_0=I_2$ 开始，将该方法应用于非线性系统 $F_{\\mathrm{nl}}$。预计迭代点 $x_k$ 会收敛到根 $x^*_{\\mathrm{nl}} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$，因此距离 $d_1 = \\|x_{\\mathrm{final}} - x^*_{\\mathrm{nl}}\\|_2$ 应接近 $0$。然而，随着迭代点的收敛，步长 $s_k$ 可能会在特定方向上对齐（子空间集中）。Broyden 更新仅在这些方向上强制执行割线条件。因此，$B_k$ 中与正交方向对应的分量未被完善。因此，最终矩阵 $B_{\\mathrm{final}}$ 可能不等于真实的雅可比矩阵 $J_{\\mathrm{nl}}(x^*_{\\mathrm{nl}})$，并且误差 $e_1 = \\|B_{\\mathrm{final}} - J_{\\mathrm{nl}}(x^*_{\\mathrm{nl}})\\|_F$ 预计不为 $0$。根处的真实雅可比矩阵是 $J_{\\mathrm{nl}}(x^*_{\\mathrm{nl}}) = \\begin{bmatrix} 2  1 \\\\ 1  0 \\end{bmatrix}$。\n\n*   **测试 $2$ (边界情况)**: 方法从精确根 $x_0 = x^*_{\\mathrm{nl}}$ 开始。初始残差 $\\|F(x_0)\\|_2$ 为 $0$。算法正确识别了这一点，并在第一次检查时终止，不执行任何步骤或更新。因此，$x_{\\mathrm{final}} = x_0$ 且 $B_{\\mathrm{final}} = B_0$。距离 $d_2$ 将为 $0$。误差 $e_2 = \\|B_0 - J_{\\mathrm{nl}}(x^*_{\\mathrm{nl}})\\|_F$ 将不为 $0$，计算为 $\\|2I_2 - J_{\\mathrm{nl}}(x^*_{\\mathrm{nl}})\\|_F$。\n\n*   **测试 $3$ (线性系统)**: 将该方法应用于线性系统 $F(x) = Ax-b$。对于线性系统，函数值的变化是 $y_k = F(x_{k+1}) - F(x_k) = A(x_{k+1}-x_k) = As_k$。Broyden 更新变为 $B_{k+1} = B_k + \\frac{(A-B_k)s_k s_k^T}{s_k^T s_k}$。这个更新具有属性 $(B_{k+1}-A)s_k=0$。在 $n$ 维空间中，如果该方法生成了 $n$ 个线性无关的步长，则 $B_{n}$ 将等于 $A$。已知 Broyden 方法对于线性系统最多在 $2n$ 次迭代内终止。对于这个二维情况，收敛应该非常快，并且最终的近似 $B_{\\mathrm{final}}$ 预计将非常接近真实（且恒定）的雅可比矩阵 $A$。误差 $d_3$ 和 $e_3$ 都应接近 $0$。\n\n这一组结构化的测试阐明了 Broyden 方法在不同场景下的基本行为，特别突出了迭代点 $x_k$ 的收敛与近似雅可比矩阵 $B_k$ 的收敛之间的区别。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef broyden_solver(F, x0, B0, tol_f, tol_s, max_iter):\n    \"\"\"\n    Solves a system of nonlinear equations F(x) = 0 using Broyden's method.\n\n    Args:\n        F (callable): The vector-valued function to find a root of.\n        x0 (np.ndarray): The initial guess for the solution x.\n        B0 (np.ndarray): The initial guess for the Jacobian matrix.\n        tol_f (float): Tolerance for the norm of the residual F(x).\n        tol_s (float): Tolerance for the norm of the step s.\n        max_iter (int): Maximum number of iterations.\n\n    Returns:\n        tuple: A tuple (x, B) containing the final solution iterate and the\n               final approximate Jacobian.\n    \"\"\"\n    x = np.array(x0, dtype=float)\n    B = np.array(B0, dtype=float)\n    \n    Fx = F(x)\n    \n    for _ in range(max_iter):\n        # 1. Check termination on residual norm\n        if np.linalg.norm(Fx) <= tol_f:\n            break\n            \n        # 2. Solve for the step s_trial = -B_k^{-1} F(x_k)\n        # We use lstsq for robustness against singularity.\n        try:\n            s_trial = np.linalg.lstsq(B, -Fx, rcond=None)[0]\n        except np.linalg.LinAlgError:\n            # This is a fallback, but lstsq should generally not fail.\n            # If it does, the matrix is extremely ill-conditioned. Stop iteration.\n            break\n\n        # 3. Check termination on step size (before backtracking)\n        if np.linalg.norm(s_trial) <= tol_s:\n            break\n\n        # 4. Backtracking line search\n        alpha = 1.0\n        norm_Fx = np.linalg.norm(Fx)\n        x_next = x + alpha * s_trial\n        Fx_next = F(x_next)\n        \n        # Backtrack until the residual norm is not increasing. Limit to 10 steps.\n        for _ in range(10):\n            if np.linalg.norm(Fx_next) < norm_Fx:\n                break\n            alpha /= 2.0\n            x_next = x + alpha * s_trial\n            Fx_next = F(x_next)\n        else: # if loop finished without break, step is not productive\n            # Could indicate stalling, so we halt.\n            break\n\n        s = x_next - x\n        y = Fx_next - Fx\n        \n        # 5. Update Jacobian B using Broyden's \"good\" formula\n        # B_{k+1} = B_k + (y_k - B_k s_k)s_k^T / (s_k^T s_k)\n        s_norm_sq = np.dot(s, s)\n        if s_norm_sq > 1e-14: # Avoid division by zero for very small steps\n            update_vec = y - B @ s\n            B += np.outer(update_vec, s) / s_norm_sq\n            \n        # 6. Update x and Fx for the next iteration\n        x = x_next\n        Fx = Fx_next\n        \n    return x, B\n\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and print the results.\n    \"\"\"\n    # --- Define Systems and Exact Solutions ---\n    def F_nl(x):\n        return np.array([\n            x[0]**2 + x[1] - 1.0, \n            x[0] + x[1]**2 - 1.0\n        ])\n\n    def J_nl(x):\n        return np.array([\n            [2.0 * x[0], 1.0], \n            [1.0, 2.0 * x[1]]\n        ])\n    \n    A = np.array([[3.0, 1.0], [1.0, 2.0]])\n    b = np.array([1.0, 0.0])\n    def F_lin(x):\n        return A @ x - b\n\n    x_star_nl = np.array([1.0, 0.0])\n    x_star_lin = np.linalg.solve(A, b)\n\n    results = []\n\n    # --- Test Case 1: Nonlinear system, standard start ---\n    x0_1 = [0.5, 0.5]\n    B0_1 = np.identity(2)\n    tol_f_1, tol_s_1, N_max_1 = 1e-10, 1e-12, 200\n    \n    x_final_1, B_final_1 = broyden_solver(F_nl, x0_1, B0_1, tol_f_1, tol_s_1, N_max_1)\n    \n    d1 = np.linalg.norm(x_final_1 - x_star_nl)\n    J_star_nl = J_nl(x_star_nl)\n    e1 = np.linalg.norm(B_final_1 - J_star_nl, ord='fro')\n    results.extend([d1, e1])\n\n    # --- Test Case 2: Nonlinear system, start at root ---\n    x0_2 = x_star_nl\n    B0_2 = 2.0 * np.identity(2)\n    tol_f_2, tol_s_2, N_max_2 = 1e-10, 1e-12, 200\n\n    x_final_2, B_final_2 = broyden_solver(F_nl, x0_2, B0_2, tol_f_2, tol_s_2, N_max_2)\n    \n    d2 = np.linalg.norm(x_final_2 - x_star_nl)\n    e2 = np.linalg.norm(B_final_2 - J_star_nl, ord='fro')\n    results.extend([d2, e2])\n\n    # --- Test Case 3: Linear system ---\n    x0_3 = [0.0, 0.0]\n    B0_3 = np.identity(2)\n    tol_f_3, tol_s_3, N_max_3 = 1e-12, 1e-12, 50\n\n    x_final_3, B_final_3 = broyden_solver(F_lin, x0_3, B0_3, tol_f_3, tol_s_3, N_max_3)\n    \n    d3 = np.linalg.norm(x_final_3 - x_star_lin)\n    e3 = np.linalg.norm(B_final_3 - A, ord='fro')\n    results.extend([d3, e3])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3211914"}]}