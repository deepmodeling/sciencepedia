{"hands_on_practices": [{"introduction": "牛顿法是求解非线性方程组最强大和最广泛使用的迭代方法之一。掌握该方法的关键第一步是熟悉其核心计算流程。本练习 [@problem_id:2207863] 将引导你完成一个完整的迭代步骤，从建立雅可比矩阵、求解线性更新方程，到计算下一个近似解，从而为更复杂的应用打下坚实的基础。", "problem": "考虑以下二元非线性方程组：\n$$\n\\begin{cases}\n2x^2 + y = 11 \\\\\nx + 2y^2 = 10\n\\end{cases}\n$$\n我们希望使用适用于方程组的牛顿法来求解该方程组的近似解。从初始猜测 $(x_0, y_0) = (3, 1)$ 开始，执行一次迭代以找到下一个近似值 $(x_1, y_1)$。\n\n求 $(x_1, y_1)$ 的坐标。将每个坐标表示为最简分数形式。", "solution": "定义向量函数 $\\mathbf{F}(x,y)$ 及其雅可比矩阵 $J(x,y)$ 如下：\n$$\n\\mathbf{F}(x,y)=\\begin{pmatrix} 2x^{2}+y-11 \\\\ x+2y^{2}-10 \\end{pmatrix}, \n\\quad\nJ(x,y)=\\begin{pmatrix} \\frac{\\partial}{\\partial x}(2x^{2}+y-11)  \\frac{\\partial}{\\partial y}(2x^{2}+y-11) \\\\ \\frac{\\partial}{\\partial x}(x+2y^{2}-10)  \\frac{\\partial}{\\partial y}(x+2y^{2}-10) \\end{pmatrix}\n=\\begin{pmatrix} 4x  1 \\\\ 1  4y \\end{pmatrix}.\n$$\n适用于方程组的牛顿法通过求解下式来计算更新量 $\\mathbf{s}=(s_{x},s_{y})^{T}$：\n$$\nJ(x_{0},y_{0})\\,\\mathbf{s}=-\\mathbf{F}(x_{0},y_{0}),\n$$\n然后令 $(x_{1},y_{1})=(x_{0},y_{0})+\\mathbf{s}$。\n\n在点 $(x_{0},y_{0})=(3,1)$ 处，计算：\n$$\n\\mathbf{F}(3,1)=\\begin{pmatrix} 2\\cdot 3^{2}+1-11 \\\\ 3+2\\cdot 1^{2}-10 \\end{pmatrix}\n=\\begin{pmatrix} 8 \\\\ -5 \\end{pmatrix},\n\\quad\nJ(3,1)=\\begin{pmatrix} 4\\cdot 3  1 \\\\ 1  4\\cdot 1 \\end{pmatrix}\n=\\begin{pmatrix} 12  1 \\\\ 1  4 \\end{pmatrix}.\n$$\n求解 $\\mathbf{s}$：\n$$\n\\begin{pmatrix} 12  1 \\\\ 1  4 \\end{pmatrix}\\begin{pmatrix} s_{x} \\\\ s_{y} \\end{pmatrix}\n=-\\begin{pmatrix} 8 \\\\ -5 \\end{pmatrix}\n=\\begin{pmatrix} -8 \\\\ 5 \\end{pmatrix},\n$$\n这是一个线性方程组：\n$$\n\\begin{cases}\n12s_{x}+s_{y}=-8, \\\\\ns_{x}+4s_{y}=5.\n\\end{cases}\n$$\n由 $s_{x}=5-4s_{y}$ 并代入第一个方程，可得：\n$$\n12(5-4s_{y})+s_{y}=-8\n\\;\\Rightarrow\\;\n60-48s_{y}+s_{y}=-8\n\\;\\Rightarrow\\;\n-47s_{y}=-68\n\\;\\Rightarrow\\;\ns_{y}=\\frac{68}{47}.\n$$\n则\n$$\ns_{x}=5-4\\cdot \\frac{68}{47}\n=\\frac{235}{47}-\\frac{272}{47}\n=-\\frac{37}{47}.\n$$\n更新近似值：\n$$\nx_{1}=x_{0}+s_{x}=3-\\frac{37}{47}=\\frac{141}{47}-\\frac{37}{47}=\\frac{104}{47}, \n\\quad\ny_{1}=y_{0}+s_{y}=1+\\frac{68}{47}=\\frac{47}{47}+\\frac{68}{47}=\\frac{115}{47}.\n$$\n因此，下一个牛顿迭代值为 $\\left(\\frac{104}{47}, \\frac{115}{47}\\right)$，两个坐标都已是最简分数形式。", "answer": "$$\\boxed{\\begin{pmatrix}\\frac{104}{47}  \\frac{115}{47}\\end{pmatrix}}$$", "id": "2207863"}, {"introduction": "在掌握了牛顿法的基本计算步骤之后，理解其局限性与潜在的“陷阱”至关重要，因为该方法并非万无一失。本练习 [@problem_id:2207871] 探讨了一种关键的失效模式：雅可比矩阵的奇异性或接近奇异性。通过分析为何某些初始猜测点是“坏”的选择，你将对该方法的稳定性和收敛条件建立起更深刻的直觉。", "problem": "一位工程师的任务是为一个模拟稳态物理系统的非线性方程组寻找数值解。方程由下式给出：\n$$f_1(x, y) = x^2 - y^2 - 4 = 0$$\n$$f_2(x, y) = xy - 3 = 0$$\n该工程师决定对该系统使用牛顿法。该方法的迭代公式为 $\\mathbf{x}_{k+1} = \\mathbf{x}_k - [J(\\mathbf{x}_k)]^{-1} \\mathbf{F}(\\mathbf{x}_k)$，其中 $\\mathbf{x} = (x, y)^T$，$\\mathbf{F} = (f_1, f_2)^T$，$J(\\mathbf{x})$ 是 $\\mathbf{F}$ 的雅可比矩阵。\n\n经过一些尝试，工程师观察到，对于这个特定系统，选择位于x轴（其中 $y_0 = 0$）或y轴（其中 $x_0 = 0$）上的初始猜测值 $\\mathbf{x}_0 = (x_0, y_0)$ 是一个糟糕的策略。下列哪个陈述为这种糟糕的表现提供了最准确和根本的原因？\n\nA. 对于坐标轴上的任何初始猜测值，牛顿法的第一步迭代产生的点也位于坐标轴上，这使得算法永远无法趋近解，因为解并不在坐标轴上。\n\nB. 对于坐标轴上的任何初始猜测值，函数向量 $\\mathbf{F}(\\mathbf{x}_0)$ 是一个零向量，这会错误地向算法发出已找到解的信号。\n\nC. 对于x轴或y轴上的任何点，雅可比矩阵都是奇异的，导致该方法因无法计算逆矩阵而立即失败。\n\nD. 点 $(0,0)$ 是雅可比矩阵奇异的唯一位置。坐标轴上靠近原点的初始猜测值会导致一个接近奇异的雅可比矩阵，使得后续迭代产生的点与真实解相距甚远，这表明了其糟糕的收敛行为。\n\nE. 该方程组没有实数解，因此无论初始猜测值如何，牛顿法都将无法收敛。", "solution": "给定的方程组为\n$$\nf_{1}(x,y)=x^{2}-y^{2}-4,\\qquad f_{2}(x,y)=xy-3,\n$$\n其向量函数为 $\\mathbf{F}(x,y)=(f_{1}(x,y),f_{2}(x,y))^{T}$，雅可比矩阵为\n$$\nJ(x,y)=\\begin{pmatrix}\n\\frac{\\partial f_{1}}{\\partial x}  \\frac{\\partial f_{1}}{\\partial y}\\\\\n\\frac{\\partial f_{2}}{\\partial x}  \\frac{\\partial f_{2}}{\\partial y}\n\\end{pmatrix}\n=\\begin{pmatrix}\n2x  -2y\\\\\ny  x\n\\end{pmatrix}.\n$$\n牛顿法的更新公式为 $\\mathbf{x}_{k+1}=\\mathbf{x}_{k}-J(\\mathbf{x}_{k})^{-1}\\mathbf{F}(\\mathbf{x}_{k})$，这要求 $J$ 在迭代点上是可逆的。\n\n首先，计算雅可比矩阵的行列式：\n$$\n\\det J(x,y)=(2x)(x)-(-2y)(y)=2x^{2}+2y^{2}=2(x^{2}+y^{2}).\n$$\n因此 $J(x,y)$ 是奇异的当且仅当 $(x,y)=(0,0)$。特别地，$J$ 在坐标轴上的一般点（原点除外）不是奇异的。这立即表明选项C是错误的。\n\n接下来，计算 $\\mathbf{F}$ 在坐标轴上的值。在x轴上，当 $y=0$ 时，\n$$\n\\mathbf{F}(x,0)=\\bigl(x^{2}-4,\\,-3\\bigr),\n$$\n其永远不为零向量。在y轴上，当 $x=0$ 时，\n$$\n\\mathbf{F}(0,y)=\\bigl(-y^{2}-4,\\,-3\\bigr),\n$$\n其也永远不为零向量。因此选项B是错误的。\n\n现在检查牛顿法在一次迭代后是否仍停留在坐标轴上。使用由 $J\\mathbf{s}=-\\mathbf{F}$ 定义的牛顿步长 $\\mathbf{s}$。在x轴上（$y=0$），我们有\n$$\nJ(x,0)=\\begin{pmatrix}2x  0\\\\ 0  x\\end{pmatrix},\\qquad \\mathbf{F}(x,0)=\\begin{pmatrix}x^{2}-4\\\\ -3\\end{pmatrix}.\n$$\n那么\n$$\n\\mathbf{s}=-J^{-1}\\mathbf{F}=-\\begin{pmatrix}\\frac{1}{2x}  0\\\\ 0  \\frac{1}{x}\\end{pmatrix}\\begin{pmatrix}x^{2}-4\\\\ -3\\end{pmatrix}\n=\\begin{pmatrix}-\\frac{x^{2}-4}{2x}\\\\ \\frac{3}{x}\\end{pmatrix},\n$$\n所以下一个迭代点是\n$$\nx_{1}=x-\\frac{x^{2}-4}{2x}=\\frac{x}{2}+\\frac{2}{x},\\qquad y_{1}=0+\\frac{3}{x}=\\frac{3}{x}.\n$$\n由于对于任何有限的 $x$ 都有 $y_{1}=\\frac{3}{x}\\neq 0$，因此迭代点会立即离开坐标轴。在y轴上（$x=0$）进行类似的计算，求解\n$$\n\\begin{pmatrix}0  -2y\\\\ y  0\\end{pmatrix}\\begin{pmatrix}s_{x}\\\\ s_{y}\\end{pmatrix}=-\\begin{pmatrix}-y^{2}-4\\\\ -3\\end{pmatrix}=\\begin{pmatrix}y^{2}+4\\\\ 3\\end{pmatrix},\n$$\n解得 $s_{x}=\\frac{3}{y}$ 和 $s_{y}=-\\frac{y^{2}+4}{2y}$，所以\n$$\nx_{1}=0+\\frac{3}{y}=\\frac{3}{y},\\qquad y_{1}=y-\\frac{y^{2}+4}{2y}=\\frac{y}{2}-\\frac{2}{y}.\n$$\n同样，迭代点会立即离开坐标轴。因此选项A是错误的。\n\n为了排除选项E，我们检查是否存在实数解。由 $xy=3$ 可得 $y=\\frac{3}{x}$，代入 $x^{2}-y^{2}=4$ 得到\n$$\nx^{2}-\\frac{9}{x^{2}}=4\\;\\;\\Longrightarrow\\;\\; x^{4}-4x^{2}-9=0.\n$$\n设 $t=x^{2}$。则 $t^{2}-4t-9=0$，解得 $t=2\\pm\\sqrt{13}$。可取的根为 $t=2+\\sqrt{13}0$，因此\n$$\nx=\\pm\\sqrt{2+\\sqrt{13}},\\qquad y=\\frac{3}{x}=\\pm\\frac{3}{\\sqrt{2+\\sqrt{13}}},\n$$\n这表明存在两个实数解。因此选项E是错误的。\n\n剩下的问题是找出为什么选择坐标轴上的点作为初始猜测值是一个糟糕策略的根本原因。由于\n$$\n\\det J(x,y)=2(x^{2}+y^{2}),\n$$\n雅可比矩阵在 $(0,0)$ 处是奇异的，并且当 $(x,y)$ 靠近原点时会变得病态。其显式逆矩阵为\n$$\nJ(x,y)^{-1}=\\frac{1}{2(x^{2}+y^{2})}\\begin{pmatrix}x  2y\\\\ -y  2x\\end{pmatrix},\n$$\n其各项元素是 $x$ 和 $y$ 的线性函数，并由因子 $\\frac{1}{2(x^2+y^2)}$ 缩放。在原点附近，这会产生大的牛顿步长。特别是在坐标轴上，我们上面推导出的牛顿更新量包含像 $\\frac{3}{x}$ 或 $\\frac{3}{y}$ 这样的项，当初始猜测值位于坐标轴上且靠近原点时，这些项的量值会变得非常大。这种病态性解释了观察到的糟糕性能，并被选项D精确地概括了。\n\n因此，最准确和根本的原因是，雅可比矩阵在原点处是奇异的，并且对于靠近原点的、位于坐标轴上的初始猜测值，雅可比矩阵接近奇异，这导致了不稳定性和糟糕的收敛性。", "answer": "$$\\boxed{D}$$", "id": "2207871"}, {"introduction": "这个最后的练习将理论与实际计算联系起来，是理论走向实践的桥梁。你将通过编程实现牛顿法，来求解一个根植于复数平面的方程组，并在此过程中揭示其吸引盆所形成的复杂而美丽的碎形图案。本练习 [@problem_id:3280962] 不仅能巩固你对算法实现的理解，还将展示数值方法如何揭示复杂数学结构背后令人惊叹的秩序与美感。", "problem": "考虑一个在两个实数变量上的非线性方程组，它由复多项式映射 $g(z)=z^3-1$ 的实部和虚部定义，其中 $z=x+\\mathrm{i}y$ 且 $\\mathrm{i}^2=-1$。定义向量值函数 $f:\\mathbb{R}^2\\to\\mathbb{R}^2$ 如下：\n$$\nf(x,y)=\\begin{bmatrix}\nx^3-3xy^2-1\\\\\n3x^2y-y^3\n\\end{bmatrix}.\n$$\n$f$ 的零点对应于 $g(z)=0$ 的根，即以下三点：\n$$\nr_1=\\begin{bmatrix}1\\\\0\\end{bmatrix},\\quad\nr_2=\\begin{bmatrix}-\\tfrac{1}{2}\\\\\\tfrac{\\sqrt{3}}{2}\\end{bmatrix},\\quad\nr_3=\\begin{bmatrix}-\\tfrac{1}{2}\\\\-\\tfrac{\\sqrt{3}}{2}\\end{bmatrix}.\n$$\n应用于 $f$ 的牛顿法在平面上展现出分形吸引盆，这意味着收敛到给定根的初始猜测值集合其边界具有分形结构。从多元微积分的基本原理和方程组的牛顿法定义出发，使用 $f$ 的雅可比矩阵推导求解 $f(x,y)=\\mathbf{0}$ 的迭代格式。设计并实现一个算法，对于给定的初始猜测值 $(x_0,y_0)$，执行牛顿迭代，直到满足收敛准则或达到最大迭代次数。\n\n为了进行分析，量化寻找一个根的计算成本，将其作为初始猜测值精度的函数。令初始猜测值位于围绕根 $r_1$ 的一个半径为 $\\varepsilon$ 的圆上，即：\n$$\n(x_0(\\theta),y_0(\\theta))=r_1+\\varepsilon\\begin{bmatrix}\\cos\\theta\\\\ \\sin\\theta\\end{bmatrix},\n$$\n其中 $\\theta$ 是一个均匀采样的角度，$\\theta_k=\\tfrac{2\\pi k}{K}$，$k\\in\\{0,1,\\dots,K-1\\}$，$K$ 是一个固定的正整数。角度必须以弧度为单位进行解释。对于每个 $\\varepsilon$，从这 $K$ 个初始猜测值开始运行算法，并计算：\n- 在固定迭代预算内收敛的那些初始猜测值的平均迭代次数。\n- 在预算内收敛的初始猜测值的比例，表示为区间 $[0,1]$ 内的一个小数。\n\n收敛准则定义如下：如果残差范数满足 $\\|f(x,y)\\|_2\\le \\tau_f$，或者到最近精确根的距离满足 $\\min_{j\\in\\{1,2,3\\}}\\|[x,y]^T-r_j\\|_2\\le \\tau_r$，则认为迭代点 $(x,y)$ 已收敛。如果在给定的 $\\varepsilon$ 下没有任何初始猜测值在迭代预算内收敛，则报告该 $\\varepsilon$ 的平均迭代次数为最大迭代次数 $M$。\n\n你的推导只能从基本定义开始，即一阶多元泰勒展开和雅可比矩阵。不要使用牛顿法的现成公式；明确地推导迭代规则。通过使用合理的参数值和稳健的停止规则来确保科学真实性。\n\n使用以下精度半径测试套件：\n$$\n\\varepsilon\\in\\{0,\\;10^{-8},\\;0.2,\\;0.6,\\;1.2,\\;2.0\\}.\n$$\n使用 $K=64$ 个角度，最大迭代次数 $M=50$，残差容差 $\\tau_f=10^{-12}$，根邻近容差 $\\tau_r=10^{-8}$，如果迭代点离开了以原点为中心、半径为 $R_{\\max}=10$ 的球，则声明为发散。所有角度必须以弧度处理。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，格式应完全如下：\n$$\n\\text{[[m}_1,\\text{m}_2,\\dots,\\text{m}_6],[p_1,p_2,\\dots,p_6]},\n$$\n其中每个 $m_i$ 是对应 $\\varepsilon$ 的平均迭代次数（一个浮点数），每个 $p_i$ 是收敛的初始猜测值的比例（一个在 $[0,1]$ 内的浮点数）。输出必须按测试套件中给定的六个 $\\varepsilon$ 值的相同顺序计算。", "solution": "用户希望使用牛顿法求解非线性方程组 $f(x,y)=0$。我将从基本原理开始推导迭代公式。\n\n设 $\\mathbf{x} = \\begin{bmatrix}x\\\\y\\end{bmatrix}$ 是 $\\mathbb{R}^2$ 中的一个向量。该非线性方程组由向量值函数 $f(\\mathbf{x})=\\mathbf{0}$ 给出。牛顿法是一种迭代算法，它生成一个近似序列 $\\mathbf{x}_0, \\mathbf{x}_1, \\mathbf{x}_2, \\dots$，在适当的条件下，该序列收敛到 $f$ 的一个根。\n\n推导从 $f$ 在当前迭代点 $\\mathbf{x}_k$ 周围的一阶多元泰勒展开开始：\n$$\nf(\\mathbf{x}) \\approx f(\\mathbf{x}_k) + J_f(\\mathbf{x}_k)(\\mathbf{x} - \\mathbf{x}_k)\n$$\n其中 $J_f(\\mathbf{x}_k)$ 是 $f$ 在 $\\mathbf{x}_k$ 处求值的雅可比矩阵。我们寻求下一个迭代点 $\\mathbf{x}_{k+1}$，使得 $f(\\mathbf{x}_{k+1}) = \\mathbf{0}$。将 $\\mathbf{x}_{k+1}$ 替换 $\\mathbf{x}$ 并将近似值设为零，我们得到：\n$$\n\\mathbf{0} \\approx f(\\mathbf{x}_k) + J_f(\\mathbf{x}_k)(\\mathbf{x}_{k+1} - \\mathbf{x}_k)\n$$\n这个方程可以重新整理以求解更新步长 $\\Delta\\mathbf{x}_k = \\mathbf{x}_{k+1} - \\mathbf{x}_k$：\n$$\nJ_f(\\mathbf{x}_k)\\Delta\\mathbf{x}_k = -f(\\mathbf{x}_k)\n$$\n假设雅可比矩阵是可逆的，我们可以解出 $\\Delta\\mathbf{x}_k$：\n$$\n\\Delta\\mathbf{x}_k = -[J_f(\\mathbf{x}_k)]^{-1}f(\\mathbf{x}_k)\n$$\n然后，牛顿迭代由以下更新规则定义：\n$$\n\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\Delta\\mathbf{x}_k = \\mathbf{x}_k - [J_f(\\mathbf{x}_k)]^{-1}f(\\mathbf{x}_k)\n$$\n现在，我们将这个通用公式应用于问题中给出的特定函数：\n$$\nf(x,y) = \\begin{bmatrix} f_1(x,y) \\\\ f_2(x,y) \\end{bmatrix} = \\begin{bmatrix} x^3 - 3xy^2 - 1 \\\\ 3x^2y - y^3 \\end{bmatrix}\n$$\n雅可比矩阵 $J_f(x,y)$ 由 $f$ 的各分量的偏导数组成：\n$$\nJ_f(x,y) = \\begin{bmatrix} \\frac{\\partial f_1}{\\partial x}  \\frac{\\partial f_1}{\\partial y} \\\\ \\frac{\\partial f_2}{\\partial x}  \\frac{\\partial f_2}{\\partial y} \\end{bmatrix} = \\begin{bmatrix} 3x^2 - 3y^2  -6xy \\\\ 6xy  3x^2 - 3y^2 \\end{bmatrix}\n$$\n为了求雅可比矩阵的逆，我们首先计算其行列式：\n$$\n\\det(J_f(x,y)) = (3x^2 - 3y^2)(3x^2 - 3y^2) - (-6xy)(6xy) = 9(x^2 - y^2)^2 + 36x^2y^2\n$$\n$$\n\\det(J_f(x,y)) = 9(x^4 - 2x^2y^2 + y^4) + 36x^2y^2 = 9(x^4 + 2x^2y^2 + y^4) = 9(x^2 + y^2)^2\n$$\n只有当 $x^2 + y^2 = 0$ 时，行列式才为零，这只在原点 $(x,y)=(0,0)$ 处发生。在这一点，雅可比矩阵是奇异的，牛顿步长未定义。这与 $(0,0)$ 是底层复映射 $g(z)=z^3-1$ 的一个临界点相一致，因为其导数 $g'(z)=3z^2$ 在 $z=0$ 处为零。\n\n对于任何 $(x,y) \\neq (0,0)$，一个 $2 \\times 2$ 矩阵的逆由 $[J_f]^{-1} = \\frac{1}{\\det(J_f)}\\begin{bmatrix} d  -b \\\\ -c  a \\end{bmatrix}$ 给出。将此应用于我们的雅可比矩阵，得到：\n$$\n[J_f(x,y)]^{-1} = \\frac{1}{9(x^2+y^2)^2} \\begin{bmatrix} 3x^2 - 3y^2  6xy \\\\ -6xy  3x^2 - 3y^2 \\end{bmatrix} = \\frac{1}{3(x^2+y^2)^2} \\begin{bmatrix} x^2 - y^2  2xy \\\\ -2xy  x^2 - y^2 \\end{bmatrix}\n$$\n牛顿更新步长 $\\Delta\\mathbf{x}_k = \\begin{bmatrix} \\Delta x_k \\\\ \\Delta y_k \\end{bmatrix}$ 通过求解线性系统 $J_f \\Delta\\mathbf{x} = -f$ 来计算。使用显式逆矩阵：\n$$\n\\begin{bmatrix} \\Delta x_k \\\\ \\Delta y_k \\end{bmatrix} = -\\frac{1}{3(x_k^2+y_k^2)^2} \\begin{bmatrix} x_k^2 - y_k^2  2x_ky_k \\\\ -2x_ky_k  x_k^2 - y_k^2 \\end{bmatrix} \\begin{bmatrix} x_k^3 - 3x_ky_k^2 - 1 \\\\ 3x_k^2y_k - y_k^3 \\end{bmatrix}\n$$\n执行矩阵向量乘法可以得到更新的简化表达式：\n$$\nx_{k+1} = x_k + \\Delta x_k = \\frac{2}{3}x_k + \\frac{x_k^2 - y_k^2}{3(x_k^2+y_k^2)^2}\n$$\n$$\ny_{k+1} = y_k + \\Delta y_k = \\frac{2}{3}y_k - \\frac{2x_ky_k}{3(x_k^2+y_k^2)^2}\n$$\n这些是从基本原理推导出的显式迭代公式。\n\n将要实现的算法将对每个指定的 $\\varepsilon$ 值执行以下步骤：\n1.  初始化总迭代次数和收敛轨迹数量的计数器。\n2.  使用公式 $(x_0,y_0) = (1+\\varepsilon\\cos\\theta, \\varepsilon\\sin\\theta)$，在以根 $r_1=(1,0)$ 为中心、半径为 $\\varepsilon$ 的圆上生成 $K=64$ 个初始点 $(x_0, y_0)$，其中 $\\theta_k = \\frac{2\\pi k}{K}$，$k \\in \\{0, 1, \\dots, K-1\\}$。\n3.  对每个初始点，执行牛顿法迭代，最多 $M=50$ 次。\n4.  在每次迭代中，检查是否收敛。如果残差的欧几里得范数 $\\|f(x,y)\\|_2$ 小于或等于 $\\tau_f=10^{-12}$，或者其到最近已知根的距离小于或等于 $\\tau_r=10^{-8}$，则认为迭代点 $(x,y)$ 已收敛。如果在第 $i$ 次迭代时发生收敛，则该轨迹的迭代次数记录为 $i$，并更新计数器。\n5.  如果迭代点的范数 $\\|(x,y)\\|_2$ 超过 $R_{\\max}=10$，则认为迭代是发散的。如果一个初始猜测值在 $M$ 次迭代内未能收敛，则计为不收敛。\n6.  在处理完给定 $\\varepsilon$ 的所有 $K$ 个初始点后，计算成功收敛轨迹的平均迭代次数。如果没有轨迹收敛，则该平均值报告为 $M$。\n7.  计算收敛轨迹的比例。\n8.  最终输出将是两个列表：一个包含平均迭代次数，另一个包含针对指定 $\\varepsilon$ 值序列的收敛比例。\n对于 $\\varepsilon=0$ 的情况，初始猜测值为 $(1,0)$，它本身就是一个根。算法应能正确地将其识别为在 0 次迭代中收敛。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and analyzes Newton's method for the system of equations derived\n    from the complex polynomial g(z) = z^3 - 1.\n    \"\"\"\n    \n    # --- Problem Parameters ---\n    epsilons = [0.0, 1e-8, 0.2, 0.6, 1.2, 2.0]\n    K = 64\n    M = 50\n    tau_f = 1e-12\n    tau_r = 1e-8\n    R_max = 10.0\n\n    # --- Problem Definitions ---\n    # The three roots of z^3 - 1 = 0 in the complex plane, as (x,y) coordinates.\n    r1 = np.array([1.0, 0.0])\n    r2 = np.array([-0.5, np.sqrt(3.0) / 2.0])\n    r3 = np.array([-0.5, -np.sqrt(3.0) / 2.0])\n    roots = np.array([r1, r2, r3])\n\n    def f(p: np.ndarray) - np.ndarray:\n        \"\"\"\n        Calculates the vector-valued function f(x, y).\n        p is a numpy array [x, y].\n        \"\"\"\n        x, y = p\n        f1 = x**3 - 3.0 * x * y**2 - 1.0\n        f2 = 3.0 * x**2 * y - y**3\n        return np.array([f1, f2])\n\n    # Lists to store the final results\n    mean_iters_list = []\n    conv_frac_list = []\n\n    for eps in epsilons:\n        total_iters = 0\n        converged_count = 0\n        \n        # Generate K initial guesses on a circle of radius eps around root r1\n        angles = np.linspace(0.0, 2.0 * np.pi, K, endpoint=False)\n        \n        for theta in angles:\n            # Current initial guess\n            p0 = r1 + eps * np.array([np.cos(theta), np.sin(theta)])\n            p = p0.copy()\n            \n            is_converged = False\n            iterations_for_path = 0\n\n            # Newton's method loop\n            for i in range(M + 1):\n                # 1. Check for divergence (leaving a large ball around the origin)\n                if np.linalg.norm(p)  R_max:\n                    break\n\n                # 2. Check for convergence\n                # Criterion 2a: Residual norm is small\n                if np.linalg.norm(f(p)) = tau_f:\n                    iterations_for_path = i\n                    is_converged = True\n                    break\n                \n                # Criterion 2b: Proximity to an exact root is small\n                dist_to_roots = np.linalg.norm(p - roots, axis=1)\n                if np.min(dist_to_roots) = tau_r:\n                    iterations_for_path = i\n                    is_converged = True\n                    break\n\n                # 3. If max iterations reached, the path has not converged\n                if i == M:\n                    break\n                \n                # 4. Perform the Newton iteration step\n                x, y = p\n                \n                # Denominator part corresponds to |z|^2, where z=x+iy\n                denom_part = x**2 + y**2\n                \n                # Handle singularity at the origin (z=0)\n                if denom_part  1e-24: # Effectively zero, prevent division by zero\n                    break\n                    \n                denom = 3.0 * denom_part**2\n                \n                # Update formulas derived in the solution\n                x_new = (2.0 / 3.0) * x + (x**2 - y**2) / denom\n                y_new = (2.0 / 3.0) * y - (2.0 * x * y) / denom\n                \n                p = np.array([x_new, y_new])\n\n            if is_converged:\n                converged_count += 1\n                total_iters += iterations_for_path\n        \n        # Calculate the required metrics for the current epsilon\n        if converged_count  0:\n            mean_iters = float(total_iters) / converged_count\n        else:\n            # As per problem specification\n            mean_iters = float(M)\n            \n        conv_frac = float(converged_count) / K\n        \n        mean_iters_list.append(mean_iters)\n        conv_frac_list.append(conv_frac)\n\n    # Format the final output string exactly as required\n    mean_iters_str = ','.join(map(str, mean_iters_list))\n    conv_frac_str = ','.join(map(str, conv_frac_list))\n    \n    print(f\"[[{mean_iters_str}],[{conv_frac_str}]]\")\n\nsolve()\n```", "id": "3280962"}]}