{"hands_on_practices": [{"introduction": "延续法的应用远不止于简单的代数方程组，它们是求解复杂问题的强大工具，例如由微分方程产生的边界值问题（BVP）。本练习将指导你应用“自然参数延续法”来求解一个经过有限差分法离散化的非线性BVP [@problem_id:3217870]。通过这个实践，你将学习如何将连续问题转化为大型非线性系统 $\\mathbf{F}(\\mathbf{u},\\lambda)=\\mathbf{0}$，并使用最直观的延续策略——逐步改变参数 $\\lambda$ 并求解，这为后续更高级技术的学习奠定了基础。", "problem": "考虑定义在闭区间 $[0,1]$ 上，关于未知函数 $u(x)$ 的一维边值问题 (BVP)，其微分方程为\n$$u''(x) + \\lambda\\,u(x) + u(x)^3 = \\sin(\\pi x),\\quad x \\in (0,1),$$\n以及齐次狄利克雷边界条件\n$$u(0) = 0,\\quad u(1) = 0.$$\n参数 $\\lambda$ 显式地出现在微分方程中，并作为延拓参数。方程右侧正弦函数的参数使用弧度制。目标是使用参数 $\\lambda$ 的延拓法，为该 BVP 在 $\\lambda$ 的不同目标值下构建数值解。\n\n从基准参数值 $\\lambda_0 = 0$ 开始，实现一个参数延拓方案，将 $\\lambda$ 从 $\\lambda_0$ 逐步改变到指定的目标值 $\\lambda_{\\text{end}}$。在每个中间参数值处，使用牛顿法求解离散化的非线性系统。计算方法必须源自基本且广泛接受的数值原理：\n\n- 在 $[0,1]$ 上使用包含 $N$ 个内部点的均匀网格。记网格间距为 $h = \\frac{1}{N+1}$，内部网格点为 $x_i = i\\,h$，其中 $i = 1,2,\\dots,N$。\n- 对内部点，使用标准三点中心有限差分公式近似二阶导数 $u''(x)$：\n$$u''(x_i) \\approx \\frac{u_{i-1} - 2\\,u_i + u_{i+1}}{h^2},$$\n其中 $u_i \\approx u(x_i)$，边界值为 $u_0 = 0$ 和 $u_{N+1} = 0$。\n- 构建长度为 $N$ 的离散残差向量 $\\mathbf{F}(\\mathbf{u},\\lambda)$，其分量为\n$$F_i(\\mathbf{u},\\lambda) = \\frac{u_{i-1} - 2\\,u_i + u_{i+1}}{h^2} + \\lambda\\,u_i + u_i^3 - \\sin(\\pi x_i),\\quad i = 1,\\dots,N.$$\n- 在每个延拓步中使用牛顿法求解 $\\mathbf{F}(\\mathbf{u},\\lambda) = \\mathbf{0}$，其雅可比矩阵元由有限差分模板和非线性项的导数导出：\n$$\\frac{\\partial F_i}{\\partial u_{i}} = -\\frac{2}{h^2} + \\lambda + 3\\,u_i^2,\\quad \\frac{\\partial F_i}{\\partial u_{i-1}} = \\frac{1}{h^2},\\quad \\frac{\\partial F_i}{\\partial u_{i+1}} = \\frac{1}{h^2},$$\n其他位置的元素为零。如有必要，实现阻尼或回溯策略以确保牛顿法稳健收敛。\n\n延拓方案必须是自然参数类型：在 $\\lambda$ 上从 $\\lambda_0 = 0$ 到目标值 $\\lambda_{\\text{end}}$ 取均匀步长，并将上一步的收敛解作为下一步牛顿法的初始猜测。\n\n对于下述每个测试用例，在达到目标参数 $\\lambda_{\\text{end}}$ 并获得收敛的离散解 $\\mathbf{u}$ 后，报告解在中点 $x = \\frac{1}{2}$ 处的值。如果 $\\frac{1}{2}$ 不恰好是网格点，则使用相邻网格点之间的线性插值来近似 $u\\!\\left(\\frac{1}{2}\\right)$。将最终报告的值四舍五入到 $6$ 位小数。本问题不涉及物理单位。$\\sin(\\pi x)$ 中出现的角度必须以弧度处理。\n\n编程求解以下测试套件：\n\n- 测试用例 1：$\\lambda_{\\text{end}} = 0$，$N = 100$，延拓步数 $= 10$。\n- 测试用例 2：$\\lambda_{\\text{end}} = 4$，$N = 120$，延拓步数 $= 20$。\n- 测试用例 3：$\\lambda_{\\text{end}} = -4$，$N = 120$，延拓步数 $= 20$。\n- 测试用例 4：$\\lambda_{\\text{end}} = 9$，$N = 150$，延拓步数 $= 30$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[result_1,result_2,result_3,result_4]$），其中每个 $result_k$ 是对应测试用例的 $u\\!\\left(\\frac{1}{2}\\right)$ 值，四舍五入到 $6$ 位小数。", "solution": "用户提供了一个定义明确的一维非线性边值问题 (BVP)，并指定了基于参数延拓的数值求解方法。\n\n### 步骤 1：提取已知条件\n-   **微分方程**：$u''(x) + \\lambda\\,u(x) + u(x)^3 = \\sin(\\pi x)$，对于 $x \\in (0,1)$。\n-   **边界条件**：$u(0) = 0$, $u(1) = 0$。\n-   **延拓参数**：$\\lambda$。\n-   **参数范围**：从 $\\lambda_0 = 0$ 开始，逐步推进到目标值 $\\lambda_{\\text{end}}$。\n-   **离散化**：在具有 $N$ 个内部点的均匀网格上使用有限差分法。\n-   **网格细节**：间距 $h = \\frac{1}{N+1}$，内部点 $x_i = i\\,h$，其中 $i=1, \\dots, N$。\n-   **有限差分公式**：$u''(x_i) \\approx \\frac{u_{i-1} - 2\\,u_i + u_{i+1}}{h^2}$，边界值为 $u_0 = u_{N+1} = 0$。\n-   **离散残差系统**：$\\mathbf{F}(\\mathbf{u},\\lambda) = \\mathbf{0}$，其分量为\n    $F_i(\\mathbf{u},\\lambda) = \\frac{u_{i-1} - 2\\,u_i + u_{i+1}}{h^2} + \\lambda\\,u_i + u_i^3 - \\sin(\\pi x_i)$，其中 $i=1, \\dots, N$。\n-   **雅可比矩阵元**：雅可比矩阵 $J_{ij} = \\frac{\\partial F_i}{\\partial u_j}$ 的非零元素为：\n    -   $J_{ii} = \\frac{\\partial F_i}{\\partial u_i} = -\\frac{2}{h^2} + \\lambda + 3\\,u_i^2$。\n    -   $J_{i,i-1} = \\frac{\\partial F_i}{\\partial u_{i-1}} = \\frac{1}{h^2}$。\n    -   $J_{i,i+1} = \\frac{\\partial F_i}{\\partial u_{i+1}} = \\frac{1}{h^2}$。\n-   **数值方法**：\n    1.  **延拓**：采用自然参数延拓，在 $\\lambda$ 上分指定的均匀步数。\n    2.  **非线性求解器**：在每个 $\\lambda$ 步上使用牛顿法。在给定 $\\lambda_k$ 时，牛顿法的初始猜测是前一个参数值 $\\lambda_{k-1}$ 的收敛解。\n-   **输出**：对于每个测试用例，报告解 $u(x)$ 在 $x = \\frac{1}{2}$ 处的值，四舍五入到 $6$ 位小数。如果 $x = \\frac{1}{2}$ 不是网格点，则使用线性插值。\n-   **测试用例**：\n    -   用例 1：$\\lambda_{\\text{end}} = 0$，$N = 100$，步数 $= 10$。\n    -   用例 2：$\\lambda_{\\text{end}} = 4$，$N = 120$，步数 $= 20$。\n    -   用例 3：$\\lambda_{\\text{end}} = -4$，$N = 120$，步数 $= 20$。\n    -   用例 4：$\\lambda_{\\text{end}} = 9$，$N = 150$，步数 $= 30$。\n\n### 步骤 2：使用提取的已知条件进行验证\n对问题进行严格的验证检查。\n\n-   **科学依据**：该问题是数值分析中的一个标准练习，涉及非线性 BVP 的求解。所规定的方法——有限差分法、牛顿法和参数延拓法——是科学计算中基本且成熟的技术。该问题在科学上和数学上是合理的。\n-   **适定性**：从计算角度来看，该问题是适定的。它提供了数学模型、离散化方案、非线性求解算法、延拓策略以及初始状态（对于基准情况 $\\lambda=0$，隐式地给定了初始猜测 $\\mathbf{u}=\\mathbf{0}$）的完整说明。这种详细的指导确保了可以构建一个唯一的计算过程。\n-   **客观性**：该问题以精确、客观的数学术语陈述，没有歧义、主观性或非科学性主张。\n\n该问题没有任何缺陷。测试用例中 $\\lambda_{\\text{end}} = \\lambda_0 = 0$ 的情况对于延拓问题来说不常见，但并非无效；它只是简化为在 $\\lambda=0$ 处求解一次 BVP。指示是完整和一致的。\n\n### 步骤 3：结论与行动\n问题是**有效的**。将根据指定的数值方法构建解决方案。\n\n### 解决方案设计\n\n实现将按以下结构进行：\n\n1.  **主函数 `solve()`**：该函数协调整个过程。它将定义测试用例，遍历它们，为每个用例调用延拓求解器，计算所需的输出值，格式化它，并以指定格式打印收集到的结果。\n\n2.  **延拓函数 `perform_continuation()`**：该函数实现自然参数延拓。\n    -   它将生成一个从 $\\lambda_0 = 0$ 到 $\\lambda_{\\text{end}}$ 的 $\\lambda$ 值序列，步数均匀且已指定。\n    -   它将解向量 $\\mathbf{u}$ 初始化为零，作为在 $\\lambda_0$ 处第一次牛顿求解的初始猜测。\n    -   然后，它遍历 $\\lambda$ 序列。在每次迭代中，它调用牛顿求解器，并将上一个 $\\lambda$ 步的收敛解作为当前步的初始猜测。\n\n3.  **牛顿法函数 `newton_solver()`**：该函数对固定的 $\\lambda$ 求解非线性系统 $\\mathbf{F}(\\mathbf{u}, \\lambda) = \\mathbf{0}$。\n    -   它迭代地改进初始猜测 $\\mathbf{u}_{\\text{guess}}$。\n    -   在每次迭代中，它计算残差向量 $\\mathbf{F}(\\mathbf{u}_k, \\lambda)$ 和雅可比矩阵 $J(\\mathbf{u}_k, \\lambda)$。\n    -   然后，它求解线性系统 $J(\\mathbf{u}_k) \\Delta \\mathbf{u}_k = -\\mathbf{F}(\\mathbf{u}_k)$ 以获得更新向量 $\\Delta \\mathbf{u}_k$。\n    -   解通过 $\\mathbf{u}_{k+1} = \\mathbf{u}_k + \\Delta \\mathbf{u}_k$ 进行更新。\n    -   当残差的范数低于指定的容差时，循环终止。\n\n4.  **残差和雅可比矩阵的辅助函数**：\n    -   `calculate_residual()`：根据给定公式计算残差向量 $\\mathbf{F}$。为了提高效率，将使用向量化的 `numpy` 操作实现。\n    -   `calculate_jacobian()`：构建三对角雅可比矩阵 $J$。这也将使用 `numpy` 的稀疏矩阵构建功能高效实现。\n\n5.  **输出计算**：在延拓过程在 $\\lambda_{\\text{end}}$ 处产生最终解向量 $\\mathbf{u}_{\\text{final}}$ 后，确定物理中点 $x=0.5$ 处的值。\n    -   计算对应的非整数网格索引 $j_{\\text{ideal}} = \\frac{0.5}{h} - 1$（在0-based索引中）。\n    -   如果 $j_{\\text{ideal}}$ （接近）一个整数，则直接从解向量中取值。\n    -   否则，在两个包围的网格点之间执行线性插值。\n\n最终代码将是一个独立的 Python 脚本，并遵守指定的环境约束。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_residual(u, lam, N, h_sq, rhs_forcing):\n    \"\"\"\n    Calculates the residual vector F(u, lambda) for the discretized BVP.\n\n    The residual F represents the system of N nonlinear equations F_i = 0.\n    \"\"\"\n    # Pad the solution vector u with boundary conditions u(0)=0 and u(1)=0.\n    u_padded = np.concatenate(([0.0], u, [0.0]))\n    \n    # Approximate the second derivative u_xx using a centered finite difference stencil.\n    laplacian_u = (u_padded[:-2] - 2 * u_padded[1:-1] + u_padded[2:]) / h_sq\n    \n    # Assemble the full residual vector F_i = u_xx + lambda*u_i + u_i^3 - f_i.\n    F = laplacian_u + lam * u + u**3 - rhs_forcing\n    return F\n\ndef calculate_jacobian(u, lam, N, h_sq):\n    \"\"\"\n    Calculates the Jacobian matrix J of the residual vector F with respect to u.\n\n    The Jacobian is a tridiagonal matrix required for Newton's method.\n    \"\"\"\n    # The main diagonal of the Jacobian: dF_i/du_i = -2/h^2 + lambda + 3*u_i^2.\n    diag_vals = -2.0 / h_sq + lam + 3.0 * u**2\n    \n    # The off-diagonal entries are constant: dF_i/du_{i-1} = dF_i/du_{i+1} = 1/h^2.\n    off_diag_val = 1.0 / h_sq\n    \n    # Construct the tridiagonal Jacobian matrix using numpy's diag function.\n    J = np.diag(diag_vals)\n    if N > 1:\n        off_diag_entries = np.full(N - 1, off_diag_val)\n        J += np.diag(off_diag_entries, k=1)\n        J += np.diag(off_diag_entries, k=-1)\n        \n    return J\n\ndef newton_solver(u_guess, lam, N, h, rhs_forcing, tol=1e-9, max_iter=50):\n    \"\"\"\n    Solves the nonlinear system F(u, lambda) = 0 using Newton's method.\n    \"\"\"\n    u = u_guess.copy()\n    h_sq = h * h\n    \n    for _ in range(max_iter):\n        # 1. Calculate the residual vector F(u_k)\n        F = calculate_residual(u, lam, N, h_sq, rhs_forcing)\n        \n        # 2. Check for convergence using the infinity norm of the residual.\n        if np.linalg.norm(F, np.inf)  tol:\n            return u\n            \n        # 3. Calculate the Jacobian matrix J(u_k)\n        J = calculate_jacobian(u, lam, N, h_sq)\n        \n        # 4. Solve the linear system J * delta_u = -F for the update step.\n        delta_u = np.linalg.solve(J, -F)\n        \n        # 5. Update the solution vector: u_{k+1} = u_k + delta_u.\n        u += delta_u\n        \n    # Assumption: Newton's method converges for the given parameters.\n    return u\n\ndef perform_continuation(lambda_end, N, num_steps):\n    \"\"\"\n    Implements natural parameter continuation to solve the BVP at a target lambda.\n    \"\"\"\n    lambda_start = 0.0\n    \n    if np.isclose(lambda_end, lambda_start):\n        # If lambda does not change, only one solve is needed at lambda_start.\n        lambda_sequence = [lambda_start]\n    else:\n        # Create a sequence of lambda values from start to end.\n        # `num_steps` implies `num_steps + 1` total points in the sequence.\n        lambda_sequence = np.linspace(lambda_start, lambda_end, num_steps + 1)\n\n    # Set up the computational grid and the forcing term sin(pi*x).\n    h = 1.0 / (N + 1)\n    x_grid = np.linspace(h, 1.0 - h, N)\n    rhs_forcing = np.sin(np.pi * x_grid)\n    \n    # The initial guess for the very first step (at lambda_start=0) is the zero vector.\n    u = np.zeros(N)\n    \n    # Iterate through the lambda sequence. The converged solution from the previous\n    # step serves as the initial guess for the current step.\n    for lam in lambda_sequence:\n        u = newton_solver(u, lam, N, h, rhs_forcing)\n        \n    return u\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (lambda_end, N, num_steps)\n        (0.0, 100, 10),\n        (4.0, 120, 20),\n        (-4.0, 120, 20),\n        (9.0, 150, 30),\n    ]\n\n    results = []\n    for lambda_end, N, num_steps in test_cases:\n        # Run the continuation method to get the final solution vector at lambda_end.\n        u_final = perform_continuation(lambda_end, N, num_steps)\n        \n        # Interpolate the solution at the midpoint x = 0.5.\n        # The ideal 0-based array index for x=0.5 is j_ideal = 0.5/h - 1.\n        h = 1.0 / (N + 1)\n        j_ideal = 0.5 * (N + 1) - 1.0\n        j_low = int(np.floor(j_ideal))\n\n        # Check if x=0.5 falls exactly on a grid point.\n        if np.isclose(j_ideal, j_low):\n            # No interpolation needed.\n            u_midpoint = u_final[j_low]\n        else:\n            # Perform linear interpolation between the two bracketing points.\n            j_high = j_low + 1\n            fractional_part = j_ideal - j_low\n            u_low_val = u_final[j_low]\n            u_high_val = u_final[j_high]\n            u_midpoint = (1.0 - fractional_part) * u_low_val + fractional_part * u_high_val\n        \n        # Format the result to 6 decimal places and add to the list.\n        results.append(f\"{u_midpoint:.6f}\")\n    \n    # Print the final output in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3217870"}, {"introduction": "虽然自然参数延续法很直观，但当解路径遇到“转折点”（即参数 $\\lambda$ 无法再作为良好局部坐标的奇点）时，该方法便会失效。本练习将直面这一核心挑战，指导你从零开始实现一个更稳健的“预测-校正”算法，该算法采用伪弧长参数化来追踪解曲线 [@problem_id:3282840]。掌握这一核心算法对于可靠地追踪复杂的解流形至关重要，是延续法工具箱中的关键技术。", "problem": "考虑参数化非线性系统 $F(x,\\lambda)=0$，其中 $x\\in\\mathbb{R}^2$，$\\lambda\\in\\mathbb{R}$，且 $F:\\mathbb{R}^2\\times\\mathbb{R}\\to\\mathbb{R}^2$ 定义为\n$$\nF_1(x,\\lambda) = x_1^3 - x_1 + x_2,\\quad F_2(x,\\lambda) = x_2 + \\lambda - x_1^2.\n$$\n$F$ 关于 $x$ 在 $(x,\\lambda)$ 处的雅可比矩阵记为 $\\dfrac{\\partial F}{\\partial x}(x,\\lambda)$，关于 $\\lambda$ 的偏导数记为 $\\dfrac{\\partial F}{\\partial \\lambda}(x,\\lambda)$。您的任务是实现一种使用预测-校正格式的延拓方法，以追踪满足 $F(x,\\lambda)=0$ 的三元组 $(x,\\lambda)$ 的解曲线。该方法必须明确使用雅可比矩阵来计算局部线性化并执行校正。\n\n基本原理和约束：\n- 使用雅可比矩阵和非线性系统线性化的定义，在有效解 $(x,\\lambda)$ 处构造解流形的局部切线方向。从概念上讲，切线方向由以下要求定义：沿其移动能保持约束 $F(x,\\lambda)=0$ 的一阶有效性。\n- 使用基于牛顿法的校正步，该方法应用于一个增广系统，该系统既强制执行原始约束，又强制执行一个定义沿所选切线方向运动的标量约束。\n- 使用基于线性代数和雅可比矩阵的数值稳定方法计算任何所需的零空间方向。\n\n算法要求：\n- 实现一个预测步，该步骤使用预先选择的步长，沿局部计算的切线方向推进近似解。\n- 实现一个校正步，该步骤将牛顿法应用于一个由原始约束和一个标量弧长类约束构成的增广系统，该标量约束将运动固定在由切线定义的预测超平面上。\n- 使用雅可比矩阵 $\\dfrac{\\partial F}{\\partial x}(x,\\lambda)$ 和 $\\dfrac{\\partial F}{\\partial \\lambda}(x,\\lambda)$ 来组装切线计算和牛顿校正器所需的线性系统。\n- 为保证鲁棒性，如果直接求解牛顿系统因接近奇异而失败，则使用与线性化一致的最小二乘替代方案。\n\n测试套件：\n实现您的程序以运行以下三种测试情况，每种情况由一个满足 $F(x_0,\\lambda_0)=0$ 的初始解 $(x_0,\\lambda_0)$、一个步长 $\\Delta s$、延拓步数 $N$ 以及牛顿求解器参数（容差 $\\varepsilon$ 和最大迭代次数 $k_{\\max}$）指定。此问题中不出现角度，因此不需要角度单位。此问题中没有物理单位。\n\n- 情况 $1$（常规顺利路径）：\n  - 初始解：$x_0 = (0.0, 0.0)$，$\\lambda_0 = 0.0$。\n  - 步长：$\\Delta s = 0.2$。\n  - 步数：$N = 12$。\n  - 牛顿容差：$\\varepsilon = 10^{-12}$。\n  - 最大牛顿迭代次数：$k_{\\max} = 20$。\n\n- 情况 $2$（接近一个转折点，在该点局部参数延拓会失败）：\n  - 初始解：$x_0 = (0.3, 0.273)$，$\\lambda_0 = -0.183$。\n  - 步长：$\\Delta s = 0.1$。\n  - 步数：$N = 20$。\n  - 牛顿容差：$\\varepsilon = 10^{-12}$。\n  - 最大牛顿迭代次数：$k_{\\max} = 20$。\n\n- 情况 $3$（接近另一个转折点）：\n  - 初始解：$x_0 = (-0.8, -0.288)$，$\\lambda_0 = 0.928$。\n  - 步长：$\\Delta s = 0.1$。\n  - 步数：$N = 15$。\n  - 牛顿容差：$\\varepsilon = 10^{-12}$。\n  - 最大牛顿迭代次数：$k_{\\max} = 25$。\n\n答案规格：\n- 对于每种情况，运行延拓方法恰好 $N$ 个预测-校正步，并返回最终的三元组 $(x_{\\text{end}},\\lambda_{\\text{end}})$。\n- 将每个最终三元组表示为包含三个实数的列表 $[x_{1,\\text{end}}, x_{2,\\text{end}}, \\lambda_{\\text{end}}]$，其中每个数字都四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含所有三种情况的结果，形式为一个逗号分隔的列表，并用方括号括起来，每种情况的结果本身也是一个用方括号括起来的逗号分隔列表。例如，格式必须完全像 $[[a_1,a_2,a_3],[b_1,b_2,b_3],[c_1,c_2,c_3]]$，其中每个 $a_i$、$b_i$ 和 $c_i$ 都是四舍五入到六位小数的浮点数。\n\n科学真实性与推导期望：\n- 从雅可比矩阵和 $F(x,\\lambda)=0$ 线性化的核心定义出发，论证基于解点处切线方向的预测步的合理性。\n- 通过构建一个增广系统来论证校正步的合理性，该系统强制执行原始约束和一个定义在与基于切线的预测正交的超平面内运动的标量约束。\n- 推导使用稳定线性代数（例如奇异值分解，首次出现时定义为 Singular Value Decomposition (SVD)）的必要性，以便即使在折叠点附近也能获得可靠的切线方向，并解释增广牛顿步如何克服 $\\dfrac{\\partial F}{\\partial x}(x,\\lambda)$ 在转折点处的奇异性。", "solution": "该问题要求实现一种预测-校正延拓方法，以追踪一个参数化非线性系统的解曲线。该系统定义为 $F(x,\\lambda)=0$，其中 $x \\in \\mathbb{R}^2$，$\\lambda \\in \\mathbb{R}$，函数 $F:\\mathbb{R}^2\\times\\mathbb{R}\\to\\mathbb{R}^2$ 由下式给出\n$$\nF(x,\\lambda) = \\begin{pmatrix} F_1(x,\\lambda) \\\\ F_2(x,\\lambda) \\end{pmatrix} = \\begin{pmatrix} x_1^3 - x_1 + x_2 \\\\ x_2 + \\lambda - x_1^2 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}.\n$$\n解集 $(x_1, x_2, \\lambda)$ 在 $\\mathbb{R}^3$ 中构成一个一维流形（一条曲线）。目标是数值地追踪这条曲线。为方便起见，我们定义一个统一的状态向量 $y = (x_1, x_2, \\lambda)^T \\in \\mathbb{R}^3$，从而系统可以紧凑地写为 $F(y)=0$，其中 $F: \\mathbb{R}^3 \\to \\mathbb{R}^2$。\n\n延拓方法的基础在于解曲线的局部几何特性。通过对恒等式 $F(y(s))=0$ 关于弧长参数 $s$求导，我们得到条件 $DF(y(s))\\frac{dy}{ds} = 0$，其中 $DF(y)$ 是 $F$ 关于 $y$ 的雅可比矩阵。这意味着曲线的切向量 $\\tau = \\frac{dy}{ds}$ 必须位于雅可比矩阵 $DF(y)$ 的零空间中。对于给定的系统，雅可比矩阵是一个 $2 \\times 3$ 矩阵：\n$$\nDF(y) = \\left[ \\frac{\\partial F}{\\partial x} \\middle| \\frac{\\partial F}{\\partial \\lambda} \\right] = \\begin{pmatrix} \\frac{\\partial F_1}{\\partial x_1}  \\frac{\\partial F_1}{\\partial x_2}  \\frac{\\partial F_1}{\\partial \\lambda} \\\\ \\frac{\\partial F_2}{\\partial x_1}  \\frac{\\partial F_2}{\\partial x_2}  \\frac{\\partial F_2}{\\partial \\lambda} \\end{pmatrix} = \\begin{pmatrix} 3x_1^2 - 1  1  0 \\\\ -2x_1  1  1 \\end{pmatrix}.\n$$\n假设 $DF(y)$ 具有满秩（秩为 2），其零空间是一维的，从而唯一地定义了点 $y$ 处的切线方向。\n\n该算法分两个主要步骤进行：预测步和校正步。\n\n**预测步**：\n给定曲线上一个已知的解点 $y_k$，预测步通过沿切线方向 $\\tau_k$ 前进一个固定距离 $\\Delta s$ 来外插到一个近似的下一点 $y_{k+1}^*$。\n$$\ny_{k+1}^* = y_k + \\Delta s \\cdot \\tau_k.\n$$\n切向量 $\\tau_k$ 计算为 $DF(y_k)$ 零空间的归一化基向量。找到这个向量的一种数值稳健的方法是奇异值分解 (SVD)。对于矩阵 $DF(y_k) = U \\Sigma V^T$，正交矩阵 $V$ 的最后一列（对应于最小的奇异值）提供了零空间的一个基。因此，我们将 $\\tau_k$ 设为该向量。为确保延拓方法沿一致的方向遍历曲线，$\\tau_k$ 的符号选择应使其与前一个切向量 $\\tau_{k-1}$ 的点积为非负：$\\tau_k^T \\tau_{k-1} \\ge 0$。对于初始步（$k=0$），常规选择是定向 $\\tau_0$，使其 $\\lambda$ 分量在可能的情况下为非负。\n\n**校正步**：\n预测点 $y_{k+1}^*$ 通常不满足 $F(y_{k+1}^*)=0$。校正步对该预测进行精化，以在其附近找到一个真实的解点 $y_{k+1}$。为确保局部解的唯一性，我们施加一个额外的约束。在伪弧长延拓方法中，此约束强制最终点 $y_{k+1}$ 位于通过 $y_{k+1}^*$ 且与切向量 $\\tau_k$ 正交的超平面上。该约束的数学形式为：\n$$\n\\tau_k^T (y_{k+1} - y_{k+1}^*) = 0.\n$$\n该方程与原始系统 $F(y_{k+1})=0$ 相结合，构成一个包含 $y_{k+1}$ 中 $3$ 个未知数的 $3$ 个方程的增广方阵系统。令 $y \\equiv y_{k+1}$，我们求解系统 $G(y)=0$：\n$$\nG(y) = \\begin{pmatrix} F(y) \\\\ \\tau_k^T (y - y_{k+1}^*) \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}.\n$$\n该系统使用牛顿法求解，以预测点 $y_{k+1}^*$ 作为初始猜测。牛顿迭代定义为 $y^{(j+1)} = y^{(j)} - [DG(y^{(j)})]^{-1} G(y^{(j)})$，其中 $DG(y)$ 是增广系统的雅可比矩阵：\n$$\nDG(y) = \\begin{pmatrix} DF(y) \\\\ \\tau_k^T \\end{pmatrix} = \\begin{pmatrix} 3x_1^2 - 1  1  0 \\\\ -2x_1  1  1 \\\\ (\\tau_k)_1  (\\tau_k)_2  (\\tau_k)_3 \\end{pmatrix}.\n$$\n此公式的一个关键特性是，即使在解曲线的转折点（状态空间雅可比矩阵 $\\frac{\\partial F}{\\partial x}$ 变为奇异），增广雅可比矩阵 $DG(y)$ 通常也是非奇异的。这使得该方法能够追踪曲线通过折叠点，而更简单的方法（如自然参数延拓）在这些点会失败。根据问题的鲁棒性要求，牛顿步的线性系统 $DG(y^{(j)}) \\Delta y = -G(y^{(j)})$ 使用最小二乘法求解，以处理潜在的数值不稳定性或病态条件。迭代过程持续进行，直到残差的欧几里得范数 $\\|G(y^{(j)})\\|_2$ 小于给定的容差 $\\varepsilon$。收敛的点被接受为解曲线上的下一个点 $y_{k+1}$。这个预测-校正循环重复指定的步数 $N$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a predictor-corrector continuation method to trace solution curves\n    of a parameterized nonlinear system F(x, lambda) = 0.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general happy path)\n        {'y0': [0.0, 0.0, 0.0], 'ds': 0.2, 'N': 12, 'tol': 1e-12, 'k_max': 20},\n        # Case 2 (near a turning point)\n        {'y0': [0.3, 0.273, -0.183], 'ds': 0.1, 'N': 20, 'tol': 1e-12, 'k_max': 20},\n        # Case 3 (approaching another turning point)\n        {'y0': [-0.8, -0.288, 0.928], 'ds': 0.1, 'N': 15, 'tol': 1e-12, 'k_max': 25},\n    ]\n\n    def F_func(y):\n        \"\"\"Computes the value of the nonlinear system F(y).\"\"\"\n        x1, x2, lam = y\n        F1 = x1**3 - x1 + x2\n        F2 = x2 + lam - x1**2\n        return np.array([F1, F2])\n\n    def DF_func(y):\n        \"\"\"Computes the 2x3 Jacobian matrix DF(y).\"\"\"\n        x1, _, _ = y\n        return np.array([\n            [3 * x1**2 - 1, 1, 0],\n            [-2 * x1, 1, 1]\n        ])\n\n    def run_continuation(y0, ds, N, tol, k_max):\n        \"\"\"\n        Executes the continuation algorithm for a single test case.\n\n        Args:\n            y0 (list): Initial solution [x1, x2, lambda].\n            ds (float): Step size along the curve.\n            N (int): Number of continuation steps.\n            tol (float): Tolerance for Newton's method convergence.\n            k_max (int): Maximum iterations for Newton's method.\n\n        Returns:\n            np.ndarray: The final solution point after N steps.\n        \"\"\"\n        y_current = np.array(y0, dtype=float)\n        # To maintain direction, we store the previous tangent.\n        # An initial orientation that favors increasing lambda helps start the process.\n        tau_prev = np.array([0.0, 0.0, 1.0])\n\n        for _ in range(N):\n            # --- Predictor Step ---\n            DF_current = DF_func(y_current)\n            \n            # Use Singular Value Decomposition (SVD) to find the null space of the 2x3 Jacobian.\n            # The null space is 1D and its basis vector is our tangent.\n            # For DF = U * Sigma * Vh, the last row of Vh (V transpose) is the normalized vector \n            # spanning the null space.\n            _, _, Vh = np.linalg.svd(DF_current)\n            tau_current = Vh[-1, :]\n            \n            # Orient the tangent vector to prevent the path from reversing.\n            if np.dot(tau_current, tau_prev)  0:\n                tau_current = -tau_current\n            tau_prev = tau_current\n\n            # Predict the next point along the tangent.\n            y_pred = y_current + ds * tau_current\n\n            # --- Corrector Step ---\n            # Use Newton's method to solve the augmented system G(y) = 0.\n            # G(y) = [F(y); tau^T * (y - y_pred)]\n            y_j = y_pred.copy()\n            \n            for _ in range(k_max):\n                F_val = F_func(y_j)\n                g_val = np.dot(tau_current, y_j - y_pred)\n                G_val = np.append(F_val, g_val)\n                \n                if np.linalg.norm(G_val)  tol:\n                    break  # Convergence achieved\n\n                # Jacobian of the augmented system DG(y)\n                DF_j = DF_func(y_j)\n                DG_j = np.vstack([DF_j, tau_current])\n\n                # Solve the linear system DG * delta_y = -G for the Newton step.\n                # np.linalg.lstsq is used for robustness as requested, handling near-singular cases.\n                delta_y = np.linalg.lstsq(DG_j, -G_val, rcond=None)[0]\n                \n                y_j += delta_y\n            \n            y_current = y_j  # Update point for the next continuation step\n        \n        return y_current\n\n    results = []\n    for case in test_cases:\n        y0, ds, N, tol, k_max = case['y0'], case['ds'], case['N'], case['tol'], case['k_max']\n        final_y = run_continuation(y0, ds, N, tol, k_max)\n        \n        # Format the result as a string with 6 decimal places.\n        rounded_y_str = [f\"{val:.6f}\" for val in final_y]\n        results.append(f\"[{','.join(rounded_y_str)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3282840"}, {"introduction": "在非线性系统中，解曲线可能在“分岔点”相交，从而产生多个解分支。本练习的目标超越了简单地追踪单一曲线，旨在教授如何在分岔点进行“分支切换” [@problem_id:3217736]。你将学习一种实用的技术——引入一个微扰辅助系统，从一个已知的解分支跳转到一个新的、非平凡的分支上。这是探索非线性系统完整解空间的必备高级技能。", "problem": "要求您在连续方法的框架内，通过使用一个微扰辅助系统，在一个简单的叉式分岔点上实现一个分支切换算法。考虑由标量残差给出的、包含两个变量 $u$ 和 $\\lambda$ 的非线性代数方程\n$$\nF(u,\\lambda) = \\lambda\\,u - u^3,\n$$\n该方程具有对称性 $u \\mapsto -u$，并在点 $(u,\\lambda)=(0,0)$ 处呈现一个简单的叉式分岔。您的任务是编写一个完整、可运行的程序，该程序能够：\n- 实现伪弧长连续法来追踪 $F(u,\\lambda)=0$ 的解曲线。\n- 通过求解一个带有微小目标值 $u=\\sigma$ 的微扰辅助系统，在分岔点进行分支切换，以播种非平凡分支。\n- 沿着选定的非平凡分支进行连续，并计算在预设的目标参数值 $\\lambda_{\\text{target}}$ 下对应的解值 $u$。\n\n推导必须从基本的数值分析原理和核心定义出发：\n- 连续方法是一种系统性的过程，通过沿着一条解曲线步进并通过求解局部适定问题进行校正，来追踪非线性方程的解流形。\n- 伪弧长方法通过一个线性化的弧长约束来增广非线性系统，以在原始变量的雅可比矩阵接近奇异时正则化校正步。\n- 在对称破缺的叉式分岔附近的分支切换事件可以通过施加一个辅助约束来引发，该约束会扰动对称平衡，例如，将状态变量 $u$ 固定为一个微小的非零目标值 $u=\\sigma$。\n\n您必须实现以下算法组件：\n1. 构建微扰辅助系统\n$$\nG(u,\\lambda;\\sigma) = \\begin{bmatrix}\nF(u,\\lambda)\\\\\nu - \\sigma\n\\end{bmatrix} = \\begin{bmatrix}\n\\lambda\\,u - u^3\\\\\nu - \\sigma\n\\end{bmatrix},\n$$\n并用牛顿法求解，以获得非平凡分支上的一个种子点 $(u_0,\\lambda_0)$。$\\sigma$ 的符号选择分支。\n2. 对于连续，给定当前解 $(u_k,\\lambda_k)$，利用切线位于 $F$ 梯度零空间的基本正交条件计算解曲线的单位切线 $(t_u, t_\\lambda)$。使用固定弧长步长 $\\Delta s$ 的预测值 $(u_{\\text{pred}},\\lambda_{\\text{pred}})=(u_k,\\lambda_k) + \\Delta s\\,(t_u,t_\\lambda)$。然后应用牛顿校正法求解增广系统\n$$\nH(u,\\lambda) = \\begin{bmatrix}\nF(u,\\lambda)\\\\\nt_u (u - u_{\\text{pred}}) + t_\\lambda (\\lambda - \\lambda_{\\text{pred}})\n\\end{bmatrix} = \\mathbf{0},\n$$\n使用由 $F$ 的偏导数和切线分量组成的 $2\\times 2$ 雅可比矩阵。对切线进行归一化，并使用一个驱动 $t_\\lambda0$ 的方向以增加 $\\lambda$。\n3. 一旦您沿着分支前进，通过从最新的连续点开始，用牛顿法求解 $F(u,\\lambda_{\\text{target}})=0$ 来精化在预设的 $\\lambda_{\\text{target}}$ 处的解 $u$；保持 $u$ 的符号与由 $\\sigma$ 编码的所选分支一致。\n\n数值要求：\n- 在弧长单位下，使用固定的预测步长 $\\Delta s = 0.05$。\n- 对于每个校正和辅助求解，使用牛顿法，其停止容差为校正范数小于 $10^{-12}$，最大迭代次数为 $12$ 次。\n- 尽可能确保切线方向满足 $t_\\lambda0$，以便连续过程朝向更大的 $\\lambda$ 值进行。\n- 在输出中将最终的 $u$ 值四舍五入到六位小数。\n\n测试套件和输出规范：\n- 您的程序必须运行由 $(\\sigma, \\lambda_{\\text{target}})$ 对指定的四个测试用例，这些用例探测了不同方面，包括正负分支以及与分岔点的邻近性：\n    1. $(\\sigma, \\lambda_{\\text{target}}) = (0.01, 0.25)$。\n    2. $(\\sigma, \\lambda_{\\text{target}}) = (-0.02, 0.49)$。\n    3. $(\\sigma, \\lambda_{\\text{target}}) = (0.001, 0.0004)$。\n    4. $(\\sigma, \\lambda_{\\text{target}}) = (-0.0015, 0.0009)$。\n- 对每个测试用例，通过求解微扰辅助系统在 $(u,\\lambda)=(0,0)$ 处进行分支切换以获得 $(u_0,\\lambda_0)$，然后使用伪弧长连续步骤直到前进到或超过 $\\lambda_{\\text{target}}$，最后用单变量牛顿法在 $\\lambda=\\lambda_{\\text{target}}$ 处精化 $u$。\n- 您的程序应生成单行输出，包含四个结果 $u$ 值，四舍五入到六位小数，以逗号分隔的列表形式并用方括号括起来，例如：“[u1,u2,u3,u4]”。不允许有额外的文本或空格。\n\n不使用角度，也没有物理单位。所有数值结果必须以普通十进制浮点数形式打印。", "solution": "该问题是有效的，因为它提出了一个在数值分析领域，特别是在应用于分岔理论的连续方法领域中，具有科学依据的适定任务。所有参数、方程和算法步骤都得到了精确定义，并与已建立的数值方法一致，从而可以得到一个唯一且可验证的解。\n\n该问题要求为非线性方程 $F(u,\\lambda) = \\lambda u - u^3 = 0$ 实现一个分支切换算法，该方程在原点 $(u,\\lambda) = (0,0)$ 处呈现叉式分岔。解曲线包括一个对所有 $\\lambda$ 都成立的平凡分支 $u=0$，以及两个对 $\\lambda \\ge 0$ 成立的非平凡分支 $u = \\pm\\sqrt{\\lambda}$。目标是计算由参数 $\\sigma$ 选定的其中一个非平凡分支上的点。指定的算法包括三个主要阶段：分支播种、沿分支连续和精化到目标参数值。\n\n**1. 通过微扰辅助系统进行分支切换（播种）**\n\n在分岔点（如 $(u,\\lambda)=(0,0)$）的核心挑战是多条解分支在此相交，使得方向的选择变得模糊。标准的连续方法通常会沿着平凡分支 $u=0$ 继续。为了切换到非平凡分支，我们引入一个微扰。问题指定构建一个辅助系统 $G(u, \\lambda; \\sigma)$，它打破了原问题的对称性。这是通过施加一个约束来实现的，即解必须通过一个具有微小非零 $u$ 值（即 $u=\\sigma$）的点。\n\n该系统定义为：\n$$\nG(u,\\lambda;\\sigma) = \\begin{bmatrix}\nF(u,\\lambda)\\\\\nu - \\sigma\n\\end{bmatrix} = \\begin{bmatrix}\n\\lambda u - u^3\\\\\nu - \\sigma\n\\end{bmatrix} = \\mathbf{0}\n$$\n这个系统的解为连续过程提供了一个起始点 $(u_0, \\lambda_0)$。通过观察可知，解为 $u_0 = \\sigma$ 和 $\\lambda_0\\sigma - \\sigma^3 = 0$，对于 $\\sigma \\ne 0$，这会得到 $\\lambda_0 = \\sigma^2$。因此，种子点是 $(u_0, \\lambda_0) = (\\sigma, \\sigma^2)$。\n\n尽管可以解析求解，但问题要求使用牛顿法。对于状态向量 $\\mathbf{x} = [u, \\lambda]^T$，迭代格式为：\n$$\n\\mathbf{x}_{k+1} = \\mathbf{x}_k - [J_G(\\mathbf{x}_k)]^{-1} G(\\mathbf{x}_k; \\sigma)\n$$\n其中 $J_G$ 是 $G$ 的雅可比矩阵：\n$$\nJ_G(u, \\lambda) = \\begin{bmatrix}\n\\frac{\\partial F}{\\partial u}  \\frac{\\partial F}{\\partial \\lambda} \\\\\n1  0\n\\end{bmatrix} = \\begin{bmatrix}\n\\lambda - 3u^2  u \\\\\n1  0\n\\end{bmatrix}\n$$\n对于此牛顿求解，一个鲁棒的初始猜测是 $(\\sigma, 0)$，对于小的 $\\sigma$，该猜测接近精确解 $(\\sigma, \\sigma^2)$。\n\n**2. 伪弧长连续**\n\n一旦在期望的分支上找到了一个点 $(u_k, \\lambda_k)$，我们就使用预测-校正格式来追踪解曲线。采用伪弧长方法来处理参数化问题，特别是在转折点附近，参数 $\\lambda$ 在这些点不再是曲线的良好局部坐标。\n\n**2.1. 预测步**\n首先，我们计算在当前点 $(u_k, \\lambda_k)$ 处解曲线的切向量 $(t_u, t_\\lambda)$。解曲线是 $F(u,\\lambda)=0$ 的一个水平集，因此切向量必须与梯度向量 $\\nabla F = (\\frac{\\partial F}{\\partial u}, \\frac{\\partial F}{\\partial \\lambda})$ 正交。一个与 $(\\frac{\\partial F}{\\partial u}, \\frac{\\partial F}{\\partial \\lambda})$ 正交的向量由 $(\\frac{\\partial F}{\\partial \\lambda}, -\\frac{\\partial F}{\\partial u})$ 给出。对于我们的问题，这是：\n$$\n(t_u, t_\\lambda)_{\\text{unnormalized}} \\propto (u_k, -(\\lambda_k - 3u_k^2)) = (u_k, 3u_k^2 - \\lambda_k)\n$$\n为确保沿路径方向一致，该向量被归一化为单位长度，并且其方向被固定以使 $t_\\lambda  0$，从而在可能的情况下强制连续过程向着 $\\lambda$ 增大的方向进行。\n\n利用单位切线 $(t_u, t_\\lambda)$，通过从 $(u_k, \\lambda_k)$ 沿切线方向前进一个大小为 $\\Delta s$ 的步长，计算出预测点 $(u_{\\text{pred}}, \\lambda_{\\text{pred}})$：\n$$\n(u_{\\text{pred}}, \\lambda_{\\text{pred}}) = (u_k, \\lambda_k) + \\Delta s (t_u, t_\\lambda)\n$$\n其中 $\\Delta s = 0.05$ 是指定的弧长步长。\n\n**2.2. 校正步**\n预测点位于切线上，通常不在解曲线本身上。校正步的作用是找到曲线上附近的一个点。这被表述为求解一个增广系统 $H(u, \\lambda) = \\mathbf{0}$，该系统由原方程和一个约束条件组成，该约束条件要求校正发生在垂直于切向量的方向上，并通过预测点：\n$$\nH(u,\\lambda) = \\begin{bmatrix}\nF(u,\\lambda)\\\\\nt_u (u - u_{\\text{pred}}) + t_\\lambda (\\lambda - \\lambda_{\\text{pred}})\n\\end{bmatrix} = \\mathbf{0}\n$$\n该系统使用牛顿法求解，以 $(u_{\\text{pred}}, \\lambda_{\\text{pred}})$ 作为初始猜测。该系统的雅可比矩阵 $J_H$ 是：\n$$\nJ_H(u, \\lambda) = \\begin{bmatrix}\n\\frac{\\partial F}{\\partial u}  \\frac{\\partial F}{\\partial \\lambda} \\\\\nt_u  t_\\lambda\n\\end{bmatrix} = \\begin{bmatrix}\n\\lambda - 3u^2  u \\\\\nt_u  t_\\lambda\n\\end{bmatrix}\n$$\n这个雅可比矩阵在正则点和简单转折点处都是非奇异的，这使得伪弧长方法具有鲁棒性。这次牛顿迭代的解给出了曲线上的下一个点 $(u_{k+1}, \\lambda_{k+1})$。重复此预测-校正循环，直到参数值 $\\lambda$ 越过目标值，即 $\\lambda_{k+1} \\ge \\lambda_{\\text{target}}$。\n\n**3. 解的精化**\n\n最后的连续点，比如 $(u_c, \\lambda_c)$，满足 $\\lambda_c \\ge \\lambda_{\\text{target}}$ 但通常 $\\lambda_c \\ne \\lambda_{\\text{target}}$。为了在 $\\lambda = \\lambda_{\\text{target}}$ 处找到精确解 $u$，我们求解参数固定的原始标量方程：\n$$\nf(u) = F(u, \\lambda_{\\text{target}}) = \\lambda_{\\text{target}} u - u^3 = 0\n$$\n这是一个关于单变量 $u$ 的求根问题。它通过标量函数的牛顿法求解：\n$$\nu_{m+1} = u_m - \\frac{f(u_m)}{f'(u_m)} = u_m - \\frac{\\lambda_{\\text{target}} u_m - u_m^3}{\\lambda_{\\text{target}} - 3u_m^2}\n$$\n此次迭代的初始猜测 $u_0$ 取自最后计算出的连续点 $u_c$。这确保了迭代收敛到正在追踪的分支上的正确根（即与 $\\sigma$ 符号相同的根）。收敛后的 $u$ 值是给定测试用例的最终答案。\n\n对于测试套件中提供的每个 $(\\sigma, \\lambda_{\\text{target}})$ 对，实现将遵循这三个阶段。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants for the numerical methods\nTOL = 1e-12\nMAX_ITER = 12\nDS = 0.05\n\ndef F_func(u, lam):\n    \"\"\"The residual function F(u, lambda).\"\"\"\n    return lam * u - u**3\n\ndef dF_du(u, lam):\n    \"\"\"Partial derivative of F with respect to u.\"\"\"\n    return lam - 3 * u**2\n\ndef dF_dlam(u, lam):\n    \"\"\"Partial derivative of F with respect to lambda.\"\"\"\n    return u\n\ndef newton_2d(func, jac, x0, tol, max_iter):\n    \"\"\"Solves a 2D system f(x)=0 using Newton's method.\"\"\"\n    x = np.array(x0, dtype=np.float64)\n    for _ in range(max_iter):\n        J = jac(x)\n        F_val = func(x)\n        if np.abs(np.linalg.det(J))  1e-20:\n            return x, False\n        delta = np.linalg.solve(J, -F_val)\n        x += delta\n        if np.linalg.norm(delta)  tol:\n            return x, True\n    return x, False\n\ndef newton_1d(func, deriv, x0, tol, max_iter):\n    \"\"\"Solves a 1D equation f(x)=0 using Newton's method.\"\"\"\n    x = np.float64(x0)\n    for _ in range(max_iter):\n        f_val = func(x)\n        df_val = deriv(x)\n        if abs(df_val)  1e-20:\n            return x, False\n        delta = -f_val / df_val\n        x += delta\n        if abs(delta)  tol:\n            return x, True\n    return x, False\n\ndef trace_branch(sigma, lambda_target, ds):\n    \"\"\"\n    Performs branch-switching, pseudo-arclength continuation, and refinement.\n    \"\"\"\n    # Stage 1: Branch Switching (Seeding)\n    def G_seed(x):\n        u, lam = x\n        return np.array([F_func(u, lam), u - sigma], dtype=np.float64)\n\n    def J_G_seed(x):\n        u, lam = x\n        return np.array([\n            [dF_du(u, lam), dF_dlam(u, lam)],\n            [1.0, 0.0]\n        ], dtype=np.float64)\n\n    seed_guess = np.array([sigma, 0.0])\n    seed_point, converged = newton_2d(G_seed, J_G_seed, seed_guess, TOL, MAX_ITER)\n    if not converged:\n        raise RuntimeError(f\"Seeding Newton failed for sigma={sigma}\")\n    \n    u_k, lambda_k = seed_point\n\n    # Stage 2: Pseudo-Arclength Continuation\n    while lambda_k  lambda_target:\n        # --- Predictor Step ---\n        tu_un = dF_dlam(u_k, lambda_k)\n        tlam_un = -dF_du(u_k, lambda_k)\n        \n        if tlam_un  0:\n            tu_un *= -1.0\n            tlam_un *= -1.0\n            \n        norm = np.sqrt(tu_un**2 + tlam_un**2)\n        if norm  1e-15:\n            raise RuntimeError(\"Tangent norm is zero during continuation.\")\n        t_u = tu_un / norm\n        t_lambda = tlam_un / norm\n\n        u_pred = u_k + ds * t_u\n        lambda_pred = lambda_k + ds * t_lambda\n        \n        # --- Corrector Step ---\n        def H_corr(x):\n            u, lam = x\n            return np.array([\n                F_func(u, lam),\n                t_u * (u - u_pred) + t_lambda * (lam - lambda_pred)\n            ], dtype=np.float64)\n        \n        def J_H_corr(x):\n            u, lam = x\n            return np.array([\n                [dF_du(u, lam), dF_dlam(u, lam)],\n                [t_u, t_lambda]\n            ], dtype=np.float64)\n            \n        corr_guess = np.array([u_pred, lambda_pred])\n        next_point, converged = newton_2d(H_corr, J_H_corr, corr_guess, TOL, MAX_ITER)\n        \n        if not converged:\n            raise RuntimeError(f\"Corrector Newton failed for target lambda={lambda_target}\")\n            \n        u_k, lambda_k = next_point\n    \n    # Stage 3: Refinement\n    def f_refine(u):\n        return F_func(u, lambda_target)\n        \n    def df_refine(u):\n        return dF_du(u, lambda_target)\n        \n    refine_guess = u_k\n    final_u, converged = newton_1d(f_refine, df_refine, refine_guess, TOL, MAX_ITER)\n    \n    if not converged:\n        raise RuntimeError(f\"Refinement Newton failed for target lambda={lambda_target}\")\n        \n    return final_u\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (sigma, lambda_target)\n        (0.01, 0.25),\n        (-0.02, 0.49),\n        (0.001, 0.0004),\n        (-0.0015, 0.0009),\n    ]\n\n    results = []\n    for sigma, lambda_target in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        u_final = trace_branch(sigma, lambda_target, DS)\n        results.append(f\"{u_final:.6f}\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3217736"}]}