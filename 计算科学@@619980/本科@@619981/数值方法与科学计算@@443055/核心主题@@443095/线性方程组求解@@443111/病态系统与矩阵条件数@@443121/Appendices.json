{"hands_on_practices": [{"introduction": "一个高条件数的矩阵在几何上意味着它所代表的线性变换会极度地扭曲空间。这个练习旨在将这一抽象概念具体化，你将亲手构造一个条件数非常大的矩阵，并观察它如何将一个完美的单位圆拉伸成一个极其扁长的椭圆 [@problem_id:3240924]。通过这个过程，你将直观地理解条件数与奇异值之间的联系，以及它们如何决定变换的拉伸程度。", "problem": "要求您构造并分析一个病态的线性变换。从矩阵二范数、奇异值和条件数的定义出发，完成以下任务：\n\n- 构造一个显式的实 $2 \\times 2$ 矩阵 $A$，使其关于矩阵二范数的条件数满足 $\\kappa_{2}(A) = 10^{8}$ 且 $\\det(A) = 1$。\n- 仅使用这些定义和正交变换的基本性质，证明单位圆在 $A$ 作用下的像是一个椭圆。确定该椭圆的半轴。\n- 使用其几何定义来定义所得椭圆的离心率 $e$，并推导出一个用半轴表示 $e$ 的表达式。\n- 计算您所构造矩阵的 $e$ 值，并以单一精确解析表达式的形式给出最终值。\n\n您的最终答案必须是单一实值表达式。无需四舍五入，也无单位。", "solution": "本题要求构造并分析一个病态的 $2 \\times 2$ 实矩阵 $A$。分析涉及其对单位圆的几何作用以及所得椭圆离心率的计算。\n\n首先，我们必须构造满足给定条件的矩阵 $A$。设 $2 \\times 2$ 矩阵 $A$ 的奇异值为 $\\sigma_1$ 和 $\\sigma_2$，对于可逆矩阵，按照惯例有 $\\sigma_1 \\ge \\sigma_2  0$。\n\n关于矩阵二范数的条件数 $\\kappa_2(A)$ 定义为最大奇异值与最小奇异值之比：\n$$ \\kappa_2(A) = \\frac{\\sigma_1}{\\sigma_2} $$\n给定条件 $\\kappa_2(A) = 10^8$。因此，我们有方程：\n$$ \\frac{\\sigma_1}{\\sigma_2} = 10^8 $$\n$A$ 的行列式 $\\det(A)$ 与奇异值的关系为 $|\\det(A)| = \\sigma_1 \\sigma_2$。给定条件 $\\det(A) = 1$，这意味着 $\\sigma_1 \\sigma_2 = 1$。\n\n现在我们得到一个关于两个未知奇异值 $\\sigma_1$ 和 $\\sigma_2$ 的方程组：\n1. $\\sigma_1 = 10^8 \\sigma_2$\n2. $\\sigma_1 \\sigma_2 = 1$\n\n将第一个方程代入第二个方程，得到：\n$$ (10^8 \\sigma_2) \\sigma_2 = 1 \\implies \\sigma_2^2 = 10^{-8} $$\n由于奇异值是非负的，我们取正平方根：\n$$ \\sigma_2 = \\sqrt{10^{-8}} = 10^{-4} $$\n现在，我们用第一个方程求出 $\\sigma_1$：\n$$ \\sigma_1 = 10^8 \\sigma_2 = 10^8 \\cdot 10^{-4} = 10^4 $$\n所求的奇异值为 $\\sigma_1 = 10^4$ 和 $\\sigma_2 = 10^{-4}$。\n\n为了构造一个显式矩阵 $A$，我们可以使用奇异值分解（SVD），它指出任何实矩阵 $A$ 都可以写成 $A = U\\Sigma V^T$ 的形式，其中 $U$ 和 $V$ 是正交矩阵，$\\Sigma$ 是包含奇异值的对角矩阵。对于我们的 $2 \\times 2$ 情况：\n$$ \\Sigma = \\begin{pmatrix} \\sigma_1  0 \\\\ 0  \\sigma_2 \\end{pmatrix} = \\begin{pmatrix} 10^4  0 \\\\ 0  10^{-4} \\end{pmatrix} $$\n构造 $A$ 的最简单方法是选择 $U$ 和 $V$ 为单位矩阵 $I = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}$，它是一个正交矩阵。这得到：\n$$ A = I \\Sigma I^T = \\Sigma = \\begin{pmatrix} 10^4  0 \\\\ 0  10^{-4} \\end{pmatrix} $$\n该矩阵是实的 $2 \\times 2$ 矩阵，并且满足 $\\kappa_2(A) = \\frac{10^4}{10^{-4}} = 10^8$ 和 $\\det(A) = (10^4)(10^{-4}) = 1$。\n\n接下来，我们证明单位圆在 $A$ 作用下的像是一个椭圆。单位圆是满足 $\\|\\mathbf{x}\\|_2 = 1$ 的向量集合 $\\mathbf{x} \\in \\mathbb{R}^2$。像是向量集合 $\\mathbf{y} = A\\mathbf{x}$。使用 SVD，有 $\\mathbf{y} = U\\Sigma V^T \\mathbf{x}$。\n令 $\\mathbf{z} = V^T \\mathbf{x}$。由于 $V^T$ 是一个正交变换，它保持欧几里得范数不变，所以 $\\|\\mathbf{z}\\|_2 = \\|V^T \\mathbf{x}\\|_2 = \\|\\mathbf{x}\\|_2 = 1$。当 $\\mathbf{x}$ 描绘单位圆时，$\\mathbf{z}$ 也描绘单位圆。\n将 $\\mathbf{z}$ 参数化表示为 $\\mathbf{z} = \\begin{pmatrix} \\cos(\\theta) \\\\ \\sin(\\theta) \\end{pmatrix}$，其中 $\\theta \\in [0, 2\\pi)$。\n那么向量 $\\mathbf{w} = \\Sigma \\mathbf{z}$ 是：\n$$ \\mathbf{w} = \\begin{pmatrix} \\sigma_1  0 \\\\ 0  \\sigma_2 \\end{pmatrix} \\begin{pmatrix} \\cos(\\theta) \\\\ \\sin(\\theta) \\end{pmatrix} = \\begin{pmatrix} \\sigma_1\\cos(\\theta) \\\\ \\sigma_2\\sin(\\theta) \\end{pmatrix} $$\n$\\mathbf{w}$ 的分量 $w_1 = \\sigma_1\\cos(\\theta)$ 和 $w_2 = \\sigma_2\\sin(\\theta)$ 满足椭圆方程：\n$$ \\left(\\frac{w_1}{\\sigma_1}\\right)^2 + \\left(\\frac{w_2}{\\sigma_2}\\right)^2 = \\cos^2(\\theta) + \\sin^2(\\theta) = 1 $$\n这是一个以原点为中心、半轴长为 $\\sigma_1$ 和 $\\sigma_2$ 且半轴与坐标轴对齐的椭圆。\n最终的像向量是 $\\mathbf{y} = U\\mathbf{w}$。矩阵 $U$ 代表一个正交变换（旋转或反射），它将 $\\mathbf{w}$ 描绘的椭圆映射到另一个椭圆。此变换保持半轴的长度不变。\n因此，单位圆在 $A$ 作用下的像是一个椭圆，其半轴长度等于 $A$ 的奇异值。半长轴为 $a = \\sigma_1 = 10^4$，半短轴为 $b = \\sigma_2 = 10^{-4}$。\n\n现在我们推导离心率 $e$ 的表达式。对于一个半长轴为 $a$、半短轴为 $b$ 的椭圆，中心到每个焦点的距离（记作 $c$）由关系式 $a^2 = b^2 + c^2$ 给出。这得到 $c = \\sqrt{a^2 - b^2}$。离心率 $e$ 的几何定义是中心到焦点的距离与半长轴之比：\n$$ e = \\frac{c}{a} = \\frac{\\sqrt{a^2 - b^2}}{a} $$\n我们可以将其改写为：\n$$ e = \\sqrt{\\frac{a^2 - b^2}{a^2}} = \\sqrt{1 - \\left(\\frac{b}{a}\\right)^2} $$\n\n最后，我们计算我们特定椭圆的 $e$ 值。半轴为 $a = 10^4$ 和 $b = 10^{-4}$。将这些值代入离心率的表达式：\n$$ e = \\sqrt{1 - \\left(\\frac{10^{-4}}{10^4}\\right)^2} $$\n$$ e = \\sqrt{1 - (10^{-8})^2} $$\n$$ e = \\sqrt{1 - 10^{-16}} $$\n这就是该椭圆离心率的精确解析表达式。", "answer": "$$\\boxed{\\sqrt{1 - 10^{-16}}}$$", "id": "3240924"}, {"introduction": "在建立了病态条件的几何直观后，我们将深入探讨其背后的代数放大机制。这个练习将精确地揭示，为何微小的数据扰动会导致解的巨大变化，并且这种敏感性是具有方向性的 [@problem_id:3240884]。通过构造一个特定的数据向量，你将验证一个微小的扰动，如果它恰好沿着与最小奇异值对应的“最弱”方向，其在解中的影响将被放大到惊人的程度，放大因子恰好是该奇异值的倒数。", "problem": "考虑一个实矩阵 $A \\in \\mathbb{R}^{3 \\times 3}$，其奇异值分解 (singular value decomposition (SVD)) 为 $A = Q \\Sigma V^{\\top}$，其中 $Q$ 和 $V$ 是正交矩阵，$\\Sigma = \\operatorname{diag}(\\sigma_{1}, \\sigma_{2}, \\sigma_{3})$，且已知奇异值 $\\sigma_{1} = 6$，$\\sigma_{2} = 2$ 和 $\\sigma_{3} = 10^{-12}$。设左奇异向量为 $Q$ 的列，分别记作 $u_{1}$、$u_{2}$ 和 $u_{3}$，其中 $u_{3}$ 对应最小的奇异值 $\\sigma_{3}$。您需要构造一个与 $u_{3}$ 近似正交的右端向量 $b$，并分析解 $x = A^{\\dagger} b$ 的敏感性，其中 $A^{\\dagger}$ 表示 Moore–Penrose 伪逆 (Moore–Penrose pseudoinverse (MPP))。\n\n定义 $b_{0} = u_{1} + u_{2}$ 和 $b = b_{0} + \\varepsilon u_{3}$，其中 $\\varepsilon = 10^{-9}$。令 $x_{0} = A^{\\dagger} b_{0}$ 和 $x = A^{\\dagger} b$。仅使用基本定义（奇异向量的正交规范性、线性性以及通过 SVD 定义的伪逆），推导解相对于沿 $u_{3}$ 方向扰动的放大因子：\n$$\ng \\equiv \\frac{\\|x - x_{0}\\|_{2}}{\\|b - b_{0}\\|_{2}},\n$$\n其中 $\\|\\cdot\\|_{2}$ 表示欧几里得范数。请给出 $g$ 的最终值，其形式为一个纯数。不需要单位。除了基本定义外，不要使用任何快捷公式。最终答案必须是单个实数。不需要四舍五入。", "solution": "问题要求计算放大因子 $g$，其定义为解的变化量的范数与右端向量变化量的范数之比。\n$$\ng \\equiv \\frac{\\|x - x_{0}\\|_{2}}{\\|b - b_{0}\\|_{2}}\n$$\n变量定义如下：\n- 矩阵 $A \\in \\mathbb{R}^{3 \\times 3}$，其 SVD 为 $A = Q \\Sigma V^{\\top}$。\n- $Q = [u_1, u_2, u_3]$ 和 $V = [v_1, v_2, v_3]$ 是正交矩阵，$\\{u_i\\}$ 和 $\\{v_i\\}$ 分别是左奇异向量集和右奇异向量集。\n- $\\Sigma = \\operatorname{diag}(\\sigma_{1}, \\sigma_{2}, \\sigma_{3})$，奇异值为 $\\sigma_{1} = 6$，$\\sigma_{2} = 2$ 和 $\\sigma_{3} = 10^{-12}$。\n- $b_{0} = u_{1} + u_{2}$。\n- $b = b_{0} + \\varepsilon u_{3}$，其中 $\\varepsilon = 10^{-9}$。\n- $x_{0} = A^{\\dagger} b_{0}$ 和 $x = A^{\\dagger} b$，其中 $A^{\\dagger}$ 是 Moore-Penrose 伪逆。\n\n首先，我们使用 $A$ 的 SVD 来定义 Moore-Penrose 伪逆 $A^{\\dagger}$：\n$$\nA^{\\dagger} = V \\Sigma^{\\dagger} Q^{\\top}\n$$\n由于所有给定的奇异值 $\\sigma_i$ 均非零，矩阵 $\\Sigma^{\\dagger}$ 是由奇异值倒数构成的对角矩阵：\n$$\n\\Sigma^{\\dagger} = \\operatorname{diag}(\\sigma_{1}^{-1}, \\sigma_{2}^{-1}, \\sigma_{3}^{-1})\n$$\n\n接下来，我们分析 $g$ 表达式的分子，即 $\\|x - x_{0}\\|_{2}$。\n解 $x$ 和 $x_0$ 之间的差值为：\n$$\nx - x_{0} = A^{\\dagger} b - A^{\\dagger} b_{0}\n$$\n根据矩阵向量乘法的线性性，我们可以写出：\n$$\nx - x_{0} = A^{\\dagger} (b - b_{0})\n$$\n右端向量 $b$ 和 $b_0$ 之间的差值为：\n$$\nb - b_{0} = (b_{0} + \\varepsilon u_{3}) - b_{0} = \\varepsilon u_{3}\n$$\n将此结果代入解的差值表达式中：\n$$\nx - x_{0} = A^{\\dagger} (\\varepsilon u_{3}) = \\varepsilon (A^{\\dagger} u_{3})\n$$\n现在，我们使用基于 SVD 的定义来计算 $A^{\\dagger}$ 对向量 $u_3$ 的作用：\n$$\nA^{\\dagger} u_{3} = (V \\Sigma^{\\dagger} Q^{\\top}) u_{3} = V \\Sigma^{\\dagger} (Q^{\\top} u_{3})\n$$\n矩阵 $Q$ 是正交的，因此其列向量 $\\{u_1, u_2, u_3\\}$ 构成一个正交规范基。矩阵 $Q^{\\top}$ 的行是 $u_1^{\\top}$、$u_2^{\\top}$ 和 $u_3^{\\top}$。乘积 $Q^{\\top} u_{3}$ 是一个列向量，其第 $i$ 个分量是 $u_{i}^{\\top} u_{3}$。由于正交规范性，$u_{i}^{\\top} u_{j} = \\delta_{ij}$ (克罗内克 δ)。因此：\n$$\nQ^{\\top} u_{3} = \\begin{pmatrix} u_{1}^{\\top} u_{3} \\\\ u_{2}^{\\top} u_{3} \\\\ u_{3}^{\\top} u_{3} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}\n$$\n将此结果代回 $A^{\\dagger} u_{3}$ 的表达式中：\n$$\nA^{\\dagger} u_{3} = V \\Sigma^{\\dagger} \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} = V \\begin{pmatrix} \\sigma_{1}^{-1}  0  0 \\\\ 0  \\sigma_{2}^{-1}  0 \\\\ 0  0  \\sigma_{3}^{-1} \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} = V \\begin{pmatrix} 0 \\\\ 0 \\\\ \\sigma_{3}^{-1} \\end{pmatrix}\n$$\n由于 $V$ 是以右奇异向量为列的矩阵，即 $V = [v_1, v_2, v_3]$，最终的乘积为：\n$$\nA^{\\dagger} u_{3} = [v_1, v_2, v_3] \\begin{pmatrix} 0 \\\\ 0 \\\\ \\sigma_{3}^{-1} \\end{pmatrix} = 0 \\cdot v_{1} + 0 \\cdot v_{2} + \\sigma_{3}^{-1} \\cdot v_{3} = \\sigma_{3}^{-1} v_{3}\n$$\n现在我们可以写出解的差值的最终表达式：\n$$\nx - x_{0} = \\varepsilon (\\sigma_{3}^{-1} v_{3})\n$$\n我们计算该向量的欧几里得范数，作为 $g$ 的分子：\n$$\n\\|x - x_{0}\\|_{2} = \\|\\varepsilon \\sigma_{3}^{-1} v_{3}\\|_{2} = |\\varepsilon \\sigma_{3}^{-1}| \\|v_{3}\\|_{2}\n$$\n向量 $v_3$ 是正交矩阵 $V$ 的一个列向量，因此它是一个单位向量，即 $\\|v_{3}\\|_{2} = 1$。考虑到 $\\varepsilon = 10^{-9}  0$ 且 $\\sigma_{3} = 10^{-12}  0$，可以去掉绝对值符号：\n$$\n\\|x - x_{0}\\|_{2} = \\varepsilon \\sigma_{3}^{-1}\n$$\n现在我们分析 $g$ 的分母，即 $\\|b - b_{0}\\|_{2}$。\n我们已经得到 $b - b_{0} = \\varepsilon u_{3}$。其范数为：\n$$\n\\|b - b_{0}\\|_{2} = \\|\\varepsilon u_{3}\\|_{2} = |\\varepsilon| \\|u_{3}\\|_{2}\n$$\n类似地，$u_3$ 是正交矩阵 $Q$ 的一个列向量，因此它是一个单位向量，$\\|u_{3}\\|_{2} = 1$。由于 $\\varepsilon  0$，我们有：\n$$\n\\|b - b_{0}\\|_{2} = \\varepsilon\n$$\n最后，我们通过计算两个范数的比值来求得放大因子 $g$：\n$$\ng = \\frac{\\|x - x_{0}\\|_{2}}{\\|b - b_{0}\\|_{2}} = \\frac{\\varepsilon \\sigma_{3}^{-1}}{\\varepsilon} = \\sigma_{3}^{-1}\n$$\n代入给定的 $\\sigma_{3}$ 值：\n$$\ng = (10^{-12})^{-1} = 10^{12}\n$$\n结果表明，对应最小奇异值的左奇异向量方向上的一个微小扰动，在解中被放大了等于该奇异值倒数的倍数。这展示了病态系统特有的敏感性。", "answer": "$$\\boxed{10^{12}}$$", "id": "3240884"}, {"introduction": "现在，我们将理论付诸实践，解决一个在科学计算中非常常见的问题：曲线拟合。这个动手编程练习将向你展示，一个看似无害的基函数选择（例如标准单项式）是如何导致一个病态的线性系统的 [@problem_id:3240835]。更重要的是，你将学习并实施一种强大的缓解策略——使用正交多项式重新设计基函数，从而显著改善系统的数值稳定性，并量化这种改进的效果。", "problem": "考虑将标量响应 $y$ 对在一组样本 $\\{x_i\\}_{i=0}^{n-1}$ 上求值的一组基函数 $\\{\\phi_j(x)\\}_{j=0}^{m-1}$ 进行普通最小二乘曲线拟合。设设计矩阵 $A \\in \\mathbb{R}^{n \\times m}$ 的元素为 $A_{ij} = \\phi_j(x_i)$，当 $A$ 的列线性无关时，最小二乘法正规方程为 $A^\\top A \\beta = A^\\top y$，其解系数为 $\\beta \\in \\mathbb{R}^m$。一个具有高度相关列的矩阵在进行最小二乘计算时容易出现数值不稳定性，这可以通过矩阵的条件数来诊断。从向量 2-范数下的诱导矩阵范数和 Moore–Penrose 伪逆的核心定义出发，设计并实现一个数值稳定的算法来计算满列秩矩形设计矩阵的 2-范数条件数 $\\kappa_2(A)$。推导过程需基于奇异值分解 (SVD)，且不假定任何快捷公式。然后，通过将样本域映射到 $[-1,1]$ 并使用匹配最大阶数的勒让德多项式作为新基，来重新设计基以减少列相关性，并评估其对 $\\kappa_2$ 的影响。\n\n您的程序必须构建以下测试套件，为每个案例计算改善因子（定义为比率 $r = \\kappa_2(A_{\\text{orig}})/\\kappa_2(A_{\\text{redesign}})$），并将这三个改善因子以单个列表的形式在一行中输出。\n\n测试套件：\n- 案例 1 (边界情况，近共线性)：$n = 50$，样本 $x_i = 1 + \\left(\\frac{i}{n-1} - \\frac{1}{2}\\right)\\cdot 2\\times 10^{-3}$，其中 $i = 0,1,\\dots,n-1$。原始基函数为 $\\phi_0(x) = 1$，$\\phi_1(x) = x$，$\\phi_2(x) = x + \\varepsilon$，其中 $\\varepsilon = 10^{-6}$。重新设计的基：使用样本最小值和最大值将 $x$ 仿射映射到 $t \\in [-1,1]$，并使用 $k = 0,1,2$ 的勒让德多项式 $P_k(t)$。\n- 案例 2 (理想情况，中度相关的单项式)：$n = 100$，样本 $x_i = \\frac{i}{n-1}$，其中 $i = 0,1,\\dots,n-1$。原始基函数为 $\\phi_k(x) = x^k$，其中 $k = 0,1,\\dots,6$。重新设计的基：将 $x$ 映射到 $t = 2x - 1$，并使用 $k = 0,1,\\dots,6$ 的勒让德多项式 $P_k(t)$。\n- 案例 3 (边缘案例，已接近正交)：$n = 80$，样本 $x_i = -1 + \\frac{2i}{n-1}$，其中 $i = 0,1,\\dots,n-1$。原始基函数为勒让德多项式 $P_k(x)$，其中 $k = 0,1,\\dots,6$。重新设计的基：使用样本最小值和最大值将 $x$ 仿射映射到 $t \\in [-1,1]$，并使用 $k = 0,1,\\dots,6$ 的勒让德多项式 $P_k(t)$。\n\n实现细节要求：\n- 通过在指定的样本点上计算指定的基函数来构建每个设计矩阵 $A$，将 $\\phi_j$ 的值放入第 $j$ 列。\n- 实现 $\\kappa_2(A)$ 的计算，该计算需通过从诱导 2-范数和 Moore–Penrose 伪逆的定义推导出基于 SVD 的算法。不要在问题陈述中假设任何条件数的闭式快捷方式；您的解决方案必须从第一性原理出发证明算法步骤的合理性。\n- 对于整数阶 $k \\ge 0$，使用其在 $[-1,1]$ 上的三项递推关系来实现勒让德多项式 $P_k(t)$；不要调用任何外部特殊函数库。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个改善因子，以逗号分隔的列表形式并用方括号括起来（例如 $[r_1,r_2,r_3]$），其中每个 $r_i$ 是一个对应于上述顺序中案例 $i$ 的十进制浮点数。", "solution": "题目要求推导并实现一种计算矩形设计矩阵 $A$ 的 2-范数条件数 $\\kappa_2(A)$ 的方法，并评估通过重新设计基函数在条件数上获得的改善。推导过程必须基于奇异值分解 (SVD) 并从第一性原理出发。\n\n### 第一部分：通过 SVD 推导 2-范数条件数\n\n题目明确指出，推导必须从诱导 2-范数和 Moore-Penrose 伪逆的核心定义开始。\n\n**1. 诱导 2-范数**\n\n对于矩阵 $A \\in \\mathbb{R}^{n \\times m}$，其诱导 2-范数（记为 $\\|A\\|_2$）定义为向量乘以 $A$ 后其欧几里得范数的最大放大率：\n$$\n\\|A\\|_2 = \\max_{\\vec{v} \\in \\mathbb{R}^m, \\vec{v} \\neq \\vec{0}} \\frac{\\|A\\vec{v}\\|_2}{\\|\\vec{v}\\|_2}\n$$\n被最大化的量，即瑞利商，可以平方：\n$$\n\\frac{\\|A\\vec{v}\\|_2^2}{\\|\\vec{v}\\|_2^2} = \\frac{(A\\vec{v})^\\top (A\\vec{v})}{\\vec{v}^\\top \\vec{v}} = \\frac{\\vec{v}^\\top A^\\top A \\vec{v}}{\\vec{v}^\\top \\vec{v}}\n$$\n矩阵 $A^\\top A$ 是一个大小为 $m \\times m$ 的对称半正定矩阵。该瑞利商的最大值是 $A^\\top A$ 的最大特征值，记为 $\\lambda_{\\max}(A^\\top A)$。因此，\n$$\n\\|A\\|_2^2 = \\lambda_{\\max}(A^\\top A) \\implies \\|A\\|_2 = \\sqrt{\\lambda_{\\max}(A^\\top A)}\n$$\n\n**2. 奇异值分解 (SVD)**\n\n任何矩阵 $A \\in \\mathbb{R}^{n \\times m}$ 都有奇异值分解 (SVD)，其形式为：\n$$\nA = U \\Sigma V^\\top\n$$\n其中 $U \\in \\mathbb{R}^{n \\times n}$ 是一个正交矩阵 ($U^\\top U = I_n$)，$V \\in \\mathbb{R}^{m \\times m}$ 是一个正交矩阵 ($V^\\top V = I_m$)，而 $\\Sigma \\in \\mathbb{R}^{n \\times m}$ 是一个包含 $A$ 的奇异值 $\\sigma_i$ 的矩形对角矩阵。奇异值是非负的，并且通常按 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_r  0$ 的顺序排列，其中 $r$ 是 $A$ 的秩。对于本问题，给定 $A$ 是满列秩的，所以 $r=m$ 且所有 $m$ 个奇异值都是正数。\n\n让我们将 $A^\\top A$ 的特征值与 $A$ 的奇异值联系起来。\n$$\nA^\\top A = (U \\Sigma V^\\top)^\\top (U \\Sigma V^\\top) = (V \\Sigma^\\top U^\\top) (U \\Sigma V^\\top)\n$$\n由于 $U^\\top U = I_n$，上式可简化为：\n$$\nA^\\top A = V \\Sigma^\\top \\Sigma V^\\top\n$$\n这是 $A^\\top A$ 的特征分解。$V$ 的列是 $A^\\top A$ 的特征向量，而 $m \\times m$ 矩阵 $\\Sigma^\\top \\Sigma$ 的对角元素是对应的特征值。矩阵 $\\Sigma^\\top \\Sigma$ 是对角矩阵，其元素为 $\\sigma_1^2, \\sigma_2^2, \\dots, \\sigma_m^2$。\n因此，$A^\\top A$ 的特征值是 $A$ 的奇异值的平方：$\\lambda_i(A^\\top A) = \\sigma_i^2$。\n\n由此，我们用奇异值来表示 $A$ 的 2-范数：\n$$\n\\|A\\|_2 = \\sqrt{\\lambda_{\\max}(A^\\top A)} = \\sqrt{\\sigma_1^2} = \\sigma_1 = \\sigma_{\\max}(A)\n$$\n\n**3. Moore-Penrose 伪逆**\n\n对于一个矩形矩阵 $A$，其条件数是根据其伪逆 $A^+$ 定义的。Moore-Penrose 伪逆 $A^+$ 是满足四个特定准则的唯一矩阵。对于一个如题目所规定的具有 $n \\ge m$ 和满列秩的矩阵 $A \\in \\mathbb{R}^{n \\times m}$，其伪逆有一个简单而显式的形式：\n$$\nA^+ = (A^\\top A)^{-1} A^\\top\n$$\n伪逆 $A^+$ 的 SVD 可以从 $A$ 的 SVD 推导出来。它由 $A^+ = V \\Sigma^+ U^\\top$ 给出，其中 $\\Sigma^+$ 是 $\\Sigma$ 的伪逆。对于一个满列秩的高矩阵 $A$，$\\Sigma$ 是一个 $n \\times m$ 矩阵，其顶部的 $m \\times m$ 块是一个对角矩阵 $D = \\text{diag}(\\sigma_1, \\dots, \\sigma_m)$，其余部分为零。它的伪逆 $\\Sigma^+$ 是一个 $m \\times n$ 矩阵，其左侧的 $m \\times m$ 块是 $D^{-1} = \\text{diag}(1/\\sigma_1, \\dots, 1/\\sigma_m)$，其余部分为零。\n\n$A^+$ 的奇异值是 $A$ 的非零奇异值的倒数。因此，$A^+$ 的奇异值是 $1/\\sigma_1, 1/\\sigma_2, \\dots, 1/\\sigma_m$。\n\n**4. 条件数**\n\n$A$ 的 2-范数条件数定义为：\n$$\n\\kappa_2(A) = \\|A\\|_2 \\|A^+\\|_2\n$$\n利用 2-范数和最大奇异值之间的关系，我们有：\n$$\n\\|A\\|_2 = \\sigma_{\\max}(A) = \\sigma_1\n$$\n$$\n\\|A^+\\|_2 = \\sigma_{\\max}(A^+) = \\frac{1}{\\sigma_{\\min}(A)} = \\frac{1}{\\sigma_m}\n$$\n此处，$\\sigma_{\\min}(A)$ 指的是 $A$ 的最小非零奇异值。由于 $A$ 是满列秩的，其所有 $m$ 个奇异值都是非零的，所以 $\\sigma_{\\min}(A) = \\sigma_m  0$。\n\n结合这些结果，得到条件数的期望表达式：\n$$\n\\kappa_2(A) = \\sigma_{\\max}(A) \\cdot \\frac{1}{\\sigma_{\\min}(A)} = \\frac{\\sigma_1}{\\sigma_m}\n$$\n这个推导提供了一个稳定的算法：计算 $A$ 的 SVD，找到最大和最小的奇异值，然后取它们的比值。这种方法避免了构造可能更病态的矩阵 $A^\\top A$。\n\n### 第二部分：基的重新设计与勒让德多项式\n\n最小二乘问题中的病态条件通常源于设计矩阵 $A$ 各列之间的高度相关性。一个常见原因是在一个不以 0 为中心的区间上使用单项式基函数 $\\{\\phi_k(x) = x^k\\}$。为了缓解这个问题，可以使用一组正交多项式作为基。\n\n**1. 仿射变换**\n\n为了使用定义在标准区间（如 $[-1, 1]$）上的正交多项式，必须将样本域 $[x_{\\min}, x_{\\max}]$ 映射到这个区间。可以使用仿射变换 $t = f(x) = ax+b$。我们要求 $f(x_{\\min}) = -1$ 和 $f(x_{\\max}) = 1$。解这个关于 $a$ 和 $b$ 的二元一次方程组，得到：\n$$\na = \\frac{2}{x_{\\max} - x_{\\min}} \\quad \\text{and} \\quad b = - \\frac{x_{\\max} + x_{\\min}}{x_{\\max} - x_{\\min}}\n$$\n因此，变换为：\n$$\nt_i = \\frac{2(x_i - x_{\\min})}{x_{\\max} - x_{\\min}} - 1\n$$\n对于案例 2，$x \\in [0, 1]$，这给出 $t = \\frac{2(x - 0)}{1 - 0} - 1 = 2x - 1$。对于案例 3，$x \\in [-1, 1]$，这给出 $t = \\frac{2(x - (-1))}{1 - (-1)} - 1 = x$。\n\n**2. 勒让德多项式**\n\n勒让德多项式 $P_k(t)$ 是在区间 $[-1, 1]$ 上关于权重函数 $w(t)=1$ 的一组正交多项式序列。它们可以通过三项递推关系（Bonnet 递推公式）生成：\n$$\nP_0(t) = 1\n$$\n$$\nP_1(t) = t\n$$\n$$\n(k+1)P_{k+1}(t) = (2k+1)tP_k(t) - kP_{k-1}(t) \\quad \\text{for } k \\ge 1\n$$\n对于变换后的变量 $t$，使用这些多项式作为基函数 $\\phi_k(t) = P_k(t)$，会使得设计矩阵的列近似正交，从而显著降低条件数。改善程度由比率 $r = \\kappa_2(A_{\\text{orig}}) / \\kappa_2(A_{\\text{redesign}})$ 来量化。\n\n### 第三部分：测试案例执行计划\n\n对于每个案例，算法按以下步骤进行：\n1.  生成样本点 $x_i$，$i=0, \\dots, n-1$。\n2.  通过在每个 $x_i$ 上计算指定的原始基函数，构建原始设计矩阵 $A_{\\text{orig}} \\in \\mathbb{R}^{n \\times m}$。\n3.  使用 SVD 程序计算 $A_{\\text{orig}}$ 的奇异值。计算 $\\kappa_2(A_{\\text{orig}}) = \\sigma_{\\max}/\\sigma_{\\min}$。\n4.  应用仿射变换将点 $x_i$ 映射到 $t_i \\in [-1, 1]$。\n5.  通过计算所需阶数以内的勒让德多项式 $P_k(t_i)$，构建重新设计的设计矩阵 $A_{\\text{redesign}} \\in \\mathbb{R}^{n \\times m}$。\n6.  计算 $A_{\\text{redesign}}$ 的奇异值并计算 $\\kappa_2(A_{\\text{redesign}})$。\n7.  计算改善因子 $r = \\kappa_2(A_{\\text{orig}}) / \\kappa_2(A_{\\text{redesign}})$。\n然后报告这三个案例的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef legendre_poly_values(max_k: int, t_values: np.ndarray) - np.ndarray:\n    \"\"\"\n    Computes Legendre polynomial values P_k(t) for k=0 to max_k.\n\n    Args:\n        max_k: The maximum degree of the polynomial.\n        t_values: A 1D numpy array of points t to evaluate the polynomials at.\n\n    Returns:\n        A numpy array of shape (len(t_values), max_k + 1), where column j\n        contains the values of P_j(t).\n    \"\"\"\n    n_samples = len(t_values)\n    # The matrix p_matrix will store P_k(t) in column k.\n    p_matrix = np.zeros((n_samples, max_k + 1))\n\n    # Base case P_0(t) = 1\n    if max_k = 0:\n        p_matrix[:, 0] = 1.0\n\n    # Base case P_1(t) = t\n    if max_k = 1:\n        p_matrix[:, 1] = t_values\n\n    # Recurrence relation for k = 1:\n    # (k+1)P_{k+1}(t) = (2k+1)t*P_k(t) - k*P_{k-1}(t)\n    for k in range(1, max_k):\n        # This calculates P_{k+1}(t) and stores it in column k+1.\n        pk_plus_1 = ((2 * k + 1) * t_values * p_matrix[:, k] - k * p_matrix[:, k - 1]) / (k + 1)\n        p_matrix[:, k + 1] = pk_plus_1\n        \n    return p_matrix\n\ndef compute_condition_number(A: np.ndarray) - float:\n    \"\"\"\n    Computes the 2-norm condition number of a matrix A using SVD.\n    kappa_2(A) = sigma_max / sigma_min.\n    \"\"\"\n    try:\n        singular_values = np.linalg.svd(A, compute_uv=False)\n        # Assuming A has full column rank, the smallest singular value is non-zero.\n        # Handle potential floating point underflow for sigma_min.\n        if singular_values[-1]  np.finfo(float).eps:\n            return np.inf\n        return singular_values[0] / singular_values[-1]\n    except np.linalg.LinAlgError:\n        return np.inf\n\ndef solve():\n    \"\"\"\n    Main function to run test suite and compute improvement factors.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (boundary, near-collinearity)\n        {\n            \"n\": 50,\n            \"m\": 3,\n            \"x_gen\": lambda n: 1.0 + (np.arange(n, dtype=float) / (n - 1) - 0.5) * 2e-3,\n            \"orig_basis_builder\": lambda x, m: np.column_stack([np.ones_like(x), x, x + 1e-6]),\n            \"redesign_max_k\": 2\n        },\n        # Case 2 (happy path, moderately correlated monomials)\n        {\n            \"n\": 100,\n            \"m\": 7,\n            \"x_gen\": lambda n: np.arange(n, dtype=float) / (n - 1),\n            \"orig_basis_builder\": lambda x, m: np.vander(x, m, increasing=True),\n            \"redesign_max_k\": 6\n        },\n        # Case 3 (edge case, already near-orthogonal)\n        {\n            \"n\": 80,\n            \"m\": 7,\n            \"x_gen\": lambda n: -1.0 + 2.0 * np.arange(n, dtype=float) / (n - 1),\n            \"orig_basis_builder\": lambda x, m: legendre_poly_values(m - 1, x),\n            \"redesign_max_k\": 6\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        n = case[\"n\"]\n        m = case[\"m\"]\n        \n        # 1. Generate sample points\n        x_i = case[\"x_gen\"](n)\n\n        # 2. Construct and analyze original design matrix\n        A_orig = case[\"orig_basis_builder\"](x_i, m)\n        kappa_orig = compute_condition_number(A_orig)\n\n        # 3. Transform sample points for redesign\n        x_min, x_max = np.min(x_i), np.max(x_i)\n        # Affine map x to t in [-1, 1]\n        # Avoid division by zero if x_min == x_max\n        if x_max  x_min:\n            t_i = 2.0 * (x_i - x_min) / (x_max - x_min) - 1.0\n        else: # all points are the same\n            t_i = np.zeros_like(x_i)\n\n        # 4. Construct and analyze redesigned design matrix\n        max_k = case[\"redesign_max_k\"]\n        A_redesign = legendre_poly_values(max_k, t_i)\n        kappa_redesign = compute_condition_number(A_redesign)\n        \n        # 5. Compute improvement factor\n        if kappa_redesign  np.finfo(float).eps:\n            improvement_factor = kappa_orig / kappa_redesign\n        else:\n            # If redesigned kappa is near zero, improvement is effectively infinite.\n            improvement_factor = np.inf\n            \n        results.append(improvement_factor)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3240835"}]}