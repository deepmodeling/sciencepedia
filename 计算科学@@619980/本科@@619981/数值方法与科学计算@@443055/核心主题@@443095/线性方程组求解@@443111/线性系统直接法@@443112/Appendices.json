{"hands_on_practices": [{"introduction": "Cholesky 分解是求解对称正定 (Symmetric Positive Definite, SPD) 线性系统的一种高效直接法。此练习将这一重要的线性代数工具与统计学中的一个核心概念——相关矩阵——联系起来。通过亲手推导一个 $3 \\times 3$ 相关矩阵的 Cholesky 分解 [@problem_id:3222494]，您不仅能深入理解算法的计算步骤，还能体会到为何对称正定性是该方法能够成功应用的关键前提。", "problem": "考虑三个联合分布的随机变量 $X_{1}$、$X_{2}$ 和 $X_{3}$，其中对于 $i \\in \\{1,2,3\\}$ 有 $\\mathbb{E}[X_{i}]=0$ 且 $\\operatorname{Var}(X_{i})=1$。它们的成对相关系数为 $\\rho_{12} = 0.5$、$\\rho_{13} = 0.2$ 和 $\\rho_{23} = 0.8$。这个 $3 \\times 3$ 的相关矩阵 $\\mathbf{R}$ 定义为：当 $i \\neq j$ 时，$R_{ij} = \\rho_{ij}$；当 $i = j$ 时，$R_{ii} = 1$。\n\n仅使用协方差和相关的定义、协方差矩阵和相关矩阵是对称半正定矩阵这一事实，以及对称正定 (SPD) 矩阵的性质，证明 $\\mathbf{R}$ 是对称正定的。然后，推导其 Cholesky 分解 $\\mathbf{R} = \\mathbf{L}\\mathbf{L}^{\\top}$，其中 $\\mathbf{L}$ 是一个对角线元素严格为正的下三角矩阵。你的推导过程应该是通过令 $\\mathbf{L}\\mathbf{L}^{\\top}$ 的元素与 $\\mathbf{R}$ 的相应元素相等，然后求解 $\\mathbf{L}$ 的元素。\n\n请用精确形式（使用分数和根式，而非小数近似值）表示 $\\mathbf{L}$ 的元素。最终答案必须是明确写出的单个下三角矩阵 $\\mathbf{L}$。", "solution": "我们首先根据给定信息构建相关矩阵 $\\mathbf{R}$。由于当 $i\\neq j$ 时 $R_{ii}=1$ 且 $R_{ij}=\\rho_{ij}$，我们有\n$$\n\\mathbf{R} = \n\\begin{pmatrix}\n1  & 0.5 & 0.2 \\\\\n0.5 & 1 & 0.8 \\\\\n0.2 & 0.8 & 1\n\\end{pmatrix}.\n$$\n为了进行精确计算，将非对角线元素重写为分数会很方便：$0.5 = \\frac{1}{2}$、$0.2 = \\frac{1}{5}$ 和 $0.8 = \\frac{4}{5}$。因此，\n$$\n\\mathbf{R} = \n\\begin{pmatrix}\n1 & \\frac{1}{2} & \\frac{1}{5} \\\\\n\\frac{1}{2} & 1 & \\frac{4}{5} \\\\\n\\frac{1}{5} & \\frac{4}{5} & 1\n\\end{pmatrix}.\n$$\n\n我们来证明 $\\mathbf{R}$ 是对称正定 (SPD) 的。根据定义，由于 $\\rho_{ij}=\\rho_{ji}$，其对称性是显而易见的。实随机变量的相关矩阵是半正定的，因为对于任意向量 $\\mathbf{y}\\in\\mathbb{R}^{3}$，\n$$\n\\mathbf{y}^{\\top}\\mathbf{R}\\mathbf{y} = \\operatorname{Var}\\!\\left(\\sum_{i=1}^{3} y_{i} X_{i}\\right) \\geq 0.\n$$\n要证明这个特定的 $\\mathbf{R}$ 是正定的，只需证明其所有顺序主子式都为正。计算行列式：\n- 第一个顺序主子式为 $1>0$。\n- 第二个顺序主子式为\n$$\n\\det\\begin{pmatrix}1 & \\frac{1}{2}\\\\ \\frac{1}{2} & 1\\end{pmatrix} = 1 - \\left(\\frac{1}{2}\\right)^{2} = \\frac{3}{4} > 0.\n$$\n- 完整的行列式为\n\\begin{align*}\n\\det(\\mathbf{R}) \n&= 1 \\cdot \\det\\begin{pmatrix}1 & \\frac{4}{5}\\\\ \\frac{4}{5} & 1\\end{pmatrix}\n- \\frac{1}{2} \\cdot \\det\\begin{pmatrix}\\frac{1}{2} & \\frac{4}{5}\\\\ \\frac{1}{5} & 1\\end{pmatrix}\n+ \\frac{1}{5} \\cdot \\det\\begin{pmatrix}\\frac{1}{2} & 1\\\\ \\frac{1}{5} & \\frac{4}{5}\\end{pmatrix} \\\\\n&= 1 \\cdot \\left(1 - \\frac{16}{25}\\right)\n- \\frac{1}{2} \\cdot \\left(\\frac{1}{2} - \\frac{4}{25}\\right)\n+ \\frac{1}{5} \\cdot \\left(\\frac{1}{2}\\cdot \\frac{4}{5} - 1\\cdot \\frac{1}{5}\\right) \\\\\n&= \\frac{9}{25} - \\frac{1}{2}\\cdot \\frac{17}{50} + \\frac{1}{5}\\cdot \\frac{1}{5}\n= \\frac{9}{25} - \\frac{17}{100} + \\frac{1}{25}\n= \\frac{36}{100} - \\frac{17}{100} + \\frac{4}{100}\n= \\frac{23}{100} > 0.\n\\end{align*}\n由于所有顺序主子式均为正，$\\mathbf{R}$ 是对称正定 (SPD) 的。\n\n对于一个 SPD 矩阵，存在唯一的 Cholesky 分解 $\\mathbf{R} = \\mathbf{L}\\mathbf{L}^{\\top}$，其中分解因子 $\\mathbf{L}$ 是一个对角线元素严格为正的下三角矩阵。设\n$$\n\\mathbf{L} = \n\\begin{pmatrix}\n\\ell_{11} & 0 & 0 \\\\\n\\ell_{21} & \\ell_{22} & 0 \\\\\n\\ell_{31} & \\ell_{32} & \\ell_{33}\n\\end{pmatrix}.\n$$\n我们通过令 $\\mathbf{L}\\mathbf{L}^{\\top}$ 与 $\\mathbf{R}$ 相等来确定其元素。乘积 $\\mathbf{L}\\mathbf{L}^{\\top}$ 的元素为\n\\begin{align*}\nR_{11} &= \\ell_{11}^{2}, \\\\\nR_{21} &= \\ell_{21}\\ell_{11}, \\quad R_{31} = \\ell_{31}\\ell_{11}, \\\\\nR_{22} &= \\ell_{21}^{2} + \\ell_{22}^{2}, \\\\\nR_{32} &= \\ell_{31}\\ell_{21} + \\ell_{32}\\ell_{22}, \\\\\nR_{33} &= \\ell_{31}^{2} + \\ell_{32}^{2} + \\ell_{33}^{2}.\n\\end{align*}\n代入相应的 $R_{ij}$ 值并依次求解：\n1. 由 $R_{11} = 1$ 可得 $\\ell_{11}^{2} = 1$，根据对角线元素为正的要求，有 $\\ell_{11} = 1$。\n2. 由 $R_{21} = \\frac{1}{2}$ 可得 $\\ell_{21}\\ell_{11} = \\frac{1}{2}$，因此 $\\ell_{21} = \\frac{1}{2}$。\n3. 由 $R_{31} = \\frac{1}{5}$ 可得 $\\ell_{31}\\ell_{11} = \\frac{1}{5}$，因此 $\\ell_{31} = \\frac{1}{5}$。\n4. 由 $R_{22} = 1$ 可得 $\\ell_{21}^{2} + \\ell_{22}^{2} = 1$，所以\n$$\n\\ell_{22}^{2} = 1 - \\left(\\frac{1}{2}\\right)^{2} = 1 - \\frac{1}{4} = \\frac{3}{4},\n\\quad \\ell_{22} = \\frac{\\sqrt{3}}{2}.\n$$\n5. 由 $R_{32} = \\frac{4}{5}$ 可得\n$$\n\\ell_{31}\\ell_{21} + \\ell_{32}\\ell_{22} = \\frac{4}{5}\n\\quad\\Rightarrow\\quad\n\\frac{1}{5}\\cdot \\frac{1}{2} + \\ell_{32}\\cdot \\frac{\\sqrt{3}}{2} = \\frac{4}{5}.\n$$\n因此\n$$\n\\ell_{32}\\cdot \\frac{\\sqrt{3}}{2} = \\frac{4}{5} - \\frac{1}{10} = \\frac{7}{10}\n\\quad\\Rightarrow\\quad\n\\ell_{32} = \\frac{7}{10}\\cdot \\frac{2}{\\sqrt{3}} = \\frac{7}{5\\sqrt{3}}.\n$$\n6. 由 $R_{33} = 1$ 可得\n$$\n\\ell_{31}^{2} + \\ell_{32}^{2} + \\ell_{33}^{2} = 1\n\\quad\\Rightarrow\\quad\n\\left(\\frac{1}{5}\\right)^{2} + \\left(\\frac{7}{5\\sqrt{3}}\\right)^{2} + \\ell_{33}^{2} = 1.\n$$\n计算前两项的和：\n$$\n\\left(\\frac{1}{5}\\right)^{2} = \\frac{1}{25}, \n\\quad\n\\left(\\frac{7}{5\\sqrt{3}}\\right)^{2} = \\frac{49}{25\\cdot 3} = \\frac{49}{75}.\n$$\n因此\n$$\n\\ell_{33}^{2} = 1 - \\frac{1}{25} - \\frac{49}{75}\n= 1 - \\frac{3}{75} - \\frac{49}{75}\n= 1 - \\frac{52}{75}\n= \\frac{23}{75},\n\\quad\n\\ell_{33} = \\sqrt{\\frac{23}{75}}.\n$$\n\n汇总所有元素，Cholesky 因子为\n$$\n\\mathbf{L} = \n\\begin{pmatrix}\n1 & 0 & 0 \\\\\n\\frac{1}{2} & \\frac{\\sqrt{3}}{2} & 0 \\\\\n\\frac{1}{5} & \\frac{7}{5\\sqrt{3}} & \\sqrt{\\frac{23}{75}}\n\\end{pmatrix},\n$$\n该矩阵满足 $\\mathbf{R} = \\mathbf{L}\\mathbf{L}^{\\top}$ 且对角线元素严格为正，符合要求。", "answer": "$$\\boxed{\\begin{pmatrix}1 & 0 & 0 \\\\ \\frac{1}{2} & \\frac{\\sqrt{3}}{2} & 0 \\\\ \\frac{1}{5} & \\frac{7}{5\\sqrt{3}} & \\sqrt{\\frac{23}{75}}\\end{pmatrix}}$$", "id": "3222494"}, {"introduction": "在科学与工程计算中，许多问题最终会归结为具有特定稀疏结构（例如三对角结构）的大型线性系统。针对这些系统，专门设计的算法（如托马斯算法）远比通用的高斯消元法更为高效。然而，直接法的一个固有挑战是数值不稳定性，例如当主元元素为零或接近于零时算法会失败。本练习 [@problem_id:3222549] 旨在引导您通过编程实践，实现托马斯算法并处理其潜在的失效情况。您将学习如何通过施加一个最小的对角线扰动来强制矩阵满足严格对角占主导条件，从而将一个数值不稳定的问题转化为一个能够稳健求解的问题，这正是连接理论与可靠数值软件的关键一步。", "problem": "您的任务是设计并实现一个完整的、可运行的程序，该程序使用直接法构建并求解一系列三对角线性方程组。每个方程组由一条次对角线、一条主对角线和一条超对角线定义。针对三对角矩阵的特殊高斯消元法（Thomas算法）在每一步都使用一个主元，该主元是当前有效的主对角线元素。如果任何主元为零（或小到在浮点数运算中无法使用），Thomas算法在不进行主元选择的情况下会失败。您的任务是：\n\n1. 检测因主元为零或数值上可忽略（定义为主元绝对值小于 $10^{-14}$）而导致的Thomas算法失败。\n2. 当检测到失败时，计算并应用最小的均匀对角平移量 $\\delta$（将 $\\delta$ 加到每个主对角线元素上），使得矩阵按行严格对角占优，从而恢复可解性并确保稳定性。\n3. 使用Thomas算法求解扰动后的系统，并报告解向量。\n\n理论基础：使用高斯消元法的标准定义及其三对角特化形式（Thomas算法）、对角占优的定义，以及一个经过充分检验的事实，即按行严格对角占优意味着矩阵可逆，并且在不进行主元选择的情况下可以防止出现零主元。\n\n使用的定义：\n- 一个大小为 $n$ 的三对角系统具有次对角线 $a \\in \\mathbb{R}^{n-1}$、主对角线 $d \\in \\mathbb{R}^{n}$、超对角线 $c \\in \\mathbb{R}^{n-1}$ 和右端项 $b \\in \\mathbb{R}^{n}$。该线性系统为 $A x = b$，其中矩阵 $A$ 的元素为 $A_{i,i} = d_i$，$A_{i,i+1} = c_i$（对于 $0 \\le i \\le n-2$），以及 $A_{i,i-1} = a_{i-1}$（对于 $1 \\le i \\le n-1$）。\n- 如果对于每一行 $i$，都有 $|d_i| > \\sum_{j \\ne i} |A_{i,j}|$，则该矩阵是按行严格对角占优的。对于三对角矩阵，这意味着 $|d_0| > |c_0|$，$|d_i| > |a_{i-1}| + |c_i|$（对于 $1 \\le i \\le n-2$），以及 $|d_{n-1}| > |a_{n-2}|$。\n\n您的程序必须：\n- 实现用于求解三对角系统的Thomas算法，并将任何满足 $|p| < 10^{-14}$ 的主元 $p$ 视为一次失败，该失败会触发均匀对角平移程序。\n- 计算能使扰动后矩阵按行严格对角占优的最小均匀对角平移量 $\\delta$，然后对平移后的系统 $A_\\delta = A + \\delta I$（其中 $I$ 为单位矩阵）重新运行Thomas算法。\n\n测试套件：\n使用以下四个测试用例。对于每个用例，请严格按照给定的值指定 $a$、$d$、$c$ 和 $b$。所有数字都必须按标准浮点数运算进行解释，不带任何物理单位。\n\n- 案例1（由于主对角线元素为零导致在第一个主元处失败）：\n  - 大小 $n = 5$\n  - 次对角线 $a = [\\,-1,\\,-1,\\,-1,\\,-1\\,]$\n  - 主对角线 $d = [\\,0,\\,2,\\,2,\\,2,\\,2\\,]$\n  - 超对角线 $c = [\\,-1,\\,-1,\\,-1,\\,-1\\,]$\n  - 右端项 $b = [\\,1,\\,0,\\,0,\\,0,\\,1\\,]$\n\n- 案例2（由于消元过程产生零主元导致在中间步骤失败）：\n  - 大小 $n = 4$\n  - 次对角线 $a = [\\,1,\\,1,\\,1\\,]$\n  - 主对角线 $d = [\\,1,\\,1,\\,2,\\,2\\,]$\n  - 超对角线 $c = [\\,1,\\,1,\\,1\\,]$\n  - 右端项 $b = [\\,1,\\,2,\\,3,\\,4\\,]$\n\n- 案例3（已为严格对角占优；无需扰动）：\n  - 大小 $n = 3$\n  - 次对角线 $a = [\\,-0.5,\\,-0.5\\,]$\n  - 主对角线 $d = [\\,2,\\,2,\\,2\\,]$\n  - 超对角线 $c = [\\,-0.5,\\,-0.5\\,]$\n  - 右端项 $b = [\\,1,\\,2,\\,3\\,]$\n\n- 案例4（第一个主元接近于零；根据给定容差视为失败）：\n  - 大小 $n = 4$\n  - 次对角线 $a = [\\,-1,\\,-1,\\,-1\\,]$\n  - 主对角线 $d = [\\,10^{-16},\\,2,\\,2,\\,2\\,]$\n  - 超对角线 $c = [\\,-1,\\,-1,\\,-1\\,]$\n  - 右端项 $b = [\\,1,\\,0,\\,0,\\,1\\,]$\n\n答案规范：\n- 对于每个测试用例，输出Thomas算法最终求解的（原始或扰动后）系统的解向量 $x$。每个解向量必须以浮点数列表的形式报告。\n- 您的程序应生成单行输出，其中包含收集到单个顶层列表中的四个解向量。将输出格式化为用方括号括起来的逗号分隔列表，每个案例对应一个内部列表，例如：$[[x\\_0,x\\_1,\\dots],[x\\_0,x\\_1,\\dots],[x\\_0,x\\_1,\\dots],[x\\_0,x\\_1,\\dots]]$。输出字符串中不得包含空格。", "solution": "在着手求解之前，我们对问题陈述的有效性进行了严格评估。\n\n### 步骤1：提取已知条件\n- **任务**：设计并实现一个程序，用于求解一系列三对角线性方程组 $Ax=b$。\n- **方法**：使用Thomas算法，这是一种直接法，也是高斯消元法的一种特化形式。\n- **矩阵定义**：大小为 $n \\times n$ 的三对角矩阵 $A$ 定义如下：\n    - 次对角线 $a \\in \\mathbb{R}^{n-1}$：$A_{i,i-1} = a_{i-1}$，对于 $1 \\le i \\le n-1$。\n    - 主对角线 $d \\in \\mathbb{R}^{n}$：$A_{i,i} = d_i$，对于 $0 \\le i \\le n-1$。\n    - 超对角线 $c \\in \\mathbb{R}^{n-1}$：$A_{i,i+1} = c_i$，对于 $0 \\le i \\le n-2$。\n    - 右端向量 $b \\in \\mathbb{R}^{n}$。\n- **失败条件**：如果主元 $p$ 的绝对值 $|p| < 10^{-14}$，则Thomas算法失败。\n- **恢复程序**：失败时，应用一个均匀的对角平移量 $\\delta$。求解新系统 $(A + \\delta I)x=b$，其中 $I$ 是单位矩阵。\n- **平移量计算**：平移量 $\\delta$ 必须是能使扰动后矩阵 $A_\\delta = A + \\delta I$ 按行严格对角占优的最小均匀值。\n- **严格对角占优 (SDD)**：对于每一行 $i$，对角线元素的绝对值大于非对角线元素的绝对值之和。对于三对角矩阵，这意味着：\n    - 第0行：$|d_0| > |c_0|$\n    - 第 $1 \\le i \\le n-2$ 行：$|d_i| > |a_{i-1}| + |c_i|$\n    - 第 $n-1$ 行：$|d_{n-1}| > |a_{n-2}|$\n- **测试套件**：提供了四个具体的测试用例，每个用例都给出了 $n, a, d, c, b$ 的值。\n- **输出格式**：包含四个解向量列表的单行字符串，格式为 `[[...],[...],...]`，不含空格。\n\n### 步骤2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题基于数值线性代数的基本概念，包括用于三对角系统的Thomas算法和严格对角占优的性质。这些都是标准的、完善的课题。该程序在科学上是合理的。\n2.  **适定性**：该问题是适定的。Thomas算法在成功时，对于非奇异矩阵会产生唯一解。严格对角占优保证了非奇异性，并确保高斯消元法（无行交换）中的所有主元都非零。因此，恢复程序将一个可能奇异或不稳定的系统转变为一个保证能用指定方法求解的系统。计算最小平移量 $\\delta$ 的指令会导出一个确定性的结果。\n3.  **客观性**：所有定义和条件都用精确的数学术语表达。失败容差（$10^{-14}$）是明确的。测试用例用精确的数值数据定义。没有主观或模糊的语言。\n4.  **完整性和一致性**：该问题是自洽的。它提供了所有必要的定义、数据和程序步骤。设置中没有矛盾之处。寻找“最小”平移量 $\\delta$ 的要求被解释为寻找绝对值最小的平移量，这在此类优化背景下是标准解释。\n\n### 步骤3：结论与行动\n该问题是**有效的**。这是一个定义明确、有科学依据的数值方法问题。我们将提供一个解决方案。\n\n### 求解设计\n解决方案包含两个主要部分：用于求解三对角系统的Thomas算法，以及在算法失败时计算对角平移量以强制实现严格对角占优的程序。\n\n**1. Thomas算法**\nThomas算法通过首先将系统 $Ax=b$ 转换为形如 $U_x=b'$ 的上三角系统，然后通过回代求解 $x$。这分两个阶段实现：\n\n**前向消元**：通过消去次对角线元素来变换矩阵。我们计算修改后的超对角线系数 $c'_i$ 和修改后的右端向量 $b'_i$。\n算法流程如下：\n我们将原始向量表示为 $a, d, c, b$。我们将计算修改后的向量 $c^*$（大小为 $n-1$）和 $b^*$（大小为 $n$）。\n第一个主元是 $p_0 = d_0$。如果 $|p_0| < 10^{-14}$，算法失败。否则：\n$$ c^*_0 = \\frac{c_0}{d_0} $$\n$$ b^*_0 = \\frac{b_0}{d_0} $$\n对于 $i = 1, 2, \\dots, n-1$，我们计算后续的主元和系数：\n第 $i$ 步的主元是 $p_i = d_i - a_{i-1} c^*_{i-1}$。如果 $|p_i| < 10^{-14}$，算法失败。否则：\n对于 $i = 1, \\dots, n-2$：\n$$ c^*_i = \\frac{c_i}{d_i - a_{i-1} c^*_{i-1}} $$\n以及对于 $i = 1, \\dots, n-1$：\n$$ b^*_i = \\frac{b_i - a_{i-1} b^*_{i-1}}{d_i - a_{i-1} c^*_{i-1}} $$\n注意，项 $c^*_{n-1}$ 和 $a_{n-1}$ 没有定义，这与矩阵维度是一致的。\n\n**回代**：前向消元后，系统等价于 $x_i + c^*_i x_{i+1} = b^*_i$（对于 $i < n-1$）和 $x_{n-1} = b^*_{n-1}$。解向量 $x$ 通过回代求得：\n$$ x_{n-1} = b^*_{n-1} $$\n对于 $i = n-2, n-3, \\dots, 0$：\n$$ x_i = b^*_i - c^*_i x_{i+1} $$\n\n**2. 实现严格对角占优的最小均匀对角平移**\n如果Thomas算法因主元接近于零而失败，我们必须找到最小（绝对值）的均匀平移量 $\\delta$，使得新矩阵 $A_\\delta = A + \\delta I$ 是严格对角占优（SDD）的。新的对角线是 $d'_i = d_i + \\delta$。\n\n$A_\\delta$ 满足SDD的条件是，对所有行 $i=0, \\dots, n-1$，都有 $|d_i + \\delta| > S_i$，其中 $S_i$ 是第 $i$ 行非对角线元素的绝对值之和：\n$$ S_0 = |c_0| $$\n$$ S_i = |a_{i-1}| + |c_i| \\quad \\text{for } 1 \\le i \\le n-2 $$\n$$ S_{n-1} = |a_{n-2}| $$\n每个不等式 $|d_i + \\delta| > S_i$ 等价于 $\\delta > S_i - d_i$ 或 $\\delta < -S_i - d_i$。为了对所有 $i$ 都满足这个条件，$\\delta$ 必须位于集合 $(-\\infty, \\delta_{\\text{low}}) \\cup (\\delta_{\\text{up}}, \\infty)$ 中，其中：\n$$ \\delta_{\\text{up}} = \\max_{i} (S_i - d_i) $$\n$$ \\delta_{\\text{low}} = \\min_{i} (-S_i - d_i) $$\n我们寻求该集合中绝对值最小的值。由于原始矩阵不是SDD（否则，假设它始于一个非奇异矩阵，算法就不会失败），$\\delta=0$ 不是一个解。因此，最小绝对值平移量的候选值是比 $\\delta_{\\text{up}}$ 大无穷小或比 $\\delta_{\\text{low}}$ 小无穷小的值。\n设 $\\epsilon$ 为一个小的正常数以确保严格不等式成立。考虑到问题的背景，一个合理的选择是 $\\epsilon = 10^{-14}$。候选的平移量是：\n$$ \\delta_1 = \\delta_{\\text{up}} + \\epsilon $$\n$$ \\delta_2 = \\delta_{\\text{low}} - \\epsilon $$\n所选的平移量 $\\delta$ 是绝对值较小的那个：\n$$ \\delta = \\begin{cases} \\delta_1 & \\text{if } |\\delta_1| \\le |\\delta_2| \\\\ \\delta_2 & \\text{if } |\\delta_1| > |\\delta_2| \\end{cases} $$\n利用这个 $\\delta$，我们构成新的对角向量 $d' = d + \\delta$，并使用Thomas算法重新求解系统 $(A+\\delta I)x=b$。第二次尝试保证会成功。\n\n**3. 实现策略**\n一个主函数将遍历所有测试用例。对每个用例，调用一个求解器函数。该求解器首先尝试使用Thomas算法求解原始矩阵的系统。如果检测到失败（返回一个空值），它将计算最小对角平移量 $\\delta$，将其应用于对角线，并对扰动后的系统再次调用Thomas算法。最终的解向量被收集并格式化为指定的输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _thomas_algorithm(a, d, c, b, tol):\n    \"\"\"\n    Solves a tridiagonal linear system Ax=b using the Thomas algorithm.\n\n    Args:\n        a (np.ndarray): The subdiagonal (length n-1).\n        d (np.ndarray): The main diagonal (length n).\n        c (np.ndarray): The superdiagonal (length n-1).\n        b (np.ndarray): The right-hand side vector (length n).\n        tol (float): The tolerance for pivot magnitude.\n\n    Returns:\n        np.ndarray: The solution vector x, or None if a pivot is too small.\n    \"\"\"\n    n = len(d)\n    a__ = np.copy(a)\n    d_ = np.copy(d)\n    c_ = np.copy(c)\n    b_ = np.copy(b)\n    \n    # Forward elimination\n    # Modify c and b vectors (c*, b* in theory)\n    \n    # First row\n    pivot = d_[0]\n    if abs(pivot)  tol:\n        return None\n    c_[0] = c_[0] / pivot\n    b_[0] = b_[0] / pivot\n\n    for i in range(1, n):\n        pivot_denom = d_[i] - a__[i-1] * c_[i-1]\n        if abs(pivot_denom)  tol:\n            return None\n        \n        if i  n - 1:\n            c_[i] = c_[i] / pivot_denom\n        \n        b_[i] = (b_[i] - a__[i-1] * b_[i-1]) / pivot_denom\n\n    # Backward substitution\n    x = np.zeros(n)\n    x[n-1] = b_[n-1]\n    for i in range(n - 2, -1, -1):\n        x[i] = b_[i] - c_[i] * x[i+1]\n        \n    return x\n\ndef solve_tridiagonal_system(a, d, c, b):\n    \"\"\"\n    Solves a tridiagonal system, applying a diagonal shift if necessary.\n\n    Args:\n        a (np.ndarray): Subdiagonal.\n        d (np.ndarray): Main diagonal.\n        c (np.ndarray): Superdiagonal.\n        b (np.ndarray): Right-hand side.\n\n    Returns:\n        np.ndarray: The solution vector x.\n    \"\"\"\n    n = len(d)\n    tol = 1e-14\n    \n    # First attempt with the original matrix\n    x = _thomas_algorithm(a, d, c, b, tol)\n    \n    if x is not None:\n        return x\n\n    # If the first attempt fails, compute the diagonal shift\n    # Calculate S_i, the sum of absolute off-diagonal values for each row\n    s = np.zeros(n)\n    s[0] = abs(c[0])\n    for i in range(1, n - 1):\n        s[i] = abs(a[i-1]) + abs(c[i])\n    if n > 1:\n        s[n-1] = abs(a[n-2])\n\n    delta_up = np.max(s - d)\n    delta_low = np.min(-s - d)\n    \n    epsilon = 1e-14\n    \n    delta_cand1 = delta_up + epsilon\n    delta_cand2 = delta_low - epsilon\n\n    if abs(delta_cand1) = abs(delta_cand2):\n        delta = delta_cand1\n    else:\n        delta = delta_cand2\n        \n    d_shifted = d + delta\n    \n    # Second attempt with the shifted matrix\n    x_shifted = _thomas_algorithm(a, d_shifted, c, b, tol)\n    \n    return x_shifted\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and generate the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 5,\n            \"a\": np.array([-1.0, -1.0, -1.0, -1.0]),\n            \"d\": np.array([0.0, 2.0, 2.0, 2.0, 2.0]),\n            \"c\": np.array([-1.0, -1.0, -1.0, -1.0]),\n            \"b\": np.array([1.0, 0.0, 0.0, 0.0, 1.0]),\n        },\n        {\n            \"n\": 4,\n            \"a\": np.array([1.0, 1.0, 1.0]),\n            \"d\": np.array([1.0, 1.0, 2.0, 2.0]),\n            \"c\": np.array([1.0, 1.0, 1.0]),\n            \"b\": np.array([1.0, 2.0, 3.0, 4.0]),\n        },\n        {\n            \"n\": 3,\n            \"a\": np.array([-0.5, -0.5]),\n            \"d\": np.array([2.0, 2.0, 2.0]),\n            \"c\": np.array([-0.5, -0.5]),\n            \"b\": np.array([1.0, 2.0, 3.0]),\n        },\n        {\n            \"n\": 4,\n            \"a\": np.array([-1.0, -1.0, -1.0]),\n            \"d\": np.array([1e-16, 2.0, 2.0, 2.0]),\n            \"c\": np.array([-1.0, -1.0, -1.0]),\n            \"b\": np.array([1.0, 0.0, 0.0, 1.0]),\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        solution = solve_tridiagonal_system(case[\"a\"], case[\"d\"], case[\"c\"], case[\"b\"])\n        results.append(solution.tolist())\n\n    # Format the output string exactly as specified.\n    output_string = str(results).replace(\" \", \"\")\n    print(output_string)\n\nsolve()\n```", "id": "3222549"}, {"introduction": "为了追求极致的计算速度，现代计算架构提供了不同精度的浮点运算（如 FP16、FP32、FP64）。一个核心的挑战是如何利用速度更快但精度更低的运算来加速求解，同时不牺牲最终解的准确性。这个高级实践 [@problem_id:3222481] 将带您探索一种强大的前沿技术——混合精度迭代精化。其核心思想是：在低精度下执行计算成本高昂的矩阵分解，然后返回高精度环境迭代地修正解的误差。通过这个编程任务，您将亲身体验矩阵的条件数 $\\kappa(A)$ 和机器算术精度 $u$ 如何共同决定了算法的收敛性，从而获得设计高性能数值求解器的宝贵见解。", "problem": "要求您构建并分析一个用于线性系统的混合精度直接求解器，该求解器将低精度因式分解与高精度迭代求精相结合。数学背景是求解系统 $A x = b$ 以得到 $x$，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是非奇异矩阵，而 $b \\in \\mathbb{R}^{n}$。\n\n构建一个程序，该程序：\n\n- 在低算术精度（Institute of Electrical and Electronics Engineers (IEEE) 754 binary16 (FP16) 或 binary32 (FP32)）下，使用部分主元法实现 $A$ 的直接因式分解。您必须在所选的低精度算术中完全执行消元操作、主元选择和三角求解。所选低精度的单位舍入误差 $u$ 仅用于分析和报告；程序应使用实际的数值类型来实现算术运算。\n- 在 IEEE 754 binary64 (FP64) 精度下应用迭代求精来改善解。在每个求精步骤中，在 FP64 中计算残差 $r = b - A x_k$，使用先前计算的低精度因子和三角求解来解 $A d = r$，并在 FP64 中更新 $x_{k+1} = x_k + d$。\n- 如果相对残差 $\\|r\\|_2 / \\|b\\|_2$ 在最多 $50$ 个求精步骤内降至阈值 $1 \\times 10^{-12}$ 以下，则宣布收敛。如果达到该阈值，则为该测试用例返回布尔结果 $\\text{True}$；否则，返回 $\\text{False}$。\n\n设计所需的基本依据：\n\n- 采用浮点算术的标准舍入模型：对于给定精度下单位舍入误差为 $u$ 的任何基本算术运算 $\\circ \\in \\{+, -, \\times, \\div\\}$，计算结果满足 $\\operatorname{fl}(a \\circ b) = (a \\circ b) (1 + \\delta)$，其中 $|\\delta| \\le u$。\n- 使用 $2$-范数条件数 $\\kappa_2(A) = \\|A\\|_2 \\|A^{-1}\\|_2$ 的概念来推断灵敏度和误差放大。\n- 将直接因式分解的分析建立在带部分主元的高斯消去法的后向稳定性解释之上：计算出的因子是邻近矩阵 $A + \\Delta A$ 的精确因子，其中 $\\|\\Delta A\\|$ 的界由 $u$ 和问题维度确定，并且三角求解产生的计算解是 $(A + \\Delta A) x = b$ 的精确解。\n\n测试套件和覆盖范围：\n\n对于每个测试用例，构造矩阵 $A$ 为 $\\mathbb{R}^{n \\times n}$ 中的对角矩阵，其对角线元素为 $[1, \\underbrace{1/\\kappa, \\ldots, 1/\\kappa}_{n-1 \\text{ times}}]$，使得 $\\kappa_2(A) = \\kappa$。使用 $n = 5$ 和右侧项 $b = [1, 2, 3, 4, 5]^T$。测试套件必须包括两种低精度类型和一系列条件数，以测试不同的情况：\n\n- 情况 1：FP16，$\\kappa = 10$。\n- 情况 2：FP16，$\\kappa = 1000$。\n- 情况 3：FP16，$\\kappa = 2048$（接近经典的 binary16 边界）。\n- 情况 4：FP16，$\\kappa = 3000$。\n- 情况 5：FP32，$\\kappa = 10^5$。\n- 情况 6：FP32，$\\kappa = 2^{24} = 16{,}777{,}216$（接近经典的 binary32 边界）。\n- 情况 7：FP32，$\\kappa = 5 \\times 10^7$。\n\n对于每种情况，按规定运行混合精度算法，并报告迭代求精是否在步数限制内达到收敛标准。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为按上述测试套件顺序排列的结果。每个元素必须是表示该情况是否收敛的布尔值（例如，$[\\text{True}, \\text{False}, \\ldots]$）。此问题不涉及任何物理单位。", "solution": "用户提供的问题是有效的。这是一个在数值线性代数领域内提法恰当、有科学依据的问题。所有需要的数据、定义和约束都已提供，没有矛盾或含糊之处。该问题要求实现并分析一种用于求解线性系统的混合精度迭代求精算法，这是科学计算中一种标准且重要的技术。\n\n问题的核心在于理解迭代求精的收敛特性，即当矩阵 $A$ 的因式分解在低精度算术（例如 FP16 或 FP32）中执行，而求精在高精度（FP64）中进行时。该方法的收敛性关键取决于矩阵 $A$ 的条件数（记为 $\\kappa(A)$）和低精度算术的单位舍入误差 $u_{low}$。\n\n设线性系统为 $A x = b$，其中 $A \\in \\mathbb{R}^{n \\times n}$。迭代求精过程从一个初始解 $x_0$ 开始，通过以下步骤生成一系列近似解 $x_k$：\n$1.$ 在高精度下计算残差：$r_k = b - A x_k$。\n$2.$ 使用 $A$ 的低精度因式分解从系统 $A d_k = r_k$ 中求解修正量 $d_k$。\n$3.$ 在高精度下更新解：$x_{k+1} = x_k + d_k$。\n\n关键步骤是修正量 $d_k$ 的计算。矩阵 $A$ 首先在低精度算术中被分解为 $\\hat{L}\\hat{U} \\approx A$。这个因式分解不是精确的；它对应于一个扰动矩阵的精确因式分解，即 $\\hat{L}\\hat{U} = A + \\Delta A$。后向误差 $\\Delta A$ 的界与 $\\|A\\|$ 和低精度单位舍入误差 $u_{low}$ 相关。然后使用这些因子求解修正方程。此外，在高精度下计算的残差 $r_k$ 必须先舍入到低精度，然后才能与低精度因子一同使用。\n\n我们来分析误差传播。第 $k$ 步解的误差是 $e_k = x - x_k$。对应的残差是 $r_k = b - A x_k = A(x - x_k) = A e_k$。\n计算出的修正量 $\\hat{d}_k$ 是 $\\hat{L}\\hat{U} \\hat{d}_k = \\operatorname{fl}(r_k)$ 的解，其中 $\\operatorname{fl}(\\cdot)$ 表示舍入到低精度。这可以写成：\n$$ \\hat{d}_k = (\\hat{L}\\hat{U})^{-1} \\operatorname{fl}(r_k) = (A + \\Delta A)^{-1} (r_k + \\delta_k) $$\n其中 $\\delta_k = \\operatorname{fl}(r_k) - r_k$ 是舍入残差产生的误差。该舍入误差的大小有界，为 $\\|\\delta_k\\| \\le u_{low} \\|r_k\\|$。\n\n新的解是 $x_{k+1} = x_k + \\hat{d}_k$，所以新的误差是：\n$$ e_{k+1} = x - x_{k+1} = (x - x_k) - \\hat{d}_k = e_k - (A + \\Delta A)^{-1} (A e_k + \\delta_k) $$\n对于小的 $\\Delta A$，使用近似 $(A + \\Delta A)^{-1} \\approx (I - A^{-1}\\Delta A)A^{-1}$，我们得到：\n$$ e_{k+1} \\approx e_k - (I - A^{-1}\\Delta A)A^{-1}(A e_k + \\delta_k) = e_k - (I - A^{-1}\\Delta A)(e_k + A^{-1}\\delta_k) $$\n展开并忽略二阶项（如 $\\Delta A \\cdot \\delta_k$），得到：\n$$ e_{k+1} \\approx e_k - (e_k + A^{-1}\\delta_k - A^{-1}\\Delta A e_k) = A^{-1}\\Delta A e_k - A^{-1}\\delta_k $$\n下一步的误差有两个分量，一个来自因式分解误差 $\\Delta A$，另一个来自残差舍入误差 $\\delta_k$。让我们对新误差的范数进行定界：\n$$ \\|e_{k+1}\\| \\le \\|A^{-1}\\Delta A e_k\\| + \\|A^{-1}\\delta_k\\| $$\n对于带部分主元的高斯消去法，后向误差的一个标准界是 $\\|\\Delta A\\| \\le C_n u_{low} \\|A\\|$，其中 $C_n$ 是一个取决于维度 $n$ 和增长因子的常数。第二项的界为 $\\|A^{-1}\\delta_k\\| \\le \\|A^{-1}\\| u_{low} \\|r_k\\| = \\|A^{-1}\\| u_{low} \\|A e_k\\| \\le u_{low} \\|A^{-1}\\| \\|A\\| \\|e_k\\| = u_{low} \\kappa(A) \\|e_k\\|$。\n两项都贡献了一个与 $u_{low} \\kappa(A)$ 成比例的因子。为了使误差收敛到零，从 $e_k$ 到 $e_{k+1}$ 的映射必须是压缩映射。这导出了迭代求精收敛的著名经验法则：\n$$ \\kappa(A) u_{low}  1 $$\n如果此条件成立，误差 $\\|e_k\\|$ 在每一步都会减小，求精过程收敛。如果 $\\kappa(A) u_{low} \\ge 1$，则不保证误差会减小，求精过程很可能会停滞或发散，无法达到高精度公差。\n\n指定精度的单位舍入误差对于 FP16 是 $u_{16} = 2^{-11} \\approx 4.88 \\times 10^{-4}$，对于 FP32 是 $u_{32} = 2^{-24} \\approx 5.96 \\times 10^{-8}$。我们现在可以根据收敛条件来评估测试用例。\n\n- 情况 1：FP16，$\\kappa = 10$。$\\kappa u_{16} = 10 \\times 2^{-11} \\approx 0.005 \\ll 1$。预期收敛。\n- 情况 2：FP16，$\\kappa = 1000$。$\\kappa u_{16} = 1000 \\times 2^{-11} \\approx 0.488  1$。预期收敛。\n- 情况 3：FP16，$\\kappa = 2048 = 2^{11}$。$\\kappa u_{16} = 2^{11} \\times 2^{-11} = 1$。这是边界情况。不保证误差会缩小。预期无法收敛到严格的公差。\n- 情况 4：FP16，$\\kappa = 3000$。$\\kappa u_{16} = 3000 \\times 2^{-11} \\approx 1.46  1$。预期发散或停滞。\n- 情况 5：FP32，$\\kappa = 10^5$。$\\kappa u_{32} = 10^5 \\times 2^{-24} \\approx 0.006 \\ll 1$。预期收敛。\n- 情况 6：FP32，$\\kappa = 2^{24}$。$\\kappa u_{32} = 2^{24} \\times 2^{-24} = 1$。这是 FP32 的边界情况。预期失败。\n- 情况 7：FP32，$\\kappa = 5 \\times 10^7$。$\\kappa u_{32} = 5 \\times 10^7 \\times 2^{-24} \\approx 2.98  1$。预期发散或停滞。\n\n此分析得出了测试套件的预期结果。所提供的 Python 代码按描述实现了混合精度算法，包括带部分主元的 LU 因式分解和迭代求精，并为每个步骤正确处理了指定的算术精度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lu_factor_pivoting(A):\n    \"\"\"\n    Performs LU factorization with partial pivoting for a square matrix A.\n    All arithmetic operations respect the dtype of A.\n\n    Args:\n        A (np.ndarray): The matrix to factorize, with a specific float dtype.\n\n    Returns:\n        tuple: A tuple containing:\n            - p_indices (np.ndarray): The permutation indices.\n            - L (np.ndarray): The lower triangular factor (unit diagonal).\n            - U (np.ndarray): The upper triangular factor.\n    \"\"\"\n    n = A.shape[0]\n    dtype = A.dtype\n    U = A.copy()\n    L = np.eye(n, dtype=dtype)\n    p_indices = np.arange(n)\n\n    for k in range(n - 1):\n        # Find pivot row in the sub-column\n        pivot_row_idx = np.argmax(np.abs(U[k:, k])) + k\n        \n        if pivot_row_idx != k:\n            # Swap rows in U\n            U[[k, pivot_row_idx], :] = U[[pivot_row_idx, k], :]\n            # Swap permutation indices\n            p_indices[[k, pivot_row_idx]] = p_indices[[pivot_row_idx, k]]\n            # Swap the computed part of L\n            if k  0:\n                L[[k, pivot_row_idx], :k] = L[[pivot_row_idx, k], :k]\n\n        # Check for singularity within the given precision\n        if U[k, k] == dtype.type(0):\n            continue  # Matrix is singular in this precision.\n\n        # Elimination\n        for i in range(k + 1, n):\n            multiplier = U[i, k] / U[k, k]\n            L[i, k] = multiplier\n            # Vectorized update of the row\n            U[i, k:] -= multiplier * U[k, k:]\n            # Enforce zero to prevent floating point artifacts\n            U[i, k] = dtype.type(0)\n\n    return p_indices, L, U\n\ndef solve_lower_triangular(L, b):\n    \"\"\"\n    Solves Ly = b for y, where L is a unit lower triangular matrix.\n    Arithmetic is performed in the dtype of L and b.\n    \"\"\"\n    n = L.shape[0]\n    dtype = L.dtype\n    y = np.zeros(n, dtype=dtype)\n    for i in range(n):\n        # dot product is more efficient and maintains dtype\n        s = b[i] - np.dot(L[i, :i], y[:i])\n        y[i] = s\n    return y\n\ndef solve_upper_triangular(U, y):\n    \"\"\"\n    Solves Ux = y for x, where U is an upper triangular matrix.\n    Arithmetic is performed in the dtype of U and y.\n    \"\"\"\n    n = U.shape[0]\n    dtype = U.dtype\n    x = np.zeros(n, dtype=dtype)\n    for i in range(n - 1, -1, -1):\n        s = y[i] - np.dot(U[i, i + 1:], x[i + 1:])\n        if U[i, i] != dtype.type(0):\n            x[i] = s / U[i, i]\n    return x\n\ndef run_mixed_precision_solver(A_orig, b_orig, low_prec_str):\n    \"\"\"\n    Implements the mixed-precision solver with iterative refinement.\n    \"\"\"\n    # 1. Setup precisions and constants\n    low_prec = np.float16 if low_prec_str == 'float16' else np.float32\n    high_prec = np.float64\n    max_iter = 50\n    tolerance = 1e-12\n\n    A_high = A_orig.astype(high_prec)\n    b_high = b_orig.astype(high_prec)\n\n    # 2. Low-precision factorization\n    A_low = A_high.astype(low_prec)\n    p_indices, L_low, U_low = lu_factor_pivoting(A_low)\n    \n    # 3. Initial solve using low-precision factors\n    b_low = b_high.astype(low_prec)\n    Pb_low = b_low[p_indices]\n    \n    y = solve_lower_triangular(L_low, Pb_low)\n    x0_low = solve_upper_triangular(U_low, y)\n    \n    x_k = x0_low.astype(high_prec)\n\n    # 4. Iterative Refinement\n    norm_b = np.linalg.norm(b_high, 2)\n    if norm_b == 0:\n        return True # Trivial solution is x=0\n\n    for _ in range(max_iter):\n        # Compute residual in high precision\n        r_high = b_high - A_high @ x_k\n        \n        # Check for convergence\n        rel_residual = np.linalg.norm(r_high, 2) / norm_b\n        if rel_residual  tolerance:\n            return True\n            \n        # Solve for the correction d in low precision (A d = r)\n        r_low = r_high.astype(low_prec)\n        \n        # Apply permutation to r\n        Pr_low = r_low[p_indices]\n        \n        d_y = solve_lower_triangular(L_low, Pr_low)\n        d_x_low = solve_upper_triangular(U_low, d_y)\n        \n        # Update solution in high precision\n        d_high = d_x_low.astype(high_prec)\n        x_k += d_high\n        \n    # Final check in case convergence happened on the last iteration\n    r_high = b_high - A_high @ x_k\n    rel_residual = np.linalg.norm(r_high, 2) / norm_b\n    if rel_residual  tolerance:\n        return True\n\n    return False\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        ('float16', 10.),\n        ('float16', 1000.),\n        ('float16', 2048.),\n        ('float16', 3000.),\n        ('float32', 1e5),\n        ('float32', 2.**24),\n        ('float32', 5e7),\n    ]\n\n    results = []\n    n = 5\n    # Use high-precision for original b\n    b_vec = np.array([1, 2, 3, 4, 5], dtype=np.float64)\n\n    for prec_str, kappa in test_cases:\n        # Construct the matrix A in high precision\n        diag_A = np.ones(n, dtype=np.float64)\n        if kappa != 1:\n            diag_A[1:] = 1.0 / kappa\n        A_mat = np.diag(diag_A)\n        \n        converged = run_mixed_precision_solver(A_mat, b_vec, prec_str)\n        results.append(str(converged))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "3222481"}]}