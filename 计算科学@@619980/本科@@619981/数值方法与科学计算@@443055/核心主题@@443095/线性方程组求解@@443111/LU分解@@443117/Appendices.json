{"hands_on_practices": [{"introduction": "掌握 LU 分解的第一步是熟悉其基本算法。本练习将引导你完成一个 $3 \\times 3$ 矩阵的 Doolittle 分解，这是一项基本技能。通过这个过程，你不仅能练习分解本身，还能将其与求解上三角矩阵的逆联系起来，这突显了矩阵分解形式的实用性。[@problem_id:2161051]", "problem": "在数值线性代数中，LU 分解是求解线性方程组、矩阵求逆和计算行列式的一种基本技术。对于一个方阵 $A$，Doolittle LU 分解是一种形如 $A = LU$ 的分解，其中 $L$ 是一个单位下三角矩阵（即主对角线上元素均为1的下三角矩阵），而 $U$ 是一个上三角矩阵。\n\n考虑如下给出的矩阵 $A$：\n$$\nA = \\begin{pmatrix} 2 & 1 & -1 \\\\ 4 & 5 & -1 \\\\ -2 & 8 & 8 \\end{pmatrix}\n$$\n你的任务是首先确定 $A$ 的 Doolittle LU 分解。在找到矩阵 $L$ 和 $U$ 之后，你必须接着求出上三角矩阵 $U$ 的逆矩阵 $U^{-1}$。\n\n将你的最终答案 $U^{-1}$ 以 3x3 矩阵的形式呈现。", "solution": "我们寻求 $A$ 的 Doolittle LU 分解，因此写出 $A=LU$，其中\n$$\nL=\\begin{pmatrix} 1 & 0 & 0 \\\\ \\ell_{21} & 1 & 0 \\\\ \\ell_{31} & \\ell_{32} & 1 \\end{pmatrix}, \\quad\nU=\\begin{pmatrix} u_{11} & u_{12} & u_{13} \\\\ 0 & u_{22} & u_{23} \\\\ 0 & 0 & u_{33} \\end{pmatrix}.\n$$\n使用 Doolittle 过程：\n- 从 $U$ 的第一行，设置 $u_{11}=a_{11}=2$，$u_{12}=a_{12}=1$，$u_{13}=a_{13}=-1$。\n- 计算乘数 $\\ell_{21}=\\frac{a_{21}}{u_{11}}=\\frac{4}{2}=2$ 和 $\\ell_{31}=\\frac{a_{31}}{u_{11}}=\\frac{-2}{2}=-1$。\n- 计算 $u_{22}=a_{22}-\\ell_{21}u_{12}=5-2\\cdot 1=3$ 和 $u_{23}=a_{23}-\\ell_{21}u_{13}=-1-2\\cdot(-1)=1$。\n- 计算 $\\ell_{32}=\\frac{a_{32}-\\ell_{31}u_{12}}{u_{22}}=\\frac{8-(-1)\\cdot 1}{3}=\\frac{9}{3}=3$。\n- 计算 $u_{33}=a_{33}-\\ell_{31}u_{13}-\\ell_{32}u_{23}=8-(-1)\\cdot(-1)-3\\cdot 1=4$。\n\n因此\n$$\nL=\\begin{pmatrix} 1 & 0 & 0 \\\\ 2 & 1 & 0 \\\\ -1 & 3 & 1 \\end{pmatrix}, \\quad\nU=\\begin{pmatrix} 2 & 1 & -1 \\\\ 0 & 3 & 1 \\\\ 0 & 0 & 4 \\end{pmatrix}.\n$$\n为了求 $U^{-1}$，我们逐列求解 $U X=I$。设 $X$ 的列向量为 $x^{(1)},x^{(2)},x^{(3)}$，求解 $U x^{(j)}=e_{j}$。\n\n对于 $j=1$：\n$$\n4x_{31}^{(1)}=0\\Rightarrow x_{31}^{(1)}=0,\\quad 3x_{21}^{(1)}+x_{31}^{(1)}=0\\Rightarrow x_{21}^{(1)}=0,\\quad 2x_{11}^{(1)}+x_{21}^{(1)}-x_{31}^{(1)}=1\\Rightarrow x_{11}^{(1)}=\\frac{1}{2}.\n$$\n因此 $x^{(1)}=(\\frac{1}{2},0,0)^{\\mathsf{T}}$。\n\n对于 $j=2$：\n$$\n4x_{32}^{(2)}=0\\Rightarrow x_{32}^{(2)}=0,\\quad 3x_{22}^{(2)}+x_{32}^{(2)}=1\\Rightarrow x_{22}^{(2)}=\\frac{1}{3},\\quad 2x_{12}^{(2)}+x_{22}^{(2)}-x_{32}^{(2)}=0\\Rightarrow x_{12}^{(2)}=-\\frac{1}{6}.\n$$\n因此 $x^{(2)}=(-\\frac{1}{6},\\frac{1}{3},0)^{\\mathsf{T}}$。\n\n对于 $j=3$：\n$$\n4x_{33}^{(3)}=1\\Rightarrow x_{33}^{(3)}=\\frac{1}{4},\\quad 3x_{23}^{(3)}+x_{33}^{(3)}=0\\Rightarrow x_{23}^{(3)}=-\\frac{1}{12},\\quad 2x_{13}^{(3)}+x_{23}^{(3)}-x_{33}^{(3)}=0\\Rightarrow x_{13}^{(3)}=\\frac{1}{6}.\n$$\n因此 $x^{(3)}=(\\frac{1}{6},-\\frac{1}{12},\\frac{1}{4})^{\\mathsf{T}}$。\n\n将这些列向量组合起来得到\n$$\nU^{-1}=\\begin{pmatrix}\n\\frac{1}{2}  & -\\frac{1}{6}  & \\frac{1}{6}\\\\\n0  & \\frac{1}{3}  & -\\frac{1}{12}\\\\\n0  & 0  & \\frac{1}{4}\n\\end{pmatrix}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{1}{2} & -\\frac{1}{6} & \\frac{1}{6} \\\\ 0 & \\frac{1}{3} & -\\frac{1}{12} \\\\ 0 & 0 & \\frac{1}{4} \\end{pmatrix}}$$", "id": "2161051"}, {"introduction": "基础的 LU 分解算法在分解过程中如果遇到主对角线元素为零（即零主元）时会失败。本练习通过一个简单的 $2 \\times 2$ 矩阵直观地展示了这个问题，并介绍了标准的解决方案——使用置换矩阵 $P$ 交换行，以确保主元非零。这引出了部分主元三角分解（$PA=LU$）的重要概念。[@problem_id:12984]", "problem": "在线性代数中，方阵 $A$ 的 LU 分解是一种形式为 $A = LU$ 的因式分解，其中 $L$ 是一个下三角矩阵，$U$ 是一个上三角矩阵。然而，如果不先对 $A$ 的行进行重新排序，这种分解并不总是可能的。具体来说，如果在高斯消元过程中，对角线上遇到零（一个“主元”元素），标准的 LU 分解算法就会失败。\n\n为了处理这种情况，我们引入一个置换矩阵 $P$。置换矩阵是通过对单位矩阵的行进行置换而得到的方阵。当我们将一个矩阵 $A$ 左乘一个置换矩阵 $P$ 时，其效果是重新排列 $A$ 的行。然后将因式分解应用于重新排序后的矩阵，得到 $PA = LU$。\n\n考虑一个由下式给出的一般 $2 \\times 2$ 矩阵 $A$：\n$$\nA = \\begin{pmatrix} 0 & a \\\\ b & c \\end{pmatrix}\n$$\n其中 $a$ 和 $b$ 是非零常数。标准的 LU 分解算法无法开始，因为第一行第一列的主元元素 $A_{11}$ 为零。\n\n推导必须应用于 $A$ 的特定 $2 \\times 2$ 置换矩阵 $P$，使得得到的矩阵 $A' = PA$ 在 $(1,1)$ 位置上有一个非零元素，从而使 LU 分解可以继续进行。", "solution": "我们寻求一个置换矩阵 $P$，使得\n$$A' = P A = \\begin{pmatrix} P_{11} & P_{12} \\\\ P_{21} & P_{22} \\end{pmatrix}\n\\begin{pmatrix} 0 & a \\\\ b & c \\end{pmatrix}$$\n的 $(1,1)$ 项非零。\n\n1. 一个 $2\\times2$ 的置换矩阵必须每行每列都恰好有一个“1”，其余位置均为零。仅有的候选者是单位矩阵\n$$I = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}$$ \n和行交换矩阵\n$$S = \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}.$$ \n\n2. 应用 $I$ 会使 $A$ 保持不变，因此 $(1,1)$ 项仍然为零。因此我们选择\n$$P = S = \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}.$$ \n\n3. 验证：\n$$PA =\n\\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}\n\\begin{pmatrix} 0 & a \\\\ b & c \\end{pmatrix}\n=\\begin{pmatrix} b & c \\\\ 0 & a \\end{pmatrix},$$\n确实 $(PA)_{11}=b\\neq0$，这使得 LU 分解可以继续进行。", "answer": "$$\\boxed{\\begin{pmatrix}0 & 1\\\\1 & 0\\end{pmatrix}}$$", "id": "12984"}, {"introduction": "在科学计算领域，理论算法必须面对有限精度计算的现实。这个编程练习通过将 LU 分解应用于著名的病态矩阵——希尔伯特矩阵，来探索其数值稳定性。通过亲手实现 Doolittle 和 Crout 两种方法并测量因子中的元素增长和残差，你将对数值稳定性的重要性获得切实的理解。[@problem_id:3249691]", "problem": "开发一个完整的、可运行的程序，用于分析在对希尔伯特矩阵应用两种经典的无主元选择的下三角-上三角 (LU) 分解算法时，所产生的三角因子中元素的幅值增长情况。你的程序必须直接从第一性原理出发，实现 LU 分解的 Doolittle 和 Crout 两种变体，并针对一小组希尔伯特矩阵测试集，报告增长和残差的量化指标。\n\n你必须使用的基本依据是：\n- 对于一个非奇异方阵 $A \\in \\mathbb{R}^{n \\times n}$，其 LU 分解是一个分解式 $A = L U$，其中 $L$ 是下三角矩阵，$U$ 是上三角矩阵。\n- 在 Doolittle 变体中，$L$ 是单位对角线的下三角矩阵，即对所有 $i$ 都有 $L_{ii} = 1$，$U$ 是具有通用对角线的上三角矩阵。\n- 在 Crout 变体中，$U$ 是单位对角线的上三角矩阵，即对所有 $i$ 都有 $U_{ii} = 1$，$L$ 是具有通用对角线的下三角矩阵。\n- 希尔伯特矩阵 $H_n \\in \\mathbb{R}^{n \\times n}$ 的分量由 $[H_n]_{ij} = \\frac{1}{i + j - 1}$ 给出，其中 $1 \\leq i,j \\leq n$。对于所有正整数 $n$，矩阵 $H_n$ 是对称正定的且非奇异的。\n\n从这些定义出发，在你的解决方案中逐步推导如何获得 $L$ 和 $U$ 的元素，确保在不使用主元选择的情况下其正确性。推导过程应通过等同 $A = L U$ 中的元素，并以与三角结构兼容的顺序求解未知数，而不假设任何已有的快捷公式。\n\n你的程序必须：\n- 对集合 $\\{1,2,5,10\\}$ 中的每个 $n$，使用双精度浮点运算构建 $H_n$。\n- 为每个 $n$ 计算两种分解：\n  - Doolittle 分解 $H_n = L^{(D)} U^{(D)}$，其中 $L^{(D)}$ 是单位对角线矩阵。\n  - Crout 分解 $H_n = L^{(C)} U^{(C)}$，其中 $U^{(C)}$ 是单位对角线矩阵。\n- 对于每种分解，计算：\n  - 下三角因子中的最大绝对值元素幅值，$g_L = \\max_{i,j} |L_{ij}|$。\n  - 上三角因子中的最大绝对值元素幅值，$g_U = \\max_{i,j} |U_{ij}|$。\n  - 分解的无穷范数残差，$r_{\\infty} = \\|H_n - L U\\|_{\\infty}$，其中 $\\|X\\|_{\\infty} = \\max_{1 \\le i \\le n} \\sum_{j=1}^n |X_{ij}|$。\n- 注意，对于希尔伯特矩阵，$\\max_{i,j} |[H_n]_{ij}| = 1$，因此原始幅值 $g_L$ 和 $g_U$ 已可作为相对于 $H_n$ 最大元素的归一化增长度量。\n\n科学真实性和数值稳健性要求：\n- 严格在不使用主元选择的情况下工作。\n- 仅使用标准的双精度浮点运算。\n- 不涉及物理单位。\n- 角度单位不适用。\n\n测试集和输出规范：\n- 使用测试集 $n \\in \\{1,2,5,10\\}$。\n- 对于每个 $n$，生成一个形式为 $[n, g_L^{(D)}, g_U^{(D)}, g_L^{(C)}, g_U^{(C)}, r_{\\infty}^{(D)}, r_{\\infty}^{(C)}]$ 的结果列表，其中上标 $(D)$ 和 $(C)$ 分别表示 Doolittle 和 Crout。\n- 你的程序应生成单行输出，其中包含所有 $n$ 的结果，形式为这些列表的逗号分隔列表，并用方括号括起来。例如，一个语法上有效的形状是 $[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\ldots]$，其中点的位置应为数值条目。\n\n最后一行必须是单行输出，不含任何额外注释。", "solution": "**1. 问题陈述分析与验证**\n\n该问题要求实现并分析 LU 分解的两种变体，即 Doolittle 方法和 Crout 方法，并应用于大小为 $n \\in \\{1, 2, 5, 10\\}$ 的希尔伯特矩阵 $H_n$。分析重点在于三角因子 $L$ 和 $U$ 中元素幅值的增长，以及分解的残差。这些算法将在不使用主元选择（pivoting）的情况下实现，这是允许的且数值稳定的，因为希尔伯特矩阵是对称正定 (Symmetric Positive Definite, SPD) 的。\n\n该问题具有科学依据，提法恰当且完整。所有定义——希尔伯特矩阵 $[H_n]_{ij} = (i+j-1)^{-1}$、Doolittle 分解 ($L_{ii}=1$)、Crout 分解 ($U_{ii}=1$) 以及无穷范数 $\\|X\\|_{\\infty} = \\max_i \\sum_j |X_{ij}|_—在数值线性代数中都是标准的。所提供的 $H_n$ 是对称正定的这一性质是正确且至关重要的，因为它保证了不带主元选择的 LU 分解存在、唯一且数值稳定。该任务是数值分析中的一个标准练习，可以得出一个清晰、可验证且非平凡的计算结果。因此，该问题被认为是有效的。\n\n**2. 从第一性原理推导 LU 分解算法**\n\n目标是对于给定的方阵 $A \\in \\mathbb{R}^{n \\times n}$，找到一个下三角矩阵 $L$ 和一个上三角矩阵 $U$，使得 $A = LU$。该矩阵乘法的逐元素定义为：\n$$A_{ij} = \\sum_{k=1}^{n} L_{ik} U_{kj}$$\n由于 $L$ 的三角性质（当 $k>i$ 时，$L_{ik}=0$）和 $U$ 的三角性质（当 $k>j$ 时，$U_{kj}=0$），求和可以简化为：\n$$A_{ij} = \\sum_{k=1}^{\\min(i,j)} L_{ik} U_{kj}$$\n为了确保分解的唯一性，必须从由 $A$ 的元素提供的 $n^2$ 个方程中确定 $L$ 和 $U$ 中的 $n^2$ 个未知元素。$L$ 和 $U$ 中潜在的未知数总共有 $n^2+n$ 个。因此，必须施加 $n$ 个额外的约束，通常是通过将 $L$ 或 $U$ 的对角线元素设置为 1 来实现。\n\n**2.1. Doolittle 算法 ($L_{ii}=1$)**\n\n在 Doolittle 变体中，$L$ 是一个单位下三角矩阵，即对所有 $i=1, \\dots, n$，$L_{ii} = 1$。未知数是 $L$ 的次对角线元素和 $U$ 的所有元素。我们可以通过分离未知量来推导出一个序贯算法。一种常见的方法是交替计算 $U$ 的行和 $L$ 的列。\n\n对于每个 $p$ 从 $1$ 到 $n$：\n1.  **计算 $U$ 的第 $p$ 行**：对于 $j = p, \\dots, n$，我们有：\n    $$A_{pj} = \\sum_{k=1}^{p} L_{pk} U_{kj} = \\sum_{k=1}^{p-1} L_{pk} U_{kj} + L_{pp} U_{pj}$$\n    因为 $L_{pp} = 1$，我们可以解出 $U_{pj}$：\n    $$U_{pj} = A_{pj} - \\sum_{k=1}^{p-1} L_{pk} U_{kj}$$\n2.  **计算 $L$ 的第 $p$ 列**：对于 $i = p+1, \\dots, n$，我们有：\n    $$A_{ip} = \\sum_{k=1}^{p} L_{ik} U_{kp} = \\sum_{k=1}^{p-1} L_{ik} U_{kp} + L_{ip} U_{pp}$$\n    由于 $U_{pp}$ 已经从上一步计算得出，我们可以解出 $L_{ip}$：\n    $$L_{ip} = \\frac{1}{U_{pp}} \\left( A_{ip} - \\sum_{k=1}^{p-1} L_{ik} U_{kp} \\right)$$\n    在这些计算中，右侧的所有元素都已在之前的步骤中计算得出。\n\n**2.2. Crout 算法 ($U_{ii}=1$)**\n\n在 Crout 变体中，$U$ 是一个单位上三角矩阵，即对所有 $i=1, \\dots, n$，$U_{ii} = 1$。未知数是 $U$ 的超对角线元素和 $L$ 的所有元素。算法与 Doolittle 类似，但计算顺序相反，即交替计算 $L$ 的列和 $U$ 的行。\n\n对于 $p=1, \\dots, n$：\n1.  **计算 $L$ 的第 $p$ 列**：对于 $i = p, \\dots, n$：\n    $$L_{ip} = A_{ip} - \\sum_{k=1}^{p-1} L_{ik} U_{kp}$$\n    这里，当 $p=1$ 时，求和为空。对于 $p>1$，所有 $L_{ik}$ 和 $U_{kp}$ 均已在之前的步骤中计算得出。\n2.  **计算 $U$ 的第 $p$ 行**：对于 $j = p+1, \\dots, n$：\n    $$U_{pj} = \\frac{1}{L_{pp}} \\left( A_{pj} - \\sum_{k=1}^{p-1} L_{pk} U_{kj} \\right)$$\n    同样，右侧的所有元素都已在之前的步骤中计算得出。\n\n这两种算法都可以直接实现，以满足问题的要求。由于希尔伯特矩阵是 SPD 的，所有主元 $U_{pp}$ (Doolittle) 和 $L_{pp}$ (Crout) 都保证为正，因此不会发生除以零的情况。\n\n**3. 实施计划**\n\n程序将按照以下步骤实现：\n1.  一个主函数，循环遍历 $n \\in \\{1, 2, 5, 10\\}$。\n2.  在循环内部：\n    a.  一个函数，用于为给定的 $n$ 生成 $H_n$。\n    b.  调用 Doolittle LU 分解函数，该函数根据 2.1 中的公式实现。\n    c.  调用 Crout LU 分解函数，该函数根据 2.2 中的公式实现。\n    d.  对每个分解，计算 $g_L = \\max|L_{ij}|$，$g_U = \\max|U_{ij}|$。\n    e.  对每个分解，计算残差矩阵 $R = H_n - LU$，并计算其无穷范数 $r_{\\infty} = \\|R\\|_{\\infty}$。\n    f.  将结果 $[n, g_L^{(D)}, g_U^{(D)}, g_L^{(C)}, g_U^{(C)}, r_{\\infty}^{(D)}, r_{\\infty}^{(C)}]$ 存储在一个列表中。\n3.  循环结束后，将所有结果列表格式化为单个字符串，并打印到标准输出。\n\n将使用 `numpy` 库进行基本的矩阵和向量操作，以提高效率和代码的可读性，同时确保核心分解逻辑是根据推导的公式显式编写的。无穷范数将使用 `numpy.linalg.norm(..., ord=numpy.inf)` 计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes LU factorization (Doolittle and Crout) for Hilbert matrices.\n    \"\"\"\n\n    def create_hilbert(n):\n        \"\"\"Constructs an n x n Hilbert matrix.\"\"\"\n        H = np.zeros((n, n), dtype=np.float64)\n        for i in range(n):\n            for j in range(n):\n                H[i, j] = 1.0 / (i + j + 1)\n        return H\n\n    def doolittle_lu(A):\n        \"\"\"\n        Computes the Doolittle LU factorization of matrix A (L is unit lower triangular).\n        Derived from first principles.\n        \"\"\"\n        n = A.shape[0]\n        L = np.eye(n, dtype=np.float64)\n        U = np.zeros((n, n), dtype=np.float64)\n\n        for p in range(n):\n            # Row p of U\n            for j in range(p, n):\n                # Summation part: sum(L[p, k] * U[k, j] for k in 0..p-1)\n                sum_val = np.dot(L[p, :p], U[:p, j])\n                U[p, j] = A[p, j] - sum_val\n\n            # Check for zero pivot before computing column p of L\n            if np.abs(U[p, p])  1e-16: # Avoid division by zero\n                # This should not happen for a positive definite matrix like Hilbert\n                # but is good practice for a general LU implementation.\n                raise np.linalg.LinAlgError(\"Zero pivot encountered in Doolittle LU\")\n\n            # Column p of L\n            for i in range(p + 1, n):\n                # Summation part: sum(L[i, k] * U[k, p] for k in 0..p-1)\n                sum_val = np.dot(L[i, :p], U[:p, p])\n                L[i, p] = (A[i, p] - sum_val) / U[p, p]\n        \n        return L, U\n\n    def crout_lu(A):\n        \"\"\"\n        Computes the Crout LU factorization of matrix A (U is unit upper triangular).\n        Derived from first principles.\n        \"\"\"\n        n = A.shape[0]\n        L = np.zeros((n, n), dtype=np.float64)\n        U = np.eye(n, dtype=np.float64)\n\n        for p in range(n):\n            # Column p of L\n            for i in range(p, n):\n                # Summation part: sum(L[i, k] * U[k, p] for k in 0..p-1)\n                sum_val = np.dot(L[i, :p], U[:p, p])\n                L[i, p] = A[i, p] - sum_val\n            \n            # Check for zero pivot before computing row p of U\n            if np.abs(L[p, p])  1e-16: # Avoid division by zero\n                raise np.linalg.LinAlgError(\"Zero pivot encountered in Crout LU\")\n            \n            # Row p of U\n            for j in range(p + 1, n):\n                # Summation part: sum(L[p, k] * U[k, j] for k in 0..p-1)\n                sum_val = np.dot(L[p, :p], U[:p, j])\n                U[p, j] = (A[p, j] - sum_val) / L[p, p]\n        \n        return L, U\n\n    test_cases_n = [1, 2, 5, 10]\n    results = []\n\n    for n in test_cases_n:\n        Hn = create_hilbert(n)\n\n        # Doolittle factorization\n        L_d, U_d = doolittle_lu(Hn)\n        g_L_d = np.max(np.abs(L_d))\n        g_U_d = np.max(np.abs(U_d))\n        residual_d = Hn - L_d @ U_d\n        r_inf_d = np.linalg.norm(residual_d, ord=np.inf)\n\n        # Crout factorization\n        L_c, U_c = crout_lu(Hn)\n        g_L_c = np.max(np.abs(L_c))\n        g_U_c = np.max(np.abs(U_c))\n        residual_c = Hn - L_c @ U_c\n        r_inf_c = np.linalg.norm(residual_c, ord=np.inf)\n        \n        # Assemble result list for this n\n        current_result = [n, g_L_d, g_U_d, g_L_c, g_U_c, r_inf_d, r_inf_c]\n        results.append(current_result)\n\n    # Format the final output string as a list of lists.\n    # The default str() representation of a list is used for the inner lists.\n    output_str = \"[\" + \",\".join([str(res) for res in results]) + \"]\"\n    \n    # Final print statement must be exactly this single line\n    print(output_str)\n\nsolve()\n```", "id": "3249691"}]}