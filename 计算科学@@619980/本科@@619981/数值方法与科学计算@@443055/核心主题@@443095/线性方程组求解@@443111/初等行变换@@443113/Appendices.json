{"hands_on_practices": [{"introduction": "高斯消元法是求解线性方程组的基石。这个过程的第一步，也是最关键的一步，就是在主元下方创造零。这个练习让你直接上手实践最核心的行替换操作，为解决更复杂的问题打下坚实的“肌肉记忆”基础。[@problem_id:1360670]", "problem": "考虑矩阵 $A$ 如下\n$$\nA = \\begin{pmatrix}\n2 & 1 & 3 \\\\\n-4 & -1 & 0 \\\\\n6 & 0 & 1\n\\end{pmatrix}\n$$\n在将矩阵变换为行阶梯形的过程中，一个关键步骤是在第一个主元下方引入零。对矩阵 $A$ 应用恰好两次初等行变换，将第一列的第二行和第三行中的元素置为零。得到的矩阵是什么？", "solution": "为了使用恰好两次初等行变换在第一列的第一个主元下方引入零，取主元为 $a_{11}=2$。对于第 $i$ 行的标准消元操作是 $R_{i} \\leftarrow R_{i} - \\left(\\frac{a_{i1}}{a_{11}}\\right) R_{1}$。\n\n对于第二行，$a_{21}=-4$，所以\n$$\nR_{2} \\leftarrow R_{2} - \\left(\\frac{-4}{2}\\right) R_{1} = R_{2} + 2 R_{1}.\n$$\n计算更新后的第二行：\n$$\n[-4,-1,0] + 2[2,1,3] = [-4+4,\\,-1+2,\\,0+6] = [0,1,6].\n$$\n\n对于第三行，$a_{31}=6$，所以\n$$\nR_{3} \\leftarrow R_{3} - \\left(\\frac{6}{2}\\right) R_{1} = R_{3} - 3 R_{1}.\n$$\n计算更新后的第三行：\n$$\n[6,0,1] - 3[2,1,3] = [6-6,\\,0-3,\\,1-9] = [0,-3,-8].\n$$\n\n在 $R_{1}$ 保持不变的情况下，经过这两次操作后得到的矩阵是\n$$\n\\begin{pmatrix}\n2 & 1 & 3 \\\\\n0 & 1 & 6 \\\\\n0 & -3 & -8\n\\end{pmatrix}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}2 & 1 & 3 \\\\ 0 & 1 & 6 \\\\ 0 & -3 & -8\\end{pmatrix}}$$", "id": "1360670"}, {"introduction": "初等行变换不仅是机械的数字操纵，它们还能揭示线性系统的内在结构。当我们将增广矩阵化为行阶梯形时，一个形如 $[0 \\dots 0 | c]$ （其中 $c$ 非零）的行直接告诉我们系统是矛盾的，因此无解。这个练习将抽象的代数变换与关于解的存在的具体结论联系起来，让你深刻理解为什么这些操作如此强大。[@problem_id:1360663]", "problem": "考虑一个包含两个变量 $x_1$ 和 $x_2$ 的二元线性方程组，该方程组依赖于一个实值参数 $k$：\n$$\n\\begin{cases}\nx_1 - 3x_2 = 5 \\\\\n-2x_1 + kx_2 = 4\n\\end{cases}\n$$\n表示该方程组的增广矩阵为\n$$\n\\begin{bmatrix}\n1 & -3 & | & 5 \\\\\n-2 & k & | & 4\n\\end{bmatrix}\n$$\n存在一个唯一的 $k$ 值，使得该方程组无解。这一事实可以通过对该矩阵应用一次初等行变换，在第二行的第一个元素位置上得到一个零来证明。求出这个特定的 $k$ 值。", "solution": "我们从增广矩阵开始\n$$\n\\begin{bmatrix}\n1 & -3 & | & 5 \\\\\n-2 & k & | & 4\n\\end{bmatrix}.\n$$\n为了通过一次初等行变换在第二行的第一个元素位置上得到一个零，我们将第一行的两倍加到第二行：\n$$\nR_{2} \\leftarrow R_{2} + 2R_{1}.\n$$\n计算新第二行的每个元素：\n- 第一个元素：$-2 + 2\\cdot 1 = 0$。\n- 第二个元素：$k + 2\\cdot(-3) = k - 6$。\n- 增广部分的元素：$4 + 2\\cdot 5 = 14$。\n\n因此矩阵变为\n$$\n\\begin{bmatrix}\n1 & -3 & | & 5 \\\\\n0 & k-6 & | & 14\n\\end{bmatrix}.\n$$\n该方程组无解，当且仅当第二个方程简化为 $0\\cdot x_{2} = 14$ 时，这是一个矛盾的方程。这种情况发生当且仅当系数 $k-6$ 等于零，而增广部分的元素非零。由于 $14 \\neq 0$，这种矛盾发生在\n$$\nk - 6 = 0 \\quad \\Rightarrow \\quad k = 6.\n$$\n因此，使得该方程组无解的唯一 $k$ 值为 $k = 6$。", "answer": "$$\\boxed{6}$$", "id": "1360663"}, {"introduction": "在理论线性代数中，任何非零主元都可以用于消元。然而，在科学计算的实际世界里，主元的选择对结果的准确性至关重要。直接应用高斯消元法（即不进行主元选择）可能会在数值上变得不稳定，尤其是在遇到小主元时，会导致巨大的误差。[@problem_id:3224076] 这个高级的、基于代码的练习将带你从理想化的理论走向浮点运算的现实。通过分析一个朴素消元法失败的案例，并观察行缩放预处理如何改善结果，你将对数值分析领域的核心挑战建立起关键的认识。", "problem": "考虑求解一个方形线性系统 $A x = b$，仅通过应用初等行变换，特别是行加法和行缩放，而不进行任何行交换（即不选主元）。此问题的基础是初等行变换的定义以及不选主元的高斯消元法 (GE) 的结构。特别地，在第 $k$ 步的消元乘数为 $m_{ik} = a_{ik}/a_{kk}$，更新操作为 $a_{i, j} \\leftarrow a_{i,j} - m_{ik} a_{k,j}$ 和 $b_i \\leftarrow b_i - m_{ik} b_k$，其中 $i > k$ 且 $j \\ge k$。为进行数值评估，定义归一化后向误差为\n$$\n\\eta(x;A,b) = \\frac{\\|b - A x\\|_\\infty}{\\|A\\|_\\infty \\|x\\|_\\infty + \\|b\\|_\\infty},\n$$\n以及不选主元的高斯消元法的元素增长因子为\n$$\n\\gamma(A) = \\frac{\\max_{i,j} |u_{ij}|}{\\max_{i,j} |a_{ij}|},\n$$\n其中 $U$ 是消元法生成的最终上三角矩阵。\n\n您的任务是构建并分析一个类似 Wilkinson 的例子，其中朴素消元法（不选主元）在数值上是不稳定的，然后应用最小行缩放（平衡化）来稳定该过程，并衡量后向误差的改善情况。最小行缩放是左对角缩放 $S = \\mathrm{diag}(s_1,\\dots,s_n)$，其中 $s_i = 1/\\max_{j} |a_{ij}|$，使得缩放后的系统 $S A x = S b$ 的所有行无穷范数均等于 $1$。由于 $S A x = S b$ 与 $A x = b$ 具有相同的解，因此计算出的缩放后系统的解被用作原始系统的近似解。\n\n具体来说，对每个测试用例执行以下操作：\n1. 通过设置 $x_{\\mathrm{true}} = \\mathbf{1}$（全为1的向量）和 $b = A x_{\\mathrm{true}}$，构建指定的矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和向量 $b \\in \\mathbb{R}^n$。\n2. 对 $A x = b$ 应用朴素高斯消元法（不选主元），仅使用行加法和行缩放。如果任何主元 $a_{kk}$ 满足 $|a_{kk}| < 10^{-20}$ 或变为非有限值，则视该测试用例的消元为失败。若失败，为报告目的，将归一化后向误差定义为 $\\eta = 1$，增长因子定义为 $+\\infty$。\n3. 应用上述定义的最小行缩放 $S$ 形成 $S A$ 和 $S b$，然后通过同样的不选主元的朴素高斯消元法求解 $(S A) x = (S b)$。使用得到的解 $x$ 计算相对于原始系统 $(A,b)$ 的归一化后向误差，并使用缩放后的矩阵 $S A$ 报告元素增长因子。\n4. 对每个测试用例，报告五个浮点数：未缩放的增长因子 $\\gamma(A)$、缩放后的增长因子 $\\gamma(SA)$、未缩放的归一化后向误差 $\\eta(A)$、缩放后的归一化后向误差 $\\eta(SA)$，以及改善比率 $\\eta(A)/\\eta(SA)$。\n\n使用以下测试套件，其中包括一般情况、边界压力情况和经典的病态族：\n- 测试用例 1：一个大小为 $n=8$ 的类似 Wilkinson 的符号模式矩阵，其首个主元极小，为 $\\epsilon = 10^{-16}$，定义如下\n$$\nw_{ij} = \\begin{cases}\n\\epsilon, & i=j=1,\\\\\n1, & i \\le j \\text{ and } (i,j) \\ne (1,1),\\\\\n-1, & i > j.\n\\end{cases}\n$$\n- 测试用例 2：与上述类似 Wilkinson 的构造相同，但 $n=12$ 且 $\\epsilon = 10^{-18}$（一个边界压力情况）。\n- 测试用例 3：一个大小为 $n=10$ 的 Vandermonde 矩阵，节点为 $t_i = 1 + i \\delta$，其中 $\\delta = 10^{-4}$，且 $V_{ij} = t_i^{j-1}$。\n- 测试用例 4：一个大小为 $n=12$ 的 Hilbert 矩阵，$H_{ij} = \\frac{1}{i + j - 1}$。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，每个元素对应一个测试用例，并且本身是一个包含五个浮点数的方括号括起来的逗号分隔列表，顺序为 $[\\gamma(A),\\gamma(SA),\\eta(A),\\eta(SA),\\eta(A)/\\eta(SA)]$。例如，整体格式为\n$$\n\\bigl[[g_1^{\\mathrm{ns}},g_1^{\\mathrm{s}},\\eta_1^{\\mathrm{ns}},\\eta_1^{\\mathrm{s}},r_1],\\dots,[g_4^{\\mathrm{ns}},g_4^{\\mathrm{s}},\\eta_4^{\\mathrm{ns}},\\eta_4^{\\mathrm{s}},r_4]\\bigr],\n$$\n打印的行中不含任何空白字符。此问题不涉及物理单位或角度。所有输出均为实数或适用的 $+\\infty$。", "solution": "此问题要求分析不选主元的高斯消元法 (GE) 的数值稳定性。我们的任务是比较这种朴素算法在原始线性系统 $A x = b$ 与预处理后的系统 $(S A) x = (S b)$ 上的性能，其中 $S$ 是一个对角缩放矩阵，旨在平衡系数矩阵的行范数。\n\n分析的核心基于两个指标：\n1.  **元素增长因子**，$\\gamma(A) = \\frac{\\max_{i,j} |u_{ij}|}{\\max_{i,j} |a_{ij}|}$，其中 $U$ 是消元法得到的上三角矩阵。该因子量化了消元过程中元素量值的增长程度。大的增长因子是数值不稳定的典型标志，因为它会放大舍入误差。\n2.  **归一化后向误差**，$\\eta(x;A,b) = \\frac{\\|b - A x\\|_\\infty}{\\|A\\|_\\infty \\|x\\|_\\infty + \\|b\\|_\\infty}$。该指标衡量计算解 $x$ 的质量。小的后向误差表明计算解是某个邻近问题的精确解，这是数值算法的一个理想属性。\n\n所用的稳定化技术是行平衡化。构造一个对角矩阵 $S = \\mathrm{diag}(s_1, \\dots, s_n)$，其缩放因子为 $s_i = 1/\\max_{j} |a_{ij}|$。将此缩放应用于系统 $A x = b$ 得到 $S A x = S b$。这种缩放的目标，也称为使矩阵的行无穷范数为单位1，是为了缓解因行尺度差异巨大而在没有主元选择时可能误导消元过程的问题。\n\n算法流程如下：\n首先，定义一个实现朴素高斯消元法的函数。该函数接收矩阵 $A$ 和向量 $b$，执行前向消元以生成一个上三角系统，然后使用回代法求得解 $x$。至关重要的是，该函数会监控主元 $a_{kk}$。如果某个主元的绝对值小于阈值（$10^{-20}$）或任何元素变为非有限值（如 `inf` 或 `nan`），则将消元标记为失败。根据问题规范，失败将导致报告的增长因子为 $+\\infty$，后向误差为 $1$。\n\n对于提供的四个测试用例中的每一个：\n1.  构造矩阵 $A$ 和右侧向量 $b$。向量 $b$ 通过将真解 $x_{\\mathrm{true}}$ 设置为全1向量来确定，即 $b = A x_{\\mathrm{true}}$。这提供了一个已知的参考解。\n2.  使用朴素GE函数求解未缩放的系统 $A x = b$。计算增长因子 $\\gamma(A)$ 和归一化后向误差 $\\eta(A)$。\n3.  根据 $A$ 的行无穷范数构造缩放矩阵 $S$。然后形成缩放后的系统 $(S A) x = (S b)$。\n4.  使用相同的朴素GE函数求解缩放后的系统。增长因子 $\\gamma(S A)$ 是相对于缩放后的矩阵 $S A$ 计算的。然后，使用得到的解向量计算相对于*原始*系统 $(A, b)$ 的归一化后向误差 $\\eta(S A)$，因为这为原始问题的解质量提供了直接比较。\n5.  最后，计算改善比率 $\\eta(A)/\\eta(S A)$ 以量化缩放的有效性。\n\n选择这四个测试用例是为了突出数值稳定性的不同方面：\n- **类似 Wilkinson 的矩阵（用例1和2）：** 这些是典型的例子，其中尽管矩阵是良态的，但一个小的首个主元会导致朴素GE中灾难性的元素增长和误差放大。预计所规定的特定平衡方案（对于这种矩阵结构，结果为 $S=I$）将无法缓解不稳定性，这表明行缩放并非万能解决方案，在这种情况下主元选择至关重要。\n- **Vandermonde 和 Hilbert 矩阵（用例3和4）：** 这些是经典的病态矩阵例子，其行之间的尺度可能差异巨大。预计行平衡化将显著提高朴素GE对这些系统的数值稳定性，从而导致更小的增长因子、低得多的后向误差和大的改善比率。\n\n实现将系统地对所有测试用例执行此过程，收集五个指定的浮点值：$\\gamma(A)$、$\\gamma(SA)$、$\\eta(A)$、$\\eta(SA)$ 和比率 $\\eta(A)/\\eta(SA)$。然后将这些结果按要求格式化为单行字符串。", "answer": "```python\nimport numpy as np\n\ndef solve_ge_naive(A_in, b_in, failure_threshold=1e-20):\n    \"\"\"\n    Solves Ax = b using Gaussian elimination without pivoting.\n    Returns the solution x and the growth factor gamma.\n    On failure, returns (None, np.inf).\n    \"\"\"\n    n = A_in.shape[0]\n    A = A_in.copy().astype(np.float64)\n    b = b_in.copy().astype(np.float64)\n\n    max_abs_initial_A = np.max(np.abs(A_in))\n    if max_abs_initial_A == 0:\n        if np.all(b_in == 0):\n            return np.zeros(n, dtype=np.float64), 1.0\n        else:\n            return None, np.inf\n\n    # Forward elimination\n    for k in range(n):\n        pivot = A[k, k]\n        if not np.isfinite(pivot) or abs(pivot)  failure_threshold:\n            return None, np.inf\n\n        for i in range(k + 1, n):\n            m = A[i, k] / pivot\n            A[i, k:] -= m * A[k, k:]\n            b[i] -= m * b[k]\n\n    U = np.triu(A)\n    \n    if not np.all(np.isfinite(U)):\n        return None, np.inf\n\n    gamma = np.max(np.abs(U)) / max_abs_initial_A\n\n    # Back substitution\n    x = np.zeros(n, dtype=np.float64)\n    for i in range(n - 1, -1, -1):\n        pivot_back = A[i, i]\n        if abs(pivot_back) == 0:\n            return None, gamma\n        \n        sum_ax = A[i, i + 1:] @ x[i + 1:]\n        x[i] = (b[i] - sum_ax) / pivot_back\n\n    if not np.all(np.isfinite(x)):\n        return None, gamma\n\n    return x, gamma\n\ndef compute_backward_error(A_orig, b_orig, x_computed):\n    \"\"\"\n    Computes the normalized backward error for a computed solution x_computed.\n    \"\"\"\n    if x_computed is None or not np.all(np.isfinite(x_computed)):\n        return 1.0\n\n    norm_A_inf = np.linalg.norm(A_orig, ord=np.inf)\n    norm_x_inf = np.linalg.norm(x_computed, ord=np.inf)\n    norm_b_inf = np.linalg.norm(b_orig, ord=np.inf)\n    \n    residual = b_orig - A_orig @ x_computed\n    norm_res_inf = np.linalg.norm(residual, ord=np.inf)\n    \n    denominator = norm_A_inf * norm_x_inf + norm_b_inf\n    \n    if denominator == 0:\n        return 0.0 if norm_res_inf == 0 else np.inf\n\n    return norm_res_inf / denominator\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases_params = [\n        {'type': 'wilkinson', 'n': 8, 'eps': 1e-16},\n        {'type': 'wilkinson', 'n': 12, 'eps': 1e-18},\n        {'type': 'vandermonde', 'n': 10, 'delta': 1e-4},\n        {'type': 'hilbert', 'n': 12}\n    ]\n\n    all_results = []\n\n    for params in test_cases_params:\n        n = params['n']\n        if params['type'] == 'wilkinson':\n            eps = params['eps']\n            A = np.ones((n, n), dtype=np.float64)\n            rows, cols = np.tril_indices(n, -1)\n            A[rows, cols] = -1.0\n            A[0, 0] = eps\n        elif params['type'] == 'vandermonde':\n            delta = params['delta']\n            t_nodes = 1.0 + (np.arange(n) + 1.0) * delta\n            A = np.vander(t_nodes, increasing=True)\n        elif params['type'] == 'hilbert':\n            i, j = np.indices((n, n))\n            A = 1.0 / (i + j + 1.0)\n        \n        A_orig = A.copy()\n        x_true = np.ones(n, dtype=np.float64)\n        b_orig = A_orig @ x_true\n        \n        # Unscaled analysis\n        x_ns, gamma_ns = solve_ge_naive(A_orig, b_orig)\n        eta_ns = compute_backward_error(A_orig, b_orig, x_ns)\n        if x_ns is None:\n            eta_ns = 1.0\n            \n        # Scaled analysis\n        row_maxs = np.max(np.abs(A_orig), axis=1)\n        s = np.divide(1.0, row_maxs, out=np.ones_like(row_maxs), where=row_maxs != 0)\n        SA = np.diag(s) @ A_orig\n        Sb = s * b_orig\n        \n        x_s, gamma_s = solve_ge_naive(SA, Sb)\n        eta_s = compute_backward_error(A_orig, b_orig, x_s)\n        if x_s is None:\n            eta_s = 1.0\n            \n        # Improvement ratio\n        if eta_s == 0.0:\n            ratio = np.inf if eta_ns > 0.0 else 1.0\n        else:\n            ratio = eta_ns / eta_s\n\n        all_results.append([gamma_ns, gamma_s, eta_ns, eta_s, ratio])\n\n    # Format and print the final output\n    outer_parts = []\n    for res_case in all_results:\n        inner_str = \",\".join(map(str, res_case))\n        outer_parts.append(f\"[{inner_str}]\")\n    \n    final_output = f\"[{','.join(outer_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3224076"}]}