{"hands_on_practices": [{"introduction": "许多科学与工程问题引出的线性系统不仅是三对角的，而且是对称的。本练习将引导你利用这种对称性来优化标准的Thomas算法。通过推导并实现一个基于$LDL^{\\mathsf{T}}$分解的专用求解器 [@problem_id:3208596]，你将亲身体验如何通过利用矩阵的特殊结构来减少存储需求和计算量，从而提高算法效率。", "problem": "考虑一个线性系统 $A x = f$，其中 $A$ 是一个 $n \\times n$ 维的对称三对角矩阵。根据定义，$A$ 的非零元素仅存在于其主对角线、第一条次对角线和第一条超对角线上，且对称性意味着次对角线等于超对角线。设主对角线由 $a_1,a_2,\\dots,a_n$ 指定，次（和超）对角线由 $b_1,b_2,\\dots,b_{n-1}$ 指定，因此 $A_{i,i} = a_i$ 且 $A_{i,i+1} = A_{i+1,i} = b_i$，其中 $i = 1,2,\\dots,n-1$。向量 $x$ 是未知数，$f$ 是给定的右端项。\n\n从带状系统高斯消元法的基础和对称性的定义出发，推导出一个专门的消元和代换方案，该方案利用对称性来最小化存储量和算术运算次数。具体要求如下：\n- 从针对三对角矩阵的、用相邻行局部操作表示的高斯消元法开始，并利用 $A$ 的对称性来推断在消元过程中保持的结构。证明消元过程可以使用一个单一的乘子序列和一个单一的主元序列来组织，而无需存储不同的次对角线和超对角线数组。\n- 利用对称矩阵和主子式的性质，论证该消元过程会产生一个下三角和对角结构，对于任何不会在消元中遇到零主元的右端项 $f$，该结构可用于高效的前向和后向代换。\n- 提供一个清晰、分步的算法，该算法首先执行一次前向扫描，计算必要的标量序列和一个中间向量，然后进行一次对角求解，接着进行一次后向扫描，所有这些操作仅使用主对角线数组 $a_i$、一个非对角线数组 $b_i$ 和右端项 $f$。\n- 与用于非对称三对角系统的通用托马斯算法相比，分析您专门方案的存储需求和运算次数，并精确指出在利用对称性时减少了哪些部分。\n\n将您推导的算法在一个单一的可运行程序中实现。该程序必须对以下每个测试用例求解系统 $A x = f$，这些测试用例共同探测了典型、边界和边缘行为：\n\n- 测试用例 1（对称正定“顺利路径”）：$n = 6$，$a_i = 2$ 对所有 $i = 1,\\dots,6$，$b_i = -1$ 对所有 $i = 1,\\dots,5$，$f = [\\,1,\\,1,\\,1,\\,1,\\,1,\\,1\\,]$。\n- 测试用例 2（边界尺寸）：$n = 1$，$a_1 = 3$，$b$ 为空，$f = [\\,6\\,]$。\n- 测试用例 3（对称不定但非奇异）：$n = 3$，$a = [\\,0.5,\\,-1.2,\\,0.5\\,]$，$b = [\\,1.0,\\,1.0\\,]$，$f = [\\,1.0,\\,2.0,\\,3.0\\,]$。\n- 测试用例 4（作为具有零非对角元素的三对角矩阵的对角矩阵）：$n = 3$，$a = [\\,5,\\,7,\\,9\\,]$，$b = [\\,0,\\,0\\,]$，$f = [\\,10,\\,14,\\,27\\,]$。\n\n所有输入均为无量纲实数。您必须将输出表示为实数。对于每个测试用例，输出是解向量 $x$，以浮点数列表的形式表示。\n\n最终输出格式规范：\n- 您的程序应生成单行输出，其中包含四个测试用例的解，格式为一个由方括号括起来的、用逗号分隔的列表的列表，不含空格。例如，如果四个解向量分别为 $[\\,x_1,x_2\\,]$、$[\\,y_1\\,]$、$[\\,z_1,z_2,z_3\\,]$ 和 $[\\,w_1,w_2,w_3\\,]$，则格式应为 $[[x_1,x_2],[y_1],[z_1,z_2,z_3],[w_1,w_2,w_3]]$。", "solution": "我们从三对角系统的高斯消元法开始。三对角矩阵的非零元素仅位于主对角线以及第一条次对角线和超对角线上。对于一个一般的三对角系统 $A x = f$，托马斯算法执行前向消元，逐步将次对角线元素置零，从而生成一个上三角系统，然后进行后向代换。\n\n此处的特殊设定是 $A$ 是对称三对角矩阵。对称性意味着 $A_{i+1,i} = A_{i,i+1}$，因此只需要一个非对角线数组。设主对角线为 $a_1,\\dots,a_n$，非对角线为 $b_1,\\dots,b_{n-1}$。在第 $i$ 步（对于 $i = 2,\\dots,n$），局部消元使用第 $i-1$ 行的主元来消去第 $i$ 行的次对角线元素。在带状系统中，由于稀疏性，消元仅影响相邻行。\n\n基本原理：用于三对角矩阵的高斯消元法通过给第 $i$ 行加上第 $i-1$ 行的 $\\ell_i$ 倍来消去 $A_{i,i-1}$，其中乘子的选择使得新的次对角线元素变为零。乘子的值为\n$$\n\\ell_i = \\frac{A_{i,i-1}}{\\tilde{A}_{i-1,i-1}},\n$$\n其中 $\\tilde{A}$ 表示经过先前消元后，在该步骤中正在运行的、被修改的系数。对于三对角矩阵，在第 $i-1$ 步消元后，第 $i-1$ 行中可能影响第 $i$ 行的元素只有对角元 $\\tilde{A}_{i-1,i-1}$ 和超对角元 $\\tilde{A}_{i-1,i}$。根据对称性和带状性，$\\tilde{A}_{i-1,i}$ 等于非对角元 $b_{i-1}$，因为相邻行消元所保持的结构不会在第一条超对角线之外引入填充元素。\n\n因此，第 $i$ 步的消元通过一个依赖于 $\\ell_i$ 和非对角元 $b_{i-1}$ 的秩一修正来更新第 $i$ 行的对角元，而右端项 $f$ 则在前向代换中接受类似的更新。具体来说，我们维护一个由 $d_i = \\tilde{A}_{i,i}$ 表示的主元序列和一个由 $\\ell_i = \\tilde{A}_{i,i-1}/d_{i-1}$ 表示的乘子序列，其中 $d_1 = a_1$，$\\ell_1$ 未使用。前向扫描遵循以下递推关系\n$$\n\\ell_i = \\frac{b_{i-1}}{d_{i-1}}, \\quad d_i = a_i - \\ell_i\\,b_{i-1}, \\quad y_i = f_i - \\ell_i\\,y_{i-1},\n$$\n对于 $i = 2,\\dots,n$，初始化为 $y_1 = f_1$。这些关系直接源于高斯消元法：从第 $i$ 行减去第 $i-1$ 行的 $\\ell_i$ 倍会消去次对角线元素，并且因为第 $i-1$ 行在其对角元之外唯一的非零元素是超对角元 $b_{i-1}$，所以第 $i$ 行的对角元减少了 $\\ell_i b_{i-1}$；第 $i$ 行的右端项则减少了 $\\ell_i y_{i-1}$。\n\n该结构可以解释为 $L D L^{\\mathsf{T}}$ 分解，这是一个经过充分检验的事实，适用于对称矩阵在所有主子式非零（即消元过程中没有主元失效）的情况。具体而言，\n$$\nA = L D L^{\\mathsf{T}},\n$$\n其中 $L$ 是单位下三角矩阵，其非对角线元素为 $\\ell_2,\\dots,\\ell_n$，对角线元素为 1；$D$ 是对角矩阵，其对角元素为 $d_1,\\dots,d_n$。这是因为每一步消元仅使用前一行的倍数来更新当前行，保持了对称性和三对角结构；累积效应等同于将 $A$ 分解为一个单位下三角矩阵 $L$、一个对角矩阵 $D$ 和 $L$ 的转置。此分解无需主元选择即可成立的条件是，对于所有的 $i$，都有 $d_i \\neq 0$，这等价于主子式非零。\n\n一旦建立了 $A = L D L^{\\mathsf{T}}$ 分解，求解 $A x = f$ 的过程就分为三个基于该分解的原则性步骤：\n1. 前向代换求解 $L y = f$。这使用递推关系\n$$\ny_1 = f_1, \\quad y_i = f_i - \\ell_i y_{i-1} \\quad \\text{对于 } i = 2,\\dots,n.\n$$\n2. 对角求解，从 $D w = y$ 中获得 $w$：\n$$\nw_i = \\frac{y_i}{d_i} \\quad \\text{对于 } i = 1,\\dots,n.\n$$\n3. 后向代换求解 $L^{\\mathsf{T}} x = w$。因为 $L^{\\mathsf{T}}$ 是单位上三角矩阵，其超对角线元素为 $\\ell_2,\\dots,\\ell_n$，递推关系为\n$$\nx_n = w_n, \\quad x_i = w_i - \\ell_{i+1} x_{i+1} \\quad \\text{对于 } i = n-1,n-2,\\dots,1.\n$$\n\n存储量的减少是因为对称性消除了携带独立的次对角线和超对角线数组的需要；只需要一个非对角线数组。该分解存储一个标量乘子序列 $\\ell_i$ 和一个标量主元序列 $d_i$，总共为矩阵因子存储 $n + (n-1)$ 个标量。在用于非对称三对角矩阵的通用托马斯算法中，必须携带三个对角线数组（$n$ 个主对角元，$(n-1)$ 个次对角元，$(n-1)$ 个超对角元），并且前向扫描通常还会计算和使用修改后的上对角线元素，导致更多的内存访问。\n\n运算次数分析：\n- 具有对称性和三对角性的前向扫描，在每一步 $i = 2,\\dots,n$ 中，计算 $\\ell_i$ 需要一次除法，更新 $d_i$ 需要一次乘法和一次减法，更新 $y_i$ 需要一次乘法和一次减法。这相当于每步一次除法和四次浮点运算，总计 $(n-1)$ 次除法和 $4(n-1)$ 次基本浮点运算。\n- 对角求解执行 $n$ 次除法来计算 $w_i$。\n- 后向代换在 $i = n-1,\\dots,1$ 的每一步中执行一次乘法和一次减法，总计 $2(n-1)$ 次浮点运算。\n\n相比之下，用于非对称三对角矩阵的通用托马斯算法执行的前向扫描，每步计算一个乘子（一次除法），更新主对角线（一次乘法和一次减法），以及更新右端项（一次乘法和一次减法），并且还必须引用一个独立的超对角线数组。虽然每步的算术运算次数在主导阶上可能相似，但利用对称性无需存储或访问一个单独的超对角线数组，并使得分解形式能够自然地重用于多个右端项而无需重新计算消元，从而在存在多个 $f$ 时降低了每次求解的有效运算次数。\n\n适合实现的算法总结：\n- 输入：长度为 $n$ 的数组 $a$（主对角线），长度为 $n-1$ 的数组 $b$（非对角线），以及长度为 $n$ 的数组 $f$。\n- 前向分解和代换：\n  - 设置 $d_1 = a_1$，$y_1 = f_1$。\n  - 对于 $i = 2$ 到 $n$：\n    - 计算 $\\ell_i = b_{i-1} / d_{i-1}$。\n    - 计算 $d_i = a_i - \\ell_i b_{i-1}$。\n    - 计算 $y_i = f_i - \\ell_i y_{i-1}$。\n- 对角求解：\n  - 对于 $i = 1$ 到 $n$，设置 $w_i = y_i / d_i$。\n- 后向代换：\n  - 设置 $x_n = w_n$。\n  - 对于 $i = n-1$ 向下到 $1$，设置 $x_i = w_i - \\ell_{i+1} x_{i+1}$。\n- 输出 $x$。\n\n测试套件包括四个案例：\n- 案例 1：$n = 6$，$a_i = 2$ 对所有 $i = 1,\\dots,6$，$b_i = -1$ 对所有 $i = 1,\\dots,5$，$f = [\\,1,\\,1,\\,1,\\,1,\\,1,\\,1\\,]$。\n- 案例 2：$n = 1$，$a_1 = 3$，$b$ 为空，$f = [\\,6\\,]$。\n- 案例 3：$n = 3$，$a = [\\,0.5,\\,-1.2,\\,0.5\\,]$，$b = [\\,1.0,\\,1.0\\,]$，$f = [\\,1.0,\\,2.0,\\,3.0\\,]$。\n- 案例 4：$n = 3$，$a = [\\,5,\\,7,\\,9\\,]$，$b = [\\,0,\\,0\\,]$，$f = [\\,10,\\,14,\\,27\\,]$。\n\n程序必须打印单行输出，其中包含四个解向量，格式为指定的嵌套列表格式，不含空格：$[[\\cdot],[\\cdot],[\\cdot],[\\cdot]]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef symmetric_tridiagonal_ldl_solve(a, b, f):\n    \"\"\"\n    Solve A x = f for symmetric tridiagonal A using LDL^T factorization.\n    A has main diagonal a (length n) and off-diagonal b (length n-1).\n    Returns x as a list of floats.\n    \"\"\"\n    n = len(a)\n    if len(f) != n:\n        raise ValueError(\"Length of f must equal length of a.\")\n    if n == 0:\n        return []\n    if len(b) not in (0, max(0, n - 1)):\n        raise ValueError(\"Length of b must be 0 or n-1.\")\n\n    # Allocate arrays\n    d = np.empty(n, dtype=float)         # diagonal of D\n    l = np.empty(n, dtype=float)         # subdiagonal of L (l[0] unused/zero)\n    y = np.empty(n, dtype=float)         # intermediate vector for Ly=f\n\n    # Forward factorization and forward substitution\n    d[0] = float(a[0])\n    l[0] = 0.0\n    y[0] = float(f[0])\n    for i in range(1, n):\n        bi_1 = float(b[i - 1]) if len(b) > 0 else 0.0\n        li = bi_1 / d[i - 1]\n        l[i] = li\n        d[i] = float(a[i]) - li * bi_1\n        y[i] = float(f[i]) - li * y[i - 1]\n\n    # Diagonal solve: D w = y\n    w = y / d\n\n    # Backward substitution: L^T x = w\n    x = np.empty(n, dtype=float)\n    x[n - 1] = w[n - 1]\n    for i in range(n - 2, -1, -1):\n        x[i] = w[i] - l[i + 1] * x[i + 1]\n\n    return x.tolist()\n\ndef format_nested_list_no_spaces(list_of_lists):\n    \"\"\"\n    Format a list of lists of numbers as a string without spaces, e.g.,\n    [[1.0,2.0],[3.0]] -> '[[1.0,2.0],[3.0]]' but with no spaces.\n    \"\"\"\n    def format_list(lst):\n        return \"[\" + \",\".join(f\"{num:.12g}\" if isinstance(num, float) else str(num) for num in lst) + \"]\"\n    return \"[\" + \",\".join(format_list(inner) for inner in list_of_lists) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (a, b, f)\n    test_cases = [\n        # Case 1: n=6, a_i=2, b_i=-1, f=ones\n        ([2, 2, 2, 2, 2, 2], [-1, -1, -1, -1, -1], [1, 1, 1, 1, 1, 1]),\n        # Case 2: n=1, a=[3], b=[], f=[6]\n        ([3], [], [6]),\n        # Case 3: n=3, symmetric indefinite\n        ([0.5, -1.2, 0.5], [1.0, 1.0], [1.0, 2.0, 3.0]),\n        # Case 4: n=3, diagonal matrix (b zeros)\n        ([5, 7, 9], [0, 0], [10, 14, 27]),\n    ]\n\n    results = []\n    for a, b, f in test_cases:\n        x = symmetric_tridiagonal_ldl_solve(a, b, f)\n        results.append(x)\n\n    # Final print statement in the exact required format: no spaces.\n    print(format_nested_list_no_spaces(results))\n\nsolve()\n```", "id": "3208596"}, {"introduction": "并非所有问题都能完美地呈现为标准的三对角形式。本练习挑战你处理一个“近似”三对角矩阵——一个在标准三对角结构之外，仅增加一个非零元素的矩阵 [@problem_id:3208725]。你将学习并应用Sherman-Morrison公式，将一个复杂的求解问题分解为两个更简单的三对角系统求解，这是一种在数值计算中广泛应用的强大思想。", "problem": "考虑一个大小为 $n \\times n$ 的线性系统 $A x = b$，其中 $A$ 是一个“近似”三对角矩阵，它是在一个严格三对角矩阵的右上角添加一个非零元素得到的。令 $T$ 表示 $A$ 的严格三对角部分，且额外的元素位于位置 $(1,n)$，其值为 $\\gamma \\in \\mathbb{R}$。矩阵 $T$ 具有非零的次对角线 $a$、主对角线 $d$ 和超对角线 $c$。矩阵 $A$ 的结构为 $A = T + \\gamma e_1 e_n^{\\top}$，其中 $e_1$ 和 $e_n$ 分别是 $\\mathbb{R}^n$ 中的第一个和最后一个标准基向量。\n\n你的任务是设计并实现一个求解器，该求解器能够：\n- 基于前向消元和后向代入（通常称为Thomas算法），对系统 $T y = b$ 使用一个稳定的三对角求解器。\n- 依据关于秩-1扰动矩阵求逆的基础线性代数恒等式，引入一个有原则的秩-1更新来处理位置 $(1,n)$ 的额外元素，而不预先假设任何快捷公式。\n- 为所有提供的测试用例生成数值上鲁棒的解。\n\n基础出发点包括：\n- 三对角矩阵和带状矩阵的定义。\n- 严格对角占优系统解的存在性和唯一性。\n- 通过消元法求解三对角系统的时间复杂度为 $\\mathcal{O}(n)$ 这一事实。\n- 一个被秩-1矩阵扰动的矩阵的逆，可以用原矩阵的逆和扰动向量的外积来表示这一性质。\n\n你必须从这些原则出发，推导出必要的步骤来实现算法。该实现必须解决以下包含五个测试用例的测试套件。每个测试用例指定了 $n$、三对角数组 $a$、$d$、$c$、标量 $\\gamma$ 以及右端向量 $b$。所有数值均为实数，所有向量的长度均为 $n$。\n\n测试套件：\n- 用例 1：$n = 5$, $a = [-1,-1,-1,-1]$, $d = [2,2,2,2,2]$, $c = [-1,-1,-1,-1]$, $\\gamma = 0.5$, $b = [1,1,1,1,1]$。\n- 用例 2：$n = 4$, $a = [-1,-1,-1]$, $d = [2,2,2,2]$, $c = [-1,-1,-1]$, $\\gamma = 0$, $b = [1,2,3,4]$。\n- 用例 3：$n = 6$, $a = [-1,-1,-1,-1,-1]$, $d = [2,2,2,2,2,2]$, $c = [-1,-1,-1,-1,-1]$, $\\gamma = -6.999$, $b = [0,1,0,1,0,1]$。\n- 用例 4：$n = 2$, $a = [-1]$, $d = [2,2]$, $c = [-1]$, $\\gamma = 0.3$, $b = [2,1]$。\n- 用例 5：$n = 5$, $a = [-1,-0.5,-1.5,-1.0]$, $d = [4,3.5,5,4.2,3.8]$, $c = [-1,-1.2,-0.7,-0.9]$, $\\gamma = 0.7$, $b = [1,0.5,-1,0.25,2]$。\n\n你的程序必须：\n- 使用前向消元和后向代入，以 $\\mathcal{O}(n)$ 的时间复杂度实现一个用于 $T y = b$ 的三对角求解器。\n- 仅使用基础线性代数恒等式实现秩-1更新，从而从三对角系统的解中获得 $A x = b$ 的解 $x$。\n- 对每个测试用例，计算解向量 $x$ 并将每个分量四舍五入到6位小数。\n\n最终输出规范：\n- 你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表中的每个条目本身都是一个代表一个测试用例解向量的方括号列表。例如，格式应为 $[[$x_{1,1},\\dots,x_{1,n_1}$],[$x_{2,1},\\dots,x_{2,n_2}$],\\dots]$，不含空格。\n- 不涉及物理单位，也不需要角度单位。\n- 每个测试用例的答案是一个浮点数列表，四舍五入到6位小数。", "solution": "用户提供的问题已经过验证，并被确定为数值线性代数领域中一个有效的、适定的问题。任务是求解线性方程组 $A x = b$，其中矩阵 $A$ 是一个三对角矩阵 $T$ 被一个秩-1矩阵扰动后得到的。\n\n该系统定义为：\n$$A x = b$$\n其中 $A$ 是一个 $n \\times n$ 的矩阵，由下式给出\n$$A = T + \\gamma e_1 e_n^{\\top}$$\n此处，$T$ 是一个严格三对角矩阵，其次对角线元素为 $a_i$（对于 $i=2, \\dots, n$），主对角线元素为 $d_i$（对于 $i=1, \\dots, n$），超对角线元素为 $c_i$（对于 $i=1, \\dots, n-1$）。项 $\\gamma e_1 e_n^{\\top}$ 表示一个秩-1更新，其中 $\\gamma \\in \\mathbb{R}$ 是一个标量，而 $e_1$ 和 $e_n$ 分别是 $\\mathbb{R}^n$ 中的第一个和最后一个标准基向量。这个更新在矩阵 $T$ 的位置 $(1, n)$ 处添加了一个非零元素 $\\gamma$。\n\n解 $x$ 可以形式化地写为 $x = A^{-1} b$。为了推导出一个计算算法，我们依赖于Sherman-Morrison公式，这是一个关于秩-1扰动矩阵求逆的基础恒等式。该公式指出，对于一个可逆矩阵 $B$ 和向量 $u, v$，矩阵 $B + uv^{\\top}$ 的逆为：\n$$(B + uv^{\\top})^{-1} = B^{-1} - \\frac{B^{-1} u v^{\\top} B^{-1}}{1 + v^{\\top} B^{-1} u}$$\n该公式成立的条件是 $1 + v^{\\top} B^{-1} u \\neq 0$。\n\n在我们的问题中，我们识别出 $B=T$，$u = \\gamma e_1$ 和 $v = e_n$。将这些代入公式，我们得到 $A$ 的逆：\n$$A^{-1} = \\left(T + (\\gamma e_1)e_n^{\\top}\\right)^{-1} = T^{-1} - \\frac{T^{-1}(\\gamma e_1)e_n^{\\top}T^{-1}}{1 + \\gamma e_n^{\\top}T^{-1}e_1}$$\n然后，通过将 $A^{-1}$ 与 $b$ 相乘来获得解向量 $x$：\n$$x = A^{-1} b = T^{-1} b - \\frac{T^{-1}(\\gamma e_1)e_n^{\\top}T^{-1}b}{1 + \\gamma e_n^{\\top}T^{-1}e_1}$$\n为了使这个表达式在计算上易于处理，我们引入两个辅助向量 $y$ 和 $z$，它们是涉及矩阵 $T$ 的三对角系统的解：\n1. 令 $y = T^{-1} b$。这等价于求解三对角系统 $T y = b$。\n2. 令 $z = T^{-1} e_1$。这等价于求解三对角系统 $T z = e_1$。\n\n使用这些定义，我们可以简化 $x$ 的表达式。\n- 项 $e_n^{\\top}T^{-1}b$ 是向量 $y$ 的第 $n$ 个分量，我们记为 $y_n$。\n- 项 $e_n^{\\top}T^{-1}e_1$ 是向量 $z$ 的第 $n$ 个分量，我们记为 $z_n$。\n- 项 $T^{-1}(\\gamma e_1)$ 变为 $\\gamma (T^{-1}e_1) = \\gamma z$。\n\n将这些代入 $x$ 的方程，我们得到最终表达式：\n$$x = y - \\frac{\\gamma y_n}{1 + \\gamma z_n} z$$\n这个简洁的公式将求解近似三对角系统的问题简化为求解两个严格三对角系统并执行一个简单的向量更新。如果 $\\gamma = 0$，该公式正确地简化为 $x=y$，因为此时 $A=T$。$A$ 的奇异性取决于分母 $1 + \\gamma z_n$ 是否为零。\n\n这两个三对角系统 $T y = b$ 和 $T z = e_1$ 可以使用Thomas算法在 $\\mathcal{O}(n)$ 时间内高效求解。我们采用一种基于LU分解的稳定算法变体。对于一个三对角系统 $T u = f$，算法分三个阶段进行：\n\n1.  **LU分解**：矩阵 $T$ 被分解为 $T = LU$，其中 $L$ 是一个下双对角矩阵，$U$ 是一个主对角线上元素为1的上双对角矩阵。$L$ 的非零元素（对角线 $\\alpha_i$）和 $U$ 的非零元素（超对角线 $\\delta_i$）通过以下递推关系计算（对数组 $a, d, c$ 使用基于0的索引）：\n    $$ \\alpha_0 = d_0 $$\n    $$ \\delta_0 = c_0 / \\alpha_0 $$\n    对于 $i = 1, \\dots, n-2$:\n    $$ \\alpha_i = d_i - a_{i-1} \\delta_{i-1} $$\n    $$ \\delta_i = c_i / \\alpha_i $$\n    $$ \\alpha_{n-1} = d_{n-1} - a_{n-2} \\delta_{n-2} $$\n\n2.  **前向代入**：系统 $T u = LU u = f$ 被分解为两个更简单的系统。首先，我们求解 $L w = f$ 得到中间向量 $w$。\n    $$ w_0 = f_0 / \\alpha_0 $$\n    对于 $i = 1, \\dots, n-1$:\n    $$ w_i = (f_i - a_{i-1} w_{i-1}) / \\alpha_i $$\n\n3.  **后向代入**：最后，我们求解 $U u = w$ 得到解向量 $u$。\n    $$ u_{n-1} = w_{n-1} $$\n    对于 $i = n-2, \\dots, 0$:\n    $$ u_i = w_i - \\delta_i u_{i+1} $$\n\n整体算法如下：\n1.  处理平凡情况：如果 $\\gamma=0$，使用Thomas算法求解 $Tx=b$ 并返回 $x$。\n2.  使用Thomas算法求解 $Ty = b$ 得到 $y$。\n3.  使用Thomas算法求解 $Tz = e_1$ 得到 $z$。\n4.  提取最后一个分量，$y_{n-1}$ 和 $z_{n-1}$（使用基于0的索引）。\n5.  计算标量因子 $\\beta = \\frac{\\gamma y_{n-1}}{1 + \\gamma z_{n-1}}$。\n6.  计算最终解向量 $x = y - \\beta z$。\n7.  返回结果向量 $x$。\n对于对角占优矩阵 $T$，此过程是数值稳定的，并为问题提供了一个高效的 $\\mathcal{O}(n)$ 解法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, solve them, and print the results.\n    \"\"\"\n\n    def tridiagonal_solver(a, d, c, f):\n        \"\"\"\n        Solves a tridiagonal linear system Tu=f using an LU decomposition-based\n        Thomas algorithm.\n        \n        Args:\n            a: Subdiagonal elements (length n-1).\n            d: Diagonal elements (length n).\n            c: Superdiagonal elements (length n-1).\n            f: Right-hand side vector (length n).\n            \n        Returns:\n            The solution vector u (numpy array of length n).\n        \"\"\"\n        n = len(d)\n        \n        # Ensure inputs are numpy arrays and create copies to avoid mutation.\n        ac, dc, cc, fc = map(lambda v: np.array(v, dtype=float), (a, d, c, f))\n\n        # LU Factorization (T = LU)\n        # alpha is the diagonal of L, delta is the superdiagonal of U.\n        alpha = np.zeros(n)\n        delta = np.zeros(n - 1)\n\n        alpha[0] = dc[0]\n        if n > 1:\n            delta[0] = cc[0] / alpha[0]\n\n        for i in range(1, n - 1):\n            alpha[i] = dc[i] - ac[i-1] * delta[i-1]\n            delta[i] = cc[i] / alpha[i]\n        \n        if n > 1:\n            alpha[n-1] = dc[n-1] - ac[n-2] * delta[n-2]\n\n        # Forward Substitution: Solve Lw = f for w\n        w = np.zeros(n)\n        w[0] = fc[0] / alpha[0]\n        for i in range(1, n):\n            w[i] = (fc[i] - ac[i-1] * w[i-1]) / alpha[i]\n            \n        # Backward Substitution: Solve Uu = w for u\n        u = np.zeros(n)\n        u[n-1] = w[n-1]\n        for i in range(n-2, -1, -1):\n            u[i] = w[i] - delta[i] * u[i+1]\n            \n        return u\n\n    def solve_almost_tridiagonal(n, a, d, c, gamma, b):\n        \"\"\"\n        Solves the almost-tridiagonal system using the Sherman-Morrison formula.\n        \"\"\"\n        # If gamma is zero, the system is purely tridiagonal.\n        if gamma == 0.0:\n            return tridiagonal_solver(a, d, c, b)\n        \n        # Step 1: Solve Ty = b\n        y = tridiagonal_solver(a, d, c, b)\n        \n        # Step 2: Solve Tz = e_1\n        e1 = np.zeros(n)\n        e1[0] = 1.0\n        z = tridiagonal_solver(a, d, c, e1)\n        \n        # Step 3: Apply the Sherman-Morrison update formula\n        # x = y - (gamma * y_n / (1 + gamma * z_n)) * z\n        y_n = y[-1]\n        z_n = z[-1]\n        \n        denominator = 1.0 + gamma * z_n\n        \n        if abs(denominator)  1e-15:\n            # This case should not occur with the given test data, but it's\n            # good practice to guard against singular matrices.\n            raise ValueError(\"Matrix A is singular or nearly singular.\")\n        \n        beta = (gamma * y_n) / denominator\n        x = y - beta * z\n        return x\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        (5, [-1,-1,-1,-1], [2,2,2,2,2], [-1,-1,-1,-1], 0.5, [1,1,1,1,1]),\n        # Case 2\n        (4, [-1,-1,-1], [2,2,2,2], [-1,-1,-1], 0.0, [1,2,3,4]),\n        # Case 3\n        (6, [-1,-1,-1,-1,-1], [2,2,2,2,2,2], [-1,-1,-1,-1,-1], -6.999, [0,1,0,1,0,1]),\n        # Case 4\n        (2, [-1], [2,2], [-1], 0.3, [2,1]),\n        # Case 5\n        (5, [-1,-0.5,-1.5,-1.0], [4,3.5,5,4.2,3.8], [-1,-1.2,-0.7,-0.9], 0.7, [1,0.5,-1,0.25,2]),\n    ]\n\n    all_solutions = []\n    for case_params in test_cases:\n        solution_vector = solve_almost_tridiagonal(*case_params)\n        \n        # Round each component to 6 decimal places.\n        rounded_solution = np.round(solution_vector, 6).tolist()\n        all_solutions.append(rounded_solution)\n\n    # Format the final output string as per the specification.\n    solution_strings = []\n    for sol in all_solutions:\n        # Create a comma-separated string for one solution vector without spaces.\n        sol_str = \",\".join(map(str, sol))\n        solution_strings.append(f\"[{sol_str}]\")\n    \n    # Join all solution strings into the final format.\n    final_output = f\"[{','.join(solution_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "3208725"}, {"introduction": "在掌握了标量三对角系统后，让我们将这一概念推广到更高维度。本练习要求你开发一个“块”Thomas算法，其中矩阵的元素本身就是小矩阵，这种结构在偏微分方程的数值解中非常常见 [@problem_id:3208590]。通过将标量运算替换为矩阵运算，你将把Thomas算法的核心逻辑提升到一个新的抽象层次，并解决一个更复杂的块三对角系统。", "problem": "考虑一个具有 $N$ 个块的块三对角线性方程组 (LSE)，其中每个块都是一个 $2 \\times 2$ 矩阵。全局系数矩阵 $\\mathbf{A}$ 具有以下分块结构：对角块 $\\mathbf{D}_i \\in \\mathbb{R}^{2 \\times 2}$ (其中 $i = 1, \\ldots, N$)，上非对角块 $\\mathbf{U}_i \\in \\mathbb{R}^{2 \\times 2}$ (其中 $i = 1, \\ldots, N-1$)，下非对角块 $\\mathbf{L}_i \\in \\mathbb{R}^{2 \\times 2}$ (其中 $i = 2, \\ldots, N$)，以及由 $2$ 维向量 $\\mathbf{f}_i \\in \\mathbb{R}^{2}$ (其中 $i = 1, \\ldots, N$) 组成的右端项。全局未知向量是由块未知数 $\\mathbf{x}_i \\in \\mathbb{R}^{2}$ ($i = 1, \\ldots, N$) 拼接而成，因此整个系统的维度为 $2N$。\n\n本问题的基础是线性系统 $\\mathbf{A}\\mathbf{x} = \\mathbf{b}$ 的定义以及应用于块级别的高斯消元法原理：消元过程逐行进行，使用遵循矩阵乘法结合律和分配律的块矩阵运算，并通过前向消元和随后的回代求得解，前提是所有中间的块主元都是非奇异的。\n\n您的任务是为此块三对角系统实现一个块 Thomas 算法。该算法必须：\n- 纯粹对块 $\\mathbf{D}_i$、$\\mathbf{U}_i$、$\\mathbf{L}_i$ 和向量 $\\mathbf{f}_i$ 进行操作，而不构造完整的 $2N \\times 2N$ 矩阵。\n- 使用标准的矩阵和向量运算在块级别上执行前向消元和回代。\n- 假设每次所需的块求逆或块线性求解都是良定义的（即，相关的 $2 \\times 2$ 矩阵是非奇异的）。\n\n为保证数值输出的一致性，请将解向量的每个分量四舍五入到 $8$ 位小数。\n\n实现程序以求解以下块三对角系统的测试套件。对于每个测试用例，数据由块数 $N$、列表 $\\{\\mathbf{D}_i\\}$、$\\{\\mathbf{U}_i\\}$、$\\{\\mathbf{L}_i\\}$ 和 $\\{\\mathbf{f}_i\\}$ 给出：\n\n测试用例 1 (典型情况):\n- $N = 3$.\n- 对角块:\n$$\n\\mathbf{D}_1 = \\begin{bmatrix} 4  1 \\\\ 1  3 \\end{bmatrix}, \\quad\n\\mathbf{D}_2 = \\begin{bmatrix} 3  0.5 \\\\ 0.5  4 \\end{bmatrix}, \\quad\n\\mathbf{D}_3 = \\begin{bmatrix} 2.5  0.4 \\\\ 0.4  2.0 \\end{bmatrix}.\n$$\n- 上对角块:\n$$\n\\mathbf{U}_1 = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}, \\quad\n\\mathbf{U}_2 = \\begin{bmatrix} -1  0.2 \\\\ 0.4  0.5 \\end{bmatrix}.\n$$\n- 下对角块:\n$$\n\\mathbf{L}_2 = \\begin{bmatrix} 0.5  -0.2 \\\\ 0.1  0.3 \\end{bmatrix}, \\quad\n\\mathbf{L}_3 = \\begin{bmatrix} -0.3  0.4 \\\\ 0.2  0.1 \\end{bmatrix}.\n$$\n- 右端项:\n$$\n\\mathbf{f}_1 = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}, \\quad\n\\mathbf{f}_2 = \\begin{bmatrix} 0 \\\\ -1 \\end{bmatrix}, \\quad\n\\mathbf{f}_3 = \\begin{bmatrix} 3 \\\\ 1 \\end{bmatrix}.\n$$\n\n测试用例 2 (只有一个块的边界情况):\n- $N = 1$.\n- 对角块:\n$$\n\\mathbf{D}_1 = \\begin{bmatrix} 2  -1 \\\\ -1  2 \\end{bmatrix}.\n$$\n- 没有上对角块或下对角块。\n- 右端项:\n$$\n\\mathbf{f}_1 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}.\n$$\n\n测试用例 3 (符号变化的较长链):\n- $N = 4$.\n- 对角块:\n$$\n\\mathbf{D}_1 = \\begin{bmatrix} 3  0.2 \\\\ 0.2  2.5 \\end{bmatrix}, \\quad\n\\mathbf{D}_2 = \\begin{bmatrix} 2.8  -0.1 \\\\ -0.1  3.2 \\end{bmatrix}, \\quad\n\\mathbf{D}_3 = \\begin{bmatrix} 3.0  0.4 \\\\ 0.4  2.2 \\end{bmatrix}, \\quad\n\\mathbf{D}_4 = \\begin{bmatrix} 2.6  -0.3 \\\\ -0.3  2.9 \\end{bmatrix}.\n$$\n- 上对角块:\n$$\n\\mathbf{U}_1 = \\begin{bmatrix} 0.1  -0.2 \\\\ 0.3  0.0 \\end{bmatrix}, \\quad\n\\mathbf{U}_2 = \\begin{bmatrix} 0.0  0.25 \\\\ -0.3  0.15 \\end{bmatrix}, \\quad\n\\mathbf{U}_3 = \\begin{bmatrix} -0.2  0.1 \\\\ 0.25  -0.05 \\end{bmatrix}.\n$$\n- 下对角块:\n$$\n\\mathbf{L}_2 = \\begin{bmatrix} -0.05  0.2 \\\\ 0.1  -0.1 \\end{bmatrix}, \\quad\n\\mathbf{L}_3 = \\begin{bmatrix} 0.2  -0.1 \\\\ 0.05  0.3 \\end{bmatrix}, \\quad\n\\mathbf{L}_4 = \\begin{bmatrix} -0.1  0.0 \\\\ 0.15  -0.2 \\end{bmatrix}.\n$$\n- 右端项:\n$$\n\\mathbf{f}_1 = \\begin{bmatrix} 0.5 \\\\ -1.0 \\end{bmatrix}, \\quad\n\\mathbf{f}_2 = \\begin{bmatrix} 1.5 \\\\ 2.0 \\end{bmatrix}, \\quad\n\\mathbf{f}_3 = \\begin{bmatrix} -0.5 \\\\ 0.25 \\end{bmatrix}, \\quad\n\\mathbf{f}_4 = \\begin{bmatrix} 0.0 \\\\ -1.0 \\end{bmatrix}.\n$$\n\n测试用例 4 (对角块接近奇异但仍可逆):\n- $N = 3$.\n- 对角块:\n$$\n\\mathbf{D}_1 = \\begin{bmatrix} 10^{-3}  0.0 \\\\ 0.0  1.0 \\end{bmatrix}, \\quad\n\\mathbf{D}_2 = \\begin{bmatrix} 1.0  0.9999 \\\\ 0.9999  1.0 \\end{bmatrix}, \\quad\n\\mathbf{D}_3 = \\begin{bmatrix} 10^{-2}  0.0 \\\\ 0.0  2.0 \\end{bmatrix}.\n$$\n- 上对角块:\n$$\n\\mathbf{U}_1 = \\begin{bmatrix} 0.2  -0.1 \\\\ 0.1  0.0 \\end{bmatrix}, \\quad\n\\mathbf{U}_2 = \\begin{bmatrix} -0.1  0.0 \\\\ 0.0  0.1 \\end{bmatrix}.\n$$\n- 下对角块:\n$$\n\\mathbf{L}_2 = \\begin{bmatrix} 0.0  0.1 \\\\ 0.05  0.0 \\end{bmatrix}, \\quad\n\\mathbf{L}_3 = \\begin{bmatrix} 0.0  -0.05 \\\\ 0.02  0.0 \\end{bmatrix}.\n$$\n- 右端项:\n$$\n\\mathbf{f}_1 = \\begin{bmatrix} 1.0 \\\\ 0.0 \\end{bmatrix}, \\quad\n\\mathbf{f}_2 = \\begin{bmatrix} -1.0 \\\\ 1.0 \\end{bmatrix}, \\quad\n\\mathbf{f}_3 = \\begin{bmatrix} 0.5 \\\\ -0.5 \\end{bmatrix}.\n$$\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个元素是对应一个测试用例的解，表示为一个从块 1 到块 N 的长度为 $2N$ 的列表，并四舍五入到 8 位小数。例如，整体输出格式必须如下所示\n$$\n\\texttt{[[x_{1,1},x_{1,2},\\ldots,x_{N,1},x_{N,2}],\\;[\\ldots],\\;[\\ldots],\\;[\\ldots]]}\n$$\n按顺序涵盖四个测试用例。", "solution": "所提出的问题是求解形式为 $\\mathbf{A}\\mathbf{x} = \\mathbf{f}$ 的块三对角线性方程组。该问题是良定义的，在数值线性代数中有坚实的科学基础，并且所有测试用例的必要数据都已提供。所有中间块主元非奇异的假设确保了通过所提出的块高斯消元法可以得到唯一解。因此，该问题被认为是有效的。\n\n该系统由 $N$ 个块方程定义。对于 $i=1, \\dots, N$，第 $i$ 个块方程为：\n$$ \\mathbf{L}_i \\mathbf{x}_{i-1} + \\mathbf{D}_i \\mathbf{x}_i + \\mathbf{U}_i \\mathbf{x}_{i+1} = \\mathbf{f}_i $$\n其中块为 $\\mathbf{L}_i, \\mathbf{D}_i, \\mathbf{U}_i \\in \\mathbb{R}^{2 \\times 2}$，向量为 $\\mathbf{x}_i, \\mathbf{f}_i \\in \\mathbb{R}^2$。按照惯例，$\\mathbf{L}_1$ 和 $\\mathbf{U}_N$ 是适当大小的零矩阵。求解该系统的算法是用于标量三对角系统的 Thomas 算法的直接推广，称为块 Thomas 算法或块三对角算法。它包括两个主要阶段：前向消元扫描和回代扫描。\n\n其核心原理是执行分块高斯消元，将系统转换为块上双对角形式，然后可以通过回代轻松求解。\n\n**1. 前向消元阶段**\n\n此阶段的目标是将每个块方程转换为以下形式：\n$$ \\mathbf{x}_i + \\mathbf{U}'_i \\mathbf{x}_{i+1} = \\mathbf{f}'_i $$\n这是通过推导修正后的块系数 $\\mathbf{U}'_i$ 和右端向量 $\\mathbf{f}'_i$ 的递推关系来实现的。\n\n对于第一个块行 ($i=1$)，方程为：\n$$ \\mathbf{D}_1 \\mathbf{x}_1 + \\mathbf{U}_1 \\mathbf{x}_2 = \\mathbf{f}_1 $$\n假设 $\\mathbf{D}_1$ 是非奇异的（根据问题陈述的保证），我们可以左乘其逆矩阵 $\\mathbf{D}_1^{-1}$：\n$$ \\mathbf{x}_1 + \\mathbf{D}_1^{-1} \\mathbf{U}_1 \\mathbf{x}_2 = \\mathbf{D}_1^{-1} \\mathbf{f}_1 $$\n这给出了我们递推关系的初始值：\n$$ \\mathbf{U}'_1 = \\mathbf{D}_1^{-1} \\mathbf{U}_1 $$\n$$ \\mathbf{f}'_1 = \\mathbf{D}_1^{-1} \\mathbf{f}_1 $$\n\n现在，考虑对于 $i = 2, \\ldots, N-1$ 的一般块行：\n$$ \\mathbf{L}_i \\mathbf{x}_{i-1} + \\mathbf{D}_i \\mathbf{x}_i + \\mathbf{U}_i \\mathbf{x}_{i+1} = \\mathbf{f}_i $$\n我们假设前一个块的关系 $\\mathbf{x}_{i-1} = \\mathbf{f}'_{i-1} - \\mathbf{U}'_{i-1} \\mathbf{x}_i$ 已经建立。将此代入块 $i$ 的方程中：\n$$ \\mathbf{L}_i (\\mathbf{f}'_{i-1} - \\mathbf{U}'_{i-1} \\mathbf{x}_i) + \\mathbf{D}_i \\mathbf{x}_i + \\mathbf{U}_i \\mathbf{x}_{i+1} = \\mathbf{f}_i $$\n对含 $\\mathbf{x}_i$ 的项进行分组：\n$$ (\\mathbf{D}_i - \\mathbf{L}_i \\mathbf{U}'_{i-1}) \\mathbf{x}_i + \\mathbf{U}_i \\mathbf{x}_{i+1} = \\mathbf{f}_i - \\mathbf{L}_i \\mathbf{f}'_{i-1} $$\n让我们定义中间块主元为 $\\mathbf{D}'_i = \\mathbf{D}_i - \\mathbf{L}_i \\mathbf{U}'_{i-1}$。问题陈述保证 $\\mathbf{D}'_i$ 是非奇异的。左乘 $(\\mathbf{D}'_i)^{-1}$：\n$$ \\mathbf{x}_i + (\\mathbf{D}'_i)^{-1} \\mathbf{U}_i \\mathbf{x}_{i+1} = (\\mathbf{D}'_i)^{-1} (\\mathbf{f}_i - \\mathbf{L}_i \\mathbf{f}'_{i-1}) $$\n这给出了对于 $i=2, \\ldots, N-1$ 的递推关系：\n$$ \\mathbf{U}'_i = (\\mathbf{D}_i - \\mathbf{L}_i \\mathbf{U}'_{i-1})^{-1} \\mathbf{U}_i $$\n$$ \\mathbf{f}'_i = (\\mathbf{D}_i - \\mathbf{L}_i \\mathbf{U}'_{i-1})^{-1} (\\mathbf{f}_i - \\mathbf{L}_i \\mathbf{f}'_{i-1}) $$\n在实现中，求解线性系统在数值上比显式计算矩阵的逆更可取。因此，我们通过求解 $(\\mathbf{D}_i - \\mathbf{L}_i \\mathbf{U}'_{i-1}) \\mathbf{X} = \\mathbf{U}_i$ 来计算 $\\mathbf{U}'_i$，对 $\\mathbf{f}'_i$ 也类似处理。\n\n对于最后一个块行 ($i=N$)，方程为：\n$$ \\mathbf{L}_N \\mathbf{x}_{N-1} + \\mathbf{D}_N \\mathbf{x}_N = \\mathbf{f}_N $$\n使用来自步骤 $N-1$ 的关系代入 $\\mathbf{x}_{N-1}$：\n$$ \\mathbf{L}_N (\\mathbf{f}'_{N-1} - \\mathbf{U}'_{N-1} \\mathbf{x}_N) + \\mathbf{D}_N \\mathbf{x}_N = \\mathbf{f}_N $$\n重新整理以求解 $\\mathbf{x}_N$：\n$$ (\\mathbf{D}_N - \\mathbf{L}_N \\mathbf{U}'_{N-1}) \\mathbf{x}_N = \\mathbf{f}_N - \\mathbf{L}_N \\mathbf{f}'_{N-1} $$\n令最后的枢轴为 $\\mathbf{D}'_N = \\mathbf{D}_N - \\mathbf{L}_N \\mathbf{U}'_{N-1}$。最后一个未知块向量 $\\mathbf{x}_N$ 通过求解以下方程得到：\n$$ \\mathbf{x}_N = (\\mathbf{D}'_N)^{-1} (\\mathbf{f}_N - \\mathbf{L}_N \\mathbf{f}'_{N-1}) $$\n\n**2. 回代阶段**\n\n计算出最后一个块向量 $\\mathbf{x}_N$ 后，我们可以通过从 $i=N-1$ 向下到 $1$ 进行回代来找到剩余的解向量。递推关系直接取自转换后的系统：\n$$ \\mathbf{x}_i = \\mathbf{f}'_i - \\mathbf{U}'_i \\mathbf{x}_{i+1} \\quad \\text{for } i = N-1, N-2, \\ldots, 1 $$\n这个过程计算出所有的 $\\mathbf{x}_i$，从而完成求解。\n\n**特殊情况: N=1**\n如果只有一个块 ($N=1$)，系统简化为 $\\mathbf{D}_1 \\mathbf{x}_1 = \\mathbf{f}_1$。解可以通过求解这个单一的 $2 \\times 2$ 系统直接获得：$\\mathbf{x}_1 = \\mathbf{D}_1^{-1} \\mathbf{f}_1$。\n\n**算法总结**\n\n1.  **如果 $N=1$**：求解 $\\mathbf{D}_1 \\mathbf{x}_1 = \\mathbf{f}_1$ 并返回 $\\mathbf{x}_1$。\n2.  **前向消元 ($i=1$ 到 $N$)**：\n    a. 初始化：通过求解 $\\mathbf{D}_1 \\mathbf{X} = \\mathbf{U}_1$ 计算 $\\mathbf{U}'_1$，通过求解 $\\mathbf{D}_1 \\mathbf{y} = \\mathbf{f}_1$ 计算 $\\mathbf{f}'_1$。\n    b. 对于 $i=2, \\ldots, N-1$ 进行迭代：\n       i.  计算主元 $\\mathbf{D}'_i = \\mathbf{D}_i - \\mathbf{L}_i \\mathbf{U}'_{i-1}$。\n       ii. 通过求解 $\\mathbf{D}'_i \\mathbf{X} = \\mathbf{U}_i$ 计算 $\\mathbf{U}'_i$。\n       iii.通过求解 $\\mathbf{D}'_i \\mathbf{y} = (\\mathbf{f}_i - \\mathbf{L}_i \\mathbf{f}'_{i-1})$ 计算 $\\mathbf{f}'_i$。\n    c. 最后一步：通过求解 $(\\mathbf{D}_N - \\mathbf{L}_N \\mathbf{U}'_{N-1}) \\mathbf{x}_N = (\\mathbf{f}_N - \\mathbf{L}_N \\mathbf{f}'_{N-1})$ 计算最后一个块向量 $\\mathbf{x}_N$。\n3.  **回代 ($i=N-1$ 到 $1$)**：\n    a. 向下迭代：$\\mathbf{x}_i = \\mathbf{f}'_i - \\mathbf{U}'_i \\mathbf{x}_{i+1}$。\n4.  **结果**：解是有序向量集合 $\\{\\mathbf{x}_1, \\ldots, \\mathbf{x}_N\\}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define, solve, and format the results for the test cases.\n    \"\"\"\n\n    def solve_block_tridiagonal(N, D, U, L, f):\n        \"\"\"\n        Solves a block tridiagonal system of equations using the block Thomas algorithm.\n\n        Args:\n            N (int): The number of blocks.\n            D (list of np.ndarray): List of N diagonal 2x2 blocks.\n            U (list of np.ndarray): List of N-1 upper off-diagonal 2x2 blocks.\n            L (list of np.ndarray): List of N-1 lower off-diagonal 2x2 blocks.\n            f (list of np.ndarray): List of N right-hand side 2x1 vectors.\n\n        Returns:\n            list: The flattened solution vector x, with components rounded to 8 decimal places.\n        \"\"\"\n        # Handle the special case of a single block.\n        if N == 1:\n            x0 = np.linalg.solve(D[0], f[0])\n            solution_vecs = [x0]\n            flat_solution = np.concatenate(solution_vecs).ravel()\n            return [round(val, 8) for val in flat_solution]\n\n        # Storage for modified coefficients (forward sweep).\n        U_prime = [None] * (N - 1)\n        f_prime = [None] * (N - 1) # We only need up to N-1 for back-substitution.\n\n        # ----- Forward Elimination Phase -----\n\n        # Step 1: i = 1 (Python index 0)\n        # Solve D_1 * X = U_1 for U'_1 and D_1 * y = f_1 for f'_1\n        U_prime[0] = np.linalg.solve(D[0], U[0])\n        f_prime[0] = np.linalg.solve(D[0], f[0])\n        \n        # Step 2: i = 2 to N-1 (Python index 1 to N-2)\n        for i in range(1, N - 1):\n            D_i, U_i = D[i], U[i]\n            L_i = L[i-1] # L_i in math corresponds to L[i-1] in problem data\n            \n            # Compute intermediate pivot D'_i = D_i - L_i * U'_{i-1}\n            D_prime_i = D_i - L_i @ U_prime[i-1]\n            \n            # Solve D'_i * X = U_i for U'_i\n            U_prime[i] = np.linalg.solve(D_prime_i, U_i)\n            \n            # Solve D'_i * y = (f_i - L_i * f'_{i-1}) for f'_i\n            f_rhs = f[i] - L_i @ f_prime[i-1]\n            f_prime[i] = np.linalg.solve(D_prime_i, f_rhs)\n\n        # Step 3: Final step of forward sweep for i=N\n        # Solve D'_N * x_N = (f_N - L_N * f'_{N-1})\n        D_N = D[N-1]\n        L_N = L[N-2]\n        \n        D_prime_N = D_N - L_N @ U_prime[N-2]\n        f_rhs_N = f[N-1] - L_N @ f_prime[N-2]\n        \n        solution_vecs = [None] * N\n        solution_vecs[N-1] = np.linalg.solve(D_prime_N, f_rhs_N)\n\n        # ----- Backward Substitution Phase -----\n        # For i = N-1 down to 1 (Python indices N-2 down to 0)\n        for i in range(N - 2, -1, -1):\n            # x_i = f'_i - U'_i * x_{i+1}\n            solution_vecs[i] = f_prime[i] - U_prime[i] @ solution_vecs[i+1]\n\n        # Flatten the list of solution vectors and round each component\n        flat_solution = np.concatenate(solution_vecs).ravel()\n        rounded_solution = [round(val, 8) for val in flat_solution]\n        \n        return rounded_solution\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        {\n            \"N\": 3,\n            \"D\": [[[4, 1], [1, 3]], [[3, 0.5], [0.5, 4]], [[2.5, 0.4], [0.4, 2.0]]],\n            \"U\": [[[1, 0], [0, 1]], [[-1, 0.2], [0.4, 0.5]]],\n            \"L\": [[[0.5, -0.2], [0.1, 0.3]], [[-0.3, 0.4], [0.2, 0.1]]],\n            \"f\": [[1, 2], [0, -1], [3, 1]]\n        },\n        # Test Case 2\n        {\n            \"N\": 1,\n            \"D\": [[[2, -1], [-1, 2]]],\n            \"U\": [],\n            \"L\": [],\n            \"f\": [[1, 0]]\n        },\n        # Test Case 3\n        {\n            \"N\": 4,\n            \"D\": [[[3, 0.2], [0.2, 2.5]], [[2.8, -0.1], [-0.1, 3.2]], [[3.0, 0.4], [0.4, 2.2]], [[2.6, -0.3], [-0.3, 2.9]]],\n            \"U\": [[[0.1, -0.2], [0.3, 0.0]], [[0.0, 0.25], [-0.3, 0.15]], [[-0.2, 0.1], [0.25, -0.05]]],\n            \"L\": [[[-0.05, 0.2], [0.1, -0.1]], [[0.2, -0.1], [0.05, 0.3]], [[-0.1, 0.0], [0.15, -0.2]]],\n            \"f\": [[0.5, -1.0], [1.5, 2.0], [-0.5, 0.25], [0.0, -1.0]]\n        },\n        # Test Case 4\n        {\n            \"N\": 3,\n            \"D\": [[[1e-3, 0.0], [0.0, 1.0]], [[1.0, 0.9999], [0.9999, 1.0]], [[1e-2, 0.0], [0.0, 2.0]]],\n            \"U\": [[[0.2, -0.1], [0.1, 0.0]], [[-0.1, 0.0], [0.0, 0.1]]],\n            \"L\": [[[0.0, 0.1], [0.05, 0.0]], [[0.0, -0.05], [0.02, 0.0]]],\n            \"f\": [[1.0, 0.0], [-1.0, 1.0], [0.5, -0.5]]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        D_mats = [np.array(m) for m in case[\"D\"]]\n        U_mats = [np.array(m) for m in case[\"U\"]]\n        L_mats = [np.array(m) for m in case[\"L\"]]\n        f_vecs = [np.array(v) for v in case[\"f\"]]\n        \n        result = solve_block_tridiagonal(N, D_mats, U_mats, L_mats, f_vecs)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_results = ','.join([str(r).replace(' ', '') for r in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n\n```", "id": "3208590"}]}