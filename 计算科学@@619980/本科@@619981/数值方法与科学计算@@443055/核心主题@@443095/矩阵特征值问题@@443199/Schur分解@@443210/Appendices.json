{"hands_on_practices": [{"introduction": "Schur分解揭示了矩阵与其特征值之间的深刻联系。这个练习探讨了一个矩阵的代数性质（如此处的幂零性）如何直接决定其Schur分解后得到的上三角矩阵$T$的结构。通过解决这个问题，你将学会如何仅从一个矩阵的抽象属性出发，推断出其分解形式的具体特征，而无需进行复杂的计算 [@problem_id:1388411]。", "problem": "在线性代数中，一个复系数方阵 $A$ 如果存在一个正整数 $k$ 使得 $A^k$ 为零矩阵，则称其为**幂零**矩阵。Schur 分解定理指出，任何复方阵 $A$ 都可以分解为 $A = UTU^*$，其中 $U$ 是一个酉矩阵（即 $U^*U = UU^* = I$），$T$ 是一个上三角矩阵。矩阵 $U^*$ 表示 $U$ 的共轭转置。\n\n考虑一个非零的幂零矩阵 $A \\in \\mathbb{C}^{n \\times n}$。根据幂零矩阵的性质和 Schur 分解，关于 $A$ 的 Schur 分解中的上三角矩阵 $T$，以下哪个陈述必须为真？\n\nA. $T$ 必须是零矩阵。\n\nB. $T$ 必须是对角矩阵。\n\nC. $T$ 的对角线元素必须全为零。\n\nD. $T$ 必须是单位矩阵。\n\nE. $T$ 必须是对称矩阵（即 $T = T^T$）。", "solution": "一个矩阵 $A \\in \\mathbb{C}^{n \\times n}$ 是幂零的，如果存在一个正整数 $k$ 使得 $A^{k}=0$。设 $\\lambda$ 是 $A$ 的任意一个特征值，其对应的特征向量为 $v \\neq 0$，因此有 $Av=\\lambda v$。那么\n$$\nA^{k}v=\\lambda^{k}v.\n$$\n因为 $A^{k}=0$，所以 $A^{k}v=0$，因此 $\\lambda^{k}v=0$。由于 $v \\neq 0$，我们必有 $\\lambda^{k}=0$，这意味着 $\\lambda=0$。因此，$A$ 的所有特征值都等于 $0$。\n\n根据 Schur 分解，存在一个酉矩阵 $U$ 和一个上三角矩阵 $T$ 使得\n$$\nA=UTU^{*}.\n$$\n相似变换保持特征值不变，所以 $A$ 和 $T$ 具有相同的特征值多重集。对于一个上三角矩阵 $T$，其特征值恰好是其对角线上的元素。因此，$T$ 的所有对角线元素必须为零。\n\n现在我们来评估这些陈述：\n- A. $T$ 必须是零矩阵：不一定，因为 $A$ 是非零的；$T$ 可以是一个非零的严格上三角矩阵。\n- B. $T$ 必须是对角矩阵：不一定；对角线元素为零的上三角矩阵不一定是对角矩阵。\n- C. $T$ 的对角线元素必须全为零：如上所示，这必须为真。\n- D. $T$ 必须是单位矩阵：错误，因为那将导致非零的特征值。\n- E. $T$ 必须是对称矩阵：如果 $T$ 是对称的且是上三角的，那么它将是对角矩阵；再加上对角线元素为零，这将迫使 $T=0$，而这并非必要条件。\n\n因此，只有陈述 C 必须为真。", "answer": "$$\\boxed{C}$$", "id": "1388411"}, {"introduction": "理论上，Schur分解定理保证了任何方阵都可以被三角化，但这个过程具体是如何操作的呢？本练习将指导你亲手为一个$2 \\times 2$矩阵计算其Schur分解，并要求将特征值按特定顺序排列。这个实践不仅能帮助你掌握构建酉矩阵$U$和上三角矩阵$T$的核心计算步骤，还能让你深刻理解Schur分解的构造性证明以及其结果对特征值排序的依赖性 [@problem_id:1388423]。", "problem": "考虑由分量 $A_{11}=5$、$A_{12}=-1$、$A_{21}=0$ 和 $A_{22}=3$ 定义的实矩阵 $A$。舒尔分解定理指出，对于任意方阵，都存在一个分解 $A = UTU^*$，其中 $U$ 是一个酉矩阵，$T$ 是一个上三角矩阵，而 $U^*$ 是 $U$ 的共轭转置。\n\n求 $A$ 的一个舒尔分解中的上三角矩阵 $T$，该矩阵满足其对角线元素从左上到右下严格递增的条件。", "solution": "我们给定实矩阵\n$$\nA=\\begin{pmatrix}5  -1 \\\\ 0  3\\end{pmatrix},\n$$\n根据舒尔分解定理，存在一个酉矩阵（在此为实正交矩阵）$U$ 和一个上三角矩阵 $T$，使得 $A=UTU^{*}$，等价地 $T=U^{*}AU$，其中 $T$ 的对角线元素等于 $A$ 的特征值。要求是对角线元素从左上到右下严格递增。\n\n首先，计算 $A$ 的特征值。由于 $A$ 是上三角矩阵，其特征值即为其对角线元素，也就是 $5$ 和 $3$。为了将它们按升序排列在 $T$ 的对角线上，我们需要\n$$\n\\operatorname{diag}(T)=(3,5).\n$$\n\n接下来，选择 $U$ 使得第一个舒尔向量是对应于特征值 $3$ 的特征向量。求解 $(A-3I)v=0$：\n$$\nA-3I=\\begin{pmatrix}2  -1 \\\\ 0  0\\end{pmatrix},\\quad 2x_{1}-x_{2}=0\\ \\Rightarrow\\ x_{2}=2x_{1}.\n$$\n一个特征向量是 $v_{3}=\\begin{pmatrix}1 \\\\ 2\\end{pmatrix}$。将其单位化得到\n$$\nu_{1}=\\frac{1}{\\sqrt{5}}\\begin{pmatrix}1 \\\\ 2\\end{pmatrix}.\n$$\n选择 $u_{2}$ 为一个与 $u_{1}$ 正交的单位向量，例如\n$$\nu_{2}=\\frac{1}{\\sqrt{5}}\\begin{pmatrix}-2 \\\\ 1\\end{pmatrix}.\n$$\n那么 $U=\\begin{pmatrix}u_{1}  u_{2}\\end{pmatrix}$ 是正交的，所以 $U^{*}=U^{T}$。\n\n定义 $T=U^{*}AU$。其元素为 $t_{ij}=u_{i}^{*}Au_{j}$。由于 $Au_{1}=3u_{1}$，我们有\n$$\nt_{11}=u_{1}^{*}Au_{1}=3,\\qquad t_{21}=u_{2}^{*}Au_{1}=u_{2}^{*}(3u_{1})=3\\,u_{2}^{*}u_{1}=0,\n$$\n所以 $T$ 是上三角矩阵。迹在相似变换下保持不变，所以\n$$\nt_{11}+t_{22}=\\operatorname{tr}(T)=\\operatorname{tr}(A)=8\\ \\Rightarrow\\ t_{22}=5.\n$$\n剩下需要计算的是 $t_{12}=u_{1}^{*}Au_{2}$。计算\n$$\nAu_{2}=\\frac{1}{\\sqrt{5}}\\begin{pmatrix}5  -1 \\\\ 0  3\\end{pmatrix}\\begin{pmatrix}-2 \\\\ 1\\end{pmatrix}\n=\\frac{1}{\\sqrt{5}}\\begin{pmatrix}-11 \\\\ 3\\end{pmatrix},\n$$\n因此\n$$\nt_{12}=u_{1}^{*}Au_{2}\n=\\left(\\frac{1}{\\sqrt{5}}\\begin{pmatrix}1  2\\end{pmatrix}\\right)\\left(\\frac{1}{\\sqrt{5}}\\begin{pmatrix}-11 \\\\ 3\\end{pmatrix}\\right)\n=\\frac{1}{5}(-11+6)=-1.\n$$\n\n因此，一个对角线元素严格递增的舒尔型是\n$$\nT=\\begin{pmatrix}3  -1 \\\\ 0  5\\end{pmatrix}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}3  -1 \\\\ 0  5\\end{pmatrix}}$$", "id": "1388423"}, {"introduction": "在处理实数矩阵时，我们经常希望得到一个完全由实数构成的分解形式。然而，实矩阵可能拥有复数特征值，这导致其标准的Schur分解包含复数。本练习旨在解决这一矛盾，指导你编写一个算法，将一个实矩阵的复Schur型$(Q, T)$转换为更具结构性的实Schur型$(Z, R)$，其中$R$是一个准上三角矩阵 [@problem_id:3271057]。这个编程实践将理论知识转化为强大的计算工具，是连接线性代数理论与科学计算应用的关键桥梁。", "problem": "一个实方阵 $A \\in \\mathbb{R}^{n \\times n}$ 存在复舒尔分解 (Complex Schur Decomposition)，该分解指出，存在一个酉矩阵 $Q \\in \\mathbb{C}^{n \\times n}$ 和一个上三角矩阵 $T \\in \\mathbb{C}^{n \\times n}$，使得 $A = Q T Q^{*}$，其中 $Q^{*}$ 表示 $Q$ 的共轭转置。一个实方阵也存在实舒尔分解 (Real Schur Decomposition)，该分解指出，存在一个正交矩阵 $Z \\in \\mathbb{R}^{n \\times n}$ 和一个准上三角矩阵 $R \\in \\mathbb{R}^{n \\times n}$（其对角线上为 $1 \\times 1$ 和 $2 \\times 2$ 的实数块，且第一副对角线下方严格为零的上三角矩阵），使得 $A = Z R Z^{\\top}$，其中 $Z^{\\top}$ 表示 $Z$ 的转置。对于一个实矩阵 $A$，复特征值以共轭对的形式出现；因此，通过为与实特征值相关联的不变子空间（一维子空间）和与复共轭对相关联的不变子空间（二维实不变子空间）选择合适的实基底，可以将复舒尔形式转换为实舒尔形式。\n\n从上述线性代数的基本事实出发，编写一个完整的程序，实现一个函数，该函数在给定实矩阵 $A$ 的复舒尔形式 $(Q, T)$ 的情况下，构造一个对应的实舒尔形式 $(Z, R)$。该函数必须：\n- 接受满足 $A = Q T Q^{*}$ 的 $Q \\in \\mathbb{C}^{n \\times n}$ 和 $T \\in \\mathbb{C}^{n \\times n}$，其中 $A$ 为某个实矩阵。\n- 假设 $T$ 的对角线元素已排序，使得复共轭特征值连续出现（每对形如 $\\lambda = \\alpha + i \\beta$ 后跟 $\\overline{\\lambda} = \\alpha - i \\beta$），而实特征值则单独出现。\n- 生成正交矩阵 $Z \\in \\mathbb{R}^{n \\times n}$ 和准上三角矩阵 $R \\in \\mathbb{R}^{n \\times n}$，使得 $A = Z R Z^{\\top}$。\n\n您的算法应基于以下原则：\n- 对于实特征值 $\\lambda \\in \\mathbb{R}$，一维不变子空间由相应的舒尔向量 $q \\in \\mathbb{C}^{n}$ 张成；因为 $A$ 是实矩阵，可以通过调整相位使该向量变为实向量，然后进行归一化，得到 $Z$ 的一个实数列。\n- 对于复共轭对 $\\lambda = \\alpha + i \\beta$ 和 $\\overline{\\lambda} = \\alpha - i \\beta$（其中 $\\beta \\neq 0$），相应的二维不变子空间可以通过一个正交实基底来表示，该基底由与 $\\lambda$ 关联的一个舒尔向量 $q \\in \\mathbb{C}^{n}$ 的实部和虚部构造，然后进行实正交化（例如，使用标准的 Gram–Schmidt 过程）。\n\n为了使任务具体且可测试，您的程序必须使用正规矩阵众所周知的酉对角化性质（即，对于这些选择，$A = Q \\Lambda Q^{*}$，其中 $\\Lambda$ 是对角矩阵），为以下测试矩阵 $A$ 构造复舒尔形式 $(Q, T)$，其中标准特征分解得到的特征向量被归一化以形成酉矩阵 $Q$，而 $T$ 则设置为按规定顺序排列的特征值对角矩阵：\n- 测试 1（二乘二复数对）：$A_{1} = \\begin{bmatrix} 1  2 \\\\ -2  1 \\end{bmatrix}$。\n- 测试 2（一个实特征值和一个复数对）：$A_{2} = \\operatorname{block\\_diag}\\!\\left(\\begin{bmatrix} 2 \\end{bmatrix}, \\begin{bmatrix} 1  3 \\\\ -3  1 \\end{bmatrix}\\right)$，得到一个三乘三矩阵。\n- 测试 3（两个复数对）：$A_{3} = \\operatorname{block\\_diag}\\!\\left(\\begin{bmatrix} 0  2 \\\\ -2  0 \\end{bmatrix}, \\begin{bmatrix} -1  1 \\\\ -1  -1 \\end{bmatrix}\\right)$，得到一个四乘四矩阵。\n- 测试 4（所有实特征值，对称）：$A_{4} = \\begin{bmatrix} 2  1  0 \\\\ 1  3  1 \\\\ 0  1  4 \\end{bmatrix}$。\n\n对于每个测试矩阵 $A$，执行以下步骤：\n- 如上所述计算 $(Q, T)$（酉特征向量矩阵 $Q$ 和对角矩阵 $T$，其特征值排序为复共轭对连续出现且实特征值在对之前）。\n- 按规定将 $(Q, T)$ 转换为 $(Z, R)$。\n- 计算以下四个量化诊断指标（每个都是一个实数）：\n    $1.$ 正交性误差：$\\left\\|Z^{\\top} Z - I\\right\\|_{F}$，其中 $I$ 是单位矩阵，$\\|\\cdot\\|_{F}$ 表示弗罗贝尼乌斯范数。\n    $2.$ 准上三角性误差：$R$ 中严格低于第一副对角线的元素的弗罗贝尼乌斯范数，即对于索引 $i - j > 1$ 的 $\\left\\| R_{i j} \\right\\|_{F}$。\n    $3.$ 重构误差：$\\left\\| A - Z R Z^{\\top} \\right\\|_{F}$。\n    $4.$ 特征值匹配误差：对于 $A$ 的特征值 $\\{\\mu_{k}\\}$ 和 $R$ 的特征值 $\\{\\nu_{k}\\}$，计算 $\\max_{k} \\min_{\\ell} \\left| \\mu_{k} - \\nu_{\\ell} \\right|$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个包含上述四个浮点值的列表。例如，格式必须为 $\\left[ [e_{11}, e_{12}, e_{13}, e_{14}], [e_{21}, e_{22}, e_{23}, e_{24}], [e_{31}, e_{32}, e_{33}, e_{34}], [e_{41}, e_{42}, e_{43}, e_{44}] \\right]$。不涉及物理单位或角度单位，也无需百分比；所有答案均为实数。", "solution": "用户希望实现一个程序，将一个实矩阵 $A$ 的复舒尔形式 $(Q, T)$ 转换为实舒尔形式 $(Z, R)$。该程序必须在四个特定的矩阵上进行测试，并为每个矩阵计算和报告一组四个诊断误差。\n\n### 步骤1：理论基础与算法设计\n\n一个实矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的特征值要么是实数，要么以复共轭对的形式出现。舒尔分解 $A = U S U^*$（其中 $U$ 是酉矩阵，$S$ 是上三角矩阵）的 $S$ 的对角线上将是 $A$ 的特征值。如果 $A$ 是实矩阵，我们可以找到一个*实*正交矩阵 $Z$，使得 $A = Z R Z^\\top$，其中 $R$ 是一个实准上三角矩阵。$R$ 的对角线由对应实特征值的 $1 \\times 1$ 块和对应复共轭对的 $2 \\times 2$ 块组成。\n\n任务是将给定的复舒尔形式 $(Q, T)$ 转换为实舒尔形式 $(Z, R)$。我们已知 $A = Q T Q^*$ 是实矩阵，$Q$ 是酉矩阵，$T$ 是上三角矩阵（对于提供的正规测试矩阵来说是对角矩阵），并且其对角线元素的排序方式是实特征值分组在一起，复共轭对相邻。\n\n转换算法通过迭代 $T$ 的对角线并应用局部酉变换来将 $Q$ 的列转换为实向量，这些实向量将构成新的实正交矩阵 $Z$ 的列。为保持等式成立，相同的变换也应用于 $T$，从而得到准上三角矩阵 $R$。\n\n设 $Z_0 = Q$ 和 $R_0 = T$。我们迭代地构造一系列酉矩阵 $U_k$ 来生成 $Z_{k+1} = Z_k U_k$ 和 $R_{k+1} = U_k^* R_k U_k$，使得 $Z_k$ 逐渐变为实矩阵。最终的 $Z$ 将是 $Z = Q U_0 U_1 \\dots$，而 $R$ 是 $\\dots U_1^* U_0^* T U_0 U_1 \\dots$。\n\n该过程迭代遍历 $T$ 的对角元素（即特征值）：\n1.  **实特征值**：如果 $T_{kk} = \\lambda_k \\in \\mathbb{R}$，则相应的舒尔向量 $q_k$（$Q$ 的第 $k$ 列）张成一个一维实不变子空间。这意味着可以通过乘以一个合适的相位因子 $e^{i\\phi}$ 使 $q_k$ 变为实数。我们找到具有最大模值的 $q_{jk}$ 分量，并选择 $e^{i\\phi}$ 使该分量变为实数。由于 $A$ 和 $\\lambda_k$ 都是实数，$A q_k = \\lambda_k q_k$ 意味着如果 $q_k$ 的一个分量变为实数，整个向量都会变为实数。这对应于一个变换 $U_k$，它是一个单位矩阵，但在位置 $(k, k)$ 处有一个相位因子。更新后的 $Q$ 变为 $Q U_k$，而 $T$ 变为 $U_k^* T U_k$。\n\n2.  **复共轭对**：如果 $T_{kk} = \\lambda = \\alpha + i\\beta$（其中 $\\beta \\neq 0$），那么根据指定的排序，$T_{k+1, k+1} = \\overline{\\lambda} = \\alpha - i\\beta$。相应的舒尔向量 $q_k$ 和 $q_{k+1}$ 张成一个二维不变子空间。可以为该子空间构建一个实正交基。例如，如果我们假设 $q_{k+1} \\approx \\overline{q_k}$（对于实矩阵的特征向量就是这种情况），我们可以形成两个新的实正交向量：$z_k = \\frac{1}{\\sqrt{2}}(q_k + q_{k+1})$ 和 $z_{k+1} = \\frac{1}{i\\sqrt{2}}(q_k - q_{k+1})$。这种基变换通过一个 $2 \\times 2$ 的酉变换 $V = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1  -i \\\\ 1  i \\end{pmatrix}$ 应用于 $Q$ 的第 $k$ 和 $k+1$ 列来完成。对 $T$ 的 $2 \\times 2$ 对角块进行的相应相似变换是：\n    $$ V^* \\begin{pmatrix} \\lambda  0 \\\\ 0  \\overline{\\lambda} \\end{pmatrix} V = \\begin{pmatrix} \\alpha  \\beta \\\\ -\\beta  \\alpha \\end{pmatrix} $$\n    这就在 $R$ 中产生了所需的 $2 \\times 2$ 实数块。完整的变换 $U_k$ 是一个单位矩阵，在索引 $(k, k+1)$ 处有这个 $V$ 块。\n\n此过程迭代应用，直到 $Q$ 的所有列都已处理完毕，最终得到一个实正交矩阵 $Z$ 和一个实准上三角矩阵 $R$。\n\n### 步骤2：实现策略\n\n程序将按以下结构组织：\n1.  一个主函数 `solve()` 将为四个测试用例协调整个过程。\n2.  定义测试矩阵 $A_1, A_2, A_3, A_4$。\n3.  对于每个矩阵 $A$：\n    a.  使用 `numpy.linalg.eig` 计算特征分解 $(V, \\Lambda)$。\n    b.  问题指出，对于这些正规矩阵，复舒尔形式 $(Q, T)$ 可以取为酉特征向量矩阵和对角特征值矩阵。特征值和特征向量被排序，以将实数值排在前面，后面是复共轭对。自定义的排序键确保对于一对 $\\alpha \\pm i\\beta$，带有正虚部的特征值 $\\alpha+i\\beta$ 出现在前面。\n    c.  排序后的特征向量构成酉矩阵 $Q$ 的列，排序后的特征值构成上三角矩阵 $T$ 的对角线。\n    d.  调用函数 `complex_to_real_schur(Q, T)`，根据上述算法执行转换。该函数迭代 $T$ 的对角线，并对 $Q$ 和 $T$ 应用适当的 $1 \\times 1$ 相位变换或 $2 \\times 2$ 块变换，得到 $Z$ 和 $R$。\n    e.  计算指定的四个诊断指标：\n        i.   **正交性误差**：计算 $\\|Z^\\top Z - I\\|_F$ 以验证 $Z$ 是正交的。\n        ii.  **准上三角性误差**：计算 $R$ 中严格低于第一副对角线的元素（$R_{ij}$ 对于 $i-j > 1$）的弗罗贝尼乌斯范数。\n        iii. **重构误差**：计算 $\\|A - Z R Z^\\top\\|_F$ 以验证分解。\n        iv.  **特征值匹配误差**：计算 $A$ 和 $R$ 的特征值，并计算误差 $\\max_{k} \\min_{\\ell} |\\mu_k(A) - \\nu_\\ell(R)|$。\n4.  收集所有测试用例的结果，并以指定的列表的列表格式打印。\n\n此实现计划是将理论原理直接转化为具体的数值算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef complex_to_real_schur(Q, T):\n    \"\"\"\n    Converts a Complex Schur form (Q, T) of a real matrix to a Real Schur Form (Z, R).\n    \n    Args:\n        Q (np.ndarray): Unitary matrix from Complex Schur form.\n        T (np.ndarray): Upper-triangular matrix from Complex Schur form.\n        \n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple (Z, R) representing the Real Schur form,\n                                       where Z is real orthogonal and R is real quasi-upper-triangular.\n    \"\"\"\n    Z = Q.copy().astype(np.complex128)\n    R = T.copy().astype(np.complex128)\n    n = Z.shape[0]\n    k = 0\n    tol = 1e-9\n\n    while k  n:\n        # Check if eigenvalue is complex\n        if abs(np.imag(R[k, k])) > tol:\n            # Complex conjugate pair case. The problem guarantees they are adjacent.\n            if k + 1 >= n:\n                # This should not be reached with proper input ordering.\n                k += 1\n                continue\n            \n            # Unitary transformation for a 2x2 block\n            V = (1 / np.sqrt(2)) * np.array([[1, -1j], [1, 1j]], dtype=np.complex128)\n            \n            # Apply transformation to Z: Z_new = Z_old @ U_k\n            Z[:, k:k+2] = Z[:, k:k+2] @ V\n            \n            # Apply similarity transformation to R: R_new = U_k^* @ R_old @ U_k\n            R[:, k:k+2] = R[:, k:k+2] @ V\n            R[k:k+2, :] = V.conj().T @ R[k:k+2, :]\n            \n            k += 2\n        else:\n            # Real eigenvalue case\n            # Re-phase column k of Z to be real.\n            Z_col = Z[:, k]\n            \n            # Only apply correction if there's a significant imaginary part\n            if np.linalg.norm(np.imag(Z_col)) > tol:\n                # Find element with largest magnitude to define the phase\n                j = np.argmax(np.abs(Z_col))\n                phase_val = Z_col[j]\n                \n                # Phase correction factor to make Z_col[j] real\n                c = phase_val.conj() / np.abs(phase_val) if np.abs(phase_val) > tol else 1.0\n                \n                # Apply transformation to Z: Z_new = Z_old @ U_k where U_k is diag(1,..,c,..)\n                Z[:, k] *= c\n                \n                # Apply similarity transformation to R: R_new = U_k^* @ R_old @ U_k\n                R[:, k] *= c\n                R[k, :] *= c.conj()\n            \n            k += 1\n\n    # Discard small imaginary parts resulting from floating-point noise\n    Z_real = np.real(Z)\n    R_real = np.real(R)\n\n    return Z_real, R_real\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([[1., 2.], [-2., 1.]]),\n        np.array([[2., 0., 0.], [0., 1., 3.], [0., -3., 1.]]),\n        np.array([[0., 2., 0., 0.], [-2., 0., 0., 0.], [0., 0., -1., 1.], [0., 0., -1., -1.]]),\n        np.array([[2., 1., 0.], [1., 3., 1.], [0., 1., 4.]])\n    ]\n\n    all_results = []\n    tol = 1e-9\n\n    for A in test_cases:\n        n = A.shape[0]\n        \n        # Step 1: Compute eigendecomposition of A. For normal matrices, this is a Schur form.\n        eigvals, eigvecs = np.linalg.eig(A)\n\n        # Step 2: Sort eigenvalues and eigenvectors according to the problem specification.\n        # Real eigenvalues precede complex conjugate pairs.\n        # Pairs are ordered by real part, then |imaginary part|.\n        # Within a pair, the eigenvalue with the positive imaginary part comes first.\n        e_list = sorted(list(zip(eigvals, eigvecs.T)), \n                        key=lambda e: (abs(e[0].imag) > tol, e[0].real, abs(e[0].imag), -e[0].imag))\n\n        # Unpack the sorted list to get the initial Complex Schur form (Q, T)\n        sorted_eigvals, sorted_eigvecs_T = zip(*e_list)\n        Q = np.array(sorted_eigvecs_T, dtype=np.complex128).T\n        T = np.diag(np.array(sorted_eigvals, dtype=np.complex128))\n\n        # Step 3: Convert the Complex Schur form (Q, T) to a Real Schur form (Z, R)\n        Z, R = complex_to_real_schur(Q, T)\n\n        # Step 4: Compute the four quantitative diagnostics.\n        # 1. Orthogonality error of Z\n        ortho_err = np.linalg.norm(Z.T @ Z - np.eye(n), 'fro')\n\n        # 2. Quasi-upper-triangularity error of R (norm of elements below the first subdiagonal)\n        tri_err = np.linalg.norm(np.tril(R, k=-2))\n        \n        # 3. Reconstruction error\n        recon_err = np.linalg.norm(A - Z @ R @ Z.T, 'fro')\n\n        # 4. Eigenvalue matching error between A and R\n        mu = np.linalg.eigvals(A)\n        nu = np.linalg.eigvals(R)\n        \n        # Compute max_k min_l |mu_k - nu_l| using broadcasting\n        dists = np.abs(mu[:, np.newaxis] - nu)\n        min_dists_for_mu = np.min(dists, axis=1)\n        eig_match_err = np.max(min_dists_for_mu)\n        \n        all_results.append([ortho_err, tri_err, recon_err, eig_match_err])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(res) for res in all_results)}]\")\n\nsolve()\n```", "id": "3271057"}]}