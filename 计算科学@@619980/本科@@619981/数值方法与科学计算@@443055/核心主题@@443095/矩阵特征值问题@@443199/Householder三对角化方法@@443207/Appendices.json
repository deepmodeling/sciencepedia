{"hands_on_practices": [{"introduction": "这个练习将标准的三对角化过程反转过来，为理解Householder变换的几何本质提供一个独特的视角。你将不再是将矩阵$A$约简为$T$，而是从其三对角形式$T$和约简过程中使用的一系列Householder向量来重构原始的对称矩阵$A$ [@problem_id:3239697]。这个实践旨在加深你对Householder三对角化是一系列正交相似变换的理解，并突显了这类变换保持矩阵行列式不变的重要性质。", "problem": "一个实对称矩阵 $A \\in \\mathbb{R}^{4 \\times 4}$ 通过由单位向量 $v_1$ 和 $v_2$ 构造的两次 Householder 反射序列，被约简为一个实对称三对角矩阵 $T$。与单位向量 $v \\in \\mathbb{R}^n$ 相关联的 Householder 反射矩阵 $H(v)$ 定义为 $H(v) = I - 2 v v^{\\top}$，其中 $I$ 表示单位矩阵。正交相似变换保持对称性。给定\n$$\nT = \\begin{pmatrix}\n4  1  0  0 \\\\\n1  3  2  0 \\\\\n0  2  5  -1 \\\\\n0  0  -1  2\n\\end{pmatrix}, \\quad\nv_1 = \\begin{pmatrix} 0 \\\\ \\frac{1}{\\sqrt{2}} \\\\ \\frac{1}{\\sqrt{2}} \\\\ 0 \\end{pmatrix}, \\quad\nv_2 = \\begin{pmatrix} 0 \\\\ 0 \\\\ \\frac{1}{\\sqrt{2}} \\\\ \\frac{1}{\\sqrt{2}} \\end{pmatrix}.\n$$\n重构与此约简过程一致的原始对称矩阵 $A$，然后计算 $A$ 的行列式。将最终答案表示为一个精确的实数（不要四舍五入）。", "solution": "该问题要求从一个实对称矩阵 $A \\in \\mathbb{R}^{4 \\times 4}$ 的三对角形式 $T$ 重构出原始矩阵 $A$，其中 $T$ 是通过两次 Householder 反射序列得到的。随后，必须计算 $A$ 的行列式。\n\n使用 Householder 变换将对称矩阵 $A$ 三对角化的过程是一系列的相似变换。对于一个 $4 \\times 4$ 矩阵，需要两步。该过程可以写成：\n$A^{(1)} = A$\n$A^{(2)} = H_1 A^{(1)} H_1$\n$T = A^{(3)} = H_2 A^{(2)} H_2 = H_2 (H_1 A H_1) H_2 = H_2 H_1 A H_1 H_2$\n此处，$H_1$ 和 $H_2$ 分别是由给定的单位向量 $v_1$ 和 $v_2$ 构造的 Householder 矩阵。对于一个单位向量 $v$，Householder 矩阵 $H(v) = I - 2vv^\\top$ 既是对称的（$H^\\top = H$），也是正交的（$H^{-1} = H^\\top = H$）。\n\n为了重构原始矩阵 $A$，我们可以逆转变换序列：\n$A = H_1 H_2 T H_2 H_1$。\n\n首先，我们构造 Householder 矩阵 $H_1$ 和 $H_2$。\n第一个单位向量是 $v_1 = \\begin{pmatrix} 0 \\\\ \\frac{1}{\\sqrt{2}} \\\\ \\frac{1}{\\sqrt{2}} \\\\ 0 \\end{pmatrix}$。\n外积 $v_1 v_1^\\top$ 是：\n$$v_1 v_1^\\top = \\begin{pmatrix} 0 \\\\ \\frac{1}{\\sqrt{2}} \\\\ \\frac{1}{\\sqrt{2}} \\\\ 0 \\end{pmatrix} \\begin{pmatrix} 0 & \\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{2}} & 0 \\end{pmatrix} = \\begin{pmatrix} 0 & 0 & 0 & 0 \\\\ 0 & \\frac{1}{2} & \\frac{1}{2} & 0 \\\\ 0 & \\frac{1}{2} & \\frac{1}{2} & 0 \\\\ 0 & 0 & 0 & 0 \\end{pmatrix}$$\nHouseholder 矩阵 $H_1$ 是：\n$$H_1 = I - 2v_1v_1^\\top = \\begin{pmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix} - 2\\begin{pmatrix} 0 & 0 & 0 & 0 \\\\ 0 & \\frac{1}{2} & \\frac{1}{2} & 0 \\\\ 0 & \\frac{1}{2} & \\frac{1}{2} & 0 \\\\ 0 & 0 & 0 & 0 \\end{pmatrix} = \\begin{pmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 0 & -1 & 0 \\\\ 0 & -1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix}$$\n第二个单位向量是 $v_2 = \\begin{pmatrix} 0 \\\\ 0 \\\\ \\frac{1}{\\sqrt{2}} \\\\ \\frac{1}{\\sqrt{2}} \\end{pmatrix}$。\n外积 $v_2 v_2^\\top$ 是：\n$$v_2 v_2^\\top = \\begin{pmatrix} 0 \\\\ 0 \\\\ \\frac{1}{\\sqrt{2}} \\\\ \\frac{1}{\\sqrt{2}} \\end{pmatrix} \\begin{pmatrix} 0 & 0 & \\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{2}} \\end{pmatrix} = \\begin{pmatrix} 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 \\\\ 0 & 0 & \\frac{1}{2} & \\frac{1}{2} \\\\ 0 & 0 & \\frac{1}{2} & \\frac{1}{2} \\end{pmatrix}$$\nHouseholder 矩阵 $H_2$ 是：\n$$H_2 = I - 2v_2v_2^\\top = \\begin{pmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix} - 2\\begin{pmatrix} 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 \\\\ 0 & 0 & \\frac{1}{2} & \\frac{1}{2} \\\\ 0 & 0 & \\frac{1}{2} & \\frac{1}{2} \\end{pmatrix} = \\begin{pmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & -1 \\\\ 0 & 0 & -1 & 0 \\end{pmatrix}$$\n现在我们用给定的矩阵 $T$ 来计算 $A = H_1 H_2 T H_2 H_1$：\n$$T = \\begin{pmatrix} 4 & 1 & 0 & 0 \\\\ 1 & 3 & 2 & 0 \\\\ 0 & 2 & 5 & -1 \\\\ 0 & 0 & -1 & 2 \\end{pmatrix}$$\n让我们先计算中间矩阵 $T' = H_2 T H_2$：\n$$H_2 T = \\begin{pmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & -1 \\\\ 0 & 0 & -1 & 0 \\end{pmatrix} \\begin{pmatrix} 4 & 1 & 0 & 0 \\\\ 1 & 3 & 2 & 0 \\\\ 0 & 2 & 5 & -1 \\\\ 0 & 0 & -1 & 2 \\end{pmatrix} = \\begin{pmatrix} 4 & 1 & 0 & 0 \\\\ 1 & 3 & 2 & 0 \\\\ 0 & 0 & 1 & -2 \\\\ 0 & -2 & -5 & 1 \\end{pmatrix}$$\n$$T' = (H_2 T) H_2 = \\begin{pmatrix} 4 & 1 & 0 & 0 \\\\ 1 & 3 & 2 & 0 \\\\ 0 & 0 & 1 & -2 \\\\ 0 & -2 & -5 & 1 \\end{pmatrix} \\begin{pmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & -1 \\\\ 0 & 0 & -1 & 0 \\end{pmatrix} = \\begin{pmatrix} 4 & 1 & 0 & 0 \\\\ 1 & 3 & 0 & -2 \\\\ 0 & 0 & 2 & -1 \\\\ 0 & -2 & -1 & 5 \\end{pmatrix}$$\n现在，我们计算 $A = H_1 T' H_1$：\n$$H_1 T' = \\begin{pmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 0 & -1 & 0 \\\\ 0 & -1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 4 & 1 & 0 & 0 \\\\ 1 & 3 & 0 & -2 \\\\ 0 & 0 & 2 & -1 \\\\ 0 & -2 & -1 & 5 \\end{pmatrix} = \\begin{pmatrix} 4 & 1 & 0 & 0 \\\\ 0 & 0 & -2 & 1 \\\\ -1 & -3 & 0 & 2 \\\\ 0 & -2 & -1 & 5 \\end{pmatrix}$$\n$$A = (H_1 T') H_1 = \\begin{pmatrix} 4 & 1 & 0 & 0 \\\\ 0 & 0 & -2 & 1 \\\\ -1 & -3 & 0 & 2 \\\\ 0 & -2 & -1 & 5 \\end{pmatrix} \\begin{pmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 0 & -1 & 0 \\\\ 0 & -1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 4 & 0 & -1 & 0 \\\\ 0 & 2 & 0 & 1 \\\\ -1 & 0 & 3 & 2 \\\\ 0 & 1 & 2 & 5 \\end{pmatrix}$$\n这就是重构的原始对称矩阵 $A$。\n\n最后一步是计算 $A$ 的行列式。由于 $A$ 和 $T$ 通过相似变换相关联（因为 $H_1$ 和 $H_2$ 是正交的），它们的行列式相等。\n$\\det(A) = \\det(H_1 H_2 T H_2 H_1)$。令 $Q = H_1 H_2$。$Q$ 是正交的，所以 $Q^{-1} = Q^\\top = (H_1 H_2)^\\top = H_2^\\top H_1^\\top = H_2 H_1$。因此 $A = Q T Q^\\top$（由于 H 是对称的，QTQ' = QTQ）。\n$\\det(A) = \\det(Q T Q^\\top) = \\det(Q) \\det(T) \\det(Q^\\top) = \\det(T)$，因为 $\\det(Q) = \\pm 1$ 且 $\\det(Q^\\top) = \\det(Q)$。\n这使我们可以从更简单的三对角矩阵 $T$ 计算行列式。\n\n计算 $\\det(T)$：\n$$\\det(T) = \\det \\begin{pmatrix} 4 & 1 & 0 & 0 \\\\ 1 & 3 & 2 & 0 \\\\ 0 & 2 & 5 & -1 \\\\ 0 & 0 & -1 & 2 \\end{pmatrix}$$\n我们沿第一行进行代数余子式展开：\n$$\\det(T) = 4 \\cdot \\det \\begin{pmatrix} 3 & 2 & 0 \\\\ 2 & 5 & -1 \\\\ 0 & -1 & 2 \\end{pmatrix} - 1 \\cdot \\det \\begin{pmatrix} 1 & 2 & 0 \\\\ 0 & 5 & -1 \\\\ 0 & -1 & 2 \\end{pmatrix}$$\n第一个 $3 \\times 3$ 行列式是：\n$$\\det \\begin{pmatrix} 3 & 2 & 0 \\\\ 2 & 5 & -1 \\\\ 0 & -1 & 2 \\end{pmatrix} = 3(5 \\cdot 2 - (-1)(-1)) - 2(2 \\cdot 2 - 0) = 3(10 - 1) - 2(4) = 3(9) - 8 = 27 - 8 = 19$$\n第二个 $3 \\times 3$ 行列式是：\n$$\\det \\begin{pmatrix} 1 & 2 & 0 \\\\ 0 & 5 & -1 \\\\ 0 & -1 & 2 \\end{pmatrix} = 1(5 \\cdot 2 - (-1)(-1)) = 10 - 1 = 9$$\n因此，$T$ 的行列式是：\n$$\\det(T) = 4(19) - 1(9) = 76 - 9 = 67$$\n因此，$\\det(A) = 67$。\n\n作为验证，我们可以直接计算重构矩阵 $A$ 的行列式：\n$$\\det(A) = \\det \\begin{pmatrix} 4 & 0 & -1 & 0 \\\\ 0 & 2 & 0 & 1 \\\\ -1 & 0 & 3 & 2 \\\\ 0 & 1 & 2 & 5 \\end{pmatrix}$$\n沿第一行进行代数余子式展开：\n$$\\det(A) = 4 \\cdot \\det \\begin{pmatrix} 2 & 0 & 1 \\\\ 0 & 3 & 2 \\\\ 1 & 2 & 5 \\end{pmatrix} + (-1) \\cdot \\det \\begin{pmatrix} 0 & 2 & 1 \\\\ -1 & 0 & 2 \\\\ 0 & 1 & 5 \\end{pmatrix}$$\n第一个 $3 \\times 3$ 行列式是：\n$$\\det \\begin{pmatrix} 2 & 0 & 1 \\\\ 0 & 3 & 2 \\\\ 1 & 2 & 5 \\end{pmatrix} = 2(3 \\cdot 5 - 2 \\cdot 2) - 0 + 1(0 \\cdot 2 - 3 \\cdot 1) = 2(11) - 3 = 19$$\n第二个 $3 \\times 3$ 行列式，沿第一列展开：\n$$\\det \\begin{pmatrix} 0 & 2 & 1 \\\\ -1 & 0 & 2 \\\\ 0 & 1 & 5 \\end{pmatrix} = -(-1) \\det \\begin{pmatrix} 2 & 1 \\\\ 1 & 5 \\end{pmatrix} = 10 - 1 = 9$$\n所以，$A$ 的行列式是：\n$$\\det(A) = 4(19) - 1(9) = 76 - 9 = 67$$\n结果匹配，证实了计算的正确性。", "answer": "$$\\boxed{67}$$", "id": "3239697"}, {"introduction": "将数值算法从理论转化为正确且稳健的代码是科学计算中的一项关键技能。本实践聚焦于Householder三对角化算法中一个常见的实现陷阱，即错误地只应用了一个不完整的相似变换 [@problem_id:3239695]。通过同时实现一个有缺陷的版本和一个正确的版本，你将亲身体验调试过程，并领会到正确应用完整分块矩阵更新以确保算法成功的至关重要性。", "problem": "考虑一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$。使用 Householder 反射变换的一系列正交相似变换可以将 $A$ 约简为对称三对角矩阵 $T$，且不改变其特征值。作用于向量 $x \\in \\mathbb{R}^{m}$ 的 Householder 反射变换定义为：选择 $u = x - \\alpha e_1$，其中 $e_1$ 是第一个标准基向量，且 $\\alpha = -\\operatorname{sign}(x_1)\\lVert x \\rVert_2$。向量 $v = \\dfrac{u}{\\lVert u \\rVert_2}$ 定义了反射变换 $H = I_m - 2 v v^\\top$，它满足 $H x = \\alpha e_1$、$H^\\top = H$，并且 $H$ 是正交的。对称三对角化过程在每一步 $k$ 应用一个由分块对角正交矩阵 $Q_k = \\operatorname{diag}(I_{k+1}, H_k)$ 实现的相似变换，其中 $H_k$ 作用于 $A$ 的第 $k$ 列对角线下方的末尾子向量。精确的相似变换为 $A \\leftarrow Q_k A Q_k^\\top$。当为 $k = 0, 1, \\dots, n-3$ 正确实现时，该过程会生成一个矩阵 $T$，在精确算术中，所有满足 $\\lvert i - j \\rvert > 1$ 的元素 $T_{i,j}$ 都精确为零；在浮点运算中，这些元素在数值上也可忽略不计。\n\n一个常见的实现错误是仅通过 $A_{22} \\leftarrow H_k A_{22} H_k$ 更新末尾主子矩阵 $A_{22}$，而忽略了非对角耦合块 $A_{12}$ 和 $A_{21}$。要理解为什么这是错误的，可将第 $k$ 步的分块形式写为\n$$\nA = \\begin{bmatrix}\nA_{11} & A_{12} \\\\\nA_{21} & A_{22}\n\\end{bmatrix}, \\quad Q_k = \\begin{bmatrix}\nI_{k+1} & 0 \\\\\n0 & H_k\n\\end{bmatrix}.\n$$\n那么，数学上正确的相似变换给出\n$$\nQ_k A Q_k^\\top = \n\\begin{bmatrix}\nA_{11} & A_{12} H_k \\\\\nH_k A_{21} & H_k A_{22} H_k\n\\end{bmatrix}.\n$$\n如果只更新 $A_{22}$ 而保持 $A_{12}$ 和 $A_{21}$ 不变，则没有执行全局相似变换，三对角带外的“填充”（fill-in）仍然存在。结果矩阵可以保持对称，但不会是严格的三对角矩阵。\n\n任务：实现错误的和修正的两种 Householder 三对角化过程。错误的过程必须在每一步只执行末尾主子矩阵的更新，而修正的过程必须对所有相关分块应用完整的分块相似变换。实现一个函数，用于计算最终矩阵中位于三对角带之外且幅值超过阈值 $\\varepsilon$ 的元素数量。使用阈值 $\\varepsilon = 10^{-10}$。\n\n您的程序必须处理以下对称矩阵测试套件：\n- 测试用例 1：$A_1 \\in \\mathbb{R}^{5 \\times 5}$，\n$$\nA_1 =\n\\begin{bmatrix}\n6 & -2 & 3 & 0 & 1 \\\\\n-2 & 5 & 2 & -1 & 4 \\\\\n3 & 2 & 4 & 2 & 0 \\\\\n0 & -1 & 2 & 3 & -2 \\\\\n1 & 4 & 0 & -2 & 7\n\\end{bmatrix}.\n$$\n- 测试用例 2：$A_2 \\in \\mathbb{R}^{2 \\times 2}$，\n$$\nA_2 =\n\\begin{bmatrix}\n2 & -1 \\\\\n-1 & 3\n\\end{bmatrix}.\n$$\n- 测试用例 3：$A_3 \\in \\mathbb{R}^{1 \\times 1}$，\n$$\nA_3 =\n\\begin{bmatrix}\n5\n\\end{bmatrix}.\n$$\n- 测试用例 4：$A_4 \\in \\mathbb{R}^{6 \\times 6}$，已为三对角矩阵，\n$$\nA_4 =\n\\begin{bmatrix}\n4 & 1 & 0 & 0 & 0 & 0 \\\\\n1 & 5 & -2 & 0 & 0 & 0 \\\\\n0 & -2 & 6 & 3 & 0 & 0 \\\\\n0 & 0 & 3 & 7 & -4 & 0 \\\\\n0 & 0 & 0 & -4 & 8 & 5 \\\\\n0 & 0 & 0 & 0 & 5 & 9\n\\end{bmatrix}.\n$$\n- 测试用例 5：$A_5 \\in \\mathbb{R}^{5 \\times 5}$，带有大小为 $10^{-12}$ 的微小非三对角扰动的三对角矩阵，\n$$\nA_5 =\n\\begin{bmatrix}\n10 & 2 & 0 & 10^{-12} & 0 \\\\\n2 & 9 & -1 & 0 & 10^{-12} \\\\\n0 & -1 & 8 & 3 & 0 \\\\\n10^{-12} & 0 & 3 & 7 & 2 \\\\\n0 & 10^{-12} & 0 & 2 & 6\n\\end{bmatrix}.\n$$\n\n定义一个函数，对于给定的矩阵 $T$ 和阈值 $\\varepsilon$，该函数计算满足 $\\lvert i - j \\rvert > 1$ 且 $\\lvert T_{i,j} \\rvert > \\varepsilon$ 的元素 $T_{i,j}$ 的数量。对每个测试用例，输出两个整数：错误实现得到的计数值和修正实现得到的计数值。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表中的每个元素是对应一个测试用例的含两个整数的列表。例如，输出应类似于 $[[b_1,f_1],[b_2,f_2],\\dots]$，其中 $b_k$ 是测试用例 $k$ 的错误计数值，$f_k$ 是修正计数值。此问题不涉及物理单位或角度单位。", "solution": "用户的要求是实现并比较针对实对称矩阵 $A$ 的 Householder 三对角化算法的两个版本：一个数学上正确的版本和一个常见的错误版本。\n\n### 1. 问题验证\n\n问题陈述已经过仔细验证。\n\n- **提取给定信息**：所有定义、常数、矩阵和过程描述均已逐字提取。\n- **科学依据**：该问题在数值线性代数理论中有充分的依据。关于 Householder 反射变换和三对角化过程的描述是标准的，并且在数学上是合理的。“错误”算法代表了一个合理的、具有说明性的实现错误。\n- **良置性**：任务定义清晰。输入是特定的矩阵，输出是基于精确阈值的定量比较（非三对角元素的计数）。问题是自洽的，没有矛盾或歧义。\n- **结论**：问题有效，可以按所述方式解决。\n\n### 2. Householder 变换\n\n该算法的核心是 Householder 变换。对于给定的向量 $x \\in \\mathbb{R}^m$，Householder 反射变换 $H$ 是一个正交矩阵，它将 $x$ 转换为第一个标准基向量 $e_1$ 的倍数。如问题中所定义的构造过程如下：\n1.  计算标量 $\\alpha = -\\operatorname{sign}(x_1) \\lVert x \\rVert_2$。为了稳健地处理 $x_1=0$ 的情况并保持数值稳定性（避免相消误差），我们定义 $\\operatorname{sign}(0)=+1$。\n2.  构造向量 $u = x - \\alpha e_1$。\n3.  将 $u$ 归一化以获得方向向量 $v = \\frac{u}{\\lVert u \\rVert_2}$。\n4.  反射变换由矩阵 $H = I_m - 2 v v^\\top$ 给出。\n\n该矩阵 $H$ 是对称的（$H=H^\\top$）和正交的（$H^\\top H = I_m$）。当作用于 $x$ 时，它产生 $H x = \\alpha e_1$。\n\n### 3. 三对角化算法\n\n该过程通过应用一系列相似变换，将对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 约简为对称三对角矩阵 $T$。算法按步骤进行，$k=0, 1, \\dots, n-3$。在每一步 $k$，目标是在第 $k$ 列的第一个次对角线元素下方引入零，并对称地在第 $k$ 行中也引入零。\n\n设 $A^{(k)}$ 为第 $k$ 步开始时的矩阵（其中 $A^{(0)}=A$）。\n1.  提取向量 $x = A^{(k)}[k+1:n, k]$。该向量的维度为 $m=n-(k+1)$。\n2.  为该向量 $x$ 构造 $m \\times m$ 的 Householder 反射变换 $H_k$。\n3.  构造完整的变换矩阵 $Q_k = \\begin{bmatrix} I_{k+1} & 0 \\\\ 0 & H_k \\end{bmatrix}$。\n4.  应用相似变换：$A^{(k+1)} = Q_k A^{(k)} Q_k^{\\top}$。\n\n由于 $H_k$ 是对称的，$Q_k$ 也是对称的，因此 $A^{(k+1)} = Q_k A^{(k)} Q_k$。\n\n### 4. 正确与错误实现对比\n\n两种实现之间的关键区别在于如何应用相似变换 $A \\leftarrow Q_k A Q_k$。使用问题陈述中的分块矩阵形式：\n$$\nA = \\begin{bmatrix}\nA_{11} & A_{12} \\\\\nA_{21} & A_{22}\n\\end{bmatrix}, \\quad Q_k = \\begin{bmatrix}\nI_{k+1} & 0 \\\\\n0 & H_k\n\\end{bmatrix}\n$$\n其中分块位置在第 $k$ 行/列之后。\n\n**正确的过程：** 必须应用完整的相似变换。\n$$\nA \\leftarrow Q_k A Q_k^\\top =\n\\begin{bmatrix}\nA_{11} & A_{12} H_k \\\\\nH_k A_{21} & H_k A_{22} H_k\n\\end{bmatrix}\n$$\n这涉及三次更新：\n-   $A_{21} \\leftarrow H_k A_{21}$：这是将第 $k$ 列中的目标元素置零的关键步骤。\n-   $A_{12} \\leftarrow A_{12} H_k$：对称地将第 $k$ 行中的元素置零。\n-   $A_{22} \\leftarrow H_k A_{22} H_k$：对末尾主子矩阵进行相似变换，以维持全局相似性并保持特征值不变。\n\n**错误的过程：** 问题描述了一个错误，即忽略了对非对角块 $A_{12}$ 和 $A_{21}$ 的更新。\n$$\nA \\leftarrow \\begin{bmatrix}\nA_{11} & A_{12} \\\\\nA_{21} & H_k A_{22} H_k\n\\end{bmatrix}\n$$\n只更新了末尾子矩阵 $A_{22}$。这未能将第 $k$ 列中的元素置零，并且由于未执行完整的相似变换，所得矩阵不保证是三对角的。然而，它确实保持对称。\n\n### 5. 实现策略\n\n对于每个测试用例矩阵 $A$：\n1.  创建两个副本 `A_correct` 和 `A_faulty`。\n2.  将正确和错误的三对角化过程应用于它们各自的矩阵。算法从 $k=0$ 迭代到 $n-3$。对于大小 $n \\le 2$ 的矩阵，不执行任何变换。\n3.  在第 $k$ 步的循环内部，使用向量 $x = A[k+1:n, k]$ 来构造 Householder 反射变换 $H_k$。\n4.  对于 `A_correct`，变换 $H_k$ 从左侧应用于行块 `A_correct[k+1:n, k:]`，然后从右侧应用于列块 `A_correct[:, k+1:n]`。这正确地实现了 $A \\leftarrow Q_k A Q_k$。\n5.  对于 `A_faulty`，仅通过 `Hk @ submatrix @ Hk` 更新末尾子矩阵 `A_faulty[k+1:n, k+1:n]`。\n6.  最后，一个计数函数检查两个结果矩阵。它统计满足 $|i-j| > 1$ 且 $|T_{i,j}| > \\varepsilon = 10^{-10}$ 的元素 $T_{i,j}$ 的数量。\n\n正确的算法预计对所有测试用例都会产生 0 的计数，因为三对角带外的所有元素在数值上都应为零。对于非已三对角的矩阵，错误的算法预计会在这些位置留下非零元素。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef count_off_tridiagonal(T, eps):\n    \"\"\"\n    Counts the number of entries T_ij with |i-j| > 1 and |T_ij| > eps.\n    \"\"\"\n    n = T.shape[0]\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if abs(i - j) > 1 and abs(T[i, j]) > eps:\n                count += 1\n    return count\n\ndef correct_tridiagonalization(A_in):\n    \"\"\"\n    Performs Householder tridiagonalization using the correct similarity transformation.\n    \"\"\"\n    A = A_in.copy()\n    n = A.shape[0]\n\n    for k in range(n - 2):\n        # 1. Define the vector x\n        x = A[k+1:n, k].copy()\n        m = x.shape[0]\n        if m == 0:\n            continue\n        \n        norm_x = np.linalg.norm(x)\n        # If the sub-column is already zero, reflector is identity.\n        if norm_x  1e-15:\n            continue\n        \n        # 2. Construct the Householder reflector H_k for x\n        # Use copysign for sign(0)=1 behavior, ensuring stability\n        sign_x0 = np.copysign(1.0, x[0]) if x[0] != 0 else 1.0\n        alpha = -sign_x0 * norm_x\n        \n        u = x.copy()\n        u[0] -= alpha\n        \n        norm_u = np.linalg.norm(u)\n        if norm_u  1e-15:\n            continue\n        v = u / norm_u\n        \n        Hk = np.eye(m) - 2 * np.outer(v, v)\n        \n        # 3. Apply the full similarity transformation A - Q_k * A * Q_k^T\n        # This is done by applying H_k to the relevant sub-blocks of A.\n        \n        # Apply H_k from the left: A[k+1:n, :] - Hk @ A[k+1:n, :]\n        sub_block_rows = A[k+1:n, k:]\n        A[k+1:n, k:] = Hk @ sub_block_rows\n        \n        # Apply H_k from the right: A[:, k+1:n] - A[:, k+1:n] @ Hk\n        sub_block_cols = A[:, k+1:n]\n        A[:, k+1:n] = sub_block_cols @ Hk\n        \n    return A\n\ndef faulty_tridiagonalization(A_in):\n    \"\"\"\n    Performs a faulty Householder tridiagonalization, updating only A_22.\n    \"\"\"\n    A = A_in.copy()\n    n = A.shape[0]\n\n    for k in range(n - 2):\n        # 1. Define the vector x\n        x = A[k+1:n, k].copy()\n        m = x.shape[0]\n        if m == 0:\n            continue\n        \n        norm_x = np.linalg.norm(x)\n        if norm_x  1e-15:\n            continue\n        \n        # 2. Construct the Householder reflector H_k for x\n        sign_x0 = np.copysign(1.0, x[0]) if x[0] != 0 else 1.0\n        alpha = -sign_x0 * norm_x\n        \n        u = x.copy()\n        u[0] -= alpha\n        \n        norm_u = np.linalg.norm(u)\n        if norm_u  1e-15:\n            continue\n        v = u / norm_u\n        \n        Hk = np.eye(m) - 2 * np.outer(v, v)\n        \n        # 3. Apply faulty update: only the trailing submatrix A_22 is updated.\n        sub_A22 = A[k+1:n, k+1:n]\n        A[k+1:n, k+1:n] = Hk @ sub_A22 @ Hk\n    \n    return A\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        np.array([\n            [6, -2, 3, 0, 1],\n            [-2, 5, 2, -1, 4],\n            [3, 2, 4, 2, 0],\n            [0, -1, 2, 3, -2],\n            [1, 4, 0, -2, 7]\n        ], dtype=float),\n        np.array([\n            [2, -1],\n            [-1, 3]\n        ], dtype=float),\n        np.array([\n            [5]\n        ], dtype=float),\n        np.array([\n            [4, 1, 0, 0, 0, 0],\n            [1, 5, -2, 0, 0, 0],\n            [0, -2, 6, 3, 0, 0],\n            [0, 0, 3, 7, -4, 0],\n            [0, 0, 0, -4, 8, 5],\n            [0, 0, 0, 0, 5, 9]\n        ], dtype=float),\n        np.array([\n            [10, 2, 0, 1e-12, 0],\n            [2, 9, -1, 0, 1e-12],\n            [0, -1, 8, 3, 0],\n            [1e-12, 0, 3, 7, 2],\n            [0, 1e-12, 0, 2, 6]\n        ], dtype=float)\n    ]\n\n    results = []\n    eps = 1e-10\n\n    for A in test_cases:\n        # Run faulty implementation\n        A_faulty_result = faulty_tridiagonalization(A)\n        count_faulty = count_off_tridiagonal(A_faulty_result, eps)\n\n        # Run corrected implementation\n        A_correct_result = correct_tridiagonalization(A)\n        count_correct = count_off_tridiagonal(A_correct_result, eps)\n        \n        results.append(f\"[{count_faulty},{count_correct}]\")\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3239695"}, {"introduction": "在处理大规模科学计算问题时，效率至关重要。由于高昂的内存和计算成本，从Householder反射镜生成完整的$n \\times n$正交矩阵$Q$通常是不切实际的。这个高级练习将指导你学习实现Householder变换的专业标准方法：对反射镜使用紧凑存储方案，并隐式地应用变换，而无需显式构造完整的矩阵 [@problem_id:3239709]。掌握这项技术对于开发高性能的数值软件至关重要。", "problem": "给定一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$。目标是使用 Householder 反射实现对称三对角化，同时紧凑地存储 Householder 向量 $v_k$，而不是构造完整的正交矩阵 $Q$。紧凑存储必须遵循以下约定：对于每一步 $k$，Householder 向量 $v_k \\in \\mathbb{R}^{n-k-1}$ 被缩放，使其第一个元素为 $1$，并且只存储其尾部元素 $v_k[1:], \\ldots, v_k[n-k-2]$。此外，还要存储反射矩阵 $H_k = I - \\tau_k v_k v_k^\\top$ 对应的标量因子 $\\tau_k \\in \\mathbb{R}$。\n\n您的程序必须：\n\n- 实现一个函数，该函数接收一个对称矩阵 $A$，执行 Householder 三对角化以生成一个对称三对角矩阵 $T$，同时紧凑地存储 Householder 向量 $v_k$ 及其标量 $\\tau_k$，而不显式构造完整的正交矩阵 $Q$。\n- 实现函数，仅使用存储的 $v_k$ 和 $\\tau_k$ 将 $Q$ 和 $Q^\\top$ 应用于任意向量 $y \\in \\mathbb{R}^n$。\n- 实现一个函数，通过将存储的反射矩阵应用于标准基向量 $e_i$ 来重构 $Q$（仅用于验证目的），此过程同样不显式构造完整的反射矩阵。\n\n使用的基本原理：\n- 使用 Householder 反射的定义：对于一个向量 $x \\in \\mathbb{R}^m$，定义 $v = x - \\alpha e_1$，其中 $\\alpha = -\\mathrm{sign}(x_1)\\,\\|x\\|_2$，以及一个标量 $\\tau = \\dfrac{2}{v^\\top v}$，使得 $H = I - \\tau v v^\\top$ 满足 $H x = \\alpha e_1$。\n- 使用双边相似变换 $A \\leftarrow H A H$，其中 $H$ 仅作用于尾随子矩阵以及更新的行和列，而不显式构造 $H$。\n\n程序必须是自包含的，不使用任何输入，并且确定性地运行。使用以下参数值的测试套件：\n\n- 测试用例 1（边界条件，平凡大小）：$A_1 = \\begin{bmatrix} 5 \\end{bmatrix}$。\n- 测试用例 2（小规模用例，显式值）：$A_2 = \\begin{bmatrix} 4  1 \\\\ 1  3 \\end{bmatrix}$。\n- 测试用例 3（一般情况，随机但确定）：设 $B \\in \\mathbb{R}^{5 \\times 5}$ 的元素 $b_{ij}$ 从伪随机种子为 $42$ 的标准正态分布中独立抽取，并定义 $A_3 = \\dfrac{1}{2}(B + B^\\top)$ 以使其对称。\n- 测试用例 4（已为三对角矩阵的输入）：$A_4 \\in \\mathbb{R}^{6 \\times 6}$，其对角线元素为 $[2,3,4,5,6,7]$，次对角线（和超对角线）元素全为 $1$，所有其他元素均为 $0$。\n- 测试用例 5（通过紧凑应用进行正交性检查）：重用从 $A_3$ 三对角化中获得的反射矩阵，并设 $y \\in \\mathbb{R}^5$ 是一个向量，其元素从伪随机种子为 $42$ 的标准正态分布中独立抽取。\n\n对于每个测试用例，计算以下可量化的答案：\n\n- 对于测试用例 1：返回一个布尔值 $r_1$，表示 $T_1$ 的所有非三对角线元素的绝对值是否小于或等于 $10^{-12}$。\n- 对于测试用例 2：返回一个浮点数 $r_2 = \\max_{i,j} \\left| \\left(Q_2^\\top A_2 Q_2 - T_2 \\right)_{ij} \\right|$，该值通过将存储的反射矩阵应用于标准基向量来重构 $Q_2$ 进行计算。此过程不得显式构造任何 Householder 矩阵。\n- 对于测试用例 3：返回一个浮点数 $r_3 = \\max_{|i-j|1} \\left| (T_3)_{ij} \\right|$。\n- 对于测试用例 4：返回一个布尔值 $r_4$，表示是否满足 $\\|T_4 - A_4\\|_\\infty \\le 10^{-10}$，其中 $\\|\\cdot\\|_\\infty$ 是所有元素上的逐元素最大绝对差。\n- 对于测试用例 5：返回一个浮点数 $r_5 = \\|Q_3^\\top (Q_3 y) - y\\|_2$，其中 $Q_3$ 由从 $A_3$ 中存储的反射矩阵隐式定义，$\\|\\cdot\\|_2$ 是欧几里得范数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[r_1, r_2, r_3, r_4, r_5]$。\n\n此问题不涉及任何物理单位、角度单位或百分比。所有值都是无量纲的实数和布尔值。", "solution": "用户要求实现对称 Householder 三对角化算法。问题的关键在于为 Householder 反射矩阵指定的紧凑存储方案，以及使用这种紧凑表示法实现相关的矩阵向量运算。\n\n### 问题验证\n\n首先，我将验证问题陈述。\n\n**第 1 步：提取已知条件**\n\n- **矩阵**：一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$。\n- **算法**：通过 Householder 反射进行对称三对角化。该算法迭代应用相似变换 $A \\leftarrow H A H$。\n- **Householder 反射矩阵定义**：对于向量 $x \\in \\mathbb{R}^m$，反射矩阵为 $H = I - \\tau v v^\\top$，其中 Householder 向量为 $v = x - \\alpha e_1$，$\\alpha = -\\mathrm{sign}(x_1)\\|x\\|_2$，标量为 $\\tau = \\dfrac{2}{v^\\top v}$。\n- **紧凑存储**：对于每一步 $k$，Householder 向量 $v_k \\in \\mathbb{R}^{n-k-1}$ 被缩放，使其第一个元素为 $1$。存储此缩放后向量的尾部 $v_k[1:], \\dots, v_k[n-k-2]$。还必须存储反射矩阵 $H_k = I - \\tau_k v_k v_k^\\top$（其中 $v_k$ 是缩放后的向量）对应的标量因子 $\\tau_k$。\n- **要求实现的函数**：\n    1.  一个将 $A$ 三对角化为 $T$ 的函数，并返回 $T$ 以及用于 `Q` 的紧凑表示的两个列表：一个用于存储缩放后的 Householder 向量的尾部（`v_list`），另一个用于存储标量（`tau_list`）。\n    2.  仅使用紧凑存储将完整的正交矩阵 $Q$ 及其转置 $Q^\\top$ 应用于向量 $y$ 的函数。$Q$ 是所有初等反射矩阵的乘积。\n    3.  一个通过将 $Q$ 应用于单位矩阵从紧凑存储中重构 $Q$ 的函数。\n- **测试用例**：\n    1.  $A_1 = \\begin{bmatrix} 5 \\end{bmatrix}$ ($n=1$)\n    2.  $A_2 = \\begin{bmatrix} 4  1 \\\\ 1  3 \\end{bmatrix}$ ($n=2$)\n    3.  $A_3 = \\frac{1}{2}(B + B^\\top)$，其中 $B \\in \\mathbb{R}^{5 \\times 5}$ 来自种子为 $42$ 的标准正态分布。\n    4.  $A_4 \\in \\mathbb{R}^{6 \\times 6}$ 是一个三对角矩阵，对角线元素为 $[2,3,4,5,6,7]$，次/超对角线元素为 $1$。\n    5.  $y \\in \\mathbb{R}^5$ 来自种子为 $42$ 的标准正态分布，使用来自 $A_3$ 的反射矩阵。\n- **输出**：\n    1.  $r_1$：布尔值，判断 $T_1$ 的所有非三对角（$|i-j|1$）元素的绝对值是否 $\\le 10^{-12}$。\n    2.  $r_2$：浮点数，$\\max_{i,j} \\left| \\left(Q_2^\\top A_2 Q_2 - T_2 \\right)_{ij} \\right|$，其中 $Q_2$ 是重构的。\n    3.  $r_3$：浮点数，$\\max_{|i-j|1} \\left| (T_3)_{ij} \\right|$。\n    4.  $r_4$：布尔值，判断是否 $\\|T_4 - A_4\\|_\\infty \\le 10^{-10}$。\n    5.  $r_5$：浮点数，$\\|Q_3^\\top (Q_3 y) - y\\|_2$。\n\n**第 2 步：使用提取的已知条件进行验证**\n\n-   **科学依据**：该问题描述了 Householder 三对角化，这是数值线性代数中的一个基石算法。指定的 Householder 向量和反射矩阵的公式是标准且正确的。构造 $v = x - \\alpha e_1$ 的方法（其中 $\\alpha = -\\mathrm{sign}(x_1)\\|x\\|_2$）简化为 $v = x + \\mathrm{sign}(x_1)\\|x\\|_2 e_1$，这是数值上稳健的选择，以避免相消误差。\n-   **适定性**：问题是适定的。该算法是确定性的，并能生成唯一的三对角矩阵 $T$ 和正交矩阵 $Q$（符号由 $\\alpha$ 的定义固定，因此结果唯一）。任务和要求的输出都有精确定义。\n-   **客观性**：语言是形式化的、数学的，没有任何主观性。\n-   **紧凑存储的一致性**：问题要求将标准 Householder 向量 $u = x - \\alpha e_1$ 缩放为一个新向量 $v$，其中 $v_1=1$。这是通过 $v = u/u_1$ 实现的。对于公式 $H=I-\\tau_k v v^\\top$，相关的标量 $\\tau_k$ 可以一致地确定为 $\\tau_k = 2/(v^\\top v)$。这等价于将原始标量 $\\tau_u = 2/(u^\\top u)$ 乘以 $u_1^2$，即 $\\tau_v = \\tau_u u_1^2$。此要求没有歧义且内部一致。\n\n**第 3 步：结论与行动**\n\n问题在科学上是合理的、适定的、客观的，并且不包含任何矛盾或歧义。这是一个有效的问题。我将继续提供解决方案。\n\n### 算法设计与实现\n\n解决方案将包含一个主函数 `solve`，用于组织所有测试用例，以及四个辅助函数：`tridiagonalize`、`apply_Q`、`apply_QT` 和 `reconstruct_Q`。\n\n1.  **`tridiagonalize(A)`**：此函数接收一个对称矩阵 `A`，并返回三对角矩阵 `T` 以及用于 `Q` 的紧凑表示的两个列表：一个用于存储缩放后的 Householder 向量的尾部（`v_list`），另一个用于存储标量（`tau_list`）。\n    - 该过程从 $k=0$ 迭代到 $n-3$。在每一步 $k$ 中，它考虑向量 $x = A[k+1:n, k]$。\n    - 它计算 Householder 反射矩阵 $P_k$，将 $x$ 中除第一个元素外的所有元素置零。变换为 $x \\rightarrow \\alpha e_1$。\n    - 完整的相似变换是 $A \\leftarrow H_k A H_k$，其中 $H_k = \\mathrm{diag}(I_{k+1}, P_k)$。这通过对尾随子矩阵 $A[k+1:n, k+1:n]$ 进行秩-2 更新来高效实现。新的次对角线元素 $A[k+1, k]$ 被设置为 $\\alpha$。\n    - 为了存储，计算未缩放的 Householder 向量 $u_k$，然后缩放为 $v_k = u_k/u_{k,0}$。存储其尾部 $v_k[1:]$ 和对应的标量 $\\tau_k = 2/(v_k^\\top v_k)$。\n\n2.  **`apply_QT(y, ...)` 和 `apply_Q(y, ...)`**：这些函数将 $Q^\\top$ 和 $Q$ 应用于向量 $y$。\n    - 正交矩阵为 $Q = H_0 H_1 \\dots H_{n-3}$。\n    - $Q^\\top y = (H_{n-3} \\dots H_0) y$。这通过按生成顺序（$k=0, 1, \\dots$）应用反射矩阵 $H_k$ 来计算。\n    - $Q y = (H_0 \\dots H_{n-3}) y$。这通过按生成顺序的逆序（$k=n-3, n-4, \\dots, 0$）应用反射矩阵 $H_k$ 来计算。\n    - 每次应用 $z \\leftarrow H_k z$ 都需要通过在其存储的尾部前添加一个 $1$ 来重构完整的缩放向量 $v_k$，然后将变换 $z_{sub} \\leftarrow z_{sub} - \\tau_k v_k (v_k^\\top z_{sub})$ 应用于 $z$ 的适当子向量。\n\n3.  **`reconstruct_Q(...)`**：此函数通过将 $Q$ 应用于单位矩阵来显式构造矩阵 $Q$，即 $Q = Q I$。它从 $Q_{matrix} = I$ 开始，并按逆序（$k=n-3, \\dots, 0$）将反射矩阵 $H_k$ 依次应用于当前的 $Q_{matrix}$，即 $Q_{matrix} \\leftarrow H_k Q_{matrix}$。每个变换同时应用于 $Q_{matrix}$ 的所有列。\n\n主函数 `solve` 将对指定的测试用例执行这些步骤，并计算五个所需的结果 $r_1$ 到 $r_5$。然后按指定格式打印结果。", "answer": "```python\nimport numpy as np\n\ndef tridiagonalize(A):\n    \"\"\"\n    Performs symmetric Householder tridiagonalization of a matrix A.\n\n    Args:\n        A (np.ndarray): A real symmetric n x n matrix.\n\n    Returns:\n        tuple: A tuple containing:\n            - T (np.ndarray): The tridiagonal matrix.\n            - v_list (list): A list of the tails of the scaled Householder vectors.\n            - tau_list (list): A list of the scalar factors tau.\n    \"\"\"\n    T = A.copy()\n    n = T.shape[0]\n    \n    if n = 2:\n        return T, [], []\n\n    v_list = []\n    tau_list = []\n    \n    # Loop from k = 0 to n-3\n    for k in range(n - 2):\n        x = T[k+1:n, k]\n        m = len(x)\n        norm_x = np.linalg.norm(x)\n        \n        # Unscaled Householder vector u\n        u = x.copy()\n        \n        alpha = 0.0\n        if norm_x > 1e-15:\n            # alpha = -sign(x_0) * ||x||\n            sign_x0 = np.copysign(1.0, x[0]) if x[0] != 0.0 else 1.0\n            alpha = -sign_x0 * norm_x\n            \n            # u = x - alpha * e_1 = x + sign(x_0) * ||x|| * e_1\n            u[0] -= alpha\n            \n            # Check for non-zero first element before scaling\n            u0 = u[0]\n            if abs(u0)  1e-15:\n                # This case implies x is already zero or nearly zero, or u=0.\n                # Treat as a no-op for this iteration.\n                v_list.append(np.zeros(m - 1))\n                tau_list.append(0.0)\n            else:\n                # Scaled vector v_k, where first component is 1\n                v = u / u0\n                v_list.append(v[1:])\n                \n                # Corresponding tau for the scaled vector\n                tau = 2.0 / (v @ v)\n                tau_list.append(tau)\n                \n                # Apply similarity transformation T - H T H using the unscaled vector u\n                # for simpler formula application, since the underlying reflector is identical.\n                tau_u = 2.0 / (u @ u)\n                \n                sub_T = T[k+1:n, k+1:n]\n                p = tau_u * (sub_T @ u)\n                beta = (u @ p) / 2.0\n                w = p - beta * u\n                sub_T -= np.outer(w, u) + np.outer(u, w)\n                T[k+1:n, k+1:n] = sub_T\n        else:\n            # norm_x is zero, column is already zeroed out.\n            v_list.append(np.zeros(m - 1))\n            tau_list.append(0.0)\n\n        T[k+1, k] = alpha\n        T[k, k+1] = alpha\n        # Enforce zeros for numerical stability\n        T[k+2:n, k] = 0.0\n        T[k, k+2:n] = 0.0\n\n    return T, v_list, tau_list\n\ndef apply_Q(y, v_list, tau_list, n):\n    \"\"\"Applies Q to a vector y, where Q = H_0 ... H_{n-3}.\"\"\"\n    z = y.copy()\n    num_reflectors = len(v_list)\n    for k in range(num_reflectors - 1, -1, -1):\n        if tau_list[k] == 0.0:\n            continue\n        v_compact = v_list[k]\n        v = np.hstack([1.0, v_compact])\n        tau = tau_list[k]\n        \n        z_sub = z[k+1:n]\n        z_sub -= tau * v * (v @ z_sub)\n        z[k+1:n] = z_sub\n    return z\n\ndef apply_QT(y, v_list, tau_list, n):\n    \"\"\"Applies Q^T to a vector y, where Q^T = H_{n-3} ... H_0.\"\"\"\n    z = y.copy()\n    num_reflectors = len(v_list)\n    for k in range(num_reflectors):\n        if tau_list[k] == 0.0:\n            continue\n        v_compact = v_list[k]\n        v = np.hstack([1.0, v_compact])\n        tau = tau_list[k]\n        \n        z_sub = z[k+1:n]\n        z_sub -= tau * v * (v @ z_sub)\n        z[k+1:n] = z_sub\n    return z\n\ndef reconstruct_Q(n, v_list, tau_list):\n    \"\"\"Reconstructs the orthogonal matrix Q from its compact representation.\"\"\"\n    if n == 0:\n        return np.array([])\n    Q = np.identity(n)\n    num_reflectors = len(v_list)\n    for k in range(num_reflectors - 1, -1, -1):\n        if tau_list[k] == 0.0:\n            continue\n        v_compact = v_list[k]\n        v = np.hstack([1.0, v_compact])\n        tau = tau_list[k]\n        \n        Q_sub = Q[k+1:n, :]\n        update = tau * np.outer(v, v @ Q_sub)\n        Q[k+1:n, :] -= update\n    return Q\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    results = []\n\n    # Test Case 1: Trivial size\n    A1 = np.array([[5.0]])\n    T1, _, _ = tridiagonalize(A1)\n    n1 = T1.shape[0]\n    off_tridiag_abs_vals_1 = [np.abs(T1[i, j]) for i in range(n1) for j in range(n1) if abs(i - j) > 1]\n    r1 = all(val = 1e-12 for val in off_tridiag_abs_vals_1) if off_tridiag_abs_vals_1 else True\n    results.append(r1)\n\n    # Test Case 2: Small case\n    A2 = np.array([[4.0, 1.0], [1.0, 3.0]])\n    T2, v_list2, tau_list2 = tridiagonalize(A2)\n    n2 = A2.shape[0]\n    Q2 = reconstruct_Q(n2, v_list2, tau_list2)\n    err_matrix2 = Q2.T @ A2 @ Q2 - T2\n    r2 = np.max(np.abs(err_matrix2))\n    results.append(r2)\n\n    # Test Case 3  5: General random case and orthogonality check\n    rng = np.random.default_rng(42)\n    B = rng.standard_normal((5, 5))\n    A3 = (B + B.T) / 2.0\n    T3, v_list3, tau_list3 = tridiagonalize(A3)\n    n3 = A3.shape[0]\n    \n    # r3 calculation\n    off_tridiag_abs_vals_3 = [np.abs(T3[i, j]) for i in range(n3) for j in range(n3) if abs(i - j) > 1]\n    r3 = 0.0 if not off_tridiag_abs_vals_3 else max(off_tridiag_abs_vals_3)\n    results.append(r3)\n\n    # Test Case 4: Already tridiagonal input\n    A4 = np.diag(np.arange(2.0, 8.0)) + np.diag(np.ones(5), 1) + np.diag(np.ones(5), -1)\n    T4, _, _ = tridiagonalize(A4)\n    r4 = np.max(np.abs(T4 - A4)) = 1e-10\n    results.append(r4)\n\n    # r5 calculation (uses artifacts from TC3)\n    y = rng.standard_normal(5)\n    Qy = apply_Q(y, v_list3, tau_list3, n3)\n    QTQy = apply_QT(Qy, v_list3, tau_list3, n3)\n    r5 = np.linalg.norm(QTQy - y)\n    results.append(r5)\n\n    # Format output\n    formatted_results = []\n    for res in results:\n        if isinstance(res, bool):\n            formatted_results.append(str(res).lower())\n        else:\n            formatted_results.append(str(res))\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3239709"}]}