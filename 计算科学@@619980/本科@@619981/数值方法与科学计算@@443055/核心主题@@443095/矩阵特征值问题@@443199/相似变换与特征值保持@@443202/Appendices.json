{"hands_on_practices": [{"introduction": "理论上，相似矩阵共享许多不变量，如迹、行列式和特征多项式。然而，反过来是否成立？本练习将通过构造一个具体的反例，帮助你深入理解相似性的真正含义，揭示仅有这些共享属性并不足以保证两个矩阵相似。[@problem_id:3273917]", "problem": "设 $A$ 和 $B$ 是实 $4 \\times 4$ 矩阵。仅使用关于相似变换和矩阵不变量的核心定义和经过充分验证的事实，构造两个显式矩阵 $A$ 和 $B$ ，它们彼此不相似，但共享以下所有性质：\n- 相同的迹，\n- 相同的行列式，\n- 相同的特征多项式，\n- 相同的弗罗贝尼乌斯范数。\n\n你必须从第一性原理出发，证明为什么 $A$ 和 $B$ 不相似，以及为什么所列的四个量对于这两个矩阵是相等的。你可以使用以下事实：对于三角矩阵，特征值是其对角线元素；迹是对角线元素之和，行列式是对角线元素之积；弗罗贝尼乌斯范数定义为 $\\lVert X \\rVert_{F} = \\sqrt{\\sum_{i,j} x_{ij}^{2}} = \\sqrt{\\operatorname{trace}(X^{\\mathsf{T}} X)}$。\n\n最后，报告你所构造矩阵的共同弗罗贝尼乌斯范数的精确值。你的答案必须是单一的封闭形式表达式。不要四舍五入。", "solution": "问题要求构造两个实 $4 \\times 4$ 矩阵 $A$ 和 $B$，它们不相似但具有相同的迹、行列式、特征多项式和弗罗贝尼乌斯范数。我们必须从第一性原理出发证明这些性质中的每一个。\n\n线性代数的一个核心原则是，两个矩阵相似当且仅当它们在不同基下表示同一个线性变换。这意味着相似矩阵共享许多性质，这些性质被称为相似不变量。这些不变量包括特征多项式、特征值、迹和行列式。然而，反之不成立；共享这些性质并不能保证相似性。决定相似性的关键不变量是若尔当标准型。两个矩阵相似当且仅当它们具有相同的若尔当标准型（在若尔当块的排列上可能有所不同）。\n\n我们的策略是构造两个矩阵 $A$ 和 $B$，使它们具有相同的特征值但不同的若尔当块结构。这将确保它们具有相同的特征多项式（因此也具有相同的迹和行列式），但彼此不相似。我们将具体地以若尔当标准型的形式构造它们，这简化了分析。最后的约束是确保它们也具有相同的弗罗贝尼乌斯范数。\n\n让我们为我们的 $4 \\times 4$ 矩阵选择特征值。为简单起见，我们选择所有特征值均为 $0$。任何此类矩阵的特征多项式都必须是 $p(\\lambda) = (\\lambda-0)^4 = \\lambda^4$。可能的若尔当标准型对应于 $4$ 的整数分拆。我们将选择 $4$ 的两种不同的分拆，它们恰好产生相同的弗罗贝尼乌斯范数。考虑分拆 $3+1$ 和 $2+2$。\n\n设矩阵 $A$ 是对应于特征值 $\\lambda=0$ 的分拆 $3+1$ 的若尔当标准型。此形式有一个大小为 $3$ 的若尔当块和一个大小为 $1$ 的若尔当块：\n$$ A = \\begin{pmatrix} 0  1  0  0 \\\\ 0  0  1  0 \\\\ 0  0  0  0 \\\\ 0  0  0  0 \\end{pmatrix} $$\n设矩阵 $B$ 是对应于特征值 $\\lambda=0$ 的分拆 $2+2$ 的若尔当标准型。此形式有两个大小为 $2$ 的若尔当块：\n$$ B = \\begin{pmatrix} 0  1  0  0 \\\\ 0  0  0  0 \\\\ 0  0  0  1 \\\\ 0  0  0  0 \\end{pmatrix} $$\n$A$ 和 $B$ 都是实 $4 \\times 4$ 矩阵。我们现在将验证它们是否满足所有要求的条件。\n\n1.  **特征多项式：** 特征多项式定义为 $p(\\lambda) = \\det(M - \\lambda I)$。对于三角矩阵，行列式是其对角线元素的乘积。\n    *   对于矩阵 $A$，$A - \\lambda I$ 是一个上三角矩阵，其对角线元素为 $(-\\lambda, -\\lambda, -\\lambda, -\\lambda)$。因此，其特征多项式为 $p_A(\\lambda) = (-\\lambda)(-\\lambda)(-\\lambda)(-\\lambda) = \\lambda^4$。$A$ 的特征值均为 $0$。\n    *   对于矩阵 $B$，$B - \\lambda I$ 也是一个上三角矩阵，其对角线元素为 $(-\\lambda, -\\lambda, -\\lambda, -\\lambda)$。因此，其特征多项式为 $p_B(\\lambda) = (-\\lambda)(-\\lambda)(-\\lambda)(-\\lambda) = \\lambda^4$。$B$ 的特征值均为 $0$。\n    因此，$A$ 和 $B$ 具有相同的特征多项式：$p_A(\\lambda) = p_B(\\lambda) = \\lambda^4$。\n\n2.  **迹：** 矩阵的迹是其对角线元素之和。\n    *   $\\operatorname{trace}(A) = 0 + 0 + 0 + 0 = 0$。\n    *   $\\operatorname{trace}(B) = 0 + 0 + 0 + 0 = 0$。\n    因此，$\\operatorname{trace}(A) = \\operatorname{trace}(B)$。这也与迹是特征值之和这一事实相符。\n\n3.  **行列式：** 三角矩阵的行列式是其对角线元素的乘积。\n    *   $\\det(A) = 0 \\times 0 \\times 0 \\times 0 = 0$。\n    *   $\\det(B) = 0 \\times 0 \\times 0 \\times 0 = 0$。\n    因此，$\\det(A) = \\det(B)$。这也与行列式是特征值之积这一事实相符。\n\n4.  **弗罗贝尼乌斯范数：** 弗罗贝尼乌斯范数定义为 $\\lVert X \\rVert_F = \\sqrt{\\sum_{i,j=1}^4 x_{ij}^2}$。\n    *   对于矩阵 $A$，唯一的非零元素是 $A_{12}=1$ 和 $A_{23}=1$。元素的平方和是 $1^2 + 1^2 = 2$。\n        $$ \\lVert A \\rVert_F = \\sqrt{1^2 + 1^2} = \\sqrt{2} $$\n    *   对于矩阵 $B$，唯一的非零元素是 $B_{12}=1$ 和 $B_{34}=1$。元素的平方和是 $1^2 + 1^2 = 2$。\n        $$ \\lVert B \\rVert_F = \\sqrt{1^2 + 1^2} = \\sqrt{2} $$\n    因此，$\\lVert A \\rVert_F = \\lVert B \\rVert_F = \\sqrt{2}$。\n\n5.  **不相似性：** 如果两个矩阵在任何相似不变量上有所不同，则它们不相似。一个基本的不变量是最小多项式。矩阵 $M$ 的最小多项式 $m_M(\\lambda)$ 是使得 $m_M(M) = 0$ 的次数最低的首一多项式。相似矩阵必须具有相同的最小多项式。\n    *   对于矩阵 $A$，我们计算它的幂：\n        $$ A^2 = A \\cdot A = \\begin{pmatrix} 0  0  1  0 \\\\ 0  0  0  0 \\\\ 0  0  0  0 \\\\ 0  0  0  0 \\end{pmatrix} $$\n        $$ A^3 = A^2 \\cdot A = \\begin{pmatrix} 0  0  0  0 \\\\ 0  0  0  0 \\\\ 0  0  0  0 \\\\ 0  0  0  0 \\end{pmatrix} = 0_{4 \\times 4} $$\n        由于 $A^2 \\neq 0$ 且 $A^3 = 0$，所以 $A$ 的最小多项式是 $m_A(\\lambda) = \\lambda^3$。\n    *   对于矩阵 $B$，我们计算它的幂：\n        $$ B^2 = B \\cdot B = \\begin{pmatrix} 0  0  0  0 \\\\ 0  0  0  0 \\\\ 0  0  0  0 \\\\ 0  0  0  0 \\end{pmatrix} = 0_{4 \\times 4} $$\n        由于 $B \\neq 0$ 且 $B^2 = 0$，所以 $B$ 的最小多项式是 $m_B(\\lambda) = \\lambda^2$。\n    *   因为 $m_A(\\lambda) \\neq m_B(\\lambda)$，所以矩阵 $A$ 和 $B$ 不相似。这反映了它们不同的若尔当结构：最小多项式中因子 $(\\lambda - \\lambda_i)$ 的次数对应于特征值 $\\lambda_i$ 的最大若尔当块的大小。对于 $A$，最大的块大小为 $3$，而对于 $B$，最大的块大小为 $2$。\n\n我们成功地构造了两个满足所有给定条件的矩阵 $A$ 和 $B$。这些矩阵的共同弗罗贝尼乌斯范数是 $\\sqrt{2}$。", "answer": "$$\n\\boxed{\\sqrt{2}}\n$$", "id": "3273917"}, {"introduction": "在将理论应用于实际计算时，算法效率是核心考量。本练习探讨了在应用相似变换算子时的两种策略——显式构造变换后矩阵和隐式应用算子——并分析它们的计算成本。通过推导，你将学会如何在不同的计算场景中做出最优选择。[@problem_id:3273924]", "problem": "考虑一个实稠密矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和一个实稠密非奇异矩阵 $P \\in \\mathbb{R}^{n \\times n}$。相似变换矩阵 $B$ 定义为 $B = P^{-1} A P$，该变换保留了 $A$ 的特征值。在一次数值模拟中，您必须将由 $B$ 表示的线性算子应用于 $m$ 个不同的向量 $x^{(1)}, x^{(2)}, \\dots, x^{(m)} \\in \\mathbb{R}^{n}$。您正在考虑两种策略：\n\n- 策略1（显式构建）：显式构建矩阵 $B$，然后将 $B$ 应用于每个向量。\n- 策略2（隐式应用）：不构建矩阵 $B$；而是通过复合映射 $x \\mapsto P^{-1}(A(Px))$ 将算子应用于每个向量。\n\n假设稠密线性代数使用以下标准的、经过充分检验的运算计数模型：\n- 一个 $n \\times n$ 稠密矩阵的LU（Lower-Upper）分解需要 $\\frac{2}{3} n^{3}$ 次浮点运算（flops）。\n- 两个 $n \\times n$ 稠密矩阵的矩阵-矩阵乘积需要 $2 n^{3}$ 次浮点运算。\n- 求解具有 $n$ 个右端项的 $n \\times n$ 三角系统，每个三角因子需要 $n^{3}$ 次浮点运算。\n- 一个 $n \\times n$ 稠密矩阵与向量的乘积需要 $2 n^{2}$ 次浮点运算。\n- 求解具有单个右端项的 $n \\times n$ 三角系统，每个三角因子需要 $n^{2}$ 次浮点运算。\n\n对于策略1，使用 $P$ 的LU因子和三角求解来构建 $B$（不要显式计算 $P^{-1}$），然后将 $B$ 应用于每个向量。对于策略2，对 $P$ 进行一次因式分解，然后对每个向量，使用矩阵-向量乘积和三角求解来应用映射 $x \\mapsto P^{-1}(A(Px))$。\n\n仅使用这些模型和相似变换的核心定义，推导每种策略的总浮点运算次数（作为 $n$ 和 $m$ 的函数），并确定精确的盈亏平衡点 $m^{\\ast}(n)$，使得策略1的总成本等于策略2的总成本。将您的最终答案表示为关于 $n$ 的单个封闭形式表达式。无需四舍五入。", "solution": "本题要求我们分析两种计算策略的总浮点运算（flop）次数，并找出它们的盈亏平衡点。我们将根据问题中提供的标准运算计数模型，逐步推导每种策略的成本。\n\n**策略1：显式构建矩阵 $B$**\n\n此策略分为两步：首先一次性构建矩阵 $B = P^{-1}AP$，然后将其应用于 $m$ 个向量。\n\n1.  **构建 $B$ 的成本：**\n    我们不直接计算 $P^{-1}$，而是求解矩阵方程 $PB = AP$ 来得到 $B$。\n    *   **计算中间矩阵 $C = AP$：** 这是一个 $n \\times n$ 矩阵与 $n \\times n$ 矩阵的乘法。\n        成本：$2n^3$ 次浮点运算。\n    *   **求解 $PB = C$：** 这需要先对 $P$ 进行LU分解，然后对 $C$ 的每一列进行一次前向和后向替换。\n        *   $P$ 的LU分解：$\\frac{2}{3}n^3$ 次浮点运算。\n        *   求解 $LY=C$（$n$ 个右端项的前向替换）：$n^3$ 次浮点运算。\n        *   求解 $UB=Y$（$n$ 个右端项的后向替换）：$n^3$ 次浮点运算。\n    *   构建 $B$ 的总成本为：\n        $C_{\\text{构建}} = 2n^3 + \\frac{2}{3}n^3 + n^3 + n^3 = \\frac{14}{3}n^3$ 次浮点运算。\n\n2.  **应用 $B$ 的成本：**\n    将构建好的稠密矩阵 $B$ 应用于 $m$ 个向量，每个向量需要一次矩阵-向量乘法。\n    *   单次矩阵-向量乘法成本：$2n^2$ 次浮点运算。\n    *   $m$ 个向量的总成本：$m \\cdot (2n^2)$ 次浮点运算。\n\n3.  **策略1的总成本：**\n    $C_1(n, m) = C_{\\text{构建}} + C_{\\text{应用}} = \\frac{14}{3}n^3 + 2mn^2$\n\n**策略2：隐式应用算子**\n\n此策略不对外显式构建 $B$，而是对每个向量 $x$ 计算 $y = P^{-1}(A(Px))$。该过程包含一次性设置和循环应用。\n\n1.  **一次性设置成本：**\n    为了高效计算 $P^{-1}v$，我们预先对 $P$ 进行一次LU分解。\n    *   $P$ 的LU分解成本：$\\frac{2}{3}n^3$ 次浮点运算。\n\n2.  **对单个向量的应用成本：**\n    对于每个向量 $x^{(i)}$，我们需要执行以下三步：\n    *   **计算 $z^{(i)} = Px^{(i)}$：** 一次矩阵-向量乘法。成本：$2n^2$ 次浮点运算。\n    *   **计算 $w^{(i)} = Az^{(i)}$：** 一次矩阵-向量乘法。成本：$2n^2$ 次浮点运算。\n    *   **计算 $y^{(i)} = P^{-1}w^{(i)}$：** 使用已分解的LU因子求解线性系统 $Py^{(i)} = w^{(i)}$。这包括一次前向替换和一次后向替换。成本：$n^2 + n^2 = 2n^2$ 次浮点运算。\n    *   单个向量的总应用成本为：$2n^2 + 2n^2 + 2n^2 = 6n^2$ 次浮点运算。\n\n3.  **策略2的总成本：**\n    总成本是设置成本加上 $m$ 次应用成本。\n    $C_2(n, m) = \\frac{2}{3}n^3 + m \\cdot (6n^2)$\n\n**确定盈亏平衡点 $m^*(n)$**\n\n盈亏平衡点是两种策略成本相等时的向量数 $m$。\n$C_1(n, m) = C_2(n, m)$\n$$ \\frac{14}{3}n^3 + 2mn^2 = \\frac{2}{3}n^3 + 6mn^2 $$\n\n现在，我们求解这个关于 $m$ 的方程：\n$$ \\left(\\frac{14}{3} - \\frac{2}{3}\\right)n^3 = (6 - 2)mn^2 $$\n$$ \\frac{12}{3}n^3 = 4mn^2 $$\n$$ 4n^3 = 4mn^2 $$\n\n假设 $n \\ge 1$，我们可以两边同时除以 $4n^2$：\n$$ m = \\frac{4n^3}{4n^2} = n $$\n因此，盈亏平衡点是 $m^*(n) = n$。这意味着，如果需要应用的向量数量大于矩阵的维度 $n$，则显式构建矩阵 $B$ 更有效；如果小于 $n$，则隐式应用算子更有效。", "answer": "$$\\boxed{n}$$", "id": "3273924"}, {"introduction": "虽然相似变换在精确算术下保持特征值不变，但在有限精度的浮点运算中，变换矩阵的性质对结果的准确性至关重要。本练习将通过一个数值实验，直观地比较正交相似变换与病态非正交相似变换对特征值计算精度的影响。你将亲手验证为何在数值计算中，我们总是优先选择稳定的正交变换。[@problem_id:3273813]", "problem": "设计并实现一个完整的、可运行的程序，进行一项可复现的数值实验，以比较一个实对称矩阵在两类相似变换下的特征值的有限精度准确性：一类是正交相似变换，另一类是使用病态矩阵的非正交相似变换。实验背景是面向高年级本科生水平的数值方法和科学计算。\n\n从以下基本事实出发：\n- 相似变换由 $B = S^{-1} A S$ 定义，其中 $S$ 是可逆矩阵，$A$ 是方阵。在精确算术中，$A$ 和 $B$ 的特征值完全相同。\n- 实对称矩阵 $A$ 具有实特征值，并且可以被正交矩阵对角化。\n- 在单位舍入误差为 $u$ 的浮点运算中，正交变换是保范的，并且通常是后向稳定的，而使用病态矩阵 $S$ 构造 $S^{-1} A S$ 会放大舍入误差，并导致更大的后向误差。\n\n你的程序必须：\n1. 如下文所规定，构造对称测试矩阵 $A$ 和变换矩阵 $Q$（正交）及 $P$（病态）。在需要的地方使用双精度（标准的 Python 和 NumPy 默认设置）和确定性种子。\n2. 在浮点运算中构造变换后的矩阵 $A_{Q} = Q^{\\mathsf{T}} A Q$ 和 $A_{P} = P^{-1} A P$。\n3. 使用对称特征值求解器从 $A$ 计算参考谱 $\\lambda_{\\mathrm{ref}}$。\n4. 使用对称特征值求解器从 $A_{Q}$ 计算谱 $\\lambda_{Q}$，并使用通用特征值求解器从 $A_{P}$ 计算谱 $\\lambda_{P}$。在比较前，按实部对特征值进行排序。\n5. 通过相对2-范数误差来量化准确性\n   $$\\mathrm{rel\\_err}(\\lambda_{\\mathrm{ref}}, \\lambda_{\\mathrm{comp}}) = \\frac{\\lVert \\lambda_{\\mathrm{comp}} - \\lambda_{\\mathrm{ref}} \\rVert_{2}}{\\max\\left(\\lVert \\lambda_{\\mathrm{ref}} \\rVert_{2}, \\varepsilon\\right)}$$\n   其中 $\\varepsilon$ 是用于避免除以零的机器ε。当 $\\lambda_{\\mathrm{comp}}$ 为复数值时，使用其实部进行比较，以关注在实轴上的偏差，这对于对称矩阵是符合预期的。\n6. 报告比率\n   $$r = \\frac{\\mathrm{rel\\_err}(\\lambda_{\\mathrm{ref}}, \\lambda_{P})}{\\max\\left(\\mathrm{rel\\_err}(\\lambda_{\\mathrm{ref}}, \\lambda_{Q}), \\varepsilon\\right)}$$\n   远大于 $1$ 的比率 $r$ 表明，病态非正交相似变换产生的特征值比正交相似变换的准确性更低。\n\n需实现的测试套件：\n- 情况1（通用“理想路径”）：$A$ 是一个 $6 \\times 6$ 的随机对称矩阵，由 $\\frac{M + M^{\\mathsf{T}}}{2}$ 生成，其中 $M$ 的元素来自种子为 $0$ 的独立标准正态分布。$Q$ 是正交矩阵，通过对一个种子为 $0$ 的随机 $6 \\times 6$ 高斯矩阵进行 $Q R$ 分解得到。$P$ 是对角矩阵，其元素在 $10^{-4}$ 和 $10^{4}$ 之间呈等比分布，产生的条件数为 $10^{8}$。\n- 情况2（边界条件）：$A$ 是一个 $10 \\times 10$ 的三对角矩阵，其对角线元素为 $2$，第一亚对角线和第一超对角线元素为 $-1$（标准的离散一维拉普拉斯算子，具有类狄利克雷结构）。$Q$ 是单位矩阵 $I$。$P$ 是单位矩阵 $I$。此情况测试两种变换均为良性时的基线。\n- 情况3（病态变换，谱分离良好）：$A$ 是一个 $8 \\times 8$ 矩阵，其对角元素为 $\\{1,2,3,4,5,6,7,8\\}$，外加一个小的对称扰动 $10^{-6} \\cdot S$，其中 $S$ 是一个由种子 $1$ 生成的随机对称矩阵。$Q$ 是正交矩阵，通过对一个种子为 $2$ 的随机 $8 \\times 8$ 高斯矩阵进行 $Q R$ 分解得到。$P$ 是对角矩阵，其元素在 $10^{-6}$ 和 $10^{6}$ 之间呈等比分布，产生的条件数为 $10^{12}$。\n- 情况4（具有挑战性的 $A$，病态的 $P$）：$A$ 是 $5 \\times 5$ 的希尔伯特矩阵，其元素为 $A_{i j} = \\frac{1}{i + j - 1}$，该矩阵是对称正定的，但在数值上具有挑战性。$Q$ 是正交矩阵，通过对一个种子为 $3$ 的随机 $5 \\times 5$ 高斯矩阵进行 $Q R$ 分解得到。$P$ 是对角矩阵，其元素在 $10^{-3}$ 和 $10^{3}$ 之间呈等比分布，产生的条件数为 $10^{6}$。\n\n计算细节：\n- 对于参考特征值 $\\lambda_{\\mathrm{ref}}$ 和 $\\lambda_{Q}$，使用对称特征值求解器。对于 $\\lambda_{P}$，使用适用于可能非对称矩阵的通用特征值求解器。\n- 在计算相对误差之前，按实部升序对每个特征值数组进行排序。\n\n最终输出规范：\n- 你的程序应生成一行输出，其中包含四个测试用例的四个比率 $r$，格式为方括号括起来的逗号分隔列表（例如 `\"[r_1,r_2,r_3,r_4]\"`）。每个 $r$ 都是一个浮点数。\n\n本任务不涉及物理单位、角度单位或百分比。所有报告的数字都是无单位的。", "solution": "该问题要求设计并实现一个数值实验，以展示相似变换的条件对计算出的特征值准确性的影响。其核心原理是，虽然相似变换 $B = S^{-1} A S$ 在精确算术中保持矩阵 $A$ 的特征值不变，但在有限精度的浮点运算中，这种不变性可能会被破坏。计算出的 $B$ 的特征值的数值稳定性高度依赖于变换矩阵 $S$ 的条件数，记为 $\\kappa(S) = \\lVert S \\rVert \\lVert S^{-1} \\rVert$。\n\n该实验对比了对实对称矩阵 $A$ 进行的两类相似变换：\n$1$. 正交变换，$A_{Q} = Q^{\\mathsf{T}} A Q$，其中 $Q$ 是正交矩阵（$Q^{\\mathsf{T}} Q = I$）。对于 2-范数，正交变换是理想条件的（$\\kappa_2(Q) = 1$），并且是已知的后向稳定变换。基于正交变换的特征值算法是数值线性代数中最可靠的算法之一。\n$2$. 非正交变换，$A_{P} = P^{-1} A P$，其中 $P$ 是一个特意构造的病态矩阵（即 $\\kappa(P) \\gg 1$）。$A_P$ 的构造涉及矩阵求逆和两次矩阵乘法，每一步都会引入舍入误差。这些误差会被 $P$ 的大条件数显著放大，导致矩阵 $A_P$ 计算出的特征值可能与 $A$ 的真实特征值有很大偏差。\n\n程序将为四个指定的测试用例系统地执行以下步骤：\n\n首先，构造所需的矩阵。每个测试用例定义了一个大小为 $n \\times n$ 的对称矩阵 $A$、一个大小为 $n \\times n$ 的正交矩阵 $Q$ 以及一个大小为 $n \\times n$ 的病态、非正交但可逆的矩阵 $P$。构造过程利用确定性随机种子以确保可复现性。例如，在情况1中，$A$ 是一个 $6 \\times 6$ 的随机对称矩阵，$Q$ 是通过QR分解得到的随机 $6 \\times 6$ 正交矩阵，$P$ 是一个 $6 \\times 6$ 的对角矩阵，其元素在 $10^{-4}$ 到 $10^{4}$ 之间呈等比数列分布，从而得到条件数 $\\kappa(P) = 10^8$。\n\n其次，在浮点运算中应用相似变换，构造 $A_{Q} = Q^{\\mathsf{T}} A Q$ 和 $A_{P} = P^{-1} A P$。\n\n第三，计算特征值谱。使用专门用于对称矩阵的求解器（`numpy.linalg.eigh`）从原始矩阵 $A$ 计算参考谱 $\\lambda_{\\mathrm{ref}}$，该方法非常精确。谱 $\\lambda_{Q}$ 也使用对称求解器从变换后的矩阵 $A_Q$ 计算得出，因为 $A_Q$ 根据其构造是堆成的。谱 $\\lambda_{P}$ 使用通用特征值求解器（`numpy.linalg.eig`）从矩阵 $A_P$ 计算得出。这个选择至关重要，因为即使 $A$ 和 $P$ 是对称的，乘积 $P^{-1} A P$ 通常也不是对称的，而且数值误差无论如何都可能引入非对称部分。通用求解器能正确处理这种情况。\n\n第四，为确保有效比较，所有计算出的特征值数组（$\\lambda_{\\mathrm{ref}}$、$\\lambda_{Q}$ 以及 $\\lambda_{P}$ 的实部）都按升序排序。请注意，由于数值不稳定性，$\\lambda_{P}$ 可能包含虚假的非零虚部，因此比较的重点是实部的偏差。\n\n第五，程序量化 $\\lambda_Q$ 和 $\\lambda_P$ 相对于参考谱 $\\lambda_{\\mathrm{ref}}$ 的准确性。这是通过相对2-范数误差函数完成的：\n$$\n\\mathrm{rel\\_err}(\\lambda_{\\mathrm{ref}}, \\lambda_{\\mathrm{comp}}) = \\frac{\\lVert \\mathrm{Re}(\\lambda_{\\mathrm{comp}}) - \\lambda_{\\mathrm{ref}} \\rVert_{2}}{\\max\\left(\\lVert \\lambda_{\\mathrm{ref}} \\rVert_{2}, \\varepsilon\\right)}\n$$\n这里，$\\lambda_{\\mathrm{comp}}$ 是计算出的谱（$\\lambda_Q$ 或 $\\lambda_P$），$\\mathrm{Re}(\\cdot)$ 表示实部，$\\lVert \\cdot \\rVert_2$ 是欧几里得范数，$\\varepsilon$ 是机器ε，用于对分母进行正则化以防止除以零。\n\n最后，程序为每个测试用例计算比率 $r$：\n$$\nr = \\frac{\\mathrm{rel\\_err}(\\lambda_{\\mathrm{ref}}, \\lambda_{P})}{\\max\\left(\\mathrm{rel\\_err}(\\lambda_{\\mathrm{ref}}, \\lambda_{Q}), \\varepsilon\\right)}\n$$\n该比率直接比较了病态变换与稳定正交变换所产生的误差。$r \\gg 1$ 的值提供了定量证据，表明病态相似变换导致计算出的特征值精度显著下降。这四个测试用例旨在不同条件下探究此现象：一个通用情况（情况1），一个两种变换均为单位矩阵的良性基线（情况2，作为对照组），一个对具有良好分离谱的矩阵应用病态变换的情况（情况3），以及一个涉及数值上具有挑战性（病态）的矩阵 $A$ 本身的情况（情况4）。情况2的预期结果是 $r \\approx 1$，而其他情况预计会产生较大的 $r$ 值。最终输出是这四个计算出的比率的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs a numerical experiment to compare eigenvalue accuracy under\n    orthogonal vs. ill-conditioned similarity transformations.\n    \"\"\"\n    \n    eps = np.finfo(float).eps\n\n    def calc_rel_err(lambda_ref, lambda_comp):\n        \"\"\"\n        Calculates the relative 2-norm error of computed eigenvalues.\n        \"\"\"\n        # Per problem spec, use real part of computed eigenvalues for comparison.\n        lambda_comp_real = np.real(lambda_comp)\n        \n        # Eigenvalues must be sorted for a meaningful element-wise comparison.\n        # np.linalg.eigh already returns sorted real eigenvalues.\n        # np.linalg.eig returns unsorted complex eigenvalues.\n        lambda_ref_sorted = np.sort(lambda_ref)\n        lambda_comp_sorted = np.sort(lambda_comp_real)\n        \n        norm_diff = np.linalg.norm(lambda_comp_sorted - lambda_ref_sorted)\n        norm_ref = np.linalg.norm(lambda_ref_sorted)\n        \n        return norm_diff / max(norm_ref, eps)\n\n    # Define test cases using a list of dictionaries for clarity.\n    test_case_params = [\n        {'id': 1},\n        {'id': 2},\n        {'id': 3},\n        {'id': 4},\n    ]\n\n    results = []\n\n    for params in test_case_params:\n        case_id = params['id']\n\n        # Construct matrices A, Q, P for each case\n        if case_id == 1:\n            # Case 1: General \"happy path\"\n            n = 6\n            seed_A = 0\n            seed_Q = 0\n            \n            rng_A = np.random.default_rng(seed_A)\n            M = rng_A.standard_normal((n, n))\n            A = (M + M.T) / 2\n            \n            rng_Q = np.random.default_rng(seed_Q)\n            M_Q = rng_Q.standard_normal((n, n))\n            Q, _ = np.linalg.qr(M_Q)\n            \n            P = np.diag(np.geomspace(1e-4, 1e4, n))\n\n        elif case_id == 2:\n            # Case 2: Boundary/baseline condition\n            n = 10\n            \n            A = np.diag(2 * np.ones(n)) - np.diag(np.ones(n-1), k=1) - np.diag(np.ones(n-1), k=-1)\n            Q = np.eye(n)\n            P = np.eye(n)\n\n        elif case_id == 3:\n            # Case 3: Ill-conditioned transformation, well-separated spectrum\n            n = 8\n            seed_S = 1\n            seed_Q = 2\n\n            A_diag = np.arange(1, n + 1, dtype=float)\n            rng_S = np.random.default_rng(seed_S)\n            M_S = rng_S.standard_normal((n, n))\n            S = (M_S + M_S.T) / 2\n            A = np.diag(A_diag) + 1e-6 * S\n\n            rng_Q = np.random.default_rng(seed_Q)\n            M_Q = rng_Q.standard_normal((n, n))\n            Q, _ = np.linalg.qr(M_Q)\n\n            P = np.diag(np.geomspace(1e-6, 1e6, n))\n\n        elif case_id == 4:\n            # Case 4: Challenging A (Hilbert matrix), ill-conditioned P\n            n = 5\n            seed_Q = 3\n\n            # Construct Hilbert matrix using 1-based indexing as in formula\n            i = np.arange(1, n + 1).reshape(n, 1)\n            j = np.arange(1, n + 1).reshape(1, n)\n            A = 1.0 / (i + j - 1)\n\n            rng_Q = np.random.default_rng(seed_Q)\n            M_Q = rng_Q.standard_normal((n, n))\n            Q, _ = np.linalg.qr(M_Q)\n\n            P = np.diag(np.geomspace(1e-3, 1e3, n))\n\n        # Perform the transformations\n        A_Q = Q.T @ A @ Q\n        P_inv = np.linalg.inv(P)\n        A_P = P_inv @ A @ P\n    \n        # Compute eigenvalues\n        # Use symmetric solver for A and A_Q\n        lambda_ref = np.linalg.eigh(A)[0]\n        lambda_Q = np.linalg.eigh(A_Q)[0]\n        # Use general solver for A_P, which is not guaranteed to be symmetric\n        lambda_P = np.linalg.eig(A_P)[0]\n\n        # Calculate relative errors\n        err_Q = calc_rel_err(lambda_ref, lambda_Q)\n        err_P = calc_rel_err(lambda_ref, lambda_P)\n        \n        # Calculate the final ratio\n        r = err_P / max(err_Q, eps)\n        results.append(r)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3273813"}]}