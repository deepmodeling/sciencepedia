{"hands_on_practices": [{"introduction": "许多科学和工程领域的复杂系统，例如种群动态或化学反应，都是通过常微分方程组 (systems of ODEs) 来描述的。本练习 [@problem_id:3282760] 将经典的 Lotka-Volterra 竞争模型作为切入点，让你亲手实践如何将一个基础的数值求解器（如四阶龙格-库塔法）应用于向量值问题。通过解决这个问题，你不仅能掌握求解 ODE 系统的核心编程技巧，还能学会如何将数值结果与模型背后的科学情境（如物种共存或灭绝）联系起来。", "problem": "考虑一个由常微分方程组（ODEs）表示的双物种竞争模型的初值问题（IVP）。设 $x(t)$ 和 $y(t)$ 表示两个竞争物种在时间 $t$ 的非负密度。经典的 Lotka–Volterra 竞争模型通过以下方程描述其动力学：\n$$\n\\frac{dx}{dt} = x\\left(r_1 - a_{11} x - a_{12} y\\right), \\quad\n\\frac{dy}{dt} = y\\left(r_2 - a_{21} x - a_{22} y\\right),\n$$\n初始条件为 $x(0) = x_0$ 和 $y(0) = y_0$。此处，$r_1$ 和 $r_2$ 是内禀增长率，$a_{11}, a_{22}$ 是种内竞争系数，而 $a_{12}, a_{21}$ 是种间竞争系数。\n\n从常微分方程（ODEs）的初值问题（IVP）的定义出发，使用固定步长的显式四阶龙格-库塔方法为上述系统实现一个数值求解器。您必须：\n- 对所有 $t \\ge 0$，将状态向量 $(x,y)$ 视为非负；如果由于离散化误差，数值更新产生了负分量，您必须在每个时间步之后立即通过将其替换为 $0$ 来将其投影回非负象限。\n- 使用均匀时间步长 $h$ 从 $t=0$ 积分到 $t=T$，其中 $T$ 和 $h$ 的值如下所给。\n- 使用阈值 $\\varepsilon$ 对 $t=T$ 时的长期结果进行分类，规则如下：\n  - 如果 $x(T) > \\varepsilon$ 和 $y(T) > \\varepsilon$（共存），则输出 $2$。\n  - 如果 $x(T) > \\varepsilon$ 和 $y(T) \\le \\varepsilon$（物种 $x$ 存续，物种 $y$ 灭绝），则输出 $1$。\n  - 如果 $x(T) \\le \\varepsilon$ 和 $y(T) > \\varepsilon$（物种 $y$ 存续，物种 $x$ 灭绝），则输出 $-1$。\n  - 如果 $x(T) \\le \\varepsilon$ 和 $y(T) \\le \\varepsilon$（两者都灭绝），则输出 $0$。\n\n对所有测试用例使用以下数值参数：\n- 最终时间 $T = 60$。\n- 时间步长 $h = 0.01$。\n- 阈值 $\\varepsilon = 10^{-8}$。\n\n测试套件包含五组参数 $(r_1,r_2,a_{11},a_{12},a_{21},a_{22},x_0,y_0)$，用于探究不同的动力学机制：\n1. 一个在中等初始密度下预期会产生共存的案例：\n   - $r_1 = 1.0$, $r_2 = 1.2$, $a_{11} = 1.0$, $a_{12} = 0.3$, $a_{21} = 0.5$, $a_{22} = 1.0$, $x_0 = 0.2$, $y_0 = 0.2$。\n2. 一个对物种 $x$ 的种间压力足够强以致其被排斥的案例：\n   - $r_1 = 1.0$, $r_2 = 1.0$, $a_{11} = 1.0$, $a_{12} = 1.4$, $a_{21} = 0.3$, $a_{22} = 1.0$, $x_0 = 0.6$, $y_0 = 0.6$。\n3. 一个对物种 $y$ 的种间压力足够强以致其被排斥的案例：\n   - $r_1 = 1.0$, $r_2 = 1.0$, $a_{11} = 1.0$, $a_{12} = 0.4$, $a_{21} = 1.3$, $a_{22} = 1.0$, $x_0 = 0.4$, $y_0 = 0.7$。\n4. 一个两个物种的内禀增长率均为负（都趋于灭绝）的案例：\n   - $r_1 = -0.3$, $r_2 = -0.2$, $a_{11} = 1.0$, $a_{12} = 0.3$, $a_{21} = 0.5$, $a_{22} = 1.0$, $x_0 = 0.5$, $y_0 = 0.5$。\n5. 一个其中一个初始种群恰好为零的边界案例：\n   - $r_1 = 1.0$, $r_2 = 1.2$, $a_{11} = 1.0$, $a_{12} = 0.3$, $a_{21} = 0.5$, $a_{22} = 1.0$, $x_0 = 0.3$, $y_0 = 0.0$。\n\n您的程序应生成单行输出，其中包含五个测试用例的分类结果，格式为一个由方括号括起来的逗号分隔列表，例如 $[c_1,c_2,c_3,c_4,c_5]$，其中每个 $c_i$ 是为测试用例 $i$ 在 $t=T$ 时计算出的整数分类代码。", "solution": "所提出的问题是常微分方程（ODEs）数值分析领域中一个有效的初值问题（IVP）。它在科学上基于已建立的 Lotka–Volterra 竞争模型，提供了所有必要的参数和条件，是适定的，并且是客观且计算上可行的。因此，我们可以着手求解。\n\n问题的核心是确定双物种竞争的长期结果，该竞争由以下自治常微分方程组建模：\n$$\n\\begin{align*}\n\\frac{dx}{dt} = x(t) \\left(r_1 - a_{11} x(t) - a_{12} y(t)\\right) \\\\\n\\frac{dy}{dt} = y(t) \\left(r_2 - a_{21} x(t) - a_{22} y(t)\\right)\n\\end{align*}\n$$\n其中 $x(t)$ 和 $y(t)$ 是两个物种在时间 $t$ 的种群密度。该系统受初始条件 $x(0) = x_0$ 和 $y(0) = y_0$ 的约束。这组方程和初始条件构成了此初值问题（IVP）。\n\n为了简洁和便于计算实现，我们使用向量 $\\vec{u}(t) = \\begin{pmatrix} x(t) \\\\ y(t) \\end{pmatrix}$ 来表示系统的状态。该初值问题（IVP）可以写成紧凑形式：\n$$\n\\frac{d\\vec{u}}{dt} = \\vec{F}(\\vec{u}(t)), \\quad \\vec{u}(0) = \\vec{u}_0 = \\begin{pmatrix} x_0 \\\\ y_0 \\end{pmatrix}\n$$\n其中函数 $\\vec{F}: \\mathbb{R}^2 \\to \\mathbb{R}^2$ 是常微分方程组的右侧：\n$$\n\\vec{F}(\\vec{u}) = \\begin{pmatrix} x(r_1 - a_{11} x - a_{12} y) \\\\ y(r_2 - a_{21} x - a_{22} y) \\end{pmatrix}\n$$\n由于这个非线性系统通常不具有闭合形式的解析解，我们必须采用数值方法来近似解轨道 $\\vec{u}(t)$ 在区间 $[0, T]$ 上的值。问题指定使用固定时间步长 $h$ 的显式四阶龙格-库塔（RK4）方法。\n\nRK4 方法在给定时间 $t_n = nh$ 的近似值 $\\vec{u}_n$ 的情况下，迭代计算时间 $t_{n+1} = (n+1)h$ 时真实解 $\\vec{u}(t_{n+1})$ 的近似值 $\\vec{u}_{n+1}$。对于自治系统，更新规则是：\n$$\n\\vec{u}_{n+1} = \\vec{u}_n + \\frac{h}{6}(\\vec{k}_1 + 2\\vec{k}_2 + 2\\vec{k}_3 + \\vec{k}_4)\n$$\n四个中间“斜率”$\\vec{k}_i$ 是函数 $\\vec{F}$ 在时间步内不同点的求值，它们形成一个加权平均，从而达到四阶精度：\n$$\n\\begin{align*}\n\\vec{k}_1 = \\vec{F}(\\vec{u}_n) \\\\\n\\vec{k}_2 = \\vec{F}(\\vec{u}_n + \\frac{h}{2}\\vec{k}_1) \\\\\n\\vec{k}_3 = \\vec{F}(\\vec{u}_n + \\frac{h}{2}\\vec{k}_2) \\\\\n\\vec{k}_4 = \\vec{F}(\\vec{u}_n + h\\vec{k}_3)\n\\end{align*}\n\n该生物模型的一个关键特征是种群密度不能为负。尽管具有非负初始数据的 Lotka–Volterra 方程的精确解保持非负，但数值方法中的离散化误差有时可能导致出现小的负值。为了强制执行这一物理约束，问题要求进行一个投影步骤。在每个时间步计算之后，计算出的状态向量 $\\vec{u}_{n+1}$ 中的任何负分量都必须设置为 $0$。如果我们让 $\\vec{u}_{n+1}^{\\text{raw}}$ 表示由 RK4 公式得到的结果，则投影后的状态为：\n$$\n\\vec{u}_{n+1} = \\begin{pmatrix} x_{n+1} \\\\ y_{n+1} \\end{pmatrix} = \\begin{pmatrix} \\max(0, x_{n+1}^{\\text{raw}}) \\\\ \\max(0, y_{n+1}^{\\text{raw}}) \\end{pmatrix}\n$$\n\n解决该问题的整体算法如下：\n1.  对于五个测试用例中的每一个，设置特定的模型参数 $(r_1, r_2, a_{11}, a_{12}, a_{21}, a_{22})$ 和初始条件 $(x_0, y_0)$。\n2.  初始化状态向量 $\\vec{u}_0 = \\begin{pmatrix} x_0 \\\\ y_0 \\end{pmatrix}$。\n3.  设置数值参数：最终时间 $T = 60$，时间步长 $h = 0.01$。所需的步数为 $N = T/h = 6000$。\n4.  从 $n = 0$ 迭代到 $N-1$：\n    a. 使用当前状态 $\\vec{u}_n$ 计算四个 RK4 阶段 $\\vec{k}_1, \\vec{k}_2, \\vec{k}_3, \\vec{k}_4$。\n    b. 使用 RK4 更新公式计算原始的下一状态 $\\vec{u}_{n+1}^{\\text{raw}}$。\n    c. 应用非负性投影以获得该步骤的最终状态 $\\vec{u}_{n+1}$。\n5.  经过 $N$ 步后，最终状态为 $\\vec{u}_N \\approx \\vec{u}(T) = \\begin{pmatrix} x(T) \\\\ y(T) \\end{pmatrix}$。\n6.  根据 $\\vec{u}_N$ 的分量和阈值 $\\varepsilon = 10^{-8}$ 对结果进行分类：\n    - 如果 $x(T) > \\varepsilon$ 且 $y(T) > \\varepsilon$，结果是共存（代码 $2$）。\n    - 如果 $x(T) > \\varepsilon$ 且 $y(T) \\le \\varepsilon$，物种 $x$ 存续（代码 $1$）。\n    - 如果 $x(T) \\le \\varepsilon$ 且 $y(T) > \\varepsilon$，物种 $y$ 存续（代码 $-1$）。\n    - 如果 $x(T) \\le \\varepsilon$ 且 $y(T) \\le \\varepsilon$，两个物种都灭绝（代码 $0$）。\n\n然后将此过程应用于五个不同的参数集中的每一个，以生成最终的分类代码列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Lotka-Volterra competition model for five test cases\n    using the RK4 method and classifies the long-term outcome.\n    \"\"\"\n    # Numerical parameters for all test cases\n    T = 60.0\n    h = 0.01\n    epsilon = 1e-8\n\n    # The test suite comprises five parameter sets:\n    # (r1, r2, a11, a12, a21, a22, x0, y0)\n    test_cases = [\n        # 1. Expected coexistence\n        (1.0, 1.2, 1.0, 0.3, 0.5, 1.0, 0.2, 0.2),\n        # 2. Species x is excluded\n        (1.0, 1.0, 1.0, 1.4, 0.3, 1.0, 0.6, 0.6),\n        # 3. Species y is excluded\n        (1.0, 1.0, 1.0, 0.4, 1.3, 1.0, 0.4, 0.7),\n        # 4. Both species go extinct\n        (-0.3, -0.2, 1.0, 0.3, 0.5, 1.0, 0.5, 0.5),\n        # 5. One initial population is zero\n        (1.0, 1.2, 1.0, 0.3, 0.5, 1.0, 0.3, 0.0),\n    ]\n\n    def lotka_volterra_rhs(u, p):\n        \"\"\"\n        Computes the right-hand side of the Lotka-Volterra ODE system.\n        \n        Args:\n            u (np.ndarray): State vector [x, y].\n            p (tuple): Model parameters (r1, r2, a11, a12, a21, a22).\n        \n        Returns:\n            np.ndarray: The derivatives [dx/dt, dy/dt].\n        \"\"\"\n        x, y = u\n        r1, r2, a11, a12, a21, a22 = p\n        dxdt = x * (r1 - a11 * x - a12 * y)\n        dydt = y * (r2 - a21 * x - a22 * y)\n        return np.array([dxdt, dydt])\n\n    results = []\n    num_steps = int(T / h)\n\n    for case in test_cases:\n        r1, r2, a11, a12, a21, a22, x0, y0 = case\n        params = (r1, r2, a11, a12, a21, a22)\n        \n        u = np.array([x0, y0], dtype=np.float64)\n\n        # Time-stepping loop using RK4\n        for _ in range(num_steps):\n            k1 = lotka_volterra_rhs(u, params)\n            k2 = lotka_volterra_rhs(u + 0.5 * h * k1, params)\n            k3 = lotka_volterra_rhs(u + 0.5 * h * k2, params)\n            k4 = lotka_volterra_rhs(u + h * k3, params)\n            \n            u_raw = u + (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n            # Project to non-negative orthant\n            u = np.maximum(0.0, u_raw)\n        \n        xT, yT = u\n        \n        # Classify the outcome at t=T\n        classification_code = 0\n        if xT > epsilon and yT > epsilon:\n            classification_code = 2  # Coexistence\n        elif xT > epsilon and yT = epsilon:\n            classification_code = 1  # Species x persists\n        elif xT = epsilon and yT > epsilon:\n            classification_code = -1 # Species y persists\n        else: # xT = epsilon and yT = epsilon\n            classification_code = 0  # Both extinct\n            \n        results.append(classification_code)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3282760"}, {"introduction": "在我们成功地将数值方法应用于一个实际模型后，一个自然而然的问题是：为什么这些方法有效？数值方法的可靠性取决于其收敛性，即当步长趋于零时，数值解是否能趋近于真实的解析解。这个练习 [@problem_id:3282744] 提供了一个极具启发性的反例，它将分析一个虽然满足零稳定性但却不具备一致性的线性多步法。通过亲手实现并观察这个方法如何在最简单的初值问题上失效，你将深刻理解 Dahlquist 等价定理中一致性与零稳定性对于收敛的缺一不可的关键作用。", "problem": "您将在常微分方程 (ODEs) 和初值问题 (IVP) 的框架内使用数值方法进行工作。考虑一个应用于标量 ODE $y'(t) = f(t,y(t))$（其初始数据为 $y(t_0) = y_0$）的初值问题的线性多步法 (LMM)。一个 $k$ 步 LMM 具有以下一般形式：$$\\sum_{j=0}^{k} \\alpha_j y_{n+j} = h \\sum_{j=0}^{k} \\beta_j f_{n+j},$$ 其中 $h$ 是均匀时间步长，$f_{n+j} := f(t_{n+j}, y_{n+j})$，且系数 $\\alpha_j$、$\\beta_j$ 是与 $n$ 无关的常数，并满足 $\\alpha_k \\neq 0$。其特征多项式为 $$\\rho(\\xi) = \\sum_{j=0}^{k} \\alpha_j \\xi^j.$$ 如果 $\\rho(\\xi)$ 的每个根的模至多为 $1$，且任何在单位圆上的根的重数为 $1$，则该方法称为零点稳定。如果一个方法的局部截断误差随 $h$ 趋于零，则该方法是相容的。一组必要的相容性条件是 $\\sum_{j=0}^{k} \\alpha_j = 0$ 和 $\\sum_{j=0}^{k} j \\alpha_j = \\sum_{j=0}^{k} \\beta_j$。根据 Dahlquist 等价定理，一个线性多步法是收敛的，当且仅当它既是零点稳定的又是相容的。\n\n您的任务是：\n\n1) 构建由 $$y_{n+1} - y_n = 0,$$ 定义的特定线性多步法，即系数为 $\\alpha_0 = -1$, $\\alpha_1 = 1$ 和 $\\beta_0 = \\beta_1 = 0$。使用上述基本定义，证明该方法满足根条件（零点稳定性），但违反了必要的相容性条件，因此根据 Dahlquist 等价定理是不收敛的。\n\n2) 将此方法应用于区间 $[0,1]$ 上的 IVP $$y'(t) = -y(t), \\quad y(0) = 1,$$，使用均匀步长 $h$。对于每个步长，计算在 $t=1$ 处的数值近似解 $y_N$（其中 $N = 1/h$，因为 $h$ 的选择能精确地划分 $[0,1]$）以及绝对全局误差 $$E(h) = \\left|y_N - y(1)\\right|,$$ 其中 $y(1)$ 是在 $t=1$ 处计算的精确解。\n\n3) 实现一个完整、可运行的程序，对以下步长测试集 $h \\in \\{\\, 1.0,\\, 0.5,\\, 0.2,\\, 0.1,\\, 0.01 \\,\\}$ 执行第 2 项中的计算。这些值测试了一个粗网格 ($h = 1.0$)、中等细化网格 ($h = 0.5$, $h = 0.2$, $h = 0.1$) 和一个相对精细的网格 ($h = 0.01$)。所有步长的选择都使得 $N = 1/h$ 为整数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表应按上述顺序包含每个测试用例的绝对全局误差 $E(h)$。例如，输出必须具有以下形式：$$[E(1.0),E(0.5),E(0.2),E(0.1),E(0.01)]。$$ 不应打印任何额外文本。", "solution": "所提出的问题是常微分方程数值分析中的一个有效练习。它在科学上基于已建立的理论，是适定的，并包含完整解答所需的所有必要信息和定义。因此，我们将进行全面分析。\n\n该问题要求对一个特定的线性多步法 (LMM) 进行分析和数值应用。其框架是标量 ODE 的初值问题 (IVP)：\n$$\ny'(t) = f(t, y(t)), \\quad y(t_0) = y_0\n$$\n\n一个通用的 $k$ 步 LMM 由以下公式给出：\n$$\n\\sum_{j=0}^{k} \\alpha_j y_{n+j} = h \\sum_{j=0}^{k} \\beta_j f_{n+j}\n$$\n\n分析的关键在于零点稳定性和相容性的概念，根据 Dahlquist 等价定理，这两个概念共同决定了收敛性。\n\n**第1部分：线性多步法的分析**\n\n需要分析的特定方法由以下公式给出：\n$$\ny_{n+1} - y_n = 0\n$$\n\n这是一个 $k=1$ 步的方法。为确定其系数，我们将其与一般的 $1$ 步形式进行比较：\n$$\n\\alpha_1 y_{n+1} + \\alpha_0 y_n = h (\\beta_1 f_{n+1} + \\beta_0 f_n)\n$$\n\n通过直接比较，我们确定系数如下：\n- $\\alpha_1 = 1$\n- $\\alpha_0 = -1$\n- $\\beta_1 = 0$\n- $\\beta_0 = 0$\n注意，按要求 $\\alpha_k = \\alpha_1 = 1 \\neq 0$。\n\n**零点稳定性（根条件）：**\n零点稳定性由第一特征多项式 $\\rho(\\xi)$ 的根决定：\n$$\n\\rho(\\xi) = \\sum_{j=0}^{k} \\alpha_j \\xi^j\n$$\n对于我们 $k=1$ 的方法，该多项式为：\n$$\n\\rho(\\xi) = \\alpha_0 \\xi^0 + \\alpha_1 \\xi^1 = -1 + 1 \\cdot \\xi = \\xi - 1\n$$\n$\\rho(\\xi) = 0$ 的根通过求解 $\\xi - 1 = 0$ 得到，这产生一个单根 $\\xi_1 = 1$。\n\n根据定义，如果 $\\rho(\\xi)$ 的所有根的模都小于或等于 $1$，且任何模等于 $1$ 的根都是单根（即重数为 $1$），则该方法是零点稳定的。\n- 我们的根的模为 $|\\xi_1| = |1| = 1$。这满足模条件。\n- 根 $\\xi_1 = 1$ 的重数为 $1$。这满足单位圆上根的单根性条件。\n因此，该方法是 **零点稳定的**。\n\n**相容性：**\n如果一个方法的局部截断误差随着步长 $h \\to 0$ 趋于零，则该方法是相容的。相容性的一组必要条件是：\n1. $\\sum_{j=0}^{k} \\alpha_j = 0$\n2. $\\sum_{j=0}^{k} j \\alpha_j = \\sum_{j=0}^{k} \\beta_j$\n\n让我们检查我们的方法是否满足这些条件：\n1. $\\sum_{j=0}^{1} \\alpha_j = \\alpha_0 + \\alpha_1 = -1 + 1 = 0$。第一个条件 **满足**。\n\n2. 对于第二个条件，我们分别计算左侧 (LHS) 和右侧 (RHS)。\n   - LHS: $\\sum_{j=0}^{1} j \\alpha_j = (0 \\cdot \\alpha_0) + (1 \\cdot \\alpha_1) = (0 \\cdot -1) + (1 \\cdot 1) = 1$。\n   - RHS: $\\sum_{j=0}^{1} \\beta_j = \\beta_0 + \\beta_1 = 0 + 0 = 0$。\n由于 LHS $= 1$ 而 RHS $= 0$，我们有 $1 \\neq 0$。第二个相容性的必要条件 **不满足**。\n\n**关于收敛性的结论：**\nDahlquist 等价定理指出，一个 LMM 是收敛的当且仅当它既是零点稳定的又是相容的。我们的分析表明，方法 $y_{n+1} - y_n = 0$ 是零点稳定的但不是相容的。因此，根据该定理，此方法是 **不收敛的**。\n\n**第2部分：应用于初值问题**\n\n我们现在将这个不收敛的方法应用于特定的 IVP：\n$$\ny'(t) = -y(t), \\quad y(0) = 1\n$$\n在区间 $[0,1]$ 上，使用均匀步长 $h$。\n\n数值格式为 $y_{n+1} - y_n = 0$，可以重写为迭代公式：\n$$\ny_{n+1} = y_n\n$$\n这个公式表明，下一步的值就是当前步的值。值得注意的是，该公式不涉及函数 $f(t,y) = -y$ 或步长 $h$，因为所有的 $\\beta_j$ 系数都为零。\n\n计算过程如下：\n- 初始条件给出 $y_0 = 1$。\n- 对于 $n=0$: $y_1 = y_0 = 1$。\n- 对于 $n=1$: $y_2 = y_1 = 1$。\n- ...\n- 对于任何步 $n$，我们都有 $y_{n+1} = 1$。\n\n任务是找到在 $t_N = 1$ 处的数值近似解 $y_N$，其中 $N=1/h$。不论 $h$ 的值（以及因此 $N$ 的值）是多少，数值解将始终是：\n$$\ny_N = 1\n$$\n\nIVP $y' = -y$, $y(0)=1$ 的精确解可以通过分离变量法找到，得到 $y(t) = e^{-t}$。因此，在 $t=1$ 处的精确值为：\n$$\ny(1) = e^{-1}\n$$\n\n在 $t=1$ 处的绝对全局误差定义为 $E(h) = |y_N - y(1)|$。代入我们的值：\n$$\nE(h) = |1 - e^{-1}|\n$$\n这个误差是一个常数，与步长 $h$ 无关。误差不随 $h \\to 0$ 而减小这一事实，直接从数值上证实了该方法是不收敛的。对于任何指定的步长 $h \\in \\{1.0, 0.5, 0.2, 0.1, 0.01\\}$，误差将完全相同。\n\n**第3部分：实现**\n\n程序将计算这个恒定的误差值 $|1 - e^{-1}|$，并构建一个列表，其中包含为每个指定步长重复的该值。$e^{-1}$ 的值约为 $0.36787944117$。误差 $E(h)$ 约为 $|1 - 0.36787944117| = 0.63212055882$。程序将生成一个列表，其中每个元素都是这个值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes a non-convergent linear multistep method for a given IVP.\n\n    The method y_{n+1} - y_n = 0 is applied to y'(t) = -y(t) with y(0) = 1.\n    The iteration is simply y_{n+1} = y_n. Starting with y_0 = 1, the numerical\n    solution at any time step is always 1, i.e., y_N = 1.\n\n    The exact solution is y(t) = exp(-t), so y(1) = exp(-1).\n\n    The absolute global error E(h) = |y_N - y(1)| is thus |1 - exp(-1)|, which\n    is a constant value independent of the step size h. This demonstrates\n    the method's lack of convergence.\n    \"\"\"\n    # Define the test cases for the step size h, as per the problem statement.\n    test_cases_h = [1.0, 0.5, 0.2, 0.1, 0.01]\n\n    # Calculate the exact solution at t=1.\n    # The ODE is y' = -y, with y(0) = 1. The solution is y(t) = exp(-t).\n    exact_y_at_1 = np.exp(-1)\n\n    # For the method y_{n+1} - y_n = 0, the numerical update is y_{n+1} = y_n.\n    # Given y_0 = 1, the numerical solution at any step n is y_n = 1.\n    # Therefore, the approximation at t=1 is y_N = 1, regardless of N (or h).\n    numerical_y_at_1 = 1.0\n\n    # The absolute global error is E(h) = |y_N - y(1)|.\n    # This value is constant for all h because the numerical method ignores\n    # the ODE's dynamics and the step size entirely.\n    constant_error = abs(numerical_y_at_1 - exact_y_at_1)\n\n    # Since the error is the same for all h, we construct the results list\n    # by repeating the constant error for each test case.\n    results = [constant_error for _ in test_cases_h]\n\n    # Final print statement in the exact required format.\n    # The output is a comma-separated list of the error values enclosed in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3282744"}, {"introduction": "真实的物理系统常常包含不连续性，例如物体碰撞或状态切换，这些“事件”对标准的固定步长积分器构成了挑战。为了精确高效地处理这类问题，现代 ODE 求解器普遍集成了事件检测功能。本练习 [@problem_id:3282603] 将指导你构建一个更为复杂的求解器，用于模拟一个带阻尼的弹跳球，它融合了自适应步长控制、用于精确定位撞击时刻的根查找算法，以及事件发生后的状态重置与积分重启。这个综合性实践将让你体验到如何将基础的数值方法组合成一个能够应对混合动态系统的强大工具。", "problem": "您将设计并实现一个完整的数值初值问题 (IVP) 求解器，用于处理一维弹跳球问题，该求解器需包含事件检测功能，并在每次碰撞后重新启动。其目标是精确检测球体撞击地面的事件时间，施加恢复系数，然后用碰撞后的速度重新开始积分。该场景遵循牛顿力学，并被表述为一个常微分方程 (ODE) 初值问题。您必须从基本原理推导您的方法，然后将其实现为一个正确且鲁棒的程序。\n\n物理设置如下。考虑一个质点球在重力和线性空气阻力作用下进行垂直运动。设 $y(t)$ 为垂直位置，$v(t)$ 为垂直速度。支配运动的力平衡是牛顿第二定律：$m \\,\\mathrm{d}v/\\mathrm{d}t = \\sum F$，其中重力为 $-m g$，线性阻力为 $-b v$。定义单位质量的阻力参数 $\\gamma = b/m$。该连续时间模型是一个一阶系统\n$\n\\frac{\\mathrm{d}y}{\\mathrm{d}t} = v,\\quad\n\\frac{\\mathrm{d}v}{\\mathrm{d}t} = -g - \\gamma v,\n$\n初始条件为 $y(0)=y_0$ 和 $v(0)=v_0$。当 $y(t)=0$ 且球体向下运动时，发生撞地事件。在碰撞时间 $t_e$，碰撞前速度为 $v(t_e^-)$，则碰撞后速度由牛顿恢复定律给出：$v(t_e^+) = - r \\, v(t_e^-)$，其中恢复系数 $r \\in [0,1]$。位置保持连续，$y(t_e^+)=0$。\n\n您的程序必须：\n- 从 $t=0$ 开始向前积分系统，使用一种基于标准显式 Runge–Kutta 方法的固定推导积分器设计。使用经典的四阶 Runge–Kutta 方法 (RK4) 作为基本的时间推进方案。通过步长加倍法控制局部截断误差：将一个大小为 $h$ 的步长与两个大小为 $h/2$ 的步长进行比较，以获得误差估计。根据用户指定的绝对容差和相对容差来接受或拒绝步长，并相应地调整 $h$ 以保持稳定性和准确性。\n- 通过框定在接受步长内 $y(t)$ 的符号变化来检测撞地事件。当事件被框定时，使用时间上的二分法对 $y(t)$ 进行求根，以精化事件时间 $t_e$。在精化过程中，每次对 $y(t)$ 的求值都必须通过使用 RK4 子步将常微分方程从左边界数值传播到查询时间来计算。当时间区间的宽度低于一个小的绝对阈值且高度的绝对值低于一个小的绝对阈值时，精化过程应停止。\n- 在 $t_e$ 时应用恢复定律，将状态重置为 $y(t_e)=0$ 和 $v(t_e) = - r \\, v(t_e^-)$，然后从此事件状态重新启动初值问题，继续积分。计算碰撞次数。如果在某次事件中，碰撞后的速度实际为零，您应停止进一步的积分，因为不会再发生碰撞。\n- 当达到指定的碰撞次数或达到指定的最大时间时，以先到者为准，终止积分。\n\n所有计算都必须使用一致的国际单位制 (SI)：$y$ 以米为单位，$v$ 以米/秒为单位，$g$ 以米/秒$^2$ 为单位，$\\gamma$ 以 1/秒为单位，时间以秒为单位。不使用角度。您的程序必须报告所请求的输出，单位为秒，四舍五入到六位小数。\n\n您必须提出并使用具体的数值容差：\n- 绝对容差 $\\mathrm{atol} = 10^{-12}$ (状态单位)。\n- 相对容差 $\\mathrm{rtol} = 10^{-9}$ (无量纲)。\n- 事件时间精化容差 $\\delta t = 10^{-10}$ 秒，事件高度容差 $\\delta y = 10^{-12}$ 米。\n这些调整必须用于所有测试用例。\n\n测试套件规范。对于下面的每个测试用例，运行您的求解器直到第 $K$ 次碰撞（如果它在最大时间 $T_{\\max}$ 之前发生），并返回第 $K$ 次碰撞的时间 $t_K$，单位为秒，四舍五入到六位小数。\n\n- 测试用例 A (正常路径，无阻力):\n  - 参数: $y_0 = 10.0$ m, $v_0 = 0.0$ m/s, $g = 9.81$ m/s$^2$, $\\gamma = 0.0$ s$^{-1}$, $r = 0.8$, $K = 3$, $T_{\\max} = 30.0$ s.\n- 测试用例 B (有阻力，初始速度向上):\n  - 参数: $y_0 = 20.0$ m, $v_0 = 5.0$ m/s, $g = 9.81$ m/s$^2$, $\\gamma = 0.1$ s$^{-1}$, $r = 0.9$, $K = 2$, $T_{\\max} = 40.0$ s.\n- 测试用例 C (边界情况，从地面开始但向上运动):\n  - 参数: $y_0 = 0.0$ m, $v_0 = 5.0$ m/s, $g = 9.81$ m/s$^2$, $\\gamma = 0.0$ s$^{-1}$, $r = 0.6$, $K = 2$, $T_{\\max} = 20.0$ s.\n- 测试用例 D (边界情况，完全非弹性碰撞):\n  - 参数: $y_0 = 1.0$ m, $v_0 = 0.0$ m/s, $g = 9.81$ m/s$^2$, $\\gamma = 0.0$ s$^{-1}$, $r = 0.0$, $K = 1$, $T_{\\max} = 10.0$ s.\n\n最终输出格式。您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[resultA,resultB,resultC,resultD]\"）。具体来说，对于按 A、B、C、D 顺序排列的四个测试用例，输出 $[t_3^{(A)}, t_2^{(B)}, t_2^{(C)}, t_1^{(D)}]$，单位为秒，四舍五入到六位小数，无附加文本。", "solution": "我们基于物理原理和数值分析基础来构建求解器。物理基础是牛顿第二定律 $m \\,\\mathrm{d}v/\\mathrm{d}t = \\sum F$。对于有重力和线性阻力的垂直运动，力为 $-m g$ 和 $- b v$，因此 $m \\,\\mathrm{d}v/\\mathrm{d}t = -m g - b v$。引入 $\\gamma = b/m$ 得到 $\\mathrm{d}v/\\mathrm{d}t = -g - \\gamma v$。运动学恒等式 $\\mathrm{d}y/\\mathrm{d}t = v$ 闭合了一阶系统\n$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}\n\\begin{bmatrix}\ny \\\\ v\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nv \\\\\n- g - \\gamma v\n\\end{bmatrix},\n$\n初始状态为 $\\begin{bmatrix} y(0) \\\\ v(0) \\end{bmatrix} = \\begin{bmatrix} y_0 \\\\ v_0 \\end{bmatrix}$。\n\n当下降过程中到达地面 $y=0$ 时，事件发生：$y(t_e) = 0$ 且 $v(t_e^-)  0$。碰撞被建模为瞬时发生，位置连续 $y(t_e^+) = 0$，速度发生跳变 $v(t_e^+) = - r \\, v(t_e^-)$。对于 $r \\in [0,1]$，碰撞时能量减少；对于 $r=0$，运动在第一次碰撞时停止。\n\n我们必须设计一个求解器来积分初值问题 (IVP) 并精确检测事件时间。我们使用显式的四阶 Runge–Kutta 方法 (RK4)，对于光滑的右端函数，这是一个经过充分检验的积分器：\n$\n\\mathbf{k}_1 = f(t_n,\\mathbf{y}_n),\\;\n\\mathbf{k}_2 = f\\!\\left(t_n+\\tfrac{h}{2}, \\mathbf{y}_n + \\tfrac{h}{2}\\mathbf{k}_1\\right),\\;\n\\mathbf{k}_3 = f\\!\\left(t_n+\\tfrac{h}{2}, \\mathbf{y}_n + \\tfrac{h}{2}\\mathbf{k}_2\\right),\\;\n\\mathbf{k}_4 = f\\!\\left(t_n+h, \\mathbf{y}_n + h \\mathbf{k}_3\\right),\n$\n$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\tfrac{h}{6}\\left(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4\\right).\n$\n为了在不依赖预先制表的嵌入式对的情况下控制局部误差，我们应用步长加倍法：使用一个大小为 $h$ 的 RK4 步计算 $\\mathbf{y}^{(1)}$，以及使用两个大小为 $h/2$ 的 RK4 步计算 $\\mathbf{y}^{(2)}$。差值 $\\delta = \\|\\mathbf{y}^{(2)} - \\mathbf{y}^{(1)}\\|_{\\infty}$ 估算了局部截断误差。如果 $\\delta \\le \\mathrm{atol} + \\mathrm{rtol}\\,\\|\\mathbf{y}^{(2)}\\|_{\\infty}$，我们接受两个半步长的解；否则，我们拒绝并减小 $h$。在接受步长后，我们可以适度增加 $h$ 以提高效率，同时保持在容差范围内。\n\n事件检测处理如下。在每个从 $(t_n,\\mathbf{y}_n)$ 到 $(t_{n+1},\\mathbf{y}_{n+1})$ 的已接受步长之后，我们检查高度分量 $y$ 的符号。如果 $y_n > 0$ 且 $y_{n+1} \\le 0$，则一个事件被框定在 $[t_n,t_{n+1}]$ 内。然后我们通过对时间进行二分法来精化事件时间 $t_e$：\n- 维护一个左边界 $(t_L,\\mathbf{y}_L)$，其中 $y_L>0$，以及一个右边界 $(t_R,\\mathbf{y}_R)$，其中 $y_R \\le 0$。\n- 在每次精化迭代中，选择 $t_M=(t_L+t_R)/2$，并通过使用具有固定小数目子步长的 RK4 从 $(t_L,\\mathbf{y}_L)$ 数值传播到 $t_M$ 来计算 $\\mathbf{y}_M$，以确保准确性。如果 $y_M>0$，将左边界更新为 $(t_M,\\mathbf{y}_M)$；否则，将右边界更新为 $(t_M,\\mathbf{y}_M)$。\n- 当 $t_R-t_L \\le \\delta t$ 且 $|y_M| \\le \\delta y$ 时终止。精化后的事件时间为 $t_e \\approx t_R$，碰撞前状态为 $\\mathbf{y}(t_e^-)\\approx \\mathbf{y}_R$。\n在事件发生时，我们精确设置 $y(t_e)=0$ 并计算碰撞后速度 $v(t_e^+)=-r\\,v(t_e^-)$。从 $(t_e,[0, v(t_e^+)])$ 重新启动初值问题。如果碰撞后速度极小，例如 $|v(t_e^+)| \\le 10^{-12}$，我们停止后续积分，因为不会再发生未来的碰撞。\n\n正确性和一致性检查源于特殊情况下的基本解。在无阻力情况 $\\gamma=0$下，两次碰撞之间的运动是弹道运动，满足 $\\mathrm{d}^2 y/\\mathrm{d}t^2 = -g$。如果 $y_0>0$ 且 $v_0 \\ge 0$，第一次碰撞时间为\n$\nt_1 = \\frac{v_0 + \\sqrt{v_0^2 + 2 g y_0}}{g}.\n$\n设碰撞前速度为 $v_1^- = -(v_0 + g t_1)$。下一次飞行的上升和下降是对称的，给出两次碰撞之间的时间增量 $\\Delta t = 2 v_1^+/g$。如果 $\\gamma=0$，后续的碰撞在时间增量上形成一个几何序列，公比为 $r, r^2, \\dots$。我们的数值方法必须在容差范围内再现这些值。例如，在特殊情况 $y_0=0$ 和 $v_0>0$ 且 $\\gamma=0$ 时，第一次碰撞时间为 $t_1 = 2 v_0/g$，第二次为 $t_2 = t_1 + 2 r v_0/g$。\n\n在线性阻力 $\\gamma>0$ 存在的情况下，两次碰撞之间的解不再是对称的，且对于一般初始数据，两次碰撞之间的闭式解时间不能用初等函数简单表示。上述事件驱动的数值方法仍然适用且准确，因为右端函数是光滑的，且二分法精化使用由常微分方程本身定义的流映射，确保对 $y(t)=0$ 进行一致的求根。\n\n算法设计总结：\n- 使用 RK4 和步长加倍法进行自适应控制，容差为 $\\mathrm{atol}=10^{-12}$ 和 $\\mathrm{rtol}=10^{-9}$。\n- 通过在接受步长上 $y$ 的符号变化来检测事件。\n- 使用时间二分法和数值传播来精化事件时间，容差为 $\\delta t=10^{-10}$ s 和 $\\delta y=10^{-12}$ m。\n- 在每个事件中应用 $v^+ = - r v^-$，在事件点设置 $y=0$，然后重新启动。\n- 在达到第 $K$ 次碰撞或超过 $T_{\\max}$ 时终止。\n\n最终输出是测试套件所要求的事件时间，单位为秒，四舍五入到六位小数，并按指定顺序和格式聚合。此设计直接反映了常微分方程 (ODE) 的初值问题 (IVP) 公式，遵守物理定律，并通过有原则的误差控制和求根来确保数值鲁棒性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef dynamics(t, state, g, gamma):\n    # state = [y, v]\n    y, v = state\n    dy = v\n    dv = -g - gamma * v\n    return np.array([dy, dv], dtype=float)\n\ndef rk4_step(f, t, y, h, args):\n    k1 = f(t, y, *args)\n    k2 = f(t + 0.5*h, y + 0.5*h*k1, *args)\n    k3 = f(t + 0.5*h, y + 0.5*h*k2, *args)\n    k4 = f(t + h, y + h*k3, *args)\n    return y + (h/6.0)*(k1 + 2*k2 + 2*k3 + k4)\n\ndef rk4_step_doubling(f, t, y, h, args):\n    # One full step\n    y1 = rk4_step(f, t, y, h, args)\n    # Two half steps\n    y_half = rk4_step(f, t, y, 0.5*h, args)\n    y2 = rk4_step(f, t + 0.5*h, y_half, 0.5*h, args)\n    # Error estimate\n    err = np.max(np.abs(y2 - y1))\n    return y2, err\n\ndef integrate_segment(f, t0, y0, t1, args, nsub=12):\n    # Propagate from (t0, y0) to t1 using nsub RK4 substeps\n    t = t0\n    y = y0.copy()\n    dt = t1 - t0\n    if dt == 0.0:\n        return y\n    h = dt / float(nsub)\n    for _ in range(nsub):\n        y = rk4_step(f, t, y, h, args)\n        t += h\n    return y\n\ndef refine_event_bisection(f, tL, yL, tR, yR, args, tol_t, tol_y):\n    # Assumes yL[0] > 0 and yR[0] = 0\n    left_t = tL\n    left_y = yL.copy()\n    right_t = tR\n    right_y = yR.copy()\n    # Use bisection with numerical propagation from left\n    while (right_t - left_t) > tol_t:\n        mid_t = 0.5*(left_t + right_t)\n        # Propagate from left to mid\n        mid_y = integrate_segment(f, left_t, left_y, mid_t, args, nsub=12)\n        ymid = mid_y[0]\n        if abs(ymid) = tol_y:\n            # Close enough in height; choose mid as right bracket\n            right_t = mid_t\n            right_y = mid_y\n            break\n        if ymid > 0.0:\n            left_t = mid_t\n            left_y = mid_y\n        else:\n            right_t = mid_t\n            right_y = mid_y\n    # Ensure right_y corresponds to y = 0 (or near zero)\n    return right_t, right_y\n\ndef simulate_bouncing_ball(y0, v0, g, gamma, r, K, t_max,\n                           atol=1e-12, rtol=1e-9,\n                           event_tol_t=1e-10, event_tol_y=1e-12):\n    # Initial state\n    t = 0.0\n    y = np.array([y0, v0], dtype=float)\n    impacts = 0\n    impact_times = []\n\n    # Initial step size guess based on time scales\n    # Use a conservative initial step\n    h = 0.01\n    h_min = 1e-8\n    h_max = 0.2\n\n    # Helper for norm\n    def norm_inf(vec):\n        return float(np.max(np.abs(vec)))\n\n    # Main integration loop\n    while t  t_max and impacts  K:\n        # Adjust step not to overrun t_max\n        h = min(h, t_max - t)\n        if h  h_min:\n            h = h_min\n\n        # Take a trial step with error estimation\n        y_new, err = rk4_step_doubling(dynamics, t, y, h, (g, gamma))\n        ynew_val = y_new[0]\n        tol = atol + rtol * max(norm_inf(y_new), 1.0)\n\n        if err = tol or h = h_min*1.01:\n            # Accept step\n            t_new = t + h\n            # Event detection: look for crossing from y>0 to y=0\n            y_old_val = y[0]\n            if y_old_val > 0.0 and ynew_val = 0.0:\n                # Refine event time within [t, t_new]\n                yR = y_new.copy()\n                t_e, state_e_minus = refine_event_bisection(\n                    dynamics, t, y, t_new, yR, (g, gamma), event_tol_t, event_tol_y\n                )\n                # Compute post-impact state\n                v_minus = state_e_minus[1]\n                v_plus = -r * v_minus\n                # Register impact\n                impacts += 1\n                impact_times.append(t_e)\n                # Restart at event\n                t = t_e\n                y = np.array([0.0, v_plus], dtype=float)\n                # If the bounce has essentially zero speed, stop\n                if abs(v_plus) = 1e-12:\n                    break\n                # Reduce step after event to be safe\n                h = max(h_min*10, min(h*0.5, h_max))\n                continue\n            else:\n                # No event, advance\n                t = t_new\n                y = y_new\n                # Attempt to increase step slightly if error is small\n                if err  0.1 * tol:\n                    h = min(h * 1.5, h_max)\n                else:\n                    # Keep h or slightly reduce\n                    h = min(h, h_max)\n        else:\n            # Reject step and decrease h\n            # Scale h down; use a safety factor\n            factor = 0.5\n            h = max(h * factor, h_min)\n\n    # Return the time of the K-th impact if available; otherwise, return t_max.\n    if len(impact_times) >= K:\n        return impact_times[K-1]\n    else:\n        # In case the K-th impact did not occur, return t_max\n        return t_max\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (y0, v0, g, gamma, r, K, T_max)\n    test_cases = [\n        (10.0, 0.0, 9.81, 0.0, 0.8, 3, 30.0),  # A\n        (20.0, 5.0, 9.81, 0.1, 0.9, 2, 40.0),  # B\n        (0.0, 5.0, 9.81, 0.0, 0.6, 2, 20.0),   # C\n        (1.0, 0.0, 9.81, 0.0, 0.0, 1, 10.0),   # D\n    ]\n\n    results = []\n    for case in test_cases:\n        y0, v0, g, gamma, r, K, tmax = case\n        t_k = simulate_bouncing_ball(y0, v0, g, gamma, r, K, tmax)\n        results.append(t_k)\n\n    # Final print statement in the exact required format with six decimals.\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3282603"}]}