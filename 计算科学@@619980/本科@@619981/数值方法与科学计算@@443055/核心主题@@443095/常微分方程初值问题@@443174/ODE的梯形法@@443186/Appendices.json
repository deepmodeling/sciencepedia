{"hands_on_practices": [{"introduction": "梯形法的一个核心特征是其“隐式”性质，这意味着每一步的计算都需要求解一个代数方程。本练习 [@problem_id:3284169] 将通过一个简单的非线性常微分方程 $y' = y^2$ 来让你亲身体验这一点。你将推导出由梯形法产生的隐式二次方程，并通过解析求解来揭示该数值方法在解趋近于奇点（“爆破”时间）时的行为和局限性。", "problem": "考虑常微分方程 (ODE) $y'(t) = y(t)^{2}$，其初始值为 $y(0) = y_{0} > 0$。设 $\\{t_{n}\\}_{n \\ge 0}$ 为一个均匀网格，其中 $t_{n+1} = t_{n} + h$，$h > 0$ 为固定步长。设 $\\{y_{n}\\}_{n \\ge 0}$ 是由某个单步法定义的离散近似值。从自治常微分方程的基本积分关系式\n$$\ny(t_{n+1}) = y(t_{n}) + \\int_{t_{n}}^{t_{n+1}} y(t)^{2} \\, dt,\n$$\n出发，应用梯形数值积分法来近似该积分，从而推导连接 $y_{n+1}$ 和 $y_{n}$ 的隐式代数关系。证明所得关系是关于 $y_{n+1}$ 的二次方程，并显式求解该二次方程得到 $y_{n+1}$，选择当 $h \\to 0$ 时能够恢复 $y_{n+1} \\to y_{n}$ 的那个分支。然后，施加 $y_{n+1}$ 为实值的条件，并确定当 $y_{n} > 0$ 时，该梯形步长所允许的最大正步长 $h_{\\max}(y_{n})$。使用通过分离变量法得到的常微分方程的精确解，简要论证当解趋近其爆破时间时，$h_{\\max}(y_{n})$ 的变化情况。将你的最终答案表示为一个包含两个元素的行矩阵，其中第一个元素是用 $y_{n}$ 和 $h$ 表示的 $y_{n+1}$ 的显式公式，第二个元素是 $h_{\\max}(y_{n})$。无需四舍五入，也无需单位。", "solution": "该问题要求对常微分方程 (ODE) $y'(t) = f(y(t))$（其中 $f(y) = y^2$）的一个数值方法进行推导和分析。推导从该常微分方程的积分形式开始。\n\n在从 $t_n$ 到 $t_{n+1}$ 的单个时间步长上的精确解由以下积分关系给出：\n$$\ny(t_{n+1}) = y(t_{n}) + \\int_{t_{n}}^{t_{n+1}} y'(t) \\, dt = y(t_{n}) + \\int_{t_{n}}^{t_{n+1}} y(t)^{2} \\, dt\n$$\n题目要求我们使用梯形法则来近似该积分。对于积分 $\\int_{a}^{b} g(t) \\, dt$，梯形法则由 $\\frac{b-a}{2} (g(a) + g(b))$ 给出。\n在我们的问题中，$g(t) = y(t)^2$，$a=t_n$，$b=t_{n+1}$，步长为 $h = t_{n+1} - t_n$。应用该法则可得：\n$$\n\\int_{t_{n}}^{t_{n+1}} y(t)^{2} \\, dt \\approx \\frac{h}{2} (y(t_n)^2 + y(t_{n+1})^2)\n$$\n用精确值 $y(t_n)$ 和 $y(t_{n+1})$ 的数值近似值（分别记为 $y_n$ 和 $y_{n+1}$）进行替换，我们得到针对此常微分方程的隐式单步法，即梯形法：\n$$\ny_{n+1} = y_n + \\frac{h}{2} (y_n^2 + y_{n+1}^2)\n$$\n这就是连接 $y_{n+1}$ 和 $y_n$ 的隐式代数关系。\n\n为了证明这是一个关于 $y_{n+1}$ 的二次方程，我们整理各项：\n$$\n\\frac{h}{2} y_{n+1}^2 - y_{n+1} + \\left(y_n + \\frac{h}{2} y_n^2\\right) = 0\n$$\n这是一个形如 $Ay_{n+1}^2 + By_{n+1} + C = 0$ 的方程，其系数为 $A = \\frac{h}{2}$，$B = -1$ 和 $C = y_n + \\frac{h}{2} y_n^2$。因此，这是一个关于未知数 $y_{n+1}$ 的二次方程。\n\n我们使用二次求根公式 $y_{n+1} = \\frac{-B \\pm \\sqrt{B^2 - 4AC}}{2A}$ 来求解这个关于 $y_{n+1}$ 的二次方程：\n$$\ny_{n+1} = \\frac{-(-1) \\pm \\sqrt{(-1)^2 - 4\\left(\\frac{h}{2}\\right)\\left(y_n + \\frac{h}{2} y_n^2\\right)}}{2\\left(\\frac{h}{2}\\right)}\n$$\n$$\ny_{n+1} = \\frac{1 \\pm \\sqrt{1 - 2h(y_n + \\frac{h}{2} y_n^2)}}{h}\n$$\n$$\ny_{n+1} = \\frac{1 \\pm \\sqrt{1 - 2hy_n - h^2 y_n^2}}{h}\n$$\n问题要求选择满足相容性条件 $y_{n+1} \\to y_n$ (当 $h \\to 0$) 的分支。我们在此极限下分析这两个分支。\n对于‘+’分支：\n$$\n\\lim_{h \\to 0} \\frac{1 + \\sqrt{1 - 2hy_n - h^2 y_n^2}}{h}\n$$\n当 $h \\to 0$ 时，分子趋近于 $1 + \\sqrt{1} = 2$，而分母趋近于 $0$。该极限趋于无穷大，这是不相容的。\n对于‘-’分支，我们得到一个 $0/0$ 型不定式。我们可以使用洛必达法则或泰勒展开。对小的 $x$ 使用泰勒展开 $\\sqrt{1-x} \\approx 1 - \\frac{x}{2}$：\n$$\n\\sqrt{1 - 2hy_n - h^2 y_n^2} \\approx 1 - \\frac{1}{2}(2hy_n + h^2 y_n^2) = 1 - hy_n - \\frac{1}{2}h^2 y_n^2\n$$\n将此代入‘-’分支的表达式中：\n$$\ny_{n+1} \\approx \\frac{1 - (1 - hy_n - \\frac{1}{2}h^2 y_n^2)}{h} = \\frac{hy_n + \\frac{1}{2}h^2 y_n^2}{h} = y_n + \\frac{1}{2}hy_n^2\n$$\n在 $h \\to 0$ 的极限下，该表达式变为 $y_n$。因此，正确的分支是带负号的那个。该步的显式公式为：\n$$\ny_{n+1} = \\frac{1 - \\sqrt{1 - 2hy_n - h^2 y_n^2}}{h}\n$$\n接下来，我们确定使 $y_{n+1}$ 为实值的最大正步长 $h_{\\max}(y_{n})$。这要求二次方程的判别式为非负：\n$$\n1 - 2hy_n - h^2 y_n^2 \\ge 0\n$$\n由于 $y_n > 0$ 并且我们寻求 $h > 0$，我们可以将其整理成一个关于 $h$ 的标准二次不等式：\n$$\ny_n^2 h^2 + 2y_n h - 1 \\le 0\n$$\n相应的二次方程 $y_n^2 h^2 + 2y_n h - 1 = 0$ 的根由下式给出：\n$$\nh = \\frac{-2y_n \\pm \\sqrt{(2y_n)^2 - 4(y_n^2)(-1)}}{2y_n^2} = \\frac{-2y_n \\pm \\sqrt{8y_n^2}}{2y_n^2} = \\frac{-2y_n \\pm 2\\sqrt{2}y_n}{2y_n^2} = \\frac{-1 \\pm \\sqrt{2}}{y_n}\n$$\n由于 $h^2$ 项的系数 $y_n^2$ 是正的，抛物线开口向上。不等式 $y_n^2 h^2 + 2y_n h - 1 \\le 0$ 在两根之间的 $h$ 值成立。这两个根是 $h_1 = \\frac{-1-\\sqrt{2}}{y_n}$ 和 $h_2 = \\frac{\\sqrt{2}-1}{y_n}$。由于 $h$ 必须为正，有效范围是 $0  h \\le \\frac{\\sqrt{2}-1}{y_n}$。因此，最大正步长为：\n$$\nh_{\\max}(y_n) = \\frac{\\sqrt{2}-1}{y_n}\n$$\n最后，我们简要论证当解趋近其爆破时间时 $h_{\\max}(y_n)$ 的行为。对于 $y' = y^2$ 且 $y(0)=y_00$，其精确解可以通过分离变量法求得：$\\frac{dy}{y^2} = dt \\implies -1/y = t - 1/y_0 \\implies y(t) = \\frac{y_0}{1-ty_0}$。该解表现出有限时间爆破，即当 $t$ 趋近于奇点 $t_{blow-up} = 1/y_0$ 时，$y(t) \\to \\infty$。当数值解趋近这个奇点时，$y_n$ 的值会变得任意大。因此，$h_{\\max}(y_n) = (\\sqrt{2}-1)/y_n$ 趋于 $0$。这意味着当数值方法趋近奇点时，需要无穷小的步长才能继续进行，这是问题在爆破时间附近表现出极端刚性的一种体现。\n\n问题要求提供一个包含两个元素的行矩阵，其中包含 $y_{n+1}$ 的显式公式和 $h_{\\max}(y_n)$ 的表达式。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{1 - \\sqrt{1 - 2hy_n - h^2 y_n^2}}{h}  \\frac{\\sqrt{2} - 1}{y_n} \\end{pmatrix}}\n$$", "id": "3284169"}, {"introduction": "对于大多数复杂问题，隐式方程无法像上一个练习那样解析求解，必须依赖迭代数值方法。本练习 [@problem_id:3284122] 将指导你实现并比较两种常用的数值求解器——不动点迭代法和牛顿法。通过解决一个典型的刚性（stiff）问题，你将能深刻理解为什么像牛顿法这样更稳健的方法对于保证隐式格式在刚性系统中的高效和可靠至关重要。", "problem": "实现一个程序，用于构建和分析一个从基本积分形式推导出的、用于求解标量初值问题的隐式单步法。考虑由常微分方程 $y'(t) = -100\\,y(t) + 100\\,t + 101$ 和初始条件 $y(0) = 1$ 定义的初值问题。从恒等式 $y(t_{n+1}) = y(t_n) + \\int_{t_n}^{t_{n+1}} f(t, y(t))\\,dt$ 以及数值积分可以在短区间上近似光滑函数积分这一事实出发，推导将经典梯形积分法则应用于该积分所产生的隐式离散方程。不要写下任何现有的步长公式；相反，应仅使用梯形法则的数值积分定义作为唯一输入，并用 $t_n$ 处的已知量和 $t_{n+1}$ 处的未知量来表示定义 $y_{n+1}$ 的非线性方程。\n\n为了在每一步从隐式方程中计算 $y_{n+1}$，请为 $y_{n+1}$ 必须满足的非线性标量方程实现以下两种内部求解器：\n- 一种不动点（Picard）迭代法，基于对梯形构造产生的右侧表达式进行重复代入，并以 $y^{(0)} = y_n$ 进行初始化。\n- 一种牛顿法，使用隐式方程左侧关于 $y$ 的导数，并使用相同的初始猜测值 $y^{(0)} = y_n$。\n\n对两种内部求解器均使用 $10^{-12}$ 的绝对停止容差。对于牛顿法，该容差应用于方程的自然残差；对于不动点迭代法，该容差应用于连续迭代值之差。每步最多使用 100 次内部迭代。如果在任何一步中，不动点迭代法在此上限内未能收敛，则认为该步长的整个不动点求解过程失败，并按如下规定报告一个哨兵值。对于这两种方法，统计所有步数累积的内部迭代总次数。\n\n为了量化精度，请使用积分因子法推导给定初值问题的精确解，并用它来计算最终时间 $T$ 的绝对误差 $|y_N - y_{\\text{exact}}(T)|$。积分区间为 $[0, T]$，其中 $T=1$，步长为 $h$，因此 $t_n = n h$ 且 $N = T/h$ 是一个整数。\n\n测试套件：\n- 按顺序使用步长 $h \\in \\{0.001, 0.01, 0.02, 0.05\\}$ 积分到 $T = 1$。即，$h = 0.001$，$h = 0.01$，$h = 0.02$ 和 $h = 0.05$。\n- 对每个 $h$，计算：\n  1) 当隐式求解由牛顿法执行时，梯形法产生的最终值 $y_N^{\\text{(Newton)}}$，\n  2) 在 $T$ 处的绝对误差，即 $|y_N^{\\text{(Newton)}} - y_{\\text{exact}}(1)|$，\n  3) 在所有步数上累加的内部牛顿迭代总次数，\n  4) 如果所有步数都收敛，则为在所有步数上累加的内部不动点迭代总次数；否则输出整数 $-1$ 以表示失败。\n\n您的程序应生成单行输出，其中包含一个扁平的、由逗号分隔的列表，该列表用方括号括起来，并按上面列出的步长进行排序，每个步长对应四个按指定顺序排列的数字。具体而言，输出格式必须为 $[y_N^{\\text{(Newton)}}(h_1), |y_N^{\\text{(Newton)}}(h_1) - y_{\\text{exact}}(1)|, \\text{iters}^{\\text{(Newton)}}(h_1), \\text{iters}^{\\text{(Fixed)}}(h_1), \\dots, y_N^{\\text{(Newton)}}(h_4), |y_N^{\\text{(Newton)}}(h_4) - y_{\\text{exact}}(1)|, \\text{iters}^{\\text{(Newton)}}(h_4), \\text{iters}^{\\text{(Fixed)}}(h_4)]$，其中 $h_1 = 0.001$，$h_2 = 0.01$，$h_3 = 0.02$，$h_4 = 0.05$。如果对于给定的 $h$，不动点迭代在任何一步中失败，则为该 $h$ 的 $\\text{iters}^{\\text{(Fixed)}}(h)$ 打印 $-1$。所有数字必须以普通十进制数字的形式在单行上打印，格式与所示列表完全相同，不带任何单位或多余的空格。", "solution": "用户提供的问题是常微分方程(ODEs)数值分析领域中一个定义明确的任务。它要求对隐式梯形法进行推导、实现和分析。\n\n### 步骤 1：问题验证\n\n根据所需标准对问题进行验证。\n\n*   **提取已知条件**：\n    *   **ODE**：标量初值问题 (IVP) 为 $y'(t) = -100\\,y(t) + 100\\,t + 101$。\n    *   **初始条件**：$y(0) = 1$。\n    *   **ODE 的积分形式**：$y(t_{n+1}) = y(t_n) + \\int_{t_n}^{t_{n+1}} f(t, y(t))\\,dt$。\n    *   **方法推导**：必须通过将梯形积分法则应用于积分形式来推导数值方法。\n    *   **内部求解器**：每一步的隐式方程将使用两种方法求解：不动点（Picard）迭代法和牛顿法。\n    *   **内部求解器的初始猜测值**：两种方法均为 $y^{(0)} = y_n$。\n    *   **内部求解器容差**：绝对容差为 $10^{-12}$。对于牛顿法，这适用于残差。对于不动点法，这适用于连续迭代值之差。\n    *   **内部求解器迭代限制**：每个时间步最多 100 次迭代。\n    *   **不动点法失败**：如果在任何一步中，迭代次数在限制内未达到收敛，则该步长 $h$ 的总迭代次数报告为 $-1$。\n    *   **分析**：计算在最终时间 $T=1$ 时的绝对误差 $|y_N - y_{\\text{exact}}(T)|$。\n    *   **离散化**：时间区间为 $[0, 1]$。步长 $h$ 导致 $t_n = n h$，总步数为 $N = T/h$。\n    *   **测试套件**：步长 $h \\in \\{0.001, 0.01, 0.02, 0.05\\}$。\n    *   **每个 `h` 的要求输出**：$y_N^{\\text{(Newton)}}$、 $|y_N^{\\text{(Newton)}} - y_{\\text{exact}}(1)|$、总牛顿迭代次数、总不动点迭代次数（或-1）。\n\n*   **验证结论**：\n    *   **科学依据**：是。该问题是数值分析中的一个标准练习，涉及将已建立的方法（梯形法则、牛顿法、不动点迭代法）应用于线性 ODE。\n    *   **适定性**：是。线性 IVP 是适定的，保证了唯一解的存在。数值任务有明确规定。\n    *   **目标明确**：是。问题定义了精确的数学和计算要求。\n    *   该问题是完整的、一致的且计算上可行的。它是一项需要推导和实现的、实质性的且非平凡的任务。\n\n*   **结论**：该问题有效。\n\n### 步骤 2：解的推导与方法分析\n\n在实施之前，该解需要进行若干分析推导。该 ODE 的形式为 $y'(t) = f(t, y(t))$，其中 $f(t, y) = -100y + 100t + 101$。\n\n#### 精确解的推导\nODE $y' + 100y = 100t + 101$ 是一阶线性 ODE。我们使用积分因子 $I(t) = e^{\\int 100 dt} = e^{100t}$ 来求解。将 ODE 乘以 $I(t)$ 得到：\n$$ e^{100t}y' + 100e^{100t}y = (100t + 101)e^{100t} $$\n左边是乘积的导数：\n$$ \\frac{d}{dt}(y(t)e^{100t}) = (100t + 101)e^{100t} $$\n对两边关于 $t$ 积分：\n$$ y(t)e^{100t} = \\int (100t + 101)e^{100t} dt $$\n右边的积分使用分部积分法 $\\int u dv = uv - \\int v du$ 求解，令 $u = 100t+101$ 和 $dv = e^{100t}dt$。由此得到 $du = 100dt$ 和 $v = \\frac{1}{100}e^{100t}$。\n$$ \\int (100t + 101)e^{100t} dt = (100t+101)\\frac{e^{100t}}{100} - \\int \\frac{e^{100t}}{100} (100) dt = (t + 1.01)e^{100t} - \\int e^{100t}dt $$\n$$ = (t + 1.01)e^{100t} - \\frac{1}{100}e^{100t} + C = (t+1)e^{100t} + C $$\n因此，通解为：\n$$ y(t) = t + 1 + Ce^{-100t} $$\n应用初始条件 $y(0) = 1$：\n$$ 1 = 0 + 1 + Ce^0 \\implies C = 0 $$\n精确解为 $y_{\\text{exact}}(t) = t + 1$。在最终时间 $T=1$ 时的值为 $y_{\\text{exact}}(1) = 1+1=2$。\n\n#### 梯形法的推导\n从 ODE 在单步 $[t_n, t_{n+1}]$ 上的积分形式出发：\n$$ y(t_{n+1}) = y(t_n) + \\int_{t_n}^{t_{n+1}} f(t, y(t)) dt $$\n我们使用梯形法则 $\\int_a^b g(x)dx \\approx \\frac{b-a}{2}(g(a)+g(b))$ 来近似该积分。令 $h=t_{n+1}-t_n$，$y_n \\approx y(t_n)$ 和 $y_{n+1} \\approx y(t_{n+1})$。\n$$ \\int_{t_n}^{t_{n+1}} f(t, y(t)) dt \\approx \\frac{h}{2}(f(t_n, y(t_n)) + f(t_{n+1}, y(t_{n+1}))) $$\n将此代入积分方程，得到隐式梯形法：\n$$ y_{n+1} = y_n + \\frac{h}{2}(f(t_n, y_n) + f(t_{n+1}, y_{n+1})) $$\n这是一个隐式方程，因为未知数 $y_{n+1}$ 出现在方程的两边。\n\n#### 内部求解器的设置\n为了在每一步找到 $y_{n+1}$，我们必须解这个方程。设 $w$ 为 $y_{n+1}$ 的未知值。\n\n**1. 不动点迭代法：**\n将方程重排以形成不动点映射 $w = G(w)$：\n$$ w = y_n + \\frac{h}{2}(f(t_n, y_n) + f(t_{n+1}, w)) $$\n迭代公式为 $w^{(k+1)} = G(w^{(k)})$，从 $w^{(0)} = y_n$ 开始。重复此过程，直到 $|w^{(k+1)} - w^{(k)}|  10^{-12}$。\n收敛性由压缩映射原理决定，该原理要求 $|G'(w)|  1$。其导数为：\n$$ G'(w) = \\frac{d}{dw} \\left( y_n + \\frac{h}{2}(f(t_n, y_n) + f(t_{n+1}, w)) \\right) = \\frac{h}{2} \\frac{\\partial f}{\\partial y}(t_{n+1}, w) $$\n对于给定的问题，$\\frac{\\partial f}{\\partial y} = -100$。因此，$G'(w) = -50h$。如果 $|-50h|  1$ 或 $h  0.02$，则迭代收敛。\n*   对于 $h=0.001$：$|-50(0.001)|=0.05  1$。收敛。\n*   对于 $h=0.01$：$|-50(0.01)|=0.5  1$。收敛。\n*   对于 $h=0.02$：$|-50(0.02)|=1$。这是一个边界情况，不保证收敛，收敛速度会极慢，或者可能失败。迭代在 100 步内不会达到容差。\n*   对于 $h=0.05$：$|-50(0.05)|=2.5 > 1$。发散。\n因此，预计不动点法在 $h=0.02$ 和 $h=0.05$ 时会失败。\n\n**2. 牛顿法：**\n我们求解残差函数 $F(w)=0$ 的根，其中：\n$$ F(w) = w - y_n - \\frac{h}{2}(f(t_n, y_n) + f(t_{n+1}, w)) = 0 $$\nNewton-Raphson 迭代公式为 $w^{(k+1)} = w^{(k)} - \\frac{F(w^{(k)})}{F'(w^{(k)})}$，从 $w^{(0)} = y_n$ 开始。重复此过程，直到残差足够小：$|F(w^{(k)})|  10^{-12}$。\n导数 $F'(w)$ 为：\n$$ F'(w) = \\frac{d}{dw} \\left( w - y_n - \\frac{h}{2}(f(t_n, y_n) + f(t_{n+1}, w)) \\right) = 1 - \\frac{h}{2} \\frac{\\partial f}{\\partial y}(t_{n+1}, w) $$\n对于我们的问题，$F'(w) = 1 - \\frac{h}{2}(-100) = 1 + 50h$。\n由于 $f(t,y)$ 是关于 $y$ 的线性函数，残差 $F(w)$ 也是 $w$ 的线性函数。因此，牛顿法将在单次迭代中找到此线性方程的精确根（不考虑浮点误差）。因此，预计每个时间步的牛顿迭代次数为 1。\n\n### 步骤 3：计算算法\n整体算法如下：\n1.  初始化一个列表以存储最终结果。\n2.  定义函数 $f(t,y) = -100y + 100t + 101$ 及其偏导数 $\\frac{\\partial f}{\\partial y} = -100$。\n3.  定义精确解 $y_{\\text{exact}}(t) = t+1$。最终值为 $y_{\\text{exact}}(1)=2$。\n4.  遍历每个步长 $h \\in \\{0.001, 0.01, 0.02, 0.05\\}$。\n5.  对于每个 $h$，从 $t=0$到 $t=1$ 运行两个独立的模拟：一个使用牛顿法作为内部求解器，另一个使用不动点法。\n6.  在每个模拟中，初始化 $t=0$, $y=1$ 和总迭代计数器。\n7.  迭代 $N=T/h$ 次。在每一步中，调用相应的内部求解器（牛顿法或不动点法）从 $y_n$ 求出 $y_{n+1}$。累加求解器返回的迭代次数。\n8.  对于不动点模拟，如果任何一步在 100 次迭代内未能收敛，则设置一个失败标志。最终迭代计数将为 $-1$。\n9.  循环结束后，计算牛顿法结果的最终误差。\n10. 存储当前 $h$ 的四个所需值：$y_N^{\\text{(Newton)}}$、误差、牛顿迭代次数和不动点迭代次数。\n11. 处理完所有 $h$ 值后，将结果列表展平并格式化以进行打印。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and analyzes the trapezoidal method for a given ODE\n    using both Newton and Fixed-Point inner solvers.\n    \"\"\"\n\n    # --- Problem Definition ---\n    # ODE: y'(t) = -100*y(t) + 100*t + 101\n    # Initial Condition: y(0) = 1\n    # Time interval: [0, 1]\n    \n    y0 = 1.0\n    t_end = 1.0\n    tol = 1e-12\n    max_inner_iters = 100\n    \n    test_h_values = [0.001, 0.01, 0.02, 0.05]\n\n    def f(t, y):\n        \"\"\"RHS of the ODE y' = f(t, y).\"\"\"\n        return -100.0 * y + 100.0 * t + 101.0\n\n    def dfdy(t, y):\n        \"\"\"Partial derivative of f with respect to y.\"\"\"\n        # For this problem, df/dy is constant.\n        return -100.0\n\n    def y_exact(t):\n        \"\"\"Exact solution to the IVP.\"\"\"\n        return t + 1.0\n\n    # --- Solver Implementations ---\n\n    def run_simulation(h, inner_solver_type):\n        \"\"\"\n        Integrates the ODE from t=0 to t=T with step size h,\n        using the specified inner solver.\n\n        Args:\n            h (float): The step size.\n            inner_solver_type (str): 'newton' or 'fixed_point'.\n\n        Returns:\n            A tuple (final_y, total_iters). `total_iters` is -1 on failure.\n        \"\"\"\n        y = y0\n        t = 0.0\n        n_steps = int(round(t_end / h))\n        total_iters = 0\n        \n        for n in range(n_steps):\n            tn = n * h\n            tn1 = (n + 1) * h\n        \n            if inner_solver_type == 'newton':\n                y_next, iters_step = solve_newton_step(y, tn, h)\n            elif inner_solver_type == 'fixed_point':\n                y_next, iters_step = solve_fp_step(y, tn, h)\n            \n            if iters_step == -1:\n                return None, -1 # Failure to converge\n            \n            y = y_next\n            total_iters += iters_step\n            \n        return y, total_iters\n\n    def solve_newton_step(yn, tn, h):\n        \"\"\"Solves for y_{n+1} using Newton's method.\"\"\"\n        tn1 = tn + h\n        fn = f(tn, yn)\n        \n        # F'(w) is constant for this linear ODE\n        F_prime = 1.0 - (h / 2.0) * dfdy(tn1, 0)\n        \n        w = yn  # Initial guess w^(0)\n        \n        # Check initial guess residual\n        fw = f(tn1, w)\n        F_w = w - yn - (h / 2.0) * (fn + fw)\n        if np.abs(F_w)  tol:\n            return w, 0\n\n        for iters in range(1, max_inner_iters + 1):\n            w = w - F_w / F_prime\n            \n            # Check residual of the new iterate\n            fw = f(tn1, w)\n            F_w = w - yn - (h / 2.0) * (fn + fw)\n            \n            if np.abs(F_w)  tol:\n                return w, iters\n                \n        return None, -1  # Did not converge\n\n    def solve_fp_step(yn, tn, h):\n        \"\"\"Solves for y_{n+1} using fixed-point iteration.\"\"\"\n        tn1 = tn + h\n        fn = f(tn, yn)\n        \n        w_k = yn # Initial guess w^(0)\n        \n        for iters in range(1, max_inner_iters + 1):\n            fw_k = f(tn1, w_k)\n            w_k_plus_1 = yn + (h / 2.0) * (fn + fw_k)\n            \n            if np.abs(w_k_plus_1 - w_k)  tol:\n                return w_k_plus_1, iters\n            \n            w_k = w_k_plus_1\n        \n        return None, -1 # Did not converge\n\n    # --- Main Execution Logic ---\n    results = []\n    y_final_exact = y_exact(t_end)\n\n    for h in test_h_values:\n        # 1. Newton's method results\n        yN_newton, iters_newton = run_simulation(h, 'newton')\n        error_newton = np.abs(yN_newton - y_final_exact)\n        \n        # 2. Fixed-point method results\n        # We don't need the final y value, just the iteration count.\n        _, iters_fp = run_simulation(h, 'fixed_point')\n\n        # 3. Collect results for this h\n        results.extend([yN_newton, error_newton, iters_newton, iters_fp])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3284122"}, {"introduction": "一个优秀的数值方法不仅要算得准，还应能保持真实解所具有的关键定性特征。本练习 [@problem_id:3284056] 聚焦于“保正性”，这是许多物理和生物模型（如种群动力学）中的一项基本物理约束。你将从第一性原理出发，推导梯形法在应用于线性测试方程时保持解为正的条件，并通过编程来验证你的理论分析。", "problem": "考虑一个常微分方程 (ODE) 的标量初值问题\n$$\n\\frac{dy}{dt} = f(t,y), \\quad y(t_0) = y_0,\n$$\n要求其真解对于所有 $t \\ge t_0$ 都满足 $y(t)  0$。许多模型（例如种群动态模型）将 $y(t)  0$ 作为一个物理约束。如果一个数值方法从 $y_0  0$ 出发，其产生的数值近似解 $y_n$ 在所有步长 $n$ 中都保持严格为正，则称该方法是保正的。\n\n您的任务是研究梯形法是否保正。从单个时间步长上初值问题的基本积分形式开始：\n$$\ny(t_{n+1}) = y(t_n) + \\int_{t_n}^{t_{n+1}} f(t, y(t))\\, dt,\n$$\n并回想一下，梯形求积法通过被积函数在区间端点处的平均值乘以区间长度来近似一个区间上的积分。仅以此为基础，推导梯形法的时间步进关系。然后，将其应用于线性测试方程\n$$\n\\frac{dy}{dt} = \\mu y, \\quad \\mu \\in \\mathbb{R},\n$$\n并从第一性原理出发，确定在假设 $y_0  0$ 的情况下，梯形法保持或不保持正性的时间步长 $h$（与 $\\mu$ 相关）的条件。\n\n编写一个程序：\n- 为线性测试方程实现梯形法更新，能够从 $y_0  0$ 开始，以均匀步长 $h$ 生成离散序列 $\\{y_n\\}_{n=0}^N$。\n- 对于下面的每个测试用例，返回一个布尔值，指示是否在每一步都满足 $y_n  0$（$n = 1,2,\\ldots,N$）。\n\n使用以下参数集 $(\\mu, y_0, h, N)$ 的测试套件：\n- 情况 1：$(\\mu, y_0, h, N) = (-1, 1.0, 0.1, 10)$。\n- 情况 2：$(\\mu, y_0, h, N) = (-1, 1.0, 3.0, 5)$。\n- 情况 3：$(\\mu, y_0, h, N) = (1, 0.1, 0.5, 6)$。\n- 情况 4：$(\\mu, y_0, h, N) = (1, 1.0, 3.0, 1)$。\n- 情况 5：$(\\mu, y_0, h, N) = (-10, 0.5, 0.19, 3)$。\n\n不涉及物理单位。不涉及角度。不涉及百分比。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的布尔值列表，且没有空格。例如，格式必须完全如下所示\n$$\n[{\\rm True},{\\rm False},{\\rm True},{\\rm False},{\\rm True}].\n$$", "solution": "该问题要求研究常微分方程 (ODE) 的梯形法的保正性。此验证将分三步进行：首先，从给定的积分形式推导梯形法；其次，将该方法应用于线性测试方程；第三，推导确保维持正性的时间步长 $h$ 的条件。\n\n**第一步：梯形法的推导**\n\n将微积分基本定理应用于时间区间 $[t_n, t_{n+1}]$ 上的 ODE $\\frac{dy}{dt} = f(t,y)$，可得精确关系：\n$$\ny(t_{n+1}) = y(t_n) + \\int_{t_n}^{t_{n+1}} f(t, y(t))\\, dt\n$$\n问题指定使用梯形求积法则来近似该积分。该法则通过由函数在区间端点的值构成的梯形的面积来近似曲线下的面积。对于 $[a, b]$ 上的被积函数 $g(t)$，其近似值为 $\\int_a^b g(t) dt \\approx \\frac{b-a}{2}(g(a) + g(b))$。\n\n将此应用于我们的积分，我们设区间为 $[t_n, t_{n+1}]$，长度为 $h = t_{n+1} - t_n$，被积函数为 $f(t, y(t))$。近似值为：\n$$\n\\int_{t_n}^{t_{n+1}} f(t, y(t))\\, dt \\approx \\frac{h}{2} \\left[ f(t_n, y(t_n)) + f(t_{n+1}, y(t_{n+1})) \\right]\n$$\n我们将数值近似定义为 $y_n \\approx y(t_n)$ 和 $y_{n+1} \\approx y(t_{n+1})$。将此近似代入精确的积分关系，得到梯形法的时间步进公式：\n$$\ny_{n+1} = y_n + \\frac{h}{2} \\left[ f(t_n, y_n) + f(t_{n+1}, y_{n+1}) \\right]\n$$\n这是一个隐式方法，因为未知值 $y_{n+1}$ 出现在方程的两边，作为右侧函数 $f$ 的参数。\n\n**第二步：应用于线性测试方程**\n\n线性测试方程由 $\\frac{dy}{dt} = \\mu y$ 给出，其中 $\\mu \\in \\mathbb{R}$。对于此 ODE，函数 $f(t, y)$ 仅为 $f(t, y) = \\mu y$。将这个特定的 $f$ 形式代入梯形公式，我们得到：\n$$\ny_{n+1} = y_n + \\frac{h}{2} \\left[ (\\mu y_n) + (\\mu y_{n+1}) \\right]\n$$\n为了获得一个显式的更新规则，我们必须通过代数方法解出 $y_{n+1}$：\n$$\ny_{n+1} - \\frac{h\\mu}{2} y_{n+1} = y_n + \\frac{h\\mu}{2} y_n\n$$\n在等式左边提取 $y_{n+1}$，在右边提取 $y_n$，得到：\n$$\ny_{n+1} \\left(1 - \\frac{h\\mu}{2}\\right) = y_n \\left(1 + \\frac{h\\mu}{2}\\right)\n$$\n假设 $1 - \\frac{h\\mu}{2} \\neq 0$，我们可以分离出 $y_{n+1}$：\n$$\ny_{n+1} = y_n \\left( \\frac{1 + \\frac{h\\mu}{2}}{1 - \\frac{h\\mu}{2}} \\right)\n$$\n这就是应用于线性测试方程的梯形法的离散递推关系。括号中的项是放大因子，它决定了解如何从一个步长演化到下一个步长。\n\n**第三步：保正条件的推导**\n\n如果一个方法从初始条件 $y_0  0$ 开始，所有的后续近似值 $y_n$ 都保持严格为正，则该方法是保正的。从上面推导的递推关系来看，如果我们假设 $y_n  0$，那么 $y_{n+1}$ 的符号完全由放大因子的符号决定：\n$$\nR(h\\mu) = \\frac{1 + \\frac{h\\mu}{2}}{1 - \\frac{h\\mu}{2}}\n$$\n为了使 $y_{n+1}$ 严格为正，我们需要 $R(h\\mu)  0$。设乘积 $z = h\\mu$。条件是：\n$$\n\\frac{1 + z/2}{1 - z/2}  0\n$$\n一个商为正，当且仅当分子和分母同号。这等价于它们的乘积为正，前提是分母不为零。\n$$\n\\left(1 + \\frac{z}{2}\\right) \\left(1 - \\frac{z}{2}\\right)  0 \\quad \\text{and} \\quad 1 - \\frac{z}{2} \\neq 0\n$$\n该乘积可以简化为平方差：\n$$\n1 - \\left(\\frac{z}{2}\\right)^2  0\n$$\n$$\n1  \\frac{z^2}{4}\n$$\n$$\n4  z^2\n$$\n对两边取平方根，得到：\n$$\n|z|  2\n$$\n将 $z = h\\mu$ 代回，我们得到严格保正的条件：\n$$\n|h\\mu|  2\n$$\n如果 $|h\\mu| = 2$，那么 $z^2 = 4$，这意味着 $1-z^2/4=0$。这意味着 $R(z)$ 的分子或分母（但不是两者同时）为零。如果 $z=2$，分母为零，导致除以零。如果 $z=-2$，分子为零，导致 $y_{n+1}=0$，这违反了严格正性。如果 $|h\\mu| > 2$，放大因子为负，导致解在每一步都改变符号，从而违反了正性。\n\n因此，对于线性测试方程，梯形法是保正的，当且仅当步长 $h$ 和参数 $\\mu$ 的乘积满足 $|h\\mu|  2$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Investigates the positivity preservation of the trapezoidal method for the\n    linear test ODE dy/dt = mu*y.\n    \"\"\"\n    # Define the test cases as tuples of (mu, y0, h, N).\n    test_cases = [\n        (-1.0, 1.0, 0.1, 10),\n        (-1.0, 1.0, 3.0, 5),\n        (1.0, 0.1, 0.5, 6),\n        (1.0, 1.0, 3.0, 1),\n        (-10.0, 0.5, 0.19, 3),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        mu, y0, h, N = case\n        \n        # Initialize the solution variable and the positivity flag.\n        y = np.float64(y0)\n        preserves_positivity = True\n\n        # The amplification factor for the trapezoidal method on the test equation is\n        # R = (1 + h*mu/2) / (1 - h*mu/2).\n        # We check the condition |h*mu|  2, which is equivalent to R > 0.\n        # This pre-check is sufficient, but the simulation is performed as requested.\n        \n        # Calculate the numerator and denominator of the amplification factor.\n        # Use np.float64 for precision consistent with typical scientific computing.\n        numerator = np.float64(1.0) + h * mu / np.float64(2.0)\n        denominator = np.float64(1.0) - h * mu / np.float64(2.0)\n\n        # A zero denominator means h*mu = 2, violating positivity.\n        if denominator == 0.0:\n            preserves_positivity = False\n        else:\n            amp_factor = numerator / denominator\n            \n            # If the amplification factor is not positive, positivity is violated.\n            if amp_factor = 0:\n                preserves_positivity = False\n            else:\n                # If the amplification factor is positive, y will never become non-positive\n                # starting from y0 > 0, as it's just repeated multiplication by a\n                # positive number. The simulation loop is technically redundant if we\n                # trust the analysis, but we run it to confirm step-by-step.\n                for _ in range(N):\n                    y = y * amp_factor\n                    # Check for strict positivity at each step.\n                    if y = 0.0:\n                        preserves_positivity = False\n                        break\n        \n        results.append(preserves_positivity)\n\n    # Format the final output as a comma-separated list of booleans in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3284056"}]}