{"hands_on_practices": [{"introduction": "掌握A-稳定性和L-稳定性概念的第一步是能够直接应用它们的数学定义。本练习提供了一个假设数值方法的稳定性函数，要求你通过计算来判断它是否为A-稳定和L-稳定。这个练习旨在帮助你熟练运用稳定性判据，并为更复杂的分析打下坚实的基础。[@problem_id:2151768]", "problem": "在分析求解常微分方程 (ODE) 的数值方法时，方法的稳定性是一个关键性质。这通常通过将方法应用于 Dahlquist 测试方程 $y' = \\lambda y$ 来研究，其中 $\\lambda$ 是一个满足 $\\text{Re}(\\lambda) \\leq 0$ 的复数。该分析导出一个稳定性函数 $R(z)$，其中 $z = h\\lambda$，$h$ 是步长。$R(z)$ 的性质决定了方法的稳定性。\n\n两个重要的稳定性性质是 A-稳定性和 L-稳定性：\n1.  如果一个方法的绝对稳定区域包含整个复左半平面，则该方法是 **A-稳定**的。对于一个具有有理稳定性函数 $R(z)$ 的方法，这等价于对于所有满足 $\\text{Re}(z) \\leq 0$ 的复数 $z$，条件 $|R(z)| \\leq 1$ 成立。\n2.  如果一个方法是 A-稳定的，并且其稳定性函数还满足条件 $\\lim_{z \\to \\infty} R(z) = 0$，则该方法是 **L-稳定**的。\n\n考虑一个假设的单步数值方法，其稳定性函数由以下有理函数给出：\n$$\nR(z) = \\frac{1+\\frac{1}{3}z}{1-\\frac{2}{3}z}\n$$\n\n根据所提供的定义，确定该方法的稳定性。\n\nA. 该方法是 A-稳定的，但不是 L-稳定的。\n\nB. 该方法是 L-稳定的。\n\nC. 该方法不是 A-稳定的。\n\nD. 该方法既不是 A-稳定的，也不是 L-稳定的。", "solution": "给定的稳定性函数为\n$$\nR(z) = \\frac{1+\\frac{1}{3}z}{1-\\frac{2}{3}z}.\n$$\nA-稳定性要求绝对稳定区域\n$$\nS=\\{z\\in\\mathbb{C}:\\,|R(z)|\\leq 1\\}\n$$\n包含整个左半平面 $\\{z:\\,\\text{Re}(z)\\leq 0\\}$。我们通过解不等式来分析 $S$\n$$\n\\left|\\frac{1+\\frac{1}{3}z}{1-\\frac{2}{3}z}\\right|\\leq 1\n\\quad\\Longleftrightarrow\\quad\n\\left|1+\\frac{1}{3}z\\right|\\leq\\left|1-\\frac{2}{3}z\\right|.\n$$\n令 $z=x+iy$，其中 $x,y\\in\\mathbb{R}$。对于实数 $\\alpha$，使用 $|1+\\alpha z|^{2}=(1+\\alpha x)^{2}+(\\alpha y)^{2}$，我们计算\n$$\n\\left|1+\\frac{1}{3}z\\right|^{2}=1+\\frac{2}{3}x+\\frac{1}{9}(x^{2}+y^{2}),\\qquad\n\\left|1-\\frac{2}{3}z\\right|^{2}=1-\\frac{4}{3}x+\\frac{4}{9}(x^{2}+y^{2}).\n$$\n因此\n$$\n1+\\frac{2}{3}x+\\frac{1}{9}(x^{2}+y^{2}) \\leq 1-\\frac{4}{3}x+\\frac{4}{9}(x^{2}+y^{2}).\n$$\n消去 $1$ 并合并项可得\n$$\n\\frac{2}{3}x+\\frac{1}{9}(x^{2}+y^{2}) \\leq -\\frac{4}{3}x+\\frac{4}{9}(x^{2}+y^{2}),\n$$\n$$\n\\frac{2}{3}x+\\frac{4}{3}x \\leq \\frac{4}{9}(x^{2}+y^{2})-\\frac{1}{9}(x^{2}+y^{2}),\n$$\n$$\n2x \\leq \\frac{1}{3}(x^{2}+y^{2}).\n$$\n乘以 3 并整理得到\n$$\n6x \\leq x^{2}+y^{2}\\quad\\Longleftrightarrow\\quad x^{2}+y^{2}-6x \\geq 0.\n$$\n配方，\n$$\n(x-3)^{2}+y^{2} \\geq 9.\n$$\n因此，绝对稳定区域 $S$ 是以 $(3,0)$ 为圆心、半径为 3 的圆的外部（包括边界）。对于任意满足 $\\text{Re}(z)=x\\leq 0$ 的 $z$，我们有 $(x-3)^{2}\\geq 9$，因此 $(x-3)^{2}+y^{2}\\geq 9$，所以每个这样的 $z$ 都位于 $S$ 中。因此，整个左半平面都被包含在内，该方法是 A-稳定的。\n\n为了检验 L-稳定性，我们计算当 $z\\to\\infty$ 时 $R(z)$ 的极限。由于分子和分母的次数相等，极限是它们首项系数的比值：\n$$\n\\lim_{z\\to\\infty}R(z)=\\lim_{z\\to\\infty}\\frac{\\frac{1}{3}z}{-\\frac{2}{3}z}=-\\frac{1}{2}\\neq 0.\n$$\n因此，该方法不是 L-稳定的。\n\n综合这些结果，该方法是 A-稳定的但不是 L-稳定的，这对应于选项 A。", "answer": "$$\\boxed{A}$$", "id": "2151768"}, {"introduction": "理论性质（如L-稳定性）具有切实的实践后果，仅有A-稳定性有时是不够的。本练习将通过分析经典的梯形法则来阐明这一点，你将验证该方法是A-稳定的但非L-稳定的。然后，通过编程实现，你将观察到它在求解一个刚性问题时产生的非物理振荡，从而直观地理解L-稳定性的实际价值。[@problem_id:3202108]", "problem": "要求您从第一性原理出发，构建并分析一个用于常微分方程的特定线性多步法，然后实现一个程序，以数值方式验证其性质，并展示其在处理一个刚性问题时的定性失效。只能使用以下基础定义和事实作为您的依据：线性多步法是任何形式为 $\\sum_{j=0}^{s} \\alpha_j y_{n+j} = h \\sum_{j=0}^{s} \\beta_j f_{n+j}$ 且系数为常数的方法；一个方法是相容的，当且仅当 $\\sum_{j=0}^{s} \\alpha_j = 0$ 且 $\\sum_{j=0}^{s} j \\alpha_j = \\sum_{j=0}^{s} \\beta_j$；绝对稳定性（A-稳定性）的定义要求，当应用于线性检验方程 $y' = \\lambda y$ 时，该方法的放大因子 $R(z)$（其中 $z = h \\lambda$）对于所有满足 $\\operatorname{Re}(z) \\le 0$ 的 $z$ 都满足 $\\lvert R(z) \\rvert \\le 1$；L-稳定性除此之外还要求 $\\lim_{\\operatorname{Re}(z)\\to -\\infty} R(z) = 0$。不要假设任何其他不能从这些事实推导出的公式。\n\n任务A。构建一个相容的、绝对稳定（A-稳定）但非L-稳定的线性多步法。用 $\\sum_{j=0}^{s} \\alpha_j y_{n+j} = h \\sum_{j=0}^{s} \\beta_j f_{n+j}$ 的形式表示该方法，并给出具体系数。通过将其应用于线性检验方程 $y'=\\lambda y$，推导出放大因子 $R(z)$ 关于 $z = h \\lambda$ 的闭式表达式。仅使用上述基本定义，证明该方法的相容性以及关于A-稳定性和非L-稳定性的论断。\n\n任务B。确定一个刚性问题和一个时间步长 $h$，使得任务A中的方法在该问题上会产生不希望出现的振荡（尽管该方法是A-稳定的），并解释导致这些振荡的机理。\n\n编程任务。在一个单独的程序中实现您的构建和分析，该程序需完成以下操作。\n\n1) 通过指定系数 $\\alpha_j$ 和 $\\beta_j$ 的数值（在代码中作为常量）来确定任务A中的方法。实现一个函数，该函数在给定复数 $z$ 的情况下，通过将方法代入检验方程 $y'=\\lambda y$ 并求解 $y_{n+1}/y_n$ 来计算方法的放大因子 $R(z)$。\n\n2) 相容性测试。使用相容性条件 $\\sum_{j=0}^{s} \\alpha_j = 0$ 和 $\\sum_{j=0}^{s} j \\alpha_j = \\sum_{j=0}^{s} \\beta_j$，返回一个布尔值，指示两个等式是否在 $10^{-12}$ 的绝对容差内成立。\n\n3) A-稳定性抽样检查。对于以下满足 $\\operatorname{Re}(z) \\le 0$ 的 $z$ 值测试套件，计算布尔值以指示 $\\lvert R(z) \\rvert \\le 1$ 是否在 $10^{-12}$ 的容差内成立：\n- $z_1 = -1$\n- $z_2 = -100$\n- $z_3 = -1 + 10 i$\n- $z_4 = -50 + 200 i$\n\n4) 数值L-稳定性检查。计算在 $z_\\star = -10^6$ 处的 $\\lvert R(z) \\rvert$ 值，并返回一个布尔值，该值当且仅当 $\\lvert R(z_\\star)\\rvert  10^{-3}$ 时为真。这为 $\\lim_{\\operatorname{Re}(z)\\to -\\infty} R(z) = 0$ 提供了一个定量代理。对于一个L-稳定的方法，在如此大的负值 $z_\\star$ 处，该代理应评估为真；对于一个非L-稳定的方法，它应评估为假。\n\n5) 刚性振荡演示。考虑刚性标量问题 $y' = \\lambda y$，其中 $\\lambda = -10000$，初始条件 $y(0) = 1$，最终时间 $T = 1$，固定步长 $h = 0.1$。使用任务A中的方法：\n- 计算 $N = T/h = 10$ 个步长，并统计序列 $(y_0,y_1,\\dots,y_N)$ 中的符号变化次数，其中如果在步骤 $n$ 处 $y_n y_{n+1}  0$ 则发生符号变化。\n- 报告最终数值大小 $\\lvert y_N \\rvert$。\n- 计算精确的最终大小 $\\lvert y(T) \\rvert = \\lvert y(0) \\exp(\\lambda T) \\rvert$。\n- 报告绝对误差 $\\lvert y_N - y(T) \\rvert$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，其结果按以下顺序排列：\n- 第2步的相容性布尔值，\n- 第3步的四个布尔值列表，顺序为 $[z_1,z_2,z_3,z_4]$，\n- 第4步的L-稳定性代理布尔值，\n- 以及第5步的列表 $[\\text{sign\\_changes}, \\lvert y_N\\rvert, \\lvert y(T)\\rvert, \\lvert y_N - y(T)\\rvert]$。\n例如，您的输出必须看起来像\n$[\\text{True},[b_1,b_2,b_3,b_4],\\text{False},[k,a,e,\\varepsilon]]$\n其中布尔值、整数和浮点数分别替换 $b_j$、$k$、$a$、$e$ 和 $\\varepsilon$。不应打印任何额外的文本或行。如果出现任何角度，必须以弧度为单位，但此处不需要。此问题中的所有量都是无量纲的，因此不需要物理单位转换。", "solution": "该问题是有效的。这是常微分方程数值分析中一个适定且自洽的练习，基于标准的定义和原理。所有必要的信息都已提供。\n\n主要任务是构建和分析一个A-稳定但非L-稳定的线性多步法（LMM），然后通过计算来展示其行为。\n\n### 任务A：方法的构建与分析\n\n我们寻找一个形式为 $\\sum_{j=0}^{s} \\alpha_j y_{n+j} = h \\sum_{j=0}^{s} \\beta_j f_{n+j}$ 的相容线性多步法（LMM），它应是A-稳定但非L-稳定的。这类方法的一个典型例子是梯形法则，它是一个单步法（$s=1$）。\n\n梯形法则是通过将常微分方程 $y' = f(t,y)$ 从 $t_n$ 积分到 $t_{n+1}$，并使用梯形求积法则来近似 $f$ 的积分而得到的：\n$$ y(t_{n+1}) - y(t_n) = \\int_{t_n}^{t_{n+1}} f(t, y(t)) dt \\approx \\frac{h}{2} [f(t_n, y(t_n)) + f(t_{n+1}, y(t_{n+1}))] $$\n这给出了数值方法：\n$$ y_{n+1} - y_n = \\frac{h}{2} (f_n + f_{n+1}) $$\n其中 $f_k = f(t_k, y_k)$ 且 $h = t_{n+1}-t_n$。\n\n为了将其表示为标准的LMM形式，我们将其重写为：\n$$ (1)y_{n+1} + (-1)y_n = h \\left( \\frac{1}{2} f_{n+1} + \\frac{1}{2} f_n \\right) $$\n将此与 $\\sum_{j=0}^{1} \\alpha_j y_{n+j} = h \\sum_{j=0}^{1} \\beta_j f_{n+j}$ 进行比较，我们确定系数为：\n- $s = 1$\n- $\\alpha_0 = -1$, $\\alpha_1 = 1$\n- $\\beta_0 = \\frac{1}{2}$, $\\beta_1 = \\frac{1}{2}$\n\n**相容性证明：**\n一个方法是相容的，如果 $\\sum_{j=0}^{s} \\alpha_j = 0$ 且 $\\sum_{j=0}^{s} j \\alpha_j = \\sum_{j=0}^{s} \\beta_j$。\n1.  第一个条件：$\\sum_{j=0}^{1} \\alpha_j = \\alpha_0 + \\alpha_1 = -1 + 1 = 0$。该条件满足。\n2.  第二个条件：\n    - 左侧：$\\sum_{j=0}^{1} j \\alpha_j = (0 \\cdot \\alpha_0) + (1 \\cdot \\alpha_1) = 0 \\cdot (-1) + 1 \\cdot 1 = 1$。\n    - 右侧：$\\sum_{j=0}^{1} \\beta_j = \\beta_0 + \\beta_1 = \\frac{1}{2} + \\frac{1}{2} = 1$。\n    - 由于 $1=1$，第二个条件也满足。\n因此，梯形法则是相容的方法。\n\n**放大因子 $R(z)$ 的推导：**\n我们将该方法应用于线性检验方程 $y' = \\lambda y$，其中 $\\lambda \\in \\mathbb{C}$。对于该方程，有 $f_{n} = \\lambda y_{n}$ 和 $f_{n+1} = \\lambda y_{n+1}$。代入方法的公式：\n$$ y_{n+1} - y_n = \\frac{h}{2} (\\lambda y_n + \\lambda y_{n+1}) $$\n令 $z = h \\lambda$。方程变为：\n$$ y_{n+1} - y_n = \\frac{z}{2} (y_n + y_{n+1}) $$\n我们求解放大因子 $R(z) = y_{n+1} / y_n$：\n$$ y_{n+1} - \\frac{z}{2} y_{n+1} = y_n + \\frac{z}{2} y_n $$\n$$ y_{n+1} \\left(1 - \\frac{z}{2}\\right) = y_n \\left(1 + \\frac{z}{2}\\right) $$\n$$ R(z) = \\frac{y_{n+1}}{y_n} = \\frac{1 + z/2}{1 - z/2} $$\n\n**稳定性证明：**\n-   **A-稳定性：** A-稳定性要求对于所有满足 $\\operatorname{Re}(z) \\le 0$ 的 $z$，都有 $|R(z)| \\le 1$。令 $z = x + iy$，其中 $x = \\operatorname{Re}(z) \\le 0$。\n    $$ |R(z)|^2 = \\left| \\frac{1 + (x+iy)/2}{1 - (x+iy)/2} \\right|^2 = \\frac{|(1 + x/2) + i(y/2)|^2}{|(1 - x/2) - i(y/2)|^2} = \\frac{(1+x/2)^2 + (y/2)^2}{(1-x/2)^2 + (y/2)^2} $$\n    条件 $|R(z)|^2 \\le 1$ 等价于：\n    $$ (1+x/2)^2 + (y/2)^2 \\le (1-x/2)^2 + (y/2)^2 $$\n    $$ 1 + x + \\frac{x^2}{4} \\le 1 - x + \\frac{x^2}{4} $$\n    $$ 2x \\le 0 \\implies x \\le 0 $$\n    这恰好是条件 $\\operatorname{Re}(z) \\le 0$。因此，梯形法则是A-稳定的。\n\n-   **非L-稳定性：** L-稳定性要求方法是A-稳定的，并且还要求 $\\lim_{\\operatorname{Re}(z)\\to -\\infty} R(z) = 0$。我们计算推导出的 $R(z)$ 的极限：\n    $$ \\lim_{\\operatorname{Re}(z)\\to -\\infty} R(z) = \\lim_{z \\to \\infty, \\operatorname{Re}(z) \\le 0} \\frac{1 + z/2}{1 - z/2} $$\n    分子和分母同除以 $z$：\n    $$ \\lim_{z \\to \\infty, \\operatorname{Re}(z) \\le 0} \\frac{1/z + 1/2}{1/z - 1/2} = \\frac{0 + 1/2}{0 - 1/2} = -1 $$\n    由于极限是 $-1$ 而不是 $0$，该方法不是L-稳定的。\n\n### 任务B：刚性振荡机理\n\n缺乏L-稳定性是导致求解刚性问题时出现不期望行为的原因。一个刚性常微分方程（ODE）的解中包含以极不相同的速率衰减的分量。高度稳定的分量对应于具有大的负实部的特征值 $\\lambda$。\n\n对于梯形法则，当 $\\operatorname{Re}(\\lambda)$ 是大的负数时，对于一个适中的步长 $h$， $z = h\\lambda$ 的值也是大的负数。正如我们刚才所证明的，对于这样的 $z$，放大因子 $R(z) \\to -1$。这意味着数值解遵循递推关系 $y_{n+1} \\approx -y_n$。\n\n这导致数值解中出现持续不衰减的振荡（例如，$y_0, -y_0, y_0, -y_0, \\dots$）。然而，真实解的分量 $e^{\\lambda t}$ 应该极快地且无振荡地衰减到零。数值方法无法阻尼刚性分量的这种失败，正是一个方法是A-稳定但非L-稳定的标志。\n\n对于具体问题 $y' = \\lambda y$，其中 $\\lambda = -10000$，步长 $h=0.1$，我们有 $z = h\\lambda = 0.1 \\times (-10000) = -1000$。放大因子为\n$$ R(-1000) = \\frac{1 - 1000/2}{1 + 1000/2} = \\frac{-499}{501} \\approx -0.996 $$\n这个值非常接近 $-1$，所以我们预期 $y_{n+1} \\approx -y_n$，导致振荡衰减得非常慢，其幅值 $|y_n| = |R|^n |y_0|$ 保持在接近 $|y_0|$ 的水平。相比之下，真实解 $y(t) = y_0 e^{-10000t}$ 几乎瞬间就变得可以忽略不计。例如，在第一步结束时，$y(0.1) = y_0 e^{-1000} \\approx y_0 \\times 10^{-435}$。数值解完全无法捕捉到这种快速衰减。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs, analyzes, and demonstrates the properties of the trapezoidal rule,\n    a linear multistep method that is A-stable but not L-stable.\n    \"\"\"\n    \n    # Task A: Define the method.\n    # The method is the trapezoidal rule: y_{n+1} - y_n = h/2 * (f_n + f_{n+1})\n    # This is a one-step method (s=1).\n    # alpha_0*y_n + alpha_1*y_{n+1} = h * (beta_0*f_n + beta_1*f_{n+1})\n    alpha = np.array([-1.0, 1.0])\n    beta = np.array([0.5, 0.5])\n    \n    # 1) Amplification factor R(z) for the trapezoidal rule\n    # R(z) = (1 + z/2) / (1 - z/2)\n    def get_R(z: complex) - complex:\n        return (1.0 + 0.5 * z) / (1.0 - 0.5 * z)\n\n    # 2) Consistency test\n    # Condition 1: sum(alpha_j) = 0\n    # Condition 2: sum(j * alpha_j) = sum(beta_j)\n    consistency_c1 = np.isclose(np.sum(alpha), 0.0, atol=1e-12)\n    rho_prime_at_1 = np.sum(np.arange(len(alpha)) * alpha)\n    sigma_at_1 = np.sum(beta)\n    consistency_c2 = np.isclose(rho_prime_at_1, sigma_at_1, atol=1e-12)\n    consistency_ok = bool(consistency_c1 and consistency_c2)\n\n    # 3) A-stability spot checks\n    # Check if |R(z)| = 1 for Re(z) = 0.\n    # We add a tolerance to the right side to account for floating point error\n    # where |R(z)| should be exactly 1 but might be 1 + epsilon.\n    z_tests = [-1.0, -100.0, -1.0 + 10.0j, -50.0 + 200.0j]\n    astability_checks = []\n    for z in z_tests:\n        # For A-stability, |R(z)| must be = 1.\n        # Adding a small tolerance to the check.\n        is_stable = abs(get_R(z)) = 1.0 + 1e-12\n        astability_checks.append(is_stable)\n\n    # 4) Numerical L-stability check\n    # Check if lim_{Re(z) -> -inf} R(z) = 0.\n    # We use a large negative z as a proxy.\n    z_star = -1.0e6\n    R_mag_at_large_neg_z = abs(get_R(z_star))\n    # For L-stability, this magnitude should be close to 0. We test if it's  10^-3.\n    # For the trapezoidal rule, |R(z)| -> 1, so this check should fail.\n    lstability_check = bool(R_mag_at_large_neg_z  1e-3)\n    \n    # 5) Stiff-oscillation demonstration\n    lam = -10000.0\n    y0 = 1.0\n    T = 1.0\n    h = 0.1\n    N = int(T / h)\n    \n    # The numerical solution is y_n = R(h*lambda)^n * y_0\n    z = h * lam\n    amp_factor = get_R(z)\n    \n    y = np.array([y0 * (amp_factor**n) for n in range(N + 1)])\n    \n    # Count sign changes\n    sign_changes = 0\n    for i in range(N):\n        if y[i] * y[i+1]  0:\n            sign_changes += 1\n            \n    # Final numerical magnitude\n    yN_mag = abs(y[N])\n    \n    # Exact final magnitude\n    # y(T) = y(0) * exp(lambda * T)\n    # np.exp(-10000) underflows to 0.0 in standard double precision\n    yT_exact = y0 * np.exp(lam * T)\n    yT_exact_mag = abs(yT_exact)\n    \n    # Absolute error\n    abs_error = abs(y[N] - yT_exact)\n    \n    stiff_results = [sign_changes, yN_mag, yT_exact_mag, abs_error]\n\n    # Final output formatting\n    # Must match: [True,[b_1,b_2,b_3,b_4],False,[k,a,e,\\varepsilon]]\n    astab_str = ','.join(map(str, astability_checks))\n    stiff_str = ','.join(map(str, stiff_results))\n    \n    # Python's str() for booleans is \"True\" or \"False\", which is what's needed.\n    # f-string interpolation automatically calls str()\n    print(f\"[{consistency_ok},[{astab_str}],{lstability_check},[{stiff_str}]]\")\n\nsolve()\n```", "id": "3202108"}, {"introduction": "在见证了非L-稳定方法的局限性后，一个自然的问题是：L-稳定的方法是否总是更优越？本练习将挑战这一简单结论。通过在一个弱阻尼振荡问题上比较L-稳定的向后欧拉法和A-稳定的梯形法则，你将发现，在某些情况下，梯形法则的更高精度使其成为更好的选择。这突显了在方法选择中，数值阻尼与精度之间的关键权衡。[@problem_id:3202129]", "problem": "本题要求您在弱阻尼振荡的背景下，对两种用于常微分方程的隐式单步方法进行数值稳定性比较，并将其形式化和实现。这两种方法分别是隐式梯形法则和后向欧拉法。该比较是使用 Dahlquist 线性检验方程进行的，该方程是绝对稳定性分析的基础。\n\n出发点与定义：\n- 考虑 Dahlquist 线性检验方程 $y'(t) = \\lambda y(t)$，其中 $\\lambda \\in \\mathbb{C}$ 且 $t \\in \\mathbb{R}$。对于恒定步长 $h  0$，定义 $z = h \\lambda$。\n- 将数值单步法应用于 Dahlquist 检验方程会导出一个形式为 $y_{n+1} = R(z) y_n$ 的线性递推关系，其中 $R(z)$ 被称为稳定性（放大）函数。\n- 如果对于所有满足 $\\operatorname{Re}(z) \\le 0$ 的 $z \\in \\mathbb{C}$，都有 $|R(z)| \\le 1$，则称该方法是 A-稳定的。\n- 如果一个方法是 A-稳定的，并且在负实轴上额外满足 $\\lim_{z \\to -\\infty} R(z) = 0$，则称该方法是 L-稳定的。\n\n任务描述：\n1. 根据后向欧拉法和隐式梯形法则应用于 $y'(t) = \\lambda y(t)$ 的定义，推导出相应的稳定性函数 $R_{\\mathrm{BE}}(z)$ 和 $R_{\\mathrm{TR}}(z)$，其中 $z = h \\lambda$。\n2. 考虑复参数 $\\lambda = -\\gamma + i \\omega$，其中 $\\gamma \\ge 0$ 且 $\\omega  0$。当 $\\gamma$ 很小时，这代表一个弱阻尼振荡。对于给定的步长 $h$ 和步数 $N$，精确解满足 $|y(Nh)| = |y(0)| \\exp(-\\gamma N h)$。数值方法会导出一个离散的振幅演化 $|y_N| = |R(z)|^N |y_0|$。为了比较振幅保持性，将 $N$ 步后的振幅误差定义为\n$$\nE_{\\mathrm{amp}} = \\left|\\, |R(z)|^N - \\exp(-\\gamma N h) \\,\\right|.\n$$\n3. 实现一个程序，对于下面测试套件中的每个测试用例，使用推导出的 $R_{\\mathrm{BE}}(z)$ 和 $R_{\\mathrm{TR}}(z)$ 计算两种方法的 $E_{\\mathrm{amp}}$，并返回一个布尔值，该布尔值指示在该测试用例中隐式梯形法则的振幅误差是否严格小于后向欧拉法。也就是说，如果 $E_{\\mathrm{amp}}^{\\mathrm{TR}}  E_{\\mathrm{amp}}^{\\mathrm{BE}}$，则为每个测试用例返回 $\\mathrm{True}$，否则返回 $\\mathrm{False}$。\n\n科学真实性要求：\n- 使用 $\\gamma$ 较小的标量复数模型 $\\lambda = -\\gamma + i \\omega$ 来模拟弱阻尼振荡。此问题不涉及物理单位。没有明确使用角度，因此不需要指定角度单位。\n\n测试套件：\n- 用例 1 (正常路径，弱阻尼，中等步长)：$\\gamma = 0.01$，$\\omega = 10.0$， $h = 0.1$， $N = 100$。\n- 用例 2 (弱阻尼，靠近振荡区的大步长)：$\\gamma = 0.01$，$\\omega = 10.0$， $h = 0.5$， $N = 20$。\n- 用例 3 (无阻尼振荡器，振幅保持边界)：$\\gamma = 0.0$，$\\omega = 10.0$， $h = 0.2$， $N = 50$。\n- 用例 4 (强阻尼和大步长，说明 L-稳定性的优势)：$\\gamma = 50.0$，$\\omega = 10.0$， $h = 1.0$， $N = 10$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按顺序排列的测试用例的布尔结果，形式为方括号括起来的逗号分隔列表，例如 `[True,False,True,True]`。不应打印任何其他文本。", "solution": "用户提供了一个问题陈述以供验证和求解。\n\n### 第 1 步：提取已知条件\n- **Dahlquist 检验方程**: $y'(t) = \\lambda y(t)$，其中 $\\lambda \\in \\mathbb{C}$ 且 $t \\in \\mathbb{R}$。\n- **无量纲参数**: $z = h \\lambda$，对于恒定步长 $h  0$。\n- **数值递推**: $y_{n+1} = R(z) y_n$，其中 $R(z)$ 是稳定性（放大）函数。\n- **A-稳定性**: 如果对于所有满足 $\\operatorname{Re}(z) \\le 0$ 的 $z \\in \\mathbb{C}$，都有 $|R(z)| \\le 1$，则称方法是 A-稳定的。\n- **L-稳定性**: 如果一个方法是 A-稳定的，并且在负实轴上满足 $\\lim_{z \\to -\\infty} R(z) = 0$，则称其为 L-稳定的。\n- **任务 1**: 推导后向欧拉法的稳定性函数 $R_{\\mathrm{BE}}(z)$ 和隐式梯形法则的稳定性函数 $R_{\\mathrm{TR}}(z)$。\n- **模型参数**: $\\lambda = -\\gamma + i \\omega$，其中 $\\gamma \\ge 0$ 且 $\\omega  0$。\n- **总步数**: $N$。\n- **精确振幅**: $|y(Nh)| = |y(0)| \\exp(-\\gamma N h)$。\n- **数值振幅**: $|y_N| = |R(z)|^N |y_0|$。\n- **振幅误差定义**: $E_{\\mathrm{amp}} = \\left|\\, |R(z)|^N - \\exp(-\\gamma N h) \\,\\right|$。\n- **任务 2 和 3**: 实现一个程序来评估两种方法的 $E_{\\mathrm{amp}}$，如果 $E_{\\mathrm{amp}}^{\\mathrm{TR}}  E_{\\mathrm{amp}}^{\\mathrm{BE}}$ 则返回 $\\mathrm{True}$，否则返回 $\\mathrm{False}$。\n- **测试套件**:\n    - 用例 1: $\\gamma = 0.01$, $\\omega = 10.0$, $h = 0.1$, $N = 100$。\n    - 用例 2: $\\gamma = 0.01$, $\\omega = 10.0$, $h = 0.5$, $N = 20$。\n    - 用例 3: $\\gamma = 0.0$, $\\omega = 10.0$, $h = 0.2$, $N = 50$。\n    - 用例 4: $\\gamma = 50.0$, $\\omega = 10.0$, $h = 1.0$, $N = 10$。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据指定标准对问题进行评估：\n- **科学上成立**: 该问题是常微分方程数值分析中的一个典型练习。A-稳定性、L-稳定性、Dahlquist 检验方程以及具体方法（后向欧拉法、梯形法则）等概念都是科学计算领域中基础且公认的。所有定义和前提在事实上都是正确的。\n- **适定的**: 该问题以数学精度进行了规定。它提供了计算所需量所需的所有必要定义、方程和参数。比较标准是明确的，可以为每个测试用例得出唯一的布尔结果。\n- **客观的**: 问题以正式、客观的语言陈述。分析基于定量的误差度量 $E_{\\mathrm{amp}}$，没有主观性。\n- **其他缺陷**: 该问题没有其他列出的缺陷。它是可形式化的，与指定主题直接相关，是完整的、一致的、科学上可验证的。它并非无足轻重，因为它需要正确推导和实现标准但并非显而易见的数值分析概念。\n\n### 第 3 步：结论与行动\n该问题是**有效的**。将提供一个合理的解决方案。\n\n### 解法\n\n目标是比较后向欧拉法和隐式梯形法在应用于弱阻尼振荡模型方程时的振幅误差。这一比较将通过绝对稳定性理论的视角进行。\n\n**1. 稳定性函数的推导**\n\n单步法的稳定性函数 $R(z)$ 是通过将该方法应用于 Dahlquist 检验方程 $y'(t) = \\lambda y(t)$，并将数值解在第 $n+1$ 步的表达式 $y_{n+1}$ 写成 $y_{n+1} = R(z) y_n$ 的形式推导出来的，其中 $z = h\\lambda$。\n\n**后向欧拉法 (BE):**\n后向欧拉法的公式为：\n$$ y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}) $$\n对于检验方程，$f(t,y) = \\lambda y$。代入可得：\n$$ y_{n+1} = y_n + h \\lambda y_{n+1} $$\n我们求解 $y_{n+1}$：\n$$ y_{n+1} (1 - h\\lambda) = y_n $$\n$$ y_{n+1} = \\frac{1}{1 - h\\lambda} y_n $$\n通过定义 $z = h\\lambda$，我们确定后向欧拉法的稳定性函数为：\n$$ R_{\\mathrm{BE}}(z) = \\frac{1}{1-z} $$\n\n**隐式梯形法则 (TR) 法：**\n隐式梯形法则的公式为：\n$$ y_{n+1} = y_n + \\frac{h}{2} [f(t_n, y_n) + f(t_{n+1}, y_{n+1})] $$\n代入 $f(t,y) = \\lambda y$ 可得：\n$$ y_{n+1} = y_n + \\frac{h}{2} (\\lambda y_n + \\lambda y_{n+1}) $$\n我们将包含 $y_{n+1}$ 的项收集到左侧，将包含 $y_n$ 的项收集到右侧：\n$$ y_{n+1} \\left(1 - \\frac{h\\lambda}{2}\\right) = y_n \\left(1 + \\frac{h\\lambda}{2}\\right) $$\n求解 $y_{n+1}$：\n$$ y_{n+1} = \\frac{1 + h\\lambda/2}{1 - h\\lambda/2} y_n $$\n利用 $z = h\\lambda$，隐式梯形法则的稳定性函数为：\n$$ R_{\\mathrm{TR}}(z) = \\frac{1 + z/2}{1 - z/2} $$\n\n**2. 振幅误差分析**\n\n问题要求比较两种方法的振幅误差 $E_{\\mathrm{amp}}$。该误差定义为 $N$ 步后的数值振幅衰减因子 $|R(z)|^N$ 与精确振幅衰减因子 $\\exp(-\\gamma N h)$ 之间的绝对差。\n$$ E_{\\mathrm{amp}} = \\left|\\, |R(z)|^N - \\exp(-\\gamma N h) \\,\\right| $$\n参数 $z$ 是根据每个测试用例给定的 $\\gamma$、$\\omega$ 和 $h$ 计算得出的：\n$$ z = h\\lambda = h(-\\gamma + i\\omega) = -h\\gamma + i(h\\omega) $$\n已知这两种方法都是 A-稳定的，这意味着对于任何稳定的物理系统（$\\operatorname{Re}(\\lambda) \\le 0$），数值解都不会出现伪增长。然而，它们的定量行为有所不同。后向欧拉法是 L-稳定的，因为 $\\lim_{z\\to-\\infty} R_{\\mathrm{BE}}(z) = \\lim_{z\\to-\\infty} \\frac{1}{1-z} = 0$。对于某些分量应快速衰减的刚性问题，此特性是理想的。梯形法则不是 L-稳定的，因为 $\\lim_{z\\to-\\infty} R_{\\mathrm{TR}}(z) = \\lim_{z\\to-\\infty} \\frac{1+z/2}{1-z/2} = -1$。这意味着对于 $\\lambda$ 的实部为非常大的负数的分量，梯形法则会将其衰减到接近 $(-1)^n y_0$ 的值，引入了伪振荡，而不是将它们衰减到零。然而，梯形法则是二阶精确的，而后向欧拉法只是一阶精确。这表明对于较小的步长，梯形法则将更精确。\n\n**3. 算法流程**\n\n对于由元组 $(\\gamma, \\omega, h, N)$ 指定的每个测试用例：\n1.  计算复数 $z = h(-\\gamma + i\\omega)$。\n2.  计算稳定性函数值 $R_{\\mathrm{BE}}(z) = \\frac{1}{1-z}$ 和 $R_{\\mathrm{TR}}(z) = \\frac{1+z/2}{1-z/2}$。\n3.  计算绝对值 $|R_{\\mathrm{BE}}(z)|$ 和 $|R_{\\mathrm{TR}}(z)|$。\n4.  计算 $N$ 步后的数值振幅因子：$|R_{\\mathrm{BE}}(z)|^N$ 和 $|R_{\\mathrm{TR}}(z)|^N$。\n5.  计算精确振幅因子：$A_{\\mathrm{exact}} = \\exp(-\\gamma N h)$。\n6.  计算每种方法的振幅误差：\n    -   $E_{\\mathrm{amp}}^{\\mathrm{BE}} = \\big| |R_{\\mathrm{BE}}(z)|^N - A_{\\mathrm{exact}} \\big|$\n    -   $E_{\\mathrm{amp}}^{\\mathrm{TR}} = \\big| |R_{\\mathrm{TR}}(z)|^N - A_{\\mathrm{exact}} \\big|$\n7.  进行比较：确定是否 $E_{\\mathrm{amp}}^{\\mathrm{TR}}  E_{\\mathrm{amp}}^{\\mathrm{BE}}$。结果是一个布尔值。\n对所有测试用例重复此过程，并将布尔结果收集到一个列表中。\n-   **用例 1 和 2**：此处，阻尼较弱，步长适中。更高的精度阶数（TR 为 2 阶，BE 为 1 阶）预计会使梯形法则具有显著优势。\n-   **用例 3**：这是一个纯振荡系统（$\\gamma=0$）。精确解具有恒定振幅（$A_{\\mathrm{exact}}=1$）。已知梯形法则对于此类问题是能量守恒的，这意味着当 $\\operatorname{Re}(z)=0$ 时，有 $|R_{\\mathrm{TR}}(z)|=1$。因此，$E_{\\mathrm{amp}}^{\\mathrm{TR}}$ 将为零。后向欧拉法会引入数值耗散，因此 $|R_{\\mathrm{BE}}(z)|1$，导致非零误差。\n-   **用例 4**：此用例代表一个具有强阻尼的刚性问题。项 $\\exp(-\\gamma N h)$ 将非常接近于 $0$。后向欧拉法的 L-稳定性将确保 $|R_{\\mathrm{BE}}(z)|$ 非常小，从而使得 $E_{\\mathrm{amp}}^{\\mathrm{BE}}$ 也非常小。梯形法则缺乏 L-稳定性，意味着 $|R_{\\mathrm{TR}}(z)|$ 将接近于 $1$，导致较大的振幅误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing amplitude errors for Backward Euler\n    and Implicit Trapezoid methods for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (gamma, omega, h, N)\n    test_cases = [\n        (0.01, 10.0, 0.1, 100),   # Case 1\n        (0.01, 10.0, 0.5, 20),    # Case 2\n        (0.0, 10.0, 0.2, 50),     # Case 3\n        (50.0, 10.0, 1.0, 10),    # Case 4\n    ]\n\n    results = []\n    for gamma, omega, h, N in test_cases:\n        # Calculate the complex parameter z = h * lambda\n        z = h * (-gamma + 1j * omega)\n\n        # ---- Backward Euler (BE) Method ----\n        # Stability function R_BE(z) = 1 / (1 - z)\n        R_be = 1.0 / (1.0 - z)\n        # Numerical amplitude after N steps\n        num_amp_be = np.abs(R_be)**N\n\n        # ---- Implicit Trapezoid (TR) Method ----\n        # Stability function R_TR(z) = (1 + z/2) / (1 - z/2)\n        R_tr = (1.0 + z / 2.0) / (1.0 - z / 2.0)\n        # Numerical amplitude after N steps\n        num_amp_tr = np.abs(R_tr)**N\n\n        # ---- Exact Amplitude ----\n        # The exact amplitude decay factor is exp(-gamma * N * h)\n        exact_amp = np.exp(-gamma * N * h)\n\n        # ---- Amplitude Error Calculation ----\n        # E_amp = | |R(z)|^N - exp(-gamma * N * h) |\n        E_amp_be = np.abs(num_amp_be - exact_amp)\n        E_amp_tr = np.abs(num_amp_tr - exact_amp)\n\n        # ---- Comparison ----\n        # Check if the trapezoid rule has a strictly smaller amplitude error\n        comparison_result = E_amp_tr  E_amp_be\n        results.append(comparison_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3202129"}]}