{"hands_on_practices": [{"introduction": "隐式方法的核心挑战在于，每一步都需要求解一个方程来确定下一个时间步的状态。本练习将引导你完成一个隐式欧拉法的单步计算，这是一个基础但至关重要的实践。通过解决这个关于CPU散热的实际问题[@problem_id:2178316]，你将掌握将微分方程代入隐式格式并代数求解未来状态的基本技能。", "problem": "一个中央处理器（CPU）在可变负载下的简化热模型由以下一阶常微分方程描述：\n$$ \\frac{dT}{dt} = -k(T - T_a) + P(t) $$\n其中，$T(t)$ 是 CPU 在时间 $t$（分钟）时的温度，单位为摄氏度（$^\\circ\\text{C}$），$k$ 是散热常数，$T_a$ 是恒定的环境温度，$P(t)$ 表示 CPU 活动产生的热量。\n\n假设参数如下：\n- 散热常数，$k = 0.5 \\text{ min}^{-1}$\n- 环境温度，$T_a = 25^\\circ\\text{C}$\n- 生热函数，$P(t) = P_0 \\cos(\\omega t)$，其中 $P_0 = 10^\\circ\\text{C}/\\text{min}$ 且 $\\omega = \\frac{\\pi}{6} \\text{ rad/min}$。\n- CPU 的初始温度为 $T(0) = 85^\\circ\\text{C}$。\n\n为了预测温度的演变，采用了一种数值方法。下一个时间步 $t_{n+1}$ 的温度 $T_{n+1}$ 是根据当前时间步 $t_n$ 的温度 $T_n$，使用以下更新规则来估计的：\n$$ T_{n+1} = T_n + h \\left( \\frac{dT}{dt} \\right)_{t=t_{n+1}, T=T_{n+1}} $$\n其中 $h = t_{n+1} - t_n$ 是时间步长。\n\n使用该数值方法的一个步长（步长为 $h = 0.5$ 分钟），计算 CPU 在 $t = 0.5$ 分钟时的近似温度。\n\n用摄氏度表示你的答案，并四舍五入到四位有效数字。", "solution": "给定一阶常微分方程\n$$\n\\frac{dT}{dt}=-k\\left(T-T_{a}\\right)+P(t), \\quad P(t)=P_{0}\\cos(\\omega t),\n$$\n我们要应用步长为 $h$ 的隐式（向后）欧拉法，从 $t_{0}=0$ 到 $t_{1}=h$ 进行一步计算。向后欧拉法的更新公式为\n$$\nT_{1}=T_{0}+h\\left.\\frac{dT}{dt}\\right|_{t=t_{1},\\,T=T_{1}}=T_{0}+h\\big(-k(T_{1}-T_{a})+P_{0}\\cos(\\omega t_{1})\\big).\n$$\n求解这个关于 $T_{1}$ 的方程。展开右边并合并含 $T_{1}$ 的项：\n$$\nT_{1}=T_{0}-hkT_{1}+hkT_{a}+hP_{0}\\cos(\\omega t_{1}).\n$$\n将含 $T_{1}$ 的项移到左边：\n$$\nT_{1}+hkT_{1}=T_{0}+hkT_{a}+hP_{0}\\cos(\\omega t_{1}).\n$$\n对左边进行因式分解并求解 $T_{1}$：\n$$\nT_{1}=\\frac{T_{0}+hkT_{a}+hP_{0}\\cos(\\omega t_{1})}{1+hk}.\n$$\n现在代入给定数据 $T_{0}=85$, $k=0.5$, $T_{a}=25$, $P_{0}=10$, $\\omega=\\frac{\\pi}{6}$, $h=0.5$ 以及 $t_{1}=0.5$：\n$$\n1+hk=1+0.5\\times 0.5=1.25,\n$$\n$$\nhkT_{a}=0.5\\times 0.5\\times 25=6.25,\n$$\n$$\nhP_{0}\\cos(\\omega t_{1})=0.5\\times 10\\times \\cos\\!\\left(\\frac{\\pi}{6}\\times 0.5\\right)=5\\cos\\!\\left(\\frac{\\pi}{12}\\right).\n$$\n因此\n$$\nT_{1}=\\frac{85+6.25+5\\cos\\!\\left(\\frac{\\pi}{12}\\right)}{1.25}.\n$$\n使用 $\\cos\\!\\left(\\frac{\\pi}{12}\\right)\\approx 0.9659258263$，我们得到\n$$\nT_{1}\\approx \\frac{85+6.25+4.829629131}{1.25}=\\frac{96.079629131}{1.25}\\approx 76.86370331.\n$$\n四舍五入到四位有效数字，在 $t=0.5$ 分钟时的近似温度是 $76.86$ 摄氏度。", "answer": "$$\\boxed{76.86}$$", "id": "2178316"}, {"introduction": "对于由偏微分方程离散化而来的大规模常微分方程组，隐式方法的优势尤为突出，但这要求我们高效地求解每个时间步产生的线性方程组。本练习[@problem_id:3241515]聚焦于一个常见且重要场景：当系统矩阵为三对角时，如何利用其特殊结构。你将实现并验证托马斯算法（一种线性时间复杂度的三对角系统求解器），亲身体会专用算法相对于通用密集求解器带来的巨大效率提升。", "problem": "您需要为常微分方程（ODE）的初值问题（IVP）设计并分析一种高效的隐式时间步进方法。从常微分方程（ODE）的定义和初值问题（IVP）的陈述开始。考虑一个形式为 $y'(t) = A y(t)$（$t \\ge 0$）的线性系统，其中 $y(t) \\in \\mathbb{R}^n$ 且 $A \\in \\mathbb{R}^{n \\times n}$ 是一个三对角矩阵。目标是构造特定的三对角矩阵 $A$，并实现后向欧拉方法，使用一种避免完全矩阵求逆的算法来推进解的时间演化，同时保持计算效率和数值稳定性。\n\n您的程序必须：\n- 为每个测试用例构造一个指定大小为 $n$ 的三对角矩阵 $A$。三对角矩阵仅在其主对角线以及第一下对角线和第一上对角线上有非零元素。将下对角线表示为 $a_i$（$i=1,\\dots,n-1$），主对角线表示为 $d_i$（$i=1,\\dots,n$），上对角线表示为 $c_i$（$i=1,\\dots,n-1$）。\n- 为初值问题 $y'(t)=A y(t)$ 推导并实现单步后向欧拉方法（Backward Euler method (BE)），过程中不执行密集矩阵求逆。在从 $t^n$ 到 $t^{n+1} = t^n + h$ 的每个时间步中，建立并求解关于 $y^{n+1}$ 的线性系统，使用基于为三对角矩阵特化的高斯消元法（通常称为 Thomas 算法）的三对角求解器，该算法以 $\\mathcal{O}(n)$ 时间和 $\\mathcal{O}(n)$ 内存运行。\n- 通过将三对角求解器的结果与在每一步为同一线性系统使用密集线性求解器得到的结果进行比较，来验证三对角求解器的正确性，并报告最大绝对差值。\n\n使用以下测试套件。对于每个用例，执行指定的操作，并记录一个浮点数，该数等于由三对角求解器计算的解与由密集求解器计算的解之间差值的无穷范数（最大绝对值）。本问题不涉及物理单位。\n\n测试套件：\n- 用例 1（正常路径，小 $n$）：设 $n=5$。定义 $A$ 为 $d_i=-2$（$i=1,\\dots,5$），$a_i=1$（$i=1,\\dots,4$），以及 $c_i=1$（$i=1,\\dots,4$）。使用时间步长 $h=0.05$。取初始条件 $y^0 = [1,0,0,0,0]^T$。执行一个单步后向欧拉步骤，并记录三对角解与密集解之间差值的无穷范数。\n- 用例 2（仅对角线，边界条件覆盖）：设 $n=10$。定义 $A$ 为对角矩阵，其中 $d_i=-i$（$i=1,\\dots,10$），且 $a_i=0$, $c_i=0$。使用 $h=0.2$。取 $y^0=[1,1,1,1,1,1,1,1,1,1]^T$。执行一个单步后向欧拉步骤，并记录差值。\n- 用例 3（更大维度，强对角占优）：设 $n=50$。定义 $A$ 为 $d_i=-5$（$i=1,\\dots,50$），$a_i=-2$（$i=1,\\dots,49$），$c_i=-1$（$i=1,\\dots,49$）。使用 $h=0.1$。取 $y^0$，其分量为 $y^0_j = j/50$（$j=0,\\dots,49$）。执行一个单步后向欧拉步骤，并记录差值。\n- 用例 4（边界情况 $h=0$）：设 $n=8$。定义 $A$ 为 $d_i=-3$（$i=1,\\dots,8$），$a_i=1$（$i=1,\\dots,7$），$c_i=1$（$i=1,\\dots,7$）。使用 $h=0$。取 $y^0$，其分量为 $y^0_j = j$（$j=0,\\dots,7$）。执行一个单步后向欧拉步骤，并记录差值。\n- 用例 5（多步，累积稳定性）：设 $n=20$。定义 $A$ 为 $d_i=-1.6$（$i=1,\\dots,20$），$a_i=0.8$（$i=1,\\dots,19$），$c_i=0.9$（$i=1,\\dots,19$）。使用 $h=0.05$。取 $y^0=[1,1,\\dots,1]^T \\in \\mathbb{R}^{20}$。执行 100 个均匀的后向欧拉步骤到达 $t=5.0$，并记录基于三对角求解器的结果与基于密集求解器的结果之间的差值。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是为用例 $i$ 指定的浮点差值。\n\n实现必须避免任何完全矩阵求逆，并且必须使用利用三对角结构以实现每次求解为线性时间复杂度的算法。所有计算均为纯数学计算，不涉及物理单位。不涉及角度。不涉及百分比；任何分数都应表示为小数。程序必须是自包含的，不需要任何输入，并遵守指定的执行环境。", "solution": "一个常微分方程（ODE）系统的初值问题（IVP）由微分方程 $y'(t) = f(t, y(t))$（$t \\ge t_0$）以及一个初始条件 $y(t_0) = y_0$ 定义。所考虑的问题是一个线性时不变系统，其形式为：\n$$\ny'(t) = A y(t), \\quad y(0) = y^0\n$$\n其中 $y(t) \\in \\mathbb{R}^n$ 是状态向量，而 $A \\in \\mathbb{R}^{n \\times n}$ 是一个常数三对角矩阵。\n\n为了数值求解此初值问题，我们采用一种时间步进方法。问题指定使用后向欧拉（BE）方法，这是一种以其强稳定性（A-稳定性）而闻名的隐式方法。我们用一个均匀的时间步长 $h$ 来离散化时间域，使得 $t^k = k h$（$k=0, 1, 2, \\dots$）。每个时间步的解记为 $y^k \\approx y(t^k)$。\n\n后向欧拉方法使用后向差分公式来近似下一个时间步 $t^{n+1}$ 处的导数：\n$$\ny'(t^{n+1}) \\approx \\frac{y^{n+1} - y^n}{h}\n$$\n将此近似值代入在 $t=t^{n+1}$ 处求值的常微分方程中，我们得到：\n$$\n\\frac{y^{n+1} - y^n}{h} = A y^{n+1}\n$$\n这个方程是隐式的，因为未知数 $y^{n+1}$ 出现在等式两边。为了求解 $y^{n+1}$，我们重新整理这些项：\n$$\ny^{n+1} - h A y^{n+1} = y^n\n$$\n将 $y^{n+1}$ 提取出来，得到一个线性方程组：\n$$\n(I - hA) y^{n+1} = y^n\n$$\n其中 $I$ 是 $n \\times n$ 的单位矩阵。在每个时间步，我们必须根据上一步的已知向量 $y^n$ 来求解这个关于未知向量 $y^{n+1}$ 的线性系统。\n\n矩阵 $A$ 是三对角的。设其对角线由向量 $d$（主对角线，长度为 $n$），$a$（下对角线，长度为 $n-1$）和 $c$（上对角线，长度为 $n-1$）表示。使用基于 1 的索引， $A$ 的非零元素为 $A_{i,i} = d_i$（$i=1,\\dots,n$），$A_{i+1,i} = a_i$（$i=1,\\dots,n-1$），以及 $A_{i,i+1} = c_i$（$i=1,\\dots,n-1$）。\n\n待求解的线性系统的矩阵 $M = I - hA$ 继承了这种三对角结构。其对角线为：\n- 主对角线：$\\tilde{d}_i = 1 - h d_i$（$i=1,\\dots,n$）。\n- 下对角线：$\\tilde{a}_i = -h a_i$（$i=1,\\dots,n-1$）。\n- 上对角线：$\\tilde{c}_i = -h c_i$（$i=1,\\dots,n-1$）。\n\n求解三对角系统比求解一般的密集系统要高效得多。直接对矩阵 $M$ 求逆将是一个 $\\mathcal{O}(n^3)$ 的操作，并且会破坏稀疏结构，需要 $\\mathcal{O}(n^2)$ 的内存。相反，我们使用 Thomas 算法（也称为三对角矩阵算法或 TDMA），这是一种特殊形式的高斯消元法，它使用 $\\mathcal{O}(n)$ 的时间和 $\\mathcal{O}(n)$ 的内存来求解该系统。\n\nThomas 算法包括两个阶段：前向消元和后向代入。考虑系统 $M x = y^n$，使用 $M$ 的对角线 $\\tilde{a}_i$（下）、$\\tilde{d}_i$（主）和 $\\tilde{c}_i$（上）按分量写出。\n$$\n\\tilde{a}_{i-1} x_{i-1} + \\tilde{d}_i x_i + \\tilde{c}_i x_{i+1} = y^n_i \\quad (\\text{with } \\tilde{a}_0=0, \\tilde{c}_n=0)\n$$\n1.  **前向消元**：该算法修改上对角线系数和右侧向量。我们计算新的系数 $c'_i$ 和 $y'_{i}$（为实现清晰起见，使用基于 0 的索引）：\n    - 对于 $i=0$：\n      $$\n      c'_0 = \\frac{\\tilde{c}_0}{\\tilde{d}_0}, \\quad y'_0 = \\frac{y^n_0}{\\tilde{d}_0}\n      $$\n    - 对于 $i=1, \\dots, n-2$：\n      $$\n      c'_i = \\frac{\\tilde{c}_i}{\\tilde{d}_i - \\tilde{a}_{i-1} c'_{i-1}}, \\quad y'_i = \\frac{y^n_i - \\tilde{a}_{i-1} y'_{i-1}}{\\tilde{d}_i - \\tilde{a}_{i-1} c'_{i-1}}\n      $$\n    - 对于 $i=n-1$：\n      $$\n      y'_{n-1} = \\frac{y^n_{n-1} - \\tilde{a}_{n-2} y'_{n-2}}{\\tilde{d}_{n-1} - \\tilde{a}_{n-2} c'_{n-2}}\n      $$\n    这将系统转换为上双对角形式。\n\n2.  **后向代入**：通过向后代入找到解 $x = y^{n+1}$：\n    - 对于 $i=n-1$：\n      $$\n      x_{n-1} = y'_{n-1}\n      $$\n    - 对于 $i=n-2, \\dots, 0$：\n      $$\n      x_i = y'_i - c'_i x_{i+1}\n      $$\n\n对于每个测试用例，我们执行一步或多步后向欧拉方法。我们构造矩阵 $M=I-hA$ 及其对角线，以及右侧向量 $y^n$。然后我们使用实现的 Thomas 算法（$y_{\\text{tri}}^{n+1}$）和由标准库提供的通用密集线性求解器（$y_{\\text{dense}}^{n+1}$）来求解 $y^{n+1}$ 以进行验证。每个用例的最终结果是差向量的无穷范数，即 $\\max_i |(y_{\\text{tri}}^{n+1})_i - (y_{\\text{dense}}^{n+1})_i|$。对于多步用例，此比较在最后一个时间步之后执行。测试用例中的矩阵被选择为使得 $I-hA$ 是对角占优的，从而确保 Thomas 算法在没有主元选择的情况下的数值稳定性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the Backward Euler method\n    with a tridiagonal solver.\n    \"\"\"\n\n    def construct_dense_A(n, d_vals, a_vals, c_vals):\n        \"\"\"Constructs the dense n x n tridiagonal matrix A.\"\"\"\n        A = np.zeros((n, n))\n        # Populate main diagonal\n        A += np.diag(d_vals)\n        # Populate sub-diagonal\n        if len(a_vals)  0:\n            A += np.diag(a_vals, k=-1)\n        # Populate super-diagonal\n        if len(c_vals)  0:\n            A += np.diag(c_vals, k=1)\n        return A\n\n    def thomas_algorithm(a, d, c, b):\n        \"\"\"\n        Solves a tridiagonal system of equations Ax=b using the Thomas algorithm.\n        a: sub-diagonal (length n-1)\n        d: main diagonal (length n)\n        c: super-diagonal (length n-1)\n        b: right-hand side vector (length n)\n        \n        The algorithm is not performed in-place to avoid side effects.\n        \"\"\"\n        n = len(d)\n        if n == 0:\n            return np.array([])\n        if n == 1:\n            return np.array([b[0] / d[0]])\n\n        # Create copies to avoid modifying original arrays\n        c_prime = np.zeros(n - 1)\n        d_prime = np.zeros(n)\n        x = np.zeros(n)\n\n        # Forward elimination\n        c_prime[0] = c[0] / d[0]\n        d_prime[0] = b[0] / d[0]\n\n        for i in range(1, n - 1):\n            denom = d[i] - a[i - 1] * c_prime[i - 1]\n            c_prime[i] = c[i] / denom\n            d_prime[i] = (b[i] - a[i - 1] * d_prime[i - 1]) / denom\n\n        denom_last = d[n - 1] - a[n - 2] * c_prime[n - 2]\n        d_prime[n - 1] = (b[n-1] - a[n-2] * d_prime[n-2]) / denom_last\n\n        # Backward substitution\n        x[n - 1] = d_prime[n - 1]\n        for i in range(n - 2, -1, -1):\n            x[i] = d_prime[i] - c_prime[i] * x[i + 1]\n\n        return x\n\n    # Define the test cases from the problem statement.\n    # Each tuple: (n, d_func, a_func, c_func, h, y0_func, steps)\n    test_cases = [\n        # Case 1\n        (5, lambda n: np.full(n, -2.0), lambda n: np.full(n - 1, 1.0), lambda n: np.full(n - 1, 1.0), 0.05, \n         lambda n: np.array([1.0] + [0.0]*(n-1)), 1),\n        # Case 2\n        (10, lambda n: -np.arange(1, n + 1, dtype=float), lambda n: np.full(n - 1, 0.0), lambda n: np.full(n - 1, 0.0), 0.2, \n         lambda n: np.ones(n), 1),\n        # Case 3\n        (50, lambda n: np.full(n, -5.0), lambda n: np.full(n - 1, -2.0), lambda n: np.full(n - 1, -1.0), 0.1, \n         lambda n: np.arange(n, dtype=float) / n, 1),\n        # Case 4\n        (8, lambda n: np.full(n, -3.0), lambda n: np.full(n - 1, 1.0), lambda n: np.full(n - 1, 1.0), 0.0,\n         lambda n: np.arange(n, dtype=float), 1),\n        # Case 5\n        (20, lambda n: np.full(n, -1.6), lambda n: np.full(n - 1, 0.8), lambda n: np.full(n - 1, 0.9), 0.05,\n         lambda n: np.ones(n), 100),\n    ]\n\n    results = []\n    for n, d_func, a_func, c_func, h, y0_func, steps in test_cases:\n        # Construct diagonals and initial condition\n        d_A = d_func(n)\n        a_A = a_func(n)\n        c_A = c_func(n)\n        y0 = y0_func(n)\n\n        # Construct dense matrix A for validation\n        A_dense = construct_dense_A(n, d_A, a_A, c_A)\n        \n        # System to solve is (I - hA)y_next = y_prev\n        M_dense = np.eye(n) - h * A_dense\n\n        # Diagonals of M = I - hA\n        # Sub-diagonal mapping: a_M[i] is for row i+1, corresponds to a_A[i]\n        # Super-diagonal mapping: c_M[i] is for row i, corresponds to c_A[i]\n        d_M = 1.0 - h * d_A\n        if n  1:\n            a_M = -h * a_A\n            c_M = -h * c_A\n        else: # Handle n=1 case\n            a_M = np.array([])\n            c_M = np.array([])\n            \n        y_tri = y0.copy()\n        y_dense = y0.copy()\n\n        for _ in range(steps):\n            # Solve using Thomas algorithm\n            y_tri = thomas_algorithm(a_M, d_M, c_M, y_tri)\n            # Solve using dense solver for validation\n            y_dense = np.linalg.solve(M_dense, y_dense)\n\n        # Calculate the infinity norm of the difference\n        diff = np.max(np.abs(y_tri - y_dense))\n        results.append(diff)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3241515"}, {"introduction": "一个优秀的数值方法不仅要精确，还应能保持原物理系统的基本性质，如能量守恒。本练习[@problem_id:3241554]将带你探索几何数值积分的迷人世界，分析梯形法在模拟简谐振子时的能量保持特性。通过理论推导和数值实验，你将发现为何像梯形法这样的“辛积分器”能够在长期模拟中精确地保持系统的能量，这对于物理和工程仿真至关重要。", "problem": "考虑由二阶常微分方程 $y'' + \\omega^2 y = 0$ 给出的简谐振子初值问题，其中 $\\omega > 0$ 为常数。通过定义 $x = y$ 和 $v = y'$ 引入一阶系统，并写为 $z = \\begin{bmatrix} x \\\\ v \\end{bmatrix}$，使得 $z' = f(z)$，其中 $f(z) = A z$，$A$ 是一个常数矩阵。标准能量（哈密顿量）为 $H(x,v) = \\tfrac{1}{2}(v^2 + \\omega^2 x^2)$。用于初值问题 $z' = f(z)$ 的梯形方法（也称为 Crank-Nicolson 方法）可写为 $z_{n+1} = z_n + \\tfrac{h}{2}\\left(f(z_n) + f(z_{n+1})\\right)$，其中时间步长 $h > 0$。您的任务是：\n\n- 仅从简谐振子的定义、一阶系统表示和梯形方法公式出发，为此问题推导线性更新关系 $z_{n+1} = T(h) z_n$，其中 $T(h)$ 是一个依赖于 $h$ 和 $\\omega$ 的常数 $2 \\times 2$ 矩阵。用对称矩阵 $Q$ 表示离散能量 $H_n = \\tfrac{1}{2} z_n^\\top Q z_n$，并从第一性原理确定 $Q$。然后，仅使用代数恒等式和表征线性系统二次不变量的条件 $A^\\top Q + Q A = 0$，确定梯形方法对于任意 $h > 0$ 和任意 $\\omega \\ge 0$ 是否精确保守 $H_n$。\n- 分析与该方法相关的单步矩阵 $T(h)$ 的特征值。证明特征值是否位于复平面的单位圆上，并从梯形方法产生的 Cayley 变换表征出发，推导每步的离散旋转角与连续频率 $\\omega$ 及步长 $h$ 之间的关系。\n- 实现一个程序，对于给定的 $(\\omega, h)$ 构建 $A$、$Q$ 和 $T(h)$，计算离散能量不变性的矩阵缺陷 $\\|T(h)^\\top Q T(h) - Q\\|$（在 Frobenius 范数下），并通过使用快速、数值稳定的求幂（不要逐步迭代）计算 $z_N = T(h)^N z_0$ 来评估大量步数 $N$ 后的 $|H_N - H_0|$，从而量化长期能量行为。同时计算 $T(h)$ 的特征值模与 $1$ 的最大偏差，即 $\\max_j \\left|\\,|\\lambda_j| - 1\\,\\right|$。\n\n测试套件。使用以下测试用例，每个用例指定为 $(\\omega, h, N, x_0, v_0)$：\n- Case $1$: $(\\omega, h, N, x_0, v_0) = (1.0, 0.8, 10^6, 1.0, 0.0)$。\n- Case $2$: $(\\omega, h, N, x_0, v_0) = (3.0, 10.0, 5 \\times 10^5, 0.7, -0.2)$。\n- Case $3$（边界情况）：$(\\omega, h, N, x_0, v_0) = (0.0, 0.5, 1234567, 0.5, 0.5)$。\n\n对于每个用例，您的程序必须输出三个浮点值：\n- $E$ = $N$ 步后的绝对能量缺陷， $|H_N - H_0|$，\n- $R$ = Frobenius 范数缺陷 $R = \\|T(h)^\\top Q T(h) - Q\\|_F$，\n- $S$ = 谱模偏差 $S = \\max_j \\left|\\,|\\lambda_j| - 1\\,\\right|$，\n\n并将它们按顺序 $[E_1, R_1, S_1, E_2, R_2, S_2, E_3, R_3, S_3]$ 汇总。\n\n最终输出格式。您的程序应生成单行输出，其中包含这 $9$ 个值，以逗号分隔列表的形式用方括号括起来，每个数字都以科学计数法书写，精确到 $12$ 位有效数字（例如，$[1.234000000000e-06,5.000000000000e-16,0.0000000000e+00]$）。输出中不允许有额外的文本或空格。不需要物理单位。所讨论的角度仅用于推理，不会出现在程序输出中。", "solution": "在尝试解答之前，需对问题进行验证。\n\n### 步骤 1：提取已知条件\n- **微分方程**：简谐振子，$y'' + \\omega^2 y = 0$，常数 $\\omega > 0$。\n- **系统表示**：$x = y$，$v = y'$，得到一阶系统 $z' = f(z)$，其中 $z = \\begin{bmatrix} x \\\\ v \\end{bmatrix}$，$f(z) = Az$，$A$ 为常数矩阵。\n- **哈密顿量（能量）**：$H(x,v) = \\tfrac{1}{2}(v^2 + \\omega^2 x^2)$。\n- **数值方法**：梯形方法 (Crank-Nicolson)，$z_{n+1} = z_n + \\tfrac{h}{2}\\left(f(z_n) + f(z_{n+1})\\right)$，时间步长 $h > 0$。\n- **任务 1（能量守恒）**：推导线性更新关系 $z_{n+1} = T(h) z_n$。将离散能量表示为 $H_n = \\tfrac{1}{2} z_n^\\top Q z_n$ 并确定对称矩阵 $Q$。使用条件 $A^\\top Q + Q A = 0$，确定梯形方法是否精确保守 $H_n$。\n- **任务 2（谱分析）**：分析 $T(h)$ 的特征值，证明它们是否位于单位圆上。从 Cayley 变换表征出发，推导每步离散旋转角的关系。\n- **任务 3（实现）**：实现一个程序，为指定的测试用例计算三个量：\n    1.  绝对能量缺陷 $E = |H_N - H_0|$，其中 $z_N = T(h)^N z_0$ 通过快速求幂计算。\n    2.  Frobenius 范数缺陷 $R = \\|T(h)^\\top Q T(h) - Q\\|_F$。\n    3.  谱模偏差 $S = \\max_j \\left|\\,|\\lambda_j| - 1\\,\\right|$。\n- **测试用例**：\n    - Case 1: $(\\omega, h, N, x_0, v_0) = (1.0, 0.8, 10^6, 1.0, 0.0)$。\n    - Case 2: $(\\omega, h, N, x_0, v_0) = (3.0, 10.0, 5 \\times 10^5, 0.7, -0.2)$。\n    - Case 3: $(\\omega, h, N, x_0, v_0) = (0.0, 0.5, 1234567, 0.5, 0.5)$。\n- **输出格式**：一个单行列表 $[E_1, R_1, S_1, E_2, R_2, S_2, E_3, R_3, S_3]$，每个数字使用科学计数法，保留 $12$ 位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题植根于经典力学（简谐振子）、数值分析（常微分方程的梯形方法）和线性代数的基本概念。数值方法的能量守恒分析是几何数值积分的核心课题。Cayley 变换及其谱特性是标准的数学工具。所有方面在科学和数学上都是合理的。\n- **适定性**：该问题是适定的。它提供了执行所需推导和计算的所有必要定义和数据。任务规定明确，可得出唯一且有意义的解。包含 $\\omega=0$ 的情况是对边界条件的有效测试，而非矛盾。\n- **客观性**：该问题以精确、客观的数学语言陈述，没有主观或带偏见的主张。\n\n### 步骤 3：结论与行动\n问题是**有效的**。它自成体系、科学合理且适定。将提供完整的解决方案。\n\n### 推导与分析\n\n#### 系统公式化与单步矩阵 $T(h)$\n二阶方程 $y'' + \\omega^2 y = 0$ 被转换为一阶系统。令 $x = y$ 且 $v = y'$。导数为 $x' = y' = v$ 和 $v' = y'' = -\\omega^2 y = -\\omega^2 x$。以向量形式，设 $z = \\begin{bmatrix} x \\\\ v \\end{bmatrix}$，则系统为：\n$$\nz' = \\begin{bmatrix} x' \\\\ v' \\end{bmatrix} = \\begin{bmatrix} 0  1 \\\\ -\\omega^2  0 \\end{bmatrix} \\begin{bmatrix} x \\\\ v \\end{bmatrix}\n$$\n这定义了系统矩阵 $A = \\begin{bmatrix} 0  1 \\\\ -\\omega^2  0 \\end{bmatrix}$。该系统是线性的，$z' = Az$。\n\n梯形方法由 $z_{n+1} = z_n + \\tfrac{h}{2}(f(z_n) + f(z_{n+1}))$ 给出。代入 $f(z) = Az$：\n$$\nz_{n+1} = z_n + \\frac{h}{2}(Az_n + Az_{n+1})\n$$\n我们求解 $z_{n+1}$：\n$$\nz_{n+1} - \\frac{h}{2}Az_{n+1} = z_n + \\frac{h}{2}Az_n\n$$\n$$\n(I - \\frac{h}{2}A) z_{n+1} = (I + \\frac{h}{2}A) z_n\n$$\n其中 $I$ 是 $2 \\times 2$ 单位矩阵。这就得到了线性更新关系 $z_{n+1} = T(h)z_n$，其单步矩阵为：\n$$\nT(h) = \\left(I - \\frac{h}{2}A\\right)^{-1} \\left(I + \\frac{h}{2}A\\right)\n$$\n这个 $T(h)$ 的表达式被称为矩阵 $\\frac{h}{2}A$ 的 Cayley 变换。\n\n#### 能量守恒分析\n能量为 $H(x,v) = \\tfrac{1}{2}(v^2 + \\omega^2 x^2)$。我们将其写成二次型 $H_n = \\tfrac{1}{2}z_n^\\top Q z_n$：\n$$\nH_n = \\frac{1}{2} \\begin{bmatrix} x_n  v_n \\end{bmatrix} \\begin{bmatrix} \\omega^2  0 \\\\ 0  1 \\end{bmatrix} \\begin{bmatrix} x_n \\\\ v_n \\end{bmatrix}\n$$\n因此，对称矩阵 $Q$ 是 $Q = \\begin{bmatrix} \\omega^2  0 \\\\ 0  1 \\end{bmatrix}$。\n\n对于连续系统 $z' = Az$，能量的时间导数是 $\\frac{d}{dt}(\\tfrac{1}{2}z^\\top Q z) = \\tfrac{1}{2}(z'^\\top Q z + z^\\top Q z') = \\tfrac{1}{2}((Az)^\\top Q z + z^\\top Q (Az)) = \\tfrac{1}{2}z^\\top(A^\\top Q + QA)z$。对所有轨迹都守恒要求 $A^\\top Q + QA = 0$。我们来验证这个条件：\n$$\nA^\\top Q + QA = \\begin{bmatrix} 0  -\\omega^2 \\\\ 1  0 \\end{bmatrix} \\begin{bmatrix} \\omega^2  0 \\\\ 0  1 \\end{bmatrix} + \\begin{bmatrix} \\omega^2  0 \\\\ 0  1 \\end{bmatrix} \\begin{bmatrix} 0  1 \\\\ -\\omega^2  0 \\end{bmatrix}\n$$\n$$\n= \\begin{bmatrix} 0  -\\omega^2 \\\\ \\omega^2  0 \\end{bmatrix} + \\begin{bmatrix} 0  \\omega^2 \\\\ -\\omega^2  0 \\end{bmatrix} = \\begin{bmatrix} 0  0 \\\\ 0  0 \\end{bmatrix}\n$$\n该条件成立，证实了 $H$ 是连续系统的一个守恒量。\n\n对于离散梯形方法，如果 $H_{n+1} = H_n$，能量就是守恒的，这等价于 $z_{n+1}^\\top Q z_{n+1} = z_n^\\top Q z_n$。代入 $z_{n+1} = T(h)z_n$，我们得到 $(T(h)z_n)^\\top Q (T(h)z_n) = z_n^\\top(T(h)^\\top Q T(h))z_n = z_n^\\top Q z_n$。这对所有 $z_n$ 都必须成立，这意味着矩阵恒等式 $T(h)^\\top Q T(h) = Q$。\n\n我们来证明这个恒等式。将梯形法则重新排列为 $z_{n+1}-z_n = hA\\frac{z_n+z_{n+1}}{2}$。令 $z_{n+1/2} = \\frac{z_{n+1}+z_n}{2}$。那么 $z_n = z_{n+1/2} - \\frac{h}{2}A z_{n+1/2}$ 且 $z_{n+1} = z_{n+1/2} + \\frac{h}{2}A z_{n+1/2}$。现在我们比较 $z_n^\\top Q z_n$ 和 $z_{n+1}^\\top Q z_{n+1}$：\n$$\nz_{n+1}^\\top Q z_{n+1} = \\left(z_{n+1/2} + \\frac{h}{2}A z_{n+1/2}\\right)^\\top Q \\left(z_{n+1/2} + \\frac{h}{2}A z_{n+1/2}\\right)\n$$\n$$\n= z_{n+1/2}^\\top Q z_{n+1/2} + \\frac{h}{2}z_{n+1/2}^\\top(A^\\top Q + QA)z_{n+1/2} + \\left(\\frac{h}{2}\\right)^2 (A z_{n+1/2})^\\top Q (A z_{n+1/2})\n$$\n由于 $A^\\top Q + QA = 0$，中间项消失。对 $z_n^\\top Q z_n$ 进行类似的展开得到：\n$$\nz_{n}^\\top Q z_{n} = z_{n+1/2}^\\top Q z_{n+1/2} - \\frac{h}{2}z_{n+1/2}^\\top(A^\\top Q + QA)z_{n+1/2} + \\left(\\frac{h}{2}\\right)^2 (A z_{n+1/2})^\\top Q (A z_{n+1/2})\n$$\n这两个表达式是相同的。因此，对所有 $n$ 都有 $z_{n+1}^\\top Q z_{n+1} = z_n^\\top Q z_n$。梯形方法对任意步长 $h > 0$ 和任意频率 $\\omega \\ge 0$ 都精确保守能量 $H_n$。因此，在精确算术中，$|H_N - H_0|=0$ 且 $\\|T(h)^\\top Q T(h) - Q\\|_F = 0$。\n\n#### $T(h)$ 的谱分析\n$T(h) = (I - \\frac{h}{2}A)^{-1} (I + \\frac{h}{2}A)$ 的特征值通过 Cayley 变换与 $A$ 的特征值相关。首先，求 $A$ 的特征值 $\\sigma$：\n$$\n\\det(A - \\sigma I) = \\det\\begin{pmatrix} -\\sigma  1 \\\\ -\\omega^2  -\\sigma \\end{pmatrix} = \\sigma^2 + \\omega^2 = 0 \\implies \\sigma_{1,2} = \\pm i\\omega\n$$\n$\\frac{h}{2}A$ 的特征值为 $\\mu_{1,2} = \\pm i\\frac{h\\omega}{2}$。令 $\\alpha = \\frac{h\\omega}{2}$。$T(h)$ 的特征值 $\\lambda$ 由映射 $\\lambda = \\frac{1+\\mu}{1-\\mu}$ 给出：\n$$\n\\lambda_{1,2} = \\frac{1 \\pm i\\alpha}{1 \\mp i\\alpha}\n$$\n这些特征值的模为：\n$$\n|\\lambda| = \\left| \\frac{1 \\pm i\\alpha}{1 \\mp i\\alpha} \\right| = \\frac{|1 \\pm i\\alpha|}{|1 \\mp i\\alpha|} = \\frac{\\sqrt{1^2 + (\\pm\\alpha)^2}}{\\sqrt{1^2 + (\\mp\\alpha)^2}} = 1\n$$\n这表明对于所有 $h>0$ 和 $\\omega \\ge 0$，$T(h)$ 的特征值都精确地位于复平面的单位圆上。这意味着在精确算术中，谱模偏差 $\\max_j ||\\lambda_j| - 1|$ 精确为 $0$。\n\n特征值可以写成 $e^{\\pm i\\theta_d}$ 的形式，其中 $\\theta_d$ 是每步的数值旋转角。我们有：\n$$\n\\lambda = \\frac{1+i\\alpha}{1-i\\alpha} = \\frac{(1+i\\alpha)^2}{1+\\alpha^2} = \\frac{1-\\alpha^2}{1+\\alpha^2} + i \\frac{2\\alpha}{1+\\alpha^2} = \\cos(\\theta_d) + i \\sin(\\theta_d)\n$$\n通过与半角正切公式比较，我们确定 $\\tan(\\theta_d/2) = \\alpha = \\frac{h\\omega}{2}$。因此，离散旋转角为 $\\theta_d = 2\\arctan(\\frac{h\\omega}{2})$。这是对真实旋转角 $\\theta_{true} = \\omega h$ 的一个近似。\n\n### 实现细节\n程序将实现推导出的公式。对于每个测试用例 $(\\omega, h, N, x_0, v_0)$：\n1.  构建矩阵 $A = \\begin{bmatrix} 0  1 \\\\ -\\omega^2  0 \\end{bmatrix}$ 和 $Q = \\begin{bmatrix} \\omega^2  0 \\\\ 0  1 \\end{bmatrix}$。\n2.  计算 $T(h) = (I - \\frac{h}{2}A)^{-1} (I + \\frac{h}{2}A)$。\n3.  计算 Frobenius 范数缺陷 $R = \\|T(h)^\\top Q T(h) - Q\\|_F$。这应该在机器精度的数量级上。\n4.  计算 $T(h)$ 的特征值 $\\lambda_j$ 和谱模偏差 $S = \\max_j \\left|\\,|\\lambda_j| - 1\\,\\right|$。这也应该在机器精度的数量级上。\n5.  计算能量缺陷 $E = |H_N - H_0|$。最终状态 $z_N$ 通过使用 `numpy.linalg.matrix_power(T(h), N)` 来高效计算 $T(h)^N$。\n    - $z_0 = [x_0, v_0]^\\top$.\n    - $H_0 = \\tfrac{1}{2}z_0^\\top Q z_0$.\n    - $z_N = T(h)^N z_0$.\n    - $H_N = \\tfrac{1}{2}z_N^\\top Q z_N$.\n    - $E = |H_N - H_0|$。由于守恒性质，$E$ 也应该非常小，反映了累积的浮点误差。\n所有三个测试用例的结果将被汇总并按指定格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite, calculating energy,\n    invariance, and spectral defects for the trapezoidal method applied\n    to the simple harmonic oscillator.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (omega, h, N, x0, v0)\n    test_cases = [\n        (1.0, 0.8, 10**6, 1.0, 0.0),\n        (3.0, 10.0, 5 * 10**5, 0.7, -0.2),\n        (0.0, 0.5, 1234567, 0.5, 0.5),\n    ]\n\n    results = []\n    for omega, h, N, x0, v0 in test_cases:\n        # Define the system matrices A and Q\n        A = np.array([[0.0, 1.0], [-omega**2, 0.0]], dtype=float)\n        Q = np.array([[omega**2, 0.0], [0.0, 1.0]], dtype=float)\n\n        # Construct the one-step matrix T(h) for the trapezoidal method\n        # T(h) = (I - h/2 * A)^-1 * (I + h/2 * A)\n        I = np.identity(2, dtype=float)\n        try:\n            inv_matrix = np.linalg.inv(I - 0.5 * h * A)\n            T_h = inv_matrix @ (I + 0.5 * h * A)\n        except np.linalg.LinAlgError:\n            # Handle singular matrix case if it arises, though unlikely for I-h/2*A\n            # This is more robust than assuming invertibility.\n            results.extend([np.nan, np.nan, np.nan])\n            continue\n        \n        # --- Task 1: Calculate Energy Defect E = |H_N - H_0| ---\n\n        # Initial state and energy\n        z0 = np.array([x0, v0], dtype=float)\n        H0 = 0.5 * (z0.T @ Q @ z0)\n\n        # Final state z_N = T(h)^N * z_0 using fast matrix exponentiation\n        T_h_pow_N = np.linalg.matrix_power(T_h, N)\n        zN = T_h_pow_N @ z0\n        \n        # Final energy\n        HN = 0.5 * (zN.T @ Q @ zN)\n\n        # Absolute energy defect E\n        E = np.abs(HN - H0)\n        \n        # --- Task 2: Calculate Invariance Defect R = ||T(h)^T Q T(h) - Q||_F ---\n        \n        # The theoretical result is 0. Numerical result will be on order of machine epsilon.\n        invariance_defect_matrix = T_h.T @ Q @ T_h - Q\n        R = np.linalg.norm(invariance_defect_matrix, 'fro')\n\n        # --- Task 3: Calculate Spectral Modulus Deviation S = max_j ||lambda_j| - 1| ---\n        \n        # Eigenvalues of the one-step matrix T(h)\n        eigenvalues = np.linalg.eigvals(T_h)\n        \n        # Moduli of the eigenvalues\n        moduli = np.abs(eigenvalues)\n        \n        # The theoretical result is 0. Numerical result will be on order of machine epsilon.\n        S = np.max(np.abs(moduli - 1.0))\n        \n        # Append results for the current case\n        results.extend([E, R, S])\n\n    # Final print statement in the exact required format.\n    # Format spec \".12e\" gives scientific notation with 1 digit before\n    # the decimal and 12 digits after, matching the problem's example format.\n    print(f\"[{','.join(f'{val:.12e}' for val in results)}]\")\n\nsolve()\n```", "id": "3241554"}]}