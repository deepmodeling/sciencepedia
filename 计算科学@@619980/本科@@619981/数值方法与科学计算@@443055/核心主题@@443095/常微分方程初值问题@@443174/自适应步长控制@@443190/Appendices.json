{"hands_on_practices": [{"introduction": "自适应步长控制的核心在于一个简单的反馈机制：根据当前步长的估算误差来调整下一步的步长。这个练习将带你深入理解这一核心机制。你将推导出一个基本但极其重要的公式，该公式揭示了误差、步长和数值方法阶数 $p$ 之间的定量关系，这是所有现代ODE求解器的心脏。[@problem_id:1659045]", "problem": "在计算科学领域，数值方法被用于近似求解常微分方程（ODEs）。现代求解器的一个关键方面是自适应步长控制，它通过调整积分步长 $h$ 来在保持所需精度水平的同时最小化计算成本。\n\n考虑一个 $p$ 阶的数值积分方法。已知在单步中产生的局部截断误差 $\\epsilon$ 与步长的 $(p+1)$ 次方成正比。这种关系可以表示为 $\\epsilon \\propto h^{p+1}$。\n\n一位工程师正在使用一个阶数为 $p=4$ 的此类求解器。该求解器为局部误差配置了一个恒定的目标容差 $tol$。在采用步长 $h_{old}$ 执行一步之后，误差估计模块报告的局部误差为 $\\epsilon_{old} = \\frac{1}{2} tol$。为了准备下一个积分步骤，控制算法必须提出一个新的步长 $h_{new}$。新步长的选择应使得下一步的预测误差 $\\epsilon_{new}$ 恰好等于目标容差 $tol$。\n\n假设关联误差与步长的比例常数在这两个连续的步骤之间没有显著变化，请确定建议的新步长 $h_{new}$ 关于旧步长 $h_{old}$ 的表达式。", "solution": "对于一个 $p$ 阶的方法，其局部截断误差满足 $\\epsilon = C h^{p+1}$，其中 $C$ 是在连续步骤之间近似恒定的比例因子。对于旧步长，\n$$\n\\epsilon_{old} = C h_{old}^{p+1} = \\frac{1}{2} tol.\n$$\n对于建议的新步长，我们要求\n$$\n\\epsilon_{new} = C h_{new}^{p+1} = tol.\n$$\n两式相除，\n$$\n\\frac{\\epsilon_{new}}{\\epsilon_{old}} = \\frac{C h_{new}^{p+1}}{C h_{old}^{p+1}} = \\left(\\frac{h_{new}}{h_{old}}\\right)^{p+1} = \\frac{tol}{\\frac{1}{2} tol} = 2.\n$$\n因此，\n$$\n\\left(\\frac{h_{new}}{h_{old}}\\right)^{p+1} = 2 \\quad \\Rightarrow \\quad \\frac{h_{new}}{h_{old}} = 2^{\\frac{1}{p+1}}.\n$$\n对于 $p=4$，我们得到\n$$\nh_{new} = 2^{\\frac{1}{5}} h_{old}.\n$$", "answer": "$$\\boxed{2^{\\frac{1}{5}} h_{old}}$$", "id": "1659045"}, {"introduction": "成功控制每一步的局部误差是否就意味着最终的全局误差也一定很小？这个问题触及了自适应方法的一个深刻而关键的限制。通过分析几个不同的微分方程，这个练习将挑战你思考局部精度和全局精度之间的关系，特别是当系统本身对微小扰动异常敏感时，局部误差可能会被急剧放大。[@problem_id:3203789]", "problem": "一个常微分方程 (ODE) 初值问题 (IVP) 在一个有限区间上，使用带有自适应步长控制的显式嵌入式龙格-库塔 (RK) 方法进行数值求解，该方法强制要求每步的局部截断误差估计不超过给定的容差 $tol$。假设 ODE 的右端项是连续可微的，因此关于轨迹的线性化是有效的，并且回想一下，对扰动的敏感性由线性化动力学的稳定性决定，其中扰动可以被放大或衰减，这取决于线性化的符号和结构。\n\n考虑以下 IVP，每一个都将使用所述的自adaptive方法在其给定的时间区间上从给定的初始条件开始求解：\n\n- A. $y'(t) = 20\\,y(t)$，满足 $y(0) = 1$，在 $[0,10]$ 上。\n- B. $y'(t) = -20\\,y(t)$，满足 $y(0) = 1$，在 $[0,10]$ 上。\n- C. $y'(t) = -20\\,y(t) + \\sin(t)$，满足 $y(0) = 0$，在 $[0,10]$ 上。\n- D. $\\mathbf{z}'(t) = A\\,\\mathbf{z}(t)$，其中 $A = \\begin{pmatrix}20  500 \\\\ 0  20\\end{pmatrix}$ 且 $\\mathbf{z}(0) = \\begin{pmatrix}1 \\\\ 0\\end{pmatrix}$，在 $[0,1]$ 上。\n\n选择所有满足以下条件的 IVP：尽管求解器在整个积分过程中强制执行标准的每步局部误差容差 $tol$，但由于系统对扰动的敏感性，最终时刻的全局误差仍可能比 $tol$ 大几个数量级。你的论证应基于第一性原理：流的线性化、齐次部分的稳定性，以及由诱导动力学产生、随时间推移的扰动增长基本界限，而不是任何特定的依赖于方法本身的公式。", "solution": "...", "answer": "$$\\boxed{AD}$$", "id": "3203789"}, {"introduction": "理论学习之后，最好的检验方式就是亲手实现一个求解器。这个实践任务要求你为一个著名的刚性系统——范德波尔振子（Van der Pol oscillator）——构建一个完整的自适应步长积分器。通过这个编码挑战，你不仅能将误差估计和步长更新的理论付诸实践，还能亲眼观察到求解器在应对刚性问题时步长是如何剧烈变化的。[@problem_id:3203792]", "problem": "考虑由范德波尔振子产生的初值问题，该问题由二阶常微分方程 $y'' - \\mu(1-y^2)y' + y = 0$ 给出。引入 $y_1 = y$ 和 $y_2 = y'$ 以获得等价的一阶系统\n$$\n\\begin{aligned}\ny_1' = y_2, \\\\\ny_2' = \\mu(1 - y_1^2)\\,y_2 - y_1,\n\\end{aligned}\n$$\n其中 $\\mu > 0$ 控制刚性，较大的 $\\mu$ 会产生刚性系统。任务是设计并实现一个自适应步长求解器，该求解器基于一个阶数至少为 $4$ 的嵌入式显式龙格-库塔方法，并带有内置的局部误差估计器，并研究当 $\\mu$ 较大时，求解该系统过程中步长的行为。\n\n从以下基础出发：\n- 常微分方程组的初值问题定义为 $\\mathbf{y}'(t) = \\mathbf{f}(t,\\mathbf{y}(t))$，初始条件为 $\\mathbf{y}(t_0) = \\mathbf{y}_0$。\n- 对于一个阶数为 $p$ 和 $p+1$ 的嵌入式显式龙格-库塔对，局部截断误差估计器 $\\mathbf{e}$ 计算为同一步骤中两个不同级加权更新之间的差值。对于足够光滑的 $\\mathbf{f}$，局部误差与 $h^{p+1}$ 成比例，其中 $h$ 是步长。\n- 自适应步长控制旨在通过在估计的局部误差较小时增加 $h$、在误差较大时减小 $h$ 来强制满足用户指定的误差容差。\n\n您的程序必须实现一个自适应显式嵌入式龙ge-Kutta积分器，并满足以下要求：\n- 使用相对容差 $rtol$ 和绝对容差 $atol$，组合成一个分量尺度 $s_i = atol + rtol \\cdot \\max(|y_i|, |y_i^{\\text{new}}|)$，其中 $y_i^{\\text{new}}$ 是候选的更新值。使用缩放后误差向量 $\\mathbf{e}/\\mathbf{s}$ 的均方根 (RMS) 范数来决定是否接受一个步。\n- 如果一个试探步被接受，则将时间推进 $h$ 并更新解；否则，拒绝该步并用一个更小的 $h$ 重试。\n- 实现一个与局部误差按 $h^{p+1}$ 缩放相一致的步长更新规则，并包含一个安全因子和增长/收缩限制，以避免步长剧烈变化。\n- 如果所选方法可用，则采用首末同阶 (First Same As Last, FSAL) 特性以减少函数求值次数，但要确保无论是否发生拒绝，其正确性都不受影响。\n- 强制实施一个最小步长 $h_{\\min}$；如果算法需要 $h  h_{\\min}$ 才能继续，则终止并报告该测试用例失败。\n- 将总尝试步数限制在一个最大值 $N_{\\max}$ 以保证程序终止。\n\n使用初始条件 $y(0) = 2$ 和 $y'(0) = 0$，因此 $\\mathbf{y}_0 = (2, 0)^{\\top}$。此问题不需要物理单位。不涉及角度。\n\n设计一个测试套件，用以探究求解器在非刚性、中度刚性和非常刚性情况下的行为。使用以下三个测试用例：\n- 测试用例 1：$\\mu = 1$, $T = 10$, $rtol = 10^{-6}$, $atol = 10^{-9}$, $h_0 = 0.1$, $h_{\\min} = 10^{-12}$, $N_{\\max} = 100000$。\n- 测试用例 2：$\\mu = 50$, $T = 10$, $rtol = 10^{-5}$, $atol = 10^{-8}$, $h_0 = 0.1$, $h_{\\min} = 10^{-12}$, $N_{\\max} = 100000$。\n- 测试用例 3：$\\mu = 200$, $T = 6$, $rtol = 10^{-4}$, $atol = 10^{-7}$, $h_0 = 0.05$, $h_{\\min} = 10^{-12}$, $N_{\\max} = 100000$。\n\n对于每个测试用例，在区间 $[0, T]$ 上运行积分器，并记录以下指标：\n- 接受的总步数（一个整数）。\n- 拒绝的总步数（一个整数）。\n- 运行期间遇到的最小步长 $h$（一个浮点数）。\n- 一个布尔值，指示是否成功到达最终时间 $T$（true）或未到达（false）。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，并且本身是按上述顺序排列的列表。例如，输出格式必须为\n$[ [\\text{accepted}_1,\\text{rejected}_1,\\text{min\\_h}_1,\\text{success}_1], [\\text{accepted}_2,\\text{rejected}_2,\\text{min\\_h}_2,\\text{success}_2], [\\text{accepted}_3,\\text{rejected}_3,\\text{min\\_h}_3,\\text{success}_3] ]$。", "solution": "所提出的问题要求设计并实现一个自适应步长积分器，以求解由范德波尔振子定义的初值问题。通过设置 $y_1 = y$ 和 $y_2 = y'$，得到的一阶常微分方程 (ODE) 组为：\n$$\n\\mathbf{y}'(t) = \\mathbf{f}(t, \\mathbf{y}(t)) = \\begin{pmatrix} y_2 \\\\ \\mu(1-y_1^2)y_2 - y_1 \\end{pmatrix}\n$$\n该问题定义在区间 $[0, T]$ 上，初始条件为 $\\mathbf{y}(0) = (2, 0)^T$。参数 $\\mu > 0$ 决定了 ODE 系统的刚性；大的 $\\mu$ 值对应于数值刚性问题，这对许多数值方法都构成了挑战。目标是实现一个能够自动调整其步长 $h$ 的求解器，以满足预设的误差容差，同时高效地处理解的慢动态和快动态。\n\n该问题指定使用一个阶数至少为 $4$ 的嵌入式显式龙格-库塔方法。一个满足此要求的经典且高效的选择是 Dormand-Prince 5(4) 对，下文称之为 DP5(4)。该方法计算一个五阶精确解（$p+1=5$），并同时提供一个四阶精确解（$p=4$）用于估计局部截断误差。DP5(4) 方法的一个显著优点是其“首末同阶”(First Same As Last, FSAL) 特性。该特性确保一个成功步的最后阶段的导数求值与后续步的第一阶段的导数求值相同。这使得每个被接受的步可以复用一次函数求值，从而降低计算成本。\n\n一个 $s$ 级的显式龙格-库塔方法将解从 $t_n$推进到 $t_{n+1} = t_n + h$。对于一个自治系统 $\\mathbf{y}' = \\mathbf{f}(\\mathbf{y})$，这涉及计算一组中间级导数：\n$$ \\mathbf{k}_i = \\mathbf{f}\\left(t_n + c_i h, \\mathbf{y}_n + h \\sum_{j=1}^{i-1} a_{ij} \\mathbf{k}_j\\right) \\quad \\text{for } i=1, \\dots, s $$\nDP5(4) 方法使用 $s=7$ 个级。如果步被接受，用于推进解的高阶（五阶）近似由下式给出：\n$$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\sum_{i=1}^7 b_i \\mathbf{k}_i $$\n同时，计算一个低阶（四阶）近似：\n$$ \\hat{\\mathbf{y}}_{n+1} = \\mathbf{y}_n + h \\sum_{i=1}^7 b_i^* \\mathbf{k}_i $$\n系数 $c_i$、$a_{ij}$、$b_i$ 和 $b_i^*$ 是由该方法的 Butcher 算表定义的常数。该步的局部误差估计定义为这两个近似值之差：\n$$ \\mathbf{e}_{n+1} = \\mathbf{y}_{n+1} - \\hat{\\mathbf{y}}_{n+1} = h \\sum_{i=1}^7 (b_i - b_i^*) \\mathbf{k}_i $$\n该估计值 $\\mathbf{e}_{n+1}$ 近似了低阶方法的局部截断误差，其缩放阶为 $\\mathcal{O}(h^{p+1})$，对于此特定方法对，对应于 $\\mathcal{O}(h^5)$。\n\n自适应算法的核心是控制步长 $h$，以将局部误差的大小保持在指定的容差范围内。控制机制实现如下：\n$1$. **误差范数计算**：问题要求采用一种混合误差容差准则，该准则结合了相对容差 $rtol$ 和绝对容差 $atol$。对于解向量 $\\mathbf{y}$ 的每个分量 $j$，定义一个容差尺度 $s_j$：\n$$ s_j = atol + rtol \\cdot \\max(|\\mathbf{y}_{n,j}|, |\\mathbf{y}_{n+1,j}|) $$\n这里，$\\mathbf{y}_{n,j}$ 是步开始时的解分量，$\\mathbf{y}_{n+1,j}$ 是来自高阶公式的候选解。然后使用缩放后的均方根 (RMS) 范数来衡量总误差：\n$$ E = \\sqrt{\\frac{1}{d} \\sum_{j=1}^d \\left( \\frac{\\mathbf{e}_{n+1,j}}{s_j} \\right)^2} $$\n其中 $d$ 是 ODE 系统的维度（在此例中为 $d=2$）。\n$2$. **步的接受/拒绝**：如果一个试探步的误差范数 $E$ 小于或等于 $1$，则该步被接受。接受后，推进解和时间：$\\mathbf{y}_{n+1} \\leftarrow \\mathbf{y}_{n+1}$ 和 $t_{n+1} \\leftarrow t_n + h$。如果 $E > 1$，则该步被拒绝；解和时间不更新，必须用更小的步长重试该步。\n$3$. **步长更新**：最优步长是使 $E \\approx 1$ 的步长。利用已知的误差缩放关系 $E \\propto h^{p+1}$，从当前步长 $h$ 和计算出的误差范数 $E$ 计算建议的新步长 $h_{\\text{new}}$：\n$$ h_{\\text{new}} = h \\cdot S \\cdot \\left( \\frac{1}{E} \\right)^{1/(p+1)} $$\n其中 $p=4$ 是误差估计方法的阶数。$S$ 是一个安全因子（通常取值为 $0.9$），以促进保守的步长调整并减少拒绝的频率。为防止步长发生不规则或过于激进的变化，新步长受到限制：\n$$ h \\cdot F_{\\min} \\le h_{\\text{new}} \\le h \\cdot F_{\\max} $$\n其中 $F_{\\min}$ 和 $F_{\\max}$ 分别是最小和最大缩放因子（例如，分别为 $0.2$ 和 $5.0$）。该更新公式既用于在拒绝步后减小步长，也用于在接受步后调整步长（可能增加它）。\n\n对于大的 $\\mu$ 值，范德波尔振子表现出刚性行为，其特征是解中同时存在非常慢和非常快的时间尺度。轨迹会迅速收敛到一个极限环，该极限环由长时间的缓慢变化和短暂的快速过渡区间交替组成。像 DP5(4) 这样的显式方法被迫采用极小的步长来准确且稳定地解析这些快速过渡。随着 $\\mu$ 的增加，我们预期自适应求解器将需要显著更多的步数，并且遇到的最小步长将变得非常小。这种行为凸显了显式方法在处理刚性问题时的一个已知局限性。算法中包含了必要的保障措施，如最大步数 ($N_{\\max}$) 和最小允许步长 ($h_{\\min}$)，以确保即使在问题的刚性对所选方法来说计算成本过高时，程序也能终止。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the adaptive Runge-Kutta solver.\n    \"\"\"\n    \n    # Dormand-Prince 5(4) Butcher Tableau\n    C = np.array([0, 1/5, 3/10, 4/5, 8/9, 1, 1], dtype=np.float64)\n    A = np.array([\n        [0, 0, 0, 0, 0, 0, 0],\n        [1/5, 0, 0, 0, 0, 0, 0],\n        [3/40, 9/40, 0, 0, 0, 0, 0],\n        [44/45, -56/15, 32/9, 0, 0, 0, 0],\n        [19372/6561, -25360/2187, 64448/6561, -212/729, 0, 0, 0],\n        [9017/3168, -355/33, 46732/5247, 49/176, -5103/18656, 0, 0],\n        [35/384, 0, 500/1113, 125/192, -2187/6784, 11/84, 0]\n    ], dtype=np.float64)\n    # 5th-order solution coefficients\n    B_HIGH = np.array([35/384, 0, 500/1113, 125/192, -2187/6784, 11/84, 0], dtype=np.float64)\n    # 4th-order solution coefficients\n    B_LOW = np.array([5179/57600, 0, 7571/16695, 393/640, -92097/339200, 187/2100, 1/40], dtype=np.float64)\n    E_COEFFS = B_HIGH - B_LOW\n    \n    # Order of the error estimator\n    ORDER = 4\n\n    # --- Solver Parameters ---\n    # Safety factor for step-size update\n    SAFETY = 0.9\n    # Min/max step-size change factors\n    MIN_FACTOR = 0.2\n    MAX_FACTOR = 5.0\n\n    def vdp_ode(t, y, mu):\n        \"\"\"Van der Pol oscillator ODE system.\"\"\"\n        y1, y2 = y\n        return np.array([y2, mu * (1 - y1**2) * y2 - y1], dtype=np.float64)\n\n    def run_integrator(mu, T, rtol, atol, h0, h_min, N_max):\n        \"\"\"\n        Implements the adaptive explicit embedded Runge-Kutta integrator.\n        \"\"\"\n        f = lambda t, y: vdp_ode(t, y, mu)\n        y0 = np.array([2.0, 0.0], dtype=np.float64)\n        \n        t = 0.0\n        y = y0\n        h = h0\n        \n        accepted_steps = 0\n        rejected_steps = 0\n        min_h_val = h0\n        \n        num_stages = 7\n        k_stages = np.zeros((num_stages, len(y0)), dtype=np.float64)\n        \n        # Initial derivative evaluation\n        k_stages[0] = f(t, y)\n        total_steps = 0\n        \n        while t  T:\n            total_steps = accepted_steps + rejected_steps\n            if total_steps = N_max:\n                return [accepted_steps, rejected_steps, min_h_val, False]\n\n            # Ensure the final step lands exactly on T\n            if t + h  T:\n                h = T - t\n            \n            if h  h_min:\n                return [accepted_steps, rejected_steps, min_h_val, False]\n\n            step_accepted = False\n            while not step_accepted:\n                # Compute stages k2 to k7\n                for i in range(1, num_stages):\n                    dy = np.dot(A[i, :i], k_stages[:i])\n                    k_stages[i] = f(t + C[i] * h, y + h * dy)\n                \n                # Higher-order solution candidate\n                y_new = y + h * np.dot(B_HIGH, k_stages)\n                \n                # Compute error estimate\n                err_vec = h * np.dot(E_COEFFS, k_stages)\n                \n                # Calculate error norm based on mixed tolerance\n                scale = atol + rtol * np.maximum(np.abs(y), np.abs(y_new))\n                err_norm = np.sqrt(np.mean((err_vec / scale)**2))\n\n                if err_norm = 1.0:\n                    step_accepted = True\n                    # Accept the step\n                    t += h\n                    y = y_new\n                    accepted_steps += 1\n                    min_h_val = min(min_h_val, h)\n                    \n                    # Use FSAL: k1 for next step is k7 from this step\n                    k_stages[0] = k_stages[num_stages-1]\n                    \n                    # Update step size for the next step\n                    if err_norm == 0.0:\n                        h_new = h * MAX_FACTOR\n                    else:\n                        h_new = h * SAFETY * (err_norm**(-1.0 / (ORDER + 1)))\n                    h = min(h * MAX_FACTOR, max(h * MIN_FACTOR, h_new))\n                \n                else:\n                    # Reject the step\n                    rejected_steps += 1\n                    total_steps = accepted_steps + rejected_steps\n                    if total_steps = N_max:\n                        return [accepted_steps, rejected_steps, min_h_val, False]\n                    \n                    # Compute smaller step size for retry\n                    h_new = h * SAFETY * (err_norm**(-1.0 / (ORDER + 1)))\n                    h = max(h_new, h * MIN_FACTOR)\n                    \n                    if h  h_min:\n                        return [accepted_steps, rejected_steps, min_h_val, False]\n        \n        return [accepted_steps, rejected_steps, min_h_val, True]\n\n    # --- Test Suite ---\n    test_cases = [\n        # (mu, T, rtol, atol, h0, h_min, N_max)\n        (1, 10, 1e-6, 1e-9, 0.1, 1e-12, 100000),\n        (50, 10, 1e-5, 1e-8, 0.1, 1e-12, 100000),\n        (200, 6, 1e-4, 1e-7, 0.05, 1e-12, 100000)\n    ]\n    \n    results = []\n    for case in test_cases:\n        result = run_integrator(*case)\n        results.append(result)\n    \n    # Format the final output string exactly as required\n    result_strings = []\n    for res in results:\n        accepted, rejected, min_h, success = res\n        result_strings.append(f\"[{accepted},{rejected},{min_h},{str(success).lower()}]\")\n        \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3203792"}]}