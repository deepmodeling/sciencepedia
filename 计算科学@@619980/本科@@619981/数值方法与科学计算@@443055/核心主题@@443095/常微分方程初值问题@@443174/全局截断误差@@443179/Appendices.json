{"hands_on_practices": [{"introduction": "理论告诉我们，一个 $p$ 阶方法的全局截断误差 $E$ 与步长 $h$ 之间存在 $E \\propto h^p$ 的关系。这个关系是数值分析中的基石之一，直接关系到计算成本与精度之间的权衡。本练习是一个基础性的思想实验，旨在检验你对这一核心概念的理解，并帮助你直观地感受步长变化对求解精度的巨大影响。[@problem_id:2185101]", "problem": "一位数值分析师正在研究一种用于求解固定区间上常微分方程的稳定数值方法的精度。已知该方法是一种二阶方法。在第一个计算实验中，该分析师使用常数步长 $h$ 计算解，并发现在区间末端的全局截断误差大约为 $\\epsilon$。\n\n在第二个实验中，该分析师决定将步长改为 $2h$，同时保持所有其他参数和微分方程不变。假设该方法在此范围内保持稳定，并且全局误差与步长的关系仍然成立，那么第二次实验的估计全局截断误差是多少？\n\nA. $\\frac{\\epsilon}{4}$\n\nB. $\\frac{\\epsilon}{2}$\n\nC. $\\epsilon$\n\nD. $2\\epsilon$\n\nE. $4\\epsilon$", "solution": "一个 $p$ 阶的稳定方法，在固定的最终时间点，其全局截断误差与步长 $h$ 的关系可表示为 $E(h)=C h^{p}$，其中 $C$ 是一个与 $h$ 无关的常数，前提是该方法保持稳定且渐近误差关系成立。\n\n已知该方法是二阶的，所以 $p=2$。对于步长 $h$，观测到的全局误差为 $\\epsilon$，因此\n$$\n\\epsilon = C h^{2}.\n$$\n如果步长变为 $2h$，新的全局误差为\n$$\nE(2h) = C (2h)^{2} = 4 C h^{2} = 4 \\epsilon.\n$$\n因此，将步长加倍会使全局误差乘以 $4$，这对应于选项 E。", "answer": "$$\\boxed{E}$$", "id": "2185101"}, {"introduction": "虽然理论预测了误差的缩放规律，但在科学计算实践中，通过实验验证理论并从中提取关键参数是一项至关重要的技能。这个练习将指导你编写程序，通过在不同步长下求解常微分方程来收集误差数据。然后，你将利用对数-对数坐标下的线性拟合来经验性地确定方法的收敛阶数，从而将抽象的数学公式与具体的数值结果联系起来，加深对全局误差行为的理解。[@problem_id:3236754]", "problem": "考虑由常微分方程 $y^{\\prime}(t) = f(t, y)$ 和初始条件 $y(t_{0}) = y_{0}$ 定义的初值问题。四阶经典显式龙格-库塔方法 (RK4) 是一种四级单步法，它通过在 $t_{n}$、$t_{n} + \\frac{h}{2}$ 和 $t_{n} + h$ 处对 $f$ 进行分级求值，将数值解 $y_{n}$ 从时间 $t_{n}$ 推进到 $t_{n+1} = t_{n} + h$。在最终时间 $T$ 处，与均匀步长 $h$ 相关联的全局截断误差定义为 $e(h) = \\left|y_{N} - y_{\\mathrm{exact}}(T)\\right|$，其中 $N = \\frac{T - t_{0}}{h}$，$y_{N}$ 是 RK4 经过 $N$ 步后产生的数值近似解。\n\n您的任务是通过拟合不同步长 $h$ 下观测到的误差 $e(h)$，并在线性拟合的对数-对数尺度上推断经验阶数 $p$ 和首项常数 $C$，从而经验性地重建 RK4 的全局截断误差定律。具体来说，对于下面的每个测试用例，您必须：\n- 实现一个求解器，对于每个提供的步长 $h$，计算在最终时间 $T$ 处的 RK4 数值解，并评估相应的误差 $e(h)$。\n- 使用自然对数，通过在所提供的步长集上进行最小二乘法拟合模型 $\\log\\left(e(h)\\right) = \\log(C) + p \\,\\log(h)$，从而推断出 $p$ 和 $C$。\n- 按照本说明末尾指定的确切输出格式，汇总所有测试用例推断出的 $\\left[p, C\\right]$。\n\n使用的基础和理由：初值问题定义 $y^{\\prime}(t) = f(t, y)$ 及 $y(t_{0}) = y_{0}$，全局截断误差 $e(h)$ 定义为在 $T$ 时刻数值解与精确解之差，以及在对数-对数尺度上对幂律关系的经验线性化。\n\n用于评估和拟合经验误差定律的测试套件：\n- 测试用例 1：$f(t, y) = y$，$t_{0} = 0$，$y_{0} = 1$，$T = 1$，精确解 $y_{\\mathrm{exact}}(t) = e^{t}$，步长 $h \\in \\left\\{0.5, 0.25, 0.125, 0.0625\\right\\}$。\n- 测试用例 2：$f(t, y) = -3\\,y$，$t_{0} = 0$，$y_{0} = 2$，$T = 2$，精确解 $y_{\\mathrm{exact}}(t) = 2\\,e^{-3t}$，步长 $h \\in \\left\\{0.5, 0.25, 0.125, 0.0625\\right\\}$。\n- 测试用例 3：$f(t, y) = y + t$，$t_{0} = 0$，$y_{0} = 0$，$T = 0.8$，精确解 $y_{\\mathrm{exact}}(t) = e^{t} - t - 1$，步长 $h \\in \\left\\{0.4, 0.2, 0.1, 0.05\\right\\}$。\n- 测试用例 4：$f(t, y) = -5\\,y$，$t_{0} = 0$，$y_{0} = 1$，$T = 1$，精确解 $y_{\\mathrm{exact}}(t) = e^{-5t}$，步长 $h \\in \\left\\{0.1, 0.05, 0.025, 0.0125\\right\\}$。\n\n所有时间量均为无量纲。不涉及物理单位。不出现角度。您的程序必须：\n- 对 $\\left(\\log(h), \\log(e(h))\\right)$ 数据对使用自然对数进行最小二乘拟合。\n- 生成单行输出，其中包含所有测试用例的结果，形式为用方括号括起来的逗号分隔列表，每个测试用例贡献一个双元素列表 $\\left[p, C\\right]$。例如，要求的格式为 $\\left[\\left[p_{1}, C_{1}\\right], \\left[p_{2}, C_{2}\\right], \\left[p_{3}, C_{3}\\right], \\left[p_{4}, C_{4}\\right]\\right]$。\n- 以浮点数形式报告数值。不需要四舍五入或指定有效数字。\n\n您的最终答案必须是一个完整、可运行的程序，该程序执行这些计算并仅打印指定的输出行。", "solution": "该问题要求经验性地确定四阶经典龙格-库塔 (RK4) 方法的全局截断误差定律。对于一个 $p$ 阶数值方法，当使用步长 $h$ 时，在固定的最终时间 $T$ 产生的全局误差 $e(h)$，在 $h$ 足够小的情况下，预计遵循幂律关系 $e(h) \\approx C h^p$。这里，$C$ 是一个依赖于微分方程和最终时间 $T$ 但不依赖于 $h$ 的常数。目标是通过对转换后的误差数据进行线性回归，为几个初值问题确定阶数 $p$ 和常数 $C$ 的经验值。\n\n初值问题由常微分方程 (ODE) $y^{\\prime}(t) = f(t, y)$ 和初始条件 $y(t_0) = y_0$ 给出。\n\n数值解的核心是 RK4 方法，这是一种单步、四级显式方法。为了将解从 $(t_n, y_n)$ 推进到 $(t_{n+1}, y_{n+1})$（其中 $t_{n+1} = t_n + h$），该方法计算四个中间斜率估计（级）$k_1, k_2, k_3, k_4$：\n$$k_1 = f(t_n, y_n)$$\n$$k_2 = f\\left(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_1\\right)$$\n$$k_3 = f\\left(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_2\\right)$$\n$$k_4 = f(t_n + h, y_n + hk_3)$$\n然后使用这些斜率的加权平均值来更新解：\n$$y_{n+1} = y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)$$\n\n为了确定误差模型 $e(h) \\approx C h^p$ 中的参数 $p$ 和 $C$，我们通过对两边取自然对数来将关系线性化：\n$$\\log(e(h)) \\approx \\log(C h^p) = \\log(C) + \\log(h^p) = \\log(C) + p \\log(h)$$\n此方程具有直线形式 $Y = mX + b$，其中 $Y = \\log(e(h))$，斜率为 $m = p$，自变量为 $X = \\log(h)$，y 轴截距为 $b = \\log(C)$。\n\n每个测试用例的总体算法如下：\n1. 对于给定集合中的每个步长 $h_i$，使用 RK4 方法求解从 $t_0$ 到 $T$ 的常微分方程。这涉及采取 $N_i = (T - t_0) / h_i$ 步来获得数值解 $y_{N_i}$。\n2. 计算在最终时间 $T$ 处的精确解 $y_{\\mathrm{exact}}(T)$。\n3. 计算每个步长的绝对全局误差：$e(h_i) = |y_{N_i} - y_{\\mathrm{exact}}(T)|$。\n4. 此过程产生一组数据点 $(h_i, e(h_i))$。\n5. 将这些数据点转换到对数尺度，创建一个新的点集 $(\\log(h_i), \\log(e(h_i)))$。\n6. 对这些转换后的点进行线性最小二乘回归，以找到最佳拟合直线。该直线的斜率是经验阶数 $p$，截距是 $\\log(C)$。\n7. 然后通过对截距取指数来恢复常数 $C$：$C = \\exp(\\log(C))$。\n8. 将得到的数对 $[p, C]$ 存储起来用于该测试用例。\n\n对问题陈述中提供的所有四个测试用例重复此过程。最终输出是每个案例的 $[p, C]$ 对的汇总。假设步长处于主阶误差项占主导地位的渐近区域，则每次回归使用多个步长可以提高推断参数的稳健性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Empirically reconstructs the global truncation error law for the RK4 method\n    by fitting observed errors to a power law e(h) = C*h^p.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"f\": lambda t, y: y,\n            \"t0\": 0.0,\n            \"y0\": 1.0,\n            \"T\": 1.0,\n            \"y_exact\": lambda t: np.exp(t),\n            \"h_values\": np.array([0.5, 0.25, 0.125, 0.0625])\n        },\n        {\n            \"f\": lambda t, y: -3.0 * y,\n            \"t0\": 0.0,\n            \"y0\": 2.0,\n            \"T\": 2.0,\n            \"y_exact\": lambda t: 2.0 * np.exp(-3.0 * t),\n            \"h_values\": np.array([0.5, 0.25, 0.125, 0.0625])\n        },\n        {\n            \"f\": lambda t, y: y + t,\n            \"t0\": 0.0,\n            \"y0\": 0.0,\n            \"T\": 0.8,\n            \"y_exact\": lambda t: np.exp(t) - t - 1.0,\n            \"h_values\": np.array([0.4, 0.2, 0.1, 0.05])\n        },\n        {\n            \"f\": lambda t, y: -5.0 * y,\n            \"t0\": 0.0,\n            \"y0\": 1.0,\n            \"T\": 1.0,\n            \"y_exact\": lambda t: np.exp(-5.0 * t),\n            \"h_values\": np.array([0.1, 0.05, 0.025, 0.0125])\n        }\n    ]\n\n    def run_rk4(f, y0, t0, T, h):\n        \"\"\"\n        Solves an ODE y'(t) = f(t,y) from t0 to T with step size h using RK4.\n        \n        Args:\n            f (callable): The function f(t, y).\n            y0 (float): The initial value y(t0).\n            t0 (float): The initial time.\n            T (float): The final time.\n            h (float): The step size.\n\n        Returns:\n            float: The numerical solution y(T).\n        \"\"\"\n        t = t0\n        y = y0\n        # Use rounding to ensure integer number of steps for the loop\n        num_steps = int(round((T - t0) / h))\n        \n        for _ in range(num_steps):\n            k1 = f(t, y)\n            k2 = f(t + 0.5 * h, y + 0.5 * h * k1)\n            k3 = f(t + 0.5 * h, y + 0.5 * h * k2)\n            k4 = f(t + h, y + h * k3)\n            y += (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n            t += h\n            \n        return y\n\n    results = []\n    for case in test_cases:\n        errors = []\n        h_vals = case[\"h_values\"]\n        \n        for h in h_vals:\n            y_numerical = run_rk4(case[\"f\"], case[\"y0\"], case[\"t0\"], case[\"T\"], h)\n            y_true = case[\"y_exact\"](case[\"T\"])\n            error = np.abs(y_numerical - y_true)\n            errors.append(error)\n        \n        # Transform data to log-log scale\n        log_h = np.log(h_vals)\n        log_e = np.log(np.array(errors))\n        \n        # Perform linear least-squares fit: log(e) = p*log(h) + log(C)\n        # np.polyfit returns [p, log(C)]\n        p, log_C = np.polyfit(log_h, log_e, 1)\n        \n        # Recover C from the intercept\n        C = np.exp(log_C)\n        \n        results.append([p, C])\n\n    # Convert results to a string with the specified format\n    # The default str() representation of a list is [item1, item2], which matches the requirement\n    # Example: str([4.0, 0.001]) -> '[4.0, 0.001]'\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3236754"}, {"introduction": "数值方法的一个核心工程目标是以最少的计算资源达到预设的精度要求。这个最终练习将理论付诸实践，展示了如何运用误差模型 $E \\approx K h^p$ 来主动控制误差。你将学习如何预测所需的步长以满足特定的误差容限，并通过实际计算来检验和修正你的预测，这个“预测-验证-调整”的循环是解决实际计算问题时的标准工作流程。[@problem_id:3236664]", "problem": "考虑形式为 $y^{\\prime}(t)=f(t,y(t))$ 的初值问题，其在有限区间 $[0,T]$ 上具有给定的初值条件 $y(0)=y_{0}$。假设 $f$ 足够光滑，以至于在 $[0,T]$ 上存在唯一的精确解 $y(t)$。对于一个相容且零稳定的 $p$ 阶单步数值方法，其阶数 $p$ 的含义是全局截断误差在步长 $h \\to 0$ 时渐近表现为 $O(h^{p})$，我们可以将步长为 $h$ 的网格上的最大节点全局误差与一个依赖于方法和问题的常数联系起来。具体来说，假设有一个已知的界常数 $C_{0}$，使得在小步长 $h$ 的渐近区域内，最大节点全局误差 $E(h)$ 满足 $E(h) \\leq C_{0}\\, h^{p}$。\n\n任务：编写一个完整的程序，对每个提供的测试用例，以数学上合理且计算上可验证的方式执行以下步骤。\n\n1. 从相容性、零稳定性和阶数定义（$p$ 阶）的基本原理出发，推导出选择步长 $h$ 所需的不等式，以保证最大节点全局误差 $E(h)$ 至多为用户指定的目标值 $\\epsilon$。使用提供的阶数 $p$ 和界常数 $C_{0}$，但不要假设任何未经证明的快捷公式。\n2. 使用推导出的关系式，计算初始步长 $h_{\\text{pred}}$，然后选择一个整数步数 $N_{0}$，使得 $h_{0}=T/N_{0}$ 不超过 $h_{\\text{pred}}$。这能确保网格与区间 $[0,T]$ 对齐，并遵守目标界限的逻辑。在此网格上计算数值解，并测量最大节点全局误差 $E(h_{0})=\\max_{0\\leq n \\leq N_{0}} \\left| y_{n}-y(t_{n}) \\right|$，其中 $t_{n}=n h_{0}$，$y_{n}$ 是数值解的值。\n3. 通过将步数加倍至 $N_{1}=2N_{0}$ 来使步长减半，得到 $h_{1}=T/N_{1}$。重新计算数值解并测量 $E(h_{1})$。\n4. 使用两个计算出的误差，并考虑到对于足够小的 $h$ 其渐近行为为 $E(h) \\approx K\\, h^{p}$，来估计一个测量的渐近误差常数 $K_{\\text{meas}}$。使用一个不会低估该常数的保守估计。\n5. 使用测量的常数 $K_{\\text{meas}}$，计算一个调整后的步长 $h_{\\text{adj}}$ 以满足目标误差 $\\epsilon$。选择一个整数步数 $N_{\\text{adj}}$，使得 $h_{\\text{adj}}=T/N_{\\text{adj}}$ 不超过由 $K_{\\text{meas}}$ 预测的值。通过计算验证最终的最大节点全局误差 $E(h_{\\text{adj}})$ 是否满足目标 $\\epsilon$。\n6. 对于每个测试用例，返回列表 $[h_{0}, E(h_{0}), h_{1}, E(h_{1}), K_{\\text{meas}}, h_{\\text{adj}}, E(h_{\\text{adj}}), \\text{meets\\_target}]$，其中 $\\text{meets\\_target}$ 是一个布尔值，指示 $E(h_{\\text{adj}}) \\leq \\epsilon$ 是否成立。\n\n您必须实现两种方法：经典四阶龙格-库塔方法和显式欧拉方法，并在网格点上测量最大节点全局误差。当出现三角函数时，将角度视为弧度。\n\n测试套件：\n- 案例 A (理想路径，光滑自治问题):\n  - 微分方程: $y^{\\prime}(t)=-y(t)$，精确解 $y(t)=e^{-t}$。\n  - 区间: $T=1$。\n  - 初值条件: $y_{0}=1$。\n  - 方法: 经典四阶龙格-库塔方法。\n  - 阶数: $p=4$。\n  - 误差目标: $\\epsilon=10^{-6}$。\n  - 已知界常数: $C_{0}=2\\times 10^{-2}$。\n- 案例 B (带三角系数的非自治问题，角度为弧度):\n  - 微分方程: $y^{\\prime}(t)=y(t)\\cos(t)$，精确解 $y(t)=\\exp(\\sin(t))$。\n  - 区间: $T=\\pi$。\n  - 初值条件: $y_{0}=1$。\n  - 方法: 经典四阶龙格-库塔方法。\n  - 阶数: $p=4$。\n  - 误差目标: $\\epsilon=5\\times 10^{-7}$。\n  - 已知界常数: $C_{0}=2\\times 10^{-1}$。\n- 案例 C (使用一阶方法的边界案例):\n  - 微分方程: $y^{\\prime}(t)=-y(t)$，精确解 $y(t)=e^{-t}$。\n  - 区间: $T=1$。\n  - 初值条件: $y_{0}=1$。\n  - 方法: 显式欧拉方法。\n  - 阶数: $p=1$。\n  - 误差目标: $\\epsilon=10^{-2}$。\n  - 已知界常数: $C_{0}=8\\times 10^{-1}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个条目，每个条目是列表 $[h_{0}, E(h_{0}), h_{1}, E(h_{1}), K_{\\text{meas}}, h_{\\text{adj}}, E(h_{\\text{adj}}), \\text{meets\\_target}]$。例如，打印的行应类似于 $[[\\ldots],[\\ldots],[\\ldots]]$。没有物理单位；所有量都是无量纲的。所有角度均为弧度。", "solution": "该问题经评估是有效的。它在科学上基于常微分方程数值分析的原理，是适定的，提供了所有必要信息，并使用客观、正式的语言陈述。各项任务在计算上是可验证的，并直接涉及全局截断误差和步长选择的主题。\n\n解决方案首先推导必要的数学关系，然后将它们在计算上应用于每个指定的测试用例。\n\n### 1. 理论推导\n\n问题围绕求解以下形式的初值问题 (IVP)：\n$$\ny^{\\prime}(t) = f(t, y(t)), \\quad y(0) = y_0\n$$\n在有限区间 $[0, T]$ 上。给定一个单步数值方法的收敛阶为 $p$，这意味着对于小步长 $h$，其最大节点全局误差 $E(h)$ 的渐近行为如下：\n$$\nE(h) = \\max_{0 \\le n \\le N} |y_n - y(t_n)| \\approx K h^p\n$$\n其中 $y_n$ 是在网格点 $t_n = n h$ 处对精确解 $y(t_n)$ 的数值近似，$K$ 是一个依赖于方法和具体初值问题的渐近误差常数。问题提供了一个已知的上界常数 $C_0$，使得在渐近区域内 $E(h) \\le C_0 h^p$ 成立。\n\n#### 1.1. 步长选择\n我们的首要目标是推导步长 $h$ 的关系式，以保证全局误差 $E(h)$ 不超过指定的容差 $\\epsilon$。使用给定的界限：\n$$\nE(h) \\le C h^p\n$$\n为确保 $E(h) \\le \\epsilon$，我们必须施加条件：\n$$\nC h^p \\le \\epsilon\n$$\n对 $h$ 求解此不等式可得：\n$$\nh^p \\le \\frac{\\epsilon}{C} \\implies h \\le \\left(\\frac{\\epsilon}{C}\\right)^{1/p}\n$$\n这个不等式是选择步长的基本关系。给定一个常数 $C$（初始界 $C_0$ 或测量的常数 $K_{\\text{meas}}$），允许的最大预测步长为 $h_{\\text{pred}} = (\\epsilon/C)^{1/p}$。为确保网格点与区间 $[0, T]$ 对齐，我们必须选择一个整数步数 $N$。步长则为 $h = T/N$。为满足推导出的约束，我们需要 $T/N \\le h_{\\text{pred}}$，这意味着 $N \\ge T/h_{\\text{pred}}$。为了使用遵守该界限的尽可能大的步长（从而使用最少的步数），我们选择满足此条件的最小整数 $N$：\n$$\nN = \\left\\lceil \\frac{T}{h_{\\text{pred}}} \\right\\rceil\n$$\n其中 $\\lceil \\cdot \\rceil$ 是上取整函数。实际使用的步长则为 $h = T/N$。\n\n#### 1.2. 渐近误差常数的估计\n在用步长 $h_0$ 和 $h_1 = h_0/2$ 进行两次计算，得到误差 $E(h_0)$ 和 $E(h_1)$ 之后，我们可以估计真实的渐近常数 $K$。假设两次计算都在渐近区域内：\n$$\nE(h_0) \\approx K h_0^p\n$$\n$$\nE(h_1) \\approx K h_1^p\n$$\n我们可以从每次计算中获得对 $K$ 的估计。例如，从第二次更精确的计算中可得：$K \\approx E(h_1) / h_1^p$。正如问题所建议的，为了保守起见且不低估该常数，审慎的做法是计算两个估计值 $K_{\\text{est},0} = E(h_0)/h_0^p$ 和 $K_{\\text{est},1} = E(h_1)/h_1^p$，并取两者中的较大者作为我们测量的常数：\n$$\nK_{\\text{meas}} = \\max\\left(\\frac{E(h_0)}{h_0^p}, \\frac{E(h_1)}{h_1^p}\\right)\n$$\n这个测量的常数 $K_{\\text{meas}}$ 是根据方法在特定问题上的实际表现经验性推导出来的，通常比一般的理论界 $C_0$ 是一个更紧的估计。\n\n### 2. 算法流程\n每个测试用例的总体流程如下：\n\n1.  **初始步长计算**：\n    *   使用提供的界 $C_0$ 计算初始预测步长：$h_{\\text{pred},0} = (\\epsilon / C_0)^{1/p}$。\n    *   确定步数：$N_0 = \\lceil T / h_{\\text{pred},0} \\rceil$。\n    *   设置初始步长：$h_0 = T/N_0$。\n\n2.  **第一次数值求解与误差计算**：\n    *   使用指定的数值方法（显式欧拉或 RK4）以 $N_0$ 步求解在 $[0, T]$ 上的常微分方程。\n    *   计算最大节点全局误差：$E(h_0) = \\max_{0 \\le n \\le N_0} |y_n - y(t_n)|$。\n\n3.  **第二次数值求解与误差计算**：\n    *   设置 $N_1 = 2N_0$ 和 $h_1 = T/N_1 = h_0/2$。\n    *   以 $N_1$ 步再次求解常微分方程。\n    *   计算相应的误差：$E(h_1) = \\max_{0 \\le n \\le N_1} |y_n - y(t_n)|$。\n\n4.  **估计渐近常数**：\n    *   使用上面推导的保守公式计算测量常数 $K_{\\text{meas}}$：$K_{\\text{meas}} = \\max(E(h_0)/h_0^p, E(h_1)/h_1^p)$。\n\n5.  **调整步长与最终验证**：\n    *   使用 $K_{\\text{meas}}$ 计算调整后的预测步长：$h_{\\text{pred,adj}} = (\\epsilon / K_{\\text{meas}})^{1/p}$。\n    *   确定调整后的步数：$N_{\\text{adj}} = \\lceil T / h_{\\text{pred,adj}} \\rceil$。\n    *   设置调整后的步长：$h_{\\text{adj}} = T/N_{\\text{adj}}$。\n    *   以 $N_{\\text{adj}}$ 步最后一次求解常微分方程。\n    *   计算最终误差：$E(h_{\\text{adj}}) = \\max_{0 \\le n \\le N_{\\text{adj}}} |y_n - y(t_n)|$。\n    *   验证是否达到误差目标：检查 $E(h_{\\text{adj}}) \\le \\epsilon$ 是否成立。\n\n6.  **报告结果**：为每个测试用例编译列表 $[h_0, E(h_0), h_1, E(h_1), K_{\\text{meas}}, h_{\\text{adj}}, E(h_{\\text{adj}}), \\text{meets\\_target}]$。\n\n### 3. 数值方法\n两种所需的单步方法由其更新规则定义。\n\n*   **显式欧拉方法（$p=1$ 阶）**：\n    $$\n    y_{n+1} = y_n + h f(t_n, y_n)\n    $$\n\n*   **经典四阶龙格-库塔方法（RK4，$p=4$ 阶）**：\n    \\begin{align*}\n    k_1 = f(t_n, y_n) \\\\\n    k_2 = f(t_n + h/2, y_n + (h/2) k_1) \\\\\n    k_3 = f(t_n + h/2, y_n + (h/2) k_2) \\\\\n    k_4 = f(t_n + h, y_n + h k_3) \\\\\n    y_{n+1} = y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n    \\end{align*}\n\n针对每个提供的测试用例，实现了这些步骤和公式。", "answer": "```python\nimport numpy as np\n\ndef solve_ode(method_name, f, y0, T, N):\n    \"\"\"\n    Solves an ODE y'(t) = f(t, y) using a specified one-step method.\n\n    Args:\n        method_name (str): Name of the method ('euler' or 'rk4').\n        f (callable): Function f(t, y).\n        y0 (float): Initial condition y(0).\n        T (float): Final time.\n        N (int): Number of steps.\n\n    Returns:\n        tuple: (numpy.ndarray of time points, numpy.ndarray of solution values).\n    \"\"\"\n    h = T / N\n    t = np.linspace(0, T, N + 1)\n    y = np.zeros(N + 1)\n    y[0] = y0\n\n    if method_name == 'euler':\n        for n in range(N):\n            y[n + 1] = y[n] + h * f(t[n], y[n])\n    elif method_name == 'rk4':\n        for n in range(N):\n            k1 = f(t[n], y[n])\n            k2 = f(t[n] + h / 2, y[n] + h / 2 * k1)\n            k3 = f(t[n] + h / 2, y[n] + h / 2 * k2)\n            k4 = f(t[n] + h, y[n] + h * k3)\n            y[n + 1] = y[n] + h / 6 * (k1 + 2 * k2 + 2 * k3 + k4)\n    else:\n        raise ValueError(\"Unknown method specified.\")\n        \n    return t, y\n\ndef calculate_max_error(t, y_num, y_exact_func):\n    \"\"\"Calculates the maximum nodal global error.\"\"\"\n    y_exact_vals = y_exact_func(t)\n    return np.max(np.abs(y_num - y_exact_vals))\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and generate the final output.\n    \"\"\"\n    # Test Suite Definition\n    test_cases = [\n        # Case A\n        {\n            \"f\": lambda t, y: -y,\n            \"y_exact\": lambda t: np.exp(-t),\n            \"T\": 1.0,\n            \"y0\": 1.0,\n            \"method\": \"rk4\",\n            \"p\": 4.0,\n            \"epsilon\": 1e-6,\n            \"C0\": 2e-2\n        },\n        # Case B\n        {\n            \"f\": lambda t, y: y * np.cos(t),\n            \"y_exact\": lambda t: np.exp(np.sin(t)),\n            \"T\": np.pi,\n            \"y0\": 1.0,\n            \"method\": \"rk4\",\n            \"p\": 4.0,\n            \"epsilon\": 5e-7,\n            \"C0\": 2e-1\n        },\n        # Case C\n        {\n            \"f\": lambda t, y: -y,\n            \"y_exact\": lambda t: np.exp(-t),\n            \"T\": 1.0,\n            \"y0\": 1.0,\n            \"method\": \"euler\",\n            \"p\": 1.0,\n            \"epsilon\": 1e-2,\n            \"C0\": 8e-1\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        f = case[\"f\"]\n        y_exact = case[\"y_exact\"]\n        T = case[\"T\"]\n        y0 = case[\"y0\"]\n        method = case[\"method\"]\n        p = case[\"p\"]\n        epsilon = case[\"epsilon\"]\n        C0 = case[\"C0\"]\n\n        # 1. Initial Step Size Calculation\n        h_pred_0 = (epsilon / C0)**(1 / p)\n        N0 = int(np.ceil(T / h_pred_0))\n        h0 = T / N0\n\n        # 2. First Numerical Solution and Error\n        t0, y0_num = solve_ode(method, f, y0, T, N0)\n        E_h0 = calculate_max_error(t0, y0_num, y_exact)\n\n        # 3. Second Numerical Solution and Error\n        N1 = 2 * N0\n        h1 = T / N1\n        t1, y1_num = solve_ode(method, f, y0, T, N1)\n        E_h1 = calculate_max_error(t1, y1_num, y_exact)\n\n        # 4. Estimate Asymptotic Constant\n        # Handle cases where error is zero to avoid division by zero\n        K_est_0 = E_h0 / (h0**p) if h0 > 0 else 0\n        K_est_1 = E_h1 / (h1**p) if h1 > 0 else 0\n        K_meas = max(K_est_0, K_est_1)\n        # Prevent K_meas from being zero if errors are zero\n        if K_meas == 0:\n            K_meas = 1e-12 # A small non-zero value\n\n        # 5. Adjusted Step Size and Final Verification\n        h_pred_adj = (epsilon / K_meas)**(1 / p)\n        N_adj = int(np.ceil(T / h_pred_adj))\n        h_adj = T / N_adj\n        \n        t_adj, y_adj_num = solve_ode(method, f, y0, T, N_adj)\n        E_h_adj = calculate_max_error(t_adj, y_adj_num, y_exact)\n        \n        meets_target = bool(E_h_adj <= epsilon)\n\n        # 6. Report Results\n        case_results = [h0, E_h0, h1, E_h1, K_meas, h_adj, E_h_adj, meets_target]\n        all_results.append(case_results)\n\n    # Format the final output string exactly as required.\n    # Convert boolean to lowercase string for printing.\n    # Format floats to a consistent representation.\n    def format_list(lst):\n        items = []\n        for item in lst:\n            if isinstance(item, bool):\n                items.append(str(item).lower())\n            else:\n                items.append(f\"{item:.10g}\")\n        return \"[\" + \",\".join(items) + \"]\"\n\n    output_str = \"[\" + \",\".join(map(format_list, all_results)) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3236664"}]}