{"hands_on_practices": [{"introduction": "理解数值方法的最佳途径之一是亲自动手进行计算。本练习将引导你手动执行一个完整的两步 Adams-Bashforth (AB2) 方法的计算过程。通过这个练习，你将直接体验多步法的一个核心特点：它需要一个“启动”方法来生成初始序列，本题将使用简单的欧拉法来完成此步骤，从而为更高阶的计算铺平道路。[@problem_id:2152563]", "problem": "考虑以下初值问题 (IVP)：\n$$ y'(t) = -y(t)\\sin(t), \\quad y(0) = 1 $$\n我们希望使用多步法求 $y(0.3)$ 的数值近似解。\n\n您需要使用步长恒为 $h=0.1$ 的两步 Adams-Bashforth (AB2) 方法。AB2 方法的公式如下：\n$$ y_{n+1} = y_n + \\frac{h}{2}(3f_n - f_{n-1}) $$\n其中 $t_k = kh$，$y_k \\approx y(t_k)$，且 $f_k = f(t_k, y_k) = -y_k\\sin(t_k)$。\n\n由于 AB2 方法是两步法，它需要两个初始值才能开始。使用给定的初始条件 $y_0 = y(0) = 1$，并使用前向欧拉法计算第一个近似值 $y_1 \\approx y(0.1)$：\n$$ y_{n+1} = y_n + h f_n $$\n在求出 $y_1$ 后，使用 AB2 方法计算后续步骤，以求得 $y(0.3)$ 的近似值。\n\n计算 $y(0.3)$ 近似值的数值。将您的最终答案四舍五入到五位有效数字。", "solution": "给定初值问题 $y'(t)=-y(t)\\sin(t)$，其中 $y(0)=1$，步长 $h=0.1$，且 $f(t,y)=-y\\sin(t)$。定义 $t_{k}=kh$，$y_{k}\\approx y(t_{k})$，以及 $f_{k}=f(t_{k},y_{k})$。\n\n首先使用前向欧拉法求 $y_{1}$：\n$$\ny_{0}=1,\\quad f_{0}=-y_{0}\\sin(0)=0,\\quad y_{1}=y_{0}+h f_{0}=1+0.1\\cdot 0=1.\n$$\n\n现在应用 AB2 方法 $y_{n+1}=y_{n}+\\frac{h}{2}\\left(3f_{n}-f_{n-1}\\right)$。\n\n计算到 $t_{2}=0.2$ 的步骤：\n$$\nf_{1}=-y_{1}\\sin(0.1)=-\\sin(0.1)\\approx -0.0998334166468282,\n$$\n$$\ny_{2}=y_{1}+\\frac{h}{2}\\left(3f_{1}-f_{0}\\right)=1+0.05\\left(3(-0.0998334166468282)-0\\right)\n=1-0.0149750124970242\\approx 0.9850249875029758.\n$$\n\n计算 $f_{2}$：\n$$\nf_{2}=-y_{2}\\sin(0.2)\\approx -0.9850249875029758\\cdot 0.19866933079506122\\approx -0.19569425508362975.\n$$\n\n计算到 $t_{3}=0.3$ 的步骤：\n$$\ny_{3}=y_{2}+\\frac{h}{2}\\left(3f_{2}-f_{1}\\right)\n=0.9850249875029758+0.05\\left(3(-0.19569425508362975)-(-0.0998334166468282)\\right)\n$$\n$$\n=0.9850249875029758+0.05\\left(-0.58708276525088925+0.0998334166468282\\right)\n=0.9850249875029758-0.0243624674302031\\approx 0.9606625200727727.\n$$\n\n因此，$y(0.3)$ 的 AB2 近似值为 $0.9606625200727727$，四舍五入到五位有效数字为 $0.96066$。", "answer": "$$\\boxed{0.96066}$$", "id": "2152563"}, {"introduction": "掌握了基本计算之后，探索方法的适用边界同样重要。这个练习构建了一个特殊的场景，在这个场景中，阶数更高的两步 Adams-Bashforth 方法产生的误差反而比最简单的前向欧拉法更大。这个看似反常的结果揭示了 Adams-Bashforth 方法的一个基本假设——即函数的光滑性，它通过多项式外插来预测未来值，当函数导数发生突变时，这种预测就可能出现严重偏差。[@problem_id:2152541]", "problem": "考虑由常微分方程给出的初值问题：\n$$\n\\frac{dy}{dt} = |t - 1|\n$$\n初始条件为 $y(0) = 0$。\n\n我们希望使用两种不同的数值方法来近似计算 $y(2.0)$ 的值，两种方法的步长均为 $h=1.0$。\n\n方法1是前向欧拉法，定义为：\n$y_{n+1} = y_n + h f(t_n, y_n)$。\n\n方法2是两步亚当斯-巴什福斯（AB2）方法，定义为：\n$y_{n+1} = y_n + \\frac{h}{2} [3 f(t_n, y_n) - f(t_{n-1}, y_{n-1})]$。\n为了初始化AB2方法，第一步的值，即 $y(1.0)$ 的近似值，将使用一步前向欧拉法计算。\n\n设 $E_{FE}$ 为前向欧拉法的绝对误差 $|y_{true}(2.0) - y_{approx}^{FE}(2.0)|$，设 $E_{AB2}$ 为两步亚当斯-巴什福斯方法的绝对误差 $|y_{true}(2.0) - y_{approx}^{AB2}(2.0)|$。\n\n根据你的计算，以下哪个陈述正确描述了这两个误差之间的关系？\n\nA. $E_{AB2}  E_{FE}$\n\nB. $E_{AB2} = E_{FE}$\n\nC. $E_{AB2} > E_{FE}$\n\nD. 两种方法都是精确的，即 $E_{AB2} = E_{FE} = 0$。\n\nE. 亚当斯-巴什福斯方法无法应用，因为函数 $f(t,y)=|t-1|$ 在 $t=1$ 处不可微。", "solution": "我们给定的初值问题是 $y'(t) = |t - 1|$，$y(0)=0$，我们要求解步长 $h=1.0$ 时 $y(2.0)$ 的值。\n\n首先，计算在 $t=2$ 处的精确解。由于 $y'(t)=|t-1|$ 仅依赖于 $t$，解是积分\n$$\ny(t) = \\int_{0}^{t} |s - 1| \\, ds.\n$$\n因此，\n$$\ny(2) = \\int_{0}^{1} (1 - s) \\, ds + \\int_{1}^{2} (s - 1) \\, ds = \\left[ s - \\frac{s^{2}}{2} \\right]_{0}^{1} + \\left[ \\frac{s^{2}}{2} - s \\right]_{1}^{2} = \\frac{1}{2} + \\frac{1}{2} = 1.\n$$\n\n使用步长 $h=1.0$ 的前向欧拉法（FE），我们有 $t_{0}=0$，$t_{1}=1$，$t_{2}=2$ 和 $y_{0}=0$，其更新公式为\n$$\ny_{n+1} = y_{n} + h f(t_{n}, y_{n}), \\quad f(t,y)=|t-1|.\n$$\n从 $t_{0}$ 到 $t_{1}$ 的一步：\n$$\ny_{1} = y_{0} + 1 \\cdot |0 - 1| = 0 + 1 = 1.\n$$\n从 $t_{1}$ 到 $t_{2}$ 的一步：\n$$\ny_{2}^{FE} = y_{1} + 1 \\cdot |1 - 1| = 1 + 0 = 1.\n$$\n因此 $y_{approx}^{FE}(2.0)=1$，所以\n$$\nE_{FE} = |y_{true}(2.0) - y_{approx}^{FE}(2.0)| = |1 - 1| = 0.\n$$\n\n两步亚当斯-巴什福斯（AB2）方法使用一步前向欧拉法进行初始化。如上所示，前向欧拉法初始化给出 $y_{1}=1$。AB2的更新公式是\n$$\ny_{n+1} = y_{n} + \\frac{h}{2} \\big(3 f(t_{n}, y_{n}) - f(t_{n-1}, y_{n-1}) \\big).\n$$\n对于 $n=1$，步长 $h=1$，$t_{1}=1$，$t_{0}=0$，我们有\n$$\nf(t_{1}, y_{1}) = |1 - 1| = 0, \\quad f(t_{0}, y_{0}) = |0 - 1| = 1,\n$$\n所以\n$$\ny_{2}^{AB2} = y_{1} + \\frac{1}{2} \\big(3 \\cdot 0 - 1 \\big) = 1 - \\frac{1}{2} = \\frac{1}{2}.\n$$\n因此\n$$\nE_{AB2} = |y_{true}(2.0) - y_{approx}^{AB2}(2.0)| = \\left| 1 - \\frac{1}{2} \\right| = \\frac{1}{2}.\n$$\n\n因此，误差满足 $E_{AB2} > E_{FE}$。亚当斯-巴什福斯方法在此是适用的，因为它仅需要对函数 $f(t,y)$进行求值，而 $f(t,y)=|t-1|$ 在所需的点上是连续且良定义的；单点的不可微性并不妨碍应用该方法。\n\n正确选项是C。", "answer": "$$\\boxed{C}$$", "id": "2152541"}, {"introduction": "在之前练习的基础上，这个更高级的实践将探讨初始值的精度如何影响整个数值模拟的全局误差。你将通过编程实现一个四步 Adams-Bashforth (AB4) 方法，并对比使用低精度（欧拉法）和高精度（四阶龙格-库塔法）启动方法时的最终结果。这个练习将量化一个重要原则：多步法的整体精度受限于其启动值的精度，从而加深你对误差传播和累积的理解。[@problem_id:3202848]", "problem": "考虑常微分方程 (ODE) $y'(t) = f(t,y(t))$ 的初值问题，其初始条件为 $y(t_0) = y_0$，其中 $f$ 足够光滑。显式四步 Adams–Bashforth 方法 (AB4) 通过 $f$ 的过去计算值的线性组合来推进数值状态，并需要在 $t_0, t_1, t_2, t_3$ 处的四个起始值。从第一性原理出发，通过从积分形式 $y(t_{n+1}) = y(t_n) + \\int_{t_n}^{t_{n+1}} f(s,y(s))\\,ds$ 开始，并通过在均匀网格点 $t_n, t_{n-1}, t_{n-2}, t_{n-3}$（所有点都以恒定步长 $h = t_{n+1}-t_n$ 间隔）上的拉格朗日插值多项式来近似 $[t_n,t_{n+1}]$ 上的 $f(s,y(s))$，来构建 AB4 方法。在您的构建过程中，请勿使用任何预先制表的 Adams–Bashforth 系数。\n\n您将量化当四个起始值分别由前向欧拉法和四阶龙格－库塔方法 (RK4) 生成时，对 AB4 模拟全局误差的影响。将网格 $\\{t_n\\}_{n=0}^N$ 上的全局误差定义为数值解与精确解在所有网格节点上的最大绝对差，即 $\\max_{0 \\le n \\le N} \\lvert y_n - y(t_n) \\rvert$。\n\n对于下方的每个测试案例，执行两次 AB4 运行：\n- 使用前向欧拉法计算 $n = 0,1,2,3$ 的起始值的 AB4。\n- 使用四阶龙格－库塔方法 (RK4) 计算 $n = 0,1,2,3$ 的起始值的 AB4。\n\n然后，对每个测试案例，计算全局误差的比率\n$$R = \\frac{\\max_{0 \\le n \\le N} \\lvert y_n^{\\text{(Euler start)}} - y(t_n) \\rvert}{\\max_{0 \\le n \\le N} \\lvert y_n^{\\text{(RK4 start)}} - y(t_n) \\rvert}.$$\n\n涉及角度的函数必须使用弧度。本问题中没有物理单位。使用以下测试套件，其中 $N$ 的选择应使 $T/h$ 为整数，且 $t_n = t_0 + n h$：\n- 测试案例 1：$f(t,y) = -y$, $y(0) = 1$, $t_0 = 0$, $T = 4$, $h = 0.1$，精确解 $y(t) = e^{-t}$。\n- 测试案例 2：$f(t,y) = -y$, $y(0) = 1$, $t_0 = 0$, $T = 4$, $h = 0.5$，精确解 $y(t) = e^{-t}$。\n- 测试案例 3：$f(t,y) = -4\\,y$, $y(0) = 1$, $t_0 = 0$, $T = 2.4$, $h = 0.2$，精确解 $y(t) = e^{-4 t}$。\n- 测试案例 4：$f(t,y) = -4\\,y$, $y(0) = 1$, $t_0 = 0$, $T = 2.4$, $h = 0.6$，精确解 $y(t) = e^{-4 t}$。\n- 测试案例 5：$f(t,y) = -y + \\sin(t)$, $y(0) = 1$, $t_0 = 0$, $T = 10$, $h = 0.1$，精确解 $y(t) = \\tfrac{1}{2}\\big(\\sin(t) - \\cos(t)\\big) + \\tfrac{3}{2} e^{-t}$，角度以弧度为单位。\n- 测试案例 6：$f(t,y) = -y + \\sin(t)$, $y(0) = 1$, $t_0 = 0$, $T = 10$, $h = 0.25$，精确解 $y(t) = \\tfrac{1}{2}\\big(\\sin(t) - \\cos(t)\\big) + \\tfrac{3}{2} e^{-t}$，角度以弧度为单位。\n\n您的程序应生成一行输出，其中包含六个测试案例的结果，格式为方括号内以逗号分隔的列表（例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$），其中每个 $r_i$ 是测试案例 $i$ 的 $R$ 的浮点值。", "solution": "所述问题在科学上是合理的、适定的、客观的且自包含的。这是一个数值分析中的典型问题，旨在探究显式四步 Adams-Bashforth ($AB4$) 方法的性质，特别是起步过程的精度对全局误差的影响。测试案例是标准的，包含了测试该方法的收敛性和稳定性的场景。因此，该问题被认为是有效的，值得提供完整解答。\n\n解答将分三部分呈现：首先，从第一性原理推导四步 Adams-Bashforth 方法；其次，分析起步方法的作用及其对全局误差和稳定性的影响；第三，解决所提供测试案例的实现策略。\n\n### 1. 四步 Adams-Bashforth (AB4) 方法的推导\n\n我们从一阶常微分方程 ($ODE$) 的初值问题开始：\n$$ y'(t) = f(t, y(t)), \\quad y(t_0) = y_0 $$\n通过将此方程从 $t_n$ 积分到 $t_{n+1}$，其中对于恒定步长 $h$ 有 $t_k = t_0 + k h$，我们得到精确关系式：\n$$ y(t_{n+1}) = y(t_n) + \\int_{t_n}^{t_{n+1}} f(s, y(s)) \\, ds $$\nAdams-Bashforth 方法通过用一个插值多项式替换（未知的）函数 $f(s, y(s))$ 来近似该积分。显式 $k$ 步 Adams-Bashforth 方法使用一个在时间点 $t_n, t_{n-1}, \\ldots, t_{n-k+1}$ 对 $k$ 个先前计算的 $f$ 值进行插值的多项式。\n\n对于四步方法 ($AB4$)，我们用一个最多 3 次的多项式 $P_3(s)$ 来近似 $f(s,y(s))$，该多项式穿过四个点 $(t_n, f_n), (t_{n-1}, f_{n-1}), (t_{n-2}, f_{n-2}),$ 和 $(t_{n-3}, f_{n-3})$，其中 $f_k = f(t_k, y_k)$。于是，数值格式为：\n$$ y_{n+1} = y_n + \\int_{t_n}^{t_{n+1}} P_3(s) \\, ds $$\n为了找到系数，我们使用拉格朗日基多项式构造 $P_3(s)$。为便于积分，我们进行变量替换 $s = t_n + \\alpha h$，这意味着 $ds = h \\, d\\alpha$。积分区间 $[t_n, t_{n+1}]$ 变为 $[\\alpha=0, \\alpha=1]$。插值节点 $t_n, t_{n-1}, t_{n-2}, t_{n-3}$ 分别对应于 $\\alpha=0, -1, -2, -3$。\n\n拉格朗日插值多项式由下式给出：\n$$ P_3(t_n + \\alpha h) = f_n L_0(\\alpha) + f_{n-1} L_1(\\alpha) + f_{n-2} L_2(\\alpha) + f_{n-3} L_3(\\alpha) $$\n其中基多项式 $L_j(\\alpha)$ 在节点 $\\{0, -1, -2, -3\\}$ 上定义：\n\\begin{align*} L_0(\\alpha) = \\frac{(\\alpha - (-1))(\\alpha - (-2))(\\alpha - (-3))}{(0 - (-1))(0 - (-2))(0 - (-3))} = \\frac{(\\alpha+1)(\\alpha+2)(\\alpha+3)}{6} \\\\ L_1(\\alpha) = \\frac{(\\alpha - 0)(\\alpha - (-2))(\\alpha - (-3))}{(-1 - 0)(-1 - (-2))(-1 - (-3))} = \\frac{\\alpha(\\alpha+2)(\\alpha+3)}{-2} \\\\ L_2(\\alpha) = \\frac{(\\alpha - 0)(\\alpha - (-1))(\\alpha - (-3))}{(-2 - 0)(-2 - (-1))(-2 - (-3))} = \\frac{\\alpha(\\alpha+1)(\\alpha+3)}{2} \\\\ L_3(\\alpha) = \\frac{(\\alpha - 0)(\\alpha - (-1))(\\alpha - (-2))}{(-3 - 0)(-3 - (-1))(-3 - (-2))} = \\frac{\\alpha(\\alpha+1)(\\alpha+2)}{-6} \\end{align*}\n积分项变为：\n$$ \\int_{t_n}^{t_{n+1}} P_3(s) \\, ds = h \\int_0^1 \\left( f_n L_0(\\alpha) + f_{n-1} L_1(\\alpha) + f_{n-2} L_2(\\alpha) + f_{n-3} L_3(\\alpha) \\right) \\, d\\alpha $$\n我们必须计算拉格朗日基多项式从 $0$ 到 $1$ 的定积分：\n\\begin{align*} \\int_0^1 L_0(\\alpha) \\, d\\alpha = \\frac{1}{6} \\int_0^1 (\\alpha^3 + 6\\alpha^2 + 11\\alpha + 6) \\, d\\alpha = \\frac{1}{6} \\left[\\frac{\\alpha^4}{4} + 2\\alpha^3 + \\frac{11\\alpha^2}{2} + 6\\alpha\\right]_0^1 = \\frac{1}{6} \\left(\\frac{1}{4} + 2 + \\frac{11}{2} + 6\\right) = \\frac{55}{24} \\\\ \\int_0^1 L_1(\\alpha) \\, d\\alpha = -\\frac{1}{2} \\int_0^1 (\\alpha^3 + 5\\alpha^2 + 6\\alpha) \\, d\\alpha = -\\frac{1}{2} \\left[\\frac{\\alpha^4}{4} + \\frac{5\\alpha^3}{3} + 3\\alpha^2\\right]_0^1 = -\\frac{1}{2} \\left(\\frac{1}{4} + \\frac{5}{3} + 3\\right) = -\\frac{59}{24} \\\\ \\int_0^1 L_2(\\alpha) \\, d\\alpha = \\frac{1}{2} \\int_0^1 (\\alpha^3 + 4\\alpha^2 + 3\\alpha) \\, d\\alpha = \\frac{1}{2} \\left[\\frac{\\alpha^4}{4} + \\frac{4\\alpha^3}{3} + \\frac{3\\alpha^2}{2}\\right]_0^1 = \\frac{1}{2} \\left(\\frac{1}{4} + \\frac{4}{3} + \\frac{3}{2}\\right) = \\frac{37}{24} \\\\ \\int_0^1 L_3(\\alpha) \\, d\\alpha = -\\frac{1}{6} \\int_0^1 (\\alpha^3 + 3\\alpha^2 + 2\\alpha) \\, d\\alpha = -\\frac{1}{6} \\left[\\frac{\\alpha^4}{4} + \\alpha^3 + \\alpha^2\\right]_0^1 = -\\frac{1}{6} \\left(\\frac{1}{4} + 1 + 1\\right) = -\\frac{9}{24} \\end{align*}\n将这些系数代入数值格式，得到四步 Adams-Bashforth ($AB4$) 方法：\n$$ y_{n+1} = y_n + \\frac{h}{24} \\left( 55 f(t_n, y_n) - 59 f(t_{n-1}, y_{n-1}) + 37 f(t_{n-2}, y_{n-2}) - 9 f(t_{n-3}, y_{n-3}) \\right) $$\n\n### 2. 起步方法与全局误差分析\n\n$AB4$ 公式是一种多步法；为了计算 $y_{n+1}$，它需要知道前四个步骤的解。要计算 $y_4$ (对于 $n=3$)，我们需要 $(y_0, y_1, y_2, y_3)$ 的值。初始条件提供了 $y_0$。值 $y_1, y_2,$ 和 $y_3$ 必须由另一种自启动方法（一种单步法）生成。这些起始值的精度对整个模拟的全局精度有至关重要的影响。\n\n$AB4$ 方法的局部截断误差为 $O(h^5)$，这导致全局误差为 $O(h^4)$ 阶，前提是起始值足够精确（即至少为 $O(h^4)$）。\n\n问题指定了两种起步方法：\n1.  **前向欧拉法**：$y_{k+1} = y_k + h f(t_k, y_k)$。这是一种一阶方法，其局部截断误差为 $O(h^2)$，全局误差为 $O(h)$。当用于启动 $AB4$ 积分时，起始值 $y_1, y_2, y_3$ 中的 $O(h)$ 误差将污染整个解。起步方法的低精度将占主导地位，导致组合格式的最终全局误差仅为 $O(h)$。\n\n2.  **四阶龙格－库塔 (RK4) 方法**：$y_{k+1} = y_k + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)$，其中 $k_i$ 是中间斜率的评估值。该方法的全局误差为 $O(h^4)$ 阶。由于起步方法的精度与主 $AB4$ 方法的精度相匹配，因此整个格式保持了所期望的 $O(h^4)$ 全局误差。\n\n因此，全局误差之比 $R = \\frac{\\text{全局误差 (欧拉起步)}}{\\text{全局误差 (RK4起步)}}$ 预期将按以下方式缩放：\n$$ R \\approx \\frac{C_1 h}{C_4 h^4} = K h^{-3} $$\n这意味着随着步长 $h$ 的减小，该比率应呈三次方增长，这突显了由不一致的起步方法导致的显著性能下降。\n\n一个关键的考虑因素是数值稳定性。对于测试方程 $y' = \\lambda y$，如果对于给定的复数值 $h\\lambda$，数值解不增长，则该方法是绝对稳定的。对于 $AB4$，其在负实轴上的绝对稳定区间约为 $[-0.723, 0]$。\n-   测试案例 1, 2, 5, 6：对于给定的参数，它们的 $h\\lambda$ 乘积（或有效的 $h\\lambda_{eff}$）位于此稳定区域内。对于这些案例，我们预期理论误差缩放关系将成立。\n-   测试案例 3, 4：此处 $f(t,y) = -4y$，因此 $\\lambda = -4$。\n    -   案例 3：$h\\lambda = 0.2 \\times (-4) = -0.8$。这在稳定区域之外。\n    -   案例 4：$h\\lambda = 0.6 \\times (-4) = -2.4$。这远在稳定区域之外。\n对于这些不稳定的案例，误差将由任何初始扰动的指数级放大所主导，而不是由局部截断误差的累积所主导。尽管欧拉法起步的模拟仍然会比 RK4 起步的模拟有更大的误差（因为它以更大的初始扰动开始），但 $R \\propto h^{-3}$ 的缩放关系预计不会成立。\n\n### 3. 实现策略\n\n解决方案将通过实现一个执行 $AB4$ 模拟的通用函数来计算。该函数将接受 $ODE$ 函数句柄、初始条件、时间参数以及一个指示起步方法（'euler' 或 'rk4'）的标志。\n\n对于六个测试案例中的每一个：\n1.  运行两个独立的模拟：一个用三步前向欧拉法初始化，另一个用三步 $RK4$ 方法初始化。\n2.  计算并存储初始值 $(y_1, y_2, y_3)$。\n3.  启动阶段后，从 $n=3$ 开始迭代应用 $AB4$ 公式，直到最终时间 $T$。使用一个大小为 4 的列表或队列来维护公式所需的 $f_k$ 值的历史记录。\n4.  通过找出数值解数组与在每个网格点上评估的精确解之间的最大绝对差来计算每次模拟的全局误差：$\\max_{0 \\le n \\le N} |y_n - y(t_n)|$。\n5.  计算并存储欧拉起步误差与 $RK4$ 起步误差的比率 $R$。\n6.  最终输出是所有六个测试案例的这些比率的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_ab4_simulation(f, y0, t0, T, h, starter_method):\n    \"\"\"\n    Solves an ODE y'(t) = f(t,y) using the four-step Adams-Bashforth method.\n\n    The first three steps are computed using a specified one-step method\n    (forward Euler or RK4) to generate the necessary starting values.\n\n    Args:\n        f (callable): The function f(t, y) defining the ODE.\n        y0 (float): The initial value y(t0).\n        t0 (float): The initial time.\n        T (float): The final time.\n        h (float): The step size.\n        starter_method (str): The method to use for starting values,\n                              either 'euler' or 'rk4'.\n\n    Returns:\n        tuple: A tuple containing:\n            - t_grid (np.ndarray): The array of time points.\n            - y (np.ndarray): The numerical solution array.\n    \"\"\"\n    N = int(round(T / h))\n    t_grid = np.linspace(t0, T, N + 1)\n    y = np.zeros(N + 1)\n    y[0] = y0\n\n    # Startup phase: Calculate y[1], y[2], y[3]\n    if starter_method == 'euler':\n        for i in range(3):\n            y[i + 1] = y[i] + h * f(t_grid[i], y[i])\n    elif starter_method == 'rk4':\n        for i in range(3):\n            y_i = y[i]\n            t_i = t_grid[i]\n            k1 = f(t_i, y_i)\n            k2 = f(t_i + h / 2.0, y_i + h / 2.0 * k1)\n            k3 = f(t_i + h / 2.0, y_i + h / 2.0 * k2)\n            k4 = f(t_i + h, y_i + h * k3)\n            y[i + 1] = y_i + h / 6.0 * (k1 + 2 * k2 + 2 * k3 + k4)\n    else:\n        raise ValueError(\"Invalid starter_method. Must be 'euler' or 'rk4'.\")\n\n    # AB4 requires the four most recent values of f(t, y).\n    # Initialize a list to store f_k for k = 0, 1, 2, 3.\n    f_hist = [f(t_grid[i], y[i]) for i in range(4)]\n\n    # AB4 coefficients\n    b0, b1, b2, b3 = 55.0/24.0, -59.0/24.0, 37.0/24.0, -9.0/24.0\n\n    # Main AB4 loop\n    for n in range(3, N):\n        # f_hist contains [f(n-3), f(n-2), f(n-1), f(n)]\n        y[n + 1] = y[n] + h * (b0 * f_hist[3] + b1 * f_hist[2] + b2 * f_hist[1] + b3 * f_hist[0])\n        \n        # Update history for the next step\n        f_hist.pop(0)\n        f_hist.append(f(t_grid[n + 1], y[n + 1]))\n\n    return t_grid, y\n\ndef solve():\n    \"\"\"\n    Main function to define and run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {'f': lambda t, y: -y,\n         'y_exact': lambda t: np.exp(-t),\n         'y0': 1.0, 't0': 0.0, 'T': 4.0, 'h': 0.1},\n        # Test case 2\n        {'f': lambda t, y: -y,\n         'y_exact': lambda t: np.exp(-t),\n         'y0': 1.0, 't0': 0.0, 'T': 4.0, 'h': 0.5},\n        # Test case 3\n        {'f': lambda t, y: -4 * y,\n         'y_exact': lambda t: np.exp(-4 * t),\n         'y0': 1.0, 't0': 0.0, 'T': 2.4, 'h': 0.2},\n        # Test case 4\n        {'f': lambda t, y: -4 * y,\n         'y_exact': lambda t: np.exp(-4 * t),\n         'y0': 1.0, 't0': 0.0, 'T': 2.4, 'h': 0.6},\n        # Test case 5\n        {'f': lambda t, y: -y + np.sin(t),\n         'y_exact': lambda t: 0.5 * (np.sin(t) - np.cos(t)) + 1.5 * np.exp(-t),\n         'y0': 1.0, 't0': 0.0, 'T': 10.0, 'h': 0.1},\n        # Test case 6\n        {'f': lambda t, y: -y + np.sin(t),\n         'y_exact': lambda t: 0.5 * (np.sin(t) - np.cos(t)) + 1.5 * np.exp(-t),\n         'y0': 1.0, 't0': 0.0, 'T': 10.0, 'h': 0.25},\n    ]\n\n    results = []\n    for case in test_cases:\n        f = case['f']\n        y_exact_func = case['y_exact']\n        y0 = case['y0']\n        t0 = case['t0']\n        T = case['T']\n        h = case['h']\n\n        # Run simulation with Euler starter\n        t_grid, y_euler_start = run_ab4_simulation(f, y0, t0, T, h, 'euler')\n        \n        # Run simulation with RK4 starter\n        _, y_rk4_start = run_ab4_simulation(f, y0, t0, T, h, 'rk4')\n        \n        # Calculate exact solution on the grid\n        y_exact_vals = y_exact_func(t_grid)\n        \n        # Compute global errors\n        error_euler = np.max(np.abs(y_euler_start - y_exact_vals))\n        error_rk4 = np.max(np.abs(y_rk4_start - y_exact_vals))\n        \n        # Compute the ratio, handle potential division by zero\n        if error_rk4 == 0.0:\n            ratio = np.inf if error_euler > 0.0 else 1.0\n        else:\n            ratio = error_euler / error_rk4\n        results.append(ratio)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3202848"}]}