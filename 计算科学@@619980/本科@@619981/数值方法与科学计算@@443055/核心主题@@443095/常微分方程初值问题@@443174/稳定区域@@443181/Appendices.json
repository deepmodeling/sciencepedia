{"hands_on_practices": [{"introduction": "我们将从绝对稳定性的基本定义入手。这个练习旨在帮助你掌握核心不等式 $|R(z)| \\leq 1$ 的应用，通过将它应用于一个给定的稳定性函数和实数轴上的负值 $z$，这是分析刚性问题时最简单也最常见的情形。通过求解这个不等式，你将为更复杂的分析打下坚实的基础 [@problem_id:2219443]。", "problem": "在常微分方程（ODE）的数值分析中，方法的稳定性对于获得可靠的解至关重要。这通常通过测试方程 $y'(t) = \\lambda y(t)$ 来研究，其中 $\\lambda$ 是一个复常数。当将单步数值方法应用于此方程时，步长为 $h$，数值解遵循 $y_{n+1} = R(z) y_n$ 形式的递推关系，其中 $z = h\\lambda$ 且 $R(z)$ 是该方法的稳定性函数。\n\n对于给定的 $z$，如果 $|R(z)| \\le 1$，则该方法被定义为绝对稳定。这个条件确保了对于衰减的精确解，数值解的幅度不会增长。\n\n考虑一个数值方法，其稳定性函数由以下多项式给出：\n$$ R(z) = 1 + z + \\frac{z^2}{2} $$\n\n对于实负的 $\\lambda$，$z$ 的值将是实负的。负实轴上的绝对稳定区域是一个形如 $[a, 0]$ 的区间。确定左端点 $a$ 的数值。", "solution": "对于应用于测试方程 $y'(t)=\\lambda y(t)$ 的单步法，其步长为 $h$，稳定性函数为 $R(z)$（其中 $z=h\\lambda$），其绝对稳定性条件是 $|R(z)|\\leq 1$。这里 $R(z)=1+z+\\frac{z^{2}}{2}$。对于实负的 $\\lambda$，参数 $z$ 是实负的。\n\n由于 $z\\in \\mathbb{R}$，$R(z)\\in \\mathbb{R}$，稳定性条件变为以下不等式对：\n$$\n-1 \\leq R(z) \\leq 1.\n$$\n首先，通过配方法重写 $R(z)$：\n$$\nR(z)=1+z+\\frac{z^{2}}{2}=\\frac{1}{2}\\left(z^{2}+2z+2\\right)=\\frac{1}{2}\\left((z+1)^{2}+1\\right).\n$$\n因此，\n$$\nR(z)\\geq \\frac{1}{2},\n$$\n在 $z=-1$ 处取等号。因此，对于所有实数 $z$，下界 $-1\\leq R(z)$ 自动成立。因此，负实轴上的稳定性条件简化为\n$$\nR(z)\\leq 1.\n$$\n解此不等式：\n$$\n1+z+\\frac{z^{2}}{2}\\leq 1 \\quad \\Longleftrightarrow \\quad z+\\frac{z^{2}}{2}\\leq 0 \\quad \\Longleftrightarrow \\quad z\\left(1+\\frac{z}{2}\\right)\\leq 0.\n$$\n根是 $z=0$ 和 $z=-2$，并且由于二次项系数为正，解集是区间\n$$\nz\\in[-2,0].\n$$\n因此，负实轴上的绝对稳定区域是 $[a,0]$，其左端点 $a=-2$。", "answer": "$$\\boxed{-2}$$", "id": "2219443"}, {"introduction": "现实世界中的问题通常表现为常微分方程组，而非单一的方程。这个练习将向你展示如何将稳定性分析扩展到方程组，这是一个关键步骤：整个系统的稳定性取决于限制最严格的那个特征值。你将为一个模拟物理振子的系统，学习如何确定前向欧拉法的最大稳定步长 [@problem_id:2219436]。", "problem": "在控制系统和机械振动的研究中，分析阻尼振子的行为是很常见的。考虑这样一个系统的简化模型，其动力学由以下二阶线性齐次常微分方程 (ODE) 控制：\n$$ y''(t) + 101 y'(t) + 100 y(t) = 0 $$\n其中 $y(t)$ 表示系统在时间 $t$ 的位移。\n\n为了对解进行数值近似，一种常见的技巧是首先将这个二阶常微分方程重写为一个等价的由两个一阶常微分方程组成的方程组。随后，应用一个数值积分方案。对于本问题，我们将使用步长恒为 $h  0$ 的前向欧拉法。\n\n数值积分的一个关键方面是稳定性。如果步长 $h$ 过大，即使精确解会衰减到零，数值解也可能无界增长。对于前向欧拉法，存在一个最大步长，超过该步长，积分将变得不稳定。\n\n确定使得前向欧拉法在应用于相应的一阶方程组时是绝对稳定的最大可能步长 $h_{max}$。", "solution": "首先将二阶常微分方程重写为一阶方程组。定义状态向量 $x(t) = \\begin{pmatrix} y(t) \\\\ v(t) \\end{pmatrix}$，其中 $v(t) = y'(t)$。那么有\n$$\n\\begin{cases}\ny'(t) = v(t), \\\\\nv'(t) = -101\\,v(t) - 100\\,y(t),\n\\end{cases}\n$$\n可以写成矩阵形式 $x'(t) = A x(t)$，其中\n$$\nA = \\begin{pmatrix} 0  1 \\\\ -100  -101 \\end{pmatrix}.\n$$\n\n$A$ 的特征值是原常微分方程的特征多项式的根，\n$$\n\\lambda^{2} + 101 \\lambda + 100 = 0.\n$$\n计算判别式：\n$$\n\\Delta = 101^{2} - 4 \\cdot 100 = 10201 - 400 = 9801,\n$$\n所以 $\\sqrt{\\Delta} = 99$。因此，\n$$\n\\lambda_{1,2} = \\frac{-101 \\pm 99}{2},\n$$\n这给出\n$$\n\\lambda_{1} = -1, \\quad \\lambda_{2} = -100.\n$$\n\n对 $x'(t) = A x(t)$ 应用前向欧拉法：\n$$\nx_{n+1} = x_{n} + h A x_{n} = (I + h A) x_{n}.\n$$\n如果放大矩阵的谱半径小于等于 $1$，则该方法是绝对稳定的。对于可对角化的矩阵 $A$，这可以通过要求 $A$ 的每个特征值 $\\lambda$ 满足以下条件来保证：\n$$\n|1 + h \\lambda| \\le 1.\n$$\n对于 $\\lambda_{1} = -1$，条件是\n$$\n|1 - h| \\le 1 \\;\\;\\Longleftrightarrow\\;\\; -1 \\le 1 - h \\le 1 \\;\\;\\Longleftrightarrow\\;\\; 0 \\le h \\le 2.\n$$\n对于 $\\lambda_{2} = -100$，条件是\n$$\n|1 - 100 h| \\le 1 \\;\\;\\Longleftrightarrow\\;\\; -1 \\le 1 - 100 h \\le 1 \\;\\;\\Longleftrightarrow\\;\\; 0 \\le h \\le \\frac{2}{100} = \\frac{1}{50}.\n$$\n为保证系统的绝对稳定性，两个条件必须同时成立，所以允许的步长为\n$$\n0  h \\le \\min\\left\\{2, \\frac{1}{50}\\right\\} = \\frac{1}{50}.\n$$\n因此，为保证绝对稳定性，最大可能步长是\n$$\nh_{\\max} = \\frac{1}{50}.\n$$", "answer": "$$\\boxed{\\frac{1}{50}}$$", "id": "2219436"}, {"introduction": "现在，让我们从手动计算迈向计算思维。这项挑战性的练习要求你编写一个算法，为给定的数值方法（经典的四阶龙格-库塔法）和系统矩阵自动确定最大稳定步长。这真实地反映了现代科学计算软件中进行稳定性分析的方式，是将理论付诸实践的终极考验 [@problem_id:3197733]。", "problem": "给定初值问题 $y'(t)=A_{\\text{sys}}\\,y(t)$，其中 $A_{\\text{sys}}$ 是一个复值矩阵，$y(t)$ 是一个复值向量函数。考虑使用固定的步长和一个由 Butcher 表描述的显式龙格－库塔方法来对该系统进行积分。时间积分的稳定性由该方法在线性检验方程 $y'(t)=\\lambda\\,y(t)$（其中 $\\lambda\\in\\mathbb{C}$）上的行为决定。对于一个显式龙格－库塔方法，其稳定性区域是集合 $\\{z\\in\\mathbb{C}\\}$，使得将相应的标量放大因子应用于 $y'(t)=\\lambda\\,y(t)$ 时满足 $\\lvert R(z)\\rvert\\leq 1$，其中 $z=\\Delta t\\,\\lambda$，$\\Delta t$ 是时间步长。如果一个方法的稳定性区域包含整个左半平面 $\\{z\\in\\mathbb{C}:\\Re(z)\\leq 0\\}$，则称该方法是代数稳定（A-稳定）的；如果它不仅是 A-稳定，而且当 $z$ 沿实轴趋向于 $-\\infty$ 时，还有 $R(z)\\to 0$，则称该方法是极限稳定（L-稳定）的。显式龙格－库塔方法不是代数稳定（A-稳定）的，因此即使当 $\\Re(\\lambda) \\le 0$ 时，最大的稳定 $\\Delta t$ 通常也是有限的。\n\n从线性检验方程的基本原理和通过 Butcher 表定义的龙格－库塔方法出发，推导出给定方法的稳定性函数 $R(z)$，为 $A_{\\text{sys}}$ 的每个特征值 $\\lambda$ 证明稳定性判据 $\\lvert R(\\Delta t\\,\\lambda)\\rvert\\leq 1$ 的合理性，并构建一个数值搜索过程。对于一个固定的龙格－库塔方法和一个给定的系统矩阵 $A_{\\text{sys}}$，该过程需找到最大的 $\\Delta t0$，使得所有缩放后的特征值 $z_i=\\Delta t\\,\\lambda_i$ 都位于稳定性区域内，即对于 $A_{\\text{sys}}$ 的所有特征值 $\\lambda_i$，都有 $\\lvert R(z_i)\\rvert\\leq 1$。你的程序不能假设稳定性多项式是预先给定的；它必须直接从 Butcher 表和应用于 $y'(t)=\\lambda\\,y(t)$ 的方法定义中获得 $R(z)$。\n\n使用经典的四阶显式龙格－库塔方法（通常称为“RK$4$”），其 Butcher 表如下：\n$$\nA_{\\text{RK}}=\\begin{bmatrix}\n0  0  0  0\\\\\n\\frac{1}{2}  0  0  0\\\\\n0  \\frac{1}{2}  0  0\\\\\n0  0  1  0\n\\end{bmatrix},\\quad\nb=\\begin{bmatrix}\n\\frac{1}{6}\\\\\n\\frac{1}{3}\\\\\n\\frac{1}{3}\\\\\n\\frac{1}{6}\n\\end{bmatrix},\\quad\nc=\\begin{bmatrix}\n0\\\\\n\\frac{1}{2}\\\\\n\\frac{1}{2}\\\\\n1\n\\end{bmatrix}.\n$$\n\n设计你的程序，将此单一的 RK 方法应用于以下每个测试矩阵 $A_{\\text{sys}}^{(k)}$，并为每个矩阵计算一个浮点数值：最大的 $\\Delta t$，使得稳定性条件 $\\lvert R(\\Delta t\\,\\lambda_i)\\rvert\\leq 1$ 对 $A_{\\text{sys}}^{(k)}$ 的所有特征值 $\\lambda_i$ 同时成立。搜索必须沿 $\\mathbb{C}$ 中的射线 $z=\\Delta t\\,\\lambda_i$（对于 $\\Delta t\\geq 0$）进行，并应返回满足约束的最大 $\\Delta t$。如果该约束仅在 $\\Delta t=0$ 时成立，你的程序必须为该情况返回 $0.0$。所有数值输出必须四舍五入到 $8$ 位小数。\n\n测试套件：\n- 情况 1（一般的负实数特征值）：\n$$\nA_{\\text{sys}}^{(1)}=\\begin{bmatrix}\n-2  0\\\\\n0  -5\n\\end{bmatrix}.\n$$\n- 情况 2（正实数特征值）：\n$$\nA_{\\text{sys}}^{(2)}=\\begin{bmatrix}\n1  0\\\\\n0  \\frac{1}{2}\n\\end{bmatrix}.\n$$\n- 情况 3（具有负实部的复共轭对）：\n$$\nA_{\\text{sys}}^{(3)}=\\begin{bmatrix}\n-1  -4\\\\\n1  -1\n\\end{bmatrix}.\n$$\n- 情况 4（具有小阻尼的高度振荡）：\n$$\nA_{\\text{sys}}^{(4)}=\\begin{bmatrix}\n-0.1  10\\\\\n-10  -0.1\n\\end{bmatrix}.\n$$\n\n最终输出格式要求：\n- 你的程序应生成单行输出，其中包含四个案例的结果，以逗号分隔的列表形式封装在方括号中，每个浮点数四舍五入到 $8$ 位小数，并且没有空格。例如，输出必须看起来像 $[d_1,d_2,d_3,d_4]$，其中每个 $d_k$ 是小数点后恰好有 $8$ 位数字的十进制字符串。", "solution": "用户提供的问题已经过验证，被确定为常微分方程数值分析领域中一个定义明确、具有科学依据的问题。所有必要信息均已提供，问题没有矛盾或歧义。我现在将提供一个完整的解决方案。\n\n### 1. 显式龙格-库塔方法与稳定性函数\n\n一个 $s$ 阶显式龙格-库塔（ERK）方法用于求解初值问题 $y'(t) = f(t, y(t))$，其定义如下：\n$$\ny_{n+1} = y_n + \\Delta t \\sum_{i=1}^s b_i k_i \\\\\nk_i = f\\left(t_n + c_i \\Delta t, y_n + \\Delta t \\sum_{j=1}^{i-1} a_{ij} k_j\\right)\n$$\n系数 $a_{ij}$、$b_i$ 和 $c_i$ 由一个 Butcher 表给出，对于显式方法，其矩阵 $A = (a_{ij})$ 是一个严格下三角矩阵。\n\n为了分析该方法的稳定性，我们将其应用于 Dahlquist 检验方程 $y'(t) = \\lambda y(t)$，其中 $\\lambda \\in \\mathbb{C}$。在这种情况下，$f(t, y) = \\lambda y$。阶段值 $k_i$ 变为：\n$$\nk_i = \\lambda \\left(y_n + \\Delta t \\sum_{j=1}^{i-1} a_{ij} k_j\\right)\n$$\n让我们定义缩放后的时间步长 $z = \\Delta t \\lambda$。我们可以观察到每个阶段向量 $k_i$ 必定与 $\\lambda y_n$ 成正比。设 $k_i = K_i(z) \\lambda y_n$，其中 $K_i(z)$ 是某个函数。将此代入阶段方程：\n$$\nK_i(z) \\lambda y_n = \\lambda \\left(y_n + \\Delta t \\sum_{j=1}^{i-1} a_{ij} (K_j(z) \\lambda y_n)\\right)\n$$\n两边同除以 $\\lambda y_n$（假设 $\\lambda, y_n \\neq 0$），我们得到一个关于级多项式 $K_i(z)$ 的递推关系：\n$$\nK_i(z) = 1 + z \\sum_{j=1}^{i-1} a_{ij} K_j(z)\n$$\n当 $i=1$ 时，由于求和为空，所以 $K_1(z) = 1$。因为 $A$ 是严格下三角矩阵，我们可以顺序计算每个 $K_i(z)$。$K_i(z)$ 是一个关于 $z$ 的 $i-1$ 次多项式。\n\n数值解更新如下：\n$$\ny_{n+1} = y_n + \\Delta t \\sum_{i=1}^s b_i (K_i(z) \\lambda y_n) = y_n \\left(1 + z \\sum_{i=1}^s b_i K_i(z)\\right)\n$$\n括号中的项是将 $y_n$ 映射到 $y_{n+1}$ 的放大因子。这就是稳定性函数 $R(z)$：\n$$\nR(z) = 1 + z \\sum_{i=1}^s b_i K_i(z)\n$$\n对于一个 $s$ 阶 ERK 方法，$R(z)$ 是一个次数至多为 $s$ 的 $z$ 的多项式。\n\n### 2. 经典 RK4 方法的稳定性函数\n\n问题提供了经典的四阶龙格-库塔方法（$s=4$）的 Butcher 表：\n$$\nA_{\\text{RK}}=\\begin{bmatrix}\n0  0  0  0\\\\\n\\frac{1}{2}  0  0  0\\\\\n0  \\frac{1}{2}  0  0\\\\\n0  0  1  0\n\\end{bmatrix},\\quad\nb=\\begin{bmatrix}\n\\frac{1}{6}\\\\\n\\frac{1}{3}\\\\\n\\frac{1}{3}\\\\\n\\frac{1}{6}\n\\end{bmatrix}\n$$\n我们推导级多项式 $K_i(z)$：\n\\begin{align*}\nK_1(z) = 1 \\\\\nK_2(z) = 1 + z a_{21} K_1(z) = 1 + z \\left(\\frac{1}{2}\\right)(1) = 1 + \\frac{z}{2} \\\\\nK_3(z) = 1 + z (a_{31} K_1(z) + a_{32} K_2(z)) = 1 + z \\left(0 + \\frac{1}{2}\\left(1 + \\frac{z}{2}\\right)\\right) = 1 + \\frac{z}{2} + \\frac{z^2}{4} \\\\\nK_4(z) = 1 + z (a_{41} K_1 + a_{42} K_2 + a_{43} K_3) = 1 + z \\left(0 + 0 + 1\\left(1 + \\frac{z}{2} + \\frac{z^2}{4}\\right)\\right) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{4}\n\\end{align*}\n现在，我们构建稳定性函数 $R(z)$：\n$$\nR(z) = 1 + z \\left( b_1 K_1(z) + b_2 K_2(z) + b_3 K_3(z) + b_4 K_4(z) \\right)\n$$\n代入 $b_i$ 的值和多项式 $K_i(z)$：\n$$\nR(z) = 1 + z \\left[ \\frac{1}{6}(1) + \\frac{1}{3}\\left(1+\\frac{z}{2}\\right) + \\frac{1}{3}\\left(1+\\frac{z}{2}+\\frac{z^2}{4}\\right) + \\frac{1}{6}\\left(1+z+\\frac{z^2}{2}+\\frac{z^3}{4}\\right) \\right]\n$$\n按 $z$ 的幂次合并括号内的项：\n\\begin{itemize}\n    \\item 常数项：$\\frac{1}{6} + \\frac{1}{3} + \\frac{1}{3} + \\frac{1}{6} = 1$\n    \\item $z$ 的一次项：$\\frac{1}{3}\\left(\\frac{1}{2}\\right) + \\frac{1}{3}\\left(\\frac{1}{2}\\right) + \\frac{1}{6}(1) = \\frac{1}{6} + \\frac{1}{6} + \\frac{1}{6} = \\frac{1}{2}$\n    \\item $z$ 的二次项：$\\frac{1}{3}\\left(\\frac{1}{4}\\right) + \\frac{1}{6}\\left(\\frac{1}{2}\\right) = \\frac{1}{12} + \\frac{1}{12} = \\frac{1}{6}$\n    \\item $z$ 的三次项：$\\frac{1}{6}\\left(\\frac{1}{4}\\right) = \\frac{1}{24}$\n\\end{itemize}\n将括号内的表达式乘以 $z$ 并加上 $1$，我们得到：\n$$\nR(z) = 1 + z\\left(1 + \\frac{1}{2}z + \\frac{1}{6}z^2 + \\frac{1}{24}z^3\\right) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24} = \\sum_{k=0}^{4} \\frac{z^k}{k!}\n$$\n这是 $e^z$ 的泰勒级数展开截断到四阶项。\n\n### 3. 线性系统的稳定性判据\n\n对于常微分方程组 $y'(t) = A_{\\text{sys}} y(t)$，假设 $A_{\\text{sys}}$ 可对角化，则存在一个可逆矩阵 $P$ 使得 $A_{\\text{sys}} = P \\Lambda P^{-1}$，其中 $\\Lambda$ 是由 $A_{\\text{sys}}$ 的特征值 $\\lambda_i$ 构成的对角矩阵。\n通过变量代换 $u(t) = P^{-1} y(t)$，系统解耦为一组独立的标量方程：$u_i'(t) = \\lambda_i u_i(t)$。\n对原始系统 $y' = A_{\\text{sys}} y$ 应用龙格-库塔方法等价于对每个标量方程应用相同的方法。变换后变量的更新规则是：\n$u_{i, n+1} = R(\\Delta t \\lambda_i) u_{i, n}$。\n为了使数值解 $y_n$ 在 $n \\to \\infty$ 时保持有界，所有分量 $u_{i,n}$ 都必须保持有界。这要求每个分量的放大因子模不大于 1：\n$$\n|R(\\Delta t \\lambda_i)| \\leq 1 \\quad \\text{对于 } A_{\\text{sys}} \\text{ 的所有特征值 } \\lambda_i\n$$\n这就是数值稳定性的条件。\n\n### 4. 最大稳定时间步长 $\\Delta t_{\\max}$ 的算法\n\n我们寻求满足所有特征值稳定性条件的最大 $\\Delta t \\geq 0$。即 $\\Delta t_{\\max} = \\sup\\{\\Delta t \\geq 0 \\mid |R(\\Delta t \\lambda_i)| \\leq 1 \\text{ for all } i\\}$。\n\n算法如下：\n1.  计算矩阵 $A_{\\text{sys}}$ 的特征值集合 $\\{\\lambda_i\\}$。\n2.  对于每个特征值 $\\lambda_i$：\n    a. 如果 $\\Re(\\lambda_i) > 0$，物理系统是不稳定的。对于任何 $\\Delta t > 0$，数值方法也将不稳定，因为对于小的 $z=\\Delta t \\lambda_i$，有 $|R(z)| \\approx |1+z| = \\sqrt{(1+\\Delta t \\Re(\\lambda_i))^2 + (\\Delta t \\Im(\\lambda_i))^2} > 1$。因此，$\\Delta t_{\\max} = 0$。\n    b. 如果 $\\lambda_i=0$，$R(0)=1$，所以该特征值对 $\\Delta t$ 没有限制。\n    c. 如果 $\\Re(\\lambda_i) \\leq 0$ 且 $\\lambda_i \\neq 0$，我们必须找到最小的正数 $\\Delta t_i^*$ 使得 $|R(\\Delta t_i^* \\lambda_i)| = 1$。该值代表了沿 $\\lambda_i$ 定义的射线方向上稳定性区域的边界。\n3.  总体的最大稳定时间步长是这些单个限制中的最小值：$\\Delta t_{\\max} = \\min_{i} \\{\\Delta t_i^*\\}$。\n\n为了找到 $\\Delta t_i^*$，我们需要求解方程 $|R(\\Delta t \\lambda_i)| - 1 = 0$ 的最小正根 $\\Delta t$。这是一个非线性方程，我们可以用数值方法求解。一个稳健的方法是首先确定根的区间，然后使用像 Brent 方法这样的求根算法。\n-   **区间包围**：对于给定的 $\\Re(\\lambda_i) \\le 0$ 的 $\\lambda_i$，函数 $h(\\Delta t) = |R(\\Delta t \\lambda_i)| - 1$ 对于小的 $\\Delta t > 0$ 是非正的。由于任何显式 RK 方法的稳定性区域都是有界的，我们可以通过从一个猜测值开始并增加它（例如，通过加倍）直到条件满足，来找到一个上界 $b$ 使得 $h(b) > 0$。这样就提供了一个包含根的区间 $[a, b]$。\n-   **求根**：在区间 $[a, b]$ 中包围了根之后，`scipy.optimize.brentq` 可以高效地找到 $\\Delta t_i^*$ 的精确值。\n\n实现将根据推导的 Butcher 表计算 $R(z)$，然后对每个测试矩阵执行此数值搜索。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It computes the maximum stable time step for the classical RK4 method\n    for several linear systems.\n    \"\"\"\n    # Butcher tableau for the classical 4-stage Runge-Kutta method (RK4)\n    A_rk4 = np.array([\n        [0.0, 0.0, 0.0, 0.0],\n        [0.5, 0.0, 0.0, 0.0],\n        [0.0, 0.5, 0.0, 0.0],\n        [0.0, 0.0, 1.0, 0.0]\n    ], dtype=float)\n    b_rk4 = np.array([1/6, 1/3, 1/3, 1/6], dtype=float)\n\n    # Test suite of system matrices A_sys\n    test_cases = [\n        # Case 1: general negative real eigenvalues\n        np.array([[-2.0, 0.0], [0.0, -5.0]], dtype=float),\n        # Case 2: positive real eigenvalues\n        np.array([[1.0, 0.0], [0.0, 0.5]], dtype=float),\n        # Case 3: complex-conjugate pair with negative real part\n        np.array([[-1.0, -4.0], [1.0, -1.0]], dtype=float),\n        # Case 4: highly oscillatory with small damping\n        np.array([[-0.1, 10.0], [-10.0, -0.1]], dtype=float)\n    ]\n\n    results = []\n    for A_sys in test_cases:\n        max_dt = find_max_dt(A_sys, A_rk4, b_rk4)\n        results.append(f\"{max_dt:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef compute_R_from_tableau(z, A, b):\n    \"\"\"\n    Computes the value of the stability function R(z) for a given z\n    and a Runge-Kutta method specified by its Butcher tableau (A, b).\n    \"\"\"\n    s = len(b)\n    K = np.zeros(s, dtype=np.complex128)\n    for i in range(s):\n        # K_i(z) = 1 + z * sum(a[i,j] * K_j(z) for j  i)\n        stage_sum = np.dot(A[i, :i], K[:i])\n        K[i] = 1.0 + z * stage_sum\n    \n    # R(z) = 1 + z * sum(b_i * K_i(z))\n    return 1.0 + z * np.dot(b, K)\n\ndef find_max_dt(A_sys, butcher_A, butcher_b):\n    \"\"\"\n    Finds the maximum stable time step dt for a system y'(t) = A_sys*y(t)\n    using the stability function derived from the provided Butcher tableau.\n    \"\"\"\n    try:\n        eigenvalues = np.linalg.eigvals(A_sys)\n    except np.linalg.LinAlgError:\n        return 0.0\n\n    # If any eigenvalue has a positive real part, the system is unstable,\n    # and the time integration will be unstable for any dt > 0.\n    if any(lam.real > 1e-9 for lam in eigenvalues):\n        return 0.0\n        \n    min_dt_root = float('inf')\n    \n    for lam in eigenvalues:\n        if abs(lam)  1e-9:  # An eigenvalue of 0 imposes no stability constraint.\n            continue\n\n        def h(dt):\n            \"\"\"Target function for root finding: |R(dt*lam)| - 1.\"\"\"\n            z = dt * lam\n            R_val = compute_R_from_tableau(z, butcher_A, butcher_b)\n            return abs(R_val) - 1.0\n\n        # Search for the smallest positive root of h(dt) = 0.\n        # This determines the stability limit for this eigenvalue.\n        \n        # Step 1: Bracket the root. Find an interval [a, b] such that\n        # h(a) = 0 and h(b) > 0.\n        # For stable/neutral eigenvalues, h(dt) = 0 for small dt > 0.\n        a = 1e-9 # Small positive number to start the search interval.\n        b = 1e-3 # Initial guess for the upper bound.\n        \n        # Exponentially increase b until h(b) > 0.\n        while h(b) = 0:\n            b *= 2.0\n            if b > 1e6: # Safety break to avoid infinite loops\n                b = float('inf')\n                break\n        \n        if b == float('inf'):\n            # This eigenvalue does not seem to impose a stability constraint\n            # within a reasonable range. This shouldn't happen for explicit methods.\n            continue\n            \n        a = b / 2.0\n        if a == 0: a = 1e-9\n\n        # Step 2: Use Brent's method to find the root within the bracketed interval.\n        try:\n            root = brentq(h, a, b)\n            min_dt_root = min(min_dt_root, root)\n        except ValueError:\n            # Should not happen with the bracketing logic above.\n            # If it does, it implies immediate instability for this eigenvalue.\n            min_dt_root = 0.0\n            break\n\n    if min_dt_root == float('inf'):\n        # This case would occur if all eigenvalues were zero.\n        # Any dt would be stable, so there's no finite maximum.\n        # The problem cases avoid this scenario. Returning 0.0 as a safe default.\n        return 0.0\n        \n    return min_dt_root\n\nsolve()\n```", "id": "3197733"}]}