{"hands_on_practices": [{"introduction": "后向差分公式（BDF）是一类隐式方法，但对于重要的线性常微分方程，其隐式性质可以通过简单的代数运算解决。本练习 [@problem_id:2155156] 将指导你推导出一阶 BDF（BDF1）方法求解通用一阶线性方程的显式迭代格式。掌握这一过程是理解和应用更复杂数值方法的基础。", "problem": "在数值分析中，后向差分公式 (BDFs) 是一族用于常微分方程数值积分的隐式方法。考虑一个形式为 $y'(t) = \\alpha y(t) + \\beta$ 的一阶常微分方程，其中 $\\alpha$ 和 $\\beta$ 是实常数。我们希望使用一个步长恒为 $h$ 的数值格式来近似该方程的解。\n\n令 $y_n$ 为真实解 $y(t_n)$ 在时间 $t_n = t_0 + nh$ 处的数值近似。一阶后向差分公式 (BDF1)，也称为后向欧拉法，使用后向差分来近似时间 $t_{n+1}$ 处的导数：\n$$\ny'(t_{n+1}) \\approx \\frac{y_{n+1} - y_n}{h}\n$$\n通过在时间 $t_{n+1}$ 处计算微分方程并代入此近似，我们得到了一个关于 $y_{n+1}$ 的递推关系。\n\n推导下一个近似值 $y_{n+1}$ 关于当前近似值 $y_n$、步长 $h$ 以及常数 $\\alpha$ 和 $\\beta$ 的完全显式公式。", "solution": "我们从给定的微分方程 $y'(t)=\\alpha y(t)+\\beta$ 和在 $t_{n+1}$ 处导数的一阶后向差分公式 (BDF1)（后向欧拉法）近似开始：\n$$\ny'(t_{n+1}) \\approx \\frac{y_{n+1}-y_{n}}{h}.\n$$\n在 $t_{n+1}$ 处计算微分方程，并用 $y_{n+1}$ 近似 $y(t_{n+1})$，得到\n$$\n\\frac{y_{n+1}-y_{n}}{h}=\\alpha y_{n+1}+\\beta.\n$$\n两边同乘以 $h$，\n$$\ny_{n+1}-y_{n}=h\\alpha y_{n+1}+h\\beta.\n$$\n将含有 $y_{n+1}$ 的项收集到左侧，\n$$\n(1-h\\alpha)y_{n+1}=y_{n}+h\\beta.\n$$\n假设 $1-h\\alpha \\neq 0$，解出 $y_{n+1}$：\n$$\ny_{n+1}=\\frac{y_{n}+h\\beta}{1-h\\alpha}.\n$$\n这就得到了关于 $y_{n}$、$h$、$\\alpha$ 和 $\\beta$ 的完全显式更新公式。", "answer": "$$\\boxed{\\frac{y_{n}+h\\beta}{1-h\\alpha}}$$", "id": "2155156"}, {"introduction": "当常微分方程是非线性时，我们无法再通过简单的代数变换直接解出下一个时间步的解 $y_{n+1}$。本练习 [@problem_id:2155132] 将向你展示处理这种情况的标准方法：将隐式 BDF 方程转化为一个求根问题，并使用牛顿法等迭代方法来求解。这是将 BDF 方法应用于更广泛实际问题的关键一步。", "problem": "考虑数值求解自治常微分方程 (ODE) 的问题，这是一种不显式依赖于自变量的微分方程。我们考虑的具体 ODE 是：\n$$y'(t) = \\cos(y(t))$$\n我们采用一种隐式数值格式来近似求解。令 $y_n$ 为解 $y(t_n)$ 在时间 $t_n$ 的数值近似。设时间步长 $h$ 为常数，使得 $t_{n+1} = t_n + h$，则下一个时间步的近似值 $y_{n+1}$ 由以下隐式方程确定：\n$$y_{n+1} = y_n + h \\cos(y_{n+1})$$\n为了在每一步中求出 $y_{n+1}$ 的值，我们必须解这个方程。这可以通过求函数 $g(x) = x - y_n - h \\cos(x)$ 的根来完成，其中根 $x$ 对应于 $y_{n+1}$。这个根通过迭代过程来求解。令 $y_{n+1}^{(k)}$ 为根的第 $k$ 次近似。其后的近似值 $y_{n+1}^{(k+1)}$ 是通过求函数 $g(x)$ 在点 $x = y_{n+1}^{(k)}$ 处的切线的根来确定的。\n\n你的任务是推导 $y_{n+1}^{(k+1)}$ 的迭代更新规则。用 $y_{n+1}^{(k)}$、$y_n$ 和步长 $h$ 来表示你的答案。", "solution": "我们已知 $y_{n+1}$ 的隐式方程是 $g(x)=x-y_{n}-h\\cos(x)$ 的根。为了迭代计算 $y_{n+1}$，我们应用牛顿法，该方法通过以下公式更新迭代值 $x^{(k)}$：\n$$\nx^{(k+1)}=x^{(k)}-\\frac{g(x^{(k)})}{g'(x^{(k)})}.\n$$\n首先，计算 $g(x)$ 的导数：\n$$\ng'(x)=\\frac{d}{dx}\\left(x-y_{n}-h\\cos(x)\\right)=1+h\\sin(x).\n$$\n使用 $x^{(k)}=y_{n+1}^{(k)}$，我们代入牛顿更新公式：\n$$\ny_{n+1}^{(k+1)}=y_{n+1}^{(k)}-\\frac{y_{n+1}^{(k)}-y_{n}-h\\cos\\!\\left(y_{n+1}^{(k)}\\right)}{1+h\\sin\\!\\left(y_{n+1}^{(k)}\\right)}.\n$$\n这就得到了用 $y_{n+1}^{(k)}$、$y_{n}$ 和 $h$ 表示的所需迭代规则。", "answer": "$$\\boxed{y_{n+1}^{(k+1)}=y_{n+1}^{(k)}-\\dfrac{y_{n+1}^{(k)}-y_{n}-h\\cos\\!\\left(y_{n+1}^{(k)}\\right)}{1+h\\sin\\!\\left(y_{n+1}^{(k)}\\right)}}$$", "id": "2155132"}, {"introduction": "高阶 BDF 方法虽然能提供更高的精度，但它们是多步的，需要依赖多个先前时间步的计算结果，这就引出了“启动”问题。这项高级练习 [@problem_id:3100231] 要求你实现一个完整的 BDF4 求解器，并采用一种实用的“自举”策略来启动计算。通过将其性能与理想启动情况进行比较，你将通过数值实验来研究和量化“瞬态阶损失”这一在科学计算中的重要概念。", "problem": "考虑一个标量常微分方程(ODE)的初值问题，其形式为 $y'(t) = f(t,y(t))$，初始条件为 $y(0) = y_0$。后向差分格式(Backward Differentiation Formula, BDF)方法是一种多步隐式方法，其推导过程为：通过过去的解值点构造插值多项式，并要求该多项式在最新时间点的导数满足微分方程。对于固定步长序列 $t_n = n h$，$k$ 步 BDF 方法可以写成如下形式：\n$$\n\\sum_{j=0}^{k} a_j y_{n-j} = h\\, f\\!\\left(t_n, y_n\\right),\n$$\n其中系数 $a_j$ 仅取决于 $k$，并通过要求方法具有一致性和对该 $k$ 的最高阶精度来确定。对于 $k=4$，该方法需要四个先前计算出的解值，因此需要一个启动策略。一种常见的实用方法是在前几步使用一个低阶 BDF 方法的自举序列：第一步使用 BDF1，第二步使用 BDF2，第三步使用 BDF3，从第四步开始及以后使用 BDF4。这会引入瞬态阶损失，因为前三步不具备完全的四阶精度。\n\n您的任务是完成以下工作：\n\n1. 从第一性原理出发，推导 $k=1,2,3,4$ 时固定步长的 BDF 系数 $a_j$。具体步骤为：从 BDF 的基本定义开始，构造一个穿过点集 $\\{(t_{n-j}, y_{n-j})\\}_{j=0}^{k}$ 的 $k$ 次插值多项式 $p(t)$，对 $p(t)$ 求导，并施加条件 $p'(t_n) = f(t_n,y_n)$。运用这些原理得到数值更新格式。\n\n2. 将该隐式更新格式应用于线性测试问题 $y'(t) = \\lambda\\, y(t)$，其中 $\\lambda \\in \\mathbb{R}$，$y(0)=y_0$。对于此测试问题，$f(t,y) = \\lambda y$，隐式更新将简化为关于 $y_n$ 的标量线性方程。\n\n3. 针对线性测试问题 $y'(t) = \\lambda\\, y(t)$ 实现一个固定步长的 BDF4 积分器，并采用以下启动策略：\n   - 第 $1$ 步：仅使用 $y_0$ 的单步 BDF1。\n   - 第 $2$ 步：使用 $y_1, y_0$ 的两步 BDF2。\n   - 第 $3$ 步：使用 $y_2, y_1, y_0$ 的三步 BDF3。\n   - 第 $4$ 步及以后：使用 $y_{n-1}, y_{n-2}, y_{n-3}, y_{n-4}$ 的四步 BDF4。\n   假设步长 $h$ 均匀，最终时间为 $T$，且 $N = T/h$ 是一个整数。\n\n4. 实现一个用于比较的“理想启动”场景：使用精确解 $y(t) = y_0 \\exp(\\lambda t)$ 来提供 $t=h, 2h, 3h$ 时的 $y_1, y_2, y_3$ 值，然后从第 4 步开始应用 BDF4。这代表一次运行，其中除了起始值是精确的外，四阶方法被一致地使用。\n\n5. 按如下方式量化由自举引起的瞬态阶损失。对于每组参数，使用步长 $h$ 和 $h/2$ 分别运行两种策略，并计算在最终时间 $T$ 的绝对误差：\n   $$\n   E_{\\text{boot}}(h) = \\left| y_N^{\\text{boot}} - y(T) \\right|,\\quad E_{\\text{boot}}(h/2) = \\left| y_{2N}^{\\text{boot}} - y(T) \\right|,\n   $$\n   $$\n   E_{\\text{ideal}}(h) = \\left| y_N^{\\text{ideal}} - y(T) \\right|,\\quad E_{\\text{ideal}}(h/2) = \\left| y_{2N}^{\\text{ideal}} - y(T) \\right|,\n   $$\n   并估计观测到的收敛阶\n   $$\n   p_{\\text{boot}} = \\frac{\\log\\!\\left(E_{\\text{boot}}(h) / E_{\\text{boot}}(h/2)\\right)}{\\log 2},\\quad\n   p_{\\text{ideal}} = \\frac{\\log\\!\\left(E_{\\text{ideal}}(h) / E_{\\text{ideal}}(h/2)\\right)}{\\log 2}.\n   $$\n   定义瞬态阶损失为 $\\Delta p = p_{\\text{ideal}} - p_{\\text{boot}}$。\n\n6. 实现您的程序，为以下每个测试用例计算 $\\Delta p$（均为 $y_0=1$ 的标量问题）：\n   - 测试用例 A (理想路径): $\\lambda = -1$, $T = 1$, $h = 0.1$。\n   - 测试用例 B (边界步数): $\\lambda = -1$, $T = 0.4$, $h = 0.1$。\n   - 测试用例 C (中度刚性，安全区域): $\\lambda = -5$, $T = 1$, $h = 0.1$。\n   - 测试用例 D (更强衰减，更小步长): $\\lambda = -20$, $T = 1$, $h = 0.05$。\n\n所有问题都具有精确解 $y(t) = \\exp(\\lambda t)$ 并且不使用物理单位。您的程序应产生单行输出，其中包含一个方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4]$），其中每个 $r_i$ 是对应测试用例的瞬态阶损失 $\\Delta p$，四舍五入到六位小数。结果必须是浮点数。\n\n您的实现必须是完全自包含的，并且无需用户输入即可运行。它必须使用指定的运行时环境和库。", "solution": "该问题要求推导并实现后向差分格式(BDF)方法来求解一个标量初值问题，并随后量化与自举启动程序相关的瞬态阶损失。分析将在线性测试问题 $y'(t) = \\lambda y(t)$ 上进行。\n\n### 1. BDF 系数的推导\n\nk 步 BDF 方法的定义是：构造一个次数最高为 $k$ 的唯一多项式 $p(t)$，使其插值于 $k+1$ 个点 $\\{(t_{n-j}, y_{n-j})\\}_{j=0}^{k}$ 上的解值，然后在最新的时间点 $t_n$ 处强制满足微分方程。也就是说，我们施加条件 $p'(t_n) = f(t_n, y_n)$。\n\n为推导这些系数，我们引入局部坐标 $s = (t - t_n)/h$，其中 $h$ 是固定步长。在此坐标系中，插值节点为 $s_j = -j$，其中 $j=0, 1, \\dots, k$。用牛顿后向差分形式表示的插值多项式为：\n$$\nP(s) = \\sum_{j=0}^{k} \\binom{-s}{j} \\nabla^j y_n\n$$\n其中 $\\nabla$ 是后向差分算子（$\\nabla y_n = y_n - y_{n-1}$，$\\nabla^2 y_n = \\nabla(\\nabla y_n) = y_n - 2y_{n-1} + y_{n-2}$ 等），且 $\\binom{-s}{j} = \\frac{(-s)(-s-1)\\cdots(-s-j+1)}{j!}$。这种形式的多项式能正确地插值数据，即 $P(-j) = y_{n-j}$ 对 $j=0, \\dots, k$ 成立。\n\n多项式对时间 $t$ 的导数通过 $p'(t) = \\frac{1}{h} P'(s)$ 与其对 $s$ 的导数相关联。我们需要在 $t=t_n$ 处计算这个值，这对应于 $s=0$。\n$$\np'(t_n) = \\frac{1}{h} P'(0)\n$$\n$P(s)$ 在 $s=0$ 处的导数为：\n$$\nP'(0) = \\left. \\frac{d}{ds} \\sum_{j=0}^{k} \\binom{-s}{j} \\right|_{s=0} \\nabla^j y_n = \\sum_{j=1}^{k} \\frac{1}{j} \\nabla^j y_n\n$$\n这里我们利用了 $\\left. \\frac{d}{ds} \\binom{-s}{j} \\right|_{s=0} = \\frac{(-1)^{j-1}(j-1)!}{j!} = \\frac{(-1)^{j-1}}{j}$ 这一事实，并且 $\\nabla^j y_n$ 中各项的和会将其重新排列成一个正系数。一个更直接的计算表明该系数就是 $1/j$。\n\n因此，BDF 方法由以下关系式给出：\n$$\n\\sum_{j=1}^{k} \\frac{1}{j} \\nabla^j y_n = h f(t_n, y_n)\n$$\n现在，通过展开后向差分 $\\nabla^j y_n = \\sum_{i=0}^{j} (-1)^i \\binom{j}{i} y_{n-i}$，我们可以找到标准形式 $\\sum_{j=0}^{k} a_j y_{n-j} = h f(t_n, y_n)$ 中的系数 $a_j$。\n\n**BDF1 ($k=1$):**\n$\\nabla y_n = h f(t_n, y_n) \\implies y_n - y_{n-1} = h f(t_n, y_n)$。\n系数：$a_0 = 1, a_1 = -1$。\n\n**BDF2 ($k=2$):**\n$\\nabla y_n + \\frac{1}{2}\\nabla^2 y_n = (y_n - y_{n-1}) + \\frac{1}{2}(y_n - 2y_{n-1} + y_{n-2}) = \\frac{3}{2}y_n - 2y_{n-1} + \\frac{1}{2}y_{n-2} = h f(t_n, y_n)$。\n系数：$a_0 = 3/2, a_1 = -2, a_2 = 1/2$。\n\n**BDF3 ($k=3$):**\n$\\nabla y_n + \\frac{1}{2}\\nabla^2 y_n + \\frac{1}{3}\\nabla^3 y_n = (y_n - y_{n-1}) + \\frac{1}{2}(y_n - 2y_{n-1} + y_{n-2}) + \\frac{1}{3}(y_n - 3y_{n-1} + 3y_{n-2} - y_{n-3}) = \\frac{11}{6}y_n - 3y_{n-1} + \\frac{3}{2}y_{n-2} - \\frac{1}{3}y_{n-3} = h f(t_n, y_n)$。\n系数：$a_0 = 11/6, a_1 = -3, a_2 = 3/2, a_3 = -1/3$。\n\n**BDF4 ($k=4$):**\n$\\sum_{j=1}^{4} \\frac{1}{j} \\nabla^j y_n = (\\dots) = \\frac{25}{12}y_n - 4y_{n-1} + 3y_{n-2} - \\frac{4}{3}y_{n-3} + \\frac{1}{4}y_{n-4} = h f(t_n, y_n)$。\n系数：$a_0 = 25/12, a_1 = -4, a_2 = 3, a_3 = -4/3, a_4 = 1/4$。\n\n### 2. 对线性测试问题的特化\n\n对于线性测试问题 $y'(t) = \\lambda y(t)$，我们有 $f(t,y) = \\lambda y$。BDF 更新公式变为关于 $y_n$ 的一个线性方程：\n$$\n\\sum_{j=0}^{k} a_j y_{n-j} = h \\lambda y_n\n$$\n分离出含 $y_n$ 的项并对其求解，得到显式更新规则：\n$$\na_0 y_n - h \\lambda y_n = - \\sum_{j=1}^{k} a_j y_{n-j} \\implies y_n = \\frac{1}{a_0 - h\\lambda} \\sum_{j=1}^{k} (-a_j) y_{n-j}\n$$\n这个公式将用于阶数 $k=1, 2, 3, 4$ 的每一种 BDF 方法。\n\n### 3.  4. 实现策略：自举启动 vs. 理想启动\n\n问题为 BDF4 积分器指定了两种启动策略。\n\n**自举策略 (Bootstrapping Strategy)：** 这种实用方法使用低阶方法为高阶方法生成必要的历史数据。其顺序如下：\n- 第 1 步 ($n=1$)：使用 BDF1 计算 $y_1$，该方法仅需 $y_0$。\n- 第 2 步 ($n=2$)：使用 BDF2 计算 $y_2$，该方法需要 $y_1, y_0$。\n- 第 3 步 ($n=3$)：使用 BDF3 计算 $y_3$，该方法需要 $y_2, y_1, y_0$。\n- 第 $n \\ge 4$ 步：使用 BDF4，该方法使用历史数据 $y_{n-1}, y_{n-2}, y_{n-3}, y_{n-4}$。\n\n**理想启动策略 (Ideal Start Strategy)：** 这种理论方法为 BDF4 方法提供精确的起始值，以分离其自身的收敛行为。\n- 第 1, 2, 3 步 ($n=1,2,3$)：将 $y_1, y_2, y_3$ 的值设置为精确解的值，即 $y(t_1), y(t_2), y(t_3)$，其中 $y(t) = y_0 \\exp(\\lambda t)$。\n- 第 $n \\ge 4$ 步：与自举策略一样，使用 BDF4。\n\n### 5. 收敛性分析与瞬态阶损失\n\n为量化该方法的精度，我们计算观测到的收敛阶 $p$。给定在固定时间 $T$ 处，对于步长 $h$ 和 $h/2$ 的绝对误差 $E(h)$ 和 $E(h/2)$，收敛阶 $p$ 可估计为：\n$$\np = \\frac{\\log(E(h) / E(h/2))}{\\log(2)}\n$$\n该公式假设对于某个常数 $C$ 和小的 $h$，误差的行为符合 $E(h) \\approx C h^p$。\n\n我们为这两种策略计算 $p_{\\text{boot}}$ 和 $p_{\\text{ideal}}$。瞬态阶损失 $\\Delta p$ 是它们的差：\n$$\n\\Delta p = p_{\\text{ideal}} - p_{\\text{boot}}\n$$\n理论上，BDF$k$ 方法具有 $k$ 阶的全局误差。因此，对于理想启动，BDF4 应表现出四阶收敛性，得到 $p_{\\text{ideal}} \\approx 4$。对于自举启动，总体精度受到用于生成历史数据的最低精度方法的限制。使用 BDF1（1 阶）生成 $y_1$ 会给 $y_1$ 的值引入一个 $O(h^2)$ 的误差。这个误差会传播并占主导地位，将整个序列的全局精度限制在二阶。因此，我们预期 $p_{\\text{boot}} \\approx 2$。所以，理论上的瞬态阶损失是 $\\Delta p \\approx 4 - 2 = 2$。本实现将检验这一假设。\n\n以下 Python 代码为指定的测试用例实现了这些步骤。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef bdf_solver(lam, T, h, y0, strategy):\n    \"\"\"\n    Solves y' = lambda*y using a BDF4 integrator with a specified start-up strategy.\n    \n    Args:\n        lam (float): The lambda parameter of the ODE.\n        T (float): The final time.\n        h (float): The constant step size.\n        y0 (float): The initial condition y(0).\n        strategy (str): 'boot' for bootstrapping or 'ideal' for exact start.\n\n    Returns:\n        float: The numerical solution y(T).\n    \"\"\"\n    N = int(round(T / h))\n    # Ensure y is large enough even if N is small\n    y = np.zeros(max(N + 1, 5), dtype=np.float64)\n    y[0] = y0\n    h_lam = h * lam\n\n    # === Start-up phase ===\n    if strategy == 'boot':\n        # Step 1: BDF1\n        if N >= 1:\n            # Formula: y_1 - y_0 = h * lam * y_1\n            # (1 - h*lam)y_1 = y_0\n            y[1] = y[0] / (1.0 - h_lam)\n        \n        # Step 2: BDF2\n        if N >= 2:\n            # Formula: 3/2 y_2 - 2 y_1 + 1/2 y_0 = h * lam * y_2\n            # (3/2 - h*lam)y_2 = 2 y_1 - 1/2 y_0\n            y[2] = (2.0 * y[1] - 0.5 * y[0]) / (1.5 - h_lam)\n\n        # Step 3: BDF3\n        if N >= 3:\n            # Formula: 11/6 y_3 - 3 y_2 + 3/2 y_1 - 1/3 y_0 = h*lam*y_3\n            # (11/6 - h*lam)y_3 = 3 y_2 - 3/2 y_1 + 1/3 y_0\n            a0_bdf3 = 11.0 / 6.0\n            y[3] = (3.0 * y[2] - 1.5 * y[1] + (1.0/3.0) * y[0]) / (a0_bdf3 - h_lam)\n\n    elif strategy == 'ideal':\n        # Use exact solution for the first 3 steps\n        if N >= 1:\n            y[1] = y0 * np.exp(lam * h)\n        if N >= 2:\n            y[2] = y0 * np.exp(lam * 2 * h)\n        if N >= 3:\n            y[3] = y0 * np.exp(lam * 3 * h)\n\n    # === Main loop: BDF4 for n >= 4 ===\n    if N >= 4:\n        # Formula: 25/12 y_n - 4 y_{n-1} + 3 y_{n-2} - 4/3 y_{n-3} + 1/4 y_{n-4} = h*lam*y_n\n        # (25/12 - h*lam)y_n = 4 y_{n-1} - 3 y_{n-2} + 4/3 y_{n-3} - 1/4 y_{n-4}\n        a0_bdf4 = 25.0 / 12.0\n        c1, c2, c3, c4 = 4.0, -3.0, 4.0 / 3.0, -1.0 / 4.0\n        \n        for n in range(4, N + 1):\n            history_sum = c1 * y[n-1] + c2 * y[n-2] + c3 * y[n-3] + c4 * y[n-4]\n            y[n] = history_sum / (a0_bdf4 - h_lam)\n            \n    return y[N]\n\ndef calculate_transient_order_loss(params):\n    \"\"\"\n    Calculates the transient order loss for a given test case.\n    \n    Args:\n        params (tuple): A tuple (lambda, T, h) defining the test case.\n        \n    Returns:\n        float: The transient order loss delta_p.\n    \"\"\"\n    lam, T, h = params\n    y0 = 1.0\n    h_half = h / 2.0\n    \n    y_exact_at_T = y0 * np.exp(lam * T)\n\n    # --- Bootstrapping Strategy ---\n    y_boot_h = bdf_solver(lam, T, h, y0, 'boot')\n    y_boot_h2 = bdf_solver(lam, T, h_half, y0, 'boot')\n    \n    E_boot_h = np.abs(y_boot_h - y_exact_at_T)\n    E_boot_h2 = np.abs(y_boot_h2 - y_exact_at_T)\n    \n    # Check for cases where error is zero to avoid log(0)\n    if E_boot_h  1e-15 or E_boot_h2  1e-15:\n        p_boot = np.nan\n    else:\n        p_boot = np.log(E_boot_h / E_boot_h2) / np.log(2.0)\n\n    # --- Ideal Start Strategy ---\n    y_ideal_h = bdf_solver(lam, T, h, y0, 'ideal')\n    y_ideal_h2 = bdf_solver(lam, T, h_half, y0, 'ideal')\n    \n    E_ideal_h = np.abs(y_ideal_h - y_exact_at_T)\n    E_ideal_h2 = np.abs(y_ideal_h2 - y_exact_at_T)\n    \n    if E_ideal_h  1e-15 or E_ideal_h2  1e-15:\n        p_ideal = np.nan\n    else:\n        p_ideal = np.log(E_ideal_h / E_ideal_h2) / np.log(2.0)\n    \n    delta_p = p_ideal - p_boot\n    return delta_p\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (lambda, T, h)\n        (-1.0, 1.0, 0.1),    # Test Case A\n        (-1.0, 0.4, 0.1),    # Test Case B\n        (-5.0, 1.0, 0.1),    # Test Case C\n        (-20.0, 1.0, 0.05),  # Test Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_p = calculate_transient_order_loss(case)\n        # Round the final result to six decimal places\n        results.append(round(delta_p, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3100231"}]}