{"hands_on_practices": [{"introduction": "要真正理解“刚性”的含义，最好的方法莫过于亲眼见证它如何让某些数值方法失效。本练习提供了一个典型的刚性微分方程。你将通过实现简单的显式前向欧拉法和隐式后向欧拉法，直观地对比它们的表现，通过观察两者在稳定性和准确性上的巨大差异，你将深刻体会到为何显式方法在求解刚性问题时会束手无策，而隐式方法又为何是必不可少的工具 [@problem_id:3198039]。", "problem": "考虑常微分方程 (ODE) 的初值问题 (IVP)：在区间 $t \\in [0, 10]$ 上，$y^{\\prime}(t) = -\\dfrac{1}{\\epsilon} y(t) + \\sin(t)$，初始条件为 $y(0) = 0$。参数 $\\epsilon$ 是一个小的正常数，给定为 $\\epsilon = 10^{-6}$，并且正弦函数中 $t$ 的角度单位是弧度。由于项 $-\\dfrac{1}{\\epsilon} y(t)$ 的存在，该初值问题表现出刚性，该项在解中引入了一个快速衰减的分量。\n\n从基本定义和经过充分检验的事实出发，完成以下任务：\n\n1. 基于线性 ODE 结构，使用积分因子法推导给定 IVP 的精确闭式解 $y(t)$。你的推导必须从一阶线性 ODE 的定义和积分因子的构造开始，并且不得依赖任何提供给你的快捷公式。\n\n2. 使用导数作为差商极限的定义以及使用固定步长 $h$ 进行时间离散化的思想，推导：\n   - 通过在每个时间步的左端点近似 $y^{\\prime}(t)$ 来推导显式前向欧拉更新法则。\n   - 通过在每个时间步的右端点近似 $y^{\\prime}(t)$ 来推导隐式后向欧拉更新法则。\n   两个推导都必须源于定义 $y^{\\prime}(t) = \\lim_{h \\to 0} \\dfrac{y(t+h) - y(t)}{h}$，并且不得假定任何预先形成的离散更新公式。\n\n3. 使用 Dahlquist 测试方程 $y^{\\prime} = \\lambda y$ 的线性稳定性分析，解释为什么当 $\\epsilon$ 很小时 IVP 是刚性的，以及这如何影响允许的显式步长。特别是，从第一性原理出发，确定对显式方法的 $h$ 的约束，并将其与隐式方法的行为进行对比。\n\n4. 实现所推导的两种方法，对一组固定的时间步长 $h$，在 $t \\in [0, 10]$ 上数值近似 $y(t)$。对于每种方法和每个时间步长，计算离散网格点上相对于你推导的精确解的最大绝对误差。如果在显式积分过程中数值解变为非有限值（例如由于溢出），则将该情况下的最大误差视为 $+\\infty$。\n\n角度单位说明：所有三角函数求值必须使用弧度。\n\n测试套件：\n- 参数：$\\epsilon = 10^{-6}$。\n- 初始条件：$y(0) = 0$。\n- 区间：$[0, 10]$。\n- 步长：$h \\in \\{1.0, 0.1, 0.01, 0.001\\}$。\n\n对于上述集合中的每个步长 $h$，评估：\n- 显式前向欧拉方法在离散时间网格 $\\{0, h, 2h, \\dots, 10\\}$ 上的最大绝对误差。\n- 隐式后向欧拉方法在相同网格上的最大绝对误差。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3,...]\"）。该列表必须按以下顺序汇总结果：对于每个按升序排列的 $h$，首先是显式方法的最大误差，然后是隐式方法的最大误差，因此最终输出有八个条目，依次对应于 $h = 0.001$，$h = 0.01$，$h = 0.1$ 和 $h = 1.0$。", "solution": "该问题经评估有效，因为它具有科学依据、问题提出得当、客观且内容自洽。它展示了刚性常微分方程（ODE）的一个典型例子，并要求进行计算科学领域基础的推导和分析。问题陈述没有矛盾或谬误。\n\n解答分为四个部分，对应于问题描述中概述的任务。\n\n### 1. 精确闭式解的推导\n\n给定的初值问题 (IVP) 是：\n$$\ny^{\\prime}(t) = -\\frac{1}{\\epsilon} y(t) + \\sin(t), \\quad y(0) = 0, \\quad t \\in [0, 10]\n$$\n这是一个一阶线性常微分方程。此类方程的标准形式是 $y' + p(t)y = q(t)$。通过重新整理给定的 ODE，我们确定相应的项：\n$$\ny^{\\prime}(t) + \\frac{1}{\\epsilon} y(t) = \\sin(t)\n$$\n这里，$p(t) = \\frac{1}{\\epsilon}$ 且 $q(t) = \\sin(t)$。\n\n为了求解该方程，我们使用积分因子法。积分因子 $I(t)$ 定义为：\n$$\nI(t) = e^{\\int p(t) dt}\n$$\n对于本问题，积分为：\n$$\n\\int p(t) dt = \\int \\frac{1}{\\epsilon} dt = \\frac{t}{\\epsilon}\n$$\n因此，积分因子为 $I(t) = e^{t/\\epsilon}$。我们将 ODE 的标准形式乘以 $I(t)$：\n$$\ne^{t/\\epsilon} y^{\\prime}(t) + \\frac{1}{\\epsilon} e^{t/\\epsilon} y(t) = e^{t/\\epsilon} \\sin(t)\n$$\n根据乘法法则，左侧是 $y(t)I(t)$ 的导数：\n$$\n\\frac{d}{dt} \\left( y(t) e^{t/\\epsilon} \\right) = e^{t/\\epsilon} \\sin(t)\n$$\n为了求得 $y(t)$，我们对两边关于 $t$ 进行积分：\n$$\n\\int \\frac{d}{dt} \\left( y(t) e^{t/\\epsilon} \\right) dt = \\int e^{t/\\epsilon} \\sin(t) dt\n$$\n$$\ny(t) e^{t/\\epsilon} = \\int e^{t/\\epsilon} \\sin(t) dt\n$$\n右侧的积分可以使用分部积分法两次求解。形如 $\\int e^{at}\\sin(bt)dt$ 的积分的通解是 $\\frac{e^{at}}{a^2+b^2}(a\\sin(bt) - b\\cos(bt))$。当 $a = 1/\\epsilon$ 和 $b = 1$ 时，我们有：\n$$\n\\int e^{t/\\epsilon} \\sin(t) dt = \\frac{e^{t/\\epsilon}}{(1/\\epsilon)^2 + 1^2} \\left( \\frac{1}{\\epsilon}\\sin(t) - 1\\cos(t) \\right) + C\n$$\n其中 $C$ 是积分常数。简化此表达式：\n$$\n\\int e^{t/\\epsilon} \\sin(t) dt = \\frac{e^{t/\\epsilon}}{(1+\\epsilon^2)/\\epsilon^2} \\left( \\frac{\\sin(t) - \\epsilon\\cos(t)}{\\epsilon} \\right) + C = \\frac{\\epsilon^2 e^{t/\\epsilon}}{1+\\epsilon^2} \\frac{\\sin(t) - \\epsilon\\cos(t)}{\\epsilon} + C\n$$\n$$\n= \\frac{\\epsilon e^{t/\\epsilon}}{1+\\epsilon^2} (\\sin(t) - \\epsilon\\cos(t)) + C = \\frac{e^{t/\\epsilon}}{1+\\epsilon^2} (\\epsilon\\sin(t) - \\epsilon^2\\cos(t)) + C\n$$\n将此结果代回关于 $y(t)e^{t/\\epsilon}$ 的方程中：\n$$\ny(t) e^{t/\\epsilon} = \\frac{e^{t/\\epsilon}}{1+\\epsilon^2} (\\epsilon\\sin(t) - \\epsilon^2\\cos(t)) + C\n$$\n通过乘以 $e^{-t/\\epsilon}$ 来求解 $y(t)$：\n$$\ny(t) = \\frac{\\epsilon\\sin(t) - \\epsilon^2\\cos(t)}{1+\\epsilon^2} + C e^{-t/\\epsilon}\n$$\n现在，我们应用初始条件 $y(0) = 0$ 来求常数 $C$：\n$$\ny(0) = 0 = \\frac{\\epsilon\\sin(0) - \\epsilon^2\\cos(0)}{1+\\epsilon^2} + C e^{0}\n$$\n$$\n0 = \\frac{0 - \\epsilon^2(1)}{1+\\epsilon^2} + C \\implies C = \\frac{\\epsilon^2}{1+\\epsilon^2}\n$$\n将 $C$ 的值代回，得到该 IVP 的精确闭式解：\n$$\ny(t) = \\frac{\\epsilon\\sin(t) - \\epsilon^2\\cos(t)}{1+\\epsilon^2} + \\frac{\\epsilon^2}{1+\\epsilon^2} e^{-t/\\epsilon}\n$$\n\n### 2. 数值方法的推导\n\n我们从导数的极限定义 $y^{\\prime}(t) = \\lim_{h \\to 0} \\frac{y(t+h) - y(t)}{h}$ 推导数值更新法则。我们考虑一个离散时间网格 $t_n = n h$，$n=0, 1, 2, \\dots$，其中 $h$ 是步长。设 $y_n$ 是对 $y(t_n)$ 的数值近似。\n\n**显式前向欧拉方法**\n前向欧拉方法在时间步的开始处 $t_n$ 近似导数 $y'(t)$。使用基于极限定义的一阶前向差商：\n$$\ny^{\\prime}(t_n) \\approx \\frac{y(t_{n+1}) - y(t_n)}{h}\n$$\n将此近似代入 $t_n$ 时刻的 ODE $y'(t) = f(t, y(t)) = -\\frac{1}{\\epsilon} y(t) + \\sin(t)$ 中：\n$$\n\\frac{y_{n+1} - y_n}{h} = -\\frac{1}{\\epsilon} y_n + \\sin(t_n)\n$$\n求解 $y_{n+1}$ 得到显式前向欧拉更新法则：\n$$\ny_{n+1} = y_n + h \\left( -\\frac{1}{\\epsilon} y_n + \\sin(t_n) \\right)\n$$\n这个法则是“显式”的，因为 $y_{n+1}$ 是直接从 $t_n$ 时刻的已知值计算得出的。\n\n**隐式后向欧拉方法**\n后向欧拉方法通过在时间步的结束处 $t_{n+1}$ 计算 ODE 来近似导数。导数 $y'(t_{n+1})$ 使用后向差商来近似：\n$$\ny^{\\prime}(t_{n+1}) \\approx \\frac{y(t_{n+1}) - y(t_n)}{h}\n$$\n将此近似代入 $t_{n+1}$ 时刻的 ODE 中：\n$$\n\\frac{y_{n+1} - y_n}{h} = -\\frac{1}{\\epsilon} y_{n+1} + \\sin(t_{n+1})\n$$\n这个方程是“隐式”的，因为未知数 $y_{n+1}$ 出现在等式两边。我们必须求解 $y_{n+1}$：\n$$\ny_{n+1} - y_n = h \\left( -\\frac{1}{\\epsilon} y_{n+1} + \\sin(t_{n+1}) \\right)\n$$\n$$\ny_{n+1} - y_n = -\\frac{h}{\\epsilon} y_{n+1} + h\\sin(t_{n+1})\n$$\n合并含有 $y_{n+1}$ 的项：\n$$\ny_{n+1} + \\frac{h}{\\epsilon} y_{n+1} = y_n + h\\sin(t_{n+1})\n$$\n$$\ny_{n+1} \\left( 1 + \\frac{h}{\\epsilon} \\right) = y_n + h\\sin(t_{n+1})\n$$\n最后，求解 $y_{n+1}$ 得到隐式后向欧拉更新法则：\n$$\ny_{n+1} = \\frac{y_n + h\\sin(t_{n+1})}{1 + h/\\epsilon}\n$$\n\n### 3. 稳定性分析与刚性\n\n刚性的概念使用 Dahlquist 测试方程 $y' = \\lambda y$ 进行分析，其中 $\\text{Re}(\\lambda)  0$。对于给定的 ODE，其动态行为主要由齐次部分 $y' = -\\frac{1}{\\epsilon} y$ 决定。因此，我们确定 $\\lambda = -1/\\epsilon$。由于 $\\epsilon = 10^{-6}$ 是一个小的正常数，$\\lambda = -10^6$ 是一个大的负实数。\n\n**前向欧拉稳定性**\n将前向欧拉法则应用于 $y'=\\lambda y$：\n$$\ny_{n+1} = y_n + h(\\lambda y_n) = (1+h\\lambda) y_n\n$$\n为使数值解保持有界（即稳定），放大因子 $R(h\\lambda) = 1+h\\lambda$ 必须满足 $|R(h\\lambda)| \\le 1$。\n$$\n|1 + h\\lambda| \\le 1\n$$\n当 $\\lambda = -1/\\epsilon$ 时，这变为 $|1 - h/\\epsilon| \\le 1$。该不等式等价于 $-1 \\le 1 - h/\\epsilon \\le 1$。\n右侧不等式 $1 - h/\\epsilon \\le 1$ 意味着 $h/\\epsilon \\ge 0$，对于正的 $h$ 和 $\\epsilon$ 这总是成立的。\n左侧不等式 $-1 \\le 1 - h/\\epsilon$ 意味着 $h/\\epsilon \\le 2$，即 $h \\le 2\\epsilon$。\n对于 $\\epsilon=10^{-6}$，步长必须满足 $h \\le 2 \\times 10^{-6}$。这是一个非常严格的限制。对于任何步长 $h > 2\\epsilon$，数值解将变得无界，并表现出指数增长的振荡。\n\n**后向欧拉稳定性**\n将后向欧拉法则应用于 $y'=\\lambda y$：\n$$\ny_{n+1} = y_n + h(\\lambda y_{n+1}) \\implies y_{n+1}(1 - h\\lambda) = y_n \\implies y_{n+1} = \\frac{1}{1-h\\lambda} y_n\n$$\n放大因子为 $R(h\\lambda) = \\frac{1}{1-h\\lambda}$。为了保证稳定性，我们需要 $|R(h\\lambda)| \\le 1$。\n$$\n\\left| \\frac{1}{1-h\\lambda} \\right| \\le 1\n$$\n当 $\\lambda = -1/\\epsilon$ 时，该表达式为 $\\left| \\frac{1}{1+h/\\epsilon} \\right|$。由于 $h > 0$ 和 $\\epsilon > 0$，分母 $1+h/\\epsilon$ 总是大于 $1$。因此，其倒数的绝对值总是小于 $1$。该方法对于任何 $h > 0$ 的选择都是稳定的。这个性质被称为 A-稳定性。\n\n**刚性解释**\n该 IVP 是刚性的，因为其精确解 $y(t) = \\frac{\\epsilon\\sin(t) - \\epsilon^2\\cos(t)}{1+\\epsilon^2} + \\frac{\\epsilon^2}{1+\\epsilon^2} e^{-t/\\epsilon}$ 包含两个时间尺度差异巨大的分量。\n1. 一个与 $e^{-t/\\epsilon}$ 成正比的快速衰减的瞬态分量，其特征时间尺度为 $\\tau_{fast} = \\epsilon = 10^{-6}$。该分量几乎瞬间就可以忽略不计。\n2. 一个缓慢变化的分量，其振荡的时间尺度为 $\\tau_{slow} \\approx 2\\pi$。\n\n刚性的产生是因为像前向欧拉这样的显式方法的稳定性受最快时间尺度 ($\\tau_{fast}$) 的支配，即使在快速分量消失很久之后，也迫使其使用不切实际的小步长 ($h \\le 2\\epsilon$)。而像后向欧拉这样的隐式方法，对于本问题是无条件稳定的，其稳定性不受 $\\tau_{fast}$ 的限制。它可以使用由捕捉慢分量的精度要求决定的更大的步长 $h$，这使其在处理刚性问题时效率要高得多。\n\n### 4. 实现与误差分析\n\n我们实现了前向和后向欧拉方法，用于在 $t \\in [0, 10]$ 区间上对步长 $h \\in \\{0.001, 0.01, 0.1, 1.0\\}$ 求解该 IVP。由于所有这些步长都违反了前向欧拉的稳定性条件 ($h > 2 \\times 10^{-6}$)，预计显式方法将产生数值不稳定的解，这些解会无界增长，导致无穷大的最大误差。而隐式方法是稳定的，应该能产生准确的结果，且误差随着 $h$ 的减小而减小。对于每种情况，都在网格点上计算数值解与精确解之间的最大绝对误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a stiff ODE using Forward and Backward Euler methods,\n    and calculates the maximum absolute error against the exact solution.\n    \"\"\"\n    \n    # Define problem parameters from the statement\n    epsilon = 1e-6\n    t_end = 10.0\n    y0 = 0.0\n    \n    # Test suite of step sizes, in increasing order as required for output.\n    h_values = [0.001, 0.01, 0.1, 1.0]\n    \n    # List to store the results in the specified order.\n    results = []\n\n    # Exact solution derived via integrating factor\n    # y(t) = (epsilon*sin(t) - epsilon^2*cos(t))/(1 + epsilon^2) \n    #        + (epsilon^2 / (1 + epsilon^2)) * exp(-t/epsilon)\n    def y_exact(t, eps):\n        term1 = (eps * np.sin(t) - eps**2 * np.cos(t)) / (1 + eps**2)\n        term2 = (eps**2 / (1 + eps**2)) * np.exp(-t / eps)\n        return term1 + term2\n\n    # Loop over each step size\n    for h in h_values:\n        # Create a stable time grid from 0 to t_end\n        # Using np.linspace is more robust against floating point errors than np.arange\n        num_steps = int(round(t_end / h))\n        t_points = np.linspace(0, t_end, num_steps + 1)\n        \n        # --- Explicit Forward Euler Method ---\n        y_fe = np.zeros(num_steps + 1)\n        y_fe[0] = y0\n        is_finite_fe = True\n        \n        for n in range(num_steps):\n            # y_{n+1} = y_n + h * f(t_n, y_n)\n            # f(t,y) = -y/epsilon + sin(t)\n            y_fe[n+1] = y_fe[n] + h * (-y_fe[n] / epsilon + np.sin(t_points[n]))\n            # Check for overflow at each step to prevent warnings and handle correctly.\n            if not np.isfinite(y_fe[n+1]):\n                is_finite_fe = False\n                break\n        \n        # Calculate maximum absolute error for Forward Euler\n        if is_finite_fe:\n            y_true = y_exact(t_points, epsilon)\n            error_fe = np.max(np.abs(y_fe - y_true))\n        else:\n            # As per problem, if solution is non-finite, error is +inf\n            error_fe = float('inf')\n        \n        results.append(error_fe)\n        \n        # --- Implicit Backward Euler Method ---\n        y_be = np.zeros(num_steps + 1)\n        y_be[0] = y0\n        \n        for n in range(num_steps):\n            # y_{n+1} = (y_n + h*sin(t_{n+1})) / (1 + h/epsilon)\n            numerator = y_be[n] + h * np.sin(t_points[n+1])\n            denominator = 1 + h / epsilon\n            y_be[n+1] = numerator / denominator\n\n        # Calculate maximum absolute error for Backward Euler\n        y_true = y_exact(t_points, epsilon)\n        error_be = np.max(np.abs(y_be - y_true))\n        results.append(error_be)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3198039"}, {"introduction": "现实世界中的刚性问题通常是非线性的。当我们将隐式方法（如后向欧拉法）应用于非线性常微分方程时，每一步都需要求解一个非线性代数方程。本练习将指导你掌握解决这一挑战的关键技术：牛顿法（Newton's method）。你将把后向欧拉法与牛顿法相结合，实现一个能够求解非线性刚性系统的迭代求解器，这是解决复杂实际问题的核心技能之一 [@problem_id:2442982]。", "problem": "给定一个标量常微分方程（ODE）\n$$\n\\frac{dy}{dt} = f(t,y) = -k\\,(y - \\sin t) - b\\,y^3,\n$$\n其初始条件为\n$$\ny(0) = y_0,\n$$\n该方程定义在区间\n$$\nt \\in [0,T], \\quad t_n = n\\,h, \\quad n=0,1,\\dots,N, \\quad \\text{其中 } Nh = T \\text{ 且 } h0.\n$$\n上的均匀时间网格上。\n函数 $\\sin t$ 中的角度必须以弧度为单位。在每一步，使用隐式单步更新\n$$\ny_{n+1} = y_n + h\\,f(t_{n+1}, y_{n+1}),\n$$\n并使用牛顿法求解所得的关于 $y_{n+1}$ 的非线性代数方程，残差或牛顿步长的绝对停止容差为 $10^{-12}$，每个时间步最多迭代 50 次。在每一步中，使用 $y_{n}$ 初始化牛顿法。\n\n实现一个程序，对下面测试套件中的每一组参数，使用上述方法将数值解从 $t=0$ 推进到 $t=T$，并返回 $y(T)$ 的近似值。\n\n测试套件（每个元组为 $(k,b,y_0,T,h)$）：\n- 情况 A（刚性，非线性，受力）：$(1000, 10, 0, 0.1, 0.001)$。\n- 情况 B（刚性，线性，受力）：$(1000, 0, 1, 0.1, 0.001)$。\n- 情况 C（单大步长，刚性，非线性）：$(1000, 5, 1, 0.05, 0.05)$。\n- 情况 D（非刚性，纯非线性）：$(0, 50, 1, 0.02, 0.005)$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的条目依次是情况 A, B, C, D 的 $y(T)$ 近似值，每个值都四舍五入到恰好 8 位小数。例如，一个包含四个结果的输出必须如下所示\n$$\n[\\text{res}_A,\\text{res}_B,\\text{res}_C,\\text{res}_D].\n$$", "solution": "所给问题是一个形如 $\\frac{dy}{dt} = f(t,y)$ 的标量常微分方程（ODE），需要进行数值求解。该问题定义明确，科学上合理，并包含了通过指定算法获得唯一解所需的所有信息。因此，我将着手解决该问题。\n\n控制方程为：\n$$\n\\frac{dy}{dt} = f(t,y) = -k\\,(y - \\sin t) - b\\,y^3, \\quad y(0) = y_0\n$$\n该方程描述了一个系统，其包含一个以速率 $k$ 趋向于正弦驱动函数 $\\sin t$ 的线性松弛项，以及一个与 $y^3$ 成正比的非线性阻尼项。$k$ 的大小决定了方程的刚性。对于较大的 $k$，显式数值方法需要极小的时间步长 $h \\ll 1/k$ 才能保持稳定。该问题正确地指定了使用隐式方法来处理这种刚性。\n\n数值积分采用隐式单步后向欧拉法。对于均匀时间网格 $t_n = n\\,h$，从时间 $t_n$ 到 $t_{n+1}$ 的更新规则由下式给出：\n$$\ny_{n+1} = y_n + h\\,f(t_{n+1}, y_{n+1})\n$$\n其中 $y_n$ 是 $y(t_n)$ 的近似值。该方程是隐式的，因为未知值 $y_{n+1}$ 出现在方程的两边。为了在每个时间步求解 $y_{n+1}$，我们必须求解一个非线性代数方程。该方程可以通过定义一个我们寻求其根的残差函数 $R(x)$ 来表示：\n$$\nR(x) = x - y_n - h\\,f(t_{n+1}, x) = 0\n$$\n其中 $x$ 代表未知数 $y_{n+1}$。\n\n为了找到 $R(x)=0$ 的根，我们采用牛顿法，这是一个由下式定义的迭代过程：\n$$\nx^{(j+1)} = x^{(j)} - \\frac{R(x^{(j)})}{R'(x^{(j)})}\n$$\n其中 $x^{(j)}$ 是第 $j$ 次迭代时对根的猜测值，$R'(x) = \\frac{dR}{dx}$ 是残差函数相对于 $x$ 的导数。每个时间步的初始猜测值被指定为上一步的值，即 $x^{(0)} = y_n$。\n\n$R'(x)$ 的导数计算如下：\n$$\nR'(x) = \\frac{d}{dx} \\left( x - y_n - h\\,f(t_{n+1}, x) \\right) = 1 - h\\,\\frac{\\partial f}{\\partial y}(t_{n+1}, x)\n$$\n对于给定的函数 $f(t,y)$，其关于 $y$ 的偏导数为：\n$$\n\\frac{\\partial f}{\\partial y}(t,y) = \\frac{\\partial}{\\partial y} \\left( -k\\,(y - \\sin t) - b\\,y^3 \\right) = -k - 3\\,b\\,y^2\n$$\n将此代入 $R'(x)$ 的表达式，我们得到：\n$$\nR'(x) = 1 - h\\,(-k - 3\\,b\\,x^2) = 1 + h\\,k + 3\\,h\\,b\\,x^2\n$$\n因此，求解 $y_{n+1}$ 的牛顿迭代是一个循环过程，不断更新猜测值 $x^{(j)}$ 直到满足停止准则。该准则为残差的绝对值 $|R(x^{(j)})|$ 或牛顿步长的绝对值 $|x^{(j+1)} - x^{(j)}|$ 小于 $10^{-12}$ 的绝对容差。如果在 50 次迭代内未达到收敛，则终止该过程。\n\n每个测试用例的总体算法如下：\n1.  初始化参数 $(k, b, y_0, T, h)$ 并计算总步数 $N = T/h$。\n2.  设置初始解 $y = y_0$ 和时间 $t = 0$。\n3.  从 $n=0$ 循环到 $N-1$：\n    a.  确定下一个时间点 $t_{n+1} = (n+1)h$。\n    b.  将牛顿法对 $y_{n+1}$ 的初始猜测值设为 $x^{(0)} = y_n$。\n    c.  使用牛顿法迭代最多 50 步来寻找解 $R(x)=0$ 的 $x$。在每次迭代 $j$ 中：\n        i.  计算残差 $R(x^{(j)})$。如果其绝对值小于 $10^{-12}$，则达到收敛。该时间步的结果为 $x^{(j)}$。\n        ii. 计算导数 $R'(x^{(j)})$。\n        iii. 计算牛顿步长 $\\Delta x = -R(x^{(j)}) / R'(x^{(j)})$。\n        iv. 更新猜测值：$x^{(j+1)} = x^{(j)} + \\Delta x$。\n        v. 如果步长的绝对值 $|\\Delta x|$ 小于 $10^{-12}$，则达到收敛。该时间步的结果为 $x^{(j+1)}$。\n    d.  更新下一个时间步的解：$y_{n+1} = x_{converged}$。\n4.  经过 $N$ 步后 $y$ 的最终值即为所要求的 $y(T)$ 的近似值。对所有指定的测试用例重复此过程。", "answer": "```python\nimport numpy as np\n\ndef run_simulation(k, b, y0, T, h):\n    \"\"\"\n    Solves the ODE dy/dt = -k*(y - sin(t)) - b*y^3 using Backward Euler\n    with Newton's method for the nonlinear solve.\n    \n    Args:\n        k (float): Stiffness parameter.\n        b (float): Nonlinearity parameter.\n        y0 (float): Initial condition y(0).\n        T (float): Final time.\n        h (float): Time step size.\n\n    Returns:\n        float: The numerical solution y(T).\n    \"\"\"\n\n    # Define the ODE function f(t, y)\n    def f(t, y, k, b):\n        return -k * (y - np.sin(t)) - b * y**3\n\n    # Define the partial derivative of f with respect to y, df/dy\n    def df_dy(t, y, k, b):\n        return -k - 3 * b * y**2\n\n    # Ensure n_steps is integer\n    n_steps = int(round(T / h))\n    if not np.isclose(n_steps * h, T):\n        # This case is not expected based on the problem statement's test cases\n        # but is good practice.\n        raise ValueError(\"T must be an integer multiple of h.\")\n\n    y_current = y0\n\n    # Main time-stepping loop\n    for n in range(n_steps):\n        t_next = (n + 1) * h\n        y_guess = y_current\n        \n        # Newton's method to solve y_next = y_current + h * f(t_next, y_next)\n        # This is equivalent to finding the root of R(y_next) = 0 where\n        # R(y_next) = y_next - y_current - h * f(t_next, y_next)\n        for _ in range(50): # Maximum of 50 iterations\n            \n            # Calculate residual at the current guess\n            residual = y_guess - y_current - h * f(t_next, y_guess, k, b)\n\n            # Check for convergence on residual\n            if abs(residual)  1e-12:\n                break\n                \n            # Calculate Jacobian of the residual function\n            # R'(y) = 1 - h * df/dy\n            jac_residual = 1.0 - h * df_dy(t_next, y_guess, k, b)\n            \n            # Avoid division by zero, although not an issue for this problem's parameters\n            if jac_residual == 0:\n                break\n\n            # Calculate Newton step\n            step = -residual / jac_residual\n            \n            # Update the guess\n            y_guess += step\n            \n            # Check for convergence on the step size\n            if abs(step)  1e-12:\n                break\n        \n        y_current = y_guess\n\n    return y_current\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test suite: (k, b, y0, T, h)\n    test_cases = [\n        (1000, 10, 0, 0.1, 0.001),     # Case A\n        (1000, 0, 1, 0.1, 0.001),      # Case B\n        (1000, 5, 1, 0.05, 0.05),       # Case C\n        (0, 50, 1, 0.02, 0.005)        # Case D\n    ]\n\n    results = []\n    for params in test_cases:\n        y_final = run_simulation(*params)\n        results.append(y_final)\n\n    # Format output as specified\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2442982"}]}