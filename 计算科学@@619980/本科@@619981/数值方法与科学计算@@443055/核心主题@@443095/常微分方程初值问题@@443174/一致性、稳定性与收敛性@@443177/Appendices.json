{"hands_on_practices": [{"introduction": "要判断一个数值方法的优劣，一个核心问题是看它如何处理基本物理行为，例如振动。本练习将分析几种经典方法在求解一个纯振荡系统时的表现。我们将引入“放大因子”$R(z)$这一关键分析工具，它的模长$|R(z)|$直接决定了数值解的幅度是会人为地增长、衰减还是保持不变。通过这个练习，你将在一个直观、可视化的场景中，建立起方法数学形式与长时程稳定性之间的联系，这是分析任何数值积分器所必备的基础技能。", "problem": "考虑线性常微分方程 (ODE) $y'(t) = i\\omega y(t)$，其中频率 $\\omega > 0$ 为实数，初始条件 $y(0) = y_{0} \\in \\mathbb{C}$ 为复数。给定一个固定的时间步长 $h > 0$，并考虑以下单步数值方法：前向欧拉法、后向欧拉法和梯形法则（也称为 Crank–Nicolson 方法）。从这些方法作为 $y'(t) = f(t,y)$ 的显式或隐式单步近似的基本定义出发，推导此常微分方程对应的离散更新关系。使用线性测试方程 $y' = \\lambda y$ 的放大因子（也称为稳定性函数）的基本概念，其中单步更新可写作 $y_{n+1} = R(z)\\,y_{n}$，且 $z = \\lambda h$，求出每种方法的放大因子。然后，将情况特殊化到 $\\lambda = i\\omega$，并确定每种方法的放大因子的绝对值。从第一性原理出发，解释随着 $n$ 的增加，这些绝对值如何决定离散解在复平面上是向外螺旋、向内螺旋，还是保持在一个圆上。最后，令 $r_{0} = |y_{0}|$ 且 $N \\in \\mathbb{N}$ 为所采取的步数。提供由每种方法产生的模 $|y_{N}|$ 关于 $\\omega$、 $h$、 $r_{0}$ 和 $N$ 的闭式表达式。将您的最终答案表示为一个单行矩阵，按以下顺序包含三个模：前向欧拉法、后向欧拉法、梯形法则。不需要四舍五入，所有量都是无量纲的。", "solution": "首先根据所需准则验证问题陈述。\n\n**步骤1：提取已知条件**\n- **常微分方程**：$y'(t) = i\\omega y(t)$\n- **常数和变量**：$\\omega \\in \\mathbb{R}$，$\\omega > 0$；$h > 0$；$N \\in \\mathbb{N}$\n- **初始条件**：$y(0) = y_{0} \\in \\mathbb{C}$\n- **定义**：$r_{0} = |y_{0}|$\n- **方法**：前向欧拉法、后向欧拉法、梯形法则（Crank-Nicolson）\n- **框架**：线性测试方程 $y' = \\lambda y$ 导致单步更新 $y_{n+1} = R(z)y_{n}$，其中 $z = \\lambda h$。\n- **任务**：推导更新关系，找到放大因子 $R(z)$，特殊化到 $\\lambda = i\\omega$ 以求得 $|R(i\\omega h)|$，解释放大因子幅值的几何意义，并为每种方法提供 $|y_N|$ 的闭式表达式。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，是适定且客观的。它是常微分方程数值分析领域中一个标准的、基本的问题。它测试了在应用于纯振荡系统时，对基本数值方法稳定性的理解。问题陈述是自洽的，提供了所有必要的定义和变量。所用术语精确且标准。没有矛盾、歧义或违反科学原理之处。\n\n**步骤3：结论与行动**\n问题有效。将提供完整解答。\n\n**离散更新关系的推导**\n给定常微分方程 $y'(t) = f(t,y)$，其中 $f(t,y) = i\\omega y(t)$。设 $y_n$ 是在时间 $t_n = n h$ 时 $y(t_n)$ 的数值近似。\n\n1.  **前向欧拉法**：这是一种显式方法，定义为 $y_{n+1} = y_n + h f(t_n, y_n)$。\n    代入 $f(t_n, y_n) = i\\omega y_n$，我们得到：\n    $$y_{n+1} = y_n + h (i\\omega y_n) = (1 + i\\omega h) y_n$$\n\n2.  **后向欧拉法**：这是一种隐式方法，定义为 $y_{n+1} = y_n + h f(t_{n+1}, y_{n+1})$。\n    代入 $f(t_{n+1}, y_{n+1}) = i\\omega y_{n+1}$，我们得到：\n    $$y_{n+1} = y_n + h (i\\omega y_{n+1})$$\n    为了求出 $y_{n+1}$，我们必须解出它：\n    $$y_{n+1} - i\\omega h y_{n+1} = y_n$$\n    $$y_{n+1}(1 - i\\omega h) = y_n$$\n    $$y_{n+1} = \\frac{1}{1 - i\\omega h} y_n$$\n\n3.  **梯形法则（Crank-Nicolson 方法）**：这是一种隐式方法，定义为 $y_{n+1} = y_n + \\frac{h}{2}(f(t_n, y_n) + f(t_{n+1}, y_{n+1}))$。\n    代入 $f$ 的具体形式，我们有：\n    $$y_{n+1} = y_n + \\frac{h}{2}(i\\omega y_n + i\\omega y_{n+1})$$\n    同样，我们解出 $y_{n+1}$：\n    $$y_{n+1} - \\frac{i\\omega h}{2} y_{n+1} = y_n + \\frac{i\\omega h}{2} y_n$$\n    $$y_{n+1}\\left(1 - \\frac{i\\omega h}{2}\\right) = y_n\\left(1 + \\frac{i\\omega h}{2}\\right)$$\n    $$y_{n+1} = \\frac{1 + \\frac{i\\omega h}{2}}{1 - \\frac{i\\omega h}{2}} y_n$$\n\n**放大因子及其模**\n对于线性测试方程 $y' = \\lambda y$，数值更新的形式为 $y_{n+1} = R(z)y_n$，其中 $z = \\lambda h$。函数 $R(z)$ 是放大因子或稳定性函数。对于我们的具体问题，$\\lambda = i\\omega$，所以 $z = i\\omega h$。\n\n1.  **前向欧拉法**：更新关系为 $y_{n+1} = (1 + i\\omega h) y_n$。将其与 $y_{n+1} = R(i\\omega h)y_n$ 比较，我们确定放大因子为：\n    $$R_{\\text{FE}}(i\\omega h) = 1 + i\\omega h$$\n    这个复数的绝对值（模）是：\n    $$|R_{\\text{FE}}(i\\omega h)| = |1 + i\\omega h| = \\sqrt{1^2 + (\\omega h)^2} = \\sqrt{1 + (\\omega h)^2}$$\n\n2.  **后向欧拉法**：更新关系为 $y_{n+1} = \\frac{1}{1 - i\\omega h} y_n$。放大因子为：\n    $$R_{\\text{BE}}(i\\omega h) = \\frac{1}{1 - i\\omega h}$$\n    其绝对值为：\n    $$|R_{\\text{BE}}(i\\omega h)| = \\left|\\frac{1}{1 - i\\omega h}\\right| = \\frac{|1|}{|1 - i\\omega h|} = \\frac{1}{\\sqrt{1^2 + (-\\omega h)^2}} = \\frac{1}{\\sqrt{1 + (\\omega h)^2}}$$\n\n3.  **梯形法则**：更新关系为 $y_{n+1} = \\frac{1 + i\\omega h/2}{1 - i\\omega h/2} y_n$。放大因子为：\n    $$R_{\\text{TR}}(i\\omega h) = \\frac{1 + \\frac{i\\omega h}{2}}{1 - \\frac{i\\omega h}{2}}$$\n    其绝对值为：\n    $$|R_{\\text{TR}}(i\\omega h)| = \\left|\\frac{1 + \\frac{i\\omega h}{2}}{1 - \\frac{i\\omega h}{2}}\\right| = \\frac{|1 + \\frac{i\\omega h}{2}|}{|1 - \\frac{i\\omega h}{2}|} = \\frac{\\sqrt{1^2 + (\\frac{\\omega h}{2})^2}}{\\sqrt{1^2 + (-\\frac{\\omega h}{2})^2}} = \\frac{\\sqrt{1 + \\frac{(\\omega h)^2}{4}}}{\\sqrt{1 + \\frac{(\\omega h)^2}{4}}} = 1$$\n    这是因为分子和分母是复共轭的，它们总是有相同的模。\n\n**几何解释**\n方程 $y'(t) = i\\omega y(t)$ 在初始条件 $y(0) = y_0$ 下的精确解是 $y(t) = y_0 \\exp(i\\omega t)$。精确解的模为 $|y(t)| = |y_0||\\exp(i\\omega t)| = |y_0| = r_0$，对于所有时间 $t$ 都是恒定的。这意味着精确解在复平面上沿着一个半径为 $r_0$ 的圆运动。\n\n数值解遵循递推关系 $y_{n+1} = R(i\\omega h) y_n$。对两边取模，得到 $|y_{n+1}| = |R(i\\omega h) y_n| = |R(i\\omega h)| |y_n|$。通过归纳法，经过 $n$ 步后，我们有 $|y_n| = |R(i\\omega h)|^n |y_0|$。数值解的模的行为取决于 $|R(i\\omega h)|$ 的值：\n\n-   如果 $|R(i\\omega h)| > 1$：模 $|y_n|$ 每一步都会增长。数值解会向外螺旋，远离真实解的圆形路径。对于前向欧拉法，由于 $\\omega > 0$ 和 $h > 0$，我们有 $(\\omega h)^2 > 0$，这意味着 $|R_{\\text{FE}}(i\\omega h)| = \\sqrt{1 + (\\omega h)^2} > 1$。因此，对于此问题，前向欧拉法是无条件不稳定的，总是产生一个以指数级增长的振幅向外螺旋的解。\n\n-   如果 $|R(i\\omega h)|  1$：模 $|y_n|$ 每一步都会减小。数值解会向内螺旋，衰减至原点。对于后向欧拉法，由于 $(\\omega h)^2 > 0$，我们有 $\\sqrt{1 + (\\omega h)^2} > 1$，这意味着 $|R_{\\text{BE}}(i\\omega h)| = \\frac{1}{\\sqrt{1 + (\\omega h)^2}}  1$。因此，后向欧拉法引入了人为的数值耗散，导致解向内螺旋。\n\n-   如果 $|R(i\\omega h)| = 1$：模 $|y_n|$ 保持恒定，对于所有 $n$ 都有 $|y_n| = |y_0|$。数值解的点保持在半径为 $r_0$ 的初始圆上，就像精确解一样。对于梯形法则，我们发现对于所有的 $\\omega$ 和 $h$，都有 $|R_{\\text{TR}}(i\\omega h)| = 1$。这意味着该方法是保守的；它精确地保持了解的模，这是所模拟的底层物理系统的一个关键属性（例如，能量或概率守恒）。\n\n**$|y_N|$ 的闭式表达式**\n使用关系式 $|y_N| = |R(i\\omega h)|^N |y_0|$ 和定义 $r_0 = |y_0|$，我们可以写出经过 $N$ 步后模的闭式表达式。\n\n1.  **前向欧拉法**：\n    $$|y_N|_{\\text{FE}} = \\left(\\sqrt{1 + (\\omega h)^2}\\right)^N r_0 = r_0 \\left(1 + (\\omega h)^2\\right)^{\\frac{N}{2}}$$\n\n2.  **后向欧拉法**：\n    $$|y_N|_{\\text{BE}} = \\left(\\frac{1}{\\sqrt{1 + (\\omega h)^2}}\\right)^N r_0 = r_0 \\left(1 + (\\omega h)^2\\right)^{-\\frac{N}{2}}$$\n\n3.  **梯形法则**：\n    $$|y_N|_{\\text{TR}} = (1)^N r_0 = r_0$$\n\n这些表达式量化了每种方法的数值解幅值的长期行为。", "answer": "$$\\boxed{\\begin{pmatrix} r_{0} \\left(1 + (\\omega h)^2\\right)^{\\frac{N}{2}}  r_{0} \\left(1 + (\\omega h)^2\\right)^{-\\frac{N}{2}}  r_{0} \\end{pmatrix}}$$", "id": "3216925"}, {"introduction": "一个自然的问题是：如果一个数值方法能够很好地近似导数（即具有一致性），这是否足以保证其数值解的正确性（即收敛性）？Dahlquist等价定理给出了否定的答案，它指出收敛性同时需要一致性和零点稳定性。[@problem_id:3112000]这个练习将引导你分析一个特殊的线性多步法，它虽然是一致的，却不满足零点稳定性的要求。通过理论分析和动手编程，你将深刻理解为何零点稳定性是数值方法可靠性不可或缺的基石，并亲眼见证一个不收敛格式如何产生谬误的结果。", "problem": "您需要通过分析和计算两方面证明，一个线性多步法可以既是一致的，又不满足零点稳定性，并因此在线性测试问题上即使步长趋于零时也会发散。严格依据核心定义和经过充分检验的事实进行推导。考虑常微分方程 (ODE) 线性测试问题 $y'=\\lambda y$（其中 $\\lambda\\in\\mathbb{R}$ 为常数）以及以下两步法\n$$\ny_{n+1}-2y_n+y_{n-1}=h\\left(f_{n+1}-f_n\\right),\n$$\n其中 $f_k=f(t_k,y_k)$，$t_k=t_0+kh$，$h>0$ 是时间步长。该格式是为足够光滑的 $f$ 定义的，并使用两个先前的值 $y_{n}$ 和 $y_{n-1}$ 来计算 $y_{n+1}$。\n\n您必须：\n- 从第一性原理出发，使用基于“对于光滑精确解，局部截断误差在 $h\\to 0$ 时趋于零”的线性多步法一致性定义，来推导该方法是否是一致的。您的推导应基于精确解的泰勒展开和标准的线性多步法表示，不应使用核心定义之外的捷径公式。\n- 从该方法的齐次部分（即当 $f\\equiv 0$ 时连接 $y_{n+1}$、$y_n$、$y_{n-1}$ 的多项式）所导出的特征多项式出发，分析零点稳定性的根条件，并确定该方法是否满足零点稳定性。\n- 解释为什么不满足零点稳定性意味着在固定的最终时间 $T>0$ 时，即使对应的常微分方程有有界解（例如当 $\\lambda\\le 0$ 时），全局数值误差也会随着 $h\\to 0$ 而无界增长。您的推理应将重根现象与寄生模式的增长以及对步数 $N=T/h$ 的依赖关系联系起来。\n\n然后，在线性测试问题 $y'=\\lambda y$ 上实现该方法，使用精确初始值 $y(0)=y_0$ 和一个故意扰动的第二个初始值。使用 $y_0=\\exp(0\\cdot\\lambda)=1$ 和 $y(h)=\\exp(\\lambda h)$ 作为精确的第一步。通过设置 $y_1^{\\text{start}}=\\exp(\\lambda h)+\\varepsilon$ 向第二个初始值引入一个大小为 $\\varepsilon\\ge 0$ 的固定扰动。将递推关系演进到 $t=T$，并测量最终绝对误差 $E(h)=|y_N-\\exp(\\lambda T)|$，其中 $N=T/h$ 是整数步数。对于每个测试用例，比较 $E(h_\\text{small})$ 与 $E(h_\\text{large})$ 以检测当 $h\\to 0$ 时的发散情况。\n\n测试套件规范：\n- 所有情况均使用最终时间 $T=1$。\n- 使用两个步长 $h_\\text{large}=0.1$ 和 $h_\\text{small}=0.05$（以确保两种情况下 $N$ 都是整数）。\n- 提供三个涵盖不同方面的测试用例：\n  1. 一般情况：$\\lambda=-1$, $\\varepsilon=10^{-8}$。\n  2. 具有常数解的边界情况：$\\lambda=0$, $\\varepsilon=10^{-8}$。\n  3. 具有完美初始值的边缘情况：$\\lambda=-1$, $\\varepsilon=0$。\n- 对于每个测试用例，计算布尔值 $B=\\big(E(h_\\text{small})>E(h_\\text{large})\\big)$，在表现出随着步长减小而发散的情况下，该值应为 $\\text{True}$，否则为 $\\text{False}$。\n\n您的程序应生成一行输出，其中包含三个测试用例的布尔值，格式为用方括号括起来的逗号分隔列表（例如，$[\\text{True},\\text{False},\\text{True}]$）。此问题不涉及物理单位或角度单位。所有数学实体必须用 LaTeX 书写。程序必须是自包含的，不需要任何输入，并在给定的测试用例上精确地实现指定的方法。", "solution": "该问题陈述是常微分方程 (ODE) 数值分析中的一个有效练习。它是自包含的，其科学基础根植于线性多步法理论，并提出了一组明确定义的分析和计算任务。我们将开始进行解答。\n\n该问题要求分析应用于线性测试方程 $y' = \\lambda y$ 的两步法\n$$\ny_{n+1}-2y_n+y_{n-1}=h\\left(f_{n+1}-f_n\\right)\n$$\n对于该方程，$f(t,y) = \\lambda y$，因此 $f_k = \\lambda y_k$。\n\n### 第 1 部分：一致性分析\n\n如果一个线性多步法的局部截断误差 (LTE) 在步长 $h \\to 0$ 时趋近于零，那么该方法就是一致的。我们从第一性原理推导 LTE。设 $y(t)$ 是常微分方程 $y' = f(t, y(t))$ 的一个足够光滑的精确解。第 $n+1$ 步的 LTE 是通过将精确解代入数值格式来定义的。为与 $k$ 步法的标准定义保持一致，我们将索引加 1，将该方法表示为从先前的步骤计算第 $n+2$ 步：\n$$\ny_{n+2} - 2y_{n+1} + y_n = h(f_{n+2} - f_{n+1})\n$$\n该方法的线性差分算子 $\\mathcal{L}$ 为：\n$$\n\\mathcal{L}[y(t); h] = y(t+2h) - 2y(t+h) + y(t) - h\\left(y'(t+2h) - y'(t+h)\\right)\n$$\n局部截断误差为 $T_{n+2} = \\mathcal{L}[y(t_n); h]/h$。一致性要求对于任何足够光滑的解 $y(t)$，当 $h \\to 0$ 时有 $T_{n+k} \\to 0$。\n\n我们对 $y(t+h)$、$y(t+2h)$、$y'(t+h)$ 和 $y'(t+2h)$ 在点 $t$ 附近进行泰勒级数展开：\n\\begin{align*}\ny(t+h) = y(t) + h y'(t) + \\frac{h^2}{2} y''(t) + \\frac{h^3}{6} y'''(t) + O(h^4) \\\\\ny(t+2h) = y(t) + 2h y'(t) + \\frac{(2h)^2}{2} y''(t) + \\frac{(2h)^3}{6} y'''(t) + O(h^4) \\\\\n= y(t) + 2h y'(t) + 2h^2 y''(t) + \\frac{4h^3}{3} y'''(t) + O(h^4) \\\\\ny'(t+h) = y'(t) + h y''(t) + \\frac{h^2}{2} y'''(t) + O(h^3) \\\\\ny'(t+2h) = y'(t) + 2h y''(t) + \\frac{(2h)^2}{2} y'''(t) + O(h^3) \\\\\n= y'(t) + 2h y''(t) + 2h^2 y'''(t) + O(h^3)\n\\end{align*}\n将这些展开式代入算子 $\\mathcal{L}[y(t); h]$：\n\n第一部分（涉及 $y$）：\n\\begin{align*}\n y(t+2h) - 2y(t+h) + y(t) \\\\\n= \\left(y(t) + 2h y' + 2h^2 y'' + \\frac{4h^3}{3} y'''\\right) - 2\\left(y(t) + h y' + \\frac{h^2}{2} y'' + \\frac{h^3}{6} y'''\\right) + y(t) + O(h^4) \\\\\n= (1-2+1)y(t) + (2-2)h y'(t) + (2-1)h^2 y''(t) + \\left(\\frac{4}{3} - \\frac{2}{6}\\right)h^3 y'''(t) + O(h^4) \\\\\n= h^2 y''(t) + h^3 y'''(t) + O(h^4)\n\\end{align*}\n\n第二部分（涉及 $y'$）：\n\\begin{align*}\n h\\left(y'(t+2h) - y'(t+h)\\right) \\\\\n= h\\left[ \\left(y'(t) + 2h y'' + 2h^2 y'''\\right) - \\left(y'(t) + h y'' + \\frac{h^2}{2} y'''\\right) + O(h^3) \\right] \\\\\n= h\\left[ h y''(t) + \\frac{3h^2}{2} y'''(t) + O(h^3) \\right] \\\\\n= h^2 y''(t) + \\frac{3h^3}{2} y'''(t) + O(h^4)\n\\end{align*}\n\n结合两部分：\n\\begin{align*}\n\\mathcal{L}[y(t); h] = \\left(h^2 y''(t) + h^3 y'''(t)\\right) - \\left(h^2 y''(t) + \\frac{3h^3}{2} y'''(t)\\right) + O(h^4) \\\\\n= -\\frac{1}{2}h^3 y'''(t) + O(h^4)\n\\end{align*}\n\n局部截断误差为 $T_{n+2} = \\mathcal{L}[y(t_n); h]/h = -\\frac{1}{2}h^2 y'''(t_n) + O(h^3)$。\n由于当 $h \\to 0$ 时 $T_{n+2} \\to 0$，因此该方法是 **一致的**。精度阶为 $p=2$，因为 LTE 的首项是 $O(h^2)$。\n\n### 第 2 部分：零点稳定性分析\n\n零点稳定性关系到数值解在齐次问题 $y' = 0$（或等价地，在 $h \\to 0$ 的极限下）的行为。对于给定的方法，令 $f \\equiv 0$（或 $h=0$）可得到齐次线性差分方程：\n$$\ny_{n+1} - 2y_n + y_{n-1} = 0\n$$\n为分析其稳定性，我们考察其第一特征多项式 $\\rho(z)$ 的根。假设解的形式为 $y_n=z^n$，我们将其代入差分方程：\n$$\nz^{n-1}(z^2 - 2z + 1) = 0\n$$\n特征多项式为 $\\rho(z) = z^2 - 2z + 1 = (z-1)^2$。$\\rho(z)=0$ 的根是 $z_1=1$ 和 $z_2=1$，即在 $z=1$ 处有一个二重根。\n\n零点稳定性的 **根条件** 指出：\n1.  $\\rho(z)$ 的所有根必须位于复平面的单位圆内或单位圆上（即 $|z_i| \\le 1$）。\n2.  任何位于单位圆上的根（即 $|z_i|=1$）必须是单根（即重数为 $1$）。\n\n我们方法的根是 $z_1=z_2=1$。它们位于单位圆上，满足第一个条件。然而，位于 $z=1$ 的根的重数为 2，这违反了第二个条件。\n因此，该方法 **不满足零点稳定性**。\n\n### 第 3 部分：发散性解释\n\nDahlquist 等价定理指出，一个线性多步法是收敛的当且仅当它既是一致的又是零点稳定的。由于我们的方法是一致的但不满足零点稳定性，所以它是 **不收敛的**。\n\n不满足零点稳定性意味着一旦引入误差，随着步数 $n$ 的增加，误差将被无界地放大。这可以通过考察齐次递推关系 $y_{n+1} - 2y_n + y_{n-1} = 0$ 的通解来理解。对于在 $z=1$ 处的二重根，其通解不仅仅是 $c_1 (1)^n$，还包括一个线性增长项：\n$$\ny_n = c_1 (1)^n + c_2 \\cdot n \\cdot (1)^n = c_1 + c_2 n\n$$\n$c_1$ 项对应于近似真实解的主根。$c_2 n$ 项是一个寄生解，它与常微分方程的行为不对应。在固定的最终时间 $T$，步数 $n = T/h$。因此，寄生成分的行为如同 $c_2 n = c_2 T/h$。随着步长 $h$ 减小（$h \\to 0$），步数 $n$ 增加，这个寄生解就会无界增长。\n\n对于完整问题 $y'=\\lambda y$，递推关系为 $y_{n+1}(1 - h\\lambda) = (2 - h\\lambda)y_n - y_{n-1}$。这是一个（对于固定的 $h$）常系数线性齐次差分方程。其特征方程为 $(1-h\\lambda)z^2 - (2-h\\lambda)z + 1 = 0$。它的根是 $z_1 = (1-h\\lambda)^{-1}$ 和 $z_2 = 1$。通解为 $y_n = c_1 z_1^n + c_2 z_2^n = c_1 ((1-h\\lambda)^{-1})^n + c_2$。\n对于小的 $h$，$z_1 \\approx 1+h\\lambda$，并且 $z_1^n \\approx (e^{h\\lambda})^n = e^{\\lambda nh} = e^{\\lambda t_n}$，所以 $z_1$ 是追踪真实解的主根。根 $z_2=1$ 是寄生根。\n\n系数 $c_1$ 和 $c_2$ 由初始值 $y_0$ 和 $y_1$ 决定。初始值中的一个微小扰动 $\\varepsilon$，$y_1 = y_{\\text{exact}}(h) + \\varepsilon$，会激发寄生模式。分析表明 $c_2$ 与 $\\varepsilon/h$ 成正比。具体来说，当 $\\lambda \\ne 0$ 时，$c_2 \\approx -\\varepsilon/(\\lambda h)$；当 $\\lambda=0$ 时，$c_2=\\varepsilon$。在这两种情况下，误差分量 $c_2$ 都随着 $h \\to 0$ 而增长。这意味着即使是无穷小的初始扰动也会被放大，导致全局误差以 $O(1/h)$ 的速度发散。\n\n对于具有完美初始值（$\\varepsilon=0$）的情况，系数 $c_2$ 与局部截断误差成正比，得到 $c_2 \\sim O(h)$。虽然这似乎表明收敛，但在计算的任何一步引入的任何浮点舍入误差都会像一个新的扰动一样，激发寄生模式。因此，发散是不可避免的，尽管如果初始数据非常精确，可能需要更多步才能变得明显。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes and implements an unstable linear multistep method to demonstrate\n    the consequences of failing the zero-stability condition.\n    \"\"\"\n\n    def compute_error(lambda_val, epsilon, h, T):\n        \"\"\"\n        Implements the given linear multistep method and computes the final error.\n\n        The method is: y_{n+1} - 2*y_n + y_{n-1} = h*(f_{n+1} - f_n)\n        For f(t,y) = lambda*y, this rearranges to:\n        y_{n+1} = ((2 - h*lambda)*y_n - y_{n-1}) / (1 - h*lambda)\n        \"\"\"\n        N = int(T / h)\n\n        # Starting values\n        # y_0 is the exact initial condition y(0)=1\n        y_prev = 1.0\n        # y_1 is the exact solution at t=h, plus a perturbation epsilon\n        y_curr = np.exp(lambda_val * h) + epsilon\n\n        # Handle the special case where lambda is 0\n        if lambda_val == 0:\n            # The recurrence simplifies to y_{n+1} = 2*y_n - y_{n-1}\n            for _ in range(N - 1): # Loop to compute y_2, y_3, ..., y_N\n                y_next = 2.0 * y_curr - y_prev\n                y_prev = y_curr\n                y_curr = y_next\n        else:\n            # Coefficients for the recurrence relation, pre-calculated for efficiency\n            c1 = (2.0 - h * lambda_val) / (1.0 - h * lambda_val)\n            c2 = -1.0 / (1.0 - h * lambda_val)\n            for _ in range(N - 1):\n                y_next = c1 * y_curr + c2 * y_prev\n                y_prev = y_curr\n                y_curr = y_next\n        \n        y_N = y_curr\n        \n        # Exact solution at time T\n        y_exact_T = np.exp(lambda_val * T)\n        \n        # Absolute error at final time T\n        error = np.abs(y_N - y_exact_T)\n        \n        return error\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (lambda, epsilon)\n        (-1.0, 1e-8),  # General case with stable ODE and perturbation\n        (0.0, 1e-8),   # Boundary case with constant solution and perturbation\n        (-1.0, 0.0),   # Edge case with stable ODE and no initial perturbation\n    ]\n    \n    T = 1.0\n    h_large = 0.1\n    h_small = 0.05\n    \n    results = []\n    for lambda_val, epsilon in test_cases:\n        # Compute error for the larger step size\n        error_large_h = compute_error(lambda_val, epsilon, h_large, T)\n        \n        # Compute error for the smaller step size\n        error_small_h = compute_error(lambda_val, epsilon, h_small, T)\n        \n        # Check for divergence: error increases as step size decreases\n        divergence_observed = error_small_h > error_large_h\n        results.append(divergence_observed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3112000"}, {"introduction": "在科学计算中，我们常使用自适应步长方法来控制局部误差，以提高效率。然而，这种策略是否总能保证得到正确的解，尤其是在面对具有挑战性的“刚性”问题时？本练习[@problem_id:3216936]将探讨自适应显式欧拉法在求解一个刚性系统时的行为。它揭示了局部精度（由一致性驱动）所允许的步长与数值稳定性所要求的步长之间可能存在的尖锐矛盾。通过编写代码并分析结果，你将发现简单自适应策略的一个关键局限，并理解为何在求解刚性微分方程时，稳定性是必须优先考虑的因素，其重要性甚至超过局部误差。", "problem": "实现并分析一个用于线性刚性系统的自适应显式欧拉时间步进器，重点关注一致性、稳定性和收敛性之间的相互作用。该系统为线性自治常微分方程，其对角矩阵为 $A = \\mathrm{diag}(-1,-1000)$，因此有 $y'(t) = A\\,y(t), \\quad y(t) \\in \\mathbb{R}^2,$，其精确解为 $y(t) = \\big(y_1(0)\\,e^{-t},\\; y_2(0)\\,e^{-1000\\,t}\\big).$ 您的程序必须基于基本定义完成以下任务。\n\n- 使用单步显式欧拉方法作为基本格式。一致性意味着当时间步长趋于零时，局部截断误差也趋于零。对于标量线性测试方程 $z'(t) = \\lambda z(t),$，显式欧拉更新得出 $z_{n+1} = z_n + h\\,\\lambda\\,z_n,$，其中 $h>0$ 是时间步长。使用线性测试方程和基于单步法放大因子的绝对稳定性定义，推导绝对稳定区域。您必须实现一个诊断功能，对于每个大小为 $h$ 的被接受的步，检查该步是否同时位于两个特征值 $\\lambda_1 = -1$ 和 $\\lambda_2 = -1000$ 的绝对稳定区域内。\n\n- 使用步长加倍法作为局部误差估计器。对于当前时刻 $t_n$ 的状态 $y_n$ 和试探步长 $h$，计算：\n  - 一个显式欧拉方法的完整步：$y^{(1)} = y_n + h\\,f(y_n), \\quad f(y) = A\\,y.$\n  - 两个显式欧拉方法的半步：$y_{n+1/2} = y_n + \\frac{h}{2}f(y_n)$，然后 $y^{(2)} = y_{n+1/2} + \\frac{h}{2}f(y_{n+1/2})$。\n  - 一个标量误差估计 $\\mathrm{est} = \\lVert y^{(2)} - y^{(1)} \\rVert_{\\infty}.$\n  如果 $\\mathrm{est} \\le \\mathrm{tol},$，则接受该步，其中 $\\mathrm{tol} > 0$ 是用户指定的容差。接受后，推进 $y_{n+1} := y^{(2)}$ 和 $t_{n+1} := t_n + h.$\n  使用基于一阶基本方法的步长加倍差异的二阶行为的标准控制器来更新下一步长：\n  $h_{\\mathrm{new}} = \\min\\big(h_{\\max},\\; \\max\\big(h_{\\min},\\; s \\cdot h \\cdot \\max(0.1,\\; (\\mathrm{tol}/\\max(\\mathrm{est},\\epsilon))^{1/2})\\big)\\big),$\n  其中安全因子 $s=0.9,$，最小步长 $h_{\\min} = 10^{-16},$，并且 $\\epsilon = 10^{-300}$ 防止除以零。如果拒绝，则保持 $t_n, y_n$ 不变，仅更新 $h \\leftarrow h_{\\mathrm{new}}.$ 通过在每次迭代中裁剪 $h \\le T - t_n$ 来确保最后一步恰好到达最终时间。\n\n- 收敛性评估：计算最终时刻的全局误差为 $\\lVert y_{\\mathrm{num}}(T) - y_{\\mathrm{exact}}(T)\\rVert_{\\infty}.$。\n\n- 自适应下的稳定性评估：在积分过程中，维护一个布尔标志。当且仅当每个被接受的步都同时满足 $\\lambda_1 = -1$ 和 $\\lambda_2 = -1000$ 的显式欧拉方法绝对稳定性条件时，该标志为 $\\mathrm{True}$，该条件根据线性测试方程定义推导出的区域确定。如果有任何被接受的步违反此条件，则将该标志设置为 $\\mathrm{False}$ 并继续积分。\n\n- 终止与保障措施：当 $t \\ge T$ 时终止。使用 $10^7$ 次总试探步数的硬上限以避免无限循环；如果达到该上限，则终止并报告截至该点计算出的指标。\n\n测试套件和所需输入。对于每个测试用例，给定 $(\\mathrm{tol},\\; y_1(0),\\; y_2(0),\\; T,\\; h_0,\\; h_{\\max}),$ 其中 $h_0$ 是初始步长猜测值， $h_{\\max}$ 是最大允许步长。如上所述，使用 $h_{\\min} = 10^{-16}$。测试套件包含以下四个案例：\n\n- 案例 A (短时间范围内中等容差的理想情况): $(\\mathrm{tol}, y_1(0), y_2(0), T, h_0, h_{\\max}) = (10^{-2},\\; 1,\\; 1,\\; 10^{-1},\\; 5\\times 10^{-2},\\; 5\\times 10^{-2}).$\n- 案例 B (初始猜测值在稳定区域外；自适应性应能减小步长并保持稳定): $(5\\times 10^{-2},\\; 1,\\; 1,\\; 10^{-2},\\; 10^{-2},\\; 10^{-2}).$\n- 案例 C (刚性分量初始值极小；局部误差控制可能接受不稳定步长，展示自适应性如何破坏稳定性): $(10^{-1},\\; 1,\\; 10^{-12},\\; 5\\times 10^{-1},\\; 5\\times 10^{-2},\\; 5\\times 10^{-2}).$\n- 案例 D (通过 $h_{\\max}$ 在绝对稳定边界设置硬上限): $(10^{-3},\\; 1,\\; 1,\\; 1,\\; 2\\times 10^{-3},\\; 2\\times 10^{-3}).$\n\n对于每个案例，您的程序必须计算：\n- 最终时刻的全局误差 $E = \\lVert y_{\\mathrm{num}}(T) - y_{\\mathrm{exact}}(T)\\rVert_{\\infty}.$\n- 布尔值 $S$，指示每个被接受的步是否都位于两个特征值的绝对稳定区域内。\n\n最终输出格式。您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，顺序为 $[E_A,\\;S_A,\\;E_B,\\;S_B,\\;E_C,\\;S_C,\\;E_D,\\;S_D],$，其中每个 $E_\\bullet$ 是一个浮点数，每个 $S_\\bullet$ 是一个布尔值。此问题不涉及单位，也没有角度。在输出中，将数字表示为普通的十进制浮点数。", "solution": "该问题要求实现并分析一个用于刚性线性常微分方程（ODE）系统的自适应显式欧拉方法。解决方案将分两部分呈现：首先是稳定性条件的理论推导，其次是所指定的自适应算法的纲要。\n\n该 ODE 系统由 $y'(t) = A y(t)$ 给出，其中 $y(t) \\in \\mathbb{R}^2$ 且 $A = \\mathrm{diag}(-1, -1000)$。因此，矩阵 $A$ 的特征值为 $\\lambda_1 = -1$ 和 $\\lambda_2 = -1000$。这些特征值在量级上的巨大差异表明该系统是刚性的。\n\n为了分析显式欧拉方法的数值稳定性，我们考虑标量线性测试方程 $z'(t) = \\lambda z(t)$，其中 $\\lambda \\in \\mathbb{C}$ 是一个常数。应用显式欧拉方法 $z_{n+1} = z_n + h f(t_n, z_n)$，时间步长为 $h>0$ 且 $f(t,z) = \\lambda z$，得到递推关系：\n$$z_{n+1} = z_n + h \\lambda z_n = (1 + h\\lambda) z_n$$\n项 $g(w) = 1+w$（其中 $w = h\\lambda$）是放大因子。对于一个单步法，要使其绝对稳定，放大因子的模不得超过 1，以确保数值误差不会在连续步骤中被放大。绝对稳定区域是满足 $|g(w)| \\le 1$ 的 $w \\in \\mathbb{C}$ 的集合。\n$|1 + h\\lambda| \\le 1$\n对于给定问题，特征值 $\\lambda_1 = -1$ 和 $\\lambda_2 = -1000$ 是实数且为负。因此，$w = h\\lambda$ 也是实数且为负。稳定性条件简化为：\n$$-1 \\le 1 + h\\lambda \\le 1$$\n这等价于两个不等式：\n1. $1 + h\\lambda \\le 1 \\implies h\\lambda \\le 0$。因为 $h>0$ 且 $\\lambda0$，这个条件总是满足的。\n2. $-1 \\le 1 + h\\lambda \\implies -2 \\le h\\lambda$。\n\n因此，对于一个实数负 $\\lambda$，显式欧拉方法是绝对稳定的，当且仅当 $h\\lambda \\in [-2, 0]$。这对步长 $h$ 施加了一个上界：\n$h \\le -\\frac{2}{\\lambda}$\n对于给定的系统，该条件必须同时对两个特征值成立：\n- 对于 $\\lambda_1 = -1$：$h \\le -\\frac{2}{-1} = 2$。\n- 对于 $\\lambda_2 = -1000$：$h \\le -\\frac{2}{-1000} = 0.002$。\n\n为确保整个系统的稳定性，步长 $h$ 必须满足最严格的条件，即 $h \\le 0.002$。数值实现将跟踪每个被接受的步是否遵守此界限。\n\n自适应算法的构建如下：\n1.  **基本方法**：单步显式欧拉方法，$y_{n+1} = y_n + h f(y_n)$，其中 $f(y) = Ay$。该方法具有一阶精度，意味着其局部截断误差（LTE）为 $\\mathcal{O}(h^2)$。\n\n2.  **局部误差估计**：使用步长加倍法。从当前时刻 $t_n$ 的状态 $y_n$ 出发，计算两个在 $t_n+h$ 处的解的独立近似值：\n    - 一个大小为 $h$ 的单步：$y^{(1)} = y_n + h A y_n$。\n    - 两个大小为 $h/2$ 的连续步：计算一个临时状态 $y_{n+1/2} = y_n + \\frac{h}{2} A y_n$，然后计算 $y^{(2)} = y_{n+1/2} + \\frac{h}{2} A y_{n+1/2}$。\n    $y^{(2)}$ 的局部截断误差小于 $y^{(1)}$ 的。这两个近似值之间的差异提供了局部误差的估计。定义一个标量误差度量为 $\\mathrm{est} = \\lVert y^{(2)} - y^{(1)} \\rVert_{\\infty}$。\n\n3.  **步长控制**：如果误差估计在指定容差范围内，即 $\\mathrm{est} \\le \\mathrm{tol}$，则接受该步。如果接受，则将状态推进到 $y_{n+1} = y^{(2)}$（使用更精确的近似值），时间推进到 $t_{n+1} = t_n + h$。如果拒绝，状态和时间保持为 $y_n$ 和 $t_n$。无论哪种情况，都使用标准的比例-积分（PI）型控制器逻辑为下一次迭代提出新的步长 $h_{\\mathrm{new}}$。一阶方法的局部截断误差与 $h^2$ 成正比。为达到目标误差 $\\mathrm{tol}$，根据当前估计的误差调整新步长：$h_{\\mathrm{new}} \\approx h (\\mathrm{tol}/\\mathrm{est})^{1/2}$。该算法采用特定公式：\n    $h_{\\mathrm{new}} = \\min\\big(h_{\\max},\\; \\max\\big(h_{\\min},\\; s \\cdot h \\cdot \\max(0.1,\\; (\\mathrm{tol}/\\max(\\mathrm{est},\\epsilon))^{1/2})\\big)\\big)$\n    此处，$s=0.9$ 是一个安全因子，$\\epsilon$ 避免除以零，而界限 $h_{\\min}$、$h_{\\max}$ 以及因子 $0.1$ 防止步长发生过大或过小的变化。\n\n4.  **收敛性与稳定性评估**：\n    - **收敛性**：在最终时间 $T$ 计算全局误差为 $E = \\lVert y_{\\mathrm{num}}(T) - y_{\\mathrm{exact}}(T)\\rVert_{\\infty}$，其中 $y_{\\mathrm{exact}}(T) = (y_1(0)e^{-T}, y_2(0)e^{-1000T})$。\n    - **稳定性**：维护一个初始化为 $\\mathrm{True}$ 的布尔标志。如果任何被接受的步长 $h > 0.002$，则将该标志设置为 $\\mathrm{False}$，表示至少有一步违反了由系统最刚性分量决定的绝对稳定性条件。\n\n这种设计使得能够实际检验一致性（局部误差控制）、稳定性（数值解的有界性）和收敛性（最终全局解的准确性）之间的关系，特别是在刚性方程的背景下，局部误差控制并不能保证稳定性。案例 C 旨在说明这种特定的失效模式，即误差控制器可能会接受一个不稳定的步，因为相应的非稳定解分量初始值太小，无法产生显著的局部误差估计。相比之下，案例 D 通过选择 $h_{\\max}$ 来强制实现稳定性，这表明即使步长在稳定范围内，它也可能因精度要求而受到严格限制。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_adaptive_euler(tol, y1_0, y2_0, T, h0, h_max):\n    \"\"\"\n    Implements an adaptive explicit Euler time-stepper for a linear stiff system.\n\n    Args:\n        tol (float): User-specified error tolerance.\n        y1_0 (float): Initial condition for the first component.\n        y2_0 (float): Initial condition for the second component.\n        T (float): Final integration time.\n        h0 (float): Initial step size guess.\n        h_max (float): Maximum allowed step size.\n\n    Returns:\n        tuple: A tuple containing:\n            - global_error (float): The final-time global error.\n            - all_steps_stable (bool): True if every accepted step was stable.\n    \"\"\"\n    # --- Problem Definition and Constants ---\n    A = np.diag([-1.0, -1000.0])\n    y0 = np.array([y1_0, y2_0], dtype=float)\n    \n    # --- Algorithm Parameters ---\n    h_min = 1e-16\n    s = 0.9  # Safety factor\n    epsilon = 1e-300\n    max_steps = 10_000_000\n    \n    # --- Initialization ---\n    t = 0.0\n    y = y0.copy()\n    h = h0\n    total_steps = 0\n    all_steps_stable = True\n    stability_limit = 2.0 / 1000.0  # h = 0.002 for stability\n\n    # --- Main Adaptive Loop ---\n    while t  T and total_steps  max_steps:\n        total_steps += 1\n        \n        # Use a temporary variable for the current step size\n        h_current = h\n        \n        # Clip step to not overshoot final time T\n        if t + h_current > T:\n            h_current = T - t\n            \n        # --- Step Doubling for Error Estimation ---\n        # Right-hand side evaluation\n        f_n = A @ y\n        \n        # One full step of size h_current\n        y_1_step = y + h_current * f_n\n        \n        # Two half-steps of size h_current/2\n        y_half_step_1 = y + (h_current / 2.0) * f_n\n        f_half = A @ y_half_step_1\n        y_2_step = y_half_step_1 + (h_current / 2.0) * f_half\n        \n        # --- Error Estimate and Step Control ---\n        error_est = np.linalg.norm(y_2_step - y_1_step, ord=np.inf)\n        \n        step_accepted = (error_est = tol or h_current = h_min)\n\n        if step_accepted:\n            t += h_current\n            y = y_2_step  # Advance with the more accurate result\n            \n            # Check if the accepted step violates the stability condition\n            if h_current > stability_limit:\n                all_steps_stable = False\n        # On rejection, t and y are not changed.\n        \n        # --- Update Step Size for Next Iteration ---\n        # The new step size is calculated based on the attempted step (h_current)\n        # and the resulting error estimate, as per the specified formula.\n        scale_factor = (tol / max(error_est, epsilon))**0.5\n        h_new = s * h_current * max(0.1, scale_factor)\n        \n        # Enforce step size bounds\n        h = min(h_max, max(h_min, h_new))\n        \n        # Break if the final time is reached\n        if t >= T:\n            break\n            \n    # --- Final Convergence and Stability Assessment ---\n    y_num_T = y\n    y_exact_T = np.array([y0[0] * np.exp(-T), y0[1] * np.exp(-1000.0 * T)])\n    \n    global_error = np.linalg.norm(y_num_T - y_exact_T, ord=np.inf)\n    \n    return global_error, all_steps_stable\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = {\n        'A': (1e-2, 1.0, 1.0, 1e-1, 5e-2, 5e-2),\n        'B': (5e-2, 1.0, 1.0, 1e-2, 1e-2, 1e-2),\n        'C': (1e-1, 1.0, 1e-12, 5e-1, 5e-2, 5e-2),\n        'D': (1e-3, 1.0, 1.0, 1.0, 2e-3, 2e-3),\n    }\n\n    results = []\n    # Process cases in specified order\n    for case_id in ['A', 'B', 'C', 'D']:\n        params = test_cases[case_id]\n        tol, y1_0, y2_0, T, h0, h_max = params\n        \n        error, stable = run_adaptive_euler(tol, y1_0, y2_0, T, h0, h_max)\n        \n        results.append(error)\n        results.append(stable)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3216936"}]}