{"hands_on_practices": [{"introduction": "从基本原理出发推导一个数值方法是理解其设计思想和内在属性的基石。这个练习将引导你根据期望的精度和稳定性要求，推导出一种特定的两步法，并确定其系数。通过分析该方法在求解振荡问题时的绝对稳定性，你将把抽象的理论性质与具体的实际限制（如最大允许步长）联系起来，从而深刻理解理论分析的实践价值。[@problem_id:3254441]", "problem": "考虑形式为 $y'(t)=f(t,y(t))$, $y(t_0)=y_0$ 的初值问题 (IVP)，以及在均匀网格 $t_n=t_0+n h$ 上通过以下形式的公式来近似解的线性多步法：\n$$\ny_{n+1} \\;=\\; a_0\\,y_n \\;+\\; a_1\\,y_{n-1} \\;+\\; h\\bigl(b_{-1}\\,y'_{n+1} \\;+\\; b_0\\,y'_n\\bigr),\n$$\n其中 $h$ 是步长，$y'_k=f(t_k,y_k)$。\n\n推导该族中一个特定的两步法，该方法需满足：\n- 相容且为 $2$ 阶（即对于 $y(t)=1$、$y(t)=t$ 和 $y(t)=t^2$ 是精确的），\n- 零稳定，其特征多项式在 $\\xi=1$ 和 $\\xi=-1$ 处有单根。\n\n按以下步骤进行：\n1. 从线性多步法的定义原理出发，对多项式 $y(t)=1$、$y(t)=t$ 和 $y(t)=t^2$ 强制精确性，以获得高达 $2$ 阶的阶条件，并在特征多项式在 $\\xi=1$ 和 $\\xi=-1$ 处有根的附加零稳定性约束下，确定系数 $a_0$、$a_1$、$b_{-1}$ 和 $b_0$。\n2. 将所得方法应用于线性测试方程 $y'(t)=\\lambda y(t)$（其中 $z=h\\lambda$），分析其绝对稳定性，并推导沿虚轴 $\\{z \\in \\mathbb{C}: z=\\mathrm{i}\\omega h,\\ \\omega\\in\\mathbb{R}\\}$ 的绝对稳定域。\n3. 使用您在虚轴上的稳定性条件，确定对于振荡测试方程 $y'(t)=\\mathrm{i}\\,\\omega\\,y(t)$（其中 $\\omega=7.5\\,\\mathrm{s}^{-1}$），确保绝对稳定性的最大允许时间步长 $h_{\\max}$。将您的答案四舍五入到四位有效数字，并以秒为单位表示最终步长。您的最终答案必须是一个数字。", "solution": "该问题要求推导和分析一个特定的两步线性多步法。该过程分为三个部分：确定该方法的系数，分析其绝对稳定性，以及计算给定振荡问题的最大稳定步长。\n\n该两步法的一般形式为：\n$$\ny_{n+1} \\;=\\; a_0\\,y_n \\;+\\; a_1\\,y_{n-1} \\;+\\; h\\bigl(b_{-1}\\,y'_{n+1} \\;+\\; b_0\\,y'_n\\bigr)\n$$\n为了分析此方法，我们首先通过平移索引 $n \\to n+1$ 将其表示为 $k$ 步线性多步法的标准形式 $\\sum_{j=0}^k \\alpha_j y_{n+j} = h \\sum_{j=0}^k \\beta_j f_{n+j}$。这得到：\n$$\ny_{n+2} \\;=\\; a_0\\,y_{n+1} \\;+\\; a_1\\,y_{n} \\;+\\; h\\bigl(b_{-1}\\,y'_{n+2} \\;+\\; b_0\\,y'_{n+1}\\bigr)\n$$\n整理成标准形式：\n$$\ny_{n+2} - a_0\\,y_{n+1} - a_1\\,y_{n} = h\\bigl(b_{-1}\\,y'_{n+2} + b_0\\,y'_{n+1}\\bigr)\n$$\n由此，我们确定第一和第二特征多项式的系数：\n$\\alpha_2=1$，$\\alpha_1=-a_0$，$\\alpha_0=-a_1$。\n$\\beta_2=b_{-1}$，$\\beta_1=b_0$，所有其他 $\\beta_j=0$。\n\n### 1. 推导方法系数\n\n问题指定了两个约束条件来确定四个系数 $a_0, a_1, b_{-1}, b_0$。\n\n首先，我们使用零稳定性约束。第一特征多项式是 $\\rho(\\xi) = \\sum_{j=0}^{2} \\alpha_j \\xi^j = \\alpha_2 \\xi^2 + \\alpha_1 \\xi + \\alpha_0 = \\xi^2 - a_0 \\xi - a_1$。问题指出 $\\rho(\\xi)$ 的根是 $\\xi_1=1$ 和 $\\xi_2=-1$。具有这些根的多项式必须是 $C(\\xi-1)(\\xi+1) = C(\\xi^2-1)$ 的形式。由于 $\\rho(\\xi)$ 的首项系数是 $\\alpha_2=1$，我们有 $C=1$，因此 $\\rho(\\xi) = \\xi^2 - 1$。\n将其与 $\\rho(\\xi) = \\xi^2 - a_0 \\xi - a_1$ 进行比较，我们推导出系数：\n$-a_0 = 0 \\implies a_0 = 0$\n$-a_1 = -1 \\implies a_1 = 1$\n\n当 $a_0=0$ 和 $a_1=1$ 时，方法简化为：\n$$\ny_{n+1} = y_{n-1} + h\\bigl(b_{-1}\\,y'_{n+1} + b_0\\,y'_n\\bigr)\n$$\n接下来，我们使用阶条件。该方法必须对多项式 $y(t)=1$、$y(t)=t$ 和 $y(t)=t^2$ 精确。我们可以通过将这些函数代入方法的方程中来测试这一点。为简单起见，我们将网格点以 $t_n$ 为中心，使得 $t_{n+1}=t_n+h$ 和 $t_{n-1}=t_n-h$。\n\n- **对于 $y(t)=1$ 的精确性**：\n如果 $y(t)=1$，那么 $y'(t)=0$。公式变为 $1 = 1 + h(b_{-1} \\cdot 0 + b_0 \\cdot 0)$，简化为 $1=1$。对于 $b_{-1}, b_0$ 的任何选择，此条件都满足。这等价于相容性条件 $\\rho(1)=0$，而我们的根的选择已经满足了该条件。\n\n- **对于 $y(t)=t$ 的精确性**：\n如果 $y(t)=t$，那么 $y'(t)=1$。在网格点上的精确值为 $y(t_{n+1})=t_{n+1}$ 和 $y(t_{n-1})=t_{n-1}$。公式变为：\n$t_{n+1} = t_{n-1} + h(b_{-1} \\cdot 1 + b_0 \\cdot 1)$\n$(t_n+h) = (t_n-h) + h(b_{-1} + b_0)$\n$2h = h(b_{-1} + b_0)$\n$b_{-1} + b_0 = 2$\n\n- **对于 $y(t)=t^2$ 的精确性**：\n如果 $y(t)=t^2$，那么 $y'(t)=2t$。精确值为 $y(t_{n+1})=t_{n+1}^2$，$y(t_{n-1})=t_{n-1}^2$，$y'(t_{n+1})=2t_{n+1}$ 和 $y'(t_n)=2t_n$。公式变为：\n$t_{n+1}^2 = t_{n-1}^2 + h\\bigl(b_{-1}(2t_{n+1}) + b_0(2t_n)\\bigr)$\n$(t_n+h)^2 = (t_n-h)^2 + 2h\\bigl(b_{-1}(t_n+h) + b_0 t_n\\bigr)$\n$t_n^2+2t_nh+h^2 = t_n^2-2t_nh+h^2 + 2h\\bigl((b_{-1}+b_0)t_n + b_{-1}h\\bigr)$\n$4t_nh = 2h\\bigl((b_{-1}+b_0)t_n + b_{-1}h\\bigr)$\n$2t_n = (b_{-1}+b_0)t_n + b_{-1}h$\n代入上一步得到的条件 $b_{-1}+b_0=2$：\n$2t_n = 2t_n + b_{-1}h$\n这意味着 $b_{-1}h = 0$。由于 $h \\neq 0$，我们必须有 $b_{-1}=0$。\n\n由 $b_{-1}+b_0=2$ 和 $b_{-1}=0$，我们得到 $b_0=2$。\n确定的系数为 $a_0=0, a_1=1, b_{-1}=0, b_0=2$。所得方法是显式两步中点法：\n$$\ny_{n+1} = y_{n-1} + 2h y'_n\n$$\n\n### 2. 绝对稳定性分析\n\n为了分析绝对稳定性，我们将该方法应用于 Dahlquist 测试方程 $y'(t)=\\lambda y(t)$，其中 $\\lambda \\in \\mathbb{C}$。将 $y'_n = \\lambda y_n$ 代入该方法得到：\n$$\ny_{n+1} = y_{n-1} + 2h\\lambda y_n\n$$\n令 $z=h\\lambda$。递推关系为：\n$$\ny_{n+1} - 2z y_n - y_{n-1} = 0\n$$\n我们寻求 $y_n = \\xi^n$ 形式的解。将此假设代入递推关系中，得到稳定性多项式：\n$$\n\\xi^{n+1} - 2z\\xi^n - \\xi^{n-1} = 0\n$$\n除以 $\\xi^{n-1}$（对于 $\\xi \\neq 0$），我们得到：\n$$\n\\xi^2 - 2z\\xi - 1 = 0\n$$\n对于给定的 $z$，如果该多项式的所有根 $\\xi$ 都满足 $|\\xi| \\le 1$，并且任何满足 $|\\xi|=1$ 的根都是单根，则该方法是绝对稳定的。\n\n我们需要找到沿虚轴的绝对稳定域，其中 $z=i\\alpha$，$\\alpha = \\omega h \\in \\mathbb{R}$。稳定性多项式变为：\n$$\n\\xi^2 - 2i\\alpha\\xi - 1 = 0\n$$\n根由二次公式给出：\n$$\n\\xi = \\frac{2i\\alpha \\pm \\sqrt{(-2i\\alpha)^2 - 4(1)(-1)}}{2} = \\frac{2i\\alpha \\pm \\sqrt{-4\\alpha^2 + 4}}{2} = i\\alpha \\pm \\sqrt{1-\\alpha^2}\n$$\n我们根据 $\\alpha$ 的值分析根的模：\n\n- **情况 1: $|\\alpha|  1$**。在这种情况下，$1-\\alpha^2 > 0$，且 $\\sqrt{1-\\alpha^2}$ 是实数。根为 $\\xi_{1,2} = i\\alpha \\pm \\sqrt{1-\\alpha^2}$。这些复根的模的平方是：\n$|\\xi|^2 = (\\pm\\sqrt{1-\\alpha^2})^2 + (\\alpha)^2 = (1-\\alpha^2) + \\alpha^2 = 1$。\n所以 $|\\xi|=1$。由于 $\\alpha \\neq \\pm 1$，$\\sqrt{1-\\alpha^2}$ 项非零，这意味着两个根是不同的。因此，对于 $|\\alpha|  1$，我们在单位圆上有两个不同的根。该方法是稳定的。\n\n- **情况 2: $|\\alpha|=1$**。在这种情况下，$1-\\alpha^2=0$。根为 $\\xi = i\\alpha$。这是单位圆上的一个重根（$|\\xi|=|i\\alpha|=|\\alpha|=1$）。在单位圆盘边界上具有重根的方法不是绝对稳定的。\n\n- **情况 3: $|\\alpha|>1$**。在这种情况下，$1-\\alpha^2  0$。我们可以写成 $\\sqrt{1-\\alpha^2} = i\\sqrt{\\alpha^2-1}$。根为：\n$\\xi = i\\alpha \\pm i\\sqrt{\\alpha^2-1} = i(\\alpha \\pm \\sqrt{\\alpha^2-1})$。\n根是纯虚数。它们的模是 $|\\xi| = |\\alpha \\pm \\sqrt{\\alpha^2-1}|$。\n一个根的模为 $|\\xi_1| = |\\alpha| + \\sqrt{\\alpha^2-1}$。由于 $|\\alpha|>1$，$\\sqrt{\\alpha^2-1}>0$，所以 $|\\xi_1| > |\\alpha| > 1$。\n由于一个根的模大于 $1$，该方法是不稳定的。\n\n综合这些发现，沿虚轴的绝对稳定域对应于 $|\\alpha|  1$ 的区间。端点被排除在外。该区域是 $\\{z \\in \\mathbb{C}: z=i\\alpha, -1  \\alpha  1 \\}$。\n\n### 3. 计算最大步长 $h_{\\max}$\n\n给定振荡测试方程 $y'(t)=i\\omega y(t)$，其中 $\\omega=7.5\\,\\mathrm{s}^{-1}$。这对应于 $\\lambda = i\\omega$ 的 Dahlquist 测试方程。\n因此，$z = h\\lambda = i\\omega h$。在稳定性分析的符号体系中，$\\alpha = \\omega h$。\n绝对稳定性的条件是 $|\\alpha|  1$，这可以转换为：\n$$\n|\\omega h|  1\n$$\n给定 $\\omega=7.5\\,\\mathrm{s}^{-1}$ 并且步长 $h$ 必须为正，不等式变为：\n$$\n7.5 h  1\n$$\n$$\nh  \\frac{1}{7.5} \\, \\mathrm{s}\n$$\n允许的时间步长集合是区间 $(0, 1/7.5)$。最大允许时间步长 $h_{\\max}$ 是这个集合的上确界。\n$$\nh_{\\max} = \\frac{1}{7.5} \\, \\mathrm{s} = \\frac{1}{15/2} \\, \\mathrm{s} = \\frac{2}{15} \\, \\mathrm{s}\n$$\n为了获得数值，我们计算该分数：\n$$\nh_{\\max} = \\frac{2}{15} \\approx 0.133333... \\, \\mathrm{s}\n$$\n问题要求将答案四舍五入到四位有效数字。\n$$\nh_{\\max} \\approx 0.1333 \\, \\mathrm{s}\n$$", "answer": "$$\\boxed{0.1333}$$", "id": "3254441"}, {"introduction": "隐式方法的强大功能伴随着一个核心挑战：在每个时间步中求解一个（通常是）非线性的代数方程。这个练习聚焦于解决这一关键问题，通过实现两种经典的数值求解器——不动点迭代和牛顿法，来求解隐式Adams-Moulton方法产生的非线性方程。通过对比它们在不同情况下的收敛域，你将亲身体验到不同算法在鲁棒性和效率上的差异，这是将数值方法应用于复杂问题的关键一步。[@problem_id:3254452]", "problem": "考虑初值问题 $y' = f(y)$，其中 $f(y) = y^3 - y$，在一个均匀时间网格 $t_n = t_0 + n h$ 上，步长 $h  0$。从常微分方程的基本恒等式 $y(t_{n+1}) = y(t_n) + \\int_{t_n}^{t_{n+1}} f(y(t)) \\, dt$ 出发，通过使用梯形法则近似该积分，推导二阶单步隐式 Adams–Moulton 方法。这将得到一个关于 $y_{n+1}$ 的隐式标量方程，用 $y_n$ 和 $h$ 表示，该方程必须在每一步中求解。对于右端项 $f(y) = y^3 - y$，此隐式方程是关于 $y_{n+1}$ 的三次多项式。\n\n你的任务是：\n- 从积分形式和梯形近似出发，推导关于 $y_{n+1}$ 的隐式标量方程。不要假设任何预先给定的离散公式；从 $y(t_{n+1}) = y(t_n) + \\int_{t_n}^{t_{n+1}} f(y(t)) \\, dt$ 开始，并进行逻辑推导。\n- 为单步 $n \\to n+1$ 的隐式方程构建两个求解器：\n  1. 基于隐式形式诱导的自然迭代的不动点迭代求解器。\n  2. 应用于从隐式方程派生的残差函数的 Newton 方法求解器。\n- 为每个求解器定义一个收敛准则和一个最大迭代次数上限。收敛的判定条件是：隐式方程的残差小于预设容差；对于不动点迭代，还要求连续迭代值之差小于预设容差。当迭代值变为非有限、超出预设边界，或者 Newton 方法因导数接近于零而无法继续时，应稳健地处理发散情况，将其标记为失败。\n\n为了比较收敛盆，对于下面的每个测试用例：\n- 使用多项式形式计算三次隐式方程的精确实根，并通过从均匀分布在预设范围上的一组初始猜测值 $\\{y^{(0)}\\}$ 运行每个求解器来对收敛盆进行分类。对于每个初始猜测值，运行求解器并使用最近根分配法确定它收敛到哪个根。如果方法未能收敛，则记录为失败。\n- 使用以下参数进行收敛盆扫描：\n  - 初始猜测值网格：在 $[-2, 2]$ 上均匀分布的 $101$ 个点。\n  - 最大迭代次数：$100$。\n  - 成功阈值：两种方法的残差容差均为 $10^{-12}$；不动点迭代的连续迭代值容差为 $10^{-10}$。\n  - 发散边界：如果 $|y|$ 超过 $10^6$，或者 Newton 方法在任何迭代中遇到幅值小于 $10^{-14}$ 的导数，则声明失败。\n\n测试套件（每个项目是一个数对 $(y_n, h)$）：\n- 测试 A (理想情况): $(y_n, h) = (0.2, 0.1)$。\n- 测试 B (中度非线性): $(y_n, h) = (0.8, 1.0)$。\n- 测试 C (强非线性，对不动点迭代有挑战性): $(y_n, h) = (-0.5, 2.0)$。\n\n精确定义最终输出格式如下。对于每个测试用例，令 $r_1  r_2  \\dots  r_k$ 为隐式三次方程的排序后实根。你的程序必须为该测试用例生成一个结构为 $[c^{\\text{fp}}_1, c^{\\text{fp}}_2, \\dots, c^{\\text{fp}}_k, F^{\\text{fp}}, c^{\\text{N}}_1, c^{\\text{N}}_2, \\dots, c^{\\text{N}}_k, F^{\\text{N}}]$ 的列表，其中 $c^{\\text{fp}}_i$ 是在不动点迭代下收敛到根 $r_i$ 的初始猜测值数量，$F^{\\text{fp}}$ 是不动点迭代的失败次数，$c^{\\text{N}}_i$ 是在 Newton 方法下收敛到根 $r_i$ 的初始猜测值数量，$F^{\\text{N}}$ 是 Newton 方法的失败次数。对于所有测试用例，将这些分案例列表聚合到一个顶层列表中，并将该顶层列表打印在一行上，格式为用方括号括起来的逗号分隔列表，不含空格。输出为整数，不涉及物理单位或角度。\n\n你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，不含空格。例如，对于三个测试用例，输出必须如下所示：\n[[a1,a2,...,afp,b1,b2,...,bn],[c1,c2,...,cfp,d1,d2,...,dn],[e1,e2,...,efp,f1,f2,...,fn]]", "solution": "该问题要求对一个初值问题（IVP）的数值方法进行推导和分析。我将首先验证问题陈述。\n\n### 第一步：提取已知条件\n- **IVP**：$y' = f(y)$，其中 $f(y) = y^3 - y$。\n- **时间网格**：$t_n = t_0 + n h$，步长 $h  0$。\n- **基本恒等式**：$y(t_n) + \\int_{t_n}^{t_{n+1}} f(y(t)) \\, dt = y(t_{n+1})$。\n- **数值方法**：二阶隐式 Adams-Moulton 方法，通过对基本恒等式中的积分应用梯形法则推导得出。\n- **求解器**：为得到的隐式方程实现两种求根方法：(1) 不动点迭代法，和 (2) Newton 法。\n- **收敛盆分析参数**：\n    - **初始猜测值**：在区间 $[-2, 2]$ 上均匀分布的 $101$ 个点。\n    - **最大迭代次数**：$100$。\n    - **容差**：两种方法的残差容差均为 $\\epsilon_{\\text{res}} = 10^{-12}$。仅用于不动点迭代的连续迭代值容差为 $\\epsilon_{\\text{diff}} = 10^{-10}$。\n    - **发散标准**：如果迭代值 $y^{(k)}$ 的幅值 $|y^{(k)}|  10^6$、为非有限数，或 Newton 方法中导数的幅值小于 $10^{-14}$，则判定为失败。\n- **测试用例**：给定的 $(y_n, h)$ 数对为 A: $(0.2, 0.1)$，B: $(0.8, 1.0)$，和 C: $(-0.5, 2.0)$。\n- **输出格式**：一个特定的嵌套列表格式，表示对于每个求解器和每个测试用例，收敛到隐式方程的每个实根的初始猜测值数量，以及失败次数。\n\n### 第二步：使用提取的已知条件进行验证\n该问题在科学和数学上是合理的。它涉及常微分方程数值分析中的标准概念：隐式积分器（梯形法则，即二阶 Adams-Moulton 方法）的推导，以及应用标准迭代求根技术（不动点法和 Newton 法）来求解每个时间步产生的非线性代数方程。\n\n所有参数、条件和测试用例都得到了明确的规定。任务是适定的、客观的且自洽的。它提出了一个标准的、非平凡的数值实验，用于比较两种不同求解器的吸引盆，这是科学计算中的一个核心课题。不存在矛盾、事实错误或违反物理或数学原理的情况。\n\n### 第三步：结论与行动\n该问题被判定为 **有效**。将提供一个完整的、论证充分的解答。\n\n### 隐式方程的推导\n\n我们从常微分方程 $y' = f(y)$ 的解 $y(t)$ 的基本精确恒等式开始：\n$$\ny(t_{n+1}) = y(t_n) + \\int_{t_n}^{t_{n+1}} f(y(t)) \\, dt\n$$\n令 $y_n$ 为 $y(t_n)$ 的数值近似。我们寻求 $y_{n+1} \\approx y(t_{n+1})$ 的近似值。该积分使用梯形法则进行近似：\n$$\n\\int_{t_n}^{t_{n+1}} g(t) \\, dt \\approx \\frac{t_{n+1} - t_n}{2} [g(t_n) + g(t_{n+1})]\n$$\n将此应用于我们的积分，其中 $g(t) = f(y(t))$ 且 $h = t_{n+1} - t_n$，我们得到：\n$$\n\\int_{t_n}^{t_{n+1}} f(y(t)) \\, dt \\approx \\frac{h}{2} [f(y(t_n)) + f(y(t_{n+1}))]\n$$\n将此代入基本恒等式的离散版本，得到隐式单步方法：\n$$\ny_{n+1} = y_n + \\frac{h}{2} [f(y_n) + f(y_{n+1})]\n$$\n这就是二阶单步 Adams-Moulton 方法，也称为常微分方程的梯形法则。对于给定的函数 $f(y) = y^3 - y$，方程变为：\n$$\ny_{n+1} = y_n + \\frac{h}{2} [(y_n^3 - y_n) + (y_{n+1}^3 - y_{n+1})]\n$$\n为了将其作为关于 $y_{n+1}$ 的求根问题进行分析，我们重新排列各项以形成一个残差函数 $R(z)$，其中 $z$ 代表未知的 $y_{n+1}$。我们寻求使 $R(z) = 0$ 的 $z$。\n$$\nR(z) = z - y_n - \\frac{h}{2} [f(y_n) + f(z)] = 0\n$$\n代入 $f(z) = z^3 - z$ 得：\n$$\nR(z) = z - y_n - \\frac{h}{2} [(y_n^3 - y_n) + (z^3 - z)] = 0\n$$\n按 $z$ 的幂次对项进行分组，我们得到一个关于 $y_{n+1}$ 的三次多项式方程：\n$$\n-\\frac{h}{2} z^3 + (1 + \\frac{h}{2})z - \\left( y_n + \\frac{h}{2}(y_n^3 - y_n) \\right) = 0\n$$\n这就是在每个时间步必须为 $y_{n+1}$ 求解的隐式标量方程。\n\n### 数值求解器\n\n对于给定的 $y_n$ 和 $h$，我们必须找到三次方程 $R(z) = 0$ 的根。\n\n**1. 不动点迭代法**\n\n隐式方程 $y_{n+1} = y_n + \\frac{h}{2} [f(y_n) + f(y_{n+1})]$ 自然地引出一个不动点迭代格式。令 $z$ 为我们未知的 $y_{n+1}$。我们定义一个迭代函数 $G(z)$ 和格式 $z^{(k+1)} = G(z^{(k)})$：\n$$\nG(z) = y_n + \\frac{h}{2} [f(y_n) + f(z)]\n$$\n对于特定的 $f(y) = y^3 - y$，这变为：\n$$\nz^{(k+1)} = y_n + \\frac{h}{2} [(y_n^3 - y_n) + ((z^{(k)})^3 - z^{(k)})]\n$$\n从初始猜测值 $z^{(0)}$ 开始，我们进行迭代直到达到收敛。收敛由两个条件确定：隐式方程的残差幅值 $|R(z^{(k+1)})|$ 必须小于 $\\epsilon_{\\text{res}} = 10^{-12}$，并且连续迭代值之差的幅值 $|z^{(k+1)} - z^{(k)}|$ 必须小于 $\\epsilon_{\\text{diff}} = 10^{-10}$。\n\n**2. Newton 法**\n\nNewton 法使用以下迭代找到 $R(z) = 0$ 的一个根：\n$$\nz^{(k+1)} = z^{(k)} - \\frac{R(z^{(k)})}{R'(z^{(k)})}\n$$\n我们有残差函数：\n$$\nR(z) = z - y_n - \\frac{h}{2} [f(y_n) + f(z)]\n$$\n它关于 $z$ 的导数是：\n$$\nR'(z) = \\frac{d}{dz} \\left( z - \\frac{h}{2}f(z) - \\text{const} \\right) = 1 - \\frac{h}{2} f'(z)\n$$\n当 $f(y) = y^3 - y$ 时，其导数为 $f'(y) = 3y^2 - 1$。所以，\n$$\nR'(z) = 1 - \\frac{h}{2} (3z^2 - 1)\n$$\n迭代从一个猜测值 $z^{(0)}$ 开始，并持续进行直到残差幅值 $|R(z^{(k+1)})|$ 小于 $\\epsilon_{\\text{res}} = 10^{-12}$。\n\n### 收敛盆分析\n\n对于每个测试用例 $(y_n, h)$，分析过程如下：\n1.  **识别根**：确定三次多项式 $R(z)=0$ 的系数。使用一个稳健的数值多项式求根器找到根。我们筛选出实根，并将其排序为 $r_1  r_2  \\dots  r_k$。对于三次多项式，$k$ 可以是 $1$ 或 $3$。\n2.  **扫描初始猜测值**：在区间 $[-2, 2]$ 上均匀创建一个包含 $101$ 个初始猜测值 $\\{z^{(0)}\\}$ 的网格。\n3.  **运行和分类**：对于网格上的每个 $z^{(0)}$：\n    - 执行不动点求解器。如果它收敛到一个值 $z_{\\text{sol}}$，通过找到最接近 $z_{\\text{sol}}$ 的根 $r_j$ 来对结果进行分类。该根的计数器 $c^{\\text{fp}}_j$ 会增加。如果求解器失败（由于达到最大迭代次数、发散或出现非有限值），失败计数器 $F^{\\text{fp}}$ 会增加。\n    - 执行 Newton 方法求解器。结果以类似方式进行分类，增加相应的根计数器 $c^{\\text{N}}_j$ 或失败计数器 $F^{\\text{N}}$。\n4.  **聚合结果**：对于每个测试用例，将计数收集到一个列表 $[c^{\\text{fp}}_1, \\dots, c^{\\text{fp}}_k, F^{\\text{fp}}, c^{\\text{N}}_1, \\dots, c^{\\text{N}}_k, F^{\\text{N}}]$ 中。然后将这些列表聚合为适用于所有测试用例的最终列表的列表。\n\n此过程为每个求解器的吸引盆大小提供了定量比较。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, solves, and analyzes an implicit ODE solver to determine basins of convergence.\n    \"\"\"\n    # Define test cases: (yn, h) pairs\n    test_cases = [\n        (0.2, 0.1),  # Test A\n        (0.8, 1.0),  # Test B\n        (-0.5, 2.0), # Test C\n    ]\n\n    # Parameters for basin scan\n    initial_guesses = np.linspace(-2.0, 2.0, 101)\n    max_iter = 100\n    res_tol = 1e-12\n    fp_diff_tol = 1e-10\n    div_bound = 1e6\n    newton_deriv_tol = 1e-14\n\n    all_results = []\n\n    for yn, h in test_cases:\n        # Define the functions for this (yn, h)\n        def f(y):\n            return y**3 - y\n\n        def G_fp(y): # Fixed-point iteration function\n            return yn + h / 2.0 * (f(yn) + f(y))\n\n        def R(y): # Residual function R(y) = 0\n            return y - G_fp(y)\n\n        def R_prime(y): # Derivative of the residual function\n            return 1.0 - h / 2.0 * (3.0 * y**2 - 1.0)\n        \n        # Find the real roots of the cubic polynomial R(z) = 0\n        # R(z) = -h/2 * z^3 + (1 + h/2) * z - (yn + h/2 * (yn^3-yn)) = 0\n        poly_coeffs = [\n            -h / 2.0,\n            0.0,\n            1.0 + h / 2.0,\n            -(yn + h / 2.0 * f(yn))\n        ]\n        roots = np.roots(poly_coeffs)\n        real_roots = np.sort(roots[np.isreal(roots)].real)\n        num_roots = len(real_roots)\n\n        # Initialize counters for this test case\n        # [c_fp_1, ..., c_fp_k, F_fp, c_N_1, ..., c_N_k, F_N]\n        counts = np.zeros(2 * num_roots + 2, dtype=int)\n        \n        fp_failure_idx = num_roots\n        newton_start_idx = num_roots + 1\n        newton_failure_idx = 2 * num_roots + 1\n\n        for y0 in initial_guesses:\n            # --- Fixed-Point Iteration Solver ---\n            y = y0\n            converged = False\n            for _ in range(max_iter):\n                y_prev = y\n                y = G_fp(y)\n                if not np.isfinite(y) or np.abs(y) > div_bound:\n                    break\n                \n                res = np.abs(R(y))\n                diff = np.abs(y - y_prev)\n                \n                if res  res_tol and diff  fp_diff_tol:\n                    converged = True\n                    break\n            \n            if converged:\n                root_idx = np.argmin(np.abs(real_roots - y))\n                counts[root_idx] += 1\n            else:\n                counts[fp_failure_idx] += 1\n\n            # --- Newton's Method Solver ---\n            y = y0\n            converged = False\n            for _ in range(max_iter):\n                deriv = R_prime(y)\n                if not np.isfinite(y) or np.abs(deriv)  newton_deriv_tol:\n                    break\n                \n                step = R(y) / deriv\n                y = y - step\n                \n                if not np.isfinite(y) or np.abs(y) > div_bound:\n                    break\n                \n                if np.abs(R(y))  res_tol:\n                    converged = True\n                    break\n\n            if converged:\n                root_idx = np.argmin(np.abs(real_roots - y))\n                counts[newton_start_idx + root_idx] += 1\n            else:\n                counts[newton_failure_idx] += 1\n        \n        all_results.append(counts.tolist())\n\n    # Format output as specified: [[...],[...]]; no spaces\n    output_str = f\"[{','.join(str(sublist).replace(' ', '') for sublist in all_results)}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3254452"}, {"introduction": "在数值计算领域，不存在“放之四海而皆准”的完美方法；选择合适的工具至关重要。本练习通过一个经典案例，揭示了为何专为刚性问题设计的后向差分格式（BDF）在处理纯振荡问题时表现不佳。通过定量分析其放大因子，你将学会如何识别并解释数值计算中产生的相位误差（数值频散）和振幅衰减（数值耗散）等现象，从而培养根据问题特性选择最优化方法的批判性思维。[@problem_id:3254493]", "problem": "考虑由二阶常微分方程 (ODE) $y''(t) + 100\\,y(t) = 0$ 以及初始条件 $y(0) = 1$ 和 $y'(0) = 0$ 给出的初值问题 (IVP)。此 IVP 描述了一个角频率为 $\\omega = 10$ 的非刚性但高度振荡的系统。为应用多步法，首先通过引入状态向量 $Y(t) = \\begin{bmatrix} y(t) \\\\ v(t) \\end{bmatrix}$（其中 $v(t) = y'(t)$）将此 IVP 重写为一阶系统，得到系统 $Y'(t) = A\\,Y(t)$，其中常数矩阵为 $A = \\begin{bmatrix} 0  1 \\\\ -100  0 \\end{bmatrix}$。\n\n从线性多步法的基本定义出发，\n$$\n\\sum_{j=0}^{k} \\alpha_j\\,y_{n-j} = h \\sum_{j=0}^{k} \\beta_j\\,f(t_{n-j}, y_{n-j}),\n$$\n通过围绕 $t_n$ 的 Taylor 级数展开确保二阶精度，并选择 $\\beta_0 = 1$、对于 $j \\geq 1$ 有 $\\beta_j = 0$，来推导二阶向后差分格式 (BDF2)。然后将得到的隐式方法应用于一阶系统 $Y'(t) = A\\,Y(t)$。\n\n使用复数测试方程 $y'(t) = i\\omega\\,y(t)$ 上的标量模态分析，解释为什么向后差分格式 (BDF) 对振荡问题会产生较差的相位精度。你的解释必须基于所推导的多步递推关系的逐模态放大因子分析，说明该方法的步放大因子 $r(\\phi)$（其中 $\\phi = \\omega h$）如何导致每步的数值角度 $\\theta = \\arg(r)$ 偏离精确值 $\\phi$，以及这种偏差如何在多个步长上累积，从而产生显著的总相位滞后。此外，评论其模长 $|r|$ 及其在振荡解的人为阻尼中所起的作用。\n\n实现一个程序，对下面列出的每个测试用例，计算：\n- 在 $N$ 步内累积的相位滞后，\n$$\n\\Delta \\varphi_N = N\\left(\\theta - \\phi\\right),\n$$\n以弧度表示，以及\n- 在 $N$ 步后的振幅比，\n$$\n\\rho_N = |r|^N,\n$$\n该值将数值振幅与精确的单位振幅进行比较。\n\n角度量必须以弧度表示。最终输出必须是浮点数。你的程序不应使用任何外部输入，且仅依赖于提供的测试套件。\n\n使用以下步长 $h$ 和步数 $N$ 的测试套件（固定 $\\omega = 10$）：\n- 测试用例 1 (正常路径，中等步长): $h = 0.05$, $N = 400$。\n- 测试用例 2 (较大步长): $h = 0.10$, $N = 200$。\n- 测试用例 3 (较小步长): $h = 0.02$, $N = 1000$。\n- 测试用例 4 (非常小的步长，接近连续极限的边界情况): $h = 0.005$, $N = 4000$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素本身都是一个形式为 $[\\Delta \\varphi_N, \\rho_N]$ 的双元素列表，按顺序对应上述测试用例。例如，输出格式必须为\n$$\n\\big[ [\\Delta \\varphi_1, \\rho_1], [\\Delta \\varphi_2, \\rho_2], [\\Delta \\varphi_3, \\rho_3], [\\Delta \\varphi_4, \\rho_4] \\big].\n$$", "solution": "问题陈述经评估有效。它在科学上基于常微分方程数值分析的既定理论，特别是关于线性多步法。该问题定义明确，提供了所有必要的定义、方程和参数，以推导所需公式、执行分析和实现指定的计算。语言客观而精确。因此，有必要提供完整的解答。\n\n### BDF2 方法的推导\n\n对于初值问题 $y'(t) = f(t, y(t))$，一个 $k$ 步线性多步法 (LMM) 的一般形式由下式给出：\n$$\n\\sum_{j=0}^{k} \\alpha_j\\,y_{n-j} = h \\sum_{j=0}^{k} \\beta_j\\,f(t_{n-j}, y_{n-j})\n$$\n其中 $y_{m}$ 是 $y(t_m)$ 在时间 $t_m = m h$ 处的数值近似。\n\n向后差分格式 (BDF) 族的特点是设定 $\\beta_0 \\neq 0$ 且对于 $j \\geq 1$ 有 $\\beta_j = 0$。问题指定 $\\beta_0=1$。这使得该方法成为隐式方法，因为未知数 $y_n$ 通过 $f_n = f(t_n, y_n)$ 出现在方程的两边。因此，BDF 的一般形式为：\n$$\n\\sum_{j=0}^{k} \\alpha_j\\,y_{n-j} = h\\,f(t_n, y_n)\n$$\n对于 BDF2 方法，步数 $k=2$。该公式涉及三个时间层级上的近似值：$y_n$, $y_{n-1}$ 和 $y_{n-2}$。\n$$\n\\alpha_0 y_n + \\alpha_1 y_{n-1} + \\alpha_2 y_{n-2} = h f_n\n$$\n为了确定系数 $\\alpha_0, \\alpha_1$ 和 $\\alpha_2$，我们通过最小化局部截断误差来强制精度。局部截断误差 $\\tau_n$ 是将精确解 $y(t)$ 代入公式时得到的残差。我们在 $t_n$ 附近对 $y(t_{n-1})$ 和 $y(t_{n-2})$ 进行 Taylor 级数展开：\n\\begin{align*}\ny(t_{n-1}) = y(t_n - h) = y(t_n) - h y'(t_n) + \\frac{h^2}{2} y''(t_n) - \\frac{h^3}{6} y'''(t_n) + O(h^4) \\\\\ny(t_{n-2}) = y(t_n - 2h) = y(t_n) - 2h y'(t_n) + \\frac{(2h)^2}{2} y''(t_n) - \\frac{(2h)^3}{6} y'''(t_n) + O(h^4) \\\\\n= y(t_n) - 2h y'(t_n) + 2h^2 y''(t_n) - \\frac{4h^3}{3} y'''(t_n) + O(h^4)\n\\end{align*}\n为达到二阶精度，该方法对于最高二次的多项式必须是精确的。这等价于使局部截断误差的 Taylor 展开中的前三项为零。设算子 $\\mathcal{L}_h[y(t)]$ 定义为 $\\mathcal{L}_h[y(t)] = \\alpha_0 y(t_n) + \\alpha_1 y(t_{n-1}) + \\alpha_2 y(t_{n-2}) - h y'(t_n)$。代入 Taylor 级数展开式：\n\\begin{align*}\n\\mathcal{L}_h[y(t)] = \\ \\alpha_0 y(t_n) \\\\\n+ \\alpha_1 \\left( y(t_n) - h y'(t_n) + \\frac{h^2}{2} y''(t_n) - \\dots \\right) \\\\\n+ \\alpha_2 \\left( y(t_n) - 2h y'(t_n) + 2h^2 y''(t_n) - \\dots \\right) \\\\\n- h y'(t_n)\n\\end{align*}\n按 $y(t_n)$ 的导数对各项进行分组：\n\\begin{align*}\n\\mathcal{L}_h[y(t)] = \\ (\\alpha_0 + \\alpha_1 + \\alpha_2) y(t_n) \\\\\n- h (\\alpha_1 + 2\\alpha_2 + 1) y'(t_n) \\\\\n+ h^2 \\left( \\frac{\\alpha_1}{2} + 2\\alpha_2 \\right) y''(t_n) + O(h^3)\n\\end{align*}\n为了使方法达到二阶精度，直到 $O(h^2)$ 的项的系数必须为零。这给出了一个关于 $\\alpha_j$ 系数的线性方程组：\n1. $y(t_n)$ 项: $\\alpha_0 + \\alpha_1 + \\alpha_2 = 0$\n2. $y'(t_n)$ 项: $\\alpha_1 + 2\\alpha_2 = -1$\n3. $y''(t_n)$ 项: $\\frac{\\alpha_1}{2} + 2\\alpha_2 = 0$\n\n从方程 (3) 得，$\\alpha_1 = -4\\alpha_2$。将其代入方程 (2) 得 $-4\\alpha_2 + 2\\alpha_2 = -1$，简化为 $-2\\alpha_2 = -1$，因此 $\\alpha_2 = 1/2$。从而，$\\alpha_1 = -4(1/2) = -2$。最后，从方程 (1) 得，$\\alpha_0 + (-2) + (1/2) = 0$，这给出 $\\alpha_0 = 3/2$。\n\n得到的 BDF2 公式为：\n$$\n\\frac{3}{2} y_n - 2 y_{n-1} + \\frac{1}{2} y_{n-2} = h f(t_n, y_n)\n$$\n\n### 标量模态分析与相位误差\n\n为分析 BDF2 在振荡问题上的性能，我们将其应用于标量复数测试方程 $y'(t) = \\lambda y(t)$，其中对于角频率为 $\\omega$ 的纯振荡系统，$\\lambda = i\\omega$。此处，$f(t_n, y_n) = \\lambda y_n$。BDF2 公式变为：\n$$\n\\frac{3}{2} y_n - 2 y_{n-1} + \\frac{1}{2} y_{n-2} = h \\lambda y_n\n$$\n这是一个线性齐次递推关系。我们寻求形式为 $y_n = r^n$ 的解，其中 $r$ 是将解从一步映射到下一步的放大因子。将此形式代入方程并除以 $r^{n-2}$，得到关于 $r$ 的特征多项式：\n$$\n\\frac{3}{2} r^2 - 2 r + \\frac{1}{2} = h \\lambda r^2\n$$\n令 $z = h\\lambda = i\\omega h$。我们引入 $\\phi = \\omega h$，它是在一个时间步长 $h$ 内的精确相角增量。所以，$z = i\\phi$。重新整理方程得到：\n$$\n\\left(\\frac{3}{2} - z\\right) r^2 - 2 r + \\frac{1}{2} = 0\n$$\n这个二次方程的根决定了该方法的稳定性和精度特性。使用二次公式，根为：\n$$\nr(z) = \\frac{2 \\pm \\sqrt{4 - 4\\left(\\frac{3}{2} - z\\right)\\left(\\frac{1}{2}\\right)}}{2\\left(\\frac{3}{2} - z\\right)} = \\frac{2 \\pm \\sqrt{4 - (3 - 2z)}}{3 - 2z} = \\frac{2 \\pm \\sqrt{1 + 2z}}{3 - 2z}\n$$\n主根，即对于小的 $z$ 近似于 $e^z$ 的根，对应于“$+$”号。因此，BDF2 方法的放大因子为：\n$$\nr(\\phi) = \\frac{2 + \\sqrt{1 + 2i\\phi}}{3 - 2i\\phi}\n$$\n\n$y' = i\\omega y$ 的精确解在每一步通过乘以 $e^{i\\omega h} = e^{i\\phi}$ 来演化。这对应于复平面中角度为 $\\phi$ 的纯旋转，振幅没有变化，因为 $|e^{i\\phi}| = 1$。数值方法通过乘以复数 $r(\\phi)$ 来近似这个操作。\n\n**相位误差（色散）：** 每步的数值相角为 $\\theta = \\arg(r(\\phi))$。精确相角为 $\\phi$。每步的相位误差为 $\\theta - \\phi$。对于 BDF 方法和纯虚数 $z$，可以证明 $\\theta  \\phi$，这意味着数值解的相位进展滞后于真实解。这种累积效应在许多步后会导致显著的总相位滞后 $\\Delta\\varphi_N$：\n$$\n\\Delta \\varphi_N = N(\\theta - \\phi)\n$$\n\n**振幅误差（人为阻尼）：** 数值解的振幅在每一步都乘以 $|r(\\phi)|$。对于一个保守的振荡系统，振幅应保持恒定，即放大因子的模应为 1。然而，BDF 方法是为了其在刚性问题（其中 $\\Re(\\lambda) \\ll 0$）上的强稳定性而设计的，而不是为了保持振荡。它们的绝对稳定区域仅在原点处接触虚轴。对于任何 $\\phi \\neq 0$ 的 $z=i\\phi$，放大因子满足 $|r(\\phi)|  1$。这引入了人为的数值阻尼，导致数值解的振幅呈指数衰减。$N$ 步后数值振幅与精确振幅之比 $\\rho_N$ 为：\n$$\n\\rho_N = |r(\\phi)|^N\n$$\n这解释了为什么 BDF 方法虽然对于刚性问题非常出色，但通常不适合模拟非刚性、无阻尼的振荡系统，因为它们会引入显著的相位滞后和人为阻尼。\n\n### 计算计划\n对每个具有参数 $h$ 和 $N$、固定 $\\omega=10$ 的测试用例：\n1. 计算精确相移步长：$\\phi = \\omega h$。\n2. 定义复变量：$z = i\\phi$。\n3. 计算复放大因子：$r = \\frac{2 + \\sqrt{1 + 2z}}{3 - 2z}$。\n4. 提取数值相角：$\\theta = \\arg(r)$。\n5. 计算总累积相位滞后：$\\Delta\\varphi_N = N(\\theta - \\phi)$。\n6. 计算最终振幅比：$\\rho_N = |r|^N$。\n所有角度计算均以弧度为单位进行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and analyzes the BDF2 method for an oscillatory IVP.\n\n    This function calculates the accumulated phase lag and amplitude ratio\n    for the BDF2 method applied to y''(t) + 100y(t) = 0.\n    \"\"\"\n    \n    # Define the fixed angular frequency from the problem statement.\n    omega = 10.0\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (step_size_h, number_of_steps_N).\n    test_cases = [\n        (0.05, 400),   # Test case 1\n        (0.10, 200),   # Test case 2\n        (0.02, 1000),  # Test case 3\n        (0.005, 4000)  # Test case 4\n    ]\n\n    results = []\n    for h, N in test_cases:\n        # 1. Calculate the exact phase step (phi = omega * h)\n        phi = omega * h\n\n        # 2. Define the complex variable z = i*phi\n        # In Python, 1j is the imaginary unit.\n        z = 1j * phi\n\n        # 3. Compute the complex amplification factor r(z) for BDF2.\n        # The formula for the principal root is r = (2 + sqrt(1 + 2z)) / (3 - 2z).\n        # np.sqrt correctly handles the principal square root of a complex number.\n        r = (2 + np.sqrt(1 + 2 * z)) / (3 - 2 * z)\n\n        # 4. Extract the numerical phase angle theta = arg(r).\n        # np.angle returns the argument of a complex number in radians.\n        theta = np.angle(r)\n        \n        # 5. Compute the total accumulated phase lag after N steps.\n        # This is N * (numerical_angle - exact_angle).\n        accumulated_phase_lag = N * (theta - phi)\n        \n        # 6. Compute the final amplitude ratio after N steps.\n        # This is |r|^N. np.abs() calculates the magnitude of a complex number.\n        amplitude_ratio = np.abs(r)**N\n\n        # Store the pair of results for this test case.\n        results.append([accumulated_phase_lag, amplitude_ratio])\n\n    # Final print statement in the exact required format.\n    # Example format: [[lag1,ratio1],[lag2,ratio2],...]\n    # We use an f-string and a generator expression to build the string.\n    print(f\"[{','.join(f'[{lag},{ratio}]' for lag, ratio in results)}]\")\n\nsolve()\n```", "id": "3254493"}]}