{"hands_on_practices": [{"introduction": "这项练习将引导您从第一性原理出发，在一个简单的双区间案例中推导自然样条和钳制样条的解析表达式。通过亲手解出多项式系数，您将对插值点和边界条件如何共同决定最终的样条曲线形成深刻的机械性理解。这种基础性实践对于揭开样条构造过程的神秘面纱、领会其全局依赖特性至关重要。[@problem_id:3220853]", "problem": "设 $x_0=0$，$x_1=1$ 和 $x_2=2$ 是三个不同的节点，其关联的数据值为 $y_0$、$y_1$ 和 $y_2$。考虑一个二次连续可微的分段三次插值函数 $S(x)$，它由 $[x_0,x_1]$ 上的三次多项式 $S_0(x)$ 和 $[x_1,x_2]$ 上的三次多项式 $S_1(x)$ 两部分组成，满足节点上的标准三次样条插值条件以及在内部节点 $x_1$ 处一阶和二阶导数的连续性。仅从三次样条的定义性质（在每个区间上是分段三次的，在闭区间 $[x_0,x_2]$ 上具有 $C^2$ 连续性，在节点处进行插值，以及边界条件）出发，执行以下操作。\n\n1. 推导在 $[0,2]$ 上的自然三次样条的闭式表达式，即唯一的 $S(x)$ 满足 $S''(x_0)=0$ 和 $S''(x_2)=0$，通过从插值和平滑度条件中显式求解两个三次多项式 $S_0(x)$ 和 $S_1(x)$ 的系数。\n2. 推导在 $[0,2]$ 上的钳位三次样条的闭式表达式，即唯一的 $S(x)$ 满足 $S'(x_0)=m_0$ 和 $S'(x_2)=m_2$，其中 $m_0$ 和 $m_2$ 是给定的端点斜率，同样通过从插值和平滑度条件中显式求解 $S_0(x)$ 和 $S_1(x)$ 的系数。\n3. 使用您推导出的显式公式，通过将其系数表示为 $y_0$、$y_1$、$y_2$ 以及在钳位情况下 $m_0$ 和 $m_2$ 的函数，分析端点约束如何传播到 $[0,1]$ 上的内部分段三次函数 $S_0(x)$。特别地，讨论哪些端点量影响 $S_0(x)$ 的三次项系数。\n\n您最终报告的答案必须是单个解析表达式：自然样条中 $S_0(x)$ 的 $x^3$ 系数减去钳位样条中 $S_0(x)$ 的 $x^3$ 系数，用 $y_0$、$y_1$、$y_2$、$m_0$ 和 $m_2$ 表示。不需要进行数值计算，也不需要四舍五入。不要包含单位。", "solution": "问题是为给定的三个节点集推导和比较自然三次样条和钳位三次样条。推导将从三次样条的基本性质出发。\n\n一个对数据 $(x_i, y_i)$（其中 $i=0, 1, \\dots, n$）进行插值的三次样条 $S(x)$ 是一个分段三次函数。在每个子区间 $[x_i, x_{i+1}]$ 上，$S(x)$ 是一个三次多项式，记作 $S_i(x)$。该样条及其一阶和二阶导数是连续的，即 $S(x) \\in C^2[x_0, x_n]$。\n\n在本问题中，我们有节点 $x_0=0$，$x_1=1$ 和 $x_2=2$，数据值为 $y_0, y_1, y_2$。步长是均匀的：$h_0 = x_1 - x_0 = 1$ 和 $h_1 = x_2 - x_1 = 1$。令 $h=1$。该样条由两段三次函数组成：$[0,1]$ 上的 $S_0(x)$ 和 $[1,2]$ 上的 $S_1(x)$。\n\n由于 $S_i(x)$ 是一个三次多项式，其二阶导数 $S_i''(x)$ 是一个线性函数。由于 $S(x)$ 的 $C^2$ 连续性，节点处的二阶导数 $M_i = S''(x_i)$ 是良定义的。$S_i''(x)$ 的线性性质允许我们将其表示为：\n$$S_i''(x) = M_i \\frac{x_{i+1} - x}{h_i} + M_{i+1} \\frac{x - x_i}{h_i}$$\n将此表达式对 $x$ 积分两次，并施加插值条件 $S_i(x_i) = y_i$ 和 $S_i(x_{i+1}) = y_{i+1}$，得到 $S_i(x)$ 的表达式：\n$$S_i(x) = \\frac{M_i}{6h_i}(x_{i+1}-x)^3 + \\frac{M_{i+1}}{6h_i}(x-x_i)^3 + \\left(\\frac{y_i}{h_i} - \\frac{M_i h_i}{6}\\right)(x_{i+1}-x) + \\left(\\frac{y_{i+1}}{h_i} - \\frac{M_{i+1}h_i}{6}\\right)(x-x_i)$$\n一阶导数的连续性 $S'_{i-1}(x_i) = S'_i(x_i)$ 为未知的矩 $M_i$ 提供了一个线性方程组。对于一个内部节点 $x_i$，此条件导出一般方程：\n$$h_{i-1}M_{i-1} + 2(h_{i-1}+h_i)M_i + h_iM_{i+1} = 6\\left(\\frac{y_{i+1}-y_i}{h_i} - \\frac{y_i-y_{i-1}}{h_{i-1}}\\right)$$\n在我们的具体情况下，有一个内部节点 $x_1=1$。当 $h_0=h_1=1$ 时，对于 $i=1$ 的方程变为：\n$$1 \\cdot M_0 + 2(1+1)M_1 + 1 \\cdot M_2 = 6\\left(\\frac{y_2-y_1}{1} - \\frac{y_1-y_0}{1}\\right)$$\n$$M_0 + 4M_1 + M_2 = 6(y_0 - 2y_1 + y_2)$$\n这个单一方程有三个未知数 $M_0, M_1, M_2$。另外两个方程由边界条件提供。\n\n我们可以将多项式片段 $S_0(x)$ 和 $S_1(x)$ 表示为 $S_i(x) = a_i + b_i(x-x_i) + c_i(x-x_i)^2 + d_i(x-x_i)^3$ 的形式。系数由在 $x_i$ 处的导数给出：\n$a_i = S(x_i) = y_i$\n$b_i = S'(x_i)$\n$c_i = S''(x_i)/2 = M_i/2$\n$d_i = S'''(x_i)/6 = \\frac{M_{i+1}-M_i}{6h_i}$\n一阶导数 $S'(x_i)$ 也可以用矩来表示：$S'_i(x_i) = \\frac{y_{i+1}-y_i}{h_i} - \\frac{h_i}{6}(2M_i+M_{i+1})$。\n\n### 1. 自然三次样条\n自然边界条件是 $S''(x_0)=0$ 和 $S''(x_2)=0$，这意味着 $M_0=0$ 和 $M_2=0$。\n将这些代入连续性方程：\n$$0 + 4M_1 + 0 = 6(y_0 - 2y_1 + y_2)$$\n$$M_1 = \\frac{3}{2}(y_0 - 2y_1 + y_2)$$\n现在我们求解在 $[0,1]$ 上的 $S_{0,nat}(x)$ 的系数：\n$a_0 = y_0$\n$c_0 = M_0/2 = 0$\n$d_0 = \\frac{M_1 - M_0}{6h_0} = \\frac{M_1 - 0}{6(1)} = \\frac{1}{6} \\left(\\frac{3}{2}(y_0 - 2y_1 + y_2)\\right) = \\frac{1}{4}(y_0 - 2y_1 + y_2)$\n$b_0 = S'_0(x_0) = \\frac{y_1-y_0}{h_0} - \\frac{h_0}{6}(2M_0+M_1) = (y_1-y_0) - \\frac{1}{6}(0+M_1) = y_1 - y_0 - \\frac{1}{6}\\left(\\frac{3}{2}(y_0 - 2y_1 + y_2)\\right)$\n$b_0 = y_1 - y_0 - \\frac{1}{4}y_0 + \\frac{1}{2}y_1 - \\frac{1}{4}y_2 = -\\frac{5}{4}y_0 + \\frac{3}{2}y_1 - \\frac{1}{4}y_2$\n因此，自然样条的第一个多项式片段是：\n$$S_{0,nat}(x) = y_0 + \\left(-\\frac{5}{4}y_0 + \\frac{3}{2}y_1 - \\frac{1}{4}y_2\\right) x + \\frac{1}{4}(y_0 - 2y_1 + y_2) x^3$$\n为了完整起见，对于在 $[1,2]$ 上的 $S_{1,nat}(x)$：\n$a_1 = y_1$， $c_1 = M_1/2 = \\frac{3}{4}(y_0 - 2y_1 + y_2)$， $d_1 = \\frac{M_2-M_1}{6h_1} = -\\frac{M_1}{6} = -\\frac{1}{4}(y_0 - 2y_1 + y_2)$，以及 $b_1 = S'_1(x_1) = S'_0(x_1) = b_0 + 2c_0 + 3d_0 = b_0+3d_0 = (-\\frac{5}{4}y_0 + \\frac{3}{2}y_1 - \\frac{1}{4}y_2) + 3(\\frac{1}{4}(y_0 - 2y_1 + y_2)) = -\\frac{1}{2}y_0 + \\frac{1}{2}y_2$。\n\n### 2. 钳位三次样条\n钳位边界条件是 $S'(x_0)=m_0$ 和 $S'(x_2)=m_2$。\n条件 $S'_0(x_0)=m_0$ 给出：\n$m_0 = \\frac{y_1-y_0}{h_0} - \\frac{h_0}{6}(2M_0+M_1) \\implies m_0 = y_1 - y_0 - \\frac{1}{6}(2M_0+M_1)$，这导致：\n$2M_0 + M_1 = 6(y_1 - y_0 - m_0)$\n条件 $S'_1(x_2)=m_2$ 给出：\n$m_2 = S'_1(x_1+h_1) = \\frac{y_2-y_1}{h_1} + \\frac{h_1}{6}(M_1+2M_2) \\implies m_2 = y_2 - y_1 + \\frac{1}{6}(M_1+2M_2)$，这导致：\n$M_1 + 2M_2 = 6(m_2 - y_2 + y_1)$\n我们有一个关于 $M_0, M_1, M_2$ 的三元线性方程组：\n(1) $M_0 + 4M_1 + M_2 = 6(y_0 - 2y_1 + y_2)$\n(2) $2M_0 + M_1 = 6(y_1 - y_0 - m_0)$\n(3) $M_1 + 2M_2 = 6(m_2 - y_2 + y_1)$\n从(2)和(3)中，我们将 $M_0$ 和 $M_2$ 用 $M_1$ 表示：\n$M_0 = 3(y_1-y_0-m_0) - \\frac{1}{2}M_1$\n$M_2 = 3(m_2-y_2+y_1) - \\frac{1}{2}M_1$\n将这些代入(1)：\n$[3(y_1-y_0-m_0) - \\frac{1}{2}M_1] + 4M_1 + [3(m_2-y_2+y_1) - \\frac{1}{2}M_1] = 6(y_0 - 2y_1 + y_2)$\n$3M_1 - 3y_0 + 6y_1 - 3y_2 - 3m_0 + 3m_2 = 6y_0 - 12y_1 + 6y_2$\n$3M_1 = 9y_0 - 18y_1 + 9y_2 + 3m_0 - 3m_2$\n$M_1 = 3(y_0 - 2y_1 + y_2) + m_0 - m_2$\n现在我们求解 $M_0$：\n$M_0 = 3(y_1-y_0-m_0) - \\frac{1}{2}(3(y_0 - 2y_1 + y_2) + m_0 - m_2) = -\\frac{9}{2}y_0 + 6y_1 - \\frac{3}{2}y_2 - \\frac{7}{2}m_0 + \\frac{1}{2}m_2$。\n现在我们求解在 $[0,1]$ 上的 $S_{0,clamped}(x)$ 的系数：\n$a_0 = y_0$\n$b_0 = S'_0(x_0) = m_0$\n$c_0 = M_0/2 = -\\frac{9}{4}y_0 + 3y_1 - \\frac{3}{4}y_2 - \\frac{7}{4}m_0 + \\frac{1}{4}m_2$\n$d_0 = \\frac{M_1 - M_0}{6h_0} = \\frac{1}{6}(M_1 - M_0)$\n$M_1-M_0 = (3y_0-6y_1+3y_2+m_0-m_2) - (-\\frac{9}{2}y_0+6y_1-\\frac{3}{2}y_2-\\frac{7}{2}m_0+\\frac{1}{2}m_2) = \\frac{15}{2}y_0 - 12y_1 + \\frac{9}{2}y_2 + \\frac{9}{2}m_0 - \\frac{3}{2}m_2$\n$d_0 = \\frac{1}{6}\\left(\\frac{15}{2}y_0 - 12y_1 + \\frac{9}{2}y_2 + \\frac{9}{2}m_0 - \\frac{3}{2}m_2\\right) = \\frac{5}{4}y_0 - 2y_1 + \\frac{3}{4}y_2 + \\frac{3}{4}m_0 - \\frac{1}{4}m_2$\n钳位样条的第一个多项式片段是：\n$$S_{0,clamped}(x) = y_0 + m_0 x + \\left(-\\frac{9}{4}y_0 + 3y_1 - \\frac{3}{4}y_2 - \\frac{7}{4}m_0 + \\frac{1}{4}m_2\\right) x^2 + \\left(\\frac{5}{4}y_0 - 2y_1 + \\frac{3}{4}y_2 + \\frac{3}{4}m_0 - \\frac{1}{4}m_2\\right) x^3$$\n\n### 3. 分析与比较\n问题的最后一部分是分析两种情况下 $S_0(x)$ 的三次项系数并计算它们的差值。\n\n$S_{0,nat}(x)$ 的三次项系数是 $d_{0,nat} = \\frac{1}{4}(y_0 - 2y_1 + y_2)$。该系数取决于所有三个数据值 $y_0, y_1, y_2$。来自端点 $x_2=2$ 的信息，即 $y_2$，传播到第一个区间 $[0,1]$ 上的多项式系数中。这说明了样条插值的全局性；任何数据点的改变都会影响整个曲线。\n\n$S_{0,clamped}(x)$ 的三次项系数是 $d_{0,clamped} = \\frac{5}{4}y_0 - 2y_1 + \\frac{3}{4}y_2 + \\frac{3}{4}m_0 - \\frac{1}{4}m_2$。该系数取决于所有数据值 $y_0, y_1, y_2$，以及两个端点斜率约束 $m_0$ 和 $m_2$。影响同样是全局性的：在远端点 $x_2=2$ 处规定的斜率 $m_2$ 会影响初始区间 $[0,1]$ 上样条的三次项。\n\n两个三次项系数之间的差是：\n$$d_{0,nat} - d_{0,clamped} = \\left(\\frac{1}{4}y_0 - \\frac{1}{2}y_1 + \\frac{1}{4}y_2\\right) - \\left(\\frac{5}{4}y_0 - 2y_1 + \\frac{3}{4}y_2 + \\frac{3}{4}m_0 - \\frac{1}{4}m_2\\right)$$\n$$d_{0,nat} - d_{0,clamped} = \\left(\\frac{1}{4} - \\frac{5}{4}\\right)y_0 + \\left(-\\frac{1}{2} + 2\\right)y_1 + \\left(\\frac{1}{4} - \\frac{3}{4}\\right)y_2 - \\frac{3}{4}m_0 + \\frac{1}{4}m_2$$\n$$d_{0,nat} - d_{0,clamped} = -y_0 + \\frac{3}{2}y_1 - \\frac{1}{2}y_2 - \\frac{3}{4}m_0 + \\frac{1}{4}m_2$$", "answer": "$$\\boxed{-y_0 + \\frac{3}{2}y_1 - \\frac{1}{2}y_2 - \\frac{3}{4}m_0 + \\frac{1}{4}m_2}$$", "id": "3220853"}, {"introduction": "理论知识在应对实际挑战时才能焕发生机。这个编程练习将展示自然样条的一个常见缺陷——在端点附近产生不希望的振荡——并说明钳制样条如何能提供更优的拟合效果。通过实现这两种样条并量化“过冲”现象，您将在视觉和数值上掌握边界条件在控制样条行为方面的关键作用，尤其是在处理快速变化的数据时。[@problem_id:3220873]", "problem": "要求您从基本定义出发，实现具有两种不同端点边界条件（自然边界条件和钳位边界条件）的三次样条插值的构建和评估。三次样条被定义为一个由连续子区间上的分段三次多项式组成的函数，它对给定的数据点进行插值，并在整个定义域上是二阶连续可微的。自然边界条件将端点处的二阶导数设置为零，而钳位边界条件则指定端点处的一阶导数。您的任务是：\n- 对于严格递增的横坐标 $\\{x_i\\}_{i=0}^{n-1}$ 和对应的纵坐标 $\\{y_i\\}_{i=0}^{n-1}$，在自然或钳位边界条件下，推导出一个计算唯一三次样条插值的算法公式。推导必须从其定义属性开始：逐段三次、满足插值约束、以及在内部节点处直到二阶导数都连续。\n- 实现两种边界条件的选择。对于钳位边界条件，使用由单边割线斜率给出的端点导数，\n$$\ns_0 \\equiv \\frac{y_1 - y_0}{x_1 - x_0}, \\quad s_{n-1} \\equiv \\frac{y_{n-1} - y_{n-2}}{x_{n-1} - x_{n-2}}.\n$$\n\n为量化反直觉的振荡，将一个子区间 $[x_i,x_{i+1}]$ 上的过冲幅度定义如下。设 $m_i = \\min\\{y_i,y_{i+1}\\}$ 和 $M_i = \\max\\{y_i,y_{i+1}\\}$。设 $S(x)$ 表示样条函数值。在 $[x_i,x_{i+1}]$ 上的过冲幅度为\n$$\n\\Delta_i \\equiv \\max\\Big\\{ \\max_{x \\in [x_i,x_{i+1}]} \\big(S(x) - M_i\\big), \\ \\max_{x \\in [x_i,x_{i+1}]}\\big(m_i - S(x)\\big), \\ 0 \\Big\\}.\n$$\n全局过冲为 $\\Delta \\equiv \\max_i \\Delta_i$。通过在每个子区间 $[x_i,x_{i+1}]$ 上的 1001 个点的均匀网格上评估 $S(x)$ 的值，来数值近似子区间的最大值。\n\n实现一个单一程序，该程序：\n- 为测试套件中的每个数据集构建自然样条和钳位样条（使用上述 $s_0$ 和 $s_{n-1}$）。\n- 为每个样条评估并报告全局过冲 $\\Delta$。\n\n您的实现必须是完全自包含的，并且除了指定的库之外，不得调用外部库。所有计算均在纯数学范畴内（无物理单位）。\n\n测试套件。使用以下数据集，每个数据集均以等长且 $x$ 严格递增的列表 $x$ 和 $y$ 给出：\n\n- 情况 A（左端陡峭，导致自然样条在左端点附近产生较大振荡）：\n  - $x = [\\,0.0,\\,0.5,\\,0.6,\\,2.0\\,]$\n  - $y = [\\,0.0,\\,1.0,\\,10.0,\\,12.0\\,]$\n\n- 情况 B（近线性，理想情况）：\n  - $x = [\\,0.0,\\,1.0,\\,2.0,\\,3.0\\,]$\n  - $y = [\\,0.0,\\,1.0,\\,2.0,\\,3.0\\,]$\n\n- 情况 C（右端陡峭，导致自然样条在右端点附近产生较大振荡）：\n  - $x = [\\,0.0,\\,1.4,\\,1.5,\\,2.0\\,]$\n  - $y = [\\,0.0,\\,2.0,\\,3.0,\\,3.2\\,]$\n\n对于每种情况，计算并返回一对过冲幅度 $\\Delta_{\\text{natural}}$ 和 $\\Delta_{\\text{clamped}}$，作为浮点数。您的程序应生成单行输出，其中包含按以下顺序串联的所有结果，形式为逗号分隔的列表，并用方括号括起来：\n$$\n[\\,\\Delta_{\\text{natural}}^{(A)},\\,\\Delta_{\\text{clamped}}^{(A)},\\,\\Delta_{\\text{natural}}^{(B)},\\,\\Delta_{\\text{clamped}}^{(B)},\\,\\Delta_{\\text{natural}}^{(C)},\\,\\Delta_{\\text{clamped}}^{(C)}\\,].\n$$", "solution": "用户要求对自然和钳位两种边界条件下的三次样条插值进行推导和实现。推导必须从基本定义出发，实现必须计算几个测试用例的全局过冲。\n\n### 三次样条插值的推导\n\n一个对 $n$ 个数据点 $(x_i, y_i)$（其中 $i=0, 1, \\ldots, n-1$ 且横坐标 $x_0  x_1  \\dots  x_{n-1}$ 严格递增）进行插值的三次样条 $S(x)$ 是一个在 $[x_0, x_{n-1}]$ 上定义的分段函数。对于每个子区间 $[x_i, x_{i+1}]$，样条段 $S_i(x)$ 是一个三次多项式。整个样条 $S(x)$ 必须满足以下性质：\n1.  **插值性**：对所有 $i=0, \\ldots, n-1$，有 $S(x_i) = y_i$。\n2.  **连续性**：$S(x)$ 在 $[x_0, x_{n-1}]$ 上是二阶连续可微的，即 $S \\in C^2[x_0, x_{n-1}]$。这意味着在每个内部节点 $x_i$ ($i=1, \\ldots, n-2$) 处，有 $S_{i-1}(x_i) = S_i(x_i)$，$S'_{i-1}(x_i) = S'_i(x_i)$，以及 $S''_{i-1}(x_i) = S''_i(x_i)$。\n\n让我们将样条在节点处的二阶导数定义为 $M_i = S''(x_i)$，其中 $i=0, \\ldots, n-1$。由于每个段 $S_i(x)$ 是一个三次多项式，其二阶导数 $S_i''(x)$ 是一个线性函数。在区间 $[x_i, x_{i+1}]$ 上，$S_i''(x)$ 经过点 $(x_i, M_i)$ 和 $(x_{i+1}, M_{i+1})$。设 $h_i = x_{i+1} - x_i$。线性函数 $S_i''(x)$ 可以用 Lagrange 线性插值公式写出：\n$$\nS_i''(x) = M_i \\frac{x_{i+1} - x}{h_i} + M_{i+1} \\frac{x - x_i}{h_i}\n$$\n对 $S_i''(x)$ 关于 $x$ 积分两次，得到三次多项式 $S_i(x)$ 的一般形式：\n$$\nS_i(x) = M_i \\frac{(x_{i+1} - x)^3}{6h_i} + M_{i+1} \\frac{(x - x_i)^3}{6h_i} + C(x-x_i) + D(x_{i+1}-x)\n$$\n其中 $C$ 和 $D$ 是积分常数，以一种便于应用插值条件的形式表达。\n我们强制执行插值条件 $S_i(x_i) = y_i$ 和 $S_i(x_{i+1}) = y_{i+1}$：\n在 $x=x_i$ 处： $y_i = M_i \\frac{h_i^3}{6h_i} + D h_i \\implies D = \\frac{y_i}{h_i} - \\frac{M_i h_i}{6}$。\n在 $x=x_{i+1}$ 处： $y_{i+1} = M_{i+1} \\frac{h_i^3}{6h_i} + C h_i \\implies C = \\frac{y_{i+1}}{h_i} - \\frac{M_{i+1} h_i}{6}$。\n\n将这些常数代回，我们得到样条段 $S_i(x)$ 的表达式，它用已知的数据点和未知的二阶导数 $M_i$ 表示：\n$$\nS_i(x) = \\frac{M_i}{6h_i}(x_{i+1}-x)^3 + \\frac{M_{i+1}}{6h_i}(x-x_i)^3 + \\left(\\frac{y_{i+1}}{h_i} - \\frac{M_{i+1}h_i}{6}\\right)(x-x_i) + \\left(\\frac{y_i}{h_i} - \\frac{M_i h_i}{6}\\right)(x_{i+1}-x)\n$$\n这个方程定义了在每个子区间 $[x_i, x_{i+1}]$ 上的样条（$i=0, \\ldots, n-2$）。为了找到未知的 $M_i$ 值，我们使用一阶导数的连续性条件 $S'_{i-1}(x_i) = S'_i(x_i)$，在内部节点 $x_i$ 处（$i=1, \\ldots, n-2$）。\n\n首先，我们求导数 $S'_i(x)$：\n$$\nS'_i(x) = -\\frac{M_i}{2h_i}(x_{i+1}-x)^2 + \\frac{M_{i+1}}{2h_i}(x-x_i)^2 + \\left(\\frac{y_{i+1}}{h_i} - \\frac{M_{i+1}h_i}{6}\\right) - \\left(\\frac{y_i}{h_i} - \\frac{M_i h_i}{6}\\right)\n$$\n在节点处计算导数：\n$S'_i(x_i) = -\\frac{M_i h_i}{2} + \\frac{y_{i+1}-y_i}{h_i} - \\frac{M_{i+1}h_i}{6} + \\frac{M_i h_i}{6} = \\frac{y_{i+1}-y_i}{h_i} - \\frac{h_i}{3}M_i - \\frac{h_i}{6}M_{i+1}$。\n$S'_{i-1}(x_i) = \\frac{y_i-y_{i-1}}{h_{i-1}} + \\frac{h_{i-1}}{3}M_i + \\frac{h_{i-1}}{6}M_{i-1}$。\n\n对于 $i=1, \\ldots, n-2$，令 $S'_{i-1}(x_i) = S'_i(x_i)$：\n$$\n\\frac{y_i-y_{i-1}}{h_{i-1}} + \\frac{h_{i-1}}{6}M_{i-1} + \\frac{h_{i-1}}{3}M_i = \\frac{y_{i+1}-y_i}{h_i} - \\frac{h_i}{3}M_i - \\frac{h_i}{6}M_{i+1}\n$$\n重新整理各项，将未知数 $M_{i-1}$、$M_i$ 和 $M_{i+1}$ 组合在一起：\n$$\nh_{i-1}M_{i-1} + 2(h_{i-1} + h_i)M_i + h_iM_{i+1} = 6\\left(\\frac{y_{i+1}-y_i}{h_i} - \\frac{y_i-y_{i-1}}{h_{i-1}}\\right)\n$$\n这个基本关系式为 $n$ 个未知数 $M_0, \\ldots, M_{n-1}$ 提供了 $n-2$ 个线性方程。为了获得唯一解，我们需要两个额外的方程，这两个方程由边界条件提供。\n\n### 边界条件\n\n**1. 自然样条：**\n自然边界条件指定端点处的曲率为零：$S''(x_0)=0$ 和 $S''(x_{n-1})=0$。这直接转化为：\n$$\nM_0 = 0, \\quad M_{n-1} = 0\n$$\n将它们代入通用系统后，剩下 $n-2$ 个方程求解 $n-2$ 个未知数 $M_1, \\ldots, M_{n-2}$。该系统形成一个严格对角占优的三对角矩阵，保证有唯一解。\n\n**2. 钳位样条：**\n钳位边界条件指定了端点处的一阶导数：$S'(x_0)=s_0$ 和 $S'(x_{n-1})=s_{n-1}$。\n使用我们对 $S'_i(x_i)$ 的表达式，令 $i=0$：\n$S'(x_0) = S'_0(x_0) = \\frac{y_1-y_0}{h_0} - \\frac{h_0}{3}M_0 - \\frac{h_0}{6}M_1 = s_0$。\n整理后得到第一个边界方程：\n$$\n2h_0M_0 + h_0M_1 = 6\\left(\\frac{y_1-y_0}{h_0} - s_0\\right)\n$$\n对于在 $x_{n-1}$ 处的条件，我们计算 $S'_{n-2}(x_{n-1})=s_{n-1}$：\n$S'_{n-2}(x_{n-1}) = \\frac{y_{n-1}-y_{n-2}}{h_{n-2}} + \\frac{h_{n-2}}{6}M_{n-2} + \\frac{h_{n-2}}{3}M_{n-1} = s_{n-1}$。\n整理后得到第二个边界方程：\n$$\nh_{n-2}M_{n-2} + 2h_{n-2}M_{n-1} = 6\\left(s_{n-1} - \\frac{y_{n-1}-y_{n-2}}{h_{n-2}}\\right)\n$$\n问题为 $s_0$ 和 $s_{n-1}$ 指定了特定的值：\n$s_0 = \\frac{y_1 - y_0}{x_1 - x_0} = \\frac{y_1 - y_0}{h_0}$\n$s_{n-1} = \\frac{y_{n-1} - y_{n-2}}{x_{n-1} - x_{n-2}} = \\frac{y_{n-1} - y_{n-2}}{h_{n-2}}$\n根据这些选择，两个边界方程的右侧都变为零：\n$2h_0M_0 + h_0M_1 = 0 \\implies 2M_0 + M_1 = 0$。\n$h_{n-2}M_{n-2} + 2h_{n-2}M_{n-1} = 0 \\implies M_{n-2} + 2M_{n-1} = 0$。\n这两个方程与 $n-2$ 个内部方程相结合，构成了一个求解未知数 $M_0, \\ldots, M_{n-1}$ 的完整的 $n \\times n$ 三对角系统。该系统也是严格对角占优的，并有唯一解。\n\n### 过冲计算\n\n在子区间 $[x_i, x_{i+1}]$ 上的过冲幅度定义为：\n$$\n\\Delta_i = \\max\\left\\{ \\max_{x \\in [x_i,x_{i+1}]} \\left(S(x) - \\max\\{y_i,y_{i+1}\\}\\right), \\ \\max_{x \\in [x_i,x_{i+1}]}\\left(\\min\\{y_i,y_{i+1}\\} - S(x)\\right), \\ 0 \\right\\}\n$$\n全局过冲是所有子区间的最大值，$\\Delta = \\max_i \\Delta_i$。在计算上，通过在一个跨越 $[x_i, x_{i+1}]$ 的、包含 1001 个点的精细均匀网格上评估样条 $S(x)$，来近似每个子区间上的最大值。此过程量化了样条振荡超出其所插值的数据点范围的程度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_tdma(lower, main, upper, d):\n    \"\"\"\n    Solves a tridiagonal system of equations Ax=d using the Thomas algorithm.\n\n    Args:\n        lower (np.ndarray): The lower diagonal of A (length n-1).\n        main (np.ndarray): The main diagonal of A (length n).\n        upper (np.ndarray): The upper diagonal of A (length n-1).\n        d (np.ndarray): The right-hand side vector (length n).\n\n    Returns:\n        np.ndarray: The solution vector x.\n    \"\"\"\n    n = len(main)\n    c_p = np.zeros(n)\n    d_p = np.zeros(n)\n\n    # Forward elimination\n    c_p[0] = upper[0] / main[0]\n    d_p[0] = d[0] / main[0]\n    for i in range(1, n):\n        denom = main[i] - lower[i-1] * c_p[i-1]\n        if i  n - 1:\n            c_p[i] = upper[i] / denom\n        d_p[i] = (d[i] - lower[i-1] * d_p[i-1]) / denom\n\n    # Backward substitution\n    x = np.zeros(n)\n    x[n-1] = d_p[n-1]\n    for i in range(n-2, -1, -1):\n        x[i] = d_p[i] - c_p[i] * x[i+1]\n    return x\n\nclass CubicSpline:\n    \"\"\"\n    A class for computing and evaluating cubic spline interpolants.\n    \"\"\"\n    def __init__(self, x, y, bc_type='natural'):\n        self.x = np.asarray(x, dtype=float)\n        self.y = np.asarray(y, dtype=float)\n        self.n = len(x)\n        \n        if self.n  2:\n            raise ValueError(\"Need at least 2 points for interpolation.\")\n        \n        self.h = self.x[1:] - self.x[:-1]\n        \n        if np.any(self.h = 0):\n            raise ValueError(\"x coordinates must be strictly increasing.\")\n\n        if bc_type == 'natural':\n            self._compute_natural_spline()\n        elif bc_type == 'clamped':\n            self._compute_clamped_spline()\n        else:\n            raise ValueError(f\"Unsupported boundary condition type: {bc_type}\")\n\n    def _compute_natural_spline(self):\n        \"\"\"Computes the second derivatives M for a natural spline.\"\"\"\n        if self.n == 2:\n            self.M = np.zeros(self.n)\n            return\n\n        N = self.n - 2  # Size of the internal system\n        \n        A_lower = self.h[1:-1]\n        A_main = 2 * (self.h[:-1] + self.h[1:])\n        A_upper = self.h[1:-1]\n\n        delta = (self.y[1:] - self.y[:-1]) / self.h\n        b_rhs = 6 * (delta[1:] - delta[:-1])\n\n        M_internal = solve_tdma(A_lower, A_main, A_upper, b_rhs)\n        \n        self.M = np.zeros(self.n)\n        self.M[1:-1] = M_internal\n\n    def _compute_clamped_spline(self):\n        \"\"\"Computes the second derivatives M for a clamped spline with specified derivatives.\"\"\"\n        if self.n == 2:\n            # Linear interpolation for 2 points, second derivatives are zero\n            self.M = np.zeros(self.n)\n            return\n\n        N = self.n\n        A_lower = np.zeros(N - 1)\n        A_main = np.zeros(N)\n        A_upper = np.zeros(N - 1)\n        b_rhs = np.zeros(N)\n\n        # First row from boundary condition: 2*M_0 + M_1 = 0\n        A_main[0] = 2.0\n        A_upper[0] = 1.0\n        b_rhs[0] = 0.0\n\n        # Internal rows\n        delta = (self.y[1:] - self.y[:-1]) / self.h\n        internal_rhs = 6 * (delta[1:] - delta[:-1])\n        b_rhs[1:-1] = internal_rhs\n\n        A_main[1:-1] = 2 * (self.h[:-1] + self.h[1:])\n        A_lower[:-1] = self.h[:-1]\n        A_upper[1:] = self.h[1:]\n\n        # Last row from boundary condition: M_{n-2} + 2*M_{n-1} = 0\n        A_lower[-1] = 1.0\n        A_main[-1] = 2.0\n        b_rhs[-1] = 0.0\n        \n        self.M = solve_tdma(A_lower, A_main, A_upper, b_rhs)\n\n    def evaluate(self, x_eval):\n        \"\"\"Evaluates the spline at given points.\"\"\"\n        x_eval = np.asarray(x_eval)\n        indices = np.searchsorted(self.x, x_eval, side='right') - 1\n        indices = np.clip(indices, 0, self.n - 2)\n\n        xi = self.x[indices]\n        xi1 = self.x[indices + 1]\n        yi = self.y[indices]\n        yi1 = self.y[indices + 1]\n        hi = self.h[indices]\n        Mi = self.M[indices]\n        Mi1 = self.M[indices + 1]\n\n        t = x_eval - xi\n        t_comp = xi1 - x_eval\n        \n        term1 = (Mi / (6 * hi)) * (t_comp**3)\n        term2 = (Mi1 / (6 * hi)) * (t**3)\n        term3 = (yi1 / hi - Mi1 * hi / 6) * t\n        term4 = (yi / hi - Mi * hi / 6) * t_comp\n        \n        return term1 + term2 + term3 + term4\n\ndef calculate_overshoot(spline, n_grid=1001):\n    \"\"\"Calculates the global overshoot magnitude for a given spline.\"\"\"\n    max_overshoot = 0.0\n    for i in range(spline.n - 1):\n        xi, xi1 = spline.x[i], spline.x[i+1]\n        yi, yi1 = spline.y[i], spline.y[i+1]\n        \n        m_i = min(yi, yi1)\n        M_i = max(yi, yi1)\n        \n        x_grid = np.linspace(xi, xi1, n_grid)\n        y_grid = spline.evaluate(x_grid)\n        \n        overshoot = np.max(y_grid) - M_i\n        undershoot = m_i - np.min(y_grid)\n        \n        interval_max_deviation = max(overshoot, undershoot, 0.0)\n        \n        if interval_max_deviation > max_overshoot:\n            max_overshoot = interval_max_deviation\n            \n    return max_overshoot\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case A (left-end steepening)\n        {'x': [0.0, 0.5, 0.6, 2.0], 'y': [0.0, 1.0, 10.0, 12.0]},\n        # Case B (near-linear)\n        {'x': [0.0, 1.0, 2.0, 3.0], 'y': [0.0, 1.0, 2.0, 3.0]},\n        # Case C (right-end steepening)\n        {'x': [0.0, 1.4, 1.5, 2.0], 'y': [0.0, 2.0, 3.0, 3.2]}\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        x = case['x']\n        y = case['y']\n        \n        # Natural Spline\n        natural_spline = CubicSpline(x, y, bc_type='natural')\n        delta_natural = calculate_overshoot(natural_spline)\n        results.append(delta_natural)\n        \n        # Clamped Spline\n        clamped_spline = CubicSpline(x, y, bc_type='clamped')\n        delta_clamped = calculate_overshoot(clamped_spline)\n        results.append(delta_clamped)\n\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3220873"}, {"introduction": "在现实世界的应用中，构造钳制样条所需的精确端点导数往往是未知的。这项高级实践将探讨一个实用的解决方案：使用有限差分公式来近似这些导数。您将比较简单的一阶近似与更精确的二阶近似对整体插值误差的影响，从而了解端点信息的质量如何传播并影响样条在整个域上的精度。[@problem_id:3220799]", "problem": "考虑区间 $[a,b]$ 上的均匀节点 $\\{x_i\\}_{i=0}^n$，其步长为 $h = \\frac{b-a}{n}$，采样值为 $f_i = f(x_i)$。在 $[a,b]$ 上的一个夹持三次样条 $S(x)$ 定义为这样一个函数：它在每个子区间 $[x_i,x_{i+1}]$ 上是一个三次多项式，且 $S(x)$、$S'(x)$ 和 $S''(x)$ 在 $[a,b]$ 上连续，并满足边界导数约束 $S'(x_0) = d_0$ 和 $S'(x_n) = d_n$。夹持三次样条由这些性质和数据 $\\{(x_i,f_i)\\}_{i=0}^n$ 完全确定。\n\n当精确的端点导数 $f'(x_0)$ 和 $f'(x_n)$ 未知时，可以使用单边有限差分 (FD) 公式从 $\\{f_i\\}$ 中近似得到它们。对于均匀步长和足够光滑的函数 $f$，使用以下标准的单边有限差分近似：\n- 一阶前向/后向公式 (阶数为 $\\mathcal{O}(h)$):\n$$\nd_0^{(1)} = \\frac{f(x_1) - f(x_0)}{h}, \\quad d_n^{(1)} = \\frac{f(x_n) - f(x_{n-1})}{h}.\n$$\n- 二阶前向/后向公式 (阶数为 $\\mathcal{O}(h^2)$):\n$$\nd_0^{(2)} = \\frac{-3 f(x_0) + 4 f(x_1) - f(x_2)}{2 h}, \\quad d_n^{(2)} = \\frac{3 f(x_n) - 4 f(x_{n-1}) + f(x_{n-2})}{2 h}.\n$$\n\n您的任务是仅使用数据 $\\{f_i\\}$ 在均匀网格上实现夹持三次样条插值，并通过上述定义的 $\\mathcal{O}(h)$ 或 $\\mathcal{O}(h^2)$ 阶单边有限差分近似来设置端点的夹持斜率。然后，对于每种情况，通过在区间的开内部 $[x_0+h,\\,x_n-h]$ 使用密集的采样点集，计算最大绝对误差 $\\max_{x \\in [x_0+h,\\,x_n-h]} |S(x) - f(x)|$ 来量化内部插值误差。在 $[x_0+h,\\,x_n-h]$ 上精确使用 $1001$ 个等距的内部采样点。\n\n在一个程序中实现样条和误差计算。程序必须生成单行输出，包含所有给定测试用例的结果。结果是一个用方括号括起来的逗号分隔列表，其中每个测试用例贡献一个包含三个浮点数的列表：\n- 使用 $\\mathcal{O}(h^2)$ 端点斜率时的最大内部绝对误差，\n- 使用 $\\mathcal{O}(h)$ 端点斜率时的最大内部绝对误差，\n- 两个误差之比（$\\mathcal{O}(h)$ 误差除以 $\\mathcal{O}(h^2)$ 误差）。\n\n角度单位（若适用）必须是弧度。不涉及任何物理单位。\n\n测试套件：\n- 案例 $\\mathbf{A}$ (理想情况，三角函数): $[0,\\pi]$ 上的 $f(x) = \\sin(x)$，其中 $n=10$。使用弧度制的 $\\pi$。\n- 案例 $\\mathbf{B}$ (指数增长): $[0,1]$ 上的 $f(x) = e^{x}$，其中 $n=8$。\n- 案例 $\\mathbf{C}$ (多项式特殊情况): $[0,1]$ 上的 $f(x) = x^3$，其中 $n=8$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例按上述顺序报告为包含三个浮点数的列表。例如，三个用例的有效输出格式为：\n$$\n\\big[ [E^{(2)}_A, E^{(1)}_A, R_A], [E^{(2)}_B, E^{(1)}_B, R_B], [E^{(2)}_C, E^{(1)}_C, R_C] \\big],\n$$\n其中 $E^{(2)}$ 和 $E^{(1)}$ 分别表示使用 $\\mathcal{O}(h^2)$ 和 $\\mathcal{O}(h)$ 端点斜率时的最大内部绝对误差，而 $R$ 是它们的比值。", "solution": "用户提出的问题已被分析并验证为数值方法领域中一个适定的、有科学依据的任务。以下是一个完整且附带推理的解决方案。\n\n### 原理与方法\n\n目标是为一个给定函数 $f(x)$ 在均匀网格上构造一个夹持三次样条插值函数 $S(x)$，并分析当所需的端点导数使用不同精度阶的有限差分公式近似时产生的插值误差。\n\n插值数据点 $\\{(x_i, f_i)\\}_{i=0}^n$ 的三次样条 $S(x)$ 是一个分段三次函数。在每个子区间 $[x_i, x_{i+1}]$ 上，$S(x)$ 是一个我们记为 $S_i(x)$ 的三次多项式。其定义性质为 $S(x)$ 及其一阶导数 $S'(x)$ 和二阶导数 $S''(x)$ 在整个区间 $[a,b]$ 上是连续的。\n\n令 $h = x_{i+1} - x_i$ 为均匀步长，并令 $M_i = S''(x_i)$ 为节点上未知的二阶导数。在 $[x_i, x_{i+1}]$ 上的三次多项式 $S_i(x)$ 可以用 $M_i$ 和 $M_{i+1}$ 表示：\n$$\nS_i(x) = M_i \\frac{(x_{i+1}-x)^3}{6h} + M_{i+1} \\frac{(x-x_i)^3}{6h} + \\left(\\frac{f_{i+1}}{h} - \\frac{M_{i+1}h}{6}\\right)(x-x_i) + \\left(\\frac{f_i}{h} - \\frac{M_i h}{6}\\right)(x_{i+1}-x)\n$$\n这种形式自动满足插值条件 $S_i(x_i) = f_i$ 和 $S_i(x_{i+1}) = f_{i+1}$。\n\n在内部节点 $x_i$ (其中 $i=1, 2, \\dots, n-1$) 处的一阶导数连续性条件 $S'_{i-1}(x_i) = S'_{i}(x_i)$，导出以下关于未知数 $M_i$ 的线性方程组：\n$$\nM_{i-1} + 4M_i + M_{i+1} = \\frac{6}{h^2}(f_{i-1} - 2f_i + f_{i+1}) \\quad \\text{for } i=1, \\dots, n-1\n$$\n这为 $n+1$ 个未知数 $(M_0, M_1, \\dots, M_n)$ 提供了 $n-1$ 个方程。\n\n剩下的两个方程从夹持边界条件 $S'(x_0) = d_0$ 和 $S'(x_n) = d_n$ 导出。通过对 $S_0(x)$ 和 $S_{n-1}(x)$ 的表达式进行微分并在端点处求值，我们得到：\n$$\nS'(x_0) = \\frac{f_1-f_0}{h} - \\frac{h}{3}M_0 - \\frac{h}{6}M_1 = d_0 \\implies 2M_0 + M_1 = \\frac{6}{h}\\left(\\frac{f_1 - f_0}{h} - d_0\\right)\n$$\n$$\nS'(x_n) = \\frac{f_n - f_{n-1}}{h} + \\frac{h}{6}M_{n-1} + \\frac{h}{3}M_n = d_n \\implies M_{n-1} + 2M_n = \\frac{6}{h}\\left(d_n - \\frac{f_n - f_{n-1}}{h}\\right)\n$$\n\n这些方程补全了方程组，可以写成矩阵形式 $A\\mathbf{M} = \\mathbf{b}$，其中 $\\mathbf{M} = [M_0, M_1, \\dots, M_n]^T$:\n$$\n\\begin{pmatrix}\n2   1   0   \\cdots   0 \\\\\n1   4   1   \\cdots   0 \\\\\n0   1   4   \\ddots   \\vdots \\\\\n\\vdots   \\ddots   \\ddots   4   1 \\\\\n0   \\cdots   0   1   2\n\\end{pmatrix}\n\\begin{pmatrix} M_0 \\\\ M_1 \\\\ M_2 \\\\ \\vdots \\\\ M_n \\end{pmatrix}\n=\n\\begin{pmatrix} \\frac{6}{h}(\\frac{f_1-f_0}{h} - d_0) \\\\ \\frac{6}{h^2}(f_0 - 2f_1 + f_2) \\\\ \\vdots \\\\ \\frac{6}{h^2}(f_{n-2} - 2f_{n-1} + f_n) \\\\ \\frac{6}{h}(d_n - \\frac{f_n-f_{n-1}}{h}) \\end{pmatrix}\n$$\n矩阵 $A$ 是一个严格对角占优的三对角矩阵，这保证了 $\\mathbf{M}$ 存在唯一解，并且可以被高效地求解。\n\n问题要求使用两种不同的单边有限差分公式从数据 $\\{f_i\\}$ 中近似端点导数 $d_0$ 和 $d_n$：\n1.  **$\\mathcal{O}(h)$ 阶近似**： $d_0^{(1)} = \\frac{f_1 - f_0}{h}$, $d_n^{(1)} = \\frac{f_n - f_{n-1}}{h}$。\n2.  **$\\mathcal{O}(h^2)$ 阶近似**： $d_0^{(2)} = \\frac{-3f_0 + 4f_1 - f_2}{2h}$, $d_n^{(2)} = \\frac{3f_n - 4f_{n-1} + f_{n-2}}{2h}$。\n\n对于每个测试用例，我们将求解系统 $A\\mathbf{M} = \\mathbf{b}$ 两次：一次使用 $(d_0^{(2)}, d_n^{(2)})$，另一次使用 $(d_0^{(1)}, d_n^{(1)})$。这将得到两组不同的二阶导数 $\\mathbf{M}^{(2)}$ 和 $\\mathbf{M}^{(1)}$，从而得到两个不同的样条插值函数 $S^{(2)}(x)$ 和 $S^{(1)}(x)$。\n\n一旦向量 $\\mathbf{M}$ 确定，样条就完全定义了。为了在任意点 $x \\in [x_i, x_{i+1}]$ 处对样条进行求值，我们可以使用以下从泰勒定理导出的多项式形式：\n$$\nS_i(x) = a_i(x-x_i)^3 + b_i(x-x_i)^2 + c_i(x-x_i) + d_i\n$$\n其中系数由以下公式给出：\n$d_i = f_i$\n$c_i = \\frac{f_{i+1}-f_i}{h} - \\frac{h}{6}(M_{i+1} + 2M_i)$\n$b_i = \\frac{M_i}{2}$\n$a_i = \\frac{M_{i+1}-M_i}{6h}$\n\n最后一步是量化每个样条的插值误差。误差的度量方式为样条与真实函数在定义域内部 $[x_1, x_{n-1}]$ 的最大绝对差 $\\max|S(x) - f(x)|$。这是通过在该区间内 $1001$ 个等距点上对误差进行采样并找出最大值来计算的。\n\n每个测试用例的算法如下：\n1.  生成网格 $\\{x_i\\}$ 和采样值 $\\{f_i\\}$。\n2.  对于每个近似阶 ($\\mathcal{O}(h^2)$ 和 $\\mathcal{O}(h)$):\n    a. 使用相应的有限差分公式计算端点导数 $d_0$ 和 $d_n$。\n    b.构造矩阵 $A$和右端向量 $\\mathbf{b}$。\n    c. 求解线性系统 $A\\mathbf{M}=\\mathbf{b}$ 以找到二阶导数值 $M_i$。\n    d. 在 $[x_1, x_{n-1}]$ 中定义一个包含 $1001$ 个点的密集评估网格。\n    e. 对于评估网格中的每个点，确定其所在的子区间 $[x_i, x_{i+1}]$，计算样条系数 $(a_i, b_i, c_i, d_i)$，并评估 $S(x)$ 的值。\n    f. 计算评估网格上样条值与真实函数值之间的最大绝对误差。\n3.  计算 $\\mathcal{O}(h)$ 误差与 $\\mathcal{O}(h^2)$ 误差之比。\n4.  报告 $\\mathcal{O}(h^2)$ 误差、$\\mathcal{O}(h)$ 误差以及它们的比值。\n\n此过程将应用于所有指定的测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_spline_error(func, a, b, n, order):\n    \"\"\"\n    Computes the clamped cubic spline and its maximum interior error.\n    \n    Args:\n        func (callable): The true function f(x).\n        a (float): The start of the interval.\n        b (float): The end of the interval.\n        n (int): The number of subintervals.\n        order (int): The order of the finite difference approximation for endpoint slopes (1 or 2).\n\n    Returns:\n        float: The maximum absolute error on the interior interval [x_1, x_{n-1}].\n    \"\"\"\n    # 1. Set up the grid and function values\n    x = np.linspace(a, b, n + 1)\n    y = func(x)\n    h = (b - a) / n\n\n    # 2. Calculate endpoint derivatives using finite difference formulas\n    if order == 1:\n        # O(h) one-sided formulas\n        d0 = (y[1] - y[0]) / h\n        dn = (y[n] - y[n-1]) / h\n    elif order == 2:\n        # O(h^2) one-sided formulas\n        if n  2:\n            raise ValueError(\"n must be at least 2 for O(h^2) formula.\")\n        d0 = (-3 * y[0] + 4 * y[1] - y[2]) / (2 * h)\n        dn = (3 * y[n] - 4 * y[n-1] + y[n-2]) / (2 * h)\n    else:\n        raise ValueError(\"Order must be 1 or 2.\")\n\n    # 3. Set up the linear system A*M = B for the second derivatives M\n    # The matrix A is an (n+1)x(n+1) tridiagonal matrix\n    A = np.zeros((n + 1, n + 1))\n    A += np.diag(np.full(n + 1, 4))\n    A += np.diag(np.ones(n), k=1)\n    A += np.diag(np.ones(n), k=-1)\n    A[0, 0] = 2\n    A[n, n] = 2\n    A[0, 1] = 1\n    A[n, n-1] = 1\n\n    # The right-hand side vector B\n    B = np.zeros(n + 1)\n    B[0] = 6 / h * ((y[1] - y[0]) / h - d0)\n    B[n] = 6 / h * (dn - (y[n] - y[n-1]) / h)\n    for i in range(1, n):\n        B[i] = 6 / h**2 * (y[i-1] - 2 * y[i] + y[i+1])\n\n    # 4. Solve for the second derivatives M\n    M = np.linalg.solve(A, B)\n\n    # 5. Evaluate the spline and the error on a dense grid\n    # The error is computed on the interior of the interval [x_1, x_{n-1}]\n    num_eval_points = 1001\n    x_eval = np.linspace(x[1], x[n-1], num_eval_points)\n    y_true = func(x_eval)\n\n    # Vectorized spline evaluation\n    # Find the interval index for each evaluation point\n    indices = np.searchsorted(x, x_eval, side='right') - 1\n    # Handle case where evaluation point is exactly the last node\n    indices[indices == n] = n - 1\n\n    # Get parameters for each evaluation point's interval\n    x_i = x[indices]\n    f_i = y[indices]\n    f_i1 = y[indices + 1]\n    M_i = M[indices]\n    M_i1 = M[indices + 1]\n    \n    # Calculate coefficients of the cubic polynomial S_i(t) = at^3 + bt^2 + ct + d, where t = x - x_i\n    # Note: These are coefficients for the polynomial based at x_i, not normalized coefficients.\n    t = x_eval - x_i\n    \n    d_coeffs = f_i\n    c_coeffs = (f_i1 - f_i)/h - h/6 * (M_i1 + 2 * M_i)\n    b_coeffs = M_i / 2\n    a_coeffs = (M_i1 - M_i) / (6 * h)\n\n    y_spline = a_coeffs * t**3 + b_coeffs * t**2 + c_coeffs * t + d_coeffs\n    \n    # Calculate the maximum absolute error\n    max_error = np.max(np.abs(y_true - y_spline))\n    \n    return max_error\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {'func': np.sin, 'a': 0, 'b': np.pi, 'n': 10},\n        {'func': np.exp, 'a': 0, 'b': 1, 'n': 8},\n        {'func': lambda x: x**3, 'a': 0, 'b': 1, 'n': 8},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        func, a, b, n = case['func'], case['a'], case['b'], case['n']\n        \n        # Calculate error for O(h^2) derivative approximation\n        error_h2 = compute_spline_error(func, a, b, n, order=2)\n        \n        # Calculate error for O(h) derivative approximation\n        error_h1 = compute_spline_error(func, a, b, n, order=1)\n        \n        # Calculate the ratio\n        ratio = error_h1 / error_h2 if error_h2 != 0 else float('inf')\n        \n        all_results.append([error_h2, error_h1, ratio])\n\n    # Format the final output string as specified\n    # The default str() for a list creates the '[val1, val2, ...]' format\n    # with spaces after commas, which matches the problem description's example.\n    results_str = ','.join(map(str, all_results))\n    \n    # Print the final output in the exact required format.\n    print(f\"[{results_str}]\")\n\nsolve()\n```", "id": "3220799"}]}