{"hands_on_practices": [{"introduction": "理论与实践之间常常存在差距，现实世界的数据很少像教科书中的例子那样干净。这个练习将引导您解决一个在实际应用中至关重要的问题：处理具有混合单位的特征，这可能导致数值不稳定的最小二乘问题。您将亲手实现一个基于 Householder 变换的 QR 分解求解器，并探索不同的列缩放策略如何影响解的准确性和数值稳定性 [@problem_id:3275437]。", "problem": "要求您设计并实现一个程序，使用数值稳定的正交分解方法，解决在特征列存在混合单位的情况下，超定的线性最小二乘问题。该程序必须明确地构造并使用基于 Householder 的分解来对一个行数多于列数的实矩阵进行因式分解，然后求解相关的上三角系统，而不是依赖黑盒求解器。\n\n从以下基本原理出发：对于一个实矩阵 $A \\in \\mathbb{R}^{m \\times n}$（其中 $m \\ge n$）和一个实向量 $b \\in \\mathbb{R}^m$，最小二乘问题旨在最小化欧几里得范数的平方 $\\lVert A x - b \\rVert_2$；正交变换保持欧几里得范数不变；任何实矩阵 $A$ 都允许通过连续的正交变换进行分解，这些变换将次对角线元素置零以产生一个上三角因子。您的实现必须利用这些事实来设计算法。\n\n您必须明确处理混合单位问题。假设 $A$ 的一列以公里为单位，而另一列以米为单位。为了获得对系数 $x$ 一致的物理解释，您应构造一个对角缩放矩阵 $D_{\\text{phys}}$，将以公里为单位的列转换为米（例如，将公里列乘以 $1000$）。此外，为了在不考虑物理单位的情况下检验数值稳定性，您应构造一个列归一化缩放矩阵 $S_{\\text{norm}}$，将每列缩放至单位 $\\ell_2$ 范数。给定一个缩放后的矩阵 $A S$ 和一个最小化 $\\lVert A S y - b \\rVert_2$ 的解 $y$，在原始混合单位坐标系中的系数向量为 $x = S y$。您的程序必须在三种场景下评估求得的解：未缩放的混合单位、物理单位一致和列归一化单位，并比较不同场景下的残差范数和条件数，同时将系数映射回相同的原始坐标系以保证可解释性。\n\n实现以下内容：\n- 对给定的 $A$ 构造一个基于 Householder 的正交分解，将相关的正交变换应用于 $b$ 以获得 $Q^\\top b$，然后求解所得的上三角系统 $R x = Q^\\top b$ 以得到最小二乘解 $x$，其中 $A = Q R$，$Q$ 为正交矩阵，$R$ 为上三角矩阵。\n- 对于物理缩放，通过将每个公里列乘以 $1000$ 以将其转换为米来定义 $D_{\\text{phys}}$，并保持米列和偏置列不变。对于归一化缩放，定义 $S_{\\text{norm}} = \\operatorname{diag}(1/\\lVert a_1 \\rVert_2, \\dots, 1/\\lVert a_n \\rVert_2)$，其中 $a_j$ 是 $A$ 的第 $j$ 列。在原始混合单位坐标系中，映射后的系数为 $x_{\\text{phys}} = D_{\\text{phys}} y_{\\text{phys}}$ 和 $x_{\\text{norm}} = S_{\\text{norm}} y_{\\text{norm}}$。\n- 计算三种场景下的残差范数 $\\lVert A x_{\\text{mix}} - b \\rVert_2$、$\\lVert A x_{\\text{phys}} - b \\rVert_2$ 和 $\\lVert A x_{\\text{norm}} - b \\rVert_2$。同时计算 2-范数条件数 $\\kappa_2(A)$、$\\kappa_2(A D_{\\text{phys}})$ 和 $\\kappa_2(A S_{\\text{norm}})$。最后，计算相对差异 $\\delta_{\\text{phys}} = \\lVert x_{\\text{mix}} - x_{\\text{phys}} \\rVert_2 / \\lVert x_{\\text{mix}} \\rVert_2$ 和 $\\delta_{\\text{norm}} = \\lVert x_{\\text{mix}} - x_{\\text{norm}} \\rVert_2 / \\lVert x_{\\text{mix}} \\rVert_2$。\n\n所有输出必须是无量纲的十进制数。将所有报告的浮点数四舍五入到 $6$ 位小数。\n\n测试套件。使用以下三个测试用例。在每个用例中，矩阵 $A$ 有三列：第一列以米为单位，第二列以公里为单位，第三列是全为1的偏置列。向量 $b$ 已明确给出。\n\n测试用例 $1$（中等条件数，混合单位）：\n$$\nA_1 = \\begin{bmatrix}\n120  0.2  1 \\\\\n340  0.5  1 \\\\\n560  0.9  1 \\\\\n780  1.3  1 \\\\\n910  1.6  1 \\\\\n1050  2.0  1\n\\end{bmatrix},\\quad\nb_1 = \\begin{bmatrix}\n356 \\\\\n778 \\\\\n1325 \\\\\n1859 \\\\\n2253.5 \\\\\n2751.5\n\\end{bmatrix}.\n$$\n\n测试用例 $2$（列间尺度差异极大）：\n$$\nA_2 = \\begin{bmatrix}\n0.4  150  1 \\\\\n0.6  300  1 \\\\\n0.9  450  1 \\\\\n1.2  600  1 \\\\\n1.5  750  1\n\\end{bmatrix},\\quad\nb_2 = \\begin{bmatrix}\n75999.6 \\\\\n151002.9 \\\\\n225999.35 \\\\\n301002.8 \\\\\n376002.25\n\\end{bmatrix}.\n$$\n\n测试用例 $3$（米和公里列接近共线性，但为满秩）：\n$$\nA_3 = \\begin{bmatrix}\n960  0.95  1 \\\\\n1035  1.05  1 \\\\\n1220  1.20  1 \\\\\n1295  1.30  1 \\\\\n1500  1.50  1 \\\\\n1790  1.80  1 \\\\\n2105  2.10  1\n\\end{bmatrix},\\quad\nb_3 = \\begin{bmatrix}\n396 \\\\\n401 \\\\\n480 \\\\\n486 \\\\\n549 \\\\\n634 \\\\\n731\n\\end{bmatrix}.\n$$\n\n对于每个测试用例 $i \\in \\{1,2,3\\}$，令 $A_i$ 和 $b_i$ 如上所述。您的程序必须对每个 $i$ 执行以下操作：\n- 在混合单位下，通过基于 Householder 的正交分解求解最小二乘问题，以获得 $x_{\\text{mix}}$。\n- 在物理缩放后，对 $A_i D_{\\text{phys}}$ 求解最小二乘问题以获得 $y_{\\text{phys}}$，然后映射 $x_{\\text{phys}} = D_{\\text{phys}} y_{\\text{phys}}$。\n- 在列归一化后，对 $A_i S_{\\text{norm}}$ 求解最小二乘问题以获得 $y_{\\text{norm}}$，然后映射 $x_{\\text{norm}} = S_{\\text{norm}} y_{\\text{norm}}$。\n- 按以下顺序计算并报告该用例的八个浮点数\n$$\n\\big[\n\\lVert A_i x_{\\text{mix}} - b_i \\rVert_2,\\;\n\\lVert A_i x_{\\text{phys}} - b_i \\rVert_2,\\;\n\\lVert A_i x_{\\text{norm}} - b_i \\rVert_2,\\;\n\\kappa_2(A_i),\\;\n\\kappa_2(A_i D_{\\text{phys}}),\\;\n\\kappa_2(A_i S_{\\text{norm}}),\\;\n\\delta_{\\text{phys}},\\;\n\\delta_{\\text{norm}}\n\\big].\n$$\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内没有空格。顶层列表应包含三个对应于三个测试用例的子列表，每个子列表按指定顺序包含八个四舍五入后的浮点数。例如，输出必须类似于\n$$\n\\big[\\,[f_{11},f_{12},\\dots,f_{18}],\\,[f_{21},f_{22},\\dots,f_{28}],\\,[f_{31},f_{32},\\dots,f_{38}]\\,\\big],\n$$\n其中每个 $f_{jk}$ 是一个格式化为 $6$ 位小数的十进制数。不得打印任何其他文本。", "solution": "该问题要求设计并实现一个数值稳定的求解器，用于解决超定线性最小二乘问题 $\\min_{x} \\lVert A x - b \\rVert_2$，其中 $A \\in \\mathbb{R}^{m \\times n}$，$m \\ge n$，$b \\in \\mathbb{R}^m$。指定的方法是使用 Householder 变换的 QR 分解。问题的关键在于研究通过缩放对矩阵 $A$ 进行预处理的效果，以解决由混合物理单位和差异巨大的列范数引起的问题。\n\n基本原理是欧几里得范数在正交变换下是不变的。如果 $Q \\in \\mathbb{R}^{m \\times m}$ 是一个正交矩阵（即 $Q^\\top Q = I$），那么对于任何向量 $z \\in \\mathbb{R}^m$，都有 $\\lVert Q z \\rVert_2 = \\lVert z \\rVert_2$。我们可以利用这个性质，将矩阵 $A$ 分解为一个正交矩阵 $Q$ 和一个上三角矩阵 $R$ 的乘积，即 $A=QR$。然后，最小二乘问题可以重写为：\n$$\n\\lVert A x - b \\rVert_2^2 = \\lVert Q R x - b \\rVert_2^2 = \\lVert Q^\\top (Q R x - b) \\rVert_2^2 = \\lVert R x - Q^\\top b \\rVert_2^2\n$$\n矩阵 $R \\in \\mathbb{R}^{m \\times n}$ 具有上三角结构。由于 $m \\ge n$，它可以被分块为：\n$$\nR = \\begin{bmatrix} R_1 \\\\ 0 \\end{bmatrix}, \\quad \\text{其中 } R_1 \\in \\mathbb{R}^{n \\times n} \\text{ 是上三角矩阵。}\n$$\n类似地，变换后的向量 $Q^\\top b$ 可以被分块为：\n$$\nQ^\\top b = \\begin{bmatrix} c_1 \\\\ c_2 \\end{bmatrix}, \\quad \\text{其中 } c_1 \\in \\mathbb{R}^n \\text{ 且 } c_2 \\in \\mathbb{R}^{m-n}.\n$$\n因此，最小化问题转化为：\n$$\n\\min_{x} \\left\\lVert \\begin{bmatrix} R_1 \\\\ 0 \\end{bmatrix} x - \\begin{bmatrix} c_1 \\\\ c_2 \\end{bmatrix} \\right\\rVert_2^2 = \\min_{x} \\left( \\lVert R_1 x - c_1 \\rVert_2^2 + \\lVert c_2 \\rVert_2^2 \\right)\n$$\n项 $\\lVert c_2 \\rVert_2^2$ 与 $x$ 无关。当 $\\lVert R_1 x - c_1 \\rVert_2^2 = 0$ 时，表达式达到最小值。假设 $A$ 的列是线性无关的，那么 $A$ 是满秩的，且 $R_1$ 是可逆的。因此，唯一的最小二乘解 $x$ 可通过求解方形上三角系统得到：\n$$\nR_1 x = c_1\n$$\n这个系统可以使用回代法高效求解。最终残差的范数平方为 $\\lVert A x - b \\rVert_2^2 = \\lVert c_2 \\rVert_2^2$。\n\nQR 分解是通过一系列 Householder 变换构造的。Householder 变换是关于一个超平面的反射，对于一个非零向量 $v \\in \\mathbb{R}^k$，它由矩阵 $H = I - 2 \\frac{v v^\\top}{v^\\top v}$ 表示。对于任意向量 $z \\in \\mathbb{R}^k$，我们可以选择一个向量 $v$，使得 $H z$ 是标准基向量 $e_1 = [1, 0, \\dots, 0]^\\top$ 的倍数。具体来说，向量 $v$ 选择为 $v = z + \\alpha e_1$，其中 $\\alpha = \\text{sgn}(z_1) \\lVert z \\rVert_2$。选择这个符号是为了避免当 $z$ 与 $e_1$ 近乎平行时发生灾难性抵消。\n\n对 $A$ 进行 QR 分解的算法是逐列进行的。对于从 $1$ 到 $n$ 的每一列 $j$：\n$1$. 考虑由第 $j$ 列从对角线元素开始及其下方元素组成的向量 $z$，即 $A_{j:m, j}$。\n$2$. 构造相应的 Householder 向量 $v_j$ 和变换矩阵 $H_j$。\n$3$. 将此变换应用于 $A$ 从第 $j$ 行到第 $m$ 行、从第 $j$ 列到第 $n$ 列的子矩阵。这会在第 $j$ 列的对角线下方引入零。同样的变换也必须应用于向量 $b$ 的相应元素。\n经过 $n$ 步后，矩阵 $A$ 被转换为上三角矩阵 $R$，向量 $b$ 被转换为 $Q^\\top b$。形式上，$R = H_n \\cdots H_2 H_1 A$ 且 $Q^\\top b = H_n \\cdots H_2 H_1 b$，其中 $Q = H_1 H_2 \\cdots H_n$。该算法不需要显式地构造 $Q$。\n\n该问题研究了基于矩阵缩放的三种场景：\n$1$. **混合单位**：使用给定的矩阵 $A$ 求解问题。解为 $x_{\\text{mix}}$。\n$2$. **物理缩放**：矩阵 $A$ 与一个对角缩放矩阵 $D_{\\text{phys}}$ 相乘。对于给定的问题，第二列以公里为单位，而其他列以米为单位或是无量纲的。为了将公里转换为米，我们设置 $D_{\\text{phys}} = \\text{diag}(1, 1000, 1)$。然后对缩放后的矩阵 $\\hat{A}_{\\text{phys}} = A D_{\\text{phys}}$ 求解最小二乘问题，得到解 $y_{\\text{phys}}$。原始未缩放坐标系中的解通过 $x_{\\text{phys}} = D_{\\text{phys}} y_{\\text{phys}}$ 恢复。\n$3$. **列归一化**：矩阵 $A$ 与一个对角矩阵 $S_{\\text{norm}} = \\text{diag}(1/\\lVert a_1 \\rVert_2, \\dots, 1/\\lVert a_n \\rVert_2)$ 相乘，其中 $a_j$ 是 $A$ 的第 $j$ 列。这种缩放使得新矩阵 $\\hat{A}_{\\text{norm}} = A S_{\\text{norm}}$ 的每一列都具有单位 $\\ell_2$ 范数。然后对 $\\hat{A}_{\\text{norm}}$ 求解最小二乘问题，得到 $y_{\\text{norm}}$，原始解通过 $x_{\\text{norm}} = S_{\\text{norm}} y_{\\text{norm}}$ 恢复。\n\n该分析需要为每种场景计算几个指标：\n- **残差范数**：$\\lVert A x - b \\rVert_2$，其中 $x \\in \\{x_{\\text{mix}}, x_{\\text{phys}}, x_{\\text{norm}}\\}$。在精确算术中，这些值是相同的，但在浮点算术中，由于底层问题的数值稳定性不同，它们可能会有差异。\n- **条件数**：2-范数条件数 $\\kappa_2(M) = \\sigma_{\\max}(M) / \\sigma_{\\min}(M)$，衡量了解对数据扰动的敏感度。我们计算 $\\kappa_2(A)$、$\\kappa_2(A D_{\\text{phys}})$ 和 $\\kappa_2(A S_{\\text{norm}})$。较低的条件数通常意味着问题在数值上更稳定。\n- **相对差异**：$\\delta_{\\text{phys}} = \\lVert x_{\\text{mix}} - x_{\\text{phys}} \\rVert_2 / \\lVert x_{\\text{mix}} \\rVert_2$ 和 $\\delta_{\\text{norm}} = \\lVert x_{\\text{mix}} - x_{\\text{norm}} \\rVert_2 / \\lVert x_{\\text{mix}} \\rVert_2$。这些值量化了从缩放矩阵获得的解与未缩放矩阵获得的解相比的数值偏差。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the least squares problems for the given test cases.\n    \"\"\"\n\n    def householder_qr_solve(A, b):\n        \"\"\"\n        Solves the least squares problem min ||Ax - b||_2 using Householder QR factorization.\n\n        Args:\n            A (np.ndarray): The matrix A (m x n).\n            b (np.ndarray): The vector b (m,).\n\n        Returns:\n            np.ndarray: The solution vector x (n,).\n        \"\"\"\n        m, n = A.shape\n        R = A.copy()\n        c = b.copy().flatten()\n\n        for j in range(n):\n            # Extract the j-th column from the diagonal down\n            z = R[j:, j].copy()\n            \n            # Compute the Householder vector v\n            # Use `np.copysign` to handle the sign of 0 correctly\n            norm_z = np.linalg.norm(z)\n            alpha = -np.copysign(norm_z, z[0]) if norm_z != 0 else 0.0\n            \n            v = z.copy()\n            v[0] -= alpha\n            \n            norm_v = np.linalg.norm(v)\n            if norm_v  1e-12: # Check to avoid division by zero\n                v = v / norm_v  # Normalize v to a unit vector u\n\n                # Apply reflection to the remaining submatrix of R\n                sub_matrix_R = R[j:, j:]\n                R[j:, j:] -= 2 * np.outer(v, v.T @ sub_matrix_R)\n\n                # Apply reflection to the corresponding part of b\n                sub_c = c[j:]\n                c[j:] -= 2 * v * (v.T @ sub_c)\n\n        # Extract the upper triangular matrix R1 and the vector c1\n        R1 = R[:n, :n]\n        c1 = c[:n]\n\n        # Solve the upper triangular system R1 @ x = c1 using back substitution\n        x = np.zeros(n)\n        for i in range(n - 1, -1, -1):\n            s = c1[i] - np.dot(R1[i, i + 1:], x[i + 1:])\n            x[i] = s / R1[i, i]\n            \n        return x\n\n    test_cases = [\n        (\n            np.array([\n                [120., 0.2, 1.], [340., 0.5, 1.], [560., 0.9, 1.],\n                [780., 1.3, 1.], [910., 1.6, 1.], [1050., 2.0, 1.]\n            ]),\n            np.array([356., 778., 1325., 1859., 2253.5, 2751.5])\n        ),\n        (\n            np.array([\n                [0.4, 150., 1.], [0.6, 300., 1.], [0.9, 450., 1.],\n                [1.2, 600., 1.], [1.5, 750., 1.]\n            ]),\n            np.array([75999.6, 151002.9, 225999.35, 301002.8, 376002.25])\n        ),\n        (\n            np.array([\n                [960., 0.95, 1.], [1035., 1.05, 1.], [1220., 1.20, 1.],\n                [1295., 1.30, 1.], [1500., 1.50, 1.], [1790., 1.80, 1.],\n                [2105., 2.10, 1.]\n            ]),\n            np.array([396., 401., 480., 486., 549., 634., 731.])\n        )\n    ]\n\n    all_results = []\n    \n    for A, b in test_cases:\n        # Scenario 1: Mixed Units (unscaled)\n        x_mix = householder_qr_solve(A, b)\n        res_norm_mix = np.linalg.norm(A @ x_mix - b.flatten())\n        cond_mix = np.linalg.cond(A, 2)\n\n        # Scenario 2: Physical Scaling\n        # Column 2 is in km, convert to m by multiplying by 1000.\n        D_phys = np.diag([1.0, 1000.0, 1.0])\n        A_phys = A @ D_phys\n        y_phys = householder_qr_solve(A_phys, b)\n        x_phys = D_phys @ y_phys\n        res_norm_phys = np.linalg.norm(A @ x_phys - b.flatten())\n        cond_phys = np.linalg.cond(A_phys, 2)\n        \n        # Scenario 3: Column Normalization Scaling\n        col_norms = np.linalg.norm(A, axis=0)\n        S_norm = np.diag(1.0 / col_norms)\n        A_norm = A @ S_norm\n        y_norm = householder_qr_solve(A_norm, b)\n        x_norm = S_norm @ y_norm\n        res_norm_norm = np.linalg.norm(A @ x_norm - b.flatten())\n        cond_norm = np.linalg.cond(A_norm, 2)\n\n        # Relative differences in solutions\n        delta_phys = np.linalg.norm(x_mix - x_phys) / np.linalg.norm(x_mix)\n        delta_norm = np.linalg.norm(x_mix - x_norm) / np.linalg.norm(x_mix)\n\n        case_results = [\n            res_norm_mix, res_norm_phys, res_norm_norm,\n            cond_mix, cond_phys, cond_norm,\n            delta_phys, delta_norm\n        ]\n        \n        all_results.append(case_results)\n\n    # Format the final output string exactly as specified.\n    formatted_cases = []\n    for case_res in all_results:\n        formatted_floats = [f\"{val:.6f}\" for val in case_res]\n        formatted_cases.append(f\"[{','.join(formatted_floats)}]\")\n    \n    print(f\"[{','.join(formatted_cases)}]\")\n\nsolve()\n```", "id": "3275437"}, {"introduction": "许多科学和工程领域的优化问题都带有约束条件，我们寻找的解不仅要最小化某个目标函数，还必须满足一组线性等式。该练习将向您展示如何将 QR 分解作为强大工具，来解决这类等式约束最小二乘 (ECLS) 问题。通过实现零空间方法，您将学习如何利用 QR 分解将一个复杂的约束问题转化为一个更小、无约束的等价问题，从而加深对解空间几何结构的理解 [@problem_id:3275428]。", "problem": "要求您设计并实现一个完整的、可运行的程序，该程序通过正交分解和零空间约化方法求解等式约束最小二乘（LS）问题。问题是在线性约束 $C x = d$ 下，最小化欧几里得范数目标 $\\|A x - b\\|_2$。程序必须基于以下基本原理构建一个符合规范的数值解法：\n- 欧几里得范数 $\\|y\\|_2 = \\sqrt{y^\\top y}$ 的定义。\n- 最小二乘（LS）的定义：对于给定的矩阵 $A$ 和向量 $b$，找到使 $\\|A x - b\\|_2$ 最小化的 $x$。\n- 满足 $Q^\\top Q = I$ 的正交矩阵 $Q$ 的定义。\n- 实数矩阵 $M$ 存在 QR 分解，可将其分解为一个正交因子和一个上三角因子；将此分解应用于约束矩阵的转置 $C^\\top$，以导出其列空间及其正交补的标准正交基。\n- $C$ 的零空间的概念，记为 $\\mathcal{N}(C) = \\{x : C x = 0\\}$。\n\n您的程序必须：\n- 基于 $C^\\top$ 的 QR 分解获得标准正交分解，构建一个算法解。利用该分解对可行集 $C x = d$ 进行参数化，将带约束的 LS 问题简化为变量数更少的无约束 LS 问题，并再次使用 QR 分解求解该简化问题。\n- 避免使用任何临时公式；设计必须基于上述基本定义和性质。\n\n输入在程序内部固定；不要从文件或标准输入中读取。程序必须能直接运行，并产生单行输出。\n\n测试套件：\n实现求解器，并在以下四个测试用例上进行评估。每个用例都明确定义了 $A$、$b$、$C$ 和 $d$。\n\n案例 1（理想情况，超定 $A$，部分约束）：\n设 $A \\in \\mathbb{R}^{6 \\times 4}$、$b \\in \\mathbb{R}^{6}$、$C \\in \\mathbb{R}^{2 \\times 4}$、$d \\in \\mathbb{R}^{2}$ 为\n$$\nA =\n\\begin{bmatrix}\n2  -1  0  0 \\\\\n1  3  -2  1 \\\\\n0  1  4  -1 \\\\\n3  0  1  2 \\\\\n0  2  0  1 \\\\\n1  0  -1  1\n\\end{bmatrix},\\quad\nb =\n\\begin{bmatrix}\n1 \\\\ 2 \\\\ 3 \\\\ 0 \\\\ -1 \\\\ 4\n\\end{bmatrix},\\quad\nC =\n\\begin{bmatrix}\n1  0  1  0 \\\\\n0  1  -1  2\n\\end{bmatrix},\\quad\nd =\n\\begin{bmatrix}\n1 \\\\ 0.5\n\\end{bmatrix}.\n$$\n\n案例 2（无约束，无约束 LS）：\n设 $A \\in \\mathbb{R}^{5 \\times 3}$、$b \\in \\mathbb{R}^{5}$、$C \\in \\mathbb{R}^{0 \\times 3}$、$d \\in \\mathbb{R}^{0}$ 为\n$$\nA =\n\\begin{bmatrix}\n1  2  0 \\\\\n0  1  1 \\\\\n3  -1  2 \\\\\n0  0  1 \\\\\n2  1  0\n\\end{bmatrix},\\quad\nb =\n\\begin{bmatrix}\n1 \\\\ 0 \\\\ 4 \\\\ -1 \\\\ 2\n\\end{bmatrix},\\quad\nC = \\text{一个 0 行 3 列的空矩阵}，\\quad\nd = \\text{一个空向量}。\n$$\n\n案例 3（完全约束，$m = n$）：\n设 $A \\in \\mathbb{R}^{4 \\times 3}$、$b \\in \\mathbb{R}^{4}$、$C \\in \\mathbb{R}^{3 \\times 3}$、$d \\in \\mathbb{R}^{3}$ 为\n$$\nA =\n\\begin{bmatrix}\n1  0  2 \\\\\n0  1  -1 \\\\\n2  -1  0 \\\\\n1  1  1\n\\end{bmatrix},\\quad\nb =\n\\begin{bmatrix}\n3 \\\\ -1 \\\\ 2 \\\\ 0\n\\end{bmatrix},\\quad\nC =\n\\begin{bmatrix}\n1  0  0 \\\\\n0  1  0 \\\\\n0  0  1\n\\end{bmatrix},\\quad\nd =\n\\begin{bmatrix}\n0.5 \\\\ -1.0 \\\\ 2.0\n\\end{bmatrix}.\n$$\n\n案例 4（单约束，较大的 $n$）：\n设 $A \\in \\mathbb{R}^{7 \\times 5}$、$b \\in \\mathbb{R}^{7}$、$C \\in \\mathbb{R}^{1 \\times 5}$、$d \\in \\mathbb{R}^{1}$ 为\n$$\nA =\n\\begin{bmatrix}\n1  0  2  -1  0 \\\\\n0  1  0  2  -1 \\\\\n2  -1  1  0  1 \\\\\n0  0  1  1  0 \\\\\n1  2  -1  0  2 \\\\\n3  0  0  -2  1 \\\\\n0  1  1  0  0\n\\end{bmatrix},\\quad\nb =\n\\begin{bmatrix}\n1 \\\\ 2 \\\\ 0 \\\\ -1 \\\\ 3 \\\\ 4 \\\\ 0.5\n\\end{bmatrix},\\quad\nC =\n\\begin{bmatrix}\n1  0  -1  0  2\n\\end{bmatrix},\\quad\nd =\n\\begin{bmatrix}\n1.0\n\\end{bmatrix}.\n$$\n\n输出规范：\n对于每个测试用例，计算解向量 $x^\\star$、残差范数 $r = \\|A x^\\star - b\\|_2$ 和约束违反度 $v = \\|C x^\\star - d\\|_2$。将所有浮点数四舍五入到六位小数。您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，每个测试用例的结果本身也是一个浮点数列表，按 $[x_1,\\ldots,x_n,r,v]$ 的顺序排列，对应于该用例的维度 $n$。\n\n例如，最终输出格式必须如下所示\n$$\n\\texttt{[[x\\_1,x\\_2,\\ldots,x\\_n,r,v],[...],[...],[...]]}\n$$\n所有浮点数均四舍五入至六位小数。\n\n角度单位和物理单位不适用于此纯数学问题；输出中不应包含任何单位。", "solution": "问题是找到向量 $x \\in \\mathbb{R}^n$，在一组线性等式约束 $C x = d$ 下，最小化残差的欧几里得范数 $\\|A x - b\\|_2$。这里，$A \\in \\mathbb{R}^{m \\times n}$，$b \\in \\mathbb{R}^m$，$C \\in \\mathbb{R}^{p \\times n}$，$d \\in \\mathbb{R}^p$。这是一个等式约束最小二乘（ECLS）问题。一个稳健且符合原理的解决方法是零空间法，它将约束问题转化为一个更小的无约束问题。推导过程如下，基于问题描述中概述的基本原理。\n\n首先，我们刻画满足约束 $C x = d$ 的所有向量 $x$ 的集合。这个集合是 $\\mathbb{R}^n$ 的一个仿射子空间。任何解 $x$ 都可以表示为一个特解 $x_p$（满足 $C x_p = d$）和一个齐次解 $x_h$（满足 $C x_h = 0$）的和。齐次解 $x_h$ 必须位于 $C$ 的零空间中，记为 $\\mathcal{N}(C)$。\n$$\nx = x_p + x_h, \\quad \\text{其中 } x_h \\in \\mathcal{N}(C)\n$$\n\n该方法的核心是找到零空间 $\\mathcal{N}(C)$ 的一个标准正交基和一个合适的特解 $x_p$。问题指定使用约束矩阵的转置 $C^\\top$ 的 QR 分解。设 $C^\\top \\in \\mathbb{R}^{n \\times p}$ 的 QR 分解为：\n$$\nC^\\top = QR\n$$\n其中 $Q \\in \\mathbb{R}^{n \\times n}$ 是一个正交矩阵（$Q^\\top Q = I_n$），$R \\in \\mathbb{R}^{n \\times p}$ 是一个上梯形矩阵。我们假设约束矩阵 $C$ 是行满秩的，即 $\\text{rank}(C)=p$。这意味着 $C^\\top$ 是列满秩的。\n\n我们将正交矩阵 $Q$ 分成两个块：\n$$\nQ = \\begin{bmatrix} Q_1  Q_2 \\end{bmatrix}\n$$\n其中 $Q_1 \\in \\mathbb{R}^{n \\times p}$，$Q_2 \\in \\mathbb{R}^{n \\times (n-p)}$。$Q_1$ 的列构成了 $C^\\top$ 的值域 $\\mathcal{R}(C^\\top)$ 的一个标准正交基。$Q_2$ 的列构成了 $\\mathcal{R}(C^\\top)$ 的正交补的一个标准正交基，而这个正交补正是 $C$ 的零空间 $\\mathcal{N}(C)$。因此，任何齐次解 $x_h$ 都可以写成 $Q_2$ 的列的线性组合：\n$$\nx_h = Q_2 z\n$$\n对于某个自由参数向量 $z \\in \\mathbb{R}^{n-p}$。\n\n接下来，我们求解一个特解 $x_p$。一个方便的选择是 $C x = d$ 的最小范数解，该解完全位于 $C^\\top$ 的值域中。因此，我们可以将其表示为 $x_p = Q_1 y$，其中 $y \\in \\mathbb{R}^p$ 是某个向量。为了求出 $y$，我们将其代入约束方程：\n$$\nC x_p = d \\implies C (Q_1 y) = d\n$$\n根据 QR 分解，我们有 $C = (QR)^\\top = R^\\top Q^\\top$。矩阵 $R$ 可以分块为 $R = \\begin{bmatrix} R_1 \\\\ 0 \\end{bmatrix}$，其中 $R_1 \\in \\mathbb{R}^{p \\times p}$ 是上三角矩阵并且是可逆的（因为 $\\text{rank}(C)=p$）。将此代入前面的方程得到：\n$$\nR^\\top Q^\\top (Q_1 y) = \\begin{bmatrix} R_1^\\top  0 \\end{bmatrix} \\begin{bmatrix} Q_1^\\top \\\\ Q_2^\\top \\end{bmatrix} (Q_1 y) = R_1^\\top Q_1^\\top Q_1 y = d\n$$\n由于 $Q_1^\\top Q_1 = I_p$，方程简化为一个关于 $y$ 的下三角系统：\n$$\nR_1^\\top y = d\n$$\n这个系统可以通过前向代入法求解 $y$。于是特解为 $x_p = Q_1 y$。\n\n有了完整的参数化表示 $x = x_p + Q_2 z$，我们将其代回原始的最小二乘目标函数：\n$$\n\\min_{x} \\|A x - b\\|_2 \\quad \\implies \\quad \\min_{z} \\|A (x_p + Q_2 z) - b\\|_2\n$$\n整理这些项，我们得到：\n$$\n\\min_{z} \\| (A Q_2) z - (b - A x_p) \\|_2\n$$\n这是一个关于未知向量 $z \\in \\mathbb{R}^{n-p}$ 的无约束最小二乘问题。令 $\\hat{A} = A Q_2$ 和 $\\hat{b} = b - A x_p$。问题现在变为找到使 $\\|\\hat{A} z - \\hat{b}\\|_2$ 最小化的 $z^\\star$。\n\n这个标准的最小二乘问题可以通过其自身的 QR 分解来求解。设 $\\hat{A}$ 的分解为 $\\hat{A} = \\hat{Q} \\hat{R}$，其中 $\\hat{Q}$ 是正交的，$\\hat{R}$ 是上梯形的。目标函数变为：\n$$\n\\|\\hat{Q} \\hat{R} z - \\hat{b}\\|_2 = \\|\\hat{Q}^\\top(\\hat{Q} \\hat{R} z - \\hat{b})\\|_2 = \\|\\hat{R} z - \\hat{Q}^\\top \\hat{b}\\|_2\n$$\n设 $\\hat{R}_1$ 是 $\\hat{R}$ 的上三角部分，并设 $c_1$ 是向量 $\\hat{c} = \\hat{Q}^\\top \\hat{b}$ 的相应部分。通过回代法求解上三角系统 $\\hat{R}_1 z = c_1$ 即可找到解 $z^\\star$。\n\n最后，通过组合特解和齐次解部分来重构原始 ECLS 问题的最优解 $x^\\star$：\n$$\nx^\\star = x_p + Q_2 z^\\star\n$$\n残差范数计算为 $r = \\|A x^\\star - b\\|_2$，约束违反度计算为 $v = \\|C x^\\star - d\\|_2$。根据构造， $v$ 的值应接近于机器精度。\n\n这种使用正交分解的、符合原理的、逐步降维的方法，为求解等式约束最小二乘问题提供了一种数值上稳定且精确的途径。该算法能够优雅地处理边缘情况，例如没有约束的问题（$p=0$）或解完全由约束确定的问题（$p=n$）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_ecls(A, b, C, d):\n    \"\"\"\n    Solves an equality-constrained least squares problem using the null-space method.\n\n    Problem: minimize ||A*x - b||_2 subject to C*x = d.\n\n    Args:\n        A (np.ndarray): Matrix A of size m x n.\n        b (np.ndarray): Vector b of size m.\n        C (np.ndarray): Constraint matrix C of size p x n.\n        d (np.ndarray): Constraint vector d of size p.\n\n    Returns:\n        tuple: A tuple containing:\n            - x_star (np.ndarray): The solution vector of size n.\n            - residual_norm (float): The final residual norm ||A*x_star - b||_2.\n            - constraint_violation (float): The constraint violation ||C*x_star - d||_2.\n    \"\"\"\n    m, n = A.shape\n    p = C.shape[0]\n\n    if p == 0:\n        # Case with no constraints: reduces to a standard least squares problem.\n        # This branch aligns with the general logic by setting up identity transformations.\n        xp = np.zeros(n)\n        Q2 = np.eye(n)\n        A_hat = A\n        b_hat = b\n    else:\n        # Perform QR factorization on the transpose of the constraint matrix C\n        # C is p x n, so C.T is n x p.\n        Q, R = np.linalg.qr(C.T, mode='complete')\n\n        # Partition Q and R\n        # Q is n x n, R is n x p\n        Q1 = Q[:, :p]\n        Q2 = Q[:, p:]\n        R1 = R[:p, :]\n\n        # Find the particular solution xp to C*x = d\n        # Solve the lower triangular system R1.T * y = d\n        y = np.linalg.solve(R1.T, d)\n        xp = Q1 @ y\n\n        # Form the reduced unconstrained least squares problem\n        # min ||(A*Q2)*z - (b - A*xp)||_2\n        A_hat = A @ Q2\n        b_hat = b - A @ xp\n\n    # Solve the reduced unconstrained LS problem for the coefficients z of the null space\n    k = A_hat.shape[1]  # This is n-p\n    if k  0:\n        # Use QR factorization of A_hat to solve for z\n        Q_hat, R_hat = np.linalg.qr(A_hat, mode='reduced')\n\n        # Solve R_hat * z = Q_hat.T * b_hat\n        c_hat = Q_hat.T @ b_hat\n        z_star = np.linalg.solve(R_hat, c_hat)\n    else:\n        # Trivial case where the null space is empty (n=p)\n        z_star = np.array([])\n    \n    # Reconstruct the final solution\n    # Q2 @ z_star produces a vector of zeros if z_star is empty\n    x_star = xp + Q2 @ z_star\n\n    # Calculate final norms for verification and output\n    residual_norm = np.linalg.norm(A @ x_star - b)\n    if p  0:\n        constraint_violation = np.linalg.norm(C @ x_star - d)\n    else:\n        constraint_violation = 0.0\n\n    return x_star, residual_norm, constraint_violation\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and print results in the specified format.\n    \"\"\"\n    # Case 1\n    A1 = np.array([\n        [2., -1., 0., 0.], [1., 3., -2., 1.], [0., 1., 4., -1.],\n        [3., 0., 1., 2.], [0., 2., 0., 1.], [1., 0., -1., 1.]\n    ])\n    b1 = np.array([1., 2., 3., 0., -1., 4.])\n    C1 = np.array([[1., 0., 1., 0.], [0., 1., -1., 2.]])\n    d1 = np.array([1., 0.5])\n\n    # Case 2\n    A2 = np.array([\n        [1., 2., 0.], [0., 1., 1.], [3., -1., 2.],\n        [0., 0., 1.], [2., 1., 0.]\n    ])\n    b2 = np.array([1., 0., 4., -1., 2.])\n    C2 = np.empty((0, 3))\n    d2 = np.empty(0)\n\n    # Case 3\n    A3 = np.array([\n        [1., 0., 2.], [0., 1., -1.], [2., -1., 0.], [1., 1., 1.]\n    ])\n    b3 = np.array([3., -1., 2., 0.])\n    C3 = np.array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]])\n    d3 = np.array([0.5, -1.0, 2.0])\n\n    # Case 4\n    A4 = np.array([\n        [1., 0., 2., -1., 0.], [0., 1., 0., 2., -1.], [2., -1., 1., 0., 1.],\n        [0., 0., 1., 1., 0.], [1., 2., -1., 0., 2.], [3., 0., 0., -2., 1.],\n        [0., 1., 1., 0., 0.]\n    ])\n    b4 = np.array([1., 2., 0., -1., 3., 4., 0.5])\n    C4 = np.array([[1., 0., -1., 0., 2.]])\n    d4 = np.array([1.0])\n\n    test_cases = [\n        (A1, b1, C1, d1),\n        (A2, b2, C2, d2),\n        (A3, b3, C3, d3),\n        (A4, b4, C4, d4),\n    ]\n\n    all_results = []\n    for A, b, C, d in test_cases:\n        x_star, r, v = solve_ecls(A, b, C, d)\n        case_result = list(x_star) + [r, v]\n        all_results.append(case_result)\n    \n    # Format the final output string exactly as specified.\n    list_strs = []\n    for case_res in all_results:\n        num_strs = [f\"{x:.6f}\" for x in case_res]\n        list_strs.append(f\"[{','.join(num_strs)}]\")\n    final_output = f\"[{','.join(list_strs)}]\"\n\n    print(final_output)\n\nsolve()\n```", "id": "3275428"}, {"introduction": "在处理传感器网络、金融数据或在线学习等流式数据时，一次性处理所有数据既不现实也不高效。这个练习将向您介绍一种优雅的增量式方法，用于解决动态增长的最小二乘问题。您将使用 Givens 旋转来逐行更新 QR 分解，而不是在每个新数据点到达时都重新计算，这突显了为不同计算场景选择合适数值工具的重要性 [@problem_id:3275374]。", "problem": "您必须使用吉文斯旋转（Givens rotations）为流式输入的行实现一个增量最小二乘解算器。目标是在处理完每个测试用例中的所有行之后，维护一个最新的因式分解并解决这个增长的最小二乘问题。您必须生成一个完整的、可运行的程序，该程序仅使用指定的 Python 环境。\n\n使用的基本原理：\n- 最小二乘问题定义为，对于给定的矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 和向量 $b \\in \\mathbb{R}^m$，在 $x \\in \\mathbb{R}^n$ 上最小化欧几里得范数 $\\lVert A x - b \\rVert_2$。\n- 正交变换保持欧几里得范数不变，即，如果 $Q \\in \\mathbb{R}^{m \\times m}$ 是正交的（因此 $Q^\\top Q = I$），那么 $\\lVert A x - b \\rVert_2 = \\lVert Q^\\top (A x - b) \\rVert_2$。\n- 吉文斯旋转是一个 $2 \\times 2$ 的正交矩阵，它可以将一个二维向量的某个选定分量置零；当嵌入到更高维度时，它能保持范数和正交性。\n\n任务规格：\n- 您将实现一个增量更新，当 $A$ 的一个新行 $a^{\\top} \\in \\mathbb{R}^n$ 和 $b$ 的一个新标量 $\\beta \\in \\mathbb{R}$ 到达时，更新现有的上三角因子 $R \\in \\mathbb{R}^{n \\times n}$ 和变换后的右侧向量 $c \\in \\mathbb{R}^n$，以便在处理完一个测试用例的所有行后，通过求解 $R x = c$ 得到完整系统的最小二乘解。此更新必须使用吉文斯旋转来执行，该旋转仅作用于当前的 $R$、新输入的行 $a^{\\top}$ 以及右侧的累加量。\n- 初始化：在处理任何测试用例的行之前，设置 $R = 0 \\in \\mathbb{R}^{n \\times n}$ 和 $c = 0 \\in \\mathbb{R}^n$。\n- 行更新需维护的不变量：\n  - 在并入 $k$ 行后，存在一个正交矩阵 $Q_k \\in \\mathbb{R}^{k \\times k}$，使得 $Q_k^\\top A_k = \\begin{bmatrix} R_k \\\\ 0 \\end{bmatrix}$，其中 $A_k \\in \\mathbb{R}^{k \\times n}$ 是前 $k$ 行构成的矩阵，而 $R_k \\in \\mathbb{R}^{n \\times n}$ 是上三角矩阵（如果秩亏，对角线上可能有零元素）。\n  - 向量 $c$ 等于 $Q_k^\\top b_k$ 的前 $n$ 个元素，其中 $b_k \\in \\mathbb{R}^k$ 汇集了 $b$ 的前 $k$ 个元素。\n- 在处理完一个测试用例的所有行之后，您必须实现一个三角求解来从 $R x = c$ 计算 $x$。为处理潜在的秩亏情况，使用一个阈值 $\\tau = 10^{-12}$：如果 $\\lvert R_{ii} \\rvert \\le \\tau$，则设 $x_i = 0$，并且在回代过程中不对该索引的 $R_{ii}$ 进行除法运算。这将产生一个具有最小残差范数的最小二乘解。\n- 为进行验证，对每个测试用例，还需使用一种稳定的批处理方法计算一个参考最小二乘解，并比较残差范数。\n\n每个测试用例需要计算和输出的内容：\n- 对于每个测试用例，在增量处理完所有行并通过回代计算出解 $x_{\\text{inc}}$ 之后，计算残差范数 $\\rho_{\\text{inc}} = \\lVert A x_{\\text{inc}} - b \\rVert_2$。\n- 同时，通过稳定的批处理方法计算一个参考解 $x_{\\text{ref}}$ 及其残差范数 $\\rho_{\\text{ref}} = \\lVert A x_{\\text{ref}} - b \\rVert_2$。\n- 该测试用例的标量结果是绝对差 $\\Delta = \\lvert \\rho_{\\text{inc}} - \\rho_{\\text{ref}} \\rvert$。\n\n使用吉文斯旋转实现的流式更新：\n- 当一个带有右侧项 $\\beta$ 的新行 $a^{\\top}$ 到达时，创建一个工作副本 $w \\leftarrow a$ 和一个标量累加器 $\\gamma \\leftarrow \\beta$。\n- 对于每个列索引 $j = 0, 1, \\dots, n-1$，计算作用于对 $\\big(R_{jj}, w_j\\big)$ 的吉文斯旋转系数 $c_j, s_j$，以将第二个分量置零。将相同的旋转应用于子行 $R_{j, j:n}$ 和 $w_{j:n}$, 并将其应用于对 $\\big(c_j^{(\\text{rhs})}, \\gamma\\big)$，其中 $c_j^{(\\text{rhs})}$ 表示向量 $c$ 当前的第 $j$ 个元素。在完成 $j = 0 \\dots n-1$ 后，丢弃 $w$ 和 $\\gamma$。此过程保持了正交性，并维持 $R$ 的上三角形式。\n\n数值细节和约束：\n- 在回代中，使用阈值 $\\tau = 10^{-12}$ 进行奇异性判断。\n- 使用数值稳定的方法从对 $(\\alpha, \\beta)$ 计算吉文斯旋转：当 $r \\ne 0$ 时，通过 $r = \\sqrt{\\alpha^2 + \\beta^2}$, $c = \\alpha / r$, $s = \\beta / r$ 计算；否则，取 $c = 1$ 和 $s = 0$。\n- 所有浮点计算必须使用双精度。\n\n测试套件：\n对于每个测试用例，$n$ 是列数，数据以有序的行流形式提供，必须按给定顺序处理。\n\n- 测试用例 1（高矩阵，良态）：\n  - $n = 3$。\n  - $A$ 的行及对应的 $b$ 元素：\n    - $[2.0, -1.0, 0.0]$, $1.0$\n    - $[-1.0, 2.0, -1.0]$, $0.0$\n    - $[0.0, -1.0, 2.0]$, $1.0$\n    - $[1.0, 0.0, -1.0]$, $-1.0$\n    - $[3.0, 1.0, 0.0]$, $4.0$\n- 测试用例 2（恰定，非奇异）：\n  - $n = 3$。\n  - $A$ 和 $b$ 的行：\n    - $[1.0, 2.0, 3.0]$, $7.0$\n    - $[0.0, -1.0, 4.0]$, $3.0$\n    - $[2.0, 0.0, 1.0]$, $5.0$\n- 测试用例 3（列秩亏：第三列等于前两列之和）：\n  - $n = 3$。\n  - $A$ 和 $b$ 的行：\n    - $[1.0, 2.0, 3.0]$, $1.0$\n    - $[2.0, -1.0, 1.0]$, $0.0$\n    - $[-1.0, 0.5, -0.5]$, $1.0$\n    - $[3.0, 1.0, 4.0]$, $2.0$\n- 测试用例 4（欠定：行数少于列数）：\n  - $n = 3$。\n  - $A$ 和 $b$ 的行：\n    - $[1.0, 0.0, 0.0]$, $3.0$\n    - $[0.0, 1.0, 0.0]$, $4.0$\n\n参考方法：\n- 对于 $x_{\\text{ref}}$，您可以使用一个批处理最小二乘解算器，该解算器返回具有最小残差范数的最小二乘解（例如，基于奇异值分解的方法）。\n\n最终输出格式：\n- 您的程序必须打印一行，其中包含一个 Python 风格的列表，内含四个标量结果 $\\Delta$，每个结果对应一个测试用例，并按上述顺序排列。\n- 每个数字必须以科学记数法格式化，小数点后精确到 $12$ 位。\n- 格式示例（非实际值）：$[1.234000000000e-06,5.678900000000e-12,0.000000000000e+00,9.990000000000e-04]$。\n\n您的程序不会接收任何输入；所有数据必须严格按照上述规定进行硬编码。您的实现只能使用允许的库和环境，并且不得打印任何额外文本。输出必须严格匹配指定的单行格式。", "solution": "该问题要求实现一个增量算法来求解线性最小二乘问题。该问题旨在寻找一个向量 $x \\in \\mathbb{R}^n$，使得对于给定的矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 和向量 $b \\in \\mathbb{R}^m$，残差的欧几里得范数 $\\lVert Ax - b \\rVert_2$ 最小。数据 $(A, b)$ 以行流的形式提供，解必须随着每一行的输入而增量更新。\n\n该方法的基础在于正交变换保持欧几里得范数不变的性质。如果 $Q \\in \\mathbb{R}^{m \\times m}$ 是一个正交矩阵（即 $Q^\\top Q = I$），那么对于任何向量 $y \\in \\mathbb{R}^m$，都有 $\\lVert y \\rVert_2 = \\lVert Q^\\top y \\rVert_2$。将此性质应用于最小二乘残差，我们得到：\n$$\n\\lVert Ax - b \\rVert_2 = \\lVert Q^\\top (Ax - b) \\rVert_2 = \\lVert (Q^\\top A)x - (Q^\\top b) \\rVert_2\n$$\n策略是选择一个能简化 $A$ 结构的 $Q$。具体来说，我们使用 QR 分解，其中 $A$ 被分解为一个正交矩阵 $Q$ 和一个上三角矩阵的乘积。我们计算一个正交矩阵 $Q$ 使得：\n$$\nQ^\\top A = \\begin{bmatrix} R \\\\ 0 \\end{bmatrix}\n$$\n其中 $R \\in \\mathbb{R}^{n \\times n}$ 是上三角矩阵，而 $0$ 是一个 $(m-n) \\times n$ 的零矩阵（假设 $m \\ge n$）。将相同的变换应用于 $b$ 会得到：\n$$\nQ^\\top b = \\begin{bmatrix} c \\\\ d \\end{bmatrix}\n$$\n其中 $c \\in \\mathbb{R}^n$ 且 $d \\in \\mathbb{R}^{m-n}$。最小化问题于是变为：\n$$\n\\min_{x} \\left\\lVert \\begin{bmatrix} R \\\\ 0 \\end{bmatrix} x - \\begin{bmatrix} c \\\\ d \\end{bmatrix} \\right\\rVert_2^2 = \\min_{x} \\left\\lVert \\begin{bmatrix} Rx - c \\\\ -d \\end{bmatrix} \\right\\rVert_2^2 = \\min_{x} \\left( \\lVert Rx - c \\rVert_2^2 + \\lVert d \\rVert_2^2 \\right)\n$$\n项 $\\lVert d \\rVert_2^2$ 与 $x$ 无关。因此，为了最小化总和，我们必须最小化 $\\lVert Rx - c \\rVert_2^2$。如果 $R$ 是非奇异的，则最小值是零，通过求解上三角系统 $Rx = c$ 来实现。最小残差范数为 $\\lVert d \\rVert_2$。\n\n对于增量求解器，我们不一次性构建完整的矩阵 $A$。取而代之的是，我们维护因子 $R \\in \\mathbb{R}^{n \\times n}$ 和变换后的向量 $c \\in \\mathbb{R}^n$。初始时，对于一个空系统（$m=0$），我们有 $R=0$ 和 $c=0$。当一个由向量 $a^\\top \\in \\mathbb{R}^{1 \\times n}$ 和标量 $\\beta \\in \\mathbb{R}$组成的新行到达时，我们需要更新 $R$ 和 $c$。这等价于找到一个正交变换来更新增广系统的因式分解：\n$$\n\\begin{bmatrix} R_{\\text{old}} \\\\ a^\\top \\end{bmatrix} \\rightarrow \\begin{bmatrix} R_{\\text{new}} \\\\ 0 \\end{bmatrix} \\quad \\text{and} \\quad \\begin{bmatrix} c_{\\text{old}} \\\\ \\beta \\end{bmatrix} \\rightarrow \\begin{bmatrix} c_{\\text{new}} \\\\ \\gamma' \\end{bmatrix}\n$$\n这个变换通过一系列 $n$ 次吉文斯旋转来完成。吉文斯旋转是一种作用于二维子空间的正交矩阵，用以将向量的特定元素置零。对于每个新行，我们应用一系列旋转来消去新行向量的每个元素，将其信息并入现有的 $R$ 矩阵和 $c$ 向量中。\n\n处理一个新行 $(a^\\top, \\beta)$ 的算法步骤如下：\n1.  初始化行向量的工作副本 $w \\leftarrow a$ 和右侧标量 $\\gamma \\leftarrow \\beta$。\n2.  对每个列索引 $j=0, 1, \\dots, n-1$：\n    a. 我们的目标是通过将元素 $w_j$ 与对角元素 $R_{jj}$ 进行旋转来将其置零。令 $\\alpha = R_{jj}$ 和 $\\beta_g = w_j$。\n    b. 计算吉文斯旋转系数 $(c_g, s_g)$。一种数值稳定的方法是先计算 $r = \\sqrt{\\alpha^2 + \\beta_g^2}$。如果 $r=0$，则旋转为单位变换（$c_g=1, s_g=0$）。否则，$c_g = \\alpha/r$ 且 $s_g = \\beta_g/r$。\n    c. 这个旋转将对 $(\\alpha, \\beta_g)$ 变换为 $(r, 0)$：\n    $$\n    \\begin{bmatrix} c_g  s_g \\\\ -s_g  c_g \\end{bmatrix} \\begin{pmatrix} R_{jj} \\\\ w_j \\end{pmatrix} = \\begin{pmatrix} \\sqrt{R_{jj}^2 + w_j^2} \\\\ 0 \\end{pmatrix}\n    $$\n    d. 将此相同的旋转应用于行的剩余部分，即子向量 $R_{j, j:n}$ 和 $w_{j:n}$，以及右侧分量 $c_j$ 和 $\\gamma$：\n    $$\n    \\begin{pmatrix} R_{j, j:n}^{(\\text{new})} \\\\ w_{j:n}^{(\\text{new})} \\end{pmatrix} = \\begin{bmatrix} c_g  s_g \\\\ -s_g  c_g \\end{bmatrix} \\begin{pmatrix} R_{j, j:n}^{(\\text{old})} \\\\ w_{j:n}^{(\\text{old})} \\end{pmatrix}\n    $$\n    $$\n    \\begin{pmatrix} c_j^{(\\text{new})} \\\\ \\gamma^{(\\text{new})} \\end{pmatrix} = \\begin{bmatrix} c_g  s_g \\\\ -s_g  c_g \\end{bmatrix} \\begin{pmatrix} c_j^{(\\text{old})} \\\\ \\gamma^{(\\text{old})} \\end{pmatrix}\n    $$\n    此步骤后，$w_j$ 变为零，并且 $R$ 的上三角结构得以保持。在遍历所有 $j$ 之后，整个向量 $w$ 被置零，更新完成。\n\n在处理完 $(A,b)$ 的所有 $m$ 行后，使用回代法求解所得系统 $Rx=c$ 以得到 $x$。对于可能秩亏的系统，矩阵 $R$ 的对角线上可能存在零或非常小的元素。使用一个阈值 $\\tau = 10^{-12}$ 来处理这种情况：如果 $|R_{ii}| \\le \\tau$，则相应的列被视为线性相关，我们设置 $x_i = 0$ 以选择一个特定的最小二乘解。\n\n通过将其残差的范数 $\\rho_{\\text{inc}} = \\lVert A x_{\\text{inc}} - b \\rVert_2$ 与来自稳定批处理求解器的残差范数 $\\rho_{\\text{ref}} = \\lVert A x_{\\text{ref}} - b \\rVert_2$ 进行比较，来验证此增量方法的正确性。对于任何最小二乘问题，最小残差范数是唯一的，即使解向量 $x$ 不是唯一的。因此，对于一个正确的实现，绝对差 $\\Delta = |\\rho_{\\text{inc}} - \\rho_{\\text{ref}}|$ 必须接近机器精度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests an incremental least-squares solver using Givens rotations.\n    \"\"\"\n\n    def solve_incremental_lsq(n, A_rows, b_vals, tau):\n        \"\"\"\n        Solves the least-squares problem incrementally using Givens rotations.\n        \n        Args:\n            n (int): The number of columns in matrix A.\n            A_rows (list of lists): The rows of matrix A.\n            b_vals (list): The entries of vector b.\n            tau (float): The threshold for singularity in back substitution.\n        \n        Returns:\n            np.ndarray: The least-squares solution vector x.\n        \"\"\"\n        R = np.zeros((n, n), dtype=np.float64)\n        c = np.zeros(n, dtype=np.float64)\n\n        for a_row, b_val in zip(A_rows, b_vals):\n            w = np.array(a_row, dtype=np.float64)\n            gamma = float(b_val)\n\n            for j in range(n):\n                alpha = R[j, j]\n                beta = w[j]\n\n                # Compute Givens rotation coefficients robustly\n                r = np.hypot(alpha, beta)\n                if r == 0.0:\n                    cg, sg = 1.0, 0.0\n                else:\n                    cg, sg = alpha / r, beta / r\n\n                # Apply rotation to R and w (from column j onwards)\n                # A temporary copy of the R sub-row is needed for the update.\n                R_j_sub = R[j, j:].copy()\n                w_sub = w[j:].copy()\n                \n                R[j, j:] = cg * R_j_sub + sg * w_sub\n                w[j:] = -sg * R_j_sub + cg * w_sub\n                \n                # Apply the same rotation to the right-hand side c and gamma\n                c_j_val = c[j]\n                c[j] = cg * c_j_val + sg * gamma\n                gamma = -sg * c_j_val + cg * gamma\n                \n        # After processing all rows, solve Rx = c by back substitution\n        x = np.zeros(n, dtype=np.float64)\n        for i in range(n - 1, -1, -1):\n            rhs = c[i] - np.dot(R[i, i+1:], x[i+1:])\n            \n            # Handle potential rank deficiency\n            if abs(R[i, i])  tau:\n                x[i] = rhs / R[i, i]\n            else:\n                x[i] = 0.0\n                \n        return x\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            3, # n\n            [[2.0, -1.0, 0.0],\n             [-1.0, 2.0, -1.0],\n             [0.0, -1.0, 2.0],\n             [1.0, 0.0, -1.0],\n             [3.0, 1.0, 0.0]], # A_rows\n            [1.0, 0.0, 1.0, -1.0, 4.0]  # b_vals\n        ),\n        (\n            3, # n\n            [[1.0, 2.0, 3.0],\n             [0.0, -1.0, 4.0],\n             [2.0, 0.0, 1.0]], # A_rows\n            [7.0, 3.0, 5.0]  # b_vals\n        ),\n        (\n            3, # n\n            [[1.0, 2.0, 3.0],\n             [2.0, -1.0, 1.0],\n             [-1.0, 0.5, -0.5],\n             [3.0, 1.0, 4.0]], # A_rows\n            [1.0, 0.0, 1.0, 2.0]  # b_vals\n        ),\n        (\n            3, # n\n            [[1.0, 0.0, 0.0],\n             [0.0, 1.0, 0.0]], # A_rows\n            [3.0, 4.0]  # b_vals\n        )\n    ]\n\n    tau = 1e-12\n    results = []\n\n    for n, A_rows, b_vals in test_cases:\n        # Assemble full matrices for residual calculation and reference solver\n        A = np.array(A_rows, dtype=np.float64)\n        b = np.array(b_vals, dtype=np.float64)\n        \n        # Get incremental solution\n        x_inc = solve_incremental_lsq(n, A_rows, b_vals, tau)\n        \n        # Get reference solution using a stable batch method\n        # Use rcond=None to let NumPy determine rank based on machine precision\n        x_ref = np.linalg.lstsq(A, b, rcond=None)[0]\n\n        # Compute residual norms for both solutions\n        # The case m=0 (A is empty) is implicitly handled as loops won't run.\n        if A.shape[0]  0:\n            rho_inc = np.linalg.norm(A @ x_inc - b)\n            rho_ref = np.linalg.norm(A @ x_ref - b)\n        else:\n            rho_inc = np.linalg.norm(-b)\n            rho_ref = np.linalg.norm(-b)\n\n        # Calculate the absolute difference of residual norms\n        delta = abs(rho_inc - rho_ref)\n        results.append(delta)\n\n    # Format the final output string exactly as specified\n    formatted_results = [f\"{r:.12e}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3275374"}]}