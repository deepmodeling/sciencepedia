{"hands_on_practices": [{"introduction": "掌握 B 样条的最佳方式莫过于亲手实现它。本练习将指导您完成这关键的第一步：将 B 样条的 Cox-de Boor 递归定义转化为可执行的算法。您将特别关注夹持节点向量（clamped knot vector）的使用，这是一种确保曲线能够精确通过其首尾控制点的常用技术。通过完成此练习 [@problem_id:3207506]，您将对 B 样条的基本公式及其在设计中的实际应用有更深刻的理解。", "problem": "要求您编写一个完整、可运行的程序，该程序以保证对首尾控制点进行插值的方式，构建并求值一条基样条（B-spline）曲线。您的设计必须从 B 样条基函数的核心递归定义出发，并进而实现一个兼顾数值稳定性和正确性的算法。\n\n请从以下基本原理开始：B 样条基函数的 Cox–de Boor 递归定义。对于一个给定的非递减节点向量 $\\{t_0, t_1, \\dots, t_m\\}$ 和次数 $p \\ge 0$，基函数 $N_{i,p}(u)$ 的递归定义如下\n$$\nN_{i,0}(u) = \n\\begin{cases}\n1,  \\text{若 } t_i \\le u  t_{i+1} \\\\\n0,  \\text{其它情况}\n\\end{cases}\n$$\n当 $p \\ge 1$ 时，\n$$\nN_{i,p}(u) = \\frac{u - t_i}{t_{i+p} - t_i} N_{i,p-1}(u) + \\frac{t_{i+p+1} - u}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(u),\n$$\n约定分母为零的项视为零。参数曲线则由下式给出\n$$\n\\mathbf{C}(u) = \\sum_{i=0}^{n} N_{i,p}(u)\\,\\mathbf{P}_i,\n$$\n其中 $\\{\\mathbf{P}_0,\\dots,\\mathbf{P}_n\\}$ 是控制点。当节点向量是钳位（也称为开放）的，即首尾节点各重复 $p+1$ 次时，可以保证曲线在参数域的两端对首尾控制点进行插值。您的任务是实现一个使用这些定义的求值算法，并通过一个测试套件来证明您的曲线精确地经过其首尾控制点。\n\n要求：\n- 基于上述递归基函数定义，实现 B 样条曲线求值，采用适合高等本科数值方法课程的数值稳定方法。您必须通过在两端使用重复度为 $p+1$ 的钳位节点向量来确保端点插值。\n- 求值域必须是 $[t_p, t_{m-p}]$。在 $u = t_p$ 和 $u = t_{m-p}$ 处，曲线必须分别返回 $\\mathbf{P}_0$ 和 $\\mathbf{P}_n$。\n- 使用欧几里得距离比较向量是否相等，绝对容差为 $10^{-9}$，相对容差为零。如果范数差小于或等于 $10^{-9}$，则视为相等。\n\n测试套件与参数：\n对于下方的每个测试用例，请在左端点 $u = t_p$ 和右端点 $u = t_{m-p}$ 处对曲线进行求值，并检查这些点是否在容差范围内与首尾控制点匹配。您的程序应为每个测试用例生成一个布尔值，表示两个端点检查是否都通过。\n\n设每个控制点 $\\mathbf{P}_i$ 是一个按规定在二维或三维空间中的坐标向量。节点向量可以是明确给出的，也可以是必须构建的开放均匀钳位节点向量。一个长度为 $m+1 = n + p + 2$ 的开放均匀钳位节点向量，其前 $p+1$ 个条目等于 $0$，后 $p+1$ 个条目等于 $1$，内部节点在 $(0,1)$ 区间内均匀分布。\n\n- 测试用例 1（正常路径，二维，二次开放均匀钳位）：\n  - 次数 $p = 2$。\n  - 控制点 $\\mathbf{P}_0,\\dots,\\mathbf{P}_4$: $\\{(0,0),(1,2),(2,0.5),(3,3),(4,0)\\}$。\n  - 为 $n=4, p=2$ 构建一个开放均匀钳位节点向量。\n- 测试用例 2（边界情况，内部节点最少，三次开放均匀钳位，类贝塞尔）：\n  - 次数 $p = 3$。\n  - 控制点 $\\mathbf{P}_0,\\dots,\\mathbf{P}_3$: $\\{(0,0),(1,2),(3,2),(4,0)\\}$。\n  - 为 $n=3, p=3$ 构建一个开放均匀钳位节点向量。\n- 测试用例 3（非均匀钳位，二维）：\n  - 次数 $p = 3$。\n  - 控制点 $\\mathbf{P}_0,\\dots,\\mathbf{P}_6$: $\\{(0,0),(1,1),(2,-1),(3,2),(4,-0.5),(5,1.5),(6,0)\\}$。\n  - 显式给定的非均匀钳位节点向量：$\\{0,0,0,0,0.15,0.6,0.85,1,1,1,1\\}$。\n- 测试用例 4（边缘情况，线性开放均匀钳位）：\n  - 次数 $p = 1$。\n  - 控制点 $\\mathbf{P}_0,\\dots,\\mathbf{P}_2$: $\\{(0,1),(1,0),(2,1.5)\\}$。\n  - 为 $n=2, p=1$ 构建一个开放均匀钳位节点向量。\n- 测试用例 5（三维，三次开放均匀钳位）：\n  - 次数 $p = 3$。\n  - 控制点 $\\mathbf{P}_0,\\dots,\\mathbf{P}_5$: $\\{(0,0,0),(1,2,1),(2,-1,2),(3,3,2),(4,0,1),(5,1,0)\\}$。\n  - 为 $n=5, p=3$ 构建一个开放均匀钳位节点向量。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $\\texttt{[true,false,true]}$。请使用小写的 Python 布尔值格式。该列表必须为每个测试用例包含一个布尔值，并按上述顺序列出。", "solution": "该问题要求实现并验证 B 样条曲线的求值，展示钳位节点向量的端点插值属性。该解决方案直接源于问题陈述中提供的 B 样条基函数的基本递归定义。\n\n一条次数为 $p$ 的 B 样条曲线 $\\mathbf{C}(u)$ 是一条参数曲线，定义为 $n+1$ 个控制点 $\\{\\mathbf{P}_0, \\dots, \\mathbf{P}_n\\}$ 的加权和：\n$$\n\\mathbf{C}(u) = \\sum_{i=0}^{n} N_{i,p}(u)\\,\\mathbf{P}_i\n$$\n权重是 B 样条基函数 $N_{i,p}(u)$，它们是次数为 $p$ 的分段多项式。其定义依赖于一个称为节点向量的非递减实数序列 $T = \\{t_0, t_1, \\dots, t_m\\}$，其中关系式 $m = n+p+1$ 必须成立。基函数由 Cox–de Boor 递归公式定义。\n\n对于 $p=0$：\n$$\nN_{i,0}(u) = \n\\begin{cases}\n1,   \\text{if } t_i \\le u  t_{i+1} \\\\\n0,   \\text{otherwise}\n\\end{cases}\n$$\n此定义意味着对于任何零长度区间，即 $t_i = t_{i+1}$，基函数 $N_{i,0}(u)$ 恒为 $0$。对于参数值 $u$ 位于定义域最末端的情况，需要特殊考虑。如果曲线定义域是 $[t_p, t_{n+1}]$，那么对于 $u = t_{n+1}$，相关的非零 0 次基函数被取为 $N_{n,0}(t_{n+1})=1$。\n\n对于 $p \\ge 1$：\n$$\nN_{i,p}(u) = \\frac{u - t_i}{t_{i+p} - t_i} N_{i,p-1}(u) + \\frac{t_{i+p+1} - u}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(u)\n$$\n问题规定，如果此表达式中的分母为零，则相应项被视为零。\n\n任务的核心是基于这些定义实现一个计算 $\\mathbf{C}(u)$ 的算法，并验证对于钳位节点向量，$\\mathbf{C}(t_p) = \\mathbf{P}_0$ 且 $\\mathbf{C}(t_{n+1}) = \\mathbf{P}_n$。一个钳位节点向量其首 $p+1$ 个节点相等，末 $p+1$ 个节点也相等。这种结构确保了 $N_{0,p}(t_p)=1$ 和 $N_{n,p}(t_{n+1})=1$，而所有其他基函数 $N_{i,p}$ 在各自的端点处为零，从而实现插值。\n\n对于每个测试用例，整体算法流程如下：\n1.  **参数设置**：定义次数 $p$ 和 $n+1$ 个控制点集合 $\\{\\mathbf{P}_i\\}$。\n2.  **节点向量构建**：构建节点向量 $T$。对于需要开放均匀钳位节点向量的情况，前 $p+1$ 个节点设置为 $0$，后 $p+1$ 个节点设置为 $1$，而 $n-p$ 个内部节点在区间 $(0,1)$ 内均匀分布。节点数量为 $m+1 = n+p+2$。\n3.  **端点处的曲线求值**：\n    *   在曲线定义域的左端点 $u_{left} = t_p$ 处对曲线进行求值。\n    *   在曲线定义域的右端点 $u_{right} = t_{n+1}$ 处对曲线进行求值。\n    *   求值本身，即 $\\mathbf{C}(u)$，由一个计算 $\\sum_{i=0}^{n} N_{i,p}(u)\\,\\mathbf{P}_i$ 的函数执行。\n4.  **基函数计算**：每个基函数 $N_{i,p}(u)$ 的值使用一个直接实现 Cox-de Boor 公式的递归函数来计算。为确保计算可行性，该递归函数被记忆化（一种动态规划形式），以防止对相同基函数值的重复计算。基例 $N_{i,0}(u)$ 的实现必须仔细处理半开区间以及在定义域右端点的特殊情况。\n5.  **验证**：将计算出的点 $\\mathbf{C}(u_{left})$ 与第一个控制点 $\\mathbf{P}_0$ 进行比较，并将 $\\mathbf{C}(u_{right})$ 与最后一个控制点 $\\mathbf{P}_n$ 进行比较。比较是通过计算向量之间的欧几里得距离来完成的。如果两个端点的距离都在指定的 $10^{-9}$ 容差范围内，则认为该测试用例通过。\n\n该实现封装了这些步骤。一个主函数遍历测试套件，调用辅助函数来构建节点向量和求值 B 样条曲线。求值函数 `b_spline_eval` 使用一个嵌套的辅助函数 `_basis_function` 来递归计算基函数。这种嵌套结构使得递归函数能够保持简洁，同时可以访问参数 $u$、节点向量 $T$ 和记忆化字典，从而避免了使用全局状态。每个测试用例的结果（一个布尔值）被收集起来，并以指定格式打印。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_clamped_uniform_knot_vector(n, p):\n    \"\"\"\n    Constructs a clamped open-uniform knot vector.\n    The domain for the interior knots is (0, 1).\n    \n    Args:\n        n (int): The number of control points minus 1.\n        p (int): The degree of the B-spline.\n        \n    Returns:\n        np.ndarray: The knot vector of length n + p + 2.\n    \"\"\"\n    num_knots = n + p + 2\n    T = np.zeros(num_knots, dtype=float)\n    \n    num_interior_knots = n - p\n    if num_interior_knots > 0:\n      denominator = float(n - p + 1)\n      T[p + 1 : n + 1] = np.arange(1, num_interior_knots + 1) / denominator\n    \n    T[n + 1:] = 1.0\n    return T\n\ndef b_spline_eval(u, p, control_points, T):\n    \"\"\"\n    Evaluates the B-spline curve at a parameter value u using the recursive\n    Cox-de Boor basis function definition with memoization.\n    \n    Args:\n        u (float): The parameter value.\n        p (int): The degree of the B-spline.\n        control_points (np.ndarray): Array of control points.\n        T (np.ndarray): The knot vector.\n        \n    Returns:\n        np.ndarray: The computed point on the curve.\n    \"\"\"\n    n = len(control_points) - 1\n    memo = {}\n\n    def _basis_function(i, deg):\n        \"\"\"\n        Computes the value of the B-spline basis function N_i,deg(u) via\n        a memoized recursion. This is a nested function to capture u, T, n, and memo.\n        \"\"\"\n        if (i, deg) in memo:\n            return memo[(i, deg)]\n\n        if deg == 0:\n            # The curve domain is [t_p, t_{n+1}]. At the right boundary u = t_{n+1},\n            # the convention is that u falls in the last interval [t_n, t_{n+1}],\n            # making N_{n,0}(t_{n+1}) = 1.\n            if u == T[n + 1] and i == n:\n                res = 1.0\n            else:\n                # Standard definition for half-open interval [t_i, t_{i+1}).\n                # This is 0 if t_i == t_{i+1}.\n                res = 1.0 if T[i] = u  T[i + 1] else 0.0\n            memo[(i, deg)] = res\n            return res\n\n        # Recursive step\n        term1 = 0.0\n        den1 = T[i + deg] - T[i]\n        if den1 != 0.0:\n            term1 = ((u - T[i]) / den1) * _basis_function(i, deg - 1)\n\n        term2 = 0.0\n        den2 = T[i + deg + 1] - T[i + 1]\n        if den2 != 0.0:\n            term2 = ((T[i + deg + 1] - u) / den2) * _basis_function(i + 1, deg - 1)\n\n        res = term1 + term2\n        memo[(i, deg)] = res\n        return res\n\n    curve_point = np.zeros_like(control_points[0], dtype=float)\n    for i in range(n + 1):\n        basis_val = _basis_function(i, p)\n        # Optimization: only add if the basis function is non-zero\n        if basis_val > 1e-12: # Check against small tolerance\n            curve_point += basis_val * control_points[i]\n            \n    return curve_point\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and verify endpoint interpolation.\n    \"\"\"\n    test_cases = [\n        # Case 1: 2D quadratic\n        {\n            \"p\": 2,\n            \"control_points\": np.array([\n                [0, 0], [1, 2], [2, 0.5], [3, 3], [4, 0]\n            ]),\n            \"knot_vector\": None \n        },\n        # Case 2: 2D cubic, Bezier-like\n        {\n            \"p\": 3,\n            \"control_points\": np.array([\n                [0, 0], [1, 2], [3, 2], [4, 0]\n            ]),\n            \"knot_vector\": None\n        },\n        # Case 3: 2D cubic, non-uniform knots\n        {\n            \"p\": 3,\n            \"control_points\": np.array([\n                [0, 0], [1, 1], [2, -1], [3, 2], [4, -0.5], [5, 1.5], [6, 0]\n            ]),\n            \"knot_vector\": np.array([0, 0, 0, 0, 0.15, 0.6, 0.85, 1, 1, 1, 1])\n        },\n        # Case 4: 2D linear\n        {\n            \"p\": 1,\n            \"control_points\": np.array([\n                [0, 1], [1, 0], [2, 1.5]\n            ]),\n            \"knot_vector\": None\n        },\n        # Case 5: 3D cubic\n        {\n            \"p\": 3,\n            \"control_points\": np.array([\n                [0, 0, 0], [1, 2, 1], [2, -1, 2], [3, 3, 2], [4, 0, 1], [5, 1, 0]\n            ]),\n            \"knot_vector\": None\n        }\n    ]\n\n    results = []\n    tolerance = 1e-9\n\n    for case in test_cases:\n        p = case[\"p\"]\n        P = case[\"control_points\"]\n        n = len(P) - 1\n\n        if case[\"knot_vector\"] is None:\n            T = build_clamped_uniform_knot_vector(n, p)\n        else:\n            T = case[\"knot_vector\"]\n        \n        # Endpoints of the parametric domain for a clamped knot vector\n        u_left = T[p]\n        u_right = T[n + 1]\n\n        # Evaluate curve at endpoints\n        C_left = b_spline_eval(u_left, p, P, T)\n        C_right = b_spline_eval(u_right, p, P, T)\n\n        # Verify interpolation\n        dist_left = np.linalg.norm(C_left - P[0])\n        dist_right = np.linalg.norm(C_right - P[-1])\n\n        check_left = dist_left = tolerance\n        check_right = dist_right = tolerance\n        \n        results.append(check_left and check_right)\n\n    # Format output as required\n    print(f\"[{','.join(map(str, results))}]\".lower())\n\nsolve()\n```", "id": "3207506"}, {"introduction": "在掌握了 B 样条曲线的基本求值之后，下一步是探索如何控制其局部形状。节点重复度（knot multiplicity）是 B 样条中一个强大的工具，它允许我们精确地控制曲线的连续性，从而创造出平滑的过渡或尖锐的角点。本练习 [@problem_id:3099558] 将引导您实现 B 样条的导数，并用它来量化节点重复度对曲线几何形状的影响，从而将理论知识与视觉和数值结果联系起来。", "problem": "您将研究在三次 B-样条中增加节点重数如何影响局部形状，包括相对于基准曲线可能出现的过冲以及尖角或平坦点的产生。请在纯数学环境下，使用二维控制点和标准 B-样条定义进行全部工作。您的程序必须是一个完整、可运行的实现，能够从第一性原理出发计算曲线及其导数，并为一个小型测试套件计算量化指标。\n\n基本依据和定义：\n- 一个次数为 $p$、控制点为 $\\{\\mathbf{P}_i\\}_{i=0}^{N-1}$、非递减节点矢量为 $\\{t_j\\}_{j=0}^{N+p}$ 的 B-样条曲线定义为\n$$\n\\mathbf{C}(t) = \\sum_{i=0}^{N-1} N_{i,p}(t)\\,\\mathbf{P}_i,\n$$\n其中 $N_{i,p}(t)$ 是由 Cox–de Boor 递归公式定义的 B-样条基函数：\n$$\nN_{i,0}(t) =\n\\begin{cases}\n1,  t_i \\le t  t_{i+1},\\\\\n0,  \\text{否则},\n\\end{cases}\n$$\n且对于 $p \\ge 1$\n$$\nN_{i,p}(t) = \\frac{t - t_i}{t_{i+p} - t_i} N_{i,p-1}(t) + \\frac{t_{i+p+1} - t}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(t),\n$$\n约定分母为零的项贡献为 $0$。\n- 曲线的导数使用基函数的导数：\n$$\n\\mathbf{C}'(t) = \\sum_{i=0}^{N-1} \\frac{d N_{i,p}(t)}{dt}\\,\\mathbf{P}_i,\n$$\n其中\n$$\n\\frac{d N_{i,p}(t)}{dt} = \\frac{p}{t_{i+p} - t_i} N_{i,p-1}(t) - \\frac{p}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(t),\n$$\n同样，将除以零的操作解释为贡献 $0$。\n- 对于一个 $p$ 次 B-样条中重数为 $m$ 的节点，曲线在该节点的连续性为 $C^{p-m}$，意味着前 $p-m$ 阶导数是连续的，而第 $(p-m+1)$ 阶导数通常存在一个跳跃。特别地，如果 $m = p+1$，曲线在该节点处会断开（不具有位置连续性）。\n\n场景和建模设置：\n- 使用次数 $p = 3$（三次）和 $N = 8$ 个位于 $\\mathbb{R}^2$ 中的控制点。\n- 使用两端重复的开放式节点矢量：\n$$\n\\underbrace{0,0,0,0}_{p+1\\text{ 次}}, \\text{内部节点}, \\underbrace{1,1,1,1}_{p+1\\text{ 次}}.\n$$\n- 设感兴趣的内部节点位置为 $u_0 = 0.5$。内部节点条目的总数为 $N - p - 1 = 4$。对于在 $u_0$ 处选定的重数 $m \\in \\{1,2,3,4\\}$，按如下方式构造内部节点多重集。包含 $m$ 个 $u_0$ 的副本，并从固定列表 $\\{0.25,\\,0.33,\\,0.75\\}$ 中使用剩余的 $4 - m$ 个条目，从该列表中取最小的 $4-m$ 个元素，然后对所有内部条目进行排序。这样对每个 $m$ 都能产生恰好四个内部节点条目。\n- 定义两种控制点场景：\n  - 场景 A（驼峰状）：\n    - $\\mathbf{P}_0=(0.0, 0.0)$,\n    - $\\mathbf{P}_1=(1.0, 1.0)$,\n    - $\\mathbf{P}_2=(2.0, 2.0)$,\n    - $\\mathbf{P}_3=(3.0, 4.0)$,\n    - $\\mathbf{P}_4=(4.0, 2.0)$,\n    - $\\mathbf{P}_5=(5.0, 1.5)$,\n    - $\\mathbf{P}_6=(6.0, 1.2)$,\n    - $\\mathbf{P}_7=(7.0, 1.1)$.\n  - 场景 B（局部平坦区域）：\n    - $\\mathbf{P}_0=(0.0, 0.0)$,\n    - $\\mathbf{P}_1=(1.0, 0.5)$,\n    - $\\mathbf{P}_2=(2.0, 1.0)$,\n    - $\\mathbf{P}_3=(3.0, 1.0)$,\n    - $\\mathbf{P}_4=(4.0, 1.0)$,\n    - $\\mathbf{P}_5=(5.0, 1.0)$,\n    - $\\mathbf{P}_6=(6.0, 1.2),\n    - $\\mathbf{P}_7=(7.0, 2.0)$.\n\n待计算的量：\n- 将基准曲线定义为在 $u_0=0.5$ 处重数 $m=1$ 的三次 B-样条，使用上述内部节点构造方法。将此基准曲线表示为 $\\mathbf{C}_{\\mathrm{base}}(t)$。\n- 对于每个场景和每个 $m \\in \\{1,2,3,4\\}$，构造相应的节点矢量并计算：\n  1. 在参数值的均匀样本上与基准曲线的最大绝对偏差：\n     $$\n     D_{\\max}(m) = \\max_{t \\in \\mathcal{T}} \\left\\lVert \\mathbf{C}_m(t) - \\mathbf{C}_{\\mathrm{base}}(t) \\right\\rVert_2.\n     $$\n     使用欧几里得范数。设样本 $\\mathcal{T}$ 为开区间 $(0,1)$ 内的 $4001$ 个等距点，例如 $t_k$ 从 $10^{-6}$ 到 $1-10^{-6}$ 线性间隔，以避免在节点处精确求值。\n  2. 内部节点 $u_0$ 处斜率不连续性的数值度量：\n     $$\n     J(m) = \\left\\lVert \\mathbf{C}_m'(u_0^+) - \\mathbf{C}_m'(u_0^-) \\right\\rVert_2.\n     $$\n     为评估单侧导数而不精确命中节点，选择\n     $$\n     \\delta = \\min\\left(0.1\\,(u_0 - u_\\text{L}),\\, 0.1\\,(u_\\text{R} - u_0),\\, 10^{-3}\\right),\n     $$\n     其中 $u_\\text{L}$ 是所构造的节点矢量中严格小于 $u_0$ 的最大节点，而 $u_\\text{R}$ 是严格大于 $u_0$ 的最小节点。然后通过使用上述基函数导数公式评估 $\\mathbf{C}_m'(u_0 - \\delta)$ 和 $\\mathbf{C}_m'(u_0 + \\delta)$ 来近似单侧导数。它们差值的欧几里得范数即为 $J(m)$。\n\n测试套件和要求输出：\n- 使用场景 A 和场景 B 的控制点。\n- 对于每个场景，评估 $m = 1, 2, 3, 4$ 时的序对 $\\left(D_{\\max}(m), J(m)\\right)$。\n- 将每个报告的浮点数结果四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含两个场景的所有结果，形式为用方括号括起来的逗号分隔列表。排序必须是：\n  - 场景 A: $D_{\\max}(1)$, $J(1)$, $D_{\\max}(2)$, $J(2)$, $D_{\\max}(3)$, $J(3)$, $D_{\\max}(4)$, $J(4)$,\n  - 其后以相同顺序跟着场景 B 的结果。\n即，输出格式为\n$$\n[\\;D_{\\max}^{A}(1),J^{A}(1),D_{\\max}^{A}(2),J^{A}(2),D_{\\max}^{A}(3),J^{A}(3),D_{\\max}^{A}(4),J^{A}(4),D_{\\max}^{B}(1),J^{B}(1),D_{\\max}^{B}(2),J^{B}(2),D_{\\max}^{B}(3),J^{B}(3),D_{\\max}^{B}(4),J^{B}(4)\\;].\n$$\n所有量都是无量纲的，因此不需要单位。", "solution": "用户提供了一个关于 B-样条曲线属性的明确定义的计算问题。我将首先验证问题陈述，然后基于基本原理提供一个全面的解决方案。\n\n### 问题验证\n\n1.  **提取已知条件**：\n    - **曲线类型**：$p=3$ 次的 B-样条曲线，有 $N=8$ 个 $\\mathbb{R}^2$ 中的控制点。\n    - **曲线定义**：$\\mathbf{C}(t) = \\sum_{i=0}^{N-1} N_{i,p}(t)\\,\\mathbf{P}_i$，其中基函数 $N_{i,p}(t)$ 由 Cox–de Boor 递归公式定义。\n    - **曲线导数**：$\\mathbf{C}'(t) = \\sum_{i=0}^{N-1} \\frac{d N_{i,p}(t)}{dt}\\,\\mathbf{P}_i$，其中 $\\frac{d N_{i,p}(t)}{dt} = \\frac{p}{t_{i+p} - t_i} N_{i,p-1}(t) - \\frac{p}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(t)$。\n    - **节点矢量**：开放式节点矢量，在 $0$ 处有 $p+1=4$ 个节点，在 $1$ 处有 $4$ 个节点。它包含 $N-p-1=4$ 个内部节点。\n    - **内部节点构造**：对于在 $u_0 = 0.5$ 处重数为 $m \\in \\{1,2,3,4\\}$ 的情况，四个内部节点由 $m$ 个 $0.5$ 和集合 $\\{0.25, 0.33, 0.75\\}$ 中最小的 $4-m$ 个值组成，并排序。\n    - **控制点场景**：提供了两组控制点，场景 A（驼峰状）和场景 B（局部平坦区域）。\n    - **度量指标**：\n        1.  $D_{\\max}(m) = \\max_{t \\in \\mathcal{T}} \\left\\lVert \\mathbf{C}_m(t) - \\mathbf{C}_{\\mathrm{base}}(t) \\right\\rVert_2$，其中 $\\mathbf{C}_{\\mathrm{base}}$ 是 $m=1$ 时的曲线。评估网格 $\\mathcal{T}$ 在 $(0,1)$ 中有 $4001$ 个点。\n        2.  $J(m) = \\left\\lVert \\mathbf{C}_m'(u_0^+) - \\mathbf{C}_m'(u_0^-) \\right\\rVert_2$，其中单侧导数在 $u_0 \\pm \\delta$ 处近似。$\\delta$ 定义为 $\\min\\left(0.1\\,(u_0 - u_\\text{L}),\\, 0.1\\,(u_\\text{R} - u_0),\\, 10^{-3}\\right)$。\n    - **输出格式**：单行输出，包含一个由逗号分隔的列表，内含 16 个浮点数值，四舍五入到六位小数，代表两种场景下每个 $m \\in \\{1,2,3,4\\}$ 对应的 $(D_{\\max}(m), J(m))$。\n\n2.  **依据标准验证**：\n    - **科学依据**：该问题植根于 B-样条的标准数学理论，这是计算科学和计算机辅助几何设计的核心课题。所有定义和公式都是正确的。\n    - **适定性**：该问题以高度精确的方式进行了规定。所有参数、数据、构造规则以及待计算量的公式都已明确给出。整个设置是自洽的，足以产生一个唯一的、确定性的解。\n    - **客观性**：问题陈述完全客观，使用了精确的数学语言和量化定义。没有主观或模糊的元素。\n    - **其他标准**：该问题并非微不足道，因为它需要一个从第一性原理出发的对非平凡算法的正确实现。它没有矛盾、不切实际或不适定的地方。\n\n3.  **结论与行动**：\n    问题陈述是**有效的**。我将继续制定并实施一个解决方案。\n\n### 解决方案设计\n\n该解决方案需要根据提供的基本定义来实现 B-样条曲线求值及其导数。Cox-de Boor 公式的直接递归实现在计算上是低效的。将采用一种更稳健、性能更好的方法，该方法基于标准文献（例如 Piegl 和 Tiller 的《The NURBS Book》）中的算法。这符合“从第一性原理出发”的要求，因为这些算法是数学定义的直接实现。\n\n1.  **核心算法**：\n    - **节点区间搜索**：将实现一个函数 `find_span` 来高效地定位包含给定参数值 $t$ 的节点区间（span）。这是高效计算基函数的前提，通常使用二分搜索实现。\n    - **基函数求值**：将实现一个函数 `basis_funs`，采用迭代的动态规划方法（《The NURBS Book》中的算法 A2.2）来计算在参数 $t$ 所在节点区间内，给定次数的所有非零基函数的值。这比朴素的递归方法效率要高得多。\n    - **曲线求值**：函数 `evaluate_bspline` 将结合 `find_span` 和 `basis_funs` 来计算曲线上的点 $\\mathbf{C}(t)$。它找到相关的节点区间，计算非零基函数，然后与相应的控制点进行加权求和。\n    - **曲线导数求值**：函数 `evaluate_bspline_derivative` 将通过直接实现求和 $\\sum_i \\frac{d N_{i,p}(t)}{dt} \\mathbf{P}_i$ 来计算 $\\mathbf{C}'(t)$。基函数的导数 $\\frac{d N_{i,p}(t)}{dt}$ 将使用提供的公式计算，而这又需要 $p-1$ 次的基函数。这些将使用相同的 `basis_funs` 算法高效计算。\n\n2.  **单个案例（$m$，场景）的工作流程**：\n    - **节点矢量构造**：通过连接起始的重复节点（$p+1$ 个零）、四个指定的内部节点和结尾的重复节点（$p+1$ 个一）来构造长度为 $N+p+1=12$ 的完整节点矢量。\n    - **为计算 $D_{\\max}$ 进行曲线求值**：对于每个 $m$，在 $(0,1)$ 内的 $4001$ 个采样点上计算曲线 $\\mathbf{C}_m(t)$。当 $m=1$ 时，这些点定义了基准曲线 $\\mathbf{C}_{\\mathrm{base}}$。当 $m1$ 时，计算与相应基准点的欧几里得距离，这些距离的最大值即为 $D_{\\max}(m)$。根据定义，$D_{\\max}(1)=0$。\n    - **导数跳跃计算 $J(m)$**：根据问题的规则确定小偏移量 $\\delta$。在 $u_0 - \\delta$ 和 $u_0 + \\delta$ 处评估导数 $\\mathbf{C}_m'(t)$。这两个导数矢量之差的欧几里得范数即为跳跃值 $J(m)$。B-样条的连续性属性表明 $J(1)$ 和 $J(2)$ 应该接近于零，而 $J(3)$ 和 $J(4)$ 可能显著非零，这为实现提供了一个很好的健全性检查。\n\n3.  **整体结构**：\n    主程序将遍历两种控制点场景。在每个场景中，它将遍历重数 $m$ 从 $1$ 到 $4$。在每个子案例中，它将构造适当的节点矢量，计算序对 $(D_{\\max}(m), J(m))$，并存储结果。最后，所有 16 个标量结果将按要求格式化为单个字符串。", "answer": "```python\nimport numpy as np\n\ndef find_span(num_cp, degree, t, knots):\n    \"\"\"\n    Finds the knot span index for a given parameter t.\n    num_cp: number of control points (N).\n    degree: degree of the curve (p).\n    t: parameter value.\n    knots: knot vector.\n    Returns the index k such that knots[k] = t  knots[k+1].\n    \"\"\"\n    # For t=1.0, which can occur at the end of the domain for an open knot vector.\n    # The valid parameter range is [knots[p], knots[N]]. For an open knot vector,\n    # this is [0, 1]. The last span index is N-1.\n    if t >= knots[num_cp]:\n        return num_cp - 1\n    \n    # Binary search for the span. The search space is [p, N-1].\n    low = degree\n    high = num_cp\n    \n    while low  high:\n        mid = (low + high) // 2\n        if t  knots[mid]:\n            high = mid\n        else:\n            low = mid + 1\n    return low - 1\n\ndef basis_funs(span, t, degree, knots):\n    \"\"\"\n    Computes the non-zero B-spline basis functions for a given parameter t.\n    (Algorithm A2.2 from The NURBS Book by Piegl and Tiller).\n    span: knot span index.\n    t: parameter value.\n    degree: degree of the curve.\n    knots: knot vector.\n    Returns an array of p+1 basis function values, N_{span-degree, degree}, ..., N_{span, degree}.\n    \"\"\"\n    basis = np.zeros(degree + 1)\n    left = np.zeros(degree + 1)\n    right = np.zeros(degree + 1)\n    \n    basis[0] = 1.0\n    for j in range(1, degree + 1):\n        left[j] = t - knots[span + 1 - j]\n        right[j] = knots[span + j] - t\n        saved = 0.0\n        for r in range(j):\n            den = knots[span + r + 1] - knots[span + r + 1 - j]\n            if den == 0.0:\n                temp = 0.0\n            else:\n                temp = basis[r] / den\n            basis[r] = saved + right[r + 1] * temp\n            saved = left[j - r] * temp\n        basis[j] = saved\n    return basis\n\ndef evaluate_bspline(t, num_cp, degree, knots, control_points):\n    \"\"\"\n    Evaluates a B-spline curve at a given parameter t.\n    \"\"\"\n    if t  knots[degree] or t > knots[num_cp]:\n        if t = knots[degree]: return control_points[0]\n        else: return control_points[-1]\n\n    span = find_span(num_cp, degree, t, knots)\n    basis_values = basis_funs(span, t, degree, knots)\n    \n    curve_point = np.zeros_like(control_points[0], dtype=float)\n    for i in range(degree + 1):\n        curve_point += basis_values[i] * control_points[span - degree + i]\n    return curve_point\n\ndef evaluate_bspline_derivative(t, num_cp, degree, knots, control_points):\n    \"\"\"\n    Evaluates the derivative of a B-spline curve at a given parameter t.\n    \"\"\"\n    if t  knots[degree] or t > knots[num_cp]:\n        return np.zeros_like(control_points[0], dtype=float)\n\n    span = find_span(num_cp, degree, t, knots)\n    # Basis functions of degree p-1 are needed for derivative of degree p\n    basis_values_p_minus_1 = basis_funs(span, t, degree - 1, knots)\n    \n    deriv_point = np.zeros_like(control_points[0], dtype=float)\n    \n    # Loop over control points whose basis functions may be non-zero\n    for i in range(span - degree, span + 1):\n        # Contribution from control point P_i\n        # dN_{i,p}/dt = p/(t_{i+p}-t_i) * N_{i,p-1} - p/(t_{i+p+1}-t_{i+1}) * N_{i+1,p-1}\n        \n        # Term 1: involving N_{i, p-1}\n        num1 = 0.0\n        # Non-zero basis functions of degree p-1 for span k are N_{k-(p-1),p-1} to N_{k,p-1}.\n        if (span - (degree - 1)) = i = span:\n            num1 = basis_values_p_minus_1[i - (span - (degree - 1))]\n        \n        den1 = knots[i + degree] - knots[i]\n        term1 = 0.0\n        if den1 != 0.0:\n            term1 = degree * num1 / den1\n\n        # Term 2: involving N_{i+1, p-1}\n        num2 = 0.0\n        if (span - (degree - 1)) = (i + 1) = span:\n            num2 = basis_values_p_minus_1[i + 1 - (span - (degree - 1))]\n\n        den2 = knots[i + degree + 1] - knots[i + 1]\n        term2 = 0.0\n        if den2 != 0.0:\n            term2 = degree * num2 / den2\n        \n        d_basis = term1 - term2\n        deriv_point += d_basis * control_points[i]\n        \n    return deriv_point\n\n\ndef solve():\n    p = 3\n    N = 8\n    u0 = 0.5\n    \n    P_A = np.array([\n        [0.0, 0.0], [1.0, 1.0], [2.0, 2.0], [3.0, 4.0],\n        [4.0, 2.0], [5.0, 1.5], [6.0, 1.2], [7.0, 1.1]\n    ], dtype=float)\n    \n    P_B = np.array([\n        [0.0, 0.0], [1.0, 0.5], [2.0, 1.0], [3.0, 1.0],\n        [4.0, 1.0], [5.0, 1.0], [6.0, 1.2], [7.0, 2.0]\n    ], dtype=float)\n\n    scenarios = [(\"A\", P_A), (\"B\", P_B)]\n    interior_knot_pool = [0.25, 0.33, 0.75]\n    \n    t_samples = np.linspace(1e-6, 1.0 - 1e-6, 4001)\n    \n    all_results = []\n    \n    for _, P in scenarios:\n        C_base_pts = None\n        \n        for m in range(1, 5):\n            # 1. Construct knot vector\n            num_other_knots = 4 - m\n            interior_knots = sorted(interior_knot_pool[:num_other_knots] + [u0] * m)\n            knots = np.concatenate((np.zeros(p + 1, dtype=float), np.array(interior_knots, dtype=float), np.ones(p + 1, dtype=float)))\n\n            # 2. Compute curve points for D_max calculation\n            C_m_pts = np.array([evaluate_bspline(t, N, p, knots, P) for t in t_samples])\n            \n            if m == 1:\n                C_base_pts = C_m_pts\n                D_max = 0.0\n            else:\n                deviations = np.linalg.norm(C_m_pts - C_base_pts, axis=1)\n                D_max = np.max(deviations)\n\n            # 3. Compute slope discontinuity J(m)\n            unique_knots = sorted(list(set(knots)))\n            u_L_idx = np.searchsorted(unique_knots, u0, side='left') - 1\n            u_R_idx = np.searchsorted(unique_knots, u0, side='right')\n            u_L = unique_knots[u_L_idx] if u_L_idx >= 0 else knots[0]\n            u_R = unique_knots[u_R_idx] if u_R_idx  len(unique_knots) else knots[-1]\n            \n            term_L = 0.1 * (u0 - u_L) if u_L  u0 else np.inf\n            term_R = 0.1 * (u_R - u0) if u_R > u0 else np.inf\n            delta = min(term_L, term_R, 1e-3)\n            \n            dC_left = evaluate_bspline_derivative(u0 - delta, N, p, knots, P)\n            dC_right = evaluate_bspline_derivative(u0 + delta, N, p, knots, P)\n            J_m = np.linalg.norm(dC_right - dC_left)\n            \n            all_results.extend([D_max, J_m])\n            \n    print(f\"[{','.join(f'{r:.6f}' for r in all_results)}]\")\n\nsolve()\n```", "id": "3099558"}, {"introduction": "B 样条的应用远不止于计算机图形学。这项高级练习将展示 B 样条在更广泛的科学计算领域中的威力，特别是作为函数逼近的基函数。您将实现一个 $L^2$ 投影，将一个给定的函数（如 $\\sin(10 x)$）用 B 样条函数进行逼近，这是有限元方法（FEM）等数值技术的核心思想。通过执行收敛性研究 [@problem_id:3099508]，您将亲眼验证当网格细化时，逼近误差如何以理论预测的速率 $O(h^{p+1})$ 下降，从而深刻体会 B 样条在数值分析中的力量。", "problem": "您的任务是设计并实现一个数值实验，以在计算科学导论的背景下展示B样条的逼近能力。该实验必须通过一个完整的、可运行的程序来定义、执行并报告其结果。该实验专注于将一个光滑目标函数投影到一个样条空间上，并研究逼近误差在均匀网格加密下的变化规律。\n\n定义域为闭区间 $[0,1]$。目标函数为 $f(x) = \\sin(10 x)$，其中正弦函数的参数以弧度为单位。样条空间是次数为 $p$、在 $[0,1]$ 上具有开放均匀节点矢量的B样条空间。节点矢量应包含 $M$ 个均匀单元，其中网格尺寸 $h = 1/M$，端点 $0$ 和 $1$ 各重复 $p+1$ 次，内部节点位于均匀细分点 $x = i h$ 处，其中 $i = 1,2,\\ldots,M-1$。该空间中的基函数数量为 $n = M + p$。\n\n投影为 $L^2$（平方可积）投影。令 $S_{p,h}$ 表示次数为 $p$、网格尺寸为 $h$ 的样条空间。$f$ 的 $L^2$ 投影 $s \\in S_{p,h}$ 由关于样条基的伽辽金正交性条件所刻画：对于每个基函数 $v \\in S_{p,h}$，残差满足 $\\int_0^1 (f(x) - s(x)) \\, v(x) \\, dx = 0$。您必须从第一性原理出发，使用标准的递推定义（Cox–de Boor 递推）来实现归一化B样条基函数的求值，并组装对 $s$ 的系数施加这些正交性条件的线性系统。在组装和误差计算中的所有积分都必须在每个子区间上使用足够高阶的高斯积分进行数值计算，以使积分误差相对于样条逼近误差可以忽略不计。在每个单元上使用高斯-勒让德积分，每个单元至少有 $50$ 个积分点。所有计算都必须使用双精度。角度必须以弧度解释，范数和积分不带物理单位，因为定义域和函数是无量纲的。\n\n$L^2$ 误差是差值 $f - s$ 的 $L^2$ 范数，定义为 $\\| f - s \\|_{L^2(0,1)} = \\left( \\int_0^1 (f(x) - s(x))^2 \\, dx \\right)^{1/2}$。通过逐单元的高斯积分实现对此误差的可靠数值计算。\n\n您必须进行一项收敛性研究，其中 $h$ 被均匀加密，并对每次加密测量误差。对于固定的次数 $p$，考虑对应于 $M \\in \\{8, 16, 32, 64\\}$ 的网格尺寸。对于每个次数 $p \\in \\{0, 1, 2, 3\\}$，计算这些网格尺寸下的 $L^2$ 误差列表，然后通过对 $\\log(\\text{误差})$ 与 $\\log(h)$ 进行线性最小二乘拟合来计算观测收敛率；拟合的斜率即为观测到的收敛率。对于光滑的 $f$，渐近期望是收敛率应近似为 $p+1$。\n\n您的程序必须实现：\n- 为给定的 $p$ 和 $M$ 构建开放均匀节点矢量。\n- 通过 Cox–de Boor 递推，在给定点集上计算所有次数为 $p$ 的归一化B样条基函数的值。\n- 使用数值积分组装 $L^2$ 投影的线性系统。\n- 求解线性系统得到样条系数，并通过积分计算 $L^2$ 误差。\n- 从 $(h, \\text{误差})$ 数据计算观测收敛率。\n\n测试套件规范：\n- 情况 1：$p = 0$，其中 $M \\in \\{8, 16, 32, 64\\}$。\n- 情况 2：$p = 1$，其中 $M \\in \\{8, 16, 32, 64\\}$。\n- 情况 3：$p = 2$，其中 $M \\in \\{8, 16, 32, 64\\}$。\n- 情况 4：$p = 3$，其中 $M \\in \\{8, 16, 32, 64\\}$。\n\n对于每种情况，报告观测到的收敛率，表示为一个四舍五入到三位小数的浮点数。这四个值共同构成最终输出。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按 $p$ 升序排列的四个观测收敛率，格式为方括号括起来的逗号分隔列表，例如 $[r_0,r_1,r_2,r_3]$，其中每个 $r_p$ 是一个四舍五入到三位小数的浮点数。不应打印任何额外的文本或行。", "solution": "我们从B样条和 $L^2$ 投影的基本定义开始。\n\n设 $[0,1]$ 被均匀划分为 $M$ 个单元，网格尺寸为 $h = 1/M$。对于给定的次数 $p \\in \\mathbb{N}_0$，我们考虑开放均匀节点矢量。将节点矢量记为 $\\{t_i\\}_{i=0}^{K-1}$，其中端点重复 $p+1$ 次，内部节点位于 $i h$ 处，其中 $i=1,2,\\ldots,M-1$。明确地，\n$$\nt_0 = t_1 = \\cdots = t_p = 0,\\quad\nt_{p+1} = h,\\quad\nt_{p+2} = 2h,\\quad \\ldots,\\quad t_{p+M-1} = (M-1)h,\\quad\nt_{K-p-1} = t_{K-p} = \\cdots = t_{K-1} = 1,\n$$\n其中 $K = (M-1) + 2(p+1)$，基函数的数量为 $n = K - p - 1 = M + p$。归一化B样条基函数 $\\{N_{i,p}(x)\\}_{i=0}^{n-1}$ 由 Cox–de Boor 递推递归定义。对于分段常数（$p = 0$）的基准情况是半开支撑区间的指示函数：\n$$\nN_{i,0}(x) = \n\\begin{cases}\n1  \\text{if } t_i \\le x  t_{i+1}, \\\\\n0  \\text{otherwise}.\n\\end{cases}\n$$\n对于 $p \\ge 1$ 的递推定义是\n$$\nN_{i,p}(x) = \\alpha_{i,p}(x)\\, N_{i,p-1}(x) + \\beta_{i,p}(x)\\, N_{i+1,p-1}(x),\n$$\n其中混合系数为\n$$\n\\alpha_{i,p}(x) = \n\\begin{cases}\n\\dfrac{x - t_i}{t_{i+p} - t_i}  \\text{if } t_{i+p} > t_i,\\\\\n0  \\text{otherwise},\n\\end{cases}\n\\qquad\n\\beta_{i,p}(x) =\n\\begin{cases}\n\\dfrac{t_{i+p+1} - x}{t_{i+p+1} - t_{i+1}}  \\text{if } t_{i+p+1} > t_{i+1},\\\\\n0  \\text{otherwise}.\n\\end{cases}\n$$\n这些定义意味着基函数是非负的，在 $[t_i, t_{i+p+1}]$ 上具有最小的局部支撑，并在 $[0,1]$ 上构成单位分解。\n\n令 $S_{p,h} = \\operatorname{span}\\{N_{i,p}\\}_{i=0}^{n-1}$ 为样条空间。$f$ 在 $S_{p,h}$ 上的 $L^2$ 投影 $s \\in S_{p,h}$ 由伽辽金正交性定义：\n$$\n\\int_0^1 \\left( f(x) - s(x) \\right) v(x) \\, dx = 0 \\quad \\text{for all } v \\in S_{p,h}.\n$$\n将 $s(x) = \\sum_{i=0}^{n-1} c_i\\, N_{i,p}(x)$ 写入并选择检验函数 $v = N_{j,p}$（其中 $j = 0,1,\\ldots,n-1$），我们得到线性系统\n$$\n\\sum_{i=0}^{n-1} c_i \\int_0^1 N_{i,p}(x) N_{j,p}(x) \\, dx = \\int_0^1 f(x) N_{j,p}(x) \\, dx,\\quad j=0,\\ldots,n-1.\n$$\n通过以下方式定义质量矩阵 $M \\in \\mathbb{R}^{n \\times n}$ 和右端项 $b \\in \\mathbb{R}^n$\n$$\nM_{j,i} = \\int_0^1 N_{i,p}(x) N_{j,p}(x) \\, dx,\\qquad\nb_j = \\int_0^1 f(x) N_{j,p}(x) \\, dx,\n$$\n系数 $c = (c_0,\\ldots,c_{n-1})^\\top$ 满足\n$$\nM c = b.\n$$\n$L^2$ 逼近误差则为\n$$\n\\| f - s \\|_{L^2(0,1)} = \\left( \\int_0^1 \\left( f(x) - \\sum_{i=0}^{n-1} c_i N_{i,p}(x) \\right)^2 \\, dx \\right)^{1/2}.\n$$\n\n数值积分通过在每个单元上进行 $q$ 阶的高斯-勒让德积分来执行。设参考区间 $[-1,1]$ 上的高斯-勒让德点和权重为 $\\{\\xi_k, w_k\\}_{k=1}^q$。对于单元区间 $[a,b]$，仿射映射 $x = \\frac{b-a}{2} \\xi + \\frac{a+b}{2}$ 产生物理积分点 $\\{x_k\\}$ 和权重 $\\{ \\hat{w}_k = \\frac{b-a}{2} w_k \\}$。对所有单元求和，$[0,1]$ 上的积分可近似为\n$$\n\\int_0^1 g(x)\\, dx \\approx \\sum_{e=1}^{M} \\sum_{k=1}^q \\hat{w}_{e,k}\\, g(x_{e,k}).\n$$\n在我们的设定中，我们取 $q \\ge 50$ 以确保积分误差可以忽略不计；这一选择可以安全地处理质量矩阵中的多项式乘积和右端项中的振荡项 $\\sin(10 x)$。\n\n算法步骤如下：\n1. 对于给定的 $p$ 和 $M$，构建开放均匀节点矢量 $\\{t_i\\}$ 并计算基函数的数量 $n$。\n2. 通过遍历所有单元并将 $q$ 点高斯-勒让德法则映射到每个单元上来创建全局积分点和权重。\n3. 使用 Cox–de Boor 递推在所有积分点上计算所有基函数 $\\{N_{i,p}\\}_{i=0}^{n-1}$ 的值。将计算结果组织成一个矩阵 $B \\in \\mathbb{R}^{n \\times N_q}$，其中 $N_q = M \\cdot q$ 是积分点的总数。\n4. 使用加权内积组装质量矩阵，\n$$\nM = B \\, \\operatorname{diag}(w) \\, B^\\top,\n$$\n其中 $w \\in \\mathbb{R}^{N_q}$ 是全局积分权重。\n5. 通过以下方式组装右端项\n$$\nb = B \\left( w \\odot f(x) \\right),\n$$\n其中 $f(x) = \\sin(10 x)$ 在积分点处求值，$\\odot$ 表示逐点相乘。\n6. 以双精度求解线性系统 $M c = b$ 以获得系数 $c$。\n7. 通过 $s(x) = \\sum_i c_i N_{i,p}(x)$ 计算样条逼近在积分点处的值，其向量化形式为 $s = B^\\top c$。\n8. 通过以下方式计算 $L^2$ 误差\n$$\n\\| f - s \\|_{L^2(0,1)} \\approx \\left( \\sum_{k=1}^{N_q} w_k \\left( f(x_k) - s(x_k) \\right)^2 \\right)^{1/2}.\n$$\n9. 对于每个次数 $p \\in \\{0,1,2,3\\}$ 和网格尺寸 $M \\in \\{8,16,32,64\\}$，计算误差，然后对 $\\log(\\text{误差})$ 与 $\\log(h)$ 进行最小二乘拟合以估计斜率 $r_p$。具体来说，如果我们记 $X = \\log(h)$ 和 $Y = \\log(\\text{误差})$，则拟合的斜率为\n$$\nr_p = \\frac{\\sum_i (X_i - \\bar{X})(Y_i - \\bar{Y})}{\\sum_i (X_i - \\bar{X})^2},\n$$\n其中求和遍历所有加密级别，上划线表示平均值。在实践中，这通过一次多项式拟合获得。\n\n根据样条空间的逼近理论，对于足够光滑的 $f$ 和均匀加密， $L^2$ 投影误差满足\n$$\n\\| f - s \\|_{L^2(0,1)} \\le C\\, h^{p+1} \\, |f|_{H^{p+1}(0,1)},\n$$\n其中 $C$ 是一个与 $h$ 无关的常数，这意味着观测到的收敛率接近 $p+1$。测试套件包括 $p=0$（分段常数）作为一个重要的边界情况，以及逐渐增加到 $p=3$ 的更高次数，其网格范围从相对粗糙的网格（$M=8$）到精细的网格（$M=64$），通过开放节点构造覆盖了理想情况和端点处的边界条件。\n\n程序输出四个观测到的收敛率，四舍五入到三位小数，以按 $p$ 递增顺序排列的、由方括号括起来的逗号分隔列表形式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef open_uniform_knots(M: int, p: int) -> np.ndarray:\n    \"\"\"\n    Construct open uniform knot vector on [0,1] with M elements and degree p.\n    Endpoints are repeated p+1 times. Interior knots are at i/M for i=1..M-1.\n    \"\"\"\n    interior = np.linspace(0.0, 1.0, M + 1)\n    # Exclude endpoints from interior\n    interior = interior[1:-1]\n    # Build knot vector\n    knots = np.concatenate([\n        np.zeros(p + 1),\n        interior,\n        np.ones(p + 1)\n    ])\n    return knots\n\ndef bspline_basis_matrix(knots: np.ndarray, p: int, x: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Evaluate all normalized B-spline basis functions of degree p defined by 'knots'\n    at points x using Cox-de Boor recursion. Returns shape (n_basis, len(x)).\n    \"\"\"\n    K = len(knots)\n    n_basis = K - p - 1\n    N = np.zeros((n_basis, x.size), dtype=np.float64)\n\n    # Base case p=0: indicator of half-open intervals [t_i, t_{i+1})\n    # Gauss-Legendre points lie inside elements, so endpoint handling is minimal.\n    for i in range(n_basis):\n        left = knots[i]\n        right = knots[i + 1]\n        # Indicator: include left, exclude right\n        mask = (x >= left)  (x  right)\n        N[i, mask] = 1.0\n    # Handle the very end point x == 1 (if present) to ensure partition of unity\n    # Assign to the last basis.\n    if np.any(np.isclose(x, knots[-1])):\n        N[-1, np.isclose(x, knots[-1])] = 1.0\n\n    # Recursion for p>=1\n    for d in range(1, p + 1):\n        N_next = np.zeros((n_basis, x.size), dtype=np.float64)\n        for i in range(n_basis):\n            # First term\n            denom1 = knots[i + d] - knots[i]\n            if denom1 > 0.0:\n                coeff1 = (x - knots[i]) / denom1\n                N_next[i, :] += coeff1 * N[i, :]\n            # Second term (uses N_{i+1, d-1})\n            if i + 1  n_basis:\n                denom2 = knots[i + d + 1] - knots[i + 1]\n                if denom2 > 0.0:\n                    coeff2 = (knots[i + d + 1] - x) / denom2\n                    N_next[i, :] += coeff2 * N[i + 1, :]\n        N = N_next\n\n    return N\n\ndef element_quadrature_points_weights(M: int, q: int) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Build global quadrature points and weights by mapping q-point Gauss-Legendre\n    rule to each of the M uniform elements on [0,1].\n    \"\"\"\n    # Gauss-Legendre on [-1,1]\n    xi, w = np.polynomial.legendre.leggauss(q)\n    points = []\n    weights = []\n    h = 1.0 / M\n    for e in range(M):\n        a = e * h\n        b = (e + 1) * h\n        # Affine map: x = 0.5*(b-a)*xi + 0.5*(b+a)\n        x_e = 0.5 * (b - a) * xi + 0.5 * (b + a)\n        w_e = 0.5 * (b - a) * w\n        points.append(x_e)\n        weights.append(w_e)\n    x_all = np.concatenate(points)\n    w_all = np.concatenate(weights)\n    return x_all, w_all\n\ndef l2_projection_error(p: int, M: int, q: int = 50) -> float:\n    \"\"\"\n    Compute L2 projection of f(x)=sin(10x) onto spline space of degree p with M elements,\n    and return the L2 error norm via high-order Gaussian quadrature.\n    \"\"\"\n    # Build knots and basis dimension\n    knots = open_uniform_knots(M, p)\n    # Global quadrature\n    xq, wq = element_quadrature_points_weights(M, q)\n    # Evaluate basis matrix\n    B = bspline_basis_matrix(knots, p, xq)  # shape (n_basis, Nq)\n    # Assemble mass matrix M = B * diag(wq) * B^T\n    BW = B * wq[np.newaxis, :]\n    Mmat = BW @ B.T\n    # Assemble RHS b = B * (wq * f(xq))\n    fx = np.sin(10.0 * xq)  # radians\n    b = B @ (wq * fx)\n    # Solve for coefficients\n    c = np.linalg.solve(Mmat, b)\n    # Approximation values at quadrature points\n    sx = B.T @ c\n    # L2 error\n    err = np.sqrt(np.sum(wq * (fx - sx) ** 2))\n    return float(err)\n\ndef convergence_rate(p: int, Ms: list[int], q: int = 50) -> float:\n    \"\"\"\n    Compute observed convergence rate via least-squares fit of log(error) vs log(h).\n    \"\"\"\n    hs = np.array([1.0 / M for M in Ms], dtype=np.float64)\n    errs = np.array([l2_projection_error(p, M, q=q) for M in Ms], dtype=np.float64)\n    X = np.log(hs)\n    Y = np.log(errs)\n    # Least squares slope\n    slope = np.polyfit(X, Y, 1)[0]\n    return float(slope)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_degrees = [0, 1, 2, 3]\n    Ms = [8, 16, 32, 64]\n    q = 50  # quadrature points per element\n\n    results = []\n    for p in test_degrees:\n        rate = convergence_rate(p, Ms, q=q)\n        results.append(f\"{rate:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3099508"}]}