{"hands_on_practices": [{"introduction": "多项式插值的成败在很大程度上取决于插值节点的选择。重心坐标权重是分析插值过程稳定性的一个关键工具。通过本练习 [@problem_id:2199710]，您将计算并比较等距节点上不同位置的权重大小，从而揭示这种节点分布方式为何会内在地导致不稳定性，为理解龙格现象的起源奠定基础。", "problem": "在多项式插值的研究中，插值点（节点）的选择显著影响所得多项式的精度和稳定性。重心插值公式提供了一种数值稳定的方法来计算插值多项式，其性质与称为重心权的量密切相关。\n\n考虑在区间 $[-1, 1]$ 上的一组 $n+1$ 个均匀分布的插值节点 $x_j$，其中 $j=0, 1, \\ldots, n$。节点由公式 $x_j = -1 + j \\cdot h$ 给出，其中步长为 $h = \\frac{2}{n}$。\n\n节点 $x_j$ 的重心权 $w_j$ 定义为：\n$$\nw_j = \\left(\\prod_{k=0, k \\neq j}^{n} (x_j - x_k)\\right)^{-1}\n$$\n\n对于 $n=10$ 的特定情况（即有 11 个插值节点），确定比值 $\\frac{|w_{10}|}{|w_5|}$ 的精确值。该比值比较了区间右端点（$x_{10}=1$）的重心权大小与区间中心点（$x_5=0$）的重心权大小。\n\n请将最终答案表示为最简分数形式。", "solution": "我们有均匀分布的节点 $x_{j}=-1+jh$，其中 $h=\\frac{2}{n}$ 且 $j=0,1,\\ldots,n$。重心权为\n$$\nw_{j}=\\left(\\prod_{k=0,\\,k\\neq j}^{n}(x_{j}-x_{k})\\right)^{-1}.\n$$\n对于均匀间距，\n$$\nx_{j}-x_{k}=(-1+jh)-(-1+kh)=(j-k)h,\n$$\n所以对 $n$ 个项（不包括 $k=j$）的乘积可以分解为\n$$\n\\prod_{k=0,\\,k\\neq j}^{n}(x_{j}-x_{k})=h^{n}\\prod_{k=0,\\,k\\neq j}^{n}(j-k).\n$$\n因此\n$$\nw_{j}=h^{-n}\\left(\\prod_{k=0,\\,k\\neq j}^{n}(j-k)\\right)^{-1}.\n$$\n通过在 $j$ 处拆分来计算该整数乘积：\n$$\n\\prod_{k=0,\\,k\\neq j}^{n}(j-k)=\\left(\\prod_{k=0}^{j-1}(j-k)\\right)\\left(\\prod_{k=j+1}^{n}(j-k)\\right)\n=j!\\cdot\\left[\\prod_{m=1}^{n-j}(-m)\\right]=(-1)^{n-j}j!(n-j)!.\n$$\n因此，取绝对值，\n$$\n|w_{j}|=h^{-n}\\left|(-1)^{n-j}j!(n-j)!\\right|^{-1}=h^{-n}\\frac{1}{j!(n-j)!}.\n$$\n当 $n=10$ 时，我们得到\n$$\n\\frac{|w_{10}|}{|w_{5}|}=\\frac{h^{-10}/\\left(10!\\cdot 0!\\right)}{h^{-10}/\\left(5!\\cdot 5!\\right)}=\\frac{(5!)^{2}}{10!\\cdot 0!}=\\frac{(5!)^{2}}{10!}.\n$$\n使用 $10!=10\\cdot 9\\cdot 8\\cdot 7\\cdot 6\\cdot 5!$ 和 $5!=120$ 进行化简：\n$$\n\\frac{(5!)^{2}}{10!}=\\frac{5!}{10\\cdot 9\\cdot 8\\cdot 7\\cdot 6}=\\frac{120}{30240}=\\frac{1}{252}.\n$$\n因此，精确的比值为 $\\frac{1}{252}$。", "answer": "$$\\boxed{\\frac{1}{252}}$$", "id": "2199710"}, {"introduction": "了解了等距节点不稳定的数学根源后，我们来亲眼见证其带来的灾难性后果。这个练习 [@problem_id:2199743] 要求您使用等距节点构建一个插值多项式，并计算其在插值区间外部一点的预测值与真实值之间的惊人差异。这将使龙格现象从一个抽象的理论概念，转变为一个具体可感的、在实践中必须警惕的误差来源。", "problem": "考虑函数 $f(x) = \\frac{1}{1 + 25x^2}$。在区间 $[-1, 1]$ 内（包含端点）取五个等距节点 $x_i$，通过计算该函数在这些节点上的值，生成一组五个点 $(x_i, y_i)$。设 $P(x)$ 是穿过所有这五个点的次数尽可能小的唯一多项式。计算在点 $x = 1.1$ 处，该多项式的值与函数的值之间的绝对差。即，计算 $|P(1.1) - f(1.1)|$。将最终答案四舍五入到三位有效数字。", "solution": "在 $[-1,1]$ 区间内（包含端点）的五个等距节点是 $x=-1,-\\tfrac{1}{2},0,\\tfrac{1}{2},1$。由于 $f(x)=\\frac{1}{1+25x^{2}}$ 是偶函数，且节点是对称的，因此次数至多为 $4$ 的唯一插值多项式也是偶函数，所以可写作\n$$\nP(x)=a+bx^{2}+cx^{4}.\n$$\n插值得到以下条件\n$$\nP(0)=a=1,\\quad P\\!\\left(\\tfrac{1}{2}\\right)=1+\\tfrac{1}{4}b+\\tfrac{1}{16}c=\\tfrac{4}{29},\\quad P(1)=1+b+c=\\tfrac{1}{26}.\n$$\n由此可得，\n$$\n\\tfrac{1}{4}b+\\tfrac{1}{16}c=-\\tfrac{25}{29},\\qquad b+c=-\\tfrac{25}{26}.\n$$\n将第一个等式乘以 $16$ 得到 $4b+c=-\\tfrac{400}{29}$。减去 $b+c=-\\tfrac{25}{26}$ 得到\n$$\n3b=-\\tfrac{400}{29}+\\tfrac{25}{26}=-\\tfrac{9675}{754}\\;\\Rightarrow\\; b=-\\tfrac{3225}{754},\n$$\n然后\n$$\nc=-\\tfrac{25}{26}-b=-\\tfrac{25}{26}+\\tfrac{3225}{754}=\\tfrac{1250}{377}.\n$$\n因此\n$$\nP(x)=1-\\tfrac{3225}{754}x^{2}+\\tfrac{1250}{377}x^{4}.\n$$\n在 $x=\\tfrac{11}{10}$ 处求值：\n$$\nP\\!\\left(\\tfrac{11}{10}\\right)=1-\\tfrac{3225}{754}\\cdot\\tfrac{121}{100}+\\tfrac{1250}{377}\\cdot\\tfrac{14641}{10000}.\n$$\n对每个分数进行化简：\n$$\n-\\tfrac{3225\\cdot 121}{754\\cdot 100}=-\\tfrac{15609}{3016},\\qquad \\tfrac{1250\\cdot 14641}{377\\cdot 10000}=\\tfrac{14641}{3016},\n$$\n所以\n$$\nP\\!\\left(\\tfrac{11}{10}\\right)=\\tfrac{3016}{3016}-\\tfrac{15609}{3016}+\\tfrac{14641}{3016}=\\tfrac{2048}{3016}=\\tfrac{256}{377}.\n$$\n此外，\n$$\nf(1.1)=\\frac{1}{1+25\\cdot 1.21}=\\frac{1}{31.25}=\\frac{4}{125}.\n$$\n因此，\n$$\n|P(1.1)-f(1.1)|=\\left|\\tfrac{256}{377}-\\tfrac{4}{125}\\right|=\\frac{|256\\cdot 125-4\\cdot 377|}{377\\cdot 125}=\\frac{30492}{47125}\\approx 0.647045\\ldots\n$$\n四舍五入到三位有效数字，结果是 $0.647$。", "answer": "$$\\boxed{0.647}$$", "id": "2199743"}, {"introduction": "面对龙格现象，一个常见的误解是增加更多的等距节点可以改善结果，但事实恰恰相反。本练习 [@problem_id:3188715] 将引导您超越这一误区，通过编写程序实现一种更智能的自适应节点加密策略。您将学习如何根据误差估计在关键区域（如区间端点附近）动态添加节点，这不仅是克服龙格现象的有效方法，也是现代科学计算中解决此类问题的重要思想。", "problem": "您需要通过在区间 $[-1,1]$ 上的单变量多项式插值中的自适应节点加密来研究 Runge 现象。从 $n$ 个等距节点开始，通过中点处的残差来估计局部插值误差，在残差最大的端点附近添加节点，并数值检验自适应性是否能减少端点振荡。此研究必须以纯粹的数学和逻辑术语表述，并实现为一个完整、可运行的程序。\n\n定义与设置：\n- 设 $f(x)$ 是定义在 $[-1,1]$ 上的实值函数。\n- 对于给定的整数 $n \\geq 2$，定义等距节点 $x_i = -1 + \\frac{2i}{n-1}$，其中 $i=0,1,\\dots,n-1$。\n- 设 $p_n(x)$ 表示满足所有 $i$ 的 $p_n(x_i) = f(x_i)$ 的、次数至多为 $n-1$ 的唯一多项式。\n- 定义残差 $r(x) = p_n(x) - f(x)$。\n- 对于窗口宽度 $w$（$0 < w < 1$），定义端点窗口集合 $E_w = [-1,-1+w] \\cup [1-w,1]$。\n- 定义端点振荡得分 $S = \\max_{x \\in E_w} |r(x)|$，该值在 $[-1,1]$ 上一个大小为 $N_{\\text{grid}}$ 的足够密集的网格上进行评估。\n\n自适应节点加密（单步）：\n- 给定当前节点集 $\\{x_i\\}$ 和相关的插值多项式 $p_n(x)$，对每对连续节点 $(x_i, x_{i+1})$ 计算中点 $m_i = \\frac{x_i + x_{i+1}}{2}$。\n- 评估中点残差 $|r(m_i)| = |p_n(m_i) - f(m_i)|$。\n- 定义加权指标 $I_i = |r(m_i)| \\cdot \\left(1 + \\alpha \\cdot |m_i|\\right)$，其中 $\\alpha > 0$ 使选择偏向于端点（因为当 $x$ 接近 $\\pm 1$ 时， $|m_i|$ 更大）。\n- 选择最多 $k$ 个具有最大 $I_i$ 值的中点，并将它们添加到节点集中。\n- 在加密后的节点集上重新计算插值多项式 $\\hat{p}(x)$ 和新的残差 $\\hat{r}(x) = \\hat{p}(x) - f(x)$。\n- 使用与之前相同的密集网格计算新的端点振荡得分 $\\hat{S} = \\max_{x \\in E_w} |\\hat{r}(x)|$。\n- 如果 $S > 0$，定义改进率 $R = \\frac{S - \\hat{S}}{S}$；如果 $S = 0$，则定义 $R = 0$。\n\n您的程序必须实现上述过程，并对每个测试用例输出一个布尔值，指示自适应加密是否将端点振荡减少了至少一个指定的阈值 $\\tau$，即 $R \\geq \\tau$ 是否成立。\n\n测试套件和参数：\n对于每个测试用例，参数以元组 $(f\\_\\text{id}, n, k, \\alpha, w, N_{\\text{grid}}, \\tau)$ 的形式给出，其中：\n- $f\\_\\text{id}$ 指定函数 $f(x)$ 如下：\n  - $f\\_\\text{id} = \\text{\"runge25\"}$ 表示 $f(x) = \\frac{1}{1 + 25 x^2}$。\n  - $f\\_\\text{id} = \\text{\"cubic\"}$ 表示 $f(x) = x^3$。\n- $n$ 是 $[-1,1]$ 上的初始等距节点数。\n- $k$ 是自适应步骤中要添加的最大中点数。\n- $\\alpha$ 是指标 $I_i$ 中的端点偏置参数。\n- $w$ 是定义 $E_w$ 的端点窗口宽度。\n- $N_{\\text{grid}}$ 是用于在 $[-1,1]$ 上近似 $S$ 和 $\\hat{S}$ 中最大值的网格点数。\n- $\\tau$ 是要求的改进率阈值，以小数形式表示。\n\n使用以下测试套件：\n1. $(\\text{\"runge25\"},\\, 10,\\, 8,\\, 1.5,\\, 0.2,\\, 5001,\\, 0.2)$.\n2. $(\\text{\"runge25\"},\\, 10,\\, 2,\\, 1.5,\\, 0.2,\\, 5001,\\, 0.05)$.\n3. $(\\text{\"cubic\"},\\, 10,\\, 8,\\, 1.5,\\, 0.2,\\, 5001,\\, 0.2)$.\n4. $(\\text{\"runge25\"},\\, 10,\\, 8,\\, 1.5,\\, 0.2,\\, 5001,\\, 0.9)$.\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个测试用例的结果，形式为方括号括起来的逗号分隔列表，例如 $[\\text{True},\\text{False},\\text{True},\\text{False}]$。不应打印任何附加文本。", "solution": "问题陈述经过了严格验证，并被确定为是合理的。它在科学上基于数值分析的原理，特别是多项式插值和 Runge 现象。所有定义在数学上都是精确的，参数是完整的，过程是适定的，从而为每个测试用例带来唯一的、可验证的解。\n\n任务是为单变量多项式插值实现并评估一个单步自适应节点加密策略。目标是测试该策略在等距节点上进行插值时，是否能有效减轻 Runge 现象特有的端点振荡。该过程将应用于区间 $[-1,1]$ 上的两个函数：Runge 函数 $f(x) = \\frac{1}{1 + 25x^2}$ 和一个简单的三次多项式 $f(x) = x^3$。\n\n方法论如下：\n\n首先，对于给定的函数 $f(x)$，在区间 $[-1,1]$ 上通过 $x_i = -1 + \\frac{2i}{n-1}$ 定义一个包含 $n$ 个等距节点的初始集合 $\\{x_i\\}_{i=0}^{n-1}$。然后构造一个次数至多为 $n-1$ 的唯一插值多项式 $p_n(x)$，使其穿过点 $(x_i, f(x_i))$。这在计算上通过使用重心插值法来实现，该方法以其数值稳定性而闻名。\n\n其次，对初始插值误差进行量化。残差函数定义为 $r(x) = p_n(x) - f(x)$。端点振荡的严重程度通过得分 $S$ 来衡量，该得分是在指定的端点窗口 $E_w = [-1, -1+w] \\cup [1-w, 1]$ 内残差的绝对值的最大值。在实践中，这个最大值是通过在 $[-1,1]$ 上的一个包含 $N_{\\text{grid}}$ 个点的非常密集的均匀网格上评估 $|r(x)|$，并找到落入 $E_w$ 中的点的最大值来近似的。\n\n第三，执行自适应加密步骤。其核心思想是在插值误差较大的区域添加新节点。误差通过计算初始节点区间中点的残差来估计。对于每对连续节点 $(x_i, x_{i+1})$，中点为 $m_i = \\frac{x_i + x_{i+1}}{2}$。为每个中点计算一个加权指标 $I_i$：\n$$I_i = |r(m_i)| \\cdot (1 + \\alpha \\cdot |m_i|)$$\n其中 $|r(m_i)| = |p_n(m_i) - f(m_i)|$ 是中点处残差的大小。项 $(1 + \\alpha \\cdot |m_i|)$（其中给定偏置参数 $\\alpha > 0$）给予更接近区间 $[-1,1]$ 端点的中点更大的权重，因为在这些地方 $|m_i|$ 更大。这策略性地将节点选择偏向 Runge 现象最显著的区域。选择最多 $k$ 个对应于最大 $I_i$ 值的中点，并将其添加到插值节点集中。\n\n第四，在加密后的非均匀节点集上执行新的插值，该节点集现在包含 $n$ 个初始节点加上新添加的点。这将产生一个更高阶的新插值多项式 $\\hat{p}(x)$。新的残差是 $\\hat{r}(x) = \\hat{p}(x) - f(x)$，并使用与之前相同的密集网格和端点窗口 $E_w$ 计算新的端点振荡得分 $\\hat{S}$：$\\hat{S} = \\max_{x \\in E_w} |\\hat{r}(x)|$。\n\n最后，通过计算改进率 $R$ 来评估加密的有效性：\n$$R = \\frac{S - \\hat{S}}{S}$$\n仅当初始误差得分 $S > 0$ 时，此比率才有定义。如果 $S=0$，我们定义 $R=0$，因为没有误差可以改进。如果该比率达到或超过给定的阈值 $\\tau$，即 $R \\ge \\tau$，则该过程被视为成功。\n\n对于涉及 $f(x) = x^3$ 且初始节点数为 $n=10$ 的测试用例，函数的次数（3）小于插值多项式可能的最大次数（$n-1 = 9$）。因此，初始插值多项式 $p_{10}(x)$ 将与 $f(x)$ 完全相同，即 $p_{10}(x) = x^3$。残差 $r(x)$ 对所有 $x$ 都将为零，导致初始得分为 $S=0$。随后，所有的中点残差和指标 $I_i$ 也将为零。在添加任意 $k$ 个新节点后，加密后的插值多项式 $\\hat{p}(x)$ 仍将精确地是 $x^3$，从而导致 $\\hat{S}=0$。根据问题定义，在这种情况下 $R=0$。因此，对于任何 $\\tau > 0$，最终测试 $R \\ge \\tau$ 将为假，这正确地表明不需要或未实现任何改进。这可以作为对实现的一个有价值的健全性检查。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import BarycentricInterpolator\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"runge25\", 10, 8, 1.5, 0.2, 5001, 0.2),\n        (\"runge25\", 10, 2, 1.5, 0.2, 5001, 0.05),\n        (\"cubic\", 10, 8, 1.5, 0.2, 5001, 0.2),\n        (\"runge25\", 10, 8, 1.5, 0.2, 5001, 0.9),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_one_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_one_case(f_id, n, k, alpha, w, N_grid, tau):\n    \"\"\"\n    Implements the adaptive node refinement procedure for a single test case.\n\n    Args:\n        f_id (str): Function identifier (\"runge25\" or \"cubic\").\n        n (int): Initial number of equispaced nodes.\n        k (int): Maximum number of midpoints to add.\n        alpha (float): Endpoint bias parameter.\n        w (float): Endpoint window width.\n        N_grid (int): Number of points in the dense evaluation grid.\n        tau (float): Improvement ratio threshold.\n\n    Returns:\n        bool: True if the improvement ratio is >= tau, False otherwise.\n    \"\"\"\n    # 1. Define the function f(x) based on the identifier.\n    if f_id == \"runge25\":\n        def f(x):\n            return 1.0 / (1.0 + 25.0 * x**2)\n    elif f_id == \"cubic\":\n        def f(x):\n            return x**3\n    else:\n        raise ValueError(\"Unknown function identifier\")\n\n    # 2. Define the dense evaluation grid and the endpoint window.\n    x_grid = np.linspace(-1.0, 1.0, N_grid)\n    endpoint_mask = (x_grid = -1.0 + w) | (x_grid >= 1.0 - w)\n\n    # 3. Initial interpolation setup.\n    x_nodes_initial = np.linspace(-1.0, 1.0, n)\n    y_nodes_initial = f(x_nodes_initial)\n    p_n = BarycentricInterpolator(x_nodes_initial, y_nodes_initial)\n\n    # 4. Calculate the initial residual and endpoint oscillation score S.\n    f_vals_grid = f(x_grid)\n    p_n_vals_grid = p_n(x_grid)\n    r_vals_grid = p_n_vals_grid - f_vals_grid\n    \n    s_val = np.max(np.abs(r_vals_grid[endpoint_mask]))\n\n    # If initial error is effectively zero, improvement R is 0.\n    if np.isclose(s_val, 0.0):\n        return 0.0 >= tau\n\n    # 5. Adaptive refinement: compute indicators and select new nodes.\n    midpoints = (x_nodes_initial[:-1] + x_nodes_initial[1:]) / 2.0\n    r_midpoints = p_n(midpoints) - f(midpoints)\n    indicators = np.abs(r_midpoints) * (1.0 + alpha * np.abs(midpoints))\n    \n    num_to_add = min(k, len(midpoints))\n    top_indices = np.argsort(indicators)[-num_to_add:]\n    nodes_to_add = midpoints[top_indices]\n    \n    x_nodes_refined = np.sort(np.union1d(x_nodes_initial, nodes_to_add))\n    y_nodes_refined = f(x_nodes_refined)\n\n    # 6. Recompute interpolant on the refined node set.\n    p_hat = BarycentricInterpolator(x_nodes_refined, y_nodes_refined)\n\n    # 7. Calculate the new endpoint oscillation score S_hat.\n    p_hat_vals_grid = p_hat(x_grid)\n    r_hat_vals_grid = p_hat_vals_grid - f_vals_grid\n    s_hat_val = np.max(np.abs(r_hat_vals_grid[endpoint_mask]))\n\n    # 8. Compute the improvement ratio R and compare with the threshold tau.\n    improvement_ratio = (s_val - s_hat_val) / s_val\n    \n    return improvement_ratio >= tau\n\nsolve()\n```", "id": "3188715"}]}