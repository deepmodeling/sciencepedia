{"hands_on_practices": [{"introduction": "掌握分段插值的第一步是理解最简单的线性情形。这个练习将引导你为一个简单曲线构建分段线性近似，并分析其误差，这是数值方法中的一项基本技能。通过这个过程，你将学会如何量化近似的质量，并初步了解函数本身的性质如何影响插值误差 [@problem_id:2193842]。", "problem": "在数值分析中，分段插值是逼近复杂函数的一种常用方法。考虑定义在区间 $[-1, 1]$ 上的函数 $f(x) = x^4$。我们希望使用一个连续分段线性插值来逼近这个函数，我们将其记为 $L(x)$。该插值函数使用节点 $x_0 = -1$、$x_1 = 0$ 和 $x_2 = 1$ 构建。在给定子区间上的插值误差定义为该子区间上函数与其插值函数之间的最大绝对差，即 $\\max |f(x) - L(x)|$。\n\n你的任务是确定在哪一个子区间（$[-1, 0]$ 或 $[0, 1]$）上，插值误差最大。\n\n从以下选项中选择正确的陈述。\n\nA. 子区间 $[-1, 0]$。\n\nB. 子区间 $[0, 1]$。\n\nC. 两个子区间上的最大误差相同。\n\nD. 最大误差出现在节点 $x=0$ 处，因此没有哪个子区间的误差唯一更大。\n\nE. 信息不足，无法确定结果。", "solution": "问题要求我们为区间 $[-1, 1]$ 上的函数 $f(x) = x^4$ 构建一个使用节点 $x = -1, 0, 1$ 的分段线性插值 $L(x)$，然后比较子区间 $[-1, 0]$ 和 $[0, 1]$ 上的最大插值误差。\n\n首先，我们在给定的节点处计算函数 $f(x)$ 的值：\n$f(x_0) = f(-1) = (-1)^4 = 1$\n$f(x_1) = f(0) = 0^4 = 0$\n$f(x_2) = f(1) = 1^4 = 1$\n\n现在，我们为每个子区间构建线性插值。\n\n**子区间 1: $[-1, 0]$**\n线性插值函数，我们称之为 $L_1(x)$，是通过点 $(x_0, f(x_0)) = (-1, 1)$ 和 $(x_1, f(x_1)) = (0, 0)$ 的直线。\n这条直线的斜率是 $m_1 = \\frac{f(x_1) - f(x_0)}{x_1 - x_0} = \\frac{0 - 1}{0 - (-1)} = -1$。\n使用点 $(0, 0)$ 的点斜式，直线方程为：\n$L_1(x) - 0 = -1(x - 0)$，化简为 $L_1(x) = -x$。\n\n这个子区间上的误差函数是 $E_1(x) = f(x) - L_1(x) = x^4 - (-x) = x^4 + x$。\n为了找到最大绝对误差，我们需要找到 $E_1(x)$ 在 $[-1, 0]$ 上的极值。我们对 $x$ 求导并令其为零：\n$E_1'(x) = \\frac{d}{dx}(x^4 + x) = 4x^3 + 1$。\n令 $E_1'(x) = 0$ 可得 $4x^3 = -1$，所以 $x^3 = -1/4$。\n临界点是 $x_c = \\sqrt[3]{-1/4} = -\\frac{1}{\\sqrt[3]{4}}$。\n该值位于区间 $[-1, 0]$ 内。\n区间端点（即节点）处的误差根据构造为零：$E_1(-1) = (-1)^4 + (-1) = 0$ 且 $E_1(0) = 0^4 + 0 = 0$。\n因此，最大绝对误差必定出现在临界点 $x_c$ 处。\n该点的误差为：\n$E_1(x_c) = \\left(-\\frac{1}{\\sqrt[3]{4}}\\right)^4 + \\left(-\\frac{1}{\\sqrt[3]{4}}\\right) = \\frac{1}{4\\sqrt[3]{4}} - \\frac{1}{\\sqrt[3]{4}} = \\frac{1 - 4}{4\\sqrt[3]{4}} = -\\frac{3}{4\\sqrt[3]{4}}$。\n在 $[-1, 0]$ 上的最大绝对误差是 $|E_1(x_c)| = \\frac{3}{4\\sqrt[3]{4}}$。\n\n**子区间 2: $[0, 1]$**\n线性插值函数，我们称之为 $L_2(x)$，是通过点 $(x_1, f(x_1)) = (0, 0)$ 和 $(x_2, f(x_2)) = (1, 1)$ 的直线。\n这条直线的斜率是 $m_2 = \\frac{f(x_2) - f(x_1)}{x_2 - x_1} = \\frac{1 - 0}{1 - 0} = 1$。\n使用点 $(0, 0)$ 的点斜式，直线方程为：\n$L_2(x) - 0 = 1(x - 0)$，化简为 $L_2(x) = x$。\n\n这个子区间上的误差函数是 $E_2(x) = f(x) - L_2(x) = x^4 - x$。\n为了找到最大绝对误差，我们求 $E_2(x)$ 在 $[0, 1]$ 上的极值。我们求导：\n$E_2'(x) = \\frac{d}{dx}(x^4 - x) = 4x^3 - 1$。\n令 $E_2'(x) = 0$ 可得 $4x^3 = 1$，所以 $x^3 = 1/4$。\n临界点是 $x_d = \\sqrt[3]{1/4} = \\frac{1}{\\sqrt[3]{4}}$。\n该值位于区间 $[0, 1]$ 内。\n端点处的误差为零：$E_2(0) = 0^4 - 0 = 0$ 且 $E_2(1) = 1^4 - 1 = 0$。\n最大绝对误差必定出现在临界点 $x_d$ 处。\n该点的误差为：\n$E_2(x_d) = \\left(\\frac{1}{\\sqrt[3]{4}}\\right)^4 - \\left(\\frac{1}{\\sqrt[3]{4}}\\right) = \\frac{1}{4\\sqrt[3]{4}} - \\frac{1}{\\sqrt[3]{4}} = \\frac{1 - 4}{4\\sqrt[3]{4}} = -\\frac{3}{4\\sqrt[3]{4}}$。\n在 $[0, 1]$ 上的最大绝对误差是 $|E_2(x_d)| = \\frac{3}{4\\sqrt[3]{4}}$。\n\n**比较**\n在 $[-1, 0]$ 上的最大绝对误差是 $\\frac{3}{4\\sqrt[3]{4}}$。\n在 $[0, 1]$ 上的最大绝对误差是 $\\frac{3}{4\\sqrt[3]{4}}$。\n两个子区间上的最大误差相同。\n\n**使用对称性的替代推理**\n函数 $f(x)=x^4$ 是一个偶函数，意味着 $f(x) = f(-x)$。\n节点关于 $x=0$ 对称放置。\n分段线性插值函数为 $L(x) = -x$（当 $x \\in [-1, 0]$ 时）和 $L(x) = x$（当 $x \\in [0, 1]$ 时）。这可以简洁地写成 $L(x) = |x|$。\n函数 $L(x) = |x|$ 也是一个偶函数。\n误差函数 $E(x) = f(x) - L(x) = x^4 - |x|$ 是两个偶函数之差，因此它也是一个偶函数。\n对于一个偶函数 $E(x)$， $|E(x)|$ 的值与 $|E(-x)|$ 的值相同。这意味着误差分布关于 $x=0$ 是对称的。因此，区间 $[-1, 0]$ 上的最大误差必然等于区间 $[0, 1]$ 上的最大误差。\n\n基于这两种分析方法，两个子区间上的最大误差是相同的。这对应于选项 C。选项 D 是不正确的，因为根据插值的定义，节点 $x=0$ 处的误差为零，这是最小误差，而不是最大误差。", "answer": "$$\\boxed{C}$$", "id": "2193842"}, {"introduction": "超越线性近似，三次样条插值能提供更平滑的拟合效果。然而，正如这个练习 [@problem_id:2193854] 将要揭示的，这种平滑性可能带来意想不到的代价。你将研究一个具体案例，其中对单调数据进行插值的样条函数自身却并非单调，这是理解插值函数行为的一个关键洞见。", "problem": "自然三次样条是用于对一组数据点 `(x_i, y_i)` 进行插值的一种常用方法。如果一个函数 `S(x)` 是一个分段三次多项式，并且在被称为节点的数据点处是连续的，且具有连续的一阶和二阶导数，那么它就是一个三次样条。如果一个样条在第一个和最后一个节点的二阶导数为零，则称其为“自然的”。\n\n考虑一组三个单调递增的数据点：`P_0 = (0, 0)`，`P_1 = (1, 1/9)` 和 `P_2 = (2, 1)`。构造一个自然三次样条 `S(x)` 以穿过这三个点。\n\n尽管数据点是严格递增的，但得到的插值函数 `S(x)` 在整个区间 `[0, 2]` 上并不是单调的。可以证明，在子区间 `[0, 1]` 中存在一个局部极值。\n\n求出该局部极值的x坐标。将你的最终答案四舍五入到四位有效数字。", "solution": "设节点为 $x_{0}=0$, $x_{1}=1$, $x_{2}=2$，对应的值为 $y_{0}=0$, $y_{1}=\\frac{1}{9}$, $y_{2}=1$。设 $h_{i}=x_{i+1}-x_{i}$，所以 $h_{0}=h_{1}=1$。对于自然三次样条，节点处的二阶导数 $M_{i}=S''(x_{i})$ 满足 $M_{0}=0$, $M_{2}=0$，以及对于内部节点 $i=1$ 的三对角系统为：\n$$\nh_{0}M_{0}+2(h_{0}+h_{1})M_{1}+h_{1}M_{2}\n=6\\left(\\frac{y_{2}-y_{1}}{h_{1}}-\\frac{y_{1}-y_{0}}{h_{0}}\\right).\n$$\n代入数据可得\n$$\n4M_{1}=6\\left(\\left(1-\\frac{1}{9}\\right)-\\left(\\frac{1}{9}-0\\right)\\right)\n=6\\left(\\frac{8}{9}-\\frac{1}{9}\\right)=6\\cdot\\frac{7}{9}=\\frac{14}{3},\n$$\n所以\n$$\nM_{1}=\\frac{7}{6},\\quad M_{0}=0,\\quad M_{2}=0.\n$$\n\n在 $[x_{0},x_{1}]=[0,1]$ 上，样条段为\n$$\nS_{0}(x)=\\frac{M_{0}(x_{1}-x)^{3}}{6h_{0}}+\\frac{M_{1}(x-x_{0})^{3}}{6h_{0}}+\\left(y_{0}-\\frac{M_{0}h_{0}^{2}}{6}\\right)\\frac{x_{1}-x}{h_{0}}+\\left(y_{1}-\\frac{M_{1}h_{0}^{2}}{6}\\right)\\frac{x-x_{0}}{h_{0}}.\n$$\n根据以上数值，\n$$\nS_{0}(x)=\\frac{\\frac{7}{6}x^{3}}{6}+\\left(\\frac{1}{9}-\\frac{\\frac{7}{6}}{6}\\right)x=\\frac{7}{36}x^{3}-\\frac{1}{12}x.\n$$\n求导以寻找临界点：\n$$\nS_{0}'(x)=\\frac{7}{12}x^{2}-\\frac{1}{12}.\n$$\n令 $S_{0}'(x)=0$ 可得\n$$\n\\frac{7}{12}x^{2}-\\frac{1}{12}=0\\;\\;\\Longrightarrow\\;\\;7x^{2}-1=0\\;\\;\\Longrightarrow\\;\\;x^{2}=\\frac{1}{7}.\n$$\n在区间 $[0,1]$ 内，临界点为\n$$\nx=\\frac{1}{\\sqrt{7}}.\n$$\n数值上，$\\frac{1}{\\sqrt{7}}\\approx 0.377964\\ldots$，四舍五入到四位有效数字为 $0.3780$。", "answer": "$$\\boxed{0.3780}$$", "id": "2193854"}, {"introduction": "在认识到标准样条插值的潜在缺陷后，我们现在转向一种解决方案：保形插值。这项高级编程练习 [@problem_id:3261829] 将挑战你实现一个保单调性的分段三次 Hermite 插值多项式 (PCHIP)。通过从第一性原理推导并应用斜率限制策略，你将构建一个既平滑又忠实于数据原始形状的插值函数。", "problem": "要求您从第一性原理出发，设计并实现一个保形的(shape-preserving)分段三次埃尔米特插值多项式(PCHIP)，该多项式需保证在输入数据值为单调时，其本身也必然是单调的。该插值函数应连续可微，并且必须穿过所有给定的数据点。单调性保证必须通过一种斜率限制策略来选择节点导数以实现，该策略会施加充分的局部条件，从而在每个子区间上，当相应数据为非递减（或非递增）时，三次片段的导数也为非负（或非正）。您的设计必须从三次埃尔米特插值的定义以及一个基本概念出发，即区间上三次多项式的导数可以表示为一个二次函数，而通过对其系数施加适当的界限，可以保证该二次函数在闭区间上的非负性。您不得预先假设任何快捷公式；相反，您必须推导出当数据单调时，如何约束节点导数以满足逐区间的单调性。\n\n定义和要求：\n- 设数据节点为 $x_0 < x_1 < \\cdots < x_{n-1}$，对应值为 $y_0, y_1, \\ldots, y_{n-1}$。在每个子区间 $[x_i, x_{i+1}]$（宽度为 $h_i = x_{i+1} - x_i$）上，使用 $y_i$、$y_{i+1}$ 以及节点导数 $m_i$、$m_{i+1}$ 构建一个三次埃尔米特片段。使用标准的三次埃尔米特基函数来定义该片段，并通过在每个节点 $x_i$ 处为相邻片段使用同一个导数 $m_i$ 来确保 $C^1$ 连续性。\n- 您的斜率限制规则必须保证：当数据值 $\\{y_i\\}$ 为单调非递减（或单调非递增）时，所得的插值函数 $s(x)$ 在整个定义域 $[x_0, x_{n-1}]$ 上也同样是单调非递减（或单调非递增）的。仅可使用从三次片段的导数以及保证导数逐点非负（或非正）的逐区间充分条件中推导出的性质。该规则必须能处理严格单调的数据以及包含平稳段的数据。\n- 为量化测试插值函数的单调性，对于下方的每个数据集，在 $[x_0, x_{n-1}]$ 区间内的 $N = 1001$ 个等距点上计算插值函数 $s(x)$ 的值。按如下方式定义带符号的单调性余量。设 $\\Delta s_j = s(x_{j+1}) - s(x_j)$ 为连续求值点上的差值，并定义 $\\sigma = \\operatorname{sign}(y_{n-1} - y_0)$，约定当 $y_{n-1} = y_0$ 时 $\\sigma = 1$。余量为\n$$\n\\mu = \\min_j \\sigma \\, \\Delta s_j.\n$$\n根据此定义，如果插值函数按要求的方向单调，则 $\\mu \\ge 0$。如果存在任何局部违规，则 $\\mu < 0$。\n- 您的程序必须为每个数据集构建插值函数并计算 $\\mu$。每个 $\\mu$ 值必须四舍五入到 $8$ 位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序与下方的测试套件一致，例如 $[\\mu_1,\\mu_2,\\mu_3,\\mu_4]$，其中每个条目小数点后必须正好有 $8$ 位数字。\n\n测试套件（每个案例提供 $(x,y)$）：\n1. 递增，非均匀间距：\n   - $x = [0.0,\\, 0.7,\\, 1.0,\\, 1.8,\\, 2.5,\\, 3.0]$\n   - $y = [0.0,\\, 0.2,\\, 0.9,\\, 1.1,\\, 2.0,\\, 2.2]$\n2. 递减，非均匀间距：\n   - $x = [0.0,\\, 0.5,\\, 1.5,\\, 2.2,\\, 3.0]$\n   - $y = [5.0,\\, 4.0,\\, 2.5,\\, 2.0,\\, 1.0]$\n3. 非单调值：\n   - $x = [0.0,\\, 0.6,\\, 1.0,\\, 1.4,\\, 2.0]$\n   - $y = [0.0,\\, 1.5,\\, 0.5,\\, 1.6,\\, 1.0]$\n4. 带平台期的非递减：\n   - $x = [0.0,\\, 0.4,\\, 0.8,\\, 1.2,\\, 2.0]$\n   - $y = [1.0,\\, 1.0,\\, 1.3,\\, 1.3,\\, 2.0]$\n\n您的程序必须是一个完整、可运行的实现，能够：\n- 构建一个穿过数据的连续可微的分段三次埃尔米特插值函数 $s(x)$。\n- 通过一个限制器选择节点导数，以保证在 $\\{y_i\\}$ 单调时 $s(x)$ 也单调。\n- 对每个数据集，在定义域 $[x_0, x_{n-1}]$ 上的 $N = 1001$ 个等距求值点上计算单调性余量 $\\mu$。\n- 按照 $[\\mu_1,\\mu_2,\\mu_3,\\mu_4]$ 的确切格式打印单行结果，每个 $\\mu_k$ 四舍五入到 $8$ 位小数。", "solution": "用户要求设计并实现一个保形的分段三次埃尔米特插值多项式 (PCHIP)，该多项式需保证在输入数据单调时插值函数也单调。解决方案必须从第一性原理推导而来。\n\n### 第1步：从第一性原理进行理论推导\n\n**1. 分段三次埃尔米特插值**\n给定一组数据点 $(x_0, y_0), (x_1, y_1), \\ldots, (x_{n-1}, y_{n-1})$，其中 $x_0 < x_1 < \\cdots < x_{n-1}$，分段三次埃尔米特插值函数 $s(x)$ 在每个子区间 $[x_i, x_{i+1}]$ 上构建。在这样的子区间上，$s(x)$ 是一个由端点 $x_i, x_{i+1}$ 处的值 $y_i, y_{i+1}$ 和导数 $m_i, m_{i+1}$ 定义的三次多项式。通过确保每个节点 $x_i$ 处的导数 $m_i$ 是唯一确定的，插值函数是连续可微的 ($C^1$)。\n\n令 $h_i = x_{i+1} - x_i$ 为区间的宽度。我们引入一个局部坐标 $t = (x - x_i)/h_i$，它将区间 $[x_i, x_{i+1}]$ 映射到 $[0, 1]$。在 $[0,1]$ 上的三次多项式 $P_i(t)$ 由下式给出：\n$$P_i(t) = y_i H_{00}(t) + y_{i+1} H_{01}(t) + (h_i m_i) H_{10}(t) + (h_i m_{i+1}) H_{11}(t)$$\n其中 $H_{jk}(t)$ 是三次埃尔米特基函数：\n- $H_{00}(t) = 2t^3 - 3t^2 + 1$ ($t=0$ 处的值)\n- $H_{01}(t) = -2t^3 + 3t^2$ ($t=1$ 处的值)\n- $H_{10}(t) = t^3 - 2t^2 + t$ ($t=0$ 处的缩放导数)\n- $H_{11}(t) = t^3 - t^2$ ($t=1$ 处的缩放导数)\n\n插值函数 $s(x)$ 对 $x$ 的导数通过链式法则与 $P_i(t)$ 对 $t$ 的导数相关联：$s'(x) = \\frac{d P_i}{dt} \\frac{dt}{dx} = \\frac{1}{h_i} P_i'(t)$。\n\n**2. 单调性条件**\n为使插值函数 $s(x)$ 在 $[x_i, x_{i+1}]$ 上是单调的，其导数 $s'(x)$ 在该区间内必须符号唯一。我们假设数据是非递减的，因此割线斜率 $\\Delta_i = (y_{i+1} - y_i)/h_i \\ge 0$。我们要求对所有 $x \\in [x_i, x_{i+1}]$ 都有 $s'(x) \\ge 0$。这意味着对所有 $t \\in [0, 1]$ 都有 $P_i'(t) \\ge 0$。\n\n导数 $P_i'(t)$ 是一个关于 $t$ 的二次函数：\n$$P_i'(t) = y_i H'_{00}(t) + y_{i+1} H'_{01}(t) + h_i m_i H'_{10}(t) + h_i m_{i+1} H'_{11}(t)$$\n将基函数的导数代入：\n- $H'_{00}(t) = 6t^2 - 6t$\n- $H'_{01}(t) = -6t^2 + 6t$\n- $H'_{10}(t) = 3t^2 - 4t + 1$\n- $H'_{11}(t) = 3t^2 - 2t$\n\n我们得到：\n$$P_i'(t) = (y_{i+1}-y_i)(6t-6t^2) + h_i m_i(3t^2 - 4t + 1) + h_i m_{i+1}(3t^2 - 2t)$$\n两边除以 $h_i$ 并代入 $\\Delta_i = (y_{i+1}-y_i)/h_i$：\n$$s'(x) = \\Delta_i(6t-6t^2) + m_i(3t^2 - 4t + 1) + m_{i+1}(3t^2 - 2t)$$\n为使这个关于 $t$ 的二次函数在 $[0,1]$ 上非负，我们需要 $s'(x_i) = m_i \\ge 0$ 和 $s'(x_{i+1}) = m_{i+1} \\ge 0$。一个更强的充分条件可以从三次曲线的凸性中导出。由其贝塞尔控制点定义的三次片段是单调的，当且仅当其控制点的y坐标是单调的。控制点为：\n$P_0 = (x_i, y_i)$, $P_1 = (x_i + \\frac{h_i}{3}, y_i + \\frac{h_i m_i}{3})$, $P_2 = (x_{i+1} - \\frac{h_i}{3}, y_{i+1} - \\frac{h_i m_{i+1}}{3})$, $P_3 = (x_{i+1}, y_{i+1})$。\n对于非递减数据 ($y_i \\le y_{i+1}$)，我们要求y坐标非递减：\n$y_i \\le y_i + \\frac{h_i m_i}{3} \\le y_{i+1} - \\frac{h_i m_{i+1}}{3} \\le y_{i+1}$。\n这产生了三个条件：\n1. $m_i \\ge 0$\n2. $m_{i+1} \\ge 0$\n3. $y_i + \\frac{h_i m_i}{3} \\le y_{i+1} - \\frac{h_i m_{i+1}}{3} \\implies m_i + m_{i+1} \\le 3 \\frac{y_{i+1}-y_i}{h_i} = 3\\Delta_i$\n\n如果数据是非递增的 ($\\Delta_i \\le 0$)，条件变为 $m_i \\le 0$, $m_{i+1} \\le 0$, 以及 $m_i + m_{i+1} \\ge 3\\Delta_i$。两种情况可以总结为：\n如果 $\\Delta_i=0$，则 $m_i=m_{i+1}=0$。\n如果 $\\Delta_i \\neq 0$：$\\mathrm{sign}(m_i) = \\mathrm{sign}(m_{i+1}) = \\mathrm{sign}(\\Delta_i)$，且 $|\\frac{m_i}{\\Delta_i} + \\frac{m_{i+1}}{\\Delta_i}| \\le 3$。\n\n### 第2步：斜率限制器算法设计\n\n要构建一个PCHIP插值函数，我们首先估计每个节点的初始导数，然后应用一个“限制器”来强制执行单调性条件。\n\n**a. 初始导数估计：**\n- 对于内部节点 $x_k$ ($k=1, \\ldots, n-2$)，如果相邻的割线斜率 $\\Delta_{k-1}$ 和 $\\Delta_k$ 符号相反，这表示存在一个局部极值，因此我们将初始导数 $m_k$ 设为 0。如果它们符号相同，一个稳健的选择是割线斜率的加权调和平均值 (Fritsch  Butland, 1984)：\n    $$m_k = \\frac{w_1+w_2}{(w_1/\\Delta_{k-1}) + (w_2/\\Delta_k)} \\quad \\text{其中} \\quad w_1 = 2h_k + h_{k-1}, w_2 = h_k + 2h_{k-1}$$\n- 对于端点节点 $x_0$ 和 $x_{n-1}$，我们使用一个非中心的3点公式，这等价于求解穿过首/末三个点的二次曲线的导数。\n    $$m_0 = \\frac{(2h_0+h_1)\\Delta_0 - h_0\\Delta_1}{h_0+h_1}$$\n    $$m_{n-1} = \\frac{(2h_{n-2}+h_{n-3})\\Delta_{n-2} - h_{n-2}\\Delta_{n-3}}{h_{n-2}+h_{n-3}}$$\n\n**b. 单调性强制（限制器）：**\n在获得初始导数估计后，我们遍历每个区间 $[x_k, x_{k+1}]$ 并强制执行上面推导出的充分条件。这可以通过从 $k=0$ 到 $n-2$ 的单次遍历完成。\n\n对于每个区间 $[x_k, x_{k+1}]$：\n1. 如果 $\\Delta_k = 0$，则设置 $m_k=0$ 和 $m_{k+1}=0$。\n2. 否则，检查符号。如果 $\\mathrm{sign}(m_k) \\neq \\mathrm{sign}(\\Delta_k)$，则设置 $m_k=0$。如果 $\\mathrm{sign}(m_{k+1}) \\neq \\mathrm{sign}(\\Delta_k)$，则设置 $m_{k+1}=0$。\n3. 检查幅度条件。令 $s_k = \\mathrm{sign}(\\Delta_k)$。如果 $s_k(m_k + m_{k+1}) > 3 |\\Delta_k|$，则该条件被违反。我们将两个导数按比例缩小，使其位于可接受区域的边界上：\n   $$m_k \\leftarrow \\frac{3\\Delta_k}{m_k+m_{k+1}} m_k \\quad \\text{和} \\quad m_{k+1} \\leftarrow \\frac{3\\Delta_k}{m_k+m_{k+1}} m_{k+1}$$\n这个过程的单次前向遍历是足够的，因为导数的幅度只会被减小（或设为零），这会保持或改善对先前区间的条件的遵守情况。\n\n### 第3步：插值函数求值与单调性余量\n一旦确定了最终的导数 $\\{m_i\\}$，就可以在任意点 `x_eval` 处计算插值函数 $s(x)$ 的值。首先找到包含 `x_eval` 的区间 $[x_k, x_{k+1}]$，计算 $t = (\\text{x\\_eval} - x_k)/h_k$，然后使用埃尔米特基多项式公式。\n\n单调性余量 $\\mu = \\min_j \\sigma \\, \\Delta s_j$ 的计算方式为，其中 $\\Delta s_j$ 是在N个等距点上计算的插值函数值的差值，而 $\\sigma = \\operatorname{sign}(y_{n-1} - y_0)$（当 $y_{n-1}=y_0$ 时，$\\sigma=1$）。非负的 $\\mu$ 值确认了插值函数的单调性与整体数据趋势的单调性一致。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the PCHIP problem for the given test suite.\n    \"\"\"\n    # Test cases from the problem statement\n    test_cases = [\n        (np.array([0.0, 0.7, 1.0, 1.8, 2.5, 3.0]), np.array([0.0, 0.2, 0.9, 1.1, 2.0, 2.2])),\n        (np.array([0.0, 0.5, 1.5, 2.2, 3.0]), np.array([5.0, 4.0, 2.5, 2.0, 1.0])),\n        (np.array([0.0, 0.6, 1.0, 1.4, 2.0]), np.array([0.0, 1.5, 0.5, 1.6, 1.0])),\n        (np.array([0.0, 0.4, 0.8, 1.2, 2.0]), np.array([1.0, 1.0, 1.3, 1.3, 2.0])),\n    ]\n\n    results = []\n    for x, y in test_cases:\n        # Construct the PCHIP interpolator\n        interpolator = PchipInterpolator(x, y)\n        \n        # Evaluate at N=1001 points\n        N = 1001\n        x_eval = np.linspace(x[0], x[-1], N)\n        s_eval = interpolator.evaluate(x_eval)\n        \n        # Calculate monotonicity margin mu\n        delta_s = np.diff(s_eval)\n        \n        sigma_val = y[-1] - y[0]\n        sigma = 1.0 if sigma_val >= 0 else -1.0\n        \n        mu = np.min(sigma * delta_s)\n        \n        results.append(f\"{mu:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nclass PchipInterpolator:\n    \"\"\"\n    A shape-preserving Piecewise Cubic Hermite Interpolating Polynomial (PCHIP)\n    that guarantees monotonicity if the input data is monotonic.\n    The implementation is derived from first principles as requested.\n    \"\"\"\n    def __init__(self, x, y):\n        self.x = np.asarray(x, dtype=float)\n        self.y = np.asarray(y, dtype=float)\n        if self.x.ndim != 1 or self.y.ndim != 1 or self.x.shape != self.y.shape:\n            raise ValueError(\"x and y must be 1D arrays of the same shape.\")\n        if self.x.shape[0] < 2:\n            raise ValueError(\"Need at least 2 data points for interpolation.\")\n        \n        # Calculate and store the final nodal derivatives after applying the limiter\n        self.m = self._calculate_derivatives(self.x, self.y)\n\n    def _calculate_derivatives(self, x, y):\n        \"\"\"\n        Calculates the nodal derivatives m_k for the PCHIP interpolant,\n        including initial estimation and a monotonicity-preserving limiter.\n        \"\"\"\n        n = len(x)\n        h = np.diff(x)\n        delta = np.diff(y) / h\n        \n        if n == 2:\n            # For two points, the interpolant is a line, derivative is constant\n            return np.array([delta[0], delta[0]])\n        \n        m = np.zeros(n)\n        \n        # Step 1: Initial derivative estimates at interior points (k=1..n-2)\n        for k in range(1, n - 1):\n            if np.sign(delta[k-1]) * np.sign(delta[k]) > 0:\n                # Weighted harmonic mean for same-sign adjacent secant slopes\n                w1 = 2 * h[k] + h[k-1]\n                w2 = h[k] + 2 * h[k-1]\n                m[k] = (w1 + w2) / (w1 / delta[k-1] + w2 / delta[k])\n            else:\n                # Zero derivative at extrema\n                m[k] = 0.0\n                \n        # Step 2: Initial derivative estimates at endpoints (k=0, n-1)\n        # These are based on fitting a quadratic to the first/last 3 points.\n        m[0] = ((2*h[0] + h[1])*delta[0] - h[0]*delta[1]) / (h[0] + h[1])\n        m[n-1] = ((2*h[n-2] + h[n-3])*delta[n-2] - h[n-2]*delta[n-3]) / (h[n-2] + h[n-3])\n        \n        # Step 3: Apply monotonicity constraints (the limiter) in a single pass.\n        for k in range(n - 1):\n            if delta[k] == 0.0:\n                # If the data is flat, the interpolant must be flat.\n                m[k] = 0.0\n                m[k+1] = 0.0\n            else:\n                # Enforce that derivatives have the same sign as the secant slope.\n                if np.sign(m[k]) != np.sign(delta[k]):\n                    m[k] = 0.0\n                if np.sign(m[k+1]) != np.sign(delta[k]):\n                    m[k+1] = 0.0\n                \n                # Check the magnitude condition derived from Bezier control points.\n                # Expressed generally: s_k * (m_k + m_{k+1}) <= 3 * |delta_k|\n                # where s_k = sign(delta_k).\n                \n                # Check for violation\n                violation = False\n                if delta[k] > 0 and m[k] + m[k+1] > 3.0 * delta[k]:\n                    violation = True\n                elif delta[k] < 0 and m[k] + m[k+1] < 3.0 * delta[k]:\n                    violation = True\n\n                if violation:\n                    # Scale down m_k and m_{k+1} to meet the boundary\n                    # while preserving their ratio. This can only happen if m_k+m_{k+1} != 0.\n                    # Given the sign checks above, m_k+m_{k+1} will have same sign as delta_k.\n                    scale = (3.0 * delta[k]) / (m[k] + m[k+1])\n                    m[k] *= scale\n                    m[k+1] *= scale\n                        \n        return m\n\n    def evaluate(self, x_eval):\n        \"\"\"\n        Evaluates the PCHIP interpolant at the given points.\n        \"\"\"\n        x_eval = np.asarray(x_eval, dtype=float)\n        \n        # Find which interval each x_eval point belongs to.\n        indices = np.searchsorted(self.x, x_eval, side='right')\n        # Handle points outside the domain by clamping to boundary intervals.\n        indices = np.clip(indices, 1, len(self.x) - 1)\n        # The interval index `k` corresponds to [x_k, x_{k+1}]\n        k = indices - 1\n        \n        # Extract data for the corresponding intervals.\n        x_k = self.x[k]\n        x_k1 = self.x[k+1]\n        y_k = self.y[k]\n        y_k1 = self.y[k+1]\n        m_k = self.m[k]\n        m_k1 = self.m[k+1]\n        \n        h = x_k1 - x_k\n        \n        # Normalize evaluation points to the local coordinate t in [0, 1].\n        t = (x_eval - x_k) / h\n        \n        # Evaluate using the standard Hermite basis functions.\n        t2 = t * t\n        t3 = t2 * t\n        \n        h00 = 2*t3 - 3*t2 + 1\n        h01 = -2*t3 + 3*t2\n        h10 = t3 - 2*t2 + t\n        h11 = t3 - t2\n        \n        s_eval = h00*y_k + h01*y_k1 + h*(h10*m_k + h11*m_k1)\n        \n        return s_eval\n\nsolve()\n```", "id": "3261829"}]}