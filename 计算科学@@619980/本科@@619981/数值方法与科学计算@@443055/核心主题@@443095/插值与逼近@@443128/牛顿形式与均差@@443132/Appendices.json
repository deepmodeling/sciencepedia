{"hands_on_practices": [{"introduction": "寻找复杂函数的根可能非常困难。一个强大的数值策略是用一个更简单的多项式来近似这个复杂函数，然后转而寻找该多项式的根。本练习将引导你完成整个过程，从构建牛顿插值多项式到求解其根，为你提供一个插值理论的实际应用。[@problem_id:3254701]", "problem": "给定一组互不相同的插值节点以及在这些节点上定义的实值函数。目标是通过构建一个次数至多为 $n$ 的牛顿插值多项式来逼近该函数的根，该多项式在给定节点处与函数值相匹配，然后在指定区间内找到该多项式的实根。此方法必须从基本定义出发：对于 $n+1$ 个不同的数据点，存在唯一的次数至多为 $n$ 的插值多项式，以及差商的递归定义。除了这些定义之外，您不能假设任何预先推导出的封闭形式“快捷”表达式。\n\n您的程序必须为每个测试用例实现以下内容：\n- 使用差商的定义，构建次数至多为 $n$ 的牛顿插值多项式 $P_n(x)$，使其对于给定的节点 $\\{x_0, x_1, \\dots, x_n\\}$ 满足 $P_n(x_i) = f(x_i)$。\n- 将牛顿形式转换为具有系数 $\\{a_0, a_1, \\dots, a_n\\}$ 的标准单项式形式，使得 $P_n(x) = a_0 + a_1 x + \\cdots + a_n x^n$。\n- 计算 $P_n(x)$ 的所有根，并提取出那些实根（虚部绝对值小于 $10^{-10}$），这些实根需位于指定区间内，并且在 $5 \\cdot 10^{-7}$ 的去重容差下代表不同的值。将根按升序排序。\n- 报告每个案例的实根列表，每个根都四舍五入到 $8$ 位小数。\n- 任何三角函数的角度都必须以弧度为单位进行解释。\n\n测试套件规范：\n- 案例 $1$ (振荡函数减去线性函数，预计有多个根):\n  - 函数: $f(x) = \\sin(x) - 0.5\\,x$。\n  - 节点: $\\{0,\\;0.5,\\;1.0,\\;1.5,\\;2.0,\\;3.0,\\;4.0\\}$。\n  - 区间: $[0,\\;4]$。\n- 案例 $2$ (带有多重根的多项式，预计插值能精确重现):\n  - 函数: $f(x) = x\\,(x-1)^2$。\n  - 节点: $\\{-0.5,\\;0.0,\\;0.75,\\;1.5\\}$。\n  - 区间: $[-0.5,\\;1.5]$。\n- 案例 $3$ (单调递减，预计有单个根):\n  - 函数: $f(x) = e^{-x} - 0.1$。\n  - 节点: $\\{0.0,\\;0.5,\\;1.0,\\;1.5,\\;2.0,\\;2.5,\\;3.0\\}$。\n  - 区间: $[0,\\;3]$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的根列表本身也呈现为用方括号括起来的、无空格的逗号分隔列表。例如，如果三个案例分别产生列表 $L_1$、$L_2$ 和 $L_3$，则输出必须严格采用 $[L_1,L_2,L_3]$ 的形式。\n- 每个根必须四舍五入到 $8$ 位小数。\n\n所有测试用例的答案都是浮点数列表。不涉及物理单位。所有三角函数求值必须使用以弧度为单位的角度。", "solution": "用户提供的问题是有效的。这是一个数值分析中的适定问题，基于多项式插值和求根的既定原则。所有必要的数据和约束都已提供，问题没有科学上的不可能性、矛盾或模糊之处。因此，我们可以着手解决。\n\n该问题要求我们通过首先用牛顿插值多项式 $P_n(x)$ 逼近函数 $f(x)$，然后在指定区间内找到 $P_n(x)$ 的实根。\n\n**1. 牛顿插值多项式**\n\n给定一组 $n+1$ 个不同的数据点 $(x_0, y_0), (x_1, y_1), \\dots, (x_n, y_n)$，其中 $y_i = f(x_i)$，存在唯一的次数至多为 $n$ 的多项式 $P_n(x)$，使得对所有 $i = 0, \\dots, n$ 都有 $P_n(x_i) = y_i$。该多项式的牛顿形式为：\n\n$$P_n(x) = c_0 + c_1(x-x_0) + c_2(x-x_0)(x-x_1) + \\dots + c_n(x-x_0)(x-x_1)\\dots(x-x_{n-1})$$\n\n这可以用乘积符号更紧凑地表示：\n\n$$P_n(x) = \\sum_{k=0}^{n} c_k \\prod_{j=0}^{k-1} (x-x_j)$$\n\n系数 $c_k$ 是差商，通过递归定义。函数 $f$ 关于节点 $x_i, \\dots, x_{i+k}$ 的 $k$ 阶差商表示为 $f[x_i, \\dots, x_{i+k}]$。\n\n递归定义如下：\n- **零阶：**\n  $$f[x_i] = f(x_i) = y_i$$\n- **$k$ 阶 (对于 $k \\ge 1$)：**\n  $$f[x_i, x_{i+1}, \\dots, x_{i+k}] = \\frac{f[x_{i+1}, \\dots, x_{i+k}] - f[x_i, \\dots, x_{i+k-1}]}{x_{i+k} - x_i}$$\n\n牛顿多项式的系数 $c_k$ 是差商表顶部对角线上的值：\n$$c_k = f[x_0, x_1, \\dots, x_k]$$\n\n对于一组节点 $\\{x_0, \\dots, x_n\\}$，可以构建差商表。第一列包含函数值 $y_i = f(x_i)$。后续的每个条目都由前一列的两个条目计算得出。例如，对于 $n=3$：\n\n| $x_i$ | $f[x_i]$      | $f[x_i, x_{i+1}]$ | $f[x_i, x_{i+1}, x_{i+2}]$ | $f[x_0, x_1, x_2, x_3]$ |\n| :---- | :------------ | :---------------- | :------------------------- | :-------------------------- |\n| $x_0$ | $y_0 = c_0$   |                   |                            |                             |\n|       |               | $f[x_0, x_1]=c_1$ |                            |                             |\n| $x_1$ | $y_1$         |                   | $f[x_0, x_1, x_2]=c_2$     |                             |\n|       |               | $f[x_1, x_2]$     |                            | $f[x_0, x_1, x_2, x_3]=c_3$ |\n| $x_2$ | $y_2$         |                   | $f[x_1, x_2, x_3]$         |                             |\n|       |               | $f[x_2, x_3]$     |                            |                             |\n| $x_3$ | $y_3$         |                   |                            |                             |\n\n我们将实现一个过程来计算此表并提取系数 $c_0, c_1, \\dots, c_n$。\n\n**2. 转换为单项式形式**\n\n牛顿形式适合于求值，但不适用于标准的求根算法，后者通常对以单项式为基的多项式进行操作，$P_n(x) = \\sum_{i=0}^{n} a_i x^i$。我们必须将 $P_n(x)$ 转换为这种形式。\n\n一种稳定且直接的转换方法是使用嵌套乘法方案。牛顿形式可以重写为：\n$$P_n(x) = c_0 + (x-x_0)\\bigg(c_1 + (x-x_1)\\Big(c_2 + \\dots + (x-x_{n-1})c_n\\Big)\\dots\\bigg)$$\n\n这种结构提示了一个迭代算法。设 $Q_k(x)$ 是第 $k$ 层嵌套内的多项式。\n- 从最内层的多项式开始：$Q_n(x) = c_n$ (一个次数为 $0$ 的多项式)。\n- 对 $k = n-1, n-2, \\dots, 0$ 迭代计算外部多项式：\n  $$Q_k(x) = c_k + (x-x_k)Q_{k+1}(x)$$\n- 最终的多项式是 $P_n(x) = Q_0(x)$。\n\n我们可以通过操作单项式基下的多项式系数数组来执行此迭代。设 `coeffs(P)` 表示多项式 $P$ 的系数数组。\n1.  用 `coeffs(Q_n) = [c_n]` 进行初始化。\n2.  对于从 $n-1$ 到 $0$ 的 $k$：\n    a.  设 `p_coeffs = coeffs(Q_{k+1})`。\n    b.  计算 `coeffs((x-x_k)Q_{k+1}(x))`。这涉及将 `p_coeffs` 乘以 $x$ (移动系数数组) 和 $-x_k$ (标量乘法)，然后将结果相加。\n    c.  将 $c_k$ 加到结果系数数组的常数项(第一个元素)上。这就得到了 `coeffs(Q_k)`。\n3.  最终的数组 `coeffs(Q_0)` 将包含单项式系数 $\\{a_0, a_1, \\dots, a_n\\}$。\n\n**3. 求根与筛选**\n\n一旦我们有了单项式系数 $\\{a_0, a_1, \\dots, a_n\\}$，我们就可以找到 $P_n(x) = 0$ 的根。一种标准的数值方法，如在 `NumPy` 等库中实现的，是找到多项式友矩阵的特征值。对于首一多项式 $p(x) = x^n + p_{n-1}x^{n-1} + \\dots + p_0$，其友矩阵为：\n$$C(p) = \\begin{pmatrix}\n0  0  \\dots  0  -p_0 \\\\\n1  0  \\dots  0  -p_1 \\\\\n0  1  \\dots  0  -p_2 \\\\\n\\vdots  \\vdots  \\ddots  \\vdots  \\vdots \\\\\n0  0  \\dots  1  -p_{n-1}\n\\end{pmatrix}$$\n$C(p)$ 的特征值正是 $p(x)$ 的根。`NumPy` 的 `roots` 函数就是利用这个原理。\n\n找到的根通常是复数。我们必须根据问题的标准对它们进行筛选：\n1.  **实根**：如果一个根 $z$ 的虚部绝对值可以忽略不计，即 $|\\text{Im}(z)| < 10^{-10}$，则认为该根是实根。\n2.  **区间检查**：实根必须位于指定的区间 $[x_{\\text{min}}, x_{\\text{max}}]$ 内。\n3.  **去重**：数值方法找到的根，特别是重根，可能会有微小差异。为了找到不同的根集合，我们对筛选后的根进行排序，然后遍历它们，只保留那些与前一个根的差值大于 $5 \\cdot 10^{-7}$ 容差的根。\n4.  **排序和四舍五入**：唯一的实根的最终列表按升序排序，并且每个根都四舍五入到 $8$ 位小数以供最终输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n\n    def divided_differences(x_nodes, y_values):\n        \"\"\"\n        Computes the divided differences table and returns the Newton coefficients.\n        \n        Args:\n            x_nodes (np.array): The distinct x-coordinates of the data points.\n            y_values (np.array): The y-coordinates of the data points (f(x)).\n\n        Returns:\n            np.array: The coefficients c_k of the Newton polynomial.\n        \"\"\"\n        n = len(x_nodes)\n        if n == 0:\n            return np.array([])\n        \n        # The table of divided differences.\n        # table[i, j] will store f[x_i, ..., x_{i+j}]\n        table = np.zeros((n, n))\n        table[:, 0] = y_values\n        \n        for j in range(1, n):\n            for i in range(n - j):\n                numerator = table[i + 1, j - 1] - table[i, j - 1]\n                denominator = x_nodes[i + j] - x_nodes[i]\n                table[i, j] = numerator / denominator\n                \n        # The coefficients are the top diagonal of the table: f[x_0], f[x_0,x_1], ...\n        return table[0, :]\n\n    def newton_to_monomial(x_nodes, newton_coeffs):\n        \"\"\"\n        Converts a polynomial from Newton form to monomial form.\n\n        Args:\n            x_nodes (np.array): The interpolation nodes x_0, x_1, ...\n            newton_coeffs (np.array): The Newton coefficients c_0, c_1, ...\n\n        Returns:\n            np.array: The coefficients a_0, a_1, ... of the monomial form.\n        \"\"\"\n        n = len(newton_coeffs) - 1\n        if n  0:\n            return np.array([])\n        \n        # Start with the highest-degree term: Q_n(x) = c_n\n        # poly_coeffs stores coeffs in increasing order of power [a_0, a_1, ...]\n        poly_coeffs = np.array([newton_coeffs[n]])\n        \n        # Iterate downwards: Q_k(x) = c_k + (x-x_k)Q_{k+1}(x)\n        for k in range(n - 1, -1, -1):\n            # Current poly_coeffs are for Q_{k+1}(x)\n            # Find coeffs for (x - x_k) * Q_{k+1}(x)\n            # Multiplying by x shifts coeffs up by one power. \n            # Pad with 0 at the start for the new constant term.\n            term_x_mult = np.pad(poly_coeffs, (1, 0), 'constant')\n\n            # Multiplying by -x_k is scalar multiplication. \n            # Pad with 0 at the end to match length.\n            term_xk_mult = -x_nodes[k] * np.pad(poly_coeffs, (0, 1), 'constant')\n\n            product_coeffs = term_x_mult + term_xk_mult\n\n            # Add the constant Newton coefficient c_k\n            product_coeffs[0] += newton_coeffs[k]\n            \n            poly_coeffs = product_coeffs\n\n        return poly_coeffs\n\n    def find_and_filter_roots(poly_coeffs, interval, imag_tol=1e-10, dedupe_tol=5e-7):\n        \"\"\"\n        Finds roots of a polynomial and filters them based on criteria.\n        \n        Args:\n            poly_coeffs (np.array): Monomial coefficients [a_0, a_1, ...].\n            interval (tuple): The interval [min, max] for filtering roots.\n            imag_tol (float): Tolerance for considering a root as real.\n            dedupe_tol (float): Tolerance for de-duplicating roots.\n\n        Returns:\n            list: A sorted list of unique, real roots within the interval.\n        \"\"\"\n        if len(poly_coeffs)  2:\n            return [] # Constant polynomial has no roots unless it's zero\n            \n        # numpy.roots expects coefficients from highest power to lowest\n        roots = np.roots(np.flip(poly_coeffs))\n        \n        # Filter for real roots\n        real_roots = roots[np.abs(np.imag(roots))  imag_tol].real\n        \n        # Filter for roots within the specified interval\n        x_min, x_max = interval\n        interval_roots = real_roots[(real_roots >= x_min)  (real_roots = x_max)]\n        interval_roots.sort()\n        \n        # De-duplicate roots\n        if len(interval_roots) == 0:\n            return []\n            \n        unique_roots = [interval_roots[0]]\n        for i in range(1, len(interval_roots)):\n            if interval_roots[i] - unique_roots[-1] > dedupe_tol:\n                unique_roots.append(interval_roots[i])\n                \n        return unique_roots\n    \n    # Test suite specification\n    test_cases = [\n        {\n            \"func\": lambda x: np.sin(x) - 0.5 * x,\n            \"nodes\": np.array([0., 0.5, 1.0, 1.5, 2.0, 3.0, 4.0]),\n            \"interval\": [0., 4.]\n        },\n        {\n            \"func\": lambda x: x * (x - 1)**2,\n            \"nodes\": np.array([-0.5, 0.0, 0.75, 1.5]),\n            \"interval\": [-0.5, 1.5]\n        },\n        {\n            \"func\": lambda x: np.exp(-x) - 0.1,\n            \"nodes\": np.array([0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0]),\n            \"interval\": [0., 3.]\n        }\n    ]\n    \n    final_results = []\n    \n    for case in test_cases:\n        func = case[\"func\"]\n        x_nodes = case[\"nodes\"]\n        interval = case[\"interval\"]\n        \n        y_values = func(x_nodes)\n        \n        # Step 1: Compute Newton coefficients\n        c_k = divided_differences(x_nodes, y_values)\n        \n        # Step 2: Convert to monomial form\n        a_i = newton_to_monomial(x_nodes, c_k)\n        \n        # Step 3: Find, filter, and process roots\n        roots_list = find_and_filter_roots(a_i, interval)\n        \n        # Step 4: Round roots to 8 decimal places\n        rounded_roots = [f\"{r:.8f}\" for r in roots_list]\n        \n        # Format for final output string\n        formatted_list = f\"[{','.join(rounded_roots)}]\"\n        final_results.append(formatted_list)\n        \n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```", "id": "3254701"}, {"introduction": "虽然多项式插值在数据点区间内可以非常精确，但用它来预测该区间之外的值——即外插——是出了名的不可靠。本练习将让你量化这种不稳定性，展示插值误差在数据区间外会如何迅速增长。你还将研究不同节点选择对近似行为的影响。[@problem_id:3254790]", "problem": "考虑一个定义在区间 $[a,b]$ 上的函数 $f$ 和一组互不相同的节点 $\\{x_0,x_1,\\dots,x_n\\}$，其中 $x_0=a$ 且 $x_n=b$。满足对所有 $i$ 都有 $p_n(x_i)=f(x_i)$ 的、次数至多为 $n$ 的唯一插值多项式 $p_n$，可以写成由均差构造的牛顿形式。均差是根据多项式插值的基本性质和插值多项式的唯一性递归定义的。在本任务中，您将使用牛顿形式和均差来构建 $p_n$，然后通过计算在插值区间外对 $p_n$ 求值时的误差来量化外插的不稳定性。\n\n从多项式插值的核心定义和均差的递归构造出发，实现一个程序，该程序能够：\n- 通过递归定义的均差为指定的节点 $\\{x_i\\}_{i=0}^n$ 构建牛顿插值多项式 $p_n$。\n- 在位于区间 $[x_0,x_n]$ 之外的点 $x$ 处计算 $p_n(x)$ 的值。\n- 计算在这些点上的绝对误差 $\\lvert f(x)-p_n(x)\\rvert$。\n- 对于有两个外部求值点 $x_{\\text{near}}$ 和 $x_{\\text{far}}$（其中 $x_{\\text{near}}$ 更靠近 $x_n$）的情况，返回定义为 $\\lvert f(x_{\\text{far}})-p_n(x_{\\text{far}})\\rvert \\big/ \\lvert f(x_{\\text{near}})-p_n(x_{\\text{near}})\\rvert$ 的增长因子。该增长因子量化了当求值点离插值区间越远时，外插误差增大的情况。\n\n使用以下测试套件来覆盖一系列行为：\n- 情况1：$f(x)=e^{x}$，区间 $[0,1]$，次数为 $n=10$ 的等距节点（即11个节点）。在 $x_{\\text{near}}=1.02$ 和 $x_{\\text{far}}=1.2$ 处求值。\n- 情况2：$f(x)=e^{x}$，区间 $[0,1]$，次数为 $n=10$ 的、映射到 $[0,1]$ 上的第一类切比雪夫节点（即11个节点）。在 $x_{\\text{near}}=1.02$ 和 $x_{\\text{far}}=1.2$ 处求值。\n- 情况3：$f(x)=\\dfrac{1}{1+25x^2}$（龙格函数），区间 $[-1,1]$，次数为 $n=10$ 的等距节点（即11个节点）。在 $x_{\\text{near}}=1.02$ 和 $x_{\\text{far}}=1.2$ 处求值。\n- 情况4：$f(x)=\\cos(x)$，区间 $[0,\\pi]$，次数为 $n=12$ 的等距节点（即13个节点）。在 $x_{\\text{near}}=\\pi+0.01$ 和 $x_{\\text{far}}=\\pi+0.2$ 处求值。所有角度测量均使用弧度。\n- 情况5：$f(x)=e^{x}$，区间 $[0,1]$，次数为 $n=10$ 的等距节点，在一个邻近边界的点 $x_{\\text{only}}=1+10^{-12}$ 处求值（此情况只有一个外部点，因此只返回绝对误差）。\n\n节点规格：\n- 对于区间 $[a,b]$ 上次数为 $n$ 的等距节点，使用 $n+1$ 个节点 $x_i=a+\\dfrac{i}{n}(b-a)$，其中 $i=0,1,\\dots,n$。\n- 对于区间 $[a,b]$ 上次数为 $n$ 的第一类切比雪夫节点，使用 $n+1$ 个节点 $x_k=\\dfrac{a+b}{2}+\\dfrac{b-a}{2}\\cos\\!\\left(\\dfrac{k\\pi}{n}\\right)$，其中 $k=0,1,\\dots,n$。\n\n您的程序必须计算：\n- 对于情况1到4，计算增长因子 $\\gamma=\\lvert f(x_{\\text{far}})-p_n(x_{\\text{far}})\\rvert \\big/ \\lvert f(x_{\\text{near}})-p_n(x_{\\text{near}})\\rvert$。\n- 对于情况5，计算单个绝对误差值 $\\lvert f(x_{\\text{only}})-p_n(x_{\\text{only}})\\rvert$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按情况1到5顺序排列的结果，格式为逗号分隔的列表并用方括号括起：$[\\gamma_1,\\gamma_2,\\gamma_3,\\gamma_4,E_5]$，其中 $\\gamma_i$ 为浮点数， $E_5$ 为浮点数。不应打印任何额外文本。\n\n本问题不涉及物理单位。余弦函数的所有角度必须以弧度为单位进行解释。", "solution": "该问题要求构建牛顿形式的插值多项式，并分析其外插误差。这将通过首先计算给定节点集的均差来完成，这些均差将作为牛顿多项式的系数。随后，将在插值区间外的点上对该多项式求值，以量化误差。\n\n对于 $n+1$ 个不同的节点 $\\{x_0, x_1, \\dots, x_n\\}$，存在一个唯一的次数至多为 $n$ 的多项式 $p_n(x)$，它对函数 $f(x)$ 进行插值，满足对所有 $i \\in \\{0, 1, \\dots, n\\}$ 都有 $p_n(x_i) = f(x_i)$。该多项式的牛顿形式由以下公式给出：\n$$ p_n(x) = \\sum_{k=0}^{n} c_k \\prod_{j=0}^{k-1} (x - x_j) $$\n这可以明确地写为：\n$$ p_n(x) = c_0 + c_1(x-x_0) + c_2(x-x_0)(x-x_1) + \\dots + c_n(x-x_0)(x-x_1)\\dots(x-x_{n-1}) $$\n系数 $c_k$ 是均差，定义为 $c_k = f[x_0, x_1, \\dots, x_k]$。\n\n均差是递归计算的。零阶均差是函数值本身：\n$$ f[x_i] = f(x_i) $$\n高阶均差由递归公式定义：\n$$ f[x_i, \\dots, x_{i+j}] = \\frac{f[x_{i+1}, \\dots, x_{i+j}] - f[x_i, \\dots, x_{i+j-1}]}{x_{i+j} - x_i} $$\n牛顿多项式所需的系数 $c_k$ 位于均差表的上对角线上：$c_0 = f[x_0]$，$c_1 = f[x_0, x_1]$，依此类推，直到 $c_n = f[x_0, \\dots, x_n]$。一种计算上高效的求这些系数的方法是对一个初始包含函数值 $y_i = f(x_i)$ 的数组使用原地算法。设此数组为 $C$。算法流程如下：\n对于 $k$ 从 $1$ 到 $n$：\n  对于 $i$ 从 $n$ 向下到 $k$：\n    $C[i] \\leftarrow \\frac{C[i] - C[i-1]}{x_i - x_{i-k}}$\n这些循环完成后，数组 $C$ 包含所需的系数：$C[k] = c_k = f[x_0, \\dots, x_k]$。此过程被实现用于计算每个测试用例的系数。\n\n一旦系数 $c_k$ 和节点 $x_k$ 被确定，多项式 $p_n(x)$ 可以在任何点 $x$ 处求值。为了数值稳定性和效率，我们使用Horner's method，它将牛顿形式重新排列为嵌套乘法：\n$$ p_n(x) = c_0 + (x-x_0)\\bigg(c_1 + (x-x_1)\\Big(c_2 + \\dots + (x-x_{n-1})c_n\\Big)\\bigg) $$\n这是迭代求值的。设 $y$ 为正在计算的值。\n初始化 $y = c_n$。\n对于 $i$ 从 $n-1$ 向下到 $0$：\n  $y \\leftarrow c_i + (x - x_i)y$\n$y$ 的最终值即为 $p_n(x)$。\n\n问题为次数为 $n$ 的多项式指定了在区间 $[a,b]$ 上的两种节点类型：\n1.  等距节点：$x_i = a + i \\frac{b-a}{n}$，其中 $i=0, 1, \\dots, n$。\n2.  第一类切比雪夫节点：这些是单位圆上等距点在直径上的投影。在 $[-1,1]$ 上的标准公式是 $\\cos(\\frac{k\\pi}{n})$。要将它们映射到 $[a,b]$，公式为 $x_k = \\frac{a+b}{2} + \\frac{b-a}{2}\\cos(\\frac{k\\pi}{n})$，其中 $k=0, 1, \\dots, n$。此公式生成的节点从 $b$ 到 $a$ 是降序的。为了在实现均差和求值算法时保持一致的升序 $x_0  x_1  \\dots  x_n$，生成的节点需要被排序。\n\n主要目标是研究外插误差，该误差发生在插值区间 $[x_0, x_n]$ 之外的点 $x$ 处对 $p_n(x)$ 求值时。绝对误差为 $E(x) = \\lvert f(x) - p_n(x) \\rvert$。为了量化不稳定性，我们为两个外插点 $x_{\\text{near}}$ 和 $x_{\\text{far}}$（其中 $x_{\\text{near}}$ 更靠近区间边界）计算增长因子 $\\gamma$：\n$$ \\gamma = \\frac{E(x_{\\text{far}})}{E(x_{\\text{near}})} = \\frac{\\lvert f(x_{\\text{far}}) - p_n(x_{\\text{far}}) \\rvert}{\\lvert f(x_{\\text{near}}) - p_n(x_{\\text{near}}) \\rvert} $$\n$\\gamma$ 的值很大表明当点远离插值区间时，外插误差会迅速增长。\n\n程序为五个测试用例中的每一个都实现了这些步骤。对于情况1到4，它计算增长因子 $\\gamma$。对于情况5，它涉及单个求值点 $x_{\\text{only}}$，计算绝对误差 $E(x_{\\text{only}})$。然后收集结果并按指定格式打印。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef newton_poly_coeffs(x_nodes, y_values):\n    \"\"\"\n    Computes the coefficients of the Newton interpolating polynomial.\n    This is done by calculating the divided differences.\n    The calculation is performed in-place for memory efficiency.\n\n    Args:\n        x_nodes (np.array): The x-coordinates of the interpolation nodes.\n        y_values (np.array): The y-coordinates (function values) at the nodes.\n\n    Returns:\n        np.array: The divided difference coefficients for the Newton polynomial.\n    \"\"\"\n    n = len(x_nodes) - 1\n    coeffs = np.copy(y_values)\n    for k in range(1, n + 1):\n        for i in range(n, k - 1, -1):\n            # Check for division by zero, although not expected with distinct nodes\n            denominator = x_nodes[i] - x_nodes[i-k]\n            if denominator == 0:\n                # This case implies non-distinct nodes, which violates problem constraints.\n                # However, for robustness, one could handle this.\n                raise ValueError(\"x_nodes must be distinct.\")\n            coeffs[i] = (coeffs[i] - coeffs[i-1]) / denominator\n    return coeffs\n\ndef evaluate_newton_poly(coeffs, x_nodes, x_eval):\n    \"\"\"\n    Evaluates the Newton form of the interpolating polynomial at a point x_eval.\n    Uses Horner's method for efficiency and numerical stability.\n\n    Args:\n        coeffs (np.array): The coefficients from the divided difference table.\n        x_nodes (np.array): The x-coordinates of the interpolation nodes.\n        x_eval (float): The point at which to evaluate the polynomial.\n\n    Returns:\n        float: The value of the polynomial p_n(x_eval).\n    \"\"\"\n    n = len(coeffs) - 1\n    result = coeffs[n]\n    for i in range(n - 1, -1, -1):\n        result = coeffs[i] + (x_eval - x_nodes[i]) * result\n    return result\n\ndef solve():\n    \"\"\"\n    Solves the specified set of interpolation and extrapolation problems.\n    \"\"\"\n    # Define the functions for the test cases\n    f1 = lambda x: np.exp(x)\n    f2 = lambda x: 1.0 / (1.0 + 25.0 * x**2)\n    f3 = lambda x: np.cos(x)\n\n    # Define the parameters for each test case\n    test_cases = [\n        {'f': f1, 'interval': [0.0, 1.0], 'n': 10, 'node_type': 'equispaced', 'eval_points': [1.02, 1.2]},\n        {'f': f1, 'interval': [0.0, 1.0], 'n': 10, 'node_type': 'chebyshev', 'eval_points': [1.02, 1.2]},\n        {'f': f2, 'interval': [-1.0, 1.0], 'n': 10, 'node_type': 'equispaced', 'eval_points': [1.02, 1.2]},\n        {'f': f3, 'interval': [0.0, np.pi], 'n': 12, 'node_type': 'equispaced', 'eval_points': [np.pi + 0.01, np.pi + 0.2]},\n        {'f': f1, 'interval': [0.0, 1.0], 'n': 10, 'node_type': 'equispaced', 'eval_points': [1.0 + 1e-12]}\n    ]\n\n    results = []\n\n    for case in test_cases:\n        f = case['f']\n        a, b = case['interval']\n        n = case['n']\n        node_type = case['node_type']\n        eval_points = case['eval_points']\n\n        # Step 1: Generate interpolation nodes\n        if node_type == 'equispaced':\n            x_nodes = np.linspace(a, b, n + 1)\n        else:  # chebyshev\n            k = np.arange(n + 1)\n            # Problem formula generates nodes in descending order. We sort them to be consistent.\n            nodes_desc = (a + b) / 2.0 + (b - a) / 2.0 * np.cos(k * np.pi / n)\n            x_nodes = np.sort(nodes_desc)\n        \n        y_values = f(x_nodes)\n\n        # Step 2: Compute Newton polynomial coefficients\n        coeffs = newton_poly_coeffs(x_nodes, y_values)\n\n        # Step 3: Evaluate and compute the required result (growth factor or error)\n        if len(eval_points) == 2:\n            x_near, x_far = eval_points\n\n            p_near = evaluate_newton_poly(coeffs, x_nodes, x_near)\n            f_near = f(x_near)\n            error_near = np.abs(f_near - p_near)\n            \n            p_far = evaluate_newton_poly(coeffs, x_nodes, x_far)\n            f_far = f(x_far)\n            error_far = np.abs(f_far - p_far)\n\n            if error_near == 0.0:\n                # Handle division by zero, though unlikely in these cases.\n                # If near error is zero, far error being non-zero implies infinite growth.\n                growth_factor = np.inf if error_far  0.0 else 0.0\n            else:\n                growth_factor = error_far / error_near\n            results.append(growth_factor)\n        else:  # len == 1, Case 5\n            x_only = eval_points[0]\n            \n            p_only = evaluate_newton_poly(coeffs, x_nodes, x_only)\n            f_only = f(x_only)\n            error_only = np.abs(f_only - p_only)\n            results.append(error_only)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3254790"}, {"introduction": "高阶多项式插值的成功与否取决于被近似函数的光滑性。本练习将探讨当该方法应用于像 $f(x)=|x|$ 这样的非光滑函数（其在原点有一个尖点）时，是如何失效的。你将观察到函数的不可微性如何体现为巨大的插值误差，并将全局多项式方法与更稳健的局部方法进行比较。[@problem_id:3254712]", "problem": "考虑函数 $f(x)=|x|$ 和使用差商的牛顿形式多项式插值。从两个不同节点 $x_0$ 和 $x_1$ 之间的一阶差商的基本定义出发，\n$$\n[x_0,x_1] = \\frac{f(x_1)-f(x_0)}{x_1-x_0},\n$$\n以及高阶差商的递归定义，\n$$\n[x_0,x_1,\\dots,x_k] = \\frac{[x_1,\\dots,x_k]-[x_0,\\dots,x_{k-1}]}{x_k - x_0},\n$$\n使用差商作为系数构建牛顿插值多项式。分析当节点集跨越 $x=0$ 时，$f(x)=|x|$ 在 $x=0$ 处的不可导性如何体现在这些高阶差商中。然后，提出并实现一种避免大幅振荡的稳健插值策略，并与全局牛顿多项式相比，评估其有效性。\n\n您必须编写一个完整的程序，该程序：\n- 对于每个给定的节点集，计算函数 $f(x)=|x|$ 的差商表系数 $c_k=[x_0,\\dots,x_k]$，并构建 $n$ 次牛顿插值多项式 $P_n(x)$。\n- 构建一个避免振荡的稳健插值函数 $L(x)$。在连续节点 $(x_i,f(x_i))$ 上使用分段线性插值。\n- 在一个包含 $m=1001$ 个点的均匀网格上评估 $P_n(x)$ 和 $L(x)$，该网格跨越 $[x_{\\min},x_{\\max}]$，其中 $x_{\\min}$ 和 $x_{\\max}$ 是节点集中的最小和最大节点。\n- 对于每个节点集，报告最高阶差商系数的绝对值 $|c_n|$、牛顿多项式的最大绝对插值误差，\n$$\nE_{\\text{poly}} = \\max_{x\\in\\text{grid}} |P_n(x)-|x||,\n$$\n以及稳健的分段线性插值函数的最大绝对插值误差，\n$$\nE_{\\text{robust}} = \\max_{x\\in\\text{grid}} |L(x)-|x||.\n$$\n\n使用以下节点集测试套件：\n1. $x=\\left[-1,\\,0,\\,1\\right]$ (跨越 $x=0$ 的对称节点；一般情况)。\n2. $x=\\left[-1,\\,-\\tfrac{1}{2},\\,0,\\,\\tfrac{1}{2},\\,1\\right]$ (更密集的对称节点；可能出现振荡)。\n3. $x=\\left[-10^{-3},\\,0,\\,10^{-3}\\right]$ (极靠近 $x=0$ 的节点；高阶差商的边界行为)。\n4. $x=\\left[0.1,\\,0.2,\\,0.4,\\,0.8\\right]$ (所有节点均在正半轴；不跨越不可导点)。\n\n所有量纲均为无量纲。不涉及角度单位。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个按 $\\left[|c_n|, E_{\\text{poly}}, E_{\\text{robust}}\\right]$ 顺序排列的包含三个十进制数的子列表。格式必须严格如下：\n```[[|c_n|,E_poly,E_robust],[|c_n|,E_poly,E_robust],...]]```\n在行内任何地方都不能有空格。", "solution": "该问题要求分析针对非光滑函数 $f(x) = |x|$ 的牛顿差商插值。我们必须计算插值多项式和一个稳健的分段线性替代方案，然后比较它们在几组节点上的最大绝对误差。\n\n分析的核心在于函数的光滑性与其差商行为之间的关系。对于在区间 $I$ 上 $k$ 次连续可微的函数 $f$，基于 $I$ 中不同节点 $x_0, x_1, \\dots, x_k$ 的 $k$ 阶差商与 $f$ 的 $k$ 阶导数通过差商中值定理相关联：\n$$\n[x_0, x_1, \\dots, x_k] = \\frac{f^{(k)}(\\xi)}{k!}\n$$\n其中 $\\xi$ 位于节点所跨越的区间内。因此，牛顿插值多项式\n$$\nP_n(x) = c_0 + c_1(x-x_0) + c_2(x-x_0)(x-x_1) + \\dots + c_n \\prod_{i=0}^{n-1}(x-x_i),\n$$\n的系数 $c_k = [x_0, \\dots, x_k]$ 可被视为函数缩放后导数的近似。对于解析函数，其导数是良态的，对于高次插值，高阶系数 $c_k$ 趋于零，导致 $P_n(x)$ 收敛于 $f(x)$。\n\n函数 $f(x)=|x|$ 是此行为的一个关键例外。它处处连续，但在 $x=0$ 处不可导。它的一阶导数可以表示为符号函数 $f'(x) = \\text{sgn}(x)$，在 $x=0$ 处有一个跳跃间断点。二阶导数在经典意义上不存在；在分布理论的框架下，它是狄拉克δ函数 $f''(x) = 2\\delta(x)$，在 $x=0$ 处是奇异的。\n\n这种非光滑性对多项式插值有深远的影响，我们可以根据节点配置进行分析：\n\n1.  **节点位于奇点的一侧：**如果所有插值节点 $\\{x_i\\}$ 都在 $x=0$ 的一侧（即所有 $x_i  0$ 或所有 $x_i  0$），那么在这些节点所跨越的区间上，$f(x)$ 等价于一个简单的多项式，即 $f(x)=x$ 或 $f(x)=-x$。对于 $f(x)=x$，一阶差商 $[x_i, x_j]$ 恒为 $1$，而所有 $k \\ge 2$ 的高阶差商 $[x_i, \\dots, x_k]$ 均为零。牛顿多项式将精确地重建该函数，导致插值误差为零。测试用例4证明了这一点。\n\n2.  **节点跨越奇点：**当节点集包含 $x=0$ 两侧的点（也可能包含 $x=0$ 本身）时，插值区间就包含了不可导点。对于 $k \\ge 1$ 阶的导数，差商中值定理不再适用。差商不能近似一个良态的导数。相反，它们试图捕捉函数在 $x=0$ 处导数的奇异性质。具体来说，对于包围原点的节点，二阶差商 $[x_0, x_1, x_2]$ 将会很大。对于对称节点 $x_0 = -\\epsilon, x_1 = 0, x_2 = \\epsilon$（其中 $\\epsilon  0$），我们计算：\n    $$\n    [x_0, x_1] = \\frac{f(0) - f(-\\epsilon)}{0 - (-\\epsilon)} = \\frac{0 - \\epsilon}{\\epsilon} = -1\n    $$\n    $$\n    [x_1, x_2] = \\frac{f(\\epsilon) - f(0)}{\\epsilon - 0} = \\frac{\\epsilon - 0}{\\epsilon} = 1\n    $$\n    $$\n    c_2 = [x_0, x_1, x_2] = \\frac{[x_1, x_2] - [x_0, x_1]}{x_2 - x_0} = \\frac{1 - (-1)}{\\epsilon - (-\\epsilon)} = \\frac{2}{2\\epsilon} = \\frac{1}{\\epsilon}\n    $$\n    当 $\\epsilon \\to 0$ 时，该系数发散，反映了奇异二阶导数的行为。高阶系数的这种增长导致全局多项式 $P_n(x)$ 表现出伪振荡（一种与龙格现象有关的行为），从而导致较大的最大误差 $E_{\\text{poly}}$。\n\n为避免此问题，稳健的插值策略必须是局部的，而非全局的。所提出的分段线性插值函数 $L(x)$ 用直线连接每对相邻节点 $(x_i, f(x_i))$ 和 $(x_{i+1}, f(x_{i+1}))$。此方法对函数的全局属性不敏感，仅依赖于局部数据。由于函数 $f(x)=|x|$ 本身由两段线性部分组成，通过位于 $f(x)$ 上的节点的分段线性插值函数 $L(x)$ 将与 $f(x)$ 本身完全相同。因此，插值误差 $E_{\\text{robust}} = \\max |L(x) - |x||$ 预计为零，或在机器精度水平。\n\n对于每个测试用例，算法按以下步骤进行：\n1.  给定节点集 $\\{x_i\\}_{i=0}^n$，计算相应的值 $\\{y_i = |x_i|\\}_{i=0}^n$。\n2.  构建差商表以找到牛顿系数 $c_k = [x_0, \\dots, x_k]$。最终系数为 $c_n$。\n3.  使用霍纳法在 $[x_{\\min}, x_{\\max}]$ 区间内一个包含 $m=1001$ 个点的密集网格上评估牛顿多项式 $P_n(x)$。计算最大绝对误差 $E_{\\text{poly}} = \\max |P_n(x) - |x||$。\n4.  使用排序后的节点构建分段线性插值函数 $L(x)$。对于 $f(x)=|x|$，这将等同于 $|x|$。计算最大绝对误差 $E_{\\text{robust}} = \\max |L(x) - |x||$。\n5.  报告三元组 $[|c_n|, E_{\\text{poly}}, E_{\\text{robust}}]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the interpolation problem for f(x)=|x| for multiple test cases.\n    \"\"\"\n\n    def compute_divided_differences(x_nodes, y_nodes):\n        \"\"\"\n        Computes the divided differences table and returns the coefficients for\n        the Newton polynomial (the top diagonal of the table).\n        \n        Args:\n            x_nodes (np.ndarray): The x-coordinates of the interpolation nodes.\n            y_nodes (np.ndarray): The y-coordinates of the interpolation nodes.\n\n        Returns:\n            np.ndarray: The Newton polynomial coefficients (c_0, c_1, ..., c_n).\n        \"\"\"\n        n = len(x_nodes)\n        coeffs = np.copy(y_nodes)\n        for j in range(1, n):\n            for i in range(n - 1, j - 1, -1):\n                coeffs[i] = (coeffs[i] - coeffs[i - 1]) / (x_nodes[i] - x_nodes[i - j])\n        return coeffs\n\n    def evaluate_newton_poly(x_eval, x_nodes, coeffs):\n        \"\"\"\n        Evaluates the Newton form of the interpolation polynomial using Horner's method.\n        \n        Args:\n            x_eval (np.ndarray): Points at which to evaluate the polynomial.\n            x_nodes (np.ndarray): The x-coordinates of the interpolation nodes.\n            coeffs (np.ndarray): The Newton polynomial coefficients.\n\n        Returns:\n            np.ndarray: The value of the polynomial at each point in x_eval.\n        \"\"\"\n        n = len(coeffs) - 1\n        y = np.full_like(x_eval, coeffs[n])\n        for i in range(n - 1, -1, -1):\n            y = coeffs[i] + (x_eval - x_nodes[i]) * y\n        return y\n    \n    def process_case(x_nodes_list):\n        \"\"\"\n        Processes a single test case: computes coefficients, polynomials, and errors.\n        \n        Args:\n            x_nodes_list (list): A list of floating-point numbers for the nodes.\n\n        Returns:\n            list: A list containing [|c_n|, E_poly, E_robust].\n        \"\"\"\n        x_nodes = np.array(x_nodes_list, dtype=np.float64)\n        y_nodes = np.abs(x_nodes)\n        n = len(x_nodes) - 1\n\n        # 1. Compute divided differences and get the highest-order coefficient c_n\n        # We need to reorder the coefficients from the typical output of a DD table\n        # function to match the Newton form P(x) = c0 + c1(x-x0) + ...\n        # The function below computes coeffs in place: F[j,j] becomes the coefficient c_j\n        F = np.zeros((n + 1, n + 1))\n        F[:, 0] = y_nodes\n\n        for j in range(1, n + 1):\n            for i in range(j, n + 1):\n                F[i, j] = (F[i, j - 1] - F[i - 1, j - 1]) / (x_nodes[i] - x_nodes[i - j])\n        \n        coeffs = np.diag(F)\n        abs_cn = np.abs(coeffs[n])\n\n        # 2. Set up evaluation grid\n        m = 1001\n        x_min, x_max = np.min(x_nodes), np.max(x_nodes)\n        x_eval = np.linspace(x_min, x_max, m)\n        y_true = np.abs(x_eval)\n\n        # 3. Evaluate Newton polynomial and its error\n        y_poly = evaluate_newton_poly(x_eval, x_nodes, coeffs)\n        e_poly = np.max(np.abs(y_poly - y_true))\n\n        # 4. Evaluate piecewise linear interpolant and its error\n        # np.interp requires sorted x-coordinates\n        sort_indices = np.argsort(x_nodes)\n        x_sorted = x_nodes[sort_indices]\n        y_sorted = y_nodes[sort_indices]\n        y_robust = np.interp(x_eval, x_sorted, y_sorted)\n        e_robust = np.max(np.abs(y_robust - y_true))\n\n        return [abs_cn, e_poly, e_robust]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [-1.0, 0.0, 1.0],\n        [-1.0, -0.5, 0.0, 0.5, 1.0],\n        [-1e-3, 0.0, 1e-3],\n        [0.1, 0.2, 0.4, 0.8],\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(process_case(case))\n    \n    # Format the final output string exactly as required, with no spaces.\n    result_strings = []\n    for res_list in results:\n        # Format each number and join with commas, enclosed in brackets.\n        sublist_string = f\"[{res_list[0]},{res_list[1]},{res_list[2]}]\"\n        result_strings.append(sublist_string)\n\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3254712"}]}