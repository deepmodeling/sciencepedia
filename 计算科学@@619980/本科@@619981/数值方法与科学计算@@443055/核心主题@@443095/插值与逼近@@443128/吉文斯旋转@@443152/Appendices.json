{"hands_on_practices": [{"introduction": "本次练习是掌握吉文斯旋转的基石。我们将学习如何计算一个特定的旋转矩阵，用以将一个二维向量的第二个分量清零。这个练习揭示了吉文斯旋转作为一种工具，其精确构造以达成特定目标（如在向量或矩阵中引入零）的核心机制。[@problem_id:2176490]", "problem": "在数值线性代数中，吉文斯旋转（Givens rotation）是一种在二维平面内旋转向量的操作，常用于诸如QR分解等算法中，以在向量或矩阵中引入零元素。一个 2x2 的吉文斯矩阵是形如下式的正交矩阵\n$$\nG = \\begin{pmatrix} c  s \\\\ -s  c \\end{pmatrix}\n$$\n其中 $c$ 和 $s$ 是满足条件 $c^2 + s^2 = 1$ 的实数。\n\n考虑向量 $x = \\begin{pmatrix} 7 \\\\ -4 \\end{pmatrix}$。请确定具体的吉文斯矩阵 $G$，使得它将向量 $x$ 变换为一个新向量 $y = Gx$，该新向量的形式为 $\\begin{pmatrix} r \\\\ 0 \\end{pmatrix}$，并且满足附加约束条件，即得到的分量 $r$ 必须为正。\n\n请以一个包含精确数值的 2x2 矩阵的形式给出您的答案。", "solution": "设 $G=\\begin{pmatrix} c  s \\\\ -s  c \\end{pmatrix}$，其中 $c^{2}+s^{2}=1$，且 $x=\\begin{pmatrix} a \\\\ b \\end{pmatrix}$。则\n$$\nGx=\\begin{pmatrix} ca+sb \\\\ -sa+cb \\end{pmatrix}.\n$$\n为了得到 $Gx=\\begin{pmatrix} r \\\\ 0 \\end{pmatrix}$，需令其第二分量为零：\n$$\n-sa+cb=0 \\quad \\Longleftrightarrow \\quad cb=sa.\n$$\n满足此式和 $c^{2}+s^{2}=1$ 的一个标准选择是\n$$\nr=\\sqrt{a^{2}+b^{2}}, \\quad c=\\frac{a}{r}, \\quad s=\\frac{b}{r}.\n$$\n根据此选择，\n$$\n-sa+cb=-\\frac{b}{r}a+\\frac{a}{r}b=0, \\quad ca+sb=\\frac{a^{2}+b^{2}}{r}=r,\n$$\n又因 $r=\\sqrt{a^{2}+b^{2}}$ 为正，故 $r>0$ 的要求得以满足。\n\n对于 $x=\\begin{pmatrix} 7 \\\\ -4 \\end{pmatrix}$，我们有 $a=7$，$b=-4$，因此\n$$\nr=\\sqrt{7^{2}+(-4)^{2}}=\\sqrt{65}, \\quad c=\\frac{7}{\\sqrt{65}}, \\quad s=\\frac{-4}{\\sqrt{65}}.\n$$\n因此，\n$$\nG=\\begin{pmatrix} \\frac{7}{\\sqrt{65}}  \\frac{-4}{\\sqrt{65}} \\\\ \\frac{4}{\\sqrt{65}}  \\frac{7}{\\sqrt{65}} \\end{pmatrix}.\n$$\n此 $G$ 矩阵可得 $Gx=\\begin{pmatrix} \\sqrt{65} \\\\ 0 \\end{pmatrix}$，其第一分量为正，符合要求。", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{7}{\\sqrt{65}}  \\frac{-4}{\\sqrt{65}} \\\\ \\frac{4}{\\sqrt{65}}  \\frac{7}{\\sqrt{65}} \\end{pmatrix}}$$", "id": "2176490"}, {"introduction": "现实世界中的数值问题通常涉及高于二维的向量空间。本练习将二维的旋转概念推广到更高维度，展示了一个吉文斯旋转如何被嵌入到高维空间中，以选择性地修改两个特定分量，同时保持所有其他分量不变。理解这一点对于掌握它在诸如QR分解等矩阵分解算法中的应用至关重要。[@problem_id:1365942]", "problem": "在数值线性代数中，Givens 旋转 (Givens rotation) 是由两个坐标轴张成的平面中的一个旋转。Givens 旋转矩阵 $G(i,j,c,s)$ 是一个单位矩阵，但有四个元素不同，其设计目的是在 $(i, j)$ 平面中执行旋转。对于三维欧几里得空间 $\\mathbb{R}^3$，矩阵 $G(i,j,c,s)$ 的定义使其元素为 $G_{kk} = 1$ (对于 $k \\notin \\{i, j\\}$)，$G_{ii} = c$，$G_{jj} = c$，$G_{ij} = s$，以及 $G_{ji} = -s$，其中 $c$ 和 $s$ 是满足 $c^2 + s^2 = 1$ 的实数。所有其他非对角元素均为零。\n\n考虑一个在 $(1,3)$ 平面内的特定 Givens 旋转，记为 $G_{1,3}$，其参数为 $c = \\frac{3}{5}$ 和 $s = \\frac{4}{5}$。\n\n求此旋转作用于向量 $v = \\begin{pmatrix} 5 \\\\ 1 \\\\ 10 \\end{pmatrix}$ 后得到的向量。请将您的答案表示为所得向量的分量。", "solution": "在 $(i,j)$ 平面内的 Givens 旋转 $G(i,j,c,s)$ 有一个 $2\\times 2$ 的子矩阵 $\\begin{pmatrix} c  s \\\\ -s  c \\end{pmatrix}$ 作用于向量 $v$ 的 $(v_{i},v_{j})$ 分量，而其他分量保持不变。因此，对于 $i=1$ 和 $j=3$，对 $v=\\begin{pmatrix} v_{1} \\\\ v_{2} \\\\ v_{3} \\end{pmatrix}$ 的作用由下式给出：\n$$\nv_{1}'=c\\,v_{1}+s\\,v_{3},\\quad v_{2}'=v_{2},\\quad v_{3}'=-s\\,v_{1}+c\\,v_{3}.\n$$\n使用 $c=\\frac{3}{5}$，$s=\\frac{4}{5}$ 和 $v=\\begin{pmatrix} 5 \\\\ 1 \\\\ 10 \\end{pmatrix}$，计算每个分量：\n$$\nv_{1}'=\\frac{3}{5}\\cdot 5+\\frac{4}{5}\\cdot 10=3+8=11,\n$$\n$$\nv_{2}'=1,\n$$\n$$\nv_{3}'=-\\frac{4}{5}\\cdot 5+\\frac{3}{5}\\cdot 10=-4+6=2.\n$$\n因此，所得向量为 $\\begin{pmatrix} 11 \\\\ 1 \\\\ 2 \\end{pmatrix}$。", "answer": "$$\\boxed{\\begin{pmatrix} 11 \\\\ 1 \\\\ 2 \\end{pmatrix}}$$", "id": "1365942"}, {"introduction": "吉文斯旋转的真正威力在于其在算法中能够被高效地顺序应用，而无需存储或构造完整的 $n \\times n$ 旋转矩阵。这项编程练习将挑战你实现一个算法，直接将一系列旋转应用于一个向量，从而模拟它在大型数值计算中的实际工作方式。这项技能是开发和理解高级数值方法的基础。[@problem_id:3236383]", "problem": "给定一个平面旋转序列（吉文斯旋转）和一个目标向量。目标是在不显式构造完整正交矩阵的情况下，将该旋转序列应用于该向量。使用的基本原理是正交矩阵的定义以及吉文斯旋转的结构，即它作用于两个坐标，在除了一个二维正交子块之外的所有地方都表现为单位矩阵。一个吉文斯旋转由作用于索引 $i$ 和 $j$ 的参数 $c$ 和 $s$ 定义，满足 $c^2 + s^2 = 1$。\n\n定义和约束：\n- 一个吉文斯旋转 $G(i,j;c,s)$ 作用于向量 $\\mathbf{x} \\in \\mathbb{R}^n$，仅通过一个二维正交子块变换分量 $x_i$ 和 $x_j$\n$$\n\\begin{pmatrix}\nc  s \\\\\n-s  c\n\\end{pmatrix},\n$$\n而所有其他分量保持不变。参数满足 $c^2 + s^2 = 1$。\n- 旋转序列为 $Q = G_k \\dots G_1$，将其应用于向量 $\\mathbf{x}$ 的操作是 $Q \\mathbf{x}$，按从 $G_1$ 到 $G_k$ 的顺序进行（即，先将 $G_1$ 应用于 $\\mathbf{x}$，然后将 $G_2$ 应用于结果，以此类推）。\n- 所有索引 $i$ 和 $j$ 均使用从 0 开始的索引。\n- 不使用角度；每个旋转由其 $(c,s)$ 值指定。\n- 不要构造完整的矩阵 $Q$。算法每次旋转必须只更新相关的两个元素。\n\n任务：\n- 编写一个完整的程序，将给定的吉文斯旋转序列 $Q = G_k \\dots G_1$ 应用于长度为 $n$ 的向量 $\\mathbf{x}$，而不显式构造矩阵 $Q$。\n- 对于每个旋转 $G(i,j;c,s)$，根据以下规则更新两个元素 $x_i$ 和 $x_j$\n$$\n\\begin{pmatrix}\nx_i' \\\\\nx_j'\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nc  s \\\\\n-s  c\n\\end{pmatrix}\n\\begin{pmatrix}\nx_i \\\\\nx_j\n\\end{pmatrix},\n$$\n从 $G_1$ 到 $G_k$ 依序应用。\n\n测试套件：\n将您的实现应用于以下参数集。每个测试用例由维度 $n$、初始向量 $\\mathbf{x}$ 以及一个有序的旋转列表 $\\mathcal{G}$ 指定，其中每个旋转是一个使用 0 基索引的元组 $(i,j,c,s)$。\n\n- 测试用例 1（一般情况）：\n  - $n = 5$\n  - $\\mathbf{x} = [3.0, -1.0, 2.0, 0.5, -4.0]^\\top$\n  - $\\mathcal{G} = [(0, 1, 0.8, 0.6), (2, 4, 0.6, -0.8), (3, 4, 0.7071067811865476, 0.7071067811865475)]$\n\n- 测试用例 2（边界情况：保持向量不变的单位旋转）：\n  - $n = 4$\n  - $\\mathbf{x} = [1.0, 2.0, 3.0, 4.0]^\\top$\n  - $\\mathcal{G} = [(1, 3, 1.0, 0.0)]$\n\n- 测试用例 3（边缘情况：零向量在任何正交变换下仍为零）：\n  - $n = 3$\n  - $\\mathbf{x} = [0.0, 0.0, 0.0]^\\top$\n  - $\\mathcal{G} = [(0, 2, 0.0, 1.0), (0, 1, 0.7071067811865476, -0.7071067811865475)]$\n\n- 测试用例 4（边缘情况：空的旋转序列）：\n  - $n = 5$\n  - $\\mathbf{x} = [-2.5, 0.0, 7.25, 1.5, -3.5]^\\top$\n  - $\\mathcal{G} = []$\n\n- 测试用例 5（边界情况：由 $c = 0$ 和 $s = \\pm 1$ 表示的纯 $90^\\circ$ 等效旋转，产生带符号的交换）：\n  - $n = 4$\n  - $\\mathbf{x} = [0.5, -1.5, 2.0, 3.0]^\\top$\n  - $\\mathcal{G} = [(0, 2, 0.0, 1.0), (1, 3, 0.0, -1.0)]$\n\n最终输出规格：\n- 您的程序应生成单行输出，包含用方括号括起来的逗号分隔的结果列表（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3]$）。\n- 每个 $\\text{result}_t$ 本身必须是测试用例 $t$ 的结果向量，格式化为一个列表，其中元素四舍五入到八位小数，例如 $[x_0,x_1,\\dots,x_{n-1}]$。", "solution": "该问题是有效的。这是数值线性代数领域一个适定且有科学依据的任务。所有提供的数据都是一致且足以进行求解的。\n\n该问题要求将一个吉文斯旋转序列应用于一个向量。吉文斯旋转是一种正交变换，它只影响向量的两个分量，在它们定义的平面内进行旋转。给定一个向量 $\\mathbf{x} \\in \\mathbb{R}^n$，吉文斯旋转 $G(i, j; c, s)$ 用于修改分量 $x_i$ 和 $x_j$，其中 $i$ 和 $j$ 是对应于旋转平面的索引。向量 $\\mathbf{x}$ 的所有其他分量保持不变。\n\n该变换由一个作用于子向量 $\\begin{pmatrix} x_i \\\\ x_j \\end{pmatrix}$ 的 $2 \\times 2$ 矩阵定义。参数 $c$ 和 $s$ 分别是旋转角的余弦和正弦，并且必须满足条件 $c^2 + s^2 = 1$，这确保了变换的正交性。更新后的分量，记为 $x_i'$ 和 $x_j'$，计算如下：\n$$\n\\begin{pmatrix}\nx_i' \\\\\nx_j'\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nc  s \\\\\n-s  c\n\\end{pmatrix}\n\\begin{pmatrix}\nx_i \\\\\nx_j\n\\end{pmatrix}\n$$\n这个矩阵向量乘法展开为两个标量方程：\n$$\nx_i' = c \\cdot x_i + s \\cdot x_j \\\\\nx_j' = -s \\cdot x_i + c \\cdot x_j\n$$\n问题规定，必须将一个包含 $k$ 个此类旋转的序列 $G_1, G_2, \\dots, G_k$ 应用于一个初始向量 $\\mathbf{x}$。最终向量 $\\mathbf{x}_{final}$ 是复合变换 $Q\\mathbf{x}$ 的结果，其中 $Q = G_k G_{k-1} \\dots G_1$。应用必须是顺序的：\n$$\n\\mathbf{x}^{(1)} = G_1 \\mathbf{x}^{(0)} \\\\\n\\mathbf{x}^{(2)} = G_2 \\mathbf{x}^{(1)} \\\\\n\\vdots \\\\\n\\mathbf{x}^{(k)} = G_k \\mathbf{x}^{(k-1)}\n$$\n其中 $\\mathbf{x}^{(0)}$ 是初始向量。\n\n关键约束是在不显式构造 $n \\times n$ 矩阵 $Q$ 的情况下执行此操作。这是应用吉文斯旋转的标准且高效的方法，因为它避免了构造和乘以大型稠密矩阵的存储和计算成本。该算法通过迭代给定的旋转序列来进行。对于每个旋转 $G_m(i, j; c, s)$，只更新向量的第 $i$ 个和第 $j$ 个元素。\n\n算法步骤如下：\n1. 使用提供的初始值初始化向量 $\\mathbf{x}$。\n2. 对于给定序列 $\\mathcal{G}$ 中的每个旋转 $(i, j, c, s)$：\n   a. 从向量 $\\mathbf{x}$ 中提取分量 $x_i$ 和 $x_j$ 的当前值。\n   b. 由于新值 $x_i'$ 和 $x_j'$ 的计算都依赖于 $x_i$ 和 $x_j$ 的原始值，因此必须注意在两次计算中都使用原始值。一个常见的实现方法是在覆盖其中一个原始值（例如 $x_i$）之前，将其存储在一个临时变量中。\n   c. 计算新值 $x_i' = c \\cdot x_i + s \\cdot x_j$。\n   d. 计算新值 $x_j' = -s \\cdot x_i + c \\cdot x_j$（使用原始的 $x_i$）。\n   e. 通过将其第 $i$ 个分量设置为 $x_i'$，第 $j$ 个分量设置为 $x_j'$ 来更新向量 $\\mathbf{x}$。\n3. 在序列中的所有旋转都已应用后，得到的向量 $\\mathbf{x}$ 就是最终答案。\n\n此过程将应用于所提供的每个测试用例。每个结果向量的最终数值将按照规定四舍五入到八位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Applies a sequence of Givens rotations to a vector for multiple test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (general case)\n        {\n            \"n\": 5,\n            \"x\": [3.0, -1.0, 2.0, 0.5, -4.0],\n            \"G\": [(0, 1, 0.8, 0.6), \n                  (2, 4, 0.6, -0.8), \n                  (3, 4, 0.7071067811865476, 0.7071067811865475)]\n        },\n        # Test case 2 (boundary case: identity rotation)\n        {\n            \"n\": 4,\n            \"x\": [1.0, 2.0, 3.0, 4.0],\n            \"G\": [(1, 3, 1.0, 0.0)]\n        },\n        # Test case 3 (edge case: zero vector)\n        {\n            \"n\": 3,\n            \"x\": [0.0, 0.0, 0.0],\n            \"G\": [(0, 2, 0.0, 1.0), \n                  (0, 1, 0.7071067811865476, -0.7071067811865475)]\n        },\n        # Test case 4 (edge case: empty sequence)\n        {\n            \"n\": 5,\n            \"x\": [-2.5, 0.0, 7.25, 1.5, -3.5],\n            \"G\": []\n        },\n        # Test case 5 (boundary case: 90-degree rotations)\n        {\n            \"n\": 4,\n            \"x\": [0.5, -1.5, 2.0, 3.0],\n            \"G\": [(0, 2, 0.0, 1.0), \n                  (1, 3, 0.0, -1.0)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Initialize vector from the current test case.\n        # Use numpy array for vectorized operations and floating point precision.\n        x = np.array(case[\"x\"], dtype=np.float64)\n        \n        # Apply each Givens rotation in sequence.\n        for rotation in case[\"G\"]:\n            i, j, c, s = rotation\n            \n            # Store original values of x[i] and x[j]\n            xi = x[i]\n            xj = x[j]\n            \n            # Apply the rotation.\n            # The calculation of the new x[j] must use the original xi.\n            x[i] = c * xi + s * xj\n            x[j] = -s * xi + c * xj\n            \n        # Round the final vector to 8 decimal places.\n        rounded_x = np.round(x, 8)\n        \n        # Convert -0.0 to 0.0 for canonical representation, then convert to list.\n        result_list = [0.0 if val == -0.0 else val for val in rounded_x.tolist()]\n        \n        # Append the string representation of the list to the results.\n        results.append(str(result_list))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3236383"}]}