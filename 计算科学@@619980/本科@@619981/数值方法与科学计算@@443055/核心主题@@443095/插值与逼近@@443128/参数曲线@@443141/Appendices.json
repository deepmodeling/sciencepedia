{"hands_on_practices": [{"introduction": "理解参数曲线不仅仅是描绘其几何形状，更关键的是要掌握物体随时间运动的动态过程。本练习 [@problem_id:2140263] 旨在探讨路径相交（共享一个几何点）与碰撞（在同一时刻到达该共享点）之间的本质区别。通过分析两个机器人的运动轨迹，你将运用基础代数技巧，加深对参数 $t$ 如何控制运动的理解。", "problem": "两个自主移动机器人，“Pathfinder”和“Rover”，被编程在一个大型、平坦的工厂地面上导航。它们的位置由一个笛卡尔坐标系描述，单位为米。\n\n“Pathfinder”的路径 $C_1$ 由其在内部时间 $t \\ge 0$（单位为秒）时的位置 $(x_1, y_1)$ 的参数方程描述：\n$$x_1(t) = 2t+1$$\n$$y_1(t) = t^2 - 2$$\n\n“Rover”的路径 $C_2$ 由其在内部时间 $s \\ge 0$（单位为秒）时的位置 $(x_2, y_2)$ 的参数方程描述：\n$$x_2(s) = s-1$$\n$$y_2(s) = s+1$$\n\n机器人的运动被分析为两种不同的情景：路径相交（它们的几何路径是否交叉？）和碰撞（它们是否在同一时间处于同一位置？）。如果存在时间参数 $t$ 和 $s$（不一定相等），使得它们的位置相同，则发生路径相交。只有当它们的位置在*相同*的时间参数值下相同时，才会发生碰撞，前提是它们的时钟是同步的（$t=s$）。\n\n根据您对机器人路径的分析，以下哪个陈述是正确的？\n\nA. 路径不相交。\n\nB. 路径在点 $(3+2\\sqrt{6}, 5+2\\sqrt{6})$ 处相交，如果它们的时钟同步，机器人将在此点碰撞。\n\nC. 路径在点 $(3+2\\sqrt{6}, 5+2\\sqrt{6})$ 处相交，但即使时钟同步，机器人也不会碰撞。\n\nD. 路径在非 $(3+2\\sqrt{6}, 5+2\\sqrt{6})$ 的一点相交，如果它们的时钟同步，机器人将在此另一点碰撞。\n\nE. 路径在非 $(3+2\\sqrt{6}, 5+2\\sqrt{6})$ 的一点相交，但即使时钟同步，机器人也不会在此另一点碰撞。", "solution": "给定平面上两条由参数定义的路径。“Pathfinder” 遵循路径 $C_{1}$，其位置为 $(x_{1}(t), y_{1}(t))$，其中 $x_{1}(t) = 2t + 1$ 且 $y_{1}(t) = t^{2} - 2$，对于 $t \\ge 0$。“Rover” 遵循路径 $C_{2}$，其位置为 $(x_{2}(s), y_{2}(s))$，其中 $x_{2}(s) = s - 1$ 且 $y_{2}(s) = s + 1$，对于 $s \\ge 0$。\n\n为确定几何路径是否相交，我们必须找到 $t \\ge 0$ 和 $s \\ge 0$ 使得\n$$\nx_{1}(t) = x_{2}(s), \\quad y_{1}(t) = y_{2}(s).\n$$\n令 $x$ 坐标相等，得到\n$$\n2t + 1 = s - 1 \\quad \\Rightarrow \\quad s = 2t + 2.\n$$\n令 $y$ 坐标相等，得到\n$$\nt^{2} - 2 = s + 1 \\quad \\Rightarrow \\quad s = t^{2} - 3.\n$$\n令这两个关于 $s$ 的表达式相等，得到\n$$\n2t + 2 = t^{2} - 3 \\quad \\Rightarrow \\quad t^{2} - 2t - 5 = 0.\n$$\n解这个二次方程，\n$$\nt = \\frac{2 \\pm \\sqrt{4 + 20}}{2} = \\frac{2 \\pm \\sqrt{24}}{2} = 1 \\pm \\sqrt{6}.\n$$\n由于 $t \\ge 0$，我们接受 $t = 1 + \\sqrt{6}$ 并舍弃 $t = 1 - \\sqrt{6}  0$。那么\n$$\ns = 2t + 2 = 2(1 + \\sqrt{6}) + 2 = 4 + 2\\sqrt{6} \\ge 0.\n$$\n交点可以从任一路径计算；使用 $C_{1}$，\n$$\nx = 2t + 1 = 2(1 + \\sqrt{6}) + 1 = 3 + 2\\sqrt{6}, \\quad y = t^{2} - 2 = (1 + \\sqrt{6})^{2} - 2 = 5 + 2\\sqrt{6}.\n$$\n因此路径在点 $(3 + 2\\sqrt{6}, 5 + 2\\sqrt{6})$ 处相交。\n\n为确定它们在时钟同步时是否会碰撞，我们需要相同的时间参数 $t = s$ 和相同的位置：\n$$\n2t + 1 = t - 1, \\quad t^{2} - 2 = t + 1.\n$$\n从第一个方程，\n$$\n2t + 1 = t - 1 \\quad \\Rightarrow \\quad t = -2,\n$$\n这违反了 $t \\ge 0$。因此，没有非负的 $t$ 能同时满足两个坐标等式，所以在时钟同步的情况下不会发生碰撞。\n\n因此，正确的陈述是路径在点 $(3 + 2\\sqrt{6}, 5 + 2\\sqrt{6})$ 处相交，但即使时钟同步，机器人也不会碰撞。", "answer": "$$\\boxed{C}$$", "id": "2140263"}, {"introduction": "参数方程是描述复杂运动的强大工具，例如一个点在滚动圆上描绘出的轨迹——摆线族曲线。在此练习 [@problem_id:3261316] 中，你将从“无滑滚动”这一基本物理原理出发，推导次摆线（hypotrochoid）的参数方程。接着，你将应用微分几何的知识计算该曲线在特定点的曲率，从而将运动学原理与曲线的几何特性紧密联系起来。", "problem": "一个半径为 $r$ 的圆在一个半径为 $R$ 的固定圆内部无滑动地滚动。一个追踪点附着在滚动圆的中心距离为 $d$ 的位置。设 $\\theta$（以弧度为单位）表示滚动圆中心相对于固定圆中心的极角，从正 $x$ 轴开始测量。在 $\\theta=0$ 时，滚动圆的中心位于正 $x$ 轴上，追踪点位于同一轴上更靠右的位置，因此追踪点的初始位置在 $(R-r+d,\\,0)$。仅从无滑动滚动条件（弧长相等）和曲率的定义（单位切向量对弧长的变化率大小）出发，完成以下任务：\n\n- 推导追踪点路径的参数方程 $x(\\theta)$ 和 $y(\\theta)$，适用于内滚情况（内摆线），并用 $R$、$r$、$d$ 和 $\\theta$ 表示。\n- 当 $R=7$，$r=3$，$d=1$ 时，计算追踪点路径在 $\\theta=0$ 处的曲率 $\\kappa$。\n\n将最终答案表示为精确值。不需要近似或四舍五入。角度以弧度为单位。", "solution": "该问题被验证为科学上合理、定义明确、客观且自洽。它描述了内摆线的生成，并要求计算其参数方程和在特定点上的曲率，这些是微分几何和运动学中的标准课题。所有必要的参数和初始条件均已提供。\n\n### 第一部分：参数方程的推导\n\n设固定圆的圆心位于笛卡尔坐标系的原点 $O=(0,0)$。其半径为 $R$。滚动圆的半径为 $r$，其中心记为 $C$。它在固定圆内部无滑动地滚动。\n\n滚动圆的中心 $C$ 始终与原点 $O$ 相距 $R-r$。设 $\\theta$ 是位置向量 $\\vec{OC}$ 的极角，从正 $x$ 轴开始测量。因此，中心 $C$ 的坐标由下式给出：\n$$ \\vec{r}_C(\\theta) = ((R-r)\\cos\\theta, (R-r)\\sin\\theta) $$\n\n一个追踪点 $P$ 附着在滚动圆上，距其中心 $C$ 的距离为 $d$。追踪点 $P$ 的位置向量由 $\\vec{r}_P = \\vec{OC} + \\vec{CP}$ 给出。我们需要确定向量 $\\vec{CP}$ 作为 $\\theta$ 的函数。\n\n“无滑动滚动”条件意味着在固定圆圆周上经过的弧长等于在滚动圆圆周上滚过的弧长。\n设初始接触点为 $K_0$，位于 $(R,0)$，此时 $\\theta=0$。当中心 $C$ 移动，使得 $\\vec{OC}$ 与 $x$ 轴形成角度 $\\theta$ 时，新的接触点 $K$ 位于线段 $OC$ 延伸至固定圆边缘的直线上。固定圆上 $K_0$ 和 $K$ 之间的弧长为 $s = R\\theta$。\n\n这段弧长必须等于滚动圆上的弧长。设 $\\phi$ 是滚动圆相对于其中心 $C$ 的旋转角度。这个旋转是相对于一个移动参考系来测量的。我们来分析向量 $\\vec{CP}$ 的方向。\n\n在 $\\theta=0$ 时，中心 $C$ 位于 $(R-r, 0)$。追踪点 $P$ 位于 $(R-r+d, 0)$。因此，在 $\\theta=0$ 时，向量 $\\vec{CP}$ 是 $(d, 0)$，指向正 $x$ 轴方向。\n\n随着系统的演化，线段 $OC$ 逆时针旋转了角度 $\\theta$。如果没有滚动，向量 $\\vec{CP}$ 也会旋转 $\\theta$。然而，由于滚动条件，圆还围绕其自身中心 $C$ 旋转。滚过的弧长是 $s=R\\theta$。这对应于滚动圆旋转了角度 $\\phi = \\frac{s}{r} = \\frac{R\\theta}{r}$。当中心 $C$ 逆时针移动时，滚动圆本身相对于直线 $OC$ 顺时针旋转。\n\n向量 $\\vec{CP}$ 与 $x$ 轴的初始方向角为 $0$。参考系 $OC$ 的旋转增加了 $\\theta$。滚动运动减去了 $\\phi$。因此，向量 $\\vec{CP}$ 相对于正 $x$ 轴的角度 $\\alpha$ 是：\n$$ \\alpha(\\theta) = \\theta - \\phi = \\theta - \\frac{R\\theta}{r} = \\left(1 - \\frac{R}{r}\\right)\\theta = -\\frac{R-r}{r}\\theta $$\n向量 $\\vec{CP}$ 的大小为 $d$，角度为 $\\alpha(\\theta)$。其分量为：\n$$ \\vec{CP}(\\theta) = (d\\cos(\\alpha(\\theta)), d\\sin(\\alpha(\\theta))) = \\left(d\\cos\\left(-\\frac{R-r}{r}\\theta\\right), d\\sin\\left(-\\frac{R-r}{r}\\theta\\right)\\right) $$\n使用恒等式 $\\cos(-u) = \\cos(u)$ 和 $\\sin(-u) = -\\sin(u)$，我们得到：\n$$ \\vec{CP}(\\theta) = \\left(d\\cos\\left(\\frac{R-r}{r}\\theta\\right), -d\\sin\\left(\\frac{R-r}{r}\\theta\\right)\\right) $$\n追踪点 $P$ 的位置向量是 $\\vec{r}_C$ 和 $\\vec{CP}$ 的和：\n$$ \\vec{r}_P(\\theta) = (x(\\theta), y(\\theta)) = ((R-r)\\cos\\theta + d \\cos\\left(\\frac{R-r}{r}\\theta\\right), (R-r)\\sin\\theta - d\\sin\\left(\\frac{R-r}{r}\\theta\\right)) $$\n参数方程是：\n$$ x(\\theta) = (R-r)\\cos\\theta + d \\cos\\left(\\frac{R-r}{r}\\theta\\right) $$\n$$ y(\\theta) = (R-r)\\sin\\theta - d\\sin\\left(\\frac{R-r}{r}\\theta\\right) $$\n在 $\\theta=0$ 时，$x(0) = (R-r)(1) + d(1) = R-r+d$ 且 $y(0) = (R-r)(0) - d(0) = 0$。这与初始条件 $(R-r+d, 0)$ 相符。\n\n### 第二部分：曲率计算\n\n我们给定了具体数值 $R=7$，$r=3$ 和 $d=1$。\n参数方程变为：\n$$ R-r = 7-3 = 4 $$\n$$ \\frac{R-r}{r} = \\frac{4}{3} $$\n$$ x(\\theta) = 4\\cos\\theta + \\cos\\left(\\frac{4}{3}\\theta\\right) $$\n$$ y(\\theta) = 4\\sin\\theta - \\sin\\left(\\frac{4}{3}\\theta\\right) $$\n曲率 $\\kappa$ 定义为单位切向量 $\\vec{T}$ 相对于弧长 $s$ 的变化率的大小，即 $\\kappa = \\left|\\frac{d\\vec{T}}{ds}\\right|$。\n使用链式法则，$\\frac{d\\vec{T}}{ds} = \\frac{d\\vec{T}/d\\theta}{ds/d\\theta}$。弧长元是 $ds = |\\vec{v}(\\theta)|d\\theta$，其中 $\\vec{v}(\\theta) = \\frac{d\\vec{r}_P}{d\\theta}$ 是速度向量。所以 $\\frac{ds}{d\\theta} = |\\vec{v}(\\theta)|$。\n曲率为 $\\kappa(\\theta) = \\frac{|d\\vec{T}/d\\theta|}{|\\vec{v}(\\theta)|}$。\n单位切向量是 $\\vec{T} = \\vec{v}/|\\vec{v}|$。对 $\\theta$ 微分得到 $\\frac{d\\vec{T}}{d\\theta} = \\frac{\\vec{a}|\\vec{v}|^2 - \\vec{v}(\\vec{v}\\cdot\\vec{a})}{|\\vec{v}|^3}$，其中 $\\vec{a}(\\theta)=\\frac{d\\vec{v}}{d\\theta}$ 是加速度向量。\n\n在速度 $\\vec{v}$ 和加速度 $\\vec{a}$ 正交的点（即 $\\vec{v} \\cdot \\vec{a} = 0$），表达式会简化。让我们计算在 $\\theta=0$ 处的导数。\n一阶导数（速度分量）：\n$$ x'(\\theta) = -4\\sin\\theta - \\frac{4}{3}\\sin\\left(\\frac{4}{3}\\theta\\right) $$\n$$ y'(\\theta) = 4\\cos\\theta - \\frac{4}{3}\\cos\\left(\\frac{4}{3}\\theta\\right) $$\n在 $\\theta=0$ 时：\n$$ x'(0) = -4\\sin(0) - \\frac{4}{3}\\sin(0) = 0 $$\n$$ y'(0) = 4\\cos(0) - \\frac{4}{3}\\cos(0) = 4 - \\frac{4}{3} = \\frac{8}{3} $$\n所以，在 $\\theta=0$ 时的速度向量是 $\\vec{v}(0) = (0, \\frac{8}{3})$。\n\n二阶导数（加速度分量）：\n$$ x''(\\theta) = -4\\cos\\theta - \\left(\\frac{4}{3}\\right)^2\\cos\\left(\\frac{4}{3}\\theta\\right) = -4\\cos\\theta - \\frac{16}{9}\\cos\\left(\\frac{4}{3}\\theta\\right) $$\n$$ y''(\\theta) = -4\\sin\\theta - \\frac{4}{3}\\left(-\\sin\\left(\\frac{4}{3}\\theta\\right) \\cdot \\frac{4}{3}\\right) = -4\\sin\\theta + \\frac{16}{9}\\sin\\left(\\frac{4}{3}\\theta\\right) $$\n在 $\\theta=0$ 时：\n$$ x''(0) = -4\\cos(0) - \\frac{16}{9}\\cos(0) = -4 - \\frac{16}{9} = -\\frac{36+16}{9} = -\\frac{52}{9} $$\n$$ y''(0) = -4\\sin(0) + \\frac{16}{9}\\sin(0) = 0 $$\n所以，在 $\\theta=0$ 时的加速度向量是 $\\vec{a}(0) = (-\\frac{52}{9}, 0)$。\n\n点积 $\\vec{v}(0) \\cdot \\vec{a}(0) = (0)(-\\frac{52}{9}) + (\\frac{8}{3})(0) = 0$。这两个向量是正交的。\n加速度的切向分量 $\\frac{d|\\vec{v}|}{d\\theta} = \\frac{\\vec{v}\\cdot\\vec{a}}{|\\vec{v}|}$ 在 $\\theta=0$ 时为零。\n这简化了 $\\frac{d\\vec{T}}{d\\theta}$ 的计算。\n$$ \\frac{d\\vec{T}}{d\\theta}\\bigg|_{\\theta=0} = \\frac{\\vec{a}(0)|\\vec{v}(0)|^2 - \\vec{v}(0)(0)}{|\\vec{v}(0)|^3} = \\frac{\\vec{a}(0)}{|\\vec{v}(0)|} $$\n于是曲率为：\n$$ \\kappa(0) = \\frac{|d\\vec{T}/d\\theta|_{\\theta=0}|}{|\\vec{v}(0)|} = \\frac{|\\vec{a}(0)/|\\vec{v}(0)||}{|\\vec{v}(0)|} = \\frac{|\\vec{a}(0)|}{|\\vec{v}(0)|^2} $$\n我们来计算大小：\n$$ |\\vec{v}(0)| = \\sqrt{0^2 + \\left(\\frac{8}{3}\\right)^2} = \\frac{8}{3} $$\n$$ |\\vec{a}(0)| = \\sqrt{\\left(-\\frac{52}{9}\\right)^2 + 0^2} = \\frac{52}{9} $$\n现在，我们计算曲率 $\\kappa(0)$：\n$$ \\kappa(0) = \\frac{|\\vec{a}(0)|}{|\\vec{v}(0)|^2} = \\frac{52/9}{(8/3)^2} = \\frac{52/9}{64/9} = \\frac{52}{64} $$\n为简化分数，我们找到 $52$ 和 $64$ 的最大公约数。两者都能被 $4$ 整除。\n$$ 52 = 4 \\times 13 $$\n$$ 64 = 4 \\times 16 $$\n$$ \\kappa(0) = \\frac{13}{16} $$\n追踪点路径在 $\\theta=0$ 处的曲率为 $\\frac{13}{16}$。\n\n或者，也可以使用参数曲线 $(x(\\theta), y(\\theta))$ 的标准曲率公式：\n$$ \\kappa(\\theta) = \\frac{|x'(\\theta)y''(\\theta) - y'(\\theta)x''(\\theta)|}{(x'(\\theta)^2 + y'(\\theta)^2)^{3/2}} $$\n在 $\\theta=0$ 时，我们有 $x'(0)=0$ 和 $y''(0)=0$。\n$$ \\kappa(0) = \\frac{|0 - y'(0)x''(0)|}{(0^2 + y'(0)^2)^{3/2}} = \\frac{|-y'(0)x''(0)|}{|y'(0)|^3} = \\frac{|x''(0)|}{y'(0)^2} $$\n代入我们求得的值：\n$$ |x''(0)| = \\left|-\\frac{52}{9}\\right| = \\frac{52}{9} $$\n$$ y'(0)^2 = \\left(\\frac{8}{3}\\right)^2 = \\frac{64}{9} $$\n$$ \\kappa(0) = \\frac{52/9}{64/9} = \\frac{52}{64} = \\frac{13}{16} $$\n这证实了结果。", "answer": "$$\\boxed{\\frac{13}{16}}$$", "id": "3261316"}, {"introduction": "在从计算机图形学到地理信息系统的众多实际应用中，复杂的曲线常常需要用更简单的折线来近似。本练习 [@problem_id:3261322] 要求你实现一个核心的曲线简化算法，其思想类似于 Ramer-Douglas-Peucker 算法。你将从欧几里得距离的基本定义出发，开发一个方法来减少采样曲线中的点数，同时在给定容差 $\\epsilon$ 范围内保持其基本形状。", "problem": "给定一个参数化平面曲线，由连续映射 $C:[a,b]\\to\\mathbb{R}^2$ 指定，其中 $C(t)=(x(t),y(t))$。您将对此曲线进行均匀采样，获取 $N$ 个点，形成一个有序点序列 $P_0,P_1,\\dots,P_{N-1}$，其中 $P_i=C(t_i)$，$t_i=a+i\\Delta t$ 且 $\\Delta t=(b-a)/(N-1)$。目标是，在下述约束条件下，通过算法将此采样折线简化为一个子序列 $Q_0,Q_1,\\dots,Q_{M-1}$。子序列中的每个点 $Q_j$ 都是原始点 $P_i$ 之一，且满足 $Q_0=P_0$ 和 $Q_{M-1}=P_{N-1}$，使得简化后的折线与原始点集的偏差在规定的容差 $\\,\\epsilon\\,$ 之内。\n\n从 $\\mathbb{R}^2$ 中欧几里得距离的基本定义出发，即对于点 $A=(a_x,a_y)$ 和 $B=(b_x,b_y)$，其距离为 $\\|A-B\\|_2=\\sqrt{(a_x-b_x)^2+(a_y-b_y)^2}$。将一个点 $R$ 到以 $A$ 和 $B$ 为端点的闭合线段的距离定义为 $R$ 到该线段上任意点的最小欧几里得距离。仅使用这些定义，构建一个方法，用于选择满足以下可接纳条件的采样点子序列：对于每一对连续的保留点 $Q_j=P_{i_j}$ 和 $Q_{j+1}=P_{i_{j+1}}$（其中 $i_j  i_{j+1}$），所有介于两者之间的原始点 $P_k$ ($i_j  k  i_{j+1}$) 到线段 $P_{i_j}P_{i_{j+1}}$ 的距离都必须小于等于 $\\epsilon$。", "solution": "提出的问题是，要求基于基本几何原理，开发并实现一种折线简化算法。该问题定义明确、数学上可靠且计算上可行。这是计算几何中的一个经典问题，通常由 Ramer-Douglas-Peucker (RDP) 算法解决。我们将根据指定的第一性原理来构建此方法。\n\n一个问题如果具有科学依据、是适定的（well-posed）并且是客观的，那么它就是有效的。\n- **科学依据**：该问题基于欧几里得几何和微积分的既定原理，具体涉及参数曲线、采样和距离度量。所提供的定义，如欧几里得距离和点到线段的距离，都是标准且正确的。\n- **适定性**：目标陈述清晰：找到满足特定容差标准的点子序列。每个测试用例的输入（曲线定义、采样参数、容差 $\\epsilon$）都已完全指定。问题陈述中隐含描述的 Ramer-Douglas-Peucker 算法保证对给定的折线和容差能够终止，并产生唯一的简化结果。\n- **客观性**：该问题使用精确的数学语言表述，没有歧义或主观论断。\n\n因此，该问题被视为**有效的**，因为它满足了一个可解科学问题的所有标准。\n\n该解决方案分两个主要阶段进行：首先，按要求形式化距离计算；其次，构建递归简化算法。\n\n### 1. 点到线段的距离\n\n问题要求计算一个点 $R$到以 $A$ 和 $B$ 为端点的闭合线段的最小欧几里得距离。设这些点由从原点出发的向量表示，记为 $\\vec{r}$、$\\vec{a}$ 和 $\\vec{b}$。\n\n通过 $A$ 和 $B$ 的无限直线上的一点可以参数化为 $L(u) = \\vec{a} + u(\\vec{b} - \\vec{a})$，其中标量参数 $u \\in \\mathbb{R}$。这条线上离 $R$ 最近的点是 $R$ 在该线上的正交投影。这发生在从投影点到 $R$ 的向量与线的方向向量 $\\vec{v} = \\vec{b} - \\vec{a}$ 正交时。\n\n$$(\\vec{r} - L(u)) \\cdot (\\vec{b} - \\vec{a}) = 0$$\n$$(\\vec{r} - (\\vec{a} + u(\\vec{b} - \\vec{a}))) \\cdot (\\vec{b} - \\vec{a}) = 0$$\n$$(\\vec{r} - \\vec{a}) \\cdot (\\vec{b} - \\vec{a}) - u(\\vec{b} - \\vec{a}) \\cdot (\\vec{b} - \\vec{a}) = 0$$\n\n解出 $u$ 可得：\n$$u = \\frac{(\\vec{r} - \\vec{a}) \\cdot (\\vec{b} - \\vec{a})}{\\|\\vec{b} - \\vec{a}\\|^2}$$\n\n此参数 $u$ 决定了无限直线上最近点的位置。对于闭合线段，参数必须限制在 $u \\in [0, 1]$。这导致三种情况：\n\n1.  如果 $u \\in [0, 1]$，投影点落在线段上。最近点为 $P_{proj} = \\vec{a} + u(\\vec{b} - \\vec{a})$，距离为 $\\|\\vec{r} - P_{proj}\\|$。\n2.  如果 $u  0$，线段上最近的点是端点 $A$。距离为 $\\|\\vec{r} - \\vec{a}\\|$。\n3.  如果 $u  1$，线段上最近的点是端点 $B$。距离为 $\\|\\vec{r} - \\vec{b}\\|$。\n\n当 $A$ 和 $B$ 重合时，即 $\\|\\vec{b} - \\vec{a}\\|^2 = 0$，会出现一个特殊情况。在这种情况下，线段是一个单点，距离就是 $\\|\\vec{r} - \\vec{a}\\|$。\n\n### 2. 递归偏差细化算法\n\n问题要求一种遵循“递归偏差细化”思想的方法，这是对 Ramer-Douglas-Peucker 算法的一种描述性名称。给定一个点序列 $P_0, \\dots, P_{N-1}$，目标是找到一个以 $P_0$ 开始、以 $P_{N-1}$ 结束的简化子序列。\n\n该算法对由起始索引 $i_{start}$ 和结束索引 $i_{end}$ 定义的折线段进行操作。初始时，这是从索引 $0$ 到 $N-1$ 的完整折线。\n\n1.  考虑连接端点 $P_{i_{start}}$ 和 $P_{i_{end}}$ 的线段。\n2.  对于每个中间点 $P_k$（其中 $i_{start}  k  i_{end}$），使用上述推导的方法计算其到线段 $(P_{i_{start}}, P_{i_{end}})$ 的垂直距离。\n3.  找到与线段距离最大（$d_{max}$）的点 $P_{i_{max}}$。\n4.  将 $d_{max}$ 与指定的容差 $\\epsilon$ 进行比较：\n    a. 如果 $d_{max} \\le \\epsilon$，则所有中间点都被认为与该线段足够接近。这部分折线的简化结果就是两个端点 $P_{i_{start}}$ 和 $P_{i_{end}}$。\n    b. 如果 $d_{max}  \\epsilon$，则点 $P_{i_{max}}$ 是一个重要特征，必须保留。然后将简化过程递归地应用于两个子折线：一个从 $P_{i_{start}}$ 到 $P_{i_{max}}$，另一个从 $P_{i_{max}}$ 到 $P_{i_{end}}$。\n\n所有保留点（初始端点加上所有被发现超出容差的点，如 $P_{i_{max}}$）的集合构成了最终的简化折线。由于每个递归步骤都作用于一个严格更小的子问题，并且点的数量是有限的，因此该过程保证会终止。\n\n在实现上，基于堆栈的迭代方法在功能上等同于递归，并且可以避免潜在的深度递归限制。\n\n### 算法实现\n\n对于每个测试用例，整个程序将按以下步骤进行：\n1.  **采样**：通过在 $[a, b]$ 中创建 $t_i$ 值的均匀网格并计算 $(x(t_i), y(t_i))$，生成曲线 $C(t)$ 的 $N$ 个点。\n2.  **简化**：\n    a. 初始化一个要保留的索引集合 `kept_indices`，初始值为 $\\{0, N-1\\}$。\n    b. 将初始索引对 `(0, N-1)` 推入堆栈。\n    c. 当堆栈不为空时：\n        i. 弹出一个索引对 `(start, end)`。\n        ii. 找到 `start` 和 `end` 之间与从 `points[start]` 到 `points[end]` 的线段距离最大的点的索引 `max_dist_idx` 和距离值 `d_max`。\n        iii. 如果存在最远点（即 `start + 1  end`）且 `d_max > epsilon`，则将 `max_dist_idx` 添加到 `kept_indices` 中，并将新的索引对 `(start, max_dist_idx)` 和 `(max_dist_idx, end)` 推入堆栈。\n3.  **输出**：将最终的集合 `kept_indices` 转换为一个排序列表，并按要求格式化。\n\n这种结构化方法从第一性原理出发，正确地实现了指定的要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef point_segment_distance(point, start, end):\n    \"\"\"\n    Calculate the Euclidean distance from a point to a line segment.\n\n    Args:\n        point (np.ndarray): The point, shape (2,).\n        start (np.ndarray): The start point of the segment, shape (2,).\n        end (np.ndarray): The end point of the segment, shape (2,).\n\n    Returns:\n        float: The distance from the point to the segment.\n    \"\"\"\n    # Handle the case where the segment is a single point\n    if np.array_equal(start, end):\n        return np.linalg.norm(point - start)\n\n    line_vec = end - start\n    pnt_vec = point - start\n    \n    line_len_sq = np.dot(line_vec, line_vec)\n    \n    # Project point onto the line containing the segment.\n    # The parameter t is the projection factor.\n    t = np.dot(pnt_vec, line_vec) / line_len_sq\n    \n    if t  0.0:\n        # Projection is outside the segment, closer to the start point.\n        return np.linalg.norm(point - start)\n    elif t > 1.0:\n        # Projection is outside the segment, closer to the end point.\n        return np.linalg.norm(point - end)\n    else:\n        # Projection is on the segment.\n        projection = start + t * line_vec\n        return np.linalg.norm(point - projection)\n\ndef simplify_polyline(points, epsilon):\n    \"\"\"\n    Simplify a polyline using the Ramer-Douglas-Peucker algorithm.\n\n    Args:\n        points (np.ndarray): An array of points, shape (N, 2).\n        epsilon (float): The tolerance for simplification.\n\n    Returns:\n        list: A sorted list of indices of the points to keep.\n    \"\"\"\n    n_points = len(points)\n    if n_points  2:\n        return list(range(n_points))\n\n    # Use a stack for an iterative implementation of the algorithm\n    stack = [(0, n_points - 1)]\n    kept_indices = {0, n_points - 1}\n\n    while stack:\n        start_idx, end_idx = stack.pop()\n\n        # Find the point with the maximum distance\n        d_max = 0.0\n        max_dist_idx = -1\n\n        for i in range(start_idx + 1, end_idx):\n            d = point_segment_distance(points[i], points[start_idx], points[end_idx])\n            if d > d_max:\n                d_max = d\n                max_dist_idx = i\n\n        # If max distance is greater than epsilon, recursively simplify\n        if max_dist_idx != -1 and d_max > epsilon:\n            kept_indices.add(max_dist_idx)\n            # Push the two new sub-segments onto the stack\n            if max_dist_idx - start_idx > 1:\n                stack.append((start_idx, max_dist_idx))\n            if end_idx - max_dist_idx > 1:\n                stack.append((max_dist_idx, end_idx))\n                \n    return sorted(list(kept_indices))\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"x_func\": lambda t: np.cos(t),\n            \"y_func\": lambda t: np.sin(t),\n            \"t_range\": (0, np.pi / 2),\n            \"N\": 101,\n            \"epsilon\": 0.01\n        },\n        {\n            \"x_func\": lambda t: np.piecewise(t, [t = 0.5, t > 0.5], [lambda v: v, 0.5]),\n            \"y_func\": lambda t: np.piecewise(t, [t = 0.5, t > 0.5], [0, lambda v: 2 * (v - 0.5)]),\n            \"t_range\": (0, 1),\n            \"N\": 51,\n            \"epsilon\": 1e-12\n        },\n        {\n            \"x_func\": lambda t: t,\n            \"y_func\": lambda t: np.sin(3 * t),\n            \"t_range\": (0, 2 * np.pi),\n            \"N\": 401,\n            \"epsilon\": 100\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        t_start, t_end = case[\"t_range\"]\n        N = case[\"N\"]\n        epsilon = case[\"epsilon\"]\n        \n        # 1. Sample the curve\n        t_values = np.linspace(t_start, t_end, N)\n        x_values = case[\"x_func\"](t_values)\n        y_values = case[\"y_func\"](t_values)\n        points = np.vstack((x_values, y_values)).T\n\n        # 2. Compute the simplified subsequence\n        retained_indices = simplify_polyline(points, epsilon)\n        all_results.append(retained_indices)\n\n    # 3. Format the final output string\n    inner_results_str = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output = f\"[{','.join(inner_results_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3261322"}]}