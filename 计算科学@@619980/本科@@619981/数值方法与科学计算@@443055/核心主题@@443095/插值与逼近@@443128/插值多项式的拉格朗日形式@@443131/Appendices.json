{"hands_on_practices": [{"introduction": "这项实践是一个绝佳的起点，它要求你从基本原理出发，实现拉格朗日插值多项式。假设你有一个能生成数据的“黑匣子”，你的任务是通过构造一个穿过所有数据点的多项式来揭示其背后的函数。这个练习不仅检验你对公式的理解，还能锻炼你将数学理论转化为可实际运行的计算机程序的能力 [@problem_id:3246629]。", "problem": "你获得了一个“黑盒”的访问权限，对于一组不同的输入点，该黑盒返回与一个低阶单变量多项式一致的输出。你的任务是通过推导和实现插值多项式，来反向工程出隐藏的多项式在指定查询点上的行为。此过程需基于插值的基本定义，而不使用问题描述中任何现成的公式。\n\n从定义多项式插值的基础出发：一个阶数至多为 $n$ 的多项式 $p(x)$，它在不同的节点 $x_j$ 处与数据值 $y_j$ 一致（即，对于所有索引 $j$，都有 $p(x_j) = y_j$），该多项式由其在这些节点上与黑盒输出相匹配的条件唯一确定。目标是从第一性原理构建 $p(x)$，并在指定的查询点上评估 $p(x)$。\n\n要求：\n- 从插值的定义出发，推导在不同节点 $x_j$ 处匹配给定点对 $(x_j, y_j)$ 的插值多项式形式。\n- 使用你推导出的形式，实现一个在给定查询点 $x$ 处评估 $p(x)$ 的数值稳健的方法。你的实现必须能处理查询点与某个节点 $x_j$ 完全重合的情况，此时应返回对应的 $y_j$ 而不执行未定义的操作。\n- 假设使用浮点表示的实数算术。不涉及物理单位。不涉及角度。不涉及百分比。\n\n测试套件：\n对于每个案例，你将获得黑盒返回的节点和输出。保证每个案例都来自一个多项式，其阶数最多比节点数少一。对于每个案例，计算给定查询点处的插值，并报告该单一数值结果。\n\n- 案例 $1$（边界情况：常数行为）：\n  - 节点：$x = [\\,2\\,]$\n  - 输出：$y = [\\,5\\,]$\n  - 查询点：$x^\\ast = 10$\n\n- 案例 $2$（边界情况：查询点与节点重合）：\n  - 节点：$x = [\\,-1,\\,4\\,]$\n  - 输出：$y = [\\,-5,\\,5\\,]$\n  - 查询点：$x^\\ast = -1$\n\n- 案例 $3$（理想情况：二次多项式）：\n  - 节点：$x = [\\,0,\\,1,\\,2\\,]$\n  - 输出：$y = [\\,1,\\,1,\\,3\\,]$\n  - 查询点：$x^\\ast = 3$\n\n- 案例 $4$（一般情况：三次多项式）：\n  - 节点：$x = [\\,-1,\\,0,\\,1,\\,2\\,]$\n  - 输出：$y = [\\,-3,\\,1,\\,1,\\,3\\,]$\n  - 查询点：$x^\\ast = 3$\n\n- 案例 $5$（边缘情况：用于数值敏感性测试的密集节点）：\n  - 节点：$x = [\\,0,\\,0.1,\\,0.2\\,]$\n  - 输出：$y = [\\,1,\\,1.23,\\,1.52\\,]$\n  - 查询点：$x^\\ast = 0.15$\n\n- 案例 $6$（一般情况：含非整系数的三次多项式）：\n  - 节点：$x = [\\,-2,\\,1,\\,2,\\,3\\,]$\n  - 输出：$y = [\\,0,\\,1.5,\\,4,\\,12.5\\,]$\n  - 查询点：$x^\\ast = 0$\n\n最终输出格式：\n你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，每个条目是按给定顺序对应案例查询点的插值，例如 $[\\,\\text{result}_1,\\,\\text{result}_2,\\,\\dots\\,]$。每个数值答案必须是浮点数。", "solution": "问题要求从第一性原理推导插值多项式，并实现它以找到隐藏多项式在指定查询点的值。\n\n多项式插值的基本原理指出，对于给定的 $n+1$ 个不同的数据点 $(x_0, y_0), (x_1, y_1), \\dots, (x_n, y_n)$，存在一个唯一的阶数至多为 $n$ 的多项式 $p(x)$，使得对于所有的 $j \\in \\{0, 1, \\dots, n\\}$ 都有 $p(x_j) = y_j$。我们的任务是构建这个多项式 $p(x)$。\n\n一种构造性的方法是将 $p(x)$ 表示为 $n+1$ 个基多项式 $L_j(x)$ 的线性组合，其中每个 $L_j(x)$ 是一个阶数为 $n$ 的多项式。我们可以将 $p(x)$ 写成：\n$$\np(x) = \\sum_{j=0}^{n} c_j L_j(x)\n$$\n为了简化求系数 $c_j$ 的问题，我们可以巧妙地选择基多项式 $L_j(x)$。我们定义 $L_j(x)$ 具有“筛选”特性，即它在节点 $x_j$ 处等于 $1$，而在所有其他 $k \\neq j$ 的节点 $x_k$ 处等于 $0$。这个性质可以用克罗内克 δ 符号 (Kronecker delta) $\\delta_{jk}$ 来正式表示：\n$$\nL_j(x_k) = \\delta_{jk} = \\begin{cases} 1  & \\text{若 } j=k \\\\ 0  & \\text{若 } j \\neq k \\end{cases}\n$$\n如果我们能构造出这样的基多项式，让我们来考察 $p(x)$ 在节点 $x_k$ 处求值时的形式：\n$$\np(x_k) = \\sum_{j=0}^{n} c_j L_j(x_k) = c_0 L_0(x_k) + \\dots + c_k L_k(x_k) + \\dots + c_n L_n(x_k)\n$$\n应用筛选特性，和式中除了 $j=k$ 的项（此时 $L_k(x_k) = 1$）外，所有其他项都变为零。和式简化为：\n$$\np(x_k) = c_k \\cdot 1 = c_k\n$$\n由于我们要求 $p(x_k) = y_k$，这意味着系数 $c_k$ 必须是给定的数据值 $y_k$。因此，插值多项式可以表示为：\n$$\np(x) = \\sum_{j=0}^{n} y_j L_j(x)\n$$\n剩下的任务是构造满足筛选特性的基多项式 $L_j(x)$。为了使 $L_j(x)$ 在每个 $k \\neq j$ 的节点 $x_k$ 处为零，它必须包含所有 $k \\neq j$ 的因子 $(x - x_k)$。我们可以将 $L_j(x)$ 写成一个乘积形式：\n$$\nL_j(x) = C_j \\prod_{k=0, k \\neq j}^{n} (x - x_k)\n$$\n这个表达式是一个阶数为 $n$ 的多项式。常数 $C_j$ 是一个归一化因子，由条件 $L_j(x_j) = 1$ 确定。将 $x = x_j$ 代入表达式中：\n$$\n1 = L_j(x_j) = C_j \\prod_{k=0, k \\neq j}^{n} (x_j - x_k)\n$$\n由于所有节点 $x_j$ 都是不同的，分母中的乘积项不为零。我们可以解出 $C_j$：\n$$\nC_j = \\frac{1}{\\prod_{k=0, k \\neq j}^{n} (x_j - x_k)}\n$$\n将这个常数代回 $L_j(x)$ 的表达式，就得到了拉格朗日基多项式的显式公式：\n$$\nL_j(x) = \\frac{\\prod_{k=0, k \\neq j}^{n} (x - x_k)}{\\prod_{k=0, k \\neq j}^{n} (x_j - x_k)} = \\prod_{k=0, k \\neq j}^{n} \\frac{x - x_k}{x_j - x_k}\n$$\n结合这些结果，我们从第一性原理推导出了拉格朗日形式的插值多项式：\n$$\np(x) = \\sum_{j=0}^{n} y_j \\left( \\prod_{k=0, k \\neq j}^{n} \\frac{x - x_k}{x_j - x_k} \\right)\n$$\n在实现时，在查询点 $x^\\ast$ 处评估 $p(x)$ 首先需要检查 $x^\\ast$ 是否在数值上接近任何一个节点 $x_j$。如果是，插值就是 $y_j$。这避免了在 $L_j(x)$ 的分母中除以一个接近零的数，并且与定义 $p(x_j) = y_j$ 一致。如果 $x^\\ast$ 不是节点，则通过实现上面推导的乘积求和公式来计算该值。对于和式中的每一项 $j$，计算相应的基多项式 $L_j(x^\\ast)$（作为因子的乘积），然后乘以 $y_j$ 并加到总和中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the polynomial interpolation problem for a suite of test cases.\n    \"\"\"\n\n    def lagrange_interpolate(x_nodes: np.ndarray, y_values: np.ndarray, x_query: float) -> float:\n        \"\"\"\n        Derives and evaluates the interpolating polynomial at a query point x_query\n        using the Lagrange formula, based on a given set of data points (nodes).\n\n        The method is derived from first principles by constructing a basis of\n        polynomials L_j(x) such that L_j(x_k) is 1 if j=k and 0 otherwise.\n        The full polynomial is then p(x) = sum(y_j * L_j(x)).\n\n        Args:\n            x_nodes: A numpy array of x-coordinates for the data points (nodes).\n            y_values: A numpy array of y-coordinates for the data points.\n            x_query: The point at which to evaluate the interpolating polynomial.\n\n        Returns:\n            The interpolated value p(x_query).\n        \"\"\"\n        num_nodes = len(x_nodes)\n        if num_nodes != len(y_values):\n            raise ValueError(\"Input arrays for nodes and values must have the same length.\")\n\n        # Requirement: Handle case where query point coincides with a node.\n        # This is critical for correctness and numerical stability, preventing\n        # potential division by zero in the Lagrange basis polynomial formula.\n        # np.isclose is used for robust floating-point comparison.\n        for j in range(num_nodes):\n            if np.isclose(x_query, x_nodes[j]):\n                return y_values[j]\n\n        # Implement the Lagrange interpolation formula: p(x) = sum_{j=0}^{n} y_j * L_j(x)\n        interpolated_value = 0.0\n        for j in range(num_nodes):\n            # Calculate the j-th Lagrange basis polynomial, L_j(x) = product_{k=0, k!=j}^{n} (x-x_k)/(x_j-x_k)\n            lagrange_basis_j = 1.0\n            for k in range(num_nodes):\n                if j != k:\n                    # This check is technically redundant due to the outer loop,\n                    # but it makes the logic explicit. The denominator x_nodes[j] - x_nodes[k]\n                    # is guaranteed to be non-zero because all nodes are distinct.\n                    lagrange_basis_j *= (x_query - x_nodes[k]) / (x_nodes[j] - x_nodes[k])\n            \n            # Add the contribution of the j-th term to the total sum\n            interpolated_value += y_values[j] * lagrange_basis_j\n            \n        return interpolated_value\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (boundary: constant behavior)\n        {'nodes': np.array([2.0]), 'outputs': np.array([5.0]), 'query': 10.0},\n        # Case 2 (boundary: query equals a node)\n        {'nodes': np.array([-1.0, 4.0]), 'outputs': np.array([-5.0, 5.0]), 'query': -1.0},\n        # Case 3 (happy path: quadratic)\n        {'nodes': np.array([0.0, 1.0, 2.0]), 'outputs': np.array([1.0, 1.0, 3.0]), 'query': 3.0},\n        # Case 4 (general: cubic)\n        {'nodes': np.array([-1.0, 0.0, 1.0, 2.0]), 'outputs': np.array([-3.0, 1.0, 1.0, 3.0]), 'query': 3.0},\n        # Case 5 (edge: closely spaced nodes for numerical sensitivity)\n        {'nodes': np.array([0.0, 0.1, 0.2]), 'outputs': np.array([1.0, 1.23, 1.52]), 'query': 0.15},\n        # Case 6 (general: cubic with non-integer coefficients)\n        {'nodes': np.array([-2.0, 1.0, 2.0, 3.0]), 'outputs': np.array([0.0, 1.5, 4.0, 12.5]), 'query': 0.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = lagrange_interpolate(case['nodes'], case['outputs'], case['query'])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3246629"}, {"introduction": "掌握了插值多项式的构造之后，我们现在转向其最根本的性质之一：唯一性。这个问题呈现了一个看似复杂的、涉及拉格朗日基函数的求和式。然而，通过运用唯一性的核心原则，你会发现它能被简化为一个惊人地优雅的结果，从而证明插值过程能够完美地再现任何低于特定次数的多项式 [@problem_id:3246595]。", "problem": "设 $n$ 是一个正整数，且 $x_0, x_1, \\dots, x_n$ 是 $n+1$ 个互不相同的实数节点。定义拉格朗日基多项式 $L_j(x)$ (对于 $j=0,1,\\dots,n$) 为\n$$\nL_j(x) \\;=\\; \\prod_{\\substack{m=0 \\\\ m \\ne j}}^{n} \\frac{x - x_m}{x_j - x_m}.\n$$\n对于一个满足 $0 \\le k \\le n$ 的固定整数 $k$，考虑多项式\n$$\nQ(x) \\;=\\; \\sum_{j=0}^{n} x_j^{k}\\, L_j(x).\n$$\n仅使用上述定义和多项式的基本性质，确定 $Q(x)$ 的闭合形式，将其表示为关于 $x$ 和 $k$ 的单个解析表达式。请将您的最终结果以单个表达式的形式给出，而不是一个方程，并且不包含任何单位。", "solution": "首先验证问题，以确保其是适定的、有科学依据且一致的。\n\n**步骤1：提取已知条件**\n- $n$ 是一个正整数。\n- $x_0, x_1, \\dots, x_n$ 是 $n+1$ 个互不相同的实数节点。\n- 拉格朗日基多项式定义为：\n$$L_j(x) = \\prod_{\\substack{m=0 \\\\ m \\ne j}}^{n} \\frac{x - x_m}{x_j - x_m} \\quad \\text{for } j=0,1,\\dots,n.$$\n- $k$ 是一个满足 $0 \\le k \\le n$ 的固定整数。\n- 所讨论的多项式为：\n$$Q(x) = \\sum_{j=0}^{n} x_j^{k}\\, L_j(x).$$\n目标是求出 $Q(x)$ 的闭合形式表达式。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题是数值分析中的一个标准练习，具体涉及多项式插值理论。\n- **科学/事实合理性**：该问题在数学上是合理的。拉格朗日基多项式和多项式 $Q(x)$ 的定义是标准且正确的。节点 $x_j$ 互不相同的条件至关重要，并且陈述正确，确保了 $L_j(x)$ 中的分母不为零。\n- **适定性**：该问题是适定的。它要求确定一个特定的多项式。多项式插值的唯一性表明存在唯一解。\n- **客观性**：该问题以精确、客观的数学语言陈述。\n- **完整性**：所有必要的信息都已提供。对 $n$ 和 $k$ 的约束是明确的。\n该问题在验证标准中列出的任何类别中都没有缺陷。\n\n**步骤3：结论与行动**\n该问题是**有效的**。将推导解答。\n\n**解答推导**\n多项式 $Q(x)$ 是由拉格朗日基多项式 $L_j(x)$ 的线性组合构成的。根据定义，对于一组给定的数据点 $(x_0, y_0), (x_1, y_1), \\dots, (x_n, y_n)$（其中 $x_j$ 互不相同），次数最多为 $n$ 的唯一插值多项式由下式给出：\n$$P(x) = \\sum_{j=0}^{n} y_j L_j(x).$$\n该多项式具有性质 $P(x_i) = y_i$，对于所有的 $i = 0, 1, \\dots, n$。\n\n所讨论的多项式是\n$$Q(x) = \\sum_{j=0}^{n} x_j^{k}\\, L_j(x).$$\n通过将其与拉格朗日插值多项式的一般形式进行比较，我们可以确定 $y_j = x_j^k$。因此，$Q(x)$ 是次数最多为 $n$ 的唯一多项式，它对数据点 $(x_j, x_j^k)$（对于 $j = 0, 1, \\dots, n$）进行插值。\n\n为了确定 $Q(x)$ 的具体形式，我们可以在每个节点 $x_i$（其中 $i \\in \\{0, 1, \\dots, n\\}$）处对其求值。拉格朗日基多项式的基本性质是\n$$L_j(x_i) = \\delta_{ji} = \\begin{cases} 1  & \\text{if } i=j \\\\ 0  & \\text{if } i \\ne j \\end{cases}$$\n其中 $\\delta_{ji}$ 是克罗内克δ。\n\n让我们在一个任意节点 $x_i$ 处对 $Q(x)$ 求值：\n$$Q(x_i) = \\sum_{j=0}^{n} x_j^{k}\\, L_j(x_i).$$\n由于克罗内克δ的性质，求和中的所有项都消失了，除了 $j=i$ 的那一项。\n$$Q(x_i) = x_0^k L_0(x_i) + \\dots + x_i^k L_i(x_i) + \\dots + x_n^k L_n(x_i) = 0 + \\dots + x_i^k (1) + \\dots + 0 = x_i^k.$$\n这表明 $Q(x)$ 在所有 $n+1$ 个互不相同的节点 $x_0, x_1, \\dots, x_n$ 上满足条件 $Q(x_i) = x_i^k$。\n\n现在，考虑简单多项式 $P(x) = x^k$。\n问题陈述 $k$ 是一个满足 $0 \\le k \\le n$ 的整数。这意味着多项式 $P(x)$ 的次数是 $k$，它小于或等于 $n$。\n让我们在节点 $x_i$ 处对这个多项式 $P(x)$ 求值：\n$$P(x_i) = x_i^k.$$\n我们现在有两个多项式，$Q(x)$ 和 $P(x) = x^k$。\n1. $Q(x)$ 的次数最多为 $n$，因为它是基多项式 $L_j(x)$ 的线性组合，而每个 $L_j(x)$ 的次数都是 $n$。\n2. $P(x) = x^k$ 的次数是 $k$，并且由于 $k \\le n$，其次数也最多为 $n$。\n3. 这两个多项式在 $n+1$ 个不同的点上取值相同：$Q(x_i) = P(x_i) = x_i^k$ 对于 $i=0, 1, \\dots, n$。\n\n我们定义一个差多项式 $D(x) = Q(x) - P(x) = Q(x) - x^k$。\n$D(x)$ 的次数最多为 $n$，因为它是两个次数最多为 $n$ 的多项式之差。\n我们知道 $D(x_i) = Q(x_i) - P(x_i) = x_i^k - x_i^k = 0$ 对于每个 $i \\in \\{0, 1, \\dots, n\\}$。\n这意味着多项式 $D(x)$ 有 $n+1$ 个不同的根，即 $x_0, x_1, \\dots, x_n$。\n根据代数基本定理，一个次数最多为 $n$ 的非零多项式最多只能有 $n$ 个不同的根。由于 $D(x)$ 有 $n+1$ 个不同的根，它必须是零多项式，即对于所有 $x$，都有 $D(x) = 0$。\n\n因此，$Q(x) - x^k = 0$，这意味着 $Q(x) = x^k$。\n$Q(x)$ 多项式的闭合形式表达式就是 $x^k$。条件 $0 \\le k \\le n$ 对于得出这个结论至关重要。", "answer": "$$ \\boxed{x^{k}} $$", "id": "3246595"}, {"introduction": "理论上，更高次数的多项式似乎能提供更好的拟合，但在实践中总是如此吗？本练习将挑战这一假设，让你尝试对一个带有不连续点的函数进行插值——这在信号处理和物理学中是常见情景。通过将单个高次全局多项式与更简单的局部（分段）近似方法进行比较，你将揭示拉格朗日插值的实际局限性（如吉布斯现象），并理解在数值分析中为特定问题选择正确工具的至关重要性 [@problem_id:3246671]。", "problem": "您需要编写一个完整的、可运行的程序，用于在区间 $[-1,1]$ 上，对不连续函数 $f(x) = \\mathrm{sign}(x)$，比较拉格朗日意义下的全局多项式插值与局部逐段多项式逼近。请从数值方法和科学计算中的以下基本概念开始：\n- 插值的定义：给定区间 $[-1,1]$ 中的不同节点 $\\{x_i\\}_{i=0}^{n-1}$ 和数据 $\\{y_i\\}_{i=0}^{n-1}$，插值函数是一个函数 $p(x)$，满足对所有 $i$ 都有 $p(x_i) = y_i$。当 $p(x)$ 是一个次数至多为 $n-1$ 的多项式时，这就定义了全局多项式插值。对于 $n$ 个不同的数据点，存在且唯一一个次数至多为 $n-1$ 的多项式与之匹配，这是数值分析中的一个基本事实。\n- 局部逐段多项式逼近的概念：使用节点将 $[-1,1]$ 划分为子区间。在每个子区间上，定义一个仅依赖于该子区间局部数据的逼近函数，例如逐段常数函数（每个子区间上为 0次）或逐段线性函数（每个子区间上为 1次）。\n- 用于误差测量的范数：对于在 $[-1,1]$ 上逼近 $f(x)$ 的函数 $g(x)$，其在离散网格 $\\{x_j\\}$ 上的上确界范数误差为 $\\max_j |g(x_j) - f(x_j)|$，该值逼近连续的 $L^\\infty$ 误差。\n\n您的程序必须实现：\n1. 一个全局多项式插值函数 $P_n(x)$，对于给定的节点 $\\{x_i\\}$ 和值 $y_i = f(x_i)$，该函数在 $[-1,1]$ 上用一个单一多项式同时对所有点 $\\{(x_i,y_i)\\}$ 进行插值。使用上述插值的定义属性来构造 $P_n(x)$。\n2. 一个局部逐段线性逼近函数 $L_n(x)$，通过在每个子区间 $[x_i, x_{i+1}]$ 上进行线性插值来构造，并约定如果 $x$ 等于一个节点 $x_i$，则 $L_n(x) = y_i$。\n3. 一个局部逐段常数逼近函数 $C_n(x)$，其在每个子区间上的定义为：将最近节点的采样值赋给 $x$。即，对于位于由连续节点中点确定的单元格中的 $x$，$C_n(x)$ 等于 $y_k$，其中 $x_k$ 是距离 $x$ 最近的节点。\n\n函数 $f(x)$ 必须实现为：当 $x  0$ 时 $f(x) = -1$，当 $x = 0$ 时 $f(x) = 0$，当 $x > 0$ 时 $f(x) = 1$。您的程序必须在 $[-1,1]$ 上的一个包含 $N=2001$ 个点的固定均匀网格上评估每个逼近函数，并计算离散上确界范数误差\n$$\nE_\\infty(P_n) = \\max_{j} \\left| P_n(x_j) - f(x_j) \\right|,\\quad\nE_\\infty(L_n) = \\max_{j} \\left| L_n(x_j) - f(x_j) \\right|,\\quad\nE_\\infty(C_n) = \\max_{j} \\left| C_n(x_j) - f(x_j) \\right|.\n$$\n\n您必须根据以下规则生成节点：\n- 等距节点：对于给定的整数 $n \\ge 2$，通过 $x_i = -1 + \\frac{2i}{n-1}$ 定义 $\\{x_i\\}_{i=0}^{n-1}$。\n- 第一类切比雪夫节点：对于给定的整数 $n \\ge 2$，通过 $x_i = \\cos\\left( \\frac{2i+1}{2n} \\pi \\right)$ 定义 $\\{x_i\\}_{i=0}^{n-1}$，所有角度均以弧度为单位。\n\n测试套件：\n使用 $N = 2001$ 的均匀评估网格，并为以下每个参数集计算三个上确界范数误差：\n- 情况 $\\mathsf{A}$ (理想情况)：等距节点， $n = 9$。\n- 情况 $\\mathsf{B}$ (备用节点分布)：切比雪夫节点， $n = 9$ (角度以弧度为单位)。\n- 情况 $\\mathsf{C}$ (小样本边界条件)：等距节点， $n = 3$。\n- 情况 $\\mathsf{D}$ (不连续点与节点不重合的边界情况)：等距节点， $n = 10$。\n- 情况 $\\mathsf{E}$ (切比雪夫节点下更大的样本量)：切比雪夫节点， $n = 25$ (角度以弧度为单位)。\n\n对于每种情况，您的程序必须按此确切顺序输出三个浮点误差 $E_\\infty(P_n)$、$E_\\infty(L_n)$ 和 $E_\\infty(C_n)$。将所有情况的结果汇总到单行输出中，该行包含一个由 15 个值连接而成的列表，以逗号分隔并用方括号括起来。每个浮点数必须四舍五入到小数点后恰好 8 位。\n\n最终输出格式示例（仅为说明，非实际值）：\n$$\n[\\text{caseA}_P,\\text{caseA}_L,\\text{caseA}_C,\\text{caseB}_P,\\ldots,\\text{caseE}_C]\n$$\n其中每个条目都是一个格式化为小数点后八位的浮点数。不得打印任何其他文本。", "solution": "该问题要求在区间 $[-1, 1]$ 上，针对不连续的符号函数 $f(x) = \\mathrm{sign}(x)$，比较三种数值逼近方案。这些方案是全局多项式插值、逐段线性插值和逐段常数逼近。比较基于在精细的均匀网格上评估的离散上确界范数误差。\n\n待逼近的函数定义为：\n$$\nf(x) =\n\\begin{cases}\n-1   \\text{if } x  0 \\\\\n0    \\text{if } x = 0 \\\\\n1    \\text{if } x > 0\n\\end{cases}\n$$\n该函数在 $x=0$ 处有一个跳跃间断点，这对依赖于光滑性的逼近方法，特别是全局多项式插值，构成了重大挑战。\n\n逼近函数 $g(x)$ 的误差在一个包含 $N=2001$ 个点的均匀评估网格 $\\{z_j\\}_{j=0}^{N-1}$（位于 $[-1, 1]$ 上）上进行测量。度量标准是离散上确界范数 $E_\\infty$，定义为：\n$$\nE_\\infty(g) = \\max_{0 \\le j  N} |g(z_j) - f(z_j)|\n$$\n\n这些逼近方案是基于一组 $n$ 个不同的节点 $\\{x_i\\}_{i=0}^{n-1}$ 以及相应的函数值 $\\{y_i\\}_{i=0}^{n-1}$ 构建的，其中 $y_i = f(x_i)$。指定了两种类型的节点分布：\n1.  **等距节点**：$x_i = -1 + \\frac{2i}{n-1}$，对于 $i=0, \\dots, n-1$。这些节点是均匀分布的。\n2.  **切比雪夫节点（第一类）**：$x_i = \\cos\\left( \\frac{(2i+1)\\pi}{2n} \\right)$，对于 $i=0, \\dots, n-1$。这些节点是 $n$ 次切比雪夫多项式 $T_n(x)$ 的根，更密集地聚集在区间的端点附近。已知此属性可有效减轻与等距节点上的高次多项式插值相关的大幅振荡（龙格现象）。\n\n三种逼近方法的实现如下：\n\n**1. 全局多项式插值 ($P_n(x)$)**\n对于给定的一组 $n$ 个数据点 $\\{(x_i, y_i)\\}_{i=0}^{n-1}$（节点 $x_i$ 各不相同），存在唯一的次数至多为 $n-1$ 的多项式 $P_n(x)$，使得对所有 $i$ 都有 $P_n(x_i) = y_i$。该多项式可以写作单项式基的形式 $P_n(x) = \\sum_{k=0}^{n-1} c_k x^k$。系数 $\\{c_k\\}$ 可以通过求解以下线性方程组得到：\n$$\n\\begin{pmatrix}\n1  x_0  x_0^2  \\cdots  x_0^{n-1} \\\\\n1  x_1  x_1^2  \\cdots  x_1^{n-1} \\\\\n\\vdots  \\vdots  \\vdots  \\ddots  \\vdots \\\\\n1  x_{n-1}  x_{n-1}^2  \\cdots  x_{n-1}^{n-1}\n\\end{pmatrix}\n\\begin{pmatrix}\nc_0 \\\\\nc_1 \\\\\n\\vdots \\\\\nc_{n-1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\ny_0 \\\\\ny_1 \\\\\n\\vdots \\\\\ny_{n-1}\n\\end{pmatrix}\n$$\n左侧的矩阵是范德蒙矩阵。虽然从概念上讲，求解这个系统很简单，但范德蒙矩阵通常是病态的，尤其是在节点为等距分布且 $n$ 较大时。通常首选数值稳定的算法，例如基于重心插值的算法，但对于给定的参数，求解该系统是可行的。实现将确定系数，然后在网格 $\\{z_j\\}$ 上评估所得多项式。对于不连续函数，$P_n(x)$ 预计在不连续点附近表现出振荡行为（吉布斯现象），并且随着 $n$ 的增加，最大误差不会收敛到零。\n\n**2. 局部逐段线性逼近 ($L_n(x)$)**\n该方法构建一个由线性段组成的连续函数。首先，将节点 $\\{x_i\\}$ 按升序排序，称之为 $\\{x'_i\\}$。在每个子区间 $[x'_i, x'_{i+1}]$ 上，逼近函数 $L_n(x)$ 是连接点 $(x'_i, y'_i)$ 和 $(x'_{i+1}, y'_{i+1})$ 的直线，其中 $y'_i = f(x'_i)$。这是一个局部方案，因为在任何给定子区间上的逼近函数的定义仅取决于其两端的数据点。该方法的误差是有界的，并且对于具有跳跃间断点的函数，误差不会收敛到零。最大误差将大约是跳跃幅度的一半，即 $\\approx 1.0$，并将出现在跨越不连续点的子区间中。\n\n**3. 局部逐段常数逼近 ($C_n(x)$)**\n这是最简单的局部逼近方案。定义域根据与节点的邻近度被划分为单元格。对于 $[-1, 1]$ 中的任何点 $x$，逼近函数 $C_n(x)$ 的值为 $y_k = f(x_k)$，其中 $x_k$ 是与 $x$ 最近的节点。如果节点按 $x'_0  x'_1  \\dots  x'_{n-1}$ 排序，这些单元格的边界是中点 $m_i = (x'_i + x'_{i+1})/2$。与内部节点 $x'_i$ 对应的单元格是 $[m_{i-1}, m_i)$。对于评估网格中的任何点 $z$，我们找到它属于哪个单元格，并赋以相应节点的函数值。与逐段线性情况类似，误差将被限制在约 $1.0$ 左右，并且对于 $f(x) = \\mathrm{sign}(x)$，误差不会收敛到零。\n\n程序将系统地执行指定的测试用例，每个用例由节点数 $n$ 及其分布定义，并计算三个误差范数 $E_\\infty(P_n)$、$E_\\infty(L_n)$ 和 $E_\\infty(C_n)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Compares global polynomial interpolation vs. local piecewise approximants\n    for the signum function f(x) = sign(x) on [-1, 1].\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'type': 'equispaced', 'n': 9},\n        {'type': 'chebyshev', 'n': 9},\n        {'type': 'equispaced', 'n': 3},\n        {'type': 'equispaced', 'n': 10},\n        {'type': 'chebyshev', 'n': 25},\n    ]\n\n    # Define the high-resolution evaluation grid\n    N = 2001\n    z_eval = np.linspace(-1, 1, N)\n    \n    # Evaluate the true function f(x) = sign(x) on the grid\n    # np.sign(0) is 0, which matches the problem's definition.\n    f_eval = np.sign(z_eval)\n    \n    all_results = []\n\n    for case in test_cases:\n        n = case['n']\n        node_type = case['type']\n\n        # 1. Generate interpolation nodes and corresponding y-values\n        if node_type == 'equispaced':\n            x_nodes = np.linspace(-1, 1, n)\n        else:  # 'chebyshev'\n            # Generates nodes in descending order\n            i = np.arange(n)\n            x_nodes = np.cos((2 * i + 1) * np.pi / (2 * n))\n        \n        y_nodes = np.sign(x_nodes)\n\n        # 2. Global Polynomial Interpolant P_n(x)\n        # We find the coefficients of the unique polynomial of degree n-1\n        # and then evaluate it on the fine grid. This is equivalent to\n        # solving the Vandermonde system.\n        poly_coeffs = np.polyfit(x_nodes, y_nodes, n - 1)\n        p_vals = np.polyval(poly_coeffs, z_eval)\n        error_p = np.max(np.abs(p_vals - f_eval))\n\n        # 3. Local Piecewise Linear Approximant L_n(x)\n        # np.interp requires x-coordinates to be in increasing order.\n        # Chebyshev nodes are generated in descending order, so we flip them.\n        if x_nodes[0]  x_nodes[-1]:\n            x_sorted_for_L = np.flip(x_nodes)\n            y_sorted_for_L = np.flip(y_nodes)\n        else:\n            x_sorted_for_L = x_nodes\n            y_sorted_for_L = y_nodes\n        l_vals = np.interp(z_eval, x_sorted_for_L, y_sorted_for_L)\n        error_l = np.max(np.abs(l_vals - f_eval))\n\n        # 4. Local Piecewise Constant Approximant C_n(x)\n        # This approximant assigns the value of the nearest node.\n        # We first sort the nodes to define the cells via their midpoints.\n        sort_indices = np.argsort(x_nodes)\n        x_sorted = x_nodes[sort_indices]\n        y_sorted = y_nodes[sort_indices]\n        \n        # Midpoints define the boundaries of the \"nearest node\" cells.\n        midpoints = (x_sorted[:-1] + x_sorted[1:]) / 2.0\n        \n        # For each evaluation point, find the index of the cell it falls into.\n        # This index corresponds to the index of the closest node in x_sorted.\n        closest_node_indices = np.searchsorted(midpoints, z_eval)\n        \n        c_vals = y_sorted[closest_node_indices]\n        error_c = np.max(np.abs(c_vals - f_eval))\n\n        # 5. Collate errors for the current case\n        all_results.extend([error_p, error_l, error_c])\n\n    # Final print statement in the exact required format.\n    # Each floating-point number is rounded to exactly 8 decimal digits.\n    formatted_results = [f\"{val:.8f}\" for val in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3246671"}]}