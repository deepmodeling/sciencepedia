{"hands_on_practices": [{"introduction": "为开启我们的动手实践，我们先来解决一个将范德蒙德矩阵的理论结构与其在多项式插值中的作用联系起来的问题。本练习采用了一种巧妙的逆向推理方法：通过已知一个插值的最终结果，我们可以推导出所涉及的范德蒙德矩阵的一个基本性质——它的行列式。这个练习将加深你对矩阵性质如何与其所代表的插值问题内在关联的理解。[@problem_id:968114]", "problem": "考虑对函数 $ f(x) = x^4 $ 在不同节点 $ x_0 = 0 $, $ x_1 = a $, $ x_2 = 2a $, $ x_3 = 3a $, $ x_4 = 4a $（其中 $ a $ 为非零实数）上进行插值。插值系统使用一个大小为 $ 5 \\times 5 $ 的范德蒙德矩阵 $ V $。根据克莱姆法则，插值多项式中 $ x^4 $ 的系数由行列式的比值给出。利用插值多项式恰好是 $ x^4 $ 这一事实，求 $ V $ 的行列式。", "solution": "节点 $ [x_0, x_1, x_2, x_3, x_4] $ 对应的范德蒙德矩阵 $ V $ 为：\n$$\nV = \\begin{bmatrix}\n1 & x_0 & x_0^2 & x_0^3 & x_0^4 \\\\\n1 & x_1 & x_1^2 & x_1^3 & x_1^4 \\\\\n1 & x_2 & x_2^2 & x_2^3 & x_2^4 \\\\\n1 & x_3 & x_3^2 & x_3^3 & x_3^4 \\\\\n1 & x_4 & x_4^2 & x_4^3 & x_4^4\n\\end{bmatrix} = \\begin{bmatrix}\n1 & 0 & 0 & 0 & 0 \\\\\n1 & a & a^2 & a^3 & a^4 \\\\\n1 & 2a & 4a^2 & 8a^3 & 16a^4 \\\\\n1 & 3a & 9a^2 & 27a^3 & 81a^4 \\\\\n1 & 4a & 16a^2 & 64a^3 & 256a^4\n\\end{bmatrix}.\n$$\n函数值向量为 $ \\mathbf{y} = [f(x_0), f(x_1), f(x_2), f(x_3), f(x_4)]^\\top = [0, a^4, 16a^4, 81a^4, 256a^4]^\\top $。根据克莱姆法则，$ x^4 $ 的系数 $ c_4 $ 为：\n$$\nc_4 = \\frac{\\det(V_4)}{\\det(V)},\n$$\n其中 $ V_4 $ 是将 $ V $ 的第五列替换为 $ \\mathbf{y} $ 后得到的矩阵：\n$$\nV_4 = \\begin{bmatrix}\n1 & 0 & 0 & 0 & 0 \\\\\n1 & a & a^2 & a^3 & a^4 \\\\\n1 & 2a & 4a^2 & 8a^3 & 16a^4 \\\\\n1 & 3a & 9a^2 & 27a^3 & 81a^4 \\\\\n1 & 4a & 16a^2 & 64a^3 & 256a^4\n\\end{bmatrix}.\n$$\n沿第一行展开 $ \\det(V_4) $。由于第一行中唯一的非零元素是第一个元素 (1)，因此：\n$$\n\\det(V_4) = 1 \\cdot (-1)^{1+1} \\det(M_{11}) = \\det \\begin{bmatrix}\na & a^2 & a^3 & a^4 \\\\\n2a & 4a^2 & 8a^3 & 16a^4 \\\\\n3a & 9a^2 & 27a^3 & 81a^4 \\\\\n4a & 16a^2 & 64a^3 & 256a^4\n\\end{bmatrix}.\n$$\n从第一列提出因子 $ a $，从第二列提出 $ a^2 $，从第三列提出 $ a^3 $，从第四列提出 $ a^4 $：\n$$\n= a \\cdot a^2 \\cdot a^3 \\cdot a^4 \\cdot \\det \\begin{bmatrix}\n1 & 1 & 1 & 1 \\\\\n2 & 4 & 8 & 16 \\\\\n3 & 9 & 27 & 81 \\\\\n4 & 16 & 64 & 256\n\\end{bmatrix} = a^{10} \\det(W), \\quad W = \\begin{bmatrix}\n1 & 1 & 1 & 1 \\\\\n2 & 4 & 8 & 16 \\\\\n3 & 9 & 27 & 81 \\\\\n4 & 16 & 64 & 256\n\\end{bmatrix}.\n$$\n从 $ W $ 的每一行提出常数因子：\n- 第1行：提出因子 1 → $ 1 \\cdot [1, 1, 1, 1] $\n- 第2行：提出因子 2 → $ 2 \\cdot [1, 2, 4, 8] $\n- 第3行：提出因子 3 → $ 3 \\cdot [1, 3, 9, 27] $\n- 第4行：提出因子 4 → $ 4 \\cdot [1, 4, 16, 64] $\n因此：\n$$\n\\det(W) = (1 \\cdot 2 \\cdot 3 \\cdot 4) \\det \\begin{bmatrix}\n1 & 1 & 1 & 1 \\\\\n1 & 2 & 4 & 8 \\\\\n1 & 3 & 9 & 27 \\\\\n1 & 4 & 16 & 64\n\\end{bmatrix} = 24 \\det(V_{\\text{std}}),\n$$\n其中 $ V_{\\text{std}} $ 是节点 $ [1, 2, 3, 4] $ 对应的范德蒙矩阵（幂次从0到3）。其行列式为：\n$$\n\\det(V_{\\text{std}}) = \\prod_{1 \\leq i  j \\leq 4} (j - i) = (2-1)(3-1)(4-1)(3-2)(4-2)(4-3) = 1 \\cdot 2 \\cdot 3 \\cdot 1 \\cdot 2 \\cdot 1 = 12.\n$$\n所以 $ \\det(W) = 24 \\cdot 12 = 288 $，且 $ \\det(V_4) = a^{10} \\cdot 288 $。因为插值多项式是 $ x^4 $，所以 $ c_4 = 1 $。求解 $ \\det(V) $：\n$$\n1 = \\frac{288 a^{10}}{\\det(V)} \\implies \\det(V) = 288 a^{10}.\n$$", "answer": "$$ \\boxed{288 a^{10}} $$", "id": "968114"}, {"introduction": "从理论转向一个实际的编程练习，我们现在将使用范德蒙系统来探索信号混叠现象。你将使用不足的样本点数来对一个高频信号进行插值，并观察所生成的多项式如何跟随一个低频的“混叠”信号，而非真实的原始信号。这个实验 [@problem_id:3285621] 直观地展示了奈奎斯特-香农采样定理，并突显了插值在现实世界中的一个关键局限性。", "problem": "您将编写一个完整的程序，该程序使用范德蒙系统进行多项式插值，以演示正弦信号的混叠现象。您必须从采样和多项式插值的基本定义出发，并量化说明当采样过慢时，所得到的插值函数如何无法区分混叠到较低频率的高频信号。\n\n基本原理：\n- 以速率 $f_s$ 进行均匀采样意味着采样时间为 $t_n = n/f_s$，其中 $n$ 为整数。对于任何实数频率 $f$，离散时间复指数 $e^{i 2\\pi f t_n}$ 在 $f$ 上是周期性的，周期为 $f_s$，因此对于任何整数 $k$，都有 $e^{i 2\\pi f t_n} = e^{i 2\\pi (f + k f_s) t_n}$。由于 $\\sin(\\cdot)$ 和 $\\cos(\\cdot)$ 是这类指数的虚部和实部，因此离散时间正弦波在混叠的情况下是无法区分的。一个常见的基带混叠映射是 $f \\mapsto f_{\\text{alias}} \\in [0, f_s/2]$，它通过离散时间频率的周期性将 $f$ 折叠到主区间内来定义。这概括了香农-奈奎斯特采样定理，即如果 $f \\geq f_s/2$，则无法从均匀采样中唯一地重建连续时间正弦波。\n- 对于多项式插值，给定不同的节点 $x_0,\\dots,x_{N-1}$ 和值 $y_0,\\dots,y_{N-1}$，存在一个唯一的次数至多为 $N-1$ 的多项式 $p(x)$，使得对所有 $n$ 都有 $p(x_n)=y_n$。写作 $p(x)=\\sum_{k=0}^{N-1} c_k x^k$，系数 $c_k$ 是范德蒙线性系统 $V c = y$ 的解，其中 $V_{n,k} = x_n^k$。\n\n任务：\n- 对于每个测试用例，考虑一个连续时间信号 $s(t) = \\sin(2\\pi f_{\\text{high}} t)$，在时间点 $t_n = n/f_s$（$n=0,1,\\dots,N-1$）进行采样。通过求解以节点 $t_n$ 和数据 $y_n = s(t_n)$ 构成的范德蒙系统，构建次数为 $(N-1)$ 的插值多项式 $p(t)$。\n- 根据上述离散时间频率的周期性，通过折叠 $f_{\\text{high}}$ 来计算基带混叠频率 $f_{\\text{alias}} \\in [0, f_s/2]$。\n- 使用线性最小二乘模型 $y_n \\approx A \\sin(2\\pi f_{\\text{alias}} t_n) + B \\cos(2\\pi f_{\\text{alias}} t_n)$ 对采样数据 $y_n$ 进行频率为 $f_{\\text{alias}}$ 的正弦波拟合，以确定使残差平方和最小的系数 $A$ 和 $B$。这体现了一个事实：任何频率的采样正弦波（在混叠情况下）都可以表示为其基带混叠频率下同相和正交正弦波的线性组合。\n- 在采样点所跨越的区间上，在一个包含 $M$ 个点的密集网格上，评估：\n  1. 真实的连续信号 $s(t)$。\n  2. 拟合的混叠正弦波 $\\tilde{s}_{\\text{alias}}(t) = A \\sin(2\\pi f_{\\text{alias}} t) + B \\cos(2\\pi f_{\\text{alias}} t)$。\n  3. 来自范德蒙系统的插值多项式 $p(t)$。\n\n对于每个测试用例，计算并报告以下可量化的指标：\n- $E_1$：在采样时刻，测量样本与拟合的混叠正弦波之间的最大绝对不匹配度，$E_1 = \\max_n \\left| y_n - \\left(A \\sin(2\\pi f_{\\text{alias}} t_n) + B \\cos(2\\pi f_{\\text{alias}} t_n)\\right) \\right|$。\n- $E_2$：在采样时刻的最大绝对插值误差，$E_2 = \\max_n | y_n - p(t_n) |$。\n- $\\kappa(V)$：基于 $\\{t_n\\}$ 构建的范德蒙矩阵 $V$ 的 $2$-范数条件数。\n- $E_3$：在密集网格上，真实连续信号与拟合的混叠正弦波之间的均方根差，$E_3 = \\sqrt{\\frac{1}{M} \\sum_{m=1}^{M} \\left( s(t_m) - \\tilde{s}_{\\text{alias}}(t_m) \\right)^2 }$。\n- $E_4$：在密集网格上，插值多项式与真实连续信号之间的均方根差，$E_4 = \\sqrt{\\frac{1}{M} \\sum_{m=1}^{M} \\left( p(t_m) - s(t_m) \\right)^2 }$。\n\n测试套件：\n提供三个测试用例来探究不同的情况：\n- 情况1（混叠）：$f_s = 10.0$ 赫兹, $N = 8$, $f_{\\text{high}} = 9.0$ 赫兹。此处 $f_{\\text{high}}  f_s/2$，因此采样不足，应混叠成一个低频正弦波。\n- 情况2（充分采样）：$f_s = 50.0$ 赫兹, $N = 12$, $f_{\\text{high}} = 9.0$ 赫兹。此处 $f_{\\text{high}}  f_s/2$，因此拟合的混叠频率应与真实频率一致。\n- 情况3（奈奎斯特边界）：$f_s = 20.0$ 赫兹, $N = 11$, $f_{\\text{high}} = 10.0$ 赫兹。这是奈奎斯特极限 $f_{\\text{high}} = f_s/2$，此时在 $t_n = n/f_s$ 处采样的纯正弦波会产生 $y_n = \\sin(\\pi n) = 0$（对于所有整数 $n$），这突显了极端的模糊性。\n\n实现细节：\n- 全文中时间单位使用秒，频率单位使用赫兹。\n- 使用 $x_n = t_n$ 和单项式基 $\\{1, x, x^2, \\dots, x^{N-1}\\}$ 构建范德蒙系统；求解 $V c = y$ 以得到 $c$。\n- 使用一个从最小采样时间到最大采样时间的包含 $M = 1001$ 个点的密集均匀网格。\n- 将所有浮点输出四舍五入到 $10$ 位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有测试用例的结果列表。每个测试用例必须按顺序 $[E_1, E_2, \\kappa(V), E_3, E_4]$ 提供一个包含五个浮点数的列表，并四舍五入到 $10$ 位小数。总输出必须是这些按用例生成的列表的单个列表，打印为单行，不带任何额外文本。例如，打印的结构应如下所示：\n[[e11,e12,e13,e14,e15],[e21,e22,e23,e24,e25],[e31,e32,e33,e34,e35]]", "solution": "已对用户提供的问题陈述进行了分析和验证。\n\n### 第 1 步：提取已知条件\n- **信号**：连续时间信号为 $s(t) = \\sin(2\\pi f_{\\text{high}} t)$。\n- **采样**：以均匀速率 $f_s$ 在时间点 $t_n = n/f_s$（$n=0, 1, \\dots, N-1$）进行采样。采样值为 $y_n = s(t_n)$。\n- **混叠频率**：基带混叠频率 $f_{\\text{alias}}$ 在范围 $[0, f_s/2]$ 内，由高频 $f_{\\text{high}}$ 根据离散时间信号的周期性（$e^{i 2\\pi f t_n} = e^{i 2\\pi (f + k f_s) t_n}$，其中 $k$ 为任意整数）折叠而来。\n- **多项式插值**：找到唯一的次数至多为 $N-1$ 的多项式 $p(t)$，使得 $p(t_n) = y_n$。$p(t)=\\sum_{k=0}^{N-1} c_k t^k$ 的系数 $c_k$ 通过求解范德蒙系统 $V c = y$ 得到，其中矩阵 $V$ 的元素为 $V_{n,k} = t_n^k$。\n- **混叠正弦波拟合**：确定系数 $A$ 和 $B$ 以最小化模型 $y_n \\approx A \\sin(2\\pi f_{\\text{alias}} t_n) + B \\cos(2\\pi f_{\\text{alias}} t_n)$ 的残差平方和。得到的拟合正弦波为 $\\tilde{s}_{\\text{alias}}(t) = A \\sin(2\\pi f_{\\text{alias}} t) + B \\cos(2\\pi f_{\\text{alias}} t)$。\n- **密集网格**：使用一个包含 $M = 1001$ 个均匀间隔点的评估网格，该网格跨越从 $t_0$ 到 $t_{N-1}$ 的区间。\n- **指标**：\n    1.  混叠拟合在采样点上的最大误差：$E_1 = \\max_n \\left| y_n - \\tilde{s}_{\\text{alias}}(t_n) \\right|$。\n    2.  多项式插值在采样点上的最大误差：$E_2 = \\max_n | y_n - p(t_n) |$。\n    3.  范德蒙矩阵的条件数：$\\kappa(V)$，使用 $2$-范数。\n    4.  密集网格上真实信号与混叠拟合之间的均方根误差：$E_3 = \\sqrt{\\frac{1}{M} \\sum_{m=1}^{M} \\left( s(t_m) - \\tilde{s}_{\\text{alias}}(t_m) \\right)^2 }$。\n    5.  密集网格上真实信号与多项式插值之间的均方根误差：$E_4 = \\sqrt{\\frac{1}{M} \\sum_{m=1}^{M} \\left( p(t_m) - s(t_m) \\right)^2 }$。\n- **测试用例**：\n    - 情况 1：$f_s = 10.0$ Hz, $N = 8$, $f_{\\text{high}} = 9.0$ Hz。\n    - 情况 2：$f_s = 50.0$ Hz, $N = 12$, $f_{\\text{high}} = 9.0$ Hz。\n    - 情况 3：$f_s = 20.0$ Hz, $N = 11$, $f_{\\text{high}} = 10.0$ Hz。\n- **取整**：所有最终的浮点指标必须四舍五入到 $10$ 位小数。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n- **科学基础（关键）**：该问题在根本上是合理的。它建立在数字信号处理（香non-奈奎斯特采样定理、混叠）和数值分析（通过范德蒙系统进行多项式插值、线性最小二乘法）的核心原理之上。所有概念都是标准的且事实正确。\n- **适定性**：该问题是适定的。对于不同的采样时间 $t_n$，范德蒙矩阵 $V$ 是非奇异的，保证了唯一的插值多项式存在。用于混叠正弦波拟合的线性最小二乘问题也是明确定义的，即使在其中一个基函数在采样点上恒为零的特殊边界情况（情况 3）下也是如此。计算被清晰地指定，并导向一组唯一的指标。\n- **客观性（关键）**：该问题以精确、量化和无偏见的语言陈述。所有任务都是基于所提供数据的确定性计算。\n- **其他缺陷**：该问题是自洽、一致且计算上可行的。它没有表现出验证清单中列出的任何缺陷，例如非形式化、不完整、不切实际、不适定或过于简单。\n\n### 第 3 步：结论与行动\n该问题**有效**。将提供完整的解决方案。\n\n### 基于原理的设计\n解决方案将通过为每个测试用例实施一个计算程序来构建，遵循数字信号处理和数值线性代数的原理。\n\n#### 1. 采样和混叠\n对于每个具有参数 $f_s$、$N$ 和 $f_{\\text{high}}$ 的测试用例，我们首先建立信号的离散表示。\n- 采样时间在区间 $[0, (N-1)/f_s]$ 上生成为 $t_n = n/f_s$，其中 $n \\in \\{0, 1, \\dots, N-1\\}$。\n- 连续信号为 $s(t) = \\sin(2\\pi f_{\\text{high}} t)$。样本计算为 $y_n = s(t_n)$。\n- 必须确定混叠频率 $f_{\\text{alias}}$。对于一个连续频率 $f$，其离散时间混叠等效频率是周期性的，周期为 $f_s$。我们找到唯一的频率 $f' \\in [-f_s/2, f_s/2]$，使得 $f \\equiv f' \\pmod{f_s}$。然后基带混叠频率为 $f_{\\text{alias}} = |f'|$。此映射可以系统地计算为 $f_{\\text{alias}} = | \\text{mod}(f_{\\text{high}} + f_s/2, f_s) - f_s/2 |$，其中 $\\text{mod}$ 是浮点余数运算。\n\n#### 2. 使用范德蒙系统的多项式插值\n目标是找到唯一的次数至多为 $N-1$ 的多项式 $p(t) = \\sum_{k=0}^{N-1} c_k t^k$，该多项式穿过 $N$ 个采样点 $(t_n, y_n)$。这个条件 $p(t_n) = y_n$（对所有 $n$）为 $N$ 个未知系数 $c_k$ 生成了一个包含 $N$ 个线性方程的系统：\n$$\n\\begin{pmatrix}\nt_0^0  t_0^1  \\dots  t_0^{N-1} \\\\\nt_1^0  t_1^1  \\dots  t_1^{N-1} \\\\\n\\vdots  \\vdots  \\ddots  \\vdots \\\\\nt_{N-1}^0  t_{N-1}^1  \\dots  t_{N-1}^{N-1}\n\\end{pmatrix}\n\\begin{pmatrix}\nc_0 \\\\ c_1 \\\\ \\vdots \\\\ c_{N-1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\ny_0 \\\\ y_1 \\\\ \\vdots \\\\ y_{N-1}\n\\end{pmatrix}\n$$\n这就是范德蒙系统 $V c = y$。我们将：\n- 构建范德蒙矩阵 $V$，其中 $V_{n,k} = t_n^k$。\n- 使用标准线性求解器求解该系统以获得系数向量 $c$。\n- 计算 $2$-范数条件数 $\\kappa(V)$ 以评估历史上著名的病态范德蒙矩阵的数值稳定性。\n\n#### 3. 通过最小二乘法进行混叠正弦波拟合\n已知样本 $y_n$ 与频率为 $f_{\\text{alias}}$ 的正弦波的样本无法区分。我们将此关系建模为 $y_n \\approx \\tilde{s}_{\\text{alias}}(t_n) = A \\sin(2\\pi f_{\\text{alias}} t_n) + B \\cos(2\\pi f_{\\text{alias}} t_n)$。我们找到最小化误差平方和 $\\sum_{n=0}^{N-1} (y_n - \\tilde{s}_{\\text{alias}}(t_n))^2$ 的系数 $A$ 和 $B$。这是一个形如 $M x \\approx y$ 的线性最小二乘问题，其中：\n$$\nM = \\begin{pmatrix}\n\\sin(2\\pi f_{\\text{alias}} t_0)  \\cos(2\\pi f_{\\text{alias}} t_0) \\\\\n\\sin(2\\pi f_{\\text{alias}} t_1)  \\cos(2\\pi f_{\\text{alias}} t_1) \\\\\n\\vdots  \\vdots \\\\\n\\sin(2\\pi f_{\\text{alias}} t_{N-1})  \\cos(2\\pi f_{\\text{alias}} t_{N-1})\n\\end{pmatrix}, \\quad\nx = \\begin{pmatrix} A \\\\ B \\end{pmatrix}, \\quad\ny = \\begin{pmatrix} y_0 \\\\ y_1 \\\\ \\vdots \\\\ y_{N-1} \\end{pmatrix}\n$$\n解 $x$ 通过求解正规方程 $(M^T M) x = M^T y$ 得到。\n\n#### 4. 误差量化\n最后，我们计算五个指定的指标来量化混叠的影响和插值函数的行为。\n- $E_1$：衡量样本 $y_n$ 与混叠频率下的正弦波的匹配程度。对于真正的混叠，这两者应完全相同，因此 $E_1$ 应接近机器精度。\n- $E_2$：衡量多项式插值在采样节点处的准确性。根据插值的定义，此误差应接近机器精度，可作为 $Vc=y$ 数值解的健全性检查。\n- $\\kappa(V)$：表征范德蒙矩阵的病态程度。这个值通常很大，表明 $y_n$ 中的小误差可能导致系数 $c_k$ 的大误差。\n- $E_3$：衡量在连续区间上，真实高频信号与其低频混叠表示之间的均方根差。值越大表明尽管它们在采样点上匹配，但它们是不同的函数。\n- $E_4$：衡量真实信号与插值多项式之间的均方根差。这揭示了被迫匹配样本的多项式在采样点之间对底层连续函数的逼近程度。在混叠的情况下，预计此误差会很大，因为多项式将倾向于跟随低频混叠而不是真实的高频信号。\n\n该程序将应用于三个测试用例中的每一个，这些用例旨在探究混叠（$f_{\\text{high}}  f_s/2$）、充分采样（$f_{\\text{high}}  f_s/2$）和临界奈奎斯特边界情况（$f_{\\text{high}} = f_s/2$）的现象。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef process_case(fs, N, f_high):\n    \"\"\"\n    Performs the full analysis for a single test case of signal aliasing.\n    \n    Args:\n        fs (float): Sampling frequency in Hertz.\n        N (int): Number of samples.\n        f_high (float): Frequency of the continuous-time signal in Hertz.\n        \n    Returns:\n        list: A list of five metrics [E1, E2, kappa_V, E3, E4], rounded.\n    \"\"\"\n    M = 1001 # Number of points for the dense grid\n\n    # 1. Sampling and Signal Generation\n    t_n = np.arange(N) / fs\n    y_n = np.sin(2 * np.pi * f_high * t_n)\n\n    # 2. Polynomial Interpolation via Vandermonde System\n    # The problem defines V_nk = t_n^k, which corresponds to increasing=True.\n    V = np.vander(t_n, N, increasing=True)\n    \n    # Solve Vc = y_n for polynomial coefficients c\n    # These coefficients are for the basis {1, t, t^2, ...}\n    try:\n        c = np.linalg.solve(V, y_n)\n    except np.linalg.LinAlgError:\n        # This should not happen for distinct t_n, but as a safeguard\n        return [np.nan] * 5\n\n    # Compute condition number of V\n    kappa_V = np.linalg.cond(V)\n\n    # 3. Alias Sinusoid Fitting\n    # Calculate alias frequency in the baseband [0, fs/2]\n    f_prime = np.mod(f_high + fs / 2.0, fs) - fs / 2.0\n    f_alias = np.abs(f_prime)\n    \n    # Set up and solve the linear least squares problem:\n    # y_n approx A*sin(...) + B*cos(...)\n    A_matrix = np.column_stack([\n        np.sin(2 * np.pi * f_alias * t_n),\n        np.cos(2 * np.pi * f_alias * t_n)\n    ])\n    \n    # lstsq returns (coeffs, residuals, rank, singular_values)\n    coeffs_ab, _, _, _ = np.linalg.lstsq(A_matrix, y_n, rcond=None)\n    A, B = coeffs_ab[0], coeffs_ab[1]\n    \n    # Fitted alias sinusoid function\n    s_alias_func = lambda t: A * np.sin(2 * np.pi * f_alias * t) + B * np.cos(2 * np.pi * f_alias * t)\n\n    # 4. Evaluation on Dense Grid\n    t_min, t_max = t_n[0], t_n[-1]\n    t_dense = np.linspace(t_min, t_max, M)\n    \n    # Evaluate signals on the dense grid\n    s_true_dense = np.sin(2 * np.pi * f_high * t_dense)\n    s_alias_dense = s_alias_func(t_dense)\n    # np.polyval expects coefficients in descending order of power\n    p_dense = np.polyval(c[::-1], t_dense)\n\n    # 5. Compute Metrics\n    # E1: Max absolute mismatch of alias fit at sample times\n    s_alias_at_samples = s_alias_func(t_n)\n    E1 = np.max(np.abs(y_n - s_alias_at_samples))\n\n    # E2: Max absolute interpolation error at sample times\n    # This should be close to machine epsilon by definition of interpolation\n    p_at_samples = np.polyval(c[::-1], t_n)\n    E2 = np.max(np.abs(y_n - p_at_samples))\n    \n    # E3: RMS difference between true signal and alias fit on dense grid\n    E3 = np.sqrt(np.mean((s_true_dense - s_alias_dense)**2))\n    \n    # E4: RMS difference between interpolating polynomial and true signal on dense grid\n    E4 = np.sqrt(np.mean((p_dense - s_true_dense)**2))\n\n    # Return rounded metrics\n    return [\n        np.round(E1, 10),\n        np.round(E2, 10),\n        np.round(kappa_V, 10),\n        np.round(E3, 10),\n        np.round(E4, 10)\n    ]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (Aliasing)\n        (10.0, 8, 9.0),\n        # Case 2 (Adequate sampling)\n        (50.0, 12, 9.0),\n        # Case 3 (Nyquist boundary)\n        (20.0, 11, 10.0)\n    ]\n\n    results = []\n    for i, case in enumerate(test_cases):\n        fs, N, f_high = case\n        case_results = process_case(fs, N, f_high)\n        results.append(case_results)\n\n    # Convert each inner list to its string representation\n    # and join them with commas for the final output format.\n    # e.g., [[1.0, 2.0], [3.0, 4.0]] - '[[1.0, 2.0],[3.0, 4.0]]'\n    final_output_str = f\"[{','.join(map(str, results))}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n```", "id": "3285621"}, {"introduction": "虽然范德蒙矩阵为求解插值多项式提供了一种直接的方法，但它存在一个主要的实际缺陷：数值不稳定性，尤其是在处理高次多项式时。这最后一个练习是一个数值实验，旨在让你亲眼见证这个问题并探索其解决方案。通过比较范德蒙矩阵（单项式基）与由正交基（勒让德多项式）构建的矩阵的条件数，你将通过经验证明为何在实际数据拟合中正交基更为优越。[@problem_id:3285634]", "problem": "设计并实现一个数值实验，以比较用于实数区间上数据拟合的两种多项式基的数值条件：单项式基和正交多项式基。单项式基产生经典的 Vandermonde 矩阵。所使用的正交基是闭区间 $\\left[-1,1\\right]$ 上的 Legendre 多项式基。对于几个指定的测试用例，您的程序必须构建相应的设计矩阵，计算它们在谱矩阵范数下的条件数，并报告条件数的比率，从而经验性地证明其相对数值稳定性。\n\n基本概念：\n- 对于节点 $\\left\\{x_i\\right\\}_{i=0}^{n-1}$ 和多项式次数 $m$，Vandermonde 矩阵是一个设计矩阵 $V \\in \\mathbb{R}^{n \\times (m+1)}$，其元素为 $V_{i,k} = x_i^k$，其中 $k=0,1,\\dots,m$。\n- $\\left[-1,1\\right]$ 上的 Legendre 多项式 $\\left\\{P_k\\right\\}_{k=0}^m$ 由其关于标准内积 $\\langle f,g \\rangle = \\int_{-1}^{1} f(x) g(x) \\, dx$ 的正交性定义，归一化为 $P_0(x)=1$，$P_1(x)=x$，并对于 $k \\ge 1$ 满足经过充分检验的三项递推关系，\n$$\n(k+1) P_{k+1}(x) = (2k+1) x P_k(x) - k P_{k-1}(x).\n$$\nLegendre 设计矩阵 $L \\in \\mathbb{R}^{n \\times (m+1)}$ 的元素为 $L_{i,k} = P_k(x_i)$，其中 $k=0,1,\\dots,m$。\n- 一个满列秩矩阵 $A$ 的谱（矩阵 $2$-范数）条件数定义为 $\\kappa_2(A) = \\sigma_{\\max}(A)/\\sigma_{\\min}(A)$，其中 $\\sigma_{\\max}(A)$ 和 $\\sigma_{\\min}(A)$ 分别是 $A$ 的最大和最小奇异值。在有限精度算法中，较大的 $\\kappa_2(A)$ 表示最小二乘解对数据扰动的敏感性更高，因此数值稳定性更差。\n\n任务：\n- 对于下面指定的每个测试用例，给定次数 $m$ 和节点集 $\\left\\{x_i\\right\\}$，构建：\n  1. Vandermonde 矩阵 $V$，其列是在节点处求值的 $\\left\\{1,x,x^2,\\dots,x^m\\right\\}$。\n  2. Legendre 矩阵 $L$，其列是使用上述三项递推关系在节点处求值的 $\\left\\{P_0(x),P_1(x),\\dots,P_m(x)\\right\\}$。\n- 为每种情况计算 $\\kappa_2(V)$ 和 $\\kappa_2(L)$。\n- 对于每种情况，输出比率 $r = \\kappa_2(V) / \\kappa_2(L)$，结果为一个四舍五入到 $6$ 位有效数字的浮点数。\n\n角度单位：所有三角函数的参数均使用弧度。\n\n测试套件：\n- 情况 $1$ (方阵，等距节点，中等次数)：$m=10$，$n=m+1$，节点 $x_i = -1 + \\dfrac{2i}{m}$，其中 $i=0,1,\\dots,m$。\n- 情况 $2$ (方阵，等距节点，更高次数)：$m=15$，$n=m+1$，节点 $x_i = -1 + \\dfrac{2i}{m}$，其中 $i=0,1,\\dots,m$。\n- 情况 $3$ (方阵，Chebyshev–Lobatto 节点)：$m=15$，$n=m+1$，节点 $x_i = \\cos\\!\\left(\\dfrac{\\pi i}{m}\\right)$，其中 $i=0,1,\\dots,m$。\n- 情况 $4$ (方阵，节点聚集在零附近)：$m=15$，$n=m+1$，节点 $x_i = 10^{-3}\\left(-1 + \\dfrac{2i}{m}\\right)$，其中 $i=0,1,\\dots,m$。\n- 情况 $5$ (超定，Chebyshev–Lobatto 节点)：$m=10$，$n=50$，节点 $x_i = \\cos\\!\\left(\\dfrac{\\pi i}{n-1}\\right)$，其中 $i=0,1,\\dots,n-1$。\n\n输出规格：\n- 您的程序应生成单行输出，其中包含按顺序排列的情况 1 到 5 的 5 个比率，形式为用方括号括起来的逗号分隔列表。例如：$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5\\right]$。\n- 每个 $\\text{result}_k$ 必须是四舍五入到 $6$ 位有效数字的浮点数。\n\n科学真实性与覆盖范围说明：\n- 等距节点的情况测试了 Vandermonde 系统的已知病态条件以及使用正交基带来的预期改善。\n- Chebyshev–Lobatto 节点的情况测试了那些在理论上更适合多项式逼近并能减少病态条件的节点。\n- 节点聚集在零附近的情况通过在更高次幂项之间产生近线性相关性，对单项式基构成了考验。\n- 超定情况展示了最小二乘设计矩阵中的条件问题。", "solution": "问题陈述已经过分析并被确定为**有效**。这是一个适定的、有科学依据的数值分析问题，提供了所有必要的数据和定义。任务是进行一项数值实验，比较从单项式基（Vandermonde 矩阵）和正交多项式基（Legendre 多项式）派生出的设计矩阵的条件。\n\n解决方案是通过实现一个数值程序来推进的，该程序针对每个指定的测试用例计算所需的条件数比率。其方法如下：\n\n首先，对于每个测试用例，我们给定一个多项式次数 $m$，采样点数 $n$，以及区间 $[-1, 1]$ 上的一个节点集 $\\{x_i\\}_{i=0}^{n-1}$。我们构建两个大小为 $n \\times (m+1)$ 的设计矩阵。\n\n第一个矩阵是 Vandermonde 矩阵 $V$，它源于使用单项式基 $\\{1, x, x^2, \\dots, x^m\\}$。$V$ 的第 $i$ 行和第 $k$ 列（行和列均使用从0开始的索引）的元素由下式给出：\n$$\nV_{i,k} = x_i^k \\quad \\text{for } i=0, \\dots, n-1 \\text{ and } k=0, \\dots, m.\n$$\n该矩阵是为给定的节点集 $\\{x_i\\}$ 构建的。\n\n第二个矩阵是 Legendre 设计矩阵 $L$，它源于使用 Legendre 多项式基 $\\{P_0(x), P_1(x), \\dots, P_m(x)\\}$。$L$ 的元素由下式给出：\n$$\nL_{i,k} = P_k(x_i) \\quad \\text{for } i=0, \\dots, n-1 \\text{ and } k=0, \\dots, m.\n$$\nLegendre 多项式 $P_k(x_i)$ 的值是数值计算得出的。前两个多项式定义为 $P_0(x) = 1$ 和 $P_1(x) = x$。对于 $k \\ge 1$，后续的多项式使用指定的三项递推关系生成：\n$$\n(k+1) P_{k+1}(x) = (2k+1) x P_k(x) - k P_{k-1}(x).\n$$\n对 $k=1, 2, \\dots, m-1$ 迭代应用此递推关系，以计算每个节点 $x_i$ 处所有必要基多项式的值，从而填充矩阵 $L$ 的各列。\n\n接下来，为矩阵 $V$ 和 $L$ 计算谱条件数 $\\kappa_2$。一个满列秩矩阵 $A$ 的谱条件数定义为其最大奇异值 $\\sigma_{\\max}(A)$ 与最小奇异值 $\\sigma_{\\min}(A)$ 的比率：\n$$\n\\kappa_2(A) = \\frac{\\sigma_{\\max}(A)}{\\sigma_{\\min}(A)}.\n$$\n该值量化了线性系统或最小二乘问题解对输入数据扰动的敏感性。较大的条件数表示数值不稳定性更高。奇异值是使用标准的奇异值分解 (SVD) 算法计算的，该算法在像 NumPy 这样的数值库中可用。\n\n最后，对于每个测试用例，计算两个条件数的比率 $r$：\n$$\nr = \\frac{\\kappa_2(V)}{\\kappa_2(L)}.\n$$\n该比率提供了一个定量度量，衡量了在多项式数据拟合中使用正交多项式基相对于标准单项式基所获得的数值稳定性改善。对所有五个测试用例重复此过程，并收集所得的比率。每个比率在包含到最终输出之前被格式化为 $6$ 位有效数字。该实验证明了 Vandermonde 矩阵的已知不良条件，特别是对于等距节点和更高次数的情况，并展示了正交 Legendre 基所带来的显著改善。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical experiment problem by comparing the conditioning of\n    Vandermonde and Legendre matrices for several test cases.\n    \"\"\"\n\n    # Helper function to evaluate Legendre polynomials P_k(x) for k=0...m\n    # at a given set of nodes x.\n    def evaluate_legendre_basis(x: np.ndarray, m: int) - np.ndarray:\n        \"\"\"\n        Computes the Legendre matrix L where L[i, k] = P_k(x[i]).\n\n        Args:\n            x: A 1D numpy array of nodes.\n            m: The maximum degree of the polynomial basis.\n\n        Returns:\n            A 2D numpy array of shape (len(x), m + 1) containing the\n            evaluations of Legendre polynomials.\n        \"\"\"\n        n = len(x)\n        L_matrix = np.zeros((n, m + 1))\n\n        # P_0(x) = 1\n        L_matrix[:, 0] = 1.0\n\n        if m  0:\n            # P_1(x) = x\n            L_matrix[:, 1] = x\n\n        # Recurrence relation for k = 1:\n        # (k+1) * P_{k+1}(x) = (2k+1) * x * P_k(x) - k * P_{k-1}(x)\n        for k in range(1, m):\n            p_k = L_matrix[:, k]\n            p_k_minus_1 = L_matrix[:, k-1]\n            p_k_plus_1 = ((2 * k + 1) * x * p_k - k * p_k_minus_1) / (k + 1)\n            L_matrix[:, k + 1] = p_k_plus_1\n        \n        return L_matrix\n\n    # Helper function to process a single test case\n    def compute_condition_number_ratio(m: int, nodes: np.ndarray) - float:\n        \"\"\"\n        Constructs Vandermonde and Legendre matrices and computes the ratio\n        of their condition numbers.\n\n        Args:\n            m: The maximum degree of the polynomial basis.\n            nodes: A 1D numpy array of nodes.\n\n        Returns:\n            The ratio kappa(V) / kappa(L).\n        \"\"\"\n        # 1. Construct the Vandermonde matrix (monomial basis)\n        # Columns are [1, x, x^2, ..., x^m]\n        V = np.vander(nodes, N=m + 1, increasing=True)\n        \n        # 2. Construct the Legendre matrix (orthogonal basis)\n        L = evaluate_legendre_basis(nodes, m)\n        \n        # 3. Compute the spectral (2-norm) condition numbers\n        cond_V = np.linalg.cond(V)\n        cond_L = np.linalg.cond(L)\n        \n        # 4. Return the ratio\n        if cond_L == 0:\n            # Avoid division by zero, though unlikely in these cases\n            return float('inf')\n        return cond_V / cond_L\n\n    # Define the test suite as specified in the problem\n    test_cases = [\n        # Case 1: m=10, n=11, equispaced\n        {'m': 10, 'n': 11, 'node_gen': lambda i, m, n: -1 + 2 * i / m},\n        # Case 2: m=15, n=16, equispaced\n        {'m': 15, 'n': 16, 'node_gen': lambda i, m, n: -1 + 2 * i / m},\n        # Case 3: m=15, n=16, Chebyshev-Lobatto\n        {'m': 15, 'n': 16, 'node_gen': lambda i, m, n: np.cos(np.pi * i / m)},\n        # Case 4: m=15, n=16, clustered near zero\n        {'m': 15, 'n': 16, 'node_gen': lambda i, m, n: 1e-3 * (-1 + 2 * i / m)},\n        # Case 5: m=10, n=50, overdetermined Chebyshev-Lobatto\n        {'m': 10, 'n': 50, 'node_gen': lambda i, m, n: np.cos(np.pi * i / (n - 1))}\n    ]\n\n    results = []\n    for case in test_cases:\n        m, n = case['m'], case['n']\n        node_gen = case['node_gen']\n        \n        indices = np.arange(n)\n        nodes = node_gen(indices, m, n)\n        \n        ratio = compute_condition_number_ratio(m, nodes)\n        \n        # Format the result to 6 significant figures\n        results.append(f\"{ratio:.6g}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "3285634"}]}