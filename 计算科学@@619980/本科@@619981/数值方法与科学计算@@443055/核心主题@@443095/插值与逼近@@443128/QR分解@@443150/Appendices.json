{"hands_on_practices": [{"introduction": "QR 分解是数值线性代数的一块基石，而 Gram-Schmidt 正交化是实现这种分解的最直观方法之一。它通过几何概念将一组线性无关的向量转化为一组标准正交向量，从而将原矩阵分解为一个正交矩阵 $Q$ 和一个上三角矩阵 $R$。这个练习将带你亲手操作 Gram-Schmidt 过程，通过具体的计算来分解一个矩阵，从而加深对原矩阵列向量、标准正交向量以及上三角矩阵 $R$ 之间关系的理解 [@problem_id:1385295]。", "problem": "考虑矩阵 $A$ 如下：\n$$A = \\begin{pmatrix} 1  1 \\\\ 2  0 \\\\ 2  -1 \\end{pmatrix}$$\n矩阵 $A$ 的 QR 分解是一种将 $A$ 分解为 $A = QR$ 的形式，其中 $Q$ 是一个具有标准正交列的矩阵，$R$ 是一个上三角矩阵。通过对矩阵 $A$ 的列向量（按从左到右的给定顺序）应用格拉姆-施密特过程，求出 $A$ 的 QR 分解中的矩阵 $R$。该过程必须被标准化，使得矩阵 $R$ 的对角线元素为正。", "solution": "设矩阵 $A$ 的列向量为 $a_{1}$ 和 $a_{2}$，其中\n$$a_{1}=\\begin{pmatrix}1\\\\2\\\\2\\end{pmatrix}, \\quad a_{2}=\\begin{pmatrix}1\\\\0\\\\-1\\end{pmatrix}。$$\n经典的格拉姆-施密特过程如下。\n\n首先，计算 $r_{11}=\\|a_{1}\\|$ 和 $q_{1}=a_{1}/r_{11}$：\n$$\\|a_{1}\\|=\\sqrt{1^{2}+2^{2}+2^{2}}=\\sqrt{9}=3,$$\n$$q_{1}=\\frac{1}{3}\\begin{pmatrix}1\\\\2\\\\2\\end{pmatrix}=\\begin{pmatrix}\\frac{1}{3}\\\\\\frac{2}{3}\\\\\\frac{2}{3}\\end{pmatrix}。$$\n\n接下来，计算 $r_{12}=q_{1}^{T}a_{2}$：\n$$r_{12}=\\begin{pmatrix}\\frac{1}{3}\\frac{2}{3}\\frac{2}{3}\\end{pmatrix}\\begin{pmatrix}1\\\\0\\\\-1\\end{pmatrix}=\\frac{1}{3}-\\frac{2}{3}=-\\frac{1}{3}。$$\n\n构造 $u_{2}=a_{2}-r_{12}q_{1}$，然后计算 $r_{22}=\\|u_{2}\\|$：\n$$u_{2}=a_{2}-\\left(-\\frac{1}{3}\\right)q_{1}=a_{2}+\\frac{1}{3}q_{1}=\\begin{pmatrix}1\\\\0\\\\-1\\end{pmatrix}+\\begin{pmatrix}\\frac{1}{9}\\\\\\frac{2}{9}\\\\\\frac{2}{9}\\end{pmatrix}=\\begin{pmatrix}\\frac{10}{9}\\\\\\frac{2}{9}\\\\-\\frac{7}{9}\\end{pmatrix},$$\n$$\\|u_{2}\\|=\\sqrt{\\left(\\frac{10}{9}\\right)^{2}+\\left(\\frac{2}{9}\\right)^{2}+\\left(-\\frac{7}{9}\\right)^{2}}=\\sqrt{\\frac{100+4+49}{81}}=\\sqrt{\\frac{153}{81}}=\\frac{\\sqrt{17}}{3}。$$\n\n根据对角线元素为正的约定，我们取\n$$r_{11}=3,\\quad r_{12}=-\\frac{1}{3},\\quad r_{22}=\\frac{\\sqrt{17}}{3}。$$\n因此，上三角矩阵 $R$ 为\n$$R=\\begin{pmatrix}3  -\\frac{1}{3}\\\\ 0  \\frac{\\sqrt{17}}{3}\\end{pmatrix}。$$", "answer": "$$\\boxed{\\begin{pmatrix}3  -\\frac{1}{3}\\\\ 0  \\frac{\\sqrt{17}}{3}\\end{pmatrix}}$$", "id": "1385295"}, {"introduction": "虽然 Gram-Schmidt 过程在概念上很清晰，但在实际数值计算中，我们常因其优越的数值稳定性而选用基于 Householder 变换的方法。Householder 变换（或称为 Householder 反射）通过构造一个特定的正交矩阵，能够精确地将一个向量中的部分元素置零。这个练习聚焦于构造单个 Householder 矩阵，这是基于反射的 QR 算法的核心构件。掌握这一关键步骤是理解这些高级算法工作原理的基础 [@problem_id:2195439]。", "problem": "在数值线性代数中，Householder变换是进行矩阵分解（例如QR分解）的一个关键工具。对于一个向量 $x \\in \\mathbb{R}^n$，其Householder矩阵是一个正交矩阵 $H$，由以下公式定义：\n$$H = I - 2 \\frac{vv^T}{v^T v}$$\n其中 $I$ 是单位矩阵，而*Householder向量* $v$ 是根据 $x$ 构造的。为了将 $x$ 中除了第一个分量之外的所有分量都置为零，一个标准且数值稳定的 $v$ 的选择是：\n$$v = x + \\sigma \\|x\\| e_1$$\n这里，$e_1$ 是第一个标准基向量（一个在第一个位置为1，其余位置为0的列向量），$\\|x\\|$ 是 $x$ 的欧几里得范数，并且 $\\sigma = \\text{sign}(x_1)$，其中 $x_1$ 是 $x$ 的第一个分量。符号函数的定义为：如果 $z \\geq 0$，则 $\\text{sign}(z) = 1$；如果 $z  0$，则 $\\text{sign}(z) = -1$。\n\n给定向量 $x = \\begin{pmatrix} 1 \\\\ 2 \\\\ 2 \\end{pmatrix}$，求其对应的Householder矩阵 $H$。请将你的答案表示为一个包含有理数元素的3x3矩阵。", "solution": "给定 $x = \\begin{pmatrix} 1 \\\\ 2 \\\\ 2 \\end{pmatrix}$ 以及Householder构造 $v = x + \\sigma \\|x\\| e_{1}$，其中 $\\sigma = \\text{sign}(x_{1})$。由于 $x_{1} = 1 \\geq 0$，我们有 $\\sigma = 1$。欧几里得范数为\n$$\n\\|x\\| = \\sqrt{x^{T}x} = \\sqrt{1^{2} + 2^{2} + 2^{2}} = \\sqrt{9} = 3.\n$$\n因此，\n$$\nv = x + \\|x\\| e_{1} = \\begin{pmatrix} 1 \\\\ 2 \\\\ 2 \\end{pmatrix} + \\begin{pmatrix} 3 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 4 \\\\ 2 \\\\ 2 \\end{pmatrix}.\n$$\nHouseholder矩阵为\n$$\nH = I - 2\\frac{vv^{T}}{v^{T}v}.\n$$\n计算所需的量：\n$$\nv^{T}v = 4^{2} + 2^{2} + 2^{2} = 16 + 4 + 4 = 24,\n$$\n$$\nvv^{T} = \\begin{pmatrix}\n16  8  8 \\\\\n8  4  4 \\\\\n8  4  4\n\\end{pmatrix}.\n$$\n于是，\n$$\nH = I - \\frac{2}{24} vv^{T} = I - \\frac{1}{12}\\begin{pmatrix}\n16  8  8 \\\\\n8  4  4 \\\\\n8  4  4\n\\end{pmatrix}\n= I - \\begin{pmatrix}\n\\frac{4}{3}  \\frac{2}{3}  \\frac{2}{3} \\\\\n\\frac{2}{3}  \\frac{1}{3}  \\frac{1}{3} \\\\\n\\frac{2}{3}  \\frac{1}{3}  \\frac{1}{3}\n\\end{pmatrix}.\n$$\n从单位矩阵中减去，得到\n$$\nH = \\begin{pmatrix}\n1 - \\frac{4}{3}  -\\frac{2}{3}  -\\frac{2}{3} \\\\\n-\\frac{2}{3}  1 - \\frac{1}{3}  -\\frac{1}{3} \\\\\n-\\frac{2}{3}  -\\frac{1}{3}  1 - \\frac{1}{3}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n-\\frac{1}{3}  -\\frac{2}{3}  -\\frac{2}{3} \\\\\n-\\frac{2}{3}  \\frac{2}{3}  -\\frac{1}{3} \\\\\n-\\frac{2}{3}  -\\frac{1}{3}  \\frac{2}{3}\n\\end{pmatrix}.\n$$\n这个 $H$ 确实满足 $Hx = \\begin{pmatrix} -3 \\\\ 0 \\\\ 0 \\end{pmatrix}$，将除了第一个分量外的所有分量都置零，并且其元素都是所要求的有理数。", "answer": "$$\\boxed{\\begin{pmatrix}-\\frac{1}{3}  -\\frac{2}{3}  -\\frac{2}{3} \\\\ -\\frac{2}{3}  \\frac{2}{3}  -\\frac{1}{3} \\\\ -\\frac{2}{3}  -\\frac{1}{3}  \\frac{2}{3}\\end{pmatrix}}$$", "id": "2195439"}, {"introduction": "我们为什么要学习 QR 分解？它在实际中有什么用？这个练习将从“如何计算”过渡到“为何重要”，展示 QR 分解在解决现实世界问题中的威力。最小二乘法是科学与工程领域无处不在的工具，从数据拟合到统计建模都有它的身影。QR 分解为求解最小二乘问题提供了一种数值上极其稳健的方法，特别是与直接求解正规方程组相比，它能有效避免病态问题。本练习通过一个具体实例——为一组数据点寻找最佳拟合圆——来演示这一强大应用 [@problem_id:3264482]。", "problem": "设计并实现一个完整的程序，该程序使用通过 QR 分解求解的线性最小二乘法，为多组二维数据点计算最佳拟合圆。您的任务是从第一性原理出发：圆的几何定义和最小二乘法的定义。在这些基础上，推导出一个线性系统，其解可以得到圆的参数，然后阐明如何使用 QR 分解来解决这个线性最小二乘问题，而无需构建正规方程。最后，实现该算法。\n\n要求：\n- 为由圆心 $\\left(a,b\\right)$ 和半径 $r$ 定义的、最佳拟合给定点 $\\left(x_i,y_i\\right)$（其中 $i$ 遍历所有可用数据）的圆，推导出一个线性最小二乘公式。您必须解释该公式是如何从圆方程和最小二乘原理中得出的。\n- 使用 QR 分解来解决由此产生的线性最小二乘问题。您必须使用分解 $A = QR$，其中 $Q$ 具有标准正交列，$R$ 是上三角矩阵，然后求解该三角系统以获得参数向量。请勿使用正规方程。\n- 该算法必须在数值上是稳健的且自洽的。\n\n测试套件：\n您必须在以下四个测试用例上运行您的程序。每个测试用例都是一个点列表。所有坐标都是无单位的实数。\n- 案例 $1$（圆上的精确数据）：点 $\\left(4.75,-2.0\\right)$、$\\left(1.5,1.25\\right)$、$\\left(-1.75,-2.0\\right)$、$\\left(1.5,-5.25\\right)$、$\\left(3.798097038,0.298097038\\right)$。\n- 案例 $2$（圆附近的噪声数据）：点 $\\left(5.10,-0.05\\right)$、$\\left(0.05,4.92\\right)$、$\\left(-4.93,0.03\\right)$、$\\left(0.02,-5.04\\right)$、$\\left(3.585,3.515\\right)$、$\\left(-3.595,3.545\\right)$、$\\left(-3.515,-3.565\\right)$、$\\left(3.495,-3.515\\right)$。\n- 案例 $3$（最少的非共线点）：点 $\\left(2.0,1.0\\right)$、$\\left(4.0,5.0\\right)$、$\\left(-1.0,3.0\\right)$。\n- 案例 $4$（近乎共线的点）：点 $\\left(-1.0,-1.01\\right)$、$\\left(0.0,1.0\\right)$、$\\left(1.0,2.99\\right)$、$\\left(2.0,5.02\\right)$、$\\left(1.5,4.01\\right)$。\n\n程序输出规范：\n- 对于每个测试用例，计算最佳拟合圆的参数，并报告从您基于 QR 的最小二乘解中获得的圆心 $\\left(a,b\\right)$ 和半径 $r$。\n- 将 $a$、$b$ 和 $r$ 中的每一个都四舍五入到恰好 $6$ 位小数。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个包含三个浮点数 $\\left[a,b,r\\right]$ 的子列表。例如：$\\left[\\left[a_1,b_1,r_1\\right],\\left[a_2,b_2,r_2\\right],\\left[a_3,b_3,r_3\\right],\\left[a_4,b_4,r_4\\right]\\right]$。\n- 不涉及物理单位。所有输出都是纯实数。\n\n您的最终答案必须是一个完整、可运行的程序，该程序以算法方式执行推导，并以上述确切格式打印所需的单行输出。除了 Python 标准库之外，唯一允许的库是 Numerical Python (NumPy)。", "solution": "该问题要求设计并实现一种算法，为一组给定的二维点找到最佳拟合圆。该方法必须基于从第一性原理推导出的线性最小二乘公式，并使用 QR 分解进行求解。\n\n### 1. 线性最小二乘公式的推导\n\n基本的几何实体是二维笛卡尔平面中的一个圆。圆心坐标为 $(a, b)$、半径为 $r$ 的圆的方程由下式给出：\n$$ (x-a)^2 + (y-b)^2 = r^2 $$\n该方程相对于参数 $a$ 和 $b$ 是非线性的。为了应用线性最小二乘法，我们必须将此方程转换为对一组新参数呈线性的形式。我们可以展开二次项：\n$$ x^2 - 2ax + a^2 + y^2 - 2by + b^2 = r^2 $$\n通过重新排列各项以将未知数与数据 $(x, y)$ 分开，我们得到：\n$$ x^2 + y^2 = 2ax + 2by + (r^2 - a^2 - b^2) $$\n为了线性化这种关系，我们引入一组新的参数 $c_1$、$c_2$ 和 $c_3$，定义如下：\n$$ c_1 = 2a $$\n$$ c_2 = 2b $$\n$$ c_3 = r^2 - a^2 - b^2 $$\n将这些代入重新排列的圆方程，可以得到新参数与数据之间的线性关系：\n$$ c_1 x + c_2 y + c_3 = x^2 + y^2 $$\n这个方程构成了我们线性模型的基础。对于每个数据点 $(x_i, y_i)$，它提供了一个关于未知参数 $c_1$、$c_2$ 和 $c_3$ 的线性方程。\n\n### 2. 构建为线性最小二乘问题\n\n对于一组 $n$ 个数据点 $(x_i, y_i)$（其中 $i=1, 2, \\dots, n$），我们有一个包含 $n$ 个线性方程的系统。通常，如果点存在噪声或者点的数量超过 3 个，将不存在任何一组参数 $(c_1, c_2, c_3)$ 能完美满足所有方程。因此，问题就变成了找到“最佳”拟合数据的参数。\n\n最小二乘原理要求我们最小化残差的平方和。第 $i$ 个点的残差 $e_i$ 是我们推导的线性方程两边之差：\n$$ e_i = (c_1 x_i + c_2 y_i + c_3) - (x_i^2 + y_i^2) $$\n目标是找到参数向量 $\\mathbf{p} = [c_1, c_2, c_3]^T$，以最小化残差平方和 $S$：\n$$ S = \\sum_{i=1}^{n} e_i^2 $$\n这个最小化问题可以用矩阵形式表示。我们寻求找到向量 $\\mathbf{p}$，以最小化残差向量 $\\mathbf{e} = A\\mathbf{p} - \\mathbf{b}$ 的欧几里得范数：\n$$ \\min_{\\mathbf{p}} \\| A\\mathbf{p} - \\mathbf{b} \\|_2^2 $$\n矩阵 $A$ 和向量 $\\mathbf{b}$ 由数据点构造如下：\n$$\nA = \\begin{pmatrix}\nx_1  y_1  1 \\\\\nx_2  y_2  1 \\\\\n\\vdots  \\vdots  \\vdots \\\\\nx_n  y_n  1\n\\end{pmatrix},\n\\quad \\mathbf{p} = \\begin{pmatrix} c_1 \\\\ c_2 \\\\ c_3 \\end{pmatrix},\n\\quad \\mathbf{b} = \\begin{pmatrix}\nx_1^2 + y_1^2 \\\\\nx_2^2 + y_2^2 \\\\\n\\vdots \\\\\nx_n^2 + y_n^2\n\\end{pmatrix}\n$$\n其中，$A$ 是一个 $n \\times 3$ 矩阵，$\\mathbf{p}$ 是一个 $3 \\times 1$ 的未知数向量，而 $\\mathbf{b}$ 是一个 $n \\times 1$ 向量。\n\n### 3. 通过 QR 分解求解\n\n问题陈述要求使用 QR 分解来解决这个线性最小二乘问题，并明确避免构建正规方程 $A^T A \\mathbf{p} = A^T \\mathbf{b}$。这种方法在数值上更为优越，特别是当矩阵 $A$ 是病态的（例如对于近乎共线的点）时。构建 $A^T A$ 会使矩阵的条件数平方，可能导致精度的严重损失。\n\n算法流程如下：\n1.  **分解**：我们计算 $n \\times 3$ 矩阵 $A$ 的“瘦”或“简化”QR 分解，使得 $A = QR$。在这种分解中，$Q$ 是一个具有标准正交列的 $n \\times 3$ 矩阵（$Q^T Q = I$，其中 $I$ 是 $3 \\times 3$ 的单位矩阵），而 $R$ 是一个 $3 \\times 3$ 的上三角矩阵。\n\n2.  **系统变换**：我们将 $A = QR$ 代入最小化目标：\n    $$ \\| A\\mathbf{p} - \\mathbf{b} \\|_2^2 = \\| QR\\mathbf{p} - \\mathbf{b} \\|_2^2 $$\n    由于 $Q$ 具有标准正交列，左乘 $Q^T$ 会将一个向量投影到 $A$ 的列空间上。最小二乘解是通过将残差向量 $A\\mathbf{p} - \\mathbf{b}$ 设置为与 $A$ 的列空间正交来找到的。这导出了方程 $A^T (A\\mathbf{p} - \\mathbf{b}) = 0$。代入 $A=QR$：\n    $$ (QR)^T (QR\\mathbf{p} - \\mathbf{b}) = 0 $$\n    $$ R^T Q^T (QR\\mathbf{p} - \\mathbf{b}) = 0 $$\n    $$ R^T (Q^T Q R \\mathbf{p} - Q^T \\mathbf{b}) = 0 $$\n    由于 $Q^T Q = I$ 并且 $R$ 是可逆的（对于满秩矩阵 $A$），我们可以将其简化为：\n    $$ R \\mathbf{p} = Q^T \\mathbf{b} $$\n\n3.  **求解系统**：方程 $R\\mathbf{p} = Q^T\\mathbf{b}$ 表示一个方形（$3 \\times 3$）线性系统。因为 $R$ 是上三角矩阵，所以可以使用回代法高效且准确地求解参数向量 $\\mathbf{p}$。\n\n### 4. 恢复几何圆参数\n\n一旦找到最小二乘解 $\\mathbf{p} = [c_1, c_2, c_3]^T$，我们必须将这些中间参数转换回具有物理意义的几何圆参数：圆心 $(a, b)$ 和半径 $r$。使用步骤 1 中的定义：\n-   圆心 $x$ 坐标：$a = \\frac{c_1}{2}$\n-   圆心 $y$ 坐标：$b = \\frac{c_2}{2}$\n-   半径：从 $c_3 = r^2 - a^2 - b^2$，我们求解 $r$：\n    $$ r^2 = c_3 + a^2 + b^2 $$\n    $$ r = \\sqrt{c_3 + a^2 + b^2} $$\n半径 $r$ 必须是一个正实数，这要求 $c_3 + a^2 + b^2 > 0$。对于任何一组非共线的输入点，这个条件都成立。\n\n因此，完整的算法如下：\n1.  给定 $n$ 个点 $(x_i, y_i)$，构建 $n \\times 3$ 矩阵 $A$ 和 $n \\times 1$ 向量 $\\mathbf{b}$。\n2.  计算简化 QR 分解 $A=QR$。\n3.  计算向量 $\\mathbf{c}' = Q^T\\mathbf{b}$。\n4.  求解上三角系统 $R\\mathbf{p} = \\mathbf{c}'$ 以得到 $\\mathbf{p} = [c_1, c_2, c_3]^T$。\n5.  计算圆的参数：$a = c_1/2$、$b = c_2/2$ 和 $r = \\sqrt{c_3 + a^2 + b^2}$。\n此过程得出的圆参数，是在代数最小二乘意义上对给定数据的最佳拟合。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the best-fit circle for several sets of 2D data points using\n    linear least squares solved via QR factorization.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (exact data on a circle)\n        np.array([\n            (4.75, -2.0), (1.5, 1.25), (-1.75, -2.0),\n            (1.5, -5.25), (3.798097038, 0.298097038)\n        ]),\n        # Case 2 (noisy data near a circle)\n        np.array([\n            (5.10, -0.05), (0.05, 4.92), (-4.93, 0.03),\n            (0.02, -5.04), (3.585, 3.515), (-3.595, 3.545),\n            (-3.515, -3.565), (3.495, -3.515)\n        ]),\n        # Case 3 (minimal non-collinear points)\n        np.array([\n            (2.0, 1.0), (4.0, 5.0), (-1.0, 3.0)\n        ]),\n        # Case 4 (nearly collinear points)\n        np.array([\n            (-1.0, -1.01), (0.0, 1.0), (1.0, 2.99),\n            (2.0, 5.02), (1.5, 4.01)\n        ])\n    ]\n\n    results = []\n    for points in test_cases:\n        # Extract x and y coordinates\n        x = points[:, 0]\n        y = points[:, 1]\n\n        # 1. Construct the matrix A and vector b for the linear system A*p = b\n        # The system is derived from c1*x + c2*y + c3 = x^2 + y^2\n        A = np.vstack([x, y, np.ones(len(x))]).T\n        b = x**2 + y**2\n\n        # 2. Compute the reduced QR factorization of A\n        # A = QR, where Q is n x 3 with orthonormal columns and R is 3 x 3 upper triangular\n        Q, R = np.linalg.qr(A)\n\n        # 3. Solve the system R*p = Q.T * b for the parameter vector p = [c1, c2, c3]\n        # This is the solution to the least squares problem min||A*p - b||^2\n        qt_b = Q.T @ b\n        p = np.linalg.solve(R, qt_b)\n        \n        c1, c2, c3 = p[0], p[1], p[2]\n\n        # 4. Recover the geometric circle parameters (a, b, r) from the algebraic parameters\n        # c1 = 2a  => a = c1 / 2\n        # c2 = 2b  => b = c2 / 2\n        # c3 = r^2 - a^2 - b^2 => r = sqrt(c3 + a^2 + b^2)\n        a = c1 / 2.0\n        b = c2 / 2.0\n        r = np.sqrt(c3 + a**2 + b**2)\n\n        # Round the results to 6 decimal places as required\n        a_r = round(a, 6)\n        b_r = round(b, 6)\n        r_r = round(r, 6)\n        \n        results.append([a_r, b_r, r_r])\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists is converted to a string\n    # and spaces are removed to match the specified format \"[[a1,b1,r1],[a2,b2,r2],...]\".\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3264482"}]}