{"hands_on_practices": [{"introduction": "复合数值积分方法的收敛阶数理论，如辛普森法则的 $O(h^4)$，通常依赖于被积函数的足够光滑性。本练习将探讨当此假设不成立时（例如，处理一个带有“尖点”的函数）会发生什么，并引导你通过分割积分区间这一直接策略来恢复高精度。这个实践揭示了在应用数值方法前，分析函数特性的重要性。[@problem_id:3214983]", "problem": "考虑区间 $\\left[0,1\\right]$ 上的函数 $f(x)=\\lvert x-0.5 \\rvert$。$f(x)$ 的导数在 $x=0.5$ 处存在一个不连续点，这对那些误差分析假设函数具有足够光滑性的求积法则构成了挑战。从数值求积通过对子区间上的被积函数的低阶多项式插值进行积分来近似定积分的基本定义出发，设计并实现复合牛顿-柯特斯（Newton–Cotes）求积法则，并分析它们在这种非光滑函数上的行为。\n\n您必须实现以下三种方法：\n\n1.  复合梯形法则，严格基于在 $\\left[0,1\\right]$ 上的 $N$ 个均匀子区间上对 1 次插值（分段线性）进行积分。\n\n2.  复合辛普森（Simpson）法则，基于在 $\\left[0,1\\right]$ 的一个均匀划分为 $N$ 个子区间上对 2 次插值（分段二次）进行积分，要求 $N$ 为偶数，以便该法则以每两个子区间为一组的方式应用。\n\n3.  分段复合辛普森法则，首先在 $c=0.5$ 处将 $\\left[0,1\\right]$ 分割为 $\\left[0,0.5\\right]$ 和 $\\left[0.5,1\\right]$，然后对每个子区间分别应用复合辛普森法则。为确保辛普森组合的有效性，您必须为每半个区间分配偶数个子区间，且总数（在可能的情况下）需等于原始的 $N$。具体而言：\n    *   如果 $N$ 是奇数，则分段复合辛普森法则不适用。\n    *   如果 $N$ 是偶数且能被 4 整除，则使用 $N_{\\text{left}}=N/2$ 和 $N_{\\text{right}}=N/2$。\n    *   如果 $N$ 是偶数但不能被 4 整除，则选择 $N_{\\text{left}}=N/2-1$ 和 $N_{\\text{right}}=N/2+1$。\n    *   如果 $N_{\\text{left}}$ 或 $N_{\\text{right}}$ 为非正数，则分段复合辛普森法则不适用。\n\n对于误差评估，使用定积分的核心微积分定义和绝对值的性质，推导出积分 $\\int_{0}^{1} \\lvert x-0.5 \\rvert \\, dx$ 的精确值，并使用此精确值计算绝对误差。对于任何方法和任何 $N$，将绝对误差定义为\n$$\nE_N = \\left\\lvert Q_N - I \\right\\rvert,\n$$\n其中 $Q_N$ 是使用 $N$ 个子区间的数值求积结果，$I$ 是精确积分值。\n\n对于经验收敛性分析，对每种方法和每对 $(N,2N)$，定义经验阶\n$$\np = \\frac{\\log\\left(E_N / E_{2N}\\right)}{\\log(2)}.\n$$\n如果某种方法对于给定的 $N$ 不适用，或者如果 $E_N$ 或 $E_{2N}$ 在数值上与 $0$ 无法区分（使用阈值 $10^{-15}$），则报告经验阶为哨兵值 $-1.0$。\n\n您的程序必须为下面的每个测试用例计算一个包含九个浮点数的列表，顺序如下：\n- 复合梯形法则的 $E_N$，\n- 复合梯形法则的 $E_{2N}$，\n- 复合梯形法则的 $p$，\n- 全区间上复合辛普森法则的 $E_N$，\n- 全区间上复合辛普森法则的 $E_{2N}$，\n- 全区间上复合辛普森法则的 $p$，\n- 分段复合辛普森法则的 $E_N$，\n- 分段复合辛普森法则的 $E_{2N}$，\n- 分段复合辛普森法则的 $p$。\n\n如果某种方法对于给定的 $N$ 不适用，则对相应的误差或阶使用 $-1.0$。此问题不涉及角度；因此，无需指定角度单位。不涉及物理单位。\n\n测试套件：\n为以下 $(N,2N)$ 对计算上述输出：\n- $(2,4)$，\n- $(4,8)$，\n- $(6,12)$，\n- $(5,10)$，\n- $(8,16)$。\n\n这些案例涵盖了粗分辨率、 $x=0.5$ 与辛普森组合边界重合的情况、 $x=0.5$ 位于辛普森组合内部的情况，以及一个奇数 $N$ 的情况，此时基于辛普森的法则在 $N$ 时不适用。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个以逗号分隔的、由各测试用例列表组成的列表，无空格，并用方括号括起来。例如，最终输出应如下所示：\n`[ [case 1 的九个数字],[case 2 的九个数字],… ]`，\n使用您的程序计算出的确切数值替换占位符。", "solution": "此问题是有效的。它提出了一个定义明确的数值分析任务，基于数值求积的既定原则。函数、区间、方法和评估标准都以足够的精度指定，并且在科学上是合理的。该问题是展示被积函数光滑性如何影响数值积分方案收敛速度的经典范例。\n\n### 1. 精确积分计算\n\n积分的精确值 $I = \\int_{0}^{1} \\lvert x-0.5 \\rvert \\, dx$ 是误差计算的参考基准。绝对值函数是分段定义的。我们在绝对值参数变号的点 $x=0.5$ 处分割积分。\n\n$$\nI = \\int_{0}^{1} \\lvert x-0.5 \\rvert \\, dx = \\int_{0}^{0.5} -(x-0.5) \\, dx + \\int_{0.5}^{1} (x-0.5) \\, dx\n$$\n\n$$\nI = \\int_{0}^{0.5} (0.5-x) \\, dx + \\int_{0.5}^{1} (x-0.5) \\, dx\n$$\n\n计算这两个定积分：\n$$\n\\int_{0}^{0.5} (0.5-x) \\, dx = \\left[ 0.5x - \\frac{x^2}{2} \\right]_{0}^{0.5} = \\left( 0.5(0.5) - \\frac{(0.5)^2}{2} \\right) - (0) = 0.25 - \\frac{0.25}{2} = 0.125\n$$\n\n$$\n\\int_{0.5}^{1} (x-0.5) \\, dx = \\left[ \\frac{x^2}{2} - 0.5x \\right]_{0.5}^{1} = \\left( \\frac{1^2}{2} - 0.5(1) \\right) - \\left( \\frac{(0.5)^2}{2} - 0.5(0.5) \\right) = (0.5 - 0.5) - (0.125 - 0.25) = 0 - (-0.125) = 0.125\n$$\n\n积分的精确值是这两部分之和：\n$$\nI = 0.125 + 0.125 = 0.25\n$$\n从几何上看，这代表了两个相同的直角三角形的面积，每个三角形的底为 $0.5$，高为 $0.5$。面积为 $2 \\times \\frac{1}{2} \\times 0.5 \\times 0.5 = 0.25$。\n\n### 2. 数值求积方法\n\n设区间为 $[a, b]$，划分为 $N$ 个宽度为 $h = (b-a)/N$ 的均匀子区间。节点为 $x_i = a + i h$，其中 $i=0, 1, \\ldots, N$。被积函数为 $f(x) = \\lvert x-0.5 \\rvert$。\n\n#### 2.1. 复合梯形法则\n该法则通过对每个子区间 $[x_i, x_{i+1}]$ 上的线性插值形成的梯形面积求和来近似积分。公式为：\n$$\nQ_N^{\\text{trap}} = h \\left( \\frac{f(x_0) + f(x_N)}{2} + \\sum_{i=1}^{N-1} f(x_i) \\right)\n$$\n假设被积函数是二次连续可微的 ($f \\in C^2$)，梯形法则的标准误差为 $O(h^2)$ 阶。我们的函数 $f(x)$ 仅在 $C^0$ 中，其一阶导数有跳跃不连续性。然而，梯形法则对线性函数是精确的。当 $N$ 是偶数时，其中一个网格点 $x_{N/2}$ 将与不连续点 $x=0.5$ 重合。由于 $f(x)$ 在 $[0, 0.5]$ 和 $[0.5, 1]$ 上是线性的，并且节点关于 $x=0.5$ 对称，梯形法则将精确地求得分段线性段的面积总和。因此，对于任何偶数 $N$，数值结果将是精确的，误差 $E_N$ 将为 $0$。对于奇数 $N$，$x=0.5$ 位于一个子区间内，预计会产生非零误差。\n\n#### 2.2. 复合辛普森法则\n该法则对成对的子区间（板块）上的分段二次插值进行积分。它要求子区间数 $N$ 为偶数。公式为：\n$$\nQ_N^{\\text{simp}} = \\frac{h}{3} \\left( f(x_0) + 4\\sum_{i=1, i \\text{ odd}}^{N-1} f(x_i) + 2\\sum_{i=2, i \\text{ even}}^{N-2} f(x_i) + f(x_N) \\right)\n$$\n假设 $f \\in C^4$，标准误差为 $O(h^4)$。由于我们的函数不光滑，这个收敛率无法达到。辛普森法则对最高三次的多项式是精确的。关键因素在于不连续点 $x=0.5$ 是落在板块边界上还是板块内部。对于 $N$ 个子区间，有 $N/2$ 个板块 $[x_{2k}, x_{2k+2}]$。如果 $x=0.5$ 是某个整数 $k$ 的节点 $x_{2k}$，则不连续点位于板块边界上。这在 $N$ 是 4 的倍数时发生。在这种情况下，函数在每个板块内（例如，在 $[0, 0.5]$ 和 $[0.5, 1]$ 上）是线性的，并且由于辛普森法则对线性函数是精确的，每半部分的积分都是精确的，从而总误差为 $0$。如果 $N$ 是偶数但不是 4 的倍数（例如，$N=2, 6, 10, \\dots$），则点 $x=0.5$ 落在某个板块内部，二次插值无法捕捉到“拐点”，导致显著误差。在这种情况下，收敛率会降至 $O(h^2)$。\n\n#### 2.3. 分段复合辛普森法则\n这种自适应策略明确地处理了不连续性。定义域 $[0, 1]$ 被分割为 $[0, 0.5]$ 和 $[0.5, 1]$。然后对每个子域分别应用复合辛普森法则。\n$$\nQ_N^{\\text{split}} = Q_{N_{\\text{left}}}^{\\text{simp}}(f, [0, 0.5]) + Q_{N_{\\text{right}}}^{\\text{simp}}(f, [0.5, 1])\n$$\n根据问题的规则，将总区间数 $N$ 划分为 $N_{\\text{left}}$ 和 $N_{\\text{right}}$，确保两者都为偶数和正数。在每个子域 $[0, 0.5]$ 和 $[0.5, 1]$ 内，函数 $f(x)$ 是一个简单的线性函数。由于辛普森法则对最高三次多项式提供精确结果，它对这些线性段也将是精确的。因此，只要该方法适用，$Q_N^{\\text{split}}$ 将等于精确积分 $I$，误差 $E_N$ 将为 $0$。该方法不适用于奇数 $N$ 或 $N=2$（根据指定的划分规则，$N_{\\text{left}}$ 将变为非正数）。\n\n### 3. 误差和收敛性分析\n\n绝对误差为 $E_N = \\lvert Q_N - I \\rvert$。经验收敛阶 $p$ 使用两种分辨率 $N$ 和 $2N$ 的误差计算：\n$$\np = \\frac{\\log(E_N / E_{2N})}{\\log(2)}\n$$\n此公式估计了误差关系 $E_N \\approx C h^p \\propto C (1/N)^p$ 中的指数。如果 $E_N$ 或 $E_{2N}$ 在数值上为零（低于 $10^{-15}$ 的阈值），或者如果方法对于给定的 $N$ 不适用，则将经验阶 $p$ 赋为哨兵值 $-1.0$。\n\n### 4. 算法实现\n\n该解决方案用 Python 实现。\n1.  定义函数 $f(x)$ 和精确积分值 $I=0.25$。\n2.  实现三个独立的函数：`composite_trapezoidal`、`composite_simpson` 和 `split_composite_simpson`。每个函数都接受被积函数、积分上下限和子区间数 $N$ 作为输入。如果方法的先决条件未满足（例如，辛普森法则的 $N$ 为奇数），它们将返回数值积分或一个哨兵值（例如 $-1.0$）。\n3.  `split_composite_simpson` 函数封装了将 $N$ 划分为 $N_{\\text{left}}$ 和 $N_{\\text{right}}$ 的特定逻辑，并在两个子域上调用 `composite_simpson` 函数。\n4.  一个辅助函数计算经验阶 $p$，处理返回哨兵值 $-1.0$ 的指定条件。\n5.  程序的主体部分遍历测试用例 $(N, 2N)$ 的列表。对于每个用例，它计算所需的九个值：三种方法各自的 $(E_N, E_{2N}, p)$。\n6.  结果被存储并格式化为列表的列表形式的最终字符串。低于 $10^{-15}$ 阈值的误差在报告时被视为 $0.0$，但会触发 $p=-1.0$ 的条件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical integration problem for f(x) = |x - 0.5| on [0, 1].\n    \"\"\"\n    \n    # Define the function, its exact integral, and the zero threshold.\n    f = lambda x: np.abs(x - 0.5)\n    I_EXACT = 0.25\n    ZERO_THRESHOLD = 1e-15\n\n    def composite_trapezoidal(func, a, b, N):\n        \"\"\"Computes the integral using the composite trapezoidal rule.\"\"\"\n        if N == 0:\n            return np.nan  # Invalid input\n        h = (b - a) / N\n        x = np.linspace(a, b, N + 1)\n        y = func(x)\n        integral = h * (np.sum(y) - 0.5 * (y[0] + y[-1]))\n        return integral\n\n    def composite_simpson(func, a, b, N):\n        \"\"\"Computes the integral using the composite Simpson's rule.\"\"\"\n        if N == 0 or N % 2 != 0:\n            return -1.0  # Sentinel for non-applicability\n        h = (b - a) / N\n        x = np.linspace(a, b, N + 1)\n        y = func(x)\n        # Sum of terms with odd indices (y_1, y_3, ...)\n        s1 = np.sum(y[1:-1:2])\n        # Sum of terms with even indices (y_2, y_4, ...)\n        s2 = np.sum(y[2:-2:2])\n        integral = (h / 3.0) * (y[0] + 4.0 * s1 + 2.0 * s2 + y[-1])\n        return integral\n\n    def split_composite_simpson(func, a, b, c, N):\n        \"\"\"Computes the integral using the split-composite Simpson's rule.\"\"\"\n        if N % 2 != 0:\n            return -1.0\n        \n        if N % 4 == 0:\n            N_left = N // 2\n            N_right = N // 2\n        else: # N is even but not divisible by 4\n            N_left = N // 2 - 1\n            N_right = N // 2 + 1\n\n        if N_left = 0 or N_right = 0:\n            return -1.0\n            \n        I_left = composite_simpson(func, a, c, N_left)\n        I_right = composite_simpson(func, c, b, N_right)\n        \n        # This check is redundant given N_left/right logic but kept for robustness\n        if I_left == -1.0 or I_right == -1.0:\n            return -1.0\n            \n        return I_left + I_right\n\n    def calculate_p(E_N, E_2N):\n        \"\"\"Calculates the empirical order of convergence.\"\"\"\n        if E_N == -1.0 or E_2N == -1.0:\n            return -1.0\n        if E_N  ZERO_THRESHOLD or E_2N  ZERO_THRESHOLD:\n            return -1.0\n        return np.log(E_N / E_2N) / np.log(2.0)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (2, 4),\n        (4, 8),\n        (6, 12),\n        (5, 10),\n        (8, 16)\n    ]\n\n    all_results = []\n    for N, N2 in test_cases:\n        case_results = []\n\n        # 1. Composite Trapezoidal Rule\n        Q_trap_N = composite_trapezoidal(f, 0.0, 1.0, N)\n        E_trap_N = np.abs(Q_trap_N - I_EXACT)\n        \n        Q_trap_N2 = composite_trapezoidal(f, 0.0, 1.0, N2)\n        E_trap_N2 = np.abs(Q_trap_N2 - I_EXACT)\n        \n        p_trap = calculate_p(E_trap_N, E_trap_N2)\n        case_results.extend([E_trap_N, E_trap_N2, p_trap])\n\n        # 2. Composite Simpson Rule\n        Q_simp_N = composite_simpson(f, 0.0, 1.0, N)\n        E_simp_N = -1.0 if Q_simp_N == -1.0 else np.abs(Q_simp_N - I_EXACT)\n        \n        Q_simp_N2 = composite_simpson(f, 0.0, 1.0, N2)\n        E_simp_N2 = -1.0 if Q_simp_N2 == -1.0 else np.abs(Q_simp_N2 - I_EXACT)\n        \n        p_simp = calculate_p(E_simp_N, E_simp_N2)\n        case_results.extend([E_simp_N, E_simp_N2, p_simp])\n\n        # 3. Split-Composite Simpson Rule\n        Q_split_N = split_composite_simpson(f, 0.0, 1.0, 0.5, N)\n        E_split_N = -1.0 if Q_split_N == -1.0 else np.abs(Q_split_N - I_EXACT)\n\n        Q_split_N2 = split_composite_simpson(f, 0.0, 1.0, 0.5, N2)\n        E_split_N2 = -1.0 if Q_split_N2 == -1.0 else np.abs(Q_split_N2 - I_EXACT)\n        \n        p_split = calculate_p(E_split_N, E_split_N2)\n        case_results.extend([E_split_N, E_split_N2, p_split])\n        \n        # Clean up near-zero errors for reporting\n        cleaned_results = [val if abs(val) > ZERO_THRESHOLD else 0.0 for val in case_results]\n        # Restore sentinel values\n        for i, val in enumerate(case_results):\n            if val == -1.0:\n                cleaned_results[i] = -1.0\n\n        all_results.append(cleaned_results)\n\n    # Final print statement in the exact required format.\n    formatted_output = '[' + ','.join([f'[{\",\".join(map(str, case))}]' for case in all_results]) + ']'\n    print(formatted_output)\n\nsolve()\n```", "id": "3214983"}, {"introduction": "在科学与工程计算中，我们常会遇到在积分端点处函数值趋于无穷的瑕积分（或称反常积分）。直接套用标准的数值积分公式通常会失败，因为它们需要在端点处求值。本练习将向你展示一种强大的技巧——变量替换，它能够“正则化”被积函数，将其转化为一个在整个积分区间上表现良好的新函数，从而使其能被数值方法有效处理。[@problem_id:3214941]", "problem": "考虑在有限区间上的幂律奇异被积函数的反常积分，其由黎曼积分定义为 $$I=\\int_{0}^{1} x^{-0.3}\\,dx.$$ 被积函数在左端点发散，这使得直接使用需要在端点求值的复合数值积分公式变得复杂。通过变量替换可以使端点行为正则化。令 $$x=t^{k},$$ 其中 $$k0,$$ 并应用链式法则将积分用新变量 $$t\\in[0,1]$$ 表示。确定以 $$t$$ 和 $$k$$ 表示的变换后被积函数，并确定在何种关于 $$k$$ 的条件下，变换后的被积函数在 $$t=0$$ 处连续且在闭区间 $$[0,1]$$ 上有界。\n\n从黎曼积分的定义和通过多项式插值构建的 Newton–Cotes 公理出发，设计并实现复合辛普森法则，以在 $$t$$-域上近似变换后的积分。使用具有偶数个子区间 $$N$$ 的均匀划分，步长为 $$h=(b-a)/N$$。确保算法在两个端点和内部节点处都对变换后的被积函数求值。如果 $$k$$ 的正则性条件不满足（因此变换后的被积函数在 $$t=0$$ 处发散），则通过将下限 $$0$$ 替换为 $$a=10^{-8}$$ 来进行截断，并在 $$[a,1]$$ 上应用复合辛普森法则。\n\n使用微积分基本定理求得 $$I$$ 的精确解析值，并报告每个数值近似值与此精确值之间的绝对误差，作为每个测试用例的最终标量输出。不涉及角度，也没有物理单位；将数值结果报告为十进制浮点数。\n\n您的实现必须为以下测试套件产生结果，该套件涵盖了一个边界情况（精确正则化阈值）、典型的正则化情况以及一个需要截断的非正则化情况：\n\n- 测试用例 1：$$k=\\frac{10}{7},\\ N=2.$$\n- 测试用例 2：$$k=1.5,\\ N=20.$$\n- 测试用例 3：$$k=2.0,\\ N=20.$$\n- 测试用例 4：$$k=1.2,\\ N=200.$$ （此情况不满足正则性条件，因此必须使用 $$a=10^{-8}$$ 进行截断。）\n- 测试用例 5：$$k=3.0,\\ N=10.$$\n\n您的程序必须计算并打印一行，其中包含所有五个测试用例的绝对误差列表，格式为方括号括起来的逗号分隔列表，每个数字四舍五入到十二位有效数字。例如，一个有效的输出格式为 $$[e_{1},e_{2},e_{3},e_{4},e_{5}],$$ 其中每个 $$e_{i}$$ 是第 $$i$$-个测试用例绝对误差的十进制表示。", "solution": "该问题要求对反常积分进行分析和数值近似\n$$I = \\int_{0}^{1} x^{-0.3}\\,dx.$$\n分析过程包括将积分变换为正则形式，确定此正则化的条件，并实现一个数值积分方案（复合辛普森法则）来近似该积分。数值结果将与精确的解析值进行比较。\n\n### 步骤 1：积分的解析评估\n\n该积分为反常积分，因为被积函数 $f(x) = x^{-0.3}$ 在积分下限 $x=0$ 处有一条垂直渐近线。然而，由于指数 $-0.3$ 大于 $-1$，该积分是收敛的。我们可以使用微积分基本定理求得其精确值。\n$$I = \\int_{0}^{1} x^{-0.3}\\,dx = \\lim_{a \\to 0^+} \\int_{a}^{1} x^{-0.3}\\,dx$$\n$x^{-0.3}$ 的原函数是 $\\frac{x^{-0.3+1}}{-0.3+1} = \\frac{x^{0.7}}{0.7}$。\n计算定积分：\n$$I = \\lim_{a \\to 0^+} \\left[ \\frac{x^{0.7}}{0.7} \\right]_{a}^{1} = \\lim_{a \\to 0^+} \\left( \\frac{1^{0.7}}{0.7} - \\frac{a^{0.7}}{0.7} \\right)$$\n因为 $0.7  0$, $\\lim_{a \\to 0^+} a^{0.7} = 0$。因此，\n$$I = \\frac{1}{0.7} - 0 = \\frac{10}{7}。$$\n该积分的精确解析值为 $I_{\\text{exact}} = \\frac{10}{7}$。\n\n### 步骤 2：变量替换与正则化\n\n为了在数值上处理 $x=0$ 处的奇点，我们应用变量替换 $x = t^k$，其中 $k  0$。\n微分是 $dx = k t^{k-1} dt$。\n$t$ 的积分限通过变换 $x$ 的积分限得到：\n- 当 $x=0$ 时, $t^k=0 \\implies t=0$。\n- 当 $x=1$ 时, $t^k=1 \\implies t=1$。\n$t$ 的积分区间仍为 $[0, 1]$。\n\n将 $x$ 和 $dx$ 代入积分，我们得到以 $t$ 表示的变换后的积分：\n$$I = \\int_{0}^{1} (t^k)^{-0.3} (k t^{k-1}) dt$$\n变换后的被积函数，我们称之为 $g(t, k)$，是：\n$$g(t, k) = t^{-0.3k} \\cdot k t^{k-1} = k t^{k-1-0.3k} = k t^{0.7k-1}$$\n积分现在表示为：\n$$I = \\int_{0}^{1} k t^{0.7k-1} dt$$\n\n### 步骤 3：正则性条件\n\n变换的目的是为了得到一个在闭区间 $[0, 1]$ 上连续且有界的被积函数 $g(t, k)$。潜在的问题点在 $t=0$。当 $t \\to 0^+$ 时，$g(t,k)$ 的行为取决于指数 $p = 0.7k-1$ 的符号。\n1.  如果 $p  0$：当 $t \\to 0^+$ 时，$t^p$ 项趋近于无穷大。被积函数在 $t=0$ 处是奇异的。\n2.  如果 $p = 0$：$g(t, k) = k t^0 = k$，它是一个常数，因此对所有 $t$ 都是有界且连续的。\n3.  如果 $p  0$：当 $t \\to 0^+$ 时，$t^p$ 项趋近于 $0$。被积函数是连续的，并且在 $t=0$ 处的值为 $0$。\n\n为了使变换后的被积函数在闭区间 $[0, 1]$ 上连续且有界，其指数必须为非负。这导出了正则性条件：\n$$0.7k - 1 \\geq 0$$\n$$0.7k \\geq 1$$\n$$k \\geq \\frac{1}{0.7} \\implies k \\geq \\frac{10}{7}$$\n\n如果这个条件不满足（即 $k  10/7$），变换后的被积函数 $g(t, k)$ 在 $t=0$ 处仍然是奇异的，问题指定积分域应被截断为 $[10^{-8}, 1]$。\n\n### 步骤 4：使用复合辛普森法则进行数值近似\n\n复合辛普森法则用于近似积分 $\\int_a^b f(t) dt$。区间 $[a, b]$ 被划分为 $N$ 个偶数个子区间，每个子区间的宽度为 $h = (b-a)/N$。节点为 $t_i = a + ih$，其中 $i=0, 1, \\dots, N$。公式为：\n$$S_N = \\frac{h}{3} \\left[ f(t_0) + 4\\sum_{i=1}^{N/2} f(t_{2i-1}) + 2\\sum_{i=1}^{N/2-1} f(t_{2i}) + f(t_N) \\right]$$\n\n每个测试用例 $(k, N)$ 的算法如下：\n1.  设置精确值 $I_{\\text{exact}} = 10/7$。\n2.  定义变换后的被积函数 $g(t, k) = k t^{0.7k-1}$。\n3.  检查正则性条件。\n    - 如果 $k \\geq 10/7$：积分为正则。积分区间为 $[a, b] = [0, 1]$。计算 $g(t, k)$ 在此区间上的数值近似值 $I_{\\text{approx}} = S_N$。\n    - 如果 $k  10/7$：被积函数是奇异的。积分区间被截断为 $[a, b] = [10^{-8}, 1]$。计算 $g(t, k)$ 在此截断区间上的 $I_{\\text{approx}} = S_N$。\n4.  计算绝对误差：$E = |I_{\\text{approx}} - I_{\\text{exact}}|$。\n\n此过程应用于所提供的五个测试用例中的每一个。对于 $k=10/7$ 的情况，被积函数是常数函数 $g(t) = 10/7$。辛普森法则对于次数最高为 3 的多项式是精确的，因此它对于常数函数也是精确的，产生的绝对误差为 0。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical integration problem for a set of test cases.\n    The solution involves a change of variables to regularize a singular integral,\n    followed by approximation using composite Simpson's rule. The absolute error\n    of the approximation is calculated against the exact analytic value.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (10.0/7.0, 2),    # Case 1: k at regularization threshold\n        (1.5, 20),        # Case 2: Regularized case\n        (2.0, 20),        # Case 3: Regularized case\n        (1.2, 200),       # Case 4: Non-regularized, requires truncation\n        (3.0, 10),        # Case 5: Regularized case\n    ]\n\n    # The exact value of the integral I = integral(x^-0.3, dx, 0, 1) is 10/7.\n    i_exact = 10.0 / 7.0\n\n    # The critical value of k for regularization.\n    k_critical = 10.0 / 7.0\n\n    results = []\n\n    def composite_simpson(f, a, b, N):\n        \"\"\"\n        Calculates the definite integral of a function f from a to b\n        using composite Simpson's rule with N subintervals.\n        N must be an even integer.\n        \"\"\"\n        if N % 2 != 0:\n            raise ValueError(\"Number of subintervals N must be even.\")\n        \n        h = (b - a) / N\n        t_nodes = np.linspace(a, b, N + 1)\n        y_nodes = f(t_nodes)\n\n        # Simpson's rule formula:\n        # h/3 * [y_0 + 4*y_1 + 2*y_2 + ... + 2*y_{N-2} + 4*y_{N-1} + y_N]\n        integral = (h / 3.0) * (\n            y_nodes[0] + \n            y_nodes[-1] + \n            4.0 * np.sum(y_nodes[1:-1:2]) + \n            2.0 * np.sum(y_nodes[2:-2:2])\n        )\n        return integral\n\n    for k, N in test_cases:\n        # The exponent in the transformed integrand g(t) = k*t^p\n        p = 0.7 * k - 1.0\n\n        # Create the transformed integrand function.\n        # Numpy handles powers of 0 correctly:\n        # 0**p = 0 for p > 0\n        # 0**0 = 1\n        # t is never 0 for p  0 due to truncation.\n        g = lambda t: k * t**p\n\n        # Determine integration interval based on regularity condition.\n        if k >= k_critical:\n            # Regular case: integrate over [0, 1]\n            a, b = 0.0, 1.0\n        else:\n            # Singular case: integrate over truncated interval [1e-8, 1]\n            a, b = 1e-8, 1.0\n        \n        # Approximate the integral using composite Simpson's rule\n        i_approx = composite_simpson(g, a, b, N)\n        \n        # Calculate the absolute error against the true value of the original integral\n        error = np.abs(i_approx - i_exact)\n        results.append(error)\n\n    # Format the results to 12 significant digits and join them into a string.\n    # The 'g' format specifier handles scientific and fixed-point notation appropriately.\n    formatted_results = [f\"{res:.12g}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3214941"}, {"introduction": "许多实际问题中的函数在大部分区域内变化平缓，但在某个局部区域内却具有尖锐的特征（如一个窄峰）。在这种情况下，使用均匀剖分的积分网格会显得十分低效，因为它在平坦区域浪费了大量计算资源。本练习旨在介绍自适应辛普森方法，这是一种“智能”算法，它能自动在函数变化最剧烈的区域加密计算节点，从而以最小的计算成本达到所需的精度。[@problem_id:3214881]", "problem": "考虑在区间 $[0,1]$ 上对函数 $f(x) = \\exp\\left(-100(x - 0.3)^2\\right)$ 的定积分进行数值计算。任务是实现两种基于辛普森法则的复合数值积分方法，并比较它们的精度和计算量：\n\n1. 一种均匀复合辛普森方法，它将 $[0,1]$ 划分为 $N$ 个相等的子区间，其中 $N$ 为偶数。如果提供了奇数 $N$，实现必须将其增加 1，以使该法则适用。\n\n2. 一种带有局部误差控制的自适应复合辛普森方法，它递归地细分一个区间，直到满足指定的局部绝对容差 $\\text{tol}$。局部误差控制必须通过比较一个区间上的辛普森近似值与其两个半区间上辛普森近似值之和来实施，并通过一种确保全局绝对误差受控的方式将容差分配到各个子区间。\n\n实现应基于以下基本原理构建：\n\n- 多项式插值：在一个区间上，通过三个点构建一个二次插值多项式来逼近一个足够光滑的函数，并对该插值多项式进行精确积分。\n- 基于多项式的复合求积的误差行为：对于足够光滑的函数 $f$，辛普森法则在单个分片上的截断误差与区间长度的五次方成比例，当均匀应用时，产生四阶全局收敛率。\n\n使用高斯函数的已知反导数（以误差函数表示）计算积分的真值，并将其用作误差计算的基准真值。\n\n对于每种方法，报告：\n- 相对于真实积分值的绝对误差。\n- 使用的函数求值次数。\n\n程序必须实现这两种方法并运行以下测试套件，其中每个测试用例是一对 $(\\text{tol}, N)$：\n\n- 测试用例 1 (标准情况)：$\\text{tol} = 10^{-6}$, $N = 100$。\n- 测试用例 2 (更严格的容差，更精细的网格)：$\\text{tol} = 10^{-8}$, $N = 1000$。\n- 测试用例 3 (更宽松的容差，更粗糙的网格)：$\\text{tol} = 10^{-4}$, $N = 10$。\n- 测试用例 4 (使用最少均匀分片的边界情况)：$\\text{tol} = 10^{-10}$, $N = 2$。\n- 测试用例 5 (非常严格的容差)：$\\text{tol} = 10^{-12}$, $N = 200$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。此列表中的每个元素对应一个测试用例，并且其本身必须是一个包含四个值的列表，顺序如下：$[\\text{abs\\_error\\_adaptive}, \\text{evals\\_adaptive}, \\text{abs\\_error\\_uniform}, \\text{evals\\_uniform}]$。例如，两个用例的输出形式为 $[[e_1,c_1,E_1,C_1],[e_2,c_2,E_2,C_2]]$。\n\n此问题不涉及物理单位，也不需要角度或百分比。最终输出值必须是适当的实数或整数，不带任何附加文本。", "solution": "用户提供了一个有效的问题陈述。\n\n### 步骤1：提取给定条件\n- **待积函数**：$f(x) = \\exp\\left(-100(x - 0.3)^2\\right)$\n- **积分区间**：$[0, 1]$\n- **方法1**：均匀复合辛普森法则，使用 $N$ 个相等的子区间。如果 $N$ 是奇数，则必须加 1。\n- **方法2**：自适应复合辛普森法则，使用局部绝对容差 $\\text{tol}$。通过比较一个单分片辛普森法则近似值 ($S_1$) 与同一区间上两个分片的近似值 ($S_2$) 来估计局部误差。\n- **真值**：使用误差函数 $\\text{erf}(x)$ 计算。\n- **每种方法的输出**：相对于真值的绝对误差和函数求值的总次数。\n- **测试套件**：一系列测试用例，每个由一对 $(\\text{tol}, N)$ 定义：\n    1. $(\\text{tol} = 10^{-6}, N = 100)$\n    2. $(\\text{tol} = 10^{-8}, N = 1000)$\n    3. $(\\text{tol} = 10^{-4}, N = 10)$\n    4. $(\\text{tol} = 10^{-10}, N = 2)$\n    5. $(\\text{tol} = 10^{-12}, N = 200)$\n- **输出格式**：单行文本：`[[abs_error_adaptive, evals_adaptive, abs_error_uniform, evals_uniform], ...]`，包含所有测试用例。\n\n### 步骤2：使用提取的给定条件进行验证\n该问题被评估为**有效**。\n\n- **科学上合理**：该问题是数值分析中的一个标准练习，涉及实现和比较公认的求积法则（复合辛普森法则，自适应求积）。函数是一个高斯函数，它是解析的，因此是无限可微的 ($C^\\infty$)，使其成为高阶积分方法的理想选择。通过误差函数计算真值的方法在数学上是可靠的。\n- **适定性**：问题定义清晰。函数、区间、方法和参数都已指定。对于每个测试用例，都可以计算出唯一的数值结果。\n- **客观性**：语言精确，没有主观或含糊的术语。\n- **完整性和一致性**：问题是自包含的。提供了实现解决方案和运行测试所需的所有信息。没有内部矛盾。\n- **可行性**：所需的计算是标准的，并且在计算上是可行的。\n\n### 步骤3：结论与行动\n问题有效。将开发一个完整的解决方案。\n\n### 基于原理的解决方案\n任务是使用复合辛普森法则的两种变体来评估定积分 $I = \\int_0^1 f(x) \\,dx$（其中 $f(x) = \\exp\\left(-100(x - 0.3)^2\\right)$），并比较它们的效率。\n\n**1. 积分的真值**\n\n高斯函数的积分可以用误差函数 $\\text{erf}(z) = \\frac{2}{\\sqrt{\\pi}} \\int_0^z e^{-t^2} \\,dt$ 来表示。\n设 $I = \\int_0^1 \\exp\\left(-100(x - 0.3)^2\\right) \\,dx$。\n我们进行变量替换。设 $u = \\sqrt{100}(x - 0.3) = 10(x - 0.3)$。这意味着 $du = 10 \\,dx$，或 $dx = \\frac{1}{10} \\,du$。\n$u$ 的积分上下限是：\n- 当 $x = 0$ 时，$u = 10(0 - 0.3) = -3$。\n- 当 $x = 1$ 时，$u = 10(1 - 0.3) = 7$。\n\n积分变为：\n$$ I = \\int_{-3}^{7} e^{-u^2} \\frac{1}{10} \\,du = \\frac{1}{10} \\int_{-3}^{7} e^{-u^2} \\,du $$\n使用误差函数的定义：\n$$ \\int_a^b e^{-t^2} \\,dt = \\int_0^b e^{-t^2} \\,dt - \\int_0^a e^{-t^2} \\,dt = \\frac{\\sqrt{\\pi}}{2} \\left[ \\text{erf}(b) - \\text{erf}(a) \\right] $$\n当 $a = -3$ 且 $b = 7$ 时，我们得到：\n$$ I = \\frac{1}{10} \\left[ \\frac{\\sqrt{\\pi}}{2} (\\text{erf}(7) - \\text{erf}(-3)) \\right] $$\n利用性质 $\\text{erf}(-z) = -\\text{erf}(z)$，真值为：\n$$ I_{true} = \\frac{\\sqrt{\\pi}}{20} \\left[ \\text{erf}(7) + \\text{erf}(3) \\right] $$\n这个值将作为我们计算数值方法绝对误差的基准真值。\n\n**2. 均匀复合辛普森法则**\n\n辛普森法则通过对一个通过点 $(a, f(a))$、 $((a+b)/2, f((a+b)/2))$ 和 $(b, f(b))$ 的二次插值多项式进行积分，来近似函数 $f(x)$ 在区间 $[a, b]$ 上的积分。公式为：\n$$ S(a, b) = \\frac{b-a}{6} \\left[ f(a) + 4f\\left(\\frac{a+b}{2}\\right) + f(b) \\right] $$\n复合辛普森法则在积分区间的划分上应用此公式。对于 $[a, b]$ 的一个均匀划​​分，分为 $N$ 个等宽子区间，宽度为 $h = (b-a)/N$（其中 $N$ 必须是偶数），节点为 $x_i = a + ih$，其中 $i = 0, 1, \\dots, N$。积分近似为：\n$$ S_N = \\frac{h}{3} \\left[ f(x_0) + 4\\sum_{i=1, i \\text{ is odd}}^{N-1} f(x_i) + 2\\sum_{i=2, i \\text{ is even}}^{N-2} f(x_i) + f(x_N) \\right] $$\n该方法的函数求值次数为 $N+1$。根据问题要求，如果给定的 $N$ 是奇数，则增加到 $N+1$，使得求值次数为 $N+2$。\n\n**3. 自适应复合辛普森法则**\n\n自适应求积方法根据被积函数的局部行为调整求值点的密度。函数 $f(x)$ 在 $x=0.3$ 附近有一个尖峰，在其他地方几乎为零，这使其成为自适应方法的首选对象。该方法的工作原理如下：\n\n对于一个区间 $[a, b]$，我们计算两个近似值：\n- 一个“粗略”近似值 $S_1$，使用 $[a, b]$ 上的单个辛普森分片。\n- 一个“精细”近似值 $S_2$，通过在半区间 $[a, m]$ 和 $[m, b]$ 上对两个辛普森分片求和得到，其中 $m = (a+b)/2$。\n\n在宽度为 $h=b-a$ 的区间上，单分片辛普森法则的误差近似为 $E_1 \\approx -\\frac{h^5}{2880} f^{(4)}(\\xi)$。双分片近似的误差为 $E_2 \\approx 2 \\times \\left(-\\frac{(h/2)^5}{2880} f^{(4)}(\\eta)\\right) \\approx \\frac{1}{16} E_1$。\n真积分 $I$ 可以写为 $I = S_1 + E_1$ 和 $I = S_2 + E_2$。\n假设 $f^{(4)}$ 在 $[a, b]$ 上几乎是常数，我们可以在近似值和更精细的近似误差 $E_2$ 之间建立关系：\n$$ S_2 - S_1 \\approx E_1 - E_2 \\approx 16 E_2 - E_2 = 15 E_2 $$\n因此，$S_2$ 的局部误差估计为 $\\text{err} \\approx \\frac{|S_2 - S_1|}{15}$。\n\n自适应算法是递归的：\n1. 对于给定的区间 $[a, b]$ 和局部容差 $\\text{tol}_{local}$，计算 $S_1$ 和 $S_2$。\n2. 计算误差估计 $\\text{err} = \\frac{|S_2 - S_1|}{15}$。\n3. 如果 $\\text{err}  \\text{tol}_{local}$，则该区间已充分解析。我们接受结果，并为了提高精度，返回理查森外推值 $I_{[a,b]} = S_2 + \\frac{S_2 - S_1}{15}$。这是对该区间上积分更准确的估计。\n4. 如果 $\\text{err} \\ge \\text{tol}_{local}$，则该区间未解析。将其细分为 $[a, m]$ 和 $[m, b]$。对每个子区间递归调用该算法，但每个子区间的容差减半：$\\text{tol}_{local}/2$。总积分是两次递归调用的结果之和。\n\n为确保全局误差控制，容差按区间宽度成比例分配。初始调用使用全局容差 $\\text{tol}$。在半区间上的每个递归步骤使用其父区间容差的一半。\n\n为避免冗余计算，端点和中点的函数值通过递归向下传递。在已知 $f(a)$、$f((a+b)/2)$ 和 $f(b)$ 的情况下，对 $[a, b]$ 的一个递归步骤只需要计算两个新值：$f((a+m)/2)$ 和 $f((m+b)/2)$。在整个递归过程中跟踪函数求值的总次数。\n\n这种自适应策略将计算量集中在高斯函数峰值周围的区域（$x \\approx 0.3$），那里函数变化迅速，而在接近 $x=0$ 和 $x=1$ 的平坦区域使用很少的求值，从而实现高效率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Implements and compares uniform and adaptive Simpson's rule for integrating\n    a Gaussian function, then runs a suite of test cases.\n    \"\"\"\n    \n    # 1. Define the function to integrate\n    def f(x):\n        return np.exp(-100.0 * (x - 0.3)**2)\n\n    # 2. Calculate the \"true\" value of the integral using the error function\n    # I = integral from 0 to 1 of exp(-100*(x-0.3)^2) dx\n    # Let u = 10*(x-0.3), so du = 10*dx.\n    # Limits: x=0 -> u=-3; x=1 -> u=7.\n    # I = (1/10) * integral from -3 to 7 of exp(-u^2) du\n    # Using erf(z) = (2/sqrt(pi)) * integral from 0 to z of exp(-t^2) dt\n    # Integral from a to b = sqrt(pi)/2 * (erf(b) - erf(a))\n    # I = (1/10) * sqrt(pi)/2 * (erf(7) - erf(-3))\n    #   = (sqrt(pi)/20) * (erf(7) + erf(3))\n    true_value = (math.sqrt(math.pi) / 20.0) * (math.erf(7.0) + math.erf(3.0))\n\n    # 3. Uniform Composite Simpson's Rule Implementation\n    def uniform_simpson(func, a, b, N):\n        \"\"\"\n        Calculates the definite integral using the uniform composite Simpson's rule.\n        \n        Args:\n            func: The function to integrate.\n            a, b: The interval of integration.\n            N: The number of subintervals (must be even, adjusted if not).\n            \n        Returns:\n            A tuple (integral_value, num_evaluations).\n        \"\"\"\n        if N % 2 != 0:\n            N += 1\n        \n        h = (b - a) / float(N)\n        x = np.linspace(a, b, N + 1)\n        y = func(x)\n        \n        # Simpson's formula: h/3 * (y0 + 4y1 + 2y2 + ... + 4y(N-1) + yN)\n        # Slicing: y[1:-1:2] gets odd indices, y[2:-2:2] gets even indices.\n        integral = (h / 3.0) * (y[0] + 4.0 * np.sum(y[1:-1:2]) + 2.0 * np.sum(y[2:-2:2]) + y[-1])\n        \n        evals = N + 1\n        return integral, evals\n\n    # 4. Adaptive Composite Simpson's Rule Implementation\n    def adaptive_simpson(func, a, b, tol):\n        \"\"\"\n        Wrapper for the recursive adaptive Simpson's rule integrator.\n        \n        Args:\n            func: The function to integrate.\n            a, b: The interval of integration.\n            tol: The desired absolute error tolerance.\n            \n        Returns:\n            A tuple (integral_value, num_evaluations).\n        \"\"\"\n        \n        eval_count = [0] # Use a list as a mutable counter\n\n        def f_counted(x):\n            eval_count[0] += 1\n            return func(x)\n        \n        # Initial function evaluations\n        fa = f_counted(a)\n        fm = f_counted((a + b) / 2.0)\n        fb = f_counted(b)\n        \n        integral = _adaptive_simpson_recursive(f_counted, a, b, tol, fa, fm, fb)\n        \n        return integral, eval_count[0]\n\n    def _adaptive_simpson_recursive(func, a, b, tol, fa, fm, fb):\n        \"\"\"Recursive helper for adaptive Simpson's rule.\"\"\"\n        h = b - a\n        m = (a + b) / 2.0\n        \n        # Coarse approximation (1 panel)\n        s1 = (h / 6.0) * (fa + 4.0 * fm + fb)\n        \n        # Finer approximation (2 panels) requires 2 new function evaluations\n        ml = (a + m) / 2.0\n        mr = (m + b) / 2.0\n        fml = func(ml)\n        fmr = func(mr)\n        \n        s2 = (h / 12.0) * (fa + 4.0 * fml + 2.0 * fm + 4.0 * fmr + fb)\n        \n        # Error estimation: |(S2 - S1) / 15| is an estimate of the error in S2.\n        error_estimate = abs(s2 - s1) / 15.0\n        \n        if error_estimate  tol:\n            # Richardson extrapolation for a more accurate result\n            return s2 + (s2 - s1) / 15.0\n        else:\n            # Subdivide and recurse, distributing tolerance\n            left_integral = _adaptive_simpson_recursive(func, a, m, tol / 2.0, fa, fml, fm)\n            right_integral = _adaptive_simpson_recursive(func, m, b, tol / 2.0, fm, fmr, fb)\n            return left_integral + right_integral\n\n    # 5. Define test cases\n    test_cases = [\n        (1e-6, 100),\n        (1e-8, 1000),\n        (1e-4, 10),\n        (1e-10, 2),\n        (1e-12, 200),\n    ]\n\n    all_results = []\n\n    # 6. Run the test suite\n    for tol, N in test_cases:\n        # Run adaptive method\n        res_adaptive, evals_adaptive = adaptive_simpson(f, 0.0, 1.0, tol)\n        error_adaptive = abs(res_adaptive - true_value)\n\n        # Run uniform method\n        res_uniform, evals_uniform = uniform_simpson(f, 0.0, 1.0, N)\n        error_uniform = abs(res_uniform - true_value)\n        \n        # Store results for this test case\n        case_result = [error_adaptive, evals_adaptive, error_uniform, evals_uniform]\n        all_results.append(case_result)\n\n    # 7. Format and print the final output\n    # The output format must be exact: [[v1,v2,v3,v4],[v5,v6,v7,v8]] with no spaces.\n    # repr() gives the correct bracket/comma structure, and .replace removes spaces.\n    output_str = repr(all_results).replace(' ', '')\n    print(output_str)\n\nsolve()\n```", "id": "3214881"}]}