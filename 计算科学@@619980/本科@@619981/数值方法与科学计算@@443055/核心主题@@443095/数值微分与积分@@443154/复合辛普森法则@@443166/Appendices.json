{"hands_on_practices": [{"introduction": "这个基础练习将帮助你迈出第一步。我们将对一个熟悉的函数 $f(x) = \\cos(x)$ 应用复合辛普森法则，其精确积分值是已知的。通过这种方式，我们可以直接计算近似误差，从而对该方法的准确性有一个具体的感受，并验证你对公式的理解和应用是否正确。[@problem_id:2210199]", "problem": "一个物理系统中，可观测量 $Q$ 的变化率由函数 $f(t) = V_0 \\cos(\\omega t)$ 描述，其中 $t$ 为时间。该量在区间 $[a, b]$ 上的总变化量由定积分 $\\Delta Q = \\int_{a}^{b} f(t) \\, dt$ 给出。\n\n考虑一个系统，其常数 $V_0 = 1.0$ 单位/秒，$\\omega = 1.0$ 弧度/秒。你的任务是分析在从 $t=0$ 到 $t=\\frac{\\pi}{2}$ 秒的时间间隔内，$Q$ 的总变化量 $\\Delta Q$（以单位计）。\n\n首先，计算总变化量的精确值 $\\Delta Q_{exact}$。\n其次，使用 $n=4$ 个子区间，应用复合辛普森1/3法则计算总变化量的近似值 $\\Delta Q_{approx}$。对于具有偶数个子区间 $n$ 的积分 $\\int_a^b g(x) \\, dx$，复合辛普森1/3法则的近似公式如下：\n$$S_n = \\frac{h}{3} \\left[ g(x_0) + 4\\sum_{i=1}^{n/2} g(x_{2i-1}) + 2\\sum_{i=1}^{n/2-1} g(x_{2i}) + g(x_n) \\right]$$\n其中 $h = \\frac{b-a}{n}$ 且 $x_i = a+ih$，$i=0, 1, \\dots, n$。\n\n最后，计算近似的绝对误差大小，其定义为 $|\\Delta Q_{exact} - \\Delta Q_{approx}|$。将此绝对误差作为你的最终答案。将你的最终答案四舍五入到五位有效数字。", "solution": "给定变化率 $f(t) = V_{0}\\cos(\\omega t)$ 以及在 $[a,b]$ 上的总变化量：\n$$\n\\Delta Q=\\int_{a}^{b} f(t)\\,dt.\n$$\n当 $V_{0}=1$ 且 $\\omega=1$ 时，我们有 $f(t)=\\cos t$，$a=0$，$b=\\frac{\\pi}{2}$。\n\n精确值：\n使用反导数 $\\int \\cos t\\,dt=\\sin t$，根据微积分基本定理可得\n$$\n\\Delta Q_{\\text{exact}}=\\int_{0}^{\\frac{\\pi}{2}} \\cos t\\,dt=\\left[\\sin t\\right]_{0}^{\\frac{\\pi}{2}}=\\sin\\!\\left(\\frac{\\pi}{2}\\right)-\\sin(0)=1-0=1.\n$$\n\n使用 $n=4$ 的复合辛普森1/3法则：\n这里 $h=\\frac{b-a}{n}=\\frac{\\frac{\\pi}{2}-0}{4}=\\frac{\\pi}{8}$ 且 $x_{i}=a+ih=0+i\\frac{\\pi}{8}$，$i=0,1,2,3,4$。因此\n$$\nx_{0}=0,\\quad x_{1}=\\frac{\\pi}{8},\\quad x_{2}=\\frac{\\pi}{4},\\quad x_{3}=\\frac{3\\pi}{8},\\quad x_{4}=\\frac{\\pi}{2}.\n$$\n使用复合辛普森公式\n$$\nS_{4}=\\frac{h}{3}\\left[g(x_{0})+4\\sum_{i=1}^{2}g(x_{2i-1})+2\\sum_{i=1}^{1}g(x_{2i})+g(x_{4})\\right],\n$$\n其中 $g(t)=\\cos t$，我们得到\n$$\nS_{4}=\\frac{\\pi}{24}\\left[\\cos 0+4\\left(\\cos\\!\\left(\\frac{\\pi}{8}\\right)+\\cos\\!\\left(\\frac{3\\pi}{8}\\right)\\right)+2\\cos\\!\\left(\\frac{\\pi}{4}\\right)+\\cos\\!\\left(\\frac{\\pi}{2}\\right)\\right].\n$$\n使用精确的特殊值 $\\cos 0=1$，$\\cos\\!\\left(\\frac{\\pi}{4}\\right)=\\frac{\\sqrt{2}}{2}$，$\\cos\\!\\left(\\frac{\\pi}{2}\\right)=0$，以及数值近似值 $\\cos\\!\\left(\\frac{\\pi}{8}\\right)\\approx 0.9238795325$，$\\cos\\!\\left(\\frac{3\\pi}{8}\\right)\\approx 0.3826834324$，我们计算\n$$\nS_{4}\\approx \\frac{\\pi}{24}\\left[1+4(0.9238795325+0.3826834324)+2\\cdot 0.7071067812+0\\right]\\approx 1.000134584974194.\n$$\n\n绝对误差：\n$$\n\\left|\\Delta Q_{\\text{exact}}-\\Delta Q_{\\text{approx}}\\right|=\\left|1-1.000134584974194\\right|\\approx 0.000134584974194.\n$$\n四舍五入到五位有效数字，得到 $1.3458\\times 10^{-4}$。", "answer": "$$\\boxed{1.3458 \\times 10^{-4}}$$", "id": "2210199"}, {"introduction": "在实践中，我们常常需要在计算前就预估所需的计算量，以确保结果满足特定的精度要求。这个练习将引导你从“计算后分析误差”转向“计算前控制误差”。你将使用复合辛普森法则的误差界限公式 [@problem_id:2210241]，来确定为达到预设精度所需的最小子区间数，这是在科学计算中进行高效、可靠估算的一项核心技能。", "problem": "在数值分析中，当一个函数的解析解难以或无法求得时，其定积分通常使用求积公式来近似计算。复合辛普森 1/3 法则就是这样一种方法。\n\n考虑近似计算积分 $I = \\int_1^2 \\frac{1}{x} \\, dx$ 的值。\n\n使用复合辛普森 1/3 法则，以偶数个子区间 $n$ 来近似 $\\int_a^b f(x) \\, dx$ 时，其绝对误差 $E_S$ 的界由以下不等式给出：\n$$|E_S| \\leq \\frac{(b-a)^5}{180n^4} M_4$$\n其中 $M_4$ 是函数 $f(x)$ 在区间 $[a, b]$ 上四阶导数绝对值的上界；即，对于所有 $x \\in [a, b]$，都有 $|f^{(4)}(x)| \\leq M_4$。\n\n确定所需的最小偶数 $n$ 值，以保证使用复合辛普森 1/3 法则对积分 $I$ 的近似，其绝对误差小于 $10^{-5}$。", "solution": "我们使用复合辛普森 $1/3$ 法则，以 $n$ 个（偶数）子区间来近似 $I=\\int_{1}^{2}\\frac{1}{x}\\,dx$。其误差界为\n$$\n|E_{S}|\\leq \\frac{(b-a)^{5}}{180\\,n^{4}}\\,M_{4},\n$$\n其中 $M_4$ 满足对于 $x \\in [1,2]$ 和 $f(x)=\\frac{1}{x}$，有 $|f^{(4)}(x)|\\leq M_{4}$。\n\n计算导数：\n$$\nf(x)=x^{-1},\\quad f'(x)=-x^{-2},\\quad f''(x)=2x^{-3},\\quad f^{(3)}(x)=-6x^{-4},\\quad f^{(4)}(x)=24x^{-5}.\n$$\n因此 $|f^{(4)}(x)|=24x^{-5}$，该函数在 $[1,2]$ 上是递减的，故其最大值在 $x=1$ 处取得。因此\n$$\nM_{4}=24.\n$$\n\n当 $a=1$ 且 $b=2$ 时，我们有 $b-a=1$，所以误差界变为\n$$\n|E_{S}|\\leq \\frac{1^{5}}{180\\,n^{4}}\\cdot 24=\\frac{24}{180\\,n^{4}}=\\frac{2}{15\\,n^{4}}.\n$$\n为了保证 $|E_{S}| \\le 10^{-5}$，只需满足\n$$\n\\frac{2}{15\\,n^{4}}\\leq 10^{-5}\\quad\\Longrightarrow\\quad n^{4}\\geq \\frac{2}{15}\\times 10^{5}=\\frac{40000}{3}.\n$$\n两边开四次方根可得 $n\\geq \\left(\\frac{40000}{3}\\right)^{1/4}$。由于 $n$ 必须是偶数，我们测试 $n=10$ 和 $n=12$：\n$$\n10^{4}=10000 < \\frac{40000}{3},\\quad 12^{4}=20736>\\frac{40000}{3}.\n$$\n因此，保证 $|E_{S}| \\le 10^{-5}$ 的最小偶数 $n$ 是 $n=12$。", "answer": "$$\\boxed{12}$$", "id": "2210241"}, {"introduction": "最后的练习将带你从手动计算飞跃到算法设计的高度。现实世界中的函数在积分域内的行为可能千差万别，一个固定的步长对于所有区域来说并非最优。这项高级练习 [@problem_id:3215250] 要求你实现一个“自适应”辛普森积分算法，它能智能地在函数变化剧烈的区域加密采样点，而在平缓区域减少计算量，这正是专业科学计算软件中数值积分的核心思想。", "problem": "要求您设计并实现一个完整的、可运行的程序，该程序使用基于复合辛普森法则的自适应加密方法来近似计算定积分。目标是在用户指定的绝对容差 $\\epsilon$ 内计算 $$\\int_a^b f(x)\\,dx$$，通过递归地细分区间并在子区间上应用辛普森型近似来实现。您的实现必须基于第一性原理：从定积分作为黎曼和极限的定义以及局部多项式插值的思想出发，然后形式化一个从有原则的局部误差估计中导出的递归接受准则。除了 Python 标准库和给定的数值库之外，不要使用任何外部库。[@problem_id:48]\n\n您的程序必须实现自适应辛普森求积 (Adaptive Simpson's Quadrature, ASQ)，此处定义为一个递归算法，该算法：\n- 在子区间上使用 $f(x)$ 的二次插值来产生辛普森型近似。\n- 通过比较在一个加密级别和更精细级别上获得的近似值来计算局部误差指示子。\n- 如果局部误差指示子保证该子区间上的绝对误差小于指定的局部容差，则接受该子区间，否则递归地细分该子区间并重复此过程。\n- 将指定的全局容差 $\\epsilon$ 分配到各个子区间，以确保总误差不超过 $\\epsilon$。\n- 强制设置最大递归深度以避免无限递归；当达到最大深度时，必须返回当前最佳的精细化估计值。\n- 通过尽可能重用已在共享节点上计算的值来统计并最小化函数求值次数。\n\n科学和数值要求：\n- 所有角度必须以弧度处理。\n- 如果 $a=b$，算法必须返回 $0$。\n- 接受准则必须根植于辛普森型截断误差在区间二分下的行为，并且必须包括一个基于局部误差指示子对接受值的修正，使得返回的估计值比原始的复合求和更精确。\n- 实现必须保证所有接受的局部误差之和不超过全局容差 $\\epsilon$。\n- 您必须通过全程使用双精度浮点运算来确保数值稳定性。\n\n测试套件：\n实现您的程序以评估以下六个测试用例。对于每个用例，您的程序必须计算积分近似值，并按如下规定将结果聚合到最终输出中。所有角度均以弧度为单位。\n\n1. 在 $[0,\\pi]$ 上，$f(x)=\\sin(x)$，$\\epsilon=10^{-12}$。这是一个具有已知精确值的平滑“理想”情况。\n2. 在 $[-1,1]$ 上，$f(x)=e^{-x^2}$，$\\epsilon=10^{-10}$。这测试了一个具有快速衰减尾部的平滑非多项式函数。\n3. 在 $[-5,5]$ 上，$f(x)=\\dfrac{1}{1+x^2}$，$\\epsilon=10^{-12}$。这测试了在较宽区间上有理函数的行为。\n4. 在 $[0,1]$ 上，$f(x)=\\sqrt{x}$，$\\epsilon=10^{-12}$。这测试了在 $x=0$ 处导数无界但积分定义良好的端点行为。\n5. 在 $[-1,1]$ 上，$f(x)=x^3$，$\\epsilon=10^{-12}$。这测试了奇次多项式的精确性性质。\n6. 在 $[2,2]$ 上，$f(x)=e^{x}$，$\\epsilon=10^{-12}$。这是一个边界条件，由于区间长度为 $0$，积分应为 $0$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表。该列表必须按上述测试用例的顺序包含六个积分近似值，每个值都表示为一个浮点数。例如，输出必须如下所示：\n$$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5,\\text{result}_6]$$\n列表前后不应打印任何额外文本。", "solution": "在指定的容差内计算定积分是数值分析中的一个经典任务。所提出的方法，自适应辛普森求积 (ASQ)，是用于此目的的稳健而高效的算法。该问题陈述是有效的，因为它科学地基于数值积分和误差分析的原理，具有明确的目标和约束条件，是一个适定的问题，并提供了一套可验证的测试用例。它是在数值方法领域内一个可以形式化的问题。\n\n该方法的基础是近似计算定积分 $\\int_a^b f(x)\\,dx$，它在几何上表示函数 $f(x)$ 从 $x=a$ 到 $x=b$ 的曲线下面积。数值求积方法通过用一个可以精确积分的更简单的函数（如多项式）来替换函数 $f(x)$，从而近似这个面积。\n\n辛普森 1/3 法则是通过在区间 $[a, b]$ 上用一个二次多项式 $P_2(x)$ 来近似 $f(x)$ 推导出来的，该多项式在三个等距点上对 $f(x)$ 进行插值：端点 $a$ 和 $b$，以及中点 $m = (a+b)/2$。该多项式的积分为我们提供了近似值：\n$$\n\\int_a^b f(x) \\,dx \\approx \\int_a^b P_2(x) \\,dx = \\frac{h}{3} \\left( f(a) + 4f(m) + f(b) \\right)\n$$\n其中 $h = (b-a)/2$ 是插值点之间的步长。更常见的做法是根据总区间宽度 $b-a$ 来定义近似，这给出了：\n$$\nS(a, b) = \\frac{b-a}{6} \\left( f(a) + 4f\\left(\\frac{a+b}{2}\\right) + f(b) \\right)\n$$\n该近似的截断误差 $E_S = \\int_a^b f(x) \\,dx - S(a, b)$ 可以被证明为：\n$$\nE_S = -\\frac{(b-a)^5}{2880} f^{(4)}(\\xi)\n$$\n对于某个 $\\xi \\in (a, b)$，前提是 $f(x)$ 是四阶连续可微的。误差的阶为 $O((b-a)^5)$。这种高阶精度使得辛普森法则对于平滑函数非常有效。\n\n*自适应*方法的核心是能够估计给定子区间上近似的局部误差，并且只在必要时细分区间以满足期望的容差。这比在整个定义域上使用具有固定小步长的复合规则更有效，因为它将计算量集中在函数性状较差的区域。\n\n为了在不知道 $f^{(4)}(x)$ 的情况下估计误差，我们比较同一区间 $[a, b]$ 上的两个近似值。首先，我们使用整个区间计算粗略近似 $S_1$：\n$$\nS_1 = \\frac{b-a}{6} \\left( f(a) + 4f(m) + f(b) \\right)\n$$\n其中 $m=(a+b)/2$。接下来，我们通过将区间二分为 $[a, m]$ 和 $[m, b]$ 并对每个子区间应用辛普森法则来计算一个更精细的近似 $S_2$。令 $c=(a+m)/2$ 且 $d=(m+b)/2$。\n$$\nS_2 = S(a, m) + S(m, b) = \\frac{m-a}{6}\\left(f(a)+4f(c)+f(m)\\right) + \\frac{b-m}{6}\\left(f(m)+4f(d)+f(b)\\right)\n$$\n由于 $m-a = b-m = (b-a)/2$，我们可以将 $S_2$ 写为：\n$$\nS_2 = \\frac{b-a}{12} \\left( f(a) + 4f(c) + 2f(m) + 4f(d) + f(b) \\right)\n$$\n令 $I$ 为积分的精确值。$S_1$ 的误差为 $I - S_1 \\approx C(b-a)^5$。$S_2$ 的误差是两个宽度减半的区间上的误差之和，所以 $I - S_2 \\approx 2 \\times C((b-a)/2)^5 = C(b-a)^5/16$。\n因此，粗略近似的误差大约是精细近似误差的 $16$ 倍：\n$$\nI - S_1 \\approx 16(I - S_2)\n$$\n通过重新排列各项，我们可以解出更精确近似 $S_2$ 的误差：\n$$\nS_2 - S_1 \\approx 15(I - S_2) \\implies E_2 = I - S_2 \\approx \\frac{S_2 - S_1}{15}\n$$\n量 $|\\frac{S_2 - S_1}{15}|$ 可作为近似 $S_2$ 的一个可计算的局部误差指示子。\n\n自适应算法以递归方式进行。给定一个区间 $[a, b]$ 和一个局部容差 $\\tau$：\n1.  计算五个必要的函数值：$f(a)$、 $f(c)$、 $f(m)$、 $f(d)$、 $f(b)$。\n2.  计算近似值 $S_1$ 和 $S_2$。\n3.  计算误差估计 $\\Delta = |S_2 - S_1|/15$。\n4.  如果 $\\Delta \\le \\tau$，则接受该近似。为进一步提高精度，我们使用理查森外推法。改进后的值为 $S_{extrapolated} = S_2 + (S_2 - S_1)/15$。返回该值。这个外推值的误差是 $O((b-a)^7)$，使其精度显著提高。\n5.  如果 $\\Delta > \\tau$，则必须加密该区间。算法在两个子区间 $[a, m]$ 和 $[m, b]$ 上递归调用自身。容差在它们之间分配，因此每个子问题都以 $\\tau/2$ 的容差来解决。结果是两次递归调用的结果之和。\n\n该过程从对整个区间 $[a, b]$ 使用全局容差 $\\epsilon$ 的初始调用开始。为防止无限递归，特别是对于具有奇点的函数，会强制执行最大递归深度。如果达到此深度，该分支的处理将终止，并返回当前的最佳估计值 ($S_{extrapolated}$) 。为了最小化函数求值次数，一个层级上计算的函数值会被传递到下一层级，因为父区间的端点和中点会成为其子区间的重用点。对于初始区间 $[a,b]$，点 $a$、$m$、$b$ 与子区间 $[a,m]$ 和 $[m,b]$ 共享。函数只需在新点 $c$ 和 $d$ 处求值。最后，对 $a=b$ 的情况进行显式处理，返回 $0$ 作为积分值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the adaptive Simpson's quadrature problem for the given test suite.\n    \"\"\"\n\n    def _recursive_asq(f, a, b, tol, fa, fm, fb, depth, max_depth):\n        \"\"\"Recursive helper for adaptive Simpson's quadrature.\"\"\"\n        m = (a + b) / 2.0\n        h = b - a\n\n        # Calculate new interpolation points and function values\n        c = (a + m) / 2.0\n        d = (m + b) / 2.0\n        fl = f(c)\n        fr = f(d)\n\n        # Coarse (1-panel) and refined (2-panel) Simpson's rule approximations\n        s1 = (h / 6.0) * (fa + 4.0 * fm + fb)\n        s2 = (h / 12.0) * (fa + 4.0 * fl + 2.0 * fm + 4.0 * fr + fb)\n        \n        # Error estimate based on the difference between the two approximations\n        error_estimate = abs(s2 - s1) / 15.0\n        \n        # Use Richardson extrapolation for a more accurate result\n        extrapolated_value = s2 + (s2 - s1) / 15.0\n\n        # Acceptance criterion: if error is within tolerance or max depth is reached\n        if depth >= max_depth or error_estimate = tol:\n            return extrapolated_value\n        \n        # If not accepted, recurse on subintervals with halved tolerance\n        left_integral = _recursive_asq(f, a, m, tol / 2.0, fa, fl, fm, depth + 1, max_depth)\n        right_integral = _recursive_asq(f, m, b, tol / 2.0, fm, fr, fb, depth + 1, max_depth)\n        \n        return left_integral + right_integral\n\n    def adaptive_simpson_quadrature(f, a, b, epsilon, max_depth=50):\n        \"\"\"\n        Computes the definite integral of f from a to b using adaptive Simpson's rule.\n\n        Args:\n            f: The function to integrate.\n            a: The start of the integration interval.\n            b: The end of the integration interval.\n            epsilon: The desired absolute tolerance.\n            max_depth: The maximum recursion depth to prevent infinite loops.\n\n        Returns:\n            The approximate value of the integral.\n        \"\"\"\n        # Handle the zero-width interval case\n        if a == b:\n            return 0.0\n\n        # Initial function evaluations for the first level\n        fa = f(a)\n        fb = f(b)\n        m = (a + b) / 2.0\n        fm = f(m)\n        \n        return _recursive_asq(f, a, b, epsilon, fa, fm, fb, 1, max_depth)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'func': np.sin, 'a': 0, 'b': np.pi, 'eps': 1e-12},\n        {'func': lambda x: np.exp(-x**2), 'a': -1, 'b': 1, 'eps': 1e-10},\n        {'func': lambda x: 1 / (1 + x**2), 'a': -5, 'b': 5, 'eps': 1e-12},\n        {'func': np.sqrt, 'a': 0, 'b': 1, 'eps': 1e-12},\n        {'func': lambda x: x**3, 'a': -1, 'b': 1, 'eps': 1e-12},\n        {'func': np.exp, 'a': 2, 'b': 2, 'eps': 1e-12},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = adaptive_simpson_quadrature(\n            f=case['func'], \n            a=float(case['a']), \n            b=float(case['b']), \n            epsilon=float(case['eps'])\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15g}' for r in results)}]\")\n\nsolve()\n```", "id": "3215250"}]}