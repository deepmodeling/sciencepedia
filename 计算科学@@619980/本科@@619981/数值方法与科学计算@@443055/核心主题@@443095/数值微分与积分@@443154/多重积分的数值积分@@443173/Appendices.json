{"hands_on_practices": [{"introduction": "本节的第一个实践将引导我们应用一种专门为处理高斯权重函数和无穷积分域而设计的强大工具——高斯-埃尔米特求积。这个练习旨在展示如何通过选择与被积函数特定结构相匹配的求积法则，来高效地计算看似复杂的无穷积分。通过这个具体的例子 [@problem_id:3258802]，我们将深入理解正交多项式在数值积分中的关键作用。", "problem": "考虑一个光滑函数与高斯权重相乘的二维积分。设 $f(x,y)$ 是一个函数，其积分\n$$I = \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty} e^{-(x^2+y^2)} f(x,y)\\,dx\\,dy$$\n是有限的。对于此类积分，一种经过充分检验的数值方法是使用基于 Hermite 多项式的乘积求积：首先构造一个针对权重 $e^{-x^2}$ 的一维高斯求积，然后将其独立应用于每个坐标，从而为多重积分形成一个张量积法则。这种方法利用了 Hermite 多项式相对于高斯权重的正交性以及权重在维度间的可分离性。\n\n在此问题中，您将实施此方法来近似计算\n$$I^\\star = \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty} e^{-(x^2+y^2)} \\cos(x+y)\\,dx\\,dy,$$\n其中余弦函数使用弧度作为角度的度量单位。您的设计基础是：\n- Riemann 积分的定义和 Fubini 定理，该定理允许在满足可积条件时交换积分次序。\n- Hermite 多项式族在 $(-\\infty,\\infty)$ 上相对于高斯权重 $e^{-x^2}$ 的正交性，这是高斯求积法则的基础，该法则在乘以 $e^{-x^2}$ 权重时能够精确地积分直到某个次数的多项式。\n- 通过对可分离权重按维度应用一维法则来构造多元乘积求积。\n\n您的程序必须：\n- 使用乘积高斯-埃尔米特(Gauss-Hermite)求积法则来近似 $I^\\star$。\n- 将 $\\cos(\\cdot)$ 按弧度处理。\n- 针对以下测试套件生成结果，该套件通过改变每个维度的求积节点数来评估收敛性、边界行为和各向异性采样：\n    1. $(n_x,n_y) = (1,1)$\n    2. $(n_x,n_y) = (2,3)$\n    3. $(n_x,n_y) = (4,4)$\n    4. $(n_x,n_y) = (8,16)$\n    5. $(n_x,n_y) = (32,32)$\n\n对于每个测试用例，计算 $I^\\star$ 的单个浮点近似值。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。将每个近似值表示为四舍五入到十位小数的浮点数。例如，一个包含三个结果的输出应如下所示：\n$$[r_1,r_2,r_3],$$\n其中每个 $r_k$ 是第 $k$ 个测试用例的十位小数近似值。\n\n不涉及物理单位；所有角度均以弧度为单位。程序必须完全自包含，无需用户输入，并且仅使用指定的库。", "solution": "该问题陈述已经过验证，并被确定为数值分析领域中一个定义良好且科学上合理的问题。它要求使用一种标准的、明确定义的方法来数值近似一个特定的二维积分。所有必要的数据和参数均已提供。\n\n目标是近似计算二维积分\n$$I^\\star = \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty} e^{-(x^2+y^2)} \\cos(x+y)\\,dx\\,dy$$\n被积函数由一个高斯权重函数 $w(x,y) = e^{-(x^2+y^2)}$ 和一个函数 $f(x,y) = \\cos(x+y)$ 组成。指定的数值方法是乘积高斯-埃尔米特(Gauss-Hermite)求积法则，由于 Hermite 多项式的性质和权重函数的可分离性，该方法特别适用于此种形式的积分。\n\n其基本原理是一维高斯-埃尔米特求积法则。该法则将实数线上的带高斯权重的积分近似为一个离散的加权和：\n$$ \\int_{-\\infty}^{\\infty} e^{-t^2} g(t)\\,dt \\approx \\sum_{k=1}^{n} w_k g(t_k) $$\n在此公式中，$n$ 表示求积节点的数量。节点 $\\{t_k\\}_{k=1}^n$ 是 $n$ 次物理学家 Hermite 多项式 $H_n(t)$ 的根。相关的权重 $\\{w_k\\}_{k=1}^n$ 经过专门计算，使得如果 $g(t)$ 是次数最高为 $2n-1$ 的任意多项式，该近似就是精确的。这种对多项式被积函数的高精度特性，使得该方法在近似光滑函数的积分时非常强大，因为光滑函数可以被多项式很好地局部近似。\n\n对于二维积分 $I^\\star$，权重函数的可分离性 $w(x,y) = e^{-x^2}e^{-y^2}$ 允许构造一个乘积法则。通过应用 Fubini 定理，我们可以将二重积分表示为累次积分：\n$$ I^\\star = \\int_{-\\infty}^{\\infty} e^{-y^2} \\left( \\int_{-\\infty}^{\\infty} e^{-x^2} \\cos(x+y)\\,dx \\right) dy $$\n数值近似是分层执行的。首先，对于一个固定的 $y$ 值，使用具有节点 $\\{x_i\\}_{i=1}^{n_x}$ 和权重 $\\{w_i^{(x)}\\}_{i=1}^{n_x}$ 的 $n_x$ 点高斯-埃尔米特法则来近似关于 $x$ 的内层积分：\n$$ \\int_{-\\infty}^{\\infty} e^{-x^2} \\cos(x+y)\\,dx \\approx \\sum_{i=1}^{n_x} w_i^{(x)} \\cos(x_i+y) $$\n然后将此近似值代入关于 $y$ 的外层积分中：\n$$ I^\\star \\approx \\int_{-\\infty}^{\\infty} e^{-y^2} \\left( \\sum_{i=1}^{n_x} w_i^{(x)} \\cos(x_i+y) \\right) dy $$\n和的有限性允许交换积分和求和算符：\n$$ I^\\star \\approx \\sum_{i=1}^{n_x} w_i^{(x)} \\int_{-\\infty}^{\\infty} e^{-y^2} \\cos(x_i+y)\\,dy $$\n最后，对于每个固定的 $x_i$，使用具有节点 $\\{y_j\\}_{j=1}^{n_y}$ 和权重 $\\{w_j^{(y)}\\}_{j=1}^{n_y}$ 的 $n_y$ 点高斯-埃尔米特法则来近似余下的关于 $y$ 的积分：\n$$ \\int_{-\\infty}^{\\infty} e^{-y^2} \\cos(x_i+y)\\,dy \\approx \\sum_{j=1}^{n_y} w_j^{(y)} \\cos(x_i+y_j) $$\n将这些步骤结合起来，得到近似 $I^\\star$ 的最终张量积求积公式：\n$$ I^\\star \\approx \\sum_{i=1}^{n_x} \\sum_{j=1}^{n_y} w_i^{(x)} w_j^{(y)} \\cos(x_i+y_j) $$\n该公式指导我们在一个二维点网格 $(x_i, y_j)$ 上计算函数 $f(x,y) = \\cos(x+y)$ 的值，然后计算一个加权和，其中每个点的权重是相应的一维求积权重之积 $w_i^{(x)} w_j^{(y)}$。\n\n实现将利用 `numpy.polynomial.hermite.hermgauss` 函数，该函数为给定的点数 $n$ 提供所需的节点和权重。对于问题陈述中指定的每个测试用例 $(n_x, n_y)$，将计算双重求和。由于函数 $\\cos(x+y)$ 的光滑性，随着 $n_x$ 和 $n_y$ 的增加，近似值预计会快速收敛到积分的真值，该真值可以通过解析方法证明为 $I^\\star = \\pi e^{-1/2} \\approx 1.9045137660$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes approximations of a 2D integral using product Gauss-Hermite quadrature\n    for a series of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple represents (n_x, n_y), the number of quadrature nodes in\n    # the x and y dimensions, respectively.\n    test_cases = [\n        (1, 1),\n        (2, 3),\n        (4, 4),\n        (8, 16),\n        (32, 32),\n    ]\n\n    results = []\n    for nx, ny in test_cases:\n        # The integral to approximate is:\n        # I = integral from -inf to inf, integral from -inf to inf of\n        #     e^-(x^2+y^2) * cos(x+y) dx dy\n        # This is approximated by the sum:\n        # Sum_i Sum_j w_i * w_j * cos(x_i + y_j)\n        # where (x_i, w_i) and (y_j, w_j) are Gauss-Hermite nodes and weights.\n\n        # Fetch the 1D Gauss-Hermite quadrature nodes and weights.\n        # The function np.polynomial.hermite.hermgauss is designed for integrals\n        # with the weight function e^(-x^2).\n        x_nodes, x_weights = np.polynomial.hermite.hermgauss(nx)\n        y_nodes, y_weights = np.polynomial.hermite.hermgauss(ny)\n\n        # To implement the double summation efficiently, we use NumPy's broadcasting\n        # and outer products.\n\n        # 1. Create a matrix of product weights.\n        #    The element at (j, i) will be y_weights[j] * x_weights[i].\n        weights_matrix = np.outer(y_weights, x_weights)\n\n        # 2. Create a matrix of node sums for the function argument.\n        #    The element at (j, i) will be y_nodes[j] + x_nodes[i].\n        nodes_sum_matrix = np.add.outer(y_nodes, x_nodes)\n\n        # 3. Evaluate the function cos(x+y) on the grid of nodes.\n        #    The angles are in radians, as is standard for `np.cos`.\n        integrand_values = np.cos(nodes_sum_matrix)\n\n        # 4. Compute the final sum by element-wise multiplication and summation.\n        integral_approximation = np.sum(weights_matrix * integrand_values)\n\n        # Round the result to ten decimal places as specified.\n        rounded_result = round(integral_approximation, 10)\n        results.append(rounded_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3258802"}, {"introduction": "在解决了具有特定结构的积分之后，我们转向更普遍的情形：在复杂几何域上进行积分。本练习 [@problem_id:3258887] 要求我们计算一个函数在椭球体上的平均值，这需要我们首先通过坐标变换将不规则的椭球域映射到一个标准的单位球或立方体上。这个过程不仅能巩固我们对多重积分变量替换法则（雅可比行列式）的理解，也让我们体验到将理论方法应用于非标准问题的完整流程。", "problem": "考虑函数 $f(x,y,z) = \\sin(x)\\cos(y)\\mathrm{e}^{z}$以及由下式定义的椭球族\n$$\\mathcal{E}(a,b,c;x_0,y_0,z_0) = \\left\\{(x,y,z) \\in \\mathbb{R}^3 \\,\\bigg|\\, \\left(\\frac{x - x_0}{a}\\right)^2 + \\left(\\frac{y - y_0}{b}\\right)^2 + \\left(\\frac{z - z_0}{c}\\right)^2 \\le 1 \\right\\},$$\n其中 $a>0$, $b>0$, $c>0$。函数 $f$ 在体积 $V$ 上的平均值基本定义为\n$$\\langle f \\rangle_V = \\frac{1}{\\operatorname{Vol}(V)} \\iiint_V f(x,y,z)\\, \\mathrm{d}V.$$\n您的任务是设计并实现一个完整的、可运行的程序，对下面给出的参数集，数值近似计算 $\\langle f \\rangle_{\\mathcal{E}(a,b,c;x_0,y_0,z_0)}$。您必须：\n- 从体积平均值的定义出发，基于一个适定的变量变换，推导出一个数值稳定的算法。该变换将 $\\mathcal{E}(a,b,c;x_0,y_0,z_0)$ 映射到一个规范域，其积分测度通过相应的雅可比行列式来解决。\n- 选择一个合理的求积方案来近似计算所得的三重积分。您可以假设能够获取正交多项式的节点和权重（例如，高斯-勒让德求积），但您必须从第一性原理出发，推导它们如何应用于变换后的积分。所有角度都必须以弧度为单位。\n- 确保计算在量纲上是一致的，所有中间步骤都基于多重积分和变量变换的定义。不允许使用捷径；数值方法必须由积分定义和变换推导得出。\n\n测试套件：\n- 情况 1（正常路径）：$(a,b,c) = (1,1,1)$, $(x_0,y_0,z_0) = (0,0,0)$，求积阶数 $(N_r,N_\\theta,N_\\phi) = (24,24,24)$。\n- 情况 2（小轴边界）：$(a,b,c) = (2,1,0.5)$, $(x_0,y_0,z_0) = (0.2,-0.3,0.1)$，求积阶数 $(N_r,N_\\theta,N_\\phi) = (28,28,32)$。\n- 情况 3（中心偏移）：$(a,b,c) = (0.75,1.5,1.25)$, $(x_0,y_0,z_0) = (1.0,2.0,-1.0)$，求积阶数 $(N_r,N_\\theta,N_\\phi) = (32,32,36)$。\n- 情况 4（高纵横比边缘）：$(a,b,c) = (3.0,3.0,0.2)$, $(x_0,y_0,z_0) = (0,0,0)$，求积阶数 $(N_r,N_\\theta,N_\\phi) = (36,48,64)$。\n\n角度单位：所有三角函数参数必须使用弧度。\n\n最终输出规范：\n- 您的程序必须生成单行输出，其中包含按上述测试套件顺序排列的四个数值近似结果，四舍五入到 $6$ 位小数，以逗号分隔并用方括号括起来；例如，$$[r_1,r_2,r_3,r_4],$$ 其中每个 $r_k$ 是一个小数点后恰好有 $6$ 位数字的十进制数。", "solution": "经评估，用户提供的问题是有效的。这是一个在数值方法领域内提法良好的、有科学依据的问题，具有完整且一致的给定条件。\n\n目标是计算函数 $f(x,y,z)$ 在椭球体积 $\\mathcal{E}$ 上的平均值。平均值定义为：\n$$\n\\langle f \\rangle_{\\mathcal{E}} = \\frac{1}{\\operatorname{Vol}(\\mathcal{E})} \\iiint_{\\mathcal{E}} f(x,y,z) \\, \\mathrm{d}V\n$$\n具体函数为 $f(x,y,z) = \\sin(x)\\cos(y)e^z$。积分域是由以下不等式定义的椭球 $\\mathcal{E}(a,b,c; x_0, y_0, z_0)$：\n$$\n\\left(\\frac{x - x_0}{a}\\right)^2 + \\left(\\frac{y - y_0}{b}\\right)^2 + \\left(\\frac{z - z_0}{c}\\right)^2 \\le 1\n$$\n该椭球的体积是一个标准结果，$\\operatorname{Vol}(\\mathcal{E}) = \\frac{4}{3}\\pi abc$。\n\n问题的核心是数值计算三重积分 $I = \\iiint_{\\mathcal{E}} f(x,y,z) \\, \\mathrm{d}V$。椭球域不适合直接积分。需要进行变量变换，将积分域转换为更方便的形状，例如单位球。\n\n首先，我们引入一个从新坐标系 $(u,v,w)$ 到原始坐标系 $(x,y,z)$ 的仿射变换：\n$$\nx = a u + x_0 \\\\\ny = b v + y_0 \\\\\nz = c w + z_0\n$$\n此变换将单位球 $B = \\{(u,v,w) \\in \\mathbb{R}^3 \\mid u^2+v^2+w^2 \\le 1\\}$ 映射到椭球 $\\mathcal{E}$。为了应用多重积分的变量变换定理，我们必须计算此变换的雅可比矩阵的行列式。雅可比矩阵为：\n$$\n\\mathbf{J}_{(u,v,w)\\to(x,y,z)} = \\frac{\\partial(x,y,z)}{\\partial(u,v,w)} = \\begin{pmatrix} \\frac{\\partial x}{\\partial u}  \\frac{\\partial x}{\\partial v}  \\frac{\\partial x}{\\partial w} \\\\ \\frac{\\partial y}{\\partial u}  \\frac{\\partial y}{\\partial v}  \\frac{\\partial y}{\\partial w} \\\\ \\frac{\\partial z}{\\partial u}  \\frac{\\partial z}{\\partial v}  \\frac{\\partial z}{\\partial w} \\end{pmatrix} = \\begin{pmatrix} a  0  0 \\\\ 0  b  0 \\\\ 0  0  c \\end{pmatrix}\n$$\n其行列式的绝对值为 $|\\det(\\mathbf{J})| = |abc| = abc$，因为半轴 $a, b, c$ 均为正。体积元变换为 $\\mathrm{d}V = \\mathrm{d}x\\,\\mathrm{d}y\\,\\mathrm{d}z = abc \\, \\mathrm{d}u\\,\\mathrm{d}v\\,\\mathrm{d}w$。\n\n现在，积分 $I$ 可以表示为在单位球 $B$ 上的积分：\n$$\nI = \\iiint_{B} f(a u + x_0, b v + y_0, c w + z_0) \\, (abc) \\, \\mathrm{d}u\\,\\mathrm{d}v\\,\\mathrm{d}w\n$$\n使用这个变换后的积分，函数 $f$ 的平均值可以重写为：\n$$\n\\langle f \\rangle_{\\mathcal{E}} = \\frac{abc \\iiint_{B} f(a u + x_0, b v + y_0, c w + z_0) \\, \\mathrm{d}u\\,\\mathrm{d}v\\,\\mathrm{d}w}{\\frac{4}{3}\\pi abc}\n$$\n$abc$ 项被约去，表达式简化为在单位球上的平均值：\n$$\n\\langle f \\rangle_{\\mathcal{E}} = \\frac{1}{\\operatorname{Vol}(B)} \\iiint_{B} f(a u + x_0, b v + y_0, c w + z_0) \\, \\mathrm{d}u\\,\\mathrm{d}v\\,\\mathrm{d}w\n$$\n其中 $\\operatorname{Vol}(B) = \\frac{4}{3}\\pi$。\n\n单位球最好使用球坐标处理。我们应用第二次变量变换，从球坐标 $(r, \\theta, \\phi)$ 变换到笛卡尔坐标 $(u,v,w)$：\n$$\nu = r \\sin\\theta \\cos\\phi \\\\\nv = r \\sin\\theta \\sin\\phi \\\\\nw = r \\cos\\theta\n$$\n在这些坐标下，单位球的积分域为 $r \\in [0, 1]$, $\\theta \\in [0, \\pi]$, 以及 $\\phi \\in [0, 2\\pi]$。微分体积元为 $\\mathrm{d}u\\,\\mathrm{d}v\\,\\mathrm{d}w = r^2 \\sin\\theta \\, \\mathrm{d}r\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi$。\n\n令变换后的被积函数为 $g(r, \\theta, \\phi) = f(x(r,\\theta,\\phi), y(r,\\theta,\\phi), z(r,\\theta,\\phi))$，其中：\n$$\nx(r,\\theta,\\phi) = a (r \\sin\\theta \\cos\\phi) + x_0 \\\\\ny(r,\\theta,\\phi) = b (r \\sin\\theta \\sin\\phi) + y_0 \\\\\nz(r,\\theta,\\phi) = c (r \\cos\\theta) + z_0\n$$\n单位球上的积分变为：\n$$\n\\iiint_{B} g \\cdot \\mathrm{d}V_u = \\int_0^{2\\pi} \\int_0^{\\pi} \\int_0^1 g(r, \\theta, \\phi) \\, r^2 \\sin\\theta \\, \\mathrm{d}r\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi\n$$\n因此，平均值为：\n$$\n\\langle f \\rangle_{\\mathcal{E}} = \\frac{3}{4\\pi} \\int_0^{2\\pi} \\int_0^{\\pi} \\int_0^1 \\sin(x(r, \\theta, \\phi))\\cos(y(r, \\theta, \\phi))e^{z(r, \\theta, \\phi)} \\, r^2 \\sin\\theta \\, \\mathrm{d}r\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi\n$$\n这个三重积分现在的形式适合进行数值求积。我们使用高斯-勒让德求积法。一维积分 $\\int_A^B H(\\xi)\\,\\mathrm{d}\\xi$ 通过将区间 $[A, B]$ 变换到 $[-1, 1]$ 并应用求积法则来近似：\n$$\n\\int_A^B H(\\xi)\\,\\mathrm{d}\\xi = \\frac{B-A}{2} \\int_{-1}^1 H\\left(\\frac{B-A}{2}\\zeta + \\frac{A+B}{2}\\right)\\,\\mathrm{d}\\zeta \\approx \\frac{B-A}{2} \\sum_{i=1}^N w_i H\\left(\\frac{B-A}{2}\\zeta_i + \\frac{A+B}{2}\\right)\n$$\n其中 $\\zeta_i$ 和 $w_i$ 是 $N$ 阶高斯-勒让德求积的节点和权重。\n\n我们将此方法应用于 $r, \\theta, \\phi$ 的三个积分，阶数分别为 $N_r, N_\\theta, N_\\phi$：\n1. 对于 $r \\in [0, 1]$：因子为 $\\frac{1-0}{2}=\\frac{1}{2}$。节点为 $\\tilde{r}_i = \\frac{1}{2}(\\zeta_{r,i}+1)$。\n2. 对于 $\\theta \\in [0, \\pi]$：因子为 $\\frac{\\pi-0}{2}=\\frac{\\pi}{2}$。节点为 $\\tilde{\\theta}_j = \\frac{\\pi}{2}(\\zeta_{\\theta,j}+1)$。\n3. 对于 $\\phi \\in [0, 2\\pi]$：因子为 $\\frac{2\\pi-0}{2}=\\pi$。节点为 $\\tilde{\\phi}_k = \\pi(\\zeta_{\\phi,k}+1)$。\n\n这些变换的总缩放因子为 $(\\frac{1}{2}) (\\frac{\\pi}{2}) (\\pi) = \\frac{\\pi^2}{4}$。\n\n令 $F(r,\\theta,\\phi) = \\sin(x(r,\\theta,\\phi))\\cos(y(r,\\theta,\\phi))e^{z(r,\\theta,\\phi)} r^2 \\sin\\theta$。积分的数值近似为：\n$$\n\\int_0^{2\\pi} \\! \\int_0^{\\pi} \\! \\int_0^1 \\! F \\, \\mathrm{d}r \\mathrm{d}\\theta \\mathrm{d}\\phi \\approx \\frac{\\pi^2}{4} \\sum_{i=1}^{N_r} \\sum_{j=1}^{N_\\theta} \\sum_{k=1}^{N_\\phi} w_{r,i} w_{\\theta,j} w_{\\phi,k} F(\\tilde{r}_i, \\tilde{\\theta}_j, \\tilde{\\phi}_k)\n$$\n将此代回平均值的表达式中：\n$$\n\\langle f \\rangle_{\\mathcal{E}} \\approx \\frac{3}{4\\pi} \\left( \\frac{\\pi^2}{4} \\sum_{i,j,k} w_{r,i} w_{\\theta,j} w_{\\phi,k} F(\\tilde{r}_i, \\tilde{\\theta}_j, \\tilde{\\phi}_k) \\right)\n$$\n$$\n\\langle f \\rangle_{\\mathcal{E}} \\approx \\frac{3\\pi}{16} \\sum_{i=1}^{N_r} \\sum_{j=1}^{N_\\theta} \\sum_{k=1}^{N_\\phi} w_{r,i} w_{\\theta,j} w_{\\phi,k} \\sin(x_{ijk})\\cos(y_{ijk})e^{z_{ijk}} \\tilde{r}_i^2 \\sin(\\tilde{\\theta}_j)\n$$\n其中 $x_{ijk}, y_{ijk}, z_{ijk}$ 是在求积节点 $(\\tilde{r}_i, \\tilde{\\theta}_j, \\tilde{\\phi}_k)$ 处计算的。这是数值算法的最终公式。实现将使用向量化操作以提高效率。\n\n值得注意的是，对于椭球中心在原点的情况（$(x_0, y_0, z_0) = (0,0,0)$），积分域 $\\mathcal{E}$ 关于原点对称。被积函数 $f(x,y,z)=\\sin(x)\\cos(y)e^z$ 关于变量 $x$ 是奇函数（即 $f(-x,y,z) = -f(x,y,z)$）。由于积分域关于 $y-z$ 平面（即 $x=0$ 平面）对称，积分的精确值为零。测试用例 1 和 4 属于这种情况，数值结果预计将接近于零，其精度仅受浮点精度限制。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It calculates the average value of a function over an ellipsoidal volume\n    using Gauss-Legendre quadrature based on a rigorous derivation.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: (a,b,c), (x0,y0,z0), (Nr,Ntheta,Nphi)\n        ((1, 1, 1), (0, 0, 0), (24, 24, 24)),\n        # Case 2\n        ((2, 1, 0.5), (0.2, -0.3, 0.1), (28, 28, 32)),\n        # Case 3\n        ((0.75, 1.5, 1.25), (1.0, 2.0, -1.0), (32, 32, 36)),\n        # Case 4\n        ((3.0, 3.0, 0.2), (0, 0, 0), (36, 48, 64)),\n    ]\n\n    results = []\n    for case in test_cases:\n        params, center, orders = case\n        a, b, c = params\n        x0, y0, z0 = center\n        Nr, Ntheta, Nphi = orders\n        \n        # Calculate the numerical approximation for the current case.\n        avg_value = calculate_average_value(a, b, c, x0, y0, z0, Nr, Ntheta, Nphi)\n        results.append(avg_value)\n\n    # Format the results to 6 decimal places and print in the specified format.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef calculate_average_value(a, b, c, x0, y0, z0, Nr, Ntheta, Nphi):\n    \"\"\"\n    Numerically approximates the average value of f(x,y,z) over an ellipsoid\n    using a 3D product Gauss-Legendre rule on spherical coordinates.\n    \"\"\"\n    # 1. Get standard Gauss-Legendre nodes/weights for the interval [-1, 1]\n    r_nodes_std, r_weights = np.polynomial.legendre.leggauss(Nr)\n    theta_nodes_std, theta_weights = np.polynomial.legendre.leggauss(Ntheta)\n    phi_nodes_std, phi_weights = np.polynomial.legendre.leggauss(Nphi)\n\n    # 2. Transform nodes to their respective integration intervals:\n    # r in [0, 1], theta in [0, pi], phi in [0, 2*pi]\n    r_nodes = 0.5 * (r_nodes_std + 1)\n    theta_nodes = (np.pi / 2.0) * (theta_nodes_std + 1)\n    phi_nodes = np.pi * (phi_nodes_std + 1)\n\n    # 3. Create a grid of coordinates using broadcasting for vectorization\n    r_grid = r_nodes[:, np.newaxis, np.newaxis]\n    theta_grid = theta_nodes[np.newaxis, :, np.newaxis]\n    phi_grid = phi_nodes[np.newaxis, np.newaxis, :]\n\n    # 4. Transform from spherical (in unit ball) to Cartesian (in ellipsoid)\n    x = a * (r_grid * np.sin(theta_grid) * np.cos(phi_grid)) + x0\n    y = b * (r_grid * np.sin(theta_grid) * np.sin(phi_grid)) + y0\n    z = c * (r_grid * np.cos(theta_grid)) + z0\n\n    # 5. Evaluate the function f(x,y,z) on the grid\n    f_values = np.sin(x) * np.cos(y) * np.exp(z)\n\n    # 6. Form the full integrand for the numerical sum, including the Jacobian r^2 * sin(theta)\n    integrand = f_values * (r_grid**2) * np.sin(theta_grid)\n\n    # 7. Compute the weighted sum over all three dimensions using np.einsum for efficiency.\n    # 'i,j,k,ijk->' sums over all indices after an element-wise product of the tensors.\n    weighted_sum = np.einsum('i,j,k,ijk->', r_weights, theta_weights, phi_weights, integrand)\n    \n    # 8. Apply scaling factors to get the final average value.\n    # The factor (3*pi/16) combines the scaling from the coordinate transformations\n    # (pi^2/4) and the normalization factor for the average value (3/(4*pi)).\n    average_value = (3.0 * np.pi / 16.0) * weighted_sum\n    \n    return average_value\n\nsolve()\n```", "id": "3258887"}, {"introduction": "当我们面对更高维度的积分问题时，传统的网格类方法会遭遇所谓的“维度灾难”。本节的最后一个实践 [@problem_id:3258918] 引入了一种截然不同的方法——蒙特卡洛积分，它能有效地绕过这一障碍。我们将通过估计一个四维超球体的体积，来亲手实现并验证蒙特卡洛方法的核心思想：用随机抽样的平均值来逼近积分值，并体会其在处理高维问题时的独特优势和统计特性。", "problem": "考虑一个 $4$ 维分析单元：半径为 $R$ 的 $4$ 维球（超球面）的体积。该体积可以表示为指示函数在 $\\mathbb{R}^4$ 上的多重积分，并使用蒙特卡洛积分进行估计。您的任务是设计并实现一个完整的程序，该程序使用蒙特卡洛积分数值化地估计该体积，并将其与从经过充分验证的通用公式推导出的解析结果进行比较。\n\n从以下基本依据开始：\n- 可测区域 $\\Omega \\subset \\mathbb{R}^d$ 的体积等于其指示函数 $I_{\\Omega}(\\mathbf{x})$ 在 $\\mathbb{R}^d$ 上的积分，即 $\\mathrm{Vol}(\\Omega) = \\int_{\\mathbb{R}^d} I_{\\Omega}(\\mathbf{x}) \\, d\\mathbf{x}$，其中如果 $\\mathbf{x} \\in \\Omega$，则 $I_{\\Omega}(\\mathbf{x}) = 1$，否则 $I_{\\Omega}(\\mathbf{x}) = 0$。\n- 蒙特卡洛积分通过从一个测度有限为 $|D|$ 的域 $D$ 中均匀抽样 $\\mathbf{X}_1,\\dots,\\mathbf{X}_N$ 来估计 $\\int_{D} f(\\mathbf{x}) \\, d\\mathbf{x}$，并计算 $\\widehat{I}_N = |D|\\cdot \\frac{1}{N}\\sum_{i=1}^{N} f(\\mathbf{X}_i)$。\n- 半径为 $R$ 的 $n$ 维球体积的经过充分验证的通用公式是 $V_n(R) = \\dfrac{\\pi^{n/2} R^n}{\\Gamma\\!\\left(\\frac{n}{2}+1\\right)}$，其中 $\\Gamma$ 是伽马函数。\n\n程序中要完成的任务：\n1. 将半径为 $R$ 的 $4$ 维球的体积表示为指示函数在边界超立方体 $D = [-R,R]^4$ 上的积分，并设计一个蒙特卡洛估计器，使用从 $D$ 中均匀抽取的 $N$ 个独立同分布样本来估计该积分。\n2. 使用通用的 $n$ 维球公式和伽马函数的性质，推导维度 $n=4$ 时精确体积关于 $R$ 的解析闭式解。\n3. 对于下方的每个测试用例，计算：\n   - 使用您的估计器计算体积的蒙特卡洛估计值 $\\widehat{V}$。\n   - 精确的解析体积 $V_{\\text{exact}}$。\n   - 按如下方式定义的误差度量 $E$：\n     - 如果 $V_{\\text{exact}} > 0$，使用相对误差 $E = \\dfrac{|\\widehat{V} - V_{\\text{exact}}|}{V_{\\text{exact}}}$。\n     - 如果 $V_{\\text{exact}} = 0$，使用绝对误差 $E = |\\widehat{V} - V_{\\text{exact}}|$。\n   - 将每个误差 $E$ 四舍五入到 $6$ 位小数。\n\n实现要求：\n- 程序必须是单个独立的脚本，仅使用 Python 标准库和 NumPy（Numerical Python）库。\n- 程序不得读取任何输入；它必须对下面的测试套件进行硬编码，并产生单行输出。\n- 必须通过使用提供的种子初始化伪随机数生成器来确保随机性是可复现的。\n\n测试套件：\n- 用例 $1$：$R = 1.0$, $N = 200000$, $\\text{seed} = 12345$。\n- 用例 $2$：$R = 0.0$, $N = 10000$, $\\text{seed} = 2023$。\n- 用例 $3$：$R = 1.0$, $N = 1$, $\\text{seed} = 7$。\n- 用例 $4$：$R = 1.5$, $N = 150000$, $\\text{seed} = 314159$。\n- 用例 $5$：$R = 2.0$, $N = 120000$, $\\text{seed} = 424242$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含测试用例的误差，格式为方括号括起来的逗号分隔列表，顺序与上面列出的用例相同，每个误差四舍五入到 $6$ 位小数，例如 $[e_1,e_2,e_3,e_4,e_5]$，其中每个 $e_i$ 是一个十进制数。", "solution": "该问题要求使用蒙特卡洛积分对半径为 $R$ 的 $4$ 维球（超球面）的体积进行数值估计。此估计值将与精确的解析体积进行比较，以计算误差度量。该过程涉及三个主要步骤：推导体积的解析公式，设计蒙特卡洛估计器，以及为一组给定的测试用例实现计算。\n\n### 1. 4维球的解析体积\n\n问题提供了半径为 $R$ 的 $n$ 维球体积的通用公式：\n$$V_n(R) = \\frac{\\pi^{n/2} R^n}{\\Gamma\\left(\\frac{n}{2}+1\\right)}$$\n其中 $\\Gamma(z)$ 是伽马函数。\n\n对于我们的具体情况，维度为 $n=4$。将 $n=4$ 代入公式可得：\n$$V_4(R) = \\frac{\\pi^{4/2} R^4}{\\Gamma\\left(\\frac{4}{2}+1\\right)} = \\frac{\\pi^2 R^4}{\\Gamma(2+1)} = \\frac{\\pi^2 R^4}{\\Gamma(3)}$$\n伽马函数具有一个性质，即对于任何正整数 $k$，$\\Gamma(k) = (k-1)!$。因此，对于 $k=3$：\n$$\\Gamma(3) = (3-1)! = 2! = 2 \\cdot 1 = 2$$\n将此结果代回体积公式，得到半径为 $R$ 的 $4$ 维球体积的精确解析表达式：\n$$V_{\\text{exact}} = V_4(R) = \\frac{\\pi^2 R^4}{2}$$\n\n### 2. 蒙特卡洛估计器设计\n\n区域 $\\Omega \\subset \\mathbb{R}^4$ 的体积可以表示为其指示函数 $I_{\\Omega}(\\mathbf{x})$ 的积分：\n$$V = \\int_{\\mathbb{R}^4} I_{\\Omega}(\\mathbf{x}) \\, d\\mathbf{x}$$\n其中，如果 $\\mathbf{x} \\in \\Omega$，则 $I_{\\Omega}(\\mathbf{x}) = 1$，否则 $I_{\\Omega}(\\mathbf{x}) = 0$。对于一个以原点为中心、半径为 $R$ 的 $4$ 维球，该区域为 $\\Omega = \\{ \\mathbf{x} \\in \\mathbb{R}^4 : \\|\\mathbf{x}\\|_2 \\le R \\}$，或者 $\\Omega = \\{ (x_1, x_2, x_3, x_4) : x_1^2 + x_2^2 + x_3^2 + x_4^2 \\le R^2 \\}$。\n\n为了应用蒙特卡洛积分，我们选择一个简单的抽样域 $D$，它包含 $\\Omega$ 并且其体积 $|D|$ 是已知的。一个自然的选择是超立方体 $D = [-R, R]^4$。这个超立方体的体积是：\n$$|D| = (R - (-R))^4 = (2R)^4 = 16R^4$$\n$\\Omega$ 的体积积分可以在这个域 $D$ 上重写为：\n$$V = \\int_{D} I_{\\Omega}(\\mathbf{x}) \\, d\\mathbf{x}$$\n因为对于任何在 $\\Omega$ 之外的 $\\mathbf{x}$（因此也包括任何在 $D \\setminus \\Omega$ 中的 $\\mathbf{x}$），都有 $I_{\\Omega}(\\mathbf{x})=0$。\n\n蒙特卡洛方法通过从 $D$ 中独立且均匀地抽取 $N$ 个点 $\\mathbf{X}_1, \\dots, \\mathbf{X}_N$ 来估计此积分。该积分的估计器由下式给出：\n$$\\widehat{V} = |D| \\cdot \\frac{1}{N} \\sum_{i=1}^N I_{\\Omega}(\\mathbf{X}_i)$$\n设 $N_{in}$ 为落在超球面 $\\Omega$ 内部或边界上的抽样点数量。这个计数恰好是 $N_{in} = \\sum_{i=1}^N I_{\\Omega}(\\mathbf{X}_i)$。那么体积的估计器可以写为：\n$$\\widehat{V} = |D| \\cdot \\frac{N_{in}}{N} = 16R^4 \\cdot \\frac{N_{in}}{N}$$\n这是超球体的体积与超立方体体积的比值，通过“命中”样本数与总样本数的比率来近似，再乘以超立方体的体积。\n\n对于 $R=0$ 的特殊情况，超球面是一个单点，其 $V_{\\text{exact}}=0$。边界框 $D = [0,0]^4$ 的体积 $|D|$ 也为 $0$，估计器正确地得出 $\\widehat{V}=0$。\n\n### 3. 计算过程和误差度量\n\n对于每个由参数 $(R, N, \\text{seed})$ 定义的测试用例，执行以下过程：\n1.  **初始化RNG**：使用给定的 `seed` 为伪随机数生成器设定种子，以确保可复现性。\n2.  **计算精确体积**：使用公式 $V_4(R) = \\frac{1}{2}\\pi^2 R^4$ 计算 $V_{\\text{exact}}$。\n3.  **生成样本**：生成 $N$ 个随机向量 $\\mathbf{X}_i$，每个向量有 $4$ 个分量。每个分量都从区间 $[-R, R]$ 上的均匀分布中抽取。\n4.  **统计“命中”数**：对于每个样本 $\\mathbf{X}_i = (x_{i1}, x_{i2}, x_{i3}, x_{i4})$，我们通过测试条件 $x_{i1}^2 + x_{i2}^2 + x_{i3}^2 + x_{i4}^2 \\le R^2$ 来检查它是否位于 $4$ 维球内。满足此条件的样本数量 $N_{in}$ 被统计下来。\n5.  **计算蒙特卡洛估计值**：使用公式 $\\widehat{V} = 16R^4 \\cdot (N_{in} / N)$ 计算估计体积 $\\widehat{V}$。如果 $R=0$，这个计算是平凡的，因为 $\\widehat{V}=0$。\n6.  **计算误差**：根据 $V_{\\text{exact}}$ 的值计算误差度量 $E$：\n    -   如果 $V_{\\text{exact}} > 0$：相对误差计算为 $E = \\dfrac{|\\widehat{V} - V_{\\text{exact}}|}{V_{\\text{exact}}}$。\n    -   如果 $V_{\\text{exact}} = 0$：绝对误差计算为 $E = |\\widehat{V} - V_{\\text{exact}}|$。这种情况发生在 $R=0$ 时，此时 $\\widehat{V}$ 和 $V_{\\text{exact}}$ 均为 $0$，导致误差 $E=0$。\n7.  **存储结果**：将计算出的误差 $E$ 四舍五入到 $6$ 位小数。\n\n对所有测试用例重复此过程，并将得到的四舍五入后的误差列表格式化为最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of estimating the volume of a 4D ball using Monte Carlo integration\n    and comparing it to the analytical result for a suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (R, N, seed)\n        (1.0, 200000, 12345),\n        (0.0, 10000, 2023),\n        (1.0, 1, 7),\n        (1.5, 150000, 314159),\n        (2.0, 120000, 424242),\n    ]\n\n    results = []\n    for R, N, seed in test_cases:\n        # Task 2: Calculate the exact analytical volume V_exact.\n        # The volume of an n-ball is V_n(R) = (pi^(n/2) * R^n) / Gamma(n/2 + 1).\n        # For n=4, this simplifies to V_4(R) = (pi^2 * R^4) / Gamma(3) = (pi^2 * R^4) / 2.\n        v_exact = (np.pi**2 * R**4) / 2.0\n\n        # Task 1: Design and run the Monte Carlo estimator.\n        \n        # Initialize the pseudorandom number generator for reproducibility.\n        rng = np.random.default_rng(seed)\n\n        v_hat = 0.0\n        # The Monte Carlo simulation is only meaningful for R > 0.\n        # If R = 0, the volume of the ball and bounding box are both 0.\n        if R > 0.0:\n            # Generate N random points in a 4-dimensional space.\n            # The points are sampled from a hypercube D = [-R, R]^4.\n            # rng.uniform generates values in [low, high). Here, [-R, R).\n            # The shape (N, 4) creates N points, each with 4 coordinates.\n            points = rng.uniform(low=-R, high=R, size=(N, 4))\n\n            # Calculate the squared Euclidean distance from the origin for each point.\n            # This is more efficient than calculating the Euclidean distance as it avoids sqrt.\n            # np.sum(points**2, axis=1) calculates x1^2+x2^2+x3^2+x4^2 for each point.\n            squared_distances = np.sum(points**2, axis=1)\n\n            # Count the number of points that fall inside or on the surface of the 4-ball.\n            # The condition is ||x||^2 = R^2.\n            n_in = np.sum(squared_distances = R**2)\n\n            # The volume of the sampling hypercube D = [-R, R]^4 is (2R)^4.\n            volume_of_domain = (2.0 * R)**4\n\n            # The Monte Carlo estimate is the volume of the sampling domain\n            # times the ratio of points inside the hypersphere to the total number of points.\n            v_hat = volume_of_domain * (n_in / N)\n        \n        # Task 3: Compute the error metric E.\n        error = 0.0\n        if v_exact > 0:\n            # Relative error\n            error = np.abs(v_hat - v_exact) / v_exact\n        else:\n            # Absolute error (for the R=0 case)\n            error = np.abs(v_hat - v_exact)\n        \n        # Round the error to 6 decimal places.\n        rounded_error = round(error, 6)\n        results.append(str(rounded_error))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3258918"}]}