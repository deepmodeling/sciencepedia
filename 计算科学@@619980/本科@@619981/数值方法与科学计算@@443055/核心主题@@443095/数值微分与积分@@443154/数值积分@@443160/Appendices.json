{"hands_on_practices": [{"introduction": "要真正掌握数值积分，我们必须从基础开始。第一个实践将超越简单地应用公式，挑战你从分段线性插值这一基本原理出发，构建复合梯形法则。通过亲手实现该法则，并在已知性质的函数上进行测试 [@problem_id:3214972]，你将具体理解为何它对线性函数是精确的，以及当函数曲率增加时其误差如何表现。", "problem": "你需要编写一个完整、可运行的程序，从第一性原理出发，构建并研究复合梯形数值积分法则，验证其对于线性函数的精确性，并量化当加入小的二次曲率时误差如何增长。其基础必须是 Riemann 积分的定义以及在均匀划分上对被积函数进行的分段线性插值。在一个划分为 $\\,n\\,$ 个等宽子区间（宽度 $\\,h = (B-A)/n\\,$）的区间 $\\,[A,B]\\,$ 上，复合梯形法则的定义如下：在每个子区间 $\\,[x_i, x_{i+1}]\\,$（其中 $\\,x_i = A + i h\\,$）上，构造一条唯一的直线，该直线在端点 $\\,x_i\\,$ 和 $\\,x_{i+1}\\,$ 处对被积函数进行插值；然后在 $\\,[x_i, x_{i+1}]\\,$ 上对该直线进行精确积分；最后将所有子区间上的这些贡献值相加。你的程序必须直接实现此定义，不得调用任何封闭形式的梯形求和公式。\n\n任务如下。\n\n1. 验证对线性函数的精确性。对于形式为 $\\,f(x) = a x + b\\,$ 的函数，精确性意味着复合梯形法则对于任何 $\\,n \\ge 1\\,$ 都能返回积分 $\\,\\int_A^B f(x)\\,dx\\,$ 的精确值。使用 $\\,10^{-12}\\,$ 的绝对差容差来判断精确性。\n\n2. 量化当加入小的二次曲率时误差的增长。考虑形式为 $\\,f(x) = a x + b + \\varepsilon x^2\\,$ 且 $\\,\\varepsilon\\,$ 很小的函数。计算绝对误差 $\\;E = \\left|\\text{composite\\_trapezoid}(f;[A,B],n) - \\int_A^B f(x)\\,dx\\right|\\;$，并研究 $\\,E\\,$ 如何依赖于 $\\,\\varepsilon\\,$、区间长度 $\\,B-A\\,$ 以及子区间数量 $\\,n\\,$。\n\n你的程序必须使用一个确定性播种的伪随机数生成器以确保可复现性。使用种子 $\\,1729\\,$ 初始化生成器，并按照下文规定，从区间 $\\,[-3,3]\\,$ 中独立均匀地抽取 $\\,a\\,$ 和 $\\,b\\,$。所有角度（如果出现）都必须以弧度为单位；然而，本问题不涉及物理单位或角度。\n\n实现以下测试套件，并严格按照规定生成输出。对于每个积分，使用精确的反导数来计算 $\\,\\int_A^B f(x)\\,dx\\,$：\n$$\n\\int_A^B \\big(a x + b + \\varepsilon x^2\\big)\\,dx \\;=\\; \\frac{a}{2}\\,(B^2 - A^2) \\;+\\; b\\,(B - A) \\;+\\; \\frac{\\varepsilon}{3}\\,(B^3 - A^3).\n$$\n\n测试套件：\n\n- 线性精确性测试（生成布尔值）：\n  - 案例 L1：函数 $\\,f(x) = 0\\cdot x + 1\\,$，区间 $\\,[A,B]=[0,1]\\,$，检查 $\\,n \\in \\{1,5,13\\}\\,$。\n  - 案例 L2：从已播种的生成器中抽取 $\\,a\\,$ 和 $\\,b\\,$，记为 $\\,a_1\\,$ 和 $\\,b_1\\,$，其中 $\\,a_1,b_1 \\sim \\mathcal{U}([-3,3])\\,$；设函数 $\\,f(x) = a_1 x + b_1\\,$，区间 $\\,[A,B]=[0,1]\\,$，检查 $\\,n \\in \\{1,5,13\\}\\,$。\n  - 案例 L3：从同一生成器中再抽取一对独立的 $\\,a_2\\,$ 和 $\\,b_2\\,$；设函数 $\\,f(x) = a_2 x + b_2\\,$，区间 $\\,[A,B]=[-2,3]\\,$，检查 $\\,n \\in \\{2,7,17\\}\\,$。\n\n- 曲率误差测试（生成浮点数）：\n  对于所有曲率测试，重用案例 L2 中的第一组随机线性系数 $\\,a_1\\,$ 和 $\\,b_1\\,$，并加上曲率 $\\,\\varepsilon x^2\\,$.\n  - 案例 C1：$\\,\\varepsilon = 10^{-3}\\,$, $\\,[A,B]=[0,1]\\,$, $\\,n=10\\,$. 以浮点数形式输出 $\\,E\\,$。\n  - 案例 C2：与案例 C1 相同，但 $\\,n=20\\,$. 以浮点数形式输出 $\\,E\\,$。\n  - 案例 C3：以浮点数形式输出比率 $\\,E_{\\text{C1}} / E_{\\text{C2}}\\,$。\n  - 案例 C4：$\\,\\varepsilon = 5\\cdot 10^{-3}\\,$, $\\,[A,B]=[0,1]\\,$, $\\,n=20\\,$. 以浮点数形式输出比率 $\\,E(\\varepsilon=5\\cdot 10^{-3}) / E(\\varepsilon=10^{-3})\\,$。\n  - 案例 C5：$\\,\\varepsilon = 10^{-3}\\,$, $\\,[A,B]=[-1,1]\\,$, $\\,n=40\\,$. 以浮点数形式输出 $\\,E\\,$。\n  - 案例 C6：$\\,\\varepsilon = 10^{-3}\\,$, $\\,[A,B]=[2,5]\\,$, $\\,n=30\\,$. 以浮点数形式输出 $\\,E\\,$。\n  - 案例 C7 (边缘情况)：$\\,\\varepsilon = 10^{-12}\\,$, $\\,[A,B]=[0,1]\\,$, $\\,n=10\\,$. 以浮点数形式输出 $\\,E\\,$。\n\n程序输出格式：\n\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须按顺序包含案例 L1–L3 的三个布尔值，以及案例 C1–C7 的七个浮点数。例如，一个带有占位符的输出行看起来像\n$\\,\\big[\\text{bool\\_L1},\\text{bool\\_L2},\\text{bool\\_L3},E_{\\text{C1}},E_{\\text{C2}},\\text{ratio\\_C3},\\text{ratio\\_C4},E_{\\text{C5}},E_{\\text{C6}},E_{\\text{C7}}\\big]\\,$.\n\n所有计算都必须以纯数学术语进行，不带任何物理单位。通过严格遵守指定的随机种子和生成过程，确保数值结果是确定性的。", "solution": "该问题要求从第一性原理出发，构建并分析复合梯形数值积分法则。这需要我们不从其最终的便捷求和公式，而是从其基本定义来实现该法则：即通过一系列分段线性函数来近似被积函数，并对这些近似函数进行积分。该分析将验证该法则对于线性函数的精确性，并量化其对于带二次曲率的函数的误差。\n\n定积分 $\\int_A^B f(x) dx$ 表示函数 $f(x)$ 从 $x=A$ 到 $x=B$ 的曲线下面积。数值求积的核心思想是通过将区间 $[A,B]$ 划分为一个分区，并在每个子域上用一个更简单、易于积分的函数来替代可能复杂的函数 $f(x)$，从而近似这个面积。\n\n复合梯形法则首先将区间 $[A,B]$ 划分为 $n$ 个等宽子区间，宽度为 $h = (B-A)/n$。划分点由 $x_i = A + i h$ 给出，其中 $i = 0, 1, \\dots, n$。在每个子区间 $[x_i, x_{i+1}]$ 上，函数 $f(x)$ 由一条唯一的直线 $p_i(x)$ 近似，该直线穿过该子区间上曲线的两个端点，即 $(x_i, f(x_i))$ 和 $(x_{i+1}, f(x_{i+1}))$。这是 $f(x)$ 在节点 $x_i$ 和 $x_{i+1}$ 处的线性插值函数。\n\n这条直线 $p_i(x)$ 的方程是：\n$$\np_i(x) = f(x_i) + \\frac{f(x_{i+1}) - f(x_i)}{x_{i+1} - x_i}(x - x_i)\n$$\n$f(x)$ 在该子区间上的积分于是被 $p_i(x)$ 的积分所近似：\n$$\n\\int_{x_i}^{x_{i+1}} f(x) dx \\approx \\int_{x_i}^{x_{i+1}} p_i(x) dx\n$$\n右侧的积分是顶点为 $(x_i, 0)$、$(x_{i+1}, 0)$、$(x_{i+1}, f(x_{i+1}))$ 和 $(x_i, f(x_i))$ 的梯形的面积。我们可以直接计算这个积分：\n$$\n\\begin{aligned}\n\\int_{x_i}^{x_{i+1}} p_i(x) dx = \\int_{x_i}^{x_{i+1}} \\left( f(x_i) + \\frac{f(x_{i+1}) - f(x_i)}{h}(x - x_i) \\right) dx \\\\\n= \\left[ f(x_i)x + \\frac{f(x_{i+1}) - f(x_i)}{h} \\frac{(x-x_i)^2}{2} \\right]_{x_i}^{x_{i+1}} \\\\\n= \\left( f(x_i)x_{i+1} + \\frac{f(x_{i+1}) - f(x_i)}{h} \\frac{h^2}{2} \\right) - \\left( f(x_i)x_i + 0 \\right) \\\\\n= f(x_i)(x_{i+1} - x_i) + \\frac{f(x_{i+1}) - f(x_i)}{2}h \\\\\n= f(x_i)h + \\frac{h}{2}f(x_{i+1}) - \\frac{h}{2}f(x_i) \\\\\n= \\frac{h}{2}(f(x_i) + f(x_{i+1}))\n\\end{aligned}\n$$\n这个结果就是众所周知的梯形面积公式。复合规则是通过将这 $n$ 个子区间上的面积相加而形成的：\n$$\n\\int_A^B f(x) dx \\approx \\sum_{i=0}^{n-1} \\frac{h}{2}(f(x_i) + f(x_{i+1}))\n$$\n实现将遵循此推导过程，遍历每个子区间，计算相应梯形的面积，并将这些面积累加到一个总和中。\n\n梯形法则的一个关键特性是它对线性函数是精确的。如果 $f(x) = ax + b$，函数本身就是一条直线。在任何子区间 $[x_i, x_{i+1}]$ 上的线性插值函数 $p_i(x)$ 由两个点 $(x_i, f(x_i))$ 和 $(x_{i+1}, f(x_{i+1}))$ 定义。由于这些点位于直线 $f(x)$ 上，插值函数 $p_i(x)$ 在整个子区间上与 $f(x)$ 完全相同。因此，近似函数的积分 $\\int_{x_i}^{x_{i+1}} p_i(x) dx$ 精确等于原函数的积分 $\\int_{x_i}^{x_{i+1}} f(x) dx$。这对所有子区间都成立，所以总和是精确的。这个性质与子区间的数量 $n \\ge 1$ 无关。\n\n对于非线性函数，该法则会引入误差。对于一个带有小二次分量的函数 $f(x) = ax + b + \\varepsilon x^2$，其二阶导数是常数：$f''(x) = 2\\varepsilon$。单个子区间 $[x_i, x_{i+1}]$ 上的局部误差由函数与其线性插值函数之差 $f(x) - p_i(x)$ 的积分给出。已知在宽度为 $h$ 的一个区间上，梯形法则的误差项为 $-\\frac{1}{12} f''(\\xi) h^3$，其中某个 $\\xi \\in (x_i, x_{i+1})$。当 $f''(x) = 2\\varepsilon$ 时，这个局部误差为 $-\\frac{2\\varepsilon}{12}h^3 = -\\frac{\\varepsilon}{6}h^3$。总误差是这 $n$ 个区间上所有局部误差之和：\n$$\nE = \\sum_{i=0}^{n-1} \\left( -\\frac{\\varepsilon}{6}h^3 \\right) = n \\left( -\\frac{\\varepsilon}{6}h^3 \\right)\n$$\n代入 $h = (B-A)/n$，我们得到全局误差：\n$$\nE = n \\left( -\\frac{\\varepsilon}{6}\\left(\\frac{B-A}{n}\\right)^3 \\right) = -\\frac{\\varepsilon(B-A)^3}{6n^2}\n$$\n绝对误差为 $|E| = \\frac{|\\varepsilon|(B-A)^3}{6n^2}$。这个理论结果预测，误差与曲率的大小 $|\\varepsilon|$ 成正比，与子区间数量 $n$ 的平方成反比。测试案例旨在验证这些关系。例如，将 $n$ 加倍应使误差减少 $2^2=4$ 倍。将 $\\varepsilon$ 乘以一个因子 $k$ 应使误差也乘以相同的因子 $k$。\n\n程序将实现这些原理，为指定的测试套件执行计算，以生成所需的布尔值和浮点数结果，并通过一个已播种的随机数生成器来遵守确定性设置。用于验证的精确积分使用提供的反导数计算：$\\int_A^B (ax + b + \\varepsilon x^2)dx = \\frac{a}{2}(B^2 - A^2) + b(B-A) + \\frac{\\varepsilon}{3}(B^3 - A^3)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and studies the composite trapezoidal rule, verifying its\n    properties on linear and nearly-linear functions.\n    \"\"\"\n\n    def composite_trapezoid(f, A, B, n):\n        \"\"\"\n        Computes the definite integral of f from A to B using the composite\n        trapezoidal rule with n subintervals, implemented from first principles.\n        \"\"\"\n        h = (B - A) / n\n        total_integral = 0.0\n        for i in range(n):\n            x_i = A + i * h\n            x_i1 = A + (i + 1) * h\n            y_i = f(x_i)\n            y_i1 = f(x_i1)\n            # The integral of the unique line connecting (x_i, y_i) and (x_i1, y_i1)\n            # over [x_i, x_i1] is the area of a trapezoid.\n            sub_integral = h * (y_i + y_i1) / 2.0\n            total_integral += sub_integral\n        return total_integral\n\n    def exact_integral_eval(a, b, eps, A, B):\n        \"\"\"\n        Computes the exact integral of f(x) = ax + b + eps*x^2 from A to B.\n        \"\"\"\n        term_a = a / 2.0 * (B**2 - A**2)\n        term_b = b * (B - A)\n        term_eps = eps / 3.0 * (B**3 - A**3)\n        return term_a + term_b + term_eps\n\n    results = []\n    TOL = 1e-12\n    SEED = 1729\n    rng = np.random.default_rng(seed=SEED)\n\n    # --- Linear exactness tests ---\n    # Case L1\n    a, b, eps = 0.0, 1.0, 0.0\n    A, B = 0.0, 1.0\n    ns_L1 = [1, 5, 13]\n    f_L1 = lambda x: a * x + b\n    exact_L1 = exact_integral_eval(a, b, eps, A, B)\n    is_exact_L1 = all(abs(composite_trapezoid(f_L1, A, B, n) - exact_L1)  TOL for n in ns_L1)\n    results.append(is_exact_L1)\n\n    # Case L2\n    a1, b1 = rng.uniform(-3, 3, 2)\n    eps = 0.0\n    A, B = 0.0, 1.0\n    ns_L2 = [1, 5, 13]\n    f_L2 = lambda x: a1 * x + b1\n    exact_L2 = exact_integral_eval(a1, b1, eps, A, B)\n    is_exact_L2 = all(abs(composite_trapezoid(f_L2, A, B, n) - exact_L2)  TOL for n in ns_L2)\n    results.append(is_exact_L2)\n\n    # Case L3\n    a2, b2 = rng.uniform(-3, 3, 2)\n    eps = 0.0\n    A, B = -2.0, 3.0\n    ns_L3 = [2, 7, 17]\n    f_L3 = lambda x: a2 * x + b2\n    exact_L3 = exact_integral_eval(a2, b2, eps, A, B)\n    is_exact_L3 = all(abs(composite_trapezoid(f_L3, A, B, n) - exact_L3)  TOL for n in ns_L3)\n    results.append(is_exact_L3)\n\n    # --- Curvature error tests ---\n    # Constants for curvature tests reuse a1, b1 from L2.\n    a, b = a1, b1\n\n    # Case C1\n    eps_C1 = 1e-3\n    A_C1, B_C1 = 0.0, 1.0\n    n_C1 = 10\n    f_C1 = lambda x: a * x + b + eps_C1 * x**2\n    num_C1 = composite_trapezoid(f_C1, A_C1, B_C1, n_C1)\n    exact_C1 = exact_integral_eval(a, b, eps_C1, A_C1, B_C1)\n    E_C1 = abs(num_C1 - exact_C1)\n    results.append(E_C1)\n    \n    # Case C2\n    eps_C2 = 1e-3\n    A_C2, B_C2 = 0.0, 1.0\n    n_C2 = 20\n    f_C2 = lambda x: a * x + b + eps_C2 * x**2\n    num_C2 = composite_trapezoid(f_C2, A_C2, B_C2, n_C2)\n    exact_C2 = exact_integral_eval(a, b, eps_C2, A_C2, B_C2)\n    E_C2 = abs(num_C2 - exact_C2)\n    results.append(E_C2)\n    \n    # Case C3\n    ratio_C3 = E_C1 / E_C2\n    results.append(ratio_C3)\n    \n    # Case C4\n    eps_C4 = 5e-3\n    A_C4, B_C4 = 0.0, 1.0\n    n_C4 = 20\n    f_C4 = lambda x: a * x + b + eps_C4 * x**2\n    num_C4 = composite_trapezoid(f_C4, A_C4, B_C4, n_C4)\n    exact_C4 = exact_integral_eval(a, b, eps_C4, A_C4, B_C4)\n    E_C4 = abs(num_C4 - exact_C4)\n    ratio_C4 = E_C4 / E_C2 # Compare with C2 error (same A,B,n, different eps)\n    results.append(ratio_C4)\n\n    # Case C5\n    eps_C5 = 1e-3\n    A_C5, B_C5 = -1.0, 1.0\n    n_C5 = 40\n    f_C5 = lambda x: a * x + b + eps_C5 * x**2\n    num_C5 = composite_trapezoid(f_C5, A_C5, B_C5, n_C5)\n    exact_C5 = exact_integral_eval(a, b, eps_C5, A_C5, B_C5)\n    E_C5 = abs(num_C5 - exact_C5)\n    results.append(E_C5)\n\n    # Case C6\n    eps_C6 = 1e-3\n    A_C6, B_C6 = 2.0, 5.0\n    n_C6 = 30\n    f_C6 = lambda x: a * x + b + eps_C6 * x**2\n    num_C6 = composite_trapezoid(f_C6, A_C6, B_C6, n_C6)\n    exact_C6 = exact_integral_eval(a, b, eps_C6, A_C6, B_C6)\n    E_C6 = abs(num_C6 - exact_C6)\n    results.append(E_C6)\n    \n    # Case C7\n    eps_C7 = 1e-12\n    A_C7, B_C7 = 0.0, 1.0\n    n_C7 = 10\n    f_C7 = lambda x: a * x + b + eps_C7 * x**2\n    num_C7 = composite_trapezoid(f_C7, A_C7, B_C7, n_C7)\n    exact_C7 = exact_integral_eval(a, b, eps_C7, A_C7, B_C7)\n    E_C7 = abs(num_C7 - exact_C7)\n    results.append(E_C7)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3214972"}, {"introduction": "标准求积法则假定被积函数是良态的，但科学与工程中的许多问题都涉及奇点。本练习介绍了一种强大的半解析技术——“减去奇点法”——来处理这种情况 [@problem_id:2180787]。你将学习如何分离出被积函数中有问题的部分，对其进行解析积分，从而留下一个光滑、规则的函数交由数值方法精确处理，这展示了分析方法与数值方法之间完美的协同作用。", "problem": "考虑瑕积分 $I = \\int_0^{\\pi/2} \\frac{dx}{\\sqrt{\\sin(x)}}$。由于被积函数在积分下限 $x=0$ 处具有奇点，该积分对于标准的数值求积方法具有挑战性。\n\n计算此类积分的一个强大技巧是“减去奇点法”。该方法将原被积函数 $f(x)$ 分裂为两部分：一个捕捉了问题行为但可解析积分的奇异部分 $f_{sing}(x)$，以及一个适合数值积分的正则（良态）部分 $f_{reg}(x) = f(x) - f_{sing}(x)$。于是原积分表示为：\n$$I = \\int_0^{\\pi/2} f_{reg}(x) \\,dx + \\int_0^{\\pi/2} f_{sing}(x) \\,dx$$\n\n你的任务是应用此技巧。首先，通过使用 $\\sin(x)$ 的 Maclaurin 级数的主阶项来近似小 $x$ 时的被积函数，从而确定一个合适的函数 $f_{sing}(x)$。接下来，解析地计算这个奇异部分的积分，我们称之为 $I_{sing} = \\int_0^{\\pi/2} f_{sing}(x) \\,dx$。\n\n为解决此问题，假设正则部分的积分已通过数值方法精确计算，得到：\n$$ \\int_0^{\\pi/2} \\left( \\frac{1}{\\sqrt{\\sin(x)}} - f_{sing}(x) \\right) dx \\approx 0.1154 $$\n\n使用你得到的 $I_{sing}$ 的解析结果和给定的正则部分的数值，确定原积分 $I$ 的值。将你的最终答案四舍五入到四位有效数字。", "solution": "我们已知瑕积分 $I=\\int_{0}^{\\pi/2} \\frac{dx}{\\sqrt{\\sin(x)}}$ 在 $x=0$ 处有一个可积奇点。为了应用减去奇点法，我们使用 $\\sin(x)$ 的 Maclaurin 级数的主阶项来近似 $x=0$ 附近的被积函数。\n\n$\\sin(x)$ 的 Maclaurin 展开式为\n$$\n\\sin(x)=x-\\frac{x^{3}}{3!}+O(x^{5}).\n$$\n对于小的 $x$，其主阶行为是 $\\sin(x)\\sim x$。因此，\n$$\n\\frac{1}{\\sqrt{\\sin(x)}}\\sim \\frac{1}{\\sqrt{x}} \\quad \\text{当 } x\\to 0^{+} \\text{ 时}.\n$$\n奇异部分的一个合适选择是\n$$\nf_{\\text{sing}}(x)=\\frac{1}{\\sqrt{x}}.\n$$\n那么正则部分是\n$$\nf_{\\text{reg}}(x)=\\frac{1}{\\sqrt{\\sin(x)}}-\\frac{1}{\\sqrt{x}}.\n$$\n为了验证 $f_{\\text{reg}}$ 在 $x=0$ 处是良态的，我们写出\n$$\n\\frac{1}{\\sqrt{\\sin(x)}}=\\frac{1}{\\sqrt{x}}\\frac{1}{\\sqrt{1-\\frac{x^{2}}{6}+O(x^{4})}}\n=\\frac{1}{\\sqrt{x}}\\left(1+\\frac{1}{2}\\left(\\frac{x^{2}}{6}\\right)+O(x^{4})\\right)\n=\\frac{1}{\\sqrt{x}}+\\frac{1}{12}x^{3/2}+O(x^{7/2}),\n$$\n所以\n$$\nf_{\\text{reg}}(x)=\\frac{1}{12}x^{3/2}+O(x^{7/2}) \\quad \\text{当 } x\\to 0^{+} \\text{ 时},\n$$\n它在 $[0,\\pi/2]$ 上是连续且可积的。\n\n接下来，我们解析地计算奇异积分\n$$\nI_{\\text{sing}}=\\int_{0}^{\\pi/2} f_{\\text{sing}}(x)\\,dx=\\int_{0}^{\\pi/2} x^{-1/2}\\,dx.\n$$\n使用不定积分 $\\int x^{-1/2}\\,dx=2x^{1/2}$，我们得到\n$$\nI_{\\text{sing}}=\\left[2x^{1/2}\\right]_{0}^{\\pi/2}=2\\sqrt{\\frac{\\pi}{2}}=\\sqrt{2\\pi}.\n$$\n\n根据构造，\n$$\nI=\\int_{0}^{\\pi/2} f_{\\text{reg}}(x)\\,dx+\\int_{0}^{\\pi/2} f_{\\text{sing}}(x)\\,dx.\n$$\n我们已知数值计算结果\n$$\n\\int_{0}^{\\pi/2}\\left(\\frac{1}{\\sqrt{\\sin(x)}}-\\frac{1}{\\sqrt{x}}\\right)dx\\approx 0.1154,\n$$\n所以\n$$\nI\\approx 0.1154+\\sqrt{2\\pi}.\n$$\n数值上，$\\sqrt{2\\pi}\\approx 2.506628274631$，因此\n$$\nI\\approx 0.1154+2.506628274631=2.622028274631.\n$$\n四舍五入到四位有效数字，得到\n$$\nI\\approx 2.622.\n$$", "answer": "$$\\boxed{2.622}$$", "id": "2180787"}, {"introduction": "均匀网格通常效率低下，它在函数平坦的区域浪费计算资源，却又无法很好地解析急剧变化的特征。本实践将探索一种更智能的方法：自适应求积 [@problem_id:3214881]。通过实现一个能自动在积分误差较大处加密网格的自适应辛普森法则，你将直接比较其与均匀网格的效率和精度，从而揭示为何自适应性是现代数值积分软件的基石。", "problem": "考虑对函数 $f(x) = \\exp\\left(-100(x - 0.3)^2\\right)$ 在区间 $[0,1]$ 上的定积分进行数值计算。任务是实现两种基于辛普森法则的复合数值积分方法，并比较它们的精度和计算量：\n\n1. 一种均匀复合辛普森方法，将 $[0,1]$ 划分成 $N$ 个相等的子区间，其中 $N$ 是一个偶数。如果提供的 $N$ 是奇数，实现时必须将其加 1，以确保该法则适用。\n\n2. 一种带有局部误差控制的自适应复合辛普森方法，该方法递归地细分一个区间，直到满足指定的局部绝对容差 $\\text{tol}$。局部误差控制必须通过以下方式实现：比较一个区间上的辛普森近似值与其两半区间上的辛普森近似值之和，并以确保全局绝对误差受控的方式将容差分配到子区间。\n\n实现应基于以下基本原理：\n\n- 多项式插值：在一个区间上，通过三点构建一个二次插值多项式来近似一个足够光滑的函数，并对该插值多项式进行精确积分。\n- 基于多项式的复合求积的误差行为：对于足够光滑的函数 $f$，辛普森法则在单个区间上的截断误差与区间长度的五次方成比例，并且在均匀应用时，可获得四阶的全局收敛率。\n\n使用以误差函数表示的高斯函数的已知反导数来计算积分的真值，并将其用作误差计算的基准真值。\n\n对每种方法，报告：\n- 相对于真实积分的绝对误差。\n- 所使用的函数求值次数。\n\n程序必须实现这两种方法，并运行以下测试套件，其中每个测试用例是一个序对 $(\\text{tol}, N)$：\n\n- 测试用例 1 (正常路径): $\\text{tol} = 10^{-6}$, $N = 100$。\n- 测试用例 2 (更紧的容差，更密的网格): $\\text{tol} = 10^{-8}$, $N = 1000$。\n- 测试用例 3 (更松的容差，更粗的网格): $\\text{tol} = 10^{-4}$, $N = 10$。\n- 测试用例 4 (使用最少均匀区间的边缘情况): $\\text{tol} = 10^{-10}$, $N = 2$。\n- 测试用例 5 (非常严格的容差): $\\text{tol} = 10^{-12}$, $N = 200$。\n\n你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。此列表中的每个元素对应一个测试用例，并且其本身必须是一个包含四个值的列表，顺序如下：$[\\text{abs\\_error\\_adaptive}, \\text{evals\\_adaptive}, \\text{abs\\_error\\_uniform}, \\text{evals\\_uniform}]$。例如，两个用例的输出形式为 $[[e_1,c_1,E_1,C_1],[e_2,c_2,E_2,C_2]]$。\n\n此问题不涉及物理单位，也不需要角度或百分比。最终输出值必须是相应的实数或整数，不带任何附加文本。", "solution": "此问题旨在通过实现和比较均匀复合辛普森法则与自适应复合辛普森法则，来评估定积分 $I = \\int_0^1 f(x) \\,dx$（其中 $f(x) = \\exp\\left(-100(x - 0.3)^2\\right)$）的效率。\n\n**1. 积分的真值**\n\n高斯函数的积分可以用误差函数 $\\text{erf}(z) = \\frac{2}{\\sqrt{\\pi}} \\int_0^z e^{-t^2} \\,dt$ 来表示。\n令 $u = \\sqrt{100}(x - 0.3) = 10(x - 0.3)$，则 $du = 10 \\,dx$。\n积分上下限变换为：当 $x = 0$ 时，$u = -3$；当 $x = 1$ 时，$u = 7$。\n积分因此变为：\n$$ I = \\int_{-3}^{7} e^{-u^2} \\frac{1}{10} \\,du = \\frac{1}{10} \\int_{-3}^{7} e^{-u^2} \\,du $$\n利用误差函数的定义和性质 $\\text{erf}(-z) = -\\text{erf}(z)$，我们有：\n$$ \\int_a^b e^{-t^2} \\,dt = \\frac{\\sqrt{\\pi}}{2} \\left[ \\text{erf}(b) - \\text{erf}(a) \\right] $$\n因此，真值为：\n$$ I_{true} = \\frac{1}{10} \\left[ \\frac{\\sqrt{\\pi}}{2} (\\text{erf}(7) - \\text{erf}(-3)) \\right] = \\frac{\\sqrt{\\pi}}{20} \\left[ \\text{erf}(7) + \\text{erf}(3) \\right] $$\n该解析值将作为计算数值误差的基准。\n\n**2. 均匀复合辛普森法则**\n\n此方法将积分区间 $[a,b]$ 分为 $N$ 个等宽子区间（$N$ 为偶数），宽度 $h=(b-a)/N$。积分近似为：\n$$ S_N = \\frac{h}{3} \\left[ f(x_0) + 4\\sum_{i=1, i \\text{ odd}}^{N-1} f(x_i) + 2\\sum_{i=2, i \\text{ even}}^{N-2} f(x_i) + f(x_N) \\right] $$\n函数求值次数为 $N+1$。此方法在整个区间上均匀分布计算量，而不考虑被积函数的局部特征。\n\n**3. 自适应复合辛普森法则**\n\n自适应求积通过在函数变化剧烈的区域加密采样点来提高效率。对于被积函数在 $x=0.3$ 处的尖峰，该方法特别有效。其核心是局部误差估计和递归细分。\n\n对于一个区间 $[a, b]$，我们计算两种辛普森近似：\n- $S_1$：使用单个辛普森法则在整个区间 $[a,b]$ 上的粗略近似。\n- $S_2$：将区间一分为二，在 $[a, m]$ 和 $[m, b]$（其中 $m=(a+b)/2$）上分别使用辛普森法则，然后求和得到的精细近似。\n\n对于光滑函数，单区间辛普森法则的误差 $E_1$ 与区间宽度 $h=b-a$ 的五次方成正比，即 $E_1 \\approx C h^5$。双区间法的总误差 $E_2$ 为两个半宽区间的误差之和，即 $E_2 \\approx 2 \\times C (h/2)^5 = E_1 / 16$。\n\n真积分 $I$ 可表示为 $I = S_1 + E_1$ 和 $I = S_2 + E_2$。假设 $f^{(4)}$ 在区间内变化不大，则有：\n$$ S_2 - S_1 \\approx E_1 - E_2 \\approx 16E_2 - E_2 = 15E_2 $$\n这给出了 $S_2$ 的一个实用误差估计：$\\text{err} \\approx \\frac{|S_2 - S_1|}{15}$。\n\n自适应算法是递归的：\n1. 对于区间 $[a,b]$ 和局部容差 $\\text{tol}_{local}$，计算 $S_1$ 和 $S_2$，并估计误差 $\\text{err}$。\n2. 如果 $\\text{err}  \\text{tol}_{local}$，则认为精度已满足要求。为了获得更好的结果，返回理查森外推值 $I_{[a,b]} = S_2 + \\frac{S_2 - S_1}{15}$。\n3. 如果 $\\text{err} \\ge \\text{tol}_{local}$，则将区间细分为 $[a, m]$ 和 $[m, b]$，并在每个子区间上以 $\\text{tol}_{local}/2$ 的容差递归调用该算法。\n\n这种策略将计算量集中在函数峰值周围，而在函数平坦的区域使用较少的求值，从而在达到相同精度的前提下，显著减少总计算量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Implements and compares uniform and adaptive Simpson's rule for integrating\n    a Gaussian function, then runs a suite of test cases.\n    \"\"\"\n    \n    # 1. Define the function to integrate\n    def f(x):\n        return np.exp(-100.0 * (x - 0.3)**2)\n\n    # 2. Calculate the \"true\" value of the integral using the error function\n    # I = integral from 0 to 1 of exp(-100*(x-0.3)^2) dx\n    # Let u = 10*(x-0.3), so du = 10*dx.\n    # Limits: x=0 -> u=-3; x=1 -> u=7.\n    # I = (1/10) * integral from -3 to 7 of exp(-u^2) du\n    # Using erf(z) = (2/sqrt(pi)) * integral from 0 to z of exp(-t^2) dt\n    # Integral from a to b = sqrt(pi)/2 * (erf(b) - erf(a))\n    # I = (1/10) * sqrt(pi)/2 * (erf(7) - erf(-3))\n    #   = (sqrt(pi)/20) * (erf(7) + erf(3))\n    true_value = (math.sqrt(math.pi) / 20.0) * (math.erf(7.0) + math.erf(3.0))\n\n    # 3. Uniform Composite Simpson's Rule Implementation\n    def uniform_simpson(func, a, b, N):\n        \"\"\"\n        Calculates the definite integral using the uniform composite Simpson's rule.\n        \n        Args:\n            func: The function to integrate.\n            a, b: The interval of integration.\n            N: The number of subintervals (must be even, adjusted if not).\n            \n        Returns:\n            A tuple (integral_value, num_evaluations).\n        \"\"\"\n        if N % 2 != 0:\n            N += 1\n        \n        h = (b - a) / float(N)\n        x = np.linspace(a, b, N + 1)\n        y = func(x)\n        \n        # Simpson's formula: h/3 * (y0 + 4y1 + 2y2 + ... + 4y(N-1) + yN)\n        # Slicing: y[1:-1:2] gets odd indices, y[2:-2:2] gets even indices.\n        integral = (h / 3.0) * (y[0] + 4.0 * np.sum(y[1:-1:2]) + 2.0 * np.sum(y[2:-2:2]) + y[-1])\n        \n        evals = N + 1\n        return integral, evals\n\n    # 4. Adaptive Composite Simpson's Rule Implementation\n    def adaptive_simpson(func, a, b, tol):\n        \"\"\"\n        Wrapper for the recursive adaptive Simpson's rule integrator.\n        \n        Args:\n            func: The function to integrate.\n            a, b: The interval of integration.\n            tol: The desired absolute error tolerance.\n            \n        Returns:\n            A tuple (integral_value, num_evaluations).\n        \"\"\"\n        \n        eval_count = [0] # Use a list as a mutable counter\n\n        def f_counted(x):\n            eval_count[0] += 1\n            return func(x)\n        \n        # Initial function evaluations\n        fa = f_counted(a)\n        fm = f_counted((a + b) / 2.0)\n        fb = f_counted(b)\n        \n        integral = _adaptive_simpson_recursive(f_counted, a, b, tol, fa, fm, fb)\n        \n        return integral, eval_count[0]\n\n    def _adaptive_simpson_recursive(func, a, b, tol, fa, fm, fb):\n        \"\"\"Recursive helper for adaptive Simpson's rule.\"\"\"\n        h = b - a\n        m = (a + b) / 2.0\n        \n        # Coarse approximation (1 panel)\n        s1 = (h / 6.0) * (fa + 4.0 * fm + fb)\n        \n        # Finer approximation (2 panels) requires 2 new function evaluations\n        ml = (a + m) / 2.0\n        mr = (m + b) / 2.0\n        fml = func(ml)\n        fmr = func(mr)\n        \n        s2 = (h / 12.0) * (fa + 4.0 * fml + 2.0 * fm + 4.0 * fmr + fb)\n        \n        # Error estimation: |(S2 - S1) / 15| is an estimate of the error in S2.\n        error_estimate = abs(s2 - s1) / 15.0\n        \n        if error_estimate  tol:\n            # Richardson extrapolation for a more accurate result\n            return s2 + (s2 - s1) / 15.0\n        else:\n            # Subdivide and recurse, distributing tolerance\n            left_integral = _adaptive_simpson_recursive(func, a, m, tol / 2.0, fa, fml, fm)\n            right_integral = _adaptive_simpson_recursive(func, m, b, tol / 2.0, fm, fmr, fb)\n            return left_integral + right_integral\n\n    # 5. Define test cases\n    test_cases = [\n        (1e-6, 100),\n        (1e-8, 1000),\n        (1e-4, 10),\n        (1e-10, 2),\n        (1e-12, 200),\n    ]\n\n    all_results = []\n\n    # 6. Run the test suite\n    for tol, N in test_cases:\n        # Run adaptive method\n        res_adaptive, evals_adaptive = adaptive_simpson(f, 0.0, 1.0, tol)\n        error_adaptive = abs(res_adaptive - true_value)\n\n        # Run uniform method\n        res_uniform, evals_uniform = uniform_simpson(f, 0.0, 1.0, N)\n        error_uniform = abs(res_uniform - true_value)\n        \n        # Store results for this test case\n        case_result = [error_adaptive, evals_adaptive, error_uniform, evals_uniform]\n        all_results.append(case_result)\n\n    # 7. Format and print the final output\n    # The output format must be exact: [[v1,v2,v3,v4],[v5,v6,v7,v8]] with no spaces.\n    # repr() gives the correct bracket/comma structure, and .replace removes spaces.\n    output_str = repr(all_results).replace(' ', '')\n    print(output_str)\n\nsolve()\n```", "id": "3214881"}]}