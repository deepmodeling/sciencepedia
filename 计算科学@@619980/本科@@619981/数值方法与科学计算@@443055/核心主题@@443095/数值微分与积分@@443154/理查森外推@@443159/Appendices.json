{"hands_on_practices": [{"introduction": "本练习将通过一个航天工程中的实际场景，带你入门理查森外推法的核心思想。你将学习如何利用两次不同步长下的一阶精度数值模拟结果，通过简单的线性组合来消除主导误差项，从而获得一个更高精度的解。这是掌握该方法的第一步，也是最关键的一步。[@problem_id:2197893]", "problem": "一组航空航天工程师正在开发一个计算机模拟程序，用以预测一个探测器在新发现的系外行星上的最终着陆速度。该模拟采用数值积分算法来求解运动方程。已知所使用的主要数值方法的全局截断误差为一阶，通常表示为 $\\mathcal{O}(h)$，其中 $h$ 是模拟的时间步长。\n\n该团队使用不同的时间步长进行了两次模拟运行，以评估其结果的收敛性。\n1.  当时间步长为 $h_1 = 0.20$ 秒时，模拟预测的最终着陆速度为 $V(h_1) = 15.60$ m/s。\n2.  当时间步长减小到 $h_2 = 0.10$ 秒时，模拟得出了一个更精确的着陆速度 $V(h_2) = 15.85$ m/s。\n\n为了在不增加进行更小时间步长模拟的计算成本的情况下获得更准确的预测，该团队决定使用理查森外推法。请应用该方法于这两个可用的速度估算值，以计算出真实着陆速度的改进估算值。\n\n将改进后的速度最终答案以 m/s 为单位表示，并四舍五入到四位有效数字。", "solution": "设真实着陆速度为 $V$，时间步长为 $h$ 时的数值估算值为 $V(h)$。对于一阶方法，其全局截断误差模型为\n$$\nV(h) = V + C h + O(h^{2}),\n$$\n其中 $C$ 是一个与 $h$ 无关的常数。对于两个步长 $h_{1}$ 和 $h_{2}$，我们有\n$$\nV(h_{1}) = V + C h_{1} + O(h_{1}^{2}), \\quad V(h_{2}) = V + C h_{2} + O(h_{2}^{2}).\n$$\n忽略 $O(h^{2})$ 项并消去 $C$ 可得\n$$\nC \\approx \\frac{V(h_{2}) - V(h_{1})}{h_{2} - h_{1}}, \\quad V \\approx V(h_{2}) - C h_{2}.\n$$\n代入 $C$ 得到一阶方法的理查森外推公式：\n$$\nV \\approx V(h_{2}) - h_{2}\\,\\frac{V(h_{2}) - V(h_{1})}{h_{2} - h_{1}} = V(h_{2}) + \\frac{V(h_{2}) - V(h_{1})}{\\frac{h_{1}}{h_{2}} - 1}.\n$$\n当 $h_{1} = 0.20$，$h_{2} = 0.10$，$V(h_{1}) = 15.60$，以及 $V(h_{2}) = 15.85$ 时，步长比为 $r = \\frac{h_{1}}{h_{2}} = 2$，所以\n$$\nV \\approx 15.85 + \\frac{15.85 - 15.60}{2 - 1} = 15.85 + 0.25 = 16.10.\n$$\n四舍五入到四位有效数字，改进后的真实着陆速度估算值为 $16.10$。", "answer": "$$\\boxed{16.10}$$", "id": "2197893"}, {"introduction": "在应用理查森外推法时，一个关键前提是知道数值方法的收敛阶数 $p$。然而，在实际研究中，这个阶数可能未知。本练习将引导你解决这个问题，你将利用三次不同离散参数下的模拟结果，通过巧妙的数学推导来反向计算出收敛阶数 $p$。这不仅加深了你对误差模型的理解，也为你提供了一个在实践中验证算法性能的强大工具。[@problem_id:2197934]", "problem": "一位计算物理学家正在模拟一个量子点系统的基态能量。该模拟采用一种数值方法，该方法依赖于一个离散化参数 $h$，其单位为长度。真实的基态能量表示为 $E_{true}$。已知模拟返回的近似值 $E(h)$ 具有以下形式的误差展开式：\n$$E(h) = E_{true} + C h^p + \\mathcal{O}(h^q)$$\n其中 $C$ 是一个非零常数，$p$ 是该方法的主收敛阶，且 $q > p$。对于所用的小 $h$ 值，由 $\\mathcal{O}(h^q)$ 表示的高阶项可以忽略不计。\n\n为了确定该方法的性能，这位物理学家用三个不同的离散化参数值运行了模拟。获得了以下关于基态能量的结果：\n- 当参数值为 $h_0$ 时：$E(h_0) = 12.545$ meV\n- 当参数值为 $h_0/2$ 时：$E(h_0/2) = 12.785$ meV\n- 当参数值为 $h_0/4$ 时：$E(h_0/4) = 12.842$ meV\n\n仅使用这三个数据点，计算收敛阶 $p$ 的数值。将你的最终答案四舍五入到三位有效数字。", "solution": "给定高阶项可忽略的渐近误差模型，\n$$E(h)=E_{true}+C h^{p},$$\n在 $h=h_{0},\\,h_{0}/2,\\,h_{0}/4$ 处求值：\n$$E(h_{0})=E_{true}+C h_{0}^{p},$$\n$$E\\!\\left(\\frac{h_{0}}{2}\\right)=E_{true}+C h_{0}^{p} 2^{-p},$$\n$$E\\!\\left(\\frac{h_{0}}{4}\\right)=E_{true}+C h_{0}^{p} 2^{-2p}.$$\n求一阶差分以消去 $E_{true}$：\n$$\\Delta_{1}=E\\!\\left(\\frac{h_{0}}{2}\\right)-E(h_{0})=C h_{0}^{p}\\left(2^{-p}-1\\right),$$\n$$\\Delta_{2}=E\\!\\left(\\frac{h_{0}}{4}\\right)-E\\!\\left(\\frac{h_{0}}{2}\\right)=C h_{0}^{p}\\left(2^{-2p}-2^{-p}\\right).$$\n求二者之比\n$$R=\\frac{\\Delta_{2}}{\\Delta_{1}}=\\frac{2^{-2p}-2^{-p}}{2^{-p}-1}.$$\n令 $x=2^{-p}$；则\n$$R=\\frac{x^{2}-x}{x-1}=x=2^{-p},$$\n所以\n$$p=-\\frac{\\ln R}{\\ln 2}.$$\n使用给定的数据，\n$$\\Delta_{1}=12.785-12.545=0.240,\\quad \\Delta_{2}=12.842-12.785=0.057,$$\n因此\n$$R=\\frac{0.057}{0.240}=0.2375.$$\n所以，\n$$p=-\\frac{\\ln(0.2375)}{\\ln 2}=\\frac{\\ln(80/19)}{\\ln 2}\\approx 2.07400058,$$\n保留三位有效数字为 $2.07$。", "answer": "$$\\boxed{2.07}$$", "id": "2197934"}, {"introduction": "理论学习的最终目的是解决实际问题。这个综合性练习将引导你将理查森外推法应用于求解常微分方程的欧拉方法中。你将通过编写代码，从一个一阶精度的基础算法出发，构建出一个二阶精度的复合解，并在一系列测试案例中验证其有效性。这个过程将完整地展示理查森外推法在计算科学与工程领域中，作为一种“后处理”技术提升数值解精度的典型工作流程。[@problem_id:3226253]", "problem": "考虑一个常微分方程 (ODE) 的初值问题 (IVP)，其形式为 $y'(t) = f(t, y(t))$，初始条件为 $y(t_0) = y_0$。前向欧拉法源于导数作为有限差分极限的基本定义以及一阶泰勒展开的应用。在实践中，前向欧拉法通过从 $t_0$ 开始以大小为 $h$ 的步长推进解，直到达到指定的最终时间 $T$，来更新精确解 $y(t_n)$ 的近似值 $y_n$，从而在 $T$ 时刻产生一个我们记为 $y_h(T)$ 的近似值。已知在关于 $f$ 和 $y(t)$ 的标准正则性假设下，前向欧拉法的全局离散误差与步长 $h$ 呈线性相关。\n\n您的任务是：\n1. 实现一个函数，该函数使用前向欧拉法为任何给定的函数 $f(t,y)$、初始条件 $y_0$、初始时间 $t_0$、最终时间 $T$ 和均匀步长 $h$ 计算 $y_h(T)$，假设 $T - t_0$ 是 $h$ 的整数倍。\n2. 假设欧拉法在 $T$ 处的近似具有形式为 $y_h(T) = y(T) + C h + D h^2 + \\mathcal{O}(h^3)$ 的渐近误差展开，其中常数 $C$ 和 $D$ 依赖于 $f$ 和解，但不依赖于 $h$。利用输出 $y_h(T)$ 和 $y_{h/2}(T)$，推导这两个近似值的线性组合，其常数权重与 $h$ 无关，能够消除首项 $\\mathcal{O}(h)$ 误差项，并产生一个对 $y(T)$ 的 $\\mathcal{O}(h^2)$ 精度估计。然后在代码中实现这个理查森外推估计器。\n3. 对于下面的每个测试用例，计算绝对误差 $\\lvert y_{\\text{extrap}}(T) - y(T) \\rvert$，其中 $y_{\\text{extrap}}(T)$ 是您的外推估计值，$y(T)$ 是在时间 $T$ 的精确解。\n\n使用以下测试套件。在所有情况下，取 $t_0 = 0$ 并使用所提供的 $h$，使得 $(T - t_0)/h$ 为整数：\n\n- 测试 1 (正常路径，线性齐次常微分方程): $f(t,y) = y$, $y_0 = 1$, $T = 1$, $h = 0.2$。精确解是在 $t = T$ 处计算的 $y(t) = e^{t}$。\n- 测试 2 (线性非齐次常微分方程): $f(t,y) = y + t$, $y_0 = 0$, $T = 2$, $h = 0.4$。精确解是在 $t = T$ 处计算的 $y(t) = e^{t} - t - 1$。\n- 测试 3 (非线性逻辑斯谛增长): $f(t,y) = r y \\left(1 - \\frac{y}{K}\\right)$，参数为 $r = 1$ 和 $K = 10$, $y_0 = 1$, $T = 3$, $h = 0.5$。精确解是在 $t = T$ 处计算的 $y(t) = \\frac{K}{1 + A e^{-r t}}$，其中 $A = \\frac{K - y_0}{y_0}$。\n- 测试 4 (边界情况，零导数): $f(t,y) = 0$, $y_0 = 3$, $T = 1$, $h = 0.5$。精确解是在 $t = T$ 处计算的常数函数 $y(t) = 3$。\n\n您的程序应：\n- 实现前向欧拉法，为每个测试用例计算 $y_h(T)$ 和 $y_{h/2}(T)$。\n- 使用两个近似值 $y_h(T)$ 和 $y_{h/2}(T)$ 实现所推导的理查森外推估计器，以获得在 $T$ 处的 $\\mathcal{O}(h^2)$ 估计。\n- 计算并记录每个测试用例的绝对误差，四舍五入到十位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来 (例如, `\"[0.0123456789,0.0000001234,0.0012340000,0.0000000000]\"` )，列表中的条目是测试 1 到测试 4 的绝对误差，每个都四舍五入到十位小数。", "solution": "该问题被评估为有效。\n\n### 第 1 步：提取已知信息\n- **问题类型**: 常微分方程 (ODE) 的初值问题 (IVP)。\n- **ODE 形式**: $y'(t) = f(t, y(t))$。\n- **初始条件**: $y(t_0) = y_0$。\n- **数值方法**: 前向欧拉法，其中 $y_{n+1} = y_n + h f(t_n, y_n)$。\n- **最终时间 $T$ 处的近似值**: $y_h(T)$。\n- **渐近误差展开**: $y_h(T) = y(T) + C h + D h^2 + \\mathcal{O}(h^3)$。\n- **约束**: $T - t_0$ 是步长 $h$ 的整数倍。\n- **任务 1**: 实现一个用于前向欧拉法以计算 $y_h(T)$ 的函数。\n- **任务 2**: 使用 $y_h(T)$ 和 $y_{h/2}(T)$，推导并实现一个对 $y(T)$ 的 $\\mathcal{O}(h^2)$ 精度的理查森外推估计器。\n- **任务 3**: 为四个测试用例计算绝对误差 $\\lvert y_{\\text{extrap}}(T) - y(T) \\rvert$。\n- **所有用例的初始时间**: $t_0 = 0$。\n\n- **测试用例 1**:\n  - $f(t,y) = y$\n  - $y_0 = 1$\n  - $T = 1$\n  - $h = 0.2$\n  - 精确解: $y(t) = e^{t}$\n\n- **测试用例 2**:\n  - $f(t,y) = y + t$\n  - $y_0 = 0$\n  - $T = 2$\n  - $h = 0.4$\n  - 精确解: $y(t) = e^{t} - t - 1$\n\n- **测试用例 3**:\n  - $f(t,y) = r y \\left(1 - \\frac{y}{K}\\right)$，其中 $r = 1, K = 10$\n  - $y_0 = 1$\n  - $T = 3$\n  - $h = 0.5$\n  - 精确解: $y(t) = \\frac{K}{1 + A e^{-r t}}$，其中 $A = \\frac{K - y_0}{y_0}$\n\n- **测试用例 4**:\n  - $f(t,y) = 0$\n  - $y_0 = 3$\n  - $T = 1$\n  - $h = 0.5$\n  - 精确解: $y(t) = 3$\n\n### 第 2 步：使用提取的已知信息进行验证\n该问题具有科学依据、适定且客观。\n1.  **科学或事实的健全性**: 该问题建立在常微分方程数值分析的基本概念之上。前向欧拉法、其误差分析和理查森外推法是标准且数学上合理的技巧。所提供的常微分方程是教学和研究中使用的经典例子。该问题没有任何科学或事实错误。\n2.  **适定性**: 该问题是适定的。对于每个测试用例，函数 $f(t,y)$ 足够光滑（关于 $y$ 是 Lipschitz 连续的），这保证了 IVP 解的存在性和唯一性。任务定义清晰，并提供了所有必要的数据（初始条件、参数、时间间隔）。\n3.  **客观性**: 语言精确且无偏。任务是定量的，需要特定的计算，没有主观解释的余地。\n4.  **完整性**: 该问题是自包含的。它指定了 ODE、初始条件、步长、最终时间以及用于误差比较的精确解。$(T - t_0)/h$ 为整数的约束简化了实现并避免了歧义。\n\n### 第 3 步：结论与行动\n该问题是**有效的**。将提供完整的解决方案。\n\n### 基于原理的解决方案\n解决方案分三个阶段展开：首先，实现前向欧拉法；其次，推导理查森外推公式；第三，将这些方法应用于指定的测试用例以计算所需的误差。\n\n**1. 前向欧拉法**\n前向欧拉法是求解形如 $y'(t) = f(t, y(t))$ 且 $y(t_0) = y_0$ 的初值问题的一阶数值方法。它在离散时间点 $t_n = t_0 + n h$ 处近似连续解 $y(t)$，其中 $h$ 是步长。该方法源于 $y(t_{n+1})$ 在 $t_n$ 附近的一阶泰勒展开：\n$y(t_{n+1}) = y(t_n) + h y'(t_n) + \\mathcal{O}(h^2) = y(t_n) + h f(t_n, y(t_n)) + \\mathcal{O}(h^2)$。\n通过忽略 $\\mathcal{O}(h^2)$ 项，我们得到近似值 $y_n \\approx y(t_n)$ 的迭代公式：\n$$y_{n+1} = y_n + h f(t_n, y_n)$$\n从初始条件 $y_0$ 开始，我们可以对 $n = 0, 1, 2, \\dots, N-1$（其中 $N = (T-t_0)/h$）迭代应用此公式，以找到近似值 $y_N \\approx y(T)$。这定义了函数 $y_h(T)$。\n\n**2. 理查森外推法**\n理查森外推法是一种提高数值近似精度的通用技术。我们已知前向欧拉法的近似值 $y_h(T)$ 具有渐近误差展开：\n$$y_h(T) = y(T) + C h + D h^2 + \\mathcal{O}(h^3)$$\n这里，$y(T)$ 是精确解，而 $C$ 和 $D$ 是依赖于函数 $f$ 及其导数但不依赖于步长 $h$ 的常数。\n\n如果我们用减半的步长 $h/2$ 再次计算近似值，公式变为：\n$$y_{h/2}(T) = y(T) + C \\left(\\frac{h}{2}\\right) + D \\left(\\frac{h}{2}\\right)^2 + \\mathcal{O}(h^3)$$\n$$y_{h/2}(T) = y(T) + \\frac{1}{2} C h + \\frac{1}{4} D h^2 + \\mathcal{O}(h^3)$$\n我们的目标是找到 $y_h(T)$ 和 $y_{h/2}(T)$ 的一个线性组合，我们将其记为 $y_{\\text{extrap}}(T)$，它能提供一个对 $y(T)$ 更精确的估计。设 $y_{\\text{extrap}}(T) = \\alpha y_h(T) + \\beta y_{h/2}(T)$。代入误差展开式：\n$$y_{\\text{extrap}}(T) = \\alpha \\left(y(T) + C h + D h^2\\right) + \\beta \\left(y(T) + \\frac{1}{2} C h + \\frac{1}{4} D h^2\\right) + \\mathcal{O}(h^3)$$\n$$y_{\\text{extrap}}(T) = (\\alpha + \\beta) y(T) + \\left(\\alpha + \\frac{\\beta}{2}\\right) C h + \\left(\\alpha + \\frac{\\beta}{4}\\right) D h^2 + \\mathcal{O}(h^3)$$\n为了获得对 $y(T)$ 的一个 $\\mathcal{O}(h^2)$ 精度估计，我们要求 $y(T)$ 的系数为 $1$，并且首项误差项 $Ch$ 的系数为 $0$。这给出了一个关于 $\\alpha$ 和 $\\beta$ 的二元线性方程组：\n1. $\\alpha + \\beta = 1$\n2. $\\alpha + \\frac{\\beta}{2} = 0$\n从方程 (2) 中，我们得到 $\\alpha = -\\beta/2$。将其代入方程 (1) 得 $-\\beta/2 + \\beta = 1$，化简为 $\\beta/2 = 1$，所以 $\\beta = 2$。因此，$\\alpha = -1$。\n于是，外推估计器为：\n$$y_{\\text{extrap}}(T) = 2 y_{h/2}(T) - y_h(T)$$\n让我们验证这个新估计的误差：\n$$y_{\\text{extrap}}(T) - y(T) = (2 y_{h/2}(T) - y_h(T)) - y(T)$$\n$$= \\left(2\\left(y(T) + \\frac{1}{2}Ch + \\frac{1}{4}Dh^2\\right) - \\left(y(T) + Ch + Dh^2\\right)\\right) - y(T) + \\mathcal{O}(h^3)$$\n$$= (2y(T) + Ch + \\frac{1}{2}Dh^2) - y(T) - Ch - Dh^2 - y(T) + \\mathcal{O}(h^3)$$\n$$= (2-1-1)y(T) + (1-1)Ch + (\\frac{1}{2}-1)Dh^2 + \\mathcal{O}(h^3) = -\\frac{1}{2} D h^2 + \\mathcal{O}(h^3)$$\n误差确实是 $h^2$ 阶的，因此该方法成功地消除了首项误差项。\n\n**3. 计算流程**\n对于四个测试用例中的每一个，应用以下算法：\n1.  定义函数 $f(t,y)$、初始条件 $y_0, t_0$、最终时间 $T$ 和步长 $h$。\n2.  实现一个函数 `forward_euler(f, y0, t0, T, h)`，它执行迭代的欧拉更新并返回在时间 $T$ 的最终近似值。步数 $N$ 计算为整数 `(T - t0) / h`。\n3.  使用给定的步长 $h$ 计算近似值：$A_h = \\text{forward_euler}(f, y_0, t_0, T, h)$。\n4.  使用减半的步长 $h/2$ 计算近似值：$A_{h/2} = \\text{forward_euler}(f, y_0, t_0, T, h/2)$。\n5.  计算理查森外推值：$y_{\\text{extrap}}(T) = 2 A_{h/2} - A_h$。\n6.  使用为特定测试用例提供的公式计算精确解 $y(T)$。\n7.  计算绝对误差：$E = \\lvert y_{\\text{extrap}}(T) - y(T) \\rvert$。\n8.  测试用例的最终结果是这个误差，四舍五入到十位小数。对所有测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes absolute errors for Richardson-extrapolated Euler method solutions\n    for a suite of ODE test cases.\n    \"\"\"\n\n    def forward_euler(f, y0, t0, T, h):\n        \"\"\"\n        Computes the solution of an IVP y'(t) = f(t, y) with y(t0) = y0 at time T\n        using the forward Euler method with step size h.\n        \"\"\"\n        t = t0\n        y = y0\n        \n        # The problem statement guarantees (T - t0) / h is an integer.\n        # Using int() directly is safe, but rounding is more robust for floats.\n        num_steps = int(round((T - t0) / h))\n\n        for _ in range(num_steps):\n            y = y + h * f(t, y)\n            t = t + h\n        \n        return y\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"f\": lambda t, y: y,\n            \"y0\": 1.0,\n            \"t0\": 0.0,\n            \"T\": 1.0,\n            \"h\": 0.2,\n            \"exact_sol\": lambda t: np.exp(t)\n        },\n        {\n            \"f\": lambda t, y: y + t,\n            \"y0\": 0.0,\n            \"t0\": 0.0,\n            \"T\": 2.0,\n            \"h\": 0.4,\n            \"exact_sol\": lambda t: np.exp(t) - t - 1.0\n        },\n        {\n            \"f\": lambda t, y: 1.0 * y * (1.0 - y / 10.0), # r=1, K=10\n            \"y0\": 1.0,\n            \"t0\": 0.0,\n            \"T\": 3.0,\n            \"h\": 0.5,\n            \"exact_sol\": lambda t: 10.0 / (1.0 + ((10.0 - 1.0) / 1.0) * np.exp(-1.0 * t))\n        },\n        {\n            \"f\": lambda t, y: 0.0,\n            \"y0\": 3.0,\n            \"t0\": 0.0,\n            \"T\": 1.0,\n            \"h\": 0.5,\n            \"exact_sol\": lambda t: 3.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        f = case[\"f\"]\n        y0 = case[\"y0\"]\n        t0 = case[\"t0\"]\n        T = case[\"T\"]\n        h = case[\"h\"]\n        exact_sol_func = case[\"exact_sol\"]\n\n        # 1. Compute approximations with step sizes h and h/2\n        y_h = forward_euler(f, y0, t0, T, h)\n        y_h_half = forward_euler(f, y0, t0, T, h / 2.0)\n\n        # 2. Apply Richardson extrapolation\n        y_extrap = 2.0 * y_h_half - y_h\n\n        # 3. Compute the exact solution\n        y_exact = exact_sol_func(T)\n        \n        # 4. Compute the absolute error\n        abs_error = abs(y_extrap - y_exact)\n        \n        results.append(abs_error)\n\n    # Format the results as strings rounded to 10 decimal places\n    # The f-string formatting ensures trailing zeros as in the example.\n    # The rounding prior to formatting correctly handles cases near the rounding boundary.\n    results_str = [f\"{round(res, 10):.10f}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "3226253"}]}