{"hands_on_practices": [{"introduction": "我们从一个基础但至关重要的练习开始，它将理论与实践紧密结合。在本练习中，我们将利用泰勒级数展开来推导常用的二阶和四阶导数的中心差分格式。这个过程的重点是建立理论截断误差与数值实验中观察到的收敛阶之间的一致性，这是验证和调试任何数值方法的基石 [@problem_id:3238903]。", "problem": "考虑函数 $f(x) = \\exp(-x^2)$。您的任务是使用中心有限差分格式来近似高阶导数，从第一性原理推导截断误差阶，并与解析导数对比，验证观察到的收敛阶。\n\n您必须基于以下基本原则进行操作：\n- 使用 $f(x \\pm kh)$ 在点 $x = x_0$ 附近的泰勒级数展开（其中 $k \\in \\mathbb{Z}$ 且 $h > 0$ 是一个小数），来构造一致的中心有限差分导数近似。具体来说，使用泰勒展开式\n$$\nf(x_0 \\pm kh) = \\sum_{n=0}^{\\infty} \\frac{(\\pm kh)^n}{n!} f^{(n)}(x_0).\n$$\n- 使用截断误差阶的定义：如果量 $Q$ 的一个近似 $A_h$ 满足 $A_h = Q + C h^p + \\mathcal{O}(h^{p+1})$（其中常数 $C \\neq 0$），则我们称该近似为 $p$ 阶。\n- 对于误差 $E(h_1)$ 和 $E(h_2)$，使用两个步长 $h_1$ 和 $h_2$ 之间的观察阶定义如下\n$$\np_{\\mathrm{obs}} = \\frac{\\log\\big(E(h_1)/E(h_2)\\big)}{\\log(h_1/h_2)}.\n$$\n\n任务：\n1. 通过直接求导，推导函数 $f(x) = \\exp(-x^2)$ 的解析二阶和四阶导数 $f^{(2)}(x)$ 和 $f^{(4)}(x)$ 的符号表达式。\n2. 使用泰勒级数，推导以下各项的中心有限差分格式及其主截断误差项：\n   - 用于 $f^{(2)}(x_0)$ 的标准中心3点近似，\n   - 用于 $f^{(2)}(x_0)$ 的、比3点格式精度更高的中心5点近似，\n   - 用于 $f^{(4)}(x_0)$ 的中心5点近似。\n   不要假设任何预先已知的系数；通过在 $x_0$ 处匹配泰勒级数项来推导它们。\n3. 实现一个程序，在特定点上评估近似值，并通过计算与任务1中得到的解析导数的误差以及当 $h$ 减半时的误差比率得到的观察阶，来验证收敛阶。\n\n测试套件：\n- 使用网格间距序列 $h_k = 0.2 \\cdot 2^{-k}$，其中 $k \\in \\{0,1,2,3,4,5\\}$。\n- 对于下面的每种情况，计算误差 $E(h_k)$（即数值近似与 $x_0$ 处解析导数之间的绝对差值），然后使用连续的步长对 $(h_{k-1}, h_k)$ 计算观察阶 $p_k$，其中 $k \\in \\{1,2,3,4,5\\}$。\n- 为保证稳健性，将每种情况报告的观察阶定义为最后三个值 $\\{p_3, p_4, p_5\\}$ 的中位数。\n- 验证以下四种情况及其预期阶数和点：\n  - 情况 A：在 $x_0 = 0.7$ 处使用中心3点格式计算 $f^{(2)}(x_0)$，预期阶为2。\n  - 情况 B：在 $x_0 = 1.3$ 处使用中心5点格式计算 $f^{(2)}(x_0)$，预期阶为4。\n  - 情况 C：在 $x_0 = 0.0$ 处使用中心5点格式计算 $f^{(4)}(x_0)$，预期阶为2。\n  - 情况 D（边缘量级情况）：在 $x_0 = 2.0$ 处使用中心5点格式计算 $f^{(2)}(x_0)$，预期阶为4。\n\n每种情况的通过/失败标准：\n- 设 $\\tilde{p}$ 为报告的观察阶（$\\{p_3, p_4, p_5\\}$ 的中位数）。如果 $|\\tilde{p} - p_{\\mathrm{expected}}| \\le 0.3$，则该情况通过，否则失败，其中 $p_{\\mathrm{expected}}$ 是该情况的预期阶。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 [情况 A, 情况 B, 情况 C, 情况 D]，其中每个条目是该情况的布尔结果，例如“[True,True,False,True]”。\n- 该问题不需要用户输入，也不涉及物理单位或角度单位。所有数值均为无量纲值。", "solution": "该问题经评估有效，因为它在数值分析方面有科学依据，问题陈述清晰，目标明确，且没有不一致或含糊不清之处。我们继续提供完整的解决方案。\n\n解决方案分为三部分，对应于问题陈述中概述的任务。首先，我们推导所需导数的解析表达式。其次，我们使用泰勒级数推导有限差分格式及其截断误差。第三，我们概述将在最终代码中实现的数值验证过程。\n\n### 第1部分：解析导数\n\n给定函数 $f(x) = \\exp(-x^2)$。我们将通过直接微分来计算其二阶和四阶导数 $f^{(2)}(x)$ 和 $f^{(4)}(x)$。为简化中间步骤，我们使用撇号表示法（即 $f'(x)$、$f''(x)$ 等）来表示对 $x$ 的导数。\n\n一阶导数为：\n$$\nf'(x) = \\frac{d}{dx} \\exp(-x^2) = -2x \\exp(-x^2) = -2x f(x)\n$$\n\n使用乘法法则求二阶导数：\n$$\nf''(x) = \\frac{d}{dx} (-2x f(x)) = -2 f(x) - 2x f'(x)\n$$\n代入 $f'(x) = -2x f(x)$：\n$$\nf''(x) = -2 f(x) - 2x (-2x f(x)) = (-2 + 4x^2) f(x)\n$$\n因此，二阶导数的解析表达式为：\n$$\nf^{(2)}(x) = (4x^2 - 2) \\exp(-x^2)\n$$\n\n为求四阶导数，我们首先计算三阶导数：\n$$\nf'''(x) = \\frac{d}{dx} \\left( (4x^2 - 2) f(x) \\right) = (8x) f(x) + (4x^2 - 2) f'(x)\n$$\n代入 $f'(x) = -2x f(x)$：\n$$\nf'''(x) = 8x f(x) + (4x^2 - 2) (-2x f(x)) = (8x - 8x^3 + 4x) f(x) = (-8x^3 + 12x) f(x)\n$$\n\n最后，通过对 $f'''(x)$ 求导来计算四阶导数：\n$$\nf^{(4)}(x) = \\frac{d}{dx} \\left( (-8x^3 + 12x) f(x) \\right) = (-24x^2 + 12) f(x) + (-8x^3 + 12x) f'(x)\n$$\n代入 $f'(x) = -2x f(x)$：\n$$\nf^{(4)}(x) = (-24x^2 + 12) f(x) + (-8x^3 + 12x) (-2x f(x)) = (-24x^2 + 12 + 16x^4 - 24x^2) f(x)\n$$\n因此，四阶导数的解析表达式为：\n$$\nf^{(4)}(x) = (16x^4 - 48x^2 + 12) \\exp(-x^2)\n$$\n\n### 第2部分：有限差分格式与截断误差\n\n我们通过构建围绕点 $x_0$ 的泰勒级数展开的线性组合，来推导中心有限差分公式及其主截断误差项。令 $f_0^{(n)}$ 表示 $f^{(n)}(x_0)$。相关的展开式为：\n$$\nf(x_0 \\pm h) = f_0 \\pm h f_0' + \\frac{h^2}{2} f_0'' + \\frac{\\pm h^3}{6} f_0''' + \\frac{h^4}{24} f_0^{(4)} + \\frac{\\pm h^5}{120} f_0^{(5)} + \\frac{h^6}{720} f_0^{(6)} + \\mathcal{O}(h^7)\n$$\n$$\nf(x_0 \\pm 2h) = f_0 \\pm 2h f_0' + \\frac{(2h)^2}{2} f_0'' + \\frac{\\pm (2h)^3}{6} f_0''' + \\frac{(2h)^4}{24} f_0^{(4)} + \\frac{\\pm (2h)^5}{120} f_0^{(5)} + \\frac{(2h)^6}{720} f_0^{(6)} + \\mathcal{O}(h^7)\n$$\n\n**2a. 用于 $f^{(2)}(x_0)$ 的3点中心格式**\n我们寻求形式为 $\\frac{c_{-1}f(x_0-h) + c_0 f(x_0) + c_1 f(x_0+h)}{h^2}$ 的近似。对于中心格式，对称性要求 $c_{-1}=c_1$。\n考虑组合 $f(x_0+h) - 2f(x_0) + f(x_0-h)$：\n$$\n(f_0 + h f_0' + \\frac{h^2}{2} f_0'' + \\frac{h^3}{6} f_0''' + \\frac{h^4}{24} f_0^{(4)} + \\mathcal{O}(h^6)) - 2f_0 + (f_0 - h f_0' + \\frac{h^2}{2} f_0'' - \\frac{h^3}{6} f_0''' + \\frac{h^4}{24} f_0^{(4)} + \\mathcal{O}(h^6))\n$$\n合并各项，奇数次幂的导数项相互抵消：\n$$\n= (1-2+1)f_0 + (1-1)h f_0' + (\\frac{1}{2}+\\frac{1}{2})h^2 f_0'' + (\\frac{1}{6}-\\frac{1}{6})h^3 f_0''' + (\\frac{1}{24}+\\frac{1}{24})h^4 f_0^{(4)} + \\mathcal{O}(h^6)\n$$\n$$\n= h^2 f_0'' + \\frac{h^4}{12} f_0^{(4)} + \\mathcal{O}(h^6)\n$$\n两边同除以 $h^2$，我们得到近似：\n$$\n\\frac{f(x_0-h) - 2f(x_0) + f(x_0+h)}{h^2} = f_0'' + \\frac{h^2}{12} f_0^{(4)} + \\mathcal{O}(h^4)\n$$\n该格式为 $\\frac{1}{h^2}[f(x_0-h) - 2f(x_0) + f(x_0+h)]$。主截断误差为 $E_T = \\frac{h^2}{12} f_0^{(4)}$，因此该方法是 $p=2$ 阶的。\n\n**2b. 用于 $f^{(2)}(x_0)$ 的5点中心格式**\n我们寻求一个更精确的、形式为 $\\frac{1}{h^2} \\sum_{j=-2}^{2} c_j f(x_0+jh)$ 的近似。对称性意味着 $c_{-j}=c_j$。线性组合为 $c_2(f(x_0-2h)+f(x_0+2h)) + c_1(f(x_0-h)+f(x_0+h)) + c_0 f(x_0)$。我们使用求和后的展开式：\n$$\nf(x_0-h) + f(x_0+h) = 2f_0 + h^2 f_0'' + \\frac{h^4}{12} f_0^{(4)} + \\frac{h^6}{360}f_0^{(6)} + \\mathcal{O}(h^8)\n$$\n$$\nf(x_0-2h)+f(x_0+2h) = 2f_0 + 4h^2 f_0'' + \\frac{4h^4}{3} f_0^{(4)} + \\frac{8h^6}{45}f_0^{(6)} + \\mathcal{O}(h^8)\n$$\n我们通过匹配导数的系数来构建一个方程组，以确定 $c_0, c_1, c_2$：\n$$\n\\text{Numerator} = (2c_2 + 2c_1 + c_0)f_0 + (4c_2 + c_1)h^2 f_0'' + (\\frac{4}{3}c_2 + \\frac{1}{12}c_1)h^4 f_0^{(4)} + \\dots\n$$\n为了近似 $h^2 f_0''$，我们需要：\n\\begin{enumerate}\n    \\item $f_0$ 的系数：$2c_2 + 2c_1 + c_0 = 0$\n    \\item $f_0''$ 的系数：$4c_2 + c_1 = 1$\n    \\item 为达到更高阶，我们消去下一个误差项（$f_0^{(4)}$）：$\\frac{4}{3}c_2 + \\frac{1}{12}c_1 = 0$\n\\end{enumerate}\n由(3)可得，$16c_2 + c_1 = 0 \\implies c_1 = -16c_2$。\n代入(2)中：$4c_2 + (-16c_2) = 1 \\implies -12c_2 = 1 \\implies c_2 = -1/12$。\n则 $c_1 = -16(-1/12) = 4/3$。\n由(1)可得：$c_0 = -2c_1 - 2c_2 = -2(4/3) - 2(-1/12) = -8/3 + 1/6 = -16/6 + 1/6 = -15/6 = -5/2$。\n系数为 $c_2=-1/12, c_1=4/3, c_0=-5/2$。该格式为：\n$$\n\\frac{-\\frac{1}{12}f(x_0-2h) + \\frac{4}{3}f(x_0-h) - \\frac{5}{2}f(x_0) + \\frac{4}{3}f(x_0+h) - \\frac{1}{12}f(x_0+2h)}{h^2}\n$$\n分子展开式中的下一项涉及 $f_0^{(6)}$：$(\\frac{8}{45}c_2 + \\frac{1}{360}c_1)h^6 f_0^{(6)}$。\n代入数值：$(\\frac{8}{45}(-\\frac{1}{12}) + \\frac{1}{360}(\\frac{4}{3})) h^6 f_0^{(6)} = (-\\frac{2}{135} + \\frac{1}{270})h^6 f_0^{(6)} = -\\frac{3}{270}h^6 f_0^{(6)} = -\\frac{1}{90}h^6 f_0^{(6)}$。\n该近似为 $f_0'' - \\frac{h^4}{90}f_0^{(6)} + \\mathcal{O}(h^6)$。截断误差为 $E_T = -\\frac{h^4}{90}f_0^{(6)}$，因此该方法是 $p=4$ 阶的。\n\n**2c. 用于 $f^{(4)}(x_0)$ 的5点中心格式**\n我们寻求一个形式为 $\\frac{1}{h^4} \\sum_{j=-2}^{2} c_j f(x_0+jh)$ 的 $f_0^{(4)}$ 的近似。我们使用与2b中相同的分子展开式，但以不同方式匹配系数以分离出 $f_0^{(4)}$：\n$$\n\\text{Numerator} = (2c_2 + 2c_1 + c_0)f_0 + (4c_2 + c_1)h^2 f_0'' + (\\frac{4}{3}c_2 + \\frac{1}{12}c_1)h^4 f_0^{(4)} + \\dots\n$$\n为了近似 $h^4 f_0^{(4)}$，我们需要：\n\\begin{enumerate}\n    \\item $f_0$ 的系数：$2c_2 + 2c_1 + c_0 = 0$\n    \\item $f_0''$ 的系数：$4c_2 + c_1 = 0 \\implies c_1 = -4c_2$\n    \\item $f_0^{(4)}$ 的系数：$\\frac{4}{3}c_2 + \\frac{1}{12}c_1 = 1$\n\\end{enumerate}\n由(2)，将 $c_1 = -4c_2$ 代入(3)：$\\frac{4}{3}c_2 + \\frac{1}{12}(-4c_2) = 1 \\implies \\frac{4}{3}c_2 - \\frac{1}{3}c_2 = 1 \\implies c_2 = 1$。\n则 $c_1 = -4(1) = -4$。\n由(1)可得：$c_0 = -2c_1 - 2c_2 = -2(-4) - 2(1) = 8 - 2 = 6$。\n系数为 $c_2=1, c_1=-4, c_0=6$。该格式为：\n$$\n\\frac{f(x_0-2h) - 4f(x_0-h) + 6f(x_0) - 4f(x_0+h) + f(x_0+2h)}{h^4}\n$$\n分子展开式中的下一项涉及 $f_0^{(6)}$：$(\\frac{8}{45}c_2 + \\frac{1}{360}c_1)h^6 f_0^{(6)}$。\n代入数值：$(\\frac{8}{45}(1) + \\frac{1}{360}(-4))h^6 f_0^{(6)} = (\\frac{64}{360} - \\frac{4}{360})h^6 f_0^{(6)} = \\frac{60}{360}h^6 f_0^{(6)} = \\frac{1}{6}h^6 f_0^{(6)}$。\n该近似为 $f_0^{(4)} + \\frac{h^2}{6}f_0^{(6)} + \\mathcal{O}(h^4)$。截断误差为 $E_T = \\frac{h^2}{6}f_0^{(6)}$，因此该方法是 $p=2$ 阶的。\n\n### 第3部分：数值验证策略\n\n理论推导将通过计算进行验证。对于指定的四个测试用例中的每一个：\n\\begin{enumerate}\n    \\item 使用一个步长序列 $h_k = 0.2 \\cdot 2^{-k}$，其中 $k \\in \\{0, 1, 2, 3, 4, 5\\}$。\n    \\item 对于每个 $h_k$，在指定的点 $x_0$ 计算相应的有限差分近似值。\n    \\item 使用第1部分中的解析公式计算 $x_0$ 处的导数真值。\n    \\item 计算绝对误差 $E(h_k)$，即数值近似与解析值之间的绝对差。\n    \\item 对于 $k \\in \\{1, 2, 3, 4, 5\\}$，使用连续的误差对计算收敛的观察阶 $p_k$：\n    $$\n    p_k = \\frac{\\log(E(h_{k-1})/E(h_k))}{\\log(h_{k-1}/h_k)} = \\frac{\\log(E(h_{k-1})/E(h_k))}{\\log(2)}\n    $$\n    \\item 每种情况报告的观察阶 $\\tilde{p}$ 定义为最后三个计算阶 $\\{p_3, p_4, p_5\\}$ 的中位数。这为 $h \\to 0$ 时的渐近收敛率提供了一个稳定的估计。\n    \\item 最后，使用标准 $|\\tilde{p} - p_{\\mathrm{expected}}| \\le 0.3$ 将每种情况与其预期的理论阶 $p_{\\mathrm{expected}}$ 进行验证。\n\\end{enumerate}\n此过程将被封装在一个Python程序中，以生成最终的布尔结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of approximating higher derivatives and verifying convergence orders.\n    \"\"\"\n\n    # Part 1: Analytic Functions\n    def f(x: float) -> float:\n        \"\"\"The base function f(x) = exp(-x^2).\"\"\"\n        return np.exp(-x**2)\n\n    def f_d2(x: float) -> float:\n        \"\"\"The analytic second derivative of f(x).\"\"\"\n        return (4 * x**2 - 2) * np.exp(-x**2)\n\n    def f_d4(x: float) -> float:\n        \"\"\"The analytic fourth derivative of f(x).\"\"\"\n        return (16 * x**4 - 48 * x**2 + 12) * np.exp(-x**2)\n\n    # Part 2: Finite Difference Stencils\n    def approx_d2_3pt(func, x0: float, h: float) -> float:\n        \"\"\"3-point centered difference approximation for the 2nd derivative.\"\"\"\n        return (func(x0 - h) - 2 * func(x0) + func(x0 + h)) / h**2\n\n    def approx_d2_5pt(func, x0: float, h: float) -> float:\n        \"\"\"5-point centered difference approximation for the 2nd derivative (order 4).\"\"\"\n        return (-func(x0 - 2 * h) + 16 * func(x0 - h) - 30 * func(x0) + 16 * func(x0 + h) - func(x0 + 2 * h)) / (12 * h**2)\n\n    def approx_d4_5pt(func, x0: float, h: float) -> float:\n        \"\"\"5-point centered difference approximation for the 4th derivative (order 2).\"\"\"\n        return (func(x0 - 2 * h) - 4 * func(x0 - h) + 6 * func(x0) - 4 * func(x0 + h) + func(x0 + 2 * h)) / h**4\n\n    # Part 3: Numerical Verification\n    h_values = [0.2 * (2**-k) for k in range(6)]\n    \n    # Test cases: (approximation_function, analytic_function, evaluation_point_x0, expected_order)\n    test_cases = [\n        # Case A: 3-point f''(0.7), expected order 2\n        (approx_d2_3pt, f_d2, 0.7, 2),\n        # Case B: 5-point f''(1.3), expected order 4\n        (approx_d2_5pt, f_d2, 1.3, 4),\n        # Case C: 5-point f^(4)(0.0), expected order 2\n        (approx_d4_5pt, f_d4, 0.0, 2),\n        # Case D: 5-point f''(2.0) edge case, expected order 4\n        (approx_d2_5pt, f_d2, 2.0, 4),\n    ]\n\n    final_results = []\n    for approx_func, analytic_func, x0, p_expected in test_cases:\n        errors = []\n        for h in h_values:\n            approx_val = approx_func(f, x0, h)\n            analytic_val = analytic_func(x0)\n            error = np.abs(approx_val - analytic_val)\n            errors.append(error)\n\n        observed_orders = []\n        # Calculate observed orders p_k for k in {1,2,3,4,5}\n        for k in range(1, len(h_values)):\n            # Ratio of step sizes is 2\n            h_ratio = h_values[k-1] / h_values[k]\n            \n            # Avoid division by zero if error becomes numerically zero\n            if errors[k] > 0 and errors[k-1] > 0:\n                error_ratio = errors[k-1] / errors[k]\n                order = np.log(error_ratio) / np.log(h_ratio)\n                observed_orders.append(order)\n            else:\n                # If error is zero, convergence is perfect/infinite.\n                # This case isn't expected to be hit, but we handle it.\n                observed_orders.append(np.inf)\n\n        # Per problem, use median of last three observed orders {p_3, p_4, p_5}\n        # These correspond to indices 2, 3, 4 of observed_orders list\n        # which has 5 elements (p_1 to p_5).\n        if len(observed_orders) >= 5:\n            last_three_orders = observed_orders[2:5]\n            reported_order = np.median(last_three_orders)\n            \n            # Apply pass-fail criterion\n            passed = np.abs(reported_order - p_expected) <= 0.3\n            final_results.append(passed)\n        else:\n            # This path should not be taken given the problem setup\n            final_results.append(False)\n\n    # Format the final output as specified\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "3238903"}, {"introduction": "在掌握了手动推导特定格式后，我们转向一种更系统化、可自动执行的通用方法。本练习将推导过程构建为一个求解线性方程组（即矩量条件）的问题，从而可以为任何给定的网格点（包括非均匀分布）计算出差分权重。您将构建一个强大的计算工具，它构成了许多数值计算库的核心功能，深刻理解“待定系数法”的威力 [@problem_id:3238803]。", "problem": "您的任务是实现并测试一个通用例程，该例程使用一组给定的模板节点生成用于近似高阶导数的精确有限差分权重。推导的基础必须是光滑函数的泰勒级数展开以及由此导出的矩条件。您的实现必须求解一个由多项式精确性条件导出的方形线性系统，并尽可能使用精确的有理数算术。\n\n设 $f$ 为一个光滑函数，$x \\in \\mathbb{R}$ 为一个点，$h \\in \\mathbb{R}$ 为一个步长，模板由 $n$ 个不同的节点 $s_0, s_1, \\dots, s_{n-1} \\in \\mathbb{R}$ 给出。目标是构造权重 $w_0, w_1, \\dots, w_{n-1}$，使得有限差分公式\n$$\n\\frac{1}{h^p} \\sum_{j=0}^{n-1} w_j \\, f(x + h s_j)\n$$\n对于所有次数不超过 $n-1$ 的多项式，都能精确地再现 $p$ 阶导数 $f^{(p)}(x)$。\n\n从泰勒级数展开\n$$\nf(x + h s_j) = \\sum_{k=0}^{\\infty} \\frac{f^{(k)}(x)}{k!} (h s_j)^k,\n$$\n开始，对次数 $k = 0, 1, \\dots, n-1$ 施加多项式精确性（矩）条件：\n$$\n\\sum_{j=0}^{n-1} w_j s_j^k =\n\\begin{cases}\n0,  \\text{if } k \\neq p, \\\\\np!,  \\text{if } k = p.\n\\end{cases}\n$$\n这些条件产生了一个包含 $n$ 个未知数 $w_j$ 的 $n$ 个方程的线性系统。该系统的矩阵是一个方形的范德蒙型矩阵，其元素为 $s_j^k$。\n\n您的程序必须：\n- 为通用的导数阶数 $p$ 和通用的、全部互不相同的模板节点 $s_j$ 构建并求解线性系统。\n- 当节点为整数时，通过标准库设施在有理数域中进行运算，使用精确的有理数算术，以使得到的权重是精确的有理数。如果无法进行精确的符号求解（例如，节点不是整数），则可以使用浮点求解，但对于此任务，所有提供的模板节点都是整数。\n- 验证输入并通过受控方式引发或发信号来处理无效配置。无效情况包括重复的模板节点以及 $p$ 超出范围 $0 \\le p \\le n-1$。\n\n测试套件规范：\n在您的程序中实现以下测试用例，并根据最终输出格式要求汇总结果。\n\n1. 中心一阶导数权重，其中 $p = 1$ 且节点为 $[-1, 0, 1]$（此处为生成权重，$n = 3$ 且 $h = 1$）。计算权重并将其与期望的精确有理数值 $\\left[-\\frac{1}{2}, 0, \\frac{1}{2}\\right]$ 进行比较。以浮点数形式报告最大绝对差值。\n\n2. 中心二阶导数权重，其中 $p = 2$ 且节点为 $[-1, 0, 1]$（为生成权重，$h=1$）。计算权重并将其与期望的精确有理数值 $[1, -2, 1]$ 进行比较。以浮点数形式报告最大绝对差值。\n\n3. 前向五阶导数权重，其中 $p = 5$ 且节点为 $[0, 1, 2, 3, 4, 5]$（为生成权重，$h=1$）。将计算出的权重与期望的精确整数序列 $[-1, 5, -10, 10, -5, 1]$ 进行比较。报告一个布尔值，指示是否完全相等。\n\n4. 使用前向五阶导数权重对光滑函数进行数值近似的精度。使用测试用例3中的权重，设 $x = 0$，$h = 10^{-3}$，且 $f(x) = e^x$。计算对 $f^{(5)}(0)$ 的近似值的绝对误差，对于 $f(x) = e^x$，$f^{(5)}(0)$ 等于 $1$。以浮点数形式报告绝对误差。\n\n5. 在非均匀模板上的多项式精确性。设 $p = 2$，节点为 $[-2, -1, 0, 1, 3, 4]$（六个不同的整数节点），$x = 0$，且 $h = 0.1$。使用生成的权重来近似 $f(x) = x^2$ 在 $x = 0$ 处的二阶导数。由于该方案被构造成对次数不超过 $n-1$ 的多项式是精确的，结果应恰好为 $f^{(2)}(0) = 2$。报告一个布尔值，指示与 $2$ 的绝对差值是否小于 $10^{-12}$。\n\n6. 无效的导数阶数。尝试使用节点 $[0, 1]$ 和 $p = 3$ 生成权重。由于 $p \\geq n$ 是无效的，例程必须发出错误信号。报告一个布尔值，指示是否正确检测到错误。\n\n7. 重复的节点（奇异系统）。尝试使用节点 $[0, 0, 1]$ 和 $p = 1$ 生成权重。由于重复的节点会导致奇异矩阵，例程必须发出错误信号。报告一个布尔值，指示是否正确检测到错误。\n\n最终输出格式要求：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果按与上述测试套件相对应的顺序排列：\n1. 测试用例1的浮点数最大绝对差值。\n2. 测试用例2的浮点数最大绝对差值。\n3. 测试用例3的布尔结果。\n4. 测试用例4的浮点数绝对误差。\n5. 测试用例5的布尔结果。\n6. 测试用例6的布尔结果。\n7. 测试用例7的布尔结果。\n\n例如，输出应如下所示：\n\"[r1,r2,r3,r4,r5,r6,r7]\".", "solution": "目标是确定用于近似一个足够光滑的函数 $f(x)$ 在点 $x$ 处的 $p$ 阶导数的有限差分公式的权重 $w_0, w_1, \\dots, w_{n-1}$。该公式由下式给出：\n$$\nf^{(p)}(x) \\approx \\frac{1}{h^p} \\sum_{j=0}^{n-1} w_j f(x + h s_j)\n$$\n其中 $\\{s_j\\}_{j=0}^{n-1}$ 是一个由 $n$ 个不同的无量纲节点组成的模板，$h$ 是步长。推导权重的方法是要求该公式对所有次数不超过 $n-1$ 的多项式都精确。\n\n我们从 $f(x + \\Delta x)$ 在点 $x$ 附近的泰勒级数展开开始：\n$$\nf(x + \\Delta x) = \\sum_{k=0}^{\\infty} \\frac{f^{(k)}(x)}{k!} (\\Delta x)^k\n$$\n对于模板中的每个节点，代入 $\\Delta x = h s_j$，我们得到：\n$$\nf(x + h s_j) = \\sum_{k=0}^{\\infty} \\frac{f^{(k)}(x)}{k!} (h s_j)^k\n$$\n现在，我们将此展开式代入有限差分公式的求和部分：\n$$\n\\sum_{j=0}^{n-1} w_j f(x + h s_j) = \\sum_{j=0}^{n-1} w_j \\left( \\sum_{k=0}^{\\infty} \\frac{f^{(k)}(x)}{k!} (h s_j)^k \\right)\n$$\n假设一致收敛允许交换求和顺序：\n$$\n\\sum_{j=0}^{n-1} w_j f(x + h s_j) = \\sum_{k=0}^{\\infty} \\frac{h^k f^{(k)}(x)}{k!} \\left( \\sum_{j=0}^{n-1} w_j s_j^k \\right)\n$$\n完整的有限差分公式旨在近似 $f^{(p)}(x)$，这意味着上述方程的右侧在除以 $h^p$ 后应简化为 $f^{(p)}(x)$。这意味着我们期望：\n$$\n\\frac{1}{h^p} \\sum_{k=0}^{\\infty} \\frac{h^k f^{(k)}(x)}{k!} \\left( \\sum_{j=0}^{n-1} w_j s_j^k \\right) = f^{(p)}(x)\n$$\n为了使该等式对任意函数 $f(x)$（或更具体地说，对其泰勒级数表示）成立，左侧每个导数项 $f^{(k)}(x)$ 的系数必须与右侧相应的项匹配。右侧仅包含 $f^{(p)}(x)$ 项。因此，对于 $k \\neq p$，$f^{(k)}(x)$ 的系数必须为零，而 $f^{(p)}(x)$ 的系数必须为 $1$。这给了我们关于内层和（矩）的以下条件：\n- 对于 $k = p$：$f^{(p)}(x)$ 的系数是 $\\frac{1}{h^p} \\frac{h^p}{p!} \\left( \\sum_{j=0}^{n-1} w_j s_j^p \\right)$。我们将其设为 $1$。\n$$\n\\frac{1}{p!} \\left( \\sum_{j=0}^{n-1} w_j s_j^p \\right) = 1 \\implies \\sum_{j=0}^{n-1} w_j s_j^p = p!\n$$\n- 对于 $k \\neq p$：$f^{(k)}(x)$ 的系数是 $\\frac{1}{h^p} \\frac{h^k}{k!} \\left( \\sum_{j=0}^{n-1} w_j s_j^k \\right)$。我们将其设为 $0$。\n$$\n\\frac{h^k}{h^p k!} \\left( \\sum_{j=0}^{n-1} w_j s_j^k \\right) = 0 \\implies \\sum_{j=0}^{n-1} w_j s_j^k = 0\n$$\n这些条件是针对 $k = 0, 1, \\dots, n-1$ 施加的。这为 $n$ 个未知权重 $w_0, w_1, \\dots, w_{n-1}$ 提供了一个包含 $n$ 个线性方程的系统。该系统可以写成矩阵形式 $\\mathbf{A} \\mathbf{w} = \\mathbf{b}$，其中：\n$$\n\\mathbf{A} =\n\\begin{pmatrix}\ns_0^0  s_1^0  \\dots  s_{n-1}^0 \\\\\ns_0^1  s_1^1  \\dots  s_{n-1}^1 \\\\\n\\vdots  \\vdots  \\ddots  \\vdots \\\\\ns_0^{n-1}  s_1^{n-1}  \\dots  s_{n-1}^{n-1}\n\\end{pmatrix}\n, \\quad\n\\mathbf{w} =\n\\begin{pmatrix}\nw_0 \\\\\nw_1 \\\\\n\\vdots \\\\\nw_{n-1}\n\\end{pmatrix}\n, \\quad\n\\mathbf{b} =\n\\begin{pmatrix}\n0 \\\\\n\\vdots \\\\\np! \\\\\n\\vdots \\\\\n0\n\\end{pmatrix}\n$$\n矩阵 $\\mathbf{A}$ 是一个范德蒙矩阵。其行列式非零当且仅当所有节点 $s_j$ 都互不相同。问题陈述保证了对于有效输入，这一条件是满足的，从而确保了权重 $\\mathbf{w}$ 的唯一解。向量 $\\mathbf{b}$ 是一个零向量，除了索引为 $p$ 的条目（第 $(p+1)$ 行）为 $p!$ 外。\n\n问题指出，输入的模板节点是整数。为了获得精确的权重，必须使用有理数算术来求解线性系统。这涉及到用有理数构造矩阵 $\\mathbf{A}$ 和向量 $\\mathbf{b}$，并使用像高斯消元法这样在有理数域上运算的算法。Python 的 `fractions` 模块为此提供了必要的工具。\n\n实现将包含一个主例程，该例程负责验证输入、构建线性系统并求解。\n输入验证必须确保两个条件：\n1. 所有模板节点 $s_j$ 必须是不同的。如果 `len(set(s))` 不等于 `len(s)`，则范德蒙矩阵 $\\mathbf{A}$ 是奇异的，唯一解不存在。\n2. 导数的阶数 $p$ 必须在范围 $0 \\le p  n$ 内，其中 $n$ 是模板点的数量。这是因为 $n$ 个点可以唯一确定一个次数最高为 $n-1$ 的多项式，而这 $n$ 个约束条件被用来确定 $n$ 个权重。对于导数阶数 $p \\geq n$，不可能满足矩条件。\n\n对于有效输入，步骤如下：\n1. 定义 $n$ 为模板 $s$ 中的节点数。\n2. 构建 $n \\times n$ 矩阵 $\\mathbf{A}$，其中对于 $k, j \\in \\{0, \\dots, n-1\\}$，$A_{kj} = s_j^k$。每个元素都表示为一个有理数。\n3. 构建 $n \\times 1$ 向量 $\\mathbf{b}$，其中对于 $k \\neq p$，$b_k = 0$，而 $b_p = p!$。每个元素也表示为一个有理数。\n4. 使用基于有理数算术的线性求解器（如带回代的高斯消元法）求解线性系统 $\\mathbf{A} \\mathbf{w} = \\mathbf{b}$ 以得到 $\\mathbf{w}$。\n得到的向量 $\\mathbf{w}$ 将包含指定有限差分方案的精确有理数权重。然后，这些权重被用于执行测试套件所需的计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom fractions import Fraction\nimport math\n\nclass FiniteDifferenceError(ValueError):\n    \"\"\"Custom exception for finite difference routine errors.\"\"\"\n    pass\n\ndef _solve_rational_system(A, b):\n    \"\"\"\n    Solves a linear system Ax=b where A and b contain Fraction objects.\n    Uses Gaussian elimination with back substitution.\n    \"\"\"\n    n = len(b)\n    # Create an augmented matrix\n    M = [row + [val] for row, val in zip(A, b)]\n\n    # Forward elimination\n    for i in range(n):\n        # Find a non-zero pivot\n        pivot_row = i\n        while pivot_row  n and M[pivot_row][i] == Fraction(0):\n            pivot_row += 1\n        \n        if pivot_row == n:\n            # This case is pre-empted by the duplicate node check,\n            # but is included for solver robustness.\n            raise np.linalg.LinAlgError(\"Singular matrix\")\n\n        # Swap the current row with the pivot row\n        M[i], M[pivot_row] = M[pivot_row], M[i]\n        \n        # Eliminate entries below the pivot\n        pivot_val = M[i][i]\n        for j in range(i + 1, n):\n            factor = M[j][i] / pivot_val\n            # M[j][i] = Fraction(0) # Not strictly necessary\n            for k in range(i + 1, n + 1):\n                M[j][k] -= factor * M[i][k]\n\n    # Backward substitution\n    x = [Fraction(0)] * n\n    for i in range(n - 1, -1, -1):\n        s = sum(M[i][j] * x[j] for j in range(i + 1, n))\n        x[i] = (M[i][n] - s) / M[i][i]\n        \n    return x\n\ndef generate_weights(s, p):\n    \"\"\"\n    Generates finite difference weights for a given stencil and derivative order.\n    \n    Args:\n        s (list or tuple of int): The stencil nodes.\n        p (int): The order of the derivative.\n        \n    Returns:\n        list of Fraction: The calculated weights.\n    \n    Raises:\n        FiniteDifferenceError: If inputs are invalid.\n    \"\"\"\n    n = len(s)\n    \n    # Input validation\n    if len(set(s)) != n:\n        raise FiniteDifferenceError(\"Stencil nodes must be distinct.\")\n    if not (0 = p  n):\n        raise FiniteDifferenceError(f\"Derivative order p must be in [0, n-1]. Got p={p}, n={n}.\")\n\n    # Construct the Vandermonde matrix A\n    A = []\n    for k in range(n):\n        A.append([Fraction(node)**k for node in s])\n\n    # Construct the right-hand side vector b\n    b = [Fraction(0)] * n\n    b[p] = Fraction(math.factorial(p))\n    \n    # The system is A_transpose * w = b. Solve A.T w = b, which is w.T A = b.T\n    # This means we solve A^T x = b for x, where A is the matrix from the loop above.\n    # The matrix in the problem is A_kj = s_j^k. The system is sum_j A_kj w_j = b_k.\n    # So A is the coefficient matrix directly.\n    return _solve_rational_system(A, b)\n\ndef solve():\n    \"\"\"\n    Runs the test suite and prints the final results.\n    \"\"\"\n    results = []\n\n    # Test Case 1: Central first derivative\n    p1 = 1\n    s1 = [-1, 0, 1]\n    expected_w1 = [Fraction(-1, 2), Fraction(0), Fraction(1, 2)]\n    computed_w1 = generate_weights(s1, p1)\n    diff1 = max(abs(float(c) - float(e)) for c, e in zip(computed_w1, expected_w1))\n    results.append(diff1)\n\n    # Test Case 2: Central second derivative\n    p2 = 2\n    s2 = [-1, 0, 1]\n    expected_w2 = [Fraction(1), Fraction(-2), Fraction(1)]\n    computed_w2 = generate_weights(s2, p2)\n    diff2 = max(abs(float(c) - float(e)) for c, e in zip(computed_w2, expected_w2))\n    results.append(diff2)\n\n    # Test Case 3: Forward fifth derivative\n    p3 = 5\n    s3 = [0, 1, 2, 3, 4, 5]\n    expected_w3 = [Fraction(v) for v in [-1, 5, -10, 10, -5, 1]]\n    computed_w3 = generate_weights(s3, p3)\n    exact_match3 = (computed_w3 == expected_w3)\n    results.append(exact_match3)\n\n    # Test Case 4: Numerical accuracy\n    p4 = 5\n    s4 = [0, 1, 2, 3, 4, 5]\n    h4 = 1e-3\n    x4 = 0.0\n    weights4 = generate_weights(s4, p4)\n    # f(x) = e^x, f^(5)(x) = e^x, f^(5)(0) = 1\n    approx4 = sum(float(w) * np.exp(x4 + h4 * node) for w, node in zip(weights4, s4)) / (h4**p4)\n    exact4 = 1.0\n    error4 = abs(approx4 - exact4)\n    results.append(error4)\n\n    # Test Case 5: Polynomial exactness on nonuniform stencil\n    p5 = 2\n    s5 = [-2, -1, 0, 1, 3, 4]\n    h5 = 0.1\n    x5 = 0.0\n    weights5 = generate_weights(s5, p5)\n    # f(x) = x^2, f''(x) = 2, f''(0) = 2\n    # The formula should be exact for polynomials of degree  n=6\n    f_vals5 = [(x5 + h5 * node)**2 for node in s5]\n    approx5 = sum(float(w) * fv for w, fv in zip(weights5, f_vals5)) / (h5**p5)\n    exact5 = 2.0\n    poly_exact5 = abs(approx5 - exact5)  1e-12\n    results.append(poly_exact5)\n\n    # Test Case 6: Invalid derivative order\n    error_detected6 = False\n    try:\n        generate_weights(s=[0, 1], p=3)\n    except FiniteDifferenceError:\n        error_detected6 = True\n    results.append(error_detected6)\n\n    # Test Case 7: Duplicate nodes\n    error_detected7 = False\n    try:\n        generate_weights(s=[0, 0, 1], p=1)\n    except FiniteDifferenceError:\n        error_detected7 = True\n    results.append(error_detected7)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3238803"}, {"introduction": "最后的这项实践将探讨数值方法的一个关键限制：对函数光滑性的依赖。通过将标准差分公式应用于一个在原点处存在“尖点”的函数 $f(x)=|x|$，我们将亲眼见证公式为何会失效，并产生谬误的结果。这个练习将引导您设计一种更稳健的自适应策略，即使用单侧差分格式来“绕开”奇点，从而学习到在实际应用中批判性地评估并调整算法的重要一课 [@problem_id:3239009]。", "problem": "考虑在步长为 $h  0$ 的均匀网格上数值逼近函数 $f(x) = |x|$ 的三阶导数 $f^{(3)}(x)$ 的问题。此问题的基本基础是足够光滑的函数 $f$ 在点 $x$ 附近的泰勒展开，即对于任意整数 $k \\ge 0$，有\n$$\nf(x + j h) = \\sum_{m=0}^{\\infty} \\frac{f^{(m)}(x)}{m!} (j h)^m,\n$$\n其中 $j$ 是索引网格点的整数。一个在 $x$ 处、阶数为 $m$、模板偏置为 $\\{j_0, j_1, \\dots, j_{n-1}\\}$ 的通用有限差分估计量需要寻找满足矩匹配条件的权重 $\\{a_0, a_1, \\dots, a_{n-1}\\}$\n$$\n\\sum_{i=0}^{n-1} a_i j_i^k = \\begin{cases}\nm!  \\text{if } k = m, \\\\\n0  \\text{if } 0 \\le k \\le n-1,\\ k \\ne m,\n\\end{cases}\n$$\n从而使得有限差分近似\n$$\nD_m[f](x; h) = \\frac{1}{h^m} \\sum_{i=0}^{n-1} a_i f(x + j_i h)\n$$\n对于次数最高为 $n-1$ 的多项式是精确的，并且其截断误差为 $O(h^{n-m})$，或者当模板的对称性导致额外的偶数阶矩抵消时，误差会更小。当 $f$ 不光滑时，泰勒展开在不可导点处或跨越不可导点时不再成立，而跨越这些点的有限差分估计量可能会灾难性地失效。\n\n您的任务是：\n- 构建一个 $f^{(3)}(x)$ 的中心有限差分估计量，使用一个不包含 $x$ 本身的对称模板，具体偏置为 $\\{-2, -1, 1, 2\\}$。通过满足直到3次的矩匹配条件，并以泰勒展开为基本基础，来推导权重。\n- 当该中心估计量的模板跨越 $f(x) = |x|$ 的非光滑点 $x = 0$ 时，诊断其失效原因。解释为什么由于缺乏光滑性，该近似会产生巨大的虚假值或误导性的抵消。\n- 设计一个改进的局部化估计量，通过使用单边模板来避免奇点，这些模板被选择为完全位于尖点光滑的一侧。当 $x \\ge 0$ 时，使用向前偏置 $\\{0, 1, 2, 3, 4\\}$；当 $x  0$ 时，使用向后偏置 $\\{-4, -3, -2, -1, 0\\}$。使用相同的矩匹配原则推导单边权重。\n- 实现一个诊断程序，以检测中心模板是否跨越非光滑点，使用区间测试 $[x - 2h, x + 2h]$ 是否包含 $0$。此外，计算尺度归一化二阶差分\n$$\nS(x; h) = \\frac{|f(x+h) - 2 f(x) + f(x-h)|}{h},\n$$\n并讨论对于 $f(x) = |x|$，当 $h$ 减小时，其在 $x = 0$ 附近的行为如何区分光滑与非光滑行为。\n- 对每个测试用例，计算：\n    1. 使用偏置 $\\{-2, -1, 1, 2\\}$ 的中心估计量值 $D_3^{\\text{central}}[f](x; h)$。\n    2. 使用偏置 $\\{-4, -3, -2, -1, 0\\}$ 的左单边估计量 $D_3^{\\text{left}}[f](x; h)$。\n    3. 使用偏置 $\\{0, 1, 2, 3, 4\\}$ 的右单边估计量 $D_3^{\\text{right}}[f](x; h)$。\n    4. 改进的局部化估计量 $D_3^{\\text{mod}}[f](x; h)$，当 $x \\ge 0$ 时选择右单边估计量，当 $x  0$ 时选择左单边估计量，而如果模板不跨越 $0$，则使用中心估计量。\n    5. 一个布尔值，指示中心模板是否跨越 $0$，即 $x - 2h \\le 0 \\le x + 2h$ 是否成立。\n- 使用函数 $f(x) = |x|$，无角度且无单位。\n\n测试套件：\n- 用例 1：$x = 1.0$, $h = 0.1$ (远离0的光滑区域；中心模板不跨越尖点)。\n- 用例 2：$x = 0.05$, $h = 0.1$ (靠近0；中心模板跨越尖点)。\n- 用例 3：$x = 0.0$, $h = 0.1$ (恰好在尖点上；中心模板对称地包含0周围的点)。\n- 用例 4：$x = 0.05$, $h = 0.01$ (靠近0，但由于 $h$ 很小，中心模板不跨越尖点)。\n- 用例 5：$x = -0.075$, $h = 0.05$ (负半轴；中心模板跨越尖点)。\n\n答案类型：\n- 对每个测试用例，项目1到4的输出是浮点数，项目5的输出是布尔值。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个含五个子列表的列表，每个子列表对应一个测试用例，且每个子列表内的顺序固定为\n$$\n\\left[ D_3^{\\text{central}},\\ D_3^{\\text{left}},\\ D_3^{\\text{right}},\\ D_3^{\\text{mod}},\\ \\text{kink\\_crossed} \\right],\n$$\n整个列表应严格按照 Python 列表字面量的形式打印，例如\n$$\n\\big[ [\\dots], [\\dots], [\\dots], [\\dots], [\\dots] \\big].\n$$", "solution": "该问题要求对函数 $f(x)=|x|$ 的三阶导数 $f^{(3)}(x)$ 的有限差分估计量进行推导、分析和实现。问题的核心在于处理标准估计量在 $x=0$ 处不可导点上的失效问题。\n\n### **1. $f^{(3)}(x)$ 的中心有限差分估计量**\n\n一个 $m$ 阶导数的有限差分估计量 $D_m[f](x; h)$ 是通过对邻近网格点上的函数值进行加权求和来构建的。对于一个使用对称模板偏置 $\\{j_i\\} = \\{-2, -1, 1, 2\\}$ 的 $f^{(3)}(x)$ 估计量，我们寻求权重 $\\{a_{-2}, a_{-1}, a_1, a_2\\}$，使得该近似对于低次多项式是精确的。这被形式化为矩匹配条件：\n$$\n\\sum_{j \\in \\{-2, -1, 1, 2\\}} a_j j^k = 3! \\cdot \\delta_{k3} \\quad \\text{for } k=0, 1, 2, 3.\n$$\n这产生了一个关于权重的线性方程组：\n\\begin{itemize}\n    \\item $k=0$ (常数多项式): $a_{-2} + a_{-1} + a_1 + a_2 = 0$\n    \\item $k=1$ (线性多项式): $-2a_{-2} - a_{-1} + a_1 + 2a_2 = 0$\n    \\item $k=2$ (二次多项式): $4a_{-2} + a_{-1} + a_1 + 4a_2 = 0$\n    \\item $k=3$ (三次多项式): $-8a_{-2} - a_{-1} + a_1 + 8a_2 = 3! = 6$\n\\end{itemize}\n对于逼近奇数阶导数（$m=3$）的对称模板，其权重必须是反对称的，即 $a_{-j} = -a_j$。因此，$a_{-2} = -a_2$ 且 $a_{-1} = -a_1$。\n将此对称性代入方程组：\n\\begin{itemize}\n    \\item $k=0$: $(-a_2) + (-a_1) + a_1 + a_2 = 0$。此式自动满足。\n    \\item $k=1$: $-2(-a_2) - (-a_1) + a_1 + 2a_2 = 2a_2 + a_1 + a_1 + 2a_2 = 4a_2 + 2a_1 = 0 \\implies a_1 = -2a_2$。\n    \\item $k=2$: $4(-a_2) + (-a_1) + a_1 + 4a_2 = 0$。此式自动满足。\n    \\item $k=3$: $-8(-a_2) - (-a_1) + a_1 + 8a_2 = 8a_2 + a_1 + a_1 + 8a_2 = 16a_2 + 2a_1 = 6$。\n\\end{itemize}\n将 $a_1 = -2a_2$ 代入 $k=3$ 的方程中得到：\n$$\n16a_2 + 2(-2a_2) = 12a_2 = 6 \\implies a_2 = \\frac{1}{2}.\n$$\n由此，我们求得其他权重：$a_1 = -2a_2 = -1$，$a_{-1} = -a_1 = 1$，以及 $a_{-2} = -a_2 = -\\frac{1}{2}$。\n因此，模板 $\\{-2, -1, 1, 2\\}$ 的权重为 $\\{-\\frac{1}{2}, 1, -1, \\frac{1}{2}\\}$。中心估计量为：\n$$\nD_3^{\\text{central}}[f](x; h) = \\frac{1}{h^3} \\left( -\\frac{1}{2}f(x-2h) + f(x-h) - f(x+h) + \\frac{1}{2}f(x+2h) \\right)\n$$\n这可以重写为：\n$$\nD_3^{\\text{central}}[f](x; h) = \\frac{-f(x-2h) + 2f(x-h) - 2f(x+h) + f(x+2h)}{2h^3}.\n$$\n\n### **2. 中心估计量对 $f(x) = |x|$ 的失效分析**\n\n有限差分公式的推导依赖于泰勒级数展开在整个模板上对函数 $f$ 有效。函数 $f(x)=|x|$ 在 $x=0$ 处有一个“尖点”；它的一阶导数是不连续的（$f'(x) = \\text{sgn}(x)$），并且在经典意义上，它在 $x=0$ 处的高阶导数是未定义的。在远离 $x=0$ 的地方，所有高于一阶的导数均为零。\n\n当中心模板 $[x-2h, x+2h]$ 包含点 $x=0$ 时，光滑性假设被违反。该公式将尖点处的急剧变化误解为存在巨大三阶导数的证据。例如，对于 $x=0.05$ 和 $h=0.1$，模板为 $[-0.15, 0.25]$，它跨越了 $0$。该估计量得出：\n$$\nD_3^{\\text{central}}[f](0.05; 0.1) = \\frac{-|-0.15| + 2|-0.05| - 2|0.15| + |0.25|}{2(0.1)^3} = \\frac{-0.15 + 0.1 - 0.3 + 0.25}{0.002} = \\frac{-0.1}{0.002} = -50.\n$$\n这个巨大的虚假值与对于任何 $x>0$ 成立的真实导数 0 有着天壤之别。一个特殊情况发生在 $x=0$ 处，此时 $f(x)=|x|$ 的对称性和算子的反对称性导致了抵消，得出 $D_3^{\\text{central}}[f](0; h) = 0$。虽然这个结果恰好是正确的，但它是对称性的产物，而非稳健性的标志。\n\n### **3. 改进的单边估计量**\n\n为了避免奇点，改进的估计量可以使用完全位于函数光滑部分的单边模板。\n\n**右侧（向前）估计量：** 对于 $x \\ge 0$，我们可以使用正半轴上的模板，例如 $\\{0, 1, 2, 3, 4\\}$。我们通过求解方程组 $\\sum_{i=0}^4 a_i j_i^k = 3! \\delta_{k3}$（对于 $k=0, \\dots, 4$）来寻找权重 $\\{a_0, a_1, a_2, a_3, a_4\\}$。这是一个 $5 \\times 5$ 的范德蒙型线性系统。解此系统可得权重：\n$$\n\\{a_0, a_1, a_2, a_3, a_4\\} = \\left\\{-\\frac{5}{2}, 9, -12, 7, -\\frac{3}{2}\\right\\}.\n$$\n右侧估计量为：\n$$\nD_3^{\\text{right}}[f](x; h) = \\frac{1}{h^3} \\left(-\\frac{5}{2}f(x) + 9f(x+h) - 12f(x+2h) + 7f(x+3h) - \\frac{3}{2}f(x+4h)\\right).\n$$\n\n**左侧（向后）估计量：** 对于 $x  0$，我们使用负半轴上的模板，例如 $\\{-4, -3, -2, -1, 0\\}$。根据对称性，权重是向前权重的负相反序列：\n$$\n\\{a_{-4}, a_{-3}, a_{-2}, a_{-1}, a_0\\} = \\left\\{\\frac{3}{2}, -7, 12, -9, \\frac{5}{2}\\right\\}.\n$$\n左侧估计量为：\n$$\nD_3^{\\text{left}}[f](x; h) = \\frac{1}{h^3} \\left(\\frac{3}{2}f(x-4h) - 7f(x-3h) + 12f(x-2h) - 9f(x-h) + \\frac{5}{2}f(x)\\right).\n$$\n由于这些单边模板完全位于光滑区域内（其中 $f(x)=x$ 或 $f(x)=-x$），并且这两个公式对于最高4次的多项式都是精确的，它们将正确地计算出三阶导数为 $0$。\n\n该问题为改进的估计量 $D_3^{\\text{mod}}$ 给出了一个略显模糊的规则。与自适应模板的标准数值实践相一致的最连贯解释是：当中心模板不含 $x=0$ 处的奇点时，使用中心估计量；否则，切换到合适的单边估计量。实现的逻辑是：如果中心模板区间 $[x-2h, x+2h]$ 包含 0，则对于 $x \\ge 0$ 使用右侧估计量，对于 $x  0$ 使用左侧估计量；否则，使用中心估计量。\n\n### **4. 尖点检测与尺度归一化二阶差分**\n\n一个简单的诊断方法，用于检测中心模板是否跨越 $x=0$ 处的尖点，是检查区间 $[x-2h, x+2h]$ 是否包含 $0$，这当且仅当 $x-2h \\le 0$ 且 $x+2h \\ge 0$ 时成立，即 $|x| \\le 2h$。\n\n尺度归一化二阶差分 $S(x; h) = \\frac{|f(x+h) - 2 f(x) + f(x-h)|}{h}$ 提供了另一种诊断非光滑性的方法。\n\\begin{itemize}\n    \\item 对于光滑函数 $f$，分子约等于 $h^2 f''(x)$，因此 $S(x; h) \\approx h |f''(x)|$，当 $h \\to 0$ 时趋于 $0$。\n    \\item 对于 $f(x)=|x|$ 在 $x=0$ 处，我们有 $S(0; h) = \\frac{|h - 0 + h|}{h} = \\frac{2h}{h} = 2$。该值是常数且非零。\n    \\item 对于 $f(x)=|x|$，当模板避开尖点时（即 $|x|>h$），函数是局部线性的，所以 $f(x+h) - 2f(x) + f(x-h) = 0$，因此 $S(x;h)=0$。\n\\end{itemize}\n$S(x; h)$ 在某点 $x$ 处当 $h \\to 0$ 时不收敛到 $0$ 是一个明确的指标，表明 $f''(x)$ 在经典意义上不存在。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical differentiation problem for f(x)=|x| for a suite of test cases.\n    \"\"\"\n\n    # Define the function f(x) = |x|.\n    f = np.abs\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 0.1),    # Case 1\n        (0.05, 0.1),   # Case 2\n        (0.0, 0.1),    # Case 3\n        (0.05, 0.01),  # Case 4\n        (-0.075, 0.05) # Case 5\n    ]\n\n    all_results = []\n\n    for x, h in test_cases:\n        # 1. Central estimator: D_3^central\n        # Stencil: {-2, -1, 1, 2}, Weights: {-1/2, 1, -1, 1/2} normalized by 1/h^3.\n        # Formula: (-f(x-2h) + 2f(x-h) - 2f(x+h) + f(x+2h)) / (2h^3)\n        numerator_central = -f(x - 2*h) + 2*f(x - h) - 2*f(x + h) + f(x + 2*h)\n        d3_central = numerator_central / (2 * h**3)\n\n        # 2. Left one-sided estimator: D_3^left\n        # Stencil: {-4, -3, -2, -1, 0}, Weights: {3/2, -7, 12, -9, 5/2}\n        numerator_left = (3/2)*f(x - 4*h) - 7*f(x - 3*h) + 12*f(x - 2*h) - 9*f(x - h) + (5/2)*f(x)\n        d3_left = numerator_left / h**3\n\n        # 3. Right one-sided estimator: D_3^right\n        # Stencil: {0, 1, 2, 3, 4}, Weights: {-5/2, 9, -12, 7, -3/2}\n        numerator_right = -(5/2)*f(x) + 9*f(x + h) - 12*f(x + 2*h) + 7*f(x + 3*h) - (3/2)*f(x + 4*h)\n        d3_right = numerator_right / h**3\n        \n        # 5. Kink crossed diagnostic\n        # The central stencil [x - 2h, x + 2h] crosses the kink at 0.\n        kink_crossed = (x - 2*h = 0) and (x + 2*h = 0)\n\n        # 4. Modified localized estimator: D_3^mod\n        # If the central stencil crosses the kink, use a one-sided estimator that avoids it.\n        # Otherwise, use the more accurate central estimator.\n        if kink_crossed:\n            if x = 0:\n                d3_mod = d3_right\n            else:\n                d3_mod = d3_left\n        else:\n            d3_mod = d3_central\n\n        # Collect results for this case in the specified order.\n        case_result = [d3_central, d3_left, d3_right, d3_mod, kink_crossed]\n        all_results.append(case_result)\n\n    # Format the final output as a Python list literal string representation.\n    # To avoid spaces and use Python's native bool representation (True/False),\n    # we convert each list to its string representation and then join them.\n    result_strings = []\n    for res in all_results:\n        # Manually format each sub-list to match specification, ensuring no spaces\n        # and correct boolean representation.\n        res_str = f\"[{res[0]},{res[1]},{res[2]},{res[3]},{res[4]}]\"\n        result_strings.append(res_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3239009"}]}