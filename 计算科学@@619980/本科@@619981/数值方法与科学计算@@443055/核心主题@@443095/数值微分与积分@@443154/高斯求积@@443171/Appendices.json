{"hands_on_practices": [{"introduction": "高斯求积的核心思想是用精心选择的节点和权重来最优地近似积分。这个练习将从最简单的情况入手：单点高斯-勒让德求积。通过将此方法应用于一个假设的物理场景——计算非均匀杆的质量，您将亲身体验高斯求积的基本机制，并理解即便是最简单的规则也能为特定函数提供有意义的近似值。[@problem_id:2175493]", "problem": "在数值分析中，Gaussian quadrature 是一种强大的方法，用于近似计算函数的定积分。其一般形式为 $\\int_{-1}^1 f(x) \\, dx \\approx \\sum_{i=1}^n w_i f(x_i)$，其中 $n$ 是点数，$x_i$ 是节点，$w_i$ 是权重。最简单的形式是单点 Gauss-Legendre 求积法则，其节点为 $x_1 = 0$，权重为 $w_1 = 2$。\n\n考虑一根长度为2米的细直杆，沿着x轴从 $x=-1$ 到 $x=1$ 放置。杆的线性质量密度（单位长度的质量）$\\lambda(x)$ 沿着其长度根据函数 $\\lambda(x) = k (x + 1/5)^3$ 变化，其中 $k$ 是一个具有适当单位的正常数。杆的总质量 $M$ 由其密度函数在其长度上的积分给出：$M = \\int_{-1}^1 \\lambda(x) \\, dx$。\n\n使用所提供的单点 Gauss-Legendre 求积法则，计算杆的近似总质量。将你的答案表示为常数 $k$ 的分数倍形式。", "solution": "题目要求我们近似计算总质量\n$$\nM=\\int_{-1}^{1}\\lambda(x)\\,dx=\\int_{-1}^{1}k\\left(x+\\frac{1}{5}\\right)^{3}\\,dx\n$$\n使用区间 $[-1,1]$ 上的单点 Gauss-Legendre 求积法则，该法则为\n$$\n\\int_{-1}^{1}f(x)\\,dx\\approx w_{1}f(x_{1}),\\quad x_{1}=0,\\quad w_{1}=2.\n$$\n在这里，$f(x)=\\lambda(x)=k\\left(x+\\frac{1}{5}\\right)^{3}$。因此，\n$$\nM\\approx 2\\,\\lambda(0)=2\\,k\\left(0+\\frac{1}{5}\\right)^{3}=2k\\left(\\frac{1}{5}\\right)^{3}.\n$$\n计算立方：\n$$\n\\left(\\frac{1}{5}\\right)^{3}=\\frac{1}{125},\n$$\n所以近似值变为\n$$\nM\\approx 2k\\cdot\\frac{1}{125}=\\frac{2k}{125}.\n$$\n这是 $k$ 的一个分数倍，符合题目要求。", "answer": "$$\\boxed{\\frac{2}{125}k}$$", "id": "2175493"}, {"introduction": "现实世界中的科学与工程问题很少会局限于标准的 $[-1, 1]$ 区间。本练习将引导您掌握一项关键技能：将高斯求积应用于任意区间。通过计算拉伸非线性聚合物所需的功，您将学习如何使用变量替换和复合求积法则，这两种技术对于在实际应用中提高高斯求积的准确性和通用性至关重要。[@problem_id:2175463]", "problem": "在材料科学领域，正在研究拉伸一种新型非线性弹性聚合物所需的能量。实验数据表明，当聚合物从其平衡长度拉伸距离 $x$ 时，其产生的阻力 $F(x)$ 可以用以下函数建模：\n$$F(x) = F_0 \\exp(\\alpha x^2)$$\n其中 $F_0$ 是在 $x=0$ 时的初始阻力，$\\alpha$ 是一个材料常数。\n\n将该聚合物从位置 $x=a$ 拉伸到 $x=b$ 所做的功 $W$ 由以下积分给出：\n$$W = \\int_a^b F(x) dx$$\n\n您的任务是使用数值积分技术来近似所做的功。具体来说，您需要应用复合两点高斯-勒让德求积法则。为此计算，您必须将总积分区间 $[a, b]$ 分成两个相等的子区间。\n\n在区间 $[-1, 1]$ 上的标准两点高斯-勒让德求积法则由下式给出：\n$$\\int_{-1}^{1} g(t) dt \\approx g\\left(-\\frac{1}{\\sqrt{3}}\\right) + g\\left(\\frac{1}{\\sqrt{3}}\\right)$$\n\n给定以下参数：\n- 初始力，$F_0 = 10.0$ N\n- 材料常数，$\\alpha = 0.50$ m$^{-2}$\n- 初始位置，$a = 0.0$ m\n- 最终位置，$b = 2.0$ m\n\n计算所做的总功 $W$。您的答案以焦耳（J）为单位，并四舍五入到四位有效数字。", "solution": "其物理原理是功等于力沿位移的线积分：$W=\\int_{a}^{b}F(x)\\,dx$。我们用复合两点高斯-勒让德求积法则在两个相等的子区间上近似这个积分。将 $[a,b]$ 分割成 $n=2$ 个长度为 $h=(b-a)/2$ 的子区间。对于第 $i$ 个子区间 $[x_{i-1},x_{i}]$，其中点为 $m_{i}=(x_{i-1}+x_{i})/2$，从 $[-1,1]$ 映射过来的两点高斯-勒让德求积法则给出\n$$\n\\int_{x_{i-1}}^{x_{i}}F(x)\\,dx \\approx \\frac{h}{2}\\left[F\\!\\left(m_{i}-\\frac{h}{2\\sqrt{3}}\\right)+F\\!\\left(m_{i}+\\frac{h}{2\\sqrt{3}}\\right)\\right].\n$$\n因此，$n=2$ 的复合求积法则是\n$$\nW \\approx \\sum_{i=1}^{2}\\frac{h}{2}\\left[F\\!\\left(m_{i}-\\frac{h}{2\\sqrt{3}}\\right)+F\\!\\left(m_{i}+\\frac{h}{2\\sqrt{3}}\\right)\\right].\n$$\n根据给定数据 $F(x)=F_{0}\\exp(\\alpha x^{2})$，$F_{0}=10.0$，$\\alpha=0.50$，$a=0.0$，$b=2.0$，我们有 $h=1$，$m_{1}=\\frac{1}{2}$，$m_{2}=\\frac{3}{2}$，以及节点偏移量 $\\delta=\\frac{h}{2\\sqrt{3}}=\\frac{1}{2\\sqrt{3}}$。四个求值点是\n$$\nx_{1,-}=\\frac{1}{2}-\\frac{1}{2\\sqrt{3}},\\quad x_{1,+}=\\frac{1}{2}+\\frac{1}{2\\sqrt{3}},\\quad\nx_{2,-}=\\frac{3}{2}-\\frac{1}{2\\sqrt{3}},\\quad x_{2,+}=\\frac{3}{2}+\\frac{1}{2\\sqrt{3}}.\n$$\n它们的平方可以精确地写为\n$$\nx_{1,-}^{2}=\\frac{1}{3}-\\frac{1}{2\\sqrt{3}},\\quad x_{1,+}^{2}=\\frac{1}{3}+\\frac{1}{2\\sqrt{3}},\\quad\nx_{2,-}^{2}=\\frac{7}{3}-\\frac{3}{2\\sqrt{3}},\\quad x_{2,+}^{2}=\\frac{7}{3}+\\frac{3}{2\\sqrt{3}}.\n$$\n由于 $\\alpha=\\frac{1}{2}$，指数为\n$$\n\\alpha x_{1,-}^{2}=\\frac{1}{6}-\\frac{1}{4\\sqrt{3}},\\quad \\alpha x_{1,+}^{2}=\\frac{1}{6}+\\frac{1}{4\\sqrt{3}},\\quad\n\\alpha x_{2,-}^{2}=\\frac{7}{6}-\\frac{3}{4\\sqrt{3}},\\quad \\alpha x_{2,+}^{2}=\\frac{7}{6}+\\frac{3}{4\\sqrt{3}}.\n$$\n因此，\n$$\nW \\approx \\frac{h}{2}\\left[F_{0}\\exp\\!\\left(\\frac{1}{6}-\\frac{1}{4\\sqrt{3}}\\right)+F_{0}\\exp\\!\\left(\\frac{1}{6}+\\frac{1}{4\\sqrt{3}}\\right)+F_{0}\\exp\\!\\left(\\frac{7}{6}-\\frac{3}{4\\sqrt{3}}\\right)+F_{0}\\exp\\!\\left(\\frac{7}{6}+\\frac{3}{4\\sqrt{3}}\\right)\\right].\n$$\n代入 $h=1$ 和 $F_{0}=10.0$ 并进行数值计算，\n$$\n\\exp\\!\\left(\\frac{1}{6}-\\frac{1}{4\\sqrt{3}}\\right)\\approx 1.022580249,\\quad\n\\exp\\!\\left(\\frac{1}{6}+\\frac{1}{4\\sqrt{3}}\\right)\\approx 1.364794995,\n$$\n$$\n\\exp\\!\\left(\\frac{7}{6}-\\frac{3}{4\\sqrt{3}}\\right)\\approx 2.082676640,\\quad\n\\exp\\!\\left(\\frac{7}{6}+\\frac{3}{4\\sqrt{3}}\\right)\\approx 4.951444581.\n$$\n因此，\n$$\nW \\approx \\frac{1}{2}\\cdot 10\\left(1.022580249+1.364794995+2.082676640+4.951444581\\right)\n= \\frac{1}{2}\\cdot 10 \\cdot 9.421496465 \\approx 47.10748233.\n$$\n四舍五入到四位有效数字，总功为 $47.11$ 焦耳。", "answer": "$$\\boxed{47.11}$$", "id": "2175463"}, {"introduction": "高斯求积中那些“神奇”的节点和权重从何而来？本练习将带您从求积法则的使用者转变为创造者。您将探索正交多项式与矩阵特征值问题之间的深刻联系，并亲手实现用于计算节点和权重的标准方法——Golub-Welsch算法。完成这个实践不仅能让您生成自己的高斯求积法则，更将揭示该方法背后优雅的数学结构。[@problem_id:3234000]", "problem": "您的任务是实现一个完整的程序，该程序使用 Golub–Welsch 算法计算区间 $[-1,1]$ 上勒让德权重 (Legendre weight) 的高斯求积 (Gaussian quadrature) 节点和权重，然后量化当 $n$ 较大时，求积对节点浮点舍入的敏感性。实现必须基于正交多项式和高斯求积的核心定义与经过充分检验的事实，从基本原理出发，不得使用任何预打包的求积例程。\n\n基本原理：\n- 对于一个在区间上的正权重函数 $w(x)$，其对应的正交多项式族 $\\{p_k(x)\\}_{k=0}^{\\infty}$ 满足一个三项递推关系，形式如下：\n$$x\\,p_k(x) = \\alpha_k\\,p_k(x) + \\beta_{k+1}\\,p_{k+1}(x) + \\beta_k\\,p_{k-1}(x),$$\n其中系数 $\\alpha_k$ 为实数，$\\beta_k$ 在 $k \\ge 1$ 时为正数，并且 $p_{-1} \\equiv 0$。\n- 对于区间 $[-1,1]$ 上的权重 $w(x) = 1$ (勒让德权重)，当 $\\{p_k\\}$ 是标准正交多项式时，对称性意味着 $\\alpha_k = 0$，并且由这些系数构建的三对角雅可比矩阵 (tridiagonal Jacobi matrix) 是实对称的。\n- 谱定理 (spectral theorem) 表明，$n \\times n$ 雅可比矩阵的特征值是实的、单的，并且位于 $[-1,1]$ 区间内。高斯求积节点就是这些特征值，而相应的权重与归一化特征向量的第一个分量的平方成正比。对于 $w(x) = 1$ 在 $[-1,1]$ 上的情况，总质量为 $\\mu_0 = \\int_{-1}^{1} 1\\,dx = 2$。\n\n程序要求：\n1) 实现 Golub–Welsch 算法，以计算 $n$ 阶高斯-勒让德求积的节点 $\\{x_i\\}_{i=1}^n$ 和权重 $\\{w_i\\}_{i=1}^n$，计算应使用双精度浮点数。您必须推导并使用标准正交勒让德多项式的三项递推系数来构建对称三对角雅可比矩阵，然后计算其特征值和特征向量以获得 $(x_i,w_i)$。\n\n2) 使用您的实现，评估以下测试套件，该套件涵盖了精确性、对光滑函数的准确性以及对节点浮点舍入的敏感性：\n- 测试 A (对最高 $2n-1$ 次多项式的精确性)：对于 $n = 4$，计算积分 $\\int_{-1}^{1} x^k\\,dx$ 的求积近似值，其中 $k$ 为 $0 \\le k \\le 7$ 的所有整数。返回求积结果与精确积分值之间的最大绝对偏差（精确值可由 $x^k$ 在 $[-1,1]$ 上的反导数得出）。当 $k$ 为奇数时，期望的精确积分为 $0$；当 $k$ 为偶数时，为 $2/(k+1)$。\n- 测试 B (光滑函数的准确性)：对于 $n = 32$，使用您的高斯-勒让德节点和权重近似计算 $\\int_{-1}^{1} e^x\\,dx$，并返回其与精确值 $e - e^{-1}$ 之间的绝对误差。\n- 测试 C (大 $n$ 时对节点舍入的敏感性)：对于 $n = 128$，使用双精度节点计算 $\\int_{-1}^{1} e^x\\,dx$ 的求积近似值 $Q$。然后，通过将每个节点舍入为单精度（32位）浮点数再转换回双精度来构成舍入后的节点 $\\{\\hat{x}_i\\}$，并使用相同的权重但计算 $e^{\\hat{x}_i}$ 来计算 $\\hat{Q}$。返回绝对差 $|Q - \\hat{Q}|$。\n- 测试 D (最坏情况下的节点扰动幅度)：对于相同的 $n = 128$，返回 $\\max_i |x_i - \\hat{x}_i|$，其中 $\\hat{x}_i$ 是与测试 C 中相同的单精度舍入节点。\n\n角度单位：如果使用任何三角函数，其参数必须是弧度。在此测试套件中，仅使用指数函数 $e^x$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，按 [测试 A 结果, 测试 B 结果, 测试 C 结果, 测试 D 结果] 的顺序排列。例如：\"[rA,rB,rC,rD]\"。\n- 每个报告的值必须是实数（浮点数）。不应打印其他任何文本。", "solution": "所述问题是有效的。它在科学上基于成熟的高斯求积和正交多项式理论，特别是用于计算节点和权重的 Golub-Welsch 算法。该问题定义明确，提供了所有必要的定义、约束和一组清晰的任务，这些任务导向一个唯一的、可验证的数值结果。它客观且没有歧义。因此，我们可以进行形式化的求解。\n\n目标是使用 Golub-Welsch 算法计算高斯-勒让德求积法则并分析其性质。此方法将寻找求积节点（即一个正交多项式的根）的问题，重新表述为一个矩阵特征值问题，这种方法在数值上是稳定且高效的。\n\n一个 $n$ 点高斯求积法则将关于权重函数 $w(x)$ 在区间 $[a, b]$ 上的积分近似为一个有限和：\n$$\n\\int_{a}^{b} w(x) f(x) \\,dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\n如果 $f(x)$ 是一个次数最高为 $2n-1$ 的多项式，则此近似是精确的。节点 $\\{x_i\\}_{i=1}^n$ 是 $n$ 次多项式 $p_n(x)$ 的根，该多项式来自正交多项式序列 $\\{p_k(x)\\}_{k=0}^{\\infty}$，该序列由正交性条件定义：\n$$\n\\int_{a}^{b} w(x) p_j(x) p_k(x) \\,dx = C_k \\delta_{jk}\n$$\n其中 $\\delta_{jk}$ 是克罗内克 δ (Kronecker delta)，$C_k$ 是一个归一化常数。如果多项式是标准正交的，则 $C_k=1$。\n\n正交多项式的一个基本性质是它们满足一个三项递推关系。对于标准正交多项式 $\\{p_k(x)\\}$，这个关系的形式为：\n$$\nx p_k(x) = \\beta_{k+1} p_{k+1}(x) + \\alpha_k p_k(x) + \\beta_k p_{k-1}(x)\n$$\n其中 $p_{-1}(x) \\equiv 0$ 且 $p_0(x)$ 是一个常数。系数 $\\alpha_k$ 和 $\\beta_k$ 是实数。这个递推关系可以写成矩阵形式。如果我们考虑前 $n$ 个多项式的向量 $\\mathbf{P}(x) = [p_0(x), p_1(x), \\dots, p_{n-1}(x)]^T$，对于 $k=0, \\dots, n-1$ 的递推关系集合可以表示为：\n$$\nx \\mathbf{P}(x) = J_n \\mathbf{P}(x) + \\beta_n p_n(x) \\mathbf{e}_n\n$$\n其中 $\\mathbf{e}_n = [0, \\dots, 0, 1]^T$，$J_n$ 是 $n \\times n$ 的对称三对角雅可比矩阵：\n$$\nJ_n = \\begin{pmatrix}\n \\alpha_0  \\beta_1  0  \\dots  0 \\\\\n \\beta_1  \\alpha_1  \\beta_2  \\dots  0 \\\\\n 0  \\beta_2  \\alpha_2  \\ddots  \\vdots \\\\\n \\vdots  \\vdots  \\ddots  \\ddots  \\beta_{n-1} \\\\\n 0  0  \\dots  \\beta_{n-1}  \\alpha_{n-1}\n\\end{pmatrix}\n$$\n求积节点 $\\{x_i\\}_{i=1}^n$ 是 $p_n(x)$ 的根。在这些根处，$p_n(x_i)=0$，递推关系简化为一个特征值方程：$x_i \\mathbf{P}(x_i) = J_n \\mathbf{P}(x_i)$。这表明求积节点恰好是雅可比矩阵 $J_n$ 的特征值。这就是 Golub-Welsch 算法的核心。\n\n对于高斯-勒让德求积，区间是 $[-1, 1]$，权重函数是 $w(x)=1$。相应的正交多项式是勒让德多项式。为了构建雅可比矩阵，我们需要*标准正交*勒让德多项式的系数 $\\alpha_k$ 和 $\\beta_k$。由 $P_k(1)=1$ 归一化的标准勒让德多项式 $P_k(x)$ 满足递推关系 $(k+1)P_{k+1}(x) = (2k+1)x P_k(x) - k P_{k-1}(x)$，其范数为 $\\int_{-1}^1 (P_k(x))^2 dx = \\frac{2}{2k+1}$。标准正交多项式为 $p_k(x) = \\sqrt{\\frac{2k+1}{2}} P_k(x)$。将此代入 $P_k(x)$ 的递推关系并重新整理，可得到 $p_k(x)$ 的递推关系：\n$$\nx p_k(x) = \\frac{k+1}{\\sqrt{(2k+1)(2k+3)}} p_{k+1}(x) + \\frac{k}{\\sqrt{(2k-1)(2k+1)}} p_{k-1}(x)\n$$\n与一般形式进行比较，我们识别出标准正交勒让德多项式的系数：\n$$\n\\alpha_k = 0 \\quad \\text{对所有 } k\n$$\n$$\n\\beta_k = \\frac{k}{\\sqrt{4k^2 - 1}} \\quad \\text{对 } k \\ge 1\n$$\n因此，高斯-勒让德求积的雅可比矩阵 $J_n$ 是一个对称三对角矩阵，其主对角线上的元素为零，次对角线和超对角线上的元素为 $\\beta_k$ (对于 $k=1, \\dots, n-1$）。\n\n求积权重 $\\{w_i\\}_{i=1}^n$ 与 $J_n$ 的特征向量相关。如果 $\\mathbf{v}_i$ 是对应于特征值 $x_i$ 的归一化特征向量，则权重 $w_i$ 由下式给出：\n$$\nw_i = \\mu_0 (v_{i,1})^2\n$$\n其中 $v_{i,1}$ 是 $\\mathbf{v}_i$ 的第一个分量，$\\mu_0$ 是权重函数的总质量，即 $\\mu_0 = \\int_{-1}^1 1 \\,dx = 2$。\n\n该算法包括以下步骤：\n1.  对于给定的阶数 $n$，使用系数 $\\alpha_k=0$ 和 $\\beta_k = k/\\sqrt{4k^2-1}$ 构建 $n \\times n$ 的雅可比矩阵 $J_n$。\n2.  计算 $J_n$ 的特征值和归一化特征向量的第一个分量。这可以使用针对对称矩阵的数值特征求解器高效地完成。特征值即为节点 $\\{x_i\\}$。\n3.  使用公式 $w_i = 2(v_{i,1})^2$ 计算权重 $\\{w_i\\}$。\n\n此过程被实现以处理指定的四个测试用例：\n-   **测试 A：** 对于 $n=4$，求积法则对最高为 $2n-1=7$ 次的多项式是精确的。我们计算 $\\int_{-1}^1 x^k dx$ (其中 $k=0, \\dots, 7$)，并找到与精确解析值（偶数 $k$ 为 $2/(k+1)$，奇数 $k$ 为 $0$）之间的最大偏差。此偏差应在机器精度级别。\n-   **测试 B：** 对于 $n=32$，我们近似计算 $\\int_{-1}^1 e^x dx$。由于 $e^x$是解析函数，高斯求积呈指数收敛。计算与精确值 $e - e^{-1}$ 的绝对误差以展示这种高精度。\n-   **测试 C：** 对于 $n=128$，我们量化求积和对节点中舍入误差的敏感性。我们使用双精度节点 $\\{x_i\\}$ 计算和 $Q = \\sum w_i e^{x_i}$。然后，我们将节点舍入为单精度以获得 $\\{\\hat{x}_i\\}$，并重新计算和 $\\hat{Q} = \\sum w_i e^{\\hat{x}_i}$。差值 $|Q - \\hat{Q}|$ 衡量了这种扰动的影响。这是衡量在大 $n$ 值下求和计算的数值稳定性的一个实用指标。\n-   **测试 D：** 对于 $n=128$，我们计算扰动本身的最大幅度 $\\max_i |x_i - \\hat{x}_i|$，以了解在节点中引入的浮点舍入误差的大小。这对应于每个节点值周围可表示的单精度数之间间隙的半宽度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Golub-Welsch algorithm for Gauss-Legendre quadrature\n    and runs the specified test suite.\n    \"\"\"\n\n    def golub_welsch(n: int):\n        \"\"\"\n        Computes the n-point Gauss-Legendre quadrature nodes and weights.\n\n        Args:\n            n: The order of the quadrature rule.\n\n        Returns:\n            A tuple (nodes, weights), where each is a numpy array of length n.\n        \"\"\"\n        if n == 0:\n            return np.array([]), np.array([])\n        \n        # Calculate the off-diagonal elements (beta_k) of the Jacobi matrix\n        # for orthonormal Legendre polynomials.\n        # beta_k = k / sqrt(4*k^2 - 1) for k = 1, 2, ..., n-1.\n        k = np.arange(1, n, dtype=np.float64)\n        beta = k / np.sqrt(4 * k**2 - 1)\n        \n        # The Jacobi matrix J_n is symmetric and tridiagonal with zeros on the diagonal\n        # and beta_k on the off-diagonals.\n        # numpy.linalg.eigh is optimized for symmetric/Hermitian matrices.\n        J = np.diag(beta, k=1) + np.diag(beta, k=-1)\n        \n        # Eigenvalues are the quadrature nodes.\n        # Eigenvectors are needed for the weights.\n        # 'eigh' returns eigenvalues in ascending order.\n        nodes, evecs = np.linalg.eigh(J)\n        \n        # The weights are derived from the first component of the normalized eigenvectors.\n        # w_i = mu_0 * (v_{i,1})^2, where mu_0 = integral of weight function from -1 to 1.\n        # For w(x)=1, mu_0 = 2.\n        # The first components of all eigenvectors are in the first row of the evecs matrix.\n        weights = 2.0 * evecs[0, :]**2\n        \n        return nodes, weights\n\n    results = []\n\n    # Test A: Exactness for polynomials up to degree 2n-1\n    n_A = 4\n    nodes_A, weights_A = golub_welsch(n_A)\n    max_dev = 0.0\n    for k in range(2 * n_A):\n        # Quadrature approximation of integral(x^k) from -1 to 1\n        quad_approx = np.sum(weights_A * (nodes_A**k))\n        \n        # Exact integral\n        if k % 2 != 0:\n            exact_integral = 0.0\n        else:\n            exact_integral = 2.0 / (k + 1.0)\n            \n        max_dev = max(max_dev, abs(quad_approx - exact_integral))\n    results.append(max_dev)\n\n    # Test B: Accuracy for a smooth function\n    n_B = 32\n    nodes_B, weights_B = golub_welsch(n_B)\n    quad_approx_B = np.sum(weights_B * np.exp(nodes_B))\n    exact_integral_B = np.exp(1.0) - np.exp(-1.0)\n    abs_error_B = abs(quad_approx_B - exact_integral_B)\n    results.append(abs_error_B)\n\n    # Test C  D: Sensitivity to node rounding for large n\n    n_C = 128\n    nodes_C, weights_C = golub_welsch(n_C)\n    \n    # Calculate the quadrature sum with double-precision nodes\n    Q = np.sum(weights_C * np.exp(nodes_C))\n    \n    # Round nodes to single-precision and back to double-precision\n    # to simulate using single-precision nodes in a double-precision calculation\n    rounded_nodes_C = np.array(np.float32(nodes_C), dtype=np.float64)\n    \n    # Calculate the quadrature sum with the rounded nodes\n    Q_hat = np.sum(weights_C * np.exp(rounded_nodes_C))\n    \n    # Test C result: absolute difference |Q - Q_hat|\n    diff_Q = abs(Q - Q_hat)\n    results.append(diff_Q)\n    \n    # Test D result: maximum absolute perturbation |x_i - x_hat_i|\n    max_node_pert = np.max(np.abs(nodes_C - rounded_nodes_C))\n    results.append(max_node_pert)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3234000"}]}