{"hands_on_practices": [{"introduction": "理解自适应求积这类递归算法的最佳方式之一是亲手模拟其执行过程。本练习将引导你手动追踪一个简化的自适应梯形法则算法，计算一个简单函数 $f(x)=x^2$ 的积分 [@problem_id:2153105]。通过这个过程，你将具体地体会到算法如何比较不同层次的近似值来估计误差，并决定是否需要进一步细分区间。", "problem": "一个自适应求积算法通过细化其计算网格来满足期望的误差容限。考虑以下为近似计算定积分 $I = \\int_a^b f(x) \\,dx$ 而设计的递归算法。\n\n**自适应积分算法：**\n函数 `AdaptiveIntegrate(f, a, b, ε)` 以一个函数 $f$、一个区间 $[a, b]$ 和一个容限 $\\epsilon$ 作为输入。\n\n1.  使用宽度为 $h_1 = b-a$ 的单个区间，根据梯形法则计算近似值 $S_1$。其公式为 $S_1 = \\frac{h_1}{2}(f(a) + f(b))$。\n2.  令 $c = (a+b)/2$ 为区间的中点。使用两个宽度均为 $h_2 = (b-a)/2$ 的子区间 $[a, c]$ 和 $[c, b]$，根据复合梯形法则计算近似值 $S_2$。其公式为 $S_2 = \\frac{h_2}{2}(f(a) + f(c)) + \\frac{h_2}{2}(f(c) + f(b))$。\n3.  更精确的近似值 $S_2$ 的误差估计基于这两个近似值之差。停止准则为 $|S_2 - S_1|  3\\epsilon$。\n4.  如果满足该准则，则此区间的过程终止并返回 $S_2$ 的值。\n5.  如果不满足该准则，算法将细化该区间。它对两个子区间递归调用自身，并将每个子区间的容限减半。区间 $[a, b]$ 的结果是这两个调用结果之和：\n    `AdaptiveIntegrate(f, a, c, ε/2) + AdaptiveIntegrate(f, c, b, ε/2)`\n\n你的任务是手动追踪此算法，以初始容限 $\\epsilon = 2$ 来求积分\n$$ I = \\int_0^4 x^2 \\,dx $$\n的数值近似值。\n\n计算该算法返回的积分的最终数值近似值。请以精确整数或分数形式提供你的答案。", "solution": "我们将给定的自适应梯形算法应用于 $[0,4]$ 上的 $f(x)=x^{2}$，初始容限为 $\\epsilon=2$。在 $[a,b]$ 上使用单个区间的梯形近似为 $S_{1}=\\frac{h_{1}}{2}\\left(f(a)+f(b)\\right)$，其中 $h_{1}=b-a$；使用两个区间的梯形近似为\n$$\nS_{2}=\\frac{h_{2}}{2}\\left(f(a)+f(c)\\right)+\\frac{h_{2}}{2}\\left(f(c)+f(b)\\right),\n$$\n其中 $c=\\frac{a+b}{2}$ 且 $h_{2}=\\frac{b-a}{2}$。一个区间的停止准则是 $|S_2 - S_1|  3\\epsilon$。如果不满足，我们对 $[a,c]$ 和 $[c,b]$ 进行递归，每个区间的容限为 $\\epsilon/2$，然后将返回的值相加。\n\n顶层区间 $[0,4]$，$\\epsilon=2$：\n- 计算 $h_{1}=4$, $S_{1}=\\frac{4}{2}\\left(f(0)+f(4)\\right)=2\\left(0+16\\right)=32$。\n- 中点 $c=2$，$h_{2}=2$，且\n$$\nS_{2}=\\frac{2}{2}\\left(f(0)+f(2)\\right)+\\frac{2}{2}\\left(f(2)+f(4)\\right)=1\\left(0+4\\right)+1\\left(4+16\\right)=4+20=24.\n$$\n- 误差检查：$\\left|S_{2}-S_{1}\\right|=\\left|24-32\\right|=8$，而 $3\\epsilon=3\\cdot 2=6$。由于 $8 \\not 6$，我们对 $[0,2]$ 和 $[2,4]$ 进行递归，每个区间的容限为 $\\epsilon/2=1$。\n\n子区间 $[0,2]$，$\\epsilon=1$：\n- 计算 $h_{1}=2$, $S_{1}=\\frac{2}{2}\\left(f(0)+f(2)\\right)=1\\left(0+4\\right)=4$。\n- 中点 $c=1$，$h_{2}=1$，且\n$$\nS_{2}=\\frac{1}{2}\\left(f(0)+f(1)\\right)+\\frac{1}{2}\\left(f(1)+f(2)\\right)=\\frac{1}{2}\\left(0+1\\right)+\\frac{1}{2}\\left(1+4\\right)=\\frac{1}{2}+\\frac{5}{2}=3.\n$$\n- 误差检查：$\\left|S_{2}-S_{1}\\right|=\\left|3-4\\right|=1$，而 $3\\epsilon=3\\cdot 1=3$。由于 $1  3$，接受 $[0,2]$ 上的 $S_{2}=3$。\n\n子区间 $[2,4]$，$\\epsilon=1$：\n- 计算 $h_{1}=2$, $S_{1}=\\frac{2}{2}\\left(f(2)+f(4)\\right)=1\\left(4+16\\right)=20$。\n- 中点 $c=3$，$h_{2}=1$，且\n$$\nS_{2}=\\frac{1}{2}\\left(f(2)+f(3)\\right)+\\frac{1}{2}\\left(f(3)+f(4)\\right)=\\frac{1}{2}\\left(4+9\\right)+\\frac{1}{2}\\left(9+16\\right)=\\frac{13}{2}+\\frac{25}{2}=19.\n$$\n- 误差检查：$\\left|S_{2}-S_{1}\\right|=\\left|19-20\\right|=1$，而 $3\\epsilon=3$。由于 $1  3$，接受 $[2,4]$ 上的 $S_{2}=19$。\n\n最后，顶层调用返回接受的子区间结果之和：\n$$\n\\text{结果} = 3+19=22.\n$$\n这就是该算法返回的最终数值近似值。", "answer": "$$\\boxed{22}$$", "id": "2153105"}, {"introduction": "在手动追踪算法的基础之上，下一步是通过编程实践来见证自适应求积的真正威力。这个练习要求你实现一个自适应算法，并将其应用于一个在不同区域行为迥异的函数 [@problem_id:3203443]。通过分析计算节点在低频和高频区域的分布，你将直观地看到算法是如何“智能地”将计算资源集中在函数最复杂的部分。", "problem": "考虑区间 $[0,2\\pi]$ 以及分段定义函数 $f(x)$，其定义为当 $x  \\pi$ 时 $f(x)=\\sin(x)$，当 $x\\ge\\pi$ 时 $f(x)=\\sin(100x)$。任务是实现一种自适应求积方法，该方法从数值分析的基本原理出发，并使用局部误差控制来决定在何处细分积分域。您必须构建一个程序，用于计算 $f(x)$ 在 $[0,2\\pi]$ 上的定积分的近似值，并定量分析自适应过程在低频区域 $[0,\\pi)$ 与高频区域 $[\\pi,2\\pi]$ 中分配节点的情况。\n\n从定积分的定义和基于多项式插值的复合数值求积概念出发。使用一个有理论依据的局部误差估计器来驱动细分过程，确保算法在估计误差较大的子区间进行加密。您必须实现一个基于辛普森型局部近似的自适应算法，该算法递归地对区间进行二分，直到满足指定的绝对误差容限 $\\tau$ 或达到最大递归深度 $D_{\\max}$。您不应为目标方法假设任何预先推导的快捷公式；相反，应根据数值积分和局部误差估计的核心定义来推导决策。\n\n您的程序必须对每个测试输入执行以下操作：\n- 计算 $\\int_{0}^{2\\pi} f(x)\\,dx$ 的数值近似值 $I$。\n- 跟踪计算 $f(x)$ 时所用的唯一横坐标集合，并报告在 $[0,\\pi)$ 和 $[\\pi,2\\pi]$ 中分别使用的唯一点的数量 $n_{\\text{low}}$ 和 $n_{\\text{high}}$。将 $x=\\pi$ 归类于高频区域。\n- 计算绝对误差 $e=|I-I_{\\text{exact}}|$，其中 $I_{\\text{exact}}$ 是根据三角积分的基本性质推导出的积分精确值。\n- 报告自适应方法是否在高频区域分配了严格多于低频区域的节点，即布尔值 $n_{\\text{high}}n_{\\text{low}}$。\n\n测试套件：\n提供以下参数集 $(\\tau,D_{\\max})$ 的结果：\n1. $\\tau=10^{-6}$ 和 $D_{\\max}=40$ (一般情况)。\n2. $\\tau=10^{-4}$ 和 $D_{\\max}=20$ (中等容限)。\n3. $\\tau=10^{-8}$ 和 $D_{\\max}=12$ (容限严格但递归深度受限的边缘情况)。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个测试用例必须贡献一个形式为 $[I,e,n_{\\text{low}},n_{\\text{high}},\\text{high\\_more}]$ 的嵌套列表，其中 $I$ 和 $e$ 是浮点数，$n_{\\text{low}}$ 和 $n_{\\text{high}}$ 是整数，而 $\\text{high\\_more}$ 是布尔值。例如，整体输出必须类似于 $[[I_1,e_1,n_{\\text{low},1},n_{\\text{high},1},\\text{high\\_more}_1],[I_2,e_2,n_{\\text{low},2},n_{\\text{high},2},\\text{high\\_more}_2],[I_3,e_3,n_{\\text{low},3},n_{\\text{high},3},\\text{high\\_more}_3]]$。不涉及物理单位。", "solution": "用户提供的问题是数值分析中一个明确定义的任务。它要求基于第一性原理实现并分析一个自适应求积算法。该问题在科学上是合理的、自洽的且客观的。因此，它被认为是有效的。\n\n### 1. 基于原理的自适应方法推导\n\n目标是近似计算定积分 $I = \\int_a^b f(x) \\, dx$。自适应求积方法通过在估计的近似误差较大的区间进行细分来加密积分域，从而将计算量集中在函数最难积分的区域。\n\n我们将方法基于辛普森法则(Simpson's rule)，该法则用一个二次多项式来近似被积函数。\n\n**使用辛普森法则的局部近似**\n\n对于给定的区间 $[a, b]$，令 $c = (a+b)/2$ 为中点。基本的辛普森法则使用三个点提供一个近似值 $S_1$：\n$$ S_1 = \\frac{b-a}{6} \\left( f(a) + 4f(c) + f(b) \\right) $$\n已知这个近似的误差为 $E_1 = -\\frac{(b-a)^5}{2880} f^{(4)}(\\xi_1)$，其中某个 $\\xi_1 \\in (a, b)$。\n\n为了在不知道 $f^{(4)}$ 的情况下估计此误差，我们通过将辛普森法则应用于两个半区间 $[a, c]$ 和 $[c, b]$ 来计算一个更精确的近似值 $S_2$。令 $d = (a+c)/2$ 和 $e = (c+b)/2$ 为新的中点。在这两个子区间上使用复合辛普森法则得到：\n$$ S_2 = \\frac{c-a}{6} \\left( f(a) + 4f(d) + f(c) \\right) + \\frac{b-c}{6} \\left( f(c) + 4f(e) + f(b) \\right) $$\n由于 $c-a = b-c = (b-a)/2$，上式可简化为：\n$$ S_2 = \\frac{b-a}{12} \\left( f(a) + 4f(d) + 2f(c) + 4f(e) + f(b) \\right) $$\n这个5点近似 $S_2$ 的误差是两个子区间上误差的总和：\n$$ E_2 = -2 \\cdot \\frac{((b-a)/2)^5}{2880} f^{(4)}(\\xi_2) = -\\frac{1}{16} \\frac{(b-a)^5}{2880} f^{(4)}(\\xi_2) $$\n假设 $f^{(4)}(x)$ 在 $[a, b]$ 上近似为常数，则有 $E_2 \\approx \\frac{1}{16} E_1$。\n\n**局部误差估计**\n\n设 $[a, b]$ 上积分的真值为 $I_{[a,b]}$。我们有以下关系：\n$I_{[a,b]} \\approx S_1 + E_1$\n$I_{[a,b]} \\approx S_2 + E_2 \\approx S_2 + \\frac{1}{16} E_1$\n\n将 $I_{[a,b]}$ 的两个表达式相等：\n$S_1 + E_1 \\approx S_2 + \\frac{1}{16} E_1 \\implies \\frac{15}{16} E_1 \\approx S_2 - S_1 \\implies E_1 \\approx \\frac{16}{15} (S_2 - S_1)$\n\n我们真正感兴趣的是我们*更好*的近似值 $S_2$ 的误差。这个误差是 $E_2 \\approx \\frac{1}{16} E_1$。代入 $E_1$ 的表达式：\n$$ E_{\\text{local}} = E_2 \\approx \\frac{1}{16} \\left( \\frac{16}{15} (S_2 - S_1) \\right) = \\frac{S_2 - S_1}{15} $$\n因此，局部误差的大小可以估计为 $|S_2 - S_1| / 15$。\n\n**递归细分策略**\n\n自适应算法是递归实现的。对于一个区间 $[a, b]$ 和一个期望的局部容限 $\\tau_{\\text{local}}$：\n1.  计算粗略近似值 $S_1$ 和精细近似值 $S_2$。\n2.  估计误差 $E_{\\text{local}} = |S_2 - S_1|/15$。\n3.  如果 $E_{\\text{local}}  \\tau_{\\text{local}}$ 或者达到了最大递归深度 $D_{\\max}$，则停止细分。返回此区间上积分的最佳估计值。这可以是更精确的值 $S_2$，也可以是通过理查森外推法(Richardson extrapolation)获得的更好的估计值：$I_{\\text{best}} = S_2 + E_{\\text{local}} = S_2 + (S_2 - S_1)/15$。我们将使用这个改进后的值。\n4.  如果误差过大，则将该区间二分为 $[a, c]$ 和 $[c, b]$。对每个子区间递归调用该算法。容限被分配给子问题；一个常见的策略是为每个子区间分配父区间容限的一半，即 $\\tau_{\\text{child}} = \\tau_{\\text{local}}/2$。\n\n初始调用作用于整个定义域 $[0, 2\\pi]$，使用用户指定的容限 $\\tau$ 和最大深度 $D_{\\max}$。\n\n### 2. 目标问题分析\n\n**函数定义**\n\n要在 $[0, 2\\pi]$ 上积分的函数是：\n$$ f(x) = \\begin{cases} \\sin(x)  \\text{for } x  \\pi \\\\ \\sin(100x)  \\text{for } x \\ge \\pi \\end{cases} $$\n该函数在 $[0, \\pi)$ 上有一个低频分量，在 $[\\pi, 2\\pi]$ 上有一个高频分量。预计自适应算法将在高频区域执行更多的细分，以解析 $\\sin(100x)$ 的快速振荡。\n\n**精确积分计算**\n\n计算误差需要积分的精确值。\n$$ I_{\\text{exact}} = \\int_{0}^{2\\pi} f(x) \\, dx = \\int_{0}^{\\pi} \\sin(x) \\, dx + \\int_{\\pi}^{2\\pi} \\sin(100x) \\, dx $$\n第一部分是：\n$$ \\int_{0}^{\\pi} \\sin(x) \\, dx = [-\\cos(x)]_{0}^{\\pi} = (-\\cos(\\pi)) - (-\\cos(0)) = -(-1) - (-1) = 1+1=2 $$\n第二部分是：\n$$ \\int_{\\pi}^{2\\pi} \\sin(100x) \\, dx = \\left[-\\frac{1}{100}\\cos(100x)\\right]_{\\pi}^{2\\pi} = -\\frac{1}{100} (\\cos(200\\pi) - \\cos(100\\pi)) = -\\frac{1}{100} (1 - 1) = 0 $$\n因此，积分的精确值为 $I_{\\text{exact}} = 2 + 0 = 2$。\n\n**计算方案**\n\n对于每个测试用例 $(\\tau, D_{\\max})$：\n1.  初始化一个空集合来存储唯一的横坐标（求值点）。\n2.  在 $[0, 2\\pi]$ 上执行递归自适应求积算法。递归函数将填充横坐标集合。\n3.  算法的结果是数值近似值 $I$。\n4.  计算绝对误差 $e = |I - I_{\\text{exact}}|$。\n5.  遍历唯一的横坐标集合。将在 $[0, \\pi)$ 中的点数计为 $n_{\\text{low}}$，将在 $[\\pi, 2\\pi]$ 中的点数计为 $n_{\\text{high}}$（将 $x=\\pi$ 归类为高频）。\n6.  确定条件 $n_{\\text{high}}  n_{\\text{low}}$ 的布尔值。\n7.  收集这五个结果：$[I, e, n_{\\text{low}}, n_{\\text{high}}, (n_{\\text{high}}  n_{\\text{low}})]$。\n所有测试用例的结果将被汇编成一个单一列表作为最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the final result.\n    \"\"\"\n\n    # Define the piecewise function f(x)\n    def f(x):\n        \"\"\"\n        The piecewise function to be integrated.\n        f(x) = sin(x) for x  pi\n        f(x) = sin(100x) for x >= pi\n        \"\"\"\n        if isinstance(x, (list, np.ndarray)):\n            # Support for vectorized input, though the algorithm evaluates point-wise\n            return np.where(x  np.pi, np.sin(x), np.sin(100 * x))\n        else:\n            if x  np.pi:\n                return np.sin(x)\n            else:\n                return np.sin(100 * x)\n\n    class AdaptiveQuadrature:\n        \"\"\"\n        A class to encapsulate the adaptive quadrature logic and state.\n        This avoids using global variables for tracking evaluation points.\n        \"\"\"\n        def __init__(self, func, exact_value):\n            self.func = func\n            self.exact_value = exact_value\n            self.points_set = set()\n\n        def _recursive_solver(self, a, b, tol, depth):\n            \"\"\"\n            The recursive core of the adaptive Simpson's method.\n            \"\"\"\n            # 1. Define the 5 points for the two-level Simpson's rule\n            c = (a + b) / 2.0\n            d = (a + c) / 2.0\n            e = (c + b) / 2.0\n\n            # 2. Evaluate the function at the necessary points\n            # To avoid duplicate additions to the set, check first if needed,\n            # but for simplicity, we add all 5 and let the set handle uniqueness.\n            # This is less performant but conceptually clear.\n            fa, fb, fc = self.func(a), self.func(b), self.func(c)\n            fd, fe = self.func(d), self.func(e)\n            \n            # Record all unique evaluation points\n            self.points_set.update([a, b, c, d, e])\n\n            # 3. Compute coarse (S1) and fine (S2) approximations\n            # S1: Simpson's rule on [a, b]\n            s1 = (b - a) * (fa + 4 * fc + fb) / 6.0\n            # S2: Composite Simpson's rule on [a, c] and [c, b]\n            s2 = (b - a) * (fa + 4 * fd + 2 * fc + 4 * fe + fb) / 12.0\n\n            # 4. Estimate the error of the more accurate approximation, S2\n            # The error is estimated as |S2 - S1| / 15\n            error = abs(s2 - s1) / 15.0\n\n            # 5. Check stopping conditions\n            if depth = 0 or error  tol:\n                # Return the best estimate using Richardson extrapolation\n                return s2 + (s2 - s1) / 15.0\n            else:\n                # 6. Recurse on subintervals with scaled tolerance\n                left_integral = self._recursive_solver(a, c, tol / 2.0, depth - 1)\n                right_integral = self._recursive_solver(c, b, tol / 2.0, depth - 1)\n                return left_integral + right_integral\n\n        def compute(self, a, b, tau, d_max):\n            \"\"\"\n            Public method to run the adaptive quadrature for a given problem setup.\n            \"\"\"\n            self.points_set.clear()\n            \n            # Start the recursion\n            integral_approx = self._recursive_solver(a, b, tau, d_max)\n            \n            # Calculate absolute error\n            abs_error = abs(integral_approx - self.exact_value)\n            \n            # Analyze node distribution\n            n_low = 0\n            n_high = 0\n            pi_val = np.pi\n            for p in self.points_set:\n                if p  pi_val:\n                    n_low += 1\n                else:  # p >= pi_val\n                    n_high += 1\n            \n            high_more = n_high > n_low\n            \n            return [integral_approx, abs_error, n_low, n_high, high_more]\n\n    # Define the problem's domain and exact integral value\n    a_domain, b_domain = 0, 2 * np.pi\n    i_exact = 2.0\n    \n    # Instantiate the solver\n    solver = AdaptiveQuadrature(func=f, exact_value=i_exact)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (tau, D_max)\n        (1e-6, 40),   # general case\n        (1e-4, 20),   # moderate tolerance\n        (1e-8, 12),   # tight tolerance, limited depth\n    ]\n\n    # Run the solver for each case and collect results\n    results = []\n    for tau, d_max in test_cases:\n        result = solver.compute(a_domain, b_domain, tau, d_max)\n        results.append(result)\n\n    # Format the final output string as required\n    # Custom formatter to handle boolean correctly as lowercased string\n    def format_item(item):\n        if isinstance(item, bool):\n            return str(item).lower()\n        return str(item)\n\n    # Format each inner list\n    formatted_results = []\n    for res_list in results:\n        formatted_list = f\"[{','.join(format_item(item) for item in res_list)}]\"\n        formatted_results.append(formatted_list)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3203443"}, {"introduction": "任何数值方法都有其局限性，理解这些局限性与掌握其工作原理同等重要。这个练习是一个思想实验，挑战你构建一个特定的函数，使得自适应算法的误差估计机制失效，从而在没有递归细分的情况下就提前终止并返回错误的结果 [@problem_id:2153040]。完成这一挑战将帮助你更批判性地看待数值方法，并深化对其背后假设的理解。", "problem": "一个自适应求积算法被设计用于在期望的容差 $\\epsilon  0$ 内，数值近似计算连续函数 $f(x)$ 的定积分 $I = \\int_a^b f(x)\\,dx$。该算法基于辛普森法则，在任意给定区间 $[u, v]$ 上按以下步骤运行：\n\n1.  使用辛普森法则在整个区间上计算一个粗略近似值：\n    $$S_1 = \\frac{v-u}{6}\\left(f(u) + 4f\\left(\\frac{u+v}{2}\\right) + f(v)\\right)$$\n2.  通过将两个半区间 $[u, w]$ 和 $[w, v]$（其中 $w = (u+v)/2$）上的辛普森法则结果相加，计算一个更精确的近似值：\n    $$S_2 = \\frac{w-u}{6}\\left(f(u) + 4f\\left(\\frac{u+w}{2}\\right) + f(w)\\right) + \\frac{v-w}{6}\\left(f(w) + 4f\\left(\\frac{w+v}{2}\\right) + f(v)\\right)$$\n3.  使用以下公式估计更精确近似值 $S_2$ 的误差：\n    $$E = \\frac{1}{15}|S_2 - S_1|$$\n4.  如果估计误差 $E$ 小于为区间 $[u,v]$ 分配的容差，则算法在该区间上终止，并返回 $S_2$ 作为其值。否则，该算法将递归地应用于子区间 $[u, w]$ 和 $[w, v]$，每个子区间的容差为原容差的一半。\n\n考虑计算一个函数在区间 $[-1, 1]$ 上的积分。下列哪个连续函数会使得该算法在第一次检查时就终止（即没有任何递归），并返回一个不正确的值 0？假设初始容差 $\\epsilon$ 是任意小的正数。\n\nA. $f(x) = 3x^2 - 1$\n\nB. $f(x) = \\sin(\\pi x)$\n\nC. $f(x) = \\cos\\left(\\frac{\\pi}{2} x\\right)$\n\nD. $f(x) = 16x^6 - 20x^4 + x^2 + 1$\n\nE. $f(x) = x^5 - x^3 + x$", "solution": "为了让算法在对于任意小的正容差 $\\epsilon$ 的情况下都在第一次检查时终止，初始区间上的估计误差必须恰好为零。对于 $[u,v]=[-1,1]$ 且 $w=0$，两个辛普森近似值为\n$$\nS_{1}=\\frac{1}{3}\\left(f(-1)+4f(0)+f(1)\\right),\n$$\n$$\nS_{2}=\\frac{1}{6}\\left(f(-1)+4f\\left(-\\frac{1}{2}\\right)+f(0)\\right)+\\frac{1}{6}\\left(f(0)+4f\\left(\\frac{1}{2}\\right)+f(1)\\right)\n=\\frac{1}{6}\\left(f(-1)+f(1)+2f(0)+4f\\left(-\\frac{1}{2}\\right)+4f\\left(\\frac{1}{2}\\right)\\right).\n$$\n误差估计为\n$$\nE=\\frac{1}{15}|S_{2}-S_{1}|.\n$$\n要对任意 $\\epsilon0$ 终止，我们需要 $E=0$，即 $S_{2}=S_{1}$。为了使算法返回不正确的值 $0$，我们还必须有 $S_{2}=0$，同时真实积分值 $\\int_{-1}^{1}f(x)\\,dx\\neq 0$。\n\n对每个选项计算 $S_{1}$ 和 $S_{2}$：\n\nA. $f(x)=3x^{2}-1$。计算 $f(-1)=2$，$f(0)=-1$，$f(1)=2$ 以及 $f\\left(\\pm\\frac{1}{2}\\right)=3\\cdot\\frac{1}{4}-1=-\\frac{1}{4}$。则\n$$\nS_{1}=\\frac{1}{3}(2+4(-1)+2)=0,\\quad\nS_{2}=\\frac{1}{6}\\left(2+2+2(-1)+4\\left(-\\frac{1}{4}\\right)+4\\left(-\\frac{1}{4}\\right)\\right)=0.\n$$\n此外，$\\int_{-1}^{1}(3x^{2}-1)\\,dx=\\left[x^{3}-x\\right]_{-1}^{1}=0$，所以返回 0 是正确的，而不是不正确的。\n\nB. $f(x)=\\sin(\\pi x)$。计算 $f(-1)=0$，$f(0)=0$，$f(1)=0$，$f\\left(-\\frac{1}{2}\\right)=-1$，$f\\left(\\frac{1}{2}\\right)=1$。则\n$$\nS_{1}=0,\\quad S_{2}=\\frac{1}{6}\\left(0+0+0+4(-1)+4(1)\\right)=0,\n$$\n并且 $\\int_{-1}^{1}\\sin(\\pi x)\\,dx=0$（被积函数为奇函数），所以返回 0 是正确的。\n\nC. $f(x)=\\cos\\left(\\frac{\\pi}{2}x\\right)$。计算 $f(-1)=0$，$f(0)=1$，$f(1)=0$，$f\\left(\\pm\\frac{1}{2}\\right)=\\cos\\left(\\pm\\frac{\\pi}{4}\\right)=\\frac{\\sqrt{2}}{2}$。则\n$$\nS_{1}=\\frac{1}{3}(0+4\\cdot 1+0)=\\frac{4}{3},\\quad\nS_{2}=\\frac{1}{6}\\left(0+0+2\\cdot 1+4\\cdot\\frac{\\sqrt{2}}{2}+4\\cdot\\frac{\\sqrt{2}}{2}\\right)=\\frac{1}{6}\\left(2+4\\sqrt{2}\\right)=\\frac{1}{3}\\left(1+2\\sqrt{2}\\right)\\neq 0,\n$$\n所以算法不会返回 0。\n\nD. $f(x)=16x^{6}-20x^{4}+x^{2}+1$。计算 $f(-1)=-2$，$f(0)=1$，$f(1)=-2$ 以及 $f\\left(\\pm\\frac{1}{2}\\right)=16\\left(\\frac{1}{64}\\right)-20\\left(\\frac{1}{16}\\right)+\\frac{1}{4}+1=\\frac{1}{4}$。则\n$$\nS_{1}=\\frac{1}{3}(-2+4\\cdot 1-2)=0,\\quad\nS_{2}=\\frac{1}{6}\\left(-2-2+2\\cdot 1+4\\cdot\\frac{1}{4}+4\\cdot\\frac{1}{4}\\right)=\\frac{1}{6}(-4+2+1+1)=0.\n$$\n因此 $E=0$ 且算法立即终止，返回 0。真实的积分值为\n$$\n\\int_{-1}^{1}\\left(16x^{6}-20x^{4}+x^{2}+1\\right)dx\n=2\\int_{0}^{1}\\left(16x^{6}-20x^{4}+x^{2}+1\\right)dx\n=2\\left(\\frac{16}{7}-4+\\frac{1}{3}+1\\right)\n=2\\left(\\frac{16}{7}-\\frac{8}{3}\\right)\n=-\\frac{16}{21}\\neq 0,\n$$\n所以返回的值 0 是不正确的。\n\nE. $f(x)=x^{5}-x^{3}+x$ 是奇函数，因此 $S_{1}=0$，$S_{2}=0$（根据节点和权重的对称性），并且 $\\int_{-1}^{1}f(x)\\,dx=0$，所以返回 0 是正确的。\n\n只有选项 D 满足要求：以 $E=0$ 立即终止并返回 0，而真实的积分值非零。", "answer": "$$\\boxed{D}$$", "id": "2153040"}]}