{"hands_on_practices": [{"introduction": "在进行科学研究时，一个核心问题是在收集数据之前确定需要多少样本。这个过程被称为样本量规划，它确保我们有足够大的机会（即统计功效）检测到我们关心的效应大小。本练习将指导你完成一个双样本$t$检验的样本量计算，通过推导将统计功效与非中心$t$分布联系起来，这是实验设计中的一项基本技能。[@problem_id:3172267]", "problem": "一位研究人员计划进行一项均衡的双样本研究，比较两个独立的、假定为具有相同但未知方差的高斯总体。设 $X_{1},\\dots,X_{n} \\overset{\\text{i.i.d.}}{\\sim} \\mathcal{N}(\\mu_{1},\\sigma^{2})$ 和 $Y_{1},\\dots,Y_{n} \\overset{\\text{i.i.d.}}{\\sim} \\mathcal{N}(\\mu_{2},\\sigma^{2})$，且所有观测值相互独立。主要分析将使用合并双样本 $t$ 统计量进行 $H_{0}:\\mu_{1}-\\mu_{2}=0$ 对 $H_{1}:\\mu_{1}-\\mu_{2}=\\delta>0$ 的单侧检验。一项初步研究表明，在规划时，共同标准差可取为 $\\sigma=1.2$，而具有科学意义的、需要检测的差异为 $\\delta=0.6$。显著性水平为 $\\alpha=0.05$（单侧），当真实差异等于 $\\delta$ 时，期望的功效为 $1-\\beta=0.9$。\n\n从适用于正态抽样和检验统计量抽样分布的基本原理出发：\n- 定义合并双样本 $t$ 统计量，并根据具有相应自由度的中心 $t$ 分布，确定其在 $H_{0}$ 下的抽样分布。\n- 根据非中心 $t$ 分布确定其在 $H_{1}$ 下的抽样分布，并用 $n$、$\\delta$ 和 $\\sigma$ 表示非中心化参数。\n- 将功效要求转换为一个涉及非中心 $t$ 分布的概率陈述，然后基于大样本行为推导出一个易于处理的近似，从而得出一个关于 $n$ 的、用标准正态分位数表示的封闭形式的规划公式。\n- 使用该推导，计算达到或超过目标功效的每组最小整数样本量 $n$。\n\n最后，简要概述您将如何通过模拟检验统计量在 $H_{1}$ 下的抽样分布来验证所达到的功效，明确说明您将采取的生成数据、计算检验统计量、确定拒绝和估计功效的步骤。不需要进行数值模拟；只需要一个清晰、有原则的验证计划。\n\n将满足功效要求的每组最小整数样本量 $n$ 作为您的最终答案。不要包含单位。由于 $n$ 是整数，无需四舍五入到有效数字。", "solution": "该问题是有效的，因为它代表了统计功效分析中的一个标准且定义明确的问题，这是统计学习和实验设计的核心课题。所有必要的参数都已提供，问题在既定的统计理论中有科学依据，并且没有歧义或矛盾。\n\n目标是确定一个均衡双样本 $t$ 检验达到指定功效所需的每组最小样本量 $n$。解决方案首先定义检验统计量及其在原假设和备择假设下的抽样分布，然后推导样本量公式，计算所需的 $n$，最后概述一个基于模拟的验证计划。\n\n设两个独立的随机样本为 $X_{1}, \\dots, X_{n} \\overset{\\text{i.i.d.}}{\\sim} \\mathcal{N}(\\mu_{1},\\sigma^{2})$ 和 $Y_{1}, \\dots, Y_{n} \\overset{\\text{i.i.d.}}{\\sim} \\mathcal{N}(\\mu_{2},\\sigma^{2})$。样本量相等 ($n_1=n_2=n$)，且总体方差假定相等但未知。\n\n样本均值为 $\\bar{X} = \\frac{1}{n}\\sum_{i=1}^{n} X_i$ 和 $\\bar{Y} = \\frac{1}{n}\\sum_{i=1}^{n} Y_i$。样本方差为 $S_{X}^{2} = \\frac{1}{n-1}\\sum_{i=1}^{n} (X_i - \\bar{X})^2$ 和 $S_{Y}^{2} = \\frac{1}{n-1}\\sum_{i=1}^{n} (Y_i - \\bar{Y})^2$。合并方差估计量 $S_p^2$ 结合了两个样本的信息来估计共同方差 $\\sigma^2$，其公式为：\n$$S_p^2 = \\frac{(n-1)S_X^2 + (n-1)S_Y^2}{(n-1) + (n-1)} = \\frac{S_X^2 + S_Y^2}{2}$$\n该估计量与 $df = (n-1) + (n-1) = 2n-2$ 的自由度相关联。\n\n合并双样本 $t$ 统计量定义为：\n$$T = \\frac{(\\bar{X} - \\bar{Y}) - (\\mu_1 - \\mu_2)}{S_p \\sqrt{\\frac{1}{n} + \\frac{1}{n}}} = \\frac{\\bar{X} - \\bar{Y} - (\\mu_1 - \\mu_2)}{S_p \\sqrt{\\frac{2}{n}}}$$\n\n在原假设 $H_0: \\mu_1 - \\mu_2 = 0$ 下，该统计量简化为：\n$$T_0 = \\frac{\\bar{X} - \\bar{Y}}{S_p \\sqrt{\\frac{2}{n}}}$$\n在 $H_0$ 下，$T_0$ 的抽样分布是自由度为 $2n-2$ 的中心 $t$ 分布。我们记作 $T_0 \\sim t_{2n-2}$。\n\n在备择假设 $H_1: \\mu_1 - \\mu_2 = \\delta > 0$ 下，$t$ 统计量的分子 $\\bar{X} - \\bar{Y}$ 的均值为 $\\delta$，而不是 $0$。为了确定其分布，我们可以将统计量 $T$ 表示为一个非标准正态变量与一个独立的、经过缩放的卡方变量的平方根之比：\n$$T = \\frac{\\frac{(\\bar{X} - \\bar{Y}) - (\\mu_1 - \\mu_2)}{\\sigma \\sqrt{2/n}} + \\frac{\\mu_1 - \\mu_2}{\\sigma \\sqrt{2/n}}}{\\sqrt{S_p^2/\\sigma^2}}$$\n在 $H_1$ 下，项 $\\frac{(\\bar{X} - \\bar{Y}) - \\delta}{\\sigma \\sqrt{2/n}}$ 是一个标准正态变量，$Z \\sim \\mathcal{N}(0,1)$。项 $\\frac{(2n-2)S_p^2}{\\sigma^2}$ 服从自由度为 $df=2n-2$ 的卡方分布，即 $\\chi^2_{2n-2}$。因此，在 $H_1$ 下，统计量 $T$ 服从自由度为 $df=2n-2$、非中心化参数（NCP）为 $\\lambda$ 的非中心 $t$ 分布，$\\lambda$ 由下式给出：\n$$\\lambda = \\frac{\\mu_1 - \\mu_2}{\\sigma \\sqrt{\\frac{2}{n}}} = \\frac{\\delta}{\\sigma \\sqrt{\\frac{2}{n}}} = \\frac{\\delta}{\\sigma}\\sqrt{\\frac{n}{2}}$$\n因此，在 $H_1$ 下，我们有 $T \\sim t_{2n-2}(\\lambda)$。\n\n如果 $T_0$ 超过一个临界值 $c$，单侧检验就拒绝 $H_0$。这个临界值是中心 $t$ 分布的 $(1-\\alpha)$ 分位数，即 $c = t_{1-\\alpha, 2n-2}$。检验的功效 $1-\\beta$ 是当 $H_1$ 为真时拒绝 $H_0$ 的概率：\n$$\\text{Power} = 1-\\beta = P(T > c \\mid H_1) = P\\left(t_{2n-2}(\\lambda) > t_{1-\\alpha, 2n-2}\\right)$$\n为了推导一个易于处理的 $n$ 的公式，我们使用大样本近似。对于大的自由度（$df = 2n-2$），中心 $t_{df}$ 分布趋近于标准正态分布 $\\mathcal{N}(0,1)$，而非中心 $t_{df}(\\lambda)$ 分布趋近于正态分布 $\\mathcal{N}(\\lambda, 1)$。\n使用这个近似，临界值变为 $c \\approx z_{1-\\alpha}$，功效方程变为：\n$$1-\\beta \\approx P(\\mathcal{N}(\\lambda, 1) > z_{1-\\alpha})$$\n设 $Z' \\sim \\mathcal{N}(\\lambda, 1)$。标准化后得到 $Z = Z' - \\lambda \\sim \\mathcal{N}(0,1)$。该概率为：\n$$1-\\beta \\approx P(Z + \\lambda > z_{1-\\alpha}) = P(Z > z_{1-\\alpha} - \\lambda)$$\n因为 $P(Z>z) = 1-\\Phi(z)$，其中 $\\Phi$ 是标准正态累积分布函数（CDF），我们有 $1-\\beta \\approx 1 - \\Phi(z_{1-\\alpha} - \\lambda)$，这意味着 $\\beta \\approx \\Phi(z_{1-\\alpha} - \\lambda)$。对两边取逆正态CDF（分位数函数），得到：\n$$z_{\\beta} \\approx z_{1-\\alpha} - \\lambda$$\n使用恒等式 $z_{\\beta} = -z_{1-\\beta}$，我们得到：\n$$-z_{1-\\beta} \\approx z_{1-\\alpha} - \\lambda$$\n解出非中心化参数 $\\lambda$：\n$$\\lambda \\approx z_{1-\\alpha} + z_{1-\\beta}$$\n现在，我们代入 $\\lambda$ 的表达式：\n$$\\frac{\\delta}{\\sigma}\\sqrt{\\frac{n}{2}} \\approx z_{1-\\alpha} + z_{1-\\beta}$$\n最后，我们求解每组的样本量 $n$：\n$$\\sqrt{n} \\approx \\frac{\\sigma \\sqrt{2}}{\\delta}(z_{1-\\alpha} + z_{1-\\beta})$$\n$$n \\approx 2 \\left(\\frac{\\sigma}{\\delta}\\right)^2 (z_{1-\\alpha} + z_{1-\\beta})^2$$\n这就是所需的用于规划的 $n$ 的封闭形式公式。\n\n我们现在使用给定的值计算 $n$：$\\sigma = 1.2$，$\\delta = 0.6$，$\\alpha = 0.05$（单侧），以及功效 $1-\\beta = 0.9$（所以 $\\beta = 0.1$）。我们需要标准正态分位数：\n$z_{1-\\alpha} = z_{0.95} \\approx 1.645$\n$z_{1-\\beta} = z_{0.90} \\approx 1.282$\n将这些值代入公式：\n$$n \\approx 2 \\left(\\frac{1.2}{0.6}\\right)^2 (1.645 + 1.282)^2$$\n$$n \\approx 2 (2)^2 (2.927)^2$$\n$$n \\approx 8 (8.567329)$$\n$$n \\approx 68.5386$$\n由于样本量必须是整数，且功效必须至少为 $0.9$，我们必须向上取整到最接近的整数。\n$$n = 69$$\n\n为验证此结果，可以进行蒙特卡洛模拟。计划如下：\n1.  **设置模拟参数**：定义 $H_1$ 下世界的真实状态和检验参数。\n    - 均值真实差异：$\\mu_1 - \\mu_2 = \\delta = 0.6$。设 $\\mu_1 = 0.6$ 和 $\\mu_2 = 0$。\n    - 真实标准差：$\\sigma = 1.2$。\n    - 每组样本量：$n = 69$。\n    - 显著性水平：$\\alpha = 0.05$（单侧）。\n    - 模拟重复次数：$M$，一个大整数（例如，$M=10,000$ 或更高）。\n2.  **计算临界值**：确定检验的确切临界值。当 $n=69$ 时，自由度为 $df = 2(69)-2 = 136$。临界值为 $c = t_{1-\\alpha, df} = t_{0.95, 136}$。\n3.  **运行模拟循环**：对于从 $1$ 到 $M$ 的每次重复 $i$：\n    a. **生成数据**：抽取两个大小为 $n=69$ 的独立样本：$X_{1}^{(i)}, \\dots, X_{n}^{(i)} \\sim \\mathcal{N}(0.6, 1.2^2)$ 和 $Y_{1}^{(i)}, \\dots, Y_{n}^{(i)} \\sim \\mathcal{N}(0, 1.2^2)$。\n    b. **计算检验统计量**：根据生成的数据，计算观测到的合并双样本 $t$ 统计量，$T_{obs}^{(i)} = \\frac{\\bar{X}^{(i)} - \\bar{Y}^{(i)}}{S_p^{(i)} \\sqrt{2/n}}$。\n    c. **检验决策**：将观测到的统计量与临界值进行比较。如果 $T_{obs}^{(i)} > c$，则此次重复拒绝原假设。\n4.  **估计功效**：估计的功效是 $H_0$ 被拒绝的重复次数所占的比例。\n    $$\\widehat{\\text{Power}} = \\frac{\\text{拒绝次数}}{M}$$\n5.  **验证**：将估计的功效 $\\widehat{\\text{Power}}$ 与目标功效 $0.9$ 进行比较。一个接近 $0.9$ 的值将验证样本量的计算。", "answer": "$$\\boxed{69}$$", "id": "3172267"}, {"introduction": "从比较均值到用线性回归建模变量间的关系，我们进入了更复杂的分析领域。综合$F$检验是评估整个回归模型是否显著的基础工具。本模拟练习将通过编程验证一个重要的理论结果：即使在现实数据中常见的自变量相关（甚至共线）的情况下，$F$统计量的理论分布依然成立，这加深了我们对该理论稳健性的理解。[@problem_id:3172367]", "problem": "考虑一个固定设计的正态线性模型：对于整数 $n \\geq 2$ 和 $p \\geq 1$，设 $X \\in \\mathbb{R}^{n \\times p}$ 是一个非随机的设计矩阵，设 $y \\in \\mathbb{R}^{n}$ 满足 $y = X \\beta + \\varepsilon$，其中 $\\beta \\in \\mathbb{R}^{p}$ 是一个未知的参数向量，$\\varepsilon \\sim \\mathcal{N}(0, \\sigma^{2} I_{n})$ 且 $\\sigma^{2} > 0$ 为已知值。本题关注此模型中原假设 $H_{0}: \\beta = 0$ 的综合检验。已知在 $H_{0}$ 为真时，以 $X$ 为条件，通过将 $y$ 正交分解到 $X$ 的列空间及其正交补空间而构建的检验统计量，其精确抽样分布仅取决于相关投影的秩。\n\n您的任务是编写一个程序，在多种相关设计场景下，数值上验证以下结论：即使 $X$ 的列是相关的，甚至可能是线性相关的，在原假设 $H_{0}$ 下，综合 $F$ 统计量的条件抽样分布也精确地是中心 $F$ 分布，其自由度由 $X$ 的秩决定。您必须使用多元正态生成器构建具有等相关特征列的 $X$，固定 $X$，在 $H_{0}$ 下模拟大量独立的 $y$ 实现，使用对 $X$ 列空间的最小二乘投影（对秩亏具有稳健性）为每次实现计算综合 $F$ 统计量，然后将该统计量的经验分布与理论中心 $F$ 分布进行比较。将所有矩阵和向量视为无物理单位的纯数学对象。\n\n使用的基本原理：\n- 正态线性模型假设：$\\varepsilon \\sim \\mathcal{N}(0, \\sigma^{2} I_{n})$，其中 $X$ 是固定的。\n- $\\mathbb{R}^{n}$ 中正交投影的性质以及高斯向量二次型的分布。\n- 卡方分布和中心 $F$ 分布的定义。\n- 自由度（df）的概念：投影矩阵的秩决定了相关卡方分布的自由度。\n\n程序要求：\n1. 对每个测试用例，按如下方式构建 $X$。\n   - 从一个均值为零、协方差为等相关矩阵 $\\Sigma \\in \\mathbb{R}^{p \\times p}$ 的 $p$ 元正态分布中独立抽取 $X$ 的行。该协方差矩阵的元素为：对所有 $i$，$\\Sigma_{ii} = 1$；对所有 $i \\neq j$，$\\Sigma_{ij} = \\rho$，其中 $\\rho \\in (-1, 1)$ 是一个指定值。\n   - （根据每个测试的指定）可选择通过将 $X$ 的最后一列替换为前两列之和来强制实现完全线性相关：$X_{\\cdot, p} \\leftarrow X_{\\cdot, 1} + X_{\\cdot, 2}$。\n   - 计算 $X$ 列空间的一个标准正交基 $Q \\in \\mathbb{R}^{n \\times r}$，其中 $r$ 是通过奇异值分解并使用标准容差规则得到的 $X$ 的数值秩。此过程必须能处理满秩和秩亏两种设计。\n2. 在每个测试用例中，以固定的 $X$ 为条件，在 $H_{0}$ 下模拟 $m$ 次独立的实现 $y^{(1)}, \\dots, y^{(m)}$，其中 $\\beta = 0$ 且 $\\sigma^{2} = 1$；这等价于抽取 $\\varepsilon^{(k)} \\sim \\mathcal{N}(0, I_{n})$ 并设 $y^{(k)} = \\varepsilon^{(k)}$，其中 $k = 1, \\dots, m$。\n3. 对每次实现，使用由 $Q$ 导出的分解计算综合 $F$ 统计量：\n   - 回归平方和是 $y^{(k)}$ 在 $X$ 列空间上投影的范数的平方，即 $\\operatorname{SSR}^{(k)} = \\|Q^{\\top} y^{(k)}\\|^{2}$。\n   - 残差平方和是 $y^{(k)}$ 在正交补空间上投影的范数的平方，即 $\\operatorname{SSE}^{(k)} = \\|y^{(k)}\\|^{2} - \\operatorname{SSR}^{(k)}$。\n   - 综合统计量为 $F^{(k)} = \\left(\\operatorname{SSR}^{(k)} / r\\right) \\big/ \\left(\\operatorname{SSE}^{(k)} / (n - r)\\right)$。\n4. 对每个测试用例，用两种互补的方式验证条件抽样分布的精确性：\n   - 分位数一致性：计算 $\\{F^{(k)}\\}_{k=1}^{m}$ 在概率 $q \\in \\{0.25, 0.5, 0.75, 0.9\\}$ 处的经验分位数，并与自由度为 $(r, n - r)$ 的中心 $F$ 分布的相应理论分位数进行比较。报告这些概率点上的最大相对偏差是否小于指定的容差。\n   - 均匀 $p$ 值：使用自由度为 $(r, n - r)$ 的中心 $F$ 分布计算右尾 $p$ 值 $p^{(k)}$，并使用 Kolmogorov–Smirnov (KS) 检验（Kolmogorov–Smirnov (KS) 将作为此检验的缩写）评估 $\\{p^{(k)}\\}$ 是否与 Uniform$(0,1)$ 分布一致。报告 KS 统计量是否不超过指定的阈值。\n5. 结合这两项检查，为每个测试用例生成一个布尔结果：如果两项检查都通过，则返回 $true$，否则返回 $false$。\n\n测试套件：\n- 用例 1 (理想路径，相关满秩)：$n = 200$, $p = 5$, $\\rho = 0.8$，不强制共线性, $m = 5000$。\n- 用例 2 (边界情况，$p = 1$，$F$ 简化为 $t$ 的平方)：$n = 50$, $p = 1$, $\\rho = 0.0$，不强制共线性, $m = 5000$。\n- 用例 3 (边缘情况，完全共线性)：$n = 100$, $p = 4$, $\\rho = 0.5$，强制 $X_{\\cdot, 4} \\leftarrow X_{\\cdot, 1} + X_{\\cdot, 2}$, $m = 5000$。\n- 用例 4 (特征多且高度相关)：$n = 80$, $p = 10$, $\\rho = 0.99$，不强制共线性, $m = 5000$。\n\n接受阈值：\n- 分位数相对偏差容差：如果 $\\left|\\widehat{Q}(q) - Q_{F}(q; r, n - r)\\right| / Q_{F}(q; r, n - r)$ 在 $q \\in \\{0.25, 0.5, 0.75, 0.9\\}$ 上的最大值小于 $0.07$，则测试通过。其中 $\\widehat{Q}(q)$ 是经验分位数，$Q_{F}(q; r, n - r)$ 是理论中心 $F$ 分位数。\n- KS 统计量阈值：如果将 $\\{p^{(k)}\\}$ 与 Uniform$(0,1)$ 进行比较的 KS 统计量不超过 $0.035$，则测试通过。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，\"[$result_{1},result_{2},result_{3},result_{4}$]\"），其中 $result_{i}$ 是上述第 $i$ 个用例的 $true$ 或 $false$ 结果。所有布尔值必须为小写。\n\n不允许外部输入，并且必须在程序内部固定随机数生成器种子以确保可复现性。所有答案都是无量纲的实数或布尔值，因此不需要指定物理单位。每个测试用例的全部计算必须在固定的 $X$ 的条件下完成，即，一旦构建了 $X$，就不要在测试用例内重新抽样。", "solution": "该问题要求对线性模型理论中的一个基本结果进行数值验证：在原假设 $H_{0}: \\beta = 0$ 下，综合 $F$ 统计量服从一个中心 $F$ 分布，其自由度由设计矩阵 $X$ 的秩决定。即使 $X$ 的列是相关的或线性相关的，此性质依然成立。该验证将通过在不同场景下模拟数据，并将计算出的 $F$ 统计量的经验分布与其理论对应分布进行比较来完成。\n\n该结果的理论基础是高斯随机向量的投影和二次型的性质，通常由 Cochran 定理总结。在正态线性模型 $y = X \\beta + \\varepsilon$ (其中 $\\varepsilon \\sim \\mathcal{N}(0, \\sigma^2 I_n)$) 中，原假设 $H_0: \\beta=0$ 意味着 $y = \\varepsilon \\sim \\mathcal{N}(0, \\sigma^2 I_n)$。为简单起见且不失一般性（因为 $F$ 统计量对 $\\sigma^2$ 是不变的），我们设 $\\sigma^2=1$，因此 $y \\sim \\mathcal{N}(0, I_n)$。\n\n总平方和 $\\|y\\|^2$ 可以被正交分解为回归平方和 (SSR) 与误差平方和 (SSE)。此分解是使用到 $X$ 列空间（记为 $\\operatorname{col}(X)$）的投影矩阵 $P_X$ 及其正交补 $P_{X^\\perp} = I_n - P_X$ 来实现的。\n回归平方和是 $y$ 在 $\\operatorname{col}(X)$ 上投影的范数的平方：\n$$ \\operatorname{SSR} = \\|P_X y\\|^2 = y^\\top P_X y $$\n残差平方和是 $y$ 在 $\\operatorname{col}(X)$ 正交补空间上投影的范数的平方：\n$$ \\operatorname{SSE} = \\|P_{X^\\perp} y\\|^2 = y^\\top P_{X^\\perp} y = \\|y\\|^2 - \\operatorname{SSR} $$\n根据 Cochran 定理，由于 $y \\sim \\mathcal{N}(0, I_n)$，二次型 $\\operatorname{SSR}$ 和 $\\operatorname{SSE}$ 是独立的，且服从卡方分布。各自的自由度由其相应投影矩阵的秩决定：\n$$ \\operatorname{SSR} \\sim \\chi^2_{r} \\quad \\text{其中} \\quad r = \\operatorname{rank}(P_X) = \\operatorname{rank}(X) $$\n$$ \\operatorname{SSE} \\sim \\chi^2_{n-r} \\quad \\text{其中} \\quad n-r = \\operatorname{rank}(P_{X^\\perp}) $$\n综合 $F$ 统计量定义为回归均方与误差均方之比：\n$$ F = \\frac{\\operatorname{SSR} / r}{\\operatorname{SSE} / (n-r)} $$\n根据定义，由两个独立的卡方变量分别除以其自由度后得到的比率所构成的随机变量，服从 $F$ 分布。因此，统计量 $F$ 服从自由度为 $(r, n-r)$ 的中心 $F$ 分布，记为 $F(r, n-r)$。至关重要的一点是，分子自由度是 $r=\\operatorname{rank}(X)$，而不一定是列数 $p$。这是处理秩亏设计矩阵的关键。\n\n数值实现过程如下：\n1. **设计矩阵构建**：对于每个测试用例，我们首先构建固定的 $n \\times p$ 设计矩阵 $X$。我们从一个 $p$ 元正态分布 $\\mathcal{N}(0, \\Sigma)$ 中生成 $n$ 个独立的行，其中 $\\Sigma$ 是一个等相关矩阵，$\\Sigma_{ii}=1$ 且对于 $i \\neq j$ 有 $\\Sigma_{ij}=\\rho$。这是通过生成标准正态变量并使用 $\\Sigma$ 的 Cholesky 分解进行变换来实现的。对于需要完全共线性的情况，将特定的一列替换为其他列的线性组合。\n\n2. **秩与基的计算**：处理相关和秩亏设计的关键步骤是准确确定 $X$ 的秩 $r$ 及其列空间的一个相应的标准正交基。$X$ 的奇异值分解（SVD） $X = U S V^\\top$ 提供了一种数值上稳定的方法来完成此任务。显著大于零的奇异值的数量给出了数值秩 $r$。矩阵 $U$ 的前 $r$ 列构成了 $\\operatorname{col}(X)$ 的一个标准正交基 $Q \\in \\mathbb{R}^{n \\times r}$。\n\n3. **F 统计量模拟**：以固定的矩阵 $X$ 为条件，我们在 $H_0$ 下模拟 $m=5000$ 个独立的响应向量 $y^{(k)}$ 的实现。当 $\\sigma^2=1$ 时，每个 $y^{(k)}$ 都是从 $\\mathcal{N}(0, I_n)$ 中抽取的一个样本。对每个 $y^{(k)}$，我们计算 $F$ 统计量。投影矩阵 $P_X$ 可以写作 $P_X = QQ^\\top$。然后，回归平方和可以高效地计算为 $\\operatorname{SSR}^{(k)} = \\|Q^\\top y^{(k)}\\|^2$。残差平方和为 $\\operatorname{SSE}^{(k)} = \\|y^{(k)}\\|^2 - \\operatorname{SSR}^{(k)}$。最后，统计量为 $F^{(k)} = \\left(\\operatorname{SSR}^{(k)}/r\\right) / \\left(\\operatorname{SSE}^{(k)}/(n-r)\\right)$。\n\n4. **分布验证**：\n- **分位数一致性**：我们计算 $m=5000$ 个模拟 $F$ 统计量在概率 $q \\in \\{0.25, 0.5, 0.75, 0.9\\}$ 处的经验分位数。将它们与 $F(r, n-r)$ 分布的理论分位数进行比较。如果最大相对偏差低于 $0.07$ 的容差，则检验通过。\n- **Kolmogorov-Smirnov (KS) 检验**：我们使用理论 $F$ 分布的生存函数，将每个模拟的统计量 $F^{(k)}$ 转换为一个 $p$ 值，$p^{(k)} = P(F_{r, n-r} \\ge F^{(k)})$。如果原始统计量确实服从 $F(r, n-r)$ 分布，那么得到的 $p$ 值应该在 $(0, 1)$ 上均匀分布。我们使用 KS 检验来测试这一假设。如果 KS 统计量低于 $0.035$ 的阈值，则检验通过。\n\n一个测试用例仅在两个验证检查都通过时才被视为成功（返回 `true`），从而以高数值置信度证实了理论结果。程序会遍历所有指定的测试用例，包括那些具有高相关性和完全共线性的用例，以证明该理论的稳健性。固定的随机种子确保了整个模拟研究的可复现性。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import f, kstest\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases for verifying the F-statistic distribution\n    in a normal linear model and print the results.\n    \"\"\"\n    # Define global parameters for the simulation study\n    M_SIMS = 5000\n    QUANTILE_LEVELS = [0.25, 0.5, 0.75, 0.9]\n    QUANTILE_TOL = 0.07\n    KS_TOL = 0.035\n    SEED = 42\n\n    # Initialize a random number generator for reproducibility\n    rng = np.random.default_rng(SEED)\n\n    # Define the suite of test cases\n    test_cases = [\n        # Case 1: Correlated full rank design\n        {'n': 200, 'p': 5, 'rho': 0.8, 'enforce_collinearity': False, 'label': 'Case 1'},\n        # Case 2: p=1, where F is equivalent to a squared t-statistic\n        {'n': 50, 'p': 1, 'rho': 0.0, 'enforce_collinearity': False, 'label': 'Case 2'},\n        # Case 3: Perfect collinearity (rank-deficient design)\n        {'n': 100, 'p': 4, 'rho': 0.5, 'enforce_collinearity': True, 'label': 'Case 3'},\n        # Case 4: Highly correlated design, potentially numerically rank-deficient\n        {'n': 80, 'p': 10, 'rho': 0.99, 'enforce_collinearity': False, 'label': 'Case 4'},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_test_case(\n            n=case['n'],\n            p=case['p'],\n            rho=case['rho'],\n            enforce_collinearity=case['enforce_collinearity'],\n            m_sims=M_SIMS,\n            quantile_levels=QUANTILE_LEVELS,\n            quantile_tol=QUANTILE_TOL,\n            ks_tol=KS_TOL,\n            rng=rng\n        )\n        results.append(str(result).lower())\n    \n    # Print the final results in the required format\n    print(f\"[{','.join(results)}]\")\n\ndef run_test_case(n, p, rho, enforce_collinearity, m_sims, quantile_levels, quantile_tol, ks_tol, rng):\n    \"\"\"\n    Executes a single simulation scenario to validate the F-statistic's distribution.\n\n    Args:\n        n (int): Number of observations.\n        p (int): Number of features.\n        rho (float): Equicorrelation coefficient for features.\n        enforce_collinearity (bool): Flag to enforce linear dependence.\n        m_sims (int): Number of simulation replications.\n        quantile_levels (list): Probabilities for quantile comparison.\n        quantile_tol (float): Tolerance for relative deviation of quantiles.\n        ks_tol (float): Threshold for the Kolmogorov-Smirnov statistic.\n        rng (np.random.Generator): NumPy random number generator instance.\n\n    Returns:\n        bool: True if both validation checks pass, False otherwise.\n    \"\"\"\n    # Step 1: Construct the design matrix X\n    mean = np.zeros(p)\n    if p == 1:\n        cov_matrix = np.array([[1.0]])\n    else:\n        cov_matrix = np.full((p, p), rho)\n        np.fill_diagonal(cov_matrix, 1.0)\n    \n    # Generate X with rows drawn from N(0, cov_matrix)\n    X = rng.multivariate_normal(mean, cov_matrix, size=n)\n\n    if enforce_collinearity:\n        if p >= 3:\n            # Replace the last column with a linear combination of the first two\n            X[:, p-1] = X[:, 0] + X[:, 1]\n        else:\n            # Cannot enforce this type of collinearity if p  3\n            return False\n\n    # Step 2: Determine rank and orthonormal basis Q for Col(X)\n    r = np.linalg.matrix_rank(X)\n    \n    if r == 0:\n        return False # Zero matrix has no well-defined F-test\n    if n - r == 0:\n        # F-statistic is not well-defined if residual degrees of freedom is not positive\n        return False \n        \n    # SVD is a robust method to find an orthonormal basis for the column space\n    U, _, _ = np.linalg.svd(X, full_matrices=False)\n    Q = U[:, :r]\n\n    # Step 3: Simulate m realizations of y and compute F-statistics\n    # Under H0: y = epsilon ~ N(0, I_n)\n    y_realizations = rng.standard_normal(size=(n, m_sims))\n    \n    # SSR = ||Q'y||^2\n    projected_y = Q.T @ y_realizations\n    ssr = np.sum(np.square(projected_y), axis=0)\n    \n    # SSE = ||y||^2 - SSR\n    y_sq_norm = np.sum(np.square(y_realizations), axis=0)\n    sse = y_sq_norm - ssr\n    \n    # F = (SSR/r) / (SSE/(n-r))\n    f_stats = (ssr / r) / (sse / (n - r))\n    \n    # Step 4: Validate the empirical distribution against the theoretical F-distribution\n    \n    # 4a: Quantile agreement check\n    empirical_quantiles = np.quantile(f_stats, quantile_levels)\n    theoretical_quantiles = f.ppf(quantile_levels, dfn=r, dfd=n-r)\n    \n    # Avoid division by zero, though F quantiles for q>0 are positive\n    if np.any(theoretical_quantiles = 1e-9):\n        quantile_check_passed = False\n    else:\n        relative_deviations = np.abs(empirical_quantiles - theoretical_quantiles) / theoretical_quantiles\n        max_rel_dev = np.max(relative_deviations)\n        quantile_check_passed = max_rel_dev  quantile_tol\n\n    # 4b: Uniform p-values check using the KS test\n    # p-values are computed using the survival function (1 - CDF) for better precision\n    p_values = f.sf(f_stats, dfn=r, dfd=n-r)\n    ks_statistic, _ = kstest(p_values, 'uniform')\n    ks_check_passed = ks_statistic = ks_tol\n\n    return quantile_check_passed and ks_check_passed\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3172367"}, {"introduction": "现代数据分析，尤其是在基因组学等领域，常常需要同时检验成千上万个假设。本练习探讨了多重检验对错误率控制带来的挑战。我们将从熟悉的$t$分布出发，研究在大量检验中*最极端*的检验统计量的分布规律，并理解像Bonferroni校正这样的方法是如何帮助我们控制总体错误率的。[@problem_id:3172330]", "problem": "您的任务是设计并实现一个基于仿真的研究，主题是高维零模型下的多重检验，重点关注学生 t 统计量的抽样分布、其在多个独立特征上的最大绝对值分布，以及用于控制族系误差率（FWER）的 Bonferroni 校正。\n\n您可以假设的基本原理：\n- 在均值为零、方差未知的正态模型下，对于单个特征，单样本学生 t 统计量计算为 $T = \\frac{\\bar{X}}{S / \\sqrt{n}}$，其中 $X_1,\\dots,X_n$ 是来自正态分布的独立同分布样本，$S$ 是样本标准差。在真实均值为 0 的零假设下，该统计量服从自由度为 $\\nu = n - 1$ 的学生 t 分布。\n- Bonferroni 不等式指出，对于事件 $A_1,\\dots,A_p$，$\\Pr\\left(\\bigcup_{j=1}^{p} A_j\\right) \\le \\sum_{j=1}^{p} \\Pr(A_j)$。\n- 特征间独立性：假设在全局零假设下，$p$ 个特征是独立的。\n\n场景与任务：\n- 考虑 $p$ 个独立特征，每个特征都处于零假设下，其数据从均值为零、方差未知的正态分布中抽样；对于每个特征，双侧检验统计量 $T_j$ 是自由度为 $\\nu = n - 1$ 的学生 t 统计量。\n- 将跨特征的最大绝对统计量定义为 $M = \\max_{1 \\le j \\le p} |T_j|$。\n- 您的任务是：\n  1. 使用 Bonferroni 不等式解析推导出一个阈值 $c_B$，确保在水平 $\\alpha$ 下对 $p$ 个双侧检验的族系误差率（FWER）最多为 $\\alpha$。用自由度为 $\\nu = n - 1$ 的学生 t 分布的逆累积分布函数来表示 $c_B$，并且除了所述的基本原理外，不使用任何快捷公式。\n  2. 实现一个仿真，对于每个测试用例，从自由度为 $\\nu = n - 1$ 的学生 t 分布中重复抽取 $p$ 个独立的 $T_j$ 值，以近似全局零假设下 $M$ 的分布。为保证可复现性，使用固定的伪随机数生成器种子 $123456$。\n  3. 对于每个测试用例，计算：\n     - 在步骤 1 中推导出的 Bonferroni 阈值 $c_B$。\n     - 在 $c_B$ 处的经验 FWER，定义为仿真重复中至少有一个 $|T_j|$ 超过 $c_B$ 的比例（以小数表示）。\n     - 在仿真重复中 $M$ 的经验均值。\n\n要实现的仿真细节：\n- 对于每次重复，从自由度为 $\\nu = n - 1$ 的学生 t 分布中生成 $p$ 个独立的抽样值，以代表 $p$ 个零假设下的 t 统计量，取其绝对值，并记录最大值。\n- 重复 $R$ 次。\n- 将经验 FWER 计算为最大绝对统计量超过 $c_B$ 的重复次数所占的比例。\n- 计算所有重复中最大绝对统计量的经验均值。\n\n测试套件：\n- 使用以下三个测试用例，每个指定为 $(n, p, \\alpha, R)$：\n  1. $(20, 50, 0.05, 40000)$ 作为具有中等 $p$ 和常用显著性水平的一般情况。\n  2. $(20, 1, 0.05, 100000)$ 作为只有一个检验的边界情况，此时 Bonferroni 阈值应与通常的双侧阈值一致。\n  3. $(5, 200, 0.01, 20000)$ 作为样本量小（自由度小）、特征多且显著性水平严格的重尾情况。\n\n输出要求：\n- 对于每个测试用例，输出一个包含三个实数的列表 $[c_B, \\text{empirical\\_FWER}, \\text{mean\\_max}]$，四舍五入到 $6$ 位小数，其中所有三个值均为小数（无百分号）。\n- 将所有测试用例的结果聚合到这些三元组的单个列表中，以逗号分隔列表的形式打印在一行上，并用方括号括起来，不含额外文本。例如，包含两个测试用例的输出应类似于 $[[x_{11},x_{12},x_{13}],[x_{21},x_{22},x_{23}]]$，其中每个 $x_{ij}$ 是格式化为 $6$ 位小数的实数。\n\n角度单位和物理单位：\n- 此问题不涉及角度或物理单位。\n\n您的程序必须：\n- 是一个完整的、可运行的程序，不需要用户输入，也不访问外部文件或网络。\n- 使用指定的伪随机数种子 $123456$。\n- 精确地生成一行符合指定格式的输出。", "solution": "在尝试提供解决方案之前，对问题进行了验证。\n\n**问题验证**\n\n**步骤 1：提取给定条件**\n- **模型：** 对于 $p$ 个独立特征中的每一个，数据都从均值为零、方差未知的正态分布中抽样。\n- **检验统计量：** 特征 $j$ 的单样本学生 t 统计量为 $T_j$。在零假设下，$T_j \\sim t_{\\nu}$，其中 $\\nu = n - 1$。\n- **全局零假设：** 所有 $p$ 个特征都处于零假设下。特征被假定为独立的。\n- **关注的统计量：** 跨特征的最大绝对统计量为 $M = \\max_{1 \\le j \\le p} |T_j|$。\n- **Bonferroni 不等式：** $\\Pr\\left(\\bigcup_{j=1}^{p} A_j\\right) \\le \\sum_{j=1}^{p} \\Pr(A_j)$。\n- **任务 1 (分析)：** 使用 Bonferroni 不等式推导出一个阈值 $c_B$，以确保对 $p$ 个双侧检验的族系误差率 (FWER) $\\le \\alpha$。表达式必须用学生 t 分布的逆累积分布函数表示。\n- **任务 2 (仿真)：** 实现一个仿真，通过为每次重复从 $t_{n-1}$ 中抽样 $p$ 个独立的值来近似 $M$ 的分布。必须使用固定的种子 $123456$。\n- **任务 3 (计算)：** 根据仿真结果，计算 Bonferroni 阈值 $c_B$、在 $c_B$ 处的经验 FWER，以及 $M$ 的经验均值。\n- **仿真参数：** $R$ 次重复。\n- **测试用例 $(n, p, \\alpha, R)$:**\n  1. $(20, 50, 0.05, 40000)$\n  2. $(20, 1, 0.05, 100000)$\n  3. $(5, 200, 0.01, 20000)$\n- **输出格式：** 对于每个测试用例，一个列表 $[c_B, \\text{empirical\\_FWER}, \\text{mean\\_max}]$，其值四舍五入到 $6$ 位小数。最终输出是这些列表的聚合列表。\n\n**步骤 2：使用提取的给定条件进行验证**\n该问题在已建立的假设检验（特别是多重比较）的统计理论方面具有科学依据。它利用了诸如学生 t 分布、Bonferroni 校正、族系误差率 (FWER) 和蒙特卡洛模拟等标准概念。该问题是良定的，提供了明确的目标、所有必要的参数（$n, p, \\alpha, R$）和明确的定义。任务是无歧义的，并能导出一个唯一的解析推导和一个可复现的数值结果（给定固定种子）。该问题是客观的，没有任何科学或事实上的不健全、不完整或矛盾之处。这是一个标准的、非平凡的计算统计学练习。\n\n**步骤 3：结论与行动**\n该问题被判定为**有效**。将提供解决方案。\n\n**方法论**\n\n**1. Bonferroni 阈值 ($c_B$) 的解析推导**\n\n族系误差率 (FWER) 是在假设全局零假设（即所有单个零假设都为真）正确的情况下，在所有 $p$ 个检验中至少犯一次 I 类错误的概率。对于第 $j$ 个特征检验，如果我们在零假设 $H_{0j}$ 为真时拒绝它，就发生了 I 类错误。对于基于统计量 $T_j$ 的双侧检验，如果其绝对值超过一个临界阈值 $|T_j|  c$，我们就拒绝 $H_{0j}$。\n\n因此，FWER 定义为：\n$$\n\\text{FWER} = \\Pr\\left( \\bigcup_{j=1}^{p} \\{|T_j|  c\\} \\right)\n$$\n我们寻求一个阈值，我们称之为 $c_B$，使得 FWER 被控制在水平 $\\alpha$ 以下，即 FWER $\\le \\alpha$。\n\n对事件的并集应用 Bonferroni 不等式：\n$$\n\\text{FWER} = \\Pr\\left( \\bigcup_{j=1}^{p} \\{|T_j|  c_B\\} \\right) \\le \\sum_{j=1}^{p} \\Pr(|T_j|  c_B)\n$$\n在全局零假设下，每个统计量 $T_j$ 都是来自自由度为 $\\nu = n-1$ 的学生 t 分布的独立抽样。由于对于所有 $j=1,\\dots,p$，分布都是相同的，所以概率 $\\Pr(|T_j|  c_B)$ 都相等。因此，总和简化为：\n$$\n\\sum_{j=1}^{p} \\Pr(|T_j|  c_B) = p \\cdot \\Pr(|T|  c_B)\n$$\n其中 $T$ 是一个服从自由度为 $\\nu$ 的学生 t 分布的随机变量，$T \\sim t_{\\nu}$。\n\n为确保 FWER $\\le \\alpha$，我们对 Bonferroni 上界施加更严格的条件：\n$$\np \\cdot \\Pr(|T|  c_B) = \\alpha\n$$\n这将每个单独检验的显著性水平设置为 $\\alpha/p$。\n$$\n\\Pr(|T|  c_B) = \\frac{\\alpha}{p}\n$$\n事件 $|T|  c_B$ 对应于 $T  c_B$ 或 $T  -c_B$。由于学生 t 分布关于 0 的对称性，$\\Pr(T  c_B) = \\Pr(T  -c_B)$。因此：\n$$\n\\Pr(|T|  c_B) = 2 \\cdot \\Pr(T  c_B)\n$$\n将此代入前一个方程得到：\n$$\n2 \\cdot \\Pr(T  c_B) = \\frac{\\alpha}{p} \\implies \\Pr(T  c_B) = \\frac{\\alpha}{2p}\n$$\n为了找到 $c_B$，我们可以使用 t 分布的累积分布函数 (CDF)，记为 $F_{t, \\nu}(x) = \\Pr(T \\le x)$。尾部概率为 $\\Pr(T  c_B) = 1 - F_{t, \\nu}(c_B)$。\n$$\n1 - F_{t, \\nu}(c_B) = \\frac{\\alpha}{2p} \\implies F_{t, \\nu}(c_B) = 1 - \\frac{\\alpha}{2p}\n$$\n最后，通过应用逆 CDF（也称为分位数函数或百分点函数），记为 $F_{t, \\nu}^{-1}$，我们得到 Bonferroni 阈值 $c_B$ 的表达式：\n$$\nc_B = F_{t, \\nu}^{-1}\\left(1 - \\frac{\\alpha}{2p}\\right)\n$$\n这是用于计算 $c_B$ 的解析公式。\n\n**2. 仿真与指标计算**\n\n实现了一个蒙特卡洛模拟来研究最大绝对统计量 $M = \\max_{j} |T_j|$ 的分布，并评估 Bonferroni 校正的性能。对于每个测试用例 $(n, p, \\alpha, R)$ 的过程如下：\n\n1.  **初始化**：使用 $123456$ 为伪随机数生成器设定种子，以确保可复现性。自由度计算为 $\\nu = n-1$。\n\n2.  **生成检验统计量**：生成一个大小为 $R \\times p$ 的矩阵，其中每个元素都是来自自由度为 $\\nu$ 的学生 t 分布的独立抽样。该矩阵代表了 $p$ 个零假设下 t 统计量的 $R$ 次重复。\n    $$\n    \\mathbf{T} = \\begin{pmatrix} T_{11}  \\dots  T_{1p} \\\\ \\vdots  \\ddots  \\vdots \\\\ T_{R1}  \\dots  T_{Rp} \\end{pmatrix}, \\quad T_{ij} \\sim t_{\\nu} \\text{ i.i.d.}\n    $$\n\n3.  **计算最大绝对统计量**：对于 $R$ 次重复中的每一次（矩阵的每一行），计算 $p$ 个统计量绝对值的最大值。这会产生一个包含 $R$ 个 $M$ 值的向量。\n    $$\n    M_i = \\max_{1 \\le j \\le p} |T_{ij}|, \\quad \\text{for } i=1, \\dots, R\n    $$\n\n4.  **计算经验 FWER**：计算解析推导出的 Bonferroni 阈值 $c_B$。经验 FWER 是最大绝对统计量 $M_i$ 超过此阈值的仿真重复所占的比例。这是 $\\Pr(M  c_B)$ 的一个蒙特卡洛估计。\n    $$\n    \\text{empirical\\_FWER} = \\frac{1}{R} \\sum_{i=1}^{R} \\mathbf{1}(M_i  c_B)\n    $$\n    其中 $\\mathbf{1}(\\cdot)$ 是指示函数。\n\n5.  **计算 M 的经验均值**：最大绝对统计量的经验均值是观测到的 $R$ 个 $M_i$ 值的算术平均值。\n    $$\n    \\text{mean\\_max} = \\frac{1}{R} \\sum_{i=1}^{R} M_i\n    $$\n这三个量——$c_B$、经验 FWER 和 $M$ 的均值——为每个测试用例计算并按规定报告。$p=1$ 的情况用作验证，此时 Bonferroni 校正无效，经验 FWER 应非常接近名义水平 $\\alpha$。小 $n$ 和大 $p$ 的情况展示了在重尾分布和高维多重检验负担下的行为。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import t\n\ndef solve():\n    \"\"\"\n    Performs a simulation study on multiple testing with Bonferroni correction.\n\n    For each test case, the function:\n    1. Analytically calculates the Bonferroni-corrected critical value (c_B).\n    2. Simulates the distribution of the maximum absolute t-statistic under the global null.\n    3. Computes the empirical Family-Wise Error Rate (FWER) at the c_B threshold.\n    4. Computes the empirical mean of the maximum absolute t-statistic.\n    \"\"\"\n    # Test suite: each entry is a tuple of (n, p, alpha, R)\n    # n: sample size\n    # p: number of features (tests)\n    # alpha: target FWER\n    # R: number of simulation replicates\n    test_cases = [\n        (20, 50, 0.05, 40000),      # General case\n        (20, 1, 0.05, 100000),      # Boundary case (single test)\n        (5, 200, 0.01, 20000),       # Heavy-tailed case\n    ]\n\n    # Seed the random number generator for reproducibility.\n    # Using default_rng is the modern, recommended practice.\n    rng = np.random.default_rng(123456)\n\n    results = []\n    \n    for n, p, alpha, R in test_cases:\n        # Degrees of freedom for the Student's t-distribution\n        df = n - 1\n\n        # 1. Analytically derive the Bonferroni threshold c_B\n        # The Bonferroni-corrected significance level for each of p two-sided tests\n        # is alpha / p. For a two-sided test, this probability mass is split\n        # into two tails, so the upper tail probability is (alpha / p) / 2.\n        # The quantile corresponds to a cumulative probability of 1 - (alpha / (2*p)).\n        bonferroni_p_value_per_tail = alpha / (2 * p)\n        c_b = t.ppf(1 - bonferroni_p_value_per_tail, df=df)\n\n        # 2. Simulate the distribution of M = max |T_j|\n        # Generate R replicates of p independent t-statistics\n        # The size is (R, p) for R rows (replicates) and p columns (features).\n        t_statistics = rng.standard_t(df, size=(R, p))\n\n        # Take the absolute value of all generated statistics\n        abs_t_statistics = np.abs(t_statistics)\n\n        # For each replicate, find the maximum absolute value across the p features\n        # axis=1 computes the max along each row.\n        max_abs_t = np.max(abs_t_statistics, axis=1)\n\n        # 3. Compute empirical FWER and the mean of the maximum statistic\n        # The empirical FWER is the proportion of replicates where the maximum\n        # absolute statistic exceeds the Bonferroni threshold.\n        # np.mean of a boolean array correctly computes the proportion of True values.\n        empirical_fwer = np.mean(max_abs_t > c_b)\n\n        # The empirical mean of M is the average of the observed maximums.\n        mean_max = np.mean(max_abs_t)\n\n        # Store the results for the current test case.\n        results.append([c_b, empirical_fwer, mean_max])\n\n    # Format the final output string as specified in the problem statement.\n    # E.g., [[val1,val2,val3],[val4,val5,val6]]\n    # Each value is formatted to 6 decimal places.\n    inner_results_str = [\n        f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\" for res in results\n    ]\n    final_output_str = f\"[{','.join(inner_results_str)}]\"\n\n    print(final_output_str)\n\nsolve()\n\n```", "id": "3172330"}]}