{"hands_on_practices": [{"introduction": "当我们从样本数据中计算统计量（如分位数）时，我们得到的是对真实总体值的估计。这个估计本身也存在不确定性。本练习将指导你使用一种基础的统计技术——delta方法——来量化样本分位数的函数的不确定性，这在金融风险管理等领域是一项常见任务。通过这个实践，你将建立对样本统计量可靠性的基础理解。[@problem_id:3177964]", "problem": "给定一个包含 $n$ 个归一化每日损失幅度的数集：\n$0.80,\\, 0.55,\\, 1.20,\\, 0.30,\\, 0.95,\\, 0.67,\\, 1.50,\\, 0.40,\\, 0.72,\\, 0.88,\\, 1.10,\\, 0.33,\\, 0.60,\\, 0.77,\\, 0.25,\\, 1.30,\\, 0.52,\\, 0.66,\\, 0.90,\\, 0.45$。\n您的任务是使用基本定义估计一个高分位数风险并量化其不确定性，然后根据非参数自举汇总来验证您不确定性估计的量级。\n\n使用经验累积分布函数（CDF；cumulative distribution function）反演，从样本中估计 $p = 0.90$ 的 $p$-分位数。将下游风险度量定义为 $R(q) = \\exp(\\beta q)$，其中 $\\beta = 0.50$，并在您的经验分位数估计值处进行评估。从第一性原理出发，使用德尔塔方法（delta method），通过将经验分位数中的不确定性传播到 $R(\\cdot)$ 中，来推导和计算 $\\widehat{R}$ 的标准误差。为了估计样本分位数方差在分位数处的密度 $f(q)$，请使用最近顺序统计量的对称间距（即，通过经验CDF在 $x_{(r-1)}$ 和 $x_{(r+1)}$ 之间的有限差分来局部逼近 $f(q)$，其中 $r$ 是经验 $p$-分位数的索引）。作为量级检验，使用 $B = 1000$ 次重采样进行的非参数自举法得到的风险度量样本标准差为 $0.121$。\n\n计算并报告 $\\widehat{R}$ 的德尔塔方法标准误差，并将您的答案四舍五入到四位有效数字。不涉及物理单位；提供一个无单位的数值。", "solution": "### 解\n目标是使用德尔塔方法计算估计的风险度量 $\\widehat{R} = R(\\widehat{q}_p)$ 的标准误差。该过程包括几个步骤：找到样本分位数，推导标准误差的德尔塔方法近似形式，估计此近似的各个组成部分，最后计算数值。\n\n首先，我们必须确定样本大小并对给定数据进行排序，以找到顺序统计量 $x_{(i)}$。样本大小为 $n = 20$。排序后的数集为：\n$x_{(1)} = 0.25$, $x_{(2)} = 0.30$, $x_{(3)} = 0.33$, $x_{(4)} = 0.40$, $x_{(5)} = 0.45$,\n$x_{(6)} = 0.52$, $x_{(7)} = 0.55$, $x_{(8)} = 0.60$, $x_{(9)} = 0.66$, $x_{(10)} = 0.67$,\n$x_{(11)} = 0.72$, $x_{(12)} = 0.77$, $x_{(13)} = 0.80$, $x_{(14)} = 0.88$, $x_{(15)} = 0.90$,\n$x_{(16)} = 0.95$, $x_{(17)} = 1.10$, $x_{(18)} = 1.20$, $x_{(19)} = 1.30$, $x_{(20)} = 1.50$。\n\n问题指定使用经验CDF反演来估计 $p=0.90$ 分位数 $\\widehat{q}_{0.90}$。样本 $p$-分位数的一个常用定义是第 $r$ 个顺序统计量，其中 $r = \\lceil n \\cdot p \\rceil$。\n对于 $n=20$ 和 $p=0.90$，索引为：\n$$ r = \\lceil 20 \\times 0.90 \\rceil = \\lceil 18 \\rceil = 18 $$\n因此，估计的 $0.90$-分位数是第 $18$ 个顺序统计量：\n$$ \\widehat{q}_{0.90} = x_{(18)} = 1.20 $$\n\n风险度量为 $R(q) = \\exp(\\beta q)$，其中 $\\beta=0.50$。估计的风险为：\n$$ \\widehat{R} = R(\\widehat{q}_{0.90}) = \\exp(0.50 \\times 1.20) = \\exp(0.60) $$\n\n德尔塔方法近似了估计量 $\\widehat{\\theta}$ 的函数 $g(\\widehat{\\theta})$ 的方差。对于单变量估计量，近似值为 $\\text{Var}(g(\\widehat{\\theta})) \\approx [g'(\\theta)]^2 \\text{Var}(\\widehat{\\theta})$。\n在我们的情境中，$\\widehat{\\theta}$ 是样本分位数 $\\widehat{q}_p$，而 $g(\\cdot)$ 是风险函数 $R(\\cdot)$。因此，$\\widehat{R}$ 的方差是：\n$$ \\text{Var}(\\widehat{R}) \\approx [R'(q_p)]^2 \\text{Var}(\\widehat{q}_p) $$\n其中 $q_p$ 是真实的总体分位数。标准误差是方差的平方根。\n\n首先，我们求 $R(q)$ 的导数：\n$$ R'(q) = \\frac{d}{dq} \\exp(\\beta q) = \\beta \\exp(\\beta q) $$\n我们使用我们的估计值来评估这个导数：\n$$ R'(\\widehat{q}_{0.90}) = 0.50 \\times \\exp(0.50 \\times 1.20) = 0.50 \\exp(0.60) $$\n\n接下来，我们需要样本分位数的方差 $\\text{Var}(\\widehat{q}_p)$。该方差的大样本近似为：\n$$ \\text{Var}(\\widehat{q}_p) \\approx \\frac{p(1-p)}{n [f(q_p)]^2} $$\n其中 $f(q_p)$ 是概率密度函数在真实分位数 $q_p$ 处的值。我们需要估计 $f(q_p)$。问题指导我们使用我们估计的分位数 $x_{(r)}$ 周围最近顺序统计量的对称间距。这给出了密度估计：\n$$ \\widehat{f}(x_{(r)}) = \\frac{(r+1)/n - (r-1)/n}{x_{(r+1)} - x_{(r-1)}} = \\frac{2/n}{x_{(r+1)} - x_{(r-1)}} $$\n对于我们的分位数 $\\widehat{q}_{0.90} = x_{(18)}$，我们有 $r=18$。我们需要相邻的顺序统计量 $x_{(17)}$ 和 $x_{(19)}$。\n从排序后的列表中，$x_{(17)} = 1.10$ 和 $x_{(19)} = 1.30$。\n将这些值与 $n=20$ 代入：\n$$ \\widehat{f}(\\widehat{q}_{0.90}) = \\frac{2/20}{x_{(19)} - x_{(17)}} = \\frac{0.1}{1.30 - 1.10} = \\frac{0.1}{0.2} = 0.50 $$\n\n现在我们可以估计样本分位数的方差：\n$$ \\widehat{\\text{Var}}(\\widehat{q}_{0.90}) = \\frac{p(1-p)}{n [\\widehat{f}(\\widehat{q}_{0.90})]^2} = \\frac{0.90 \\times (1-0.90)}{20 \\times (0.50)^2} = \\frac{0.09}{20 \\times 0.25} = \\frac{0.09}{5} = 0.018 $$\n\n最后，我们结合这些结果来找到估计的风险度量 $\\widehat{R}$ 的方差：\n$$ \\widehat{\\text{Var}}(\\widehat{R}) \\approx [R'(\\widehat{q}_{0.90})]^2 \\widehat{\\text{Var}}(\\widehat{q}_{0.90}) $$\n$$ \\widehat{\\text{Var}}(\\widehat{R}) \\approx [0.50 \\exp(0.60)]^2 \\times 0.018 $$\n标准误差 $\\text{SE}(\\widehat{R})$ 是方差的平方根：\n$$ \\text{SE}(\\widehat{R}) = \\sqrt{\\widehat{\\text{Var}}(\\widehat{R})} \\approx \\sqrt{[0.50 \\exp(0.60)]^2 \\times 0.018} $$\n$$ \\text{SE}(\\widehat{R}) \\approx |0.50 \\exp(0.60)| \\sqrt{0.018} = 0.50 \\exp(0.60) \\sqrt{0.018} $$\n现在我们计算数值：\n$$ \\exp(0.60) \\approx 1.8221188 $$\n$$ \\sqrt{0.018} \\approx 0.1341640786 $$\n$$ \\text{SE}(\\widehat{R}) \\approx 0.50 \\times 1.8221188 \\times 0.1341640786 \\approx 0.122235 $$\n四舍五入到四位有效数字，我们得到 $0.1222$。这个值与提供的自举估计值 $0.121$ 一致，证实了我们计算的合理性。", "answer": "$$\\boxed{0.1222}$$", "id": "3177964"}, {"introduction": "在估计分位数的基础上，我们现在来探讨一个实践中的细微差别：对于有限的、离散的数据集，我们应该如何定义分位数？不同的软件包使用不同的“插值规则”，而这个选择并不仅仅是学术上的。本练习将展示这些看似微小的技术细节如何对现实世界的结果产生重大影响，例如模型中的决策阈值及其导致的算法公平性。[@problem_id:3177907]", "problem": "给定两个有限的实值分数集，代表两个人口群体，以及一个全局决策规则。根据该规则，当且仅当个体的分数大于或等于一个阈值时，该个体被接纳。该阈值由两个群体合并分数的特定经验分位数定义。主要目标是比较在不同插值规则下计算的经验分位数，并量化它们对使用百分位阈值的公平性指标的下游影响。\n\n起点与定义：\n- 设 $X$ 为一个实值随机变量，其累积分布函数 (CDF) 为 $F(x) = \\mathbb{P}(X \\le x)$。对于一个分位数水平 $q \\in [0,1]$，$q$-分位数是任何满足 $F(x_q) \\ge q$ 且 $F(x_q^{-}) \\le q$ 的值 $x_q$，其中 $x_q^{-}$ 表示从左侧逼近的极限。\n- 给定一个大小为 $n$ 的有限样本，经验累积分布函数 (ECDF) 是 $F_n(x) = \\frac{1}{n} \\sum_{i=1}^{n} \\mathbf{1}\\{X_i \\le x\\}$，其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数，$X_i$ 是观测到的分数。经验 $q$-分位数是使用 $F_n$ 和一个插值规则来定义的，该规则指定了如何处理相邻顺序统计量之间的非整数秩。\n- 待比较的插值规则是以下广泛使用的约定：“lower”（选择不超过目标秩的最大观测值）、“higher”（选择不小于目标秩的最小观测值）、“nearest”（选择最接近的观测秩）、“midpoint”（包含目标秩的相邻观测值的平均值）以及“linear”（根据目标秩的小数部分，在两个相邻观测值之间进行线性插值）。所有规则都作用于排序后的合并分数，并且仅在如何解决顺序统计量之间的分数秩上有所不同。\n\n待评估的公平性指标：\n- 公平性指标是人口均等 (Demographic Parity, DP) 差异。对于群体 $\\mathcal{A}$ 和 $\\mathcal{B}$，其接受率分别为 $r_{\\mathcal{A}}$ 和 $r_{\\mathcal{B}}$，DP 差异定义为 $d = |r_{\\mathcal{A}} - r_{\\mathcal{B}}|$。接受率必须表示为小数（例如，百分之六十表示为 $0.6$）。\n- 是否接受由一个全局阈值 $T_q$ 决定，该阈值是两个群体合并分数的经验 $q$-分位数。当且仅当个体的分数大于或等于 $T_q$ 时，该个体被接纳。\n\n任务：\n- 对于每个测试用例，在两个群体的合并分数上，使用 $\\{\\text{linear}, \\text{lower}, \\text{higher}, \\text{nearest}, \\text{midpoint}\\}$ 中的每种插值规则计算 $T_q$。\n- 对于每种规则，计算接受率 $r_{\\mathcal{A}}$ 和 $r_{\\mathcal{B}}$，然后计算 DP 差异 $d$。\n- 令 $d_{\\text{linear}}$ 为使用“linear”规则时的 DP 差异。通过计算以下公式来量化该测试用例中插值对公平性指标的影响：\n$$ \\Delta = \\max_{m \\in \\{\\text{lower}, \\text{higher}, \\text{nearest}, \\text{midpoint}\\}} \\left| d_{m} - d_{\\text{linear}} \\right|, $$\n其中 $d_{m}$ 是在方法 $m$ 下的 DP 差异。\n- 整个测试套件的最终输出是一个包含 $\\Delta$ 值的单一列表，每个测试用例一个值，打印在单行上，形式为方括号括起来的逗号分隔列表，例如 $[0.0,0.1,0.05]$。\n\n测试套件：\n- 用例 1（一般情况）：\n  - 群体 $\\mathcal{A}$ 分数：[$0.10$, $0.20$, $0.35$, $0.40$, $0.50$]\n  - 群体 $\\mathcal{B}$ 分数：[$0.05$, $0.25$, $0.30$, $0.45$, $0.55$]\n  - 分位数水平 $q$：$0.70$\n- 用例 2（小样本和中位数阈值的边界情况）：\n  - 群体 $\\mathcal{A}$ 分数：[$0.20$, $0.80$, $0.90$]\n  - 群体 $\\mathcal{B}$ 分数：[$0.10$, $0.70$, $0.95$]\n  - 分位数水平 $q$：$0.50$\n- 用例 3（平局和重复值）：\n  - 群体 $\\mathcal{A}$ 分数：[$0.30$, $0.30$, $0.30$, $0.60$, $0.60$]\n  - 群体 $\\mathcal{B}$ 分数：[$0.40$, $0.40$, $0.40$, $0.40$, $0.70$]\n  - 分位数水平 $q$：$0.60$\n- 用例 4（极端上分位数）：\n  - 群体 $\\mathcal{A}$ 分数：[$0.20$, $0.40$, $0.60$, $0.80$]\n  - 群体 $\\mathcal{B}$ 分数：[$0.10$, $0.30$, $0.50$, $0.70$]\n  - 分位数水平 $q$：$0.95$\n\n精确输出格式要求：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如 $[r_1,r_2,r_3,r_4]$），其中每个 $r_i$ 是第 $i$ 个测试用例计算出的 $\\Delta$ 值。", "solution": "该问题要求分析不同经验分位数插值方法对公平性指标，特别是人口均等 (DP) 差异的影响。对于每个给定的测试用例，我们必须计算一个指标 $\\Delta$，它表示相对于基准的“linear”插值方法，使用替代插值方法（“lower”、“higher”、“nearest”、“midpoint”）所引起的 DP 差异的最大偏差。\n\n每个测试用例的处理流程如下：\n1.  将群体 $\\mathcal{A}$ 和群体 $\\mathcal{B}$ 的分数合并成一个单一的合并数据集。\n2.  对于五种指定的插值方法中的每一种 ($m \\in \\{\\text{linear}, \\text{lower}, \\text{higher}, \\text{nearest}, \\text{midpoint}\\}$)，计算决策阈值 $T_q^{(m)}$。该阈值是使用方法 $m$ 计算的合并分数的经验 $q$-分位数。\n3.  对于每个阈值 $T_q^{(m)}$，确定每个群体的接受率 $r_{\\mathcal{A}}^{(m)}$ 和 $r_{\\mathcal{B}}^{(m)}$。如果个体的分数大于或等于阈值，则该个体被接纳。接受率是一个群体中被接纳的个体所占的比例。\n4.  计算每种方法的 DP 差异，$d_m = |r_{\\mathcal{A}}^{(m)} - r_{\\mathcal{B}}^{(m)}|$。\n5.  最后，计算目标指标 $\\Delta = \\max_{m \\in \\{\\text{lower}, \\text{higher}, \\text{nearest}, \\text{midpoint}\\}} |d_m - d_{\\text{linear}}|$。\n\n计算的核心是经验 $q$-分位数的计算。设大小为 $n$ 的合并并排序的样本由一个以 0 为索引的序列 $S = (x_0, x_1, \\dots, x_{n-1})$ 表示。分位数的值由索引 $k = q(n-1)$ 确定。设 $i = \\lfloor k \\rfloor$ 为该索引的向下取整，$j = \\lceil k \\rceil$ 为向上取整。不同插值方法的阈值 $T_q$ 则计算如下：\n- 线性 (Linear)：$T_q = x_i + (k-i)(x_j - x_i)$\n- 较低 (Lower)：$T_q = x_i$\n- 较高 (Higher)：$T_q = x_j$\n- 中点 (Midpoint)：$T_q = (x_i + x_j) / 2$\n- 最近 (Nearest)：$T_q = x_{\\text{round}(k)}$，其中当小数部分为 0.5 时，舍入到最近的偶数整数。\n\n我们现在将此方法应用于每个测试用例。\n\n**用例 1：**\n- 群体 $\\mathcal{A}$ 分数：[$0.10, 0.20, 0.35, 0.40, 0.50$] ($n_{\\mathcal{A}} = 5$)\n- 群体 $\\mathcal{B}$ 分数：[$0.05, 0.25, 0.30, 0.45, 0.55$] ($n_{\\mathcal{B}} = 5$)\n- 分位数水平 $q = 0.70$\n合并并排序后的分数为 $S = (0.05, 0.10, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50, 0.55)$，大小 $n=10$。\n索引为 $k = 0.70 \\times (10-1) = 6.3$。因此，$i=6$ 且 $j=7$。对应的值为 $x_6 = 0.40$ 和 $x_7 = 0.45$。\n- $T_q^{(\\text{linear})} = 0.40 + (6.3-6)(0.45-0.40) = 0.415$。\n  $r_{\\mathcal{A}} = 1/5 = 0.2$, $r_{\\mathcal{B}} = 2/5 = 0.4$。$d_{\\text{linear}} = |0.2 - 0.4| = 0.2$。\n- $T_q^{(\\text{lower})} = x_6 = 0.40$。\n  $r_{\\mathcal{A}} = 2/5 = 0.4$, $r_{\\mathcal{B}} = 2/5 = 0.4$。$d_{\\text{lower}} = |0.4 - 0.4| = 0.0$。\n- $T_q^{(\\text{higher})} = x_7 = 0.45$。\n  $r_{\\mathcal{A}} = 1/5 = 0.2$, $r_{\\mathcal{B}} = 2/5 = 0.4$。$d_{\\text{higher}} = |0.2 - 0.4| = 0.2$。\n- $T_q^{(\\text{nearest})} = x_{\\text{round}(6.3)} = x_6 = 0.40$。\n  $d_{\\text{nearest}} = d_{\\text{lower}} = 0.0$。\n- $T_q^{(\\text{midpoint})} = (0.40+0.45)/2 = 0.425$。\n  $r_{\\mathcal{A}} = 1/5 = 0.2$, $r_{\\mathcal{B}} = 2/5 = 0.4$。$d_{\\text{midpoint}} = |0.2 - 0.4| = 0.2$。\n与 $d_{\\text{linear}}$ 的差异为 $|0.0 - 0.2| = 0.2$, $|0.2 - 0.2| = 0.0$, $|0.0 - 0.2| = 0.2$ 和 $|0.2 - 0.2| = 0.0$。\n$\\Delta = \\max(0.2, 0.0, 0.2, 0.0) = 0.2$。\n\n**用例 2：**\n- 群体 $\\mathcal{A}$ 分数：[$0.20, 0.80, 0.90$] ($n_{\\mathcal{A}} = 3$)\n- 群体 $\\mathcal{B}$ 分数：[$0.10, 0.70, 0.95$] ($n_{\\mathcal{B}} = 3$)\n- 分位数水平 $q = 0.50$\n合并并排序后的分数为 $S = (0.10, 0.20, 0.70, 0.80, 0.90, 0.95)$，大小 $n=6$。\n索引为 $k = 0.50 \\times (6-1) = 2.5$。因此，$i=2$ 且 $j=3$。对应的值为 $x_2 = 0.70$ 和 $x_3 = 0.80$。\n- $T_q^{(\\text{linear})} = 0.70 + (2.5-2)(0.80-0.70) = 0.75$。\n  $r_{\\mathcal{A}} = 2/3$, $r_{\\mathcal{B}} = 1/3$。$d_{\\text{linear}} = |2/3 - 1/3| = 1/3$。\n- $T_q^{(\\text{lower})} = x_2 = 0.70$。\n  $r_{\\mathcal{A}} = 2/3$, $r_{\\mathcal{B}} = 2/3$。$d_{\\text{lower}} = |2/3 - 2/3| = 0.0$。\n- $T_q^{(\\text{higher})} = x_3 = 0.80$。\n  $r_{\\mathcal{A}} = 2/3$, $r_{\\mathcal{B}} = 1/3$。$d_{\\text{higher}} = |2/3 - 1/3| = 1/3$。\n- $T_q^{(\\text{nearest})} = x_{\\text{round}(2.5)} = x_2 = 0.70$。\n  $d_{\\text{nearest}} = d_{\\text{lower}} = 0.0$。\n- $T_q^{(\\text{midpoint})} = (0.70+0.80)/2 = 0.75$。\n  $d_{\\text{midpoint}} = d_{\\text{linear}} = 1/3$。\n与 $d_{\\text{linear}}$ 的差异为 $|0.0 - 1/3| = 1/3$, $|1/3 - 1/3| = 0.0$, $|0.0 - 1/3| = 1/3$ 和 $|1/3 - 1/3| = 0.0$。\n$\\Delta = \\max(1/3, 0.0, 1/3, 0.0) = 1/3 \\approx 0.333...$。\n\n**用例 3：**\n- 群体 $\\mathcal{A}$ 分数：[$0.30, 0.30, 0.30, 0.60, 0.60$] ($n_{\\mathcal{A}} = 5$)\n- 群体 $\\mathcal{B}$ 分数：[$0.40, 0.40, 0.40, 0.40, 0.70$] ($n_{\\mathcal{B}} = 5$)\n- 分位数水平 $q = 0.60$\n合并并排序后的分数为 $S = (0.30, 0.30, 0.30, 0.40, 0.40, 0.40, 0.40, 0.60, 0.60, 0.70)$，大小 $n=10$。\n索引为 $k = 0.60 \\times (10-1) = 5.4$。因此，$i=5$ 且 $j=6$。对应的值为 $x_5 = 0.40$ 和 $x_6 = 0.40$。\n由于 $x_i = x_j$，所有插值方法都产生相同的阈值 $T_q = 0.40$。\n因此，对于所有方法 $m$，$d_m$ 都是相同的。\n对于 $T_q = 0.40$：\n$r_{\\mathcal{A}} = 2/5 = 0.4$。\n$r_{\\mathcal{B}} = 5/5 = 1.0$。\n$d = |0.4 - 1.0| = 0.6$。\n因为对所有 $m$ 都有 $d_m=0.6$，所以对所有其他方法 $d_m - d_{\\text{linear}} = 0$。\n$\\Delta = 0.0$。\n\n**用例 4：**\n- 群体 $\\mathcal{A}$ 分数：[$0.20, 0.40, 0.60, 0.80$] ($n_{\\mathcal{A}} = 4$)\n- 群体 $\\mathcal{B}$ 分数：[$0.10, 0.30, 0.50, 0.70$] ($n_{\\mathcal{B}} = 4$)\n- 分位数水平 $q = 0.95$\n合并并排序后的分数为 $S = (0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80)$，大小 $n=8$。\n索引为 $k = 0.95 \\times (8-1) = 6.65$。因此，$i=6$ 且 $j=7$。对应的值为 $x_6 = 0.70$ 和 $x_7 = 0.80$。\n- $T_q^{(\\text{linear})} = 0.70 + (6.65-6)(0.80-0.70) = 0.765$。\n  $r_{\\mathcal{A}} = 1/4 = 0.25$, $r_{\\mathcal{B}} = 0/4 = 0.0$。$d_{\\text{linear}} = |0.25 - 0.0| = 0.25$。\n- $T_q^{(\\text{lower})} = x_6 = 0.70$。\n  $r_{\\mathcal{A}} = 1/4 = 0.25$, $r_{\\mathcal{B}} = 1/4 = 0.25$。$d_{\\text{lower}} = |0.25 - 0.25| = 0.0$。\n- $T_q^{(\\text{higher})} = x_7 = 0.80$。\n  $r_{\\mathcal{A}} = 1/4 = 0.25$, $r_{\\mathcal{B}} = 0/4 = 0.0$。$d_{\\text{higher}} = |0.25 - 0.0| = 0.25$。\n- $T_q^{(\\text{nearest})} = x_{\\text{round}(6.65)} = x_7 = 0.80$。\n  $d_{\\text{nearest}} = d_{\\text{higher}} = 0.25$。\n- $T_q^{(\\text{midpoint})} = (0.70+0.80)/2 = 0.75$。\n  $r_{\\mathcal{A}} = 1/4 = 0.25$, $r_{\\mathcal{B}} = 0/4 = 0.0$。$d_{\\text{midpoint}} = |0.25 - 0.0| = 0.25$。\n与 $d_{\\text{linear}}$ 的差异为 $|0.0 - 0.25| = 0.25$, $|0.25 - 0.25| = 0.0$, $|0.25 - 0.25| = 0.0$ 和 $|0.25 - 0.25| = 0.0$。\n$\\Delta = \\max(0.25, 0.0, 0.0, 0.0) = 0.25$。\n\n四个测试用例最终计算出的 $\\Delta$ 值为 $[0.2, 0.333..., 0.0, 0.25]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_delta(scores_A, scores_B, q):\n    \"\"\"\n    Computes the maximum impact of quantile interpolation on the DP difference.\n\n    Args:\n        scores_A (list): A list of real-valued scores for group A.\n        scores_B (list): A list of real-valued scores for group B.\n        q (float): The quantile level, between 0 and 1.\n\n    Returns:\n        float: The computed Delta value for the test case.\n    \"\"\"\n    scores_A_np = np.array(scores_A)\n    scores_B_np = np.array(scores_B)\n    \n    n_A = len(scores_A)\n    n_B = len(scores_B)\n\n    # Pool the scores from both groups.\n    pooled_scores = np.concatenate((scores_A_np, scores_B_np))\n    \n    interpolation_methods = ['linear', 'lower', 'higher', 'nearest', 'midpoint']\n    dp_differences = {}\n    \n    for method in interpolation_methods:\n        # Step 1: Compute the decision threshold T_q using the specified interpolation method.\n        # numpy.quantile's 'method' parameter was named 'interpolation' in older versions.\n        T_q = np.quantile(pooled_scores, q, method=method)\n        \n        # Step 2: Compute acceptance rates for each group.\n        # Acceptance is defined as score = T_q.\n        rate_A = np.sum(scores_A_np = T_q) / n_A\n        rate_B = np.sum(scores_B_np = T_q) / n_B\n        \n        # Step 3: Compute the Demographic Parity (DP) difference.\n        d_m = np.abs(rate_A - rate_B)\n        dp_differences[method] = d_m\n        \n    # Step 4: Quantify the effect of interpolation relative to the 'linear' method.\n    d_linear = dp_differences['linear']\n    other_methods = ['lower', 'higher', 'nearest', 'midpoint']\n    \n    max_abs_diff = 0.0\n    for method in other_methods:\n        diff = np.abs(dp_differences[method] - d_linear)\n        if diff  max_abs_diff:\n            max_abs_diff = diff\n            \n    return max_abs_diff\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general case)\n        (\n            [0.10, 0.20, 0.35, 0.40, 0.50],\n            [0.05, 0.25, 0.30, 0.45, 0.55],\n            0.70\n        ),\n        # Case 2 (boundary with small sample and median threshold)\n        (\n            [0.20, 0.80, 0.90],\n            [0.10, 0.70, 0.95],\n            0.50\n        ),\n        # Case 3 (ties and repeated values)\n        (\n            [0.30, 0.30, 0.30, 0.60, 0.60],\n            [0.40, 0.40, 0.40, 0.40, 0.70],\n            0.60\n        ),\n        # Case 4 (extreme upper quantile)\n        (\n            [0.20, 0.40, 0.60, 0.80],\n            [0.10, 0.30, 0.50, 0.70],\n            0.95\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        scores_A, scores_B, q = case\n        delta = calculate_delta(scores_A, scores_B, q)\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3177907"}, {"introduction": "本练习将百分位数与机器学习的核心任务——模型评估——联系起来。我们将通过一个动手实践揭示ROC曲线下面积（AUC）的一个基本性质：它对于单调变换的不变性。你将通过计算发现，将原始预测分数替换为其全局百分位数秩次并不会改变AUC值，并进一步探索在何种情况下，这种基于秩次的变换能为模型性能分析带来更深刻的洞见。[@problem_id:3177941]", "problem": "给定您的是二元分类数据集，包含一个标签向量和一个对应的实值预测分数向量。您的任务是：(i) 推导并实现预测分数的经验百分位变换；(ii) 计算原始分数和百分位变换后分数的受试者工作特征曲线下面积（AUC；定义见下文）；(iii) 评估在此变换下AUC的稳定性。此外，在原始分数量表因组而异的多组情景中，实现分组百分位归一化，以探究基于百分位的排序是否比原始分数更具信息量。\n\n使用的基本原理和定义：\n- 设 $N$ 为观测数量，索引为 $i \\in \\{1,\\dots,N\\}$。每个观测值都有一个二元标签 $Y_i \\in \\{0,1\\}$ 和一个实值预测分数 $S_i \\in \\mathbb{R}$。\n- 分数的经验累积分布函数（ECDF）定义为 $$ F_N(s) = \\frac{1}{N}\\sum_{j=1}^{N} \\mathbf{1}\\{S_j \\le s\\}, $$ 其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。百分位数是以 $[0,1]$ 区间内的小数表示的分位数；在本任务中，请将百分位数表示为 $[0,1]$ 区间内的小数（而非使用百分号）。\n- 使用中间排名来处理并列值：如果并列分数的排序后位置跨越整数排名 $r_{\\text{low}},\\dots,r_{\\text{high}}$，则为每个并列分数分配中间排名 $$ r_{\\text{mid}} = \\frac{r_{\\text{low}} + r_{\\text{high}}}{2}. $$ 将 $S_i$ 的全局经验百分位定义为 $$ P_i = \\frac{r_i - 0.5}{N}, $$ 其中 $r_i$ 是 $S_i$ 在所有 $N$ 个分数中的中间排名。在具有组 $G_i \\in \\{0,1,\\dots\\}$ 的多组情况下，将分组百分位定义为 $$ P^{(g)}_i = \\frac{r^{(g)}_i - 0.5}{N_g}, $$ 其中 $r^{(g)}_i$ 是 $S_i$ 在其所属组 $g = G_i$ 内的中间排名，而 $N_g$ 是组 $g$ 中的观测数量。\n- 受试者工作特征曲线（ROC）（此处定义为通过对分数设置阈值可实现的所有真阳性率和假阳性率对的集合）的曲线下面积（AUC），可定义为从正标签样本中随机选择一个分数，其值大于从负标签样本中随机选择一个分数的概率，其中平局情况则各记半分。使用排名，设 $m = \\sum_{i=1}^{N} \\mathbf{1}\\{Y_i = 1\\}$ 和 $n = \\sum_{i=1}^{N} \\mathbf{1}\\{Y_i = 0\\}$，并设 $R^+ = \\sum_{i: Y_i=1} r_i$ 为正标签观测值的中间排名之和；则AUC由下式给出：$$ \\text{AUC} = \\frac{R^+ - \\frac{m(m+1)}{2}}{m \\cdot n}. $$\n\n您的程序必须对下方的每个测试用例执行以下操作：\n1. 使用基于中间排名的公式计算原始分数的AUC。\n2. 计算全局百分位分数 $P_i$ 及相应的AUC，然后计算绝对差 $$ \\Delta_{\\text{global}} = \\left|\\text{AUC}_{\\text{raw}} - \\text{AUC}_{\\text{global}}\\right|. $$\n3. 计算分组百分位分数 $P^{(g)}_i$ 及相应的AUC，以及提升量 $$ \\Delta_{\\text{group}} = \\text{AUC}_{\\text{group}} - \\text{AUC}_{\\text{raw}}. $$\n4. 将所有AUC和差异报告为小数。\n\n测试套件（每个用例提供标签 $Y$、分数 $S$ 和整数组标签 $G$）：\n- 用例 $1$（连续、大部分唯一的分数；单组）：\n  - $Y = [0,0,0,0,1,1,1,1,1,0,1,0]$\n  - $S = [0.10,0.15,0.20,0.25,0.30,0.22,0.27,0.35,0.40,0.12,0.33,0.18]$\n  - $G = [0,0,0,0,0,0,0,0,0,0,0,0]$\n- 用例 $2$（大量并列值；单组）：\n  - $Y = [0,0,1,1,0,1,0,1]$\n  - $S = [0.50,0.50,0.50,0.50,0.70,0.70,0.20,0.20]$\n  - $G = [0,0,0,0,0,0,0,0]$\n- 用例 $3$（极端离群值；单组）：\n  - $Y = [0,0,0,0,1,1,1,1,1,0]$\n  - $S = [0.01,0.02,0.03,100.00,0.04,0.05,0.06,0.07,0.08,0.90]$\n  - $G = [0,0,0,0,0,0,0,0,0,0]$\n- 用例 $4$（退化的常数分数；单组）：\n  - $Y = [0,0,0,1,1,1,0,1]$\n  - $S = [0.30,0.30,0.30,0.30,0.30,0.30,0.30,0.30]$\n  - $G = [0,0,0,0,0,0,0,0]$\n- 用例 $5$（具有不同原始分数量表的两个组；预期基于百分位的排序更具信息量）：\n  - $Y = [0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1]$\n  - $S = [20,22,18,24,35,37,33,39,1030,1050,1100,1080,1005,1010,995,1020]$\n  - $G = [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1]$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个列表的列表。对于每个测试用例，按此顺序输出列表 $[\\text{AUC}_{\\text{raw}}, \\text{AUC}_{\\text{global}}, \\Delta_{\\text{global}}, \\text{AUC}_{\\text{group}}, \\Delta_{\\text{group}}]$，所有值均为小数。将五个测试用例的结果汇总到一个列表中，并严格按单行打印，例如：$$ [[a_1,b_1,c_1,d_1,e_1],[a_2,b_2,c_2,d_2,e_2],\\dots]. $$", "solution": "### 1. 核心思想与算法概述\n该问题的核心是验证ROC曲线下面积（AUC）对单调变换的不变性，并探索非单调的组内归一化变换对AUC的影响。\n\n- **AUC计算**: AUC可由Mann-Whitney U统计量导出，其公式完全依赖于分数的秩（rank）而非原始值。我们将实现一个函数，根据问题中提供的公式计算AUC：$$ \\text{AUC} = \\frac{R^+ - \\frac{m(m+1)}{2}}{m \\cdot n} $$ 其中 $m$ 和 $n$ 分别是正负样本的数量，$R^+$ 是正样本的秩之和。秩的计算将使用“中间排名”或“平均排名”来处理并列值。\n\n- **全局百分位变换**: 全局百分位 $P_i$ 定义为 $$ P_i = \\frac{r_i - 0.5}{N} $$ 其中 $r_i$ 是分数 $S_i$ 的全局中间排名，$N$ 是总样本量。这是一个对秩 $r_i$ 的严格增函数，因此它是一个保序（单调）变换。由于AUC仅依赖于秩，此变换不应改变分数的相对顺序，故理论上我们预期 $\\text{AUC}_{\\text{raw}} = \\text{AUC}_{\\text{global}}$，即绝对差 $\\Delta_{\\text{global}}$ 为0（或由于浮点数精度问题而接近0）。\n\n- **分组百分位变换**: 分组百分位 $P^{(g)}_i$ 定义为 $$ P^{(g)}_i = \\frac{r^{(g)}_i - 0.5}{N_g} $$ 其中 $r^{(g)}_i$ 和 $N_g$ 分别是组内的秩和样本量。此变换分别对每个组内的分数进行归一化。这**不是**一个对所有分数的全局单调变换，因为它可能改变跨组样本的相对排序。例如，A组中的最高分（在A组内百分位接近1.0）可能低于B组中的最低分（在B组内百分位接近0.0）。因此，$\\text{AUC}_{\\text{group}}$ 可能会显著不同于 $\\text{AUC}_{\\text{raw}}$。\n\n### 2. 逐步实现\n对于每个测试用例，算法流程如下：\n1.  **计算 $\\text{AUC}_{\\text{raw}}$**: 计算所有原始分数 $S$ 的中间排名，找出正样本的秩并求和，代入公式计算 $\\text{AUC}_{\\text{raw}}$。\n2.  **计算 $\\text{AUC}_{\\text{global}}$ 和 $\\Delta_{\\text{global}}$**:\n    a. 使用上一步的全局排名，计算每个分数的全局百分位分数 $P_i$。\n    b. 使用新的百分位分数 $P_i$ 和原始标签 $Y$ 计算 $\\text{AUC}_{\\text{global}}$。\n    c. 计算 $\\Delta_{\\text{global}} = |\\text{AUC}_{\\text{raw}} - \\text{AUC}_{\\text{global}}|$。\n3.  **计算 $\\text{AUC}_{\\text{group}}$ 和 $\\Delta_{\\text{group}}$**:\n    a. 初始化一个新的分数向量 $P_{\\text{group}}$。\n    b. 遍历所有唯一的组ID。对每个组，提取其内部的分数，计算组内排名，并转换为组内百分位分数。\n    c. 将计算出的组内百分位分数填充回 $P_{\\text{group}}$ 向量的相应位置。\n    d. 使用这个新的 $P_{\\text{group}}$ 分数向量和原始标签 $Y$ 计算 $\\text{AUC}_{\\text{group}}$。\n    e. 计算 $\\Delta_{\\text{group}} = \\text{AUC}_{\\text{group}} - \\text{AUC}_{\\text{raw}}$。\n4.  **汇总结果**: 将五个计算出的值 $[\\text{AUC}_{\\text{raw}}, \\text{AUC}_{\\text{global}}, \\Delta_{\\text{global}}, \\text{AUC}_{\\text{group}}, \\Delta_{\\text{group}}]$ 存储起来。\n\n此过程系统地应用于所有测试用例，最终将所有结果汇总并格式化为列表的列表进行输出。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import rankdata\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases, calculating AUC for raw scores,\n    global-percentile-transformed scores, and groupwise-percentile-transformed\n    scores, along with specified difference metrics.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"Y\": np.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0]),\n            \"S\": np.array([0.10, 0.15, 0.20, 0.25, 0.30, 0.22, 0.27, 0.35, 0.40, 0.12, 0.33, 0.18]),\n            \"G\": np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n        },\n        {\n            \"Y\": np.array([0, 0, 1, 1, 0, 1, 0, 1]),\n            \"S\": np.array([0.50, 0.50, 0.50, 0.50, 0.70, 0.70, 0.20, 0.20]),\n            \"G\": np.array([0, 0, 0, 0, 0, 0, 0, 0])\n        },\n        {\n            \"Y\": np.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 0]),\n            \"S\": np.array([0.01, 0.02, 0.03, 100.00, 0.04, 0.05, 0.06, 0.07, 0.08, 0.90]),\n            \"G\": np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n        },\n        {\n            \"Y\": np.array([0, 0, 0, 1, 1, 1, 0, 1]),\n            \"S\": np.array([0.30, 0.30, 0.30, 0.30, 0.30, 0.30, 0.30, 0.30]),\n            \"G\": np.array([0, 0, 0, 0, 0, 0, 0, 0])\n        },\n        {\n            \"Y\": np.array([0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]),\n            \"S\": np.array([20, 22, 18, 24, 35, 37, 33, 39, 1030, 1050, 1100, 1080, 1005, 1010, 995, 1020]),\n            \"G\": np.array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1])\n        }\n    ]\n\n    def calculate_auc(labels, scores):\n        \"\"\"\n        Calculates AUC using the rank-based formula.\n        AUC = (R_pos - m*(m+1)/2) / (m*n)\n        \"\"\"\n        pos_mask = (labels == 1)\n        m = np.sum(pos_mask)\n        n = len(labels) - m\n\n        if m == 0 or n == 0:\n            return 0.5 # Or np.nan, but 0.5 is a common convention for non-discriminable case\n\n        ranks = rankdata(scores, method='average')\n        R_pos = np.sum(ranks[pos_mask])\n\n        auc = (R_pos - m * (m + 1) / 2) / (m * n)\n        return auc\n\n    def process_case(Y, S, G):\n        \"\"\"\n        Processes a single test case according to the problem description.\n        \"\"\"\n        N = len(Y)\n\n        # 1. Raw-score AUC\n        auc_raw = calculate_auc(Y, S)\n\n        # 2. Global percentile AUC\n        ranks_global = rankdata(S, method='average')\n        P_global = (ranks_global - 0.5) / N\n        auc_global = calculate_auc(Y, P_global)\n        delta_global = abs(auc_raw - auc_global)\n\n        # 3. Groupwise percentile AUC\n        P_group = np.zeros_like(S, dtype=float)\n        unique_groups = np.unique(G)\n        for g_id in unique_groups:\n            group_mask = (G == g_id)\n            S_g = S[group_mask]\n            N_g = len(S_g)\n            if N_g  0:\n                ranks_g = rankdata(S_g, method='average')\n                P_g_vals = (ranks_g - 0.5) / N_g\n                P_group[group_mask] = P_g_vals\n        \n        auc_group = calculate_auc(Y, P_group)\n        delta_group = auc_group - auc_raw\n        \n        return [auc_raw, auc_global, delta_global, auc_group, delta_group]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case[\"Y\"], case[\"S\"], case[\"G\"])\n        results.append(result)\n        \n    # Python's default float representation is sufficient for \"decimals\"\n    # The requirement is to format the list of lists into a string.\n    # e.g. [[a1, b1, ...], [a2, b2, ...]]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3177941"}]}