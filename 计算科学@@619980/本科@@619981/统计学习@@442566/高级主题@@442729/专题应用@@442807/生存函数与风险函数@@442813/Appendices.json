{"hands_on_practices": [{"introduction": "理解生存函数与风险函数之间的关系是生存分析的基础。本练习将超越简单的理论情况，要求您从对数逻辑斯蒂（log-logistic）模型出发，推导出其对应的风险函数。通过分析该函数的形状，您将发现风险并非总是恒定或单调递减的，从而对事件发生的可能性如何随时间演变获得更深刻的理解。[@problem_id:3186972]", "problem": "一位数据科学家在客户保留研究中对一个事件发生时间变量 $T \\geq 0$ 进行建模。该模型假设了一个对数逻辑生存函数\n$$\nS(t) = \\frac{1}{1 + \\left(\\frac{t}{\\alpha}\\right)^{\\gamma}},\n$$\n其中尺度参数为 $\\alpha > 0$，形状参数为 $\\gamma > 0$。仅从生存分析的核心定义出发，即：\n- 概率密度函数 (PDF) $f(t)$ 满足 $f(t) = -\\frac{d}{dt}S(t)$，以及\n- 风险函数 $h(t)$ 定义为 $h(t) = \\frac{f(t)}{S(t)}$，\n推导由 $S(t)$ 所蕴含的风险函数 $h(t)$。\n\n然后，分析 $h(t)$ 的行为，证明当 $\\gamma > 1$ 时，它是非单调的，并达到唯一的内部极大值。确定 $h(t)$ 达到此峰值的精确闭式时间 $t^{\\star}$，并用 $\\alpha$ 和 $\\gamma$ 表示。最后，对在这种客户保留背景下，驼峰形风险函数对风险随时间的变化意味着什么，给出一个简短且有科学依据的解释。\n\n你的最终答案必须是 $t^{\\star}$ 关于 $\\alpha$ 和 $\\gamma$ 的单一闭式解析表达式。", "solution": "该问题是有效的。这是一个适定、有科学依据的生存分析问题，它自洽且没有矛盾或歧义。它要求基于基本定义推导和分析标准的统计函数。\n\n问题始于对数逻辑分布的生存函数，由下式给出\n$$\nS(t) = \\frac{1}{1 + \\left(\\frac{t}{\\alpha}\\right)^{\\gamma}}\n$$\n其中 $t \\geq 0$ 是事件发生时间变量，$\\alpha > 0$ 是尺度参数，$\\gamma > 0$ 是形状参数。\n\n首先，我们使用其关于生存函数的定义 $f(t) = -\\frac{d}{dt}S(t)$ 来推导概率密度函数 (PDF) $f(t)$。为了便于求导，我们可以将 $S(t)$ 写成：\n$$\nS(t) = \\left[1 + \\left(\\frac{t}{\\alpha}\\right)^{\\gamma}\\right]^{-1}\n$$\n对 $t$ 应用链式法则进行求导：\n$$\n\\frac{d}{dt}S(t) = -1 \\cdot \\left[1 + \\left(\\frac{t}{\\alpha}\\right)^{\\gamma}\\right]^{-2} \\cdot \\frac{d}{dt}\\left[1 + \\left(\\frac{t}{\\alpha}\\right)^{\\gamma}\\right]\n$$\n内部部分的导数是：\n$$\n\\frac{d}{dt}\\left[1 + \\left(\\frac{t}{\\alpha}\\right)^{\\gamma}\\right] = \\frac{d}{dt}\\left(\\frac{t^{\\gamma}}{\\alpha^{\\gamma}}\\right) = \\frac{1}{\\alpha^{\\gamma}} \\cdot \\gamma t^{\\gamma-1} = \\frac{\\gamma}{\\alpha} \\left(\\frac{t}{\\alpha}\\right)^{\\gamma-1}\n$$\n将此代回，我们得到：\n$$\n\\frac{d}{dt}S(t) = -\\frac{\\frac{\\gamma}{\\alpha} \\left(\\frac{t}{\\alpha}\\right)^{\\gamma-1}}{\\left[1 + \\left(\\frac{t}{\\alpha}\\right)^{\\gamma}\\right]^2}\n$$\n因此，PDF 是：\n$$\nf(t) = -\\frac{d}{dt}S(t) = \\frac{\\frac{\\gamma}{\\alpha} \\left(\\frac{t}{\\alpha}\\right)^{\\gamma-1}}{\\left[1 + \\left(\\frac{t}{\\alpha}\\right)^{\\gamma}\\right]^2}\n$$\n接下来，我们使用其定义 $h(t) = \\frac{f(t)}{S(t)}$ 来推导风险函数 $h(t)$。\n$$\nh(t) = \\frac{\\frac{\\frac{\\gamma}{\\alpha} \\left(\\frac{t}{\\alpha}\\right)^{\\gamma-1}}{\\left[1 + \\left(\\frac{t}{\\alpha}\\right)^{\\gamma}\\right]^2}}{\\frac{1}{1 + \\left(\\frac{t}{\\alpha}\\right)^{\\gamma}}}\n$$\n消去分母中的一项，我们得到风险函数：\n$$\nh(t) = \\frac{\\frac{\\gamma}{\\alpha} \\left(\\frac{t}{\\alpha}\\right)^{\\gamma-1}}{1 + \\left(\\frac{t}{\\alpha}\\right)^{\\gamma}}\n$$\n为了分析 $h(t)$ 的行为，我们通过寻找临界点来求其极值。这可以通过求解 $\\frac{d}{dt}h(t) = 0$ 来完成。为了方便求导，我们可以将 $h(t)$ 的分子和分母同乘以 $\\alpha^{\\gamma}$ 来重写：\n$$\nh(t) = \\frac{\\gamma \\alpha^{\\gamma-1} t^{\\gamma-1}}{\\alpha^{\\gamma} + t^{\\gamma}}\n$$\n现在我们使用商法则对 $h(t)$ 关于 $t$ 求导，其中 $u(t) = \\gamma \\alpha^{\\gamma-1} t^{\\gamma-1}$ 且 $v(t) = \\alpha^{\\gamma} + t^{\\gamma}$。\n导数分别为 $u'(t) = \\gamma \\alpha^{\\gamma-1} (\\gamma-1) t^{\\gamma-2}$ 和 $v'(t) = \\gamma t^{\\gamma-1}$。\n$$\n\\frac{d}{dt}h(t) = \\frac{u'(t)v(t) - u(t)v'(t)}{[v(t)]^2} = \\frac{\\gamma \\alpha^{\\gamma-1}(\\gamma-1)t^{\\gamma-2}(\\alpha^{\\gamma} + t^{\\gamma}) - \\gamma \\alpha^{\\gamma-1}t^{\\gamma-1}(\\gamma t^{\\gamma-1})}{(\\alpha^{\\gamma} + t^{\\gamma})^2}\n$$\n我们将分子设为 $0$ 来寻找 $t > 0$ 的临界点。我们可以提出公因式 $\\gamma \\alpha^{\\gamma-1}t^{\\gamma-2}$：\n$$\n\\gamma \\alpha^{\\gamma-1}t^{\\gamma-2} \\left[ (\\gamma-1)(\\alpha^{\\gamma} + t^{\\gamma}) - \\gamma t^{\\gamma} \\right] = 0\n$$\n由于 $\\alpha > 0$、$\\gamma > 0$，并且我们正在寻找一个内部极大值 ($t > 0$)，因此括号中的项必须等于零：\n$$\n(\\gamma-1)(\\alpha^{\\gamma} + t^{\\gamma}) - \\gamma t^{\\gamma} = 0\n$$\n$$\n(\\gamma-1)\\alpha^{\\gamma} + (\\gamma-1)t^{\\gamma} - \\gamma t^{\\gamma} = 0\n$$\n$$\n(\\gamma-1)\\alpha^{\\gamma} - t^{\\gamma} = 0\n$$\n这给出了临界时间 $t^{\\star}$ 的方程：\n$$\n(t^{\\star})^{\\gamma} = (\\gamma-1)\\alpha^{\\gamma}\n$$\n要使 $t^{\\star}$ 存在实数正解，等式右侧必须为正。由于 $\\alpha > 0$，这要求 $\\gamma-1 > 0$，即 $\\gamma > 1$。这证实了只有当形状参数 $\\gamma$ 大于 $1$ 时，才会出现具有内部极值的非单调形状。如果 $0 < \\gamma \\leq 1$，风险函数是单调递减的。\n\n当 $\\gamma>1$ 时，求解 $t^{\\star}$：\n$$\nt^{\\star} = \\left( (\\gamma-1)\\alpha^{\\gamma} \\right)^{1/\\gamma} = \\alpha (\\gamma-1)^{1/\\gamma}\n$$\n为了确认这是一个极大值，我们检查导数 $\\frac{d}{dt}h(t)$ 的符号。该符号由 $(\\gamma-1)\\alpha^{\\gamma} - t^{\\gamma}$ 这一项决定。\n- 当 $0 < t < t^{\\star}$ 时，我们有 $t^{\\gamma} < (t^{\\star})^{\\gamma} = (\\gamma-1)\\alpha^{\\gamma}$。因此 $(\\gamma-1)\\alpha^{\\gamma} - t^{\\gamma} > 0$，这意味着 $\\frac{d}{dt}h(t) > 0$。函数是递增的。\n- 当 $t > t^{\\star}$ 时，我们有 $t^{\\gamma} > (t^{\\star})^{\\gamma} = (\\gamma-1)\\alpha^{\\gamma}$。因此 $(\\gamma-1)\\alpha^{\\gamma} - t^{\\gamma} < 0$，这意味着 $\\frac{d}{dt}h(t) < 0$。函数是递减的。\n这证实了当 $\\gamma > 1$ 时，$h(t)$ 在 $t = t^{\\star} = \\alpha(\\gamma-1)^{1/\\gamma}$ 处达到唯一的内部极大值。\n\n最后，在客户保留的背景下，对驼峰形风险函数的解释如下。风险函数 $h(t)$ 表示在客户一直保留到时间 $t$ 的条件下，在时间 $t$ 的客户流失瞬时率。\n- 风险函数的初始递增阶段 ($0 < t < t^{\\star}$) 标志着一个风险不断升级的时期。客户可能处于初期的评估或试用期，他们流失的可能性随着时间的推移而增加。\n- 在 $t = t^{\\star}$ 处的风险函数峰值标志着瞬时风险最高的点。一个存活了这么久的客户正处于他们最脆弱的时刻。\n- 随后的递减阶段 ($t > t^{\\star}$) 意味着，如果一个客户被保留超过这个风险峰值时间，他们对产品/服务的忠诚度或投入会增强。流失的风险随后逐渐下降，这表明一种先是正向持续时间依赖性，然后是负向持续时间依赖性的形式。这种灵活的形状使得对数逻辑模型适用于初始风险低但会增长，最终因选择或适应而下降的现象。", "answer": "$$\n\\boxed{\\alpha (\\gamma - 1)^{\\frac{1}{\\gamma}}}\n$$", "id": "3186972"}, {"introduction": "生存分析的一个核心目标是理解个体特征（即协变量）如何影响最终结果。本练习将要求您从比例风险模型（proportional hazards model）这一生存分析的基石出发，推导出中位生存时间。您还将计算其对协变量变化的敏感度，从而学习如何量化风险因素对生存时间的具体影响。[@problem_id:3186976]", "problem": "在统计学习的生存分析背景下，令 $T \\geq 0$ 表示一个非负的事件时间随机变量，令 $x \\in \\mathbb{R}$ 为一个标量协变量。生存函数为 $S(t \\mid x) = \\Pr(T > t \\mid x)$，风险函数定义为 $h(t \\mid x) = \\lim_{\\Delta t \\to 0^{+}} \\frac{\\Pr(t \\leq T < t + \\Delta t \\mid T \\geq t, x)}{\\Delta t}$。考虑一个具有威布尔基线风险的比例风险模型（Proportional Hazards (PH)），其规定为\n$$\nh(t \\mid x) = \\lambda \\, k \\, t^{k-1} \\exp(\\beta x), \\quad t \\geq 0,\n$$\n其中 $\\lambda > 0$ 和 $k > 0$ 分别是尺度参数和形状参数，而 $\\beta \\in \\mathbb{R}$ 则编码了协变量的对数线性效应。\n\n从生存和风险的核心定义出发，推导出满足 $S(t_{0.5}(x) \\mid x) = 0.5$ 的中位生存时间 $t_{0.5}(x)$，并将其表示为关于 $\\lambda$、 $k$、 $\\beta$ 和 $x$ 的闭式表达式。然后，通过推导导数 $\\frac{d}{dx} t_{0.5}(x)$ 的解析表达式来量化中位生存时间对协变量微小变化的敏感性，该导数表征了在 $x$ 的无穷小扰动下 $t_{0.5}(x)$ 的一阶变化。将两个结果均表示为闭式解析表达式。最终答案无需四舍五入，也无需报告单位。", "solution": "该问题陈述经评估具有科学依据、问题定义良好、客观且完整。它代表了生存分析领域的一个标准推导，因此是有效的。\n\n推导过程分两个阶段进行。首先，我们将从第一性原理出发，推导中位生存时间 $t_{0.5}(x)$。其次，我们将此表达式对协变量 $x$ 求导，以求得敏感性 $\\frac{d}{dx} t_{0.5}(x)$。\n\n生存函数 $S(t \\mid x)$ 和风险函数 $h(t \\mid x)$ 之间的基本关系由下式给出：\n$$\nS(t \\mid x) = \\exp\\left(-H(t \\mid x)\\right)\n$$\n其中 $H(t \\mid x)$ 是累积风险函数，定义为风险函数从 $0$ 到 $t$ 的积分：\n$$\nH(t \\mid x) = \\int_{0}^{t} h(u \\mid x) \\, du\n$$\n问题指定了一个具有威布尔基线的比例风险模型，其风险函数为：\n$$\nh(t \\mid x) = \\lambda \\, k \\, t^{k-1} \\exp(\\beta x)\n$$\n参数为 $\\lambda > 0$、 $k > 0$ 和 $\\beta \\in \\mathbb{R}$。\n\n首先，我们通过对给定的风险函数关于时间变量（在被积函数中我们用 $u$ 表示）进行积分来计算累积风险函数 $H(t \\mid x)$：\n$$\nH(t \\mid x) = \\int_{0}^{t} \\lambda \\, k \\, u^{k-1} \\exp(\\beta x) \\, du\n$$\n项 $\\lambda$ 和 $\\exp(\\beta x)$ 相对于积分变量 $u$ 是常数，可以从积分中提出：\n$$\nH(t \\mid x) = \\lambda \\exp(\\beta x) \\int_{0}^{t} k \\, u^{k-1} \\, du\n$$\n$k \\, u^{k-1}$ 的积分是 $u^k$。计算该定积分可得：\n$$\n\\int_{0}^{t} k \\, u^{k-1} \\, du = \\left[ u^k \\right]_{0}^{t} = t^k - 0^k = t^k\n$$\n因为 $k > 0$。\n将此结果代回累积风险的表达式，我们得到：\n$$\nH(t \\mid x) = \\lambda t^k \\exp(\\beta x)\n$$\n现在，我们可以写出生存函数 $S(t \\mid x)$：\n$$\nS(t \\mid x) = \\exp\\left(-\\lambda t^k \\exp(\\beta x)\\right)\n$$\n中位生存时间，记为 $t_{0.5}(x)$，是生存概率恰好为 $0.5$ 的时间 $t$。我们通过设置 $S(t \\mid x) = 0.5$ 并求解 $t = t_{0.5}(x)$ 来找到它：\n$$\nS(t_{0.5}(x) \\mid x) = \\exp\\left(-\\lambda [t_{0.5}(x)]^k \\exp(\\beta x)\\right) = 0.5\n$$\n为求解 $t_{0.5}(x)$，我们对等式两边取自然对数：\n$$\n-\\lambda [t_{0.5}(x)]^k \\exp(\\beta x) = \\ln(0.5)\n$$\n利用属性 $\\ln(0.5) = \\ln(1/2) = -\\ln(2)$，方程变为：\n$$\n-\\lambda [t_{0.5}(x)]^k \\exp(\\beta x) = -\\ln(2)\n$$\n两边乘以 $-1$ 并分离出包含 $t_{0.5}(x)$ 的项，得到：\n$$\n[t_{0.5}(x)]^k = \\frac{\\ln(2)}{\\lambda \\exp(\\beta x)} = \\frac{\\ln(2)}{\\lambda} \\exp(-\\beta x)\n$$\n为了得到 $t_{0.5}(x)$ 的最终表达式，我们对两边取 $k$ 次方根（或取 $1/k$ 次幂）：\n$$\nt_{0.5}(x) = \\left(\\frac{\\ln(2)}{\\lambda} \\exp(-\\beta x)\\right)^{1/k} = \\left(\\frac{\\ln(2)}{\\lambda}\\right)^{1/k} \\exp\\left(-\\frac{\\beta x}{k}\\right)\n$$\n这就是中位生存时间的闭式表达式。\n\n接下来，我们通过计算导数 $\\frac{d}{dx} t_{0.5}(x)$ 来量化中位生存时间对协变量 $x$ 的敏感性。为简化表达式，我们定义一个常数 $C = \\left(\\frac{\\ln(2)}{\\lambda}\\right)^{1/k}$。那么：\n$$\nt_{0.5}(x) = C \\cdot \\exp\\left(-\\frac{\\beta x}{k}\\right)\n$$\n我们使用链式法则对该表达式关于 $x$ 求导。$\\exp(ax)$ 的导数是 $a\\exp(ax)$。在这里，$-\\frac{\\beta}{k}$ 扮演了 $a$ 的角色。\n$$\n\\frac{d}{dx} t_{0.5}(x) = \\frac{d}{dx} \\left[ C \\cdot \\exp\\left(-\\frac{\\beta x}{k}\\right) \\right] = C \\cdot \\frac{d}{dx} \\left[ \\exp\\left(-\\frac{\\beta x}{k}\\right) \\right]\n$$\n$$\n\\frac{d}{dx} t_{0.5}(x) = C \\cdot \\left(-\\frac{\\beta}{k}\\right) \\exp\\left(-\\frac{\\beta x}{k}\\right)\n$$\n将 $C$ 的表达式代回此方程，得到导数的最终解析形式：\n$$\n\\frac{d}{dx} t_{0.5}(x) = \\left(\\frac{\\ln(2)}{\\lambda}\\right)^{1/k} \\left(-\\frac{\\beta}{k}\\right) \\exp\\left(-\\frac{\\beta x}{k}\\right)\n$$\n可以重新整理为：\n$$\n\\frac{d}{dx} t_{0.5}(x) = -\\frac{\\beta}{k} \\left(\\frac{\\ln(2)}{\\lambda}\\right)^{1/k} \\exp\\left(-\\frac{\\beta x}{k}\\right)\n$$\n至此，两个所求量的推导完成。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\left(\\frac{\\ln(2)}{\\lambda}\\right)^{1/k} \\exp\\left(-\\frac{\\beta x}{k}\\right)  -\\frac{\\beta}{k} \\left(\\frac{\\ln(2)}{\\lambda}\\right)^{1/k} \\exp\\left(-\\frac{\\beta x}{k}\\right) \\end{pmatrix}}\n$$", "id": "3186976"}, {"introduction": "理论模型的价值在于其能准确地反映现实。最后的这项动手实践将引导您从理论走向应用，实现一个模型校准度检查。您将编写代码，将模型的预测事件概率与观测数据进行比较，这是在真实数据科学情境中验证任何生存模型的关键技能。[@problem_id:3186997]", "problem": "给定一个包含右删失事件时间数据的队列，以及一个在指定时间分箱边界上输出预测生存函数 $\\hat S(t \\mid X)$ 的模型。目标是通过在时间分箱内，将经验事件率与从 $\\hat S(t \\mid X)$ 推导出的模型隐含的条件事件概率进行比较，来评估风险函数 $h(t \\mid X)$ 的校准度。从事件时间分析中生存函数和风险函数的核心定义出发：生存函数 $S(t) = \\mathbb{P}(T > t)$ 和风险函数 $h(t) = \\lim_{\\Delta t \\to 0} \\frac{\\mathbb{P}(t \\le T < t + \\Delta t \\mid T \\ge t)}{\\Delta t}$。仅使用这些定义和生存分析中经过充分检验的事实来推导您将要计算的算法量。\n\n使用给定的分箱边界 $\\{t_0, t_1, \\dots, t_K\\}$ 设计一个时间分箱程序，其中分箱 $k$ 对应于区间 $[t_k, t_{k+1})$。对于每个分箱：\n- 确定经验事件率，即在该分箱开始时处于风险中的个体中，于该分箱内发生事件的个体所占的比例。\n- 确定模型隐含的在该分箱内的条件事件概率，该概率是通过将在分箱边界上评估的给定 $\\hat S(t \\mid X)$ 的个体预测值进行聚合得到的。\n\n请精确实现以下规则：\n1. 对于观测时间为 $T_i$ 的个体 $i$，如果在分箱 $k$ 开始时 $T_i \\ge t_k$，则该个体处于风险中。\n2. 分箱 $k$ 中观测到的事件数是事件指示符 $\\delta_i = 1$ 且 $t_k \\le T_i < t_{k+1}$ 的个体数量。\n3. 分箱 $k$ 的经验事件率为 $d_k / n_k$，其中 $d_k$ 是该分箱中的事件计数，$n_k$ 是在该分箱开始时处于风险中的个体数。如果 $n_k = 0$，则将该分箱的经验事件率定义为 $0$。\n4. 对于分箱 $k$ 中的个体 $i$，其模型隐含的条件事件概率是根据分箱边界 $t_k$ 和 $t_{k+1}$ 处的 $\\hat S_i(t)$ 计算得出的，并通过对分箱开始时所有处于风险中的个体进行平均来聚合。在使用提供的 $\\hat S_i(t)$ 值进行计算时，将生存值裁剪到区间 $[10^{-12}, 1]$ 以避免除零错误并确保数值稳定性，然后将得到的条件概率限制在区间 $[0, 1]$ 内。\n5. 通过均方根误差 (RMSE) 来量化校准度，其定义为所有分箱的经验事件率与预测的条件事件概率之间差值的平方的平均值的平方根。如果某个分箱的 $n_k = 0$，则使用上述定义的值将该分箱包含在内。\n\n您的程序必须为以下每个测试用例实现此过程，并输出每个用例的 RMSE。不需要物理单位；概率是无量纲的。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[$r_1, r_2, r_3$]”），其中每个 $r_j$ 是对应于测试用例 $j$ 的 RMSE 的浮点数。\n\n测试套件：\n- 测试用例 1 (一般情况)：\n  - 分箱边界: $[0.0, 2.0, 4.0, 6.0]$。\n  - 观测时间: $T = [1.0, 3.2, 5.5, 2.1, 4.5, 6.0]$。\n  - 事件指示符: $\\delta = [1, 1, 1, 0, 1, 0]$。\n  - 在分箱边界处的预测生存矩阵 $\\hat S$（行代表个体，列代表边界）：\n    - 个体 1: $[1.0, 0.201896, 0.040762, 0.008230]$。\n    - 个体 2: $[1.0, 0.548812, 0.301194, 0.165299]$。\n    - 个体 3: $[1.0, 0.818731, 0.670320, 0.548812]$。\n    - 个体 4: $[1.0, 0.367879, 0.135335, 0.049787]$。\n    - 个体 5: $[1.0, 0.670320, 0.449329, 0.301194]$。\n    - 个体 6: $[1.0, 0.904837, 0.818731, 0.740818]$。\n- 测试用例 2 (单个分箱和混合结果)：\n  - 分箱边界: $[0.0, 1.0]$。\n  - 观测时间: $T = [0.3, 0.7, 1.2, 0.9]$。\n  - 事件指示符: $\\delta = [1, 0, 1, 1]$。\n  - 预测生存矩阵 $\\hat S$:\n    - 个体 1: $[1.0, 0.7]$。\n    - 个体 2: $[1.0, 0.9]$。\n    - 个体 3: $[1.0, 0.6]$。\n    - 个体 4: $[1.0, 0.8]$。\n- 测试用例 3 (跨分箱构建的完美校准)：\n  - 分箱边界: $[0.0, 1.0, 2.0]$。\n  - 观测时间: $T = [0.5, 1.5, 1.7, 3.0, 3.0]$。\n  - 事件指示符: $\\delta = [1, 1, 0, 0, 0]$。\n  - 预测生存矩阵 $\\hat S$:\n    - 个体 1: $[1.0, 0.8, 0.6]$。\n    - 个体 2: $[1.0, 0.8, 0.6]$。\n    - 个体 3: $[1.0, 0.8, 0.6]$。\n    - 个体 4: $[1.0, 0.8, 0.6]$。\n    - 个体 5: $[1.0, 0.8, 0.6]$。\n- 测试用例 4 (无观测事件，但预测风险非零)：\n  - 分箱边界: $[0.0, 2.0, 4.0]$。\n  - 观测时间: $T = [1.0, 3.0, 3.5]$。\n  - 事件指示符: $\\delta = [0, 0, 0]$。\n  - 预测生存矩阵 $\\hat S$:\n    - 个体 1: $[1.0, 0.548812, 0.301194]$。\n    - 个体 2: $[1.0, 0.548812, 0.301194]$。\n    - 个体 3: $[1.0, 0.548812, 0.301194]$。\n\n您的程序必须为每个测试用例计算如上定义的均方根误差，并以指定的单行格式返回结果。不应读取任何输入；所有数据必须按此处给定的方式硬编码。", "solution": "在统计学习和生物统计学中，通过对时间进行分箱来评估生存模型风险函数的校准度是一项定义明确且具有科学依据的任务。问题陈述提供了构建一个严谨、可验证的算法所需的所有必要数据和定义。\n\n问题的核心在于在离散时间区间内，将经验事件率与模型预测的事件概率进行比较。我们首先从提供的基本定义出发，对所涉及的量进行形式化。\n\n生存函数 $S(t)$ 是指在时间 $t$ 之前目标事件未发生的概率，定义为 $S(t) = \\mathbb{P}(T > t)$，其中 $T$ 是事件时间随机变量。风险函数 $h(t)$ 表示在给定存活至时间 $t$ 的条件下，在时间 $t$ 事件发生的瞬时速率：\n$$h(t) = \\lim_{\\Delta t \\to 0} \\frac{\\mathbb{P}(t \\le T < t + \\Delta t \\mid T \\ge t)}{\\Delta t}$$\n\n该问题要求对一组预定义的时间分箱进行离散时间分析。设分箱边界为 $\\{t_0, t_1, \\dots, t_K\\}$，定义了 $K$ 个分箱，其中分箱 $k$ 是区间 $[t_k, t_{k+1})$，对于 $k \\in \\{0, 1, \\dots, K-1\\}$。\n\n对于每个分箱 $k$，我们必须计算两个量：经验事件率和模型隐含的条件事件概率。\n\n首先，我们推导在给定个体在分箱开始时未发生事件的情况下，个体 $i$ 在分箱 $k$ 内的模型隐含的条件事件概率。该概率为 $p_{i,k} = \\mathbb{P}(t_k \\le T_i < t_{k+1} \\mid T_i \\ge t_k)$。使用条件概率的定义：\n$$p_{i,k} = \\frac{\\mathbb{P}(\\{t_k \\le T_i < t_{k+1}\\} \\cap \\{T_i \\ge t_k\\})}{\\mathbb{P}(T_i \\ge t_k)}$$\n分子中的事件 $\\{t_k \\le T_i < t_{k+1}\\} \\cap \\{T_i \\ge t_k\\}$ 即为 $\\{t_k \\le T_i < t_{k+1}\\}$。这个区间事件的概率可以用生存函数来表示。假设事件时间变量是连续的，则 $\\mathbb{P}(t_k \\le T_i < t_{k+1}) = S_i(t_k) - S_i(t_{k+1})$。分母中的概率是 $\\mathbb{P}(T_i \\ge t_k)$，对于连续变量，这也等于 $S_i(t_k)$。因此，个体的条件事件概率为：\n$$p_{i,k} = \\frac{S_i(t_k) - S_i(t_{k+1})}{S_i(t_k)} = 1 - \\frac{S_i(t_{k+1})}{S_i(t_k)}$$\n此推导提供了使用模型的预测生存函数 $\\hat{S}_i(t)$ 来计算个体 $i$ 的模型隐含概率的公式。\n\n计算校准的均方根误差 (RMSE) 的算法过程如下：\n\n对于每个测试用例，给定分箱边界 $\\{t_k\\}_{k=0}^K$、观测时间 $\\{T_i\\}_{i=1}^N$、事件指示符 $\\{\\delta_i\\}_{i=1}^N$ 和预测生存函数 $\\{\\hat{S}_i(t)\\}_{i=1}^N$：\n\n1.  初始化一个空列表，用于存储每个分箱的平方误差。\n2.  从 $0$ 到 $K-1$ 遍历每个分箱 $k$，对应于区间 $[t_k, t_{k+1})$。\n\n    a.  **确定风险集**：识别在分箱 $k$ 开始时处于风险中的个体集合 $R_k$。根据问题描述，如果个体的观测时间 $T_i$ 大于或等于分箱的起始时间，即 $R_k = \\{i \\mid T_i \\ge t_k\\}$，则个体 $i$ 处于风险中。处于风险中的个体数量为 $n_k = |R_k|$。\n\n    b.  **计算经验事件率 ($E_k$)**：\n        i.  计算分箱内的观测事件数 $d_k$。这些是在时间区间 $[t_k, t_{k+1})$ 内发生事件的个体。形式上，$d_k = \\sum_{i=1}^N \\mathbb{I}(t_k \\le T_i < t_{k+1} \\text{ and } \\delta_i = 1)$，其中 $\\mathbb{I}(\\cdot)$ 是指示函数。\n        ii. 分箱 $k$ 的经验事件率为 $E_k = d_k/n_k$。如果 $n_k = 0$，问题规定 $E_k = 0$。\n\n    c.  **计算平均预测概率 ($P_k$)**：\n        i.  如果 $n_k = 0$，则平均预测概率未定义。我们采用的约定是，该分箱对总误差的贡献为 $0$，实际上就是设置 $P_k=0$ 以匹配 $E_k=0$。\n        ii. 如果 $n_k > 0$，我们首先为风险集 $R_k$ 中的每个个体 $i$ 计算其个体预测的条件事件概率 $p_{i,k}$。\n            - 从提供的数据中获取预测的生存概率 $\\hat{S}_i(t_k)$ 和 $\\hat{S}_i(t_{k+1})$。\n            - 为保证数值稳定性，将这些值裁剪到范围 $[10^{-12}, 1]$ 内，我们称之为 $\\hat{S}'_i(t_k)$ 和 $\\hat{S}'_i(t_{k+1})$。\n            - 计算原始概率：$p_{i,k}^{\\text{raw}} = 1 - \\frac{\\hat{S}'_i(t_{k+1})}{\\hat{S}'_i(t_k)}$。\n            - 将此值约束在区间 $[0, 1]$ 内，以获得最终的个体预测值 $p_{i,k}$。\n        iii. 该分箱的平均预测概率 $P_k$ 是这些个体概率在风险集上的均值：$P_k = \\frac{1}{n_k} \\sum_{i \\in R_k} p_{i,k}$。\n\n    d.  **存储平方误差**：计算平方差 $(E_k - P_k)^2$ 并将其添加到平方误差列表中。\n\n3.  **计算最终 RMSE**：在遍历所有 $K$ 个分箱后，计算所存储的平方误差的均值。RMSE 是该均值的平方根：\n    $$\\text{RMSE} = \\sqrt{\\frac{1}{K} \\sum_{k=0}^{K-1} (E_k - P_k)^2}$$\n\n将此过程应用于每个测试用例，以计算所需的 RMSE 值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating the calibration RMSE for each test case.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"bin_edges\": [0.0, 2.0, 4.0, 6.0],\n            \"T\": [1.0, 3.2, 5.5, 2.1, 4.5, 6.0],\n            \"delta\": [1, 1, 1, 0, 1, 0],\n            \"S_hat\": [\n                [1.0, 0.201896, 0.040762, 0.008230],\n                [1.0, 0.548812, 0.301194, 0.165299],\n                [1.0, 0.818731, 0.670320, 0.548812],\n                [1.0, 0.367879, 0.135335, 0.049787],\n                [1.0, 0.670320, 0.449329, 0.301194],\n                [1.0, 0.904837, 0.818731, 0.740818],\n            ],\n        },\n        {\n            \"bin_edges\": [0.0, 1.0],\n            \"T\": [0.3, 0.7, 1.2, 0.9],\n            \"delta\": [1, 0, 1, 1],\n            \"S_hat\": [\n                [1.0, 0.7],\n                [1.0, 0.9],\n                [1.0, 0.6],\n                [1.0, 0.8],\n            ],\n        },\n        {\n            \"bin_edges\": [0.0, 1.0, 2.0],\n            \"T\": [0.5, 1.5, 1.7, 3.0, 3.0],\n            \"delta\": [1, 1, 0, 0, 0],\n            \"S_hat\": [\n                [1.0, 0.8, 0.6],\n                [1.0, 0.8, 0.6],\n                [1.0, 0.8, 0.6],\n                [1.0, 0.8, 0.6],\n                [1.0, 0.8, 0.6],\n            ],\n        },\n        {\n            \"bin_edges\": [0.0, 2.0, 4.0],\n            \"T\": [1.0, 3.0, 3.5],\n            \"delta\": [0, 0, 0],\n            \"S_hat\": [\n                [1.0, 0.548812, 0.301194],\n                [1.0, 0.548812, 0.301194],\n                [1.0, 0.548812, 0.301194],\n            ],\n        },\n    ]\n\n    def calculate_rmse(bin_edges, T, delta, S_hat):\n        \"\"\"\n        Calculates the calibration RMSE for a single test case.\n        \"\"\"\n        T = np.array(T)\n        delta = np.array(delta)\n        S_hat = np.array(S_hat)\n        \n        num_individuals = len(T)\n        num_bins = len(bin_edges) - 1\n        squared_errors = []\n\n        for k in range(num_bins):\n            t_k = bin_edges[k]\n            t_k_plus_1 = bin_edges[k+1]\n\n            # 1. Determine the risk set\n            at_risk_indices = np.where(T >= t_k)[0]\n            n_k = len(at_risk_indices)\n\n            # Handle case where no one is at risk\n            if n_k == 0:\n                empirical_rate = 0.0\n                predicted_prob = 0.0\n                squared_errors.append((empirical_rate - predicted_prob)**2)\n                continue\n\n            # 2. Calculate empirical event rate\n            event_indices = np.where((T >= t_k) & (T < t_k_plus_1) & (delta == 1))[0]\n            d_k = len(event_indices)\n            empirical_rate = d_k / n_k\n\n            # 3. Calculate model-implied conditional event probability\n            individual_probs = []\n            for i in at_risk_indices:\n                s_hat_tk = S_hat[i, k]\n                s_hat_tk_plus_1 = S_hat[i, k+1]\n\n                # Clip survival values for numerical stability\n                s_hat_tk_clipped = np.clip(s_hat_tk, 1e-12, 1.0)\n                s_hat_tk_plus_1_clipped = np.clip(s_hat_tk_plus_1, 1e-12, 1.0)\n\n                # Calculate individual probability\n                prob_raw = 1.0 - (s_hat_tk_plus_1_clipped / s_hat_tk_clipped)\n                \n                # Constrain probability to [0, 1]\n                prob = np.clip(prob_raw, 0.0, 1.0)\n                individual_probs.append(prob)\n            \n            predicted_prob = np.mean(individual_probs)\n\n            # 4. Quantify calibration error for the bin\n            squared_errors.append((empirical_rate - predicted_prob)**2)\n\n        # 5. Compute final RMSE\n        if not squared_errors:\n            return 0.0\n            \n        mean_squared_error = np.mean(squared_errors)\n        rmse = np.sqrt(mean_squared_error)\n        \n        return rmse\n\n    results = []\n    for case in test_cases:\n        rmse = calculate_rmse(case[\"bin_edges\"], case[\"T\"], case[\"delta\"], case[\"S_hat\"])\n        results.append(rmse)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\nsolve()\n```", "id": "3186997"}]}