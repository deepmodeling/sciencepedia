{"hands_on_practices": [{"introduction": "第一个实践将指导你手动计算对数秩统计量，这是比较生存曲线的基石。通过逐步处理数据，你将具体理解该检验如何利用每个时间点的事件和删失观测信息。本练习还通过将对数秩检验与不恰当的 Wilcoxon 秩和检验进行对比，突显了一个关键概念：忽略删失数据而草率应用分析方法的危险性。", "problem": "在一项临床试验中，研究人员比较了一种新的治疗药物（A组）与一种标准疗法（B组）对患者生存时间的影响。共有16名患者入组，并被随机分配到两个组中的一个，每组8名患者。主要终点是直到特定事件发生的时间（单位：月）。一些患者在观察期结束前失访或未经历该事件；这些被记录为删失观测值。\n\n两组的观测时间如下，其中`+`符号表示删失观测值：\n- **A组（新药组）：** 21, 26, 31, 35+, 35+, 35+, 35+, 35+\n- **B组（标准治疗组）：** 5, 10, 15, 18, 22, 27, 32, 38\n\n一位数据分析师提出了两种不同的方法来检验两组生存分布没有差异的原假设。\n1. 对数秩检验，这是分析此类带删失的时间-事件数据的标准方法。\n2. 一种“朴素的”Wilcoxon秩和检验（也称为Mann-Whitney U检验），*仅*应用于经历了事件的患者子集（即非删失观测值）。\n\n您的任务是计算每种方法的检验统计量。设 $Z$ 为对数秩检验的检验统计量，计算公式为 $Z = (\\sum(O_A - E_A)) / \\sqrt{\\sum V}$，其中 $O_A$ 是A组的观测事件数，$E_A$ 是期望事件数，$V$ 是方差。设 $U$ 为Wilcoxon秩和检验的检验统计量，定义为为每个组计算的两个可能的 $U$ 统计量中的较小者。\n\n计算数值对 $(Z, U)$。对于最终答案，将 $Z$ 四舍五入到三位有效数字，并将 $U$ 表示为精确整数。", "solution": "该问题要求根据所提供的A、B两组生存数据计算两个统计检验值。\n\n**第一部分：朴素的Wilcoxon秩和检验（Mann-Whitney U检验）**\n\n此检验仅对经历了事件的受试者进行。我们首先提取每组的事件时间。\n- A组事件时间：{21, 26, 31}。经历事件的受试者样本量为 $n_A = 3$。\n- B组事件时间：{5, 10, 15, 18, 22, 27, 32, 38}。经历事件的受试者样本量为 $n_B = 8$。\n\n接下来，我们将所有事件时间合并，并从最小到最大进行排序。在这种朴素分析中，总观测数为 $N = n_A + n_B = 3 + 8 = 11$。\n\n| 时间 | 组别 | 秩次 |\n|------|-------|------|\n| 5    | B     | 1    |\n| 10   | B     | 2    |\n| 15   | B     | 3    |\n| 18   | B     | 4    |\n| 21   | A     | 5    |\n| 22   | B     | 6    |\n| 26   | A     | 7    |\n| 27   | B     | 8    |\n| 31   | A     | 9    |\n| 32   | B     | 10   |\n| 38   | B     | 11   |\n\n现在，我们计算每组的秩和。\n- A组的秩和 ($R_A$)：$5 + 7 + 9 = 21$。\n- B组的秩和 ($R_B$)：$1 + 2 + 3 + 4 + 6 + 8 + 10 + 11 = 45$。\n作为检验，总秩和应为 $\\frac{N(N+1)}{2} = \\frac{11(12)}{2} = 66$。确实，$R_A + R_B = 21 + 45 = 66$。\n\n每组的Mann-Whitney U统计量计算如下：\n$U_A = R_A - \\frac{n_A(n_A+1)}{2} = 21 - \\frac{3(3+1)}{2} = 21 - 6 = 15$。\n$U_B = R_B - \\frac{n_B(n_B+1)}{2} = 45 - \\frac{8(8+1)}{2} = 45 - 36 = 9$。\n作为检验，$U_A + U_B = 15 + 9 = 24$，这应等于 $n_A n_B = 3 \\times 8 = 24$。计算正确。\n\n检验统计量 $U$ 是 $U_A$ 和 $U_B$ 中的较小者。\n$U = \\min(15, 9) = 9$。\n\n**第二部分：对数秩检验**\n\n此检验使用所有数据（包括删失观测值）来比较生存分布。原假设是两组的生存函数相同。我们在每个不同的事件时间点计算观测事件数 ($O_A$)、期望事件数 ($E_A$) 和方差 ($V$)。\n\n数据如下：\n- A组：{21, 26, 31, 35+, 35+, 35+, 35+, 35+} ($N_A=8$)\n- B组：{5, 10, 15, 18, 22, 27, 32, 38} ($N_B=8$)\n不同的事件时间点为：5, 10, 15, 18, 21, 22, 26, 27, 31, 32, 38。\n\n我们构建一个表格来记录每个事件时间 $t_j$ 的计算过程。\n- $n_{Aj}$：在 $t_j$ 时刻之前A组中处于风险中的受试者数量。\n- $n_{Bj}$：在 $t_j$ 时刻之前B组中处于风险中的受试者数量。\n- $N_j = n_{Aj} + n_{Bj}$：处于风险中的总人数。\n- $d_j$：在 $t_j$ 时刻发生的事件总数。对于此数据集，所有事件时间的 $d_j=1$。\n- $d_{Aj}$：在 $t_j$ 时刻A组发生的事件数。\n- $O_{Aj} = d_{Aj}$：A组的观测事件数。\n- $E_{Aj} = d_j \\frac{n_{Aj}}{N_j}$：在 $H_0$ 下A组的期望事件数。\n- $V_j = \\frac{n_{Aj} n_{Bj} d_j (N_j - d_j)}{N_j^2 (N_j-1)}$：在 $H_0$ 下 $O_{Aj}$ 的方差。\n\n| $t_j$ | $n_{Aj}$ | $n_{Bj}$ | $N_j$ | $d_j$ | $d_{Aj}$ | $O_{Aj}-E_{Aj}$ | $V_j$ |\n|-------|----------|----------|-------|-------|----------|-----------------------|-----------------------|\n| 5     | 8        | 8        | 16    | 1     | 0        | $0 - 8/16 = -0.5000$  | $\\frac{8 \\cdot 8 \\cdot 1 \\cdot 15}{16^2 \\cdot 15} = 0.2500$ |\n| 10    | 8        | 7        | 15    | 1     | 0        | $0 - 8/15 \\approx -0.5333$ | $\\frac{8 \\cdot 7 \\cdot 1 \\cdot 14}{15^2 \\cdot 14} \\approx 0.2489$ |\n| 15    | 8        | 6        | 14    | 1     | 0        | $0 - 8/14 \\approx -0.5714$ | $\\frac{8 \\cdot 6 \\cdot 1 \\cdot 13}{14^2 \\cdot 13} \\approx 0.2449$ |\n| 18    | 8        | 5        | 13    | 1     | 0        | $0 - 8/13 \\approx -0.6154$ | $\\frac{8 \\cdot 5 \\cdot 1 \\cdot 12}{13^2 \\cdot 12} \\approx 0.2367$ |\n| 21    | 8        | 4        | 12    | 1     | 1        | $1 - 8/12 \\approx 0.3333$  | $\\frac{8 \\cdot 4 \\cdot 1 \\cdot 11}{12^2 \\cdot 11} \\approx 0.2222$ |\n| 22    | 7        | 4        | 11    | 1     | 0        | $0 - 7/11 \\approx -0.6364$ | $\\frac{7 \\cdot 4 \\cdot 1 \\cdot 10}{11^2 \\cdot 10} \\approx 0.2314$ |\n| 26    | 7        | 3        | 10    | 1     | 1        | $1 - 7/10 = 0.3000$   | $\\frac{7 \\cdot 3 \\cdot 1 \\cdot 9}{10^2 \\cdot 9} = 0.2100$ |\n| 27    | 6        | 3        | 9     | 1     | 0        | $0 - 6/9 \\approx -0.6667$ | $\\frac{6 \\cdot 3 \\cdot 1 \\cdot 8}{9^2 \\cdot 8} \\approx 0.2222$ |\n| 31    | 6        | 2        | 8     | 1     | 1        | $1 - 6/8 = 0.2500$    | $\\frac{6 \\cdot 2 \\cdot 1 \\cdot 7}{8^2 \\cdot 7} = 0.1875$ |\n| 32    | 5        | 2        | 7     | 1     | 0        | $0 - 5/7 \\approx -0.7143$ | $\\frac{5 \\cdot 2 \\cdot 1 \\cdot 6}{7^2 \\cdot 6} \\approx 0.2041$ |\n| 38    | 0        | 1        | 1     | 1     | 0        | $0 - 0/1 = 0$         | $0$ (since $N_j-1=0$) |\n注意：在 $t=35$ 时，A组的5名受试者被删失，因此对于在 $t=38$ 发生的事件，$n_{Aj}=0$。\n\n现在我们对 $O_{Aj}-E_{Aj}$ 和 $V_j$ 列求和。\n$\\sum(O_{Aj}-E_{Aj}) \\approx -0.5000 - 0.5333 - 0.5714 - 0.6154 + 0.3333 - 0.6364 + 0.3000 - 0.6667 + 0.2500 - 0.7143 + 0 = -3.3542$\n\n$\\sum V_j \\approx 0.2500 + 0.2489 + 0.2449 + 0.2367 + 0.2222 + 0.2314 + 0.2100 + 0.2222 + 0.1875 + 0.2041 + 0 = 2.2579$\n\n对数秩检验统计量 $Z$ 为：\n$Z = \\frac{\\sum(O_{Aj}-E_{Aj})}{\\sqrt{\\sum V_j}} = \\frac{-3.3542}{\\sqrt{2.2579}} \\approx \\frac{-3.3542}{1.50263} \\approx -2.2322$\n\n四舍五入到三位有效数字，$Z = -2.23$。\n\n数值对 $(Z, U)$ 是 $(-2.23, 9)$。", "answer": "$$\\boxed{\\begin{pmatrix} -2.23  9 \\end{pmatrix}}$$", "id": "1962146"}, {"introduction": "虽然大样本检验依赖于卡方分布等渐近近似，但更深刻的理解源于精确置换检验。本练习将展示如何为一个小型数据集从第一性原理构建对数秩统计量的零分布。通过枚举所有可能的分组情况，你将计算出一个精确的 $p$ 值，这不仅揭示了该检验的组合学基础，也为小样本情况下的统计推断提供了黄金标准。", "problem": "在一项小型临床试验中，一种新疗法（A组）正与对照组（B组）进行比较。共有六名受试者参与了这项研究，其中三名被随机分配到A组，三名被分配到B组。该研究对受试者进行随访，记录发生特定不良事件的时间，或者如果他们在未发生事件的情况下离开研究，则记录他们最后一次随访的时间（删失）。\n\n所有六名受试者的合并数据如下，其中时间以月为单位，状态为“事件”或“删失”：\n- 受试者 1：(3, 事件)\n- 受试者 2：(5, 事件)\n- 受试者 3：(6, 删失)\n- 受试者 4：(8, 事件)\n- 受试者 5：(10, 删失)\n- 受试者 6：(12, 事件)\n\n观察到的受试者分组情况如下：\n- A组（治疗组）：结果为 (5, 事件)、(6, 删失) 和 (12, 事件) 的受试者。\n- B组（对照组）：结果为 (3, 事件)、(8, 事件) 和 (10, 删失) 的受试者。\n\n为了检验两组之间事件时间分布没有差异的原假设，您将执行一个精确对数秩检验。这涉及到为每一种可能的受试者分组方式计算对数秩统计量的分子 $U = \\sum_{j} (O_j - E_j)$。\n\n通过构建统计量 $U$ 的精确置换分布，计算观察数据的双侧p值。将您的最终答案四舍五入到四位有效数字。", "solution": "我们按时间顺序排列六名受试者：$t_{1}=3$ (事件)，$t_{2}=5$ (事件)，$t_{3}=6$ (删失)，$t_{4}=8$ (事件)，$t_{5}=10$ (删失)，$t_{6}=12$ (事件)。在每个事件时间 $j$，对数秩的分子是 $O_{j}-E_{j}$，其中 $O_{j}$ 是A组的事件数，而 $E_{j}=d_{j}\\,n_{Aj}/n_{j}$，其中 $d_{j}$ 是在时间 $j$ 发生的事件数，$n_{j}$ 是在时间 $j$ 之前处于风险中的人数，$n_{Aj}$ 是在时间 $j$ 之前A组中处于风险中的人数。在时间 $t_{1},t_{2},t_{4},t_{6}$，有 $d_{j}=1$；在时间 $t_{3},t_{5}$ 发生的删失贡献为零。\n\n设 $a_{i}\\in\\{0,1\\}$ 表示受试者 $i$ 是否在A组，且 $\\sum_{i=1}^{6}a_{i}=3$。那么：\n- 在 $t_{1}=3$ 时：$n_{1}=6$，$n_{A1}=3$，$E_{1}=1\\cdot(3/6)=\\frac{1}{2}$，$O_{1}=a_{1}$，所以贡献为 $a_{1}-\\frac{1}{2}$。\n- 在 $t_{2}=5$ 时：$n_{2}=5$，$n_{A2}=3-a_{1}$，$E_{2}=\\frac{3-a_{1}}{5}$，$O_{2}=a_{2}$，所以贡献为 $a_{2}-\\frac{3-a_{1}}{5}$。\n- 在 $t_{3}=6$ 时 (删失)：无贡献。\n- 在 $t_{4}=8$ 时：$n_{3}=3$，$n_{A3}=3-a_{1}-a_{2}-a_{3}$，$E_{3}=\\frac{3-a_{1}-a_{2}-a_{3}}{3}$，$O_{3}=a_{4}$，所以贡献为 $a_{4}-\\frac{3-a_{1}-a_{2}-a_{3}}{3}$。\n- 在 $t_{5}=10$ 时 (删失)：无贡献。\n- 在 $t_{6}=12$ 时：$n_{4}=1$，$E_{4}=a_{6}$，$O_{4}=a_{6}$，所以贡献为 $0$。\n\n因此，\n$$\nU=(a_{1}-\\tfrac{1}{2})+\\Bigl(a_{2}-\\tfrac{3-a_{1}}{5}\\Bigr)+\\Bigl(a_{4}-\\tfrac{3-a_{1}-a_{2}-a_{3}}{3}\\Bigr),\n$$\n化简为\n$$\nU=\\tfrac{23}{15}a_{1}+\\tfrac{4}{3}a_{2}+\\tfrac{1}{3}a_{3}+a_{4}-\\tfrac{21}{10}.\n$$\n\n观察到的分配是A组：$(5,\\text{事件})$、$(6,\\text{删失})$、$(12,\\text{事件})$，即 $(a_{1},a_{2},a_{3},a_{4},a_{5},a_{6})=(0,1,1,0,0,1)$。因此\n$$\nU_{\\text{obs}}=\\tfrac{4}{3}\\cdot 1+\\tfrac{1}{3}\\cdot 1-\\tfrac{21}{10}=\\tfrac{5}{3}-\\tfrac{21}{10}=-\\tfrac{13}{30}.\n$$\n\n为了构建精确置换分布，我们枚举所有 $\\binom{6}{3}=20$ 种分配方式。我们根据A组包含来自 {受试者1, 2, 3, 4} 的人数来计算所有可能的 $U$ 值及其频率。\n-   **选择3名来自 {1,2,3,4}** ($\\binom{4}{3}=4$ 种方式, 每种频率为1):\n    -   $U(\\{1,2,3\\}) = 33/30$, $U(\\{1,2,4\\}) = 53/30$, $U(\\{1,3,4\\}) = 23/30$, $U(\\{2,3,4\\}) = 17/30$\n-   **选择2名来自 {1,2,3,4}** ($\\binom{4}{2}=6$ 种方式, 每种频率为2):\n    -   $U(\\{1,2\\}) = 23/30$, $U(\\{1,3\\}) = -7/30$, $U(\\{1,4\\}) = 13/30$, $U(\\{2,3\\}) = -13/30$, $U(\\{2,4\\}) = 7/30$, $U(\\{3,4\\}) = -23/30$\n-   **选择1名来自 {1,2,3,4}** ($\\binom{4}{1}=4$ 种方式, 每种频率为1):\n    -   $U(\\{1\\}) = -17/30$, $U(\\{2\\}) = -23/30$, $U(\\{3\\}) = -53/30$, $U(\\{4\\}) = -33/30$\n\n汇总后，$U$ 的完整多重集及其计数为：$\\tfrac{53}{30}(1)$, $\\tfrac{33}{30}(1)$, $\\tfrac{23}{30}(3)$, $\\tfrac{17}{30}(1)$, $\\tfrac{13}{30}(2)$, $\\tfrac{7}{30}(2)$, $-\\tfrac{7}{30}(2)$, $-\\tfrac{13}{30}(2)$, $-\\tfrac{17}{30}(1)$, $-\\tfrac{23}{30}(3)$, $-\\tfrac{33}{30}(1)$, $-\\tfrac{53}{30}(1)$。\n\n由于观测统计量的绝对值为 $|U_{\\text{obs}}|=13/30$，双侧p值是满足 $|U| \\ge 13/30$ 的排列所占的比例。在20个排列中，满足 $|U|  13/30$ 的值仅有 $\\pm 7/30$（总计数为4）。因此，有 $20-4=16$ 个排列的统计量值至少与观测值同样极端。p值计算如下：\n$$p=\\frac{16}{20}=0.8$$\n四舍五入到四位有效数字，p值为 $0.8000$。", "answer": "$$\\boxed{0.8000}$$", "id": "1962134"}, {"introduction": "真实世界的数据常常包含协变量，这些变量可能影响结果并混淆处理组之间的比较。分层对数秩检验是解决此问题的有力工具，它在同质亚组（即“层”）内比较生存曲线。这个高级实践旨在让你实现这一过程，教你如何控制混淆变量并正确地汇总结果，以获得一个经过调整的、更准确的总体处理效应评估。", "problem": "给定包含右删失的双处理组生存数据，以及一个被怀疑以非线性方式影响风险的连续协变量 $Z$。您的任务是实现对这两个处理组进行分层对数秩比较，其中分层通过对 $Z$ 进行非线性变换来形成，然后评估在各个层内是否仍然存在残余的处理差异。\n\n基本原理和假设：\n- 设生存函数为 $S(t)$，风险函数为 $h(t)$。对于每个分层，设在时间 $t$ 之前刻的风险集为 $R(t)$，其中有 $n(t)$ 个个体处于风险中，而在标记为 $1$ 的处理组中有 $n_{1}(t)$ 个个体处于风险中。\n- 在每个分层内两个处理组风险相等的原假设下，在任何一个不同的事件时间 $t$（以 $R(t)$ 和当时的总事件数 $d(t)$ 为条件），归因于处理组 $1$ 的事件数量遵循无放回超几何分布。因此，在每个事件时间，处理组 $1$ 的预期事件数与 $n_{1}(t)$ 成正比，其变异性反映了无放回抽样（有限总体校正）。必须使用这种无放回机制来处理事件时间的结（tied event times）。\n\n需要计算的内容：\n- 非线性分层：对于每个测试用例，通过 $f(Z) = Z^{2}$ 变换协变量，并根据该测试用例内 $f(Z)$ 的样本中位数将数据精确地分为两个分层。$f(Z)$ 小于或等于中位数的个体属于下层，而 $f(Z)$ 严格大于中位数的个体属于上层。\n- 在每个分层内，通过在该分层中对不同的事件时间 $t$ 进行汇总来构建一个对数秩类型的得分：将时间 $t$ 时处理组 $1$ 中观察到的事件计数与其在原假设下的条件期望（基于超几何分布）进行比较，并汇总相应的条件方差，这些方差包含了针对结的无放回有限样本校正。将所得的分层水平贡献定义为观察值减去期望值的总和，及其方差。\n- 通过将两个分层的（观察值-期望值）贡献及其方差相加，形成总体的分层统计量，然后构建一个单一的二次型，该二次型在原假设下渐近服从自由度为1的卡方分布。同时，为每个单独的分层计算其自身的自由度为1的二次型和p值。\n- 显著性水平：使用 $\\alpha = 0.05$。\n- 层内残差评估：生成一个布尔值，当且仅当至少有一个分层的层内p值严格小于 $\\alpha$ 时，该值为真。\n\n需要遵守的实现细节：\n- 右删失：在事件时间 $t$，风险集必须包括所有观测时间大于或等于 $t$ 的个体。如果一个个体在时间 $t$ 被删失，他们被计入时间 $t$ 的风险集，但在 $t$ 时不贡献任何事件。\n- 在事件时间 $t$ 的结必须使用无放回超几何模型来处理事件在不同处理组间的分布，并在方差中进行相应的有限总体校正。\n- 如果一个分层不包含任何信息（例如，没有事件或退化的风险集导致方差为零），其方差贡献被视为零。在这种分层中，层内统计量定义为零，p值定义为一。\n\n测试套件：\n实现您的程序，为以下三个测试用例计算所需的输出。每个用例都包含观测时间、事件指示符、处理组标签和协变量 $Z$ 的数组。所有数字都没有单位。\n\n- 测试用例 $1$（理想情况；两个分层都有明显差异）：\n  - times $=$ $[2,3,4,5,\\,6,7,8,9,\\,1,2,3,4,\\,8,9,10,11]$\n  - events $=$ $[1,1,1,0,\\,1,1,1,1,\\,1,1,1,1,\\,1,1,1,1]$\n  - groups $=$ $[0,0,0,0,\\,1,1,1,1,\\,0,0,0,0,\\,1,1,1,1]$\n  - $Z$ $=$ $[1,-1,1,-1,\\,1,-1,1,-1,\\,2,-2,2,-2,\\,2,-2,2,-2]$\n\n- 测试用例 $2$（边界行为；一个分层没有事件）：\n  - times $=$ $[5,6,7,8,\\,3,6,4,5]$\n  - events $=$ $[0,0,0,0,\\,1,1,1,1]$\n  - groups $=$ $[0,1,0,1,\\,0,0,1,1]$\n  - $Z$ $=$ $[1,-1,-1,1,\\,2,2,-2,-2]$\n\n- 测试用例 $3$（边缘情况，事件时间有多个结）：\n  - times $=$ $[5,5,5,9,\\,7,7,9,9]$\n  - events $=$ $[1,1,1,0,\\,1,1,0,0]$\n  - groups $=$ $[0,1,0,1,\\,0,1,0,1]$\n  - $Z$ $=$ $[1,-1,1,-1,\\,2,-2,2,-2]$\n\n每个测试用例的所需输出：\n- 设 $S$ 为总体的、自由度为1的分层卡方统计量。\n- 设 $P$ 为使用自由度为1的卡方累积分布函数（CDF）计算出的相应p值。\n- 设 $B$ 为一个布尔值，指示是否有任何单个分层的层内p值严格低于 $\\alpha$。\n\n您的程序应生成单行输出，其中包含一个含三个元素的列表，每个元素对应一个测试用例，且每个元素本身是一个列表 $[S,P,B]$。浮点数 $S$ 和 $P$ 必须四舍五入到恰好六位小数，$B$ 必须是 True 或 False。该行必须严格按照以下格式打印（无多余空格）：例如，$[[S_{1},P_{1},B_{1}],[S_{2},P_{2},B_{2}],[S_{3},P_{3},B_{3}]]$。", "solution": "用户提供了一个有效的、定义明确的生存分析问题。任务是实现一个分层对数秩检验，以比较两个处理组之间的生存分布，分层基于连续协变量 $Z$ 的非线性变换。该方法依赖于既定的统计学原理，特别是在原假设下事件分布的超几何模型，该模型适用于处理事件时间中的结。\n\n整个过程包括四个主要步骤：数据分层、计算每个分层内的对数秩统计量、汇总为单个分层检验统计量，以及评估单个分层内的残余处理差异。\n\n1.  **数据分层**\n    对于每个受试者 $i$，给定一个观测时间 $T_i$、一个事件指示符 $\\delta_i$（$1$ 代表事件，$0$ 代表删失）、一个处理组分配 $G_i \\in \\{0, 1\\}$ 和一个连续协变量值 $Z_i$。分层是基于协变量 $Z$ 的非线性变换进行的。具体来说，我们为所有受试者计算 $f(Z_i) = Z_i^2$。然后计算这些变换值的样本中位数 $m = \\text{median}(\\{f(Z_i)\\})$。数据被划分为两个分层：\n    -   下层：所有满足 $f(Z_i) \\le m$ 的受试者 $i$。\n    -   上层：所有满足 $f(Z_i)  m$ 的受试者 $i$。\n\n2.  **各分层内的对数秩检验**\n    在每个分层 $k$ 内，我们执行一个与标准对数秩检验类似的比较。设 $t_1  t_2  \\dots  t_D$ 为在分层 $k$ 中观察到的不同事件时间。在每个事件时间 $t_j$：\n    -   风险集 $R(t_j)$ 由该分层中在时间 $t_j$ 或恰好在 $t_j$ 之前仍在观察中的所有个体组成。即，观测时间 $T_i \\ge t_j$ 的个体。\n    -   设 $n_j$ 为风险集 $R(t_j)$ 中的个体总数。\n    -   设 $n_{1j}$ 为 $R(t_j)$ 中属于处理组 $1$ 的个体数。\n    -   设 $d_j$ 为在时间 $t_j$ 发生的事件总数。\n    -   设 $d_{1j}$ 为在时间 $t_j$ 观察到的处理组 $1$ 个体中的事件数。\n\n    在分层内两个处理组的风险率没有差异的原假设（$H_0$）下，给定计数 $n_j$、$n_{1j}$ 和 $d_j$ 的条件下，来自组 $1$ 的事件数 $d_{1j}$ 服从超几何分布。\n    在时间 $t_j$ 组 $1$ 中的预期事件数由下式给出：\n    $$ E_j = d_j \\frac{n_{1j}}{n_j} $$\n    在时间 $t_j$ 组 $1$ 中的事件数方差，其中包含了处理事件时间结的有限总体校正，由超几何分布的方差给出：\n    $$ V_j = d_j \\frac{n_{1j}}{n_j} \\left(1 - \\frac{n_{1j}}{n_j}\\right) \\frac{n_j - d_j}{n_j - 1} $$\n    如果分母 $n_j - 1$ 为零（即 $n_j \\le 1$），或者如果 $n_{1j}=0$，$n_{1j}=n_j$，$d_j=0$ 或 $d_j=n_j$，则方差 $V_j$ 为 $0$。\n\n3.  **汇总与统计量构建**\n    一个分层内所有唯一事件时间的贡献被汇总。对于分层 $k$：\n    -   分层水平得分为观察事件数减去预期事件数的总和：$O_k - E_k = \\sum_{j} (d_{1j} - E_j)$。\n    -   分层水平方差为各方差之和：$V_k = \\sum_j V_j$。\n\n    为了获得总体的分层检验统计量，我们将两个分层（我们将其标记为 $k=1, 2$）的得分和方差相加：\n    -   总体得分：$O - E = (O_1 - E_1) + (O_2 - E_2) = \\sum_k (O_k - E_k)$。\n    -   总体方差：$V = V_1 + V_2 = \\sum_k V_k$。\n\n    总体的分层对数秩统计量 $S$ 随后被构建为一个二次型：\n    $$ S = \\frac{(O - E)^2}{V} $$\n    在所有分层中处理效应均为零的全局原假设下，$S$ 渐近服从自由度为1的卡方（$\\chi^2$）分布。如果 $V=0$，统计量 $S$ 定义为 $0$。\n\n4.  **假设检验与残差评估**\n    -   **总体检验**：总体分层检验的p值 $P$ 是通过 $\\chi^2(1)$ 分布的生存函数（1 - CDF）计算的：$P = \\text{Pr}(\\chi^2_1 \\ge S)$。\n    -   **层内评估**：为了评估在任何单个分层内是否存在显著的处理差异，需要为每个分层 $k$ 计算一个单独的统计量：\n        $$ S_k = \\frac{(O_k - E_k)^2}{V_k} $$\n        在特定于分层的原假设下，这个 $S_k$ 也服从 $\\chi^2(1)$ 分布。相应的p值为 $P_k = \\text{Pr}(\\chi^2_1 \\ge S_k)$。如果一个分层的方差为零（$V_k=0$），它不提供任何用于比较的信息；在这种情况下，其统计量 $S_k$ 定义为 $0$，其p值 $P_k$ 定义为 $1$。\n    -   **布尔标志**：如果任何一个层内p值 $P_k$ 严格小于指定的显著性水平 $\\alpha = 0.05$，则布尔标志 $B$ 设置为 `True`。否则，$B$ 设置为 `False`。\n\n    每个测试用例的最终输出是一个列表 $[S, P, B]$，其中浮点数值 $S$ 和 $P$ 四舍五入到六位小数。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef stratified_log_rank(times: np.ndarray, events: np.ndarray, groups: np.ndarray, z: np.ndarray) - list:\n    \"\"\"\n    Performs a stratified log-rank test on survival data.\n\n    Args:\n        times: Array of observed times.\n        events: Array of event indicators (1=event, 0=censored).\n        groups: Array of treatment group labels (0 or 1).\n        z: Array of continuous covariate values.\n\n    Returns:\n        A list containing [S, P, B]:\n        S: The overall stratified chi-square statistic.\n        P: The corresponding p-value.\n        B: A boolean indicating if any stratum has p  0.05.\n    \"\"\"\n    # --- 1. Stratification ---\n    z_sq = z**2\n    median_z_sq = np.median(z_sq)\n    \n    lower_stratum_mask = z_sq = median_z_sq\n    upper_stratum_mask = z_sq  median_z_sq\n\n    strata_masks = [lower_stratum_mask, upper_stratum_mask]\n    \n    stratum_results = []\n\n    # --- 2. Per-Stratum Calculation ---\n    for mask in strata_masks:\n        if not np.any(mask):\n            # Stratum is empty, contribute zero information.\n            stratum_results.append({'O_minus_E': 0.0, 'V': 0.0})\n            continue\n\n        s_times = times[mask]\n        s_events = events[mask]\n        s_groups = groups[mask]\n\n        # Find unique event times in this stratum\n        unique_event_times = np.unique(s_times[s_events == 1])\n        \n        stratum_O_minus_E = 0.0\n        stratum_V = 0.0\n        \n        if unique_event_times.size == 0:\n            # No events in stratum, contribute zero information.\n            stratum_results.append({'O_minus_E': 0.0, 'V': 0.0})\n            continue\n\n        for t in unique_event_times:\n            # Identify risk set at time t\n            at_risk_mask = s_times = t\n            n_j = np.sum(at_risk_mask)\n            \n            # Sub-populations in risk set\n            risk_set_groups = s_groups[at_risk_mask]\n            n_1j = np.sum(risk_set_groups == 1)\n\n            # Identify events at time t\n            event_mask = (s_times == t)  (s_events == 1)\n            d_j = np.sum(event_mask)\n            d_1j = np.sum(event_mask  (s_groups == 1))\n\n            if n_j == 0: # Should not happen if there are events\n                continue\n\n            # Calculate expected events and variance\n            E_j = d_j * (n_1j / n_j)\n            stratum_O_minus_E += (d_1j - E_j)\n\n            if n_j  1:\n                term1 = d_j * (n_1j / n_j) * (1 - n_1j / n_j)\n                correction = (n_j - d_j) / (n_j - 1)\n                V_j = term1 * correction\n            else:\n                # Variance is 0 if risk set size is 1 or less\n                V_j = 0.0\n            \n            stratum_V += V_j\n\n        stratum_results.append({'O_minus_E': stratum_O_minus_E, 'V': stratum_V})\n    \n    # --- 3. Aggregation and Statistic Construction ---\n    # Within-stratum statistics\n    alpha = 0.05\n    has_significant_stratum = False\n    \n    for res in stratum_results:\n        V_k = res['V']\n        O_minus_E_k = res['O_minus_E']\n        \n        if V_k  0:\n            S_k = (O_minus_E_k**2) / V_k\n            P_k = chi2.sf(S_k, 1)\n        else:\n            S_k = 0.0\n            P_k = 1.0\n        \n        if P_k  alpha:\n            has_significant_stratum = True\n\n    # Overall stratified statistic\n    total_O_minus_E = sum(res['O_minus_E'] for res in stratum_results)\n    total_V = sum(res['V'] for res in stratum_results)\n\n    if total_V  0:\n        S = (total_O_minus_E**2) / total_V\n        P = chi2.sf(S, 1)\n    else:\n        S = 0.0\n        P = 1.0\n\n    return [S, P, has_significant_stratum]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"times\": np.array([2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 8, 9, 10, 11]),\n            \"events\": np.array([1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]),\n            \"groups\": np.array([0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]),\n            \"z\": np.array([1, -1, 1, -1, 1, -1, 1, -1, 2, -2, 2, -2, 2, -2, 2, -2]),\n        },\n        {\n            \"times\": np.array([5, 6, 7, 8, 3, 6, 4, 5]),\n            \"events\": np.array([0, 0, 0, 0, 1, 1, 1, 1]),\n            \"groups\": np.array([0, 1, 0, 1, 0, 0, 1, 1]),\n            \"z\": np.array([1, -1, -1, 1, 2, 2, -2, -2]),\n        },\n        {\n            \"times\": np.array([5, 5, 5, 9, 7, 7, 9, 9]),\n            \"events\": np.array([1, 1, 1, 0, 1, 1, 0, 0]),\n            \"groups\": np.array([0, 1, 0, 1, 0, 1, 0, 1]),\n            \"z\": np.array([1, -1, 1, -1, 2, -2, 2, -2]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        S, P, B = stratified_log_rank(**case)\n        results.append([round(S, 6), round(P, 6), B])\n\n    # Format the output string without spaces inside the inner lists.\n    formatted_results = []\n    for res_list in results:\n        # Format floats to 6 decimal places, ensuring trailing zeros\n        s_str = f\"{res_list[0]:.6f}\"\n        p_str = f\"{res_list[1]:.6f}\"\n        b_str = str(res_list[2])\n        formatted_results.append(f\"[{s_str},{p_str},{b_str}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3185163"}]}