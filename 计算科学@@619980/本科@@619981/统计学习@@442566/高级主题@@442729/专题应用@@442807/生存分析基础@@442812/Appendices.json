{"hands_on_practices": [{"introduction": "Kaplan-Meier (KM) 估计量是生存分析的基石，它提供了一种从删失数据中估计生存函数的非参数方法。然而，该估计的精度并非恒定不变，它关键性地取决于每个事件时间点上可用信息的数量。本练习将引导您通过一个思想实验，探讨删失如何影响 KM 估计量的方差，从而帮助您建立关于数据质量与统计精度之间关系的关键直觉 [@problem_id:3179136]。", "problem": "一项队列研究从基线开始随访 $n=100$ 名独立受试者。考虑使用非参数Kaplan-Meier (KM) 估计量来估计 $t=9$ 个月时的生存函数。在下述两种研究设计中，$t=9$ 个月之前恰好有三个不同的事件时间，分别为 $t_1=3$、$t_2=6$ 和 $t_3=9$ 个月，对应的事件计数分别为 $d_1=5$、$d_2=4$ 和 $d_3=3$。没有事件和删失恰好发生在同一记录时间。两种设计的唯一区别在于事件时间之间被删失的受试者数量，具体如下：\n\n- 设计L（较低删失）：在 $0$ 到 $3$ 个月之间，删失人数为 $c_{(0,3)}=0$；在 $3$ 到 $6$ 个月之间，删失人数为 $c_{(3,6)}=2$；在 $6$ 到 $9$ 个月之间，删失人数为 $c_{(6,9)}=3$。在 $t=9$ 个月之前没有其他失访。\n- 设计H（较高删失）：在 $0$ 到 $3$ 个月之间，删失人数为 $c_{(0,3)}=10$；在 $3$ 到 $6$ 个月之间，删失人数为 $c_{(3,6)}=10$；在 $6$ 到 $9$ 个月之间，删失人数为 $c_{(6,9)}=10$。在 $t=9$ 个月之前没有其他失访。\n\n仅使用KM估计量、风险集的基本定义，以及KM估计量在固定时间点上经过充分检验的大样本方差行为，判断哪个陈述最能描述设计H和设计L在 $t=9$ 个月时方差的比较情况。选择唯一的最佳答案。\n\nA. 在 $t=9$ 个月时的方差在设计H中更小，因为提供信息的个体较少，从而导致变异性降低。\n\nB. 在 $t=9$ 个月时的方差在设计H中更大，因为在 $t=9$ 个月前增加的删失减少了事件时间点的风险集大小，从而增大了乘积极限估计量的变异性。\n\nC. 在 $t=9$ 个月时的方差在两种设计中相同，因为KM估计量及其变异性仅取决于事件计数和事件时间，而与删失无关。\n\nD. 在 $t=9$ 个月时的方差在设计H中未定义，因为大量删失使得在 $t=9$ 个月前的非参数生存估计无效。", "solution": "用户希望我验证一个关于Kaplan-Meier估计量在两种不同删失情景下其方差比较的问题陈述。\n\n### 步骤1：提取已知条件\n\n-   基线时总受试者数：$n=100$，独立。\n-   任务：使用Kaplan-Meier (KM) 估计量估计 $t=9$ 个月时的生存函数 $S(t)$。\n-   不同的事件时间点：$t_1=3$ 个月，$t_2=6$ 个月，$t_3=9$ 个月。\n-   事件计数：在 $t_1$ 时 $d_1=5$，在 $t_2$ 时 $d_2=4$，在 $t_3$ 时 $d_3=3$。\n-   在同一记录时间，事件和删失之间没有结。\n-   设计L（较低删失）：\n    -   在 $(0, 3)$ 个月内删失的受试者数量：$c_{(0,3)}=0$。\n    -   在 $(3, 6)$ 个月内删失的受试者数量：$c_{(3,6)}=2$。\n    -   在 $(6, 9)$ 个月内删失的受试者数量：$c_{(6,9)}=3$。\n-   设计H（较高删失）：\n    -   在 $(0, 3)$ 个月内删失的受试者数量：$c_{(0,3)}=10$。\n    -   在 $(3, 6)$ 个月内删失的受试者数量：$c_{(3,6)}=10$。\n    -   在 $(6, 9)$ 个月内删失的受试者数量：$c_{(6,9)}=10$。\n-   问题要求比较设计H和设计L中KM估计量在 $t=9$ 个月时的方差 $\\text{Var}(\\hat{S}(9))$。\n\n### 步骤2：使用提取的已知条件进行验证\n\n必须评估问题陈述的科学依据、良置性 (well-posed) 和客观性。\n\n1.  **科学或事实不健全性**：该问题基于已建立的生存分析统计理论。Kaplan-Meier估计量、风险集、删失以及通过Greenwood公式进行方差估计都是该领域的标准课题。该设定描述了一个合理的队列研究。未检测到科学或事实上的不健全之处。\n2.  **非形式化或不相关**：该问题完全可以在生存分析的框架内形式化，并且与 *生存分析基础* 这一主题直接相关。\n3.  **不完整或矛盾的设定**：该问题提供了计算目标量所需的所有必要数据。我们来验证一下数据的一致性。\n    -   对于设计L，在每个事件时间 $t_i$ 的风险人数 $n_i$ 为：\n        -   $n_{1,L} = 100 - c_{(0,3)} = 100 - 0 = 100$。\n        -   $n_{2,L} = (n_{1,L} - d_1) - c_{(3,6)} = (100 - 5) - 2 = 93$。\n        -   $n_{3,L} = (n_{2,L} - d_2) - c_{(6,9)} = (93 - 4) - 3 = 86$。\n    -   对于设计H，在每个事件时间 $t_i$ 的风险人数 $n_i$ 为：\n        -   $n_{1,H} = 100 - c_{(0,3)} = 100 - 10 = 90$。\n        -   $n_{2,H} = (n_{1,H} - d_1) - c_{(3,6)} = (90 - 5) - 10 = 75$。\n        -   $n_{3,H} = (n_{2,H} - d_2) - c_{(6,9)} = (75 - 4) - 10 = 61$。\n    在两种设计中，每个时间点的风险人数 ($n_i$) 始终大于事件数 ($d_i$)，因此计算是良定义的。该设定是完整的且内部一致的。\n4.  **不切实际或不可行**：这些数字对于医学或工程可靠性研究来说是合理的。不存在物理上或科学上的不可能性。\n5.  **病态 (ill-posed) 或结构不良**：问题是明确的，要求比较方差，这是一个良定义的统计量。可以推导出唯一、稳定且有意义的解。\n6.  **伪深刻、琐碎或同义反复**：该问题测试了关于删失对生存估计精度影响的核心概念点。它并非琐碎问题，因为它需要理解KM估计量方差公式的结构。\n7.  **超出科学可验证性**：这些声明在数学上是可验证的。\n\n### 步骤3：结论和行动\n\n问题陈述是 **有效的**。开始进行解答。\n\n### 推导\n\n生存函数 $S(t)$ 的Kaplan-Meier (KM) 估计量由乘积极限公式给出：\n$$ \\hat{S}(t) = \\prod_{i: t_i \\le t} \\left( 1 - \\frac{d_i}{n_i} \\right) $$\n其中 $t_i$ 是不同的事件时间，$d_i$ 是在 $t_i$ 时的事件数，$n_i$ 是恰好在 $t_i$ 之前处于风险集中的个体数量（即，正在被观察且尚未发生事件）。\n\n问题涉及KM估计量在 $t=9$ 个月时的方差。$\\hat{S}(t)$ 的大样本近似方差最常用的公式是Greenwood公式：\n$$ \\widehat{\\text{Var}}(\\hat{S}(t)) \\approx [\\hat{S}(t)]^2 \\sum_{i: t_i \\le t} \\frac{d_i}{n_i(n_i - d_i)} $$\n我们需要比较设计L的 $\\widehat{\\text{Var}}(\\hat{S}_L(9))$ 和设计H的 $\\widehat{\\text{Var}}(\\hat{S}_H(9))$。求和将针对三个事件时间 $t_1=3$、$t_2=6$ 和 $t_3=9$ 进行。\n\n我们来计算两种设计的风险集大小 $n_i$。\n\n**对于设计L（较低删失）：**\n-   在 $t_1=3$ 时的风险集：$n_{1,L} = 100$。\n-   $t_1$ 后的存活人数：$100 - 5 = 95$。\n-   在 $(3,6)$ 之间删失的人数：$c_{(3,6)} = 2$。\n-   在 $t_2=6$ 时的风险集：$n_{2,L} = 95 - 2 = 93$。\n-   $t_2$ 后的存活人数：$93 - 4 = 89$。\n-   在 $(6,9)$ 之间删失的人数：$c_{(6,9)} = 3$。\n-   在 $t_3=9$ 时的风险集：$n_{3,L} = 89 - 3 = 86$。\n\n**对于设计H（较高删失）：**\n-   在 $t_1=3$ 时的风险集：$n_{1,H} = 100 - 10 = 90$。\n-   $t_1$ 后的存活人数：$90 - 5 = 85$。\n-   在 $(3,6)$ 之间删失的人数：$c_{(3,6)} = 10$。\n-   在 $t_2=6$ 时的风险集：$n_{2,H} = 85 - 10 = 75$。\n-   $t_2$ 后的存活人数：$75 - 4 = 71$。\n-   在 $(6,9)$ 之间删失的人数：$c_{(6,9)} = 10$。\n-   在 $t_3=9$ 时的风险集：$n_{3,H} = 71 - 10 = 61$。\n\n通过直接比较，对于每个事件时间 $i \\in \\{1, 2, 3\\}$，设计H中的风险集大小都小于设计L：\n-   $n_{1,H} = 90  n_{1,L} = 100$\n-   $n_{2,H} = 75  n_{2,L} = 93$\n-   $n_{3,H} = 61  n_{3,L} = 86$\n\n现在，我们来分析对方差的影响。方差公式由两部分组成：生存估计的平方 $[\\hat{S}(9)]^2$ 和求和项 $\\sum_{i=1}^3 \\frac{d_i}{n_i(n_i-d_i)}$。\n\n1.  **对求和项的分析：**和中的项形式为 $\\frac{d_i}{n_i(n_i-d_i)}$。由于在每个时间 $i$，$d_i$ 对于两种设计都是常数，并且函数 $f(x) = \\frac{k}{x(x-k)}$（对于固定的 $k>0$）在 $x>k$ 时是递减函数，所以较小的 $n_i$ 值会导致该项的值较大。\n    由于对于所有的 $i=1, 2, 3$ 都有 $n_{i,H}  n_{i,L}$，因此得出：\n    $$ \\frac{d_i}{n_{i,H}(n_{i,H} - d_i)} > \\frac{d_i}{n_{i,L}(n_{i,L} - d_i)} \\quad \\text{for each } i. $$\n    因此，对于设计H，整个和更大：\n    $$ \\sum_{i=1}^3 \\frac{d_i}{n_{i,H}(n_{i,H} - d_i)} > \\sum_{i=1}^3 \\frac{d_i}{n_{i,L}(n_{i,L} - d_i)} $$\n\n2.  **对生存估计的分析：**生存估计 $\\hat{S}(9)$ 是各项 $(1 - d_i/n_i)$ 的乘积。由于 $n_{i,H}  n_{i,L}$，风险估计 $d_i/n_{i,H} > d_i/n_{i,L}$，这意味着对于每个 $i$，生存因子 $(1 - d_i/n_{i,H})  (1 - d_i/n_{i,L})$。因此，设计H的乘积更小：$\\hat{S}_H(9)  \\hat{S}_L(9)$。这意味着前置因子 $[\\hat{S}_H(9)]^2$ 小于 $[\\hat{S}_L(9)]^2$。\n\n尽管这两种效应（求和项和前置因子）方向相反，但求和项的变化通常占主导地位。这里测试的核心原理是，删失减少了可用于估计的信息量，直观上这必然导致更高的方差（更低的精度）。较小的风险集直接反映了这种信息损失。我们通过计算来证实这一点。\n\n对于设计L：$\\hat{S}_L(9) = (1 - \\frac{5}{100})(1 - \\frac{4}{93})(1 - \\frac{3}{86}) \\approx 0.8770$。\nL的求和项：$\\frac{5}{100(95)} + \\frac{4}{93(89)} + \\frac{3}{86(83)} \\approx 0.000526 + 0.000483 + 0.000420 = 0.001429$。\n$\\widehat{\\text{Var}}(\\hat{S}_L(9)) \\approx (0.8770)^2 \\times 0.001429 \\approx 0.7691 \\times 0.001429 \\approx 0.001099$。\n\n对于设计H：$\\hat{S}_H(9) = (1 - \\frac{5}{90})(1 - \\frac{4}{75})(1 - \\frac{3}{61}) \\approx 0.8494$。\nH的求和项：$\\frac{5}{90(85)} + \\frac{4}{75(71)} + \\frac{3}{61(58)} \\approx 0.000654 + 0.000751 + 0.000848 = 0.002253$。\n$\\widehat{\\text{Var}}(\\hat{S}_H(9)) \\approx (0.8494)^2 \\times 0.002253 \\approx 0.7215 \\times 0.002253 \\approx 0.001626$。\n\n计算证实了 $\\widehat{\\text{Var}}(\\hat{S}_H(9)) > \\widehat{\\text{Var}}(\\hat{S}_L(9))$。设计H的方差更大。这是因为较重的删失导致风险集大小 ($n_i$) 的减小，从而使得单个方差贡献项 $\\frac{d_i}{n_i(n_i-d_i)}$ 的增加幅度，比生存估计前置因子 $[\\hat{S}(9)]^2$ 的减小幅度更为显著。\n\n### 逐项分析\n\nA. 在 $t=9$ 个月时的方差在设计H中更小，因为提供信息的个体较少，从而导致变异性降低。\n这个陈述在两个方面是错误的。首先，我们的计算表明设计H的方差更大，而不是更小。其次，其推理存在缺陷；提供信息的个体较少（即有效样本量较小）会导致变异性*增加*，而不是减少。\n**结论：错误。**\n\nB. 在 $t=9$ 个月时的方差在设计H中更大，因为在 $t=9$ 个月前增加的删失减少了事件时间点的风险集大小，从而增大了乘积极限估计量的变异性。\n这个陈述正确地声称设计H的方差更大。其提供的推理恰是导致这一结果的机制：增加的删失导致风险集 ($n_i$) 变小，这反过来又增大了Greenwood公式中的各项，从而“增大了变异性”。这与我们的推导完全一致。\n**结论：正确。**\n\nC. 在 $t=9$ 个月时的方差在两种设计中相同，因为KM估计量及其变异性仅取决于事件计数和事件时间，而与删失无关。\n这个陈述是错误的。我们的计算表明方差是不同的。其推理从根本上就是错误的。KM估计 $\\hat{S}(t)$ 及其方差都明确地依赖于风险集大小 $n_i$，而风险集大小直接受删失模式的影响。\n**结论：错误。**\n\nD. 在 $t=9$ 个月时的方差在设计H中未定义，因为大量删失使得在 $t=9$ 个月前的非参数生存估计无效。\n这个陈述是错误的。只要风险集不为零，KM估计量及其方差就是良定义的。在设计H中， $t=9$ 个月时的风险集为 $n_{3,H} = 61$，远大于零。设计H中的删失程度尚不足以导致估计量未定义。\n**结论：错误。**", "answer": "$$\\boxed{B}$$", "id": "3179136"}, {"introduction": "虽然 Kaplan-Meier 曲线提供了生存情况的全貌，但直接比较它们可能具有挑战性，尤其是当曲线交叉时（这是非等比例风险的标志）。限制性平均生存时间 (RMST) 通过计算在选定时间范围内的平均生存时间，提供了一个稳健且无需假设的汇总指标，其几何意义是生存曲线下的面积。在这个编程练习中，您将实现 RMST 的计算，从而获得一个实用的工具，用于在标准假设可能不成立的情景下比较不同治疗组 [@problem_id:3179108]。", "problem": "给定两个治疗组（A组和B组），每个组都有一个估计的生存曲线，该曲线表示为在有限时间网格上的一个右连续、非递增的分段常数阶梯函数。目标是计算截至一个有限时间范围的限制性平均生存时间（RMST），然后以一种在非比例风险（non-proportional hazards, NPH）条件下仍然有效的方式比较这两个治疗组。这种比较应通过在该时间范围内的限制性平均生存时间的差异来进行，该差异总结了到该时间为止的总体平均生存情况，而不依赖于比例风险假设。\n\n基本原理：\n- 生存函数定义为 $S(t)=\\mathbb{P}(Tt)$，其中 $T$ 是一个非负的事件发生时间随机变量。\n- 截至有限时间范围 $\\,\\tau\\,$ 的限制性平均生存时间定义为从 $\\,t=0\\,$ 到 $\\,t=\\tau\\,$ 的生存曲线下的面积。\n- 对于一个具有有限网格 $0=g_0  g_1  \\dots  g_m$ 的右连续阶梯函数 $S(t)$，该函数在每个区间 $[g_k,g_{k+1})$ 上是常数，并取在 $g_k$ 处给定的值。如果 $\\tau$ 严格位于一个区间内，则最后一个区间在 $\\tau$ 处被截断。\n\n程序输入规范：\n- 程序应内部存储一个测试用例列表。每个测试用例包括：\n  - 一个严格递增的时间网格 $[g_0,g_1,\\dots,g_m]$，其中 $g_0=0$ 且 $g_m\\ge \\tau$。\n  - 两个生存值列表，一个用于A组，一个用于B组，每个列表长度为 $m+1$。索引 $k$ 处的值是区间 $[g_k,g_{k+1})$ 上的右连续生存水平。\n  - 一个有限时间范围 $\\tau$，满足 $0\\le \\tau\\le g_m$。\n- 所有生存值都在 $[0,1]$ 范围内，并且随网格索引非递增。\n\n任务：\n- 对于每个测试用例，通过使用上述分段常数解释，对所提供的从 $t=0$ 到 $t=\\tau$ 的阶梯函数进行积分，计算A组和B组的限制性平均生存时间。\n- 计算差值 $\\Delta=\\mathrm{RMST}_B-\\mathrm{RMST}_A$。\n- 报告一个偏好指标 $I$，定义如下：\n  - 如果 $\\Delta>0$，则 $I=1$，\n  - 如果 $\\Delta0$，则 $I=-1$，\n  - 如果 $\\Delta=0$，则 $I=0$，\n  使用 $10^{-12}$ 的数值容差来判断是否相等。\n\n要求的数值输出格式：\n- 对于每个测试用例，输出一个包含四个值的列表：$[\\mathrm{RMST}_A,\\mathrm{RMST}_B,\\Delta,I]$。\n- 前三个值必须是四舍五入到六位小数的浮点数。最后一个值必须是整数。\n- 程序必须生成单行输出，其中包含所有测试用例的结果，形式为一个用方括号括起来的逗号分隔列表，其中每个元素是该测试用例的含四个值的方括号列表。例如：$[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],\\dots]$。\n\n程序内部需实现的测试套件：\n- 案例1（非比例风险，生存曲线交叉且内部截断）：\n  - 网格：$[0.0,2.0,5.0,8.0,12.0]$\n  - A组：$[1.0,0.92,0.80,0.74,0.70]$\n  - B组：$[1.0,0.96,0.78,0.77,0.72]$\n  - 时间范围：$\\tau=10.0$\n- 案例2（时间范围等于最后一个网格点）：\n  - 网格：$[0.0,3.0,6.0,9.0,12.0]$\n  - A组：$[1.0,0.90,0.82,0.70,0.60]$\n  - B组：$[1.0,0.95,0.75,0.72,0.65]$\n  - 时间范围：$\\tau=12.0$\n- 案例3（小时间范围位于第一个区间内，预期为平局）：\n  - 网格：$[0.0,4.0,9.0]$\n  - A组：$[1.0,0.85,0.70]$\n  - B组：$[1.0,0.88,0.68]$\n  - 时间范围：$\\tau=2.0$\n- 案例4（多次交叉且时间范围位于一个网格点上）：\n  - 网格：$[0.0,1.0,2.5,4.0,7.5,10.0]$\n  - A组：$[1.0,0.97,0.90,0.86,0.80,0.78]$\n  - B组：$[1.0,0.99,0.91,0.85,0.79,0.76]$\n  - 时间范围：$\\tau=7.5$\n\n您的程序应为每个案例计算所要求的四个值，并按照上述描述，以所要求的确切格式在单行中打印它们。不涉及用户输入；所有数据都嵌入在程序中。", "solution": "所提出的问题是有效的。它在科学上基于生存分析（统计学的一个分支）的原理，并且问题定义良好，具有清晰、客观和完整的规范。获得唯一解所需的所有数据和定义均已提供。\n\n主要目标是计算两个治疗组（A组和B组）在指定时间范围 $\\tau$ 内的限制性平均生存时间（RMST）。RMST是比较生存分布的一种稳健度量，尤其是在不满足比例风险假设时。每个组的生存函数 $S(t)$ 均以右连续、分段常数阶梯函数的形式提供。\n\n截至时间 $\\tau > 0$ 的RMST定义为从时间 $t=0$ 到 $t=\\tau$ 的生存曲线下的总面积：\n$$\n\\mathrm{RMST}(\\tau) = \\int_{0}^{\\tau} S(t) dt\n$$\n生存函数 $S_A(t)$ 和 $S_B(t)$ 定义在一个有限的、严格递增的时间网格 $G = \\{g_0, g_1, \\dots, g_m\\}$ 上，其中 $g_0=0$。对于每个组，都给出了相应的生存概率列表 $s = \\{s_0, s_1, \\dots, s_m\\}$。问题规定，生存函数 $S(t)$ 在每个区间 $[g_k, g_{k+1})$ 上是常数，取值为 $s_k$。即：\n$$\nS(t) = s_k \\quad \\text{for } t \\in [g_k, g_{k+1})\n$$\n计算 $\\mathrm{RMST}(\\tau)$ 的积分可以通过对阶梯函数在区间 $[0, \\tau]$ 上形成的矩形面积求和来完成。设网格点为 $g_0, g_1, \\dots, g_m$。我们遍历由这些网格点定义的区间。\n\n对于每个区间 $[g_k, g_{k+1})$（其中 $k \\in \\{0, 1, \\dots, m-1\\}$），我们计算其对积分的贡献。\n让我们考虑一个从 $g_k$ 开始的区间。\n如果时间范围 $\\tau$ 小于或等于 $g_k$，那么这个区间及所有后续区间对积分的贡献面积为零。\n如果时间范围 $\\tau$ 大于 $g_{k+1}$，则该区间的完整矩形面积都包含在内。该面积是高度 $s_k$ 乘以区间宽度 $(g_{k+1} - g_k)$。\n如果时间范围 $\\tau$ 落在该区间内，即 $g_k  \\tau \\le g_{k+1}$，则其贡献来自一个截断的矩形。该面积是高度 $s_k$ 乘以宽度 $(\\tau - g_k)$。这是对积分的最后贡献。\n\n这个过程可以形式化为一个算法。我们将 $\\mathrm{RMST}$ 初始化为 $0$。然后从 $k=0$ 到 $m-1$ 进行迭代：\n1. 定义区间起点 $t_{\\text{start}} = g_k$ 和终点 $t_{\\text{end}} = g_{k+1}$。\n2. 如果 $\\tau \\le t_{\\text{start}}$，积分已完成，因此我们停止。\n3. 确定积分区间的有效终点。这是区间终点 $t_{\\text{end}}$ 和时间范围 $\\tau$ 中的较小值。设其为 $t_{\\text{effective\\_end}} = \\min(\\tau, t_{\\text{end}})$。\n4. 此分段的矩形宽度为 $w_k = t_{\\text{effective\\_end}} - t_{\\text{start}}$。\n5. 此分段的生存概率为 $s_k$。\n6. 要增加的面积为 $A_k = s_k \\times w_k$。\n7. 将此面积加到总和中：$\\mathrm{RMST} = \\mathrm{RMST} + A_k$。\n\n使用此方法计算出 $\\mathrm{RMST}_A$ 和 $\\mathrm{RMST}_B$ 后，我们求它们的差值：\n$$\n\\Delta = \\mathrm{RMST}_B - \\mathrm{RMST}_A\n$$\n$\\Delta$ 的符号表明哪个治疗组在时间范围 $\\tau$ 内具有更长的平均生存时间。正的 $\\Delta$ 表示B组更优，而负的 $\\Delta$ 表示A组更优。\n\n最后，我们基于 $\\Delta$ 定义一个偏好指标 $I$，使用数值容差 $\\epsilon=10^{-12}$ 来处理与零比较时可能出现的浮点数不精确问题。\n$$\nI = \\begin{cases}\n1   \\text{if } \\Delta > \\epsilon \\\\\n-1  \\text{if } \\Delta  -\\epsilon \\\\\n0   \\text{otherwise}\n\\end{cases}\n$$\n每个测试用例的最终输出是一个包含计算值的列表：$[\\mathrm{RMST}_A, \\mathrm{RMST}_B, \\Delta, I]$，其中前三个值四舍五入到六位小数。\n\n例如，我们来计算案例1的结果：\n- 网格：$g = [0.0, 2.0, 5.0, 8.0, 12.0]$\n- A组生存率：$s_A = [1.0, 0.92, 0.80, 0.74, 0.70]$\n- B组生存率：$s_B = [1.0, 0.96, 0.78, 0.77, 0.72]$\n- 时间范围：$\\tau = 10.0$\n\n对于A组：\n- 区间 $[0.0, 2.0)$: 面积 = $s_{A,0} \\times (2.0 - 0.0) = 1.0 \\times 2.0 = 2.0$\n- 区间 $[2.0, 5.0)$: 面积 = $s_{A,1} \\times (5.0 - 2.0) = 0.92 \\times 3.0 = 2.76$\n- 区间 $[5.0, 8.0)$: 面积 = $s_{A,2} \\times (8.0 - 5.0) = 0.80 \\times 3.0 = 2.40$\n- 区间 $[8.0, 12.0)$，在 $\\tau=10.0$ 处截断：面积 = $s_{A,3} \\times (10.0 - 8.0) = 0.74 \\times 2.0 = 1.48$\n- $\\mathrm{RMST}_A = 2.0 + 2.76 + 2.40 + 1.48 = 8.64$\n\n对于B组：\n- 区间 $[0.0, 2.0)$: 面积 = $s_{B,0} \\times (2.0 - 0.0) = 1.0 \\times 2.0 = 2.0$\n- 区间 $[2.0, 5.0)$: 面积 = $s_{B,1} \\times (5.0 - 2.0) = 0.96 \\times 3.0 = 2.88$\n- 区间 $[5.0, 8.0)$: 面积 = $s_{B,2} \\times (8.0 - 5.0) = 0.78 \\times 3.0 = 2.34$\n- 区间 $[8.0, 12.0)$，在 $\\tau=10.0$ 处截断：面积 = $s_{B,3} \\times (10.0 - 8.0) = 0.77 \\times 2.0 = 1.54$\n- $\\mathrm{RMST}_B = 2.0 + 2.88 + 2.34 + 1.54 = 8.76$\n\n比较：\n- $\\Delta = \\mathrm{RMST}_B - \\mathrm{RMST}_A = 8.76 - 8.64 = 0.12$\n- 因为 $0.12 > 10^{-12}$，所以指标 $I=1$。\n- 案例1的结果是 $[8.640000, 8.760000, 0.120000, 1]$。\n此过程将应用于所有提供的测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Restricted Mean Survival Time (RMST) problem for a set of predefined test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: non-proportional hazards with crossing survival and interior truncation\n        {\n            \"grid\": np.array([0.0, 2.0, 5.0, 8.0, 12.0]),\n            \"surv_a\": np.array([1.0, 0.92, 0.80, 0.74, 0.70]),\n            \"surv_b\": np.array([1.0, 0.96, 0.78, 0.77, 0.72]),\n            \"tau\": 10.0,\n        },\n        # Case 2: horizon equals last grid point\n        {\n            \"grid\": np.array([0.0, 3.0, 6.0, 9.0, 12.0]),\n            \"surv_a\": np.array([1.0, 0.90, 0.82, 0.70, 0.60]),\n            \"surv_b\": np.array([1.0, 0.95, 0.75, 0.72, 0.65]),\n            \"tau\": 12.0,\n        },\n        # Case 3: small horizon inside the first interval, tie expected\n        {\n            \"grid\": np.array([0.0, 4.0, 9.0]),\n            \"surv_a\": np.array([1.0, 0.85, 0.70]),\n            \"surv_b\": np.array([1.0, 0.88, 0.68]),\n            \"tau\": 2.0,\n        },\n        # Case 4: multiple crossings and horizon on a grid point\n        {\n            \"grid\": np.array([0.0, 1.0, 2.5, 4.0, 7.5, 10.0]),\n            \"surv_a\": np.array([1.0, 0.97, 0.90, 0.86, 0.80, 0.78]),\n            \"surv_b\": np.array([1.0, 0.99, 0.91, 0.85, 0.79, 0.76]),\n            \"tau\": 7.5,\n        },\n    ]\n\n    def calculate_rmst(grid, survival_values, tau):\n        \"\"\"\n        Calculates the RMST for a right-continuous piecewise-constant survival function.\n        \n        Args:\n            grid (np.ndarray): The time grid points.\n            survival_values (np.ndarray): The survival probabilities on each interval.\n            tau (float): The time horizon for restriction.\n            \n        Returns:\n            float: The calculated RMST.\n        \"\"\"\n        rmst = 0.0\n        # Iterate through the intervals defined by the grid\n        for i in range(len(grid) - 1):\n            t_start = grid[i]\n            t_end = grid[i+1]\n            \n            # If the integration horizon is before or at the start of this interval, we are done.\n            if tau = t_start:\n                break\n            \n            # The value of the survival function in this interval [t_start, t_end)\n            s_val = survival_values[i]\n            \n            # Calculate the width of the integration for this interval.\n            # It's the distance from t_start to either tau or t_end, whichever is smaller.\n            integration_end = min(tau, t_end)\n            width = integration_end - t_start\n            \n            # Add the area of this rectangular segment to the total RMST.\n            rmst += s_val * width\n            \n        return rmst\n\n    formatted_results = []\n    tolerance = 1e-12\n\n    for case in test_cases:\n        grid, surv_a, surv_b, tau = case[\"grid\"], case[\"surv_a\"], case[\"surv_b\"], case[\"tau\"]\n\n        rmst_a = calculate_rmst(grid, surv_a, tau)\n        rmst_b = calculate_rmst(grid, surv_b, tau)\n        \n        delta = rmst_b - rmst_a\n        \n        if delta > tolerance:\n            indicator = 1\n        elif delta  -tolerance:\n            indicator = -1\n        else:\n            indicator = 0\n            \n        # Format the result list for this case as a string\n        case_result_str = (\n            f\"[{rmst_a:.6f},{rmst_b:.6f},{delta:.6f},{indicator}]\"\n        )\n        formatted_results.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3179108"}, {"introduction": "在非参数估计的基础上，我们可以使用 Cox 等比例风险 (PH) 模型和加速失效时间 (AFT) 模型等生存回归模型来评估协变量对生存时间的影响。然而，这些模型基于不同的基本假设；Cox 模型假定风险是等比例的，而这个条件在实践中常常不被满足。这个高级模拟练习将展示模型设定错误的具体后果，引导您生成违反 PH 假设的数据，然后分别拟合 Cox 和 AFT 模型，并使用 RMST 来评估哪个模型能提供更准确的预测 [@problem_id:3179084]。", "problem": "考虑一个影响事件时间随机变量 $T$ 的二元协变量 $x \\in \\{0,1\\}$。设生存函数定义为 $S(t \\mid x) = \\mathbb{P}(T  t \\mid x)$（对于 $t \\ge 0$），概率密度函数为 $f(t \\mid x)$，风险函数为 $h(t \\mid x) = \\frac{f(t \\mid x)}{S(t \\mid x)}$，累积风险函数为 $H(t \\mid x) = \\int_0^t h(u \\mid x) \\, du$。截至有限时间范围 $\\tau  0$ 的限制性平均生存时间（RMST）定义为\n$$\n\\mathrm{RMST}_x(\\tau) = \\int_0^\\tau S(t \\mid x)\\, dt.\n$$\n\n两种广泛使用的模型类别是：\n- Cox 比例风险（PH）模型，该模型假定 $h(t \\mid x) = h_0(t)\\,\\exp(\\beta_{\\mathrm{Cox}} x)$，其中 $h_0(t)$ 是一个未指定的基线风险函数，$\\beta_{\\mathrm{Cox}}$ 是一个回归系数。\n- 加速失效时间（AFT）模型，该模型假定 $\\log T = \\mu + \\beta_{\\mathrm{AFT}} x + \\sigma Z$，其中 $Z \\sim \\mathcal{N}(0,1)$，$\\mu \\in \\mathbb{R}$，$\\beta_{\\mathrm{AFT}} \\in \\mathbb{R}$，且 $\\sigma  0$；这意味着对数正态生存分布，并且当 $\\beta_{\\mathrm{AFT}} \\ne 0$ 时，通常违反比例风险假设。\n\n从上述核心定义出发，您必须：\n1. 在对数正态 AFT 数据生成过程中，模拟右删失生存数据，参数为 $(\\mu, \\beta, \\sigma)$，并采用率为 $\\lambda_c$ 的独立指数删失。对每个个体 $i$，抽取 $x_i \\in \\{0,1\\}$，$Z_i \\sim \\mathcal{N}(0,1)$，设置 $T_i = \\exp(\\mu + \\beta x_i + \\sigma Z_i)$，抽取 $C_i \\sim \\mathrm{Exp}(\\lambda_c)$，并观察 $Y_i = \\min(T_i, C_i)$ 和事件指示符 $\\delta_i = \\mathbb{I}\\{T_i \\le C_i\\}$。\n2. 通过最大化单个二元协变量 $x$ 的偏似然来拟合 Cox PH 模型，并使用 Breslow 估计量来估计基线累积风险。使用这些来构建预测的生存函数 $\\widehat{S}_{\\mathrm{Cox}}(t \\mid x)$。\n3. 在右删失下通过最大似然拟合对数正态 AFT 模型，以估计 $(\\widehat{\\mu}, \\widehat{\\beta}, \\widehat{\\sigma})$，并使用拟合的参数构建预测的生存函数 $\\widehat{S}_{\\mathrm{AFT}}(t \\mid x)$。\n4. 在对数正态数据生成过程下计算真实的生存函数 $S_{\\mathrm{true}}(t \\mid x)$，并计算相应的真实限制性平均生存时间 $\\mathrm{RMST}^{\\mathrm{true}}_x(\\tau) = \\int_0^\\tau S_{\\mathrm{true}}(t \\mid x) \\, dt$。在 $[0,\\tau]$ 上使用足够精细的网格对所有积分进行数值近似。\n5. 对于每个模型 $M \\in \\{\\mathrm{Cox}, \\mathrm{AFT}\\}$ 和组别 $x \\in \\{0,1\\}$，计算预测的限制性平均生存时间 $\\mathrm{RMST}^{M}_x(\\tau) = \\int_0^\\tau \\widehat{S}_M(t \\mid x)\\, dt$，以及其相对于真实值的绝对校准误差 $E^{M}_x(\\tau) = \\left|\\mathrm{RMST}^{M}_x(\\tau) - \\mathrm{RMST}^{\\mathrm{true}}_x(\\tau)\\right|$。通过平均绝对误差在两个组别间汇总校准情况，\n$$\n\\overline{E}^{M}(\\tau) = \\frac{E^{M}_0(\\tau) + E^{M}_1(\\tau)}{2}.\n$$\n6. 通过比较 $\\overline{E}^{\\mathrm{AFT}}(\\tau)$ 和 $\\overline{E}^{\\mathrm{Cox}}(\\tau)$ 来决定哪个模型能提供更好的 RMST$(\\tau)$ 校准：值较小的模型被认为校准得更好。\n\n您的程序必须实现上述完整的处理流程，并评估一个包含以下参数集的测试套件。每个测试用例是一个元组 $(n, p, \\mu, \\beta, \\sigma, \\lambda_c, \\tau, \\text{seed})$，其中 $n$ 是样本量，$p$ 是 $x=1$ 的概率，$\\mu$ 是对数尺度截距，$\\beta$ 是 AFT 效应，$\\sigma$ 是对数尺度标准差，$\\lambda_c$ 是指数删失率，$\\tau$ 是 RMST 时间范围，$\\text{seed}$ 是随机种子：\n- 用例 1：$(n, p, \\mu, \\beta, \\sigma, \\lambda_c, \\tau, \\text{seed}) = (1000, 0.5, 2.0, 0.7, 0.6, 0.05, 10.0, 1)$。\n- 用例 2：$(n, p, \\mu, \\beta, \\sigma, \\lambda_c, \\tau, \\text{seed}) = (1000, 0.5, 2.0, 1.0, 0.9, 0.2, 8.0, 2)$。\n- 用例 3：$(n, p, \\mu, \\beta, \\sigma, \\lambda_c, \\tau, \\text{seed}) = (500, 0.2, 1.5, 0.8, 0.5, 0.1, 6.0, 3)$。\n- 用例 4：$(n, p, \\mu, \\beta, \\sigma, \\lambda_c, \\tau, \\text{seed}) = (400, 0.5, 1.0, 1.2, 1.0, 0.3, 5.0, 4)$。\n\n数值单位：时间以任意单位计；无需进行物理单位转换。不涉及角度。百分比必须表示为小数。\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔的结果列表。对于每个测试用例（按上述顺序），元素必须是一个布尔值，指示加速失效时间模型是否比 Cox 比例风险模型产生更好的 RMST$(\\tau)$ 校准，即 $\\overline{E}^{\\mathrm{AFT}}(\\tau)  \\overline{E}^{\\mathrm{Cox}}(\\tau)$ 是否成立。最终输出必须如下所示：\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4],\n$$\n其中每个 $\\text{result}_k \\in \\{\\text{True},\\text{False}\\}$。", "solution": "用户希望解决一个统计模拟问题。\n\n计划如下：\n1.  **验证问题陈述**：\n    -   提取所有给定信息：定义、模型规格、模拟步骤、计算公式和测试用例。\n    -   检查是否存在任何科学、逻辑或结构上的缺陷。\n\n2.  **如果有效，设计解决方案**：\n    -   该问题是一个多步骤的模拟和建模练习。我需要将其分解为一个清晰的操作序列。\n    -   **步骤 1：数据生成**。这部分已明确规定。对于每个个体 $i=1, ..., n$：\n        -   抽取 $x_i \\sim \\text{Bernoulli}(p)$。\n        -   抽取 $Z_i \\sim \\mathcal{N}(0,1)$。\n        -   计算真实事件时间 $T_i = \\exp(\\mu + \\beta x_i + \\sigma Z_i)$。\n        -   抽取删失时间 $C_i \\sim \\text{Exp}(\\lambda_c)$。\n        -   观测时间为 $Y_i = \\min(T_i, C_i)$。\n        -   事件指示符为 $\\delta_i = \\mathbb{I}\\{T_i \\le C_i\\}$。\n    -   **步骤 2：Cox PH 模型拟合**。\n        -   模型为 $h(t \\mid x) = h_0(t) \\exp(\\beta_{\\text{Cox}} x)$。\n        -   需要最大化单个二元协变量 $x$ 的偏对数似然来找到 $\\widehat{\\beta}_{\\text{Cox}}$。偏对数似然为：\n            $$ \\ell(\\beta) = \\sum_{i=1}^n \\delta_i \\left( \\beta x_i - \\log \\sum_{j \\in R(Y_i)} \\exp(\\beta x_j) \\right) $$\n            其中 $R(Y_i) = \\{j: Y_j \\ge Y_i\\}$ 是在时间 $Y_i$ 的风险集。\n        -   我将需要一个数值优化器（如牛顿-拉夫逊法或 `scipy.optimize` 中的任何方法）来找到 $\\widehat{\\beta}_{\\text{Cox}}$。\n        -   找到 $\\widehat{\\beta}_{\\text{Cox}}$ 后，我需要使用 Breslow 估计量来估计累积基线风险 $H_0(t)$。\n            $$ \\widehat{H}_0(t) = \\sum_{Y_i \\le t, \\delta_i=1} \\frac{1}{\\sum_{j \\in R(Y_i)} \\exp(\\widehat{\\beta}_{\\text{Cox}} x_j)} $$\n            这是一个在观测到的事件时间处跳跃的阶跃函数。\n        -   Cox 模型的预测生存函数是 $\\widehat{S}_{\\text{Cox}}(t \\mid x) = \\exp(-\\widehat{H}(t \\mid x)) = \\exp(-\\widehat{H}_0(t) \\exp(\\widehat{\\beta}_{\\text{Cox}} x))$。\n    -   **步骤 3：对数正态 AFT 模型拟合**。\n        -   模型为 $\\log T = \\mu + \\beta x + \\sigma Z$，其中 $Z \\sim \\mathcal{N}(0,1)$。这等同于 $T \\sim \\text{Log-Normal}(\\mu + \\beta x, \\sigma^2)$。\n        -   令 $V_i = \\log Y_i$。该模型可以写成一个删失数据的线性回归模型：$V_i = \\mu + \\beta x_i + \\sigma Z_i^*$，其中 $Z_i^*$ 是误差项。\n        -   需要最大化来自参数分布的右删失数据的似然函数。对于个体 $i$，其对似然的贡献是：\n            $$ L_i(\\mu, \\beta, \\sigma) = [f_{T_i}(Y_i \\mid x_i)]^{\\delta_i} [S_{T_i}(Y_i \\mid x_i)]^{1-\\delta_i} $$\n            其中 $f_{T_i}$ 和 $S_{T_i}$ 是对数正态分布的概率密度函数和生存函数。\n        -   对数似然函数是：\n            $$ \\ell(\\mu, \\beta, \\sigma) = \\sum_{i=1}^n \\left\\{ \\delta_i \\log f_{T_i}(Y_i \\mid x_i) + (1-\\delta_i) \\log S_{T_i}(Y_i \\mid x_i) \\right\\} $$\n            $$ \\ell(\\mu, \\beta, \\sigma) = \\sum_{i=1}^n \\left\\{ \\delta_i \\left[ -\\log Y_i - \\log \\sigma + \\log \\phi(z_i) \\right] + (1-\\delta_i) \\log \\Phi(-z_i) \\right\\} $$\n            其中 $z_i = (\\log Y_i - \\mu - \\beta x_i)/\\sigma$，$\\phi$ 和 $\\Phi$ 分别是标准正态的PDF和CDF。\n        -   我需要使用 `scipy.optimize` 中的数值优化器来最大化这个关于 $(\\mu, \\beta, \\sigma)$ 的函数。\n        -   找到 $(\\widehat{\\mu}, \\widehat{\\beta}, \\widehat{\\sigma})$ 后，AFT 模型的预测生存函数是：\n            $$ \\widehat{S}_{\\text{AFT}}(t \\mid x) = \\Phi\\left(-\\frac{\\log t - (\\widehat{\\mu}+\\widehat{\\beta} x)}{\\widehat{\\sigma}}\\right) $$\n    -   **步骤 4：真实生存函数和 RMST**。\n        -   数据是从一个参数为 $(\\mu, \\beta, \\sigma)$ 的对数正态 AFT 模型生成的。所以真实的生存函数是已知的。\n        -   $S_{\\text{true}}(t \\mid x) = \\Phi\\left(-\\frac{\\log t - (\\mu+\\beta x)}{\\sigma}\\right)$。\n        -   真实的 RMST 是 $\\mathrm{RMST}^{\\text{true}}_x(\\tau) = \\int_0^\\tau S_{\\text{true}}(t \\mid x) \\, dt$。\n    -   **步骤 5：预测的 RMST 和误差计算**。\n        -   对于每个模型 $M \\in \\{\\text{Cox}, \\text{AFT}\\}$ 和组别 $x \\in \\{0,1\\}$，计算预测的 RMST：\n            $$ \\mathrm{RMST}^{M}_x(\\tau) = \\int_0^\\tau \\widehat{S}_M(t \\mid x)\\, dt $$\n        -   这些积分将进行数值计算。\n        -   然后，计算绝对校准误差：\n            $$ E^{M}_x(\\tau) = \\left|\\mathrm{RMST}^{M}_x(\\tau) - \\mathrm{RMST}^{\\text{true}}_x(\\tau)\\right| $$\n        -   最后，平均绝对误差：\n            $$ \\overline{E}^{M}(\\tau) = \\frac{E^{M}_0(\\tau) + E^{M}_1(\\tau)}{2} $$\n    -   **步骤 6：比较**。\n        -   比较 $\\overline{E}^{\\text{AFT}}(\\tau)$ 和 $\\overline{E}^{\\text{Cox}}(\\tau)$。\n        -   如果 $\\overline{E}^{\\text{AFT}}(\\tau)  \\overline{E}^{\\text{Cox}}(\\tau)$，则测试用例的结果为 `True`，否则为 `False`。\n\n该问题在科学和数学上是合理的，描述了生存分析中的一个标准模拟研究。所有术语都定义明确，并且程序是按算法指定的。测试用例中提供的参数对于此类研究是合理的。因此，该问题被认为是有效的。\n\n### 基于原则的解决方案设计\n\n该解决方案通过为每个测试用例实施问题陈述中描述的六步流程来推进。\n\n1.  **数据生成**：一个函数将从对数正态加速失效时间（AFT）模型中模拟右删失生存数据。对于 $n$ 个个体中的每一个，它会生成一个二元协变量 $x_i$，一个真实事件时间 $T_i = \\exp(\\mu + \\beta x_i + \\sigma Z_i)$（其中 $Z_i \\sim \\mathcal{N}(0,1)$），以及一个来自率为 $\\lambda_c$ 的指数分布的删失时间 $C_i$。个体 $i$ 的观测数据是随访时间 $Y_i = \\min(T_i, C_i)$ 和事件指示符 $\\delta_i = \\mathbb{I}(T_i \\leq C_i)$。为确保可复现性，为每个测试用例提供了参数 $(n, p, \\mu, \\beta, \\sigma, \\lambda_c)$ 和一个随机种子。\n\n2.  **Cox 模型拟合**：\n    -   **参数估计**：Cox 比例风险（PH）模型系数 $\\beta_{\\mathrm{Cox}}$ 是通过最大化偏对数似然来估计的。这是一个非线性优化问题，此处使用 `scipy.optimize.minimize` 提供的 BFGS 算法解决。目标函数（负偏对数似然）是根据公式 $\\ell(\\beta) = \\sum_{i: \\delta_i=1} [\\beta x_i - \\log(\\sum_{j \\in R(Y_i)} \\exp(\\beta x_j))]$ 构建的，其中 $R(Y_i)$ 是在时间 $Y_i$ 处于风险中的个体集合。为了高效地计算风险集总和，首先按观测时间 $Y_i$ 对数据进行排序，并使用逆向累积和。\n    -   **基线风险估计**：使用 Breslow 估计量估计累积基线风险 $H_0(t)$。这是一个在每个观测到的事件时间 $t_k$ 增加的阶跃函数。在 $t_k$ 处的跳跃大小是在 $t_k$ 发生的事件数除以风险评分的总和，$\\sum_{j \\in R(t_k)} \\exp(\\widehat{\\beta}_{\\mathrm{Cox}}x_j)$。\n    -   **生存预测**：估计的生存函数则为 $\\widehat{S}_{\\mathrm{Cox}}(t|x) = \\exp(-\\widehat{H}_0(t)\\exp(\\widehat{\\beta}_{\\mathrm{Cox}}x))$。\n\n3.  **AFT 模型拟合**：\n    -   **参数估计**：对数正态 AFT 模型参数 $(\\mu, \\beta, \\sigma)$ 是通过最大化右删失数据的全对数似然来估计的。对数似然函数为 $\\ell(\\mu, \\beta, \\sigma) = \\sum_i [\\delta_i \\log f(Y_i|x_i) + (1-\\delta_i) \\log S(Y_i|x_i)]$，其中 $f$ 和 $S$ 是对数正态分布的概率密度函数和生存函数。通过最小化负对数似然来找到参数，同样使用 BFGS 算法。为确保约束 $\\sigma > 0$，优化是针对 $\\log(\\sigma)$ 进行的。\n    -   **生存预测**：利用估计的参数 $(\\widehat{\\mu}, \\widehat{\\beta}, \\widehat{\\sigma})$，预测的生存函数为 $\\widehat{S}_{\\mathrm{AFT}}(t|x) = \\Phi\\left(-\\frac{\\log t - (\\widehat{\\mu} + \\widehat{\\beta}x)}{\\widehat{\\sigma}}\\right)$，其中 $\\Phi$ 是标准正态累积分布函数。\n\n4.  **真实量**：由于数据生成过程是已知的，真实的生存函数 $S_{\\mathrm{true}}(t|x)$ 就是具有真实参数 $(\\mu, \\beta, \\sigma)$ 的对数正态生存函数。真实的限制性平均生存时间（RMST）是该函数从 $0$ 到指定时间范围 $\\tau$ 的积分。\n\n5.  **RMST 计算和误差评估**：所有 RMST 值（真实的、Cox 预测的、AFT 预测的）都是通过对相应的生存函数从 $t=0$ 到 $t=\\tau$ 进行数值积分来计算的。为此，在精细的时间点网格上应用梯形法则（`numpy.trapz`）。然后，对于每个模型 $M \\in \\{\\mathrm{Cox}, \\mathrm{AFT}\\}$，通过在两个协变量组（$x=0$ 和 $x=1$）上平均预测 RMST 和真实 RMST 之间的绝对差异，来计算平均绝对校准误差 $\\overline{E}^M(\\tau)$。\n\n6.  **模型比较**：最后，如果 AFT 模型的平均绝对误差 $\\overline{E}^{\\mathrm{AFT}}(\\tau)$ 小于 Cox 模型的 $\\overline{E}^{\\mathrm{Cox}}(\\tau)$，则判断 AFT 模型具有更好的校准性。这种比较为每个测试用例产生一个布尔结果。由于数据是从 AFT 模型生成的，预计 AFT 模型通常会表现得更好，这为实现的正确性提供了概念性检查。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation study and print the results.\n    \"\"\"\n\n    def _fit_cox_model(Y, delta, x):\n        \"\"\"\n        Fits a Cox PH model for a single binary covariate using partial likelihood.\n        Implements Breslow's method for handling event times.\n        Returns the coefficient and a function for the Breslow baseline cumulative hazard.\n        \"\"\"\n        sort_idx = np.argsort(Y)\n        Y_sorted = Y[sort_idx]\n        delta_sorted = delta[sort_idx]\n        x_sorted = x[sort_idx]\n\n        def neg_log_partial_likelihood(beta, Y_s, delta_s, x_s):\n            beta = beta[0]\n            risk_scores = np.exp(beta * x_s)\n            risk_set_sums = np.cumsum(risk_scores[::-1])[::-1]\n            \n            # Use a small epsilon for numerical stability\n            log_risk_set_sums = np.log(risk_set_sums + 1e-30)\n            \n            event_indices = (delta_s == 1)\n            linear_term_at_events = beta * x_s[event_indices]\n            log_risk_set_sums_at_events = log_risk_set_sums[event_indices]\n            \n            log_likelihood = np.sum(linear_term_at_events - log_risk_set_sums_at_events)\n            return -log_likelihood\n\n        res = minimize(\n            neg_log_partial_likelihood,\n            x0=np.array([0.0]),\n            args=(Y_sorted, delta_sorted, x_sorted),\n            method='BFGS'\n        )\n        beta_cox = res.x[0]\n\n        risk_scores_est = np.exp(beta_cox * x_sorted)\n        risk_set_sums_est = np.cumsum(risk_scores_est[::-1])[::-1]\n        \n        event_mask = (delta_sorted == 1)\n        unique_event_times, event_time_indices = np.unique(Y_sorted[event_mask], return_inverse=True)\n        num_events_at_time = np.bincount(event_time_indices)\n        \n        y_event_indices = np.searchsorted(Y_sorted, unique_event_times)\n        risk_set_sum_at_event_time = risk_set_sums_est[y_event_indices]\n        \n        hazard_jumps = num_events_at_time / (risk_set_sum_at_event_time + 1e-30)\n        cum_hazard_jumps = np.cumsum(hazard_jumps)\n\n        def breslow_estimator(t_grid):\n            H0_t = np.zeros_like(t_grid, dtype=float)\n            indices = np.searchsorted(unique_event_times, t_grid, side='right')\n            valid_indices = (indices > 0)\n            H0_t[valid_indices] = cum_hazard_jumps[indices[valid_indices] - 1]\n            return H0_t\n            \n        return beta_cox, breslow_estimator\n\n    def _fit_aft_model(Y, delta, x):\n        \"\"\"\n        Fits a log-normal AFT model using maximum likelihood for right-censored data.\n        \"\"\"\n        log_Y = np.log(Y)\n        initial_params = np.array([1.0, 0.0, 0.0])\n        is_event = (delta == 1)\n        if np.sum(is_event) > 2:\n            x_event = x[is_event]\n            if np.any(x_event != x_event[0]):\n                log_Y_event = log_Y[is_event]\n                X = np.vstack([np.ones(len(x_event)), x_event]).T\n                try:\n                    params, _, _, _ = np.linalg.lstsq(X, log_Y_event, rcond=None)\n                    mu_init, beta_init = params\n                    residuals = log_Y_event - X @ params\n                    sigma_init = np.std(residuals)\n                    if sigma_init > 1e-4:\n                        initial_params = np.array([mu_init, beta_init, np.log(sigma_init)])\n                except np.linalg.LinAlgError:\n                    pass\n\n        def neg_log_likelihood(params, log_Y_l, delta_l, x_l):\n            mu, beta, log_sigma = params\n            sigma = np.exp(log_sigma)\n            if sigma  1e-6: return np.inf\n\n            z = (log_Y_l - mu - beta * x_l) / sigma\n            \n            events_mask = (delta_l == 1)\n            loglik = np.sum(norm.logpdf(z[events_mask]) - log_sigma - log_Y_l[events_mask])\n            loglik += np.sum(norm.logsf(z[~events_mask]))\n            \n            return -loglik if np.isfinite(loglik) else np.inf\n\n        res = minimize(\n            neg_log_likelihood,\n            initial_params,\n            args=(log_Y, delta, x),\n            method='BFGS'\n        )\n        mu_aft, beta_aft, log_sigma_aft = res.x\n        sigma_aft = np.exp(log_sigma_aft)\n        return mu_aft, beta_aft, sigma_aft\n\n    def _run_simulation_case(n, p, mu, beta, sigma, lambda_c, tau, seed):\n        \"\"\"\n        Runs the full pipeline for one test case.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        x = rng.binomial(1, p, size=n)\n        Z = rng.standard_normal(size=n)\n        T = np.exp(mu + beta * x + sigma * Z)\n        if lambda_c > 0:\n            C = rng.exponential(scale=1 / lambda_c, size=n)\n        else:\n            C = np.full(n, np.inf)\n        Y = np.minimum(T, C)\n        delta = (T = C).astype(int)\n\n        t_grid = np.linspace(0, tau, 2001)\n\n        beta_cox, H0_func = _fit_cox_model(Y, delta, x)\n        H0_on_grid = H0_func(t_grid)\n        S_cox_0 = np.exp(-H0_on_grid)\n        S_cox_1 = np.exp(-H0_on_grid * np.exp(beta_cox))\n        rmst_cox_0 = np.trapz(S_cox_0, t_grid)\n        rmst_cox_1 = np.trapz(S_cox_1, t_grid)\n\n        mu_aft, beta_aft, sigma_aft = _fit_aft_model(Y, delta, x)\n        with np.errstate(divide='ignore'):\n            log_t_grid = np.log(t_grid)\n        \n        S_aft_0 = norm.sf((log_t_grid - mu_aft) / sigma_aft)\n        S_aft_1 = norm.sf((log_t_grid - (mu_aft + beta_aft)) / sigma_aft)\n        S_aft_0[0] = 1.0\n        S_aft_1[0] = 1.0\n        rmst_aft_0 = np.trapz(S_aft_0, t_grid)\n        rmst_aft_1 = np.trapz(S_aft_1, t_grid)\n\n        S_true_0 = norm.sf((log_t_grid - mu) / sigma)\n        S_true_1 = norm.sf((log_t_grid - (mu + beta)) / sigma)\n        S_true_0[0] = 1.0\n        S_true_1[0] = 1.0\n        rmst_true_0 = np.trapz(S_true_0, t_grid)\n        rmst_true_1 = np.trapz(S_true_1, t_grid)\n\n        E_cox_0 = np.abs(rmst_cox_0 - rmst_true_0)\n        E_cox_1 = np.abs(rmst_cox_1 - rmst_true_1)\n        E_bar_cox = (E_cox_0 + E_cox_1) / 2.0\n\n        E_aft_0 = np.abs(rmst_aft_0 - rmst_true_0)\n        E_aft_1 = np.abs(rmst_aft_1 - rmst_true_1)\n        E_bar_aft = (E_aft_0 + E_aft_1) / 2.0\n\n        return E_bar_aft  E_bar_cox\n\n    test_cases = [\n        (1000, 0.5, 2.0, 0.7, 0.6, 0.05, 10.0, 1),\n        (1000, 0.5, 2.0, 1.0, 0.9, 0.2, 8.0, 2),\n        (500, 0.2, 1.5, 0.8, 0.5, 0.1, 6.0, 3),\n        (400, 0.5, 1.0, 1.2, 1.0, 0.3, 5.0, 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _run_simulation_case(*case)\n        results.append(str(result))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "3179084"}]}