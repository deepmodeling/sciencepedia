{"hands_on_practices": [{"introduction": "在构建复杂的网络之前，我们必须能够控制数据在各层之间流动时的几何形状。本练习将引导您推导出一个关键公式，用于计算保持特征图空间维度不变（即所谓的“相同”卷积）所需的确切填充量 [@problem_id:3126176]。掌握这项技能对于设计任何可预测和稳定的卷积神经网络架构都是一项基本功。", "problem": "考虑一个卷积神经网络（CNN）中的二维卷积层，它作用于一个高度为 $H$、宽度为 $W$ 的输入特征图。该层使用一个大小为 $k \\times k$ 的方形核，两个空间维度上的膨胀（dilation）均为 $d$，步长（stride）均为 $s$，并在空间边界上应用零填充（zero-padding）。假设采用通用库中实现的标准互相关（即没有核翻转），并且每个空间维度两侧的填充量均为整数值。\n\n从网格上的离散卷积定义以及膨胀和步长的定义出发，推导出输出高度等于输入高度（且与 $H$ 无关）的条件，以及针对宽度的类似条件。证明该条件强制总填充量、有效感受野和步长之间存在特定关系。然后，假设唯一能对所有 $H$ 保持空间尺寸不变的可选值为 $s=1$，推导出每个空间维度的最小总填充量 $P_{\\text{total}}(d,k)$ 的闭式表达式，该表达式保证输出的高度和宽度分别等于 $H$ 和 $W$。在你的推导中，解释为什么当 $k$ 为奇数时，对称的每侧填充量 $p = \\frac{d\\,(k-1)}{2}$ 能实现精确的“相同”卷积，并分析当 $k$ 为偶数时出现的“差一”不对称性，按 $d$ 的奇偶性区分情况。\n\n仅报告 $P_{\\text{total}}(d,k)$ 的单个闭式表达式作为最终答案。不包含任何单位。无需进行数值舍入。", "solution": "该问题要求推导最小总填充量 $P_{\\text{total}}(d, k)$，以确保二维卷积层的输出空间维度与输入空间维度相同，这种配置通常被称为“相同”（\"same\"）卷积。我们首先将输入和输出维度之间的关系形式化。\n\n设输入特征图的空间维度大小为 $N_{in}$（代表高度 $H$ 或宽度 $W$）。卷积层有一个大小为 $k$ 的核，一个膨胀因子 $d$，一个步长 $s$，以及沿该维度施加的总填充量 $P_{\\text{total}}$。该填充由两侧的整数填充量 $p_{left}$ 和 $p_{right}$ 组成，使得 $P_{\\text{total}} = p_{left} + p_{right}$。\n\n核的有效大小，即其感受野范围，并不仅仅是 $k$，而是通过膨胀被扩大了。膨胀后的核覆盖了 $k_{eff}$ 个输入元素的范围，由下式给出：\n$$k_{eff} = d \\cdot (k-1) + 1$$\n这个公式的由来是，在 $k$ 个核权重之间有 $k-1$ 个间隙，每个间隙的大小为 $d-1$。总范围是权重的数量加上间隙的总大小：$k + (k-1)(d-1) = k + kd - k - d + 1 = kd - d + 1 = d(k-1) + 1$。\n\n施加总填充量 $P_{\\text{total}}$ 后，输入维度的有效大小变为 $N_{in} + P_{\\text{total}}$。膨胀后核的左上角元素在这个填充后的输入上可能的位置数量为 $(N_{in} + P_{\\text{total}}) - k_{eff} + 1$。对于步长 $s$，输出元素的数量 $N_{out}$ 由标准公式给出：\n$$N_{out} = \\left\\lfloor \\frac{(N_{in} + P_{\\text{total}}) - k_{eff}}{s} \\right\\rfloor + 1$$\n代入 $k_{eff}$ 的表达式，我们得到：\n$$N_{out} = \\left\\lfloor \\frac{N_{in} + P_{\\text{total}} - (d(k-1) + 1)}{s} \\right\\rfloor + 1$$\n\n第一个任务是找到在任何输入大小 $N_{in} \\ge 1$ 下都满足 $N_{out} = N_{in}$ 的条件。\n设 $N_{out} = N_{in}$：\n$$N_{in} = \\left\\lfloor \\frac{N_{in} + P_{\\text{total}} - d(k-1) - 1}{s} \\right\\rfloor + 1$$\n$$N_{in} - 1 = \\left\\lfloor \\frac{N_{in} + P_{\\text{total}} - d(k-1) - 1}{s} \\right\\rfloor$$\n根据向下取整函数的定义，$\\lfloor x \\rfloor = y$ 等价于 $y \\le x  y+1$。应用这一定义，我们得到双重不等式：\n$$N_{in} - 1 \\le \\frac{N_{in} + P_{\\text{total}} - d(k-1) - 1}{s}  N_{in}$$\n乘以 $s$（其中 $s \\ge 1$ 是一个正整数）：\n$$s(N_{in} - 1) \\le N_{in} + P_{\\text{total}} - d(k-1) - 1  s N_{in}$$\n这个不等式必须对所有 $N_{in} \\ge 1$ 的值都成立。让我们重新整理各项以分离出 $N_{in}$：\n$$(s-1)N_{in} - s \\le P_{\\text{total}} - d(k-1) - 1  (s-1)N_{in}$$\n为了使这个不等式对所有 $N_{in}$ 都成立，依赖于 $N_{in}$ 的项不能让中间的常数项超出边界。如果 $s  1$，则 $s-1  0$，下界 $(s-1)N_{in} - s$ 和上界 $(s-1)N_{in}$ 都随 $N_{in}$ 增长。它们之间的区间 $[(s-1)N_{in} - s, (s-1)N_{in})$ 的宽度固定为 $s$，但其位置会移动。一个常数值 $P_{\\text{total}} - d(k-1) - 1$ 不可能对所有的 $N_{in}$ 都停留在这个移动的区间内。要对所有 $N_{in}$ 满足该条件的唯一方法是，如果 $N_{in}$ 的系数为零。这迫使 $s-1=0$，即 $s=1$。\n\n这个推导证实了问题的假设，即 $s=1$ 是保持空间大小与输入维度无关所必需的。当 $s=1$ 时，不等式简化为：\n$$-1 \\le P_{\\text{total}} - d(k-1) - 1  0$$\n因为 $P_{\\text{total}}$、$d$ 和 $k$ 都是整数，所以表达式 $P_{\\text{total}} - d(k-1) - 1$ 也必须是一个整数。唯一满足 $-1 \\le z  0$ 的整数 $z$ 是 $z=-1$。因此，我们必须有：\n$$P_{\\text{total}} - d(k-1) - 1 = -1$$\n$$P_{\\text{total}} = d(k-1)$$\n这是在 $s=1$ 时保证 $N_{out} = N_{in}$ 的唯一总填充量值。因此，它是最小且唯一的值。我们可以将其表示为 $P_{\\text{total}}(d,k) = d(k-1)$。\n\n问题还要求证明这强制了总填充量、有效感受野和步长之间的关系。我们有 $s=1$ 和 $P_{\\text{total}} = d(k-1)$。有效感受野是 $k_{eff} = d(k-1)+1$。因此，关系是 $P_{\\text{total}} = k_{eff} - 1$。\n\n最后，我们分析这个总填充量的实现。$P_{\\text{total}}$ 必须被分成两侧的填充量 $p_{left}$ 和 $p_{right}$，它们必须是整数。\n如果 $k$ 是奇数，则 $k-1$ 是偶数。因此，所需的总填充量 $P_{\\text{total}} = d(k-1)$ 始终是偶数，无论 $d$ 是奇数还是偶数。偶数的总填充量可以被完美地平衡，从而允许两侧对称填充：\n$$p = p_{left} = p_{right} = \\frac{P_{\\text{total}}}{2} = \\frac{d(k-1)}{2}$$\n这维持了输出特征图与输入的空间对齐。\n\n如果 $k$ 是偶数，则 $k-1$ 是奇数。总填充量 $P_{\\text{total}} = d(k-1)$ 的奇偶性现在取决于膨胀 $d$ 的奇偶性。\n- 如果 $d$ 是偶数，$P_{\\text{total}}$ 是偶数（偶数 × 奇数 = 偶数）。同样可以实现对称填充 $p = \\frac{d(k-1)}{2}$。\n- 如果 $d$ 是奇数，$P_{\\text{total}}$ 是奇数（奇数 × 奇数 = 奇数）。由于 $P_{\\text{total}}$ 是奇数，它不能被分成两个相等的整数部分。这强制了非对称填充，即 $p_{left} \\neq p_{right}$。例如，可以选择 $p_{left} = \\lfloor \\frac{P_{\\text{total}}}{2} \\rfloor = \\frac{d(k-1)-1}{2}$ 和 $p_{right} = \\lceil \\frac{P_{\\text{total}}}{2} \\rceil = \\frac{d(k-1)+1}{2}$。这种不可避免的不对称性导致输出特征图相对于输入产生半个像素的空间位移，这也就是所提到的“差一”不对称性。\n\n尽管存在这些关于对称或非对称应用的实现细节，但每个维度所需的总填充量是唯一确定的。保证输出大小等于输入大小的最小总填充量的闭式表达式为 $P_{\\text{total}}(d,k) = d(k-1)$。", "answer": "$$\n\\boxed{d(k-1)}\n$$", "id": "3126176"}, {"introduction": "卷积网络为何对图像等空间数据如此有效？一个核心原因是其内在的平移等变性：对输入进行平移，其输出特征图也会相应地平移。本练习将挑战您通过分析和编码来验证这一关键属性 [@problem_id:3126241]，从而揭示像填充这样的架构选择并非无足轻重的实现细节，而是维护此基本原则、确保网络能够在不同位置识别相同特征的关键。", "problem": "你的任务是利用离散卷积、有限网格上的平移算子以及逐点非线性的基本属性，来设计和验证平移等变的空间预测网络。平移等变性指的是，对于一个作用于二维数组的函数 $f$ 和一个平移算子 $T_{\\delta}$，关系式 $f(T_{\\delta} x) = T_{\\delta} f(x)$ 对所有有效的输入 $x$ 和平移 $\\delta$ 都成立。除非另有明确说明，否则网格是具有周期性边界条件的有限网格。\n\n将使用的基本基础和定义：\n- 一个二维离散信号是一个函数 $x: \\{0,\\dots,H-1\\} \\times \\{0,\\dots,W-1\\} \\to \\mathbb{R}$，表示为一个形状为 $H \\times W$ 的数组。\n- 带有 $\\delta = (\\delta_y,\\delta_x)$ 的循环平移算子 $T_{\\delta}$ 的作用是 $(T_{\\delta} x)[i,j] = x[(i-\\delta_y) \\bmod H, (j-\\delta_x) \\bmod W]$。\n- 对于一个奇数尺寸 $k_h \\times k_w$ 的核 $k$，其中心位于 $(\\lfloor k_h/2 \\rfloor,\\lfloor k_w/2 \\rfloor)$，在循环边界条件下，二维离散互相关由以下公式给出：\n  $$ (x \\star_{\\mathrm{circ}} k)[i,j] = \\sum_{m=0}^{k_h-1}\\sum_{n=0}^{k_w-1} x\\big((i+m-c_h) \\bmod H, (j+n-c_w) \\bmod W\\big)\\, k[m,n], $$\n  其中 $c_h = \\lfloor k_h/2 \\rfloor$ 且 $c_w = \\lfloor k_w/2 \\rfloor$。\n- 一个逐点非线性函数 $\\sigma$ 独立地作用于每个空间位置，例如 $\\sigma(u) = \\max(u,0)$（整流线性单元）。\n- 一个常数偏置 $b \\in \\mathbb{R}$ 被均匀地加到整个空间上，得到 $y[i,j] = u[i,j] + b$。\n\n任务：\n- 设计一个由循环互相关层、常数偏置和逐点非线性组成的小型网络家族，每个网络都产生一个 $H \\times W$ 的空间图。对于一个指定的反例，使用零填充（非循环）互相关来说明一个失败案例。\n- 对于每个网络，通过分析（从定义出发进行推理）来验证在哪种边界条件下，关系式 $f(T_{\\delta} x) = T_{\\delta} f(x)$ 对所有 $x$ 和 $\\delta$ 成立，在哪种条件下不成立。\n- 实现一个程序，使用最大绝对差准则和容差 $\\epsilon$ 来数值上测试等变关系 $f(T_{\\delta} x) = T_{\\delta} f(x)$，并为每个测试用例报告一个布尔值，指示该属性是否在容差范围内成立。\n\n数值细节和约束：\n- 使用形状为 $H \\times W$ 的数组，其中 $H = 16$ 且 $W = 16$。\n- 所有核必须具有奇数空间维度。\n- 对于循环层，使用如上定义的循环互相关。对于一个非循环案例，使用零填充互相关，它将域外的值视为零，并返回一个相同形状的数组。\n- 在任何要求使用非线性的地方，使用整流线性单元 $\\sigma(u) = \\max(u,0)$。\n- 使用容差 $\\epsilon = 10^{-9}$，通过条件 $\\max_{i,j} |A[i,j] - B[i,j]| \\le \\epsilon$ 来判断相等。\n- 随机性必须是可复现的。对于每个测试用例，使用提供的种子 $s$ 初始化一个伪随机数生成器，并从标准正态分布中独立抽取输入和核的所有条目。\n\n测试套件：\n每个测试用例指定 $(H,W,\\delta,\\text{architecture},\\text{kernel sizes},\\text{seed})$。实现以下六个案例，并评估属性 $f(T_{\\delta} x) = T_{\\delta} f(x)$。\n\n- 案例 A（理想路径，单层）：\n  - $H = 16$, $W = 16$, $\\delta = (3,-5)$, 架构：一个核大小为 $3 \\times 3$ 的循环互相关层，加上一个常数偏置，然后是一个整流线性单元，种子 $s = 0$。\n- 案例 B（层的组合）：\n  - $H = 16$, $W = 16$, $\\delta = (7,2)$, 架构：两个循环互相关层，核大小均为 $3 \\times 3$，每个层都有自己的常数偏置，在第一层和第二层之后都应用一个整流线性单元，种子 $s = 1$。\n- 案例 C（零填充下的失败案例）：\n  - $H = 16$, $W = 16$, $\\delta = (5,4)$, 架构：一个核大小为 $3 \\times 3$ 的零填充互相关层（非循环），加上一个常数偏置，然后是一个整流线性单元，种子 $s = 2$。\n- 案例 D（偏置不变性，大平移）：\n  - $H = 16$, $W = 16$, $\\delta = (15,-16)$, 架构：一个核大小为 $3 \\times 3$ 的循环互相关层，加上一个非零常数偏置，然后是一个整流线性单元，种子 $s = 3$。\n- 案例 E（逐点线性头）：\n  - $H = 16$, $W = 16$, $\\delta = (1,1)$, 架构：一个核大小为 $3 \\times 3$ 的循环互相关层，然后是一个整流线性单元，再然后是一个实现为 $1 \\times 1$ 循环互相关并带有自己偏置的逐点线性层，种子 $s = 4$。\n- 案例 F（扩张循环层）：\n  - $H = 16$, $W = 16$, $\\delta = (2,-3)$, 架构：一个循环互相关层，其核是通过将零插入到一个基础 $3 \\times 3$ 核中（扩张因子 $d = 2$）来构建的，从而得到一个有效的 $5 \\times 5$ 核大小，加上一个常数偏置，然后是一个整流线性单元，种子 $s = 5$。\n\n程序输入和输出：\n- 没有外部输入。你的程序必须在内部构建指定的六个测试用例，使用提供的种子生成随机输入和核，以容差 $\\epsilon = 10^{-9}$ 评估每个案例的等变关系，并将六个布尔结果聚合成一行输出，格式为一个用方括号括起来的逗号分隔列表，例如 $[\\text{True},\\text{False},\\dots]$，其中恰好有六个条目且没有额外的空格。", "solution": "该问题要求对几种由标准组件构建的小型神经网络架构的平移等变性进行分析。如果对于任何有效的输入信号 $x$ 和任何平移向量 $\\delta$，关系式 $f(T_{\\delta} x) = T_{\\delta} f(x)$ 都成立，那么函数 $f$ 就是平移等变的。在这里，$T_{\\delta}$ 是在大小为 $H \\times W$ 的有限二维网格上定义的循环平移算子。该网格由索引 $\\{0, \\dots, H-1\\} \\times \\{0, \\dots, W-1\\}$ 定义。\n\n平移算子 $T_{\\delta}$（其中 $\\delta = (\\delta_y, \\delta_x)$）定义为 $(T_{\\delta} x)[i,j] = x[(i-\\delta_y) \\bmod H, (j-\\delta_x) \\bmod W]$。此操作将信号 $x$ 的内容按向量 $\\delta$ 进行移位，并采用周期性边界条件。\n\n网络 $f$ 被构建为原始操作的复合，$f = f_L \\circ f_{L-1} \\circ \\dots \\circ f_1$。平移等变性在复合下是保持的。如果两个函数 $g$ 和 $h$ 各自都是平移等变的，它们的复合 $g \\circ h$ 也是平移等变的。这可以如下证明：\n$$ (g \\circ h)(T_{\\delta} x) = g(h(T_{\\delta} x)) $$\n根据 $h$ 的等变性，$h(T_{\\delta} x) = T_{\\delta} h(x)$。代入此式可得：\n$$ g(T_{\\delta} h(x)) $$\n根据 $g$ 的等变性，应用于输入 $y = h(x)$：\n$$ g(T_{\\delta} y) = T_{\\delta} g(y) \\implies g(T_{\\delta} h(x)) = T_{\\delta} g(h(x)) = T_{\\delta} (g \\circ h)(x) $$\n因此，我们有 $(g \\circ h)(T_{\\delta} x) = T_{\\delta} (g \\circ h)(x)$。要确定一个网络 $f$ 是否是平移等变的，我们必须分析其每个构成层。\n\n构建模块包括：\n1. 循环互相关\n2. 加上一个常数偏置\n3. 逐点非线性\n4. 零填充互相关（用于一个反例）\n\n让我们分析每个组件的平移等变性。\n\n1. **循环互相关 ($C_k$)**:\n令操作为 $y = x \\star_{\\mathrm{circ}} k$。输出由以下公式给出：\n$$ y[i,j] = (x \\star_{\\mathrm{circ}} k)[i,j] = \\sum_{m=0}^{k_h-1}\\sum_{n=0}^{k_w-1} x\\big((i+m-c_h) \\bmod H, (j+n-c_w) \\bmod W\\big)\\, k[m,n] $$\n其中 $c_h = \\lfloor k_h/2 \\rfloor$ 且 $c_w = \\lfloor k_w/2 \\rfloor$。\n为了测试等变性，我们比较 $T_{\\delta}(x \\star_{\\mathrm{circ}} k)$ 和 $(T_{\\delta} x) \\star_{\\mathrm{circ}} k$。\n\n首先，让我们计算平移后的输出 $(T_{\\delta} y)[i,j]$：\n$$ (T_{\\delta} y)[i,j] = y[(i-\\delta_y) \\bmod H, (j-\\delta_x) \\bmod W] $$\n代入 $y$ 的定义：\n$$ (T_{\\delta} y)[i,j] = \\sum_{m, n} x\\Big(\\big(((i-\\delta_y) \\bmod H) + m-c_h\\big) \\bmod H, \\big(((j-\\delta_x) \\bmod W) + n-c_w\\big) \\bmod W\\Big) \\, k[m,n] $$\n由于模运算的性质，这可以简化为：\n$$ (T_{\\delta} y)[i,j] = \\sum_{m, n} x\\big((i-\\delta_y+m-c_h) \\bmod H, (j-\\delta_x+n-c_w) \\bmod W\\big) \\, k[m,n] $$\n\n接下来，让我们计算平移后输入的输出，$y' = (T_{\\delta} x) \\star_{\\mathrm{circ}} k$：\n$$ y'[i,j] = \\sum_{m,n} (T_{\\delta} x)\\big((i+m-c_h) \\bmod H, (j+n-c_w) \\bmod W\\big) \\, k[m,n] $$\n使用 $T_{\\delta}$ 的定义，$(T_{\\delta} x)[a,b] = x[(a-\\delta_y)\\bmod H, (b-\\delta_x)\\bmod W]$，我们得到：\n$$ y'[i,j] = \\sum_{m,n} x\\Big(\\big((i+m-c_h)\\bmod H - \\delta_y\\big) \\bmod H, \\big((j+n-c_w)\\bmod W - \\delta_x\\big) \\bmod W\\Big) \\, k[m,n] $$\n这再次简化为：\n$$ y'[i,j] = \\sum_{m,n} x\\big((i+m-c_h-\\delta_y) \\bmod H, (j+n-c_w-\\delta_x) \\bmod W\\big) \\, k[m,n] $$\n$(T_{\\delta} y)[i,j]$ 和 $y'[i,j]$ 的表达式是相同的。因此，循环互相关是一个平移等变的操作。只要边界条件是循环的，无论核的值或大小如何（包括 $1 \\times 1$ 的核和扩张核），这个结论都成立。\n\n2. **常数偏置加法 ($B_b$)**:\n令操作为 $y[i,j] = u[i,j] + b$。\n平移后的输出是 $(T_{\\delta} y)[i,j] = y[(i-\\delta_y)\\bmod H, (j-\\delta_x)\\bmod W] = u[(i-\\delta_y)\\bmod H, (j-\\delta_x)\\bmod W] + b$。\n平移后输入的输出是 $(T_{\\delta} u + b)[i,j] = (T_{\\delta} u)[i,j] + b = u[(i-\\delta_y)\\bmod H, (j-\\delta_x)\\bmod W] + b$。\n这两个表达式是相同的。因此，加上一个常数偏置是一个平移等变的操作。\n\n3. **逐点非线性 ($\\Sigma$)**:\n令操作为 $y[i,j] = \\sigma(u[i,j])$，其中 $\\sigma$ 是一个独立应用于每个元素的函数。\n平移后的输出是 $(T_{\\delta} y)[i,j] = y[(i-\\delta_y)\\bmod H, (j-\\delta_x)\\bmod W] = \\sigma\\big(u[(i-\\delta_y)\\bmod H, (j-\\delta_x)\\bmod W]\\big)$。\n平移后输入的输出是 $\\sigma(T_{\\delta} u)[i,j] = \\sigma\\big((T_{\\delta} u)[i,j]\\big) = \\sigma\\big(u[(i-\\delta_y)\\bmod H, (j-\\delta_x)\\bmod W]\\big)$。\n这两个表达式是相同的。任何逐点操作，包括整流线性单元（ReLU），都是平移等变的。\n\n4. **零填充互相关 ($C'_k$)**:\n此操作的定义与循环互相关类似，但来自网格 $\\{0, \\dots, H-1\\} \\times \\{0, \\dots, W-1\\}$ 外部的输入被视为零。这破坏了网格的周期性对称性。考虑一个输入信号 $x$，它在除边界附近一个点（例如 $x[0,0]=1$）之外的所有地方都为零。输出 $y = C'_k(x)$ 将呈现一个由核 $k$ 决定的模式。现在考虑一个平移后的输入 $x' = T_\\delta x$。如果 $\\delta$ 使得非零元素从边界移到网格内部，那么互相关将使用邻近的信号值（在本例中为零）进行计算，而不是填充的零。得到的输出模式 $y' = C'_k(x')$ 在形状上将与 $y$ 相同。然而，如果我们计算原始输出的平移 $T_\\delta y$，结果将是原始输出模式的简单移位，包括由边界引起的任何伪影。这两个结果 $y'$ 和 $T_\\delta y$ 通常不匹配，因为填充与信号的相互作用方式取决于其相对于边界的位置。因此，带零填充的互相关不是平移等变的。\n\n**测试案例分析：**\n\n-   **案例 A**: `circ_corr` $\\to$ `bias` $\\to$ `relu`。这是在循环边界条件下三个平移等变操作的复合。因此，得到的网络是**等变的**。\n-   **案例 B**: `(circ_corr - bias - relu)` $\\to$ `(circ_corr - bias - relu)`。这是两个块的复合，每个块如案例 A 所述是等变的。等变函数的复合是等变的。该网络是**等变的**。\n-   **案例 C**: `zero_pad_corr` $\\to$ `bias` $\\to$ `relu`。该网络以一个零填充互相关层开始，该层不是平移等变的。单个非等变层的存在使得整个网络**不是等变的**。\n-   **案例 D**: `circ_corr` $\\to$ `bias` $\\to$ `relu`。这与案例 A 的架构相同。平移向量 $\\delta = (15,-16) \\equiv (-1,0) \\pmod{16}$ 和非零偏置的具体值不改变等变性的基本属性。该网络是**等变的**。\n-   **案例 E**: `circ_corr(3x3)` $\\to$ `relu` $\\to$ `circ_corr(1x1)` $\\to$ `bias`。一个 $1 \\times 1$ 的互相关是逐点缩放，这是一个平移等变操作。所有其他组件也是等变的。该网络是等变块的复合，因此是**等变的**。\n-   **案例 F**: `dilated_circ_corr` $\\to$ `bias` $\\to$ `relu`。扩张循环互相关是循环互相关的一个特例，其中核具有插入零的稀疏结构。循环互相关等变性的证明与核的具体值无关，仅取决于循环求和。因此，该层也是等变的。该网络是**等变的**。\n\n测试套件的预期布尔结果是：[True, True, False, True, True, True]。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import correlate2d\n\ndef solve():\n    \"\"\"\n    Solves the problem by numerically testing the translation equivariance\n    of different network architectures specified in the test cases.\n    \"\"\"\n\n    # --- Helper Functions for Network Layers ---\n\n    def circular_translation(x, delta):\n        \"\"\"Applies circular translation T_delta to a 2D array x.\"\"\"\n        # delta = (delta_y, delta_x)\n        # np.roll shifts array elements. A shift of (dy, dx) moves the\n        # element at (r, c) to (r+dy, c+dx).\n        # We want (T_delta x)[i,j] = x[i-delta_y, j-delta_x].\n        # This corresponds to shifting the content by delta.\n        return np.roll(x, shift=delta, axis=(0, 1))\n\n    def circular_cross_correlation(x, k):\n        \"\"\"Performs circular cross-correlation.\"\"\"\n        return correlate2d(x, k, mode='same', boundary='wrap')\n\n    def zero_padding_cross_correlation(x, k):\n        \"\"\"Performs zero-padding cross-correlation.\"\"\"\n        return correlate2d(x, k, mode='same', boundary='fill', fillvalue=0)\n\n    def relu(x):\n        \"\"\"Applies the Rectified Linear Unit pointwise.\"\"\"\n        return np.maximum(x, 0)\n    \n    def create_dilated_kernel(base_kernel, dilation_factor):\n        \"\"\"Creates a dilated kernel from a base kernel.\"\"\"\n        kh_base, kw_base = base_kernel.shape\n        d = dilation_factor\n        \n        # Effective kernel size calculation\n        kh_dil = kh_base + (kh_base - 1) * (d - 1)\n        kw_dil = kw_base + (kw_base - 1) * (d - 1)\n        \n        dilated_kernel = np.zeros((kh_dil, kw_dil))\n        \n        for i in range(kh_base):\n            for j in range(kw_base):\n                dilated_kernel[i * d, j * d] = base_kernel[i, j]\n                \n        return dilated_kernel\n\n    # --- Test Case Definitions ---\n    \n    test_cases = [\n        # Case A: (H, W, delta, architecture, kernel_sizes, seed)\n        (16, 16, (3, -5), 'A', [(3, 3)], 0),\n        # Case B\n        (16, 16, (7, 2), 'B', [(3, 3), (3, 3)], 1),\n        # Case C\n        (16, 16, (5, 4), 'C', [(3, 3)], 2),\n        # Case D\n        (16, 16, (15, -16), 'D', [(3, 3)], 3),\n        # Case E\n        (16, 16, (1, 1), 'E', [(3, 3), (1, 1)], 4),\n        # Case F\n        (16, 16, (2, -3), 'F', [(3, 3)], 5),\n    ]\n\n    results = []\n    epsilon = 1e-9\n\n    for case in test_cases:\n        H, W, delta, arch, kernel_sizes, seed = case\n        \n        # Initialize RNG for reproducibility for each case\n        np.random.seed(seed)\n        \n        # Generate random input\n        x = np.random.standard_normal((H, W))\n\n        # Define the network function f(x) for the current architecture\n        if arch == 'A':\n            k = np.random.standard_normal(kernel_sizes[0])\n            b = np.random.standard_normal()\n            f = lambda z: relu(circular_cross_correlation(z, k) + b)\n        \n        elif arch == 'B':\n            k1 = np.random.standard_normal(kernel_sizes[0])\n            b1 = np.random.standard_normal()\n            k2 = np.random.standard_normal(kernel_sizes[1])\n            b2 = np.random.standard_normal()\n            f = lambda z: relu(circular_cross_correlation(relu(circular_cross_correlation(z, k1) + b1), k2) + b2)\n            \n        elif arch == 'C':\n            k = np.random.standard_normal(kernel_sizes[0])\n            b = np.random.standard_normal()\n            f = lambda z: relu(zero_padding_cross_correlation(z, k) + b)\n            \n        elif arch == 'D':\n            k = np.random.standard_normal(kernel_sizes[0])\n            b = np.random.standard_normal()\n            f = lambda z: relu(circular_cross_correlation(z, k) + b)\n\n        elif arch == 'E':\n            k1 = np.random.standard_normal(kernel_sizes[0])\n            k2 = np.random.standard_normal(kernel_sizes[1])\n            b2 = np.random.standard_normal()\n            f = lambda z: circular_cross_correlation(relu(circular_cross_correlation(z, k1)), k2) + b2\n\n        elif arch == 'F':\n            k_base = np.random.standard_normal(kernel_sizes[0])\n            k_dilated = create_dilated_kernel(k_base, dilation_factor=2)\n            b = np.random.standard_normal()\n            f = lambda z: relu(circular_cross_correlation(z, k_dilated) + b)\n            \n        # --- Equivariance Test ---\n        # LHS: f(T_delta(x))\n        x_translated = circular_translation(x, delta)\n        lhs = f(x_translated)\n\n        # RHS: T_delta(f(x))\n        fx = f(x)\n        rhs = circular_translation(fx, delta)\n        \n        # Compare LHS and RHS\n        max_abs_diff = np.max(np.abs(lhs - rhs))\n        is_equivariant = max_abs_diff = epsilon\n        results.append(is_equivariant)\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3126241"}, {"introduction": "关于边界条件的理论概念会产生切实可见的实际影响。在这个编程练习中，您将通过在周期性图像上应用卷积操作，直接比较零填充和循环填充的效果 [@problem_id:3111157]。通过亲手实现并测量产生的误差，您将直观地理解不恰当的边界处理如何引入不必要的伪影，从而深刻体会到为何这些看似微小的选择至关重要。", "problem": "您将研究在卷积神经网络（CNN）中通常称为卷积的离散二维运算中，填充选择所产生的影响。在 CNN 的实践中，所使用的运算是二维离散互相关，它使用一个有限支撑的核，应用于输入图像，并根据给定的填充规则进行评估。您的任务是在合成的周期性纹理上，比较半径为 $p$ 的循环填充与零填充，并检验循环填充可以减少边界伪影的假设。您必须编写一个完整且可运行的程序，为每个测试用例计算一个布尔结果，并按照下文的规定，将它们作为单个列表输出到一行中。\n\n基本原理和定义：\n- 令 $I \\in \\mathbb{R}^{N \\times N}$ 为一个离散图像，由像素坐标 $(i,j)$ 索引，其中 $i \\in \\{0,\\dots,N-1\\}$ 且 $j \\in \\{0,\\dots,N-1\\}$。\n- 令 $K \\in \\mathbb{R}^{k \\times k}$ 为一个有限支撑的核，其中 $k$ 为奇数，并定义核的半宽为 $p = \\lfloor k/2 \\rfloor$。\n- 图像 $I$ 与核 $K$ 的 CNN 互相关（在实践中常被称为卷积），记为 $O = I \\star K$，在像素 $(i,j)$ 处定义为\n$$\nO[i,j] \\;=\\; \\sum_{u=-p}^{p} \\sum_{v=-p}^{p} K[u+p,v+p] \\cdot \\widetilde{I}[i+u,\\, j+v],\n$$\n其中 $\\widetilde{I}$ 的扩展规则取决于填充方案：\n    - 零填充：对于任何在 $\\{0,\\dots,N-1\\} \\times \\{0,\\dots,N-1\\}$ 之外的 $(x,y)$，设置 $\\widetilde{I}[x,y] = 0$。\n    - 循环填充：将索引解释为模 $N$，即 $\\widetilde{I}[x,y] = I[x \\bmod N,\\, y \\bmod N]$。\n- 这里的周期性纹理是一个函数 $I$，它由离散正弦函数构建而成，其参数是 $2\\pi/N$ 的整数倍，因此 $I$ 在边长为 $N$ 的离散环面上满足周期性边界条件。\n- 定义两个数组 $A,B \\in \\mathbb{R}^{N \\times N}$ 在掩码 $M \\in \\{0,1\\}^{N \\times N}$ 上的均方误差（MSE）为\n$$\n\\mathrm{MSE}_M(A,B) \\;=\\; \n\\begin{cases}\n\\frac{1}{m} \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} M[i,j]\\;\\big(A[i,j]-B[i,j]\\big)^2,  \\text{if } m = \\sum M[i,j]  0,\\\\\n0,  \\text{if } m = 0.\n\\end{cases}\n$$\n- 定义宽度为 $p$ 的边界环形掩码为 $M_{\\mathrm{bdry}}[i,j] = 1$ 当 $i \\in \\{0,\\dots,p-1\\} \\cup \\{N-p,\\dots,N-1\\}$ 或 $j \\in \\{0,\\dots,p-1\\} \\cup \\{N-p,\\dots,N-1\\}$ 时，否则 $M_{\\mathrm{bdry}}[i,j] = 0$。定义内部掩码为 $M_{\\mathrm{int}} = 1 - M_{\\mathrm{bdry}}$。\n\n待检验的假设：\n- 对于周期性纹理 $I$，循环填充与在离散环面上的预期计算相匹配，因此相对于零填充可以减少边界伪影。在操作上，对于相同的 $I$ 和 $K$：\n    - 零填充输出相对于循环填充输出的边界环形均方误差，严格大于循环填充输出相对于其自身的边界环形均方误差。\n    - 在内部区域，两种填充方案都应与环面计算一致，因此内部均方误差在数值上应可忽略不计。\n\n程序要求：\n- 使用以下公式构建尺寸为 $N \\times N$ 的合成周期性纹理 $I$\n$$\nI[i,j] \\;=\\; a_1 \\sin\\!\\Big(\\tfrac{2\\pi f_1}{N}\\, i\\Big) \\;+\\; a_2 \\cos\\!\\Big(\\tfrac{2\\pi f_2}{N}\\, j\\Big) \\;+\\; a_3 \\sin\\!\\Big(\\tfrac{2\\pi}{N}\\,(f_3 i + f_4 j)\\Big),\n$$\n其中的振幅 $a_1,a_2,a_3$ 和整数频率 $f_1,f_2,f_3,f_4$ 在下面的每个测试用例中指定。\n- 对于每个测试用例，计算三个输出：\n    - $T$：使用循环填充计算的参考输出（这代表在离散环面上的预期操作）。\n    - $C$：使用循环填充计算的输出（与用于 $T$ 的算子相同）。\n    - $Z$：使用零填充计算的输出。\n- 对于每个测试用例，使用上面定义的宽度为 $p=\\lfloor k/2 \\rfloor$ 的边界和内部掩码，计算四个均方误差：$\\mathrm{MSE}_{\\mathrm{bdry}}(Z,T)$、$\\mathrm{MSE}_{\\mathrm{bdry}}(C,T)$、$\\mathrm{MSE}_{\\mathrm{int}}(Z,T)$ 和 $\\mathrm{MSE}_{\\mathrm{int}}(C,T)$。\n- 当且仅当以下两个条件都成立时，将测试用例的布尔结果判定为真：\n    - 边界伪影减少：$\\mathrm{MSE}_{\\mathrm{bdry}}(Z,T)  \\mathrm{MSE}_{\\mathrm{bdry}}(C,T) + \\varepsilon$。\n    - 内部一致性：$\\mathrm{MSE}_{\\mathrm{int}}(Z,T) \\le \\varepsilon$ 且 $\\mathrm{MSE}_{\\mathrm{int}}(C,T) \\le \\varepsilon$。\n这里的 $\\varepsilon$ 是一个小的数值公差，您必须将其设置为一个合理的固定值（例如，$\\varepsilon = 10^{-12}$）。\n\n测试套件（为覆盖范围设计的三个案例）：\n- 案例 1（理想路径，较大图像，平滑核）：\n    - $N = 64$。\n    - 核尺寸 $k=5$ 且填充半径 $p=2$。\n    - 核 $K$ 是一个归一化的盒式滤波器：对于所有的 $u,v \\in \\{-2,-1,0,1,2\\}$，设置 $K[u+p,v+p] = 1/25$。\n    - 纹理参数：$a_1 = 0.6$, $a_2 = 0.35$, $a_3 = 0.25$, $f_1 = 4$, $f_2 = 7$, $f_3 = 9$, $f_4 = 5$。\n- 案例 2（不同核类型，中等图像）：\n    - $N = 17$。\n    - 核尺寸 $k=3$ 且填充半径 $p=1$。\n    - 核 $K$ 是 $3 \\times 3$ 的离散拉普拉斯算子\n    $$\n    K \\;=\\; \\begin{bmatrix}\n    0  -1  0\\\\\n    -1  4  -1\\\\\n    0  -1  0\n    \\end{bmatrix}.\n    $$\n    - 纹理参数：$a_1 = 0.5$, $a_2 = 0.4$, $a_3 = 0.3$, $f_1 = 3$, $f_2 = 5$, $f_3 = 2$, $f_4 = 1$。\n- 案例 3（边界主导场景，小图像，同尺寸核）：\n    - $N = 5$。\n    - 核尺寸 $k=5$ 且填充半径 $p=2$。\n    - 核 $K$ 是与案例 1 中相同的归一化盒式滤波器。\n    - 纹理参数：$a_1 = 0.75$, $a_2 = 0.25$, $a_3 = 0.5$, $f_1 = 1$, $f_2 = 2$, $f_3 = 1$, $f_4 = 1$。\n\n要求的最终输出格式：\n- 您的程序应生成一行输出，其中包含三个测试用例的布尔结果，格式为方括号括起来的逗号分隔列表，没有空格，并按案例 1、2、3 的顺序排列。例如：$[{\\tt True},{\\tt False},{\\tt True}]$。\n\n角度单位和物理单位：\n- 三角函数内部使用的所有角度都以弧度为单位。\n- 没有物理单位；所有量都是无量纲的实数。\n\n约束：\n- 您必须在代码中直接实现这些操作，并且不得依赖外部文件或用户输入。除了 Python 标准库之外，唯一允许的库是在执行环境中指定的库。公差 $\\varepsilon$ 必须是固定的，并且对所有案例都相同。", "solution": "该问题要求研究填充对二维离散互相关运算的影响，该运算在卷积神经网络（CNN）的背景下通常被称为卷积。我们被要求检验这样一个假设：对于具有周期性边界条件的信号，循环填充在减轻边界伪影方面优于零填充。\n\n该假设的理论基础在于离散傅里叶变换（DFT）的性质。离散卷积定理指出，空间域中的循环卷积等同于频域中的逐元素乘积。具体来说，如果 $O = I \\circledast K$（其中 $\\circledast$ 表示循环卷积），那么 $\\mathcal{F}(O) = \\mathcal{F}(I) \\odot \\mathcal{F}(K)$，其中 $\\mathcal{F}$ 是离散傅里叶变换，$\\odot$ 是哈达玛（逐元素）积。如问题中所定义的，周期性纹理可以由其离散傅里叶频谱完美表示。使用循环填充实现的循环卷积，尊重信号的周期性，并在离散环面 $\\mathbb{Z}_N \\times \\mathbb{Z}_N$ 上正确计算该运算。相比之下，零填充通过用零包围信号，在边界处有效地截断了信号，当边界处的信号值非零时，这会引入高频伪影。这种不连续性破坏了信号固有的周期性。\n\n问题将该运算指定为互相关：\n$$\nO[i,j] \\;=\\; \\sum_{u=-p}^{p} \\sum_{v=-p}^{p} K[u+p,v+p] \\cdot \\widetilde{I}[i+u,\\, j+v]\n$$\n其中 $k$ 是核大小，$p = \\lfloor k/2 \\rfloor$ 是核的半宽，$\\widetilde{I}$ 是填充后的输入图像。离散卷积会在求和中使用 $\\widetilde{I}[i-u, j-v]$。然而，对于一个点对称的核 $K$，即 $K[u+p, v+p] = K[-u+p, -v+p]$，互相关和卷积的运算是相同的。所有三个测试用例中使用的核——归一化的盒式滤波器和离散拉普拉斯算子——确实是对称的。因此，从卷积定理推导出的逻辑是直接适用的。\n\n检验该假设的方法如下：\n1.  **生成参考输出 $T$**：这是使用循环填充计算的。它代表了在离散环面上执行互相关的基准真相（ground truth），对于周期性输入信号 $I$ 来说，这是数学上理想的运算。\n2.  **生成测试输出**：我们计算两个输出：使用循环填充的 $C$ 和使用零填充的 $Z$。根据定义，$C$ 将与 $T$ 相同。\n3.  **评估性能**：我们使用均方误差（MSE）将 $Z$ 与参考 $T$ 进行比较，该比较分为两个区域：宽度为 $p$ 的边界环和内部区域。均方误差定义为：\n    $$\n    \\mathrm{MSE}_M(A,B) \\;=\\; \\frac{1}{\\sum M} \\sum_{i,j} M[i,j]\\;\\big(A[i,j]-B[i,j]\\big)^2\n    $$\n    其中 $M$ 是边界掩码 $M_{\\mathrm{bdry}}$ 或内部掩码 $M_{\\mathrm{int}}$。\n4.  **假设验证**：对于给定的测试用例，如果满足由小公差 $\\varepsilon=10^{-12}$ 控制的两个条件，则该假设被认为是真的：\n    a. **边界伪影减少**：零填充在边界区域的误差必须显著大于循环填充的误差。由于循环填充的误差 $\\mathrm{MSE}_{\\mathrm{bdry}}(C,T)$ 根据定义为零（在机器精度范围内），这可以简化为 $\\mathrm{MSE}_{\\mathrm{bdry}}(Z,T)  \\varepsilon$。\n    b. **内部一致性**：在远离边界的区域，两种填充方法应该产生相同的结果，因为核的支撑域没有超出图像的原始域。因此，两种填充方案在内部的误差都必须是可忽略的：$\\mathrm{MSE}_{\\mathrm{int}}(Z,T) \\le \\varepsilon$ 且 $\\mathrm{MSE}_{\\mathrm{int}}(C,T) \\le \\varepsilon$。由于 $\\mathrm{MSE}_{\\mathrm{int}}(C,T) = 0$，这实际上是在测试 $\\mathrm{MSE}_{\\mathrm{int}}(Z,T) \\le \\varepsilon$ 是否成立。\n\n该实现将首先定义用于生成周期性纹理 $I$、掩码 $M_{\\mathrm{bdry}}$ 和 $M_{\\mathrm{int}}$ 以及计算 MSE 的函数。一个核心函数将直接实现互相关求和，以适应 `'circular'`（循环）或 `'zero'`（零）填充逻辑。每个测试用例将通过生成所需的输入（$I, K$）、计算输出（$T, Z$）、计算四个指定的 MSE 值并应用布尔决策逻辑来处理。\n\n每个测试用例的具体参数如下：\n\n**案例 1：** $N=64, k=5, p=2$。核是一个 $5 \\times 5$ 的归一化盒式滤波器（$K_{ij} = 1/25$）。纹理是参数为 $a_1=0.6, a_2=0.35, a_3=0.25, f_1=4, f_2=7, f_3=9, f_4=5$ 的正弦函数之和。我们预期该假设成立，因为图像相对于核来说很大，这在边界和内部区域之间提供了明确的区分。\n\n**案例 2：** $N=17, k=3, p=1$。核是一个 $3 \\times 3$ 的离散拉普拉斯算子。纹理参数为 $a_1=0.5, a_2=0.4, a_3=0.3, f_1=3, f_2=5, f_3=2, f_4=1$。这个案例在一个较小的、素数维度的图像上测试了一种不同类型的核（高通滤波器）。基本原理保持不变，所以我们预计该假设会成立。\n\n**案例 3：** $N=5, k=5, p=2$。核同样是 $5 \\times 5$ 的盒式滤波器。纹理参数为 $a_1=0.75, a_2=0.25, a_3=0.5, f_1=1, f_2=2, f_3=1, f_4=1$。这是一个极端情况，其中核的支撑尺寸 $k$ 等于图像维度 $N$。内部区域仅包含位于 $(2,2)$ 的单个像素，而图像的其余部分被视为边界。这为边界效应提供了严格的测试。对于任何输出像素，在循环填充下，核将“环绕”图像；而在零填充下，它将与一个大的零区域相互作用。这种差异应该很明显。对于零填充，在 $(2,2)$ 处的内部计算仍然涉及访问原始图像像素，因为对于 $u,v \\in \\{-2,\\dots,2\\}$，索引 $2+u$ 和 $2+v$ 仍在 $\\{0,\\dots,4\\}$ 的范围内。因此，我们预期内部误差可以忽略不计，而边界误差会很大，从而证实该假设。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by testing the hypothesis about padding in 2D cross-correlation.\n    \"\"\"\n    \n    # Define the tolerance epsilon as required.\n    epsilon = 1e-12\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 64, \"k\": 5,\n            \"kernel_type\": \"box\",\n            \"texture_params\": {\"a1\": 0.6, \"a2\": 0.35, \"a3\": 0.25, \"f1\": 4, \"f2\": 7, \"f3\": 9, \"f4\": 5}\n        },\n        {\n            \"N\": 17, \"k\": 3,\n            \"kernel_type\": \"laplacian\",\n            \"texture_params\": {\"a1\": 0.5, \"a2\": 0.4, \"a3\": 0.3, \"f1\": 3, \"f2\": 5, \"f3\": 2, \"f4\": 1}\n        },\n        {\n            \"N\": 5, \"k\": 5,\n            \"kernel_type\": \"box\",\n            \"texture_params\": {\"a1\": 0.75, \"a2\": 0.25, \"a3\": 0.5, \"f1\": 1, \"f2\": 2, \"f3\": 1, \"f4\": 1}\n        }\n    ]\n\n    results = []\n    \n    # Helper functions\n    \n    def create_periodic_texture(N, a1, a2, a3, f1, f2, f3, f4):\n        \"\"\"Generates the NxN periodic texture image.\"\"\"\n        i_coords, j_coords = np.meshgrid(np.arange(N), np.arange(N), indexing='ij')\n        term1 = a1 * np.sin(2 * np.pi * f1 * i_coords / N)\n        term2 = a2 * np.cos(2 * np.pi * f2 * j_coords / N)\n        term3 = a3 * np.sin(2 * np.pi * (f3 * i_coords + f4 * j_coords) / N)\n        return term1 + term2 + term3\n\n    def cross_correlate(I, K, padding_mode):\n        \"\"\"Performs 2D cross-correlation with specified padding.\"\"\"\n        N = I.shape[0]\n        k = K.shape[0]\n        p = k // 2\n        O = np.zeros_like(I)\n\n        for i in range(N):\n            for j in range(N):\n                accumulator = 0.0\n                for u in range(-p, p + 1):\n                    for v in range(-p, p + 1):\n                        src_i, src_j = i + u, j + v\n                        pixel_val = 0.0\n                        if padding_mode == 'circular':\n                            pixel_val = I[src_i % N, src_j % N]\n                        elif padding_mode == 'zero':\n                            if 0 = src_i  N and 0 = src_j  N:\n                                pixel_val = I[src_i, src_j]\n                        \n                        accumulator += K[u + p, v + p] * pixel_val\n                O[i, j] = accumulator\n        return O\n        \n    def calculate_mse(A, B, mask):\n        \"\"\"Calculates Mean Squared Error between A and B over a mask.\"\"\"\n        m = np.sum(mask)\n        if m == 0:\n            return 0.0\n        error = np.sum(mask * (A - B)**2) / m\n        return error\n\n    for case in test_cases:\n        N = case[\"N\"]\n        k = case[\"k\"]\n        p = k // 2\n        \n        # 1. Construct image and kernel\n        I = create_periodic_texture(N, **case[\"texture_params\"])\n        \n        if case[\"kernel_type\"] == \"box\":\n            K = np.full((k, k), 1.0 / (k * k))\n        elif case[\"kernel_type\"] == \"laplacian\":\n            K = np.array([[0, -1, 0], [-1, 4, -1], [0, -1, 0]], dtype=float)\n\n        # 2. Compute outputs T, C, and Z\n        # T is the reference, using circular padding\n        T = cross_correlate(I, K, 'circular')\n        # C is the test output with circular padding (will be identical to T)\n        C = T\n        # Z is the test output with zero padding\n        Z = cross_correlate(I, K, 'zero')\n\n        # 3. Define masks\n        M_bdry = np.zeros((N, N), dtype=int)\n        boundary_indices = list(range(p)) + list(range(N - p, N))\n        for i in range(N):\n            for j in range(N):\n                if i in boundary_indices or j in boundary_indices:\n                    M_bdry[i, j] = 1\n        M_int = 1 - M_bdry\n\n        # 4. Compute MSEs\n        mse_bdry_zt = calculate_mse(Z, T, M_bdry)\n        mse_bdry_ct = calculate_mse(C, T, M_bdry)\n        mse_int_zt = calculate_mse(Z, T, M_int)\n        mse_int_ct = calculate_mse(C, T, M_int)\n\n        # 5. Decide boolean result\n        cond1 = mse_bdry_zt > mse_bdry_ct + epsilon\n        cond2 = mse_int_zt = epsilon and mse_int_ct = epsilon\n        \n        result = cond1 and cond2\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3111157"}]}