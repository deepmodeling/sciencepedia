{"hands_on_practices": [{"introduction": "在分析萨维奇定理的证明之前，一个关键的预备步骤是量化计算的规模。本练习旨在让你推导出一个非确定性图灵机（NTM）在给定空间限制下可能达到的不同配置的总数 [@problem_id:1437894]。理解如何计算这个数字至关重要，因为配置总数的对数（$\\log N$）直接决定了模拟算法的递归深度，从而影响其整体空间复杂度。", "problem": "在计算复杂性理论的研究中，理解抽象机的资源使用情况是基础。考虑一台单带非确定性图灵机 (NTM)。在任意时刻，这样一台机器的格局由三个部分完全描述：其当前的内部状态、其工作带上写入的全部内容，以及其磁带头的当前位置。\n\n设该 NTM 拥有一个状态集 $Q$ 和一个磁带字母表 $\\Sigma$。对于大小为 $s$ 的输入，该机器被设计为具有空间复杂度 $f(s) = c \\log_2 s$，其中 $c$ 是一个正常数。这意味着对于任何大小为 $s$ 的输入，该机器在其工作带上最多使用 $f(s)$ 个单元格。\n\n推导一个简化的、明确的公式，用于计算该 NTM 可能处于的最大不同格局数。将你的答案表示为状态数 $|Q|$、磁带字母表大小 $|\\Sigma|$、常数 $c$ 和输入大小 $s$ 的函数。", "solution": "一个格局由以下几项确定：\n- 当前的内部状态（选择数：$|Q|$），\n- 工作带上可能被使用的单元格中的全部内容（最多 $f(s)$ 个单元格中的每一个都可以包含 $|\\Sigma|$ 个符号中的任意一个，得到 $|\\Sigma|^{f(s)}$ 种可能性），\n- 工作带上的磁带头位置（最多 $f(s)$ 种选择）。\n\n因此，由空间限制所允许的最大不同格局数是\n$$\nN_{\\max}(s)=|Q|\\cdot f(s)\\cdot |\\Sigma|^{f(s)}.\n$$\n当 $f(s)=c\\log_{2}(s)$ 时，上式变为\n$$\nN_{\\max}(s)=|Q|\\cdot c\\log_{2}(s)\\cdot |\\Sigma|^{c\\log_{2}(s)}.\n$$\n使用恒等式 $a^{\\log_{b}(x)}=x^{\\log_{b}(a)}$，并令 $a=|\\Sigma|$ 和 $b=2$，我们简化\n$$\n|\\Sigma|^{c\\log_{2}(s)}=s^{c\\log_{2}(|\\Sigma|)}.\n$$\n因此，一个明确的简化表达式为\n$$\nN_{\\max}(s)=|Q|\\cdot c\\log_{2}(s)\\cdot s^{c\\log_{2}(|\\Sigma|)}.\n$$", "answer": "$$\\boxed{|Q|\\cdot c\\log_{2}(s)\\cdot s^{c\\log_{2}(|\\Sigma|)}}$$", "id": "1437894"}, {"introduction": "萨维奇定理的核心是一种巧妙的分治算法，它通过递归地将计算路径对半分割来检查可达性。为了具体理解这一过程，亲手追踪算法的执行流程是最好的方法 [@problem_id:1437866]。本练习将带你深入该递归调用的内部，通过分析调用的层次结构，你会清晰地看到算法是如何利用“分而治之”的思想，以对数级别的递归深度来处理指数级别的路径长度的。", "problem": "在计算复杂性理论中，萨维奇定理使用一个递归算法来证明，该算法用于确定在一个非确定性计算中，构型 $C_{final}$ 是否可以从构型 $C_{initial}$ 到达。考虑该算法的一个版本 `REACH(C_1, C_2, k)`，如果构型 $C_2$ 可以在至多 $2^k$ 步内从 $C_1$ 到达，则该函数返回 `true`，否则返回 `false`。该算法定义如下：\n\n**算法：`REACH(C_1, C_2, k)`**\n1.  如果 $k=0$，检查是否有 $C_1 = C_2$ 或者 $C_2$ 能否在单步计算内从 $C_1$ 到达。如果是，则返回 `true`；否则返回 `false`。\n2.  如果 $k > 0$，遍历所有可能的中间构型 $C_{mid}$。对于每个 $C_{mid}$：\n    a. 调用 `REACH(C_1, C_{mid}, k-1)`。\n    b. 调用 `REACH(C_{mid}, C_2, k-1)`。\n    c. 如果这两个递归调用都返回 `true`，则停止并返回 `true`。\n3.  如果循环结束仍未找到这样的 $C_{mid}$，则返回 `false`。\n\n假设我们使用调用 `REACH(C_{start}, C_{accept}, 4)` 来检查起始构型 $C_{start}$ 和接受构型 $C_{accept}$ 之间在至多16步内的可达性。这个初始调用被认为是递归的第0层。由第0层调用直接进行的递归调用是第1层调用。由任何第1层调用直接进行的递归调用是第2层调用。\n\n以下哪个选项正确地描述了在第2层进行的所有递归调用的通用形式？在下述选项中，$C_i$、$C_j$ 和 $C_k$ 代表了搜索不同阶段的某个中间构型。\n\nA. `REACH(C_{start}, C_i, 2)` 和 `REACH(C_i, C_{accept}, 2)`\n\nB. `REACH(C_{start}, C_j, 2)`、`REACH(C_j, C_i, 2)`、`REACH(C_i, C_k, 2)` 和 `REACH(C_k, C_{accept}, 2)`\n\nC. `REACH(C_{start}, C_i, 3)` 和 `REACH(C_i, C_{accept}, 3)`\n\nD. `REACH(C_{start}, C_j, 4)` 和 `REACH(C_j, C_i, 4)`\n\nE. `REACH(C_{start}, C_{accept}, 2)`", "solution": "我们从第0层的调用开始，也就是初始调用 $REACH(C_{start}, C_{accept}, 4)$。由于 $k=4>0$，根据算法，它会遍历所有中间构型 $C_{i}$，并对每个 $C_{i}$ 进行两次参数为 $k-1=3$ 的递归调用。因此，由第0层生成的第1层调用具有以下确切形式：\n$$REACH(C_{start}, C_{i}, 3) \\quad \\text{和} \\quad REACH(C_{i}, C_{accept}, 3).$$\n\n在每个第1层的调用中，参数 $k=3>0$，因此它会再次遍历所有中间构型，并进行两次参数为 $k-1=2$ 的调用。因此，对于一个第1层的调用 $REACH(C_{start}, C_{i}, 3)$，它为所有中间构型 $C_{j}$ 生成的第2层调用是：\n$$REACH(C_{start}, C_{j}, 2) \\quad \\text{和} \\quad REACH(C_{j}, C_{i}, 2).$$\n同样地，对于一个第1层的调用 $REACH(C_{i}, C_{accept}, 3)$，它为所有中间构型 $C_{k}$ 生成的第2层调用是：\n$$REACH(C_{i}, C_{k}, 2) \\quad \\text{和} \\quad REACH(C_{k}, C_{accept}, 2).$$\n\n汇总由两类第1层调用产生的所有第2层调用，第2层的通用形式的完整集合是：\n$$REACH(C_{start}, C_{j}, 2), \\quad REACH(C_{j}, C_{i}, 2), \\quad REACH(C_i, C_{k}, 2), \\quad REACH(C_k, C_{accept}, 2),$$\n这与选项B相匹配。\n\n要理解为什么其他选项是错误的：\n- 选项A列出了 $REACH(C_{start}, C_i, 2)$ 和 $REACH(C_i, C_{accept}, 2)$，但在第2层，调用在每个第1层的分支内使用了新的中间构型 $C_j$ 和 $C_k$；选项A中的这对调用没有捕捉到跨分支的结构，也不是完整的集合。\n- 选项C使用了 $k=3$，这对应于第1层，而不是第2层。\n- 选项D使用了 $k=4$，这是第0层调用的参数，而不是第2层的。\n- 选项E是一个单一的特例调用，只有当某个中间构型等于 $C_{accept}$ 或 $C_{start}$ 时才可能发生，但它没有描述通用形式的完整集合。\n\n因此，正确选项是B。", "answer": "$$\\boxed{B}$$", "id": "1437866"}, {"introduction": "萨维奇定理的经典证明构建了一个算法来*判定*是否存在一条从初始配置到接受配置的路径，但它本身并不输出这条路径。本练习将挑战你思考一个更进一步的问题：我们能否在保持空间效率的同时，将这个判定算法修改为一个能够*构造*并输出完整计算路径的算法？[@problem_id:1437882] 通过分析这个扩展算法，你将体会到计算复杂性理论中一个深刻的思想，即如何利用判定问题的解来有效地解决其对应的搜索问题。", "problem": "考虑一台非确定性图灵机 (NTM)，它在长度为 $n$ 的输入上最多使用 $S(n)$ 空间，其中 $S(n) \\ge \\log n$。这台 NTM 的一个配置 (configuration) 可以通过其有限控制器的状态、工作带的内容以及磁带头的位置来描述。存储一个配置所需的总大小为 $O(S(n))$。\n\nSavitch 定理提供了一个确定性算法，用于判定一台 NTM 是否接受一个输入。该证明的核心是一个递归函数，我们称之为 `REACH(c1, c2, k)`，它判断配置 `c2` 是否可以在至多 $2^k$ 步内从配置 `c1` 到达。\n- 对于 $k=0$，它检查 `c1 = c2` 或者 `c1` 是否可以在单次转移中产生 `c2`。\n- 对于 $k>0$，它遍历所有可能的中间配置 `cm`，并递归地检查 `REACH(c1, cm, k-1)` 和 `REACH(cm, c2, k-1)` 是否都为真。\n最大递归深度 $k$ 被选择为 $O(S(n))$，并且这个 `REACH` 算法可以在一台确定性图灵机上使用 $O(S(n)^2)$ 的空间来实现。\n\n现在，让我们考虑一个修改后的任务：不仅仅是判断可达性，而是实际输出一整条接受计算路径（一个从起始配置 $c_{start}$ 到接受配置 $c_{accept}$ 的配置序列），每次打印一个配置。\n\n为了解决这个问题，提出了一个算法 `FINDPATH(c_start, c_accept)`。其操作如下：\n1. 它首先通过调用 `REACH(c_start, c_accept, k_max)` 来验证 $c_{accept}$ 是否可以从 $c_{start}$ 到达，其中 $k_{max}$ 的数量级为 $S(n)$。如果不可达，算法终止。\n2. 如果路径存在，它会打印起始配置 $c_{start}$。\n3. 然后它调用一个递归的辅助过程 `GENERATE_PATH(c_1, c_2, k)`。初始调用为 `GENERATE_PATH(c_start, c_accept, k_max)`。\n4. 过程 `GENERATE_PATH(c_1, c_2, k)` 被设计为打印路径段的剩余部分，即从紧随 $c_1$ 之后的配置到并包括 $c_2$ 的所有配置。其逻辑如下：\n    - 如果 $c_1$ 与 $c_2$ 相同，它立即返回。\n    - 如果 $k=0$，意味着 $c_2$ 在单步之后紧随 $c_1$。该过程打印 $c_2$ 并返回。\n    - 如果 $k>0$，它通过遍历所有可能性来搜索一个中间配置 $c_m$。对于找到的第一个使得 `REACH(c_1, c_m, k-1)` 和 `REACH(c_m, c_2, k-1)` 都返回真的 $c_m$，它执行两个连续的递归调用：`GENERATE_PATH(c_1, c_m, k-1)` 之后是 `GENERATE_PATH(c_m, c_2, k-1)`。在这些调用之后，它停止搜索中点并返回。\n\n整个 `FINDPATH` 算法关于 $S(n)$ 的最紧渐近（大O）空间复杂度是多少？\n\nA. $O(S(n))$\n\nB. $O(S(n) \\log S(n))$\n\nC. $O(S(n)^2)$\n\nD. $O(S(n)^3)$\n\nE. $O(S(n) \\cdot 2^{S(n)})$", "solution": "题目要求 `FINDPATH` 算法的空间复杂度。我们分析该算法的组成部分及其空间需求。\n\n`FINDPATH` 算法包含三个主要步骤：\n1. 一次对 `REACH(c_start, c_accept, k_max)` 的调用。\n2. 打印起始配置 $c_{start}$。\n3. 一次对 `GENERATE_PATH(c_start, c_accept, k_max)` 的调用。\n\n总空间复杂度将是这些步骤中任何一个所使用的最大空间，因为它们是按顺序执行的。\n\n步骤 1：`REACH` 的空间。\n问题描述指明，标准 `REACH` 算法在最大递归深度为 $k_{max} = O(S(n))$ 时，使用 $O(S(n)^2)$ 的空间。这是 Savitch 定理证明中的一个已知结果。`REACH(c1, c2, k)` 的空间复杂度是 $O(k \\cdot S(n))$。当 $k = k_{max} = O(S(n))$ 时，空间为 $O(S(n) \\cdot S(n)) = O(S(n)^2)$。\n\n步骤 2：打印所需的空间。\n打印单个配置 $c_{start}$ 需要将该配置保存在内存中，这需要 $O(S(n))$ 的空间。这小于步骤 1 所需的空间。\n\n步骤 3：`GENERATE_PATH` 的空间。\n这是分析中最复杂的部分。让我们将 `GENERATE_PATH` 表示为 `GP`。我们需要确定 `GP(c1, c2, k)` 的空间复杂度。\n\n设 `Space_GP(k)` 为调用递归参数为 $k$ 的 `GP` 所需的空间。\n`GP(c1, c2, k)` 的单个激活帧需要存储其参数（`c1`、`c2`、`k`）和局部变量（循环变量 `cm`）。存储两个配置和一个整数需要 $O(S(n)) + O(S(n)) + O(\\log k)$ 的空间。由于 $k=O(S(n))$ 且 $S(n) \\ge \\log n$，这可以简化为 $O(S(n))$。\n\n在 `GP(k)` 内部，算法顺序执行几个操作：\na. 它遍历 `cm`，这需要 $O(S(n))$ 的空间来存储当前的 `cm`。\nb. 对于每个 `cm`，它调用 `REACH(c1, cm, k-1)`。这次调用的空间是 $O((k-1)S(n))$。\nc. 然后它调用 `REACH(cm, c2, k-1)`。空间同样是 $O((k-1)S(n))$ 并且重用前一个 `REACH` 调用的空间。\nd. 如果两个 `REACH` 调用都成功，它会进行两次递归调用：`GP(c1, cm, k-1)` 和 `GP(cm, c2, k-1)`。这些调用也是顺序的，因此它们重用空间。\n\n`GP(k)` 的空间复杂度可以用一个递推关系来描述。总空间是当前帧的空间加上其任何顺序子过程所使用的最大空间。\n`Space_GP(k) = O(S(n)) + max(Space_REACH(k-1), Space_GP(k-1))`\n其中 `Space_REACH(k-1)` 是 `REACH` 调用所需的空间，为 $O((k-1)S(n))$。\n所以，`Space_GP(k) = O(S(n)) + max(O((k-1)S(n)), Space_GP(k-1))`。\n\n让我们通过考虑完整的调用栈来分析总空间使用情况。对 `GP(k_max)` 的一次调用可以导致一连串的递归调用：`GP(k_max) \\to GP(k_max-1) \\to \\dots \\to GP(0)`。这个递归的最大深度是 $k_{max}$。\n\n考虑执行在调用 `GP(j)` 内部的时刻，这个调用是由调用链 `GP(k_{max}) \\to \\dots \\to GP(j+1)` 发起的。\n此时，调用栈上有 $(k_{max} - j + 1)$ 个 `GP` 的激活帧。每个帧占用 $O(S(n))$ 的空间。因此，`GP` 帧的栈占用了 $(k_{max} - j + 1) \\cdot O(S(n))$ 的空间。\n\n在执行 `GP(j)` 时，算法会调用 `REACH(j-1)`。这个调用需要自己的栈空间，大小为 $O((j-1)S(n))$。这部分空间在现有调用栈之上分配。\n此刻使用的总空间是 `GP` 调用栈的空间与 `REACH` 调用空间之和：\n`TotalSpace(j) = (k_{max} - j + 1) \\cdot O(S(n)) + O((j-1)S(n))`\n\n让我们找到这个函数在 $j \\in \\{1, \\dots, k_{max}\\}$ 上的最大值。设 $C_1$ 和 $C_2$ 为来自大O表示法的常数。\n`TotalSpace(j) \\approx C_1(k_{max} - j + 1)S(n) + C_2(j - 1)S(n)`\n`TotalSpace(j) \\approx (C_1 k_{max} + C_1 - C_2) S(n) + (C_2 - C_1)j S(n)`\n这是一个关于 $j$ 的线性函数。最大值必定出现在定义域的边界，即 $j=1$ 或 $j=k_{max}$。\n\n- 在 $j=k_{max}$ 时： `GP` 栈很浅（深度为1）。调用的是 `GP(k_{max})`，它会调用 `REACH(k_{max}-1)`。\n`TotalSpace(k_{max}) = O(S(n)) + O((k_{max}-1)S(n)) = O(k_{max} S(n))`。\n\n- 在 $j=1$ 时：`GP` 栈很深（深度为 $k_{max}$）。调用的是 `GP(1)`，它会调用 `REACH(0)`。\n`TotalSpace(1) = k_{max} \\cdot O(S(n)) + O(0 \\cdot S(n)) = O(k_{max} S(n))`。\n\n在这两种情况下，以及对于所有介于两者之间的 $j$，总空间复杂度都受 $O(k_{max} S(n))$ 的限制。\n由于 $k_{max} = O(S(n))$，`GENERATE_PATH` 过程的空间复杂度是 $O(S(n) \\cdot S(n)) = O(S(n)^2)$。\n\n结论：\n- 步骤 1 (`REACH`) 的空间：$O(S(n)^2)$。\n- 步骤 3 (`GENERATE_PATH`) 的空间：$O(S(n)^2)$。\n\n`FINDPATH` 的总体空间复杂度是其顺序步骤所用空间的最大值，即 $\\max(O(S(n)^2), O(S(n)^2)) = O(S(n)^2)$。该算法成功地重构并打印了路径，而没有使用指数级的空间，因为它是在运行中动态地重新生成路径段，而不是存储它们。空间复杂度与原始的判定算法保持相同。\n\n因此，最紧的渐近空间复杂度是 $O(S(n)^2)$。这与选项 C 相符。", "answer": "$$\\boxed{C}$$", "id": "1437882"}]}