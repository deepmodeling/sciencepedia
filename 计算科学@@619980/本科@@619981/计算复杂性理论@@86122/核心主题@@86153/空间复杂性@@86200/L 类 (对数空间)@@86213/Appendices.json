{"hands_on_practices": [{"introduction": "我们的第一个练习是计算复杂性中的一个经典问题，它完美地展示了对数空间算法的核心机制。我们将要解决的问题是判断一个由'0'和'1'组成的字符串是否具有 `$0^n1^n$` 的形式。这个练习将教会你如何在只读输入上使用工作带来维护一个二进制计数器，这是在有限内存下进行计算的一项基本技能。[@problem_id:1452636]", "problem": "考虑一个用于数据验证协议的简化模型。一个数据包流由一个二进制字符串表示。一个有效的“突发”（burst）被定义为一个非空的'0'序列（代表请求类型的数据包），后跟一个非空的'1'序列（代表释放类型的数据包）。如果'0'的数量等于'1'的数量，则该突发被认为是“平衡的”（balanced）。\n\n你的任务是分析判定一个传入的突发是否平衡所需的计算资源。这个任务由一个确定性图灵机（TM）来建模，该图灵机带有一个只读的输入带和一个单独的读写工作带。对于长度为 $N$ 的输入，该 TM 使用的空间是它在其工作带上访问的单元格数量。复杂度类 **L**，也称为 DLOGSPACE，是所有可以由这样的 TM 使用 $O(\\log N)$ 工作带空间解决的判定问题的集合。\n\n设平衡突发的语言为 $L_{bal} = \\{0^n 1^n \\mid n \\ge 1\\}$。假设给予 TM 的任何输入字符串 $w$ 都保证是一个有效的突发，即其形式为 $0^k 1^m$，其中 $k, m \\ge 1$ 是某个整数。问题是 $L_{bal}$ 是否属于类 **L**。\n\n下列哪个陈述提供了最准确和最根本的原因来解释判定 $L_{bal}$ 的空间复杂度？\n\nA. TM 可以在输入带上每找到一个'1'就划掉一个'0'。由于这类操作不使用工作带，该算法在常数工作空间内运行，这是对数空间的一个子集。\n\nB. 语言 $L_{bal}$ 是一个确定性上下文无关语言（DCFL）。所有 DCFL 都已知可在对数空间内判定，所以 $L_{bal}$ 必定在 **L** 中。\n\nC. TM 可以使用其工作带来维护一个二进制计数器。它可以扫描输入以计算'0'的数量，存储结果，然后将其与'1'的数量进行比较。二进制计数器所需的空间与其存储的值（最多为输入长度）成对数关系。\n\nD. 这个问题可以由一个双向确定性有限自动机（2DFA）解决，并且由 2DFA 判定的语言类是 **L** 的一个已知子集。\n\nE. 这个问题可以由一个非确定性 TM 解决，该 TM 猜测字符串的中点并验证两半部分。由于根据 Immerman–Szelepcsényi 定理，我们知道非确定性对数空间（**NL**）等于 **L**，所以该问题在 **L** 中。", "solution": "正确的陈述是 C。让我们分析为什么它是正确的，以及为什么其他选项是错误的。\n\n该问题要求一种算法，使用仅 $O(\\log N)$ 的工作带空间来判定语言 $L_{bal} = \\{0^n 1^n \\mid n \\ge 1\\}$，其中 $N$ 是输入字符串的长度。对于输入 $w = 0^n 1^n$，其长度为 $N = 2n$。\n\n**正确选项 (C) 的分析：**\n\n这个选项描述了一个可行的对数空间算法。一个带只读输入带和工作带的确定性图灵机可以如下实现此算法：\n\n1.  在工作带上初始化一个二进制计数器为 0。我们称此计数器为 `C`。\n2.  从左到右扫描输入带。读写头每遇到一个 '0'，就将计数器 `C` 加一。\n3.  输入保证为 $0^k 1^m$ 的形式。当机器读到第一个 '1' 时，它已经完成了对 '0' 的计数。此时，计数器 `C` 的值为 $k$。\n4.  机器接着继续扫描输入带上的 '1'。每读到一个 '1'，就将计数器 `C` 减一。\n5.  读写头经过输入的最后一个字符后，机器检查计数器 `C` 的值。\n    *   如果 `C` 为 0，则意味着 '0' 的数量等于 '1' 的数量 ($k=m$)。机器接受。\n    *   如果 `C` 不为 0，则意味着 $k \\ne m$。机器拒绝。\n    *   可以进行一个额外的检查：如果 `C` 变为负数（或在读完所有 '1' 之前达到 0），则意味着 $k < m$，机器可以立即拒绝。\n\n让我们分析该算法的空间复杂度。计数器上存储的最大值是 $k$，即 '0' 的数量。以二进制形式存储一个整数 $k$ 需要 $\\lfloor \\log_2 k \\rfloor + 1$ 位（带单元）。输入长度为 $N = k+m$。因为输入必须是平衡的才能被接受 ($k=m=n$)，所以 $N=2n$，空间为 $O(\\log n)$。在输入为 $0^k 1^m$ 的一般情况下，空间为 $O(\\log k)$。由于 $k < N$，所需的空间受 $O(\\log N)$ 的限制。因此，语言 $L_{bal}$ 可在对数空间内判定，且 $L_{bal} \\in \\mathbf{L}$。选项 C 正确地描述了这一基本机制。\n\n**错误选项的分析：**\n\n*   **A：** 复杂度类 **L** 的标准定义假设图灵机具有*只读*输入带。因此，在该模型中，划掉或修改输入带不是一个有效的操作。即使使用一个允许修改输入带的不同模型，该带上使用的空间也会计入总空间复杂度，使其成为一个线性空间 ($O(N)$) 算法，而不是对数空间算法。\n\n*   **B：** 这个陈述包含两个论断。第一个，“$L_{bal}$ 是一个确定性上下文无关语言（DCFL）”，是正确的。它可以被一个确定性下推自动机识别，该自动机每遇到一个'0'就压栈，每遇到一个'1'就弹栈。然而，第二个论断，“所有 DCFL 都已知可在对数空间内判定”，是错误的。DCFL 类不包含在 **L** 中。存在一些 DCFL 不被认为在 **L** 中，并且普遍认为 $\\mathbf{L} \\subsetneq \\text{DCFL}$。\n\n*   **D：** 这个选项声称该问题可以由一个双向确定性有限自动机（2DFA）解决，该自动机是一种可以在输入带上左右移动其读写头的有限自动机。由 2DFA 判定的语言类是 **L** 的一个子集，这是正确的。然而，2DFA 是否能判定语言 $\\{0^n 1^n\\}$ 是一个长期存在的开放问题。人们普遍推测它不能。因此，不能以此作为 $L_{bal}$ 在 **L** 中的有效理由。\n\n*   **E：** 这个陈述依赖于 **L** = **NL** 的论断，其中 **NL** 是非确定性对数空间。这是计算复杂性理论中最著名的未解决问题之一。尽管 Immerman–Szelepcsényi 定理证明了 **NL** = **co-NL**，但它并未解决 **L** 与 **NL** 的问题。人们普遍认为 **L** $\\neq$ **NL**。因此，假设 **L** = **NL** 来证明一个结论是错误的。无论如何，如 C 中的正确算法所示，判定 $L_{bal}$ 的问题不需要非确定性。", "answer": "$$\\boxed{C}$$", "id": "1452636"}, {"introduction": "在掌握了基本的计数技术后，让我们来处理一个更常见的数据验证任务：在一个未排序的数据记录数组中检测重复项。这个问题会挑战你重新思考“效率”的含义，因为在对数空间中，我们无法负担使用哈希集或排序等需要大量内存的典型方法。这个练习将引导你发现一种巧妙的、利用时间换取空间的策略，这在内存受限的计算中是一个至关重要的概念。[@problem_id:1452612]", "problem": "一个嵌入式系统被设计用于监控和验证来自传感器网络的数据日志的完整性。该系统具有极其有限的随机存取存储器 (RAM)，但它可以只读访问存储日志的大容量存储设备。某一天的日志表示为一个包含 $n$ 个整数值传感器读数的序列。如果任何传感器读数被记录超过一次，系统就会标记一个严重错误。\n\n形式上，输入是一个包含 $n$ 个整数的只读数组 $A$。数组中整数的值保证在 $[1, n^2]$ 范围内。输入的总大小被认为是 $O(n \\log n)$ 比特。你的任务是分析用以判断数组 $A$ 中是否存在至少一个重复值的算法。如果一个算法的辅助空间复杂度（除输入存储外所使用的内存）为 $O(\\log n)$，则该算法被认为是“对数空间”算法。\n\n以下哪种提议的算法能够正确判断数组 $A$ 是否包含任何重复项，并且在对数空间限制内运行？\n\nA. 初始化一个空的哈希集合。从第一个元素到最后一个元素遍历数组 $A$。对于每个元素 $A[i]$，检查它是否已存在于哈希集合中。如果存在，则说明找到了重复项。如果不存在，则将 $A[i]$ 添加到哈希集合中。如果遍历完整个数组都没有找到重复项，则说明不存在重复项。\n\nB. 使用嵌套循环结构。外层循环使用索引 $i$ 从 $0$ 遍历到 $n-1$。内层循环使用索引 $j$ 从 $i+1$ 遍历到 $n-1$。在内层循环中，读取 $A[i]$ 和 $A[j]$ 的值并进行比较。如果 $A[i]$ 等于 $A[j]$，则说明找到了重复项。如果循环完成而没有找到任何匹配，则说明不存在重复项。\n\nC. 首先，在内存中创建一个数组 $A$ 的可变副本。然后，对这个副本应用一个原地排序算法，例如堆排序。最后，遍历一次排序后的副本，将每个元素与紧随其后的元素进行比较。如果任何两个相邻元素相同，则说明存在重复项。\n\nD. 使用索引 $i$ 从 $0$ 遍历到 $n-2$ 遍历数组 $A$。在每次迭代中，将元素 $A[i]$ 与下一个元素 $A[i+1]$ 进行比较。如果它们相等，则说明找到了重复项，算法终止。如果循环完成，则说明不存在重复项。", "solution": "要解决这个问题，我们必须根据两个标准来分析每个提议的算法：正确性（如果存在重复项，它是否总能找到？）和空间复杂度（它是否在 $O(\\log n)$ 的辅助空间内运行？）。\n\n**分析选项 A：**\n该算法使用哈希集合来跟踪到目前为止已经见过的元素。\n*   **正确性：**该算法是正确的。如果遇到的元素 $A[i]$ 已经存在于哈希集合中，那么它必然是先前某个元素的重复。如果循环完成，则意味着每个元素都是唯一的。\n*   **空间复杂度：**所需空间由哈希集合的最大大小决定。在最坏的情况下，即数组 $A$ 中的所有 $n$ 个元素都不同，哈希集合需要存储所有 $n$ 个元素。每个元素是最大为 $n^2$ 的整数，需要 $O(\\log(n^2)) = O(\\log n)$ 比特的存储空间。因此，总空间复杂度为 $O(n \\log n)$。这是多项式空间，而不是对数空间。所以，该选项违反了空间限制。\n\n**分析选项 B：**\n该算法使用一对嵌套循环来比较数组中每一对不同的元素。\n*   **正确性：**该算法是正确的。它对所有 $i < j$ 的元素对 $(A[i], A[j])$ 进行暴力检查。如果数组中存在一对重复项，比如说在索引 $p$ 和 $q$ 处（其中 $p < q$），算法最终会设置 $i=p$ 和 $j=q$，发现 $A[p] = A[q]$，并正确地报告存在重复项。如果不存在重复项，则不会找到这样的元素对。\n*   **空间复杂度：**该算法需要内存来存储循环的状态和正在比较的值。循环索引 $i$ 和 $j$ 的范围是从 $0$ 到 $n-1$。存储这种量级的整数需要大约 $\\log_2(n)$ 比特，即 $O(\\log n)$ 的空间。该算法还从输入数组中读取两个值 $A[i]$ 和 $A[j]$ 进行比较。问题描述指出这些值的范围在 $[1, n^2]$ 内。存储这样的值需要 $\\log_2(n^2) = 2 \\log_2(n)$ 比特，也即 $O(\\log n)$ 的空间。总的辅助内存是这几个变量所需空间的总和，即 $O(\\log n) + O(\\log n) = O(\\log n)$。因此，该算法满足对数空间限制。\n\n**分析选项 C：**\n该算法涉及复制数组，对副本进行排序，然后扫描以查找相邻的重复项。\n*   **正确性：**该算法是正确的。排序会将所有相同的元素聚集在一起，因此对排序后的数组进行单次遍历以检查相邻元素就足以找到重复项。\n*   **空间复杂度：**第一步是“在内存中创建一个数组 $A$ 的可变副本”。正如在对选项 A 的分析中所确立的，数组 $A$ 包含 $n$ 个元素，每个元素需要 $O(\\log n)$ 比特。因此，一个完整的副本需要 $O(n \\log n)$ 的空间。这立即违反了 $O(\\log n)$ 的空间限制。问题还特别说明输入位于只读设备上，这使得对原始数据进行原地排序成为不可能，从而强调了需要一个副本。\n\n**分析选项 D：**\n该算法遍历数组，并且只将每个元素与其紧随其后的元素进行比较。\n*   **正确性：**该算法是不正确的。问题指出数组 $A$ 是未排序的。重复项不保证会出现在相邻位置。例如，考虑 $n=4$ 时的数组 $A = [10, 20, 30, 10]$。重复的值是 10，但它的两个实例并不相邻。该算法会比较 $(10, 20)$、$(20, 30)$ 和 $(30, 10)$，找不到相等的值，并错误地得出结论说没有重复项。\n*   **空间复杂度：**该算法使用一个索引 $i$，需要 $O(\\log n)$ 的空间。它的空间效率非常高，但由于它无法正确解决问题，因此是无效的。\n\n**结论：**\n只有算法 B 对于未排序的数组既是正确的，又满足严格的 $O(\\log n)$ 空间复杂度要求。", "answer": "$$\\boxed{B}$$", "id": "1452612"}, {"introduction": "我们的最后一个动手实践将探讨如何分析具有内在结构的数据，例如排列。问题是确定一个给定的排列是否构成一个单一的大循环，这在分析密码学和组合算法等领域非常有用。解决这个问题需要一种称为“指针跟随”的强大技术，你将学习如何通过迭代地从一个元素跳到下一个元素来跟踪路径，并计算路径的长度，所有这些都在对数空间限制内完成。[@problem_id:1452624]", "problem": "在计算复杂性理论中，复杂度类 L（对数空间）包含那些可以由一台确定性图灵机使用与输入规模成对数关系的内存量解决的判定问题。在此背景下，一个基本的挑战是在严格的内存限制下分析组合结构。\n\n考虑一个作用于整数集合 $\\{1, 2, \\dots, n\\}$ 上的排列 $\\pi$。该排列由一个长度为 $n$ 的只读数组 $P$ 表示，其中对于每个 $i \\in \\{1, 2, \\dots, n\\}$，条目 $P[i]$ 包含值 $\\pi(i)$。例如，如果 $n=4$ 且排列是循环 $(1 \\to 2 \\to 4 \\to 3 \\to 1)$，则对应的数组将是 $P=[2, 4, 1, 3]$（假设使用基于1的索引，其中 $P[1]=2, P[2]=4, P[3]=1, P[4]=3$）。\n\n问题是要判断给定的排列 $\\pi$ 是否构成一个长度为 $n$ 的单一循环。如果一个解决此问题的算法其辅助内存使用量为 $O(\\log n)$ 比特，并且不计算只读输入数组 $P$ 所占用的空间，则该算法被认为是对数空间算法。\n\n以下哪种提出的算法在对数空间限制内正确地解决了这个问题？\n\nA. 初始化一个大小为 $n$ 的布尔数组 `visited`，所有值均为 `false`。设置一个指针 `current = 1` 和一个计数器 `count = 0`。当 `visited[current]` 为 `false` 时，将 `visited[current]` 设为 `true`，更新 `current = P[current]`，并增加 `count`。循环终止后，当且仅当 `count` 等于 $n$ 时，该排列是一个单一循环。\n\nB. 初始化一个指针 `current = 1`。然后，执行一个循环 $n$ 次，在每次迭代中通过 `current = P[current]` 更新指针。循环完成后，当且仅当 `current` 等于 1 时，该排列是一个单一循环。\n\nC. 初始化一个大小为 $n$ 的布尔数组 `visited`，所有值均为 `false`，并初始化一个计数器 `num_cycles = 0`。用变量 `i` 从 $1$ 迭代到 $n$。如果 `visited[i]` 为 `false`，则增加 `num_cycles`，设置 `current = i`，并从 `i` 开始遍历循环，将每个元素标记为已访问，直到返回 `i`。在 `i` 的循环完成后，当且仅当 `num_cycles` 等于 1 时，该排列是一个单一循环。\n\nD. 初始化一个指针 `current = 1` 和一个计数器 `steps = 0`。进入一个循环，重复更新 `current = P[current]` 并增加 `steps`。循环持续直到 `current` 变为 1。循环终止后，当且仅当 `steps` 的最终值等于 $n$ 时，该排列是一个单一循环。\n\nE. 初始化一个计数器 `fixed_points = 0`。用变量 `i` 从 $1$ 迭代到 $n$。如果 $P[i] == i$，则增加 `fixed_points`。迭代完成后，当且仅当 `fixed_points` 等于 0 时，该排列是一个单一循环。", "solution": "我们要寻找一个算法，它能判断一个作用于 $\\{1,\\dots,n\\}$ 上的排列 $\\pi$ 是否为一个长度为 $n$ 的单一循环，同时使用的辅助内存不超过 $O(\\log_{2} n)$ 比特。输入数组 $P$ 是只读的，不计入空间使用量。\n\n设 $\\pi$ 是由 $P$ 给出的排列，并将包含 1 的循环的长度定义为\n$$\nL \\equiv \\min\\{k \\in \\mathbb{N} : \\pi^{k}(1) = 1\\}。\n$$\n关于排列的循环分解，一个标准的事实是：$\\pi$ 是一个长度为 $n$ 的单一循环当且仅当 $L = n$。\n\n我们从正确性和空间使用两方面分析每种提出的算法。\n\n算法 A 使用了一个大小为 $n$ 的布尔数组，即 $\\Theta(n)$ 比特，这超过了 $O(\\log_{2} n)$ 比特。尽管它能正确计算从 1 开始可达的循环的大小并与 $n$ 进行比较，但它违反了对数空间限制。因此，A 在空间上是无效的。\n\n算法 B 从 1 开始，并精确地应用 $\\pi$ 共 $n$ 次，当且仅当 $\\pi^{n}(1) = 1$ 时返回真。设 $L$ 是 1 所在的循环的长度。那么\n$$\n\\pi^{n}(1) = 1 \\iff L \\mid n。\n$$\n因此，如果 $L < n$ 并且 $L \\mid n$（例如，当 $L=2$ 且 $n$ 为偶数时），该算法会错误地返回真。其空间复杂度为 $O(\\log_{2} n)$，但正确性不成立。因此，B 在正确性上是无效的。\n\n算法 C 使用一个大小为 $n$ 的布尔数组来标记已访问的元素，因此使用 $\\Theta(n)$ 比特，违反了对数空间限制，尽管该算法是正确的。因此，C 在空间上是无效的。\n\n算法 D 初始化 $current = 1$，然后迭代 $current \\leftarrow \\pi(current)$，同时增加计数器 $steps$，直到 $current$ 返回到 1。根据 $L$ 的定义，这个循环恰好运行 $L$ 次，因此在终止时 $steps = L$。然后它检查 $steps = n$ 是否成立，这等价于 $L = n$，即 $\\pi$ 是一个单一的 n-循环。内存使用量为 $O(\\log_{2} n)$ 比特：用于存储 $current$ 和 $steps$（每个需要 $\\lceil \\log_{2} n \\rceil$ 比特）以及一些常数开销。因此，D 是正确的并且是对数空间的。\n\n算法 E 统计不动点的数量。虽然一个 n-循环有零个不动点，但其逆命题是假的：例如，当 $n=4$ 时，排列 $\\pi(1)=2$, $\\pi(2)=1$, $\\pi(3)=4$, $\\pi(4)=3$ 没有不动点，但它不是一个单一的 4-循环。因此 E 是不正确的，尽管它使用了 $O(\\log_{2} n)$ 的空间。因此，E 在正确性上是无效的。\n\n因此，唯一既正确又在 $O(\\log_{2} n)$ 空间限制内的算法是 D。", "answer": "$$\\boxed{D}$$", "id": "1452624"}]}