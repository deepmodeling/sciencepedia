{"hands_on_practices": [{"introduction": "证明TQBF的PSPACE-hardness的第一步是将图灵机的计算过程转化为布尔逻辑。这个练习将带你实践最基础的一步：为图灵机的磁带符号进行编码。通过确定表示有限个符号所需的最少布尔变量数，你将掌握将计算模型元素映射到逻辑变量的基本原则。[@problem_id:1438399]", "problem": "在计算复杂性研究中，像图灵机这样的理论模型是基础。分析这些机器的一个关键部分是使用更简单的逻辑系统来表示它们的格局。\n\n考虑一位计算机科学家正在为一个特定的图灵机设计一个逻辑表示。这台机器的带字母表，用集合 $\\Gamma$ 表示，包含了可以写在其纸带上的所有符号。对于这台特定的机器，字母表 $\\Gamma$ 总共包含12个不同的符号。任务是对单个纸带单元格的内容进行编码。这种编码必须使用一组布尔变量来完成，其中每个变量只能处于两种状态之一：真或假。这些变量状态的唯一组合必须对应于 $\\Gamma$ 中的12个不同符号中的每一个。\n\n唯一表示带字母表 $\\Gamma$ 中任意一个符号所需的最小布尔变量数量是多少？\n\nA) 2\n\nB) 3\n\nC) 4\n\nD) 11\n\nE) 12", "solution": "一个布尔变量可以表示两种状态。对于 $n$ 个布尔变量，根据乘法法则，不同编码的数量是 $2^n$。为了唯一地编码带字母表 $\\Gamma$ 中所有 $|\\Gamma|=12$ 个符号，我们需要\n$$\n2^{n} \\geq 12.\n$$\n两边取以2为底的对数，得到\n$$\nn \\geq \\log_{2}(12).\n$$\n我们寻找满足此条件的最小整数 $n$。检验2的幂：\n$$\n2^{3}=8<12,\\quad 2^{4}=16\\geq 12.\n$$\n因此，所需的最小布尔变量数量是 $n=4$，这对应于选项C。", "answer": "$$\\boxed{C}$$", "id": "1438399"}, {"introduction": "在将图灵机配置编码为布尔变量后，下一步是捕捉机器的动态行为，即它的单步计算。这个练习要求你为图灵机的转移规则构建一个精确的逻辑表达式，这是构建完整TQBF公式的核心构造块 $\\phi_{next}$ 的一部分。完成这个练习能让你深入理解如何将一个确定的计算规则翻译成严格的布尔逻辑。[@problem_id:1438359]", "problem": "在证明量化布尔公式（QBF）问题是PSPACE完备的标准证明中，我们会提供一个从任意一个由多项式空间图灵机判定的语言出发的多项式时间归约。该归约的一个关键部分是构造一个布尔公式（我们称之为 $\\phi_{next}$），它可验证地编码了机器的单个计算步骤。\n\n考虑一个单带确定性图灵机 $M$，它由一个状态集 $Q$、一个带字母表 $\\Gamma$ 和一个转移函数 $\\delta$ 定义。我们在一条长度为固定有限值 $N$ 的带子上分析其计算过程，带单元的索引从 $1$ 到 $N$。\n\n为了用布尔变量表示 $M$ 的一个格局，我们使用以下命题：\n- $S_q$：为真当且仅当机器的当前状态是 $q \\in Q$。\n- $H_i$：为真当且仅当读写头位于带单元 $i$，$1 \\leq i \\leq N$。\n- $T_{i, \\sigma}$：为真当且仅当带单元 $i$ 包含符号 $\\sigma \\in \\Gamma$，$1 \\leq i \\leq N$。\n\n为了区分两个连续的格局，我们用不带撇的变量（$S_q, H_i, T_{i, \\sigma}$）表示初始格局 $C$，用带撇的变量（$S'_q, H'_i, T'_{i, \\sigma}$）表示后继格局 $C'$。\n\n转移函数 $\\delta$ 将一个状态-符号对映射到一个新状态、一个要写入的符号和一个读写头移动方向。一个使读写头向右移动的转移具有形式 $\\delta(q, \\sigma) = (q', \\sigma', R)$。令 $\\Delta_R$ 为所有使得转移函数指定向右移动的状态-符号对 $(q, \\sigma)$ 的集合，即 $ \\Delta_R = \\{ (q, \\sigma) \\mid \\exists q' \\in Q, \\sigma' \\in \\Gamma \\text{ 使得 } \\delta(q, \\sigma) = (q', \\sigma', R) \\} $。\n\n你的任务是构造公式 $\\phi_{next}$ 的一部分，该部分要确保*如果*发生了一个导致向右移动的转移，则格局 $C'$ 中的读写头位置会被正确更新。你的公式必须是一个逻辑陈述，对于任何执行了向右移动的有效演化，该陈述都为真。该公式的构造应使其对所有可能发生向右移动而又不会移出带子的读写头位置 $i$（即，对于 $i \\in \\{1, 2, \\dots, N-1\\}$）都成立。请使用标准逻辑联结词（$\\land$ 表示合取，$\\lor$ 表示析取，$\\implies$ 表示蕴含）和大规模算子（$\\bigwedge$ 表示对集合的合取，$\\bigvee$ 表示对集合的析取）来表达你的答案。", "solution": "我们必须编码这样一个条件：每当在当前读写头位置有一个向右移动的转移适用时，下一个格局中的读写头就位于右侧的单元格。一个向右移动的转移在单元格索引 $i$ 处适用，精确地当读写头在当前格局中处于位置 $i$ 且当前的状态-符号对是 $\\Delta_{R}$ 中的一个时。形式上，在位置 $i$ 处向右移动的条件是\n$$\nH_{i} \\land \\bigvee_{(q,\\sigma)\\in \\Delta_{R}} \\left( S_{q} \\land T_{i,\\sigma} \\right).\n$$\n如果这个条件成立，那么下一个格局中的读写头位置必须恰好在 $i+1$，也就是说，我们需要\n$$\n\\left( H_{i} \\land \\bigvee_{(q,\\sigma)\\in \\Delta_{R}} \\left( S_{q} \\land T_{i,\\sigma} \\right) \\right) \\implies H'_{i+1}.\n$$\n由于从最右边的单元格向右移动会超出带子范围，所以这种情况不会发生，因此我们使该蕴含对所有 $i \\in \\{1,2,\\ldots,N-1\\}$ 成立，从而得到以下合取式\n$$\n\\bigwedge_{i=1}^{N-1} \\left( \\left( H_{i} \\land \\bigvee_{(q,\\sigma)\\in \\Delta_{R}} \\left( S_{q} \\land T_{i,\\sigma} \\right) \\right) \\implies H'_{i+1} \\right).\n$$\n该公式为真，当且仅当对于任何在位置 $i \\leq N-1$ 执行向右移动转移的有效格局，其后继格局都将读写头置于位置 $i+1$，从而正确地更新了向右移动时的读写头位置。", "answer": "$$\\boxed{\\bigwedge_{i=1}^{N-1}\\left(\\left(H_{i}\\land\\bigvee_{(q,\\sigma)\\in\\Delta_{R}}\\left(S_{q}\\land T_{i,\\sigma}\\right)\\right)\\implies H'_{i+1}\\right)}$$", "id": "1438359"}, {"introduction": "我们已经知道如何编码图灵机的单个计算步骤，但完整的证明依赖于一个巧妙的递归方法来验证指数级的计算步骤。这个练习通过一个思想实验来挑战你对这种递归结构的理解：分析一个错误的基例如何导致整个归约失效。通过诊断这个假设性问题，你将更深刻地领会到递归折半方法的力量和精妙之处，这是整个PSPACE-hardness证明的关键。[@problem_id:1438337]", "problem": "在证明真量化布尔公式 (True Quantified Boolean Formula, TQBF) 问题的 PSPACE-硬度的标准证明中，我们会构造一个从由多项式空间图灵机 (Turing Machine, TM) $M$ 判定的语言 $L$ 出发的、一个多项式时间的归约。设 $M$ 是一个在所有输入上都会停机的确定性图灵机，它在 $s(n) = n^k$ 的空间内判定语言 $L$（其中 $k$ 为某个常数）。对于一个长度为 $n$ 的输入 $w$，$M$ 的任何格局都可以编码为一个固定多项式长度 $N$ 的二进制字符串。\n\n该归约构建了一个公式，通常表示为 $\\text{REACH}(C_a, C_b, i)$，其意图是当且仅当格局 $C_b$ 可以从格局 $C_a$ 在至多 $2^i$ 个图灵机步骤内到达时，该公式为真。这是递归定义的。递归步骤为：\n$$ \\text{REACH}(C_a, C_b, i) \\equiv \\exists C_m \\left( \\text{REACH}(C_a, C_m, i-1) \\wedge \\text{REACH}(C_m, C_b, i-1) \\right) $$\n完整的 TQBF 公式 $\\Phi$ 断言一个接受格局可以从起始格局在至多 $2^D$ 步内到达，其中 $D$ 是一个多项式大的数。具体来说，$\\Phi \\equiv \\exists C_{accept} (\\phi_{accept}(C_{accept}) \\wedge \\text{REACH}(C_{start}, C_{accept}, D))$，其中 $C_{start}$ 是已知的起始格局，并且当 $C_{accept}$ 是一个接受格局时 $\\phi_{accept}(C_{accept})$ 为真。\n\n现在，考虑这个归约的一个有缺陷的实现，其中递归的基准情形（对于 $i=0$）被错误地定义了。这个有缺陷的基准情形 $\\text{REACH}(C_a, C_b, 0)$ 没有正确反映图灵机的单步转移函数，而是被定义为当且仅当 $C_a$ 和 $C_b$ 的 $N$ 位二进制编码之间的汉明距离至多为 1 时为真。\n\n假设选择的递归深度 $D$ 大于 $\\log_2(N)$。使用这个有缺陷的基准情形对整个公式 $\\Phi$ 的行为有何直接的逻辑后果？\n\nA. $\\Phi$ 为真当且仅当图灵机 $M$ 接受输入 $w$。\n\nB. $\\Phi$ 为真当且仅当存在一个格局序列 $C_0, C_1, \\dots, C_k$，其中 $C_0 = C_{start}$，$C_k$ 是一个接受格局，且对于所有的 $j \\in [0, k-1]$，$C_j$ 和 $C_{j+1}$ 之间的汉明距离至多为 1。\n\nC. $\\Phi$ 总是为真，只要在句法上可以编码一个图灵机处于接受状态的格局。\n\nD. $\\Phi$ 总是为假。\n\nE. $\\Phi$ 的真值正确地反映了 $M$ 是否接受 $w$，但仅当图灵机的转移函数恰好每步最多改变格局编码的一个比特时才成立。", "solution": "题目要求我们分析在一个为图灵机计算过程构造 TQBF 公式的递归中，一个有缺陷的基准情形所带来的影响。\n\n让我们将两个二进制字符串 $x$ 和 $y$ 之间的汉明距离表示为 $H(x, y)$。\n有缺陷的基准情形给出为：$\\text{REACH}(C_a, C_b, 0)$ 为真当且仅当 $H(C_a, C_b) \\le 1$。\n\n我们需要理解在有这个缺陷的基准情形下，$\\text{REACH}(C_a, C_b, i)$ 这个陈述意味着什么。我们可以通过对 $i$ 进行归纳来分析这一点。\n\n**基准情形 (i=0):**\n根据有缺陷的基准情形的定义，如果 $\\text{REACH}(C_a, C_b, 0)$ 为真，则 $H(C_a, C_b) \\le 1$。注意 $1 = 2^0$。因此，对于 $i=0$，该公式意味着 $H(C_a, C_b) \\le 2^i$。\n\n**归纳假设:**\n假设对于 $i=k-1$，如果 $\\text{REACH}(C_a, C_b, k-1)$ 为真，它意味着 $H(C_a, C_b) \\le 2^{k-1}$。\n\n**归纳步骤 (i=k):**\n递归定义是 $\\text{REACH}(C_a, C_b, k) \\equiv \\exists C_m (\\text{REACH}(C_a, C_m, k-1) \\wedge \\text{REACH}(C_m, C_b, k-1))$。\n如果 $\\text{REACH}(C_a, C_b, k)$ 为真，那么必然存在一个中间格局 $C_m$，使得 $\\text{REACH}(C_a, C_m, k-1)$ 和 $\\text{REACH}(C_m, C_b, k-1)$ 都为真。\n\n将归纳假设应用于这两个子问题：\n1. $\\text{REACH}(C_a, C_m, k-1)$ 为真意味着 $H(C_a, C_m) \\le 2^{k-1}$。\n2. $\\text{REACH}(C_m, C_b, k-1)$ 为真意味着 $H(C_m, C_b) \\le 2^{k-1}$。\n\n汉明距离满足三角不等式：$H(x, z) \\le H(x, y) + H(y, z)$。\n将此应用于我们的格局，我们得到：\n$$ H(C_a, C_b) \\le H(C_a, C_m) + H(C_m, C_b) $$\n代入我们假设中的界限：\n$$ H(C_a, C_b) \\le 2^{k-1} + 2^{k-1} = 2 \\cdot 2^{k-1} = 2^k $$\n因此，通过归纳法，如果 $\\text{REACH}(C_a, C_b, i)$ 为真，它意味着 $H(C_a, C_b) \\le 2^i$。这个有缺陷的构造用汉明距离的句法约束取代了图灵机可达性的语义约束。\n\n现在我们分析完整的公式 $\\Phi$：\n$$ \\Phi \\equiv \\exists C_{accept} (\\phi_{accept}(C_{accept}) \\wedge \\text{REACH}(C_{start}, C_{accept}, D)) $$\n如果存在一个接受格局 $C_{accept}$ 使得 $\\text{REACH}(C_{start}, C_{accept}, D)$ 为真，那么此公式为真。\n根据我们的分析，这意味着如果存在一个接受格局 $C_{accept}$ 使得以下条件成立，则 $\\Phi$ 为真：\n$$ H(C_{start}, C_{accept}) \\le 2^D $$\n题中说明格局被编码为长度为 $N$ 的二进制字符串。任意两个长度为 $N$ 的字符串之间可能的最大汉明距离是 $N$。\n题中还指定递归深度 $D$ 的选择满足 $D > \\log_2(N)$。这意味着 $2^D > N$。\n\n因此，对于任何一对格局 $C_{start}$ 和 $C_{accept}$，条件 $H(C_{start}, C_{accept}) \\le 2^D$ 总是为真，因为它们的汉明距离最大为 $N$，而我们知道 $N  2^D$。\n\n可达性约束已经变得完全无关紧要。它根本不限制 $C_{accept}$ 的选择。公式 $\\Phi$ 简化为：\n$$ \\Phi \\equiv \\exists C_{accept} (\\phi_{accept}(C_{accept}) \\wedge \\text{true}) $$\n$$ \\Phi \\equiv \\exists C_{accept} (\\phi_{accept}(C_{accept})) $$\n这个公式只是在问：“是否存在一个格局是接受格局？”\n接受格局是指图灵机状态为 $q_{accept}$ 的格局。我们总是可以构造一个长度为 $N$ 的有效二进制字符串，它编码了一个状态部分设置为 $q_{accept}$ 的格局（无论带内容或磁头位置如何）。由于总能描述出这样的格局，因此总存在一个 $C_{accept}$ 使得 $\\phi_{accept}(C_{accept})$ 为真。\n\n因此，无论图灵机 $M$ 或输入 $w$ 是什么，公式 $\\Phi$ 总是为真。这与选项 C 相符。\n\n让我们简要地看一下为什么其他选项是错误的：\nA：该归约已经损坏，不再模拟图灵机的行为。\nB：这是一个貌似合理的干扰项，但它曲解了递归定义。该递归并没有建立一个每步汉明距离 $H \\le 1$ 的分步路径。它只约束了指数级增长区间的端点。\nD：该公式总是为真，而不是假。\nE：虽然如果图灵机以这种方式工作，基准情形会“更正确”一些，但递归结构仍然会指数级地放大允许的距离，因此整个公式 $\\Phi$ 仍然会是平凡真。核心问题在于结构，而不仅仅是基准情形与图灵机的不匹配。", "answer": "$$\\boxed{C}$$", "id": "1438337"}]}