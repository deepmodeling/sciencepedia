{"hands_on_practices": [{"introduction": "空间复杂度对计算模型的具体设定异常敏感。本练习将通过一个引人注目的例子来展示这一点。通过为图灵机的只读输入带简单地增加第二个读头，一个看似需要线性空间才能解决的问题，竟然可以在常数空间 $O(1)$ 内高效完成。这个实践将挑战你在标准模型之外进行思考，并体会硬件特性如何深刻影响算法效率。[@problem_id:1448405]", "problem": "考虑一台设计用于分析字符串的专用图灵机（TM）。该机器配备一条只读输入带和一条独立、标准的可读写工作带。其独特之处在于，它有两个独立的只读磁头，我们称之为 $H_1$ 和 $H_2$，它们可以在输入带上向左或向右移动。\n\n给定一个长度为 $n$ 的输入字符串 $w$，其中 $n$ 保证为正偶数。字符串中的符号来自一个有限字母表 $\\Sigma$。任务是为这台机器设计一个算法，以确定字符串 $w$ 是否为偶数长度的回文串，即它可以表示为 $x x^R$ 的形式，其中 $x$ 是字符串的前半部分，$x^R$ 是 $x$ 的反转。\n\n在这台特定的双磁头图灵机上解决此问题，最节省空间的算法的空间复杂度是多少？空间复杂度定义为工作带上使用的单元格数量，它是输入长度 $n$ 的函数。\n\n从以下选项中选择正确的复杂度类。\n\nA. $O(1)$\nB. $O(\\log n)$\nC. $O(\\sqrt{n})$\nD. $O(n)$\nE. $O(n \\log n)$", "solution": "我们将机器模型形式化：输入带是只读的，并且有两个独立的磁头 $H_{1}$ 和 $H_{2}$，它们可以向左或向右移动。有一条独立的可读写工作带，空间复杂度在此带上测量，其定义为使用的不同单元格的数量，是输入长度 $n$ 的函数。输入长度 $n$ 是一个正偶数，目标是判断是否 $w = x x^{R}$。\n\n使用两个只读磁头和常数工作带空间的算法：\n1. 将 $H_{1}$ 移动到第一个输入符号，具体方法是将其向左移动直到读到左端标记，然后向右移动一次。\n2. 将 $H_{2}$ 移动到最后一个输入符号，具体方法是将其向右移动直到读到右端标记，然后向左移动一次。\n3. 重复以下循环：\n   a. 读取 $H_{1}$ 和 $H_{2}$ 下的符号。如果它们不同，立即拒绝。\n   b. 将 $H_{1}$ 向右移动一个单元格，并将 $H_{2}$ 向左移动一个单元格。\n   c. 如果磁头 $H_1$ 的位置越过了 $H_2$ 的位置，则停机并接受。\n\n正确性论证：\n- 最初，$H_{1}$ 位于索引 $0$，$H_{2}$ 位于索引 $n-1$。在每次迭代 $t$ 中，比较的是索引为 $t$ 和 $n-1-t$ 的符号对。如果 $w$ 不是偶数长度的回文串，那么存在某个 $i$（满足 $0 \\leq i < \\frac{n}{2}$）使得 $w[i] \\neq w[n-1-i]$，算法将在迭代 $t = i$ 时拒绝。如果所有这样的对都匹配，那么在前 $n/2$ 次迭代中所有符号对都会匹配，此时算法即可确定该字符串为回文串并接受。该循环可能会对每个对称的符号对比较两次（一次在磁头相遇前，一次在相遇后），但这不影响正确性。\n\n空间使用：\n- 工作带从未用于存储索引、计数器或标记；所有的控制都是通过在输入带上移动两个只读磁头来实现的。该机器只需要常数数量的控制状态。因此，使用的工作带单元格数量由一个与 $n$ 无关的常数限定。\n- 形式上，如果 $S(n)$ 表示在长度为 $n$ 的输入上使用的工作带单元格数量，那么存在一个常数 $c$，使得对于所有的 $n$ 都有 $S(n) \\leq c$。因此，$S(n) \\in O(1)$。\n\n在给定选项中的最优性：\n- 没有任何算法可以使用少于常数的工作带空间，而所提出的算法实现了常数空间。因此，在所提供的选项中，最节省空间的复杂度类是 $O(1)$。\n\n因此，正确选项是 A。", "answer": "$$\\boxed{A}$$", "id": "1448405"}, {"introduction": "在了解了计算模型如何影响复杂度之后，我们转向一个关于复杂度类的基本性质：闭包性。本练习要求你分析一个证明，该证明旨在说明非确定性对数空间类 $NL$ 在串接（concatenation）操作下是封闭的。通过审慎评估所提出的算法，你将对非确定性对数空间计算的精妙之处有更深刻的理解，特别是如何在不违反 $O(\\log n)$ 空间限制的前提下，正确地在输入的*一部分*上模拟一台机器。[@problem_id:1448432]", "problem": "在计算复杂性理论中，一个语言是定义在有限字母表 $\\Sigma$ 上的字符串集合。复杂度类非确定性对数空间 ($\\text{NL}$) 包含了所有可以由非确定性图灵机 (NTM) 在输入长度为 $n$ 时，使用大小为 $O(\\log n)$ 的工作带判定的语言。\n\n两个语言 $L_1$ 和 $L_2$ 的串接操作定义为语言 $L_1 \\circ L_2 = \\{w_1w_2 \\mid w_1 \\in L_1 \\text{ and } w_2 \\in L_2\\}$，其中 $w_1w_2$ 是将字符串 $w_2$ 附加到字符串 $w_1$ 之后形成的字符串。\n\n一个基本问题是复杂度类在某些操作下是否是闭合的。考虑以下断言：“$\\text{NL}$ 类在串接操作下是闭合的。”\n\n为了研究这个断言，一位工程师提出了以下算法，用于一个新的 NTM（我们称之为 $M_{cat}$）来判定一个长度为 $n$ 的输入字符串 $w$ 是否属于 $L_1 \\circ L_2$，假设 $L_1, L_2 \\in \\text{NL}$ 分别由 NTM $M_1$ 和 $M_2$ 判定。\n\n**针对输入 $w$ 的 $M_{cat}$ 提议算法：**\n1.  非确定性地猜测一个分割点，即一个整数索引 $i$，其中 $0 \\le i \\le n$。这将输入 $w$ 分割成一个前缀 $u = w[1..i]$ 和一个后缀 $v = w[i+1..n]$。\n2.  为了检查前缀 $u$ 是否在 $L_1$ 中，该机器在*整个*输入字符串 $w$ 上模拟 $M_1$。但是，模拟过程被修改：如果在任何时刻 $M_1$ 的输入带头试图移动到大于 $i$ 的位置，当前的非确定性路径立即被拒绝。\n3.  如果这个修改后的 $M_1$ 模拟进入了接受状态，机器接着检查后缀 $v$。它在*整个*输入字符串 $w$ 上模拟 $M_2$。这个模拟也被修改：如果在任何时刻 $M_2$ 的输入带头试图读取位置 $k \\le i$ 上的符号，它将读到一个不属于原始字母表 $\\Sigma$ 的特殊符号 `$`。\n4.  如果第 3 步中 $M_2$ 的模拟也进入了接受状态，那么 $M_{cat}$ 接受输入字符串 $w$。如果在给定的非确定性路径上，任何接受条件未被满足，该路径则拒绝。\n\n以下哪个陈述对该断言和提议的算法提供了最准确的评估？\n\nA. 该断言是正确的，且提议的算法是有效的，它能在对数空间内正确判定字符串是否属于 $L_1 \\circ L_2$。\nB. 该断言是正确的，但提议的算法有缺陷。虽然其判定隶属关系的逻辑是合理的，但它需要超过对数空间，因为它模拟了两个独立的机器，而每个机器都使用对数空间。\nC. 该断言是正确的，但提议的算法有缺陷。所描述的过程没有正确地测试后缀字符串是否属于 $L_2$，因为修改 $M_2$ 所见的输入带并不等同于将后缀作为一个独立的输入在 $M_2$ 上运行。\nD. 该断言是错误的。存在语言 $L_1, L_2 \\in \\text{NL}$，使得它们的串接 $L_1 \\circ L_2$ 不在 $\\text{NL}$ 中。提议算法中的缺陷是根本性的，无法在对数空间限制内修复。\nE. $\\text{NL}$ 在串接操作下的闭包性是复杂性理论中一个已知的开放问题，与 L vs. NL 问题密切相关。所提供的算法是一个已知的、但未成功的解决方法。", "solution": "我们来分析这个断言和提议的算法，重点关注对数空间模型以及为 NTM 模拟子输入的语义。\n\n首先，回顾定义：$\\text{NL}$ 是指可以由非确定性图灵机在只读输入带上使用 $O(\\log n)$ 空间判定的语言类。要证明 $\\text{NL}$ 在串接操作下是闭合的，只需给定判定 $L_{1} \\in \\text{NL}$ 的 $M_{1}$ 和判定 $L_{2} \\in \\text{NL}$ 的 $M_{2}$，构造一个使用 $O(\\log n)$ 空间判定 $L_{1} \\circ L_{2}$ 的 NTM $M_{cat}$ 即可。\n\n一个标准的正确方法如下。对于长度为 $n$ 的输入 $w$，$M_{cat}$ 非确定性地猜测一个分割索引 $i \\in \\{0,1,\\dots,n\\}$，然后：\n- 在前缀 $u = w[1..i]$ 上模拟 $M_{1}$，通过跟踪模拟的输入带头位置 $h_{1} \\in \\{0,1,\\dots,i+1\\}$，并在需要时将其转换为 $w$ 上的实际输入带头位置。如果模拟的带头试图从 $i$ 向右移动到 $i+1$，它应该读取 $u$ 的右结束符（或空白符）；同样，如果它从位置 $1$ 向左移动到 $0$，它应该读取 $u$ 的左结束符。这可以通过使用 $O(\\log n)$ 位二进制数来维护 $h_{1}$，并在读取符号时将实际输入带头重新定位到与 $h_{1}$ 对应的绝对索引来实现。由于重复扫描，时间可能会增加，但空间仍保持 $O(\\log n)$。\n- 如果 $M_{1}$ 接受，则它在后缀 $v = w[i+1..n]$ 上模拟 $M_{2}$，通过跟踪模拟的带头位置 $h_{2} \\in \\{0,1,\\dots,|v|+1\\}$，并将 $h_{2}=0$ 解释为 $v$ 的左结束符，将 $h_{2}=|v|+1$ 解释为右结束符。当 $1 \\leq h_{2} \\leq |v|$ 时，实际输入带头被移动到绝对位置 $i+h_{2}$，当 $h_{2} \\in \\{0,|v|+1\\}$ 时，提供适当的结束符。同样，$h_{2}$ 使用 $O(\\log n)$ 空间存储，并且模拟的工作带重用了相同的 $O(\\log n)$ 空间预算。\n- 使用的总空间是 $O(\\log n)$，因为我们存储了：分割索引 $i$ 的二进制表示、每次一个模拟的带头计数器（$h_{1}$ 或 $h_{2}$）、以及 $M_{1}$ 或 $M_{2}$ 的工作带，每个都使用 $O(\\log n)$ 空间。这些量是顺序重用的，所以总和是 $O(\\log n)$。\n\n因此，断言“$\\text{NL}$ 在串接操作下是闭合的”是正确的。\n\n接下来，我们评估工程师提议的算法。\n\n第 1 步（猜测 $i$）是合适的，并使用 $O(\\log n)$ 空间来存储 $i$。\n\n然而，第 2 步是有缺陷的。它提议在整个 $w$ 上模拟 $M_{1}$，但如果 $M_{1}$ 试图将其输入带头移动超过位置 $i$，则立即拒绝。这并没有正确地在 $u$ 上模拟 $M_{1}$，因为在输入 $u$ 上，机器可能合法地移动到位置 $i+1$ 以读取右结束符（或空白符），其行为可能依赖于该符号。强制在任何访问位置 $i+1$ 的尝试上立即拒绝，会错误地改变 $M_{1}$ 的行为，并可能导致拒绝有效输入。\n\n第 3 步试图通过在所有位置 $k \\leq i$ 提供一个特殊符号来模拟 $M_{2}$ 对后缀 $v$ 的处理。这也不等同于将 $v$ 作为独立输入在 $M_{2}$ 上进行模拟：一个准确的模拟必须为 $v$ 强制执行正确的左结束符语义（带头不能自由移动到左侧任意多的、都返回相同符号的不同位置），跟踪 $v$ 内部的相对带头位置，并在恰好是边界 $i$ 和 $n$ 的地方提供正确的结束符。简单地为所有 $k \\leq i$ 替换一个特殊符号，未能强制规定 $v$ 只有一个具有正确带头移动约束的左边界单元；它改变了 $M_{2}$ 的转移结构，使其与在真实输入等于 $v$ 时的行为不同。因此，这种输入修改不是对在 $v$ 上运行 $M_{2}$ 的有效模拟。\n\n关于空间使用，缺陷并不在于顺序模拟两个对数空间机器会超过 $O(\\log n)$ 的空间；因为模拟是顺序进行的并重用空间，总空间保持为 $O(\\log n)$。因此，声称该算法需要超过对数空间的反对意见是不正确的。\n\n综合以上几点：\n- 关于闭包性的断言是正确的。\n- 提议的算法是有缺陷的，因为其约束或修改输入带访问的方法，没有忠实地在 $u$ 上模拟 $M_1$ 和在 $v$ 上模拟 $M_2$。\n- 最准确的批评是，修改 $M_{2}$ 所见的输入（以及类似地对 $M_1$ 的拒绝规则）不等同于正确的子串模拟，尽管一个正确的对数空间构造是存在的。\n\n因此，正确的选项是断言该论断正确，但具体的提议过程因未能正确模拟后缀的隶属关系测试而存在缺陷的陈述。", "answer": "$$\\boxed{C}$$", "id": "1448432"}, {"introduction": "最后的这个实践将我们带到计算复杂性理论的前沿。它提出了一个经典的“假设分析”思想实验：如果确定性对数空间类 $L$ 在克林星号（Kleene star）操作下是封闭的，将会发生什么？本练习将引导你理解一个著名证明的核心逻辑，该证明揭示了这一假设将直接导出一个惊人结论：$L=NL$。通过解决这个问题，你将体验到复杂性理论家如何运用闭包性质和巧妙的归约来连接看似无关的概念，并探索计算复杂度的宏伟版图。[@problem_id:1448429]", "problem": "在计算复杂性理论中，$\\text{L}$ 是指可以由一台确定性图灵机使用 $O(\\log n)$ 空间解决的判定问题所构成的类，$\\text{NL}$ 则是非确定性图灵机对应的类。一个主要的开放问题是 $\\text{L} = \\text{NL}$ 是否成立。若能证明一个 $\\text{NL}$-完全问题（例如 `PATH`）在 $\\text{L}$ 中，则此问题可获解决。`PATH` 问题询问在给定的有向图 $G=(V, E)$ 中，两个指定的顶点 $s$ 和 $t$ 之间是否存在路径。\n\n探索此类问题的一个常用方法是，为一个复杂性类假设某个性质，然后观察其推论。假设我们认为 $\\text{L}$ 在克林星号（Kleene star）运算下是闭合的。这意味着如果一个语言 $A$ 在 $\\text{L}$ 中，那么它的克林星号 $A^*$ 也在 $\\text{L}$ 中。\n\n证明该假设蕴含 $\\text{L} = \\text{NL}$ 的标准方法是，首先证明 $\\text{L}$ 也必须在一种“复合”运算下闭合，然后利用该运算来解决 `PATH` 问题。对于一个字母表为顶点对 $(u,v)$ 的语言 $A$，其与自身的复合运算定义如下：\n$$A \\circ A = \\{ (u, w) \\mid \\text{存在一个顶点 } v \\text{ 使得 } (u, v) \\in A \\text{ 且 } (v, w) \\in A \\}$$\n如果我们能证明（利用克林星号闭包的假设）对于任何 $A \\in \\text{L}$，判定 $A \\circ A$ 成员关系的问题也在 $\\text{L}$ 中，那么我们就可以为 `PATH` 构建一个对数空间算法。\n\n你的任务是，利用 $\\text{L}$ 在克林星号运算下闭合这一事实，找出对数空间算法用于判定给定对 $(u,w)$ 是否在 $A \\circ A$ 中所应使用的正确方法。下列哪项正确地描述了这种算法的核心？\n\nA. 该算法检查字符串 `(u,w)` 是否是语言 $(A \\cup A)^*$ 的成员。\nB. 该算法通过遍历所有可能的中间顶点 $v \\in V$ 来直接构造语言 $A' = A \\circ A$，然后检查 $(u,w)$ 是否在 $A'$ 中。\nC. 该算法构造语言 $A_1 = \\{ \\text{`(x,y)`\\#} \\mid (x,y) \\in A \\}$ 和 $A_2 = \\{ \\#\\text{`(x,y)`} \\mid (x,y) \\in A \\}$，形成 $L_{check} = (A_1 \\cup A_2)^*$，并检查 $L_{check}$ 是否包含某个顶点 $v$ 对应的形如 `(u,v)#(v,w)` 的字符串。\nD. 该算法非确定性地猜测一个中间顶点 $v$，然后确定性地检查 $(u,v)$ 和 $(v,w)$ 是否都在 $A$ 中。\nE. 该算法构造语言 $A^*$，然后检查它是否包含一个字符串，其中 $(u,v)$ 和 $(v,w)$ 作为子串出现（对于某个顶点 $v$）。", "solution": "给定一个语言 $A \\in \\mathrm{L}$，其字母表为顶点对 $(x,y)$ 的编码，我们想要一个确定性的对数空间过程，来判定一个给定的对 $(u,w)$ 是否属于以下关系复合：\n$$\nA \\circ A = \\{(u,w) \\mid \\exists v \\text{ 使得 } (u,v) \\in A \\text{ 且 } (v,w) \\in A\\}.\n$$\n我们可以假设 $\\mathrm{L}$ 在克林星号下是闭合的。标准的途径是利用这个假设来证明 $\\mathrm{L}$ 在一个合适的“复合”运算下也是闭合的，然后通过重复平方（repeated squaring）的方法得出一个用于解决 `PATH` 的对数空间算法。\n\n其核心思想是将测试“$\\exists v$ 使得 $(u,v)\\in A$ 且 $(v,w)\\in A$”规约到对一个可在 $\\mathrm{L}$ 中处理的、星号闭合语言的单一成员关系测试。为此，定义以下对数空间可识别语言：\n- $A_{1} = \\{\\text{enc}(x,y)\\# \\mid (x,y) \\in A\\}$,\n- $A_{2} = \\{\\#\\text{enc}(x,y) \\mid (x,y) \\in A\\}$.\n\n其中 $\\text{enc}(x,y)$ 是对 $(x,y)$ 的标准编码。由于 $A \\in \\mathrm{L}$，判定 $A_{1}$ 或 $A_{2}$ 的成员关系也在 $\\mathrm{L}$ 中：检查在适当边界是否存在固定分隔符“$\\#$”是一个正则（因此是 $\\mathrm{L}$）检查，而剩余部分则由 $A$ 的 $\\mathrm{L}$ 判定器进行测试，同时实际上可以忽略该分隔符。由于 $\\mathrm{L}$ 在并集运算下闭合，所以 $A_{1} \\cup A_{2} \\in \\mathrm{L}$。根据 $\\mathrm{L}$ 在星号运算下闭合的假设，我们也有\n$$\nL_{\\mathrm{check}} = (A_{1} \\cup A_{2})^{*} \\in \\mathrm{L}.\n$$\n\n现在，要判定 $(u,w) \\in A \\circ A$ 是否成立，一个确定性对数空间图灵机可以遍历所有候选顶点 $v$（使用 $O(\\log n)$ 位来索引 $v$），并对每个 $v$ 形成短字符串\n$$\ns_{v} = \\text{enc}(u,v)\\#\\text{enc}(v,w),\n$$\n然后对 $s_{v}$ 调用 $L_{\\mathrm{check}}$ 的 $\\mathrm{L}$ 判定器。这可以在总共 $O(\\log n)$ 空间内完成，方法是模拟 $L_{\\mathrm{check}}$ 判定器的输入头，并根据当前的 $(u,v,w)$ 三元组即时地回答其查询；在标准编码下，字符串 $s_{v}$ 的长度为 $O(\\log n)$，因此不需要 $O(\\log n)$ 之外的额外空间。\n\n其正确性取决于分隔符所强制的对齐：$s_{v}$ 在 $(A_{1} \\cup A_{2})^{*}$ 中，当且仅当它可以被分解为一串片段的拼接，其中每个片段都在 $A_{1}$ 或 $A_{2}$ 中。因为 $s_{v}$ 以编码的左括号等符号开头，且中间恰好包含一个“$\\#$”，唯一可行的分解方式就是一个覆盖了前缀（直至并包括分隔符）的 $A_{1}$ 片段（确保了“$(u,v) \\in A$”），后跟一个覆盖了从分隔符开始的后缀的 $A_{2}$ 片段（确保了“$(v,w) \\in A$”）。因此，\n$$\ns_{v} \\in L_{\\mathrm{check}}\n\\;\\;\\Longleftrightarrow\\;\\;\n\\bigl((u,v) \\in A \\text{ and } (v,w) \\in A\\bigr).\n$$\n所以，\n$$\n(u,w) \\in A \\circ A\n\\;\\;\\Longleftrightarrow\\;\\;\n\\exists v \\text{ 使得 } s_{v} \\in L_{\\mathrm{check}}.\n$$\n在 $O(\\log n)$ 空间中枚举 $v$ 并调用 $L_{\\mathrm{check}}$ 的 $\\mathrm{L}$ 判定器，就产生了一个确定性的对数空间算法。这精确地是选项C中所描述的构造方法：构建 $A_{1}$ 和 $A_{2}$，使用星号闭包假设形成 $L_{\\mathrm{check}} = (A_{1} \\cup A_{2})^{*}$，并检查是否存在一个 $v$ 使得形如 `(u,v)#(v,w)` 的字符串在 $L_{\\mathrm{check}}$ 中。其他选项要么没有以要求的方式利用星号闭包性（A、B、E），要么本质上是非确定性的（D），因此没有体现“在星号闭包下的对数空间”这一方法。", "answer": "$$\\boxed{C}$$", "id": "1448429"}]}