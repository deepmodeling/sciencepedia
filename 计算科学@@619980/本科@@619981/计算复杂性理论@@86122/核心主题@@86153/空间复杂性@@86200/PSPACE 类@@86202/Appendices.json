{"hands_on_practices": [{"introduction": "可达性问题是计算理论中的一个基本问题，它询问是否可以从一个状态到达另一个状态。虽然朴素的广-度优先搜索等方法可能需要指数级的空间来存储所有访问过的状态，但一种更巧妙的“分而治之”递归策略——其思想与萨维奇定理的核心不谋而合——可以在多项式空间内解决这个问题。这个练习将引导你分析这类递归算法的空间复杂度，这是理解和设计 PSPACE 算法的一项关键技能。[@problem_id:1454887]", "problem": "考虑一个被称为“$n$ 位配置锁”的计算系统。在此系统中，一个“配置”是一个 $n$ 位的二进制字符串，可以解释为从 $0$ 到 $2^n - 1$ 的一个整数。该系统以离散时间步演化。从任意给定配置 $C$，它可以通过两种可能的非确定性操作之一，在单一步骤内转移到一个新配置 $C'$。这些操作是根据配置字符串 $C$ 的整数值 $v$ 定义的：\n\n1.  操作 A：新配置的整数值为 $v' = (3v + 1) \\pmod{2^n}$。\n2.  操作 B：新配置的整数值为 $v' = (5v + 1) \\pmod{2^n}$。\n\n我们关心的是可达性问题：一个起始配置 $C_{start}$ 能否在恰好 $k$ 步内到达一个目标配置 $C_{target}$？\n\n为了解决这个问题，提出了一个名为 `CanReach($C_1, C_2, t$)` 的递归算法。该算法确定配置 $C_2$ 是否可以在恰好 $t$ 步内从 $C_1$ 到达。该算法的逻辑如下：\n\n-   **基准情况：** 如果 $t=1$，函数检查是否可以通过操作 A 或操作 B 从 $C_1$ 单步到达 $C_2$。如果存在有效的转移，则返回 `True`，否则返回 `False`。\n-   **递归步骤：** 如果 $t > 1$，函数会遍历所有 $2^n$ 种可能的中间状态 $C_{mid}$ 的配置。对于每个 $C_{mid}$，它通过进行两次独立的递归调用来检查 $C_{mid}$ 是否可以在 $\\lfloor t/2 \\rfloor$ 步内从 $C_1$ 到达，并且 $C_2$ 是否可以在 $\\lceil t/2 \\rceil$ 步内从 $C_{mid}$ 到达。如果对于任何 $C_{mid}$，两次调用都返回 `True`，则函数立即返回 `True`。如果循环结束仍未找到这样的 $C_{mid}$，则函数返回 `False`。\n\n你的任务是分析此算法的空间复杂度。初始调用为 `CanReach($C_{start}, C_{target}, 2^n$)`。假设存储一个 $n$ 位配置所需的空间与 $n$ 成正比，并且存储整数步数 $t$（其大小可达 $2^n$）也需要与 $n$ 成正比的空间。递归堆栈所需的总空间可以用大O表示法写成 $O(f(n))$，其中 $f(n)$ 是某个函数。请确定这个函数 $f(n)$。", "solution": "我们分析函数调用树的递归堆栈空间。每个激活记录（栈帧）必须存储其参数和循环状态：\n- 每个配置参数 $C_{1}$ 和 $C_{2}$ 都需要与 $n$ 成正比的空间，对于固定的正常数 $c_{1},c_{2}$，即 $c_{1} n$ 和 $c_{2} n$。\n- 步数 $t$ 的大小可达 $2^{n}$，这需要与 $n$ 成正比的空间，比如 $c_{3} n$。\n- 循环遍历所有 $2^{n}$ 种可能的 $C_{\\text{mid}}$，但在任何时候只存储当前的 $C_{\\text{mid}}$，这需要与 $n$ 成正比的空间，比如 $c_{4} n$。\n- 任何额外的控制或常数大小的状态为 $O(1)$，并被包含在常数 $c_{5}$ 中。\n\n因此，每帧的空间满足\n$$\ns(n) \\le (c_{1}+c_{2}+c_{3}+c_{4})\\,n + c_{5} = a\\,n + c_{5}, \n$$\n对于某个常数 $a>0$，因此 $s(n)=\\Theta(n)$。\n\n接下来，我们确定最大递归深度。设 $D(t)$ 表示输入步数为 $t$ 时的最大深度。基准情况使用一个栈帧，所以 $D(1)=1$。对于 $t>1$，函数进行两次递归调用，步数分别为 $\\lfloor t/2 \\rfloor$ 和 $\\lceil t/2 \\rceil$，但它是顺序执行的（只有在第一个调用返回后才执行第二个）。因此，任何时候的最大堆栈深度为\n$$\nD(t) = 1 + \\max\\!\\big(D(\\lfloor t/2 \\rfloor),\\, D(\\lceil t/2 \\rceil)\\big) \\le 1 + D(\\lceil t/2 \\rceil).\n$$\n通过重复减半，经过 $m$ 次这样的步骤后，参数大小最多为 $\\lceil t/2^{m} \\rceil$。当这个值变为 $1$ 时，递归停止，这发生在满足 $t \\le 2^{m}$ 的最小 $m$ 值时，即 $m=\\lceil \\log_{2} t \\rceil$。因此\n$$\nD(t) \\le \\lceil \\log_{2} t \\rceil + 1.\n$$\n\n初始调用有 $t=2^{n}$，所以\n$$\nD(2^{n}) \\le \\lceil \\log_{2}(2^{n}) \\rceil + 1 = n + 1 = \\Theta(n).\n$$\n\n总的递归堆栈空间是最大深度和每帧空间的乘积：\n$$\nS(n) \\le D(2^{n}) \\cdot s(n) \\le (n+1)\\,(a n + c_{5}) = a n^{2} + (a + c_{5}) n + c_{5}.\n$$\n因此 $S(n) = O(n^{2})$。由于 $S(n)$ 表示为 $O(f(n))$，我们得出结论\n$$\nf(n) = n^{2}.\n$$", "answer": "$$\\boxed{n^{2}}$$", "id": "1454887"}, {"introduction": "一个强大的计算复杂性类不仅由它能解决的问题来定义，也由其在基本运算下的“封闭性”来定义。这个练习探讨了 PSPACE 在串联运算下的封闭性，这是一个关键的结构特性。通过设计一个算法来判定一个字符串是否由两个分别属于 PSPACE 语言的子串串联而成，你将学会如何组合多项式空间图灵机，并掌握空间重用这一核心技巧。[@problem_id:1454902]", "problem": "在计算复杂性理论中，一个复杂度类是一组可以在特定资源限制下由一个计算模型解决的问题。PSPACE (多项式空间) 类包含了所有可以由一个确定性图灵机在相对于输入大小的多项式空间内解决的判定问题。\n\n设 $L_1$ 和 $L_2$ 是两个语言，分别由确定性图灵机 $M_1$ 和 $M_2$ 在由多项式 $p_1(n)$ 和 $p_2(n)$ 界定的空间内判定，其中 $n$ 是输入串的长度。因此，根据定义，有 $L_1 \\in \\text{PSPACE}$ 且 $L_2 \\in \\text{PSPACE}$。\n\n这两个语言的串接，记作 $L = L_1 \\circ L_2$，定义为所有可通过将一个来自 $L_1$ 的串 $x$ 与一个来自 $L_2$ 的串 $y$ 串接而形成的串 $w$ 的集合。即，$L = \\{xy \\mid x \\in L_1 \\text{ and } y \\in L_2\\}$。\n\n我们希望证明 PSPACE 类在串接运算下是封闭的，即如果 $L_1, L_2 \\in \\text{PSPACE}$，那么 $L_1 \\circ L_2 \\in \\text{PSPACE}$。这需要构造一个图灵机 $M$，它能仅使用多项式大小的空间来判定 $L_1 \\circ L_2$。\n\n给定一个长度为 $n$ 的输入串 $w$，下列哪个选项描述了一个正确的、供确定性图灵机 $M$ 使用的、在仅使用多项式空间的情况下判定 $w \\in L$ 的高层算法？\n\nA. 图灵机 $M$ 首先枚举并存储其带上所有长度不超过 $n$ 的在 $L_1$ 中的串。然后，它枚举并存储所有长度不超过 $n$ 的在 $L_2$ 中的串。最后，对于每个存储的来自 $L_1$ 的串 $x$ 和每个来自 $L_2$ 的串 $y$，它检查它们的串接 $xy$ 是否等于输入 $w$。如果找到匹配项，它就接受；否则，它就拒绝。\n\nB. 图灵机 $M$ 系统地尝试将输入串 $w$ 分割成两个非空部分 $w = xy$ 的所有可能方式。对于每一种这样的分割，$M$ 首先在前缀 $x$ 上模拟图灵机 $M_1$。如果 $M_1$ 接受，$M$ 会擦除其工作带，然后在后缀 $y$ 上模拟图灵机 $M_2$。如果 $M_2$ 也接受，图灵机 $M$ 停机并接受。如果检查了所有可能的分割，但没有一个能导致两个模拟都接受，则 $M$ 停机并拒绝。\n\nC. 图灵机 $M$ 将输入串 $w$ 精确地分成两半，一个前缀 $x$ 和一个后缀 $y$。然后它使用一个双带图灵机，在第一条带上模拟 $M_1$ 对 $x$ 的运行，在第二条带上模拟 $M_2$ 对 $y$ 的运行。如果两个模拟都接受，$M$ 就接受。否则，$M$ 拒绝。\n\nD. 由于语言 $L_1$ 和 $L_2$ 可能是无限的，因此不可能检查所有可能的对 $(x, y)$ 以确定它们的串接是否构成 $w$。因此，判定 $L_1 \\circ L_2$ 的成员资格问题是不可判定的，并且不存在这样的图灵机 $M$。", "solution": "给定 $L_{1},L_{2} \\in \\text{PSPACE}$，它们分别有确定性判定机 $M_{1}$ 和 $M_{2}$，对长度为 $n$ 的输入，使用的空间分别最多为 $p_{1}(n)$ 和 $p_{2}(n)$。对于长度为 $n$ 的串 $w \\in \\Sigma^{*}$，$w \\in L_{1} \\circ L_{2}$ 当且仅当存在一个索引 $i$，$0 \\le i \\le n$，使得前缀 $x = w[1..i] \\in L_{1}$ 且后缀 $y = w[i+1..n] \\in L_{2}$。一个确定性图灵机 $M$ 可以通过遍历所有分割点 $i$ 并分别在 $x$ 上模拟 $M_{1}$ 和在 $y$ 上模拟 $M_{2}$ 来判定这个问题。\n\n空间分析：定义 $p(n) = \\max\\{p_{1}(n),p_{2}(n)\\}$。对于一个固定的分割点 $i$，$|x| = i \\le n$ 且 $|y| = n - i \\le n$，因此模拟过程使用的空间最多为 $p_{1}(i) \\le p_{1}(n) \\le p(n)$ 和 $p_{2}(n-i) \\le p_{2}(n) \\le p(n)$。由于 $M$ 首先在 $x$ 上模拟 $M_{1}$，并且仅当 $M_1$ 接受时，才擦除其工作带并在 $y$ 上模拟 $M_{2}$，所以使用的峰值空间最多为 $p(n)$ 加上管理分割和模拟的开销。为了将 $x$ 和 $y$ 提供给模拟器，$M$ 可以：\n- 将输入保留在只读带上，并维护一个用于分割索引 $i$ 的计数器，将被模拟的机器试图读取超过指定末尾的尝试解释为空白符；该计数器使用 $O(\\log n)$ 的空间；或者\n- 在每次模拟之前，将相关的子串复制到工作带上，这会使用 $O(n)$ 的空间。\n\n在两种情况下，每次分割所需的总空间都由\n$$\nq(n) = p(n) + O(n),\n$$\n界定，这是 $n$ 的一个多项式。对所有 $i \\in \\{0,1,\\dots,n\\}$ 的循环是顺序执行的，因此空间不会在迭代中累积；只有时间可能会爆炸式增长，但这不影响 PSPACE 的成员资格。因此，该过程在多项式空间内判定 $L_{1} \\circ L_{2}$，从而证明了 PSPACE 在串接运算下是封闭的。\n\n选项评估：\n- A 存储了所有来自 $L_{1}$ 和 $L_{2}$ 且长度不超过 $n$ 的串，这需要关于 $n$ 的指数空间，所以它不是多项式空间的。\n- B 描述了标准的多项式空间过程：尝试每个分割，在前缀上模拟 $M_{1}$，如果它接受，则擦除工作带后在后缀上模拟 $M_{2}$。如上所述，这最多使用 $q(n)$ 的空间。为了完全覆盖定义 $L_{1} \\circ L_{2} = \\{xy : x \\in L_{1}, y \\in L_{2}\\}$ 的所有情况，也应该包括 $i=0$ 和 $i=n$ 的分割；这是一个简单的调整，不会改变空间界限。\n- C 只检查了在 $i = \\lfloor n/2 \\rfloor$ 处的分割，这是不够的，因为有效的分解可能在任何 $i$ 处发生。\n- D 是错误的：$L_{1} \\circ L_{2}$ 的成员资格问题可以通过上述算法在多项式空间内判定。\n\n因此，正确的高层算法是 B。", "answer": "$$\\boxed{B}$$", "id": "1454902"}, {"introduction": "PSPACE 的应用超出了简单的可达性问题，并与逻辑和计数问题有着深刻的联系。尽管精确计算满足布尔公式的解的数量（#SAT）是一个非常困难的问题，但计算模某个整数的解的数量有时却可以在多项式空间内完成。这个练习要求你手动执行一个递归算法，来计算一个 2-CNF 公式的解的数量模 3，从而具体体验 PSPACE 算法在解决逻辑难题时的精巧之处。[@problem_id:1454907]", "problem": "计算复杂性理论中的一个核心问题是计算给定问题的解的数量，这通常用前缀 # 来表示（例如，#SAT）。虽然为 2-合取范式（2-CNF）公式找到一个可满足赋值的问题是多项式时间内可解的，但计算所有这类赋值（#2-SAT）的问题是 #P-完全的，因此被认为是难解的。\n\n本问题探讨一个相关的问题：确定可满足赋值的数量模一个小整数（具体为 3）的结果。给定一个包含 $n$ 个变量 $\\{x_1, x_2, \\dots, x_n\\}$ 的布尔公式。一个文字（literal）是变量 $x_i$ 或其否定 $\\neg x_i$。一个 2-CNF 公式是多个子句的合取（AND，用 $\\land$ 表示），其中每个子句是至多两个文字的析取（OR，用 $\\lor$ 表示）。一个可满足赋值是将变量映射到 {True, False}，使得整个公式为 True 的一种赋值方式。\n\n考虑以下递归算法 `CountMod3($\\psi, k, n$)`，该算法计算公式 $\\psi$ 的可满足赋值数量模 3 的结果。假定 $\\psi$ 中的变量是 $\\{x_k, x_{k+1}, \\dots, x_n\\}$ 的一个子集。\n\n**算法 `CountMod3($\\psi, k, n$)`：**\n\n1.  **基例（不可满足）：** 如果公式 $\\psi$ 被确定为不可满足，则返回 0。如果一个公式包含空子句 `()`，它就是不可满足的。空子句可能由一个代入将单位子句（如`($x_i$)`）化简为 `(False)` 而产生。\n2.  **基例（重言式）：** 如果公式 $\\psi$ 不包含任何子句，那么对于剩余变量 $\\{x_k, \\dots, x_n\\}$ 的任何赋值，它都是满足的。这样的赋值数量为 $2^{n-k+1}$。函数应返回 $2^{n-k+1} \\pmod 3$。\n3.  **递归步骤：** 如果不满足任何基例，选择变量 $x_k$：\n    a.  通过代入 $x_k = \\text{False}$ 从 $\\psi$ 构建公式 $\\psi_0$。这涉及到将所有文字 $x_k$ 的实例替换为 False，将 $\\neg x_k$ 替换为 True。然后对结果公式进行化简：\n        - 任何包含 True 的子句（例如 `(True ∨ $l$)`）被移除。\n        - 在任何子句中，任何 False 的实例被移除（例如 `(False ∨ $l$)` 变为 `($l$)`）。\n    b.  递归计算 $c_0 = \\text{CountMod3}(\\psi_0, k+1, n)$。\n    c.  通过代入 $x_k = \\text{True}$ 并以类似方式化简，从 $\\psi$ 构建公式 $\\psi_1$。\n    d.  递归计算 $c_1 = \\text{CountMod3}(\\psi_1, k+1, n)$。\n    e.  返回 $(c_0 + c_1) \\pmod 3$。\n\n给定以下包含 $n=4$ 个变量 $\\{x_1, x_2, x_3, x_4\\}$ 的 2-CNF 公式 $\\phi$：\n$$ \\phi = (\\neg x_1 \\lor x_2) \\land (\\neg x_2 \\lor x_3) \\land (\\neg x_3 \\lor x_4) \\land (\\neg x_4 \\lor \\neg x_1) \\land (x_1 \\lor x_3) $$\n\n请确定初始调用 `CountMod3($\\phi$, 1, 4)` 返回的值。", "solution": "我们将 CountMod3 应用于 $\\phi=(\\neg x_{1}\\lor x_{2})\\land(\\neg x_{2}\\lor x_{3})\\land(\\neg x_{3}\\lor x_{4})\\land(\\neg x_{4}\\lor \\neg x_{1})\\land(x_{1}\\lor x_{3})$，其中 $(k,n)=(1,4)$。该公式既不是不可满足的，也不是空的，所以我们对 $x_{1}$ 进行分支。\n\n情况 $x_{1}=\\text{False}$：代入 $x_{1}=\\text{False}$，因此 $\\neg x_{1}=\\text{True}$。子句化简如下：\n- $(\\neg x_{1}\\lor x_{2})\\to(\\text{True}\\lor x_{2})$，结果为 $\\text{True}$，被移除。\n- $(\\neg x_{2}\\lor x_{3})$ 不变。\n- $(\\neg x_{3}\\lor x_{4})$ 不变。\n- $(\\neg x_{4}\\lor \\neg x_{1})\\to(\\neg x_{4}\\lor \\text{True})$，结果为 $\\text{True}$，被移除。\n- $(x_{1}\\lor x_{3})\\to(\\text{False}\\lor x_{3})$，成为单位子句 $(x_{3})$。\n因此 $\\psi_{0}=(\\neg x_{2}\\lor x_{3})\\land(\\neg x_{3}\\lor x_{4})\\land(x_{3})$，我们调用 CountMod3$(\\psi_{0},2,4)$ 并对 $x_{2}$ 进行分支。\n\n子情况 $x_{2}=\\text{False}$：在 $\\psi_{0}$ 中，$(\\neg x_{2}\\lor x_{3})\\to(\\text{True}\\lor x_{3})$，结果为 $\\text{True}$，被移除；其余部分保留，得到 $\\psi_{00}=(\\neg x_{3}\\lor x_{4})\\land(x_{3})$。对 $x_{3}$ 进行分支：\n- $x_{3}=\\text{False}$ 使得单位子句 $(x_{3})$ 变为 $\\text{False}$，即一个空子句，所以这个分支不可满足，返回 $0$。\n- $x_{3}=\\text{True}$ 使得 $(\\neg x_{3}\\lor x_{4})\\to(\\text{False}\\lor x_{4})=(x_{4})$ 并且移除了 $(x_{3})$，所以我们得到 $\\psi_{000}=(x_{4})$。对 $x_{4}$ 进行分支：\n  - $x_{4}=\\text{False}$ 产生一个空子句，返回 $0$。\n  - $x_{4}=\\text{True}$ 移除了该子句，不留下任何子句；重言式基例返回 $2^{n-(k+1)+1}=2^{4-5+1}=2^{0}=1$ 模 $3$，即 $1$。\n因此 $x_{2}=\\text{False}$ 的子情况贡献了 $0+1=1$。\n\n子情况 $x_{2}=\\text{True}$：$(\\neg x_{2}\\lor x_{3})\\to(\\text{False}\\lor x_{3})=(x_{3})$，所以 $\\psi_{01}=(x_{3})\\land(\\neg x_{3}\\lor x_{4})\\land(x_{3})$。对 $x_{3}$ 进行分支：\n- $x_{3}=\\text{False}$ 从 $(x_{3})$ 产生一个空子句，返回 $0$。\n- $x_{3}=\\text{True}$ 使得 $(\\neg x_{3}\\lor x_{4})\\to(x_{4})$ 并且移除了单位子句，得到 $(x_{4})$。对 $x_{4}$ 进行分支：\n  - $x_{4}=\\text{False}$ 是不可满足的，返回 $0$。\n  - $x_{4}=\\text{True}$ 产生没有子句的情况，重言式返回 $2^{0}=1$ 模 $3$，即 $1$。\n因此 $x_{2}=\\text{True}$ 的子情况贡献了 $0+1=1$。\n\n所以 $c_{0}=\\text{CountMod3}(\\psi_{0},2,4)=1+1=2$ (并且 $2\\bmod 3=2$)。\n\n情况 $x_{1}=\\text{True}$：代入 $x_{1}=\\text{True}$，因此 $\\neg x_{1}=\\text{False}$。子句化简如下：\n- $(\\neg x_{1}\\lor x_{2})\\to(\\text{False}\\lor x_{2})=(x_{2})$。\n- $(\\neg x_{2}\\lor x_{3})$ 不变。\n- $(\\neg x_{3}\\lor x_{4})$ 不变。\n- $(\\neg x_{4}\\lor \\neg x_{1})\\to(\\neg x_{4}\\lor \\text{False})=(\\neg x_{4})$。\n- $(x_{1}\\lor x_{3})\\to(\\text{True}\\lor x_{3})$，结果为 $\\text{True}$，被移除。\n因此 $\\psi_{1}=(x_{2})\\land(\\neg x_{2}\\lor x_{3})\\land(\\neg x_{3}\\lor x_{4})\\land(\\neg x_{4})$，我们调用 CountMod3$(\\psi_{1},2,4)$ 并对 $x_{2}$ 进行分支。\n\n子情况 $x_{2}=\\text{False}$：单位子句 $(x_{2})$ 变为 $\\text{False}$，产生一个空子句；返回 $0$。\n\n子情况 $x_{2}=\\text{True}$：移除 $(x_{2})$，并且 $(\\neg x_{2}\\lor x_{3})\\to(\\text{False}\\lor x_{3})=(x_{3})$。我们得到 $\\psi_{11}=(x_{3})\\land(\\neg x_{3}\\lor x_{4})\\land(\\neg x_{4})$。对 $x_{3}$ 进行分支：\n- $x_{3}=\\text{False}$ 从 $(x_{3})$ 产生一个空子句，返回 $0$。\n- $x_{3}=\\text{True}$ 使得 $(\\neg x_{3}\\lor x_{4})\\to(x_{4})$ 并保留 $(\\neg x_{4})$，所以我们有 $(x_{4})\\land(\\neg x_{4})$。对 $x_{4}$ 进行分支：\n  - $x_{4}=\\text{False}$ 使得 $(x_{4})$ 为假，产生空子句，返回 $0$。\n  - $x_{4}=\\text{True}$ 使得 $(\\neg x_{4})$ 为假，产生空子句，返回 $0$。\n因此这个子情况贡献了 $0$。\n\n所以 $c_{1}=\\text{CountMod3}(\\psi_{1},2,4)=0+0=0$。\n\n最后，CountMod3$(\\phi,1,4)$ 返回 $(c_{0}+c_{1})\\bmod 3=(2+0)\\bmod 3=2$。", "answer": "$$\\boxed{2}$$", "id": "1454907"}]}