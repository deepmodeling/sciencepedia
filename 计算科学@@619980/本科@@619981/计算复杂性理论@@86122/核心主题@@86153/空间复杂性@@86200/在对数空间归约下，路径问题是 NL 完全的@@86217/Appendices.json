{"hands_on_practices": [{"introduction": "这项练习将为您提供对数空间归约的直接、动手实践经验。我们将探索如何通过将一个带约束的路径寻找问题转化回标准的 $PATH$ 实例来处理额外的约束 [@problem_id:1435016]。本练习旨在让您熟悉“顶点分裂”这一常见而强大的技巧，通过分析归约后生成图的结构，您将对转换的代价有一个具体的认识。", "problem": "在计算复杂性理论中，`PATH` 问题旨在判断在一个给定的有向图中，是否存在一条从指定的顶点 $s$ 到顶点 $t$ 的路径。一个相关的问题是 `AVOID-PATH`，它引入了一个额外的约束。\n\n`AVOID-PATH` 问题的定义如下：给定一个有向图 $G=(V, E)$、一个起始顶点 $s \\in V$、一个目标顶点 $t \\in V$，以及一个“禁止”顶点集合 $F \\subseteq V$，判断是否存在一条从 $s$ 到 $t$ 的路径，使得该路径上的每个顶点（包括起始和结束顶点 $s$ 和 $t$）都不在 $F$ 中。\n\n`AVOID-PATH` 问题可以通过对数空间归约，将其任何实例转换为标准 `PATH` 问题的一个等价实例来解决。考虑以下“顶点分裂”归约策略：\n\n一个 `AVOID-PATH` 实例，由元组 $\\langle G=(V,E), s, t, F \\rangle$ 描述，被转换为一个 `PATH` 实例 $\\langle G'=(V',E'), s', t' \\rangle$。新图 $G'$ 的构造如下：\n1.  对于 $V$ 中的每个顶点 $v$，在 $V'$ 中创建两个新顶点，记为 $v_{\\text{in}}$ 和 $v_{\\text{out}}$。\n2.  对于 $V$ 中**不**在禁止集合 $F$ 内的每个顶点 $v$，在 $E'$ 中添加一条从 $v_{\\text{in}}$ 到 $v_{\\text{out}}$ 的有向边。\n3.  对于原图中的每条有向边 $(u,v) \\in E$，在 $E'$ 中添加一条从 $u_{\\text{out}}$ 到 $v_{\\text{in}}$ 的有向边。\n4.  将新的起始顶点和目标顶点分别设置为 $s' = s_{\\text{in}}$ 和 $t' = t_{\\text{out}}$。\n\n设原图 $G$ 有 $n$ 个顶点（即 $|V|=n$）和 $m$ 条边（即 $|E|=m$）。设禁止顶点集合 $F$ 包含 $k$ 个顶点（即 $|F|=k$）。\n\n您的任务是确定新构造的图 $G'$ 中的顶点数和边数。请以关于 $n$、$m$ 和 $k$ 的符号表达式对的形式给出您的答案。第一个表达式应为顶点数 $|V'|$，第二个表达式应为边数 $|E'|$。", "solution": "我们使用顶点分裂归约法来分析从 $G$ 构造 $G'$ 的过程，并通过直接枚举来计算顶点和边的数量。\n\n关于顶点：对于原图中的每个顶点 $v \\in V$，构造过程会在 $V'$ 中创建两个不同的顶点 $v_{\\text{in}}$ 和 $v_{\\text{out}}$。根据乘法和加法原理，顶点总数为\n$$\n|V'|=2|V|=2n.\n$$\n\n关于边：添加了两种不相交类型的边。\n- 内部边：对于每个 $v \\in V \\setminus F$，添加一条有向边 $v_{\\text{in}} \\to v_{\\text{out}}$。这类顶点的数量为 $|V \\setminus F|=n-k$，因此贡献了 $n-k$ 条边。\n- 转移边：对于原图中的每条有向边 $(u,v) \\in E$，添加一条有向边 $u_{\\text{out}} \\to v_{\\text{in}}$。原图中有 $|E|=m$ 条这样的边。\n\n这两组边是不相交的，因为内部边从 $v_{\\text{in}}$ 指向 $v_{\\text{out}}$，而转移边从某个 $u_{\\text{out}}$ 指向某个 $v_{\\text{in}}$。因此，边的总数是它们的和\n$$\n|E'|=(n-k)+m=m+n-k.\n$$\n\n设置 $s'=s_{\\text{in}}$ 和 $t'=t_{\\text{out}}$ 并不会引入额外的顶点或边，因为这些只是对现有顶点的指定。\n\n因此，计数结果为 $|V'|=2n$ 和 $|E'|=m+n-k$。", "answer": "$$\\boxed{\\begin{pmatrix} 2n & m+n-k \\end{pmatrix}}$$", "id": "1435016"}, {"introduction": "在实践了如何构建一个归约之后，我们现在转向其形式化定义本身。什么才是一个有效的对数空间归约？此问题探讨了一个关键的约束，它超越了归约函数本身的内存使用：其输出的规模。通过思考将二进制数转换为一元表示的任务 [@problem_id:1435076]，您将理解为什么输出规模的指数级增长会使一个函数不能成为标准的对数空间归约，这是正确应用复杂性理论的关键洞见。", "problem": "一位系统工程师正在为一项物理实验设计一款微控制器。该控制器的主要任务是接收一个表示正整数 $N$ 的 $n$ 位二进制串 $B$，然后生成一串恰好包含 $N$ 个电压脉冲的脉冲序列。该微控制器有一个用于输入 $B$ 的只读输入寄存器和一个用于输出脉冲的只写输出引脚。关键在于，其内部的读写工作内存极其有限，最多只能存储 $c \\log_2 n$ 位，其中 $c$ 是一个小常数。用复杂性理论的语言来说，它运行的任何算法都必须是对数空间计算。\n\n工程师设计了一种基于输入数 $N$ 的二进制展开式的算法，$N = \\sum_{i=0}^{n-1} b_i 2^i$，其中 $b_i$ 是 $B$ 的第 $i$ 位。该算法通过一个指针从 $i=n-1$ 迭代到 $0$。如果发现第 $i$ 位 $b_i$ 是 '1'，它就会执行一个子程序 `GeneratePowerOfTwoPulses(i)`，该子程序旨在精确生成 $2^i$ 个脉冲。`GeneratePowerOfTwoPulses(i)` 的实现方式是模拟 $i$ 个嵌套循环，每个循环迭代两次。最内层循环的循环体触发一个脉冲。\n\n设计完之后，工程师就该算法的可行性及其与对数空间归约概念的关系提出了几项主张。对数空间归约是证明问题对于一个复杂性类是完备的一个基本工具。\n\n思考以下陈述：\n\n(I) 工程师提出的将二进制输入 $N$ 转换为 $N$ 个脉冲的一元流的算法可以在指定的微控制器上实现，因为整个过程在对数空间内是可计算的，即 $O(\\log n)$。\n\n(II) 工程师提出的算法需要 $\\Theta(n)$ 的工作空间。因此，它不是一个对数空间计算，无法在指定的微控制器上实现。\n\n(III) 一个将数字从其二进制表示转换为其一元表示的函数不被视为标准的对数空间归约，主要原因是该函数本身在对数空间内是不可计算的。\n\n(IV) 一个将数字从其二进制表示转换为其一元表示的函数不被视为标准的对数空间归约，主要原因是该函数的输出长度通常不受其输入长度的多项式界定。\n\n以上陈述中，哪些是正确的？\n\nA. I 和 III\n\nB. I 和 IV\n\nC. II 和 III\n\nD. II 和 IV\n\nE. 仅 II", "solution": "我们使用对数空间转换器（只读输入、只写输出和 $O(\\log n)$ 工作空间）的空间复杂性原理来分析每个陈述。\n\n首先，考虑子程序 $\\text{GeneratePowerOfTwoPulses}(i)$。根据设计，它模拟 $i$ 个嵌套循环，每个循环迭代两次，最内层的循环输出一个脉冲。为了确定性地模拟 $i$ 个嵌套的二元循环，机器必须维护每个循环的状态（第一次或第二次迭代）。这需要存储 $i$ 个一位的循环计数器。因此，该子程序需要 $\\Theta(i)$ 位的工作内存。在最坏情况下，当 $i=n-1$ 时，它需要 $\\Theta(n)$ 位。外部算法还维护一个指向输入位的指针 $i$，这需要 $O(\\log n)$ 位，但主要开销是子程序的 $\\Theta(n)$ 位。因此，所提出的算法使用 $\\Theta(n)$ 的工作空间，不是一个对数空间计算。\n\n因此：\n- 陈述 (I) 是错误的，因为所描述的算法不符合 $O(\\log n)$ 的空间要求。\n- 陈述 (II) 是正确的，因为嵌套循环生成器在最坏情况下需要 $\\Theta(n)$ 位。\n\n接下来，考虑对数空间归约。一个具有 $O(\\log n)$ 工作空间的确定性对数空间转换器，其构型数量最多是输入长度 $n$ 的多项式级别，因为构型的数量是\n$$\n|Q| \\cdot n^{O(1)} \\cdot 2^{O(\\log n)} = n^{O(1)}.\n$$\n如果机器会停机，它就不能重复访问一个构型；因此，步数受 $n$ 的多项式界定。因为它每一步最多输出一个符号，所以输出长度也受 $n$ 的多项式界定。将一个 $n$ 位二进制表示映射到长度为 $N$ 的一元串的函数，其输出长度可能为 $N$，其中 $N$ 最大可达 $2^{n}-1$，这个值不受 $n$ 的多项式界定。因此，由于其超多项式的输出长度，这样的函数不能成为一个标准的对数空间归约。\n\n因此：\n- 陈述 (III) 作为解释为什么它不是标准对数空间归约的理由是错误的；主要问题是输出长度缺少多项式界。\n- 陈述 (IV) 是正确的，因为输出不受输入长度的多项式界定。\n\n综合以上分析，正确的陈述是 II 和 IV。", "answer": "$$\\boxed{D}$$", "id": "1435076"}, {"introduction": "最后的这项实践将深入探讨完备性证明的逻辑核心。归约不仅仅是一个转换过程，它更是一座必须双向都成立的逻辑桥梁。在这个问题中，您将扮演一个证明审查员的角色，分析一个旨在证明 $PATH$ 是 $NL$-难的、但有缺陷的假设性归约 [@problem_id:1435034]。通过诊断一个看似微小的错误为何能使整个证明失效，您将深刻体会到支撑所有完备性论证的“当且仅当”条件的严格性。", "problem": "在计算复杂性理论中，PATH 问题是理解复杂性类 NL 的一个基石。PATH 问题询问的是在一个有向图 $G$ 中，两个指定的顶点 $s$ 和 $t$ 之间是否存在一条路径。复杂性类 NL（非确定性对数空间）包含所有可以由一台非确定性图灵机（NTM）在对数于输入长度大小的工作带上解决的判定问题。\n\n为了证明 PATH 是 NL-困难的，必须证明对于任何语言 $L \\in \\text{NL}$，都存在一个从 $L$ 到 PATH 的对数空间归约。标准的证明过程如下：设 $L$ 是 NL 中的一个语言，由一台对数空间 NTM $M$ 判定。对于任意输入串 $w$，一个对数空间转换器会构建一个“格局图”$G_M(w)$。该图的顶点代表了机器 $M$ 在输入 $w$ 上的所有可能格局。从格局 $C_1$ 到 $C_2$ 存在一条有向边，当且仅当机器 $M$ 可以在一个计算步骤内从 $C_1$ 转移到 $C_2$。于是，判定 $w \\in L$ 的问题就等价于判定在 $G_M(w)$ 中是否存在一条从初始格局 $C_{\\text{start}}$ 到唯一接受格局 $C_{\\text{accept}}$ 的路径。\n\n现在，考虑一个学生 Alice，她实现了一个对数空间转换器来执行这个归约。她的转换器有一个微妙的错误。对于一个 NTM $M$ 的任意给定输入 $w$：\n- 它能正确地生成所有可能的格局作为顶点集。\n- 它能正确地识别出 $C_{\\text{start}}$ 和 $C_{\\text{accept}}$ 顶点。\n- 然而，在生成边时，如果所有有效的单步机器转移集合非空，她的转换器总是会从最终的图表示中遗漏恰好一个有效的转移。具体被遗漏的边可能因输入 $w$ 的不同而不同。\n\n鉴于 Alice 的实现中存在这个特定的缺陷，它如何影响其构造作为 PATH 问题 NL-困难性证明的有效性？\n\nA. PATH 的 NL-困难性证明仍然完全有效。遗漏一条边是一个无关紧要的错误，不会破坏对所有可能输入的基本逻辑等价性。\n\nB. 该证明无效。这个缺陷可能导致语言 $L$ 的一个“否”实例（即输入 $w \\notin L$）被映射为 PATH 的一个“是”实例，因为错误的图可能包含一条本不应存在的路径。\n\nC. 该证明无效。这个缺陷可能导致语言 $L$ 的一个“是”实例（即输入 $w \\in L$）被映射为 PATH 的一个“否”实例，因为被遗漏的边可能对所有接受计算路径都至关重要。\n\nD. 该证明无效，但这主要是因为执行归约的转换器由于需要选择并遗漏一条边的额外逻辑，不再能保证在对数空间内运行。\n\nE. PATH 的 NL-困难性证明失败了，但这个构造现在可以被视为 PATH 包含在 NL 中（即 PATH $\\in$ NL）的一个有效证明。", "solution": "我们将标准归约和该错误的影响形式化。\n\n1) 标准归约及其正确性条件：\n- 设 $L \\in \\text{NL}$，且 $M$ 是一个判定 $L$ 的非确定性对数空间图灵机。\n- 在输入 $w$ 上，对数空间转换器构造格局图 $G_{M}(w)=(V,E)$，其顶点 $V$ 是 $M$ 在 $w$ 上的所有格局，且 $(C_{1},C_{2}) \\in E$ 当且仅当 $M$ 能在一步内从格局 $C_{1}$ 转移到格局 $C_{2}$。\n- 设 $s=C_{\\text{start}}$ 为唯一初始格局， $t=C_{\\text{accept}}$ 为唯一接受格局。\n- 到 PATH 的归约的标准正确性条件是：\n$$\nw \\in L \\iff \\text{在 } G_{M}(w) \\text{ 中存在一条从 } s \\text{ 到 } t \\text{ 的路径}。\n$$\n\n2) Alice 错误在归约后实例中的模型：\n- Alice 的转换器输出相同的顶点集 $V$，相同的 $s$ 和 $t$，但在 $E$ 非空时，会输出一个通过移除一个有效转移得到的边集 $E'$。形式上，对于某个边 $e^{*} \\in E$（可能依赖于 $w$），\n$$\nE' \\;=\\; E \\setminus \\{e^{*}\\}.\n$$\n- 因此，生成的实例是 $G'=(V,E')$，具有相同的 $s,t$。\n\n3) 对“否”方向的影响：\n- 假设 $w \\notin L$。那么在 $G_{M}(w)$ 中没有从 $s$ 到 $t$ 的路径：\n$$\nw \\notin L \\implies G_{M}(w) \\text{ 中不存在从 } s \\text{ 到 } t \\text{ 的路径}。\n$$\n- 移除边不能创建新路径。形式上，如果 $E' \\subseteq E$，那么 $(V,E')$ 中的任何 $s \\leadsto t$ 路径也是 $(V,E)$ 中的一条 $s \\leadsto t$ 路径。因此，\n$$\n(V,E) \\text{ 中不存在 } s \\leadsto t \\text{ 路径} \\implies (V,E') \\text{ 中不存在 } s \\leadsto t \\text{ 路径}。\n$$\n- 因此，Alice 的错误不能将一个“否”实例映射到一个“是”实例。选项 B 是错误的。\n\n4) 在该错误下，“是”实例变为“否”实例的存在性：\n- 为了保持 NL-困难性，该归约必须对所有 $w$ 满足：\n$$\nw \\in L \\iff (V,E') \\text{ 中存在 } s \\leadsto t \\text{ 路径}。\n$$\n- 我们证明这个等价关系可能不成立。构造一个 $M$ 和 $w \\in L$，使得 $G_{M}(w)$ 中恰好只有一条从 $s$ 到 $t$ 的路径，并且除了该路径上的边之外没有其他边。一种方法是让 $M$ 在 $w$ 上是确定的，并具有唯一的接受性运行，同时定义其转移函数，使得不在该运行上的每个格局都是停机状态（没有出向转移）。那么 $E$ 中唯一的边恰好就是这条唯一的 $s \\leadsto t$ 路径上的边。\n- 由于 Alice 的错误在 $E$ 非空时会从中移除恰好一条边 $e^{*}$，它必然会移除那条唯一路径上的一条边。因此，新的图 $(V,E')$ 中将没有 $s \\leadsto t$ 路径。\n- 因此，存在输入 $w \\in L$，对于这些输入，有错误的归约会输出一个 PATH 的“否”实例。这破坏了所要求的双向蕴涵关系，并使归约无效。这正是选项 C 中描述的失败情况。\n\n5) 剩余选项：\n- 选项 A 是不正确的，因为等价关系必须对所有输入都成立；当移除的单条边位于所有接受路径上时，这可能是致命的。\n- 选项 D 是不正确的，因为空间限制原则上不受影响；问题在于语义正确性，而非空间复杂性。\n- 选项 E 与 NL-困难性无关；此外，这个有缺陷的归约并不能证明 $\\text{PATH} \\in \\text{NL}$（这是一个独立已知的事实）。\n\n结论：该缺陷可以通过删除一条对所有接受路径都至关重要的边，将 $L$ 的一个“是”实例映射为 PATH 的一个“否”实例，因此该证明因选项 C 中的理由而无效。", "answer": "$$\\boxed{C}$$", "id": "1435034"}]}