{"hands_on_practices": [{"introduction": "第一个练习将巩固我们对复杂性类 $NL$ 的理解。我们将分析一个用于检查图中连通性的特定非确定性算法。通过仔细计算指针和计数器等变量所需的内存，你将对对数空间（即 $O(\\log n)$）在实践中的真正含义获得具体的直觉。[@problem_id:1453163]", "problem": "一个大规模的、去中心化的数据存储网络被建模为一个无向图 $G=(V, E)$，其中顶点集合 $V$ 代表 $n$ 个不同的数据服务器，标记从 $1$ 到 $n$。边集合 $E$ 代表这些服务器之间的直接、双向通信链接。一项关键的维护任务是确定两个特定的服务器，一个源服务器 $s$ 和一个目标服务器 $t$，是否在网络的同一个连通分量中，这意味着理论上数据包可以在它们之间路由。\n\n一位初级工程师提出了以下非确定性算法来检查连通性：\n1. 初始化变量 `current_node` 为源服务器 $s$ 的标签。初始化一个整型计数器 `steps_taken` 为 0。这些变量存储在工作带上。\n2. 如果 `current_node` 等于 $t$，算法停机并接受。\n3. 如果 `steps_taken` 等于 $n$，算法停机并拒绝。这可以防止非终止计算。\n4. 将 `steps_taken` 增加一。\n5. 非确定性地选择一个服务器 `next_node`，该服务器是图中 `current_node` 的一个邻居。\n6. 将 `current_node` 更新为 `next_node` 的值。\n7. 转到步骤 2。\n\n假设此算法在一个非确定性图灵机上实现。图的结构被提供在一个只读输入带上（例如，以邻接表的形式），这部分不计入算法的空间复杂度。你的任务是确定执行此算法所需的可写工作带上的空间复杂度。该复杂度应使用大O表示法表示，并作为服务器总数 $n$ 的函数。\n\n以下哪项表示该算法的工作带空间复杂度的最紧上界？\n\nA. $O(1)$\n\nB. $O(\\log n)$\n\nC. $O(n)$\n\nD. $O(n \\log n)$\n\nE. $O(n^2)$", "solution": "问题要求解一个给定的非确定性算法在图灵机工作带上的空间复杂度。空间复杂度由算法在执行期间存储其使用的变量所需的内存量决定。代表图的输入位于只读带上，不计入此复杂度。让我们分析算法需要在其工作带上存储的每一条信息所需的内存。\n\n该算法使用两个主要变量：`current_node` 和 `steps_taken`。\n\n首先，我们考虑变量 `current_node`。这个变量存储算法当前正在访问的服务器的标签。服务器的标签从 $1$ 到 $n$。要存储一个在范围 $[1, n]$ 内的整数值，我们需要的比特数与该范围大小的对数成正比。具体来说，要用二进制表示任何不大于 $n$ 的整数，我们需要 $\\lceil \\log_2 n \\rceil$ 比特。用大O表示法来说，存储 `current_node` 所需的空间是 $O(\\log n)$。\n\n其次，我们分析计数器 `steps_taken` 所需的空间。这个计数器从 0 开始，并在非确定性游走的每一步递增。当 `steps_taken` 达到 $n$ 时，算法有一个停止条件（步骤3）。因此，这个计数器能容纳的最大值为 $n$。与变量 `current_node` 类似，存储一个不大于 $n$ 的整数值需要 $O(\\log n)$ 的空间。\n\n第三，算法在步骤5中非确定性地选择一个邻居 `next_node`。机器可能需要一些临时的暂存空间，用来从输入带读取邻居的ID，并在覆盖 `current_node` 之前暂存它。任何邻居的ID也是一个介于 $1$ 和 $n$ 之间的整数，因此存储这个临时值也需要 $O(\\log n)$ 的空间。\n\n工作带上所需的总空间是算法必须跟踪的所有变量所需空间之和。这包括 `current_node`、`steps_taken` 以及过程中使用的任何临时变量。\n\n总空间 = `current_node`所需空间 + `steps_taken`所需空间 + 临时变量所需空间\n总空间 = $O(\\log n) + O(\\log n) + O(\\log n)$\n\n有限个 $O(\\log n)$ 项的和仍然是 $O(\\log n)$。\n\n因此，算法在工作带上的总空间复杂度是 $O(\\log n)$。这意味着无向图s-t连通性问题属于复杂度类 $NL$（非确定性对数空间）。\n\n让我们评估一下给出的选项：\nA. $O(1)$: 这意味着空间是常数级别的，与服务器数量 $n$ 无关。这是不正确的，因为我们需要存储服务器标签，其大小取决于 $n$。\nB. $O(\\log n)$: 这与我们的推导相符。\nC. $O(n)$: 如果算法需要存储其遍历过的完整路径，那么空间复杂度将是 $O(n)$。所描述的算法巧妙地通过只存储当前位置来避免了这种情况。\nD. $O(n \\log n)$: 这可能对应于存储一条长度最多为 $n$ 的路径，其中每个节点ID需要 $O(\\log n)$ 的空间。同样，该算法不这样做。\nE. $O(n^2)$: 这可能是将在工作带上存储图的邻接矩阵表示所需的空间，而该算法并非如此操作。\n\n因此，选项中最紧的上界是 $O(\\log n)$。", "answer": "$$\\boxed{B}$$", "id": "1453163"}, {"introduction": "在掌握了对数空间路径查找的基础知识后，我们现在来解决一个更细致的问题。这个练习挑战你判断是否存在具有特定属性的路径——在本例中，是穿过奇数个特殊“切换”顶点的路径。解决问题的关键在于增强机器的状态，以在不超过对数空间限制的情况下跟踪额外信息（奇偶性），这是复杂性理论中一个强大且广泛使用的技巧。[@problem_id:1453142]", "problem": "在计算复杂性理论领域，我们分析解决计算问题所需的资源。考虑以下判定问题，我们称之为 `ODD-SWITCH-PATH`。\n\n该问题的一个实例由一个元组 $(G, S, s, t)$ 定义，其中：\n- $G = (V, E)$ 是一个有向图，其中 $V$ 是顶点集合，$E$ 是有向边集合。令 $|V| = k$。\n- $S \\subseteq V$ 是一个指定的非空顶点子集，我们称之为“切换点”(switchers)。\n- $s \\in V$ 是起始顶点。\n- $t \\in V$ 是目标顶点。\n\n一条从 $s$ 到 $t$ 的路径是一个顶点序列 $(v_0, v_1, \\ldots, v_m)$，使得 $v_0 = s$， $v_m = t$，并且对于所有 $i \\in \\{0, 1, \\ldots, m-1\\}$，有向边 $(v_i, v_{i+1}) \\in E$。注意，路径包含其起始和结束顶点。路径上的切换点数量是序列中也属于集合 $S$ 的顶点 $v_i$ 的计数。\n\n`ODD-SWITCH-PATH` 问题询问：给定一个实例 $(G, S, s, t)$，是否存在至少一条从 $s$ 到 $t$ 的路径，其包含奇数个切换点？\n\n下列哪个选项代表了已证明包含 `ODD-SWITCH-PATH` 问题的最紧确的、著名的复杂性类？\n\nA. L (确定性对数空间)\n\nB. NL (非确定性对数空间)\n\nC. P (多项式时间)\n\nD. NP (非确定性多项式时间)\n\nE. PSPACE (多项式空间)", "solution": "我们首先通过给出一个决定该语言的非确定性对数空间算法，来证明其包含在 $NL$ 中。设输入为 $(G, S, s, t)$，其中 $G = (V, E)$ 且 $|V| = k$。一台非确定性图灵机维护：\n- 当前顶点 $v \\in V$，使用 $O(\\log k)$ 比特，\n- 一个步数计数器 $c$，初始化为 $k$ 并在每一步递减，使用 $O(\\log k)$ 比特，\n- 一个奇偶校验位 $b \\in \\{0,1\\}$，表示到目前为止访问过的切换点数量模 $2$ 的奇偶性。\n\n初始化 $v := s$，如果 $s \\in S$ 则 $b := 1$，否则 $b := 0$。重复以下步骤直到停机：\n- 如果 $v = t$ 且 $b = 1$，则接受。\n- 如果 $c = 0$，则拒绝。\n- 否则，非确定性地选择一个邻居 $u$ 使得 $(v,u) \\in E$，设置 $v := u$，设置 $b := b \\oplus [u \\in S]$，并设置 $c := c - 1$。\n\n这使用了 $O(\\log k)$ 空间。正确性：如果存在一条从 $s$ 到 $t$ 的路径 $(v_{0},\\ldots,v_{m})$，其在 $S$ 中有奇数个顶点，那么就存在一条这样的简单路径，其长度 $m \\leq k-1$；该机器可以猜测这条路径，并在 $v = t$ 且 $b = 1$ 时接受。反之，任何接受的计算路径都对应于一条从 $s$ 到 $t$ 的顶点序列，其在 $t$ 处的奇偶校验位 $b$ 为 $1$，这意味着该路径上的切换点数量是奇数。因此，$\\text{ODD-SWITCH-PATH} \\in NL$。\n\n我们现在通过一个从有向 $s$-$t$ 可达性问题 $\\text{STCON}$（该问题是 $NL$-完全的）出发的对数空间多一归约来证明其 $NL$-困难性。给定一个 $\\text{STCON}$ 的实例 $(G, s, t)$，将其映射到 `ODD-SWITCH-PATH` 的实例 $(G, S, s, t)$，其中 $S := \\{t\\}$。这个映射在对数空间内是可计算的。我们断言：\n$$\n(G,s,t) \\in \\text{STCON} \\iff (G, \\{t\\}, s, t) \\in \\text{ODD-SWITCH-PATH}.\n$$\n($\\Rightarrow$) 如果存在一条从 $s$ 到 $t$ 的路径，那么就存在一条这样的简单路径，它在末尾只访问一次 $t$。由于 $S = \\{t\\}$，该路径上的切换点数量为 $1$，是奇数。\n($\\Leftarrow$) 如果在 $S = \\{t\\}$ 的设定下，存在一条从 $s$ 到 $t$ 的路径，其上有奇数个切换点，那么特别地，就存在一条从 $s$ 到 $t$ 的路径。因此该归约是正确的，从而确立了其 $NL$-困难性。\n\n综上，包含于 $NL$ 和 $NL$-困难性共同意味着 $\\text{ODD-SWITCH-PATH}$ 是 $NL$-完全的。因此，已证明包含该问题的最紧确的著名复杂性类是 $NL$。", "answer": "$$\\boxed{B}$$", "id": "1453142"}, {"introduction": "我们最后的练习将焦点从寻找路径转移到证明路径的不存在，这是一个概念上不同但同样重要的任务。我们将探讨验证一个图是否为无环图的问题，这对于像任务依赖调度这样的工作至关重要。这个练习将引导你理解补问题（complementary problem）的概念，以及 Immerman-Szelepcsényi 定理（即 $NL = co\\text{-}NL$）的深远意义。[@problem_id:1453166]", "problem": "考虑一个名为 `TASK-ORDERING-VALIDATION` 的计算问题。在此问题中，给定一个包含 $n$ 个任务的集合，记为 $T = \\{t_1, t_2, \\dots, t_n\\}$，以及一个包含 $m$ 个前置依赖关系的集合 $D$。每个依赖关系是一个有序对 $(t_i, t_j)$，表示任务 $t_i$ 必须在任务 $t_j$ 开始之前完成。该系统可以建模为一个有向图 $G=(V, E)$，其中顶点 $V$ 对应于任务集合 $T$，且当且仅当 $(t_i, t_j)$ 是 $D$ 中的一个依赖关系时，图中存在一条从顶点 $t_i$ 到顶点 $t_j$ 的有向边。\n\n所有任务的一个有效的顺序排序仅在依赖关系图不包含任何循环依赖（例如，任务A需要任务B，任务B需要任务C，而任务C又需要任务A）时才可能存在。这种循环依赖对应于图中的一个有向环，即一条由一条或多条边组成、起点和终点为同一顶点的路径。`TASK-ORDERING-VALIDATION` 问题是判定给定的任务和依赖关系集合是否不含循环依赖。用图论的术语来说，这等价于确定对应的有向图 $G$ 是否为一个有向无环图（DAG）。\n\n令 $NL$ 为可由非确定性图灵机使用对数量级的内存空间（$O(\\log |input|)$）解决的判定问题的复杂度类，令 $co\\text{-}NL$ 为其补问题在 $NL$ 中的问题的类别。基于这些复杂度类的基本性质，关于 `TASK-ORDERING-VALIDATION` 问题的以下哪个陈述是正确的？\n\n假设图以标准格式（例如，邻接表）表示，使其输入规模是 $n$ 和 $m$ 的多项式。\n\nA. `TASK-ORDERING-VALIDATION` 在 $NL$ 中，但尚不清楚它是否在 $co\\text{-}NL$ 中。\n\nB. `TASK-ORDERING-VALIDATION` 在 $co\\text{-}NL$ 中，但尚不清楚它是否在 $NL$ 中。\n\nC. 已知 `TASK-ORDERING-VALIDATION` 在 $P$ 中，但尚不清楚它是否在 $NL$ 或 $co\\text{-}NL$ 中。\n\nD. `TASK-ORDERING-VALIDATION` 同时在 $NL$ 和 $co\\text{-}NL$ 中。\n\nE. `TASK-ORDERING-VALIDATION` 是 $NP$-hard 的。", "solution": "我们将该实例建模为一个有向图 $G=(V,E)$，其中 $|V|=n$ 且 $|E|=m$。该问题询问 $G$ 是否是无环的，即 $G$ 是否不包含有向环。令 $ACYCLIC$ 表示这个判定问题，令 $CYCLE$ 表示其补问题，即询问 $G$ 是否包含一个有向环。形式上，$ACYCLIC=\\overline{CYCLE}$。\n\n步骤 1（证明 $CYCLE \\in \\mathrm{NL}$）：我们描述一个用于 $CYCLE$ 的非确定性对数空间算法。\n- 非确定性地选择一个起始顶点 $v_{0} \\in V$，并使用 $O(\\log n)$ 比特存储其索引。\n- 维护一个计数器 $c$，初始化为 $1$ 且上界为 $n$，用 $O(\\log n)$ 比特存储。\n- 维护当前顶点 $v$，初始化为 $v_{0}$，用 $O(\\log n)$ 比特存储。\n- 重复以下步骤：非确定性地选择一条出边 $(v,u) \\in E$（通过猜测一个邻居的索引并从输入中验证），设置 $v \\leftarrow u$，并增加 $c$。如果在任何步骤中 $v=v_{0}$ 且 $c \\geq 1$，则接受。如果 $c$ 超过 $n$，则在此计算分支上拒绝。\n正确性：如果 $G$ 有一个有向环，那么存在一个长度为 $k$ 的简单环，其中 $1 \\leq k \\leq n$。该机器可以通过选择环上的 $v_{0}$ 并猜测沿着环的 $k$ 条边来猜中这个环，从而在最多 $n$ 步内回到 $v_{0}$ 并接受。如果 $G$ 没有环，那么任何不超过 $n$ 次的边遍历序列在至少一步之后都不会返回到 $v_{0}$，因此没有接受分支。空间：我们存储 $v_{0}$、$v$ 和计数器 $c$，每个都占用 $O(\\log n)$ 比特，外加用于扫描输入和验证边的常数工作空间；因此总空间为 $O(\\log |input|)$。所以 $CYCLE \\in \\mathrm{NL}$。\n\n步骤 2（补问题和 co-NL）：由于 $ACYCLIC=\\overline{CYCLE}$ 且 $CYCLE \\in \\mathrm{NL}$，根据 $co\\text{-}NL$ 的定义，可得 $ACYCLIC \\in \\mathrm{co\\text{-}NL}$。\n\n步骤 3（Immerman–Szelepcsényi 定理）：根据 Immerman–Szelepcsényi 定理，$\\mathrm{NL}=\\mathrm{co\\text{-}NL}$。因此 $ACYCLIC$ 也属于 $\\mathrm{NL}$。\n\n步骤 4（与已知的多项式时间算法的一致性）：另外，通过例如深度优先搜索或用于拓扑排序的 Kahn 算法，可知 $ACYCLIC \\in \\mathrm{P}$。这与上述结论不矛盾，并且在标准假设下支持了该问题不是 $NP$-hard 的观点。在给定的选项中，唯一正确的陈述是该问题同时属于 $\\mathrm{NL}$ 和 $\\mathrm{co\\text{-}NL}$。\n\n因此，正确选项是 D。", "answer": "$$\\boxed{D}$$", "id": "1453166"}]}