{"hands_on_practices": [{"introduction": "掌握量化布尔公式 (QBF) 的第一步是学会如何确定其真值。本练习将通过一个基础的公式 [@problem_id:1440116] 来引导你实践这一核心技能。通过分析交替出现的量词（“对于所有”和“存在”），你将体验到量化计算的“游戏”本质，从而为理解更复杂的公式奠定坚实的基础。", "problem": "在计算复杂性理论中，量化布尔公式（Quantified Boolean Formula, QBF）是一种在经典命题逻辑的基础上，增加了对布尔变量的量词的公式。QBF 的真值是通过对量词进行求值来确定的，这些量词将变量绑定到 TRUE 或 FALSE 值。全称量词 $\\forall x$ 表示其后的公式对于 $x$ 的所有可能取值都必须为真，而存在量词 $\\exists x$ 表示其后的公式对于 $x$ 的至少一个可能取值必须为真。\n\n设逻辑运算符表示为 $\\land$ (AND)、$\\lor$ (OR) 和 $\\neg$ (NOT)。为了提供一个数值答案，设真值 TRUE 由整数 $1$ 表示，真值 FALSE 由整数 $0$ 表示。\n\n确定以下量化布尔公式的真值所对应的整数值：\n$$ \\forall a \\exists b ((a \\land b) \\lor (\\neg a \\land \\neg b)) $$", "solution": "我们首先简化量词内部的联结词矩阵。根据双条件句的定义，命题等价式\n$$\n(a \\land b) \\lor (\\neg a \\land \\neg b) \\equiv a \\leftrightarrow b\n$$\n成立。因此，给定的 QBF 等价于\n$$\n\\forall a \\ \\exists b \\ (a \\leftrightarrow b).\n$$\n为了对此求值，我们固定 $a$ 的一个任意值。我们通过选择\n$$\nb := a.\n$$\n来为存在量词提供一个见证(witness)。\n将 $b=a$ 代入内部公式，得到\n$$\n(a \\land a) \\lor (\\neg a \\land \\neg a).\n$$\n根据幂等律，$a \\land a = a$ 且 $\\neg a \\land \\neg a = \\neg a$，因此表达式简化为\n$$\na \\lor \\neg a,\n$$\n根据排中律，这是一个重言式，因此对于任何 $a$ 其值都为 TRUE。因此，对于每一个 $a$，都存在一个 $b$ (具体来说是 $b=a$) 使得内部公式为真。所以，这个全称量化语句为真。\n\n根据题目的约定，TRUE 对应整数 $1$。", "answer": "$$\\boxed{1}$$", "id": "1440116"}, {"introduction": "在掌握了基础求值之后，我们来探讨一个量化逻辑中至关重要且容易出错的概念：量词的顺序。本练习 [@problem_id:1440153] 通过对比两个看似相似但顺序颠倒的公式，揭示了 $\\forall x \\exists y$ 和 $\\exists y \\forall x$ 之间语义上的巨大差异。理解这一点对于精确地构造和解读逻辑论证至关重要。", "problem": "在计算复杂性理论的研究中，量化布尔公式 (QBF) 是一种经典命题逻辑中的公式，其变量是量化的。量词 $\\forall$ (全称) 和 $\\exists$ (存在) 的取值范围是布尔域 `{True, False}`。QBF 的求值问题是复杂性类 PSPACE 中的一个基本问题。\n\n考虑逻辑蕴含算子 $\\to$，其中 $A \\to B$ 为 `False` 当且仅当 `A` 为 `True` 且 `B` 为 `False`；在其他情况下，其值为 `True`。\n\n计算下面两个 QBF 的真值：\n1.  $F_1 = \\forall x \\exists y (x \\to y)$\n2.  $F_2 = \\exists y \\forall x (x \\to y)$\n\n根据您的计算，从以下选项中选择正确的陈述。\n\nA. $F_1$ 为真且 $F_2$ 为真。\n\nB. $F_1$ 为真且 $F_2$ 为假。\n\nC. $F_1$ 为假且 $F_2$ 为真。\n\nD. $F_1$ 为假且 $F_2$ 为假。", "solution": "我们使用蕴含的命题等价式：对于任意命题 $A$ 和 $B$，$A \\to B \\equiv \\lnot A \\lor B$。\n\n计算 $F_{1}$：\n$$\nF_{1}=\\forall x \\exists y\\,(x \\to y) \\equiv \\forall x \\exists y\\,(\\lnot x \\lor y).\n$$\n考虑 $x$ 的两种可能的真值：\n- 如果 $x$ 为真，那么 $\\lnot x$ 为假，所以 $\\lnot x \\lor y$ 化简为 $y$。此时，通过选择 $y$ 为真，$\\exists y\\,(y)$ 成立。\n- 如果 $x$ 为假，那么 $\\lnot x$ 为真，所以无论 $y$ 的取值如何，$\\lnot x \\lor y$ 都为真，因此 $\\exists y\\,(\\lnot x \\lor y)$ 成立。\n\n因此，对于每一个 $x$，都存在一个 $y$ 使得 $x \\to y$ 为真，所以 $F_{1}$ 为真。\n\n计算 $F_{2}$：\n$$\nF_{2}=\\exists y \\forall x\\,(x \\to y) \\equiv \\exists y \\forall x\\,(\\lnot x \\lor y).\n$$\n选择 $y$ 为真。那么对于任意的 $x$，由于 $y$ 为真，$\\lnot x \\lor y$ 也为真。因此，对于这个 $y$ 的选择，$\\forall x\\,(\\lnot x \\lor y)$ 成立，所以存在量词得到满足。因此 $F_{2}$ 为真。\n\n$F_{1}$ 和 $F_{2}$ 都为真，这对应于选项 A。", "answer": "$$\\boxed{A}$$", "id": "1440153"}, {"introduction": "最后一个练习将展示量化布尔公式作为一种强大描述语言的真正威力。在这个思想实验中 [@problem_id:1464839]，你的任务是构建一个 QBF，它能够精确表达“另一个公式 $\\phi$ 恰好有一个满足解”这一复杂属性。这个过程不仅能加深你对 QBF 表达能力的理解，也揭示了其在计算复杂性理论中用于编码问题的核心作用。", "problem": "在计算复杂性理论中，量化布尔公式（Quantified Boolean Formula, QBF）是一种在经典命题逻辑的基础上，通过对布尔变量使用量词（$\\forall$ 表示“对所有”和 $\\exists$ 表示“存在”）而扩展出来的公式。真量化布尔公式（True Quantified Boolean Formula, TQBF）是一个没有自由变量的QBF，其求值结果为真或假。\n\n考虑一个依赖于两个布尔变量 $x_1$ 和 $x_2$ 的命题公式 $\\phi(x_1, x_2)$。你的任务是选择一个TQBF，该TQBF为真当且仅当 $\\phi(x_1, x_2)$ 恰好有一个满足赋值。\n\n为清楚起见，在下面的选项中，我们为两个赋值的相等性引入一种简写表示法。令表达式 $((x_1, x_2) = (y_1, y_2))$ 等价于布尔公式 $((x_1 \\iff y_1) \\land (x_2 \\iff y_2))$。\n\n下列哪个TQBF正确地表达了 $\\phi(x_1, x_2)$ 恰好有一个满足赋值的性质？\n\nA. $\\exists x_1 \\exists x_2 \\left( \\phi(x_1, x_2) \\land \\forall y_1 \\forall y_2 \\left( \\phi(y_1, y_2) \\implies ((x_1, x_2) = (y_1, y_2)) \\right) \\right)$\n\nB. $\\exists x_1 \\exists x_2 \\left( \\phi(x_1, x_2) \\land \\forall y_1 \\forall y_2 \\left( ((x_1, x_2) = (y_1, y_2)) \\implies \\phi(y_1, y_2) \\right) \\right)$\n\nC. $\\exists x_1 \\exists x_2 \\exists y_1 \\exists y_2 \\left( \\phi(x_1,x_2) \\land \\phi(y_1,y_2) \\land \\neg((x_1,x_2)=(y_1,y_2)) \\right)$\n\nD. $\\forall x_1 \\forall x_2 \\forall y_1 \\forall y_2 \\left( (\\phi(x_1,x_2) \\land \\phi(y_1,y_2)) \\implies ((x_1,x_2)=(y_1,y_2)) \\right)$", "solution": "我们需要一个TQBF，它为真当且仅当存在唯一一个赋值 $(x_{1},x_{2}) \\in \\{0,1\\}^{2}$ 使得 $\\phi(x_{1},x_{2})$ 为真。“恰好有一个满足赋值”的逻辑表述是存在性（existence）和唯一性（uniqueness）的合取：\n1) 存在性：$\\exists x_{1}\\exists x_{2}\\,\\phi(x_{1},x_{2})$。\n2) 唯一性：对于特定的见证 $(x_{1},x_{2})$，有 $\\forall y_{1}\\forall y_{2}\\,(\\phi(y_{1},y_{2}) \\implies ((x_{1},x_{2})=(y_{1},y_{2})))$。\n\n将这两者合并成一个公式可得：\n$$\n\\exists x_{1}\\exists x_{2}\\left(\\phi(x_{1},x_{2}) \\land \\forall y_{1}\\forall y_{2}\\left(\\phi(y_{1},y_{2}) \\implies ((x_{1},x_{2})=(y_{1},y_{2}))\\right)\\right),\n$$\n这与选项A匹配。\n\n现在我们来精确地验证每个选项：\n\n- 选项A表述为：\n$$\n\\exists x_{1}\\exists x_{2}\\left(\\phi(x_{1},x_{2}) \\land \\forall y_{1}\\forall y_{2}\\left(\\phi(y_{1},y_{2}) \\implies ((x_{1},x_{2})=(y_{1},y_{2}))\\right)\\right).\n$$\n该公式断言存在一个满足赋值 $(x_{1},x_{2})$，并且任何满足赋值 $(y_{1},y_{2})$ 都必须与它相等。这正是“恰好有一个满足赋值”的定义。\n\n- 选项B表述为：\n$$\n\\exists x_{1}\\exists x_{2}\\left(\\phi(x_{1},x_{2}) \\land \\forall y_{1}\\forall y_{2}\\left(((x_{1},x_{2})=(y_{1},y_{2})) \\implies \\phi(y_{1},y_{2})\\right)\\right).\n$$\n对于任何使得 $\\phi(x_{1},x_{2})$ 为真的固定赋值 $(x_{1},x_{2})$，蕴含式 $((x_{1},x_{2})=(y_{1},y_{2})) \\implies \\phi(y_{1},y_{2})$ 对所有的 $(y_{1},y_{2})$ 都成立：如果 $(y_{1},y_{2})=(x_{1},x_{2})$，那么因为 $\\phi(x_{1},x_{2})$ 为真，所以 $\\phi(y_{1},y_{2})$ 也为真；如果 $(y_{1},y_{2})\\neq(x_{1},x_{2})$，那么前件为假，蕴含式为真。因此，只要给定 $\\phi(x_{1},x_{2})$ 为真，这个全称量化条件就总是满足的。整个公式等价于 $\\exists x_{1}\\exists x_{2}\\,\\phi(x_{1},x_{2})$，它表达的是“至少有一个满足赋值”，而不是唯一性。\n\n- 选项C表述为：\n$$\n\\exists x_{1}\\exists x_{2}\\exists y_{1}\\exists y_{2}\\left(\\phi(x_{1},x_{2}) \\land \\phi(y_{1},y_{2}) \\land \\neg((x_{1},x_{2})=(y_{1},y_{2}))\\right),\n$$\n该公式断言存在两个不同的满足赋值。这表达的是“至少有两个”，与唯一性相反。\n\n- 选项D表述为：\n$$\n\\forall x_{1}\\forall x_{2}\\forall y_{1}\\forall y_{2}\\left((\\phi(x_{1},x_{2}) \\land \\phi(y_{1},y_{2})) \\implies ((x_{1},x_{2})=(y_{1},y_{2}))\\right),\n$$\n该公式断言不存在两个不同的满足赋值。这表达的是“至多有一个满足赋值”，但不能保证存在性。因此，它允许零个满足赋值，而不是恰好一个。\n\n因此，只有选项A正确地表达了 $\\phi(x_{1},x_{2})$ 恰好有一个满足赋值。", "answer": "$$\\boxed{A}$$", "id": "1464839"}]}