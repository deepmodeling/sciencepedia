{"hands_on_practices": [{"introduction": "在深入研究解决无向 $s$-$t$ 连通性问题的对数空间算法之前，我们首先需要理解为什么像深度优先搜索（DFS）这样常见的图遍历算法不满足严格的空间限制。通过分析标准 DFS 实现的空间复杂度，我们可以明确对数空间计算所面临的核心挑战。这个练习 [@problem_id:1468444] 将帮助你巩固对算法空间复杂度的理解，并为后续学习更高效的算法奠定基础。", "problem": "考虑 $s$-$t$ 连通性判定问题：给定一个包含 $n = |V|$ 个顶点的无权无向图 $G=(V,E)$ 以及两个指定的顶点 $s$ 和 $t$，目标是确定它们之间是否存在一条路径。一种常见的方法是实现递归的深度优先搜索（DFS）算法。这种标准实现使用辅助空间主要用于两个目的：\n\n1.  一个显式的数据结构，例如布尔数组或哈希集合，用于记录所有已访问过的顶点，以防止无限循环。\n2.  系统的递归调用栈，它隐式地存储了当前搜索路径的上下文。\n\n在计算复杂性理论中，L 类包含那些可以由确定性图灵机仅使用对数级别内存（$O(\\log n)$）解决的判定问题。Omer Reingold 的一项里程碑式成果证明了无向图的 $s$-$t$ 连通性问题属于 L 类。这意味着存在一个解决此问题的算法，其空间界限为对数级别。然而，上述标准的递归 DFS 实现不满足这个界限。\n\n对于一个有 $n$ 个顶点的图，这种标准的递归 DFS 实现所需辅助空间复杂度的最紧的最坏情况渐近界是多少？\n\nA. $O(\\log n)$\n\nB. $O(n)$\n\nC. $O(n \\log n)$\n\nD. $O(n+m)$, 其中 $m = |E|$\n\nE. $O(n^{2})$", "solution": "我们将辅助空间定义为超出输入图表示本身所使用的内存。在用于解决具有 $n$ 个顶点的无向图 $s$-$t$ 连通性问题的标准递归 DFS 中，有两个辅助空间组成部分：\n\n1) 已访问集合：一个布尔数组或哈希集合，用于标记每个顶点是否已被访问，以避免在有环图中的无限递归。这需要为每个顶点存储一个标志，共 $n$ 个条目，因此该结构的辅助空间为 $O(n)$。\n\n2) 递归调用栈：在最坏情况下（例如，一个有 $n$ 个顶点的路径图），DFS 会沿着一条简单路径进行，递归深度达到 $n$。每个栈帧存储固定大小的信息（例如当前顶点、循环索引或迭代器状态、以及返回地址），每个栈帧的空间为 $O(1)$。因此，在最坏情况下，递归栈使用的空间为 $O(n)$。\n\n将这两部分的贡献相加，得到的总辅助空间为 $O(n) + O(n) = O(n)$。这个界是紧的：在路径图上，由于已访问结构和最大递归深度，该算法确实使用 $\\Theta(n)$ 的辅助空间。输入表示（例如，需要 $O(n+m)$ 空间的邻接表）不计入辅助空间。\n\n因此，最紧的最坏情况渐近界是 $O(n)$，对应于选项 B。", "answer": "$$\\boxed{B}$$", "id": "1468444"}, {"introduction": "克服了标准 DFS 的空间限制后，我们来探索一种替代方案：基于分治思想的递归算法。这种方法的核心是将寻找长路径的问题分解为寻找若干短路径的子问题，从而在有限的空间内完成搜索。通过在一个简单的四顶点环形图上追踪这个递归过程 [@problem_id:1468448]，你将亲手体验算法是如何通过寻找中间点来逐步确认路径存在性的，从而直观地理解其工作原理。", "problem": "考虑一个在无向图中确定两个顶点之间是否存在路径的问题，该问题通常被称为 `$s$-$t$ 连通性` (st-connectivity)。一个解决此问题的著名递归算法，其灵感来自 Savitch 定理，其工作原理是重复搜索中间顶点。设图为 $G = (V, E)$，其中 $V$ 是顶点集，$E$ 是边集。该算法由函数 $\\text{PATH}(u, v, k)$ 定义，如果从顶点 $u$ 到顶点 $v$ 存在一条长度最多为 $k$ 的路径，则该函数返回 `true`，否则返回 `false`。路径的长度是其包含的边的数量。对于此问题，假设 $k$ 始终是 2 的幂。\n\n函数 $\\text{PATH}(u, v, k)$ 的定义如下：\n- **基本情况**：如果 $k=1$，$\\text{PATH}(u, v, 1)$ 在 $u=v$ 或 $(u, v)$ 是 $E$ 中的一条边时返回 `true`。否则，返回 `false`。\n- **递归步骤**：如果 $k > 1$，函数会遍历所有顶点 $w \\in V$。对于每个 $w$，它会进行两次递归调用：$\\text{PATH}(u, w, k/2)$ 和 $\\text{PATH}(w, v, k/2)$。如果对于任何顶点 $w$，这两个调用都返回 `true`，那么 $\\text{PATH}(u, v, k)$ 会立即返回 `true`。如果循环结束仍未找到这样的 $w$，则函数返回 `false`。\n\n给定一个 4 顶点的环形图 $C_4$，其顶点集为 $V = \\{v_1, v_2, v_3, v_4\\}$。边集为 $E = \\{(v_1, v_2), (v_2, v_3), (v_3, v_4), (v_4, v_1)\\}$。\n\n考虑初始调用 $\\text{PATH}(v_1, v_3, 4)$。在此调用的执行过程中，算法将测试 $V$ 中的每个顶点作为潜在的中间顶点 $w$。所有能使 $\\text{PATH}(v_1, w, 2)$ 和 $\\text{PATH}(w, v_3, 2)$ 这两个递归调用都返回 `true` 的顶点 $w$ 构成了下列哪个集合？\n\nA. $\\{v_2, v_4\\}$\n\nB. $\\{v_1, v_3\\}$\n\nC. $\\{v_2\\}$\n\nD. $\\{v_1, v_2, v_3, v_4\\}$\n\nE. $\\{v_1, v_2, v_4\\}$", "solution": "我们得到了无向图中 $s$-$t$ 连通性问题的递归决策过程。对于 $k=1$，基本情况当且仅当 $u=v$ 或 $(u,v)\\in E$ 时返回 `true`。对于 $k>1$ 且 $k$ 为 2 的幂，递归步骤当且仅当存在某个 $w\\in V$，使得两个长度限制减半的递归调用都返回 `true` 时，才返回 `true`。特别地，对于 $k=2$，定义蕴含了：\n$$\n\\text{PATH}(u,v,2)\\ \\text{is true} \\iff \\exists\\,x\\in V:\\ \\text{PATH}(u,x,1)\\ \\wedge\\ \\text{PATH}(x,v,1).\n$$\n根据基本情况，$\\text{PATH}(a,b,1)$ 为 `true` 当且仅当 $a=b$ 或 $(a,b)\\in E$。因此，$\\text{PATH}(u,v,2)$ 为 `true` 当且仅当存在一个 $x$ 使得 $u=x$ 或 $(u,x)\\in E$，并且 $x=v$ 或 $(x,v)\\in E$。这等价于说 $u$ 和 $v$ 之间的图距离至多为 $2$。\n\n该图是 4-环图 $C_{4}$，其 $V=\\{v_{1},v_{2},v_{3},v_{4}\\}$ 且 $E=\\{(v_{1},v_{2}),(v_{2},v_{3}),(v_{3},v_{4}),(v_{4},v_{1})\\}$。从 $v_{1}$ 出发的距离为：\n- $d(v_{1},v_{1})=0$，\n- $d(v_{1},v_{2})=1$，\n- $d(v_{1},v_{4})=1$，\n- $d(v_{1},v_{3})=2$。\n因此，对每个 $w\\in V$，$\\text{PATH}(v_{1},w,2)$ 都为 `true`。\n\n类似地，到 $v_{3}$ 的距离为：\n- $d(v_{3},v_{3})=0$，\n- $d(v_{3},v_{2})=1$，\n- $d(v_{3},v_{4})=1$，\n- $d(v_{3},v_{1})=2$。\n因此，对每个 $w\\in V$，$\\text{PATH}(w,v_{3},2)$ 都为 `true`。\n\n我们也可以为每个 $w$ 明确地找出所需的中间点以满足递归定义：\n- 对于 $w=v_{1}$：$\\text{PATH}(v_{1},v_{1},2)$ 为 `true`（通过 $x=v_{1}$），且 $\\text{PATH}(v_{1},v_{3},2)$ 为 `true`（通过 $x=v_{2}$ 或 $x=v_{4}$）。\n- 对于 $w=v_{2}$：$\\text{PATH}(v_{1},v_{2},2)$ 为 `true`（通过 $x=v_{1}$ 或 $x=v_{2}$），且 $\\text{PATH}(v_{2},v_{3},2)$ 为 `true`（通过 $x=v_{2}$ 或 $x=v_{3}$）。\n- 对于 $w=v_{3}$：$\\text{PATH}(v_{1},v_{3},2)$ 为 `true`（通过 $x=v_{2}$ 或 $x=v_{4}$），且 $\\text{PATH}(v_{3},v_{3},2)$ 为 `true`（通过 $x=v_{3}$）。\n- 对于 $w=v_{4}$：$\\text{PATH}(v_{1},v_{4},2)$ 为 `true`（通过 $x=v_{1}$ 或 $x=v_{4}$），且 $\\text{PATH}(v_{4},v_{3},2)$ 为 `true`（通过 $x=v_{4}$ 或 $x=v_{3}$）。\n\n因此，对于每个 $w\\in\\{v_{1},v_{2},v_{3},v_{4}\\}$，$\\text{PATH}(v_{1},w,2)$ 和 $\\text{PATH}(w,v_{3},2)$ 的评估结果都为 `true`。正确的子集是 $\\{v_{1},v_{2},v_{3},v_{4}\\}$，对应于选项 D。", "answer": "$$\\boxed{D}$$", "id": "1468448"}, {"introduction": "一个优秀的算法不仅要能正确地“找到”路径，还必须能够可靠地“确认”路径不存在。这个练习 [@problem_id:1468381] 将检验递归算法在图不连通情况下的表现。通过分析一个由两个互不相连的团组成的特殊图，你将深入探究算法是如何通过递归调用返回的 `true` 和 `false` 值，最终正确地判断出起点 $s$ 和终点 $t$ 之间没有路径的。", "problem": "无向图 $s$-$t$ 连通性问题旨在判断在一个无向图中，两个顶点 $s$ 和 $t$ 之间是否存在一条路径。这是复杂度理论中的一个基石问题，由 Omer Reingold 证明其可以在对数空间（L）内解决，这个证明十分著名。该证明涉及一个递归算法。现在我们考虑该算法的一个简化概念版，名为 $\\text{ExplorePath}$。\n\n函数 $\\text{ExplorePath}(u, v, d)$ 用于确定在给定图 $G=(V, E)$ 中，顶点 $u$ 和 $v$ 之间是否存在一条长度至多为 $2^d$ 的路径。其逻辑定义如下：\n\n- **基本情况 ($d=0$)：** 如果 $u=v$ 或者 $(u, v)$ 是 $E$ 中的一条边，则函数返回 `true`。否则，返回 `false`。\n- **递归步骤 ($d>0$)：** 函数遍历顶点集 $V$ 中的每个顶点 $w$。如果能找到任何一个顶点 $w$，使得 $\\text{ExplorePath}(u, w, d-1)$ 和 $\\text{ExplorePath}(w, v, d-1)$ *都* 返回 `true`，那么函数立即停止并返回 `true`。如果遍历完所有可能的顶点 $w$ 之后仍未找到这样的顶点，函数则返回 `false`。\n\n现在，考虑一个有10个顶点的无向图 $G$，其顶点集为 $V = \\{v_1, v_2, \\ldots, v_{10}\\}$。该顶点集被划分为两个不相交的集合：$C_1 = \\{v_1, v_2, v_3, v_4, v_5\\}$ 和 $C_2 = \\{v_6, v_7, v_8, v_9, v_{10}\\}$。图的边定义如下：在每个集合（$C_1$ 或 $C_2$）内部，顶点构成一个团（即，每个顶点都与同一集合中的所有其他顶点通过边相连）。$C_1$ 中的任何顶点与 $C_2$ 中的任何顶点之间都没有边相连。\n\n为了确定起始顶点 $s = v_1$ 和目标顶点 $t = v_{10}$ 之间是否存在路径，进行了一次初始调用 $\\text{ExplorePath}(s, t, k)$，其中 $k = \\lceil \\log_2(N) \\rceil$，而 $N=10$ 是顶点的总数。\n\n对于这个特定的图以及选定的 $s$ 和 $t$，以下哪个陈述准确地描述了该算法执行过程的一个关键方面？\n\nA. 在执行过程中，至少有一次对 $\\text{ExplorePath}(u, v, 1)$ 的调用会返回 `true`，其中 $u \\in C_1$ 且 $v \\in C_2$。\n\nB. 算法终止并返回 `false`，因为对于同一团中的一对不同顶点 $(u, v)$，一次基本情况调用 $\\text{ExplorePath}(u, v, 0)$ 返回了 `false`。\n\nC. 对于在初始调用 $\\text{ExplorePath}(v_1, v_{10}, k)$ 中作为中间点测试的每个顶点 $w$，其对应的两个递归子调用 $\\text{ExplorePath}(v_1, w, k-1)$ 和 $\\text{ExplorePath}(w, v_{10}, k-1)$ 都将返回 `false`。\n\nD. 对于在初始调用 $\\text{ExplorePath}(v_1, v_{10}, k)$ 中作为中间点测试的每个顶点 $w$，其对应的两个递归子调用 $\\text{ExplorePath}(v_1, w, k-1)$ 或 $\\text{ExplorePath}(w, v_{10}, k-1)$ 中恰好有一个会返回 `true`。\n\nE. 初始调用 $\\text{ExplorePath}(v_1, v_{10}, k)$ 最终返回 `true`。", "solution": "该图有两个不相交的团，$C_{1}=\\{v_{1},v_{2},v_{3},v_{4},v_{5}\\}$ 和 $C_{2}=\\{v_{6},v_{7},v_{8},v_{9},v_{10}\\}$，且 $C_{1}$ 和 $C_{2}$ 之间没有边。因此，对于所有 $u \\in C_{1}$ 和 $v \\in C_{2}$，它们之间不存在任何长度的路径。特别地，对于所有 $d \\geq 0$，任何 $u \\in C_{1}$ 和任何 $v \\in C_{2}$ 之间都不存在长度至多为 $2^{d}$ 的路径。\n\n根据基本情况的定义，当 $d=0$ 时，$\\text{ExplorePath}(u,v,0)$ 返回 true 当且仅当 $u=v$ 或 $(u,v) \\in E$。由于每个 $C_{i}$ 都是一个团，对于同一团中不同的 $u,v \\in C_{i}$，我们有 $(u,v) \\in E$，因此对于同一团中不同的 $u,v$，$\\text{ExplorePath}(u,v,0)=\\text{true}$。对于 $u \\in C_{1}$ 和 $v \\in C_{2}$，有 $(u,v) \\notin E$，因此 $\\text{ExplorePath}(u,v,0)=\\text{false}$。\n\n我们调用 $\\text{ExplorePath}(v_{1},v_{10},k)$，其中 $k=\\lceil \\log_{2}(N) \\rceil$ 且 $N=10$。在此初始调用中，算法会遍历所有 $w \\in V$，并检查 $\\text{ExplorePath}(v_{1},w,k-1)$ 和 $\\text{ExplorePath}(w,v_{10},k-1)$ 是否都返回 true。\n\n- 如果 $w \\in C_{1}$，那么在团内部 $v_{1}$ 和 $w$ 之间存在一条长度为 1 的路径，因此 $\\text{ExplorePath}(v_{1},w,k-1)=\\text{true}$，因为 $1 \\leq 2^{k-1}$。然而，从任何 $w \\in C_{1}$ 到 $v_{10} \\in C_{2}$ 都完全没有路径，所以 $\\text{ExplorePath}(w,v_{10},k-1)=\\text{false}$。\n\n- 如果 $w \\in C_{2}$，那么从 $v_{1} \\in C_{1}$ 到 $w \\in C_{2}$ 没有路径，所以 $\\text{ExplorePath}(v_{1},w,k-1)=\\text{false}$，而从 $w$ 到 $v_{10}$ 在 $C_{2}$ 内部存在一条长度至多为 1 的路径，所以 $\\text{ExplorePath}(w,v_{10},k-1)=\\text{true}$。\n\n- 特殊情况 $w=v_{1}$ 和 $w=v_{10}$ 也符合相同的模式：对于 $w=v_{1}$，$\\text{ExplorePath}(v_{1},v_{1},k-1)=\\text{true}$ 且 $\\text{ExplorePath}(v_{1},v_{10},k-1)=\\text{false}$；对于 $w=v_{10}$，$\\text{ExplorePath}(v_{1},v_{10},k-1)=\\text{false}$ 且 $\\text{ExplorePath}(v_{10},v_{10},k-1)=\\text{true}$。\n\n因此，对于每个 $w \\in V$，两个子调用中恰好一个为 true，另一个为 false：\n$$\n\\forall w \\in V:\\quad \\left(\\text{ExplorePath}(v_{1},w,k-1),\\,\\text{ExplorePath}(w,v_{10},k-1)\\right) \\in \\{(\\text{true},\\text{false}),(\\text{false},\\text{true})\\}.\n$$\n因此，不存在任何 $w$ 使得两个子调用都返回 true，所以初始调用返回 false。这排除了选项 A、B、C 和 E，并与选项 D 完全匹配。", "answer": "$$\\boxed{D}$$", "id": "1468381"}]}