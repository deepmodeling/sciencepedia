{"hands_on_practices": [{"introduction": "掌握 2-SAT 算法的第一步是熟练地将逻辑子句转换为蕴含图中的有向边。这个练习将让你直接实践构建蕴含图，并通过从一个给定的起点出发，追踪图中的路径来探索其结构。通过这个过程，你将能直观地理解逻辑约束是如何在系统中传播的 [@problem_id:1410675]。", "problem": "计算机科学中的一个常见问题是确定布尔公式的可满足性。对于2-合取范式 (2-CNF) 的公式，即每个子句最多是两个文字的析取的公式，存在一种基于图论的高效算法。本问题探讨了此类算法核心的图构建过程的行为。\n\n其过程如下：给定一个包含 $n$ 个变量 $\\{x_1, \\dots, x_n\\}$ 的集合的2-CNF公式 $\\phi$，我们构建一个有向图。该图的顶点集由 $2n$ 个顶点组成，每个文字（即每个 $x_i$ 及其否定 $\\neg x_i$）都对应一个独立的顶点。对于公式 $\\phi$ 中存在的每个形如 $(a \\lor b)$ 的子句，在图中添加两条有向边：一条从代表 $\\neg a$ 的顶点到代表 $b$ 的顶点的边，以及一条从代表 $\\neg b$ 的顶点到代表 $a$ 的顶点的边。\n\n考虑一个定义在六个变量 $\\{x_1, x_2, x_3, x_4, x_5, x_6\\}$ 上的特定2-CNF公式 $\\phi$。该公式由以下七个子句的合取 (AND) 给出：\n1.  $(x_1 \\lor \\neg x_1)$\n2.  $(\\neg x_2 \\lor x_1)$\n3.  $(x_3 \\lor \\neg x_2)$\n4.  $(x_4 \\lor \\neg x_3)$\n5.  $(x_5 \\lor \\neg x_4)$\n6.  $(x_6 \\lor \\neg x_5)$\n7.  $(x_2 \\lor \\neg x_6)$\n\n将上述过程应用于此公式 $\\phi$，确定从代表文字 $\\neg x_1$ 的顶点出发，通过任意长度（包括长度为零）的有向路径可达的独立顶点总数。", "solution": "我们按规定构建蕴含图：对于每个子句 $(a \\lor b)$，添加有向边 $\\neg a \\to b$ 和 $\\neg b \\to a$。顶点是 $12$ 个文字 $\\{x_i, \\neg x_i : i \\in \\{1, \\dots, 6\\}\\}$。\n\n处理每个子句以列出边：\n1. $(x_1 \\lor \\neg x_1)$ 得到 $\\neg x_1 \\to \\neg x_1$ 和 $x_1 \\to x_1$。\n2. $(\\neg x_2 \\lor x_1)$ 得到 $x_2 \\to x_1$ 和 $\\neg x_1 \\to \\neg x_2$。\n3. $(x_3 \\lor \\neg x_2)$ 得到 $\\neg x_3 \\to \\neg x_2$ 和 $x_2 \\to x_3$。\n4. $(x_4 \\lor \\neg x_3)$ 得到 $\\neg x_4 \\to \\neg x_3$ 和 $x_3 \\to x_4$。\n5. $(x_5 \\lor \\neg x_4)$ 得到 $\\neg x_5 \\to \\neg x_4$ 和 $x_4 \\to x_5$。\n6. $(x_6 \\lor \\neg x_5)$ 得到 $\\neg x_6 \\to \\neg x_5$ 和 $x_5 \\to x_6$。\n7. $(x_2 \\lor \\neg x_6)$ 得到 $\\neg x_2 \\to \\neg x_6$ 和 $x_6 \\to x_2$。\n\n我们现在计算从起始顶点 $\\neg x_1$ 可达的顶点集合（路径长度任意，包括零长度）。用起始顶点初始化可达集合：$\\{\\neg x_1\\}$。\n\n从 $\\neg x_1$ 出发的边是 $\\neg x_1 \\to \\neg x_1$（自环）和 $\\neg x_1 \\to \\neg x_2$。因此我们添加 $\\neg x_2$。\n\n从 $\\neg x_2$ 出发的唯一一条边是 $\\neg x_2 \\to \\neg x_6$，所以添加 $\\neg x_6$。\n\n从 $\\neg x_6$ 出发的唯一一条边是 $\\neg x_6 \\to \\neg x_5$，所以添加 $\\neg x_5$。\n\n从 $\\neg x_5$ 出发的唯一一条边是 $\\neg x_5 \\to \\neg x_4$，所以添加 $\\neg x_4$。\n\n从 $\\neg x_4$ 出发的唯一一条边是 $\\neg x_4 \\to \\neg x_3$，所以添加 $\\neg x_3$。\n\n从 $\\neg x_3$ 出发的唯一一条边是 $\\neg x_3 \\to \\neg x_2$，而它已在可达集合中。因此，探索在 $\\neg x_2, \\neg x_3, \\neg x_4, \\neg x_5, \\neg x_6$ 之间形成了一个环。\n\n从上面的边列表中可以看出，没有任何从这些否定文字出发的边指向任何肯定文字；所有从否定源点出发的边都指向否定目标点。因此，完整的可达集合是\n$$\nR=\\{\\neg x_1, \\neg x_2, \\neg x_3, \\neg x_4, \\neg x_5, \\neg x_6\\},\n$$\n可达的独立顶点数量为 $|R|=6$。", "answer": "$$\\boxed{6}$$", "id": "1410675"}, {"introduction": "掌握了基本操作之后，下一步是学习如何将 2-SAT 框架应用到更广泛的问题上。这个练习将挑战你如何为一个“异或”（$x_i \\oplus x_j$）约束进行建模，这并非一个标准的 2-CNF 子句。通过找出将异或约束转换为等价的标准子句的方法，你将学到一个关键的解题技巧：将一个新问题归约到你已经知道如何解决的问题上 [@problem_id:1410702]。", "problem": "在计算复杂性理论的研究中，2-可满足性 (2-SAT) 问题是一个基石，它对于复杂性类 $\\mathrm{NL}$ (非确定性对数空间) 是完备的。2-SAT 的标准算法涉及从一个给定的 2-合取范式 (2-CNF) 公式构建一个“蕴含图”。对于一个包含变量 $x_1, \\dots, x_n$ 的公式 $\\Phi$，其图 $G_{\\Phi}$ 有 $2n$ 个顶点，代表文字 $\\{x_1, \\neg x_1, \\dots, x_n, \\neg x_n\\}$。$\\Phi$ 中每个形如 $(l_i \\lor l_j)$ 的子句都被转换成 $G_{\\Phi}$ 中的两条有向边：一条从 $\\neg a$ 到 $b$ 的边和一条从 $\\neg b$ 到 $a$ 的边。这些边代表了逻辑蕴含 $(\\neg a \\Rightarrow b)$ 和 $(\\neg b \\Rightarrow a)$。\n\n考虑对标准 2-SAT 问题的一个扩展，其中除了形如 $(l_i \\lor l_j)$ 的标准子句外，我们引入一种新型约束：“异或”(XOR)子句，记作 $(x_i \\oplus x_j)$。当且仅当布尔变量 $x_i$ 和 $x_j$ 具有不同的真值时，该子句才被满足。\n\n为了使用标准的蕴含图框架来解决这个扩展问题，必须首先将每个 XOR 子句转换成一个等价的标准 2-CNF 子句集。为了正确地为一个 XOR 子句 $(x_i \\oplus x_j)$ 建模，必须向蕴含图中添加下列哪组有向边？\n\nA. $\\{\\neg x_i \\to x_j, \\neg x_j \\to x_i\\}$\n\nB. $\\{x_i \\to \\neg x_j, x_j \\to \\neg x_i\\}$\n\nC. $\\{x_i \\to x_j, \\neg x_i \\to \\neg x_j, x_j \\to x_i, \\neg x_j \\to \\neg x_i\\}$\n\nD. $\\{x_i \\to \\neg x_j, \\neg x_j \\to x_i, \\neg x_i \\to x_j, x_j \\to \\neg x_i\\}$\n\nE. $\\{x_i \\to x_j, x_j \\to \\neg x_i\\}$", "solution": "我们从布尔变量上的 XOR 约束的逻辑含义开始：当且仅当 $x_i$ 和 $x_j$ 具有不同的真值时，$x_i \\oplus x_j$ 才为真。等价地，\n$$\nx_i \\oplus x_j \\equiv (x_i \\land \\neg x_j) \\lor (\\neg x_i \\land x_j).\n$$\n这个条件的一个标准 2-CNF 表示是\n$$\n(x_i \\lor x_j) \\land (\\neg x_i \\lor \\neg x_j),\n$$\n这可以通过检查真值表来验证，或者通过观察到该式强制了“至少一个为真”与“至少一个为假”，因此最终恰好一个为真。\n\n在 2-SAT 的蕴含图中，每个子句 $(a \\lor b)$ 产生蕴含关系 $(\\neg a \\Rightarrow b)$ 和 $(\\neg b \\Rightarrow a)$，它们被表示为有向边 $\\neg a \\to b$ 和 $\\neg b \\to a$。\n\n将此规则应用于这两个子句：\n1) 对于 $(x_i \\lor x_j)$，我们添加边\n$$\n\\neg x_i \\to x_j, \\quad \\neg x_j \\to x_i.\n$$\n2) 对于 $(\\neg x_i \\lor \\neg x_j)$，令 $a = \\neg x_i$ 且 $b = \\neg x_j$。那么 $\\neg a = x_i$ 且 $\\neg b = x_j$，因此我们添加边\n$$\nx_i \\to \\neg x_j, \\quad x_j \\to \\neg x_i.\n$$\n\n综合为单个 XOR 子句 $(x_i \\oplus x_j)$ 建模所需的所有蕴含关系，我们得到集合\n$$\n\\{\\, x_i \\to \\neg x_j, \\ \\neg x_j \\to x_i, \\ \\neg x_i \\to x_j, \\ x_j \\to \\neg x_i \\,\\},\n$$\n这与选项 D 相匹配。", "answer": "$$\\boxed{D}$$", "id": "1410702"}, {"introduction": "2-SAT 算法能高效地告诉我们一个解是否存在，但在实际应用中，我们通常需要找到一个具体的满足赋值。这最后一个练习将带你探索一种强大的算法思想，即如何将一个“判定”算法转化为一个“搜索”算法。你将设计一个迭代过程，为任何可满足的公式构造出一个有效赋值，从而弥合理论上的可满足性与具体解决方案之间的鸿沟 [@problem_id:1410686]。", "problem": "2-可满足性（2-SAT）问题旨在判断一个给定的 2-合取范式（2-CNF）布尔公式是否存在一个可满足赋值。一个 2-CNF 公式是多个子句的合取（AND），其中每个子句是最多两个文字的析取（OR）。一个文字是一个变量或其否定形式。\n\n对于任意 2-CNF 公式 $\\phi$，我们可以构建一个蕴含图 $G_\\phi$。$G_\\phi$ 的顶点是 $\\phi$ 的所有文字（即，对于每个变量 $x_i$，图中都有代表 $x_i$ 和 $\\neg x_i$ 的顶点）。对于 $\\phi$ 中每个形如 $(\\alpha \\lor \\beta)$ 的子句，我们在 $G_\\phi$ 中添加两条有向边：一条表示蕴含关系 $\\neg \\alpha \\to \\beta$，另一条表示 $\\neg \\beta \\to \\alpha$。\n\n一个基本定理指出，一个 2-CNF 公式 $\\phi$ 是不可满足的，当且仅当存在一个变量 $x_i$，使得 $x_i$ 和 $\\neg x_i$ 位于 $G_\\phi$ 的同一个强连通分量（SCC）中。这等价于在 $G_\\phi$ 中，既存在从 $x_i$ 到 $\\neg x_i$ 的路径，也存在从 $\\neg x_i$ 到 $x_i$ 的路径。\n\n在有向图中判断两个顶点之间是否存在路径，是一个属于复杂度类非确定性对数空间（$\\mathrm{NL}$）的问题。因此，2-SAT 的判定问题属于 $\\mathrm{coNL}$，并且根据伊默尔曼-塞莱普切尼定理（$\\mathrm{NL} = \\mathrm{coNL}$），它也属于 $\\mathrm{NL}$。这意味着存在一个高效的（多项式时间）2-SAT 判定算法。\n\n假设给定一个包含 $n$ 个变量 $\\{x_1, x_2, \\ldots, x_n\\}$ 的 2-CNF 公式 $\\phi$，并保证该公式是可满足的。你还可以使用一个预言机 `IS_SAT(psi)`，它接受任意 2-CNF 公式 `psi` 作为输入，如果 `psi` 可满足则返回 `true`，否则返回 `false`。下列哪个迭代过程保证能为 $\\phi$ 找到一个可满足赋值？\n\nA. 初始化一个空赋值。对于 $i$ 从 1 到 $n$：询问预言机 `IS_SAT`($\\phi \\land x_i$)。如果结果为 `true`，则永久地将 $x_i$ 设为 `true`，并将 $\\phi$ 更新为 $\\phi \\land x_i$。否则，永久地将 $x_i$ 设为 `false`，并将 $\\phi$ 更新为 $\\phi \\land \\neg x_i$。\n\nB. 对于每个变量 $x_i$ 从 1 到 $n$：独立地查询预言机 `IS_SAT`($\\phi \\land x_i$)。如果预言机返回 `true`，则赋值 $x_i = \\texttt{true}$。否则，赋值 $x_i = \\texttt{false}$。\n\nC. 对于每个变量 $x_i$ 从 1 到 $n$：为原始公式 $\\phi$ 构建蕴含图。如果在此图中存在从文字 $x_i$ 到文字 $\\neg x_i$ 的路径，则赋值 $x_i = \\texttt{false}$。否则，赋值 $x_i = \\texttt{true}$。\n\nD. 初始化所有变量为未赋值。选择一个未赋值的变量 $x_i$。将 $x_i$ 赋值为 `true`，并检查此部分赋值是否违反任何子句。如果违反，则回溯并将 $x_i$ 赋值为 `false`。如果找到一个不会立即导致矛盾的值，则将该赋值永久化，并对下一个未赋值的变量重复此过程。", "solution": "我们分析每个过程，并确定它是否保证能利用给定的预言机为一个可满足的 2-CNF 公式 $\\phi$ 找到一个可满足赋值。\n\nA 的论证：保证能找到一个可满足赋值。\n对变量进行归纳证明：\n- 不变量：在为 $x_1,\\dots,x_{i-1}$ 赋值后，令 $\\phi_{i-1}$ 表示 $\\phi$ 与这些赋值的合取。不变量是 $\\phi_{i-1}$ 是可满足的。\n- 基础情况：根据假设，$\\phi_0=\\phi$ 是可满足的。\n- 归纳步骤：在第 $i$ 步，算法查询 `IS_SAT`($\\phi_{i-1} \\land x_i$)。如果返回 `true`，则存在一个扩展了 $x_i=\\texttt{true}$ 的赋值可以满足 $\\phi_{i-1}$，因此设置 $x_i=\\texttt{true}$ 保持了可满足性。否则，由于 $\\phi_{i-1}$ 是可满足的，那么 `IS_SAT`($\\phi_{i-1} \\land \\neg x_i$) 必定为 `true`（两个单位扩展中至少有一个是可满足的），因此设置 $x_i=\\texttt{false}$ 保持了可满足性。因此，不变量对于 $\\phi_i$ 也成立。\n- 经过 $n$ 步后，$\\phi_n$ 是可满足的，并且固定了所有变量的值，因此所选择的完整赋值满足 $\\phi$。\n因此，A 是正确的。\n\nB 的反例：不保证成功。\n设\n$$\n\\phi \\;=\\; (x \\lor y)\\;\\land\\;(\\neg x \\lor z)\\;\\land\\;(\\neg y \\lor \\neg z).\n$$\n这个 $\\phi$ 是可满足的（例如，$x=\\texttt{false},\\,y=\\texttt{true},\\,z=\\texttt{false}$ 满足所有子句）。\n对原始的 $\\phi$ 独立查询预言机得到：\n- `IS_SAT`($\\phi \\land x$)=`true`（例如，$x=\\texttt{true},\\,y=\\texttt{false},\\,z=\\texttt{true}$ 可行），\n- `IS_SAT`($\\phi \\land y$)=`true`（例如，$y=\\texttt{true},\\,x=\\texttt{false},\\,z=\\texttt{false}$ 可行），\n- `IS_SAT`($\\phi \\land z$)=`true`（例如，$z=\\texttt{true},\\,y=\\texttt{false},\\,x=\\texttt{true}$ 可行）。\n过程 B 接着会设置 $x=y=z=\\texttt{true}$，但这个赋值使得 $(\\neg y \\lor \\neg z)$ 为假，因此它不满足 $\\phi$。所以 B 不保证成功。\n\nC 的反例与归约：不保证成功。\n关键等价关系：对于一个 2-CNF 公式 $\\phi$ 和变量 $x_i$，在蕴含图 $G_\\phi$ 中存在从 $x_i$ 到 $\\neg x_i$ 的路径，当且仅当 $\\phi \\land x_i$ 是不可满足的。\n- 如果在 $G_\\phi$ 中有 $x_i \\to \\neg x_i$，添加单位子句 $x_i$ 会引入边 $\\neg x_i \\to x_i$，使得 $x_i$ 和 $\\neg x_i$ 属于同一个强连通分量，从而使 $\\phi \\land x_i$ 不可满足。\n- 反之，如果 $\\phi \\land x_i$ 不可满足，那么在 $G_{\\phi \\land x_i}$ 中唯一的新边是 $\\neg x_i \\to x_i$，而不可满足性意味着 $x_i$ 和 $\\neg x_i$ 在同一个强连通分量中；因此在 $G_\\phi$ 中必定已经存在一条路径 $x_i \\to \\neg x_i$。\n因此 C 的规则“当且仅当存在 $x_i \\to \\neg x_i$ 时赋值 $x_i=\\texttt{false}$，否则 $x_i=\\texttt{true}$”等价于“当且仅当 `IS_SAT`($\\phi \\land x_i$)=`true` 时赋值 $x_i=\\texttt{true}$，否则 $x_i=\\texttt{false}$”，并且是独立地对原始 $\\phi$ 应用的。这与 B 的陷阱相同，因此上面同一个 $\\phi$ 显示了 C 可能会失败（它会设置 $x=y=z=\\texttt{true}$，而这不是一个可满足赋值）。所以 C 不保证成功。\n\nD 的反例推理：按其陈述不保证成功。\n该过程仅在某个赋值立即导致某个子句为假时才拒绝该赋值，否则就将赋值“永久化”，并且没有规定在后续出现冲突时重新考虑早前的选择。考虑\n$$\n\\phi \\;=\\; (\\neg x \\lor z)\\;\\land\\;(\\neg x \\lor \\neg z).\n$$\n这个 $\\phi$ 是可满足的（例如，$x=\\texttt{false}$，z 取任意值）。过程 D 可能首先选择 $x$ 并尝试 $x=\\texttt{true}$，这不会立即导致任何子句为假：子句变成了单位子句 $z$ 和单位子句 $\\neg z$，在当前的部分赋值下它们尚未被证伪。然后算法将 $x=\\texttt{true}$ 永久化，并转向处理 $z$。尝试 $z=\\texttt{true}$ 会立即证伪 $(\\neg x \\lor \\neg z)$；回溯到 $z=\\texttt{false}$ 又会立即证伪 $(\\neg x \\lor z)$。在尝试了 $z$ 的两个值之后，由于 $x$ 早先已被声明为永久的，算法无法继续前进以找到可满足赋值 $x=\\texttt{false}$。由于所描述的过程不包括在后续冲突时修正早前的永久赋值，因此它不保证成功。\n\n结论：只有 A 保证能利用预言机为任何可满足的 $\\phi$ 找到一个可满足赋值。", "answer": "$$\\boxed{A}$$", "id": "1410686"}]}