{"hands_on_practices": [{"introduction": "掌握 $PSPACE$ 完备性概念的最佳方式之一是通过分析二人对抗游戏。这个练习将引导你进入一个在非确定性有限自动机（NFA）上进行的游戏。通过分析一个规模虽小但结构完整的游戏树，你将亲身体验如何确定最优策略，并为你理解定义了许多 $PSPACE$ 问题的对抗性逻辑打下坚实的基础。[@problem_id:1439439]", "problem": "考虑一个由两名玩家（玩家1和玩家2）在非确定性有限自动机（NFA）上进行的游戏。该游戏由一个NFA和一个固定的输入字符串定义。\n\n该NFA（我们称之为 $M$）由以下几个部分定义：\n- 一个状态集 $Q = \\{q_0, q_1, q_2, q_3, q_4\\}$。\n- 一个输入字母表 $\\Sigma = \\{a, b\\}$。\n- 一个转移函数 $\\delta$，具体如下：\n  - $\\delta(q_0, a) = \\{q_1, q_2\\}$\n  - $\\delta(q_0, b) = \\emptyset$\n  - $\\delta(q_1, a) = \\emptyset$\n  - $\\delta(q_1, b) = \\{q_3, q_4\\}$\n  - $\\delta(q_2, a) = \\{q_0\\}$\n  - $\\delta(q_2, b) = \\{q_4\\}$\n  - $\\delta(q_3, a) = \\{q_1\\}$\n  - $\\delta(q_3, b) = \\emptyset$\n  - $\\delta(q_4, a) = \\{q_4\\}$\n  - $\\delta(q_4, b) = \\{q_4\\}$\n- 一个起始状态 $q_{start} = q_0$。\n- 一个最终（接受）状态集 $F = \\{q_4\\}$。\n\n游戏使用的输入字符串为 $w = ab$。\n\n游戏规则如下：\n1. 游戏开始时，NFA处于其起始状态 $q_0$。\n2. 玩家轮流处理输入字符串，一次一个字符，从左到右。\n3. 对于字符串的第 $i$ 个字符（其中 $i=1$ 代表第一个字符，$i=2$ 代表第二个字符，以此类推），设当前状态为 $q$。所有可能的下一状态集合由 $\\delta(q, w_i)$ 给出。\n4. 如果 $i$ 是奇数，玩家1从可能的下一状态集合中选择下一个状态。\n5. 如果 $i$ 是偶数，玩家2从可能的下一状态集合中选择下一个状态。\n6. 如果可能的下一状态集合为空，则轮到该玩家移动时没有有效移动，因此立即判负。如果该集合只包含一个状态，则玩家必须选择该状态。\n7. 如果在处理完整个字符串 $w$ 后，NFA的状态属于最终状态集 $F$，则玩家1获胜。如果最终状态不在 $F$ 中，则玩家2获胜。\n8. 双方玩家都采取最优策略以达成各自的目标。\n\n玩家1有获胜策略吗？\n\nA. 是的，玩家1有获胜策略。\n\nB. 不，玩家2有获胜策略。\n\nC. 无论玩家如何选择，游戏都将以平局告终。\n\nD. 结果取决于某一方玩家的非最优移动。", "solution": "我们从状态 $q_0$ 和输入 $w=ab$ 开始。对于第一个符号（$i=1$，奇数），玩家1从 $\\delta(q_0, a)=\\{q_1, q_2\\}$ 中选择下一个状态。由于该集合非空，不会立即判负。\n\n考虑玩家1的两种可能选择：\n\n1. 如果玩家1在读取 $a$ 后选择 $q_1$，那么对于第二个符号（$i=2$，偶数），玩家2从 $\\delta(q_1, b)=\\{q_3, q_4\\}$ 中进行选择。由于玩家2的目标是避免进入接受状态，他们会选择 $q_3$（因为 $q_3 \\notin F$），使得最终状态为 $q_3 \\notin F$，从而玩家2获胜。\n\n2. 如果玩家1在读取 $a$ 后选择 $q_2$，那么对于第二个符号，玩家2必须从 $\\delta(q_2, b)=\\{q_4\\}$ 中进行选择，这是一个单元素集合，迫使下一状态为 $q_4$。最终状态为 $q_4 \\in F$，从而玩家1获胜。\n\n在最优策略下，玩家1在第一步选择 $q_2$，从而迫使第二步后的最终状态为 $q_4$。因此，玩家1有获胜策略。", "answer": "$$\\boxed{A}$$", "id": "1439439"}, {"introduction": "在对抗性博弈思想的基础上，这个问题将概念推广到了图上的游戏。在这里，你需要思考一种能够捕捉游戏逻辑的递归策略。这个练习是理解 $PSPACE$ 问题决定性特征的关键：它们通常可以通过一个即使需要指数时间，也只使用多项式空间（内存）的算法来解决。[@problem_id:1439408]", "problem": "两名计算机科学专业的学生，Alex和Ben，正在分析一个他们称之为“对抗路径博弈”（Adversarial Path Game）的双人博弈的计算复杂度。\n\n该博弈由一个有向图 $G=(V, E)$、一个起始顶点 $s \\in V$ 和一个目标顶点 $t \\in V$ 定义。玩家1和玩家2轮流移动一个最初放置在顶点 $s$ 上的棋子。在玩家的回合中，他们必须将棋子从当前顶点 $u$ 沿着一条边 $(u,v) \\in E$ 移动到相邻的顶点 $v$。\n\n规则如下：\n1.  玩家1先手。\n2.  首先将棋子移动到目标顶点 $t$ 的玩家立即获胜。\n3.  如果轮到某个玩家，且棋子位于一个没有出边的非目标顶点 $u \\neq t$ 上，则该玩家没有有效移动，立即判负。\n4.  为确保博弈总能终止，总移动步数最多为 $2|V|$。如果在第 $2|V|$ 步结束时仍无玩家获胜，则宣布玩家1失败（因此玩家2获胜）。\n\n相应的判定问题 `WINNING-STRATEGY` 问：给定一个实例 $(G, s, t)$，假设玩家2会采取最优策略来对抗，玩家1是否存在获胜策略？\n\nAlex提出了一个解决此问题的算法。他定义了一个递归函数 $\\text{CanWin}(u, k)$，如果当前玩家可以从顶点 $u$ 开始在接下来的 $k$ 步内强制获胜，则该函数返回真。初始调用将是 $\\text{CanWin}(s, 2|V|)$。Alex推断，由于这个函数可能会为其每个邻居顶点递归调用自身，总计算量可能是 $|V|$ 的指数级。他得出结论，`WINNING-STRATEGY` 属于复杂度类 EXP（可在指数时间内解决）。\n\nBen同意递归解法是正确的方向，但他声称Alex的复杂度分析不完整，并可能产生误导。Ben认为，该算法的空间需求更能揭示这个问题的根本复杂度。\n\n下列哪个陈述对 `WINNING-STRATEGY` 问题的计算复杂度分析最为准确？\n\nA. Alex是正确的。该问题属于EXP。博弈树的指数级性质意味着该问题无法在多项式空间内解决，因此它不属于PSPACE。\n\nB. 两名学生都忽略了一个关键细节。获胜策略是玩家1的一系列移动。这个序列是一个多项式长度的证据，可以在多项式时间内验证。因此，该问题属于NP。\n\nC. 该博弈是一个对抗性搜索问题，可以用深度优先递归算法解决。虽然朴素实现所需的时间是指数级的，但所需空间只是多项式级的，因为调用栈的深度受限于多项式级的博弈长度（$2|V|$）。因此，该问题属于PSPACE。\n\nD. 两名学生都把问题想得太复杂了。判断玩家1是否能赢等同于检查是否存在从 $s$ 到 $t$ 的路径。这可以使用像广度优先搜索（BFS）这样的算法在多项式时间内解决，从而将该问题归入P。\n\nE. Alex的算法是有缺陷的，因为博弈中可能存在环路，导致无限递归。正确的算法需要存储所有访问过的状态以避免环路，这需要指数级的空间。因此，该问题属于EXPSPACE。", "solution": "我们将该判定问题形式化如下。博弈状态由一个数对 $(u,k)$ 给出，其中 $u \\in V$ 是棋子当前所在的顶点，$k$ 是剩余的步数，初始状态为 $(s,2|V|)$。玩家轮流行动；$k$ 为偶数时玩家1移动，$k$ 为奇数时玩家2移动。当一步移动到达 $t$ 时，博弈立即结束。如果轮到某个玩家在状态 $(u,k)$ 且 $u \\neq t$ 并且 $\\deg^{+}(u)=0$，则该玩家失败。如果在 $k$ 减到 $0$ 时无人获胜，这对应于玩家1的回合（因为 $0$ 是偶数），根据规则4，玩家1失败。\n\n定义一个递归谓词 $\\text{CanWin}(u,k)$，其含义为：在状态 $(u,k)$ 时轮到的玩家可以从 $(u,k)$ 强制获胜。递归关系如下：\n- 如果存在 $(u,v) \\in E$ 且 $v=t$，则 $\\text{CanWin}(u,k)=\\text{true}$（当前玩家移动到 $t$ 并立即获胜）。\n- 否则，如果 $\\deg^{+}(u)=0$，则 $\\text{CanWin}(u,k)=\\text{false}$（当前玩家没有合法移动，因此失败）。\n- 否则，如果 $k=0$，由于这是玩家1的回合，根据规则4，$\\text{CanWin}(u,0)=\\text{false}$。\n- 否则，当前玩家有获胜移动，当且仅当存在一个后继顶点 $v$ 满足 $(u,v) \\in E$，使得下一位玩家无法从 $(v,k-1)$ 强制获胜，即：\n$$\n\\text{CanWin}(u,k)=\\exists v \\in V \\text{ with } (u,v)\\in E \\text{ such that } \\neg \\text{CanWin}(v,k-1).\n$$\n\n这种深度优先的递归评估会探索博弈树，深度最多为 $2|V|$，因为每次移动 $k$ 减1，而初始界限为 $2|V|$。因此，递归深度受限于 $|V|$ 的一个多项式。\n\n空间分析：深度优先评估只保留当前深度最多为 $2|V|$ 的调用栈。每个栈帧需要存储 $u$（一个 $V$ 中的索引）、$k$（一个以 $2|V|$ 为界的整数），以及遍历 $u$ 的出边的迭代状态。每个栈帧的空间是 $O(\\log |V|)$ 比特外加控制信息，因此总空间为\n$$\nO\\left( |V| \\cdot \\log |V| \\right),\n$$\n这是输入大小的多项式。因此该问题属于PSPACE。\n\n时间分析：最坏情况下，递归调用的次数是 $|V|$ 的指数级，因为分支因子最大可达 $\\max_{u} \\deg^{+}(u)$，深度为 $2|V|$，所以朴素实现可能需要 $|V|^{\\Theta(|V|)}$ 的时间。这表明虽然时间可以是指数级的，但空间保持在多项式级别，这是PSPACE成员资格的定义性属性。\n\n其他选项不正确的原因：\n- 选项A不正确，因为尽管时间可能是指数级的，但该问题可以通过上述的深度优先递归在多项式空间内解决，所以它属于PSPACE。\n- 选项B不正确，因为一个单一的多项式长度的移动序列并不能证明可以战胜玩家2的所有最优反制移动；一个完整的获胜策略可能需要一个条件分支的移动树，其大小可以是指数级的。\n- 选项D不正确，因为存在从 $s$ 到 $t$ 的路径并不意味着玩家1可以强制到达 $t$ 来对抗一个对手；必须考虑对抗性的选择。\n- 选项E不正确，因为明确的移动步数限制 $2|V|$ 防止了无限递归；正确性不需要指数空间的已访问状态记录，而深度优先方法仅使用多项式空间。\n\n因此，最准确的陈述是该问题属于PSPACE，因为其递归深度和空间使用量具有多项式界限，如选项C所述。", "answer": "$$\\boxed{C}$$", "id": "1439408"}, {"introduction": "PSPACE 完备性的范畴远不止于简单的游戏。这个问题展示了一个源于网络安全的实际场景，其中防火墙规则被建模为非确定性有限自动机 (NFA)。你将分析验证两个规则集是否“完美解析”的复杂性，而这最终会转化为一个形式语言理论中的基本问题。这个实践揭示了 PSPACE 完备性如何在关键的验证和系统检查任务中出现，从而将抽象理论与现实世界的计算挑战联系起来。[@problem_id:1439444]", "problem": "一位软件工程师正在为高安全性的数据中心开发一个复杂的防火墙系统。该防火墙对网络数据包序列进行操作，其中每个数据包都属于某个特定类型。所有可能的数据包类型集合用字母表 $\\Sigma$ 表示。防火墙的行为由两个独立的规则集控制，一个“允许列表” (Allow-list) 和一个“拒绝列表” (Deny-list)。每个规则集由一个模式匹配引擎定义，该引擎可以被形式化地建模为非确定性有限自动机（Nondeterministic Finite Automaton, NFA）。\n\n设 $N_A$ 是代表允许列表的NFA，$N_D$ 是代表拒绝列表的NFA。两个自动机都作用于共同的字母表 $\\Sigma$。一个数据包序列 $w \\in \\Sigma^*$ 如果被 $N_A$ 接受（即 $w \\in L(N_A)$），则称其为*允许*的；如果被 $N_D$ 接受（即 $w \\in L(N_D)$），则称其为*拒绝*的。\n\n当且仅当对于每个可以想到的数据包序列 $w \\in \\Sigma^*$，该序列要么被允许，要么被拒绝，但不能两者都是，那么该系统被定义为**“完美解决”**（Perfectly Resolved）。换句话说，$\\Sigma^*$ 中的每个字符串必须恰好属于语言 $L(N_A)$ 或 $L(N_D)$ 中的一个。\n\n工程师需要创建一个诊断工具来检查给定的规则集对 $\\langle N_A, N_D \\rangle$ 是否是“完美解决”的。我们将相应的判定问题定义如下：\n`PERFECTLY_RESOLVED` = $\\{ \\langle N_A, N_D \\rangle \\mid \\text{由 NFA } N_A \\text{ 和 } N_D \\text{ 指定的防火墙系统是完美解决的} \\}$。\n\n`PERFECTLY_RESOLVED` 问题的计算复杂性是什么？\n\nA. 它在 P 中。\n\nB. 它是 NP 完全的。\n\nC. 它是 coNP 完全的。\n\nD. 它是 PSPACE 完全的。\n\nE. 它在 EXPTIME 中，但不知道是否在 PSPACE 中。\n\nF. 它是不可判定的。", "solution": "问题的核心是确定 `PERFECTLY_RESOLVED` 判定问题的复杂性类别。\n\n首先，我们必须将给定的“完美解决”的英文描述翻译成形式语言理论中的一个精确陈述。该条件指出，对于任何字符串 $w \\in \\Sigma^*$，它必须要么在 $L(N_A)$ 中，要么在 $L(N_D)$ 中，但不能同时在两者中。这可以分解为两个条件：\n1.  两种语言的并集必须覆盖所有可能的字符串：$L(N_A) \\cup L(N_D) = \\Sigma^*$。\n2.  两种语言的交集必须为空：$L(N_A) \\cap L(N_D) = \\emptyset$。\n\n这两个条件合在一起，等价于说语言 $L(N_A)$ 是语言 $L(N_D)$ 的精确补集，即 $L(N_A) = \\overline{L(N_D)}$。因此，`PERFECTLY_RESOLVED` 问题等价于 NFA 互补性问题。\n\n为了确定这个问题的复杂性，我们将证明它是 PSPACE 完全的。这需要一个分为两部分的证明：\n1.  `PERFECTLY_RESOLVED` 在 PSPACE 中。\n2.  `PERFECTLY_RESOLVED` 是 PSPACE 难的。\n\n**第1部分：`PERFECTLY_RESOLVED` 在 PSPACE 中**\n\n我们需要证明存在一台图灵机，它只使用相对于输入大小 $|\\langle N_A, N_D \\rangle|$ 的多项式大小的空间来判定该问题。如前所述，我们需要验证两个属性：(a) $L(N_A) \\cap L(N_D) = \\emptyset$ 和 (b) $L(N_A) \\cup L(N_D) = \\Sigma^*$。\n\n**(a) 检查 $L(N_A) \\cap L(N_D) = \\emptyset$：**\n这个子问题询问两个 NFA 语言的交集是否为空。我们可以使用标准的乘积构造法来创建一个 NFA（我们称之为 $N_{intersect}$），它接受语言 $L(N_A) \\cap L(N_D)$。如果 $N_A$ 有 $n_A$ 个状态，$N_D$ 有 $n_D$ 个状态，那么 $N_{intersect}$ 将有 $n_A \\times n_D$ 个状态。问题 $L(N_{intersect}) = \\emptyset$ 等价于检查是否存在从 $N_{intersect}$ 的开始状态到其任何最终状态的路径。这是一个在具有多项式数量顶点的图上的可达性问题。可达性问题可以通过猜测路径在对数空间（NLOGSPACE）内非确定性地解决。由于 NLOGSPACE $\\subseteq$ PSPACE，这个检查可以在多项式空间内完成。\n\n**(b) 检查 $L(N_A) \\cup L(N_D) = \\Sigma^*$：**\n这个子问题询问两个 NFA 语言的并集是否是全集。我们可以构造一个 NFA, $N_{union}$，它接受 $L(N_A) \\cup L(N_D)$。这可以通过创建一个新的开始状态，并用 $\\epsilon$-转移连接到 $N_A$ 和 $N_D$ 的开始状态来完成。得到的 NFA, $N_{union}$，有 $n_A + n_D + 1$ 个状态。问题就变成了检查 $L(N_{union}) = \\Sigma^*$ 是否成立。这是 NFA 的全集问题（universality problem），通常表示为 `ALL_NFA`。\n\nNFA 的全集问题已知是在 PSPACE 中的。为了证明这一点，我们可以考虑它的补问题：非全集问题，即询问“$L(N_{union}) \\neq \\Sigma^*$ 是否成立？”。这等价于询问“是否存在一个不被 $N_{union}$ 接受的字符串 $w$？”。\n为了解决这个问题，我们可以尝试找到这样一个字符串 $w$。一个确定性的方法是使用子集构造法将 $N_{union}$ 转换为一个等价的确定性有限自动机（DFA）。这个 DFA 最多可以有 $2^{n_A+n_D+1}$ 个状态。然后我们可以检查这个 DFA 中是否存在从开始状态可达的非接受状态。然而，显式地构造这个 DFA 可能需要指数级的空间。\n\n相反，我们可以使用一个非确定性多项式空间算法。根据 Savitch's Theorem，NPSPACE = PSPACE。用于非全集问题的 NPSPACE 算法工作如下：\n- 非确定性地逐个符号猜测一个字符串 $w \\in \\Sigma^*$。\n- 在猜测每个符号后，更新 $N_{union}$ 中可能的当前状态集合。这个集合可以用多项式空间存储（一个长度为 $n_A+n_D+1$ 的位向量）。\n- 如果我们处理一个字符串 $w$ 后，得到的状态集合不包含任何最终状态，那么我们就找到了一个不在 $L(N_{union})$ 中的字符串，因此我们接受。\n- 一个 $n$ 状态 NFA 不接受的最短字符串（如果存在的话）的长度小于 $2^n$。我们可以使用一个计数器（大小为 $n$ 的多项式）来限制猜测字符串的长度。\n\n由于非全集问题在 NPSPACE 中，所以它在 PSPACE 中。全集问题（`ALL_NFA`）是一个 PSPACE 问题的补问题，而 PSPACE 在补运算下是封闭的，所以 `ALL_NFA` 也在 PSPACE 中。\n\n由于检查 (a) 和 (b) 都可以用多项式空间完成，一个 PSPACE 机器可以顺序运行它们来判定 `PERFECTLY_RESOLVED`。因此，`PERFECTLY_RESOLVED` 在 PSPACE 中。\n\n**第2部分：`PERFECTLY_RESOLVED` 是 PSPACE 难的**\n\n为了证明 PSPACE 难度，我们将从一个已知的 PSPACE 难问题进行多项式时间归约。我们将使用 `ALL_NFA` 问题本身，该问题已知是 PSPACE 完全的。\n`ALL_NFA` 问题是：给定一个 NFA $N$，是否有 $L(N) = \\Sigma^*$？\n\n让我们构造一个从 `ALL_NFA` 的任意实例到 `PERFECTLY_RESOLVED` 实例的归约。\n给定一个在字母表 $\\Sigma$ 上的 NFA $N$，它是 `ALL_NFA` 的输入。我们必须在多项式时间内构造一对 NFA $\\langle N_A, N_D \\rangle$，使得这对 NFA 是 `PERFECTLY_RESOLVED` 的“是”实例，当且仅当 $N$ 是 `ALL_NFA` 的“是”实例。\n\n归约如下：\n1.  令 $N_A = N$。\n2.  构造一个接受空语言的 NFA $N_D$，即 $L(N_D) = \\emptyset$。一个简单的方法是创建一个只有一个状态的 NFA，该状态是开始状态但不是最终状态，并且没有任何转移。我们称这个自动机为 $N_{\\emptyset}$。\n\n这个构造花费常数（因此是多项式）时间。\n\n现在，我们必须证明归约的正确性。\n实例 $\\langle N_A, N_D \\rangle = \\langle N, N_{\\emptyset} \\rangle$ 在 `PERFECTLY_RESOLVED` 中\n$\\iff$ $L(N_A) = \\overline{L(N_D)}$\n$\\iff$ $L(N) = \\overline{L(N_{\\emptyset})}$\n$\\iff$ $L(N) = \\overline{\\emptyset}$\n$\\iff$ $L(N) = \\Sigma^*$\n\n这最后一个条件 $L(N) = \\Sigma^*$，正是原始实例 $\\langle N \\rangle$ 属于 `ALL_NFA` 的条件。\n因此，我们有了一个多项式时间归约 `ALL_NFA` $\\le_p$ `PERFECTLY_RESOLVED`。由于 `ALL_NFA` 是 PSPACE 难的，`PERFECTLY_RESOLVED` 也必须是 PSPACE 难的。\n\n**结论**\n\n我们已经证明了 `PERFECTLY_RESOLVED` 在 PSPACE 中，并且它是 PSPACE 难的。因此，`PERFECTLY_RESOLVED` 问题是 PSPACE 完全的。这对应于选项 D。", "answer": "$$\\boxed{D}$$", "id": "1439444"}]}