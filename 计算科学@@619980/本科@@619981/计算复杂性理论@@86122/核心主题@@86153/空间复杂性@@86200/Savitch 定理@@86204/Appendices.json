{"hands_on_practices": [{"introduction": "理解萨维奇定理证明核心的递归算法最好的方法之一就是亲手实践。下面的练习将引导你在一张简单的有向图上，追踪该算法为寻找一条路径所进行的关键递归调用。通过这个过程，你将直观地感受到算法是如何通过“分而治之”的策略，将一个复杂路径问题分解为更小的子问题。[@problem_id:1446438]", "problem": "Savitch 定理的构造性证明提供了一个在多项式空间内解决有向图 $G=(V, E)$ 的 st-连通性问题的算法。该算法递归地确定在某个最大路径长度之内，`start` 节点和 `end` 节点之间是否存在路径。\n\n考虑一个有向图，其节点集为 $V = \\{1, 2, 3, 4, 5\\}$。其边被排列成一条简单的线：$E = \\{(1, 2), (2, 3), (3, 4), (4, 5)\\}$。\n\n我们使用一个递归函数 `REACH(start, end, max_len)`，如果 `end` 节点可以从 `start` 节点通过一条长度至多为 `max_len` 的路径到达，则该函数返回 `True`，否则返回 `False`。该算法定义如下：\n\n1.  **基本情况**：如果 `max_len` 为 1，当 `start == end` 或直接边 `(start, end)` 存在于 $E$ 中时，函数返回 `True`。否则，返回 `False`。\n2.  **递归步骤**：如果 `max_len > 1`，函数会按数值递增的顺序（即从 1 到 5）遍历 $V$ 中的所有节点 `mid`。对于每个 `mid`，它会进行两次递归调用：`REACH(start, mid, ceil(max_len / 2))` 和 `REACH(mid, end, ceil(max_len / 2))`。如果这两个调用都返回 `True`，函数会立即停止迭代并返回 `True`。\n3.  **失败情况**：如果对所有可能的 `mid` 节点的循环完成，而两个递归调用从未都返回 `True`，则函数返回 `False`。\n\n要求您追踪初始调用 `REACH(1, 5, 4)` 的执行过程。“一对顶层递归调用”指的是在 `REACH(1, 5, 4)` 的执行过程中，对给定的 `mid` 直接进行的那两个调用，即 `(REACH(1, mid, ...), REACH(mid, 5, ...))`。\n\n下列哪个选项正确地列出了在算法找到成功路径且主调用 `REACH(1, 5, 4)` 返回 `True` 之前所进行的一系列顶层递归调用*对*？\n\nA. `[(REACH(1,1,2), REACH(1,5,2)), (REACH(1,2,2), REACH(2,5,2)), (REACH(1,3,2), REACH(3,5,2))]`\n\nB. `[(REACH(1,3,2), REACH(3,5,2))]`\n\nC. `[(REACH(1,2,1), REACH(2,3,1)), (REACH(3,4,1), REACH(4,5,1))]`\n\nD. `[(REACH(1,1,2), REACH(1,5,2)), (REACH(1,2,2), REACH(2,5,2)), (REACH(1,3,2), REACH(3,5,2)), (REACH(1,4,2), REACH(4,5,2)), (REACH(1,5,2), REACH(5,5,2))]`\n\nE. `[(REACH(1,5,2), REACH(5,5,2)), (REACH(1,4,2), REACH(4,5,2)), (REACH(1,3,2), REACH(3,5,2))]`", "solution": "问题要求我们为初始调用 `REACH(1, 5, 4)` 追踪函数 `REACH(start, end, max_len)` 所进行的顶层递归调用序列。\n\n初始参数为 `start = 1`，`end = 5` 和 `max_len = 4`。\n由于 `max_len = 4 > 1`，算法进入递归步骤。子问题的长度将是 $\\lceil \\text{max\\_len} / 2 \\rceil = \\lceil 4 / 2 \\rceil = 2$。算法将从 1 到 5 遍历 `mid`，并对每个 `mid` 测试调用对 `(REACH(1, mid, 2), REACH(mid, 5, 2))`。一旦找到一个使两个调用都返回 `True` 的 `mid`，过程就停止。\n\n让我们追踪 `mid` 的迭代过程：\n\n**1. `mid = 1`:**\n第一对顶层递归调用是 `(REACH(1, 1, 2), REACH(1, 5, 2))`。\n-   `REACH(1, 1, 2)`：为了评估这个调用，算法会为一条长度至多为 2 的路径寻找一个中间点 `z`。让我们尝试 `z=1`。这个子调用会测试 `REACH(1, 1, 1)` 和 `REACH(1, 1, 1)`。基本情况 `REACH(1,1,1)` 为 `True`，因为 `start == end`。由于两个子调用都为 `True`，所以 `REACH(1, 1, 2)` 返回 `True`。\n-   `REACH(1, 5, 2)`：此调用检查从节点 1 到节点 5 是否存在长度至多为 2 的路径。通过检查图的边 $E = \\{(1, 2), (2, 3), (3, 4), (4, 5)\\}$，从 1 到 5 的最短路径是 $1 \\to 2 \\to 3 \\to 4 \\to 5$，其长度为 4。不存在长度为 2 或更短的路径。因此，`REACH(1, 5, 2)` 将返回 `False`。\n由于该调用对中的一个返回了 `False`，算法继续到下一个 `mid`。到目前为止的调用对序列是 `[(REACH(1,1,2), REACH(1,5,2))]`。\n\n**2. `mid = 2`:**\n下一对调用是 `(REACH(1, 2, 2), REACH(2, 5, 2))`。\n-   `REACH(1, 2, 2)`：此调用检查从节点 1 到 2 是否存在长度至多为 2 的路径。路径是 $1 \\to 2$，长度为 1。算法会找到这条路径。例如，对于子中间点 `z=1`，它会检查 `REACH(1,1,1)` (True) 和 `REACH(1,2,1)` (True，因为边 (1,2) 存在)。因此，`REACH(1, 2, 2)` 返回 `True`。\n-   `REACH(2, 5, 2)`：此调用检查从 2 到 5 是否存在长度至多为 2 的路径。最短路径是 $2 \\to 3 \\to 4 \\to 5$，长度为 3。不存在长度为 2 的路径。因此，`REACH(2, 5, 2)` 将返回 `False`。\n同样，这对调用不都为 `True` 值。算法继续。现在的调用对序列是 `[(REACH(1,1,2), REACH(1,5,2)), (REACH(1,2,2), REACH(2,5,2))]`。\n\n**3. `mid = 3`:**\n下一对调用是 `(REACH(1, 3, 2), REACH(3, 5, 2))`。\n-   `REACH(1, 3, 2)`：此调用检查从 1 到 3 是否存在长度至多为 2 的路径。路径 $1 \\to 2 \\to 3$ 存在且长度为 2。算法会发现这一点。具体来说，当它尝试子中间点 `z=2` 时，它会调用 `REACH(1, 2, 1)`（True，边存在）和 `REACH(2, 3, 1)`（True，边存在）。因为两者都为 `True`，`REACH(1, 3, 2)` 返回 `True`。\n-   `REACH(3, 5, 2)`：此调用检查从 3 到 5 是否存在长度至多为 2 的路径。路径 $3 \\to 4 \\to 5$ 存在且长度为 2。算法会发现这一点。具体来说，当它尝试子中间点 `z=4` 时，它会调用 `REACH(3, 4, 1)`（True，边存在）和 `REACH(4, 5, 1)`（True，边存在）。因为两者都为 `True`，`REACH(3, 5, 2)` 返回 `True`。\n\n由于 `REACH(1, 3, 2)` 和 `REACH(3, 5, 2)` 都返回 `True`，`REACH(1, 5, 4)` 的主循环中的条件得到满足。函数立即停止迭代并返回 `True`。\n\n在函数返回 `True` 之前所分析的顶层调用对的总序列是 `mid=1`、`mid=2` 和 `mid=3` 的调用对集合。\n该序列是：`[(REACH(1,1,2), REACH(1,5,2)), (REACH(1,2,2), REACH(2,5,2)), (REACH(1,3,2), REACH(3,5,2))]`。\n\n这与选项 A 匹配。\n- 选项 B 不正确，因为它只列出了成功的调用对，忽略了 `mid=1` 和 `mid=2` 的失败尝试。\n- 选项 C 不正确，因为它列出的是成功情况 (`mid=3`) 下的第二层递归调用，而不是顶层调用。\n- 选项 D 不正确，因为它列出了所有可能的中间点的调用对，但算法在 `mid=3` 第一次成功后就停止了。\n- 选项 E 不正确，因为算法是按递增顺序遍历 `mid`，而不是递减顺序。", "answer": "$$\\boxed{A}$$", "id": "1446438"}, {"introduction": "在理解了算法如何找到一条路径之后，一个自然而然的问题是：它找到的是一条“好”路径吗？该练习挑战你去批判性地思考萨维奇算法的输出特性，并让你区分“可达性”（existence）和“最优性”（optimality）这两个重要概念。深入思考算法找到的路径是否保证为最短路径，将有助于你更精确地把握该算法的目标和局限。[@problem_id:1446443]", "problem": "在计算复杂性理论中，Savitch 定理证明了任何可由非确定性图灵机 (NTM) 在多项式空间内解决的问题，同样也可由确定性图灵机在多项式空间内解决，从而确立了 $\\text{PSPACE} = \\text{NPSPACE}$。\n\n该证明的核心是一个用于判定 `ST-REACH` 问题的确定性算法：给定一个有向图（代表 NTM 的格局图）、一个起始顶点 $c_{start}$、一个终止顶点 $c_{end}$ 和一个最大路径长度 $N$，确定是否存在一条从 $c_{start}$ 到 $c_{end}$ 的长度不超过 $N$ 的路径。\n\n让我们考虑该证明核心的递归过程的一个简化版本。这个我们称为 `CanReach`($c_1, c_2, k$) 的函数，用于确定格局 $c_2$ 是否可以在至多 $2^k$ 步内从格局 $c_1$ 到达。参数 $k$ 是一个整数，满足 $2^k \\ge N$。\n\n该算法定义如下：\n- **`CanReach`($c_1, c_2, k$):**\n  1. 如果 $k = 0$：若 $c_1$ 与 $c_2$ 相同，或者根据 NTM 的转移函数，$c_2$ 可以从 $c_1$ 一步到达，则返回 `true`。否则，返回 `false`。\n  2. 如果 $k > 0$：遍历每个可能的中间格局 $c_{mid}$。对于每个 $c_{mid}$：\n     a. 如果 `CanReach`($c_1, c_{mid}, k-1$) 返回 `true`，则：\n     b. 如果 `CanReach`($c_{mid}, c_2, k-1$) 也返回 `true`：\n     c. 那么就找到了一条路径。返回 `true`。\n  3. 如果循环结束仍未找到任何这样的 $c_{mid}$，则返回 `false`。\n\n该算法成功验证其存在的**第一条**路径，是由（按机器固定的迭代顺序）**第一个**使得两个递归调用都成功的中间格局 $c_{mid}$ 所隐含定义的，对于所有子问题也依此类推。\n\n这个隐含找到的路径是否保证是格局图中从 $c_{start}$ 到 $c_{end}$ 的一条最短路径？\n\nA. 是，因为对路径长度的递归二分确保了最优子结构，这是最短路径算法的一个特征。\n\nB. 是，因为该算法是广度优先搜索的一种空间优化实现。\n\nC. 否，因为该算法按固定顺序系统地尝试所有可能的中间格局，第一个导向有效路径的格局不一定位于最短路径上。\n\nD. 否，因为格局图可能包含环，而最短路径算法在带环的图上没有明确定义。\n\nE. 这个问题提法不当，因为该算法只判定路径的存在性，而不能构建或识别任何特定路径。", "solution": "我们来形式化地描述这个问题。设 $G=(V,E)$ 是非确定性图灵机的有向格局图。对于 $c_1,c_2 \\in V$ 和整数 $k \\ge 0$，过程 $\\mathrm{CanReach}(c_1,c_2,k)$ 返回真，当且仅当在 $G$ 中存在一条从 $c_1$到 $c_2$ 且长度不超过 $2^{k}$ 的路径。我们将图论距离 $\\mathrm{dist}(u,v)$ 定义为从 $u$ 到 $v$ 的最短路径的长度（若不存在路径，则 $\\mathrm{dist}(u,v)=\\infty$）。问题在于，由第一个成功的递归中点选择序列所隐含确定的特定路径，是否总是从 $c_{start}$到 $c_{end}$ 的最短路径。\n\n我们来分析算法的行为。基本情况 $k=0$ 测试的是 $c_1=c_2$ 或 $(c_1,c_2) \\in E$ 是否成立，即 $\\mathrm{dist}(c_1,c_2) \\le 1$。对于 $k>0$，算法以固定顺序遍历 $c_{mid} \\in V$，并在找到某个 $c_{mid}$ 使得 $\\mathrm{CanReach}(c_1,c_{mid},k-1)$ 和 $\\mathrm{CanReach}(c_{mid},c_2,k-1)$ 均为真时返回真。通过对 $k$ 进行归纳，可以证明该判定问题的正确性成立：如果过程返回真，则存在一条长度不超过 $2^{k}$ 的路径；如果返回假，则不存在这样的路径。然而，这个正确性标准只关心在长度限制内的存在性，而不关心由中点选择序列所构建的特定路径的长度是否最小。\n\n为了说明找到的第一条路径不必是最短的，我们构造一个明确的反例。设 $V=\\{s,a,b,t\\}$ 且 $E=\\{(s,t),(s,a),(a,b),(b,t)\\}$。那么通过直接边 $(s,t)$，$\\mathrm{dist}(s,t)=1$，同时还存在一条更长的路径 $s \\to a \\to b \\to t$，其长度为 $3$。选择 $k=2$，这样 $2^{k}=4 \\ge 3$。假设遍历中点的固定顺序是 $a,b,s,t$。\n\n考虑 $\\mathrm{CanReach}(s,t,2)$。该过程首先检查 $c_{mid}=a$：\n- 它评估 $\\mathrm{CanReach}(s,a,1)$，该值为真，因为存在一条从 $s$到 $a$ 的长度不超过 $2$ 的路径（实际上，$(s,a) \\in E$）。具体来说，在 $\\mathrm{CanReach}(s,a,1)$ 中，选择 $c_{mid}=a$ 会使得 $\\mathrm{CanReach}(s,a,0)$ 为真（因为 $(s,a) \\in E$），并且 $\\mathrm{CanReach}(a,a,0)$ 为真（因为 $a=a$）。\n- 接着它评估 $\\mathrm{CanReach}(a,t,1)$，该值也为真，因为存在一条长度为 $2$ 的路径 $a \\to b \\to t$。具体来说，在 $\\mathrm{CanReach}(a,t,1)$ 中，选择 $c_{mid}=b$ 会使得 $\\mathrm{CanReach}(a,b,0)$ 为真（因为 $(a,b) \\in E$），并且 $\\mathrm{CanReach}(b,t,0)$ 为真（因为 $(b,t) \\in E$）。\n\n因此，$\\mathrm{CanReach}(s,t,2)$ 在处理第一个中点 $a$ 时返回真，从而通过长度为 $3$ 的路径 $s \\to a \\to b \\to t$ 证实了可达性。请注意，存在一条长度为 $1$ 的严格更短的路径 $s \\to t$，该路径也能被算法所验证（例如，通过考虑 $c_{mid}=t$，然后 $\\mathrm{CanReach}(s,t,1)$ 会分裂成两段长度至多为 $1$ 的路径），但由于中点的迭代顺序是固定的且与距离无关，算法只要找到任何一个能将路径分割成两条长度不超过 $2^{k-1}$ 的子路径的有效中点，就会立即返回。因此，发现的第一条成功路径不必是最短的；它只保证长度不超过 $2^{k}$。\n\n这直接驳斥了选项 A（中点的迭代顺序没有强制执行由最优子结构驱动的最短路径保证）和选项 B（该算法不是广度优先搜索；它不按距离非递减的顺序探索状态）。选项 D 是不正确的，因为即使在有环的图中，最短路径长度也是良定义的；环的存在并不排除最短路径的概念。选项 E 是不正确的，因为尽管 Savitch 算法是为判定问题设计的，但递归的中点选择确实隐含地定义了一条特定路径，并且通过少量的记录工作就可以输出该路径；即便在给定的描述中，该路径也由成功的那些中点隐含地指定了。因此，正确的选择是，找到的第一条路径不保证是最短的，这恰恰是因为算法对中点的固定顺序搜索可能会在找到更短的有效路径之前，先识别出一条更长的有效路径。", "answer": "$$\\boxed{C}$$", "id": "1446443"}, {"introduction": "萨维奇定理的原始证明主要关注一个“判定问题”——即判断路径是否存在，而这在空间效率上取得了巨大成功。然而，在实际应用中，我们往往不仅想知道路径是否存在，还想知道路径本身。这个高级练习将引导你扩展核心算法，使其不仅能做出判定，还能在严格的空间限制下“构造”出一条具体的路径，从而将理论算法转化为一个更具实用性的工具。[@problem_id:1446393]", "problem": "在计算复杂性理论领域，Savitch 定理确立了一个深刻的结果，即 $\\text{NPSPACE} = \\text{PSPACE}$，其中 NPSPACE 是指可由非确定性图灵机在多项式空间内解决的问题类别，而 PSPACE 则是指确定性图灵机在多项式空间内可以解决的问题类别。该定理的构造性证明提供了一种确定性算法，仅使用多对数空间即可解决图可达性问题，这是一个典型的 $\\text{NPSPACE}$ 完全问题。\n\n考虑一个特殊的机器人探索场景。一个自主智能体必须在一个表示为有向图 $G=(V, E)$ 的大型复杂网络中导航，其中顶点数为 $|V| = N$。该智能体的机载计算机内存非常有限。给定起始顶点 $s$ 和目标顶点 $t$，标准的 Savitch 算法可以确定路径是否存在。然而，为了导航，该智能体还必须生成实际的路径。\n\n你的任务是为这个智能体设计一个确定性算法。该算法的输入为顶点数 $N$、起始顶点 $s$ 和目标顶点 $t$。图的结构本身通过一个预言机函数 `is_edge(u, v)` 提供，如果存在从 $u$ 到 $v$ 的有向边，该函数返回 true，否则返回 false。\n\n该智能体的计算模型包括：\n1.  对输入（$N, s, t$）和 `is_edge` 预言机的只读访问权限。\n2.  一条主要的读写工作带，其使用量定义了空间复杂度。\n3.  一条独立的一次写入输出带。在这条带上，磁带头只能在当前单元格写入一个符号并向右移动；它不能擦除或向左移动。\n\n如果存在从 $s$ 到 $t$ 的路径，你的算法必须将代表这样一条简单路径的顶点序列写入一次写入输出带。如果不存在路径，输出带应保持为空。\n\n这个寻路算法的工作带空间复杂度的最紧上界是什么？请用关于 $N$ 的大O表示法表示。\n\nA. $O(\\log N)$\n\nB. $O((\\log N)^2)$\n\nC. $O(N)$\n\nD. $O(N \\log N)$\n\nE. $O(N^2)$", "solution": "给定一个有向图 $G=(V,E)$，其中 $|V|=N$，对 $N,s,t$ 和边预言机 `is_edge(u,v)` 具有只读访问权限，一条决定空间复杂度的读写工作带，以及一条一次写入输出带。目标是，如果存在一条从 $s$ 到 $t$ 的简单路径，则确定性地输出该路径，否则不输出任何内容，并使用最优的工作带空间。\n\n首先，回顾 Savitch 用于可达性问题的递归决策过程。定义谓词\n$$\n\\text{REACH}(u,v,\\ell) := \\text{“存在一条从 }u\\text{ 到 }v\\text{ 的长度至多为 }\\ell\\text{ 的有向路径。”}\n$$\nSavitch 的递归过程如下：\n- 基本情况：对于 $\\ell=1$，当且仅当 `is_edge(u,v)` 或 $u=v$ 时返回 true（这取决于是否允许长度为 0 的路径；如果需要，我们可以通过包含 $u=v$ 的情况将路径长度归一化到 $\\{0,1,\\dots\\}$ 集合中）。\n- 递归情况：对于 $\\ell>1$，令 $\\ell_{1}=\\lfloor \\ell/2 \\rfloor$ 且 $\\ell_{2}=\\lceil \\ell/2 \\rceil$。那么\n$$\n\\text{REACH}(u,v,\\ell) \\text{ 为真，当且仅当存在 } m \\in V \\text{ 使得 }\n\\text{REACH}(u,m,\\ell_{1}) \\wedge \\text{REACH}(m,v,\\ell_{2})。\n$$\n该算法使用深度为 $O(\\log \\ell)$ 的递归树来确定性地判断可达性，在每一层递归中，它存储 $u,v,\\ell$ 和循环变量 $m$，每个变量都可以用 $O(\\log N)$ 比特来保存。因此，判断 $\\text{REACH}(u,v,\\ell)$ 的工作带空间为\n$$\nO(\\log \\ell \\cdot \\log N)。\n$$\n通过设置 $\\ell=N-1$，我们可以在 $O((\\log N)^{2})$ 空间内判断 $s$–$t$ 的可达性。\n\n为了输出一条简单路径，我们将生成一条最短的 $s$–$t$ 路径，该路径必然是简单的。令 $D$ 表示从 $s$ 到 $t$ 的最短路径距离（以边的数量计），并约定如果 $t$ 不可达，则 $D=\\infty$。我们可以通过计算 $\\text{REACH}(s,t,k)$ 来确定 $D \\leq k$ 是否成立。因此，我们可以通过在 $\\{0,1,\\dots,N-1\\}$ 上对 $k$ 进行二分查找来精确计算 $D$（当其为有限值时），此过程需要维护两个用于表示上下界的 $O(\\log N)$ 比特的计数器，并使用 $\\text{REACH}$ 作为决策子程序。此过程的工作带空间仍然是\n$$\nO((\\log N)^{2}),\n$$\n由于 $\\text{REACH}$ 调用的开销占主导地位。\n\n如果 $\\text{REACH}(s,t,N-1)$ 为假，我们停止算法，并且不向输出带写入任何内容。否则，有 $D \\leq N-1$。我们现在通过贪心前向扩展的方式构造一条最短路径：\n- 初始化 $u := s$，输出 $u$，并设置剩余距离预算 $d := D$。\n- 对于 $i=1,2,\\dots,D$：\n  - 扫描所有 $v \\in V$（使用一个 $O(\\log N)$ 比特的计数器在 $\\{1,2,\\dots,N\\}$ 上迭代 $v$）。对于第一个满足 `is_edge(u,v)` 为真且 $\\text{REACH}(v,t,d-1)$ 为真的 $v$，将此 $v$ 固定为下一个顶点。\n  - 将 $v$ 输出到一次写入带，设置 $u := v$，并设置 $d := d-1$。\n这个循环保证在每一步都能找到这样一个 $v$，因为根据 $D$ 的定义，在某条最短路径上，$u$ 存在一个邻居，从该邻居到终点的剩余距离为 $d-1$。经过 $D$ 次迭代后，我们到达了 $t$；打印出的序列长度为 $D$，并且由于它是一条最短路径，因此是简单的。\n\n路径构建的空间分析：\n- 变量 $u$、$v$、$d$ 和循环索引各需要 $O(\\log N)$ 比特。\n- 每次对 $\\text{REACH}(\\cdot,\\cdot,\\cdot)$ 的调用，由于递归深度为 $O(\\log N)$ 且每层需要 $O(\\log N)$ 比特，因此使用 $O((\\log N)^{2})$ 的工作带空间。\n- 总空间是这些开销中的最大值，即 $O((\\log N)^{2})$。一次写入输出带的使用不计入工作带空间。\n\n因此，存在一个确定性算法，在给定 $N,s,t$ 和 `is_edge` 预言机的情况下，可以判断可达性，并在存在路径时输出一条简单的 $s$–$t$ 路径，其使用的工作带空间为\n$$\nO((\\log N)^{2})。\n$$\n在所提供的选项中，这是最紧的上界。\n\n因此，正确选项是 B。", "answer": "$$\\boxed{B}$$", "id": "1446393"}]}