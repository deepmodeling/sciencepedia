{"hands_on_practices": [{"introduction": "非确定性对数空间（`NSPACE(log n)` 或 `NL`）的概念可能显得有些抽象。这个练习旨在通过一个具体问题，帮助你直观地理解一个 `NL` 机器是如何工作的。通过思考如何仅使用几个指向输入的“指针”来解决 `TWIN_INTERLEAVE` 问题，你将能更好地把握对数空间计算的本质限制与强大能力。[@problem_id:1453626]", "problem": "在数据传输与验证领域，通常使用冗余来防止错误。考虑一个简化的协议，其中一个作为密钥的非空字符串 $v$ 通过发送两个独立的、相同的 $v$ 的副本进行传输。然而，传输信道可能会将这两个副本的各部分交错在一起。结果是一个单一的接收字符串 $w$。接收端的系统必须验证 $w$ 是否可能由这个过程生成。\n\n形式上，我们称一个字符串 $w$ 是两个字符串 $x$ 和 $y$ 的交错，如果 $w$ 的字符可以被划分为两个子序列，当按顺序读取时，它们恰好构成 $x$ 和 $y$。例如，`axbyc` 是 `abc` 和 `xy` 的一个交错。\n\n令语言 `TWIN_INTERLEAVE` 为给定字母表 $\\Sigma$ 上所有字符串 $w$ 的集合，其中 $w$ 是某个非空字符串 $v$ 和其自身的交错。例如，`ab` 不在该语言中，但 `aabb` 是（对于 $v$=`ab`），而 `abba` 不是。\n\n在计算复杂性理论中，一个已知的结果是，`TWIN_INTERLEAVE` 问题可以由一台非确定性图灵机在其工作带上使用相对于输入大小的对数空间来判定。这个复杂度类被称为 NL，即非确定性对数空间（`NL = NSPACE(log n)`）。\n\n设 $n$ 是输入字符串 $w$ 的长度。以下哪个选项最能描述一台非确定性图灵机在上述对数空间限制内判定 `TWIN_INTERLEAVE` 成员资格时，其工作带上的基本存储需求？\n\nA. 一个能够存储从 $0$ 到 $n$ 之间任意整数值的单个计数器。\n\nB. 固定数量的指针，其中每个指针是一个变量，用于存储输入字符串 $w$ 的索引（即一个从 $1$ 到 $n$ 的值）。\n\nC. 一个用于存放长度最大为 $n/2$ 的 $w$ 的子串的临时缓冲区。\n\nD. 一个足以存储完整候选字符串 $v$ 的内存段。\n\nE. 两个栈，其中两个栈存储的符号总数最多可达 $n$。", "solution": "我们将此判定任务形式化如下：给定长度为 $n$ 的输入 $w$，判定是否存在递增的索引序列 $i_{1}<i_{2}<\\cdots<i_{m}$ 和 $j_{1}<j_{2}<\\cdots<j_{m}$，使得 $n=2m$，$\\{i_{1},\\ldots,i_{m}\\}\\cup\\{j_{1},\\ldots,j_{m}\\}=\\{1,\\ldots,n\\}$（不交并），并且对于所有 $t\\in\\{1,\\ldots,m\\}$ 都有 $w[i_{t}]=w[j_{t}]$。这表示 $w$ 是某个长度为 $m$ 的非空字符串 $v$ 和其自身的交错。\n\n一个在 $O(\\log n)$ 空间内运行的非确定性图灵机可以通过迭代 $t=1$ 到 $m$ 并非确定性地猜测下一对 $(i_{t},j_{t})$ 来验证这样的证书，其中 $i_{t}$ 和 $j_{t}$ 相对于 $(i_{t-1},j_{t-1})$ 是严格递增的，同时在只读输入带上直接检查 $w[i_{t}]=w[j_{t}]$。为了执行这些检查，图灵机必须：\n- 存储固定数量的 $w$ 的索引（例如，当前的 $i_{t}$ 和 $j_{t}$，以及可能用于检查单调性的前一对索引）。每个索引是 $\\{1,\\ldots,n\\}$ 中的一个整数，可以用 $\\lceil \\log_{2} n \\rceil$ 位来存储。\n- 将输入磁头移动到这些索引指示的位置并比较符号。字母表是固定的，因此符号比较使用常数空间。\n\n因此，工作带上的基本存储是固定数量的变量，每个变量持有一个从 $1$ 到 $n$ 的索引，总共需要 $O(\\log n)$ 位。这与 NL 计算的标准刻画相符，即图灵机在输入中保留常数个指针，并通过多次遍历来重用它们。\n\n现在我们评估各个选项：\n- A. 一个存储从 $0$ 到 $n$ 的值的单个计数器使用 $O(\\log n)$ 位，但通常需要同时拥有至少两个独立的索引（对应两个子序列）来比较 $w[i_{t}]$ 和 $w[j_{t}]$，同时还要维持顺序约束。单个计数器不足以作为所需存储的通用描述。\n- B. 固定数量的指针（$w$ 的索引）精确地捕捉了 NL 的策略：存储 $O(1)$ 个索引，每个需要 $O(\\log n)$ 位，总空间为 $O(\\log n)$。\n- C. 一个长度最大为 $n/2$ 的缓冲区需要 $\\Theta(n)$ 的空间，超过了 $O(\\log n)$。\n- D. 存储完整的候选字符串 $v$ 需要 $\\Theta(n)$ 的空间，超过了 $O(\\log n)$。\n- E. 两个总共可存储多达 $n$ 个符号的栈需要 $\\Theta(n)$ 的空间，超过了 $O(\\log n)$。\n\n因此，工作带的基本存储需求由选项 B 所描述。", "answer": "$$\\boxed{B}$$", "id": "1453626"}, {"introduction": "萨维奇定理（Savitch's Theorem）是连接非确定性空间和确定性空间的核心桥梁，但其理论形式 $NSPACE(s(n)) \\subseteq DSPACE(s(n)^2)$ 如何在实践中应用呢？这个练习提供了一个绝佳的场景。通过为一个给定的非确定性算法计算其确定性模拟的空间上限，你将掌握一项在复杂度分析中至关重要的实用技能。[@problem_id:1453645]", "problem": "一位计算生物学家设计了一种新的非确定性算法，用于分析复杂蛋白质折叠路径的稳定性。输入的大小（该输入编码了蛋白质的一级结构和环境因素）用 $n$ 表示。\n\n该算法在任何单一非确定性计算路径上的性能由其内存使用量（空间复杂度）来表征。该使用量由两个主要部分组成：\n1. 一个用于存储蛋白质状态空间的主要数据结构，其所需内存量与 $n^{2/5}$ 成正比。\n2. 一个用于递归路径查找搜索的辅助暂存空间，其峰值所需内存量与 $n^{3/5}$ 成正比。\n\n在计算中内存最密集的部分，主要数据结构和辅助暂存空间必须同时保存在内存中。为了验证算法的正确性，需要在标准的确定性机器上对其进行模拟。Savitch 定理提供了一种方法，可以为此类确定性模拟所需的空间建立一个上界。\n\n直接应用 Savitch 定理，解决同一问题的*确定性*算法的空间复杂度的最紧上界是什么？请用关于 $n$ 的大O符号表示你的答案。", "solution": "该非确定性算法在任何单一计算路径上的峰值空间是两个同时存在的组成部分之和：需要 $O(n^{2/5})$ 空间的主要数据结构和需要 $O(n^{3/5})$ 空间的辅助暂存空间。因此，非确定性空间复杂度为\n$$\ns(n)=\\Theta\\!\\big(n^{2/5}+n^{3/5}\\big)=\\Theta\\!\\big(n^{3/5}\\big).\n$$\n根据 Savitch 定理，对于任何 $s(n)\\ge \\log n$，我们有\n$$\n\\mathrm{NSPACE}(s(n))\\subseteq \\mathrm{DSPACE}\\big(s(n)^{2}\\big).\n$$\n这里 $s(n)=\\Theta(n^{3/5})$ 对于足够大的 $n$ 满足 $s(n)\\ge \\log n$，所以直接应用 Savitch 定理可得出一个确定性空间上界\n$$\n\\mathrm{DSPACE}\\big(s(n)^{2}\\big)=\\mathrm{DSPACE}\\big(\\Theta(n^{3/5})^{2}\\big)=O\\big(n^{6/5}\\big).\n$$\n因此，由 Savitch 定理保证的、解决同一问题的确定性算法的最紧上界是 $O(n^{6/5})$。", "answer": "$$\\boxed{O(n^{6/5})}$$", "id": "1453645"}, {"introduction": "萨维奇定理的结论——空间复杂度的平方关系——是如何实现的？这个练习让你有机会深入探索其背后的精妙机制。题目中提出的递归算法实际上是萨维奇定理证明思想的一个具体实例。通过分析这个分治算法的空间消耗，你将亲身体会到，通过巧妙的递归和空间复用，我们如何能够将非确定性“猜测”的威力转化为确定性计算中可控的（尽管是平方级的）空间开销。[@problem_id:1453632]", "problem": "考虑**矩阵乘积生成 (MPG)** 问题。一个 MPG 的实例是一个元组 $(n, p, S, T, L)$，其中：\n- $n$ 是一个正整数，代表矩阵的维度。\n- $p$ 是一个素数，定义了有限域 $F_p$。\n- $S = \\{G_1, G_2, \\ldots, G_m\\}$ 是一个包含 $m$ 个生成矩阵的集合，其中每个 $G_i$ 是一个 $n \\times n$ 的矩阵，其元素在 $F_p$ 中。\n- $T$ 是一个 $n \\times n$ 的目标矩阵，其元素在 $F_p$ 中。\n- $L$ 是一个正整数，代表矩阵乘积的最大允许长度。\n\n该问题询问是否存在一个整数 $k$（满足 $1 \\le k \\le L$）和一个由 $k$ 个来自集合 $S$ 的矩阵组成的序列 $M_1, M_2, \\ldots, M_k$（其中矩阵可以重复选择），使得它们的乘积等于目标矩阵 $T$。即，$T = M_k \\cdots M_2 M_1$。\n\n为分析该问题的复杂度，一位计算机科学家提出了一个递归非确定性过程 `Can_Reach(A, B, k)`。如果矩阵 `B` 可以通过将矩阵 `A` 右乘一个由 $S$ 中恰好 `k` 个矩阵构成的乘积得到，则该过程返回 `true`。形式上，如果存在一个来自 $S$ 的序列 $M_1, \\ldots, M_k$ 使得 $B = A \\cdot M_1 \\cdot M_2 \\cdots M_k$，则 `Can_Reach(A, B, k)` 为 `true`。所有算术运算都在 $F_p$ 中进行。\n\n该过程定义如下：\n1.  **基本情况 (k=1):** 遍历集合 $S$ 中的每个生成矩阵 $G_i$。如果 $A \\cdot G_i = B$，则返回 `true`。如果循环结束仍未找到这样的生成矩阵，则返回 `false`。\n2.  **递归步骤 (k>1):**\n    a. 非确定性地选择一个中间 $n \\times n$ 矩阵 $C$，其元素在 $F_p$ 中。\n    b. 递归调用 `Can_Reach(A, C, \\lfloor k/2 \\rfloor)`。\n    c. 递归调用 `Can_Reach(C, B, k - \\lfloor k/2 \\rfloor)`。\n    d. 如果两个递归调用都返回 `true`，则返回 `true`。否则，此非确定性路径失败。\n\n一个非确定性图灵机 (NTM) 可以通过首先非确定性地猜测一个长度 $k \\in \\{1, \\ldots, L\\}$，然后执行 `Can_Reach(I, T, k)` 来解决 MPG 问题，其中 $I$ 是 $n \\times n$ 的单位矩阵。\n\n为了进行复杂度分析，设最大乘积长度为 $L = 2^{(n^2)}$。假设存储一个 $n \\times n$ 矩阵需要 $O(n^2)$ 的空间，存储一个值最大为 $L$ 的整数需要 $O(\\log L)$ 的空间。这个基于 NTM 的算法的空间复杂度是关于 $n$ 的什么函数？请从以下选项中选择最紧的渐近上界。\n\nA. $O(n^2)$\n\nB. $O(n^3)$\n\nC. $O(n^4)$\n\nD. $O(n^6)$\n\nE. $O(2^{(n^2)})$", "solution": "我们分析运行该递归过程的 NTM 在单条计算路径上所使用的非确定性空间。\n\n设 $L = 2^{(n^{2})}$。机器首先猜测 $k \\in \\{1,\\ldots,L\\}$，这需要 $O(\\log L)$ 的空间。由于 $\\log_{2} L = n^{2}$，因此这部分空间是 $O(n^{2})$。\n\n考虑递归过程 $\\text{Can\\_Reach}(A,B,k)$。定义 $S(k)$ 为求解参数为 $k$ 的调用时，在单条非确定性路径上使用的空间（不包括只读输入）。我们只计算工作空间。\n\n基本情况 $k=1$：为了检查是否存在 $G_{i} \\in S$ 使得 $A G_{i} = B$，我们可以一次计算一个乘积，这需要存储一个 $n \\times n$ 的矩阵结果，即 $O(n^{2})$ 的空间。因此，\n$$\nS(1) = O(n^{2}).\n$$\n\n递归情况 $k>1$：算法\n1) 非确定性地选择一个中间矩阵 $C$ 并存储它，这会消耗 $O(n^{2})$ 的空间；\n2) 递归调用 $\\text{Can\\_Reach}(A,C,\\lfloor k/2 \\rfloor)$，然后\n3) 调用 $\\text{Can\\_Reach}(C,B,k - \\lfloor k/2 \\rfloor)$。\n\n这两个递归调用是顺序执行的，但所选择的矩阵 $C$ 必须在两个调用期间都存在。因此，每一层递归会增加：\n- 一个存储的矩阵 $C$：$O(n^{2})$ 空间，\n- 一个存储的整型参数（例如当前的 $k$ 或其一半），大小为 $O(\\log L) = O(n^{2})$。\n\n因此，在更深的递归调用之上，每一层递归会增加 $O(n^{2} + \\log L) = O(n^{2})$ 的空间。写出递推关系，\n$$\nS(k) = S\\!\\left(\\left\\lfloor \\frac{k}{2} \\right\\rfloor\\right) + O(n^{2} + \\log L) = S\\!\\left(\\left\\lfloor \\frac{k}{2} \\right\\rfloor\\right) + O(n^{2}).\n$$\n递归深度为 $O(\\log_{2} k) \\le O(\\log_{2} L) = O(n^{2})$。展开递推式可得\n$$\nS(k) = O\\big((n^{2}) \\cdot \\log_{2} k\\big) + S(1) \\le O\\big(n^{2} \\cdot \\log_{2} L\\big) + O(n^{2}) = O(n^{2} \\cdot n^{2}) + O(n^{2}) = O(n^{4}).\n$$\n\n因此，基于 NTM 的算法在最坏情况下使用 $O(n^{4})$ 的空间。在给定的选项中，最紧的渐近上界是 $O(n^{4})$。", "answer": "$$\\boxed{C}$$", "id": "1453632"}]}