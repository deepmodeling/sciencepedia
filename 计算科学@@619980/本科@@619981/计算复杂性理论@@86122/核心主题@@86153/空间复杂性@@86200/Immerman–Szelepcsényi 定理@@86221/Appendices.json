{"hands_on_practices": [{"introduction": "理解 Immerman–Szelepcsényi 定理的核心是掌握其证明技术，即“归纳计数”。这个练习让你亲身体验这一过程。我们将通过一个“反向可达性”的场景来模拟这个计数过程：给定一个目标节点，我们迭代地计算可以到达它的节点集合的大小。这个过程与定理证明中从源头出发计算前向可达性集合的逻辑是完全对称的，能帮助你具体地理解算法是如何逐步构建和验证可达节点数的。[@problem_id:1458177]", "problem": "在一个大型分布式系统中，有一组 $N$ 个微服务，从 1 到 $N$ 连续编号，它们相互交互。这些交互由一个有向图 $G = (V, E)$ 描述，其中 $V = \\{1, 2, \\dots, N\\}$ 代表服务，一条有向边 $(u, v) \\in E$ 表示服务 $u$ 对服务 $v$ 进行网络调用。\n\n在一个特定的目标服务 $t$ 中检测到了一个严重故障。工程团队怀疑存在一个错误，该错误可能源于任何一个服务 $u$，只要从 $u$ 到 $t$ 存在一条服务调用路径。为了识别所有可能存在故障的服务，他们采用了一种基于归纳计数原理的分析方法，该原理是 Immerman–Szelepcsényi 定理证明的核心。\n\n设 $B_i(t)$ 是所有能通过长度至多为 $i$ 的路径到达服务 $t$ 的服务的集合。设 $k_i = |B_i(t)|$ 是这类服务的数量。团队的自动化分析工具已经计算出了最初几步的 $k_i$ 值。\n\n给定以下系统配置：\n- 服务总数，$N = 8$。\n- 观察到故障的目标服务，$t = 8$。\n- 所有通信路径（边）的集合是：\n  $E = \\{(1, 3), (2, 3), (3, 5), (4, 5), (4, 6), (5, 7), (6, 7), (7, 8)\\}$.\n- 已知在至多 $i=2$ 步内可到达 $t$ 的服务数量为 $k_2 = 4$。\n\n计算在至多 $i=3$ 步内可到达服务 $t=8$ 的服务的数量。换句话说，确定 $k_3$ 的值。", "solution": "给定一个有向图 $G=(V,E)$，其中 $V=\\{1,2,\\dots,8\\}$，目标节点 $t=8$，以及边集 $E=\\{(1,3),(2,3),(3,5),(4,5),(4,6),(5,7),(6,7),(7,8)\\}$。对于每个整数 $i\\geq 0$，定义 $B_{i}(t)$ 为可以通过长度至多为 $i$ 的有向路径到达 $t$ 的节点集合，并令 $k_{i}=|B_{i}(t)|$。归纳计数中使用的归纳步骤是：\n$$\nB_{i+1}(t)\\;=\\;B_{i}(t)\\;\\cup\\;\\{\\,u\\in V:\\exists\\,(u,v)\\in E\\text{ with }v\\in B_{i}(t)\\,\\}.\n$$\n我们还使用 $B_{0}(t)=\\{t\\}$（长度为 $0$ 的路径的可达性是指从 $t$ 到其自身）。我们验证给定的 $k_{2}=4$，然后计算 $k_{3}$。\n\n首先，计算 $B_{0}(t)$：\n$$\nB_{0}(t)=\\{8\\}.\n$$\n\n接下来，通过添加 $8$ 的所有入邻点来计算 $B_{1}(t)$：\n指向 $8$ 的唯一边是 $(7,8)$，所以\n$$\nB_{1}(t)=B_{0}(t)\\cup\\{7\\}=\\{8,7\\},\n\\quad k_{1}=2.\n$$\n\n然后，通过添加 $B_{1}(t)$ 中节点的所​​有入邻点来计算 $B_{2}(t)$。\n$7$ 的入邻点是 $5$ 和 $6$，$8$ 的入邻点是 $7$，但 $7$ 已经包含在内。因此\n$$\nB_{2}(t)=\\{8,7,5,6\\},\n\\quad k_{2}=4,\n$$\n这与给定值相符。\n\n现在通过添加 $B_{2}(t)$ 中节点的所​​有入邻点来计算 $B_{3}(t)$。\n入邻点如下：\n- 对于 $5$：节点 $3$ 和 $4$（通过边 $(3,5)$ 和 $(4,5)$），\n- 对于 $6$：节点 $4$（通过边 $(4,6)$），\n- 对于 $7$：节点 $5$ 和 $6$（通过边 $(5,7)$ 和 $(6,7)$）（已在 $B_{2}(t)$ 中），\n- 对于 $8$：节点 $7$（通过边 $(7,8)$）（已在 $B_{2}(t)$ 中）。\n因此，唯一新增的节点是 $3$ 和 $4$，得到\n$$\nB_{3}(t)=\\{8,7,5,6,3,4\\},\n\\quad k_{3}=|B_{3}(t)|=6.\n$$\n\n因此，在至多 $3$ 步内可到达 $t=8$ 的服务数量为 $k_{3}=6$。", "answer": "$$\\boxed{6}$$", "id": "1458177"}, {"introduction": "“归纳计数”究竟在计算什么？这是一个关键且容易混淆的问题。这个方法计算的是可达*节点*的*集合大小*，而不是从起点到终点的*路径*数量。这个练习通过对比两个算法来阐明这一区别：一个正确地计算了可达节点的数量，而另一个有缺陷的算法则错误地累加了路径。通过分析它们的输出，你将深刻理解为什么归纳计数依赖于集合的单调增长性质，以及为什么直接计数路径会破坏这一机制。[@problem_id:1458156]", "problem": "一位工程师正在设计两种简单的迭代算法，用于分析一个小型通信网络。该网络被建模为一个有向图 `G`，其顶点集为 `V = {A, B, C, D}`，边集为 `E = {(A, B), (A, C), (B, D), (C, D)}`。顶点 `A` 是所有分析的指定起点。设 `n=4` 为图中的顶点数。工程师需要你确定这两种不同算法的输出。\n\n**算法 1: `ComputeReachableSetSize`**\n\n该算法正确计算从起始顶点 `A` 可达的唯一顶点总数。它的工作原理是迭代地扩展一个可达顶点的集合。\n\n1.  初始化一个顶点集 `R`，包含起始顶点：`R = {A}`。\n2.  重复 `n` 次：\n    a. 创建一个临时集合 `N`，其中包含所有满足以下条件的顶点 `v`：在 `E` 中存在一条边 `(u, v)`，且 `u` 是当前在集合 `R` 中的一个顶点。\n    b. 通过与临时集合取并集来更新集合 `R`：`R = R \\cup N`。\n3.  该算法的最终输出是最终集合 `R` 的大小（基数）。\n\n**算法 2: `NaivePathAggregator`**\n\n该算法代表了一种有缺陷的路径计数尝试。它旨在聚合从 `A` 出发的路径计数，但其逻辑存在错误。它错误地将跟踪可达节点的逻辑与路径计数混合在一起。\n\n1.  初始化一个“已探索”顶点集 `S = {A}`。\n2.  初始化一个映射（例如，字典）`P`，用于存储每个顶点的计数。设置 `P[A] = 1`，并对 `V` 中所有其他顶点 `v` 设置 `P[v] = 0`。\n3.  重复 `n` 次：\n    a. 创建一个“新到达”顶点的临时集合 `T`，并初始化为空集。\n    b. 对于当前在集合 `S` 中的每个顶点 `u`：\n        i. 对于 `E` 中以 `u` 为起点的每条边 `(u, v)`：\n            - 将目标顶点 `v` 添加到集合 `T` 中。\n            - 将 `v` 的路径计数加一：`P[v] = P[v] + 1`。\n    c. 通过取并集来更新已探索顶点集：`S = S \\cup T`。\n4.  该算法的最终输出是为顶点 `D` 存储的计数，即 `P[D]` 的值。\n\n你的任务是在给定的图 `G` 上追踪这两种算法的执行过程。`ComputeReachableSetSize` 和 `NaivePathAggregator` 的最终输出值分别是多少？请将你的答案表示为一个行矩阵 `[Result1, Result2]`，其中 `Result1` 是第一个算法的输出，`Result2` 是第二个算法的输出。", "solution": "给定一个有向图，其顶点集为 $V=\\{A,B,C,D\\}$，边集为 $E=\\{(A,B),(A,C),(B,D),(C,D)\\}$，起始顶点为 $A$，两种算法都进行 $n=4$ 次迭代。\n\n对于算法 1 (`ComputeReachableSetSize`)，初始化 $R_{0}=\\{A\\}$。在每次迭代 $i$ 中，计算 $N_{i}=\\{v\\mid \\exists u\\in R_{i-1}:(u,v)\\in E\\}$，然后更新 $R_{i}=R_{i-1}\\cup N_{i}$。\n迭代 1：$R_{0}=\\{A\\}$。从 $A$ 出发有到 $B$ 和 $C$ 的边，所以 $N_{1}=\\{B,C\\}$ 且 $R_{1}=\\{A,B,C\\}$。\n迭代 2：$R_{1}=\\{A,B,C\\}$。从 $A$ 我们得到 $B,C$，从 $B$ 我们得到 $D$，从 $C$ 我们得到 $D$，因此 $N_{2}=\\{B,C,D\\}$ 且 $R_{2}=\\{A,B,C,D\\}$。\n迭代 3：$R_{2}=\\{A,B,C,D\\}$。从 $A,B,C$ 出发的边再次产生 $N_{3}=\\{B,C,D\\}$ 且 $R_{3}=\\{A,B,C,D\\}$。\n迭代 4：同样的模式得到 $N_{4}=\\{B,C,D\\}$ 且 $R_{4}=\\{A,B,C,D\\}$。\n因此，最终输出为 $|R_{4}|=4$。\n\n对于算法 2 (`NaivePathAggregator`)，初始化 $S_{0}=\\{A\\}$ 和路径计数 $P_{0}[A]=1$, $P_{0}[B]=0$, $P_{0}[C]=0$, $P_{0}[D]=0$。在每次迭代 $i$ 中，从 $T_{i}=\\varnothing$ 开始，然后对于每个 $u\\in S_{i-1}$ 和每条边 $(u,v)\\in E$，将 $v$ 添加到 $T_{i}$ 中并将 $P[v]$ 加 1，最后设置 $S_{i}=S_{i-1}\\cup T_{i}$。\n迭代 1：$S_{0}=\\{A\\}$。通过 $(A,B)$ 和 $(A,C)$ 处理 $A$ 得到 $T_{1}=\\{B,C\\}$，$P[B]=1$，$P[C]=1$，$P[D]=0$。更新 $S_{1}=\\{A,B,C\\}$。\n迭代 2：$S_{1}=\\{A,B,C\\}$。处理 $A$ 会使 $P[B]$ 和 $P[C]$ 各加 1；通过 $(B,D)$ 处理 $B$ 会使 $P[D]$ 加 1；通过 $(C,D)$ 处理 $C$ 会使 $P[D]$ 再加 1。因此 $P[B]=2$，$P[C]=2$，$P[D]=2$，并且 $T_{2}=\\{B,C,D\\}$，所以 $S_{2}=\\{A,B,C,D\\}$。\n迭代 3：$S_{2}=\\{A,B,C,D\\}$。处理 $A$ 会使 $P[B]$ 和 $P[C]$ 各加 1；处理 $B$ 会使 $P[D]$ 加 1；处理 $C$ 会使 $P[D]$ 再加 1；$D$ 没有出边。因此 $P[B]=3$，$P[C]=3$，$P[D]=4$，且 $S_{3}=\\{A,B,C,D\\}$。\n迭代 4：应用相同的更新，得到 $P[B]=4$，$P[C]=4$，$P[D]=6$，且 $S_{4}=\\{A,B,C,D\\}$。\n因此，算法 2 的最终输出是 $P[D]=6$。\n\n所要求的结果行矩阵是 $\\begin{pmatrix}4  6\\end{pmatrix}$。", "answer": "$$\\boxed{\\begin{pmatrix}4  6\\end{pmatrix}}$$", "id": "1458156"}, {"introduction": "Immerman–Szelepcsényi 定理一个深刻的结论是 $\\text{NL} = \\text{co-NL}$，这意味着非确定性对数空间可解的问题的补问题，同样也可以在非确定性对数空间内解决。本练习将这一理论应用于一个经典的 $\\text{co-NL}$ 问题：验证一个非确定性有限自动机（NFA）是否接受所有长度为 $k$ 的字符串。这要求我们使用非确定性算法来验证一个全称量词性质（“对于所有字符串”），而归纳计数正是实现这一看似矛盾任务的关键。这个练习将检验你是否理解了如何利用归纳计数来构建一个正确的验证程序。[@problem_id:1458147]", "problem": "考虑这样一个问题：判断一个给定的非确定性有限自动机 (NFA) $M = (Q, \\Sigma, \\delta, q_0, F)$ 是否接受所有长度为 $k$ 的字符串。设字母表为 $\\Sigma = \\{0, 1\\}$。这个问题，即判定语言 $ALL_{NFA,k}$，是复杂性类 coNL 中问题的一个经典例子。Immerman–Szelepcsényi 定理指出，非确定性空间有界复杂性类在补运算下是封闭的，这意味着 $ALL_{NFA,k}$ 也可以由一个仅使用对数空间的非确定性图灵机来判定。该定理的构造性证明依赖于一种称为“归纳计数”的技术。\n\n你的任务是分析一个使用此原理的非确定性算法。该算法在 NFA 的幂集构造（子集构造）的状态空间上运行，而无需显式地构建完整的幂集自动机。这个空间中的一个状态，我们称之为“子集状态”，是 NFA 状态集 $Q$ 的一个子集。初始子集状态是 $S_0 = \\{q_0\\}$。从一个子集状态 $S$ 经过一个输入符号 $\\sigma$ 的转移会到达子集状态 $S' = \\bigcup_{q \\in S} \\delta(q, \\sigma)$。如果一个子集状态 $S$ 不包含原 NFA 的任何终态，即 $S \\cap F = \\emptyset$，则该状态被定义为“拒绝状态”。\n\n这个问题等价于验证：从初始子集状态 $S_0$ 出发，在刚好 $k$ 步内无法到达任何拒绝子集状态。\n\n一个归纳计数算法首先计算每一步可达的子集状态的数量。令 $R_i$ 为从 $S_0$ 经过刚好 $i$ 步可达的所有子集状态的集合，并令 $c_i = |R_i|$。假设该算法已经成功计算出正确的计数序列 $c_0, c_1, \\ldots, c_k$。\n\n给定这些正确的计数值，以下哪个过程准确地描述了一个非确定性算法的最终验证步骤，以确认自动机 $M$ 确实接受所有长度为 $k$ 的字符串？\n\nA. 算法从 $S_0$ 出发，通过探索所有长度为 $k$ 的路径，确定性地构造集合 $R_k$。然后，它遍历 $R_k$ 中的每个状态 $S$，并检查是否有 $S \\cap F = \\emptyset$。如果找到这样的状态，则拒绝；否则，接受。\n\nB. 算法非确定性地猜测一个子集状态 $S$。然后验证 $S$ 在 $k$ 步内是可达的。如果可达，它会检查是否有 $S \\cap F = \\emptyset$。如果此条件满足，算法接受。如果算法的所有可能非确定性路径都未能找到这样一个拒绝状态，则机器拒绝。\n\nC. 算法使用计数值 $c_k$。它初始化一个计数器 `verified_count = 0`。然后，它遍历所有可能的子集状态 $S \\subseteq Q$。对于每个子集状态 $S$，它通过在 $R_{k-1}$ 中寻找一个有效的前驱（使用计数值 $c_{k-1}$ 来确保所有前驱都被统计）来非确定性地尝试验证 $S \\in R_k$。如果 $S$ 被验证在 $R_k$ 中，它将 `verified_count` 加一，并检查是否有 $S \\cap F = \\emptyset$。如果此条件在任何时候得到满足，算法立即拒绝。如果外层循环完成且 `verified_count` 等于 $c_k$ 并且没有发现任何拒绝状态，则算法接受。\n\nD. 算法使用计数值 $c_k$ 来一次性非确定性地猜测整个集合 $R_k$。它验证猜测的集合大小为 $c_k$。然后，它检查猜测集合的每个成员，看它是否为拒绝状态。如果没有成员是拒绝状态，则接受。", "solution": "我们将验证目标形式化。对于 NFA $M=(Q,\\Sigma,\\delta,q_{0},F)$，其中 $\\Sigma=\\{0,1\\}$，以及在 $2^{Q}$ 上的子集构造，我们将关于 $\\sigma\\in\\Sigma$ 的子集状态转移定义为\n$$\n\\Delta(S,\\sigma)\\;=\\;\\bigcup_{q\\in S}\\delta(q,\\sigma).\n$$\n令 $S_{0}=\\{q_{0}\\}$，$R_{i}$ 为从 $S_{0}$ 经过刚好 $i$ 步可达的子集状态的集合，且 $c_{i}=|R_{i}|$。如果 $S\\cap F=\\emptyset$，则子集状态 $S$ 是拒绝状态。性质“$M$ 接受所有长度为 $k$ 的字符串”等价于“$R_{k}$ 中没有任何拒绝子集状态”。\n\n假设我们已经有了正确的计数值 $c_{0},c_{1},\\ldots,c_{k}$。根据 Immerman–Szelepcsényi 方法，最终的验证必须使用归纳计数：它必须确认恰好有 $c_{k}$ 个不同的子集状态构成了 $R_{k}$（完备性和非重复性），并且这些状态中没有一个是拒绝状态。这可以通过在非确定性对数空间中完成：扫描候选状态 $S\\subseteq Q$，通过寻找一个前驱 $T\\in R_{k-1}$ 和一个符号 $\\sigma\\in\\Sigma$ 使得 $\\Delta(T,\\sigma)=S$ 来验证成员关系 $S\\in R_{k}$，并使用先前验证过的计数值 $c_{k-1}$ 来确保对 $R_{k}$ 的验证与已验证的 $R_{k-1}$ 保持一致，没有遗漏或重复成员。具体来说，对于每个 $S\\subseteq Q$，非确定性地搜索 $T\\subseteq Q$ 和 $\\sigma\\in\\Sigma$，使得 $T\\in R_{k-1}$ 并且 $\\Delta(T,\\sigma)=S$。如果找到，则增加一个已验证的 $R_{k}$ 中不同成员的计数器，并且如果 $S\\cap F=\\emptyset$，则立即拒绝。只有当已验证的不同成员总数等于 $c_{k}$ 且没有发现拒绝状态 $S$ 时，才接受。这正是归纳计数风格的验证：它保证了 $R_{k}$ 中所有且仅有的 $c_{k}$ 个成员都已得到验证，并且其中没有一个是拒绝状态。\n\n我们现在评估各个选项：\n\nA. 通过探索所有长度为 $k$ 的路径来确定性地构造 $R_{k}$，通常需要指数级别的时间和空间来枚举和存储子集状态，并且不符合作为归纳计数核心的非确定性对数空间方法。它没有反映 coNL 的验证技术。\n\nB. 非确定性地猜测一个 $S$ 并在其是拒绝状态且在 $k$ 步内可达时接受，这判定的是存在性属性“在 $R_{k}$ 中存在一个拒绝子集状态”，即判定的是补语言。它恰好在 $M$ 未能接受所有长度为 $k$ 的字符串时接受，这对于目标语言来说是错误的接受准则。\n\nC. 遍历所有子集状态 $S\\subseteq Q$，通过 $R_{k-1}$ 中的前驱来非确定性地验证 $S\\in R_{k}$，同时维护一个已验证的不同成员的计数器以使其等于 $c_{k}$，并在发现 $S\\cap F=\\emptyset$ 时立即拒绝，这与归纳计数验证范式相匹配。它使用计数值 $c_{k-1}$ 和 $c_{k}$ 来确保完备性和非重复性，并确认 $R_{k}$ 中没有任何成员是拒绝状态。这是正确的 coNL 风格的验证步骤。\n\nD. 一次性非确定性地猜测整个集合 $R_{k}$ 并检查其大小是否为 $c_{k}$，需要表示一个指数级大的集合并验证猜测的全局正确性，这在对数空间内是不可行的，也不是归纳计数的进行方式。\n\n因此，与归纳计数证明技术一致的、描述最终验证步骤的正确过程是选项 C。", "answer": "$$\\boxed{C}$$", "id": "1458147"}]}