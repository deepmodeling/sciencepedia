{"hands_on_practices": [{"introduction": "本练习是掌握 Horn-SAT 算法的第一步，旨在让你亲手模拟其执行过程。通过一个软件特征激活的直观场景，你将追踪一个多项式时间“标记”算法的运行，逐步推导出真值指派。这个实践有助于你建立对逻辑蕴含如何传播并最终确定最小满足赋值的直观感受。[@problem_id:1427138]", "problem": "一个软件功能激活管理系统由六个布尔功能的状态定义，这些状态由变量 $x_1, x_2, x_3, x_4, x_5, x_6$ 表示。变量值为1表示相应的功能为`ON`，而值为0则意味着该功能为`OFF`。\n\n系统的状态由一个应用一组规则的迭代激活算法决定。过程如下：\n1.  最初，所有功能都设置为`OFF`（所有变量均为0）。\n2.  然后系统应用一组激活规则。这一过程分轮进行。在每一轮中，算法会检查所有规则。如果某个规则的前提条件被当前`ON`状态的功能集合满足，则该规则的目标功能将被设为`ON`（其变量被设置为1）。\n3.  这个分轮应用规则的过程会一直持续，直到完整一轮结束后，没有新的功能被设为`ON`为止。\n\n系统的激活规则如下：\n- **规则 1:** 功能 1 为 `ON`。\n- **规则 2:** 功能 2 为 `ON`。\n- **规则 3:** 如果功能 1 为 `ON`，则功能 3 被设为 `ON`。\n- **规则 4:** 如果功能 3 和功能 4 为 `ON`，则功能 5 被设为 `ON`。\n- **规则 5:** 如果功能 5 为 `ON`，则功能 6 被设为 `ON`。\n- **规则 6:** 如果功能 2 和功能 6 为 `ON`，则功能 4 被设为 `ON`。\n\n算法完成后，功能的最终状态是什么？状态应表示为一个向量 $(x_1, x_2, x_3, x_4, x_5, x_6)$。\n\nA. (1, 1, 0, 0, 0, 0)\n\nB. (1, 1, 1, 0, 0, 0)\n\nC. (1, 1, 1, 1, 0, 0)\n\nD. (1, 1, 1, 1, 1, 1)\n\nE. (1, 0, 1, 0, 0, 0)", "solution": "我们将规则形式化为关于布尔变量 $x_{1},\\dots,x_{6}$ 的蕴含式：\n- 规则 1: $x_{1}=1$。\n- 规则 2: $x_{2}=1$。\n- 规则 3: $x_{1}=1 \\Rightarrow x_{3}=1$。\n- 规则 4: $(x_{3}=1) \\land (x_{4}=1) \\Rightarrow x_{5}=1$。\n- 规则 5: $x_{5}=1 \\Rightarrow x_{6}=1$。\n- 规则 6: $(x_{2}=1) \\land (x_{6}=1) \\Rightarrow x_{4}=1$。\n\n算法从全零状态开始，并重复应用这些蕴含式，直到在完整一轮中没有新的变量变为$1$为止。设第 $t$ 轮后的状态表示为 $x^{(t)}=(x_{1}^{(t)},x_{2}^{(t)},x_{3}^{(t)},x_{4}^{(t)},x_{5}^{(t)},x_{6}^{(t)})$。\n\n初始化得到\n$$\nx^{(0)}=(0,0,0,0,0,0).\n$$\n\n第 1 轮：\n- 根据规则1和规则2，我们设定 $x_{1}^{(1)}=1$ 和 $x_{2}^{(1)}=1$。\n- 由于 $x_{1}^{(1)}=1$，规则3适用，因此 $x_{3}^{(1)}=1$。\n- 规则4需要 $x_{3}=1$ 和 $x_{4}=1$ 同时成立，但 $x_{4}^{(1)}=0$，因此不适用。\n- 规则5需要 $x_{5}=1$，该条件未满足，因此不适用。\n- 规则6需要 $x_{2}=1$ 和 $x_{6}=1$ 同时成立，但 $x_{6}^{(1)}=0$，因此不适用。\n因此，在第 1 轮结束时，\n$$\nx^{(1)}=(1,1,1,0,0,0).\n$$\n\n第 2 轮：\n- 规则1、2和3的条件已被满足，但它们不会在 $x_{1}=1$、$x_{2}=1$、$x_{3}=1$ 的基础上引起任何新变化。\n- 规则4仍然不适用，因为它除了需要 $x_{3}=1$ 之外还需要 $x_{4}=1$，但 $x_{4}=0$。\n- 规则5仍然不适用，因为它需要 $x_{5}=1$，而该条件为假。\n- 规则6仍然不适用，因为它需要 $x_{6}=1$，而该条件为假。\n这一轮没有新的功能被开启，因此算法终止。\n\n因此，最终状态是\n$$\n(x_{1},x_{2},x_{3},x_{4},x_{5},x_{6})=(1,1,1,0,0,0),\n$$\n这对应于选项B。", "answer": "$$\\boxed{B}$$", "id": "1427138"}, {"introduction": "理解算法的适用边界与掌握算法本身同样重要。这个练习将挑战 Horn-SAT 标记算法的极限，通过将其应用于一个包含非 Horn 子句的公式，我们将揭示为何该算法无法保证对一般 SAT 问题找到解。这能深化我们对 Horn 子句这一结构特性为何是高效求解关键的理解。[@problem_id:1427136]", "problem": "在计算逻辑中，如果一个布尔公式是一个或多个子句的合取（AND, $\\land$），则称其为合取范式（CNF），其中子句是文字的析取（OR, $\\lor$）。文字可以是变量（正文字）或其否定（负文字）。Horn子句是最多只含一个正文字的子句。例如，$(\\neg v_1 \\lor \\neg v_2 \\lor v_3)$ 和 $(\\neg v_1 \\lor \\neg v_2)$ 是Horn子句，但 $(v_1 \\lor v_2)$ 不是。Horn可满足性问题（Horn-SAT）可在多项式时间内求解，其内容是判断一个完全由Horn子句组成的公式是否可满足。\n\nHorn-SAT 的一个标准算法是标记算法。考虑该算法的以下具体实现：\n1.  初始化一个空集合 `marked_vars`，用于存储被确定为 TRUE 的变量。\n2.  对于公式中每个形如 $(h)$ 的“单位子句”，将变量 $h$ 添加到 `marked_vars` 中。\n3.  重复以下操作，直到在一整轮遍历中没有新变量可以添加到 `marked_vars` 为止：\n    对于每个形如 $(\\neg l_1 \\lor \\neg l_2 \\lor \\dots \\lor \\neg l_k \\lor h)$ 的子句，如果所有负文字 $l_1, l_2, \\dots, l_k$ 对应的变量都已在 `marked_vars` 中，则将变量 $h$ 添加到 `marked_vars` 中。\n4.  循环终止后，提出了一个可能的满足赋值：`marked_vars` 中的所有变量设为 TRUE，所有其他变量设为 FALSE。\n5.  最后，进行一致性检查。对于每个只包含负文字的子句，例如 $(\\neg l_1 \\lor \\neg l_2 \\lor \\dots \\lor \\neg l_k)$，如果所有变量 $l_1, l_2, \\dots, l_k$ 都在 `marked_vars` 中，则算法报告公式为 UNSATISFIABLE。否则，它输出步骤4中提出的赋值。\n\n现在，考虑以下布尔公式 $\\phi$，它包含Horn子句和非Horn子句：\n$$ \\phi = (v_1 \\lor v_2) \\land (\\neg v_1 \\lor v_3) \\land (\\neg v_2) $$\n当上述标记算法应用于公式 $\\phi$ 时，结果是什么？\n\nA. 算法标记变量 $v_1$ 和 $v_3$，提出赋值 $(v_1, v_2, v_3) = (\\text{TRUE}, \\text{FALSE}, \\text{TRUE})$，并且此赋值正确地满足了 $\\phi$。\n\nB. 算法未能标记任何变量，提出赋值 $(v_1, v_2, v_3) = (\\text{FALSE}, \\text{FALSE}, \\text{FALSE})$，并且此赋值未能满足子句 $(v_1 \\lor v_2)$。\n\nC. 算法使用子句 $(\\neg v_2)$ 推断出 $v_2$ 必须为 FALSE，标记了 $v_1$ 和 $v_3$，并提出了正确的满足赋值。\n\nD. 算法未能标记任何变量，并且因为子句 $(\\neg v_2)$ 的存在，它在一致性检查期间报告公式为 UNSATISFIABLE。\n\nE. 算法无法处理非Horn子句 $(v_1 \\lor v_2)$，因此进入无限循环。", "solution": "将 $\\phi$ 的子句标记如下：\n$$C_{1}=(v_{1}\\lor v_{2}),\\quad C_{2}=(\\neg v_{1}\\lor v_{3}),\\quad C_{3}=(\\neg v_{2}).$$\n步骤1初始化 $\\mathrm{marked\\_vars}=\\varnothing$。\n\n在步骤2中，只有形如 $(h)$ 的单位子句会将变量 $h$ 添加到 $\\mathrm{marked\\_vars}$ 中。子句 $C_{3}$ 是 $(\\neg v_{2})$，不符合 $(h)$ 的形式，并且 $\\phi$ 中没有正单位子句。因此，没有变量被添加，$\\mathrm{marked\\_vars}=\\varnothing$。\n\n在步骤3中，我们遍历形如 $(\\neg l_{1}\\lor\\dots\\lor\\neg l_{k}\\lor h)$ 的子句，并在所有 $l_{i}$ 都已在 $\\mathrm{marked\\_vars}$ 中的情况下添加 $h$。子句 $C_{2}$ 符合此形式，其中 $k=1$，$l_{1}=v_{1}$，$h=v_{3}$，但条件要求 $v_{1}\\in\\mathrm{marked\\_vars}$，这是不成立的。子句 $C_{1}$ 不符合所需形式（它不是蕴含类型的Horn子句），而 $C_{3}$ 没有正文字头部 $h$。因此，在一整轮遍历中没有新变量被添加，循环终止，此时 $\\mathrm{marked\\_vars}=\\varnothing$。\n\n在步骤4中，提出的赋值将 `marked_vars` 中的所有变量设为 TRUE，所有其他变量设为 FALSE，得到 $(v_{1},v_{2},v_{3})=(\\text{FALSE},\\text{FALSE},\\text{FALSE})$。\n\n在步骤5中，一致性检查会审查只包含负文字的子句。唯一这样的子句是 $C_{3}=(\\neg v_{2})$。只有当这类子句中的所有变量都在 `marked_vars` 中时，算法才会报告 UNSAT。由于 $v_{2}\\notin\\mathrm{marked\\_vars}$，因此不会报告 UNSAT，算法输出所提出的赋值。\n\n最后，我们验证所提出的赋值是否满足 $\\phi$。在 $(v_{1},v_{2})=(\\text{FALSE},\\text{FALSE})$ 的条件下评估 $C_{1}$：\n$$(v_{1}\\lor v_{2})=\\text{FALSE}\\lor\\text{FALSE}=\\text{FALSE}.$$\n因此，该赋值未能满足 $\\phi$。此行为与选项B完全一致。", "answer": "$$\\boxed{B}$$", "id": "1427136"}, {"introduction": "高效算法的真正力量在于它们能作为基础模块来解决更复杂的问题。本练习从执行算法转向设计算法，要求我们利用一个已知的 Horn-SAT 求解器来解决一个相关的新问题。这个过程展示了计算科学中的一种核心思想——规约（reduction），即把一个新问题转化为一个已知的、可解的问题，从而体现了 Horn-SAT 算法的强大实用价值。[@problem_id:1427111]", "problem": "在人工智能领域，知识库通常由一组逻辑规则构建而成。一类特别高效且富有表达力的规则可以用Horn子句来建模。考虑一个使用此类知识库的医疗诊断系统。该系统的状态由一组命题变量描述，其中每个变量可能代表一个症状（例如 `has_fever`）或一个诊断（例如 `has_flu`）。\n\n让我们正式定义其组成部分：\n- **文字**（literal）是一个命题变量（一个正文字，例如 $x$）或其否定（一个负文字，例如 $\\neg x$）。\n- **Horn子句**（Horn clause）是最多只包含一个正文字的文字析取。Horn子句及其常见逻辑等价的示例如下：\n    1. 确定子句（definite clause）：$\\neg p_1 \\lor \\neg p_2 \\lor \\dots \\lor \\neg p_k \\lor q$，它等价于 $(p_1 \\land p_2 \\land \\dots \\land p_k) \\rightarrow q$。这表示一条规则，例如，“如果一个病人发烧且咳嗽，那么他们可能得了流感。”\n    2. 否定子句（negative clause）：$\\neg p_1 \\lor \\neg p_2 \\lor \\dots \\lor \\neg p_k$，它等价于 $(p_1 \\land p_2 \\land \\dots \\land p_k) \\rightarrow \\text{FALSE}$。这表示一个约束，例如，“一个病人不能同时患有疾病 A 和疾病 B。”\n    3. 事实（fact）：$q$，它等价于 $\\text{TRUE} \\rightarrow q$。这表示一个观察到的事实，例如，“该病人发烧了。”\n- **Horn公式**（Horn formula）$\\Phi$ 是Horn子句的合取（AND）。\n- **满足赋值**（satisfying assignment）是对所有变量进行真值（TRUE/FALSE）指派，使得整个公式 $\\Phi$ 的值为 TRUE。\n\n对于诊断系统来说，一个关键的查询是确定某个特定的诊断在逻辑上是否可能。给定代表整个知识库的Horn公式 $\\Phi$ 和一个代表潜在诊断的特定变量 $x$，开发者需要一个算法来解决 **HORN-EXIST-TRUE** 问题：确定是否存在*任何*使变量 $x$ 的值为 TRUE 的 $\\Phi$ 的满足赋值。\n\n对于给定的Horn公式 $\\Phi$ 和变量 $x$，以下哪个陈述正确描述了一种解决 HORN-EXIST-TRUE 问题的多项式时间方法？\n\nA. 该问题等价于检查 $\\Phi$ 的可满足性。如果 $\\Phi$ 有任何满足赋值，那么对于任何变量 $v$，必然存在某个满足赋值使其值为 TRUE。\n\nB. 使用标准的线性时间Horn可满足性（Horn-SAT）算法找到 $\\Phi$ 的最小满足赋值。变量 $x$ 能在一个满足赋值中被设为 TRUE，当且仅当 $x$ 在这个最小赋值中被设为 TRUE。\n\nC. 通过添加子句 $(\\neg x)$ 来修改公式 $\\Phi$，并检查结果公式是否可满足。如果结果公式不可满足，那么就可以将 $x$ 设为 TRUE。\n\nD. 该问题是 **NP**-完全的，是通用布尔可满足性问题（SAT）的一个已知的难解变体，因此据信不存在多项式时间算法。\n\nE. 通过添加子句 $(x)$ 来修改公式 $\\Phi$，形成一个新的公式 $\\Phi'$。用 $x$ 为 TRUE 来满足 $\\Phi$ 是可能的，当且仅当这个新公式 $\\Phi'$ 是可满足的。", "solution": "问题要求一个多项式时间算法，以确定在一个给定的Horn公式 $\\Phi$ 的任何满足赋值中，变量 $x$ 是否可以被设为 TRUE。这就是 HORN-EXIST-TRUE 问题。我们需要评估所提出的方法。关键在于将此问题与标准的Horn可满足性（Horn-SAT）问题联系起来，后者已知可在多项式时间（实际上是线性时间）内解决。\n\n让我们分析一下 HORN-EXIST-TRUE($\\Phi, x$) 和 Horn-SAT 之间的关系。我们在寻找一个赋值 $A$，使得 $A$ 满足 $\\Phi$ （记作 $A \\models \\Phi$）并且 $A(x) = \\text{TRUE}$。\n\n考虑选项 E 中的提议。我们构建一个新公式 $\\Phi' = \\Phi \\land (x)$。\n首先，我们观察到 $\\Phi'$ 也是一个Horn公式。原始公式 $\\Phi$ 是Horn子句的合取。新子句 $(x)$ 本身也是一个Horn子句（它恰好包含一个正文字和零个负文字，等价于 $\\text{TRUE} \\rightarrow x$）。Horn子句的合取结果仍是一个Horn公式。由于 Horn-SAT 可在多项式时间内解决，因此检查 $\\Phi'$ 的可满足性也可以在多项式时间内完成。\n\n现在，我们必须证明这种方法是正确的。也就是说，我们必须证明“存在一个 $x=\\text{TRUE}$ 的 $\\Phi$ 的满足赋值”当且仅当“$\\Phi'$ 是可满足的”。\n\n**第一部分：(⇒) 假设存在一个 $x=\\text{TRUE}$ 的 $\\Phi$ 的满足赋值。**\n设这个赋值为 $A$。根据定义，我们有：\n1. $A \\models \\Phi$（$A$ 满足 $\\Phi$）\n2. $A(x) = \\text{TRUE}$\n\n我们想证明 $\\Phi'$ 是可满足的。如果一个赋值满足一个合取的每个部分，那么它就满足该合取。\n公式是 $\\Phi' = \\Phi \\land (x)$。\n- $A$ 是否满足 $\\Phi$？是的，根据假设 (1)。\n- $A$ 是否满足子句 $(x)$？是的，因为一个赋值要满足一个单文字子句，它必须将该文字赋值为 TRUE，而我们从 (2) 知道 $A(x) = \\text{TRUE}$。\n由于 $A$ 同时满足 $\\Phi$ 和 $(x)$，所以它是它们合取 $\\Phi'$ 的一个满足赋值。因此，$\\Phi'$ 是可满足的。\n\n**第二部分：(⇐) 假设 $\\Phi' = \\Phi \\land (x)$ 是可满足的。**\n根据定义，这意味着存在一个赋值，我们称之为 $A'$，使得 $A' \\models \\Phi'$。\n由于 $A'$ 满足合取 $\\Phi \\land (x)$，它必须满足每个部分：\n1. $A' \\models \\Phi$\n2. $A' \\models (x)$\n\n从 (2) 可知，为了让 $A'$ 满足子句 $(x)$，必须有 $A'(x) = \\text{TRUE}$。\n从 (1) 我们知道，这同一个赋值 $A'$ 是原始公式 $\\Phi$ 的一个满足赋值。\n所以，我们找到了一个赋值，即 $A'$，它满足 $\\Phi$ 并且其中 $x$ 被赋值为 TRUE。这正是 HORN-EXIST-TRUE 问题所要求的。\n\n这证明了检查 $\\Phi' = \\Phi \\land (x)$ 的可满足性是解决 HORN-EXIST-TRUE($\\Phi, x$) 的一个正确的、多项式时间的方法。因此，选项 E 是正确的。\n\n让我们简要分析一下为什么其他选项是错误的：\n- **A**: 这是错误的。一个公式可能是可满足的，但某些变量在所有满足赋值中可能都被强制为 FALSE。例如，$\\Phi = (\\neg x)$ 是一个Horn公式。它可以通过将 $x$ 设为 FALSE 来满足。不存在 $x=\\text{TRUE}$ 的满足赋值。\n- **B**: 这是不正确的。标准的 Horn-SAT 算法找到的是*最小满足赋值*，其中值为 TRUE 的变量集合是最小的。这个赋值告诉我们哪些变量在任何满足赋值中都*必须*为 TRUE。一个变量 $x$ 在最小模型中可能为 FALSE，但在其他非最小的满足赋值中可以被设为 TRUE。例如，考虑 $\\Phi = (p \\rightarrow q)$。最小模型是 $\\{p=\\text{FALSE}, q=\\text{FALSE}\\}$。在这里，$p$ 是 FALSE。然而，赋值 $\\{p=\\text{TRUE}, q=\\text{TRUE}\\}$ 也满足 $\\Phi$。所以，即使 $p$ 在最小模型中为假，它也可能为真。\n- **C**: 通过添加 $(\\neg x)$ 来修改 $\\Phi$ 是在测试一个错误的属性。$(\\neg x)$ 等价于 $(x \\rightarrow \\text{FALSE})$，这是一个Horn子句。公式 $\\Phi \\land (\\neg x)$ 可满足当且仅当存在一个 $x$ 为 FALSE 的 $\\Phi$ 的满足赋值。该选项提出，如果这个新公式*不可满足*，那么就可以将 $x$ 设为 TRUE。这意味着 $\\Phi$ 的*每个*满足赋值都必须使 $x=\\text{TRUE}$。这回答的是“$x$ 必须为真吗？”的问题，而不是“$x$ 可以为真吗？”。\n- **D**: 这是不正确的。如前所示，该问题可以在多项式时间内归约到 Horn-SAT，后者是复杂度类 **P** 中的一个经典问题（可在多项式时间内解决）。因此，HORN-EXIST-TRUE 也在 **P** 中，而不是 **NP**-完全的。\n\n基于此分析，选项 E 提供了正确且计算上高效的方法。", "answer": "$$\\boxed{E}$$", "id": "1427111"}]}