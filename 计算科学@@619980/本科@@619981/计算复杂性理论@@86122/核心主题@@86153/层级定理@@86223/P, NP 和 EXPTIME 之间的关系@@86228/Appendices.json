{"hands_on_practices": [{"introduction": "理解复杂性类的第一步是学习根据其形式化定义对算法进行分类。这个练习旨在检验你对 EXPTIME 定义的理解，特别是它是一个时间复杂度*上界*的概念，你需要运用数学不等式技巧，来比较阶乘函数$O(n!)$与指数函数的增长率，从而确定一个具体算法的归属 [@problem_id:1445364]。", "problem": "在计算复杂性理论中，问题根据解决它们所需的资源被划分为不同的类别。EXPTIME 就是这样的一个类别。\n\n复杂性类别 EXPTIME（代表指数时间）被定义为所有可以在确定性图灵机上于 $O(2^{p(n)})$ 时间内解决的判定问题的集合，其中 $p(n)$ 是输入规模 $n$ 的某个多项式函数。\n\n假设一位计算机科学家为某个判定问题设计了一个新算法。经过仔细分析，他们确定该算法的最坏情况时间复杂度为 $T(n) = O(n!)$，其中 $n$ 是输入规模。\n\n根据这些信息，以下哪个陈述是正确的？\n\nA. 该问题保证在 EXPTIME 中，因为对于大的 $n$，$n!$ 的增长速度慢于 $2^n$。\n\nB. 该问题保证在 EXPTIME 中，因为 $n!$ 的增长被某个多项式 $p(n)$ 的 $2^{p(n)}$ 所界定。\n\nC. 该问题不保证在 EXPTIME 中，因为 $n!$ 的增长速度快于任何 $2^{p(n)}$形式的函数，其中 $p(n)$ 是一个多项式。\n\nD. 无法确定该问题是否在 EXPTIME 中，因为阶乘时间复杂度与指数时间复杂度类别无关。", "solution": "根据定义，如果存在一个确定性图灵机能在 $O(2^{p(n)})$ 时间内解决一个判定问题，其中 $p(n)$ 是输入规模 $n$ 的某个多项式，那么该问题就属于 EXPTIME。\n\n我们给定一个算法，其最坏情况时间复杂度为 $T(n) = O(n!)$。为了将 $n!$ 与 $2^{p(n)}$ 形式的函数联系起来，我们使用基本界限\n$$\nn! \\leq n^{n}.\n$$\n将 $n^{n}$ 写成指数形式：\n$$\nn^{n} = 2^{n \\log_{2} n}.\n$$\n对于所有 $n \\geq 1$，我们有 $\\log_{2} n \\leq n$，因此\n$$\nn \\log_{2} n \\leq n^{2}.\n$$\n所以，\n$$\nn! \\leq n^{n} = 2^{n \\log_{2} n} \\leq 2^{n^{2}}.\n$$\n因此，存在一个多项式 $p(n) = n^{2}$，使得 $n! = O(2^{p(n)})$。因为 $T(n) = O(n!)$，所以可以得出\n$$\nT(n) = O(2^{n^{2}}),\n$$\n这符合 EXPTIME 的标准。\n\n现在评估各个选项：\n\n- A 是错误的，因为 $n!$ 的增长速度并不慢于 $2^{n}$；事实上，对于足够大的 $n$，$n!$的增长速度远快于$2^n$。\n- B 是正确的，如上所示：$n! \\leq 2^{n^{2}}$，其中多项式 $p(n)=n^{2}$，这意味着该问题属于 EXPTIME。\n- C 是错误的，因为 $n!$ 的增长速度并非快于每一个多项式 $p$ 对应的 $2^{p(n)}$；例如，$2^{n^{2}}$ 的增长速度就快于 $n!$。\n- D 是错误的，因为我们可以确定其归属：该问题在 EXPTIME 中。\n\n因此，正确选项是 B。", "answer": "$$\\boxed{B}$$", "id": "1445364"}, {"introduction": "除了对已有算法进行分类，我们还可以通过关于假设计算模型的思想实验来加深对复杂性类的理解。这个练习通过一个巧妙的构造，揭示了指数时间与在指数级增长的输入上运行多项式时间算法的等价性，这种“填充”（padding）论证是计算复杂性理论中一个非常有力的工具 [@problem_id:1445367]。", "problem": "在计算复杂性理论中，我们经常通过考虑假设性的计算模型来探索不同复杂性类之间的关系。想象一种特殊类型的机器，称为“指数预处理器”（Exponential Preprocessor）。该机器分两个阶段对二进制输入字符串 $x$ 进行操作。\n\n首先，在预处理阶段，它接收长度为 $n = |x|$ 的输入字符串 $x$，并生成一个新的、经过填充的字符串 $y$。字符串 $y$ 是通过取原始字符串 $x$ 并在其后附加一个特殊的填充字符（不在原始二进制字母表中）直到 $y$ 的总长度恰好为 $2^n$ 来创建的。\n\n其次，在计算阶段，该机器将这个填充后的字符串 $y$ 输入到一个标准的确定性算法中，已知该算法的运行时间相对于其输入长度是多项式时间的。也就是说，如果该算法的输入长度为 $L$，其运行时间受 $O(L^k)$ 的限制，其中 $k \\ge 1$ 是某个固定的常数。\n\n令 $S$ 为可由指数预处理器解决的所有判定问题的集合，其中复杂性是相对于原始输入大小 $n$ 来度量的。下列哪个标准复杂性类等价于 $S$？\n\nA. P (多项式时间)\n\nB. NP (非确定性多项式时间)\n\nC. PSPACE (多项式空间)\n\nD. EXPTIME (指数时间)\n\nE. NEXPTIME (非确定性指数时间)", "solution": "为了确定与“指数预处理器”可解决的问题集合 $S$ 等价的复杂性类，我们需要分析该机器所花费的总时间，将其表示为原始输入大小 $n = |x|$ 的函数。\n\n步骤 1：分析输入转换。\n原始输入是长度为 $n$ 的字符串 $x$。预处理器将其转换为长度为 $|y| = 2^n$ 的新字符串 $y$。这个填充步骤本身所需的时间与新字符串的长度成正比，即 $O(2^n)$。\n\n步骤 2：分析计算阶段的运行时间。\n问题陈述指出，在填充后的字符串 $y$ 上运行的算法的时间复杂度相对于 $y$ 的长度是多项式的。设 $|y| = L$。该算法的运行时间为 $T_{algo}(L) = O(L^k)$，其中 $k \\ge 1$ 是某个常数整数。\n\n步骤 3：用原始输入大小 $n$ 表示总运行时间。\n我们需要将整个过程的运行时间表示为 $n$ 的函数。填充后字符串的长度为 $L = |y| = 2^n$。将此代入多项式时间复杂度的表达式中，得到：\n$$T(n) = T_{algo}(|y|) = T_{algo}(2^n) = O\\left((2^n)^k\\right) = O\\left(2^{nk}\\right)$$\n填充步骤的时间是 $O(2^n)$，对于 $k \\ge 1$，这个时间被计算步骤的时间 $O(2^{nk})$ 所主导。因此，指数预处理器相对于原始输入大小 $n$ 的总时间复杂度是 $O(2^{nk})$。\n\n步骤 4：将导出的时间复杂度与标准复杂性类相关联。\n现在我们将这个时间复杂度与给定类的定义进行比较。\n复杂性类 EXPTIME（指数时间）被定义为所有可由确定性图灵机在 $O(2^{p(n)})$ 时间内解决的判定问题的集合，其中 $p(n)$ 是输入大小 $n$ 的某个多项式。\n\n在我们的例子中，运行时间是 $O(2^{nk})$。指数 $nk$ 是 $n$ 的一个多项式（具体来说，它是一个线性多项式，$p(n) = nk$）。因此，任何可由指数预处理器解决的问题都可以在符合 EXPTIME 定义的时间内解决。这意味着 $S \\subseteq \\text{EXPTIME}$。\n\n步骤 5：论证等价性（$S = \\text{EXPTIME}$）。\n为了证明这两个类是等价的，我们还需要证明 EXPTIME 中的任何问题都可以由我们的指数预处理器解决。\n设 $A$ 是 EXPTIME 中的任意一个问题。根据定义，存在一个确定性图灵机 $M$ 在 $O(2^{p(n)})$ 时间内解决 $A$，其中 $p(n)$ 是某个多项式。\n\n我们可以为我们的指数预处理器的计算阶段构建一个算法来解决 $A$。该算法接收长度为 $2^n$ 的填充字符串 $y$ 作为输入，提取原始的前 $n$ 位以恢复 $x$，然后在输入 $x$ 上模拟图灵机 $M$。\n\n在 $x$ 上模拟 $M$ 需要 $O(2^{p(n)})$ 步。我们需要检查这个模拟时间是否是字符串 $y$ 长度的多项式，其中 $L = 2^n$。\n模拟时间为 $T_{sim} = O(2^{p(n)})$。我们算法的输入长度为 $L = 2^n$。\n$T_{sim}$ 是 $L$ 的多项式吗？$L$ 的多项式形式为 $O(L^k) = O((2^n)^k) = O(2^{nk})$，其中 $k$ 是某个常数。\n我们的模拟时间是 $O(2^{p(n)})$。由于 $p(n)$ 是 $n$ 的多项式，我们总能找到一个线性多项式 $nk$（通过选择一个足够大的整数 $k$），使得对于所有足够大的 $n$，$p(n) \\le nk$。例如，如果 $p(n) = a_d n^d + \\dots + a_0$，我们可以选择足够大的 $k$ 来确保该不等式成立。\n因此，模拟时间 $O(2^{p(n)})$ 受 $O(2^{nk})$ 的限制，而 $O(2^{nk})$ 是 $L = 2^n$ 的多项式。这意味着我们为计算阶段构建的算法在其输入 $y$ 方面是多项式时间运行的。\n\n由于 EXPTIME 中的任何问题都可以由指数预处理器解决，我们有 $\\text{EXPTIME} \\subseteq S$。\n结合两个包含关系（$S \\subseteq \\text{EXPTIME}$ 和 $\\text{EXPTIME} \\subseteq S$），我们得出结论 $S = \\text{EXPTIME}$。\n\n其他选项不正确：\n- A. P：运行时间相对于 $n$ 是指数的，而不是多项式的。\n- B. NP：NP 包含在 EXPTIME 中，但这个过程可以解决被认为在 NP 之外的问题（即 EXPTIME 中的所有问题）。\n- C. PSPACE：该过程仅存储填充后的字符串 $y$ 就至少需要 $O(2^n)$ 的空间。这是指数空间，而不是多项式空间。\n- E. NEXPTIME：所描述的机器是确定性的，因此它自然地定义了一个确定性时间复杂性类。\n\n因此，问题集合 $S$ 等价于 EXPTIME。", "answer": "$$\\boxed{D}$$", "id": "1445367"}, {"introduction": "完备性（completeness）和归约（reduction）是理解复杂性领域结构性关系的核心，针对某一个“最难”问题的突破性进展，可能会对整个复杂性类产生连锁反应。这个更具挑战性的练习将促使你分析一个假设性发现所带来的后果：一个针对 EXPTIME-完备问题出人意料的高效算法，你需要综合运用关于完备性、归约和算法分析的知识，来推导计算复杂性理论中的一个重大结构性变化 [@problem_id:1445386]。", "problem": "在计算复杂性理论中，EXPTIME 类包含所有可由确定性图灵机在相对于输入规模 $n$ 的指数时间内解决的判定问题。形式上，$\\text{EXPTIME} = \\bigcup_{c \\ge 1} \\text{DTIME}(2^{n^c})$，其中 DTIME($f(n)$) 是可在 $O(f(n))$ 时间内解决的问题类。如果一个问题属于 EXPTIME，并且 EXPTIME 中的每个问题都可以在多项式时间内归约到它，那么该问题是 EXPTIME-完全的。\n\n一位理论计算机科学家正在研究一个与博弈论相关的著名 EXPTIME-完全问题，我们称之为 GENERALIZED HEX。该问题的一个实例是一个游戏状态，问题是先手玩家是否存在必胜策略。实例的规模用 $n$ 表示。\n\n这位科学家提出了一个非凡的主张。他们断言存在一个确定性算法，我们称之为 `Shrink`，它可以在 $n$ 的多项式时间内，将 GENERALIZED HEX 的任意规模为 $n$ 的实例 $I$ 转换成一个新的、更小但逻辑等价的实例 $I'$。其主张的关键部分是新实例的规模 $|I'|$；他们声称它受限于原始规模自然对数的多项式，即对于某些固定的正常数 $c$ 和 $d$，有 $|I'| \\le c \\left(\\ln n\\right)^d$。如果对于判定问题（“玩家1是否获胜？”）的答案相同，则两个实例是逻辑等价的。\n\n如果这一主张为真，它将意味着计算复杂性类的重大塌陷。下列哪个陈述是该科学家主张最直接和最准确的推论？\n\nA. P = NP\n\nB. NP = EXPTIME\n\nC. EXPTIME 塌陷到可在准多项式时间内解决的问题类，即由确定性图灵机在 $O(n^{(\\ln n)^k})$ 时间内（对于某个常数 $k$）解决的问题类。\n\nD. 多项式谱系塌陷到其第一层（$\\text{PH} = \\Sigma_1^p$）。\n\nE. EXPTIME = PSPACE", "solution": "设 GENERALIZED HEX 是 EXPTIME-完全的，并设所声称的算法 `Shrink` 可在 $n^{O(1)}$ 时间内将任意规模为 $n$ 的实例 $I$ 映射到一个逻辑等价的实例 $I'$，其规模为 $|I'| \\le c(\\ln n)^{d}$，其中 $c$ 和 $d$ 是固定的正常数。因为 GENERALIZED HEX 属于 EXPTIME，所以存在一个确定性算法 $\\mathcal{A}$ 和一个常数 $a \\ge 1$，使得对于任意规模为 $m$ 的输入，$\\mathcal{A}$ 都能在至多\n$$\nT_{\\mathcal{A}}(m) \\le 2^{m^{a}} = \\exp\\!\\left(m^{a}\\ln 2\\right)\n$$\n的时间内判定它。\n给定一个规模为 $n$ 的输入 $I$，我们在 $n^{O(1)}$ 时间内计算出 $I'$，然后在 $I'$ 上运行算法 $\\mathcal{A}$。$I'$ 的规模 $m$ 满足 $m \\le c(\\ln n)^{d}$。因此，总运行时间为\n$$\nn^{O(1)} \\;+\\; 2^{(c(\\ln n)^{d})^{a}}\n\\;=\\; n^{O(1)} \\;+\\; 2^{c^{a}(\\ln n)^{ad}}\n\\;\\le\\; 2^{O((\\ln n)^{ad})}.\n$$\n将指数部分重写为准多项式形式。对于任意实数 $r>0$，\n$$\n2^{(\\ln n)^{r}} \\;=\\; \\exp\\!\\left((\\ln n)^{r}\\ln 2\\right)\n\\;=\\; \\exp\\!\\left((\\ln 2)\\,(\\ln n)^{r-1}\\cdot \\ln n\\right)\n\\;=\\; n^{(\\ln 2)\\,(\\ln n)^{r-1}}.\n$$\n因此，对于 $r=ad>0$，我们得到\n$$\n2^{O((\\ln n)^{ad})} \\;=\\; n^{O((\\ln n)^{ad-1})},\n$$\n这是准多项式时间，因为存在一个常数 $k$，使得对于所有足够大的 $n$，都有 $n^{O((\\ln n)^{ad-1})} \\le n^{(\\ln n)^{k}}$。\n\n因此，GENERALIZED HEX 可以在准多项式时间内解决。因为 GENERALIZED HEX 在多项式时间多一归约下是 EXPTIME-完全的，所以对于任何语言 $L \\in \\text{EXPTIME}$，都存在一个多项式时间归约 $f$，使得 $x \\in L$ 当且仅当 $f(x) \\in \\text{GENERALIZED HEX}$。对于长度为 $N$ 的输入 $x$，我们在 $N^{O(1)}$ 时间内计算出 $y=f(x)$，其长度 $|y| \\le N^{O(1)}$，然后对 $y$ 应用 `Shrink` 算法，并如上所述在准多项式时间内解决所得的实例。总时间为\n$$\nN^{O(1)} \\;+\\; |y|^{(\\ln |y|)^{k}} \\;\\le\\; N^{O((\\ln N)^{k})},\n$$\n这是准多项式时间。因此 $\\text{EXPTIME} \\subseteq \\text{QP}$，其中 $\\text{QP}$ 表示准多项式时间。\n\n反之，$\\text{QP} \\subseteq \\text{EXPTIME}$，因为对于任意固定的 $k$，\n$$\nn^{(\\ln n)^{k}} \\;=\\; \\exp\\!\\left((\\ln n)^{k+1}\\right) \\;\\le\\; \\exp\\!\\left(n\\right) \\;\\approx\\; 2^{1.44 n}\n$$\n对于所有足够大的 $n$ 成立，因此准多项式时间是 EXPTIME 的一个子类。结合这两个包含关系可得 $\\text{EXPTIME} = \\text{QP}$。\n\n这正是选项 C 的内容：EXPTIME 塌陷到可在准多项式时间内解决的问题类。", "answer": "$$\\boxed{C}$$", "id": "1445386"}]}