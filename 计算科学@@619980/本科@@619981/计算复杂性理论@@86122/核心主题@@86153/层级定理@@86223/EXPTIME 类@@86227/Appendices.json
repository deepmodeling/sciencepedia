{"hands_on_practices": [{"introduction": "这第一个练习旨在检验你对 EXPTIME 的基本理解。其形式化定义——运行时间为 $O(2^{p(n)})$，其中 $p(n)$ 是一个多项式——是分类算法的“模板”。本练习将挑战你用这个定义来衡量各种常见的运行时间函数，帮助你区分哪些属于指数时间，哪些增长得更快。[@problem_id:1452143]", "problem": "在计算复杂性理论中，判定问题根据解决它们所需的资源被划分为不同的复杂性类。其中一个基本的复杂性类是 EXPTIME（指数时间）。如果存在一个确定性图灵机，它可以在 $O(2^{p(n)})$ 的时间复杂度内解决一个判定问题，那么该问题就属于 EXPTIME 类，其中 $n$ 是输入的大小，$p(n)$ 是关于 $n$ 的任意多项式函数。\n\n一名计算机科学专业的学生正在分析五种不同的算法，每种算法都旨在解决一个不同的问题。这些算法的最坏情况时间复杂度已经被确定为输入大小 $n$ 的函数。\n\n- 算法 A: $O(2^{n^4})$\n- 算法 B: $O(2^{\\sqrt{n}})$\n- 算法 C: $O(1.5^n)$\n- 算法 D: $O(2^{2^n})$\n- 算法 E: $O(n^{1000})$\n\n上面列出的时间复杂度中，哪一个对应的问题**不**保证属于 EXPTIME 类？", "solution": "EXPTIME 是指可以由确定性图灵机在时间 $O(2^{p(n)})$ 内解决的判定问题类，其中 $p(n)$ 是某个多项式。\n\n根据多项式 $p$ 的 $2^{p(n)}$ 形式来评估每个算法：\n- 算法 A 的时间复杂度为 $O(2^{n^4})$。这里 $p(n)=n^4$ 是一个多项式，因此 $O(2^{n^4}) \\subseteq \\text{EXPTIME}$。\n\n- 算法 B 的时间复杂度为 $O(2^{\\sqrt{n}})$。由于对于所有 $n \\ge 1$，都有 $\\sqrt{n} \\le n$，我们得到 $2^{\\sqrt{n}} \\le 2^n$，所以 $O(2^{\\sqrt{n}}) \\subseteq O(2^n)$，其中 $p(n)=n$ 是一个多项式。因此它属于 EXPTIME。\n\n- 算法 C 的时间复杂度为 $O(1.5^n)$。利用 $1.5^n = 2^{(\\log_2(1.5))n}$，其中常数 $\\log_2(1.5) \\le 1$，对于所有 $n \\ge 1$，我们有 $1.5^n \\le 2^n$，所以 $O(1.5^n) \\subseteq O(2^n)$，其中 $p(n)=n$ 是一个多项式。因此它属于 EXPTIME。\n\n- 算法 E 的时间复杂度为 $O(n^{1000})$。由于指数函数增长快于多项式函数，$\\lim_{n\\to\\infty}\\frac{n^{1000}}{2^n}=0$，因此存在一个 $N$，使得对于所有 $n \\ge N$，都有 $n^{1000} \\le 2^n$。所以 $O(n^{1000}) \\subseteq O(2^n)$，其中 $p(n)=n$ 是一个多项式，因此它属于 EXPTIME。\n\n- 算法 D 的时间复杂度为 $O(2^{2^n})$。对于任何多项式 $p(n)$，当 $n$ 足够大时，我们有 $2^n > p(n)$，这意味着最终会有 $2^{2^n} > 2^{p(n)}$。因此，对于任意多项式 $p$，$2^{2^n} \\notin O(2^{p(n)})$，所以这个界不保证属于 EXPTIME。\n\n因此，只有双指数时间 $O(2^{2^n})$ 不保证属于 EXPTIME。", "answer": "$$\\boxed{D}$$", "id": "1452143"}, {"introduction": "许多算法，特别是解决难题的算法，其工作原理是在一个巨大的潜在解空间中进行搜索。本练习探讨了一种常见的算法结构：生成指数数量的候选解，然后逐一验证。它揭示了一个关键的洞察：仅仅包含指数级的步骤并不能自动保证算法属于 EXPTIME；每一步的计算成本同样至关重要。[@problem_id:1452149]", "problem": "在计算复杂性理论中，EXPTIME类（也称为 EXP）是所有可以在 $O(2^{p(n)})$ 时间内由确定性图灵机解决的判定问题的集合，其中 $p(n)$ 是输入规模 $n$ 的一个多项式函数。\n\n一名计算机科学专业的学生正在设计一个算法来解决一个复杂的判定问题。该算法处理大小为 $n$ 的输入。其通用策略是一种穷举搜索，包含两个阶段：\n1.  **生成**：算法生成一个完整的候选解集合。生成的不同候选解的总数恰好是 $2^n$。\n2.  **验证**：对于这 $2^n$ 个候选解中的每一个，算法都会运行一个验证子程序来检查该候选解是否是问题的有效解。我们将这个验证子程序的时间复杂度记作函数 $V(n)$，它依赖于原始输入规模 $n$。\n\n该学生算法的总运行时间因此为 $T(n) = 2^n \\cdot V(n)$。该学生声称他们的算法将该问题归入 EXPTIME 类。要使这一声称成立，以下哪个陈述为验证时间 $V(n)$ 提供了最准确和最普适的条件？\n\nA. 无论函数 $V(n)$ 是什么，该算法都保证属于 EXPTIME，因为候选解的数量 $2^n$ 已经是指数级的。\nB. 该算法保证属于 EXPTIME，当且仅当 $V(n)$ 是 $n$ 的多项式函数，即 $V(n) = O(n^k)$ 对于某个常数 $k$。\nC. 如果 $V(n)$ 的上界为一个关于 $n$ 的多项式的指数函数，即对于某个多项式 $q(n)$ 有 $V(n) = O(2^{q(n)})$，则该算法保证属于 EXPTIME。\nD. 该算法保证属于 EXPTIME，当且仅当被解决的问题是 NP-完全的，因为所有 NP-完全问题都在 EXPTIME 中。\nE. 该算法不可能属于 EXPTIME，因为总运行时间 $T(n)$ 涉及与 $2^n$ 的乘积，其增长速度总是快于 $O(2^{p(n)})$ 的界限。", "solution": "根据定义，一个判定问题属于 EXPTIME，如果存在一个多项式 $p(n)$，使得该问题可以在确定性图灵机上于 $O(2^{p(n)})$ 时间内被解决。所描述的算法的总运行时间为\n$$\nT(n) = 2^n \\cdot V(n).\n$$\n要使该算法将问题归入 EXPTIME，必须存在一个多项式 $p(n)$ 和一个常数 $c>0$，使得\n$$\nT(n) \\le c \\cdot 2^{p(n)} \\quad \\text{for all sufficiently large } n.\n$$\n将 $T(n) = 2^n V(n)$ 代入，得到等价条件\n$$\n2^n V(n) \\le c \\cdot 2^{p(n)}.\n$$\n两边同除以 $2^n$ 得出\n$$\nV(n) \\le c \\cdot 2^{p(n)-n}.\n$$\n定义 $q(n) = p(n) - n$。由于 $p(n)$ 是一个多项式，而 $n$ 是一个1次多项式，所以 $q(n)$ 也是一个多项式。因此，上述条件等价于\n$$\nV(n) = O(2^{q(n)}) \\quad \\text{for some polynomial } q(n).\n$$\n这证明了充分性：如果对于一个多项式 $q(n)$，有 $V(n) = O(2^{q(n)})$，那么\n$$\nT(n) = 2^n V(n) = O(2^n \\cdot 2^{q(n)}) = O(2^{n+q(n)}),\n$$\n并且 $p(n) = n+q(n)$ 是一个多项式，所以 $T(n) = O(2^{p(n)})$，从而将该算法归入 EXPTIME。\n\n这也证明了必要性：如果该算法属于 EXPTIME，那么存在一个多项式 $p(n)$ 使得 $2^n V(n) = O(2^{p(n)})$，这意味着对于多项式 $q(n)=p(n)-n$，有 $V(n)=O(2^{p(n)-n})=O(2^{q(n)})$。因此，如果 $V(n)$ 的增长速度快于 $2^{\\text{poly}(n)}$（例如，$V(n)=2^{2^n}$），那么 $T(n)=2^n V(n)$ 将不会被 $2^{\\text{poly}(n)}$ 所界定，该算法也就不属于 EXPTIME。\n\n逐一评估选项：\n- A 是错误的，因为 $V(n)$ 可能是超指数级的，例如 $V(n)=2^{2^n}$，这会使得 $T(n)$ 不在 $O(2^{\\text{poly}(n)})$ 范围内。\n- B 的条件过于严格；$V(n)$ 为多项式是充分条件但非必要条件。例如，$V(n)=2^n$ 会得出 $T(n)=2^{2n}$，这仍然属于 EXPTIME。\n- C 符合我们推导出的充分必要条件：对于某个多项式 $q(n)$，有 $V(n) = O(2^{q(n)})$。\n- D 是错误的；是否属于 EXPTIME 并不取决于问题是否 NP-完全，并且其中声称的等价关系是错误的。\n- E 是错误的；$2^n$ 乘以 $2^{\\text{poly}(n)}$ 的结果仍然是 $2^{\\text{poly}(n)}$ 的形式。\n\n因此，最准确和最普适的条件是选项 C。", "answer": "$$\\boxed{C}$$", "id": "1452149"}, {"introduction": "计算复杂性理论不仅在于分析单个算法，更在于理解不同问题之间的关系。这最后一个练习介绍了一个强大的概念——多项式时间归约（polynomial-time reduction），它是问题分类的基石。你将探索如何通过证明一个问题可以被高效地转化为另一个问题，来为其计算复杂性设定一个上限。[@problem_id:1452129]", "problem": "在计算复杂性理论中，问题根据解决它们所需的资源（如时间或内存）进行分类。我们来定义两个重要的时间复杂度类：\n\n1.  **P (多项式时间)**：如果存在一个算法能在输入大小 $n$ 的多项式时间内解决一个判定问题，那么该问题就属于 P 类。也就是说，其运行时间为 $O(n^k)$，其中 $k$ 是某个常数。\n2.  **EXPTIME (指数时间)**：如果存在一个算法能在输入大小 $n$ 的某个多项式的指数函数时间内解决一个判定问题，那么该问题就属于 EXPTIME 类。也就是说，其运行时间为 $O(2^{p(n)})$，其中 $p(n)$ 是某个多项式。\n\n比较问题难度的一个关键概念是多项式时间归约。如果问题 B 的一个算法可以用来解决问题 A，且仅需多项式量的额外工作，我们就说问题 $A$ 可多项式时间归约到问题 $B$，记作 $A \\leq_p B$。更正式地说，存在一个可在多项式时间内计算的函数 $f$，它将问题 $A$ 的一个输入 $x$ 转换为问题 $B$ 的一个输入 $f(x)$，使得实例 $x$ 是 $A$ 的‘是’实例当且仅当 $f(x)$ 是 $B$ 的‘是’实例。\n\n假设我们正在研究两个问题，问题 `PHOTON_PATH` 和问题 `QUANTUM_SIM`。我们已经确定 `QUANTUM_SIM` 属于 EXPTIME 复杂度类。然后，一位研究人员证明了存在一个从 `PHOTON_PATH` 到 `QUANTUM_SIM` 的多项式时间归约（即 `PHOTON_PATH` $\\leq_p$ `QUANTUM_SIM`）。\n\n仅根据这些信息，下列哪项代表了包含 `PHOTON_PATH` 问题的复杂度类的最紧**保证**上限？\n\nA. P (多项式时间)\nB. NP (非确定性多项式时间)\nC. PSPACE (多项式空间)\nD. EXPTIME (指数时间)\nE. 该问题是不可判定的。", "solution": "问题要求在已知 `PHOTON_PATH` $\\leq_p$ `QUANTUM_SIM` 且 `QUANTUM_SIM` $\\in$ EXPTIME 的条件下，找出问题 `PHOTON_PATH` 所属的复杂度类的最紧保证上限。\n\n我们来分析多项式时间归约 `PHOTON_PATH` $\\leq_p$ `QUANTUM_SIM` 的含义。这个归约意味着我们可以构建一个算法，使用 `QUANTUM_SIM` 的算法作为子程序来解决 `PHOTON_PATH` 问题。让我们针对 `PHOTON_PATH` 问题的一个任意输入 $x$ 来描述这个过程。\n\n步骤 1：归约。\n归约是一个函数 $f$，它将 `PHOTON_PATH` 的输入 $x$ 转换为 `QUANTUM_SIM` 的一个新输入，我们称之为 $y = f(x)$。根据多项式时间归约的定义，这个函数 $f$ 必须在多项式时间内是可计算的。设输入 $x$ 的大小为 $n$。计算 $y=f(x)$ 的时间为 $O(n^c)$，其中 $c$ 是某个常数。一个重要的推论是，输出 $y$ 的大小也必须是 $n$ 的多项式，因为一个运行时间为 $O(n^c)$ 的算法最多只能产生一个大小为 $O(n^c)$ 的输出。设 $y$ 的大小为 $m$。我们有 $m = |y| = |f(x)| \\le O(n^c)$，这意味着 $m$ 也是 $n$ 的一个多项式。我们可以将其写为 $m = q(n)$，其中 $q$ 是一个多项式。\n\n步骤 2：解决归约后的实例。\n我们已知 `QUANTUM_SIM` 问题属于 EXPTIME。这意味着存在一个算法，可以在 $O(2^{p(s)})$ 时间内解决 `QUANTUM_SIM` 的任何实例，其中 $s$ 是 `QUANTUM_SIM` 算法的输入大小，而 $p$ 是某个多项式。在我们的例子中，`QUANTUM_SIM` 算法的输入是 $y$，其大小为 $m$。因此，解决输入为 $y$ 的 `QUANTUM_SIM` 问题所需的时间是 $O(2^{p(m)})$。\n\n步骤 3：合并时间复杂度。\n解决一个大小为 $n$ 的 `PHOTON_PATH` 输入 $x$ 所需的总时间是归约所需时间（步骤 1）和解决 `QUANTUM_SIM` 实例所需时间（步骤 2）的总和。\n\n总时间 = (计算 $y=f(x)$ 的时间) + (在 $y$ 上解决 `QUANTUM_SIM` 的时间)\n\n我们用原始输入大小 $n$ 来表示这个时间。\n计算 $y=f(x)$ 的时间是 $O(n^c)$。\n在 $y$ 上解决 `QUANTUM_SIM` 的时间是 $O(2^{p(m)})$。由于 $m = q(n)$，其中 $q$ 是某个多项式，因此这个时间变为 $O(2^{p(q(n))})$。\n两个多项式的复合 $p(q(n))$ 本身也是一个多项式。我们称这个新多项式为 $r(n) = p(q(n))$。所以，解决 `QUANTUM_SIM` 部分的时间是 $O(2^{r(n)})$。\n\n因此，解决 `PHOTON_PATH` 的总时间是：\n$$T_{\\text{total}}(n) = O(n^c) + O(2^{r(n)})$$\n\n当我们分析渐近复杂度时，指数项 $O(2^{r(n)})$ 的增长速度远快于任何多项式项 $O(n^c)$。因此，指数项主导了总体复杂度。\n$$T_{\\text{total}}(n) = O(2^{r(n)})$$\n\n这个最终的时间复杂度 $O(2^{\\text{poly}(n)})$，根据定义，正是 EXPTIME 复杂度类。因此，我们保证 `PHOTON_PATH` 问题属于 EXPTIME。\n\n这是最紧的**保证**上限。`PHOTON_PATH` 可能是一个简单得多的问题（例如，属于 P 类），但归约只提供了一个上限。由于 `PHOTON_PATH` 有可能是 EXPTIME-完全问题（其难度与 EXPTIME 中的任何其他问题一样大），仅凭所给信息，我们无法保证它属于任何更小的类，如 P、NP 或 PSPACE。因此，包含 `PHOTON_PATH` 的最紧保证复杂度类是 EXPTIME。\n\n与给定选项比较：\nA. P：不保证。`PHOTON_PATH` 可能更难。\nB. NP：不保证。\nC. PSPACE：不保证。虽然 PSPACE 包含在 EXPTIME 中，但我们不能确定 `PHOTON_PATH` 是否在 PSPACE 中。\nD. EXPTIME：由上述推理过程保证。\nE. 该问题是不可判定的：不正确，因为我们刚刚展示了一个可以判定它的算法。\n\n因此，正确答案是 EXPTIME。", "answer": "$$\\boxed{D}$$", "id": "1452129"}]}