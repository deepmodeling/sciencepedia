{"hands_on_practices": [{"introduction": "理解非确定性图灵机（NTM）的关键在于将其计算过程想象成一棵树。这个练习将带你亲手构建计算树的最初几层，通过追踪一个具体 NTM 在给定输入上的所有可能路径，让你直观地感受非确定性选择是如何导致计算路径分叉的。这是掌握 NTM 计算模型的第一步。[@problem_id:1417864]", "problem": "考虑一个用于判定语言$L = \\{w \\in \\{0,1\\}^* \\mid w \\text{ 包含至少一个 '1'}\\}$的非确定性图灵机 (NTM)。该机器的形式化定义如下：\n*   状态集: $Q = \\{q_0, q_{\\text{move}}, q_{\\text{check}}, q_{\\text{acc}}, q_{\\text{rej}}\\}$\n*   输入字母表: $\\Sigma = \\{0, 1\\}$\n*   纸带字母表: $\\Gamma = \\{0, 1, \\sqcup\\}$，其中$\\sqcup$是空白符号。\n*   初始状态: $q_0$\n*   接受状态: $q_{\\text{acc}}$\n*   拒绝状态: $q_{\\text{rej}}$\n*   转移函数 $\\delta$:\n    1.  $\\delta(q_0, c) = \\{(q_{\\text{move}}, c, R)\\}$对于任意$c \\in \\{0, 1\\}$\n    2.  $\\delta(q_{\\text{move}}, c) = \\{(q_{\\text{move}}, c, R), (q_{\\text{check}}, c, S)\\}$对于任意$c \\in \\{0, 1\\}$\n    3.  $\\delta(q_{\\text{move}}, \\sqcup) = \\{(q_{\\text{rej}}, \\sqcup, S)\\}$\n    4.  $\\delta(q_{\\text{check}}, 1) = \\{(q_{\\text{acc}}, 1, S)\\}$\n    5.  $\\delta(q_{\\text{check}}, 0) = \\{(q_{\\text{rej}}, 0, S)\\}$\n\n机器的格局用记号$uqv$描述，它表示当前状态为$q$，纸带上包含字符串$uv$，并且读写头正在扫描$v$的第一个符号。对于输入字符串$w$，初始格局是$q_0w$。\n\n一个 NTM 的计算过程可以被看作是一棵计算树，其根节点是初始格局（第 0 层），第$k+1$层的节点是从第$k$层的格局经过一步可以到达的所有可能格局。\n\n给定输入字符串$w = 101$，该 NTM 计算树第 2 层的所有不同格局的集合是什么？\n\nA. $\\{1q_{\\text{move}}01, 1q_{\\text{check}}01\\}$\n\nB. $\\{1q_{\\text{move}}01, q_{\\text{check}}101\\}$\n\nC. $\\{10q_{\\text{move}}1, 1q_{\\text{check}}01, q_{\\text{check}}101\\}$\n\nD. $\\{10q_{\\text{move}}1, 1q_{\\text{check}}01\\}$\n\nE. $\\{10q_{\\text{move}}1, 10q_{\\text{check}}1, 1q_{\\text{check}}01\\}$", "solution": "我们使用格局记号$uqv$，其中纸带包含$uv$，读写头扫描$v$的第一个符号，当前状态为$q$。对于输入$w=101$，初始格局（第 0 层）是$q_{0}101$。\n\n从$q_{0}$状态读取$1$，应用规则 1：$\\delta(q_{0},1)=\\{(q_{\\text{move}},1,R)\\}$。将$1$写回（不变）并向右移动，得到第 1 层的格局$1q_{\\text{move}}01$。\n\n在第 2 层，我们从格局$1q_{\\text{move}}01$进行扩展。此时，读写头读取$0$，应用规则 2：$\\delta(q_{\\text{move}},0)=\\{(q_{\\text{move}},0,R),(q_{\\text{check}},0,S)\\}$。\n- 选择$(q_{\\text{move}},0,R)$：写入$0$，向右移动，状态切换到$q_{\\text{move}}$，得到格局$10q_{\\text{move}}1$。\n- 选择$(q_{\\text{check}},0,S)$：写入$0$，读写头保持不动，状态切换到$q_{\\text{check}}$，得到格局$1q_{\\text{check}}01$。\n\n在此层级没有其他转移适用（没有读取到空白符号，且从$q_{\\text{check}}$转移到接受状态需要读取$1$，而在此层级进入$q_{\\text{check}}$状态的分支中当前符号并非$1$）。因此，第 2 层的所有不同格局的集合是$\\{10q_{\\text{move}}1, 1q_{\\text{check}}01\\}$，这对应于选项 D。", "answer": "$$\\boxed{D}$$", "id": "1417864"}, {"introduction": "在了解了计算树如何分支后，一个自然的问题是：这棵树的规模有多大？此练习将帮助你从宏观上把握计算树的增长速度，通过推导树在特定深度 $k$ 处可能存在的最大配置数，来揭示非确定性计算所固有的指数级增长特性。这个概念对于理解 NP 问题的计算复杂度至关重要。[@problem_id:1417810]", "problem": "非确定性图灵机 (NTM) 可以被看作是一种并行探索多个计算路径的理论计算机。对于一个给定的输入，一个 NTM 所有可能的计算序列集合可以用一棵计算树来表示。这棵树的根是初始构型（包括机器的起始状态、带上的输入和初始磁头位置）。树中深度为$d$的一个节点代表了经过$d$个计算步骤后可达的一个构型。一个节点的子节点是根据机器的转移函数，可以从该节点一步到达的所有构型。\n\n考虑一个特定的 NTM，其转移函数规定对于任何构型，在下一步中它至多可以转移到两个可能的构型。设$k$是一个非负整数，代表计算树中的一个特定深度。\n\n确定在该 NTM 的计算树中，深度为$k$时可能存在的最大构型数量。请用关于$k$的闭式解析表达式来表示你的答案。", "solution": "设$N(k)$表示计算树中深度为$k$时的最大构型数量。转移函数允许从任何构型产生至多两个可能的下一构型，因此分支因子至多为$2$。\n\n在根部（深度$0$），恰好有一个构型，所以$N(0)=1$。从深度为$d$的任何构型出发，在深度为$d+1$处至多有$2$个子节点。因此，在最大化的情况下，即每一步中每个节点都恰好分支为两个子节点，该序列满足以下递推关系：\n$$\nN(0)=1, \\quad N(k+1)=2\\,N(k).\n$$\n通过迭代求解该递推关系，可得：\n$$\nN(k)=2^{k}.\n$$\n或者，用归纳法证明：基本情况$N(0)=1=2^{0}$成立。假设$N(k)=2^{k}$，那么$N(k+1)\\leq 2\\,N(k)=2\\cdot 2^{k}=2^{k+1}$，并且当每个节点都有两个子节点时等号成立。因此，在深度为$k$时可能存在的最大构型数量是$2^{k}$。", "answer": "$$\\boxed{2^{k}}$$", "id": "1417810"}, {"introduction": "计算树不仅是一个理论模型，它还完美地诠释了 NTM “猜测并验证” 的工作模式。在这个练习中，你将分析一个经过精心设计的 NTM，它首先非确定性地生成一个潜在解，然后确定性地验证该解是否正确。通过计算所有可能的计算路径总数，你将深入理解 NTM 如何在指数级的搜索空间中寻找一个有效解，这也是 NP 类问题的核心特征。[@problem_id:1417859]", "problem": "一个特定的非确定性图灵机（NTM），我们称之为$M$，被定义在一条单向无限纸带上运行。$M$的状态集为$\\{q_{\\text{gen}}, q_{\\text{rewind}}, q_{\\text{check\\_first}}, q_{\\text{check\\_rest}}, q_{\\text{accept}}, q_{\\text{reject}}\\}$。输入字母表是$\\{a\\}$，纸带字母表是$\\{a, 0, 1, \\sqcup\\}$，其中$\\sqcup$是空白符号。该机器从状态$q_{\\text{gen}}$开始，其读写头位于输入字符串的最左边符号上。转移定义如下：\n\n1.  **生成阶段 (Generation):** 如果处于状态$q_{\\text{gen}}$并且读到 'a'，$M$非确定性地选择以下两种移动之一：(i) 写入 '0'，右移，并保持在$q_{\\text{gen}}$状态，或 (ii) 写入 '1'，右移，并保持在$q_{\\text{gen}}$状态。\n2.  **开始验证 (Start Verification):** 在状态$q_{\\text{gen}}$读到空白符号$\\sqcup$时，$M$写入$\\sqcup$，将其读写头向左移动一个位置，并转移到状态$q_{\\text{rewind}}$。\n3.  **回卷 (Rewind):** 在状态$q_{\\text{rewind}}$中，只要读到 '0' 或 '1'，$M$便会持续将其读写头向左移动。当一个内部机制检测到读写头已移动到起始单元（单元0）的左侧时，它会自动将读写头放回第一个单元（单元1）上，并且机器转移到状态$q_{\\text{check\\_first}}$。\n4.  **检查首个符号 (Check First Symbol):** 在状态$q_{\\text{check\\_first}}$中，如果读写头读到 '1'，$M$右移并转移到$q_{\\text{check\\_rest}}$。如果读到 '0'，它立即转移到停机状态$q_{\\text{reject}}$。\n5.  **检查剩余部分 (Check Remainder):** 在状态$q_{\\text{check\\_rest}}$中，如果读写头读到 '0'，$M$右移并保持在$q_{\\text{check\\_rest}}$状态。如果读到 '1'，它立即转移到停机状态$q_{\\text{reject}}$。\n6.  **接受/拒绝 (Accept/Reject):** 如果$M$处于状态$q_{\\text{check\\_rest}}$并读到空白符号$\\sqcup$，它转移到停机状态$q_{\\text{accept}}$。状态$q_{\\text{reject}}$也是一个停机状态。任何未在上面明确定义的转移的配置都会导致机器转移到$q_{\\text{reject}}$。\n\n此 NTM 在输入字符串$w = a^n$上运行，该字符串由符号 'a' 重复$n$次组成，其中$n$是一个正整数。该 NTM 在此输入上的计算可以表示为一个计算树，其中从根到叶节点（一个停机配置）的每条路径代表一种可能的非确定性选择序列。\n\n确定 NTM $M$在输入$a^n$上的计算树中不同路径的总数公式。用一个关于$n$的闭式解析表达式来表示你的答案。", "solution": "将计算树理解为仅在机器做出非确定性选择的地方产生分支。在状态$q_{\\text{gen}}$中，对于输入$a^n$，读写头从左到右精确地扫描$n$个输入符号中的每一个，并且在每个符号处，它非确定性地在两种操作之间进行选择：写入$0$或写入$1$，然后右移并保持在$q_{\\text{gen}}$状态。根据乘法法则，在这个生成阶段，不同非确定性选择序列的总数为\n$2 \\times 2 \\times \\cdots \\times 2 = 2^{n}$。\n\n一旦读到第$n$个符号右侧的空白符$\\sqcup$，机器便确定性地执行回卷和验证阶段。给定生成的长度为$n$的二进制字符串，$q_{\\text{rewind}}$、$q_{\\text{check\\_first}}$和$q_{\\text{check\\_rest}}$中的转移是确定性的，任何未定义的情况都会直接进入停机状态$q_{\\text{reject}}$。因此，每个不同的非确定性生成选择序列都精确地决定了一条从根到叶的停机路径（停机于$q_{\\text{accept}}$或$q_{\\text{reject}}$）。因此，不同的从根到叶的计算路径总数等于长度为$n$的二进制字符串的数量，即$2^{n}$。等价地，通过计算在$n$个位置上所有可能的 1 的放置方式，\n$$\n\\sum_{k=0}^{n} \\binom{n}{k} = 2^{n}.\n$$\n因此，不同计算路径的总数为$2^{n}$。", "answer": "$$\\boxed{2^{n}}$$", "id": "1417859"}]}