{"hands_on_practices": [{"introduction": "库克-莱文定理的证明关键在于将图灵机的计算过程转化为一个逻辑公式。其中一个基础步骤是确保计算历史表（tableau）的每一个配置都是格式正确的。此练习 [@problem_id:1405676] 要求你编码一条最基本的规则：在任何给定时刻，每个磁带格必须且只能包含字母表中的一个符号。掌握这种“恰好一个”约束的编码方式是构建基于 SAT 的模型的关键技能。", "problem": "在库克-莱文定理的证明中，一个多项式时间非确定性图灵机（TM）的计算被转换成一个布尔可满足性问题。这是通过构造一个合取范式（CNF）的公式 $\\phi$ 来实现的，该公式可满足当且仅当该图灵机接受其输入。\n\n考虑此构造的一部分，针对一个带字母表为 $Γ = \\{s_0, s_1, s_B\\}$ 的图灵机，其中 $s_B$ 是空白符号。带的状态由一组布尔变量 $P_{i,j,s}$ 描述，其中 $P_{i,j,s}$ 为真当且仅当在时间步 $i$，带单元 $j$ 包含符号 $s$。\n\n需要强制执行的一个基本约束是，在任何给定的时间，每个带单元必须包含来自字母表的恰好一个符号。\n\n对于时间步 $i=5$ 和带单元 $j=2$ 的特定实例，令变量为 $A = P_{5,2,s_0}$，$B = P_{5,2,s_1}$ 和 $C = P_{5,2,s_B}$。下列哪个以CNF书写的公式正确地表达了“在时间5，带单元2持有来自集合 $\\{s_0, s_1, s_B\\}$ 的恰好一个符号”这一约束？\n\nA. $(A \\lor B \\lor C) \\land (\\lnot A \\lor \\lnot B) \\land (\\lnot A \\lor \\lnot C) \\land (\\lnot B \\lor \\lnot C)$\n\nB. $(A \\lor B \\lor C)$\n\nC. $(\\lnot A \\lor \\lnot B) \\land (\\lnot A \\lor \\lnot C) \\land (\\lnot B \\lor \\lnot C)$\n\nD. $(A \\land B \\land C)$\n\nE. $(A \\lor \\lnot B) \\land (\\lnot A \\lor C) \\land (B \\lor \\lnot C)$", "solution": "我们正在使用布尔变量对库克-莱文定理中的“在给定时间，每个带单元恰好有一个符号”这一约束进行编码。对于时间步 $i=5$ 和带单元 $j=2$，定义\n$$\nA = P_{5,2,s_{0}}, \\quad B = P_{5,2,s_{1}}, \\quad C = P_{5,2,s_{B}}.\n$$\n该单元包含来自 $\\{s_{0},s_{1},s_{B}\\}$ 的恰好一个符号的要求意味着：\n1) $A,B,C$ 中至少有一个为真。\n2) $A,B,C$ 中至多有一个为真。\n\n“至少一个”部分是单个子句\n$$\nA \\lor B \\lor C.\n$$\n“至多一个”部分禁止任何一对变量同时为真，等价于\n$$\n\\lnot(A \\land B), \\quad \\lnot(A \\land C), \\quad \\lnot(B \\land C),\n$$\n其CNF形式为\n$$\n(\\lnot A \\lor \\lnot B) \\land (\\lnot A \\lor \\lnot C) \\land (\\lnot B \\lor \\lnot C).\n$$\n将两者结合起来得到CNF\n$$\n(A \\lor B \\lor C) \\land (\\lnot A \\lor \\lnot B) \\land (\\lnot A \\lor \\lnot C) \\land (\\lnot B \\lor \\lnot C),\n$$\n这对应于选项A。\n\n为了确认其他选项不正确：\n- B只包含了“至少一个”部分，并允许多个符号同时存在。\n- C只包含了“至多一个”部分，并允许三个变量都为假。\n- D强制三个变量都为真，这违反了排他性。\n- E不等价于“恰好一个”；例如，当 $A=\\text{false}$，$B=\\text{false}$，$C=\\text{false}$ 时，E中的每个子句求值为\n$$\nA \\lor \\lnot B = \\text{false} \\lor \\text{true} = \\text{true}, \\quad \\lnot A \\lor C = \\text{true} \\lor \\text{false} = \\text{true}, \\quad B \\lor \\lnot C = \\text{false} \\lor \\text{true} = \\text{true},\n$$\n因此，即使 $A,B,C$ 都不为真，E也被满足，这违反了“至少一个”的要求。\n\n因此，正确的CNF是选项A。", "answer": "$$\\boxed{A}$$", "id": "1405676"}, {"introduction": "在为任意计算配置建立通用规则之后，我们现在需要关注计算的特定起点。该定理要求我们创建一个公式 $\\phi_{start}$，用以固定机器在时间 $t=0$ 时的初始状态。本练习 [@problem_id:1456001] 聚焦于此初始设置的一个关键部分：指定机器的读写头必须从第一个磁带格开始，并且不能在其他任何位置。这为你提供了在更具体的上下文中练习编码精确定位约束的机会。", "problem": "在库克-列文定理的证明中，我们使用一台给定的非确定性图灵机（NTM）和一个长度为 $n$ 的输入字符串 $w$ 来构造一个布尔公式 $\\phi$。这个公式是可满足的，当且仅当该 NTM 接受输入 $w$。$\\phi$ 的构造依赖于将机器的整个计算历史描述为一个计算历史表（tableau）。我们假设计算在一定的时间步数内运行，该步数以 $n$ 的一个多项式为界，我们将其表示为 $N$。计算也被限制在纸带的一个有限部分上，其单元格的索引从 $i=0$ 到 $i=N-1$。\n\n为了形式化这个计算历史表，我们使用一组命题变量。我们定义变量 $H(i, t)$ 是一个布尔变量，它为真当且仅当在时间步 $t$，图灵机的读写头位于纸带位置 $i$ 处，其中 $0 \\le i  N$ 且 $0 \\le t  N$。\n\n整个公式 $\\phi$ 的一部分是一个子公式，通常称为 $\\phi_{start}$，它断言在时间 $t=0$ 时，机器处于其正确的初始配置。这个初始配置的一个关键部分是读写头的位置。按照惯例，NTM 开始计算时，其读写头位于纸带的第一个单元格上，即对应于位置 $i=0$。\n\n以下哪个逻辑公式正确且完整地指定了在初始时间步 $t=0$ 时读写头位置所需的条件？\n\nA. $H(0, 0)$\n\nB. $\\bigvee_{i=0}^{N-1} H(i, 0)$\n\nC. $H(0, 0) \\land \\left( \\bigwedge_{i=1}^{N-1} \\lnot H(i, 0) \\right)$\n\nD. $H(0, 0) \\rightarrow \\left( \\bigwedge_{i=1}^{N-1} \\lnot H(i, 0) \\right)$\n\nE. $\\left( \\bigvee_{i=0}^{N-1} H(i, 0) \\right) \\land \\left( \\bigwedge_{0 \\le i  j  N} (\\lnot H(i, 0) \\lor \\lnot H(j, 0)) \\right)$", "solution": "我们需要形式化初始读写头的位置：在时间 $t=0$ 时，读写头必须恰好位于单元格 $i=0$ 处，而不能在任何其他单元格。使用变量 $H(i,t)$，这个要求可以表示为 $H(0,0)$ 为真，并且对于所有满足 $1 \\le i \\le N-1$ 的 $i$，$H(i,0)$ 都为假的合取范式：\n$$\nH(0,0) \\land \\left( \\bigwedge_{i=1}^{N-1} \\lnot H(i,0) \\right).\n$$\n现在我们根据这个要求来评估每个选项。\n\n- 选项 A：$H(0,0)$。这强制要求读写头位于 $i=0$，但并未排除对于某个 $j \\neq 0$，$H(j,0)$ 也为真的情况。因此，它没有完整地规定在 $t=0$ 时的位置唯一性。\n\n- 选项 B：$\\bigvee_{i=0}^{N-1} H(i,0)$。这只断言在 $t=0$ 时读写头在某个位置，但不一定在 $i=0$；因此不正确。\n\n- 选项 C：$H(0,0) \\land \\left( \\bigwedge_{i=1}^{N-1} \\lnot H(i,0) \\right)$。这断言在 $t=0$ 时，读写头位于 $i=0$ 且不在其他任何地方；这与所需条件完全匹配。\n\n- 选项 D：$H(0,0) \\rightarrow \\left( \\bigwedge_{i=1}^{N-1} \\lnot H(i,0) \\right)$。这允许 $H(0,0)$ 为假而某个其他的 $H(j,0)$ 为真，因此它没有强制读写头必须在 $i=0$；条件不充分。\n\n- 选项 E：$\\left( \\bigvee_{i=0}^{N-1} H(i,0) \\right) \\land \\left( \\bigwedge_{0 \\le i  j  N} (\\lnot H(i,0) \\lor \\lnot H(j,0)) \\right)$。这强制在 $t=0$ 时读写头的位置是唯一的，但没有强制该位置必须是 $i=0$；条件不充分。\n\n因此，关于初始读写头位置的正确且完整的规范由选项 C 给出。", "answer": "$$\\boxed{C}$$", "id": "1456001"}, {"introduction": "模拟计算过程的精髓在于捕捉其动态——即机器的配置如何根据规则从一步合法地演变到下一步。这部分由机器的转移函数决定，是编码中最复杂的部分，构成了公式 $\\phi_{move}$。最后的这个练习 [@problem_id:1405705] 将挑战你将单条转移规则转化为一个逻辑蕴含式，从而将机器在时间 $t$ 的配置与其在时间 $t+1$ 的配置联系起来。这揭示了一组简单的局部规则如何能够共同确保整个计算序列的有效性。", "problem": "在 Cook-Levin 定理的背景下，一个图灵机的计算过程被编码为一个庞大的布尔可满足性 (SAT) 实例。这种编码的一个关键部分是创建逻辑子句来强制执行机器的转移规则。\n\n考虑一个确定性图灵机，它有一个状态集 $Q$、一个带字母表 $\\Gamma$ 和一个转移函数 $\\delta$。我们使用以下布尔变量来描述机器在任意时间步的格局：\n-   $S_{t,q}$：当且仅当机器在时间步 $t$ 处于状态 $q \\in Q$ 时为真。\n-   $H_{t,j}$：当且仅当机器的读写头在时间步 $t$ 位于带位置 $j$ 时为真。\n-   $T_{t,j,s}$：当且仅当在时间步 $t$，带单元 $j$ 包含符号 $s \\in \\Gamma$ 时为真。\n\n假设该机器有一条特定的转移规则如下：\n$$ \\delta(q_1, a) = (q_2, b, R) $$\n该规则意味着，如果机器处于状态 $q_1$ 并且从带上读取符号 $a$，它将转移到状态 $q_2$，在当前带单元中写入符号 $b$，并将读写头向右 (R) 移动一个位置。\n\n下列哪个逻辑公式能正确确保对于任意时间步 $t$ 和任意带位置 $j$，机器在时间 $t+1$ 的格局是其在时间 $t$ 的格局根据此特定规则得出的有效推论？\n\nA. $(S_{t, q_1} \\land H_{t, j} \\land T_{t, j, a}) \\rightarrow (S_{t+1, q_2} \\land H_{t+1, j+1} \\land T_{t+1, j, b})$\n\nB. $(S_{t, q_1} \\land H_{t, j} \\land T_{t, j, a}) \\land (S_{t+1, q_2} \\land H_{t+1, j+1} \\land T_{t+1, j, b})$\n\nC. $(S_{t+1, q_2} \\land H_{t+1, j+1} \\land T_{t+1, j, b}) \\rightarrow (S_{t, q_1} \\land H_{t, j} \\land T_{t, j, a})$\n\nD. $(S_{t, q_1} \\land H_{t, j} \\land T_{t, j, a}) \\rightarrow (S_{t+1, q_2} \\land H_{t+1, j} \\land T_{t+1, j+1, b})$\n\nE. $(S_{t, q_1} \\lor H_{t, j} \\lor T_{t, j, a}) \\rightarrow (S_{t+1, q_2} \\lor H_{t+1, j+1} \\lor T_{t+1, j, b})$", "solution": "我们给定了一个确定性图灵机，其转移函数为 $\\delta$，并使用布尔变量 $S_{t,q}$、$H_{t,j}$ 和 $T_{t,j,s}$ 分别描述机器在时间 $t$ 的状态、读写头位置和带符号。特定的转移规则是 $\\delta(q_{1}, a) = (q_{2}, b, R)$，这意味着：如果在时间 $t$，机器处于状态 $q_{1}$，其读写头位于单元 $j$ 上，且读写头下的符号是 $a$，那么在时间 $t+1$，机器必须处于状态 $q_{2}$，读写头必须位于位置 $j+1$，并且单元 $j$ 中写入的符号必须是 $b$。\n\n根据变量的语义：\n- $S_{t,q_{1}}$ 表示在时间 $t$ 的状态是 $q_{1}$。\n- $H_{t,j}$ 表示在时间 $t$ 读写头位于位置 $j$。\n- $T_{t,j,a}$ 表示在时间 $t$ 带单元 $j$ 的符号是 $a$。\n- 在时间 $t+1$，规则要求 $S_{t+1,q_{2}}$、$H_{t+1,j+1}$ 和 $T_{t+1,j,b}$ 成立。\n\n因此，要强制执行“如果在时间 $t$ 发生左侧的格局，那么在时间 $t+1$ 必须产生右侧的推论”这一转移，正确的逻辑约束是以下蕴含式：\n$$\n\\left(S_{t,q_{1}} \\land H_{t,j} \\land T_{t,j,a}\\right) \\rightarrow \\left(S_{t+1,q_{2}} \\land H_{t+1,j+1} \\land T_{t+1,j,b}\\right),\n$$\n该式需要对所有的 $t$ 和 $j$ 进行实例化。\n\n现在我们来评估各个选项：\n- A 正是上面的蕴含式，所以它正确地强制执行了该转移。\n- B 是前件和后件的合取，这会强制机器在包含该子句时始终处于前件的格局中；它没有表达条件转移，约束过强。\n- C 颠倒了蕴含的方向；它会强制要求 $t+1$ 的格局蕴含着特定的 $t$ 的格局，这不是预期的转移约束。\n- D 错误地放置了读写头和写入位置：它将读写头保持在 $j$ 处，并在 $j+1$ 处写入 $b$，这与 $\\delta(q_{1}, a) = (q_{2}, b, R)$ 相矛盾。\n- E 使用了析取，这没有捕捉到必要的条件结构；它允许前件或后件部分为真，无法正确地强制执行转移。\n\n因此，正确选项是 A。", "answer": "$$\\boxed{A}$$", "id": "1405705"}]}