{"hands_on_practices": [{"introduction": "在面对像 0-1 背包问题这样的优化选择问题时，一个很自然的第一反应是采用“贪心”策略。这个练习旨在揭示最直观的贪心方法（例如，总是优先选择价值最高的物品）为何不适用于 0-1 背包问题。通过构建一个具体的反例，您将更深刻地理解该问题的组合复杂性，并认识到为何需要更精密的算法来求解。[@problem_id:1449258]", "problem": "一位数据科学家的任务是，在一台可用随机存取存储器 (RAM) 容量有限的服务器上，选择一批计算任务来运行。该服务器有 10 GB 的可用 RAM 容量。现有三个待处理的任务，每个任务都有特定的 RAM 需求和一个代表其重要性的关联优先级值。目标是选择这些任务的一个子集来同时运行，使得它们的总 RAM 需求不超过服务器的容量，并且所选任务的优先级值之和最大化。\n\n这三个任务是：\n- 任务1：优先级值 = 10, RAM 需求 = 10 GB\n- 任务2：优先级值 = 6, RAM 需求 = 5 GB\n- 任务3：优先级值 = 6, RAM 需求 = 5 GB\n\n考虑一个简单的任务选择贪心策略：总是优先选择可用任务中优先级值最高的那个，并持续此过程，直到无法在不超出 RAM 容量的情况下添加更多任务为止。\n\n设 $V_{greedy}$ 为应用这种“最高优先级优先”的贪心策略所获得的总优先级值。\n设 $V_{optimal}$ 为通过任何有效的任务组合可以实现的最大总优先级值。\n\n以下哪个选项代表了正确的有序对 $(V_{greedy}, V_{optimal})$？\n\nA. (10, 10)\n\nB. (10, 12)\n\nC. (12, 10)\n\nD. (12, 12)\n\nE. (6, 12)", "solution": "我们将此选择问题建模为一个 $0$-$1$ 背包问题。设容量为 $C=10$，任务为具有价值和重量的物品，分别为 $(v_{1},w_{1})=(10,10)$、$(v_{2},w_{2})=(6,5)$、$(v_{3},w_{3})=(6,5)$。目标是选择一个子集 $S$ 以最大化\n$$\n\\sum_{i \\in S} v_{i}\n$$\n约束条件为\n$$\n\\sum_{i \\in S} w_{i} \\leq C.\n$$\n\n贪心策略（最高优先级值优先）：按 $v_{i}$ 的非递增顺序对物品进行排序。顺序为任务1，然后是任务2和任务3（任务2和3并列）。从容量 $C=10$ 开始。\n- 考虑物品 $1$：$w_{1}=10 \\leq C=10$，因此将其包含。剩余容量变为 $C \\leftarrow C - w_{1} = 10 - 10 = 0$。\n- 考虑物品 $2$ 和 $3$：$w_{2}=w_{3}=5 > 0$，因此两者都无法放入剩余容量中。\n因此，贪心策略选择的集合是 $S_{\\text{greedy}}=\\{1\\}$，其总价值为\n$$\nV_{\\text{greedy}}=\\sum_{i \\in S_{\\text{greedy}}} v_{i}=10.\n$$\n\n最优解：枚举所有可行的子集及其总价值和总重量。\n- $S=\\varnothing$: 总重量 $0 \\leq 10$，总价值 $0$。\n- $S=\\{1\\}$: 总重量 $10 \\leq 10$，总价值 $10$。\n- $S=\\{2\\}$: 总重量 $5 \\leq 10$，总价值 $6$。\n- $S=\\{3\\}$: 总重量 $5 \\leq 10$，总价值 $6$。\n- $S=\\{2,3\\}$: 总重量 $5+5=10 \\leq 10$，总价值 $6+6=12$。\n- $S=\\{1,2\\}$: 总重量 $10+5=15 > 10$ (不可行)。\n- $S=\\{1,3\\}$: 总重量 $10+5=15 > 10$ (不可行)。\n- $S=\\{1,2,3\\}$: 总重量 $10+5+5=20 > 10$ (不可行)。\n最大可行总价值为\n$$\nV_{\\text{optimal}}=12,\n$$\n由 $S=\\{2,3\\}$ 达到。\n\n因此，有序对为 $(V_{\\text{greedy}},V_{\\text{optimal}})=(10,12)$，这对应于选项 B。", "answer": "$$\\boxed{B}$$", "id": "1449258"}, {"introduction": "既然我们已经看到简单的贪心策略是不足的，现在我们转向一种能保证找到最优解的强大技术：动态规划。本练习将引导您探索解决 0-1 背包问题的经典动态规划方法，并特别关注一种内存高效的实现方式。通过追踪动态规划表（在本例中是一个一维数组）的状态变化，您将建立一个坚实的心智模型，理解算法如何从子问题的解系统性地构建出全局最优解，这是算法设计中的一个核心思想。[@problem_id:1449277]", "problem": "一位工程师正在为一款内存极度有限的微控制器开发资源分配算法。该算法必须解决“背包问题”的一个变种。给定一组任务，每个任务都有特定的内存“重量”和代表其优先级的“价值”，目标是选择一个任务子集，在不超过微控制器总内存容量的前提下，最大化总优先级价值。\n\n为节省内存，该工程师的算法仅使用一个一维数组，我们称之为 `V_max`，其大小为 `W+1`，其中 `W` 是总内存容量。该数组首先被初始化，所有元素都设置为零。然后，算法逐个处理每个任务。对于一个给定的权重为 `w_i`、价值为 `v_i` 的任务 `i`，该算法根据以下规则更新 `V_max` 数组：对于从 `W` 向下到 `w_i`（含 `w_i`）的每个整数容量 `j`，元素 `V_max[j]` 被更新为其当前值与 `V_max[j - w_i] + v_i` 两者中的较大值。\n\n假设总内存容量为 `W = 7`。可用任务如下表所示：\n\n| 任务ID | 重量 `w` | 价值 `v` |\n|:---:|:---:|:---:|\n| 1 | 3 | 5 |\n| 2 | 5 | 9 |\n| 3 | 2 | 3 |\n\n该算法将首先处理任务1，然后处理任务2，最后处理任务3。你的目标是确定该算法在处理完**前两个任务**（任务1和任务2）之后，`V_max` 数组的状态。数组 `V_max` 的索引范围是从 0 到 7。\n\n以行矩阵的形式给出你的答案，其中包含元素 `V_max[0]` 到 `V_max[7]` 的整数值。", "solution": "我们使用一个数组 $V_{\\max}[0..W]$ 来解决一个 0-1 背包问题，其中 $W=7$。对于每个权重为 $w_{i}$、价值为 $v_{i}$ 的任务，其更新规则是\n$$\nV_{\\max}[j] \\leftarrow \\max\\!\\big(V_{\\max}[j],\\, V_{\\max}[j-w_{i}] + v_{i}\\big)\\quad\\text{for } j=W,W-1,\\ldots,w_{i}.\n$$\n初始化：\n$$\nV_{\\max}[j]=0\\quad\\text{for } j=0,1,\\ldots,7,\n$$\n我们可以将其写为\n$$\n\\begin{pmatrix}\n0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\n\\end{pmatrix}.\n$$\n\n处理任务1，其 $w_{1}=3$，$v_{1}=5$：\n对于 $j=7,6,5,4,3$，\n$$\nV_{\\max}[j]=\\max\\!\\big(V_{\\max}[j],\\, V_{\\max}[j-3]+5\\big).\n$$\n由于对于所有这些 $j$，$V_{\\max}[j-3]$ 的初始值都为 0，因此每次更新都会得到\n$$\nV_{\\max}[j]=\\max(0,0+5)=5.\n$$\n索引 $j=0,1,2$ 的值保持为零。处理完任务1后：\n$$\n\\begin{pmatrix}\n0 & 0 & 0 & 5 & 5 & 5 & 5 & 5\n\\end{pmatrix}.\n$$\n\n处理任务2，其 $w_{2}=5$，$v_{2}=9$：\n对于 $j=7,6,5$，\n$$\nV_{\\max}[j]=\\max\\!\\big(V_{\\max}[j],\\, V_{\\max}[j-5]+9\\big).\n$$\n逐个计算：\n- 对于 $j=7$：$V_{\\max}[7]=\\max(5, V_{\\max}[2]+9)=\\max(5, 0+9)=9$。\n- 对于 $j=6$：$V_{\\max}[6]=\\max(5, V_{\\max}[1]+9)=\\max(5, 0+9)=9$。\n- 对于 $j=5$：$V_{\\max}[5]=\\max(5, V_{\\max}[0]+9)=\\max(5, 0+9)=9$。\n在这一轮中，索引 $j=0,1,2,3,4$ 处的元素不受影响，因此它们分别保持为 $0,0,0,5,5$。因此，在处理完前两个任务后，数组为\n$$\n\\begin{pmatrix}\n0 & 0 & 0 & 5 & 5 & 9 & 9 & 9\n\\end{pmatrix}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}0 & 0 & 0 & 5 & 5 & 9 & 9 & 9\\end{pmatrix}}$$", "id": "1449277"}, {"introduction": "动态规划虽然能提供精确解，但其运行时间依赖于背包的容量 $W$，这在 $W$ 非常大时可能不切实际。在这种情况下，我们常常寻求近似算法——它们运行速度快，并能提供一个虽不一定最优但有质量保证的解。这个问题将指导您分析一种巧妙的 0-1 背包问题近似算法，该算法结合了基于“密度”（即价值与重量之比 $v_i/w_i$）的贪心策略和另一个简单的备选方案。通过这个练习，您将学习到“近似比”这一关键概念，它是评估 NP-难问题算法性能的重要指标，并亲身体验如何证明这种性能保证。[@problem_id:1412169]", "problem": "一家名为 “NimbusScale” 的云计算初创公司需要优化其任务调度以最大化收入。该公司在一台总可用内存为 $W$ 的服务器上运行客户提交的任务。每个任务 $i$ 需要一定的内存量 $w_i$，并产生特定的收入 $v_i$。该公司只能运行总内存需求不超过 $W$ 的任务子集。\n\n一位工程师提出了一个名为 `GreedyByDensity` 的简单贪心算法。该算法首先将所有可用任务按其收入-内存比 $v_i/w_i$ 进行降序排序。然后，它遍历排序后的列表，当且仅当一个任务能放入剩余的可用内存时，才将其添加到调度中。\n\n工程师意识到这种简单方法可能不是最优的，于是设计了一种名为 `BestOfTwo` 的改进算法。该算法计算两种可能的调度方案，并选择总收入更高的那一种：\n1. 由 `GreedyByDensity` 算法产生的调度方案，其总收入为 $R_G$。\n2. 仅包含能放入内存限制 $W$ 内的单个最赚钱任务的调度方案，其收入为 $R_{max}$。\n因此，`BestOfTwo` 算法的最终收入为 $R_{ALG} = \\max(R_G, R_{max})$。\n\n为向投资者提供性能保证，NimbusScale 需要确定 `BestOfTwo` 算法的最坏情况性能。该性能由近似比 $C$ 衡量，定义为在所有可能的任务集和内存容量下，分数 $\\frac{R_{OPT}}{R_{ALG}}$ 的最大可能值。在此，$R_{OPT}$ 是理论上最优调度方案的收入，$R_{ALG}$ 是 `BestOfTwo` 算法的收入。\n\n确定 `BestOfTwo` 算法的近似比 $C$ 的值。", "solution": "我们面临的是一个0-1背包问题，其容量为 $W$，物品重量为 $w_{i}$，价值为 $v_{i}$。`BestOfTwo` 算法计算 $R_{ALG}=\\max\\{R_{G},R_{\\max}\\}$，其中 $R_{G}$ 是 `GreedyByDensity` 算法产生的价值（按 $v_{i}/w_{i}$ 的非增顺序处理物品，如果物品能放入则添加），$R_{\\max}$ 是能放入的单个最佳物品的价值。\n\n首先，我们观察到，可以不失一般性地丢弃任何 $w_{i}>W$ 的物品，因为这样的物品永远不可能是任何可行0-1解的一部分；这不会改变 $R_{OPT}$、$R_{G}$、$R_{\\max}$ 或 $R_{ALG}$ 的值。\n\n对物品进行排序，使得 $\\frac{v_{1}}{w_{1}}\\geq \\frac{v_{2}}{w_{2}}\\geq \\cdots$。设 $S$ 为此顺序下的一个最大前缀，其中的物品可以被完全添加，直到遇到第一个无法放入的物品。记 $V_{S}=\\sum_{i\\in S}v_{i}$。设 $j$ 是（按此顺序）第一个无法放入的物品。\n\n考虑分数背包问题的最优解 $R_F$，它是整数最优解 $R_{OPT}$ 的一个上界 ($R_{OPT} \\le R_F$)。分数背包的最优解是通过按密度顺序填充物品得到的，其价值 $R_F  V_S + v_j$。因此，$R_{OPT}  V_S + v_j$。\n我们知道，`GreedyByDensity` 算法的收入 $R_G$ 至少为 $V_S$（因为它至少包含了前缀 $S$），并且单个最佳物品的收入 $R_{\\max}$ 至少为 $v_j$（因为 $R_{\\max}$ 是所有单个物品中的最大价值）。所以：\n$$R_{OPT}  V_S + v_j \\le R_G + R_{\\max}$$\n`BestOfTwo` 算法的收入为 $R_{ALG} = \\max(R_G, R_{\\max})$。利用不等式 $a+b \\le 2\\max(a, b)$，我们得到：\n$$R_{OPT}  R_G + R_{\\max} \\le 2\\max(R_G, R_{\\max}) = 2R_{ALG}$$\n由此可得 $\\frac{R_{OPT}}{R_{ALG}}  2$，所以近似比 $C \\le 2$。\n\n接下来需要证明该界是紧的，也即最坏情况下的比率可以趋近于 $2$。固定参数 $V0$ 和 $0\\varepsilon\\frac{1}{2}$。设 $W=1$。构造如下物品：\n- 一个大任务 $B$，其 $w_{B}=1-\\varepsilon$ 且 $v_{B}=V$（密度为 $d_{B}=\\frac{V}{1-\\varepsilon}$）。\n- 一组小任务，其总重量为 $\\varepsilon+\\eta$（对于某个 $0\\eta\\ll \\varepsilon$），总价值为 $\\frac{V}{\\varepsilon}(\\varepsilon+\\eta)$（密度为 $d_{T}=\\frac{V}{\\varepsilon}$）。精细地选择这些小任务，使得每个小任务的个体价值都小于 $V$（例如，通过取足够小的单个重量，使每个任务的价值都严格低于 $V$）。\n\n由于 $d_{T}=\\frac{V}{\\varepsilon}\\frac{V}{1-\\varepsilon}=d_{B}$（因为 $\\varepsilon\\frac{1}{2}$），`GreedyByDensity`算法会首先选择所有小任务。之后，剩余容量为 $1-(\\varepsilon+\\eta)1-\\varepsilon=w_{B}$，所以任务 $B$ 无法放入，被跳过。因此，贪心算法的收入为\n$$\nR_{G}=\\frac{V}{\\varepsilon}(\\varepsilon+\\eta)=V\\Bigl(1+\\frac{\\eta}{\\varepsilon}\\Bigr).\n$$\n单个最佳任务的价值为 $R_{\\max}=V$（根据构造，大任务 $B$ 的价值优于任何单个小任务），因此\n$$\nR_{ALG}=\\max\\left\\{V\\Bigl(1+\\frac{\\eta}{\\varepsilon}\\Bigr),\\,V\\right\\}=V\\Bigl(1+\\frac{\\eta}{\\varepsilon}\\Bigr).\n$$\n一个最优解会装入任务 $B$ 以及总重量恰好为 $\\varepsilon$ 的一些小任务（由于任务的细粒度，这是可行的），产生的价值为\n$$\nR_{OPT}=V+\\frac{V}{\\varepsilon}\\cdot \\varepsilon=2V.\n$$\n因此，\n$$\n\\frac{R_{OPT}}{R_{ALG}}=\\frac{2V}{V\\left(1+\\frac{\\eta}{\\varepsilon}\\right)}=\\frac{2}{1+\\frac{\\eta}{\\varepsilon}}.\n$$\n令 $\\frac{\\eta}{\\varepsilon}\\to 0$ 可知，该比率趋近于 $2$，这证明了 $C\\geq 2$。结合 $C\\leq 2$，我们得到 $C=2$。", "answer": "$$\\boxed{2}$$", "id": "1412169"}]}