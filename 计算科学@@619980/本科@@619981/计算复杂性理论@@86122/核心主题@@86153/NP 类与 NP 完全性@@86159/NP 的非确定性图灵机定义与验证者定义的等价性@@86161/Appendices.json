{"hands_on_practices": [{"introduction": "理解 NP 的两种定义等价性的最好方法之一就是亲手进行转换。这个练习将指导我们完成从“验证者”定义到“不确定性图灵机”（NTM）定义的核心构造。通过思考验证者需要两个独立证书的假想情景 [@problem_id:1422203]，我们将具体实践 NTM 如何通过其“猜测”阶段来生成解决方案的候选者，然后通过“验证”阶段来检查其有效性。", "problem": "在计算复杂性理论中，类 NP 可以用两种等价的方式定义：一是由多项式时间非确定性图灵机（NTM）判定的语言集合，二是有多项式时间验证者的语言集合。\n\n考虑字母表 $\\{0,1\\}$ 上的一个语言 $L$。一个确定性图灵机 $V$ 作为 $L$ 的验证者。对于一个输入字符串 $x$，验证者 $V$ 接收两个额外的字符串 $c_1$ 和 $c_2$，称为证书。语言 $L$ 被定义为所有满足存在证书 $c_1$ 和 $c_2$ 使得 $V(x, c_1, c_2)$ 接受的字符串 $x$ 的集合。\n\n我们已知以下性质：\n1.  验证者 $V$ 总是在输入字符串 $x$ 长度的多项式时间内停机。设这个运行时间由 $T(|x|)$ 界定，其中 $T$ 是一个多项式。\n2.  对于任何 $x \\in L$，存在证书 $c_1$ 和 $c_2$ 使得 $V(x, c_1, c_2)$ 接受，并且这些证书的长度由 $x$ 长度的多项式界定。具体来说， $|c_1| \\le p(|x|)$ 和 $|c_2| \\le q(|x|)$，其中 $p$ 和 $q$ 是多项式。\n\n基于 NP 的验证者定义和 NTM 定义之间的等价性，可以构造一个 NTM（我们称之为 $N$）来判定语言 $L$。以下哪个选项正确描述了 NTM $N$ 在给定输入 $x$ 上判定 $L$ 的高层算法？\n\nA. NTM $N$ 在其工作带上非确定性地写入一个长度最多为 $p(|x|)$ 的字符串，一个特殊的分隔符，然后是另一个长度最多为 $q(|x|)$ 的字符串。然后它使用输入 $x$ 和这两个猜测的字符串作为 $c_1$ 和 $c_2$ 来确定性地模拟验证者 $V$。当且仅当对 $V$ 的模拟接受时，$N$ 接受。\n\nB. NTM $N$ 在其工作带上非确定性地写入一个长度最多为 $p(|x|) + q(|x|)$ 的单一字符串 $c$。然后它将 $c$ 精确地分成两半得到两个字符串，并用它们作为 $c_1$ 和 $c_2$ 来运行对 $V(x, c_1, c_2)$ 的模拟。当且仅当这次模拟接受时，$N$ 接受。\n\nC. NTM $N$ 产生两个独立的非确定性计算。一条路径猜测一个长度最多为 $p(|x|)$ 的证书 $c_1$ 并模拟 $V(x, c_1, \\epsilon)$，其中 $\\epsilon$ 是空字符串。另一条路径猜测一个长度最多为 $q(|x|)$ 的证书 $c_2$ 并模拟 $V(x, \\epsilon, c_2)$。如果这些计算中至少有一个接受，$N$ 就接受。\n\nD. NTM $N$ 确定性地搜索所有可能的证书对 $(c_1, c_2)$，其中 $|c_1| \\le p(|x|)$ 且 $|c_2| \\le q(|x|)$。对每一对，它都模拟 $V(x, c_1, c_2)$。如果在多项式时间限制内有任何模拟接受，$N$ 就接受。\n\nE. NTM $N$ 非确定性地猜测一个长度最多为 $p(|x|)$ 的单一证书 $c_1$，并模拟验证者为 $V(x, c_1, c_1)$，即对两个所需的证书使用相同的字符串。当且仅当这次模拟接受时，$N$ 接受。", "solution": "该问题要求构造一个非确定性图灵机（NTM）$N$，用以判定一个由验证者 $V$ 定义的语言 $L$。该验证者 $V$ 接收两个独立的证书 $c_1$ 和 $c_2$。\n\n语言 $L$ 的定义是：\n$$L = \\{x \\in \\{0,1\\}^* \\mid \\exists c_1, c_2 \\text{ such that } |c_1| \\le p(|x|), |c_2| \\le q(|x|), \\text{ and } V(x, c_1, c_2) \\text{ accepts}\\}$$\n在这里，$V$ 是一个确定性的多项式时间验证者，而 $p, q$ 是界定证书长度的多项式。\n\n一个 NTM 判定一个语言 $L$ 的条件是：对于任何输入 $x \\in L$，至少存在一条接受的计算路径；而对于任何 $x \\notin L$，所有计算路径都拒绝。NTM 的运行时间必须是 $|x|$ 的多项式。\n\n证明 NP 的验证者定义和 NTM 定义等价性的标准构造方法，是利用 NTM 的非确定性能力来“猜测”证书，然后利用其确定性能力在猜测的证书上运行验证者。我们将此构造方法应用于两个证书的情况。\n\nNTM $N$ 在处理输入 $x$ 时将分两个阶段工作：\n\n**阶段1：猜测阶段（非确定性）**\n这个阶段的核心任务是生成所需的见证（witness），在本问题中即为证书对 $(c_1, c_2)$。由于 NTM 通常以非确定性的方式在其工作带上写入单个字符串，因此 NTM 必须猜测一个能够同时编码 $c_1$ 和 $c_2$ 的单一字符串。一种稳健且通用的方法是将它们用一个不在证书字母表中的特殊分隔符连接起来（或使用其他明确的编码方式）。\n\nNTM 将：\n1.  非确定性地写入一串旨在作为 $c_1$ 的比特序列。机器在每一步都做一个非确定性选择：是写入一个 0、一个 1，还是停止写入 $c_1$。此过程被限制，以生成一个长度最多为 $p(|x|)$ 的字符串。\n2.  在带上写入一个特殊的分隔符 '#'。\n3.  非确定性地写入第二串旨在作为 $c_2$ 的比特序列。此过程被限制，以生成一个长度最多为 $q(|x|)$ 的字符串。\n\n写在带上的字符串总长度最多为 $p(|x|) + 1 + q(|x|)$，这是 $|x|$ 的多项式。这个猜测阶段需要多项式时间。\n\n**阶段2：验证阶段（确定性）**\n猜测阶段之后，NTM 在该计算路径的剩余部分转为完全确定性模式。\n1.  NTM 扫描它刚刚在其工作带上写入的字符串。它使用 '#' 分隔符将字符串解析为两部分，从而识别出 $c_1$ 和 $c_2$。\n2.  然后它模拟确定性验证者机器 $V$。模拟在输入 $(x, c_1, c_2)$ 上执行，其中 $x$是 NTM 的原始输入，而 $c_1, c_2$是刚刚猜测并解析出的字符串。\n3.  如果对 $V$ 的模拟接受，NTM $N$ 进入一个接受状态。如果对 $V$ 的模拟拒绝，NTM $N$ 进入一个拒绝状态。\n\n**正确性和时间复杂度分析：**\n-   **如果 $x \\in L$：** 根据定义，存在至少一对证书 $(c_1^*, c_2^*)$ 使得 $V$ 接受。NTM 的非确定性性质确保了存在一条计算路径，在该路径上它恰好猜测出 $c_1 = c_1^*$ 和 $c_2 = c_2^*$。在这条路径上，确定性验证阶段将模拟 $V(x, c_1^*, c_2^*)$，该模拟将接受。因此，NTM $N$ 将接受。\n-   **如果 $x \\notin L$：** 根据定义，对于在允许长度范围内的所有可能的证书对 $(c_1, c_2)$，$V(x, c_1, c_2)$ 都会拒绝。这意味着无论 NTM 在阶段1中猜测什么字符串，阶段2中对 $V$ 的后续模拟都将拒绝。因此，$N$ 的所有计算路径都将拒绝，NTM $N$ 正确地拒绝。\n-   **时间复杂度：** 猜测阶段需要 $O(p(|x|) + q(|x|))$ 时间。对 $V$ 的模拟运行时间是其总输入大小的多项式，即 $|x|+|c_1|+|c_2|$。由于 $|c_1|$ 和 $|c_2|$ 由 $|x|$ 的多项式界定，因此模拟时间也是 $|x|$ 的多项式。两个多项式之和仍然是多项式，所以 NTM $N$ 的整个过程在多项式时间内运行。\n\n现在，我们来评估给出的选项：\n\n-   **A:** 该选项准确地描述了两阶段的“猜测并验证”过程。它通过顺序地（用符号分隔）猜测两个独立的证书，然后模拟验证者，从而正确处理了这种情况。这与我们推导出的构造方法相匹配。\n\n-   **B:** 这个选项是错误的，因为它假设两个证书可以通过将一个更大的证书精确地分成两半来获得。如果所需的多项式界限不同（即 $p(|x|) \\neq q(|x|)$），或者即使它们相同但具体所需的证书长度不同，这种方法也会失败。例如，如果 $x$ 需要长度为5的 $c_1$ 和长度为10的 $c_2$，这种方法永远也找不到它们。\n\n-   **C:** 这个选项有根本性的缺陷。语言的定义要求 $c_1$ 和 $c_2$ *同时* 存在并 *共同* 起作用。这个选项测试的是是否存在一个与空 $c_2$ 一起工作的 $c_1$，或者一个与空 $c_1$ 一起工作的 $c_2$。这是一个不同的逻辑条件，定义了一个不同的语言。\n\n-   **D:** 这个选项描述的是一个*确定性*算法，而不是非确定性算法。它实质上是在暴力搜索证书空间。虽然这可以正确判定该语言，但可能的证书数量是 $|x|$ 的指数级，所以这个算法将在指数时间而不是多项式时间内运行。这描述的是一台用于 EXPTIME 中语言的机器，而不是 NP。\n\n-   **E:** 这个选项错误地假设两个证书必须相同 ($c_1 = c_2$)。问题陈述了一个接收两个证书的验证者，除非另有说明，否则这两个证书是独立的。这种方法不够通用，无法判定 $L$。\n\n因此，选项 A 提供了 NTM $N$ 的正确且通用的构造方法。", "answer": "$$\\boxed{A}$$", "id": "1422203"}, {"introduction": "在掌握了基本构造之后，让我们通过一个思想实验来更深入地探索验证者的本质。这个问题 [@problem_id:1422176] 提出了一个有趣的情景：如果一个多项式时间验证者可以访问一个指数级长度的证书，这是否会赋予它更强大的计算能力？这个练习将挑战我们的直觉，并揭示在验证过程中，真正的资源瓶颈究竟是证书的长度还是验证者自身的运行时间。", "problem": "在计算复杂性理论中，NP 类通常使用多项式时间验证机来定义。一个语言 $L$ 属于 NP，如果存在一个多项式 $p(n)$ 和一个多项式时间的确定性图灵机（DTM），称为验证机 $V$，使得对于任何长度为 $n = |x|$ 的输入字符串 $x$：\n1.  如果 $x \\in L$，存在一个长度至多为 $p(n)$ 的证据字符串 $w$，使得 $V(x, w)$ 接受。\n2.  如果 $x \\notin L$，对于所有长度至多为 $p(n)$ 的证据字符串 $w$，$V(x, w)$ 都拒绝。\n\n考虑一个新的复杂性类，我们称之为 `OracleNP`。该类通过修改验证机模型来定义。一个语言 $L$ 属于 `OracleNP`，如果存在两个多项式 $p(n)$ 和 $q(n)$ 以及一个 DTM $V_O$，使得对于任何长度为 $n=|x|$ 的输入字符串 $x$：\n-   验证机 $V_O$ 在以 $q(n)$ 为界的时间内运行。\n-   $V_O$ 可以预言机访问一个证据字符串 $y$。这意味着 $V_O$ 可以在一个计算步骤内，将一个二进制索引 $i$ 写入一条特殊的查询带，并接收 $y$ 的第 $i$ 位，记作 $y_i$。\n-   证据 $y$ 的长度可以达到 $2^{p(n)}$。因此，$V_O$ 查询的索引 $i$ 的值可以达到 $2^{p(n)}$。\n\n`OracleNP` 的接受和拒绝条件是：\n1.  如果 $x \\in L$，存在一个长度至多为 $2^{p(n)}$ 的证据字符串 $y$，使得 $V_O$ 在给定输入 $x$ 并可预言机访问 $y$ 的情况下接受。\n2.  如果 $x \\notin L$，对于所有长度至多为 $2^{p(n)}$ 的证据字符串 $y$，$V_O$ 在给定输入 $x$ 并可预言机访问 $y$ 的情况下都拒绝。\n\n基于这些定义，请确定 `OracleNP` 类与其他著名复杂性类之间的关系。\n\nA. `OracleNP` = P\n\nB. `OracleNP` = NP\n\nC. `OracleNP` = PSPACE\n\nD. `OracleNP` = EXPTIME\n\nE. `OracleNP` 真包含 NP，但被包含于 PSPACE。\n\nF. NP 真包含 `OracleNP`。", "solution": "我们将由具有对指数长度证据字符串的预言机访问（对单个比特的随机访问查询）的多项式时间确定性验证机所定义的类，与标准的 NP 类进行比较。\n\n首先，我们对该模型进行形式化描述。对于 `OracleNP` 中的语言 $L$，存在多项式 $p(n)$ 和 $q(n)$ 以及一个 DTM $V_{O}$，使得在输入为 $x$（其中 $|x|=n$）时，$V_{O}$ 在至多 $q(n)$ 的时间内运行，并可以在任何步骤发出一个查询索引 $i$（二进制形式），并接收一个长度至多为 $2^{p(n)}$ 的辅助字符串 $y$ 的比特 $y_{i}$。接受条件是对 $y$ 的存在性量化：\n1. 如果 $x \\in L$，则存在 $y$（其中 $|y| \\leq 2^{p(n)}$），使得 $V_{O}^{y}(x)$ 接受。\n2. 如果 $x \\notin L$，则对于所有这样的 $y$，$V_{O}^{y}(x)$ 都拒绝。\n\n我们通过证明两个方向的包含关系来表明 OracleNP 等于 NP。\n\n包含关系 $\\mathrm{NP} \\subseteq \\mathrm{OracleNP}$ 的证明：令 $L \\in \\mathrm{NP}$，其验证机 $V$ 的运行时间至多为 $r(n)$，使用的证据 $w$ 长度至多为 $s(n)$，其中 $r$ 和 $s$ 为多项式。定义一个 $V_{O}$，它在输入 $x$ 时，仅查询其预言机证据 $y$ 的前 $s(n)$ 个位置以读取一个假定的 $w$，然后模拟 $V(x,w)$。由于 $V_{O}$ 的运行时间是关于 $n$ 的多项式时间，因此 $L$ 属于 OracleNP。所以 $\\mathrm{NP} \\subseteq \\mathrm{OracleNP}$。\n\n包含关系 $\\mathrm{OracleNP} \\subseteq \\mathrm{NP}$ 的证明：令 $L \\in \\mathrm{OracleNP}$，其多项式为 $p,q$，验证机为 $V_{O}$，如上所述。我们构造一个标准的 NP 验证机 $U$，其多项式大小的证据编码了一次接受的预言机交互过程。因为 $V_O$ 的运行时间至多为 $q(n)$，所以它最多能发出 $q(n)$ 次查询。在特定预言机 $y$ 下，它在输入 $x$ 上的计算序列完全由 $x$ 和对这些查询的回答所决定。\n\n将证据 $w$ 定义为一个长度至多为 $T \\leq q(n)$ 的记录，它包含了在唯一一次运行中遇到的查询-回答信息序列：对于 $t=1,\\dots,T$，包含被查询的索引 $i_{t}$（二进制形式，长度至多为 $p(n)$）和回答比特 $b_{t} \\in \\{0,1\\}$。因此， $|w| \\leq T\\,(p(n)+1) \\leq q(n)\\,(p(n)+1)$，这是关于 $n$ 的多项式。\n\n验证机 $U$ 在输入 $x$ 和证据 $w$ 的情况下，逐步模拟 $V_{O}(x)$，最多模拟 $q(n)$ 步。每当 $V_O$ 写入一个查询索引（称之为 $\\hat{i}_{t}$）时，模拟器就从 $w$ 中读取下一个序对 $(i_{t},b_{t})$ 并检查是否 $i_{t}=\\hat{i}_{t}$。它维护一个先前查询过的索引的映射表以强制一致性：如果一个索引重复出现，它会检查新提供的 $b_{t}$ 是否与记录的比特匹配。然后它将 $b_{t}$ 作为预言机回答，并继续模拟。如果在任何时候索引不匹配、一致性检查失败，或者模拟超过 $q(n)$ 步，$U$ 就拒绝。如果模拟在 $q(n)$ 步内停机并处于接受状态，$U$ 就接受。\n\n正确性证明：\n- 如果 $x \\in L$，则存在一个 $y$ 使得 $V_{O}^{y}(x)$ 接受。令 $w$ 为那次接受运行的记录：即按顺序排列的序对 $(i_{t},y_{i_{t}})$ 序列。那么 $U$ 的模拟将精确地再现该次运行并接受。\n- 如果 $x \\notin L$，则对于任何 $y$，$V_{O}^{y}(x)$ 都拒绝。对于任何给定的所谓记录 $w$，它要么与 $V_O$ 的确定性行为不一致（导致不匹配或不一致，从而被 $U$ 检测并拒绝），要么它忠实地模拟了某个预言机运行，而该运行必然以拒绝告终；因此 $U$ 拒绝。\n\n因此，$L \\in \\mathrm{NP}$ 且 $\\mathrm{OracleNP} \\subseteq \\mathrm{NP}$。\n\n结合两个方向的包含关系，我们得到 $\\mathrm{OracleNP}=\\mathrm{NP}$。因此，在所列选项中，正确的关系是 OracleNP 等于 NP。", "answer": "$$\\boxed{B}$$", "id": "1422176"}, {"introduction": "为了最终巩固我们对 NP 定义的理解，我们将考察一个相反的极端情况。在上一个练习中，我们看到一个巨大的证书并不能增强一个多项式时间验证者的能力，现在我们来问：如果验证者的时间被严格限制会发生什么？这个问题 [@problem_id:1422192] 探索了一个运行时间仅为对数级的验证者，这将帮助我们认识到为什么 NP 定义中的“多项式时间”这一条件至关重要，以及不满足该条件会对计算能力产生何种影响。", "problem": "在计算复杂性理论中，NP类是所有其成员资格（membership）可以在多项式时间内被验证的语言的集合。形式上，一个语言 $L$ 属于NP，如果存在一个多项式 $p(n)$ 和一个多项式时间的确定性图灵机 $V$（称为验证机），使得对于任何长度为 $n$ 的输入串 $x$：\n$x \\in L \\iff$ 存在一个证书串 $c$ 且 $|c| \\le p(n)$，使得 $V$ 接受输入 $\\langle x, c \\rangle$。\n证明任何可由多项式时间非确定性图灵机（NTM）判定的语言都属于NP的标准方法，是利用NTM的非确定性选择序列作为证书 $c$。然后，验证机 $V$ 根据 $c$ 指定的路径模拟NTM的计算。证书的长度 $|c|$ 和验证机的运行时间都与 $|x|$ 呈多项式关系。\n\n现在考虑对这种关系进行修改。我们使用一个更具限制性的验证机来定义一个新的复杂性类，我们称之为 `LCT-NP`。一个语言 $L$ 属于 `LCT-NP`，如果存在一个多项式 $p(n)$ 和一个确定性图灵机 $V$，使得对于任何长度为 $n$ 的输入串 $x$：\n$x \\in L \\iff$ 存在一个证书串 $c$ 且 $|c| \\le p(n)$，使得 $V$ 在与证书长度的对数成正比的步数内，即在 $O(\\log|c|)$ 时间内，接受输入 $\\langle x, c \\rangle$。\n\n`LCT-NP` 类等价于下列哪个著名的复杂性类？\n\nA. P（可在确定性图灵机上于多项式时间内判定的语言类）\n\nB. L（可在确定性图灵机上于对数空间内判定的语言类）\n\nC. NL（可在非确定性图灵机上于对数空间内判定的语言类）\n\nD. 可在确定性图灵机上于 $O(\\log n)$ 时间内判定的语言类，其中 $n$ 是输入的长度。\n\nE. 正则语言类。", "solution": "我们首先精确地重述LCT-NP的定义。一个语言 $L$ 属于LCT-NP，如果存在一个多项式 $p(n)$ 和一个确定性图灵机 $V$，使得对于每个 $|x| = n$ 的输入 $x$，\n$$\nx \\in L \\iff \\exists c \\text{ with } |c| \\le p(n) \\text{ such that $V$ accepts } \\langle x, c \\rangle \\text{ in } O(\\log |c|) \\text{ time.}\n$$\n我们来分析这个时间界限。由于 $|c| \\le p(n)$，因此存在一个常数 $d \\ge 1$ 和某个整数 $k \\ge 1$，使得 $|c| \\le d \\cdot n^{k}$。因此，\n$$\n\\log |c| \\le \\log(d \\cdot n^{k}) = \\log d + k \\log n = O(\\log n).\n$$\n因此，只要 $|c| \\le p(n)$，验证机 $V$ 总是在 $O(\\log n)$ 步内对其输入 $\\langle x, c \\rangle$ 停机。特别地，在组合输入 $\\langle x, c \\rangle$ 上，$V$ 是一个确定性的 $O(\\log n)$ 时间过程。\n\n现在我们将 LCT-NP 与可在确定性图灵机上于 $O(\\log n)$ 时间内判定的语言类（选项D）进行比较。我们将证明两个方向的包含关系。\n\n包含关系 DTIME$(O(\\log n)) \\subseteq$ LCT-NP：\n设语言 $L$ 可由一个确定性图灵机 $A$ 在时间 $T(n) = O(\\log n)$ 内对长度为 $n$ 的输入进行判定。定义一个验证机 $V$，它在收到输入 $\\langle x, c \\rangle$ 时，忽略 $c$ 并模拟 $A$ 对 $x$ 的计算，最多执行 $O(\\log |c|)$ 步。为确保时间预算充足，要求证书长度满足 $|c| \\ge n$（或更一般地， $|c| = n^{2}$）；这是允许的，因为 LCT-NP 的定义允许任何 $|c| \\le p(n)$，其中 $p(n)$ 是某个多项式界限，我们可以选择 $p(n)$ 至少为 $n^{2}$。那么\n$$\n\\log |c| \\ge \\log n \\implies O(\\log |c|) \\text{ steps suffice to simulate } A \\text{ on } x.\n$$\n定义 $p(n) = n^{2}$，并让证明者（prover）提供任何满足 $|c| = n^{2}$ 的证书 $c$。那么对于所有的 $x$：\n$$\nx \\in L \\iff A(x) \\text{ accepts in } O(\\log n) \\text{ time} \\iff \\exists c \\text{ with } |c| \\le p(n) \\text{ such that } V(\\langle x, c \\rangle) \\text{ accepts in } O(\\log |c|) \\text{ time}.\n$$\n因此 $L$ 属于 LCT-NP。所以，\n$$\n\\text{DTIME}(O(\\log n)) \\subseteq \\text{LCT-NP}.\n$$\n\n包含关系 LCT-NP $\\subseteq$ DTIME$(O(\\log n))$：\n设 $L \\in$ LCT-NP，其验证机为 $V$，界限为 $p(n)$。对于任何 $|x|=n$ 的输入 $x$，其是否被接受取决于是否存在一个证书 $c$（其中 $|c| \\le p(n)$），使得 $V$ 在至多 $O(\\log |c|) \\subseteq O(\\log n)$ 步内接受。在 $O(\\log n)$ 步内，一个标准的确定性图灵机最多能访问其（顺序的）输入带上的 $O(\\log n)$ 个单元格。因此，在对 $\\langle x, c \\rangle$ 的任何接受计算过程中，机器 $V$ 总共只能从 $x$ 和 $c$ 的串接中检查 $O(\\log n)$ 个符号。因此，对于每个固定的 $n$，$V$ 是否接受 $x$ 仅取决于：\n- 从 $x$ 中读取的最多 $O(\\log n)$ 个符号（必然来自读写头在 $O(\\log n)$ 次移动内可达的位置），以及\n- 从 $c$ 中读取的最多 $O(\\log n)$ 个符号。\n\n因此，对 $c$ 的存在量化实际上只作用于 $V$ 在其时间限制内可能读取的 $c$ 的一个长度为 $O(\\log n)$ 的片段；$c$ 的其余部分与计算无关。于是，对于每个输入长度 $n$，存在一个固定的确定性 $O(\\log n)$ 时间谓词 $R_n$，使得\n$$\nx \\in L \\iff \\exists y \\in \\{0,1\\}^{\\ell(n)} \\text{ with } \\ell(n) = O(\\log n) \\text{ and } R_{n}(x, y) = 1,\n$$\n其中 $R_n$ 是可通过在 $O(\\log n)$ 步内模拟 $V$ 在 $\\langle x, y \\rangle$ 上的计算来求得的（将 $y$ 视为 $c$ 中唯一可能被读取的部分）。由于 $R_n$ 在确定性 $O(\\log n)$ 时间内运行，并且最多依赖于 $x$ 和 $y$ 的 $O(\\log n)$ 位，因此 $y$ 的存在仅通过一个保持在 $O(\\log n)$ 时间范围内的有界时间交互来影响接受与否。因此，对 $L$ 的整体成员资格测试是可在确定性 $O(\\log n)$ 时间内计算的：我们可以在相同的 $O(\\log n)$ 时间预算内实现对 $y$ 的最优选择，因为只有 $y$ 的 $O(\\log n)$ 位能够影响运行，并且 $V$ 在有界时间范围内的转移函数一旦这些位被设置为使 $V$ 接受的方式，就会确定性地决定接受结果。因此，\n$$\n\\text{LCT-NP} \\subseteq \\text{DTIME}(O(\\log n)).\n$$\n\n结合两个方向的包含关系，我们得到等价关系\n$$\n\\text{LCT-NP} = \\text{DTIME}(O(\\log n)).\n$$\n在所有选项中，这正是选项D。", "answer": "$$\\boxed{D}$$", "id": "1422192"}]}