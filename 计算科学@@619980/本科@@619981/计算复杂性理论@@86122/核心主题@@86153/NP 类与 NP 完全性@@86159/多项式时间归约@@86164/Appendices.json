{"hands_on_practices": [{"introduction": "第一个练习说明了规约不仅仅是用来证明问题难度的工具，它本身也是一种强大的解题技巧。我们将探讨如何将一个看似几何谜题的问题——用多米诺骨牌铺满地板——转化为一个经典的图论问题：寻找完美匹配。这个练习旨在培养你的直觉，让你了解如何用另一种我们拥有高效算法的数学语言来为一个问题的核心约束建模。[@problem_id:1436237]", "problem": "一位建筑师正在使用基于网格的系统设计一个房间的平面图。该房间由一个方格网格表示。一些方格被指定为“障碍”，无法铺砌，而其余的“可用”方格必须由1x2的矩形瓷砖（通常称为多米诺骨牌）完美覆盖。每张多米诺骨牌必须恰好覆盖两个相邻（即共享一条边）的可用方格。\n\n一位计算机科学家的任务是创建一个算法，以确定给定的平面图是否可以被完美铺砌。根据计算复杂性理论，我们知道 `PERFECT MATCHING` 问题可以被有效地（在多项式时间内）解决。`PERFECT MATCHING` 问题的定义如下：给定一个图 $G=(V, E)$，确定是否存在一个边子集 $M \\subseteq E$，使得顶点集 $V$ 中的每个顶点都恰好是 $M$ 中一条边的端点。\n\n你的任务是形式化一个从多米诺骨牌铺砌问题到 `PERFECT MATCHING` 问题的多项式时间归约。对于一个具有可用方格集合 $S$ 的通用网格，下列哪个选项正确描述了图 $G=(V, E)$ 的构造，使得可用方格存在完美铺砌等价于图 $G$ 中存在完美匹配？\n\nA. 令顶点集 $V$ 为所有可用方格的集合 $S$。当且仅当顶点 $u$ 和 $v$ 对应的方格在网格中相邻时，边 $(u, v)$ 存在于边集 $E$ 中。\n\nB. 令顶点集 $V$ 为所有可用方格的集合 $S$。当且仅当顶点 $u$ 和 $v$ 对应的方格在同一行或同一列时，边 $(u, v)$ 存在于边集 $E$ 中。\n\nC. 令顶点集 $V$ 由网格的每一行的一个顶点和每一列的一个顶点组成。当且仅当位于第 $r$ 行和第 $c$ 列的方格是可用方格时，边 $(r, c)$ 存在于边集 $E$ 中。\n\nD. 令顶点集 $V$ 为网格上单个多米诺骨牌所有可能的有效放置位置的集合。当且仅当多米诺骨牌的放置位置 $d_1$ 和 $d_2$ 不重叠时，边 $(d_1, d_2)$ 存在于边集 $E$ 中。", "solution": "我们将具有可用方格集合 $S$ 的网格上的多米诺骨牌铺砌问题到 PERFECT MATCHING 问题的归约形式化如下。\n\n图的构造：给定一个网格和可用方格的集合 $S$，定义一个图 $G=(V,E)$ 如下\n$$\nV=S,\\qquad E=\\{\\{u,v\\}\\subseteq S:\\ u\\text{ and }v\\text{ are adjacent squares in the grid}\\}.\n$$\n相邻意味着如果一个方格由整数坐标 $(i,j)$ 索引，那么 $u=(i,j)$ 和 $v=(i',j')$ 相邻当且仅当 $|i-i'|+|j-j'|=1$。通过扫描网格，并为每个 $u\\in S$ 添加连接到其最多四个也位于 $S$ 中的邻居的边，这个构造可以在 $|S|$ 的多项式时间内完成。\n\n正确性（铺砌对应于完美匹配）：多米诺骨牌铺砌是把 $S$ 划分成不相交的相邻方格对。图 $G$ 中的完美匹配是一个集合 $M\\subseteq E$，使得 $V$ 中的每个顶点都恰好与 $M$ 中的一条边相关联。\n\n正向：假设存在一个用多米诺骨牌对 $S$ 的完美铺砌 $\\mathcal{T}$。每张多米诺骨牌恰好覆盖两个相邻的可用方格 $\\{u,v\\}$，因此对应于一条边 $\\{u,v\\}\\in E$。定义\n$$\nM=\\{\\{u,v\\}\\in E:\\ \\{u,v\\}\\text{ is the pair covered by some domino in }\\mathcal{T}\\}.\n$$\n因为 $\\mathcal{T}$ 中的瓷砖是不相交的并且覆盖了 $S$ 中的所有方格，所以 $M$ 中的边是不相交的并且覆盖了 $V=S$ 中的所有顶点。因此，$M$ 是图 $G$ 中的一个完美匹配。\n\n反向：假设图 $G$ 有一个完美匹配 $M$。$M$ 中的每条边 $\\{u,v\\}$ 都将两个相邻的可用方格配对。由于 $M$ 是完美的， $M$ 的边是不相交的并且覆盖了 $V=S$ 中的所有顶点。在每个这样的相邻对 $\\{u,v\\}\\in M$ 上放置一个多米诺骨牌；这些多米诺骨牌是不相交的并且覆盖了所有的 $S$，因此定义了一个完美铺砌。\n\n因此，当且仅当图 $G$ 有一个完美匹配时，该实例存在一个完美铺砌。该映射可在多项式时间内计算，因此这是一个有效的多项式时间多一归约。\n\n选项验证：\n- 选项 A 与上述构造完全匹配，是正确的。\n- 选项 B 错误地连接了同一行或同一列中的所有方格，包括不相邻的方格，这允许了不对应于有效多米诺骨牌放置的配对；这是不正确的。\n- 选项 C 使用行为顶点，列为顶点，可用方格为边；其中的完美匹配会将每一行和每一列精确匹配一次，这并不能模拟多米诺的邻接性或对 $S$ 的覆盖；这是不正确的。\n- 选项 D 将顶点设为多米诺骨牌的放置位置，边表示不重叠；完美匹配将会配对放置位置，而不是选择一个覆盖 $S$ 的集合。选择一组不重叠放置位置的正确结构是独立集，而不是完美匹配；这是不正确的。\n\n因此，正确的构造由选项 A 给出。", "answer": "$$\\boxed{A}$$", "id": "1436237"}, {"introduction": "现在，让我们转向归约在复杂性理论中的主要用途：证明 NP-难度。这个练习要求你分析一个从著名的 NP-难问题 `SUBSET-SUM` 到其变体 `MULTIPLE-CHOICE-SUBSET-SUM` 的归约。这里的关键是理解证明一个问题“至少和另一个问题一样难”的逻辑，并体会用一个简单的列表 $\\lbrace s_i, 0 \\rbrace$ 来模拟一个基本计算选择的精妙之处。[@problem_id:1436216]", "problem": "在计算复杂性理论中，我们分析计算问题的难度。如果一个问题可以由确定性图灵机在多项式时间内解决，那么它就属于P类问题。如果一个问题的提议解可以在多项式时间内被验证，那么它就属于NP类（非确定性多项式时间）问题。如果任何NP类中的问题都可以在多项式时间内归约到它，那么这个问题就是NP-hard的。\n\n考虑以下两个判定问题：\n\n1.  **SUBSET-SUM**：给定一个有限整数集合 $S = \\{s_1, s_2, \\dots, s_n\\}$ 和一个目标整数 $T$，是否存在一个子集 $S' \\subseteq S$，使得 $S'$ 中元素的和恰好等于 $T$？已知 `SUBSET-SUM` 问题是NP-hard的。\n\n2.  **MULTIPLE-CHOICE-SUBSET-SUM (MCSS)**：给定 $k$ 个非空整数列表的集合 $\\mathcal{L} = \\{L_1, L_2, \\dots, L_k\\}$ 和一个目标整数 $T'$，是否可能从每个列表 $L_i$（对于 $i=1, \\dots, k$）中恰好选择一个整数 $x_i$，使得 $\\sum_{i=1}^{k} x_i = T'$？\n\n为了证明 `MCSS` 是 NP-hard 的，一名学生提出了一个从 `SUBSET-SUM` 的多项式时间归约。该归约按如下方式从一个 `SUBSET-SUM` 实例构造一个 `MCSS` 实例：\n\n给定一个由集合 $S = \\{s_1, s_2, \\dots, s_n\\}$ 和目标 $T$ 定义的 `SUBSET-SUM` 实例，构造出的 `MCSS` 实例由 $n$ 个列表的集合 $\\mathcal{L} = \\{L_1, L_2, \\dots, L_n\\}$ 和一个目标 $T'$ 定义。对于原集合 $S$ 中的每个整数 $s_i$，创建一个对应的列表 $L_i$ 为 $L_i = \\{s_i, 0\\}$。`MCSS` 实例的目标被设置为 $T' = T$。\n\n下列哪个陈述正确地评价了这个用以证明 `MCSS` 的 NP-hard 性的归约？\n\nA. 该构造是一个有效的多项式时间归约，正确地证明了 `MCSS` 是NP-hard的。\n\nB. 该构造无效，因为它只证明了所需逻辑等价性的一个方向；具体来说，它表明如果一个 `SUBSET-SUM` 实例有解，那么构造的 `MCSS` 实例也有解，但未能证明其逆命题。\n\nC. 该构造无效，因为从 `SUBSET-SUM` 实例到 `MCSS` 实例的转换无法在相对于 `SUBSET-SUM` 输入规模的多项式时间内计算。\n\nD. 该构造无效，因为要证明一个问题是NP-hard的，必须将该问题归约*到*一个已知的NP-hard问题（即 `MCSS` 归约到 `SUBSET-SUM`），而不是反过来。\n\nE. 该构造无效，因为 `MCSS` 问题要求从*每个*列表中选择一个元素，这没有正确地建模 `SUBSET-SUM` 问题，在 `SUBSET-SUM` 问题中可以为子集选择任意数量的元素（从零到 $n$ 个）。", "solution": "要证明一个问题 $Q$ 是 NP-hard 的，我们只需展示一个从已知的 NP-hard 问题 $P$ 到 $Q$ 的多项式时间多一归约。形式上，我们需要一个函数 $f$，它可以在输入规模的多项式时间内计算，并且对于 $P$ 的每个实例 $x$，$x$ 是 $P$ 的是实例当且仅当 $f(x)$ 是 $Q$ 的是实例。这个条件确保了 $Q$ 至少和 $P$ 一样难。\n\n在这里，$P$ 是 SUBSET-SUM，$Q$ 是 MCSS。所提出的归约将 SUBSET-SUM 的一个实例 $(S,T)$（其中 $S=\\{s_{1},\\dots,s_{n}\\}$）映射到 MCSS 的一个实例 $(\\mathcal{L},T')$，该实例定义为 $\\mathcal{L}=\\{L_{1},\\dots,L_{n}\\}$，其中对每个 $i$ 有 $L_{i}=\\{s_{i},0\\}$，并且 $T'=T$。\n\n首先，该映射是多项式时间可计算的：构造 $n$ 个列表，每个列表包含两个整数 $s_{i}$ 和 $0$，并设置 $T'=T$，所需时间是关于 $n$ 和整数输入规模的多项式，因此是关于 SUBSET-SUM 实例规模的多项式。\n\n其次，归约的正确性由一个双向蕴涵保证。\n1. 如果 SUBSET-SUM 实例是一个是实例，那么存在一个子集 $S'\\subseteq S$ 使得\n$$\n\\sum_{s\\in S'} s \\;=\\; T.\n$$\n为每个 $i$ 定义一个选择 $x_{i}\\in L_{i}$，方法是：如果 $s_{i}\\in S'$，则设 $x_{i}=s_{i}$；否则设 $x_{i}=0$。这样，从每个列表中恰好选择了一个元素，并且\n$$\n\\sum_{i=1}^{n} x_{i} \\;=\\; \\sum_{s\\in S'} s \\;=\\; T \\;=\\; T',\n$$\n因此构造的 MCSS 实例是一个是实例。\n\n2. 反之，如果构造的 MCSS 实例是一个是实例，那么存在选择 $x_{i}\\in L_{i}$ 对于 $i=1,\\dots,n$ 使得\n$$\n\\sum_{i=1}^{n} x_{i} \\;=\\; T'.\n$$\n根据构造，每个 $x_{i}\\in\\{s_{i},0\\}$。定义 $S'=\\{\\,s_{i}\\in S : x_{i}=s_{i}\\,\\}$。那么\n$$\n\\sum_{s\\in S'} s \\;=\\; \\sum_{i=1}^{n} x_{i} \\;=\\; T' \\;=\\; T,\n$$\n因此原始的 SUBSET-SUM 实例是一个是实例。\n\n因此，对于每个实例 $(S,T)$，实例 $(\\mathcal{L},T')$ 满足\n$$\n(S,T)\\in \\text{SUBSET-SUM} \\;\\;\\Longleftrightarrow\\;\\; (\\mathcal{L},T')\\in \\text{MCSS}.\n$$\n这建立了一个有效的多项式时间多一归约 $\\text{SUBSET-SUM} \\leq_{p} \\text{MCSS}$。因为 SUBSET-SUM 是 NP-hard 的，所以 MCSS 也是 NP-hard 的。\n\n这直接支持了选项 A。选项 B 是错误的，因为该归约证明了双向的等价性。选项 C 是错误的，因为该构造显然是多项式时间的。选项 D 是错误的，因为证明 MCSS 的 NP-hard 性的正确方向是把一个已知的 NP-hard 问题归约到 MCSS，而不是反过来。选项 E 是错误的，因为要求从每个列表中进行选择与 SUBSET-SUM 是一致的，这是通过在每个列表中包含 0 实现的，这模拟了从子集中排除一个元素的选择。", "answer": "$$\\boxed{A}$$", "id": "1436216"}, {"introduction": "我们的最后一个练习将挑战你进行更抽象的思考，将一个图问题与一个矩阵问题联系起来。你将通过把 `VERTEX-COVER` 归约到 `COLUMN-COVER` 来证明后者的 NP-难度。这个练习的重点是培养一项至关重要的技能：识别一个问题的本质结构属性（例如顶点覆盖边），并将其映射到另一个问题的约束上（例如选定的列覆盖所有行），这是设计归约时一种常见且强大的模式。[@problem_id:1436236]", "problem": "在计算复杂性理论中，我们使用多项式时间归约来确定问题的相对难度。如果问题 $P_1$ 的任何实例都可以在多项式时间内转换为问题 $P_2$ 的一个实例，使得 $P_2$ 实例的解可以用来解决原始的 $P_1$ 实例，那么我们称问题 $P_1$ 可归约到问题 $P_2$。\n\n考虑以下两个判定问题：\n\n1.  **VERTEX-COVER**：给定一个无向图 $G=(V, E)$（其中 $V$ 是顶点集，$E$ 是边集）和一个正整数 $k$，是否存在一个顶点子集 $V' \\subseteq V$ 且满足 $|V'| \\le k$，使得对于每条边 $(u, v) \\in E$，顶点 $u$ 或 $v$ 中至少有一个在 $V'$ 中？这样的集合 $V'$ 被称为顶点覆盖。\n\n2.  **COLUMN-COVER**：给定一个 $m \\times n$ 的二进制矩阵 $M$（只包含0和1）和一个正整数 $k'$，是否存在一个列索引集合 $C'$ 且满足 $|C'| \\le k'$，使得 $M$ 中的每一行在 $C'$ 指定的列中至少有一个'1'？\n\n你的任务是找出一个正确的的多项式时间归约，将 VERTEX-COVER 的任意实例 $(G=(V, E), k)$ 转换为 COLUMN-COVER 的一个实例 $(M, k')$。设 $|V| = n$ 且 $|E| = m$。顶点索引为 $v_1, \\dots, v_n$，边索引为 $e_1, \\dots, e_m$。\n\n下列哪个选项描述了正确的转换？\n\nA. 构建一个 $n \\times n$ 的矩阵 $M$，该矩阵对应于 $G$ 的邻接矩阵，其中如果顶点 $v_i$ 和顶点 $v_j$ 之间有边，则 $M_{ij}=1$，否则 $M_{ij}=0$。将 COLUMN-COVER 的目标整数设为 $k'=k$。\n\nB. 构建一个 $m \\times n$ 的矩阵 $M$。对于每条边 $e_i = (v_a, v_b)$，设置矩阵项 $M_{ia}=1$ 和 $M_{ib}=1$。矩阵中的所有其他项均为0。将 COLUMN-COVER 的目标整数设为 $k'=n-k$。\n\nC. 构建一个 $n \\times m$ 的矩阵 $M$。对于每条边 $e_j = (v_a, v_b)$，设置矩阵项 $M_{aj}=1$ 和 $M_{bj}=1$。矩阵中的所有其他项均为0。将 COLUMN-COVER 的目标整数设为 $k'=k$。\n\nD. 构建一个 $m \\times n$ 的矩阵 $M$。对于每条边 $e_i = (v_a, v_b)$，设置矩阵项 $M_{ia}=1$ 和 $M_{ib}=1$。矩阵中的所有其他项均为0。将 COLUMN-COVER 的目标整数设为 $k'=k$。", "solution": "目标是找到一个从 VERTEX-COVER 实例 $(G=(V,E), k)$ 到 COLUMN-COVER 实例 $(M, k')$ 的映射，使得 VERTEX-COVER 实例的答案为“是”当且仅当 COLUMN-COVER 实例的答案为“是”。让我们分析一下提议的几种转换。\n\n正确的转换由选项D给出。我们来描述这个构造并证明其正确性。\n\n**构造（如选项D所述）：**\n给定 VERTEX-COVER 实例 $(G=(V,E), k)$，其中 $|V|=n$ 且 $|E|=m$。我们如下构造一个 COLUMN-COVER 实例 $(M, k')$：\n1.  创建一个 $m \\times n$ 的矩阵 $M$。该矩阵的行对应于 $G$ 的边，列对应于 $G$ 的顶点。\n2.  对于矩阵的每个元素 $M_{ij}$（第 $i$ 行，第 $j$ 列），如果边 $e_i$ 与顶点 $v_j$ 相关联，则设置 $M_{ij} = 1$，否则设置 $M_{ij} = 0$。在一个无向图中，一条边 $e_i = (v_a, v_b)$ 与两个顶点 $v_a$ 和 $v_b$ 相关联。因此，对于与边 $e_i$ 对应的每一行 $i$，恰好有两列的值为'1'。\n3.  将 COLUMN-COVER 问题的整数设为 $k' = k$。\n\n这个构造可以在多项式时间内完成。创建一个 $m \\times n$ 的矩阵并遍历所有 $m$ 条边，为每条边设置两个矩阵项，这需要 $O(m \\cdot n)$ 的时间，这在图表示的规模上是多项式的。\n\n**正确性证明：**\n我们必须证明，$G$ 有一个大小至多为 $k$ 的顶点覆盖，当且仅当 $M$ 有一个大小至多为 $k$ 的列覆盖。\n\n**第一部分： (VERTEX-COVER $\\implies$ COLUMN-COVER)**\n假设在 $G$ 中存在一个顶点覆盖 $V' \\subseteq V$ 且 $|V'| \\le k$。我们需要证明对于矩阵 $M$ 存在一个列覆盖 $C'$ 且 $|C'| \\le k$。\n\n我们通过选取与 $V'$ 中顶点对应的列的索引来构造列集合 $C'$。形式上，$C' = \\{j \\mid v_j \\in V'\\}$。根据这个构造，$|C'| = |V'| \\le k$。\n\n现在我们必须证明 $C'$ 是一个有效的列覆盖。考虑矩阵 $M$ 中的任意一行 $i$。该行对应于 $G$ 中的一条边 $e_i = (v_a, v_b)$。由于 $V'$ 是一个顶点覆盖，根据定义，它必须包含 $e_i$ 的至少一个端点。也就是说，$v_a \\in V'$ 或 $v_b \\in V'$ (或两者都在)。\n\n- 如果 $v_a \\in V'$，那么列索引 $a$ 就在 $C'$ 中。根据我们对 $M$ 的构造，矩阵项 $M_{ia}$ 为1。因此，行 $i$ 被列 $a \\in C'$ “覆盖”。\n- 如果 $v_b \\in V'$，那么列索引 $b$ 就在 $C'$ 中。根据我们对 $M$ 的构造，矩阵项 $M_{ib}$ 为1。因此，行 $i$ 被列 $b \\in C'$ “覆盖”。\n\n由于每条边都被 $V'$ 覆盖，所以 $M$ 中的每一行都在一个对应于 $V'$ 中某个顶点的列上有一个'1'。因此，$C'$ 是 $M$ 的一个大小至多为 $k$ 的有效列覆盖。\n\n**第二部分： (COLUMN-COVER $\\implies$ VERTEX-COVER)**\n假设对于矩阵 $M$ 存在一个列覆盖 $C'$ 且 $|C'| \\le k$。我们需要证明在 $G$ 中存在一个顶点覆盖 $V'$ 且 $|V'| \\le k$。\n\n我们通过选取与 $C'$ 中列索引对应的顶点来构造顶点集合 $V'$。形式上，$V' = \\{v_j \\mid j \\in C'\\}$。根据这个构造， $|V'| = |C'| \\le k$。\n\n现在我们必须证明 $V'$ 是一个有效的顶点覆盖。考虑 $G$ 中的任意一条边 $e_i = (v_a, v_b)$。这条边对应于矩阵 $M$ 的第 $i$ 行。由于 $C'$ 是一个列覆盖，第 $i$ 行必须在某个索引属于 $C'$ 的列上至少有一个'1'。设这个列为 $j \\in C'$。\n\n所以，对于某个 $j \\in C'$，有 $M_{ij}=1$。根据我们对 $M$ 的构造，$M_{ij}=1$ 意味着边 $e_i$ 与顶点 $v_j$ 相关联。根据我们对 $V'$ 的构造，由于 $j \\in C'$，顶点 $v_j$ 就在 $V'$ 中。因此，边 $e_i$ 被顶点 $v_j \\in V'$ 覆盖。\n\n由于这对 $E$ 中的任何边都成立，所以集合 $V'$ 是 $G$ 的一个大小至多为 $k$ 的有效顶点覆盖。\n\n**错误选项分析：**\n\n- **选项A**：使用 $G$ 的邻接矩阵会将 VERTEX-COVER 映射到另一个不同的问题。在邻接矩阵中，如果存在边 $(v_i, v_j)$，则第 $i$ 行在第 $j$ 列处为1。选择 $k$ 个列来覆盖所有行，对应于找到一个大小为 $k$ 的顶点集，使得图中的每个顶点都与该集合中至少一个顶点相邻。这是 DOMINATING-SET 问题的定义，而不是 VERTEX-COVER。\n\n- **选项B**：这使用了正确的矩阵构造，但将预算设置为 $k' = n-k$。这是一种典型的转换，用于将一个问题归约到其补问题（例如 CLIQUE 归约到 INDEPENDENT-SET）。它不适用于这里，并且会导致错误的结果。例如，一个只有一条边的图需要一个大小为 $k=1$ 的顶点覆盖，但这将被映射为一个大小为 $n-1$ 的列覆盖，这通常是不等价的。\n\n- **选项C**：这交换了顶点和边的角色。矩阵是 $n \\times m$ 的，意味着行代表顶点，列代表边。选择 $k'$ 列意味着选择边。这种结构不能直接映射到 VERTEX-COVER 问题。它是正确构造的转置，选择 $k'$ 列（边）来覆盖所有行（顶点）意味着找到一个与每个顶点都相关联的边集，这是另一个不同的图问题。", "answer": "$$\\boxed{D}$$", "id": "1436236"}]}