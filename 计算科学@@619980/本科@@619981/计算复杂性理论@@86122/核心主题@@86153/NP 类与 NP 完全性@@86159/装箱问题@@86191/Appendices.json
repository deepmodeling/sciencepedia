{"hands_on_practices": [{"introduction": "装箱问题最直观的求解方法之一是采用贪心策略。首次适应（First-Fit）算法就是这样一个典型的例子，它遵循一个简单的规则：按顺序处理每个物品，并将其放入第一个有足够剩余空间的箱子中。这个练习将通过一个整理数字音乐播放列表的生动场景，帮助你一步步地演练首次适应算法的完整过程，从而牢固掌握其基本工作原理。[@problem_id:1449885]", "problem": "一个数字音乐服务商需要将一批新歌整理到一系列播放列表中。每个播放列表有严格的60分钟最长时长限制。该服务使用一种特定的自动化流程来将歌曲分配到播放列表中。歌曲按其标题的字母顺序逐一处理。对于每首歌曲，系统会尝试将其放入第一个有足够剩余容量的已创建播放列表（即播放列表1，然后是播放列表2，依此类推）。如果现有的播放列表都无法容纳该歌曲，则会为其创建一个新的播放列表。\n\n根据以下歌曲及其时长列表，确定存放所有歌曲所需的播放列表总数。\n\n- \"Ambient Awakening\": 18分钟\n- \"Blockchain Blues\": 25分钟\n- \"Cybernetic Serenade\": 38分钟\n- \"Data-driven Dream\": 15分钟\n- \"Echoes of Entropy\": 22分钟\n- \"Fractal Fantasy\": 12分钟\n- \"Glitch in the Grid\": 29分钟\n- \"Holomorphic Harmony\": 7分钟", "solution": "我们将此过程建模为首次适应（First-Fit）装箱问题，其中箱子的容量为 $C=60$。歌曲按照所列的字母顺序进行处理。设 $r_{i}$ 表示在每次放置后播放列表 $i$ 的剩余容量。\n\n1) “Ambient Awakening”，时长 $18$：\n- 尚无播放列表，创建播放列表 $1$。\n- 放入播放列表 $1$：$r_{1} = 60 - 18 = 42$。\n\n2) “Blockchain Blues”，时长 $25$：\n- 尝试播放列表 $1$：$25 \\leq r_{1}=42$，可以放入。\n- 更新：$r_{1} = 42 - 25 = 17$。\n\n3) “Cybernetic Serenade”，时长 $38$：\n- 尝试播放列表 $1$：$38 \\nleq 17$，无法放入。\n- 创建播放列表 $2$，并放入其中：$r_{2} = 60 - 38 = 22$。\n\n4) “Data-driven Dream”，时长 $15$：\n- 尝试播放列表 $1$：$15 \\leq r_{1}=17$，可以放入。\n- 更新：$r_{1} = 17 - 15 = 2$。\n\n5) “Echoes of Entropy”，时长 $22$：\n- 尝试播放列表 $1$：$22 \\nleq 2$，无法放入。\n- 尝试播放列表 $2$：$22 \\leq r_{2}=22$，正好可以放入。\n- 更新：$r_{2} = 22 - 22 = 0$。\n\n6) “Fractal Fantasy”，时长 $12$：\n- 尝试播放列表 $1$：$12 \\nleq 2$，无法放入。\n- 尝试播放列表 $2$：$12 \\nleq 0$，无法放入。\n- 创建播放列表 $3$，并放入其中：$r_{3} = 60 - 12 = 48$。\n\n7) “Glitch in the Grid”，时长 $29$：\n- 尝试播放列表 $1$：$29 \\nleq 2$，无法放入。\n- 尝试播放列表 $2$：$29 \\nleq 0$，无法放入。\n- 尝试播放列表 $3$：$29 \\leq r_{3}=48$，可以放入。\n- 更新：$r_{3} = 48 - 29 = 19$。\n\n8) “Holomorphic Harmony”，时长 $7$：\n- 尝试播放列表 $1$：$7 \\nleq 2$，无法放入。\n- 尝试播放列表 $2$：$7 \\nleq 0$，无法放入。\n- 尝试播放列表 $3$：$7 \\leq r_{3}=19$，可以放入。\n- 更新：$r_{3} = 19 - 7 = 12$。\n\n所有歌曲都被放入了播放列表 $1$至$3$。因此，所需的播放列表总数为 $3$个。", "answer": "$$\\boxed{3}$$", "id": "1449885"}, {"introduction": "首次适应算法并非唯一的贪心策略。另一个常见的启发式算法是最佳适应（Best-Fit）算法，它试图将物品放入能使其“fit”得最紧密的箱子中，以期为后续的大物品留出更多完整的空间。这个练习提供了一个精巧的实例，让你通过对比首次适应和最佳适应算法在同一组物品上的不同表现，来深入理解不同贪心策略之间的细微差别及其对最终结果的影响。[@problem_id:1449928]", "problem": "装箱问题是计算机科学中的一个经典挑战，其目标是将一组大小各异的物品装入最少数目的箱子中，每个箱子都有固定的容量。解决这个问题的两种常见在线近似算法是首次适应（First-Fit）和最佳适应（Best-Fit）。在线算法从给定的列表中逐个处理物品，而无需知道后续的物品。\n\n这些算法的定义如下：\n- **首次适应（FF）**：对于列表中的每个物品，将其放入第一个（即索引最小的）有足够剩余容量的箱子中。如果没有现有的箱子可以容纳该物品，则开启一个新箱子并将物品放入其中。\n- **最佳适应（BF）**：对于列表中的每个物品，将其放入具有最小足够剩余容量（即最紧密贴合）的箱子中。如果没有现有的箱子可以容纳该物品，则为其开启一个新箱子。如果出现多个箱子提供相同最佳匹配的平局情况，则将物品放入索引最小的那个箱子中。\n\n考虑一组相同的箱子，每个箱子的容量为 $C=10$。给定一个有序的物品列表，其大小如下：$L = (4, 8, 2, 4)$。\n\n令 $L_{FF}$ 为应用首次适应算法后，各箱子（从箱子1到最后一个开启的箱子）的最终剩余容量的有序列表。类似地，令 $L_{BF}$ 为应用最佳适应算法后，各箱子的最终剩余容量的有序列表。下列哪个陈述正确描述了 $L_{FF}$ 和 $L_{BF}$？\n\nA. $L_{FF} = (0, 2)$ 和 $L_{BF} = (2, 0)$\n\nB. $L_{FF} = (2, 0)$ 和 $L_{BF} = (0, 2)$\n\nC. $L_{FF} = (0, 2)$ 和 $L_{BF} = (0, 2)$\n\nD. $L_{FF} = (4, 2)$ 和 $L_{BF} = (2, 4)$\n\nE. 两种算法都导致开启了三个箱子。", "solution": "我们以箱子容量 $C=10$ 和物品列表 $L=(4,8,2,4)$ 来逐步模拟每种在线算法，并记录剩余容量。\n\n首次适应（FF）算法：\n1) 物品 $4$：尚无箱子，开启箱子1。剩余容量变为 $10-4=6$。状态：$(6)$。\n2) 物品 $8$：箱子1的剩余容量为 $6<8$，无法放入，因此开启箱子2。其剩余容量变为 $10-8=2$。状态：$(6,2)$。\n3) 物品 $2$：放入第一个能容纳它的箱子，即剩余容量为 $6$ 的箱子1。箱子1的新剩余容量为 $6-2=4$。状态：$(4,2)$。\n4) 物品 $4$：放入第一个能容纳它的箱子，即剩余容量为 $4$ 的箱子1。箱子1的新剩余容量为 $4-4=0$。最终状态：$(0,2)$。\n因此 $L_{FF}=(0,2)$。\n\n最佳适应（BF）算法：\n1) 物品 $4$：尚无箱子，开启箱子1。剩余容量变为 $10-4=6$。状态：$(6)$。\n2) 物品 $8$：箱子1的剩余容量为 $6<8$，无法放入，因此开启箱子2。其剩余容量变为 $10-8=2$。状态：$(6,2)$。\n3) 物品 $2$：在能容纳物品 $2$ 的箱子中，选择有最小足够剩余容量的那个。箱子2的剩余容量为 $2$，箱子1为 $6$，因此选择箱子2。箱子2的新剩余容量为 $2-2=0$。状态：$(6,0)$。\n4) 物品 $4$：在能容纳物品 $4$ 的箱子中，只有剩余容量为 $6$ 的箱子1符合条件。将其放入该箱子；新剩余容量为 $6-4=2$。最终状态：$(2,0)$。\n因此 $L_{BF}=(2,0)$。\n\n与选项比较，此结果与选项A匹配。", "answer": "$$\\boxed{A}$$", "id": "1449928"}, {"introduction": "贪心启发式算法虽然简单高效，但它们能保证得到最好的结果吗？这个练习旨在揭示贪心策略的内在局限性。通过一个精心设计的场景，你会发现，由于算法在每一步都只做出局部最优选择，最终使用的箱子总数可能多于理论上的最优解。通过计算启发式解法和最优解之间的差距，你将更深刻地体会到近似算法的性能评估为何如此重要。[@problem_id:1449894]", "problem": "一家物流公司使用标准集装箱管理货物运输，每个集装箱的标准化容量为1个单位。该公司需要运输两种特殊物品：“A类”物品，每件占据集装箱容量的 $2/3$；以及“B类”物品，每件占据集装箱容量的 $1/3$。\n\n在某一天，一个自动装载系统接收到一批特定顺序的待包装物品。首先，一批30件“B类”物品到达，随后是一批30件“A类”物品。该系统采用一种“首次适应”（First-Fit）贪心算法，按照物品到达的顺序进行包装。首次适应算法的工作原理如下：对于每件物品，它会尝试将其放入第一个（按开启顺序，从1号开始检查）有足够剩余容量的集装箱中。如果没有现成的集装箱能装下该物品，系统就会开启一个新的空集装箱，并将物品放入其中。\n\n一种最优装箱策略会通过可能地对物品重新排序，来达到所需集装箱数量的绝对最小值。\n\n计算对于给定序列，首次适应算法使用的集装箱数量与最优装箱所需的集装箱数量之间的差值。", "solution": "设 $B_{FF}$ 为首次适应算法使用的集装箱数量，$B_{OPT}$ 为最优装箱使用的集装箱数量。我们需要计算差值 $\\Delta B = B_{FF} - B_{OPT}$。\n\n**第一部分：计算首次适应算法使用的集装箱数量 ($B_{FF}$)**\n\n首次适应算法按给定的顺序处理物品：首先是30件“B类”物品（大小为 $1/3$），然后是30件“A类”物品（大小为 $2/3$）。\n\n**步骤1.1：包装30件“B类”物品。**\n每件“B类”物品的大小为 $1/3$。该算法将顺序填充集装箱。\n- 第一件“B类”物品进入1号集装箱。剩余容量：$1 - 1/3 = 2/3$。\n- 第二件“B类”物品也装入1号集装箱。剩余容量：$2/3 - 1/3 = 1/3$。\n- 第三件“B类”物品也装入1号集装箱。剩余容量：$1/3 - 1/3 = 0$。1号集装箱已满。\n- 第四件“B类”物品装不进1号集装箱，因此算法开启2号集装箱。\n这个模式会重复。每个集装箱正好可以装下三件“B类”物品 ($3 \\times 1/3 = 1$)。\n要包装30件“B类”物品，所需的集装箱数量为：\n$$N_{B} = \\frac{30 \\text{ items}}{3 \\text{ items/container}} = 10 \\text{ containers}$$\n因此，在第一阶段之后，我们有10个集装箱，且全部装满。\n\n**步骤1.2：包装30件“A类”物品。**\n现在，30件“A类”物品到达，每件大小为 $2/3$。\n首次适应算法会尝试将第一件“A类”物品放入现有的集装箱中，从1号集装箱开始。\n- 1号到10号集装箱都已完全装满（剩余容量为0）。一件“A类”物品（大小为 $2/3$）无法装入其中任何一个。\n- 因此，对于第一件“A类”物品，算法必须开启一个新的集装箱，即11号集装箱。\n- 第一件“A类”物品被放入11号集装箱。剩余容量：$1 - 2/3 = 1/3$。\n- 当第二件“A类”物品到达时，算法会检查现有的集装箱。1号到10号集装箱已满。11号集装箱只剩下 $1/3$ 的容量，这对于大小为 $2/3$ 的物品来说是不够的。\n- 因此，算法为第二件“A类”物品开启一个新的集装箱，即12号集装箱。\n这个逻辑适用于所有30件“A类”物品。每一件都需要一个自己的新集装箱，因为任意两件“A类”物品都无法装入同一个集装箱（$2 \\times 2/3 = 4/3 > 1$），并且装有一件“A类”物品的集装箱的剩余空间对于另一件来说太小了。\n为“A类”物品所需的新集装箱数量为30。\n$$N_{A} = 30 \\text{ containers}$$\n\n**步骤1.3：首次适应算法的总集装箱数。**\n首次适应算法使用的集装箱总数为两个阶段集装箱数量的总和。\n$$B_{FF} = N_{B} + N_{A} = 10 + 30 = 40$$\n\n**第二部分：计算最优装箱所需的集装箱数量 ($B_{OPT}$)**\n\n对于最优装箱，我们可以按任意顺序排列物品，以最小化所用集装箱的数量。包装这些物品最有效的方法是将一件“A类”物品和一件“B类”物品组合到单个集装箱中。\n一件“A类”和一件“B类”物品的总大小为：\n$$\\text{Size} = \\frac{2}{3} + \\frac{1}{3} = 1$$\n这个组合能完美地装满一个集装箱。我们有30件“A类”物品和30件“B类”物品。因此我们可以组成30个这样的配对。\n每个配对将正好装满一个集装箱。因此，所需的最小集装箱数量为30。\n$$B_{OPT} = 30$$\n\n**第三部分：计算差值**\n\n首次适应算法使用的集装箱数量与最优数量之间的差值为：\n$$\\Delta B = B_{FF} - B_{OPT} = 40 - 30 = 10$$", "answer": "$$\\boxed{10}$$", "id": "1449894"}]}