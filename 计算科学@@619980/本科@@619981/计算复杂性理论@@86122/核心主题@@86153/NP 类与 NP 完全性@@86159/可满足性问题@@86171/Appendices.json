{"hands_on_practices": [{"introduction": "大多数现代SAT求解器都要求输入为一种称为合取范式（CNF）的标准格式。这意味着我们需要一种可靠的方法，将任意逻辑语句转换为CNF。本练习将介绍Tseitin变换背后的核心思想，这是实现该转换的一项基石技术。通过转换一个代表AND门的基础逻辑等价式，你将练习应用逻辑定律以达到所需格式的系统性步骤[@problem_id:1462173]。", "problem": "在计算逻辑中，将任意逻辑公式转换为标准化格式是许多算法（特别是那些为解决布尔可满足性问题而设计的算法）的关键第一步。最常见的标准格式之一是合取范式（Conjunctive Normal Form, CNF）。\n\n如果一个公式是单个或多个子句的合取（AND，用 $\\land$ 表示），那么它就处于CNF。其中，子句是单个或多个文字的析取（OR，用 $\\lor$ 表示）。文字是一个变量（例如，$x$）或其否定（例如，$\\neg x$）。\n\n考虑逻辑等价陈述 $z \\leftrightarrow (x \\land y)$。在将复杂的逻辑电路编码为适合基于CNF的求解器的格式时，这种类型的陈述是一个基本的构建块。你的任务是将此陈述转换为一组逻辑等价的子句。\n\n下列哪组子句在逻辑上等价于表达式 $z \\leftrightarrow (x \\land y)$？\n\nA. $\\{ (\\neg x \\lor z), (\\neg y \\lor z), (\\neg z \\lor x \\lor y) \\}$\nB. $\\{ (\\neg x \\lor \\neg y \\lor z), (\\neg z \\lor x), (\\neg z \\lor y) \\}$\nC. $\\{ (x \\lor y \\lor \\neg z), (z \\lor \\neg x), (z \\lor \\neg y) \\}$\nD. $\\{ (\\neg x \\lor z), (\\neg y \\lor z), (\\neg z \\lor x), (\\neg z \\lor y) \\}$\nE. $\\{ (\\neg x \\lor \\neg y \\lor z) \\}$", "solution": "目标是将逻辑表达式 $z \\leftrightarrow (x \\land y)$ 转换为等价的合取范式（CNF）。这涉及将表达式转换为子句的合取，其中每个子句是文字的析取。\n\n第一步：展开双条件。\n双条件运算符 $A \\leftrightarrow B$ 在逻辑上等价于 $(A \\rightarrow B) \\land (B \\rightarrow A)$。\n将此应用于我们的表达式，得到：\n$$ (z \\rightarrow (x \\land y)) \\land ((x \\land y) \\rightarrow z) $$\n\n第二步：将蕴含转换为析取。\n蕴含运算符 $A \\rightarrow B$ 在逻辑上等价于 $\\neg A \\lor B$。我们将此规则应用于我们表达式的两个部分。\n对于第一部分 $(z \\rightarrow (x \\land y))$，我们得到：\n$$ \\neg z \\lor (x \\land y) $$\n对于第二部分 $((x \\land y) \\rightarrow z)$，我们得到：\n$$ \\neg(x \\land y) \\lor z $$\n将它们结合起来，完整的表达式现在是：\n$$ (\\neg z \\lor (x \\land y)) \\land (\\neg(x \\land y) \\lor z) $$\n\n第三步：应用德摩根定律。\n该表达式是两项的合取。让我们分析每一项以确保其为子句形式（文字的析取）。\n第二项 $\\neg(x \\land y) \\lor z$ 包含一个作用于合取式的否定。我们使用德摩根定律，该定律指出 $\\neg(A \\land B) \\equiv (\\neg A \\lor \\neg B)$。\n应用该定律，第二项变为：\n$$ (\\neg x \\lor \\neg y) \\lor z $$\n由于 $\\lor$ 运算符满足结合律，我们可以将其写为单个子句：\n$$ (\\neg x \\lor \\neg y \\lor z) $$\n\n第四步：应用分配律。\n第一项 $\\neg z \\lor (x \\land y)$ 在一个析取式中包含一个合取式。这不是一个有效的子句。我们必须使用分配律，该定律指出 $A \\lor (B \\land C) \\equiv (A \\lor B) \\land (A \\lor C)$。\n令 $A = \\neg z$，$B = x$，$C = y$。应用该定律，第一项变为：\n$$ (\\neg z \\lor x) \\land (\\neg z \\lor y) $$\n这个表达式是两个有效子句 $(\\neg z \\lor x)$ 和 $(\\neg z \\lor y)$ 的合取。\n\n第五步：合并结果。\n现在，我们将转换后的形式代回到第二步的主表达式中。\n原始表达式等价于：\n$$ ((\\neg z \\lor x) \\land (\\neg z \\lor y)) \\land (\\neg x \\lor \\neg y \\lor z) $$\n这是一个由三个子句组成的合取式。因此，子句集合是：\n$$ \\{ (\\neg z \\lor x), (\\neg z \\lor y), (\\neg x \\lor \\neg y \\lor z) \\} $$\n\n第六步：与给定选项进行匹配。\n我们将我们得到的子句集合与所提供的选项进行比较。集合 $\\{ (\\neg z \\lor x), (\\neg z \\lor y), (\\neg x \\lor \\neg y \\lor z) \\}$ 与选项B匹配，需要注意的是，集合中子句的顺序和子句中文字的顺序无关紧要。\n\n因此，正确选项是B。", "answer": "$$\\boxed{B}$$", "id": "1462173"}, {"introduction": "SAT问题的威力不仅在于其理论深度，还在于其为各种实际问题建模和求解的能力。从调度到电路验证，第一步总是将问题的约束条件转化为布尔公式。本练习将引导你将一个简单且贴近生活的场景——大学课程注册——建模为一个2-SAT实例[@problem_id:1462201]。你将学习如何将人类可读的规则转换为精确的2-CNF子句及其对应的蕴含关系，这是高效求解2-SAT问题的关键。", "problem": "一所大学正在设计一个自动化的课程注册系统。为确保学生满足先修课程要求并避免冲突，该系统必须满足一组逻辑约束。对于某位特定学生，设布尔变量 $A$、$B$ 和 $C$ 分别表示是否注册了“高级算法”(Advanced Algorithms)、“生物信息学”(Bioinformatics)和“编译器”(Compilers)课程。如果学生注册了某门课程，则其对应的变量为真，否则为假。注册约束条件如下：\n\n1.  由于时间冲突，学生不能在同一学期同时注册“高级算法”和“生物信息学”。\n2.  如果学生注册“高级算法”，则必须同时注册“编译器”作为并修课程。\n3.  学生必须在“生物信息学”和“编译器”中至少注册一门。\n\n这些约束可以被建模为一个 2-可满足性 (2-SAT) 问题。在一个 2-SAT 问题中，每个形如 $(L_1 \\lor L_2)$ 的逻辑子句（其中 $L_1$ 和 $L_2$ 是文字，即一个变量或其否定形式）都等价于一对蕴含式：$(\\neg L_1 \\implies L_2)$ 和 $(\\neg L_2 \\implies L_1)$。由一个公式中所有子句派生出的所有这类蕴含式集合，可用于构建一个蕴含图。\n\n下列哪组蕴含式集合正确且完整地表示了给定的注册约束？\n\nA. { $A \\implies \\neg B$, $B \\implies \\neg A$, $A \\implies C$, $\\neg C \\implies \\neg A$, $\\neg B \\implies C$, $\\neg C \\implies B$ }\nB. { $A \\implies \\neg B$, $A \\implies C$, $\\neg B \\implies C$ }\nC. { $\\neg A \\implies B$, $\\neg B \\implies A$, $\\neg A \\implies C$, $C \\implies A$, $B \\implies C$, $C \\implies B$ }\nD. { $\\neg B \\implies A$, $\\neg A \\implies B$, $C \\implies A$, $\\neg A \\implies \\neg C$, $C \\implies \\neg B$, $B \\implies \\neg C$ }", "solution": "我们定义布尔变量 $A$、$B$ 和 $C$ 分别表示注册“高级算法”、“生物信息学”和“编译器”课程。我们将每个约束转换为一个 2-CNF 子句，然后使用 2-SAT 规则，即 $(L_{1} \\lor L_{2})$ 等价于 $(\\neg L_{1} \\implies L_{2})$ 和 $(\\neg L_{2} \\implies L_{1})$，将其转换为蕴含式。\n\n约束 1：学生不能同时注册 $A$ 和 $B$。这表示为 $\\neg(A \\land B)$，根据德摩根定律 (De Morgan's law) 等价于 $(\\neg A \\lor \\neg B)$。令 $L_{1}=\\neg A$ 且 $L_{2}=\\neg B$。其蕴含式为：\n$$\\neg(\\neg A) \\implies \\neg B \\;\\;\\Longleftrightarrow\\;\\; A \\implies \\neg B,$$\n$$\\neg(\\neg B) \\implies \\neg A \\;\\;\\Longleftrightarrow\\;\\; B \\implies \\neg A.$$\n\n约束 2：若注册 $A$ 则必注册 $C$，即 $A \\implies C$，这等价于 $(\\neg A \\lor C)$。令 $L_{1}=\\neg A$ 且 $L_{2}=C$。其蕴含式为：\n$$\\neg(\\neg A) \\implies C \\;\\;\\Longleftrightarrow\\;\\; A \\implies C,$$\n$$\\neg C \\implies \\neg A.$$\n\n约束 3：至少注册 $B$ 或 $C$ 之一：$(B \\lor C)$。令 $L_{1}=B$ 且 $L_{2}=C$。其蕴含式为：\n$$\\neg B \\implies C,$$\n$$\\neg C \\implies B.$$\n\n收集所有蕴含式，得到集合\n$$\\{\\,A \\implies \\neg B,\\; B \\implies \\neg A,\\; A \\implies C,\\; \\neg C \\implies \\neg A,\\; \\neg B \\implies C,\\; \\neg C \\implies B\\,\\},$$\n该集合与选项 A 完全匹配。选项 B 遗漏了必要的逆否蕴含式，因此不完整。选项 C 对应于 $(A \\lor B)$、$(A \\lor C)$ 和 $(\\neg B \\lor \\neg C)$，它们并不代表原始约束。同理，选项 D 也不匹配所需的子句，并引入了与约束不一致的蕴含式。", "answer": "$$\\boxed{A}$$", "id": "1462201"}, {"introduction": "一旦问题被建模为SAT实例，我们如何找到一个解？对于大规模问题，我们常常求助于像局部搜索这样的启发式算法。然而，这些方法并非万无一失。本练习将探讨优化和搜索算法中的一个经典挑战：局部最优。你将分析一个场景，其中一个简单的贪心算法“卡”在一个部分解上，无法找到真正的全局解，因为任何微小的改动都无法带来严格的改善[@problem_id:1462193]。理解这一现象对于领会为什么求解SAT问题是计算困难的（NP完全问题），以及为什么需要更复杂的算法（包含逃离局部最优的机制）至关重要。", "problem": "一个布尔公式，如果它是一个或多个子句的合取（AND，用 $\\land$ 表示），其中每个子句是文字的析取（OR，用 $\\lor$ 表示），则该公式处于合取范式（CNF）中。一个文字是一个布尔变量或其否定。一个 3-SAT 实例是一个 3-CNF 形式的布尔公式，其中每个子句在变量集 $\\{x_1, x_2, \\dots, x_n\\}$ 上都恰好包含三个文字。一个赋值是将每个变量映射到 $\\{\\text{true}, \\text{false}\\}$ 中一个值的映射。如果一个赋值使公式的求值结果为真，则该赋值满足该公式。如果存在至少一个满足赋值，则一个 3-SAT 实例是可满足的。\n\n考虑一个我们称之为“贪婪单翻转爬山”（Greedy Single-Flip Ascent）的贪婪局部搜索算法，该算法旨在为 3-SAT 实例找到一个满足赋值。该算法按以下步骤进行：\n1.  从一个给定的变量真值初始赋值开始。\n2.  在每一步，计算被满足子句的数量。然后，考虑通过翻转单个变量的值可以达到的所有可能的新赋值。\n3.  如果任何单次翻转导致被满足子句的数量严格增加，则选择导致最大增量的翻转。如果存在平局，可以选择任何一个最佳翻转。然后算法移至这个新赋值，并从步骤2重复。\n4.  如果没有单次翻转可以增加被满足子句的数量，算法终止。终止时的赋值被称为局部最优。\n\n一个全局最优是满足公式所有子句的赋值。你的任务是确定一个场景，在该场景中，“贪婪单翻转爬山”算法陷入一个非全局最优的局部最优。\n\n以下哪个选项正确地指定了一个元组 $(\\phi, A_{start}, A_{local})$，其中 $\\phi$ 是一个在三个变量 $\\{x_1, x_2, x_3\\}$ 上的可满足的 3-SAT 实例，$A_{start}$ 是一个初始赋值，$A_{local}$ 是算法陷入的一个局部最优，且 $A_{local}$ 不是一个全局最优？我们将 $(x_1, x_2, x_3)$ 的赋值表示为一个3位字符串，其中第 $i$ 位为1表示true，为0表示false。\n\nA. $\\phi = \\{ (x_1 \\lor x_1 \\lor x_2), (\\neg x_1 \\lor \\neg x_1 \\lor \\neg x_1), (\\neg x_2 \\lor \\neg x_2 \\lor \\neg x_3) \\}$, $A_{start} = 000$, $A_{local} = 000$\nB. $\\phi = \\{ (x_1 \\lor x_2 \\lor \\neg x_3), (x_1 \\lor \\neg x_2 \\lor x_3), (\\neg x_1 \\lor x_2 \\lor x_3) \\}$, $A_{start} = 000$, $A_{local} = 000$\nC. $\\phi = \\{ (x_1 \\lor x_2 \\lor x_3), (\\neg x_1 \\lor x_2 \\lor x_3), (x_1 \\lor \\neg x_2 \\lor x_3), (x_1 \\lor x_2 \\lor \\neg x_3) \\}$, $A_{start} = 000$, $A_{local} = 000$\nD. $\\phi = \\{ (x_1 \\lor x_2 \\lor x_3), (\\neg x_1 \\lor x_2 \\lor x_3), (x_1 \\lor \\neg x_2 \\lor x_3), (x_1 \\lor x_2 \\lor \\neg x_3) \\}$, $A_{start} = 100$, $A_{local} = 100$", "solution": "我们必须找到一个选项，其中给定的公式 $\\phi$ 是可满足的，算法从 $A_{start}$ 开始到达一个局部最优 $A_{local}$，在该局部最优中，没有单变量翻转能增加被满足子句的数量，并且 $A_{local}$ 不是一个全局最优（即，它不满足所有子句）。\n\n分析选项A：$\\phi=\\{(x_{1}\\lor x_{1}\\lor x_{2}),(\\neg x_{1}\\lor \\neg x_{1}\\lor \\neg x_{1}),(\\neg x_{2}\\lor \\neg x_{2}\\lor \\neg x_{3})\\}$, $A_{start}=000$, $A_{local}=000$。\n简化子句：$(x_{1}\\lor x_{2})$, $\\neg x_{1}$, $(\\neg x_{2}\\lor \\neg x_{3})$。该实例是不可满足的，因为要满足 $\\neg x_1$ 和 $(x_1 \\lor x_2)$，必须有 $x_1=0$ 和 $x_2=1$。要满足 $(\\neg x_2 \\lor \\neg x_3)$，必须有 $x_2=0$ 或 $x_3=0$。因此 $x_2=1$ 和 $x_2=0$ 矛盾。但问题要求实例是可满足的。让我们重新检查。等等，问题文本中没有简化子句，所以我们应该使用原始的。\n$\\phi = \\{ (x_1 \\lor x_1 \\lor x_2), (\\neg x_1 \\lor \\neg x_1 \\lor \\neg x_1), (\\neg x_2 \\lor \\neg x_2 \\lor \\neg x_3) \\}$。这些不是3-SAT子句。第一个和第三个子句只有2个独特的文字，第二个只有一个。然而，题目定义3-SAT每个子句**恰好**包含三个文字。这里存在不一致，但我们按字面意思分析。简化后：$\\{ (x_1 \\lor x_2), (\\neg x_1), (\\neg x_2 \\lor \\neg x_3) \\}$。要满足这个公式，我们需要 $x_1=0$。那么第一个子句要求 $x_2=1$。第三个子句要求 $x_2=0$ 或 $x_3=0$。由于 $x_2$ 必须为1，这要求 $x_3=0$。所以赋值 $(0,1,0)$ 满足所有子句。该公式是可满足的。\n在 $000$ 处求值：$(0 \\lor 0 \\lor 0) \\equiv (0 \\lor 0)$ is F. $(\\neg 0 \\lor \\neg 0 \\lor \\neg 0) \\equiv (\\neg 0)$ is T. $(\\neg 0 \\lor \\neg 0 \\lor \\neg 0) \\equiv (\\neg 0 \\lor \\neg 0)$ is T. 满足2个子句。\n翻转 $x_2$ 到 $010$：$(0 \\lor 1 \\lor 0)$ is T. $(\\neg 0)$ is T. $(\\neg 1 \\lor \\neg 0)$ is T. 满足3个子句。\n数量从2增加到3。因此 $000$ 不是局部最优。A是无效的。我的原始解决方案文本是不同的。让我们使用原始文本的分析。\n(原始文本分析)\n分析选项A：$\\phi=\\{(x_{1}\\lor x_{1}\\lor x_{2}),(\\neg x_{1}\\lor \\neg x_{1}\\lor \\neg x_{1}),(\\neg x_{2}\\lor \\neg x_{2}\\lor \\neg x_{3})\\}$, $A_{start}=000$, $A_{local}=000$。\n简化子句：$(x_{1}\\lor x_{2})$, $\\neg x_{1}$, $(\\neg x_{2}\\lor \\neg x_{3})$。该实例是可满足的，例如，$010$ 满足全部三个子句。在 $000$ 处求值：被满足的子句数量为 $2$。考虑从 $000$ 进行单次翻转：翻转 $x_{2}$ 得到 $010$，它满足 $3$ 个子句。因此存在一个严格改进的翻转，所以 $000$ 不是一个局部最优。因此A是无效的。 (这个分析是正确的，但我之前在草稿中误判了可满足性。我将保持这个正确的分析，但原始文件中的解决方案部分可能更简洁，让我们检查它。原始方案说 `010` 满足 3 个子句，而 `000` 满足 2 个，所以 000 不是局部最优。这是对的。)\n\n分析选项B：$\\phi=\\{(x_{1}\\lor x_{2}\\lor \\neg x_{3}),(x_{1}\\lor \\neg x_{2}\\lor x_{3}),(\\neg x_{1}\\lor x_{2}\\lor x_{3})\\}$, $A_{start}=000$, $A_{local}=000$。\n在 $000$ 处，每个子句的求值结果都为真：$(0\\lor 0\\lor 1)$, $(0\\lor 1\\lor 0)$, $(1\\lor 0\\lor 0)$，因此所有 $3$ 个子句都被满足。所以 $000$ 是一个全局最优，这与 $A_{local}$ 不是全局最优的要求相矛盾。因此B是无效的。\n\n分析选项C：$\\phi=\\{(x_{1}\\lor x_{2}\\lor x_{3}),(\\neg x_{1}\\lor x_{2}\\lor x_{3}),(x_{1}\\lor \\neg x_{2}\\lor x_{3}),(x_{1}\\lor x_{2}\\lor \\neg x_{3})\\}$, $A_{start}=000$, $A_{local}=000$。\n首先，$\\phi$ 是可满足的；例如，$111$ 满足所有四个子句。在 $000$ 处求值：第一个子句 $(x_{1}\\lor x_{2}\\lor x_{3})$ 为假，而其他三个子句 $(\\neg x_{1}\\lor x_{2}\\lor x_{3})$、$(x_{1}\\lor \\neg x_{2}\\lor x_{3})$ 和 $(x_{1}\\lor x_{2}\\lor \\neg x_{3})$ 为真，所以恰好有 $3$ 个子句被满足。检查所有单次翻转：\n- 翻转 $x_{1}$ 到 $100$：满足的子句数为 $3$ (第二个子句变为假，其他三个为真)。\n- 翻转 $x_{2}$ 到 $010$：满足的子句数为 $3$ (第三个子句变为假，其他三个为真)。\n- 翻转 $x_{3}$ 到 $001$：满足的子句数为 $3$ (第四个子句变为假，其他三个为真)。\n没有单次翻转能使满足的子句数超过 $3$，所以 $000$ 是一个局部最优。因为它不满足所有子句，所以它不是一个全局最优。从 $A_{start}=000$ 开始，算法立即在这个局部最优处终止。因此C满足所有要求。\n\n分析选项D：与C中相同的 $\\phi$，$A_{start}=100$，$A_{local}=100$。\n在 $100$ 处，有 $3$ 个子句被满足。将 $x_{2}$ 翻转到 $110$ 会使得所有 $4$ 个子句都被满足，这严格增加了数量。因此 $100$ 不是一个局部最优，所以D是无效的。\n\n因此，正确选项是C。", "answer": "$$\\boxed{C}$$", "id": "1462193"}]}