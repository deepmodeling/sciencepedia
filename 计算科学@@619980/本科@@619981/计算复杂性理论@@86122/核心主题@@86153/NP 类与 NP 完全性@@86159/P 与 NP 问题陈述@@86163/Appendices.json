{"hands_on_practices": [{"introduction": "许多现实世界中的挑战，例如寻找最短路径，都属于优化问题。为了在 $P$ 与 $NP$ 问题的背景下分析它们的计算难度，我们首先必须将它们改写为“是/否”形式的判定问题。本练习将挑战你为著名的旅行商问题（Traveling Salesperson Problem）完成这种转换，并确定构成一个“是”答案的有效“证明”（即证书）是什么。", "problem": "一家科技公司正在为一支自动配送无人机队设计一个复杂的调度系统。这些无人机必须访问一组 $n$ 个不同的配送地点。该系统可以获取任意两个地点 $u$ 和 $v$ 之间的精确旅行时间 $t(u, v)$。一个关键的挑战是找到一条最优路径，以最小化总旅行时间。这是著名的旅行商问题 (TSP) 的一个变体。\n\n在计算复杂性理论中，为了对 TSP 这类问题的难度进行分类，我们通常将它们从*优化问题*（要求找到最佳解）转换为*判定问题*（答案为“是”或“否”）。如果一个问题的判定版本的任何“是”实例都可以被高效地验证，那么该问题就属于 NP 类（非确定性多项式时间）。这个验证过程包括在相对于问题输入大小的多项式时间内，检查一个被称为*证书*或*见证*的提议解。\n\n考虑无人机路径规划问题的判定版本。输入包括 $n$ 个地点、所有旅行时间 $t(u, v)$ 的集合，以及一个最大允许总行程时间 $K$。问题是在此时间限制内是否可以完成一个有效的行程。\n\n以下哪个选项正确地指出了这个问题的形式化判定问题以及一个允许在多项式时间内验证“是”答案的有效证书？\n\nA. **判定问题：** 是否存在一条访问每个地点恰好一次并返回起点的行程，其总旅行时间至多为 $K$？ **证书：** 行程总旅行时间的数值。\n\nB. **判定问题：** 访问每个地点恰好一次并返回起点的行程，其可能的最短旅行时间是多少？ **证书：** 一个由 $n$ 个地点组成的构成完整行程的特定有序序列。\n\nC. **判定问题：** 是否存在一条访问每个地点恰好一次并返回起点的行程，其总旅行时间至多为 $K$？ **证书：** 用于找到该行程的计算机算法的描述。\n\nD. **判定问题：** 是否存在一条访问每个地点恰好一次并返回起点的行程，其总旅行时间至多为 $K$？ **证书：** 一个由 $n$ 个地点组成的构成完整行程的特定有序序列（例如，地点1 -> 地点5 -> ... -> 地点1）。", "solution": "要解决这个问题，我们必须正确识别两个组成部分：旅行商问题 (TSP) 的判定版本和一个“是”实例的有效证书。\n\n首先，我们来分析判定问题的表述。计算复杂性理论，特别是对 NP 类的研究，关注的是判定问题，即答案为“是”或“否”的问题。原始的 TSP 是一个优化问题：它问的是“一次行程的*最小*总距离/时间是多少？”为了将其转换为判定问题，我们引入一个阈值，在问题描述中以 $K$ 给出。相应的判定问题不是要找到最小值，而是要确定是否存在一个满足特定标准的解。因此，正确的判定问题是：“是否存在一条访问每个地点恰好一次并返回起点的行程，其总旅行时间至多为 $K$？”\n\n我们来检查一下选项中提出的判定问题：\n- 选项 B 问的是，“可能的最短旅行时间是多少...？”这是问题的优化版本，而不是判定版本。因此，选项 B 是不正确的。\n- 选项 A、C 和 D 都提出了正确的判定问题：“是否存在一条...总旅行时间至多为 $K$ 的行程？”所以，我们现在必须评估这些选项中提议的证书。\n\n其次，我们来分析证书的概念。对于一个在 NP 类中的问题，其“是”答案必须能在多项式时间内被验证。这意味着如果有人声称答案是“是”，他们必须提供一份证据（即证书），让我们能够快速确认他们的主张。证书本身不是找到解的方法，而是解本身或其一种表示。验证者是一个算法，它接收问题实例（地点、时间、$K$）和证书作为输入，并在多项式时间内确认该证书是否能证明这是一个“是”实例。\n\n让我们评估剩余选项（A、C 和 D）的证书：\n- **选项 A 证书：** “行程总旅行时间的数值。”\n假设证书是数字 `120.5`。要验证这一点，我们需要确认一个总时间为 `120.5`（小于等于 $K$）的行程确实存在。但仅仅有这个数字对我们没有帮助。我们仍然需要搜索具有该特定总时间的行程，这和原问题一样困难。证书必须使验证变得容易。因此，仅一个数值不是一个有效的证书。这排除了选项 A。\n\n- **选项 C 证书：** “用于找到该行程的计算机算法的描述。”\n证书是代表解的一份数据，而不是用于找到解的过程。验证一个算法是否正确并且确实能找到这样的行程是一个复杂得多的问题（与程序验证相关），这并不是复杂性理论中证书验证的含义。验证者的任务是检查一个给定的解，而不是一个给定的求解方法。因此，这不是一个有效的证书。这排除了选项 C。\n\n- **选项 D 证书：** “一个由 $n$ 个地点组成的构成完整行程的特定有序序列（例如，地点1 -> 地点5 -> ... -> 地点1）。”\n这是一个有效的证书。我们来看看验证者如何使用它。给定一个由 $n$ 个地点组成的序列，验证者可以在多项式时间内执行以下步骤：\n1.  检查该序列是否是所有 $n$ 个地点的一个排列（即，它恰好访问了每个地点一次）。这可以通过排序或使用哈希表来完成，时间复杂度与 $n \\log n$ 或 $n$ 成正比。\n2.  计算由该序列定义的行程的总旅行时间。这涉及到对行程中 $n$ 段路程的 $n$ 个旅行时间求和（例如，$t(L_1, L_2) + t(L_2, L_3) + \\dots + t(L_n, L_1)$）。这是一个简单的 $n$ 个数字的求和，属于线性时间操作，时间复杂度为 $O(n)$。\n3.  将计算出的总时间与阈值 $K$ 进行比较。这是一个单一的比较，属于常数时间操作，时间复杂度为 $O(1)$。\n由于所有验证步骤都可以在多项式时间内执行（实际上，相对于地点数量 $n$ 是线性时间），所以这个序列是一个有效的证书。\n\n选项 D 中的判定问题和证书都是正确的。", "answer": "$$\\boxed{D}$$", "id": "1460208"}, {"introduction": "我们不会从零开始分析每一个问题，而是使用一种叫做多项式时间归约的强大工具，将新问题与已知问题联系起来。本练习探讨了归约的一个基本属性：如果问题 $A$ 可以高效地转化为问题 $B$，而已知问题 $B$ 是“容易的”（属于 $P$ 类），这能告诉我们关于问题 $A$ 难度的什么信息？理解这个逻辑是掌握计算复杂性理论版图的关键。", "problem": "在计算复杂性理论中，我们根据解决问题所需的资源对问题进行分类。P类包含所有可以由确定性图灵机在多项式时间内解决的判定问题。如果存在一个多项式时间算法，可以将问题A的任何实例转换为问题B的一个实例，使得当且仅当问题B的转换后实例的答案为“是”时，问题A的原始实例的答案也为“是”，那么我们称问题A可多项式归约到问题B，记为 $A \\le_p B$。\n\n假设给定两个判定问题，问题A和问题B。您已知以下两个事实：\n1. 问题B属于复杂性类P。\n2. 问题A可多项式归约到问题B ($A \\le_p B$)。\n\n仅根据这些信息，关于问题A的复杂性，您能得出的最精确的结论是什么？\n\nA. 问题A属于P。\n\nB. 问题A是NP完全的。\n\nC. 问题A属于NP，但无法确定其是否属于P。\n\nD. 问题A必须至少与问题B一样难。\n\nE. 无法对问题A的复杂性得出任何有意义的结论。", "solution": "我们已知问题B属于P，并且问题A可多项式时间归约到问题B，记为 $A \\le_{p} B$。根据多项式时间多对一归约的定义，存在一个函数 $f$，使得对于每个输入 $x$，\n$$x \\in A \\iff f(x) \\in B,$$\n并且 $f$ 可由一个确定性图灵机在输入大小的多项式时间内计算。具体来说，存在一个多项式 $p$，使得计算 $f$ 的时间至多为 $p(|x|)$。此外，输出的大小也受多项式限制，即存在一个多项式 $s$ 使得\n$$|f(x)| \\leq s(|x|) \\quad \\text{for all } x.$$\n\n因为B属于P，所以存在一个确定性图灵机 $M_{B}$，它能在输入大小的多项式时间内判定B。也就是说，存在一个多项式 $q$，使得对于任何输入 $y$，\n$$T_{B}(|y|) \\leq q(|y|).$$\n\n我们可以构造一个判定A的确定性算法如下：对于输入 $x$，计算 $y = f(x)$，然后对输入 $y$ 运行 $M_{B}$ 并输出其判定结果。算法的正确性源于归约性质 $x \\in A \\iff f(x) \\in B$。\n\n对于大小为 $|x| = n$ 的输入 $x$，总运行时间 $T_{A}(n)$ 的上界是计算 $f(x)$ 的时间加上在 $y=f(x)$ 上判定B的时间：\n$$T_{A}(n) \\leq p(n) + q(|f(x)|).$$\n使用大小界限 $|f(x)| \\leq s(n)$，我们得到\n$$T_{A}(n) \\leq p(n) + q(s(n)).$$\n由于 $p$、$q$ 和 $s$ 都是多项式，复合函数 $q \\circ s$ 是一个多项式，而多项式的和也是一个多项式。因此，存在一个多项式 $t$ 使得\n$$T_{A}(n) \\leq t(n),$$\n这表明A可以在多项式时间内被判定；也就是说，$A \\in \\text{P}$。\n\n因此，最精确的结论是问题A属于P。声称问题A是NP完全的、仅仅属于NP、或A至少和B一样难的选项都没有依据；实际上，$A \\le_{p} B$ 表明A的难度不高于B。", "answer": "$$\\boxed{A}$$", "id": "1460220"}, {"introduction": "$NP$ 类关注的是判定问题，但我们通常希望找到一个实际的解，而不仅仅是知道解是否存在。这个思想实验将展示许多 $NP$ 问题中判定问题与搜索问题之间的深刻联系，这一特性被称为自归约性。通过假设你拥有一个能解决 3-SAT 判定问题的“魔法盒子”，你将设计一个策略来找出一个满足条件的赋值，从而揭示解决判定问题如何能帮助我们解决搜索问题。", "problem": "一位计算机科学家正在设计一种算法，用于为可满足的布尔公式寻找一个有效的变量赋值。该算法可以访问一个专用的硬件预言机。这个预言机可以解决3-可满足性（3-SAT）判定问题。\n\n以下是形式化定义：\n- 一个**3-合取范式（3-CNF）**公式是一个布尔公式，它是一些子句的合取（AND），其中每个子句是恰好三个不同文字的析取（OR）。一个文字是一个变量或其否定。\n- 就本问题而言，**预言机**是一个名为`IS_SATISFIABLE(F)`的黑盒机器。它接受任何3-CNF公式`F`作为输入，如果`F`是可满足的（即，至少存在一个变量赋值使公式为真），则立即返回`True`，否则返回`False`。每次对`IS_SATISFIABLE(F)`的调用都算作一次“查询”。\n\n这位科学家提出的算法`FIND_ASSIGNMENT`，对于一个给定的、具有$n$个变量（表示为$x_1, x_2, \\dots, x_n$）的3-CNF公式$\\phi$，其工作流程如下：\n\n1.  初始化一个工作公式 $\\phi_{current} = \\phi$。\n2.  对于 $i$ 从 $1$ 到 $n$：\n    a. 通过在$\\phi_{current}$中用`True`替换变量$x_i$来创建一个临时公式$\\phi_{true}$。这可以通过将所有出现的文字$x_i$替换为`True`，将文字$\\neg x_i$替换为`False`，并简化公式来完成。\n    b. 用这个临时公式查询预言机：`IS_SATISFIABLE($\\phi_{true}$)`.\n    c. 如果预言机返回`True`，这意味着存在一个满足条件的赋值，其中$x_i$为真。算法通过更新工作公式来确定这个选择：$\\phi_{current} \\leftarrow \\phi_{true}$。\n    d. 如果预言机返回`False`，这意味着要使原始公式$\\phi$可满足，$x_i$ *必须* 为`False`。然后，算法在*步骤2a之前*的$\\phi_{current}$版本中用`False`替换$x_i$，创建一个新的临时公式$\\phi_{false}$。然后查询预言机：`IS_SATISFIABLE($\\phi_{false}$)`.\n        i. 如果这次查询返回`True`，算法通过更新工作公式来确定$x_i = \\text{False}$：$\\phi_{current} \\leftarrow \\phi_{false}$。\n        ii. 如果这次查询也返回`False`，这意味着没有任何赋值可以满足该公式，因此原始公式$\\phi$必定是不可满足的。算法终止并报告失败。\n3.  如果循环完成，则已找到一个完整的满足赋值。\n\n对于任何具有$n$个变量的3-CNF公式，`FIND_ASSIGNMENT`算法为找到一个满足赋值或确定不存在赋值而向预言机进行查询的最大次数是多少？\n\nA. $n$\n\nB. $n+1$\n\nC. $2n$\n\nD. $n^2$\n\nE. $2^n$\n\nF. $2n+1$", "solution": "设 $\\phi$ 是一个具有 $n$ 个变量的 3-CNF 公式，且预言机是一个用于可满足性判定的决策过程。在循环的第 $i$ 次迭代中，算法通过在当前公式中设置 $x_i=\\text{True}$ 来构造 $\\phi_{\\text{true}}$，并进行一次查询。如果预言机返回 True，算法则确定 $x_i=\\text{True}$ 并继续，因此第 $i$ 次迭代恰好使用一次查询。如果预言机返回 False，算法通过（在步骤前的公式中）设置 $x_i=\\text{False}$ 来构造 $\\phi_{\\text{false}}$，并进行第二次查询。如果第二次查询返回 True，它则确定 $x_i=\\text{False}$ 并继续；如果返回 False，算法正确地推断出没有赋值可以满足 $\\phi$（因为 $x_i=\\text{True}$ 和 $x_i=\\text{False}$ 都会使公式不可满足）并停止。因此，在任何迭代 $i$ 中，预言机查询的次数最多为 $2$。\n\n如果 $\\phi$ 是可满足的，循环将完成所有 $n$ 次迭代。一个最坏情况下的可满足实例是，对于每个 $i$，对 $\\phi_{\\text{true}}$ 的查询返回 False，而对 $\\phi_{\\text{false}}$ 的查询返回 True。在这种情况下，每次迭代使用 $2$ 次查询，总查询次数为\n$$\nQ=2n.\n$$\n\n如果 $\\phi$ 是不可满足的，那么对于任何 $i$ 以及与先前选择一致的任何部分赋值，$\\phi_{\\texttrue}$ 和 $\\phi_{\\text{false}}$ 都是不可满足的。因此，算法在第一次迭代中经过恰好 $2$ 次查询后检测到不可满足性并停止，此时 $Q=2$。\n\n综合所有具有 $n$ 个变量的 3-CNF 公式（无论是否可满足），最坏情况由上述可满足实例达到，最大预言机查询次数为\n$$\nQ_{\\max}=2n.\n$$", "answer": "$$\\boxed{C}$$", "id": "1460198"}]}