{"hands_on_practices": [{"introduction": "库克-莱文定理证明的核心，是将图灵机的计算过程转化为一个布尔公式 $\\phi$。构建此公式的第一步是精确描述计算的起始配置，即 $\\phi_{start}$ 部分。本练习将让你实践如何用布尔变量来指定带头的初始位置，这是整个逻辑构造的基石之一 [@problem_id:1438663]。", "problem": "在 Cook-Levin 定理的背景下，一个关键步骤是构造一个布尔公式 $\\phi$。当且仅当一个给定的非确定性图灵机 (NTM) $M$ 接受一个长度为 $n$ 的输入字符串 $w$ 时，该公式才是可满足的。这通过创建一个表示 $M$ 在 $w$ 上的计算历史的表格来实现。\n\n假设 NTM $M$ 保证在多项式 $p(n)$ 界定的步数内停机。我们可以使用一个大小为 $p(n) \\times p(n)$ 的表格来对计算进行建模，其中行表示时间步 $t$（从 $0$ 到 $p(n)-1$），列表示磁带单元格索引 $j$（从 $0$ 到 $p(n)-1$）。\n\n为了描述机器的状态，我们引入一组布尔变量。如果机器的读写头在时间步 $t$ 位于单元格 $j$，则变量 $H_{t,j}$ 为真，否则为假。这里，$0 \\le t < p(n)$ 且 $0 \\le j < p(n)$。\n\n按照惯例，NTM 在时间 $t=0$ 开始其计算，其读写头位于磁带的第一个单元格，即单元格 $j=0$。\n\n下列哪个布尔表达式正确且完整地编码了读写头位置的这一特定初始条件，作为总的起始格局公式 $\\phi_{start}$ 的一部分？\n\nA. $H_{0,0} \\land \\left( \\bigwedge_{j=1}^{p(n)-1} \\neg H_{0,j} \\right)$\n\nB. $\\bigvee_{j=0}^{p(n)-1} H_{0,j}$\n\nC. $H_{0,0}$\n\nD. $\\left(\\bigvee_{j=0}^{p(n)-1} H_{0,j}\\right) \\land \\left( \\bigwedge_{0 \\le i < k < p(n)} (\\neg H_{0,i} \\lor \\neg H_{0,k}) \\right)$\n\nE. $\\bigwedge_{j=0}^{p(n)-1} H_{0,j}$", "solution": "我们给定布尔变量 $H_{t,j}$，当且仅当读写头在时间 $t$ 位于单元格 $j$ 时，$H_{t,j}$ 为真。初始条件规定，在时间 $t=0$ 时，读写头位于单元格 $j=0$。为了完整地编码时间 $t=0$ 时的这个特定条件，我们必须同时断言两件事：\n- 在指定单元格为真：$H_{0,0}$ 必须为真。\n- 在同一时间所有其他单元格为假：对于每一个满足 $1 \\le j \\le p(n)-1$ 的 $j$，$H_{0,j}$ 必须为假。\n\n这两个要求共同由合取式\n$$\nH_{0,0} \\land \\left( \\bigwedge_{j=1}^{p(n)-1} \\neg H_{0,j} \\right)\n$$\n表示。这个公式是将读写头在时间 $0$ 精确地固定在单元格 $0$ 的充分必要条件。\n\n现在评估各个选项：\n- 选项 A 正是上面的公式，因此它正确且完整地编码了初始读写头位置。\n- 选项 B, $\\bigvee_{j=0}^{p(n)-1} H_{0,j}$，强制要求读写头在时间 $0$ 位于某个位置，但没有强制它必须在 $j=0$。\n- 选项 C, $H_{0,0}$，强制要求读写头位于 $j=0$，但没有排除某些 $j \\neq 0$ 的 $H_{0,j}$ 也为真的可能性；因此，除非在其他地方强制执行互斥性，否则它是不完整的。问题要求在 $\\phi_{start}$ 中完整编码这一特定初始条件，因此该选项本身是不充分的。\n- 选项 D, $\\left(\\bigvee_{j=0}^{p(n)-1} H_{0,j}\\right) \\land \\left( \\bigwedge_{0 \\le i < k < p(n)} (\\neg H_{0,i} \\lor \\neg H_{0,k}) \\right)$，表示在时间 $0$ 恰好有一个 $H_{0,j}$ 为真，但它允许该唯一位置是任何 $j$，而不一定是 $j=0$。\n- 选项 E, $\\bigwedge_{j=0}^{p(n)-1} H_{0,j}$，错误地强制所有位置同时为真。\n\n因此，正确选项是 A。", "answer": "$$\\boxed{A}$$", "id": "1438663"}, {"introduction": "在确定了初始状态之后，我们必须定义机器如何随时间演变的规则。一个至关重要的规则，即“框架公理”（frame axiom），确保了计算中未被读写头访问的纸带部分保持不变。这项练习要求你将此规则表达为合取范式（CNF），这是证明整个归约过程能够在多项式时间内完成的关键一步 [@problem_id:1438617]。", "problem": "在库克-莱文定理的背景下，一个图灵机的计算历史被编码成一个大的布尔公式。该公式是可满足的，当且仅当该图灵机接受输入字符串。该公式的一部分必须确保机器的配置仅根据其转移规则进行更改。\n\n这种编码使用一组布尔变量来描述在每个时间步 $t$ 和纸带位置 $j$ 时机器的状态。设纸带字母表为 $\\Sigma$。我们定义以下变量：\n- $H_{t,j}$ 为真，表示在时间 $t$ 读写头位于位置 $j$。\n- $C_{t,j,s}$ 为真，表示在时间 $t$ 纸带单元 $j$ 包含符号 $s \\in \\Sigma$。\n\n这个构造的一个关键部分是“框架公理”或“局部性规则”，它确保纸带单元不会自发地改变。具体来说，它必须强制满足以下条件：\n“如果在时间 $t$ 读写头不在位置 $j$，那么单元 $j$ 中的符号必须在时间 $t$ 到 $t+1$ 之间保持不变。”\n\n对于每一个有效的时间 $t$、位置 $j$ 和符号 $s \\in \\Sigma$，这条规则必须被翻译成一组合取范式 (CNF) 的子句。对于单个时间 $t$、位置 $j$ 和符号 $s$，下列哪个 CNF 公式正确且完整地表述了这条规则？\n\nA. $(H_{t,j} \\lor \\lnot C_{t,j,s} \\lor C_{t+1,j,s}) \\land (H_{t,j} \\lor C_{t,j,s} \\lor \\lnot C_{t+1,j,s})$\n\nB. $(\\lnot H_{t,j} \\lor \\lnot C_{t,j,s} \\lor C_{t+1,j,s}) \\land (\\lnot H_{t,j} \\lor C_{t,j,s} \\lor \\lnot C_{t+1,j,s})$\n\nC. $(H_{t,j} \\lor \\lnot C_{t,j,s} \\lor C_{t+1,j,s})$\n\nD. $(H_{t+1,j} \\lor \\lnot C_{t,j,s} \\lor C_{t+1,j,s}) \\land (H_{t+1,j} \\lor C_{t,j,s} \\lor \\lnot C_{t+1,j,s})$", "solution": "我们需要对局部性规则进行编码：如果在时间 $t$ 读写头不在位置 $j$，那么单元 $j$ 中的符号在时间 $t$ 到 $t+1$ 之间不发生改变。对于固定的 $t$，$j$ 和 $s \\in \\Sigma$，这对应于条件等价式\n$$\n\\lnot H_{t,j} \\rightarrow \\left(C_{t,j,s} \\leftrightarrow C_{t+1,j,s}\\right).\n$$\n该等价式是两个蕴含式的合取：\n$$\nC_{t,j,s} \\leftrightarrow C_{t+1,j,s} \\equiv \\left(C_{t,j,s} \\rightarrow C_{t+1,j,s}\\right) \\land \\left(C_{t+1,j,s} \\rightarrow C_{t,j,s}\\right).\n$$\n将外层的蕴含分配到合取式上，得到两个条件式：\n$$\n\\lnot H_{t,j} \\rightarrow \\left(C_{t,j,s} \\rightarrow C_{t+1,j,s}\\right), \\quad \\lnot H_{t,j} \\rightarrow \\left(C_{t+1,j,s} \\rightarrow C_{t,j,s}\\right).\n$$\n每个蕴含式 $A \\rightarrow B$ 等价于 $\\lnot A \\lor B$。对于第一个条件式，\n$$\n\\lnot H_{t,j} \\rightarrow \\left(C_{t,j,s} \\rightarrow C_{t+1,j,s}\\right) \\equiv H_{t,j} \\lor \\lnot C_{t,j,s} \\lor C_{t+1,j,s}.\n$$\n对于第二个条件式，\n$$\n\\lnot H_{t,j} \\rightarrow \\left(C_{t+1,j,s} \\rightarrow C_{t,j,s}\\right) \\equiv H_{t,j} \\lor \\lnot C_{t+1,j,s} \\lor C_{t,j,s}.\n$$\n因此，正确的 CNF 是这两个子句的合取：\n$$\n\\left(H_{t,j} \\lor \\lnot C_{t,j,s} \\lor C_{t+1,j,s}\\right) \\land \\left(H_{t,j} \\lor C_{t,j,s} \\lor \\lnot C_{t+1,j,s}\\right).\n$$\n与选项比较，这与选项 A 匹配。选项 B 错误地以 $H_{t,j}$ 为真作为条件（因为每个子句都含有 $\\lnot H_{t,j}$，所以只有当 $H_{t,j}$ 为真时，公式才对其他变量施加约束），选项 C 只包含了一个方向，因此不完整，而选项 D 错误地使用了 $H_{t+1,j}$ 而不是 $H_{t,j}$。", "answer": "$$\\boxed{A}$$", "id": "1438617"}, {"introduction": "一个严谨的逻辑构造不仅要规定什么是必须为真的，还要排除什么是必须为假的。在库克-莱文的证明中，这意味着在任何时刻，机器都必须处于唯一的状态，其读写头也必须在唯一的位置。这个思想实验将探讨如果省略了这些“唯一性”约束会产生何种后果，从而揭示为何它们并非冗余，而是防止模拟出现物理上不可能情况的关键所在 [@problem_id:1438664]。", "problem": "在库克-列文定理的背景下，一个标准的证明技巧是构造一个命题逻辑公式 $\\Phi$，该公式可满足当且仅当一台给定的非确定性图灵机 (NTM) $M$ 接受输入串 $w$。这个构造模拟了 $M$ 对 $w$ 在多项式数量的时间步 $p(|w|)$ 内的计算过程。\n\n该公式通常使用布尔变量来描述机器在每个时间步 $t$（其中 $0 \\le t \\le p(|w|)$）的格局。这些变量包括：\n- $Q_{t,q}$: 如果 $M$ 在时间步 $t$ 处于状态 $q$，则为真。\n- $H_{t,j}$: 如果 $M$ 的读写头在时间步 $t$ 位于位置 $j$，则为真。\n- $C_{t,j,s}$: 如果带单元 $j$ 在时间步 $t$ 包含符号 $s$，则为真。\n\n一名计算机科学专业的学生正尝试实现这个构造。他们正确地创建了公式 $\\Phi$ 中用于强制执行以下条件的部分：\n1.  机器以输入 $w$ 的正确初始格局开始。\n2.  机器的计算最终达到一个接受状态。\n3.  从时间 $t$ 的一个格局到 $t+1$ 的一个格局的每次转移都根据 $M$ 的转移函数是有效的。\n4.  在任何时间 $t$，每个带单元 $j$ 包含*恰好一个*符号。\n5.  在任何时间 $t$，机器处于*至少一个*状态，并且其读写头位于*至少一个*位置。这是通过对所有状态 $q_i$ 使用诸如 $(Q_{t,q_1} \\lor Q_{t,q_2} \\lor ...)$ 这样的子句来实现的。\n\n然而，该学生忘记为机器的状态和读写头位置添加“唯一性”或“至多一个”的子句。具体来说，对于任何给定的时间 $t$，所有形如 $(\\lnot Q_{t,q_i} \\lor \\lnot Q_{t,q_j})$（对于不同状态 $q_i, q_j$）和 $(\\lnot H_{t,j_i} \\lor \\lnot H_{t,j_j})$（对于不同位置 $j_i, j_j$）的成对否定子句都从公式 $\\Phi$ 中被省略了。\n\n以下哪项描述了这种省略可能导致的后果，即它可能被这个不完整公式的一个可满足赋值所表示？\n\nA. 可满足赋值可能对应于一个“计算”，其中机器在同一时间 $t$ 处于多个不同的状态。\n\nB. 可满足赋值可能对应于一个“计算”，其中执行了一个从时间 $t$ 到 $t+1$ 的转移，而该转移是机器的转移函数所不允许的。\n\nC. 可满足赋值可能对应于一个“计算”，该计算没有以正确的初始状态和磁带上的输入 $w$ 开始。\n\nD. 可满足赋值可能对应于一个“计算”，其中机器在某一特定时间 $t$ 完全不处于任何状态。\n\nE. 可满足赋值可能对应于一个“计算”，该计算运行了 $p(|w|)$ 步但从未进入任何机器定义的接受状态。", "solution": "我们分析在保持库克-列文构造的所有其他部分不变的情况下，省略状态变量 $Q_{t,q}$ 和读写头位置变量 $H_{t,j}$ 的至多一个 (AMO) 子句所带来的逻辑后果。\n\n首先，我们重申被强制执行的部分：\n1. 初始格局被强制执行：在 $t=0$ 时，磁带编码了 $w$，读写头和状态被设置为标准的初始值，所有其他格局位都符合初始规范。\n2. 接受条件被强制执行：存在 $t \\in \\{0,\\dots,p(|w|)\\}$ 使得 $Q_{t,q_{\\text{acc}}}$ 为真。\n3. 转移有效性被强制执行：对于每个 $t,j,q,s$，都有形如\n$$\n\\left(Q_{t,q} \\land H_{t,j} \\land C_{t,j,s}\\right) \\Rightarrow \\text{Next}_{t+1}(q,s,j)\n$$\n的子句，其中 $\\text{Next}_{t+1}(q,s,j)$ 断言了由转移函数 $\\delta(q,s)=(q',s',d)$ 所规定的特定更新，即 $Q_{t+1,q'}$、$H_{t+1,j'}$（其中 $j'=j+d$）以及对于在单元 $j$ 写入的符号的 $C_{t+1,j,s'}$。\n4. 每个单元恰好一个磁带符号被强制执行：对于每个 $t,j$，我们既有“至少一个”子句 $\\bigvee_{s} C_{t,j,s}$，也有对于所有 $s \\neq s'$ 的成对互斥子句 $\\left(\\lnot C_{t,j,s} \\lor \\lnot C_{t,j,s'}\\right)$。\n5. 至少一个状态和至少一个读写头位置被强制执行：对于每个 $t$，$\\bigvee_{q} Q_{t,q}$ 和 $\\bigvee_{j} H_{t,j}$ 都成立。\n\n被省略的正是针对 $Q$ 和 $H$ 的 AMO 约束：对于每个固定的 $t$，没有形如 $\\left(\\lnot Q_{t,q_{i}} \\lor \\lnot Q_{t,q_{j}}\\right)$（对于 $q_{i} \\neq q_{j}$）的子句，也没有形如 $\\left(\\lnot H_{t,j_{i}} \\lor \\lnot H_{t,j_{j}}\\right)$（对于 $j_{i} \\neq j_{j}$）的子句。\n\n我们现在来评估每个选项：\n\nA. 在同一时间 $t$ 处于多个不同的状态。\n由于缺少对 $Q_{t,q}$ 的 AMO 约束，该公式在句法上不禁止在同一时间 $t$ 将 $Q_{t,q_{1}}$ 和 $Q_{t,q_{2}}$ 都设置为真。唯一可能间接禁止这种情况的方式是，如果转移有效性加上磁带符号唯一性会产生矛盾。然而，存在这样的机器 $M$ 以及对 $H_{t,j}$ 和 $C_{t,j,s}$ 的一致选择，使得不会出现矛盾。具体来说，假设在时间 $t$，读写头位于某个位置 $j$（$H_{t,j}$ 为真），扫描到的符号是 $s$（$C_{t,j,s}$ 为真）。如果两个不同的状态 $q_{1},q_{2}$ 满足 $\\delta(q_{1},s)=(q'_{1},s',d_{1})$ 和 $\\delta(q_{2},s)=(q'_{2},s',d_{2})$ 共享相同的写入符号 $s'$，那么蕴含式\n$$\n\\left(Q_{t,q_{1}} \\land H_{t,j} \\land C_{t,j,s}\\right) \\Rightarrow C_{t+1,j,s'} \\quad \\text{和} \\quad \\left(Q_{t,q_{2}} \\land H_{t,j} \\land C_{t,j,s}\\right) \\Rightarrow C_{t+1,j,s'}\n$$\n与 $t+1$ 时刻单元 $j$ 的“磁带符号恰好一个”的约束是一致的。其推论 $Q_{t+1,q'_{1}}$ 和 $Q_{t+1,q'_{2}}$ 可以同时为真，因为对 $Q_{t+1,\\cdot}$ 没有 AMO 约束；类似地，多个 $H_{t+1,j'}$ 也可以被设置，因为对 $H_{t+1,\\cdot}$ 也没有 AMO 约束。因此，存在一个可满足赋值，其中在同一时间 $t$ 有多个 $Q_{t,q}$ 为真。因此，A 是一个可能的后果。\n\nB. 从 $t$ 到 $t+1$ 的非法转移。\n该构造包含了转移有效性子句，这些子句对于每一个被激活的前件 $\\left(Q_{t,q} \\land H_{t,j} \\land C_{t,j,s}\\right)$，都精确地强制执行由 $\\delta(q,s)$ 所允许的更新。缺少对 $Q$ 和 $H$ 的 AMO 约束并不会引入任何允许不在 $\\delta$ 中的转移的子句。它可能允许多个转移同时触发，但每一个本身都是被允许的。因此，该公式仍然禁止任何单个的不在转移函数中的转移。因此，B 不是一个后果。\n\nC. 不正确的初始格局。\n初始格局子句仍然存在，并强制在 $t=0$ 时有正确的初始状态、读写头位置和磁带上的输入。在其他时间缺少 AMO 约束并不会使这一点无效。因此，C 不是一个后果。\n\nD. 在某个时间 $t$ 不处于任何状态。\n对于每个 $t$，“至少一个状态”子句 $\\bigvee_{q} Q_{t,q}$ 都存在，因此不可能在任何时间 $t$ 使所有的 $Q_{t,q}$ 都为假。因此，D 不是一个后果。\n\nE. 从未进入接受状态。\n接受条件被强制执行（例如，通过 $\\bigvee_{t \\le p(|w|)} Q_{t,q_{\\text{acc}}}$），所以某个 $Q_{t,q_{\\text{acc}}}$ 必须为真。缺少 AMO 约束并不会移除这个要求。因此，E 不是一个后果。\n\n因此，省略 AMO 约束使得可满足赋值编码多个状态（以及同样地，多个读写头位置）的同时占据成为可能，而不会违反其余的约束，所以 A 是正确的选项。", "answer": "$$\\boxed{A}$$", "id": "1438664"}]}