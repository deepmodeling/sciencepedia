{"hands_on_practices": [{"introduction": "子集和问题看似简单，但其背后隐藏着深刻的计算复杂性。这个练习旨在揭示一个常见的误区：为什么一个直观的“贪心”策略——总是选择当前可选的最大数——无法保证找到解。通过这个具体的反例[@problem_id:1463403]，我们可以更好地理解为何需要更精巧的算法来应对这类问题。", "problem": "一名计算机科学专业的学生正在研究子集和问题（Subset-Sum problem），该问题旨在判断一个给定整数集合中是否存在一个非空子集，其元素之和等于一个特定的目标值。该学生实现了一个贪心算法来解决此问题。算法工作原理如下：\n\n1.  从一个空的解子集和初始目标值 $T$ 开始。\n2.  从可用整数集合 $S$ 中，选择小于或等于剩余目标值的最大整数。\n3.  将此整数添加到解子集中，并从剩余目标值中减去它的值。\n4.  从可用集合 $S$ 中移除所选的整数。\n5.  重复步骤2-4，直到剩余目标值变为零（找到解）或没有更多整数可供选择（算法失败）。\n\n该学生在一组整数 $S = \\{10, 7, 6, 5\\}$ 和目标值 $T = 12$ 上测试了该算法。贪心算法未能找到解。然而，确实存在一个元素之和等于 $T$ 的有效子集。请问以下哪个是正确的子集？\n\nA. $\\{10\\}$\n\nB. $\\{7, 6\\}$\n\nC. $\\{7, 5\\}$\n\nD. $\\{5, 6\\}$\n\nE. 不存在这样的子集", "solution": "该问题要求我们从集合 $S = \\{10, 7, 6, 5\\}$ 中找出元素之和等于目标值 $T = 12$ 的正确子集。题目告知我们，一个特定的贪心算法未能找到此解。让我们首先追踪该贪心算法的执行过程，以理解其失败的原因，然后我们将检查给出的选项以找到正确的解。\n\n首先，我们追踪所描述的贪心算法。\n整数集合为 $S = \\{10, 7, 6, 5\\}$，目标值为 $T = 12$。$S$ 中的整数已按降序排列，这对于贪心选择过程很方便。\n\n步骤1：当前目标值为12。$S$ 中最大的整数是10。由于 $10 \\le 12$，算法选择10。\n- 部分解子集现在是 $\\{10\\}$。\n- 剩余目标值变为 $12 - 10 = 2$。\n- 可用整数集合变为 $\\{7, 6, 5\\}$。\n\n步骤2：当前目标值为2。可用整数为 $\\{7, 6, 5\\}$。\n- 最大的可用整数是7。由于 $7 > 2$，它不能被选择。\n- 其次最大的可用整数是6。由于 $6 > 2$，它不能被选择。\n- 再次大的可用整数是5。由于 $5 > 2$，它不能被选择。\n\n步骤3：可用集合中没有任何整数小于或等于剩余目标值2。算法在未能将目标值减至0的情况下终止。贪心方法只找到了子集 $\\{10\\}$，其和为10，而不是12。因此，正如问题中所述，贪心算法失败了。\n\n现在，我们需要找到正确的子集。我们可以通过检查提供的多项选择选项来做到这一点。\n\nA. 子集是 $\\{10\\}$。其元素之和为10。这不等于目标值 $T = 12$。\n\nB. 子集是 $\\{7, 6\\}$。其元素之和为 $7 + 6 = 13$。这不等于目标值 $T = 12$。\n\nC. 子集是 $\\{7, 5\\}$。其元素之和为 $7 + 5 = 12$。这等于目标值 $T = 12$。这是一个有效的解。\n\nD. 子集是 $\\{5, 6\\}$。其元素之和为 $5 + 6 = 11$。这不等于目标值 $T = 12$。\n\nE. 此选项声称不存在这样的子集。这是错误的，因为我们在选项C中找到了一个有效的子集。\n\n因此，$S$ 中元素之和等于 $T=12$ 的正确子集是 $\\{7, 5\\}$。", "answer": "$$\\boxed{C}$$", "id": "1463403"}, {"introduction": "尽管子集和问题在一般情况下是 NP 完全的，但这并不意味着所有特例都同样困难。这个练习[@problem_id:1463440]将引导你探索一个有趣的特例：当集合中的所有数都是 2 的幂时，问题会发生什么变化。通过将问题与数字的二进制表示联系起来，你将发现一种出乎意料的高效解法，从而体会到问题结构的改变如何深刻影响其计算复杂度。", "problem": "子集和问题（SUBSET-SUM problem）是计算机科学中的一个经典问题：给定一个有限整数集 $S = \\{s_1, s_2, \\dots, s_n\\}$ 和一个目标整数 $T$，判断是否存在 $S$ 的一个非空子集，其元素之和恰好等于 $T$。在其一般形式下，子集和问题是NP完全的，这意味着没有已知的算法可以在输入规模的多项式时间内解决该问题的每一个实例，并且它被认为是NP类（不确定性多项式时间）中最难的问题之一。\n\n考虑该问题的一个特殊变体，其中集合 $S$ 只包含不同的、非负的2的幂。例如，$S$ 可以是 $\\{2^0, 2^2, 2^3, 2^7\\}$，即 $\\{1, 4, 8, 128\\}$。\n\n给定所有集合 $S$ 中的元素都是不同的2的幂这一特定约束，这个子集和问题变体的计算复杂度是多少？\n\nA. 它仍然是NP完全的。\n\nB. 它可以在多项式时间内求解，因此属于复杂度类P。\n\nC. 它是可解的，但只能在指数时间内求解，类似于一般问题的暴力解法。\n\nD. 该问题变得不可判定。\n\nE. 它可以在相对于输入规模的对数时间内求解。", "solution": "设 $S=\\{s_{1},\\dots,s_{n}\\}$，其中每个 $s_{j}$ 是一个不同的非负2的幂。因此存在不同的指数 $e_{1},\\dots,e_{n}\\in\\mathbb{N}\\cup\\{0\\}$ 使得\n$$\ns_{j}=2^{e_{j}} \\quad \\text{for } j=1,\\dots,n,\n$$\n我们定义指数集 $E=\\{e_{1},\\dots,e_{n}\\}$。对于任意子集 $X\\subseteq S$，其元素之和为\n$$\n\\sum_{s\\in X}s=\\sum_{2^{e}\\in X}2^{e}.\n$$\n因为 $X$ 中各元素的指数互不相同，该和的二进制表示中，比特位为1的位置恰好是 $X$ 中各元素的指数 $e$。这依赖于二进制表示的唯一性：每个非负整数都有一个唯一的表示形式\n$$\nT=\\sum_{i\\in B(T)}2^{i},\n$$\n其中 $B(T)$ 是 $T$ 的第 $i$ 个比特位等于1的所有位置 $i$ 的集合。因此，对于 $T\\ge 0$，我们有：\n$$\n\\exists\\,X\\subseteq S\\text{ with }\\sum_{s\\in X}s=T \\quad \\Longleftrightarrow \\quad B(T)\\subseteq E.\n$$\n此外，由于子集必须是非空的，并且所有 $s_{j}\\ge 0$（且至少有一个 $s_{j}>0$），如果 $T=0$，则不存在和为 $T$ 的非空子集；如果 $T<0$，则根本不存在任何子集，因为所有的和都是非负的。这些条件都可以在输入规模的多项式时间内进行检查。\n\n一个明确的多项式时间算法如下：\n1. 如果 $T<0$，回答NO。如果 $T=0$，由于要求非空子集，回答NO。\n2. 对每个 $s_j$，提取其指数 $e_j$（可在 $s_j$ 的比特长度的多项式时间内验证），从而计算出 $E=\\{e:\\,2^{e}\\in S\\}$。\n3. 从 $T$ 的二进制展开式中计算出 $B(T)$。\n4. 检查是否 $B(T)\\subseteq E$；如果是，回答YES，否则回答NO。\n\n运行时间为 $O\\!\\left(\\sum_{j=1}^{n}\\log s_{j}+\\log T\\right)$，在标准二进制编码下，这是输入规模的多项式。因此，这个特殊情况是可在多项式时间内求解的，所以它属于P类。\n\n因此，在这些选项中，正确的分类是B。", "answer": "$$\\boxed{B}$$", "id": "1463440"}, {"introduction": "对于一般的子集和问题，动态规划是一种经典的求解方法。然而，该算法虽然有效，却可能消耗大量内存资源。这个练习[@problem_id:1463442]将带你深入分析标准动态规划算法的空间复杂度，并思考如何对其进行优化。掌握这种优化技巧，是将理论算法转化为实用高效代码的关键一步。", "problem": "子集和问题（SUBSET-SUM problem）是计算机科学中的一个经典问题：给定一个非负整数集合 $S = \\{s_1, s_2, \\ldots, s_n\\}$ 和一个目标整数和 $t$，确定是否存在 $S$ 的一个非空子集，其元素之和恰好为 $t$。\n\n解决此问题的标准方法是使用动态规划（Dynamic Programming, DP）。我们可以构建一个大小为 $(n+1) \\times (t+1)$ 的二维布尔表，称之为 `P`。表项 `P[i][j]` 为 `true` 表示可以使用前 `i` 个元素 $\\{s_1, \\ldots, s_i\\}$ 的一个子集构成和 `j`，否则为 `false`。该表使用以下递推关系进行填充：\n`P[i][j] = P[i-1][j] OR P[i-1][j - s_i]`\n（其中第二项仅在 $j \\ge s_i$ 时考虑）。基础情况通常是 `P[0][0] = true` 以及对于 $j > 0$ 的 `P[0][j] = false`。问题的最终答案由 `P[n][t]` 给出。\n\n分析此标准算法的空间复杂度及其优化逻辑。请考虑以下陈述：\n\nI. 上述标准二维动态规划算法的空间复杂度是 $O(n \\cdot t)$。\nII. 空间复杂度可以优化到 $O(n + t)$，因为注意到只需要前一列的值。\nIII. 空间优化是可行的，因为任何状态 `(i, j)`（使用前 `i` 个元素构成和 `j`）的计算仅依赖于前一行 `i-1` 的状态。\nIV. 为了使用单个一维数组实现此优化，遍历可能和 `j` 的内层循环必须按递增顺序处理（例如，从 `j = s_i` 到 `j = t`）。\n\n以上哪些陈述是正确的？\n\nA. 仅 I\n\nB. 仅 I 和 III\n\nC. 仅 II 和 IV\n\nD. I、III 和 IV\n\nE. 以上全部", "solution": "我们如下定义动态规划表：对于整数 $i \\in \\{0,1,\\ldots,n\\}$ 和 $j \\in \\{0,1,\\ldots,t\\}$，令 $P[i][j]$ 为一个布尔值，表示 $\\{s_{1},\\ldots,s_{i}\\}$ 的某个子集之和是否为 $j$。递推关系为\n$$\nP[i][j] = P[i-1][j] \\lor \\bigl(j \\ge s_{i} \\land P[i-1][j - s_{i}]\\bigr),\n$$\n基础情况为 $P[0][0] = \\text{true}$ 以及对于所有 $j > 0$ 的 $P[0][j] = \\text{false}$。\n\n陈述 I：该表有 $(n+1)(t+1)$ 个布尔条目。因此，标准二维动态规划使用的空间为 $\\Theta(n t)$，即 $O(n \\cdot t)$。所以陈述 I 是正确的。\n\n陈述 III：从递推关系可知，每个 $P[i][j]$ 仅依赖于 $P[i-1][j]$ 和 $P[i-1][j - s_{i}]$，也就是说，仅依赖于索引为 $i-1$ 的前一行。这种在 $i$ 上的局部性正是空间优化成为可能的原因。所以陈述 III 是正确的。\n\n空间优化逻辑：定义一个一维数组 $D[j]$ 来表示和为 $j \\in \\{0,\\ldots,t\\}$ 的当前行值。为了原地模拟从行 $i-1$ 到行 $i$ 的转换，我们必须确保在计算更新\n$$\nD[j] \\leftarrow D[j] \\lor D[j - s_{i}],\n$$\n时，所使用的 $D[j - s_{i}]$ 的值来自前一行，而不是已在当前行中更新的值。这可以通过将 $j$ 从 $t$ 向下递减迭代到 $s_{i}$ 来实现。结果是，$D$ 只需要 $O(t)$ 的空间，外加用于索引和临时变量的常数额外空间，所以优化后的空间是 $O(t)$。\n\n陈述 II：该陈述声称通过只使用前一列，优化后的空间是 $O(n + t)$，但依赖关系是基于前一行，并且标准的优化使用一个长度为 $t+1$ 的一维数组，实现 $O(t)$ 的空间复杂度，而不是 $O(n + t)$。所以陈述 II 是不正确的。\n\n陈述 IV：该陈述声称内层循环必须以递增顺序处理 $j$。如上所示，递增顺序将允许多次重复使用 $s_{i}$，因为 $D[j - s_{i}]$ 可能已经包含了当前迭代中 $s_{i}$ 的贡献。例如，在将 $D[s_{i}]$ 设置为 true 后，递增的扫描将允许 $D[2 s_{i}] \\leftarrow D[2 s_{i}] \\lor D[s_{i}]$ 通过两次使用 $s_{i}$ 而变为 true，这对于0-1子集问题是不正确的。因此，我们必须以递减顺序迭代 $j$，所以陈述 IV 是错误的。\n\n因此，正确的陈述仅有 I 和 III。", "answer": "$$\\boxed{B}$$", "id": "1463442"}]}