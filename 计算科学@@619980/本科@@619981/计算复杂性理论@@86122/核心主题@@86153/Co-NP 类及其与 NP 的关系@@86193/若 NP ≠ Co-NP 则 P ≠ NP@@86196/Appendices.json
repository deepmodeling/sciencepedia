{"hands_on_practices": [{"introduction": "我们将通过一个思想实验来开始我们的实践，探索在一个假想的 $P=NP$ 世界里会发生什么。这个练习将让你追踪一个属于 $co-NP$ 类的问题的“命运”，看看它在 $P=NP$ 的假设下会归于何处。通过这个过程，你将亲手运用 $P$ 类的强大属性——对补运算的封闭性——来推导出一个关键结论。[@problem_id:1427404]", "problem": "在计算复杂性理论中，我们根据解决决策问题所需的资源来定义几个类别。\n- **P** 类包含所有可以由确定性算法在输入字符串长度的多项式时间内判定的语言（字符串集合）。\n- **NP** 类（非确定性多项式时间）包含所有语言，其“是”实例存在一个证据（或证书），该证据可由一个确定性算法在多项式时间内验证其正确性。\n- **co-NP** 类包含所有语言 $L$，其补集 $\\bar{L}$ 属于 NP。补集 $\\bar{L}$ 是指在给定字母表上所有不属于 $L$ 的字符串的集合。\n\n计算机科学中的一个主要开放问题是 P 是否等于 NP。为了论证，假设已经明确证明了 P = NP。现在，考虑任何一个属于 co-NP 类的任意语言 $L$。仅基于 P = NP 这一假设，以下哪个结论在逻辑上必然为真？\n\nA. 语言 $L$ 必定属于 P 类。\n\nB. 语言 $L$ 必定是 NP-完全的。\n\nC. 语言 $L$ 可能属于也可能不属于 P；其是否属于 P 取决于 $L$ 除了其属于 co-NP 之外的其他属性。\n\nD. $L$ 的补集 $\\bar{L}$ 必定是不可判定的。\n\nE. 语言 $L$ 属于 NP，但不一定属于 P。", "solution": "假设给定的条件是 $P=\\mathrm{NP}$。设 $L$ 是任何一个满足 $L\\in \\text{co-NP}$ 的语言。根据 $\\text{co-NP}$ 的定义，这意味着 $\\overline{L}\\in \\mathrm{NP}$。\n\n使用 $P=\\mathrm{NP}$ 的假设，我们得到 $\\overline{L}\\in P$。P 类在补运算下是闭合的，这是一个标准的闭包性质：如果 $A\\in P$，那么 $\\overline{A}\\in P$。将此性质应用于 $A=\\overline{L}$，可得出 $L=\\overline{\\overline{L}}\\in P$。\n\n因此，每一个 $L\\in \\text{co-NP}$ 都满足 $L\\in P$。等价地，在 $P=\\mathrm{NP}$ 的条件下，我们得到 $P=\\mathrm{NP}=\\text{co-NP}$。\n\n评估各个选项：\n- A 根据上述论证为真。\n- B 不被保证；属于 $P$ 并不意味着是 NP-完全的。\n- C 为假，因为在该假设下，属于 $P$ 是被保证的。\n- D 为假；$\\overline{L}\\in P$，因此是多项式时间内可判定的。\n- E 为假，因为在 $P=\\mathrm{NP}$ 的条件下，属于 $\\mathrm{NP}$ 就意味着属于 $P$。\n\n因此，正确且有保证的结论是 A。", "answer": "$$\\boxed{A}$$", "id": "1427404"}, {"introduction": "在我们理解了 $P=NP$ 如何影响 $co-NP$ 中的问题之后，现在我们可以正面解决本文的核心定理。这个练习将引导你使用一个强大的数学工具——反证法——来证明为什么 $P=NP$ 和 $NP \\neq co-NP$ 这两个假设是相互矛盾的，不能同时成立。这构成了本文主题的逻辑核心，即如果 $NP \\neq co-NP$，那么 $P \\neq NP$。[@problem_id:1427439]", "problem": "在计算复杂度理论中，我们研究解决计算问题所需的资源。让我们考虑三个基本的复杂度类：\n- **P (多项式时间):** 可由确定性图灵机在输入规模的多项式函数时间内解决的判定问题类。\n- **NP (非确定性多项式时间):** 对于一个'是'实例，存在一个证据（或证明），该证据可以由确定性图灵机在多项式时间内验证的判定问题类。\n- **co-NP:** 对于一个'否'实例，存在一个证据（或证明/反例），该证据可以在多项式时间内被验证的判定问题类。等价地，一个问题 $L$ 属于 co-NP 当且仅当它的补集 $\\bar{L}$ （其中'是'实例和'否'实例被交换）属于 NP。\n\n考虑一个假设情景，其中给定以下两个假设为真：\n1.  $P = NP$\n2.  $NP \\neq co-NP$\n\n基于这两个假设，以下哪个陈述是最准确的逻辑推论？\n\nA. P 类在补运算下不是闭合的。\n\nB. 这两个假设导致逻辑矛盾。\n\nC. co-NP 类必须是 NP 的真子集（即 $co-NP \\subset NP$）。\n\nD. NP 类必须是 co-NP 的真子集（即 $NP \\subset co-NP$）。\n\nE. NP 中至少存在一个问题，其补集不在 NP 中。", "solution": "假设 $P = NP$ 且 $NP \\neq \\text{co-NP}$。\n\n首先，证明 $P$ 在补运算下是闭合的。令 $L \\in P$。那么存在一个确定性图灵机 $M$ 和一个多项式 $p$，使得对于所有输入 $x$，$M$ 在时间 $p(|x|)$ 内判定 $x$ 是否属于 $L$。定义一个机器 $M'$，它在输入 $x$ 上运行 $M(x)$ 并翻转其接受/拒绝的决定。那么 $M'$ 在时间 $p(|x|)$ 内判定 $\\overline{L}$，因此 $\\overline{L} \\in P$。因此 $P$ 在补运算下是闭合的，即 $P = \\text{co-}P$。\n\n由 $P = NP$ 取补集可得 $\\text{co-}P = \\text{co-NP}$。使用刚刚证明的 $P = \\text{co-}P$，我们有\n$$\nNP = P = \\text{co-}P = \\text{co-NP},\n$$\n所以 $NP = \\text{co-NP}$。\n\n这与假设 $NP \\neq \\text{co-NP}$ 直接矛盾。因此，这两个假设放在一起是不一致的；它们导致了逻辑矛盾。\n\n评估各个选项：\n- A 是错误的，因为 $P$ 在补运算下是闭合的。\n- B 是正确的，如上所示。\n- C 和 D 与 $P = NP$ 蕴含 $NP = \\text{co-NP}$ 不相容。\n- E 在 $P = NP$ 的条件下是错误的，因为那样的话 $NP = P$ 且在补运算下是闭合的。\n\n因此，正确选项是 B。", "answer": "$$\\boxed{B}$$", "id": "1427439"}, {"introduction": "前面的练习证明了如果 $P=NP$，那么 $NP=co-NP$。但这个证明为何成立？关键在于我们一直使用的 $P$ 类的一个基本性质：对补运算的封闭性。这个终极挑战将带你进入一个假想的“相对化世界”，在这个世界里，我们人为地移除了这个性质，让你亲眼见证即使 $P=NP$ 成立，$NP=co-NP$ 的结论也不再必然导出。这个练习将深刻揭示补运算封闭性在这一重要证明中不可或缺的作用。[@problem_id:1427443]", "problem": "在计算复杂性理论中，一个语言（language）是代表某个判定问题的所有“是”实例的字符串集合。一个语言 $L$ 的补集，记作 $\\bar{L}$，由所有不在 $L$ 中的字符串组成（基于一个固定的字母表）。如果对于复杂度类 $C$ 中的每一个语言 $L$，其补集 $\\bar{L}$ 也属于 $C$，那么我们称复杂度类 $C$ 在补运算下是“闭合的”。\n\n对于一个给定的谕示（oracle）$A$（它是一个固定的字符串集合），我们可以定义相对化的复杂度类。复杂度类 $P^A$ 包含所有可以由一台能访问谕示 $A$ 的确定性图灵机在多项式时间内判定的语言。复杂度类 $NP^A$ 包含所有可以由一台能访问 $A$ 的非确定性图灵机在多项式时间内判定的语言。复杂度类 $co-NP^A$ 被定义为所有满足其补集 $\\bar{L}$ 属于 $NP^A$ 的语言 $L$ 的集合。\n\n在标准的、非相对化（即没有谕示）的设置中，一个著名的定理是：如果 P = NP，那么 NP = co-NP。该定理的证明根本上依赖于 P 类在补运算下是闭合的这一事实。为了证明这个闭包性质对于该证明的逻辑是不可或缺的，我们考虑一个假设的谕示 $A$，它构建了一个该性质不成立的“相对化世界”。\n\n假设给定一个谕示 $A$，关于它以下两个陈述是既定事实：\n1. $P^A = NP^A$。\n2. 复杂度类 $P^A$ 在补运算下不是闭合的。也就是说，存在至少一个语言 $L_0 \\in P^A$，其补集 $\\overline{L_0} \\notin P^A$。\n\n仅基于这两个预设前提，下列哪些结论是逻辑上必然的？选择所有有效选项。\n\nA. $NP^A = co-NP^A$。\n\nB. $NP^A \\neq co-NP^A$。\n\nC. $P^A = PSPACE^A$，其中 $PSPACE^A$ 是指能被一台可访问谕示 $A$ 的确定性图灵机在多项式空间内判定的语言所组成的类。\n\nD. 对于任何语言 $L \\in NP^A$，其补集 $\\bar{L}$ 也属于 $NP^A$。\n\nE. 存在某个语言 $L_1 \\in co-NP^A$ 使得 $L_1 \\notin P^A$。", "solution": "我们已知两个前提：\n(1) $P^{A} = NP^{A}$。\n(2) $P^{A}$ 在补运算下不是闭合的，即 $\\exists L_{0} \\in P^{A}$ 使得 $\\overline{L_{0}} \\notin P^{A}$。\n\n首先，利用(1)来推导(2)的一个结论。根据(1)，由于 $L_{0} \\in P^{A}$ 且 $P^{A} = NP^{A}$，我们可知 $L_{0} \\in NP^{A}$。根据 $\\text{co-NP}^{A}$ 的定义，一个语言 $L$ 属于 $\\text{co-NP}^{A}$ 当且仅当其补集 $\\overline{L}$ 属于 $NP^{A}$。将此定义应用于 $L = \\overline{L_{0}}$，我们有 $\\overline{\\overline{L_{0}}} = L_{0} \\in NP^{A}$，因此 $\\overline{L_{0}} \\in \\text{co-NP}^{A}$。根据(2)，$\\overline{L_{0}} \\notin P^{A}$。因此，存在一个属于 $\\text{co-NP}^{A}$ 但不属于 $P^{A}$ 的语言，这使得选项 E 成为逻辑上必然的结论。\n\n接下来，分析选项 A。假设 $NP^{A} = \\text{co-NP}^{A}$ 成立，以导出矛盾。那么根据(1)，有 $P^{A} = NP^{A} = \\text{co-NP}^{A}$。任取一个语言 $L \\in P^{A}$。由于 $P^{A} = \\text{co-NP}^{A}$，我们有 $L \\in \\text{co-NP}^{A}$，根据定义，这意味着 $\\overline{L} \\in NP^{A}$。再利用 $NP^{A} = P^{A}$，我们得到 $\\overline{L} \\in P^{A}$。因此 $P^{A}$ 将在补运算下是闭合的，这与(2)矛盾。所以 $NP^{A} \\neq \\text{co-NP}^{A}$ 必然成立，这使得选项 B 成为逻辑上必然的结论，而选项 A 是错误的。\n\n选项 D 断言，对于每一个 $L \\in NP^{A}$，都有 $\\overline{L} \\in NP^{A}$，即 $NP^{A}$ 在补运算下是闭合的。根据 $\\text{co-NP}^{A}$ 的定义，这蕴含了 $NP^{A} = \\text{co-NP}^{A}$，而这与我们已证明的 $NP^{A} \\neq \\text{co-NP}^{A}$ 的必然性相矛盾。因此，在这些前提下，D 不是必然的，实际上是错误的。\n\n选项 C 声称 $P^{A} = PSPACE^{A}$。前提(1)和(2)没有对 $P^{A}$ (或 $NP^{A}$) 与 $PSPACE^{A}$ 之间的关系施加任何限制。存在这样的相对化世界，其中 $P^{A} = NP^{A}$ 但 $P^{A} \\neq PSPACE^{A}$。因此，C 不是(1)和(2)的逻辑必然结果。\n\n综上所述，必须成立的结论是 B 和 E。", "answer": "$$\\boxed{BE}$$", "id": "1427443"}]}