{"hands_on_practices": [{"introduction": "验证一个命题公式是否为重言式最直接的方法是构建其真值表。这个练习将带你通过这一基本过程，系统地评估所有可能的真值组合。通过手动构建真值表[@problem_id:1464066]，你不仅能巩固对逻辑联结词（如蕴含 $\\rightarrow$、合取 $\\land$）的理解，还能直观地看到一个公式为何在任何解释下都为真。", "problem": "在一门形式逻辑课程中，学生们的任务是对命题公式进行分类。如果一个公式对于其命题变量的所有可能真值指派都为真，则该公式被定义为**重言式**。如果一个公式对于所有此类指派都为假，则它是一个**矛盾式**。既非重言式也非矛盾式的公式被称为**偶然式**。\n\n一位名叫 Alex 的学生分析了四个涉及命题变量 $p$ 和 $q$ 的不同公式，并对每个公式提出了一个论断。你的任务是确定 Alex 的哪个论断是正确的。\n\nA. 公式 $((p \\rightarrow q) \\land \\neg q) \\rightarrow \\neg p$ 是一个重言式。\n\nB. 公式 $(p \\lor q) \\land (\\neg p \\land \\neg q)$ 是一个偶然式。\n\nC. 公式 $(p \\rightarrow q) \\rightarrow p$ 是一个重言式。\n\nD. 公式 $(p \\land \\neg p) \\rightarrow q$ 是一个矛盾式。", "solution": "为确定哪个论断是正确的，我们将通过构建其真值表来分析每个公式。真值“真”和“假”分别用 T 和 F 表示。\n\n**选项 A 的分析：**\n公式为 $F_A = ((p \\rightarrow q) \\land \\neg q) \\rightarrow \\neg p$。\n我们逐步构建此公式的真值表。各列将代表变量和子表达式。\n仅当 $p$ 为 T 且 $q$ 为 F 时，蕴含式 $p \\rightarrow q$ 才为假。\n| $p$ | $q$ | $\\neg p$ | $\\neg q$ | $p \\rightarrow q$ | $(p \\rightarrow q) \\land \\neg q$ | $F_A$ |\n|---|---|---|---|---|---|---|\n| T | T | F | F | T | F | T |\n| T | F | F | T | F | F | T |\n| F | T | T | F | T | F | T |\n| F | F | T | T | T | T | T |\n$F_A$ 的最后一列仅包含 T 值。这意味着该公式是一个重言式。因此，Alex 在选项 A 中的论断是正确的。\n\n**选项 B 的分析：**\n公式为 $F_B = (p \\lor q) \\land (\\neg p \\land \\neg q)$。\n我们构建其真值表。\n| $p$ | $q$ | $\\neg p$ | $\\neg q$ | $p \\lor q$ | $\\neg p \\land \\neg q$ | $F_B$ |\n|---|---|---|---|---|---|---|\n| T | T | F | F | T | F | F |\n| T | F | F | T | T | F | F |\n| F | T | T | F | T | F | F |\n| F | F | T | T | F | T | F |\n$F_B$ 的最后一列仅包含 F 值。这意味着该公式是一个矛盾式。Alex 声称它是一个偶然式。因此，选项 B 中的论断是不正确的。\n\n**选项 C 的分析：**\n公式为 $F_C = (p \\rightarrow q) \\rightarrow p$。\n我们构建其真值表。\n| $p$ | $q$ | $p \\rightarrow q$ | $F_C$ |\n|---|---|---|---|\n| T | T | T | T |\n| T | F | F | T |\n| F | T | T | F |\n| F | F | T | F |\n$F_C$ 的最后一列同时包含 T 和 F 值。这意味着该公式是一个偶然式。Alex 声称它是一个重言式。因此，选项 C 中的论断是不正确的。\n\n**选项 D 的分析：**\n公式为 $F_D = (p \\land \\neg p) \\rightarrow q$。\n子表达式 $p \\land \\neg p$ 是一个矛盾式，意味着它恒为假。只要前件 $A$ 为假，无论后件 $B$ 的真值如何，蕴含式 $A \\rightarrow B$ 都为真。在这种情况下，前件是 $p \\land \\neg p$，它恒为假。因此，蕴含式 $F_D$ 必恒为真。\n我们用真值表来验证这一点。\n| $p$ | $q$ | $\\neg p$ | $p \\land \\neg p$ | $F_D$ |\n|---|---|---|---|---|\n| T | T | F | F | T |\n| T | F | F | F | T |\n| F | T | T | F | T |\n| F | F | T | F | T |\n$F_D$ 的最后一列仅包含 T 值，所以该公式是一个重言式。Alex 声称它是一个矛盾式。因此，选项 D 中的论断是不正确的。\n\n基于对所有四个选项的分析，只有选项 A 中的论断是正确的。", "answer": "$$\\boxed{A}$$", "id": "1464066"}, {"introduction": "在掌握了具体公式的验证后，下一个挑战是学会对一整类公式的属性进行推理。这个思想实验[@problem_id:1464067]要求你只根据公式的构成规则——仅使用合取($\\land$)联结词——来判断其是否可能成为重言式。这种从具体实例到抽象结构的思维跳跃，是理论分析和算法设计的核心能力。", "problem": "在命题逻辑中，公式是由命题变量（例如 $p, q, r, \\dots$）构成的陈述，这些变量可被赋予 `True` 或 `False` 的真值。\n\n如果一个公式对于其变量的每一种可能的真值赋值，其求值结果都为 `True`，那么该公式被定义为**重言式**。\n\n考虑根据特定规则构造的一类命题公式：该公式必须至少包含一个命题变量，并且必须仅使用逻辑合取（$\\land$）联结词来构建。例如，给定变量 $p$ 和 $q$，表达式 $p \\land q$ 和 $p \\land p \\land q$ 属于此类，而 $p$、$p \\lor q$ 和 $\\neg p$ 则不属于。\n\n根据此定义，这类公式可能成为重言式吗？\n\nA. 是，任何此类公式都是重言式。\n\nB. 是，但仅当公式恰好包含一个不同变量时（例如，像 $p \\land p$ 这样的公式）。\n\nC. 否，此类公式永远不可能是重言式。\n\nD. 当且仅当公式中的每个变量都被赋值为 `True` 时，它才是重言式。\n\nE. 在不了解公式具体结构的情况下无法确定。", "solution": "我们将所述类别形式化如下：该类中的公式是命题变量的有限合取，其中联结词 $\\land$ 至少出现一次；也就是说，任何公式都具有以下形式\n$$\n\\varphi \\;=\\; x_{1} \\land x_{2} \\land \\dots \\land x_{n},\n$$\n其中 $n \\geq 2$ 且每个 $x_{i}$ 都是一个命题变量。（这与 $p \\land q$ 和 $p \\land p \\land q$ 被包含在内，而 $p$ 被排除在外的例子相符。）\n\n根据合取的真值定义，对于变量的任意赋值 $v$，我们有\n$$\nv(\\varphi) = \\text{True} \\quad \\text{if and only if} \\quad \\forall i \\in \\{1,\\dots,n\\},\\; v(x_{i}) = \\text{True}.\n$$\n等价地，如果存在某个索引 $j$ 使得 $v(x_{j}) = \\text{False}$，则 $v(\\varphi) = \\text{False}$。由于 $\\varphi$ 至少包含一个变量，我们选择 $\\varphi$ 中出现的任意一个变量 $x_j$。考虑由下式定义的赋值 $v$：\n$$\nv(x_{j}) = \\text{False}, \\quad \\text{and} \\quad v(x_{i}) = \\text{True} \\text{ for all } i \\neq j.\n$$\n在此赋值下，根据合取规则，有 $v(\\varphi) = \\text{False}$。因此，$\\varphi$ 并非在所有赋值下都为真，故而不是一个重言式。\n\n无论变量是否重复（例如 $p \\land p$）或出现多个不同变量，此论证均成立。唯一恒为真（永真）的合取（即空合取）已被问题的规则和示例排除。因此，此类别中的任何公式都不可能是重言式。\n\n所以，正确选项是 C。", "answer": "$$\\boxed{C}$$", "id": "1464067"}, {"introduction": "将逻辑概念转化为计算机可以执行的步骤，是计算理论的核心。这个练习[@problem_id:1464042]将真值表方法形式化为一个递归算法，并要求你分析其执行效率。通过追踪算法的调用次数，你将亲身体会到为什么重言式问题在计算上是“困难”的，并直观地理解其指数级复杂度的来源，这是理解 NP 与 co-NP 等复杂性类的关键一步。", "problem": "一名计算机科学专业的学生正在开发一个递归算法，用于判断一个给定的命题逻辑公式是否为重言式。该算法名为 `CheckTautology`，其工作原理如下：\n\n该函数定义为 `CheckTautology(F, A)`，其中 `F` 是一个命题公式，`A` 是一个将变量映射到布尔值（`True` 或 `False`）的赋值集合。令 `V(F)` 为公式 `F` 中出现的唯一变量的集合。该函数的行为由一个基本情况和一个递归步骤定义：\n\n- **基本情况**：如果 `A` 中已赋值的变量集合与公式中的变量集合 `V(F)` 相同，则函数使用 `A` 中的赋值来评估公式 `F`，并返回最终的布尔值（`True` 或 `False`）。\n- **递归步骤**：如果 `V(F)` 中存在未赋值的变量，算法会按字母顺序选择第一个尚未在 `A` 中赋值的变量 `p`。然后，它进行两次递归调用：一次将 `p` 赋值为 `True`，另一次将 `p` 赋值为 `False`。当且仅当这两个递归调用都返回 `True` 时，该函数返回 `True`；否则，它返回 `False`。\n\n为了检查公式 `F` 是否为重言式，会进行一个初始调用 `CheckTautology(F, A_0)`，其中 `A_0` 是空的赋值集合。\n\n考虑以下命题公式 $\\phi$：\n$$ \\phi = (p \\to (q \\to r)) \\to ((p \\to q) \\to (p \\to r)) $$\n\n要确定 $\\phi$ 是否为重言式，总共需要调用 `CheckTautology` 函数多少次（包括初始调用）？", "solution": "令 $V(\\phi)$ 表示该公式中的变量集合。对于 $\\phi=(p \\to (q \\to r)) \\to ((p \\to q) \\to (p \\to r))$，我们有\n$$\nV(\\phi)=\\{p,q,r\\}, \\quad |V(\\phi)|=3.\n$$\n当 $\\phi$ 是一个重言式时，函数 CheckTautology 会在所有赋值下对 $\\phi$ 进行评估，因为在每个非基本情况的调用中，它都会进行两次递归调用（对第一个未赋值的变量分别设为 $\\text{True}$ 和 $\\text{False}$），并且当且仅当两次调用都返回 $\\text{True}$ 时，它才返回 $\\text{True}$。由于 $\\phi$ 确实是一个重言式，没有分支会返回 $\\text{False}$，因此不会发生提前终止，整个二叉递归树都会被探索。\n\n令 $T(n)$ 为当公式是重言式时，CheckTautology 对一个含有 $n$ 个不同变量的公式进行的总调用次数（包括初始调用）。那么：\n- 基本情况：当 $n=0$ 时，恰好有一次调用，该调用立即进行评估并返回，因此\n$$\nT(0)=1.\n$$\n- 递归步骤：对于 $n \\geq 1$，顶层调用对含有 $n-1$ 个剩余未赋值变量的公式进行两次递归调用，并且我们计算当前调用本身，因此\n$$\nT(n)=1+2\\,T(n-1).\n$$\n通过定义 $S(n)=T(n)+1$ 来求解该递推关系。那么\n$$\nS(n)=T(n)+1=\\bigl(1+2\\,T(n-1)\\bigr)+1=2\\bigl(T(n-1)+1\\bigr)=2\\,S(n-1),\n$$\n其中 $S(0)=T(0)+1=2$。因此\n$$\nS(n)=2^{n+1} \\quad \\Longrightarrow \\quad T(n)=S(n)-1=2^{n+1}-1.\n$$\n对于 $n=3$，\n$$\nT(3)=2^{4}-1=15.\n$$\n这等价于一个高度为 $3$ 的满二叉树中的总节点数，由 $\\sum_{k=0}^{3}2^{k}=2^{4}-1$ 给出。\n\n因此，总调用次数（包括初始调用）是 $15$。", "answer": "$$\\boxed{15}$$", "id": "1464042"}]}