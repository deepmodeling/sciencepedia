{"hands_on_practices": [{"introduction": "在处理完全复杂的重言式问题（TAUTOLOGY）之前，我们先来看一个简化的例子，理解问题结构如何显著改变其难度，这有助于我们建立直觉。第一个练习将研究一个高度受限的 TAUT 版本。通过分析一种简单的公式类型，我们将亲眼看到并非所有重言式问题都是计算困难的。[@problem_id:1449027]", "problem": "在设计一个专门的逻辑电路验证器时，你的任务是分析一个高度受限问题的复杂度。该验证器只处理形如 $\\phi = v_1 \\to v_2$ 的布尔公式，其中 $\\to$ 表示实质蕴涵算子，而 $v_1$ 和 $v_2$ 是单个布尔变量的标识符（例如，`x`、`y`、`var123`）。这个问题，我们称之为 `SIMPLE-TAUT`，是判定一个给定受限格式的公式 $\\phi$ 是否为重言式。如果一个公式对于其变量的所有可能真值赋值都为真，则该公式是一个重言式。\n\n例如，如果输入是公式 $x \\to x$，答案是“是”，因为它是一个重言式。如果输入是 $x \\to y$（其中 `x` 和 `y` 是不同的变量），答案是“否”，因为它在 `x` 为真且 `y` 为假时为假。\n\n你的任务是确定 `SIMPLE-TAUT` 所属的复杂度类。下列哪个陈述最准确地描述了 `SIMPLE-TAUT` 的复杂度？\n\nA. `SIMPLE-TAUT` 属于 P。\nB. `SIMPLE-TAUT` 是 NP完全的，但不属于 P（假设 P $\\neq$ NP）。\nC. `SIMPLE-TAUT` 是 co-NP完全的，但不属于 P（假设 P $\\neq$ NP）。\nD. `SIMPLE-TAUT` 是可判定的，但不属于 co-NP。\nE. `SIMPLE-TAUT` 是不可判定的。", "solution": "设输入公式为 $\\phi = v_{1} \\to v_{2}$，其中 $v_{1}$ 和 $v_{2}$ 是单个布尔变量（标识符）。根据实质蕴涵的定义，\n$$\nv_{1} \\to v_{2} \\equiv \\neg v_{1} \\lor v_{2}.\n$$\n我们来刻画 $\\phi$ 成为重言式的条件。\n\n1) 当 $v_{1} = v_{2}$ 时的充分性：\n如果 $v_{1} = v_{2} = x$，那么\n$$\nx \\to x \\equiv \\neg x \\lor x,\n$$\n并且根据排中律，对于 $x$ 的所有真值赋值，$\\neg x \\lor x$ 均为真。因此 $\\phi$ 是一个重言式。\n\n2) 当 $v_{1} \\neq v_{2}$ 时的必要性：\n如果 $v_{1}$ 和 $v_{2}$ 是不同的变量，取赋值 $v_{1} = \\text{True}$ 和 $v_{2} = \\text{False}$。那么\n$$\n\\neg v_{1} \\lor v_{2} = \\text{False} \\lor \\text{False} = \\text{False},\n$$\n所以 $\\phi$ 不是一个重言式。\n\n因此，$\\phi$ 是一个重言式，当且仅当这两个标识符在句法上是相同的。这提供了一个确定性判定过程：解析输入并测试命名 $v_{1}$ 和 $v_{2}$ 的字符串是否相等。这可以在与输入长度成线性关系的时间内完成，因此在多项式时间内完成。所以，语言 SIMPLE-TAUT 属于类 P。由于它属于 P，除非 $\\text{P}=\\text{NP}$，否则它不是 NP完全或 co-NP完全的，并且它当然是可判定的。\n\n因此，在给定的选项中，最准确的描述是 SIMPLE-TAUT 属于 P。", "answer": "$$\\boxed{A}$$", "id": "1449027"}, {"introduction": "证明 TAUT 问题是 co-NP-完全的，其关键在于它与著名的 SAT 问题（特别是其补问题 UNSAT）之间的深刻联系。本练习要求你构建一个基本的转换，将这两个问题直接联系起来。掌握这个归约是理解为什么 TAUT 属于 co-NP 复杂性类的核心。[@problem_id:1449002]", "problem": "在计算复杂性理论中，要证明一个问题对于某个复杂性类是难的，通常需要从一个已知的难问题进行归约。该领域的一个基石是可满足性问题和重言式问题之间的关系。\n\n给定一个3-合取范式（3-CNF）的布尔公式 $\\phi$。如果一个公式是若干子句的合取（AND），其中每个子句是恰好三个不同文字（一个变量或其否定）的析取（OR），则该公式为3-CNF形式。\n\n如果一个布尔公式对于其变量的每一种可能的真值赋值，其结果都为False，则称该公式是**不可满足的**。判断一个3-CNF公式是否不可满足的问题称为3-UNSAT。\n如果一个布尔公式对于其变量的每一种可能的真值赋值，其结果都为True，则称该公式为**重言式**。判断一个公式是否为重言式的问题称为TAUT。\n\n你的任务是找到一个通用的变换，从任意一个3-CNF公式 $\\phi$ 构造出一个新公式 $\\psi$，使得 $\\phi$ 是不可满足的当且仅当 $\\psi$ 是一个重言式。下列哪个构造正确地定义了这样的一个 $\\psi$？\n\nA. $\\psi = \\phi$\nB. $\\psi = \\neg \\phi$\nC. 设 $\\phi = C_1 \\land C_2 \\land \\dots \\land C_k$，其中每个 $C_i$ 是一个子句。新公式为 $\\psi = (\\neg C_1) \\land (\\neg C_2) \\land \\dots \\land (\\neg C_k)$。\nD. 设 $\\phi = C_1 \\land C_2 \\land \\dots \\land C_k$，其中每个 $C_i$ 是一个子句。新公式为 $\\psi = C_1 \\lor C_2 \\lor \\dots \\lor C_k$。\nE. 设 $x$ 是出现在 $\\phi$ 中的一个布尔变量。新公式为 $\\psi = \\phi \\land (x \\lor \\neg x)$。", "solution": "我们寻求一个变换，对于任意给定的3-CNF公式 $\\phi$，能产生一个公式 $\\psi$，使得 $\\phi$ 是不可满足的当且仅当 $\\psi$ 是一个重言式。\n\n设 $\\sigma$ 遍历 $\\phi$ 的变量的所有真值赋值。用 $\\phi[\\sigma]$ 表示 $\\phi$ 在赋值 $\\sigma$ 下的真值。根据定义：\n- $\\phi$ 是不可满足的当且仅当 $\\forall \\sigma,\\ \\phi[\\sigma] = \\mathrm{False}$。\n- $\\psi$ 是一个重言式当且仅当 $\\forall \\sigma,\\ \\psi[\\sigma] = \\mathrm{True}$。\n\n考虑变换 $\\psi = \\neg \\phi$。对于每一个 $\\sigma$，否定的布尔语义满足\n$$(\\neg \\phi)[\\sigma] = \\neg\\big(\\phi[\\sigma]\\big).$$\n因此，\n$$\\phi \\text{ 是不可满足的} \\iff \\forall \\sigma,\\ \\phi[\\sigma] = \\mathrm{False} \\iff \\forall \\sigma,\\ \\neg\\big(\\phi[\\sigma]\\big) = \\mathrm{True} \\iff \\forall \\sigma,\\ (\\neg \\phi)[\\sigma] = \\mathrm{True} \\iff \\neg \\phi \\text{ 是一个重言式}。$$\n因此，正确的构造是 $\\psi = \\neg \\phi$，即选项B。\n\n为了确认其他选项是不正确的：\n- A: $\\psi = \\phi$ 通常不能满足该双向蕴含条件，因为一个不可满足的公式永远不是一个重言式。\n- C: 如果 $\\phi = \\bigwedge_{i=1}^{k} C_{i}$，那么根据德摩根定律 $\\psi = \\bigwedge_{i=1}^{k} \\neg C_{i} = \\neg\\big(\\bigvee_{i=1}^{k} C_{i}\\big)$，这不等于 $\\neg \\phi = \\bigvee_{i=1}^{k} \\neg C_{i}$；因此它没有实现所要求的等价关系。\n- D: $\\psi = \\bigvee_{i=1}^{k} C_{i}$ 并不会在 $\\phi$ 不可满足时恰好成为重言式；$\\phi$ 的不可满足性并不意味着每个赋值都使至少一个 $C_{i}$为真，而这是该析取式成为重言式所必需的。\n- E: $\\psi = \\phi \\land (x \\lor \\neg x)$ 与 $\\phi$ 逻辑等价，因为 $x \\lor \\neg x$ 是一个重言式，所以它不会在 $\\phi$ 不可满足时恰好将任意的 $\\phi$ 转换为重言式。\n\n因此，选项中唯一正确的变换是 $\\psi = \\neg \\phi$（选项B）。", "answer": "$$\\boxed{B}$$", "id": "1449002"}, {"introduction": "在计算复杂性理论中，我们通常区分判定问题（是否存在解？）和搜索问题（找到一个解）。这个练习将向你展示如何弥合两者之间的鸿沟。通过假设你拥有一个可以解决 TAUT 判定问题的“神谕机”，你将设计一个分步过程，为任何非重言式的公式找到一个具体的证伪赋值，从而阐释强大的“搜索问题到判定问题的归约”技术。[@problem_id:1448990]", "problem": "在计算复杂性理论中，一个判定问题的预言机（oracle）是一个假设的黑箱，它可以在单个步骤内解决该问题。考虑一个预言机 `IS_TAUT`，它可以确定一个给定的布尔公式是否为重言式（tautology）。如果一个公式对于其变量的所有可能真值指派，其求值结果都为“真”，那么这个公式就是一个重言式。\n\n假设给定一个含有 $n$ 个变量的布尔公式 $\\phi(x_1, x_2, \\ldots, x_n)$，并且你知道 $\\phi$ *不是*一个重言式。这意味着存在至少一个“证伪指派” (falsifying assignment)——即一组特定的变量真/假值——使得公式 $\\phi$ 的求值结果为“假”。\n\n存在一个标准的多项式时间算法，在可以访问 `IS_TAUT` 预言机的情况下，可以找到一个这样的证伪指派。该算法通过从 $x_1$ 到 $x_n$ 依次确定每个变量的真值来运行。为此，它通过为变量代入真值来构建新公式，并查询预言机以决定哪条路径保留了存在证伪指派的可能性。\n\n考虑以下定义的特定布尔公式 $\\phi(x_1, x_2, x_3, x_4)$：\n$$ \\phi = ((\\neg x_1) \\land x_2) \\lor (x_1 \\land (\\neg x_3)) \\lor (x_2 \\implies x_4) $$\n使用标准的搜索到判定归约算法，按 $x_1, x_2, x_3, x_4$ 的顺序确定变量指派，找出该算法针对此公式 $\\phi$ 输出的特定证伪指派。在这个标准算法中，在确定变量 $x_i$ 值的每一步，算法首先检查将 $x_i$ 设为“真”是否能找到证伪指派。\n\n设真值用1表示“真”，用0表示“假”。最终答案应为一个包含四个数字的序列，代表 $(x_1, x_2, x_3, x_4)$ 的真值。", "solution": "目标是使用 TAUT 预言机找到给定布尔公式 $\\phi$ 的一个证伪指派。一个证伪指派是使 $\\phi$ 求值为假（0）的一组 $(x_1, x_2, x_3, x_4)$ 的真值。指定的算法按顺序确定 $x_1, x_2, x_3, x_4$ 的值。对于每个变量 $x_i$，它首先尝试设置 $x_i=1$（真）。它通过代入这个值来构建一个新公式，并向 `IS_TAUT` 预言机询问所得公式是否为重言式。如果预言机返回 `False`，这意味着存在一个 $x_i=1$ 的证伪指派，因此我们固定 $x_i=1$。如果预言机返回 `True`，那么原始公式的任何证伪指派都必须满足 $x_i=0$，因此我们固定 $x_i=0$。\n\n初始公式为 $\\phi_0(x_1, x_2, x_3, x_4) = ((\\neg x_1) \\land x_2) \\lor (x_1 \\land (\\neg x_3)) \\lor (x_2 \\implies x_4)$。\n我们可以简化蕴含式：$x_2 \\implies x_4 \\equiv (\\neg x_2) \\lor x_4$。\n所以，$\\phi_0 = ((\\neg x_1) \\land x_2) \\lor (x_1 \\land (\\neg x_3)) \\lor ((\\neg x_2) \\lor x_4)$。\n\n**步骤 1：确定 $x_1$ 的值。**\n让我们尝试设置 $x_1=1$。新公式 $\\phi_1$ 是将 $x_1=1$ 代入 $\\phi_0$ 得到：\n$$ \\phi_1(x_2, x_3, x_4) = ((\\neg 1) \\land x_2) \\lor (1 \\land (\\neg x_3)) \\lor ((\\neg x_2) \\lor x_4) $$\n$$ \\phi_1 = (0 \\land x_2) \\lor (\\neg x_3) \\lor ((\\neg x_2) \\lor x_4) $$\n$$ \\phi_1 = 0 \\lor (\\neg x_3) \\lor (\\neg x_2) \\lor x_4 $$\n$$ \\phi_1 = (\\neg x_2) \\lor (\\neg x_3) \\lor x_4 $$\n我们查询预言机：`IS_TAUT`($\\phi_1$)? 公式 $\\phi_1$ 不是重言式。例如，如果 $x_2=1, x_3=1, x_4=0$，那么 $\\phi_1 = (\\neg 1) \\lor (\\neg 1) \\lor 0 = 0 \\lor 0 \\lor 0 = 0$。因为 $\\phi_1$ 存在证伪指派，所以它不是重言式。\n预言机返回`False`。\n因此，算法固定 $b_1 = 1$。我们下一步骤的工作公式是 $\\phi_1$。\n\n**步骤 2：确定 $x_2$ 的值。**\n我们当前的公式是 $\\phi_1(x_2, x_3, x_4) = (\\neg x_2) \\lor (\\neg x_3) \\lor x_4$。\n让我们尝试设置 $x_2=1$。新公式 $\\phi_2$ 是将 $x_2=1$ 代入 $\\phi_1$ 得到：\n$$ \\phi_2(x_3, x_4) = (\\neg 1) \\lor (\\neg x_3) \\lor x_4 $$\n$$ \\phi_2 = 0 \\lor (\\neg x_3) \\lor x_4 $$\n$$ \\phi_2 = (\\neg x_3) \\lor x_4 $$\n我们查询预言机：`IS_TAUT`($\\phi_2$)? 公式 $\\phi_2$ 不是重言式，因为它在 $x_3=1, x_4=0$ 时为假。\n预言机返回`False`。\n因此，算法固定 $b_2 = 1$。我们下一步的工作公式是 $\\phi_2$。\n\n**步骤 3：确定 $x_3$ 的值。**\n我们当前的公式是 $\\phi_2(x_3, x_4) = (\\neg x_3) \\lor x_4$。\n让我们尝试设置 $x_3=1$。新公式 $\\phi_3$ 是将 $x_3=1$ 代入 $\\phi_2$ 得到：\n$$ \\phi_3(x_4) = (\\neg 1) \\lor x_4 $$\n$$ \\phi_3 = 0 \\lor x_4 $$\n$$ \\phi_3 = x_4 $$\n我们查询预言机：`IS_TAUT`($\\phi_3$)? 公式 $\\phi_3=x_4$ 不是重言式，因为它在 $x_4=0$ 时为假。\n预言机返回`False`。\n因此，算法固定 $b_3 = 1$。我们现在的工作公式是 $\\phi_3$。\n\n**步骤 4：确定 $x_4$ 的值。**\n我们当前的公式是 $\\phi_3(x_4) = x_4$。\n让我们尝试设置 $x_4=1$。新公式 $\\phi_4$ 是将 $x_4=1$ 代入 $\\phi_3$ 得到：\n$$ \\phi_4 = 1 $$\n我们查询预言机：`IS_TAUT`($\\phi_4$)? 公式 `1` (或“真”) 恒为真，因此根据定义，它是一个重言式。\n预言机返回`True`。\n由于设置 $x_4=1$ 导致了一个重言式，所以 $\\phi_3$ 的任何证伪指派都必须满足 $x_4 \\neq 1$。\n因此，算法固定 $b_4 = 0$。\n\n综合所有步骤的结果，算法找到的证伪指派为 $(b_1, b_2, b_3, b_4) = (1, 1, 1, 0)$。\n\n让我们验证这个结果。\n$\\phi(1, 1, 1, 0) = ((\\neg 1) \\land 1) \\lor (1 \\land (\\neg 1)) \\lor (1 \\implies 0)$\n$= (0 \\land 1) \\lor (1 \\land 0) \\lor 0$\n$= 0 \\lor 0 \\lor 0$\n$= 0$\n该指派正确地证伪了该公式。", "answer": "$$\\boxed{\\begin{pmatrix} 1 & 1 & 1 & 0 \\end{pmatrix}}$$", "id": "1448990"}]}