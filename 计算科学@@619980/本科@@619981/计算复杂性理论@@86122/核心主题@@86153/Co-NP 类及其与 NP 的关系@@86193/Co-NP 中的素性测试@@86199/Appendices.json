{"hands_on_practices": [{"introduction": "在我们深入研究素性检验的复杂性之前，让我们通过一个基础练习来热身。这个练习将帮助我们掌握复杂度类 NP 的核心机制——“证书” (certificate) 和“验证者” (verifier)。通过分析“完美幂” (perfect power) 这个语言，你将学会如何识别一个有效的证明系统，这是证明一个问题属于 NP 的基石。[@problem_id:1436744]", "problem": "在计算复杂性理论中，如果一个问题的实例的一个提议解（称为“证书”）可以在多项式时间内被验证，那么该问题对应的语言 $L$ 就属于 NP 类（非确定性多项式时间）。\n\n考虑完全幂语言 $L_{\\text{PP}}$，它由所有可以表示为 $a^k$（其中整数 $a, k \\ge 2$）形式的正整数 $n$ 组成。一个判断是否属于该语言的算法，其输入为一个整数 $n$。此输入的规模由表示 $n$ 所需的比特数来衡量，我们记作 $B = \\lfloor \\log_2 n \\rfloor + 1$。如果一个验证机的运行时间以 $B$ 的多项式为界，则认为它在多项式时间内运行。\n\n一位计算机科学家正在为 $L_{\\text{PP}}$ 设计一个验证机。她有四个提案，每个提案都包含一个需要提供的证书和一个验证算法。以下哪个提案正确且最直接地证明了 $L_{\\text{PP}}$ 属于 NP 类？\n\nA. **证书：** 一个整数 $k \\ge 2$。 **验证算法：** 在区间 $[2, n]$ 中对整数 $a$ 进行二分搜索，以检查是否有 $a^k = n$。\n\nB. **证书：** 一个整数 $a \\ge 2$。 **验证算法：** 从 $2$ 到 $n$ 遍历所有整数 $k$，并检查是否有 $a^k = n$。\n\nC. **证书：** 一对整数 $\\langle a, k \\rangle$，其中 $a, k \\ge 2$。 **验证算法：** 计算 $a^k$ 并检查其是否等于 $n$。\n\nD. **证书：** $n$ 的完整素因数分解，形式为 $p_1^{e_1} p_2^{e_2} \\cdots p_m^{e_m}$。 **验证算法：** 检查所有 $p_i$ 都是素数，它们的幂的乘积等于 $n$，并且指数集合 $\\{e_1, e_2, \\ldots, e_m\\}$ 的最大公约数大于 1。", "solution": "我们回顾 NP 验证机的定义：存在一个多项式 $p$，使得对于每个长度为 $|x|$ 的输入 $x$，都存在一个长度 $|y| \\leq p(|x|)$ 的证书 $y$ 和一个确定性验证机 $V$，该验证机在 $|x|$ 的多项式时间内运行，并且当且仅当 $x$ 属于该语言时接受。在这里，输入是一个正整数 $n$，其比特长度为 $B=\\lfloor \\log_{2} n \\rfloor + 1$。我们用 $M(B)$ 表示在标准 RAM 模型上乘以两个 $B$ 比特整数所需的时间；$M(B)$ 是关于 $B$ 的多项式。通过重复平方的快速幂算法需要 $O(\\log k)$ 次乘法。\n\n我们根据 $B$ 来分析每个提案的证书长度和验证机运行时间。\n\nA. 证书：一个整数 $k \\geq 2$。由于 $n=a^{k}$ 且 $a \\geq 2$ 意味着 $2^{k} \\leq n$，任何有效的证书都满足 $k \\leq \\log_{2} n$，因此其比特长度为 $O(\\log k) \\leq O(\\log \\log n)=O(\\log B)$，这是关于 $B$ 的多项式。验证机在 $[2,n]$ 中对 $a$ 进行二分搜索。函数 $f(a)=a^{k}$ 在 $a \\geq 1$ 时是严格递增的，所以二分搜索需要 $O(\\log n)=O(B)$ 次迭代。在每次迭代中，通过重复平方计算 $a^{k}$ 需要 $O(\\log k)$ 次乘法，而且如果中间值超过 $n$ 我们可以提前中止，所以所有中间值最多有 $B$ 比特。因此，单次幂运算的成本为 $O(M(B)\\log k) \\leq O(M(B)\\log B)$。总时间为 $O(B \\cdot M(B) \\cdot \\log B)$，这是关于 $B$ 的多项式。因此，A 是一个有效的 NP 验证过程。\n\nB. 证书：一个整数 $a \\geq 2$。证书长度为 $O(\\log a) \\leq O(B)$，但验证机需要从 $2$ 迭代到 $n$ 来遍历 $k$，这将是 $\\Theta(n)$ 次迭代。由于 $n$ 有 $B$ 比特， $n$ 可能大到 $2^{B}$，因此一个长度为 $\\Theta(n)$ 的循环是关于 $B$ 指数级的，而不是多项式级的。因此，B 未能证明其属于 NP。\n\nC. 证书：一对整数 $\\langle a,k \\rangle$，其中 $a,k \\geq 2$。由于 $a^{k}=n$ 且 $a \\geq 2$ 意味着 $a \\leq n$ 和 $k \\leq \\log_{2} n$，证书长度为 $O(\\log a + \\log k) \\leq O(B + \\log B)=O(B)$。验证机通过重复平方计算 $a^{k}$，如果中间值超过 $n$ 就中止，确保所有中间值最多有 $B$ 比特。这需要 $O(\\log k)$ 次乘法，所以耗时为 $O(M(B)\\log k) \\leq O(M(B) B)$，外加一次与 $n$ 的 $O(B)$ 比较。因此，验证过程在关于 $B$ 的多项式时间内运行。这是最简单、最直接的 NP 证书：它恰好提供了见证 $\\langle a,k \\rangle$ 并检查 $a^{k}=n$。\n\nD. 证书：素因数分解 $n=\\prod_{i=1}^{m} p_{i}^{e_{i}}$。该证书的大小为 $O\\!\\left(\\sum_{i=1}^{m} \\log p_{i} + \\sum_{i=1}^{m} \\log e_{i}\\right)$。由于 $\\sum \\log p_{i} \\leq \\log n = O(B)$ 且每个 $e_{i} \\leq \\log_{2} n$，其中 $m \\leq B$，我们有 $\\sum \\log e_{i} \\leq m \\log \\log n = O(B \\log B)$。因此证书长度是关于 $B$ 的多项式。验证机在多项式时间内确定性地检查每个 $p_{i}$ 的素性（例如，通过 AKS 算法），在 $O(B \\cdot M(B))$ 时间内计算 $\\prod p_{i}^{e_{i}}$ 的乘积并与 $n$ 比较，并在关于 $\\log \\max e_{i} \\leq O(\\log B)$ 的多项式时间内计算 $\\gcd(e_{1},\\ldots,e_{m})$。因此，D 也是一个有效的 NP 验证过程。\n\n在有效的提案中，C 是证明 $L_{\\text{PP}} \\in \\text{NP}$ 最直接的方法，因为它使用了自然的见证 $\\langle a,k \\rangle$ 和一个简单的多项式时间检查 $a^{k}=n$，而没有使用辅助的复杂子程序或额外的搜索。", "answer": "$$\\boxed{C}$$", "id": "1436744"}, {"introduction": "现在，我们将挑战一个更微妙的问题，它的结构与 co-NP 语言非常相似。`NONSEMIPRIME` 语言包含那些*不*是两个不同素数乘积的整数。这个练习将锻炼你设计证书的能力，以高效地证明一个对象*不具备*某种特定结构，这是理解 co-NP 的关键思维方式。[@problem_id:1436741]", "problem": "在计算复杂性理论中，如果一个语言 $L$ 属于 NP 类（非确定性多项式时间），那么存在一个多项式时间的确定性验证算法 $V$ 和一个多项式 $p$，使得对于任何输入字符串 $x$：\n1.  如果 $x \\in L$，存在一个长度至多为 $p(|x|)$ 的证书字符串 $c$，使得 $V(x, c)$ 接受。\n2.  如果 $x \\notin L$，那么对于所有可能的证书字符串 $c$，$V(x, c)$ 都会拒绝。\n\n我们来定义在大于1的整数集合上的语言 `NONSEMIPRIME`。一个整数 $n > 1$ 如果是两个不同素数的乘积，则称其为半素数。语言 `NONSEMIPRIME` 包含所有大于1但*不是*半素数的整数。一个整数 $n$ 属于 `NONSEMIPRIME`，如果它是素数，或者是单个素数的幂（$p^k$，$k \\geq 2$），或者是三个或更多素数因子（计入重数）的乘积。\n\n一个用于 `NONSEMIPRIME` 的完整验证器需要处理几种情况。以下哪个选项描述的证书 $c$ 和相应的验证逻辑 $V(n, c)$ 可以作为这样一个系统的有效组成部分？一个组成部分被认为是有效的，条件是其验证过程的时间复杂度是 $\\log(n)$ 的多项式，并且验证器的“接受”结果能保证整数 $n$ 属于 `NONSEMIPRIME`。\n\nA. 证书 $c$ 是一对整数 $(p, q)$。验证器检查 $p$ 和 $q$ 是不同的素数，并且 $n = p \\times q$。\nB. 证书 $c$ 是一个整数 $d$。验证器检查 $d$ 是 $n$ 的一个非平凡因子（即 $1 < d < n$）。\nC. 证书 $c$ 是一对整数 $(d, w)$。验证器检查 $d$ 是 $n$ 的一个非平凡因子（即 $1 < d < n$），并且 $w$ 是 $d$ 的一个非平凡因子（即 $1 < w < d$）。\nD. 证书 $c$ 是一个整数 $a$，满足 $1 < a < n$。验证器检查是否 $a^{n-1} \\equiv 1 \\pmod{n}$。", "solution": "我们分析每个建议的证书-验证器组件，以检查两个属性：(i) 验证过程在输入大小（即 $O(\\log n)$）的多项式时间内运行，以及 (ii) 只要验证器接受，就能保证 $n$ 属于 `NONSEMIPRIME`（即，$n$ 不是两个不同素数的乘积）。\n\n选项 A：$c=(p,q)$，检查 $p$ 和 $q$ 均为素数且 $n=pq$ 同时 $p \\neq q$。\n- 验证复杂度：使用素性测试，可以在多项式时间内确定性地检查 $p$ 和 $q$ 的素性；检查 $pq=n$ 的时间是 $\\log n$ 的多项式。因此，验证过程是 $\\log n$ 的多项式时间。\n- 对于 `NONSEMIPRIME` 的可靠性：如果验证器接受，那么 $n=pq$（$p, q$ 为不同素数），所以 $n$ 是一个半素数。因此 $n \\notin \\text{NONSEMIPRIME}$。所以，接受并不能保证 $n$ 属于 `NONSEMIPRIME`。选项 A 无效。\n\n选项 B：$c=d$，检查 $1<d<n$ 且 $d \\mid n$。\n- 验证复杂度：通过整数除法，检查 $1<d<n$ 和 $d \\mid n$ 的过程是 $\\log n$ 的多项式时间。\n- 对于 `NONSEMIPRIME` 的可靠性：如果 $n$ 是一个由不同素数构成的半素数 $n=pq$，那么取 $d=p$ 会得出 $1<d<n$ 且 $d \\mid n$，所以验证器会接受一个半素数。因此，接受并不能保证 $n \\in \\text{NONSEMIPRIME}$。选项 B 无效。\n\n选项 C：$c=(d,w)$，检查 $1<d<n$，$d \\mid n$，以及 $1<w<d$，$w \\mid d$。\n- 验证复杂度：所有检查都是整数比较和可除性测试，这些都是 $\\log n$ 的多项式时间。\n- 对于 `NONSEMIPRIME` 的可靠性：如果验证器接受，那么存在整数 $w, d$ 满足 $1<w<d<n$，$w \\mid d$ 且 $d \\mid n$。这意味着 $d$ 是 $n$ 的一个合数真因子。如果 $n$ 是一个半素数 $n=pq$（其中 $p, q$ 为不同的素数），其大于1的真因子只有 $p$ 和 $q$，两者都是素数。因此，一个半素数不可能有合数真因子。所以，接受意味着 $n \\notin \\{pq: p,q \\text{ 是不同素数}\\}$，即接受意味着 $n \\in \\text{NONSEMIPRIME}$。选项 C 作为一个组件是有效的。\n\n选项 D：$c=a$，检查 $1<a<n$ 且 $a^{n-1} \\equiv 1 \\pmod{n}$。\n- 验证复杂度：模幂运算可以在 $\\log n$ 的多项式时间内完成。\n- 对于 `NONSEMIPRIME` 的可靠性：存在形如 $pq$（其中 $p, q$ 为不同素数）的合数 $n$（即半素数），它们是关于某个基 $a$ 的伪素数，满足 $a^{n-1} \\equiv 1 \\pmod{n}$。例如，$n=341=11 \\cdot 31$ 和 $a=2$ 满足 $2^{340} \\equiv 1 \\pmod{341}$。因此，验证器可能会接受一个半素数，所以接受并不能保证 $n \\in \\text{NONSEMIPRIME}$。选项 D 无效。\n\n因此，在这些选项中，只有选项 C 是一个有效的组件：它的接受保证了 $n$ 属于 `NONSEMIPRIME`，并且其验证过程在 $\\log n$ 的多项式时间内运行。", "answer": "$$\\boxed{C}$$", "id": "1436741"}, {"introduction": "最后的这个练习将我们带到本章的核心主题：证明一个语言属于 co-NP。我们将通过为其补集——即至少有两个不同素因子的数的语言——设计一个证书，来直接证明素数幂的语言在 co-NP 中。这个练习不仅巩固了 NP 和 co-NP 之间的关系，还展示了如何用一个简洁的证书来优雅地证明一个数的合数特性。[@problem_id:1436748]", "problem": "在计算复杂性理论中，一个关键概念是“证书”（certificate）或“见证”（witness）。对于一个给定的语言 $L$（一个由字符串组成的集合，在本例中是整数），输入 $n$ 的一个证书是一条信息 $y$，它能让一个验证算法高效地确认 $n$ 确实在 $L$ 中。一个验证者 $V(n, y)$ 必须在关于 $n$ 的规模（即关于 $\\log_2 n$）的多项式时间内运行，并且必须满足两个条件：\n1.  **完备性**：对于每个 $n \\in L$，都存在一个证书 $y$（其规模是关于 $\\log_2 n$ 的多项式），使得 $V(n,y)$ 接受。\n2.  **可靠性**：对于任何 $n \\notin L$，验证者 $V(n,y)$ 对所有可能的证书 $y$ 都必须拒绝。\n\n考虑一个语言 $L$，它是由至少包含两个不同素因子的正整数组成的。例如，$12 = 2^2 \\cdot 3$ 在 $L$ 中，但 $17$（一个素数）和 $8 = 2^3$（一个素数幂）不在 $L$ 中。\n\n以下关于证书 $y$ 的提议中，哪些可以有效地证明一个整数 $n$ 属于语言 $L$？\n\nA. 两个整数 $u,v$，使得 $u > 1, v > 1$ 且 $n = uv$。\nB. 一个整数 $d$，使得 $1 < d < n$ 且 $d$ 整除 $n$。\nC. 两个整数 $u,v$，使得 $u > 1, v > 1, n = uv$，且它们的最大公约数 $\\gcd(u,v) = 1$。\nD. 一个整除 $n$ 的素数 $p$，以及一个整数 $m > 1$，使得 $m$ 也整除 $n$ 且 $\\gcd(p,m) = 1$。\nE. 两个都整除 $n$ 的不同素数 $p_1, p_2$。\n\n选择所有有效选项。", "solution": "我们将语言 $L$ 形式化为素因数分解中包含至少两个不同素数的正整数 $n$ 的集合。等价地，$n \\in L$ 当且仅当存在不同的素数 $p_{1}$ 和 $p_{2}$ 使得 $p_{1} \\mid n$ 且 $p_{2} \\mid n$。\n\n对于 $n \\in L$ 的证书 $y$，必须能让一个确定性验证者 $V(n,y)$ 在 $\\log_2 n$ 的多项式时间内检查出 $n$ 确实有至少两个不同的素因子。我们对每个提议进行可靠性（绝不接受 $n \\notin L$）和完备性（对于每个 $n \\in L$，都存在这样的证书）两方面的评估，并确保验证工作在 $n$ 的位长度上是多项式时间的。\n\n关于高效检查的预备知识：\n- 可除性检查“$a \\mid b$”、等式检查以及通过欧几里得算法计算 $\\gcd(a,b)$，其运行时间都是输入位长度的多项式时间，因此也是 $\\log_2 n$ 的多项式时间。\n- 一个声称的素数的素性，可以在其位长度的多项式时间内确定性地验证（例如，AKS 素性检验）。因此，在验证者的时间限制内，检查一个整数是否为素数是可行的。\n- 证书的大小必须是 $\\log_2 n$ 的多项式；作为因子或素数提供的所有整数最多为 $n$，因此它们的编码是 $O(\\log_2 n)$ 位。\n\n选项 A：两个整数 $u,v$ 满足 $u>1$，$v>1$ 且 $n=uv$。\n- 验证：检查 $u>1$，$v>1$ 和 $uv=n$。这是多项式时间的。\n- 可靠性：失败。考虑 $n$ 是一个素数幂，例如 $n=2^{3}$。取 $u=2, v=2^{2}$ 满足 $u>1, v>1$ 和 $uv=n$，但 $n \\notin L$。因此，存在 $n \\notin L$ 却有一个会被接受的证书。所以A是不可靠的，是无效的。\n\n选项 B：一个整数 $d$ 满足 $1<d<n$ 且 $d \\mid n$。\n- 验证：检查 $1<d<n$ 和 $d \\mid n$。这是多项式时间的。\n- 可靠性：失败，原因与A相同。如果 $n$ 是一个素数幂，例如 $n=2^{3}$，那么 $d=2$ 是一个满足 $1<d<n$ 的有效因子，但 $n \\notin L$。所以B是不可靠的，是无效的。\n\n选项 C：两个整数 $u,v$ 满足 $u>1$，$v>1$，$n=uv$ 且 $\\gcd(u,v)=1$。\n- 验证：检查 $u>1$，$v>1$，$uv=n$ 和 $\\gcd(u,v)=1$。这些都是多项式时间的。\n- 可靠性：假设验证者接受，即 $u>1, v>1, n=uv$ 且 $\\gcd(u,v)=1$。由于 $u>1$ 和 $v>1$，它们各自至少有一个素因子，比如说 $p \\mid u$ 和 $q \\mid v$。条件 $\\gcd(u,v)=1$ 意味着 $p \\neq q$。因为 $p \\mid u$ 且 $u \\mid n$，我们有 $p \\mid n$；同理 $q \\mid n$。因此 $n$ 至少有两个不同的素因子，所以 $n \\in L$。因此可靠性成立。\n- 完备性：如果 $n \\in L$，可写作 $n = \\prod_{i=1}^k p_i^{\\alpha_i}$，其中 $k \\geq 2$ 且 $p_i$ 是不同的素数。选择任意一个索引 $j$，设 $u=p_{j}^{\\alpha_{j}}$ 且 $v=n/u = \\prod_{i \\neq j} p_i^{\\alpha_i}$。那么 $u>1, v>1, uv=n$，并且因为它们没有共同的素因子，所以 $\\gcd(u,v)=1$。因此这样的证书存在。因此完备性成立。所以C是有效的。\n\n选项 D：一个素数 $p$ 满足 $p \\mid n$，以及一个整数 $m>1$ 满足 $m \\mid n$ 且 $\\gcd(p,m)=1$。\n- 验证：检查 $p$ 是素数、$p \\mid n$、$m>1$、$m \\mid n$ 以及 $\\gcd(p,m)=1$。所有检查在 $\\log_2 n$ 上都是多项式时间的（素性可通过多项式时间的素性检验来完成）。\n- 可靠性：如果验证者接受，那么有素数 $p$ 满足 $p \\mid n$，且有整数 $m>1$ 满足 $m \\mid n$ 和 $\\gcd(p,m)=1$。由于 $m>1$， $m$ 有一个素因子 $q$。条件 $\\gcd(p,m)=1$ 意味着 $q \\neq p$。另外，$q \\mid m$ 和 $m \\mid n$ 意味着 $q \\mid n$。因此 $n$ 至少有两个不同的素因子 $p$ 和 $q$ 整除它，所以 $n \\in L$。因此可靠性成立。\n- 完备性：如果 $n \\in L$ 的因数分解为 $n = \\prod_{i=1}^k p_i^{\\alpha_i}$ 且 $k \\geq 2$，选择 $p=p_{1}$ 和 $m=\\prod_{i=2}^{k} p_{i}^{\\alpha_{i}}$。那么 $p \\mid n, m>1, m \\mid n$ 且 $\\gcd(p,m)=1$。因此完备性成立。所以D是有效的。\n\n选项 E：两个不同的素数 $p_{1},p_{2}$ 都整除 $n$。\n- 验证：检查 $p_{1}$ 是素数，$p_{2}$ 是素数，$p_{1} \\neq p_{2}$，$p_{1} \\mid n$ 以及 $p_{2} \\mid n$。所有这些都是多项式时间的。\n- 可靠性：如果接受，那么 $n$ 有两个不同的素因子 $p_{1}$ 和 $p_{2}$，所以 $n \\in L$。因此可靠性成立。\n- 完备性：如果 $n \\in L$，根据定义，存在两个不同的素数整除 $n$。提供这两个素数就能通过验证。因此完备性成立。所以E是有效的。\n\n结论：选项 C、D 和 E 是有效的证书；选项 A 和 B 因缺乏可靠性而无效。", "answer": "$$\\boxed{CDE}$$", "id": "1436748"}]}