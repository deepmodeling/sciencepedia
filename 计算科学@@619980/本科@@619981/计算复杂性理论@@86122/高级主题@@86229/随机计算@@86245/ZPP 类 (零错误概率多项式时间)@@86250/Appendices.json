{"hands_on_practices": [{"introduction": "理解ZPP复杂性类的核心在于掌握如何分析拉斯维加斯算法的期望运行时间。这个练习提供了一个典型的场景：一个随机算法单次运行成功率不高，但每次运行所用时间是确定的。通过计算其在重复执行下的总期望运行时间，你将能够亲手验证一个算法是否满足ZPP对期望多项式时间的要求 [@problem_id:1455251]。", "problem": "复杂度类 ZPP（Zero-error Probabilistic Polynomial-time，零错误概率多项式时间）包含这样一类判定问题：它们可以由一个概率算法解决，该算法总是返回正确的答案，并且其期望运行时间是输入规模的多项式。这类算法也被称为拉斯维加斯算法（Las Vegas algorithms）。\n\n考虑一个为某个判定问题设计的随机算法 `Searcher`，其处理的输入规模为 $n$。该算法具有以下特征：\n1.  该算法从不产生错误答案。它要么返回正确的“是”（'YES'）或“否”（'NO'）解，要么报告“失败”（'FAILURE'）。\n2.  `Searcher` 的单次运行，无论成功与否，都在 $T(n) = c n^{\\alpha}$ 的时间内完成，其中 $c$ 和 $\\alpha$ 是给定的正常数。\n3.  对于一个规模为 $n$ 的给定输入，`Searcher` 单次运行成功的概率（即返回“是”或“否”）是 $p(n) = n^{-\\beta}$，其中 $\\beta$ 是一个给定的正常数。\n\n为保证得到解，我们构造一个新的主算法 `MasterSolver`，它在同一个输入上重复执行 `Searcher`，直到获得“是”或“否”的答案。请确定 `MasterSolver` 的期望总运行时间，将其表示为参数 $c$、$\\alpha$、$\\beta$ 以及输入规模 $n$ 的函数。请将您的答案表示为单个闭式解析表达式。", "solution": "令 $p(n)=n^{-\\beta}$ 表示 `Searcher` 在输入规模为 $n$ 时单次独立运行的成功概率，并令 $T(n)=c n^{\\alpha}$ 表示每次运行的确定性时间。令 $K$ 为当 `MasterSolver` 重复 `Searcher` 时，首次成功所需的运行次数。\n\n由于每次运行以概率 $p(n)$ 成功，且失败会导致重复，因此 $K$ 服从参数为 $p(n)$ 的几何分布：\n$$\n\\Pr(K=k)=(1-p(n))^{k-1}p(n), \\quad k\\in\\{1,2,\\ldots\\}.\n$$\n参数为 $p(n)$ 的几何随机变量的期望是\n$$\n\\mathbb{E}[K]=\\sum_{k=1}^{\\infty}k(1-p(n))^{k-1}p(n)=\\frac{1}{p(n)}.\n$$\n总运行时间为 $S=K\\,T(n)$，因为 $K$ 次运行中的每一次都确定性地消耗时间 $T(n)$。因此\n$$\n\\mathbb{E}[S]=\\mathbb{E}[K\\,T(n)]=T(n)\\,\\mathbb{E}[K]=c n^{\\alpha}\\cdot\\frac{1}{p(n)}.\n$$\n代入 $p(n)=n^{-\\beta}$ 得\n$$\n\\mathbb{E}[S]=c n^{\\alpha}\\cdot n^{\\beta}=c\\,n^{\\alpha+\\beta}.\n$$\n因此，`MasterSolver` 的期望总运行时间是 $c\\,n^{\\alpha+\\beta}$。", "answer": "$$\\boxed{c\\,n^{\\alpha+\\beta}}$$", "id": "1455251"}, {"introduction": "准确地定义和区分不同的复杂性类是计算理论中的一项基本功。ZPP的“零错误”特性是其区别于其他概率复杂性类（如RP）的关键。本练习设置了一个包含“单边错误”的算法场景，旨在让你清晰地辨别为何即使一个算法大部分时候是正确的，但只要它有概率输出错误答案，就不符合ZPP的严格定义 [@problem_id:1455254]。", "problem": "一位系统工程师开发了一种新的概率算法 `NetCheck`，旨在确定一个计算机网络是否完全连通。网络被表示为一个图，其中计算机是顶点，直接链接是边。`NetCheck` 的运行时间相对于网络中的顶点数量是多项式时间的。该算法经过广泛测试，得到以下一致的结果：\n\n1.  如果输入的网络图是连通的，`NetCheck` 总是输出 \"CONNECTED\"。\n2.  如果输入的网络图是不连通的，`NetCheck` 以 $1/3$ 的概率输出 \"CONNECTED\"，以 $2/3$ 的概率输出 \"DISCONNECTED\"。\n\n复杂度类“零错误概率多项式时间”（ZPP）是为判定问题定义的。如果存在一个概率算法，该算法被允许以至多 $1/2$ 的概率返回“FAIL”答案（即“我不知道”），但每当它返回“YES”或“NO”答案时，该答案必须始终是正确的，那么一个问题就属于 ZPP。此外，一个 ZPP 算法的期望运行时间必须是输入规模的多项式时间。\n\n根据 `NetCheck` 的行为和 ZPP 算法的定义，以下哪个陈述为网络连通性问题（由 `NetCheck` 算法决定的）不属于 ZPP 类的最准确原因？\n\nA. 该算法在处理不连通网络时的错误概率（$1/3$）不小于或等于一个任意小的常数。\nB. 该算法只表现出单边错误，而 ZPP 算法必须能够在“YES”和“NO”两种情况下都可能出错。\nC. 该算法可能产生不正确的“YES”或“NO”答案，这对于 ZPP 算法是禁止的。\nD. 该算法的运行时间仅在平均情况下是多项式时间，而不是在最坏情况下。\nE. 该算法从不返回“FAIL”答案，而这是任何非确定性 ZPP 算法所要求的一种可能输出。", "solution": "我们将此判定问题形式化为语言成员问题：设 $L$ 是连通图的集合，其中对于 $x \\in L$，正确的输出是“YES”，对于 $x \\notin L$，正确的输出是“NO”。\n\n根据定义，概率算法 `NetCheck` 满足：\n- 对于所有 $x \\in L$（连通图），它以概率 $1$ 输出 YES，以概率 $0$ 输出 NO。\n- 对于所有 $x \\notin L$（不连通图），它以概率 $\\frac{1}{3}$ 输出 YES，以概率 $\\frac{2}{3}$ 输出 NO。\n\n一个用于判定问题的 ZPP 算法必须满足零错误属性：它可以输出一个特殊符号（称之为 FAIL），但每当它输出 YES 或 NO 时，该答案必须是正确的。形式上，设 $A$ 是一个 ZPP 算法，对于每个输入 $x$，我们有：\n- $\\Pr[A(x) = \\text{FAIL}] \\leq \\frac{1}{2}$,\n- $\\Pr[A(x) = \\text{YES} \\mid A(x) \\neq \\text{FAIL}] = 1$ 当且仅当 $x \\in L$,\n- $\\Pr[A(x) = \\text{NO} \\mid A(x) \\neq \\text{FAIL}] = 1$ 当且仅当 $x \\notin L$,\n并且期望运行时间是输入规模的多项式时间。\n\n`NetCheck` 违反了零错误要求，因为存在 $x \\notin L$ 的情况，使得它以正概率 $\\frac{1}{3}$ 输出 YES。也就是说，`NetCheck` 可以在“NO”实例上产生不正确的“YES”答案。因此，无论其运行时间如何，`NetCheck` 都不是一个 ZPP 算法。\n\n我们现在评估各个选项：\n- A 是不正确的，因为 ZPP 要求在 YES/NO 输出上零错误，而不仅仅是一个小的错误概率；此外，通过重复来减少错误与 ZPP 的零错误标准无关。\n- B 是不正确的，因为 ZPP 不要求双边错误；它要求在确定性答案上零错误。\n- C 是正确的：`NetCheck` 可以输出不正确的 YES（并且从不输出 FAIL），这对于 ZPP 算法是禁止的。\n- D 是不正确的，因为 ZPP 要求期望多项式时间，而非最坏情况多项式时间；`NetCheck` 的时间限制在这里不是问题。\n- E 是不正确的，因为 ZPP 算法被允许返回 FAIL，但不是必须这样做；只要没有错误，缺少 FAIL 并不排除 ZPP，而 `NetCheck` 存在错误。\n\n因此，最准确的原因是 `NetCheck` 可能产生不正确的 YES 或 NO 答案，这违反了 ZPP 的零错误要求。", "answer": "$$\\boxed{C}$$", "id": "1455254"}, {"introduction": "优秀的复杂性类通常在其基本运算下是封闭的，这保证了我们可以通过组合已知的算法来解决更复杂的问题。这个练习将引导你从分析转向设计，要求你利用两个已知的ZPP算法来为它们的语言连接（concatenation）构建一个新的ZPP算法。这不仅能加深你对ZPP算法期望时间分析的理解，还能让你体会到复杂性类的闭包性质在算法设计中的实际应用 [@problem_id:1455255]。", "problem": "在计算复杂性理论中，ZPP类（代表零错误概率多项式时间）表示可通过一种概率算法求解的问题，该算法总是正确的，并在期望多项式时间内运行。用于判定问题的 ZPP 算法可以输出“是”、“否”或“未知”（通常表示为 '?'）。它具有以下两个关键属性：\n1.  它从不返回不正确的答案（即，如果真实答案是“是”，它从不输出“否”，反之亦然）。\n2.  对于任何给定的输入，其返回“未知”的概率最多为 $1/2$。\n\n考虑在同一字母表上的两种语言 $L_1$ 和 $L_2$。给定两个 ZPP 算法 $A_1$ 和 $A_2$，它们分别判定 $L_1$ 和 $L_2$ 的成员关系。对于长度为 $k$ 的输入， $A_1$ 的期望运行时间由 $T_1(k) = C_1 k^{a_1}$ 给出，而 $A_2$ 的期望运行时间由 $T_2(k) = C_2 k^{a_2}$ 给出。此处，$C_1, C_2, a_1,$ 和 $a_2$ 是给定的正常数。\n\n任务是设计一个新的 ZPP 算法 $A_{cat}$，用于判定连接语言 $L_{cat} = L_1 L_2 = \\{uv \\mid u \\in L_1 \\text{ and } v \\in L_2\\}$ 的成员关系。确定该算法 $A_{cat}$ 在处理长度为 $n$ 的输入字符串时，其最坏情况期望运行时间的最紧多项式上界。为简化最终推导，可将任何形如 $\\sum_{i=0}^{n} g(i)$ 的和式用积分 $\\int_0^n g(x) dx$ 来近似。请用 $n, C_1, C_2, a_1$ 和 $a_2$ 的符号表达式来表示答案。", "solution": "根据问题描述，我们有两个ZPP算法 $A_1$ 和 $A_2$ 分别用于判定语言 $L_1$ 和 $L_2$。对于一个长度为 $k$ 的输入，运行算法 $A_1$ 得到一个确定性（且正确）答案所需的期望时间是 $T_1(k) = C_1 k^{a_1}$。类似地，运行算法 $A_2$ 所需的期望时间是 $T_2(k) = C_2 k^{a_2}$。这些是完整的ZPP算法的期望运行时间，已经包含了内部可能需要的重复执行步骤。\n\n按如下方式设计 $A_{cat}$。对于长度为 $n$ 的输入 $x$，对于每个分割索引 $i\\in\\{0,1,\\dots,n\\}$，令 $u=x[1..i]$ 且 $v=x[i+1..n]$。对于每个 $i$：\n- 在 $u$ 上运行 ZPP 算法 $A_1$。如果它返回“是”，则进行下一步。如果返回“否”，则继续处理下一个 $i$。\n- 在 $v$ 上运行 ZPP 算法 $A_2$。如果它返回“是”，则接受并停止。如果返回“否”，则继续处理下一个 $i$。\n如果处理完所有分割都没有接受，则拒绝。该算法是零错误的，因为 $A_1$ 和 $A_2$ 从不犯错，并且我们只在两部分都得到确定的“是”时才接受。它总能停止并给出正确答案。\n\n我们现在来界定最坏情况的期望运行时间。这发生在输入 $x$ 不属于 $L_{cat}$ 时，因为算法必须检查所有可能的分割。对于一个固定的分割 $i$，检查 $u \\in L_1$ 和 $v \\in L_2$ 的期望时间是 $T_1(i) + T_2(n-i)$。利用期望的线性性质，总的最坏情况期望运行时间是对所有分割的期望时间求和：\n$$\n\\mathbb{E}[T_{cat}(n)] = \\sum_{i=0}^{n}\\left(T_1(i) + T_2(n-i)\\right) = \\sum_{i=0}^{n}\\left(C_{1}i^{a_{1}}+C_{2}(n-i)^{a_{2}}\\right)\n$$\n$$\n=C_{1}\\sum_{i=0}^{n}i^{a_{1}}+C_{2}\\sum_{i=0}^{n}(n-i)^{a_{2}}.\n$$\n注意到 $\\sum_{i=0}^{n}(n-i)^{a_{2}} = \\sum_{j=0}^{n}j^{a_{2}}$。为了得到最紧的多项式上界，并根据允许的近似方法，我们用相应的积分来近似每个和式：\n$$\n\\sum_{i=0}^{n}i^{a}\\approx \\int_{0}^{n}x^{a}\\,dx=\\frac{n^{a+1}}{a+1}.\n$$\n将此应用于两个和式，得到\n$$\n\\mathbb{E}[T_{cat}(n)]\\approx \\frac{C_{1}}{a_{1}+1}\\,n^{a_{1}+1}+\\frac{C_{2}}{a_{2}+1}\\,n^{a_{2}+1}.\n$$\n因此，$A_{cat}$ 的最坏情况期望运行时间的最紧多项式上界（忽略低阶项）是这两个主导项的和。", "answer": "$$\\boxed{\\frac{C_{1}}{a_{1}+1}\\,n^{a_{1}+1}+\\frac{C_{2}}{a_{2}+1}\\,n^{a_{2}+1}}$$", "id": "1455255"}]}