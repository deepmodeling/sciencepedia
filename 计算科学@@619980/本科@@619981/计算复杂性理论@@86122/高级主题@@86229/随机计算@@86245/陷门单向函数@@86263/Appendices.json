{"hands_on_practices": [{"introduction": "要真正理解陷门单向函数，最好的方法是亲手分析一个具体的例子。这个练习 [@problem_id:1467639] 提供了一个在密码学中常见的函数结构，你需要剖析它的属性，以确定它是否符合陷门单向函数的定义。这项实践将帮助你巩固关于单向性、陷门信息以及如何利用陷门进行反演的核心概念。", "problem": "在公钥密码学的研究中，陷门单向函数的概念是基础性的。如果一个函数对于任何给定的输入都易于计算，但从给定的输出确定输入在计算上是不可行的，那么该函数被认为是**单向的**。**陷门单向函数**是一种特殊的单向函数，其求逆过程变得容易，当且仅当持有者拥有被称为“陷门”的特定秘密信息。\n\n考虑一个大素数阶 $q$ 的有限循环群 $G$，其生成元 $g$ 已知。群运算用 $\\cdot$ 表示。设 $h$ 是 $G$ 中的一个公共元素，其构造方式为 $h=g^x$，其中 $x \\in \\{1, 2, \\ldots, q-1\\}$ 是一个秘密整数。你可以假设在 $G$ 中解决离散对数问题 (DLP)——即在给定 $g$ 和 $h$ 的情况下求解 $x$——在计算上是不可行的。\n\n现在，分析函数 $f: G \\times \\mathbb{Z}_q \\to G \\times G$，其定义如下：\n$f(m, r) = (g^r, m \\cdot h^r)$\n其中 $m \\in G$ 是消息，$r \\in \\mathbb{Z}_q$ 是一个随机选择的整数。知道秘密的授权接收者的主要目标，是在收到输出 $(c_1, c_2) = f(m, r)$ 后，恢复原始消息 $m$。\n\n在 DLP 是困难问题的假设下，下列哪个陈述最准确地描述了函数 $f(m, r)$ 的属性？\n\nA. 函数是陷门单向函数，陷门是秘密指数 $x$。\nB. 函数是陷门单向函数，陷门是随机整数 $r$。\nC. 函数是陷门单向函数，陷门是消息 $m$。\nD. 函数是单向函数，但没有陷门。\nE. 函数不是单向函数，因为任何一方都可以轻易地将其求逆。", "solution": "我们在一个素数阶 $q$、生成元为 $g$ 的有限循环群 $G$ 中进行操作。公钥是 $h=g^{x}$，其中 $x \\in \\{1,2,\\ldots,q-1\\}$ 是秘密。函数为 $f(m,r)=(c_{1},c_{2})=(g^{r},\\,m \\cdot h^{r})$，其中 $m \\in G$ 且 $r \\in \\mathbb{Z}_{q}$。\n\n首先，展示知道 $x$ 的授权接收者如何从 $(c_{1},c_{2})$ 恢复 $m$。使用定义 $c_{1}=g^{r}$ 和陷门 $x$，计算\n$$\ns=c_{1}^{x}=(g^{r})^{x}=g^{rx}=h^{r}.\n$$\n这利用了 $G$ 中的标准幂运算以及关系式 $h=g^{x}$。然后通过乘以 $s^{-1}=(h^{r})^{-1}$ 来对 $c_{2}=m \\cdot h^{r}$ 进行求逆：\n$$\nm=c_{2}\\cdot s^{-1}=m \\cdot h^{r} \\cdot (h^{r})^{-1}=m.\n$$\n因此，在给定 $x$ 的情况下，从 $(c_{1},c_{2})$ 恢复 $m$ 是高效的，这证明了使用陷门 $x$ 的高效求逆算法的存在性。\n\n接下来，论证在没有 $x$ 的情况下，根据所述的困难性假设，求逆是不可行的。从 $(c_{1},c_{2})$ 中，为了得到 $m$，需要 $h^{r}$。有两条自然的途径：\n1. 从 $c_{1}=g^{r}$ 恢复 $r$，然后计算 $h^{r}$；但求解 $r$ 正是在 $G$ 中的离散对数问题，而该问题被假设是困难的。\n2. 通过计算 $g^{xr}$ 直接从 $(g^{x},g^{r})$ 计算出 $h^{r}$；这是计算性 Diffie–Hellman 问题。尽管问题陈述仅假设了 DLP 的困难性，但任何能通过为任意 $(c_{1},c_{2})$ 输出 $m$ 来对 $f$ 进行求逆的算法，尤其是在 $m$ 对攻击者未知的情况下，将允许恢复 $m$，而这需要从 $(g^{x},g^{r})$ 计算出 $h^{r}$；在没有陷门 $x$ 的情况下，这被认为是不可行的。\n\n因此，在 DLP 困难性假设下，对于缺少 $x$ 的一方，$f$ 是单向的，而拥有 $x$ 的一方可以高效地进行求逆以恢复 $m$。随机数 $r$ 是临时的，而不是一个能够对所有输出进行求逆的固定秘密；消息 $m$ 本身不是陷门；并且该函数不能被任意一方轻易求逆。\n\n因此，正确的定性是，$f$ 是一个以 $x$ 为陷门的陷门单向函数。", "answer": "$$\\boxed{A}$$", "id": "1467639"}, {"introduction": "陷门函数的安全性依赖于其反演的“计算困难性”。这个练习 [@problem_id:1467625] 将通过一个思想实验来探索这种困难性的理论边界，假设你拥有一台能够解决著名的布尔可满足性问题 (SAT) 的神奇“预言机”。通过将破解函数的问题转化为一个 SAT 实例，你将能更深刻地理解密码学的安全性与计算复杂性理论基本原理之间的紧密联系。", "problem": "一位密码学家正在分析一个新提出的公钥密码方案。该方案的安全性依赖于一个陷门单向置换族。该置换族由一个生成算法 $\\text{Gen}$ 定义，当输入一个安全参数 $n$ 时，它会输出一对密钥 $(pk, sk)$。公钥 $pk$ 定义了一个置换 $f_{pk}: \\{0,1\\}^{n} \\to \\{0,1\\}^{n}$，而私钥 $sk$ 则是允许对 $f_{pk}$ 进行高效求逆的陷门。\n\n公钥 $pk$ 包含一个布尔电路 $C_{pk}$ 的完整描述，该电路计算函数 $f_{pk}$。电路 $C_{pk}$ 接受一个 $n$ 比特的输入并产生一个 $n$ 比特的输出。电路的大小，记为 $s(n)$，定义为它所包含的逻辑门（例如，与门、或门、非门）的总数。\n\n一个攻击者截获了一个值 $y \\in \\{0,1\\}^{n}$，并且可以访问公钥 $pk$，但无法访问私钥 $sk$。攻击者的目标是找到唯一的原像 $x \\in \\{0,1\\}^{n}$，使得 $f_{pk}(x) = y$。\n\n攻击者获得了一个强大的计算预言机 $O_\\text{SAT}$ 的访问权限。这个预言机解决布尔可满足性问题 (SAT)。当给定一个用变量 $v_1, v_2, \\ldots$ 表示的布尔公式时，如果存在一组对变量的`真`/`假`赋值能使整个公式为`真`，则预言机返回`真`，否则返回`假`。关键是，如果公式是可满足的，预言机还会为所有变量提供一个这样的可满足赋值。\n\n为了找到原像 $x$，攻击者计划构造一个单一的布尔公式 $\\Phi$，并只查询一次 $O_\\text{SAT}$ 预言机。$\\Phi$ 的变量将代表未知输入 $x$ 的比特位以及电路 $C_{pk}$ 内部连线上的逻辑值。这个公式 $\\Phi$ 所需的布尔变量的最小总数是多少，用 $n$ 和 $s(n)$ 的函数表示？", "solution": "我们需要一个单一的SAT实例来捕捉以下约束：大小为 $s(n)$ 的电路 $C_{pk}$ 将一个未知输入 $x \\in \\{0,1\\}^{n}$ 映射到给定的输出 $y \\in \\{0,1\\}^{n}$。这些变量必须编码：\n- 未知输入 $x$ 的 $n$ 个输入比特，以及\n- $C_{pk}$ 内部连线所承载的逻辑值。\n\n使用一个标准的电路到SAT（Tseitin风格）编码：\n1) 为主输入引入 $n$ 个变量 $x_{1},\\dots,x_{n}$。\n2) 对于 $C_{pk}$ 中的 $s(n)$ 个门 $g_{1},\\dots,g_{s(n)}$ 中的每一个，引入一个变量 $z_{j}$ 来表示门 $g_{j}$ 的输出线（逻辑值）。通过将 $z_{j}$ 与其门的输入文字相关联的子句来强制每个门的功能。除了每个门的一个输出变量外，这不会引入额外的变量。\n3) 对于每个电路输出比特，约束相应的连线变量等于 $y$ 的已知比特。这是通过单元子句（例如，$z_{o(i)}$ 或 $\\lnot z_{o(i)}$）完成的，因此不使用新的变量。\n\n因此，公式中布尔变量的总数恰好是主输入变量的数量加上每个门输出的一个变量：\n$$\nn + s(n).\n$$\n\n最小性：根据问题的规定，$\\Phi$ 的变量“代表未知输入 $x$ 的比特位以及电路 $C_{pk}$ 内部连线上的逻辑值”。有 $n$ 个输入比特和恰好 $s(n)$ 个不同的内部门输出信号，其逻辑值必须被表示，因此至少需要 $n + s(n)$ 个变量。此外，等于 $y$ 的输出可以通过单元子句来强制，而无需创建额外的变量。因此，所需的最小变量总数为 $n + s(n)$。", "answer": "$$\\boxed{n+s(n)}$$", "id": "1467625"}, {"introduction": "在现实世界的密码学中，我们常常通过组合更简单的、已证明安全的基础模块来构建复杂的系统。这个练习 [@problem_id:1467638] 将挑战你像密码学家一样思考：一个由两个安全的陷门置换组合而成的新函数，其自身是否仍然安全？这项实践突出了在设计加密系统时，对组件组合的安全性进行形式化证明和严谨推理的重要性。", "problem": "在密码学领域，陷门单向置换族是一个基本概念。它由一个三元组的概率多项式时间（PPT）算法 $(\\text{Gen}, \\text{Eval}, \\text{Invert})$ 正式定义。\n\n1.  $\\text{Gen}(1^n)$: 一个密钥生成算法，其输入为安全参数 $n$，输出一对密钥，即一个公钥 $pk$ 和一个私钥（或陷门）$sk$。\n2.  $\\text{Eval}(pk, x)$: 一个求值算法，用于计算函数 $f_{pk}(x)$。对于任何固定的 $pk$，$f_{pk}$ 是其定义域 $D_{pk}$ 上的一个置换。\n3.  $\\text{Invert}(sk, y)$: 一个求逆算法，它使用陷门 $sk$ 来计算逆 $f_{pk}^{-1}(y)$。\n\n为使该元组成为一个安全的陷门单向置换族，它必须满足两个条件：\n- **正确性**：对于由 $\\text{Gen}(1^n)$ 生成的任何密钥对 $(pk, sk)$ 以及任何 $x \\in D_{pk}$，必须有 $\\text{Invert}(sk, \\text{Eval}(pk, x)) = x$。\n- **安全性**：对于任何PPT敌手 $\\mathcal{A}$，$\\mathcal{A}(pk, \\text{Eval}(pk, x)) = x$ 的概率在安全参数 $n$ 上是可忽略的。该概率是针对从 $\\text{Gen}(1^n)$ 中选择的 $(pk, sk)$、从定义域 $D_{pk}$ 中随机选择的 $x$ 以及 $\\mathcal{A}$ 的内部随机性来计算的。\n\n现在，考虑两个不同的、安全的陷门单向置换族, $\\mathcal{F}_1 = (\\text{Gen}_1, \\text{Eval}_1, \\text{Invert}_1)$ 和 $\\mathcal{F}_2 = (\\text{Gen}_2, \\text{Eval}_2, \\text{Invert}_2)$，它们分别在定义域 $D_1$ 和 $D_2$ 上运行。\n\n我们构造一个新的函数族 $\\mathcal{F}$，作为 $\\mathcal{F}_1$ 和 $\\mathcal{F}_2$ 的直积。生成算法 $\\text{Gen}_F(1^n)$ 的工作方式是：运行 $\\text{Gen}_1(1^n)$ 得到 $(pk_1, sk_1)$，运行 $\\text{Gen}_2(1^n)$ 得到 $(pk_2, sk_2)$，然后输出组合密钥 $pk_F = (pk_1, pk_2)$ 和 $sk_F = (sk_1, sk_2)$。函数 $F_{pk_F}$ 在定义域 $D_1 \\times D_2$ 上的定义如下：\n$$F_{pk_F}(x, y) = (\\text{Eval}_1(pk_1, x), \\text{Eval}_2(pk_2, y))$$\n\n新的函数族 $\\mathcal{F}$ 是否必然是一个安全的陷门单向置换族？\n\nA. 是。组合函数的安全性可以形式化地归约到其组件的安全性。如果组合函数可以被求逆，那么至少有一个组件函数可以被求逆，这与初始假设相矛盾。\nB. 否。一个族的安全性定义只要求对于大多数公钥来说求逆是困难的。有可能对于与 $pk_1$ 配对的特定公钥 $pk_2$，$f_{pk_2}$ 很容易被求逆，并且这种情况以不可忽略的概率发生。\nC. 否。虽然单个公钥 $pk_1$ 和 $pk_2$ 不会泄露它们各自的陷门，但 $(pk_1, pk_2)$ 中的信息组合可能会无意中泄露 $f_{pk_1}$ 或 $f_{pk_2}$ 的陷门。\nD. 否。以这种方式构造的函数 $F_{pk_F}$ 不保证是乘积定义域 $D_1 \\times D_2$ 上的一个置换。", "solution": "我们首先验证正确性以及乘积定义域上的函数是否是一个置换。对于任何 $(pk_{1},sk_{1}) \\leftarrow \\text{Gen}_{1}(1^{n})$ 和 $(pk_{2},sk_{2}) \\leftarrow \\text{Gen}_{2}(1^{n})$，定义 $pk_{F}=(pk_{1},pk_{2})$，$sk_{F}=(sk_{1},sk_{2})$，以及\n$$\nF_{pk_{F}}(x,y) = \\big(\\text{Eval}_{1}(pk_{1},x),\\ \\text{Eval}_{2}(pk_{2},y)\\big).\n$$\n因为对于每个固定的 $pk_{i}$，映射 $f^{(i)}_{pk_{i}}=\\text{Eval}_{i}(pk_{i},\\cdot)$ 是 $D_{i}$ 上的一个置换，所以乘积映射 $F_{pk_{F}}$ 是 $D_{1}\\times D_{2}$ 上的一个置换，其逆为\n$$\nF_{pk_{F}}^{-1}(u,v) = \\big(\\text{Invert}_{1}(sk_{1},u),\\ \\text{Invert}_{2}(sk_{2},v)\\big).\n$$\n正确性随之立即得出：对于任何 $(x,y)\\in D_{1}\\times D_{2}$，有\n$$\n\\text{Invert}_{1}(sk_{1},\\text{Eval}_{1}(pk_{1},x))=x,\\quad \\text{Invert}_{2}(sk_{2},\\text{Eval}_{2}(pk_{2},y))=y,\n$$\n因此\n$$\n\\text{Invert}_{F}(sk_{F},F_{pk_{F}}(x,y))=(x,y).\n$$\n\n现在我们通过归约来证明安全性。假设，为了引出矛盾，存在一个PPT敌手 $\\mathcal{A}_{F}$ 和一个多项式 $p(\\cdot)$，使得对于无穷多个 $n$，有\n$$\n\\Pr\\big[\\mathcal{A}_{F}(pk_{F},F_{pk_{F}}(x,y))=(x,y)\\big]\\ \\geq\\ \\frac{1}{p(n)},\n$$\n其中概率是针对 $(pk_{1},sk_{1})\\leftarrow \\text{Gen}_{1}(1^{n})$、$(pk_{2},sk_{2})\\leftarrow \\text{Gen}_{2}(1^{n})$、从 $D_{1}\\times D_{2}$ 中一致地（或根据定义域的指定分布）选择的 $(x,y)$ 以及 $\\mathcal{A}_{F}$ 的内部随机性来计算的。\n\n我们为第二个族 $\\mathcal{F}_{2}$ 构造一个PPT求逆器 $\\mathcal{B}_{2}$，它将与其安全性相矛盾。在输入为 $(pk_{2},u)$ 时，其中 $u=\\text{Eval}_{2}(pk_{2},y)$ 且 $y\\leftarrow D_{2}$ 一致地选择，$\\mathcal{B}_{2}$ 按以下步骤进行：\n1. 采样 $(pk_{1},sk_{1})\\leftarrow \\text{Gen}_{1}(1^{n})$。\n2. 从 $D_{1}$ 中一致地采样 $x$ 并计算 $v=\\text{Eval}_{1}(pk_{1},x)$。\n3. 在输入 $(pk_{F},(v,u))$ 上运行 $\\mathcal{A}_{F}$，其中 $pk_{F}=(pk_{1},pk_{2})$。\n4. 如果 $\\mathcal{A}_{F}$ 输出 $(x',y')$，则输出 $y'$；否则输出失败。\n\n根据构造，$\\mathcal{B}_{2}$ 为 $\\mathcal{A}_{F}$ 导出的 $(pk_{1},pk_{2},x,y)$ 的联合分布与假设 $\\mathcal{A}_{F}$ 以至少 $1/p(n)$ 的概率成功的分布是相同的：$pk_{1}$ 和 $pk_{2}$ 由它们各自的生成器独立生成，$x$ 在 $D_{1}$ 中是一致的，而对于一致的 $y\\in D_{2}$ 有 $u=\\text{Eval}_{2}(pk_{2},y)$。因此，\n$$\n\\Pr\\big[\\mathcal{B}_{2}(pk_{2},\\text{Eval}_{2}(pk_{2},y))=y\\big]\n=\\Pr\\big[\\mathcal{A}_{F}(pk_{F},(v,u))=(x,y)\\big]\n\\geq \\frac{1}{p(n)}.\n$$\n因此，$\\mathcal{B}_{2}$ 以不可忽略的概率对一个随机输入求逆 $\\text{Eval}_{2}$，这与 $\\mathcal{F}_{2}$ 的假定安全性相矛盾。同样可以写出一个类似的归约来与 $\\mathcal{F}_{1}$ 的安全性相矛盾。\n\n这证明了没有PPT敌手能以不可忽略的概率对一个随机输入求逆 $F_{pk_{F}}$，因此直积族是安全的。\n\n我们现在评估这些选项：\n- 选项A是正确的：上述归约表明，乘积的安全性归约到其组件的安全性。\n- 选项B是不正确的：如果存在不可忽略比例的 $pk_{2}$ 导致求逆变得容易，这在对密钥进行平均时已经违反了为 $\\mathcal{F}_{2}$ 给出的安全性定义。\n- 选项C是不正确的：$(pk_{1},pk_{2})$ 是独立采样的；任何使用 $(pk_{1},pk_{2})$ 的敌手都可以通过采样 $pk_{1}$ 转换成一个只使用 $pk_{2}$ 的敌手，由于独立性，成功概率得以保持。\n- 选项D是不正确的：置换的乘积是笛卡尔积上的一个置换。\n\n因此，新的函数族 $\\mathcal{F}$ 必然是一个安全的陷门单向置换族，正确选项是A。", "answer": "$$\\boxed{A}$$", "id": "1467638"}]}