{"hands_on_practices": [{"introduction": "让我们从一个基本问题开始：当我们将随机算法组合在一起时，它们会如何表现？这个练习 [@problem_id:1455470] 通过一个直观的场景——测试产品的不同类型缺陷——来探讨 $RP$ 类是否在并集运算下是封闭的。通过解决这个问题，你将练习如何从现有算法构建一个新的概率算法，并严格分析其正确性和单侧错误概率。", "problem": "在计算复杂性理论领域，RP 类（代表随机多项式时间，Randomized Polynomial Time）刻画了可通过具有单侧错误的概率图灵机解决的判定问题。一个语言 $L$ 属于 RP，如果存在一个概率多项式时间图灵机 $M$，使得对于任何输入串 $x$：\n1. 如果 $x$ 在语言 $L$ 中，那么 $M$ 输出 1 (接受) 的概率至少为 $1/2$。($x \\in L \\implies P(M(x) = 1) \\ge 1/2$)\n2. 如果 $x$ 不在语言 $L$ 中，那么 $M$ 输出 1 (接受) 的概率恰好为 0。($x \\notin L \\implies P(M(x) = 1) = 0$)\n\n考虑一家设计微芯片的公司。他们开发了两种独立的概率测试算法 $A_1$ 和 $A_2$，用于检测不同类型的制造缺陷。设 $L_1$ 为所有带有“类型1”缺陷的芯片集合，而 $L_2$ 为所有带有“类型2”缺陷的芯片集合。这两种测试算法都对应于 RP 机，这意味着语言 $L_1$ 和 $L_2$ 都属于复杂性类 RP。\n\n如果一个芯片有类型1缺陷、或类型2缺陷、或两者兼有，则被认为是“全局缺陷”的。设 $L_{union}$ 为所有全局缺陷芯片的语言，因此 $L_{union} = L_1 \\cup L_2$。\n\n为了创建一个统一的测试，一位工程师提出了一个新算法 $A_{union}$。在接收到芯片 $x$ 进行测试时，$A_{union}$ 的操作如下：\n- 首先，对 $x$ 运行算法 $A_1$。\n- 如果 $A_1$ 输出 1，则 $A_{union}$ 立即输出 1 并停止。\n- 如果 $A_1$ 输出 0，则 $A_{union}$ 继续对 $x$ 运行算法 $A_2$ 并输出 $A_2$ 的结果。\n\n基于这种构造，关于语言 $L_{union}$ 的以下哪个陈述总是正确的？\n\nA. $L_{union}$ 保证在 RP 中。\n\nB. $L_{union}$ 不保证在 RP 中，但保证在 co-RP 中。\n\nC. $L_{union}$ 的分类取决于 $L_1$ 和 $L_2$ 的具体性质；它不保证在 RP 中。\n\nD. $L_{union}$ 保证在 P (多项式时间) 中。\n\nE. $L_{union}$ 保证在 BPP (有界错误概率多项式时间) 中，但不一定在 RP 中。", "solution": "我们已知两个语言 $L_{1},L_{2}$ 均在 RP 中。根据定义，存在概率多项式时间算法 $A_{1},A_{2}$，使得对于所有输入 $x$：\n- 如果 $x \\in L_{i}$，那么 $\\Pr(A_{i}(x)=1) \\ge \\frac{1}{2}$。\n- 如果 $x \\notin L_{i}$，那么 $\\Pr(A_{i}(x)=1)=0$。\n所提议的统一算法 $A_{\\text{union}}$ 首先运行 $A_{1}$，如果 $A_{1}$ 接受，则立即接受；否则，它运行 $A_{2}$ 并输出其结果。我们根据 RP 的定义来分析其运行时间和正确性。\n\n多项式时间：设输入长度为 $n$ 时的运行时间分别为 $T_{1}(n)$ 和 $T_{2}(n)$，两者都是多项式的。那么运行时间 $T_{\\text{union}}(n)$ 满足\n$$\nT_{\\text{union}}(n) \\le T_{1}(n) + T_{2}(n),\n$$\n这也是多项式的；因此 $A_{\\text{union}}$ 在概率多项式时间内运行。\n\n单侧错误（对否定实例的可靠性）：如果 $x \\notin L_{1} \\cup L_{2}$，那么 $x \\notin L_{1}$ 并且 $x \\notin L_{2}$，所以\n$$\n\\Pr(A_{1}(x)=1)=0 \\quad \\text{且} \\quad \\Pr(A_{2}(x)=1)=0.\n$$\n因此 $A_{\\text{union}}$ 接受的概率为\n$$\n\\Pr(A_{\\text{union}}(x)=1) = 0 + \\Pr(A_{1}(x)=0)\\cdot 0 = 0,\n$$\n所以没有假阳性。\n\n对于肯定实例的接受概率：如果 $x \\in L_{1} \\cup L_{2}$，我们分情况讨论。\n- 如果 $x \\in L_{1} \\setminus L_{2}$，那么 $\\Pr(A_{1}(x)=1) \\ge \\frac{1}{2}$，所以 $A_{\\text{union}}$ 无需运行 $A_{2}$ 就以至少 $\\frac{1}{2}$ 的概率接受。\n- 如果 $x \\in L_{2} \\setminus L_{1}$，那么 $\\Pr(A_{1}(x)=1)=0$（因为 $x \\notin L_{1}$），因此 $A_{\\text{union}}$ 运行 $A_{2}$ 并以概率\n$$\n\\Pr(A_{\\text{union}}(x)=1)=\\Pr(A_{2}(x)=1)\\ge \\frac{1}{2}\n$$\n接受。\n- 如果 $x \\in L_{1} \\cap L_{2}$，那么 $\\Pr(A_{1}(x)=1) \\ge \\frac{1}{2}$，所以 $A_{\\text{union}}$ 以至少 $\\frac{1}{2}$ 的概率接受。\n\n在所有 $x \\in L_{1} \\cup L_{2}$ 的情况下，我们都有 $\\Pr(A_{\\text{union}}(x)=1) \\ge \\frac{1}{2}$。结合对于否定实例的零接受概率和多项式时间，这满足了 RP 的定义。因此 $L_{\\text{union}} \\in \\text{RP}$，并且陈述 A 总是正确的。作为一般性的保证，其他选项是不必要的或错误的。\n\n因此，正确选项是 A。", "answer": "$$\\boxed{A}$$", "id": "1455470"}, {"introduction": "现实世界的问题常常需要结合不同类型的计算工具。这个练习 [@problem_id:1455488] 向你提出挑战，要求你为一个由随机时间语言（$L_1 \\in RP$）和确定性时间语言（$L_2 \\in P$）连接而成的语言构建一个算法。成功解决这个问题，将展示如何在集成概率子程序的同时系统地处理不确定性（即字符串的分割点），这是高级算法设计中的一项关键技能。", "problem": "在计算复杂性理论中，我们根据判定语言所需的资源对其进行分类。让我们考虑两个重要的复杂性类：\n\n- **P (多项式时间)**：如果存在一个确定性算法，能在 $w$ 长度的多项式时间内判定一个给定的字符串 $w$ 是否在语言 $L$ 中，那么语言 $L$ 就属于 P 类。\n- **RP (随机多项式时间)**：如果存在一个在多项式时间内运行的随机算法，并且该算法具有以下性质，那么语言 $L$ 就属于 RP 类：\n    1. 如果字符串 $w$ 在 $L$ 中，算法输出“是”的概率至少为 $1/2$。\n    2. 如果字符串 $w$ 不在 $L$ 中，算法总是输出“否”。\n\n现在，考虑语言的连接运算。对于同一字母表上的任意两个语言 $L_1$ 和 $L_2$，它们的连接（记作 $L_1 \\circ L_2$）是由字符串集合 $\\{uv \\mid u \\in L_1 \\text{ and } v \\in L_2\\}$ 定义的语言。\n\n假设我们有一个语言 $L_1$ 属于 RP，一个语言 $L_2$ 属于 P。让新语言 $L$ 由它们的连接构成，即 $L = L_1 \\circ L_2$。\n\n下列哪个选项代表了保证包含语言 $L$ 的最具体（即最小）的复杂性类？\n\nA. P\n\nB. RP\n\nC. co-RP\n\nD. ZPP ($RP \\cap co-RP$)\n\nE. NP", "solution": "给定同一字母表上的 $L_{1}\\in \\mathrm{RP}$ 和 $L_{2}\\in \\mathrm{P}$，我们考虑 $L=L_{1}\\circ L_{2}=\\{uv:\\ u\\in L_{1},\\ v\\in L_{2}\\}$。我们将为 $L$ 构建一个具有单侧错误的随机多项式时间判定器，从而证明 $L\\in \\mathrm{RP}$，然后论证为什么选项中没有更小的类能得到保证。\n\n设 $w$ 是一个长度为 $n$ 的输入字符串。对于每个分割索引 $i\\in\\{0,1,\\dots,n\\}$，定义前缀-后缀对\n$$\nu_{i}=w[1..i],\\qquad v_{i}=w[i+1..n].\n$$\n因为 $L_{2}\\in \\mathrm{P}$，所以存在一个用于 $L_{2}$ 的确定性多项式时间判定器 $A_{2}$。计算索引集\n$$\nS=\\{\\,i\\in\\{0,\\dots,n\\}\\mid A_{2}(v_{i})=\\text{yes}\\,\\}.\n$$\n这个计算最多需要 $(n+1)\\cdot \\operatorname{poly}(n)$ 的时间，这在 $n$ 上是多项式的。如果 $S=\\varnothing$，则输出“否”并停止。\n\n由于 $L_{1}\\in \\mathrm{RP}$，存在一个用于 $L_{1}$ 的随机多项式时间判定器 $A_{1}$，它具有以下性质：对于任何字符串 $x$，如果 $x\\in L_{1}$，那么 $\\Pr[A_{1}(x)=\\text{yes}]\\geq \\frac{1}{2}$；如果 $x\\notin L_{1}$，那么 $\\Pr[A_{1}(x)=\\text{yes}]=0$。\n\n现在，对于 $S$ 中的每个 $i$，在输入 $u_{i}$ 上运行一次 $A_{1}$。如果任何一次调用返回“是”，则输出“是”并停止。如果所有调用都返回“否”，则输出“否”。调用总数最多为 $n+1$ 次，每次运行时间为 $\\operatorname{poly}(n)$，所以总时间仍然是多项式的。\n\n我们来证明其具有单侧错误的正确性：\n1. 如果 $w\\notin L$，那么对于 $S$ 中的每一个 $i$，我们都有 $u_{i}\\notin L_{1}$（根据 $L$ 的定义）。因此，根据 $A_{1}$ 的单侧错误性质，对于每个这样的 $i$，$\\Pr[A_{1}(u_{i})=\\text{yes}]=0$。所以，整个算法输出“是”的概率为 0，因此总是输出“否”。这符合 RP 对“否”实例的要求。\n2. 如果 $w\\in L$，则存在至少一个索引 $i^{\\ast}\\in\\{0,\\dots,n\\}$，使得 $u_{i^{\\ast}}\\in L_{1}$ 且 $v_{i^{\\ast}}\\in L_{2}$。根据构造，有 $i^{\\ast}\\in S$，并且根据对 $A_{1}$ 的 RP 保证，\n$$\n\\Pr[A_{1}(u_{i^{\\ast}})=\\text{yes}]\\geq \\frac{1}{2}.\n$$\n由于只要对 $S$ 中的任何索引的调用返回“是”，算法就会输出“是”，我们有\n$$\n\\Pr[\\text{algorithm outputs yes}]\\geq \\Pr[A_{1}(u_{i^{\\ast}})=\\text{yes}]\\geq \\frac{1}{2}.\n$$\n因此，该算法以至少 $\\frac{1}{2}$ 的概率对“是”实例输出“是”，并且从不对“否”实例输出“是”。所以 $L\\in \\mathrm{RP}$。\n\n为了说明在给定选项中没有更小的类能得到保证，考虑 $L_{2}=\\{\\epsilon\\}$，它属于 $\\mathrm{P}$。那么 $L_{1}\\circ L_{2}=L_{1}$。如果对于任意的 $L_{1}\\in \\mathrm{RP}$，人们总能保证 $L\\in \\mathrm{P}$（或 $\\mathrm{co\\mbox{-}RP}$ 或 $\\mathrm{ZPP}$），那么就意味着 $\\mathrm{RP}$ 中的每个语言都在那个更小的类中，这将导出诸如 $\\mathrm{RP}\\subseteq \\mathrm{P}$ 或 $\\mathrm{RP}\\subseteq \\mathrm{co\\mbox{-}RP}$ 这样的包含关系，而这些关系目前尚不为人所知，也无法由现有理论保证。因此，在选项中，始终保证包含 $L$ 的最具体的类是 $\\mathrm{RP}$。\n\n因此，正确选项是 B。", "answer": "$$\\boxed{B}$$", "id": "1455488"}, {"introduction": "在 $RP$ 的定义中，“$1/2$”这个成功概率究竟有多重要？这个思想实验 [@problem_id:1455479] 邀请你思考一个“更弱”版本的 $RP$，其中算法只需有逆多项式级别的成功机会，例如 $1/|x|^2$。通过证明这个“弱”类实际上与 $RP$ 完全相同，你将揭示概率放大这一强大概念，它是证明随机计算稳健性的基石技术。这是一个能将表面理解深化为深刻领悟的关键洞见。", "problem": "在计算复杂性理论中，一个语言是某个字母表上的一组字符串。复杂性类 RP (Randomized Polynomial time，随机多项式时间) 是使用概率多项式时间图灵机 (Probabilistic Polynomial-Time Machine, PPTM) 来定义的。如果存在一个 PPTM（我们称之为 $M$），它在输入长度 $|x|$ 的多项式时间内运行，并且满足以下两个条件，那么语言 $L$ 就属于 RP：\n1. 对于任何属于语言 $L$ 的字符串 $x$（即 $x \\in L$），机器 $M$ 接受的概率至少为 $1/2$。用符号表示为 $\\Pr[M(x) \\text{ accepts}] \\ge 1/2$。\n2. 对于任何不属于语言 $L$ 的字符串 $x$（即 $x \\notin L$），机器 $M$ 总是拒绝。用符号表示为 $\\Pr[M(x) \\text{ accepts}] = 0$。\n\n现在，考虑一个新的复杂性类，我们称之为 $\\text{WEAK-RP}$。如果存在一个 PPTM (我们称之为 $M'$) 和一个多项式 $p(n)$，使得对于任何长度为 $n = |x|$ 的输入字符串 $x$，满足以下条件，那么语言 $L$ 就属于 $\\text{WEAK-RP}$：\n1. 如果 $x \\in L$，那么 $\\Pr[M'(x) \\text{ accepts}] \\ge 1/p(n)$。\n2. 如果 $x \\notin L$，那么 $\\Pr[M'(x) \\text{ accepts}] = 0$。\n\n复杂性类 RP 和 $\\text{WEAK-RP}$ 之间的关系是什么？\n\nA. $\\text{WEAK-RP}$ 是 RP 的真子集 (即 $\\text{WEAK-RP} \\subset \\text{RP}$ 且 $\\text{WEAK-RP} \\neq \\text{RP}$)。\n\nB. $\\text{WEAK-RP}$ 是 RP 的真超集 (即 $\\text{RP} \\subset \\text{WEAK-RP}$ 且 $\\text{RP} \\neq \\text{WEAK-RP}$)。\n\nC. $\\text{WEAK-RP}$ 等于 RP (即 $\\text{WEAK-RP} = \\text{RP}$)。\n\nD. $\\text{WEAK-RP}$ 和 RP 是不可比较的 (即，两者都不是对方的子集)。\n\nE. $\\text{WEAK-RP}$ 中的每个语言都是不可判定的，而 RP 包含一些可判定的语言。", "solution": "我们首先重申定义属性。RP 包含这样一些语言，对于这些语言，存在一个概率多项式时间图灵机，它以至少 $1/2$ 的概率接受每个 $x \\in L$ 的实例，并且从不接受 $x \\notin L$ 的实例。复杂性类 $\\text{WEAK-RP}$ 将对 $x \\in L$ 的接受概率放宽到至少为 $1/p(n)$（其中 $p(n)$ 是某个仅取决于输入长度 $n = |x|$ 的多项式），同时仍然要求对 $x \\notin L$ 的接受概率为零。\n\n步骤 1 (RP 包含于 WEAK-RP)：令 $L \\in \\text{RP}$，其见证机为 $M$，满足对于 $x \\in L$ 有 $\\Pr[M(x)\\text{ accepts}] \\ge 1/2$，而对于 $x \\notin L$ 有概率为 $0$。选择常数多项式 $p(n) = 2$。那么 $1/2 \\ge 1/p(n)$，所以 $M$ 也见证了 $L \\in \\text{WEAK-RP}$。因此 $\\text{RP} \\subseteq \\text{WEAK-RP}$。\n\n步骤 2 (通过放大证明 WEAK-RP 包含于 RP)：令 $L \\in \\text{WEAK-RP}$，其见证机为 $M'$，多项式为 $p(n)$，使得对于所有长度为 $n = |x|$ 的 $x$：\n- 如果 $x \\in L$，则 $\\Pr[M'(x)\\text{ accepts}] \\ge 1/p(n)$，\n- 如果 $x \\notin L$，则 $\\Pr[M'(x)\\text{ accepts}] = 0$。\n不失一般性地，定义 $q(n) = \\max\\{1, \\lceil p(n) \\rceil\\}$，这样 $q(n)$ 就是一个整值多项式且 $q(n) \\ge 1$。那么对于 $x \\in L$，我们仍然有 $\\Pr[M'(x)\\text{ accepts}] \\ge 1/q(n)$，因为 $1/q(n) \\le 1/p(n)$。\n\n构造一个新的概率多项式时间图灵机 $M$，它在输入长度为 $n$ 的 $x$ 上，执行 $k(n) = \\lceil q(n)\\ln 2 \\rceil$ 次独立的 $M'$ 运行，并且当且仅当至少有一次运行接受时，$M$ 才接受。由于每次运行使用独立的随机位，所以各次运行是独立的。\n\n- 如果 $x \\notin L$，那么每次运行接受的概率为 $0$，所以 $M$ 接受的概率也是 $0$。因此，单边错误的条件得以保持。\n\n- 如果 $x \\in L$，令 $\\alpha(n) = \\Pr[M'(x)\\text{ accepts}]$，所以 $\\alpha(n) \\ge 1/q(n)$。根据独立性，\n$$\n\\Pr[M(x)\\text{ accepts}] \\;=\\; 1 - \\Pr[\\text{all }k(n)\\text{ runs reject}]\n\\;=\\; 1 - (1 - \\alpha(n))^{k(n)}.\n$$\n使用 $\\alpha(n) \\ge 1/q(n)$ 以及函数 $t \\mapsto (1-t)^{k}$ 在 $t \\in [0,1]$ 上的单调性，我们得到\n$$\n\\Pr[M(x)\\text{ accepts}] \\;\\ge\\; 1 - \\left(1 - \\frac{1}{q(n)}\\right)^{k(n)} \\;\\ge\\; 1 - \\left(1 - \\frac{1}{q(n)}\\right)^{q(n)\\ln 2}.\n$$\n为了界定后一项，我们使用不等式 $\\ln(1 - z) \\le -z$（对于 $z \\in (0,1)$）来得到\n$$\n\\left(1 - \\frac{1}{q(n)}\\right)^{q(n)\\ln 2}\n= \\exp\\!\\left(q(n)\\ln 2 \\cdot \\ln\\!\\left(1 - \\frac{1}{q(n)}\\right)\\right)\n\\le \\exp\\!\\left(q(n)\\ln 2 \\cdot \\left(-\\frac{1}{q(n)}\\right)\\right)\n= \\exp(-\\ln 2) = \\frac{1}{2}.\n$$\n因此，\n$$\n\\Pr[M(x)\\text{ accepts}] \\;\\ge\\; 1 - \\frac{1}{2} \\;=\\; \\frac{1}{2}.\n$$\n机器 $M$ 在 $n$ 的多项式时间内运行，因为它执行了 $k(n) = \\lceil q(n)\\ln 2 \\rceil$ 次独立的 PPTM 运行，而 $k(n)$ 是 $n$ 的多项式。因此，$M$ 见证了 $L \\in \\text{RP}$。\n\n结合步骤 1 和步骤 2，我们得到 $\\text{WEAK-RP} = \\text{RP}$。\n\n因此，正确选项是 C。", "answer": "$$\\boxed{C}$$", "id": "1455479"}]}