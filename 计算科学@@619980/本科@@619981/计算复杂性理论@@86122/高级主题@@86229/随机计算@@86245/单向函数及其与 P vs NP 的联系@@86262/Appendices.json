{"hands_on_practices": [{"introduction": "为了扎实地理解单向函数的概念，我们从一个直观的例子开始。这个练习将探讨一个看似复杂的函数——循环位移——为什么它不满足单向性的要求。通过亲手执行其逆运算，你将具体体会到“易于求逆”的含义，并理解为什么仅仅“易于计算”不足以构成一个安全的单向函数。[@problem_id:1433133]", "problem": "在计算复杂性理论的研究中，单向函数是一种对每个输入都易于计算，但对随机输出在平均情况下难以求逆的函数。形式上，如果一个函数 $f$ 可以在多项式时间内计算，但没有概率多项式时间算法能够对不可忽略部分的输入 $x$ 找到 $f(x)$ 的一个原像，则该函数是单向函数的候选者。\n\n考虑一个为密码学应用提出的函数 `SHIFT_L(x, k, n)`。该函数接受一个 $n$ 位无符号整数 $x$，并将其二进制表示循环左移 $k$ 个位置。例如，如果 $n=8$ 且输入整数的二进制表示为 `11010010`，则当 $k=2$ 时，`SHIFT_L` 会产生二进制数 `01001011`。\n\n一位分析师的任务是评估该函数作为单向函数的适用性。他们被给定一个输出整数 $y=43$，该整数是通过对某个未知的原始整数 $x$ 计算 $y = \\text{SHIFT\\_L}(x, k, n)$ 生成的。使用的参数为 $n=8$ 和 $k=3$。为证明该函数不是单向的，分析师必须高效地找到原始整数 $x$。\n\n原始整数 $x$ 的值是多少？", "solution": "我们将此操作形式化如下。设 $x$ 的一个 $n$ 位向量写作 $(x_{n-1},\\dots,x_{0})$，其中 $x_{n-1}$ 是最高有效位。定义以 $k$ 个位置进行循环左旋的操作 $\\operatorname{LROT}_{n,k}$ 为\n$$\n\\operatorname{LROT}_{n,k}(x)_{i} = x_{(i-k)\\bmod n}, \\quad i\\in\\{0,1,\\dots,n-1\\}.\n$$\n这是在 $\\{0,1\\}^{n}$ 上的一个排列，因此是可逆的，其逆运算由以 $k$ 个位置进行循环右旋的操作 $\\operatorname{RROT}_{n,k}$ 给出：\n$$\n\\operatorname{RROT}_{n,k} = \\operatorname{LROT}_{n,k}^{-1}, \\qquad \\operatorname{RROT}_{n,k}(y)_{i} = y_{(i+k)\\bmod n}.\n$$\n给定 $y=\\operatorname{LROT}_{8,3}(x)$ 且 $y=43$，我们通过计算 $x=\\operatorname{RROT}_{8,3}(y)$ 来求逆。\n\n首先，将 $y$ 写成 8 位二进制形式。由于\n$$\n43 = 2^{5} + 2^{3} + 2^{1} + 2^{0},\n$$\n其 8 位向量（最高有效位在前）为\n$$\ny = (y_{7},y_{6},y_{5},y_{4},y_{3},y_{2},y_{1},y_{0}) = (0,0,1,0,1,0,1,1).\n$$\n应用 $n=8$ 和 $k=3$ 的逆旋转操作，\n$$\nx = \\operatorname{RROT}_{8,3}(y) = (y_{2},y_{1},y_{0},y_{7},y_{6},y_{5},y_{4},y_{3}) = (0,1,1,0,0,1,0,1).\n$$\n将 $x$ 转换回十进制：\n$$\nx = 0\\cdot 2^{7} + 1\\cdot 2^{6} + 1\\cdot 2^{5} + 0\\cdot 2^{4} + 0\\cdot 2^{3} + 1\\cdot 2^{2} + 0\\cdot 2^{1} + 1\\cdot 2^{0} = 64 + 32 + 4 + 1 = 101.\n$$\n因此，原始整数为 $x=101$。", "answer": "$$\\boxed{101}$$", "id": "1433133"}, {"introduction": "下一个练习将深入探讨单向函数定义中一个更微妙但至关重要的方面：“平均情况”下的难解性。一个函数如果仅仅在极少数情况下难以求逆，但在绝大多数情况下都很容易，那么它就不是一个合格的单向函数。这个练习要求你分析一个假设函数的求逆成功概率，并判断它是否满足密码学上的安全性标准。[@problem_id:1433092]", "problem": "在计算复杂性理论中，单向函数 (one-way function) 是一种易于计算但平均上难以求逆的函数。更正式地说，一个函数 $f: \\{0,1\\}^* \\to \\{0,1\\}^*$ 是单向函数，如果它满足以下两个性质：\n\n1.  **易于计算：** 存在一个多项式时间算法，对任何输入 $x$ 都能计算出 $f(x)$。\n2.  **难以求逆：** 对于任意概率多项式时间 (PPT) 算法 $\\mathcal{A}$，任意正多项式 $p$，以及所有足够大的安全参数 $n$，算法 $\\mathcal{A}$ 成功找到 $f(x)$ 的一个原像的概率是可忽略的。也就是说，\n    $$ \\Pr_{x \\leftarrow \\{0,1\\}^n, \\text{coins of } \\mathcal{A}} [\\mathcal{A}(f(x)) \\in f^{-1}(f(x))]  \\frac{1}{p(n)} $$\n    其中 $x$ 是从所有 $n$ 位字符串的集合 $\\{0,1\\}^n$ 中均匀随机选择的。如果一个关于 $n$ 的函数比 $n$ 的任何多项式的倒数下降得更快，则该函数被认为是可忽略的。\n\n考虑一个假设的密码学函数 `QuirkHash`，它将 $n$ 位字符串映射到 $n$ 位字符串。已知 `QuirkHash` 可在 $O(n^3)$ 时间内计算。该函数有一个奇特的性质：对于一个非常特定的输出字符串 $y_{special} = 1^n$（一个由 $n$ 个 1 组成的字符串），找到其任意原像在计算上是不可行的，并被认为需要指数时间。然而，对于任何输出 $y \\neq y_{special}$，存在一个公开的、确定性的多项式时间算法 `EasyInvert`，它能在 $O(n^4)$ 时间内找到一个原像。\n\n此外，已知映射到特殊输出的输入集合 $C_n = \\{x \\in \\{0,1\\}^n \\mid \\text{QuirkHash}(x) = y_{special}\\}$ 的大小为 $|C_n| = \\lfloor n^2 \\ln(n) \\rfloor$。\n\n一个敌手构建了一个算法 $\\mathcal{A}$ 来求逆 `QuirkHash`。给定一个输出 $y = \\text{QuirkHash}(x)$（其中 $x$ 是一个随机选择的 $n$ 位输入），$\\mathcal{A}$ 的操作如下：\n- 如果 $y \\neq y_{special}$，它运行 `EasyInvert(y)` 并返回结果。\n- 如果 $y = y_{special}$，它放弃并返回 'FAILURE'。\n\n根据单向函数的正式定义，以下哪个陈述正确地对 `QuirkHash` 进行了分类？\n\nA. `QuirkHash` 是一个单向函数，因为至少存在一个输出，其原像难以找到。\n\nB. `QuirkHash` 是一个单向函数，因为遇到难以求逆情况的概率是可忽略的，这意味着该函数在平均上是难以求逆的。\n\nC. `QuirkHash` 不是一个单向函数，因为存在一个概率多项式时间算法，能以不可忽略的概率对其求逆。\n\nD. `QuirkHash` 不是一个单向函数，因为单向函数必须对其值域中的每一个可能的输出都难以求逆。\n\nE. `QuirkHash` 的分类无法确定，因为对 $y_{special}$ 求逆的难度只是一个猜想，而非一个已证明的事实。", "solution": "我们首先精确地重述单向函数的条件。一个函数 $f:\\{0,1\\}^{*}\\to\\{0,1\\}^{*}$ 是单向的，如果：\n- 它可在多项式时间内计算。\n- 对于任意概率多项式时间 (PPT) 算法 $\\mathcal{A}$，任意正多项式 $p$，以及所有足够大的 $n$，其求逆成功概率是可忽略的，即：\n$$\n\\Pr_{x \\leftarrow \\{0,1\\}^{n},\\,\\text{coins of }\\mathcal{A}}\\left[\\mathcal{A}(f(x)) \\in f^{-1}(f(x))\\right]  \\frac{1}{p(n)}.\n$$\n\n`QuirkHash` 可在 $O(n^{3})$ 时间内计算，因此它满足易于计算的性质。\n\n定义 $y_{special} = 1^{n}$ 和 $C_{n} = \\{x \\in \\{0,1\\}^{n} : \\text{QuirkHash}(x) = y_{special}\\}$ 且 $|C_{n}| = \\lfloor n^{2}\\ln(n) \\rfloor$。对于任何 $y \\neq y_{special}$，存在一个确定性的多项式时间求逆器 `EasyInvert`，它能在 $O(n^{4})$ 时间内找到一个原像。\n\n考虑所描述的 PPT 算法 $\\mathcal{A}$：\n- 对于均匀选择的 $x \\leftarrow \\{0,1\\}^{n}$，输入为 $y = \\text{QuirkHash}(x)$，如果 $y \\neq y_{special}$，则输出 `EasyInvert(y)`；否则输出 `FAILURE`。\n这个算法 $\\mathcal{A}$ 在多项式时间内运行，因为 `EasyInvert` 在 $O(n^{4})$ 时间内运行，且判断 $y \\stackrel{?}{=} y_{special}$ 是平凡的。\n\n计算其成功概率。由于当 $y \\neq y_{special}$ 时 $\\mathcal{A}$ 总是成功，而当 $y = y_{special}$ 时总是失败，我们有\n$$\n\\Pr\\left[\\mathcal{A}(\\text{QuirkHash}(x)) \\in \\text{QuirkHash}^{-1}(\\text{QuirkHash}(x))\\right]\n= \\Pr\\left[\\text{QuirkHash}(x) \\neq y_{special}\\right]\n= 1 - \\Pr\\left[\\text{QuirkHash}(x) = y_{special}\\right].\n$$\n因为 $x$ 在 $\\{0,1\\}^{n}$ 上是均匀分布的，\n$$\n\\Pr\\left[\\text{QuirkHash}(x) = y_{special}\\right] = \\frac{|C_{n}|}{2^{n}} = \\frac{\\lfloor n^{2}\\ln(n) \\rfloor}{2^{n}} \\leq \\frac{n^{2}\\ln(n)}{2^{n}}.\n$$\n因此\n$$\n\\Pr\\left[\\mathcal{A}(\\text{QuirkHash}(x)) \\in \\text{QuirkHash}^{-1}(\\text{QuirkHash}(x))\\right]\n\\geq 1 - \\frac{n^{2}\\ln(n)}{2^{n}}.\n$$\n\n我们现在证明失败概率 $\\frac{n^{2}\\ln(n)}{2^{n}}$ 是可忽略的。利用对于足够大的 $n$，有 $\\ln(n) \\leq n$ 这一事实，我们得到\n$$\n\\frac{n^{2}\\ln(n)}{2^{n}} \\leq \\frac{n^{3}}{2^{n}}\n$$\n对所有足够大的 $n$ 成立。由于对任意固定的 $k$，$\\lim_{n \\to \\infty} \\frac{n^{k}}{2^{n}} = 0$，因此 $\\frac{n^{3}}{2^{n}}$ 是可忽略的，所以 $\\frac{n^{2}\\ln(n)}{2^{n}}$ 也是可忽略的。因此，成功概率满足\n$$\n\\Pr\\left[\\mathcal{A}(\\text{QuirkHash}(x)) \\in \\text{QuirkHash}^{-1}(\\text{QuirkHash}(x))\\right]\n= 1 - \\text{negl}(n),\n$$\n这是不可忽略的。特别地，存在一个正多项式 $p$（例如，$p(n) = 2$），使得对于所有足够大的 $n$，\n$$\n\\Pr\\left[\\mathcal{A}(\\text{QuirkHash}(x)) \\in \\text{QuirkHash}^{-1}(\\text{QuirkHash}(x))\\right] \\geq \\frac{1}{p(n)}.\n$$\n因此，存在一个 PPT 算法能以不可忽略的概率求逆 QuirkHash。根据正式定义，这违反了单向函数所要求的难以求逆的条件。\n\n评估各个选项：\n- A 是错误的：仅对单个输出的困难性不足以构成单向性。\n- B 是错误的：难以处理的实例只占可忽略的一小部分，这意味着该函数在平均上是容易求逆的，而不是困难的。\n- C 是正确的：所描述的算法 $\\mathcal{A}$ 以不可忽略的（实际上是压倒性的）概率成功求逆。\n- D 是错误的：单向性是一个平均情况下的概念，而不是要求对每个输出都是最坏情况（难以求逆）的。\n- E 是错误的：分类并不依赖于证明对 $y_{special}$ 求逆的困难性；在绝大多数输出上存在高效求逆器这一事实，已经证明了该函数不是单向的。\n\n因此，正确的分类是 C。", "answer": "$$\\boxed{C}$$", "id": "1433092"}, {"introduction": "最后的练习将我们的关注点从分析转向构造——这是密码学和计算复杂性理论中的一项核心技能。假设我们已经有了一个安全的“积木”（一个已知的单向函数 $f$），我们能否通过简单地组合它来构建新的安全函数？这个练习将引导你使用归约证明这一强大的技术，来论证一个新构造的函数的安全性是如何依赖于其底层组件的。[@problem_id:1433150]", "problem": "在计算复杂性理论领域，单向函数是一种易于计算但难以求逆的函数。更形式化地说，我们定义一个函数 $f: \\{0,1\\}^* \\to \\{0,1\\}^*$，它将任意长度的二进制字符串映射到其他二进制字符串。如果函数 $f$ 满足以下两个性质，我们就称其为**单向函数**：\n1.  **易于计算**：存在一个确定性算法，对于任何输入 $x$，它都可以在 $x$ 长度的多项式时间内计算出 $f(x)$。\n2.  **难以求逆**：对于任何在其输入长度的多项式时间内运行的概率性算法 $A$， $A$ 成功找到一个原像的概率是可忽略的。也就是说，对于一个随机选择的长度为 $n$ 的输入 $x$，算法 $A(f(x))$ 输出一个 $x'$ 使得 $f(x') = f(x)$ 的概率，其趋向于零的速度比 $n$ 的任何逆多项式都快。\n\n单向函数的存在性是计算机科学中的一个重大开放问题，并且它与 P vs NP 问题紧密相关。如果单向函数存在，则可以证明 P 不等于 NP（其中 P 是可在多项式时间内解决的问题类，NP 是可在多项式时间内验证的问题类）。\n\n一位密码学家提出了一种从现有函数构造新函数的方法。假设给定一个函数 $f$，保证它根据上述定义是一个单向函数。新函数我们称之为 $g$，它定义在两个相同长度的输入对 $(x_1, x_2)$ 上，其输出是 $f$ 各自输出的连接。也就是说，对于输入 $x_1, x_2 \\in \\{0,1\\}^n$，函数 $g$ 定义为：\n$$g(x_1, x_2) = (f(x_1), f(x_2))$$\n其输出是一个有序字符串对。\n\n新构造的函数 $g$ 是否也必然是单向函数？\n\nA. 是，函数 $g$ 始终是单向函数。\n\nB. 否，函数 $g$ 绝不是单向函数。\n\nC. 仅当函数 $f$ 也是一个置换（即双射）时，函数 $g$ 才是单向函数。\n\nD. 仅当 P = NP 时，函数 $g$ 才是单向函数。\n\nE. $g$ 是否为单向函数是一个未解决的问题，其证明将解决 P 与 NP 问题。", "solution": "设 $f:\\{0,1\\}^{*}\\to\\{0,1\\}^{*}$ 为一个单向函数。根据定义，对于每个输入长度 $n$，$f$ 可在关于 $n$ 的多项式时间内计算，并且对于任意概率多项式时间（PPT）算法 $A$，其求逆成功概率\n$$\n\\Pr_{x\\leftarrow\\{0,1\\}^{n}}\\big[f(A(f(x)))=f(x)\\big]\n$$\n在 $n$ 上是可忽略的。\n\n我们通过 $g(x_{1},x_{2})=(f(x_{1}),f(x_{2}))$ 定义函数 $g:\\{0,1\\}^{n}\\times\\{0,1\\}^{n}\\to\\{0,1\\}^{*}\\times\\{0,1\\}^{*}$。我们来验证 $g$ 的单向性两个性质。\n\n易于计算：由于 $f$ 可在关于 $n$ 的多项式时间内计算，因此计算 $f(x_{1})$ 和 $f(x_{2})$ 分别需要关于 $n$ 的多项式时间。所以，计算 $g(x_{1},x_{2})$ 的时间是关于 $n$ 的多项式时间，从而也是关于输入长度 $2n$ 的多项式时间。\n\n难以求逆：我们用反证法，假设存在一个 PPT 算法 $A_{g}$ 和一个不可忽略的函数 $\\epsilon(n)$，使得\n$$\n\\Pr_{(x_{1},x_{2})\\leftarrow\\{0,1\\}^{n}\\times\\{0,1\\}^{n}}\\Big[(x_{1}',x_{2}')\\leftarrow A_{g}(g(x_{1},x_{2}))\\ \\wedge\\ f(x_{1}')=f(x_{1})\\ \\wedge\\ f(x_{2}')=f(x_{2})\\Big]\\geq \\epsilon(n).\n$$\n我们为 $f$ 构建一个 PPT 求逆器 $B_{f}$ 如下。对于形式为 $y=f(x)$ 的输入 $y$，其中 $x\\leftarrow\\{0,1\\}^{n}$ 是均匀随机的（如同在 $f$ 的单向性实验中一样），$B_{f}$ 执行以下操作：\n1. 均匀随机地采样 $r\\leftarrow\\{0,1\\}^{n}$。\n2. 计算 $y_{2}=f(r)$。\n3. 在 $(y,y_{2})$ 上运行 $A_{g}$ 以获得 $(x_{1}',x_{2}')$。\n4. 检查是否 $f(x_{1}')=y$ 且 $f(x_{2}')=y_{2}$。如果是，则输出 $x_{1}'$；否则，输出失败。\n\n$B_{f}$ 在关于 $n$ 的多项式时间内运行，因为每一步都是多项式时间的，且 $A_{g}$ 是 PPT 算法。考虑输入到 $A_{g}$ 的 $(y,y_{2})$ 的分布。我们有 $y=f(x)$，其中 $x\\leftarrow\\{0,1\\}^{n}$ 是均匀的；以及 $y_{2}=f(r)$，其中 $r\\leftarrow\\{0,1\\}^{n}$ 是独立的均匀随机变量。因此，$(y,y_{2})$ 的分布与从 $\\{0,1\\}^{n}\\times\\{0,1\\}^{n}$ 中抽取的 $(x_1, x_2)$ 所对应的 $g(x_{1},x_{2})$ 的分布完全相同。所以，\n$$\n\\begin{align*}\n\\Pr\\big[B_{f}\\text{ outputs }x'\\text{ with }f(x')=y\\big]\n =\n\\Pr_{(x_{1},x_{2})}\\Big[(x_{1}',x_{2}')\\leftarrow A_{g}(g(x_{1},x_{2}))\\ \\wedge\\ f(x_{1}')=f(x_{1})\\ \\wedge\\ f(x_{2}')=f(x_{2})\\Big] \\\\\n \\geq \\epsilon(n),\n\\end{align*}\n$$\n这个概率是不可忽略的。这与 $f$ 的单向性相矛盾。因此，没有任何用于 $g$ 的 PPT 求逆器能够以不可忽略的概率成功，从而证明了 $g$ 是难以求逆的。\n\n由于在 $f$ 是单向函数的假设下，$g$ 既易于计算又难以求逆，所以 $g$ 是一个单向函数。选项 C、D 或 E 中的附加条件都不是必需的，而选项 B 是错误的。\n\n因此，正确选项是 A。", "answer": "$$\\boxed{A}$$", "id": "1433150"}]}