{"hands_on_practices": [{"introduction": "理论知识只有通过实践才能真正内化。本练习将引导你亲手操作 Nisan-Wigderson (NW) 生成器的基本构造过程，让你从最基础的层面理解它是如何将一个短随机种子扩展成一个更长的伪随机字符串的。通过一个具体的例子，你将学会如何应用给定的硬函数和组合设计来计算最终的输出。[@problem_id:1459778]", "problem": "Nisan-Wigderson (NW) 生成器是一种利用硬布尔函数构造的伪随机生成器。该生成器接收一个短的随机种子，并将其扩展为一个更长的伪随机字符串。\n\n其构造由以下几个部分定义：\n1.  一个长度为 $n$ 的种子字符串 $x$，即 $x \\in \\{0,1\\}^n$。我们将其中的比特表示为 $x = x_1x_2...x_n$。\n2.  一个布尔函数 $f: \\{0,1\\}^k \\to \\{0,1\\}$，其中整数 $k < n$。\n3.  $m$ 个子集的集合 $S_1, S_2, ..., S_m$，其中每个 $S_i \\subseteq \\{1, 2, ..., n\\}$ 且大小为 $|S_i| = k$。\n\n输出字符串的第 $i$ 个比特 $z_i$ 是通过将函数 $f$ 应用于由集合 $S_i$ 索引的种子 $x$ 的比特来计算的。我们把这个操作表示为 $z_i = f(x|_{S_i})$，其中 $x|_{S_i}$ 是一个长度为 $k$ 的字符串，由种子中索引 $j \\in S_i$ 对应的比特 $x_j$ 按索引升序连接而成。最终的输出是字符串 $z = z_1z_2...z_m$。\n\n考虑一个具有以下参数的 NW 生成器：\n- 种子长度为 $n=4$。\n- 输出长度为 $m=3$。\n- 种子为 $x = 1101$。\n- 函数 $f: \\{0,1\\}^2 \\to \\{0,1\\}$ 定义为 $f(y_1, y_2) = y_1 \\oplus y_2$，其中 $\\oplus$ 表示按位异或 (XOR) 运算。\n- 集合为 $S_1 = \\{1, 2\\}$，$S_2 = \\{3, 4\\}$ 和 $S_3 = \\{1, 3\\}$。\n\n计算该生成器在给定种子下产生的 3 比特输出字符串 $z$。", "solution": "该问题要求我们计算一个特定的 Nisan-Wigderson (NW) 生成器的输出字符串。该生成器由一个种子 $x$、一个函数 $f$ 以及一组集合 $S_1, S_2, S_3$ 定义。输出字符串为 $z = z_1z_2z_3$，其中每个比特 $z_i$ 的计算方式为 $z_i = f(x|_{S_i})$。\n\n给定的参数如下：\n- 种子: $x = 1101$。这意味着各个比特为 $x_1=1$, $x_2=1$, $x_3=0$, 和 $x_4=1$。\n- 函数: $f(y_1, y_2) = y_1 \\oplus y_2$。\n- 集合: $S_1 = \\{1, 2\\}$, $S_2 = \\{3, 4\\}$, $S_3 = \\{1, 3\\}$。\n\n我们将逐步计算输出字符串 $z$ 的每个比特。\n\n**步骤 1：计算第一个输出比特 $z_1$。**\n第一个输出比特由集合 $S_1 = \\{1, 2\\}$ 决定。我们首先提取种子 $x$ 中由 $S_1$ 指定的索引处的比特。索引为 1 和 2。\n对应的比特是 $x_1=1$ 和 $x_2=1$。\n因此，函数 $f$ 的输入是字符串 $x|_{S_1} = x_1x_2 = 11$。\n我们将函数 $f$ 应用于这些比特：\n$z_1 = f(1, 1) = 1 \\oplus 1 = 0$。\n\n**步骤 2：计算第二个输出比特 $z_2$。**\n第二个输出比特由集合 $S_2 = \\{3, 4\\}$ 决定。我们提取种子 $x$ 中索引为 3 和 4 处的比特。\n对应的比特是 $x_3=0$ 和 $x_4=1$。\n因此，函数 $f$ 的输入是字符串 $x|_{S_2} = x_3x_4 = 01$。\n我们将函数 $f$ 应用于这些比特：\n$z_2 = f(0, 1) = 0 \\oplus 1 = 1$。\n\n**步骤 3：计算第三个输出比特 $z_3$。**\n第三个输出比特由集合 $S_3 = \\{1, 3\\}$ 决定。我们提取种子 $x$ 中索引为 1 和 3 处的比特，并按索引升序排列。\n对应的比特是 $x_1=1$ 和 $x_3=0$。\n因此，函数 $f$ 的输入是字符串 $x|_{S_3} = x_1x_3 = 10$。\n我们将函数 $f$ 应用于这些比特：\n$z_3 = f(1, 0) = 1 \\oplus 0 = 1$。\n\n**步骤 4：构造最终的输出字符串。**\n最终的输出字符串 $z$ 是计算出的比特 $z_1, z_2, z_3$ 的串联。\n$z = z_1z_2z_3 = 011$。\n\n因此，对于给定的种子和参数，NW 生成器的输出是字符串 011。", "answer": "$$\\boxed{011}$$", "id": "1459778"}, {"introduction": "理解了 NW 生成器的基本运作方式后，下一个关键问题是：它的伪随机性从何而来？此练习通过一个思想实验，探讨了当生成器的一个核心组件——组合设计——被有意地选择为一个“坏”的设计时，会发生什么。这将帮助你深刻体会到，为何集合 $S_i$ 的巧妙构造对于保证输出的随机性至关重要，而不仅仅是硬函数的存在。[@problem_id:1459746]", "problem": "Nisan-Wigderson (NW) 生成器是复杂性理论中的一个基本构造，用于从一个在平均情况下难于计算的函数创建一个伪随机生成器。该生成器接受一个短的随机种子，并将其扩展为一个更长的字符串，这个字符串对于某一类的计算观察者来说看起来是随机的。\n\n我们来定义一个 NW 生成器的组成部分：\n1.  一个函数 $f: \\{0,1\\}^k \\to \\{0,1\\}$，它被假定对于某一类电路是“困难”的。\n2.  一个长度为 $n$ 的种子 $x$，其中 $x \\in \\{0,1\\}^n$。\n3.  一个组合设计，它是种子位索引的 $m$ 个子集的集合：$S_1, S_2, \\dots, S_m \\subseteq \\{1, 2, \\dots, n\\}$，其中每个集合 $S_i$ 的大小为 $k$（即 $|S_i| = k$）。\n\n该生成器生成一个长度为 $m$ 的输出字符串 $y \\in \\{0,1\\}^m$。输出的第 $i$ 位 $y_i$，是通过将函数 $f$ 应用于由集合 $S_i$ 所选择的种子 $x$ 的那些位来计算的。我们将这个位的子序列记为 $x|_{S_i}$。因此，生成规则是：\n$$ y_i = f(x|_{S_i}) \\text{ for } i = 1, 2, \\dots, m $$\nNW 生成器的安全性和随机性属性关键地依赖于集合 $S_i$ 的组合性质，特别是任意两个不同的集合具有很小的交集。\n\n考虑一个配置错误的 NW 生成器，其组合设计选择得很差。具体来说，令 $n > k$ 并假设设计中的所有集合都是相同的。设这个公共集合为 $S = \\{1, 2, \\dots, k\\}$，从而 $S_1 = S_2 = \\dots = S_m = S$。\n\n对于一个随机选择的种子 $x \\in \\{0,1\\}^n$，下列哪个陈述最准确地描述了由这个配置错误的生成器所产生的输出字符串 $y \\in \\{0,1\\}^m$？\n\nA. 只要函数 $f$ 足够困难，该生成器仍然可以作为一个有效的伪随机生成器，欺骗任何特定大小的电路。\n\nB. 输出字符串的所有位都完全相同。\n\nC. 对于 $f$ 的任何选择，输出字符串保证是全零字符串或全一字符串。\n\nD. 输出字符串由 $m$ 个独立且均匀随机的位组成。\n\nE. 输出位是高度相关的，但它们的精确值从一位到下一位会发生不可预测的变化。", "solution": "我们给定一个配置错误设计的 NW 生成器，其中所有集合都相同：$S_{1}=\\dots=S_{m}=S=\\{1,\\dots,k\\}$。对于任意种子 $x\\in\\{0,1\\}^{n}$，定义 $k$ 位的子序列 $u=x|_{S}\\in\\{0,1\\}^{k}$。根据生成规则，\n$$\ny_{i}=f\\bigl(x|_{S_{i}}\\bigr)=f\\bigl(x|_{S}\\bigr)=f(u)\\quad\\text{for all }i\\in\\{1,\\dots,m\\}.\n$$\n因此，对于任意 $i,j\\in\\{1,\\dots,m\\}$，\n$$\ny_{i}=f(u)=y_{j},\n$$\n所以所有输出位都相同。由于 $f:\\{0,1\\}^{k}\\to\\{0,1\\}$，这个公共值 $f(u)$ 要么是 $0$ 要么是 $1$，因此输出字符串 $y$ 要么等于 $0^{m}$ 要么等于 $1^{m}$，具体是哪一个取决于 $x$ 和 $f$。因此，在任何有意义的层面上，它都不是一个伪随机生成器：输出位是完全相关的，并且肯定不是独立的或均匀随机的。\n\n评估各个选项：\n- A 是错误的，因为输出是退化的（在所有位置上都是常数），所以它不能欺骗合理的电路。\n- B 是正确的：所有位都相同。\n- C，从字面上看，陈述了对于任何 $f$，输出字符串总是 $0^{m}$ 或 $1^{m}$，对于每个固定的种子 $x$ 来说，情况确实如此。然而，作为一个描述，B 是最准确和最简洁的刻画，没有关于其对 $x$ 的依赖性的歧义。\n- D 是错误的，因为这些位既不是独立的也不是均匀随机的。\n- E 是错误的，因为位与位之间没有变化；所有位都完全相同。\n\n因此，正确的选项是 B。", "answer": "$$\\boxed{B}$$", "id": "1459746"}, {"introduction": "NW 构造的另一个支柱是其所依赖的“硬函数” $f$。本练习将深入探讨“硬度”这一概念的稳健性。我们将研究对硬函数进行一个简单的、公开的线性变换是否会削弱生成器的安全性，通过这种方式，你将能更好地理解密码学语境下“计算硬度”的真正含义以及安全归约是如何运作的。[@problem_id:1459796]", "problem": "Nisan-Wigderson (NW) 生成器是计算复杂性理论中的一个基础性构造，它利用一个平均情况下难计算的函数来构建一个伪随机生成器。\n\n让我们建立必要的定义。如果对于任何最多包含 $S$ 个门的布尔电路 $C$，以下不等式都成立，那么函数 $f: \\{0,1\\}^n \\to \\{0,1\\}$ 被称为是 $(S, \\delta)$-难的：\n$$\n\\left| \\Pr_{y \\in_R \\{0,1\\}^n}[C(y) = f(y)] - \\frac{1}{2} \\right| \\le \\delta\n$$\n此处，$y \\in_R \\{0,1\\}^n$ 表示 $y$ 是从所有 $n$ 位字符串的集合中均匀随机选取的。\n\nNW 生成器（记作 $G_f$）使用这样一个函数 $f$ 和一个特定的组合设计，将一个短的随机种子 $x \\in \\{0,1\\}^L$ 扩展成一个更长的伪随机字符串 $G_f(x) \\in \\{0,1\\}^M$。一个关键结论是，如果 $f$ 足够难（即，对于大的 $S$ 和小的 $\\delta$），那么对于任何特定规模的电路，$G_f$ 的输出与一个真随机字符串在计算上是不可区分的。\n\n现在，考虑一个场景：我们构建一个新的生成器 $G_h$，它使用与 $G_f$ 完全相同的组合设计，但我们将难函数 $f$ 替换为一个修改后的函数 $h: \\{0,1\\}^n \\to \\{0,1\\}$。这个新函数定义为 $h(y) = f(y \\oplus c)$，其中 $c \\in \\{0,1\\}^n$ 是一个固定的、公开已知的、非零的常数向量，而 $\\oplus$ 表示按位异或操作。\n\n假设原始函数 $f$ 足够难，使得 $G_f$ 成为一个能够抵抗所有多项式时间敌手的密码学安全的伪随机生成器。新生成器 $G_h$ 的安全性与原始生成器 $G_f$ 的安全性相比如何？\n\nA. 生成器 $G_h$ 完全不安全。由于线性变换 `⊕ c` 是公开信息，敌手可以轻易地将其输出与随机数据区分开。\n\nB. $G_h$ 的安全性与 $G_f$ 的安全性完全相同。$h$ 的难度与 $f$ 的难度完全一样。\n\nC. 生成器 $G_h$ 仍然安全，但其可证明安全性略有减弱。它能保证抵抗的电路类别比 $G_f$ 能抵抗的电路类别稍微小一些。\n\nD. $G_h$ 的安全性显著降低（例如，降低一个大于2的常数因子）。修改的线性性质使得 $h$ 比 $f$ 更容易近似。\n\nE. $G_h$ 的安全性可证明地比 $G_f$ 更强。常数 $c$ 充当一个“调整项”(tweak)，增加了底层函数的复杂度，使其更难被电路计算。", "solution": "令 $f:\\{0,1\\}^{n}\\to\\{0,1\\}$ 是 $(S,\\delta)$-难的。定义 $h:\\{0,1\\}^{n}\\to\\{0,1\\}$ 为 $h(y)=f(y\\oplus c)$，其中 $c\\in\\{0,1\\}^{n}$ 是一个固定的非零向量。考虑映射 $\\varphi_{c}:\\{0,1\\}^{n}\\to\\{0,1\\}^{n}$，其定义为 $\\varphi_{c}(y)=y\\oplus c$。这个映射是一个双射，并且如果 $y$ 在 $\\{0,1\\}^{n}$ 上是均匀分布的，那么 $z=\\varphi_{c}(y)$ 也是。\n\n从 $h$ 到 $f$ 的难度传递：假设存在一个规模至多为 $S_{h}$ 的电路 $C_{h}$，使得\n$$\n\\left|\\Pr_{y\\in_{R}\\{0,1\\}^{n}}[C_{h}(y)=h(y)]-\\frac{1}{2}\\right|\\geq\\varepsilon.\n$$\n定义电路 $C_{f}$ 为\n$$\nC_{f}(y)\\triangleq C_{h}(y\\oplus c).\n$$\n那么\n$$\n\\Pr_{y}[C_{f}(y)=f(y)]\n=\\Pr_{y}[C_{h}(y\\oplus c)=f(y)]\n=\\Pr_{z}[C_{h}(z)=f(z\\oplus c)]\n=\\Pr_{z}[C_{h}(z)=h(z)].\n$$\n因此 $C_{f}$ 具有相同的优势：\n$$\n\\left|\\Pr_{y}[C_{f}(y)=f(y)]-\\frac{1}{2}\\right|\n=\\left|\\Pr_{z}[C_{h}(z)=h(z)]-\\frac{1}{2}\\right|\n\\geq\\varepsilon.\n$$\n计算 $y\\mapsto y\\oplus c$ 的规模开销至多为 $t=O(n)$ 个门（每个输入位一个异或门），所以 $\\mathrm{size}(C_{f})\\leq S_{h}+t$。因此，如果 $h$ 不是 $(S-t,\\delta)$-难的，那么 $f$ 也将不是 $(S,\\delta)$-难的。等价地，从 $f$ 是 $(S,\\delta)$-难的，我们推断出 $h$ 是 $(S-t,\\delta)$-难的。反向的证明（从一个用于 $f$ 的电路到一个用于 $h$ 的电路）是对称的，并产生相同的 $O(n)$ 加性开销。因此，$f$ 和 $h$ 的难度参数在电路规模上相差一个加性的 $O(n)$ 移位，而优势 $\\delta$ 完全相同。\n\n对 NW 生成器的影响：标准的 NW 安全性归约指出，如果 $f$ 是 $(S,\\delta)$-难的，且组合设计具有合适的参数，那么任何规模至多为 $T$ 且以至少 $\\varepsilon$ 的优势将 $G_{f}$ 的输出与均匀分布区分开的区分器 $D$，都可以产生一个规模至多为 $\\mathrm{poly}(T)$ 的电路，该电路在随机输入上计算 $f$ 的优势与 $\\varepsilon$ 和 $\\delta$ 相关。若用 $h$ 替代 $f$ 运行相同的归约，则会产生一个用于 $h$ 的预测器，其规模至多为 $\\mathrm{poly}(T)$ 并具有相当的优势；将其与 $y\\mapsto y\\oplus c$ 复合，可以将其转换为一个用于 $f$ 的预测器，该预测器具有相同的优势和一个加性的 $O(n)$ 规模开销。因此，我们能通过归约得到与假设难度相矛盾的区分器 $D$ 的类别，仅仅缩小了对应于该加性 $O(n)$ 开销的多项式部分。从渐近的角度看，如果 $G_{f}$ 能抵抗所有多项式时间的敌手，那么 $G_{h}$ 也仍然安全，但是我们能证明其安全性的电路规模的精确量化界限，在相应的难度参数上略微减弱了，最多为一个加性的 $O(n)$。\n\n因此，这个公开的、固定的与 $c$ 的异或操作既不会使生成器不安全，也不会使其严格更强；它保持了安全性，只是在可证明的参数上存在微小的、纯技术性的衰减，这种衰减既不显著，也并非在严格的 $(S,\\delta)$ 计数层面上完全等同。\n\n因此，正确的选项是 $G_{h}$ 仍然安全，但由于在 $h$ 和 $f$ 的预测器之间进行转换时存在微小的加性开销，其可证明安全性略微减弱了。", "answer": "$$\\boxed{C}$$", "id": "1459796"}]}