{"hands_on_practices": [{"introduction": "复杂性类 **BPP** 中的算法是“大概率正确”的。其定义保证了错误率被一个小于 $1/2$ 的常数（例如 $1/3$）所限制，但这为什么有用呢？因为我们可以通过重复运行算法来将错误率降至任意小。这个练习将具体展示这个被称为“放大”（amplification）的关键思想，你将计算一个简单的三次运行多数表决机制如何显著提高算法的可靠性，这是概率计算的基石之一。[@problem_id:1436863]", "problem": "在计算复杂性理论领域，如果一个判定问题存在一个算法，对于任何给定的输入，能够以至少 $\\frac{2}{3}$ 的概率正确判断该输入是否属于某个语言，那么该问题被称为可由一个有界错误概率多项式时间算法解决。这意味着在任何单次运行中，得到错误答案的概率至多为 $\\frac{1}{3}$。\n\n考虑这样一个算法，我们称之为 `ALG`，它被用来验证数据记录的完整性。对于任何给定的数据记录，`ALG` 给出正确验证结果的概率恰好为 $\\frac{2}{3}$，这意味着其错误概率恰好为 $\\frac{1}{3}$。为了提高可靠性，一位工程师实施了一种放大策略：在相同的输入数据记录上独立运行算法 `ALG` 三次，并通过对三次结果进行多数表决来确定最终答案。\n\n这个多数表决过程产生错误答案的概率是多少？请用最简分数表示你的最终答案。", "solution": "设 $p$ 为算法 `ALG` 单次运行产生错误答案的概率。根据问题陈述，我们有 $p = \\frac{1}{3}$。\n因此，单次运行产生正确答案的概率是 $1 - p = 1 - \\frac{1}{3} = \\frac{2}{3}$。\n\n放大策略包括独立运行算法三次并进行多数表决。当且仅当大多数运行产生错误答案时，此过程的最终结果才会是错误的。对于三次运行，这意味着要么三次运行中有两次是错误的，要么三次运行全部是错误的。\n\n我们来分析这两种互斥的情况。由于各次运行是独立的，我们可以使用二项分布来模拟错误结果的数量。设试验次数（运行次数）为 $n=3$。\n\n情况1：恰好有两次运行是错误的。\n从三次运行中选出哪两次是错误的方式数由二项式系数 $\\binom{3}{2}$ 给出。任何一个包含两次错误运行和一次正确运行的特定序列（例如，错误-错误-正确）的概率是 $p \\cdot p \\cdot (1-p) = p^2 (1-p)$。\n因此，恰好有两次错误运行的总概率是：\n$$P(\\text{2 incorrect}) = \\binom{3}{2} p^2 (1-p)$$\n我们知道 $\\binom{3}{2} = \\frac{3!}{2!(3-2)!} = \\frac{3 \\cdot 2 \\cdot 1}{(2 \\cdot 1)(1)} = 3$。\n代入 $p$ 和 $1-p$ 的值：\n$$P(\\text{2 incorrect}) = 3 \\left(\\frac{1}{3}\\right)^2 \\left(\\frac{2}{3}\\right) = 3 \\cdot \\frac{1}{9} \\cdot \\frac{2}{3} = \\frac{6}{27}$$\n\n情况2：所有三次运行都是错误的。\n这种情况发生的方式数是 $\\binom{3}{3} = 1$。这个特定序列（错误-错误-错误）的概率是 $p \\cdot p \\cdot p = p^3$。\n因此，三次运行都错误的总概率是：\n$$P(\\text{3 incorrect}) = \\binom{3}{3} p^3 (1-p)^0 = 1 \\cdot p^3$$\n代入 $p$ 的值：\n$$P(\\text{3 incorrect}) = \\left(\\frac{1}{3}\\right)^3 = \\frac{1}{27}$$\n\n多数表决过程是错误的的总概率是这两种情况的概率之和：\n$$P(\\text{failure}) = P(\\text{2 incorrect}) + P(\\text{3 incorrect})$$\n$$P(\\text{failure}) = \\frac{6}{27} + \\frac{1}{27} = \\frac{7}{27}$$\n\n最终概率是 $\\frac{7}{27}$。这个分数已经是最简形式，因为 7 和 27 是互质的。", "answer": "$$\\boxed{\\frac{7}{27}}$$", "id": "1436863"}, {"introduction": "现在让我们看一种不同类型的概率算法，它具有“单边错误”，这定义了复杂性类 **RP**。当答案是“是”时，这类算法从不出错，但当答案是“否”时，它们可能会误判。这种不对称性需要一种特定的放大策略。这个练习要求你计算出需要重复运行多少次算法，才能将错误接受的概率降到一个非常低的水平，从而突显我们如何在实践中处理和减少单边错误。[@problem_id:1436854]", "problem": "一位计算机科学家正在为一个关于语言 $L$ 的判定问题设计一个算法。该算法使用一台概率图灵机（Probabilistic Turing Machine, PTM），这是一种标准图灵机的变体，可以在每一步做出随机选择。这台 PTM 旨在成为一个属于被称为随机多项式时间（Randomized Polynomial time, RP）的复杂度类的语言的算法示例。\n\n对于任意给定的输入字符串 $x$，这台记为 $M$ 的特定 PTM 的行为特征如下：\n- 如果字符串 $x$ 属于语言 $L$（即 $x \\in L$），机器 $M$ 保证会停机并输出‘接受’。\n- 如果字符串 $x$ 不属于语言 $L$（即 $x \\notin L$），机器 $M$ 将会停机，并以恰好 $1/4$ 的概率错误地输出‘接受’。它将以 $3/4$ 的概率正确地停机并输出‘拒绝’。\n\n为了提高结果的可靠性，该科学家提出了一个记为 $M_k$ 的放大算法。这个新算法对相同的输入字符串 $x$ 执行原始 PTM $M$ 共 $k$ 次独立试验。$M_k$ 的判定规则定义如下：如果 $k$ 次试验中至少有一次结果为‘拒绝’，则它对输入 $x$ 输出‘拒绝’；否则，如果所有 $k$ 次试验的结果都是‘接受’，$M_k$ 将输出‘接受’。\n\n必须执行的最小整数试验次数 $k$ 是多少，才能确保放大算法 $M_k$ 错误地接受一个不属于语言 $L$ 的输入的概率严格小于 $1\\%$？", "solution": "对于在输入 $x \\notin L$ 上的一次独立运行，$M$ 发生“接受”这一错误事件的概率为 $\\frac{1}{4}$。放大算法 $M_{k}$ 仅在所有 $k$ 次独立运行都接受时才接受。根据独立性，当 $x \\notin L$ 时，所有 $k$ 次运行都接受的概率为\n$$\n\\left(\\frac{1}{4}\\right)^{k}.\n$$\n我们要求这个错误概率严格小于 $\\frac{1}{100}$：\n$$\n\\left(\\frac{1}{4}\\right)^{k} < \\frac{1}{100}.\n$$\n等价地，\n$$\n4^{k} > 100.\n$$\n两边取自然对数，\n$$\nk \\ln 4 > \\ln 100 = 2 \\ln 10,\n$$\n所以\n$$\nk > \\frac{2 \\ln 10}{\\ln 4}.\n$$\n为了找到满足此严格不等式的最小整数 $k$，我们测试 $k=4$：\n$$\n4^{4} = 256 > 100 \\quad \\Longleftrightarrow \\quad \\left(\\frac{1}{4}\\right)^{4} = \\frac{1}{256} < \\frac{1}{100},\n$$\n所以 $k=4$ 足够了。对于 $k=3$，$4^{3} = 64 < 100$，因此不足够。因此，最小整数是 $k=4$。", "answer": "$$\\boxed{4}$$", "id": "1436854"}, {"introduction": "我们已经看到，如果初始成功概率足够高（例如，大于 $1/2$），我们就可以有效降低错误率。这引出一个根本问题：如果概率没那么高呢？本练习是一个思想实验，旨在探讨为什么像 **RP** 这样的定义中概率阈值的设定如此关键。通过分析一个 **RP** 的“弱化”版本——其中对于“是”实例的成功概率仅要求大于零——你将揭示概率计算与非确定性计算之间一个深刻而惊人的联系，从而理解这些复杂性类的定义为何如此精确。[@problem_id:1436826]", "problem": "在计算复杂性理论中，概率图灵机是标准图灵机的一种变体，它可以使用随机性。如果存在一个多项式时间的概率图灵机 $M$，对于任何输入串 $x$都具有以下性质，那么我们称语言 $L$ 属于复杂性类 **RP** (Randomized Polynomial Time)：\n1.  如果 $x$ 在语言 $L$ 中（一个“是”实例），则 $M$ 输出“接受”的概率至少为 $1/2$。形式上，$x \\in L \\implies \\Pr[M(x) \\text{ accepts}] \\geq 1/2$。\n2.  如果 $x$ 不在语言 $L$ 中（一个“否”实例），则 $M$ 输出“接受”的概率恰好为 $0$。形式上，$x \\notin L \\implies \\Pr[M(x) \\text{ accepts}] = 0$。\n\n一名计算机科学专业的学生提出了这个类的一个“更弱”的版本，他们称之为 **RP_weak**。其定义与 **RP** 相同，只是关于“是”实例的条件被放宽了。具体来说，如果存在一个多项式时间的概率图灵机 $M'$，对于任何输入串 $x$都满足以下条件，那么语言 $L$ 就在 **RP_weak** 中：\n1.  如果 $x \\in L$，则 $M'$ 输出“接受”的概率严格大于 $0$。形式上，$x \\in L \\implies \\Pr[M'(x) \\text{ accepts}] > 0$。\n2.  如果 $x \\notin L$，则 $M'$ 输出“接受”的概率恰好为 $0$。形式上，$x \\notin L \\implies \\Pr[M'(x) \\text{ accepts}] = 0$。\n\n这个新定义似乎允许算法在“是”实例上的成功概率极其微小但不为零。问题是，这种改变是否会显著改变该类的计算能力。下列哪个著名的复杂性类被证明与 **RP_weak** 等价？\n\n回顾 **NP** (Nondeterministic Polynomial Time) 的定义：对于每个 $x \\in L$，如果存在一个长度为 $x$ 长度的多项式的“证书”或“见证”串 $y$，使得一个确定性多项式时间图灵机（“验证机”）可以检查 $y$ 证明了 $x \\in L$, 那么语言 $L$ 就在 **NP** 中。对于 $x \\notin L$，不存在这样的证书。\n\nA. P (Polynomial Time)\n\nB. RP (Randomized Polynomial Time)\n\nC. BPP (Bounded-error Probabilistic Polynomial Time)\n\nD. NP (Nondeterministic Polynomial Time)\n\nE. PSPACE (Polynomial Space)", "solution": "设 $L$ 属于 $\\text{RP\\_weak}$，由一个在多项式时间内运行的概率图灵机 $M'$ 见证。根据时间界限，存在一个多项式 $p$，使得在长度为 $n$ 的输入上，$M'$ 最多使用 $p(n)$ 个随机位。对于任意固定的输入 $x$，$M'$ 的每一次执行都对应于固定一个随机串 $r \\in \\{0,1\\}^{p(|x|)}$，并用设为 $r$ 的随机性来运行 $M'$ 的确定性计算。\n\n第一个包含关系 $\\text{RP\\_weak} \\subseteq \\text{NP}$：假设 $x \\in L$。根据定义，$\\Pr[M'(x) \\text{ accepts}] > 0$。由于样本空间是有限的，这意味着至少存在一个随机串 $r \\in \\{0,1\\}^{p(|x|)}$，使得确定性计算 $M'(x;r)$ 接受。考虑验证机 $V$：在输入 $(x,r)$ 上，它模拟在 $x$ 上的 $M'$，并将随机带设置为 $r$，并且当且仅当 $M'$ 接受时，它才接受。该模拟是确定性的，并且因为 $M'$ 是多项式时间的且 $|r| \\leq p(|x|)$，所以它也在 $|x|$ 的多项式时间内运行。如果 $x \\notin L$，根据定义 $\\Pr[M'(x) \\text{ accepts}] = 0$，这意味着对于所有的 $r$，$M'(x;r)$ 都会拒绝。因此不存在接受的见证。所以 $L \\in \\text{NP}$。\n\n第二个包含关系 $\\text{NP} \\subseteq \\text{RP\\_weak}$：设 $L \\in \\text{NP}$，其验证机 $V$ 在 $|x|$ 的多项式时间内运行。存在一个多项式 $p$，使得对于每个 $x \\in L$，都有一个见证 $y \\in \\{0,1\\}^{p(|x|)}$ 使得 $V(x,y)$ 接受；而对于 $x \\notin L$，则不存在这样的 $y$。在输入 $x$ 上，定义一个概率图灵机 $M'$ 如下：均匀随机地抽取一个串 $y \\in \\{0,1\\}^{p(|x|)}$，确定性地运行 $V(x,y)$，并且当且仅当 $V$ 接受时，$M'$ 才接受。这个 $M'$ 在多项式时间内运行。如果 $x \\in L$，则存在一个 $y^{\\ast}$ 使得 $V(x,y^{\\ast})$ 接受，因此\n$$\n\\Pr[M'(x) \\text{ accepts}] \\geq \\Pr[y = y^{\\ast}] = 2^{-p(|x|)} > 0.\n$$\n如果 $x \\notin L$，则对所有的 $y$，$V(x,y)$ 都拒绝，因此\n$$\n\\Pr[M'(x) \\text{ accepts}] = 0.\n$$\n因此 $L \\in \\text{RP\\_weak}$。\n\n综合两个包含关系可得 $\\text{RP\\_weak} = \\text{NP}$。因此，可证明与 **RP_weak** 等价的类是 NP，即选项 D。", "answer": "$$\\boxed{D}$$", "id": "1436826"}]}