{"hands_on_practices": [{"introduction": "我们首先从一个基础练习开始，它将帮助你掌握通过重复执行来降低 BPP 算法错误率的核心机制。这个练习将具体展示，即使一个算法的初始错误率不算很低（例如 $1/3$），我们也可以通过多数表决策略，将其最终错误率降低到一个极小的水平。这个过程被称为“放大”，是计算复杂性理论中证明 BPP 类稳健性的关键所在 [@problem_id:1422498]。", "problem": "一个计算理论研究小组为一个判定问题设计了一种新的概率算法。已知该算法属于复杂度类 BPP (Bounded-error Probabilistic Polynomial-time)，这意味着对于任何给定的输入，它产生正确“是”或“否”答案的概率至少为 $2/3$。因此，任何单次运行的错误概率 $\\epsilon_0$ 至多为 $1/3$。\n\n为了提高结果的可信度，研究人员采用一种放大策略：他们对相同的输入独立运行该算法 $k$ 次，并将多数票的结果作为最终答案。他们希望对一次特别重要的计算达到高度的确定性，要求最终多数票出错的概率小于 $2^{-100}$。\n\n对于此问题，你可以使用以下来自复杂度理论的标准结果，该结果是 Chernoff 界的一个推论：经过 $k$ 次试验后，多数票表决程序的错误概率 $\\delta_k$ 由以下不等式界定：\n$$ \\delta_k \\le \\exp\\left(-2k\\left(\\frac{1}{2} - \\epsilon_0\\right)^2\\right) $$\n其中 $\\epsilon_0$ 是单次试验的错误概率，你应该取其最坏情况下的值。\n\n确定所需的最小整数试验次数 $k$，以确保最终的错误概率小于 $2^{-100}$。在你的计算中，请使用近似值 $\\ln(2) \\approx 0.69315$。", "solution": "给定 $k$ 次独立运行后多数票表决错误的类Chernoff界：\n$$\n\\delta_{k} \\le \\exp\\left(-2k\\left(\\frac{1}{2}-\\epsilon_{0}\\right)^{2}\\right),\n$$\n且单次运行的最坏情况错误率为 $\\epsilon_{0}=\\frac{1}{3}$。代入 $\\epsilon_{0}=\\frac{1}{3}$ 可得\n$$\n\\left(\\frac{1}{2}-\\epsilon_{0}\\right)=\\frac{1}{2}-\\frac{1}{3}=\\frac{1}{6},\n$$\n所以\n$$\n\\delta_{k} \\le \\exp\\left(-2k\\left(\\frac{1}{6}\\right)^{2}\\right)=\\exp\\left(-\\frac{k}{18}\\right).\n$$\n为确保最终错误概率小于 $2^{-100}$，只需满足\n$$\n\\exp\\left(-\\frac{k}{18}\\right) < 2^{-100}.\n$$\n对两边取自然对数，得到\n$$\n-\\frac{k}{18} < -100\\,\\ln(2),\n$$\n这等价于\n$$\n\\frac{k}{18} > 100\\,\\ln(2) \\quad \\Longrightarrow \\quad k > 1800\\,\\ln(2).\n$$\n由于 $k$ 必须是整数，其最小允许值为\n$$\nk_{\\min}=\\left\\lceil 1800\\,\\ln(2)\\right\\rceil.\n$$\n使用给定的近似值 $\\ln(2)\\approx 0.69315$，\n$$\n1800\\,\\ln(2)\\approx 1800\\times 0.69315=1247.67\\ldots,\n$$\n因此\n$$\nk_{\\min}=1248.\n$$", "answer": "$$\\boxed{1248}$$", "id": "1422498"}, {"introduction": "在理解了如何降低错误率之后，一个自然而然的问题是：算法的初始可靠性到底有多重要？本练习通过比较两个具有不同初始错误率（分别为 $1/4$ 和 $1/3$）的算法，来定量地探讨这个问题。你将通过计算发现，为了达到相同的极低错误目标，初始错误率的微小差异会导致所需重复次数的显著不同，从而深刻理解放大技术对初始条件的敏感性 [@problem_id:1422496]。", "problem": "考虑两个概率算法 $\\mathcal{A}_1$ 和 $\\mathcal{A}_2$，它们用于解决相同判定问题，输入大小为 $n$。任一算法单次执行的运行时间由一个多项式函数 $T(n)$ 给出。\n\n对于任何给定的输入，算法 $\\mathcal{A}_1$ 返回正确答案的概率至少为 $3/4$。相比之下，算法 $\\mathcal{A}_2$ 的可靠性较低，返回正确答案的概率至少为 $2/3$。两种算法的错误都是双边的，这意味着它们在问题的“是”实例和“否”实例上都可能出错。\n\n为了提高它们的可靠性，对两种算法都采用了一个标准的放大程序。该程序包括将算法独立运行 $k$ 次，并取结果的多数表决作为最终答案。对于每种算法，我们希望确定所需的最小重复次数 $k_1$（对于 $\\mathcal{A}_1$）和 $k_2$（对于 $\\mathcal{A}_2$），以确保放大后算法的最终错误概率最多为 $2^{-n}$。\n\n设 $Time_1(n) = k_1 T(n)$ 和 $Time_2(n) = k_2 T(n)$ 分别是 $\\mathcal{A}_1$ 和 $\\mathcal{A}_2$ 放大后的总时间复杂度。假设 $n$ 很大，确定比率 $\\frac{Time_2(n)}{Time_1(n)}$ 的值。\n\n请用一个精确的分数表示你的答案。", "solution": "问题要求计算将两个概率算法放大到目标错误概率 $2^{-n}$ 所需总运行时间的渐近比率 $\\frac{Time_2(n)}{Time_1(n)}$。这个比率等同于每种算法所需重复次数的比率 $\\frac{k_2}{k_1}$，因为两种算法的单次运行时间 $T(n)$ 是相同的。\n\n首先，我们确定每种算法单次运行的错误概率。\n对于算法 $\\mathcal{A}_1$，其成功概率为 $p_1 = 3/4$，因此错误概率为 $\\epsilon_1 = 1 - p_1 = 1 - 3/4 = 1/4$。\n对于算法 $\\mathcal{A}_2$，其成功概率为 $p_2 = 2/3$，因此错误概率为 $\\epsilon_2 = 1 - p_2 = 1 - 2/3 = 1/3$。\n两种错误概率都满足 $\\epsilon_i < 1/2$，这是通过多数表决进行放大有效的必要条件。\n\n放大过程包括将一个错误率为 $\\epsilon$ 的算法运行 $k$ 次独立试验，并进行多数表决。设 $X_i$ 为第 $i$ 次试验的指示随机变量，如果算法返回错误答案，则 $X_i=1$，否则 $X_i=0$。我们有 $P(X_i=1) = \\epsilon$。错误答案的总数为 $S_k = \\sum_{i=1}^k X_i$。如果超过一半的试验是错误的，即 $S_k > k/2$，则多数表决是错误的。\n\n为了界定概率 $P(S_k > k/2)$，我们可以使用切诺夫界的一个版本，即霍夫丁不等式 (Hoeffding's inequality)。对于 $k$ 个独立伯努利变量的和 $S_k$，其均值为 $E[S_k] = k\\epsilon$，该不等式表述为：\n$$ P(S_k \\ge (1+\\delta)E[S_k]) \\le \\exp\\left(-\\frac{\\delta^2}{3}E[S_k]\\right) $$\n一种更直接且常用于 BPP 放大的形式指出，多数表决结果错误的概率有界于：\n$$ P(\\text{error}) \\le \\exp(-2k(1/2 - \\epsilon)^2) $$\n我们希望这个最终错误概率最多为 $2^{-n}$。因此，我们建立不等式：\n$$ \\exp(-2k(1/2 - \\epsilon)^2) \\le 2^{-n} $$\n对两边取自然对数：\n$$ -2k(1/2 - \\epsilon)^2 \\le n \\ln(2^{-1}) = -n \\ln(2) $$\n两边乘以 $-1$ 并反转不等号：\n$$ 2k(1/2 - \\epsilon)^2 \\ge n \\ln(2) $$\n求解 $k$，我们得到所需的最小重复次数：\n$$ k \\ge \\frac{n \\ln(2)}{2(1/2 - \\epsilon)^2} $$\n这可以简化为：\n$$ k \\ge \\frac{n \\ln(2)}{2\\left(\\frac{1-2\\epsilon}{2}\\right)^2} = \\frac{n \\ln(2)}{2 \\frac{(1-2\\epsilon)^2}{4}} = \\frac{2n \\ln(2)}{(1-2\\epsilon)^2} $$\n对于大的 $n$，我们可以用右侧（R.H.S）的值来近似所需的最小重复次数 $k$，因为上取整函数对该比率的影响可以忽略不计。\n$$ k \\approx \\frac{2n \\ln(2)}{(1-2\\epsilon)^2} $$\n\n现在，我们计算每种算法所需的重复次数。\n\n对于算法 $\\mathcal{A}_1$，其 $\\epsilon_1 = 1/4$：\n$$ k_1 \\approx \\frac{2n \\ln(2)}{(1 - 2(1/4))^2} = \\frac{2n \\ln(2)}{(1 - 1/2)^2} = \\frac{2n \\ln(2)}{(1/2)^2} = \\frac{2n \\ln(2)}{1/4} = 8n \\ln(2) $$\n\n对于算法 $\\mathcal{A}_2$，其 $\\epsilon_2 = 1/3$：\n$$ k_2 \\approx \\frac{2n \\ln(2)}{(1 - 2(1/3))^2} = \\frac{2n \\ln(2)}{(1 - 2/3)^2} = \\frac{2n \\ln(2)}{(1/3)^2} = \\frac{2n \\ln(2)}{1/9} = 18n \\ln(2) $$\n\n最后，我们计算总运行时间的比率。\n$$ \\frac{Time_2(n)}{Time_1(n)} = \\frac{k_2 T(n)}{k_1 T(n)} = \\frac{k_2}{k_1} $$\n代入 $k_1$ 和 $k_2$ 的表达式：\n$$ \\frac{k_2}{k_1} \\approx \\frac{18n \\ln(2)}{8n \\ln(2)} = \\frac{18}{8} = \\frac{9}{4} $$\n该比率是一个常数，不依赖于 $n$ 或 $T(n)$。", "answer": "$$\\boxed{\\frac{9}{4}}$$", "id": "1422496"}, {"introduction": "理论计算最终要服务于实践决策。最后一个练习将我们带入一个更贴近现实的应用场景，其中除了可靠性，还必须考虑成本效益。你需要在两个性能和成本各不相同的概率算法之间做出选择，以最低的总成本达到预设的成功率目标。这个问题将理论知识与经济权衡相结合，锻炼你在约束条件下解决优化问题的能力 [@problem_id:1422544]。", "problem": "一家网络安全公司可以使用两种不同的概率算法（算法A和算法B）来检验用于加密密钥的大数的素性。两种算法都可以通过多次运行并采用多数表决的方式来增强其效果。\n\n- 算法A的初始成功概率为 $p_A = 0.52$，每次运行的成本为 $c_A = 1.00$ 美元。\n- 算法B的初始成功概率为 $p_B = 0.51$，每次运行的成本为 $c_B = 0.50$ 美元。\n\n一个增强后的算法在 $k$ 次独立运行后的可靠性由其失败概率 $P_{\\text{fail}}(k)$ 决定。对于给定的初始成功概率 $p = 0.5 + \\epsilon$，该失败概率的一个上界由下式给出：\n$$P_{\\text{fail}}(k) \\le \\exp(-2k\\epsilon^2)$$\n\n该公司需要选择其中一种算法，并确定需要运行的次数，以达到至少 $99.99\\%$ 的成功概率，同时最小化总财务成本。这个可能的最低总成本是多少？\n\n请以美元作答，并四舍五入到两位有效数字。", "solution": "给定两种算法的初始成功概率为 $p_{A}=0.52$ 和 $p_{B}=0.51$，因此我们记 $p=0.5+\\epsilon$，其中 $\\epsilon_{A}=0.02$ 和 $\\epsilon_{B}=0.01$。经过 $k$ 次独立运行并采用多数表决后，失败概率的上界为\n$$\nP_{\\text{fail}}(k)\\leq \\exp\\big(-2k\\epsilon^{2}\\big).\n$$\n为保证成功概率至少为 $0.9999$，我们需要 $P_{\\text{fail}}(k)\\leq 0.0001=10^{-4}$。因此，对于给定的 $\\epsilon$，\n$$\n\\exp\\big(-2k\\epsilon^{2}\\big)\\leq 10^{-4}.\n$$\n两边取自然对数，并解出 $k$，\n$$\n-2k\\epsilon^{2}\\leq \\ln\\big(10^{-4}\\big)=-4\\ln(10)\n\\quad\\Longrightarrow\\quad\nk\\geq \\frac{\\ln\\big(10^{4}\\big)}{2\\epsilon^{2}}=\\frac{4\\ln(10)}{2\\epsilon^{2}}=\\frac{2\\ln(10)}{\\epsilon^{2}}.\n$$\n因此，所需的最小整数运行次数为\n$$\nk^{\\ast}(\\epsilon)=\\left\\lceil \\frac{2\\ln(10)}{\\epsilon^{2}}\\right\\rceil.\n$$\n对于算法A，有 $\\epsilon_{A}=0.02$，\n$$\nk_{A}^{\\ast}=\\left\\lceil \\frac{2\\ln(10)}{(0.02)^{2}}\\right\\rceil\n=\\left\\lceil \\frac{2\\ln(10)}{0.0004}\\right\\rceil\n=\\left\\lceil 5000\\ln(10)\\right\\rceil.\n$$\n使用 $\\ln(10)\\approx 2.302585093$，我们得到\n$$\nk_{A}^{\\ast}=\\left\\lceil 5000\\times 2.302585093\\right\\rceil=\\left\\lceil 11512.925465\\right\\rceil=11513.\n$$\n则算法A的总成本为\n$$\n\\text{Cost}_{A}=c_{A} \\times k_{A}^{\\ast}=1.00 \\times 11513=11513.\n$$\n对于算法B，有 $\\epsilon_{B}=0.01$，\n$$\nk_{B}^{\\ast}=\\left\\lceil \\frac{2\\ln(10)}{(0.01)^{2}}\\right\\rceil\n=\\left\\lceil \\frac{2\\ln(10)}{0.0001}\\right\\rceil\n=\\left\\lceil 20000\\ln(10)\\right\\rceil\n=\\left\\lceil 46051.70186\\right\\rceil=46052.\n$$\n算法B的总成本为\n$$\n\\text{Cost}_{B}=c_{B} \\times k_{B}^{\\ast}=0.50 \\times 46052=23026.\n$$\n比较可知，$\\text{Cost}_{A}=11513$ 且 $\\text{Cost}_{B}=23026$，因此最低可能总成本由算法A实现，为 $11513$ 美元。四舍五入到两位有效数字，得到 $1.2\\times 10^{4}$。", "answer": "$$\\boxed{1.2 \\times 10^{4}}$$", "id": "1422544"}]}