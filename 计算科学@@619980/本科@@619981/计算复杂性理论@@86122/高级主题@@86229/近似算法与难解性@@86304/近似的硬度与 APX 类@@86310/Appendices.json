{"hands_on_practices": [{"introduction": "理论是实践的根基，而实践能加深我们对理论的理解。我们首先从一个经典的NP-hard问题——顶点覆盖问题（Vertex Cover）入手。通过分析一个简单直观的贪心算法，你将亲手实践如何严格证明一个近似比，并掌握利用极大匹配（maximal matching）来为最优解的大小建立下界的核心分析技巧。[@problem_id:1426648]", "problem": "在计算复杂性理论中，许多优化问题是 NP难 的，这意味着我们不期望找到一个能在多项式时间内最优地解决它们的算法。对于这类问题，我们通常寻求多项式时间的近似算法，以保证其解在最优解的某个因子范围内。\n\n考虑 **最小顶点覆盖** (MINIMUM VERTEX COVER) 问题：给定一个无向图 $G = (V, E)$，其中 $V$ 是顶点集，$E$ 是边集，找到一个大小尽可能小的顶点子集 $V' \\subseteq V$，使得 $E$ 中的每条边至少有一个端点在 $V'$ 中。\n\n让我们来分析一个解决此问题的简单贪心算法，我们称之为 **EDGE-PICKER**：\n1. 初始化顶点覆盖 $C$ 为一个空集。\n2. 当图中仍至少含有一条边时：\n   a. 从图的边集 $E$ 中任选一条边 $(u, v)$。\n   b. 将两个顶点 $u$ 和 $v$ 都加入到覆盖 $C$ 中。\n   c. 从图中移除边 $(u,v)$ 以及所有与 $u$ 或 $v$ 相关联的其他边。\n3. 返回集合 $C$ 作为近似的顶点覆盖。\n\n对于一个最小化问题，其算法的 **近似比** (approximation ratio) 是指在所有可能的输入上，该算法产生的解的大小与最优解的大小的最大可能比值。一个 **紧致** (tight) 近似比是指，存在一个输入实例，使得该算法的性能恰好达到该比率。\n\n对于最小顶点覆盖问题，EDGE-PICKER 算法的紧致近似比是多少？\n\nA. $1.5$\n\nB. $2$\n\nC. $\\log_2(|V|)$，其中 $|V|$ 是图中顶点的数量。\n\nD. $|V|^{1/2}$\n\nE. 该比率不受任何关于 $|V|$ 的函数的限制。", "solution": "设 $G=(V,E)$ 为输入图。运行 EDGE-PICKER 算法，并令 $C$ 为返回的集合。设 $M$ 为执行过程中在步骤 2a 中选择的边的集合。\n\n首先，$M$ 是一个匹配 (matching)。确实，当一条边 $(u,v)$ 被选中时，步骤 2c 会移除所有与 $u$ 或 $v$ 相关联的边。因此，之后选择的任何边都不能与 $(u,v)$ 共享端点，所以被选中的边是两两不相交的。\n\n此外，$M$ 是图 $G$ 中的一个极大匹配 (maximal matching)。算法终止时，残余图中已无任何边；因此，在 $G$ 中不存在两个端点都在 $M$ 中各边端点集之外的边，否则这样的边将仍然存在且可被选择。因此，在不破坏匹配性质的前提下，没有额外的边可以被加入到 $M$ 中。\n\n因为算法将 $M$ 中每条边的两个端点都加入到 $C$ 中，并且 $M$ 中的边是不相交的，所以没有端点被重复添加。因此\n$$\n|C|=2|M|.\n$$\n设 $C^{*}$ 为一个最优顶点覆盖。$M$ 中的每一条边都必须被 $C^{*}$ 覆盖。由于 $M$ 中的边是不相交的，覆盖这些边需要每条边至少有一个不同的端点在 $C^{*}$ 中。因此\n$$\n|C^{*}| \\ge |M|.\n$$\n结合这两个不等式可得\n$$\n|C| = 2|M| \\le 2|C^{*}|,\n$$\n所以近似比至多为 $2$。\n\n为了证明其紧致性，考虑一个由一个中心点和 $k$ 个叶节点组成的星形图。一个最优顶点覆盖的大小为 $1$（即中心点）。EDGE-PICKER 算法选择某条边 $(\\text{center}, \\text{leaf})$，将其两个端点都加入覆盖，然后移除所有边，最终返回的 $|C|=2$。因此，比率 $|C|/|C^{*}|=2$。或者，在一个由 $k$ 条不相交的边组成的图上，最优顶点覆盖 $|C^{*}|=k$，而 EDGE-PICKER 算法返回 $2k$ 个顶点，比率同样为 $2$。\n\n因此，EDGE-PICKER 算法的紧致近似比是 $2$，对应选项 B。", "answer": "$$\\boxed{B}$$", "id": "1426648"}, {"introduction": "优秀的算法思想往往具有普适性。在下一个练习中，我们将前一个练习中的顶点覆盖问题推广到更一般化的超图（hypergraph）场景。这项实践旨在挑战你将在标准图上学到的分析方法进行调整和应用，以应对更复杂的结构。通过这个过程，你将清晰地看到近似比是如何随着问题的结构参数（具体来说，是超边的大小上限 $d$）而变化的。[@problem_id:1426652]", "problem": "在图论中，标准图上的顶点覆盖问题可以推广到超图。一个超图是一个偶对 $H = (V, E)$，其中 $V$ 是一个顶点集合，$E$ 是一个超边集合，每条超边都是 $V$ 的一个非空子集。$H$ 的一个顶点覆盖是顶点的一个子集 $C \\subseteq V$，使得对于 $E$ 中的每一条超边 $e$， $e$ 和 $C$ 的交集非空 ($e \\cap C \\neq \\emptyset$)。\n\n这个被称为超图顶点覆盖的优化问题，是找到一个大小尽可能小的顶点覆盖。已知该问题是 NP难 的。该问题的一个特例是 $d$-超图顶点覆盖问题，其中每条超边 $e \\in E$ 的大小最多为 $d$，即对于一个固定的整数 $d \\ge 2$，有 $|e| \\le d$。注意，当 $d=2$ 时，这就是图上的标准顶点覆盖问题。\n\n考虑以下为找到 $d$-超图顶点覆盖问题的近似解而设计的贪心算法：\n\n1. 初始化顶点覆盖 $C$ 为空集。\n2. 当 $E$ 中至少存在一条未被 $C$ 覆盖的超边时：\n    a. 选择一条任意的尚未被覆盖的超边 $e' \\in E$ (即 $e' \\cap C = \\emptyset$)。\n    b. 将该超边 $e'$ 的所有顶点添加到覆盖中。通过设置 $C := C \\cup e'$ 来更新 $C$。\n3. 返回最终的集合 $C$。\n\n这类算法的性能由其近似比来衡量。对于一个最小化问题，近似比是指算法产生的解的大小与最优解大小之比在所有可能输入上的最大值。\n\n确定该贪心算法对于 $d$-超图顶点覆盖问题的最坏情况近似比。请用一个关于 $d$ 的符号表达式来表示你的答案。", "solution": "令 $H=(V,E)$ 是一个秩至多为 $d$ 的超图，也就是说，对于每一个 $e \\in E$ 都有 $|e| \\leq d$。设所述的贪心算法产生一个覆盖 $C$。定义 $S \\subseteq E$ 为算法在步骤 2a 中明确选择，并将其所有顶点加入 $C$ 的那些超边的集合。设 $k=|S|$。\n\n断言 1：$S$ 中的超边是两两不相交的。\n证明：考虑在两次不同的迭代中选择了 $e_{i},e_{j} \\in S$，其中 $i<j$。当 $e_{i}$ 被选中时，算法将 $e_{i}$ 的所有顶点加入 $C$，因此任何与 $e_{i}$ 相交的超边都会被覆盖。由于 $e_{j}$ 是在之后的迭代中被选中的，它在那个时候必然是未被覆盖的，因此 $e_{i} \\cap e_{j} = \\emptyset$。所以，$S$ 中的所有超边都是两两不相交的。\n\n从这种不相交性我们可以得到两个界。\n\n算法输出大小的上界：\n$$\n|C|=\\left|\\bigcup_{e \\in S} e\\right|=\\sum_{e \\in S} |e| \\leq \\sum_{e \\in S} d = dk.\n$$\n任意最优顶点覆盖 $C^{*}$ 大小的下界：因为每个 $e \\in S$ 都必须被 $C^{*}$ 覆盖，并且 $S$ 中的超边是两两不相交的，所以 $C^{*}$ 必须从每个 $e \\in S$ 中包含至少一个不同的顶点，因此\n$$\n|C^{*}| \\geq k.\n$$\n结合这两个不等式可得\n$$\n|C| \\leq dk \\leq d |C^{*}|.\n$$\n因此，该算法的近似比最多为 $d$。\n\n紧致性：考虑一个超图，其中存在一个顶点 $v$ 被包含在每一条超边中，并且有 $m$ 条超边 $e_{1},\\ldots,e_{m}$，每条的大小都恰好为 $d$，其中 $e_{i}=\\{v\\} \\cup S_{i}$，且集合 $S_{1},\\ldots,S_{m}$ 两两不相交。一个最优覆盖是 $\\{v\\}$，所以 $|C^{*}|=1$。该算法首先任选一条未被覆盖的超边 $e_{i}$，并将其全部 $d$ 个顶点加入 $C$。这个集合包含了 $v$，因此覆盖了所有超边。因此 $|C|=d$，近似比为 $d$。这说明这个界是紧的。\n\n因此，该贪心算法的最坏情况近似比恰好是 $d$。", "answer": "$$\\boxed{d}$$", "id": "1426652"}, {"introduction": "并非所有看似合理的贪心策略都能得到良好的结果，认识算法的局限性与证明其有效性同等重要。我们将转向另一个与顶点覆盖密切相关的NP-hard问题——最大独立集（Maximum Independent Set）。这项实践将指导你通过构造一个特殊的图族来进行“最坏情况”分析，揭示一个直观的贪心启发式算法在特定实例上表现可以任意地差。这强调了在算法设计中，严谨的分析远比单纯的直觉更为关键。[@problem_id:1426630]", "problem": "在计算复杂性理论中，许多优化问题是NP难的，这意味着没有已知的算法可以在多项式时间内找到最优解。对于这类问题，我们通常依赖多项式时间的启发式算法，旨在找到一个“足够好”但不一定最优的解。图上的一个最基本的NP难问题是最大独立集（MIS）问题。独立集是图中的一个顶点子集，其中任意两个顶点都不相邻。MIS问题旨在找到一个大小尽可能大的独立集。\n\n考虑一个解决此问题的简单启发式算法，我们称之为**贪心选择启发式算法**。该启发式算法的工作方式如下：\n1. 初始化独立集 $S$ 为空集。\n2. 当图中仍有顶点时：\n   a. 从图中任选一个顶点 $v$。\n   b. 将 $v$ 加入集合 $S$。\n   c. 从图中删除 $v$ 及其所有邻居。\n3. 返回集合 $S$。\n\n该启发式算法找到的解的质量可能在很大程度上取决于每一步所做的“任意”选择。为了分析其局限性，我们考虑一个特定的图族 $G_k$，它由一个整数 $k \\ge 2$ 参数化。图 $G_k$ 的构造如下：\n- 顶点集由两个不相交的顶点集组成：一个集合 $C = \\{c_1, c_2, \\dots, c_k\\}$ 和一个集合 $U = \\{u_1, u_2, \\dots, u_k\\}$。\n- 边集由两条规则定义：\n    1. 集合 $C$ 中的顶点形成一个团；也就是说，$C$ 中每一对不同的顶点 $(c_i, c_j)$ 都由一条边连接。\n    2. 对于每一对满足 $i \\neq j$ 的下标 $(i, j)$，都有一条边连接顶点 $c_i \\in C$ 和顶点 $u_j \\in U$。\n\n你的任务是确定贪心选择启发式算法在这个图族上的性能保证。具体来说，就是求出比率 $\\frac{\\alpha(G_k)}{|S_{\\text{worst}}|}$，其中 $\\alpha(G_k)$ 是 $G_k$ 中真正的最大独立集的大小，而 $|S_{\\text{worst}}|$ 是贪心选择启发式算法通过一系列特别“不幸”的选择可能产生的最小独立集的大小。\n\n请将你的答案表示为关于 $k$ 的函数。", "solution": "我们首先重述 $G_{k}$ 的结构。顶点集为 $V=C \\cup U$，其中 $C=\\{c_{1},\\dots,c_{k}\\}$ 和 $U=\\{u_{1},\\dots,u_{k}\\}$ 不相交。其边为：\n1) $C$ 导出一个团，因此每一对不同的顶点 $c_{i}, c_{j}$ 都相邻。\n2) 对于 $i \\neq j$，$c_{i}$ 与 $u_{j}$ 相邻。因此，$c_{i}$ 不与 $u_{i}$ 相邻，并且 $U$ 内部没有边。\n\n确定 $\\alpha(G_{k})$。由于 $U$ 的顶点之间没有边，集合 $U$ 是一个大小为 $k$ 的独立集，因此\n$$\n\\alpha(G_{k}) \\geq k.\n$$\n设 $S$ 为任意独立集，记 $a=|S \\cap C|$ 和 $b=|S \\cap U|$。由于 $C$ 是一个团，我们有 $a \\leq 1$。如果 $a=0$，那么 $|S|=b \\leq k$。如果 $a=1$，比如说 $c_{i} \\in S$，那么对于每个 $j \\neq i$，$c_{i}$ 都与 $u_{j}$ 相邻，所以对于所有 $j \\neq i$ 都有 $u_{j} \\notin S$，并且从 $U$ 中只有 $u_{i}$ 可能被包含进来。因此 $b \\leq 1$ 且 $|S|=a+b \\leq 2$。在所有情况下，\n$$\n|S| \\leq k.\n$$\n结合下界可得\n$$\n\\alpha(G_{k})=k.\n$$\n\n在最坏情况下分析贪心选择启发式算法。该算法迭代地选择一个顶点 $v$，将 $v$ 插入 $S$，并删除 $v$ 及其所有邻居。\n\n考虑一个“不幸”的初始选择 $v=c_{i} \\in C$。$c_{i}$ 的邻居恰好是 $(C \\setminus \\{c_{i}\\}) \\cup (U \\setminus \\{u_{i}\\})$。在删除 $c_{i}$ 及其邻居后，唯一剩下的顶点是 $u_{i}$。下一步（也是最后一步）选择 $u_{i}$，过程终止。因此，在这次运行中，启发式算法输出一个独立集，其大小为\n$$\n|S|=2.\n$$\n或者，如果第一个选择是 $v=u_{j} \\in U$，那么 $u_{j}$ 的邻居正好是 $\\{c_{i}: i \\neq j\\}$。在删除 $u_{j}$ 和这些邻居后，剩下的顶点是 $c_{j}$ 和所有满足 $\\ell \\neq j$ 的 $u_{\\ell}$。一个对抗性的第二步选择 $v=c_{j}$ 会删除 $c_{j}$ 以及所有剩下的满足 $\\ell \\neq j$ 的 $u_{\\ell}$，不留下任何顶点。然后启发式算法输出集合 $S=\\{u_{j},c_{j}\\}$，其大小为\n$$\n|S|=2.\n$$\n无论哪种情况，启发式算法都不能在一次选择后就终止，因为第一次选择至少会留下一个不与其相邻的顶点（具体来说，如果 $v=c_{i}$，会留下 $u_{i}$；如果 $v=u_{j}$，至少会留下 $c_{j}$）。因此，该启发式算法在 $G_{k}$ 上能产生的最小独立集的大小是\n$$\n|S_{\\text{worst}}|=2.\n$$\n\n因此，所要求的性能比率是\n$$\n\\frac{\\alpha(G_{k})}{|S_{\\text{worst}}|}=\\frac{k}{2}.\n$$", "answer": "$$\\boxed{\\frac{k}{2}}$$", "id": "1426630"}]}