{"hands_on_practices": [{"introduction": "顶点覆盖问题是计算理论中的一个经典 NP-困难问题。一个简单而有效的 2-近似算法是基于寻找图中的极大匹配。这个练习将带你亲手实践这一过程：给定一个具体的图和其中的一个极大匹配，你的任务是应用该算法的规则，构造出相应的顶点覆盖集。通过这个练习，你将巩固对该核心算法步骤的理解。[@problem_id:1412472]", "problem": "考虑一个由顶点集 $V$ 和边集 $E$ 定义的无向图 $G = (V, E)$。\n顶点集为 $V = \\{v_1, v_2, v_3, v_4, v_5, v_6, v_7, v_8, v_9\\}$。\n边集为 $E = \\{(v_1, v_2), (v_1, v_4), (v_2, v_3), (v_3, v_6), (v_4, v_5), (v_4, v_7), (v_5, v_6), (v_7, v_8), (v_8, v_9)\\}$。\n\n该图的一个极大匹配 $M$ 以边集的形式给出：\n$M = \\{(v_1, v_2), (v_3, v_6), (v_4, v_5), (v_7, v_8)\\}$。\n\n顶点覆盖是顶点的一个子集 $C \\subseteq V$，使得 $E$ 中的每条边都至少有一个端点在 $C$ 中。构造顶点覆盖的一种方法是，将给定的极大匹配 $M$ 中所有边的端点顶点组成一个集合。\n\n下列哪个集合代表了由这一特定过程生成的顶点覆盖？\n\nA. $\\{v_1, v_2, v_3, v_4, v_5, v_6, v_7, v_8\\}$\n\nB. $\\{v_2, v_4, v_6, v_8\\}$\n\nC. $\\{v_2, v_5, v_6, v_8\\}$\n\nD. $\\{v_1, v_3, v_4, v_7, v_9\\}$\n\nE. $\\{v_1, v_2, v_3, v_4, v_5, v_6, v_7, v_8, v_9\\}$", "solution": "我们给定一个无向图 $G=(V,E)$，其中 $V=\\{v_{1},v_{2},v_{3},v_{4},v_{5},v_{6},v_{7},v_{8},v_{9}\\}$ 以及一个极大匹配 $M=\\{(v_{1},v_{2}),(v_{3},v_{6}),(v_{4},v_{5}),(v_{7},v_{8})\\}$。所描述的过程通过取 $M$ 中所有边的所有端点来构造一个顶点覆盖。形式上，定义\n$$\nC=\\bigcup_{(u,v)\\in M}\\{u,v\\}.\n$$\n将此应用于给定的 $M$，\n$$\nC=\\{v_{1},v_{2}\\}\\cup\\{v_{3},v_{6}\\}\\cup\\{v_{4},v_{5}\\}\\cup\\{v_{7},v_{8}\\}=\\{v_{1},v_{2},v_{3},v_{4},v_{5},v_{6},v_{7},v_{8}\\}.\n$$\n为确认 $C$ 是一个顶点覆盖，取 $E$ 中的任意边 $(x,y)$。如果 $(x,y)\\in M$，那么根据构造，$x$ 和 $y$ 都在 $C$ 中。如果 $(x,y)\\notin M$，根据 $M$ 的极大性，这意味着 $x$ 或 $y$ 中至少有一个顶点与 $M$ 中的某条边邻接（否则 $(x,y)$ 就可以被加入到 $M$ 中），因此至少有一个端点位于 $C$ 中。所以，$E$ 中的每条边在 $C$ 中都有一个端点，因此 $C$ 是一个顶点覆盖。计算出的集合与选项A相符。", "answer": "$$\\boxed{A}$$", "id": "1412472"}, {"introduction": "集合覆盖问题是顶点覆盖问题的一个泛化，在现实世界中有着广泛的应用。解决该问题的经典贪心算法遵循一个直观的启发式策略：在每一步都选择能覆盖最多未被覆盖元素的新集合。本练习将这一抽象算法置于一个选择手机应用的具体场景中，让你通过分步追踪贪心选择过程，深入理解其工作机制和决策逻辑。[@problem_id:1412448]", "problem": "一名计算机科学专业的学生 Alex 正在寻找一组智能手机应用程序，以覆盖一系列所需的功能。所有所需功能的全集由集合 $U$ 给出：\n$U = \\{ \\text{照片编辑, 视频剪辑, 云同步, 任务管理, 日历集成, 笔记, 文件共享, 深色模式} \\}$。\n\nAlex 找到了六个潜在的应用程序。每个应用程序提供的功能如下所列：\n- $A_1$ (Creative Suite): $\\{ \\text{照片编辑, 视频剪辑, 深色模式} \\}$\n- $A_2$ (Organizer Pro): $\\{ \\text{任务管理, 日历集成, 笔记} \\}$\n- $A_3$ (SyncSphere): $\\{ \\text{云同步, 文件共享, 笔记, 深色模式} \\}$\n- $A_4$ (QuickTools): $\\{ \\text{视频剪辑, 任务管理, 文件共享} \\}$\n- $A_5$ (Notes & Cloud): $\\{ \\text{笔记, 云同步} \\}$\n- $A_6$ (ProjectFlow): $\\{ \\text{任务管理, 日历集成, 文件共享} \\}$\n\nAlex 想要选择最少数量的应用程序来提供 $U$ 中的所有功能。这是一个集合覆盖问题的实例，该问题是众所周知的计算难题。为了找到一个近似解，Alex 决定使用标准的贪心算法。\n\n贪心算法的工作方式如下：在每一步中，选择能覆盖最多尚未被已选应用覆盖的功能的应用。如果覆盖最多新功能的数量出现平局，则选择下标最小的应用（例如，如果 $i < j$，则选择 $A_i$ 而不是 $A_j$）。\n\n按照这个贪心算法，Alex 选择的第一个和第二个应用是什么？你的答案应该是一个有序对，形式为（第一个应用，第二个应用）。\n\nA. ($A_3$, $A_1$)\n\nB. ($A_3$, $A_2$)\n\nC. ($A_1$, $A_4$)\n\nD. ($A_3$, $A_4$)\n\nE. ($A_2$, $A_6$)\n\nF. ($A_4$, $A_3$)", "solution": "用符号表示各项功能：PE (Photo Editing), VT (Video Trimming), CS (Cloud Sync), TM (Task Management), CI (Calendar Integration), NT (Note Taking), FS (File Sharing), DM (Dark Mode)。那么\n$$U=\\{ \\text{PE}, \\text{VT}, \\text{CS}, \\text{TM}, \\text{CI}, \\text{NT}, \\text{FS}, \\text{DM} \\}.$$\n这些应用是\n$$A_{1}=\\{\\text{PE},\\text{VT},\\text{DM}\\},\\quad A_{2}=\\{\\text{TM},\\text{CI},\\text{NT}\\},\\quad A_{3}=\\{\\text{CS},\\text{FS},\\text{NT},\\text{DM}\\},$$\n$$A_{4}=\\{\\text{VT},\\text{TM},\\text{FS}\\},\\quad A_{5}=\\{\\text{NT},\\text{CS}\\},\\quad A_{6}=\\{\\text{TM},\\text{CI},\\text{FS}\\}.$$\n贪心规则在每一步选择一个 $A_{i}$，使得新覆盖的功能数量最大化，即最大化 $\\left|A_{i}\\setminus S\\right|$，其中 $S$ 是已覆盖功能的集合。\n\n第一步：初始时 $S=\\varnothing$，所以 $\\left|A_{i}\\setminus S\\right|=\\left|A_{i}\\right|$。计算各个集合的大小：\n$$\\left|A_{1}\\right|=3,\\ \\left|A_{2}\\right|=3,\\ \\left|A_{3}\\right|=4,\\ \\left|A_{4}\\right|=3,\\ \\left|A_{5}\\right|=2,\\ \\left|A_{6}\\right|=3.$$\n最大值为 $4$，仅由 $A_{3}$ 达到，所以第一个选择是 $A_{3}$。现在\n$$S_{1}=A_{3}=\\{\\text{CS},\\text{FS},\\text{NT},\\text{DM}\\},\\quad U\\setminus S_{1}=\\{\\text{PE},\\text{VT},\\text{TM},\\text{CI}\\}.$$\n\n第二步：对于剩下的每个应用，计算相对于 $S_{1}$ 新覆盖的功能：\n$$A_{1}\\setminus S_{1}=\\{\\text{PE},\\text{VT}\\}\\ \\Rightarrow\\ \\left|A_{1}\\setminus S_{1}\\right|=2,$$\n$$A_{2}\\setminus S_{1}=\\{\\text{TM},\\text{CI}\\}\\ \\Rightarrow\\ \\left|A_{2}\\setminus S_{1}\\right|=2,$$\n$$A_{4}\\setminus S_{1}=\\{\\text{VT},\\text{TM}\\}\\ \\Rightarrow\\ \\left|A_{4}\\setminus S_{1}\\right|=2,$$\n$$A_{5}\\setminus S_{1}=\\varnothing\\ \\Rightarrow\\ \\left|A_{5}\\setminus S_{1}\\right|=0,$$\n$$A_{6}\\setminus S_{1}=\\{\\text{TM},\\text{CI}\\}\\ \\Rightarrow\\ \\left|A_{6}\\setminus S_{1}\\right|=2.$$\n新覆盖功能数量的最大值是 $2$，在 $A_{1},A_{2},A_{4},A_{6}$ 之间出现平局。根据平局决胜规则（最小下标），选择 $A_{1}$ 作为第二个应用。\n\n因此，前两个选择是 $(A_{3},A_{1})$，对应选项 A。", "answer": "$$\\boxed{A}$$", "id": "1412448"}, {"introduction": "评估一个近似算法不仅要了解其工作原理，还要理解其性能边界。这个练习将引导我们回到顶点覆盖问题，并分析其 2-近似算法的性能。通过构建一个由多个“星形图”组成的特殊网络结构，我们将看到该算法产生的解的大小恰好是该实例最优解的两倍，这直接证明了其近似比 $2$ 是一个“紧致”的界限。[@problem_id:1412471]", "problem": "一位系统架构师正在为分布式计算网络设计一种监控策略。该网络被建模为一个图 $G=(V, E)$，其中顶点集 $V$ 代表服务器，边集 $E$ 代表直接的通信链路。“监控集”是服务器的一个子集 $C \\subseteq V$，使得 $E$ 中的每条通信链路都至少连接到 $C$ 中的一个服务器。这在形式上被称为顶点覆盖。\n\n找到一个最小可能规模的监控集是一个 NP-难问题。因此，该架构师采用了一种近似算法。该算法的工作方式如下：\n1. 从一个空的监控集 $C = \\emptyset$ 开始。\n2. 当网络中仍有未覆盖的链路时，任选一条未覆盖的链路 $(u, v)$。\n3. 将服务器 $u$ 和 $v$ 都添加到监控集 $C$ 中。\n4. 现在，所有连接到 $u$ 或 $v$ 的链路都被视为已覆盖。\n5. 重复此过程，直到所有链路都被覆盖。\n\n这个过程等同于在图中找到一个极大匹配 $M$，然后由 $M$ 中所有边的端点构成顶点覆盖 $C$。\n\n为了对该算法进行压力测试，该架构师构建了一个特殊的测试用例图。这个图 $G$ 由 $k=50$ 个独立的不相交分量组成。每个分量都是一个 $K_{1,n}$ 类型的“星形图”，其中 $n=10$。一个 $K_{1,n}$ 图由一个中心服务器通过链路连接到 $n$ 个外围服务器组成。因此，整个图 $G$ 由 50 个独立的服务器星形簇组成。\n\n对于此测试，通过从 50 个星形图分量中各选取一条链路来生成一个特定的极大匹配 $M$。\n\n对于这个特定的图和选定的极大匹配，由所述算法产生的监控集中的服务器总数是多少？", "solution": "该算法从一个极大匹配的端点构建其监控集。如果 $M$ 是所选的极大匹配，那么监控集为\n$$\nC=\\bigcup_{(u,v)\\in M}\\{u,v\\},\n$$\n所以其基数满足\n$$\n|C|=\\sum_{(u,v)\\in M}2=2|M|.\n$$\n图 $G$ 是 $k=50$ 个星形图 $K_{1,n}$（其中 $n=10$）的不交并。在一个星形图 $K_{1,n}$ 中，每条边都与唯一的中心顶点邻接，所以一个匹配最多只能包含一条边；因此，在每个星形图中选取一条边所产生的匹配在每个分量中恰好包含一条边，并且是极大的。因此，根据指定的构造方法——从 50 个分量中各选取一条边——我们有\n$$\n|M|=k=50.\n$$\n应用监控集大小和匹配大小之间的关系可得\n$$\n|C|=2|M|=2k=2\\cdot 50=100.\n$$\n因此，该算法产生的监控集包含 100 个服务器。", "answer": "$$\\boxed{100}$$", "id": "1412471"}]}