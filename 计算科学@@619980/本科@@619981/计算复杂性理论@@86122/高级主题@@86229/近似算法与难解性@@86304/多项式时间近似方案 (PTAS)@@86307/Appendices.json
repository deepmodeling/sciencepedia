{"hands_on_practices": [{"introduction": "要掌握多项式时间近似方案（PTAS），首先必须清晰地理解其核心定义及其与全多项式时间近似方案（FPTAS）的区别。这个练习为你提供了直接应用这些定义的机会 [@problem_id:1435966]。通过分析几种假设算法的时间复杂度函数，你将学会如何根据运行时间对输入规模 $n$ 和近似误差 $\\epsilon$ 的依赖关系，来准确地对算法进行分类。这项基本技能是评估任何近似方案理论效率和实用性的第一步。", "problem": "一家名为 `ConnectSphere` 的科技公司正在研究一个与其分布式计算平台上的资源分配相关的、出了名的困难优化问题。该问题已知是 NP-难的。为了找到可行的解，该公司的算法部门开发了四种不同的近似算法。每种算法都接受一个大小为 $n$ 的问题实例和一个误差容限参数 $\\epsilon > 0$，并生成一个保证在最优解的 $(1+\\epsilon)$ 因子范围内的解。\n\n公司需要评估这些算法中哪些可以被归类为多项式时间近似方案 (PTAS) 或完全多项式时间近似方案 (FPTAS)。定义如下：\n\n- **多项式时间近似方案 (PTAS)** 是一种近似算法，对于每个固定的 $\\epsilon > 0$ 值，其运行时间在输入大小 $n$ 上是多项式的。多项式的指数可以依赖于 $\\epsilon$。例如，运行时间为 $O(n^{1/\\epsilon})$ 的算法是一个 PTAS。\n- **完全多项式时间近似方案 (FPTAS)** 是一个 PTAS，其运行时间在 $1/\\epsilon$ 上也是多项式的。例如，运行时间为 $O((1/\\epsilon)^{2} \\cdot n^{3})$ 的算法是一个 FPTAS。\n\n这四种提出的算法的时间复杂度为：\n- **算法 1:** $T_1(n, \\epsilon) = O(n^4 + (1/\\epsilon)^3)$\n- **算法 2:** $T_2(n, \\epsilon) = O(n \\cdot 3^{1/\\epsilon})$\n- **算法 3:** $T_3(n, \\epsilon) = O(n^{2 + 1/\\epsilon})$\n- **算法 4:** $T_4(n, \\epsilon) = O(\\frac{1}{\\epsilon^2} \\cdot n^2 \\log n)$\n\n下列哪种算法符合完全多项式时间近似方案 (FPTAS) 的条件？\n\nA. 仅算法2\nB. 仅算法1和算法4\nC. 仅算法2和算法3\nD. 仅算法3\nE. 所有四种算法都是 FPTAS。", "solution": "我们使用以下定义：\n- 如果对于每个固定的 $\\epsilon>0$，一个算法的运行时间在 $n$ 上是多项式的，那么它就是一个 PTAS。\n- 如果一个算法是 PTAS，并且其运行时间在 $n$ 和 $1/\\epsilon$ 上都是多项式的，那么它就是一个 FPTAS。形式上，应存在常数 $a,b \\geq 0$ 和一个常数 $C>0$，使得 $T(n,\\epsilon) \\leq C \\cdot n^{a} \\cdot (1/\\epsilon)^{b}$（不计 $n$ 的多对数因子）。\n\n我们逐一检查每个算法：\n\n算法1：$T_{1}(n,\\epsilon) = O\\!\\left(n^{4} + (1/\\epsilon)^{3}\\right)$。这是一个关于 $n$ 的多项式和一个关于 $1/\\epsilon$ 的多项式之和。因此 $T_{1}(n,\\epsilon)$ 在 $n$ 和 $1/\\epsilon$ 上都是多项式的，所以算法1是一个 FPTAS。\n\n算法2：$T_{2}(n,\\epsilon) = O\\!\\left(n \\cdot 3^{1/\\epsilon}\\right) = O\\!\\left(n \\cdot \\exp\\!\\left((\\ln 3)/\\epsilon\\right)\\right)$。因子 $3^{1/\\epsilon}$ 在 $1/\\epsilon$ 上是指数级的，并且不被任何关于 $1/\\epsilon$ 的多项式所界定。因此，它在 $1/\\epsilon$ 上不是多项式的，所以算法2不是一个 FPTAS（尽管它是一个 PTAS，因为对于固定的 $\\epsilon$，因子 $3^{1/\\epsilon}$ 是一个常数）。\n\n算法3：$T_{3}(n,\\epsilon) = O\\!\\left(n^{2+1/\\epsilon}\\right) = O\\!\\left(n^{2} \\cdot n^{1/\\epsilon}\\right) = O\\!\\left(n^{2} \\cdot \\exp\\!\\left((\\ln n)/\\epsilon\\right)\\right)$。这里 $n$ 的指数依赖于 $1/\\epsilon$。如果对于某个固定的 $a,b$，FPTAS 的界 $T(n,\\epsilon) \\leq C \\cdot n^{a} \\cdot (1/\\epsilon)^{b}$ 成立，那么对于足够小的 $\\epsilon$，我们将有 $1/\\epsilon > a$，并且当 $n \\to \\infty$ 时，项 $n^{1/\\epsilon}$ 将主导任何固定的幂 $n^{a}$，这与该界相矛盾。因此，算法3不是 FPTAS（尽管它是一个 PTAS，因为对于固定的 $\\epsilon$，运行时间在 $n$ 上是多项式的）。\n\n算法4：$T_{4}(n,\\epsilon) = O\\!\\left((1/\\epsilon)^{2} \\cdot n^{2} \\ln n\\right)$。这在 $1/\\epsilon$ 上是多项式的，在 $n$ 上也是多项式的（因为对于足够大的 $n$，$n^{2} \\ln n \\leq n^{3}$，所以它被一个多项式上界）。因此，算法4是一个 FPTAS。\n\n综合以上分析，恰好算法1和算法4是 FPTAS。", "answer": "$$\\boxed{B}$$", "id": "1435966"}, {"introduction": "一个算法被归类为 PTAS 确保了理论上我们可以获得任意精度的近似解，但这并不意味着它在实践中总是可行的。这个练习通过一个生动的思想实验，揭示了近似精度与计算成本之间的严峻权衡 [@problem_id:1435944]。你将为一个运行时间为 $O(n^{1/\\epsilon})$ 的 PTAS 计算在温和的精度要求下所需的实际运算量，其结果将直观地展示为什么这类算法的实用性可能极其有限，从而突显出 FPTAS 在效率上的巨大优势。", "problem": "一家专注于物流的科技初创公司正在开发一种算法，以优化其自动驾驶无人机机队的配送路线。该问题是一个最小化问题，旨在找到访问 $n$ 个地点的集合的最短可能路径。他们正在使用一类被称为多项式时间近似方案 (PTAS) 的算法。对于任何给定的误差容限 $\\epsilon > 0$，PTAS 保证得出的解的总长度不超过绝对最优解长度的 $(1+\\epsilon)$ 倍。\n\n该公司使用的特定 PTAS 实现具有已知的时间复杂度，以基本计算操作的数量来衡量，由函数 $T(n, \\epsilon) = c \\cdot n^{1/\\epsilon}$ 给出，其中 $n$ 是配送地点的数量，常数 $c = 10^5$。\n\n管理层规定，对于一个拥有 $n=60$ 个配送点的中等规模城市的新服务，计算出的无人机路线必须保证比数学上的最优路线长不超过 $2\\%$。计算该算法为满足此保证而进行单次路线计算所需的总基本操作数。将您的答案以科学记数法表示，并四舍五入到三位有效数字。", "solution": "问题要求计算一个特定的近似算法为找到一条无人机路线所需的基本操作数。该算法的性能由其时间复杂度函数和近似质量来描述。\n\n首先，让我们确定问题陈述中给出的参数。\n配送地点的数量是 $n=60$。\n时间复杂度函数中的常数是 $c=10^5$。\n时间复杂度函数是 $T(n, \\epsilon) = c \\cdot n^{1/\\epsilon}$。\n\n管理层的要求是，算法生成的路线长度不得超过最优路线的 $2\\%$。对于一个最小化问题，多项式时间近似方案 (PTAS) 产生一个值为 $S$ 的解，使得 $S \\le (1+\\epsilon) \\cdot OPT$，其中 $OPT$ 是最优解的值。\n\n一个比最优解长 $2\\%$ 的解可以表示为 $OPT + 0.02 \\cdot OPT = 1.02 \\cdot OPT$。\n因此，我们可以将近似保证因子 $(1+\\epsilon)$ 设置为 $1.02$。\n$$1 + \\epsilon = 1.02$$\n求解误差容限 $\\epsilon$，我们得到：\n$$\\epsilon = 1.02 - 1 = 0.02$$\n\n现在我们拥有了使用给定的时间复杂度函数 $T(n, \\epsilon)$ 来计算基本操作数所需的所有值。\n我们将 $n=60$，$c=10^5$ 和 $\\epsilon=0.02$ 代入公式 $T(n, \\epsilon) = c \\cdot n^{1/\\epsilon}$。\n\n首先，我们计算指数 $1/\\epsilon$：\n$$\\frac{1}{\\epsilon} = \\frac{1}{0.02} = 50$$\n\n现在，将这个指数和其他值代入函数 $T$：\n$$T(60, 0.02) = 10^5 \\cdot 60^{50}$$\n\n这是一个非常大的数，所以我们必须使用对数来处理它并将其表示为科学记数法。我们想找到一个值 $T$ 使得 $T = A \\times 10^k$，其中 $1 \\le A  10$。\n让我们对表达式取以10为底的对数：\n$$\\log_{10}(T) = \\log_{10}(10^5 \\cdot 60^{50})$$\n使用对数性质 $\\log(ab) = \\log(a) + \\log(b)$：\n$$\\log_{10}(T) = \\log_{10}(10^5) + \\log_{10}(60^{50})$$\n使用对数性质 $\\log(x^y) = y\\log(x)$ 和 $\\log_{10}(10^z) = z$：\n$$\\log_{10}(T) = 5 + 50 \\cdot \\log_{10}(60)$$\n我们可以近似计算 $\\log_{10}(60)$：\n$$\\log_{10}(60) = \\log_{10}(6 \\times 10) = \\log_{10}(6) + \\log_{10}(10) = \\log_{10}(2 \\times 3) + 1 = \\log_{10}(2) + \\log_{10}(3) + 1$$\n使用 $\\log_{10}(2) \\approx 0.30103$ 和 $\\log_{10}(3) \\approx 0.47712$ 的标准近似值：\n$$\\log_{10}(60) \\approx 0.30103 + 0.47712 + 1 = 1.77815$$\n现在我们将这个值代回到 $\\log_{10}(T)$ 的表达式中：\n$$\\log_{10}(T) = 5 + 50 \\cdot (1.77815)$$\n$$\\log_{10}(T) = 5 + 88.9075$$\n$$\\log_{10}(T) = 93.9075$$\n这意味着 $T = 10^{93.9075}$。为了将其写成科学记数法，我们将指数的整数部分和小数部分分开：\n$$T = 10^{0.9075} \\times 10^{93}$$\n现在我们计算尾数的值，$10^{0.9075}$：\n$$10^{0.9075} \\approx 8.0814$$\n所以，总操作数大约是：\n$$T \\approx 8.0814 \\times 10^{93}$$\n问题要求答案四舍五入到三位有效数字。\n$$T \\approx 8.08 \\times 10^{93}$$\n这个天文数字般的数值说明了即使对于中等规模的输入和看似宽松的精度要求，使用此类 PTAS 在实践中也面临挑战。尽管对于固定的 $\\epsilon$，该算法是“多项式时间”的，但多项式的次数 $1/\\epsilon$ 使其在计算上是不可行的。", "answer": "$$\\boxed{8.08 \\times 10^{93}}$$", "id": "1435944"}, {"introduction": "这个综合性练习将引导你从分析转向设计，挑战你为路径图上的最大权独立集问题从头开始构建一个完整的 FPTAS [@problem_id:1425213]。你将应用一种强大的核心技术——值缩放与舍入（value scaling and rounding）。具体来说，你需要设计一个缩放函数来转换顶点权重，然后为缩放后的问题构建一个精确的动态规划解法，并最终证明你的整个方案满足了 FPTAS 的近似保证和时间复杂度要求。这个过程封装了许多 FPTAS 设计的经典范式。", "problem": "路径图 $P_n$ 定义在一个包含 $n$ 个顶点的集合 $V = \\{v_1, v_2, \\ldots, v_n\\}$ 上，其边集为 $E = \\{(v_i, v_{i+1}) \\mid 1 \\le i  n\\}$。每个顶点 $v_i$ 都被赋予一个正整数权重 $w_i > 0$。\n\n*独立集*是顶点集 $V$ 的一个子集 $I \\subseteq V$，其中 $I$ 中的任意两个顶点都不相邻。一个独立集 $I$ 的权重是其顶点的权重之和，即 $W(I) = \\sum_{v_i \\in I} w_i$。*最大权独立集 (MWIS)* 问题旨在找到一个具有最大可能权重的独立集，该权重记为 $W^*$。\n\n如果一个用于最大化问题的算法，对于任意给定的误差参数 $\\epsilon  0$，都能产生一个权重为 $W_{sol}$ 的解，满足 $W_{sol} \\ge (1-\\epsilon)W^*$，并且其运行时间在输入规模和 $1/\\epsilon$ 上都是多项式的，那么该算法就是一个*全多项式时间近似方案 (FPTAS)*。\n\n考虑一个用于路径图上 MWIS 问题的算法策略，该策略按如下步骤进行：\n1. 通过一个缩放和取整的过程，将所有原始顶点权重 $w_i$ 转换为新的整数权重 $w'_i$。\n2. 然后，使用一个精确算法来求解具有新权重 $w'_i$ 的问题实例的最大权独立集。\n3. 将步骤2中找到的独立集作为原始问题的近似解返回。\n\n你的任务是完整地详述此策略，以创建一个有效的 FPTAS。这包括定义缩放变换，并为缩放后的问题选择一个合适的精确算法。根据你的设计，确定函数 $f(n, \\epsilon)$，使得你的 FPTAS 的总运行时间为 $O(f(n, \\epsilon))$。假设 $n \\ge 2$ 且 $0  \\epsilon \\le 1$。", "solution": "设 $P_{n}$ 是一个路径图，其顶点为 $v_{1},\\ldots,v_{n}$，对应正整数权重为 $w_{1},\\ldots,w_{n}$。设 $W^{*}$ 是最优 MWIS 权重。为构建一个遵循前述策略的 FPTAS，我们按如下步骤进行。\n\n缩放和取整。令 $W_{\\max}=\\max_{1\\le i\\le n}w_{i}$。对于给定的 $\\epsilon\\in(0,1]$，定义缩放因子\n$$\nK=\\frac{\\epsilon W_{\\max}}{n}.\n$$\n定义缩放后的整数权重为\n$$\nw'_{i}=\\left\\lfloor \\frac{w_{i}}{K}\\right\\rfloor \\quad \\text{for } i=1,\\ldots,n.\n$$\n根据构造，对于每个 $i$，\n$$\nK\\,w'_{i}\\le w_{i}K\\,(w'_{i}+1).\n$$\n\n针对缩放后实例的精确算法。使用一个基于缩放后权重和的动态规划。令 $S=\\sum_{i=1}^{n}w'_{i}$。为 $i\\in\\{0,1,\\ldots,n\\}$ 和 $s\\in\\{0,1,\\ldots,S\\}$ 定义一个布尔表 $C[i,s]$，其含义为：$C[i,s]$ 为真当且仅当在 $\\{v_{1},\\ldots,v_{i}\\}$ 中存在一个独立集，其缩放后的总权重等于 $s$。初始化\n$$\nC[0,0]=\\text{true},\\quad C[0,s]=\\text{false}\\ \\text{for }s0.\n$$\n对于 $i=1$，\n$$\nC[1,s]=\\big(C[0,s]\\big)\\ \\lor\\ \\big(s=w'_{1}\\big).\n$$\n对于 $i\\ge 2$，使用递推关系\n$$\nC[i,s]=C[i-1,s]\\ \\lor\\ \\big(s\\ge w'_{i}\\ \\land\\ C[i-2,\\,s-w'_{i}]\\big).\n$$\n填充该表后，令\n$$\ns^{*}=\\max\\{\\,s\\in\\{0,\\ldots,S\\}\\mid C[n,s]=\\text{true}\\,\\}.\n$$\n通过使用递推决策的标准回溯法，恢复一个达到 $s^{*}$ 的独立集 $I'$。这个 $I'$ 是具有权重 $w'_{i}$ 的缩放后实例的精确最优 MWIS。\n\n近似保证。令 $I^{*}$ 为原始实例的最优 MWIS，其权重为 $W^{*}=\\sum_{i\\in I^{*}}w_{i}$。根据 $w'_{i}\\ge \\frac{w_{i}}{K}-1$，对 $I^{*}$ 中的所有 $i$ 求和得到\n$$\n\\sum_{i\\in I^{*}}w'_{i}\\ge \\frac{1}{K}\\sum_{i\\in I^{*}}w_{i}-|I^{*}|=\\frac{W^{*}}{K}-|I^{*}|.\n$$\n由于 $I'$ 最大化了缩放后的权重和，我们有 $\\sum_{i\\in I'}w'_{i}\\ge \\sum_{i\\in I^{*}}w'_{i}\\ge \\frac{W^{*}}{K}-|I^{*}|$。对每个 $i$ 使用 $w_{i}\\ge K\\,w'_{i}$，得到\n$$\nW(I')=\\sum_{i\\in I'}w_{i}\\ge K\\sum_{i\\in I'}w'_{i}\\ge K\\left(\\frac{W^{*}}{K}-|I^{*}|\\right)=W^{*}-K\\,|I^{*}|.\n$$\n因为 $|I^{*}|\\le n$ 且 $K=\\frac{\\epsilon W_{\\max}}{n}$，并且 $W^{*}\\ge W_{\\max}$，可得\n$$\nK\\,|I^{*}|\\le n\\cdot\\frac{\\epsilon W_{\\max}}{n}=\\epsilon W_{\\max}\\le \\epsilon W^{*},\n$$\n因此\n$$\nW(I')\\ge W^{*}-\\epsilon W^{*}=(1-\\epsilon)W^{*}.\n$$\n因此，该算法达到了所要求的近似比。\n\n运行时间。计算 $W_{\\max}$ 和所有 $w'_{i}$ 需要 $O(n)$ 时间。动态规划表的大小为 $O(nS)$，填充时间为 $O(nS)$。$S$ 的上界为\n$$\nS=\\sum_{i=1}^{n}w'_{i}\\le \\sum_{i=1}^{n}\\frac{w_{i}}{K}=\\frac{1}{K}\\sum_{i=1}^{n}w_{i}\\le \\frac{nW_{\\max}}{K}=\\frac{nW_{\\max}}{\\epsilon W_{\\max}/n}=\\frac{n^{2}}{\\epsilon}.\n$$\n因此，总运行时间为 $O\\!\\left(nS\\right)=O\\!\\left(\\frac{n^{3}}{\\epsilon}\\right)$，这在 $n$ 和 $\\frac{1}{\\epsilon}$ 上都是多项式的。因此，一个可接受的选择是 $f(n,\\epsilon)=\\frac{n^{3}}{\\epsilon}$。", "answer": "$$\\boxed{\\frac{n^{3}}{\\epsilon}}$$", "id": "1425213"}]}