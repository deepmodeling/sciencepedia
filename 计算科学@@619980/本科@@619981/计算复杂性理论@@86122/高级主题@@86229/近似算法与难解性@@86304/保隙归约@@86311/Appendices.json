{"hands_on_practices": [{"introduction": "本节的实践练习旨在让你亲手构建和分析保隙归约，这是证明近似难度理论的基石。我们将从最直接的归约形式入手，此练习将展示两个表面上不同的问题——任务调度和物品装箱——如何在数学结构上是等价的 [@problem_id:1425491]。通过将一个问题的实例直接映射为另一个问题，你将学会如何利用一个已有的求解器来解决一个新问题，并准确判断其近似性能保证。", "problem": "您是一家云计算公司的软件工程师。您的团队的任务是开发一项服务，用于在一个由相同服务器组成的集群上调度客户的作业。形式上，这是一个在并行机器上调度作业以最小化完工时间的经典问题。\n\n您正在研究该问题的一个基于承诺的决策版本，我们称之为 `Gap-Makespan`。一个 `Gap-Makespan` 实例由一组 $n$ 个处理时间已知的作业 $\\{p_1, p_2, \\dots, p_n\\}$、$m$ 台相同的服务器和一个目标截止时间 $T$ 定义。问题实例保证满足以下两个条件之一：\n1.  （是-实例）最优完工时间小于或等于截止时间 $T$。即，$C_{\\max}^{*} \\le T$。\n2.  （否-实例）最优完工时间严格大于 $T \\cdot g_{MS}$，其中 $g_{MS} > 1$ 是一个性能差距参数。即，$C_{\\max}^{*} > T \\cdot g_{MS}$。\n\n您的任务是构建一个能够区分这两种情况的求解器。\n\n幸运的是，您的公司可以使用一个名为 `CapacityOptimizer` 的专有软件库。该库解决一个带间隙的装箱问题版本，我们称之为 `Gap-Capacity`。一个 `Gap-Capacity` 实例由一组 $n$ 个大小为 $\\{s_1, s_2, \\dots, s_n\\}$ 的物品、固定数量的 $k$ 个箱子以及一个目标箱子容量 $C$ 定义。`CapacityOptimizer` 库保证能正确区分以下两种情况：\n1.  （是-实例）将所有物品装入 $k$ 个箱子所需的最小箱子容量小于或等于目标容量 $C$。\n2.  （否-实例）将所有物品装入 $k$ 个箱子所需的最小箱子容量严格大于 $C \\cdot g_{CO}$，其中 $g_{CO} > 1$ 是该库内置的性能差距。\n\n对于任何不满足这两个承诺之一的输入，该库的输出是未定义的。\n\n请描述一个通过调用 `CapacityOptimizer` 库来解决 `Gap-Makespan` 问题实例的过程。根据您的过程，如果 `CapacityOptimizer` 库保证的性能差距为 $g_{CO}$，那么您的新调度服务可以保证的相应性能差距 $g_{MS}$ 是多少？请用一个关于 $g_{CO}$ 的符号表达式来表示您的答案。", "solution": "给定一个 Gap-Makespan 实例，其作业处理时间为 $\\{p_{1},\\dots,p_{n}\\}$，$m$ 台相同机器，和一个目标截止时间 $T$。设最优完工时间为 $C_{\\max}^{*}$，定义为\n$$\nC_{\\max}^{*}=\\min_{\\{M_{1},\\dots,M_{m}\\}}\\max_{j\\in\\{1,\\dots,m\\}}\\sum_{i\\in M_{j}}p_{i},\n$$\n其中 $\\{M_{1},\\dots,M_{m}\\}$ 是将作业划分成并分配给这些机器的 $m$ 个不相交的集合。\n\n按如下方式构建一个 Gap-Capacity 实例：\n- 物品：大小为 $s_{i}=p_{i}$，其中 $i\\in\\{1,\\dots,n\\}$。\n- 箱子数量：$k=m$。\n- 目标容量：$C=T$。\n\n对于容量 $C$ 的装箱可行性等价于存在一个完工时间至多为 $C$ 的调度，因为将物品装入容量为 $C$ 的 $m$ 个箱子中意味着存在一个划分 $\\{M_{1},\\dots,M_{m}\\}$，使得对于所有的 $j$，都有 $\\sum_{i\\in M_{j}}p_{i}\\leq C$，这恰好是一个完工时间至多为 $C$ 的调度。因此，将物品装入 $k=m$ 个箱子所需的最小箱子容量等于最优完工时间：\n$$\nC_{\\text{pack}}^{*}=C_{\\max}^{*}.\n$$\n\n现在，对构建的、容量为 $C=T$ 的 Gap-Capacity 实例调用 CapacityOptimizer。根据该库的保证，它会区分：\n- 是：$C_{\\text{pack}}^{*}\\leq T$，\n- 否：$C_{\\text{pack}}^{*}>T\\cdot g_{CO}$。\n\n使用 $C_{\\text{pack}}^{*}=C_{\\max}^{*}$，上述条件变为：\n- 是：$C_{\\max}^{*}\\leq T$，\n- 否：$C_{\\max}^{*}>T\\cdot g_{CO}$。\n\n因此，过程如下：\n- 如果 CapacityOptimizer 返回“是”，则为 Gap-Makespan 输出“是”。\n- 如果 CapacityOptimizer 返回“否”，则为 Gap-Makespan 输出“否”。\n\n因为 Gap-Makespan 实例被承诺满足 $C_{\\max}^{*}\\leq T$ 或 $C_{\\max}^{*}>T\\cdot g_{MS}$ 这两种情况之一，并且当 $g_{MS}=g_{CO}$ 时，构建的 Gap-Capacity 实例满足相应的承诺，所以该求解器能正确地区分这两种被承诺的情况。因此，Gap-Makespan 可实现的性能差距等于该库的差距：\n$$\ng_{MS}=g_{CO}.\n$$", "answer": "$$\\boxed{g_{CO}}$$", "id": "1425491"}, {"introduction": "在了解了问题的直接等价性后，我们来探讨一种更通用的归约技巧：通过系统地构造一个更大、更结构化的实例来进行归约。在这个练习中，你将通过复制集合覆盖问题中的所有元素和集合，来分析这种“加倍”操作如何线性地影响最优解 $\\mathrm{OPT}(I)$ 的大小 [@problem_id:1425437]。这项实践将揭示归约如何改变解的规模，同时保持近似间隙的比率不变，这对于理解更复杂的归约构造至关重要。", "problem": "在计算复杂性理论中，我们经常通过承诺问题的视角来研究优化问题，以分析其近似难度。\n\n考虑最小集合覆盖问题。一个实例是一个序对 $I = (U, S)$，其中 $U$ 是一个有限的元素全集，$S$ 是 $U$ 的一些子集构成的集合。目标是找到一个规模尽可能小的子集族 $S' \\subseteq S$，使得 $S'$ 中集合的并集能够覆盖整个全集 $U$。我们将这个最小子集族的规模，即最优解的大小，记为 $\\mathrm{OPT}(I)$。\n\n让我们定义一个归约 $f$，它接收一个集合覆盖实例 $I=(U, S)$ 并生成一个新实例 $I' = f(I) = (U', S')$。新实例的构造如下：\n1. 对于 $U$ 中的每个元素 $u \\in U$，我们创建两个新的、不同的元素 $u_A$ 和 $u_B$。新的全集 $U'$ 是所有这些新创建的元素的集合：$U' = \\{u_A \\mid u \\in U\\} \\cup \\{u_B \\mid u \\in U\\}$。\n2. 对于 $S$ 中的每个集合 $S_j \\in S$，我们创建两个新的集合 $S_{j,A}$ 和 $S_{j,B}$。集合 $S_{j,A}$ 定义为 $\\{u_A \\mid u \\in S_j\\}$，集合 $S_{j,B}$ 定义为 $\\{u_B \\mid u \\in S_j\\}$。新的集合族 $S'$ 由所有这些新创建的集合组成：$S' = \\{S_{j,A} \\mid S_j \\in S\\} \\cup \\{S_{j,B} \\mid S_j \\in S\\}$。\n\n现在，考虑集合覆盖问题的承诺问题变体，记作 Gap-SetCover$_{c}$。对于一个实例 $I$ 和一个整数 $k$，我们得到一个承诺，即要么 $\\mathrm{OPT}(I) \\leq k$，要么 $\\mathrm{OPT}(I) > c \\cdot k$，其中 $c > 1$ 是一个常数。一个间隙保持归约将实例 $I$ 映射到实例 $I'$，使得如果 $\\mathrm{OPT}(I) \\leq k$，则 $\\mathrm{OPT}(I') \\leq \\alpha \\cdot k$；如果 $\\mathrm{OPT}(I) > c \\cdot k$，则 $\\mathrm{OPT}(I') > \\beta \\cdot c \\cdot k$，其中 $\\alpha$ 和 $\\beta$ 是某个常数。如果 $\\beta > \\alpha$，则称该间隙被放大。如果 $\\beta = \\alpha$，则该间隙被保持。\n\n下列哪个陈述正确地描述了 $\\mathrm{OPT}(I')$ 和 $\\mathrm{OPT}(I)$ 之间的关系以及相应的间隙归约参数 $\\alpha$ 和 $\\beta$？\n\nA. $\\mathrm{OPT}(I') = \\mathrm{OPT}(I)$，其中 $\\alpha=1, \\beta=1$。该归约是间隙保持的。\n\nB. $\\mathrm{OPT}(I') = 2 \\cdot \\mathrm{OPT}(I)$，其中 $\\alpha=2, \\beta=2$。该归约是间隙保持的。\n\nC. $\\mathrm{OPT}(I') = 2 \\cdot \\mathrm{OPT}(I)$，其中 $\\alpha=2, \\beta=1$。该归约是间隙缩小的。\n\nD. $\\mathrm{OPT}(I') = (\\mathrm{OPT}(I))^2$。间隙转换参数 $\\alpha, \\beta$ 不能表示为与 $k$ 无关的常数。\n\nE. 关系是 $\\mathrm{OPT}(I') < 2 \\cdot \\mathrm{OPT}(I)$，因为 $I'$ 的一个最优解可能会巧妙地混合来自 'A' 组和 'B' 组的集合。", "solution": "该问题要求我们找出集合覆盖实例 $I$ 的最优解大小与通过复制所有元素和集合构造的新实例 $I'$ 的最优解大小之间的关系。然后，我们利用这种关系来分析该归约对问题近似间隙的影响。\n\n设 $I=(U, S)$ 是原始实例，$I'=(U', S')$ 是由归约 $f$ 创建的新实例。设 $\\mathrm{OPT}(I)$ 和 $\\mathrm{OPT}(I')$ 分别是 $I$ 和 $I'$ 的最小集合覆盖的大小。\n\n首先，我们将建立 $\\mathrm{OPT}(I')$ 和 $\\mathrm{OPT}(I)$ 之间的关系。我们将分两部分来完成：首先证明 $\\mathrm{OPT}(I') \\leq 2 \\cdot \\mathrm{OPT}(I)$，然后证明 $\\mathrm{OPT}(I') \\geq 2 \\cdot \\mathrm{OPT}(I)$。\n\n第 1 部分：证明 $\\mathrm{OPT}(I') \\leq 2 \\cdot \\mathrm{OPT}(I)$。\n设 $C_{opt} = \\{S_{i_1}, S_{i_2}, \\dots, S_{i_k}\\}$ 是实例 $I$ 的一个最优集合覆盖。根据定义，有 $|C_{opt}| = k = \\mathrm{OPT}(I)$，并且 $\\bigcup_{j=1}^{k} S_{i_j} = U$。\n我们可以基于 $C_{opt}$ 为 $I'$ 构造一个集合覆盖。考虑集合族 $C' \\subseteq S'$，其定义如下：\n$C' = \\{S_{i_1, A}, S_{i_2, A}, \\dots, S_{i_k, A}\\} \\cup \\{S_{i_1, B}, S_{i_2, B}, \\dots, S_{i_k, B}\\}$。\n这个集合族的规模是 $|C'| = k + k = 2k = 2 \\cdot \\mathrm{OPT}(I)$。\n现在我们必须检查 $C'$ 是否是 $U'$ 的一个有效覆盖。$C'$ 中集合的并集是：\n$$ \\bigcup_{S'' \\in C'} S'' = \\left( \\bigcup_{j=1}^{k} S_{i_j, A} \\right) \\cup \\left( \\bigcup_{j=1}^{k} S_{i_j, B} \\right) $$\n根据 $S_{j,A}$ 的构造，第一个并集覆盖了 $U_A$ 中的所有元素：\n$$ \\bigcup_{j=1}^{k} S_{i_j, A} = \\{u_A \\mid u \\in \\bigcup_{j=1}^{k} S_{i_j}\\} = \\{u_A \\mid u \\in U\\} = U_A $$\n类似地，第二个并集覆盖了 $U_B$ 中的所有元素：\n$$ \\bigcup_{j=1}^{k} S_{i_j, B} = \\{u_B \\mid u \\in \\bigcup_{j=1}^{k} S_{i_j}\\} = \\{u_B \\mid u \\in U\\} = U_B $$\n因此，$C'$ 中所有集合的并集是 $U_A \\cup U_B = U'$。这意味着 $C'$ 是 $I'$ 的一个有效集合覆盖。由于 $\\mathrm{OPT}(I')$ 是*最小*集合覆盖的大小，我们必然有 $\\mathrm{OPT}(I') \\leq |C'|$。\n因此，我们证明了 $\\mathrm{OPT}(I') \\leq 2 \\cdot \\mathrm{OPT}(I)$。\n\n第 2 部分：证明 $\\mathrm{OPT}(I') \\geq 2 \\cdot \\mathrm{OPT}(I)$。\n设 $C'_{opt}$ 是 $I'$ 的一个最优集合覆盖。因此 $|C'_{opt}| = \\mathrm{OPT}(I')$。\n全集 $U'$ 被划分为两个不相交的集合 $U_A$ 和 $U_B$。$S'$ 中形如 $S_{j,A}$ 的集合只包含来自 $U_A$ 的元素，而形如 $S_{j,B}$ 的集合只包含来自 $U_B$ 的元素。这意味着覆盖 $U'$ 的问题可以完美地分解为两个独立的子问题：一个是用来自 $S_A = \\{S_{j,A}\\}_{S_j \\in S}$ 的集合来覆盖 $U_A$，另一个是用来自 $S_B = \\{S_{j,B}\\}_{S_j \\in S}$ 的集合来覆盖 $U_B$。\n设 $C'_A = C'_{opt} \\cap S_A$ 和 $C'_B = C'_{opt} \\cap S_B$。由于 $S_A$ 和 $S_B$ 不相交，所以 $|C'_{opt}| = |C'_A| + |C'_B|$。\n$C'_A$ 中的集合必须覆盖整个 $U_A$。设 $C_A \\subseteq S$ 是与 $C'_A$ 中集合相对应的原始集合族。使用 $S_A$ 中的集合寻找 $U_A$ 的最小覆盖问题，在结构上与使用 $S$ 中的集合寻找 $U$ 的最小覆盖问题是相同的。因此，从 $S_A$ 中选取集合来覆盖 $U_A$ 的最小集合族的规模恰好是 $\\mathrm{OPT}(I)$。这意味着 $|C'_A| \\geq \\mathrm{OPT}(I)$。\n根据对称性论证，$C'_B$ 中的集合必须覆盖整个 $U_B$，而这样的最小集合族的规模也必须是 $\\mathrm{OPT}(I)$。这意味着 $|C'_B| \\geq \\mathrm{OPT}(I)$。\n结合这些结果，我们得到：\n$$ \\mathrm{OPT}(I') = |C'_{opt}| = |C'_A| + |C'_B| \\geq \\mathrm{OPT}(I) + \\mathrm{OPT}(I) = 2 \\cdot \\mathrm{OPT}(I) $$\n所以我们证明了 $\\mathrm{OPT}(I') \\geq 2 \\cdot \\mathrm{OPT}(I)$。\n\n结合第 1 部分和第 2 部分，我们有 $\\mathrm{OPT}(I') \\leq 2 \\cdot \\mathrm{OPT}(I)$ 和 $\\mathrm{OPT}(I') \\geq 2 \\cdot \\mathrm{OPT}(I)$，这意味着我们必然得到等式：\n$$ \\mathrm{OPT}(I') = 2 \\cdot \\mathrm{OPT}(I) $$\n\n现在我们分析间隙变换。我们对 $I$ 有一个承诺：\n- 情况 1 (完备性)：$\\mathrm{OPT}(I) \\leq k$。\n使用我们推导出的关系，这意味着 $\\mathrm{OPT}(I') = 2 \\cdot \\mathrm{OPT}(I) \\leq 2k$。这符合 $\\mathrm{OPT}(I') \\leq \\alpha \\cdot k$ 的形式，其中 $\\alpha = 2$。\n- 情况 2 (可靠性)：$\\mathrm{OPT}(I) > c \\cdot k$。\n这意味着 $\\mathrm{OPT}(I') = 2 \\cdot \\mathrm{OPT}(I) > 2(c \\cdot k) = (2) \\cdot c \\cdot k$。这符合 $\\mathrm{OPT}(I') > \\beta \\cdot c \\cdot k$ 的形式，其中 $\\beta = 2$。\n\n由于 $\\alpha = 2$ 且 $\\beta = 2$，我们有 $\\alpha = \\beta$。这意味着该归约是间隙保持的；它没有放大间隙。\n这对应于选项 B。让我们回顾一下其他选项：\nA. $\\mathrm{OPT}(I')$ 的关系不正确。\nC. $\\beta$ 的值不正确。如果 $\\beta=1, \\alpha=2$，间隙会缩小，所以它是间隙缩小的。\nD. $\\mathrm{OPT}(I')$ 的关系不正确。\nE. 不正确。子问题是完全不相交的，因此组合问题的最优解恰好是子问题最优解之和。\n\n因此，正确的陈述是 B。", "answer": "$$\\boxed{B}$$", "id": "1425437"}, {"introduction": "最后，我们来研究保隙归约中一个更精妙的方面。一个看似简单的图变换——比如为一个图增加一个连接所有原顶点的“万能”顶点——可能会对问题的近似间隙产生非平凡的影响。这个练习将引导你分析这种变换如何作用于顶点覆盖问题，并揭示即使归约“压缩”了原有的近似间隙（即新的间隙因子 $s'$ 小于原间隙因子 $s$），它在特定条件下仍然是有效的 [@problem_id:1425471]。这突显了在证明近似难度时，对归约性质进行精确数学分析的重要性。", "problem": "在计算复杂性理论中，许多优化问题都以其带间隙决策形式进行研究。考虑最小顶点覆盖（VC）问题的带间隙决策版本，记为 `(1, s)`-GAP-VC。无向图的顶点覆盖是顶点的一个子集，使得图中的每条边都至少与该子集中的一个顶点相关联。对于一个由图 $G$ 和整数 $k$ 组成的实例 $(G, k)$，我们有以下承诺：\n- **是实例**：$G$ 的最小顶点覆盖的大小，记为 $\\mathrm{vc}(G)$，满足 $\\mathrm{vc}(G) \\le k$。\n- **否实例**：$G$ 的最小顶点覆盖的大小满足 $\\mathrm{vc}(G) > s \\cdot k$，其中 $s > 1$ 是某个常数间隙因子。\n\n现在，考虑一个特定的图变换 $T$。给定一个有 $n$ 个顶点的无向图 $G=(V, E)$，变换 $T(G)$ 会生成一个新图 $G'=(V', E')$。新图 $G'$ 的构造方法是：向图 $G$ 中添加一个单一的新“通用”顶点（我们称之为 $u$），并将 $u$ 连接到所有原来在 $V$ 中的顶点。形式上，$V' = V \\cup \\{u\\}$ 且 $E' = E \\cup \\{(u,v) \\mid v \\in V\\}$。\n\n我们想知道这个变换是否可以成为一个从实例 $(G, k)$ 上的 `(1, s)`-GAP-VC 到对应实例 $(G', k')$ 上的 `(1, s')`-GAP-VC 的多项式时间保隙归约的一部分。具体来说，考虑将实例 $(G, k)$ 映射到 $(G', k+1)$ 的归约。假设对于任何输入实例 $(G, k)$，我们都有 $k < n-1$。\n\n以下哪个陈述正确地描述了此映射是否构成一个有效的保隙归约？\n\nA. 是的，这是一个保持原始间隙因子的保隙归约，因此 `s' = s`。\n\nB. 不，这不是一个保隙归约。虽然存在某种关系，但新的间隙 `s'` 不能是一个固定的常数；它必须依赖于原始问题实例中的参数 `k`。\n\nC. 不，这不是一个保隙归约，因为分析表明，对于任何 `s > 1`，新的间隙因子 `s'` 都必须小于或等于 1。\n\nD. 是的，这是一个保隙归约，其中新的间隙因子 `s'` 是一个依赖于 `s` 的常数（例如，`s'=(s+1)/2`），并且严格小于 `s`。", "solution": "设 $G=(V,E)$ 且 $|V|=n$，并通过添加一个与每个 $v \\in V$ 相邻的通用顶点 $u$ 来形成 $T(G)=G'=(V',E')$，因此 $V'=V \\cup \\{u\\}$ 且 $E'=E \\cup \\{(u,v): v \\in V\\}$。考虑映射 $(G,k) \\mapsto (G',k+1)$。\n\n首先，计算 $\\mathrm{vc}(G')$（以 $\\mathrm{vc}(G)$ 表示）。$G'$ 的任何顶点覆盖都必须覆盖：\n- 所有原始边 $E$，以及\n- 所有新边 $\\{(u,v): v \\in V\\}$。\n\n如果 $u$ 在覆盖集中，那么所有新边都被 $u$ 覆盖，剩下的任务是覆盖 $E$，这至少需要来自 $V$ 的 $\\mathrm{vc}(G)$ 个顶点。因此存在一个大小为 $1+\\mathrm{vc}(G)$ 的覆盖集，并且在使用 $u$ 的情况下没有更小的覆盖集。\n\n如果 $u$ 不在覆盖集中，那么每条边 $(u,v)$ 都必须通过包含 $v$ 来覆盖，因此 $V$ 中的所有顶点都必须在覆盖集中，从而得到大小为 $n$ 的覆盖集。\n\n因此\n$$\n\\mathrm{vc}(G')=\\min\\{1+\\mathrm{vc}(G),\\,n\\}。\n$$\n对于任何 $n$ 顶点的图，$\\mathrm{vc}(G)=n-\\alpha(G)$，其中 $\\alpha(G)$ 是最大独立集的大小。由于 $\\alpha(G) \\ge 1$，我们有 $\\mathrm{vc}(G) \\le n-1$，因此 $1+\\mathrm{vc}(G) \\le n$。所以，对于所有的 $G$，都有\n$$\n\\mathrm{vc}(G')=1+\\mathrm{vc}(G)\n$$\n\n现在分析在 $(G,k) \\mapsto (G',k+1)$ 下的间隙。\n\n是实例：如果 $\\mathrm{vc}(G) \\le k$，则\n$$\n\\mathrm{vc}(G')=1+\\mathrm{vc}(G) \\le 1+k,\n$$\n因此 $(G',k+1)$ 是一个是实例。\n\n否实例：如果 $\\mathrm{vc}(G) > s \\cdot k$，则\n$$\n\\mathrm{vc}(G')=1+\\mathrm{vc}(G) > s \\cdot k + 1。\n$$\n为确保 $(G',k+1)$ 对于某个常数 $s' > 1$ 是一个否实例，我们需要\n$$\n\\mathrm{vc}(G') > s'(k+1),\n$$\n如果\n$$\ns'(k+1) \\le s \\cdot k + 1 \\quad \\text{对于所有允许的 } k,\n$$\n这一条件就能得到保证。\n\n等价地，\n$$\ns' \\le \\frac{s \\cdot k + 1}{k+1} = s - \\frac{s-1}{k+1}。\n$$\n在 $k \\ge 1$ 的范围内，右侧在 $k=1$ 处取最小值，得到\n$$\n\\min_{k \\ge 1} \\frac{s \\cdot k + 1}{k+1} = \\frac{s+1}{2}。\n$$\n因此选择常数\n$$\ns'=\\frac{s+1}{2}\n$$\n可以确保对于所有 $k \\ge 1$ 都有 $s'(k+1) \\le s \\cdot k + 1$，因此只要 $\\mathrm{vc}(G) > s \\cdot k$，就有 $\\mathrm{vc}(G') > s'(k+1)$。由于 $s>1$，我们有 $1 < s' < s$。\n\n注：如果允许 $k=0$，则 $\\inf_{k \\ge 0} \\frac{s \\cdot k + 1}{k+1} = 1$，所以没有常数 $s' > 1$ 会满足条件。在 $k \\ge 1$ 的通常限制下（或者在经过平凡的预处理以处理 $k=0$ 的情况后），像 $(s+1)/2$ 这样的常数 $s'$ 是可行的。因此，所描述的映射构成了一个有效的多项式时间保隙归约，其常数间隙因子严格更小且仅依赖于 $s$。\n\n因此，正确选项是 D。", "answer": "$$\\boxed{D}$$", "id": "1425471"}]}