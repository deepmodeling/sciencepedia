{"hands_on_practices": [{"introduction": "Shor算法的量子部分本质上是一个高效的“周期查找器”。为了深入理解这个强大的量子子程序的目标，通过一个具体的例子手动计算周期是至关重要的。这个练习将引导你亲手计算一个模指数函数的周期，帮助你直观地感受这个核心概念，而这正是整个Shor算法赖以成功的基础。[@problem_id:1447896]", "problem": "考虑一个函数 $f$，它将非负整数映射到一个有限的整数集合，其定义规则为 $f(x) = a^x \\pmod{N}$，其中 $a$ 和 $N$ 为正整数，且 $a$ 与 $N$ 的最大公约数为 1。这个函数是周期性的。周期，记为 $r$，是满足 $a^r \\equiv 1 \\pmod{N}$ 的最小正整数。\n\n对于底数为 $a=7$、模为 $N=15$ 的特定情况，请通过直接计算来确定函数 $f(x) = 7^x \\pmod{15}$ 的周期 $r$。", "solution": "我们被要求找到 $a=7$ 对模 $N=15$ 的周期（乘法阶）$r$，它被定义为满足 $7^{r} \\equiv 1 \\pmod{15}$ 的最小正整数。由于 $\\gcd(7,15)=1$，$7$ 的幂在模 15 乘法群中是良定义的。根据欧拉定理 (Euler's theorem)，$7^{\\varphi(15)} \\equiv 1 \\pmod{15}$，其中 $\\varphi(15)=\\varphi(3)\\varphi(5)=2 \\cdot 4 = 8$，因此阶 $r$ 必须整除 $8$。我们通过直接计算来找到最小的此种 $r$。\n\n我们使用“若 $x \\equiv y \\pmod{15}$，则 $7x \\equiv 7y \\pmod{15}$”这一性质，来计算 $7$ 对模 $15$ 的连续幂：\n\n$7^{1} \\equiv 7 \\pmod{15}$，不与 $1$ 同余。\n\n$7^{2} \\equiv 7 \\cdot 7 = 49 \\equiv 49 - 45 = 4 \\pmod{15}$，不与 $1$ 同余。\n\n$7^{3} \\equiv 7 \\cdot 7^{2} \\equiv 7 \\cdot 4 = 28 \\equiv 28 - 15 = 13 \\pmod{15}$，不与 $1$ 同余。\n\n$7^{4} \\equiv 7 \\cdot 7^{3} \\equiv 7 \\cdot 13 = 91 \\equiv 91 - 90 = 1 \\pmod{15}$。\n\n因此，满足 $7^{r} \\equiv 1 \\pmod{15}$ 的最小正整数 $r$ 是 $r=4$。这也与阶必须整除 $8$ 的事实相符，并且我们已经验证了，对于更小的正指数 1、2、3，其结果均不与 1 模 15 同余。", "answer": "$$\\boxed{4}$$", "id": "1447896"}, {"introduction": "量子计算机并不会直接输出周期 $r$，而是给出一个与分数 $c/r$ 相关的测量结果。如何从这个近似值中精确地恢复出周期 $r$ 是经典后处理的关键一步，而连分数算法正是完成此任务的强大数学工具。通过这个练习，你将模拟Shor算法中至关重要的一步，亲身体验如何利用一个高效的经典算法从量子计算机的输出中提取出我们需要的核心信息。[@problem_id:1447898]", "problem": "在用于整数分解的Shor算法的经典后处理阶段，从一个$m$量子比特寄存器中获得的测量结果$y$被用来构造分数$\\frac{y}{2^m}$。这个分数是一个未知有理数$\\frac{c}{r}$的近似，其中$r$是某个模幂函数的待求周期，而$c$是与$r$互质的整数。连分数算法通过寻找$\\frac{y}{2^m}$的最佳有理逼近，为恢复周期$r$提供了一种高效的方法。\n\n假设在一次分解大整数的尝试中，Shor算法的量子相位估计子程序用到了一个包含$m=11$个量子比特的辅助寄存器。对该寄存器进行测量，得到的整数值为$y=381$。根据该算法的理论保证，我们知道周期$r$必须小于60。\n\n你的任务是分析这一测量结果。对值$\\frac{y}{2^m}$应用连分数算法，以生成其有理逼近（渐近分数）的序列。从这个序列中，找出“最佳”有理逼近$\\frac{p}{q}$。在本问题中，它被定义为在满足已知约束$q < 60$的条件下，具有最大分母$q$的那个渐近分数。将此分母$q$作为你的最终答案。", "solution": "我们根据给定的数据构造测量得到的有理数。当$m=11$和$y=381$时，我们有\n$$\nx=\\frac{y}{2^{m}}=\\frac{381}{2^{11}}=\\frac{381}{2048}.\n$$\n为求$x$的连分数，我们对数对$(2048,381)$应用欧几里得算法来提取部分商。执行以下除法运算：\n$$\n2048=5\\cdot 381+143,\\quad 381=2\\cdot 143+95,\\quad 143=1\\cdot 95+48,\n$$\n$$\n95=1\\cdot 48+47,\\quad 48=1\\cdot 47+1,\\quad 47=47\\cdot 1+0.\n$$\n因此，$\\frac{2048}{381}$的连分数是$[5;2,1,1,1,47]$，所以$x=\\frac{381}{2048}$的连分数是\n$$\n[0;5,2,1,1,1,47].\n$$\n使用标准递推关系，其中$a_{0}=0$, $a_{1}=5$, $a_{2}=2$, $a_{3}=1$, $a_{4}=1$, $a_{5}=1$, $a_{6}=47$，以及初始条件$p_{-2}=0$, $p_{-1}=1$, $q_{-2}=1$, $q_{-1}=0$，来计算渐近分数$p_{k}/q_{k}$：\n$$\np_{k}=a_{k}p_{k-1}+p_{k-2},\\quad q_{k}=a_{k}q_{k-1}+q_{k-2}.\n$$\n逐步计算如下：\n- $k=0$: $p_{0}=0\\cdot 1+0=0$, $q_{0}=0\\cdot 0+1=1$，所以 $\\frac{p_{0}}{q_{0}}=\\frac{0}{1}$。\n- $k=1$: $p_{1}=5\\cdot 0+1=1$, $q_{1}=5\\cdot 1+0=5$，所以 $\\frac{p_{1}}{q_{1}}=\\frac{1}{5}$。\n- $k=2$: $p_{2}=2\\cdot 1+0=2$, $q_{2}=2\\cdot 5+1=11$，所以 $\\frac{p_{2}}{q_{2}}=\\frac{2}{11}$。\n- $k=3$: $p_{3}=1\\cdot 2+1=3$, $q_{3}=1\\cdot 11+5=16$，所以 $\\frac{p_{3}}{q_{3}}=\\frac{3}{16}$。\n- $k=4$: $p_{4}=1\\cdot 3+2=5$, $q_{4}=1\\cdot 16+11=27$，所以 $\\frac{p_{4}}{q_{4}}=\\frac{5}{27}$。\n- $k=5$: $p_{5}=1\\cdot 5+3=8$, $q_{5}=1\\cdot 27+16=43$，所以 $\\frac{p_{5}}{q_{5}}=\\frac{8}{43}$。\n- $k=6$: $p_{6}=47\\cdot 8+5=381$, $q_{6}=47\\cdot 43+27=2048$，所以 $\\frac{p_{6}}{q_{6}}=\\frac{381}{2048}$。\n\n因此，这些渐近分数的分母分别为$1,5,11,16,27,43,2048$。在约束条件$q<60$下，具有最大分母的渐近分数是$\\frac{8}{43}$，因此所求的分母是$q=43$。", "answer": "$$\\boxed{43}$$", "id": "1447898"}, {"introduction": "成功找到周期 $r$ 并不意味着分解任务一定成功，算法在经典后处理阶段仍可能因为特定情况而失败。Shor算法的成功依赖于一个关键的代数技巧——平方差分解，而这个技巧对周期 $r$ 的奇偶性有严格的要求。分析当周期为奇数时算法为何会失败，将有助于你更深刻地理解该算法背后的数学原理及其内在约束。[@problem_id:1447866]", "problem": "在用于整数分解的 Shor 算法中，一个关键步骤是对量子子程序找到的周期 $r$ 进行经典后处理。我们来考虑一个分解整数 $N=35$ 的尝试。一名学生选择了基数 $a=6$，并正确地使用算法的量子部分来找到函数 $f(x)=6^x \\pmod{35}$ 的周期。找到的周期是 $r=2$。\n\n现在，考虑一个假设的替代情景。假设对于一个不同的整数 $N'$ 和一个不同的基数 $a'$，一名学生运行了量子周期寻找子程序，算法返回了一个奇数周期，例如 $r'=7$。在这种情况下，Shor 算法的标准经典后处理阶段将会失败，学生需要用一个不同的基数重新启动算法。\n\n当周期 $r'$ 为奇数时，以下哪个陈述为 Shor 算法在经典后处理阶段失败提供了最准确和最根本的原因？\n\nA. 只有当选择的基数 $a'$ 与 $N'$ 有公因子时，才会出现奇数周期 $r'$，这意味着最大公约数（GCD）预检查 $\\gcd(a', N') > 1$ 应该已经找到了一个因子。\n\nB. 作为周期寻找子程序核心的量子傅里叶变换，在数学上被限制为只对合数 $N'$ 产生偶数周期。一个奇数结果意味着量子硬件存在故障。\n\nC. 分解步骤依赖于将 $a'^{r'}-1$ 表示为平方差，这只有在指数 $r'/2$ 是整数时才可能实现。\n\nD. 奇数周期 $r'$ 意味着 $a'^{r'/2} \\equiv -1 \\pmod{N'}$，这是算法产生平凡因子的特定失败条件之一。\n\nE. 当周期 $r'$ 为奇数时，元素 $a'$ 在模 $N'$ 整数乘法群中的阶不是 2 的幂，这使得最终的 GCD 计算效率低下。", "solution": "在 Shor 算法中，在选择一个满足 $1<a<N$ 且 $\\gcd(a,N)=1$ 的整数 $a$ 后，量子子程序会找到 $a$ 模 $N$ 的阶（周期）$r$，定义为满足\n$$\na^{r} \\equiv 1 \\pmod{N}.\n$$\n的最小正整数。然后，经典后处理利用代数恒等式\n$$\na^{r} - 1 = \\left(a^{\\frac{r}{2}} - 1\\right)\\left(a^{\\frac{r}{2}} + 1\\right),\n$$\n这要求 $\\frac{r}{2}$ 是一个整数，即 $r$ 必须是偶数。由于 $a^{r} \\equiv 1 \\pmod{N}$，所以 $N$ 整除 $a^{r}-1$。如果 $r$ 是偶数并且附加条件 $a^{\\frac{r}{2}} \\not\\equiv -1 \\pmod{N}$ 成立，那么两个因子都不等于 $0 \\pmod{N}$。因此，可以通过\n$$\np=\\gcd\\!\\left(a^{\\frac{r}{2}}-1,\\,N\\right),\\qquad q=\\gcd\\!\\left(a^{\\frac{r}{2}}+1,\\,N\\right),\n$$\n来提取 $N$ 的非平凡因子，对于随机选择的 $a$，这有很高的概率得出 $1<p<N$ 和 $1<q<N$。\n\n当量子子程序返回的周期 $r'$ 是奇数时，上述步骤从根本上失败了：因为 $\\frac{r'}{2}$ 不是整数，恒等式\n$$\na'^{\\,r'} - 1 = \\left(a'^{\\,\\frac{r'}{2}} - 1\\right)\\left(a'^{\\,\\frac{r'}{2}} + 1\\right)\n$$\n在整数上不可用。因此，标准的经典后处理没有直接的方法将 $a'^{\\,r'}-1$ 分解为两个模 $N'$ 同余于 $\\pm 1$ 的因子，也就无法应用通常的最大公约数计算来提取非平凡因子。这就是当 $r'$ 为奇数时，算法必须用不同的基数重新启动的根本原因。\n\n评估各个选项：\n\n- 选项 A 是错误的：即使 $\\gcd(a',N')=1$，也可能出现奇数阶 $r'$。GCD 预检查并不能排除奇数阶；它只检测 $a'$ 已经与 $N'$ 共享因子的平凡情况。\n\n- 选项 B 是错误的：量子傅里叶变换估计周期结构，但并不局限于偶数周期；奇数阶可能出现，而这并不意味着任何硬件故障。\n\n- 选项 C 是正确的：分解步骤关键性地使用了 $a'^{\\,r'}-1=\\left(a'^{\\,\\frac{r'}{2}}-1\\right)\\left(a'^{\\,\\frac{r'}{2}}+1\\right)$，这要求 $\\frac{r'}{2}\\in\\mathbb{Z}$，即 $r'$ 为偶数。\n\n- 选项 D 是不正确的：同余式 $a'^{\\,\\frac{r'}{2}}\\equiv -1 \\pmod{N'}$ 仅在 $r'$ 为偶数时有意义；它是 $r'$ 为偶数时的失败情况之一，而不是 $r'$ 为奇数的结果。\n\n- 选项 E 是误导性的：最终 GCD 计算的效率并不取决于阶是否为 2 的幂；障碍在于当 $r'$ 为奇数时，无法应用平方差步骤。\n\n因此，当 $r'$ 为奇数时失败的最准确和最根本的原因，正是在于经典因子提取依赖于使用 $\\frac{r'}{2}$ 将 $a'^{\\,r'}-1$ 表示为平方差，而如果 $r'$ 是奇数，这是不可能的。", "answer": "$$\\boxed{C}$$", "id": "1447866"}]}