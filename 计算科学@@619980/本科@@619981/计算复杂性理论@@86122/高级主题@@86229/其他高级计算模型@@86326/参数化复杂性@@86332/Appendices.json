{"hands_on_practices": [{"introduction": "参数化算法中最强大的技术之一是“有界搜索树”或分支算法。其核心思想是构建一个搜索树，其大小（节点数）是参数 $k$ 的函数，而不是总输入大小 $n$ 的函数。本练习将要求您分析支配集问题的搜索树大小，让您具体感受这些算法如何控制“组合爆炸”。[@problem_id:1434030]", "problem": "一家新的电信公司计划在一个城市部署一个基站网络。该城市的布局被建模为一个图 $G=(V, E)$，其中顶点集 $V$ 代表关键位置，边集 $E$ 代表直接的通信链路。放置在位置 $v \\in V$ 的基站可以为 $v$ 本身以及所有直接连接的位置（其邻居）提供服务。如果一个位置有基站，或者与一个有基站的位置相邻，那么该位置就被认为是“已覆盖”的。\n\n该公司希望确定是否可能通过部署至多 $k$ 个基站来覆盖城市中的所有位置。由于市政规定，任何单个位置最多可以与其他 $\\Delta$ 个位置有直接通信链路。\n\n为解决此问题，一位工程师提出了一种递归算法。该算法按以下步骤进行：\n1. 如果所有位置都已覆盖，则算法的当前探索路径成功终止。\n2. 如果 $k$ 个基站的预算已用尽（$k=0$）但仍有位置未被覆盖，则此探索路径失败。\n3. 否则，算法会识别一个任意的未覆盖位置 $u$。为确保 $u$ 被覆盖，必须在 $u$ 或其某个邻居处放置一个基站。\n4. 然后，算法通过独立的递归调用来探索每一种可能性。对于在某个位置 $v$（其中 $v$ 是 $u$ 或其邻居之一）放置基站的每一种选择，都会以 $k-1$ 的剩余预算进行一次新的递归调用，以覆盖网络的其余部分。\n\n将一条探索路径可以终止（无论是成功还是失败）的总方式数定义为“结果”的数量。这对应于完整递归调用树中的叶子数量。\n\n确定结果数量的最紧可能最坏情况上界。将您的答案表示为预算 $k$ 和最大度 $\\Delta$ 的函数。", "solution": "设 $T(k,\\Delta)$ 表示在给定预算 $k$ 的情况下，对于所有最大度至多为 $\\Delta$ 的图以及算法所做的所有选择，递归树中可能的结果（叶子）的最大数量。\n\n在任何剩余预算 $k>0$ 的递归步骤中，算法会选择一个未覆盖的顶点 $u$。为了覆盖 $u$，算法会在 $\\{u\\} \\cup N(u)$ 中的一个顶点上放置基站来进行分支，其中 $N(u)$ 表示 $u$ 的邻居。此步骤中的分支数量最多为 $|N(u)| + 1 \\le \\Delta + 1$。每个分支将预算减少1，因此从此步骤开始的每个子树都受 $T(k-1,\\Delta)$ 的限制。因此，\n$$\nT(k,\\Delta) \\le (\\Delta+1) \\, T(k-1,\\Delta).\n$$\n当 $k=0$ 或所有顶点都已覆盖时，递归终止。在任何一种情况下，当前节点都是一个叶子节点。因此，基本情况满足\n$$\nT(0,\\Delta)=1.\n$$\n通过展开递推关系，我们得到\n$$\nT(k,\\Delta) \\le (\\Delta+1)^{k} \\, T(0,\\Delta) = (\\Delta+1)^{k}.\n$$\n\n为了证明其紧密性，我们构造一个图，该图是 $k$ 个星形图的不交并，每个星形图都同构于 $K_{1,\\Delta}$（一个度为 $\\Delta$ 的中心和 $\\Delta$ 个叶子）。如果算法总是选择一个未覆盖星形图的中心作为 $u$，那么在 $k$ 个层级中的每一层都恰好有 $\\Delta+1$ 个分支（在该星形图的中心或其 $\\Delta$ 个叶子中的任何一个上放置基站），并且只有在每个星形图上恰好放置一个基站后，即在深度为 $k$ 之后，覆盖才会完成。因此，递归树是一个深度为 $k$ 的满 $(\\Delta+1)$-叉树，产生恰好 $(\\Delta+1)^{k}$ 个叶子。因此，界 $(\\Delta+1)^{k}$ 既是最坏情况上界，也是紧密的。", "answer": "$$\\boxed{(\\Delta+1)^{k}}$$", "id": "1434030"}, {"introduction": "内核化 (Kernelization) 是另一种强大的参数化技术，可以看作一种智能的预处理方法。在解决一个难题之前，我们应用“规约规则”将输入实例缩减为一个更小的“内核”，其大小仅取决于参数 $k$。本练习将指导您证明一个针对 $k$-不交三角形问题的简单规约规则是“安全”的——意味着它不会改变问题的最终答案——这是设计内核化算法的一项关键技能。[@problem_id:1434062]", "problem": "在计算复杂性理论中，尤其是在参数化算法的研究中，一个常用技术是应用预处理规则来简化问题实例。如果将一条规则应用于一个实例 $(I, k)$ 后，会得到一个新的、更小的实例 $(I', k')$，并且当且仅当新实例有解时，原实例也有解，那么这条规则被认为是“安全”的。\n\n考虑 **$k$-不交三角形**问题：\n\n**输入：**一个无向图 $G = (V, E)$ 和一个正整数 $k$。\n**问题：**$G$ 是否包含一个由 $k$ 个顶点不交的三角形组成的集合（即，任意两个三角形都不共享公共顶点）？\n\n针对此问题，提出的一条预处理规则如下：\n\n**规则：**如果存在一个顶点 $v \\in V$，其度 $\\text{deg}(v)$ 严格小于 2，则从图中移除 $v$。新实例变为 $(G - \\{v\\}, k)$。\n\n下列哪个陈述为这条规则对于 $k$-不交三角形问题是安全的提供了最完整和最正确的理由？\n\nA. 要成为三角形的一个顶点，该顶点必须与另外两个顶点相连，且这两个顶点之间也相连。这意味着参与构成三角形的任何顶点，其度必须至少为 2。因此，度小于 2 的顶点不可能属于任何三角形，移除它不会影响潜在的解。\n\nB. 这条规则是安全的，因为预处理的目标是减少图中的顶点和边的数量，从而使后续寻找三角形的计算成本更低，同时不改变参数 $k$。\n\nC. 度小于 2 的顶点通常位于图的外围。图的核心部分（其中更可能找到像三角形这样的复杂结构）被保留了下来。\n\nD. 度为 1 的顶点是叶节点。由于三角形是一个环，而叶节点不能成为任何环的一部分，所以移除它是安全的。这个逻辑可以扩展到度为 0 的孤立顶点。\n\nE. 如果一个顶点 $v$ 只有一个邻居 $u$，它就不能构成三角形。要使 $v$ 位于一个三角形中，它的邻居 $u$ 需要与 $v$ 的另一个邻居相邻，但 $v$ 没有其他邻居。这个论证不适用于度为 0 的顶点。", "solution": "要确定给定的预处理规则为何是安全的，我们必须证明原始图 $G$ 有解当且仅当修改后的图 $G' = G - \\{v\\}$ 有解，其中 $v$ 是任意一个度小于 2 的顶点。让我们通过证明这种双向等价性来分析这个问题。\n\n设原始问题实例为 $(G, k)$，新实例为 $(G', k)$，其中对于度 $\\text{deg}_G(v) < 2$ 的顶点 $v$，有 $G' = G - \\{v\\}$。\n\n**第一部分：如果 $(G, k)$ 有解，那么 $(G', k)$ 也有解。**\n\n假设 $G$ 有解。这意味着在 $G$ 中存在一个由 $k$ 个顶点不交的三角形组成的集合 $S = \\{T_1, T_2, \\dots, T_k\\}$。\n\n现在，考虑度 $\\text{deg}_G(v) < 2$ 的顶点 $v$。我们需要确定 $v$ 是否能成为 $G$ 中任何三角形的一部分。一个三角形是由三个顶点（比如 $\\{a, b, c\\}$）组成的集合，使得边 $(a, b)$、$(b, c)$ 和 $(c, a)$ 都存在于图中。任何顶点要成为这个三角形的一部分，它必须与另外两个顶点相连。例如，顶点 $a$ 必须有到 $b$ 和 $c$ 的边。这意味着任何在三角形内的顶点的度必须至少为 2。\n\n在我们的情况中，顶点 $v$ 的度 $\\text{deg}_G(v) < 2$。这意味着它的度为 0 或 1。\n- 如果 $\\text{deg}_G(v) = 0$，$v$ 是一个孤立顶点，没有任何边。它不可能成为任何三角形的一部分。\n- 如果 $\\text{deg}_G(v) = 1$，$v$ 恰好与另一个顶点相连。它不可能成为三角形的一部分，因为这需要至少有两条与它关联的边。\n\n由于 $v$ 不可能成为 $G$ 中任何三角形的顶点，所以它也不可能属于解集 $S$ 中的任何一个三角形。因此，$S$ 中的所有 $k$ 个三角形完全由来自 $V \\setminus \\{v\\}$ 的顶点组成。这意味着一个由 $k$ 个不交三角形组成的集合 $S$ 存在于由 $V \\setminus \\{v\\}$ 导出的子图中，而这个子图正是图 $G' = G - \\{v\\}$。\n\n因此，如果 $(G, k)$ 是一个“是”实例，那么 $(G', k)$ 也是一个“是”实例。\n\n**第二部分：如果 $(G', k)$ 有解，那么 $(G, k)$ 也有解。**\n\n这个方向的证明更直接。假设 $G' = G - \\{v\\}$ 有解。这意味着在 $G'$ 中存在一个由 $k$ 个顶点不交的三角形组成的集合 $S = \\{T_1, T_2, \\dots, T_k\\}$。\n\n图 $G'$ 是 $G$ 的一个子图。$G'$ 中的任何边和顶点也都存在于 $G$ 中。因此，集合 $S$ 中的所有三角形也都存在于图 $G$ 中。由于这些三角形在 $G'$ 中是顶点不交的，它们在 $G$ 中也保持顶点不交（因为 $G$ 只是增加了顶点 $v$ 及其关联的边，而这些都不属于 $S$ 中的任何三角形）。\n\n因此，如果 $(G', k)$ 是一个“是”实例，那么 $(G, k)$ 也是一个“是”实例。\n\n**结论与选项评估：**\n\n由于我们已经证明了双向蕴涵关系，所以该规则是安全的。证明的核心在于第一部分的论证：度小于 2 的顶点不可能成为任何三角形的一部分。让我们基于这个推理来评估给出的选项。\n\n*   **A：** 该陈述正确地指出了根本原因。三角形中的一个顶点，其度必须至少为 2。因此，任何度为 0 或 1 的顶点都与任何潜在的不交三角形解无关。移除它是安全的。这是一个完整且准确的理由。\n*   **B：** 该陈述描述了预处理的*目的*（简化实例），而不是这条特定规则为何*正确*或“安全”的数学理由。\n*   **C：** 这里使用了“外围”和“核心”等非正式语言。虽然直观，但这并不是一个严谨的数学论证，也没有提供正式的理由。\n*   **D：** 这个陈述对于度为 1 的顶点的推理是正确的（叶节点不能在环中），但没有 A 直接。A 的推理基于三角形中顶点的直接局部属性，对于这个问题来说，这比环的一般属性是更根本的论证。\n*   **E：** 这个陈述正确地分析了度为 1 的顶点的情况，但明确指出它没有涵盖度为 0 的顶点。该规则适用于任何度*严格小于 2*的顶点，所以这个理由是不完整的。\n\n因此，选项 A 为该规则的安全性提供了最完整和最根本的理由。", "answer": "$$\\boxed{A}$$", "id": "1434062"}, {"introduction": "现在，我们将前一个练习中的实践技术与理论联系起来。参数化复杂性中一个重要的定理指出，一个问题是固定参数可解的 (FPT)，当且仅当它拥有一个内核化算法。本练习旨在检验您对这一深刻联系的理解，要求您思考发现一个内核大小虽然受 $k$ 的函数限制但并非多项式函数时所带来的影响。这将帮助您区分 FPT 的一般概念与拥有多项式内核这一更具体、更理想的性质。[@problem_id:1434031]", "problem": "在参数化复杂性领域，一个核心目标是为那些通常是计算困难的问题寻找高效的算法。这通常通过识别一个与输入相关的参数 $k$ 并设计一个其复杂度仅在 $k$ 上是指数型的，但在总输入大小 $n$ 上是多项式型的算法来实现。\n\n一个参数化问题是一种语言 $L \\subseteq \\Sigma^* \\times \\mathbb{N}$，其中对于一个实例 $(x, k)$，$x$是输入的主要部分，$k$是参数。如果一个问题可以被一个运行时间为 $f(k) \\cdot |x|^c$ 的算法解决，其中 $f$ 是任何仅依赖于 $k$ 的可计算函数，而 $c$ 是一个与 $k$ 和 $|x|$ 无关的常数，则该问题被称为**固定参数可解（FPT, Fixed-Parameter Tractable）**。\n\n**核化算法（kernelization algorithm）**是一种多项式时间算法，它接受一个参数化问题的实例 $(x, k)$ 并返回一个等价的实例 $(x', k')$，称为**核（kernel）**。核的一个关键特性是其大小受一个关于参数的函数所界定，即对于某个函数 $g$，有 $|x'| \\le g(k)$ 和 $k' \\le g(k)$。如果大小函数 $g(k)$ 是关于 $k$ 的多项式，则该核被称为**多项式核（polynomial kernel）**。\n\n假设一位研究人员正在研究一个新的参数化问题，并为其发现了一个核化算法。该算法的运行时间是输入大小 $|x|$ 的多项式，并产生一个大小由函数 $g(k) = k^{\\log k}$ 界定的核，其中 $k$ 是参数。\n\n基于这一发现，以下哪个陈述是绝对正确的？\n\nA. 该问题不在 FPT 中，因为核大小 $g(k)$ 是超多项式级的。\n\nB. 该问题有一个多项式核，因为 $g(k) = k^{\\log k}$ 的增长速度远慢于像 $2^k$ 这样的纯指数函数。\n\nC. 该问题在 FPT 中，但这个特定的核化过程并不能证明该问题拥有多项式核。\n\nD. 如果不知道用于解决核内实例的具体算法，就不可能确定该问题是否在 FPT 中。\n\nE. 该问题有一个多项式核，因为核化算法本身在多项式时间内运行。", "solution": "解答需要对固定参数可解（FPT）、核化和多项式核的定义有仔细的理解。我们将逐步分析给定的情景。\n\n1.  **核化与 FPT 的关系：** 参数化复杂性中的一个基本定理指出，一个可判定的参数化问题是固定参数可解的（FPT），当且仅当它是可核化的。如果一个问题存在一个如题目描述中所述的核化算法，那么它就是“可核化的”。该定理对核的大小没有任何限制，除了其大小必须由某个关于参数 $k$ 的可计算函数 $g(k)$ 界定。\n\n2.  **将定理应用于本问题：** 题目陈述明确指出，对于所讨论的问题，存在一个核化算法。该算法在多项式时间内运行，并将任何实例 $(x, k)$ 归约为一个等价的核 $(x', k')$。因此，根据该定理，该问题保证属于 FPT。解决该问题的总运行时间将是核化所需的时间（在 $|x|$ 上是多项式时间，例如 $O(|x|^d)$）加上解决核所需的时间之和。由于核的大小 $|x'|$ 仅依赖于 $k$（即 $|x'| \\le k^{\\log k}$），任何用于解决核的算法，即使是暴力算法，其运行时间也将纯粹是 $k$ 的函数。我们将这个时间称为 $h(|x'|) = h(k^{\\log k})$。令 $f(k) = h(k^{\\log k})$。总时间为 $O(|x|^d) + f(k)$。根据定义，具有此运行时间的算法是一个 FPT 算法。因此，核的存在，无论其大小如何，都证明了该问题在 FPT 中。\n\n3.  **分析核的大小：** 现在的问题是确定这个核是否是*多项式核*。多项式核要求大小函数 $g(k)$ 是关于 $k$ 的一个多项式。如果一个函数 $p(k)$ 可以写成 $p(k) = a_d k^d + a_{d-1} k^{d-1} + \\dots + a_0$ 的形式，其中 $d$ 是某个固定的、常数的次数，则该函数是多项式。给定的大小函数是 $g(k) = k^{\\log k}$。要检查这是否是多项式，我们可以将其增长率与任意一个常数 $c$ 的多项式 $p(k) = k^c$ 进行比较。我们可以分析其指数。该函数是 $k^{\\log k}$。一个多项式的形式是 $k^c$，其中 $c$ 是一个常数。在我们的例子中，指数是 $\\log k$，它不是一个常数；它随 $k$ 的增长而增长。因此，$g(k) = k^{\\log k}$ 不是 $k$ 的多项式函数。它比任何多项式增长得都快。例如，对于任何常数 $c > 0$，当 $k \\to \\infty$ 时，比率 $\\frac{k^{\\log k}}{k^c} = k^{\\log k - c}$ 趋于无穷大。这证实了 $k^{\\log k}$ 是一个超多项式函数。\n\n4.  **评估选项：**\n    *   **A. 该问题不在 FPT 中，因为核大小 $g(k)$ 是超多项式级的。** 这是不正确的。如步骤2所述，*任何*核的存在都保证了问题在 FPT 中。\n    *   **B. 该问题有一个多项式核，因为 $g(k) = k^{\\log k}$ 的增长速度远慢于像 $2^k$ 这样的纯指数函数。** 这是不正确的。虽然 $k^{\\log k}$ 的确是次指数级的，但“非指数级”并不是多项式级的定义。如步骤3所示，$k^{\\log k}$ 是超多项式级的。\n    *   **C. 该问题在 FPT 中，但这个特定的核化过程并不能证明该问题拥有多项式核。** 这是正确的。该问题在 FPT 中，因为它是可核化的（步骤2）。这个特定的核不是多项式核，因为其大小函数 $g(k) = k^{\\log k}$ 是超多项式级的（步骤3）。该问题可能存在另一个不同的核化算法，能产生一个多项式核，但题目中给出的这个并不能证明这一点。\n    *   **D. 如果不知道用于解决核内实例的具体算法，就不可能确定该问题是否在 FPT 中。** 这是不正确的。核化过程的存在足以证明问题在 FPT 中，如步骤2所述。我们总可以在核上使用暴力（或任何）算法。\n    *   **E. 该问题有一个多项式核，因为核化算法本身在多项式时间内运行。** 这是不正确的。这混淆了两个不同的属性。核化的定义*要求*归约算法在多项式时间内运行。而*多项式核*的定义与该算法*输出的大小*有关，而不是其运行时间。\n\n因此，唯一绝对正确的陈述是C。", "answer": "$$\\boxed{C}$$", "id": "1434031"}]}