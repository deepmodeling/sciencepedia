{"hands_on_practices": [{"introduction": "在深入研究复杂的算法之前，一个高效的预处理步骤是检查是否存在使问题变得简单的特殊条件。这个练习将探讨背包问题中的一个场景，即当所有物品的总重量小于背包容量时，会发生什么。通过这个例子[@problem_id:1429641]，你将学习如何识别并利用这种“平凡实例”，从而在多项式时间内直接解决问题，避免不必要的计算。", "problem": "在物流领域的算法优化中，一位数据科学家负责提高一辆送货卡车的装载算法的效率。该问题被建模为经典的0/1背包问题。\n\n该问题形式化定义如下：给定一个包含 $n$ 个物品的集合，其中每个物品 $i$（$i=1, \\dots, n$）都有一个正整数重量 $w_i > 0$ 和一个正整数价值 $v_i > 0$。目标是选择这些物品的一个子集装入一个最大载重容量为 $W$ 的背包（即卡车）中，以使得所选物品的价值总和最大化。设 $S$ 为物品的一个子集。目标是在满足约束条件 $\\sum_{i \\in S} w_i \\le W$ 的情况下，最大化 $\\sum_{i \\in S} v_i$。\n\n作为称为“核化”（kernelization）的预处理步骤的一部分，该数据科学家的算法在尝试使用一个更复杂的、可能是指数时间的算法解决问题之前，对输入实例进行初步分析。在对一组特定的 $n$ 个物品和卡车容量 $W$ 进行分析时，该算法发现所有可用物品的重量总和严格小于卡车的容量，即 $\\sum_{i=1}^{n} w_i < W$。\n\n基于对该实例的这一特定发现，算法可以对这个0/1背包问题实例得出什么最准确的结论？\n\nA. 该实例可以在多项式时间内通过选择所有物品来解决，因为这一选择保证是最优的，并且满足重量约束。\n\nB. 该问题仍然是NP难的，但是一个将物品按其价值重量比排序并按降序选取的贪心算法现在保证能找到最优解。\n\nC. 该实例是不可行的，意味着任何物品子集的选择都会超过容量 $W$。\n\nD. 该问题可以被高效地归约为一个子集和问题的实例。\n\nE. 最优解将恰好只包含一个物品，即价值最高的那个物品 $v_i$。", "solution": "给定一个0/1背包问题实例，其中物品由 $i \\in \\{1,\\dots,n\\}$ 索引，每个物品具有正整数重量 $w_{i} > 0$ 和价值 $v_{i} > 0$，背包容量为 $W$。目标是在所有子集 $S \\subseteq \\{1,\\dots,n\\}$ 中，满足约束条件 $\\sum_{i \\in S} w_{i} \\le W$ 的前提下，最大化 $\\sum_{i \\in S} v_{i}$。预处理揭示了所有物品的重量总和满足\n$$\n\\sum_{i=1}^{n} w_{i} < W.\n$$\n令 $N = \\{1,\\dots,n\\}$ 表示所有物品的集合，并考虑选择 $S = N$。那么，重量约束是满足的，因为\n$$\n\\sum_{i \\in S} w_{i} \\;=\\; \\sum_{i=1}^{n} w_{i} \\;<\\; W \\;\\;\\Rightarrow\\;\\; \\sum_{i \\in S} w_{i} \\le W,\n$$\n所以 $S=N$ 是一个可行解。由于所有价值都是严格为正的，对于任何子集 $T \\subseteq N$，我们有\n$$\n\\sum_{i \\in T} v_{i} \\;\\le\\; \\sum_{i \\in N} v_{i},\n$$\n等号成立当且仅当 $T = N$。这是由单调性得出的：添加任何不在 $T$ 中的物品 $j$ 都会使目标值增加 $v_{j} > 0$。因此，在所有可行子集中，子集 $S = N$ 产生最大目标值，因为它是可行的，并且其价值优于任何真子集。因此，最优解是选择所有物品，并且这可以在多项式时间内通过检查单个不等式 $\\sum_{i=1}^{n} w_{i} < W$ 并返回 $S=N$ 来验证。\n\n评估各个选项：\n- A是正确的：选择所有物品是最优且可行的，这为该实例提供了一个多项式时间的解法。\n- B不是最准确的描述：虽然基于比率的贪心算法在这种特殊情况下也会包含所有物品（因为任何顺序的物品总重量都低于容量），但关键结论不是关于贪心启发式，而是该实例可以通过选取所有物品被轻易地解决；援引NP难度和贪心算法是不必要的，且不如A选项精确。\n- C是错误的：该实例是可行的，因为 $S=N$ 是一个可行解。\n- D是不必要的，并且对于此实例来说不是一个准确的结论：该实例已经解决了，不需要归约到子集和问题。\n- E是错误的：最优解包含所有物品，而不仅仅是一个。\n\n因此，最准确的结论是A。", "answer": "$$\\boxed{A}$$", "id": "1429641"}, {"introduction": "核化的一个核心思想是识别并移除问题实例中的“被支配”元素，从而在不改变解的最优性的前提下缩小问题规模。这个练习以一个直观的“团队组建”问题为例，该问题本质上是集合覆盖问题的一个变体。你将分析当一名员工的技能集完全被另一名员工的技能集包含时，我们能做出何种安全的简化决策[@problem_id:1429664]，这揭示了支配规则在数据约减中的强大作用。", "problem": "在计算复杂性理论中，核化（kernelization）是一种用于减小问题实例规模的预处理技术。考虑以下我们称之为**最小团队覆盖（MINIMUM TEAM COVER）**的判定问题：\n\n给定一个可用员工集合 $E$，其中每位员工 $e \\in E$ 都拥有一组特定的技能 $S_e$，一个所需技能的目标集合 $S_{req}$，以及一个整数 $k$，我们能否选出一个最多由 $k$ 名员工组成的团队，使得 $S_{req}$ 中的每一项技能都被至少一名团队成员所覆盖？\n\n一家咨询公司正在分析此问题的一个小实例，以确定哪些预处理规则是有效的。一个有效规则的目标是通过将员工从考虑范围内移除来简化实例，同时对于任何可能的 $k$ 和 $S_{req}$，都不会改变“最小团队覆盖”问题的答案。换句话说，如果存在一个最优（规模最小）的团队，那么从缩减后的员工池中应该仍然能够找到一个最优团队。\n\n当前的候选人及其技能如下：\n*   **Liam**: {'版本控制', 'API设计'}\n*   **Mia**: {'数据库', 'UI/UX'}\n*   **Noah**: {'版本控制'}\n*   **Olivia**: {'版本控制', 'API设计', '测试'}\n*   **Ethan**: {'数据库'}\n\n下列哪个陈述描述了可以应用于此候选人池的有效预处理步骤？选择所有适用项。\n\nA. 移除 Liam，因为他的技能集是 Olivia 技能集的严格子集。\n\nB. 移除 Olivia，因为她的技能集严格包含 Liam 的技能集。\n\nC. 移除 Noah，因为他的技能集是 Liam 技能集的严格子集。\n\nD. 移除 Ethan，因为他的技能集是 Mia 技能集的严格子集。\n\nE. 无法在不潜在影响找到最优解的能力的情况下移除任何员工。", "solution": "我们为集合覆盖类问题形式化一个标准的支配（子集）归约规则。对于拥有技能集 $S_{x}$ 和 $S_{y}$ 的员工 $x$ 和 $y$，如果 $S_{x} \\subset S_{y}$，那么 $x$ 被 $y$ 支配，可以被安全地移除，而不会改变对于任何目标 $S_{req}$ 和任何 $k$ 的判定问题的答案。\n\n安全性证明：固定任意的 $S_{req}$ 和 $k$。考虑任何一个大小为 $|T| \\leq k$ 的可行团队 $T$。如果 $x \\notin T$，那么从员工池中移除 $x$ 没有影响。如果 $x \\in T$，定义 $T' = (T \\setminus \\{x\\}) \\cup \\{y\\}$。那么 $|T'| = |T| \\leq k$，并且由于 $S_{x} \\subset S_{y}$，由 $T'$ 覆盖的技能集合包含了由 $T$ 覆盖的所有技能。因此 $T'$ 也是可行的。如果 $T$ 是一个最小规模的可行团队，那么 $T'$ 的规模与 $T$ 相同，所以存在一个不使用 $x$ 的最优团队。因此，移除 $x$ 对于所有的 $S_{req}$ 和 $k$ 都保持了可行性和最优性。反之，移除 $y$ 通常是不安全的，因为 $y$ 可能拥有 $S_{x}$ 中没有的技能，而这些技能可能是某个 $S_{req}$ 所需的。\n\n将此规则应用于给定的候选人池：\n- Liam vs. Olivia: $S_{\\text{Liam}} = \\{\\text{版本控制}, \\text{API设计}\\}$ 且 $S_{\\text{Olivia}} = \\{\\text{版本控制}, \\text{API设计}, \\text{测试}\\}$。我们有 $S_{\\text{Liam}} \\subset S_{\\text{Olivia}}$，所以移除 Liam 是有效的。这验证了选项 A。\n- 因为 Olivia 的技能集严格包含 Liam 的技能集而移除 Olivia（选项 B）通常是无效的：如果 $S_{req}$ 包含“测试”技能，只有 Olivia 提供该技能，因此移除 Olivia 可能会改变答案。\n- Noah vs. Liam（以及 Olivia）: $S_{\\text{Noah}} = \\{\\text{版本控制}\\} \\subset S_{\\text{Liam}}$ 且 $S_{\\text{Noah}} \\subset S_{\\text{Olivia}}$。因此，根据支配规则，移除 Noah 是有效的。这验证了选项 C。\n- Ethan vs. Mia: $S_{\\text{Ethan}} = \\{\\text{数据库}\\} \\subset S_{\\text{Mia}} = \\{\\text{数据库}, \\text{UI/UX}\\}$。因此，移除 Ethan 是有效的。这验证了选项 D。\n- 由于 A、C 和 D 都是有效的移除操作，因此陈述 E 是错误的。\n\n因此，有效的预处理步骤是 A、C 和 D。", "answer": "$$\\boxed{ACD}$$", "id": "1429664"}, {"introduction": "与移除被支配元素相辅相成的是识别并删除冗余约束。如果一个约束的存在被另一个更严格的约束所蕴含，那么它就是多余的。这个练习将带你进入经典的$d$-集合命中问题，你将分析当一个待“命中”的集合是另一个集合的超集时的情况[@problem_id:1429634]。这个实践将帮助你理解如何通过消除冗余的条件来精简问题，这是与支配规则对偶的重要预处理技巧。", "problem": "在计算复杂性理论中，$d$-Hitting Set 问题是一个经典的判定问题。该问题的一个实例由一个元组 $(U, \\mathcal{S}, k)$ 定义，其中 $U$ 是一个元素全集，$\\mathcal{S} = \\{S_1, S_2, \\ldots, S_m\\}$ 是 $U$ 的一个子集集合，其中每个集合 $S_i$ 的大小最多为 $d$（即 $|S_i| \\le d$），而 $k$ 是一个正整数。问题是是否存在一个大小至多为 $k$ 的“触碰集”$H \\subseteq U$（即 $|H| \\le k$），它与集合 $\\mathcal{S}$ 中的每个集合都有非空交集（即对于所有 $i=1, \\ldots, m$，都有 $H \\cap S_i \\neq \\emptyset$）。\n\n作为解决该问题的预处理步骤，我们通常会寻找可以减小实例规模的简化规则，而不改变判定问题的答案。考虑一个 $d$-Hitting Set 实例，其中对于集合中的两个不同集合 $S_i \\in \\mathcal{S}$ 和 $S_j \\in \\mathcal{S}$，已知 $S_j$ 是 $S_i$ 的一个真子集（即 $S_j \\subset S_i$）。\n\n下列哪个陈述描述了一个可以应用于该实例的有效简化，同时保证简化后的实例有“是”答案，当且仅当原始实例也有“是”答案？\n\nA. 集合 $S_i$ 可以从集合 $\\mathcal{S}$ 中移除。\n\nB. 集合 $S_j$ 可以从集合 $\\mathcal{S}$ 中移除。\n\nC. 集合 $S_i$ 和 $S_j$ 都可以从集合 $\\mathcal{S}$ 中移除。\n\nD. 集合差 $S_i \\setminus S_j$ 中的所有元素都可以从全集 $U$ 中移除，并因此从 $\\mathcal{S}$ 中任何包含这些元素的集合中移除。\n\nE. 实例的任何有效触碰集都必须包含至少一个来自集合差 $S_i \\setminus S_j$ 的元素。", "solution": "该问题要求为 $d$-Hitting Set 问题寻找一个有效的规约规则，该规则适用于输入集合中一个集合 $S_j$ 是另一个集合 $S_i$ 的真子集的情况。如果修改后的实例是“是”实例当且仅当原始实例是“是”实例，那么该规约规则是有效的。设原始实例为 $I = (U, \\mathcal{S}, k)$，建议的简化实例为 $I'$。我们需要证明 $I$ 存在一个大小至多为 $k$ 的触碰集，当且仅当 $I'$ 也存在。\n\n让我们逐一分析每个选项。\n\n**选项A分析：集合 $S_i$ 可以从集合 $\\mathcal{S}$ 中移除。**\n\n设新实例为 $I' = (U, \\mathcal{S}', k)$，其中 $\\mathcal{S}' = \\mathcal{S} \\setminus \\{S_i\\}$。我们需要证明，存在一个大小至多为 $k$ 的触碰集 $H$ 用于实例 $I$，当且仅当存在一个大小至多为 $k$ 的触碰集 $H'$ 用于实例 $I'$。\n\n首先，假设原始实例 $I$ 存在一个大小至多为 $k$ 的触碰集 $H$。根据定义，$H$ 与 $\\mathcal{S}$ 中的每个集合相交。这包括子集集合 $\\mathcal{S}' = \\mathcal{S} \\setminus \\{S_i\\}$ 中的每个集合。因此，$H$ 也是实例 $I'$ 的一个有效触碰集。所以，如果 $I$ 是一个“是”实例，那么 $I'$ 也是一个“是”实例。\n\n接下来，假设简化实例 $I'$ 存在一个大小至多为 $k$ 的触碰集 $H'$。根据定义，$H'$ 与 $\\mathcal{S}'$ 中的每个集合相交。为了证明 $H'$ 也是原始实例 $I$ 的一个触碰集，我们只需要验证 $H'$ 与被移除的那个集合 $S_i$ 相交。\n由于 $S_j \\in \\mathcal{S}$ 且 $S_j \\neq S_i$，因此 $S_j \\in \\mathcal{S}'$。因为 $H'$ 是 $I'$ 的一个触碰集，所以它必须与 $S_j$ 相交。这意味着存在一个元素 $x$ 使得 $x \\in H'$ 且 $x \\in S_j$。\n给定条件是 $S_j \\subset S_i$。根据子集的定义，$S_j$ 中的每个元素也都在 $S_i$ 中。由于 $x \\in S_j$，那么必然有 $x \\in S_i$。\n因此，$x \\in H' \\cap S_i$，这意味着 $H'$ 与 $S_i$ 有非空交集。\n由于 $H'$ 与 $\\mathcal{S}'$ 中的每个集合相交，并且也与 $S_i$ 相交，所以它与 $\\mathcal{S}$ 中的每个集合都相交。因此，$H'$ 是原始实例 $I$ 的一个有效触碰集。所以，如果 $I'$ 是一个“是”实例，那么 $I$ 也是一个“是”实例。\n\n由于两个实例的解的存在性是等价的，因此这个简化是有效的。由 $S_i$ 施加的约束是冗余的，因为任何“触碰”了更严格约束 $S_j$ 的集合，将自动触碰更宽松的约束 $S_i$。\n\n**选项B分析：集合 $S_j$ 可以从集合 $\\mathcal{S}$ 中移除。**\n\n这是一个无效的简化。考虑一个反例：\n设全集为 $U = \\{a, b\\}$。设集合的集族为 $\\mathcal{S} = \\{S_i, S_j\\}$，其中 $S_i = \\{a, b\\}$ 且 $S_j = \\{a\\}$，并设 $k=1$。我们有 $S_j \\subset S_i$。\n根据此规则，简化后的实例是 $I' = (U, \\{S_i\\}, k)$，即 $(U, \\{\\{a, b\\}\\}, 1)$。$I'$ 的一个有效触碰集是 $H' = \\{b\\}$。\n然而，$H'=\\{b\\}$ 不是原始实例 $I$ 的有效触碰集，因为它不与 $S_j = \\{a\\}$ 相交。\n原始实例唯一的有效触碰集是 $H=\\{a\\}$。通过移除 $S_j$，我们改变了问题，从而出现了一个新的、不正确的解。\n\n**选项C分析：集合 $S_i$ 和 $S_j$ 都可以从集合 $\\mathcal{S}$ 中移除。**\n\n这也是无效的。如果仅仅移除 $S_j$ 是无效的（如上所示），那么同时移除 $S_j$ 和 $S_i$ 也必然是无效的，因为它从问题中移除了一个必要的约束（$S_j$）。例如，在选项 B 的反例中，同时移除 $\\{a,b\\}$ 和 $\\{a\\}$ 会留下一个空的集合集族，对于它来说，空集是一个大小为 0 的有效触碰集。这显然不是原始问题的解。\n\n**选项D分析：集合差 $S_i \\setminus S_j$ 中的所有元素都可以从全集 $U$ 中移除。**\n\n这是一个无效的简化。从全集中移除元素可能会消除有效的解。\n考虑一个反例：\n设 $U = \\{a, b, c\\}$。设集族为 $\\mathcal{S} = \\{S_1, S_2\\}$，其中 $S_1 = \\{a, c\\}$ 且 $S_2 = \\{b\\}$。此外，设 $S_i = \\{a,b\\}$ 且 $S_j=\\{a\\}$。完整的集族是 $\\mathcal{S}_{full} = \\{ \\{a,c\\}, \\{b\\}, \\{a,b\\}, \\{a\\} \\}$。设 $k=2$。\n集合差是 $S_i \\setminus S_j = \\{a,b\\} \\setminus \\{a\\} = \\{b\\}$。该规则建议从全集中移除元素 $b$。\n原始实例有一个大小为 2 的有效触碰集 $H = \\{b, c\\}$。$H$ 用 $c$ 触碰 $\\{a,c\\}$，并用 $b$ 触碰 $\\{b\\}$、$\\{a,b\\}$ 和 $\\{a\\}$。\n让我们应用该规则。我们从 $U$ 中移除 $b$。新的全集是 $U'=\\{a,c\\}$。这些集合变为：\n$S_1' = \\{a, c\\}$\n$S_2' = \\emptyset$（有问题！触碰集无法与空集相交。许多 Hitting Set 的定义要求集合为非空。为避免这种退化情况，我们假设集合为非空并完善这个例子）。\n\n完善后的反例：\n设 $U=\\{a,b,c\\}$ 且 $\\mathcal{S} = \\{ \\{a, b\\}, \\{a\\}, \\{b, c\\} \\}$。设 $k=1$。\n这里，$S_i = \\{a,b\\}$ 且 $S_j = \\{a\\}$。集合差是 $S_i \\setminus S_j = \\{b\\}$。该规则建议从全集 $U$ 中移除 $b$。\n原始问题要求为 $\\{\\{a,b\\}, \\{a\\}, \\{b,c\\}\\}$ 找到一个大小为 1 的触碰集。唯一的解是 $H=\\{b\\}$。它用 $b$ 触碰 $\\{a,b\\}$ 和 $\\{b,c\\}$，而根据我们对选项 A 的分析，它不需要触碰 $\\{a\\}$（因为我们可以移除 $\\{a,b\\}$）。实际需要触碰的集合是 $\\{a\\}$ 和 $\\{b,c\\}$。这没有大小为 1 的触碰集。让我们把 $k$ 改为 2。一个解是 $\\{a,b\\}$。\n让我们试一个更清晰的例子。$U=\\{a,b,d\\}$, $\\mathcal{S} = \\{\\{a,d\\}, \\{b,d\\}\\}$。$k=1$。解：$H=\\{d\\}$。\n现在，加入 $S_i=\\{a,c\\}$ 和 $S_j=\\{a\\}$。实例变为 $\\mathcal{S}' = \\{\\{a,d\\}, \\{b,d\\}, \\{a,c\\}, \\{a\\}\\}$。$S_i \\setminus S_j = \\{c\\}$。该规则说要从 $U$ 中移除 $c$。\n新实例：$U'=\\{a,b,d\\}$, $\\mathcal{S}'' = \\{\\{a,d\\}, \\{b,d\\}, \\{a\\}, \\{a\\}\\}$。问题是触碰 $\\{\\{a,d\\},\\{b,d\\},\\{a\\}\\}$。一个大小为 2 的触碰集是 $\\{a,d\\}$。\n原始实例：$\\mathcal{S}' = \\{\\{a,d\\}, \\{b,d\\}, \\{a,c\\}, \\{a\\}\\}$。一个大小为 2 的触碰集可以是 $\\{c,d\\}$。通过移除 $c$，这个有效的解就被破坏了。因此，这个规则是无效的。\n\n**选项E分析：实例的任何有效触碰集都必须包含至少一个来自集合差 $S_i \\setminus S_j$ 的元素。**\n\n这是错误的。一个触碰集必须与 $S_j$ 相交。如果它通过选择一个元素 $x \\in S_j$ 来做到这一点，那么它也与 $S_i$ 相交了（因为 $x \\in S_j \\implies x \\in S_i$）。没有必要从 $S_i \\setminus S_j$ 中选择一个元素来满足与 $S_i$ 或 $S_j$ 相关的约束。例如，设 $U=\\{a, b, c\\}$，$\\mathcal{S}=\\{\\{a, b\\}, \\{a\\}, \\{c\\}\\}$，且 $k=2$。这里 $S_i=\\{a,b\\}$ 且 $S_j=\\{a\\}$。集合差是 $\\{b\\}$。一个有效的触碰集是 $H=\\{a,c\\}$。这个集合不包含任何来自集合差 $S_i \\setminus S_j = \\{b\\}$ 的元素。因此，该陈述是错误的。\n\n根据以上分析，只有选项 A 描述了一个有效的简化。", "answer": "$$\\boxed{A}$$", "id": "1429634"}]}