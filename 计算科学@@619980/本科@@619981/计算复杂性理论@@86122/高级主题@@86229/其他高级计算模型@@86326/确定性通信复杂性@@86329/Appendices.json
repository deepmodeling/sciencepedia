{"hands_on_practices": [{"introduction": "通信复杂性的核心在于证明协议所需通信量的下界。本练习 [@problem_id:1421116] 提供了一个极佳的起点，它将问题置于一个直观的图论场景中：判断网络中的两个节点是否相邻。通过解决这个问题，你将亲手构建一个简单的协议来确定通信的上界，并运用经典的“愚弄集”（fooling set）论证来证明一个严格的下界，从而精确地确定其通信复杂度。", "problem": "两方，Alice和Bob，需要解决一个与网络结构相关的计算问题。该网络是一个有10个顶点的循环图，顶点被连续标记为0, 1, 2, ..., 9。在此图中，任意顶点 $i$ 仅通过一条边与顶点 $(i-1) \\pmod{10}$ 和顶点 $(i+1) \\pmod{10}$ 相连。\n\nAlice私下持有一个顶点标签 $x \\in \\{0, 1, ..., 9\\}$，Bob私下持有一个顶点标签 $y \\in \\{0, 1, ..., 9\\}$。Alice不知道Bob的顶点，Bob也不知道Alice的顶点。他们的目标是确定他们在图中的顶点是否相邻。他们可以遵循一个预先安排好的协议，通过一个信道相互发送比特来进行通信。\n\n在最坏情况输入下，为了保证Alice能得知她的顶点是否与Bob的顶点相邻，他们之间必须交换的绝对最小比特数是多少？\n\nA. 3\nB. 4\nC. 5\nD. 10", "solution": "设顶点集合为 $V = \\{0, 1, \\dots, 9\\}$。Alice的输入是 $x \\in V$，Bob的输入是 $y \\in V$。他们想要计算函数 $ADJ(x, y)$，其中当顶点 $x$ 和 $y$ 相邻时 $ADJ(x, y) = 1$，否则 $ADJ(x, y) = 0$。根据问题描述，在这个10顶点的循环图中，相邻意味着 $y = (x+1) \\pmod{10}$ 或 $y = (x-1) \\pmod{10}$。最终结果必须被Alice知晓。\n\n首先，我们确定所需比特数的一个上界。可以通过构造一个有效的通信协议来找到一个上界。\n\n考虑以下协议：\n1. Bob将他的输入顶点 $y$ 发送给Alice。\n2. Alice接收到 $y$。由于她知道自己的输入 $x$，她现在就有了两个输入。\n3. Alice通过检查 $y$ 是否等于 $(x+1) \\pmod{10}$ 或 $(x-1) \\pmod{10}$ 来计算 $ADJ(x, y)$。既然她现在知道了结果，协议就完成了。\n\n我们来分析这个协议所需的比特数。Bob的输入 $y$ 可以是 $\\{0, 1, \\dots, 9\\}$ 中的10个值中的任意一个。为了编码10种可能性中的一种，最少需要 $\\lceil \\log_2(10) \\rceil$ 个比特。\n$\\log_2(8) = 3$ 且 $\\log_2(16) = 4$，所以 $\\log_2(10)$ 在3和4之间。因此，$\\lceil \\log_2(10) \\rceil = 4$。\nBob可以把他数字 $y$ 的一个4比特二进制表示发送给Alice。这个协议总共需要4比特的通信量。这就确定了一个上界：所需的最小比特数最多为4。\n\n接下来，我们确定比特数的一个下界。为了证明4比特是最小值，我们必须证明没有任何使用3个或更少比特的协议能够解决这个问题。我们将使用一个“愚弄集”论证。任何通信量为 $k$ 比特的确定性协议，最多可以有 $2^k$ 种不同的通信记录（交换的消息序列）。如果两个不同的输入对 $(x_1, y_1)$ 和 $(x_2, y_2)$ 产生相同的通信记录，那么协议就无法区分它们。这意味着“交叉”对 $(x_1, y_2)$ 和 $(x_2, y_1)$ 也必定产生相同的记录。对于一个正确的协议，这四对输入都必须产生相同的输出值（这被称为一个单色矩形）。如果我们能找到一个包含 $M$ 个输入对的集合，在任何有效协议中，这些输入对都必须有不同的通信记录，那么我们就需要至少 $M$ 种不同的记录。这意味着 $2^k \\ge M$，或者 $k \\ge \\lceil \\log_2(M) \\rceil$。\n\n我们来构造这样一个对的集合。考虑由10个顶点相邻的输入对组成的集合 $S$：\n$S = \\{ (0,1), (1,2), (2,3), (3,4), (4,5), (5,6), (6,7), (7,8), (8,9), (9,0) \\}$。\n对于 $S$ 中的每一对 $(x,y)$，函数值都是 $ADJ(x,y) = 1$。\n\n我们从 $S$ 中任取两个不同的对：$(x_1, y_1) = (i, (i+1)\\pmod{10})$ 和 $(x_2, y_2) = (j, (j+1)\\pmod{10})$，其中 $i \\neq j$。\n为了引出矛盾，我们假设这两对可以产生相同的通信记录。这将意味着交叉对 $(x_1, y_2) = (i, (j+1)\\pmod{10})$ 和 $(x_2, y_1) = (j, (i+1)\\pmod{10})$ 的值也必须为 $ADJ=1$。\n我们来检查这个条件。\n$ADJ(i, (j+1)\\pmod{10}) = 1$ 意味着 $(j+1) \\equiv i \\pm 1 \\pmod{10}$。\n这给出了两种可能性：\n1a) $j+1 \\equiv i+1 \\pmod{10} \\implies j \\equiv i \\pmod{10}$。这是不可能的，因为我们选择了不同的对，$i \\ne j$。\n1b) $j+1 \\equiv i-1 \\pmod{10} \\implies j \\equiv i-2 \\pmod{10}$。\n\n$ADJ(j, (i+1)\\pmod{10}) = 1$ 意味着 $(i+1) \\equiv j \\pm 1 \\pmod{10}$。\n这给出了两种可能性：\n2a) $i+1 \\equiv j+1 \\pmod{10} \\implies i \\equiv j \\pmod{10}$。同样不可能。\n2b) $i+1 \\equiv j-1 \\pmod{10} \\implies i \\equiv j-2 \\pmod{10}$。\n\n所以，为了使两个交叉对的输出都为1，我们必须同时满足 $j \\equiv i-2 \\pmod{10}$ 和 $i \\equiv j-2 \\pmod{10}$。\n将第一个同余式代入第二个得到：\n$i \\equiv (i-2) - 2 \\pmod{10}$\n$i \\equiv i-4 \\pmod{10}$\n$0 \\equiv -4 \\pmod{10}$，这意味着 $4 \\equiv 0 \\pmod{10}$。\n这是错误的，因为10不能整除4。\n\n这个矛盾表明，对于我们集合 $S$ 中的任意两个不同对，它们不可能属于同一个值为1的单色矩形。因此，任何正确的协议都必须为 $S$ 中的10个对中的每一个产生一个唯一的通信记录。\n为了有至少10个不同的记录，交换的比特数 $k$ 必须满足 $2^k \\ge 10$。\n满足此不等式的最小整数 $k$ 是 $k=4$，因为 $2^3=8 < 10$ 且 $2^4=16 \\ge 10$。\n这就确定了一个下界：最小比特数至少为4。\n\n由于我们已经找到了一个4比特的上界和一个4比特的下界，因此所需的最小比特数恰好是4。\n与给出的选项比较：\nA. 3 - 不正确，小于下界。\nB. 4 - 正确。\nC. 5 - 不正确，对于一个简单协议来说，这是一个有效的比特数，但不是最小值。\nD. 10 - 不正确。\n\n最小比特数是4。", "answer": "$$\\boxed{B}$$", "id": "1421116"}, {"introduction": "优秀的计算机科学家善于透过现象看本质。这个练习 [@problem_id:1421146] 旨在培养这种抽象思维能力，它描述了一个关于分布式传感器数据同步的实际场景。你的任务是揭示这个特定问题的核心，并将其归约为一个更基本、更具普适性的通信问题——判断两个数是否相等（$EQUALITY$）。这个过程将展示如何通过抽象来简化问题，并应用已知的复杂度结论。", "problem": "有两个分布式传感器，我们称之为 Alice 和 Bob，它们正在监测某个环境参数。在一个小时的时间段内，每个传感器进行 $n=1000$ 次独立的二进制测量，从而每个传感器都得到一个 $n$ 位长的字符串。设 $x$ 是 Alice 持有的字符串，$y$ 是 Bob 持有的字符串。测量结果中的 '1' 表示发生了感兴趣的事件，'0' 表示没有事件发生。\n\n为确保他们的计数机制是同步的，他们需要确定他们是否检测到了相同总数的事件。他们想要计算函数 $f(x, y)$，其定义为：如果字符串 $x$ 中 '1' 的数量等于字符串 $y$ 中 '1' 的数量，则函数值为 $1$，否则为 $0$。\n\nAlice 和 Bob 可以通过一个信道交换比特来进行通信。一个确定性协议是他们为交换消息而遵循的一套预定义规则。对于给定的输入对 $(x, y)$，一旦至少有一方知道了 $f(x,y)$ 的正确值，就认为该协议已经计算出了该函数。一个协议对于特定输入对 $(x, y)$ 的成本是交换的总比特数。函数 $f$ 的确定性通信复杂度是在最坏情况输入对 $(x, y)$ 下，由最高效的协议所能达到的最低可能成本。\n\n对于这个同步检查函数 $f$ 且 $n=1000$ 的情况，其确切的确定性通信复杂度是多少？请用一个整数作为你的答案。", "solution": "令 $n$ 为字符串长度，并定义汉明权重 $a=|x|$ 和 $b=|y|$。那么 $a,b \\in \\{0,1,\\dots,n\\}$，所以每个值都有 $m=n+1$ 种可能性。该函数为\n$$\nf(x,y)=1 \\;\\;\\Longleftrightarrow\\;\\; a=b.\n$$\n因此，问题简化为在大小为 $m$ 的域上计算相等性。\n\n上界：Alice 可以在本地计算 $a$，并使用\n$$\nL=\\lceil \\log_{2} m \\rceil=\\lceil \\log_{2} (n+1) \\rceil\n$$\n比特将其二进制编码发送给 Bob，这足以唯一地标识 $m$ 种可能性中的一种。Bob 在本地计算 $b$，当且仅当接收到的值等于 $b$ 时输出 $1$。因此，存在一个最坏情况成本为 $L=\\lceil \\log_{2} (n+1) \\rceil$ 比特的确定性协议。\n\n下界：考虑集合\n$$\nS=\\{(i,i): i\\in\\{0,1,\\dots,n\\}\\},\n$$\n其大小为 $|S|=m=n+1$。对于任意不同的 $(i,i),(j,j)\\in S$ 且 $i\\neq j$，我们有 $f(i,i)=1$ 和 $f(i,j)=f(j,i)=0$，所以 $S$ 是一个 1-欺骗集。根据欺骗集下界，确定性通信复杂度 $D(f)$ 满足\n$$\nD(f)\\geq \\log_{2} |S|=\\log_{2} (n+1).\n$$\n由于 $D(f)$ 是一个整数，这意味着\n$$\nD(f)\\geq \\lceil \\log_{2} (n+1) \\rceil.\n$$\n结合上界和下界，我们得到确切值\n$$\nD(f)=\\lceil \\log_{2} (n+1) \\rceil.\n$$\n对于 $n=1000$，我们有 $m=1001$ 且 $2^{9}=512<1001\\leq 1024=2^{10}$，因此\n$$\nD(f)=\\lceil \\log_{2} 1001 \\rceil=10.\n$$", "answer": "$$\\boxed{10}$$", "id": "1421146"}, {"introduction": "掌握一个证明技巧的最好方法就是去构造它。前面的练习向我们展示了如何应用“愚弄集”方法，而本练习 [@problem_id:1421154] 则更进一步，要求你直接为给定的函数构建一个尽可能大的愚弄集。这个挑战将迫使你深入理解愚弄集的定义和性质，从根本上理解它为何能成为证明通信下界的有力工具。", "problem": "两个分离的计算代理，Alice 和 Bob，需要合作完成一项计算任务。Alice 收到一个长度为 $n$ 的位串 $x = x_1x_2...x_n$，Bob 收到一个同样长度为 $n$ 的位串 $y = y_1y_2...y_n$。他们的目标是确定 $y$ 是否为 $x$ 的逐位取反。位串的逐位取反是通过翻转其所有位（将 0 变为 1，将 1 变为 0）得到的。形式上，他们想要计算一个函数 $f(x, y)$，当对于所有从 1 到 $n$ 的 $i$ 都有 $y_i = 1 - x_i$ 时，该函数值为 1，否则为 0。\n\n为了分析这个问题的“难度”，我们有兴趣构造一种特殊的集合。考虑一个输入对集合 $S = \\{(x_1, y_1), (x_2, y_2), \\dots, (x_k, y_k)\\}$。如果该集合满足以下两个标准，则称其为“区分集”：\n\n1.  **成功标准：** 对于集合 $S$ 中的每一对 $(x_i, y_i)$，函数值必须为 1。即，对于所有的 $i=1, \\dots, k$，有 $f(x_i, y_i) = 1$。\n2.  **愚弄标准：** 对于集合 $S$ 中任意两个*不同*的对 $(x_i, y_i)$ 和 $(x_j, y_j)$（其中 $i \\neq j$），“交叉”对 $(x_i, y_j)$ 的函数值必须为 0。即，$f(x_i, y_j) = 0$。\n\n你的任务是确定这样一个区分集 $S$ 的最大可能大小 $k$。请用 $n$ 的函数表示你的答案。", "solution": "令 $f:\\{0,1\\}^{n}\\times\\{0,1\\}^{n}\\to\\{0,1\\}$ 定义为：$f(x,y)=1$ 当且仅当 $y$ 是 $x$ 的逐位取反，即 $y=\\overline{x}$，其中对于所有的 $i\\in\\{1,\\dots,n\\}$，有 $(\\overline{x})_{i}=1-x_{i}$。\n\n下界（显式构造）：\n考虑集合\n$$\nS^{\\ast}=\\{(x,\\overline{x}) : x\\in\\{0,1\\}^{n}\\}.\n$$\n成功标准：对于每个 $(x,\\overline{x})\\in S^{\\ast}$，根据定义有 $f(x,\\overline{x})=1$。\n愚弄标准：取 $S^{\\ast}$ 中任意两个不同的对 $(x,\\overline{x})$ 和 $(x',\\overline{x'})$，其中 $x\\neq x'$。那么\n$$\nf(x,\\overline{x'})=1 \\iff \\overline{x'}=\\overline{x} \\iff x'=x,\n$$\n因为 $x\\neq x'$，所以该命题为假。因此 $f(x,\\overline{x'})=0$。所以 $S^{\\ast}$ 是一个大小为 $|S^{\\ast}|=2^{n}$ 的区分集，得出 $k\\geq 2^{n}$。\n\n上界（必要性）：\n令 $S=\\{(x_{i},y_{i})\\}_{i=1}^{k}$ 为任意区分集。根据成功标准，对于每个 $i$，我们必须有 $y_{i}=\\overline{x_{i}}$。因此，映射 $(x_{i},y_{i})\\mapsto x_{i}$ 在 $S$ 上是单射的，因为如果 $x_{i}=x_{j}$，则 $y_{i}=\\overline{x_{i}}=\\overline{x_{j}}=y_{j}$，这意味着 $(x_{i},y_{i})=(x_{j},y_{j})$，这与 $i\\neq j$ 时对的相异性相矛盾。由于总共有 $2^{n}$ 个可能的 $x\\in\\{0,1\\}^{n}$，因此可得 $k\\leq 2^{n}$。\n\n结合下界和上界，得出最大可能的大小\n$$\nk_{\\max}=2^{n}.\n$$", "answer": "$$\\boxed{2^{n}}$$", "id": "1421154"}]}