{"hands_on_practices": [{"introduction": "描述复杂性的第一步是学习如何将结构属性转化为逻辑语言。本练习聚焦于使用一阶逻辑（FO）为一种特定的图结构——“星形图”——提供一个完整而精确的定义。通过构建一个既不过于宽泛也不过于严格的公式，你将体会到逻辑双条件（$\\leftrightarrow$）在同时捕捉必要和充分条件时的强大作用，这是用逻辑框架描述任何计算问题的基础技能。[@problem_id:1420782]", "problem": "在描述复杂性领域，我们研究定义结构性质所需的逻辑资源。考虑使用一阶逻辑语言描述的图。所有顶点的集合 $V$ 作为该逻辑的论域。该语言包含一个单一的二元关系符号 $E$，其中 $E(u,v)$ 为真当且仅当顶点 $u$ 和 $v$ 之间有一条边连接。关系 $E$ 是对称的，即 $E(u,v)$ 成立当且仅当 $E(v,u)$ 成立。标准的等号 $=$ 也是该语言的一部分。\n\n一个非空图被称为**星形图**（star graph），如果它具有一个独特的结构属性：存在一个特殊的顶点，称为中心点，使得：\n1. 每个非中心点的顶点都与中心点有一条边相连。\n2. 图中没有其他边。具体来说，这意味着：\n    a. 如果两个顶点都不是中心点，则它们之间没有边相连。\n    b. 中心点不与自身相连（实际上，没有任何顶点与自身相连）。\n\n下列哪个一阶句子正确且完整地表达了图是星形图这一性质？\n\nA. $\\exists c \\forall u \\forall v (E(u,v) \\rightarrow ((u=c \\land v \\neq c) \\lor (v=c \\land u \\neq c)))$\nB. $\\exists c \\forall u \\forall v (((u=c \\land v \\neq c) \\lor (v=c \\land u \\neq c)) \\rightarrow E(u,v))$\nC. $\\exists c \\forall u \\forall v (E(u,v) \\leftrightarrow (u=c \\lor v=c))$\nD. $\\exists c \\forall u \\forall v (E(u,v) \\leftrightarrow ((u=c \\land v \\neq c) \\lor (v=c \\land u \\neq c)))$", "solution": "要解决这个问题，我们必须将星形图的英文定义翻译成一个精确的一阶逻辑句子。让我们逐条分析该定义，然后评估给出的每个选项。\n\n星形图的定义有两个主要条件，适用于至少有一个顶点的图，这一点在一阶逻辑的非空论域语义中是隐含的。\n\n首先，“存在一个特殊的顶点，称为中心点...”。这可以翻译成对这个中心点（我们称之为 $c$）的存在量词：\n$\\exists c (\\dots)$\n\n现在，让我们形式化地表述中心点 $c$ 必须满足的两个条件。\n\n条件1：“每个非中心点的顶点都与中心点有一条边相连。”\n这可以写成：对于任意顶点 $v$，如果 $v$ 不等于 $c$，那么 $c$ 和 $v$ 之间存在一条边。\n用形式逻辑表示为：$\\forall v (v \\neq c \\rightarrow E(c,v))$。\n\n条件2：“图中没有其他边。”在问题描述中，这被分解为两个子条件。\n2a：“如果两个顶点都不是中心点，则它们之间没有边相连。”\n这意味着对于任意两个顶点 $u$ 和 $v$，如果它们都不是中心点，则它们之间没有边。由于在一个简单的星形图中，边连接的是不同的顶点，我们应该考虑不同的 $u$ 和 $v$。\n用形式逻辑表示为：$\\forall u \\forall v ((u \\neq c \\land v \\neq c \\land u \\neq v) \\rightarrow \\neg E(u,v))$。\n2b：“中心点不与自身相连（实际上，没有任何顶点与自身相连）。”\n这意味着没有自环。\n用形式逻辑表示为：$\\forall x (\\neg E(x,x))$。\n\n将所有这些条件结合起来，我们得到一个冗长但正确的公式：\n$\\exists c (\\forall v (v \\neq c \\rightarrow E(c,v)) \\land \\forall u \\forall v ((u \\neq c \\land v \\neq c \\land u \\neq v) \\rightarrow \\neg E(u,v)) \\land \\forall x (\\neg E(x,x)))$。\n\n一个更简洁的方式来同时表达条件1和2是：一条边 $E(u,v)$ 存在*当且仅当*其中一个顶点是中心点 $c$，而另一个是不同的非中心点顶点。让我们分析这个形式为 $P \\leftrightarrow Q$ 的双条件语句。它等价于 $(P \\rightarrow Q) \\land (Q \\rightarrow P)$。\n\n该论述为：一条边 $E(u,v)$ 存在，当且仅当一个顶点是 $c$ 而另一个不是 $c$。这可以写成：\n$E(u,v) \\leftrightarrow ((u=c \\land v \\neq c) \\lor (v=c \\land u \\neq c))$。\n\n让我们看看在 $\\exists c \\forall u \\forall v$ 作用下，这个单一的语句是否能捕捉到完整的定义。\n\n“如果”部分($\\leftarrow$)：$((u=c \\land v \\neq c) \\lor (v=c \\land u \\neq c)) \\rightarrow E(u,v)$。\n这表示对于任意不为 $c$ 的顶点 $v$（令 $u=c$），必须存在一条边 $E(c,v)$。这正是条件1。\n\n“仅当”部分($\\rightarrow$)：$E(u,v) \\rightarrow ((u=c \\land v \\neq c) \\lor (v=c \\land u \\neq c))$。\n这表示要使一条边 $E(u,v)$ 存在，其必要条件是其中一个端点是 $c$ 而另一个不是。让我们看看这禁止了哪些情况：\n- 两个非中心点顶点 $u$ 和 $v$ 之间能有边吗？如果 $u \\neq c$ 和 $v \\neq c$，蕴含式的右侧为假。为了使蕴含式为真，其左侧 $E(u,v)$ 也必须为假。这涵盖了条件2a。\n- 中心点上能有自环 $E(c,c)$ 吗？令 $u=c$ 和 $v=c$。右侧是 $((c=c \\land c \\neq c) \\lor (c=c \\land c \\neq c))$，其值为假。因此，$E(c,c)$ 必须为假。这涵盖了条件2b的主要部分。\n- 非中心点顶点 $v$ 上能有自环吗？令 $u=v$ 且 $u \\neq c$。右侧是 $((u=c \\land u \\neq c) \\lor (u=c \\land u \\neq c))$，其值为假。因此，$E(u,u)$ 必须为假。这涵盖了条件2b的其余部分。\n\n所以，句子 $\\exists c \\forall u \\forall v (E(u,v) \\leftrightarrow ((u=c \\land v \\neq c) \\lor (v=c \\land u \\neq c)))$ 正确且完整地定义了星形图。这对应于选项D。\n\n现在让我们来审查为什么其他选项不正确。\n\nA. $\\exists c \\forall u \\forall v (E(u,v) \\rightarrow ((u=c \\land v \\neq c) \\lor (v=c \\land u \\neq c)))$\n这只是正确的双条件语句中的“仅当”部分。它陈述了*如果*存在一条边，它必须连接中心点和一个非中心点顶点。它没有强制要求任何边*必须*存在。例如，一个包含三个顶点 $\\{c, a, b\\}$ 且只有一条边 $E(c,a)$ 的图满足这个公式，但它不是一个星形图，因为顶点 $b$ 没有连接到中心点 $c$。\n\nB. $\\exists c \\forall u \\forall v (((u=c \\land v \\neq c) \\lor (v=c \\land u \\neq c)) \\rightarrow E(u,v))$\n这只是正确的双条件语句中的“如果”部分。它要求中心点 $c$ 连接到所有其他顶点。但是，它不禁止其他边的存在。例如，一个有3个或更多顶点的完全图 $K_n$，对于任意选择的 $c$ 都满足这个公式。任何顶点 $c$ 都连接到所有其他顶点。但当 $n \\ge 3$ 时，$K_n$ 不是一个星形图，因为非中心点顶点之间存在边。\n\nC. $\\exists c \\forall u \\forall v (E(u,v) \\leftrightarrow (u=c \\lor v=c))$\n这个公式陈述了 $u$ 和 $v$ 之间存在一条边，当且仅当它们中至少有一个是中心点 $c$。让我们在 $u=c$ 和 $v=c$ 的情况下测试它。右侧 $(c=c \\lor c=c)$ 为真。因此，为了使双条件成立，左侧 $E(c,c)$ 也必须为真。这意味着该公式要求中心点上存在自环，这违反了星形图（以及通常的简单图）的定义。\n\n因此，选项D是唯一一个捕捉了图成为星形图的所有充要条件的选项。", "answer": "$$\\boxed{D}$$", "id": "1420782"}, {"introduction": "在我们学习了如何用一阶逻辑表达属性之后，一个自然的问题是：一阶逻辑的表达能力有何局限？Ehrenfeucht-Fraïssé（EF）博弈是证明某些属性无法用一阶逻辑表达的主要工具。这个练习邀请你在EF博弈中扮演“破坏者”（Spoiler）的角色，目标是在两个图之间找到一个结构上的差异。通过设计一个必胜策略，你将直观地理解为何像连通性这样的属性超出了FO的表达范围，并学会如何形式化地证明一种逻辑的描述能力局限。[@problem_id:1420779]", "problem": "考虑两个简单无向图 $G_1$ 和 $G_2$。\n第一个图 $G_1$ 是一个路径图，其顶点集为 $V_1 = \\{p_1, p_2, p_3\\}$，边集为 $E_1 = \\{\\{p_1, p_2\\}, \\{p_2, p_3\\}\\}$。\n第二个图 $G_2$ 是一个圈图，其顶点集为 $V_2 = \\{c_1, c_2, c_3\\}$，边集为 $E_2 = \\{\\{c_1, c_2\\}, \\{c_2, c_3\\}, \\{c_3, c_1\\}\\}$。\n\n在这两个图上，由两名玩家——破坏者（Spoiler）和模仿者（Duplicator）——进行一场 Ehrenfeucht-Fraïssé（EF）博弈。我们将考虑一场2轮的博弈。\n博弈规则如下：\n- 博弈分两轮进行。\n- 在每一轮 $i$（$i=1, 2$），破坏者从 $G_1$ 或 $G_2$ 中选择一个顶点。\n- 模仿者必须在另一个图（破坏者未选择的那个图）中选择一个顶点作为回应。\n- 设两轮后从 $G_1$ 中选出的顶点为 $v_1, v_2 \\in V_1$，从 $G_2$ 中选出的相应顶点为 $u_1, u_2 \\in V_2$。\n\n如果所选顶点之间的映射保持了图的结构，则模仿者获胜。也就是说，对于 $G_1$ 中任意一对被选中的顶点，它们之间有边相连当且仅当它们在 $G_2$ 中对应的顶点之间也有边相连。如果在博弈结束时这个条件不成立，则破坏者获胜。\n\n破坏者的目标是选择顶点，使得模仿者无法维持这种结构上的对应关系。在这次的2轮博弈中，无论模仿者如何回应，破坏者的下列哪种第一轮走法能保证其获胜？\n\nA. 破坏者在图 $G_1$ 中选择顶点 $p_2$。\nB. 破坏者在图 $G_2$ 中选择顶点 $c_2$。\nC. 破坏者在图 $G_1$ 中选择顶点 $p_1$。\nD. 在2轮博弈中，模仿者有必胜策略，因此破坏者没有任何第一轮走法能保证获胜。", "solution": "我们分析在 $G_1$（一个三顶点的路径图）和 $G_2$（一个3-圈图）之间的2轮 Ehrenfeucht-Fraïssé 博弈。在标准的图上 EF 博弈中，模仿者必须在已选顶点之间维持一个局部同构，这要求同时保持相等关系和邻接关系。形式上，如果两轮过后，破坏者选择了 $v_1, v_2 \\in V_1$，模仿者选择了 $u_1, u_2 \\in V_2$，那么模仿者获胜的条件是：对于所有 $i,j \\in \\{1,2\\}$，$v_i=v_j \\iff u_i=u_j$, 且 $E_1(v_i,v_j) \\iff E_2(u_i,u_j)$.\n\n图的关键属性：\n- 在 $G_1$ 中，$p_2$ 的度为2，$p_1, p_3$ 的度为1，且 $E_1(p_1, p_3)$ 为假。\n- 在 $G_2$ 中，任意一对不同的顶点都是相邻的，因此对于不同的 $x,y \\in V_2$，$E_2(x,y)$ 为真。\n\n我们逐一检查每个提议的第一步走法。\n\nA. 破坏者在 $G_1$ 中选择 $p_2$。模仿者用 $V_2$ 中的任意一个顶点 $c$ 回应。在第二步中，任何选择 $v_2 \\in V_1 \\setminus \\{p_2\\}$ 都满足 $E_1(p_2,v_2)$ 为真。模仿者可以选择 $u_2 \\in V_2 \\setminus \\{c\\}$，此时 $E_2(c,u_2)$ 也为真，从而同时保持了顶点的不等关系和邻接关系。在两轮内无法强制造成违规，所以这一第一步走法不能保证破坏者获胜。\n\nB. 破坏者在 $G_2$ 中选择 $c_2$。模仿者可以用 $G_1$ 中的 $p_2$ 回应。然后，在第二轮走棋中，若破坏者选择一个与第一个不同的顶点，则 $G_2$ 中的 $c_2$ 和 $G_1$ 中的 $p_2$ 都与各自图中的所有其他顶点相邻。模仿者可以在回应中匹配邻接性和不等关系，因此破坏者无法在两轮内强制造成违规。所以这一第一步走法不能保证获胜。\n\nC. 破坏者在 $G_1$ 中选择 $p_1$。设模仿者用 $V_2$ 中的任意一个顶点 $u_1$ 回应。破坏者接着在 $G_1$ 中选择 $v_2=p_3 \\neq p_1$，此时 $E_1(p_1, p_3)$ 为假。为了同时满足两个条件，模仿者必须在 $V_2$ 中选择一个顶点 $u_2$，满足 $u_2 \\neq u_1$ 且 $E_2(u_1,u_2)$ 为假。然而，在 $G_2$ 中任意一对不同的顶点都是相邻的，所以这样的 $u_2$ 不存在。如果模仿者为了让 $E_2(u_1,u_2)$ 为假而选择 $u_2=u_1$，那么相等关系就无法保持，因为 $v_2 \\neq v_1$ 但 $u_2=u_1$。因此，模仿者无法维持局部同构，破坏者获胜。所以这一第一步走法保证了破坏者的胜利。\n\nD. 这个选项是错误的，因为选项 C 是一个能让破坏者获胜的第一步走法。\n\n因此，正确选项是 C。", "answer": "$$\\boxed{C}$$", "id": "1420779"}, {"introduction": "我们已经看到，一阶逻辑无法表达涉及任意长度路径的属性，例如可达性。为了捕捉更复杂的计算问题，我们需要为逻辑语言增加递归的能力。本练习将介绍Datalog，一种体现了不动点逻辑思想的查询语言。你的任务是编写一个简单的程序来识别网络中所有属于环的节点，这是一个需要计算传递闭包的经典问题。这个实践连接了逻辑与算法，展示了递归的逻辑定义如何被执行以解决真实的图问题，并为理解像LFP（最小不动点逻辑）这样能够刻画重要复杂性类（如PTIME）的更强大逻辑奠定了基础。[@problem_id:1420810]", "problem": "在计算机网络的分析中，通常需要识别循环依赖。考虑一个表示网络的有向图，其中节点是服务器，边表示单向数据链路。该网络的结构由一个谓词 `Edge(u, v)` 描述，当且仅当存在从服务器 `u` 到服务器 `v` 的直接数据链路时，该谓词为真。\n\n如果一个服务器存在一条或多条链路组成的路径，从该服务器出发并最终返回到自身，那么该服务器就被认为是“反馈回路”或环的一部分。您的任务是找出正确的 Datalog 程序，该程序定义一个新的谓词 `InCycle(x)`，对于属于至少一个环的每个服务器 `x`，该谓词为真。\n\n在 Datalog 语法中，`:-` 表示逻辑蕴含（读作“如果”），逗号表示逻辑与，变量由大写字母表示（例如 `X`、`Y`、`Z`）。\n\n下列哪个 Datalog 程序能正确识别所有属于环的服务器？\n\nA.\n`Reaches(X, Y) :- Edge(X, Y).`\n`Reaches(X, Z) :- Reaches(X, Y), Edge(Y, Z).`\n`InCycle(X) :- Reaches(X, X).`\n\nB.\n`InCycle(X) :- Edge(X, X).`\n\nC.\n`Reaches(X, Y) :- Edge(X, Y).`\n`InCycle(X) :- Reaches(X, Y), Reaches(Y, X).`\n\nD.\n`InCycle(X) :- Edge(X, Y), InCycle(Y).`\n\nE.\n`Reaches(X, Y) :- Edge(X, Y).`\n`Reaches(X, Z) :- Reaches(X, Y), Edge(Y, Z).`\n`InCycle(X) :- Reaches(Y, X).`", "solution": "问题要求编写一个 Datalog 程序来查找有向图中所有属于环的节点。如果一个节点 `X` 存在一条长度为一或更长的路径从 `X` 回到其自身，那么它就处于一个环中。让我们分析所需的逻辑，然后评估每个选项。\n\n**环检测的核心逻辑**\n\n1.  **定义可达性：** 首先，我们需要定义任意两个节点之间路径或“可达性”的概念。让我们创建一个谓词 `Reaches(A, B)`，如果存在一条从节点 `A` 到节点 `B` 的长度至少为一的路径，则该谓词为真。这是一个经典的传递闭包问题。\n2.  **基本情况：** 如果 `X` 和 `Y` 之间存在一条直接边，则存在一条长度为一的路径。在 Datalog 中，这表示为：\n    `Reaches(X, Y) :- Edge(X, Y).`\n3.  **递归步骤：** 如果存在一条从 `X`到某个中间节点`Y`的路径，并且存在一条从`Y`到`Z`的直接边，那么就存在一条从`X`到`Z`的路径。这允许我们将现有路径延长一条边。在 Datalog 中，这表示为：\n    `Reaches(X, Z) :- Reaches(X, Y), Edge(Y, Z).`\n    这两条规则共同正确地计算了 `Edge` 关系的传递闭包，意味着对于所有 `B` 可从 `A` 到达的节点对 `(A, B)`，`Reaches(A, B)` 将为真。\n4.  **定义环成员：** 在正确定义了 `Reaches` 谓词之后，如果一个节点 `X` 可以到达它自己，那么它就在一个环中。这是对我们的 `Reaches` 谓词的一个简单查询：\n    `InCycle(X) :- Reaches(X, X).`\n\n将这些步骤结合起来，我们就得到了完整的程序。现在让我们基于这个逻辑来分析给定的选项。\n\n**选项分析**\n\n*   **选项 A：**\n    `Reaches(X, Y) :- Edge(X, Y).`\n    `Reaches(X, Z) :- Reaches(X, Y), Edge(Y, Z).`\n    `InCycle(X) :- Reaches(X, X).`\n    这个程序与上面推导出的逻辑完全匹配。前两条规则计算可达性关系（传递闭包），第三条规则正确地将一个节点识别为在环中，如果它可以到达自身。这个程序是正确的。\n\n*   **选项 B：**\n    `InCycle(X) :- Edge(X, X).`\n    这个程序只识别那些有自环（从节点到自身的边）的节点。这对应于长度为 1 的环。它无法找到属于更长环（例如 $A \\to B \\to A$）的节点。因此，它是不正确的。\n\n*   **选项 C：**\n    `Reaches(X, Y) :- Edge(X, Y).`\n    `InCycle(X) :- Reaches(X, Y), Reaches(Y, X).`\n    这个程序是有缺陷的，因为 `Reaches` 谓词没有被递归定义。关于 `Reaches` 的唯一规则是 `Reaches(X, Y) :- Edge(X, Y)`，这意味着 `Reaches` 与 `Edge` 是相同的。将此代入 `InCycle` 规则，得到 `InCycle(X) :- Edge(X, Y), Edge(Y, X)`。这个程序只查找属于长度恰好为 2 的环的节点。它会漏掉长度为 1 和长度为 3 或更长的环。因此，它是不正确的。\n\n*   **选项 D：**\n    `InCycle(X) :- Edge(X, Y), InCycle(Y).`\n    这是一个格式不正确的递归规则。Datalog 求值的工作方式是从已知事实（`Edge` 谓词）开始，并推导出新的事实。这条 `InCycle` 的规则要求右侧有一个 `InCycle` 事实，才能在左侧推导出一个新的 `InCycle` 事实。由于没有“基本情况”规则可以仅从 `Edge` 事实中产生第一个 `InCycle` 事实，这个程序将永远不会为 `InCycle` 产生任何输出。因此，它是不正确的。\n\n*   **选项 E：**\n    `Reaches(X, Y) :- Edge(X, Y).`\n    `Reaches(X, Z) :- Reaches(X, Y), Edge(Y, Z).`\n    `InCycle(X) :- Reaches(Y, X).`\n    `Reaches` 谓词定义正确。然而，`InCycle` 的规则在逻辑上是有缺陷的。`InCycle(X) :- Reaches(Y, X)` 表明，如果*任何*节点 `Y` 可以到达节点 `X`，那么 `X` 就在一个环中。在一个典型的连通图中，这几乎会将每个节点都标记为在环中，但这并不是属于环的定义。要让一个节点 `X` 在环中，它必须能够到达*它自己*。这个规则没有强制执行这个条件。因此，它是不正确的。\n\n根据分析，选项 A 是唯一一个正确定义了可达性，然后用它来识别可以到达自身的节点的程序。", "answer": "$$\\boxed{A}$$", "id": "1420810"}]}