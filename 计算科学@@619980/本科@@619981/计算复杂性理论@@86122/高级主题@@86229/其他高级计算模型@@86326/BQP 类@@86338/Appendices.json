{"hands_on_practices": [{"introduction": "为了真正掌握BQP的内涵，我们需要将抽象的定义与具体的计算场景联系起来。这个练习通过一个假设的2-量子比特系统，探索了BQP（有界错误量子多项式时间）的概率界限在物理上的意义。你将计算一个量子门中的参数需要有多大的变化，才能可靠地区分“是”与“否”两种情况，同时满足BQP对错误率的要求。这个实践旨在帮助你建立起理论定义与量子系统物理行为之间的直觉联系。[@problem_id:1451244]", "problem": "一个量子计算设备被用来区分关于一个物理系统的两种假设，标记为‘是’和‘否’。‘是’的情况对应于系统参数为 $\\theta_Y$，‘否’的情况对应于参数为 $\\theta_N$。该设备在一个2量子比特寄存器上运行，执行以下算法：\n1. 将寄存器初始化到状态 $|\\psi_{in}\\rangle = |00\\rangle$。\n2. 应用一个幺正变换 $U(\\theta)$，其中 $\\theta$ 是 $\\theta_Y$ 或 $\\theta_N$。在计算基 $\\{|00\\rangle, |01\\rangle, |10\\rangle, |11\\rangle\\}$ 中，$U(\\theta)$ 的矩阵由下式给出：\n$$ U(\\theta) = \\begin{pmatrix} \\cos\\theta & 0 & \\sin\\theta & 0 \\\\ 0 & 1 & 0 & 0 \\\\ -\\sin\\theta & 0 & \\cos\\theta & 0 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix} $$\n3. 在计算基中测量第一个量子比特。如果结果是‘1’，算法输出‘是’。否则，输出‘否’。\n\n如果对于‘是’实例，输出‘是’的概率至少为 $2/3$，而对于‘否’实例，该概率至多为 $1/3$，那么这个过程被认为是复杂度类有界错误量子多项式时间 (Bounded-error Quantum Polynomial time, BQP) 中一个问题的有效算法。\n\n已知 $\\theta_Y$ 和 $\\theta_N$ 都在范围 $[0, \\pi/2]$ 内，确定差值 $\\theta_Y - \\theta_N$ 的最小可能值。将你的答案表示为一个以弧度为单位的闭式解析表达式。", "solution": "输入状态是 $|\\psi_{in}\\rangle=|00\\rangle$。将 $U(\\theta)$ 应用于 $|00\\rangle$ 的结果可以从给定矩阵的第一列读出：\n$$\nU(\\theta)|00\\rangle=\\cos\\theta\\,|00\\rangle-\\sin\\theta\\,|10\\rangle.\n$$\n在计算基中测量第一个量子比特时，如果幺正变换后的状态包含 $|10\\rangle$ 或 $|11\\rangle$ 分量，则测量结果为 1。从上述状态可知，第一个量子比特为 1 的唯一分量是 $|10\\rangle$，其振幅为 $-\\sin\\theta$，并且没有 $|11\\rangle$ 分量。因此，接受概率（输出‘是’）作为 $\\theta$ 的函数是\n$$\np(\\theta)=\\sin^{2}\\theta.\n$$\n\n对于一个有效的 BQP 过程，我们需要对于‘是’实例有 $p(\\theta_{Y})\\geq \\frac{2}{3}$，对于‘否’实例有 $p(\\theta_{N})\\leq \\frac{1}{3}$。由于 $\\theta\\in[0,\\pi/2]$，函数 $\\sin^{2}\\theta$ 是单调不减的，因为其导数 $\\sin 2\\theta$ 在 $[0,\\pi/2]$ 上 $\\geq 0$。因此，为了在这些约束下最小化差值 $\\theta_{Y}-\\theta_{N}$，我们令约束取等号：\n$$\n\\sin^{2}\\theta_{Y}=\\frac{2}{3},\\qquad \\sin^{2}\\theta_{N}=\\frac{1}{3}.\n$$\n因为 $\\theta\\in[0,\\pi/2]$ 意味着 $\\sin\\theta\\geq 0$，我们得到\n$$\n\\theta_{Y}=\\arcsin\\!\\left(\\sqrt{\\frac{2}{3}}\\right),\\qquad \\theta_{N}=\\arcsin\\!\\left(\\sqrt{\\frac{1}{3}}\\right),\n$$\n所以最小差值为\n$$\n\\Delta\\theta_{\\min}=\\arcsin\\!\\left(\\sqrt{\\frac{2}{3}}\\right)-\\arcsin\\!\\left(\\sqrt{\\frac{1}{3}}\\right).\n$$\n使用对于 $a,b\\in[0,1]$ 的恒等式，\n$$\n\\arcsin a-\\arcsin b=\\arcsin\\!\\left(a\\sqrt{1-b^{2}}-b\\sqrt{1-a^{2}}\\right),\n$$\n并代入 $a=\\sqrt{\\frac{2}{3}}$ 和 $b=\\sqrt{\\frac{1}{3}}$，我们得到\n$$\n\\Delta\\theta_{\\min}=\\arcsin\\!\\left(\\sqrt{\\frac{2}{3}}\\sqrt{1-\\frac{1}{3}}-\\sqrt{\\frac{1}{3}}\\sqrt{1-\\frac{2}{3}}\\right)\n=\\arcsin\\!\\left(\\frac{2}{3}-\\frac{1}{3}\\right)=\\arcsin\\!\\left(\\frac{1}{3}\\right).\n$$\n因此，$\\theta_{Y}-\\theta_{N}$ 的最小可能值是 $\\arcsin\\!\\left(\\frac{1}{3}\\right)$ 弧度。", "answer": "$$\\boxed{\\arcsin\\!\\left(\\frac{1}{3}\\right)}$$", "id": "1451244"}, {"introduction": "在理解了BQP对成功概率的要求之后，下一步是观察一个实际的BQP算法是如何工作的。本练习将引导你分析著名的Deutsch-Jozsa问题的最简形式，这是一个展示量子计算优势的经典范例。你的任务是仅通过一次“黑箱”查询，就判断一个未知函数是常数函数还是平衡函数。通过这个过程，你将亲身体验量子叠加和干涉如何协同作用，从而实现超越经典确定性算法的计算效率。[@problem_id:1451267]", "problem": "你的任务是刻画一个未知的计算模块，该模块可以被建模为一个“黑箱”或“预言机”。该预言机实现了一个单一的、未知的布尔函数 $f: \\{0, 1\\} \\to \\{0, 1\\}$。你得到的承诺是，函数 $f$ 属于两类之一：要么是**常函数**（意味着 $f(0) = f(1)$），要么是**平衡函数**（意味着 $f(0) \\neq f(1)$）。\n\n为了确定该函数的类别，你使用一个简单的量子电路。步骤如下：\n\n1.  将两个量子比特，一个数据量子比特和一个辅助量子比特，初始化到状态 $|\\psi_0\\rangle = |0\\rangle|1\\rangle$。\n2.  对每个量子比特分别施加一个Hadamard门 $H$。\n3.  将由幺正算符 $U_f$ 表示的量子预言机应用于该双量子比特态。预言机的作用由变换 $U_f: |x\\rangle|y\\rangle \\mapsto |x\\rangle|y \\oplus f(x)\\rangle$ 定义，其中 $x, y \\in \\{0, 1\\}$ 并且 $\\oplus$ 表示模2加法。\n4.  仅对数据（第一个）量子比特施加一个Hadamard门。\n5.  在计算基 $\\{|0\\rangle, |1\\rangle\\}$ 中测量数据（第一个）量子比特。\n\n在精确地执行此过程一次后，对数据量子比特的测量得到结果 `1`。根据这个结果，你能对函数 $f$ 的性质得出什么确定性的结论？\n\nA. 函数 $f$ 必须是常函数。\n\nB. 函数 $f$ 必须是平衡函数。\n\nC. 函数 $f$ 可能是常函数也可能是平衡函数。\n\nD. 测量结果 `1` 是不可能的；实验中必定存在错误。\n\nE. 函数 $f$ 必须是恒等函数，$f(x) = x$。", "solution": "我们从两个初始化为 $|\\psi_{0}\\rangle = |0\\rangle|1\\rangle$ 的量子比特开始。对每个量子比特施加一个Hadamard门 $H$ 会得到\n$$\nH|0\\rangle = \\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}}, \\quad H|1\\rangle = \\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}.\n$$\n因此，在第2步之后，状态为\n$$\n|\\psi_{1}\\rangle = \\left(\\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}}\\right) \\otimes \\left(\\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}\\right) = \\frac{1}{\\sqrt{2}}\\left(|0\\rangle + |1\\rangle\\right)\\otimes |-\\rangle,\n$$\n其中 $|-\\rangle = \\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}$。\n\n预言机的作用为 $U_{f}: |x\\rangle|y\\rangle \\mapsto |x\\rangle|y \\oplus f(x)\\rangle$。它对 $|-\\rangle$ 的作用会产生一个相位回踢：\n$$\nU_{f}\\big(|x\\rangle|-\\rangle\\big) = U_{f}\\left(|x\\rangle\\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}\\right) \n= \\frac{1}{\\sqrt{2}}\\left(|x\\rangle|f(x)\\rangle - |x\\rangle|1 \\oplus f(x)\\rangle\\right)\n= (-1)^{f(x)}|x\\rangle|-\\rangle.\n$$\n因此，在施加 $U_{f}$ 后，状态变为\n$$\n|\\psi_{2}\\rangle = \\frac{1}{\\sqrt{2}}\\left((-1)^{f(0)}|0\\rangle + (-1)^{f(1)}|1\\rangle\\right)\\otimes |-\\rangle.\n$$\n\n接下来，仅对第一个（数据）量子比特施加一个Hadamard门。使用 $H|0\\rangle = \\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}}$ 和 $H|1\\rangle = \\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}$，我们得到\n$$\n|\\psi_{3}\\rangle = \\frac{1}{\\sqrt{2}}\\left((-1)^{f(0)}\\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}} + (-1)^{f(1)}\\frac{|0\\rangle - |1\\rangle}{\\sqrt{2}}\\right)\\otimes |-\\rangle\n= \\frac{1}{2}\\left(\\big((-1)^{f(0)} + (-1)^{f(1)}\\big)|0\\rangle + \\big((-1)^{f(0)} - (-1)^{f(1)}\\big)|1\\rangle\\right)\\otimes |-\\rangle.\n$$\n\n对第一个量子比特的测量得到结果 $0$ 的振幅为 $\\frac{1}{2}\\big((-1)^{f(0)} + (-1)^{f(1)}\\big)$，得到结果 $1$ 的振幅为 $\\frac{1}{2}\\big((-1)^{f(0)} - (-1)^{f(1)}\\big)$。由于已知 $f$ 要么是常函数要么是平衡函数：\n- 如果 $f$ 是常函数，那么 $f(0) = f(1)$，所以 $(-1)^{f(0)} = (-1)^{f(1)}$，和为 $\\pm 2$，差为 $0$。因此，第一个量子比特必然是 $|0\\rangle$。\n- 如果 $f$ 是平衡函数，那么 $f(0) \\neq f(1)$，所以 $(-1)^{f(0)} = -(-1)^{f(1)}$，和为 $0$，差为 $\\pm 2$。因此，第一个量子比特必然是 $|1\\rangle$。\n\n鉴于测量结果是 $1$，我们可以确定地得出结论，$f$ 是平衡函数。它不一定是特定的函数 $f(x) = x$，因为 $f(x) = 1 \\oplus x$ 也会得到相同的结果。结果 $1$ 是可能的，并且 $f$ 不是常函数。\n\n因此，正确选项是B。", "answer": "$$\\boxed{B}$$", "id": "1451267"}, {"introduction": "一个计算复杂性类不仅由它能解决的问题来定义，也由其内在的结构特性来刻画。这个练习将探讨BQP的一个关键对称性质：它在补集运算下是闭合的，即 $BQP = coBQP$。通过对一个通用BQP算法进行一个简单的修改——在测量前翻转输出量子比特——你将证明，若一个问题属于BQP，那么其补问题也必然属于BQP。这个优雅的结论揭示了量子计算在处理正反问题时所具有的内在对称性。[@problem_id:1451258]", "problem": "一个量子算法，记作 $\\mathcal{A}$，被设计用于解决一个语言 $L$ 的判定问题。该算法对一个输入字符串 $x$ 进行操作，并通过测量一个指定的输出量子比特来结束。如果测量结果为 1，则输入字符串 $x$ 被视为“接受”；如果结果为 0，则被“拒绝”。\n\n算法 $\\mathcal{A}$ 的性能由两个概率精确描述：\n1.  对于语言 $L$ 中的任意字符串 $x$（即 $x \\in L$），该算法输出 1 的概率恰好为 $p_{yes}$。\n2.  对于不属于语言 $L$ 的任意字符串 $x$（即 $x \\notin L$），该算法输出 1 的概率恰好为 $p_{no}$。\n\n要使语言 $L$ 被认为属于复杂性类别“有界错误量子多项式时间”（BQP），要求其“成功”概率高而“失败”概率低，且两者之间有足够的差距。典型的界限是 $p_{yes} \\ge 2/3$ 和 $p_{no} \\le 1/3$。\n\n现在，构造一个新的量子算法 $\\mathcal{A}'$，用于解决补语言 $\\bar{L}$ 的判定问题，该语言包含所有不属于 $L$ 的字符串。这个新算法 $\\mathcal{A}'$ 与 $\\mathcal{A}$ 在各方面都完全相同，只有一个额外的操作除外：在进行测量之前，立即对输出量子比特应用一个 Pauli-X（非）门。\n\n对于决定语言 $\\bar{L}$ 的新算法 $\\mathcal{A}'$，设 $\\mathcal{A}'$ 对输入字符串 $y \\in \\bar{L}$ 输出 1 的概率记为 $p'_{yes}$。类似地，设 $\\mathcal{A}'$ 对输入字符串 $z \\notin \\bar{L}$ 输出 1 的概率记为 $p'_{no}$。\n\n请用原始概率 $p_{yes}$ 和 $p_{no}$ 表示算法 $\\mathcal{A}'$ 的概率对 $(p'_{yes}, p'_{no})$。", "solution": "我们来分析原始算法 $\\mathcal{A}$ 和新算法 $\\mathcal{A}'$ 输出概率之间的关系。\n\n对于给定的输入字符串 $x$，原始算法 $\\mathcal{A}$ 输出 1 的概率为 $P_{\\mathcal{A}}(1|x)$，输出 0 的概率为 $P_{\\mathcal{A}}(0|x)$。由于只有两种结果，这些概率之和必须为 1。\n$$P_{\\mathcal{A}}(0|x) + P_{\\mathcal{A}}(1|x) = 1$$\n\n新算法 $\\mathcal{A}'$ 是通过获取算法 $\\mathcal{A}$ 并在测量前对输出量子比特应用一个 Pauli-X（非）门来构造的。Pauli-X 门的作用是翻转量子比特的状态：它将 $|0\\rangle$ 转换为 $|1\\rangle$，并将 $|1\\rangle$ 转换为 $|0\\rangle$。\n\n因此，任何在算法 $\\mathcal{A}$ 中会导致测量结果为 1 的计算基态，在算法 $\\mathcal{A}'$ 中现在将导致结果为 0。反之，任何在 $\\mathcal{A}$ 中会导致结果为 0 的状态，在 $\\mathcal{A}'$ 中现在将导致结果为 1。这意味着结果的概率分布被交换了。\n\n因此，算法 $\\mathcal{A}'$ 输出 1 的概率，记作 $P_{\\mathcal{A}'}(1|x)$，等于算法 $\\mathcal{A}$ 输出 0 的概率。\n$$P_{\\mathcal{A}'}(1|x) = P_{\\mathcal{A}}(0|x)$$\n使用第一步中的关系，我们可以用 $\\mathcal{A}$ 输出 1 的概率来表示它：\n$$P_{\\mathcal{A}'}(1|x) = 1 - P_{\\mathcal{A}}(1|x)$$\n\n现在我们可以确定 $p'_{yes}$ 和 $p'_{no}$。\n\n首先，我们来求 $p'_{yes}$。这是 $\\mathcal{A}'$ 对属于补语言 $\\bar{L}$ 的输入字符串 $y$ 输出 1 的概率。根据补语言的定义，如果 $y \\in \\bar{L}$，那么 $y \\notin L$。\n$$p'_{yes} = P_{\\mathcal{A}'}(1|y) \\quad \\text{其中 } y \\in \\bar{L}$$\n使用我们推导出的关系：\n$$p'_{yes} = 1 - P_{\\mathcal{A}}(1|y)$$\n根据问题描述，对于任何不属于 $L$ 的字符串（如 $y$），算法 $\\mathcal{A}$ 输出 1 的概率是 $p_{no}$。所以，$P_{\\mathcal{A}}(1|y) = p_{no}$。\n将其代入，我们得到：\n$$p'_{yes} = 1 - p_{no}$$\n\n接下来，我们来求 $p'_{no}$。这是 $\\mathcal{A}'$ 对不属于补语言 $\\bar{L}$ 的输入字符串 $z$ 输出 1 的概率。如果 $z \\notin \\bar{L}$，这意味着 $z \\in L$。\n$$p'_{no} = P_{\\mathcal{A}'}(1|z) \\quad \\text{其中 } z \\notin \\bar{L}$$\n再次使用我们推导出的关系：\n$$p'_{no} = 1 - P_{\\mathcal{A}}(1|z)$$\n根据问题描述，对于任何属于 $L$ 的字符串（如 $z$），算法 $\\mathcal{A}$ 输出 1 的概率是 $p_{yes}$。所以，$P_{\\mathcal{A}}(1|z) = p_{yes}$。\n将其代入，我们得到：\n$$p'_{no} = 1 - p_{yes}$$\n\n因此，新概率对 $(p'_{yes}, p'_{no})$ 为 $(1 - p_{no}, 1 - p_{yes})$。", "answer": "$$\\boxed{\\begin{pmatrix} 1 - p_{no} & 1 - p_{yes} \\end{pmatrix}}$$", "id": "1451258"}]}