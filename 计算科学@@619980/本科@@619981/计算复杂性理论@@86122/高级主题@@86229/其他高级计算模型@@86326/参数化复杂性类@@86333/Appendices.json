{"hands_on_practices": [{"introduction": "在参数化算法的世界里，运行时间中依赖于参数$k$的部分至关重要。这个练习将通过一个具体的计算任务，让你直观地比较一个具有多项式参数依赖($k^2$)的算法和一个具有指数参数依赖($2^k$)的算法在处理大规模数据时的实际成本。这个对比凸显了为何理解算法复杂度如何随参数$k$变化，对于选择在实践中真正高效的解决方案是多么关键。[@problem_id:1434347]", "problem": "一个生物信息学研究团队正在开发算法，用于在一个非常大的脱氧核糖核酸（DNA）序列中搜索特定的功能基序。DNA序列的大小用$n$表示，基序的一个关键结构特性由一个整数参数$k$描述。该团队有两种相互竞争的算法，`PolyScan`和`ExpoScan`。\n\n每种算法的计算成本，以基本操作总数来衡量，已经通过理论分析和实验基准测试确定。\n- `PolyScan`的成本$N_P$由函数$N_P(n, k) = c_P k^2 n^2$给出。\n- `ExpoScan`的成本$N_E$由函数$N_E(n, k) = c_E 2^k n^2$给出。\n\n通过在某个特定高性能计算集群上进行的基准测试，比例常数被估计为 $c_P = 1.0 \\times 10^{-12}$ 操作/单位和 $c_E = 8.0 \\times 10^{-16}$ 操作/单位。\n\n该团队需要处理一个新测序的基因组，其主要输入大小为 $n = 5.0 \\times 10^6$，相关基序参数为 $k = 20$。计算在此特定任务下，`ExpoScan`所需的操作总数与`PolyScan`所需的操作总数的比率。\n\n将你的最终答案四舍五入到三位有效数字。", "solution": "目标是求出`ExpoScan`与`PolyScan`所需操作总数的比率，我们将其记为 $R = \\frac{N_E}{N_P}$。\n\n每种算法的操作数由以下函数给出：\n对于`PolyScan`：\n$$N_P(n, k) = c_P k^2 n^2$$\n对于`ExpoScan`：\n$$N_E(n, k) = c_E 2^k n^2$$\n\n我们已知的常数和参数值如下：\n- $c_P = 1.0 \\times 10^{-12}$\n- $c_E = 8.0 \\times 10^{-16}$\n- $n = 5.0 \\times 10^6$\n- $k = 20$\n\n现在，我们可以建立比率$R$：\n$$R = \\frac{N_E}{N_P} = \\frac{c_E 2^k n^2}{c_P k^2 n^2}$$\n\n注意到项$n^2$同时出现在分子和分母中。我们可以消去这一项，从而简化比率的表达式。这说明了参数化复杂度的核心思想：对于一个固定的参数$k$，算法成本随输入大小$n$的缩放可能是相同的，因此算法的选择关键取决于其与参数$k$相关的行为。\n\n简化后的比率为：\n$$R = \\frac{c_E 2^k}{c_P k^2}$$\n\n现在，我们将给定的数值代入这个简化后的表达式中：\n$$R = \\frac{(8.0 \\times 10^{-16}) \\cdot 2^{20}}{(1.0 \\times 10^{-12}) \\cdot 20^2}$$\n\n让我们计算$k$和2的幂：\n- $k^2 = 20^2 = 400 = 4.0 \\times 10^2$\n- $2^{20} = (2^{10})^2 = (1024)^2 = 1048576 \\approx 1.048576 \\times 10^6$\n\n将这些值代回到$R$的表达式中：\n$$R = \\frac{(8.0 \\times 10^{-16}) \\cdot (1.048576 \\times 10^6)}{(1.0 \\times 10^{-12}) \\cdot (4.0 \\times 10^2)}$$\n\n现在，我们将数字部分和10的幂分组：\n$$R = \\frac{8.0 \\cdot 1.048576}{1.0 \\cdot 4.0} \\times \\frac{10^{-16} \\cdot 10^6}{10^{-12} \\cdot 10^2}$$\n$$R = \\frac{8.388608}{4.0} \\times \\frac{10^{-10}}{10^{-10}}$$\n$$R = 2.097152 \\times 1$$\n$$R = 2.097152$$\n\n题目要求将最终答案四舍五入到三位有效数字。前三位有效数字是2、0和9。第四位数字是7，大于或等于5，所以我们将第三位数字向上取整。\n$$R \\approx 2.10$$", "answer": "$$\\boxed{2.10}$$", "id": "1434347"}, {"introduction": "我们如何设计出高效的固定参数可解（FPT）算法？一个核心技术是构造“有界深度搜索树”。这个练习将引导你分析一个为“击中集”问题设计的递归算法。通过估算其递归产生的搜索树的规模，你将亲身体验如何证明一个算法的复杂度可以被一个仅与参数$k$相关的函数乘以一个$n$的多项式所约束，这正是FPT算法的标志性特征。[@problem_id:1434298]", "problem": "命中集问题（Hitting Set problem）是计算机科学中的一个经典问题。该问题的一个实例由一个元素全集 $U$，一个由 $U$ 的非空子集组成的集合 $C = \\{S_1, S_2, \\ldots, S_m\\}$，以及一个正整数参数 $k$ 定义。问题是要确定是否存在一个大小至多为 $k$ 的*命中集* $H \\subseteq U$（即 $|H| \\le k$），使得 $H$ “命中” $C$ 中的每一个集合（即对于所有 $i=1, \\ldots, m$，都有 $H \\cap S_i \\ne \\emptyset$）。\n\n考虑以下为解决命中集问题而设计的递归算法，该算法以解的大小 $k$ 作为参数。\n\n**算法 `RecursiveHittingSet(C_current, k_rem)`：**\n1.  如果集合 `C_current` 为空，意味着所有原始集合都已被命中。返回 `true`。\n2.  如果 `k_rem` 为 0 且 `C_current` 不为空，说明在命中所有集合之前，用于命中集的预算已用尽。返回 `false`。\n3.  从 `C_current` 中选择一个任意集合 $S$。\n4.  对于 $S$ 中的每个元素 $x$：\n    a. 令 `C_next` 为 `C_current` 中所有不包含元素 $x$ 的集合构成的子集。\n    b. 进行一次递归调用：`RecursiveHittingSet(C_next, k_rem - 1)`。\n    c. 如果这次递归调用返回 `true`，说明找到了一个有效的命中集。停止并返回 `true`。\n5.  如果循环完成而没有任何递归调用返回 `true`，说明无法在给定的预算内命中集合 $S$ 及余下的集合。返回 `false`。\n\n该算法的执行过程可以被可视化为一棵搜索树，其中每个节点对应一次递归调用。根节点代表初始调用，一个节点会为其在该步骤选择的集合 $S$ 中的每个元素 $x$ 分支出一个子节点。\n\n设 $d_{max}$ 是原始输入集合 $C$ 中最大集合的大小。在最坏情况分析中，我们假设算法可能总是需要处理一个大小最大为 $d_{max}$ 的集合。下列哪个表达式给出了这棵搜索树中节点总数关于参数 $k$ 和最大集合大小 $d_{max}$ 的最紧上界？\n\nA. $O(k \\cdot d_{max})$\n\nB. $O(k^{d_{max}})$\n\nC. $O((d_{max})^k)$\n\nD. $O(d_{max} \\log k)", "solution": "在每次递归调用中，算法选择一个集合 $S$（其中 $|S| \\le d_{max}$），并对 $S$ 中的每个 $x$ 进行一次分支。在每个分支中，它将剩余预算减一，即 $k_{rem} \\mapsto k_{rem}-1$，并移除所有包含 $x$ 的集合。因此，在最坏情况下：\n- 每个节点的分支因子最多为 $d_{max}$。\n- 搜索树的深度最多为 $k$，因为在 $k$ 次选择之后，如果仍有集合未被命中，步骤2中的参数检查就会触发。\n\n设 $T(k)$ 表示当剩余预算为 $k$ 时搜索树中的最大节点数。那么最坏情况下的递推关系满足\n$$\nT(k) \\le 1 + d_{max} \\, T(k-1), \\quad T(0) \\le 1.\n$$\n展开此式可得\n$$\nT(k) \\le \\sum_{i=0}^{k} d_{max}^{i} = \\frac{d_{max}^{k+1}-1}{d_{max}-1} = O\\!\\left(d_{max}^{k}\\right) \\quad \\text{for } d_{max} \\ge 2,\n$$\n而对于 $d_{max}=1$，我们同样有 $T(k) \\le k+1 = O(1) = O\\!\\left(d_{max}^{k}\\right)$。\n\n此外，这个界在常数因子内是紧的：例如，考虑 $k+1$ 个两两不交的集合，每个集合的大小都为 $d_{max}$，并要求一个大小至多为 $k$ 的命中集。算法在得出结论之前，可能会探索一棵深度为 $k$ 的、完全的 $d_{max}$-叉树，从而产生 $\\Theta\\!\\left(d_{max}^{k}\\right)$ 个节点。\n\n在这些选项中，与此行为匹配的最紧上界是 $O\\!\\left((d_{max})^{k}\\right)$。", "answer": "$$\\boxed{C}$$", "id": "1434298"}, {"introduction": "参数化复杂性理论的精髓不仅在于设计算法，还在于揭示不同问题之间的内在联系。参数化归约是实现这一目标的关键工具，它类似于经典计算复杂性中的多项式时间归约。本练习将指导你完成一个经典的参数化归约：将著名的$k$-顶点覆盖问题转化为$k$-有界布尔可满足性问题，让你亲手构建这种转换，并理解其如何保持问题的可解性。[@problem_id:1434317]", "problem": "一个工程团队正在解决一个网络监控问题。这个问题被称为 $k$-顶点覆盖（$k$-VERTEX-COVER），旨在确定一个给定的网络图 $G=(V,E)$ 是否可以通过在节点子集 $V' \\subseteq V$ 上放置最多 $k$ 个传感器来进行“监控”，使得每条链路 $(u, v) \\in E$ 的端点 $u$ 或 $v$ 上至少有一个传感器。\n\n该团队只能使用一个专门用于解决另一种问题（称为 $k$-有界可满足性问题，$k$-BOUNDED-SAT）的求解器。该求解器接受一个合取范式（CNF）的布尔公式 $\\phi$——即一系列子句的合取（AND），其中每个子句是文字的析取（OR）——以及一个整数 $k$。它能确定是否存在一个 $\\phi$ 的可满足真值指派，该指派最多将 $k$ 个变量设为 TRUE。\n\n为了使用他们的求解器，团队需要将 $k$-VERTEX-COVER 的任何实例 $(G, k)$ 转换为 $k$-BOUNDED-SAT 的一个实例 $(\\phi, k)$。转换过程如下：\n1. 对于图中的每个顶点 $v \\in V$，创建一个唯一的布尔变量 $x_v$。\n2. 对于图中的每条边 $(u, v) \\in E$，使用变量 $x_u$ 和 $x_v$ 构建一个子句。\n3. 最终的公式 $\\phi$ 是步骤2中生成的所有子句的合取。\n\n这个转换被设计成具有这样的性质：图 $G$ 存在一个大小最多为 $k$ 的顶点覆盖，当且仅当生成的公式 $\\phi$ 存在一个最多有 $k$ 个变量被设为 TRUE 的可满足指派。\n\n考虑一个特定的图 $G$，其顶点集为 $V = \\{a, b, c, d\\}$，边集为 $E = \\{(a, b), (b, c), (c, d), (d, a)\\}$。按照所描述的转换，以下哪个 CNF 公式是正确的输出 $\\phi$？与顶点 $a, b, c, d$ 对应的变量分别为 $x_a, x_b, x_c, x_d$。\n\nA. $(x_a \\land x_b) \\lor (x_b \\land x_c) \\lor (x_c \\land x_d) \\lor (x_d \\land x_a)$\n\nB. $(\\neg x_a \\lor \\neg x_b) \\land (\\neg x_b \\lor \\neg x_c) \\land (\\neg x_c \\lor \\neg x_d) \\land (\\neg x_d \\lor \\neg x_a)$\n\nC. $(x_a \\lor x_b) \\land (x_b \\lor x_c) \\land (x_c \\lor x_d) \\land (x_d \\lor x_a)$\n\nD. $(x_a \\leftrightarrow x_b) \\land (x_b \\leftrightarrow x_c) \\land (x_c \\leftrightarrow x_d) \\land (x_d \\leftrightarrow x_a)$\n\nE. $(x_a \\land x_b \\land x_c \\land x_d)$", "solution": "题目要求我们根据一个描述的转换规则，从一个给定的图 $G=(V, E)$ 构建一个特定的合取范式（CNF）公式 $\\phi$。这个转换连接了 $k$-VERTEX-COVER 问题和 $k$-BOUNDED-SAT 问题。\n\n转换的核心思想是在两个问题的元素之间建立直接的对应关系。顶点 $v$ 属于顶点覆盖被映射为其对应的布尔变量 $x_v$ 被赋值为 TRUE。规模约束 $k$ 在两个问题中保持不变。\n\n顶点覆盖 $V'$ 的定义属性是，对于每条边 $(u, v) \\in E$，它的至少一个端点必须在覆盖中。用集合论的符号表示，即 $u \\in V'$ 或 $v \\in V'$。\n\n使用已建立的对应关系，条件“$u \\in V'$ 或 $v \\in V'$”被翻译成逻辑条件“$x_u$ 为 TRUE 或 $x_v$ 为 TRUE”。这恰好是逻辑析取 $(x_u \\lor x_v)$。要成为一个有效的顶点覆盖，这个条件必须对图中的*每*条边都成立。\n\n转换通过确保这个属性对所有边同时成立来构建最终公式 $\\phi$。它的做法是为每条边 $(u, v) \\in E$ 创建一个形如 $(x_u \\lor x_v)$ 的子句。最终的公式 $\\phi$ 是所有这些子句的合取（逻辑 AND），这是 CNF 公式的要求。因此，转换的通用形式是：\n$$ \\phi = \\bigwedge_{(u,v) \\in E} (x_u \\lor x_v) $$\n\n现在，我们将这个通用规则应用于题目中给出的具体实例。\n图是 $G=(V,E)$，其中：\n- 顶点集为 $V = \\{a, b, c, d\\}$。\n- 边集为 $E = \\{(a, b), (b, c), (c, d), (d, a)\\}$。\n\n相应的布尔变量是 $x_a, x_b, x_c, x_d$。我们为 $E$ 中的每条边生成一个子句：\n1. 边 $(a, b)$ 产生子句 $(x_a \\lor x_b)$。\n2. 边 $(b, c)$ 产生子句 $(x_b \\lor x_c)$。\n3. 边 $(c, d)$ 产生子句 $(x_c \\lor x_d)$。\n4. 边 $(d, a)$ 产生子句 $(x_d \\lor x_a)$。\n\n最终的公式 $\\phi$ 是这四个子句的合取：\n$$ \\phi = (x_a \\lor x_b) \\land (x_b \\lor x_c) \\land (x_c \\lor x_d) \\land (x_d \\lor x_a) $$\n\n让我们将这个结果与给定的选项进行比较：\n- A: $(x_a \\land x_b) \\lor (x_b \\land x_c) \\lor (x_c \\land x_d) \\lor (x_d \\land x_a)$ 是析取范式（DNF），而不是合取范式（CNF）。它错误地交换了 AND 和 OR 的作用。\n- B: $(\\neg x_a \\lor \\neg x_b) \\land (\\neg x_b \\lor \\neg x_c) \\land (\\neg x_c \\lor \\neg x_d) \\land (\\neg x_d \\lor \\neg x_a)$。子句 $(\\neg x_u \\lor \\neg x_v)$ 等价于 $\\neg(x_u \\land x_v)$，意味着 $u$ 和 $v$ 不能同时在所选集合中。这对应于独立集的定义，而不是顶点覆盖。\n- C: $(x_a \\lor x_b) \\land (x_b \\lor x_c) \\land (x_c \\lor x_d) \\land (x_d \\lor x_a)$。这与我们推导出的公式完全匹配。\n- D: 这个选项使用了双条件（$\\leftrightarrow$），这不属于所描述的转换逻辑。\n- E: 这个选项是一个单一子句，这意味着所有边都以一种特定方式连接到所有顶点，但对于给定的图来说并非如此。只有当问题简化为单个巨大的 OR 子句时，它才是正确的，但事实并非如此。\n\n因此，正确的 CNF 公式在选项 C 中给出。", "answer": "$$\\boxed{C}$$", "id": "1434317"}]}