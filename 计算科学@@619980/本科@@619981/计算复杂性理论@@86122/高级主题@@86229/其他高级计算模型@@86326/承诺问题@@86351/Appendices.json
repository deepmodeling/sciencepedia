{"hands_on_practices": [{"introduction": "许多计算问题在一般情况下可能非常困难，但如果输入满足某个特定的“承诺”，问题或许会变得出人意料地简单。这个练习正是这样一个典型例子，我们将看到一个关于多项式根的保证如何让我们能够设计出一个极为高效的算法。通过解决这个问题 [@problem_id:1437636]，你将亲身体会到承诺如何将复杂问题转化为多项式时间内可解的任务。", "problem": "在计算复杂性理论中，一个标准的判定问题由一个语言 $L$ 定义，该语言是一个字符串集合，目标是确定给定的输入字符串 $x$ 是否在 $L$ 中。承诺问题是一种泛化，其中输入被保证（“承诺”）来自所有可能字符串的一个特定子集。\n\n一个承诺问题由一对不相交的字符串集合 $(\\Pi_{YES}, \\Pi_{NO})$ 正式定义。如果一个算法接受每个输入 $x \\in \\Pi_{YES}$ 并拒绝每个输入 $x \\in \\Pi_{NO}$，则称该算法解决了这个承诺问题。该算法在 $\\Pi_{YES} \\cup \\Pi_{NO}$ 之外的输入上的行为不受约束。集合 $\\Pi_{YES} \\cup \\Pi_{NO}$ 被称为承诺。\n\n复杂性类 PromiseP 包含所有可以由确定性算法在相对于输入长度的多项式时间内解决的承诺问题。\n\n考虑以下计算问题，我们称之为 `ONE_ROOT`：\n\n-   **输入：** 一个整系数多项式 $p(x) = a_n x^n + \\dots + a_1 x + a_0$，表示为其整系数的列表 $\\langle p \\rangle = [a_0, a_1, \\dots, a_n]$。\n-   **承诺：** 输入多项式 $p(x)$ 被保证恰好满足以下两个条件之一：要么 $p(1) = 0$，要么 $p(-1) = 0$。\n-   **问题：** 多项式 $p(x)$ 在 $x=1$ 处是否有根？\n\n这可以被构建为一个承诺问题 $(\\Pi_{YES}, \\Pi_{NO})$，其中 $\\Pi_{YES}$ 是“是”实例（即 $p(1)=0$ 的情况），而 $\\Pi_{NO}$ 是“否”实例（即 $p(-1)=0$ 的情况）。\n\n下列哪个陈述是正确的？\n\nA. `ONE_ROOT` 属于 PromiseP。\n\nB. `ONE_ROOT` 不属于 PromiseP，但它是可判定的。\n\nC. `ONE_ROOT` 是不可判定的。\n\nD. `ONE_ROOT` 的复杂性取决于多项式的次数，并且只有当次数被一个常数界定时，它才属于 PromiseP。", "solution": "给定一个整系数多项式 $p(x)=a_{n}x^{n}+\\dots+a_{1}x+a_{0}$，编码为 $\\langle p \\rangle=[a_{0},a_{1},\\dots,a_{n}]$，并承诺 $p(1)=0$ 或 $p(-1)=0$ 中恰好有一个成立。问题是询问是否 $p(1)=0$。我们将承诺问题 $(\\Pi_{\\mathrm{YES}},\\Pi_{\\mathrm{NO}})$ 定义为\n$$\n\\Pi_{\\mathrm{YES}}=\\{\\langle p\\rangle:\\ p(1)=0,\\ p(-1)\\neq 0\\},\\quad \\Pi_{\\mathrm{NO}}=\\{\\langle p\\rangle:\\ p(-1)=0,\\ p(1)\\neq 0\\}.\n$$\n如果一个算法接受 $\\Pi_{\\mathrm{YES}}$ 中的所有输入并拒绝 $\\Pi_{\\mathrm{NO}}$ 中的所有输入，那么它就解决了这个承诺问题；其在 $\\Pi_{\\mathrm{YES}}\\cup\\Pi_{\\mathrm{NO}}$ 之外的行为是无关紧要的。\n\n关键观察：在 $x=1$ 处对 $p$ 求值可以简化为对其系数求和：\n$$\np(1)=\\sum_{i=0}^{n}a_{i}.\n$$\n算法：给定 $\\langle p\\rangle=[a_{0},\\dots,a_{n}]$，计算\n$$\ns=\\sum_{i=0}^{n}a_{i},\n$$\n当且仅当 $s=0$ 时输出“是”（YES）；否则输出“否”（NO）。\n\n在承诺下的正确性：如果 $\\langle p\\rangle\\in\\Pi_{\\mathrm{YES}}$，根据定义有 $p(1)=0$，因此 $s=0$，算法输出“是”。如果 $\\langle p\\rangle\\in\\Pi_{\\mathrm{NO}}$，则 $p(1)\\neq 0$，因此 $s\\neq 0$，算法输出“否”。因此，该算法对于所有满足承诺的输入都是正确的。对于同时满足 $p(1)=0$ 和 $p(-1)=0$（或两者都不满足）的输入，其行为不受承诺的约束；实际上，该算法对任何输入仍然能正确输出。\n\n运行时间：设总输入大小为 $N$，其度量为整数 $a_{0},\\dots,a_{n}$ 的比特长度之和，加上分隔符的编码开销。将两个比特长度最多为 $L$ 的整数相加，可以在 $O(L)$ 时间内完成。$n+1$ 个整数的迭代求和，其比特长度受其输入大小的限制，所需时间是 $N$ 的多项式时间；中间和的比特长度最多增加 $O(\\log(n+1))$，因此总时间为 $O\\!\\left(\\sum_{i=0}^{n}\\mathrm{len}(a_{i})+n\\log(n+1)\\right)$，这是 $N$ 的多项式。因此，该算法是确定性多项式时间的。\n\n结论：该问题属于 PromiseP，因为存在一个确定性多项式时间算法，它对所有满足承诺的输入都能正确判定。因此，陈述 A 是正确的。陈述 B 和 C 是错误的，因为该问题在确定性多项式时间内是可判定的。陈述 D 是错误的，因为该算法在多项式时间内运行，无需对多项式次数有任何界定。", "answer": "$$\\boxed{A}$$", "id": "1437636"}, {"introduction": "承诺的力量究竟有多大？这个思想实验将“承诺”的概念推向了极限。它触及了计算理论中最著名的不可判定问题之一——停机问题，并揭示了即使是已被证明在一般情况下无解的问题，在足够强的承诺下也可能变得可判定。这个练习 [@problem_id:1437602] 强调了为所有输入求解与仅为有保证的子集求解之间的本质区别。", "problem": "承诺问题 (promise problem) 是一个由一对不相交的字符串集合 $(L_{YES}, L_{NO})$ 定义的计算任务。如果一个图灵机 (TM) 对于任意输入串 $x$，当 $x \\in L_{YES}$ 时停机并接受，当 $x \\in L_{NO}$ 时停机并拒绝，那么我们称该图灵机判定此承诺问题。对于不属于 $L_{YES} \\cup L_{NO}$ 的输入，该图灵机的行为是未指定的。\n\n设 $w_0$ 是一个固定的二进制串 \"0101\"。考虑一个与图灵机行为相关的承诺问题 $\\mathcal{P} = (L_{YES}, L_{NO})$。该问题的输入是一个图灵机的编码，记作 $\\langle M \\rangle$。其承诺是，对于该问题给定的任何图灵机 $M$，它保证在所有长度等于 $w_0$ 长度（即 $|w'| = |w_0| = 4$）的输入串 $w'$ 上都会停机。\n\n承诺问题 $\\mathcal{P}$ 的集合定义如下：\n- $L_{YES} = \\{ \\langle M \\rangle \\mid \\text{图灵机 } M \\text{ 接受 } w_0 \\text{ 并且在所有长度为4的串上停机} \\}$\n- $L_{NO} = \\{ \\langle M \\rangle \\mid \\text{图灵机 } M \\text{ 不接受 } w_0 \\text{ 并且在所有长度为4的串上停机} \\}$\n\n问题是，在输入总是属于 $L_{YES} \\cup L_{NO}$ 的承诺下，区分 $L_{YES}$ 和 $L_{NO}$ 中实例的计算性质是什么？\n\n下列哪个陈述正确地描述了此承诺问题 $\\mathcal{P}$ 的复杂性？\n\nA. 该承诺问题是可判定的。\n\nB. 该承诺问题是不可判定的，但属于复杂性类 RE (图灵可识别的)。\n\nC. 该承诺问题是不可判定的，但属于复杂性类 co-RE。\n\nD. 该承诺问题是不可判定的，且既不属于 RE 也不属于 co-RE。", "solution": "该问题询问的是承诺问题 $\\mathcal{P} = (L_{YES}, L_{NO})$ 的可判定性。如果一个算法能在输入保证属于 $L_{YES}$ 或 $L_{NO}$ 的情况下，正确地区分来自这两个集合的输入，那么该算法就判定了这个问题。\n\n让我们分析一下这个问题的结构。我们得到一个图灵机的编码 $\\langle M \\rangle$，并被承诺该图灵机 $M$ 对所有长度为4的输入串都会停机。这里讨论的具体字符串是 $w_0 = 0101$，其长度为4。\n\n这个承诺是关键信息。既然我们保证了 $M$ 在所有长度为4的串上都会停机，那么这个保证也特别适用于字符串 $w_0 = 0101$。因此，对于任何遵守该承诺的输入 $\\langle M \\rangle$，我们可以确定 $M$ 在输入 $w_0$ 上的计算将会终止。\n\n基于这一洞见，我们可以构造一个图灵机，称之为 $D$，来解决这个承诺问题。$D$ 的算法如下：\n对于输入 $\\langle M \\rangle$：\n1. $D$ 接收编码 $\\langle M \\rangle$ 和固定字符串 $w_0 = 0101$。\n2. $D$ 模拟图灵机 $M$ 在输入串 $w_0$ 上的执行过程。\n3. 因为输入 $\\langle M \\rangle$ 被承诺属于 $L_{YES} \\cup L_{NO}$，所以图灵机 $M$ 保证在 $w_0$ 上会停机。因此，$D$ 所执行的模拟也保证会终止。\n4. 当 $M(w_0)$ 的模拟停机时，$D$ 检查其结果：\n   - 如果 $M$ 在一个接受状态下停机，这意味着 $\\langle M \\rangle \\in L_{YES}$。在这种情况下，$D$ 停机并接受。\n   - 如果 $M$ 在一个拒绝状态下停机，这意味着 $M$ 不接受 $w_0$，所以 $\\langle M \\rangle \\in L_{NO}$。在这种情况下，$D$ 停机并拒绝。\n\n上述图灵机 $D$ 可作为判定器来判定承诺问题 $\\mathcal{P}$。对于来自承诺集合 $L_{YES} \\cup L_{NO}$ 的任何输入 $\\langle M \\rangle$，$D$ 总是会停机并给出正确的答案：对于 $L_{YES}$ 中的输入，它接受；对于 $L_{NO}$ 中的输入，它拒绝。因此，承诺问题 $\\mathcal{P}$ 是可判定的。\n\n为了理解为什么其他选项是错误的，将此问题与相关的不可判定问题进行对比是很重要的。\n- 如果没有这个承诺，判定一个任意图灵机 $M$ 是否接受固定字符串 $w_0$ 的问题（即语言 $A_{TM}^{w_0} = \\{ \\langle M \\rangle \\mid M \\text{ 接受 } w_0 \\}$）是不可判定的。然而，这个问题是图灵可识别的（属于 RE），因为可以模拟 $M$ 在 $w_0$ 上的运行，如果它接受就接受。如果 $M$ 进入循环或拒绝，识别器可能不会停机。如果学生将我们的问题与这个标准问题相混淆，就可能会错误地选择选项B。\n- 一个关键的错误是认为判定器 $D$ 必须首先验证承诺。验证承诺的问题，即判定语言 $P_4 = \\{ \\langle M \\rangle \\mid M \\text{ 在所有长度为4的串上停机} \\}$，其本身是高度不可判定的（超越了 RE 和 co-RE）。一个判定 $P_4$ 的图灵机将需要解决 $M$ 在 $2^4 = 16$ 个不同输入上的停机问题。根据莱斯定理(Rice's theorem)，图灵机语言的任何非平凡属性都是不可判定的。尽管这个承诺是关于图灵机的行为，而不仅仅是其语言，但也可以证明它是不可判定的。如果有人认为必须先验证承诺，那么他可能会错误地选择选项D。\n\n然而，承诺问题的定义使我们免除了这一责任。我们*被给定*输入满足该承诺，这个条件足够强大，可以使一个原本不可判定的问题变得可判定。\n\n因此，这个总会停机的判定器 $D$ 的存在证明了该承诺问题是可判定的。", "answer": "$$\\boxed{A}$$", "id": "1437602"}, {"introduction": "承诺问题的应用并不仅限于确定性计算，它们在概率算法中同样扮演着重要角色。在这个实践中，我们将探索承诺与随机化算法的交叉点。你需要设计一个概率算法来区分两种特定结构的图，这展示了当一个确定性的区分方法不那么直观时，如何利用承诺和随机性来有效地解决问题 [@problem_id:1437609]。", "problem": "考虑一个名为 `PATH_vs_STAR` 的承诺问题。这个问题的输入是一个包含 $n \\ge 4$ 个顶点的无向图 $G = (V,E)$，以邻接矩阵的形式给出。我们得到一个承诺，即输入图 $G$ 要么是路径图 $P_n$，要么是星形图 $K_{1,n-1}$。\n\n- **路径图** $P_n$是一种图，其顶点可以排列成一个序列 $v_1, v_2, \\ldots, v_n$，使得对于所有 $i = 1, \\ldots, n-1$，边恰好是 $(v_i, v_{i+1})$。\n- **星形图** $K_{1,n-1}$是一种图，它有一个中心顶点连接到所有其他 $n-1$ 个顶点，并且图中只有这些边。\n\n目标是设计一个算法来判断图 $G$ 属于哪种类型。具体来说，如果 $G$ 是一个路径图，算法应输出 'YES'；如果 $G$ 是一个星形图，算法应输出 'NO'。\n\n一个承诺问题 $(\\Pi_{YES}, \\Pi_{NO})$，其中 $\\Pi_{YES}$ 是 'YES' 实例的集合（这里是所有的 $P_n$ 图），而 $\\Pi_{NO}$ 是 'NO' 实例的集合（所有的 $K_{1,n-1}$ 图），如果它能被一个在多项式时间内运行的随机算法解决，并且对于任何有效的输入 $G$ 都满足以下条件，那么它就属于复杂性类 PromiseBPP（有界错误概率多项式时间）：\n- 如果 $G \\in \\Pi_{YES}$，算法以至少 $2/3$ 的概率输出 'YES'。\n- 如果 $G \\in \\Pi_{NO}$，算法以至少 $2/3$ 的概率输出 'NO'。\n\n以下哪个随机算法能正确解决 `PATH_vs_STAR` 承诺问题，并证明对于所有 $n \\ge 4$，该问题都属于 PromiseBPP？\n\nA. **算法 A：**\n1. 从 $V$ 中均匀随机地选择一个顶点 $v$。\n2. 计算其度 $\\deg(v)$。\n3. 如果 $\\deg(v) = 2$，输出 'YES'。\n4. 否则，输出 'NO'。\n\nB. **算法 B：**\n1. 从 $V$ 中均匀随机地选择两个不同的顶点 $u$ 和 $v$。\n2. 计算它们的度 $\\deg(u)$ 和 $\\deg(v)$。\n3. 如果 $\\deg(u)=1$ 且 $\\deg(v)=1$，输出 'NO'。\n4. 否则，输出 'YES'。\n\nC. **算法 C：**\n1. 重复 5 次：\n   a. 从 $V$ 中均匀随机地选择一个顶点 $v$。\n   b. 如果 $\\deg(v) \\ge 3$，输出 'NO' 并停止。\n2. 如果循环完成而没有停止，输出 'YES'。\n\nD. **算法 D：**\n1. 重复 $2n$ 次：\n   a. 从 $V$ 中均匀随机地选择一个顶点 $v$。\n   b. 如果 $\\deg(v) \\ge 3$，输出 'NO' 并停止。\n2. 如果循环完成而没有停止，输出 'YES'。\n\nE. **算法 E：**\n1. 计算所有 $n$ 个顶点的度。\n2. 如果恰好有两个顶点的度为 1，另外 $n-2$ 个顶点的度为 2，则准备输出 'YES'。否则，准备输出 'NO'。\n3. 抛一枚均匀的硬币。如果正面朝上，输出准备好的答案。如果反面朝上，输出与准备好的答案相反的结果。", "solution": "为了确定哪个算法在 PromiseBPP 中解决了 `PATH_vs_STAR` 承诺问题，我们必须针对所有 $n \\ge 4$ 的情况，根据问题的要求来分析每个提出的算法。要求是：多项式运行时间，对于 YES 实例和 NO 实例，正确率的概率都 $\\ge 2/3$。从一个 $n \\times n$ 的邻接矩阵计算单个顶点的度所需的时间是 $O(n)$。\n\n首先，让我们确定对于 $n \\ge 4$ 的图的度属性：\n- 路径图 $P_n$ 有两个度为 1 的顶点（端点）和 $n-2$ 个度为 2 的顶点。最大度为 2。\n- 星形图 $K_{1,n-1}$ 有一个度为 $n-1$ 的中心顶点和 $n-1$ 个度为 1 的叶顶点。由于 $n \\ge 4$，中心顶点的度为 $n-1 \\ge 3$。最大度为 $n-1$。\n\n关键区别在于路径图的最大度为 2，而星形图的最大度至少为 3。任何度 $\\ge 3$ 的顶点都立即表明该图是星形图。任何度为 2 的顶点都立即表明该图是路径图。\n\n**算法 A 的分析：**\n- **YES 实例 ($G=P_n$)：** 仅当算法选择了一个度为 2 的顶点时，它才会输出 'YES'。这样的顶点有 $n-2$ 个。输出 'YES' 的概率是 $\\frac{n-2}{n} = 1 - \\frac{2}{n}$。我们要求这个概率至少为 $2/3$。所以，$1 - \\frac{2}{n} \\ge \\frac{2}{3} \\implies \\frac{1}{3} \\ge \\frac{2}{n} \\implies n \\ge 6$。该算法在 $n=4$（概率=1/2）和 $n=5$（概率=3/5）时失败，因为这些概率小于 $2/3$。\n- **结论：** 算法 A 不正确。\n\n**算法 B 的分析：**\n- **NO 实例 ($G=K_{1,n-1}$)：** 如果算法选择了两个度为 1 的顶点，它会输出 'NO'。这样的顶点有 $n-1$ 个。这一事件的概率是 $\\frac{\\binom{n-1}{2}}{\\binom{n}{2}} = \\frac{(n-1)(n-2)/2}{n(n-1)/2} = \\frac{n-2}{n} = 1 - \\frac{2}{n}$。这是正确输出 'NO' 的概率。与算法 A 一样，这个概率仅在 $n \\ge 6$ 时才 $\\ge 2/3$。它在 $n=4, 5$ 时失败。\n- **结论：** 算法 B 不正确。\n\n**算法 C 的分析：**\n- **YES 实例 ($G=P_n$)：** 在 $P_n$ 中最大度为 2。条件 $\\deg(v) \\ge 3$ 永远不会满足。算法将总是完成循环并输出 'YES'。正确率为 1，这 $\\ge 2/3$。这部分是正确的。\n- **NO 实例 ($G=K_{1,n-1}$)：** 如果算法在所有 5 次试验中都未能选到唯一的中心顶点（度为 $n-1 \\ge 3$），则会出错。在一次试验中选到中心顶点的概率是 $1/n$。没有选到它的概率是 $1 - 1/n$。错误（输出 'YES'）的概率是在 5 次独立试验中都没有选到中心顶点的概率，即 $\\left(1 - \\frac{1}{n}\\right)^5$。我们需要这个错误概率 $\\le 1/3$。然而，当 $n$ 变得很大时，$\\left(1 - \\frac{1}{n}\\right)^5$ 趋近于 $1$。例如，如果 $n=10$，错误概率是 $(0.9)^5 \\approx 0.59$，这大于 $1/3$。\n- **结论：** 算法 C 不正确，因为它在 NO 实例上的错误概率对于所有 $n \\ge 4$ 并没有被 $1/3$ 界定。\n\n**算法 D 的分析：**\n- **YES 实例 ($G=P_n$)：** 与算法 C 类似，最大度为 2，所以条件 $\\deg(v) \\ge 3$ 永远不会满足。算法总是输出 'YES'。正确率为 1。这是正确的。\n- **NO 实例 ($G=K_{1,n-1}$)：** 如果算法在 $2n$ 次试验中都未能选到中心顶点，则会出错。错误概率是 $P(\\text{error}) = \\left(1 - \\frac{1}{n}\\right)^{2n}$。我们需要检查对于所有 $n \\ge 4$ 这个值是否 $\\le 1/3$。\n我们可以使用不等式 $1-x \\le \\exp(-x)$，它对所有实数 $x$ 都成立。设 $x=1/n$，我们有 $1 - \\frac{1}{n} \\le \\exp(-1/n)$。\n因此，$P(\\text{error}) = \\left(1 - \\frac{1}{n}\\right)^{2n} \\le \\left(\\exp\\left(-\\frac{1}{n}\\right)\\right)^{2n} = \\exp(-2)$。\n$\\exp(-2)$ 的值约等于 $0.135$。由于 $0.135 < 1/3$，错误概率被适当地界定了。\n该算法的运行时间是 $2n$ 次迭代，每次迭代都涉及计算一个度，这需要 $O(n)$ 的时间。总运行时间是 $O(n \\cdot n) = O(n^2)$，这是 $n$ 的一个多项式。\n- **结论：** 算法 D 在多项式时间内运行，并且对于所有 $n \\ge 4$ 的 YES 和 NO 实例都满足正确率概率要求。因此，它是一个正确的算法，将该问题置于 PromiseBPP 中。\n\n**算法 E 的分析：**\n- 前两个步骤描述了一个确定性的多项式时间算法，该算法计算图的完整度序列。这个过程能以 100% 的准确率正确区分 $P_n$ 和 $K_{1,n-1}$。我们称这个确定性部分的输出为 $D(G)$。\n- 第三步引入了随机性：算法以 $1/2$ 的概率输出 $D(G)$，以 $1/2$ 的概率输出其相反的结果。\n- **YES 实例 ($G=P_n$)：** $D(G)$ 是 'YES'。算法以 $1/2$ 的概率输出 'YES'。这不满足 $\\ge 2/3$。\n- **NO 实例 ($G=K_{1,n-1}$)：** $D(G)$ 是 'NO'。算法以 $1/2$ 的概率输出 'NO'。这不满足 $\\ge 2/3$。\n- **结论：** 算法 E 不正确，因为最后的随机化步骤将其成功概率降低到 $1/2$，低于所要求的 $2/3$ 的阈值。\n\n基于以上分析，只有算法 D 能正确解决问题。", "answer": "$$\\boxed{D}$$", "id": "1437609"}]}