{"hands_on_practices": [{"introduction": "本练习将引导你分析一个基础但功能强大的随机通信协议。该协议旨在解决一个经典的数论问题：判断两个由不同方持有的整数是否共享一个公因数。通过将大整数映射到一个随机选择的小素数的模下，我们创造了一个紧凑的“指纹”[@problem_id:1440982]，这极大地降低了通信开销。这个实践将帮助你亲手计算协议的通信成本和错误概率，从而掌握单向错误随机协议的核心思想。", "problem": "Alice和Bob正在研究随机通信协议。他们的任务是确定他们各自的整数$x$和$y$是否共享一个公共素因子。他们设计了以下单向协议，该协议依赖于一个共享的公共随机源：\n\n**协议：公共因子测试**\n1.  从所有小于或等于一个公开已知整数$M$的素数集合中，均匀随机地选择一个素数$p$。\n2.  Alice计算$a = x \\pmod p$并将$a$的值传输给Bob。\n3.  Bob接收$a$。然后他计算$b = y \\pmod p$。\n4.  Bob的输出规则：如果$a=0$且$b=0$，Bob输出找到了一个公共因子。否则，他输出对于所选的素数$p$没有找到公共因子。\n\n该协议被称为具有单侧错误。如果协议输出找到了一个公共因子，那么这个结果总是正确的（即$\\text{gcd}(x,y) > 1$）。然而，如果$\\text{gcd}(x,y) > 1$，协议可能会未能找到公共因子，从而导致错误。\n\n考虑一个具体情景，其中参数$M=100$。Alice的数字是$x = 177$，Bob的数字是$y = 295$。已知这些数的素数分解为$x=3 \\times 59$和$y=5 \\times 59$。\n\n该协议的通信成本是多少（以Alice必须发送的比特数衡量），以及对于这一对特定的输入$(x, y)$，其错误概率是多少？错误概率定义为在确实存在公共因子的情况下，协议未能找到该公共因子的概率。\n\nA. 通信成本：6比特，错误概率：24/25\n\nB. 通信成本：7比特，错误概率：1/25\n\nC. 通信成本：7比特，错误概率：24/25\n\nD. 通信成本：8比特，错误概率：24/25\n\nE. 通信成本：7比特，错误概率：23/24", "solution": "一个素数$p$从所有至多为$M=100$的素数集合中均匀选取。设这个集合为$\\mathcal{P}$，其大小为$|\\mathcal{P}|=\\pi(100)$。至多为100的素数个数是$\\pi(100)=25$。\n\n通信成本：Alice发送$a=x \\bmod p$，其值位于集合$\\{0,1,\\dots,p-1\\}$中。编码任何此类余数所需的比特数是$\\lceil \\log_{2} p \\rceil$。该协议必须适用于小于等于100的最大可能$p$，即$97$。由于$2^{6}=64<97\\leq 2^{7}=128$，可得\n$$\n\\lceil \\log_{2} 97 \\rceil=7,\n$$\n所以通信成本是$7$比特。\n\n错误概率：协议输出“找到”当且仅当$a=0$且$b=0$，这等价于$p \\mid x$且$p \\mid y$，即$p$整除$\\gcd(x,y)$。给定$x=3 \\times 59$和$y=5 \\times 59$，我们有$\\gcd(x,y)=59$。因此，协议仅在$p=59$时成功。由于$p$在$|\\mathcal{P}|=25$的集合$\\mathcal{P}$上均匀分布，成功概率为\n$$\n\\frac{1}{25},\n$$\n因此错误概率为\n$$\n1-\\frac{1}{25}=\\frac{24}{25}.\n$$\n\n因此，正确选项是“通信成本：7比特，错误概率：$24/25$。”", "answer": "$$\\boxed{C}$$", "id": "1440982"}, {"introduction": "在处理如基因组测序等海量数据时，直接比较原始数据是不切实际的。此练习模拟了一个计算生物学场景，你需要设计一个协议来高效地检测两个长 DNA 序列中是否存在公共子串[@problem_id:1440992]。你将看到，通过为每个子串计算指纹，我们可以将一个复杂的字符串匹配问题转化为一个简单的集合交集问题。这项实践的重点是理解如何通过选择足够大的随机素数来将“误报”的概率控制在可接受的范围内，并据此计算出总的通信成本。", "problem": "Alice和Bob正在合作一个大规模的计算生物学项目。Alice有一个脱氧核糖核酸 (DNA) 序列 $x$，Bob有一个DNA序列 $y$，两者的长度都为 $n$。这些序列被表示为基于字母表 $\\{A, C, G, T\\}$ 的字符串。他们想要确定在他们的序列中是否存在一个长度恰好为 $k$ 的公共子串。直接比较需要传输其中一个序列，而这样做的成本很高。他们决定使用一个随机化通信协议，该协议如下所述。\n\n1.  他们公开约定一个从字母表 $\\{A, C, G, T\\}$ 到整数集合 $\\{0, 1, 2, 3\\}$ 的映射。这将他们的DNA序列转换成整数串。\n2.  他们将每个长度为 $k$ 的子串解释为一个整数的4进制表示。对于一个子串 $s = s_1 s_2 \\dots s_k$，其中每个 $s_i$ 是对应一个DNA碱基的整数，其关联的整数值为 $N(s) = \\sum_{i=1}^k s_i 4^{k-i}$。\n3.  为了处理可能非常大的数字，他们还公开约定了一个素数 $p$。Alice为她的 $n-k+1$ 个长度为 $k$ 的子串中的每一个计算一个“指纹”。一个子串 $s$ 的指纹是 $FP(s) = N(s) \\pmod p$。她将这些指纹收集到一个集合 $F_x$ 中。\n4.  在一条消息中，Alice将整个指纹集合 $F_x$ 发送给Bob。\n5.  Bob为他自己的子串计算指纹，创建集合 $F_y$。然后他检查交集 $F_x \\cap F_y$ 是否非空。如果是，他们就断定很可能存在一个长度为 $k$ 的公共子串。如果交集为空，他们就断定不存在公共子串。\n\n此协议存在单边错误：如果存在公共子串，它从不会漏检，但在不存在公共子串时，它可能会报告存在（一个假阳性）。假设 $n=1,000,000$ 且 $k=50$。他们希望假阳性的概率最多为 $10^{-6}$。为了实现这一点，他们从区间 $[M, 2M]$ 内的素数集合中均匀随机地选择素数 $p$ 。已知对于任何整数 $Z > 1$，其不同素因子的数量严格小于 $\\log_2(Z)$。他们确定，为了满足他们期望的错误界限，他们必须选择 $M$ 为满足条件的最小的10的整数次幂。\n\n你的任务是计算在最坏情况下，Alice必须发送给Bob的比特总数。为了发送她的指纹集合，Alice逐个地传输每个唯一的指纹值。每个指纹所需的比特数由他们可能约定的最大素数决定。将关于比特总数的最终答案用科学记数法表示，并四舍五入到三位有效数字。", "solution": "令 $n=10^{6}$ 且 $k=50$。每个长度为 $k$ 的子串 $s$ 映射到一个整数 $N(s)\\in\\{0,1,\\dots,4^{k}-1\\}$。对于没有公共长度为 $k$ 的子串的字符串 $x$ 和 $y$，出现假阳性的充要条件是，存在来自 $x$ 的子串 $s$ 和来自 $y$ 的子串 $t$，使得 $N(s)\\not= N(t)$ 但 $N(s)\\equiv N(t)\\pmod p$，即 $p$ 整除 $Z_{s,t}\\equiv |N(s)-N(t)|$。\n\n令 $L\\equiv n-k+1$ 为每个字符串中长度为 $k$ 的子串的数量；此处\n$$\nL=n-k+1=10^{6}-50+1=999{,}951.\n$$\n最多有 $L^{2}$ 个有序对 $(s,t)$，对于每个这样的对，有 $1\\leq Z_{s,t}\\leq 4^{k}-1$。令 $D$ 为所有满足 $Z_{s,t}\\geq 1$ 的 $Z_{s,t}$ 的集合。如果选择的素数 $p\\in[M,2M]$ 整除 $D$ 中至少一个 $Z$，则出现假阳性。\n\n根据给定的事实，任何整数 $Z>1$ 的不同素因子的数量严格小于 $\\log_{2}(Z)$。因此，整除 $D$ 中至少一个 $Z$ 的不同素数的数量严格小于\n$$\n\\log_{2}\\!\\Big(\\prod_{Z\\in D} Z\\Big)=\\sum_{Z\\in D}\\log_{2}(Z)\\leq |D|\\cdot\\log_{2}(4^{k})\\leq L^{2}\\cdot 2k.\n$$\n因此，在 $[M,2M]$ 中的“坏”素数数量严格小于 $2kL^{2}$。如果 $P(M)$ 表示 $[M,2M]$ 中素数的数量，那么从这些素数中均匀随机选择 $p$ 将得到\n$$\n\\Pr[\\text{假阳性}]\\leq \\frac{2kL^{2}}{P(M)}.\n$$\n为确保此概率最多为 $10^{-6}$，只需要满足\n$$\nP(M)\\geq 10^{6}\\cdot 2kL^{2}.\n$$\n当 $k=50$ 且 $L=999{,}951$时，\n$$\n2kL^2 = 2 \\cdot 50 \\cdot (999,951)^2 = 100 \\cdot 999,902,002,401 = 99,990,200,240,100.\n$$\n因此一个充分条件是\n$$\nP(M)\\geq 10^{6}\\cdot 99,990,200,240,100 \\approx 9.999\\times 10^{19}.\n$$\n\n使用素数定理作为一个保守估计，$[M,2M]$ 中的素数数量 $P(M)$ 满足 $P(M)\\approx \\frac{M}{\\ln M}$；一个保守的下界是 $P(M)\\gtrsim \\frac{M}{\\ln(2M)}$。我们需要选择 $M$ 为满足以下条件的最小的10的整数次幂：\n$$\n\\frac{M}{\\ln(2M)}\\geq 9.999\\times 10^{19}.\n$$\n测试 $M=10^{21}$：\n$$\n\\frac{10^{21}}{\\ln(2\\times 10^{21})}=\\frac{10^{21}}{\\ln 2+21\\ln 10}\\approx \\frac{10^{21}}{49.047}\\approx 2.04\\times 10^{19}<9.999\\times 10^{19},\n$$\n所以 $10^{21}$ 是不够的。测试 $M=10^{22}$：\n$$\n\\frac{10^{22}}{\\ln(2\\times 10^{22})}=\\frac{10^{22}}{\\ln 2+22\\ln 10}\\approx \\frac{10^{22}}{51.350}\\approx 1.95\\times 10^{20}\\geq 9.999\\times 10^{19},\n$$\n所以 $M=10^{22}$ 足够了，并且是满足条件的最小的10的次幂。\n\n每个指纹的比特长度由可能约定的最大素数（最多为 $2M$）决定，因此\n$$\nb=\\left\\lceil \\log_{2}(2M)\\right\\rceil=\\left\\lceil \\log_{2}(2\\times 10^{22})\\right\\rceil\n=\\left\\lceil 1+22\\log_{2}10\\right\\rceil\n=\\left\\lceil 1+22\\cdot \\frac{\\ln 10}{\\ln 2}\\right\\rceil\n=\\left\\lceil 74.082417\\right\\rceil=75.\n$$\n在最坏情况下，由于 $p\\gg L$，所有 $L$ 个指纹在模 $p$ 意义下都是不同的，所以Alice发送 $L$ 个指纹。发送的比特总数是\n$$\nT=b\\cdot L=75\\cdot 999{,}951=74{,}996{,}325 \\approx 7.50\\times 10^{7}.\n$$\n用科学记数法表示并四舍五入到三位有效数字，\n$$\nT\\approx 7.50\\times 10^{7}.\n$$", "answer": "$$\\boxed{7.50 \\times 10^{7}}$$", "id": "1440992"}, {"introduction": "随机化不仅能用于比较对象，还能用来检测复杂的结构性质。本练习介绍了一种精巧的代数方法，用于检验一个整数集合中是否存在三项等差数列（3-AP）[@problem_id:1441012]。该协议的核心思想是构建一个多项式，其性质反映了集合的结构，并通过在一个随机点上求值来判断该多项式是否恒为零。通过解决这个问题，你将深入理解多项式恒等式检验（Polynomial Identity Testing）的威力，并亲身体验在有限域上分析多项式根以确定算法错误率的过程。", "problem": "一位算法设计者提出了一种称为 AP-Test 的随机化测试，用于检查一个整数集合 $S \\subseteq \\{0, 1, \\dots, N-1\\}$ 是否包含三项等差数列（3-AP）。一个 3-AP 是 $S$ 的一个包含三个不同元素的子集 $\\{x, y, z\\}$，其中一个元素是另外两个元素的平均数（例如，$x+z=2y$）。\n\nAP-Test 流程定义如下：\n1.  给定输入集合 S，选择一个素数 $p$ 使得 $N < p < 2N$。\n2.  从集合 $\\{1, 2, \\dots, p-1\\}$ 中均匀随机地选择一个整数 $r$。\n3.  该算法计算两个在模 $p$ 意义下的值：\n    $T = \\left(\\sum_{i \\in S} r^i\\right)^2 \\pmod{p}$\n    $C = \\sum_{i \\in S} r^{2i} \\pmod{p}$\n4.  如果 $T$ 与 $C$ 在模 $p$ 意义下不同余，算法输出“检测到 3-AP”。否则，它输出“未检测到 3-AP”。\n\n假设此测试在特定输入集 $S = \\{0, 1, 4, 5\\}$ 上执行，其全集大小参数为 $N=6$。事实是，这个集合 $S$ 不包含任何 3-AP。为该测试选择的素数是 $p=7$。\n\n对于这个实例，AP-Test 算法产生错误输出的概率是多少？请将您的答案表示为最简精确分数。", "solution": "问题要求计算给定实例的错误输出概率。输入集合是 $S = \\{0, 1, 4, 5\\}$，它不包含三项等差数列（3-AP）。因此，AP-Test 算法的正确输出是“未检测到 3-AP”。如果算法报告“检测到 3-AP”，则发生错误输出。\n\n根据流程，如果 $T \\not\\equiv C \\pmod{p}$，算法将输出“检测到 3-AP”。这是发生错误的条件。我们来分析这个条件。\n该测试涉及检查以下同余关系：\n$$ \\left(\\sum_{i \\in S} r^i\\right)^2 \\equiv \\sum_{i \\in S} r^{2i} \\pmod{p} $$\n如果此同余关系成立，算法输出“未检测到 3-AP”（正确输出），如果不成立，则输出“检测到 3-AP”（错误输出）。\n\n我们基于这个比较定义一个多项式 $P(z)$：\n$$ P(z) = \\left(\\sum_{i \\in S} z^i\\right)^2 - \\sum_{i \\in S} z^{2i} $$\n该算法的检查等同于测试 $P(r) \\equiv 0 \\pmod{p}$ 是否成立。\n如果 $P(r) \\not\\equiv 0 \\pmod{p}$，则发生错误输出。\n\n我们来展开多项式 $P(z)$：\n$$ P(z) = \\left(\\sum_{i \\in S} z^i\\right)\\left(\\sum_{j \\in S} z^j\\right) - \\sum_{k \\in S} z^{2k} $$\n$$ P(z) = \\sum_{i,j \\in S} z^{i+j} - \\sum_{k \\in S} z^{2k} $$\n第一个求和可以分为 $i=j$ 和 $i \\neq j$ 两种情况：\n$$ P(z) = \\left(\\sum_{k \\in S} z^{k+k} + \\sum_{i,j \\in S, i \\neq j} z^{i+j}\\right) - \\sum_{k \\in S} z^{2k} $$\n$$ P(z) = \\left(\\sum_{k \\in S} z^{2k}\\right) + \\sum_{i,j \\in S, i \\neq j} z^{i+j} - \\sum_{k \\in S} z^{2k} $$\n$$ P(z) = \\sum_{i,j \\in S, i \\neq j} z^{i+j} $$\n由于求和对于 $i$ 和 $j$ 是对称的，我们可以将其写为：\n$$ P(z) = 2 \\sum_{i,j \\in S, i<j} z^{i+j} $$\n\n现在，我们必须为特定集合 $S = \\{0, 1, 4, 5\\}$ 构建此多项式。满足 $i<j$ 的数对 $(i,j)$ 如下：\n- $(0, 1) \\implies i+j = 1$\n- $(0, 4) \\implies i+j = 4$\n- $(0, 5) \\implies i+j = 5$\n- $(1, 4) \\implies i+j = 5$\n- $(1, 5) \\implies i+j = 6$\n- $(4, 5) \\implies i+j = 9$\n\n将这些代入 $P(z)$ 的表达式中：\n$$ P(z) = 2(z^1 + z^4 + z^5 + z^5 + z^6 + z^9) = 2(z^9 + z^6 + 2z^5 + z^4 + z) $$\n测试在模 $p=7$ 下进行。随机整数 $r$ 从 $\\{1, 2, 3, 4, 5, 6\\}$ 中选取。根据费马小定理，对于此集合中的任何 $r$，都有 $r^{p-1} \\equiv r^6 \\equiv 1 \\pmod{7}$。这使我们可以在计算 $r$ 处的多项式值时进行简化。具体来说，$r^9 = r^{6+3} \\equiv 1 \\cdot r^3 = r^3 \\pmod{7}$。\n\n所以，对于 $r \\in \\{1, \\dots, 6\\}$，计算 $P(r)$ 模 7 等价于计算：\n$$ P(r) \\equiv 2(r^3 + 1 + 2r^5 + r^4 + r) \\pmod{7} $$\n如果 $P(r) \\equiv 0 \\pmod{7}$，则输出正确。由于 2 在模 7 意义下可逆，这等价于：\n$$ 2r^5 + r^4 + r^3 + r + 1 \\equiv 0 \\pmod{7} $$\n我们需要在集合 $\\{1, 2, 3, 4, 5, 6\\}$ 中找到该多项式的根的数量。我们来测试每个可能的 $r$ 值：\n- 对于 $r=1$：$2(1)^5 + (1)^4 + (1)^3 + 1 + 1 = 2+1+1+1+1 = 6 \\not\\equiv 0 \\pmod{7}$。\n- 对于 $r=2$：$2(32) + 16 + 8 + 2 + 1 = 64+16+8+2+1 = 91$。由于 $91 = 13 \\times 7$，所以 $91 \\equiv 0 \\pmod{7}$。因此，$r=2$ 是一个根。\n- 对于 $r=3$：$2(243) + 81 + 27 + 3 + 1 = 486+81+27+3+1 = 598$。$598 = 85 \\times 7 + 3$，所以 $598 \\equiv 3 \\pmod{7}$。\n- 对于 $r=4 \\equiv -3 \\pmod{7}$：$2(-3)^5 + (-3)^4 + (-3)^3 + (-3) + 1 = 2(-243) + 81 - 27 - 3 + 1 = -486+81-27-2 = -434$。由于 $434 = 62 \\times 7$，所以 $-434 \\equiv 0 \\pmod{7}$。因此，$r=4$ 是一个根。\n- 对于 $r=5 \\equiv -2 \\pmod{7}$：$2(-2)^5 + (-2)^4 + (-2)^3 + (-2) + 1 = 2(-32) + 16 - 8 - 2 + 1 = -64+16-8-1 = -57$。由于 $-57 = -9 \\times 7 + 6$，所以 $-57 \\equiv 6 \\pmod{7}$。\n- 对于 $r=6 \\equiv -1 \\pmod{7}$：$2(-1)^5 + (-1)^4 + (-1)^3 + (-1) + 1 = -2+1-1-1+1 = -2 \\equiv 5 \\pmod{7}$。\n\n我们在集合 $\\{1, 2, 3, 4, 5, 6\\}$ 中找到了该多项式的两个根：$r=2$ 和 $r=4$。\n如果 $r$ 是这两个根之一，算法会输出正确的结果（“未检测到 3-AP”）。$r$ 有 $p-1=6$ 种可能的选择，每种选择的概率相等，为 $1/6$。\n正确输出的概率是：\n$$ \\Pr(\\text{correct}) = \\frac{\\text{Number of roots}}{\\text{Number of choices for } r} = \\frac{2}{6} = \\frac{1}{3} $$\n题目要求的是错误输出的概率。当 $r$ 不是多项式的根时，就会发生这种情况。\n$$ \\Pr(\\text{incorrect}) = 1 - \\Pr(\\text{correct}) = 1 - \\frac{1}{3} = \\frac{2}{3} $$\nAP-Test 算法产生错误输出的概率是 $2/3$。", "answer": "$$\\boxed{\\frac{2}{3}}$$", "id": "1441012"}]}