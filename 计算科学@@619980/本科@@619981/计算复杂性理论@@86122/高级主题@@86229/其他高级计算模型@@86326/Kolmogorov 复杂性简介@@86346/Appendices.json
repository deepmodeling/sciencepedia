{"hands_on_practices": [{"introduction": "让我们从柯尔莫哥洛夫复杂性的一个基本性质开始。当我们引入一种简单、可预测的冗余形式（例如，将一个字符串复制一倍）时，其复杂性会发生什么变化？这个练习 [@problem_id:1429018] 探讨了这个问题，它有助于我们巩固一个核心思想：可计算的操作仅增加一个常数的复杂性开销，这揭示了真正的复杂性关乎信息内容，而非仅仅是字符串的长度。", "problem": "在算法信息论领域（理论计算机科学的一个分支），我们通过一个对象最短可能描述的长度来量化其复杂性。对于一个有限二进制字符串 $x$，其柯尔莫哥洛夫复杂度，记作 $K(x)$，是相对于一个固定的通用图灵机 $U$ 来定义的。它是指当作为输入提供给 $U$ 时，能使 $U$ 输出字符串 $x$ 然后停机的最短程序 $p$ 的长度（以比特为单位）。形式上，$K(x) = \\min\\{|p| : U(p)=x\\}$。尽管 $K(x)$ 的确切值取决于所选择的通用图灵机 $U$，但复杂度理论中的关键关系，例如上界和下界，在相差一个加性常数的情况下仍然成立。\n\n考虑一个数据处理任务，其中一个二进制字符串 $x$ 与自身连接形成一个新的字符串 $xx$。这是数据冗余的一个简单模型。我们对这个新的、更长的字符串的复杂性感兴趣。\n\n对于任何二进制字符串 $x$，下列哪个不等式表示字符串 $xx$ 的柯尔莫哥洛夫复杂度的最紧一般上界？在这些表达式中，$c$ 代表一个正常数，其值仅取决于通用图灵机 $U$ 的选择，而与字符串 $x$ 或其属性无关。\n\nA. $K(xx) \\le K(x) + c$\n\nB. $K(xx) \\le 2K(x) + c$\n\nC. $K(xx) \\le K(x)^2 + c$\n\nD. $K(xx) \\le K(x) + c \\log_2(|x|)$\n\nE. $K(xx) \\le |x| + c$", "solution": "设 $U$ 为一个固定的通用图灵机，$K(\\cdot)$ 为相关的（无前缀）柯尔莫哥洛夫复杂度。对于任意全可计算函数 $f$，存在一个常数 $c_{f}$（仅取决于 $f$ 和 $U$），使得\n$$\nK(f(x)) \\leq K(x) + c_{f}.\n$$\n这个标准上界的推导如下：设 $p$ 是用于 $x$ 的最短 $U$ 程序，因此 $|p| = K(x)$ 且 $U(p)=x$。固定一个常数长度的程序 $r_{f}$，其长度为 $|r_{f}|=c_{f}$，该程序在给定某个程序 $p$ 的描述后，模拟 $U(p)$ 以获得 $x$，然后计算并输出 $f(x)$。考虑连接后的代码 $r_{f}p$（因为我们使用无前缀描述，所以它是良构的），其长度为 $|r_{f}p| = |r_{f}| + |p| = c_{f} + K(x)$，并使 $U$ 输出 $f(x)$。因此\n$$\nK(f(x)) \\leq |r_{f}p| = K(x) + c_{f}.\n$$\n\n将此应用于 $f(y)=yy$（复制字符串）。由于 $f$ 是全可计算的，因此存在一个常数 $c$ 使得\n$$\nK(xx) \\leq K(x) + c.\n$$\n\n在相差一个加性常数的情况下，这个界基本上是紧的：定义函数 $g(z)$ 返回 $z$ 的前半部分。那么 $g$ 是全可计算的，且 $g(xx)=x$，因此根据相同的推理，存在一个常数 $c'$ 使得\n$$\nK(x) \\leq K(xx) + c'.\n$$\n因此，$K(xx) \\geq K(x) - c'$，这与上界结合表明，通常情况下 $K(xx) = K(x) \\pm O(1)$。在给定的选项中，这使得选项 A 成为最紧的一般上界；选项 B、C、D 和 E 则更松，因为它们分别比 $K(x)+c$ 多了一个额外的 $K(x)$ 项、一个二次项、一个增长的 $\\log_{2}(|x|)$ 项，或者用通常更大的 $|x|$ 替换了 $K(x)$。", "answer": "$$\\boxed{A}$$", "id": "1429018"}, {"introduction": "在探讨了简单的冗余之后，我们现在来审视结构所扮演的角色。这个练习 [@problem_id:1429003] 考察了来自高度规则的语言 $L = \\{0^n 1^n\\}$ 的字符串。通过分析当给定字符串长度作为辅助信息时其复杂性如何变化，你将更深刻地体会到柯尔莫哥洛夫复杂性是如何量化可预测性，并区分结构化数据与随机噪声的。", "problem": "在算法信息论中，一个字符串 $s$ 的柯尔莫哥洛夫复杂度，记作 $K(s)$，是指能够输出 $s$ 的最短计算机程序的长度。这表示该字符串的最终压缩大小。条件柯尔莫哥洛夫复杂度 $K(s \\mid y)$ 是指在给定输入 $y$ 的情况下，能够产生 $s$ 的最短程序的长度。对于这些定义，我们假设存在一个固定的、最优的通用编程语言（或等价地，一个通用图灵机）。\n\n考虑上下文无关语言 $L = \\{0^n 1^n \\mid n \\ge 1\\}$，它由所有包含一个或多个零，后跟等量个一的字符串组成。\n\n假设 $x$ 是一个已知属于语言 $L$ 的字符串。对于所有这样的字符串 $x$，当其长度 $|x|$ 任意增大时，下列哪个陈述为条件柯尔莫哥洛夫复杂度 $K(x \\mid |x|)$ 提供了最紧且最精确的上界？在以下选项中，$c$、$c_1$ 和 $c_2$ 代表正常数，其值与具体字符串 $x$ 无关。\n\nA. $K(x \\mid |x|) \\le c_1 |x|^{1/2} + c_2$\n\nB. $K(x \\mid |x|) \\ge c_1 |x| - c_2$\n\nC. $K(x \\mid |x|) \\le c$\n\nD. $K(x \\mid |x|) \\le c_1 \\log_{2}(|x|) + c_2$", "solution": "设 $L=\\{0^{n}1^{n}\\mid n\\ge 1\\}$ 且 $x\\in L$。那么存在 $n\\ge 1$ 使得 $x=0^{n}1^{n}$，因此 $|x|=2n$。于是，给定长度 $|x|$，$n$ 的值由下式确定\n$$\nn=\\frac{|x|}{2}.\n$$\n根据相对于一个固定的最优通用机 $U$ 的条件柯尔莫哥洛夫复杂度的定义，我们有\n$$\nK(x\\mid y)=\\min\\{|p|:\\;U(p,y)=x\\}.\n$$\n考虑以下固定程序 $p$（在高层次上描述）：输入一个整数 $m$，计算 $m/2$ 并输出 $0^{m/2}1^{m/2}$。$p$ 的代码独立于 $m$ 和 $x$，因此 $|p|$ 是一个常数。对于任何 $|x|=m$ 的 $x\\in L$，将 $|x|$ 输入到 $p$ 中会产生 $x$，即 $U(p,|x|)=x$。因此，\n$$\nK(x\\mid |x|)\\le |p|=c,\n$$\n其中 $c$ 是一个仅依赖于通用机和固定程序的选择，且独立于 $x$ 和 $|x|$ 的常数。因此，对于所有 $x\\in L$，$K(x\\mid |x|)$ 存在一个常数上界，该上界对 $|x|$ 是一致的。\n\n在给定的选项中，陈述 C 精确地断言了这个常数上界。陈述 A 和 D 提供了随着 $|x|$ 增长的更弱（更松）的上界，而陈述 B 是一个下界，不是上界。由于对于每个偶数长度，在 $L$ 中恰好有一个字符串，所以这个常数界在渐近意义上是紧密的，只相差一个由通用机选择所固有的加法常数。\n\n因此，选项中最紧且最精确的上界是常数界。", "answer": "$$\\boxed{C}$$", "id": "1429003"}, {"introduction": "最后，让我们综合运用这些概念，来分析一个更复杂但仍具有完美结构的对象。这个问题 [@problem_id:1429007] 将挑战你估算一个由连续整数的二进制表示拼接而成的长字符串的可压缩性。这个练习通过展示如何量化一个字符串的表面大小与其真实最小描述长度之间的巨大差距，将理论与应用联系起来。", "problem": "在计算复杂性理论中，一个有限二进制字符串 $s$ 的柯尔莫哥洛夫复杂度，记作 $K(s)$，被定义为能够输出字符串 $s$ 然后停止的最短计算机程序（用一种固定的、通用的编程语言编写）的长度。这提供了一种衡量字符串算法信息内容的方法；如果 $K(s)$ 很小，则该字符串被认为是简单的；如果 $K(s)$ 接近其长度 $|s|$，则该字符串被认为是复杂的或随机的。\n\n考虑一个由拼接整数 1 到 $n$ 的标准二进制表示而形成的二进制字符串序列。设 $\\text{bin}(k)$ 为整数 $k$ 的不带任何前导零的二进制表示（例如，$\\text{bin}(1) = \\text{\"1\"}$，$\\text{bin}(2) = \\text{\"10\"}$，$\\text{bin}(6) = \\text{\"110\"}$）。\n设 $S_n$ 是由拼接这些二进制表示形成的字符串：\n$$S_n = \\text{bin}(1) \\text{bin}(2) \\text{bin}(3) \\dots \\text{bin}(n)$$\n\n对于非常大的 $n$，$S_n$ 字符串是高度结构化的，因此是可压缩的。其可压缩程度可以通过其长度与柯尔莫哥洛夫复杂度之差 $|S_n| - K(S_n)$ 来量化。\n\n求这种可压缩性的主阶渐近行为。也就是说，找到一个包含 $n$ 和标准数学函数的简单函数 $f(n)$，使得：\n$$ \\lim_{n \\to \\infty} \\frac{|S_n| - K(S_n)}{f(n)} = 1 $$\n你的答案应该是这个函数 $f(n)$。对于你对 $K(S_n)$ 的估计，你可以假设对于大的 $n$，其复杂度主要由指定 $n$ 本身所需的信息决定，并且生成算法逻辑的复杂度相比之下可以忽略不计。你可以在最终表达式中使用以 2 为底的对数。", "solution": "我们首先计算拼接后的二进制字符串的长度。一个整数 $k$ 的标准二进制表示的比特数是 $\\lfloor \\log_{2} k \\rfloor + 1$。因此，\n$$\n|S_{n}|=\\sum_{k=1}^{n}\\big(\\lfloor \\log_{2} k \\rfloor + 1\\big)=n+\\sum_{k=1}^{n}\\lfloor \\log_{2} k \\rfloor.\n$$\n由于对每个 $k$ 都有 $0 \\leq \\log_{2} k - \\lfloor \\log_{2} k \\rfloor  1$，\n$$\n\\sum_{k=1}^{n}\\lfloor \\log_{2} k \\rfloor=\\sum_{k=1}^{n}\\log_{2} k+O(n)=\\log_{2}(n!)+O(n).\n$$\n因此，\n$$\n|S_{n}|=\\log_{2}(n!)+O(n).\n$$\n使用以 2 为底的 Stirling 近似，\n$$\n\\log_{2}(n!)=n\\log_{2} n-(\\log_{2} e)\\,n+\\frac{1}{2}\\log_{2}(2\\pi n)+o(1),\n$$\n所以\n$$\n|S_{n}|=n\\log_{2} n+n\\big(1-\\log_{2} e\\big)+\\frac{1}{2}\\log_{2}(2\\pi n)+o(1).\n$$\n特别地，\n$$\n\\frac{|S_{n}|}{n\\log_{2} n}\\to 1 \\quad \\text{当 } n\\to\\infty.\n$$\n\n接下来，要输出 $S_{n}$，只需提供 $n$ 和一个从 1 循环到 $n$ 并打印 $\\text{bin}(k)$ 的固定程序即可；根据给定的假设，该逻辑的描述长度可以忽略不计，而柯尔莫哥洛夫复杂度主要由指定 $n$ 所需的信息决定。因此，\n$$\nK(S_{n})=K(n)+O(1)=\\Theta(\\log_{2} n),\n$$\n所以\n$$\n\\frac{K(S_{n})}{n\\log_{2} n}\\to 0 \\quad \\text{当 } n\\to\\infty.\n$$\n\n综合起来，\n$$\n\\frac{|S_{n}|-K(S_{n})}{n\\log_{2} n}=\\frac{|S_{n}|}{n\\log_{2} n}-\\frac{K(S_{n})}{n\\log_{2} n}\\to 1-0=1.\n$$\n因此，一个有效的主阶归一化函数是\n$$\nf(n)=n\\log_{2} n.\n$$", "answer": "$$\\boxed{n \\log_{2} n}$$", "id": "1429007"}]}