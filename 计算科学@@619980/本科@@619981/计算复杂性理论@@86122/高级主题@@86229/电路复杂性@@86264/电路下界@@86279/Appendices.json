{"hands_on_practices": [{"introduction": "我们从一个基础练习开始。证明即便是最简单的函数，例如逻辑与（AND），也存在一个最小的资源需求，这是踏入电路下界世界的第一步。这个练习 [@problem_id:1414757] 旨在介绍一种强大且通用的证明技术，该技术基于追踪输入信息如何在电路中传播，从而为任何可能的电路设计建立一个不可逾越的限制。", "problem": "一位硬件设计师正在构建一个定制的超大规模集成电路 (VLSI) 芯片。该芯片的一个核心组件必须计算 $n$ 个不同输入信号 $x_1, x_2, \\ldots, x_n$ 的逻辑合取（即与函数）。由于特定的设计约束，该设计师被限制只能使用“单调”逻辑。单调电路是仅由与门和或门构成的电路，它不包含任何非门。设计师可用的构建模块是扇入为二的标准门（即，每个门正好接收两个输入）。当且仅当所有 $n$ 个输入信号都为 '1' 时，该电路必须输出值 '1'。设计师的目标是最小化用于实现此函数的门的总数，因为这直接影响芯片的成本和功耗。尽管一个简单的与门链提供了一种可能的实现方式，但这是否是最高效的方式并不显而易见，特别是在或门也可用且输入可以扇出到多个门的情况下。请确定构建一个计算 $n$ 个变量逻辑与的单调电路所需的双输入门的绝对最小数量。请将您的答案表示为 $n$ 的函数。", "solution": "我们要仅使用双输入单调门（与门和或门）来计算 $f(x_{1},\\ldots,x_{n})=x_{1}\\wedge x_{2}\\wedge\\cdots\\wedge x_{n}$，并且必须最小化门的总数。\n\n对于电路中的每个节点 $v$，定义其支持集 $S(v)\\subseteq\\{x_{1},\\ldots,x_{n}\\}$ 为在节点 $v$ 处计算的布尔函数实际依赖的输入变量集合；等价地，$S(v)$ 是存在到 $v$ 的有向路径的那些输入的集合。对于一个输入节点 $x_{i}$，我们有 $S(x_{i})=\\{x_{i}\\}$。对于任意一个双输入单调门 $w=u_{1}\\circ u_{2}$，其中 $\\circ\\in\\{\\wedge,\\vee\\}$，其支持集满足\n$$\nS(w)=S(u_{1})\\cup S(u_{2}),\n$$\n因为在节点 $w$ 处的函数依赖于某个变量，当且仅当它的至少一个输入依赖于该变量。\n\n令 $d(v)=|S(v)|$ 表示影响 $v$ 的不同输入变量的数量。那么对于输入有 $d(x_{i})=1$，对于任意门 $w=u_{1}\\circ u_{2}$ 我们有\n$$\nd(w)=|S(u_{1})\\cup S(u_{2})|\\leq d(u_{1})+d(u_{2}).\n$$\n\n令 $g(v)$ 表示节点 $v$ 的传递扇入（子电路）中的门数。对于一个输入，$g(x_{i})=0$。对于一个门 $w=u_{1}\\circ u_{2}$，子电路的门数满足\n$$\ng(w)=g(u_{1})+g(u_{2})+1.\n$$\n我们断言对于每个节点 $v$，都有\n$$\ng(v)\\geq d(v)-1.\n$$\n我们通过结构归纳法证明这一点。对于一个输入 $x_{i}$，$g(x_{i})=0$ 且 $d(x_{i})=1$，因此 $0\\geq 1-1$ 成立。对于一个门 $w=u_{1}\\circ u_{2}$，\n$$\ng(w)=g(u_{1})+g(u_{2})+1\\geq (d(u_{1})-1)+(d(u_{2})-1)+1=d(u_{1})+d(u_{2})-1\\geq d(w)-1,\n$$\n这里使用了归纳假设以及 $d(w)\\leq d(u_{1})+d(u_{2})$。这就证明了该断言。\n\n将此结论应用于计算 $f(x_{1},\\ldots,x_{n})=x_{1}\\wedge\\cdots\\wedge x_{n}$ 的电路的输出节点 $o$。该函数依赖于所有 $n$ 个输入，所以 $d(o)=n$。因此，\n$$\ng(o)\\geq n-1.\n$$\n这是对于任何计算 $n$ 元与函数的双输入单调电路的普适下界。\n\n通过一个由与门构成的二叉树（或链）可以达到 $n-1$ 个门的上界。该结构将 $n$ 个输入两两组合，直到产生单个输出，这恰好使用了 $n-1$ 个与门。或门不能减少这个数量：上述下界对与门和或门的任何混合都成立，因为它只用到了在双输入单调门下支持集合并这一事实。\n\n因此，所需的双输入门的绝对最小数量是 $n-1$。对于 $n=1$ 的情况，结果为 $0$，这也是正确的，因为输出可以不通过任何门直接连接到 $x_{1}$。", "answer": "$$\\boxed{n-1}$$", "id": "1414757"}, {"introduction": "在掌握了基本下界之后，我们转向一个在计算复杂性理论中至关重要的问题：团问题（$CLIQUE$）。这个练习 [@problem_id:1431925] 的目的不是证明一个复杂的下界，而是让你亲手将一个图论属性转化为布尔公式。通过为一个小规模实例构建公式，你将对为何 $CLIQUE$ 对于单调电路而言是一个棘手的函数获得宝贵的直观理解。", "problem": "在计算复杂性研究中，$CLIQUE_{k,n}$ 布尔函数是一个核心研究对象。该函数建模了在一个包含 $n$ 个顶点的更大图中寻找一个 $k$-团（一个大小为 $k$ 的完全子图）的问题。\n\n考虑一个有 4 个顶点（标记为 $\\{1, 2, 3, 4\\}$）的图。该图的结构由一组布尔输入变量 $x_{i,j}$（$1 \\le i < j \\le 4$）描述。如果顶点 $i$ 和 $j$ 之间有边连接，则变量 $x_{i,j}$ 为 1，否则为 0。\n\n设 $f$ 是布尔函数 $CLIQUE_{3,4}$，当且仅当由输入所定义的图包含一个 3-团（一个三角形）时，该函数输出 1。如果一个函数将任意输入从 0 变为 1 时，其输出只可能从 0 变为 1，而绝不会从 1 变为 0，则称该函数是单调的。所有 $CLIQUE$ 函数都是单调的。单调函数可以用只包含与（$\\land$）和或（$\\lor$）运算，而不包含非（$\\neg$）运算的公式来表示。\n\n对于含 4 个顶点的图，一个关键性质是：这样的图包含一个 3-团，当且仅当它不是 2-可着色的。如果一个图的顶点集可以被划分为两个不相交的非空子集 $V_1$ 和 $V_2$，使得 $V_1$ 内的任意两个顶点之间没有边连接，且 $V_2$ 内的任意两个顶点之间也没有边连接，则该图被定义为 2-可着色（或二分图）。\n\n你的任务是为函数 $f = CLIQUE_{3,4}$ 推导出其最小单调和之积（POS）范式。POS 范式，也称为合取范式（CNF），是子句的合取（与运算），其中每个子句是变量的析取（或运算）。一个最小单调 POS 范式是指一个能正确表示该函数的范式，并且从该范式中移除任何子句中的任何变量，或移除任何子句，都会改变它所计算的函数。\n\n根据你推导出的范式，确定文字出现次数的总数。一次文字出现是指一个变量在范式中的单次出现。例如，范式 $(x_{1,2} \\lor x_{1,3}) \\land (x_{1,2})$ 中有 3 次文字出现。", "solution": "我们将六个边变量标记为 $x_{i,j}$（$1 \\leq i < j \\leq 4$），其中 $x_{i,j}=1$ 意味着边 $\\{i,j\\}$ 存在。函数 $f=CLIQUE_{3,4}$ 是单调的，且当且仅当图包含一个三角形时输出 1。对于含 4 个顶点的图，一个图包含三角形当且仅当它不是 2-可着色的。因此，可以通过禁止 2-可着色性来获得 $f$ 的一个单调 POS (CNF) 范式：对于每个顶点集的无序二划分 $V=V_{1}\\cup V_{2}$（其中 $V_{1},V_{2}\\neq \\emptyset$），我们要求 $V_{1}$ 内部或 $V_{2}$ 内部至少要有一条边存在。每一个这样的二划分都会产生一个子句：\n$$\n\\bigvee_{\\{i,j\\}\\subseteq V_{1}} x_{i,j}\\ \\lor\\ \\bigvee_{\\{i,j\\}\\subseteq V_{2}} x_{i,j}.\n$$\n\n对于 $V=\\{1,2,3,4\\}$，恰好存在 7 个非空的无序二划分：四个是 $1\\text{-}3$ 类型的，三个是 $2\\text{-}2$ 类型的。写出所有相应的子句，便得到最小单调 POS 范式：\n$$\n\\begin{aligned}\nf \\equiv\\ & (x_{1,2} \\lor x_{1,3} \\lor x_{2,3}) \\land (x_{1,2} \\lor x_{1,4} \\lor x_{2,4}) \\\\\n& \\land (x_{1,3} \\lor x_{1,4} \\lor x_{3,4}) \\land (x_{2,3} \\lor x_{2,4} \\lor x_{3,4}) \\\\\n& \\land (x_{1,2} \\lor x_{3,4}) \\land (x_{1,3} \\lor x_{2,4}) \\land (x_{1,4} \\lor x_{2,3}).\n\\end{aligned}\n$$\n\n正确性：如果图满足所有子句，那么对于任意二划分都至少存在一条内部边，因此该图不是 2-可着色的。在 4 个顶点的情况下，不是 2-可着色就意味着图包含一个三角形，因此 $f=1$。反之，如果图包含一个由顶点 $\\{a,b,c\\}$ 构成的三角形，那么在对顶点集进行的任何二划分中，$a,b,c$ 中必有两个顶点会落在同一个部分，因此 $x_{a,b},x_{a,c},x_{b,c}$ 中至少有一个会出现在对应的子句中且其值为 1。因此所有子句都被满足，范式输出 1。\n\n子句的最小性：没有子句可以被移除。对于一个 $1\\text{-}3$ 类型的子句，比如 $(x_{1,2} \\lor x_{1,3} \\lor x_{2,3})$，我们考虑以顶点 4 为中心的星形图 $K_{1,3}$，它是一个二分图：设 $x_{1,4}=x_{2,4}=x_{3,4}=1$ 且 $x_{1,2}=x_{1,3}=x_{2,3}=0$。这个赋值会使得该子句为假，而所有其他子句都为真，并且 $f=0$。移除该子句将会导致错误地接受这个输入。对于一个 $2\\text{-}2$ 类型的子句，例如 $(x_{1,2} \\lor x_{3,4})$，我们考虑划分 $\\{1,2\\}\\mid\\{3,4\\}$ 上的完全二分图 $K_{2,2}$：设 $x_{1,3}=x_{1,4}=x_{2,3}=x_{2,4}=1$ 且 $x_{1,2}=x_{3,4}=0$。这会使得该子句为假，而所有其他子句都为真，并且 $f=0$。因此，每个子句都是必需的。\n\n子句内文字的最小性：从一个子句中移除一个文字会使范式更强（即更难满足），因此要证明每个文字的必要性，我们只需展示一个包含三角形的图，在该图中，对应的子句仅因为该文字的存在才得以满足。例如，在子句 $(x_{1,2} \\lor x_{1,3} \\lor x_{2,3})$ 中，考虑一个只包含三角形 $\\{1,2,4\\}$ 的图（即设 $x_{1,2}=x_{1,4}=x_{2,4}=1$，其他三条边为 0），该图仅通过 $x_{1,2}$ 满足此子句。移除 $x_{1,2}$ 将导致该子句为假，从而使得整个范式对于一个真输入（一个有三角形的图）为假。对于每个子句中的每个文字都存在类似的见证（例如，对于其他文字，可以分别使用三角形 $\\{1,3,4\\}$ 或 $\\{2,3,4\\}$；对于一个 $2\\text{-}2$ 类型的子句 $(x_{a,b}\\lor x_{c,d})$，包含 $\\{a,b\\}$ 或 $\\{c,d\\}$ 的三角形可以作为见证其必要性）。因此，没有文字可以被移除。\n\n计算文字出现次数：有四个 $1\\text{-}3$ 类型的子句，每个包含 3 个文字，总共贡献了 $4 \\times 3 = 12$ 次出现；有三个 $2\\text{-}2$ 类型的子句，每个包含 2 个文字，总共贡献了 $3 \\times 2 = 6$ 次出现。文字出现的总次数为 $12+6=18$。", "answer": "$$\\boxed{18}$$", "id": "1431925"}, {"introduction": "一个函数的复杂性不仅取决于函数本身，还取决于我们选择如何表示它。这个练习 [@problem_id:1414726] 通过一个特殊的函数鲜明地揭示了这一点，该函数在一种形式（析取范式 DNF）下表达起来非常简洁，但在另一种形式（合取范式 CNF）下却需要指数级的规模。通过这个对比，你将深刻体会到电路结构和表示方式在决定计算复杂性时的关键作用。", "problem": "在计算复杂性理论中，理解表示一个布尔函数所需的资源是一项基本任务。同一个函数的不同表示形式可能在大小上差异巨大。考虑一个布尔函数，它作用于 $n=m^2$ 个变量，其中 $m$ 是一个大于 1 的整数。这些变量表示为 $x_{i,j}$ (对于 $1 \\le i, j \\le m$)，可以概念性地排列成一个 $m \\times m$ 的网格。\n\n让我们定义“列满”(Column-Complete)函数 $f_m$，当且仅当网格中存在至少一列 $j$，该列中的所有变量都为 TRUE 时，该函数输出 TRUE。也就是说，如果存在一个 $j \\in \\{1, \\dots, m\\}$ 使得对于所有的 $i \\in \\{1, \\dots, m\\}$ 都有 $x_{i,j}=1$，则 $f_m(x_{1,1}, \\dots, x_{m,m}) = 1$。否则，$f_m = 0$。\n\n一个布尔函数可以表示为析取范式 (DNF)，即与项的或（例如 $(x_1 \\land x_2) \\lor (x_3 \\land x_4)$）；或者表示为合取范式 (CNF)，即或项的与（例如 $(x_1 \\lor x_2) \\land (x_3 \\lor x_4)$）。DNF 表示的大小是它包含的与项的数量。CNF 表示的大小是它包含的或子句的数量。\n\n设 $S_{DNF}$ 为函数 $f_m$ 的最小 DNF 表示的大小，设 $S_{CNF}$ 为 $f_m$ 的最小 CNF 表示的大小。\n\n确定比率 $\\frac{S_{CNF}}{S_{DNF}}$ 作为 $m$ 的函数。", "solution": "问题要求计算“列满”函数 $f_m$ 的最小合取范式 (CNF) 和最小析取范式 (DNF) 的大小之比。函数 $f_m$ 作用于 $n=m^2$ 个变量 $x_{i,j}$ (其中 $1 \\le i, j \\le m$)，其定义为：当且仅当存在一列 $j$，该列中所有变量 $x_{i,j}$ 均为 TRUE 时，函数值为 TRUE。\n\n**步骤1：确定最小 DNF 表示的大小，$S_{DNF}$。**\n\n函数 $f_m$ 的定义可以直接转换成一个逻辑表达式。条件“第 $j$ 列中的所有变量都为 TRUE”可以写成与项 $C_j = x_{1,j} \\land x_{2,j} \\land \\dots \\land x_{m,j} = \\bigwedge_{i=1}^{m} x_{i,j}$。\n\n如果存在*至少一个*这样的列，函数 $f_m$ 就为 TRUE。这对应于对所有可能的列进行或运算。\n$$f_m = C_1 \\lor C_2 \\lor \\dots \\lor C_m = \\bigvee_{j=1}^{m} C_j = \\bigvee_{j=1}^{m} \\left( \\bigwedge_{i=1}^{m} x_{i,j} \\right)$$\n该表达式是合取项（ANDs）的析取（OR），根据定义，这是一个 DNF。这个 DNF 的大小，以与项的数量来衡量，是 $m$。\n\n为了证明这是最小 DNF，我们必须论证不存在更小的 DNF。$f_m$ 的任何 DNF 中的项都必须是 $f_m$ 的一个素蕴涵项 (prime implicant)。如果 $T=1$ 蕴涵 $f_m=1$，那么项 $T$ 就是一个蕴涵项 (implicant)。让我们考虑我们的一个项，$C_j = \\bigwedge_{i=1}^{m} x_{i,j}$。如果我们从这个项中移除任何一个变量，比如 $x_{k,j}$，我们会得到一个新项 $T' = \\bigwedge_{i=1, i\\neq k}^{m} x_{i,j}$。我们可以构造一个变量赋值，使得 $T'=1$ 但 $f_m=0$。例如，将 $T'$ 中的所有变量设为 1，将 $x_{k,j}$ 设为 0，并将网格中所有其他变量设为 0。在这种赋值下，$T'=1$，但没有一列是全为1的（第 $j$ 列不是，因为 $x_{k,j}=0$，其他列也不是），所以 $f_m=0$。因此，$T'$ 不是 $f_m$ 的蕴涵项。这表明每个项 $C_j$ 都是一个素蕴涵项，因为不能从中移除任何文字 (literal)。$f_m$ 的任何有效 DNF 都必须是覆盖该函数的素蕴涵项之和。由于每个 $C_j$ 覆盖了一组任何其他 $C_k$ 都未覆盖的可满足赋值（例如，只有第 $j$ 列全为1的赋值），因此所有 $m$ 个项都是必需的。\n因此，$f_m$ 的最小 DNF 正是我们写下的那个。其大小为：\n$$S_{DNF} = m$$\n\n**步骤2：确定最小 CNF 表示的大小，$S_{CNF}$。**\n\nCNF 是或项的与。我们可以通过应用分配律 $(A \\land B) \\lor C = (A \\lor C) \\land (B \\lor C)$ 从我们找到的 DNF 推导出 CNF。对我们的 DNF 重复应用此法则等价于一个更通用的规则。\n我们的 DNF 是 $f_m = C_1 \\lor C_2 \\lor \\dots \\lor C_m$，其中每个 $C_j$ 是文字的合取，$C_j = \\{x_{1,j}, x_{2,j}, \\dots, x_{m,j}\\}$。为了将其转换为 CNF，我们通过从每个项 $C_1, C_2, \\dots, C_m$ 中各选取一个文字并将它们进行或运算来形成新的子句。\n得到的 CNF 中的一个通用子句将具有以下形式：\n$$K = (y_1 \\lor y_2 \\lor \\dots \\lor y_m)$$\n其中 $y_1$ 是来自 $C_1$ 的一个变量，$y_2$ 是来自 $C_2$ 的一个变量，以此类推。\n从项 $C_j$ 中可用的变量是 $\\{x_{1,j}, x_{2,j}, \\dots, x_{m,j}\\}$。对于每个 $y_j$ 都有 $m$ 种选择。\n所以，CNF 中的一个子句看起来像这样：\n$$(x_{i_1, 1} \\lor x_{i_2, 2} \\lor \\dots \\lor x_{i_m, m})$$\n其中每个索引 $i_k$ 可以是 $1$ 到 $m$ 之间的任意整数。\n\n为了找到这类子句的总数，我们计算从 $m$ 个列项中各选一个变量的方式数。\n- 对于第一个项 $C_1$，我们有 $m$ 种变量选择（任何 $x_{i,1}$）。\n- 对于第二个项 $C_2$，我们有 $m$ 种变量选择（任何 $x_{i,2}$）。\n- ...\n- 对于第 $m$ 个项 $C_m$，我们有 $m$ 种变量选择（任何 $x_{i,m}$）。\n\n由于对每个项的选择是独立的，所以不同子句的总数是每个项选择数的乘积：\n$$S_{CNF} = m \\times m \\times \\dots \\times m \\quad (m \\text{ times})$$\n$$S_{CNF} = m^m$$\n\n为了确认这是最小 CNF，可以论证这 $m^m$ 个子句中的每一个都是 $f_m$ 的素蕴含子句 (prime implicate)。一个蕴含子句 (implicate) 是一个被 $f_m$ 所蕴含的子句 $K$，意味着如果 $f_m=1$，则 $K=1$。这等价于说如果 $K=0$，则 $f_m=0$。\n考虑一个子句 $K = (x_{i_1, 1} \\lor x_{i_2, 2} \\lor \\dots \\lor x_{i_m, m})$。如果我们设 $K=0$，这意味着我们设 $x_{i_1, 1}=0, x_{i_2, 2}=0, \\dots, x_{i_m, m}=0$。这个赋值确保了对于每一列 $j$，至少有一个变量（即 $x_{i_j, j}$）为 0。因此，不可能有任何一列全为 1，这意味着 $f_m=0$。所以，$K$ 是一个蕴含子句。这是一个素蕴含子句，因为从中移除任何变量都会破坏这个性质。例如，如果我们移除 $x_{i_1, 1}$，新的子句是 $K'=(x_{i_2, 2} \\lor \\dots \\lor x_{i_m, m})$。我们可以将 $K'$ 中的所有变量都设为 0，这使得 $K'=0$。但我们也可以将第 1 列中的所有变量都设为 1。这将使得 $f_m=1$。因此，$K'$ 不是一个蕴含子句。\n最小 CNF 是所有素蕴含子句的合取。我们已经找到了所有 $m^m$ 个。因此，最小 CNF 的大小是 $m^m$。\n\n**步骤3：计算比率。**\n\n现在我们计算比率 $\\frac{S_{CNF}}{S_{DNF}}$。\n$$ \\frac{S_{CNF}}{S_{DNF}} = \\frac{m^m}{m} = m^{m-1} $$\n这个比率表明，对于这个函数，其最小 DNF 和最小 CNF 的大小之间存在指数级的差距，因为指数的底数 $m$ 随着变量数量的增加而增长 ($m=\\sqrt{n}$)。", "answer": "$$\\boxed{m^{m-1}}$$", "id": "1414726"}]}