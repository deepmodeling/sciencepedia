{"hands_on_practices": [{"introduction": "许多现实世界的问题，从系统设计到任务调度，都涉及满足一系列约束条件。在我们能够分析一个问题的计算复杂性之前，我们必须首先学会将这些约束条件转化为精确的逻辑或数学形式。这项练习将为您提供在这一关键转化步骤中的实践机会，通过将描述性规则转换为形式化的布尔子句，您将为解决计算理论中更复杂的问题打下坚实的基础。[@problem_id:1433475]", "problem": "一位系统架构师正在设计一个小型容错服务器网络。该网络由四台服务器组成，分别标记为 $s_1, s_2, s_3,$ 和 $s_4$。每台服务器可以配置为两种模式之一：“主用”(Primary)或“备用”(Backup)。为确保系统稳定并防止资源冲突，任何有效的网络配置都必须满足一组特定的依赖规则。\n\n依赖规则如下：\n1. 如果服务器 $s_1$ 配置为“主用”，那么服务器 $s_2$ 也必须配置为“主用”。\n2. 如果服务器 $s_2$ 配置为“主用”，那么服务器 $s_3$ 必须配置为“备用”。\n3. 如果服务器 $s_3$ 配置为“主用”，那么服务器 $s_1$ 必须配置为“备用”。\n4. 如果服务器 $s_4$ 配置为“备用”，那么服务器 $s_3$ 必须配置为“主用”。\n\n你的任务是确定这四台服务器满足所有这四条依赖规则的有效配置的总数。一个配置是为四台服务器中的每一台分配一种模式（“主用”或“备用”）。", "solution": "问题要求找出四台服务器的有效配置数量，其中每台服务器可以处于两种状态之一：“主用”或“备用”。我们有四条规则来约束可能的配置。\n\n首先，我们将此问题转化为布尔逻辑的语言。我们可以用一个布尔变量 $x_i$ 来表示每台服务器 $s_i$ 的状态。设当服务器 $s_i$ 为“主用”时，$x_i = \\text{TRUE}$，当服务器 $s_i$ 为“备用”时，$x_i = \\text{FALSE}$。\n\n现在，我们可以将这四条规则中的每一条都转换成一个逻辑子句。一个蕴含关系“如果 P，则 Q”在逻辑上等价于“(非 P) 或 Q”，我们可以记作 $\\neg P \\lor Q$。\n\n规则 1：“如果服务器 $s_1$ 是‘主用’ ($x_1$)，那么服务器 $s_2$ 是‘主用’ ($x_2$)。”\n这可以转化为蕴含式 $x_1 \\Rightarrow x_2$，等价于子句 $C_1: \\neg x_1 \\lor x_2$。\n\n规则 2：“如果服务器 $s_2$ 是‘主用’ ($x_2$)，那么服务器 $s_3$ 是‘备用’ ($\\neg x_3$)。”\n这可以转化为蕴含式 $x_2 \\Rightarrow \\neg x_3$，等价于子句 $C_2: \\neg x_2 \\lor \\neg x_3$。\n\n规则 3：“如果服务器 $s_3$ 是‘主用’ ($x_3$)，那么服务器 $s_1$ 是‘备用’ ($\\neg x_1$)。”\n这可以转化为蕴含式 $x_3 \\Rightarrow \\neg x_1$，等价于子句 $C_3: \\neg x_3 \\lor \\neg x_1$。\n\n规则 4：“如果服务器 $s_4$ 是‘备用’ ($\\neg x_4$)，那么服务器 $s_3$ 是‘主用’ ($x_3$)。”\n这可以转化为蕴含式 $\\neg x_4 \\Rightarrow x_3$，等价于子句 $\\neg(\\neg x_4) \\lor x_3$，可简化为 $C_4: x_4 \\lor x_3$。\n\n问题现在是找出布尔公式 $\\Phi = C_1 \\land C_2 \\land C_3 \\land C_4$ 的可满足赋值的数量。也就是说，我们需要找出有多少种 $x_1, x_2, x_3, x_4$ 的真值组合能使整个公式为 TRUE。\n\n由于只有4个变量，因此共有 $2^4 = 16$ 种可能的真值赋值。我们可以通过在真值表中枚举每一种情况来测试它们。在下表中，T 代表 TRUE (“主用”)，F 代表 FALSE (“备用”)。一个赋值是有效的，当且仅当所有四个子句 $C_1, C_2, C_3, C_4$ 的求值结果都为 TRUE。\n\n| 赋值 | $x_1$ | $x_2$ | $x_3$ | $x_4$ | $C_1: \\neg x_1 \\lor x_2$ | $C_2: \\neg x_2 \\lor \\neg x_3$ | $C_3: \\neg x_3 \\lor \\neg x_1$ | $C_4: x_4 \\lor x_3$ | 是否有效？ |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| 1 | F | F | F | F | T | T | T | F | 否 |\n| 2 | F | F | F | T | T | T | T | T | **是** |\n| 3 | F | F | T | F | T | T | T | T | **是** |\n| 4 | F | F | T | T | T | T | T | T | **是** |\n| 5 | F | T | F | F | T | T | T | F | 否 |\n| 6 | F | T | F | T | T | T | T | T | **是** |\n| 7 | F | T | T | F | T | F | T | T | 否 |\n| 8 | F | T | T | T | T | F | T | T | 否 |\n| 9 | T | F | F | F | F | T | T | F | 否 |\n| 10 | T | F | F | T | F | T | T | T | 否 |\n| 11 | T | F | T | F | F | T | F | T | 否 |\n| 12 | T | F | T | T | F | T | F | T | 否 |\n| 13 | T | T | F | F | T | T | T | F | 否 |\n| 14 | T | T | F | T | T | T | T | T | **是** |\n| 15 | T | T | T | F | T | F | F | T | 否 |\n| 16 | T | T | T | T | T | F | F | T | 否 |\n\n通过检查表中的“是否有效？”列，我们可以统计出使所有四个子句都为真的赋值数量。有效的赋值是：\n1. 赋值 2: $(x_1, x_2, x_3, x_4) = (\\text{F, F, F, T})$\n2. 赋值 3: $(x_1, x_2, x_3, x_4) = (\\text{F, F, T, F})$\n3. 赋值 4: $(x_1, x_2, x_3, x_4) = (\\text{F, F, T, T})$\n4. 赋值 6: $(x_1, x_2, x_3, x_4) = (\\text{F, T, F, T})$\n5. 赋值 14: $(x_1, x_2, x_3, x_4) = (\\text{T, T, F, T})$\n\n共有5个这样的赋值。因此，共有5种不同的服务器配置满足所有依赖规则。", "answer": "$$\\boxed{5}$$", "id": "1433475"}, {"introduction": "许多P完备问题的一个共同特征是表达式求值，其结构强制要求顺序执行。然而，并非所有的表达式求值问题都是“天生顺序”的，其运算符的底层属性可以从根本上改变问题的可并行性。这个思想实验挑战您超越问题的表面结构，通过分析 `max` 运算符的性质，您将发现为什么这个问题，尽管可能存在深度嵌套，却能够被高效地并行解决，因此它属于NC类，而不是P完备问题。[@problem_id:1433477]", "problem": "在计算复杂性理论中，我们研究解决计算问题所需的资源。**P**类包含所有可以由确定性顺序计算机在多项式时间内解决的判定问题。**NC**类（Nick's Class）是可在拥有多项式数量处理器的并行计算机上于多对数时间内解决的判定问题集合。NC类中的问题被认为是“可有效并行化的”。人们普遍认为NC是P的真子集。\n\n如果P类中的一个问题属于P类中最“难”的问题之一，那么它就被称为**P完全**问题。更形式化地说，P类中的任何其他问题都可以通过对数空间归约到该问题。P完全问题被认为是“内在顺序的”，并且极不可能属于NC类。如果发现任何P完全问题属于NC类，那将意味着P = NC。\n\n考虑**最大表达式求值问题（MEEP）**，其定义如下：给定一个包含一组整型变量 $x_1, x_2, \\dots, x_n$ 和二元运算符 `max(,)` 的完全括号化表达式，以及每个变量的整数值，计算该表达式的最终值。此类表达式的一个例子是 `max(x_1, max(max(x_2, x_3), x_4))`。\n\n根据所提供的定义，确定最大表达式求值问题（MEEP）最准确的分类。\n\nA. MEEP是P完全的，因为任意的括号嵌套强加了顺序求值顺序，这与其他P完全问题（如通用电路求值问题）类似。\n\nB. MEEP属于NC类，因为 `max` 运算符具有结合律，这使得计算可以被重构并有效地并行执行，而无需考虑初始的括号方式。\n\nC. MEEP不属于P类，因此不可能是P完全的，因为评估一个深度嵌套的表达式所需的步骤数与深度成正比，而深度可能与变量数量成指数关系。\n\nD. MEEP是#P完全的，因为该问题等价于计算在集合中找到最大元素所需的比较次数。\n\nE. MEEP仅在表达式对应于平衡二叉树时才属于NC类。对于任意嵌套（不平衡）的表达式，该问题是P完全的。", "solution": "给定一个在整型变量 $x_{1},\\dots,x_{n}$ 上使用二元运算符 $\\max(\\cdot,\\cdot)$ 的完全括号化表达式，要求我们计算其最终值。关键的代数性质是 $\\max$ 具有结合律和交换律：\n$$\n\\max(a,\\max(b,c))=\\max(\\max(a,b),c)=\\max(a,b,c),\n$$\n并且它也具有幂等性：\n$$\n\\max(a,a)=a.\n$$\n因此，对于任何仅由应用于 $\\{x_{1},\\dots,x_{n}\\}$ 中变量（可能重复）的 $\\max$ 构成的完全括号化表达式 $E$，其值仅取决于出现的变量的多重集，并等于这些值的全局最大值。等价地，\n$$\n\\mathrm{MEEP}(E)=\\max\\{x_{i} : x_{i} \\text{ appears in } E\\}.\n$$\n\n为了对该问题进行分类，我们观察到计算 $n$ 个整数的最大值是可有效并行化的。一个标准的并行归约算法使用 $O(n)$ 个处理器在 $O(\\log n)$ 时间内计算最大值：定义 $y_{i}^{(0)}=x_{i}$（对于 $1 \\le i \\le n$），并在每一轮 $t \\ge 1$ 中设置\n$$\ny_{i}^{(t)}=\\max\\bigl(y_{2i-1}^{(t-1)},\\,y_{2i}^{(t-1)}\\bigr)\n\\quad \\text{for} \\quad 1 \\le i \\le \\left\\lfloor \\frac{n}{2^{t}} \\right\\rfloor.\n$$\n经过 $T=\\lceil \\log_{2} n \\rceil$ 轮后，我们得到\n$$\ny_{1}^{(T)}=\\max_{1 \\le i \\le n} x_{i}.\n$$\n该算法在多对数时间内使用多项式数量的处理器运行，因此它属于 $NC$ 类。初始的括号方式不会限制并行求值，因为结合律保证了将其重新组合成平衡的归约树不会改变结果。\n\n因此：\n- 选项A是错误的：结合律打破了任何所谓的内在顺序性。\n- 选项C是错误的：任何此类表达式的深度最多与 $n$ 呈线性关系，并且在任何情况下我们都可以在多对数并行时间内求值。\n- 选项D是错误的：MEEP要求的是最大值，而不是一个计数；它不是一个计数问题，这里也没有到 $\\#P$ 函数的归约。\n- 选项E是错误的：即使对于不平衡的表达式，结合律也允许进行平衡的并行求值，因此该问题仍然属于 $NC$ 类。\n\n因此，最准确的分类是MEEP属于 $NC$ 类，因为结合律使得无论初始括号方式如何，都能进行有效的并行求值。", "answer": "$$\\boxed{B}$$", "id": "1433477"}, {"introduction": "现在我们来看一个真正体现P完备问题本质的经典问题：指针追踪。诸如寻找链表末端，或如此例中确定并查集数据结构中的最终根节点等问题，常常涉及每一步的输入是上一步输出的依赖关系。这个实践问题模拟了一系列不带“路径压缩”这一并行友好优化的 `union` 操作，通过手动追踪数据结构的变化，您将对“天生顺序”的含义以及为何这类问题难以并行化获得切实的理解。[@problem_id:1433739]", "problem": "在并行计算的研究中，理解顺序依赖至关重要。并查集数据结构是此类依赖的一个经典例子。考虑一个包含 $N=16$ 个元素的系统，索引从 0 到 15。这些元素通过一个并查集数据结构被组织成不相交的集合。\n\n最初，每个元素 $i \\in \\{0, 1, ..., 15\\}$ 各自属于一个集合。系统的状态由一个父节点数组 $p$ 和一个秩数组 $r$ 来维护。对于每个元素 $i$，$p[i]$ 是其父节点，$r[i]$ 是其秩。最初，对于所有的 $i$，$p[i] = i$ 并且 $r[i] = 0$。\n\n`find(i)` 操作通过遍历父指针，直到到达一个其父节点是自身的元素，从而返回包含元素 $i$ 的集合的代表元（或根）。在本问题中，`find` 操作**不**执行路径压缩。\n\n集合通过 `union(u, v)` 操作进行合并。该操作首先找到 $u$ 和 $v$ 的代表元，我们称之为 $r_u = \\text{find}(u)$ 和 $r_v = \\text{find}(v)$。如果 $r_u$ 和 $r_v$ 不同，则根据**按秩合并**的启发式方法和一个特定的平局打破规则来合并集合：\n- 如果 $r[r_u] < r[r_v]$，则将 $r_u$ 的父节点设置为 $r_v$。\n- 如果 $r[r_u] > r[r_v]$，则将 $r_v$ 的父节点设置为 $r_u$。\n- 如果 $r[r_u] = r[r_v]$，则将索引较小的根的父节点设置为索引较大的根，并将索引较大的根的秩加一。\n\n按给定顺序对系统执行一个包含 15 次 `union` 操作的特定序列：\n1.  `union(1, 0)`\n2.  `union(3, 2)`\n3.  `union(5, 4)`\n4.  `union(7, 6)`\n5.  `union(9, 8)`\n6.  `union(11, 10)`\n7.  `union(13, 12)`\n8.  `union(15, 14)`\n9.  `union(2, 0)`\n10. `union(6, 4)`\n11. `union(10, 8)`\n12. `union(14, 12)`\n13. `union(4, 0)`\n14. `union(12, 8)`\n15. `union(8, 0)`\n\n在完成这整个操作序列后，包含元素 7 的集合的代表元索引是多少？", "solution": "我们将通过给定的 15 个操作序列来追踪并查集数据结构的状态，特别是父节点数组 `p` 和秩数组 `r`。共有 $N=16$ 个元素，索引从 0 到 15。\n\n**初始状态：**\n每个元素都是自己的父节点，秩为 0。\n$p = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]$\n$r = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]$\n\n`find(i)` 操作从 $i$ 开始沿着父指针找到其根。由于没有路径压缩，它不会改变 `p` 数组。`union(u, v)` 操作根据其根的秩来合并 $u$ 和 $v$ 的集合，并遵循指定的平局打破规则：如果秩相等，则索引较小的根指向索引较大的根。\n\n**操作 1-8：成对合并**\n\n这些操作合并了相邻的元素对。在每种情况下，两个元素都是秩为 0 的根。应用平局打破规则。\n1. `union(1, 0)`：根是 1 和 0。秩相等 (0)。因为 $0 < 1$，我们设置 $p[0] = 1$ 并且 $r[1]$ 变为 1。\n2. `union(3, 2)`：根是 3 和 2。秩相等 (0)。因为 $2 < 3$，我们设置 $p[2] = 3$ 并且 $r[3]$ 变为 1。\n3. `union(5, 4)`：根是 5 和 4。秩相等 (0)。因为 $4 < 5$，我们设置 $p[4] = 5$ 并且 $r[5]$ 变为 1。\n4. `union(7, 6)`：根是 7 和 6。秩相等 (0)。因为 $6 < 7$，我们设置 $p[6] = 7$ 并且 $r[7]$ 变为 1。\n5. `union(9, 8)`：根是 9 和 8。秩相等 (0)。因为 $8 < 9$，我们设置 $p[8] = 9$ 并且 $r[9]$ 变为 1。\n6. `union(11, 10)`：根是 11 和 10。秩相等 (0)。因为 $10 < 11$，我们设置 $p[10] = 11$ 并且 $r[11]$ 变为 1。\n7. `union(13, 12)`：根是 13 和 12。秩相等 (0)。因为 $12 < 13$，我们设置 $p[12] = 13$ 并且 $r[13]$ 变为 1。\n8. `union(15, 14)`：根是 15 和 14。秩相等 (0)。因为 $14 < 15$，我们设置 $p[14] = 15$ 并且 $r[15]$ 变为 1。\n\n完成这 8 个操作后，奇数索引的元素成为秩为 1 的根，并且每个都是其前面偶数索引元素的父节点。\n- 根： {1, 3, 5, 7, 9, 11, 13, 15}\n- 秩：对于奇数 $i$，$r[i]=1$，否则为 0。\n- 根的父节点：对于奇数 $i$，$p[i]=i$。\n- 非根节点的父节点： $p[0]=1, p[2]=3, p[4]=5, p[6]=7, p[8]=9, p[10]=11, p[12]=13, p[14]=15$。\n\n**操作 9-12：第一层合并**\n\n这些操作合并上面创建的大小为 2 的集合。\n9. `union(2, 0)`：`find(2)` 的结果是 3。`find(0)` 的结果是 1。我们合并根 3 和 1。两者的秩都为 1。因为 $1 < 3$，我们设置 $p[1] = 3$ 并且 $r[3]$ 变为 2。\n10. `union(6, 4)`：`find(6)` 的结果是 7。`find(4)` 的结果是 5。我们合并根 7 和 5。两者的秩都为 1。因为 $5 < 7$，我们设置 $p[5] = 7$ 并且 $r[7]$ 变为 2。\n11. `union(10, 8)`：`find(10)` 的结果是 11。`find(8)` 的结果是 9。我们合并根 11 和 9。两者的秩都为 1。因为 $9 < 11$，我们设置 $p[9] = 11$ 并且 $r[11]$ 变为 2。\n12. `union(14, 12)`：`find(14)` 的结果是 15。`find(12)` 的结果是 13。我们合并根 15 和 13。两者的秩都为 1。因为 $13 < 15$，我们设置 $p[13] = 15$ 并且 $r[15]$ 变为 2。\n\n完成这 4 个操作后，我们得到 4 个集合，每个集合的大小为 4。\n- 根： {3, 7, 11, 15}\n- 秩：$r[3]=2, r[7]=2, r[11]=2, r[15]=2$。所有其他的秩为 0 或 1。\n- 现在父节点链更长了。例如，`find(0)` 遵循 $0 \\to 1 \\to 3$ 的路径。\n\n**操作 13-14：第二层合并**\n\n13. `union(4, 0)`：`find(4)` 遍历 $4 \\to 5 \\to 7$，所以根是 7。`find(0)` 遍历 $0 \\to 1 \\to 3$，所以根是 3。我们合并根 7 和 3。两者的秩都为 2。因为 $3 < 7$，我们设置 $p[3] = 7$ 并且 $r[7]$ 变为 3。\n14. `union(12, 8)`：`find(12)` 遍历 $12 \\to 13 \\to 15$，根是 15。`find(8)` 遍历 $8 \\to 9 \\to 11$，根是 11。我们合并根 15 和 11。两者的秩都为 2。因为 $11 < 15$，我们设置 $p[11] = 15$ 并且 $r[15]$ 变为 3。\n\n现在我们有两个大集合，每个的大小为 8。\n- 根： {7, 15}\n- 秩：$r[7]=3, r[15]=3$。\n\n**操作 15：最终合并**\n\n15. `union(8, 0)`：`find(8)` 遍历 $8 \\to 9 \\to 11 \\to 15$，根是 15。`find(0)` 遍历 $0 \\to 1 \\to 3 \\to 7$，根是 7。我们合并最后两个根，15 和 7。两者的秩都为 3。因为 $7 < 15$，我们设置 $p[7] = 15$ 并且 $r[15]$ 变为 4。\n\n**最终状态与答案**\n\n在所有操作之后，全部 16 个元素被合并到一个单一的根下。最后一个操作将根 7 的父节点设置为 15。因此，15 是所有元素的唯一代表元。\n\n问题要求的是包含元素 7 的集合的代表元。我们可以通过从 7 开始追踪父指针直到到达根来找到它。\n- 元素是 7。\n- 在所有操作之后，我们查看 $p[7]$。最后的操作设置了 $p[7] = 15$。\n- 然后我们查看 $p[15]$。由于 15 是最终的根，所以 $p[15]$ 仍然是 15。\n路径是 $7 \\to 15$。包含元素 7 的树的根是 15。", "answer": "$$\\boxed{15}$$", "id": "1433739"}]}