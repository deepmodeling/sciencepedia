{"hands_on_practices": [{"introduction": "我们从NC层级中最基础的一层——$NC^0$——开始我们的实践。这个练习将通过一个具体的编码转换问题，帮助你理解何为“高度局部化”的计算，以及为什么这类问题能够实现最大程度的并行处理。掌握$NC^0$的定义是理解整个并行计算复杂性层级结构的第一步。[@problem_id:1459534]", "problem": "在计算复杂性理论领域，NC层级（Nick's Class）用于对被认为是“可高效并行化”的问题进行分类。如果一个问题可以由一个规模为输入大小$n$的多项式、深度为多对数（具体为 $O(\\log^k n)$）的一致布尔电路族解决，那么该问题就属于类 $NC^k$。类 $NC^0$ 对应于可用恒定深度、多项式规模的电路解决的问题，其中每个输出位仅依赖于恒定数量的输入位。\n\n考虑将一个$n$位二进制整数转换为其对应的$n$位反射二进制码（也称为格雷码）的问题。设输入二进制表示为 $B = b_{n-1}b_{n-2}...b_1b_0$，输出格雷码为 $G = g_{n-1}g_{n-2}...g_1g_0$。转换规则定义如下：\n- 最高有效位保持不变：$g_{n-1} = b_{n-1}$。\n- 对于所有其他位（其中 $0 \\le i  n-1$），格雷码位是相应二进制位与下一个更高有效位的二进制位的异或（XOR）：$g_i = b_i \\oplus b_{i+1}$。\n\n根据所提供的定义，请确定此转换问题在 NC 层级中的最精确分类。\n\nA. 该问题在 $NC^0$ 中。\n\nB. 该问题在 $NC^1$ 中，但不在 $NC^0$ 中。\n\nC. 该问题在 $NC^2$ 中，但不在 $NC^1$ 中。\n\nD. 该问题是 $P$-完备的，因此据信不属于任何 $NC^k$ 类。\n\nE. 分类取决于 $n$ 是否为 2 的幂。", "solution": "题意要求我们在 NC 层级内，对从一个 $n$ 位二进制数 $B = b_{n-1}b_{n-2}\\dots b_{1}b_{0}$ 到其 $n$ 位格雷码 $G = g_{n-1}g_{n-2}\\dots g_{1}g_{0}$ 的映射进行分类，该映射定义为\n$$\ng_{n-1} = b_{n-1}, \\quad g_{i} = b_{i} \\oplus b_{i+1} \\quad \\text{for } 0 \\leq i  n-1.\n$$\n根据定义，如果存在一个一致的、有界扇入的布尔电路族来计算一个语言（或函数），且该电路族的规模为多项式，深度为 $O\\!\\left((\\log n)^{k}\\right)$，则该语言（或函数）属于 $NC^{k}$。类 $NC^{0}$ 由可通过一致的、恒定深度、多项式规模、有界扇入的电路族计算的函数组成，这等价于每个输出位仅依赖于 $O(1)$ 个输入位。\n\n对于每个满足 $0 \\leq i  n-1$ 的 $i$，输出位 $g_{i}$ 仅依赖于两个输入位 $b_{i}$ 和 $b_{i+1}$，而对于 $i = n-1$，我们有 $g_{n-1}$ 仅依赖于 $b_{n-1}$。因此，每个输出位都依赖于恒定数量的输入，该数量与 $n$ 无关。此外，每个 $g_{i}$ 都可以由一个基于 $\\{\\land,\\lor,\\neg\\}$ 的、恒定深度、有界扇入的电路计算，因为两个位的异或具有标准的布尔表达式\n$$\nb_{i} \\oplus b_{i+1} \\;=\\; (b_{i} \\land \\neg b_{i+1}) \\;\\lor\\; (\\neg b_{i} \\land b_{i+1}).\n$$\n此实现最多使用一层非门，其输出送入一层二元与门，再送入一个二元或门，从而得到恒定的深度（例如，扇入为2时深度为3）。最高有效位 $g_{n-1} = b_{n-1}$ 通过一根导线实现。因此，并行计算所有 $n$ 个输出位所得到的电路深度是一个与 $n$ 无关的固定常数，其规模为 $O(n)$，即 $n$ 的多项式。\n\n关于一致性，其布线模式是完全规则的：对于每个 $i$，计算 $g_{i}$ 的门仅连接到 $b_{i}$ 和 $b_{i+1}$（或在 $i = n-1$ 时仅连接到 $b_{n-1}$）。因此，一个标准的一致性条件（例如 DLOGTIME-uniformity）是满足的，因为一台确定性图灵机可以在给定以二进制编码的 $n$ 和门索引的情况下，在 $O(\\log n)$ 时间内计算出连接关系。\n\n因此，该转换映射可由一个一致的、恒定深度、多项式规模、有界扇入的布尔电路族计算，其中每个输出位依赖于 $O(1)$ 个输入位。所以该问题属于 $NC^{0}$。由于 $NC^{0} \\subseteq NC^{1} \\subseteq NC^{2} \\subseteq \\dots$，在给定的选项中，最精确的分类是它属于 $NC^{0}$。", "answer": "$$\\boxed{A}$$", "id": "1459534"}, {"introduction": "接下来，我们将挑战一个看似本质上是串行的问题，并探索如何为其设计一个高效的并行算法，从而进入$NC^1$的世界。这个“寻找第一个1”的问题将引导你思考如何重构计算过程以利用并行性，并引入一种强大的并行算法技巧——前缀计算。通过这个练习，你将体会到并行算法设计的精妙之处。[@problem_id:1459518]", "problem": "在并行计算领域，理解一个问题所固有的并行性对于设计高效算法至关重要。被称为尼克类（Nick's Class, NC）的复杂度类为此分析提供了一个框架。如果一个计算问题可以在并行计算机上，使用 $n$ 的多项式数量的处理器，在多对数时间内（即时间与 $O(\\log^k n)$ 成正比，其中 $k$ 为某个常数，$n$ 是输入规模）解决，那么该问题就属于 NC。更具体地说，如果一个问题的并行时间复杂度为 $O(\\log^k n)$，则它属于 $NC^k$。\n\n考虑基本的“找到第一个1”（First-One）问题，这是并行数据处理中一个常见的子程序。该问题定义如下：给定一个长度为 $n$ 的二进制字符串 $S$，表示为一个位数组 $S[1..n]$，找到使 $S[i]=1$ 成立的最小索引 $i$。如果字符串不包含'1'，则输出为0。\n\n根据这些定义，确定“找到第一个1”问题在 NC 层级结构中最精确的分类。\n\nA. 该问题属于 $NC^1$。\n\nB. 该问题是 $P$-完备的，这意味着它不太可能属于 NC。\n\nC. 即使在并行机上，该问题也需要 $\\Omega(n)$ 的时间来解决，因此不属于 NC。\n\nD. 该问题属于 $NC^2$ 但不属于 $NC^1$。", "solution": "我们回顾 NC 的定义：如果一个问题可以使用 $n$ 的多项式数量的处理器，在 $O(\\log^{k} n)$ 的时间内（对于某个固定的 $k \\in \\mathbb{N}$）解决，那么该问题就属于 NC。$NC^{1}$ 类包含那些可以使用多项式数量的处理器和有界扇入，以 $O(\\log n)$ 的深度解决的问题。\n\n我们为“找到第一个1”函数构建一个深度为 $O(\\log n)$ 的并行算法。设输入为 $S[1],\\dots,S[n] \\in \\{0,1\\}$。定义前缀或（prefix-OR）数组 $Q[1],\\dots,Q[n]$ 为\n$$\nQ[i] \\equiv \\bigvee_{j=1}^{i} S[j].\n$$\n布尔或运算是可结合的，因此我们可以使用标准的并行前缀方法，在 $O(\\log n)$ 的深度和多项式的工作量内计算出所有的 $Q[i]$。一种具体的方法是递归倍增法：定义对所有 $i$ 有 $R^{(0)}[i] = S[i]$，并且对于 $t=1,2,\\dots,\\lceil \\log_{2} n \\rceil$ 设置\n$$\nR^{(t)}[i] = \\begin{cases}\nR^{(t-1)}[i] \\lor R^{(t-1)}[i-2^{t-1}],  \\text{若 } i>2^{t-1},\\\\\nR^{(t-1)}[i],  \\text{其他情况}。\n\\end{cases}\n$$\n每个阶段只使用扇入为2的或门，因此具有常数深度，并且共有 $\\lceil \\log_{2} n \\rceil$ 个阶段。最后，对于所有 $i$ 都有 $Q[i] = R^{(\\lceil \\log_{2} n \\rceil)}[i]$，总深度为 $O(\\log n)$，每个阶段使用 $O(n)$ 个处理器，因此处理器总数是 $n$ 的多项式。\n\n引入 $Q[0] \\equiv 0$ 并定义标记数组 $M[1],\\dots,M[n]$ 为\n$$\nM[i] \\equiv S[i] \\land \\lnot Q[i-1] = Q[i] \\land \\lnot Q[i-1].\n$$\n根据构造，$M[i]=1$ 当且仅当 $i$ 是满足 $S[i]=1$ 的最小索引；否则 $M[i]=0$。如果字符串中没有1，则 $Q[n]=0$，因此对所有 $i$ 都有 $M[i]=0$。\n\n我们现在将索引编码为范围在 $\\{0,1,\\dots,n\\}$ 内的二进制数。设 $L \\equiv \\lceil \\log_{2}(n+1) \\rceil$。对于每个比特位 $b \\in \\{0,1,\\dots,L-1\\}$，定义第 $b$ 个输出比特 $B[b]$ 为\n$$\nB[b] \\equiv \\bigvee_{i=1}^{n} \\left( M[i] \\land \\mathrm{bit}_{b}(i) \\right),\n$$\n其中 $\\mathrm{bit}_{b}(i) \\in \\{0,1\\}$ 是 $i$ 的第 $b$ 个二进制位。由于最多只有一个 $M[i]$ 等于1，这些或-规约（OR-reductions）操作只是选择了那个唯一索引的比特位；如果所有的 $M[i]=0$，那么所有的 $B[b]=0$，表示0。每个 $B[b]$ 是对 $n$ 个项的或运算，这些项由扇入为2的或门构成一个平衡二叉树，其深度为 $O(\\log n)$。所有的 $L$ 个比特是并行计算的，所以这个阶段的深度仍然是 $O(\\log n)$，处理器数量为 $O(n L)$，这是 $n$ 的多项式。\n\n结合各个阶段，总的并行时间（电路深度）为\n$$\nO(\\log n) + O(1) + O(\\log n) = O(\\log n),\n$$\n使用的处理器数量是 $n$ 的多项式，并且门是有限扇入的。因此，“找到第一个1”问题属于 $NC^{1}$。\n\n这表明选项A是正确的。选项B是错误的，因为该问题不是$P$-完备的；它有一个 $NC^{1}$ 算法。选项C是错误的，因为上述算法在并行机上以 $O(\\log n)$ 的时间运行。选项D是错误的，因为我们已经展示了一个 $NC^{1}$ 算法；此外，已知的类分离结果并未将其置于 $NC^{1}$ 之外。", "answer": "$$\\boxed{A}$$", "id": "1459518"}, {"introduction": "在掌握了如何对具体问题进行分类后，我们来探讨一个更深层次的结构性问题。这个练习不关注单个算法，而是研究$NC^1$这个复杂性类别本身的性质：当我们将两个高效的并行算法链接在一起时，得到的组合算法是否仍然是高效并行的？理解函数组合下的闭包性质，对于模块化地构建复杂并行系统至关重要。[@problem_id:1459527]", "problem": "在并行计算理论中，被称为尼克类（Nick's Class, NC）的复杂性类为识别那些可以在并行计算机上高效解决的问题提供了一个框架。如果一个问题可以由一个满足两个关键性质的一致布尔电路族解决，那么该问题就被认为属于类 $NC^k$（对于某个整数 $k \\ge 0$）。对于大小为 $n$ 的输入，该电路必须具备：\n1.  一个在 $n$ 上是多项式级的规模（门数量），即 $n^{O(1)}$。\n2.  一个在 $n$ 上是对数多项式级的深度（从输入到输出的最长路径），具体为 $O(\\log^k n)$。\n这些电路中的门被假定具有恒定的扇入（输入数量，通常为2）。\n\n考量两个函数 $f$ 和 $g$，它们都将比特串映射到比特串。已知这两个函数都可由属于复杂性类 $NC^1$ 的算法计算。通过将这两个函数链接在一起，创建了一个新的复合函数 $h$，使得对于任何输入比特串 $x$，输出为 $h(x) = g(f(x))$。\n\n根据电路复合的性质，复合函数 $h$ 的最紧确且最准确的分类是什么？\n\nA. $NC^0$\n\nB. $NC^1$\n\nC. $NC^2$\n\nD. $P$\n\nE. 不必然属于任何NC类。", "solution": "设 $f:\\{0,1\\}^{n} \\to \\{0,1\\}^{m(n)}$ 和 $g:\\{0,1\\}^{m} \\to \\{0,1\\}^{\\ell(m)}$ 可由一致 $NC^{1}$ 电路族计算。根据定义，存在电路族 $\\{C_{f,n}\\}$ 和 $\\{C_{g,m}\\}$ 具有以下性质：\n- 规模界限：$\\mathrm{size}(C_{f,n}) = n^{O(1)}$ 且 $\\mathrm{size}(C_{g,m}) = m^{O(1)}$。\n- 深度界限：$\\mathrm{depth}(C_{f,n}) = O(\\log n)$ 且 $\\mathrm{depth}(C_{g,m}) = O(\\log m)$。\n- 所有门均有恒定扇入。\n\n因为 $C_{f,n}$ 的规模在 $n$ 上是多项式级的，所以输出比特数 $m(n)$ 满足 $m(n) \\le n^{O(1)}$；否则，电路甚至无法在多项式描述规模内呈现那么多的输出。\n\n定义复合函数 $h(x) = g(f(x))$。为了在长度为 $n$ 的输入上计算 $h$，我们通过将 $C_{f,n}$ 的 $m(n)$ 个输出作为 $C_{g,m(n)}$ 的 $m(n)$ 个输入来构造电路 $C_{h,n}$。那么：\n- 规模满足\n$$\n\\mathrm{size}(C_{h,n}) \\le \\mathrm{size}(C_{f,n}) + \\mathrm{size}(C_{g,m(n)}) = n^{O(1)} + \\left(m(n)\\right)^{O(1)} = n^{O(1)},\n$$\n因为 $m(n) \\le n^{O(1)}$ 意味着 $\\left(m(n)\\right)^{O(1)} = n^{O(1)}$。\n- 深度满足\n$$\n\\mathrm{depth}(C_{h,n}) \\le \\mathrm{depth}(C_{f,n}) + \\mathrm{depth}(C_{g,m(n)}) = O(\\log n) + O\\!\\left(\\log m(n)\\right).\n$$\n使用 $m(n) \\le n^{c}$（对于某个常数 $c > 0$），我们有\n$$\n\\log m(n) \\le \\log\\!\\left(n^{c}\\right) = c \\log n,\n$$\n所以\n$$\n\\mathrm{depth}(C_{h,n}) = O(\\log n).\n$$\n复合电路保持了恒定扇入和一致性（标准的一致性概念，如对数空间一致性，在复合下是封闭的）。因此，$h$ 可由一个一致的、多项式规模、 $O(\\log n)$ 深度、恒定扇入的电路族计算，即 $h \\in NC^{1}$。\n\n这个分类是紧确的：通常情况下，复合两个非平凡的 $NC^{1}$ 函数不会将深度降低到 $O(1)$，所以 $NC^{0}$ 太小；而 $NC^{2}$ 和 $P$ 是有效的超集，但它们不是最紧确的分类。\n\n因此，最紧确且最准确的分类是 $NC^{1}$。", "answer": "$$\\boxed{B}$$", "id": "1459527"}]}