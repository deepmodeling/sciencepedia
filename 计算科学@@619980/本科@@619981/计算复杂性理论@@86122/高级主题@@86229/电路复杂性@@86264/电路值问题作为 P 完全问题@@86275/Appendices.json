{"hands_on_practices": [{"introduction": "任何复杂的计算归根结底都是由简单的逻辑门组合而成。这个练习将带你实践一个基本功：将一个常见的布尔函数——异或（XOR）——用与门（AND）、或门（OR）和非门（NOT）这些基本构建模块来表示。掌握这种从逻辑表达式到电路的转换，是理解任何计算问题如何被电路化的第一步。[@problem_id:1450370]", "problem": "在计算复杂性理论的研究中，一个核心问题是问题能够被多高效地解决。电路求值问题（CVP）是该领域的一个关键问题，它询问一个给定的布尔电路在一组特定输入下是否求值为 `true`。理解如何从一组基本门（如与、或、非）为各种逻辑函数构建电路，是分析 CVP 复杂性的一个基本步骤。\n\n考虑两个布尔输入变量 $x$ 和 $y$。你的任务是找出一个能正确实现异或（XOR）操作的布尔表达式，该操作表示为 $x \\oplus y$。该表达式必须仅使用与（用 $\\land$ 表示）、或（用 $\\lor$ 表示）和非（用 $\\neg$ 表示）这些基本逻辑运算来构建。\n\n下列哪个布尔表达式逻辑上等价于 $x \\oplus y$？\n\nA. $(x \\land y) \\lor (\\neg x \\land \\neg y)$\n\nB. $(x \\lor \\neg y) \\land (\\neg x \\lor y)$\n\nC. $(x \\land \\neg y) \\lor (\\neg x \\land y)$\n\nD. $(x \\lor y) \\land (\\neg x \\land \\neg y)$\n\nE. $(x \\lor y) \\land (x \\lor \\neg y)$", "solution": "我们回顾异或的定义属性：$x \\oplus y$ 为真当且仅当 $x$ 或 $y$ 中恰好有一个为真，等价地，$x \\oplus y = 1$ 当且仅当 $x \\neq y$。\n\n一个使用 $\\land$、$\\lor$ 和 $\\neg$ 表示异或的范式是\n$$\nx \\oplus y = (x \\lor y) \\land \\neg(x \\land y).\n$$\n对否定部分应用德摩根定律：\n$$\n\\neg(x \\land y) = \\neg x \\lor \\neg y,\n$$\n因此\n$$\nx \\oplus y = (x \\lor y) \\land (\\neg x \\lor \\neg y).\n$$\n使用分配律得到析取范式：\n$$\n(x \\lor y) \\land (\\neg x \\lor \\neg y) = (x \\land \\neg x) \\lor (x \\land \\neg y) \\lor (y \\land \\neg x) \\lor (y \\land \\neg y).\n$$\n使用矛盾式 $x \\land \\neg x = 0$ 和 $y \\land \\neg y = 0$ 进行化简：\n$$\n(x \\lor y) \\land (\\neg x \\lor \\neg y) = (x \\land \\neg y) \\lor (\\neg x \\land y).\n$$\n这与选项 C 匹配。\n\n为完整起见，我们验证其他选项：\n- A: $(x \\land y) \\lor (\\neg x \\land \\neg y)$ 在 $x=y$ 时为真，即同或（XNOR）。\n- B: $(x \\lor \\neg y) \\land (\\neg x \\lor y)$ 展开为\n$$\n(x \\land \\neg x) \\lor (x \\land y) \\lor (\\neg y \\land \\neg x) \\lor (\\neg y \\land y) = (x \\land y) \\lor (\\neg x \\land \\neg y),\n$$\n即同或（XNOR）。\n- D: $(x \\lor y) \\land (\\neg x \\land \\neg y)$ 恒为假，因为 $(\\neg x \\land \\neg y)$ 蕴含 $\\neg(x \\lor y)$。\n- E: $(x \\lor y) \\land (x \\lor \\neg y)$ 使用 $(a \\lor b) \\land (a \\lor c) = a \\lor (b \\land c)$ 化简：\n$$\n(x \\lor y) \\land (x \\lor \\neg y) = x \\lor (y \\land \\neg y) = x.\n$$\n因此，只有选项 C 等价于 $x \\oplus y$。", "answer": "$$\\boxed{C}$$", "id": "1450370"}, {"introduction": "在我们理解了电路的基本构造后，一个更深层次的问题是：是什么使得电路求值问题（CVP）在计算上如此“困难”？通过一个精巧的思想实验，本练习将一般性的 CVP 与一个受限的、更简单的版本（TreeCVP）进行对比。这种对比能帮助我们精确地定位到导致问题难以并行化、具有内在顺序性的关键结构特征，从而深刻理解 P-完备问题的本质。[@problem_id:1450420]", "problem": "布尔电路值问题 (CVP) 是计算复杂度理论中的一个基础问题。该问题旨在回答：给定一个布尔电路的描述和一组初始二进制输入值，指定的输出门的二进制值是多少？电路是由与门 (AND)、或门 (OR) 和非门 (NOT) 组成的。在一般情况下，电路的底层图是一个有向无环图 (DAG)，其中一个门的输出（其“扇出”）可以用作许多其他门的输入。这个通用版本的 CVP 已知是 P-完备的，这意味着它属于那些可以在多项式时间内解决的固有顺序性问题之一。\n\n现在，考虑该问题的一个特殊情况，我们称之为 TreeCVP。在 TreeCVP 中，电路受到限制，任何门的输出最多只能作为一个其他门的输入。这一约束确保了电路的图结构是一棵树（或一个通向最终输出门的树林）。这个看似微小的限制极大地降低了问题的复杂性，将 TreeCVP 归入复杂度类 L，即可使用对数级别的内存空间解决的问题集合。由于人们普遍认为 L 是 P 的一个真子集，这意味着 TreeCVP 不是 P-完备的。\n\n与 P-完备的通用 CVP 相比，以下哪个陈述为 TreeCVP 为何能在对数空间内解决提供了最准确和最根本的原因？\n\nA. 在树状电路中，门的总数总是与主输入数量成对数比例，这是一般电路不具备的特性。\n\nB. 树状电路中没有环是将其计算简化到对数空间的主要特征，而一般电路可能包含环。\n\nC. 树状电路的求值可以通过简单的后序遍历来执行，这只需要一个大小与输入比特数成正比的栈。\n\nD. 树状结构允许对所有门进行并行求值，从而得到一个对数时间算法，这直接意味着对数空间的使用。\n\nE. 由于任何门的输出最多只被一个其他门使用，其值永远不需要为了在电路的不同部分重用而被存储，这使得一种不需要保存多个中间结果的求值策略成为可能。", "solution": "通用 CVP 定义在 DAG 电路上，其中一个门的输出可以馈入多个其他门（扇出大于一）。TreeCVP 施加了每个门的输出最多用作一个其他门的输入的限制，因此其底层图是一棵树。我们分析的关键资源是空间，即对于大小为 $n$ 的输入，是否存在一个使用 $O(\\log n)$ 比特工作带的确定性算法。\n\n一个确定性的对数空间机器对输入（电路描述和输入赋值）具有只读访问权限，一个只写的输出，以及 $O(\\log n)$ 的工作空间。要对一个排列成树状的布尔电路进行求值，可以执行一次后序遍历，根据其子节点的值计算每个门的值。虽然一个朴素的递归遍历会使用一个与树深度成正比的栈，但我们可以通过两种与 $O(\\log n)$ 空间兼容的标准方法来避免存储显式栈：一种是通过指针翻转式的遍历，它只维护恒定数量的节点标识符（每个标识符可用 $O(\\log n)$ 比特存储）；另一种是通过反复扫描输入来定位当前节点的子节点或父节点，这需要一个小的有限控制器加上用于保存当前节点标识符和恒定数量标志的 $O(\\log n)$ 比特。这可能会将时间增加到多项式级别，但空间仍然是 $O(\\log n)$。\n\n这能在对数空间内工作，其根本原因是无扇出特性：由于每个门的输出最多被一个父节点使用，一旦一个子树的值在其父节点处被合并，该子树的值就再也不会在其他地方被需要。因此，算法在任何时候都不需要存储多个中间门的值以供重用。相反，它可以计算一个子节点的值，立即用它来计算父节点的值（可能在计算另一个子节点之后），然后丢弃它。在遍历过程中唯一需要持久化的信息是当前节点的身份和恒定数量的局部状态比特，所有这些都可以在 $O(\\log n)$ 空间内编码。\n\n相比之下，在一般的 DAG 电路中，一个门的输出可能被许多父节点需要。为了避免重复地重新计算该门的值（这可能导致超多项式甚至指数级的时间爆炸），通常会存储中间值以供多个消费者重用，这可能迫使同时维护许多这样的值，从而超出了 $O(\\log n)$ 空间。这正是树状结构限制所消除的存储压力。\n\n评估各个选项：\n- A 是错误的：一棵树的门数可以是输入数量的线性函数；通常不存在对数比例关系。\n- B 具有误导性：通用 CVP 本身就是无环的；没有环并不是区分 TreeCVP 和通用 DAG 电路的特征。\n- C 的陈述不正确：后序遍历并不需要一个与输入比特数成正比的栈；所需的栈深度是树的深度，在最坏情况下可以是输入数量的线性函数。此外，对数空间算法通过指针翻转或重新遍历来避免使用显式栈。\n- D 是不正确的：对于任意树，并行求值和对数时间并不能得到保证；树的深度可能很大，并且在此背景下，对数时间并不直接意味着对数空间。\n- E 抓住了根本原因：扇出最多为一，意味着没有门的值必须被保留以在电路的不同部分重用，这使得一种避免存储多个中间结果并能在 $O(\\log n)$ 空间内完成的求值策略成为可能。\n\n因此，最准确和最根本的原因是无扇出特性，它消除了存储中间结果以供重用的需要。", "answer": "$$\\boxed{E}$$", "id": "1450420"}, {"introduction": "在计算复杂性理论中，证明一个问题是 P-完备的“黄金标准”方法，是将其从一个已知的 P-完备问题进行归约。本练习提供了一个将此抽象概念付诸实践的机会，你将亲手执行一个从霍恩可满足性问题（Horn-SAT）到单调电路求值问题（Monotone CVP）的归约过程。通过这个具体步骤，你不仅能解决问题，更能领会复杂性理论中用以界定问题难度的核心方法论。[@problem_id:1450431]", "problem": "在计算复杂性理论中，电路值问题 (CVP) 是一个基础的 P-完备问题。一个关键的变体是单调电路值问题 (Monotone CVP)，它被限制于只包含与门和或门而不含非门的电路。为了证明单调 CVP 是 P-完备的，可以从另一个已知的 P-完备问题——霍恩可满足性问题 (Horn-SAT) 进行对数空间归约。\n\n一个霍恩公式是多个霍恩子句的合取。每个霍恩子句是多个文字（一个变量或其否定）的析取，其中最多含有一个正（非否定）文字。我们可以将这些子句表示为蕴含式：\n1.  形式为 $(\\neg y_1 \\vee \\neg y_2 \\vee \\dots \\vee \\neg y_k \\vee x)$ 的子句等价于蕴含式 $(y_1 \\wedge y_2 \\wedge \\dots \\wedge y_k) \\implies x$。\n2.  只有一个正文字 $x$ 的子句等价于 $\\text{true} \\implies x$。\n\n考虑以下将一个 Horn-SAT 实例（只包含上述两种类型的子句）转换为一个单调 CVP 实例的归约过程：\n\n*   **输入：** 电路有一个常数输入节点 `TRUE`，其布尔值固定为 1。所有其他未被 `true => ...` 子句明确设置为真的变量初始时被认为是假 (0)。\n*   **电路结构：** 对于霍恩公式中的每个变量 $v_i$，我们将构建逻辑来确定其值。$v_i$ 的最终值由电路中一根同样标记为 $v_i$ 的导线表示。\n*   **子句转换：**\n    *   对于每个形如 `true => v_i` 的子句， `TRUE` 输入节点被用作确定 $v_i$ 值的逻辑的一个输入。\n    *   对于每个形如 `(v_{j1} AND v_{j2} AND ... AND v_{jk}) => v_i` 的子句，会创建一个与门。该门的输入是对应于变量 $v_{j1}, v_{j2}, \\dots, v_{jk}$ 的导线。这个与门的输出被用作确定 $v_i$ 值的逻辑的一个输入。\n*   **变量值计算：** 变量 $v_i$ 的最终值是通过对所有以 $v_i$ 为后件的蕴含式的结果进行或运算来确定的。也就是说，如果有 $m$ 个子句的后件是 $v_i$，我们创建一个有 $m$ 个输入的或门。每个输入来自为这些子句之一构建的逻辑（或者是 `TRUE` 节点，或者是一个与门的输出）。该或门的输出成为 $v_i$ 的最终导线。如果一个变量从未成为任何子句的后件，它的值保持为 0。\n\n给定以下在变量 $\\{x_1, x_2, x_3, x_4, x_5\\}$ 上的霍恩公式 $\\Phi$：\n$$ \\Phi = (\\text{true} \\implies x_1) \\wedge (\\text{true} \\implies x_2) \\wedge (x_1 \\wedge x_2 \\implies x_3) \\wedge (x_3 \\implies x_4) \\wedge (x_1 \\wedge x_4 \\implies x_5) $$\n\n按照所描述的归约过程，构建相应的单调布尔电路。确定为对应于变量 $x_5$ 的输出导线计算出的最终布尔值（使用 1 代表真，0 代表假）。", "solution": "我们遵循从霍恩公式到单调电路的给定归约方法，该电路具有一个值为 $1$ 的常数输入节点 TRUE。对于每个变量 $v_i$，其输出导线是所有以后件为 $v_i$ 的蕴含式所对应的门的输出的析取；每个这样的门要么是常数 $1$（对于子句 $\\text{true} \\implies v_i$），要么是前件变量的与运算（对于子句 $(v_{j_1} \\land \\cdots \\land v_{j_k}) \\implies v_i$）。\n\n翻译以下公式的每个子句：\n$$\n\\Phi=(\\text{true}\\implies x_{1})\\land(\\text{true}\\implies x_{2})\\land(x_{1}\\land x_{2}\\implies x_{3})\\land(x_{3}\\implies x_{4})\\land(x_{1}\\land x_{4}\\implies x_{5})\n$$\n如下。\n\n1.  对于 $x_1$：存在一个子句 $\\text{true}\\implies x_1$，所以 $x_1$ 的或门有一个单一输入 TRUE。因此\n    $x_1 = 1$.\n\n2.  对于 $x_2$：存在一个子句 $\\text{true}\\implies x_2$，所以 $x_2$ 的或门有一个单一输入 TRUE。因此\n    $x_2 = 1$.\n\n3.  对于 $x_3$：存在一个子句 $(x_1 \\land x_2) \\implies x_3$。我们创建一个输入为 $x_1$ 和 $x_2$ 的与门，并将其输出馈入 $x_3$ 的或门。因此\n    $x_3 = (x_1 \\land x_2) = 1 \\land 1 = 1$.\n\n4.  对于 $x_4$：存在一个子句 $(x_3) \\implies x_4$，即一个以 $x_3$ 为输入的单输入与门馈入 $x_4$ 的或门，所以\n    $x_4 = x_3 = 1$.\n\n5.  对于 $x_5$：存在一个子句 $(x_1 \\land x_4) \\implies x_5$。我们创建一个输入为 $x_1$ 和 $x_4$ 的与门馈入 $x_5$ 的或门。因此\n    $x_5 = (x_1 \\land x_4) = 1 \\land 1 = 1$.\n\n因此，通过所述归约得到的单调电路将对应于变量 $x_5$ 的输出导线的值计算为 $1$。", "answer": "$$\\boxed{1}$$", "id": "1450431"}]}