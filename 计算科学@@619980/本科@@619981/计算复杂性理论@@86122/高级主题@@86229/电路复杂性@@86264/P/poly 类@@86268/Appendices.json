{"hands_on_practices": [{"introduction": "这个练习将阐明 P/poly 的一个核心原则：对于给定长度 $n$ 的电路是固定的。如果某个语言中所有长度为 $n$ 的字符串的成员资格都相同，那么电路可以非常简单，甚至与输入字符串本身无关。这个问题有助于我们从基础上理解“非均匀性”的含义 [@problem_id:1454195]。", "problem": "在计算复杂性理论中，具有多项式规模电路的语言类，记作 P/poly，在理解有效计算的局限性方面扮演着至关重要的角色。如果存在一个布尔电路族 $\\{C_n\\}_{n \\ge 0}$ 和一个多项式 $p(n)$，使得以下条件成立，则称二元字母表 $\\{0, 1\\}$ 上的语言 $L$ 属于 P/poly：\n1. 对于每个非负整数 $n$，电路 $C_n$ 有 $n$ 个输入。\n2. 每个电路 $C_n$ 的规模（定义为其与门、或门和非门的总数）至多为 $p(n)$。\n3. 对于任何长度为 $n$ 的二进制串 $w$，当且仅当 $w \\in L$ 时，电路 $C_n$ 输出 1。\n\n考虑语言 $L_{parity}$，它被定义为所有长度为偶数的二进制串的集合。\n$L_{parity} = \\{ w \\in \\{0, 1\\}^\\* \\mid |w| \\text{ is an even number} \\}$\n\n对于这个语言 $L_{parity}$，必须存在一个可以判定它的电路族 $\\{C_n\\}_{n \\ge 1}$。下列哪个陈述最准确地描述了对于 $n \\ge 1$ 的电路 $C_n$ 的最小可能规模？\n\nA. $C_n$ 的规模必须随 $n$ 线性增长，即规模为 $\\Theta(n)$。\n\nB. $C_n$ 的规模可以是一个与 $n$ 无关的常数。\n\nC. $C_n$ 的规模必须随 $n$ 平方增长，即规模为 $\\Theta(n^2)$。\n\nD. $C_n$ 的规模必须随 $n$ 指数增长，即规模为 $\\Theta(2^n)$。\n\nE. 不存在这样的电路族，因为该语言是非一致性的。", "solution": "给定语言 $L_{parity} = \\{ w \\in \\{0,1\\}^\\* \\mid |w| \\text{ is even} \\}$。对于一个固定的输入长度 $n$，由 $C_{n}$ 计算的判定函数是\n$$\nf_{n}(w) =\n\\begin{cases}\n1 & \\text{if } n \\text{ is even},\\\\\n0 & \\text{if } n \\text{ is odd},\n\\end{cases}\n$$\n对于所有的 $w \\in \\{0,1\\}^{n}$。因此，对于每个固定的 $n$，$f_{n}$ 是在 $\\{0,1\\}^{n}$ 上的一个常数函数，与输入位无关。\n\n要通过带有与门、或门和非门的布尔电路来实现这样的函数：\n- 如果 $n$ 是偶数，定义 $C_{n}$ 输出永真式 $x_{1} \\vee \\neg x_{1}$，其结果恒为 $1$。这使用一个非门和一个或门，因此规模是一个与 $n$ 无关的常数（具体为 $2$）。\n- 如果 $n$ 是奇数，定义 $C_{n}$ 输出矛盾式 $x_{1} \\wedge \\neg x_{1}$，其结果恒为 $0$。这使用一个非门和一个与门，因此规模同样是一个与 $n$ 无关的常数（具体为 $2$）。\n\n因此，存在一个判定 $L_{parity}$ 的电路族 $\\{C_{n}\\}_{n \\ge 1}$，使得 $C_{n}$ 的规模受一个与 $n$ 无关的常数限制。这表明线性、平方或指数增长是不必要的。此外，陈述 E 是不正确的，因为 P/poly 明确允许非一致性电路族，而这里一个简单的非一致性常数规模电路族就足够了。\n\n因此，正确的选项是电路规模可以是一个与 $n$ 无关的常数。", "answer": "$$\\boxed{B}$$", "id": "1454195"}, {"introduction": "在上一个练习的基础上，这个问题将探讨如何将针对每个长度 $n$ 的特定非均匀信息（或“建议”）直接嵌入到电路的设计中。我们将看到，通过为每个长度“硬编码”其定义字符串，一个由任意字符串序列定义的看似复杂的语言，如何能被多项式大小的电路判定。这个实践加深了我们对建议字符串和电路族之间关系的理解 [@problem_id:1454160]。", "problem": "在计算复杂性理论中，P/poly 类（非一致性多项式时间）表示那些可被一个多项式规模的布尔电路族判定的语言。更形式化地说，如果存在一个多项式 $p(n)$ 和一个电路族 $\\{C_n\\}_{n \\in \\mathbb{N}}$，使得对于每个自然数 $n$ 都满足以下条件，那么语言 $L \\subseteq \\{0,1\\}^\\*$ 就属于 P/poly：\n1. 电路 $C_n$ 最多有 $p(n)$ 个门。\n2. 对于任何长度为 $n$ 的字符串 $x$，如果 $x \\in L$，电路 $C_n$ 输出 1；如果 $x \\notin L$，电路 $C_n$ 输出 0。\n\n注意，对于每个输入长度 $n$，电路 $C_n$ 都可以是不同的。\n\n考虑一个语言 $L$，它由一个任意的、固定的“阈值”字符串序列 $\\{s_n\\}_{n \\in \\mathbb{N}}$ 定义，其中每个 $s_n$ 是一个长度为 $n$ 的二进制字符串。语言 $L$ 是所有 $L_n$（其中 $n \\in \\mathbb{N}$）的并集，其中 $L_n$ 定义如下：\n$$L_n = \\{x \\in \\{0,1\\}^n \\mid x \\text{ 在字典序上小于 } s_n\\}$$\n例如，如果对于 $n=3$，固定的字符串是 $s_3 = 101$，那么字符串 $000, 001, 010, 011, 100$ 属于 $L_3$，而 $101, 110, 111$ 则不属于。\n\n字符串序列 $\\{s_n\\}$ 是任意的；不要求它以任何方式是可计算的。下列哪个陈述为语言 $L$ 必定属于 P/poly 提供了正确的理由？\n\nA. 该语言属于 P/poly，因为可以构造一个单一的多项式时间图灵机。该机器接受输入字符串 $x$ 和相应的字符串 $s_{|x|}$，对它们进行字典序比较，并相应地接受或拒绝。\n\nB. 该语言不一定属于 P/poly，因为序列 $\\{s_n\\}$ 可能基于一个不可计算问题来定义（例如，$s_n$ 编码了关于停机问题的信息）。P/poly 电路族不能解决不可计算问题。\n\nC. 对于每个输入长度 $n$，特定的字符串 $s_n$ 可以被硬编码到专用电路 $C_n$ 的逻辑中。该电路使用数量为 $n$ 的多项式的门，将输入 $x$ 与硬编码的 $s_n$ 进行比较。这样一族电路 $\\{C_n\\}$ 的存在，就将该语言置于 P/poly 中。\n\nD. 该语言不一定属于 P/poly，因为为了处理任意字符串 $s_n$，电路 $C_n$ 需要包含所有 $2^n$ 种可能的阈值字符串的信息，而这将需要指数数量的门。", "solution": "为了确定语言 $L$ 为何属于 P/poly，我们必须分析 P/poly 的定义，并考察它如何应用于给定的语言 $L$。P/poly 类的核心在于其“非一致性”，这意味着我们被允许为每个输入长度 $n$ 使用一个不同的电路 $C_n$。这个电路 $C_n$ 只需要对长度为 $n$ 的输入有效，并且可以将特定于长度 $n$ 的信息“内建”到其结构中。\n\n让我们来评估每个选项：\n\n**选项 A：**这个陈述是错误的。它描述的是一个*一致性*计算模型，这是复杂性类 P 的典型特征。它假定单个图灵机可以获取字符串 $s_{|x|}$ 然后执行比较。然而，问题指明序列 $\\{s_n\\}$ 是任意的，并且可能不是可计算的。如果 $\\{s_n\\}$ 是一个不可计算序列，那就没有任何单个图灵机能够为任意的 $n$ 生成 $s_n$。因此，这个理由只有在 $\\{s_n\\}$ 是一个 P 可计算序列时才成立，而这一点是无法保证的。\n\n**选项 B：**这个陈述是错误的。它对 P/poly 的能力做出了错误的论断。P/poly 的非一致性使其可以包含不可计算语言。对于每个长度 $n$，电路 $C_n$ 以其自身结构的形式被提供了“建议”(advice)。这个建议可以是一个不可计算的比特序列。例如，由所有满足“第 $n$ 个图灵机停机”的字符串 $1^n$ 组成的不可计算语言，可以被一个电路族判定，其中电路 $C_n$ 仅仅是一根根据为 $n$ 预先计算好（但不可计算）的答案而连接到 '1' 或 '0' 的导线。因此，$\\{s_n\\}$ 的潜在不可计算性并不是语言 $L$ 属于 P/poly 的障碍。\n\n**选项 D：**这个陈述是错误的。它误解了电路族的工作方式。对于任意给定的 $n$，语言 $L_n$ 是由*一个特定的字符串* $s_n$ 定义的。电路 $C_n$ 不需要处理 $s_n$ 的所有可能选择；它只需要对作为语言定义一部分的那个单个、固定的 $s_n$ 有效即可。因此，电路不需要编码关于所有 $2^n$ 种可能性的信息，只需要编码关于一种可能性的信息。\n\n**选项 C：**这个陈述是正确的。它精确地抓住了非一致性原则。对于每个输入大小 $n$，字符串 $s_n$ 是固定的。我们可以设计一个电路 $C_n$，将这个特定的字符串 $s_n$ “硬编码”到其门电路中。该电路接受一个 $n$ 比特的输入 $x$，并将其与硬编码的 $s_n$ 进行比较。一个用于比较两个 $n$ 比特字符串的标准字典序比较电路，可以用与 $n$ 成正比（即规模为 $O(n)$）数量的门来构建。这可以通过从最高有效位到最低有效位逐一比较 $x$ 和 $s_n$ 的比特位，并使用逻辑门来确定在第一个不同的比特位上，是否是 $x$ 的比特为 '0' 而 $s_n$ 的比特为 '1' 来完成。由于这个电路的规模是 $O(n)$，它的大小受一个关于 $n$ 的多项式（例如，对于某个常数 $c$，$p(n) = c \\cdot n$）的限制。既然我们可以为每个 $n$ 构造这样一个多项式规模的电路 $C_n$，那么语言 $L = \\bigcup_n L_n$ 就满足属于 P/poly的定义。字符串序列 $\\{s_n\\}$ 充当了被整合到电路族 $\\{C_n\\}$ 设计中的“建议”(advice)。", "answer": "$$\\boxed{C}$$", "id": "1454160"}, {"introduction": "最后一个练习揭示了 P/poly 的一个惊人而关键的特性：它能够包含不可判定语言。通过构造一个结合了可判定问题和不可判定问题的语言，我们将展示非均匀的“建议”模型如何让 P/poly 解决任何单一算法（图灵机）都无法解决的问题。这突显了均匀（如 P）和非均匀（如 P/poly）计算复杂性类之间的根本区别 [@problem_id:1454149]。", "problem": "令 $\\Sigma = \\{0,1\\}$ 为字母表。我们将通过组合一个复杂度类 P 中的著名语言和一个不可判定语言来定义一个新语言。\n\n首先，令 $L_P$ 为 $\\Sigma$ 上的所有回文串组成的语言。如果一个字符串 $w$ 正向和反向读起来都一样，那么它就是一个回文串。形式上，$L_P = \\{ w \\in \\Sigma^\\* \\mid w = w^R \\}$，其中 $w^R$ 是 $w$ 的反转。已知 $L_P \\in P$。\n\n其次，我们来定义一个不可判定的一元语言。一元语言是 $\\{1\\}^\\*$ 的一个子集。设 $M_i$ 表示在一个标准的、固定的所有有效图灵机编码的枚举下，与整数 $i$ 对应的图灵机。定义一元语言 $L_T$ 如下：\n$$L_T = \\{1^i \\mid \\text{图灵机 } M_i \\text{ 在空串 } \\epsilon \\text{ 上停机} \\}$$\n你可以假设来自可计算性理论的已知结论，即 $L_T$ 是一个不可判定语言。\n\n使用这两种语言，我们在字母表 $\\Sigma$ 上构建一个新语言 $L_{new}$。一个字符串 $x \\in \\Sigma^\\*$ 是否属于 $L_{new}$ 取决于其长度 $|x|$，具体如下：\n- 如果 $|x|$ 是奇数，那么 $x \\in L_{new}$ 当且仅当 $x$ 是一个回文串（即 $x \\in L_P$）。\n- 如果 $|x|$ 是偶数，那么 $x \\in L_{new}$ 当且仅当该长度的一元字符串在 $L_T$ 中（即 $1^{|x|} \\in L_T$）。\n\n语言 $L_{new}$ 属于以下哪个复杂度类？\n\nA. $P$ (多项式时间)\n\nB. $NP$ (非确定性多项式时间)\n\nC. $P/poly$ (带有多项式大小建议的多项式时间)\n\nD. $R$ (所有可判定语言的集合)\n\nE. 以上都不是；该语言是不可判定的。", "solution": "问题要求我们将语言 $L_{new}$ 归入给定的复杂度类之一。语言 $L_{new}$ 定义为：\n$L_{new} = \\{ x \\in \\{0,1\\}^\\* \\mid (|x| \\text{ 为奇数且 } x \\in L_P) \\lor (|x| \\text{ 为偶数且 } 1^{|x|} \\in L_T) \\}$。\n\n让我们来分析这些选项。\n\n首先，我们检查 $L_{new}$ 是否是可判定的（即，是否在类 $R$ 中）。如果存在一个图灵机在所有输入上都停机并能正确判定语言的隶属关系，那么该语言就是可判定的。为引出矛盾，我们假设 $L_{new}$ 可由某个图灵机 $M_{new}$ 判定。那么我们可以用 $M_{new}$ 来判定不可判定的语言 $L_T$。要判定一个字符串 $1^i$ 是否在 $L_T$ 中，我们可以遵循以下算法：\n1. 如果 $i$ 是奇数，根据定义我们知道 $1^i \\notin L_T$，因为 $L_T$ 只能包含特定长度的全1字符串，而不是 $\\{1\\}^\\*$ 中的任意字符串。一个更常规的 $L_T$ 定义是作为 $\\{1\\}^\\*$ 的一个子集。假设题目陈述意味着 $L_T \\subseteq \\{1\\}^*$，那么这个算法成立。我们假设问题暗示了检查“$i$ 是否满足 $M_i$ 在 $\\epsilon$ 上停机？”。\n2. 要判定对于任何 $i \\ge 0$ 是否有 $1^i \\in L_T$：\n   a. 如果 $i$ 是奇数，我们不能直接使用我们的构造。然而，问题的核心是偶数长度的情况。我们来关注这一点。\n   b. 如果 $i$ 是偶数，构造任意一个长度为 $i$ 的字符串 $x$（例如，$x = 0^i$）。\n   c. 在输入 $x$ 上运行假设的判定器 $M_{new}$。\n   d. 根据 $L_{new}$ 的定义，因为 $|x|=i$ 是偶数，所以 $M_{new}$ 将接受 $x$ 当且仅当 $1^i \\in L_T$。\n这个过程可以判定所有偶数长度的一元字符串在 $L_T$ 中的隶属关系。这本身并不能判定整个 $L_T$，但它判定了一个不可判定语言的无限子集，这是一个强烈的暗示，说明有问题。因为对于一个通用的 $i$，判定 $M_i$ 是否在 $\\epsilon$ 上停机是不可判定的，而我们的过程可以对所有偶数 $i$ 进行判定，这意味着集合 $\\{i \\mid i \\text{ 是偶数且 } M_i \\text{ 在 } \\epsilon \\text{ 上停机}\\}$ 是可判定的。这本身并不构成矛盾，但是完整的语言 $L_T$ 是不可判定的。如果 $L_{new}$ 属于 $P$、$NP$ 或 $R$，那就意味着 $L_{new}$ 是可判定的。这将给我们一个算法来判定对于任何偶数 $n$，是否有 $1^n \\in L_T$。这与 $L_T$ 是不可判定的这一事实相矛盾。$L_T$ 不可判定性的一个形式化证明表明，不存在任何算法，因此即使对于像所有偶数这样的无限输入子集，也不存在任何算法。因此，$L_{new}$ 不可能在 $R$ 中，并且由此可知，它也不可能在 $P$ 或 $NP$ 中，因为 $P \\subseteq NP \\subseteq R$。这排除了选项 A、B 和 D。\n\n我们剩下选项 C ($P/poly$) 和选项 E (不可判定)。注意，这里的“不可判定”通常指的是图灵可判定性（一致性计算）。类 $P/poly$ 是一个非一致性复杂度类，并且已知它包含不可判定的语言。我们来检查 $L_{new}$ 是否符合 $P/poly$ 的定义。\n\n一个语言 $L$ 在 $P/poly$ 中，如果存在一个多项式时间算法 $A$ 和一个建议串序列 $\\{a_n\\}_{n \\in \\mathbb{N}}$，使得对于每个长度 $n$，建议串的大小 $|a_n|$ 受 $n$ 的一个多项式限制，并且对于任何长度为 $n$ 的输入 $x$，$A(x, a_n)$ 都能正确判定 $x$ 是否属于 $L$。建议串 $a_n$ 只依赖于输入的长度 $n$，而不依赖于输入 $x$ 本身。\n\n我们来为 $L_{new}$ 构造算法和建议。\n\n定义建议序列 $\\{a_n\\}$ 如下：\n对于每个自然数 $n \\ge 0$，建议 $a_n$ 将是单个比特。\n$$a_n = \\begin{cases} 1 & \\text{如果 } 1^n \\in L_T \\\\ 0 & \\text{如果 } 1^n \\notin L_T \\end{cases}$$\n这个建议序列在数学上是良定义的，尽管它是不可计算的（因为 $L_T$ 是不可判定的）。$P/poly$ 的定义不要求建议是可计算的。建议的大小对于所有 $n$ 都是 $|a_n| = 1$。这受一个多项式（例如 $p(n)=1$）的限制。\n\n现在，我们定义多项式时间算法 $A(x, a_{|x|})$。设 $n = |x|$ 为输入字符串 $x$ 的长度。\n1. 检查 $n$ 是奇数还是偶数。\n2. 如果 $n$ 是奇数：\n   算法忽略建议 $a_n$。它检查 $x$ 是否是回文串。这可以通过比较第一个字符和最后一个字符，第二个和倒数第二个，以此类推来完成。这需要 $O(n)$ 时间。如果 $x$ 是回文串，算法接受。否则，它拒绝。这根据 $L_{new}$ 的定义正确地判定了奇数长度字符串的隶属关系。\n3. 如果 $n$ 是偶数：\n   算法忽略输入字符串 $x$ 本身，只考虑建议比特 $a_n$。如果 $a_n = 1$，算法接受。如果 $a_n = 0$，算法拒绝。根据我们对建议的定义，$a_n=1$ 当且仅当 $1^n \\in L_T$。所以，该算法正确地判定了偶数长度字符串的隶属关系。\n\n算法 $A$ 的总运行时间主要由回文串检查决定，为 $O(n)$。这是一个多项式时间算法。\n\n既然我们已经构造了一个多项式时间算法和一个多项式大小的建议序列来正确判定 $L_{new}$，我们就证明了 $L_{new} \\in P/poly$。\n\n因此，正确的分类是 $P/poly$。选项 E 是不正确的，因为该语言完全符合选项中提供的一个更具体（尽管是非一致性的）类的定义。", "answer": "$$\\boxed{C}$$", "id": "1454149"}]}