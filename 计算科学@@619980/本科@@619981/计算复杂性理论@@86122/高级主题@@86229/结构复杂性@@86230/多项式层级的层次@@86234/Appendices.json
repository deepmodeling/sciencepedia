{"hands_on_practices": [{"introduction": "理论学习之后的下一步是实践。将一个用自然语言描述的计算问题转化为量化逻辑，并将其精确地置于多项式时间层级中，是一项核心技能。这个练习提供了一个绝佳的机会，让您来实践如何识别一个问题的基础逻辑结构，并将其对应到正确的复杂度类中，特别是 $\\Pi_2^P$。[@problem_id:1429942]", "problem": "在形式化验证领域，一个常见的任务是证明一个系统模型在各种输入下的行为都是正确的。考虑一个与抽象机的计算能力相关的该任务的简化模型。\n\n我们定义一个名为 UNIVERSAL_ACCEPTANCE 的判定问题。该问题的一个实例是一个对 `(<M>, 1^n)`，其中 `<M>` 是一台非确定性图灵机 (NTM) 的标准字符串编码，而 `n` 是一个用一元表示法表示的正整数。我们保证，对于任何长度为 `n` 的输入字符串，NTM `M` 会在实例大小（即 `|(<M>)| + n`）的多项式步数内停机。\n\n需要回答的问题是：NTM `M` 是否接受*每一个*长度恰好为 `n` 的二进制字符串？\n\n令 `L_UA` 为对应于 UNIVERSAL_ACCEPTANCE 问题的“是”实例的形式语言。你的任务是在标准的复杂性类层次结构中对 `L_UA` 进行分类。下列哪一项是 `L_UA` 最精确的分类（即，列表中已知包含 `L_UA` 的最小的著名复杂性类）？\n\nA. `P`\n\nB. `NP`\n\nC. `co-NP`\n\nD. $\\Sigma_2^P$\n\nE. $\\Pi_2^P$\n\nF. `PSPACE`", "solution": "该问题要求对语言 `L_UA` 进行最精确的复杂性分类，`L_UA`被定义为所有满足以下条件的对 `(<M>, 1^n)` 的集合：非确定性图灵机 (NTM) `M` 接受每一个长度为 `n` 的二进制字符串。\n\n首先，我们使用形式逻辑和量词来表达实例 `w = (<M>, 1^n)` 属于 `L_UA` 的条件。根据问题定义，当且仅当对于所有长度为 `n` 的二进制字符串 `x`，机器 `M` 都接受 `x` 时，`w ∈ L_UA`。我们可以将其写为：\n$$ w = (<M>, 1^n) \\in L_{UA} \\iff \\forall x \\in \\{0, 1\\}^n, \\text{ NTM } M \\text{ accepts } x $$\n我们量化的字符串 `x` 的长度为 `n`，它受输入大小 `|w|` 的限制。\n\n接下来，我们分析内部命题“NTM `M` 接受 `x`”的复杂性。这是典型的 `NP`-完全问题的定义，通常表示为 `A_NTM`。如果一个“是”实例可以在给定一个合适的证据的情况下于多项式时间内被验证，那么该语言就属于 `NP` 类。对于 `A_NTM`，一个实例是 `(<M>, x)`，而证据 `c` 是表示 `M` 在输入 `x` 上的一条接受计算路径的一系列格局。问题描述保证了 `M` 的运行时间是 `|(<M>)| + n` 的多项式。因此，一条接受路径 `c` 的长度也受 `|(<M>)| + n` 的多项式限制。\n\n一个语言 `L` 属于 `NP` 的定义可以用一个多项式时间验证机 `V`（它是一个确定性图灵机）和一个存在量词来表示：\n$$ u \\in L \\iff \\exists c, \\text{ where } |c| \\le \\text{poly}(|u|), \\text{ such that } V(u, c) \\text{ accepts.} $$\n将此应用于我们的子问题“NTM `M` 接受 `x`”，我们得到：\n$$ \\text{NTM } M \\text{ accepts } x \\iff \\exists c \\text{ such that } V(<M>, x, c) \\text{ accepts.} $$\n这里，`V` 是一个多项式时间机器，它验证 `c` 是 `M` 在 `x` 上的一个合法的接受计算。\n\n现在，我们将这个存在表达式代回到 `L_UA` 的定义中：\n$$ (<M>, 1^n) \\in L_{UA} \\iff \\forall x \\in \\{0, 1\\}^n, (\\exists c \\text{ such that } V(<M>, x, c) \\text{ accepts}). $$\n\n这种后跟一个多项式时间谓词的 $\\forall\\exists$ 量词结构，是复杂性类 $\\Pi_2^P$（多项式层级的第二层）的定义性特征。$\\Pi_2^P$ 的一般定义是满足以下条件的语言 `L` 的集合：存在一个多项式时间谓词 `P` 和一个多项式 `p`，使得对于任意输入 `w`：\n$$ w \\in L \\iff \\forall y \\exists z, \\text{ where } |y|, |z| \\le p(|w|), \\text{ the predicate } P(w, y, z) \\text{ is true.} $$\n\n我们可以将我们的问题直接映射到这个定义上：\n- 输入是 `w = (<M>, 1^n)`。\n- 全称量化变量 `y` 是长度为 `n` 的字符串 `x`。其长度是 `|w|` 的多项式。\n- 存在量化变量 `z` 是证据 `c`。其长度也是 `|w|` 的多项式。\n- 多项式时间谓词 `P(w, y, z)` 是验证机 `V(<M>, x, c)`。\n\n这表明 `L_UA` 属于 $\\Pi_2^P$。\n\n为了确保这是选项中*最精确*的分类，我们必须考虑 `L_UA` 是否可能属于一个更小的类。\n该问题目前未知是否属于 `P`、`NP` 或 `co-NP`。事实上，可以通过将典型的 $\\Pi_2^P$-完全问题 `∀∃SAT` 归约到 `L_UA`，来证明 `L_UA` 是 $\\Pi_2^P$-完全的。这个困难性结果意味着 `L_UA` 不可能属于 `P`、`NP`、`co-NP` 或 $\\Sigma_2^P$，除非多项式层级坍缩到更低的层级，而这被普遍推测是错误的。\n$\\Sigma_2^P$ 的特征是 `∃∀` 量词结构，这与我们问题的 `∀∃` 结构不同。\n`PSPACE` 包含整个多项式层级，所以 `L_UA` 确实在 `PSPACE` 中。然而，$\\Pi_2^P$ 是 `PSPACE` 的一个子类，这使得 $\\Pi_2^P$ 成为一个更精确、更紧确的分类。\n\n因此，在给定的选项中，`L_UA` 的最精确分类是 $\\Pi_2^P$。", "answer": "$$\\boxed{E}$$", "id": "1429942"}, {"introduction": "许多计算问题不仅仅关心解的存在性，还关心解的唯一性。这个问题将挑战我们如何用计算复杂性的语言来形式化“恰好有一个解”这个概念。通过解决这个问题，我们将探索到由 `NP` 和 `co-NP` 相互作用而产生的更微妙的复杂度类，例如 $\\Delta_2^P$。[@problem_id:1429958]", "problem": "在计算复杂性理论中，多项式层级（Polynomial Hierarchy, PH）根据描述计算问题所需的逻辑量词的复杂性，提供了一种分类方法。该层级的各个级别对于整数 $k \\ge 0$ 表示为 $\\Sigma_k^P$、$\\Pi_k^P$ 和 $\\Delta_k^P$。\n\n对于 $k \\ge 1$，如果一个语言 $L$ 可以用一个以存在量词开头、后面跟着 $k-1$ 次量词交替的公式来描述，并且该公式作用于一个多项式时间可验证的关系，那么这个语言 $L$ 就属于 $\\Sigma_k^P$。形式上，存在一个多项式 $p$ 和一个多项式时间可计算的谓词 $R$，使得字符串 $x$ 属于 $L$ 当且仅当：\n$$ \\exists y_1 \\forall y_2 \\exists y_3 \\dots Q_k y_k : R(x, y_1, y_2, \\dots, y_k) $$\n其中每个见证字符串 $y_i$ 的长度以 $p(|x|)$ 为界，并且如果 $k$ 是奇数，则 $Q_k$ 是 $\\exists$；如果 $k$ 是偶数，则 $Q_k$ 是 $\\forall$。\n\n- $\\Sigma_1^P$ 是 `NP` 类。\n- $\\Pi_k^P$ 是其补集属于 $\\Sigma_k^P$ 的语言类。这些语言由以全称量词 ($\\forall$) 开头的公式描述。$\\Pi_1^P$ 是 `co-NP` 类。\n- $\\Delta_k^P$ 是可以由一个确定性多项式时间算法判定的语言类，该算法可以访问一个能解决 $\\Sigma_{k-1}^P$ 中任何问题的谕示。例如，$\\Delta_2^P = P^{\\text{NP}}$。已知 $\\Delta_k^P \\subseteq \\Sigma_k^P \\cap \\Pi_k^P$。\n\n考虑 `3-SAT` 问题，该问题询问一个给定的 3-合取范式（3-CNF）布尔公式是否存在满足赋值。现在，考虑一个相关语言，我们称之为 `UNIQUE-3-SAT`。该语言包含所有恰好只有一个满足赋值的 3-CNF 公式。\n\n下列哪个类别代表了 `UNIQUE-3-SAT` 问题最紧确的已知分类？\n\nA. $\\Sigma_1^P$ (即 `NP`)\n\nB. $\\Pi_1^P$ (即 `co-NP`)\n\nC. $\\Delta_2^P$\n\nD. $\\Sigma_2^P$ 但非 $\\Pi_2^P$\n\nE. $\\Pi_2^P$ 但非 $\\Sigma_2^P$", "solution": "给定 `UNIQUE-3-SAT`，即恰好有一个满足赋值的 3-CNF 公式的集合。将这个条件写成一个计数陈述：\n$$\n\\#\\text{SAT}(\\varphi)=1,\n$$\n其中 $\\#\\text{SAT}(\\varphi)$ 表示 $\\varphi$ 的满足赋值的数量。\n\n等价地，“恰好有一个满足赋值”这个条件可以分解为“至少有一个满足赋值”和“没有至少两个满足赋值”的合取。形式上，定义多项式时间可验证的谓词 $R(\\varphi,y)$，它检查赋值 $y$ 是否满足 3-CNF 公式 $\\varphi$。考虑以下语言：\n$$\nL_{\\text{SAT}}=\\{\\varphi \\in 3\\text{-CNF} \\mid \\exists y:\\ R(\\varphi,y)\\},\n$$\n$$\nL_{\\geq 2}=\\{\\varphi \\in 3\\text{-CNF} \\mid \\exists y_{1}\\exists y_{2}:\\ (y_{1}\\neq y_{2}) \\land R(\\varphi,y_{1}) \\land R(\\varphi,y_{2})\\}.\n$$\n根据定义，$L_{\\text{SAT}} \\in \\Sigma_1^P$，因为它对一个多项式有界的见证和一个多项式时间验证，只有一个开头的存在量词。同样，$L_{\\geq 2} \\in \\Sigma_1^P$，因为它可以用存在量词表达，作用于两个多项式有界的见证和一个多项式时间的检查。\n\n那么 `UNIQUE-3-SAT` 语言可以写成\n$$\n\\text{UNIQUE-3-SAT} \\;=\\; L_{\\text{SAT}} \\;\\cap\\; \\overline{L_{\\geq 2}}.\n$$\n这是 $A \\cap B$ 的形式，其中 $A \\in \\Sigma_1^P$ 且 $B \\in \\Pi_1^P$，因此\n$$\n\\text{UNIQUE-3-SAT} \\in \\text{DP},\n$$\n其中 $\\text{DP}=\\{A \\cap B \\mid A \\in \\Sigma_1^P,\\ B \\in \\Pi_1^P\\}$。\n\n接下来，我们使用标准包含关系 $\\text{DP} \\subseteq P^{\\text{NP}}=\\Delta_2^P$。一个可以访问 NP 谕示的确定性多项式时间机器通过以下方式判定 `UNIQUE-3-SAT`：\n- 查询 NP 谕示关于 $L_{\\text{SAT}}$ 的成员性（即，是否存在至少一个满足赋值），以及\n- 查询 NP 谕示关于 $L_{\\geq 2}$ 的成员性（即，是否存在两个不同的满足赋值），\n当且仅当第一个答案是“是”且第二个答案是“否”时接受。因此，\n$$\n\\text{UNIQUE-3-SAT} \\in \\Delta_2^P.\n$$\n\n根据已知的包含关系 $\\Delta_2^P \\subseteq \\Sigma_2^P \\cap \\Pi_2^P$，`UNIQUE-3-SAT` 同时属于 $\\Sigma_2^P$ 和 $\\Pi_2^P$；因此，断言其只属于其中一个的陈述是不正确的。目前没有已知的将 `UNIQUE-3-SAT` 归入 $\\Sigma_1^P$ 或 $\\Pi_1^P$ 的方法。在所提供的选项中，最紧确的已知分类是 $\\Delta_2^P$。", "answer": "$$\\boxed{C}$$", "id": "1429958"}, {"introduction": "现在，让我们来检验并推广我们对唯一性问题的理解。这个练习要求我们将前一个问题中关于“唯一性”的逻辑应用到一个更高层级的复杂问题上。通过这个实践，您将看到多项式时间层级的结构模式如何在更高层次上重复出现，从而加深对复杂度类递归定义的理解。[@problem_id:1429949]", "problem": "在计算复杂性理论中，多项式层级 (PH) 是一个推广了复杂性类 P、NP 和 co-NP 的复杂性类层级。该层级的各阶被表示为 $\\Sigma_k^P$、$\\Pi_k^P$ 和 $\\Delta_k^P$。第二阶的一个范式问题是判定一个具有两次量词交替的量化布尔公式 (QBF) 的真值。例如，语言 $QSAT_2$ 由所有形如 $\\exists \\vec{x} \\forall \\vec{y} \\, \\phi(\\vec{x}, \\vec{y})$ 的真公式组成，其中 $\\phi$ 是一个无量词的布尔公式，并且已知 $QSAT_2$ 是 $\\Sigma_2^P$-完全的。\n\n考虑一个相关但更微妙的判定问题。给定一个形如 $\\Phi = \\exists \\vec{x} \\forall \\vec{y} \\, \\phi(\\vec{x}, \\vec{y})$ 的 QBF。我们不仅关心是否存在一个满足存在量词量化的变量 $\\vec{x}$ 的赋值，还关心这样的赋值是否是*唯一的*。\n\n我们将语言 $UNIQUE\\_SAT_{\\exists\\forall}$ 定义如下：\n一个公式 $\\Phi = \\exists \\vec{x} \\forall \\vec{y} \\, \\phi(\\vec{x}, \\vec{y})$ 属于 $UNIQUE\\_SAT_{\\exists\\forall}$ 当且仅当存在*恰好一个*对变量 $\\vec{x}$ 的赋值 $\\vec{a}$，使得公式 $\\forall \\vec{y} \\, \\phi(\\vec{a}, \\vec{y})$ 为真。\n\n你的任务是确定 $UNIQUE\\_SAT_{\\exists\\forall}$ 语言在多项式层级中的精确分类。下列哪个选项正确地描述了它的复杂性？\n\nA. $UNIQUE\\_SAT_{\\exists\\forall}$ 是 $\\Sigma_2^P$-完全的。\n\nB. $UNIQUE\\_SAT_{\\exists\\forall}$ 是 $\\Pi_2^P$-完全的。\n\nC. $UNIQUE\\_SAT_{\\exists\\forall}$ 是 $DP_2$-完全的，其中 $DP_2 = \\{L_1 \\cap L_2 \\mid L_1 \\in \\Sigma_2^P, L_2 \\in \\Pi_2^P\\}$。\n\nD. $UNIQUE\\_SAT_{\\exists\\forall}$ 是 $\\Delta_3^P$-完全的 (即，对于 $P^{\\Sigma_2^P}$ 是完全的)。\n\nE. 以上选项均不正确。", "solution": "我们给定形如 $\\Phi=\\exists \\vec{x}\\,\\forall \\vec{y}\\,\\phi(\\vec{x},\\vec{y})$ 的输入公式，并询问是否存在唯一的赋值 $\\vec{a}$ 给 $\\vec{x}$，使得 $\\forall \\vec{y}\\,\\phi(\\vec{a},\\vec{y})$ 成立。定义语言\n$$\nUNIQUE\\_SAT_{\\exists\\forall}=\\left\\{\\Phi \\mid \\left|\\left\\{\\vec{a} \\mid \\forall \\vec{y}\\,\\phi(\\vec{a},\\vec{y})\\right\\}\\right|=1\\right\\}.\n$$\n\n第一步：将 $UNIQUE\\_SAT_{\\exists\\forall}$ 表示为一个 $\\Sigma_2^P$ 语言和一个 $\\Pi_2^P$ 语言的交集。\n\n- 令\n$$\nL_{\\geq 1}=\\left\\{\\Phi \\mid \\exists \\vec{x}\\,\\forall \\vec{y}\\,\\phi(\\vec{x},\\vec{y})\\right\\}.\n$$\n这就是范式 $\\Sigma_2^P$-完全语言 $QSAT_{2}$。\n\n- 令\n$$\nL_{\\leq 1}=\\left\\{\\Phi \\mid \\neg\\left(\\exists \\vec{x}_{1}\\neq \\vec{x}_{2}\\,\\forall \\vec{y}\\,\\left(\\phi(\\vec{x}_{1},\\vec{y})\\land \\phi(\\vec{x}_{2},\\vec{y})\\right)\\right)\\right\\}.\n$$\n其补集为\n$$\n\\overline{L_{\\leq 1}}=\\left\\{\\Phi \\mid \\exists \\vec{x}_{1}\\neq \\vec{x}_{2}\\,\\forall \\vec{y}\\,\\left(\\phi(\\vec{x}_{1},\\vec{y})\\land \\phi(\\vec{x}_{2},\\vec{y})\\right)\\right\\},\n$$\n它显然属于 $\\Sigma_2^P$（因为它具有一个 $\\exists\\forall$ 结构）。因此 $L_{\\leq 1}\\in \\Pi_2^P$。\n\n根据定义，\n$$\nUNIQUE\\_SAT_{\\exists\\forall}=L_{\\geq 1}\\cap L_{\\leq 1}.\n$$\n因此 $UNIQUE\\_SAT_{\\exists\\forall}\\in DP_2$，其中\n$$\nDP_{2}=\\{L_{1}\\cap L_{2}\\mid L_{1}\\in \\Sigma_2^P,\\,L_{2}\\in \\Pi_2^P\\}.\n$$\n\n第二步：在 $DP_2$ 内的完全性。\n\n成员性已被证明。对于困难性，可以观察到判定“至少一个见证”是 $\\Sigma_2^P$-完全的（通过 $QSAT_{2}$），而判定“至多一个见证”是 $\\Pi_2^P$-完全的，如上所证。使用带有选择变量的 QBF 上的标准乘积/不交并构造（通过在无量词矩阵内部分支来保持 $\\exists\\vec{x}\\,\\forall\\vec{y}$ 量词前缀），可以将任何形如 $L_1 \\cap L_2$（其中 $L_1\\in\\Sigma_2^P$ 且 $L_2\\in\\Pi_2^P$）的语言多一归约到 $UNIQUE\\_SAT_{\\exists\\forall}$。具体方法是，将一个输入映射到一个单一的 $\\exists\\vec{x}\\forall\\vec{y}$ 公式，当且仅当该输入属于 $L_1 \\cap L_2$ 时，其 $\\vec{x}$-见证的数量恰好为一；如果 $\\Sigma_2^P$-条件不满足，则数量为零；如果 $\\Pi_2^P$-条件不满足，则数量至少为二。因此 $UNIQUE\\_SAT_{\\exists\\forall}$ 是 $DP_2$-困难的，从而也是 $DP_2$-完全的。\n\n因此，在给定的选项中，正确的分类是 $UNIQUE\\_SAT_{\\exists\\forall}$ 是 $DP_2$-完全的。", "answer": "$$\\boxed{C}$$", "id": "1429949"}]}