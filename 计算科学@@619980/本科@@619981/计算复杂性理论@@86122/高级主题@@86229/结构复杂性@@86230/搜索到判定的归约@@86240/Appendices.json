{"hands_on_practices": [{"introduction": "我们将从一个典型的“通过排除法进行规约”的例子开始。在这个练习中，你将使用一个决策预言机来系统性地缩小搜索范围，从而在一个大图中找到一个特定的子结构。这个过程演示了搜索到决策规约的核心思想：通过迭代地移除那些对于任何解决方案都不是必需的元素，来揭示一个实际的解决方案 [@problem_id:1446692]。这个方法在许多领域都有应用，例如在生物信息学中寻找网络模体。", "problem": "在生物信息学领域，研究人员将蛋白质-蛋白质相互作用（PPI）网络建模为图，其中蛋白质是顶点，两个蛋白质之间的显著相互作用是边。一项关键任务是找到功能“基序”，它们是小的、重复出现的相互作用模式。\n\n假设您是一名计算生物学家，正在处理一个大型PPI网络，该网络由一个图 $G=(V, E)$ 表示，其中 $|V|=n$。您正在寻找一个特定的、已知的功能基序，该基序由一个较小的图 $H=(V_H, E_H)$ 表示，其中 $|V_H|=k$。该基序预期以*导出子图*的形式出现在 $G$ 中。由顶点子集 $S \\subseteq V$ 导出的 $G$ 的子图是一个包含顶点集 $S$ 以及 $E$ 中连接 $S$ 内两个顶点的所有边的图。\n\n您可以访问一个假设的、先进的计算服务，称为 `HAS_MOTIF`。此服务充当一个判定谕示机：您向其提供任意图 $G'$，如果 $G'$ 包含一个与 $H$ 同构的导出子图，它会立即返回 YES，否则返回 NO。该服务每次使用都非常昂贵，但您已经通过一次初始调用确认 `HAS_MOTIF(G)` 返回 YES。\n\n您的任务是设计一个算法，利用 `HAS_MOTIF` 谕示机找到 $G$ 中构成基序 $H$ 实例的 $k$ 个顶点的实际集合。您的算法为保证找到一个此类基序的顶点集，需要对 `HAS_MOTIF` 谕示机进行调用的最大次数是多少？请用 $n$ 和 $k$ 的函数表示您的答案。", "solution": "我们有一个判定谕示机 `HAS_MOTIF`，对于任何输入图，当且仅当该图包含一个与具有 $k$ 个顶点的固定模式 $H$ 同构的导出子图时，它返回 YES。我们已经确认，对于初始图 $G=(V,E)$（其中 $|V|=n$），`HAS_MOTIF`$(G)$ 返回 YES。目标是找到一个特定的顶点集 $S \\subseteq V$（其中 $|S|=k$），该集合在 $G$ 中导出一个 $H$ 的副本，同时最小化额外的谕示机调用次数。\n\n我们设计一个自归约算法，通过逐个删除顶点来缩小图，并始终保持当前图仍然包含一个 $H$ 的导出子图副本这一性质。过程如下：\n1. 初始化 $G_{0} := G$ 和 $V_{0} := V$。\n2. 对于 $t = 0,1,2,\\dots$，当 $|V_{t}| > k$ 时，从 $V_{t}$ 中任选一个顶点 $v$，并对导出子图 $G_{t} - v$ 查询 `HAS_MOTIF`。\n   - 如果 `HAS_MOTIF`$(G_{t} - v)$ 返回 YES，则设置 $G_{t+1} := G_{t} - v$ 和 $V_{t+1} := V_{t} \\setminus \\{v\\}$。这保留了至少一个 $H$ 的导出子图副本的存在性。\n   - 如果 `HAS_MOTIF`$(G_{t} - v)$ 返回 NO，则保留 $v$（不删除它）并尝试另一个不同的顶点。\n\n正确性：假设 `HAS_MOTIF`$(G_{t})$ 为 YES。如果存在某个 $k$-元集 $S \\subseteq V_{t}$（其中 $v \\notin S$），其上存在 $H$ 的一个导出子图副本，那么 $G_{t} - v$ 仍然包含该副本，因此谕示机返回 YES，删除 $v$ 是安全的。如果谕示机对 $G_{t} - v$ 返回 NO，那么 $G_{t}$ 中 $H$ 的每个导出子图副本都必须包含 $v$；因此 $v$ 是一个必要顶点，它必须存在于当前图及所有后续子图的任何大小为 $k$ 的解中。重复此过程可确保只要 $|V_{t}| > k$，就至少存在一个可移除的顶点，因为任何一个大小为 $k$ 的特定解 $S$ 都包含在 $V_{t}$ 中，且任何 $v \\in V_{t} \\setminus S$ 都是可移除的。当 $|V_{T}|=k$ 时，该过程终止。由于每次删除后 `HAS_MOTIF` 始终返回 YES，最终的 $k$-顶点图 $G_{T}$ 必然包含一个 $H$ 的导出子图副本，并且由于总共只有 $k$ 个顶点，这意味着 $G_{T}$ 本身与 $H$ 同构；因此 $V_{T}$ 就是所求的顶点集。\n\n查询复杂度上界：每次成功的删除（YES 结果）都使顶点数减少一。要从 $n$ 个顶点减少到 $k$ 个顶点，需要进行恰好 $n-k$ 次删除，因此至少有 $n-k$ 个 YES 回答和 $n-k$ 次此类谕示机调用。考虑 NO 回答：如果 `HAS_MOTIF`$(G_{t} - v)$ 为 NO，那么 $v$ 存在于 $G_{t}$ 的每个解中。一旦一个顶点在某个阶段成为必要顶点，它在之后的所有阶段中都保持为必要顶点，因为在进一步删除下，解的集合只会缩小，所以我们永远不需要重新测试它。此外，不同必要顶点的总数永远不会超过 $k$，因为每个解都恰好有 $k$ 个顶点，并且所有必要顶点都必须属于每个解。因此，在整个执行过程中，NO 回答的总数最多为 $k$。\n\n因此，算法所做的谕示机调用总数最多为\n$$(n-k) + k = n.$$\n此计数利用了 `HAS_MOTIF`$(G)$ 为 YES 的先验知识，并且不需要重新发出该初始查询。因此，该算法保证最多通过 $n$ 次对 `HAS_MOTIF` 的调用，就能找到一个有效的 $H$ 的 $k$-顶点实例。", "answer": "$$\\boxed{n}$$", "id": "1446692"}, {"introduction": "与通过排除来简化问题不同，另一种强大的策略是“增量式构建”解决方案。在这个练习中，你将学习如何通过逐一确定解的各个组成部分来解决一个搜索问题 [@problem_id:1446695]。你将利用决策预言机在每一步验证你的选择，从而逐步构建出完整的解。这种方法在解具有固定数量组件的问题时尤其有效，例如将一个数表示为特定数量的平方和。", "problem": "在计算复杂性理论领域，搜索到判定的归约是一种利用相应判定问题的预言机来解决搜索问题的方法。搜索问题要求找到一个解，而判定问题仅询问是否存在解。\n\n考虑将一个整数表示为平方和的问题，这是数论和计算机科学中一个备受关注的课题。假设你可以使用一个特定的计算预言机，我们称之为 $\\text{DECIDE\\_SUM\\_SQUARES}$。这个预言机接受两个输入：一个非负整数 $M$ 和一个正整数 $j$。如果 $M$ 可以表示为 $j$ 个非负整数的平方和（即，如果存在非负整数 $y_1, y_2, \\ldots, y_j$ 使得 $y_1^2 + y_2^2 + \\dots + y_j^2 = M$），它返回 $\\text{True}$，否则返回 $\\text{False}$。你可以假设每次调用此预言机都花费常量时间。\n\n你的任务是设计一个算法，利用这个预言机来解决相应的搜索问题：对于给定的非负整数 $N$ 和正整数 $k$，找到一个包含 $k$ 个非负整数的集合 $\\{x_1, x_2, \\ldots, x_k\\}$，使得 $x_1^2 + x_2^2 + \\dots + x_k^2 = N$。\n\n假设对于给定的输入 $N$ 和 $k$，总是保证存在解，请确定你的算法为找到这样一个整数集合所需调用 $\\text{DECIDE\\_SUM\\_SQUARES}$ 预言机的最大次数。将你的答案表示为关于 $N$ 和 $k$ 的函数。", "solution": "我们构建一个标准的搜索到判定的自归约，利用预言机一次确定一个平方数。维持一个剩余和以及剩余平方数的数量。\n\n算法：\n- 初始化剩余和 $R := N$ 以及剩余数量 $j := k$。\n- 对于从 $1$ 到 $k-1$ 的每个位置 $i$（等价地，当 $j \\geq 2$ 时）：\n  - 对于从 $0$ 到 $\\lfloor \\sqrt{R} \\rfloor$ 的 $t$：\n    - 查询 $\\text{DECIDE\\_SUM\\_SQUARES}(R - t^2, j-1)$。\n    - 如果预言机返回 $\\text{True}$，则设 $x_{i} := t$，更新 $R := R - t^{2}$ 和 $j := j-1$，并跳出内层循环以处理下一个位置。\n- 当 $j = 1$ 时，剩余的 $R$ 必定是一个完全平方数（这是由预言机响应所保证的不变量），因此设 $x_{k} := \\sqrt{R}$，无需再进行任何预言机调用。\n\n正确性可由归纳法得出：在每个阶段，如果预言机对某个 $t$ 返回 $\\text{True}$，则余项 $R - t^{2}$ 可以表示为 $j-1$ 个平方的和，因此继续这个过程将得到一个完整的表示。因为对于给定的 $N$ 和 $k$ 保证存在解，所以在每个阶段，$\\{0,1,\\ldots,\\lfloor \\sqrt{R} \\rfloor\\}$ 中至少有一个 $t$ 会成功。\n\n预言机调用复杂度：\n- 在一个剩余和为 $R$、剩余数量为 $j \\geq 2$ 的固定阶段，我们按递增顺序尝试 $t$。在最坏情况下，成功的 $t$ 是最后一个尝试的值，因此该阶段的预言机调用次数最多为 $\\lfloor \\sqrt{R} \\rfloor + 1$。\n- 由于在整个过程中 $R \\leq N$，每个阶段最多使用 $\\lfloor \\sqrt{N} \\rfloor + 1$ 次预言机调用。\n- 恰好有 $k-1$ 个这样的阶段（当 $j=1$ 时我们不需要任何调用）。\n\n因此，该算法使用的预言机调用次数的绝对最坏情况上界，表示为关于 $N$ 和 $k$ 的函数，是\n$$\n(k-1)\\bigl(\\lfloor \\sqrt{N} \\rfloor + 1\\bigr).\n$$\n该界限是算法可以保证达到的，与剩余和的演变方式无关，并且它用一个精确的表达式匹配了直观的 $O(k \\sqrt{N})$ 行为。", "answer": "$$\\boxed{(k-1)\\bigl(\\lfloor \\sqrt{N} \\rfloor + 1\\bigr)}$$", "id": "1446695"}, {"introduction": "现在，让我们来处理一个更复杂的任务，它将决策预言机用于解决优化问题。这个练习不仅要求找到一个解，而是要找到一个*最优*解 [@problem_id:1446683]。你将分两步走：首先，利用决策预言机的单调性，通过二分搜索高效地确定最优解的值（例如，需要外包的最少任务数）；然后，在已知最优值的情况下，应用自规约技术来构造出实际的解决方案本身。这种“二分搜索+自规约”的模式是解决计算理论中许多优化问题的强大范式。", "problem": "一家大型软件公司的项目经理正在监督一个包含 $N$ 个不同编程任务的项目。这些任务相互依赖；例如，任务A可能需要在任务B开始之前完成。这些依赖关系可以用一个有向图 $G$ 来表示，其中每个任务是一个顶点，一条从顶点 $u$ 到顶点 $v$ 的有向边意味着任务 $u$ 必须在任务 $v$ 之前完成。\n\n不幸的是，由于规划不善，任务依赖关系图中包含了循环依赖（即有向环）。例如，任务A依赖于B，B依赖于C，而C又依赖于A。这种环结构使得确定一个有效的任务执行顺序变得不可能。为了解决这个问题，经理必须“外包”一部分任务，这等同于从图中移除相应的顶点（及其关联的边）。目标是外包一个规模尽可能小的任务集合，以打破所有的环。\n\n该经理可以利用一个专门的外部咨询服务，该服务充当一个预言机（oracle）。该服务提供了一个函数 $\\text{CAN\\_BREAK}(G', k)$，它接受一个任务图 $G'$ 和一个整数 $k$ 作为输入。如果通过外包至多 $k$ 个任务可以打破 $G'$ 中的所有环，则该函数返回 $\\text{True}$，否则返回 $\\text{False}$。\n\n请设计一个高效的算法，利用 $\\text{CAN\\_BREAK}$ 预言机来找出一个必须外包的最小规模的任务集合。在最坏情况下，你的算法需要调用 $\\text{CAN\\_BREAK}$ 预言机总共多少次？请将你的答案表示为总任务数 $N$ 的函数。", "solution": "令 $G=(V,E)$ 为有向任务图，其中 $|V|=N$。一个反馈顶点集（FVS）是一个顶点子集 $S \\subseteq V$，使得 $G-S$ 是无环的。预言机谓词为\n$$\nP(k) \\equiv \\text{CAN\\_BREAK}(G,k),\n$$\n该谓词对于 $k$ 是单调不减的：如果 $P(k)$ 为真且 $k' \\geq k$，则 $P(k')$ 也为真。此外，$P(N)$ 无需调用预言机即为真，因为移除所有 $N$ 个顶点将得到一个无环图。\n\n步骤 1（找到最小规模 $k^{\\ast}$）。对 $k \\in \\{0,1,\\ldots,N\\}$ 进行二分搜索，以找到使得 $P(k^{\\ast})$ 为真的最小 $k^{\\ast}$。由于 $P$ 是单调的，对 $N+1$ 个候选值进行二分搜索，在最坏情况下最多需要 $\\lceil \\log_{2}(N+1) \\rceil$ 次预言机调用。\n\n步骤 2（通过自归约构造一个大小为 $k^{\\ast}$ 的显式FVS）。维护当前图 $H$（初始为 $H:=G$）、剩余预算 $r$（初始为 $r:=k^{\\ast}$）和部分解 $S$（初始为空）。当 $r>0$ 时，按任意固定顺序处理 $H$ 的顶点。对于每个当前顶点 $v$：\n- 对实例 $(H-v,\\,r-1)$ 查询预言机。如果 $\\text{CAN\\_BREAK}(H-v, r-1)$ 为真，则说明存在一个大小至多为 $r$ 的 $H$ 的反馈顶点集，该集合包含 $v$；于是设置 $S:=S \\cup \\{v\\}$，更新 $H:=H-v$，并将 $r$ 减一，即 $r:=r-1$。\n- 如果预言机返回假，则将 $v$ 保留在 $H$ 中，并继续处理下一个顶点。\n\n测试的正确性：$\\text{CAN\\_BREAK}(H-v, r-1)$ 为真，当且仅当存在一个集合 $T$ 满足 $|T| \\leq r-1$ 使得 $(H-v)-T$ 是无环的，这等价于 $H-(T \\cup \\{v\\})$ 是无环的，且 $|T \\cup \\{v\\}| \\leq r$。因此，该测试精确地刻画了是否存在一个包含 $v$ 且大小至多为 $r$ 的反馈顶点集。\n\n进展与终止：假设在某次迭代中，存在一个大小为 $r$ 的反馈顶点集 $S'$ 对应于当前的图 $H$。令 $v$ 为该固定顺序中第一个属于 $S'$ 的顶点。那么 $\\text{CAN\\_BREAK}(H-v, r-1)$ 为真，因此算法会将 $v$ 加入解集，并将 $r$ 减一。重复此过程，算法将精确地选择 $k^{\\ast}$ 个顶点后停止。原始图 $G$ 中的每个顶点最多被测试一次，因此该阶段在最坏情况下最多进行 $N$ 次预言机调用。\n\n总预言机调用次数：在最坏情况下，最多为 $N + \\lceil \\log_{2}(N+1) \\rceil$ 次。", "answer": "$$\\boxed{N+\\lceil \\log_{2}(N+1)\\rceil}$$", "id": "1446683"}]}