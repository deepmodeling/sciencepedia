{"hands_on_practices": [{"introduction": "要真正理解一个复杂性类，关键在于探究哪些运算能使其保持封闭。本练习 [@problem_id:1415409] 旨在提供一个关于 $\\mathbf{NP}$ 类闭包性质的概览，涵盖了并集、连接、克林星号（Kleene Star）等基本操作。通过思考如何为这些操作构造新的验证器和凭证（certificate），你将建立一套系统性的方法来证明闭包性质，为更深入的探索打下坚实的基础。", "problem": "在计算复杂性理论中，复杂度类非确定性多项式时间 (NP) 被定义为这样一类判定问题：对于其中的“是”实例，存在一个证据（certificate），该证据可由一台确定性图灵机在多项式时间内验证。一个重要的研究领域是理解对语言的哪些操作会保持该类的成员资格。\n\n设 $\\Sigma$ 是一个有限字母表。对于字母表 $\\Sigma$ 上的任意属于 NP 类的语言 $L, L_1, L_2$，考虑以下产生新语言的操作：\n\n1.  **并集：**$L_1 \\cup L_2 = \\{w \\mid w \\in L_1 \\text{ 或 } w \\in L_2\\}$\n2.  **连接：**$L_1 L_2 = \\{w_1 w_2 \\mid w_1 \\in L_1 \\text{ 且 } w_2 \\in L_2\\}$\n3.  **克林星号：**$L^* = \\bigcup_{i \\ge 0} L^i$，其中 $L^0 = \\{\\epsilon\\}$（只包含空字符串的语言），且对于 $i \\ge 1$，$L^i = L L^{i-1}$。\n4.  **补集：**$\\overline{L} = \\{w \\in \\Sigma^* \\mid w \\notin L\\}$\n5.  **循环移位：**$CYCLE(L) = \\{vu \\mid \\text{对于某些字符串 } u, v \\in \\Sigma^*, \\$uv \\in L\\}$\n\n下列哪个陈述是正确的？选择所有适用的选项。\n\nA. 语言 $L_1 \\cup L_2$ 总是属于 NP。\n\nB. 语言 $L_1 L_2$ 总是属于 NP。\n\nC. 语言 $L^*$ 总是属于 NP。\n\nD. 语言 $\\overline{L}$ 总是属于 NP。\n\nE. 语言 $CYCLE(L)$ 总是属于 NP。", "solution": "我们使用 NP 的验证机定义。一个语言 $L \\subseteq \\Sigma^{*}$ 属于 NP，如果存在一个确定性多项式时间验证机 $V$ 和一个多项式 $p$，使得对于每一个 $x \\in \\Sigma^{*}$，都有：\n$$\nx \\in L \\iff \\exists y \\in \\Sigma^{*} \\text{ s.t. } |y| \\le p(|x|) \\text{ and } V(x,y)=1.\n$$\n我们将证明 NP 在这些操作下是封闭的，但补集操作除外，因为在该操作下的封闭性将意味着 $\\mathrm{NP}=\\mathrm{coNP}$，而这是否成立尚不明确。\n\n对于并集，假设 $L_1,L_2 \\in \\mathrm{NP}$，其验证机分别为 $V_1,V_2$，多项式分别为 $p_1,p_2$。为 $L_1 \\cup L_2$ 定义一个验证机 $V$，其输入为 $(w,b,y)$。它首先检查 $b \\in \\{1,2\\}$，如果 $b=1$，则运行 $V_1(w,y)$；如果 $b=2$，则运行 $V_2(w,y)$。如果 $w \\in L_1 \\cup L_2$，那么存在 $b \\in \\{1,2\\}$ 和一个证据 $y$（其长度 $|y| \\le \\max\\{p_1(|w|),p_2(|w|)\\}$），使得 $V$ 接受。运行时间是 $|w|$ 的多项式，证据长度也是多项式，因此 $L_1 \\cup L_2 \\in \\mathrm{NP}$。所以 A 是正确的。\n\n对于连接，假设 $L_1,L_2 \\in \\mathrm{NP}$，其验证机分别为 $V_1,V_2$，多项式分别为 $p_1,p_2$。对于 $w \\in \\Sigma^{*}$，$w \\in L_1L_2$ 当且仅当存在字符串 $w_1,w_2$ 使得 $w=w_1w_2$，$w_1 \\in L_1$ 且 $w_2 \\in L_2$。定义一个验证机 $V$，其输入为 $(w,i,y_1,y_2)$。它首先根据 $|w_1|=i$ 将 $w$ 解析为 $w=w_1w_2$，然后运行 $V_1(w_1,y_1)$ 和 $V_2(w_2,y_2)$，并在两者都接受时接受。如果 $w \\in L_1L_2$，那么存在一个分割点 $i$ 和证据 $y_1,y_2$（其长度满足 $|y_1| \\le p_1(|w_1|) \\le p_1(|w|)$ 和 $|y_2| \\le p_2(|w_2|) \\le p_2(|w|)$），使得 $V$ 接受。总证据长度最多为 $|i|+|y_1|+|y_2|$，这是 $|w|$ 的多项式。验证过程也在 $|w|$ 的多项式时间内运行。因此 $L_1L_2 \\in \\mathrm{NP}$。所以 B 是正确的。\n\n对于克林星号，假设 $L \\in \\mathrm{NP}$，其验证机为 $V$，多项式为 $p$。对于 $w \\in \\Sigma^{*}$，$w \\in L^{*}$ 当且仅当存在一个整数 $k \\ge 0$ 和一个划分 $w=w_1\\cdots w_k$，使得每个 $w_i \\in L$（约定当且仅当 $w=\\epsilon$ 时 $k=0$）。定义一个验证机，其输入为 $(w,k,i_1,\\dots,i_{k-1},y_1,\\dots,y_k)$。它使用切割位置 $i_1,\\dots,i_{k-1}$ 将 $w$ 解析为 $w_1,\\dots,w_k$，检查 $k \\le |w|+1$（以排除指数级数量的空字符串片段），然后对每个 $i$ 运行 $V(w_i,y_i)$，并在所有都接受时接受。如果 $w \\in L^{*}$，则存在某个划分，其中 $k \\le |w|+1$，并且存在证据 $y_i$ 满足 $|y_i| \\le p(|w_i|)$。设对于某些常数 $C,d \\in \\mathbb{N}$，有 $p(n) \\le C n^d$。那么总证据长度最多为\n$$\nO(\\log |w|) + \\sum_{i=1}^{k} p(|w_{i}|) \\le O(\\log |w|) + C \\sum_{i=1}^{k} |w_{i}|^{d} \\le O(\\log |w|) + C |w|^{d},\n$$\n因为 $\\sum_{i=1}^{k} |w_{i}|=|w|$，且对于 $d \\ge 1$，有 $\\sum_{i} |w_{i}|^{d} \\le |w|^{d}$。验证机调用 $V$ 的次数 $k \\le |w|+1$ 次，每次调用时间都是 $|w|$ 的多项式，因此总时间是 $|w|$ 的多项式。所以 $L^{*} \\in \\mathrm{NP}$。因此 C 是正确的。\n\n对于补集，如果对于每个 $L \\in \\mathrm{NP}$ 都有 $\\overline{L} \\in \\mathrm{NP}$，那么 $\\mathrm{NP}=\\mathrm{coNP}$。这个等式是否成立尚不明确。因此，断言 NP 在通常情况下对补集操作是封闭的是不正确的。所以 D 是错误的。\n\n对于循环移位，定义 $CYCLE(L)=\\{vu \\mid \\exists u,v \\in \\Sigma^{*} \\text{ 且 } uv \\in L\\}$。假设 $L \\in \\mathrm{NP}$，其验证机为 $V$，多项式为 $p$。为 $CYCLE(L)$ 定义一个验证机 $V'$ 如下：对于输入 $(x,s,y)$，其中 $x \\in \\Sigma^{*}$，$s$ 是一个满足 $0 \\le s \\le |x|$ 的分割位置，将 $x$ 写为 $x=vu$（其中 $|v|=s$），然后构造 $uv$ 并运行 $V(uv,y)$，如果 $V$ 接受，则 $V'$ 也接受。如果 $x \\in CYCLE(L)$，那么存在 $u,v$ 使得 $x=vu$ 且 $uv \\in L$，因此存在一个证据 $y$，其长度 $|y| \\le p(|uv|)=p(|x|)$，使得 $V(uv,y)=1$。证据长度为 $|s|+|y|$，这是 $|x|$ 的多项式，并且验证过程在多项式时间内运行。因此 $CYCLE(L) \\in \\mathrm{NP}$。所以 E 是正确的。\n\n综合以上分析，正确的陈述是 A、B、C 和 E。", "answer": "$$\\boxed{ABCE}$$", "id": "1415409"}, {"introduction": "在掌握了标准的字符串操作后，我们将转向一个更抽象但极为根本的逻辑运算：存在量化。这个练习 [@problem_id:1415437] 探讨了 $\\mathbf{NP}$ 在“投影”（projection）操作下的闭包性，这本质上对应于在一个多项式有界的见证（witness）上进行存在量化。证明这一性质并不仅仅是一个学术练习，它正式地将基于验证器的 $\\mathbf{NP}$ 定义与基于非确定性图灵机的定义联系在一起，让你对 $\\mathbf{NP}$ 类的内在结构有更深刻的认识。", "problem": "在计算复杂性理论中，NP类（非确定性多项式时间）包含的是那些其提议解可以被高效验证的判定问题。形式上，如果存在一个称为验证机的确定性多项式时间图灵机 $V$ 和一个多项式 $p(n)$，使得对于字母表 $\\Sigma$ 上的任意字符串 $s \\in \\Sigma^*$，语言 $A$ 属于 NP 当且仅当：\n$s \\in A$ 存在一个证书字符串 $c \\in \\Sigma^*$，其长度 $|c| \\le p(|s|)$，使得 $V$ 接受对 $(s, c)$。\n\n考虑一个成对的语言 $L \\subseteq \\Sigma^* \\times \\Sigma^*$，已知其属于 NP。这意味着存在一个多项式时间的验证机 $V_L$ 和一个多项式 $p_L$，使得对于任意字符串对 $(x,y)$：\n$(x,y) \\in L$ 当且仅当存在一个证书 $w$，其长度 $|w| \\le p_L(|x|+|y|)$，使得 $V_L$ 接受输入 $((x,y), w)$。\n此外，对于任何 $(x,y) \\in L$，字符串 $y$ 的长度由字符串 $x$ 的长度多项式有界；也就是说，存在一个多项式 $q$ 使得 $|y| \\le q(|x|)$。\n\n现在，考虑 $L$ 在其第一个分量上的投影，这定义了一个新语言 $L_1$：\n$$L_1 = \\{ x \\in \\Sigma^* \\mid \\exists y \\in \\Sigma^* \\text{ such that } (x,y) \\in L \\}$$\n为了证明 $L_1$ 也属于 NP，我们必须构造一个新的多项式时间验证机（我们称之为 $V_1$），并为其确定一个合适的证书。对于输入字符串 $x$，以下哪个选项正确描述了这样一个验证机 $V_1$ 的构造和操作？\n\nA. $V_1$ 接受输入 $x$ 和一个证书 $w$。它非确定性地猜测一个多项式长度的字符串 $y$，然后模拟原始验证机 $V_L$ 在输入 $((x,y), w)$ 上的行为。\n\nB. $V_1$ 接受输入 $x$ 和一个由字符串 $y$ 组成的证书。然后它模拟原始验证机 $V_L$ 在输入 $((x,y), \\epsilon)$ 上的行为，其中 $\\epsilon$ 是空串，如果 $V_L$ 接受则 $V_1$ 也接受。\n\nC. $V_1$ 接受输入 $x$ 和一个证书 $c'$，该证书是字符串对 $\\langle y, w \\rangle$ 的编码。$V_1$ 首先解析 $c'$ 以提取 $y$ 和 $w$。然后它模拟原始验证机 $V_L$ 在输入 $((x,y), w)$ 上的行为，并且当且仅当 $V_L$ 接受时它才接受。\n\nD. 语言 $L_1$ 不一定在 NP 中，因为所需的字符串 $y$ 的长度没有界限，所以验证机无法在相对于 $x$ 长度的多项式时间内处理它。\n\nE. $V_1$ 接受输入 $x$ 和一个证书 $c'$，该证书是字符串对 $\\langle y, w \\rangle$ 的编码。它首先验证 $y$ 是某个已知的 NP 完全语言的成员，并且 $|w| \\le p_L(|x|+|y|)$，然后模拟 $V_L$ 在输入 $((x,y), w)$ 上的行为。", "solution": "我们给定一个属于 NP 的成对语言 $L \\subseteq \\Sigma^{*} \\times \\Sigma^{*}$。因此，存在一个确定性多项式时间验证机 $V_L$ 和一个多项式 $p_L$，使得对于任意 $(x,y)$，\n$$(x,y) \\in L \\iff \\exists w \\in \\Sigma^{*} \\text{ with } |w| \\le p_L(|x|+|y|) \\text{ and } V_L(((x,y),w)) \\text{ accepts}.$$\n我们还被告知第二个分量是多项式有界的：存在一个多项式 $q$，使得对于所有 $(x,y) \\in L$，我们有\n$$|y| \\le q(|x|).$$\n定义投影语言\n$$L_{1} = \\{ x \\in \\Sigma^{*} \\mid \\exists y \\in \\Sigma^{*} \\text{ such that } (x,y) \\in L \\}.$$\n要证明 $L_{1} \\in \\text{NP}$，我们必须构造一个确定性多项式时间验证机 $V_{1}$ 和一个多项式 $p_{1}$，使得对于任意 $x$，\n$$x \\in L_{1} \\iff \\exists c' \\in \\Sigma^{*} \\text{ with } |c'| \\le p_{1}(|x|) \\text{ and } V_{1}((x,c')) \\text{ accepts}.$$\n\n证书和验证机的构造：\n- 设 $x$ 的证书为一个字符串对 $(y,w)$ 的标准编码 $c' = \\langle y, w \\rangle$。使用任何固定的、多项式时间可解码且长度为多项式有界的配对函数。具体来说，存在一个多项式 $r$，使得对于所有字符串 $y,w$，\n$$|\\langle y, w \\rangle| \\le r(|y| + |w|),$$\n并且将 $\\langle y, w \\rangle$ 解码为 $(y,w)$ 的计算时间是 $|\\langle y, w \\rangle|$ 的多项式时间。\n- 验证机 $V_{1}$ 在输入 $(x,c')$ 上执行以下操作：\n  1. 解析 $c'$ 以获得 $(y,w)$。\n  2. 模拟 $V_{L}$ 在输入 $((x,y),w)$ 上的行为。\n  3. 当且仅当 $V_{L}$ 接受时，才接受。\n\n正确性：\n- 可靠性：如果 $V_{1}$ 接受 $(x,c')$，那么解析出的 $(y,w)$ 会使 $V_{L}$ 接受 $((x,y),w)$。因此，$(x,y) \\in L$，所以 $x \\in L_{1}$。\n- 完备性：如果 $x \\in L_{1}$，那么存在 $y$ 使得 $(x,y) \\in L$。根据 $L$ 属于 NP，存在 $w$ 使得 $|w| \\le p_{L}(|x|+|y|)$ 并且 $V_{L}$ 接受 $((x,y),w)$。那么 $c'=\\langle y,w \\rangle$ 会使 $V_{1}$ 接受。\n\n多项式证书大小：\n设 $s = |x|$。使用给定的界 $|y| \\le q(s)$ 和验证机界 $|w| \\le p_{L}(|x|+|y|)$，我们得到\n$$|w| \\le p_{L}(s + |y|) \\le p_{L}(s + q(s)).$$\n因此证书长度满足\n$$|c'| = |\\langle y, w \\rangle| \\le r(|y| + |w|) \\le r\\big(q(s) + p_{L}(s + q(s))\\big).$$\n定义多项式\n$$p_{1}(n) = r\\big(q(n) + p_{L}(n + q(n))\\big),$$\n所以 $|c'| \\le p_{1}(|x|)$。\n\n多项式时间验证：\n将 $c'$ 解析为 $(y,w)$ 的时间是 $|c'|$ 的多项式时间，因此也是 $|x|$ 的多项式时间。$V_{L}$ 的输入大小是 $|(x,y)| + |w| \\le |x| + |y| + |w| \\le s + q(s) + p_{L}(s + q(s))$，这是 $s$ 的多项式。由于 $V_{L}$ 在其输入长度的多项式时间内运行，因此 $V_{1}$ 的总运行时间是 $|x|$ 的多项式。\n\n因此，对于如上构造的验证机 $V_{1}$，$L_{1} \\in \\text{NP}$。在这些选项中，这与选项 C 中的描述完全对应：证书编码了 $y$ 和 $w$，$V_{1}$ 解析它们并在 $((x,y),w)$ 上运行 $V_{L}$。\n\n为什么其他选项不正确：\n- A：NP 验证定义中的验证机是确定性的；它不能依赖于对 $y$ 的非确定性猜测。相反，$y$ 必须是证书的一部分。\n- B：$L$ 的原始见证 $w$ 可能非空；一般情况下，省略 $w$ 会破坏完备性。\n- D：这是错误的，因为给定了多项式界 $|y| \\le q(|x|)$。\n- E：验证 $y$ 是否属于某个 NP 完全语言是无关的，而且通常来说，除非 $\\text{P}=\\text{NP}$，否则不知道是否可以在确定性多项式时间内完成；这对于验证 $L$ 的成员资格是不必要的。", "answer": "$$\\boxed{C}$$", "id": "1415437"}]}