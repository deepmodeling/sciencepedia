{"hands_on_practices": [{"introduction": "理解预言机图灵机最直接的方式就是亲手用它来解决一个问题。这个练习将挑战你使用一个能够判断一个数是否为质数的 `PRIME` 预言机，来判定一个给定的整数是否为半质数。通过这个过程，你将学会如何将一个复杂问题分解，并利用预言机作为基本构件来高效地构建算法 [@problem_id:1433319]。", "problem": "预言机图灵机（OTM）是一种标准的图灵机，配备了一条特殊的“预言机”纸带和三个特殊状态：`q_query`、`q_yes` 和 `q_no`。每当 OTM 进入 `q_query` 状态时，预言机就会瞬时执行一次计算。如果当前在预言机纸带上的字符串属于一个预定义的预言机语言 $L_{oracle}$，则机器转移到状态 `q_yes`；否则，它转移到状态 `q_no`。这个查询-回答过程被视为一个单一的计算步骤。\n\n考虑一个 OTM，我们称之为 $M$，它可以访问一个用于语言 `PRIME` = {$k \\mid k$ 是一个质数，其中 $k$ 以二进制表示} 的预言机。机器 $M$ 的目标是判定语言 `SEMIPRIME` = {$n \\mid n$ 是一个半质数，其中 $n$ 以二进制表示}。半质数是一个自然数，它是两个质数（这两个质数不一定不同）的乘积。\n\n下列哪个描述准确地表示了机器 $M$ 为了对任意给定的整数输入 $n > 1$ 正确判定 `SEMIPRIME` 所应实现的高级算法？\n\nA. 遍历从 2 到 $n-1$ 的所有整数 $i$。对每个 $i$，对 $i$ 查询 `PRIME` 预言机。如果预言机接受，则检查 $i$ 是否能整除 $n$。如果能，则停机并接受。如果循环结束仍未找到这样的 $i$，则停机并拒绝。\n\nB. 对输入 $n$ 查询 `PRIME` 预言机。如果预言机接受，则停机并拒绝。否则，遍历从 2 到 $\\lfloor \\sqrt{n} \\rfloor$ 的所有整数 $i$。对每个 $i$，如果 $i$ 整除 $n$，则对 $i$ 查询 `PRIME` 预言机。如果预言机接受，则停机并接受。如果循环结束仍未找到这样的因子，则停机并拒绝。\n\nC. 遍历从 2 到 $\\lfloor \\sqrt{n} \\rfloor$ 的所有整数 $i$。对每个 $i$，检查 $i$ 是否能整除 $n$。如果能，则令 $j = n/i$。然后，对 $i$ 查询 `PRIME` 预言机，并对 $j$ 查询 `PRIME` 预言机。如果两个查询都被接受，则停机并接受。如果循环结束仍未找到这样的数对 $(i, j)$，则停机并拒绝。\n\nD. 对输入 $n$ 查询 `PRIME` 预言机。如果预言机接受，则停机并拒绝。否则，停机并接受。\n\nE. 遍历从 2 到 $\\lfloor \\sqrt{n} \\rfloor$ 的所有整数 $i$。对每个 $i$，对 $i$ 查询 `PRIME` 预言机。如果预言机接受，则检查 $n$ 是否能被 $i$ 整除但不能被 $i^2$ 整除。如果可以，则令 $j=n/i$ 并对 $j$ 查询 `PRIME` 预言机。如果这第二个查询被接受，则停机并接受。如果循环结束，则拒绝。", "solution": "我们必须使用一个 `PRIME` 预言机来判定输入为 $n1$ 的 `SEMIPRIME` 语言。根据定义，当且仅当存在质数 $p$ 和 $q$ 使得 $n=pq$（允许 $p=q$）时，$n$ 是半质数。设 $p \\leq q$；那么 $p \\leq \\sqrt{n}$，因为如果 $p\\sqrt{n}$，则 $pq  \\sqrt{n}\\cdot \\sqrt{n} = n$，这与假设矛盾。因此，当且仅当存在一个整数 $i$ 满足 $2 \\leq i \\leq \\lfloor \\sqrt{n} \\rfloor$ 且 $i \\mid n$，并且 $i$ 和 $j = n/i$ 都是质数时，$n$ 是半质数。\n\n使用 `PRIME` 预言机，正确的高级算法因此必须：\n- 遍历 $i$ 从 $2$ 到 $\\lfloor \\sqrt{n} \\rfloor$。\n- 对每个 $i$，测试可整除性 $i \\mid n$。如果成立，则设 $j=n/i$。\n- 对 $i$ 和 $j$ 查询预言机；当且仅当两者都是质数时接受。\n- 如果找不到这样的数对，则拒绝。\n\n这与选项 C 完全匹配。其他选项是不正确的：\n- A 接受任何有质数因子的 $n$，例如 $n=12$，其中 $i=2$ 是质数且能整除 $n$，但 $12$ 不是半质数。\n- B 接受至少有一个小质数因子的合数，例如 $n=8$ 和 $i=2$，但 $8$ 不是半质数。\n- D 接受所有合数，因此错误地分类了非半质数的合数以及质数的平方。\n- E 通过要求 $i^{2} \\nmid n$ 错误地排除了质数的平方，因此它会拒绝 $n=9$，而 $n=3\\cdot 3$ 是一个半质数。\n\n因此，只有选项 C 使用 `PRIME` 预言机正确地判定了 `SEMIPRIME`。", "answer": "$$\\boxed{C}$$", "id": "1433319"}, {"introduction": "在设计了具体的预言机算法之后，让我们转向一个更深层次的理论问题。这个练习探讨了当预言机本身能解决的问题属于一个“简单”的复杂性类（如 $P$ 类）时，会发生什么。通过证明当预言机语言 $A \\in P$ 时，$P^A = P$ 成立，你将深入理解相对化复杂性的核心思想，并揭示一个“简单”的预言机并不会为多项式时间计算增加额外的能力 [@problem_id:1417476]。", "problem": "在计算复杂度理论中，谕示图灵机（OTM）是一种用于研究判定问题的抽象机器。它是一种带有额外“谕示”带和特殊状态的标准图灵机。当机器进入一个特殊的询问状态时，它可以在单个计算步骤内获得一个固定语言 $A$（“谕示语言”）的成员资格问题的答案。\n\n设 $P$ 和 $NP$ 分别是由确定性图灵机和非确定性图灵机在多项式时间内可判定的语言的标准复杂度类。对于一个给定的谕示语言 $A$，我们将 $P^A$ 定义为可由带谕示 $A$ 的确定性 OTM 在多项式时间内判定的语言类。类似地，$NP^A$ 是可由带谕示 $A$ 的非确定性 OTM 在多项式时间内判定的语言类。\n\n假设给定谕示语言 $A$ 本身是复杂度类 $P$ 的成员。在此条件下，下列哪些陈述*总是*正确的？选择所有适用项。\n\nA. $P^A = P$\nB. $NP^A = P^A$\nC. $NP^A = NP$\nD. $P^A$ 是所有多项式时间多一归约于 $A$ 的语言 $L$ 的集合。\nE. $P^A$ 是 $P$ 的一个真超集（即 $P \\subset P^A$），因为谕示提供了额外的计算能力。", "solution": "我们已知固定的谕示语言满足 $A \\in P$。我们在此条件下分析每个陈述。\n\n首先，回顾定义：$P^{A}$ 是可由带谕示 $A$ 的确定性谕示图灵机在多项式时间内判定的语言类，等价于可以在多项式时间内对 $A$ 进行多项式次自适应谕示查询（即多项式时间图灵可归约于 $A$）而判定的语言类。类似地，$NP^{A}$ 是其非确定性模拟。\n\n陈述 A: $P^{A} = P$。\n- 包含关系 $P \\subseteq P^{A}$ 是平凡的，因为确定性机器可以忽略谕示。\n- 对于 $P^{A} \\subseteq P$，设 $L \\in P^{A}$ 通过某个确定性谕示机器 $M^{A}$ 判定，该机器在长度为 $n = |x|$ 的输入上运行时间为 $q(n)$，其中 $q$ 是一个多项式。每个谕示查询的长度最多为 $q(n)$，因为 $M^{A}$ 在 $q(n)$ 步内最多能写入 $q(n)$ 个符号。由于 $A \\in P$，存在一个用于 $A$ 的确定性判定器，它在长度为 $m$ 的输入上运行时间为 $p(m)$，其中 $p$ 是一个多项式。我们可以通过使用 $A$ 的判定器来计算每个谕示的答案，从而在输入 $x$ 上模拟 $M^{A}$。查询总数最多为 $q(n)$（受步数限制），每个查询答案的计算成本最多为 $p(q(n))$ 时间。因此，总模拟时间最多为\n$$\nq(n) + q(n) \\cdot p(q(n)),\n$$\n它是 $n$ 的一个多项式，因为多项式的复合和乘积仍然是多项式。因此 $L \\in P$，所以 $P^{A} \\subseteq P$。因此，$P^{A} = P$。所以 A 是正确的。\n\n陈述 C: $NP^{A} = NP$。\n- 包含关系 $NP \\subseteq NP^{A}$ 是平凡的，因为非确定性机器可以忽略谕示。\n- 对于 $NP^{A} \\subseteq NP$，设 $L \\in NP^{A}$ 通过某个非确定性谕示机器 $N^{A}$ 判定，该机器在长度为 $n$ 的输入上运行时间为 $q(n)$，其中 $q$ 是一个多项式。如上所述，每个谕示查询的长度最多为 $q(n)$，并且在任何计算分支上最多有 $q(n)$ 次查询。因为 $A \\in P$ 且其判定器的时间为 $p(m)$，我们可以用 $p(q(n))$ 的时间确定性地模拟每个谕示答案。用这个确定性计算替换每个谕示步骤，会得到一个 $N^{A}$ 的非确定性模拟，其运行时间最多为\n$$\nq(n) + q(n) \\cdot p(q(n)),\n$$\n这是一个多项式。因此 $L \\in NP$，所以 $NP^{A} \\subseteq NP$。因此，$NP^{A} = NP$。所以 C 是正确的。\n\n陈述 B: $NP^{A} = P^{A}$。\n根据上面的 A 和 C，$P^{A} = P$ 且 $NP^{A} = NP$。如果 B 总是正确的，那将意味着 $NP = P$。这个等式是否成立尚属未知，并且仅凭 $A \\in P$ 这个条件也无法保证它成立。因此，B 不总是正确的。\n\n陈述 D: $P^{A}$ 是所有多项式时间多一归约于 $A$ 的语言 $L$ 的集合。\n根据定义，$P^{A}$ 对应于多项式时间图灵归约，而不一定是多一归约。此外，由于 $A \\in P$，我们已经知道 $P^{A} = P$。多项式时间多一归约于一个固定的 $A \\in P$ 的语言类不一定等于整个 $P$。一个具体的反例是 $A = \\emptyset$。如果 $L \\leq_{m}^{p} \\emptyset$，那么存在一个多项式时间函数 $f$，使得 $x \\in L$ 当且仅当 $f(x) \\in \\emptyset$，这意味着 $L = \\emptyset$。因此，多一归约于 $\\emptyset$ 的语言集合仅为 $\\{\\emptyset\\}$，而 $P^{\\emptyset} = P$。因此 D 是错误的。\n\n陈述 E: $P^{A}$ 是 $P$ 的一个真超集。\n根据 A，我们有 $P^{A} = P$，所以它不是一个真超集。因此，E 是错误的。\n\n因此，在 $A \\in P$ 的条件下总是正确的陈述是 A 和 C。", "answer": "$$\\boxed{AC}$$", "id": "1417476"}, {"introduction": "最后一个练习将向你展示预言机模型在实际应用中的强大威力，特别是如何利用它解决搜索问题。你将使用一个为布尔可满足性问题 (SAT) 服务的判定预言机，来找出一个不可满足公式中的“最小不可满足核心”。这个过程不仅让你能接触到计算复杂性理论中的一个核心难题，还展示了如何巧妙地将一个判定问题（回答“是”或“否”）的解决方案转化为一个寻找具体解（一个子集）的搜索算法 [@problem_id:1433316]。", "problem": "在计算复杂性理论中，预言图灵机是一种用于研究判定问题的抽象机。它可以被看作一个标准的图灵机，附加一个被称为“预言机”的“黑箱”，该预言机能够在一个单一操作中判定某些问题。对于本问题，我们考虑一个用于布尔可满足性（SAT）问题的预言机。这个预言机，记作 $\\mathcal{O}_{SAT}$，它接受任何合取范式（CNF）的布尔公式作为输入，如果公式是可满足的，则返回 `TRUE`，否则返回 `FALSE`。\n\n一个CNF公式是一个或多个子句的合取（AND），其中每个子句是若干文字（一个变量或其否定形式）的析取（OR）。一个不可满足的CNF公式 $\\phi$ 可能包含其子句的一个更小的子集，而该子集本身也是不可满足的。这样的子集被称为一个不可满足核心。一个最小不可满足核心是一个不可满足核心，它具有这样的性质：如果从中移除任何单个子句，剩余的子句集就变得可满足。\n\n考虑以下算法 `ReduceCore`，它被设计用来寻找一个给定的不可满足CNF公式 $\\phi = \\{C_1, C_2, \\ldots, C_m\\}$ 的最小不可满足核心。该算法依赖于 $\\mathcal{O}_{SAT}$ 预言机。\n\n**算法：`ReduceCore`**\n1. 初始化一个子句的工作集 $S$，使其成为输入公式 $\\phi$ 的一个副本。\n2. 按照给定的索引顺序，遍历原始公式 $\\phi$ 的子句 $C_1, C_2, \\ldots, C_m$。\n3. 对于原始公式中的每个子句 $C_i$，构造一个测试集 $S_{\\text{test}} = S \\setminus \\{C_i\\}$。请注意，$S$ 可能已被前面的步骤修改过。此测试旨在检验 $C_i$ 当前是否在 $S$ 中以及它是否可以被移除。\n4. 如果 $C_i$ 在 $S$ 中，用 $S_{\\text{test}}$ 查询预言机。如果 $\\mathcal{O}_{SAT}(S_{\\text{test}})$ 返回 `FALSE`（意味着在没有 $C_i$ 的情况下该集合仍然是不可满足的），则从工作集 $S$ 中永久地移除 $C_i$。\n5. 迭代完成后，算法返回最终的工作集 $S$。\n\n给定以下关于变量 $\\{a, b, c, d, e\\}$ 的不可满足CNF公式 $\\Phi$。该公式由9个子句组成，索引如下：\n- $C_1: (a \\lor b)$\n- $C_2: (a \\lor \\neg b)$\n- $C_3: (\\neg a \\lor c)$\n- $C_4: (\\neg a \\lor \\neg c)$\n- $C_5: (a \\lor d)$\n- $C_6: (\\neg a \\lor \\neg d)$\n- $C_7: (a \\lor c \\lor d)$\n- $C_8: (b \\lor c)$\n- $C_9: (\\neg b \\lor \\neg c \\lor e)$\n\n当在输入公式 $\\Phi$ 上执行 `ReduceCore` 算法时，其返回的最终集合中的子句数量是多少？", "solution": "初始化 $S=\\{C_{1},\\ldots,C_{9}\\}$。算法按顺序检查 $C_{1},\\ldots,C_{9}$。对于每个仍在 $S$ 中的 $C_{i}$，它查询 $\\mathcal{O}_{SAT}(S\\setminus\\{C_{i}\\})$，当且仅当预言机返回 FALSE（即，缩减后的集合仍然不可满足）时，移除 $C_{i}$。\n\n测试 $C_{1}$：考虑 $S\\setminus\\{C_{1}\\}=\\{C_{2},\\ldots,C_{9}\\}$。子句 $C_{3}:(\\neg a\\lor c)$ 和 $C_{4}:(\\neg a\\lor \\neg c)$ 共同排除了 $a=\\text{true}$ 的情况，所以可以设 $a=\\text{false}$。那么 $C_{2}$ 变为 $\\neg b$ 所以设 $b=\\text{false}$；$C_{5}$ 变为 $d$ 所以设 $d=\\text{true}$；$C_{6}$ 被 $\\neg a$ 满足；$C_{7}$ 被 $c\\lor d$ 满足（因为 $d=\\text{true}$）；$C_{8}$ 被 $b\\lor c$ 满足（选择 $c=\\text{true}$）；$C_{9}$ 被 $\\neg b$ 满足。因此 $S\\setminus\\{C_{1}\\}$ 是可满足的，所以 $\\mathcal{O}_{SAT}$ 返回 TRUE，保留 $C_{1}$。\n\n测试 $C_{2}$：考虑 $S\\setminus\\{C_{2}\\}$。同样地，由 $C_{3}$ 和 $C_{4}$ 可得 $a=\\text{false}$。那么 $C_{1}$ 变为 $b$ 所以设 $b=\\text{true}$；$C_{5}$ 变为 $d$ 所以设 $d=\\text{true}$；$C_{6}$ 被 $\\neg a$ 满足；$C_{7}$ 被 $c\\lor d$ 满足；$C_{8}$ 被 $b$ 满足；当 $b=\\text{true}$ 时，$C_{9}$ 需要 $\\neg c\\lor e$，所以，例如，选择 $e=\\text{true}$。因此 $S\\setminus\\{C_{2}\\}$ 是可满足的；预言机返回 TRUE，保留 $C_{2}$。\n\n测试 $C_{3}$：考虑 $S\\setminus\\{C_{3}\\}=\\{C_{1},C_{2},C_{4},C_{5},C_{6},C_{7},C_{8},C_{9}\\}$。设 $a=\\text{true}$ 和 $c=\\text{false}$；那么 $C_{4}$ 被 $\\neg c$ 满足，$C_{6}$ 变为 $\\neg d$ 所以设 $d=\\text{false}$，并且 $C_{1},C_{2},C_{5},C_{7}$ 被 $a$ 满足。设 $b=\\text{true}$ 使得 $C_{8}$ 被满足；$C_{9}$ 被 $\\neg c$ 满足。因此是可满足的；预言机返回 TRUE，保留 $C_{3}$。\n\n测试 $C_{4}$：考虑 $S\\setminus\\{C_{4}\\}$。设 $a=\\text{true}$ 和 $c=\\text{true}$；那么 $C_{3}$ 被 $c$ 满足，$C_{6}$ 变为 $\\neg d$ 所以设 $d=\\text{false}$，并且 $C_{1},C_{2},C_{5},C_{7}$ 被 $a$ 满足。例如，设 $e=\\text{true}$ 使得 $C_{9}$ 被满足；$C_{8}$ 被 $c$ 满足。因此是可满足的；预言机返回 TRUE，保留 $C_{4}$。\n\n测试 $C_{5}$：考虑 $S\\setminus\\{C_{5}\\}$。子句对 $C_{3}$ 和 $C_{4}$ 排除了 $a=\\text{true}$，所以 $a=\\text{false}$。那么 $C_{1}$ 变为 $b$ 而 $C_{2}$ 变为 $\\neg b$，这是一个矛盾。因此 $S\\setminus\\{C_{5}\\}$ 是不可满足的；预言机返回 FALSE，移除 $C_{5}$，所以 $S:=S\\setminus\\{C_{5}\\}$。\n\n测试 $C_{6}$：现在考虑 $S\\setminus\\{C_{6}\\}$，此时的 $S$ 不包含 $C_{5}$。应用相同的推理：$C_{3}$ 和 $C_{4}$ 迫使 $a=\\text{false}$，从 $C_{1}$ 和 $C_{2}$ 中产生出 $b$ 和 $\\neg b$，因此是不可满足的。预言机返回 FALSE，移除 $C_{6}$。\n\n测试 $C_{7}$：在 $C_{5}$ 和 $C_{6}$ 都已被移除的情况下，考虑 $S\\setminus\\{C_{7}\\}$。同样地，$C_{3}$ 和 $C_{4}$ 迫使 $a=\\text{false}$，从 $C_{1}$ 和 $C_{2}$ 中产生出 $b$ 和 $\\neg b$，因此是不可满足的。预言机返回 FALSE，移除 $C_{7}$。\n\n测试 $C_{8}$：考虑 $S\\setminus\\{C_{8}\\}$。如前所述，$C_{3}$ 和 $C_{4}$ 迫使 $a=\\text{false}$，因此 $C_{1}$ 和 $C_{2}$ 在 $b$ 上产生矛盾。因此是不可满足的；预言机返回 FALSE，移除 $C_{8}$。\n\n测试 $C_{9}$：考虑 $S\\setminus\\{C_{9}\\}=\\{C_{1},C_{2},C_{3},C_{4}\\}$。由于 $C_{3}$ 和 $C_{4}$ 迫使 $a=\\text{false}$，$C_{1}$ 变为 $b$ 而 $C_{2}$ 变为 $\\neg b$，产生一个矛盾。因此是不可满足的；预言机返回 FALSE，移除 $C_{9}$。\n\n完成迭代后，最终的集合是 $S=\\{C_{1},C_{2},C_{3},C_{4}\\}$，它包含 4 个子句，并且是包含关系上最小的不可满足集（移除这四个子句中的任何一个都会得到一个可满足集）。", "answer": "$$\\boxed{4}$$", "id": "1433316"}]}