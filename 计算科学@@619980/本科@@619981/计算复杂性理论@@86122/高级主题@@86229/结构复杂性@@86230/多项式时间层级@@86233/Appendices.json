{"hands_on_practices": [{"introduction": "多项式时间层级 (Polynomial-time Hierarchy, PH) 为我们提供了一个精细的框架来对 $P$ 和 $NP$ 之外的计算问题进行分类。然而，要真正理解这个层级，我们必须从其基础开始。这个练习将抽象的理论与一个具体的工程问题——电路验证——联系起来，通过将一个基本计算任务定位在层级中的正确位置，来巩固你对 $PH$ 最底层 $P = \\Sigma_0^p$ 的理解 [@problem_id:1461573]。", "problem": "在集成电路设计领域，一项基本任务是验证所设计的逻辑电路在给定输入集下的行为是否符合预期。我们可以将此任务建模为一个名为 `CHIP-VERIFY` 的计算问题。\n\n布尔电路由一组门组成。每个门是 AND、OR 或 NOT 类型。电路有一组主输入节点和一个指定的输出门。门与输入之间的连接是指定的，形成一个有向无环图。\n\n`CHIP-VERIFY` 问题定义如下：给定一个布尔电路的完整描述，以及对其每个主输入节点的布尔值（0 或 1）的具体赋值，确定该电路的指定输出门是否求值为 1。\n\n在计算复杂性理论中，多项式时间层级 (PH) 是一个推广了 P、NP 和 co-NP 等复杂性类的层级结构。对于任何整数 $k \\ge 0$，定义了类 $\\Sigma_k^p$ 和 $\\Pi_k^p$。一个语言 $L$ 属于 $\\Sigma_k^p$ 当且仅当存在一个多项式时间图灵机 $V$ 和一个多项式 $q$，使得对于任何输入 $x$，我们有：\n$$x \\in L \\iff \\exists y_1 \\forall y_2 \\dots Q_k y_k, \\ V(x, y_1, y_2, \\dots, y_k) = 1$$\n其中每个 $y_i$ 是长度至多为 $q(|x|)$ 的字符串，量词 $Q_k$ 在 $k$ 为奇数时是 $\\exists$，在 $k$ 为偶数时是 $\\forall$。一个语言属于 $\\Pi_k^p$ 如果其补集属于 $\\Sigma_k^p$。该层级的基础定义为 $\\Sigma_0^p = \\Pi_0^p = P$，即可在多项式时间内解决的问题类。\n\n基于这些定义，多项式时间层级中保证包含 `CHIP-VERIFY` 问题的最低复杂性类是什么？\n\nA. $\\Sigma_0^p$\n\nB. $\\Sigma_1^p$\n\nC. $\\Pi_1^p$\n\nD. $\\Sigma_2^p$\n\nE. 该问题不在多项式时间层级中。", "solution": "我们给定一个由 AND、OR 和 NOT 门组成的布尔电路，及其所有主输入的指定赋值，并被要求确定指定的输出门是否求值为 1。这正是电路求值问题 (Circuit Value Problem, CVP) 的判定版本。\n\n要判定输出值，我们可以按照电路有向无环图的拓扑顺序计算门的值：\n1. 将每个主输入的值初始化为给定的赋值。\n2. 按照拓扑顺序，对每个门根据其类型（AND、OR、NOT）从其前驱节点的值计算出自身的布尔值。\n3. 输出在指定输出门处计算出的值，当且仅当该值为 1 时接受。\n\n由于电路图是无环的，因此存在拓扑排序。每个门被处理一次，每条边被检查常数次，所以运行时间与电路描述的大小成线性关系，因此与输入长度成多项式关系。因此，`CHIP-VERIFY` 可以在多项式时间内解决，即 `CHIP-VERIFY` 属于 $P$。\n\n根据多项式时间层级的定义，其基础层级是 $P = \\Sigma_0^p = \\Pi_0^p$。由于 `CHIP-VERIFY` 属于 $P$，保证包含它的层级中的最低类别是 $\\Sigma_0^p$。\n\n因此，在这些选项中，正确的选择是 A。", "answer": "$$\\boxed{A}$$", "id": "1461573"}, {"introduction": "多项式时间层级的精妙之处在于它通过“预言机” (oracle) 的概念逐层构建。每一层都通过允许该层的计算机访问一个能够瞬间解决下一层问题的“魔法黑盒”来定义。这个练习深入探讨了这一构造过程，特别是通过考察当一台非确定性图灵机获得了解决 $SAT$ 问题的预言机能力时，我们所得到的计算能力对应于层级中的哪一类，从而揭示了 $NP$、预言机和 $\\Sigma_2^p$ 之间的内在联系 [@problem_id:1461565]。", "problem": "在计算复杂度理论中，我们分析解决计算问题所需的资源。非确定性多项式时间图灵机 (NPTM) 是一种理论计算模型，它可以同时探索多个计算路径。谕示图灵机是一种抽象机，用于借助一个称为谕示(oracle)的子程序来研究判定问题，该谕示可以在单一步骤内解决一个特定的问题。\n\n布尔可满足性问题 (SAT) 是判定是否存在一个能满足给定布尔公式的解释的问题。\n\n多项式时间层级 (PH) 是一个复杂度类的层级，它推广了 P、NP 和 co-NP 等类。该层级的各层级，对于整数 $k \\ge 0$，表示为 $\\Sigma_k^p$ 和 $\\Pi_k^p$，其定义如下：\n- $\\Sigma_0^p = \\Pi_0^p = P$\n- 对于 $k \\ge 0$：\n  - $\\Sigma_{k+1}^p = \\text{NP}^{\\Sigma_k^p}$，它表示可以由一个带有对任意 $\\Sigma_k^p$-完全问题的谕示、且在多项式时间内运行的 NPTM 所判定的语言集合。\n  - $\\Pi_{k+1}^p = \\text{co-}\\Sigma_{k+1}^p$\n\n考虑这样一个复杂度类，它包含所有可以由一台能够访问 SAT 问题谕示的非确定性多项式时间图灵机判定的语言。在多项式时间层级中，下列哪个类与这个类等价？\n\nA. $\\Sigma_1^p$\n\nB. $\\Pi_1^p$\n\nC. $\\Delta_2^p$\n\nD. $\\Sigma_2^p$\n\nE. $\\Pi_2^p$", "solution": "令 $C$ 表示所有可以由一台能够访问 SAT 谕示的非确定性多项式时间图灵机判定的语言所构成的类。根据定义，有 $C = \\text{NP}^{\\text{SAT}}$。\n\n回顾一下，在多项式时间多一归约下，SAT 是 $\\Sigma_1^p$-完全（NP-完全）的。多项式时间层级的定义使得\n$$\n\\Sigma_2^p = \\text{NP}^{\\Sigma_1^p},\n$$\n也就是说，这个类是由 NPTM 在多项式时间内，使用一个对任意 $\\Sigma_1^p$-完全问题的谕示所能判定的语言集合。\n\n首先，我们证明 $C \\subseteq \\Sigma_2^p$。由于 $\\text{SAT} \\in \\Sigma_1^p$，任何带有 SAT 谕示的 $\\text{NP}$ 机也是一个带有来自 $\\Sigma_1^p$ 的谕示的 $\\text{NP}$ 机，因此\n$$\n\\text{NP}^{\\text{SAT}} \\subseteq \\text{NP}^{\\Sigma_1^p} = \\Sigma_2^p.\n$$\n\n接下来，我们证明 $\\Sigma_2^p \\subseteq C$。设 $L \\in \\Sigma_2^p$。那么对于某个谕示 $O \\in \\Sigma_1^p$，有 $L \\in \\text{NP}^{O}$。因为 SAT 是 $\\Sigma_1^p$-完全的，所以存在一个多项式时间可计算的归约 $r$，使得对于所有的 $y$，有 $y \\in O$ 当且仅当 $r(y) \\in \\text{SAT}$。一台用谕示 $O$ 来判定 $L$ 的 NPTM，可以通过将每次对 $O$ 的查询 $y$ 替换为对 SAT 的查询 $r(y)$，从而被一台用 SAT 谕示的 NPTM 模拟。这个过程保持了多项式时间，所以\n$$\n\\text{NP}^{\\Sigma_1^p} \\subseteq \\text{NP}^{\\text{SAT}}.\n$$\n\n结合两个包含关系，我们得到\n$$\n\\text{NP}^{\\text{SAT}} = \\Sigma_2^p.\n$$\n\n因此，问题中所描述的类等于 $\\Sigma_2^p$，对应于选项 D。", "answer": "$$\\boxed{D}$$", "id": "1461565"}, {"introduction": "在计算复杂性理论中，判定问题（“是否存在解？”）和搜索问题（“请找出一个解。”）之间存在着深刻的联系。通常，如果我们能高效地判定一个问题，我们往往也能高效地找到一个解。这个练习将让你亲身体验一种强大的通用技术——自归约 (self-reducibility)，展示如何利用一个只能回答“是”或“否”的 $\\Sigma_k^p$ 判定预言机，系统性地、一步步地构建出满足条件的实际“见证” (witness) [@problem_id:1461585]。", "problem": "在计算复杂性理论中，多项式时间层级 (Polynomial-Time Hierarchy, PH) 是一个推广了 P、NP 和 co-NP 等复杂性类的复杂性层级结构。该层级中的类对于 $k \\ge 0$ 表示为 $\\Sigma_k^p$、$\\Pi_k^p$ 和 $\\Delta_k^p$。\n\n定义这些类的一种标准方法是通过量化布尔公式 (Quantified Boolean Formulas, QBFs)。一个 QBF 的形式为 $Q_1 \\vec{x}_1 Q_2 \\vec{x}_2 \\dots Q_k \\vec{x}_k \\phi(\\vec{x}_1, \\dots, \\vec{x}_k)$，其中每个 $Q_i$ 是一个量词（$\\forall$ 或 $\\exists$），每个 $\\vec{x}_i$ 是一组布尔变量，而 $\\phi$ 是一个无量词的布尔公式。\n\n$\\Sigma_k^p$ 类对应于这样一类问题集合，这些问题可以通过判定具有 $k$ 个交替量词且以存在量词开头的 QBF 的真值来解决。形式上，令 $L_k$ 为所有具有以下形式的为真的 QBF 构成的语言：\n$$ \\exists \\vec{x}_1 \\forall \\vec{x}_2 \\exists \\vec{x}_3 \\dots Q_k \\vec{x}_k \\phi(\\vec{x}_1, \\vec{x}_2, \\dots, \\vec{x}_k) $$\n其中 $\\phi$ 是一个无量词的公式。判定 $L_k$ 成员资格的问题是 $\\Sigma_k^p$ 类的完备问题。\n\n假设对于某个固定的整数 $k \\ge 1$，您获得了一个用于语言 $L_k$ 的计算预言机。这个预言机可以在单一步骤内判断任何具有 $\\Sigma_k^p$ 量词结构的给定公式是真是假。\n\n给定一个特定公式 $\\Phi$，保证它是语言 $L_k$ 中的一个真公式。该公式形式如下：\n$$ \\Phi = \\exists \\vec{x} \\: \\forall \\vec{y}_1 \\: \\exists \\vec{y}_2 \\dots Q_k \\vec{y}_{k-1} \\: \\psi(\\vec{x}, \\vec{y}_1, \\dots, \\vec{y}_{k-1}) $$\n这里，$\\vec{x} = (x_1, x_2, \\dots, x_n)$ 是最外层的由 $n$ 个存在量化变量组成的变量块。由于 $\\Phi$ 为真，因此至少存在一个对 $\\vec{x}$ 的满足赋值，称为“见证”，它使得公式的其余部分为真。\n\n您的任务是设计一个算法，使用 $L_k$ 预言机来找到 $\\vec{x}$ 的一个这样的见证。确定您的算法在最坏情况下必须对 $L_k$ 预言机进行的调用次数。将答案表示为 $n$ 的函数。", "solution": "该问题要求设计一个算法，使用一个能判定任何 $\\Sigma_k^p$ 公式真值的预言机，来为一个为真的 $\\Sigma_k^p$ 公式的最外层存在量化变量找到一个满足见证。我们需要找出该算法所需的预言机调用次数。\n\n我们将使用的核心原则是自归约性。我们可以一次一个分量地（从 $w_1$ 到 $w_n$）为 $\\vec{x}$ 构造见证赋值 $\\vec{w} = (w_1, w_2, \\dots, w_n)$。\n\n设给定的真公式为 $\\Phi = \\exists x_1, \\dots, x_n \\, \\Psi(x_1, \\dots, x_n)$，其中 $\\Psi$ 表示从第一个全称量词开始的公式余下部分，即 $\\Psi(\\vec{x}) = \\forall \\vec{y}_1 \\dots \\psi(\\vec{x}, \\dots)$。\n\n**步骤 1：确定 $w_1$ 的值。**\n\n我们知道存在一个见证。这意味着要么存在一个以 $w_1=1$ 开头的见证，要么存在一个以 $w_1=0$ 开头的见证（或两者都存在）。为了确定 $w_1$ 可以取哪个值，我们可以测试其中一种可能性，比如说 $w_1=1$。\n\n我们通过在原始公式 $\\Phi$ 中将 $x_1$ 固定为 1 来构造一个新公式 $\\Phi_1$：\n$$ \\Phi_1 = \\exists x_2, \\dots, x_n \\: \\forall \\vec{y}_1 \\: \\exists \\vec{y}_2 \\dots Q_k \\vec{y}_{k-1} \\: \\psi(1, x_2, \\dots, x_n, \\vec{y}_1, \\dots, \\vec{y}_{k-1}) $$\n这个新公式 $\\Phi_1$ 询问在第一个分量为 1 的情况下，是否存在一种方法来完成这个见证。注意到 $\\Phi_1$ 的量词结构仍然是一个以存在量词（$\\exists x_2, \\dots x_n$）开头的 $k$ 个交替量词序列。因此，$\\Phi_1$ 是一个 $\\Sigma_k^p$ 公式，我们可以使用我们的 $L_k$ 预言机来判定其真值。\n\n我们用公式 $\\Phi_1$ 对预言机进行一次调用。\n- **情况 1：预言机返回“真”。** 如果 $\\Phi_1$ 为真，这意味着存在一个以 1 开头的 $\\vec{x}$ 的见证。因此，我们可以明确地设置 $w_1=1$。我们的问题现在归约为在为真的（由预言机确认的）公式 $\\Phi_1$ 中，为剩余的变量 $(x_2, \\dots, x_n)$ 寻找一个见证。\n- **情况 2：预言机返回“假”。** 如果 $\\Phi_1$ 为假，这意味着不存在以 1 开头的 $\\vec{x}$ 的见证。然而，我们已知原始公式 $\\Phi$ 为真，这保证了至少存在一个见证。如果没有以 1 开头的见证，那么必定存在一个以 0 开头的见证。因此，我们可以明确地设置 $w_1=0$。我们不需要进行第二次预言机调用来确认这一点。问题现在归约为在 $x_1$ 被设置为 0 的公式中为 $(x_2, \\dots, x_n)$ 寻找一个见证。\n\n无论在哪种情况下，我们都通过恰好一次预言机调用来确定 $w_1$ 的正确值。\n\n**步骤 2：推广至 $w_i$。**\n\n我们可以推广这个过程。假设我们已经确定了见证的前 $i-1$ 个分量 $(w_1, w_2, \\dots, w_{i-1})$。我们现在需要找到 $w_i$。\n\n我们通过将前 $i-1$ 个变量固定为它们已确定的值，并将第 $i$ 个变量设置为 1，来构造一个公式 $\\Phi_i$：\n$$ \\Phi_i = \\exists x_{i+1}, \\dots, x_n \\: \\forall \\vec{y}_1 \\dots Q_k \\vec{y}_{k-1} \\: \\psi(w_1, \\dots, w_{i-1}, 1, x_{i+1}, \\dots, x_n, \\vec{y}_1, \\dots) $$\n同样，$\\Phi_i$ 是一个 $\\Sigma_k^p$ 公式，所以我们可以使用预言机。\n- 我们用 $\\Phi_i$ 查询预言机。\n- 如果预言机返回“真”，我们就设置 $w_i=1$。\n- 如果预言机返回“假”，我们知道对于前缀 $(w_1, \\dots, w_{i-1})$ 必定存在一个有效的补全（根据前面步骤的构造）。如果这个补全不能以 1 继续，那么它必定能以 0 继续。所以，我们设置 $w_i=0$。\n\n这个过程对从 $i=1$ 到 $n$ 的每个变量 $x_i$ 重复进行。对于每个变量，我们构造一个新的 $\\Sigma_k^p$ 公式，并恰好对 $L_k$ 预言机进行一次调用，以确定其在见证中的正确赋值。\n\n**步骤 3：计算预言机调用的总次数。**\n\n该算法迭代 $n$ 次，对 $\\vec{x}$ 中的每个变量迭代一次。在每次迭代中，它都恰好对 $L_k$ 预言机进行一次调用。因此，找到完整见证 $\\vec{w}$ 所需的预言机调用总次数恰好是 $n$。这在最坏情况下也成立，因为无论预言机的回答是什么，该逻辑都要求每个变量调用一次。每个新公式 $\\Phi_i$ 的构造时间是原始公式 $\\Phi$ 大小的多项式级别，因此整个算法相对于预言机在多项式时间内运行。\n\n预言机调用的总次数等于最外层存在量化块中的变量数量，即 $n$。", "answer": "$$\\boxed{n}$$", "id": "1461585"}]}