{"hands_on_practices": [{"introduction": "自我归约的概念弥合了判定解是否存在与实际找到一个解之间的鸿沟。第一个练习 [@problem_id:1446970] 提供了一个具体的起点，它要求你在已知一个布尔公式的满足赋值后，寻找第二个不同的满足赋值。这项实践对于理解如何通过操作逻辑公式来约束解空间至关重要，这是解决许多搜索问题的基础技术。", "problem": "在计算复杂性理论中，“预言机”（oracle）是一个有用的抽象概念。一个判定问题（例如布尔可满足性问题，简称SAT）的预言机是一个黑箱，它可以在一步之内回答任何给定的布尔公式是否可满足。SAT的自可归约性（self-reducibility）允许我们使用这样的预言机，不仅可以判定可满足性，还可以在解存在的情况下找到一个满足赋值。\n\n考虑以下具有四个变量 $x_1, x_2, x_3, x_4$ 的合取范式（CNF）布尔公式 $F$：\n$$ F = (x_1 \\lor x_3) \\land (\\neg x_2 \\lor x_4) \\land (\\neg x_1 \\lor \\neg x_3 \\lor x_4) $$\n已知赋值 $A = (x_1 \\mapsto \\text{True}, x_2 \\mapsto \\text{True}, x_3 \\mapsto \\text{False}, x_4 \\mapsto \\text{True})$ 是 $F$ 的一个满足赋值。\n\n你的任务是为 $F$ 找到第二个不同的满足赋值。完成此任务的标准方法是构造一个新公式，我们称之为 $F'$，该公式可满足当且仅当存在一个不同于 $A$ 的 $F$ 的满足赋值。一旦构造出 $F'$，就可以在标准的自可归约搜索中使用SAT预言机来找到这样一个赋值。\n\n以下哪项代表了为开始此过程必须构造的正确公式 $F'$？\n\nA. $ F \\land (\\neg x_1 \\lor \\neg x_2 \\lor x_3 \\lor \\neg x_4) $\n\nB. $ F \\land (x_1 \\land x_2 \\land \\neg x_3 \\land x_4) $\n\nC. $ F \\lor (\\neg x_1 \\lor \\neg x_2 \\lor x_3 \\lor \\neg x_4) $\n\nD. $ (\\neg x_1 \\lor \\neg x_2 \\lor x_3 \\lor \\neg x_4) $\n\nE. $ F \\land (x_1 \\lor x_2 \\lor \\neg x_3 \\lor x_4) $", "solution": "我们已知CNF公式 $F$ 和一个已知的满足赋值 $A$，$A$ 中 $x_{1}=\\text{True}$，$x_{2}=\\text{True}$，$x_{3}=\\text{False}$，$x_{4}=\\text{True}$。为了通过自可归约性使用SAT预言机找到第二个不同的满足赋值，我们必须构造一个公式 $F'$，该公式可满足当且仅当存在一个不同于 $A$ 的 $F$ 的满足赋值。标准的构造方法是通过将 $F$ 与一个在赋值 $A$ 上为假但在其他所有赋值上为真的子句进行合取，从而精确地排除赋值 $A$。\n\n赋值 $A$ 可以表示为将所有变量固定为其在 $A$ 中取值的合取式：\n$$\nC_{A} \\equiv x_{1} \\land x_{2} \\land \\neg x_{3} \\land x_{4}.\n$$\n为了精确地排除 $A$，我们添加这个合取式的否定。根据 De Morgan 定律，\n$$\n\\neg C_{A} \\equiv \\neg(x_{1} \\land x_{2} \\land \\neg x_{3} \\land x_{4}) = (\\neg x_{1} \\lor \\neg x_{2} \\lor x_{3} \\lor \\neg x_{4}).\n$$\n这个析取式是一个单一的子句，它在赋值 $A$ 上精确地为假，而在任何与 $A$ 至少在一个变量上不同的赋值上都为真。因此，所求的公式是\n$$\nF' \\equiv F \\land (\\neg x_{1} \\lor \\neg x_{2} \\lor x_{3} \\lor \\neg x_{4}).\n$$\n这就实现了所要求的等价性：如果 $F'$ 是可满足的，那么存在一个满足 $F$ 且不同于 $A$ 的赋值；反之，任何不是 $A$ 的 $F$ 的满足赋值都会满足添加的子句，从而也满足 $F'$。\n\n与选项匹配，这正是选项A。选项B和E没有排除 $A$（B强制赋值为 $A$ 本身；E的子句在 $A$ 上为真，但没有排除它）。选项C使用了与 $F$ 的析取，这不能保证结果是 $F$ 的一个满足赋值。选项D完全丢弃了 $F$，允许那些不满足 $F$ 的赋值。", "answer": "$$\\boxed{A}$$", "id": "1446970"}, {"introduction": "一个公式可能拥有多个满足赋值，但有时我们希望找到具有特定性质的解。这个问题 [@problem_id:1447155] 挑战你超越寻找“任意”解的范畴，去设计一个策略来找到一个“最小”满足赋值。通过比较不同的算法方法，你将更深刻地理解搜索顺序和逻辑如何直接影响最终解的属性，从而体会到自我归约方法的强大与精妙之处。", "problem": "在计算复杂性理论中，布尔可满足性问题（SAT）是一个基础性问题。给定一个关于变量集合 $\\{x_1, x_2, \\ldots, x_n\\}$ 的合取范式（CNF）布尔公式 $\\phi$，问题在于确定是否存在一种对变量的 TRUE 或 FALSE 赋值，使得整个公式的求值为 TRUE。\n\n假设你有一个被称为 SAT 预言机的假设性设备。这个预言机由函数 `is_sat(ψ)` 表示，它接收任意布尔公式 `ψ` 作为输入，如果 `ψ` 是可满足的，则立即返回 TRUE，否则返回 FALSE。尽管这样的预言机可以告诉你*是否存在*一个可满足赋值，但它不直接提供这个赋值。\n\n一个被称为自归约的著名过程使用这个预言机来为一个给定的可满足公式 $\\phi$ 找到一个可满足赋值。然而，一个公式可以有多个可满足赋值。我们感兴趣的是一种被称为*极小可满足赋值*的特定类型的赋值。一个可满足赋值 $A$ 被定义为**极小**的，如果对于在 $A$ 中被赋值为 TRUE 的任意变量 $x_i$，将其值翻转为 FALSE（同时保持所有其他变量赋值不变）会得到一个不再满足 $\\phi$ 的赋值。\n\n你的任务是找出一个正确且能保证成功的算法，该算法使用 SAT 预言机为一个给定的可满足公式 $\\phi$ 找到一个这样的极小可满足赋值。待考虑的算法从 $x_1$ 到 $x_n$ 逐个变量地构建赋值。在下面的描述中，$\\psi$ 表示一个从 $\\psi = \\phi$ 开始逐步构建的公式。最终的赋值用 $A$ 表示。\n\n下列哪个算法能正确且保证为任意可满足的输入公式 $\\phi$ 找到一个极小可满足赋值？\n\nA. 初始化 $\\psi = \\phi$。\n对于 $i = 1, \\ldots, n$：\n_    _如果 `is_sat`($\\psi \\land x_i$) 为 TRUE：\n_    _    _设置 $A(x_i) = \\text{TRUE}$ 并更新 $\\psi \\leftarrow \\psi \\land x_i$。\n_    _否则：\n_    _    _设置 $A(x_i) = \\text{FALSE}$ 并更新 $\\psi \\leftarrow \\psi \\land \\neg x_i$。\n返回 $A$。\n\nB. 初始化 $\\psi = \\phi$。\n对于 $i = 1, \\ldots, n$：\n_    _如果 `is_sat`($\\psi \\land \\neg x_i$) 为 TRUE：\n_    _    _设置 $A(x_i) = \\text{FALSE}$ 并更新 $\\psi \\leftarrow \\psi \\land \\neg x_i$。\n_    _否则：\n_    _    _设置 $A(x_i) = \\text{TRUE}$ 并更新 $\\psi \\leftarrow \\psi \\land x_i$。\n返回 $A$。\n\nC. 首先，使用标准的自归约方法（算法 A）找到一个任意的可满足赋值 $A_0$。\n初始化 $A = A_0$。\n对于 $i = 1, \\ldots, n$：\n_    _如果 $A(x_i)$ 为 TRUE：\n_    _    _令 $A'$ 为与 $A$ 相同但将 $x_i$ 设置为 FALSE 的赋值。\n_    _    _如果 $A'$ 满足 $\\phi$：\n_    _    _    _更新 $A \\leftarrow A'$。\n返回 $A$。\n\nD. 对于 $i = 1, \\ldots, n$：\n_    _令 $\\phi_T = \\phi \\land x_i$ 和 $\\phi_F = \\phi \\land \\neg x_i$。\n_    _如果 `is_sat`($\\phi_T$) 为 TRUE 且 `is_sat`($\\phi_F$) 为 TRUE：\n_    _    _设置 $A(x_i) = \\text{FALSE}$。\n_    _否则如果 `is_sat`($\\phi_T$) 为 TRUE：\n_    _    _设置 $A(x_i) = \\text{TRUE}$。\n_    _否则：\n_    _    _设置 $A(x_i) = \\text{FALSE}$。\n返回 $A$。", "solution": "我们想要一个算法，它总是返回一个可满足赋值，并保证其极小性，即对于输出中每个被设置为 TRUE 的变量，若将其翻转为 FALSE 同时保持所有其他变量固定，将使公式变得不可满足。\n\n算法 B：\n- 正确性（返回一个可满足赋值）：维持一个不变量：在第 $i$ 次迭代开始时，工作公式 $\\psi$ 等于 $\\phi$ 与 $x_{1},\\ldots,x_{i-1}$ 的固定值进行合取的结果，并且是可满足的。在第 $i$ 步，算法查询 $\\text{is\\_sat}(\\psi \\land \\neg x_{i})$。如果为 TRUE，则设置 $x_{i}=\\text{FALSE}$ 并更新 $\\psi \\leftarrow \\psi \\land \\neg x_{i}$，根据预言机的回答，该公式仍然是可满足的。否则，它设置 $x_{i}=\\text{TRUE}$ 并更新 $\\psi \\leftarrow \\psi \\land x_{i}$。这样做是安全的，因为 $\\psi$ 是可满足的且 $\\psi \\equiv (\\psi \\land x_{i}) \\lor (\\psi \\land \\neg x_{i})$；如果 $\\psi \\land \\neg x_{i}$ 是不可满足的，那么 $\\psi \\land x_{i}$ 必须是可满足的（否则 $\\psi$ 本身将是不可满足的）。根据归纳法，经过 $n$ 步之后，$\\psi$ 包含了对所有变量的赋值并且是可满足的，因此生成的 $A$ 满足 $\\phi$。\n\n- 极小性：设 $i$ 是任意一个使得 $A(x_{i})=\\text{TRUE}$ 的索引。这种情况只在第 $i$ 步中 $\\text{is\\_sat}(\\psi \\land \\neg x_{i})$ 返回 FALSE 时发生，此时 $\\psi$ 已经包含了 $x_{1},\\ldots,x_{i-1}$ 在 $A$ 中的固定值。预言机返回 FALSE 意味着不存在对 $x_{i+1},\\ldots,x_{n}$ 的赋值可以满足 $\\psi \\land \\neg x_{i}$。特别地，如果我们取 $A$ 中使用的 $x_{i+1},\\ldots,x_{n}$ 的最终值，那么\n$$\n\\phi \\land \\bigwedge_{j<i}\\ell_{j} \\land \\neg x_{i} \\land \\bigwedge_{j>i}\\ell_{j}\n$$\n是不可满足的，其中每个 $\\ell_{j}$ 根据 $A$ 的赋值是 $x_{j}$ 或 $\\neg x_{j}$。因此，将 $x_{i}$ 翻转为 FALSE 同时保持 $A$ 中所有其他变量不变，会使 $\\phi$ 为假。因此 $A$ 中的每个 TRUE 都是必要的，并且 $A$ 是极小的。所以算法 B 是正确的。\n\n算法 A：\n- 反例：设 $\\phi=(x_{1}\\lor x_{2})$。在 $i=1$ 时，$\\text{is\\_sat}(\\phi \\land x_{1})$ 为 TRUE，因此设置 $x_{1}=\\text{TRUE}$。在 $i=2$ 时，$\\text{is\\_sat}(\\phi \\land x_{1} \\land x_{2})$ 为 TRUE，因此设置 $x_{2}=\\text{TRUE}$。结果 $A(x_{1})=\\text{TRUE}$，$A(x_{2})=\\text{TRUE}$ 不是极小的，因为将 $x_{2}$ 翻转为 FALSE 仍然满足 $\\phi$。\n\n算法 C：\n- 反例：设 $\\phi=(\\neg x_{2}\\lor x_{1})$。算法 A 会产生 $A_{0}(x_{1})=\\text{TRUE}$，$A_{0}(x_{2})=\\text{TRUE}$，因为 $\\phi \\land x_{1}$ 和 $\\phi \\land x_{1} \\land x_{2}$ 都是可满足的。现在看算法 C：对于 $i=1$，尝试在保持 $x_{2}=\\text{TRUE}$ 的同时将 $x_{1}$ 翻转为 FALSE；$(\\neg x_{2}\\lor x_{1})$ 的求值为 FALSE，所以保持 $x_{1}=\\text{TRUE}$。对于 $i=2$，将 $x_{2}$ 翻转为 FALSE；$(\\neg x_{2}\\lor x_{1})$ 为 TRUE，所以设置 $x_{2}=\\text{FALSE}$ 并返回 $A=(x_{1}=\\text{TRUE},x_{2}=\\text{FALSE})$。这个 $A$ 不是极小的，因为将 $x_{1}$ 翻转为 FALSE 会得到 $(x_{1}=\\text{FALSE},x_{2}=\\text{FALSE})$，这仍然满足 $\\phi$。该算法的缺陷在于，单次遍历可能会错过由后续翻转操作创造出的、可以进一步简化的 TRUE 赋值。\n\n算法 D：\n- 反例（独立选择的不兼容性）：设\n$$\n\\phi=(x_{1}\\lor x_{2}) \\land (x_{1}\\lor x_{3}) \\land (x_{2}\\lor x_{3}).\n$$\n对于每个 $i\\in\\{1,2,3\\}$，$\\phi \\land x_{i}$ 和 $\\phi \\land \\neg x_{i}$ 都是可满足的（例如，$\\phi \\land \\neg x_{1}$ 可由 $x_{2}=\\text{TRUE},x_{3}=\\text{TRUE}$ 满足）。因此，算法 D 将所有变量设置为 FALSE，产生 $A=(\\text{FALSE},\\text{FALSE},\\text{FALSE})$，这并不满足 $\\phi$。因此 D 甚至不能保证找到一个可满足赋值。\n\n结论：只有算法 B 能够为任意可满足的输入 $\\phi$ 正确且总是返回一个极小可满足赋值。", "answer": "$$\\boxed{B}$$", "id": "1447155"}, {"introduction": "自我归约的威力远不止于布尔可满足性问题（SAT），它同样适用于许多其他问题，尤其是在图论领域。这个练习 [@problem_id:1447183] 展示了解决最大团问题（Maximum Clique）的一种经典两阶段自我归约策略。你将首先通过二分搜索确定最优解的大小，然后迭代地构建出解的本身。这项实践展现了“预言机”算法的通用性，揭示了如何利用一个判定型预言机来高效地解决一个复杂的优化和搜索问题，并巩固了“结合二分搜索寻找最优值与迭代搜索构建解”的通用模式。", "problem": "一位工程师的任务是分析一个复杂通信网络的结构，该网络可以建模为一个无向图 $G=(V, E)$，其中 $V$ 是 $n$ 个通信节点的集合，$E$ 是它们之间 $m$ 条直接链路的集合。该工程师需要识别出一个“核心通信枢纽”，它被定义为图中的一个最大团。团（clique）是一个顶点子集，其中任意两个不同的顶点都通过一条边相连。最大团是图中可能的最大规模的团。\n\n为了辅助这项任务，该工程师可以使用一个专门的硬件预言机。该预言机提供一个函数 `HAS_CLIQUE(G', k')`，它接受一个图 $G'$ 和一个整数 $k'$ 作为输入。如果 $G'$ 包含一个大小至少为 $k'$ 的团，它返回 `true`，否则返回 `false`。对该预言机的每次调用都算作一个计算步骤。\n\n您的任务是设计一个算法，利用这个预言机来找到构成图 $G$ 中一个最大团的顶点集合。对于一个有 $n$ 个顶点的图，您的算法最多需要调用多少次 `HAS_CLIQUE` 预言机？请用关于 $n$ 的闭式解析表达式来表示您的答案。", "solution": "问题要求设计一个算法，使用一个决策预言机在图 $G$ 中找到一个最大团，并确定所需预言机调用的最大次数。解决方案可分为两个主要阶段：首先，确定最大团的大小；其次，识别出构成该团的顶点。\n\n**阶段 1：确定最大团的大小 ($k_{\\max}$)**\n\n我们可以利用的核心性质是团问题的单调性。如果一个图包含一个大小为 $k$ 的团，那么它也必然包含所有小于 $k$ 的大小的团。这个性质使得该问题适合使用二分搜索。我们可以在 $[1, n]$ 范围内搜索使得预言机 `HAS_CLIQUE(G, k)` 返回 `true` 的最大整数 $k$。\n\n让我们定义二分搜索过程：\n1. 初始化搜索范围：`low = 1`，`high = n`。\n2. 初始化一个变量来存储至今找到的最大团的大小：`k_max = 0`。\n3. 当 `low <= high` 时：\n    a. 计算中点：`mid = floor((low + high) / 2)`。\n    b. 调用预言机：`result = HAS_CLIQUE(G, mid)`。\n    c. 如果 `result` 为 `true`，意味着存在一个大小为 `mid` 的团。这可能是我们的最大团，或者可能存在一个更大的团。因此，我们记录这个大小 `k_max = mid`，并通过将搜索空间调整到上半部分来尝试寻找更大的团：`low = mid + 1`。\n    d. 如果 `result` 为 `false`，则大小为 `mid` 的团不存在。因此，任何比 `mid` 更大的团也无法存在。我们必须在下半部分搜索更小的团：`high = mid - 1`。\n\n当二分搜索循环终止时，`k_max` 将持有图 $G$ 中最大团的大小。在大小为 $n$ 的范围上进行二分搜索，需要 $\\lceil \\log_{2}(n) \\rceil$ 次查询。\n\n**阶段 2：识别最大团的顶点**\n\n既然我们已经知道最大团的大小是 $k_{\\max}$，我们就可以使用一种自可约方法来找到构成这样一个团的具体顶点。最有效的方法是一个排除过程。\n\n算法流程如下：\n1. 初始化一个候选顶点集 `V_cand`，使其为原始图的完整顶点集 `V`。\n2. 逐一遍历原始顶点集 $V$ 中的每个顶点 $v$。对于每个 $v$：\n    a. 创建一个临时图 $G'$，它是由 `V_cand \\setminus \\{v\\}` 中的顶点在 $G$ 中导出的子图。\n    b. 调用预言机：`result = HAS_CLIQUE(G', k_max)`。\n    c. 如果 `result` 为 `true`，这意味着即使从我们当前的候选集中移除 $v$，一个大小为 $k_{\\max}$ 的团仍然存在。这表明 $v$ 不是必需的，所以我们可以通过将 `V_cand` 更新为 `V_cand \\setminus \\{v\\}` 来从候选集中永久地丢弃它。\n    d. 如果 `result` 为 `false`，这意味着 $v$ 对于在当前候选集内构成任何大小为 $k_{\\max}$ 的团都是必需的。因此，我们必须保留 $v$，并且不修改 `V_cand`。\n\n对原始图 $G$ 的所有 $n$ 个顶点重复此过程。对于 $n$ 个顶点中的每一个，我们都恰好调用一次预言机来决定是将其保留在候选池中还是丢弃。遍历完所有 $n$ 个顶点后，最终的集合 `V_cand` 将恰好包含 $k_{\\max}$ 个顶点。这些顶点构成一个最大团，因为我们已经系统地排除了所有对于构成一个大小为 $k_{\\max}$ 的团而言并非绝对必需的顶点。此阶段的预言机调用次数恰好是 $n$。\n\n**总预言机调用次数**\n\n总预言机调用次数是阶段 1 和阶段 2 调用次数的总和。\n总调用次数 = (寻找 $k_{\\max}$ 的调用次数) + (寻找顶点的调用次数)\n总调用次数 = $\\lceil \\log_{2}(n) \\rceil + n$\n\n因此，该算法所需的最大预言机调用次数为 $n + \\lceil \\log_{2}(n) \\rceil$。", "answer": "$$\\boxed{n + \\lceil \\log_{2}(n) \\rceil}$$", "id": "1447183"}]}