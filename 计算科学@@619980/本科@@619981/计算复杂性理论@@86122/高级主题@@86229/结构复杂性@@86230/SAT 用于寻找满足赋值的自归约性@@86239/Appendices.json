{"hands_on_practices": [{"introduction": "本练习以其最纯粹的形式展示了自可归约性的基本机制。通过使用一个假设的预言机，它能对一个公式的可满足性做出简单的“是/否”回答，我们可以系统地重构出一个完整的、唯一的解。这项实践对于理解如何利用决策问题的解决器来解决搜索问题至关重要，这是计算复杂性理论中的一个核心概念。[@problem_id:1447134]", "problem": "一位名叫 Ada 的计算机科学家正在使用一种特殊的计算设备，该设备用作一个预言机。这个预言机被设计用来解决布尔可满足性问题（SAT）的一个承诺版本。它接受一个布尔公式作为输入，并严格承诺该公式要么是不可满足的，要么恰好只有一个可满足赋值。\n- 如果输入的公式是不可满足的，预言机输出 `FALSE`。\n- 如果输入的公式有唯一的可满足赋值，预言机输出 `TRUE`。\n对于任何具有多于一个可满足赋值的公式，预言机的行为是未定义的。\n\n如果一个布尔公式是一个或多个子句的逻辑与，其中每个子句是一个或多个文字的逻辑或，那么它就处于合取范式（CNF）中。一个文字是一个变量或其否定。一个可满足赋值是为变量赋的一组特定的 `TRUE`/`FALSE` 值，它使得整个公式的求值为 `TRUE`。\n\nAda 得到了以下一个关于三个布尔变量 $x_1, x_2, x_3$ 的 CNF 公式 $\\Phi_0$：\n$$ \\Phi_0 = (x_1) \\land (x_1 \\lor x_2) \\land (\\neg x_1 \\lor \\neg x_2) \\land (\\neg x_1 \\lor x_3) $$\n她被保证 $\\Phi_0$ 恰好有一个可满足赋值。她的目标是通过向预言机进行一系列查询来确定这个唯一的赋值。\n\n请描述一个使用该预言机来找到 $\\Phi_0$ 的唯一可满足赋值的过程，并确定这个赋值。请将您的答案表示为一个单行矩阵，按顺序代表 $(x_1, x_2, x_3)$ 的值，其中 $1$ 代表 $\\text{True}$，$0$ 代表 $\\text{False}$。", "solution": "我们得到了一个用于承诺问题的预言机，对于任何保证为不可满足或恰好有一个可满足赋值的输入公式，它在后一种情况下输出 TRUE，在前一种情况下输出 FALSE；否则其行为是未定义的。原始公式\n$$\n\\Phi_0 = (x_1) \\land (x_1 \\lor x_2) \\land (\\neg x_1 \\lor \\neg x_2) \\land (\\neg x_1 \\lor x_3)\n$$\n被承诺恰好有一个可满足赋值。\n\n使用预言机确定唯一赋值的一般步骤：\n对每个变量 $x_i$ 按顺序操作，维持目前已固定的部分赋值。为确定 $x_i$ 的值，我们将当前的部分赋值与 $x_i=\\text{True}$ 合取来构成新公式，并用此公式查询预言机一次。如果预言机返回 TRUE，则设 $x_i=1$；如果返回 FALSE，则设 $x_i=0$。这个过程在每一步都遵守了承诺，因为既然 $\\Phi_0$ 有一个唯一的可满足赋值 $a$，那么对于任何被测试的 $x_i$，两种可能性 $x_i=1$ 或 $x_i=0$ 中恰好有一种与 $a$ 一致。被测试的公式要么是唯一可满足的（如果测试值与 $a_i$ 匹配），要么是不可满足的（如果不匹配）。\n\n将此过程应用于 $\\Phi_0$：\n\n1) 确定 $x_1$。对下面的公式 $F_1$ 查询预言机：\n$$\nF_1 \\equiv \\Phi_0 \\land x_1\n$$\n由于 $\\Phi_0$ 包含子句 $(x_1)$，任何可满足赋值都必须有 $x_1=1$，所以 $F_1$ 恰好有一个可满足赋值。因此预言机返回 TRUE，我们设定 $x_1=1$。\n\n2) 在 $x_1=1$ 的条件下确定 $x_2$。对下面的公式 $F_2$ 查询预言机：\n$$\nF_2 \\equiv \\Phi_0 \\land x_1 \\land x_2\n$$\n在 $x_1=1$ 和 $x_2=1$ 的条件下，子句 $(\\neg x_1 \\lor \\neg x_2)$ 的求值为 $0$，所以 $F_2$ 是不可满足的。因此预言机返回 FALSE，我们设定 $x_2=0$。\n\n3) 在 $x_1=1$ 和 $x_2=0$ 的条件下确定 $x_3$。对下面的公式 $F_3$ 查询预言机：\n$$\nF_3 \\equiv \\Phi_0 \\land x_1 \\land \\neg x_2 \\land x_3\n$$\n在 $x_1=1$，$x_2=0$，$x_3=1$ 的条件下对每个子句求值：\n- $(x_1)$ 变为 $1$，\n- $(x_1 \\lor x_2)$ 变为 $1 \\lor 0 = 1$，\n- $(\\neg x_1 \\lor \\neg x_2)$ 变为 $0 \\lor 1 = 1$，\n- $(\\neg x_1 \\lor x_3)$ 变为 $0 \\lor 1 = 1$。\n因此 $F_3$ 是可满足的，并且根据唯一性承诺，它恰好有一个可满足赋值，所以预言机返回 TRUE。因此 $x_3=1$。\n\n所以，唯一的可满足赋值是 $(x_1, x_2, x_3)=(1, 0, 1)$。", "answer": "$$\\boxed{\\begin{pmatrix}1 & 0 & 1\\end{pmatrix}}$$", "id": "1447134"}, {"introduction": "在基础自可归约算法之上，这个问题探索了如何处理额外的外部约束。许多现实世界的问题不仅需要满足一个核心逻辑公式，还需要满足一系列附加条件，例如本题中提出的不等式约束 ($x_i \\neq x_j$) 。本练习将指导你掌握一种强大的技术：将这些额外规则直接编码到合取范式 (CNF) 公式中，从而让一个标准的 SAT 预言机能够解决一个更复杂的约束问题。[@problem_id:1447152]", "problem": "在计算复杂性理论中，布尔可满足性问题（SAT）是一个基础问题。给定一个合取范式（CNF）的布尔公式，该问题旨在确定是否存在对其变量的一组真值（真/假）赋值，使得整个公式的计算结果为真。\n\nSAT 的一个关键特性是其自可约性。该特性意味着，如果我们有一个可以解决判定问题（即对一个公式是否可满足回答“是”或“否”）的“黑盒”预言机，我们就可以利用这个预言机为任何可满足的公式找到一个实际的满足赋值。标准算法的流程如下：对于一个具有变量 $x_1, x_2, \\ldots, x_n$ 的可满足公式 $\\phi$，它会迭代地确定每个变量的值。为了找到 $x_1$ 的值，它会询问预言机，将 $x_1$ 设置为“真”后的公式 $\\phi$ 是否可满足。如果可满足，我们就固定 $x_1 = \\text{True}$；否则，我们必须固定 $x_1 = \\text{False}$。对 $x_2, x_3, \\ldots, x_n$ 重复此过程，在每一步中代入已找到的变量的值。\n\n考虑一个 SAT 的变体，我们称之为 `UNEQUAL-SAT`。在一个 `UNEQUAL-SAT` 实例中，给定一个具有变量 $x_1, \\ldots, x_n$ 的标准 CNF 公式 $\\phi$，以及一组额外的成对不等式约束 $C = \\{(i_1, j_1), (i_2, j_2), \\ldots, (i_k, j_k)\\}$，其中每一对 $(i, j)$ 表示变量 $x_i$ 和 $x_j$ 的真值必须不同（即 $x_i \\neq x_j$）的约束。\n\n假设您可以使用一个标准的 SAT 预言机（它只能判定标准 CNF 公式的可满足性），以下哪一项描述了为给定的 `UNEQUAL-SAT` 实例 $(\\phi, C)$ 找到一个满足赋值的正确且完整的过程？\n\nA. 对于 $C$ 中的每个约束 $(i, j)$，将原始公式 $\\phi$ 与子句 $(x_i \\lor x_j)$ 和 $(\\neg x_i \\lor \\neg x_j)$ 进行逻辑与运算，从而构造一个新公式 $\\phi'$。然后，对新公式 $\\phi'$ 应用标准的自可约算法。\n\nB. 首先，使用标准的自可约算法为原始公式 $\\phi$ 找到一个满足赋值。然后，根据 $C$ 中的约束检查此赋值。如果某个约束 $x_i \\neq x_j$ 被违反，则翻转 $x_i$ 的值。重复此翻转过程，直到 $C$ 中的所有约束都得到满足。\n\nC. 在对变量 $x_k$ 的自可约循环中，当预言机建议一个值（例如 $x_k = \\text{True}$）后，手动检查此赋值是否违反了任何不等式约束 $x_k \\neq x_j$，其中 $x_j$ 已在前一步中被赋值。如果违反，则忽略预言机的建议，并将 $x_k$ 设置为相反的值。否则，接受预言机的建议。\n\nD. 该问题无法用标准的 SAT 预言机解决。由于 `UNEQUAL-SAT` 问题的结构与 SAT 有根本不同，因此需要一个能够直接处理不等式约束的预言机。", "solution": "给定一个关于变量 $x_{1},\\ldots,x_{n}$ 的 CNF 公式 $\\phi$ 和一组不等式约束 $C=\\{(i_{1},j_{1}),\\ldots,(i_{k},j_{k})\\}$，其中每个 $(i,j)\\in C$ 强制要求 $x_{i}\\neq x_{j}$。目标是仅使用一个标准的 SAT 预言机为实例 $(\\phi,C)$ 找到一个满足赋值。\n\n关键的观察点是，每个不等式约束 $x_{i}\\neq x_{j}$ 都可以用 CNF 表达，而无需引入新变量。对于布尔变量，等价关系\n$$\nx_{i}\\neq x_{j}\\iff (x_{i}\\lor x_{j})\\land(\\neg x_{i}\\lor \\neg x_{j})\n$$\n成立。为了证明这个等价关系，请注意 $x_{i}\\neq x_{j}$ 意味着 $x_{i},x_{j}$ 中恰好有一个为真。合取式 $(x_{i}\\lor x_{j})$ 强制要求至少有一个为真，而 $(\\neg x_{i}\\lor \\neg x_{j})$ 强制要求至少有一个为假。两者结合，强制要求恰好有一个为真，这正是 $x_{i}\\neq x_{j}$ 的含义。反之，如果两个子句都成立，那么它们不可能都为假（被 $x_{i}\\lor x_{j}$ 排除），也不可能都为真（被 $\\neg x_{i}\\lor \\neg x_{j}$ 排除），所以必须恰好有一个为真，因此 $x_{i}\\neq x_{j}$ 成立。\n\n利用这个等价关系，我们构造一个标准的 CNF 公式\n$$\n\\phi' \\;=\\; \\phi \\;\\land\\; \\bigwedge_{(i,j)\\in C}\\Big((x_{i}\\lor x_{j})\\land(\\neg x_{i}\\lor \\neg x_{j})\\Big)\n$$\n根据构造，一个赋值满足 $\\phi'$ 当且仅当它满足 $\\phi$ 和 $C$ 中的所有不等式。因此，$(\\phi,C)$ 是可满足的当且仅当 $\\phi'$ 是可满足的，并且 $\\phi'$ 的任何满足赋值都是 $(\\phi,C)$ 的一个满足赋值，反之亦然。\n\n在仅有一个用于 CNF 公式的标准 SAT 预言机的情况下，我们现在可以直接对 $\\phi'$ 应用标准的 SAT 自可约过程。假设变量排序为 $x_{1},\\ldots,x_{n}$。初始化一个空的部分赋值。对于从 $1$ 到 $n$ 的每个 $k$，通过将已经固定的值 $x_{1}=v_{1},\\ldots,x_{k-1}=v_{k-1}$ 代入 $\\phi'$ 来定义部分赋值的公式，然后在此基础上额外设置 $x_{k}=\\text{True}$，并用得到的公式询问预言机。如果预言机回答结果公式是可满足的，则设置 $x_{k}=\\text{True}$；否则，设置 $x_{k}=\\text{False}$。这是 SAT 的标准自可约方法，它保证了如果 $\\phi'$ 是可满足的，该过程将产生一个满足 $\\phi'$ 的完整赋值。因为 $\\phi'$ 同时编码了 $\\phi$ 和 $C$ 中的不等式，所以最终的赋值满足原始的 UNEQUAL-SAT 实例 $(\\phi,C)$。\n\n选项 B 和 C 是不正确的，因为它们将 $C$ 的强制执行与 $\\phi$ 的可满足性分离开来，在翻转赋值或覆盖预言机引导的选择时，若不重新检查可满足性，可能会破坏可满足性。选项 D 是不正确的，因为不等式约束可以用 CNF 表达，所以一个标准的 SAT 预言机就足够了。\n\n因此，正确且完整的流程是：将不等式约束编码成 CNF 子句，形成 $\\phi'$，然后对 $\\phi'$ 应用标准的 SAT 自可约算法。", "answer": "$$\\boxed{A}$$", "id": "1447152"}, {"introduction": "这项进阶实践的目标不再是寻找*任意*一个满足赋值，而是寻找一个具有特殊性质的解：最小满足赋值。最小赋值通常是理想的，因为它代表了一种“最简单”或最有效的解决方案。本练习挑战你修改标准的自可归约搜索策略本身，通过精心选择测试的顺序（例如，优先尝试将变量赋值为 `FALSE`），你可以引导搜索过程找到具有特定优化特征的解。[@problem_id:1447155]", "problem": "在计算复杂性理论中，布尔可满足性问题（SAT）是一个基础性问题。给定一个以变量集合 $\\{x_1, x_2, \\ldots, x_n\\}$ 为基础、呈合取范式（CNF）的布尔公式 $\\phi$，问题在于确定是否存在一组对变量的真（True）或假（False）赋值，使得整个公式的计算结果为真（True）。\n\n假设你有一个被称为 SAT 预言机（SAT oracle）的假设性设备。这个预言机由函数 `is_sat(ψ)` 表示，它接受任何布尔公式 `ψ` 作为输入，如果 `ψ` 是可满足的，则立即返回 `True`，否则返回 `False`。虽然这样的预言机可以告诉你*是否*存在一个满足赋值，但它不直接提供这个赋值。\n\n一个被称为自归约（self-reducibility）的著名过程利用这个预言机来为一个给定的可满足公式 $\\phi$ 找到一个满足赋值。然而，一个公式可以有许多满足赋值。我们感兴趣的是一种特定类型的赋值，称为*极小满足赋值*。一个满足赋值 $A$ 被定义为**极小的**，如果对于 $A$ 中任何被赋值为 `True` 的变量 $x_i$，将其值翻转为 `False`（同时保持所有其他变量的赋值不变）会导致该赋值不再满足 $\\phi$。\n\n你的任务是识别一个正确且有保证的算法，该算法使用 SAT 预言机为一个给定的可满足公式 $\\phi$ 找到一个这样的极小满足赋值。所考虑的算法从 $x_1$ 到 $x_n$ 逐个变量地构建赋值。在下面的描述中，$\\psi$ 表示一个逐步构建的公式，初始时 $\\psi = \\phi$。最终的赋值用 $A$ 表示。\n\n下列哪个算法能正确并保证为任何可满足的输入公式 $\\phi$ 找到一个极小满足赋值？\n\nA. 初始化 $\\psi = \\phi$。\n对于 $i = 1, \\ldots, n$：\n    如果 `is_sat`($\\psi \\land x_i$) 为 `True`：\n        设置 $A(x_i) = \\text{True}$ 并更新 $\\psi \\leftarrow \\psi \\land x_i$。\n    否则：\n        设置 $A(x_i) = \\text{False}$ 并更新 $\\psi \\leftarrow \\psi \\land \\neg x_i$。\n返回 $A$。\n\nB. 初始化 $\\psi = \\phi$。\n对于 $i = 1, \\ldots, n$：\n    如果 `is_sat`($\\psi \\land \\neg x_i$) 为 `True`：\n        设置 $A(x_i) = \\text{False}$ 并更新 $\\psi \\leftarrow \\psi \\land \\neg x_i$。\n    否则：\n        设置 $A(x_i) = \\text{True}$ 并更新 $\\psi \\leftarrow \\psi \\land x_i$。\n返回 $A$。\n\nC. 首先，使用标准的自归约方法（算法 A）找到一个任意的满足赋值 $A_0$。\n初始化 $A = A_0$。\n对于 $i = 1, \\ldots, n$：\n    如果 $A(x_i)$ 为 `True`：\n        令 $A'$ 为与 $A$ 相同但将 $x_i$ 设置为 `False` 的赋值。\n        如果 $A'$ 满足 $\\phi$：\n            更新 $A \\leftarrow A'$。\n返回 $A$。\n\nD. 对于 $i = 1, \\ldots, n$：\n    令 $\\phi_T = \\phi \\land x_i$ 且 $\\phi_F = \\phi \\land \\neg x_i$。\n    如果 `is_sat`($\\phi_T$) 为 `True` 且 `is_sat`($\\phi_F$) 为 `True`：\n        设置 $A(x_i) = \\text{False}$。\n    否则如果 `is_sat`($\\phi_T$) 为 `True`：\n        设置 $A(x_i) = \\text{True}$。\n    否则：\n        设置 $A(x_i) = \\text{False}$。\n返回 $A$。", "solution": "我们需要一个算法，它总是返回一个满足赋值，并保证极小性，即对于输出中每个被设置为 $\\text{True}$ 的变量，若将其翻转为 $\\text{False}$ 而保持所有其他变量不变，都会使公式变得不可满足。\n\n算法 B：\n- 正确性（返回一个满足赋值）：维持一个不变量，即在第 $i$ 次迭代开始时，工作公式 $\\psi$ 等于 $\\phi$ 与 $x_{1},\\ldots,x_{i-1}$ 的固定值联言（conjoined）的结果，并且是可满足的。在第 $i$ 步，算法查询 $\\text{is\\_sat}(\\psi \\land \\neg x_{i})$。如果为 `True`，则设置 $x_{i}=\\text{False}$ 并更新 $\\psi \\leftarrow \\psi \\land \\neg x_{i}$，根据预言机的回答，该公式保持可满足。否则，它设置 $x_{i}=\\text{True}$ 并更新 $\\psi \\leftarrow \\psi \\land x_{i}$。这样做是安全的，因为 $\\psi$ 是可满足的，并且 $\\psi \\equiv (\\psi \\land x_{i}) \\lor (\\psi \\land \\neg x_{i})$；如果 $\\psi \\land \\neg x_{i}$ 是不可满足的，那么 $\\psi \\land x_{i}$ 必须是可满足的（否则 $\\psi$ 将是不可满足的）。通过归纳法，经过 $n$ 步后，$\\psi$ 包含了所有变量的赋值并且是可满足的，因此生成的 $A$ 满足 $\\phi$。\n\n- 极小性：令 $i$ 为任何满足 $A(x_{i})=\\text{True}$ 的索引。这种情况只在第 $i$ 步 $\\text{is\\_sat}(\\psi \\land \\neg x_{i})$ 返回 `False` 时发生，此时 $\\psi$ 已经包含了 $A$ 中 $x_{1},\\ldots,x_{i-1}$ 的固定值。预言机返回 `False` 意味着不存在对 $x_{i+1},\\ldots,x_{n}$ 的赋值可以满足 $\\psi \\land \\neg x_{i}$。特别地，如果我们取 $A$ 中使用的 $x_{i+1},\\ldots,x_{n}$ 的最终值，那么\n$$\n\\phi \\land \\bigwedge_{j<i}\\ell_{j} \\land \\neg x_{i} \\land \\bigwedge_{j>i}\\ell_{j}\n$$\n是不可满足的，其中根据 $A$ 的赋值，每个 $\\ell_{j}$ 是 $x_{j}$ 或 $\\neg x_{j}$。因此，当保持 $A$ 中所有其他变量不变时，将 $x_{i}$ 翻转为 `False` 会使 $\\phi$ 为假。因此，$A$ 中的每个 `True` 都是必需的，且 $A$ 是极小的。所以 B 是正确的。\n\n算法 A：\n- 反例：令 $\\phi=(x_1 \\lor x_2)$。在 $i=1$ 时，$\\text{is\\_sat}(\\phi \\land x_1)$ 为 `True`，所以设置 $x_1=\\text{True}$。在 $i=2$ 时，$\\text{is\\_sat}(\\phi \\land x_1 \\land x_2)$ 为 `True`，所以设置 $x_2=\\text{True}$。结果 $A(x_1)=\\text{True}$，$A(x_2)=\\text{True}$ 不是极小的，因为将 $x_2$ 翻转为 `False` 仍然满足 $\\phi$。\n\n算法 C：\n- 反例：令 $\\phi=(\\neg x_2 \\lor x_1)$。算法 A 产生 $A_0(x_1)=\\text{True}$, $A_0(x_2)=\\text{True}$，因为 $\\phi \\land x_1$ 和 $\\phi \\land x_1 \\land x_2$ 都是可满足的。现在看算法 C：对于 $i=1$，尝试将 $x_1$ 翻转为 `False`，同时保持 $x_2=\\text{True}$；$(\\neg x_2\\lor x_1)$ 计算结果为 `False`，所以保持 $x_1=\\text{True}$。对于 $i=2$，将 $x_2$ 翻转为 `False`；$(\\neg x_2\\lor x_1)$ 为 `True`，所以设置 $x_2=\\text{False}$ 并返回 $A=(x_1=\\text{True}, x_2=\\text{False})$。这个 $A$ 不是极小的，因为将 $x_1$ 翻转为 `False` 会得到 $(x_1=\\text{False}, x_2=\\text{False})$，这仍然满足 $\\phi$。其缺陷在于，单次遍历可能会错过因后续翻转而产生的可进一步简化的 `True` 赋值。\n\n算法 D：\n- 反例（独立选择的不兼容性）：令\n$$\n\\phi=(x_1 \\lor x_2) \\land (x_1 \\lor x_3) \\land (x_2 \\lor x_3).\n$$\n对于每个 $i\\in\\{1,2,3\\}$，$\\phi \\land x_i$ 和 $\\phi \\land \\neg x_i$ 都是可满足的（例如，$\\phi \\land \\neg x_1$ 可由 $x_2=\\text{True},x_3=\\text{True}$ 满足）。因此，算法 D 会将所有变量都设置为 `False`，得到 $A=(\\text{False}, \\text{False}, \\text{False})$，但这不满足 $\\phi$。因此 D 甚至不能保证得到一个满足赋值。\n\n结论：只有算法 B 能正确并总是为任何可满足的输入 $\\phi$ 返回一个极小满足赋值。", "answer": "$$\\boxed{B}$$", "id": "1447155"}]}