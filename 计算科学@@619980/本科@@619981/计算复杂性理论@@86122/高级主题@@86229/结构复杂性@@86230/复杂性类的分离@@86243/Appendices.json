{"hands_on_practices": [{"introduction": "在开始探索复杂性类的分离之前，我们首先需要掌握计算资源之间的基本关系。这个练习旨在巩固一个基础但至关重要的概念：确定性时间和空间之间的联系。通过分析一个算法的时间复杂度，我们可以为其空间复杂度推导出一个确定的上界，这是理解更复杂的类包含关系的第一步。[@problem_id:1447409]", "problem": "在计算复杂性理论领域，我们根据在某个计算模型（通常是确定性图灵机）上解决问题所需的资源来对问题进行分类。复杂度类 $\\mathrm{DTIME}(t(n))$ 包含了所有可以由确定性图灵机在最多 $O(t(n))$ 时间内解决的判定问题，其中 $n$ 是输入规模。类似地，复杂度类 $\\mathrm{DSPACE}(s(n))$ 包含了所有可以由确定性图灵机使用最多 $O(s(n))$ 空间（即磁带单元）解决的判定问题。\n\n一位计算机科学家正在分析一个新开发的针对某个问题的算法。她已经正式证明，该算法在确定性单带图灵机上运行，并在与输入规模 $n$ 的立方成正比的步数内终止。也就是说，该问题属于复杂度类 $\\mathrm{DTIME}(n^3)$。\n\n仅根据此信息以及标准确定性时间和空间复杂度类之间的基本、既定关系，解决此问题所需空间复杂度的最紧*保证*上界是多少？\n\nA. $O(\\log n)$\nB. $O(n)$\nC. $O(n^{1.5})$\nD. $O(n^2)$\nE. $O(n^3)$\nF. $O(n^6)$\nG. $O(2^{O(n^3)})$", "solution": "令 $T(n)$ 表示给定确定性单带图灵机在长度为 $n$ 的输入上的时间复杂度（步数），$S(n)$ 表示其空间复杂度（使用的磁带单元数）。\n\n基本事实：在单带图灵机的每一步计算中，读写头最多只能访问一个新磁带单元。因此，在整个计算过程中可以访问到的不同磁带单元的总数最多是总步数。所以，\n$$\nS(n) \\leq T(n) + c\n$$\n对于某个常数 $c$，这意味着\n$$\nS(n) \\in O(T(n)).\n$$\n这就得出了标准的复杂度类包含关系\n$$\n\\mathrm{DTIME}(t(n)) \\subseteq \\mathrm{DSPACE}(t(n)).\n$$\n\n根据题意，该算法的运行时间为 $T(n) \\in O(n^{3})$，由此直接得出\n$$\nS(n) \\in O(T(n)) \\subseteq O(n^{3}).\n$$\n\n保证的紧密性：仅基于时间上界，一般情况下不能保证任何更小的渐进空间上界，因为我们可以设计出在 $O(n^{3})$ 时间内写入 $\\Theta(n^{3})$ 个不同磁带单元的计算，从而需要 $\\Theta(n^{3})$ 的空间。因此，从给定信息可以推导出的最紧保证上界是 $O(n^{3})$。\n\n因此，在这些选项中，最紧的保证上界是 $O(n^{3})$。", "answer": "$$\\boxed{E}$$", "id": "1447409"}, {"introduction": "计算复杂性理论不仅研究我们现实世界中的计算，还通过“谕示机” (oracle) 这一思想实验工具来探索各种可能的计算宇宙。在这个练习中，我们将挑战一个核心问题：在什么样的“神力”帮助下，$P$ 类问题能够等价于 $NP$ 类问题？通过构建一个能让 $P^A = NP^A$ 的谕示机 $A$，你将深入理解 $PSPACE$ 类的强大计算能力，并对 $P$ vs $NP$ 问题的深刻内涵有更清晰的认识。[@problem_id:1447404]", "problem": "在计算复杂性理论的框架内，我们可以探索在存在“预言机”（oracle）——一种能在单一步骤内解决特定语言问题的假设性设备——的情况下，复杂性类之间的关系如何变化。预言机图灵机（Oracle Turing Machine, OTM）是一种标准的图灵机，它增加了一条特殊的询问带和一个询问状态。当机器进入询问状态，且其询问带上有一个字符串 $w$ 时，如果 $w$ 属于预言语言 $A$，它会立即转换到一个“是”状态；否则，转换到一个“否”状态。\n\n类 $P^A$ 包含所有能由带有预言机 $A$ 的确定性 OTM 在多项式时间内判定的语言。类似地，$NP^A$ 是能由带有预言机 $A$ 的非确定性 OTM 在多项式时间内判定的语言类。\n\n对于本问题，回顾 PSPACE 是指能被确定性图灵机在多项式于输入长度的空间内判定的语言类。一个语言 $L$ 被定义为 PSPACE完全的，如果它在 PSPACE 中，并且 PSPACE 中的任何其他语言都可以在多项式时间内归约到 $L$。\n\n你的任务是找出一个*可判定的*预言语言 $A$ 的属性，该属性确保这两个相对化类的崩塌，即保证 $P^A = NP^A$。下列关于语言 $A$ 的哪个属性是充分条件？\n\nA. 语言 $A$ 是 NP完全的。\nB. 语言 $A$ 是 PSPACE完全的。\nC. 语言 $A$ 可在指数时间内判定，但不能在多项式时间内判定。\nD. 语言 $A$ 是有限的。\nE. 语言 $A$ 是正则的但不是有限的。", "solution": "目标是找到一个可判定的预言语言 $A$ 的属性，该属性保证 $P^A = NP^A$。我们将分析每个选项，但首先，我们将证明如果 $A$ 是 PSPACE完全的，则该等式成立。\n\n根据定义，确定性机器是非确定性机器的特例，因此 $P^A \\subseteq NP^A$ 总是成立的。为了证明相等，我们必须证明另一个方向：$NP^A \\subseteq P^A$。我们将通过证明这两个类都等于 $PSPACE$ 来做到这一点。\n\n**步骤 1：证明对于一个 PSPACE完全的预言机 $A$，有 $NP^A \\subseteq PSPACE$。**\n设 $L$ 是 $NP^A$ 中的一个语言。这意味着存在一台带有预言机 $A$ 的非确定性预言机图灵机（OTM）$M$，它在多项式时间内判定 $L$，对于长度为 $n$ 的输入，时间为 $p(n)$。\n\n我们可以用一台只使用多项式空间的确定性图灵机 $S$ 来模拟 $M$ 在输入 $x$ 上的计算。机器 $S$ 将系统地探索非确定性机器 $M$ 的所有可能计算路径。\n\n由于 $M$ 的运行时间为 $p(n)$，任何计算路径的长度最多为 $p(n)$。在任何一步中，非确定性选择的数量是一个固定的常数。因此，$S$ 可以以深度优先的方式探索所有路径。这需要存储 $M$ 的当前配置（带上内容、读写头位置、状态）以及到目前为止所做的选择路径。存储单个配置所需的空间是 $n$ 的多项式。\n\n当 $M$ 的模拟到达对字符串 $w$ 的预言机 $A$ 的一次询问时，模拟器 $S$ 必须确定是否 $w \\in A$。由于 $A$ 是 PSPACE完全的，它属于 $PSPACE$。这意味着存在一台确定性图灵机，它使用多项式空间来判定 $A$ 中的成员资格。所以，模拟器 $S$ 可以执行这个 $PSPACE$ 算法作为子程序来解决预言机询问。询问字符串 $w$ 的长度最多为 $p(n)$（因为它必须在多项式时间内写在询问带上），所以判定 $w \\in A$ 所需的空间是 $|w|$ 的多项式，也即是 $n$ 的多项式。\n\n模拟器 $S$ 使用的总空间是管理计算路径搜索所需空间与解决预言机询问所需空间之和。两者都是 $n$ 的多项式，所以总空间是多项式的。因此，$S$ 在多项式空间内判定 $L$。这意味着 $L \\in PSPACE$。\n由于 $L$ 是 $NP^A$ 中任意一个语言，我们已经证明了 $NP^A \\subseteq PSPACE$。\n\n**步骤 2：证明对于一个 PSPACE完全的预言机 $A$，有 $PSPACE \\subseteq P^A$。**\n设 $L$ 是 $PSPACE$ 中的任意一个语言。根据 $A$ 是 PSPACE完全的定义，任何这样的 $L$ 都可以多项式时间归约到 $A$ （记作 $L \\leq_p A$）。这意味着存在一个函数 $f$，它可由一台确定性图灵机在多项式时间内计算，使得对于任何输入字符串 $x$，$x \\in L$ 当且仅当 $f(x) \\in A$。\n\n我们可以构造一台确定性 OTM，称之为 $M'$，它使用预言机 $A$ 来判定 $L$。在输入 $x$ 上，$M'$ 的操作如下：\n1. 计算字符串 $y = f(x)$。由于 $f$ 可在多项式时间内计算，此步骤需要多项式时间。设此时间为 $q(|x|)$。\n2. 对预言机 $A$ 进行一次关于字符串 $y$ 的询问。这需要一步。\n3. 如果预言机回答“是”（意味着 $y \\in A$），$M'$ 接受。如果预言机回答“否”，$M'$ 拒绝。\n\n$M'$ 的总运行时间为 $q(|x|) + 1$，这是 $|x|$ 的多项式。由于 $M'$ 是确定性的，并且在多项式时间内判定 $L$，因此 $L \\in P^A$。\n由于 $L$ 是 $PSPACE$ 中的任意一个语言，我们已经证明了 $PSPACE \\subseteq P^A$。\n\n**步骤 3：结论。**\n从步骤 1，我们有 $NP^A \\subseteq PSPACE$。从步骤 2，我们有 $PSPACE \\subseteq P^A$。将这两者结合起来得到 $NP^A \\subseteq P^A$。\n再加上 $P^A \\subseteq NP^A$ 这个事实，我们得出结论 $P^A = NP^A$。\n因此，如果 $A$ 是 PSPACE完全的，该等式成立。这意味着选项 B 是一个充分条件。\n\n**其他选项的分析：**\n*   **A. 语言 $A$ 是 NP完全的。** 如果 $A$ 是 NP完全的（例如，SAT），那么 $P^A = P^{SAT}$ 且 $NP^A = NP^{SAT}$。$P^{SAT}=NP^{SAT}$ 是否相等是一个开放问题，并且与多项式谱系的崩塌有关。它不是一个有保证的结果。\n*   **C. 语言 $A$ 可在指数时间内判定，但不能在多项式时间内判定。** 这个条件不充分。事实上，Baker, Gill, 和 Solovay 的一个经典构造提供了一个这种类型的预言机，对于该预言机有 $P^A \\neq NP^A$。\n*   **D. 语言 $A$ 是有限的。** 任何有限语言都是正则的，并且在读取输入后可以在常数时间内（对于一个固定的语言）判定，这是多项式时间的一个特例。所以，如果 $A$ 是有限的，那么 $A \\in P$。一个 P 中的语言的预言机不增加计算能力，这意味着 $P^A=P$ 且 $NP^A=NP$。所以 $P^A=NP^A$ 等价于 $P=NP$，而这被认为是未知的。\n*   **E. 语言 $A$ 是正则的但不是有限的。** 与 D 类似，所有正则语言都在 $P$ 中。因此，这个预言机不增加能力，适用于 D 的推理也适用于此。\n\n所列出的属性中，唯一能保证 $P^A = NP^A$ 的是 $A$ 是 PSPACE完全的。", "answer": "$$\\boxed{B}$$", "id": "1447404"}, {"introduction": "在我们见识了谕示机如何能够“压缩”复杂性类之后，现在我们将探讨它的另一面：谕示机同样可以用来“拉开”它们之间的距离。本练习将引导你思考如何通过精巧的对角论证法来构造一个特殊的谕示机 $A$，从而证明在其世界中 $NP^A \\neq coNP^A$。理解这一构造过程，将揭示为何那些“相对化”的证明技术（即在任何谕示机下都成立的技术）无法解决 $P$ vs $NP$ 问题，这是计算复杂性理论中的一个里程碑式的发现。[@problem_id:1447430]", "problem": "在计算复杂性理论中，预言机被用作一种理论工具来探究复杂度类之间的关系。一个针对语言 $A$ 的预言机可以被想象成一个“黑箱”，它可以在单个计算步骤内回答任何成员查询“字符串 $w$ 是否在语言 $A$ 中？”。相对于预言机 $A$ 定义的复杂度类，如 $P^A$ 或 $NP^A$，包含了所有能被配备了该预言机访问权限的相应类型（例如，多项式时间确定性或非确定性）的机器所判定的语言。\n\nNP（非确定性多项式时间）类包含的语言，其“是”实例可以在给定一个合适的证据（certificate）的情况下，在多项式时间内被验证。coNP 类包含的语言，其“否”实例可以在多项式时间内被验证。一个语言 $L$ 属于 coNP 当且仅当其补集 $\\bar{L}$ 属于 NP。\n\n考虑以下依赖于预言机语言 $A$ 的语言 schema：\n$$U_A = \\{1^n \\mid \\text{存在一个长度为 } n \\text{ 的字符串 } x \\text{ 使得 } x \\in A\\}$$\n在这里，$1^n$ 表示一个由 $n$ 个连续'1'组成的字符串。一个已知的结果是，对于预言机 $A$ 的任何选择，语言 $U_A$ 都属于 $NP^A$ 类。\n\n你的任务是确定为了证明 $NP^A \\neq coNP^A$ 而构造的预言机 $A$ 所需具备的关键特性。这是通过确保语言 $U_A$ *不* 属于 $coNP^A$ 来实现的。 $A$ 的构造通过对角化论证进行，其中预言机的构建旨在专门击败每一个试图识别 $U_A$ 补集的可能的多项式时间机器。\n\n以下哪个陈述最好地描述了为实现此分离而构造的预言机语言 $A$ 的基本属性？\n\nA. 语言 $A$ 是 PSPACE-完全的。\nB. 对于每个整数 $n \\ge 1$，语言 $A$ 必须恰好包含一个长度为 $n$ 的字符串。\nC. 对于每个整数 $n \\ge 1$，语言 $A$ 包含零个或恰好一个长度为 $n$ 的字符串，其选择是系统地做出的，以便对所有候选的 coNP 机器进行对角化。\nD. 语言 $A$ 是所有回文二进制字符串的集合。\nE. 语言 $A$ 是一个有限语言。", "solution": "给定一个依赖于预言机的语言\n$$U_{A}=\\{1^{n}\\mid \\exists x, |x|=n \\text{ 且 } x\\in A\\}.$$\n$U_{A}\\in NP^{A}$ 总是成立的，因为一个 $NP^{A}$ 机器在输入 $1^{n}$ 时，可以非确定性地猜测一个长度为 $n$ 的字符串 $x$，并使用一次预言机查询在多项式时间内验证 $x\\in A$。\n\n为了分离 $NP^{A}$ 和 $coNP^{A}$，只需构建一个预言机 $A$ 使得 $U_{A}\\notin coNP^{A}$。对角化策略的运作方式是，确保对于每一个声称能判定 $\\overline{U_{A}}=\\{1^{n}\\mid \\forall x, |x|=n \\Rightarrow x\\notin A\\}$ 的多项式时间预言机 $M_{i}^{(\\cdot)}$，我们都选择一个新的长度 $n_{i}$，并定义 $A$ 在长度为 $n_{i}$ 的字符串上的行为，从而使 $M_{i}^{A}$ 在输入 $1^{n_{i}}$ 上出错。\n\n关键的组合优势来自于对 $A$ 的限制，即对于每个长度 $n$，集合 $A\\cap\\{0,1\\}^{n}$ 的大小至多为一。在此限制下，判定在长度为 $n$ 处的 $\\overline{U_{A}}$ 相当于证明没有长度为 $n$ 的字符串在 $A$ 中，也就是说，长度为 $n$ 的字符串集合是空的。一个最多进行多项式次预言机查询的多项式时间机器，无法在 $2^{n}$ 种可能性中排除存在一个未被查询的字符串。这使得可以对 $A$ 进行如下的对抗性定义。\n\n枚举所有的多项式时间预言图灵机 $\\{M_{1},M_{2},\\dots\\}$。对于阶段 $i$，选择一个之前未使用过的足够大的新长度 $n_{i}$。在输入 $1^{n_{i}}$ 上模拟 $M_{i}^{A}$，在模拟过程中，对任何关于长度为 $n_{i}$ 的字符串的查询都回答 0（即“不在 $A$ 中”），并根据先前的设定一致地回答其他长度的查询。由于 $M_{i}$ 在 $n_{i}$ 的多项式时间内运行，它最多发出多项式数量的关于长度为 $n_{i}$ 的查询。在 $M_{i}^{A}$ 停机后：\n- 如果 $M_{i}^{A}$ 接受（声称 $1^{n_{i}}\\in\\overline{U_{A}}$，即长度为 $n_i$ 的字符串集合是空的），则选择某个未被查询的长度为 $n_i$ 的字符串 $x$，并设定 $x\\in A$。这使得 $1^{n_{i}}\\in U_{A}$，与接受结果矛盾。\n- 如果 $M_{i}^{A}$ 拒绝（声称 $1^{n_{i}}\\notin\\overline{U_{A}}$，即字符串集合非空），则保持 $A\\cap\\{0,1\\}^{n_{i}}=\\varnothing$。这使得 $1^{n_{i}}\\notin U_{A}$，与拒绝结果矛盾。\n\n这总是可行的，因为在长度 $n_i$ 上总有未被查询的字符串，并且对于每个 $n$ 都有 $|A\\cap\\{0,1\\}^{n}|\\in\\{0,1\\}$ 的限制保证了各阶段之间的一致性并防止了未来的冲突。因此，对于所构造的 $A$，$U_{A}\\notin coNP^{A}$，故而 $NP^{A}\\neq coNP^{A}$。\n\n此构造中使用的 $A$ 的基本属性正是：对于每个长度 $n$，$A$ 包含零个或恰好一个该长度的字符串，其选择是针对所有候选的 $coNP^{A}$ 机器以对抗性方式（通过对角化）做出的。在这些选项中，这由陈述 C 所描述。陈述 A、D 和 E 没有抓住实现对角化所依赖的“每个长度上的稀疏性”，而陈述 B（每个长度上恰好有一个字符串）会使 $U_{A}$ 变得平凡，因此无法分离这两个类。", "answer": "$$\\boxed{C}$$", "id": "1447430"}]}