{"hands_on_practices": [{"introduction": "要真正掌握 NP-中间问题的概念，一个有效的方法是检验潜在的候选问题。这个练习提供了一个看似合理的候选语言 $L$——它由所有编码长度为偶数的可满足布尔公式组成。通过分析这个问题，你将亲身体验为何对一个 NP-完全问题（如 SAT）施加看似简单的句法约束，并不一定能降低其根本的计算复杂度，这有助于你更深刻地理解 NP-完全性的稳固性。", "problem": "在计算复杂性理论中，NP-中间类 (NP-intermediate) 被定义为这样一类判定问题的集合：这些问题属于 NP，但既不属于 P 也不属于 NP-完全。NP 是可在多项式时间内验证的判定问题类，而 P 是可在多项式时间内求解的判定问题类。Ladner 定理指出，如果 P 不等于 NP ($P \\neq NP$)，那么这个 NP-中间类是非空的。\n\n考虑布尔可满足性问题 (SAT)，该问题是已知的 NP-完全问题。假设一个学生提出了以下语言 $L$ 作为 NP-中间问题的一个潜在候选者：\n$$ L = \\{ \\phi \\mid \\phi \\text{ 是一个可满足的布尔公式，且其标准编码的长度 } |\\phi| \\text{ 是一个偶数} \\} $$\n\n假设 $P \\neq NP$，下列哪个陈述为语言 $L$ 不适合作为证明 NP-中间问题存在的例子提供了最准确和具体的理由？\n\nA. 语言 $L$ 可在多项式时间内判定，意味着 $L$ 属于 P 类。\n\nB. 语言 $L$ 是 NP-完全的。\n\nC. 语言 $L$ 不属于 NP 类。\n\nD. 任何 NP-中间问题的存在本身都取决于未经证实的 $P \\neq NP$ 猜想，这使得任何具体例子都纯粹是假设性的。\n\nE. 拥有偶数长度编码的属性是一个“语法”属性，这类属性不能改变底层“语义”问题（可满足性）的基本复杂性。", "solution": "我们分析语言\n$$L=\\{\\phi\\mid \\phi \\text{ 是一个可满足的布尔公式且 }|\\phi|\\text{ 是偶数}\\}$$.\n首先，我们证明 $L \\in \\text{NP}$。一个用于 $L$ 的非确定性验证机，以对 $\\phi$ 中变量的真值指派 $a$ 作为证据，并在多项式时间内检查：(i) $a$ 满足 $\\phi$，以及 (ii) $|\\phi|$ 是偶数。这两项检查都是多项式时间的：在给定 $a$ 的情况下评估 $\\phi$ 的时间是 $|\\phi|$ 的多项式，而计算 $|\\phi|$ 的奇偶性是微不足道的。因此 $L \\in \\text{NP}$。\n\n接下来，我们通过给出 $\\text{SAT}$ 和 $L$ 之间的双向多项式时间多一归约来证明 $L$ 是 NP-完全的。\n\n归约 $\\text{SAT} \\le_p L$：给定任意布尔公式 $\\psi$，我们构造一个 $f(\\psi)$，使得 $\\psi \\in \\text{SAT}$ 当且仅当 $f(\\psi) \\in L$。我们需要 $f(\\psi)$ 可满足当且仅当 $\\psi$ 可满足，并且其长度总是偶数。令 $\\tau(v)$ 表示一个关于新变量 $v$ 的固定重言式，例如 $\\tau(v)=(v \\lor \\lnot v)$。设 $c_0$ 和 $c_1$ 是两个重言式小工具 (gadget)，它们的编码具有相反的奇偶性，这可以通过使用编码长度奇偶性不同的变量名来保证（在任何标准编码下，可以选择变量标识符来将编码长度调整一）。具体来说，设 $\\tau_0(v_0)$ 和 $\\tau_1(v_1)$ 是满足 $|\\tau_0(v_0)| \\equiv 0 \\pmod{2}$ 和 $|\\tau_1(v_1)| \\equiv 1 \\pmod{2}$ 的重言式。定义\n$$f(\\psi)=\\psi \\land \\tau_b(v_b),$$\n其中 $b \\in \\{0,1\\}$ 的选择要使得 $|f(\\psi)|$ 为偶数；我们可以通过计算 $|\\psi|$ 的奇偶性以及连接词和 $\\tau_0、\\tau_1$ 的固定奇偶性来确定 $b$。这个计算只使用编码长度的奇偶性，并且是多项式时间的。由于 $\\tau_b(v_b)$ 是一个重言式，因此 $f(\\psi)$ 可满足当且仅当 $\\psi$ 可满足。此外，根据构造，$|f(\\psi)|$ 是偶数。因此 $\\psi \\in \\text{SAT}$ 当且仅当 $f(\\psi) \\in L$，所以 $\\text{SAT} \\le_p L$。\n\n归约 $L \\le_p \\text{SAT}$：定义 $g(\\phi)$ 如下\n$$\ng(\\phi)=\\begin{cases}\n\\phi, & \\text{若 }|\\phi|\\text{ 是偶数},\\\\\n(x \\land \\lnot x), & \\text{若 }|\\phi|\\text{ 是奇数},\n\\end{cases}\n$$\n其中 $x$ 是一个新变量。计算 $|\\phi|$ 模 2 是多项式时间的，并且 $(x \\land \\lnot x)$ 是不可满足的。那么：\n- 如果 $\\phi \\in L$，则 $\\phi$ 可满足且 $|\\phi|$ 是偶数，所以 $g(\\phi)=\\phi$ 是可满足的，因此 $g(\\phi) \\in \\text{SAT}$。\n- 如果 $\\phi \\notin L$，那么要么 $\\phi$ 是不可满足的（此时如果 $|\\phi|$ 是偶数，则 $g(\\phi)=\\phi$；如果 $|\\phi|$ 是奇数，则 $g(\\phi)=(x \\land \\lnot x)$），这会得到一个不可满足的 $g(\\phi)$；要么 $\\phi$ 是可满足的但 $|\\phi|$ 是奇数，此时 $g(\\phi)=(x \\land \\lnot x)$ 是不可满足的。在所有情况下，$\\phi \\notin L$ 都意味着 $g(\\phi) \\notin \\text{SAT}$。\n因此 $\\phi \\in L$ 当且仅当 $g(\\phi) \\in \\text{SAT}$，所以 $L \\le_p \\text{SAT}$。\n\n综合这两个归约，$L$ 是 NP-完全的。因此，（在假设 $P \\neq NP$ 的前提下）$L$ 不适合作为 NP-中间问题例子的最准确和具体的理由是，$L$ 实际上是 NP-完全的。在这些选项中，这对应于选项 B。\n\n选项 A 是错误的，除非 $\\text{SAT} \\in \\text{P}$。选项 C 是错误的，因为我们已经证明了 $L \\in \\text{NP}$。选项 D 是关于拉德纳定理的一般性陈述，并没有具体讨论 $L$。选项 E 是一个不精确的启发式说法，并且正如所证明的，语法的奇偶性限制并没有降低复杂性；相反，通过上述归约，$L$ 仍然是 NP-完全的。", "answer": "$$\\boxed{B}$$", "id": "1429692"}, {"introduction": "拉德纳定理最深刻的洞见之一来自于其构造性证明，该证明使用了一种名为“对角化”的精妙技术来逐步构建一个 NP-中间语言。为了揭开这个抽象过程的神秘面纱，本练习将你置于构造算法的核心。通过在一个具体场景中模拟该算法的初始几个阶段，你将亲手追踪一个 NP-中间语言的“诞生”过程，从而对对角化论证的运作机制获得具体而直观的理解。", "problem": "本题涉及一个 NP 中间语言的构造，这是 Ladner 定理证明中的一个核心主题。假设 $P \\neq NP$。令 SAT 为字母表 $\\Sigma = \\{0, 1\\}$ 上的一个标准 NP 完全语言。我们将构造一个语言 $L_S$，它属于 NP，但既不属于 P，也不是 NP 完全的。\n\n该语言 $L_S$ 定义为：\n$$L_S = \\{x \\in \\Sigma^* \\mid x \\in \\text{SAT} \\land \\chi_S(|x|) = 1\\}$$\n其中 $\\chi_S: \\mathbb{N} \\to \\{0,1\\}$ 是一个特征函数，由下面描述的确定性算法构造。\n\n令 $\\{M_i\\}_{i \\ge 1}$ 为所有确定性多项式时间图灵机的有效枚举，其中机器 $M_i$ 在长度为 $n$ 的输入上的运行时间由多项式 $p_i(n) = n^i + i$ 界定。\n\n$\\chi_S$ 的构造分阶段进行，$k=1, 2, 3, \\dots$。阶段 $k$ 的目标是确保语言 $L_S$ 不被机器 $M_k$ 判定。\n\n**$\\chi_S$ 的构造算法：**\n\n1.  **初始化：** 对于所有 $n \\in \\mathbb{N}$，初始化函数 $\\chi_S(n) = 1$。同时，用 $z_0 = 0$ 初始化一个见证长度序列。\n\n2.  **分阶段对角化：** 对于每个阶段 $k = 1, 2, 3, \\dots$：\n    a. 找到满足条件 $p_k(z_k) < 2^{\\sqrt{z_k}}$ 的最小整数 $z_k \\ge z_{k-1} + 1$。这个 $z_k$ 将作为阶段 $k$ 的“见证长度”。\n    b. 考虑该长度的规范字符串 $w_k = 1^{z_k}$。\n    c. 判断 $w_k \\in \\text{SAT}$ 是否成立。如果 $w_k \\in \\text{SAT}$，则令 $s_k=1$，否则令 $s_k=0$。\n    d. 在输入 $w_k$ 上模拟机器 $M_k$。令其输出为 $b_k = M_k(w_k) \\in \\{0,1\\}$。\n    e. 为确保 $L(M_k) \\neq L_S$，我们希望实现 $M_k(w_k) \\neq (w_k \\in L_S)$。也就是说，$b_k \\neq (s_k \\land \\chi_S(z_k))$。如果对于 $\\chi_S(z_k)$ 的当前值，此不等式已经成立，则无需更改。否则，我们必须修改 $\\chi_S(z_k)$。\n    f. 只有在必要且可能时才会触发修改。具体规则是：如果 $s_k=1$ 且 $b_k=1$，则设置 $\\chi_S(z_k)=0$。在所有其他情况下，保持 $\\chi_S(z_k)$ 的当前值（除非在前一阶段被更改，否则该值为 1，不过 $z_k$ 的选择可以防止这种情况）。\n\n**问题细节：**\n\n针对本题，给定以下信息：\n- 前三个阶段的图灵机为：\n    - 对于所有输入 $w$，$M_1(w) = 1$。\n    - 如果 $|w|$ 为偶数，则 $M_2(w) = 1$，否则为 $0$。\n    - 如果 $|w|$ 是一个完全平方数，则 $M_3(w) = 1$，否则为 $0$。\n- 就本题而言，假设一元字符串 $1^n$ 属于 SAT 当且仅当 $n$ 是一个素数。\n\n你的任务是确定在完成前三个阶段（$k=1, 2, 3$）后函数 $\\chi_S$ 的状态。具体来说，你必须计算以下总和的值：\n$$C = \\sum_{n=1}^{1000} (1 - \\chi_S(n))$$\n这个总和有效地计算了在长度 1000 以内，$\\chi_S(n)$ 被设为 0 的次数。", "solution": "1.  阶段 1 ($k=1$): $p_1(n)=n+1$。找到满足 $n+1  2^{\\sqrt{n}}$ 的最小 $z_1 \\ge 1$。测试得出 $z_1=19$，因为 $19+1=20  2^{\\sqrt{19}} \\approx 20.3$。$w_1=1^{19}$, $s_1=1$ (19 是素数), $b_1=M_1(w_1)=1$。因为 $s_1=1$ 且 $b_1=1$，设置 $\\chi_S(19)=0$。\n\n2.  阶段 2 ($k=2$): $p_2(n)=n^2+2$。找到满足 $n^2+2  2^{\\sqrt{n}}$ 的最小 $z_2 \\ge 20$。估算得出 $z_2=257$，因为 $257^2+2 = 66051  2^{\\sqrt{257}} \\approx 66846$。$w_2=1^{257}$, $s_2=1$ (257 是素数), $b_2=M_2(w_2)=0$ (257 是奇数)。这里 $b_2=0$ 而 $(s_2 \\land \\chi_S(257)) = (1 \\land 1) = 1$，不等式已成立，因此无需变化；$\\chi_S(257)=1$。\n\n3.  阶段 3 ($k=3$): $p_3(n)=n^3+3$。找到满足 $n^3+3  2^{\\sqrt{n}}$ 的最小 $z_3 \\ge 258$。估算得出 $z_3=854$。$w_3=1^{854}$, $s_3=0$ (854 是合数), $b_3=M_3(w_3)=0$ (854 不是平方数)。因为 $s_3=0$，修改规则的条件 ($s_k=1$ 且 $b_k=1$) 不满足，因此无需变化；$\\chi_S(854)=1$。\n\n在阶段 1–3 中，只有 $\\chi_S(19)$ 被设置为 0。\n因此\n$$C=\\sum_{n=1}^{1000}(1-\\chi_S(n)) = (1-\\chi_S(19)) + \\sum_{n=1, n\\neq 19}^{1000}(1-\\chi_S(n)) = (1-0) + 0 = 1.$$", "answer": "$$\\boxed{1}$$", "id": "61614"}, {"introduction": "拉德纳定理的对角化技术不仅能证明 NP-中间问题的存在，其思想还可以被扩展和调整，以揭示 NP 复杂性类中更精细的结构。这个具有挑战性的练习展示了这种方法的强大功能和灵活性。通过追踪一个更为复杂的构造过程，你将探索如何构建一对多项式时间不可比较的 NP-中间语言，即两者之间都不能通过多项式时间归约相互转化，从而加深对计算复杂性谱系丰富性的认识。", "problem": "本问题探讨一种受 Ladner 定理证明启发的构造性方法，用于创建两个多项式不可比较的计算复杂语言。\n\n**背景与定义：**\n- 令 SAT 为布尔可满足性问题，一个著名的 NP-完全（非确定性多项式时间完全）问题。我们视其所有实例为编码后的二进制串。\n- 如果存在一个多项式时间可计算的函数 $f$，使得对于所有字符串 $x$，$x \\in A \\iff f(x) \\in B$ 成立，则稱语言 $A$ 可多项式时间归约到语言 $B$，记为 $A \\le_p B$。\n- 如果语言 $L \\in \\text{NP}$，但 $L$ 不在 P 中且 $L$ 不是 NP-完全的，则称 $L$ 是 NP-中间语言。\n- 如果 $L_A \\le_p L_B$ 和 $L_B \\le_p L_A$ 均不成立，则称语言 $L_A$ 和 $L_B$ 是多项式不可比较的。\n- 令 $\\{T_i\\}_{i \\ge 1}$ 为所有计算多项式时间函数（转换器）的图灵机的一个标准枚举。它们代表了所有潜在的多项式时间归约。\n- 为整数 $n$ 定义函数 $h(n)$ 如下：当 $n \\ge 10$ 时，$h(n) = \\lfloor \\log_{10}(\\log_{10}(n)) \\rfloor$；当 $n  10$ 时，$h(n) = 0$。\n\n**构造过程：**\n我们将定义两个基于字母表 $\\{0,1\\}$ 的语言 $L_A$ 和 $L_B$。任何字符串 $x$ 在这些语言中的隶属关系由一个算法确定，该算法根据 $k = h(|x|)$ 分阶段运行。此构造使用两个布尔标志数组 $G_A[j]$ 和 $G_B[j]$（$j \\ge 1$），它们全部初始化为 `false`。这些标志用于跟踪某个特定的对角化要求是否已满足。\n\n字符串 $x$ 的隶属关系按以下方式确定：\n1.  令 $n = |x|$ 并计算 $k = h(n)$。如果 $k = 0$，则 $x \\notin L_A$ 且 $x \\notin L_B$。\n2.  如果 $k  0$，算法会一次性地定义所有长度为 $n$ 的字符串的隶属关系。令 $z_n = 1^n$ 为该长度的指定“见证”串。\n3.  **情况：对于某个整数 $j \\ge 1$，$k = 2j-1$。**（此阶段针对通过 $T_j$ 的潜在归约 $L_B \\le_p L_A$。）\n    - 如果标志 $G_B[j]$ 为 `true`，则要求已满足。对于所有长度为 $n$ 的字符串 $x'$：\n        - $x' \\in L_A \\iff x' \\in \\text{SAT}$。\n        - $x' \\in L_B \\iff x' \\in \\text{SAT}$。\n    - 如果标志 $G_B[j]$ 为 `false`，则尝试对角化：\n        - 计算 $y = T_j(z_n)$。假设 $T_j$ 的运行时间由一个已知的多项式 $p_j(n)$ 界定。如果 $T_j(z_n)$ 在其时间界限内停机且 $h(|y|)  k$，则对角化 `成功`。否则，为 `失败`。\n        - 如果 `成功`：将 $G_B[j]$ 设为 `true`。通过递归应用此算法来确定 $y$ 在 $L_A$ 中的隶属关系。\n            - 如果 $y \\in L_A$，则对于见证串 $z_n$：$z_n \\notin L_B$。\n            - 如果 $y \\notin L_A$，则对于见证串 $z_n$：$z_n \\in L_B$。\n            对于所有其他长度为 $n$ 的字符串 $x' \\neq z_n$，其隶属关系为 $x' \\in L_B \\iff x' \\in \\text{SAT}$。在这个 `成功` 的子情况中，所有长度为 $n$ 的字符串在 $L_A$ 中的隶属关系由 SAT 决定：$x' \\in L_A \\iff x' \\in \\text{SAT}$。\n        - 如果 `失败`：标志 $G_B[j]$ 保持为 `false`。对于所有长度为 $n$ 的字符串 $x'$：\n            - $x' \\in L_A \\iff x' \\in \\text{SAT}$。\n            - $x' \\in L_B \\iff x' \\in \\text{SAT}$。\n4.  **情况：对于某个整数 $j \\ge 1$，$k = 2j$。**（此阶段针对通过 $T_j$ 的归约 $L_A \\le_p L_B$。）这种情况与奇数情况对称。\n    - 如果 $G_A[j]$ 为 `true`，对于所有长度为 $n$ 的 $x'$：$x' \\in L_A \\iff x' \\in \\text{SAT}$ 且 $x' \\in L_B \\iff x' \\in \\text{SAT}$。\n    - 如果 $G_A[j]$ 为 `false`，通过计算 $y = T_j(z_n)$ 尝试对角化：\n        - 如果 `成功` ($h(|y|)  k$)：将 $G_A[j]$ 设为 `true`。递归地确定 $y \\in L_B$。\n            - 如果 $y \\in L_B$，则 $z_n \\notin L_A$。\n            - 如果 $y \\notin L_B$，则 $z_n \\in L_A$。\n            对于长度为 $n$ 且 $x' \\neq z_n$ 的字符串：$x' \\in L_A \\iff x' \\in \\text{SAT}$。在此子情况中，对于所有长度为 $n$ 的 $x'$：$x' \\in L_B \\iff x' \\in \\text{SAT}$。\n        - 如果 `失败`：对于所有长度为 $n$ 的 $x'$：$x' \\in L_A \\iff x' \\in \\text{SAT}$ 且 $x' \\in L_B \\iff x' \\in \\text{SAT}$。\n\n**问题：**\n假设转换器的枚举如下：\n-   $T_1$ 是恒等转换器：$T_1(z) = z$。\n-   $T_2$ 是一个常量转换器：对于任何输入 $z$，$T_2(z) = 1^{10^{10}}$。\n-   对于所有 $j \\ge 3$，当转换器 $T_j$ 作用于任何长度为 $n$ 的见证串 $z_n$（其中 $h(n) \\ge 2j-1$）时，它产生的输出 $y$ 满足 $h(|y|) \\ge h(n)$。\n\n此外，假设对于任何整数 $m \\ge 10^{10}$，字符串 $1^m$ 都在 SAT 中。\n\n考虑字符串 $x_A = 1^{10^{10}}$ 和 $x_B = 1^{10^{1000}}$。定义一个结果向量 $V = (v_A, v_B)$，其中如果 $x_A \\in L_A$ 则 $v_A=1$，否则 $v_A=0$；类似地，如果 $x_B \\in L_B$ 则 $v_B=1$，否则 $v_B=0$。\n\n确定向量 $V$。你的答案应该是一个 $1 \\times 2$ 的行矩阵。", "solution": "给定当 $n \\ge 10$ 时有 $h(n) = \\lfloor \\log_{10}(\\log_{10}(n)) \\rfloor$，且所有标志 $G_A[j], G_B[j]$ 初始为假。对于任何 $m \\ge 10^{10}$，$1^m \\in \\text{SAT}$。我们必须确定 $x_A = 1^{10^{10}}$ 相对于 $L_A$ 的 $v_A$ 值，以及 $x_B = 1^{10^{1000}}$ 相对于 $L_B$ 的 $v_B$ 值。\n\n首先考虑 $x_A = 1^{10^{10}}$。令 $n_A = |x_A| = 10^{10}$ 且 $k_A = h(n_A)$。计算\n$$\nk_A = h(10^{10}) = \\left\\lfloor \\log_{10}\\big(\\log_{10}(10^{10})\\big) \\right\\rfloor = \\left\\lfloor \\log_{10}(10) \\right\\rfloor = 1.\n$$\n因此 $k_A = 1 = 2 \\cdot 1 - 1$，所以我们处于 $j=1$ 的奇数情况，目标是通过 $T_1$ 实现 $L_B \\le_p L_A$。由于 $G_B[1]$ 初始为假，我们尝试通过计算 $y = T_1(z_{n_A})$ 来进行对角化。这里 $z_{n_A} = 1^{n_A} = 1^{10^{10}}$，并且 $T_1$ 是恒等转换器，所以 $y = z_{n_A}$ 且 $|y| = n_A$。成功的条件要求 $h(|y|)  k_A$。但是\n$$\nh(|y|) = h(n_A) = k_A = 1,\n$$\n所以 $h(|y|)  k_A$ 不成立。因此对角化失败。根据构造规则，对于所有长度为 $n_A$ 的字符串 $x'$，我们设置\n$$\nx' \\in L_A \\iff x' \\in \\text{SAT}, \\quad x' \\in L_B \\iff x' \\in \\text{SAT}.\n$$\n因为 $x_A = 1^{10^{10}}$ 并且对于任何 $m \\ge 10^{10}$ 我们有 $1^m \\in \\text{SAT}$，所以 $x_A \\in L_A$。因此 $v_A = 1$。\n\n接下来考虑 $x_B = 1^{10^{1000}}$。令 $n_B = |x_B| = 10^{1000}$ 且 $k_B = h(n_B)$。计算\n$$\nk_B = h(10^{1000}) = \\left\\lfloor \\log_{10}\\big(\\log_{10}(10^{1000})\\big) \\right\\rfloor = \\left\\lfloor \\log_{10}(1000) \\right\\rfloor = 3.\n$$\n因此 $k_B = 3 = 2 \\cdot 2 - 1$，是 $j=2$ 的奇数情况，目标是通过 $T_2$ 实现 $L_B \\le_p L_A$。初始时 $G_B[2]$ 为假，所以我们尝试对角化：计算 $y = T_2(z_{n_B})$，其中 $z_{n_B} = 1^{n_B} = 1^{10^{1000}}$。根据定义，$T_2$ 输出常量 $1^{10^{10}}$，所以 $y = 1^{10^{10}}$。成功的条件是 $h(|y|)  k_B$。我们有\n$$\nh(|y|) = h(10^{10}) = \\left\\lfloor \\log_{10}\\big(\\log_{10}(10^{10})\\big) \\right\\rfloor = \\left\\lfloor \\log_{10}(10) \\right\\rfloor = 1  3 = k_B,\n$$\n因此对角化成功。将 $G_B[2]$ 设为真。规则接着要求递归地确定 $y \\in L_A$。对于 $y = 1^{10^{10}}$，如上文对 $k=1$ 的情况所示，对角化失败，并且在长度为 $10^{10}$ 时 $L_A$ 与 SAT 一致，所以\n$$\ny \\in L_A \\iff y \\in \\text{SAT}.\n$$\n因为 $1^{10^{10}} \\in \\text{SAT}$，我们有 $y \\in L_A$。在成功的奇数情况子程序中，如果 $y \\in L_A$，则对于见证串 $z_{n_B} = 1^{10^{1000}}$ 我们设置\n$$\nz_{n_B} \\notin L_B.\n$$\n因为 $x_B = z_{n_B}$，所以 $x_B \\notin L_B$，因此 $v_B = 0$。\n\n因此结果向量为行矩阵 $(1,0)$。", "answer": "$$\\boxed{\\begin{pmatrix}1  0\\end{pmatrix}}$$", "id": "1429718"}]}