{"hands_on_practices": [{"introduction": "让我们从一个基本问题开始：如果证明者试图作弊会怎么样？这个练习将通过分析一个单轮协议来检验证明系统的“可靠性”（soundness）。在这个假设场景中，两个图实际上是同构的，但一个不诚实的证明者（Alice）仍试图说服验证者（Bob）它们是非同构的。通过计算作弊证明者的最佳成功概率，你将理解该协议的内在安全基础，以及为什么单轮交互是不够的 [@problem_id:1469892]。", "problem": "在理论计算机科学领域，一个交互式证明系统允许一个计算能力强大的证明者（Prover）让一个计算能力有限的验证者（Verifier）相信某个数学陈述的真实性。考虑以下旨在证明两个图 $G_1$ 和 $G_2$ 非同构的交互式协议。\n\n证明者 Alice 声称，两个特定的图 $G_1$ 和 $G_2$ 对验证者 Bob 来说是非同构的。为了说服 Bob，他们执行以下协议的一轮：\n\n1.  **Bob 的步骤**：Bob 从集合 $\\{1, 2\\}$ 中均匀随机地选择一个索引 $i$。然后，他对他选择的图 $G_i$ 的顶点标签应用一个随机排列，从而创建一个新图 $H$。这意味着 $H$ 与 $G_i$ 同构，但其顶点标签被打乱了。Bob 只将图 $H$ 发送给 Alice。\n\n2.  **Alice 的步骤**：Alice 接收到图 $H$。假设她拥有无限的计算能力。她必须确定原始图 $G_1$ 或 $G_2$ 中的哪一个与 $H$ 同构。她将她的答案，一个索引 $j \\in \\{1, 2\\}$，发回给 Bob。\n\n3.  **Bob 的验证**：Bob 检查 Alice 返回的索引 $j$ 是否与他秘密选择的索引 $i$ 匹配。如果 $j=i$，则该轮成功。如果 $j \\neq i$，则该轮失败，Bob 拒绝 Alice 的声称。\n\n现在，假设 Alice 试图作弊。实际上，两个图 $G_1$ 和 $G_2$ 是同构的，这个事实 Alice 知道但 Bob 不知道。Alice 仍然声称图是不同构的，并参与协议，希望能通过验证步骤。\n\n假设 Alice 采用最佳策略来确定她的回应 $j$，她能成功完成这一轮协议的概率是多少？\n\nA. 0\n\nB. $\\frac{1}{4}$\n\nC. $\\frac{1}{2}$\n\nD. $\\frac{3}{4}$\n\nE. 1", "solution": "设 $G_{1}$ 和 $G_{2}$ 是顶点集大小同为 $n$ 的图，且 $G_{1} \\simeq G_{2}$。设 $I \\in \\{1,2\\}$ 是 Bob 的均匀随机选择，因此 $\\Pr(I=i)=\\frac{1}{2}$。设 $\\Pi$ 是对称群 $S_{n}$ 中的一个均匀随机排列，且独立于 $I$。Bob 构建 $H=\\Pi(G_{I})$ 并将 $H$ 发送给 Alice。\n\n因为 $G_{1} \\simeq G_{2}$，所以存在一个排列 $\\sigma \\in S_{n}$ 使得 $G_{2}=\\sigma(G_{1})$。对于任意一个具有 $n$ 个顶点的有标签图 $h$，\n$$\n\\Pr(H=h \\mid I=2)=\\Pr(\\Pi(G_{2})=h)=\\Pr(\\Pi(\\sigma(G_{1}))=h).\n$$\n定义 $\\Pi'=\\Pi \\circ \\sigma$，我们可知，当 $\\Pi$ 在 $S_{n}$ 上均匀分布时，$\\Pi'$ 也在 $S_{n}$ 上均匀分布，因此\n$$\n\\Pr(H=h \\mid I=2)=\\Pr(\\Pi'(G_{1})=h)=\\Pr(H=h \\mid I=1).\n$$\n因此，在给定 $I=1$ 和 $I=2$ 的条件下，$H$ 的条件分布是相同的。根据贝叶斯法则，对于任何满足 $\\Pr(H=h)>0$ 的 $h$，\n$$\n\\Pr(I=i \\mid H=h)=\\frac{\\Pr(H=h \\mid I=i)\\Pr(I=i)}{\\sum_{k=1}^{2}\\Pr(H=h \\mid I=k)\\Pr(I=k)}=\\frac{a \\cdot \\frac{1}{2}}{a \\cdot \\frac{1}{2}+a \\cdot \\frac{1}{2}}=\\frac{1}{2},\n$$\n其中 $a=\\Pr(H=h \\mid I=1)=\\Pr(H=h \\mid I=2)$。\n\n设 Alice 的策略（可能是随机化的）是根据某个条件分布 $\\Pr(J=j \\mid H=h)$ 输出 $J \\in \\{1,2\\}$。成功概率为\n$$\n\\Pr(J=I)=\\sum_{h}\\Pr(H=h)\\sum_{i=1}^{2}\\Pr(I=i \\mid H=h)\\Pr(J=i \\mid H=h).\n$$\n对于两个 $i$ 值，使用 $\\Pr(I=i \\mid H=h)=\\frac{1}{2}$，\n$$\n\\Pr(J=I)=\\sum_{h}\\Pr(H=h)\\left(\\frac{1}{2}\\sum_{i=1}^{2}\\Pr(J=i \\mid H=h)\\right)=\\sum_{h}\\Pr(H=h)\\left(\\frac{1}{2}\\cdot 1\\right)=\\frac{1}{2}.\n$$\n因此，没有任何策略可以达到的成功概率能超过 $\\frac{1}{2}$，而这个概率可以通过随机猜测达到。因此，当 $G_{1}$ 和 $G_{2}$ 同构时，Alice 的最优成功概率是 $\\frac{1}{2}$，对应于选项 C。", "answer": "$$\\boxed{C}$$", "id": "1469892"}, {"introduction": "我们已经看到，单轮协议提供的安全性有限，因为作弊者仍有 $1/2$ 的成功机会。在实践中，协议会被重复多次以指数级地增强可信度。这个问题要求你运用贝叶斯定理，根据一系列成功的验证来量化并更新验证者的信任度。通过这个练习，你将体会到密码学协议中重复迭代的力量，并掌握一个衡量和增强安全性的具体数学工具 [@problem_id:1469933]。", "problem": "一家名为“GraphGuard”的网络安全公司正在开发一种验证数字身份的新方法。该系统的核心依赖于图同构问题的计算难度。一位工程师 Alice 向她的经理 Bob 展示了两个大型复杂的网络图 $G_1$ 和 $G_2$。Alice 声称这两个图是非同构的，这是她提出的安全协议的一个关键要求。\n\nBob 对此表示怀疑。根据他以往使用类似图生成算法的经验，他认为 Alice 正确（即图是非同构的）的概率为50%，而图实际上是同构的概率也为50%。为了检验 Alice 的说法，他们同意进行以下可重复多次的交互式挑战：\n\n1.  Bob 秘密地并以相等的概率随机选择两个图中的一个，即 $G_1$ 或 $G_2$。\n2.  然后，他通过随机置换所选图的顶点标签来生成一个新图 $H$。这个过程确保了 $H$ 与他选择的图是同构的，但其结构已被打乱。\n3.  Bob 只将图 $H$ 展示给 Alice。\n4.  Alice 必须判断 $H$ 是与 $G_1$ 同构还是与 $G_2$ 同构。\n\n假设如果图 $G_1$ 和 $G_2$ 确实是非同构的，Alice 的先进系统能够以100%的准确率正确识别出 $H$ 的来源。然而，如果这两个图实际上是同构的，即使是她的系统也无法区分它们，她只能靠猜测，这使得她在每次挑战中答对的概率为50%。\n\n他们连续进行了 $k=12$ 轮挑战，Alice 每一次都给出了正确的答案。Bob 对图 $G_1$ 和 $G_2$ 确实是非同构的这一结论的新置信度（以概率表示）是多少？\n\n请将你的答案以四位有效数字的小数形式给出。", "solution": "设假设为：\n- $H_{\\mathrm{NI}}$：$G_{1}$ 和 $G_{2}$ 是非同构的。\n- $H_{\\mathrm{I}}$：$G_{1}$ 和 $G_{2}$ 是同构的。\n\nBob 的先验信念为 $P(H_{\\mathrm{NI}})=\\frac{1}{2}$ 和 $P(H_{\\mathrm{I}})=\\frac{1}{2}$。\n\n在每一轮中，如果 $H_{\\mathrm{NI}}$ 为真，Alice 答对的概率为 $1$。如果 $H_{\\mathrm{I}}$ 为真，Alice 答对的概率为 $\\frac{1}{2}$。在 $k=12$ 轮独立的、且所有答案都正确的挑战中，似然函数为\n$$\nP(\\text{all 12 correct}\\mid H_{\\mathrm{NI}})=1^{12}=1,\n$$\n$$\nP(\\text{all 12 correct}\\mid H_{\\mathrm{I}})=\\left(\\frac{1}{2}\\right)^{12}=2^{-12}.\n$$\n\n根据贝叶斯定理，图是非同构的后验概率为\n$$\nP(H_{\\mathrm{NI}}\\mid \\text{all 12 correct})=\\frac{P(\\text{all 12 correct}\\mid H_{\\mathrm{NI}})P(H_{\\mathrm{NI}})}{P(\\text{all 12 correct}\\mid H_{\\mathrm{NI}})P(H_{\\mathrm{NI}})+P(\\text{all 12 correct}\\mid H_{\\mathrm{I}})P(H_{\\mathrm{I}})}.\n$$\n代入数值，\n$$\nP(H_{\\mathrm{NI}}\\mid \\text{all 12 correct})=\\frac{1\\cdot \\frac{1}{2}}{1\\cdot \\frac{1}{2}+2^{-12}\\cdot \\frac{1}{2}}=\\frac{1}{1+2^{-12}}=\\frac{4096}{4097}.\n$$\n\n化为小数并保留四位有效数字，\n$$\n\\frac{4096}{4097}\\approx 0.9998.\n$$", "answer": "$$\\boxed{0.9998}$$", "id": "1469933"}, {"introduction": "零知识证明的安全性依赖于几个关键假设，其中随机性至关重要。这个思想实验将挑战协议的一个核心要素：验证者挑战的随机性。通过分析当验证者的挑战变得可预测（例如，遵循一个固定的模式）时会发生什么，你将能够准确指出证明系统的哪个核心属性会因此失效。这个练习将深化你对随机性重要性的理解——它不仅仅是一个技术细节，而是整个密码学安全体系的基石 [@problem_id:1469924]。", "problem": "在理论计算机科学领域，零知识证明 (ZKP) 是一种方法，通过这种方法，一方（证明者）可以向另一方（验证者）证明某个陈述为真，而除了该陈述确实为真这一事实之外，不泄露任何额外信息。\n\n考虑一个经典的零知识证明，用于证明两个图 $G_1$ 和 $G_2$ 是**同构的**。该协议涉及一个证明者 Alice（她知道这两个图是同构的）和一个验证者 Bob。该协议按以下轮次进行：\n1.  Alice 随机选择两个图中的一个 $G_i$，其中 $i \\in \\{1, 2\\}$。\n2.  然后，她对所选图 $G_i$ 的顶点应用一个随机置换 $\\pi$，从而创建一个新图 $H$。这使得 $H$ 与 $G_i$ 同构。\n3.  Alice 将图 $H$ 发送给 Bob。\n4.  拥有 $G_1$ 和 $G_2$ 的 Bob 接收到 $H$，并随机选择一个挑战 $j \\in \\{1, 2\\}$。他要求 Alice 提供一个 $H$ 与 $G_j$ 之间的同构。\n5.  Alice 遵从请求。如果她的初始选择 $i$ 与 Bob 的挑战 $j$ 匹配，她就能提供该同构。如果 $i \\neq j$，那么只有当 $G_1$ 和 $G_2$ 事实上是同构的情况下，她才能提供该同构。\n6.  Bob 验证该同构。如果有效，则该轮成功。此过程会重复多次，以降低作弊的证明者成功的概率。\n\n现在，假设验证者 Bob 决定修改协议。他不在每一轮（步骤4）中随机选择他的挑战 $j$，而是使用一个公开已知的、确定性的序列。例如，对于轮次序列 $k = 1, 2, 3, 4, \\dots$，他将挑战分别设置为 $j=1, j=2, j=1, j=2, \\dots$。\n\n假设一个恶意证明者 Eve 试图让 Bob 相信两个图 $G_1$ 和 $G_2$ 是**同构的**，而实际上它们**是非同构的**。Bob 使用确定性挑战序列的做法严重破坏了零知识证明的哪一个基本性质，从而使得 Eve 能够成功作弊？\n\nA. 完备性 (Completeness)：如果陈述为真，诚实的证明者总能说服诚实的验证者。\n\nB. 可靠性 (Soundness)：如果陈述为假，作弊的证明者只有可忽略的概率能说服验证者。\n\nC. 零知识性 (Zero-Knowledge)：验证者除了知道该陈述为真之外，学不到任何其他东西。\n\nD. 同构不变性 (Isomorphism Invariance)：证明结果与图的特定顶点标记无关。", "solution": "我们首先回顾零知识证明对于一个语言的三个核心性质：完备性（如果陈述为真，诚实的证明者能以高概率说服诚实的验证者），可靠性（如果陈述为假，任何作弊的证明者都无法说服验证者，除非以可忽略的概率），以及零知识性（验证者除了陈述的真实性之外学不到任何东西）。\n\n在所讨论的标准交互式协议结构中，防止作弊证明者的关键保护措施是，在证明者提交用以固定其后续可揭示内容的消息（在此即图 $H$）时，验证者的挑战对其是不可预测的。形式上来说，如果图实际上是同构的（即“非同构”这一陈述为假），并且一个恶意证明者不知道 $G_{1}$ 和 $G_{2}$ 之间的同构，那么在发送 $H$（构造为两个图之一的随机置换）之后，证明者只有在挑战 $j$ 与其用来构造 $H$ 的索引 $i$ 一致时，才能正确回答挑战。对于一个均匀随机的挑战，这得出\n$$\n\\Pr[\\text{在一轮中接受}] = \\frac{1}{2},\n$$\n在 $t$ 个独立轮次中，\n$$\n\\Pr[\\text{在 } t \\text{ 轮中接受}] = \\left(\\frac{1}{2}\\right)^{t} = 2^{-t},\n$$\n这个概率对于 $t$ 来说是可忽略的。这正是可靠性的保证：当陈述为假时，任何作弊证明者的成功概率都是可忽略的。\n\n现在假设验证者用一个公开已知的确定性序列（例如，按轮次为 $j=1,2,1,2,\\dots$）替换了随机挑战。那么证明者在每轮发送 $H$ 之前，就提前知道了将被问到的 $j$。一个恶意证明者可以在每一轮都设置 $i=j$，将 $H$ 构造为 $G_{j}$ 的一个随机置换，因此总能在被挑战时生成 $H$ 和 $G_{j}$ 之间的同构。这使得\n$$\n\\Pr[\\text{在一轮中接受}] = 1 \\quad \\text{并且} \\quad \\Pr[\\text{在 } t \\text{ 轮中接受}] = 1,\n$$\n尽管陈述是假的。因此，通过使挑战具有确定性和可预测性而受到严重破坏的性质是可靠性：当陈述为假时，作弊证明者说服验证者的概率不再是可忽略的；在这种攻击下，它变成了 $1$。\n\n完备性在这里不是问题（当陈述为真时，诚实的证明者仍然能够说服验证者），并且在这种情况下，零知识性不受验证者挑战的确定性的直接影响。“同构不变性”不是零知识证明的三个基本性质之一，也不是此处的关键保证。因此，被破坏的性质是可靠性。", "answer": "$$\\boxed{B}$$", "id": "1469924"}]}