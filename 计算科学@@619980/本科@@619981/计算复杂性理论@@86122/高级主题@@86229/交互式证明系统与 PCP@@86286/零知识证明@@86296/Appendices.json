{"hands_on_practices": [{"introduction": "零知识证明的“可靠性”（Soundness）属性不仅仅是一个理论概念，它通常可以通过概率来精确量化。这个练习提供了一个简单直观的认证模型，让你计算一个没有秘密信息的欺骗性证明者成功欺骗验证者的确切概率。通过这个实践，你将具体地理解密码学协议中“可靠性”的含义以及如何通过增加挑战的复杂度（例如，增加 $k$ 的值）来指数级地降低欺骗成功的可能性 [@problem_id:1470204]。", "problem": "一个认证系统正在基于一个简单的挑战-响应协议进行设计。在该系统中，每个用户都有一个长度为 $n$ 的密码字符串。密码中的所有字符都取自一个包含 $s$ 个不同符号的字母表 $\\Sigma$。\n\n该认证协议按如下方式单轮进行：\n1. 服务器（验证者）从集合 $\\{1, 2, \\dots, n\\}$ 中随机且均匀地选择一个包含 $k$ 个不同索引的集合，其中 $1 \\le k \\le n$。\n2. 服务器将这组包含 $k$ 个索引的集合发送给用户的客户端（证明者）。\n3. 客户端必须使用与从服务器收到的 $k$ 个索引相对应的密码字符进行响应。\n4. 当且仅当客户端的响应与存储的密码中的所有 $k$ 个字符完全匹配时，服务器才授予访问权限。\n\n考虑一个不知道用户密码的恶意行为者。该行为者设法截获了服务器的挑战（即包含 $k$ 个索引的集合），并试图通过向服务器发送响应来冒充用户。该行为者知道系统的参数，即密码长度 $n$、字母表大小 $s$ 和被挑战的索引数量 $k$。然而，该行为者对于正确密码的任何单个字符都没有任何信息。\n\n假设该行为者采用最优策略来猜测所需的字符，那么该行为者在单次尝试中成功欺骗服务器的最大概率是多少？请用包含 $n$、$s$ 和 $k$ 的符号表达式来表示你的答案。", "solution": "服务器选择一个索引集合 $C \\subset \\{1,\\dots,n\\}$，其中 $|C|=k$，并将 $C$ 发送给证明者。对于这个固定的挑战 $C$，正确的响应是这些索引位置上密码符号组成的有序 $k$ 元组。由于密码字符取自大小为 $s$ 的字母表 $\\Sigma$，因此在被挑战的位置上，总共有 $s^{k}$ 种可能的 $k$ 元组。\n\n一个对密码没有任何信息的恶意行为者必须提交某个 $k$ 元组作为响应。对于任意固定的 $C$，在 $s^{k}$ 种可能的 $k$ 元组中，最多只有一个会与正确的匹配。因此，对于任何确定性的猜测，成功的事件就是真实的 $k$ 元组与猜测的 $k$ 元组相等。在自然的对称性假设下（或者等价地，将未知密码建模为在 $\\Sigma^{n}$ 上均匀随机分布），被挑战位置上的 $k$ 元组在 $\\Sigma^{k}$ 上均匀分布，因此一个固定的猜测与之匹配的概率是\n$$\n\\frac{1}{s^{k}}.\n$$\n随机化猜测并不能提高这个概率：任何随机化策略都是确定性猜测上的一个分布，根据期望的线性性质，成功概率仍然是 $\\frac{1}{s^{k}}$ 的凸组合，因此最多为 $\\frac{1}{s^{k}}$，而这个概率已经可以通过任何固定的猜测达到。选择 $C$ 的随机性不会改变这个结论，因为攻击者在猜测之前会观察到 $C$，并且对于每一个实现的 $C$，成功概率都是 $\\frac{1}{s^{k}}$。\n\n因此，在单次尝试中成功欺骗服务器的最大概率是\n$$\n\\frac{1}{s^{k}}.\n$$\n这个表达式不依赖于 $n$，因为只有被挑战的 $k$ 个位置会影响单轮的成功。", "answer": "$$\\boxed{\\frac{1}{s^{k}}}$$", "id": "1470204"}, {"introduction": "一个零知识证明协议的安全性依赖于对所有规则的严格遵守，即使是看似微小的失误也可能导致灾难性的后果。这个练习模拟了一个常见但致命的实现错误：在协议中重用了一个本应是随机一次性的数值。你将扮演攻击者的角色，利用这个漏洞，通过简单的代数运算从公开的交互信息中恢复出本应保密的密钥 $s$，从而亲身体验到密码学协议实现的严谨性是多么重要 [@problem_id:1470174]。", "problem": "在一个使用零知识证明（ZKP）协议的系统中，证明者 Alice 想要向验证者 Bob 证明她拥有一个秘密整数密钥 $s$。这个秘密是她的公钥 $v$ 对一个合数 $n$ 取模的平方根，满足 $s^2 \\equiv v \\pmod{n}$。$n$ 和 $v$ 的值是公开的，但 $n$ 的素因子是保密的。\n\n一轮证明的协议按以下步骤进行：\n1.  **承诺**：Alice 选择一个秘密随机整数 $r$（其中 $\\gcd(r,n)=1$），计算承诺值 $x \\equiv r^2 \\pmod{n}$，并将 $x$ 发送给 Bob。\n2.  **挑战**：Bob 发回一个随机挑战比特 $c \\in \\{0, 1\\}$。\n3.  **响应**：Alice 计算一个响应 $y$。如果 $c=0$，她发送 $y=r$。如果 $c=1$，她发送 $y=rs \\pmod{n}$。\n4.  **验证**：如果 $c=0$，Bob 验证 $y^2 \\equiv x \\pmod{n}$。如果 $c=1$，Bob 验证 $y^2 \\equiv xv \\pmod{n}$。\n\n假设公开值为 $n=3127$ 和 $v=619$。由于一个软件错误，Alice 的认证客户端在与 Bob 的连续两次认证会话中使用了*相同*的承诺值 $x$（因此也使用了相同的随机数 $r$）。\n\n在第一次会话中，Bob 用 $c_1=0$ 进行挑战，Alice 响应了 $y_1=500$。\n在第二次会话中，Bob 注意到重复的承诺，巧妙地用 $c_2=1$ 进行了挑战。Alice 有问题的客户端响应了 $y_2=3095$。\n\n通过利用这个漏洞，Bob 可以推断出 Alice 的秘密密钥 $s$。这个秘密密钥 $s$ 的值是多少？答案必须是一个介于 $0$ 和 $n-1$ 之间（含两端）的整数。", "solution": "Alice 在两次会话中重复使用了相同的承诺 $x \\equiv r^{2} \\pmod{n}$，所以两次响应都对应于相同的 $r$。根据协议：\n- 当 $c_{1}=0$ 时，Alice 发送了 $y_{1}=r=500$。\n- 当 $c_{2}=1$ 时，Alice 发送了 $y_{2} \\equiv rs \\pmod{3127}$，其中 $y_{2}=3095$。\n\n根据协议设计，由于 $\\gcd(r,n)=1$，因此 $r$ 存在模 $n$ 的乘法逆元。因此，\n$$\ns \\equiv y_{2}\\,r^{-1} \\equiv y_{2}\\,y_{1}^{-1} \\pmod{3127}.\n$$\n\n我们首先通过扩展欧几里得算法计算 $y_{1}^{-1} \\bmod 3127$。计算 gcd 链：\n$$\n3127=6\\cdot 500+127,\\quad 500=3\\cdot 127+119,\\quad 127=1\\cdot 119+8,\n$$\n$$\n119=14\\cdot 8+7,\\quad 8=1\\cdot 7+1,\\quad 7=7\\cdot 1+0,\n$$\n所以 $\\gcd(500,3127)=1$。回代得到\n$$\n1=8-1\\cdot 7=15\\cdot 8-1\\cdot 119=15\\cdot 127-16\\cdot 119\n$$\n$$\n=15\\cdot 127-16\\cdot(500-3\\cdot 127)=63\\cdot 127-16\\cdot 500\n$$\n$$\n=63\\cdot(3127-6\\cdot 500)-16\\cdot 500=63\\cdot 3127-394\\cdot 500.\n$$\n因此\n$$\n-394\\cdot 500 \\equiv 1 \\pmod{3127}\\quad\\Rightarrow\\quad 500^{-1} \\equiv 2733 \\pmod{3127}。\n$$\n\n所以，\n$$\ns \\equiv 3095\\cdot 2733 \\pmod{3127}。\n$$\n为简化计算，先对因子进行模约简：$3095 \\equiv -32 \\pmod{3127}$ 且 $2733 \\equiv -394 \\pmod{3127}$，所以\n$$\ns \\equiv (-32)\\cdot(-394)=12608 \\pmod{3127}。\n$$\n现在将 $12608$ 对 $3127$ 取模：\n$$\n12608-4\\cdot 3127=12608-12508=100,\n$$\n所以 $s \\equiv 100 \\pmod{3127}$。\n\n与公钥 $v$ 进行验证：\n$$\ns^{2}=100^{2}=10000 \\equiv 10000-3\\cdot 3127=10000-9381=619 \\equiv v \\pmod{3127}。\n$$\n因此推断出的秘密密钥是 $s=100$。", "answer": "$$\\boxed{100}$$", "id": "1470174"}, {"introduction": "一个协议在孤立执行时可能是安全的，但在一个可以同时进行多个会话的网络环境中，它可能变得脆弱。这个练习将引导你思考一种经典的“中间人攻击”（Man-in-the-Middle Attack），也被称为“中继攻击”（Relay Attack）。通过巧妙地在诚实的证明者和验证者之间传递信息，一个完全不知道秘密的恶意方可以成功地“证明”她拥有该秘密，这揭示了并发环境下协议安全性的一个关键挑战 [@problem_id:1470165]。", "problem": "在计算复杂性理论中，零知识证明 (ZKP) 允许证明者 (prover) 向验证者 (verifier) 证明一个命题为真，而无需揭示任何超出该命题本身有效性的信息。\n\n考虑图三着色问题。如果可以为 $V$ 中的每个顶点赋予三种颜色（例如，红、绿、蓝）之一，使得没有两个相邻的顶点（由 $E$ 中的一条边连接）共享相同的颜色，则图 $G=(V, E)$ 是可三着色的。证明一个大型复杂图是可三着色的在计算上是困难的，但验证一个给定的着色方案是容易的。\n\n一个标准的交互式 ZKP 协议，用于证明者 Peggy 向验证者 Victor 证明她知道一个公开图 $G$ 的有效三着色方案 $c: V \\to \\{\\text{red, green, blue}\\}$，该协议按轮次进行如下：\n\n1.  **承诺 (Commitment):** Peggy 首先选择三种颜色的一个随机置换 $\\pi$。她将此置换应用于她的整个着色方案，得到一个新的、被打乱的着色方案 $c' = \\pi \\circ c$。对于每个顶点 $v \\in V$，她使用密码学安全的承诺方案对其新颜色 $c'(v)$ 进行承诺，该方案可被视为一个函数 `Commit(message, salt)`。她将所有承诺的集合 $\\{C_v\\}_{v \\in V}$ 发送给 Victor，其中 $C_v = \\text{Commit}(c'(v), \\text{salt}_v)$。`salt` 是每个承诺唯一的大的随机数。\n\n2.  **挑战 (Challenge):** Victor 随机选择一条边 $(u, w) \\in E$，并要求 Peggy 揭示该边两个顶点的颜色。\n\n3.  **回应 (Response):** Peggy 揭示置换后的颜色 $c'(u)$、$c'(w)$ 以及对应的 `salt`，$\\text{salt}_u$ 和 $\\text{salt}_w$。\n\n4.  **验证 (Verification):** Victor 检查两个条件：\n    a) 揭示的信息是真实的：$\\text{Commit}(c'(u), \\text{salt}_u) = C_u$ 且 $\\text{Commit}(c'(w), \\text{salt}_w) = C_w$。\n    b) 着色属性在该边上成立：$c'(u) \\neq c'(w)$。\n\n如果两个检查都通过，则该轮成功。该协议会重复足够多的轮次，以使作弊的证明者成功的概率变得无穷小。\n\n现在，考虑一个有三方的场景：\n-   **Peggy:** 一个诚实的证明者，她拥有一个大型公开图 $G$ 的有效三着色方案。\n-   **Charlie:** 一个诚实的验证者。\n-   **Mallory:** 一个恶意的参与方，她 **不** 知道 $G$ 的三着色方案，但希望让 Charlie 相信她知道。\n\nMallory 能够同时参与两个协议会话：一个作为“证明者”与 Charlie 进行，另一个作为“验证者”与 Peggy 进行。\n\n以下哪种策略能让 Mallory 成功通过与 Charlie 的每一轮验证，从而欺骗性地证明她知道该着色方案，而始终不被发现？\n\n**A:** 在与 Peggy 的会话中，Mallory 请求 Peggy 揭示她完整的秘密三着色方案 $c$。然后，Mallory 使用这个被揭示的着色方案在另一个会话中诚实地向 Charlie 证明她的知识。\n\n**B:** Mallory 通过向 Charlie 发送对每个顶点的随机生成数据的承诺来启动她的会话。当 Charlie 对一条边 $(u,w)$ 发出挑战时，Mallory 无法为她最初的承诺提供有效的回应。于是，她随机选择两个不同的颜色，比如‘red’和‘green’，并声称它们对应于顶点 $u$ 和 $w$，希望这个猜测能通过验证。\n\n**C:** Mallory 通过向 Charlie 发送她自己的一组承诺 $\\{C'_v\\}_{v \\in V}$ 来启动她的会话。同时，她与 Peggy 启动一个会话。当 Charlie 用一条边 $(u,w)$ 挑战她时，Mallory 将相同的挑战传递给 Peggy。在收到 Peggy 的回应（颜色和`salt`）后，Mallory 在她自己对 Charlie 的回应中使用这些颜色。\n\n**D:** Mallory 与 Peggy 启动一个会话。当 Peggy 发送她的一组承诺 $\\{C_v\\}_{v \\in V}$ 时，Mallory 将这组完全相同的承诺转发给 Charlie，作为她自己的承诺。当 Charlie 用一条边 $(u,w)$ 挑战她时，Mallory 将这个完全相同的挑战转发给 Peggy。当 Peggy 发送她的回应时，Mallory 将那个完全相同的回应转发给 Charlie。\n\n**E:** Mallory 被动地窃听 Peggy 与其他验证者之间的许多独立证明会话。她记录了所有的边挑战和相应的被揭示的颜色对。在收集到足够的数据后，她试图重构完整的着色方案 $c$，并在她与 Charlie 的会话中使用它。", "solution": "我们使用协议和承诺方案的属性来分析每种提出的策略。所使用的关键密码学属性是：\n- 隐藏性 (Hiding)：对于每个 $v \\in V$，在没有打开值 (opening) 的情况下，承诺 $C_v=\\text{Commit}(c'(v),\\text{salt}_v)$ 不会泄露任何关于 $c'(v)$ 的信息。\n- 绑定性 (Binding)：在 $C_v$ 被固定后，Peggy（或任何声称 $C_v$ 属于自己的人）不能在之后将 $C_v$ 打开为一个不同的颜色-`salt`对。\n- 零知识性 (Zero-knowledge)：协议的交互记录不泄露任何关于原始着色方案 $c$ 的知识，因为颜色在每一轮都通过 $c'=\\pi \\circ c$ 被随机置换，并且只揭示单个被挑战的边的颜色。\n- 抗随机猜测的可靠性 (Soundness)：如果没有与先前承诺相匹配的有效打开值，证明者无法持续通过验证。\n\n选项 A：Mallory 请求 Peggy 揭示完整的着色方案 $c$。Peggy 是一个诚实的证明者，并遵守协议，而该协议从不要求完全揭示 $c$。根据零知识性，Peggy 不会泄露 $c$。因此，Mallory 无法通过这种方式获得 $c$。此策略失败。\n\n选项 B：Mallory 对随机数据进行承诺，在收到挑战 $(u,w)$ 后，她试图用随机颜色来回答。根据绑定性，Mallory 的原始承诺固定了打开值。由于她的随机回复几乎肯定不会与她的原始承诺相匹配，Victor 的检查 $\\text{Commit}(c'(u),\\text{salt}_u)=C_u$ 和 $\\text{Commit}(c'(w),\\text{salt}_w)=C_w$ 将会失败。即使她试图猜测颜色和 `salt`，如果不与先前的承诺匹配，这也是不可行的。这无法通过每一轮验证。此策略失败。\n\n选项 C：Mallory 将她自己的承诺 $\\{C'_v\\}$ 发送给 Charlie，但在收到挑战 $(u,w)$ 后，她将该挑战转发给 Peggy，以获取对 Peggy 承诺 $\\{C_v\\}$ 的真实打开值。然而，Mallory 的承诺 $C'_v$ 与 Peggy 的 $C_v$ 是独立的，因为它们在看到 Peggy 的打开值之前就已固定，并且使用了不同的 `salt` 和可能不同的置换。根据绑定性，Mallory 无法打开 $C'_u, C'_w$ 来匹配 Peggy 的颜色和 `salt`，除非是巧合，而这在计算上是不可行的。因此 Victor 对 $C'_u, C'_w$ 的身份验证检查会失败。此策略失败。\n\n选项 D：Mallory 将 Peggy 的承诺 $\\{C_v\\}$ 作为她自己的承诺转发给 Charlie。当 Charlie 挑战 $(u,w)$ 时，Mallory 将挑战转发给 Peggy，然后将 Peggy 的确切回应 $(c'(u),\\text{salt}_u)$ 和 $(c'(w),\\text{salt}_w)$ 转发给 Charlie。Victor 的验证检查：\n1) 真实性：$\\text{Commit}(c'(u),\\text{salt}_u)=C_u$ 和 $\\text{Commit}(c'(w),\\text{salt}_w)=C_w$ 会通过，因为这些是 Peggy 对其承诺的真实打开值，而由于转发，Charlie 相信这些是 Mallory 的。\n2) 正确着色：$c'(u)\\neq c'(w)$ 成立，因为 Peggy 的着色方案在置换下是有效的。\n因为 Mallory 精确地中继了来自 Peggy 的有效承诺和打开值，所以与 Charlie 的每一轮验证都会通过。并发性确保 Mallory 可以在看到 Charlie 的挑战后获得 Peggy 的打开值。这是针对此普通交互式协议的典型中间人中继攻击，利用了其缺乏非延展性 (non-malleability) 的弱点。此策略成功。\n\n选项 E：Mallory 窃听许多会话。由于零知识性和每轮的随机置换 $\\pi$，在边上揭示的颜色是相对于新的置换而言的，不会累积成关于 $c$ 的知识。承诺的隐藏性阻止了学习未打开的颜色。从这些交互记录中重构 $c$ 在计算上是不可行的，因此 Mallory 之后无法向 Charlie 证明她拥有知识。此策略失败。\n\n因此，只有选项 D 能让 Mallory 通过原封不动地中继 Peggy 的承诺和回应，从而成功通过与 Charlie 的每一轮验证而不被发现。", "answer": "$$\\boxed{D}$$", "id": "1470165"}]}