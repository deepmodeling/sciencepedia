{"hands_on_practices": [{"introduction": "在深入探讨 PCP 定理对 $NP$ 类的强大描述之前，让我们从一个基础练习开始。这个练习通过将 PCP 表示法应用于我们熟悉的 $P$ 类——即多项式时间内可解问题的集合——来巩固基础。通过确定 $P$ 类的 PCP 验证器参数，你将建立一个基准，从而更清晰地理解随机性和查询复杂度的作用。[@problem_id:1461213]", "problem": "在计算复杂性理论中，如果存在一个多项式时间的随机算法（称为验证者），该算法与大小为 $n = |x|$ 的输入 $x$ 的一个证明字符串 $\\pi$ 进行交互，那么语言 $L$ 就被认为属于 PCP($r(n), q(n)$) 类。验证者必须遵守以下约束和属性：\n- 最多使用 $r(n)$ 个随机比特。\n- 最多从证明字符串 $\\pi$ 中查询 $q(n)$ 个比特。\n- **完备性：**如果 $x \\in L$，存在一个证明 $\\pi$，使得验证者以概率 1 接受。\n- **可靠性：**如果 $x \\notin L$，对于任意证明字符串 $\\pi'$，验证者以至多 1/2 的概率接受。\n\n另外，复杂性类 P 被定义为所有可由一个确定性算法在多项式时间内判定的语言的集合。\n\n你的任务是使用这种概率可验证明 (PCP) 的形式化方法来精确地刻画 P 类。确定最小的非负整数常量 $c_r$ 和 $c_q$，使得常数函数 $r(n) = c_r$ 和 $q(n) = c_q$ 满足等式 P = PCP($r(n), q(n)$)。提供常量 $c_r$ 和 $c_q$ 的值。", "solution": "我们断言 $P=\\mathrm{PCP}(0,0)$，并且这些常量是满足该要求的最小非负整数。\n\n首先，证明 $P \\subseteq \\mathrm{PCP}(0,0)$。设 $L \\in P$。那么存在一个判别 $L$ 的确定性多项式时间算法 $A$。定义一个验证者 $V$，它在输入 $x$ 上，使用 $r(n)=0$ 个随机比特并对证明进行 $q(n)=0$ 次查询（也即，它完全忽略证明），然后简单地运行 $A(x)$ 并输出其判定结果。完备性：如果 $x \\in L$，存在一个证明 $\\pi$（实际上是任意 $\\pi$），使得 $V$ 以概率 $1$ 接受，因为 $V$ 是确定性的且等同于 $A$。可靠性：如果 $x \\notin L$，对于任意证明 $\\pi'$，$V$ 以概率 $0 \\le \\frac{1}{2}$ 接受，同样是因为 $V$ 是确定性的且等同于 $A$。因此 $L \\in \\mathrm{PCP}(0,0)$，这证明了 $P \\subseteq \\mathrm{PCP}(0,0)$。\n\n其次，证明 $\\mathrm{PCP}(0,0) \\subseteq P$。假设 $L \\in \\mathrm{PCP}(0,0)$。那么存在一个多项式时间验证者 $V$，它使用 $0$ 个随机比特并对证明进行 $0$ 次查询。因此，$V$ 是一个确定性多项式时间算法，其输出仅依赖于 $x$。对于任意固定的 $\\pi_{0}$，定义 $A(x)$ 为 $V(x,\\pi_{0})$；因为 $V$ 从不读取证明，所以这是良定义的并且可以在多项式时间内计算。根据完备性，如果 $x \\in L$，存在一个 $\\pi$ 使得 $V$ 接受，这意味着 $A(x)=1$。根据可靠性，如果 $x \\notin L$，那么对于任意 $\\pi'$，接受概率至多为 $\\frac{1}{2}$；由于 $V$ 是确定性的，这个概率要么是 $0$ 要么是 $1$，因此它必须是 $0$，所以 $A(x)=0$。因此，$A$ 在多项式时间内判别 $L$，并且 $L \\in P$。因此 $\\mathrm{PCP}(0,0) \\subseteq P$。\n\n结合两个包含关系可得 $P=\\mathrm{PCP}(0,0)$。由于要求 $c_{r}$ 和 $c_{q}$ 是非负整数，实现此等式的最小常量是 $c_{r}=0$ 和 $c_{q}=0$。", "answer": "$$\\boxed{\\begin{pmatrix}0  0\\end{pmatrix}}$$", "id": "1461213"}, {"introduction": "PCP 验证器的一个关键特性是其“可靠性”（soundness）——保证它能以高概率拒绝错误的证明。本练习探讨了我们如何将这种置信度从一个常数概率放大到任何期望的确定性水平。理解这种错误抑制（error reduction）的过程，对于领会为何概率算法和证明系统能成为可靠的工具至关重要。[@problem_id:1461240]", "problem": "在理论计算机科学领域，一个概率可验证明 (Probabilistically Checkable Proof, PCP) 系统允许一个随机验证者仅通过查询证明中的少量比特来检验一个数学证明。考虑一个为特定判定问题设计的PCP验证者。该验证者具有以下性质：\n\n1.  **完备性：** 对于任何真实的陈述，存在一个有效的证明，使得验证者总是接受。\n2.  **可靠性：** 对于任何虚假的陈述，无论提供的所谓证明如何，验证者错误接受的概率至多为 $s$，其中 $s$ 是一个满足 $0  s  1$ 的常数。\n\n为了提高置信度并减少出错的概率，验证者会在同一个（假定的虚假）陈述及其所谓的证明上独立运行多次。每次运行都使用一组新的、独立的随机比特。当且仅当验证者的*每一次运行*都接受时，整个协议才宣告该证明“被接受”。\n\n您的任务是确定所需的最小独立试验次数，记为 $k$，以保证错误地接受一个假陈述的总概率至多为 $\\epsilon$，其中 $\\epsilon$ 是一个满足 $0  \\epsilon  s$ 的期望误差容限。\n\n请找到最小整数值 $k$ 关于 $s$ 和 $\\epsilon$ 的一个闭式表达式。", "solution": "令 $P(\\text{accept})$ 为单次运行的验证者错误接受一个虚假陈述的证明的概率。根据问题对可靠性的定义，我们有 $P(\\text{accept}) \\le s$。为了找到所需的最小试验次数，我们必须考虑最坏情况，即单次错误接受的概率恰好为 $s$。因此，我们取 $P(\\text{accept}) = s$。\n\n该协议涉及独立运行验证者 $k$ 次。当且仅当所有 $k$ 次试验都得出接受的结果时，整个协议才会接受一个虚假陈述。令 $A_i$ 为第 $i$ 次试验错误接受的事件。整体错误接受的事件 $A_{\\text{overall}}$ 是这些单个事件的交集：\n$$A_{\\text{overall}} = A_1 \\cap A_2 \\cap \\dots \\cap A_k$$\n\n由于每次试验都是独立的，这些事件交集的概率是它们各自概率的乘积：\n$$P(A_{\\text{overall}}) = P(A_1) \\times P(A_2) \\times \\dots \\times P(A_k)$$\n在我们的最坏情况分析中，对于所有的 $i=1, \\dots, k$ 都有 $P(A_i) = s$。因此，整体错误接受的概率是：\n$$P(A_{\\text{overall}}) = s \\times s \\times \\dots \\times s \\quad (k \\text{ 次}) = s^k$$\n\n问题要求这个总体的错误概率至多为 $\\epsilon$。这给了我们如下不等式：\n$$s^k \\le \\epsilon$$\n\n为了解出 $k$，我们可以对不等式两边取自然对数。由于 $s$ 和 $\\epsilon$ 都是正数，所以对数是良定义的。\n$$\\ln(s^k) \\le \\ln(\\epsilon)$$\n使用对数的幂法则 $\\ln(a^b) = b \\ln(a)$，我们得到：\n$$k \\ln(s) \\le \\ln(\\epsilon)$$\n\n现在，我们需要分离出 $k$。我们已知 $0  s  1$，这意味着 $\\ln(s)$ 是一个负数。当不等式两边同除以一个负数时，我们必须反转不等号的方向。\n$$k \\ge \\frac{\\ln(\\epsilon)}{\\ln(s)}$$\n这个不等式给出了 $k$ 的一个下界。由于试验次数 $k$ 必须是一个整数，我们需要找到满足此条件的最小整数。大于或等于一个给定实数的最小整数由向上取整函数（ceiling function）$\\lceil \\cdot \\rceil$ 给出。\n\n因此，所需的最小整数试验次数为：\n$$k = \\left\\lceil \\frac{\\ln(\\epsilon)}{\\ln(s)} \\right\\rceil$$\n这个表达式也可以使用对数的换底公式 $\\log_b(a) = \\frac{\\ln(a)}{\\ln(b)}$ 写成 $k = \\lceil \\log_s(\\epsilon) \\rceil$。", "answer": "$$\\boxed{\\left\\lceil \\frac{\\ln(\\epsilon)}{\\ln(s)} \\right\\rceil}$$", "id": "1461240"}, {"introduction": "完整的 PCP 定理，即 $NP = \\text{PCP}[O(\\log n), O(1)]$，同时涉及对数随机性和常数次查询。这个思想实验将挑战你思考一个假设的、简化版定理的推论，其中验证器完全不使用随机性。通过分析这种情况，你将更深刻地体会到为什么随机性是赋予 PCP 定理其惊人力量的关键要素。[@problem_id:1461194]", "problem": "在计算复杂性理论中，**P** 类包含所有可以由确定性图灵机在多项式时间内解决的判定问题。**NP** 类包含所有对于一个“是”实例，其证明可以由确定性图灵机在多项式时间内验证的判定问题。\n\n**PCP 定理**使用概率可检验证明（Probabilistically Checkable Proofs, PCP）为 NP 提供了一个等价的刻画。如果存在一个概率多项式时间验证者 $V$，对于任何长度为 $n$ 的输入串 $x$，当其被赋予对证明串 $\\pi$ 的访问权限时，具有以下性质，那么语言 $L$ 就属于 $\\text{PCP}[r(n), q(n)]$ 类：\n1.  验证者 $V$ 至多使用 $O(r(n))$ 个随机比特。\n2.  验证者 $V$ 至多从证明 $\\pi$ 中读取 $O(q(n))$ 个比特。\n3.  **完备性**：如果 $x \\in L$，则存在一个证明 $\\pi$，使得 $V$ 以概率 1 接受。\n4.  **可靠性**：如果 $x \\notin L$，则对于任何证明 $\\pi$，$V$ 的接受概率至多为 $1/2$。\n\n现在，考虑一个假设情景，其中复杂性理论的一项重大突破确立了以下等式：\n$$ \\text{NP} = \\text{PCP}[0, O(1)] $$\n这意味着对于 NP 中的任何语言，都存在一个使用零个随机比特（$r(n)=0$）并且只从证明中查询常数数量比特（$q(n)=O(1)$）的验证者。\n\n这个假设性结果对复杂度类 P 和 NP 之间的关系最直接且最重要的推论是什么？\n\nA. P = NP\n\nB. P $\\neq$ NP\n\nC. 该结果与 P = NP 或 P $\\neq$ NP 均相符，并未解决该问题。\n\nD. NP = co-NP，但 P 与 NP 的问题仍未解决。\n\nE. 这样的结果在逻辑上是不可能的，与 NP 的定义相矛盾。", "solution": "我们已知假设性陈述 $\\text{NP}=\\text{PCP}[0,O(1)]$。根据 $\\text{PCP}[r(n),q(n)]$ 的定义，对于此类中的一个语言 $L$，存在一个概率多项式时间验证者 $V$，它至多使用 $O(r(n))$ 个随机比特，并从一个证明串 $\\pi$ 中读取至多 $O(q(n))$ 个比特，其完备性为 $1$，可靠性至多为 $\\frac{1}{2}$。\n\n第1步（从零随机性到确定性）。由于 $r(n)=0$，验证者 $V$ 不使用任何随机比特，因此在输入 $x$ 和对 $\\pi$ 的谕示访问下是确定性的。所以，对于任何固定的 $(x,\\pi)$，（基于内部随机性的）接受概率要么是 $0$，要么是 $1$。可靠性条件指出，如果 $x\\notin L$，那么对所有 $\\pi$，$V$ 的接受概率至多为 $\\frac{1}{2}$，这因此意味着如果 $x\\notin L$，那么对所有 $\\pi$，$V$ 都会确定性地拒绝（接受概率为 $0$）。完备性条件意味着如果 $x\\in L$，则存在某个 $\\pi$ 使得 $V$ 确定性地接受（接受概率为 $1$）。\n\n第2步（常数查询界限）。由于 $q(n)=O(1)$，存在一个常数 $K$（与 $n$ 无关），使得在任何长度为 $n$ 的输入 $x$ 上，$V$ 对 $\\pi$ 进行的查询次数至多为 $K$ 次。这些查询位置可以根据 $x$ 和之前查询的答案自适应地选择，但查询的总比特数永远不会超过 $K$。\n\n第3步（归约到有限多个确定性检查）。对于固定的 $x$，确定性验证者 $V$ 的决策仅基于：\n- 输入 $x$，以及\n- 它对其（自适应选择的）查询所收到的至多 $K$ 个答案的序列。\n\n因此，对于每个 $x$，存在一组最多 $2^{K}$ 个可能的答案记录 $a\\in\\{0,1\\}^{t}$（其中 $t\\leq K$），这些记录可能在某个自适应查询路径上被观察到。我们可以通过对较短的记录进行填充来等价地考虑所有 $a\\in\\{0,1\\}^{K}$。我们定义一个确定性多项式时间模拟 $D(x,a)$，给定 $x$ 和一个候选答案向量 $a\\in\\{0,1\\}^{K}$，它通过以下方式模拟 $V$ 在 $x$ 上的计算：\n- 根据 $x$ 和目前已提供的答案，计算 $V$ 将会查询的下一个位置。\n- 将 $a$ 中的下一个比特作为答案提供。\n- 在至多 $K$ 次查询后停止，并输出 $V$ 的最终决策。\n\n由于 $V$ 在多项式时间内运行，并且执行至多 $K$ 步谕示交互（其中 $K$ 是常数），所以这个模拟过程在 $|x|$ 的多项式时间内运行。\n\n第4步（多项式时间内的判定过程）。考虑非确定性条件：\n- 如果 $x\\in L$，完备性保证了存在某个证明 $\\pi$ 使得 $V$ 接受；等价地，存在某个与 $\\pi$ 一致的记录 $a\\in\\{0,1\\}^{K}$ 使得 $D(x,a)$ 接受。因此，存在 $a$ 使得 $D(x,a)$ 接受。\n- 如果 $x\\notin L$，可靠性和确定性意味着对于每一个 $\\pi$（因此对于每一个可能的记录 $a$），$V$ 都会拒绝；因此对于所有的 $a\\in\\{0,1\\}^{K}$，$D(x,a)$ 都会拒绝。\n\n因此，$L$ 的成员资格等价于谓词 $\\exists a\\in\\{0,1\\}^{K}: D(x,a)=\\text{accept}$ 的真值。由于 $K$ 是一个常数，我们可以通过确定性地枚举所有 $2^{K}$ 种 $a$ 的赋值，并对每个赋值计算 $D(x,a)$ 来判定此问题。总运行时间至多为 $2^{K}\\cdot \\text{poly}(|x|)$，因为 $2^{K}$ 是一个常数因子，所以这是 $\\text{poly}(|x|)$。\n\n因此，$\\text{PCP}[0,O(1)]$ 中的每个语言都在 $\\text{P}$ 中。根据假设 $\\text{NP}=\\text{PCP}[0,O(1)]$，我们得到 $\\text{NP}\\subseteq \\text{P}$。由于 $\\text{P}\\subseteq \\text{NP}$ 是平凡成立的，因此可以得出 $\\text{P}=\\text{NP}$。\n\n因此，假设等式 $\\text{NP}=\\text{PCP}[0,O(1)]$ 最直接且最重要的推论是 $\\text{P}=\\text{NP}$。", "answer": "$$\\boxed{A}$$", "id": "1461194"}]}