{"hands_on_practices": [{"introduction": "为了真正理解概率可检验证明 (Probabilistically Checkable Proof, PCP) 的强大之处，我们首先需要将其与我们已经熟悉的概念联系起来。这个练习通过将经典的 NP 验证过程重新构建为 PCP 系统的特例，为此奠定了基础。通过分析一个“朴素”的、确定性地读取整个证书的验证者，你将能够明确 PCP 框架的基线参数，并为后续理解 PCP 定理带来的巨大效率提升做好准备。[@problem_id:1420240]", "problem": "在计算复杂性理论中，NP类（代表非确定性多项式时间）包含了所有“是”实例存在一个可在多项式时间内验证的证书的判定问题。形式上，一个语言 $L$ 属于 NP，如果存在一个多项式时间的确定性图灵机 $V$（称为验证机）和一个多项式 $p$，使得对于任意长度为 $n$ 的输入 $x$：\n- 如果 $x \\in L$，则存在一个长度 $|c| \\le p(n)$ 的证书字符串 $c$，使得 $V(x, c)$ 接受。\n- 如果 $x \\notin L$，则对于所有长度 $|c| \\le p(n)$ 的证书 $c$，$V(x, c)$ 拒绝。\n\n另外，定义了 $\\text{PCP}(r(n), q(n))$ 类，代表概率可检验证明（Probabilistically Checkable Proofs）。一个语言 $L$ 属于 $\\text{PCP}(r(n), q(n))$，如果存在一个概率多项式时间验证机 $V$，它能对一个证明字符串 $\\pi$ 进行预言机访问。对于一个长度为 $n$ 的输入 $x$，验证机 $V$ 最多使用 $O(r(n))$ 个随机比特，并对证明 $\\pi$ 进行最多 $O(q(n))$ 次非自适应查询。条件如下：\n- 完备性：如果 $x \\in L$，则存在一个证明 $\\pi$，使得 $V^{\\pi}(x)$ 以概率 1 接受。\n- 可靠性：如果 $x \\notin L$，则对于所有证明 $\\pi'$，$V^{\\pi'}(x)$ 以至多 1/2 的概率接受。\n\n现在，考虑一个语言 $L \\in \\text{NP}$。我们可以使用PCP框架来为标准的NP验证过程建模。我们将 NP 证书 $c$ 视为 PCP 证明 $\\pi$。假设我们构造一个特殊的、“朴素”的 PCP 验证机，对于给定的输入 $x$，它只是简单地模拟原始的 NP 验证机。这个朴素的验证机确定性地读取*整个*证明 $\\pi$（长度至多为 $p(n)$），然后完全按照 NP 验证机 $V$ 的方式决定接受或拒绝。\n\n下列哪个选项正确地描述了这个特定的朴素验证机的随机性与查询复杂度 $(r(n), q(n))$？\n\nA. $r(n) = 0, q(n) = p(n)$\n\nB. $r(n) = O(\\log n), q(n) = O(1)$\n\nC. $r(n) = p(n), q(n) = 0$\n\nD. $r(n) = 0, q(n) = O(\\log n)$\n\nE. $r(n) = O(\\log p(n)), q(n) = O(1)$", "solution": "根据 NP 的定义，存在一个确定性多项式时间验证机 $V$ 和一个多项式 $p$，使得对于任意长度为 $n$ 的输入 $x$，一个长度为 $|c| \\le p(n)$ 的证书 $c$ 能使 $V(x,c)$ 接受，当且仅当 $x \\in L$。为了在 PCP 框架中对此建模，我们将证明预言机 $\\pi$ 就看作是证书 $c$。\n\n考虑所描述的朴素 PCP 验证机：对于输入 $x$，它确定性地读取整个证明 $\\pi$ 并模拟 $V(x,\\pi)$。由于该验证机是确定性的，不使用任何随机比特，因此使用的随机比特数为\n$$\nr(n) = 0.\n$$\n在 PCP 模型中，一次查询是访问证明预言机 $\\pi$ 的一个索引。读取长度至多为 $p(n)$ 的整个证明需要查询 $\\pi$ 的每一个位置，因此非自适应查询的数量满足\n$$\nq(n) = p(n).\n$$\n该验证机具有完备性概率 $1$（如果 $x \\in L$，存在 $\\pi$ 使其接受）和可靠性概率 $0$（如果 $x \\notin L$，它对所有 $\\pi$ 都拒绝），这符合 PCP 定义中可靠性要求至多为 $\\frac{1}{2}$ 的规定。\n\n因此，随机性与查询复杂度的正确选择是数对 $(r(n), q(n)) = (0, p(n))$，这对应于选项 A。", "answer": "$$\\boxed{A}$$", "id": "1420240"}, {"introduction": "掌握了 NP 验证的 PCP 视角后，我们现在来直面计算复杂性理论中最令人惊奇的成果之一：PCP 定理。这个练习直接挑战你运用 PCP 定理的核心内容，即 $\\text{NP} = \\text{PCP}(O(\\log n), O(1))$。通过分析一个只使用对数级随机性和常数级查询的验证者，你将巩固对该定理的理解，并体会到仅检查证明的极小部分就能验证复杂计算的深刻含义。[@problem_id:1420205]", "problem": "在计算复杂性理论的研究中，一个用于语言 $L$ 的概率可验证明 (PCP) 系统提供了一种方法，用于验证一个给定的字符串 $x$ 属于 $L$ 的证明。在这种系统中，验证者是一个概率算法，它可以访问输入串 $x$ 和一个独立的证明串 $\\pi$。验证者的复杂度由其随机性复杂度 $r(n)$ 和查询复杂度 $q(n)$ 来衡量，其中 $n$ 是输入 $x$ 的大小。函数 $r(n)$ 表示验证者使用的随机位数，而 $q(n)$ 表示它从证明串 $\\pi$ 中读取的位数。所有具有这些参数的 PCP 系统的语言所构成的类被记为 $\\text{PCP}(r(n), q(n))$。\n\n考虑一类为某类问题设计的特定类型的 PCP 验证者。对于任何大小为 $n$ 的给定输入，该验证者按以下方式操作：\n1.  它使用恰好 $\\log_2 n$ 个随机位。这些随机位用于从证明串中 $n$ 个可能的起始位置集合里唯一且均匀地选择一个索引。\n2.  在选择一个起始位置后，验证者从证明串中读取一个长度为 $c$ 的比特序列，其中 $c$ 是一个不依赖于 $n$ 的固定正整数常量。\n3.  然后，验证者仅根据其读取的 $c$ 个比特来做出接受或拒绝的决定。\n\n根据著名的 PCP 定理（该定理将此类证明系统与标准复杂度类联系起来），所有可以由具有上述行为的验证者判定的语言所构成的类等价于以下著名复杂度类中的一个。它是哪一个？\n\nA. P (多项式时间)\n\nB. NP (非确定性多项式时间)\n\nC. PSPACE (多项式空间)\n\nD. L (对数空间)\n\nE. EXP (指数时间)", "solution": "我们已知一个验证者，在长度为 $n$ 的输入上，它使用恰好 $r(n)=\\log_{2} n$ 个随机位来从证明串的 $n$ 个起始位置中均匀地选择一个，然后读取恰好 $q(n)=c$ 个证明位（其中 $c$ 是一个不依赖于 $n$ 的固定正常数），并仅根据这 $c$ 个位来决定接受或拒绝。根据定义，可由这类验证者判定的语言集合是 $\\text{PCP}(\\log_{2} n, c)$。\n\n根据 PCP 定理，存在绝对常数 $c_{0},d_{0}>0$，使得\n$$\n\\text{NP}=\\text{PCP}(d_{0}\\log_{2} n, c_{0}).\n$$\n特别地，$\\text{NP}\\subseteq \\text{PCP}(O(\\log n),O(1))$，反之，$\\text{PCP}(O(\\log n),O(1))\\subseteq \\text{NP}$。我们现在将给定的验证者与这些参数对齐，并论证双向包含关系，以得出其与 $\\text{NP}$ 相等的结论。\n\n首先，观察到验证者可以使用的可能随机串的数量是\n$$\nR(n)=2^{r(n)}=2^{\\log_{2} n}=n.\n$$\n因此，恰好有 $n$ 种随机选择。根据 $\\text{PCP}(r,q)$ 的定义，验证者是多项式时间的，并且它对每个随机选择只查询 $q(n)=c$ 个位。\n\n包含关系 $\\text{PCP}(\\log_{2} n,c)\\subseteq \\text{NP}$ 的证明：设 $L\\in \\text{PCP}(\\log_{2} n,c)$，其完备性为 $a$，可靠性为 $b$，其中 $a,b\\in[0,1]$ 是固定常数，且对于某个固定 $\\delta>0$ 有 $a-b\\geq \\delta$。对于长度为 $n$ 的输入 $x$，考虑一个非确定性算法，它猜测一个证明 $\\pi$，该证明包含所有可能被读取的证明位置。因为验证者从 $n$ 个起始位置中选择一个，并从每个位置读取 $c$ 个位，所以在所有随机串上查询的位置总集合的大小最多为 $n\\cdot c$，因此与验证相关的 $\\pi$ 的部分长度为 $O(n)$，并且可以在多项式时间内被猜测出来。然后，该算法在所有 $R(n)=n$ 个随机串上确定性地模拟验证者，并计算接受结果的数量。当且仅当至少有 $a\\cdot R(n)$ 次模拟接受时，该算法才接受。每次模拟使用的时间是 $n$ 的多项式时间，并且有 $n$ 次模拟，所以总的确定性验证时间是 $n$ 的多项式时间。因此，$L$ 的成员资格可以由一个 $\\text{NP}$ 机判定，从而确立了 $\\text{PCP}(\\log_{2} n,c)\\subseteq \\text{NP}$。\n\n包含关系 $\\text{NP}\\subseteq \\text{PCP}(\\log_{2} n,c')$（对于某个常数 $c'$）正是 PCP 定理的内容：$\\text{NP}$ 中的每个语言都有一个多项式时间的概率验证者，它使用 $O(\\log n)$ 个随机位和 $O(1)$ 次查询。调整常数因子和对数的底只会使 $d_{0}$ 和 $c_{0}$ 产生常数倍的变化，因此所给定的使用恰好 $\\log_{2} n$ 个随机位和常数次查询的形式是被覆盖的。\n\n结合两个方向，由所描述的验证者可判定的语言类恰好是 $\\text{NP}$。在所提供的选项中，这对应于 B。", "answer": "$$\\boxed{B}$$", "id": "1420205"}, {"introduction": "一个强大的理论定义通常具有“鲁棒性”(robustness)，即其核心结论不依赖于某些脆弱的、特定的参数选择。这个练习将引导你探究 PCP 定义的鲁棒性，特别是其完备性 ($completeness$) 和可靠性 ($soundness$) 概率。你将发现，只要完备性和可靠性之间存在一个常数“间隙”，该 PCP 类的计算能力就保持不变，这揭示了在复杂性理论中至关重要的“放大”(amplification) 技术。[@problem_id:1420219]", "problem": "概率可检验证明 (Probabilistically Checkable Proof, PCP) 系统允许一个随机验证者通过仅检查一个数学证明的少量比特来对其进行验证。对于一个语言 $L$，验证者 $V$ 是一个概率多项式时间算法，对于一个长度为 $n$ 的输入 $x$，它被赋予对一个证明字符串 $\\pi$ 的预言机访问权限。该验证者最多使用 $r(n)$ 个随机比特，并最多查询证明的 $q(n)$ 个比特。证明 $\\pi$ 的长度被假定为 $n$ 的多项式级别。\n\n标准复杂性类 $\\text{PCP}(r(n), q(n))$，形式上记为 $\\text{PCP}_{1, 1/2}(r(n), q(n))$，是所有拥有具备以下性质的 PCP 系统的语言 $L$ 的集合：\n- **完备性**：如果 $x \\in L$，则存在一个证明 $\\pi$，使得验证者 $V$ 以概率 1 接受。\n- **可靠性**：如果 $x \\notin L$，对于任意证明 $\\pi'$，验证者 $V$ 以最多 $1/2$ 的概率接受。\n\n著名的 PCP 定理建立了 NP 和 PCP 之间的一个深刻联系，该定理指出 $\\text{NP} = \\text{PCP}(O(\\log n), O(1))$。\n\n现在，让我们考虑一个 PCP 类的修改后定义，我们将其称为 $\\text{PCP}'(r(n), q(n))$。这个类，更形式化地记为 $\\text{PCP}_{2/3, 1/3}(r(n), q(n))$，是为拥有具备以下不同概率阈值的 PCP 系统的语言定义的：\n- **修改后的完备性**：如果 $x \\in L$，则存在一个证明 $\\pi$，使得 $V$ 以至少 $2/3$ 的概率接受。\n- **修改后的可靠性**：如果 $x \\notin L$，对于任意证明 $\\pi'$，$V$ 以最多 $1/3$ 的概率接受。\n\n你的任务是在与 PCP 定理相同的资源约束下，分析这个修改后的 PCP 系统的计算能力。具体来说，请确定与 $\\text{PCP}'(O(\\log n), O(1))$ 相等的复杂性类。你的答案应该是一个主要的、著名的复杂性类的通用名称。", "solution": "令 $r(n)$ 和 $q(n)$ 分别表示随机性界限和查询界限。\n\n第一个包含关系：$\\text{NP} \\subseteq \\text{PCP}'(O(\\log n), O(1))$。\n根据 PCP 定理，对于每个 $L \\in \\text{NP}$，存在一个参数为 $r(n) = O(\\log n)$ 和 $q(n) = O(1)$ 的验证者 $V$，使得\n- 完备性：如果 $x \\in L$，则 $\\exists \\pi$ 使得 $\\Pr_{R}[V^{\\pi}(x; R)=1]=1$，\n- 可靠性：如果 $x \\notin L$，则 $\\forall \\pi'$，$\\Pr_{R}[V^{\\pi'}(x; R)=1] \\le \\frac{1}{2}$。\n定义 $V'$，它使用独立的随机字符串 $R_{1}, R_{2}$ 运行两个独立的 $V$ 实例，并且当且仅当两个实例都接受时才接受。那么\n- 如果 $x \\in L$ 且 $\\pi$ 是一个见证证明，则接受概率为\n$$\n\\Pr[V'^{\\pi}(x; R_{1},R_{2})=1] \\;=\\; \\Pr[V^{\\pi}(x; R_{1})=1] \\cdot \\Pr[V^{\\pi}(x; R_{2})=1] \\;=\\; 1 \\cdot 1 \\;=\\; 1 \\;\\ge\\; \\frac{2}{3},\n$$\n- 如果 $x \\notin L$，对每个 $\\pi'$，\n$$\n\\Pr[V'^{\\pi'}(x; R_{1},R_{2})=1] \\;\\le\\; \\left(\\frac{1}{2}\\right)^{2} \\;=\\; \\frac{1}{4} \\;\\le\\; \\frac{1}{3}.\n$$\n资源界限满足 $r'(n)=2r(n)=O(\\log n)$ 和 $q'(n)=2q(n)=O(1)$。因此 $L \\in \\text{PCP}'(O(\\log n), O(1))$，所以 $\\text{NP} \\subseteq \\text{PCP}'(O(\\log n), O(1))$。\n\n第二个包含关系：$\\text{PCP}'(O(\\log n), O(1)) \\subseteq \\text{NP}$。\n令 $L \\in \\text{PCP}'(O(\\log n), O(1))$，其验证者 $V$ 最多使用 $r(n) \\le c_{r} \\log n$ 个随机比特和最多 $q(n) \\le c_{q}$ 次查询，并且证明长度对于 $n=|x|$ 是多项式级别的。对于任意固定的 $x$ 和证明 $\\pi$，令\n$$\nT \\;=\\; 2^{r(n)} \\;\\le\\; 2^{c_{r} \\log n} \\;=\\; n^{c_{r}},\n$$\n并定义\n$$\nA(x,\\pi) \\;=\\; \\left| \\{ R \\in \\{0,1\\}^{r(n)} : V^{\\pi}(x; R)=1 \\} \\right|.\n$$\n那么接受概率恰好是 $A(x,\\pi)/T$。一个非确定性多项式时间机器可以猜测 $\\pi$，并通过枚举所有 $T$ 个随机字符串并模拟 $V$ 来计算 $A(x,\\pi)$，这需要的时间为 $T \\cdot \\text{poly}(n) = n^{O(1)}$。它当且仅当\n$$\n\\frac{A(x,\\pi)}{T} \\;\\ge\\; \\frac{2}{3} \\quad\\Longleftrightarrow\\quad 3A(x,\\pi) \\;\\ge\\; 2T.\n$$\n时接受。\n如果 $x \\in L$，则存在一个 $\\pi$ 使得接受概率至少为 $\\frac{2}{3}$，所以该机器接受。如果 $x \\notin L$，那么对于每个 $\\pi'$，接受概率最多为 $\\frac{1}{3}$，因此 $3A(x,\\pi') \\le T < 2T$，该机器拒绝。因此 $L \\in \\text{NP}$。\n\n结合这两个包含关系可得\n$$\n\\text{PCP}'(O(\\log n), O(1)) \\;=\\; \\text{NP}.\n$$", "answer": "$$\\boxed{\\text{NP}}$$", "id": "1420219"}]}