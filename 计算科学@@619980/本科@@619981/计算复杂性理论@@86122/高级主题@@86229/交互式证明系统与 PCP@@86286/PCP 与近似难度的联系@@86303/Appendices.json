{"hands_on_practices": [{"introduction": "本节的第一个练习将带你探索将 PCP 验证者转化为约束满足问题 (CSP) 的基本步骤。理解这一转化过程是掌握如何用证明验证来为优化问题建模的关键。通过根据验证者的参数计算其所能生成的最大约束数量，你将深入理解验证者的随机性与查询结构是如何直接决定最终优化问题实例的规模的。[@problem_id:1418606]", "problem": "为分析概率性可验证证明（PCP）验证器所生成的约束系统的结构，我们构建了一个理论模型。该验证器专为处理输入大小为 $n$ 的判定问题而设计。其操作定义如下：\n\n1.  验证器使用一个总长度为 $r(n)$ 的随机串 $R$。该随机串是两个独立部分 $R_1$ 和 $R_2$ 的串联，其长度分别为 $r_1(n)$ 和 $r_2(n)$，因此有 $r(n) = r_1(n) + r_2(n)$。\n2.  第一部分 $R_1$ 用于确定性地从给定的证明串 $\\pi$ 中选择一组 $q(n)$ 个不同的位置进行查询。我们将由 $R_1$ 生成的查询位置集合记为 $Q(R_1)$。\n3.  第二部分 $R_2$ 用于确定性地选择一个接受谓词，记为 $V_{R_2}$。接受谓词是一个布尔函数，它以 $q(n)$ 个比特为输入，并返回一个比特来表示接受（1）或拒绝（0）。\n4.  对于一个给定的完整随机串 $R = R_1R_2$，验证器接受证明 $\\pi$ 当且仅当谓词 $V_{R_2}$ 对从证明中位于 $Q(R_1)$ 位置读取的特定比特求值为 1。\n\n在证明近似困难性的标准方法中，这个 PCP 系统被转换成一个约束满足问题（CSP）的实例。对于验证器可能从其随机串中产生的每一对唯一的 $(Q, V)$（由一个查询位置集合 $Q$ 和一个接受谓词 $V$ 组成），都会生成一个不同的约束。\n\n假设从随机串到结果的映射是最大多样化的（即，只要可能，不同的随机串就会产生不同的结果），那么为最终的 CSP 实例所能生成的最大可能约束数是多少？请用 $r_1(n)$、$r_2(n)$ 和 $q(n)$ 将你的答案表示为一个单一的封闭形式解析表达式。为简化最终表达式，可将这些函数写为 $r_1$、$r_2$ 和 $q$。", "solution": "$R_{1}$ 有 $2^{r_{1}}$ 种可能的串，$R_{2}$ 有 $2^{r_{2}}$ 种可能的串。在最大多样性假设下，映射 $R_{1} \\mapsto Q(R_{1})$ 在所有 $2^{r_{1}}$ 种可能性上都可以是单射的，从而最多产生 $2^{r_{1}}$ 个不同的查询集。对于接受谓词，作用于 $q$ 比特上的不同布尔谓词的总数是 $2^{2^{q}}$，因此映射 $R_{2} \\mapsto V_{R_{2}}$ 最多可以产生 $\\min\\!\\left(2^{r_{2}},\\,2^{2^{q}}\\right)$ 个不同的谓词。\n\n因为 $R_{1}$ 和 $R_{2}$ 是相互独立并串联形成 $R = R_{1}R_{2}$，所以每一对结果都会组合起来，因此不同的验证器结果集合是不同的 $Q$ 集合和不同的 $V$ 集合的笛卡尔积。因此，不同对偶 $(Q,V)$ 的最大数量——也就是生成的约束的最大数量——是\n$$\n2^{r_{1}} \\cdot \\min\\!\\left(2^{r_{2}},\\,2^{2^{q}}\\right).\n$$\n这个数量总是最多为 $2^{r_{1}+r_{2}}$，即随机串的总数，这符合要求。", "answer": "$$\\boxed{2^{r_{1}}\\min\\!\\left(2^{r_{2}},\\,2^{2^{q}}\\right)}$$", "id": "1418606"}, {"introduction": "这个练习在将 PCP 简化为 CSP 的概念基础上，展示了 PCP 定理在实践中的全部威力。你将从一个由 PCP 生成的问题出发，一路追踪其如何归约到一个经典的优化问题——集合覆盖问题，并计算由此产生的不可近似间隙。这个动手计算的过程将使“可满足性间隙”这一抽象概念变得具体，它精确地揭示了为何为集合覆盖问题寻找近似解是计算困难的。[@problem_id:1418609]", "problem": "概率可验证明（PCP）定理为证明许多优化问题的近似困难性提供了一个强大的工具。这是通过构建从NP完全问题（如3-SAT）到优化问题实例的归约来实现的，在优化问题的实例中，YES实例（可满足的3-SAT公式）和NO实例（不可满足的3-SAT公式）的目标函数值之间存在一个可计算的“间隙”。\n\n考虑一个特定的基于PCP的归约，它将一个3-SAT公式转换为一种特殊类型的约束满足问题（CSP）。这个CSP，我们称之为 $\\psi$，具有以下由PCP定理保证的性质：\n1.  CSP $\\psi$ 定义在一个包含 $N$ 个变量的集合 $\\{x_1, \\dots, x_N\\}$ 和一个包含 $M$ 个约束的集合 $\\{C_1, \\dots, C_M\\}$ 上。\n2.  该归约保证了一个“满足度间隙”：\n    -   如果原始的3-SAT公式是可满足的（YES情况），那么存在一个对 $N$ 个变量的赋值，可以满足 $\\psi$ 的所有 $M$ 个约束。\n    -   如果原始的3-SAT公式是不可满足的（NO情况），那么对 $N$ 个变量的任何赋值都不能满足超过 $M$ 个约束中的一小部分 $s$，其中 $s1$。\n3.  此外，得到的CSP是正则的，意味着每个变量 $x_i$ 恰好出现在 $D$ 个约束中。\n\n现在，考虑一个从这个CSP $\\psi$ 到集合覆盖问题实例的标准归约。集合覆盖实例 $(\\mathcal{U}, \\mathcal{S})$ 的构建如下：\n-   要覆盖的全集 $\\mathcal{U}$ 是 $\\psi$ 的所有 $M$ 个约束的集合。\n-   可用的子集集合 $\\mathcal{S}$ 由每个变量 $x_i$ 和每个可能的二进制值 $v \\in \\{0, 1\\}$ 对应的一个集合 $S_{i,v}$ 组成。集合 $S_{i,v}$ 被定义为当变量 $x_i$ 被赋值为 $v$ 时所有被满足的约束的集合。\n\n给定一个通过此过程生成的CSP实例 $\\psi$，其参数如下：$N=2000$ 个变量， $M=25000$ 个约束，满足度间隙参数 $s=0.6$，以及正则性参数 $D=25$。\n\n你的任务是分析此实例的最优集合覆盖的大小。\n1.  在YES情况下（即CSP完全可满足时），最小集合覆盖的大小是多少？记为 $k_{YES}$。\n2.  接下来，考虑NO情况。任何对应于一个有效赋值（即每个变量一个集合）的 $N$ 个集合的集合，最多能覆盖 $sM$ 个约束。为了覆盖剩余的约束，必须添加额外的集合。假设在最乐观的情况下，每个额外的集合都覆盖了最大可能数量的*新的、之前未被覆盖的*约束，那么覆盖所有 $M$ 个约束所需的*额外*集合的最小数量是多少？\n3.  根据你在前面部分的答案，在NO情况下最小集合覆盖的大小是多少？记为 $k_{NO}$。\n4.  最后，计算该归约为集合覆盖问题建立的近似困难度间隙 $\\gamma = \\frac{k_{NO}}{k_{YES}}$。\n\n提供近似困难度间隙 $\\gamma$ 的单一数值。将你的最终答案四舍五入到四位有效数字。", "solution": "我们给定一个CSP实例，它有 $N$ 个变量，$M$ 个约束，正则性为 $D$，以及一个满足度间隙 $s1$。集合覆盖实例使用由所有 $M$ 个约束组成的全集 $\\mathcal{U}$ 和集合族 $\\{S_{i,v}\\}$，其中 $S_{i,v}$ 包含当 $x_{i}=v$ 时所有被满足的约束。正则性意味着每个变量恰好出现在 $D$ 个约束中，因此对于任何 $i$ 和 $v$，$S_{i,v}$ 的大小最多为 $D$。\n\n1) YES情况。如果CSP是可满足的，那么存在一个赋值 $a:[N]\\to\\{0,1\\}$ 满足所有 $M$ 个约束。选择 $N$ 个集合 $\\{S_{i,a(i)}: i\\in[N]\\}$ 会覆盖所有约束，因此有 $k_{YES} \\leq N$。根据此归约的标准分析，我们取 $k_{YES}=N$。当 $N=2000$ 时，得到 $k_{YES}=2000$。\n\n2) NO情况的额外集合。任何对应于单个赋值的 $N$ 个集合的集合最多能覆盖 $sM$ 个约束。因此，在这 $N$ 个集合之后，未被覆盖的约束数量是\n$$\nM - sM = (1-s)M.\n$$\n在最乐观的情况下，每个额外的集合都覆盖了最大可能数量的新的、之前未被覆盖的约束，根据正则性，这个数量最多为 $D$。因此，所需的最小额外集合数量是\n$$\n\\left\\lceil \\frac{(1-s)M}{D} \\right\\rceil.\n$$\n代入 $s=0.6$，$M=25000$ 和 $D=25$，\n$$\n(1-s)M = 0.4 \\times 25000 = 10000,\\quad \\frac{10000}{25}=400,\n$$\n所以最小额外集合数量是 $400$。\n\n3) NO情况的覆盖大小。因此，在NO情况下最小集合覆盖的大小是\n$$\nk_{NO} = N + \\left\\lceil \\frac{(1-s)M}{D} \\right\\rceil = 2000 + 400 = 2400.\n$$\n\n4) 近似困难度间隙。间隙为\n$$\n\\gamma = \\frac{k_{NO}}{k_{YES}} = \\frac{2400}{2000} = 1.2.\n$$\n四舍五入到四位有效数字，结果是 $1.200$。", "answer": "$$\\boxed{1.200}$$", "id": "1418609"}, {"introduction": "最后的这项练习通过一个思想实验，鼓励你思考 PCP 定理的深层理论意义。通过假设一个特定问题存在一个高效的近似算法（即多项式时间近似方案，PTAS），你将推导出任何可用于证明其硬度的 PCP 系统所必须具备的属性。这项实践阐明了强大的 PCP 的存在性与 NP 难问题的高效近似算法的不存在性之间深刻的逆向关系。[@problem_id:1418576]", "problem": "在计算复杂性理论中，概率可检验证明（PCP）定理在优化问题的近似困难性与证明验证之间建立了一种深刻的联系。本问题探讨了为一个特定问题发现一个高效近似算法所带来的一个假设性后果。\n\n考虑最大恰好-3-模-2-线性方程（MAX-E3-LIN-2）问题。MAX-E3-LIN-2 的一个实例由域 $\\mathbb{F}_2 = \\{0, 1\\}$ 上的一组变量 $x_1, \\dots, x_m$ 和一系列约束组成，其中每个约束都是一个恰好涉及三个不同变量的线性方程，即形式为 $x_i \\oplus x_j \\oplus x_k = b$，其中 $b \\in \\{0, 1\\}$ 且 $\\oplus$ 表示异或运算（模2加法）。其目标是找到一个对变量的赋值，以最大化被满足的方程总数。\n\n现在，设想一个由输入大小 $n$ 索引的 PCP 验证者族，其设计用于判定一个语言 $L$。对于任何大小为 $n$ 的输入串，验证者 $V_n$ 对一个证明串进行操作。验证过程涉及一系列局部检查，其中每个检查都可以完美地表示为一个 MAX-E3-LIN-2 实例中的约束。验证者的性能由其完备性 $c(n)$ 和可靠性 $s(n)$ 来刻画。\n- 如果一个输入在 $L$ 中（一个“是”实例），则存在一个证明，使验证者以概率 $c(n)$ 接受。\n- 如果一个输入不在 $L$ 中（一个“否”实例），则任何证明都使验证者以至多 $s(n)$ 的概率接受。\n\n给定以下两个前提：\n1. 现已发现 MAX-E3-LIN-2 存在一个多项式时间近似方案（PTAS）。PTAS 是一种算法，对于任意给定的实例 $I$ 和任意误差参数 $\\epsilon  0$，它能产生一个解，其解的值在最优值的 $(1-\\epsilon)$ 乘法因子范围内。对于任意固定的 $\\epsilon$，该算法的运行时间是实例大小 $|I|$ 的多项式时间。\n2. 语言 $L$ 不在 P 类中，P 类是可在确定性多项式时间内求解的判定问题类。\n\n基于这些前提，下列关于验证者完备性 $c(n)$ 和可靠性 $s(n)$ 的陈述中，哪一个必须为真？\n\nA. 对所有足够大的 $n$，$c(n) = 1$ 且 $s(n) \\le 1/2$。\n\nB. 间隙，定义为 $c(n) - s(n)$，对于所有足够大的 $n$，必须是一个大于零的常数。\n\nC. 比率 $s(n)/c(n)$，对于所有足够大的 $n$，必须是一个严格小于 1 的常数。\n\nD. 当 $n \\to \\infty$ 时，比率 $s(n)/c(n)$ 必须趋近于 1。\n\nE. 对于某个常数 $k0$，间隙 $c(n) - s(n)$ 必须是 $O(1/n^k)$。", "solution": "我们将验证者与优化问题之间的联系以及 PTAS 的影响形式化。\n\n对于一个长度为 $n$ 的输入串 $x$，令 $V_{n}$ 为该验证者。根据假设， $V_{n}$ 的每个局部检查都恰好是 MAX-E3-LIN-2 实例中的一个约束。通过聚合所有检查来构造一个实例 $I(x)$，总共有 $M$ 个约束。令 $p^{\\ast}(x)$ 表示验证者 $V_{n}$ 在输入 $x$ 上对所有证明所能达到的最大接受概率。因为每个检查对应一个约束，而“接受”事件即为所查询的约束被满足的事件，所以可满足约束的最优比例等于 $p^{\\ast}(x)$：\n$$\n\\frac{\\operatorname{OPT}(I(x))}{M}=p^{\\ast}(x).\n$$\n根据完备性和可靠性，\n$$\nx \\in L \\implies p^{\\ast}(x) \\ge c(n), \\qquad x \\notin L \\implies p^{\\ast}(x) \\le s(n).\n$$\n\nMAX-E3-LIN-2 的一个 PTAS 保证，对于任何 $\\epsilon0$，在实例 $I(x)$ 上，它会返回一个值为 $\\operatorname{val}(I(x))$ 的赋值，该赋值满足\n$$\n\\frac{\\operatorname{val}(I(x))}{M} \\ge (1-\\epsilon)\\,\\frac{\\operatorname{OPT}(I(x))}{M}=(1-\\epsilon)\\,p^{\\ast}(x).\n$$\n\n假设存在一个常数 $\\delta0$ 和一个 $n_{0}$，使得对于所有 $n \\ge n_{0}$：\n$$\n\\frac{s(n)}{c(n)} \\le 1-\\delta.\n$$\n固定一个 $\\epsilon$ 使得 $0\\epsilon\\delta$。对于任何 $|x|=n \\ge n_{0}$ 的“是”实例，\n$$\n\\frac{\\operatorname{val}(I(x))}{M} \\ge (1-\\epsilon)\\,p^{\\ast}(x) \\ge (1-\\epsilon)\\,c(n)  (1-\\delta)\\,c(n) \\ge s(n).\n$$\n对于任何“否”实例，任何赋值最多能满足 $s(n)$ 比例的约束，所以\n$$\n\\frac{\\operatorname{val}(I(x))}{M} \\le s(n).\n$$\n因此，通过将得到的比例与区间 $(s(n),(1-\\epsilon)c(n))$ 中的任意阈值进行比较，就可以在确定性多项式时间内判定 $L$（因为对于固定的 $\\epsilon$，PTAS 在 $|I(x)|$ 的多项式时间内运行，并且计算比例也是多项式时间的），这意味着 $L \\in \\mathrm{P}$。这与 $L \\notin \\mathrm{P}$ 的前提相矛盾。因此，对于所有足够大的 $n$，$s(n)/c(n)$ 不可能与 1 有界分离。等价地，我们必须有\n$$\n\\lim_{n \\to \\infty} \\frac{s(n)}{c(n)}=1.\n$$\n\n现在评估各个选项：\n- A 选项会得出对于大的 $n$ 有 $\\frac{s(n)}{c(n)} \\le \\frac{1}{2}$，这与我们刚刚推导出的必要条件相矛盾。\n- B 选项断言存在一个常数的加性间隙 $c(n)-s(n) \\ge \\gamma0$；结合任意下界 $c(n) \\ge c_{0}0$，这将意味着 $\\frac{s(n)}{c(n)} \\le 1-\\gamma/c_{0}1$，再次与必要条件矛盾。即使没有统一的 $c_{0}$，前提也并未要求 B 成立，而且 B 通常会允许通过一个固定的 $\\epsilon$ 进行多项式时间判定，因此在 $L \\notin \\mathrm{P}$ 的条件下它不可能是真的。\n- C 选项明确指出存在一个严格小于 1 的常数比率，我们刚刚排除了这种情况。\n- D 选项恰好陈述了所要求的条件 $\\frac{s(n)}{c(n)} \\to 1$。\n- E 选项要求加性间隙具有一个特定的多项式衰减速率。前提只强迫相对间隙趋于零；而加性间隙例如可以是 $\\Theta(1/\\ln n)$，它对于任何 $k0$ 都不是 $O(1/n^{k})$。因此 E 并非必然成立。\n\n因此，唯一必须为真的陈述是 D。", "answer": "$$\\boxed{D}$$", "id": "1418576"}]}