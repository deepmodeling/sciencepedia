{"hands_on_practices": [{"introduction": "要真正理解一个计算模型的精髓，一个有效的方法是思考当其关键部分被移除时会发生什么。$AM$ 协议的核心在于验证者 Arthur 的随机性和证明者 Merlin 的无限计算能力。本练习通过一个思想实验，要求我们探索如果 Arthur 失去了他产生随机挑战的能力，变为一个确定性验证者，那么 $AM$ 类会变成什么 [@problem_id:1450703]。通过将这个修改后的协议与一个我们熟知的复杂性类联系起来，我们可以更深刻地体会到随机性在交互式证明中所扮演的不可或缺的角色。", "problem": "在计算复杂性理论中，AM 类（代表 Arthur-Merlin）刻画了这样一类语言，其成员资格可以通过一个两轮交互式协议来验证。对于一个长度为 $n$ 的输入串 $x$，该协议按以下步骤进行：\n1.  验证者 Arthur，一台概率多项式时间图灵机，生成一个长度为 $n$ 的多项式级别的随机串 $r$，并将其发送给证明者 Merlin。\n2.  证明者 Merlin，拥有无限的计算能力，接收 $r$ 并返回一个长度为 $n$ 的多项式级别的响应串 $y$（即“证明”）。\n3.  随后，Arthur 根据输入 $x$、他的随机串 $r$ 和 Merlin 的响应 $y$ 来确定性地计算一个结果。\n\n如果存在一个满足以下条件的协议，则语言 $L$ 属于 AM 类：\n-   **完备性：**如果 $x \\in L$，Merlin 存在一种选择 $y$ 的策略，使得 Arthur 以至少 $2/3$ 的概率（基于对 $r$ 的选择）接受。\n-   **可靠性：**如果 $x \\notin L$，对于 Merlin 使用的任何选择 $y$ 的策略，Arthur 以至多 $1/3$ 的概率（基于对 $r$ 的选择）接受。\n\n现在，考虑这个类的一个修改版本，我们称之为 DAM (Deterministic-Arthur-Merlin)。在 DAM 协议中，Arthur 是一台确定性多项式时间图灵机，这意味着他无法访问随机位。因此，在第一步中，Arthur 向 Merlin 发送一个预定义的、空的或恒定的字符串，因为他无法生成随机挑战。然后 Merlin 发送他的证明 $y$，Arthur 根据 $x$ 和 $y$ 做出最终的确定性决策。\n\n下列哪个复杂性类等价于 DAM？\n\nA. P (多项式时间)\nB. NP (非确定性多项式时间)\nC. co-NP\nD. BPP (有界错误概率多项式时间)\nE. PSPACE (多项式空间)", "solution": "让我们来分析修改后的复杂性类 DAM (Deterministic-Arthur-Merlin) 的定义。\n\n一个语言 $L$ 属于 DAM 类的协议如下：\n1.  对于给定的输入串 $x$，Arthur，一台确定性多项式时间机器，准备一条要发送给 Merlin 的消息。由于 Arthur 是确定性的并且无法访问随机性，他的消息不能依赖于随机串。他只能根据 $x$ 来计算一条消息。然而，标准的 AM 协议将 Arthur 的第一条消息作为随机性的*唯一*来源。在一个确定性变体中，这条消息是固定的（例如，一个空字符串），并且不包含 Merlin 尚不具备的任何信息。因此，第一轮是无关紧要的，我们可以将该协议建模为 Merlin 简单地向 Arthur 发送一个证明串 $y$。\n2.  Merlin，凭借其无限的计算能力，向 Arthur 发送一个证明串 $y$。$y$ 的长度必须是 $x$ 长度的多项式级别。\n3.  Arthur，一个确定性多项式时间验证者，接收 $y$ 并根据输入 $x$ 和证明 $y$ 决定是接受还是拒绝。我们将 Arthur 的验证过程表示为一个多项式时间算法 $V(x, y)$，它对“接受”输出 1，对“拒绝”输出 0。\n\n现在，让我们将 AM 的完备性和可靠性条件转换到 DAM 的上下文中。由于没有随机性，接受的概率要么是 0，要么是 1。\n\n-   **完备性：**如果 $x \\in L$，必须存在一种 Merlin 的策略使得 Arthur 接受。由于 Arthur 的最终决定是确定性的，这意味着必须存在一个证明串 $y$（多项式长度），使得 $V(x, y) = 1$。“概率”为 1，满足 $\\geq 2/3$ 的条件。\n\n-   **可靠性：**如果 $x \\notin L$，对于 Merlin 使用的任何策略，Arthur 都必须拒绝。这意味着对于 Merlin 可能发送的任何证明串 $y$，Arthur 的验证都必须失败。也就是说，对于所有（多项式长度的）字符串 $y$，$V(x, y) = 0$。接受的“概率”为 0，满足 $\\leq 1/3$ 的条件。\n\n因此，当且仅当存在一个确定性多项式时间算法 $V$ 和一个多项式函数 $p$，使得对于任何输入串 $x$：\n$x \\in L \\iff \\exists y$ 且 $|y| \\leq p(|x|)$ 使得 $V(x, y) = 1$，一个语言 $L$ 就属于 DAM 类。\n\n这正是复杂性类 NP（非确定性多项式时间）的基于验证者的定义。在 NP 的背景下，字符串 $y$ 被称为“证书”或“见证”。NP 的定义是：如果存在一个多项式时间验证者 $V$，使得对于每个 $x$，当且仅当存在一个长度为 $|x|$ 的多项式级别的证书 $y$ 能够被 $V$ 接受时，$x \\in L$。\n\n我们为 DAM 推导出的定义与 NP 的定义是相同的。\n\n我们来考虑其他选项：\n-   **A. P:** 如果 Arthur 可以在多项式时间内自己决定该语言，而不需要 Merlin 的证明，那就会是这种情况。我们的定义允许那些寻找证明 $y$ 可能很困难，但验证它很容易的问题，这正是那些尚不确定是否在 P 中的 NP 问题（如 SAT）的本质。\n-   **C. co-NP:** 如果一个语言的补集在 NP 中，那么该语言就在 co-NP 中。这意味着对于“否”实例（$x \\notin L$），存在一个简短的非成员资格证明。我们的 DAM 定义要求为“是”实例（$x \\in L$）提供证明。\n-   **D. BPP:** 这个类由概率算法定义。我们明确地从 Arthur 那里移除了随机性，所以结果类不是概率性的。\n-   **E. PSPACE:** 虽然 NP 包含在 PSPACE 中，但没有理由相信它们是相等的。DAM 协议只给予 Arthur 多项式时间，而不是多项式空间，因此没有理由认为它会像 PSPACE 那样强大。\n\n因此，修改后的 DAM 类等价于 NP。", "answer": "$$\\boxed{B}$$", "id": "1450703"}, {"introduction": "理解了随机性的重要性之后，让我们来看一个它在实践中如何发挥作用的具体例子。本练习要求我们为矩阵秩（MATRIX RANK）问题设计一个高效的 $AM$ 协议，其中 Merlin 需要说服 Arthur 一个给定矩阵的秩至少为 $k$ [@problem_id:1450673]。这个问题的巧妙之处在于，它展示了随机性如何将一个计算上可能很昂贵的确定性验证任务（例如，找到一个非奇异子矩阵并计算其行列式）转变为一个简单、快速且在很高概率下正确的概率性检查。这揭示了随机化算法中一种强大的设计模式，并具体展示了 $AM$ 协议的效率和威力。", "problem": "在计算复杂性理论领域，Arthur-Merlin (AM) 协议是一种交互式证明系统，其中一个计算能力有限的概率验证者（Arthur）与一个全能但可能不可信的证明者（Merlin）进行交互。就本问题而言，我们考虑一个单轮协议，其中 Merlin 向 Arthur 发送一个单一的证明字符串。然后 Arthur 执行一个随机计算，该计算必须在输入规模的多项式时间内完成，以决定是接受还是拒绝 Merlin 的主张。\n\n考虑以下判定问题：给定一个 $n \\times n$ 矩阵 $M$，其元素来自一个大的有限域 $\\mathbb{F}_q$，以及一个整数 $k$（其中 $1 \\leq k \\leq n$），判定 $M$ 的秩是否至少为 $k$。Merlin 的目标是构建一个证明来说服 Arthur $\\operatorname{rank}(M) \\geq k$。Arthur 的验证算法应该非常高效，理想情况下应避免像计算完整行列式这样计算成本高昂的操作。\n\n下列哪项描述了完成此任务的正确且高效的协议，同时满足完备性（Arthur 以概率 1 接受真实的主张）和可靠性（Arthur 以至多 1/2 的概率接受错误的主张）的条件？\n\nA. Merlin 确定 $M$ 的一个 $k \\times k$ 子矩阵 $A$。Arthur 选择两个随机向量 $u, v \\in \\mathbb{F}_q^k$ 并发送给 Merlin。Merlin 返回一个标量 $\\alpha$，并声称它等于 $u^T A v$。然后 Arthur 自己计算 $u^T A v$，如果他的结果与 $\\alpha$ 匹配，则接受。\n\nB. Merlin 确定 $M$ 的一个 $k \\times k$ 子矩阵 $A$，声称它是非奇异的，并将其行和列索引发送给 Arthur。然后 Arthur 随机选择 $k$ 个向量 $v_1, \\dots, v_k \\in \\mathbb{F}_q^k$，计算像向量 $u_i = A v_i$（其中 $i=1, \\dots, k$），如果向量集合 $\\{u_1, \\dots, u_k\\}$ 是线性无关的，则接受。\n\nC. Merlin 确定 $M$ 的 $k$ 个列，声称它们是线性无关的，从而构成一个 $n \\times k$ 的子矩阵 $M_C$。他将这些列的索引发送给 Arthur。Arthur 构建一个随机的 $k \\times n$ 矩阵 $R$ 并计算 $k \\times k$ 的乘积矩阵 $P = R M_C$。如果 $P$ 的行列式非零，则 Arthur 接受。\n\nD. Merlin 确定 $M$ 的一个 $k \\times k$ 子矩阵 $A$，声称它是非奇异的。他计算一个矩阵 $B$，并声称它是 $A$ 的逆矩阵。他将 $A$ 的索引和矩阵 $B$ 发送给 Arthur。Arthur 随机选择一个向量 $v \\in \\mathbb{F}_q^k$，计算 $w = Bv$，然后计算 $w' = Aw$。如果 $w'$ 等于原始向量 $v$，则 Arthur 接受。\n\nE. Merlin 确定 $M$ 的一个 $k \\times k$ 子矩阵 $A$，声称它是非奇异的，并将其索引发送给 Arthur。Arthur 选择一个随机向量 $r \\in \\mathbb{F}_q^k$ 并作为挑战发送给 Merlin。然后 Merlin 找到并返回一个向量 $x$，声称它是方程组 $Ax = r$ 的解。如果 $Ax$ 确实等于 $r$，则 Arthur 接受。", "solution": "我们需要一个单轮协议：Merlin 发送一个证明字符串；然后 Arthur 执行一个随机化的多项式时间验证，其完备性为 1，可靠性至多为 $\\frac{1}{2}$。该判定问题是验证 $\\operatorname{rank}(M) \\geq k$ 是否成立。这等价于 $M$ 中存在一个 $k \\times k$ 的非奇异子矩阵 $A$，因为 $\\operatorname{rank}(M) \\geq k$ 当且仅当 $M$ 有 $k$ 个线性无关的列（或行），这又等价于存在一个行列式非零的 $k \\times k$ 子矩阵。\n\n考虑选项 D。Merlin 确定一个 $k \\times k$ 子矩阵 $A$ 并提供一个声称是 $A^{-1}$ 的矩阵 $B$。Arthur 随机选择一个 $v \\in \\mathbb{F}_{q}^{k}$，计算 $w = B v$，然后计算 $w' = A w = A(Bv)$，如果 $w' = v$ 则接受。验证的断言是 $A B v = v$。令 $I_{k}$ 表示 $k \\times k$ 的单位矩阵。\n\n完备性：如果 $\\operatorname{rank}(M) \\geq k$，则存在一个 $k \\times k$ 的非奇异子矩阵 $A$。如果 Merlin 发送了正确的 $B = A^{-1}$，那么 $A B = I_{k}$。因此对于每一个 $v \\in \\mathbb{F}_{q}^{k}$，\n$$\nA(B v) = (A B) v = I_{k} v = v,\n$$\n所以 Arthur 根据其随机性以概率 $1$ 接受。因此完备性为 $1$。\n\n可靠性：如果 $\\operatorname{rank}(M) < k$，那么每个 $k \\times k$ 的子矩阵 $A$ 都是奇异的，所以不存在任何 $B$ 使得 $A B = I_{k}$。对于 Merlin 发送的任何 $B$，定义误差矩阵\n$$\nE \\triangleq A B - I_{k}.\n$$\n由于 $A$ 是奇异的，$E \\neq 0$。Arthur 当且仅当 $E v = 0$ 时接受。对于一个在 $\\mathbb{F}_{q}^{k}$ 中均匀随机的 $v$，接受的概率等于\n$$\n\\Pr_{v \\leftarrow \\mathbb{F}_{q}^{k}}[E v = 0] = \\frac{|\\ker(E)|}{q^{k}} = \\frac{q^{\\dim \\ker(E)}}{q^{k}}.\n$$\n因为 $E \\neq 0$，我们有 $\\operatorname{rank}(E) \\geq 1$，所以根据秩-零度定理，\n$$\n\\dim \\ker(E) = k - \\operatorname{rank}(E) \\leq k - 1,\n$$\n这意味着\n$$\n\\Pr[\\text{accept}] \\leq \\frac{q^{k-1}}{q^{k}} = \\frac{1}{q} \\leq \\frac{1}{2}.\n$$\n因此可靠性至多为 $\\frac{1}{2}$。Arthur 的计算只在 $\\mathbb{F}_{q}$ 上使用 $O(k^{2})$ 次域运算的矩阵向量乘法，以及从 $M$ 中提取 $A$ 的元素，避免了计算完整的行列式。\n\n现在考虑其他选项：\n\nA. 这是多轮的（Arthur 向 Merlin 发送 $u, v$）并且不检验非奇异性：无论 $A$ 是否奇异，$u^{T} A v$ 的等式都可能成立。它既不满足单轮约束，也不满足可靠性。\n\nB. Merlin 发送一个 $k \\times k$ 子矩阵 $A$ 的索引。Arthur 随机选择 $v_{1},\\dots,v_{k} \\in \\mathbb{F}_{q}^{k}$，如果 $\\{A v_{i}\\}$ 线性无关则接受。即使 $A$ 是非奇异的，随机选择的 $\\{v_{i}\\}$ 也可能以正概率线性相关，导致对真实主张的拒绝。因此完备性小于 $1$，违反了要求。\n\nC. Merlin 发送 $k$ 个无关列的索引，构成 $M_{C}$。Arthur 随机选择 $R \\in \\mathbb{F}_{q}^{k \\times n}$，如果 $\\det(R M_{C}) \\neq 0$ 则接受。当 $M_{C}$ 具有满列秩时，随着 $R$ 均匀变化，$R M_{C}$ 在 $\\mathbb{F}_{q}^{k \\times k}$ 上均匀分布，所以\n$$\n\\Pr[\\det(R M_{C}) \\neq 0] = \\prod_{i=0}^{k-1} \\left(1 - q^{i-k}\\right) < 1,\n$$\n因此完备性小于 $1$，违反了要求。\n\nE. 这是一个标准的交互式证明：Arthur 发送一个随机的 $r \\in \\mathbb{F}_{q}^{k}$，Merlin 返回满足 $A x = r$ 的 $x$。它具有完备性 1 和至多 $\\frac{1}{q}$ 的可靠性，但它不是单轮的，因为 Arthur 向 Merlin 发送了一个挑战。因此它违反了单轮约束。\n\n只有 D 满足单轮、完备性为 1、可靠性至多为 $\\frac{1}{2}$ 以及高效性。", "answer": "$$\\boxed{D}$$", "id": "1450673"}, {"introduction": "$AM$ 协议的能力远不止于验证线性代数属性，它还能处理复杂的逻辑断言。本练习挑战我们为 UNIQUE-SAT 问题设计一个交互式协议，该问题不仅要求证明一个布尔公式是可满足的，还要求证明其只有唯一的满足解 [@problem_id:1450707]。这个实践引入了交互式证明理论中一个极为强大的技术——“代数化”（arithmetization），它将逻辑公式转化为多项式。通过这种转换，证明唯一性的逻辑问题就变成了验证一个代数和是否为零的断言，而这可以通过高效的“和校验协议”（sum-check protocol）来完成，从而展示了 $AM$ 在处理计数和唯一性等问题上的强大能力。", "problem": "在计算复杂性理论中，Arthur-Merlin (AM) 类刻画了可由一种特定的交互式证明系统解决的判定问题。一个 AM 协议对于输入字符串 $w$ 包含三轮通信：\n1.  **Merlin -> Arthur:** 全能但不可信的魔法师 Merlin 将一个证明字符串 $m_1$ 发送给 Arthur。\n2.  **Arthur -> Merlin:** 概率多项式时间验证者 Arthur 将一个公共随机字符串 $r$ 发送给 Merlin。\n3.  **Merlin -> Arthur:** Merlin 将最终的证明字符串 $m_2$ 发送给 Arthur。\n随后，Arthur 基于 $w$、$m_1$、$r$ 和 $m_2$ 执行一个多项式时间计算，以决定接受或拒绝。该协议必须满足：\n-   **完备性 (Completeness)：** 如果 $w$ 在该语言中，那么存在一个 Merlin 的策略，使得 Arthur 以至少 $2/3$ 的概率接受。\n-   **可靠性 (Soundness)：** 如果 $w$ 不在该语言中，那么对于 Merlin 使用的任何策略，Arthur 以至多 $1/3$ 的概率接受。\n\n考虑语言 UNIQUE-SAT，它由所有恰好有一个满足赋值的布尔可满足性公式组成。你的任务是为 UNIQUE-SAT 设计一个 AM 协议的核心部分。\n\n假设协议开始时，Merlin 发送一个字符串 $a$，并声称这是给定具有 $n$ 个变量的公式 $\\phi$ 的唯一满足赋值。Arthur 在多项式时间内验证 $\\phi(a)$ 确实为真。核心挑战在于随后的交互阶段，Merlin 必须说服 Arthur 该赋值的*唯一性*。以下哪一项描述了用于此交互式唯一性证明的有效且正确的机制？\n\nA. Arthur 选择一个随机哈希函数 $h: \\{0,1\\}^n \\to \\{0,1\\}^n$ 和一个随机值 $z \\in \\{0,1\\}^n$。他将 $(h, z)$ 发送给 Merlin。为了让 Arthur 信服其唯一性，Merlin 必须证明不存在赋值 $y \\neq a$ 使得 $\\phi(y)$ 为真且 $h(y) = z$。\n\nB. Arthur 和 Merlin 商定将公式 $\\psi(y) = \\phi(y) \\land (y \\neq a)$ 算术化为一个大有限域 $\\mathbb{F}_q$ 上的低阶多变量多项式 $P(y_1, \\dots, y_n)$。Arthur 从 $\\mathbb{F}_q^n$ 中取一个随机点 $(r_1, \\dots, r_n)$ 发送给 Merlin。Merlin 回复一个单变量多项式序列 $g_1, \\dots, g_n$。Arthur 通过检查 $g_i$ 与最终求值 $P(r_1, \\dots, r_n)$ 之间的关系，来验证这些多项式是否正确地编码了“所有 $y \\in \\{0,1\\}^n$ 上的 $P(y)$ 之和为零”这一声明。\n\nC. Arthur 和 Merlin 商定将公式 $\\psi(y) = \\phi(y) \\land (y \\neq a)$ 算术化为一个多项式 $P(y_1, \\dots, y_n)$。Arthur 生成一个单一的随机点 $r = (r_1, \\dots, r_n)$ 并将其发送给 Merlin。Merlin 必须计算并返回其值 $v = P(r)$。Arthur 当且仅当 $v=0$ 时接受该赋值是唯一的。\n\nD. Merlin 构建一个图，其顶点是 $2^n$ 个可能的变量赋值。然后他向 Arthur 提供一个证书，证明与赋值 $a$ 对应的顶点在所有满足赋值所导出的子图中形成一个大小为 1 的连通分量。\n\nE. Merlin 将唯一性声明重新表述为真量化布尔公式 (TQBF) $\\exists x \\forall y ((\\phi(x)) \\land (\\phi(y) \\implies y=x))$。然后他与 Arthur 进行一个已知的 TQBF 的 AM 协议来证明这个新公式为真。", "solution": "我们必须说服 Arthur，Merlin 发送的赋值 $a \\in \\{0,1\\}^{n}$ 是 $\\phi$ 的唯一满足赋值。令 $\\psi(y)$ 是由下式定义的布尔谓词\n$$\n\\psi(y) \\equiv \\phi(y) \\land (y \\neq a).\n$$\n$a$ 的唯一性等价于\n$$\n\\sum_{y \\in \\{0,1\\}^{n}} \\psi(y) \\;=\\; 0.\n$$\n为将其置于 AM 框架中，我们将 $\\psi$ 算术化为一个在足够大的有限域 $\\mathbb{F}_{q}$ 上的低阶多变量多项式 $P \\in \\mathbb{F}_{q}[Y_{1},\\dots,Y_{n}]$，使得：\n- 对于所有 $y \\in \\{0,1\\}^{n}$，$P(y) \\in \\{0,1\\}$ 且 $P(y) = 1$ 当且仅当 $\\psi(y)$ 为真。\n- $P$ 的总次数以一个关于 $n$ 的多项式为界。\n\n定义目标和\n$$\nS \\;=\\; \\sum_{y \\in \\{0,1\\}^{n}} P(y).\n$$\n“$a$ 是唯一的”这一声明等价于 $S=0$。这个声明可以通过标准的和校验协议（sumcheck protocol）来验证，该协议是一种公共掷币交互式证明，因此可以在 AM 格式中实现，其中 Arthur 一次性发送他所有的随机选择。\n\n具体来说，为 $i=1,\\dots,n$ 定义单变量多项式\n$$\ng_{1}(X_{1}) \\;=\\; \\sum_{y_{2},\\dots,y_{n} \\in \\{0,1\\}} P(X_{1},y_{2},\\dots,y_{n}),\n$$\n并且，对于 $i \\geq 2$ 归纳地定义\n$$\ng_{i}(X_{i}) \\;=\\; \\sum_{y_{i+1},\\dots,y_{n} \\in \\{0,1\\}} P(r_{1},\\dots,r_{i-1},X_{i},y_{i+1},\\dots,y_{n}),\n$$\n其中 $(r_{1},\\dots,r_{n}) \\in \\mathbb{F}_{q}^{n}$ 是 Arthur 的随机挑战。每个 $g_i$ 的次数至多为 $P$ 在相应变量上的次数，因此其次数至多是关于 $n$ 的多项式。\n\n一次与 AM 兼容的执行过程如下：\n- Merlin 首先发送 $a$，Arthur 在多项式时间内检查 $\\phi(a)$ 是否为真。\n- Arthur 从 $\\mathbb{F}_{q}^{n}$ 中均匀随机抽样 $(r_{1},\\dots,r_{n})$，并将其作为单一的公共随机字符串发送。\n- Merlin 回复所声称的单变量多项式序列 $g_{1},\\dots,g_{n}$。\n\nArthur 执行以下多项式时间检查：\n1. 检查 $g_{1}(0) + g_{1}(1) = 0$ (这编码了声明 $S=0$)。\n2. 对于每个 $i=1,\\dots,n-1$，检查一致性：\n$$\ng_{i}(r_{i}) \\stackrel{?}{=} g_{i+1}(0) + g_{i+1}(1).\n$$\n3. 最后，检查\n$$\ng_{n}(r_{n}) \\stackrel{?}{=} P(r_{1},\\dots,r_{n}),\n$$\n其中 Arthur 通过在该点对 $\\psi$ 的算术化进行求值，从而在多项式时间内亲自计算 $P(r_{1},\\dots,r_{n})$。这个求值是高效的，因为 $P$ 是通过标准的低阶扩展从 $\\phi$ 和谓词 $(y \\neq a)$ 获得的。\n\n完备性：如果 $a$ 是唯一的，那么 $S=0$。一个诚实的 Merlin 可以提供正确的 $g_i$ 多项式。所有检查都确定性地通过，因此 Arthur 以至少 $\\frac{2}{3}$ 的概率接受（实际上，在理想化设置中，对于 Arthur 的随机性，接受概率为 $1$）。\n\n可靠性：如果存在一个 $y \\neq a$ 使得 $\\phi(y)$ 为真，那么 $S \\geq 1$，所以任何声称 $S=0$ 的 $g_i$ 序列必须在某一步上是不一致的。根据标准的和校验可靠性以及 Schwartz–Zippel 引理，对于随机的 $(r_{1},\\dots,r_{n})$，一个不一致的序列通过所有检查的概率至多为\n$$\n\\frac{\\deg(P)}{|\\mathbb{F}_{q}|}\n$$\n（对于检查序列，最多相差一个 $n$ 的多项式因子）。选择在 $n$ 上多项式大的 $|\\mathbb{F}_{q}|$ 可以确保这个作弊概率至多为 $\\frac{1}{3}$。因此，AM 的完备性和可靠性要求得到满足。\n\n因此，有效的机制正是选项 B 中描述的算术化加和校验方法。\n\n为什么其他选项失败：\n- A: 对于 $h:\\{0,1\\}^{n} \\to \\{0,1\\}^{n}$ 和随机的 $z$，第二个解与 $z$ 碰撞的概率是 $2^{-n}$，这是指数级小的，不能通过多项式次重复提升到常数概率。此外，如果没有算术化的交互式证明结构，为每个 $(h,z)$ 证明不存在性是 coNP-难的。\n- C: 一次单一的随机求值 $P(r)$ 无法提供证明整个超立方体上的和为零的证书，并且让 Merlin 报告 $P(r)$ 是无用的，除非 Arthur 能够独立地验证它，而这无论如何都会归结为完整的和校验框架；如其所述，该方法是不可靠的。\n- D: 所描述的图有 $2^n$ 个顶点；在满足赋值中构建并验证一个单点连通分量的证书不是多项式时间可检查的。\n- E: TQBF 是 PSPACE-完备的，并且目前不知道它是否属于 AM；调用一个用于 TQBF 的 AM 协议是无效的。\n\n因此，只有 B 描述了一种用于证明唯一性的正确 AM 机制。", "answer": "$$\\boxed{B}$$", "id": "1450707"}]}