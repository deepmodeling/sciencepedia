{"hands_on_practices": [{"introduction": "理论知识只有通过实践才能真正掌握。让我们从一个基本问题开始，确保你理解了公共硬币协议的核心机制。这个练习将带你回顾一个典型的 $\\mathrm{AM}[2]$ 协议的步骤，这是 Arthur-Merlin 协议中最简洁的形式之一。准确识别信息交换的顺序是理解更复杂协议的基础。[@problem_id:1439640]", "problem": "在计算复杂性理论领域，一个交互式证明系统包含一个名为 Arthur 的验证者和一个名为 Merlin 的证明者。Arthur 是一台概率多项式时间图灵机，而 Merlin 拥有无限的计算能力但不可信。他们通过一个协议来确定一个给定的输入字符串 $x$ 是否属于一个语言 $L$。\n\n复杂性类 $\\mathrm{AM}[k]$ 包含了所有具有 $k$ 条消息交互式证明系统的语言，其中 Arthur 首先行动，并且 Arthur 的随机选择（“硬币”）是“公共的”，即向 Merlin 公开。\n\n考虑一个属于类 $\\mathrm{AM}[2]$ 的语言 $L$。下列哪个操作序列正确地描述了用于判断输入字符串 $x$ 是否在 $L$ 中的基本协议？\n\nA. Arthur 接收输入 $x$，生成一个长度为 $|x|$ 的多项式的随机字符串 $r$，并将其发送给 Merlin。Merlin 计算并返回一条消息 $m$。然后 Arthur 对 $(x, r, m)$ 执行一个确定性多项式时间计算，以决定是接受还是拒绝。\n\nB. Arthur 接收输入 $x$。同样可以访问 $x$ 的 Merlin 计算一个证明消息 $m$ 并将其发送给 Arthur。然后 Arthur 生成一个随机字符串 $r$，并对 $(x, m, r)$ 执行一个确定性多项式时间计算，以决定是接受还是拒绝。\n\nC. Arthur 接收输入 $x$，生成一个随机字符串 $r_1$，并将其发送给 Merlin。Merlin 返回一条消息 $m$。然后 Arthur 生成第二个随机字符串 $r_2$ 并发送给 Merlin，Merlin 提供最终的响应。然后 Arthur 做出决定。\n\nD. Arthur 接收输入 $x$。Merlin 生成一个他声称是随机的字符串 $r$ 以及一个证明消息 $m$。Merlin 将对 $(r, m)$ 发送给 Arthur。然后 Arthur 对 $(x, r, m)$ 执行一个确定性多项式时间计算，以决定是接受还是拒绝。\n\nE. Arthur 接收输入 $x$，生成一个随机字符串 $r$，并将其发送给 Merlin。Merlin 计算并返回一条消息 $m$。然后 Arthur 使用一组新的私有随机硬币对 $(x, r, m)$ 执行一个概率多项式时间计算，以决定是接受还是拒绝。", "solution": "我们回顾 $\\mathrm{AM}[k]$ 协议的定义：它是一个具有 $k$ 条消息的公共硬币交互式证明，其中 Arthur（一个概率多项式时间验证者）首先行动，并且 Arthur 的所有随机选择都是公共的，即向 Merlin 公开。具体对于 $\\mathrm{AM}[2]$，其标准协议恰好由两条消息组成：Arthur 发送一个单一的公共随机挑战，Merlin 回复一条消息；然后 Arthur 基于输入、公共随机性和 Merlin 的回复的一个确定性多项式时间谓词来做出决定。\n\n我们根据这个定义来分析每个选项。\n\n1. 在选项A中，Arthur 在接收输入 $x$ 后，生成一个长度为 $|x|$ 的多项式的随机字符串 $r$，并将其发送给 Merlin。Merlin 以一条消息 $m$ 作为回应。然后 Arthur 对 $(x, r, m)$ 执行一个确定性多项式时间计算来决定接受或拒绝。这符合标准的 $\\mathrm{AM}[2]$ 模型：两条消息，Arthur 使用公共硬币首先行动，并且在给定公共硬币的情况下，最终的决定可以被认为是确定性的，因为任何额外的公共随机性都可以并入 $r$ 中，而不会改变模型。\n\n2. 在选项B中，Merlin 首先发送一个证明 $m$，然后 Arthur 生成随机性 $r$ 并做出决定。这是 $\\mathrm{MA}$ 模式（Merlin 在先，Arthur 在后），并且在 Merlin 形成 $m$ 时，Arthur 的硬币不一定对 Merlin 公开。这不符合 $\\mathrm{AM}[2]$，因为不是 Arthur 首先行动。\n\n3. 在选项C中，消息超过了两条：Arthur 发送 $r_{1}$，Merlin 回复 $m$，Arthur 发送 $r_{2}$，Merlin 再次回复，然后 Arthur 做出决定。这不是 $\\mathrm{AM}[2]$，而是一个更长的公共硬币协议（至少是 $\\mathrm{AM}[3]$）。\n\n4. 在选项D中，Merlin 生成“随机”字符串 $r$ 并与 $m$ 一起发送给 Arthur。在公共硬币协议中，随机性是由 Arthur 生成并公开的；不能信任 Merlin 来生成 Arthur 的随机性。因此这违反了模型。\n\n5. 在选项E中，Arthur向Merlin发送一个公共随机字符串 $r$，Merlin 回复 $m$，然后 Arthur 使用一组新的私有随机硬币来做出决定。这违反了公共硬币条件，因为 Arthur 的新硬币是私有的。在公共硬币设置中，Arthur 使用的任何随机性都必须是公共的；此外，即使 Arthur 在最后使用了额外的公共随机性，它也可以被并入初始的 $r$ 中，使得在给定 $(x, r, m)$ 的情况下，最终的决定是确定性的。\n\n因此，只有选项 A 正确地描述了基本的 $\\mathrm{AM}[2]$ 协议。", "answer": "$$\\boxed{A}$$", "id": "1439640"}, {"introduction": "理解一个概念威力的最好方法之一，就是想象它不存在时会发生什么。这个思想实验将挑战你思考公共硬币在 Arthur-Merlin 协议中的真正作用。通过剥夺 Arthur 使用随机性的能力，我们将探索这个计算模型会退化成哪个我们所熟知的复杂性类，从而揭示随机性所带来的额外计算能力。[@problem_id:1439656]", "problem": "在计算复杂性理论中，交互式证明系统是描述涉及一个验证者和一个证明者的计算的抽象模型。Arthur-Merlin (AM) 协议是一种特定类型的交互式证明系统，用于解决关于语言 $L$ 的判定问题。它涉及一个名为 Arthur 的概率多项式时间验证者，和一个名为 Merlin 的全能但不可信的证明者。\n\n对于长度为 $n$ 的输入字符串 $x$，标准的 AM 协议定义如下：\n1.  验证者 Arthur 接收输入 $x$。他生成一个长度为 $n$ 的多项式次方的随机字符串 $r$ 并发送给 Merlin。这个字符串被认为是“公开的”，因为 Merlin 可以看到它。\n2.  证明者 Merlin 在接收到 $x$ 和 $r$ 后，计算并发送一个长度为 $n$ 的多项式次方的响应字符串 $y$ 给 Arthur。\n3.  Arthur 接着运行一个确定性多项式时间算法，我们称其判定函数为 $V(x, y, r)$，根据证明 $y$ 和他的随机字符串 $r$ 来接受或拒绝输入 $x$。\n\n如果满足以下两个条件，则语言 $L$ 属于复杂性类 AM：\n- **完备性 (Completeness)：** 对于任何字符串 $x \\in L$，存在一个来自 Merlin 的响应 $y$，使得 Arthur 以高概率接受。形式上：$\\forall x \\in L$，Merlin 可以选择一个证明 $y$，使得 $\\Pr_{r}[V(x, y, r) = \\text{accept}] \\geq \\frac{2}{3}$。\n- **可靠性 (Soundness)：** 对于任何字符串 $x \\notin L$，无论 Merlin 提供什么响应 $y$，Arthur 都将以低概率接受。形式上：$\\forall x \\notin L$，对于任何证明 $y$，$\\Pr_{r}[V(x, y, r) = \\text{accept}] \\leq \\frac{1}{3}$。\n\n现在，考虑此协议的一个修改版本，其中 Arthur 被剥夺了使用随机性的能力。他变成了一个纯粹的确定性多项式时间验证者，这意味着他不生成或使用任何随机字符串 $r$。下列哪个著名的复杂性类等价于这个修改后的、确定性的 Arthur-Merlin 协议所能判定的语言类？\n\nA. P (多项式时间)\nB. BPP (有界错误概率多项式时间)\nC. NP (非确定性多项式时间)\nD. co-NP\nE. AM\nF. MA", "solution": "我们重述标准的 AM 定义，然后移除随机性来推导所得的类。\n\n在 AM 中，验证者使用一个多项式长度的随机字符串 $r$ 和一个确定性判定过程 $V(x,y,r)$。完备性和可靠性条件是：\n$$\n\\forall x \\in L,\\ \\exists y \\text{ of length poly}(|x|):\\ \\Pr_{r}\\big[V(x,y,r)=\\text{accept}\\big] \\geq \\frac{2}{3},\n$$\n$$\n\\forall x \\notin L,\\ \\forall y \\text{ of length poly}(|x|):\\ \\Pr_{r}\\big[V(x,y,r)=\\text{accept}\\big] \\leq \\frac{1}{3}.\n$$\n\n现在移除 Arthur 的随机性。这产生了一个确定性多项式时间验证者，因此没有 $r$。等价地，令 $r$ 为空字符串 $\\epsilon$，并定义一个确定性判定谓词 $V'(x,y) \\coloneqq V(x,y,\\epsilon)$。对 $r$ 的概率变得微不足道：对于任何固定的输入和证明，接受概率要么是 $0$，要么是 $1$。因此，这两个 AM 条件简化为：\n$$\n\\forall x \\in L,\\ \\exists y \\text{ of length poly}(|x|):\\ V'(x,y)=\\text{accept},\n$$\n$$\n\\forall x \\notin L,\\ \\forall y \\text{ of length poly}(|x|):\\ V'(x,y)=\\text{reject}.\n$$\n\n这正是 $\\mathrm{NP}$ 的基于验证者的定义：对于“是”实例 (yes-instances)，语言有一个多项式长度的证据 $y$，确定性多项式时间验证者会接受它；而对于“否”实例 (no-instances)，不存在这样的证据。\n\n形式上，我们证明双向包含关系。\n\n- 修改后的 AM $\\subseteq \\mathrm{NP}$：给定一个由修改后协议（验证者为 $V'$）判定的语言 $L$，定义 $\\mathrm{NP}$ 验证者 $W(x,y)=1$ 当且仅当 $V'(x,y)=\\text{accept}$。根据完备性，对于 $x \\in L$ 存在一个 $y$ 使得 $W$ 接受；根据可靠性，对于 $x \\notin L$ 不存在任何 $y$ 使得 $W$ 接受。\n\n- $\\mathrm{NP} \\subseteq$ 修改后的 AM：给定 $L \\in \\mathrm{NP}$，其验证者 $W(x,y)$ 在确定性多项式时间内运行，我们构造修改后的协议，其中 Merlin 发送 $y$，Arthur 计算 $V'(x,y) \\coloneqq W(x,y)$。完备性和可靠性直接源于 $\\mathrm{NP}$ 的定义。\n\n因此，从 AM 中移除验证者随机性所得到的类等于 $\\mathrm{NP}$。在选项中，这是选项 C。", "answer": "$$\\boxed{C}$$", "id": "1439656"}, {"introduction": "公共硬币和私有硬币并非可以随意互换的概念，这个练习将通过一个具体的反例深刻地揭示这一点。我们假设一个使用私有硬币的协议，并探讨一种看似合理的、将其转化为公共硬币协议的“天真”尝试。通过分析这种转换的致命缺陷，你将亲身体会到为什么保护验证者的随机性在某些情况下对于协议的可靠性（Soundness）至关重要。[@problem_id:1439683]", "problem": "在计算复杂性理论中，一个交互式证明（IP）系统涉及一个强大的证明者（Prover），其试图说服一个随机化的验证者（Verifier）相信某个陈述的真实性。考虑一个用于语言 $L$ 的“私有硬币”IP系统。对于一个给定的输入字符串 $x$，验证者使用一个私有随机字符串 $r$（从一个包含 $2^k$ 个可能字符串的集合 $\\mathcal{R}$ 中均匀抽取）来与证明者进行对话。在交互结束时，验证者决定是接受还是拒绝。\n\n这个私有硬币系统由两个属性定义：\n1.  **完备性（Completeness）：** 如果输入字符串 $x$ 在语言 $L$ 中，那么存在一种策略，使得诚实的证明者总能说服验证者接受。接受的概率为 1。\n2.  **可靠性（Soundness）：** 如果输入字符串 $x$ 不在语言 $L$ 中，那么没有任何证明者（无论其策略如何）能以大于 $s$（其中 $0 < s < 1$）的概率说服验证者接受。该概率是基于验证者对 $r \\in \\mathcal{R}$ 的随机选择计算的。\n\n现在，考虑一个不同的、更简单的证明系统，我们称之为“基于证书”的系统 $\\mathcal{P}_{cert}$。在这个系统中，为了证明 $x$ 在 $L$ 中，证明者向一个确定性验证者提供一个单一的证书。所提供的证书是一个对 $(r_{guess}, T)$，其中 $r_{guess}$ 是来自集合 $\\mathcal{R}$ 的一个特定字符串，而 $T$ 是一次完整对话的记录。$\\mathcal{P}_{cert}$ 的确定性验证者执行一次单一的检查：它验证所提供的记录 $T$ 是否代表了一次交互，这次交互会在原始私有硬币验证者的私有随机字符串恰好是 $r_{guess}$ 的情况下，导致其接受输入 $x$。如果此检查通过，验证者接受；否则，它拒绝。\n\n假设对于一个不在 $L$ 中的特定字符串 $x_{false}$，能够让恶意证明者欺骗原始私有硬币验证者的私有随机字符串集合是非空的。当收到一个来自最优、恶意证明者的证书时，基于证书的系统 $\\mathcal{P}_{cert}$ 中的验证者接受虚假陈述“$x_{false}$ 在 $L$ 中”的概率是多少？\n\nA. $s$\nB. $s^k$\nC. $s/2^k$\nD. $1$\nE. $0$", "solution": "设 $\\mathcal{R}$ 为验证者的随机性空间，其中 $|\\mathcal{R}|=2^{k}$。对于 $x_{false} \\notin L$，私有硬币IP系统的可靠性条件指出，对于任意证明者策略，基于从 $\\mathcal{R}$ 中均匀随机选取的 $r$ 的接受概率至多为 $s$。等价地，存在一个“可接受的”随机字符串集合 $S \\subseteq \\mathcal{R}$（对于这些字符串，与证明者的某些交互可以导致原始验证者接受），使得\n$$\n\\frac{|S|}{|\\mathcal{R}|} \\le s \\quad \\Longrightarrow \\quad |S| \\le s \\cdot 2^{k}.\n$$\n问题假设 $S \\neq \\emptyset$。\n\n在基于证书的系统 $\\mathcal{P}_{cert}$ 中，验证者是确定性的，并对证书 $(r_{guess}, T)$ 执行单一检查。一个旨在最大化接受概率的恶意证明者可以选择 $r_{guess} \\in S$（根据 $S \\neq \\emptyset$ 的假设，这样的 $r_{guess}$ 存在），并提供一个相应的记录 $T$，该记录对于使用随机性 $r_{guess}$ 的原始验证者来说是可接受的。确定性验证者随后会验证 $T$ 是对于 $r_{guess}$ 的一个有效的、可接受的记录，并接受。在此验证过程中没有剩余的随机性，所以只要使用了这样的 $r_{guess}$，接受就是确定的。\n\n因此，在 $S \\neq \\emptyset$ 的假设下，当收到来自最优、恶意证明者的证书时，基于证书的验证者接受该虚假陈述的概率是\n$$\n1.\n$$\n这对应于选项 D。", "answer": "$$\\boxed{D}$$", "id": "1439683"}]}