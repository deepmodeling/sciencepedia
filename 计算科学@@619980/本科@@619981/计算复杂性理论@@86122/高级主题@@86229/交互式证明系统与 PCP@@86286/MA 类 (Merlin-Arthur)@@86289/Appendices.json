{"hands_on_practices": [{"introduction": "复杂性类的研究常常涉及它们的闭包性质，例如它们在并集、交集和补集等运算下是否封闭。这个练习提供了一个动手实践的机会，来证明 MA 类在交集运算下是封闭的。这里的关键在于学习如何将两个独立的 MA 协议组合成一个新协议，并定量分析新协议的完备性（completeness）和可靠性（soundness）概率如何变化。通过这个练习，你将直接应用 MA 类的核心定义来进行概率计算。[@problem_id:1452890]", "problem": "一个由语言 $L$ 表示的判定问题，如果存在一个概率多项式时间图灵机 $V$（称为验证者 Arthur）和一个多项式 $p(n)$，使得对于任意长度为 $n$ 的输入串 $x$ 都满足以下条件，则该问题属于复杂性类 Merlin-Arthur (MA)：\n1.  **完备性**：如果 $x \\in L$，则存在一个长度至多为 $p(n)$ 的证明串 $y$（由一个全能但不可信的证明者 Merlin 提供），使得 $V$ 以不小于 $2/3$ 的概率接受 $(x, y)$。\n2.  **可靠性**：如果 $x \\notin L$，对于所有长度至多为 $p(n)$ 的可能证明串 $y$，$V$ 以至多为 $1/3$ 的概率接受 $(x, y)$。\n\n考虑两个语言 $L_1$ 和 $L_2$，它们都属于 MA 类。设它们各自的验证者为 $V_1$ 和 $V_2$，它们满足上述概率的 MA 条件。为了证明交集 $L = L_1 \\cap L_2$ 也在 MA 中，我们构建了一个新协议。在此协议中，Merlin 提供一个单一的证明串 $y$，该证明串是 $L_1$ 的证明 $y_1$ 和 $L_2$ 的证明 $y_2$ 的拼接。新的验证者 $V$ 在收到输入 $x$ 和拼接的证明 $y=(y_1, y_2)$ 后，使用独立的随机比特分别运行 $V_1(x,y_1)$ 和 $V_2(x,y_2)$。验证者 $V$ 当且仅当 $V_1$ 和 $V_2$ 都接受时才接受。\n\n设 $P_C$ 为这个针对语言 $L = L_1 \\cap L_2$ 的新协议的最小完备性概率， $P_S$ 为其最大可靠性概率。计算表达式 $9 P_C - 3 P_S$ 的值。", "solution": "给定两个在 MA 类中的语言，其验证者满足完备性不小于 $2/3$ 和可靠性不大于 $1/3$。针对 $L=L_{1}\\cap L_{2}$ 的组合协议使用一个拼接的证明 $y=(y_{1},y_{2})$，并使用独立的随机比特运行 $V_{1}(x,y_{1})$ 和 $V_{2}(x,y_{2})$，当且仅当两者都接受时才接受。\n\n根据每个语言的完备性条件，对于 $x\\in L$，存在证明 $y_{1}$ 和 $y_{2}$ 使得\n$$\n\\Pr[V_{1}(x,y_{1})\\text{ accepts}] \\ge \\frac{2}{3},\\quad \\Pr[V_{2}(x,y_{2})\\text{ accepts}] \\ge \\frac{2}{3}.\n$$\n由于两次运行使用独立的随机比特，且接受事件是独立的，因此联合接受概率是两者的乘积：\n$$\n\\Pr[V\\text{ accepts }(x,y)] \\;=\\; \\Pr[V_{1}\\text{ accepts}]\\cdot \\Pr[V_{2}\\text{ accepts}] \\;\\ge\\; \\left(\\frac{2}{3}\\right)\\left(\\frac{2}{3}\\right) \\;=\\; \\frac{4}{9}.\n$$\n因此，组合协议的最小完备性概率为\n$$\nP_{C}=\\frac{4}{9}.\n$$\n\n对于可靠性，取任意 $x\\notin L=L_{1}\\cap L_{2}$。那么 $x\\notin L_{1}$ 或 $x\\notin L_{2}$ 至少有一个成立。假设 $x\\notin L_{1}$。那么对于所有的 $y_{1}$，\n$$\n\\Pr[V_{1}(x,y_{1})\\text{ accepts}] \\le \\frac{1}{3}.\n$$\n对于任何 $y_{2}$，根据 $V_{1}$ 和 $V_{2}$ 使用的随机比特的独立性，\n$$\n\\Pr[V\\text{ accepts }(x,y)] \\;=\\; \\Pr[V_{1}\\text{ accepts}]\\cdot \\Pr[V_{2}\\text{ accepts}] \\;\\le\\; \\left(\\frac{1}{3}\\right)\\cdot 1 \\;=\\; \\frac{1}{3},\n$$\n因为 $\\Pr[V_{2}\\text{ accepts}] \\le 1$。如果 $x\\notin L_{2}$，同样的上界也成立。因此，组合协议的最大可靠性概率为\n$$\nP_{S}=\\frac{1}{3}.\n$$\n\n最后，计算\n$$\n9P_{C}-3P_{S} \\;=\\; 9\\cdot \\frac{4}{9} \\;-\\; 3\\cdot \\frac{1}{3} \\;=\\; 4-1 \\;=\\; 3.\n$$", "answer": "$$\\boxed{3}$$", "id": "1452890"}, {"introduction": "继上一个关于交集的练习之后，我们现在来探讨两个 MA 语言的并集问题。与交集要求两个条件同时满足不同，并集只需要其中一个条件成立即可。这为协议设计带来了新的挑战：Merlin 如何有效地告知 Arthur 哪个条件得到了满足，同时又不损害协议的可靠性？这个练习将引导你思考协议的结构，并从几个方案中选出唯一正确的设计，从而加深对 Merlin-Arthur 协议中证明和验证之间动态关系的理解。[@problem_id:1452910]", "problem": "在计算复杂性理论中，MA 类（MA 代表 Merlin-Arthur）表示可以通过一类特定交互式协议解决的判定问题集合。此协议涉及一个计算能力有限的概率性验证者 (Arthur) 和一个全能但不可信的证明者 (Merlin)。对于一个语言 $L$ 而言，要使其属于 MA 类，其协议必须满足两个属性：\n\n1.  **完备性 (Completeness):** 对于语言中的任意输入串 $x$ ($x \\in L$)，存在一个证明串 $y$，Merlin 可以提供给 Arthur，使得 Arthur 以至少 $2/3$ 的概率接受 $x$。\n2.  **可靠性 (Soundness):** 对于不属于该语言的任意输入串 $x$ ($x \\notin L$)，无论 Merlin 提供任何证明串 $y$，Arthur 接受 $x$ 的概率至多为 $1/3$。\n\n假设我们有两个语言 $L_1$ 和 $L_2$，并且已知它们都属于 MA 类。设它们各自的多项式时间验证者分别为 $A_1$ 和 $A_2$。我们希望为这两个语言的并集 $L = L_1 \\cup L_2$ 设计一个新的 MA 协议。在为 $L$ 设计的协议中，Merlin 发送一个形式为 $y = (b, y')$ 的复合证明，其中 $b$ 是一个比特（$b \\in \\{1, 2\\}$），指示 Merlin 声称 $x$ 属于哪个语言（$L_1$ 或 $L_2$），而 $y'$ 是对所声称语言的相应证明。\n\n下列哪种新验证者 $A$ 的策略通过满足完备性和可靠性条件，为 $L = L_1 \\cup L_2$ 正确地实现了一个有效的 MA 协议？\n\nA. $A$ 检查比特 $b$。如果 $b=1$，$A$ 执行 $A_1(x, y')$ 并返回其判定结果。如果 $b=2$，$A$ 执行 $A_2(x, y')$ 并返回其判定结果。\n\nB. $A$ 忽略比特 $b$。它抛一枚均匀的硬币，设结果为 $i \\in \\{1,2\\}$。然后它执行 $A_i(x, y')$ 并返回其判定结果。\n\nC. $A$ 忽略比特 $b$。它同时执行 $A_1(x, y')$ 和 $A_2(x, y')$。当且仅当 $A_1$ 和 $A_2$ 都接受时，它才接受。\n\nD. $A$ 忽略比特 $b$。它同时执行 $A_1(x, y')$ 和 $A_2(x, y')$。如果 $A_1$ 或 $A_2$ 中至少有一个接受，它就接受。", "solution": "为了确定新验证者 $A$ 的正确策略，我们必须分析每个选项，看它是否满足 MA 类语言所需的完备性和可靠性属性。目标语言是 $L = L_1 \\cup L_2$。$L_1$ 的验证者 $A_1$ 和 $L_2$ 的验证者 $A_2$ 的完备性概率 $\\ge 2/3$，可靠性概率 $\\le 1/3$。\n\n**策略 A 的分析：**\n验证者 $A$ 遵循 Merlin 的指示比特 $b$。\n*   **完备性：** 假设输入串 $x$ 在 $L$ 中，即 $x \\in L_1$ 或 $x \\in L_2$。\n    *   情况 1：$x \\in L_1$。由于 $L_1 \\in \\text{MA}$，存在一个证明 $y_1'$，使得 $\\Pr[A_1(x, y_1') = \\text{accept}] \\ge 2/3$。一个诚实的 Merlin 想要说服 Arthur，所以他会发送证明 $y = (1, y_1')$。验证者 $A$ 将看到 $b=1$ 并运行 $A_1(x, y_1')$，以 $\\ge 2/3$ 的概率接受。\n    *   情况 2：$x \\in L_2$。类似地，存在一个证明 $y_2'$，使得 $\\Pr[A_2(x, y_2') = \\text{accept}] \\ge 2/3$。Merlin 会发送 $y = (2, y_2')$。验证者 $A$ 将看到 $b=2$ 并运行 $A_2(x, y_2')$，以 $\\ge 2/3$ 的概率接受。\n    由于对于任何 $x \\in L$，Merlin 都可以提供一个能使接受概率至少为 $2/3$ 的证明，因此完备性条件得到满足。\n*   **可靠性：** 假设输入串 $x$ 不在 $L$ 中，即 $x \\notin L_1$ 且 $x \\notin L_2$。Merlin 是不可信的，会试图欺骗 Arthur。Merlin 发送某个证明 $y=(b, y')$。\n    *   情况 1：Merlin 选择 $b=1$。验证者 $A$ 运行 $A_1(x, y')$。由于 $x \\notin L_1$，根据 $A_1$ 的可靠性属性，对于 Merlin 提供的任何证明 $y'$，$\\Pr[A_1(x, y') = \\text{accept}] \\le 1/3$。\n    *   情况 2：Merlin 选择 $b=2$。验证者 $A$ 运行 $A_2(x, y')$。由于 $x \\notin L_2$，根据 $A_2$ 的可靠性属性，对于 Merlin 提供的任何证明 $y'$，$\\Pr[A_2(x, y') = \\text{accept}] \\le 1/3$。\n    Merlin 必须选择其中一个选项。无论在哪种情况下，让 Arthur 接受的最大概率是 $1/3$。因此，对于任意 $x \\notin L$，无论 Merlin 提供任何证明 $y$，接受概率都 $\\le 1/3$。可靠性条件得到满足。\n**结论：** 策略 A 是一个有效的 MA 协议。\n\n**策略 B 的分析：**\n验证者 $A$ 忽略 $b$ 并随机选择一个验证者。\n*   **完备性：** 假设 $x \\in L_1$ 但 $x \\notin L_2$。一个诚实的 Merlin 会为 $L_1$ 提供有效的证明 $y_1'$（他可以为 $b$ 设置任何比特值，因为该比特被忽略了）。验证者 $A$ 抛硬币。\n    *   以 $1/2$ 的概率，$A$ 选择运行 $A_1(x, y_1')$。在此分支中，接受的概率 $\\ge 2/3$。\n    *   以 $1/2$ 的概率，$A$ 选择运行 $A_2(x, y_1')$。由于 $x \\notin L_2$，无论证明 $y_1'$ 是什么，在此分支中接受的概率 $\\le 1/3$。\n    总的接受概率是：\n    $\\Pr[A \\text{ accepts}] = \\frac{1}{2} \\Pr[A_1(x, y_1')=\\text{accept}] + \\frac{1}{2} \\Pr[A_2(x, y_1')=\\text{accept}]$。\n    使用边界值，这个概率大约是 $\\frac{1}{2} \\cdot \\frac{2}{3} + \\frac{1}{2} \\cdot \\frac{1}{3} = \\frac{1}{3} + \\frac{1}{6} = \\frac{1}{2}$。\n    $1/2$ 的接受概率不满足 $\\ge 2/3$ 的要求。因此，完备性条件不满足。\n\n**策略 C 的分析：**\n验证者 $A$ 仅当 $A_1$ 和 $A_2$ 都接受时才接受。\n*   **完备性：** 再次假设 $x \\in L_1$ 但 $x \\notin L_2$。Merlin 提供一个证明 $y'$。为了被接受， $A_1(x, y')$ 和 $A_2(x, y')$ 都必须接受。然而，由于 $x \\notin L_2$，无论 $y'$ 是什么，$A_2$ 接受的概率至多为 $1/3$。\n    $\\Pr[A_1 \\text{ accepts AND } A_2 \\text{ accepts}] \\le \\Pr[A_2 \\text{ accepts}] \\le 1/3$。\n    $\\le 1/3$ 的接受概率不满足 $\\ge 2/3$ 的要求。完备性条件不满足。\n\n**策略 D 的分析：**\n验证者 $A$ 如果 $A_1$ 或 $A_2$ 中至少有一个接受，它就接受。\n*   **可靠性：** 假设 $x \\notin L_1$ 且 $x \\notin L_2$。恶意的 Merlin 可以构造一个单一的证明 $y'$ 来试图欺骗任何一个验证者。如果 $A_1(x, y')$ 接受或 $A_2(x, y')$ 接受，验证者 $A$ 就会接受。我们使用概率的并集界（union bound）：\n    $\\Pr[A_1 \\text{ accepts OR } A_2 \\text{ accepts}] \\le \\Pr[A_1 \\text{ accepts}] + \\Pr[A_2 \\text{ accepts}]$。\n    由于 $x \\notin L_1$ 且 $x \\notin L_2$，对于任何证明 $y'$，我们有 $\\Pr[A_1(x, y')=\\text{accept}] \\le 1/3$ 和 $\\Pr[A_2(x, y')=\\text{accept}] \\le 1/3$。\n    因此，$\\Pr[A \\text{ accepts}] \\le 1/3 + 1/3 = 2/3$。\n    对于一个“否”实例，接受概率高达 $2/3$ 违反了可靠性条件，该条件要求概率至多为 $1/3$。可靠性条件不满足。\n\n只有策略 A 同时满足 MA 协议的完备性和可靠性属性。", "answer": "$$\\boxed{A}$$", "id": "1452910"}, {"introduction": "要全面理解一个复杂性类，研究其补类是至关重要的一步。这个练习旨在探讨 MA 和 co-MA 之间的对称关系，特别是证明者 (Merlin) 在这两种协议中的目标有何根本不同。通过一个经典的哈密顿环路问题作为具体实例，你将分析在证明一个“是”实例（属于 MA）和一个“否”实例（属于 co-MA）时，Merlin 需要提供什么样的证据。这个思想实验将澄清一个核心概念：协议的判定目标决定了证明者的任务。[@problem_id:1452866]", "problem": "考虑语言 $L_{SI}$，它由所有图的有序对 $(G_1, G_2)$ 组成，其中 $G_1$ 和 $G_2$ 是简单无向图，并且 $G_2$ 同构于 $G_1$ 的一个子图。\n\n假设为该语言设计了两个独立的交互式证明系统，两者都涉及一个计算有界的概率验证者 (Arthur) 和一个全能但不可信的证明者 (Merlin)。设一个具体实例由对 $(H, C)$ 给出，其中 $H$ 是一个有 $n$ 个顶点的图，$C$ 是 $n$ 个顶点的圈图 $C_n$。对实例 $(H, C) \\in L_{SI}$ 回答“是”，等价于判断 $H$ 是否有一个哈密顿圈。\n\n系统 1 是为语言 $L_{SI}$ 设计的一个 MA (Merlin-Arthur) 协议。\n系统 2 是为语言 $L_{SI}$ 设计的一个 co-MA 协议。\n\n在这两个系统中，Merlin 都为实例 $(H, C)$ 向 Arthur 发送一个单一的证明字符串。然后 Arthur 使用该实例和 Merlin 的证明运行其随机多项式时间算法，并决定是接受还是拒绝。\n\n下列哪个陈述最准确地描述了在每个系统中，证明者 Merlin 在为 Arthur 构建证明时的主要目标？\n\nA. 在系统 1 中，Merlin 的目标是提供一个证明，帮助说服 Arthur 相信 $H$ 不存在哈密顿圈。在系统 2 中，Merlin 的目标是提供一个证明，帮助说服 Arthur 相信 $H$ 存在哈密顿圈。\n\nB. 在系统 1 和系统 2 中，Merlin 的目标都是提供一个证明，帮助说服 Arthur 相信 $H$ 存在哈密顿圈。\n\nC. 在系统 1 中，Merlin 的目标是提供一个证明，帮助说服 Arthur 相信 $H$ 存在哈密顿圈。在系统 2 中，Merlin 的目标是提供一个证明，帮助说服 Arthur 相信 $H$ 不存在哈密顿圈。\n\nD. 在系统 1 和系统 2 中，Merlin 的目标都是提供一个证明，帮助说服 Arthur 相信 $H$ 不存在哈密顿圈。\n\nE. Merlin 的目标取决于 $H$ 是否真的有哈密顿圈。如果 H 有，他就试图证明它有；如果没有，他就试图证明它没有，而这与系统无关。", "solution": "该问题要求确定在两种不同类型的交互式证明系统（MA 和 co-MA）中，针对特定语言 $L_{SI}$ 和实例 $(H, C)$，证明者 (Merlin) 的目标是什么。关键在于理解复杂度类 MA 和 co-MA 的定义。\n\n一个 MA 协议由一个证明者 (Merlin) 向一个概率多项式时间验证者 (Arthur) 发送一个证明。验证者的决定确定了实例是否属于该语言。\n\n步骤 1：分析 Merlin 在系统 1 (MA 协议) 中的目标。\n对于一个语言 $L$，MA (Merlin-Arthur) 类的定义如下：\n- **完备性：** 如果一个实例 $x$ 在 $L$ 中 ($x \\in L$)，那么必须存在一个 Merlin 可以发送的证明 $y$，使得 Arthur 以高概率（例如，$\\ge 2/3$）接受。\n- **可靠性：** 如果一个实例 $x$ 不在 $L$ 中 ($x \\notin L$)，那么对于 Merlin 发送的任何证明 $y$，Arthur 都必须以低概率（例如，$\\le 1/3$）接受。\n\n在这个框架中，Merlin 的目标总是让 Arthur 接受。Arthur 的接受被解释为对实例是否属于该语言的“是”回答。\n对于系统 1，协议是为语言 $L_{SI}$ 设计的。Merlin 想要说服 Arthur 相信实例 $(H, C)$ 在 $L_{SI}$ 中。如问题所述，$(H, C) \\in L_{SI}$ 等价于陈述“$H$ 有一个哈密顿圈”。\n因此，在系统 1 中，Merlin 的目标是提供一个证明，帮助说服 Arthur 相信 $H$ 确实有一个哈密顿圈。\n\n步骤 2：分析 Merlin 在系统 2 (co-MA 协议) 中的目标。\nco-MA 类是其补集在 MA 中的语言类。也就是说，$L \\in \\text{co-MA}$ 当且仅当 $\\bar{L} \\in \\text{MA}$。根据定义，一个针对语言 $L$ 的 co-MA 协议，就是针对其补集 $\\bar{L}$ 的一个 MA 协议。\n\n对于系统 2，该协议是针对 $L_{SI}$ 的一个 co-MA 协议。这意味着它是一个针对语言 $\\bar{L}_{SI}$ 的 MA 协议。语言 $\\bar{L}_{SI}$ 包含所有图的有序对 $(G_1, G_2)$，其中 $G_2$ *不*同构于 $G_1$ 的一个子图。\n在这个针对 $\\bar{L}_{SI}$ 的 MA 协议中，Merlin 的目标仍然是让 Arthur 接受。然而，Arthur 的接受现在意味着该实例在 $\\bar{L}_{SI}$ 中。\n所以，Merlin 想要说服 Arthur 相信实例 $(H, C)$ 在 $\\bar{L}_{SI}$ 中。陈述 $(H, C) \\in \\bar{L}_{SI}$ 等价于“$H$ 没有哈密顿圈”。\n因此，在系统 2 中，Merlin 的目标是提供一个证明，帮助说服 Arthur 相信 $H$ 不存在哈密顿圈。\n\n步骤 3：结合结果并选择正确的选项。\n从步骤 1 可知，在系统 1 (MA) 中，Merlin 的目标是证明 $H$ 有一个哈密顿圈。\n从步骤 2 可知，在系统 2 (co-MA) 中，Merlin 的目标是证明 $H$ 不存在哈密顿圈。\n\n让我们检查给出的选项：\nA. 错误。它颠倒了系统 1 和系统 2 的目标。\nB. 错误。它声称两个系统中的目标相同，都是证明圈的存在。\nC. 正确。它指出在系统 1 中，目标是证明存在性，而在系统 2 中，目标是证明不存在性。这与我们的分析相符。\nD. 错误。它声称两个系统中的目标相同，都是证明圈的不存在性。\nE. 错误。这个选项误解了 Merlin 的角色。Merlin 的目标是由协议（MA 或 co-MA）固定的，而不是由陈述的实际真假决定的。在任何交互式协议中，Merlin 的目的都是让 Arthur 接受。“接受”意味着什么，这在 MA 和 co-MA 协议之间是不同的。\n\n因此，唯一准确描述 Merlin 在两个系统中目标的陈述是 C。", "answer": "$$\\boxed{C}$$", "id": "1452866"}]}