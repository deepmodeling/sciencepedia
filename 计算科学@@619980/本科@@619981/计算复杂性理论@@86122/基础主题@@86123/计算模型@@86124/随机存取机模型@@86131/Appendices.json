{"hands_on_practices": [{"introduction": "理论学习之后，最好的检验方法莫过于亲自动手。本节的第一个练习将带你深入随机存取机（RAM）的“大脑”，使用最基础的指令集来构建程序逻辑。这个练习的核心是模拟条件判断——这是现代编程语言中 `if` 语句的底层实现——从而让你直观地感受程序控制流是如何在机器层面被精确操纵的 [@problem_id:1440594]。通过这个实践，你将学会如何像计算机科学家一样，用最少的工具解决问题。", "problem": "一个简单的随机存取机（RAM）模型对一组寄存器 `R1, R2, R3, ...` 进行操作，这些寄存器可以存储整数值。程序是一系列从1开始编号的指令。该机器支持以下指令集：\n\n- `COPY Ri Rj`：将寄存器 `Ri` 中的整数复制到寄存器 `Rj`。\n- `ADD Ri Rj Rk`：计算 `Ri` 和 `Rj` 中整数的和，并将结果存储在 `Rk` 中。（$Rk \\leftarrow Ri + Rj$）\n- `SUB Ri Rj Rk`：计算 `Ri` 中的整数减去 `Rj` 中的整数的差，并将结果存储在 `Rk` 中。（$Rk \\leftarrow Ri - Rj$）\n- `JGTZ Ri L`：如果寄存器 `Ri` 中的整数严格大于0，则程序跳转到第 `L` 行。否则，程序按顺序执行下一条指令。\n\n当指令指针移动到一个大于程序总指令数的行号时，程序终止。\n\n假设最初，一个任意整数 `x` 被放置在寄存器 `R1` 中。所有其他寄存器（`R2`、`R3`、...）都被初始化为值0。你的任务是确定一个最短的程序，该程序能确保无论 `x` 的初始值是什么，在程序终止时，`x` 的绝对值（记为 $|x|$）都存储在寄存器 `R1` 中。\n\n这样的程序所需的最少指令数是多少？", "solution": "我们的目标是为指定的随机存取机（RAM）模型编写一个程序，用于计算最初存储在寄存器 `R1` 中的整数 `x` 的绝对值。我们需要找到所需的最少指令数。\n\n绝对值 $|x|$ 的定义是：\n- 如果 $x \\geq 0$，则 $|x| = x$。\n- 如果 $x  0$，则 $|x| = -x$。\n\n这个定义是条件性的。执行的操作取决于 `x` 的符号。因此，我们的程序必须实现这种条件逻辑。在我们的 RAM 模型中，唯一可用的条件指令是 `JGTZ Ri L`，即“如果大于零则跳转”。该指令可以区分正数（$x > 0$）和非正数（$x \\leq 0$）。\n\n让我们基于应用于 `R1`（其中存有 `x`）的 `JGTZ` 指令来分析各种情况。\n\n**情况 1：$x > 0$**\n在这种情况下，$|x| = x$。`R1` 中的值已经是正确的。程序不应对 `R1` 进行任何操作。`JGTZ R1 L` 指令将触发一次跳转。我们可以利用这次跳转来跳过任何会修改 `R1` 的指令。\n\n**情况 2：$x \\leq 0$**\n在这种情况下，`JGTZ R1 L` 不会引起跳转，程序将继续执行下一条指令。\n- 如果 $x = 0$，则 $|x| = 0$。`R1` 中的值已经是正确的。\n- 如果 $x  0$，则 $|x| = -x$。程序必须计算 $-x$ 并将其存储在 `R1` 中。\n\n操作 $-x$ 可以表示为 $0 - x$。根据问题描述，除 `R1` 外的所有寄存器都初始化为 0。我们可以使用任何其他寄存器，比如 `R2`，其初始值为 0。减法 $0 - x$ 可以通过指令 `SUB R2 R1 R1` 来实现。该指令计算 `R2 - R1` 并将结果存储在 `R1` 中。由于 `R2` 为 0 而 `R1` 为 `x`，这将导致 $R1 \\leftarrow 0 - x$，即 $-x$。\n\n注意，如果 $x$ 为 0，`SUB R2 R1 R1` 会计算 $R1 \\leftarrow 0 - 0 = 0$，这对于 $|0|$ 也是正确的。因此，单条指令 `SUB R2 R1 R1` 正确地处理了所有非正数情况（$x \\leq 0$）。\n\n现在我们可以构建一个程序。我们需要一个条件跳转来处理 $x > 0$ 的情况，以及一个减法来处理 $x \\leq 0$ 的情况。\n\n让我们尝试构建最短的程序。\n我们能用1条指令完成吗？\n- `SUB`、`ADD` 或 `COPY` 指令会无条件执行。例如，`SUB R2 R1 R1` 会错误地将 $x=5$ 变为 $-5$。\n- `JGTZ` 指令只改变程序流程；它不修改 `R1` 中的数据。\n因此，单条指令是不够的。\n\n让我们尝试构建一个2指令的程序。\n我们需要第一条指令是条件跳转。如果 $x > 0$，我们希望跳过下一条指令并终止。如果程序跳转到一个大于总指令数的行号，程序就会终止。对于一个2指令的程序，跳转到第3行将导致终止。\n\n考虑以下程序：\n1. `JGTZ R1 3`\n2. `SUB R2 R1 R1`\n\n让我们针对 `x` 的三种可能性来追踪其执行过程：\n\n- **如果 $x > 0$（例如，$x = 5$）：**\n  - 第1行：执行 `JGTZ R1 3`。由于 $R1 > 0$，程序跳转到第3行。\n  - 由于没有第3行，程序终止。\n  - `R1` 中的值保持为 `x`。最终值为 `x`，即 $|x|$。这是正确的。\n\n- **如果 $x  0$（例如，$x = -5$）：**\n  - 第1行：执行 `JGTZ R1 3`。由于 `R1` 不大于0，不执行跳转。\n  - 第2行：执行 `SUB R2 R1 R1`。`R1` 获得 `R2 - R1` 的值。最初，`R2=0` 且 `R1=x`。所以 `R1` 变为 $0 - x = -x$。对于 $x=-5$，`R1` 变为 `5`。\n  - 程序然后试图继续执行到第3行。由于没有第3行，程序终止。\n  - `R1` 中的最终值为 $-x$，即 $|x|$。这是正确的。\n\n- **如果 $x = 0$：**\n  - 第1行：执行 `JGTZ R1 3`。由于 `R1` 不大于0，不执行跳转。\n  - 第2行：执行 `SUB R2 R1 R1`。`R1` 获得 `R2 - R1` 的值，即 $0 - 0 = 0$。\n  - 程序终止。\n  - `R1` 中的最终值为 `0`，即 $|0|$。这是正确的。\n\n这个2指令的程序能为任何整数 `x` 正确计算其绝对值。既然我们已经论证了1条指令是不够的，那么所需的最少指令数就是2。", "answer": "$$\\boxed{2}$$", "id": "1440594"}, {"introduction": "在编写程序之后，下一个关键问题是：它运行得有多快？这个练习将我们的视角从程序的功能转向其执行效率，并介绍一种重要的度量方式——对数代价模型。与假设所有操作耗时相同的单位代价模型不同，对数代价模型更真实地反映了处理大数字需要更多时间的物理现实 [@problem_id:1440567]。通过计算一个具体乘法操作的成本，你将获得宝贵的实践经验，理解理论复杂性分析中成本度量的重要性。", "problem": "正在评估一款专用处理器在密码学任务中的性能。该处理器的架构基于随机存取机（RAM）模型，其计算成本采用对数成本模型来衡量。在此模型中，执行一次操作所需的时间取决于操作数的位长。一个正整数 $k$ 的位长，记为 $\\beta(k)$，是其标准二进制表示中的位数，由公式 $\\beta(k) = \\lfloor \\log_{2} k \\rfloor + 1$ 给出。\n\n该处理器有一个专用的硬件乘法器。乘以两个正整数 $A$ 和 $B$ 的时间成本（以时钟周期为单位）由它们各自位长的乘积给出：\n$$T = \\beta(A) \\cdot \\beta(B)$$\n\n正在考虑的具体操作是整数 $A = 3 \\cdot 2^{40}$ 和 $B = 5 \\cdot 2^{50}$ 的乘法。\n\n计算这次乘法的总时间成本 $T$。请用时钟周期表示你的答案。", "solution": "我们已知 RAM 的对数成本模型，其乘法时间成本定义为\n$$T=\\beta(A)\\cdot\\beta(B),$$\n其中，对于正整数 $k$，位长为 $\\beta(k)=\\lfloor \\log_{2}k\\rfloor+1$。\n\n输入为 $A=3\\cdot 2^{40}$ 和 $B=5\\cdot 2^{50}$。我们利用乘以2的幂会将二进制表示向左移动而不改变前导位的性质，因此对于正整数 $m$，\n$$\\beta\\!\\left(m\\cdot 2^{n}\\right)=\\beta(m)+n.$$\n\n计算 $\\beta(A)$：\n$$\\beta(A)=\\beta\\!\\left(3\\cdot 2^{40}\\right)=\\beta(3)+40.$$\n因为 $\\beta(3)=\\lfloor \\log_{2}3\\rfloor+1=1+1=2$，所以\n$$\\beta(A)=2+40=42.$$\n\n计算 $\\beta(B)$：\n$$\\beta(B)=\\beta\\!\\left(5\\cdot 2^{50}\\right)=\\beta(5)+50.$$\n因为 $\\beta(5)=\\lfloor \\log_{2}5\\rfloor+1=2+1=3$，所以\n$$\\beta(B)=3+50=53.$$\n\n因此，时间成本为\n$$T=\\beta(A)\\cdot\\beta(B)=42\\cdot 53.$$\n计算乘积：\n$$42\\cdot 53=(40+2)(50+3)=2000+120+100+6=2226.$$\n\n因此，总时间成本为 $2226$ 个时钟周期。", "answer": "$$\\boxed{2226}$$", "id": "1440567"}, {"introduction": "最后一个练习将所有概念——指令、程序流和内存——融为一体，揭示它们之间复杂的相互作用。我们将通过追踪一个存在内存错误的程序，来探讨其与机器内存结构（尤其是调用栈）的交互。这个实践活动将直观地展示一个看似微小的编程错误如何引发“缓冲区溢出”，一个将理论 RAM 模型与现实世界软件安全紧密相连的关键概念 [@problem_id:1440630]。", "problem": "考虑一个用于理论分析的、设计有简化架构的假设性随机存取机（RAM）。该机器具有以下规格：\n\n**架构：**\n*   **内存：**一个从 0 开始索引的、字节寻址的内存数组 `M`。对于本问题，假设每个整数值占据一个内存地址。\n*   **寄存器：**四个通用整数寄存器 `r0、r1、r2、r3`。\n*   **特殊寄存器：**一个程序计数器（`PC`），用于存放下一条要执行指令的地址；以及一个堆栈指针（`SP`），指向堆栈的栈顶元素。\n*   **堆栈：**堆栈向下增长，即从高内存地址向低内存地址增长。`SP` 寄存器始终指向最近压入值的内存地址。\n\n**指令集：**\n*   `CONST r_i, val`: 将整数常量 `val` 赋给寄存器 `r_i`。\n*   `MOV r_i, r_j`: 将寄存器 `r_j` 的值复制到 `r_i`。\n*   `ADD r_i, r_j, r_k`: 计算 `r_j + r_k` 并将结果存储在 `r_i` 中。\n*   `SUB r_i, r_j, r_k`: 计算 `r_j - r_k` 并将结果存储在 `r_i` 中。\n*   `LOAD r_i, r_j`: 从 `r_j` 指定的内存地址加载值到 `r_i`。（$r_i \\leftarrow M[r_j]$）。\n*   `STORE r_i, r_j`: 将寄存器 `r_j` 的值存储到 `r_i` 指定的内存地址。（$M[r_i] \\leftarrow r_j$）。\n*   `CALL addr`: 将返回地址（$PC+1$）压入堆栈（递减 `SP`，然后设置 $M[SP] \\leftarrow PC+1$），然后跳转到 `addr`（设置 $PC \\leftarrow addr$）。\n*   `RET`: 从堆栈中弹出返回地址到 `PC`（设置 $PC \\leftarrow M[SP]$，然后递增 `SP`）。\n*   `PUSH r_i`: 将 `r_i` 的值压入堆栈（递减 `SP`，然后设置 $M[SP] \\leftarrow r_i$）。\n*   `POP r_i`: 从栈顶弹出一个值到 `r_i`（设置 $r_i \\leftarrow M[SP]$，然后递增 `SP`）。\n*   `HALT`: 终止程序执行。\n\n**场景：**\n一个程序被加载到机器的内存中。机器的初始状态如下：\n*   `PC = 100`\n*   `SP = 1024`\n*   `r0 = 0`, `r1 = 0`, `r2 = 0`, `r3 = 0`\n*   所有其他内存位置均初始化为 0。\n\n存储在内存中的程序代码如下：\n\n```\n// Main function\n100: CALL 200\n101: HALT\n\n// Subroutine\n200: PUSH r1         // Function prologue: save caller's context\n201: MOV r1, SP      // Use r1 as a frame pointer\n202: CONST r2, 3\n203: SUB SP, SP, r2  // Allocate a 3-element buffer on the stack\n204: CONST r2, 4     // Buggy index for buffer access\n205: CONST r3, 300   // Value to write\n206: ADD r0, SP, r2  // Calculate target address: base of buffer + index\n207: STORE r0, r3    // Write value to calculated address\n208: MOV SP, r1      // Function epilogue: deallocate buffer\n209: POP r1          // Restore caller's context\n210: RET             // Return to caller\n\n// Unrelated code block\n300: CONST r0, 999\n301: HALT\n```\n\n从初始状态开始追踪该程序的执行。当 `HALT` 指令被执行时，存储在寄存器 `r0` 中的值是多少？", "solution": "我们将逐步追踪程序的执行，并记录程序计数器（`PC`）、堆栈指针（`SP`）、相关寄存器（`r0`、`r1`、`r2`、`r3`）以及关键内存位置的变化。\n\n**初始状态：**\n*   `PC = 100`\n*   `SP = 1024`\n*   `r0=0, r1=0, r2=0, r3=0`\n\n**执行追踪：**\n\n**1. `MAIN` 函数执行：**\n*   `PC=100`: `CALL 200`\n    *   `CALL` 指令首先将返回地址（$PC+1=101$）压入堆栈。\n    *   `SP` 递减：$SP = 1024 - 1 = 1023$。\n    *   存储返回地址：`M[1023] = 101`。\n    *   `PC` 被设置为子程序的地址：`PC = 200`。\n*   **状态：** `PC=200`，`SP=1023`，`M[1023]=101`。\n\n**2. `SUB` 函数序言：**\n*   `PC=200`: `PUSH r1`\n    *   `SP` 递减：$SP = 1023 - 1 = 1022$。\n    *   `r1` 的值（为 0）被存储：`M[1022] = 0`。\n*   `PC=201`: `MOV r1, SP`\n    *   `SP` 的值（1022）被复制到 `r1` 中。`r1` 现在将作为此函数调用的帧指针。`r1 = 1022`。\n*   `PC=202`: `CONST r2, 3`\n    *   寄存器 `r2` 被设置为 3。`r2 = 3`。\n*   `PC=203`: `SUB SP, SP, r2`\n    *   `SP` 被更新：$SP = SP - r2 = 1022 - 3 = 1019$。这在堆栈上分配了一个包含 3 个元素的缓冲区。\n*   **序言执行后的堆栈布局：**\n    *   `SP = 1019`。\n    *   缓冲区：`M[1019]`、`M[1020]`、`M[1021]`。\n    *   保存的 `r1`：`M[1022]`（位于 `r1`，即帧指针处）。\n    *   返回地址：`M[1023]`（位于 $r1+1$）。\n*   **状态：** `PC=204`，`SP=1019`，`r1=1022`，`r2=3`，`M[1022]=0`，`M[1023]=101`。\n\n**3. `SUB` 函数体（溢出）：**\n*   `PC=204`: `CONST r2, 4`\n    *   寄存器 `r2` 的值被覆盖为 4。这是一个错误的索引。`r2 = 4`。\n*   `PC=205`: `CONST r3, 300`\n    *   寄存器 `r3` 被设置为 300。这是将要写入的值。`r3 = 300`。\n*   `PC=206`: `ADD r0, SP, r2`\n    *   计算目标内存地址。代码意图访问缓冲区中的一个元素，其基地址为 `SP`。\n    *   $r0 = SP + r2 = 1019 + 4 = 1023$。\n*   `PC=207`: `STORE r0, r3`\n    *   `r3` 的值（300）被存储到由 `r0` 指定的内存地址（1023）。\n    *   `M[1023] = 300`。\n    *   **关键在于，这条指令将存储在 `M[1023]` 的原始返回地址（`101`）覆盖为新值 `300`。**\n*   **状态：** `PC=208`，`r0=1023`，`r3=300`，`M[1023]=300`。\n\n**4. `SUB` 函数尾声与 `RET`：**\n*   `PC=208`: `MOV SP, r1`\n    *   `SP` 被重置为帧指针的值，从而释放局部缓冲区。`SP = r1 = 1022`。\n*   `PC=209`: `POP r1`\n    *   从堆栈中恢复 `r1` 保存的值。\n    *   `r1 = M[SP] = M[1022] = 0`。\n    *   `SP` 递增：$SP = 1022 + 1 = 1023$。\n*   `PC=210`: `RET`\n    *   `RET` 指令从栈顶弹出返回地址到 `PC`。\n    *   `PC = M[SP] = M[1023]`。\n    *   由于第 3 步的覆盖操作，`M[1023]` 的值是 `300`。\n    *   因此，`PC = 300`。\n    *   `SP` 递增：$SP = 1023 + 1 = 1024$。\n*   **状态：** 控制流被劫持。程序没有返回到地址 `101`，而是跳转到了地址 `300`。`PC=300`，`SP=1024`，`r1=0`。\n\n**5. 被劫持代码的执行：**\n*   `PC=300`: `CONST r0, 999`\n    *   值 `999` 被赋给寄存器 `r0`。`r0 = 999`。\n*   `PC=301`: `HALT`\n    *   程序终止。\n\n**结论：**\n在程序终止时，寄存器 `r0` 中的最终值为 999。", "answer": "$$\\boxed{999}$$", "id": "1440630"}]}