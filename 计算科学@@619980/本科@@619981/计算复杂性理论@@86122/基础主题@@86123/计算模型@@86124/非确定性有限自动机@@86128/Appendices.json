{"hands_on_practices": [{"introduction": "在我们设计自己的非确定性有限自动机（NFA）之前，首先必须掌握它们如何处理输入。本练习将带你逐步追踪一个给定的NFA在处理字符串时的状态变化，让你亲身体验NFA如何同时探索多条计算路径。特别是，这个练习包含了$\\epsilon$转移，它揭示了NFA在不消耗任何输入符号的情况下改变状态的能力，这是理解其强大功能和复杂性的关键一步。[@problem_id:1388210]", "problem": "一位计算机科学家正在设计一个基于非确定性有限自动机 (NFA) 的简单词法分析工具，用于检测二进制数据流中的特定模式。该 NFA 由以下几个部分正式定义：\n- 状态集 $Q = \\{q_0, q_1, q_2, q_3\\}$。\n- 输入字母表 $\\Sigma = \\{0, 1\\}$。\n- 起始状态 $q_{start} = q_0$。\n- 接受状态集 $F = \\{q_3\\}$。\n\n转移函数 $\\delta: Q \\times (\\Sigma \\cup \\{\\epsilon\\}) \\to \\mathcal{P}(Q)$，其中 $\\mathcal{P}(Q)$ 是 $Q$ 的幂集，$\\epsilon$ 表示空字符串，由以下规则表给出。注意，如果某个状态-输入对未在表中列出，其转移将指向空集 $\\emptyset$。\n\n- $\\delta(q_0, 0) = \\{q_0\\}$\n- $\\delta(q_0, 1) = \\{q_0, q_1\\}$\n- $\\delta(q_1, 0) = \\{q_2\\}$\n- $\\delta(q_1, \\epsilon) = \\{q_2\\}$\n- $\\delta(q_2, 1) = \\{q_3\\}$\n- $\\delta(q_3, 0) = \\{q_3\\}$\n- $\\delta(q_3, 1) = \\{q_3\\}$\n\n给定输入字符串 `101`，确定自动机在处理完整个字符串后可能处于的所有状态的集合。从以下选项中选择正确的集合。\n\nA. $\\{q_0, q_1, q_3\\}$\n\nB. $\\{q_0, q_1, q_2, q_3\\}$\n\nC. $\\{q_3\\}$\n\nD. $\\{q_0, q_2\\}$\n\nE. $\\{q_0, q_1, q_2\\}$", "solution": "对于一个带有 $\\epsilon$-转移的 NFA，在每一步中，我们先计算当前状态集的 $\\epsilon$-闭包，然后根据输入符号进行转移，最后再次计算 $\\epsilon$-闭包。设 $\\text{E}(S)$ 表示集合 $S$ 的 $\\epsilon$-闭包。未指定的转移指向空集。\n\n初始闭包：\n$$\nS_{0}=\\text{E}(\\{q_{0}\\})=\\{q_{0}\\}\n$$\n\n读取第一个符号 $1$ 后：\n$$\nT_{1}=\\bigcup_{q\\in S_{0}}\\delta(q,1)=\\delta(q_{0},1)=\\{q_{0},q_{1}\\}\n$$\n$$\nS_{1}=\\text{E}(T_{1})=\\{q_{0},q_{1}\\}\\cup\\delta(q_{1},\\epsilon)=\\{q_{0},q_{1},q_{2}\\}\n$$\n\n读取第二个符号 $0$ 后：\n$$\nT_{2}=\\bigcup_{q\\in S_{1}}\\delta(q,0)=\\delta(q_{0},0)\\cup\\delta(q_{1},0)\\cup\\delta(q_{2},0)=\\{q_{0}\\}\\cup\\{q_{2}\\}\\cup\\emptyset=\\{q_{0},q_{2}\\}\n$$\n$$\nS_{2}=\\text{E}(T_{2})=\\{q_{0},q_{2}\\}\n$$\n\n读取第三个符号 $1$ 后：\n$$\nT_{3}=\\bigcup_{q\\in S_{2}}\\delta(q,1)=\\delta(q_{0},1)\\cup\\delta(q_{2},1)=\\{q_{0},q_{1}\\}\\cup\\{q_{3}\\}=\\{q_{0},q_{1},q_{3}\\}\n$$\n$$\nS_{3}=\\text{E}(T_{3})=\\{q_{0},q_{1},q_{3}\\}\\cup\\delta(q_{1},\\epsilon)=\\{q_{0},q_{1},q_{2},q_{3}\\}\n$$\n\n因此，在处理完整个字符串 $101$ 后，可能的状态集是 $\\{q_{0},q_{1},q_{2},q_{3}\\}$，这对应于选项 B。", "answer": "$$\\boxed{B}$$", "id": "1388210"}, {"introduction": "理解了NFA的运行机制后，现在让我们来亲手设计一个。这个练习要求你构建一个NFA来识别所有以特定子串“ab”结尾的字符串，这是一个经典的模式匹配问题。通过这个实践，你将能深刻体会到非确定性的核心优势——“猜测”能力，即NFA如何利用它来简化状态和转移，从而高效地解决在确定性模型中可能需要更复杂逻辑的问题。[@problem_id:1388241]", "problem": "在理论计算机科学领域，非确定性有限自动机（Nondeterministic Finite Automaton, NFA）是一种用于识别文本字符串中模式的计算模型。一个 NFA 由一个五元组 $M = (Q, \\Sigma, \\delta, q_0, F)$ 形式化定义，其中：\n- $Q$ 是一个有限的状态集。\n- $\\Sigma$ 是一个有限的输入符号集，称为字母表。\n- $\\delta: Q \\times \\Sigma \\to \\mathcal{P}(Q)$ 是转移函数，其中 $\\mathcal{P}(Q)$ 是 $Q$ 的幂集。\n- $q_0 \\in Q$ 是起始状态。\n- $F \\subseteq Q$ 是最终（或接受）状态的集合。\n\n一个 NFA 接受一个字符串，是指从起始状态 $q_0$ 出发，在处理完整个字符串后，存在至少一个转移序列能够到达 $F$ 中的某个状态。\n\n考虑语言 $L$，它包含所有在字母表 $\\Sigma = \\{a, b\\}$ 上以子串 'ab' 结尾的字符串。以下哪种形式化描述正确地表示了一个能精确接受语言 $L$ 的 NFA？在所有选项中，状态集均为 $Q=\\{q_0, q_1, q_2\\}$，字母表为 $\\Sigma = \\{a, b\\}$，起始状态为 $q_0$。未明确定义的转移都假定映射到空集 $\\emptyset$。\n\nA. $F = \\{q_2\\}$，且转移函数 $\\delta$ 定义为：\n   - $\\delta(q_0, a) = \\{q_0, q_1\\}$\n   - $\\delta(q_0, b) = \\{q_0\\}$\n   - $\\delta(q_1, b) = \\{q_2\\}$\n\nB. $F = \\{q_2\\}$，且转移函数 $\\delta$ 定义为：\n   - $\\delta(q_0, a) = \\{q_1\\}$\n   - $\\delta(q_0, b) = \\{q_0\\}$\n   - $\\delta(q_1, b) = \\{q_2\\}$\n\nC. $F = \\{q_2\\}$，且转移函数 $\\delta$ 定义为：\n   - $\\delta(q_0, a) = \\{q_0, q_1\\}$\n   - $\\delta(q_0, b) = \\{q_0\\}$\n   - $\\delta(q_1, b) = \\{q_2\\}$\n   - $\\delta(q_2, a) = \\{q_2\\}$\n   - $\\delta(q_2, b) = \\{q_2\\}$\n\nD. $F = \\{q_0, q_2\\}$，且转移函数 $\\delta$ 定义为：\n   - $\\delta(q_0, a) = \\{q_0, q_1\\}$\n   - $\\delta(q_0, b) = \\{q_0\\}$\n   - $\\delta(q_1, b) = \\{q_2\\}$", "solution": "问题要求我们找出一个能够接受语言 $L$ 的非确定性有限自动机（NFA），该语言 $L$ 包含所有在字母表 $\\Sigma = \\{a, b\\}$ 上以子串 'ab' 结尾的字符串。我们先分析该语言的特性，然后评估每个选项。\n\n语言 $L$ 包括像 \"ab\"、\"aab\"、\"bab\" 和 \"abbab\" 这样的字符串。它不包括空串 $\\epsilon$、\"a\"、\"b\"、\"ba\" 或 \"aba\" 等字符串。用于该语言的 NFA 必须能够处理任意前缀，然后识别出结尾的 'ab' 序列。\n\n让我们逐一分析每个选项：\n\n**选项A分析：**\n- $Q = \\{q_0, q_1, q_2\\}$，起始状态 $q_0$，$F = \\{q_2\\}$。\n- 转移：$\\delta(q_0, a) = \\{q_0, q_1\\}$，$\\delta(q_0, b) = \\{q_0\\}$，$\\delta(q_1, b) = \\{q_2\\}$。\n\n这个 NFA 的逻辑可以解释如下：\n- 状态 $q_0$ 是初始状态，也是一个“搜索”状态。它消耗任意的 'a' 和 'b' 序列。循环 $\\delta(q_0, a) \\ni q_0$ 和 $\\delta(q_0, b) = \\{q_0\\}$ 允许自动机在处理任何前缀时都保持在该状态。\n- 转移 $\\delta(q_0, a) \\ni q_1$ 是非确定性的。当 NFA 在状态 $q_0$ 读入一个 'a' 时，它可以“猜测”这个 'a' 可能是期望的后缀 \"ab\" 的开始。它会派生一条新的计算路径转移到状态 $q_1$。\n- 状态 $q_1$ 代表了这样一种假设：最后看到的字符是 \"ab\" 中的 'a'。\n- 如果下一个字符是 'b'，转移 $\\delta(q_1, b) = \\{q_2\\}$ 会将这条路径引向最终状态 $q_2$。如果字符串在此结束，则该字符串被接受。\n- 如果在状态 $q_1$ 读入任何其他字符（例如 'a'），或者在状态 $q_2$ 读入任何字符，该计算路径会因为没有定义相应的转移而终止。\n\n让我们用一些字符串来测试这个 NFA：\n- 字符串 \"aab\"：\n    1. 从 $q_0$ 开始。读入 'a'。$\\delta(q_0, a) = \\{q_0, q_1\\}$。NFA 现在处于状态集 $\\{q_0, q_1\\}$ 中。\n    2. 读入 'a'。从 $q_0$ 出发，$\\delta(q_0, a) = \\{q_0, q_1\\}$。从 $q_1$ 出发，$\\delta(q_1, a) = \\emptyset$。结果状态的并集为 $\\{q_0, q_1\\} \\cup \\emptyset = \\{q_0, q_1\\}$。NFA 处于状态 $\\{q_0, q_1\\}$。\n    3. 读入 'b'。从 $q_0$ 出发，$\\delta(q_0, b) = \\{q_0\\}$。从 $q_1$ 出发，$\\delta(q_1, b) = \\{q_2\\}$。结果状态的并集为 $\\{q_0\\} \\cup \\{q_2\\} = \\{q_0, q_2\\}$。\n    4. 字符串结束。最终状态集为 $\\{q_0, q_2\\}$。由于该集合包含一个最终状态（$q_2 \\in F$），字符串 \"aab\" 被接受。正确。\n- 字符串 \"aba\"：\n    1. 从 $q_0$ 开始。读入 'a'。状态为 $\\{q_0, q_1\\}$。\n    2. 读入 'b'。从 $q_0 \\to \\{q_0\\}$，从 $q_1 \\to \\{q_2\\}$。状态为 $\\{q_0, q_2\\}$。\n    3. 读入 'a'。从 $q_0 \\to \\{q_0, q_1\\}$，从 $q_2 \\to \\emptyset$。状态为 $\\{q_0, q_1\\}$。\n    4. 字符串结束。最终状态集为 $\\{q_0, q_1\\}$。该集合不包含 $F$ 中的任何状态。字符串 \"aba\" 被拒绝。正确。\n这个构造正确地接受了所有以 \"ab\" 结尾的字符串，并拒绝了所有其他字符串。因此，选项 A 是正确答案。\n\n**选项B分析：**\n- $F = \\{q_2\\}$，$\\delta(q_0, a) = \\{q_1\\}$，$\\delta(q_0, b) = \\{q_0\\}$，$\\delta(q_1, b) = \\{q_2\\}$。\n这个 NFA 的转移是确定性的（每个都映射到单元素集或空集）。问题在于转移 $\\delta(q_0, a) = \\{q_1\\}$。一旦读入一个 'a'，自动机必须转移到 $q_1$，并且再也无法返回 $q_0$。\n- 我们测试 \"aab\"。从 $q_0$ 开始。读入 'a'。转到 $q_1$。读入 'a'。$\\delta(q_1, a) = \\emptyset$。计算路径在没有到达最终状态的情况下终止。字符串 \"aab\" 被拒绝，但它应该被接受。因此，选项 B 是不正确的。这个 NFA 只接受形式为 $b^k ab$（其中 $k \\ge 0$）的字符串。\n\n**选项C分析：**\n- $F = \\{q_2\\}$。这个 NFA 与选项 A 类似，但在最终状态 $q_2$ 上增加了自循环：$\\delta(q_2, a) = \\{q_2\\}$ 和 $\\delta(q_2, b) = \\{q_2\\}$。\n这些循环意味着一旦自动机到达最终状态 $q_2$（即，一旦它看到了一个 \"ab\" 子串），无论后面跟随什么字符，它都将保持在那个最终状态。\n- 我们测试 \"aba\"。\n    1. 从 $q_0$ 开始。读入 'a'。状态为 $\\{q_0, q_1\\}$。\n    2. 读入 'b'。从 $q_0 \\to \\{q_0\\}$，从 $q_1 \\to \\{q_2\\}$。状态为 $\\{q_0, q_2\\}$。\n    3. 读入 'a'。从 $q_0 \\to \\{q_0, q_1\\}$，从 $q_2 \\to \\{q_2\\}$。状态为 $\\{q_0, q_1, q_2\\}$。\n    4. 字符串结束。最终状态集包含 $q_2 \\in F$。字符串 \"aba\" 被接受。这是不正确的，因为 \"aba\" 并不以 \"ab\" 结尾。这个 NFA 接受任何*包含* \"ab\" 作为子串的字符串。因此，选项 C 是不正确的。\n\n**选项D分析：**\n- $F = \\{q_0, q_2\\}$。这个 NFA 与选项 A 中的正确 NFA 具有相同的转移，但最终状态集不同。在这里，起始状态 $q_0$ 也是一个最终状态。\n因为 $q_0$ 是一个最终状态，所以空串 $\\epsilon$ 被接受，这是不正确的。此外，考虑转移 $\\delta(q_0, a) \\ni q_0$ 和 $\\delta(q_0, b) = \\{q_0\\}$。对于*任何*输入字符串都存在一条仅停留在状态 $q_0$ 的路径。由于 $q_0$ 是一个接受状态，这条路径将导致该字符串被接受。例如，对于字符串 \"b\"，自动机可以沿着路径 $q_0 \\xrightarrow{b} q_0$ 最终停留在最终状态。因此，\"b\" 被接受。这是不正确的。这个 NFA 接受 $\\Sigma^*$ 中的所有字符串。因此，选项 D 是不正确的。\n\n根据以上分析，只有选项 A 正确地描述了用于指定语言的 NFA。", "answer": "$$\\boxed{A}$$", "id": "1388241"}, {"introduction": "NFA和DFA之间的一个关键区别在于它们对语言求补运算的处理方式。本练习通过一个具体的反例，揭示了一个常见的误区：简单地翻转NFA的接受状态并不能得到其补语言的自动机。这个思想实验将迫使你思考NFA接受条件的本质——“存在一条接受路径”，并理解为什么这种存在性逻辑使得补集操作远比在DFA中复杂。[@problem_id:1432814]", "problem": "一个字母表 $\\Sigma = \\{a, b\\}$ 上的字符串 $w$ 可以被编码为一个正整数。我们定义一个编码函数 $E(w)$，它将字符串解释为一个三进制数，其中字符 `a` 映射到数字 1，字符 `b` 映射到数字 2。字符串从左到右读取，分别对应于最高有效位到最低有效位。例如，字符串 'ba' 被编码为 $E(\\text{\"ba\"}) = (21)_3 = 2 \\times 3^1 + 1 \\times 3^0 = 7$。\n\n现在，考虑一个记为 $M$ 的非确定性有限自动机（NFA），它由五元组 $(Q, \\Sigma, \\delta, q_s, F)$ 定义，其中：\n- 状态集 $Q$ 为 $\\{q_0, q_1, q_2\\}$。\n- 输入字母表 $\\Sigma$ 为 $\\{a, b\\}$。\n- 转移函数 $\\delta: Q \\times \\Sigma \\to \\mathcal{P}(Q)$，其中 $\\mathcal{P}(Q)$ 是 $Q$ 的幂集，由以下非空转移给出：\n    - $\\delta(q_0, a) = \\{q_1\\}$\n    - $\\delta(q_1, b) = \\{q_0, q_2\\}$\n    - 所有其他转移 $\\delta(q, \\sigma)$ 的结果均为空集 $\\emptyset$。\n- 开始状态 $q_s$ 为 $q_0$。\n- 最终（或接受）状态集 $F$ 为 $\\{q_2\\}$。\n\n设 $L(M)$ 为 NFA $M$ 所接受的语言。考虑第二个 NFA $M'$，它是通过反转 $M$ 的最终状态集而构造的。形式上，$M' = (Q, \\Sigma, \\delta, q_s, F')$，其中 $F' = Q \\setminus F$。\n\n众所周知，这种状态反转过程对于 NFA 而言，并不能计算出其补集语言。为证明这一点，必须存在至少一个同时被 $M$ 和 $M'$ 接受的非空字符串。请找出最短的这样一个非空字符串 $w$，并提供其十进制整数编码 $E(w)$。", "solution": "我们分析 NFA $M=(Q,\\Sigma,\\delta,q_{s},F)$，其中 $Q=\\{q_{0},q_{1},q_{2}\\}$, $\\Sigma=\\{a,b\\}$, $q_{s}=q_{0}$, $F=\\{q_{2}\\}$，且唯一的非空转移为\n$$\n\\delta(q_{0},a)=\\{q_{1}\\},\\quad \\delta(q_{1},b)=\\{q_{0},q_{2}\\},\n$$\n所有其他 $\\delta(q,\\sigma)=\\emptyset$。\n\n从这些转移中可以看出：\n- 从 $q_{0}$ 出发，唯一可能的移动是在输入 $a$ 时，转移到 $q_{1}$。\n- 从 $q_{1}$ 出发，唯一可能的移动是在输入 $b$ 时，转移到 $q_{0}$ 或 $q_{2}$。\n- 从 $q_{2}$ 出发，对于 $a$ 或 $b$ 都没有出向的转移。\n\n因此，在任何成功的路径上，输入必须以 $a$ 开始，然后是 $a,b,a,b,\\ldots$ 交替出现。在 $M$ 中被接受，要求在处理完整个输入后，自动机处于状态 $q_2$。而状态 $q_2$ 只能从 $q_1$ 在读取一个 $b$ 后到达，并且这必须是最后一个符号，因为 $q_2$ 没有出向转移。因此，$M$ 的语言是\n$$\nL(M)=\\{(ab)^{k}\\mid k\\in\\mathbb{N},\\ k\\geq 1\\}.\n$$\n\n现在考虑 $M'=(Q,\\Sigma,\\delta,q_{s},F')$，其中 $F'=Q\\setminus F=\\{q_{0},q_{1}\\}$。一个字符串被 $M'$ 接受，当且仅当存在至少一条路径，在处理完整个输入后，结束于状态 $q_0$ 或 $q_1$。\n\n我们寻找同时被 $M$ 和 $M'$ 接受的最短非空字符串 $w$。对于长度为 1 的字符串：\n- $w=a$：唯一的路径是 $q_{0}\\xrightarrow{a}q_{1}$，其终点不在 $F$ 中，所以 $a\\notin L(M)$；终点在 $F'$ 中 ($q_1 \\in F'$)，所以 $a\\in L(M')$。\n- $w=b$：从 $q_0$ 没有关于 $b$ 的转移，所以 $b\\notin L(M)$ 并且 $b\\notin L(M')$。\n\n因此，没有长度为 1 的字符串同时属于这两种语言。考虑 $w=ab$：\n- 对于 $M$，存在路径 $q_{0}\\xrightarrow{a}q_{1}\\xrightarrow{b}q_{2}$，其终点为 $q_{2}\\in F$，所以 $ab\\in L(M)$。\n- 对于 $M'$，存在路径 $q_{0}\\xrightarrow{a}q_{1}\\xrightarrow{b}q_{0}$，其终点为 $q_{0}\\in F'$，所以 $ab\\in L(M')$。\n\n没有其他长度为 2 的字符串能够被处理并达到接受状态，而我们已经排除了长度为 1 的情况。因此，被两者同时接受的最短非空字符串是 $w=ab$。\n\n最后，计算其在 $E$ 下的编码：将 $a\\mapsto 1$，$b\\mapsto 2$，并在三进制下进行解释，最左边的字符为最高有效位。因此\n$$\nE(ab)=1\\cdot 3^{1}+2\\cdot 3^{0}=3+2=5.\n$$", "answer": "$$\\boxed{5}$$", "id": "1432814"}]}