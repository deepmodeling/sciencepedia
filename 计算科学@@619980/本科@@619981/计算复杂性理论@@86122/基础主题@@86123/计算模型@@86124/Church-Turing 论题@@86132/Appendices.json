{"hands_on_practices": [{"introduction": "为了真正理解丘奇-图灵论题，我们首先需要搞清楚是什么让图灵机如此强大。本练习将通过一个经典的例子来探讨计算能力层级中的一个关键区别：有界内存与无界内存。通过分析为何一个简单的有限状态自动机（FSA）无法识别语言 $L=\\{0^k 1^k \\mid k \\ge 1\\}$，你将深刻体会到图灵机的无限纸带所提供的根本性优势 [@problem_id:1405449]。", "problem": "在丘奇-图灵论题的背景下，该论题假设图灵机（TM）可以计算任何具有算法的函数，我们通常将图灵机与更简单的计算模型进行比较，以理解计算能力的层级。\n\n一位初级软件工程师被分配了一项数据验证任务。任务是为字母表 $\\Sigma = \\{0, 1\\}$ 上的语言 $L$ 构建一个识别器。该语言定义为 $L = \\{0^k 1^k \\mid k \\ge 1\\}$，由一个或多个 '0' 后跟等量 '1' 的所有字符串组成。例如，'01'、'0011' 和 '000111' 属于 $L$，而 '011'、'001' 和 '10' 则不属于。\n\n该工程师首先尝试使用有限状态自动机（FSA），也称为有限自动机，来实现这个识别器。经过多次尝试，他们得出结论，无法为该任务构建任何FSA。下列哪个陈述提供了最根本的原因，解释了为什么FSA无法识别语言 $L$，从而说明了为什么它是一种比图灵机能力更弱的计算模型？\n\nA. FSA由有限个状态定义。为了识别 $L$，机器必须记住它已处理的 '0' 的确切数量，这个数量可以是任意大的。FSA的有限状态只提供了有限的内存，不足以完成这种无界计数任务。相比之下，图灵机可以使用其无限长的纸带作为无界内存。\n\nB. 语言 $L$ 本质上是非确定性的，因为 $k$ 的值是事先未知的。标准的确定性有限状态自动机无法处理这一点，虽然非确定性有限状态自动机（NFA）更强大，但只有图灵机才足够强大，以解决 $L$ 所需的无界非确定性问题。\n\nC. FSA的主要限制是其读写头只能在输入上单向移动。图灵机之所以能成功，是因为其读写头是双向的，允许它在 '0' 块和 '1' 块之间来回移动，以确认它们的数量相等。\n\nD. 图灵机可以识别 $L$，因为它能解决该特定语言的停机问题，而FSA不能。FSA的主要失败点在于它无法确定在读取 '0' 之后是否应该停机。\n\nE. FSA之所以失败，是因为它不能写入或修改其输入。图灵机可以解决这个问题，因为它具有写入能力，允许它在匹配每个 '0' 和相应的 '1' 时做标记，从而跟踪计数。", "solution": "我们通过证明语言 $L=\\{0^{k}1^{k}\\mid k\\ge 1\\}$ 不是正则语言，来形式化地说明有限状态自动机（FSA）的局限性，这意味着没有FSA可以识别它。设 $M=(Q,\\Sigma,\\delta,q_{0},F)$ 是字母表 $\\Sigma=\\{0,1\\}$ 上的任意一个FSA，其状态数为 $|Q|=n$。考虑字符串 $w=0^{n}1^{n}\\in L$。当 $M$ 读取前 $n$ 个符号 $0^{n}$ 时，它会访问 $n+1$ 个状态（包括读取任何符号之前的起始状态），因此根据鸽巢原理，存在索引 $0\\le i<j\\le n$ 使得读取 $0^{i}$ 后达到的状态与读取 $0^{j}$ 后达到的状态相同。设 $p=j-i>0$。那么，对于任何整数 $t\\ge 0$，在任意形如 $0^{i}(0^{p})^{t}0^{n-j}1^{n}$ 的字符串上进行计算，在处理完 '0' 块后所达到的状态将与处理 $w$ 时完全相同，因此在处理后续的 $1^{n}$ 时也将遵循相同的状态转换。特别地，如果 $w$ 被接受，那么\n$$\nw_{0}=0^{i}(0^{p})^{0}0^{n-j}1^{n}=0^{n-p}1^{n}\n$$\n也将被接受。但 $0^{n-p}1^{n}\\notin L$ ，因为它含有的 '0' 少于 '1'。这个矛盾表明没有FSA能精确地接受 $L$，即 $L$ 不是正则语言。\n\n这个证明所揭示的根本原因是，识别 $L$ 需要记住一个无界的 '0' 的数量，以便与 '1' 的数量进行比较，而FSA只有有限个状态，因此只有有限的内存，不足以进行无界计数。相比之下，图灵机（TM）可以使用其无限长的纸带存储任意大的计数值，因此可以识别 $L$。\n\n因此，在给定的陈述中，最根本和正确的原因是FSA只有有限内存，无法执行无界计数，而图灵机可以；这对应于选项A。其他选项不正确的原因如下：非确定性（选项B）并不增加正则语言的计算能力，因为确定性有限自动机（DFA）和非确定性有限自动机（NFA）识别相同的语言类别；读写头方向（选项C）不是根本原因，因为双向有限自动机与单向有限自动机具有相同的能力；停机问题（选项D）与识别 $L$ 无关；写入能力（选项E）不是核心问题，因为需要的是无界内存，而不仅仅是写入能力（例如，带有堆栈的下推自动机可以识别 $L$ 而无需在输入带上写入）。", "answer": "$$\\boxed{A}$$", "id": "1405449"}, {"introduction": "丘奇-图灵论题的核心论点之一是，所有“足够强大”的计算模型在计算能力上都是等价的。这个练习将让你思考“等价”在实践中意味着什么。我们将探讨一个看似截然不同的设备——一个带有两个栈的下推自动机（2-PDA）——如何能完美地模拟一个图灵机，从而为该论题的普适性提供了有力的证据 [@problem_id:1405422]。", "problem": "丘奇-图灵论题断言，任何可由算法计算的函数都可以由图灵机（TM）计算。这表明所有足够强大的计算模型都是等价的。双栈下推自动机（2-PDA）就是这样一种模型，它是一种配备了两个独立栈的有限自动机，每个栈都具有标准的弹出（pop）、压入（push）和读栈顶（read-top）操作。图灵机和双栈下推自动机的计算等价性是计算理论中的一个基石性成果，它证明了在标准下推自动机上增加第二个栈会将其计算能力提升到与图灵机等价的水平。\n\n这种等价性是通过证明这两种机器可以相互模拟来建立的。考虑用一个双栈下推自动机来模拟一个标准的单带图灵机。以下哪个陈述最准确且有效地描述了2-PDA模拟TM的核心机制？\n\nA. 一个栈用于存储图灵机带子上的全部非空内容。第二个栈用于存储图灵机读写头的当前位置，该位置通过栈上符号的数量（例如，以一元制）进行编码。\n\nB. 两个栈以读/写分离的方式工作。一个栈被指定为“读栈”，2-PDA可以从中读取带子符号；第二个栈是“写栈”，2-PDA向其上压入要写入带子的新符号。\n\nC. 两个栈用于表示图灵机的带子，概念上在读写头的当前位置处被分割。一个栈存储读写头左侧的带子部分，另一个栈存储从读写头当前位置到右侧的带子部分。移动图灵机读写头对应于从一个栈弹出一个符号并将其压入另一个栈。\n\nD. 2-PDA在根本上比图灵机弱。虽然比单栈自动机更强大，但栈固有的后进先出（LIFO）特性使其无法模拟图灵机在带子上自由地向任一方向移动到任意位置的能力。\n\nE. 第一个栈用于模拟图灵机的带子。第二个栈作为控制栈，保存状态转移和写入符号的历史记录，从而允许2-PDA回溯并探索不同的计算分支。", "solution": "我们比较双栈下推自动机（2-PDA）模拟图灵机（TM）的能力和一种标准模拟策略。\n\n一个单带图灵机的格局可以表示为一个三元组，包括当前状态、带子内容和读写头位置。设带字母表为 $\\Gamma$，空白符号为 $\\sqcup$，瞬时描述为一个字符串 $u a v$，其中 $u \\in \\Gamma^{*}$ 是读写头左侧的有限内容，$a \\in \\Gamma$ 是读写头正下方的符号，$v \\in \\Gamma^{*}$ 是读写头右侧的有限内容，其后是隐含的无限空白。2-PDA使用两个栈 $L$ 和 $R$ 来编码读写头周围的带子：\n$$\nL = u^{\\text{rev}}, \\quad R = a v,\n$$\n其中 $u^{\\text{rev}}$ 表示 $u$ 的反转。因此，$L$ 的栈顶保存着读写头紧左侧的符号，$R$ 的栈顶保存着读写头正下方的符号。如果一侧为空，2-PDA将缺失的栈顶视作 $\\sqcup$。\n\n2-PDA一次模拟一步TM的转移。TM的一步转移具有如下形式：\n$$\n\\delta(q, a) = (q', b, D),\n$$\n意思是：在状态 $q$ 下读取到 $a$，则写入 $b$，向方向 $D \\in \\{\\text{L}, \\text{R}\\}$ 移动，并进入状态 $q'$。\n\n2-PDA执行以下操作来模拟这样一步：\n\n1. 读取读写头下的符号：将空栈顶视为 $\\sqcup$ 以确保 $R$ 非空；读写头下的符号是 $\\text{top}(R)$。\n\n2. 写入操作：通过弹出 $\\text{top}(R)$ 并将 $b$ 压入 $R$ 来将读写头下的符号替换为 $b$。\n\n3. 读写头移动：\n- 如果 $D = \\text{R}$，则将读写头向右移动一格，方法是弹出 $R$ 的（新）栈顶（即刚写入的 $b$）并将其压入 $L$，从而使 $R$ 上的下一个符号成为新的读写头下符号；如果 $R$ 变空，则将 $\\sqcup$ 压入 $R$ 以代表右侧的无限空白。\n- 如果 $D = \\text{L}$，则将读写头向左移动一格，方法是弹出 $L$ 的栈顶（空栈顶视为 $\\sqcup$）并将其压入 $R$，从而使其成为新的读写头下符号；如果 $L$ 变空，则读写头的左侧被隐式地视为空白。\n\n这个方案仅使用两个栈上的后进先出（LIFO）操作就精确地捕捉了图灵机的双向读写头移动和读/写能力：移动读写头对应于从一个栈弹出并压入另一个栈，而写入则对应于修改代表读写头位置的右栈的栈顶符号。\n\n相比之下：\n- 使用一个栈存储整个带子，另一个作为一元制读写头位置计数器（选项A），在没有随机访问能力的情况下不允许在读写头处进行局部覆写，而2-PDA缺乏这种能力。\n- 将读和写分离到不同栈上（选项B）无法模拟图灵机带子的双向移动和局部覆写结构。\n- 声称2-PDA比TM弱（选项D）是错误的；两个栈在计算上与TM等价。\n- 使用第二个栈进行回溯控制（选项E）是不必要的，也未能捕捉到核心的带子分割机制；对于确定性图灵机，该模拟是确定性的，并不依赖于搜索历史。\n\n因此，准确的核心机制是在读写头处分割带子，将左边部分反向存储在一个栈中，将当前单元格加上右边部分存在另一个栈中，并将读写头移动模拟为栈之间的传输。这正是选项C所描述的。", "answer": "$$\\boxed{C}$$", "id": "1405422"}, {"introduction": "丘奇-图灵论题不仅定义了什么是可计算的，也揭示了某些明确定义的问题是根本“不可计算”的。本练习将介绍著名的“忙碌的海狸”（Busy Beaver）函数 $\\Sigma(n)$。通过一个巧妙的逻辑悖论，你将证明不存在任何图灵机可以计算此函数，从而揭示算法计算的深刻局限性 [@problem_id:1405440]。", "problem": "丘奇-图灵论题断言，任何能通过有效过程计算的函数，都可以由图灵机计算。该论题的一个关键推论是，存在定义明确但不可计算的函数。其中一个最著名的例子是忙碌的海狸函数 $\\Sigma(n)$，其定义为：一个会停机的、$n$ 状态、2 符号（其中一个是空白符）的图灵机在停机前，在初始为空白的纸带上所能写入的‘1’的最大数量。$\\Sigma(n)$ 的不可计算性可以通过反证法来证明。\n\n考虑以下一个我们称之为 $M_{paradox}$ 的图灵机的假想构造：\n\n首先，假设存在一个假想的图灵机 $M_{\\Sigma}$，它能计算忙碌的海狸函数 $\\Sigma(n)$。这台机器 $M_{\\Sigma}$ 从纸带上读取整数 $n$ 作为输入，在完成计算后，它会在纸带上写入整数值 $\\Sigma(n)$ 并停机。设这台机器 $M_{\\Sigma}$ 的状态数为一个固定常数 $c$。\n\n现在，我们通过将 $M_{\\Sigma}$ 的功能与其他组件相结合来构造机器 $M_{paradox}$。机器 $M_{paradox}$ 被设计用于处理一个硬编码在其结构中的值 $N$。$M_{paradox}$ 的完整操作序列如下：\n1.  一个子机器 $M_{write}$ 将整数 $N$ 写入纸带。该组件需要固定数量的状态 $c_{write}$。\n2.  然后执行机器 $M_{\\Sigma}$（它有 $c$ 个状态），使用纸带上的值 $N$ 作为其输入来计算 $\\Sigma(N)$。\n3.  最后一个子机器 $M_{increment}$ 从纸带上读取值 $\\Sigma(N)$，然后在停机前，在纸带的一个空白区域上写入总共 $\\Sigma(N) + 1$ 个‘1’。该组件需要固定数量的状态 $c_{inc}$。\n\n整个机器 $M_{paradox}$ 的总状态数是其各组成部分状态数的总和，因此其状态数为 $N_{total} = c_{write} + c + c_{inc}$。为了制造悖论，操作步骤中使用的硬编码整数 $N$ 被设定为等于 $M_{paradox}$ 自身总状态数。也就是说，我们设定 $N = N_{total}$。已知来自非预言机组件的额外状态总和为 $c_{write} + c_{inc} = 38$。\n\n这个构造——一个有 $N_{total}$ 个状态、被设计用来写入 $\\Sigma(N_{total}) + 1$ 个‘1’的机器——在与忙碌的海狸函数其本身的定义进行比较时，会导出一个根本性的矛盾，从而证明最初的假设（$M_{\\Sigma}$ 的存在）必定是错误的。\n\n以下哪个数学陈述正确地表示了从这个假想构造中导出的矛盾？\n\nA. $\\Sigma(c+38) + 1 = \\Sigma(c) + \\Sigma(38)$\nB. $\\Sigma(c+38) \\le \\Sigma(c) + 38$\nC. $c+38 \\le \\Sigma(c+38)$\nD. $\\Sigma(c+38) + 1 \\le \\Sigma(c+38)$\nE. $\\Sigma(c) + 1 \\le \\Sigma(c)$", "solution": "根据忙碌的海狸函数的定义，对于任何一个从空白纸带开始、在停机前写入 $t$ 个‘1’的、会停机的 $n$ 状态、2 符号图灵机 $M$，都存在基本界限\n$$\nt \\le \\Sigma(n).\n$$\n假设存在一个有 $c$ 个状态的图灵机 $M_{\\Sigma}$，当给定纸带上的输入 $n$ 时，它会在纸带上写入 $\\Sigma(n)$ 后停机。通过组合以下部分来构造 $M_{paradox}$：\n- 一个写入器 $M_{write}$，它使用 $c_{write}$ 个状态将一个硬编码的整数 $N$ 写入纸带，\n- 具有 $c$ 个状态的预言机 $M_{\\Sigma}$，用来计算 $\\Sigma(N)$，\n- 一个具有 $c_{inc}$ 个状态的增量器 $M_{increment}$，它在纸带的一个空白区域上精确写入 $\\Sigma(N)+1$ 个‘1’，然后停机。\n\n$M_{paradox}$ 的总状态数为\n$$\nN_{total} = c_{write} + c + c_{inc}.\n$$\n已知 $c_{write} + c_{inc} = 38$，因此\n$$\nN_{total} = c + 38.\n$$\n设定硬编码的输入为 $N = N_{total}$。那么 $M_{paradox}$ 就是一个从空白纸带开始、停机并精确写入 $\\Sigma(N) + 1$ 个‘1’的 $N$ 状态、2 符号图灵机。将忙碌的海狸函数的定义界限应用于这个特定的 $N$ 状态停机图灵机，我们得到\n$$\n\\Sigma(N) + 1 \\le \\Sigma(N),\n$$\n这是一个矛盾。代入 $N = c + 38$，我们得到明确的矛盾不等式\n$$\n\\Sigma(c+38) + 1 \\le \\Sigma(c+38).\n$$\n在给定的选项中，这正是陈述 D。", "answer": "$$\\boxed{D}$$", "id": "1405440"}]}