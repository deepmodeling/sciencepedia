{"hands_on_practices": [{"introduction": "设计确定性有限自动机 (DFA) 是理解正则语言核心性质的第一步。这个练习将抽象的自动机理论与具体的数学概念——模运算——联系起来。通过为识别特定余数的二进制数构建一个 DFA，你将亲身体验如何利用状态来“记忆”处理过字符串的关键信息，这是自动机解决问题的基础。[@problem_id:1444116]", "problem": "在计算理论中，一个语言是给定字母表上的字符串集合。考虑字母表 $\\Sigma = \\{0, 1\\}$。我们可以将任意非空二进制字符串 $w = b_k b_{k-1} \\dots b_1 b_0$ (其中每个 $b_i \\in \\{0, 1\\}$) 解释为一个正整数 $N(w)$，使用标准的二进制表示法：\n$$N(w) = \\sum_{i=0}^{k} b_i \\cdot 2^i$$\n例如，字符串 \"101\" 表示数字 $1\\cdot2^2 + 0\\cdot2^1 + 1\\cdot2^0 = 4 + 0 + 1 = 5$。\n\n设 $L$ 是由所有非空二进制字符串 $w$ 组成的语言，这些字符串所表示的整数 $N(w)$ 满足条件 $N(w) \\equiv 2 \\pmod{3}$。例如，字符串 \"10\" 属于 $L$，因为它表示数字 2，且 $2 \\equiv 2 \\pmod{3}$。字符串 \"101\" 也属于 $L$，因为它表示数字 5，且 $5 \\equiv 2 \\pmod{3}$。字符串 \"11\" 不属于 $L$，因为它表示 3，且 $3 \\equiv 0 \\pmod{3}$。空字符串不属于 $L$。\n\n接受语言 $L$ 的确定性有限自动机 (DFA) 所需的最少状态数是多少？", "solution": "为了解决这个问题，我们需要找到接受语言 $L$ 的最小确定性有限自动机 (DFA) 的状态数。语言 $L$ 由二进制字符串 $w$ 组成，其表示的数字 $N(w)$ 满足 $N(w) \\equiv 2 \\pmod{3}$。\n\nDFA 从左到右处理字符串。为了确定一个字符串是否在 $L$ 中，DFA 必须有效地计算该字符串所表示的数值模 3 的值。我们的 DFA 的状态可以表示当前数值模 3 的值。由于除以 3 有三种可能的余数（0、1 和 2），我们可以设计一个有三个状态的 DFA，称它们为 $q_0, q_1, q_2$。状态 $q_i$ 将对应于目前已处理的、表示的数值与 $i \\pmod{3}$ 同余的字符串集合。\n\n我们来定义这个 DFA 的组成部分：\n状态集 $Q = \\{q_0, q_1, q_2\\}$。\n字母表 $\\Sigma = \\{0, 1\\}$。\n起始状态：处理过程在读取任何字符之前开始。这对应于空字符串，我们可以认为它表示数字 0。因为 $0 \\equiv 0 \\pmod{3}$，所以起始状态必须是 $q_0$。\n\n转移函数 $\\delta$：我们来分析当追加一个比特位时，数值（模 3）如何变化。假设我们已经处理了一个字符串 $w$，它表示数字 $N(w)$，并且 DFA 处于状态 $q_i$，意味着 $N(w) \\equiv i \\pmod{3}$。\n如果读入一个 '0'，新的字符串是 $w0$。其值为 $N(w0) = 2 \\cdot N(w) + 0$。模 3 运算后，可得 $N(w0) \\equiv 2 \\cdot N(w) \\pmod{3}$。如果 $N(w) \\equiv i \\pmod{3}$，那么 $N(w0) \\equiv 2i \\pmod{3}$。\n如果读入一个 '1'，新的字符串是 $w1$。其值为 $N(w1) = 2 \\cdot N(w) + 1$。模 3 运算后，可得 $N(w1) \\equiv 2 \\cdot N(w) + 1 \\pmod{3}$。如果 $N(w) \\equiv i \\pmod{3}$，那么 $N(w1) \\equiv 2i + 1 \\pmod{3}$。\n\n使用这些规则，我们可以定义转移：\n- 状态 $q_0$ ($i=0$):\n  - 输入 '0'：新状态为 $q_{(2 \\cdot 0) \\pmod{3}} = q_0$。所以，$\\delta(q_0, 0) = q_0$。\n  - 输入 '1'：新状态为 $q_{(2 \\cdot 0 + 1) \\pmod{3}} = q_1$。所以，$\\delta(q_0, 1) = q_1$。\n- 状态 $q_1$ ($i=1$):\n  - 输入 '0'：新状态为 $q_{(2 \\cdot 1) \\pmod{3}} = q_2$。所以，$\\delta(q_1, 0) = q_2$。\n  - 输入 '1'：新状态为 $q_{(2 \\cdot 1 + 1) \\pmod{3}} = q_0$。所以，$\\delta(q_1, 1) = q_0$。\n- 状态 $q_2$ ($i=2$):\n  - 输入 '0'：新状态为 $q_{(2 \\cdot 2) \\pmod{3}} = q_{4 \\pmod{3}} = q_1$。所以，$\\delta(q_2, 0) = q_1$。\n  - 输入 '1'：新状态为 $q_{(2 \\cdot 2 + 1) \\pmod{3}} = q_{5 \\pmod{3}} = q_2$。所以，$\\delta(q_2, 1) = q_2$。\n\n接受状态集 $F$：语言 $L$ 接受满足 $N(w) \\equiv 2 \\pmod{3}$ 的字符串 $w$。因此，唯一的接受状态是 $q_2$。所以，$F = \\{q_2\\}$。\n\n问题陈述指明空字符串不属于 $L$。我们的起始状态是 $q_0$，它不是接受状态。因此，空字符串被拒绝，这是正确的。\n\n我们构建了一个 3 状态的 DFA。现在我们必须确认它是最小的。一个 DFA 是最小的，如果它的所有状态都可以从起始状态到达，并且所有状态对都是可区分的。\n\n1.  可达性：\n    - $q_0$ 是起始状态，因此是可达的。\n    - $q_1$ 可从 $q_0$ 经由输入 \"1\" 到达。\n    - $q_2$ 可从 $q_0$ 经由输入 \"10\" 到达 ($\\delta(q_0, 1) = q_1$, $\\delta(q_1, 0) = q_2$)。\n    所有三个状态都是可达的。\n\n2.  可区分性：如果存在一个字符串，它能将两个状态中的一个引导至接受状态，而将另一个引导至非接受状态，那么这两个状态就是可区分的。\n    - $q_0$ 和 $q_2$：$q_2$ 是接受状态，而 $q_0$ 不是。它们可以由空字符串区分。\n    - $q_1$ 和 $q_2$：$q_2$ 是接受状态，而 $q_1$ 不是。它们可以由空字符串区分。\n    - $q_0$ 和 $q_1$：从 $q_0$ 开始，输入 \"0\" 会到达 $q_0$（非接受状态）。从 $q_1$ 开始，输入 \"0\" 会到达 $q_2$（接受状态）。因此，$q_0$ 和 $q_1$ 是可区分的。\n\n由于所有三个状态都是可达的且两两可区分，我们构建的 DFA 是最小的。所需的最少状态数是 3。\n这个结果也可以由 Myhill-Nerode 定理预测，该定理指出，一个语言的最小 DFA 的状态数等于 Nerode 关系的等价类的数量。对于这个语言，等价类对应于模 3 的三种可能的余数。", "answer": "$$\\boxed{3}$$", "id": "1444116"}, {"introduction": "虽然 DFA 功能强大，但它们的能力是有限的——它们的有限内存无法处理需要无限“计数”的任务。抽引理 (Pumping Lemma) 是我们证明一个语言不是正则语言的最主要形式化工具。这个练习将指导你应用抽引理来证明一个经典的非正则语言，让你掌握这种反证法的逻辑结构，特别是如何通过巧妙的构造找到矛盾。[@problem_id:1444112]", "problem": "一位分析师正在研究一种通信协议，其中有效信号是构建在单字符字母表 $\\Sigma = \\{s\\}$ 上的字符串。有效信号的语言（记为 $L$）被定义为所有长度 $k$ 为素数的字符串 $s^k$ 的集合。形式化地, $L = \\{ s^k \\mid k \\text{ 是一个素数} \\}$。\n\n该分析师假设 $L$ 不是一个正则语言。为了证明这一点，他们决定使用正则语言的泵引理。该引理指出，对于任何正则语言，都存在一个泵长度 $p$，使得该语言中任何长度 $|w| \\ge p$ 的字符串 $w$ 都可以被分解为三个部分 $w=xyz$，且满足以下三个条件：\n1. $|y| \\ge 1$\n2. $|xy| \\le p$\n3. 对于所有非负整数 $i$，字符串 $xy^iz$ 也属于 $L$。\n\n分析师为了进行反证，假设 $L$ 是正则的，并且其泵长度为 $p=8$。他们选择了字符串 $w = s^{13}$，该字符串属于 $L$ 因为13是一个素数，且其长度13大于假定的泵长度 $p=8$。根据泵引理，$w$ 可以被分解为 $xyz$，其中 $|xy| \\le 8$ 且 $|y| \\ge 1$。设子串 $y$ 的长度记为 $j$。\n\n对于泵整数 $i$ 的以下哪个选项，可以保证对于 $w$ 的*任何*可能的有效分解（即，对于任何满足 $1 \\le j \\le 8$ 的整数 $j$），所产生的字符串 $xy^iz$ *不*在语言 $L$ 中？\n\nA. $i=0$\n\nB. $i=2$\n\nC. $i=12$\n\nD. $i=13$\n\nE. $i=14$", "solution": "使用反证法，假设 $L$ 是一个泵长度为 $p=8$ 的正则语言。选择字符串 $w=s^{13} \\in L$，其长度为 $|w|=13 \\ge 8$。根据泵引理，$w$ 可以被分解为 $w=xyz$，其中 $|y| \\ge 1$ 且 $|xy| \\le 8$。在此一元字母表上，我们可以写成\n$$\nx=s^{a},\\quad y=s^{j},\\quad z=s^{13-a-j},\n$$\n其中 $a \\ge 0$，$j \\ge 1$，且 $a+j \\le 8$。对于任何泵指数 $i \\ge 0$，泵出的字符串 $xy^{i}z$ 的长度为\n$$\n|xy^{i}z|=|x|+i|y|+|z|=a+ij+(13-a-j)=13+(i-1)j.\n$$\n一个泵出的字符串 $xy^{i}z$ 属于 $L$ 当且仅当 $13+(i-1)j$ 是素数。我们需要找到一个 $i$，使得对于每一个有效的分解（等价于，对于每一个满足 $1 \\le j \\le 8$ 的 $j$，因为选择 $a=8-j$ 可以确保 $|xy| \\le 8$），数字 $13+(i-1)j$ 都不是素数。\n\n检查每个选项：\n- $i=0$: 长度为 $13-j$。当 $j=2$ 时，我们得到 $11$，这是一个素数。因此不能保证。\n- $i=2$: 长度为 $13+j$。当 $j=4$ 时，我们得到 $17$，这是一个素数。因此不能保证。\n- $i=12$: 长度为 $13+11j$。当 $j=6$ 时，我们得到 $79$，这是一个素数。因此不能保证。\n- $i=13$: 长度为 $13+12j$。当 $j=2$ 时，我们得到 $37$，这是一个素数。因此不能保证。\n- $i=14$: 长度为 $13+13j=13(1+j)$。对于所有 $j \\ge 1$，$1+j \\ge 2$，所以这个数是13的一个大于13的倍数，因此是合数，所以对于每一个有效的分解，$xy^{14}z \\notin L$。\n\n因此，选择 $i=14$ 可以保证对于任何有效分解，$xy^{i}z \\notin L$。", "answer": "$$\\boxed{E}$$", "id": "1444112"}, {"introduction": "正则语言理论的真正力量不仅在于识别字符串，还在于其丰富的闭包性质和算法可判定性。这个练习模拟了一个现实世界中的软件验证问题，要求你设计一个算法来判定一个语言是否是另一个语言的子集 ($L_1 \\subseteq L_2$)。通过组合补集、交集和空性测试等基本操作，你将学会如何利用正则语言的理论特性来构建解决复杂问题的系统性方法。[@problem_id:1444096]", "problem": "一家网络安全公司的软件工程团队的任务是验证一个新的、高度优化的防火墙模块的行为。该防火墙用于识别恶意网络数据包的规则被建模为一个确定性有限自动机 (DFA)。设 $\\Sigma$ 为数据包头部中所有可能字节的字母表。\n\n该公司有一个行为众所周知的可信传统防火墙。它正确识别为恶意的所有数据包头的集合是一个正则语言 $L(M_{\\text{legacy}})$，其中 $M_{\\text{legacy}}$ 是一个 DFA。新的、优化的防火墙实现了一套不同的规则，由另一个 DFA $M_{\\text{new}}$ 表示，它接受语言 $L(M_{\\text{new}})$。\n\n部署的一个关键要求是“无漏报”。也就是说，任何被新防火墙识别为恶意的数据包头，也必须被可信的传统防火墙识别为恶意。形式上，这要求新防火墙接受的语言是传统防火墙接受的语言的子集，即 $L(M_{\\text{new}}) \\subseteq L(M_{\\text{legacy}})$。\n\n你的任务是确定一个正确的算法过程，以判定对于任意给定的两个 DFA $M_{\\text{new}}$ 和 $M_{\\text{legacy}}$，这个包含性质是否成立。该过程必须由对有限自动机的标准、可判定操作组成。\n\n下列哪项描述了一个正确且完整的算法，用于判定 $L(M_{\\text{new}}) \\subseteq L(M_{\\text{legacy}})$ 是否成立？\n\nA. 为语言 $L(M_{\\text{legacy}})^c \\cap L(M_{\\text{new}})$ 构造一个 DFA $M_{A}$。然后，检查 $L(M_{A})$ 是否为空。当且仅当 $L(M_{A})$ 为空时，该包含关系成立。\n\nB. 为语言 $L(M_{\\text{legacy}}) \\cap L(M_{\\text{new}})$ 构造一个 DFA $M_{B}$。然后，检查 $L(M_{B})$ 是否为空。当且仅当 $L(M_{B})$ 为空时，该包含关系成立。\n\nC. 对于无限集 $L(M_{\\text{new}})$ 中的每个字符串 $w$，模拟这两个 DFA 以检查 $w$ 是否也在 $L(M_{\\text{legacy}})$ 中。如果这对所有这样的字符串 $w$ 都成立，则该包含关系成立。\n\nD. 为语言 $L(M_{\\text{new}})^c \\cap L(M_{\\text{legacy}})$ 构造一个 DFA $M_{D}$。然后，检查 $L(M_{D})$ 是否为空。当且仅当 $L(M_{D})$ 为空时，该包含关系成立。\n\nE. 为语言 $L(M_{\\text{legacy}}) \\cup L(M_{\\text{new}})$ 构造一个 DFA $M_{E}$。然后，通过比较它们的状态图，检查这个新自动机是否与 $M_{\\text{new}}$ 等价。当且仅当它们等价时，该包含关系成立。", "solution": "我们必须判定是否 $L(M_{\\text{new}}) \\subseteq L(M_{\\text{legacy}})$。根据一个标准的集合论等价关系，对于同一字母表上的任意语言 $A$ 和 $B$，\n$$\nA \\subseteq B \\iff A \\cap B^{c} = \\varnothing.\n$$\n将此应用于 $A = L(M_{\\text{new}})$ 和 $B = L(M_{\\text{legacy}})$，我们得到\n$$\nL(M_{\\text{new}}) \\subseteq L(M_{\\text{legacy}}) \\iff L(M_{\\text{new}}) \\cap (L(M_{\\text{legacy}}))^{c} = \\varnothing.\n$$\n\nDFA 在补集和交集运算下是封闭的，且相应的构造是有效的：\n- 补集：给定一个完备的 DFA $M_{\\ell} = (Q_{\\ell}, \\Sigma, \\delta_{\\ell}, q_{0,\\ell}, F_{\\ell})$，其补集 DFA 是 $M_{\\ell}^{c} = (Q_{\\ell}, \\Sigma, \\delta_{\\ell}, q_{0,\\ell}, Q_{\\ell} \\setminus F_{\\ell})$，它识别 $\\Sigma^{*} \\setminus L(M_{\\ell})$。如果 $M_{\\ell}$ 不是完备的，首先添加一个陷阱状态使其完备。\n- 交集：给定 $M_{\\text{new}} = (Q_{n}, \\Sigma, \\delta_{n}, q_{0,n}, F_{n})$ 和如上所述的 $M_{\\ell}^{c}$，构造乘积 DFA\n$$\nM_{A} = \\left(Q_{n} \\times Q_{\\ell}, \\Sigma, \\delta, (q_{0,n}, q_{0,\\ell}), F_{n} \\times (Q_{\\ell} \\setminus F_{\\ell})\\right),\n$$\n其中对于所有 $a \\in \\Sigma$，$\\delta((q_{n}, q_{\\ell}), a) = (\\delta_{n}(q_{n}, a), \\delta_{\\ell}(q_{\\ell}, a))$。那么 $L(M_{A}) = L(M_{\\text{new}}) \\cap (L(M_{\\text{legacy}}))^{c}$。\n\nDFA 语言的空性是可判定的：$L(M)$ 为空，当且仅当从开始状态无法到达任何接受状态。这可以通过在 $M$ 的有限转移图上进行图可达性搜索来检查。\n\n因此，算法如下：\n1. 构造 $M_{\\text{legacy}}$ 的补集 $M_{\\ell}^{c}$。\n2. 构造识别 $L(M_{\\text{new}}) \\cap (L(M_{\\text{legacy}}))^{c}$ 的乘积 DFA $M_{A}$。\n3. 通过可达性分析判定 $L(M_{A})$ 是否为空。如果为空，则包含关系成立；否则，一个可达的接受状态（及相应的字符串）就是该包含关系的一个反例。\n\n这个过程与选项 A 完全匹配。其他选项不正确，原因如下：\n- B 检查 $L(M_{\\text{legacy}}) \\cap L(M_{\\text{new}})$ 的空性，这测试的是不相交性，而不是包含关系。\n- C 要求检查一个无限集中的所有字符串，不能得出一个在所有情况下都能停机的通用判定过程。\n- D 检查 $L(M_{\\text{new}})^{c} \\cap L(M_{\\text{legacy}})$ 的空性，这等价于 $L(M_{\\text{legacy}}) \\subseteq L(M_{\\text{new}})$，即反向的包含关系。\n- E 测试 $L(M_{\\text{legacy}}) \\cup L(M_{\\text{new}}) = L(M_{\\text{new}})$ 是否成立，这也等价于 $L(M_{\\text{legacy}}) \\subseteq L(M_{\\text{new}})$，即反向的包含关系。此外，“比较状态图”通常不是一个正确的等价性测试方法，除非使用像乘积构造或最小化这样的形式化方法，而且在这里没有必要。", "answer": "$$\\boxed{A}$$", "id": "1444096"}]}