{"hands_on_practices": [{"introduction": "掌握确定性有限自动机（DFA）的关键在于将语言的抽象描述转化为具体的状态和转换。这个练习是一个绝佳的起点，它要求我们构建一个DFA来识别具有特定属性的字符串——包含偶数个 $a$ 和奇数个 $b$。通过这个实践，你将学会如何利用DFA的状态来“记忆”处理输入时必须跟踪的关键信息（在本例中是字符的奇偶性），这是设计任何自动机的核心思维方式。[@problem_id:1421354]", "problem": "考虑字母表 $\\Sigma = \\{a, b\\}$。设 $L$ 是由字母表 $\\Sigma$ 上所有包含偶数个 'a' 和奇数个 'b' 的字符串组成的语言。确定性有限自动机 (DFA) 是一种有限状态机，它通过一系列状态处理字符串来接受或拒绝它们。识别语言 $L$ 的 DFA 所需的最小状态数是多少？\n\nA. 2\n\nB. 3\n\nC. 4\n\nD. 5\n\nE. 6", "solution": "要解决这个问题，我们需要确定一个确定性有限自动机 (DFA) 在逐个字符处理字符串以判断其是否属于语言 $L$ 时必须记住的关键信息。一个字符串的接受条件取决于两个独立的属性：'a' 数量的奇偶性和 'b' 数量的奇偶性。\n\n我们来分析一下自动机需要跟踪的属性：\n1.  到目前为止，自动机是看到了偶数个还是奇数个 'a'？\n2.  到目前为止，自动机是看到了偶数个还是奇数个 'b'？\n\nDFA 中的一个状态必须编码这两个问题的答案。我们可以用一个有序对 $(P_a, P_b)$ 来表示自动机的状态，其中 $P_a$ 是已见 'a' 数量的奇偶性，而 $P_b$ 是已见 'b' 数量的奇偶性。每个奇偶性可以是“偶数”或“奇数”。\n\n这给了我们四种可能的奇偶性组合，它们将对应于所需的最小状态数：\n1.  状态 $q_0$：（偶数个 'a'，偶数个 'b'）\n2.  状态 $q_1$：（偶数个 'a'，奇数个 'b'）\n3.  状态 $q_2$：（奇数个 'a'，偶数个 'b'）\n4.  状态 $q_3$：（奇数个 'a'，奇数个 'b'）\n\n让我们更正式地定义状态和转移：\n状态集合为 $Q = \\{q_0, q_1, q_2, q_3\\}$。\n字母表为 $\\Sigma = \\{a, b\\}$。\n\n起始状态必须对应于空字符串的属性。空字符串有零个 'a' 和零个 'b'。由于零是偶数，所以初始状态表示偶数个 'a' 和偶数个 'b'。因此，起始状态是 $q_0$。\n\n接受状态必须对应于语言 $L$ 的定义，即要求有偶数个 'a' 和奇数个 'b'。因此，唯一的接受状态是 $q_1$。\n\n现在，我们来考虑这些状态之间的转移：\n- 从状态 $q_0$（偶数个 'a'，偶数个 'b'）：\n  - 读到 'a' 时，'a' 的数量奇偶性变为奇数，而 'b' 的数量奇偶性保持偶数。自动机转移到状态 $q_2$（奇数个 'a'，偶数个 'b'）。\n  - 读到 'b' 时，'b' 的数量奇偶性变为奇数，而 'a' 的数量奇偶性保持偶数。自动机转移到状态 $q_1$（偶数个 'a'，奇数个 'b'）。\n\n- 从状态 $q_1$（偶数个 'a'，奇数个 'b'）：\n  - 读到 'a' 时，'a' 的数量奇偶性变为奇数。自动机转移到状态 $q_3$（奇数个 'a'，奇数个 'b'）。\n  - 读到 'b' 时，'b' 的数量奇偶性变回偶数。自动机转移到状态 $q_0$（偶数个 'a'，偶数个 'b'）。\n\n- 从状态 $q_2$（奇数个 'a'，偶数个 'b'）：\n  - 读到 'a' 时，'a' 的数量奇偶性变回偶数。自动机转移到状态 $q_0$（偶数个 'a'，偶数个 'b'）。\n  - 读到 'b' 时，'b' 的数量奇偶性变为奇数。自动机转移到状态 $q_3$（奇数个 'a'，奇数个 'b'）。\n\n- 从状态 $q_3$（奇数个 'a'，奇数个 'b'）：\n  - 读到 'a' 时，'a' 的数量奇偶性变回偶数。自动机转移到状态 $q_1$（偶数个 'a'，奇数个 'b'）。\n  - 读到 'b' 时，'b' 的数量奇偶性变回偶数。自动机转移到状态 $q_2$（奇数个 'a'，偶数个 'b'）。\n\n所有四个状态都可以从起始状态 $q_0$ 到达。例如：\n- $q_0$ 是起始状态。\n- 读入 'b' 可以到达 $q_1$。\n- 读入 'a' 可以到达 $q_2$。\n- 读入 'ab' 可以到达 $q_3$。\n\n此外，所有四个状态都是可区分的。例如，从状态 $q_0$ 开始，字符串 'b' 会到达一个接受状态（$q_1$），但从状态 $q_2$ 开始，字符串 'b' 会到达一个非接受状态（$q_3$）。这意味着 $q_0$ 和 $q_2$ 必须是不同的状态。对于所有状态对都可以进行类似的论证。由于所有四个状态对于区分不同的奇偶性组合都是必需的，因此最小的 DFA 必须恰好有 4 个状态。", "answer": "$$\\boxed{C}$$", "id": "1421354"}, {"introduction": "在学会了如何从零开始构建DFA之后，下一步是分析一个给定的DFA。自动机的状态图结构本身蕴含了其所识别语言的深刻属性。这个练习将引导你通过分析DFA的状态转换图来判断其接受的语言是有限的还是无限的，这是一个至关重要的问题。你将发现，图中是否存在可达的、并且能通向接受状态的循环，是决定语言规模的关键。[@problem_id:1362810]", "problem": "一个网络工程师团队正在为一个控制系统设计一个简单的验证协议。该协议接受由字母表 $\\Sigma = \\{0, 1\\}$ 表示的二进制信号序列。序列的有效性通过一个确定有限自动机 (DFA) 来检查。一个序列被认为是有效的，当且仅当该 DFA 在处理完整个序列后停在一个接受状态。\n\n该 DFA 记为 $M$，由五元组 $(Q, \\Sigma, \\delta, q_0, F)$ 形式化定义，其中：\n- 状态集合为 $Q = \\{S_0, S_1, S_2, S_3, S_4, S_5\\}$。\n- 输入字母表为 $\\Sigma = \\{0, 1\\}$。\n- 初始状态为 $q_0 = S_0$。\n- 接受状态集合为 $F = \\{S_4\\}$。\n- 转移函数 $\\delta: Q \\times \\Sigma \\to Q$ 由下表给出：\n\n| 当前状态 | 输入 '0' | 输入 '1' |\n| :-------: | :-------: | :-------: |\n|   $S_0$   |   $S_1$   |   $S_2$   |\n|   $S_1$   |   $S_0$   |   $S_3$   |\n|   $S_2$   |   $S_5$   |   $S_4$   |\n|   $S_3$   |   $S_3$   |   $S_4$   |\n|   $S_4$   |   $S_5$   |   $S_5$   |\n|   $S_5$   |   $S_5$   |   $S_5$   |\n\n令 $L(M)$ 为此 DFA 接受的所有有效信号序列组成的语言。你的任务是确定该语言的性质。下列哪个陈述是正确的？\n\nA. 语言 $L(M)$ 是有限的。\n\nB. 语言 $L(M)$ 是无限的。\n\nC. 语言 $L(M)$ 是空的（不包含任何字符串）。\n\nD. 语言 $L(M)$ 是有限的还是无限的是不可判定的。", "solution": "我们分析给定的 DFA $M=(Q,\\Sigma,\\delta,q_{0},F)$ 的接受情况，其中 $Q=\\{S_{0},S_{1},S_{2},S_{3},S_{4},S_{5}\\}$，$\\Sigma=\\{0,1\\}$，$q_{0}=S_{0}$，$F=\\{S_{4}\\}$，且转移函数如规定。一个字符串被接受，如果其运行结束于状态 $S_{4}$。从表中可知，一旦自动机进入 $S_{4}$，任何后续输入都会导致其转移到 $S_{5}$，而 $S_{5}$ 是一个非接受的陷阱状态：$\\delta(S_{4},0)=S_{5}$，$\\delta(S_{4},1)=S_{5}$，以及 $\\delta(S_{5},0)=\\delta(S_{5},1)=S_{5}$。因此，任何被接受的字符串都必须在首次到达 $S_{4}$ 时恰好结束；如果字符串要被接受，则在进入 $S_4$ 后不能再有任何符号。\n\n要确定 $L(M)$ 是有限的还是无限的，只需检查是否存在一个可达的、与 $S_4$ 不相交的环路，并且从这个环路可以到达 $S_4$。如果存在这样的环路，我们可以在环路上重复任意次，然后通过一个最终的转移到达 $S_{4}$，从而产生无限多个被接受的字符串。\n\n从转移表中可以看出，$S_{3}$ 是从初始状态可达的：\n$$S_{0}\\xrightarrow{0}S_{1}\\xrightarrow{1}S_{3}。$$\n在状态 $S_{3}$，输入为 $0$ 时有一个自环：\n$$\\delta(S_{3},0)=S_{3},$$\n并且从 $S_{3}$ 出发，输入为 $1$ 时会转移到接受状态：\n$$\\delta(S_{3},1)=S_{4}。$$\n因此，对于任意整数 $k\\geq 0$，字符串\n$$w_{k}=0\\,1\\,0^{k}\\,1$$\n都会被接受，因为其运行路径是：\n$$S_{0}\\xrightarrow{0}S_{1}\\xrightarrow{1}S_{3}\\xrightarrow{0^{k}}S_{3}\\xrightarrow{1}S_{4}。$$\n对于不同的 $k$，这些字符串都是不同的，所以存在无限多个被接受的字符串。因此 $L(M)$ 是无限的。它既不是空的也不是有限的，并且由于该 DFA 是完全指定的，所以这个问题是可判定的；因此选项 D 是错误的。\n\n所以，正确选项是 B。", "answer": "$$\\boxed{B}$$", "id": "1362810"}, {"introduction": "在软件工程和协议设计中，我们常常需要验证两个不同的实现是否功能完全相同。这个实践将这一实际问题抽象为一个关于DFA等价性的核心理论问题。你将探索如何确定性地判断两个DFA是否接受完全相同的语言，而无需无限地测试所有可能的字符串。这个问题将引导你思考一个强大的理论工具——乘积自动机，并用它来推导出一个确定的、有限的测试边界。[@problem_id:1421345]", "problem": "两位计算机科学家，Alice和Bob，为一种新的通信协议独立设计了解析器。每位研究者都将其解析器建模为确定性有限自动机 (DFA)。一个 DFA 被形式化地定义为一个五元组 $(Q, \\Sigma, \\delta, q_0, F)$，其中 $Q$ 是一个有限的状态集，$\\Sigma$ 是输入字母表，$\\delta: Q \\times \\Sigma \\to Q$ 是转移函数，$q_0 \\in Q$ 是起始状态，$F \\subseteq Q$ 是终止（或接受）状态集。如果一个 DFA 在处理完整个输入字符串后停在集合 $F$ 中的一个状态，那么该字符串就被接受。\n\n第一位研究者的 DFA，$M_A$，有 4 个状态。第二位研究者的 DFA，$M_B$，有 5 个状态。两个 DFA 都基于相同的字母表运行。如果两个 DFA 接受完全相同的语言（即，相同的输入字符串集合），则它们被认为是等价的。\n\n为了验证他们的设计是否等价，他们计划用所有可能的不超过特定长度的输入字符串来测试这两个 DFA。如果对于所有测试字符串，两个 DFA 都给出相同的结果（即，都接受或都拒绝），他们就将断定这两个 DFA 是等价的。他们想要找到能保证此结论正确的最小测试界限。\n\n能够区分两个不等价 DFA（一个有 4 个状态，另一个有 5 个状态）的*最短*字符串的最大可能长度是多少？这个长度代表了他们为了确信等价性而必须测试的字符串长度的上限。请将此最大长度作为你的答案。", "solution": "令 $M_{A}=(Q_{A},\\Sigma,\\delta_{A},q_{A},F_{A})$，其状态数为 $|Q_{A}|=m$；令 $M_{B}=(Q_{B},\\Sigma,\\delta_{B},q_{B},F_{B})$，其状态数为 $|Q_{B}|=n$。考虑一个标准的积自动机，它识别这两个 DFA 语言的对称差：\n- 状态集 $Q=Q_{A}\\times Q_{B}$，因此 $|Q|=mn$。\n- 起始状态 $(q_{A},q_{B})$。\n- 转移函数 $\\delta((p,q),a)=(\\delta_{A}(p,a),\\delta_{B}(q,a))$，对于 $a\\in\\Sigma$。\n- 接受状态集 $D=(F_{A}\\times(Q_{B}\\setminus F_{B}))\\cup((Q_{A}\\setminus F_{A})\\times F_{B})$。\n\n根据构造，一个字符串 $w\\in\\Sigma^{*}$ 被这个积自动机接受，当且仅当它能区分 $M_{A}$ 和 $M_{B}$，也就是说，$M_{A}$ 或 $M_{B}$ 中恰好有一个接受 $w$。因此，如果 $M_{A}$ 和 $M_{B}$ 不等价，那么积自动机所接受的语言 $L$ 是非空的。\n\n断言：在任何具有 $N$ 个状态的 DFA 中，如果其语言非空，那么存在一个长度至多为 $N-1$ 的被接受的字符串。证明：令 $w$ 为一最短的被接受的字符串，并考虑其从起始状态到某一接受状态的唯一计算路径。该路径访问 $|w|+1$ 个状态。如果该路径上有任何状态重复，比如说第 $i$ 个和第 $j$ 个状态相同（$0\\leq i<j\\leq |w|$），那么移除这两个状态之间的循环部分，可以得到一个更短的被接受字符串，这与 $w$ 的最短性相矛盾。因此，所有访问过的状态都是不同的，所以 $|w|+1\\leq N$，从而 $|w|\\leq N-1$。\n\n将该断言应用于积自动机，可得最短区分字符串的长度至多为 $mn-1$。这个界在一般情况下是紧的（存在这样的 DFA 对，其积自动机从起始状态到第一个接受状态形成一条长度为 $mn$ 的简单路径），所以最短区分字符串的最大可能长度是 $mn-1$。\n\n当 $m=4$ 且 $n=5$ 时，最大可能长度是 $4\\cdot 5-1=19$。", "answer": "$$\\boxed{19}$$", "id": "1421345"}]}