{"hands_on_practices": [{"introduction": "正则表达式是描述文本模式的强大工具，而非确定性有限自动机 (Nondeterministic Finite Automaton, NFA) 则是识别这些模式的计算模型。将给定的正则表达式转换为等效的 $NFA$ 是形式语言理论中的一项核心技能。通过这个练习 [@problem_id:1424597]，你将锻炼分析正则表达式和构建高效自动机的能力，这在文本处理和编译器设计等领域至关重要。", "problem": "在计算理论中，一个非确定性有限自动机（NFA）被形式化地定义为一个5元组 $(Q, \\Sigma, \\delta, q_0, F)$，其中 $Q$ 是一个有限的状态集合，$\\Sigma$ 是一个有限的符号字母表，$\\delta: Q \\times (\\Sigma \\cup \\{\\epsilon\\}) \\to \\mathcal{P}(Q)$ 是转移函数（其中 $\\mathcal{P}(Q)$ 是 $Q$ 的幂集），$q_0 \\in Q$ 是起始状态，而 $F \\subseteq Q$ 是接受（或最终）状态的集合。\n\n考虑在字母表 $\\Sigma = \\{a, b\\}$ 上的语言 $L$，它由以下正则表达式定义：\n$$ (a^*b \\cup b^*a)^+ $$\n一个接受语言 $L$ 的 NFA 所需的最小状态数是多少？\n\nA. 1\n\nB. 2\n\nC. 3\n\nD. 4\n\nE. 5", "solution": "我们分析正则表达式 $R = a^{*}b \\cup b^{*}a$ 和在 $\\Sigma = \\{a, b\\}$ 上的语言 $L = R^{+}$。\n\n首先，观察到 $a \\in R$，因为当 $b$ 出现零次时，$b^*a$ 产生 $a$；并且 $b \\in R$，因为当 $a$ 出现零次时，$a^*b$ 产生 $b$。因此 $\\{a, b\\} \\subseteq R$。由于 $L = R^{+}$ 是 $R$ 中元素的所有有限串联的集合，所以 $\\{a, b\\}$ 上的每个非空字符串都是 $a$ 和 $b$ 的串联，而 $a$ 和 $b$ 都在 $R$ 中。因此，\n$$\n\\{a, b\\}^{+} \\subseteq L.\n$$\n反之，在 $L = R^{+}$ 中的每个字符串都是由长度至少为1的块串联而成，所以 $L \\subseteq \\{a, b\\}^{+}$。因此，\n$$\nL = \\{a, b\\}^{+}.\n$$\n\n我们现在来确定接受 $L = \\Sigma^{+}$ 所需的 NFA 的最小状态数。\n\n下界：任何单状态 NFA 都无法在不接受 $\\epsilon$ 的情况下识别 $\\Sigma^{+}$。如果这个唯一的状态是接受状态，那么 $\\epsilon$ 会被接受；如果它是拒绝状态，那么任何非空字符串都无法被接受，因为所有计算都将终止于同一个拒绝状态。对于单状态自动机，$\\epsilon$-转移没有帮助，因为是否接受 $\\epsilon$ 仅取决于起始状态是否为接受状态。因此，至少需要2个状态。\n\n上界（构造性证明）：一个2状态的 NFA 就足够了。设 $Q = \\{q_{0}, q_{1}\\}$，起始状态为 $q_{0}$，接受状态集为 $F = \\{q_{1}\\}$。定义转移如下：\n$$\n\\delta(q_{0}, a) = \\{q_{1}\\}, \\quad \\delta(q_{0}, b) = \\{q_{1}\\}, \\quad \\delta(q_{1}, a) = \\{q_{1}\\}, \\quad \\delta(q_{1}, b) = \\{q_{1}\\}.\n$$\n那么该自动机恰好接受 $\\Sigma^{+}$。因此，一个 NFA 的最小状态数是2。\n\n在这些选项中，这对应于B。", "answer": "$$\\boxed{B}$$", "id": "1424597"}, {"introduction": "某些语言，如回文语言，需要有限自动机所不具备的记忆能力。下推自动机 (Pushdown Automaton, PDA) 通过增加一个栈来扩展 $NFA$，从而能够识别更广泛的上下文无关语言。这个练习 [@problem_id:1424576] 展示了如何通过非确定性地使用栈，让机器“记住”字符串的前半部分并与后半部分进行匹配，从而深刻理解上下文无关语言的识别过程。", "problem": "考虑字母表 $\\Sigma = \\{a, b\\}$ 上所有回文构成的语言 $L$。回文是一个正读和反读都相同的字符串。形式上，$L = \\{w \\in \\{a,b\\}^* \\mid w = w^R\\}$，其中 $w^R$ 表示字符串 $w$ 的反转。\n\n我们正在设计一个非确定性下推自动机（PDA），记为 $M$，以接受该语言 $L$。该 PDA 由元组 $M = (Q, \\Sigma, \\Gamma, \\delta, q_0, Z_0, F)$ 定义，包含以下组成部分：\n- 状态 $Q = \\{q_0, q_1, q_2\\}$\n- 输入字母表 $\\Sigma = \\{a, b\\}$\n- 栈字母表 $\\Gamma = \\{a, b, Z_0\\}$，其中 $Z_0$ 是初始栈符号。\n- 起始状态 $q_0$\n- 最终状态集 $F = \\{q_2\\}$\n\n该 PDA 的预期逻辑如下：\n1. 在状态 $q_0$ 中，读取输入字符串的前半部分，并将相应的符号推入栈中。\n2. 非确定性地猜测字符串的中心，并转换到状态 $q_1$。此转换可能会也可能不会消耗输入符号，以处理偶数和奇数长度的回文。\n3. 在状态 $q_1$ 中，读取输入字符串的后半部分，将每个符号与栈顶符号进行匹配并将其弹出。\n4. 如果整个输入字符串已被读取，并且栈中只剩下初始符号 $Z_0$，则转换到最终状态 $q_2$。\n\n部分转移规则 $\\delta$ 已被定义。转移规则的书写格式为 $\\delta(\\text{当前状态}, \\text{输入符号}, \\text{栈顶}) = \\{(\\text{下一状态}, \\text{要推入栈的字符串})\\}$。\n- **推入规则（在状态 $q_0$ 中）：**\n    - 对于任意栈符号 $X \\in \\Gamma$，有 $\\delta(q_0, a, X) = \\{(q_0, aX)\\}$\n    - 对于任意栈符号 $X \\in \\Gamma$，有 $\\delta(q_0, b, X) = \\{(q_0, bX)\\}$\n- **接受规则：**\n    - $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$\n\n你的任务是找出完成此 PDA 所需的正确附加转移规则集，使其能够正确接受语言 $L$。以下哪组规则正确地表示了“猜测中心”和“弹出”阶段？注意，$\\epsilon$ 表示空字符串。\n\nA.\n- $\\delta(q_0, a, a) = \\{(q_1, \\epsilon)\\}$\n- $\\delta(q_0, b, b) = \\{(q_1, \\epsilon)\\}$\n- $\\delta(q_1, a, a) = \\{(q_1, \\epsilon)\\}$\n- $\\delta(q_1, b, b) = \\{(q_1, \\epsilon)\\}$\n\nB.\n- 对于任意 $X \\in \\Gamma$，有 $\\delta(q_0, \\epsilon, X) = \\{(q_1, X)\\}$\n- $\\delta(q_1, a, a) = \\{(q_1, \\epsilon)\\}$\n- $\\delta(q_1, b, b) = \\{(q_1, \\epsilon)\\}$\n\nC.\n- 对于任意 $X \\in \\Gamma$，有 $\\delta(q_0, \\epsilon, X) = \\{(q_1, X)\\}$\n- 对于任意 $X \\in \\Gamma$，有 $\\delta(q_0, a, X) = \\{(q_1, X)\\}$\n- 对于任意 $X \\in \\Gamma$，有 $\\delta(q_0, b, X) = \\{(q_1, X)\\}$\n- $\\delta(q_1, a, a) = \\{(q_1, \\epsilon)\\}$\n- $\\delta(q_1, b, b) = \\{(q_1, \\epsilon)\\}$\n\nD.\n- 对于任意 $X \\in \\Gamma$，有 $\\delta(q_0, \\epsilon, X) = \\{(q_1, X)\\}$\n- 对于任意 $X \\in \\Gamma$，有 $\\delta(q_0, a, X) = \\{(q_1, X)\\}$\n- 对于任意 $X \\in \\Gamma$，有 $\\delta(q_0, b, X) = \\{(q_1, X)\\}$\n- $\\delta(q_1, a, b) = \\{(q_1, \\epsilon)\\}$\n- $\\delta(q_1, b, a) = \\{(q_1, \\epsilon)\\}$", "solution": "目标是构造一个能够识别字母表 $\\Sigma=\\{a,b\\}$ 上回文语言 $L = \\{w \\mid w=w^R\\}$ 的下推自动机（PDA）。该 PDA 必须能正确处理偶数长度和奇数长度的回文，以及空字符串。\n\n给定的 PDA 结构使用三个状态：$q_0$ 用于推入阶段，$q_1$ 用于弹出阶段，$q_2$ 作为最终（接受）状态。\n\n让我们逐步分析所需的逻辑：\n\n1.  **推入阶段：** PDA 从状态 $q_0$ 开始。对于输入字符串 $w$ 的前半部分，它应该读取符号并将其推入栈中。这样就创建了前半部分的反向记录。已提供的规则 $\\delta(q_0, a, X) = \\{(q_0, aX)\\}$ 和 $\\delta(q_0, b, X) = \\{(q_0, bX)\\}$（对于任意 $X \\in \\Gamma$）正确地实现了这一点。对于一个输入符号 $c$，它被推到栈顶现有符号（$X$）的上面，使得栈内容变为 $cX$。\n\n2.  **猜测中心：** 这是关键的非确定性步骤。PDA 必须猜测何时到达字符串的中心。\n    *   **偶数长度回文：** 对于像 `abba` 这样的字符串，中心位于两个 `b` 之间。在读取 `ab` 之后，栈中包含 `baZ_0`（从底到顶）。PDA 必须在不消耗任何输入符号的情况下，从推入状态 ($q_0$) 转换到弹出状态 ($q_1$)。实现这一点的规则是 $\\delta(q_0, \\epsilon, X) = \\{(q_1, X)\\}$（对于任意栈符号 $X$）。此规则保持栈不变，并转移到状态 $q_1$ 开始匹配阶段。\n    *   **奇数长度回文：** 对于像 `aba` 这样的字符串，中心是符号 `b`。在读取 `a` 之后，栈中包含 `aZ_0`。PDA 需要读取中心符号 `b`，但*不*执行任何栈操作，因为这个中心字符没有与之对应的部分。然后它必须转换到状态 $q_1$。实现这一点的规则是 $\\delta(q_0, a, X) = \\{(q_1, X)\\}$ 和 $\\delta(q_0, b, X) = \\{(q_1, X)\\}$（对于栈上的任意符号 $X$）。这些规则消耗一个输入符号（中间那个），但在转移到弹出状态 $q_1$ 之前保持栈不变。\n\n3.  **弹出阶段：** 一旦进入状态 $q_1$，PDA 就开始读取字符串的后半部分。对于它读取的每个输入符号，它必须与栈顶的符号相匹配。如果匹配，栈顶符号被弹出。例如，如果输入是 `a` 且栈顶是 `a`，自动机应该弹出 `a` 并保持在状态 $q_1$。所需的规则是 $\\delta(q_1, a, a) = \\{(q_1, \\epsilon)\\}$ 和 $\\delta(q_1, b, b) = \\{(q_1, \\epsilon)\\}$。输出中的 $\\epsilon$ 表示没有东西被推回栈中，这实际上是一次弹出操作。\n\n4.  **接受：** 在读取完整个字符串后，如果自动机成功匹配了后半部分的所有符号，栈应该只包含初始符号 $Z_0$。给定的接受规则 $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$ 允许自动机此时转换到最终状态 $q_2$，从而接受该字符串。空字符串也是一个回文。自动机可以通过在 $q_0$ 开始，立即采用 $\\epsilon$-转换 $\\delta(q_0, \\epsilon, Z_0) = \\{(q_1, Z_0)\\}$ 到达 $q_1$，然后采用接受转换 $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$ 来接受空字符串。\n\n现在，我们来评估给出的选项：\n\n*   **选项 A：** 规则 $\\delta(q_0, a, a) = \\{(q_1, \\epsilon)\\}$ 和 $\\delta(q_0, b, b) = \\{(q_1, \\epsilon)\\}$ 对于“猜测中心”来说是错误的。它们意味着要转换到状态 $q_1$，自动机必须读取一个与栈顶匹配的输入符号并将其弹出。这不符合先推入字符串前半部分再匹配后半部分的逻辑。\n\n*   **选项 B：** 这个选项只包含了用于猜测中心的规则 $\\delta(q_0, \\epsilon, X) = \\{(q_1, X)\\}$。这能正确处理偶数长度的回文，但没有提供处理奇数长度回文中心字符的方法。像 `aba` 这样的奇数长度回文会被拒绝，因为 PDA 在读取中间的 `b` 时没有定义的转换。\n\n*   **选项 C：** 这个选项提供了猜测中心和弹出阶段所需的完整规则集。\n    *   $\\delta(q_0, \\epsilon, X) = \\{(q_1, X)\\}$ 处理偶数长度的情况。\n    *   $\\delta(q_0, a, X) = \\{(q_1, X)\\}$ 和 $\\delta(q_0, b, X) = \\{(q_1, X)\\}$ 通过消耗中间符号而不改变栈来处理奇数长度的情况。\n    *   $\\delta(q_1, a, a) = \\{(q_1, \\epsilon)\\}$ 和 $\\delta(q_1, b, b) = \\{(q_1, \\epsilon)\\}$ 正确地实现了字符串后半部分的匹配和弹出。\n    这组规则是正确的。\n\n*   **选项 D：** 这个选项有正确的猜测中心规则，但其弹出规则是错误的。规则 $\\delta(q_1, a, b) = \\{(q_1, \\epsilon)\\}$ 意味着“如果输入是 `a`，则弹出 `b`”。这无法匹配回文。对于回文 `aba`，在推入 `a` 并读取中心 `b` 后，栈中包含 `aZ_0`。下一个输入是 `a`。这组规则没有为 $\\delta(q_1, a, a)$ 提供转换，因此自动机会卡住并拒绝。\n\n因此，唯一正确且完整的规则集在选项 C 中提供。", "answer": "$$\\boxed{C}$$", "id": "1424576"}, {"introduction": "上下文无关文法 (Context-Free Grammar, CFG) 可以有多种形式，但算法和证明通常需要一种标准化的格式，而乔姆斯基范式 (Chomsky Normal Form, CNF) 是其中最重要的标准形式之一。将任意 $CFG$ 转换为 $CNF$ 是一个重要的算法过程。掌握这个转换算法 [@problem_id:1424566] 不仅仅是一个理论练习，它也是使用某些解析算法（如 CYK 算法）的实际前提，并简化了形式语言理论中的许多证明。", "problem": "上下文无关文法（CFG）是一种形式文法，其中每条产生式规则都具有 $V \\rightarrow w$ 的形式，其中 $V$ 是一个单独的非终结符，而 $w$ 是一个由终结符和/或非终结符组成的字符串。\n\n如果一个 CFG 的每条产生式规则都符合以下形式之一，那么它就处于 Chomsky 范式 (CNF) 中：\n1. $A \\rightarrow BC$，其中 $A, B, C$ 是非终结符。\n2. $A \\rightarrow a$，其中 $A$ 是一个非终结符，而 $a$ 是一个终结符。\n此外，如果空字符串 $\\epsilon$ 属于该语言，则允许规则 $S \\rightarrow \\epsilon$，其中 $S$ 是开始符号，前提是 $S$ 不出现在任何规则的右侧。\n\n考虑以下上下文无关文法 $G$，其非终结符集合为 $V = \\{S, A, B\\}$，终结符集合为 $\\Sigma = \\{a, b\\}$，$S$ 为开始符号。产生式规则 $P$ 如下：\n$S \\rightarrow aSA$\n$A \\rightarrow bB$\n$B \\rightarrow S \\mid \\epsilon$\n\n你的任务是将文法 $G$ 转换为一个等价的 Chomsky 范式文法 $G'$。从以下选项中，选择一个正确表示 $G'$ 产生式规则集合的选项。在选项中，$S'$ 是新的开始符号，任何其他新的非终结符由 $V_x$ 或 $X_y$ 表示。\n\nA.\n$S' \\rightarrow V_a X_1$\n$S \\rightarrow V_a X_1$\n$A \\rightarrow V_b B$\n$B \\rightarrow V_a X_1$\n$X_1 \\rightarrow S A$\n$V_a \\rightarrow a$\n$V_b \\rightarrow b$\n\nB.\n$S' \\rightarrow V_a X_1$\n$S \\rightarrow V_a X_1$\n$A \\rightarrow V_b B$\n$A \\rightarrow b$\n$B \\rightarrow S$\n$B \\rightarrow V_a X_1$\n$X_1 \\rightarrow S A$\n$V_a \\rightarrow a$\n$V_b \\rightarrow b$\n\nC.\n$S' \\rightarrow V_a X_1$\n$S \\rightarrow V_a X_1$\n$A \\rightarrow V_b B$\n$A \\rightarrow b$\n$B \\rightarrow V_a X_1$\n$X_1 \\rightarrow S A$\n$V_a \\rightarrow a$\n$V_b \\rightarrow b$\n\nD.\n$S \\rightarrow V_a X_1$\n$A \\rightarrow V_b B$\n$A \\rightarrow b$\n$B \\rightarrow V_a X_1$\n$X_1 \\rightarrow S A$\n$V_a \\rightarrow a$\n$V_b \\rightarrow b$\n\nE.\n$S' \\rightarrow V_a S A$\n$S \\rightarrow V_a S A$\n$A \\rightarrow V_b B$\n$A \\rightarrow b$\n$B \\rightarrow V_a S A$\n$V_a \\rightarrow a$\n$V_b \\rightarrow b$", "solution": "我们从给定的文法开始，其非终结符为 $V=\\{S,A,B\\}$，终结符为 $\\Sigma=\\{a,b\\}$，开始符号为 $S$，产生式如下：\n$$\nS \\rightarrow aSA,\\quad A \\rightarrow bB,\\quad B \\rightarrow S \\mid \\epsilon.\n$$\n\n步骤 1：识别可空非终结符。由于 $B \\rightarrow \\epsilon$，所以 $B$ 是可空的。因为 $A \\rightarrow bB$，$A$ 可以推导出 $b$ 但不能推导出 $\\epsilon$，所以 $A$ 不是可空的。同样，$S$ 也不是可空的，因为它的规则 $S \\rightarrow aSA$ 包含终结符 $a$ 且右侧没有只由可空符号组成。\n\n步骤 2：消除 $\\epsilon$-产生式。移除 $B \\rightarrow \\epsilon$，并为每个包含 $B$ 的产生式添加一个省略 $B$ 的变体。唯一这样的产生式是 $A \\rightarrow bB$，它产生一个额外的 $A \\rightarrow b$。因此，在消除 $\\epsilon$ 之后，我们得到：\n$$\nS \\rightarrow aSA,\\quad A \\rightarrow bB \\mid b,\\quad B \\rightarrow S.\n$$\n\n步骤 3：消除单元产生式。唯一的单元产生式是 $B \\rightarrow S$。将其移除，并让 $B$ 采纳 $S$ 的产生式，即 $B \\rightarrow aSA$。我们得到：\n$$\nS \\rightarrow aSA,\\quad A \\rightarrow bB \\mid b,\\quad B \\rightarrow aSA.\n$$\n\n步骤 4：为 Chomsky 范式做准备，方法是在较长的右侧中隔离终结符并进行二元化。为出现在长度大于 1 的右侧中的终结符引入新的非终结符：\n$$\nV_{a} \\rightarrow a,\\quad V_{b} \\rightarrow b.\n$$\n在较长的右侧中替换终结符，并通过引入新变量 $X_{1}$ 将任何长度大于 $2$ 的右侧二元化：\n$$\nX_{1} \\rightarrow SA.\n$$\n然后转换\n$$\nS \\rightarrow aSA \\Rightarrow S \\rightarrow V_{a}SA \\Rightarrow S \\rightarrow V_{a}X_{1},\n$$\n$$\nB \\rightarrow aSA \\Rightarrow B \\rightarrow V_{a}SA \\Rightarrow B \\rightarrow V_{a}X_{1},\n$$\n和\n$$\nA \\rightarrow bB \\Rightarrow A \\rightarrow V_{b}B,\\quad A \\rightarrow b\\ \\text{（保留为终结符规则）}.\n$$\n\n步骤 5：引入一个新的开始符号 $S'$，它不出现在任何右侧。为避免单元产生式 $S' \\rightarrow S$，将 $S'$ 定义为直接镜像 $S$ 的产生式：\n$$\nS' \\rightarrow V_{a}X_{1}.\n$$\n\n将所有 CNF 形式的产生式收集起来，我们得到：\n$$\nS' \\rightarrow V_{a}X_{1},\\quad S \\rightarrow V_{a}X_{1},\\quad A \\rightarrow V_{b}B \\mid b,\\quad B \\rightarrow V_{a}X_{1},\\quad X_{1} \\rightarrow SA,\\quad V_{a} \\rightarrow a,\\quad V_{b} \\rightarrow b,\n$$\n这与选项 C 匹配。\n\n为什么其他选项无效：\n- A 忽略了 $A \\rightarrow b$，这是在消除 $B \\rightarrow \\epsilon$ 后所必需的，因此改变了语言。\n- B 保留了单元产生式 $B \\rightarrow S$，这在 CNF 中是不允许的。\n- D 缺少选项描述中指定的新开始符号 $S'$。\n- E 包含长度为 3 的右侧（例如，$S' \\rightarrow V_{a}SA$），违反了 CNF 的二元形式要求。\n\n因此，正确选项是 C。", "answer": "$$\\boxed{C}$$", "id": "1424566"}]}