## 引言
我们生活在一个由复杂计算驱动的时代，从模拟遥远星系的运行到日常发送的每一封电子邮件。但你是否曾想过，这一切宏伟的数字大厦，其最底层的基石究竟是什么？令人惊讶的是，所有这些复杂性都源于几个极其简单的概念，而理解它们是进入计算机科学殿堂的钥匙。本文旨在揭开这层神秘的面纱，深入探讨[计算理论](@article_id:337219)最核心的构件：字母表与字符串。我们常常使用信息，却很少思考信息本身是如何被定义、表示和操作的，本文就将填补这一认知上的空白。在接下来的内容中，我们将首先从零开始构建这些核心概念，探索信息编码的巨大威力；然后，我们将见证这些简单的元素如何应用于生物学、数据压缩和逻辑等广阔领域；最后，通过动手实践来巩固所学。现在，就让我们一同开始构建这个计算世界吧。

## 原理与机制

好的，让我们开始动手吧。我们已经讨论了这个领域是什么，但现在到了有趣的部分：我们将从头开始构建计算世界。我是说*真正地*从头开始。你可能会惊讶地发现，你发送的每一封电子邮件，观看的每一个视频，对遥远星系的每一次复杂模拟，都建立在一些简单到孩童都能掌握的概念之上。但这些简单概念的组合方式，才是所有魔力、美感和力量的所在。

### 信息的原子：字母表与字符串

首先，什么是信息？暂时忘掉那些花哨的定义。想象你有一串珠子。你有一大袋不同颜色的珠子——比如，红色、绿色和蓝色。你可以把它们拿出来，按你喜欢的任何顺序串在一起。“红、绿、蓝”。“蓝、蓝、红”。或者连续一千个蓝色珠子。

在我们的世界里，这袋可用颜色的集合被称为**字母表**。一个字母表，我们用希腊字母 $\Sigma$（Sigma）表示，它只是一个有限的符号集合。它不一定是字母！对于计算机来说，最重要的字母表是二进制字母表，即 $\Sigma = \{0, 1\}$。对于研究DNA的生物学家来说，字母表是 $\Sigma = \{A, C, G, T\}$，代表四种[核苷酸](@article_id:339332)碱基 [@problem_id:1411667]。

这些“珠子”或符号的序列，串在一起，就是我们所说的**字符串**。“10110”是二进制字母表上的一个字符串。“BANANA”是英文字母表上的一个字符串 [@problem_id:1411691]。很简单，对吧？最基本的操作就是把字符串一个接一个地粘在一起。我们称之为**连接**（concatenation）。如果你有字符串 $u = \text{“HELLO”}$ 和 $v = \text{“WORLD”}$，它们的连接 $uv$ 就是简单的“HELLOWORLD”。

我们决不能忘记一个非常特殊的、近乎哲学的字符串：**空字符串**。它是一个完全不含任何符号的字符串，长度为零。我们给它一个特殊的符号，$\epsilon$（epsilon）。它看似微不足道，但它对于字符串世界的重要性，就像数字零对于数学一样。它是连接操作的单位元：对于任何字符串 $w$，都有 $w\epsilon = \epsilon w = w$。

### 通用语言与编码的力量

我们有了这些字母表。但是，实验室里的机器可能理解像 $\{\text{ADD, SUB, MUL, LOAD}\}$ 这样的命令字母表 [@problem_id:1411684]，而你的计算机只懂 $\{0, 1\}$。它们如何交流？答案是整个科学领域中最深刻的思想之一：**编码**。我们可以用一个字母表的字符串来表示另一个字母表的符号。特别是，*任何*有限字母表都可以只用二进制来编码。

怎么做呢？假设我们有一个包含 $k$ 个符号的字母表。我们想用0和1给每个符号一个唯一的标识标签。如果我们使用长度为 $L$ 的二进制字符串，可以创建多少个唯一的标签？用一位，我们有两个：0, 1。用两位，我们有四个：00, 01, 10, 11。用 $L$ 位，我们可以创建 $2^L$ 个唯一标签。因此，要给每个符号一个唯一的标签，我们只需选择一个足够大的长度 $L$，使得 $2^L \ge k$。满足条件的最小长度是 $L = \lceil \log_2 k \rceil$。这个优美的小公式是信息论的一条基本定律 [@problem_id:1411647]。对于一个有 $k=113$ 个符号的字母表，我们会发现 $2^6 = 64$ 太小了，但 $2^7 = 128$ 足够了。所以，我们可以用一个唯一的7位二进制字符串来表示这113个符号中的每一个。

这意味着，在非常真实的意义上，二进制字母表是通用的。任何东西都可以被翻译成它。但这种翻译，即*表示*的行为，会带来惊人的后果。

让我们思考如何表示一个数字，比如 $N$。一个非常自然的方法是放下 $N$ 个石子，或者写一个由 $N$ 个1组成的字符串。我们称之为**一元**（unary）表示。表示 $N$ 的字符串长度就是 $N$。但我们刚刚发现的二进制编码要聪明得多。它所需的位数，即其长度，大约是 $\log_2 N$。

这有什么区别？我们来玩个游戏。假设我们寻找一个数字 $N$，它简单的一元表示比它聪明的二[进制表示](@article_id:641038)长一百万倍 [@problem_id:1411687]。我们试图解这个方程：$N = 1,000,000 \times (\lfloor \log_2 N \rfloor + 1)$。这看起来很吓人，但通过尝试几个值，我们会发现对于二进制长度 $L_B(N) = 25$ 时，数字是 $N = 25,000,000$。不等式也完美成立：$2^{24} \le 25,000,000 < 2^{25}$。想一想！用一元表示数字两千五百万需要两千五百万个“1”。而用二进制，只需要25位。$N$ 和 $\log_2 N$ 之间的指数级差异不仅仅是件奇闻轶事。它正是计算机能够处理巨大数字的原因。编码方案的选择，可能意味着一个计算需要一秒钟完成，还是需要比宇宙年龄还长的时间才能完成。

我们还可以变得更聪明。像 $\text{ADD} \to 00$ 这样的固定字典仅仅是个开始。我们可以创建上下文感知的编码。例如，如果我们对一个命令进行编码时，如果它与前一个命令相同，就用不同的方式编码，会怎么样？这可以压缩含有大量重复的序列。这是一种简单的[行程长度编码](@article_id:336918)（run-length encoding），一种基本的[数据压缩](@article_id:298151)技术，表明编码行为本身也可以是一个[算法](@article_id:331821)过程 [@problem_id:1411684]。

### 字符串的秘密代数

既然我们有了字符串，就来玩玩它们吧。我们已经见过了连接，现在来看另一个简单的操作：**反转**（reversal）。一个字符串 $w$ 的反转，记作 $w^R$，就是把字符串倒过来写。例如，“HELLO”的反转是“OLLEH”。

如果我们将两个字符串 $u$ 和 $v$ 连接起来，然后再反转结果，会发生什么？即 $(uv)^R$。想象一下先穿袜子再穿鞋。要反转这个过程，你必须先脱鞋，再脱袜子。字符串也是如此！$(uv)^R = v^R u^R$。这是一个基本属性。

但这里有一个有趣的问题：在什么特殊情况下，那个“错误”的恒等式 $(uv)^R = u^R v^R$ 才会成立呢？[@problem_id:1411622]。如果我们将标准形式和非标准形式划等号，我们得到 $v^R u^R = u^R v^R$。如果我们再将这个等式的两边都反转（因为 $(S^R)^R = S$），我们会得到一个惊人简单的条件：$uv = vu$。这两个字符串必须是可交换的（commute）！

这似乎很简单。什么时候两个字符串是可交换的？你可能会说，“只有当它们是同一个字符串时！”但事实并非如此。“A”和“AA”是可交换的。“AB”和“ABAB”也是可交换的。字符串数学（称为“词语组合学”）中一个深刻而优美的结果表明，两个字符串 $u$ 和 $v$ 是可交换的，*当且仅当*它们都是同一个更小的字符串的幂。也就是说，必须存在某个根字符串 $w$，使得 $u=w^i$ 和 $v=w^j$ 对于某些整数 $i$ 和 $j$ 成立。这揭示了字符串中隐藏的一种结构：一种周期性。

就像任何整数都可以分解为素数一样，任何字符串都可以归结为一个唯一的**本原根**（primitive root）——一个本身不是任何更小字符串的幂的字符串 [@problem_id:1411621]。字符串“baababa”的长度是7，一个素数，所以它不可能是任何更小字符串的幂。它是本原的。字符串“ababab”是 $(ab)^3$；它的本原根是“ab”。字符串拥有唯一的“原子”根这一思想，是支配这些简单序列的优雅而隐秘的数学的又一块拼图。

在我们继续之前，让我们澄清两个经常引起混淆的术语：**子串**（substring）和**[子序列](@article_id:308116)**（subsequence）[@problem_id:1411691]。
*   **子串**是一个较大字符串中连续、不间断的一部分。“NAN”是“BANANA”的子串，因为你可以在其中找到它作为一个完整的块。
*   **[子序列](@article_id:308116)**则是通过从字符串中删除零个或多个字符，但保持其余字符的原始顺序而形成的。“BNA”是“BANANA”的子序列（取第1位的B，第3位的N，第4位的A）。

所有子串也都是子序列，但反之不然。这个区别在许多[算法](@article_id:331821)中至关重要，从文本搜索到[DNA分析](@article_id:307706)。

### 从单个字符串到无限世界：语言

到目前为止，我们讨论的都是单个字符串。但真正的力量来自于我们开始讨论*字符串的集合*。在[形式语言理论](@article_id:327795)中，一个字符串的集合被称为**语言**（language）。就是这样。这是一个非常宽泛的定义。

由字母表 $\Sigma$ 可以构成的*所有可能的字符串*的集合被称为**克林闭包**（Kleene closure），记作 $\Sigma^*$。这是我们的论域[全集](@article_id:327907)。它包括空字符串 $\epsilon$。任何在 $\Sigma$ 上的语言都只是这个无限[全集](@article_id:327907)的某个子集。

例如，在字母表 $\Sigma = \{a, b\}$ 上，我们可以定义一个语言 $L_1$ 为所有'a'和'b'数量完全相等且长度至少为4的字符串的集合 [@problem_id:1411664]。字符串“aabb”就在这个语言中，字符串“ababab”也是。而像“aba”这样的字符串则*不*在 $L_1$ 中，因为它的长度太短了。

因为语言只是集合，所以我们可以对它们使用集合论的所有工具。我们可以讨论两个语言的并集（$L_A \cup L_B$，即在 $L_A$ 或 $L_B$ 中的字符串集合）、它们的交集等等。我们甚至可以对它们的大小进行组合推理 [@problem_id:1411667]。我们还可以通过一个语言*不是*什么来定义它。语言 $L$ 的**补集**（complement），记作 $\bar{L}$，是全集 $\Sigma^*$ 中所有*不*在 $L$ 中的字符串的集合。所以，对于我们的语言 $L_1$，字符串“aba”就在其[补集](@article_id:306716) $\bar{L_1}$ 中。

这把我们带到了最后一个，也许是构建语言最强大的工具：**克林星号**（Kleene star）。如果 $L$ 是一个语言，那么 $L^*$ 是你通过从 $L$ 中取出*任意*数量（零个或多个）的字符串并以*任意*顺序将它们连接在一起而得到的语言。

这个操作有一个非常清晰的属性。假设你有一个有限的语言（一个有限的字符串集合）叫做 B。它的克林星号 $B^*$ 何时是无限的？看起来它似乎应该总是无限的，对吧？你可以一直连接下去。但如果你的语言 $B$ 只是 $\{\epsilon\}$ 呢？那么无论你从 $B$ 中取出多少个字符串并连接起来，你得到的永远只有 $\epsilon$。结果 $B^*$ 就只是 $\{\epsilon\}$，是有限的。如果你的语言 $B$ 是空集 \{\} 呢？那么你只能从中取出零个字符串，这会得到空字符串 $\epsilon$。所以 $(\{\})^* = \{\epsilon\}$，也是有限的。

事实证明，有一个简单而优美的规则：对于任何语言 $L$，语言 $L^*$ 是有限的*当且仅当*$L$ 除了可能包含空字符串外，不包含任何其他字符串。换句话说，$L^*$ 是无限的，当且仅当 $L$ 包含至少一个非空字符串 [@problem_id:1411681]。这一个操作，克林星号，是我们从一个有限的描述（一个有限的字符串集合）生成一个无限但高度结构化世界的首要工具。

最后，我们可以结合这些思想来分析一个玩具计算系统。想象一个系统，其中的字符串通过反复删除任何“xy”或“z”子串来进行“规范化” [@problem_id:1411653]。那些无法再被简化的字符串形成了一个“稳定”的语言。然后我们可以问：是否存在一个“中性密钥”——一个字符串，当它附加到一个稳定字符串上然后进行规范化后，能返回原始的稳定字符串？解决这个问题需要思考规范化规则如何在两个连接字符串的边界上相互作用。这是一个微观世界，反映了我们如何推理程序和计算过程：定义对象，定义转换规则，并分析系统涌现出的属性。

从简单的符号，到字符串，到支配它们的代数，再到我们可以构建的无限语言——这就是整个计算机科学大厦赖以建立的基石。这是一个源于惊人简单性，却又拥有无穷复杂性与美的世界。