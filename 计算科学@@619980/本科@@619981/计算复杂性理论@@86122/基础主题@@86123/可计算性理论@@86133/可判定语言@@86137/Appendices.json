{"hands_on_practices": [{"introduction": "要真正理解可判定性，最好的方法莫过于亲手设计一个判定器。这个练习将带你深入图灵机的核心，为二进制加法语言 $L = \\{x+y=z\\}$ 设计判定算法。通过这个过程，你将把我们熟悉的列竖式加法法则，转化为图灵机在纸带上的具体操作，深刻体会图灵机如何利用有限状态和纸带存储来完成计算。", "problem": "考虑字母表 $\\Sigma = \\{0, 1, +, =\\}$ 上的语言 $L$。该语言由所有表示有效二进制加法的字符串组成。一个字符串 $w$ 属于 $L$ 当且仅当它具有 $x+y=z$ 的形式，其中 $x, y, z$ 是由 $\\{0, 1\\}$ 中字符组成的非空字符串，并且二进制字符串 $x$ 的数值加上二进制字符串 $y$ 的数值等于二进制字符串 $z$ 的数值。例如，字符串 \"101+10=111\" 属于 $L$，因为二进制数 101 (十进制 5) 加上二进制数 10 (十进制 2) 等于二进制数 111 (十进制 7)。字符串 \"1+1=10\" 也属于 $L$。然而，字符串 \"11+1=101\" 不属于 $L$。\n\n我们要设计一台确定性单带图灵机 (TM) 来判定这个语言 $L$。我们关心的是这台图灵机在执行初始扫描，验证输入字符串恰好包含一个 '+' 符号和一个 '=' 符号，并且 '+' 出现在 '=' 之前之后的核心计算逻辑。\n\n从这个经过验证的格式开始，以下哪种高层描述概述了图灵机完成判定过程的正确步骤？\n\nA. 图灵机找到操作数字符串 $x$ 和 $y$。它用前导零填充较短的操作数，使其长度与较长的操作数相同。然后，它从右到左逐位移动，对填充后的 $x$ 和 $y$ 的相应位执行按位异或 (XOR) 操作。然后将结果字符串与字符串 $z$ 逐位比较。当且仅当异或操作的结果与 $z$ 完全相同时，图灵机接受。\n\nB. 图灵机将 '+' 和 '=' 符号替换为空白符号。然后它重复扫描整个带子。在每次扫描中，它找到对应于 $x$ 的字符串中最右边的 '1' 和对应于 $y$ 的字符串中最右边的 '1'，将两者都变为 '0'，然后在对应于 $z$ 的字符串中找到最左边的 '0' 并将其变为 '1'。如果在此过程结束时（$x$ 或 $y$ 中不再有 '1'），字符串 $z$ 全由 '1' 组成，则图灵机接受。\n\nC. 图灵机从右向左工作。它标记 $z$ 的最右边一位，然后是 $y$ 的最右边一位，然后是 $x$ 的最右边一位。如果来自 $x$ 和 $y$ 的位的和与来自 $z$ 的位不匹配（例如，如果 $x$ 有一个 '1'，$y$ 有一个 '0'，而 $z$ 有一个 '0'），则拒绝。它不使用其内部状态来处理进位。如果和为 2 (来自 '1'+'1')，它仅检查 $z$ 中的相应位是否为 '0'。它继续这个过程，一次向左移动一位，直到所有位都被标记。如果所有检查都通过，它就接受。\n\nD. 图灵机使用其有限控制器（内部状态）来记住一个进位位，初始设置为 0。它从右到左遍历这三个数。在每一步中，它读取 $x$ 和 $y$ 的最右边未标记的位（将较短数字的末端视为 0），并将它们与进位相加。它验证和模 2 的结果与 $z$ 的相应位相匹配。如果不匹配，图灵机就拒绝。然后它将进位位更新为和除以 2 的整数部分。为避免重复处理这些位，它会标记每个处理过的位（例如，用 $0_m$ 替换 '0'，用 $1_m$ 替换 '1'）。在处理完 $x$ 和 $y$ 的所有位之后，它验证 $z$ 的任何剩余位是否与最终的进位值一致。如果所有检查都通过，图灵机就接受。", "solution": "我们假设输入已被验证，恰好包含一个 '+' 和一个 '=' 符号，且 '+' 在 '=' 的左边，并且 $x, y, z$ 是三个非空的二进制子串。判定 $L$ 的正确性可以归结为检查带进位的标准二进制加法：对于从右到左的每个位位置 $i$，如果 $a_{i}$ 是 $x$ 的第 $i$ 位（如果 $i$ 超出长度则为 $0$），$b_{i}$ 是 $y$ 的第 $i$ 位（或 $0$），$k$是该步骤的输入进位，那么期望的输出位是\n$$\ns_{i} \\equiv a_{i} + b_{i} + k \\pmod{2},\n$$\n而输出进位是\n$$\nk' = \\left\\lfloor \\frac{a_{i} + b_{i} + k}{2} \\right\\rfloor.\n$$\n一个正确的图灵机必须在从右到左移动时精确地实现这个逻辑，并防止重复处理数位（例如，通过标记已处理的符号）。\n\n我们现在来分析每个选项：\n\nA. 该选项建议用前导零填充较短的操作数，并计算填充后的 $x$ 和 $y$ 的按位异或，然后与 $z$ 比较。按位异或对应于在每个位置计算 $(a_{i} + b_{i}) \\bmod 2$，但从不传播进位。因此它没有实现 $k' = \\left\\lfloor (a_{i} + b_{i} + k)/2 \\right\\rfloor$。一个简单的反例是 $x=1, y=1, z=10$。$1$ 和 $1$ 的异或结果是 $0$，这与 $z=10$ 不匹配，所以这个过程会拒绝一个有效的字符串。因此 A 是不正确的。\n\nB. 该选项重复地将 $x$ 中最右边的 '1' 与 $y$ 中最右边的 '1' 配对，并将 $z$ 中最左边的 '0' 翻转为 '1'，如果 $z$ 最后全变成 '1' 则接受。这个过程忽略了位置权重 $2^{i}$，只操作计数和极端位置，因此它不对应于带进位的二进制加法。例如，考虑 $x=1, y=0, z=1$，这是有效的。由于 $y$ 中没有 '1'，没有最右边的 '1' 对可以处理；算法无法继续消除 $x$ 中的 '1'，也无法达到一个正确的接受状态。因此它无法接受一个有效输入，也就不能判定 $L$。因此 B 是不正确的。\n\nC. 该选项在每个位置检查两个操作数位之和与 $z$ 位是否相符，但明确不使用任何进位。使用上面的公式，这错误地强制在所有位置执行 $s_{i} \\equiv a_{i} + b_{i} \\pmod{2}$ 且 $k \\equiv 0$。对于 $x=1, y=1, z=10$，在最低有效位，我们有 $a_{0}+b_{0}=2$，$z_{0}=0$，所以它通过了那个位置，但在下一个位置，它实际上是在检查 $0+0$ 与 $z_{1}=1$ 是否相符，并拒绝。因此 C 错误地拒绝了一个有效输入。因此 C 是不正确的。\n\nD. 这与带进位的二进制加法标准算法相匹配。图灵机在其有限控制器中使用一个进位位 $k \\in \\{0,1\\}$，初始为 $0$。在每一步中它：\n- 定位 $x$ 和 $y$ 最右边的未标记位（将超出左端的位置视为 $0$），以及 $z$ 中相应的最右边未标记位。\n- 计算 $t = a_{i} + b_{i} + k$，检查 $z_{i} \\equiv t \\bmod 2$ 是否成立。如果不成立，则拒绝。\n- 将进位更新为 $k' = \\left\\lfloor t/2 \\right\\rfloor$。\n- 标记已处理的位（例如，用 $0_{m}$ 替换 $0$，用 $1_{m}$ 替换 $1$）以避免重复处理，并向左移动一个位置重复操作。\n\n在 $x$ 和 $y$ 的所有位都被标记之后，它验证 $z$ 的剩余位是否与最终的进位值一致：如果 $k=1$，它要求 $z$ 恰好有一个剩余位为 $1$，后面跟着的都是 $0$（或者如果之前已经匹配，则没有更多位）；如果 $k=0$，它要求所有剩余的 $z$ 位都为 $0$。这正是\n$$\ns_{i} \\equiv a_{i} + b_{i} + k \\pmod{2}, \\quad k' = \\left\\lfloor \\frac{a_{i} + b_{i} + k}{2} \\right\\rfloor,\n$$\n的语义，通过从右到左实现并加以标记来确保终止性和正确性。因此 D 概述了判定 $L$ 的一个正确决策过程。\n\n结论：只有 D 为图灵机在初始格式检查后判定 $L$ 提供了正确的高层描述。", "answer": "$$\\boxed{D}$$", "id": "1419574"}, {"introduction": "并非所有可判定语言都能被下推自动机这样的简单模型所识别，有些语言需要图灵机更强的计算能力。本练习 [@problem_id:1419581] 以一个假设的生物高分子合成规则为背景，要求你判定语言 $L = \\{ A^i B^j C^{i \\times j} \\mid i, j \\ge 1 \\}$ 在乔姆斯基谱系中的确切位置。通过证明该语言是可判定的但非上下文无关的，你将更清晰地认识到图灵机相较于下推自动机的强大能力。", "problem": "一个生物工程团队正在研究模仿脱氧核糖核酸（DNA）某些特性的合成聚合物。这些聚合物是由包含三种不同单体（A型、B型和C型）的字母表构成的字符串。一个聚合物当且仅当它遵循一个严格的构成规则时，才被称作“结构稳定”的。该规则要求聚合物必须由一个或多个A型单体的连续块，紧接着一个或多个B型单体的连续块，再紧接着一个或多个C型单体的连续块组成。此外，一个关键的稳定性条件是，C型单体的数量必须恰好等于A型单体的数量与B型单体的数量的乘积。\n\n设 $L$ 是表示字母表 $\\Sigma = \\{A, B, C\\}$ 上所有结构稳定的聚合物的字符串的语言。该语言可以形式化地表示为 $L = \\{ A^i B^j C^k \\mid i \\ge 1, j \\ge 1, \\text{ and } k = i \\times j \\}$。\n\n根据Chomsky层次结构和计算理论，对于语言 $L$ 最精确的分类是什么？\n\nA. $L$ 是一个正则语言。\nB. $L$ 是一个上下文无关语言，但不是正则语言。\nC. $L$ 是一个可判定语言（也称为递归语言），但不是上下文无关语言。\nD. $L$ 是一个图灵可识别语言（也称为递归可枚举语言），但不是可判定语言。\nE. $L$ 不是一个图灵可识别语言。", "solution": "我们分析字母表 $\\Sigma = \\{A,B,C\\}$ 上的形式语言 $L = \\{ A^{i} B^{j} C^{k} \\mid i \\ge 1, j \\ge 1, k = ij \\}$。\n\n首先，$L$ 不是正则的。使用反证法，假设 $L$ 是正则的。考虑正则语言 $R_{1} = A^{+} B C^{+}$，它强制有且仅有一个 $B$。那么\n$$\nL \\cap R_{1} = \\{ A^{i} B C^{i} \\mid i \\ge 1 \\}.\n$$\n定义同态 $h$ 为 $h(A) = a$、$h(B) = \\epsilon$ 和 $h(C) = c$。根据正则语言在与正则语言的交集运算和同态运算下的封闭性，如果 $L$ 是正则的，那么 $h(L \\cap R_{1})$ 也将是正则的。但是\n$$\nh(L \\cap R_{1}) = \\{ a^{i} c^{i} \\mid i \\ge 1 \\},\n$$\n根据正则语言的泵引理，该语言不是正则的。这个矛盾表明 $L$ 不是正则的。\n\n其次，$L$ 不是上下文无关的。令 $\\Psi(L) \\subseteq \\mathbb{N}^{3}$ 表示 $L$ 的Parikh图像，即\n$$\n\\Psi(L) = \\{ (i,j,k) \\in \\mathbb{N}^{3} \\mid i \\ge 1, j \\ge 1, k = i j \\}.\n$$\n根据Parikh定理，任何上下文无关语言的Parikh图像都是半线性的。假设 $L$ 是上下文无关的以导出矛盾。那么 $\\Psi(L)$ 将是半线性的。将 $\\Psi(L)$ 与线性集\n$$\nM = \\{ (n,n,k) \\mid n \\in \\mathbb{N}, k \\in \\mathbb{N} \\}\n$$\n求交集，半线性集在与线性集的交集下是封闭的。我们得到\n$$\n\\Psi(L) \\cap M = \\{ (n,n,k) \\mid k = n^{2}, n \\ge 1 \\}.\n$$\n将其投影到第三个坐标（这是一个线性映射，半线性集在其下是封闭的），得到完全平方数集合\n$$\n\\{ n^{2} \\mid n \\ge 1 \\}.\n$$\n然而，$\\mathbb{N}$ 的半线性子集恰好是算术级数的有限并集，而平方数集合不是算术级数的有限并集（因为连续平方数之间的差值是无界的）。这个矛盾表明 $L$ 不是上下文无关的。\n\n第三，$L$ 是可判定的（递归的）。一个确定性图灵机可以通过以下步骤判定 $L$：\n1) 验证输入的形式是否为 $A^{+} B^{+} C^{+}$。\n2) 设 $i$ 是 $A$ 符号的数量，$j$ 是 $B$ 符号的数量。对于 $j$ 个 $B$ 中的每一个，从 $C$ 块中划掉恰好 $i$ 个符号（通过模拟重复加法来检查 $k = i j$）。当且仅当处理完所有 $B$ 符号后，所有的 $C$ 符号都恰好被用完，没有剩余也无不足，则接受。这个过程对所有输入都会停机，因此 $L$ 是可判定的。\n\n综合以上分析，$L$ 是可判定的，但不是上下文无关的，也不是正则的。在所提供的选项中，最精确的分类是 $L$ 是一个可判定语言（递归语言），但不是上下文无关语言。", "answer": "$$\\boxed{C}$$", "id": "1419581"}, {"introduction": "在可计算性理论中，一个强大的思想是“归约”，即利用一个已有的判定器去解决一个新问题。这个练习 [@problem_id:1419579] 将引导你进行一次这样的思维构建：假设你有一个判定上下文无关文法（CFG）所生成的语言是否为空的“黑箱”工具，你如何利用它来判定一个下推自动机（PDA）所接受的语言是否为*非空*？这个过程不仅巩固了 PDA 和 CFG 之间的等价关系，更展现了计算理论中模块化解决问题的优雅之处。", "problem": "假设您在一家开发编译器构造工具的公司工作。您得到一台特殊的图灵机，我们称之为 $D_{EMPTY\\_GRAMMAR}$，它充当语言 $E_{CFG}$ 的判定器。语言 $E_{CFG}$ 被定义为所有上下文无关文法（CFG）的字符串编码 $\\langle G \\rangle$ 的集合，其中该文法生成的语言 $L(G)$ 是空集（$\\emptyset$）。换句话说，对于输入 $\\langle G \\rangle$ ，判定器 $D_{EMPTY\\_GRAMMAR}$ 在 $L(G) = \\emptyset$ 时接受，在 $L(G) \\neq \\emptyset$ 时拒绝。\n\n您的任务是利用这个现有工具来设计一个新的判定器，我们称之为 $D_{NONEMPTY\\_AUTOMATON}$。这个新的判定器必须解决下推自动机（PDA）的非空性问题。具体来说，对于任何给定的 PDA $P$，判定器 $D_{NONEMPTY\\_AUTOMATON}$ 在 PDA 的语言 $L(P)$ 包含至少一个字符串（即 $L(P) \\neq \\emptyset$）时应接受其编码 $\\langle P \\rangle$，在 $L(P)$ 为空时应拒绝 $\\langle P \\rangle$。\n\n以下哪项描述准确地概述了使用给定的判定器 $D_{EMPTY\\_GRAMMAR}$ 来构造 $D_{NONEMPTY\\_AUTOMATON}$ 的有效高层算法？请注意，$\\langle P \\rangle$ 表示输入 PDA $P$ 的字符串编码。\n\nA. 将 PDA $P$ 转换为等价的正则表达式 $R$。在 $R$ 的编码上运行 $D_{EMPTY\\_GRAMMAR}$。如果 $D_{EMPTY\\_GRAMMAR}$ 接受，则 $D_{NONEMPTY\\_AUTOMATON}$ 拒绝。否则，$D_{NONEMPTY\\_AUTOMATON}$ 接受。\nB. 将 PDA $P$ 转换为等价的上下文无关文法 $G$。在编码 $\\langle G \\rangle$ 上运行 $D_{EMPTY\\_GRAMMAR}$。如果 $D_{EMPTY\\_GRAMMAR}$ 接受，则 $D_{NONEMPTY\\_AUTOMATON}$ 拒绝。否则，$D_{NONEMPTY\\_AUTOMATON}$ 接受。\nC. 将 PDA $P$ 转换为等价的上下文无关文法 $G$。在编码 $\\langle G \\rangle$ 上运行 $D_{EMPTY\\_GRAMMAR}$。如果 $D_{EMPTY\\_GRAMMAR}$ 接受，则 $D_{NONEMPTY\\_AUTOMATON}$ 接受。否则，$D_{NONEMPTY\\_AUTOMATON}$ 拒绝。\nD. 这是不可能的。确定一个 PDA 是否接受任何字符串的问题是不可判定的，因此无法构造像 $D_{NONEMPTY\\_AUTOMATON}$ 这样的判定器。\nE. 构造一个新的 PDA $P'$，它接受 $P$ 的补语言。将这个新的 PDA $P'$ 转换为等价的上下文无关文法 $G'$。在 $\\langle G' \\rangle$ 上运行 $D_{EMPTY\\_GRAMMAR}$。如果 $D_{EMPTY\\_GRAMMAR}$ 接受，则 $D_{NONEMPTY\\_AUTOMATON}$ 接受。否则，它拒绝。", "solution": "我们给定一个用于语言 $E_{CFG}=\\{\\langle G\\rangle:\\text{$G$ is a CFG and }L(G)=\\emptyset\\}$ 的判定器 $D_{EMPTY\\_GRAMMAR}$。我们必须构建一个判定器 $D_{NONEMPTY\\_AUTOMATON}$，它在输入为 PDA $P$ 的编码 $\\langle P\\rangle$ 时，当且仅当 $L(P)\\neq\\emptyset$ 时接受，当且仅当 $L(P)=\\emptyset$ 时拒绝。\n\n关键原理：对于每个 PDA $P$，都存在一个可有效构造的 CFG $G$，使得 $L(G)=L(P)$，反之亦然。标准的 PDA 到 CFG 的构造过程是完全的且会终止。\n\n使用 $D_{EMPTY\\_GRAMMAR}$ 的算法：\n1. 对于输入 $\\langle P\\rangle$，有效地构造一个 CFG $G$，使得 $L(G)=L(P)$。\n2. 在 $\\langle G\\rangle$ 上运行 $D_{EMPTY\\_GRAMMAR}$。\n3. 如果 $D_{EMPTY\\_GRAMMAR}$ 接受（即 $L(G)=\\emptyset$），则输出拒绝；否则（即 $L(G)\\neq\\emptyset$），输出接受。\n\n正确性：\n- 可靠性（Soundness）：如果 $D_{EMPTY\\_GRAMMAR}$ 接受，则 $L(G)=\\emptyset$。由于 $L(G)=L(P)$，因此 $L(P)=\\emptyset$，所以 $D_{NONEMPTY\\_AUTOMATON}$ 必须拒绝。如果 $D_{EMPTY\\_GRAMMAR}$ 拒绝，则 $L(G)\\neq\\emptyset$，因此 $L(P)\\neq\\emptyset$，所以 $D_{NONEMPTY\\_AUTOMATON}$ 接受。\n- 终止性（Termination）：PDA 到 CFG 的转换会终止，并且 $D_{EMPTY\\_GRAMMAR}$ 是一个判定器，因此组合起来的程序对所有输入都会停机。\n\n选项评估：\n- A 是无效的，因为一个通用的 PDA 不一定等价于一个正则表达式；PDA 识别的是上下文无关语言，而这些语言通常不是正则的。\n- B 与上述算法匹配，是有效的。\n- C 颠倒了来自 $D_{EMPTY\\_GRAMMAR}$ 的接受/拒绝映射，因此是错误的。\n- D 是错误的；PDA 的非空性问题通过 CFG 等价性和空性检查是可判定的。\n- E 是无效的，因为上下文无关语言通常在补运算下不封闭，因此为 $L(P)$ 的补语言构造一个 PDA（或 CFG）通常是不可能的。\n\n因此，正确的高层算法在选项 B 中描述。", "answer": "$$\\boxed{B}$$", "id": "1419579"}]}