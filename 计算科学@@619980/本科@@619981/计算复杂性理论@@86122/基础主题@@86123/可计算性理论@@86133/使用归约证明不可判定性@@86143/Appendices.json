{"hands_on_practices": [{"introduction": "第一个练习将帮助你热身。它使用一个清晰、结构化的模板来介绍归约的核心逻辑。通过决定新机器 $M'$ 应如何根据原始机器 $M$ 的计算结果来行动，你将练习支撑所有通过归约证明不可判定性的“当且仅当”推理，并掌握从一个已知的不可判定问题（如 $A_{TM}$）出发，构建证明的基本模式 [@problem_id:1468814]。", "problem": "在可计算性理论中，证明一个问题是不可判定的一个核心方法是，证明如果我们能解决它，我们也能解决一个已知的不可判定问题。这种技术被称为归约。一个基础的不可判定问题是图灵机（TM）的接受问题，记作 $A_{TM}$。语言 $A_{TM}$ 被定义为所有序偶 $\\langle M, w \\rangle$ 的集合，其中 $M$ 是一个图灵机的描述，$w$ 是一个 $M$ 接受的输入串。\n\n我们来考虑一个与形式语言的特定属性相关的新判定问题。如果一个自然数 $n$ 是两个素数（这两个素数不必是不同的）的乘积，那么它被称为**半素数**。例如，$4 = 2 \\times 2$，$6 = 2 \\times 3$ 和 $9 = 3 \\times 3$ 是半素数，而 $1$、$7$ 和 $12$ 不是。\n\n现在，定义语言 $SEMIPRIME_{ONLY}$ 如下：\n$SEMIPRIME_{ONLY} = \\{ \\langle M \\rangle \\mid M \\text{ 是一个图灵机，其语言 } L(M) \\text{ 非空，且对于每个字符串 } s \\in L(M), \\text{ 其长度 } |s| \\text{ 是一个半素数} \\}$。\n\n为了证明 $SEMIPRIME_{ONLY}$ 是不可判定的，我们可以构造一个从 $A_{TM}$ 出发的归约。其策略是，取 $A_{TM}$ 的一个任意实例 $\\langle M, w \\rangle$，并将其转换为 $SEMIPRIME_{ONLY}$ 的一个实例 $\\langle M' \\rangle$，使得 $M$ 接受 $w$ 当且仅当 $\\langle M' \\rangle \\in SEMIPRIME_{ONLY}$。\n\n构造出的机器 $M'$ 接受一个字符串 $x$ 作为其输入。其行为由以下高级算法定义：\n\n**$M'(x)$ 的算法：**\n1.  对于输入 $x$，首先在固定字符串 $w$ 上模拟机器 $M$。\n2.  如果在 $w$ 上对 $M$ 的模拟停机并接受：\n    则在原始输入 $x$ 上执行一个名为 `ACCEPT_BEHAVIOR` 的过程。\n3.  如果在 $w$ 上对 $M$ 的模拟停机并拒绝，或者无限循环：\n    则在原始输入 $x$ 上执行一个名为 `REJECT_BEHAVIOR` 的过程。\n\n以下哪一对关于 (`ACCEPT_BEHAVIOR`, `REJECT_BEHAVIOR`) 的定义能正确确保此构造构成一个从 $A_{TM}$ 到 $SEMIPRIME_{ONLY}$ 的有效归约？\n\nA. `ACCEPT_BEHAVIOR`：“检查 $|x|$ 是否为半素数。如果是，则接受 $x$。否则，拒绝 $x$。”\n   `REJECT_BEHAVIOR`：“拒绝 $x$。”\n\nB. `ACCEPT_BEHAVIOR`：“拒绝 $x$。”\n   `REJECT_BEHAVIOR`：“检查 $|x|$ 是否为半素数。如果是，则接受 $x$。否则，拒绝 $x$。”\n\nC. `ACCEPT_BEHAVIOR`：“接受 $x$。”\n   `REJECT_BEHAVIOR`：“拒绝 $x$。”\n\nD. `ACCEPT_BEHAVIOR`：“检查 $|x|$ 是否为素数。如果是，则接受 $x$。否则，拒绝 $x$。”\n   `REJECT_BEHAVIOR`：“拒绝 $x$。”\n\nE. `ACCEPT_BEHAVIOR`：“检查 $|x|$ 是否为半素数。如果是，则接受 $x$。否则，拒绝 $x$。”\n   `REJECT_BEHAVIOR`：“当且仅当 $|x| = 4$ 时接受 $x$。”", "solution": "我们寻找一个可计算映射 $f$，使得对于 $A_{TM}$ 的每个输入 $\\langle M,w\\rangle$，$f(\\langle M,w\\rangle)=\\langle M'\\rangle$ 满足\n$$\n\\langle M,w\\rangle \\in A_{TM} \\iff \\langle M'\\rangle \\in SEMIPRIME_{ONLY},\n$$\n其中\n$$\nSEMIPRIME_{ONLY}=\\{\\langle N\\rangle \\mid L(N)\\neq \\emptyset \\text{ 且 } (\\forall s\\in L(N))\\; |s| \\text{ 是半素数}\\}.\n$$\n根据构造，$M'$ 在输入 $x$ 上首先模拟 $w$ 上的 $M$。如果 $M$ 接受 $w$，$M'$ 会在 $x$ 上执行 ACCEPT\\_BEHAVIOR；如果 $M$ 拒绝 $w$（或未能接受），$M'$ 会执行 REJECT\\_BEHAVIOR（或者永不接受任何输入，这仍然导致 $L(M')=\\emptyset$）。要成为一个有效的归约，所选择的行为必须确保：\n- 如果 $M$ 接受 $w$，那么 $L(M')\\neq \\emptyset$ 且每个被接受的字符串都具有半素数长度。\n- 如果 $M$ 不接受 $w$（拒绝或不停机），那么 $\\langle M'\\rangle \\notin SEMIPRIME_{ONLY}$，这一条件在 $L(M')=\\emptyset$ 或 $L(M')$ 包含某个长度不是半素数的字符串时得到满足。\n\n我们逐一分析每个选项：\n\n选项 A：\n- ACCEPT\\_BEHAVIOR：当且仅当 $|x|$ 是半素数时接受 $x$；否则拒绝。\n- REJECT\\_BEHAVIOR：拒绝 $x$。\n情况 1：$M$ 接受 $w$。那么 $L(M')=\\{x \\mid |x| \\text{ 是半素数}\\}$。这个集合非空（例如，存在长度为 $4$ 的字符串）并且每个被接受的字符串都具有半素数长度，所以 $\\langle M'\\rangle \\in SEMIPRIME_{ONLY}$。\n情况 2：$M$ 不接受 $w$。那么对于每个 $x$，$M'$ 要么执行 REJECT\\_BEHAVIOR 并拒绝，要么永不接受（如果模拟不停机）。因此 $L(M')=\\emptyset$，所以 $\\langle M'\\rangle \\notin SEMIPRIME_{ONLY}$。因此，\n$$\n\\langle M,w\\rangle \\in A_{TM} \\iff \\langle M'\\rangle \\in SEMIPRIME_{ONLY}.\n$$\n因此 A 满足归约条件。\n\n选项 B：\n- ACCEPT\\_BEHAVIOR：拒绝 $x$。\n- REJECT\\_BEHAVIOR：当且仅当 $|x|$ 是半素数时接受 $x$。\n如果 $M$ 接受 $w$，那么 $L(M')=\\emptyset$，所以 $\\langle M'\\rangle \\notin SEMIPRIME_{ONLY}$，这与所要求的蕴含关系相矛盾。因此 B 失败。\n\n选项 C：\n- ACCEPT\\_BEHAVIOR：接受 $x$。\n- REJECT\\_BEHAVIOR：拒绝 $x$。\n如果 $M$ 接受 $w$，那么 $L(M')=\\Sigma^{*}$，它包含了长度非半素数的字符串（例如，长度为 $1$）。因此 $\\langle M'\\rangle \\notin SEMIPRIME_{ONLY}$。因此 C 失败。\n\n选项 D：\n- ACCEPT\\_BEHAVIOR：当且仅当 $|x|$ 是素数时接受 $x$。\n- REJECT\\_BEHAVIOR：拒绝 $x$。\n如果 $M$ 接受 $w$，那么 $L(M')$ 只包含长度为素数的字符串。素数不是半素数，所以 $L(M')$ 违反了“仅半素数长度”的要求。因此 D 失败。\n\n选项 E：\n- ACCEPT\\_BEHAVIOR：当且仅当 $|x|$ 是半素数时接受 $x$。\n- REJECT\\_BEHAVIOR：当且仅当 $|x|=4$ 时接受 $x$。\n如果 $M$ 不接受 $w$，那么 $L(M')=\\{x \\mid |x|=4\\}$，该语言非空并且所有被接受的字符串都具有半素数长度，所以即使 $\\langle M,w\\rangle \\notin A_{TM}$，也有 $\\langle M'\\rangle \\in SEMIPRIME_{ONLY}$。这反转了预期的等价关系。因此 E 失败。\n\n因此，只有选项 A 得出了一个从 $A_{TM}$ 到 $SEMIPRIME_{ONLY}$ 的正确归约。", "answer": "$$\\boxed{A}$$", "id": "1468814"}, {"introduction": "在掌握了基本模板后，这个练习引入了设计归约时的一个常见挑战：如何防止模拟过程本身意外地满足我们所要证明的性质。这个问题要求一个更精巧的构造，迫使你思考如何将模拟阶段与最终的“触发”事件“隔离”开来。通过解决这个问题，你将学会为更复杂的性质创建出逻辑严密且无懈可击的归约 [@problem_id:1468757]。", "problem": "在计算理论中，证明一个语言是不可判定的标准技巧是从一个已知的不可判定语言进行归约。考虑语言 $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ 是一台接受输入字符串 } w \\text{ 的图灵机 (TM)} \\}$。一个基础性的结论是，$A_{TM}$ 是不可判定的。\n\n一位计算机科学家想要证明下面这个我们称之为 $L_{REP\\_SYM}$ 的语言也是不可判定的：\n$L_{REP\\_SYM} = \\{ \\langle M \\rangle \\mid M \\text{ 是一台图灵机，当它在空输入字符串 } \\epsilon \\text{ 上运行时，最终会在其带上连续两次写入同一个非空符号} \\}$。\n\n为了做到这一点，她计划将 $A_{TM}$ 归约到 $L_{REP\\_SYM}$。这需要一个过程，该过程接受 $A_{TM}$ 问题的任意实例 $\\langle M, w \\rangle$，并构造一个 $L_{REP\\_SYM}$ 问题的实例 $\\langle M' \\rangle$，使得：\n$M$ 接受 $w$ 当且仅当 $M'$ 在空字符串 $\\epsilon$ 上运行时，连续两次写入同一个非空符号。\n\n下面是构造机器 $M'$ 的四个不同提议。这些为 $M'$ 提议的构造中，哪一个能通过从 $A_{TM}$ 进行归约来正确地确立 $L_{REP\\_SYM}$ 的不可判定性？\n\nA. 在输入 $\\epsilon$ 上，机器 $M'$ 模拟机器 $M$ 在输入 $w$ 上的执行。如果模拟显示 $M$ 停机并接受 $w$， $M'$ 会进入一个特殊的状态序列，使其连续两次写入符号 '1'，然后停机。\n\nB. 在输入 $\\epsilon$ 上，机器 $M'$ 检查机器 $M$ 的编码 $\\langle M \\rangle$。如果字符串 $\\langle M \\rangle$ 包含任何连续重复两次的字符，$M'$ 就连续两次写入符号 '1' 并停机。否则，$M'$ 立即停机而不写入任何东西。\n\nC. 在输入 $\\epsilon$ 上，机器 $M'$ 模拟机器 $M$ 在输入 $w$ 上的执行。对于 $M$ 的带字母表中的任何符号 $\\sigma$，$M'$ 在自己的字母表中使用两个新符号 $\\sigma_A$ 和 $\\sigma_B$。当模拟 $M$ 写入 $\\sigma$ 时，$M'$ 交替写入 $\\sigma_A$ 和 $\\sigma_B$，以确保在此阶段没有非空符号被重复。如果对 $M$ 在 $w$ 上的模拟停机并接受，$M'$ 随后连续两次写入一个新的特殊符号 'x' 并停机。\n\nD. 在输入 $\\epsilon$ 上，机器 $M'$ 将字符串 $w$ 写入其带上。然后，它在 $M$ 的描述上以带输入 $w$ 运行一个通用图灵机模拟器。如果模拟因任何原因（接受或拒绝）停机，$M'$ 就连续两次写入符号 '1'。如果模拟循环，$M'$ 也循环。", "solution": "我们必须提供一个从 $A_{TM}$ 到 $L_{REP\\_SYM}$ 的可计算映射归约 $f$，使得对于每个输入 $\\langle M,w \\rangle$，构造出的机器 $M' = f(\\langle M,w \\rangle)$ 满足\n$$\n\\langle M,w \\rangle \\in A_{TM} \\iff \\langle M' \\rangle \\in L_{REP\\_SYM},\n$$\n即，$M$ 接受 $w$ 当且仅当 $M'$ 在 $\\epsilon$ 上启动时，最终在其带上连续两次写入同一个非空符号。至关重要的是，构造必须确保除非 $M$ 接受 $w$，否则 $M'$ 不会意外地满足“连续两次”写入的条件。\n\n评估每个提议：\n\nA. 这个 $M'$ 模拟 $M$ 在 $w$ 上的运行，如果发现 $M$ 停机并接受，它就连续两次写入 '1' 并停机。正向蕴涵成立：如果 $M$ 接受 $w$，那么 $M'$ 确实会写入重复的符号。然而，反向蕴涵可能会失败，因为在模拟阶段，$M'$ 本身可能就会连续两次写入同一个非空符号，即使 $M$ 从不接受。例如，假设 $M$ 是这样一台机器：在任何输入上，它执行两次连续的、写入同一个非空符号的步骤（比如在两个连续的转移中写入 '1'），然后拒绝。那么 $M$ 不接受 $w$，但 $M'$ 在模拟过程中会产生“连续两次相同的写入”。因此\n$$\n\\langle M,w \\rangle \\notin A_{TM} \\quad \\text{但} \\quad \\langle M' \\rangle \\in L_{REP\\_SYM},\n$$\n违反了所要求的等价性。所以A不是一个正确的归约。\n\nB. 这个 $M'$ 检查 $\\langle M \\rangle$ 并在编码中查找重复的相邻字符；如果找到，它就写入 '1' 两次并停机，否则立即停机。这种行为仅取决于 $\\langle M \\rangle$ 的句法形式，而忽略了 $w$以及 $M$ 是否接受 $w$ 的语义问题。因此，可能存在具有相同编码属性（或简单的重命名）但接受行为不同的 $\\langle M,w \\rangle$ 和 $\\langle N,u \\rangle$，所以等价性\n$$\n\\langle M,w \\rangle \\in A_{TM} \\iff \\langle M' \\rangle \\in L_{REP\\_SYM}\n$$\n无法得到保证。因此B不是一个正确的归约。\n\nC. 这个 $M'$ 模拟 $M$ 在 $w$ 上的运行，但是对于 $M$ 的每个带符号 $\\sigma$，$M'$ 在自己的字母表中使用两个不同的符号 $\\sigma_A$ 和 $\\sigma_B$，并在 $M$ 每次写入 $\\sigma$ 时交替使用它们。这确保了在模拟阶段，$M'$ 永远不会在连续的写入步骤中写入同一个非空符号：如果在模拟运行中有两次连续的写入是同一个基本符号 $\\sigma$，那么 $M'$ 会写入 $\\sigma_A$ 然后是 $\\sigma_B$（或反之），这两个是不同的；如果基本符号不同，那么写入的符号自然也不同。模拟结束后，当且仅当 $M$ 停机并接受 $w$ 时，$M'$ 才会连续两次写入一个新的特殊符号 $x$ 并停机。因此：\n- 如果 $M$ 接受 $w$，那么 $M'$ 最终会连续两次写入 $x$，所以 $\\langle M' \\rangle \\in L_{REP\\_SYM}$。\n- 如果 $M$ 不接受 $w$（拒绝或循环），那么 $M'$ 永远不会进入接受后的阶段，并且根据交替写入机制的构造，在模拟过程中永远不会连续两次写入同一个非空符号。因此 $\\langle M' \\rangle \\notin L_{REP\\_SYM}$。\n因此\n$$\n\\langle M,w \\rangle \\in A_{TM} \\iff \\langle M' \\rangle \\in L_{REP\\_SYM},\n$$\n并且该映射是可计算的。所以C是一个正确的归约，确立了 $L_{REP\\_SYM}$ 的不可判定性。\n\nD. 这个 $M'$ 首先将 $w$ 写入其带上，然后模拟 $M$ 在 $w$ 上的运行，如果模拟因任何原因停机，就写入 '1' '1'。这里有两个明显的失败之处：(i) 在写入输入 $w$ 时，如果 $w$ 包含任何相邻的相同符号，$M'$ 会立即连续两次写入同一个非空符号，这与 $M$ 的行为无关；(ii) 即使不考虑这一点，触发条件是 $M$ 是否停机（接受或拒绝），而不是 $M$ 是否接受，因此它归约到的是停机问题，而不是 $A_{TM}$。无论哪种情况，与接受的等价性都失败了，所以D不是一个正确的归约。\n\n结论：只有提议C实现了一个从 $A_{TM}$ 到 $L_{REP\\_SYM}$ 的有效的多一归约。", "answer": "$$\\boxed{C}$$", "id": "1468757"}, {"introduction": "最后的练习将多个关键概念融为一体。你的任务不再仅仅是证明不可判定性，而是要对一个语言的性质进行完整分类。你需要首先判断该语言是否为图灵可识别的，然后再通过归约证明它不是可判定的。这个练习展示了归约技术如何在分析和分类计算问题复杂性的宏大图景中发挥作用 [@problem_id:1468767]。", "problem": "考虑一个标准的图灵机（TM）模型，它有一条在两个方向上都无限的带子。带上的单元格由整数 $(\\dots, -2, -1, 0, 1, 2, \\dots)$ 索引。图灵机从初始状态开始，其读写头位于单元格 0。“空白带”是指每个单元格都包含空白符号的带子。\n\n我们定义一个语言 $L_{NEG}$，它由满足特定性质的图灵机的编码组成。一个图灵机编码 $\\langle M \\rangle$ 属于 $L_{NEG}$ 当且仅当机器 $M$ 在空白带上启动后，最终会在一个负索引（即索引 $i < 0$）的带单元格上写入一个非空白符号。\n\n下列哪个陈述正确描述了语言 $L_{NEG}$ 的性质？\n\nA. $L_{NEG}$ 是可判定的。\nB. $L_{NEG}$ 不是图灵可识别的。\nC. $L_{NEG}$ 是图灵可识别的，但不是可判定的。\nD. $L_{NEG}$ 和其补集 $\\overline{L_{NEG}}$ 都是图灵可识别的。\nE. $L_{NEG}$ 不是可判定的，但其补集 $\\overline{L_{NEG}}$ 是图灵可识别的。", "solution": "我们首先精确地重述该语言。令 $L_{NEG}=\\{\\langle M\\rangle:\\text{ 当图灵机 } M \\text{ 从单元格 } 0 \\text{ 开始在空白带上运行时，最终会在某个索引为 } i<0 \\text{ 的单元格上写入一个非空白符号}\\}$。\n\n为了证明 $L_{NEG}$ 是图灵可识别的，我们构建一个识别器 $R$。对于输入 $\\langle M\\rangle$， $R$ 在一条双向无限的空白带上从索引 0 开始，一步一步地模拟 $M$。在模拟过程中，$R$ 监控每一次写操作；如果 $M$ 在某个索引为 $i<0$ 的单元格上写入了非空白符号，$R$ 就停机并接受。如果 $M$ 从不执行这样的写操作，$R$ 可能会永远运行下去。因此，$R$ 恰好接受 $L_{NEG}$ 中的编码，所以 $L_{NEG}$ 是图灵可识别的。\n\n接下来，我们通过从空白带停机问题进行映射归约来证明 $L_{NEG}$ 是不可判定的。令 $H_{\\text{blank}}=\\{\\langle M\\rangle: M \\text{ 在空白带上启动时会停机}\\}$。众所周知 $H_{\\text{blank}}$ 是不可判定的。定义一个可计算的映射 $f$，它对于给定的 $\\langle M\\rangle$，输出一个图灵机 $N$ 的编码 $\\langle N\\rangle$。$N$ 在空白带上按如下方式运行：$N$ 在空白带上模拟 $M$；如果 $M$ 的模拟停机， $N$ 就将其读写头移动到索引 -1 处，并在那里写入一个固定的非空白符号（然后停机，或任意继续）。如果 $M$ 的模拟没有停机，那么 $N$ 就永远不会在任何负索引的单元格上写入。这个构造是有效的，所以 $f$ 是可计算的，并且它满足\n$$\n\\langle M\\rangle\\in H_{\\text{blank}}\\iff \\langle N\\rangle=f(\\langle M\\rangle)\\in L_{NEG}.\n$$\n因此 $H_{\\text{blank}}\\leq_{m} L_{NEG}$。由于 $H_{\\text{blank}}$ 是不可判定的，所以 $L_{NEG}$ 也是不可判定的。\n\n最后，如果 $L_{NEG}$ 和它的补集 $\\overline{L_{NEG}}$ 都是图灵可识别的，那么 $L_{NEG}$ 将是可判定的（通过交叉运行这两个识别器，并在其中一个接受时接受），这与不可判定性相矛盾。因此，$\\overline{L_{NEG}}$ 不是图灵可识别的。\n\n综合这些事实，$L_{NEG}$ 是图灵可识别但不可判定的，其补集不是图灵可识别的，所以正确选项是 C。", "answer": "$$\\boxed{C}$$", "id": "1468767"}]}