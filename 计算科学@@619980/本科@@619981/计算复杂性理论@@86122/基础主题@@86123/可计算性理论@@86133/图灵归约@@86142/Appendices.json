{"hands_on_practices": [{"introduction": "图灵归约的核心思想是利用一个“神谕”（oracle）来解决另一个问题，从而帮助我们理解问题之间的难度关系。这个练习将探讨一种基础情景：当我们把一个问题 $L_1$ 归约到一个已知的“简单”问题 $L_2$ 时，会发生什么？通过思考当神谕语言 $L_2$ 是一个有限集（因此是可判定的）时，我们能对 $L_1$ 的可计算性得出什么结论，你将能巩固对图灵归约基本性质的理解。[@problem_id:1468145]", "problem": "在可计算性理论的研究中，语言被定义为某个有限字母表上的字符串集合。如果存在一台图灵机，它在每个输入字符串上都会停机，并且当且仅当该字符串属于语言 $L$ 时接受该字符串，那么语言 $L$ 被称为可判定的。如果一个语言包含有限数量的字符串，则该语言是有限的。\n\n如果存在一个预言图灵机，在给定一个用于 $L_2$ 的预言机的情况下，可以判定 $L_1$，则称语言 $L_1$ 可图灵归约到语言 $L_2$，记作 $L_1 \\le_T L_2$。用于 $L_2$ 的预言机是一个假设性设备，它可以即时回答任何形式为“字符串 $w$ 是否在 $L_2$ 中？”的成员资格查询。该预言图灵机本身必须在所有输入上停机。\n\n假设给定语言 $L_1$ 可图灵归约到语言 $L_2$，并且您还被告知 $L_2$ 是一个有限语言。仅根据这些信息，关于语言 $L_1$ 可以得出什么确定性的结论？\n\nA. $L_1$ 总是可判定的。\n\nB. $L_1$ 不一定是可判定的；它可能不可判定。\n\nC. $L_1$ 也必须是一个有限语言。\n\nD. $L_1$ 是可判定的当且仅当 $L_1$ 是 $L_2$ 的子集。\n\nE. 在不知道 $L_2$ 中的具体字符串的情况下，无法确定 $L_1$ 的可判定性。", "solution": "根据定义，$L_1 \\le_{T} L_2$ 意味着存在一个预言图灵机 $M^{L_2}$，它在每个输入上都会停机，并使用一个能回答形如“$w \\in L_2$ 吗？”的成员资格查询的预言机来判定 $L_1$。\n\n由于 $L_2$ 是有限的，所以 $L_2$ 是可判定的。要证明这一点，可以构造一台图灵机 $D_2$，它在输入为 $w$ 时，将 $w$ 与枚举 $L_2$ 的有限集合中的每个字符串进行比较，如果找到匹配项则接受；在经过有限次比较后（因为 $L_2$ 是有限的），如果未找到匹配项则拒绝。这台机器在所有输入上都会停机，因此 $L_2$ 是可判定的。\n\n因为 $L_2$ 是可判定的，我们可以通过在每个被查询的字符串上运行 $D_2$ 来模拟 $M^{L_2}$ 的预言机调用。形式上，构造一台模拟 $M^{L_2}$ 的图灵机 $M'$；每当 $M^{L_2}$ 要对某个字符串 $x$ 查询预言机时，$M'$ 就在 $x$ 上运行 $D_2$，并将其接受/拒绝的结果用作预言机的答案。由于 $D_2$ 在所有输入上都会停机，所以每次模拟的预言机调用都会停机。此外，根据假设，$M^{L_2}$ 在每个输入上都会停机，因此在任何计算过程中它只进行有限次的预言机查询；因此，$M'$ 的模拟在所有输入上都会停机，并产生与 $M^{L_2}$ 相同的接受/拒绝判定。因此 $M'$ 判定 $L_1$。\n\n所以，$L_1$ 是可判定的。在选项中，这对应于 A。其他选项是错误的：$L_1$ 不必是有限的；可判定性不依赖于 $L_1 \\subseteq L_2$；我们不需要知道 $L_2$ 的具体字符串来得出可判定性的结论，只需要知道 $L_2$ 的有限性。", "answer": "$$\\boxed{A}$$", "id": "1468145"}, {"introduction": "在掌握了与可判定问题的归约之后，我们进入了不可判定问题的领域。图灵归约不仅适用于我们能解决的问题，它更是一个关键工具，用于对我们*无法*解决的问题进行分类。这个思想实验将让你探索两个著名的不可判定问题——停机问题 ($A_{\\text{TM}}$) 和全停机问题 ($TOTAL_{\\text{TM}}$)，并设计一种归约，证明如果你拥有解决其中一个问题的神谕，便可以解决另一个。[@problem_id:1468089]", "problem": "在理论计算机科学领域，我们通常根据问题的计算难度对其进行分类。有两个著名的不可判定问题与图灵机（TM）的行为有关，图灵机是一种计算的数学模型。\n\n第一个是停机问题，它询问一个给定的图灵机 $M$ 是否会在一个特定的输入串 $w$ 上停机。与该问题相对应的语言被记为 $A_{\\text{TM}} = \\{ \\langle M, w \\rangle \\mid M \\text{ is a TM and } M \\text{ halts on input } w \\}$。\n\n第二个问题询问一个图灵机是否会对*所有*可能的输入停机。该问题的语言是 $TOTAL_{\\text{TM}} = \\{ \\langle M \\rangle \\mid M \\text{ is a TM and } M \\text{ halts on all inputs} \\}$。\n\n尽管这两种语言都是不可判定的，但可以使用一个针对其中一个问题的被称为“预言机”的假设性设备来解决另一个问题。一个用于 $TOTAL_{\\text{TM}}$ 的预言机是一个黑盒式子程序，当给定任意图灵机 $\\langle M' \\rangle$ 的描述时，它能立即且正确地确定 $\\langle M' \\rangle \\in TOTAL_{\\text{TM}}$ 是否成立。\n\n你的任务是为一个新的图灵机（我们称之为 $M'$）确定一个正确的设计，这个 $M'$ 可以与一个 $TOTAL_{\\text{TM}}$ 预言机结合使用，来判定一个任意实例 $\\langle M, w \\rangle$ 的停机问题。整体的判定过程如下所示：\n1. 接收一个输入 $\\langle M, w \\rangle$。\n2. 基于 $M$ 和 $w$ 构建一个新图灵机 $M'$ 的描述。\n3. 用 $\\langle M' \\rangle$ 查询 $TOTAL_{\\text{TM}}$ 预言机。\n4. 预言机对于 $M'$ 的“是/否”回答必须直接对应于 $M$ 是否在 $w$ 上停机的“是/否”回答。\n\n以下哪种关于 $M'$ 在任意输入 $x$ 上的行为的描述，构成了用于此目的的正确设计？\n\nA. 对于任意输入 $x$，机器 $M'$ 忽略 $x$，并在固定的串 $w$ 上模拟 $M$。$M'$ 停机当且仅当这个对 $M$ 在 $w$ 上的模拟停机。\n\nB. 对于任意输入 $x$，机器 $M'$ 在该输入 $x$ 上模拟 $M$。$M'$ 停机当且仅当这个对 $M$ 在 $x$ 上的模拟停机。\n\nC. 对于任意输入 $x$，机器 $M'$ 忽略 $x$，并在固定的串 $w$ 上模拟 $M$。如果对 $M$ 的模拟停机， $M'$ 就进入一个无限循环。如果对 $M$ 的模拟不停机，$M'$ 就立即停机。\n\nD. 对于任意输入 $x$，机器 $M'$ 首先在固定的串 $w$ 上模拟 $M$。如果这个模拟停机， $M'$ 接着继续在它自己的输入 $x$ 上模拟 $M$，并且当且仅当这第二个模拟停机时才停机。\n\nE. 不存在这样的 $M'$ 构造，因为 $A_{\\text{TM}}$ 和 $TOTAL_{\\text{TM}}$ 都定义了不可判定的语言。", "solution": "我们给定了一个用于 $TOTAL_{\\text{TM}}=\\{\\langle N\\rangle\\mid N\\text{ halts on all inputs}\\}$ 的预言机。为了使用这个预言机来判定 $A_{\\text{TM}}=\\{\\langle M,w\\rangle\\mid M\\text{ halts on }w\\}$，我们必须为任意输入 $\\langle M,w\\rangle$ 构建一个图灵机 $M'$，使得\n$$\n\\langle M,w\\rangle\\in A_{\\text{TM}}\\iff \\langle M'\\rangle\\in TOTAL_{\\text{TM}}.\n$$\n这要求 $M'$ 对所有输入都停机，当且仅当 $M$ 在 $w$ 上停机。\n\n考虑选项 A 中描述的构造：定义 $M'$，使得对于任意输入 $x$，$M'$ 忽略 $x$ 并在固定的输入 $w$ 上模拟 $M$，当且仅当该模拟停机时，$M'$ 才停机。\n\n我们来验证这个等价关系：\n- 假设 $M$ 在 $w$ 上停机。那么，$M'$ 所执行的对 $M$ 在 $w$ 上的模拟就会停机。因为 $M'$ 忽略其输入 $x$，所以对于每一个 $x$ 都会发生相同的行为。因此，对于所有的 $x$，$M'(x)$ 都会停机，所以 $\\langle M'\\rangle\\in TOTAL_{\\text{TM}}$。\n- 反之，假设 $M$ 在 $w$ 上不停机。那么，$M'$ 中的模拟将永不停机，并且因为 $M'$ 忽略 $x$，所以对于每一个 $x$，$M'(x)$ 都不会停机。因此，$\\langle M'\\rangle\\notin TOTAL_{\\text{TM}}$。\n\n综合以上两点，\n$$\n\\langle M,w\\rangle\\in A_{\\text{TM}}\\iff \\langle M'\\rangle\\in TOTAL_{\\text{TM}}.\n$$\n因此，用 $\\langle M'\\rangle$ 查询 $TOTAL_{\\text{TM}}$ 预言机会得到“是”的回答，当且仅当 $M$ 在 $w$ 上停机，这与对 $A_{\\text{TM}}$ 所期望的判定结果完全匹配。\n\n为了完整起见，其他选项未能产生所需的等价关系：\n- 选项 B 使得 $M'$ 对所有输入停机当且仅当 $M$ 对所有输入停机，这并未反映出 $M$ 是否在特定输入 $w$ 上停机。\n- 选项 C 反转了对应关系：$M'$ 对所有输入停机当且仅当 $M$ 在 $w$ 上不停机，因此预言机的“是”回答将意味着 $M$ 在 $w$ 上不停机，而不是直接的对应关系。\n- 选项 D 使得 $M'$ 对所有输入停机，仅当 $M$ 在 $w$ 上停机且 $M$ 对所有输入都停机时成立；因此它是在确认 $M$ 在 $w$ 上停机之后，再判定 $M$ 是否对所有输入停机，这不符合所需的属性。\n- 选项 E 是不正确的，因为通过选项 A 中的构造，存在一个从 $A_{\\text{TM}}$ 到 $TOTAL_{\\text{TM}}$ 的预言机归约。\n\n因此，正确的设计是选项 A。", "answer": "$$\\boxed{A}$$", "id": "1468089"}, {"introduction": "现在，我们将理论概念应用于一种强大且常见的算法技术。许多问题本质上是“搜索”问题（寻找一个具体解），但解决相关的“判定”问题（是否存在解）往往更容易。这个练习提供了一个假设性的神谕，它可以解决一个调度问题的判定版本，并要求你利用它来构建一个实际的最优调度方案。这种经典的“从判定到搜索”的归约是一种普适的问题解决模式，在计算机科学和优化领域有着广泛应用。[@problem_id:1468109]", "problem": "在计算复杂性理论领域，一个常见的技术是使用一个解决判定问题（一个“是/否”问题）的子程序来帮助解决相关的搜索问题（一个“找到一个实例”的问题）。本问题探讨了这样一种情景。\n\n假设您是一家资助机构的项目经理。您有一份拨款提案清单，每份提案都有一个要求的开始周和结束周。您的任务是选出可能的最大拨款集合进行资助，约束条件是，作为唯一的评审人，您不能评审两个时间区间重叠的拨款提案。\n\n您可以使用一个强大的、预先存在的计算子程序，名为 `HAS_SCHEDULE_OF_SIZE_K`。该子程序接受两个参数：一个拨款集合 `G` 和一个整数 `k`。如果存在一个 `G` 的无冲突子集，其大小至少为 `k`，则它返回 `True`，否则返回 `False`。如果两个拨款的时间区间重叠，则它们发生冲突。时间区间定义为 $[start\\_week, end\\_week)$，表示它包含开始周，但不包含结束周。\n\n您的目标是使用这个 `HAS_SCHEDULE_OF_SIZE_K` 子程序来找到一个具体的、最大规模的无冲突拨款集合。您必须使用以下确定性算法：\n\n1.  首先，确定整个原始拨款集合 $T$ 的一个无冲突时间表的最大可能大小 $k_{max}$。\n2.  初始化一个空时间表 $S = \\emptyset$ 和一个候选拨款集合 $U = T$。\n3.  按索引的递增顺序遍历原始集合 $T$ 中的每个拨款 $g$。\n    a. 我们将当前考虑的拨款称为 $g_{current}$。如果 $g_{current}$ 不在当前的候选集合 $U$ 中，则跳过它。\n    b. 为了决定是否将 $g_{current}$ 添加到您的解中，您必须确定这是否是一个“安全”的选择。一个选择是安全的，如果选择了 $g_{current}$ 之后，仍然有可能形成一个达到目标大小的完整时间表。为了测试这一点，构建一个临时集合 $U_{test}$，其中包含 $U \\setminus \\{g_{current}\\}$ 中所有与 $g_{current}$ 不冲突的拨款。\n    c. 查询预言机：`HAS_SCHEDULE_OF_SIZE_K(U_{test}, $|S| + k_{max} - 1|$)`。等等，这一行似乎过于复杂。让我们简化这个逻辑。\n\n让我们更清晰地重述构建阶段（步骤2和3）的核心逻辑：\n\n2.  初始化最终时间表 $S = \\emptyset$ 和可供考虑的拨款集合 $U = T$。\n3.  按索引顺序遍历原始集合 $T$ 中的拨款 $g_1, g_2, \\dots, g_n$。对于每个拨款 $g_i$：\n    a. 检查选择 $g_i$ 是否为“安全移动”。如果确定选择 $g_i$ 后，我们仍然可以形成一个最大规模的时间表，则该移动是安全的。为了测试这一点，我们看是否可以从剩余的兼容拨款中形成一个大小为 $(k_{max} - |S| - 1)$ 的时间表。具体来说，定义 $U_{compatible} = \\{ g' \\in U \\setminus \\{g_i\\} \\mid g' \\text{ 与 } g_i \\text{ 不冲突} \\}$。查询预言机：`HAS_SCHEDULE_OF_SIZE_K(U_{compatible}, $k_{max} - |S| - 1$)$。\n    b. 如果预言机返回 `True`，则 $g_i$ 是一个安全的选择。将 $g_i$ 添加到您的时间表 $S$ 中，并更新可用拨款集合 $U$，使其仅包含与您新选择兼容的那些拨款，即 $U = U_{compatible}$。\n    c. 如果预言机返回 `False`，则选择 $g_i$ 是一个死胡同。不要将其添加到 $S$ 中。只需将 $g_i$ 从可用拨款集合 $U$ 中移除，然后继续处理下一个拨款。\n\n给定以下六个拨款的集合 $T$，下面哪个选项代表您的算法将构建的最终时间表 $S$？拨款由其索引标识。\n\n-   $g_1$: (索引=1, 开始=1, 结束=5)\n-   $g_2$: (索引=2, 开始=0, 结束=3)\n-   $g_3$: (索引=3, 开始=4, 结束=7)\n-   $g_4$: (索引=4, 开始=6, 结束=9)\n-   $g_5$: (索引=5, 开始=2, 结束=4)\n-   $g_6$: (索引=6, 开始=8, 结束=10)\n\n选择列出最终时间表 $S$ 中拨款索引的选项。\n\nA. {1, 4}\n\nB. {3, 5, 6}\n\nC. {1, 4, 6}\n\nD. {2, 3, 6}", "solution": "我们得到了六个拨款的（半开）区间：\n$g_1 = [1,5)$, $g_2 = [0,3)$, $g_3 = [4,7)$, $g_4 = [6,9)$, $g_5 = [2,4)$, $g_6 = [8,10)$。\n两个区间 $[a,b)$ 和 $[c,d)$ 如果重叠则相互冲突，即，如果不是 $(b \\le c \\text{ 或 } d \\le a)$。\n\n首先，确定 $T=\\{g_1,\\dots,g_6\\}$ 的无冲突子集的最大可能大小 $k_{\\max}$。集合 $\\{g_2, g_3, g_6\\}$ 是无冲突的，因为 $[0,3)$ 在 $[4,7)$ 开始前结束，而 $[4,7)$ 在 $[8,10)$ 开始前结束，所以存在一个大小为 3 的无冲突集合。为了确定上限，请注意在 $\\{g_1, g_2, g_5\\}$ 中最多只能选择一个（每对都重叠），在 $\\{g_3, g_4\\}$ 中最多只能选择一个（它们重叠），而 $g_6$ 与 $g_4$ 重叠但与 $g_3$ 不重叠。因此，总大小最多为 $1+1+1=3$。所以，\n$$\nk_{\\max}=3.\n$$\n\n现在运行构建过程，初始 $S=\\emptyset$ 和 $U=T$，按索引顺序遍历 $g_1, g_2, \\dots, g_6$。在每一步，对于当前 $g_i\\in U$，定义 $U_{\\text{compatible}}=\\{g'\\in U\\setminus\\{g_i\\}: g' \\text{ 与 } g_i \\text{ 不冲突}\\}$，并查询\n$$\n\\text{`HAS_SCHEDULE_OF_SIZE_K`}\\big(U_{\\text{compatible}},\\,k_{\\max}-|S|-1\\big).\n$$\n\n考虑 $g_1=[1,5)$。在 $U\\setminus\\{g_1\\}$ 中与其兼容的拨款是 $g_4=[6,9)$ 和 $g_6=[8,10)$，所以 $U_{\\text{compatible}}=\\{g_4,g_6\\}$。使用 $k_{\\max}-|S|-1=3-0-1=2$ 进行查询，询问在 $\\{g_4,g_6\\}$ 中是否存在大小至少为 2 的无冲突子集。由于 $g_4$ 和 $g_6$ 重叠，最大的无冲突子集大小为 $1  2$，所以预言机返回 False。因此 $g_1$ 不被添加；从 $U$ 中移除 $g_1$。\n\n考虑 $g_2=[0,3)$。此时 $U$ 为 $T\\setminus\\{g_1\\}$，与 $g_2$ 兼容的拨款是 $g_3$、$g_4$ 和 $g_6$，所以 $U_{\\text{compatible}}=\\{g_3,g_4,g_6\\}$。使用 $k_{\\max}-|S|-1=3-0-1=2$ 进行查询。在 $\\{g_3,g_4,g_6\\}$ 中，子集 $\\{g_3,g_6\\}$ 是大小为 2 的无冲突集合，所以预言机返回 True。因此 $g_2$ 是安全的；将其添加到 $S$ 并设置 $U=\\{g_3,g_4,g_6\\}$。\n\n考虑 $g_3=[4,7)$。在 $U\\setminus\\{g_3\\}=\\{g_4,g_6\\}$ 中，只有 $g_6$ 与 $g_3$ 兼容，所以 $U_{\\text{compatible}}=\\{g_6\\}$。使用 $k_{\\max}-|S|-1=3-1-1=1$ 进行查询。由于 $\\{g_6\\}$ 有一个大小为 1 的无冲突子集，预言机返回 True。将 $g_3$ 添加到 $S$ 并设置 $U=\\{g_6\\}$。\n\n考虑 $g_4$。它不在 $U$ 中，所以跳过。\n\n考虑 $g_5$。它不在 $U$ 中，所以跳过。\n\n考虑 $g_6=[8,10)$。现在 $U\\setminus\\{g_6\\}=\\emptyset$，所以 $U_{\\text{compatible}}=\\emptyset$。使用 $k_{\\max}-|S|-1=3-2-1=0$ 进行查询。一个大小至少为 0 的子集总是存在的（空集），所以预言机返回 True。将 $g_6$ 添加到 $S$ 并设置 $U=\\emptyset$。\n\n算法终止时得到 $S=\\{g_2,g_3,g_6\\}$，这对应于选项D。", "answer": "$$\\boxed{D}$$", "id": "1468109"}]}