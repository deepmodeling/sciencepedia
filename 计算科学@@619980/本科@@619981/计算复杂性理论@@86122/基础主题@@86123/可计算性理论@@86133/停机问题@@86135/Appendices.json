{"hands_on_practices": [{"introduction": "停机问题的不可判定性证明，其核心在于一个精妙的自指论证，即“对角线法”。这项练习将通过一个简化的具体示例，引导你亲手构建这个论证中的矛盾，从而直观地理解为何一个能解决所有停机问题的通用算法是不可能存在的。这个思想实验将揭示计算理论中的一个根本性悖论。[@problem_id:1457066]", "problem": "在可计算性理论的研究中，我们经常分析一种被称为图灵机的假想计算机器的行为。对于这个问题，我们考虑一个图灵机集合，记为 $M_1, M_2, M_3, \\dots$。每台机器都可以通过一个有限的符号串来唯一地描述，记为 $\\langle M_i \\rangle$。我们可以将一台机器的描述，比如 $\\langle M_j \\rangle$，作为输入提供给另一台机器 $M_i$。这个计算的结果，记为 $M_i(\\langle M_j \\rangle)$，是机器 $M_i$ 要么最终停机 ($\\text{HALT}$)，要么永远运行 ($\\text{LOOP}$)。\n\n前三台这样的机器在前三个输入上的行为总结在下表中：\n\n| | 输入 $\\langle M_1 \\rangle$ | 输入 $\\langle M_2 \\rangle$ | 输入 $\\langle M_3 \\rangle$ |\n| :--- | :--- | :--- | :--- |\n| **机器 $M_1$** | $\\text{LOOP}$ | $\\text{HALT}$ | $\\text{HALT}$ |\n| **机器 $M_2$** | $\\text{HALT}$ | $\\text{LOOP}$ | $\\text{HALT}$ |\n| **机器 $M_3$** | $\\text{LOOP}$ | $\\text{LOOP}$ | $\\text{LOOP}$ |\n\n例如，第二行第三列的条目表明，当机器 $M_2$ 接收到输入串 $\\langle M_3 \\rangle$ 时，它将最终停机：$M_2(\\langle M_3 \\rangle) \\to \\text{HALT}$。第一行第一列的条目表明 $M_1(\\langle M_1 \\rangle) \\to \\text{LOOP}$。\n\n现在，我们定义一台新的图灵机，称为“对角线机”$D$。$D$ 的行为是针对*任何*机器描述 $\\langle M_i \\rangle$作为输入来定义的：\n1.  在接收到输入 $\\langle M_i \\rangle$ 时，机器 $D$ 首先确定机器 $M_i$ 在其自身描述 $M_i(\\langle M_i \\rangle)$ 上运行的结果。这等价于查看上述表格（的无限大版本）的对角线上的条目。\n2.  如果 $M_i(\\langle M_i \\rangle)$ 的结果是 $\\text{HALT}$，那么机器 $D$ 被定义为进入一个无限 $\\text{LOOP}$。\n3.  如果 $M_i(\\langle M_i \\rangle)$ 的结果是 $\\text{LOOP}$，那么机器 $D$ 被定义为 $\\text{HALT}$。\n\n本质上，$D$ 的构造使其行为与对角线上的条目相反。由于 $D$ 是一台图灵机，它也必须有自己的字符串描述 $\\langle D \\rangle$。\n\n当机器 $D$ 以其自身的描述 $\\langle D \\rangle$ 作为输入运行时，其行为是什么？\n\nA. 在输入为 $\\langle D \\rangle$ 时，$D$ 将会 $\\text{HALT}$。\nB. 在输入为 $\\langle D \\rangle$ 时，$D$ 将会 $\\text{LOOP}$。\nC. 行为是未定义的，因为 $D$ 不是原始表格中的机器之一 ($M_1, M_2, M_3$)。\nD. 所描述的机器 $D$ 是自相矛盾的，因此无法被构造。", "solution": "给定一个可数的图灵机列表 $\\{M_{1},M_{2},\\dots\\}$，其编码为 $\\langle M_{i}\\rangle$，以及一台机器 $D$ 的定义。在输入为 $\\langle M_{i}\\rangle$ 时，$D$ 首先确定 $M_{i}(\\langle M_{i}\\rangle)$ 的结果，然后执行相反的操作：如果 $M_{i}(\\langle M_{i}\\rangle)$ 停机，则 $D$ 循环；如果 $M_{i}(\\langle M_{i}\\rangle)$ 循环，则 $D$ 停机。\n\n形式上，对于每个 $i$，\n$$\nD(\\langle M_{i}\\rangle)=\\text{HALT} \\iff M_{i}(\\langle M_{i}\\rangle)=\\text{LOOP},\n$$\n以及等价地，\n$$\nD(\\langle M_{i}\\rangle)=\\text{LOOP} \\iff M_{i}(\\langle M_{i}\\rangle)=\\text{HALT}.\n$$\n\n由于 $D$ 是一台图灵机，它有一个编码 $\\langle D\\rangle$。代入 $M_{i}=D$ 可得到自应用条件\n$$\nD(\\langle D\\rangle)=\\text{HALT} \\iff D(\\langle D\\rangle)=\\text{LOOP}.\n$$\n在二值设定中，这个等价关系无法被任何结果满足：假设 $D(\\langle D\\rangle)=\\text{HALT}$ 会导出 $D(\\langle D\\rangle)=\\text{LOOP}$，而假设 $D(\\langle D\\rangle)=\\text{LOOP}$ 会导出 $D(\\langle D\\rangle)=\\text{HALT}$。因此，对于输入 $\\langle D\\rangle$，$D$ 无法被赋予一个一致的行为。\n\n因此，$D$ 的定义预设了对任意 $i$ 都能判定 $M_{i}(\\langle M_{i}\\rangle)$ 的能力，而当该定义应用于满足 $M_i=D$ 的 $i$ 时，便会导致矛盾。在标准的可计算性理论中，这表明这样一台机器 $D$ 无法被构造成图灵机。正确的选项是，所描述的 $D$ 是自相矛盾的，且无法被构造。", "answer": "$$\\boxed{D}$$", "id": "1457066"}, {"introduction": "在证明一个新问题不可判定时，我们最强大的工具是“归约”（reduction）。归约的思想是，将一个已知的不可判定问题（如 $A_{TM}$）转化为一个新问题，从而证明这个新问题至少和已知问题一样“难”。这项练习将指导你完成一个经典的归约证明，将图灵机接受问题（$A_{TM}$）归约为在空输入上的停机问题（$HALT_{\\epsilon}$），这是计算理论学习者必须掌握的一项基本技能。[@problem_id:1457092]", "problem": "在理论计算机科学中，一个关键的结果是图灵机接受问题（Acceptance Problem for Turing Machines）的不可判定性。设图灵机（TM）是一种形式计算模型，类似于一个计算机程序。对应于接受问题的语言表示为 $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ 是一台接受输入串 } w \\text{ 的图灵机} \\}$。一个基本定理是，不存在算法可以对所有的配对 $\\langle M, w \\rangle$ 判定 $M$ 是否接受 $w$。换句话说，$A_{TM}$ 是一个不可判定语言。\n\n现在，考虑一个相关但看似更简单的问题。我们定义语言 $HALT_{\\epsilon} = \\{ \\langle M \\rangle \\mid M \\text{ 是一台在空输入串 } \\epsilon \\text{ 上停机的图灵机} \\}$。一位计算机科学家推测 $HALT_{\\epsilon}$ 也是不可判定的。为了研究这个问题，她试图证明，如果存在一个可以判定 $HALT_{\\epsilon}$ 的假设算法，那么这个算法就可以被用作一个子程序来构建一个能判定不可能解决的问题 $A_{TM}$ 的算法，从而导致矛盾。\n\n策略如下：为了判定一个给定的图灵机 $M$ 是否接受字符串 $w$（即，解决 $A_{TM}$ 的一个实例 $\\langle M, w \\rangle$），我们首先构造一个新的图灵机，称之为 $M_{\\text{construct}}$。$M_{\\text{construct}}$ 的行为是根据 $M$ 和 $w$ 特别设计的。然后，我们将 $M_{\\text{construct}}$ 的描述输入到我们假设的 $HALT_{\\epsilon}$ 判定器中。这个判定器的输出（$M_{\\text{construct}}$ 是否在 $\\epsilon$ 上停机）应该能明确地告诉我们 $M$ 是否接受 $w$。\n\n以下哪项正确地描述了当机器 $M_{\\text{construct}}$ 在空字符串 $\\epsilon$ 上运行时所必需的行为，从而使得该策略能够成功证明 $HALT_{\\epsilon}$ 是不可判定的？\n\nA. 在输入为 $\\epsilon$ 时，$M_{\\text{construct}}$ 模拟 $M$ 在输入 $w$ 上的运行。如果模拟显示 $M$ 接受 $w$，$M_{\\text{construct}}$ 就停机。如果模拟显示 $M$ 拒绝 $w$，$M_{\\text{construct}}$ 就进入一个无限循环。\n\nB. 在输入为 $\\epsilon$ 时，$M_{\\text{construct}}$ 模拟 $M$ 在输入 $w$ 上的运行。如果模拟显示 $M$ 在 $w$ 上停机（无论接受或拒绝），$M_{\\text{construct}}$ 就停机。否则，它进入一个无限循环。\n\nC. 在输入为 $\\epsilon$ 时，$M_{\\text{construct}}$ 模拟 $M$ 在空字符串 $\\epsilon$ 上的运行。如果模拟显示 $M$ 接受 $\\epsilon$，$M_{\\text{construct}}$ 就停机。如果模拟显示 $M$ 拒绝 $\\epsilon$，$M_{\\text{construct}}$ 就进入一个无限循环。\n\nD. 在输入为 $\\epsilon$ 时，$M_{\\text{construct}}$ 模拟 $M$ 在输入 $w$ 上的运行。如果模拟显示 $M$ 接受 $w$，$M_{\\text{construct}}$ 就进入一个无限循环。如果模拟显示 $M$ 拒绝 $w$，$M_{\\text{construct}}$ 就停机。\n\nE. 在输入为 $\\epsilon$ 时，$M_{\\text{construct}}$ 模拟 $M$ 在输入 $w$ 上的运行。它的设计是当且仅当 $M$ 接受 $w$ 时，它进入一个接受状态。", "solution": "我们的目标是证明，一个用于 $HALT_{\\epsilon}=\\{\\langle M\\rangle\\mid M \\text{ 在 } \\epsilon \\text{ 上停机}\\}$ 的假设判定器，可以被用来判定 $A_{TM}=\\{\\langle M,w\\rangle\\mid M \\text{ 接受 } w\\}$。这需要一个可计算的转换 $f$，它将任意配对 $\\langle M,w\\rangle$ 映射到一个机器 $\\langle M_{\\text{construct}}\\rangle$，使得以下等价关系成立：\n$$\n\\langle M,w\\rangle\\in A_{TM}\\iff \\langle M_{\\text{construct}}\\rangle\\in HALT_{\\epsilon}.\n$$\n如果存在这样的 $f$，那么给定一个 $HALT_{\\epsilon}$ 的判定器，我们就可以通过应用 $f$ 并在 $\\langle M_{\\text{construct}}\\rangle$ 上运行该判定器来判定 $A_{TM}$。由于 $A_{TM}$ 是不可判定的，这将意味着 $HALT_{\\epsilon}$ 也是不可判定的。\n\n因此，$M_{\\text{construct}}$ 必须被定义为：它在输入 $\\epsilon$ 上停机，当且仅当 $M$ 接受 $w$。一个正确的构造是：\n- 在输入为 $\\epsilon$ 时，模拟 $M$ 在输入 $w$ 上的运行。\n- 如果模拟显示 $M$ 接受 $w$，则停机（例如，接受）。\n- 如果模拟显示 $M$ 拒绝 $w$，则无限循环。\n- 如果 $M$ 在 $w$ 上不停机，模拟将永远不会结束，因此 $M_{\\text{construct}}$ 也不会停机。\n\n这确保了以下精确的等价关系\n$$\n\\langle M,w\\rangle\\in A_{TM}\\iff M\\text{ 接受 }w\\iff M_{\\text{construct}}\\text{ 在 }\\epsilon\\text{ 上停机}\\iff \\langle M_{\\text{construct}}\\rangle\\in HALT_{\\epsilon}.\n$$\n因此，一个 $HALT_{\\epsilon}$ 的判定器将可以通过映射 $\\langle M,w\\rangle\\mapsto \\langle M_{\\text{construct}}\\rangle$ 来判定 $A_{TM}$，这是一个矛盾。因此 $HALT_{\\epsilon}$ 是不可判定的。\n\n在这些选项中：\n- A 精确地匹配了所需的构造。\n- B 使得在 $\\epsilon$ 上的停机对应于 $M$ 在 $w$ 上因任何原因停机，这归约到了一般的停机问题而不是接受问题；它没有按照策略的要求判定 $A_{TM}$。\n- C 模拟 $M$ 在 $\\epsilon$ 上而不是在 $w$ 上的运行，破坏了与给定实例 $\\langle M,w\\rangle$ 所需的对应关系。\n- D 使得在 $\\epsilon$ 上的停机对应于 $M$ 拒绝 $w$，这并没有如所述那样判定 $A_{TM}$。\n- E 是模棱两可的：进入接受状态意味着停机，但它不排除当 $M$ 拒绝 $w$ 时，也通过拒绝而停机，因此它不能保证停机与接受之间所需的“当且仅当”条件。\n\n因此，正确的描述是 A。", "answer": "$$\\boxed{A}$$", "id": "1457092"}, {"introduction": "运用归约证明需要严谨的逻辑，一个常见的陷阱是弄错归约的方向。本练习模拟了一个学生在证明中犯下这种典型错误的场景，挑战你找出其中的逻辑谬误。通过辨析这个错误，你不仅能避免在未来的证明中重蹈覆辙，还能更深刻地理解归约证明的真正内涵：它是在断言“如果新问题可解，那么旧的不可解问题也将可解”，以此导出矛盾。[@problem_id:1457073]", "problem": "计算理论课程的一名学生 Alice，任务是证明一个特定的语言 `TOTAL_TM` 是不可判定的。该语言定义为 `TOTAL_TM` = $\\{ \\langle M \\rangle \\mid M \\text{ 是一台在所有可能的输入串上都会停机的图灵机 (TM)} \\}$。\n\nAlice 知道标准的停机问题 $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ 是一台在输入 } w \\text{ 上会停机的图灵机} \\}$ 是一个著名的不可判定语言。\n\n为了证明她的论断，她正确地构造了一个可计算函数 $f$，该函数将 `TOTAL_TM` 的任意实例 $\\langle M \\rangle$ 转换为 $A_{TM}$ 的一个实例 $\\langle M', w' \\rangle = f(\\langle M \\rangle)$，使得 $\\langle M \\rangle \\in \\text{TOTAL\\_TM}$ 当且仅当 $\\langle M', w' \\rangle \\in A_{TM}$。这建立了一个从 `TOTAL_TM` 到 $A_{TM}$ 的映射归约（记为 $\\text{TOTAL\\_TM} \\le_m A_{TM}$）。\n\nAlice 随后总结了她的证明：“既然我已经证明了 `TOTAL_TM` 可归约到 $A_{TM}$，并且我们知道 $A_{TM}$ 是不可判定的，那么从逻辑上可以得出 `TOTAL_TM` 也必定是不可判定的。”\n\n下列哪个陈述最好地解释了 Alice 推理中的根本性错误？\n\nA. 为了通过归约证明一个语言 $P$ 是不可判定的，必须将一个已知的不可判定语言 $U$ 归约 *到* $P$（即证明 $U \\le_m P$），而不是反过来。Alice 的归约方向对于她要达成的目标是错误的。\nB. 语言 `TOTAL_TM` 不是图灵可识别的，而 $A_{TM}$ 是。一个映射归约仅在处于同一可识别性类别（即可识别或都不可识别）的语言之间有效。\nC. Alice 的论证是循环论证。为了构造可计算函数 $f$，她必须隐式地假设了一个判定 `TOTAL_TM` 的方法，这与她试图证明的论断相矛盾。\nD. 该归约是无效的，因为已知 `TOTAL_TM` 是一个比 $A_{TM}$ “更难”的问题。计算理论的一个基本定理是，不能将一个计算上更难的问题归约到一个更容易的问题。\nE. 任何从接受单个编码 $\\langle M \\rangle$ 作为输入的语言到接受一个对 $\\langle M, w \\rangle$ 作为输入的语言的归约都存在固有缺陷，因为它需要制造原始输入中不存在的信息（字符串 $w$）。", "solution": "我们给定了语言 $\\text{TOTAL\\_TM} = \\{ \\langle M \\rangle \\mid M \\text{ 在所有输入上停机} \\}$ 和停机问题 $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ 在输入 } w \\text{ 上停机} \\}$，其中已知 $A_{TM}$ 是不可判定的。Alice 展示了一个映射归约 $\\text{TOTAL\\_TM} \\le_{m} A_{TM}$，并由此得出结论 `TOTAL_TM` 是不可判定的。\n\n回顾定义：对于语言 $A$ 和 $B$，$A \\le_{m} B$ 意味着存在一个全可计算函数 $f$，使得对于所有字符串 $x$， \n$$x \\in A \\iff f(x) \\in B.$$\n\n映射归约的关键性质：\n- 如果 $A \\le_{m} B$ 且 $B$ 是可判定的，那么 $A$ 也是可判定的。证明：给定一个用于 $B$ 的判定器，通过计算 $f(x)$ 并在其上运行用于 $B$ 的判定器来判定 $A$ 的输入 $x$；当且仅当该判定器接受时，我们也接受。\n- 该陈述的逆否命题是：如果 $A$ 是不可判定的且 $A \\le_{m} B$，那么 $B$ 也是不可判定的。\n\n因此，要通过归约证明目标语言 $P$ 是不可判定的，必须将一个已知的不可判定语言 $U$ 归约到 $P$，即证明 $U \\le_{m} P$。这样，如果 $P$ 是可判定的，那么 $U$ 也将是可判定的，这与 $U$ 的已知不可判定性相矛盾。\n\n然而，Alice 证明的是 $\\text{TOTAL\\_TM} \\le_{m} A_{TM}$。根据上述基本性质，这个蕴含关系只能得出：\n$$\\text{若 } A_{TM} \\text{ 是可判定的，则 } \\text{TOTAL\\_TM} \\text{ 是可判定的。}$$\n但由于 $A_{TM}$ 是不可判定的，这个条件句没有告诉我们任何关于 $\\text{TOTAL\\_TM}$ 可判定性的信息。因此，Alice 的结论是不成立的。\n\n一个具体的例子可以说明为什么这样的归约方向不能证明不可判定性：设 $L$ 是任意一个可判定语言。设 $D$ 是它的判定器。定义一个可计算函数 $f$，它在输入 $x$ 上运行 $D(x)$，如果 $D$ 接受，则输出一个固定的属于 $A_{TM}$ 的对 $\\langle M_{halt}, w_{halt} \\rangle$；如果 $D$ 拒绝，则输出一个固定的不属于 $A_{TM}$ 的对 $\\langle M_{loop}, w_{loop} \\rangle$。那么 $x \\in L \\iff f(x) \\in A_{TM}$，所以 $L \\le_{m} A_{TM}$，然而 $L$ 是可判定的。因此，证明 $P \\le_{m} A_{TM}$ 并不能断定 $P$ 是不可判定的。\n\n因此，根本性的错误在于归约的方向。这对应于选项 A。其他选项是错误的，因为：映射归约不要求具有相同的可识别性状态（B 是错误的），构造函数 $f$ 并不假设存在 `TOTAL_TM` 的判定器（C 是错误的），“从更难到更容易”的说法不是这里所用的正式标准（D 具有误导性），以及通过可计算的填充或硬编码从单个元素生成对是标准做法（E 是错误的）。", "answer": "$$\\boxed{A}$$", "id": "1457073"}]}