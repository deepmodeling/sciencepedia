{"hands_on_practices": [{"introduction": "停机问题的不可判定性不仅仅是图灵机这种复杂模型的特性。这个练习将探讨一个更为精简的计算模型——双计数器机（2-CM）。通过理解双计数器机如何模拟图灵机，你将能够通过归约法证明，即使是这样简单的系统，其停机问题同样是不可判定的 [@problem_id:1438132]。这揭示了不可判定性是计算理论中一个深刻且普遍的性质。", "problem": "在可计算性理论领域，停机问题是不可判定问题的一个经典例子。对于一个给定的计算模型，例如图灵机（TM），停机问题是：给定一个机器的描述和初始输入，该机器最终会停机，还是会永远运行下去？已经证明，不存在一个通用算法可以为图灵机的所有可能输入解决停机问题。\n\n一名计算机科学专业的学生提出了一种新的极简计算模型，称为双计数器机（2-CM）。一台 2-CM 由一个有限状态集和两个计数器组成，每个计数器都可以存储任意非负整数。该机器根据一个简单的指令程序运行。这些指令可以增加计数器的值、减少计数器的值，或者根据某个计数器当前是否为零来执行到另一条指令的条件跳转。\n\n该学生推测，由于 2-CM 模型比图灵机（图灵机有一条无限长的纸带）简单得多，其版本的停机问题可能是可判定的。也就是说，也许存在一种算法，可以判定任意给定的 2-CM 在一组给定的初始计数器值下是否会停机。\n\n然而，可计算性理论中的一个基本结果表明，**任何图灵机都可以由一台双计数器机模拟**。这意味着对于任何图灵机及其输入，都可以构造出一台等价的 2-CM，该 2-CM 停机当且仅当原始图灵机停机。\n\n基于这些信息，关于双计数器机停机问题（“2-CM 停机问题”）的可判定性，以下哪个陈述提供了最准确的结论？\n\nA. 2-CM 停机问题是不可判定的。如果它是可判定的，那么就可以通过先将图灵机转换为其等价的 2-CM，然后使用 2-CM 的判定器来为图灵机停机问题构造一个判定器。这将与已知的图灵机停机问题的不可判定性相矛盾。\n\nB. 2-CM 停机问题是可判定的。用 2-CM 模拟图灵机并不意味着它们具有相同的可判定性属性。2-CM 的结构更简单，缺少无限纸带，这使得对其状态和计数器值循环的分析成为可能，而图灵机的无限纸带则阻止了这种分析。\n\nC. 2-CM 停机问题是不可判定的，但仅限于那些主动模拟图灵机的 2-CM。对于那些不是作为图灵机模拟器构造的 2-CM，由于其指令集有限，停机问题是可判定的。\n\nD. 从给定的信息中无法确定 2-CM 停机问题的可判定性。2-CM 可以模拟图灵机这一事实并未提供足够的信息来对 2-CM 本身的属性得出结论。\n\nE. 2-CM 停机问题是可判定的。模拟能力仅意味着这些机器在计算能力上是等价的（图灵完备的），但可判定性是一个与问题相关的独立属性，而非与机器的能力相关。", "solution": "我们将停机问题和归约论证形式化。\n\n定义图灵机停机问题语言\n$$\nH_{\\mathrm{TM}}=\\{ \\langle M,x \\rangle \\mid \\text{图灵机 } M \\text{ 在输入 } x \\text{ 上停机} \\}.\n$$\n定义 2-CM 停机问题语言\n$$\nH_{2\\mathrm{CM}}=\\{ \\langle C,\\vec{v} \\rangle \\mid \\text{双计数器机 } C \\text{ 在初始计数器 } \\vec{v} \\text{ 上停机} \\}.\n$$\n\n鉴于“任何图灵机都可以由一台双计数器机模拟，且停机行为得以保留”这一既定事实，存在一个有效的（可计算的）转换，该转换对于输入编码 $\\langle M,x \\rangle$，会输出一个带初始计数器的 2-CM 的编码 $\\langle C_{M,x},\\vec{v}_{0} \\rangle$，使得\n$$\n\\langle M,x \\rangle \\in H_{\\mathrm{TM}} \\iff \\langle C_{M,x},\\vec{v}_{0} \\rangle \\in H_{2\\mathrm{CM}}.\n$$\n等价地，存在一个可计算函数 $f$，满足\n$$\nf(\\langle M,x \\rangle)=\\langle C_{M,x},\\vec{v}_{0} \\rangle \\quad \\text{且} \\quad \\langle M,x \\rangle \\in H_{\\mathrm{TM}} \\iff f(\\langle M,x \\rangle) \\in H_{2\\mathrm{CM}}.\n$$\n这是一个多一归约 $H_{\\mathrm{TM}} \\leq_{m} H_{2\\mathrm{CM}}$。\n\n假设 $H_{2\\mathrm{CM}}$ 是可判定的以导出矛盾。那么存在一个判定器 $D_{2\\mathrm{CM}}$，对于每个输入 $y$，$D_{2\\mathrm{CM}}(y)$ 都能正确判定其是否属于 $H_{2\\mathrm{CM}}$。可以如下为 $H_{\\mathrm{TM}}$ 构造一个判定器 $D_{\\mathrm{TM}}$：对于输入 $\\langle M,x \\rangle$，计算 $f(\\langle M,x \\rangle)$ 并在该结果上运行 $D_{2\\mathrm{CM}}$；输出相同的答案。根据由 $f$ 所保持的等价性，这个 $D_{\\mathrm{TM}}$ 可以判定 $H_{\\mathrm{TM}}$。\n\n然而，一个基本结论是 $H_{\\mathrm{TM}}$ 是不可判定的。这个矛盾表明，$H_{2\\mathrm{CM}}$ 是可判定的这一假设是错误的。因此，$H_{2\\mathrm{CM}}$ 是不可判定的。\n\n评估各个选项：\n- A 正确地陈述了归约论证以及与 $H_{\\mathrm{TM}}$ 已知的不可判定性之间的矛盾。\n- B 和 E 错误地声称其是可判定的；一个可计算模拟的存在足以通过上述归约来传递不可判定性。\n- C 是不正确的，因为不可判定性是关于整个语言的；存在编码了图灵机行为的实例就足以使整个停机问题变得不可判定。\n- D 是不正确的，因为给定的信息足以通过多一归约得出不可判定的结论。\n\n因此，正确选项是 A。", "answer": "$$\\boxed{A}$$", "id": "1438132"}, {"introduction": "让我们进行一个思想实验：假设你拥有一个可以瞬间解决停机问题的“神谕机”（Oracle）。这个练习要求你利用这个强大的假设性工具来解决一个不同的问题——判断一个程序是否会在其执行过程中打印出特定的字符串“hello world” [@problem_id:1438125]。这种被称为图灵归约的技巧，是理论计算机科学中比较问题难度和探索计算极限的核心方法。", "problem": "在可计算性理论的研究中，我们经常探索算法计算能力的极限。一个核心的不可解问题是停机问题：判断一个任意的图灵机（TM）在给定输入上是否会停机。\n\n假设您被授予访问一个假设性的“谕示机”的权限，这是一个名为 `HALT_ORACLE` 的黑箱函数。该谕示机接收任意图灵机 `M` 的描述和一个输入串 `s`，并立即提供一个确切的答案。具体来说，如果图灵机 `M` 在输入 `s` 上运行时会停机，`HALT_ORACLE(M, s)` 返回 `true`；如果 `M` 永远运行，则返回 `false`。\n\n您的任务是使用这个强大的谕示机来解决一个不同但相关的问题，我们称之为 `HW_PROBLEM`。`HW_PROBLEM` 的问题是：对于任意的图灵机 `P` 和输入串 `w`，`P` 在输入 `w` 上执行期间，是否会曾将其输出带上写入特定的字符串 \"hello world\"？\n\n您必须设计一个算法，作为 `HW_PROBLEM` 的**判定器**。判定器是一种算法，对于任何给定的输入（在本例中是 `P` 和 `w`），它保证会停机并提供正确的“是”或“否”的答案。\n\n对于任意给定的图灵机 `P` 和输入 `w`，以下哪个算法能正确且总是判定 `HW_PROBLEM`？\n\nA. 构造一个机器 `D`，它以 `<P, w>` 作为输入。`D` 模拟 `P` 在输入 `w` 上的执行。如果在任何时刻 `P` 将 \"hello world\" 写入其输出带，`D` 就停机并输出“是”。如果 `P` 在从未写入 \"hello world\" 的情况下停机，`D` 就停机并输出“否”。\n\nB. 构造一个机器 `D`，它以 `<P, w>` 作为输入。`D` 首先查询谕示机 `HALT_ORACLE(P, w)`。如果谕示机返回 `false`，`D` 立即停机并输出“否”。如果谕示机返回 `true`，`D` 接着模拟 `P` 在 `w` 上的执行（现在保证会停机），并检查最终的输出带。如果存在 \"hello world\"，`D` 输出“是”；否则，它输出“否”。\n\nC. 构造一个机器 `D`，它以 `<P, w>` 作为输入。`D` 首先创建一个新图灵机 `P_prime` 的描述。机器 `P_prime` 被设计为忽略其自身的输入。相反，`P_prime` 模拟 `P` 在输入 `w` 上的执行。`P_prime` 监视被模拟的 `P` 的输出带。如果 `P` 曾写入 \"hello world\"，`P_prime` 就立即停机。如果 `P` 的模拟在*没有*写入 \"hello world\" 的情况下停机，`P_prime` 就进入一个特意设置的无限循环。在构造 `P_prime` 之后，`D` 查询谕示机 `HALT_ORACLE(P_prime, \"\")`，其中 `\"\"` 是空字符串。如果谕示机返回 `true`，`D` 输出“是”。如果返回 `false`，`D` 输出“否”。\n\nD. 构造一个机器 `D`，它以 `<P, w>` 作为输入。`D` 首先创建一个新图灵机 `P_double_prime` 的描述。这个新机器 `P_double_prime` 模拟 `P` 在输入 `w` 上的执行。如果 `P` 的模拟停机，`P_double_prime` 接着检查输出带。如果存在 \"hello world\"，`P_double_prime` 就停机。如果不存在 \"hello world\"，`P_double_prime` 就进入一个无限循环。在构造 `P_double_prime` 之后，`D` 查询谕示机 `HALT_ORACLE(P_double_prime, \"\")`。如果谕示机返回 `true`，`D` 输出“是”。如果返回 `false`，`D` 输出“否”。", "solution": "题目要求我们判定，对于任意图灵机 $P$ 和输入 $w$，在 $P$ 对输入 $w$ 的执行过程中，是否曾写入字符串 \"hello world\"。我们可以使用一个谕示机 $\\text{HALT\\_ORACLE}(M,s)$，当且仅当 $M$ 在输入 $s$ 上停机时，它返回 true，否则返回 false。一个正确的判定器必须在所有输入上停机，并返回正确的“是”或“否”的答案。\n\n分析每个提议的算法：\n\n选项 A: $D$ 模拟 $P$ 在 $w$ 上的执行，如果它观察到 \"hello world\"，就回答“是”，如果 $P$ 在未写入 \"hello world\" 的情况下停机，就回答“否”。这不是一个判定器。如果 $P$ 永远运行且从未写入 \"hello world\"，那么 $D$ 也会永远模拟下去并且永不停机。因此，A 未能保证总是停机。\n\n选项 B: $D$ 查询 $\\text{HALT\\_ORACLE}(P,w)$。如果返回 false， $D$ 输出“否”。如果返回 true， $D$ 模拟 $P$ 在 $w$ 上的执行（现在保证停机），并检查最终输出中是否有 \"hello world\"。这是不正确的：存在这样的机器 $P$，它在输入 $w$ 上，在某个有限的时间点写入 \"hello world\"，然后继续永远运行。在这种情况下，$\\text{HALT\\_ORACLE}(P,w)$ 返回 false，所以 $D$ 输出“否”，但目标问题的正确答案是“是”，因为 \"hello world\" 在执行过程中被写入了。因此，B 是不正确的。\n\n选项 C: $D$ 构造一个 $P'$，它忽略自身的输入，转而模拟 $P$ 在 $w$ 上的执行，并监视写入操作。$P'$ 的行为如下：\n- 如果 $P$ 曾写入 \"hello world\"，那么 $P'$ 立即停机。\n- 如果 $P$ 在没有写入 \"hello world\" 的情况下停机，那么 $P'$ 进入一个无限循环。\n- 如果 $P$ 永远运行且没有写入 \"hello world\"，那么 $P'$ 也永远运行（继续模拟）。\n然后 $D$ 查询 $\\text{HALT\\_ORACLE}(P',\\epsilon)$，其中 $\\epsilon$ 是空字符串。正确性分析：\n- 如果 $P$ 在 $w$ 上曾写入 \"hello world\"，那么 $P'$ 会停机，所以 $\\text{HALT\\_ORACLE}(P',\\epsilon)$ 返回 true， $D$ 输出“是”。\n- 如果 $P$ 在 $w$ 上从未写入 \"hello world\"，有两种子情况：\n  1. $P$ 在没有写入 \"hello world\" 的情况下停机：那么 $P'$ 将无限循环，所以谕示机返回 false， $D$ 输出“否”。\n  2. $P$ 永远运行且没有写入 \"hello world\"：那么 $P'$ 也永不停机，所以谕示机返回 false， $D$ 输出“否”。\n在所有情况下， $D$ 都在一次谕示机查询后停机，并给出正确的答案。因此，C 是一个有效的判定器。\n\n选项 D: $D$ 构造一个 $P''$，它模拟 $P$ 在 $w$ 上的执行，并且只有在检测到 $P$ 停机后才检查最终输出；如果存在 \"hello world\"，它就停机，否则就循环。当 $P$ 在 $w$ 上写入 \"hello world\" 然后继续永远运行（永不停机）时，这个方法会失败。在这种情况下， $P''$ 永不停机，因为它在检查之前等待 $P$ 停机，所以 $\\text{HALT\\_ORACLE}(P'',\\epsilon)$ 返回 false，而 $D$ 输出“否”，这是不正确的，因为 \"hello world\" 确实在执行过程中被写入了。因此，D 是不正确的。\n\n因此，只有选项 C 使用谕示机正确且总是能判定该问题。", "answer": "$$\\boxed{C}$$", "id": "1438125"}, {"introduction": "在证明一个问题是不可判定的过程中，正确地运用归约逻辑至关重要。此练习呈现了一个学生试图证明一个问题不可判定时所犯的常见逻辑错误 [@problem_id:1457073]。你的任务是精确地指出其推理的根本缺陷，从而加深对归约证明方向性的理解——即我们必须将一个已知的不可判定问题 $U$ 归约到新问题 $P$ (即证明 $U \\le_m P$)，而不是反过来。", "problem": "计算理论课程的一名学生 Alice 接到一项任务，需要证明一个特定的语言 `TOTAL_TM` 是不可判定的。该语言定义为 `TOTAL_TM` = $\\{ \\langle M \\rangle \\mid M \\text{ 是一个在所有可能的输入串上都会停机的图灵机 (TM)} \\}$。\n\nAlice 知道标准的停机问题 $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ 是一个在输入 } w \\text{ 上会停机的图灵机} \\}$ 是一个著名的不可判定语言。\n\n为了证明她的论点，她正确地构造了一个可计算函数 $f$，该函数将 `TOTAL_TM` 的任意实例 $\\langle M \\rangle$ 转换为 $A_{TM}$ 的一个实例 $\\langle M', w' \\rangle = f(\\langle M \\rangle)$，使得 $\\langle M \\rangle \\in \\text{`TOTAL_TM`}$ 当且仅当 $\\langle M', w' \\rangle \\in A_{TM}$。这建立了一个从 `TOTAL_TM` 到 $A_{TM}$ 的映射归约 (记作 $\\text{`TOTAL_TM`} \\le_m A_{TM}$)。\n\n然后 Alice 总结了她的证明：“既然我已经证明了 `TOTAL_TM` 可归约到 $A_{TM}$，并且我们知道 $A_{TM}$ 是不可判定的，那么从逻辑上可以推断出 `TOTAL_TM` 也必定是不可判定的。”\n\n下列哪个陈述最好地解释了 Alice 推理中的根本性缺陷？\n\nA. 为了通过归约证明一个语言 $P$ 是不可判定的，必须将一个已知的不可判定语言 $U$ *归约到* $P$ (即，证明 $U \\le_m P$)，而不是反过来。对于她要达成的目标来说，Alice 的归约方向是错误的。\nB. 语言 `TOTAL_TM` 不是图灵可识别的，而 $A_{TM}$ 是。映射归约只在处于同一可识别性类别（即可识别或都不可识别）的语言之间有效。\nC. Alice 的论证是循环论证。为了构造可计算函数 $f$，她必须已经隐含地假设了一种判定 `TOTAL_TM` 的方法，这与她试图证明的结论相矛盾。\nD. 这个归约是无效的，因为已知 `TOTAL_TM` 是一个比 $A_{TM}$ “更难”的问题。计算理论的一个基本定理是，不能将一个计算上更难的问题归约到一个更容易的问题。\nE. 任何从一个以单一编码 $\\langle M \\rangle$ 为输入的语言归约到一个以配对 $\\langle M, w \\rangle$ 为输入的语言，其本身都是有缺陷的，因为它需要制造原始输入中不存在的信息（即字符串 $w$）。", "solution": "我们已知语言 $\\text{TOTAL\\_TM} = \\{ \\langle M \\rangle \\mid M \\text{ 在所有输入上停机} \\}$ 和停机问题 $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ 在输入 } w \\text{ 上停机} \\}$，其中 $A_{TM}$ 是已知的不可判定语言。Alice 展示了一个映射归约 $\\text{TOTAL\\_TM} \\le_{m} A_{TM}$，并由此得出 $\\text{TOTAL\\_TM}$ 是不可判定的结论。\n\n回顾定义：对于语言 $A$ 和 $B$，$A \\le_{m} B$ 意味着存在一个全可计算函数 $f$，使得对于所有字符串 $x$，\n$$x \\in A \\iff f(x) \\in B.$$\n\n映射归约的关键性质：\n- 如果 $A \\le_{m} B$ 且 $B$ 是可判定的，那么 $A$ 也是可判定的。证明：给定一个用于 $B$ 的判定器，通过计算 $f(x)$ 并在其上运行 $B$ 的判定器来判定输入为 $x$ 的 $A$；当且仅当 $B$ 的判定器接受时，我们也接受。\n- 该陈述的逆否命题是：如果 $A$ 是不可判定的且 $A \\le_{m} B$，那么 $B$ 也是不可判定的。\n\n因此，要通过归约证明目标语言 $P$ 是不可判定的，必须将一个已知的不可判定语言 $U$ 归约到 $P$，即证明 $U \\le_{m} P$。这样一来，如果 $P$ 是可判定的，那么 $U$ 也将是可判定的，这与 $U$ 的已知不可判定性相矛盾。\n\n然而，Alice 证明的却是 $\\text{TOTAL\\_TM} \\le_{m} A_{TM}$。根据上述基本性质，这个蕴含关系只能得出：\n$$\\text{如果 } A_{TM} \\text{ 是可判定的，那么 } \\text{TOTAL\\_TM} \\text{ 也是可判定的。}$$\n但由于 $A_{TM}$ 是不可判定的，这个条件句并没有告诉我们任何关于 $\\text{TOTAL\\_TM}$ 可判定性的信息。因此，Alice 的结论是不成立的。\n\n一个具体的例证可以说明为什么这样的归约方向不能证明不可判定性：设 $L$ 是任意一个可判定语言， $D$ 是它的判定器。定义一个可计算函数 $f$，它在输入 $x$ 上运行 $D(x)$，如果 $D$ 接受，则输出一个固定的属于 $A_{TM}$ 的配对 $\\langle M_{halt}, w_{halt} \\rangle$；如果 $D$ 拒绝，则输出一个固定的不属于 $A_{TM}$ 的配对 $\\langle M_{loop}, w_{loop} \\rangle$。于是有 $x \\in L \\iff f(x) \\in A_{TM}$，即 $L \\le_{m} A_{TM}$，但 $L$ 是可判定的。因此，证明 $P \\le_{m} A_{TM}$ 并不能断定 $P$ 是不可判定的。\n\n因此，根本性的缺陷在于归约的方向。这对应于选项 A。其他选项是错误的，因为：映射归约不要求语言具有相同的可识别性状态（B 是错误的），构造函数 $f$ 并不需要假设存在一个用于 `TOTAL_TM` 的判定器（C 是错误的），“从更难到更容易”的说法不是这里所用的正式标准（D 具有误导性），以及通过可计算的填充或硬编码从单个元素生成配对是标准操作（E 是错误的）。", "answer": "$$\\boxed{A}$$", "id": "1457073"}]}