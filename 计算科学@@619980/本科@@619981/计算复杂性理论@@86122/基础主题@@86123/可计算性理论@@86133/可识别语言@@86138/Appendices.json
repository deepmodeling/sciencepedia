{"hands_on_practices": [{"introduction": "要真正理解可识别语言，最好的方法就是亲自设计一台图灵机。这个练习将带你入门，我们从一个直观的语言开始：由字母 $a$ 组成的、长度为完全平方数的字符串集合。你的任务是思考并确定一个图灵机的正确策略，这个策略必须精确地符合“识别者”的定义——当输入字符串属于该语言时，机器停机并接受；而当字符串不属于该语言时，机器可以拒绝，也可以永不停机。通过这个练习，你将对可识别语言和可判定语言之间的核心区别建立起坚实的直觉。[@problem_id:1442190]", "problem": "在计算理论中，形式语言是定义在有限字母表上的字符串集合。如果存在一台图灵机（TM）可以识别属于某个语言的字符串，那么该语言就被称为是*可识别的*。具体来说，对于任意给定的输入字符串 $w$，一台图灵机识别语言 $L$ 的条件是：\n1. 如果 $w$ 在 $L$ 中，则图灵机停机并进入`accept`状态。\n2. 如果 $w$ 不在 $L$ 中，则图灵机要么停机并进入`reject`状态，要么永远运行（永不停机）。\n\n考虑定义在字母表 $\\Sigma = \\{a\\}$ 上的语言 $L$，它是由所有长度为完全平方数的 'a' 字符串组成的集合。形式上，该语言为 $L = \\{ a^k \\mid k = n^2 \\text{ 对于某个整数 } n \\ge 0 \\}$。这包括空字符串，此时 $k=0$，因为 $0^2=0$。\n\n下面是为处理输入字符串 $w=a^k$ 而设计的图灵机的四种不同策略。以下哪种策略正确描述了一台能够识别语言 $L$ 的图灵机？\n\nA. 图灵机分阶段运行。在阶段 $n$（其中 $n=0, 1, 2, 3, \\dots$），图灵机计算值 $s = n^2$。然后它将输入字符串的长度 $k$ 与 $s$进行比较。如果 $k=s$，图灵机停机并接受。如果 $k \\ne s$，它进入下一阶段 $n+1$。\n\nB. 图灵机分阶段运行。在阶段 $n$（其中 $n=0, 1, 2, 3, \\dots$），图灵机计算值 $s = n^2$。然后它将输入字符串的长度 $k$ 与 $s$进行比较。如果 $s > k$，图灵机判定 $k$ 不可能是一个完全平方数，于是停机并拒绝。如果 $s = k$，图灵机进入一个特殊设计的无限循环。如果 $s < k$，它进入下一阶段 $n+1$。\n\nC. 图灵机的状态机中硬编码了一个大的固定整数 $M$（例如，$M=1,000,000$）。对于所有从 $0$ 到 $M$ 的 $n$，图灵机生成并测试每个完全平方数 $s=n^2$。如果输入字符串的长度 $k$ 与其中任何一个平方数匹配，图灵机就停机并接受。如果在检查完所有直到 $M^2$ 的平方数后仍未找到匹配项，图灵机就停机并拒绝。\n\nD. 图灵机非确定性地猜测一个整数 $m$ 使得 $1 \\le m^2 < k$，其中 $k$ 是输入字符串的长度。然后它检查余数 $k - m^2$ 是否也是一个完全平方数（包括 0）。如果它找到了一个满足此条件的 $m$，它就停机并接受。如果在所有可能的非确定性路径上都找不到这样的 $m$，机器就拒绝。", "solution": "我们使用这个定义：一台图灵机（TM）识别一个语言 $L$，指的是对于任何输入 $w$，当 $w \\in L$ 时，它停机并接受；当 $w \\notin L$ 时，它要么停机并拒绝，要么永远运行。这里的语言是一元平方数语言 $L = \\{ a^{k} \\mid \\exists n \\ge 0 \\text{ with } k = n^{2} \\}$。\n\n分析每个策略：\n\n- 选项 A：在阶段 $n = 0,1,2,\\dots$，计算 $s = n^{2}$ 并与 $k$ 比较。如果 $k = s$，停机并接受；否则继续。如果 $k \\in L$，则存在一个 $n$ 使得 $k = n^{2}$，因此机器在该阶段停机并接受（包括当 $k=0$ 时的 $n=0$）。如果 $k \\notin L$，那么对于所有的 $n$，都有 $k \\ne n^{2}$，所以机器永不停机（永远运行）。这满足了识别器的条件：准确地接受属于语言的成员；对于不属于语言的成员，允许不停机。因此，A 是一个正确的识别器。\n\n- 选项 B：在阶段 $n$，计算 $s = n^{2}$。如果 $s > k$，停机并拒绝；如果 $s = k$，进入无限循环；否则继续。对于 $k \\in L$，存在一个 $n$ 使得 $s = k$，但此时机器会进入循环并且不接受，这违反了必须接受语言成员的要求。因此 B 不是 $L$ 的识别器。\n\n- 选项 C：只测试直到一个固定上限 $M^{2}$ 的 $n^{2}$。如果 $k$ 与某个被测试的平方数匹配，则接受；否则拒绝。对于任何 $k = n^{2} > M^{2}$，即使 $k \\in L$，机器也会停机并拒绝，这违反了识别的定义。因此 C 不是 $L$ 的识别器。\n\n- 选项 D：非确定性地猜测一个 $m$ 使得 $1 \\le m^{2} < k$，并且如果 $k - m^{2}$ 是一个完全平方数（包括 $0$），则接受。一个正确的识别器必须接受所有 $k = n^{2}$。然而，对于许多平方数（例如 $k=4$ 或 $k=9$），不存在满足 $1 \\le m^{2} < k$ 且 $k - m^{2}$ 是完全平方数的 $m$；唯一的分解是 $k = n^{2} + 0^{2}$，但 $m = n$ 因 $m^{2} < k$ 的限制而不被允许。因此，该机器无法接受 $L$ 的所有成员。因此 D 不是 $L$ 的识别器。\n\n结论：只有 A 正确地识别了 $L$。", "answer": "$$\\boxed{A}$$", "id": "1442190"}, {"introduction": "掌握了识别者的基本定义后，我们将探索可计算性理论中一个深刻的边界：可识别但不可判定的语言。这个问题将通过一个实际的“程序验证”场景，引导你认识计算理论中最著名的例子之一——接受问题 $A_{TM}$。通过分析语法正确的程序语言 $L_{SYNTAX}$ 和那些能够停机并接受输入的程序语言 $L_{ACCEPT}$ 之间的关系，你将发现一个具体的、可被识别但从根本上无法被判定的语言。这个练习不仅是一个理论推导，它揭示了计算本身固有的、无法逾越的局限性。[@problem_id:1442181]", "problem": "在计算理论中，我们通过研究抽象机能处理的语言来分析其能力。一种*语言*是某个字母表上的字符串集合。如果存在一个算法（图灵机），它对每个输入字符串都会停机，并正确判断该字符串是否属于该语言，那么这种语言就称为*可判定的*。如果存在一个算法，当输入字符串属于该语言时，它会停机并接受，而当字符串不属于该语言时，它可能会停机并拒绝，或者无限循环，那么这种语言就称为*可识别的*。每种可判定的语言也都是可识别的，但反之不一定成立。\n\n考虑一个构建“通用程序验证器”的假设项目。我们将程序及其输入建模为字符串。设一个编码后的程序表示为 $P$，其输入表示为 $I$。我们将一个程序-输入对表示为单个字符串 $\\langle P, I \\rangle$。\n\n让我们定义与此验证器相关的两个特定语言：\n\n1.  $L_{SYNTAX}$：所有字符串 $\\langle P, I \\rangle$ 的语言，其中字符串 $P$ 代表一个根据特定程序设计语言语法规则的语法有效程序，而 $I$ 是该程序的有效输入。我们可以假设编译器总能解析字符串 $\\langle P, I \\rangle$ 并在有限时间内明确确定其语法是否格式良好。\n\n2.  $L_{ACCEPT}$：所有字符串 $\\langle P, I \\rangle$ 的语言，使得 $P$ 是一个语法有效的程序，$I$ 是一个有效输入，并且程序 $P$ 在以输入 $I$ 执行时，最终会停机并进入一个“接受”状态。\n\n根据这些定义和可计算性理论的基本原理，以下哪个陈述准确地描述了 $L_{SYNTAX}$ 和 $L_{ACCEPT}$ 的关系和性质？\n\nA. $L_{ACCEPT}$ 是可判定的，因为它是可判定语言 $L_{SYNTAX}$ 的一个子集。\nB. $L_{ACCEPT}$ 不是一个可判定的语言，并且它不是 $L_{SYNTAX}$ 的子集。\nC. $L_{ACCEPT}$ 是 $L_{SYNTAX}$ 的一个真子集，并且虽然 $L_{SYNTAX}$ 是可判定的，但 $L_{ACCEPT}$ 是可识别的但不是可判定的。\nD. $L_{SYNTAX}$ 和 $L_{ACCEPT}$ 都是可识别的，但两者都不是可判定的。\nE. $L_{ACCEPT}$ 不是一个可识别的语言。", "solution": "我们首先用可计算性理论的术语重述相关定义。如果存在一台图灵机，它对每个输入都会停机并正确判定其成员资格，那么一个语言就是可判定的。如果存在一台图灵机，它对语言中的成员会停机并接受，而对非成员则拒绝或无限循环，那么一个语言就是可识别的。\n\n考虑 $L_{SYNTAX} = \\{\\langle P, I \\rangle : P \\text{ 是一个语法有效的程序且 } I \\text{ 是 } P \\text{ 的有效输入}\\}$。根据假设，存在一个编译器或解析器，可以在有限时间内确定给定的 $\\langle P, I \\rangle$ 在语法上是否格式良好。因此，存在一个 $L_{SYNTAX}$ 的判定器，它对所有输入都会停机，并且恰好接受那些在 $L_{SYNTAX}$ 中的字符串。因此 $L_{SYNTAX}$ 是可判定的。由于每个可判定的语言都是可识别的，所以 $L_{SYNTAX}$ 也是可识别的。\n\n现在考虑 $L_{ACCEPT} = \\{\\langle P, I \\rangle : P \\text{ 是语法有效的，} I \\text{ 是有效的，且 } P \\text{ 在输入 } I \\text{ 上停机并接受}\\}$。根据其定义，如果 $\\langle P, I \\rangle \\in L_{ACCEPT}$，那么 $P$ 是语法有效的，并且 $I$ 是一个有效输入。因此我们有集合论上的蕴涵关系\n$$\n\\langle P, I \\rangle \\in L_{ACCEPT} \\implies \\langle P, I \\rangle \\in L_{SYNTAX},\n$$\n这得出了子集关系\n$$\nL_{ACCEPT} \\subseteq L_{SYNTAX}.\n$$\n此外，这个包含关系是真包含，因为存在语法有效的程序和输入，程序对其不接受（可能拒绝或无限循环），所以这些对属于 $L_{SYNTAX}$ 但不属于 $L_{ACCEPT}$。因此\n$$\nL_{ACCEPT} \\subset L_{SYNTAX}.\n$$\n\n接下来，我们分析 $L_{ACCEPT}$ 的可识别性和可判定性。为了证明其可识别性，定义一台图灵机 $U$，它在输入 $\\langle P, I \\rangle$ 上模拟 $P$ 在 $I$ 上的执行：如果模拟过程达到接受状态，$U$ 就接受。如果 $P$ 拒绝或无限循环，$U$ 也可能相应地拒绝或无限循环。这正是一个 $L_{ACCEPT}$ 的识别器，因此 $L_{ACCEPT}$ 是可识别的。\n\n为了证明 $L_{ACCEPT}$ 不是可判定的，我们将停机问题归约到它。设 $HALT = \\{ \\langle P, I \\rangle \\mid P \\text{ 在输入 } I \\text{ 上停机}\\}$。假设（为了引出矛盾）存在一个 $L_{ACCEPT}$ 的判定器 $D$。给定 $HALT$ 的一个任意实例 $\\langle P, I \\rangle$，构造一个新程序 $P^{\\dagger}$，它对任何输入 $x$ 模拟 $P$ 在 $I$ 上的执行，如果模拟停机（无论 $P$ 是接受还是拒绝），$P^{\\dagger}$ 就进入一个接受状态。形式上，$P^{\\dagger}$ 忽略 $x$ 并实现：模拟 $P$ 在 $I$ 上的执行；一旦 $P$ 停机，就接受。这个构造是有效的，并产生一个带有有效输入的语法有效程序。那么，对于 $P^{\\dagger}$ 的任何固定的有效输入 $x$，有\n$$\n\\langle P, I \\rangle \\in HALT \\iff \\langle P^{\\dagger}, x \\rangle \\in L_{ACCEPT}\n$$\n如果 $D$ 能判定 $L_{ACCEPT}$，我们就可以通过将 $\\langle P, I \\rangle$ 映射到 $\\langle P^{\\dagger}, x \\rangle$ 并运行 $D$ 来判定 $HALT$，这与已知的 $HALT$ 的不可判定性相矛盾。因此 $L_{ACCEPT}$ 是不可判定的。\n\n综合这些事实：\n- $L_{SYNTAX}$ 是可判定的（因此也是可识别的）。\n- $L_{ACCEPT}$ 是 $L_{SYNTAX}$ 的一个真子集，是可识别的，但不是可判定的。\n\n在给出的选项中，这恰好被选项C所描述。", "answer": "$$\\boxed{C}$$", "id": "1442181"}, {"introduction": "在研究形式语言时，一个核心任务是理解不同语言类别的闭包性质——即对一个类别中的语言进行某种运算后，得到的结果是否仍然属于该类别。这个更具挑战性的练习将引导你探究可识别语言类在“右商”运算下是否封闭。要解决这个问题，你需要设计一个更为复杂的图灵机构造方法。这促使你思考如何巧妙地管理和模拟无限的计算路径，例如使用一种称为“燕尾交叉” (dovetailing) 的强大技术，从而证明关于整个可识别语言类的一个重要性质。[@problem_id:1442152]", "problem": "在形式语言理论中，一个语言 $L$ 被定义为在某个有限字母表 $\\Sigma$ 上的字符串集合。一个语言 $L$ 被称为**可识别的**，如果存在一台图灵机（TM），对于任意输入字符串 $w$，当且仅当 $w \\in L$ 时，该图灵机停机并接受。对于不在 $L$ 中的字符串，该图灵机可能停机并拒绝，也可能无限循环。已知可识别语言类在某些运算（如并集、交集和连接）下是封闭的。\n\n考虑**右商**运算。对于同一字母表 $\\Sigma$ 上的两个语言 $L_1$ 和 $L_2$，它们的右商，记作 $L_1/L_2$，被定义为如下语言：\n$$L_1/L_2 = \\{x \\in \\Sigma^* \\mid \\text{there exists a string } y \\in L_2 \\text{ such that the concatenation } xy \\in L_1\\}$$\n\n你的任务是确定可识别语言类在这种右商运算下的封闭性。\n\n下列哪个陈述是正确的？\n\nA. 任意两个可识别语言 $L_1$ 和 $L_2$ 的右商 $L_1/L_2$ 总是可识别的。\nB. 右商 $L_1/L_2$ 是可识别的，当且仅当 $L_2$ 是一个可判定的语言（即可判定的语言是指存在一个对于所有输入都会停机的图灵机）。\nC. 右商 $L_1/L_2$ 是可识别的，当且仅当 $L_1$ 和 $L_2$ 都是可判定的语言。\nD. 右商 $L_1/L_2$ 不一定是可识别的。存在可识别语言 $L_1$ 和 $L_2$，使得它们的右商 $L_1/L_2$ 不是一个可识别语言。", "solution": "我们给定两个可识别语言 $L_{1}, L_{2} \\subseteq \\Sigma^{*}$，以及分别识别它们的图灵机 $M_{1}$ 和 $M_{2}$。即，对 $i \\in \\{1,2\\}$，$M_{i}$ 停机并接受的字符串集合恰好是 $L_i$，而对不在 $L_{i}$ 中的字符串，$M_i$ 可能拒绝或无限循环。\n\n我们必须确定右商\n$$\nL_{1}/L_{2}=\\{x \\in \\Sigma^{*} \\mid \\exists y \\in \\Sigma^{*} \\text{ such that } y \\in L_{2} \\text{ and } xy \\in L_{1}\\}\n$$\n是否可识别，以及在何种条件下可识别。\n\n从 $L_{1}$ 和 $L_{2}$ 的识别器构造 $L_{1}/L_{2}$ 的识别器：\n定义一台图灵机 $M$，它在输入 $x \\in \\Sigma^{*}$ 上，对所有 $y \\in \\Sigma^{*}$ 进行燕尾式搜索，并并行模拟 $M_{2}$ 在输入 $y$ 上以及 $M_{1}$ 在连接后的字符串 $xy$ 上的运行，具体如下。\n\n$M$ 在输入 $x$ 上的算法：\n1. 对于 $t=1,2,3,\\dots$ 执行：\n   - 按一个固定的有效顺序（例如，长度-字典序）枚举 $\\Sigma^{*}$ 中的前 $t$ 个字符串 $y_{1},\\dots,y_{t}$。\n   - 对于每个 $j \\in \\{1,\\dots,t\\}$，模拟 $M_{2}$ 在输入 $y_{j}$ 上运行 $t$ 步，并模拟 $M_{1}$ 在输入 $xy_{j}$ 上运行 $t$ 步。\n   - 如果对于某个 $j \\in \\{1,\\dots,t\\}$，两个模拟都在已执行的步骤内进入了它们的接受状态，那么接受 $x$。\n\n正确性：\n- 可靠性：如果 $M$ 接受 $x$，那么存在某个 $y_{j}$，使得 $M_{2}$ 接受 $y_{j}$ 并且 $M_{1}$ 接受 $xy_{j}$，因此 $y_{j} \\in L_{2}$ 且 $xy_{j} \\in L_{1}$。根据定义，可得 $x \\in L_{1}/L_{2}$。\n- 完备性：假设 $x \\in L_{1}/L_{2}$。那么存在一个字符串 $y \\in \\Sigma^{*}$，使得 $y \\in L_2$ 且 $xy \\in L_1$。设 $M_2$ 接受 $y$ 所需的有限步数为 $s_2$，$M_1$ 接受 $xy$ 所需的有限步数为 $s_1$。选择一个足够大的 $t \\geq \\max\\{s_{1},s_{2}\\}$，使得 $y$ 包含在 $y_{1},\\dots,y_{t}$ 中，并且 $t$ 步的模拟足以覆盖这两个接受过程。那么在阶段 $t$，$M$ 将会检测到两个模拟都接受，并会接受 $x$。因此，如果 $x \\in L_{1}/L_{2}$，$M$ 会停机并接受 $x$。\n\n如果 $x \\notin L_{1}/L_{2}$，那么对于每一个 $y \\in \\Sigma^{*}$，$M_2$ 对 $y$ 的运行或 $M_1$ 对 $xy$ 的运行至少有一个不接受；因此 $M$ 永远不会找到一个见证接受的配对，并可能永远运行下去，这对于一个识别器是允许的。因此，$M$ 识别 $L_{1}/L_{2}$。\n\n这个构造仅仅利用了 $L_{1}$ 和 $L_{2}$ 是可识别的（即 $M_{1}$ 和 $M_{2}$ 存在）这一事实，以及标准的燕尾式法则来实现一个存在性搜索。不需要对 $L_2$ 作可判定性假设。\n\n这对各选项意味着：\n- A 是正确的：对于任意可识别语言 $L_{1}$ 和 $L_{2}$，根据上述构造，其右商 $L_{1}/L_{2}$ 是可识别的。\n- B 是错误的：$L_1/L_2$ 的可识别性不要求 $L_2$ 是可判定的；$L_2$ 的可识别性就足够了。\n- C 是错误的：并非必须 $L_1$ 和 $L_2$ 都是可判定的；两者的可识别性就足够了。\n- D 是错误的：该构造表明，对于可识别的 $L_1$ 和 $L_2$，不存在反例。\n\n因此，正确的陈述是 A。", "answer": "$$\\boxed{A}$$", "id": "1442152"}]}