{"hands_on_practices": [{"introduction": "掌握映射归约的最好方法就是亲手构造它。我们将从一个基础练习开始，证明一个语言的不可判定性。这个练习将向我们展示如何将一个已知的不可判定问题（如图灵机的接受问题 $A_{TM}$）的“是/否”答案，编码到一个新图灵机语言的特定属性中。我们将要解决的问题是，判断一个图灵机是否恰好只接受一个字符串（$|L(M)| = 1$）是不可判定的。这个练习是一个完美的起点，因为它要求我们将新机器的语言精确地构造为要么是一个特定的单元素集合，要么是空集，这有助于我们清晰地理解归约的核心逻辑。[@problem_id:1431361]", "problem": "在可计算性理论中，证明一个语言是不可判定的一个核心方法是，展示一个从已知的不可判定语言到该语言的映射归约。设 $A_{TM}$ 是图灵机（TMs）的接受问题，定义为 $A_{TM} = \\{\\langle M, w \\rangle \\mid M \\text{ 是一个图灵机且 } M \\text{ 接受字符串 } w\\}$。已知语言 $A_{TM}$ 是不可判定的。\n\n考虑语言 $ONE_{TM}$，它被定义为所有接受的语言中恰好只包含一个字符串的图灵机的集合：\n$$ONE_{TM} = \\{\\langle M \\rangle \\mid M \\text{ 是一个图灵机且 } |L(M)| = 1\\}$$\n其中 $L(M)$ 是机器 $M$ 的语言，而 $|L(M)|$ 表示该语言中字符串的数量。\n\n为了证明 $ONE_{TM}$ 是不可判定的，可以构造一个可计算函数 $f$，它接受一个输入 $\\langle M, w \\rangle$ 并输出一个新图灵机 $M'$ 的描述。该函数必须满足映射归约的条件：$\\langle M, w \\rangle \\in A_{TM}$ 当且仅当 $\\langle M' \\rangle \\in ONE_{TM}$。\n\n设 $s_0$ 是一个固定的非空字符串（例如，$s_0 = \\text{computation}$）。函数 $f$ 基于 $M$ 和 $w$ 构造 $M'$。以下哪项关于 $M'$ 在任意输入字符串 $x$ 上的行为的描述正确地实现了这个归约？\n\nA. 在输入 $x$ 上，$M'$ 模拟 $M$ 在 $w$ 上的运行。如果该模拟接受，$M'$ 就接受 $x$。否则，$M'$ 拒绝 $x$。\n\nB. 在输入 $x$ 上，$M'$ 模拟 $M$ 在 $x$ 上的运行。如果该模拟接受，$M'$ 也接受 $x$。机器 $M'$ 还被硬编码为无论 $M$ 的行为如何都接受字符串 $s_0$。\n\nC. 在输入 $x$ 上，$M'$ 首先检查是否 $x = s_0$。如果 $x \\neq s_0$，$M'$ 立即拒绝。如果 $x = s_0$，$M'$ 接着继续模拟 $M$ 在 $w$ 上的运行。如果该模拟接受，$M'$ 就接受其输入 $s_0$。否则，$M'$ 拒绝。\n\nD. 在输入 $x$ 上，$M'$ 的行为与 $M$ 无关。它检查是否 $x=w$。如果是，$M'$ 接受。如果 $x \\neq w$，$M'$ 拒绝。", "solution": "我们要构造一个可计算函数 $f$，将输入 $\\langle M,w \\rangle$ 映射到一个图灵机 $M'$，使得\n$$\\langle M,w \\rangle \\in A_{TM} \\iff \\langle M' \\rangle \\in ONE_{TM}.$$\n根据定义，$\\langle M' \\rangle \\in ONE_{TM}$ 表示 $|L(M')|=1$。我们固定一个特定的非空字符串 $s_{0}$。\n\n定义 $f$ 如下：对输入 $\\langle M,w \\rangle$，输出图灵机 $M'$ 的编码，该图灵机在输入 $x$ 上执行以下操作：\n1. 如果 $x \\neq s_{0}$，拒绝。\n2. 如果 $x = s_{0}$，模拟 $M$ 在 $w$ 上的运行；如果模拟接受，则接受 $s_{0}$；如果模拟停机并拒绝，则拒绝 $s_{0}$；如果模拟不停机，那么 $M'$ 在 $s_{0}$ 上也不停机。\n\n这个 $f$ 是可计算的，因为 $M'$ 的描述可以由 $M$ 的代码、字符串 $w$ 和固定字符串 $s_{0}$ 通过硬编码一个与 $s_{0}$ 的比较以及对 $M$ 在 $w$ 上运行的模拟来有效构造。\n\n正确性：\n- 如果 $\\langle M,w \\rangle \\in A_{TM}$，那么 $M$ 接受 $w$。因此，在输入 $x=s_{0}$ 上，$M'$ 接受，而在所有 $x \\neq s_{0}$ 上，$M'$ 拒绝。因此 $L(M')=\\{s_{0}\\}$ 且 $|L(M')|=1$，所以 $\\langle M' \\rangle \\in ONE_{TM}$。\n- 如果 $\\langle M,w \\rangle \\notin A_{TM}$，那么 $M$ 不接受 $w$（要么拒绝，要么不停机）。因此，对于 $x=s_{0}$，$M'$ 不接受；对于 $x \\neq s_{0}$，$M'$ 拒绝。所以 $L(M')=\\varnothing$ 且 $|L(M')|=0$，故 $\\langle M' \\rangle \\notin ONE_{TM}$。\n\n因此 $\\langle M,w \\rangle \\in A_{TM} \\iff \\langle M' \\rangle \\in ONE_{TM}$，这与描述 C 相符。\n\n为什么其他选项是错误的：\n- 选项 A 使得如果 $M$ 接受 $w$，则 $L(M')=\\Sigma^{*}$，否则 $L(M')=\\varnothing$；$|L(M')|$ 永远不为 $1$。\n- 选项 B 确保了无论 $M$ 如何，$s_{0} \\in L(M')$，并且可能根据 $M$ 包含其他字符串，所以 $|L(M')|$ 很少为 $1$，也未编码 $M$ 是否接受 $w$。\n- 选项 D 完全忽略了 $M$，并且总是产生一个单元素语言 $\\{w\\}$，这破坏了与 $A_{TM}$ 的必要等价关系。\n\n因此，正确的实现是选项 C。", "answer": "$$\\boxed{C}$$", "id": "1431361"}, {"introduction": "在掌握了基础的归约构造之后，我们来挑战一个更复杂的属性。这次，我们不再关心语言中是否只有一个字符串，而是要判断它是否包含了一个无穷集合——所有偶数长度的字符串。这个练习 [@problem_id:1431374] 促使我们将之前学到的逻辑进行调整，以满足一个更广泛的条件，从验证单个字符串的存在性，升级到验证一整类字符串的普遍性。这有助于我们加深对如何通过归约来证明关于语言的“全体”性质的理解。", "problem": "在可计算性理论中，证明一个语言是不可判定的基本技术之一是通过映射归约。令 $\\Sigma = \\{0, 1\\}$ 为字母表。考虑著名的图灵机（TM）接受问题的不可判定语言：\n$$A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ 是一个接受字符串 } w \\text{ 的图灵机} \\}$$\n现在，考虑另一个与图灵机在偶数长度字符串上的行为相关的语言 $L_{EVEN}$：\n$$L_{EVEN} = \\{ \\langle M \\rangle \\mid M \\text{ 是一个图灵机且 } L(M) \\text{ 包含所有偶数长度的字符串} \\}$$\n为了证明 $L_{EVEN}$ 是不可判定的，我们可以构造一个从 $A_{TM}$ 到 $L_{EVEN}$ 的映射归约。这需要定义一个可计算函数 $f$，它将输入 $\\langle M, w \\rangle$ 转换为输出 $\\langle M' \\rangle$，使得 $\\langle M, w \\rangle \\in A_{TM}$ 当且仅当 $\\langle M' \\rangle \\in L_{EVEN}$。\n\n以下哪项正确描述了由该归约函数 $f$ 构造的机器 $M'$ 的行为？\n\nA. 对于输入 $x$，机器 $M'$ 模拟 $M$ 在 $w$ 上的运行。如果 $M$ 接受 $w$，$M'$ 就拒绝 $x$。如果 $M$ 不接受 $w$（即拒绝或进入无限循环），$M'$ 就接受 $x$。\n\nB. 对于输入 $x$，机器 $M'$ 模拟 $M$ 在 $w$ 上的运行。如果 $M$ 接受 $w$，$M'$ 就接着模拟 $M$ 在 $x$ 上的运行，且其行为与 $M$ 在 $x$ 上的行为一致。如果 $M$ 不接受 $w$，$M'$ 就拒绝 $x$。\n\nC. 对于输入 $x$，机器 $M'$ 首先检查 $x$ 的长度（记为 $|x|$）是否为偶数。如果 $|x|$ 是奇数，$M'$ 就拒绝。如果 $|x|$ 是偶数，$M'$ 就忽略 $x$ 并模拟 $M$ 在 $w$ 上的运行。如果模拟结果表明 $M$ 接受 $w$，那么 $M'$ 就接受 $x$。\n\nD. 对于输入 $x$，机器 $M'$ 首先检查 $x$ 的长度（记为 $|x|$）是否为偶数。如果 $|x|$ 是偶数，$M'$ 就接受。如果 $|x|$ 是奇数，$M'$ 模拟 $M$ 在 $w$ 上的运行，并在 $M$ 接受 $w$ 的情况下接受。", "solution": "我们的目标是构造一个可计算函数 $f$，它将 $A_{TM}$ 的实例 $\\langle M,w \\rangle$ 映射到 $L_{EVEN}$ 的实例 $\\langle M' \\rangle$ 上，使得\n$$\\langle M,w \\rangle \\in A_{TM} \\iff \\langle M' \\rangle \\in L_{EVEN}.$$\n回顾一下，$L_{EVEN} = \\{\\langle M \\rangle \\mid E \\subseteq L(M)\\}$，其中\n$$E = \\{x \\in \\Sigma^{*} : |x| \\text{ is even}\\}.$$\n\n我们通过从 $\\langle M,w \\rangle$ 构造 $M'$ 来定义 $f$ 如下。对于输入 $x$，机器 $M'$：\n1. 检查 $|x|$ 的奇偶性。\n2. 如果 $|x|$ 是奇数，$M'$ 拒绝 $x$。\n3. 如果 $|x|$ 是偶数，$M'$ 模拟 $M$ 在 $w$ 上的运行。如果模拟接受，$M'$ 就接受 $x$；如果模拟不接受（即拒绝或不停止），那么 $M'$ 也不接受 $x$。\n\n这个构造是可计算的，因为奇偶性检查以及将对 $M$ 在 $w$ 上的固定模拟硬编码进 $M'$ 中都是有效的操作。\n\n正确性证明：\n- 如果 $\\langle M,w \\rangle \\in A_{TM}$，那么 $M$ 接受 $w$。因此，对于所有 $|x|$ 为偶数的字符串 $x$，根据步骤3，$M'$ 都会接受 $x$。所以 $E \\subseteq L(M')$，于是 $\\langle M' \\rangle \\in L_{EVEN}$。\n- 如果 $\\langle M,w \\rangle \\notin A_{TM}$，那么 $M$ 不接受 $w$。那么对于所有 $|x|$ 为偶数的 $x$，步骤3中的模拟永远不会导致接受，因此 $M'$ 不会接受这样的 $x$。故存在一个偶数长度的字符串不在 $L(M')$ 中，所以 $E \\nsubseteq L(M')$ 且 $\\langle M' \\rangle \\notin L_{EVEN}$。\n\n因此，这个 $M'$ 满足了所要求的当且仅当条件，其所描述的行为与选项C匹配。\n\n检查其他选项：\n- A 反转了条件，使得当 $M$ 不接受 $w$ 时 $L(M') = \\Sigma^{*}$，而当 $M$ 接受 $w$ 时 $L(M')$ 为空集，这无法得出 $E \\subseteq L(M')$ 当且仅当 $M$ 接受 $w$。\n- B 使得当 $M$ 接受 $w$ 时，$L(M')$ 依赖于 $L(M)$ 在任意 $x$ 上的行为，这不能保证包含所有偶数长度的字符串。\n- D 使得所有偶数长度的字符串都会被接受，而不管 $M$ 和 $w$ 如何，这破坏了归约。\n\n因此，正确的描述是C。", "answer": "$$\\boxed{C}$$", "id": "1431374"}, {"introduction": "现在，让我们见证映射归约真正的威力，将其应用到一个非标准的计算模型上。通过将经典的停机问题 $HALT_{TM}$ 归约到一个关于双磁头图灵机 (2-HTM) 的问题，我们将证明这种模型的某个特定行为是不可判定的。这个练习 [@problem_id:1431410] 极具挑战性和启发性，它要求我们发挥创造力，将“停机”这一抽象性质转化为“磁头碰撞”这样一种物理事件，这充分展示了归约技术在不同计算模型和问题间的强大通用性。", "problem": "在可计算性理论中，一台标准的图灵机（TM）是一种计算模型，它有一条无限长的纸带和一个读写头。一台双头单带图灵机（2-HTM）是一种变体，它拥有一条无限长的纸带，但具有两个独立的读写头，我们称之为 $H_1$ 和 $H_2$。该机器的转移函数形式为 $\\delta: Q \\times \\Gamma^2 \\to Q \\times \\Gamma^2 \\times \\{L, R, S\\}^2$，其中 $Q$ 是状态集，$\\Gamma$ 是纸带字母表，$\\{L, R, S\\}$ 分别代表读写头的移动：左、右和保持不动。这意味着机器的下一步动作由其当前状态以及两个读写头读取的符号共同决定。\n\n如果一台 2-HTM $T$ 在其计算过程中的任何时刻，其两个读写头 $H_1$ 和 $H_2$ 占据了纸带上的同一个单元格，我们称之为发生了“读写头碰撞”。\n\n我们定义两种语言。第一种是众所周知的图灵机不可判定停机问题：\n$HALT_{TM} = \\{\\langle M, w \\rangle \\mid M \\text{ 是一台在输入串 } w \\text{ 上会停机的图灵机}\\}$。\n\n第二种是一种关于 2-HTM 行为的语言：\n$HEAD_{COLLIDE} = \\{\\langle T \\rangle \\mid T \\text{ 是一台 2-HTM，当其在一条完全空白的纸带上启动时，最终会发生读写头碰撞}\\}$。\n\n为了证明 $HEAD_{COLLIDE}$ 是不可判定的，我们可以构造一个从 $HALT_{TM}$ 出发的映射归约。这需要定义一个可计算函数 $f$，该函数将任意给定的输入 $\\langle M, w \\rangle$ 转换为一台特定 2-HTM 的描述，记为 $T = f(\\langle M, w \\rangle)$。这个转换必须满足映射归约性的核心性质：$M$ 在 $w$ 上停机，当且仅当 $T$ 在空白纸带上启动时会发生读写头碰撞。\n\n下列哪个陈述为构造 2-HTM $T$ 提供了最有效和最直接的策略，从而能正确地实现归约 $HALT_{TM} \\le_m HEAD_{COLLIDE}$？\n\nA. 机器 $T$ 将其读写头 $H_1$ 和 $H_2$ 放置在一段纸带的两端。$H_1$ 模拟 $M$ 在 $w$ 上的运行，而 $H_2$ 在模拟的每一步都向 $H_1$ 移动一步。当且仅当 $M$ 永远运行时，碰撞保证会发生。\n\nB. $T$ 的一个读写头（比如 $H_1$）被用于在纸带的一个区域上执行图灵机 $M$ 在输入 $w$ 上的模拟。另一个读写头 $H_2$ 保持在远离模拟区域的一个指定的“目标”单元格上静止不动。当且仅当对 $M$ 的模拟到达一个停机状态时，$T$ 进入一个特殊状态，在该状态下它指示 $H_1$ 移动到目标单元格，从而引发碰撞。\n\nC. $T$ 的两个读写头 $H_1$ 和 $H_2$ 从同一个单元格开始。$H_1$ 保持静止，而 $H_2$ 写入输入 $w$ 然后无限地向右移动。$M$ 在 $w$ 上的模拟被完全编码在 $T$ 的有限状态控制器中。碰撞在第一步就发生，这使得在 $HEAD_{COLLIDE}$ 中的成员资格变得平凡，并且与 $M$ 的行为无关。\n\nD. 读写头 $H_1$ 和 $H_2$ 都被用来模拟 $M$ 在 $w$上的计算。$H_1$ 模拟 $M$ 纸带的左半部分，$H_2$ 模拟右半部分。如果 $M$ 的计算需要其读写头从一半移动到另一半，则两个读写头会在纸带的中心点碰撞，这个事件被设计为对应于 $M$ 的停机。\n\nE. 机器 $T$ 使用读写头 $H_1$ 模拟 $M$ 在 $w$ 上的运行。读写头 $H_2$ 在同一纸带上一个独立的、平行的符号轨道上，完美地镜像 $H_1$ 的移动（例如，如果 $H_1$ 向左移动，$H_2$ 也向左移动）。如果 $M$ 的模拟停机，$T$ 进入一个清理阶段，在该阶段 $H_2$ 被移动到 $H_1$ 的轨道上以引发碰撞。", "solution": "我们寻求一个可计算映射 $f$，它将序对 $\\langle M,w \\rangle$ 映射到双头单带图灵机 $T$ 的编码 $\\langle T \\rangle$，使得\n$$\n\\langle M,w \\rangle \\in HALT_{TM} \\iff \\langle T \\rangle \\in HEAD_{COLLIDE}.\n$$\n最直接的构造方法是让一个读写头模拟 $M$ 在 $w$ 上的运行，并将另一个读写头固定在一个指定的目标单元格上。只有当模拟的计算停机时，我们才将执行模拟的读写头移动到目标单元格以强制发生读写头碰撞。\n\n将此策略形式化：给定 $\\langle M,w \\rangle$，我们如下定义 $T=f(\\langle M,w \\rangle)$。\n\n1. 在空白纸带上进行初始化。$T$ 使用其两个读写头 $H_{1}$ 和 $H_{2}$ 执行一个有限的设置过程：\n- 选择一个指定的目标单元格（例如，物理纸带位置 $0$）。在该单元格上写入一个唯一的标记符号 $\\#$。将 $H_{2}$ 放置在该目标单元格上，并此后一直保持其静止；这是通过转移函数始终为 $H_{2}$ 输出移动 $S$ 来强制执行的。\n- 选择一个与目标单元格不相交的模拟区域。为确保永远不相交，固定一个可计算双射 $g:\\mathbb{Z}\\to\\mathbb{N}$，并将模拟的纸带单元格 $i\\in\\mathbb{Z}$ 表示在物理纸带位置 $p(i)=-g(i)-1$ 上。因此，每个模拟的单元格都存储在严格为负的物理位置上。将 $H_{1}$ 放置在模拟区域（例如，在 $p(0)$ 处），并确保位置为 $0$ 的目标单元格永远不被模拟所使用。\n\n2. 编码输入。对 $T$ 进行编程，以便由 $H_{1}$ 将 $M$ 在输入 $w$ 上的模拟初始纸带写入模拟区域：对于每个对应于 $w$ 符号的 $i$，在 $p(i)$ 处写入该符号，并在其他地方写入空白符。这是一个有限的、可计算的初始化过程。\n\n3. 模拟阶段。当模拟的机器 $M$ 尚未到达停机状态时，$T$ 使用 $H_{1}$ 模拟 $M$ 的一步：\n- 在有限控制器内维护 $M$ 的当前模拟状态和当前模拟的读写头索引 $i\\in\\mathbb{Z}$。\n- 为了读取或写入模拟单元格 $i$，将 $H_{1}$ 移动到物理位置 $p(i)$，读取或写入存储在那里的符号，根据 $M$ 的转移函数更新模拟状态，并相应地将 $i$ 更新为 $i-1$、$i$ 或 $i+1$。因为 $p(i)$ 始终为严格负数，所以 $H_{1}$ 在此模拟阶段永不访问位置为 $0$ 的目标单元格。与此同时，$H_{2}$ 在目标单元格保持静止。\n\n4. 停机时碰撞阶段。当且仅当模拟的 $M$ 进入一个停机状态时，$T$ 转换到一个特殊阶段，在该阶段它忽略模拟数据，并重复地将 $H_{1}$ 向右移动，直到它到达位置为 $0$ 的目标单元格，而 $H_{2}$ 在那里是静止的。当 $H_{1}$ 第一次到达位置 $0$ 时，两个读写头占据同一个单元格，即发生读写头碰撞。\n\n归约的正确性：\n- 如果 $M$ 在 $w$ 上停机，那么模拟阶段将在有限时间内达到一个模拟的停机状态，$T$ 随之进入停机时碰撞阶段。在该阶段，$H_{1}$ 向右移动到目标单元格并与 $H_{2}$ 碰撞。因此 $\\langle T \\rangle \\in HEAD_{COLLIDE}$。\n- 如果 $M$ 不在 $w$ 上停机，那么模拟阶段永不停机。在整个模拟过程中，$H_{1}$ 被限制在严格为负的位置，而 $H_{2}$ 保持在位置 $0$ 静止。因此永远不会发生碰撞，并且 $\\langle T \\rangle \\notin HEAD_{COLLIDE}$。\n\n$f$ 的可计算性：给定 $\\langle M,w \\rangle$，$T$ 的描述可以通过将 $M$ 和 $w$ 硬编码到 $T$ 的有限控制器中，并使用固定的可计算函数 $g$ 来定位模拟的单元格来有效地生成。因此 $f$ 是可计算的，并且满足所要求的双向蕴含关系。\n\n因此，归约 $HALT_{TM} \\le_{m} HEAD_{COLLIDE}$ 通过上述策略得以实现，该策略与选项 B 相符。\n\n为什么其他选项失败或较差：\n- A 反转了条件（它表明碰撞发生当且仅当 $M$ 永远运行），这没有实现到 $HEAD_{COLLIDE}$ 的所需映射。\n- C 使得碰撞立即发生且独立于 $M$ 和 $w$，因此没有产生归约。\n- D 将碰撞与读写头交叉事件而不是停机联系起来，这通常不对应于 $M$ 的停机。\n- E 可以被设计出来，但引入了关于单纸带上“单独轨道”的不必要复杂性和模糊性；B 是直接的、标准的构造方法，它简洁地强制了碰撞当且仅当停机。\n\n因此，最有效和最直接的策略是 B。", "answer": "$$\\boxed{B}$$", "id": "1431410"}]}