{"hands_on_practices": [{"introduction": "本练习探讨了一种最基本的计算模式：对输入进行单次从左到右的扫描。通过分析一台验证简单交替模式的图灵机，你将理解线性时间复杂度（表示为 $O(n)$）是如何产生的，这代表计算时间与输入规模成正比。这个练习为你分析更复杂的算法奠定了基础。[@problem_id:1466953]", "problem": "考虑一个单带图灵机 (TM)，它被设计用来判定语言 $L$。该语言由字母表 $\\Sigma = \\{0, 1\\}$ 上0和1交替出现的字符串组成。$L$ 中的字符串示例包括空字符串、\"0\"、\"1\"、\"010\" 和 \"10101\"。一个长度为 $n = |w|$ 的输入字符串 $w$ 被放置在一条原本为空白的带子上。该图灵机开始时，其读写头位于 $w$ 的最左边符号上。如果 $w$ 是空字符串，则读写头从一个空白符号 $\\sqcup$ 开始。\n\n该图灵机是确定性的，并根据以下高级描述进行操作：\n\n1.  图灵机从起始状态 $q_{start}$ 开始。\n2.  如果读写头下的符号是空白符号 $\\sqcup$，它会转移到停机接受状态 $q_{accept}$。这处理了空字符串的情况。\n3.  如果符号是 '0'，它会转移到状态 $q_{expect\\_1}$ 并将读写头向右移动一格。\n4.  如果符号是 '1'，它会转移到状态 $q_{expect\\_0}$ 并将读写头向右移动一格。\n5.  当处于状态 $q_{expect\\_1}$ 时：\n    a. 如果读到 '1'，它会转移到状态 $q_{expect\\_0}$ 并将读写头向右移动一格。\n    b. 如果读到空白符号 $\\sqcup$，它会转移到停机接受状态 $q_{accept}$。\n    c. 如果读到 '0'，它会转移到停机拒绝状态 $q_{reject}$。\n6.  当处于状态 $q_{expect\\_0}$ 时：\n    a. 如果读到 '0'，它会转移到状态 $q_{expect\\_1}$ 并将读写头向右移动一格。\n    b. 如果读到空白符号 $\\sqcup$，它会转移到停机接受状态 $q_{accept}$。\n    c. 如果读到 '1'，它会转移到停机拒绝状态 $q_{reject}$。\n7.  一旦图灵机进入 $q_{accept}$ 或 $q_{reject}$，它就会停机。\n\n对于此图灵机，单个计算步骤包括读取一个符号、改变状态以及移动读写头（或停机）。对于长度为 $n > 0$ 的输入字符串，此图灵机的最坏情况时间复杂度 $T(n)$ 用大O表示法表示是什么？\n\nA. $O(1)$\n\nB. $O(\\log n)$\n\nC. $O(n)$\n\nD. $O(n \\log n)$\n\nE. $O(n^2)$", "solution": "设 $n$ 表示输入长度，且 $n>0$。定义 $S(w)$ 为在输入 $w$ 上的计算步骤数，并将最坏情况时间复杂度定义为 $T(n)=\\max_{|w|=n}S(w)$。\n\n每个计算步骤包括读取当前符号、改变状态以及将读写头向右移动一格（或停机）。给定的转移规则确保图灵机永远不会向左移动；它严格地从左到右扫描，并在检测到不匹配或在最后一个输入符号后看到空白符号时停机。\n\n对于任何 $|w|=n$ 的非空输入 $w$：\n- 在位置1，处于状态 $q_{start}$ 的机器读取 $w_{1}$，转移到 $q_{expect\\_1}$ 或 $q_{expect\\_0}$，并向右移动。这是一个步骤。\n- 对于 $2 \\leq i \\leq n$ 的每个后续位置 $i$，如果直到 $w_{i}$ 的前缀都符合交替规则，机器会读取 $w_{i}$，在 $q_{expect\\_0}$ 和 $q_{expect\\_1}$ 之间转移，并向右移动。每个这样的位置恰好贡献1个步骤。如果在位置 $i$ 发生违例，机器将转移到 $q_{reject}$ 并停机，因此在这种情况下 $S(w)=i$。\n- 如果直到位置 $n$ 都没有发生违例，那么在第 $n$ 步之后，读写头位于输入右侧的空白单元格上，机器会对 $\\sqcup$ 执行最后一步，进入 $q_{accept}$ 并停机。因此，对于一个交替字符串，$S(w)=n+1$。\n\n因此，最坏情况发生在 $w$ 是完美交替字符串时，得出\n$$\nT(n)=\\max_{|w|=n}S(w)=n+1.\n$$\n因此，用大O表示法，\n$$\nT(n)\\in O(n).\n$$\n在给出的选项中，这对应于选项C。", "answer": "$$\\boxed{C}$$", "id": "1466953"}, {"introduction": "并非所有问题都能通过单次扫描解决，许多算法需要在带上反复移动。本练习通过分析一台复制输入字符串的图灵机，展示了重复扫描和倒带操作如何自然地导致 $O(n^2)$ 的二次时间复杂度。理解这一点对于认识单带图灵机的局限性和设计高效算法至关重要。[@problem_id:1466996]", "problem": "一台单带图灵机 (TM) 的任务是复制一个给定的输入字符串。输入是一个长度为 $n$ 的字符串 $w$，由字母表 $\\Sigma = \\{a, b\\}$ 中的符号组成。带字母表为 $\\Gamma = \\{a, b, \\dot{a}, \\dot{b}, \\sqcup\\}$，其中 $\\dot{a}$ 和 $\\dot{b}$ 分别是 $a$ 和 $b$ 的“标记”版本，$\\sqcup$ 是空白符号。\n\n最初，带上包含 ...$\\sqcup$ w $\\sqcup$...，读写头位于 $w$ 的第一个符号上。图灵机必须在带上内容为 ...$\\sqcup$ ww $\\sqcup$... 时停机。读写头的最终位置不重要。\n\n该图灵机执行以下算法：\n1.  **主循环：** 此循环对原始输入字符串 $w$ 中的每个符号重复执行。对于第 $i$ 次迭代（其中 $i=1, \\dots, n$）：\n    a. 从带的最左端开始，读写头向右移动以找到第一个未标记的符号（即原始字符串的第 $i$ 个符号）。设该符号为 $\\sigma$。读写头读取 $\\sigma$ 并将其替换为标记版本 $\\dot{\\sigma}$。\n    b. 读写头向右移动，越过带上所有非空白符号，直到找到第一个空白单元格 $\\sqcup$。\n    c. 读写头在该空白单元格中写入符号 $\\sigma$。\n    d. 读写头一直向左移动，返回到带的第一个单元格，以准备开始下一次迭代。\n\n2.  **清理阶段：** 主循环完成后，带上包含 $\\dot{w}w$，其中 $\\dot{w}$是原始字符串的标记版本。图灵机从带的开头执行最后一次扫描，将 $n$ 个标记符号 $\\dot{\\sigma}$ 替换回其原始版本 $\\sigma$。\n\n确定此完整算法的总体时间复杂度，该复杂度定义为读写头执行的单个步骤（读、写或左/右移动）的总数。请使用大O表示法将答案表示为输入字符串 $w$ 长度 $n$ 的函数。", "solution": "我们计算读写头的基本操作：每次读取、每次写入以及每次单格移动都计为一个步骤。设输入长度为 $n$。在主循环的第 $i$ 次迭代期间（其中 $i \\in \\{1,\\dots,n\\}$），在写入复制的符号之前，带上有 $n+(i-1)$ 个非空白符号；在写入第 $i$ 个复制的符号之后，带上有 $n+i$ 个非空白符号。\n\n对于第 $i$ 次迭代，我们将成本 $T_{i}$ 分解为与步骤(a)-(d)相对应的四个部分：\n\n- 步骤(a)：从最左端（第一个符号）到第一个未标记的符号（即第 $i$ 个符号），读写头检查 $i$ 个单元格，向右移动越过前 $i-1$ 个已标记的单元格并停在第 $i$ 个上。这需要 $i$ 次读取、$(i-1)$ 次右移和 $1$ 次写入以进行标记，成本为\n$$\nA_{i} = i + (i-1) + 1 = 2i.\n$$\n\n- 步骤(b)：从位置 $i$ 到右侧的第一个空白单元格，读写头必须穿过 $n$ 个位置（剩下的 $n-i$ 个原始符号和之前附加的 $i-1$ 个符号，再加上一次进入空白格的移动）。每次移动都包含一次移动和一次读取，所以\n$$\nB_{i} = n + n = 2n.\n$$\n\n- 步骤(c)：在空白单元格中写入符号 $\\sigma$ 是一次写入操作：\n$$\nC_{i} = 1.\n$$\n\n- 步骤(d)：返回到第一个（最左边）符号的操作是这样实现的：一直向左移动直到遇到左侧的空白符号，然后向右移动一次到达第一个符号。在步骤(c)之后，带上有 $n+i$ 个非空白符号。因此，从最右边的非空白符号处一直移动到其左侧的空白符号处需要 $(n+i)$ 次左移和 $(n+i)$ 次读取，然后一次右移和一次读取以停在并识别第一个符号。因此\n$$\nD_{i} = (n+i) + (n+i) + 1 + 1 = 2(n+i) + 2.\n$$\n\n将第 $i$ 次迭代的这四部分贡献相加，得到\n$$\nT_{i} = A_{i} + B_{i} + C_{i} + D_{i} = 2i + 2n + 1 + 2(n+i) + 2 = 4n + 4i + 3.\n$$\n\n因此，主循环的总成本为\n$$\n\\sum_{i=1}^{n} T_{i} = \\sum_{i=1}^{n} \\left(4n + 4i + 3\\right) = 4n^{2} + 4 \\cdot \\frac{n(n+1)}{2} + 3n = 6n^{2} + 5n,\n$$\n即 $O(n^{2})$。\n\n清理阶段：主循环结束后，带上包含 $\\dot{w}w$，其中 $|\\dot{w}| = n$。最后一次扫描通过一次从左到右遍历前 $n$ 个单元格，将每个标记符号替换回其未标记版本。每个单元格的操作使用常数数量的步骤（一次读取、一次写入以及在相邻单元格之间的移动），因此清理成本为 $O(n)$。\n\n结合这两个部分，总体时间复杂度为\n$$\nO(n^{2}) + O(n) = O(n^{2}).\n$$\n\n为求完整性，我们还可给出一个匹配的下界：每次迭代都必须从靠近左端的位置移动到遥远的右端，然后再返回，跨越的带段长度为 $\\Theta(n+i)$。因此，总移动次数至少是 $\\sum_{i=1}^{n} n = \\Theta(n^{2})$ 的数量级。所以该算法的运行时间为 $\\Theta(n^{2})$，用大O表示法，其时间复杂度为 $O(n^{2})$。", "answer": "$$\\boxed{O(n^{2})}$$", "id": "1466996"}, {"introduction": "本练习介绍了一种更复杂的算法技巧：在图灵机上实现“分治”策略。通过分析一台判断输入长度是否为2的幂的机器，你将看到算法如何通过重复减半问题规模来求解。这个过程揭示了 $O(n \\log n)$ 这一重要复杂度类的起源，它代表了对数次线性时间操作的累积效应。[@problem_id:1466990]", "problem": "考虑一台单带图灵机 (TM)，它用于判定语言 $L = \\{a^n \\mid n = 2^k \\text{ for some integer } k \\ge 0\\}$，输入字母表为 $\\Sigma = \\{a\\}$。其带字母表为 $\\Gamma = \\{a, x, \\sqcup\\}$，其中 $\\sqcup$ 是空白符号。\n\n该图灵机对长度为 $n$ 的输入字符串按以下算法运行：\n\n1.  如果带子为空（输入为空字符串，$n=0$），机器停机并拒绝。\n2.  机器从左到右扫描带子。在扫描过程中，它统计符号 'a' 的数量。\n3.  如果 'a' 的数量恰好为一，机器停机并接受。\n4.  如果 'a' 的数量为奇数且大于一，机器停机并拒绝。\n5.  如果 'a' 的数量为偶数且大于一，机器准备进行下一轮扫描。它将读写头倒回到最左边的单元格。然后，它开始新一轮从左到右的扫描。在这次新的扫描中，它将遇到的每第二个 'a' 用符号 'x' 覆盖来标记它。\n6.  标记扫描完成后，机器将读写头倒回到最左边的单元格，并返回步骤 2 以统计剩余未标记的 'a' 的数量。\n\n这台图灵机的时间复杂度是多少，用关于输入长度 $n$ 的函数的大O表示法表示？\n\nA. $O(n)$\n\nB. $O(n \\log n)$\n\nC. $O(n^2)$\n\nD. $O(\\log n)$\n\nE. $O(2^n)$", "solution": "设输入长度为 $n$。该机器重复执行扫描过程，每次扫描包括：\n- 一次从左到右的计数扫描，范围是带子的已使用部分，其长度为 $n$，因为在标记过程中没有引入空白符（符号仅从 $a$ 变为 $x$），\n- 有条件地将读写头倒回到左端（每次都是一次从右到左最多扫描 $n$ 个单元格的扫描），\n- 以及，当 'a' 的数量为偶数且大于一时，进行一次从左到右的标记扫描，标记每第二个 'a'（同样最多扫描 $n$ 个单元格），然后再次倒带。\n\n因此，每个完整的减半轮次（计数、倒带、标记、倒带）的成本至多是 $n$ 的一个常数倍。单独一次计数扫描的成本至多也是 $n$ 的一个常数倍。\n\n设 $v_{2}(n)$ 是满足 $2^{t} \\mid n$ 的最大整数 $t$。每次计数为偶数且大于一时，未标记的 'a' 的数量减半，因此在机器达到一个奇数计数（大于一）并拒绝，或达到1并接受之前，总共会进行 $v_{2}(n)$ 轮标记。因此：\n- 计数扫描发生 $v_{2}(n) + 1$ 次（每轮一次，包括最后停机的那一轮），\n- 标记扫描发生 $v_{2}(n)$ 次，\n- 倒带发生 $2 v_{2}(n)$ 次（在每次导致标记的计数扫描后一次，以及在每次标记扫描后一次）。\n\n每次扫描或倒带最多扫描 $n$ 个单元格，因此存在一个常数 $c > 0$ 使得\n$$\nT(n) \\le c\\,n\\,( (v_{2}(n)+1) + v_{2}(n) + 2 v_{2}(n) ) = c\\,n\\,(4 v_{2}(n) + 1).\n$$\n由于 $v_{2}(n) \\le \\lfloor \\log_{2}(n) \\rfloor$，可得\n$$\nT(n) = O\\!\\left(n \\log_{2}(n)\\right).\n$$\n因此，时间复杂度为 $O(n \\log n)$，对应于选项 B。", "answer": "$$\\boxed{B}$$", "id": "1466990"}]}