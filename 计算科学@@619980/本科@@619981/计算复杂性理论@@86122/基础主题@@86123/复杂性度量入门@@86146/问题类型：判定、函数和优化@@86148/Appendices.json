{"hands_on_practices": [{"introduction": "我们首先从一个直观的例子开始，探索优化问题和判定问题之间的基本关系。想象一下，如果你有能力计算出任意网络中最大的数据带宽（这是一个优化问题），那么判断该网络是否能支持某个特定带宽需求（这是一个判定问题）就变得非常简单。这个练习将帮助你形式化这一过程，展示如何利用优化问题的解来直接回答一个相关的判定问题。[@problem_id:1437415]", "problem": "在网络工程和计算理论领域，我们通常区分优化问题和判定问题。\n\n考虑以下优化问题：\n- **问题名称**：`MAX_BANDWIDTH`\n- **输入**：一个表示为图 $G$ 的网络，其中节点是服务器，带权边代表直接连接的容量。\n- **输出**：一个实数，表示整个网络中*任意*一对不同节点之间可实现的最大数据带宽。\n\n现在，考虑相关的判定问题：\n- **问题名称**：`CAN_SUPPORT_SERVICE`\n- **输入**：一个网络图 $G$ 和一个所需的带宽阈值 $B > 0$。\n- **输出**：如果网络中存在至少一对节点能够支持不小于 $B$ 的通信带宽，则输出 'YES'。否则，输出 'NO'。\n\n假设您可以访问一个假设性的“谕示机”——一个可以为您提供的任何网络图 $G$ 输入瞬间解决 `MAX_BANDWIDTH` 问题的黑盒计算设备。您的任务是设计一个算法，使用这个谕示机来解决 `CAN_SUPPORT_SERVICE` 判定问题。\n\n以下哪个过程能使用 `MAX_BANDWIDTH` 谕示机正确且最高效地解决 `CAN_SUPPORT_SERVICE(G, B)` 问题？\n\nA.\n1. 将网络图 $G$ 作为输入提供给 `MAX_BANDWIDTH` 谕示机。\n2. 设谕示机的数值输出为 $M$。\n3. 如果 $M \\geq B$，算法返回 'YES'。\n4. 否则，算法返回 'NO'。\n\nB.\n1. 将网络图 $G$ 和阈值 $B$ 同时作为输入提供给 `MAX_BANDWIDTH` 谕示机。\n2. 如果谕示机返回的值大于 0，算法返回 'YES'。\n3. 否则，算法返回 'NO'。\n\nC.\n1. 识别网络图 $G$ 中所有唯一的节点对 $(u, v)$。\n2. 对每一对节点，都以图 $G$ 作为输入调用 `MAX_BANDWIDTH` 谕示机。\n3. 如果其中任何一次调用返回的值 $M \\geq B$，算法立即返回 'YES'。\n4. 如果所有节点对都检查完毕且此条件从未满足，算法返回 'NO'。\n\nD.\n1. 将网络图 $G$ 作为输入提供给 `MAX_BANDWIDTH` 谕示机。\n2. 设谕示机的数值输出为 $M$。\n3. 如果 $M < B$，算法返回 'YES'。\n4. 否则，算法返回 'NO'。\n\nE.\n1. 首先，检查图 $G$ 中的边数是否大于或等于阈值 $B$。\n2. 如果是，则调用 `MAX_BANDWIDTH` 谕示机。如果谕示机返回一个正数，算法返回 'YES'。\n3. 否则，算法返回 'NO'。", "solution": "我们将优化谕示机和判定谓词进行形式化，以推导出正确的归约。\n\n设 $\\text{bw}(u,v)$ 表示图 $G$ 中节点 $u$ 和 $v$ 之间可实现的最大带宽。`MAX_BANDWIDTH` 的优化谕示机返回\n$$\nM^{\\ast}=\\max_{u\\neq v}\\text{bw}(u,v).\n$$\n判定问题 $\\text{CAN\\_SUPPORT\\_SERVICE}(G,B)$ 询问是否存在\n$$\n\\exists\\,(u,v)\\text{ with }u\\neq v\\text{ such that }\\text{bw}(u,v)\\geq B.\n$$\n根据有限集上最大值的基本性质，以下等价关系成立：\n$$\n\\left(\\exists\\,(u,v):\\text{bw}(u,v)\\geq B\\right)\\quad\\Longleftrightarrow\\quad \\max_{u\\neq v}\\text{bw}(u,v)\\geq B,\n$$\n即，\n$$\n\\exists\\,(u,v):\\text{bw}(u,v)\\geq B\\quad\\Longleftrightarrow\\quad M^{\\ast}\\geq B.\n$$\n因此，一个调用一次 `MAX_BANDWIDTH` 谕示机以获得 $M^{\\ast}$，并且当且仅当 $M^{\\ast}\\geq B$ 时返回 'YES' 的算法是正确的。\n\n在给定的过程中：\n- A 精确地实现了这个单次调用的比较 $M\\geq B$，因此是正确的，并且只使用了一次谕示机，这是最高效的。\n- B 是无效的，因为该谕示机只接受 $G$ 作为输入，并且它检查的是 $M>0$ 而不是 $M\\geq B$，当 $0<M<B$ 时会失败。\n- C 对每一对节点都用相同的 $G$ 重复调用同一个谕示机，每次都会产生相同的 $M$；虽然它能返回正确答案，但其效率严格低于 A。\n- D 反转了比较条件（它在 $M<B$ 时返回 'YES'），所以是不正确的。\n- E 使用了一个不相关的边数启发式方法，并且同样检查的是 $M>0$，所以是不正确的。\n\n因此，正确且最高效的过程是 A。", "answer": "$$\\boxed{A}$$", "id": "1437415"}, {"introduction": "现在，我们将挑战一个更复杂但极其强大的技术：利用判定预言机（decision oracle）来解决一个优化问题。在编译器设计和自动机理论中，一个核心任务是将非确定性有限自动机（NFA）转换为状态数最少的等价确定性有限自动机（DFA）。本练习假设你只有一个“黑盒”工具，它只能回答“是否存在一个不多于 $k$ 个状态的等价DFA？”这样的判定问题，而你的任务是巧妙地运用这个工具，精确地找出最小状态数。[@problem_id:1437439]", "problem": "在编译器设计和形式语言理论领域，优化状态机的大小是一项关键任务。考虑一个非确定性有限自动机 (Nondeterministic Finite Automaton, NFA)，记作 $N$，它由一个五元组 $(Q, \\Sigma, \\delta, q_0, F)$ 定义。给定一个特定的 NFA，$N_{spec}$，其组成部分如下：\n- 状态集合 $Q = \\{q_0, q_1, q_2, q_3\\}$。\n- 输入字母表 $\\Sigma = \\{a, b\\}$。\n- 起始状态为 $q_0$。\n- 终结（接受）状态集合为 $F = \\{q_3\\}$。\n- 转移函数 $\\delta: Q \\times \\Sigma \\to \\mathcal{P}(Q)$ 定义如下：\n    - $\\delta(q_0, a) = \\{q_0, q_1\\}$\n    - $\\delta(q_0, b) = \\{q_0\\}$\n    - $\\delta(q_1, b) = \\{q_2\\}$\n    - $\\delta(q_2, a) = \\{q_3\\}$\n    - 所有其他转移都指向空集 $\\emptyset$。例如，$\\delta(q_1, a) = \\emptyset$。\n\n你有一个功能强大但不透明的软件库。该库提供一个单一函数 `CAN_MINIMIZE(N, k)`，它接受一个 NFA $N$ 和一个正整数 $k$ 作为输入。如果存在一个等价的、最多有 $k$ 个状态的确定性有限自动机 (Deterministic Finite Automaton, DFA)，该函数返回 `TRUE`，否则返回 `FALSE`。你无法访问此函数的源代码，只能将其当作一个黑盒预言机使用。\n\n你的任务是确定与给定的 NFA $N_{spec}$ 等价的最小 DFA 的确切状态数。你可以根据需要多次调用 `CAN_MINIMIZE` 函数。这个最小状态数是多少？", "solution": "我们首先刻画给定的 NFA $N_{spec}$ 所识别的语言。唯一的接受状态是 $q_{3}$，到达 $q_{3}$ 的唯一路径是 $q_{0} \\xrightarrow{a} q_{1} \\xrightarrow{b} q_{2} \\xrightarrow{a} q_{3}$。从 $q_{3}$ 没有出射转移，因此任何接受计算都必须在该序列的最后一个 $a$ 被读取时精确结束。由于 $q_{0}$ 对 $a$ 和 $b$ 都有自环（通过 $\\delta(q_{0},a) \\ni q_{0}$ 和 $\\delta(q_{0},b)=\\{q_{0}\\}$），自动机可以在任何前缀上停留在 $q_{0}$，并在倒数第三个符号是 $a$ 时非确定性地选择进入 $q_{1}$，然后读取 $b$ 和 $a$ 来结束。因此，该语言是\n$$\nL = \\{\\, xaba : x \\in \\{a,b\\}^{*} \\,\\},\n$$\n即所有在 $\\{a,b\\}$ 上以后缀 $aba$ 结尾的字符串集合。\n\n为了确定 $L$ 的最小 DFA 的状态数，我们使用 Myhill–Nerode 定理和标准构造方法，构造一个 DFA 来跟踪输入中同时也是模式串 $aba$ 前缀的最长后缀。\n\n上界（存在一个有 $4$ 个状态的 DFA）：考虑一个 DFA，其状态对应于到目前为止读取的输入中，同时也是 $aba$ 的前缀的最长后缀的长度。设这些长度为 $0,1,2,3$，其中状态 $3$ 是接受状态。通过在读取每个符号时更新这个最长后缀的长度来计算转移：\n- 从状态 $0$：输入 $a$ 到状态 $1$；输入 $b$ 到状态 $0$。\n- 从状态 $1$：输入 $a$ 到状态 $1$（$aa$ 的最长后缀中作为 $aba$ 前缀的是 $a$）；输入 $b$ 到状态 $2$（匹配 $ab$）。\n- 从状态 $2$：输入 $a$ 到状态 $3$（匹配 $aba$）；输入 $b$ 到状态 $0$（$abb$ 的后缀中没有非空的 $aba$ 前缀）。\n- 从状态 $3$：输入 $a$ 到状态 $1$（$abaa$ 的最长后缀中作为 $aba$ 前缀的是 $a$）；输入 $b$ 到状态 $2$（$abab$ 的最长后缀中作为 $aba$ 前缀的是 $ab$）。\n这个 DFA 有 $4$ 个状态，并且它精确地接受那些在处理完整个输入后最终状态为 $3$ 的字符串，即恰好是以 $aba$ 结尾的字符串。因此，存在一个等价的、最多有 $4$ 个状态的 DFA。\n\n下界（至少需要 $4$ 个状态）：根据 Myhill–Nerode 定理，我们通过展示 $4$ 个相对于 $L$ 两两可区分的字符串，来证明至少存在 $4$ 个不同的右同余类。取集合 $\\{\\epsilon, a, ab, aba\\}$。我们通过合适的扩展来展示其两两可区分性：\n- $aba$ 在 $L$ 中，而 $\\epsilon$、$a$ 和 $ab$ 不在 $L$ 中；因此通过扩展 $z=\\epsilon$，$aba$ 可与 $\\epsilon$、$a$ 和 $ab$ 中的每一个区分开。\n- 要区分 $ab$ 和 $a$：取 $z=a$。那么 $abz=aba \\in L$，而 $az=aa \\notin L$。\n- 要区分 $a$ 和 $\\epsilon$：取 $z=ba$。那么 $az=aba \\in L$，而 $\\epsilon z=ba \\notin L$。\n这证明了至少存在 $4$ 个不同的 Myhill–Nerode 等价类，因此任何用于 $L$ 的 DFA 都必须至少有 $4$ 个状态。\n\n结合上界和下界，与 $N_{spec}$ 等价的最小 DFA 恰好有 $4$ 个状态。等价地，黑盒会报告 $\\text{CAN\\_MINIMIZE}(N_{spec},3)=\\text{FALSE}$ 和 $\\text{CAN\\_MINIMIZE}(N_{spec},4)=\\text{TRUE}$。\n\n因此，最小状态数是 $4$。", "answer": "$$\\boxed{4}$$", "id": "1437439"}, {"introduction": "在前一个练习的基础上，我们将二分搜索策略的应用从离散领域（如状态数）扩展到连续领域。考虑一个实际的几何问题：为一组服务点找到能覆盖它们的最小广播圆。这个问题将引导你思考，即便我们的决策工具（“这些点能否被半径为 $r$ 的圆覆盖？”）只能给出是或否的答案，我们依然可以通过系统性的方法，在任意给定的精度 $\\epsilon$ 内逼近最优半径 $R_{min}$。[@problem_id:1437394]", "problem": "一家电信公司正在设计一种算法，以确定一座新广播塔的最佳位置和功率。该广播塔必须为 $n$ 个指定的服务点提供信号覆盖。这些服务点由二维平面上的一组点 $P = \\{p_1, p_2, \\dots, p_n\\}$ 表示，其中每个点 $p_i$ 的坐标为 $(x_i, y_i)$。\n\n为最小化运营成本，公司希望找到一个能够覆盖所有 $n$ 个服务点的单一圆形区域的最小可能广播半径 $R_{min}$。该圆的圆心可以是平面上的任意一点。\n\n工程团队为您提供了一个功能强大但运行成本高昂的模拟工具，该工具可以建模为一个“黑盒”预言机函数 `CAN_COVER(P, r)`。该函数以点集 $P$ 和半径 $r$ 作为输入。如果存在一个半径为 $r$ 的圆能够覆盖 $P$ 中的所有点，则函数返回 `true`，否则返回 `false`。对该预言机的每次调用都被视为一个计算步骤。\n\n对位置数据的初步分析确定了一个边界值 $C_{max}$，使得对于点集 $P$ 中的所有点 $(x_i, y_i)$，均满足 $|x_i| \\le C_{max}$ 和 $|y_i| \\le C_{max}$。\n\n您的任务是设计一个策略，使用 `CAN_COVER` 预言机来找到最小半径 $R_{min}$。具体而言，对于给定的精度 $\\epsilon > 0$，请确定需要调用 `CAN_COVER` 的最少次数，以保证找到的估计半径 $R_{est}$ 满足绝对误差不超过 $\\epsilon$，即 $|R_{est} - R_{min}| \\le \\epsilon$。\n\n请用 $C_{max}$ 和 $\\epsilon$ 将您的答案表示为一个闭式解析表达式。", "solution": "设 $R_{min}$ 为覆盖 $P$ 中所有点的圆的最小半径。预言机谓词 $f(r) := \\texttt{CAN\\_COVER}(P, r)$ 是单调的：当 $r < R_{min}$ 时，$f(r) = \\text{false}$；当 $r \\ge R_{min}$ 时，$f(r) = \\text{true}$。\n\n先验几何界：由于每个点 $p_{i}$ 都位于正方形 $\\{(x,y): |x| \\le C_{max}, |y| \\le C_{max}\\}$ 内，一个以原点为圆心、半径为 $C_{max}\\sqrt{2}$ 的圆可以覆盖整个正方形，因此\n$$\n0 \\le R_{min} \\le C_{max}\\sqrt{2}.\n$$\n因此，我们可以初始化一个搜索区间 $[L_{0}, U_{0}] = [0, C_{max}\\sqrt{2}]$，该区间保证包含 $R_{min}$，并且这一步无需任何预言机调用。\n\n对 $r \\in [L, U]$ 使用二分搜索：在每一步中，查询中点 $m = \\frac{L+U}{2}$。若 $f(m) = \\text{true}$，则 $R_{min} \\le m$，故设 $U \\leftarrow m$；否则 $R_{min} > m$，故设 $L \\leftarrow m$。通过归纳法，经过 $t$ 次预言机调用后，维护的区间 $[L_{t}, U_{t}]$ 包含 $R_{min}$，并且其长度满足\n$$\nU_{t} - L_{t} \\le \\frac{U_{0} - L_{0}}{2^{t}} = \\frac{C_{max}\\sqrt{2}}{2^{t}}.\n$$\n如果我们以中点 $R_{est} = \\frac{L_{t} + U_{t}}{2}$ 作为估计半径输出，那么最坏情况下的绝对误差最多是区间长度的一半：\n$$\n|R_{est} - R_{min}| \\le \\frac{U_{t} - L_{t}}{2} \\le \\frac{C_{max}\\sqrt{2}}{2^{t+1}}.\n$$\n为保证 $|R_{est} - R_{min}| \\le \\epsilon$，只需满足\n$$\n\\frac{C_{max}\\sqrt{2}}{2^{t+1}} \\le \\epsilon\n\\quad \\Longleftrightarrow \\quad\nt \\ge \\log_{2}\\!\\left(\\frac{C_{max}\\sqrt{2}}{2\\epsilon}\\right).\n$$\n由于调用次数必须是整数，在最坏情况下所需的预言机调用最小次数为\n$$\n\\left\\lceil \\log_{2}\\!\\left(\\frac{C_{max}\\sqrt{2}}{2\\epsilon}\\right) \\right\\rceil.\n$$\n此界为最优界：经过 $t$ 次二元预言机调用后，任何算法所能将 $R_{min}$ 约束到的区间的长度至少为 $\\frac{C_{max}\\sqrt{2}}{2^{t}}$，因此（通过选择中点）可以保证的最佳绝对误差至少为 $\\frac{C_{max}\\sqrt{2}}{2^{t+1}}$，这便导出了相同的必要条件。", "answer": "$$\\boxed{\\left\\lceil \\log_{2}\\!\\left(\\frac{C_{max}\\sqrt{2}}{2\\epsilon}\\right) \\right\\rceil}$$", "id": "1437394"}]}