{"hands_on_practices": [{"introduction": "我们从一个基础但至关重要的问题开始。许多算法的核心在于嵌套循环，而分析它们的性能是理解时间复杂度的第一步。这个练习 [@problem_id:1469548] 模拟了一个常见的编程任务：在两个列表中查找共同元素，它将帮助你掌握分析嵌套循环性能的方法，并理解当算法效率依赖于多个输入（大小为 $m$ 和 $n$）时，如何用大O表示法来刻画其最坏情况下的时间复杂度。", "problem": "一名程序员的任务是为一个电子商务平台开发一个功能。该功能需要识别出用户心愿单中的哪些商品目前正在特价销售。心愿单由一个包含独一无二整数商品ID的数组表示，我们称之为 `wishlist`，其大小为 $m$。特价销售的商品列表由第二个包含独一无二整数商品ID的数组 `saleItems` 表示，其大小为 $n$。\n\n为了找到共同的商品，该程序员实现了一个直接的算法。该算法遍历 `wishlist` 数组中的每一个商品ID。对于心愿单中的每一个商品ID，它会接着遍历 `saleItems` 数组中的每一个商品ID以检查是否匹配。\n\n该算法的最坏情况时间复杂度是多少，用大O表示法表示，并作为数组大小 $m$ 和 $n$ 的函数？\n\nA. $O(m + n)$\n\nB. $O(m \\log n + n \\log m)$\n\nC. $O(mn)$\n\nD. $O(\\max(m, n))$\n\nE. $O(\\min(m, n))$", "solution": "让外层循环遍历数组 $wishlist$ 的 $m$ 个元素，对于每个元素，内层循环扫描数组 $saleItems$ 的所有 $n$ 个元素以检查是否匹配。\n\n假设每次比较和循环开销都需要常数时间 $c>0$。那么，在最坏情况下（即没有提前终止，且每个内层循环都扫描所有 $n$ 个项目），常数时间操作的总数是\n$$\nT(m,n) = \\sum_{i=1}^{m} \\sum_{j=1}^{n} c = c \\sum_{i=1}^{m} \\left( \\sum_{j=1}^{n} 1 \\right) = c \\sum_{i=1}^{m} n = c m n.\n$$\n因此，在渐近意义上，\n$$\nT(m,n) \\in O(mn).\n$$\n在所描述的算法中，没有预处理或辅助数据结构能改变这个界限，而且ID的唯一性也不会减少每次外层迭代在最坏情况下的比较次数。\n\n因此，最坏情况下的时间复杂度是 $O(mn)$，对应于选项 C。", "answer": "$$\\boxed{C}$$", "id": "1469548"}, {"introduction": "接下来，我们将分析一个比简单嵌套循环更精巧的算法。这个练习 [@problem_id:1469569] 介绍了一种自定义的“跳跃扫描搜索”算法，它是对块搜索等思想的实用变体。要确定其最坏情况下的性能，你需要将其分解为不同的执行阶段，并仔细推理在何种输入下，比较次数会达到最大值。这个过程将锻炼你分析多阶段算法和理解参数（如步长 $k$）如何影响效率的能力。", "problem": "一位程序员正在设计一种名为“跳跃-扫描搜索”的自定义搜索算法，用于在一个包含`n`个不同元素的大型有序数组`A`中查找目标值`x`。该数组为0索引，即其元素为`A[0], A[1], ..., A[n-1]`。该算法的行为由一个整数步长`k`决定，其中`1 < k < n`。\n\n“跳跃-扫描搜索”算法按顺序分两个阶段运行：\n\n1.  **跳跃阶段：** 算法首先检查索引为`k-1`处的元素。如果该元素小于`x`，则“跳跃”到索引为`2k-1`处检查元素。此过程持续进行，算法会不断检查索引为`j \\cdot k - 1`（其中`j = 1, 2, 3, \\ldots`）处的元素，只要索引`j \\cdot k - 1`在数组边界内（即小于`n`）且元素`A[j \\cdot k - 1]`小于目标值`x`。\n\n2.  **扫描阶段：** 当在某个步骤`j`，元素`A[j \\cdot k - 1]`大于或等于`x`，或者索引`j \\cdot k - 1`不再小于`n`时，跳跃阶段终止。\n    *   如果跳跃阶段因`A[j \\cdot k - 1] \\ge x`而停止，算法将从索引`(j-1) \\cdot k`开始，线性扫描该元素块。\n    *   如果跳跃阶段因检查了直到索引`m \\cdot k - 1`（其中`(m+1) \\cdot k - 1 \\ge n`）的所有可能跳跃点，并且发现它们都小于`x`而停止，则算法将从索引`m \\cdot k`开始，线性扫描数组的最后一段。\n    线性扫描将持续进行，直到找到元素`x`或该块被完全扫描。为提高效率，任何在跳跃阶段已经检查过的元素不会在扫描阶段再次被检查。\n\n你的任务是确定在最坏情况下，该算法执行的最大可能比较次数。单次“比较”包括访问一个数组元素并将其值与`x`进行比较。请用`n`和`k`的闭式解析表达式表示你的答案。", "solution": "设数组长度为$n$，步长为$k$，且$1<k<n$。在跳跃阶段检查的跳跃点索引为\n$$\np_{j}=j k-1,\\quad j=1,2,\\ldots\n$$\n只要$p_{j}<n$。满足$p_{j}<n$的最大$j$也满足$j k\\le n$，因此总共可用的跳跃点数量为\n$$\nm=\\left\\lfloor \\frac{n}{k}\\right\\rfloor\n$$\n这些跳跃点位于索引$p_{1},\\ldots,p_{m}$处。\n\n计算每个阶段的比较次数：\n\n1) 跳跃阶段。如果跳跃阶段在第一个满足$A[p_{j}]\\ge x$的$j$处停止，则跳跃阶段的比较次数为$j$。如果在边界内从未找到这样的$j$（即所有$m$个跳跃点都满足$A[p_{j}]<x$），则跳跃阶段的比较次数为$m$。\n\n2) 扫描阶段。根据跳跃阶段的停止方式，存在两种情况。\n\na) 在某个$1\\le j\\le m$处因$A[p_{j}]\\ge x$而提前停止。此时，扫描阶段从索引$(j-1)k$线性扫描到$p_{j}-1=j k-2$，不再重复检查$p_{j}$。此次扫描的比较次数为块的长度\n$$\n\\bigl(j k-2\\bigr)-\\bigl((j-1)k\\bigr)+1=(k-1).\n$$\n因此，在$j$处停止的总比较次数为\n$$\nT_{1}(j)=j+(k-1).\n$$\n由于$T_{1}(j)$随$j$递增，此情况下的最坏情况在$j=m$时达到，得出\n$$\nT_{1,\\max}=m+(k-1).\n$$\n\nb) 越界（所有跳跃点都小于$x$）。此时，扫描阶段从索引$m k$开始，扫描至$n-1$，该段的长度为\n$$\nL=n-m k.\n$$\n总比较次数为\n$$\nT_{2}=m+L=m+(n-m k)=n-m(k-1).\n$$\n\n取两种情况下的最大值。比较\n$$\nT_{1,\\max}-T_{2}=\\bigl(m+(k-1)\\bigr)-\\bigl(n-m(k-1)\\bigr)=k(m+1)-1-n.\n$$\n使用$m=\\left\\lfloor \\frac{n}{k}\\right\\rfloor$，我们有$m k\\le n\\le (m+1)k-1$，因此$k(m+1)-1-n\\ge 0$。所以\n$$\nT_{1,\\max}\\ge T_{2},\n$$\n仅当$n=(m+1)k-1$时等号成立。\n\n因此，最坏情况下的最大可能比较次数是\n$$\nm+(k-1)=\\left\\lfloor \\frac{n}{k}\\right\\rfloor + (k-1).\n$$", "answer": "$$\\boxed{\\left\\lfloor \\frac{n}{k}\\right\\rfloor + k - 1}$$", "id": "1469569"}, {"introduction": "最后，我们转向递归算法的分析，这是计算机科学中的一个核心主题。这个练习 [@problem_id:1469561] 提出了一个为分层数据设计的递归算法，其特点是递归调用了两个大小不等的子问题，由此产生一个非标准的递推关系。解决这个问题将让你实践分析“分而治之”算法的强大工具，如主定理的推广或递归树方法，并学会如何在递归过程中识别占主导地位的成本部分，从而确定最终的时间复杂度。", "problem": "一个为一种特殊形式的层次化数据分析而设计的实验性算法，作用于一个大小为 $n$ 的输入数组。为简单起见，假设 $n$ 总是4的幂。该算法的流程递归定义如下：\n\n1.  如果输入大小 $n$ 为1，算法终止，耗时为常数时间。\n2.  如果 $n > 1$，算法首先对整个数组执行一次全局整合操作。该操作所需的时间与数组大小的平方成正比，由 $c n^2$ 给出，其中 $c$ 是某个正常数。\n3.  整合之后，算法对两个不同的、不重叠的子问题进行递归调用：\n    a. 第一个递归调用处理一个大小为 $n/2$ 的子数组。\n    b. 第二个递归调用处理一个大小为 $n/4$ 的不同子数组。\n\n总时间复杂度 $T(n)$ 是整合步骤的时间与两次递归调用的时间之和。\n\n下列哪项表示该算法最坏情况下时间复杂度 $T(n)$ 的最紧渐近上下界（大$\\Theta$表示法）？\n\nA. $\\Theta(n \\log n)$\n\nB. $\\Theta(n^{\\log_{2}(\\phi)})$，其中 $\\phi = \\frac{1+\\sqrt{5}}{2}$ 是黄金比例。\n\nC. $\\Theta(n^2)$\n\nD. $\\Theta(n^2 \\log n)$\n\nE. $\\Theta(n^3)$", "solution": "我们根据描述将递推关系形式化。令 $T(1)=\\Theta(1)$，且对于 $n>1$，\n$$\nT(n)=T\\!\\left(\\frac{n}{2}\\right)+T\\!\\left(\\frac{n}{4}\\right)+c n^{2},\n$$\n其中 $c>0$ 是一个常数。我们使用 Akra–Bazzi 定理来分析这个关系。将递推关系写成 $T(x)=\\sum_{i=1}^{k} a_{i} T(b_{i} x)+g(x)$ 的形式，其中 $a_{1}=1$，$a_{2}=1$，$b_{1}=\\frac{1}{2}$，$b_{2}=\\frac{1}{4}$，以及 $g(x)=c x^{2}$。从下式中求解 $p$：\n$$\n\\sum_{i=1}^{2} a_{i} b_{i}^{p}=1 \\quad \\Longleftrightarrow \\quad \\left(\\frac{1}{2}\\right)^{p}+\\left(\\frac{1}{4}\\right)^{p}=1.\n$$\n令 $y=2^{-p}$。则 $y+y^{2}=1$，即，\n$$\ny^{2}+y-1=0.\n$$\n正根是\n$$\ny=\\frac{-1+\\sqrt{1+4}}{2}=\\frac{-1+\\sqrt{5}}{2}=\\frac{1}{\\phi},\n$$\n其中 $\\phi=\\frac{1+\\sqrt{5}}{2}$ 是黄金比例。因此 $2^{-p}=\\frac{1}{\\phi}$，这意味着\n$$\np=\\log_{2}(\\phi).\n$$\n因为 $1<\\phi<2$，所以 $0<p<1$。\n\n根据 Akra–Bazzi 定理，\n$$\nT(x)=\\Theta\\!\\left(x^{p}\\left(1+\\int_{1}^{x} \\frac{g(u)}{u^{p+1}}\\,du\\right)\\right).\n$$\n当 $g(u)=c u^{2}$ 时，被积函数为\n$$\n\\frac{g(u)}{u^{p+1}}=c\\,u^{2-(p+1)}=c\\,u^{1-p}.\n$$\n因为 $1-p>0$，我们计算\n$$\n\\int_{1}^{x} c\\,u^{1-p}\\,du=c\\,\\left[\\frac{u^{2-p}}{2-p}\\right]_{1}^{x}=\\frac{c}{2-p}\\left(x^{2-p}-1\\right).\n$$\n因此，\n$$\nT(x)=\\Theta\\!\\left(x^{p}\\left(1+\\frac{c}{2-p}\\left(x^{2-p}-1\\right)\\right)\\right)=\\Theta\\!\\left(x^{p}\\cdot x^{2-p}\\right)=\\Theta\\!\\left(x^{2}\\right).\n$$\n用 $n$ 重写，我们得到 $T(n)=\\Theta(n^{2})$，这对应于选项C。", "answer": "$$\\boxed{C}$$", "id": "1469561"}]}