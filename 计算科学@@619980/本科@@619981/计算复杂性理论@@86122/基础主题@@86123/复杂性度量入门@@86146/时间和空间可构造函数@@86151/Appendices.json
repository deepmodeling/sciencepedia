{"hands_on_practices": [{"introduction": "本节的第一个实践旨在巩固您对空间可构造性形式化定义的理解。通过研究最简单的情况——常数函数，您将揭示计算空间度量方式中的一个关键细节，为解决更复杂的问题奠定坚实的基础。[@problem_id:1466676]", "problem": "在计算复杂性理论中，我们分析算法所需的资源，例如时间和空间。如果一个函数所描述的资源可以由图灵机（TM）自身来追踪，那么该函数就被认为是“良性的”或“可构造的”。\n\n形式上，如果存在一个多带图灵机，在给定任意长度为 $n$ 的输入串时，该图灵机停机并恰好在其工作带上使用 $s(n)$ 个单元格，那么函数 $s: \\mathbb{N} \\to \\mathbb{N}$ 就被称为**空间可构造的**。使用的空间定义为工作带读写头访问过的不同单元格的数量。\n\n考虑以下关于常数函数的两个陈述：\n\n**陈述 I：** 函数 $f(n) = k$ 是空间可构造的，其中 $k$ 是一个固定的正整数（$k \\ge 1$）。\n**陈述 II：** 函数 $g(n) = 0$ 是空间可构造的。\n\n以下哪个选项正确地评估了这两个陈述的真伪？\n\nA. 陈述 I 为真，陈述 II 为假。\nB. 陈述 I 为假，陈述 II 为真。\nC. 陈述 I 和陈述 II 均为真。\nD. 陈述 I 和陈述 II 均为假。", "solution": "我们采用标准的空间复杂度模型：一个确定性的多带图灵机有一个只读输入带和至少一个读写工作带；该机器启动时，每个工作带的读写头都位于一个指定的起始单元格上。对于长度为 $n$ 的输入，所使用的空间是在计算过程中扫描过的工作带上不同单元格的数量。根据此定义，扫描起始单元格即算作访问了它。\n\n陈述 I 的分析：设 $k \\in \\mathbb{N}$ 且 $k \\ge 1$，并对所有 $n \\in \\mathbb{N}$ 定义 $f(n)=k$。我们构造一个多带图灵机 $M_{k}$，它在处理任何长度为 $n$ 的输入时，恰好使用 $k$ 个工作带单元格并停机。构造方法如下：\n1. 如果 $k=1$，$M_{1}$ 会立即停机，而不移动其工作带读写头。由于读写头从一个指定的起始单元格开始，因此恰好访问了一个唯一的工作带单元格。因此，使用的空间为 $1=f(n)$。\n2. 如果 $k>1$，$M_{k}$ 执行以下操作：从工作带读写头的初始位置（访问第一个单元格）开始，它将读写头移动到一个新的、之前未访问过的单元格 $k-1$ 次（例如，在空白带上向右移动 $k-1$ 步），然后停机。访问过的不同工作带单元格集合的基数恰好为 $k$，与输入长度 $n$ 无关。因此，对于任意长度为 $n$ 的输入，$M_{k}$ 恰好使用 $f(n)=k$ 个单元格。\n\n因此，当 $k \\ge 1$ 时，$f(n)=k$ 是空间可构造的，所以陈述 I 为真。\n\n陈述 II 的分析：设对所有 $n \\in \\mathbb{N}$ 有 $g(n)=0$。我们用反证法。假设存在一个多带图灵机 $M$，对于任何长度为 $n$ 的输入，它会停机并恰好使用 $g(n)=0$ 个工作带单元格。令 $V$ 表示在一次计算中访问过的不同工作带单元格的集合。根据模型的初始配置，在时刻零，工作带读写头正在扫描其起始单元格，这算作一次访问；因此立即有 $|V| \\ge 1$。由于只要工作带存在，读写头就无法避免扫描那个起始单元格，所以在任何停机的计算中，访问过的工作带单元格总数至少为 $1$，这与 $|V|=0$ 的要求相矛盾。因此，不存在这样的图灵机 $M$，函数 $g(n)=0$ 不是空间可构造的。因此陈述 II 为假。\n\n综合两者，陈述 I 为真，陈述 II 为假，这对应于选项A。", "answer": "$$\\boxed{A}$$", "id": "1466676"}, {"introduction": "最后的这个实践介绍了一种证明时间可构造性的常用替代方法，尤其适用于增长非常迅速的函数。您将分析函数 $f(n) = 2^{n-1}$，并理解其可构造性并非取决于其巨大的数值，而是取决于其紧凑的二进制表示形式能够被多么高效地计算出来。[@problem_id:1466715]", "problem": "在计算复杂性理论领域，一个关键概念是资源限制函数的“可构造性”（constructibility）。这个性质对于证明许多层次定理至关重要，这些定理表明拥有更多资源的机器可以解决更多问题。\n\n一位计算机科学家正在分析一个计算过程，其运行时间 $f(n)$ 作为输入参数 $n \\ge 1$ 的函数，由以下递推关系描述：\n$$f(n) = 2f(n-1)$$\n其基本情况为 $f(1) = 1$。\n\n为了继续分析，该科学家必须确定 $f(n)$ 是否是一个时间可构造函数。一个函数 $f: \\mathbb{N} \\to \\mathbb{N}$ 被定义为**时间可构造的**（time-constructible），如果存在一个图灵机，当给定一个由 $n$ 个1组成的输入字符串（表示为 $1^n$）时，它会精确地运行 $f(n)$ 步，然后停机。\n\n根据这个定义，下列哪个陈述是正确的？\n\nA. 是的，该函数是时间可构造的，因为可以证明对于 $n \\ge 1$，$f(n) = n!$，而 $n!$ 是一个已知的时间可构造函数。\nB. 是的，该函数是时间可构造的，因为存在一个算法可以在 $O(n^2)$ 步内计算出其值，并且 $n^2$ 渐进小于 $f(n)$。\nC. 不，该函数不是时间可构造的，因为它呈指数级增长，而计算一个指数级的值所需的步数比该值本身增长得更快。\nD. 不，该函数不是时间可构造的，因为任何增长速度快于 $n$ 的多项式的函数都不可能是时间可构造的。", "solution": "我们通过重复代入来求解该递推关系。给定 $f(1)=1$ 以及对于 $n \\ge 2$ 有 $f(n)=2 f(n-1)$，我们得到：\n$$\nf(2)=2 f(1)=2,\\quad f(3)=2 f(2)=4,\\quad \\dots\n$$\n一般地，\n$$\nf(n)=2^{n-1} f(1)=2^{n-1}.\n$$\n\n根据定义，我们需要证明存在一台图灵机，在输入为 $1^n$ 时，能精确运行 $f(n) = 2^{n-1}$ 步。这可以通过一个标准构造来实现：如果一个函数 $s(n)$ 是空间可构造的，那么时间函数 $t(n) = 2^{O(s(n))}$ 是时间可构造的。\n\n首先，我们证明 $s(n)=n-1$ 是空间可构造的。一台图灵机可以在其工作带上从起始单元格开始向右移动 $n-2$ 步，从而精确地访问 $n-1$ 个单元格。这个过程可以在 $O(n)$ 时间内完成。\n\n既然 $s(n)=n-1$ 是空间可构造的，那么 $t(n)=2^{n-1}$ 就是时间可构造的（这里我们利用了可以将 $2^{O(s(n))}$ 的构造精炼为恰好 $2^{s(n)}$ 步的标准结果）。因此，该函数是时间可构造的。\n\n现在评估各个选项：\n- A 是错误的，因为解是 $f(n)=2^{n-1}$，而不是 $n!$。\n- B 陈述该函数是时间可构造的，这是正确的。其给出的理由——“因为存在一个算法可以在 $O(n^2)$ 步内计算出其值...”——描述的是该函数是“完全时间可构造的”。对于像 $f(n)=2^{n-1}$ 这样增长足够快的函数，完全时间可构造性等价于标准的时间可构造性。因此，该选项的结论正确，其理由也是一个有效的、 وإن كان غير مباشر的证明路径。\n- C 是错误的。指数级增长并不排除时间可构造性。\n- D 是错误的。许多超多项式函数，包括 $2^{n}$ 和本题中的 $2^{n-1}$，都是时间可构造的。\n\n因此，正确选项是 B。", "answer": "$$\\boxed{B}$$", "id": "1466715"}]}