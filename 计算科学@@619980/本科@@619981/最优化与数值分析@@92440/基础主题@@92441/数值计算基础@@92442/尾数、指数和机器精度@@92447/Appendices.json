{"hands_on_practices": [{"introduction": "这项练习将引导您为一个简化的、假设的浮点系统从头开始计算机器精度（machine epsilon）。通过在一个可控的环境中实践基本定义，您将建立一个坚实的直觉，理解机器精度如何与尾数的比特数内在关联。在接触更复杂的真实世界标准之前，这种基础性理解至关重要。[@problem_id:2204331]", "problem": "考虑一个为低功耗嵌入式控制器设计的假设性8位浮点数系统。在此系统中，每个数字使用1位表示符号（$S$），4位表示偏置指数（$E$），以及3位表示尾数的小数部分（$M$）。\n\n一个数的值由以下公式给出：\n$$V = (-1)^S \\times (1.M)_2 \\times 2^{E - \\text{bias}}$$\n\n尾数是规格化的，意味着其形式为 $(1.M)_2$，表示二进制数 $1$ 后面跟着3位小数 $M$。指数偏置量定义为 $\\text{bias} = 2^{k-1} - 1$，其中 $k$ 是指数域中的位数。\n\n在任何浮点系统中，都存在一个关于精度的基本限制，称为机器精度（machine epsilon, $\\epsilon_m$）。它被定义为这样一个最小的正数：当它与1相加时，在该系统的表示法中产生一个大于1的值。\n\n计算这个8位浮点系统的机器精度 $\\epsilon_m$ 的值。请将您的答案表示为单个十进制实数。", "solution": "我们有一个8位浮点格式，包含1个符号位、4个指数位和3个尾数小数位。其值由下式给出：\n$$\nV = (-1)^{S} \\times (1.M)_{2} \\times 2^{E - \\text{bias}},\n$$\n尾数是规格化的，且对于 $k$ 个指数位，偏置量由 $\\text{bias} = 2^{k-1} - 1$ 定义。\n\n首先计算 $k=4$ 时的偏置量：\n$$\n\\text{bias} = 2^{4-1} - 1 = 2^{3} - 1 = 7.\n$$\n数字 $1$ 通过选择 $S=0$，$E=\\text{bias}$ 和 $M=000$ 来表示，得到\n$$\nV_{1} = (1.000)_{2} \\times 2^{7-7} = 1 \\times 2^{0} = 1.\n$$\n在相同指数下，大于1的下一个可表示的数具有最小的正尾数增量，即 $M=001$。其值为\n$$\nV_{\\text{next}} = (1.001)_{2} \\times 2^{7-7} = \\left(1 + 2^{-3}\\right) \\times 2^{0} = 1 + 2^{-3}.\n$$\n根据机器精度 $\\epsilon_{m}$ 的定义，即在该系统中使 $1 + \\epsilon_{m} > 1$ 成立的最小正数，我们有\n$$\n\\epsilon_{m} = V_{\\text{next}} - V_{1} = \\left(1 + 2^{-3}\\right) - 1 = 2^{-3} = \\frac{1}{8} = 0.125.\n$$\n等价地，由于精度为 $p=1+3=4$ 个有效位（包括隐含的前导 $1$），通用公式 $\\epsilon_{m} = 2^{1-p}$ 得出\n$$\n\\epsilon_{m} = 2^{1-4} = 2^{-3} = 0.125,\n$$\n这与直接构造的结果一致。", "answer": "$$\\boxed{0.125}$$", "id": "2204331"}, {"introduction": "在建立了对机器精度的理论理解之后，这个实践将从理论转向实际应用。您将编写一个程序，以经验方式测量大多数现代计算机中使用的标准单精度和双精度浮点数的机器精度。这项练习不仅验证了理论公式，还展示了一种探测您的计算环境极限的实用方法。[@problem_id:2395229]", "problem": "编写一个完整的程序，以经验方式确定单精度和双精度二进制浮点数的机器精度 (machine epsilon)，并根据电气和电子工程师协会 (IEEE) 754 标准的理论预期值验证结果。在此背景下，将机器精度定义为满足在给定精度下 $1 + \\epsilon$ 可表示且严格大于 $1$ 的最小正数 $\\epsilon$。仅使用确定性计算；不读取任何输入。\n\n背景和基础：在 IEEE 754 标准中，浮点数以基数 $b = 2$ 表示。任何规格化数都可以写成 $x = m \\times b^{e}$ 的形式，其中尾数 $m$ 满足 $1 \\le m < 2$，而 $e$ 是一个整数阶码。对于规格化数，相邻可表示值之间的间隔仅取决于基数 $b$ 和尾数位数 $p$。单精度的 $p = 24$，双精度的 $p = 53$。所有舍入操作均遵循“向最近的偶数舍入”原则。\n\n您的程序必须执行的任务：\n- 为给定的二进制浮点类型实现一个纯粹的经验性过程，通过迭代减半来估算机器精度。在该类型中，从 $\\epsilon = 1$ 开始，并重复将其减半，直到将其加到 $1$ 上不再改变该类型中的值为止。返回最后一个确实改变了值的 $\\epsilon$。对于单精度（$32$位）和双精度（$64$位），此操作必须分别执行。\n- 仅使用上述基本事实，根据 $b$ 和 $p$ 计算每种精度下 $1$ 与下一个更大的可表示数之间的理论间隔。\n- 对于每种精度，计算经验值 $\\epsilon_{\\mathrm{emp}}$ 与理论间隔 $\\epsilon_{\\mathrm{theory}}$ 之间的相对误差，公式为 $\\left|\\epsilon_{\\mathrm{emp}} - \\epsilon_{\\mathrm{theory}}\\right| / \\epsilon_{\\mathrm{theory}}$。\n- 对于每种精度，验证边界属性，即在该精度下计算时，$1 + \\epsilon_{\\mathrm{emp}} > 1$ 而 $1 + \\epsilon_{\\mathrm{emp}}/2 = 1$，并将结果报告为布尔值。\n\n测试套件和参数：\n- 使用以下类型-参数对：\n  - 单精度（$32$位），$p = 24$。\n  - 双精度（$64$位），$p = 53$。\n这两种情况共同构成了测试套件，您的程序必须同时处理它们。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表包含以下六个条目，并严格按照此顺序排列：\n  - $[\\epsilon_{\\mathrm{single}}, \\epsilon_{\\mathrm{double}}, r_{\\mathrm{single}}, r_{\\mathrm{double}}, \\mathrm{ok}_{\\mathrm{single}}, \\mathrm{ok}_{\\mathrm{double}}]$,\n其中 $\\epsilon_{\\mathrm{single}}$ 和 $\\epsilon_{\\mathrm{double}}$ 分别是单精度和双精度的经验值，$r_{\\mathrm{single}}$ 和 $r_{\\mathrm{double}}$ 是相应的相对误差（非负实数），$\\mathrm{ok}_{\\mathrm{single}}$ 和 $\\mathrm{ok}_{\\mathrm{double}}$ 是用于边界属性的布尔值。数字必须以标准十进制数形式打印。例如，输出必须类似于 $[x_1,x_2,x_3,x_4,True,True]$，并用实际计算出的值替换。\n\n角度单位和物理单位不适用于此问题。所有数值必须报告为无单位的实数或布尔值。程序必须是自包含的，并且不得要求任何输入。在符合 IEEE 754 标准算术的实现中，结果必须是可复现的。", "solution": "该问题要求根据电气和电子工程师协会 (IEEE) 754 标准的规定，对单精度和双精度浮点数的机器精度进行经验性和理论性的确定。对问题陈述的验证证实了其科学性、一致性和完整性。因此，我们可以进行正式的求解。\n\n解决方案基于二进制浮点表示的原理。根据 IEEE 754 标准，一个规格化浮点数 $x$ 以基数 $b=2$ 表示为：\n$$x = (-1)^s \\times m \\times 2^e$$\n其中 $s$ 是符号位，$e$ 是阶码，$m$ 是尾数（或有效数）。尾数被规格化到范围 $1 \\le m < 2$ 内，并以 $m = 1.f$ 的形式存储，其中前导位 $1$ 是隐含的，$f$ 是显式存储的小数部分。尾数的总精度位数为 $p$。这包括隐含的前导位。因此，小数部分 $f$ 由 $p-1$ 位表示。\n\n对于单精度数，参数为 $p=24$。对于双精度数，参数为 $p=53$。\n\n**理论机器精度**\n\n问题要求我们计算数字 $1$ 与下一个更大的可表示数之间的理论间隔。数字 $1$ 在二进制浮点算术中是精确可表示的。其规格化表示为：\n$$1.0 = (1.000...0)_2 \\times 2^0$$\n这里，阶码为 $e=0$，尾数为 $m=1$。$p-1$ 个小数位全为零。\n\n要找到比 $1$ 大的下一个可表示浮点数，我们必须做出最小可能的改变。这可以通过增加尾数小数部分的最低有效位 (LSB) 来实现。LSB 对应的值为 $2^{-(p-1)}$。因此，下一个数的尾数是：\n$$m' = (1.000...01)_2 = 1 + 2^{-(p-1)}$$\n下一个可表示数 $x_{\\text{next}}$ 因此是：\n$$x_{\\text{next}} = (1 + 2^{-(p-1)}) \\times 2^0 = 1 + 2^{-(p-1)}$$\n理论间隔，我们称之为 $\\epsilon_{\\mathrm{theory}}$，是 $x_{\\text{next}}$ 与 $1$ 之间的差：\n$$\\epsilon_{\\mathrm{theory}} = x_{\\text{next}} - 1 = (1 + 2^{-(p-1)}) - 1 = 2^{-(p-1)}$$\n\n使用给定的参数：\n- 对于单精度 ($p=24$):\n  $$\\epsilon_{\\mathrm{theory, single}} = 2^{-(24-1)} = 2^{-23}$$\n- 对于双精度 ($p=53$):\n  $$\\epsilon_{\\mathrm{theory, double}} = 2^{-(53-1)} = 2^{-52}$$\n\n**经验估算过程**\n\n问题指定了一个迭代算法来经验性地找到机器精度。我们从 $\\epsilon = 1$ 开始，并重复将其除以 $2$，直到满足条件 $(1 + \\epsilon)_{FP} = 1$ 为止，其中下标 $FP$ 表示浮点运算。算法将返回使 $(1 + \\epsilon)_{FP} > 1$ 的最后一个 $\\epsilon$ 值。\n\n让我们分析这个过程。我们测试的是 $\\epsilon_k = 2^{-k}$ 这样的值，其中 $k=0, 1, 2, \\dots$。操作是 $1$ 和 $\\epsilon_k$ 的浮点加法。精确的数学和是 $1 + 2^{-k}$。为了执行加法，操作数的阶码必须对齐。数字 $1$ 是 $1.0 \\times 2^0$，$\\epsilon_k$ 是 $1.0 \\times 2^{-k}$。通过右移较小数的尾数来执行求和：\n$$1.0 \\times 2^0 + 1.0 \\times 2^{-k} = (1.00...0_2 + 0.00...1_2) \\times 2^0$$\n其中第二项中的 $1$ 在二进制小数点后的第 $k$ 个位置。结果的尾数有 $p-1$ 个小数位用于存储。\n\n- 如果 $k < p-1$，位置 $k$ 的位在尾数的可表示部分内。和 $1+2^{-k}$ 是精确可表示的，结果大于 $1$。\n- 如果 $k = p-1$，和是 $1+2^{-(p-1)}$。这是紧随 $1$ 之后的下一个可表示数，如前所述。所以，$(1+2^{-(p-1)})_{FP} = 1+2^{-(p-1)} > 1$。\n- 如果 $k=p$，数学和是 $1+2^{-p}$。这个值恰好位于两个连续的可表示数 $N_1=1$ 和 $N_2=1+2^{-(p-1)}$ 的正中间。\n  $$1+2^{-p} = 1 + \\frac{1}{2}(2^{-(p-1)}) = \\frac{N_1 + N_2}{2}$$\n  IEEE 754 标准规定了“向最近的偶数舍入”。我们必须向其尾数最低有效位为 $0$ 的邻近值舍入。\n  $N_1=1$ 的尾数是 $(1.00...0)_2$。其 LSB 是 $0$。\n  $N_2=1+2^{-(p-1)}$ 的尾数是 $(1.00...1)_2$。其 LSB 是 $1$。\n  因此，这种平局情况向下舍入到 $N_1=1$。所以，$(1+2^{-p})_{FP} = 1$。\n- 如果 $k > p$，和 $1+2^{-k}$ 更接近于 $1$ 而不是 $1+2^{-(p-1)}$，所以它也舍入到 $1$。\n\n问题中指定的迭代过程，“重复将其减半，直到将其加到 $1$ 上不再改变该类型中的值为止……返回最后一个确实改变了值的 $\\epsilon$”，将在测试 $\\epsilon_k = 2^{-p}$ 时停止。此时，$(1+\\epsilon_k)_{FP} = 1$。算法返回前一个 epsilon 的值，即 $\\epsilon_{p-1}=2^{-(p-1)}$。因此，经验确定的 epsilon 是：\n$$\\epsilon_{\\mathrm{emp}} = 2^{-(p-1)}$$\n\n**验证和误差计算**\n\n根据以上推导，我们有 $\\epsilon_{\\mathrm{emp}} = \\epsilon_{\\mathrm{theory}} = 2^{-(p-1)}$。\n因此，相对误差为：\n$$r = \\frac{|\\epsilon_{\\mathrm{emp}} - \\epsilon_{\\mathrm{theory}}|}{\\epsilon_{\\mathrm{theory}}} = \\frac{|2^{-(p-1)} - 2^{-(p-1)}|}{2^{-(p-1)}} = 0$$\n这对单精度和双精度都必须成立。\n\n边界属性验证需要检查两个条件：\n$1$. $(1 + \\epsilon_{\\mathrm{emp}})_{FP} > 1$:\n    这是 $(1 + 2^{-(p-1)})_{FP} > 1$。由于 $1+2^{-(p-1)}$ 是精确可表示的，并且是紧随 $1$ 之后的下一个值，所以这是真的。\n$2$. $(1 + \\epsilon_{\\mathrm{emp}}/2)_{FP} = 1$:\n    这是 $(1 + 2^{-(p-1)}/2)_{FP} = (1 + 2^{-p})_{FP}$。如舍入规则分析所示，此表达式计算结果为 $1$。这也是真的。\n\n因此，边界属性的布尔检查应都返回真。\n\n**实现策略**\n\n解决方案将使用 Python 中的 `numpy` 库来实现，以访问 `np.float32`（单精度）和 `np.float64`（双精度）类型。一个函数将通过实现迭代减半循环来为给定的浮点类型执行经验计算。主程序将对 `np.float32` 和 `np.float64` 类型都执行此操作。理论值、相对误差和边界属性布尔值将按推导的方式计算。所有六个所需的值（$\\epsilon_{\\mathrm{single}}$, $\\epsilon_{\\mathrm{double}}$, $r_{\\mathrm{single}}$, $r_{\\mathrm{double}}$, $\\mathrm{ok}_{\\mathrm{single}}$, $\\mathrm{ok}_{\\mathrm{double}}$）将被收集并以指定格式打印。计算必须确保中间浮点类型得到正确处理，例如在执行单精度测试时使用 `np.float32(1)`。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Empirically determines and theoretically validates machine epsilon for single\n    and double precision floating-point numbers as per IEEE 754.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (numpy_type, significand_bits_p, name)\n    test_cases = [\n        (np.float32, 24, \"single\"),\n        (np.float64, 53, \"double\"),\n    ]\n\n    results_dict = {}\n\n    for precision_type, p, name in test_cases:\n        # Task 1: Empirically determine machine epsilon.\n        # The specified procedure is to start with epsilon = 1 and repeatedly\n        # halve it. The last epsilon for which 1 + epsilon > 1 is the result.\n        # A more direct loop finds the smallest representable power of 2, epsilon,\n        # such that 1 + epsilon/2 == 1, which confirms that epsilon is the smallest\n        # representable number that makes a difference when added to 1.\n        one = precision_type(1)\n        two = precision_type(2)\n        epsilon = precision_type(1)\n        \n        while one + (epsilon / two) != one:\n            epsilon = epsilon / two\n        \n        epsilon_emp = epsilon\n        \n        # Task 2: Compute the theoretical spacing.\n        # As derived from IEEE 754 principles, the theoretical spacing between 1\n        # and the next representable number is 2^-(p-1).\n        # We use Python's native float (double precision) for this calculation\n        # to ensure high accuracy for the reference value.\n        epsilon_theory = 2.0**(-(p - 1))\n\n        # Task 3: Compute the relative error.\n        # The empirical value should be identical to the theoretical one.\n        # The relative error is computed with high-precision values.\n        relative_error = np.abs(float(epsilon_emp) - epsilon_theory) / epsilon_theory\n        \n        # Task 4: Verify the boundary property.\n        # This confirms our understanding of the epsilon value. We must check that\n        # 1 + epsilon_emp > 1 but 1 + epsilon_emp/2 = 1, all in the target precision.\n        boundary_ok = (one + epsilon_emp > one) and \\\n                      (one + epsilon_emp / two == one)\n\n        # Store results for this precision.\n        results_dict[name] = {\n            \"epsilon_emp\": epsilon_emp,\n            \"relative_error\": relative_error,\n            \"boundary_ok\": boundary_ok\n        }\n\n    # Assemble the final list of results in the specified order.\n    # [eps_single, eps_double, r_single, r_double, ok_single, ok_double]\n    final_results = [\n        results_dict[\"single\"][\"epsilon_emp\"],\n        results_dict[\"double\"][\"epsilon_emp\"],\n        results_dict[\"single\"][\"relative_error\"],\n        results_dict[\"double\"][\"relative_error\"],\n        results_dict[\"single\"][\"boundary_ok\"],\n        results_dict[\"double\"][\"boundary_ok\"]\n    ]\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) function correctly converts floats and booleans to their\n    # standard string representations (e.g., \"True\", \"False\").\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "2395229"}, {"introduction": "既然我们已经定义并测量了机器精度，让我们来探讨它的直接后果。这个问题研究了当一个看似简单的计算涉及到一个仅比 $1.0$ 大一点的数时会发生什么。它揭示了由机器精度决定的、可表示数字之间的离散“间隙”如何对数值结果产生切实且可预测的影响，从而突显了理解浮点数算术精细结构的重要性。[@problem_id:2215598]", "problem": "在现代计算中，实数通常使用浮点表示法来近似。考虑无处不在的电气和电子工程师协会（IEEE）754单精度格式。在此格式中，一个规格化数的值 $V$ 由 $V = (-1)^s \\times 2^{E-127} \\times (1.M)_2$ 给出，其中 $s$ 是一个单独的符号位，$E$ 是一个8位的指数（偏置为127），而 $M$ 是尾数的23位小数部分。项 $(1.M)_2$ 表示一个二进制数，其小数部分由位串 $M$ 给出。\n\n现在，考虑数学函数 $f(x) = \\sqrt{x-1}$。我们希望在一台计算机上计算这个函数，其中变量 $x$ 以单精度格式存储。由于这种表示法的有限性，数字不是连续的。存在一个可表示的、严格大于 1.0 的最小单精度数。我们称这个数为 $x_{\\text{next}}$。\n\n如果我们使用浮点运算来计算表达式 $y = x_{\\text{next}} - 1.0$，我们将得到该表达式可以产生的最小可能正值。你的任务是确定 $\\sqrt{y}$ 的精确数学值。你应该计算这个值 $y$ 的真实数学平方根，而不是计算结果的后续浮点表示。\n\n将你的最终答案表示为 $C \\times 2^k$ 形式的解析表达式，其中 $k$ 是一个整数，$C$ 是一个数值常数。你的常数 $C$ 可能包含无理根式（例如 $\\sqrt{3}$）。", "solution": "我们首先刻画严格大于 $1.0$ 的下一个可表示的 IEEE 754 单精度数。一个规格化的单精度数具有形式 $V = (-1)^{s} \\times 2^{E-127} \\times (1.M)_{2}$。在 $1.0$ 附近，我们有 $s=0$ 和 $E=127$，所以 $2^{E-127} = 2^{0} = 1$，并且在 $\\left[1,2\\right)$ 范围内的值具有形式\n$$\nV = (1.M)_{2} = 1 + \\sum_{i=1}^{23} b_{i} 2^{-i},\n$$\n其中 $M = b_{1} b_{2} \\dots b_{23}$ 是23位的小数部分。大于 $1.0$ 的最小正增量出现在 $b_{1} = b_{2} = \\dots = b_{22} = 0$ 且 $b_{23} = 1$ 时，给出的小数值为 $2^{-23}$。因此，严格大于 $1.0$ 的最小可表示数为\n$$\nx_{\\text{next}} = 1 + 2^{-23}.\n$$\n\n接下来我们使用浮点运算计算 $y = x_{\\text{next}} - 1.0$。精确的实数差值为\n$$\ny_{\\text{exact}} = (1 + 2^{-23}) - 1 = 2^{-23}.\n$$\n数字 $2^{-23}$ 作为一个指数 $E = 127 - 23 = 104$ 且尾数 $M = 0$ 的规格化数，可以在单精度中精确表示，所以浮点减法在没有舍入误差的情况下精确地得出 $y = 2^{-23}$。\n\n所要求的量是 $\\sqrt{y}$ 的精确数学值：\n$$\n\\sqrt{y} = \\sqrt{2^{-23}} = 2^{-23/2} = 2^{-12} \\sqrt{2}.\n$$\n这符合 $C \\times 2^{k}$ 的形式，其中 $C = \\sqrt{2}$ 且 $k = -12$。", "answer": "$$\\boxed{\\sqrt{2}\\times 2^{-12}}$$", "id": "2215598"}]}