{"hands_on_practices": [{"introduction": "为了真正理解灾难性抵消，没有什么比亲手模拟计算机的算术过程更有效了。这个练习 [@problem_id:2158313] 将引导您在一个假设的、仅有4位有效数字精度的计算环境中，逐步计算一个函数的数值。通过这个过程，您将直观地看到当两个几乎相等的数相减时，有效信息是如何丢失的，从而深刻理解灾难性抵消的根源。", "problem": "一种简化的计算机体系结构使用一个保持4位有效数字精度的浮点标准来表示所有实数并执行算术运算。在每次基本算术运算（加法、减法、乘法、除法）之后，结果会立即四舍五入到4位有效数字。\n\n考虑对 $x = 1.234 \\times 10^{-3}$ 这个值计算函数 $f(x) = \\frac{\\exp(x) - 1}{x}$。\n\n首先，使用“直接方法”计算 $f(x)$ 的一个近似值。这包括计算 $\\exp(x)$ 的值，减去1，然后将结果除以 $x$。为此计算，给定高精度值 $\\exp(1.234 \\times 10^{-3}) = 1.00123476...$ 设在该计算机的4位有效数字算术下，此直接计算的结果为 $V_D$。\n\n其次，为了建立一个更准确的基准，使用一种“稳定方法”。稳定值 $V_S$ 通过用 $f(x)$ 在 $x=0$ 附近的泰勒级数展开式的前两个非零项来近似定义。你应该使用完全精度计算该值。\n\n计算直接方法相对于稳定方法的相对误差，其定义为 $\\left| \\frac{V_D - V_S}{V_S} \\right|$。\n\n将你的最终答案表示为四舍五入到三位有效数字的小数。", "solution": "该机器用4位有效数字表示所有实数。因此，任何存储的中间结果在每次基本算术运算后立即四舍五入到4位有效数字，并且任何存储的常数（例如计算 $\\exp(x)$ 的输出）都用4位有效数字表示。\n\n直接方法：\n- 输入 $x$ 表示为 $x=1.234 \\times 10^{-3}$（已经是4位有效数字）。\n- 给定 $\\exp(1.234 \\times 10^{-3}) \\approx 1.00123476$，机器将其存储为 $1.001$（4位有效数字）。\n- 减法（四舍五入到4位有效数字）：\n$$1.001 - 1.000 = 0.001 \\quad \\Rightarrow \\quad 0.001000 = 1.000 \\times 10^{-3}.$$\n- 除法（四舍五入到4位有效数字）：\n$$V_{D} = \\frac{1.000 \\times 10^{-3}}{1.234 \\times 10^{-3}} = \\frac{1.000}{1.234} \\approx 0.810372\\ \\Rightarrow\\ 0.8104.$$\n\n稳定方法：\n使用泰勒级数 $\\exp(x) = 1 + x + \\frac{x^{2}}{2!} + \\cdots$，我们得到\n$$f(x) = \\frac{\\exp(x) - 1}{x} = 1 + \\frac{x}{2} + \\frac{x^{2}}{6} + \\cdots.$$\n保留前两个非零项并以完全精度计算，\n$$V_{S} = 1 + \\frac{x}{2} = 1 + \\frac{1.234 \\times 10^{-3}}{2} = 1 + 0.617 \\times 10^{-3} = 1.000617.$$\n\n相对误差：\n$$\\left|\\frac{V_{D} - V_{S}}{V_{S}}\\right| = \\left|\\frac{0.8104 - 1.000617}{1.000617}\\right| = \\frac{0.190217}{1.000617} \\approx 0.190.$$\n四舍五入到三位有效数字，相对误差为 $0.190$。", "answer": "$$\\boxed{0.190}$$", "id": "2158313"}, {"introduction": "识别数值不稳定性是第一步，而关键的下一步是修复它。这个练习 [@problem_id:2375840] 挑战您运用代数技巧，将一个在特定条件下会产生灾难性抵消的表达式，例如计算大数值 $x$ 的 $\\sqrt{x^2+1} - x$，转化为一个数学上等价但数值上稳定的形式。掌握这种代数重构方法对于编写可靠的科学计算代码至关重要。", "problem": "设实数 $x > 0$ 上的函数 $f(x) = \\sqrt{x^{2}+1} - x$。在单位舍入误差为 $u$ 的标准浮点运算模型中，当 $x$ 非常大时，直接计算 $f(x)$ 会遭遇灾难性抵消。请从基本原理出发，推导一个与 $f(x)$ 代数等价且数值稳定的闭式表达式，以避免在 $x$ 非常大时减去近似相等的量。请将最终答案表示为仅含 $x$ 的单个解析表达式。无需进行舍入。", "solution": "对问题陈述进行验证。\n\n提取已知条件如下：\n1.  函数定义为 $f(x) = \\sqrt{x^{2}+1} - x$。\n2.  函数的定义域指定为实数 $x > 0$。\n3.  计算环境为单位舍入误差是 $u$ 的标准浮点运算模型。\n4.  所述的数值问题是，当 $x$ 非常大时，直接计算 $f(x)$ 会遭遇灾难性抵消。\n5.  目标是为 $f(x)$ 推导一个能避免此问题的、代数等价且数值稳定的闭式表达式。最终答案必须是仅含 $x$ 的单个解析表达式。\n\n问题陈述的验证：\n-   **科学依据**：该问题具有科学合理性。两个近似相等的浮点数相减时出现的灾难性抵消现象，是数值分析和计算科学中的一个基本课题。函数 $f(x) = \\sqrt{x^{2}+1} - x$ 是用于说明此效应的典型例子。对于大的正数 $x$，$\\sqrt{x^{2}+1}$ 项可以通过 Taylor 级数展开进行近似：$\\sqrt{x^{2}+1} = x\\sqrt{1 + \\frac{1}{x^{2}}} \\approx x(1 + \\frac{1}{2x^{2}}) = x + \\frac{1}{2x}$。因此，$f(x) \\approx (x + \\frac{1}{2x}) - x = \\frac{1}{2x}$。被减去的两个量，$\\sqrt{x^{2}+1}$ 和 $x$，确实近似相等，这证实了灾难性抵消的前提。\n-   **适定性**：该问题是适定的。它要求对一个给定的表达式进行代数重构，以达到一个特定的、明确定义的数值属性（稳定性）。存在一个唯一的标准解。\n-   **客观性**：该问题以精确、客观的数学语言陈述。它没有歧义和主观论断。\n\n因此，该问题陈述被认为是有效的。解答过程如下。\n\n当 $x > 0$ 很大时，表达式 $f(x) = \\sqrt{x^{2}+1} - x$ 的数值不稳定性根源在于两个数量级相近的数相减。在浮点运算中，如果两个数 $a$ 和 $b$ 非常接近，它们的差 $a-b$ 的有效数字位数会显著少于 $a$ 或 $b$ 各自的有效数字位数。这种相对精度的损失被称为灾难性抵消。\n\n为了推导一个数值稳定的表达式，我们必须消除这种减法。对于包含形如 $\\sqrt{A} - B$ 的差与平方根的表达式，一种标准的代数技巧是乘以并除以其共轭表达式 $\\sqrt{A} + B$。该技巧常被称为“分子有理化”。\n\n给定函数为 $f(x) = \\sqrt{x^{2}+1} - x$。其共轭表达式为 $\\sqrt{x^{2}+1} + x$。我们将 $f(x)$ 乘以并除以此共轭表达式：\n\n$$ f(x) = (\\sqrt{x^{2}+1} - x) \\cdot \\frac{\\sqrt{x^{2}+1} + x}{\\sqrt{x^{2}+1} + x} $$\n\n现在的分子具有 $(a-b)(a+b)$ 的形式，可以简化为 $a^{2}-b^{2}$。这里，$a = \\sqrt{x^{2}+1}$ 且 $b = x$。\n\n$$ f(x) = \\frac{(\\sqrt{x^{2}+1})^{2} - x^{2}}{\\sqrt{x^{2}+1} + x} $$\n\n简化分子：\n\n$$ (\\sqrt{x^{2}+1})^{2} - x^{2} = (x^{2}+1) - x^{2} = 1 $$\n\n将此结果代回 $f(x)$ 的表达式中：\n\n$$ f(x) = \\frac{1}{\\sqrt{x^{2}+1} + x} $$\n\n这个新表达式在定义域内对所有 $x$ 都与原表达式代数等价。我们现在必须验证其数值稳定性。分母由两个正量 $\\sqrt{x^{2}+1}$ 和 $x$ 的和组成。在浮点运算中，两个同号数相加是一种良性运算，不会引起灾难性抵消。随后除以此和也是一个数值稳定的运算。\n\n对于大的 $x$，分母会变得很大，结果会正确地趋近于零，而不会有任何相对精度的损失。因此，这个转换后的表达式对于所有 $x > 0$ 都是数值稳定的，特别是对于原表达式失效的大的 $x$ 值。", "answer": "$$ \\boxed{\\frac{1}{\\sqrt{x^{2}+1} + x}} $$", "id": "2375840"}, {"introduction": "现在，让我们将理论和技巧应用于一个完整且实际的编程任务中。二次方程求根是数值计算中的一个经典问题，其标准公式在某些条件下会遭遇严重的灾难性抵消。这个综合性练习 [@problem_id:2389875] 要求您设计并实现程序，通过与高精度参考值的对比，定量地评估朴素算法和稳健算法之间的误差差异，从而将您对数值稳定性的理解提升到实践应用的高度。", "problem": "设计并实现一个程序，用于定量模拟在 $b^2 \\gg 4 a c$ 条件下计算二次方程 $a x^2 + b x + c = 0$ 的根时出现的数值不稳定性。您的程序必须将二次方程求根公式的直接、朴素计算与一个从第一性原理推导出的数值稳定计算进行比较，并且必须使用高精度参考值来测量前向相对误差。\n\n基本基础和建模假设：\n- 使用标准的浮点舍入模型进行基本运算，即浮点算术中的每个基本算术运算都满足 $\\operatorname{fl}(x \\circ y) = (x \\circ y)(1 + \\delta)$，其中 $|\\delta| \\le \\varepsilon$，$\\varepsilon$ 是机器 epsilon，$\\circ$ 表示 $+$, $-$, $\\times$, 或 $\\div$。\n- 认识到两个相近的浮点数相减会导致有效数字的损失（灾难性抵消），尤其是在 $b^2 \\gg 4 a c$ 的情况下计算 $-b + \\sqrt{b^2 - 4 a c}$ 时。\n- 使用多项式系数与根之间的关系（韦达定理）作为经过充分检验的事实：如果 $x_1$ 和 $x_2$ 是方程的根，则有 $x_1 + x_2 = -b/a$ 和 $x_1 x_2 = c/a$。\n\n程序要求：\n1. 实现两种双精度的根的计算方法：\n   - 一种朴素方法，该方法使用标准的双精度浮点数，通过二次方程求根公式 $x = (-b \\pm \\sqrt{b^2 - 4 a c})/(2 a)$ 直接计算两个根。\n   - 一种数值稳定的方法，该方法通过基于第一性原理以及系数与根之间关系进行的代数重排，来避免对相近数进行减法运算。您必须确保该实现在 $b^2 \\gg 4 a c$ 条件下，能为原本不稳定的那个根最小化抵消误差。\n2. 实现一个高精度的根的参考计算，使用基数为 10 的任意精度，精度至少设置为 $p = 80$ 个十进制位，以近似真实值。使用此参考值来评估前向误差。\n3. 对于下述每个测试用例，以高精度计算两个参考根 $x_{\\text{true},1}$ 和 $x_{\\text{true},2}$，并按绝对值大小将它们标记为“小”根 $x_{\\text{true},s}$（$|x|$ 较小的那个）和“大”根 $x_{\\text{true},L}$（$|x|$ 较大的那个）。对于每种方法（朴素和稳定），也将其计算出的两个根按绝对值大小标记为“小”和“大”，以便按尺度对齐比较。\n4. 对于一个计算根 $\\hat{x}$ 和一个参考根 $x_{\\text{true}}$，将前向相对误差定义为 $E = |\\hat{x} - x_{\\text{true}}|/|x_{\\text{true}}|$（当 $x_{\\text{true}} \\ne 0$ 时），以及 $E = |\\hat{x}|$（当 $x_{\\text{true}} = 0$ 时）。\n5. 对于每个测试用例，按顺序 $[E_{\\text{naive},s}, E_{\\text{naive},L}, E_{\\text{stable},s}, E_{\\text{stable},L}]$ 生成一个包含四个浮点数的列表。\n\n测试套件：\n使用以下五个测试用例，每个用例指定为 $(a,b,c)$：\n- $(1, 10^8, 1)$\n- $(1, -10^8, 1)$\n- $(1, 3, 1)$\n- $(1, 10^{16}, 1)$\n- $(10^{-8}, 1, 10^{-16})$\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个 Python 风格的列表的列表，其中不含空格，每个内部列表对应一个测试用例，顺序与上面列出的一致。每个浮点数必须以科学记数法格式化，小数点后保留十二位数字。例如，类似 `[[1.234000000000\\mathrm{e}{-12},5.678000000000\\mathrm{e}{+03},\\ldots],\\ldots]` 的一行。\n- 每个测试用例的输出元素必须严格按照 $[E_{\\text{naive},s}, E_{\\text{naive},L}, E_{\\text{stable},s}, E_{\\text{stable},L}]$ 的顺序排列。", "solution": "所述问题是有效的。这是一个在计算物理学中提法适定、有科学依据的问题，它探讨了数值稳定性、灾难性抵消和误差传播等基本概念。所有必要的数据、模型和定义都已提供，问题没有事实错误、歧义或矛盾。我们将给出一个完整的解决方案。\n\n问题的核心是求解二次方程 $a x^2 + b x + c = 0$ 并分析其解的数值稳定性。标准的求根公式是：\n\n$$\nx_{1,2} = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\n$$\n\n我们将分析这个公式的行为，并推导出一个更稳定的替代方案。\n\n**1. 朴素方法中的数值不稳定性分析**\n\n朴素方法直接为两个根实现上述公式。在 $b^2 \\gg 4ac$ 的条件下会出现不稳定性。在这种情况下，判别式 $\\Delta = b^2 - 4ac$ 非常接近 $b^2$，因此 $\\sqrt{\\Delta}$ 非常接近 $|b|$。\n\n让我们分析分子 $-b \\pm \\sqrt{\\Delta}$。浮点误差模型指出，一次运算的结果是真实结果乘以 $(1+\\delta)$，其中 $|\\delta| \\le \\varepsilon$，即机器 epsilon。当我们减去两个几乎相等的数时，结果的相对误差可能会非常大。这种现象被称为灾难性抵消。\n\n考虑项 $\\sqrt{b^2 - 4ac}$。对小的 $z = \\frac{4ac}{b^2}$ 使用二项式或泰勒展开：\n$$\n\\sqrt{b^2 - 4ac} = |b|\\sqrt{1 - \\frac{4ac}{b^2}} = |b|\\left(1 - \\frac{1}{2}\\frac{4ac}{b^2} - \\frac{1}{8}\\left(\\frac{4ac}{b^2}\\right)^2 - \\dots\\right) \\approx |b|\\left(1 - \\frac{2ac}{b^2}\\right)\n$$\n其中一个根的计算将涉及从 $-b$ 中减去 $\\sqrt{\\Delta}$（反之亦然）。\n- 如果 $b > 0$，则 $|b|=b$。根 $x_1 = (-b + \\sqrt{b^2-4ac})/(2a)$ 涉及减法运算：\n$$\n-b + \\sqrt{b^2-4ac} \\approx -b + b\\left(1 - \\frac{2ac}{b^2}\\right) = -b + b - \\frac{2ac}{b} = -\\frac{2ac}{b}\n$$\n该运算为 $-b + (\\approx b)$，是两个几乎相等的数相减，导致有效数字的损失。这个根是绝对值较小的那个。另一个根 $x_2 = (-b - \\sqrt{b^2-4ac})/(2a)$ 涉及两个大的负数相加，这是数值稳定的。这个根具有较大的绝对值。\n\n- 如果 $b < 0$，则 $|b|=-b$。根 $x_2 = (-b - \\sqrt{b^2-4ac})/(2a)$ 是不稳定的，因为 $-b > 0$ 且 $\\sqrt{b^2-4ac} \\approx \\sqrt{b^2} = |b| = -b$。该运算为 $(\\approx -b) - (-b)$。稳定的根是 $x_1 = (-b + \\sqrt{b^2-4ac})/(2a)$，它涉及两个大的正数相加。\n\n一般来说，不稳定的计算是涉及 $-b + \\operatorname{sgn}(b)\\sqrt{\\Delta}$ 的那个根，它对应于绝对值较小的根。稳定的计算是涉及 $-b - \\operatorname{sgn}(b)\\sqrt{\\Delta}$ 的那个根，也就是绝对值较大的根。\n\n**2. 数值稳定方法的推导**\n\n为避免灾难性抵消，必须设计一个稳定的算法。策略是：\na. 使用数值稳定版本的二次方程求根公式，计算绝对值较大的根，我们将其表示为 $\\hat{x}_L$：\n$$\n\\hat{x}_L = \\frac{-b - \\operatorname{sgn}(b)\\sqrt{b^2 - 4ac}}{2a}\n$$\n此处，项 $\\operatorname{sgn}(b)\\sqrt{b^2 - 4ac}$ 与 $b$ 的符号相同，因此 $-b$ 和 $-\\operatorname{sgn}(b)\\sqrt{b^2-4ac}$ 的符号也相同。所以它们的和是数值稳定的。\n\nb. 为了找到第二个根（绝对值较小的那个，$\\hat{x}_s$），我们使用韦达定理，该定理将根 $x_1, x_2$ 与多项式系数联系起来：\n$$\nx_1 + x_2 = -\\frac{b}{a} \\quad \\text{和} \\quad x_1 x_2 = \\frac{c}{a}\n$$\n利用乘积关系，我们可以从大根计算出小根：\n$$\n\\hat{x}_s = \\frac{c/a}{\\hat{x}_L} = \\frac{c}{a\\hat{x}_L}\n$$\n这个计算是稳定的，因为 $\\hat{x}_L$ 已被精确计算，并且作为大绝对值的根，它不接近于零。试图使用求和关系式 $\\hat{x}_s = -b/a - \\hat{x}_L$ 将是一个错误，因为它会重新引入灾难性抵消，因为 $\\hat{x}_L \\approx -b/a$。\n\n**3. 实现与误差分析**\n\n该程序将为每个测试用例 $(a, b, c)$ 实现三种求根过程：\n\n- **参考计算**：根 $x_{\\text{true},1}$ 和 $x_{\\text{true},2}$ 使用标准的二次方程求根公式计算，但采用任意精度算术。使用 $p = 85$ 个十进制位的精度，以确保这些值可作为可靠的基准真相。然后按其绝对值对所得的根进行排序，以确定绝对值较小的“小”真值根 $x_{\\text{true},s}$ 和绝对值较大的“大”真值根 $x_{\\text{true},L}$。\n\n- **朴素计算**：根 $\\hat{x}_{\\text{naive},1}$ 和 $\\hat{x}_{\\text{naive},2}$ 使用双精度浮点算术，通过标准的二次方程求根公式计算。然后按绝对值大小对它们进行排序，得到 $\\hat{x}_{\\text{naive},s}$ 和 $\\hat{x}_{\\text{naive},L}$。\n\n- **稳定计算**：使用上面推导的稳定算法，以双精度计算根。首先计算大根 $\\hat{x}_{\\text{stable},L}$，然后使用韦达定理找到小根 $\\hat{x}_{\\text{stable},s}$。此方法固有地将根按绝对值大小分开产生。\n\n最后，对每种方法（朴素和稳定）和每种根类型（小和大），都相对于高精度参考值计算前向相对误差。对于计算根 $\\hat{x}$ 和真值根 $x_{\\text{true}}$，误差 $E$ 由下式给出：\n$$\nE = \\frac{|\\hat{x} - x_{\\text{true}}|}{|x_{\\text{true}}|} \\quad (\\text{对于 } x_{\\text{true}} \\neq 0)\n$$\n计算 $|\\hat{x} - x_{\\text{true}}|$ 是在高精度下执行的，以避免在比较过程中因真值而损失精度。最终程序遍历测试套件，为每种情况计算四个所需的误差值，并按规定格式化输出。", "answer": "```python\nimport numpy as np\nimport decimal\n\ndef solve():\n    \"\"\"\n    Computes and compares the numerical stability of naive and stable algorithms\n    for solving the quadratic equation ax^2 + bx + c = 0, particularly when b^2 >> 4ac.\n    \"\"\"\n    # Set precision for high-precision reference calculations.\n    # p=80 decimal digits is required, 85 is used for safety.\n    decimal.getcontext().prec = 85\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 1.0e8, 1.0),\n        (1.0, -1.0e8, 1.0),\n        (1.0, 3.0, 1.0),\n        (1.0, 1.0e16, 1.0),\n        (1.0e-8, 1.0, 1.0e-16),\n    ]\n\n    all_case_results = []\n\n    def compute_relative_error(computed_val, true_val_hp):\n        \"\"\"\n        Calculates the forward relative error using a high-precision true value.\n        E = |computed - true| / |true|\n        \"\"\"\n        if true_val_hp == 0:\n            return abs(computed_val)\n        \n        # Promote the computed float to Decimal for accurate error calculation\n        error = abs(decimal.Decimal(computed_val) - true_val_hp) / abs(true_val_hp)\n        return float(error)\n\n    for a, b, c in test_cases:\n        # --- 1. High-Precision Reference Calculation ---\n        a_hp = decimal.Decimal(a)\n        b_hp = decimal.Decimal(b)\n        c_hp = decimal.Decimal(c)\n\n        delta_hp = (b_hp**2 - 4 * a_hp * c_hp).sqrt()\n        x_true1 = (-b_hp + delta_hp) / (2 * a_hp)\n        x_true2 = (-b_hp - delta_hp) / (2 * a_hp)\n\n        # Label true roots by magnitude: small (s) and large (L)\n        if abs(x_true1) < abs(x_true2):\n            x_true_s, x_true_L = x_true1, x_true2\n        else:\n            x_true_s, x_true_L = x_true2, x_true1\n\n        # --- 2. Naive Double-Precision Calculation ---\n        a_dp, b_dp, c_dp = a, b, c\n        \n        # Handle potential negative discriminant for real roots\n        discriminant_val = b_dp**2 - 4 * a_dp * c_dp\n        if discriminant_val < 0:\n            # Although problem context implies real roots, this is robust\n            discriminant_val = 0\n            \n        delta_dp = np.sqrt(discriminant_val)\n        \n        x_naive1 = (-b_dp + delta_dp) / (2 * a_dp)\n        x_naive2 = (-b_dp - delta_dp) / (2 * a_dp)\n        \n        # Label naive roots by magnitude\n        if abs(x_naive1) < abs(x_naive2):\n            x_naive_s, x_naive_L = x_naive1, x_naive2\n        else:\n            x_naive_s, x_naive_L = x_naive2, x_naive1\n\n        # --- 3. Stable Double-Precision Calculation ---\n        # The sign of b is used to determine the stable formula for the large root.\n        # np.copysign is used to handle b=0 robustly.\n        sign_b = np.copysign(1.0, b_dp if b_dp != 0 else 1.0)\n        \n        # Calculate the large root first, avoiding cancellation\n        x_stable_L = (-b_dp - sign_b * delta_dp) / (2 * a_dp)\n        \n        # Calculate the small root using Vieta's formula\n        x_stable_s = (c_dp / a_dp) / x_stable_L\n\n        # --- 4. Compute Forward Relative Errors ---\n        E_naive_s = compute_relative_error(x_naive_s, x_true_s)\n        E_naive_L = compute_relative_error(x_naive_L, x_true_L)\n        \n        E_stable_s = compute_relative_error(x_stable_s, x_true_s)\n        E_stable_L = compute_relative_error(x_stable_L, x_true_L)\n\n        case_errors = [E_naive_s, E_naive_L, E_stable_s, E_stable_L]\n        all_case_results.append(case_errors)\n\n    # --- 5. Format and Print Final Output ---\n    output_parts = []\n    for errors in all_case_results:\n        formatted_errors = [f\"{e:.12e}\" for e in errors]\n        output_parts.append(f\"[{','.join(formatted_errors)}]\")\n    \n    final_output_string = f\"[{','.join(output_parts)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "2389875"}]}