{"hands_on_practices": [{"introduction": "即使是久经考验的数学公式，在有限精度算术的世界里也可能出现问题。第一个实践将使用我们所熟知的一元二次方程求根公式，来揭示一个被称为“灾难性相消”（catastrophic cancellation）的关键弱点。通过解决这个问题 [@problem_id:2435764]，你将亲眼看到两个几乎相等的数字相减如何抹去有效数字，并学会一种强大的技巧——代数重构——以恢复计算的数值稳定性。", "problem": "考虑二次多项式 $p(x) = x^2 - 10^8 x + 1$。从基本原理出发，推导 $p(x) = 0$ 的两个实数根的精确闭式表达式。然后，使用有限精度浮点运算中的舍入基本模型（如电气和电子工程师协会 (IEEE) 754 双精度 (binary64) 标准），解释两个精确闭式表达式中哪一个在数值计算上是不稳定的，并说明原因，指出其灾难性抵消的机制。最后，将不稳定的根改写为一种能够避免相减抵消的、代数上等价的精确形式。\n\n回答要求：以两个根的精确符号表达式形式提供最终答案，无需数值近似。无需舍入。将最终答案表示为一对精确表达式。", "solution": "在尝试求解之前，需对问题陈述进行验证。\n\n首先，我们提取问题的已知条件。\n给定的二次多项式为 $p(x) = x^2 - 10^8 x + 1$。\n问题要求解方程 $p(x) = 0$ 的根。\n数值稳定性的分析必须在有限精度浮点运算的背景下进行，特别是要参考电气和电子工程师协会 (IEEE) 754 双精度标准。\n该任务涉及从标准求根公式导出的根表达式中，找出由于“灾难性抵消”而导致数值不稳定的那一个，并随后为该根推导出一个代数上等价但数值上稳定的表达式。\n\n接下来，我们验证问题陈述。\n该问题具有科学依据，因为它涉及数值分析中的一个基本课题：两个几乎相等的数相减时发生的精度损失。这种现象被称为灾难性抵消，是浮点运算中一个被充分认识的后果。该多项式及其系数在数学上是合理的。\n该问题是适定的。它提供了求解根并分析其数值性质所需的所有信息（$a=1, b=-10^8, c=1$）。问题是无歧义的，并能导出一组唯一的根的稳定表达式。\n该问题是客观的，以精确的数学术语陈述，不含任何主观或推测性内容。\n因此，该问题被视为有效，并将提供解答。\n\n待求解的二次方程为 $x^2 - 10^8 x + 1 = 0$。\n我们应用二次方程 $ax^2 + bx + c = 0$ 的标准求根公式，其根由 $x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$ 给出。\n对于给定的多项式，系数为 $a=1$，$b=-10^8$ 和 $c=1$。\n将这些值代入公式，得到：\n$$x = \\frac{-(-10^8) \\pm \\sqrt{(-10^8)^2 - 4(1)(1)}}{2(1)}$$\n$$x = \\frac{10^8 \\pm \\sqrt{10^{16} - 4}}{2}$$\n这给出了两个精确的实数根：\n$$x_1 = \\frac{10^8 + \\sqrt{10^{16} - 4}}{2}$$\n$$x_2 = \\frac{10^8 - \\sqrt{10^{16} - 4}}{2}$$\n\n现在，我们必须在有限精度算法中分析这些表达式的数值稳定性。潜在不稳定性的根源在于两个几乎相等的量相减。\n我们来研究所涉及各项的大小。$10^{16}$ 这一项远大于 $4$。因此，$\\sqrt{10^{16} - 4}$ 的值非常接近 $\\sqrt{10^{16}} = 10^8$。\n为了更清楚地看到这一点，我们可以使用二项式近似。\n$$\\sqrt{10^{16} - 4} = \\sqrt{10^{16}(1 - 4 \\times 10^{-16})} = 10^8 \\sqrt{1 - 4 \\times 10^{-16}}$$\n对于一个很小的值 $\\epsilon$，近似式 $(1 - \\epsilon)^{1/2} \\approx 1 - \\frac{1}{2}\\epsilon$ 成立。这里，$\\epsilon = 4 \\times 10^{-16}$，它非常小。\n因此，$\\sqrt{10^{16} - 4} \\approx 10^8 (1 - \\frac{1}{2}(4 \\times 10^{-16})) = 10^8 (1 - 2 \\times 10^{-16}) = 10^8 - 2 \\times 10^{-8}$。\n$\\sqrt{10^{16} - 4}$ 的值仅略小于 $10^8$。\n\n考虑 $x_1$ 的表达式：$x_1 = \\frac{10^8 + \\sqrt{10^{16} - 4}}{2}$。该表达式涉及两个大小相近的大正数相加。在浮点运算中，此操作是数值稳定的。其和的相对误差很小，与机器精度在同一数量级。\n\n考虑 $x_2$ 的表达式：$x_2 = \\frac{10^8 - \\sqrt{10^{16} - 4}}{2}$。该表达式涉及两个非常接近的数相减。设 $y = \\sqrt{10^{16} - 4}$。在浮点计算中，$10^8$ 和 $y$ 的计算值将在许多高位有效数字上相同。当执行减法 $10^8 - y$ 时，这些高位数字会相互抵消，结果由剩下的、有效性较低的数字决定，而这些数字又受到计算 $y$ 时产生的舍入误差的严重影响。这种相对误差的急剧增加就是灾难性抵消现象。因此，如果直接使用标准双精度算法计算，$x_2$ 的表达式是数值不稳定的，会产生一个高度不准确的结果。\n\n为了找到 $x_2$ 的一个数值稳定的表达式，我们使用韦达定理，该定理将多项式的系数与其根联系起来。对于二次方程 $ax^2 + bx + c = 0$，其两根之积为 $x_1 x_2 = \\frac{c}{a}$。\n对于我们的方程，这给出 $x_1 x_2 = \\frac{1}{1} = 1$。\n我们可以使用 $x_1$ 的公式精确地计算出稳定的根 $x_1$。然后，我们可以通过关系式 $x_2 = \\frac{1}{x_1}$ 求出 $x_2$。\n代入 $x_1$ 的稳定表达式：\n$$x_2 = \\frac{1}{\\frac{10^8 + \\sqrt{10^{16} - 4}}{2}} = \\frac{2}{10^8 + \\sqrt{10^{16} - 4}}$$\n这个修正后的 $x_2$ 表达式只涉及正数的加法和除法，这两种运算都是数值稳定的。它避免了相减抵消，因此是数值计算的首选形式。\n\n我们通过对其分母进行有理化来验证这个新形式在代数上与原来不稳定的 $x_2$ 形式是等价的：\n$$\\frac{2}{10^8 + \\sqrt{10^{16} - 4}} \\cdot \\frac{10^8 - \\sqrt{10^{16} - 4}}{10^8 - \\sqrt{10^{16} - 4}} = \\frac{2(10^8 - \\sqrt{10^{16} - 4})}{(10^8)^2 - (10^{16} - 4)} = \\frac{2(10^8 - \\sqrt{10^{16} - 4})}{10^{16} - 10^{16} + 4} = \\frac{2(10^8 - \\sqrt{10^{16} - 4})}{4} = \\frac{10^8 - \\sqrt{10^{16} - 4}}{2}$$\n这证实了代数等价性。\n\n最终要求的答案包含两个根的精确符号表达式，并以其数值稳定的形式重写。\n较大的根是 $x_1 = \\frac{10^8 + \\sqrt{10^{16} - 4}}{2}$。\n较小的根，以其稳定形式表示，是 $x_2 = \\frac{2}{10^8 + \\sqrt{10^{16} - 4}}$。", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{10^8 + \\sqrt{10^{16} - 4}}{2} & \\frac{2}{10^8 + \\sqrt{10^{16} - 4}} \\end{pmatrix}}$$", "id": "2435764"}, {"introduction": "了解了舍入误差如何破坏计算的准确性后，我们现在来探讨它如何影响程序逻辑。这个练习 [@problem_id:2447428] 模拟了一个常见的编程场景：一个循环由于浮点数的表示误差而未能如期终止。这项动手编码任务将具体展示为什么对浮点数进行精确的相等性比较是一种危险的做法，也是一个常见的程序错误的来源。", "problem": "给定实数标量 $s$、$h$ 和 $t$，以及一个正整数 $M$。考虑由 $x_0 = s$ 和 $x_{n+1} = x_n + h$（对于 $n \\ge 0$）定义的序列 $\\{x_n\\}_{n\\ge 0}$。由于表示和舍入效应，当 $x_n$ 使用二进制浮点运算计算时，检查 $x_n = t$ 是否成立的朴素终止条件可能不可靠。您的任务是编写一个程序，对每个给定的测试用例，模拟浮点序列，并报告在有界模拟迭代次数内，等式 $x_n = t$ 是否曾成立。\n\n对于每个测试用例，请执行以下步骤：\n1. 在双精度浮点运算中初始化 $x_0 = s$。\n2. 对于 $n = 0,1,2,\\dots$，在浮点运算中精确检查 $x_n = t$ 是否成立。如果对于某个 $n \\le M$ 等式成立，记录满足条件的最小 $n$ 值，并终止该测试用例的模拟。\n3. 如果在 $0 \\le n \\le M$ 范围内没有等式成立，则在 $M$ 次增量后终止模拟。\n4. 令 $n_{\\mathrm{exec}}$ 表示您的模拟为该测试用例实际执行的增量次数，其中 $n_{\\mathrm{exec}}$ 等于观察到等式成立的最小 $n$ 值（如果存在），否则为 $M$。\n5. 使用精确实数算术计算理论精确值 $x_{\\mathrm{exact}} = s + n_{\\mathrm{exec}}\\,h$，中间步骤不使用浮点舍入。\n6. 令 $x_{\\mathrm{float}}$ 表示您的模拟在 $n_{\\mathrm{exec}}$ 次增量后获得的浮点值。计算绝对误差 $e = |x_{\\mathrm{float}} - x_{\\mathrm{exact}}|$，结果为实数。\n\n对于每个测试用例，您的程序必须按顺序输出一个包含以下字段的列表：\n- 一个布尔值，指示是否存在 $n \\in \\{0,1,\\dots,M\\}$ 使得在浮点运算中 $x_n = t$。\n- 如果存在，则为满足条件的最小 $n$；否则为整数 $-1$。\n- 整数 $n_{\\mathrm{exec}}$。\n- $n_{\\mathrm{exec}}$ 次增量后的浮点值 $x_{\\mathrm{float}}$。\n- 为便于报告而转换成浮点数的理论精确值 $x_{\\mathrm{exact}}$。\n- 作为浮点数的绝对误差 $e$。\n\n请使用以下五个测试用例。在所有测试用例中，不涉及角度，也没有物理单位。以十进制书写的实数（例如 $0.1$）表示以十为基数的精确实数值，而涉及二的幂的表达式（例如 $2^{-55}$）也表示精确实数值。\n\n- 测试用例 1（使用十进制步长的典型相等性判断失败）：\n  $s = 0.0$, $h = 0.1$, $t = 1.0$, $M = 12$。\n- 测试用例 2（步长可精确表示且目标可达）：\n  $s = 0.0$, $h = 0.125$, $t = 1.0$, $M = 8$。\n- 测试用例 3（步长不能整除区间）：\n  $s = 0.0$, $h = 0.3$, $t = 1.0$, $M = 10$。\n- 测试用例 4（使用十进制步长向零负向递减）：\n  $s = 1.0$, $h = -0.1$, $t = 0.0$, $M = 12$。\n- 测试用例 5（增量小于一个末位单位直至累积）：\n  $s = 1.0$, $h = 2^{-55}$, $t = 1 + 2^{-52}$, $M = 8$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个元素本身是对应一个测试用例的列表，顺序与上文一致。例如，输出必须采用以下形式：\n$[r_1,r_2,r_3,r_4,r_5]$\n其中每个 $r_i$ 是对应于测试用例 $i$ 的列表，并且该行中不得有任何空格。每个列表 $r_i$ 的形式必须为\n$[\\text{hit}, n_{\\min}, n_{\\mathrm{exec}}, x_{\\mathrm{float}}, x_{\\mathrm{exact}}, e]$\n字段类型如上定义。此行上的所有数字输出都必须表示为以十为基数的浮点数或整数。", "solution": "该问题陈述已经过严格验证，并被确定为有效。它在科学上基于数值计算的原理，问题提法清晰，具有明确的确定性过程，并且表述客观。它提出了一个计算工程中关于浮点运算局限性的标准而根本的问题。我们现在开始进行解答。\n\n此问题的核心在于精确实数算术与基于计算机的浮点算术之间的根本区别，后者受双精度数的 IEEE $754$ 标准约束。在模拟序列 $x_{n+1} = x_n + h$ 时，会产生两个主要的误差来源：\n\n$1$. **表示误差**：许多十进制小数，例如 $0.1$ 或 $0.3$，在二进制中没有精确的有限表示。它们被存储为最接近的可表示二进制浮点数。例如，十进制数 $0.1$ 在二进制中是一个无限循环小数 ($0.0001100110011\\dots_2$)，必须被截断以适应双精度浮点数的 $52$ 位有效数位。这在任何计算开始之前就引入了初始误差。相反，那些是二的幂的有限和的数，例如 $0.125 = 1/8 = 2^{-3}$，则可以被精确表示。\n\n$2$. **舍入误差**：每次算术运算（在此情况下为加法）都是以有限精度执行的。$x_n + h$ 的数学精确结果会被舍入到最接近的可表示浮点数。这个在每一步引入的小误差，经过多次迭代后会累积，导致计算出的序列 $x_n$ 偏离其理论路径。\n\n所给问题要求通过模拟来展示这些效应。方法如下：\n\n首先，我们必须细致地处理输入值。所提供的测试用例参数 $s$、$h$ 和 $t$ 被定义为精确实数。为了计算理论值 $x_{\\mathrm{exact}}$，我们必须使用一个高精度算术库，以避免标准的浮点不精确性。为此，我们使用了 Python 的 `decimal` 模块，并将其配置为足够高的精度，以确保所有计算都如同精确计算一样。每个测试用例的输入都被转换为这些高精度对象。\n\n其次，对每个测试用例使用标准的双精度浮点运算进行模拟，这在 Python 中由 `float` 类型或 `numpy.float64` 表示。模拟遵循以下算法：\n$1$. 初始化浮点序列值 $x_{\\mathrm{float}} \\leftarrow \\text{float}(s)$。初始化 `hit` 为 `False`，`n_min` 为 $-1$。\n$2$. 使用索引 $n$ 从 $0$ 到 $M$（含）进行迭代。在每次迭代中，序列的当前值 $x_n$ 由 $x_{\\mathrm{float}}$ 表示。\n$3$. 在每一步 $n$，执行精确相等性检查：`if` $x_{\\mathrm{float}} == \\text{float}(t)$。\n$4$. 如果等式成立，则目标已达到。我们将 `hit` 设置为 `True`，记录当前索引为 $n_{\\mathrm{min}} = n$，将执行的增量次数设为 $n_{\\mathrm{exec}} = n$，存储 $x_{\\mathrm{float}}$ 的当前值作为最终值，并终止该测试用例的模拟循环。\n$5$. 如果等式不成立且 $n < M$，则序列前进一步：$x_{\\mathrm{float}} \\leftarrow x_{\\mathrm{float}} + \\text{float}(h)$。\n$6$. 如果循环完成而未找到等式成立的情况（即，对于所有 $n \\in \\{0, 1, \\dots, M\\}$），我们将 $n_{\\mathrm{exec}}$ 设为 $M$。$x_{\\mathrm{float}}$ 的最终值是 $M$ 次增量后的结果。\n\n第三，在模拟确定了 $n_{\\mathrm{exec}}$ 和最终 $x_{\\mathrm{float}}$ 的值之后，我们计算理论量。\n$1$. 使用高精度的 `Decimal` 对象计算精确的最终值：$x_{\\mathrm{exact}} = s_{\\mathrm{exact}} + n_{\\mathrm{exec}} \\cdot h_{\\mathrm{exact}}$。\n$2$. 那么绝对误差为 $e = |x_{\\mathrm{float}} - \\text{float}(x_{\\mathrm{exact}})|$。\n\n最后，将六个所需的输出字段（`hit`、$n_{\\mathrm{min}}$、$n_{\\mathrm{exec}}$、$x_{\\mathrm{float}}$、$\\text{float}(x_{\\mathrm{exact}})$ 和 $e$）收集到每个测试用例的列表中。\n\n具体的测试用例旨在说明不同的行为：\n- **用例 1、3 和 4**：这些用例使用的步长（$h = \\pm 0.1$、$h = 0.3$）在二进制中无法精确表示。表示误差和舍入误差的累积将导致浮点序列精确地错过目标值 $t$。因此，我们预期 `hit` 为 `False`。\n- **用例 2**：在此用例中，$s、h、t$（`0.0`、`0.125`、`1.0`）都可以精确表示，因为 $h=2^{-3}$。所有的加法都是精确的。序列将在 $n=8$ 时精确达到目标 $t=1.0$。因此，我们预期 `hit` 为 `True`。\n- **用例 5**：这个用例很微妙。起始值是 $s=1.0$。对于 $1.0$ 来说，其末位单位（ULP）是 $2^{-52}$。增量是 $h = 2^{-55}$，它小于 $1.0$ 的 ULP 的一半。根据 IEEE $754$ 中的“舍入到最近偶数”规则，操作 $1.0 + 2^{-55}$ 会舍入回 $1.0$。因此，模拟的 $x_n$ 值将一直停留在 $1.0$，永远不会达到目标 $t = 1.0 + 2^{-52}$。然而，精确的和确实会累积。这展示了由于微小增量丢失而导致的显著截断误差。我们预期 `hit` 为 `False`，并且会产生一个等于丢失增量总和的非零误差 $e$。", "answer": "```python\nimport numpy as np\nfrom decimal import Decimal, getcontext\n\ndef solve():\n    \"\"\"\n    Simulates a floating-point sequence and compares it with exact arithmetic.\n    \"\"\"\n    # Set a high precision for the Decimal module for \"exact\" calculations.\n    getcontext().prec = 100\n\n    def run_case_simulation(s_exact, h_exact, t_exact, M):\n        \"\"\"\n        Runs the simulation for a single test case.\n        \"\"\"\n        # Convert exact Decimal inputs to double-precision floats for simulation.\n        s_f = np.float64(s_exact)\n        h_f = np.float64(h_exact)\n        t_f = np.float64(t_exact)\n\n        x_n_float = s_f\n        hit = False\n        n_min = -1\n        \n        # Loop from n=0 to M, checking the sequence value x_n at each step.\n        for n in range(M + 1):\n            # Per problem, check for exact floating-point equality.\n            if x_n_float == t_f:\n                hit = True\n                n_min = n\n                n_exec = n\n                x_float_final = x_n_float\n                break\n            \n            # If not hit and not the last iteration, perform one increment.\n            if n  M:\n                x_n_float += h_f\n        else:  # This 'else' clause executes if the 'for' loop completes without a 'break'.\n            n_exec = M\n            # The final value is the result after M increments.\n            x_float_final = x_n_float\n\n        # Calculate the theoretical exact value and the absolute error.\n        x_exact_val = s_exact + Decimal(n_exec) * h_exact\n        error = np.abs(x_float_final - np.float64(x_exact_val))\n\n        return [hit, n_min, n_exec, x_float_final, np.float64(x_exact_val), error]\n\n    # Define test cases using Decimal for exact representation of inputs.\n    test_cases = [\n        # Test case 1: Canonical failure with decimal step.\n        (Decimal('0.0'), Decimal('0.1'), Decimal('1.0'), 12),\n        # Test case 2: Exactly representable step and reachable target.\n        (Decimal('0.0'), Decimal('0.125'), Decimal('1.0'), 8),\n        # Test case 3: Step does not subdivide the interval.\n        (Decimal('0.0'), Decimal('0.3'), Decimal('1.0'), 10),\n        # Test case 4: Negative step toward zero with decimal step.\n        (Decimal('1.0'), Decimal('-0.1'), Decimal('0.0'), 12),\n        # Test case 5: Increments below one ULP until accumulation.\n        (Decimal('1.0'), Decimal(1) / (Decimal(2)**55), Decimal(1) + Decimal(1) / (Decimal(2)**52), 8)\n    ]\n    \n    all_results = []\n    for case_params in test_cases:\n        s, h, t, M = case_params\n        result = run_case_simulation(s, h, t, M)\n        all_results.append(result)\n\n    # Format the output string to be a list of lists with no spaces.\n    # Each inner list is manually formatted to avoid spaces from default str(list).\n    result_strings = []\n    for res in all_results:\n        # Note: res[0] is a boolean, str(res[0]) is 'True' or 'False'.\n        res_str = f\"[{res[0]},{res[1]},{res[2]},{res[3]},{res[4]},{res[5]}]\"\n        result_strings.append(res_str)\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2447428"}, {"introduction": "识别数值陷阱是第一步，而克服它们则是下一步。这最后一个实践将介绍一种强大的算法，用以解决求和过程中的累积舍入误差问题。你将实现并测试 Kahan 求和算法 [@problem_id:2447409]，这是一种经典的技术，它巧妙地追踪并补偿每次加法中损失的精度，从而得到显著更准确的结果。", "problem": "您必须编写一个完整、可运行的程序，该程序评估对实数序列求和时的舍入误差，并使用 Kahan 求和算法展示误差的减小。所有计算都必须使用标准双精度二进制浮点算术进行。对于每个测试用例，计算同一序列的两个和：一个朴素的从左到右浮点和，以及一个使用 Kahan 求和算法的补偿和。对于每个和，计算其相对于高精度参考和的绝对误差。您的程序随后必须输出单行文本，其中包含所有测试用例的所有绝对误差，并遵循指定的顺序和格式。\n\n对于一个计算和 $\\hat{S}$，其相对于参考值 $S^{\\star}$ 的绝对误差定义为 $E = \\lvert \\hat{S} - S^{\\star} \\rvert$。\n\n测试套件由以下四个序列组成：\n\n- 测试用例 $1$ (将许多微小增量添加到一个大的基准值上):\n  - 序列 $S_1$ 的长度为 $N_1 + 1$，其中 $N_1 = 10^{6}$。第一项是 $s^{(1)}_0 = 1$，其余 $N_1$ 项为 $s^{(1)}_k = 10^{-16}$ (对于 $1 \\le k \\le N_1$) 。\n\n- 测试用例 $2$ (重复的灾难性抵消三元组):\n  - 设 $M = 2 \\cdot 10^{5}$。序列 $S_2$ 是 $M$ 个三项组 $(1, 10^{-16}, -1)$ 的拼接。\n\n- 测试用例 $3$ (具有轻微偏差的确定性伪随机小数值):\n  - 设模数 $m = 2^{64}$，乘数 $a = 6364136223846793005$，增量 $c = 1442695040888963407$，种子 $x_0 = 123456789123456789$。通过 $x_{k+1} \\equiv a x_k + c \\pmod{m}$ (对于 $k \\ge 0$) 定义一个线性同余生成器。设 $N_3 = 5 \\cdot 10^{4}$。对于 $k = 1, 2, \\dots, N_3$，定义 $u_k = \\frac{x_k}{m} - \\frac{1}{2}$ 以及序列项 $s^{(3)}_k = 10^{-12} u_k + 10^{-16}$。序列 $S_3$ 由这 $N_3$ 个项组成。\n\n- 测试用例 $4$ (短序列中的动态范围和抵消):\n  - 序列 $S_4$ 有五个项：$(10^{16}, 1, -10^{16}, 3, 4 \\cdot 10^{-16})$。\n\n对于每个测试用例 $i \\in \\{1,2,3,4\\}$，计算：\n- 朴素和 $\\hat{S}^{\\text{naive}}_i$：通过在双精度浮点算术中从左到右累加得到。\n- Kahan 补偿和 $\\hat{S}^{\\text{Kahan}}_i$：在双精度浮点算术中使用 Kahan 求和算法得到。\n- 一个高精度参考值 $S^{\\star}_i$：根据序列的数学定义计算得出，尽可能使用精确算术，或使用至少有 $50$ 位正确十进制数字的以 $10$ 为基数的任意精度算术，以确保双精度下的舍入不会污染 $S^{\\star}_i$。\n\n对于每个测试用例 $i$，计算绝对误差 $E^{\\text{naive}}_i = \\lvert \\hat{S}^{\\text{naive}}_i - S^{\\star}_i \\rvert$ 和 $E^{\\text{Kahan}}_i = \\lvert \\hat{S}^{\\text{Kahan}}_i - S^{\\star}_i \\rvert$。\n\n最终输出格式：\n- 生成单行输出，包含一个用方括号括起来的逗号分隔列表。该列表必须按以下顺序包含 $8$ 个数字：\n  - $E^{\\text{naive}}_1, E^{\\text{Kahan}}_1, E^{\\text{naive}}_2, E^{\\text{Kahan}}_2, E^{\\text{naive}}_3, E^{\\text{Kahan}}_3, E^{\\text{naive}}_4, E^{\\text{Kahan}}_4$。\n- 每个数字必须四舍五入到 $12$ 位有效数字，并以十进制形式表示（科学记数法是可接受的）。\n- 所需单行格式示例（仅为说明）：$[e_1,e_2,e_3,e_4,e_5,e_6,e_7,e_8]$。\n\n本问题不涉及物理单位或角度单位。程序必须是自包含的，且不得需要任何用户输入或外部文件。在任何遵循标准双精度浮点语义的现代编程语言中，结果必须能够根据上述定义精确复现。", "solution": "问题陈述已经过分析，并被确定为有效。其科学基础是数值分析的原理，特别是关于浮点算术和舍入误差。该问题是良构的，提供了计算唯一、可验证解所需的所有数据和定义。它是客观的，没有歧义。\n\n这个问题的核心是，在对数量级差异巨大的浮点数进行求和时，展示并量化发生的精度损失，以及如何使用补偿求和算法来减轻这种误差。\n\n所有计算均使用标准双精度浮点算术执行，这对应于 IEEE 754 $64$ 位格式。该格式具有大约 $15$ 到 $17$ 位的十进制精度。对于此格式，机器 epsilon $\\epsilon$（即满足 $1.0 + \\epsilon  1.0$ 的最小数）约为 $2.22 \\times 10^{-16}$。当两个数量级差异巨大的数相加时，较小的数可能会部分或完全丢失。这种现象被称为“淹没”(swamping)。\n\n第一种求和方法是朴素的从左到右累加。对于序列 $s_0, s_1, \\dots, s_N$，其和 $\\hat{S}^{\\text{naive}}$ 计算为 $(\\dots((s_0 + s_1) + s_2) + \\dots + s_N)$。这种方法极易受到舍入误差的影响。\n\n第二种方法是 Kahan 求和算法，这是一种补偿求和方法。它能显著减少对有限精度浮点数序列求和时产生的数值误差。该算法维护一个动态的补偿变量 $c$，用于累积本应丢失的误差。对于序列中的每一项 $s_k$，更新规则如下：\n$$y_k = s_k - c_{k-1}$$\n$$t_k = \\text{sum}_{k-1} + y_k$$\n$$c_k = (t_k - \\text{sum}_{k-1}) - y_k$$\n$$\\text{sum}_k = t_k$$\n这里，$\\text{sum}_0 = 0$ 且 $c_0 = 0$。项 $(t_k - \\text{sum}_{k-1})$ 恢复了 $y_k$ 的高位部分，而从中减去 $y_k$ 则分离出了低位部分（即舍入误差），该误差存储在 $c_k$ 中，并从下一项 $s_{k+1}$ 中减去。\n\n绝对误差定义为 $E = \\lvert \\hat{S} - S^{\\star} \\rvert$，其中 $\\hat{S}$ 是计算所得的和，$S^{\\star}$ 是高精度参考和。\n\n测试用例分析：\n\n测试用例 $1$：\n序列为 $s^{(1)}_0 = 1$，后跟 $N_1 = 10^6$ 个项，这些项为 $s^{(1)}_k = 10^{-16}$ (当 $k \\ge 1$ 时)。\n精确和为 $S^{\\star}_1 = 1 + 10^6 \\times 10^{-16} = 1 + 10^{-10}$。\n在朴素求和中，我们计算 $1 + 10^{-16} + 10^{-16} + \\dots$。相对于 $1.0$，项 $10^{-16}$ 非常接近机器 epsilon。在双精度算术中，运算 $1.0 + 10^{-16}$ 会遭受“淹没”效应；结果很可能会被舍入回 $1.0$。因此，大多数小项会丢失，$\\hat{S}^{\\text{naive}}_1$ 预计会非常接近 $1.0$，导致误差接近 $10^{-10}$。\nKahan 算法会在每一步中将丢失的部分 $10^{-16}$ 捕获到补偿变量 $c$ 中并重新引入，从而得到一个与 $S^{\\star}_1$ 极其接近的结果 $\\hat{S}^{\\text{Kahan}}_1$。误差 $E^{\\text{Kahan}}_1$ 应当接近机器精度。\n\n测试用例 $2$：\n序列由 $M = 2 \\cdot 10^5$ 个块 $(1, 10^{-16}, -1)$ 组成。\n每个块的精确和为 $1 + 10^{-16} - 1 = 10^{-16}$。总精确和为 $S^{\\star}_2 = 2 \\cdot 10^5 \\times 10^{-16} = 2 \\cdot 10^{-11}$。\n朴素求和将计算 $(1 + 10^{-16}) - 1$。与第一个案例一样，$1 + 10^{-16}$ 很可能会舍入为 $1.0$，因此 $(1 + 10^{-16}) - 1$ 的计算结果为 $0$。对所有块重复此过程，$\\hat{S}^{\\text{naive}}_2$ 预计为 $0.0$，导致误差 $E^{\\text{naive}}_2$ 恰好为 $2 \\cdot 10^{-11}$。\nKahan 算法将防止这种抵消错误，产生一个与 $S^{\\star}_2$ 非常接近的和 $\\hat{S}^{\\text{Kahan}}_2$，以及一个更小的误差 $E^{\\text{Kahan}}_2$。\n\n测试用例 $3$：\n序列由 $N_3 = 5 \\cdot 10^4$ 个项 $s^{(3)}_k = 10^{-12} u_k + 10^{-16}$ 组成，其中 $u_k = \\frac{x_k}{m} - \\frac{1}{2}$ 且 $x_k$ 来自一个线性同余生成器 (LCG)。$u_k$ 的值是范围在 $[-0.5, 0.5)$ 内的伪随机数。项 $s^{(3)}_k$ 很小，并带有 $10^{-16}$ 的微小正偏差。\n精确和为 $S^{\\star}_3 = \\sum_{k=1}^{N_3} (10^{-12} u_k + 10^{-16}) = 10^{-12} \\sum_{k=1}^{N_3} u_k + N_3 \\cdot 10^{-16}$。\n这个和必须使用高精度算术来计算，以作为参考值 $S^{\\star}_3$。LCG 的状态 $x_{k+1} \\equiv a x_k + c \\pmod{m}$ 使用 $64$ 位整数算术计算。和 $\\sum x_k$ 使用任意精度整数计算，而 $S^{\\star}_3$ 的最终表达式则使用高精度十进制算术求值。\n在 $5 \\cdot 10^4$ 次加法中，朴素求和会累积小的舍入误差。Kahan 算法预计会最小化这种累积，从而导致 $E^{\\text{Kahan}}_3 \\ll E^{\\text{naive}}_3$。\n\n测试用例 $4$：\n序列为 $(10^{16}, 1, -10^{16}, 3, 4 \\cdot 10^{-16})$。\n精确和为 $S^{\\star}_4 = (10^{16} - 10^{16}) + (1 + 3) + 4 \\cdot 10^{-16} = 4 + 4 \\cdot 10^{-16}$。\n朴素的从左到右求和按步骤计算如下：\n1. $10^{16} + 1 = 10^{16}$（淹没，因为 $1$ 小于 $10^{16}$ 的最末位单位）。\n2. $10^{16} - 10^{16} = 0$。\n3. $0 + 3 = 3$。\n4. $3 + 4 \\cdot 10^{-16} = 3$（淹没，因为 $4 \\cdot 10^{-16}$ 小于相对于 $3$ 的机器 epsilon）。\n所以，$\\hat{S}^{\\text{naive}}_4 = 3$。误差为 $E^{\\text{naive}}_4 = \\lvert 3 - (4 + 4 \\cdot 10^{-16}) \\rvert \\approx 1$。\nKahan 求和算法就是为处理这种情况而设计的。第一步中损失的 $1$ 将被补偿变量捕获。最终的和 $\\hat{S}^{\\text{Kahan}}_4$ 应该非常接近真实和 $S^{\\star}_4$，从而产生一个非常小的误差 $E^{\\text{Kahan}}_4$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport decimal\n\ndef solve():\n    \"\"\"\n    Computes and prints round-off errors for naive and Kahan summations\n    for four specific test cases, adhering to the problem specification.\n    \"\"\"\n\n    def naive_sum(sequence):\n        \"\"\"Computes the naive left-to-right sum of a sequence.\"\"\"\n        s = 0.0\n        for x in sequence:\n            s += x\n        return s\n\n    def kahan_sum(sequence):\n        \"\"\"Computes the sum of a sequence using Kahan's algorithm.\"\"\"\n        s = 0.0\n        c = 0.0\n        for x in sequence:\n            y = x - c\n            t = s + y\n            c = (t - s) - y\n            s = t\n        return s\n\n    def generate_test_cases():\n        \"\"\"Generates the sequences for all four test cases.\"\"\"\n        # Test Case 1: Many tiny increments\n        N1 = 10**6\n        seq1 = np.full(N1, 1e-16, dtype=np.float64)\n        seq1 = np.insert(seq1, 0, 1.0)\n        \n        # Test Case 2: Repeated catastrophic cancellation\n        M = 2 * 10**5\n        block = np.array([1.0, 1e-16, -1.0], dtype=np.float64)\n        seq2 = np.tile(block, M)\n        \n        # Test Case 3: LCG-based sequence\n        m = 2**64\n        a = 6364136223846793005\n        c = 1442695040888963407\n        x0 = 123456789123456789\n        N3 = 5 * 10**4\n        \n        seq3 = np.zeros(N3, dtype=np.float64)\n        x_current = x0\n        for k in range(N3):\n            x_current = (a * x_current + c) % m\n            u_k = x_current / m - 0.5\n            seq3[k] = 1e-12 * u_k + 1e-16\n\n        # Test Case 4: Dynamic range and cancellation\n        seq4 = np.array([1e16, 1.0, -1e16, 3.0, 4e-16], dtype=np.float64)\n        \n        return [seq1, seq2, seq3, seq4]\n\n    def get_reference_sums():\n        \"\"\"Computes high-accuracy reference sums for all test cases.\"\"\"\n        # Set precision for Decimal calculations\n        decimal.getcontext().prec = 100\n\n        # Reference Sum 1\n        N1 = 10**6\n        s_star_1 = decimal.Decimal(1) + decimal.Decimal(N1) * decimal.Decimal('1e-16')\n\n        # Reference Sum 2\n        M = 2 * 10**5\n        s_star_2 = decimal.Decimal(M) * decimal.Decimal('1e-16')\n\n        # Reference Sum 3\n        m = 2**64\n        a = 6364136223846793005\n        c = 1442695040888963407\n        x0 = 123456789123456789\n        N3 = 5 * 10**4\n        \n        sum_x = 0\n        x_current = x0\n        for _ in range(N3):\n            x_current = (a * x_current + c) % m\n            sum_x += x_current\n        \n        D_sum_x = decimal.Decimal(sum_x)\n        D_m = decimal.Decimal(m)\n        D_N3 = decimal.Decimal(N3)\n        D_1e_12 = decimal.Decimal('1e-12')\n        D_1e_16 = decimal.Decimal('1e-16')\n        D_half = decimal.Decimal('0.5')\n        \n        sum_u = D_sum_x / D_m - D_N3 * D_half\n        s_star_3 = D_1e_12 * sum_u + D_N3 * D_1e_16\n\n        # Reference Sum 4\n        s_star_4 = decimal.Decimal('4') + decimal.Decimal('4e-16')\n        \n        return [float(s_star_1), float(s_star_2), float(s_star_3), float(s_star_4)]\n\n    sequences = generate_test_cases()\n    reference_sums = get_reference_sums()\n    \n    results = []\n    \n    for i in range(4):\n        seq = sequences[i]\n        s_star = reference_sums[i]\n        \n        # Naive sum and its error\n        s_naive = naive_sum(seq)\n        e_naive = abs(s_naive - s_star)\n        \n        # Kahan sum and its error\n        s_kahan = kahan_sum(seq)\n        e_kahan = abs(s_kahan - s_star)\n        \n        results.extend([e_naive, e_kahan])\n\n    # Format output to 12 significant digits and print\n    formatted_results = [f\"{res:.12g}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2447409"}]}