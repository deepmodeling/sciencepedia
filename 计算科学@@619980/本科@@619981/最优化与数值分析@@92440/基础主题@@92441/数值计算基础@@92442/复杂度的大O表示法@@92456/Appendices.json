{"hands_on_practices": [{"introduction": "要真正掌握算法复杂性，最好的方法是从分析一个基础且具体的计算任务开始。这个练习将带你分析一个在数值线性代数中至关重要的操作：验证一个向量是否是矩阵的特征向量。通过分解这个验证过程的步骤，你将学会如何将算法的每一步操作映射到其计算成本，并最终使用大O表示法来确定其整体时间复杂度。", "problem": "在开发一个数值线性代数库时，需要一个函数来验证特征向量算法的结果。该验证函数接受一个$n \\times n$的实数值方阵$A$和一个非零的$n$维实数值列向量$x$作为输入。该函数必须确定$x$是否是$A$的一个特征向量。对于大规模计算，该算法的性能分析至关重要。\n\n你的任务是确定执行此验证的最有效算法的最坏情况时间复杂度。时间复杂度应使用大O表示法表示为矩阵维度$n$的函数。假设基本算术运算（加、减、乘、除）和比较操作都花费常数时间，$O(1)$。\n\n对于这个验证过程，最紧确的大O时间复杂度是多少？\n\nA. $O(n)$\n\nB. $O(n \\log n)$\n\nC. $O(n^2)$\n\nD. $O(n^3)$\n\nE. $O(n!)$", "solution": "我们必须验证给定的非零向量$x \\in \\mathbb{R}^{n}$是否是给定矩阵$A \\in \\mathbb{R}^{n \\times n}$的一个特征向量。根据定义，$x$是$A$的特征向量当且仅当存在一个标量$\\lambda \\in \\mathbb{R}$使得\n$$\nA x = \\lambda x,\n$$\n其中给定$x \\neq 0$。\n\n一个高效的验证算法如下进行。\n\n1) 计算矩阵-向量乘积 $y = A x$。对于每个$i \\in \\{1,\\dots,n\\}$，\n$$\ny_{i} = \\sum_{j=1}^{n} a_{ij} x_{j}.\n$$\n每行需要$n$次乘法和$n-1$次加法，因此总共有$\\Theta(n^{2})$次算术运算。在每次算术运算为$O(1)$的假设下，此步骤的成本为$O(n^{2})$。\n\n2) 确定一个候选特征值$\\lambda$。找到一个索引$k$使得$x_{k} \\neq 0$（由于$x \\neq 0$，这样的索引必然存在）。在最坏情况下，这个搜索的成本为$O(n)$。定义\n$$\n\\lambda = \\frac{y_{k}}{x_{k}},\n$$\n一旦找到$k$，这需要$O(1)$的时间。\n\n3) 逐分量验证等式$y = \\lambda x$。对于每个$j \\in \\{1,\\dots,n\\}$：\n- 如果$x_{j} \\neq 0$，检查是否$y_{j} = \\lambda x_{j}$。\n- 如果$x_{j} = 0$，检查是否$y_{j} = 0$。\n此步骤使用$O(n)$次比较和至多$O(n)$次乘法。\n\n因此，该算法的总运行时间为\n$$\nO(n^{2}) + O(n) + O(n) = O(n^{2}),\n$$\n主要由矩阵-向量乘法决定。\n\n为了说明在最坏情况下没有算法能渐近地做得更好，我们考虑一个下界论证。假设$x$没有任何零分量。任何检查少于$A$中所有$n^{2}$个元素的算法，都会留下至少一个元素$a_{pq}$未被检查。构造两个矩阵$A$和$A'$，它们在所有已检查的元素上都相同，仅在$a_{pq}$处相差某个$\\delta \\neq 0$。那么\n$$\n(A' x)_{p} = (A x)_{p} + \\delta x_{q},\n$$\n由于$x_{q} \\neq 0$，这将使第$p$个分量发生一个非零量的改变。通过适当地选择$\\delta$，可以使得$A$和$A'$中的一个满足$A x = \\lambda x$（对于某个$\\lambda$），而另一个不满足。一个没有检查$a_{pq}$的算法无法区分这两种情况，因此任何正确的算法在最坏情况下都必须检查$\\Omega(n^{2})$个元素，这意味着时间下界为$\\Omega(n^{2})$。\n\n将$O(n^{2})$的上界与$\\Omega(n^{2})$的下界结合起来，得到一个紧确的$\\Theta(n^{2})$界。在大O表示法中，选项中最紧确的选择是$O(n^{2})$，对应于选项C。", "answer": "$$\\boxed{C}$$", "id": "2156952"}, {"introduction": "在许多科学和工程应用中，我们处理的矩阵绝大多数元素都为零，这类矩阵被称为“稀疏矩阵”。直接使用标准算法处理稀疏矩阵会浪费大量时间在零元素上，因此我们需要更高效的方法。这个练习将向你展示，当利用专门的数据结构（例如坐标列表格式）来存储稀疏矩阵时，算法的复杂度分析会如何变化，从而让你理解数据结构与算法效率之间的密切关系。", "problem": "在计算科学领域，许多问题涉及线性系统，而其中的矩阵是稀疏的。如果一个矩阵的非零元素数量远小于其总元素数量，则该矩阵被认为是稀疏的。为了提高性能和减少内存使用，人们使用专门的数据结构和算法来处理这些矩阵。\n\n考虑一个 $n \\times n$ 的稀疏矩阵 $A$，它恰好包含 $k$ 个非零元素，其中 $k \\ll n^2$。矩阵 $A$ 使用坐标列表（COO）表示法进行存储。该格式使用三个长度为 $k$ 的列表：一个用于存储非零元素的值，一个用于存储它们对应的行索引，另一个用于存储它们对应的列索引。\n\n你的任务是分析一个计算乘积 $y = Ax$ 的算法的时间复杂度，其中 $x$ 是一个大小为 $n$ 的稠密列向量（即，它有 $n$ 个元素，所有元素都可能非零）。\n\n该算法的执行过程如下：\n1.  创建一个大小为 $n$ 的输出向量 $y$，并将其所有元素初始化为零。\n2.  接着，算法使用COO列表对 $A$ 的 $k$ 个非零元素进行一次精确迭代。对于每个位于行索引 $i$ 和列索引 $j$ 且值为 $v$ 的非零元素，执行更新操作：$y_i \\leftarrow y_i + v \\cdot x_j$。\n\n用大O表示法表示，该算法的最坏情况时间复杂度是多少？\n\nA. $O(n)$\n\nB. $O(k)$\n\nC. $O(n+k)$\n\nD. $O(nk)$\n\nE. $O(n^2)$\n\nF. $O(k \\log n)$", "solution": "设 $A \\in \\mathbb{R}^{n \\times n}$ 是一个恰好有 $k$ 个非零元素并以COO格式存储的矩阵，设 $x \\in \\mathbb{R}^{n}$ 是一个稠密向量。该算法按如下方式计算 $y = Ax$。\n\n步骤1（初始化）：创建 $y \\in \\mathbb{R}^{n}$ 并将其所有元素设置为零。设置每个元素是一个常数时间操作。设每次写入的常数成本为 $c_{1}$。那么此步骤的时间为\n$$\nT_{1}(n) = c_{1} n,\n$$\n即 $\\Theta(n)$，因此也是 $O(n)$。\n\n步骤2（单次遍历非零元素）：对 $A$ 的 $k$ 个非零元素进行一次遍历。对于每个非零元素 $(v,i,j)$，执行更新操作 $y_{i} \\leftarrow y_{i} + v \\cdot x_{j}$。在标准RAM模型下，访问 $x_{j}$、乘以 $v$ 以及加到 $y_{i}$ 上的操作都是常数时间操作。设处理每个非零元素的常数成本为 $c_{2}$。那么此步骤的时间为\n$$\nT_{2}(k) = c_{2} k,\n$$\n即 $\\Theta(k)$，因此也是 $O(k)$。\n\n总时间：总运行时间是两个独立步骤之和，\n$$\nT(n,k) = T_{1}(n) + T_{2}(k) = c_{1} n + c_{2} k.\n$$\n用大O表示法，表示为\n$$\nT(n,k) \\in O(n + k).\n$$\n因此，最坏情况时间复杂度是 $O(n + k)$，对应于选项C。", "answer": "$$\\boxed{C}$$", "id": "2156941"}, {"introduction": "“分而治之”是一种强大且优雅的算法设计策略，它将一个大问题分解为多个较小的、独立的子问题来解决。这个练习模拟了一个典型的分治算法，你需要为它建立并求解一个递推关系，以确定其时间复杂度。通过解决这个问题，你将熟悉一种在计算机科学中反复出现的复杂度类别——$O(n \\log n)$，它是许多高效排序和搜索算法（如归并排序）的标志。", "problem": "一位软件工程师正在设计一种名为 'LogSynthesizer' 的新算法，用于处理和整合服务器日志文件。该算法操作于一个包含 $n$ 个条目的日志文件。\n\nLogSynthesizer 算法的设计如下：\n1. 如果日志文件只有一个条目（即 $n=1$），该算法执行常数次操作后终止。\n2. 如果日志文件有多个条目，该算法执行以下三个步骤：\n    a. 它将日志文件分成相等的两半，每半包含 $n/2$ 个条目。\n    b. 它递归地调用自身，分别处理这两半。\n    c. 在两个递归调用返回后，它合并它们处理后的结果。这个合并步骤需要对所有原始的 $n$ 个条目进行一次遍历以确保一致性，并且这次遍历花费的总时间与 $n$ 成正比。\n\n设 $T(n)$ 是 LogSynthesizer 算法处理大小为 $n$ 的日志文件所需的总操作次数函数。根据描述，确定该算法时间复杂度的最紧渐近上界（大O表示法）。\n\n从以下选项中选择正确的选项：\nA. $O(\\log n)$\n\nB. $O(n)$\n\nC. $O(n \\log n)$\n\nD. $O(n^2)$\n\nE. $O(2^n)$", "solution": "设 $T(n)$ 表示总操作次数。根据算法描述：\n- 基本情况：$T(1)=\\Theta(1)$。\n- 对于 $n1$，算法分解为两个大小为 $n/2$ 的子问题，递归地解决它们，并在线性时间内合并结果。因此存在一个常数 $c0$ 使得\n$$\nT(n)=2\\,T\\!\\left(\\frac{n}{2}\\right)+c\\,n.\n$$\n\n使用递归树方法，为简单起见，假设 $n=2^{h}$，那么树的高度为 $h=\\log_{2}(n)$。在第 $i$ 层（$0 \\leq i \\leq h-1$），有 $2^{i}$ 个大小为 $n/2^{i}$ 的子问题。第 $i$ 层的总合并成本是\n$$\n2^{i}\\cdot c\\left(\\frac{n}{2^{i}}\\right)=c\\,n.\n$$\n由于在到达叶子节点之前有 $h=\\log_{2}(n)$ 个这样的层，所有非叶子节点的总成本是\n$$\nc\\,n\\,\\log_{2}(n).\n$$\n在叶子节点处，有 $2^{h}=n$ 个大小为 1 的子问题，每个成本为 $\\Theta(1)$，所以叶子节点的总成本是 $\\Theta(n)$。\n\n因此，\n$$\nT(n)=\\Theta\\!\\left(n\\log_{2}(n)\\right)+\\Theta(n)=\\Theta\\!\\left(n\\log_{2}(n)\\right).\n$$\n等价地，在对数底的常数因子范围内，$T(n)=\\Theta\\!\\left(n\\log(n)\\right)$。因此，最紧的渐近上界是 $O(n\\log n)$，这对应于选项C。\n\n根据主定理，当 $a=2$、$b=2$ 且 $f(n)=c\\,n$ 时，我们有 $n^{\\log_{b}a}=n$，且 $f(n)=\\Theta\\!\\left(n^{\\log_{b}a}\\right)$，这属于主定理的第二种情况，并得出相同的结果 $T(n)=\\Theta\\!\\left(n\\log n\\right)$。", "answer": "$$\\boxed{C}$$", "id": "2156959"}]}