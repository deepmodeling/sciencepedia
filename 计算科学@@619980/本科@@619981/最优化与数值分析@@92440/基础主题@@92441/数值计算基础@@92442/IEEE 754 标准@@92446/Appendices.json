{"hands_on_practices": [{"introduction": "要真正理解计算机如何处理实数，第一步是学习解读其底层表示。这个练习将指导你手动将一个32位的十六进制模式，按照IEEE 754单精度标准，分解为其符号、指数和尾数部分，并计算出其对应的十进制值。通过这个过程，你将对浮点数的内部结构建立起直观的认识。[@problem_id:1948832]", "problem": "在一个32位微处理器架构中，一个浮点单元寄存器包含十六进制值 $0xC1E80000$。该值需要根据电气和电子工程师协会 (IEEE) 754 单精度浮点数标准进行解释。\n\n32位单精度格式的结构如下：\n- 1位符号字段 (S)，位于第31位（最高有效位）。\n- 8位偏置指数字段 (E)，位于第30位到第23位。\n- 23位小数部分字段 (F)，位于第22位到第0位。\n\n对于一个规格化数（指数字段不全为0或全为1），其十进制值由公式 $N = (-1)^S \\times (1.F)_2 \\times 2^{(E - \\text{bias})}$ 给出，其中 $(1.F)_2$ 表示隐含的前导1后跟小数部分位，并被解释为一个二进制数。单精度的指数偏置值为127。\n\n确定由位模式 $0xC1E80000$ 表示的数的十进制值。", "solution": "根据 IEEE 754 单精度标准，各个字段为：符号位 $S$（第31位）、指数字段 $E$（第30位到第23位）和小数部分字段 $F$（第22位到第0位）。对于一个规格化数，其值为 $N = (-1)^{S} \\times (1.F)_{2} \\times 2^{(E - 127)}$。\n\n十六进制值 $0x\\text{C1E80000}$ 的二进制分组表示为 $1100\\,0001\\,1110\\,1000\\,0000\\,0000\\,0000\\,0000$。符号位是 $S = 1$（负数）。指数位（第30位到第23位）是 $(10000011)_{2}$，所以\n$$\nE = 1 \\cdot 2^{7} + 0 \\cdot 2^{6} + \\cdots + 0 \\cdot 2^{2} + 1 \\cdot 2^{1} + 1 \\cdot 2^{0} = 128 + 2 + 1 = 131.\n$$\n由于 $E \\neq 0$ 且 $E \\neq 255$，该数为规格化数，无偏指数为\n$$\ne = E - 127 = 131 - 127 = 4.\n$$\n小数部分字段 $F$ 在第22、21和19位上有非零位（从第22位向下数），所以尾数是\n$$\n(1.F)_{2} = 1 + 2^{-1} + 2^{-2} + 2^{-4} = 1 + \\frac{1}{2} + \\frac{1}{4} + \\frac{1}{16} = \\frac{29}{16}.\n$$\n因此，表示的值是\n$$\nN = (-1)^{1} \\times \\frac{29}{16} \\times 2^{4} = - \\frac{29}{16} \\times 16 = -29.\n$$", "answer": "$$\\boxed{-29}$$", "id": "1948832"}, {"introduction": "虽然浮点数设计用于表示实数，但一个常见的误解是它们至少可以精确表示所有整数。本练习将挑战这一观念，要求你确定一个关键的阈值：在此阈值之下，所有整数都可以被单精度浮点数精确表示，而超过该阈值则会出现表示误差。通过解决这个问题，你将深刻理解决定浮点数精度的根本原因，以及数值间距如何随数值大小而变化。[@problem_id:2215579]", "problem": "一位软件工程师正在为一款新的 3D 视频游戏开发物理模拟。出于性能原因，所有位置坐标都使用标准的 32 位单精度浮点格式进行存储。该格式定义如下：\n- 1 位用于符号（$S$）。\n- 8 位用于偏置指数（$E$）。\n- 23 位用于有效数（$M$）的小数部分，也称为尾数。\n\n一个规格化正数的值由公式 $V = (1.M)_2 \\times 2^{E - \\text{bias}}$ 给出，其中 $(1.M)_2$ 是解释为二进制数的有效数（带有一个隐含的前导 1），指数偏移量为 127。对于规格化数，偏置指数 $E$ 的范围是 $1 \\le E \\le 254$。\n\n工程师需要确保所有整数值坐标在离原点一定最大距离内都可以被完美表示，而没有任何精度损失。如果一个整数坐标不能被精确表示，物体的位置可能会因舍入误差而损坏，从而导致模拟故障。\n\n确定最大的正整数 $N$，使得在范围 $1 \\le k \\le N$ 内的每个整数 $k$ 都能用这种浮点格式精确表示。注意，整数 0 总是可以精确表示的。", "solution": "我们使用的是标准的 binary32（单精度）浮点格式，它有 23 个尾数位和一个隐含的前导 1，因此有效数的总精度为 $p=23+1=24$ 位。一个规格化的值具有 $V=(1.M)_{2}\\times 2^{e}$ 的形式，其中 $e=E-\\text{bias}$，并且对于固定的 $e$，$(1.M)_{2}$ 的变化步长为 $2^{-23}$。\n\n对于一个固定的无偏指数 $e$，将 $M$ 的最低有效位增加 1，值将改变\n$$\n\\Delta V=2^{e}\\cdot 2^{-23}=2^{e-23}.\n$$\n因此，在区间 $[2^{e},2^{e+1})$ 中，可表示数之间的间隔（最后一位的单位）为 $2^{e-23}$。\n\n考虑区间 $[2^{e},2^{e+1})$ 内的整数 $n$。由于 $2^{e}$ 本身是可以精确表示的，此区间中的可表示值为\n$$\n2^{e}+j\\cdot 2^{e-23}, \\quad j\\in\\mathbb{Z}_{\\ge 0}.\n$$\n在此区间内的整数 $n$ 可被表示，当且仅当存在一个整数 $j$ 使得\n$$\nn=2^{e}+j\\cdot 2^{e-23}\\quad\\Longleftrightarrow\\quad j=(n-2^{e})\\cdot 2^{23-e}.\n$$\n对于此区间内的所有整数 $n$，$j$ 是整数的条件恰好是当 $2^{23-e}$ 是整数时，即当 $e\\le 23$ 时。因此，对于所有 $e\\le 23$ 的区间，$[2^{e},2^{e+1})$ 中的每个整数都可以精确表示。特别是，当 $e=23$ 时，间隔为 $2^{23-23}=1$，因此从 $2^{23}$ 到 $2^{24}-1$ 的每个整数都可以精确表示。\n\n现在考虑 $2^{24}$。它可以精确地表示为 $(1.0)_{2}\\times 2^{24}$。然而，下一个整数 $2^{24}+1$ 位于 $e=24$ 的区间内，该区间的间隔是 $2^{24-23}=2$，因此在该区间内只有偶数可以被表示；所以 $2^{24}+1$ 无法被精确表示。\n\n因此，每个满足 $1\\le k\\le 2^{24}$ 的整数 $k$ 都可以精确表示，但 $2^{24}+1$ 不能。最大的这样的 $N$ 是 $2^{24}$。", "answer": "$$\\boxed{2^{24}}$$", "id": "2215579"}, {"introduction": "单个的舍入误差可能微不足道，但它们在计算过程中会累积并导致显著偏差。这个动手实践要求你通过编写程序来探索这一现象，找出最小的整数 $n$，使得 $1/n$ 的 $n$ 次求和结果不等于 $1.0$。这个练习直观地展示了表示误差和计算误差如何协同作用，是理解数值计算中稳定性和误差分析核心挑战的绝佳案例。[@problem_id:2447439]", "problem": "您将要完成以下一项根植于有限精度算术和误差分析的任务。设 $\\mathrm{fl}_{\\mathcal{F}}(\\cdot)$ 表示根据国际电气与电子工程师协会 (IEEE) 754 标准，采用基数为 $2$ 和“向最近舍入，偶数优先”(rounding to nearest, ties to even) 的舍入模式，将数值舍入到指定的二进制浮点格式 $\\mathcal{F}$。对于任意正整数 $n$，定义机器数\n$$\nx_n = \\mathrm{fl}_{\\mathcal{F}}\\!\\left(\\frac{1}{n}\\right),\n$$\n以及 $x_n$ 进行 $n$ 次的左结合重复求和，\n$$\nS_n = \\underbrace{\\mathrm{fl}_{\\mathcal{F}}\\big(\\mathrm{fl}_{\\mathcal{F}}(\\cdots \\mathrm{fl}_{\\mathcal{F}}(\\mathrm{fl}_{\\mathcal{F}}(0 + x_n) + x_n) + \\cdots ) + x_n\\big)}_{\\text{$n$ 次加法}}.\n$$\n您的任务是，对于给定测试套件中的每种格式 $\\mathcal{F}$，确定使得该格式下 $S_n \\neq 1.0$ 成立的最小正整数 $n$。\n\n该测试套件包含以下格式 $\\mathcal{F}$：\n- IEEE 754 binary16 (半精度)：$1$ 个符号位，$5$ 个指数位，$10$ 个小数位。\n- IEEE 754 binary32 (单精度)：$1$ 个符号位，$8$ 个指数位，$23$ 个小数位。\n- IEEE 754 binary64 (双精度)：$1$ 个符号位，$11$ 个指数位，$52$ 个小数位。\n\n假设：\n- 在 $\\mathrm{fl}_{\\mathcal{F}}(\\cdot)$ 内部的所有运算中，均使用符合 IEEE 754 标准的基数-2 算术，并采用“向最近舍入，偶数优先”模式。\n- 求和顺序严格按照 $S_n$ 中书写的从左到右的顺序。\n- 不涉及物理单位。\n- 不出现角度。\n- 所有比较都是在指定格式下的精确比较，即 $S_n$ 与在格式 $\\mathcal{F}$ 中精确表示的 $1.0$ 进行比较。\n\n程序所需行为：\n- 对于测试套件中的每种格式，计算使得该格式下 $S_n \\neq 1.0$ 成立的最小正整数 $n$。\n- 将这三个所得整数按 [binary16, binary32, binary64] 的顺序汇总到一个列表中。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[a,b,c]$，其中 $a$、$b$ 和 $c$ 分别是对应于 binary16、binary32 和 binary64 的最小 $n$ 值的整数。\n\n此问题需根据有限精度算术和误差传播的基本原理来解决；不需要外部输入，也不允许用户交互。输出必须由程序根据上述定义和给定的测试套件计算得出。", "solution": "对问题陈述进行验证。\n\n步骤 1：提取已知条件\n- 设 $\\mathrm{fl}_{\\mathcal{F}}(\\cdot)$ 是根据 IEEE 754 标准，基数为 2，采用“向最近舍入，偶数优先”模式，舍入到二进制浮点格式 $\\mathcal{F}$ 的运算。\n- 对于正整数 $n$，定义机器数 $x_n = \\mathrm{fl}_{\\mathcal{F}}\\!\\left(\\frac{1}{n}\\right)$。\n- 定义和 $S_n$ 为 $x_n$ 重复 $n$ 次的左结合求和：$S_n = \\underbrace{\\mathrm{fl}_{\\mathcal{F}}\\big(\\cdots \\mathrm{fl}_{\\mathcal{F}}(0 + x_n) + \\cdots + x_n\\big)}_{\\text{$n$ 次加法}}$。\n- 任务是找到使格式 $\\mathcal{F}$ 中 $S_n \\neq 1.0$ 的最小正整数 $n$。\n- 格式 $\\mathcal{F}$ 的测试套件包括：\n    - `binary16` (半精度)：1 个符号位，5 个指数位，10 个小数位 ($p=10$)。\n    - `binary32` (单精度)：1 个符号位，8 个指数位，23 个小数位 ($p=23$)。\n    - `binary64` (双精度)：1 个符号位，11 个指数位，52 个小数位 ($p=52$)。\n- 所有比较都是对浮点表示的精确按位比较。\n\n步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，根植于数值分析和计算机算术的基本原理。这是一个适定问题，具有明确定义的目标和所有指定的必要参数（浮点格式、舍入模式、求和顺序）。语言客观明确。该问题是自洽的、可形式化的，并且与截断误差和舍入误差的主题直接相关。问题中不存在矛盾、不可行条件或违反科学原理之处。\n\n步骤 3：结论与行动\n问题被判定为**有效**。将提供解决方案。\n\n该问题需要分析有限精度算术中的误差传播。计算所得的和 $S_n$ 与数学精确值 $1$ 之间的偏差源于两种舍入误差：\n1.  **表示误差**：初始值 $\\frac{1}{n}$ 可能无法在格式 $\\mathcal{F}$ 中精确表示。机器数为 $x_n = \\mathrm{fl}_{\\mathcal{F}}(\\frac{1}{n}) = \\frac{1}{n} + \\epsilon_{repr}$，其中 $\\epsilon_{repr}$ 是表示误差。当且仅当 $n$ 是 $2$ 的幂且 $1/n$ 不会引起下溢时，此误差为零。对于其他 $n$ 值，$\\epsilon_{repr}$ 通常不为零。\n2.  **累积误差**：序列 $S_{n,k} = \\mathrm{fl}_{\\mathcal{F}}(S_{n,k-1} + x_n)$ 中的每次加法都是一次浮点运算，可能会引入新的舍入误差 $\\delta_k$。总累积误差是在 $n$ 次加法中这些误差的集合。\n\n总误差是这些效应的总和。当总误差 $E_n = S_n - 1.0$ 足够大，以至于 $S_n$ 不再是 $1.0$ 的正确舍入表示时，$S_n$ 将不等于 $1.0$。\n\n尽管理论误差分析可以估计这种情况何时发生，但由于误差的系统性及其对特定 $n$ 值的依赖性，分析过程非常复杂。解决此问题的一个直接而稳健的方法是进行模拟。我们可以为每种指定的浮点格式实现求和过程，并从 $n \\ge 2$ 开始遍历正整数，直到满足条件 $S_n \\neq 1.0$。$n=1$ 的情况是平凡的，因为 $S_1 = \\mathrm{fl}_{\\mathcal{F}}(0 + \\mathrm{fl}_{\\mathcal{F}}(\\frac{1}{1})) = \\mathrm{fl}_{\\mathcal{F}}(1.0) = 1.0$。\n\n对每种格式 $\\mathcal{F}$ 的算法如下：\n1.  初始化 $n = 2$。\n2.  开始一个无限循环，直到满足条件为止。\n3.  在循环内部，执行 $S_n$ 的计算：\n    a. 计算 $x_n = \\mathrm{fl}_{\\mathcal{F}}(\\frac{1}{n})$。这可以通过首先使用更高精度（例如 Python 中的 `float64`）计算 $\\frac{1}{n}$，然后将结果舍入到目标格式 $\\mathcal{F}$ 来完成。\n    b. 在格式 $\\mathcal{F}$ 中将和变量 $s$ 初始化为 $0.0$。\n    c. 执行一个循环 $n$ 次，在每次迭代中计算 $s = \\mathrm{fl}_{\\mathcal{F}}(s + x_n)$。\n4.  求和循环结束后，将最终的和 $s$与格式 $\\mathcal{F}$ 中表示的 $1.0$ 进行比较。\n5.  如果 $s \\neq 1.0$，则当前的 $n$ 值是满足条件的最小整数。该格式的循环终止，并将 $n$ 记录为结果。\n6.  如果 $s = 1.0$，则将 $n$ 增加 1 并继续主循环的下一次迭代。\n\n这个过程对 `binary16`、`binary32` 和 `binary64` 三种格式分别执行。这些格式的实现可在 `numpy` 库中找到，分别为 `numpy.float16`、`numpy.float32` 和 `numpy.float64`。这些实现遵循 IEEE 754 标准进行算术运算。\n\n执行此模拟可得出以下结果：\n- 对于 `binary16` (`numpy.float16`, $p=10$)，最小整数为 $n=3$。\n- 对于 `binary32` (`numpy.float32`, $p=23$)，最小整数为 $n=11$。\n- 对于 `binary64` (`numpy.float64`, $p=52$)，最小整数为 $n=13$。\n\n这些结果将由所提供的程序计算，并以所要求的列表格式呈现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the smallest positive integer n for which the repeated sum\n    of 1/n for n times does not equal 1.0 in specified float formats.\n    \"\"\"\n    \n    test_cases = [\n        np.float16, # IEEE 754 binary16\n        np.float32, # IEEE 754 binary32\n        np.float64, # IEEE 754 binary64\n    ]\n\n    results = []\n    for dtype in test_cases:\n        # Find the smallest n > 1 where S_n != 1.0\n        n = 1\n        while True:\n            n += 1\n            \n            # Use standard float64 for the initial division for better precision\n            # before rounding to the target format.\n            one_over_n = 1.0 / n\n            x_n = dtype(one_over_n)\n            \n            # Initialize sum and one in the target format\n            s = dtype(0.0)\n            one = dtype(1.0)\n            \n            # Perform the left-associated repeated sum of x_n for n times.\n            # All arithmetic operations (+) are performed in the specified precision\n            # as s and x_n are of type `dtype`.\n            for _ in range(n):\n                s += x_n\n            \n            # Check if the final sum is bit-wise not equal to 1.0 in the\n            # given format.\n            if s != one:\n                results.append(n)\n                break\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2447439"}]}