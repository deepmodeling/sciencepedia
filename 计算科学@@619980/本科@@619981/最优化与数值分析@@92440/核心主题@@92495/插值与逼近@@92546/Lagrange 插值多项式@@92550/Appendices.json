{"hands_on_practices": [{"introduction": "掌握了拉格朗日插值多项式的理论之后，首要的实践技能便是从给定的数据点出发，构建出这个多项式。虽然拉格朗日基多项式提供了一种直接的表达形式，但将其转换为我们更熟悉的标准单项式形式（如 $ax^2 + bx + c$）是一项基础且重要的代数练习。这个练习将通过一个具体例子，帮助你巩固插值条件如何转化为一个线性方程组，并求解出多项式的系数。[@problem_id:2183505]", "problem": "一个函数 $f(x)$ 在三个点处的值为：$(x_0, f(x_0)) = (0, \\exp(-1))$，$(x_1, f(x_1)) = (1, 1)$，以及 $(x_2, f(x_2)) = (2, \\exp(1))$。构造一个二次拉格朗日插值多项式 $P_2(x)$，用这三个点来近似 $f(x)$。该多项式可以写成标准形式 $P_2(x) = ax^2 + bx + c$。求系数 $a$ 的精确值。常数 $e$ 是自然对数的底。", "solution": "令 $P_{2}(x)=ax^{2}+bx+c$ 对这三个点进行插值。施加插值条件：\n1) $P_{2}(0)=c=\\exp(-1)$。\n2) $P_{2}(1)=a+b+c=1$，因此 $a+b=1-\\exp(-1)$。\n3) $P_{2}(2)=4a+2b+c=\\exp(1)$，因此 $4a+2b=\\exp(1)-\\exp(-1)$。\n\n将 $a+b=1-\\exp(-1)$ 乘以 $2$ 得到 $2a+2b=2-2\\exp(-1)$。从 $4a+2b=\\exp(1)-\\exp(-1)$ 中减去此式：\n$$\n(4a+2b)-(2a+2b)=\\left[\\exp(1)-\\exp(-1)\\right]-\\left[2-2\\exp(-1)\\right],\n$$\n化简为\n$$\n2a=\\exp(1)-2+\\exp(-1).\n$$\n因此，\n$$\na=\\frac{1}{2}\\left(\\exp(1)-2+\\exp(-1)\\right)=\\frac{\\exp(1)+\\exp(-1)}{2}-1.\n$$", "answer": "$$\\boxed{\\frac{\\exp(1)+\\exp(-1)}{2}-1}$$", "id": "2183505"}, {"introduction": "从计算转向概念，这项练习将引导我们思考一个更深层次的问题：数据点本身的几何排列，如何决定其插值多项式的本质？我们知道，$n+1$ 个点唯一确定一个次数至多为 $n$ 的多项式，但如果这些点恰好排列在一条直线上，这个“次数至多为 $n$”的上限是否过于宽泛？通过这个思想实验，你将发现数据结构与多项式次数之间的深刻联系。[@problem_id:2183535]", "problem": "设有一组 $n+1$ 个不同的数据点 $(x_i, y_i)$，其中 $i=0, 1, \\dots, n$，$n$ 是一个大于或等于 2 的固定整数。已知所有这些点都完全共线，即它们位于一条由方程 $y = mx + c$ 描述的直线上，其中 $m$ 和 $c$ 是实数常数且 $m \\neq 0$。\n\n可以构建一个唯一的次数至多为 $n$ 的多项式 $P(x)$，该多项式穿过所有这 $n+1$ 个点。这个多项式被称为 Lagrange 插值多项式。\n\n下列哪个陈述正确地指出了 $P(x)$ 的确切次数？\n\nA. 次数总是 $n$。\nB. 次数总是 1。\nC. 次数总是 0。\nD. 次数可以是 1 到 $n$ 之间的任何整数，具体取决于 $x_i$ 值的分布。\nE. 次数总是 2。", "solution": "问题要求解对于一组 $n+1$ 个共线点（其中 $n \\geq 2$）的 Lagrange 插值多项式 $P(x)$ 的确切次数。\n\n根据多项式插值基本定理，对于任何一组 $n+1$ 个不同的点 $(x_i, y_i)$，存在一个唯一的次数至多为 $n$ 的多项式，它穿过每一个点。这个唯一的多项式就是 Lagrange 插值多项式 $P(x)$。\n\n给定的点 $(x_i, y_i)$ 是共线的，并且位于直线 $y = mx + c$ 上，约束条件是 $m \\neq 0$。这意味着对于该集合中的每一个点，其坐标都满足关系式 $y_i = mx_i + c$。\n\n让我们定义一个新的多项式 $Q(x) = mx + c$。\n首先，我们来确定 $Q(x)$ 的次数。由于它是一个线性方程形式的多项式，并且 $x$ 项的系数 $m$ 被明确指定为非零（$m \\neq 0$），所以 $Q(x)$ 的次数恰好是 1。\n\n接下来，我们检查这个多项式 $Q(x)$ 是否穿过所有给定的数据点。我们可以在每个 $x_i$ 坐标处计算 $Q(x)$ 的值：\n$$Q(x_i) = m x_i + c$$\n根据问题陈述，我们知道对于每个点，都有 $y_i = m x_i + c$。因此，我们有：\n$$Q(x_i) = y_i$$\n这对所有 $i = 0, 1, \\dots, n$ 都成立。这表明多项式 $Q(x)$ 是给定 $n+1$ 个点的插值多项式。\n\n我们现在找到了一个次数为 1 的多项式 $Q(x)$，它穿过所有 $n+1$ 个点。Lagrange 多项式 $P(x)$ 是用于此目的的、*唯一*的次数*至多*为 $n$ 的多项式。既然我们找到了这样一个多项式，并且其唯一性已由定理证明，那么 $P(x)$ 必然与 $Q(x)$ 相同。\n$$P(x) = Q(x) = mx + c$$\n因此，$P(x)$ 的次数就是 $mx+c$ 的次数。如前所述，由于 $m \\neq 0$，所以次数恰好是 1。这个结果与 $n$（当 $n \\geq 2$ 时）和点 $x_i$ 的具体位置无关。\n\n让我们分析一下给定的选项：\nA. 次数总是 $n$。对于不位于次数小于 $n$ 的多项式上的一般点集，情况确实如此。但在这里这是不正确的，因为这些点具有特殊的结构（共线性）。\nB. 次数总是 1。我们的推导表明这是正确的。拟合这些共线点的唯一多项式就是这条直线本身。\nC. 次数总是 0。如果 $m=0$，这将是正确的，因为直线将是 $y=c$，这是一个 0 次多项式。然而，问题指明了 $m \\neq 0$。\nD. 次数可以是 1 到 $n$ 之间的任何整数。这是不正确的；插值多项式的唯一性确保了只有一个特定的结果。\nE. 次数总是 2。这是不正确的。定义一个唯一的抛物线（2 次多项式）至少需要 3 个不共线的点。\n\n因此，Lagrange 插值多项式 $P(x)$ 的确切次数是 1。", "answer": "$$\\boxed{B}$$", "id": "2183535"}, {"introduction": "现在，让我们将理论与实际代码连接起来。借鉴前一个练习所揭示的原理——共线点集的插值多项式次数为1——本节的最终实践将挑战你设计一个稳健的算法。你的任务是利用插值多项式的次数来判断一组点是否共线，这是计算机图形学和数据分析中的一个常见任务。这个练习不仅仅是理论的应用，更要求你考虑现实世界中的计算复杂性，如浮点数精度和垂直线等边界情况。[@problem_id:2425948]", "problem": "给定$n \\ge 1$的有限平面点集$\\{(x_i,y_i)\\}_{i=0}^{n}$。当且仅当存在一条包含所有点的直线时，该点集是共线的。直线可以表示为 $y = ax + b$（对于某些实数 $a$ 和 $b$，非垂直线），或者表示为 $x = c$（对于某个实数 $c$，垂直线）。您的任务是设计并实现一个程序，该程序通过检查在拉格朗日形式下为非垂直情况构建的唯一插值多项式的次数，并结合逻辑上必要的预先检查来正确处理垂直情况，从而确定点的共线性。\n\n使用的基本原理：\n- 多项式次数的定义为$x$的非零系数的最高指数。\n- 对于不同的横坐标$x_0,\\dots,x_n$，存在一个次数至多为 $n$ 的唯一多项式 $p(x)$ 对数据 $(x_i,y_i)$ 进行插值，并且任何这样的多项式都恰好在 $n+1$ 个插值节点处与数据重合。\n- 平面点的共线性定义为位于同一直线上。\n\n算法的设计要求：\n- 如果所有 $x$ 坐标在数值容差 $\\tau$ 内相等，则判断点集在一条垂直线上共线并返回 $\\mathrm{True}$。\n- 如果存在两个点具有相同的 $x$ 坐标但不同的 $y$ 坐标（差异大于 $\\tau$），而并非所有 $x$ 坐标都在 $\\tau$ 内相等，则判断该点集不可能位于任何单一直线上并返回 $\\mathrm{False}$。\n- 否则，移除完全重复的点，确保剩余的插值节点具有不同的 $x$ 坐标，为$y$作为$x$的函数构建拉格朗日插值多项式 $p(x)$，将其转换为单项式系数，通过将绝对值 $\\le \\tau$ 的任何系数视为零来确定其有效次数，并且当且仅当有效次数至多为 $1$ 时，声明该点集共线。\n- 对于所有的零值测试和垂直线检查，使用固定的容差 $\\tau = 10^{-10}$，并使用实数运算处理所有计算。程序不得假设除此处所述之外的任何特殊结构。\n- 如果唯一点的数量（移除重复点后）至多为 $2$，则返回 $\\mathrm{True}$，因为任意两点都是共线的。\n\n您的程序的输入由直接嵌入源代码中的以下测试套件固定。对于每个案例，将每对 $(x,y)$ 解释为使用无量纲单位。\n- 案例 $\\#1$（非垂直，线性）：$\\{(-1, -1), (0, 1), (2, 5)\\}$。\n- 案例 $\\#2$（非垂直，非线性）：$\\{(0, 0), (1, 1), (2, 2.1)\\}$。\n- 案例 $\\#3$（垂直线）：$\\{(3, 0), (3, 5), (3, -2)\\}$。\n- 案例 $\\#4$（包含重复点，线性）：$\\{(1, 2), (1, 2), (2, 4), (3, 6)\\}$。\n- 案例 $\\#5$（存在 $x$ 相同但 $y$ 不同的点，且存在其他不同 $x$ 的点）：$\\{(1, 2), (1, 3), (2, 4)\\}$。\n- 案例 $\\#6$（恰好两个点）：$\\{(-100, 50), (200, -250)\\}$。\n- 案例 $\\#7$（近似线性，但有远低于容差的微小扰动）：$\\{(0, 1), (1, 0.5), (2, 0), (3, -0.5 + 10^{-12})\\}$。\n\n输出规范：\n- 您的程序应生成一行输出，其中包含一个逗号分隔并用方括号括起的列表，结果顺序与上述测试案例相同。每个结果必须是布尔值 $\\mathrm{True}$ 或 $\\mathrm{False}$，不含空格。例如，格式必须类似于 $[r_A,r_B,r_C]$。\n\n限制与说明：\n- 仅使用实数运算，并按规定使用固定容差 $\\tau = 10^{-10}$ 进行系数修剪和相等性检查。\n- 实现必须是自包含的，不要求任何输入。输出必须从硬编码的测试套件中计算得出。", "solution": "该问题旨在确定给定的一组 $n+1$ 个平面点 $\\{(x_i, y_i)\\}_{i=0}^{n}$（其中 $n \\ge 1$）是否共线。共线性要求所有点必须位于同一条直线上，该直线可以是非垂直的（形式为 $y = ax + b$）或垂直的（形式为 $x = c$）。规定的方法是使用多项式插值，其原理是：一组点位于一条非垂直线上，当且仅当通过它们的唯一插值多项式的次数至多为 $1$。此方法必须辅以处理数值精度和垂直线特殊情况的逻辑。该问题是良态的且科学上合理的，因此我们着手设计一个严谨的算法。\n\n算法流程按一系列逻辑步骤构建，旨在系统地处理所有情况和数值偏差。所有浮点数比较均使用数值容差 $\\tau = 10^{-10}$。\n\n首先，必须对输入数据进行清理。给定的是一组可能包含重复项的点。任意两点确定一条直线，因此如果唯一点的数量小于或等于 $2$，则该点集是平凡共线的。我们首先将输入简化为唯一点的集合。设此集合为 $S$。如果 $|S| \\le 2$，我们判定这些点共线并终止。\n\n其次，我们必须处理垂直线的情况。垂直线由方程 $x=c$（其中 $c$ 为某个常数）描述。这不是 $y=f(x)$ 形式的函数，因此不能用关于 $x$ 的标准多项式表示。通过检查唯一集合 $S$ 中所有点的 $x$ 坐标是否在容差 $\\tau$ 内相同，可以识别这种情况。令 $X = \\{x | (x, y) \\in S\\}$。如果 $\\max(X) - \\min(X) \\le \\tau$，则所有点都位于一条垂直线上，我们判定它们共线。\n\n第三，对于非垂直情况，这些点必须能表示一个单值函数。也就是说，对于 $S$ 中的任意两点 $(x_i, y_i)$ 和 $(x_j, y_j)$，如果 $x_i$ 与 $x_j$ 在数值上不可区分，则 $y_i$ 也必须与 $y_j$ 在数值上不可区分。如果我们发现两点满足 $|x_i - x_j| \\le \\tau$ 但 $|y_i - y_j| > \\tau$，则没有任何函数 $y=f(x)$ 能同时通过这两点。由于垂直线的情况已被排除，因此没有单一直线能包含这些点。因此，我们必须检查此条件，如果满足，则判定这些点不共线。此步骤也有助于为插值准备数据。我们可以将 $x$ 坐标在 $\\tau$ 范围内的点分组。如果任何这样的组的 $y$ 坐标分布范围大于 $\\tau$，我们就找到了一个矛盾。否则，我们可以用一个代表点（例如，通过对组内坐标求平均值）来替换每个组。此过程产生一个新的点集 $S'$，其中所有 $x$ 坐标都是不同的（相差大于 $\\tau$）。如果在合并后，点的数量 $|S'| \\le 2$，则该点集再次被视为平凡共线。\n\n第四，对于一个清理过的、具有不同横坐标的 $N+1$ 个点的集合 $S' = \\{(x'_j, y'_j)\\}_{j=0}^{N}$ （其中 $N+1 = |S'| > 2$），我们可以应用多项式插值基本定理。存在一个次数至多为 $N$ 的唯一多项式 $p(x)$，使得对所有 $j \\in \\{0, \\dots, N\\}$ 都有 $p(x'_j) = y'_j$。该多项式可以以拉格朗日形式构建：\n$$\np(x) = \\sum_{j=0}^{N} y'_j L_j(x), \\quad \\text{其中} \\quad L_j(x) = \\prod_{k=0, k \\ne j}^{N} \\frac{x - x'_k}{x'_j - x'_k}\n$$\n这些点共线的充要条件是它们位于一条直线 $y = ax+b$ 上，这是一个次数为 $1$ 的多项式（如果 $a=0$，则次数为 $0$）。因此，共线条件等价于唯一插值多项式 $p(x)$ 的次数至多为 $1$。\n\n为了确定次数，我们必须将 $p(x)$ 转换为其单项式表示，$p(x) = \\sum_{k=0}^{N} c_k x^k$。在用浮点数进行实际计算时，理论上为零的系数可能会显示为非常小的非零值。因此，我们必须确定多项式的“有效次数”。有效次数定义为对应系数的绝对值 $|c_k|$ 大于容差 $\\tau$ 的最大整数 $k$。如果对于 $k > 1$ 的所有系数 $c_k$ 都满足 $|c_k| \\le \\tau$，则有效次数至多为 $1$，我们判定这些点共线。否则，这些点不共线。如果所有系数都满足 $|c_k| \\le \\tau$，则有效次数被认为小于或等于 $1$，这些点共线（表示一条接近 $y=0$ 的水平线）。至此，算法完成。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import lagrange\n\ndef solve():\n    \"\"\"\n    Solves the collinearity problem for a predefined suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case #1 (non-vertical, linear)\n        [(-1, -1), (0, 1), (2, 5)],\n        # Case #2 (non-vertical, non-linear)\n        [(0, 0), (1, 1), (2, 2.1)],\n        # Case #3 (vertical line)\n        [(3, 0), (3, 5), (3, -2)],\n        # Case #4 (duplicates included, linear)\n        [(1, 2), (1, 2), (2, 4), (3, 6)],\n        # Case #5 (conflicting equal x with different y and a different x present)\n        [(1, 2), (1, 3), (2, 4)],\n        # Case #6 (exactly two points)\n        [(-100, 50), (200, -250)],\n        # Case #7 (near-linear with tiny perturbation well below tolerance)\n        [(0, 1), (1, 0.5), (2, 0), (3, -0.5 + 1e-12)],\n    ]\n\n    tolerance = 1e-10\n    \n    results = []\n    for points in test_cases:\n        result = is_collinear(points, tolerance)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef is_collinear(points, tau):\n    \"\"\"\n    Determines if a set of points is collinear based on the degree of the\n    interpolating polynomial and special case checks.\n\n    Args:\n        points (list of tuples): A list of (x, y) coordinates.\n        tau (float): The numerical tolerance for floating-point comparisons.\n\n    Returns:\n        bool: True if the points are collinear, False otherwise.\n    \"\"\"\n    # 1. Remove exact duplicates and handle trivial cases.\n    unique_points = sorted(list(set(points)))\n    if len(unique_points) <= 2:\n        return True\n\n    x_coords = np.array([p[0] for p in unique_points])\n    y_coords = np.array([p[1] for p in unique_points])\n\n    # 2. Check for vertical line.\n    # np.ptp (peak-to-peak) is equivalent to max(arr) - min(arr)\n    if np.ptp(x_coords) <= tau:\n        return True\n\n    # 3. Consolidate points with close x-coordinates and check for function validity.\n    # This step ensures that for each x, there is a unique y (within tolerance)\n    # and prepares a set of nodes with distinct x for interpolation.\n    consolidated_points = []\n    \n    # The unique_points are already sorted by x-coordinate (default tuple sort).\n    # We group points with numerically equal x-coordinates.\n    i = 0\n    while i < len(unique_points):\n        # Start a new group\n        group_indices = [i]\n        j = i + 1\n        while j < len(unique_points) and abs(unique_points[j][0] - unique_points[i][0]) <= tau:\n            group_indices.append(j)\n            j += 1\n        \n        # Process the group\n        group_y = y_coords[group_indices]\n        if np.ptp(group_y) > tau:\n            # Contradiction: same x, different y. Not a function.\n            return False\n        \n        # The group is valid, consolidate into a single point by averaging.\n        group_x = x_coords[group_indices]\n        avg_x = np.mean(group_x)\n        avg_y = np.mean(group_y)\n        consolidated_points.append((avg_x, avg_y))\n        \n        i = j # Move to the start of the next group\n\n    if len(consolidated_points) <= 2:\n        return True\n\n    # 4. Perform Lagrange interpolation and check the degree.\n    x_final = np.array([p[0] for p in consolidated_points])\n    y_final = np.array([p[1] for p in consolidated_points])\n    \n    # Construct the unique interpolating polynomial.\n    poly = lagrange(x_final, y_final)\n    \n    # 5. Determine the effective degree.\n    effective_degree = 0\n    # a_n is the coefficient of the highest power\n    coeffs = poly.coeffs\n    for i, coeff in enumerate(coeffs):\n        if abs(coeff) > tau:\n            # Degree is (number of coeffs - 1) for the first element,\n            # and decreases with index.\n            effective_degree = len(coeffs) - 1 - i\n            break\n    \n    return effective_degree <= 1\n\n# Execute the solution\nsolve()\n```", "id": "2425948"}]}