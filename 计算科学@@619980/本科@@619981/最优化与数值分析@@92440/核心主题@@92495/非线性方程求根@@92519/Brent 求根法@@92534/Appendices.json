{"hands_on_practices": [{"introduction": "理论知识的真正掌握在于实践。这个练习旨在引导你亲手执行 Brent 方法的完整迭代，从而深入理解其内部的决策逻辑。通过求解贝塞尔函数 $J_0(x)$ 的根，你将体验到该方法如何巧妙地在快速的插值法和稳健的二分法之间进行选择，这是掌握 Brent 方法核心机制的关键一步 [@problem_id:2157795]。", "problem": "布伦特方法是一种流行的求根算法，它结合了二分法、割线法和逆二次插值法。考虑函数 $f(x) = J_0(x)$，其中 $J_0(x)$ 是零阶第一类贝塞尔函数。我们想要找到该函数的第一个正根。\n\n给定根的初始包围区间为 $[a_0, b_0] = [2.0, 3.0]$。您的任务是应用布伦特方法进行两次完整迭代，以找到根的一个更精确的估计值。\n\n您必须遵循的方法逻辑如下：\n1.  在每一步中，对于当前包围区间 $[a, b]$ 和第三个点 $c$（$b$ 的前一个值），首先尝试使用点 $(a, f(a))$、$(b, f(b))$ 和 $(c, f(c))$ 进行逆二次插值，以找到一个新的估计值 $s$。这仅在 $f(a)$、$f(b)$ 和 $f(c)$ 互不相同时才可能。\n2.  如果逆二次插值不可行或其结果不被接受，则回退到使用点 $(a, f(a))$ 和 $(b, f(b))$ 的割线法来找到估计值 $s$。\n3.  来自插值法或割线法的新估计值 $s$ 仅在它位于 $\\frac{3a+b}{4}$ 和 $b$ 之间时才被接受。\n4.  如果估计值 $s$ 不被接受，则改用二分法，其中新的估计值是中点 $s = \\frac{a+b}{2}$。\n5.  在找到新的估计值 $s$ 后，根据函数值的符号为下一次迭代更新区间 $[a, b]$ 和点 $c$。新的区间必须始终包围根。\n\n为了进行计算，请使用以下预先计算的函数值：\n- $J_0(2.0) = 0.22389$\n- $J_0(3.0) = -0.26005$\n- $J_0(2.46264) = -0.02495$\n- $J_0(2.41146) = -0.00282$\n\n计算该方法完成两次完整迭代后的最佳根估计值。最佳估计值是最终包围区间的端点，其函数值更接近于零。报告您的最终答案，四舍五入到四位有效数字。", "solution": "我们严格按照规定应用布伦特方法，仅使用提供的函数值。\n\n设 $f(x)=J_{0}(x)$。初始时，$a_{0}=2.0$， $b_{0}=3.0$，且 $f(a_{0})=0.22389>0$ 和 $f(b_{0})=-0.26005<0$，因此区间 $[a_{0},b_{0}]$ 包围一个根。对于第一次迭代，我们取 $c_{0}=a_{0}$（因此逆二次插值不可行，因为 $a_{0}=c_{0}$）。\n\n迭代 1：\n- 由于逆二次插值不可行，使用点 $(a_{0},f(a_{0}))$ 和 $(b_{0},f(b_{0}))$ 的割线法：\n$$\ns_{1}\n= b_{0} - f(b_{0})\\frac{b_{0}-a_{0}}{f(b_{0})-f(a_{0})}\n= 3.0 - \\left(-0.26005\\right)\\frac{3.0-2.0}{-0.26005-0.22389}.\n$$\n计算分母 $f(b_{0})-f(a_{0})=-0.48394$，因此\n$$\ns_{1}=3.0 - \\frac{-0.26005}{-0.48394}=3.0-0.53736=2.46264.\n$$\n- 接受性检查：$s_{1}$ 必须满足 $\\frac{3a_{0}+b_{0}}{4} \\leq s_{1} \\leq b_{0}$。此处，$\\frac{3\\cdot 2.0 + 3.0}{4}=2.25$，并且 $2.25 \\leq 2.46264 \\leq 3.0$，因此 $s_{1}$ 被接受。\n- 使用符号更新包围区间：$f(a_{0})\\cdot f(s_{1})=0.22389\\cdot(-0.02495)<0$，因此新的包围区间是 $[a_{1},b_{1}]=[a_{0},s_{1}]=[2.0,2.46264]$。设置 $c_{1}=b_{0}=3.0$。将使用提供的值 $f(b_{1})=f(2.46264)=-0.02495$。\n\n迭代 2：\n- 尝试使用点 $(a_{1},f(a_{1}))=(2.0,0.22389)$、$(b_{1},f(b_{1}))=(2.46264,-0.02495)$ 和 $(c_{1},f(c_{1}))=(3.0,-0.26005)$ 进行逆二次插值，这些点的函数值互不相同。使用逆二次插值（将 $x$ 插值为 $y=f(x)$ 的二次函数，并在 $y=0$ 处求值），公式为\n$$\ns_{2}\n= x_{0}\\frac{f_{1}f_{2}}{(f_{0}-f_{1})(f_{0}-f_{2})}\n+ x_{1}\\frac{f_{0}f_{2}}{(f_{1}-f_{0})(f_{1}-f_{2})}\n+ x_{2}\\frac{f_{0}f_{1}}{(f_{2}-f_{0})(f_{2}-f_{1})},\n$$\n其中 $(x_{0},f_{0})=(2.0,0.22389)$，$(x_{1},f_{1})=(2.46264,-0.02495)$，$(x_{2},f_{2})=(3.0,-0.26005)$。\n使用所提供的值（以及与之一致的算术运算），得到\n$$\ns_{2}=2.41146.\n$$\n- 接受性检查：$s_{2}$ 必须满足 $\\frac{3a_{1}+b_{1}}{4} \\leq s_{2} \\leq b_{1}$。此处，$\\frac{3\\cdot 2.0 + 2.46264}{4}=\\frac{8.46264}{4}=2.11566$，并且 $2.11566 \\leq 2.41146 \\leq 2.46264$，因此 $s_{2}$ 被接受。\n- 使用符号更新包围区间：$f(a_{1})\\cdot f(s_{2})=0.22389\\cdot(-0.00282)<0$，因此新的包围区间是 $[a_{2},b_{2}]=[a_{1},s_{2}]=[2.0,2.41146]$。将使用提供的值 $f(b_{2})=f(2.41146)=-0.00282$。\n\n经过两次完整迭代后，最终的包围区间是 $[2.0,2.41146]$，其函数值为 $f(2.0)=0.22389$ 和 $f(2.41146)=-0.00282$。最佳估计值是其函数值更接近于零的端点，即 $b_{2}=2.41146$。四舍五入到四位有效数字得到 $2.411$。", "answer": "$$\\boxed{2.411}$$", "id": "2157795"}, {"introduction": "Brent 方法的强大之处不仅在于其速度，更在于其稳健性。这个练习通过一个特殊的函数 $f(x) = \\text{sign}(x-2) \\sqrt{|x-2|}$ 来让你思考一个问题：当函数在根附近不“平滑”时会发生什么？通过分析为什么插值步骤在这种情况下会表现不佳，你将深刻理解 Brent 方法中二分法作为“安全网”的必要性和智慧所在 [@problem_id:2157793]。", "problem": "Brent方法是一种流行的求根算法，它结合了二分法的可靠性与基于插值的方法（即割线法和逆二次插值）的速度。该算法在可能的情况下会尝试使用更快的插值方法，但如果插值步骤不理想，它会退回到二分法。\n\n考虑函数 $f(x) = \\text{sign}(x-2) \\sqrt{|x-2|}$，它在 $x=2$ 处有一个根。当应用Brent方法寻找该根时，可以观察到基于插值的步骤表现不佳，导致算法严重依赖二分法后备方案，从而收敛速度远慢于预期。\n\n对于这个特定函数在其根附近的情况，以下哪个陈述为基于插值的步骤（割线法和逆二次插值）表现不佳提供了最准确的数学原因？\n\nA. 函数在根 $x=2$ 处不连续。\n\nB. 函数相对于根具有奇对称性，即 $f(2+h) = -f(2-h)$，这迫使算法采取对称但缓慢的步骤。\n\nC. 函数的一阶导数在根处无定义，当 $x$ 趋近于根时，其值趋于无穷大。\n\nD. 函数的二阶导数在根处为零，表明存在一个拐点，该拐点减慢了收敛速度。\n\nE. 算法失败是因为它只能应用于多项式，但该函数包含平方根项。", "solution": "目标是理解为什么Brent方法的基于插值的组成部分（割线法和逆二次插值）对于函数 $f(x) = \\text{sign}(x-2) \\sqrt{|x-2|}$ 在其根 $x=2$ 附近表现不佳。\n\n首先，我们来分析函数 $f(x)$。该函数是使用符号函数和绝对值定义的。我们可以将其表示为分段形式，以便更好地理解它在根 $x=2$ 附近的行为。\n- 如果 $x > 2$，则 $x-2 > 0$，所以 $\\text{sign}(x-2) = 1$ 且 $|x-2| = x-2$。因此，$f(x) = \\sqrt{x-2}$。\n- 如果 $x < 2$，则 $x-2 < 0$，所以 $\\text{sign}(x-2) = -1$ 且 $|x-2| = -(x-2) = 2-x$。因此，$f(x) = -\\sqrt{2-x}$。\n- 如果 $x = 2$，则 $f(2) = \\text{sign}(0)\\sqrt{0} = 0 \\times 0 = 0$。\n\nBrent算法中使用的插值方法，即割线法和逆二次插值，之所以能实现快速收敛，是基于函数局部光滑且可以被低阶多项式（割线法对应直线，逆二次插值对应二次多项式）很好地近似这一假设。这种光滑性的一个关键指标是函数在根附近的导数行为。\n\n让我们计算当 $x \\neq 2$ 时的一阶导数 $f'(x)$。\n- 对于 $x > 2$，$f'(x) = \\frac{d}{dx}(\\sqrt{x-2}) = \\frac{d}{dx}((x-2)^{1/2}) = \\frac{1}{2}(x-2)^{-1/2} = \\frac{1}{2\\sqrt{x-2}}$。\n- 对于 $x < 2$，$f'(x) = \\frac{d}{dx}(-\\sqrt{2-x}) = -\\frac{1}{2}(2-x)^{-1/2}(-1) = \\frac{1}{2\\sqrt{2-x}}$。\n\n现在，我们研究当 $x$ 趋近于根 $2$ 时导数的极限。\n- 当 $x \\to 2$ 从右侧（$x \\to 2^+$）时，分母 $2\\sqrt{x-2} \\to 0^+$。因此，$\\lim_{x\\to 2^+} f'(x) = +\\infty$。\n- 当 $x \\to 2$ 从左侧（$x \\to 2^-$）时，分母 $2\\sqrt{2-x} \\to 0^+$。因此，$\\lim_{x\\to 2^-} f'(x) = +\\infty$。\n\n由于导数的极限从两侧都趋于无穷大，导数 $f'(2)$ 是无定义的。从几何上看，这意味着函数在其根 $x=2$ 处有一条垂直切线。\n\n这条垂直切线是插值方法失效的主要原因：\n1.  **割线法：** 该方法用连接两点 $(x_n, f(x_n))$ 和 $(x_{n-1}, f(x_{n-1}))$ 的割线来近似函数。当这些点接近根 $x=2$ 时，函数图像几乎是垂直的。割线也几乎是垂直的，其与x轴的交点（下一个根的估计值）可能对点的微小变化高度敏感，导致不准确或不稳定的步骤。局部线性的基本假设被违反了。\n2.  **逆二次插值（IQI）：** 该方法用一个二次多项式来拟合*反函数* $x = f^{-1}(y)$。如果原函数 $f(x)$ 在根处的导数为无穷大，那么反函数在该点的导数将为零。反函数的导数为 $(f^{-1})'(y) = 1/f'(x)$。当 $x \\to 2$ 时，$f'(x) \\to \\infty$，所以 $(f^{-1})'(0) = 0$。我们再来看反函数的二阶导数。反函数是 $x = 2+y|y|$。它的一阶导数是 $x'(y) = 2|y|$，二阶导数是 $x''(y) = 2 \\text{sign}(y)$，在 $y=0$ 处有一个跳跃间断点。一个二阶导数不连续的函数在该点附近无法被单个二次多项式很好地近似。\n\n由于两种插值方案都未能产生可靠且快速收敛的估计值，Brent方法的逻辑将反复拒绝它们的输出，并退回到有保证但缓慢的二分法。\n\n现在我们来评估给定的选项：\nA. 函数在根 $x=2$ 处不连续。这是错误的。如上所示，$\\lim_{x\\to 2} f(x) = 0 = f(2)$，所以函数是连续的。\nB. 函数相对于根具有奇对称性。这个陈述是正确的，因为 $f(2+h) = \\text{sign}(h)\\sqrt{|h|}$ 并且 $-f(2-h) = -(\\text{sign}(-h)\\sqrt{|-h|}) = -(-\\text{sign}(h)\\sqrt{|h|}) = \\text{sign}(h)\\sqrt{|h|}$。然而，这不是性能不佳的原因。例如，$g(x) = x-2$ 也具有这种对称性，而Brent方法对其完全有效。\nC. 函数的一阶导数在根处无定义，当 $x$ 趋近于根时，其值趋于无穷大。这是正确的，正如我们的计算所示。这个无穷大的导数（垂直切线）违反了插值方法所依赖的光滑性假设，导致它们表现不佳。这是正确的解释。\nD. 函数的二阶导数在根处为零。这是错误的。一阶导数在根处甚至没有定义，所以二阶导数也不可能存在。此外，对于 $x>2$，$f''(x) = -\\frac{1}{4}(x-2)^{-3/2}$，当 $x \\to 2^+$ 时，其值趋于 $-\\infty$。\nE. 算法失败是因为它只能应用于多项式。这是错误的。Brent方法是一种通用的求根器，适用于广泛的连续函数。\n\n因此，导致性能不佳的最准确原因是根处的导数为无穷大。", "answer": "$$\\boxed{C}$$", "id": "2157793"}, {"introduction": "任何数值算法都建立在特定的数学假设之上，Brent 方法也不例外。这个思想实验将挑战一个核心假设：函数的连续性。通过考察一个在区间内包含垂直渐近线的函数，即使初始区间满足 $f(a)f(b) < 0$ 的条件，算法的行为也会出乎意料，它不会找到根，而是会收敛到奇点。这个练习有助于培养批判性思维，让你明白在应用算法时审视其前提条件的重要性 [@problem_id:2157800]。", "problem": "考虑函数 $f(x) = \\frac{1}{x - \\pi}$，其初始包围区间为 $[a_0, b_0] = [3, 4]$。一个计算机程序实现了 Brent 方法，从给定的包围区间开始，寻找该区间内函数 $f(x)$ 的一个根。该实现使用标准的双精度浮点运算，并遵循 Brent 方法的典型逻辑，该逻辑结合了二分法、割线法和反二次插值法。该方法的终止条件是包围区间的宽度小于一个预定义的公差。\n\n已知初始区间满足条件 $f(a_0) f(b_0) < 0$，以下哪个陈述最准确地描述了该算法的行为和结果？\n\nA. 算法将收敛到函数 $f(x)$ 的真实根。\n\nB. 算法将迅速确定在区间 $[3, 4]$ 内不存在根，并正常终止，报告这一事实。\n\nC. 算法生成的迭代序列将收敛于 $x=\\pi$，程序最终将因除零或浮点溢出等运行时错误而终止。\n\nD. 算法将进入一个无限循环，其中包围区间 $[a_k, b_k]$ 无法缩小，因为来自割线法和反二次插值的提议点总是被拒绝。\n\nE. 算法将收敛到其中一个端点，即 $x=3$ 或 $x=4$，因为函数的值在距离垂直渐近线最远的点处最小化。", "solution": "我们分析 Brent 方法应用于区间 $[3,4]$ 上的函数 $f(x) = \\frac{1}{x - \\pi}$ 时的行为。\n\n1) $f$ 的基本性质：\n- 该函数对所有 $x \\in \\mathbb{R}$ 且 $x \\neq \\pi$ 有定义，并在 $x=\\pi$ 处有一个简单极点（垂直渐近线）。\n- $f$ 没有实数零点，因为 $\\frac{1}{x-\\pi} = 0$ 无解。\n- 在 $[3,4]$ 上，我们有 $3 < \\pi < 4$，因此 $f(3) < 0$ 且 $f(4) > 0$。所以 $f(3) f(4) < 0$，但符号变化是由于 $x=\\pi$ 处的不连续性造成的，而不是因为一个零点。\n\n2) Brent 方法的假设和不变量：\n- Brent 方法要求初始包围区间 $[a_{0}, b_{0}]$ 满足 $f(a_{0}) f(b_{0}) < 0$，并隐含地利用 $f$ 在该区间上的连续性，通过介值定理来保证根的存在。在这里，连续性在 $x=\\pi$ 处不成立。\n- 尽管如此，算法仍维持包围不变量 $f(a_{k}) f(b_{k}) < 0$。因为 $f$ 在 $x=\\pi$ 两侧变号，并且在每一侧都连续，但在渐近线处不连续，所以该不变量意味着对所有 $k$ 都有 $a_{k} < \\pi < b_{k}$。\n\n3) Brent 方法中的二分法行为：\n- 令 $m_{k} = \\frac{a_{k} + b_{k}}{2}$。则\n$$\nf(m_{k}) = \\frac{1}{m_{k} - \\pi}.\n$$\n- $f(m_{k})$ 的符号与 $m_{k} - \\pi$ 的符号相同。因此：\n  - 若 $m_{k} < \\pi$，则 $f(m_{k}) < 0$，新的包围区间变为 $[m_{k}, b_{k}]$。\n  - 若 $m_{k} > \\pi$，则 $f(m_{k}) > 0$，新的包围区间变为 $[a_{k}, m_{k}]$。\n- 因此，每当采取二分步骤时，包围区间都会严格缩小并继续跨越 $\\pi$：\n$$\na_{k} \\uparrow \\pi, \\quad b_{k} \\downarrow \\pi.\n$$\n\n4) Brent 方法中的割线法和反二次插值法：\n- 割线法和反二次插值法提出的点，当被 Brent 方法的保障措施接受时，位于 $(a_{k}, b_{k})$ 内；因此它们在 $\\pi$ 的一侧。它们的函数值保持有限，除非该提议点在浮点运算中等于 $\\pi$，在这种情况下 $f$ 未定义，并发生浮点除零错误。\n- 如果一个提议点不可接受（例如，位于区间之外或违反了 Brent 的接受标准），Brent 方法会退回到二分法，这保证了包围区间的缩小。\n\n5) 收敛与终止：\n- 因为区间总是跨越 $x=\\pi$ 并且该方法保证（至少通过二分法）区间会缩小，我们有\n$$\n\\lim_{k \\to \\infty} a_{k} = \\pi^{-}, \\qquad \\lim_{k \\to \\infty} b_{k} = \\pi^{+}.\n$$\n- 如前所述，该方法的终止条件是基于宽度 $|b_{k} - a_{k}|$ 小于一个预设的公差。因此，算法将驱使迭代点趋向 $x=\\pi$，并尝试在越来越接近 $\\pi$ 的点上计算 $f$ 的值。\n- 由于当 $x \\to \\pi$ 时 $|f(x)| = \\left|\\frac{1}{x - \\pi}\\right| \\to \\infty$，$f$ 的数值计算结果会变得极大。在标准的双精度运算中，原则上可能出现两种失败模式：\n  - 如果一个迭代点等于 $\\pi$ 的浮点表示，则会发生除零错误。\n  - 如果 $|x - \\pi|$ 变得足够小，以至于 $\\left|\\frac{1}{x - \\pi}\\right|$ 超过了可表示的最大有限数，则会发生浮点溢出。\n- 无论在满足公差标准之前是否实际触发了异常，其基本行为是迭代点收敛于 $x=\\pi$，而不是一个根（根不存在）。算法不会“检测”到根的缺失，因为它被极点引起的符号变化误导，而不是被真正的穿零点误导。\n\n6) 排除选项：\n- A 是错误的：不存在根，因此不可能收敛到真实根。\n- B 是错误的：因为 $f(a_{0}) f(b_{0}) < 0$，该方法根据连续性假设存在一个根，并且不会“迅速”检测到根的缺失。\n- D 是错误的：Brent 的二分法保障措施确保了包围区间的缩小；不会发生固定宽度区间的无限循环。\n- E 是错误的：该方法不会收敛到端点；它围绕 $\\pi$ 缩小区间。\n- C 正确地描述了迭代点收敛于 $x=\\pi$ 并且在极点附近的数值计算可能导致计算失败（如除零或溢出）。在给定的选项中，这是对该行为最准确的描述。", "answer": "$$\\boxed{C}$$", "id": "2157800"}]}