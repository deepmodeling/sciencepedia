{"hands_on_practices": [{"introduction": "要真正理解一个算法，没有什么比亲手追踪其执行步骤更好的方法了。第一个练习就邀请你对一个简化的自适应求积方法进行手动模拟。通过为简单函数计算积分，你将对所有自适应方法核心的递归决策过程——近似、误差估计和加密——建立起具体而深刻的理解。[@problem_id:2153105]", "problem": "自适应求积算法通过细化其计算网格来满足期望的误差容限。考虑以下为近似计算定积分 $I = \\int_a^b f(x) \\,dx$ 而设计的递归算法。\n\n**自适应积分算法：**\n函数 `AdaptiveIntegrate(f, a, b, ε)` 以一个函数 $f$、一个区间 $[a, b]$ 和一个容限 $\\epsilon$ 作为输入。\n\n1.  使用宽度为 $h_1 = b-a$ 的单个区间，通过梯形法则计算近似值 $S_1$。其公式为 $S_1 = \\frac{h_1}{2}(f(a) + f(b))$。\n2.  令 $c = (a+b)/2$ 为区间的中点。使用两个宽度均为 $h_2 = (b-a)/2$ 的子区间 $[a, c]$ 和 $[c, b]$，通过复合梯形法则计算近似值 $S_2$。其公式为 $S_2 = \\frac{h_2}{2}(f(a) + f(c)) + \\frac{h_2}{2}(f(c) + f(b))$。\n3.  更精确的近似值 $S_2$ 的误差估计基于这两个近似值之间的差异。停止准则为 $|S_2 - S_1| < 3\\epsilon$。\n4.  如果满足该准则，则此区间的过程终止并返回 $S_2$ 的值。\n5.  如果不满足该准则，算法将细化区间。它在两个子区间上递归调用自身，并将每个子区间的容限减半。区间 $[a, b]$ 的结果是这两个调用结果之和：\n    `AdaptiveIntegrate(f, a, c, ε/2) + AdaptiveIntegrate(f, c, b, ε/2)`\n\n你的任务是手动追踪此算法，以初始容限 $\\epsilon = 2$ 计算积分\n$$ I = \\int_0^4 x^2 \\,dx $$\n的数值近似值。\n\n计算该算法返回的积分的最终数值近似值。以精确整数或分数形式提供你的答案。", "solution": "我们将给定的自适应梯形算法应用于函数 $f(x)=x^{2}$ 在区间 $[0,4]$ 上，初始容限为 $\\epsilon=2$。在 $[a,b]$ 上使用一个区间的梯形近似值为 $S_{1}=\\frac{h_{1}}{2}\\left(f(a)+f(b)\\right)$，其中 $h_{1}=b-a$，而使用两个区间的梯形近似值为\n$$\nS_{2}=\\frac{h_{2}}{2}\\left(f(a)+f(c)\\right)+\\frac{h_{2}}{2}\\left(f(c)+f(b)\\right),\n$$\n其中 $c=\\frac{a+b}{2}$ 且 $h_{2}=\\frac{b-a}{2}$。一个区间的停止准则是 $\\left|S_{2}-S_{1}\\right|<3\\epsilon$。如果不满足，我们对 $[a,c]$ 和 $[c,b]$ 进行递归，每个子区间的容限为 $\\epsilon/2$，然后将返回的值相加。\n\n顶层区间 $[0,4]$，容限 $\\epsilon=2$：\n- 计算 $h_{1}=4$，$S_{1}=\\frac{4}{2}\\left(f(0)+f(4)\\right)=2\\left(0+16\\right)=32$。\n- 中点 $c=2$，$h_{2}=2$，以及\n$$\nS_{2}=\\frac{2}{2}\\left(f(0)+f(2)\\right)+\\frac{2}{2}\\left(f(2)+f(4)\\right)=1\\left(0+4\\right)+1\\left(4+16\\right)=4+20=24.\n$$\n- 误差检查：$\\left|S_{2}-S_{1}\\right|=\\left|24-32\\right|=8$，而 $3\\epsilon=3\\cdot 2=6$。由于 $8\\not<6$，我们在 $[0,2]$ 和 $[2,4]$ 上进行递归，每个子区间的容限为 $\\epsilon/2=1$。\n\n子区间 $[0,2]$，容限 $\\epsilon=1$：\n- 计算 $h_{1}=2$，$S_{1}=\\frac{2}{2}\\left(f(0)+f(2)\\right)=1\\left(0+4\\right)=4$。\n- 中点 $c=1$，$h_{2}=1$，以及\n$$\nS_{2}=\\frac{1}{2}\\left(f(0)+f(1)\\right)+\\frac{1}{2}\\left(f(1)+f(2)\\right)=\\frac{1}{2}\\left(0+1\\right)+\\frac{1}{2}\\left(1+4\\right)=\\frac{1}{2}+\\frac{5}{2}=3.\n$$\n- 误差检查：$\\left|S_{2}-S_{1}\\right|=\\left|3-4\\right|=1$，而 $3\\epsilon=3\\cdot 1=3$。由于 $1<3$，接受 $[0,2]$ 上的 $S_{2}=3$。\n\n子区间 $[2,4]$，容限 $\\epsilon=1$：\n- 计算 $h_{1}=2$，$S_{1}=\\frac{2}{2}\\left(f(2)+f(4)\\right)=1\\left(4+16\\right)=20$。\n- 中点 $c=3$，$h_{2}=1$，以及\n$$\nS_{2}=\\frac{1}{2}\\left(f(2)+f(3)\\right)+\\frac{1}{2}\\left(f(3)+f(4)\\right)=\\frac{1}{2}\\left(4+9\\right)+\\frac{1}{2}\\left(9+16\\right)=\\frac{13}{2}+\\frac{25}{2}=19.\n$$\n- 误差检查：$\\left|S_{2}-S_{1}\\right|=\\left|19-20\\right|=1$，而 $3\\epsilon=3$。由于 $1<3$，接受 $[2,4]$ 上的 $S_{2}=19$。\n\n最后，顶层调用返回接受的子区间结果之和：\n$$\n\\text{结果} = 3+19=22.\n$$\n这就是算法返回的最终数值近似值。", "answer": "$$\\boxed{22}$$", "id": "2153105"}, {"introduction": "自适应方法虽然功能强大，但并非万无一失；它们的“阿喀琉斯之踵”在于其误差*估计*。本练习将展示一个警示性的案例，其中一个特殊设计的函数会让算法的误差估计值产生误导性地减小，从而导致其过早终止并产生巨大的实际误差。通过分析这一失效案例，你将学会批判性地评估这些方法在何时以及为何会产生误导，这是任何严谨的实践者都必须具备的关键技能。[@problem_id:2153058]", "problem": "一个基于辛普森法则的自适应求积算法被用来在给定的容差 $\\epsilon$ 内近似计算函数 $f(x)$ 在区间 $[a, b]$ 上的定积分。该算法的核心是一个递归过程，其操作如下：\n\n1.  给定一个区间 $[a, b]$ 和容差 `tol`，首先使用点 $a$、$c=(a+b)/2$ 和 $b$ 这三个点，计算粗略的辛普森法则近似值 $S_1 = S(a,b)$。\n2.  接下来，通过对两个子区间 $[a,c]$ 和 $[c,b]$ 应用辛普森法则并将结果相加，计算一个更精确的近似值 $S_2 = S(a,c) + S(c,b)$。\n3.  精确近似值 $S_2$ 的绝对误差估计为 $E_{est} = \\frac{1}{15}|S_2 - S_1|$。\n4.  如果 $E_{est} \\le \\text{tol}$，则该区间的递归终止，并返回 $S_2$ 的值作为近似结果。\n5.  如果 $E_{est} > \\text{tol}$，则对子区间 $[a,c]$ 和 $[c,b]$ 递归调用该算法，每个子区间的容差为 $\\text{tol}/2$。最终的近似值是这两个递归调用结果的和。\n\n考虑函数\n$$\nf(x) = \\alpha - \\beta x^2 - \\gamma x^4 + C \\sin^2(\\pi x)\n$$\n在区间 $[-L, L]$ 上的积分，其中参数由 $\\alpha = 2$、$\\beta = 0.5$、$\\gamma = 0.01$、$C = 10$ 和 $L = 2$ 给出。\n\n该算法以区间 $[-2, 2]$ 和容差 $\\epsilon = 0.01$ 开始。我们发现该算法仅在第一步之后就终止了（即没有任何递归调用）。你的任务是分析这个结果。\n\n计算返回的近似值的真实绝对误差与估计绝对误差之比。将你的最终答案四舍五入到四位有效数字。", "solution": "我们在区间 $[a,b]$ 上使用辛普森法则，其中点为 $c=(a+b)/2$:\n$$\nS(a,b) = \\frac{b-a}{6}\\big(f(a) + 4 f(c) + f(b)\\big).\n$$\n这里 $a=-2$, $b=2$, $c=0$。该自适应方案计算\n$$\nS_{1} = S(-2,2), \\quad S_{2} = S(-2,0) + S(0,2), \\quad E_{\\text{est}} = \\frac{1}{15}|S_{2} - S_{1}|.\n$$\n函数为\n$$\nf(x) = 2 - \\frac{1}{2}x^{2} - \\frac{1}{100}x^{4} + 10 \\sin^{2}(\\pi x),\n$$\n它是一个偶函数。在辛普森节点 $x \\in \\{-2,-1,0,1,2\\}$ 处，我们有 $\\sin^{2}(\\pi x)=0$，因此在这些节点上，$f$ 简化为其多项式部分。因此\n$$\nf(0)=2, \\quad f(1)=2 - \\frac{1}{2} - \\frac{1}{100} = \\frac{149}{100}, \\quad f(2)=2 - 2 - \\frac{16}{100} = -\\frac{4}{25}.\n$$\n计算 $S_{1}$ 和 $S_{2}$：\n$$\nS_{1} = \\frac{4}{6}\\big(f(-2) + 4 f(0) + f(2)\\big) = \\frac{4}{6}\\big(2 f(2) + 4 f(0)\\big) = \\frac{4}{3}\\big(f(2) + 2 f(0)\\big) = \\frac{4}{3}\\left(-\\frac{4}{25} + 4\\right) = \\frac{128}{25},\n$$\n$$\nS_{2} = \\frac{2}{6}\\big(f(-2) + 4 f(-1) + f(0)\\big) + \\frac{2}{6}\\big(f(0) + 4 f(1) + f(2)\\big) = \\frac{2}{3}\\big(f(2) + 4 f(1) + f(0)\\big) = \\frac{2}{3}\\left(-\\frac{4}{25} + 4\\cdot\\frac{149}{100} + 2\\right) = \\frac{26}{5}.\n$$\n于是\n$$\nS_{2} - S_{1} = \\frac{26}{5} - \\frac{128}{25} = \\frac{2}{25}, \\quad E_{\\text{est}} = \\frac{1}{15}\\left|\\frac{2}{25}\\right| = \\frac{2}{375} \\leq 0.01,\n$$\n因此算法在第一步后终止并返回 $S_{2}$。\n\n现在计算精确积分 $I = \\int_{-2}^{2} f(x)\\,dx$。将其分为多项式部分和三角函数部分。对于多项式部分，\n$$\n\\int_{-2}^{2}\\left(2 - \\frac{1}{2}x^{2} - \\frac{1}{100}x^{4}\\right) dx = 8 - \\frac{8}{3} - \\frac{16}{125} = \\frac{1952}{375}.\n$$\n对于三角函数部分，由于 $\\sin^{2}(\\pi x) = \\frac{1 - \\cos(2\\pi x)}{2}$ 并且在 $[-2,2]$ 上有四个完整周期，\n$$\n\\int_{-2}^{2} 10 \\sin^{2}(\\pi x)\\,dx = 10 \\cdot \\frac{1}{2} \\cdot 4 = 20 = \\frac{7500}{375}.\n$$\n因此，精确积分为\n$$\nI = \\frac{1952}{375} + \\frac{7500}{375} = \\frac{9452}{375}.\n$$\n返回的近似值的真实绝对误差是\n$$\nE_{\\text{true}} = \\left|I - S_{2}\\right| = \\left|\\frac{9452}{375} - \\frac{26}{5}\\right| = \\left|\\frac{9452}{375} - \\frac{1950}{375}\\right| = \\frac{7502}{375}.\n$$\n因此，真实绝对误差与估计绝对误差之比为\n$$\n\\frac{E_{\\text{true}}}{E_{\\text{est}}} = \\frac{\\frac{7502}{375}}{\\frac{2}{375}} = \\frac{7502}{2} = 3751.\n$$\n四舍五入到四位有效数字，结果是 $3751$。", "answer": "$$\\boxed{3751}$$", "id": "2153058"}, {"introduction": "现实世界的问题常常涉及不完全平滑的函数，例如由相变或信号切换引起的具有跳跃间断点的函数。在这种间断点上，幼稚地应用自适应求积会失败。最后一个练习将从理论走向代码，挑战你通过告知求积程序间断点的位置来实施一个稳健的解决方案，从而正确处理在物理学和工程学中常见的这类函数。[@problem_id:2371893]", "problem": "你需要编写一个完整的程序，对在指定点存在单个已知跳跃间断点的分段定义函数进行定积分的数值计算。每个被积函数由两个解析分支定义，对于 $x<x_{0}$ 记为 $f_{\\mathrm{L}}(x)$，对于 $x>x_{0}$ 记为 $f_{\\mathrm{R}}(x)$，且在 $x=x_{0}$ 处无定义。不得使用 $x=x_{0}$ 处的值。所有三角函数的参数均以弧度为单位。对于每种情况，程序必须生成真实积分 $I=\\int_{a}^{b} f(x)\\,dx$ 的一个近似值 $\\widehat{I}$，该近似值需同时满足绝对误差要求 $\\left|\\widehat{I}-I\\right|\\leq \\varepsilon_{\\mathrm{abs}}$ 和相对误差要求 $\\left|\\widehat{I}-I\\right| \\leq \\varepsilon_{\\mathrm{rel}}\\left|I\\right|$。角度应按弧度处理。\n\n测试套件包含四个积分。在下述所有定义中，所有常数均为实数，且函数在跳跃位置处无定义。如果 $x_{0}\\notin [a,b]$，则函数在 $[a,b]$ 上等于相应的分支，没有任何跳跃。\n\n- 情况 $1$（内部跳跃；平滑基函数）：\n  - $f_{\\mathrm{L}}(x)=e^{-x^{2}}$\n  - $f_{\\mathrm{R}}(x)=e^{-x^{2}}+c$，其中 $c=1.5$\n  - 积分区间 $[a,b]=\\left[-2,2\\right]$\n  - 跳跃位置 $x_{0}=0.25$\n  - 绝对容差 $\\varepsilon_{\\mathrm{abs}}=10^{-9}$ 和相对容差 $\\varepsilon_{\\mathrm{rel}}=10^{-9}$\n\n- 情况 $2$（跳跃点在左边界；整个区间在右侧）：\n  - $f_{\\mathrm{L}}(x)=\\cos(x)$\n  - $f_{\\mathrm{R}}(x)=\\cos(x)+c$，其中 $c=3$\n  - 积分区间 $[a,b]=\\left[0,\\pi\\right]$\n  - 跳跃位置 $x_{0}=0$\n  - 绝对容差 $\\varepsilon_{\\mathrm{abs}}=10^{-10}$ 和相对容差 $\\varepsilon_{\\mathrm{rel}}=10^{-10}$\n\n- 情况 $3$（跳跃点在区间外；未遇到跳跃）：\n  - $f_{\\mathrm{L}}(x)=\\ln\\!\\left(1+x^{2}\\right)$\n  - $f_{\\mathrm{R}}(x)=\\ln\\!\\left(1+x^{2}\\right)+c$，其中 $c=10$\n  - 积分区间 $[a,b]=\\left[-1,1\\right]$\n  - 跳跃位置 $x_{0}=5$\n  - 绝对容差 $\\varepsilon_{\\mathrm{abs}}=10^{-10}$ 和相对容差 $\\varepsilon_{\\mathrm{rel}}=10^{-10}$\n\n- 情况 $4$（内部跳跃；在 $[a,b]$ 上非多项式但平滑的基函数）：\n  - $f_{\\mathrm{L}}(x)=\\sqrt{1+x}$ 定义于 $x\\in\\left[-1,1\\right]$\n  - $f_{\\mathrm{R}}(x)=\\sqrt{1+x}+c$，其中 $c=-0.75$\n  - 积分区间 $[a,b]=\\left[-1,1\\right]$\n  - 跳跃位置 $x_{0}=0.3$\n  - 绝对容差 $\\varepsilon_{\\mathrm{abs}}=10^{-10}$ 和相对容差 $\\varepsilon_{\\mathrm{rel}}=10^{-10}$\n\n要求：\n- 你的程序必须确保永远不会在 $x=x_{0}$ 处计算被积函数的值。\n- 你的程序必须对每种情况都达到绝对和相对误差标准。\n- 你的程序必须生成单行输出，其中包含四个结果，以逗号分隔的列表形式，并用方括号括起来，顺序为情况 $1$ 到 $4$。每个结果必须四舍五入到恰好 $12$ 位小数的小数形式。例如：$\\left[\\widehat{I}_{1},\\widehat{I}_{2},\\widehat{I}_{3},\\widehat{I}_{4}\\right]$，其中每个 $\\widehat{I}_{k}$ 在小数点后恰好有 $12$ 位数字。\n\n最终输出格式：\n- 单行：$\\left[\\widehat{I}_{1},\\widehat{I}_{2},\\widehat{I}_{3},\\widehat{I}_{4}\\right]$ 无空格，每个值四舍五入到 $12$ 位小数。", "solution": "该问题陈述已经过严格验证，被认为是科学上合理、适定、客观且自洽的。它提出了计算物理和数值分析中的一个标准任务：计算具有有限跳跃间断点的函数的定积分。\n\n完成此任务的基本定理是定积分的可加性。对于在区间 $[a, b]$ 上积分的函数 $f(x)$，以及任意点 $x_0 \\in (a, b)$，积分可以分解为：\n$$\n\\int_a^b f(x) \\, dx = \\int_a^{x_0} f(x) \\, dx + \\int_{x_0}^b f(x) \\, dx\n$$\n问题指定了一个在 $x=x_0$ 处有跳跃间断点的分段函数 $f(x)$，定义如下：\n$$\nf(x) =\n\\begin{cases}\nf_{\\mathrm{L}}(x) & \\text{if } x < x_0 \\\\\nf_{\\mathrm{R}}(x) & \\text{if } x > x_0\n\\end{cases}\n$$\n$f(x_0)$ 处的值是未定义的，这对于黎曼积分或勒贝格积分来说无关紧要，因为单个点的值不影响积分值。\n\n策略性方法取决于间断点 $x_0$ 相对于积分区间 $[a, b]$ 的位置。\n\n1.  **内部间断点 ($a < x_0 < b$)**：直接应用可加性。原始积分被分成两个独立的积分，其被积函数在子区间上是连续的：\n    $$\n    I = \\int_a^b f(x) \\, dx = \\int_a^{x_0} f_{\\mathrm{L}}(x) \\, dx + \\int_{x_0}^b f_{\\mathrm{R}}(x) \\, dx\n    $$\n    这两个积分中的每一个，$I_L = \\int_a^{x_0} f_{\\mathrm{L}}(x) \\, dx$ 和 $I_R = \\int_{x_0}^b f_{\\mathrm{R}}(x) \\, dx$，现在都可以使用针对连续函数的标准求积方法进行数值计算。\n\n2.  **间断点在区间外部或边界上 ($x_0 \\le a$ 或 $x_0 \\ge b$)**：\n    *   如果 $x_0 \\ge b$，那么对于所有 $x \\in [a, b]$，条件 $x \\le x_0$ 成立（或者如果 $x_0 > b$，则 $x < x_0$）。因此，被积函数 $f(x)$ 在整个区间 $[a, b]$ 上等同于单个连续分支 $f_{\\mathrm{L}}(x)$。积分即为：\n        $$\n        I = \\int_a^b f_{\\mathrm{L}}(x) \\, dx\n        $$\n    *   如果 $x_0 \\le a$，那么对于所有 $x \\in [a, b]$，条件 $x \\ge x_0$ 成立（或者如果 $x_0 < a$，则 $x > x_0$）。被积函数 $f(x)$ 在 $[a, b]$ 上等同于连续分支 $f_{\\mathrm{R}}(x)$。积分即为：\n        $$\n        I = \\int_a^b f_{\\mathrm{R}}(x) \\, dx\n        $$\n\n对于数值计算，需要一个稳健的自适应求积算法来满足严格的误差容差（$\\varepsilon_{\\mathrm{abs}}$ 和 $\\varepsilon_{\\mathrm{rel}}$）。`scipy.integrate.quad` 函数是一个理想的选择，它是高可靠性 FORTRAN 库 QUADPACK 的 Python 接口。\n\n`quad` 的一个关键特性是其 `points` 参数。当提供一个包含已知难点（如间断点或奇点）的列表时，积分器会在这些点上对区间进行划分。然后，它分别计算每个子区间的积分并对结果求和，同时管理总误差预算。这种方法正是内部间断点情况 ($a < x_0 < b$) 所需要的。通过调用 `quad(f, a, b, points=[x_0], ...)`，我们指示算法计算 $\\int_a^{x_0} f(x) \\, dx + \\int_{x_0}^b f(x) \\, dx$。这正确地处理了跳跃，并且重要的是，避免了在点 $x_0$ 本身进行任何函数求值，从而满足了问题的一个关键约束。\n\n总体算法如下：\n对于每个具有参数 $\\{f_{\\mathrm{L}}, f_{\\mathrm{R}}, [a, b], x_0, \\varepsilon_{\\mathrm{abs}}, \\varepsilon_{\\mathrm{rel}}\\}$ 的测试用例：\n1.  检查 $x_0$ 相对于 $[a, b]$ 的位置。\n2.  如果 $a < x_0 < b$，定义一个单一的分段函数 `f(x)`，它根据情况返回 `fL(x)` 或 `fR(x)`。在 $[a, b]$ 上调用 `scipy.integrate.quad` 计算 `f(x)` 的积分，并将 `x0` 传入 `points` 参数。\n3.  如果 $x_0 \\le a$，函数在 $(a, b]$ 上是连续的，且等于 $f_{\\mathrm{R}}(x)$。在 $[a, b]$ 上调用 `scipy.integrate.quad` 计算 $f_{\\mathrm{R}}(x)$ 的积分。\n4.  如果 $x_0 \\ge b$，函数在 $[a, b)$ 上是连续的，且等于 $f_{\\mathrm{L}}(x)$。在 $[a, b]$ 上调用 `scipy.integrate.quad` 计算 $f_{\\mathrm{L}}(x)$ 的积分。\n5.  在所有对 `quad` 的调用中，通过 `epsabs` 和 `epsrel` 参数指定给定的容差 $\\varepsilon_{\\mathrm{abs}}$ 和 $\\varepsilon_{\\mathrm{rel}}$。\n6.  积分结果是 `quad` 返回的元组的第一个元素。收集结果，格式化为 $12$ 位小数，然后打印。\n\n这种有原则的方法确保了正确性、准确性，并遵守了所有问题约束。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves a series of definite integrals for piecewise functions with\n    a single jump discontinuity, adhering to specified error tolerances.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"id\": 1,\n            \"fL\": lambda x: np.exp(-x**2),\n            \"fR\": lambda x: np.exp(-x**2) + 1.5,\n            \"interval\": [-2.0, 2.0],\n            \"x0\": 0.25,\n            \"epsabs\": 1e-9,\n            \"epsrel\": 1e-9,\n        },\n        {\n            \"id\": 2,\n            \"fL\": lambda x: np.cos(x),\n            \"fR\": lambda x: np.cos(x) + 3.0,\n            \"interval\": [0.0, np.pi],\n            \"x0\": 0.0,\n            \"epsabs\": 1e-10,\n            \"epsrel\": 1e-10,\n        },\n        {\n            \"id\": 3,\n            \"fL\": lambda x: np.log(1 + x**2),\n            \"fR\": lambda x: np.log(1 + x**2) + 10.0,\n            \"interval\": [-1.0, 1.0],\n            \"x0\": 5.0,\n            \"epsabs\": 1e-10,\n            \"epsrel\": 1e-10,\n        },\n        {\n            \"id\": 4,\n            \"fL\": lambda x: np.sqrt(1 + x),\n            \"fR\": lambda x: np.sqrt(1 + x) - 0.75,\n            \"interval\": [-1.0, 1.0],\n            \"x0\": 0.3,\n            \"epsabs\": 1e-10,\n            \"epsrel\": 1e-10,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        fL = case[\"fL\"]\n        fR = case[\"fR\"]\n        a, b = case[\"interval\"]\n        x0 = case[\"x0\"]\n        epsabs = case[\"epsabs\"]\n        epsrel = case[\"epsrel\"]\n        \n        integral_val = 0.0\n\n        if a  x0  b:\n            # Case when the discontinuity is inside the integration interval.\n            # Define the full piecewise function. np.where handles vector inputs from quad.\n            def f(x):\n                return np.where(x  x0, fL(x), fR(x))\n            \n            # Use the 'points' argument to tell the integrator about the discontinuity.\n            # This ensures the interval is split at x0 and avoids evaluating f(x0).\n            integral_val, _ = quad(f, a, b, points=[x0], epsabs=epsabs, epsrel=epsrel)\n        elif x0 = a:\n            # Discontinuity is at or before the start of the interval.\n            # The integrand is fR(x) over the entire interval (a, b].\n            integral_val, _ = quad(fR, a, b, epsabs=epsabs, epsrel=epsrel)\n        else:  # x0 >= b\n            # Discontinuity is at or after the end of the interval.\n            # The integrand is fL(x) over the entire interval [a, b).\n            integral_val, _ = quad(fL, a, b, epsabs=epsabs, epsrel=epsrel)\n            \n        results.append(integral_val)\n\n    # Format the results to exactly 12 decimal places as required.\n    formatted_results = [f\"{res:.12f}\" for res in results]\n\n    # Print the final output in the specified format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2371893"}]}