{"hands_on_practices": [{"introduction": "Adams-Moulton方法通常与一个显式方法（如Adams-Bashforth）配对，形成一个预测-校正方案，这在计算上非常高效。本练习将带你亲手体验这个过程，通过一个具体的常微分方程初值问题，一步步完成预测和校正，从而牢固掌握这一核心机制。这个实践是理解更复杂多步法实现的基础。[@problem_id:2152822]", "problem": "考虑由常微分方程 $y'(t) = y(t) - t^2 + 1$ 定义的初值问题。假设我们使用固定步长 $h = 0.2$ 的数值方法来近似其解。已知近似解曲线上的前两个点：在 $t_0 = 0.0$ 时，值为 $y_0 = 0.5$；在 $t_1 = 0.2$ 时，值为 $y_1 = 0.82930$。\n\n您的任务是应用以下预测-校正格式的单步，计算在时间 $t_2 = 0.4$ 时的下一个值 $y_2$。\n\n首先，使用以下公式计算预测值 $y_{i+1}^*$：\n$$y_{i+1}^* = y_i + \\frac{h}{2}\\left(3f(t_i, y_i) - f(t_{i-1}, y_{i-1})\\right)$$\n其中 $f(t,y) = y'(t)$。\n\n其次，使用这个预测值，通过以下公式计算校正值 $y_{i+1}$：\n$$y_{i+1} = y_i + \\frac{h}{2}\\left(f(t_{i+1}, y_{i+1}^*) + f(t_i, y_i)\\right)$$\n\n报告最终的校正值 $y_2$。将您的最终答案保留五位有效数字。", "solution": "我们给定常微分方程 $y'(t)=f(t,y)=y-t^{2}+1$ 和步长 $h=0.2$，已知值为 $(t_{0},y_{0})=(0.0,0.5)$ 和 $(t_{1},y_{1})=(0.2,0.82930)$。我们的目标是使用指定的预测-校正格式计算在 $t_{2}=0.4$ 时的 $y_{2}$。\n\n首先计算在已知点处所需的函数值：\n$$f(t_{0},y_{0})=y_{0}-t_{0}^{2}+1=0.5-0+1=1.5$$\n$$f(t_{1},y_{1})=y_{1}-t_{1}^{2}+1=0.82930-0.04+1=1.78930$$\n\n预测步 (两步Adams-Bashforth法)：\n$$y_{2}^{*}=y_{1}+\\frac{h}{2}\\left(3f(t_{1},y_{1})-f(t_{0},y_{0})\\right) = 0.82930+0.1\\left(3\\cdot 1.78930-1.5\\right)=0.82930+0.1\\cdot 3.86790=1.216090$$\n\n在预测点 $(t_{2},y_{2}^{*})=(0.4,1.216090)$ 处计算 $f$ 的值：\n$$f(t_{2},y_{2}^{*})=y_{2}^{*}-t_{2}^{2}+1=1.216090-0.16+1=2.056090$$\n\n校正步 (使用预测端点值的梯形步)：\n$$y_{2}=y_{1}+\\frac{h}{2}\\left(f(t_{2},y_{2}^{*})+f(t_{1},y_{1})\\right) = 0.82930+0.1\\left(2.056090+1.78930\\right) = 0.82930+0.3845390=1.2138390$$\n\n保留五位有效数字得到 $1.2138$。", "answer": "$$\\boxed{1.2138}$$", "id": "2152822"}, {"introduction": "任何数值方法的精度都由其局部截断误差来量化。本练习将引导你使用泰勒级数展开这一基本分析工具，推导二阶Adams-Moulton方法（即梯形法则）的误差常数。通过这个推导，你将不仅能验证该方法的阶数，还能从根本上理解误差项的来源和形式，这是评估和比较不同数值方法能力的关键一步。[@problem_id:2152831]", "problem": "在常微分方程（ODE）的数值分析中，单步法用于近似求解形如 $y'(t) = f(t, y(t))$，且满足 $y(t_0) = y_0$ 的初值问题的解。梯形法是一种单步隐式方法，它将解从时间 $t_i$ 推进到 $t_{i+1} = t_i + h$，其中 $h$ 是步长。其公式为：\n$$w_{i+1} = w_i + \\frac{h}{2} \\left[ f(t_i, w_i) + f(t_{i+1}, w_{i+1}) \\right]$$\n其中 $w_i$ 是对真实解 $y(t_i)$ 的数值近似。该方法是 Adams-Moulton 方法族的一员，具体来说是二阶 Adams-Moulton 方法。\n\n局部截断误差 $\\tau_{i+1}$ 是在假设已知精确解值 $y(t_i)$ 的情况下，单步计算中引入的误差。它通过将真实解 $y(t)$ 代入数值格式来定义：\n$$\\tau_{i+1} = y(t_{i+1}) - \\left( y(t_i) + \\frac{h}{2} \\left[ f(t_i, y(t_i)) + f(t_{i+1}, y(t_{i+1})) \\right] \\right)$$\n对于一个 $p$ 阶方法，其局部截断误差可以表示为 $\\tau_{i+1} = C_p h^{p+1} y^{(p+1)}(\\xi_i) + \\mathcal{O}(h^{p+2})$，其中某个 $\\xi_i \\in (t_i, t_{i+1})$，$C_p$ 是误差常数，$y^{(p+1)}$ 是真实解 $y(t)$ 的 $(p+1)$ 阶导数。\n\n已知梯形法的收敛阶为 $p=2$，求其对应的误差常数 $C_2$ 的值。", "solution": "我们考虑局部截断误差的定义：\n$$\\tau_{i+1} = y(t_{i+1}) - \\left( y(t_i) + \\frac{h}{2}\\left[f(t_i,y(t_i)) + f(t_{i+1},y(t_{i+1}))\\right]\\right)$$\n使用微分方程 $y'(t)=f(t,y(t))$，我们有 $f(t_i,y(t_i))=y'(t_i)$ 和 $f(t_{i+1},y(t_{i+1}))=y'(t_{i+1})$。\n\n将 $y(t)$ 和 $y'(t)$ 在 $t_i$ 点进行泰勒展开：\n$$y(t_{i+1}) = y(t_i) + h y'(t_i) + \\frac{h^{2}}{2} y''(t_i) + \\frac{h^{3}}{6} y^{(3)}(t_i) + O(h^4)$$\n$$y'(t_{i+1}) = y'(t_i) + h y''(t_i) + \\frac{h^{2}}{2} y^{(3)}(t_i) + O(h^3)$$\n\n代入梯形法表达式中：\n$$y(t_i) + \\frac{h}{2}\\left[y'(t_i) + y'(t_{i+1})\\right] = y(t_i) + \\frac{h}{2}\\left[y'(t_i) + y'(t_i) + h y''(t_i) + \\frac{h^{2}}{2} y^{(3)}(t_i) + O(h^3)\\right]$$\n化简后得到：\n$$y(t_i) + h y'(t_i) + \\frac{h^{2}}{2} y''(t_i) + \\frac{h^{3}}{4} y^{(3)}(t_i) + O(h^4)$$\n\n因此，局部截断误差为：\n$$\\tau_{i+1} = \\left[y(t_i) + h y'(t_i) + \\frac{h^{2}}{2} y''(t_i) + \\frac{h^{3}}{6} y^{(3)}(t_i)\\right] - \\left[y(t_i) + h y'(t_i) + \\frac{h^{2}}{2} y''(t_i) + \\frac{h^{3}}{4} y^{(3)}(t_i)\\right] + O(h^4)$$\n合并同类项可得：\n$$\\tau_{i+1} = \\left(\\frac{1}{6} - \\frac{1}{4}\\right) h^{3} y^{(3)}(t_i) + O(h^{4}) = -\\frac{1}{12} h^{3} y^{(3)}(t_i) + O(h^{4})$$\n根据局部截断误差的定义 $\\tau_{i+1} = C_{p} h^{p+1} y^{(p+1)}(\\xi_i) + O(h^{p+2})$，对于阶数 $p=2$，我们有 $\\tau_{i+1} = C_{2} h^{3} y^{(3)}(\\xi_i) + O(h^{4})$。因此，我们可以确定误差常数为：\n$$C_{2} = -\\frac{1}{12}$$", "answer": "$$\\boxed{-\\frac{1}{12}}$$", "id": "2152831"}, {"introduction": "在数值分析中，一个普遍的误解是更高阶的方法总是更优越。本练习将通过一个引人深思的计算实验来挑战这一观念，探索数值稳定性的复杂性。你将通过编程实现一个稳定性检测器，并找出一个具体案例，其中低阶的AM-2方法保持稳定，而高阶的AM-4方法却发散。这个实践揭示了在为特定问题（尤其是刚性问题）选择数值方法时，稳定性和阶数之间需要权衡的重要现实。[@problem_id:2371562]", "problem": "你需要构建并分析一个线性常微分方程（ODE），以揭示两种不同阶的隐式 Adams–Moulton 多步法之间一个反直觉的稳定性行为。目标是找出一个例子，其中对于给定的步长，二阶 Adams–Moulton 方法（AM-2）是稳定的，而更高阶的四阶 Adams–Moulton 方法（AM-4）是不稳定的。你必须实现一个程序，通过将线性多步法的基本根条件应用于线性检验方程，来验证稳定性或不稳定性。\n\n基本依据和定义：\n- 考虑线性检验方程 $y' = \\lambda y$，其中复标量 $ \\lambda \\in \\mathbb{C} $。对于固定的步长 $h > 0$，定义复数 $z = h \\lambda$。\n- 线性多步法的形式为 $\\sum_{j=0}^{s} \\alpha_j y_{n+j} = h \\sum_{j=0}^{s} \\beta_j f_{n+j}$，其中 $f_{n+j} = f(t_{n+j}, y_{n+j})$。在检验方程 $f(t,y) = \\lambda y$ 上，该方法可简化为关于放大因子 $\\xi$ 的特征方程：$ \\rho(\\xi) - z \\sigma(\\xi) = 0$，其中 $ \\rho(\\xi) = \\sum_{j=0}^{s} \\alpha_j \\xi^j$ 和 $ \\sigma(\\xi) = \\sum_{j=0}^{s} \\beta_j \\xi^j$。\n- 对于给定的 $z$，绝对稳定性意味着 $ \\rho(\\xi) - z \\sigma(\\xi) = 0$ 的所有根 $\\xi$ 都满足 $|\\xi| < 1$；如果某个根位于单位圆上，它必须是单根才能是临界稳定的。你应该实现对根条件的数值检验，并在一个小的数值容差范围内将 $|\\xi| \\le 1$ 视为稳定。\n\n任务要求：\n1. 使用上述原理，为二阶 Adams–Moulton 方法（AM-2）和四阶 Adams–Moulton 方法（AM-4）实现稳定性测试。你应该使用这些方法的标准 Adams–Moulton 系数。对于每种方法，构建相应的多项式 $ \\rho(\\xi)$ 和 $ \\sigma(\\xi)$，并对给定的 $z$ 测试根条件。\n2. 构建一个形式为 $y' = \\lambda y$ 的标量线性 ODE，使其在以下意义上是“病态的”：对于指定的步长 $h$，AM-2 方法是稳定的（所有根满足 $|\\xi| < 1$），而 AM-4 方法是不稳定的（至少有一个根满足 $|\\xi| > 1$）。你的程序应通过根条件进行数值验证，而不是借助任何外部的稳定性区域图。\n3. 通过使用标准的多项式求根器计算特征多项式的根，并用一个小的数值容差验证模条件，来稳健地实现稳定性检查。\n\n测试套件：\n在以下三个测试用例上评估你的实现，每个用例由一对 $(\\lambda,h)$ 指定：\n- 用例 1：$\\lambda = -1.0$， $h = 0.1$。\n- 用例 2：$\\lambda = -50.0$， $h = 0.2$。\n- 用例 3：$\\lambda = 1.0$， $h = 0.1$。\n\n对于每个用例，计算 $z = h \\lambda$ 并确定两个布尔值：第一个表示 AM-2 是否稳定，第二个表示 AM-4 是否稳定，两者都依据根条件判断。“病态”行为嵌在其中一个用例中。\n\n最终输出格式：\n你的程序应生成单行输出，包含一个由列表组成的列表，格式为逗号分隔。每个内部列表的形式为 $[b_{\\mathrm{AM2}}, b_{\\mathrm{AM4}}]$，其中布尔值不带引号。例如，输出必须类似于 $[[\\text{True},\\text{False}],[\\text{True},\\text{True}],[\\text{False},\\text{False}]]$，但其值由你对上述测试套件的计算确定。", "solution": "所述问题是常微分方程数值分析中的一个标准练习。它具有科学依据，问题定义明确，并包含足够的信息以进行求解。其目标是展示一个已知的现象：高阶数值方法可能比较低阶方法具有更小的稳定区域，从而对某些刚性问题表现出反直觉的行为。我将着手解决。\n\n分析的核心是线性检验方程，这是一个研究常微分方程数值方法稳定性的基本工具。该方程由下式给出：\n$$ y'(t) = \\lambda y(t) $$\n其中 $y(t) \\in \\mathbb{C}$ 且 $\\lambda \\in \\mathbb{C}$。当一个形式为 $\\sum_{j=0}^{s} \\alpha_j y_{n+j} = h \\sum_{j=0}^{s} \\beta_j f_{n+j}$ 的线性多步法（LMM）应用于该方程（其中 $f(t,y) = \\lambda y$）时，会产生一个关于序列 $\\{y_n\\}$ 的线性常系数递推关系。该递推关系的解形式为 $y_n = \\xi^n$，其中 $\\xi$ 是特征方程的根：\n$$ \\rho(\\xi) - z \\sigma(\\xi) = 0 $$\n这里，$z = h\\lambda$，而 $\\rho(\\xi) = \\sum_{j=0}^{s} \\alpha_j \\xi^j$ 和 $\\sigma(\\xi) = \\sum_{j=0}^{s} \\beta_j \\xi^j$ 分别是该方法的第一和第二特征多项式。\n\n对于给定的 $z$，如果其特征方程的所有根 $\\xi_k$ 都满足 $|\\xi_k| \\le 1$，则该方法被定义为绝对稳定。任何模等于 $1$ 的根都必须是单根。问题陈述允许在数值实现上稍作放宽，其中 $|\\xi_k| \\le 1 + \\epsilon$（对于一个小的容差 $\\epsilon$）被认为是稳定的。这种检查方式简化了分析，避免了对单位圆上单根的显式检查。\n\n首先，我们分析二阶 Adams-Moulton 方法（AM-2），也称为梯形法则。这是一个单步法（$s=1$），定义如下：\n$$ y_{n+1} - y_{n} = \\frac{h}{2} (f_{n+1} + f_n) $$\n由此形式，我们确定系数为 $\\alpha_1=1, \\alpha_0=-1$ 和 $\\beta_1=1/2, \\beta_0=1/2$。其特征多项式为：\n$$ \\rho(\\xi) = \\xi - 1 $$\n$$ \\sigma(\\xi) = \\frac{1}{2}\\xi + \\frac{1}{2} $$\n得到的特征方程是关于 $\\xi$ 的线性方程：\n$$ (\\xi - 1) - z \\left( \\frac{1}{2}\\xi + \\frac{1}{2} \\right) = 0 \\implies \\xi\\left(1 - \\frac{z}{2}\\right) = 1 + \\frac{z}{2} $$\n这个单根，被称为放大因子，是：\n$$ \\xi = \\frac{1 + z/2}{1 - z/2} $$\n为保证稳定性，我们要求 $|\\xi| \\le 1$。设 $z = x+iy$。条件 $|\\frac{2+z}{2-z}| \\le 1$ 等价于 $|2+z|^2 \\le |2-z|^2$。\n$$ (2+x)^2 + y^2 \\le (2-x)^2 + y^2 \\implies 4+4x+x^2 \\le 4-4x+x^2 \\implies 8x \\le 0 \\implies x \\le 0 $$\n因此，对于复平面左半部分的所有 $z$（$\\text{Re}(z) \\le 0$），AM-2 方法都是稳定的。此性质被称为 A-稳定性。\n\n接下来，我们分析四阶 Adams-Moulton 方法（AM-4）。这是一个三步法（$s=3$），由以下公式给出：\n$$ y_{n+3} - y_{n+2} = \\frac{h}{24}(9f_{n+3} + 19f_{n+2} - 5f_{n+1} + f_n) $$\n由此，我们提取系数。第一特征多项式具有 $\\alpha_3=1, \\alpha_2=-1$，所有其他 $\\alpha_j=0$：\n$$ \\rho(\\xi) = \\xi^3 - \\xi^2 $$\n第二特征多项式的系数为 $\\beta_3 = 9/24, \\beta_2 = 19/24, \\beta_1 = -5/24, \\beta_0 = 1/24$：\n$$ \\sigma(\\xi) = \\frac{1}{24}(9\\xi^3 + 19\\xi^2 - 5\\xi + 1) $$\n特征方程 $\\rho(\\xi) - z \\sigma(\\xi) = 0$ 是：\n$$ (\\xi^3 - \\xi^2) - \\frac{z}{24}(9\\xi^3 + 19\\xi^2 - 5\\xi + 1) = 0 $$\n两边乘以 $24$ 并按 $\\xi$ 的幂次合并项，得到一个三次多项式方程：\n$$ (24 - 9z)\\xi^3 + (-24 - 19z)\\xi^2 + (5z)\\xi - z = 0 $$\n与 AM-2 不同，该方程无法轻易地解析求解其稳定区域。对于给定的 $z$，AM-4 的稳定性必须通过数值方法找到该多项式的三个根，并检查它们的模是否都小于或等于 $1$ 来确定。一个已知的结果是 AM-4 方法不是 A-稳定的；其绝对稳定区域不包含整个左半平面。\n\n实现将按以下步骤进行。对于每个给定的对 $(\\lambda, h)$：\n1. 计算 $z = h\\lambda$。\n2. 对于 AM-2，计算 $\\xi = (1 + z/2)/(1 - z/2)$ 并检查是否 $|\\xi| \\le 1 + \\epsilon$。\n3. 对于 AM-4，构建三次多项式 $P(\\xi) = a_3 \\xi^3 + a_2 \\xi^2 + a_1 \\xi + a_0$ 的复数系数，其中 $a_3=24-9z, a_2=-24-19z, a_1=5z, a_0=-z$。使用标准的数值求根器获得根 $\\xi_1, \\xi_2, \\xi_3$。检查是否 $\\max(|\\xi_1|, |\\xi_2|, |\\xi_3|) \\le 1 + \\epsilon$。\n4. 一个小的容差 $\\epsilon = 10^{-9}$ 适合于此数值检查。\n\n我们现在根据此过程评估所提供的测试用例。\n\n- **用例 1**：$(\\lambda, h) = (-1.0, 0.1) \\implies z = -0.1$。\n  - AM-2：$\\text{Re}(z) = -0.1 \\le 0$。该方法稳定。\n  - AM-4：$z = -0.1$ 是一个非常靠近原点的点。该方法是零稳定的，并且对于小的负实数 $z$，已知是稳定的。我们预期其稳定。\n  - 预测结果：$[\\text{True}, \\text{True}]$。\n\n- **用例 2**：$(\\lambda, h) = (-50.0, 0.2) \\implies z = -10.0$。\n  - AM-2：$\\text{Re}(z) = -10.0 \\le 0$。该方法是 A-稳定的，因此保持稳定。\n  - AM-4：AM-4 沿负实轴的稳定区域约为 $(-3.0, 0)$。由于 $z = -10.0$ 远在此区间之外，我们预期至少有一个根的模将大于 $1$。该方法不稳定。这就是病态的用例。\n  - 预测结果：$[\\text{True}, \\text{False}]$。\n\n- **用例 3**：$(\\lambda, h) = (1.0, 0.1) \\implies z = 0.1$。\n  - AM-2：$\\text{Re}(z) = 0.1 > 0$。该方法不稳定。\n  - AM-4：对于 $\\text{Re}(z) > 0$，预期是不稳定的。$\\rho(\\xi)$ 在 $\\xi=1$ 处的根会被扰动到一个大于 $1$ 的值。该方法不稳定。\n  - 预测结果：$[\\text{False}, \\text{False}]$。\n\n最终的程序将实现此逻辑并以数值方式确认这些预测。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef check_stability_am2(z: complex, tol: float = 1e-9) -> bool:\n    \"\"\"\n    Checks the stability of the AM-2 method for a given z = h*lambda.\n    AM-2 is stable if the single root xi of its characteristic equation has |xi| <= 1.\n    \"\"\"\n    # The characteristic polynomial for AM-2 is (1 - z/2)*xi - (1 + z/2) = 0.\n    # Avoid division by zero if z = 2.\n    if abs(z - 2.0) < tol:\n        # If z=2, the equation is degenerate. Physically, this corresponds to an\n        # infinite amplification factor, hence unstable.\n        return False\n        \n    xi = (1 + z / 2) / (1 - z / 2)\n    return np.abs(xi) <= 1.0 + tol\n\ndef check_stability_am4(z: complex, tol: float = 1e-9) -> bool:\n    \"\"\"\n    Checks the stability of the AM-4 method for a given z = h*lambda.\n    AM-4 is stable if all roots xi of its characteristic equation have |xi| <= 1.\n    \"\"\"\n    # Characteristic equation for AM-4:\n    # (24 - 9*z)*xi^3 + (-24 - 19*z)*xi^2 + (5*z)*xi - z = 0\n    # Coefficients of the cubic polynomial a*xi^3 + b*xi^2 + c*xi + d = 0\n    # The coefficients are complex numbers.\n    coeffs = [\n        24 - 9 * z,\n        -24 - 19 * z,\n        5 * z,\n        -z\n    ]\n    \n    # Use numpy.roots to find the roots of the polynomial.\n    # The roots will be complex.\n    try:\n        roots = np.roots(coeffs)\n    except np.linalg.LinAlgError:\n        # This can happen in degenerate cases, considered unstable.\n        return False\n\n    # Check the modulus of each root. The method is unstable if any root has\n    # a modulus greater than 1 (plus tolerance).\n    max_modulus = np.max(np.abs(roots))\n    \n    return max_modulus <= 1.0 + tol\n\ndef solve():\n    \"\"\"\n    Solves the problem by evaluating the stability of AM-2 and AM-4 for given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement as tuples of (lambda, h).\n    test_cases = [\n        (-1.0, 0.1),\n        (-50.0, 0.2),\n        (1.0, 0.1),\n    ]\n\n    results = []\n    for lambda_val, h_val in test_cases:\n        # Calculate z = h * lambda\n        z = h_val * lambda_val\n        \n        # Check stability for AM-2 and AM-4\n        is_stable_am2 = check_stability_am2(z)\n        is_stable_am4 = check_stability_am4(z)\n        \n        results.append([is_stable_am2, is_stable_am4])\n\n    # Format the final output string exactly as specified.\n    # e.g., [[True,False],[True,True],[False,False]]\n    # No spaces within the inner lists.\n    # The boolean values should be capitalized True/False in Python, which translates to\n    # the required literal in the output.\n    formatted_inner_lists = [f\"[{str(r[0])},{str(r[1])}]\" for r in results]\n    output_string = f\"[{','.join(formatted_inner_lists)}]\"\n    \n    # Python bool `str` converts to 'True' and 'False'. This is not what the problem asks.\n    # It wants a literal boolean, not a string. Let's rebuild the string.\n    # A cleaner way to generate the required string format without quotes.\n    py_results = [[True, True], [True, False], [False, False]] # Based on manual calc\n    output_str_final = str(py_results).replace(\" \", \"\") # This will give [[True,False],...]\n    \n    # Let's run the code to be sure.\n    final_results_str = str(results).replace(\" \", \"\").replace(\"True\", \"True\").replace(\"False\", \"False\")\n\n    print(final_results_str)\n\nsolve()\n```", "id": "2371562"}]}