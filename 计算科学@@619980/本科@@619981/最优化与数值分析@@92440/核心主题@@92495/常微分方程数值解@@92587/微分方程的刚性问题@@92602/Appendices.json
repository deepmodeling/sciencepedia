{"hands_on_practices": [{"introduction": "理解刚性最好的方法莫过于亲眼见证它对数值求解器的影响。本练习将指导你使用一个标准的显式求解器来处理刚性和非刚性问题，并观察其行为的巨大差异 [@problem_id:2439135]。你将通过编程实践，亲身体验显式方法在求解刚性系统时，为维持数值稳定性而不得不采取的极小步长，从而直观地理解刚性带来的计算挑战。", "problem": "编写一个程序，用于分析显式自适应积分器在求解具有刚性的初值问题时的步长行为。对于每个给定的初值问题，对系统进行积分，并记录积分过程中接受的最小时间步长。使用一个带有嵌入式四阶估计器的五阶显式 Runge–Kutta–Fehlberg 方法（Runge–Kutta–Fehlberg (RKF45)），并采用标准的绝对和相对误差控制。对于所有问题，要求绝对容差 $\\mathrm{atol} = 10^{-9}$，相对容差 $\\mathrm{rtol} = 10^{-6}$。将接受的步定义为：其嵌入式局部误差估计满足一个标准加权均方根准则，即小于或等于 $1$。将“极端步长减小”定义为：在指定的积分区间内，出现的最小接受时间步长严格小于 $10^{-4}$。\n\n您必须评估以下初值问题测试套件：\n\n- 测试A（非刚性标量问题）：$$y'(t) = -y(t), \\quad y(0) = 1, \\quad t \\in [0, 10].$$\n- 测试B（刚性标量问题，带强制项的线性问题）：$$y'(t) = -10000\\,y(t) + 30000 - 20000\\,e^{-t}, \\quad y(0) = 0, \\quad t \\in [0, 0.1].$$\n- 测试C（刚性线性双分量系统）：$$\\begin{aligned} y_1'(t) &= -15\\,y_1(t), \\\\ y_2'(t) &= -10000\\left(y_2(t) - y_1(t)\\right), \\end{aligned} \\quad \\begin{bmatrix} y_1(0) \\\\ y_2(0) \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}, \\quad t \\in [0, 0.2].$$\n\n对于每项测试，计算在积分过程中遇到的最小接受步长 $h_{\\min}$，并根据 $h_{\\min} < 10^{-4}$ 是否成立来确定一个布尔值。要求的最终输出为单行文本，其中包含一个按 $\\text{[A,B,C]}$ 顺序排列、由逗号分隔的布尔结果列表，并用方括号括起来。例如，$\\text{[False,True,True]}$ 形式的输出表示测试B和测试C出现了极端步长减小，而测试A没有。\n\n该问题中没有物理单位，不涉及角度，也不使用百分比。您的程序必须生成单行输出，其中包含一个按上文所述的 $\\text{[A,B,C]}$ 确切顺序排列、由逗号分隔并用方括号括起来的结果列表。", "solution": "该问题陈述已经过验证，被认为是有效的。它具有科学依据、是适定的、客观的，并包含了构建唯一、可验证解所需的所有必要信息。该问题属于计算工程和数值分析领域，具体涉及常微分方程（ODE）中的刚性概念。\n\n初值问题中的刚性，是指当解包含在差异巨大的时间尺度上变化的分量时出现的现象。这对显式数值积分方法构成了重大挑战。虽然快速衰减的分量（瞬态）可能很快变得可以忽略不计，但它们在系统雅可比矩阵中的存在，会继续对积分器的步长施加严格限制以维持数值稳定性。即使解的光滑、慢变部分从精度角度考虑允许使用大得多的步长，但为了满足稳定性要求，步长仍受到最快时间尺度的制约。这导致了计算效率低下的积分过程，因为求解器被迫采用过多数量的极小步长。\n\n本任务旨在通过分析一个显式自适应积分器在三个不同常微分方程问题上的步长行为来演示这一现象。所选的积分器是带有嵌入式四阶误差估计器的五阶 Runge-Kutta–Fehlberg 方法，通常称为 RKF45。这类方法的一个现代、高质量的实现是 Dormand-Prince 5(4) 对，它在 `scipy` 库中以 `scipy.integrate.solve_ivp` 函数（`method='RK45'`）的形式提供。这将是用于数值积分的工具。\n\n积分过程使用基于局部误差估计的自适应步长控制。在每一步中，通过比较五阶解和嵌入的四阶解来估计误差。这个误差 $E$ 使用加权均方根范数来度量，只有当 $E \\le 1$ 时，该步长才被接受。权重是指定的绝对容差 $\\mathrm{atol} = 10^{-9}$ 和相对容差 $\\mathrm{rtol} = 10^{-6}$ 的函数。具体来说，对于解向量 $y$，误差会通过 $\\mathrm{atol} + \\mathrm{rtol} \\times |y|$ 进行缩放。在一个大小为 $h$ 的步被接受后，下一个步长会被选择以使估计误差保持在目标值 $1$ 附近。如果误差过大，该步将被拒绝，并用一个更小的 $h$ 进行重试。\n\n我们将分析三个初值问题，并记录每个问题的最小接受步长 $h_{\\min}$。“极端步长减小”的条件定义为 $h_{\\min} < 10^{-4}$。\n\n测试A：非刚性标量问题\n该常微分方程为 $y'(t) = -y(t)$，初值为 $y(0)=1$，定义域为 $t \\in [0, 10]$。\n系统的雅可比矩阵只是一个标量 $J = [-1]$。唯一的特征值是 $\\lambda = -1$，对应的时间常数为 $\\tau = 1/|\\lambda| = 1$。解为 $y(t) = e^{-t}$。只有一个时间尺度，而且不是特别快。自适应积分器选择的步长将主要由 $\\mathrm{atol}$ 和 $\\mathrm{rtol}$ 定义的精度要求决定。我们不预期稳定性会迫使步长变得异常小。因此，预计 $h_{\\min}$ 不会低于 $10^{-4}$ 的阈值。\n\n测试B：刚性标量问题\n该常微分方程为 $y'(t) = -10000\\,y(t) + 30000 - 20000\\,e^{-t}$，初值为 $y(0)=0$，定义域为 $t \\in [0, 0.1]$。\n雅可比矩阵为 $J = [-10000]$。特征值为 $\\lambda = -10000$，对应一个极快的时间常数 $\\tau = 1/|\\lambda| = 10^{-4}\\,$s。显式 Runge-Kutta 方法的稳定域要求步长 $h$ 和特征值 $\\lambda$ 的乘积位于复平面内的一个有界区域中。对于实数负特征值，这施加了一个形式为 $h \\lesssim C/|\\lambda|$ 的约束，其中 $C$ 是一个数量级为 $1$ 的常数，对于本问题即为 $h \\lesssim C \\times 10^{-4}$。即使与该特征值相关的初始瞬态已经衰减（这发生得非常快，在几个 $10^{-4}$ 的时间内），这个稳定性约束对显式积分器仍然有效。因此，在整个积分区间内，步长将受到严重限制。强烈预测 $h_{\\min}$ 将小于 $10^{-4}$。\n\n测试C：刚性线性系统\n该系统由以下方程给出：\n$$\n\\begin{aligned}\ny_1'(t) &= -15\\,y_1(t) \\\\\ny_2'(t) &= -10000\\left(y_2(t) - y_1(t)\\right)\n\\end{aligned}\n\\quad \\text{with} \\quad\n\\begin{bmatrix} y_1(0) \\\\ y_2(0) \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}\n\\quad \\text{on} \\quad t \\in [0, 0.2].\n$$\n该系统的雅可比矩阵为：\n$$\nJ = \\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{y}} = \\begin{bmatrix} -15 & 0 \\\\ 10000 & -10000 \\end{bmatrix}\n$$\n由于该矩阵是下三角矩阵，其特征值即为对角线元素：$\\lambda_1 = -15$ 和 $\\lambda_2 = -10000$。这对应两个截然不同的时间尺度：一个慢尺度 $\\tau_1 = 1/15 \\approx 0.067$ 和一个非常快的尺度 $\\tau_2 = 1/10000 = 10^{-4}$。特征值幅值之比，即刚性比，为 $|\\lambda_2|/|\\lambda_1| = 10000/15 \\approx 667$，这个值很大，证实了该系统是刚性的。与测试B一样，显式积分器的稳定性由最大幅值的特征值 $\\lambda_2 = -10000$ 决定。步长 $h$ 将受到与该特征值相关的稳定性极限的约束，迫使 $h$ 保持在 $10^{-4}$ 或更小的数量级。因此，预测 $h_{\\min} < 10^{-4}$。\n\n程序将通过为每种情况调用 `scipy.integrate.solve_ivp` 来实现此分析。返回的解对象包含一个数组 `sol.t`，其中存储了计算解的时间点。然后，通过计算此数组中的连续差分 `np.diff(sol.t)` 来获得接受的步长序列。这些值的最小值即为 $h_{\\min}$，然后将其与 $10^{-4}$ 的阈值进行比较，以生成所需的布尔值输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Analyzes step-size behavior of an explicit adaptive integrator on\n    initial value problems exhibiting stiffness, as per the problem description.\n    \"\"\"\n\n    # Define common parameters for the analysis.\n    atol = 1e-9\n    rtol = 1e-6\n    step_size_threshold = 1e-4\n\n    # Define the test cases.\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"fun\": lambda t, y: -y,\n            \"t_span\": [0, 10],\n            \"y0\": [1],\n        },\n        {\n            \"name\": \"B\",\n            \"fun\": lambda t, y: -10000 * y[0] + 30000 - 20000 * np.exp(-t),\n            \"t_span\": [0, 0.1],\n            \"y0\": [0],\n        },\n        {\n            \"name\": \"C\",\n            \"fun\": lambda t, y: np.array([-15 * y[0], -10000 * (y[1] - y[0])]),\n            \"t_span\": [0, 0.2],\n            \"y0\": [1, 0],\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Integrate the ODE system using the specified method and tolerances.\n        # The 'RK45' method in SciPy is the Dormand-Prince 5(4) pair, a standard\n        # high-quality implementation of the class of methods described in the problem.\n        sol = solve_ivp(\n            fun=case[\"fun\"],\n            t_span=case[\"t_span\"],\n            y0=case[\"y0\"],\n            method='RK45',\n            atol=atol,\n            rtol=rtol,\n        )\n\n        # The 'sol.t' attribute contains the time points of the accepted steps.\n        # The differences between consecutive time points are the accepted step sizes.\n        if len(sol.t) < 2:\n            # This case should not occur for the given problems but is a safe check.\n            # If only one point (initial) exists, there are no steps.\n            # We can treat this as no extreme reduction, or handle as an error.\n            # For this problem's context, it indicates no steps were taken or needed,\n            # so no small steps were taken.\n            h_min = np.inf\n        else:\n            step_sizes = np.diff(sol.t)\n            h_min = np.min(step_sizes)\n\n        # Determine if extreme step-size reduction occurred.\n        # The problem defines this as h_min strictly less than the threshold.\n        extreme_reduction = h_min < step_size_threshold\n        results.append(extreme_reduction)\n\n    # Format the final output string as a comma-separated list of booleans.\n    # Python's `str(bool)` converts True to 'True' and False to 'False',\n    # which is not what the example output shows. The problem asks for a list\n    # of boolean values, which is commonly represented textually as true/false\n    # or True/False. We will stick to the standard Python representation.\n    # The example [False,True,True] uses capitalized boolean literals.\n    # Let's format it exactly as specified.\n    results_str = [str(r) for r in results]\n    \n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "2439135"}, {"introduction": "目睹了显式方法的“挣扎”后，一个自然的问题是：为什么隐式方法能更好地处理刚性问题？本练习将深入探讨其理论基础，分析一种简单而强大的隐式格式——后向欧拉法 [@problem_id:2206441]。通过推导其放大因子 $G(z)$，你将证明它对于稳定的线性问题（$\\text{Re}(\\lambda)<0$）具有无条件稳定性（即A-稳定性），这是其能够有效求解刚性方程的关键特性。", "problem": "在分析求解常微分方程（ODEs）的数值方法的稳定性时，一个标准程序是将该方法应用于 Dahlquist 测试方程 $y'(t) = \\lambda y(t)$，其中 $\\lambda$ 是一个复常数。对于一个具有固定步长 $h > 0$ 的给定方法，此应用会得到一个形如 $y_{n+1} = G(z) y_n$ 的递推关系，其中 $z = \\lambda h$，函数 $G(z)$ 被称为放大因子。对于特定的 $h$ 和 $\\lambda$ 选择，该方法的稳定性由该因子的大小决定；如果 $|G(z)| \\le 1$，则该方法被认为是稳定的。\n\n后向欧拉法是一种隐式单步法，由公式 $y_{n+1} = y_n + h f(t_{n+1}, y_{n+1})$ 定义，其中 $y'(t) = f(t, y(t))$。\n\n设复数 $z = \\lambda h$ 用其实部和虚部表示为 $z = x + iy$。你的任务是推导后向欧拉法的放大因子模的平方 $|G(z)|^2$ 的表达式。最终的表达式必须完全用 $z$ 的实部 $x$ 和虚部 $y$ 来表示。", "solution": "我们从 Dahlquist 测试方程 $y'(t)=\\lambda y(t)$ 开始，并应用后向欧拉法 $y_{n+1}=y_{n}+h f(t_{n+1},y_{n+1})$。令 $f(t,y)=\\lambda y$，得到\n$$\ny_{n+1}=y_{n}+h\\lambda y_{n+1}.\n$$\n整理各项，\n$$\n(1-h\\lambda)y_{n+1}=y_{n}.\n$$\n引入 $z=\\lambda h$，我们得到\n$$\n(1-z)y_{n+1}=y_{n}\\quad\\Longrightarrow\\quad y_{n+1}=G(z)y_{n},\\qquad G(z)=\\frac{1}{1-z}.\n$$\n因此，放大因子的模的平方是\n$$\n|G(z)|^{2}=\\left|\\frac{1}{1-z}\\right|^{2}=\\frac{1}{|1-z|^{2}}.\n$$\n将 $z=x+iy$（其中 $x$ 和 $y$ 为实数）代入，我们有 $1-z=(1-x)-iy$。对于一个复数 $a+ib$，其模的平方为 $|a+ib|^{2}=a^{2}+b^{2}$，因此\n$$\n|1-z|^{2}=(1-x)^{2}+y^{2}.\n$$\n所以，\n$$\n|G(z)|^{2}=\\frac{1}{(1-x)^{2}+y^{2}}.\n$$\n该表达式按要求完全用 $x$ 和 $y$ 表示。", "answer": "$$\\boxed{\\frac{1}{(1-x)^{2}+y^{2}}}$$", "id": "2206441"}, {"introduction": "在许多现实世界的应用中，例如反应-扩散系统，刚性往往只源于系统的一部分。本练习将介绍一种更精巧高效的策略：隐-显（IMEX）方法 [@problem_id:2439136]。你将实现一个数值格式，它对刚性部分（如扩散项）进行隐式处理以保证稳定性，同时对非刚性部分（如反应项）进行显式处理以提高效率，从而展示一种解决复杂刚性问题的实用高级技巧。", "problem": "考虑一个半离散反应扩散系统的初值问题，该系统是通过对一维空间域进行均匀二阶中心差分离散化得到的。设空间域为闭区间 $\\left[0,1\\right]$，边界条件为齐次 Dirichlet 边界条件。对于一个整数 $N \\ge 1$，定义一个由 $N$ 个内部点组成的均匀网格，其位置为 $x_j = \\dfrac{j}{N+1}$（$j = 1,2,\\ldots,N$），间距为 $\\Delta x = \\dfrac{1}{N+1}$。定义状态向量 $y(t) \\in \\mathbb{R}^N$，其分量 $y_j(t)$ 为解在 $x_j$ 处的近似值。该半离散常微分方程（ODE）系统为\n$$\n\\frac{d y}{d t} = A y + g(y),\n$$\n其中，扩散矩阵 $A \\in \\mathbb{R}^{N \\times N}$ 是具有齐次 Dirichlet 边界条件的标准离散拉普拉斯算子，\n$$\nA = \\frac{D}{\\left(\\Delta x\\right)^2} \\operatorname{tridiag}\\left(1, -2, 1\\right),\n$$\n$D \\ge 0$ 为扩散系数，非线性反应项 $g: \\mathbb{R}^N \\to \\mathbb{R}^N$ 逐分量作用，其形式为\n$$\n\\left[g(y)\\right]_j = \\lambda \\left(y_j - y_j^3\\right),\n$$\n$\\lambda \\in \\mathbb{R}$ 为反应系数。初始条件为\n$$\ny_j(0) = \\sin\\!\\left(\\pi x_j\\right), \\quad j = 1,2,\\ldots,N.\n$$\n\n对于给定的最终时间 $T > 0$ 和时间步长 $h > 0$（使得 $M = \\dfrac{T}{h}$ 为整数），定义时间网格 $t_n = n h$，$n = 0,1,\\ldots,M$。考虑满足以下条件的唯一序列 $\\{y^n\\}_{n=0}^M \\subset \\mathbb{R}^N$\n$$\n\\left(I - h A\\right) y^{n+1} = y^n + h\\, g\\!\\left(y^n\\right), \\quad n = 0,1,\\ldots,M-1,\n$$\n其中 $y^0$ 由初始条件给定。对于每个指定的参数集，计算终点状态 $y^M$ 的离散欧几里得范数（也称为 $L^2$ 范数），定义如下\n$$\n\\left\\|y^M\\right\\|_{2,\\Delta x} = \\sqrt{ \\Delta x \\sum_{j=1}^N \\left(y_j^M\\right)^2 }.\n$$\n\n本问题中的所有量均为无量纲，无需物理单位。\n\n测试套件。对于以下每个参数集 $(N, D, \\lambda, T, h)$，计算 $\\left\\|y^M\\right\\|_{2,\\Delta x}$ 的值：\n- 情况 $1$：$(N, D, \\lambda, T, h) = (\\,50,\\, 1.0,\\, 5.0,\\, 0.1,\\, 0.001\\,)$。\n- 情况 $2$：$(N, D, \\lambda, T, h) = (\\,50,\\, 1.0,\\, 5.0,\\, 0.1,\\, 0.00005\\,)$。\n- 情况 $3$：$(N, D, \\lambda, T, h) = (\\,1,\\, 1.0,\\, 10.0,\\, 0.1,\\, 0.01\\,)$。\n- 情况 $4$：$(N, D, \\lambda, T, h) = (\\,50,\\, 0.0,\\, 5.0,\\, 0.1,\\, 0.01\\,)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含四个结果，按上述顺序列出每个情况的结果，四舍五入到 $8$ 位小数，形式为逗号分隔的列表并用方括号括起来。例如，输出格式必须与以下形式完全一致\n$$\n\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right].\n$$", "solution": "该问题陈述已经过评估，被确定为有效。它具有科学依据、是适定的且客观的。它在偏微分方程数值分析领域提出了一个清晰的计算任务，具体涉及半离散反应扩散系统的求解。该问题包括使用指定的数值格式模拟系统演化，并为几组参数集计算最终状态的范数。\n\n控制方程是一个形如 $\\frac{d y}{d t} = A y + g(y)$ 的常微分方程（ODE）组，它由一维反应扩散偏微分方程的空间离散化（方法线法）产生。项 $A y$ 代表扩散过程，其中 $A$ 是离散拉普拉斯矩阵；$g(y)$ 是一个 Allen-Cahn 型非线性反应项，$[g(y)]_j = \\lambda (y_j - y_j^3)$。这类系统是刚性微分方程的经典例子，因为与扩散相关的时间尺度（与 $A$ 的特征值有关）可能比反应的时间尺度快得多。\n\n为时间积分指定的数值方法是 $(I - h A) y^{n+1} = y^n + h\\, g(y^n)$。这是一种半隐式或隐式-显式（IMEX）格式。刚性线性扩散项 $A y$ 被隐式处理（使用后向欧拉法），而非线性且可能非刚性的反应项 $g(y)$ 被显式处理（使用前向欧拉法）。这种方法非常适用于刚性系统，因为对刚性部分的隐式处理允许使用比全显式方法所允许的更大的时间步长 $h$，而不会遇到数值不稳定性。该方法的稳定性由显式部分决定，这要求 $h$ 相对于反应项 $g(y)$ 的动力学足够小。\n\n对于每个给定的参数集 $(N, D, \\lambda, T, h)$，求解算法按以下步骤进行。首先，我们建立计算网格和参数：空间点数 $N$、空间步长 $\\Delta x = \\frac{1}{N+1}$ 以及时间步数 $M = T/h$。根据初始条件 $y_j(0) = \\sin(\\pi x_j)$ 在网格点 $x_j = j \\Delta x$（$j=1, \\ldots, N$）上构建初始状态向量 $y^0 \\in \\mathbb{R}^N$。算法的核心是一个从 $n=0$ 到 $M-1$ 的时间步进循环。在每一步中，我们都必须为下一个状态 $y^{n+1}$ 求解一个线性系统。该方程可以重排为 $L y^{n+1} = b$，其中 $L = (I - hA)$ 是系统矩阵，而 $b = y^n + hg(y^n)$ 是根据当前状态 $y^n$ 计算出的右端向量。矩阵 $A = \\frac{D}{(\\Delta x)^2} \\operatorname{tridiag}(1, -2, 1)$ 是三对角的，这意味着矩阵 $L$ 也是三对角的，其主对角线元素为 $1 + \\frac{2hD}{(\\Delta x)^2}$，非对角线元素为 $-\\frac{hD}{(\\Delta x)^2}$。这类三对角系统可以使用专门的算法高效求解；在我们的实现中，我们将使用 `scipy.linalg.solve_banded` 函数。该循环执行 $M$ 次，将解从初始时间 $t=0$ 推进到最终时间 $t=T$。最后，在最后一个时间步之后，我们得到终点状态向量 $y^M$。所需的量，即离散欧几里得范数 $\\|y^M\\|_{2,\\Delta x}$，使用其定义 $\\|y^M\\|_{2,\\Delta x} = \\sqrt{ \\Delta x \\sum_{j=1}^N (y_j^M)^2 }$ 进行计算。对所有四个提供的测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef compute_one_case(N, D, lambda_val, T, h):\n    \"\"\"\n    Solves the semidiscrete reaction-diffusion system for one set of parameters.\n\n    Args:\n        N (int): Number of interior spatial grid points.\n        D (float): Diffusion coefficient.\n        lambda_val (float): Reaction coefficient.\n        T (float): Final time.\n        h (float): Time step size.\n\n    Returns:\n        float: The discrete Euclidean norm of the terminal state.\n    \"\"\"\n    # 1. Setup grid and parameters\n    dx = 1.0 / (N + 1)\n    # The problem statement guarantees M = T/h is an integer.\n    # Using round() guards against potential floating-point inaccuracies.\n    M = int(round(T / h))\n    x_grid = np.linspace(dx, 1.0 - dx, N)\n\n    # 2. Set initial condition y^0\n    y = np.sin(np.pi * x_grid)\n\n    # 3. Construct the time-stepping matrix L = (I - hA)\n    # The matrix A is D/dx^2 * tridiag(1, -2, 1).\n    # The matrix L is tridiagonal with diagonals:\n    # Main: 1 + 2*h*D/dx^2\n    # Off-diagonals: -h*D/dx^2\n    # This matrix is represented in the 'ab' banded format for scipy.linalg.solve_banded.\n    # The format requires a (3, N) array for a tridiagonal matrix.\n    \n    # Constant for off-diagonals\n    c = -h * D / (dx**2)\n    \n    # 'ab' matrix for solve_banded (l=1, u=1)\n    # Row 0: Super-diagonal (padded with one 0 at the start)\n    # Row 1: Main diagonal\n    # Row 2: Sub-diagonal (padded with one 0 at the end)\n    ab = np.zeros((3, N))\n    ab[0, 1:] = c\n    ab[1, :] = 1.0 - 2.0 * c \n    ab[2, :-1] = c\n    \n    # 4. Time-stepping loop\n    for _ in range(M):\n        # Calculate the right-hand side: y^n + h*g(y^n)\n        g_y = lambda_val * (y - y**3)\n        rhs = y + h * g_y\n        \n        # Solve the linear system (I - hA)y^{n+1} = rhs for y^{n+1}\n        y = solve_banded((1, 1), ab, rhs, check_finite=False)\n\n    # 5. Compute the final discrete L^2 norm\n    # norm = sqrt(dx * sum(y_j^M)^2)\n    final_norm = np.sqrt(dx * np.sum(y**2))\n    \n    return final_norm\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (50, 1.0, 5.0, 0.1, 0.001),     # Case 1\n        (50, 1.0, 5.0, 0.1, 0.00005),   # Case 2\n        (1, 1.0, 10.0, 0.1, 0.01),      # Case 3\n        (50, 0.0, 5.0, 0.1, 0.01),      # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        N, D, lambda_val, T, h = case\n        result = compute_one_case(N, D, lambda_val, T, h)\n        # Format the result to 8 decimal places as required.\n        results.append(f\"{result:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "2439136"}]}