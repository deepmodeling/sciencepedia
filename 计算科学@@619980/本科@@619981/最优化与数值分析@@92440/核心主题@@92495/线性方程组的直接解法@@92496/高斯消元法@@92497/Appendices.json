{"hands_on_practices": [{"introduction": "掌握了理论之后，让我们通过一个基础练习来巩固高斯消元法的核心步骤。这个练习将引导你处理一个简单的 $2 \\times 2$ 线性方程组，其目标是熟练运用行变换将增广矩阵化为行阶梯形，并使用回代法求解。这是掌握高斯消元法并解决更复杂问题的基石 [@problem_id:23110]。", "problem": "考虑以下包含两个变量 $x$ 和 $y$ 的线性方程组：\n$$\n\\begin{cases}\n3x + 5y = 1 \\\\\n4x + 2y = 6\n\\end{cases}\n$$\n你的任务是求出变量 $x$ 的值。为此，你必须使用高斯消元法。该过程包括以下几个阶段：\n1.  将方程组表示为增广矩阵。\n2.  使用初等行变换将增广矩阵变换为行阶梯形矩阵。一个矩阵为行阶梯形矩阵，需满足：\n    - 所有非零行都位于全零行的上方。\n    - 非零行的首个非零元素（从左起第一个非零数，也称主元）严格位于其上方一行的首个非零元素的右侧。\n3.  根据行阶梯形矩阵重新写出方程组。\n4.  使用回代法求出 $x$ 和 $y$ 的唯一解。\n\n推导出 $x$ 的值。", "solution": "我们将该方程组表示为增广矩阵：\n$$\n\\left[\\begin{array}{cc|c}\n3 & 5 & 1\\\\\n4 & 2 & 6\n\\end{array}\\right]\n$$\n\n进行消元操作 $R_2\\leftarrow R_2-\\frac{4}{3}R_1$：\n$$\n\\left[\\begin{array}{cc|c}\n3 & 5 & 1\\\\\n0 & -\\frac{14}{3} & \\frac{14}{3}\n\\end{array}\\right]\n$$\n\n由第二行可得 $-\\tfrac{14}{3}y=\\tfrac{14}{3}$，所以 $y=-1$。将其代入第一行，\n$$\n3x+5(-1)=1\\implies3x-5=1\\implies3x=6\\implies x=2.\n$$", "answer": "$$\\boxed{2}$$", "id": "23110"}, {"introduction": "高斯消元法的威力不仅在于求解具有唯一解的系统。本练习将引导你探索当方程组存在无穷多解时的情形 [@problem_id:2175262]。通过这个实践，你将学会如何从行阶梯形矩阵中识别出自由变量，并理解解集在几何上构成的对象——一条直线，从而建立代数操作与几何直觉之间的深刻联系。", "problem": "考虑下列含三个变量 $x_1, x_2, x_3$ 的线性方程组：\n$$\n\\begin{cases}\nx_1 + x_2 + x_3 = 6 \\\\\n2x_1 - x_2 + 3x_3 = 9 \\\\\n4x_1 + x_2 + 5x_3 = 21\n\\end{cases}\n$$\n该方程组的所有解 $(x_1, x_2, x_3)$ 的集合在三维空间 $\\mathbb{R}^3$ 中构成一个几何对象。下列哪个选项正确地描述了这个对象？\n\nA. 一个点\n\nB. 一条直线\n\nC. 一个平面\n\nD. 空集\n\nE. 整个三维空间 $\\mathbb{R}^3$", "solution": "每个线性方程在 $\\mathbb{R}^{3}$ 中代表一个平面；它们的公共解集就是这些平面的交集。为了确定交集的类型，我们通过高斯消元法来分析该方程组。\n\n从对应于以下方程组的增广矩阵开始：\n$$\n\\begin{cases}\nx_{1} + x_{2} + x_{3} = 6 \\\\\n2x_{1} - x_{2} + 3x_{3} = 9 \\\\\n4x_{1} + x_{2} + 5x_{3} = 21\n\\end{cases}\n$$\n应用行变换：\n1) $R_{2} \\leftarrow R_{2} - 2R_{1}$ 得到 $[0,\\,-3,\\,1\\,|\\,-3]$。\n2) $R_{3} \\leftarrow R_{3} - 4R_{1}$ 得到 $[0,\\,-3,\\,1\\,|\\,-3]$。\n3) $R_{3} \\leftarrow R_{3} - R_{2}$ 得到 $[0,\\,0,\\,0\\,|\\,0]$。\n\n因此，化简后的方程组为\n$$\n\\begin{cases}\nx_{1} + x_{2} + x_{3} = 6 \\\\\n-3x_{2} + x_{3} = -3 \\\\\n0=0\n\\end{cases}\n$$\n没有出现矛盾情况，因此该方程组是相容的。系数矩阵的秩为 $2$（即有两个线性无关的方程），增广矩阵的秩也为 $2$。有 $3$ 个变量，秩为 $2$，因此解集的维数是 $3-2=1$，这在 $\\mathbb{R}^3$ 中是一条仿射直线。\n\n因此，该几何对象是一条直线。", "answer": "$$\\boxed{B}$$", "id": "2175262"}, {"introduction": "最后的这个实践将理论与实际应用联系起来，展示了高斯消元法在科学计算中的强大威力。你将面对一个源于物理学（热传导）离散化后产生的特定结构（三对角）的大型线性系统。这个练习要求你实现一个为三对角系统量身定制的高效算法，并分析其线性时间复杂度（$O(N)$），从而深刻体会算法效率在解决实际工程问题中的重要性 [@problem_id:2396200]。", "problem": "考虑由以下边值问题描述的一维稳态热传导模型\n$$\n-\\dfrac{d}{dx}\\!\\left(k(x)\\,\\dfrac{du}{dx}\\right) = q(x), \\quad x \\in (0,1), \\quad u(0)=0,\\; u(1)=0,\n$$\n其中 $k(x)$ 是热导率，$q(x)$ 是体积源项。使用具有 $N$ 个内部节点的均匀网格，网格间距为 $h = \\dfrac{1}{N+1}$，节点位置为 $x_i = i\\,h$，其中 $i=1,2,\\dots,N$。在节点 $i$ 处的守恒二阶有限差分格式使用界面热导率 $k_{i+\\tfrac{1}{2}} = k\\!\\left(x_i + \\dfrac{h}{2}\\right)$ 和 $k_{i-\\tfrac{1}{2}} = k\\!\\left(x_i - \\dfrac{h}{2}\\right)$，产生如下形式的三对角线性系统\n$$\n-\\,k_{i-\\tfrac{1}{2}}\\,u_{i-1} + \\left(k_{i-\\tfrac{1}{2}} + k_{i+\\tfrac{1}{2}}\\right) u_i - k_{i+\\tfrac{1}{2}}\\,u_{i+1} = q(x_i)\\,h^2, \\quad i=1,2,\\dots,N,\n$$\n其中 $u_0=0$ 且 $u_{N+1}=0$。当 $k(x) \\ge \\kappa_{\\min} &gt; 0$ 且 $q(x)$ 有界时，系数矩阵是严格对角占优的，这保证了唯一解的存在。\n\n编写一个完整、可运行的程序，该程序：\n- 不接受任何输入，仅使用下面指定的参数值。\n- 为每个指定情况构建由上述离散化所隐含的三对角系统的三条对角线。\n- 通过应用针对三对角矩阵的直接消去法及随后的回代来求解每个系统。\n- 为了验证正确性，将计算出的解向量与通过通用求解器求解相应稠密线性系统得到的解进行比较，并报告最大绝对差。\n- 为了验证计算复杂度，在保持所有其他参数固定的情况下，当系统规模 $N$ 加倍时，凭经验测量求解时间，并报告观察到的时间比率是否与线性时间 $O(N)$ 复杂度一致。\n\n使用以下参数值测试套件：\n- 情况 A（均匀属性）：\n  - 对所有 $x \\in [0,1]$，$k(x) = 1$，\n  - 对所有 $x \\in [0,1]$，$q(x) = 2$，\n  - $N = 10$。\n  - 要求结果：三对角直接求解得到的解与稠密矩阵通用求解器得到的解之间的最大绝对差，以浮点数表示。\n- 情况 B（边界尺寸的边缘情况）：\n  - 对所有 $x \\in [0,1]$，$k(x) = 1$，\n  - 对所有 $x \\in [0,1]$，$q(x) = 2$，\n  - $N = 1$。\n  - 要求结果：单个内部解的值 $u_1$，以浮点数表示。\n- 情况 C（可变热导率）：\n  - 对所有 $x \\in [0,1]$，$k(x) = 1 + x$，\n  - 对所有 $x \\in [0,1]$，$q(x) = 1$，\n  - $N = 15$。\n  - 要求结果：三对角直接求解得到的解与稠密矩阵通用求解器得到的解之间的最大绝对差，以浮点数表示。\n- 情况 D（经验性复杂度验证）：\n  - 对所有 $x \\in [0,1]$，$k(x) = 1$，\n  - 对所有 $x \\in [0,1]$，$q(x) = 2$，\n  - 求解规模 $N \\in \\{4000,\\,8000,\\,16000\\}$，\n  - 通过对重复求解取平均来测量每个 $N$ 的系统求解时间，然后计算时间比率 $T(8000)/T(4000)$ 和 $T(16000)/T(8000)$。返回一个布尔值，表示两个比率是否都位于区间 $[1.6,\\,2.5]$ 内。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\text{情况 A 结果}, \\text{情况 B 结果}, \\text{情况 C 结果}, \\text{情况 D 结果}]$。例如，一个有效的输出形式是 $[x_1,x_2,x_3,x_4]$，其中 $x_1$、$x_2$ 和 $x_3$ 是浮点数，$x_4$ 是一个布尔值。", "solution": "该边值问题\n$$\n-\\dfrac{d}{dx}\\!\\left(k(x)\\,\\dfrac{du}{dx}\\right) = q(x), \\quad x \\in (0,1), \\quad u(0)=0,\\; u(1)=0,\n$$\n在一个具有 $N$ 个内部节点、间距为 $h=\\dfrac{1}{N+1}$、节点为 $x_i = i\\,h$（$i=1,2,\\dots,N$）的均匀网格上进行离散化。守恒的有限体积或有限差分公式在半网格界面上使用谐波通量。记\n$$\nk_{i+\\tfrac{1}{2}} = k\\!\\left(x_i + \\dfrac{h}{2}\\right), \\qquad k_{i-\\tfrac{1}{2}} = k\\!\\left(x_i - \\dfrac{h}{2}\\right).\n$$\n对围绕 $x_i$ 的单元上的通量散度进行近似，得到\n$$\n-\\dfrac{1}{h}\\left(\\dfrac{k_{i+\\tfrac{1}{2}}(u_{i+1} - u_{i})}{h} - \\dfrac{k_{i-\\tfrac{1}{2}}(u_{i} - u_{i-1})}{h}\\right) = q(x_i),\n$$\n整理后可得到三对角线性系统\n$$\n-\\,k_{i-\\tfrac{1}{2}}\\,u_{i-1} + \\left(k_{i-\\tfrac{1}{2}} + k_{i+\\tfrac{1}{2}}\\right) u_i - k_{i+\\tfrac{1}{2}}\\,u_{i+1} = q(x_i)\\,h^2, \\quad i=1,2,\\dots,N,\n$$\n其中狄利克雷（Dirichlet）条件为 $u_0=0$ 和 $u_{N+1}=0$。对于 $k(x) \\ge \\kappa_{\\min} &gt; 0$，主对角线元素满足\n$$\nk_{i-\\tfrac{1}{2}} + k_{i+\\tfrac{1}{2}} \\ge \\kappa_{\\min} + \\kappa_{\\min} = 2\\,\\kappa_{\\min},\n$$\n而非对角线元素为 $-k_{i-\\tfrac{1}{2}}$ 和 $-k_{i+\\tfrac{1}{2}}$，这意味着矩阵是严格对角占优的，并有唯一解。\n\n通过专门针对三对角矩阵的高斯消元法（Gaussian elimination）的算法求解过程，首先在 $O(N)$ 次算术运算中消去下副对角线，然后进行一次 $O(N)$ 的回代。设三条对角线存储为向量\n$$\n\\ell = \\left[\\ell_1,\\dots,\\ell_{N-1}\\right], \\quad d = \\left[d_1,\\dots,d_N\\right], \\quad u = \\left[u_1,\\dots,u_{N-1}\\right],\n$$\n右端项为 $b = \\left[b_1,\\dots,b_N\\right]$。对于 $i=2$ 到 $N$ 的前向消元过程计算乘数\n$$\nm_i = \\dfrac{\\ell_{i-1}}{d_{i-1}},\n$$\n然后更新\n$$\nd_i \\leftarrow d_i - m_i\\,u_{i-1}, \\qquad b_i \\leftarrow b_i - m_i\\,b_{i-1}.\n$$\n因为 $d_{i-1} &gt; 0$ 并且严格对角占优成立，所以不会发生除以零的情况。消元后，系统变为上三角形式，其上对角线 $u$ 不变，主对角线变为修改后的 $d$。回代过程设置\n$$\nx_N = \\dfrac{b_N}{d_N}, \\qquad x_i = \\dfrac{b_i - u_i\\,x_{i+1}}{d_i} \\quad \\text{for } i=N-1,\\dots,1.\n$$\n这正是高斯消元法和回代法，但利用了三对角稀疏性来确保 $O(N)$ 的运行时间和 $O(N)$ 的存储空间。\n\n为了从热方程离散化中构建对角线，对每个 $i \\in \\{1,\\dots,N\\}$ 定义\n$$\nx_i = i\\,h, \\quad k_{i-\\tfrac{1}{2}} = k\\!\\left(x_i - \\dfrac{h}{2}\\right), \\quad k_{i+\\tfrac{1}{2}} = k\\!\\left(x_i + \\dfrac{h}{2}\\right).\n$$\n然后设置\n$$\n\\ell_{i-1} = -\\,k_{i-\\tfrac{1}{2}} \\quad (i\\ge 2), \\qquad d_i = k_{i-\\tfrac{1}{2}} + k_{i+\\tfrac{1}{2}}, \\qquad u_i = -\\,k_{i+\\tfrac{1}{2}} \\quad (i\\le N-1),\n$$\n以及\n$$\nb_i = q(x_i)\\,h^2.\n$$\n对于情况 A 和情况 B，$k(x)=1$ 且 $q(x)=2$，有 $k_{i-\\tfrac{1}{2}}=1$ 且 $k_{i+\\tfrac{1}{2}}=1$，因此 $\\ell_i=-1$，$d_i=2$，$u_i=-1$，以及 $b_i = 2\\,h^2$。对于情况 C，$k(x)=1+x$ 且 $q(x)=1$，热导率随位置线性变化但保持为正，从而保持了严格对角占优性。\n\n正确性验证通过组装稠密矩阵 $A \\in \\mathbb{R}^{N\\times N}$（其中 $A_{i,i}=d_i$，$i\\ge 2$ 时 $A_{i,i-1}=\\ell_{i-1}$，及 $i\\le N-1$ 时 $A_{i,i+1}=u_i$）来执行，然后使用最大绝对差比较专门的三对角解 $x$ 与稠密解 $A^{-1}b$\n$$\n\\|x - A^{-1}b\\|_{\\infty} = \\max_i |x_i - (A^{-1}b)_i|.\n$$\n\n为了经验性地验证 $O(N)$ 复杂度，在保持 $k(x)$ 和 $q(x)$ 固定的情况下，测量求解 $N \\in \\{4000,8000,16000\\}$ 所需的挂钟时间 $T(N)$。比率\n$$\n\\rho_1 = \\dfrac{T(8000)}{T(4000)}, \\qquad \\rho_2 = \\dfrac{T(16000)}{T(8000)}\n$$\n对于足够大的 $N$，应该接近 $2$。为减少计时噪声，应对多次重复求解的时间进行平均，并使用中位数或平均值。报告一个布尔值，指示 $\\rho_1$ 和 $\\rho_2$ 是否都位于区间 $[1.6,\\,2.5]$ 内，这个区间容纳了典型的测量变异性，同时反映了线性增长。\n\n程序计算并输出：\n- 情况 A：当 $N=10$, $k(x)=1$, $q(x)=2$ 时，等于 $\\|x - A^{-1}b\\|_{\\infty}$ 的浮点数值。\n- 情况 B：当 $N=1$, $k(x)=1$, $q(x)=2$ 时，等于 $u_1$ 的浮点数值。\n- 情况 C：当 $N=15$, $k(x)=1+x$, $q(x)=1$ 时，等于 $\\|x - A^{-1}b\\|_{\\infty}$ 的浮点数值。\n- 情况 D：当 $N \\in \\{4000,8000,16000\\}$, $k(x)=1$, $q(x)=2$ 时，等于 $\\left(\\rho_1 \\in [1.6,2.5]\\right) \\wedge \\left(\\rho_2 \\in [1.6,2.5]\\right)$ 的布尔值。\n\n最终输出是格式为 $[r_A, r_B, r_C, r_D]$ 的单行，其中 $r_A, r_B, $ 和 $r_C$ 是浮点数，$r_D$ 是一个布尔值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport time\n\ndef thomas_solve(lower, diag, upper, rhs):\n    \"\"\"\n    Solve a tridiagonal linear system Ax = rhs where:\n    - lower: subdiagonal (length n-1)\n    - diag: main diagonal (length n)\n    - upper: superdiagonal (length n-1)\n    - rhs: right-hand side (length n)\n    Returns x (length n).\n    \"\"\"\n    n = diag.size\n    # Make working copies to preserve inputs\n    c = upper.astype(float).copy()\n    d = diag.astype(float).copy()\n    b = rhs.astype(float).copy()\n\n    # Forward elimination\n    for i in range(1, n):\n        if d[i-1] == 0.0:\n            # Extremely unlikely for strictly diagonally dominant matrices\n            raise ZeroDivisionError(\"Zero pivot encountered in tridiagonal elimination.\")\n        m = lower[i-1] / d[i-1]\n        d[i] -= m * c[i-1]\n        b[i] -= m * b[i-1]\n\n    # Back substitution\n    x = np.empty(n, dtype=float)\n    x[-1] = b[-1] / d[-1]\n    for i in range(n - 2, -1, -1):\n        x[i] = (b[i] - c[i] * x[i + 1]) / d[i]\n    return x\n\ndef build_heat_tridiag(N, k_func, q_func):\n    \"\"\"\n    Build tridiagonal coefficients (lower, diag, upper) and rhs for the 1D steady heat equation:\n      -d/dx (k(x) du/dx) = q(x), u(0)=u(1)=0\n    using uniform grid with N interior points.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    x = (np.arange(1, N + 1, dtype=float)) * h\n    diag = np.empty(N, dtype=float)\n    rhs = np.empty(N, dtype=float)\n    lower = np.empty(max(N - 1, 0), dtype=float)\n    upper = np.empty(max(N - 1, 0), dtype=float)\n\n    for j in range(N):\n        xi = x[j]\n        km = k_func(xi - 0.5 * h)\n        kp = k_func(xi + 0.5 * h)\n        diag[j] = km + kp\n        rhs[j] = q_func(xi) * (h ** 2)\n        if j > 0:\n            lower[j - 1] = -km\n        if j < N - 1:\n            upper[j] = -kp\n    return lower, diag, upper, rhs\n\ndef dense_from_tridiag(lower, diag, upper):\n    \"\"\"Construct a dense matrix from tridiagonal vectors.\"\"\"\n    n = diag.size\n    A = np.zeros((n, n), dtype=float)\n    A[np.arange(n), np.arange(n)] = diag\n    if n >= 2:\n        A[np.arange(1, n), np.arange(0, n - 1)] = lower\n        A[np.arange(0, n - 1), np.arange(1, n)] = upper\n    return A\n\ndef case_A():\n    # k(x)=1, q(x)=2, N=10\n    N = 10\n    k_func = lambda x: 1.0\n    q_func = lambda x: 2.0\n    lower, diag, upper, rhs = build_heat_tridiag(N, k_func, q_func)\n    x_tridiag = thomas_solve(lower, diag, upper, rhs)\n    A = dense_from_tridiag(lower, diag, upper)\n    x_dense = np.linalg.solve(A, rhs)\n    err = float(np.max(np.abs(x_tridiag - x_dense)))\n    return err\n\ndef case_B():\n    # Edge case N=1, k(x)=1, q(x)=2\n    N = 1\n    k_func = lambda x: 1.0\n    q_func = lambda x: 2.0\n    lower, diag, upper, rhs = build_heat_tridiag(N, k_func, q_func)\n    x_tridiag = thomas_solve(lower, diag, upper, rhs)\n    return float(x_tridiag[0])\n\ndef case_C():\n    # Variable conductivity k(x)=1+x, source q(x)=1, N=15\n    N = 15\n    k_func = lambda x: 1.0 + x\n    q_func = lambda x: 1.0\n    lower, diag, upper, rhs = build_heat_tridiag(N, k_func, q_func)\n    x_tridiag = thomas_solve(lower, diag, upper, rhs)\n    A = dense_from_tridiag(lower, diag, upper)\n    x_dense = np.linalg.solve(A, rhs)\n    err = float(np.max(np.abs(x_tridiag - x_dense)))\n    return err\n\ndef time_one_size(N, repeats_inner=30, repeats_outer=5):\n    \"\"\"\n    Time the tridiagonal solve for a given N.\n    Build the system once and solve it repeats_inner times per outer repetition.\n    Return the median time per solve over outer repetitions.\n    \"\"\"\n    # Use constant coefficients k=1, q=2\n    k_func = lambda x: 1.0\n    q_func = lambda x: 2.0\n    lower, diag, upper, rhs = build_heat_tridiag(N, k_func, q_func)\n\n    times = []\n    for _ in range(repeats_outer):\n        t0 = time.perf_counter()\n        for _ in range(repeats_inner):\n            # Each solve copies arrays internally, so inputs are reusable\n            _ = thomas_solve(lower, diag, upper, rhs)\n        t1 = time.perf_counter()\n        times.append((t1 - t0) / repeats_inner)\n    # Median helps mitigate noise\n    return float(np.median(times))\n\ndef case_D():\n    sizes = [4000, 8000, 16000]\n    # Increase repeats_inner if needed to stabilize timing; chosen to be modest to keep runtime short.\n    t1 = time_one_size(sizes[0], repeats_inner=30, repeats_outer=5)\n    t2 = time_one_size(sizes[1], repeats_inner=30, repeats_outer=5)\n    t3 = time_one_size(sizes[2], repeats_inner=30, repeats_outer=5)\n    # Compute ratios\n    ratio1 = t2 / t1 if t1 > 0 else float('inf')\n    ratio2 = t3 / t2 if t2 > 0 else float('inf')\n    is_linear = (1.6 <= ratio1 <= 2.5) and (1.6 <= ratio2 <= 2.5)\n    return bool(is_linear)\n\ndef solve():\n    results = []\n    results.append(case_A())\n    results.append(case_B())\n    results.append(case_C())\n    results.append(case_D())\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2396200"}]}