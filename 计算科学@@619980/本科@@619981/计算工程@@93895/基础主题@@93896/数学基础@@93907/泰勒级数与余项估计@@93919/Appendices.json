{"hands_on_practices": [{"introduction": "在计算工程中，我们经常遇到像误差函数 $\\operatorname{erf}(x)$ 这样的特殊函数，它们没有简单的封闭形式表达式。泰勒级数提供了一种计算这些函数值的强大方法，但一个关键的实际问题是：为了达到所需的精度，我们应该计算级数的多少项？本练习将指导你使用泰勒级数的余项估计来回答这个问题，这是确保数值算法效率和准确性的基本技能。[@problem_id:2442184]", "problem": "在计算工程中，误差函数 (erf) 对实数输入的定义为\n$$\\operatorname{erf}(x) = \\frac{2}{\\sqrt{\\pi}} \\int_{0}^{x} \\exp\\!\\left(-t^{2}\\right)\\, dt.$$\n对于 $\\operatorname{erf}(x)$ 的麦克劳林级数，考虑其截断\n$$S_{N}(x) = \\sum_{n=0}^{N} c_{n}\\, x^{2n+1},$$\n其中 $c_{n}$ 是从 $\\operatorname{erf}(x)$ 在 $x=0$ 处的麦克劳林展开式中获得的系数。确定最小的整数 $N$，使得在 $S_{N}(x)$ 处截断能保证当 $x=0.5$ 时，绝对近似误差满足\n$$\\left|\\operatorname{erf}(0.5) - S_{N}(0.5)\\right| < 1.0 \\times 10^{-8}.$$\n最终答案只提供整数 $N$。", "solution": "题目陈述经验证。\n\n**步骤1：提取已知条件**\n- 误差函数定义为 $\\operatorname{erf}(x) = \\frac{2}{\\sqrt{\\pi}} \\int_{0}^{x} \\exp(-t^{2})\\, dt$。\n- 截断的麦克劳林级数为 $S_{N}(x) = \\sum_{n=0}^{N} c_{n}\\, x^{2n+1}$。\n- 求值点为 $x=0.5$。\n- 要求的绝对误差容限为 $|\\operatorname{erf}(0.5) - S_{N}(0.5)| < 1.0 \\times 10^{-8}$。\n- 目标是找到满足此条件的最小整数 $N$。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，是适定且客观的。\n- **科学依据**：误差函数、其级数展开以及截断误差分析是数学物理、数值分析和计算工程中的标准课题。所有定义都是标准和正确的。\n- **适定性**：该问题要求找到满足特定不等式的最小整数 $N$。该级数的性质确保了这样的整数存在且唯一。\n- **客观性**：该问题使用精确的数学语言陈述，没有歧义或主观内容。\n\n**步骤3：结论与行动**\n问题被认为是有效的。将制定完整的解题方案。\n\n解题过程首先确定 $\\operatorname{erf}(x)$ 的麦克劳林级数。该过程从已知的指数函数的麦克劳林级数开始：\n$$ \\exp(u) = \\sum_{k=0}^{\\infty} \\frac{u^{k}}{k!} $$\n通过代入 $u = -t^2$，我们得到被积函数的级数：\n$$ \\exp(-t^2) = \\sum_{k=0}^{\\infty} \\frac{(-t^2)^{k}}{k!} = \\sum_{k=0}^{\\infty} \\frac{(-1)^k t^{2k}}{k!} $$\n该级数具有无穷收敛半径，这允许在任何有限区间上进行逐项积分。从 $t=0$ 积分到 $t=x$：\n$$ \\int_{0}^{x} \\exp(-t^{2})\\, dt = \\int_{0}^{x} \\left( \\sum_{k=0}^{\\infty} \\frac{(-1)^k t^{2k}}{k!} \\right) dt = \\sum_{k=0}^{\\infty} \\frac{(-1)^k}{k!} \\int_{0}^{x} t^{2k}\\, dt $$\n$$ = \\sum_{k=0}^{\\infty} \\frac{(-1)^k}{k!} \\left[ \\frac{t^{2k+1}}{2k+1} \\right]_{0}^{x} = \\sum_{k=0}^{\\infty} \\frac{(-1)^k x^{2k+1}}{k!(2k+1)} $$\n根据 $\\operatorname{erf}(x)$ 的定义，乘以常数因子 $\\frac{2}{\\sqrt{\\pi}}$，得到其麦克劳林级数。为了与问题的符号系统保持一致，我们使用索引 $n$ 代替 $k$：\n$$ \\operatorname{erf}(x) = \\frac{2}{\\sqrt{\\pi}} \\sum_{n=0}^{\\infty} \\frac{(-1)^n x^{2n+1}}{n!(2n+1)} $$\n截断级数由 $S_N(x) = \\sum_{n=0}^{N} c_n x^{2n+1}$ 给出，其中系数为 $c_n = \\frac{2}{\\sqrt{\\pi}} \\frac{(-1)^n}{n!(2n+1)}$。近似误差是余项 $R_N(x) = \\operatorname{erf}(x) - S_N(x)$。\n$$ R_N(x) = \\frac{2}{\\sqrt{\\pi}} \\sum_{n=N+1}^{\\infty} \\frac{(-1)^n x^{2n+1}}{n!(2n+1)} $$\n对于任何固定的 $x > 0$，$\\operatorname{erf}(x)$ 的麦克劳林级数是一个交错级数。为了应用交错级数余项定理，我们必须验证当 $x=0.5$ 时，级数各项的绝对值是单调递减并趋于零的。设 $a_n = \\frac{2}{\\sqrt{\\pi}} \\frac{x^{2n+1}}{n!(2n+1)}$。连续项的绝对值之比为：\n$$ \\frac{a_{n+1}}{a_n} = \\frac{x^{2(n+1)+1}}{(n+1)!(2(n+1)+1)} \\cdot \\frac{n!(2n+1)}{x^{2n+1}} = \\frac{x^2 (2n+1)}{(n+1)(2n+3)} $$\n当 $x=0.5$ 时，该比值变为：\n$$ \\frac{(0.5)^2 (2n+1)}{(n+1)(2n+3)} = \\frac{0.25(2n+1)}{2n^2+5n+3} $$\n对于所有 $n \\ge 0$，分母 $2n^2+5n+3$ 严格大于分子 $0.5n+0.25$。因此，该比值总是小于 1，这证实了各项的绝对值是单调递减的。由于分母中有阶乘，当 $n \\to \\infty$ 时，各项的极限为零。\n\n交错级数余项定理指出，绝对误差 $|R_N(x)|$ 小于第一个被舍弃的项（即对应于 $n=N+1$ 的项）的绝对值。\n$$ |\\operatorname{erf}(0.5) - S_N(0.5)| = |R_N(0.5)| \\le \\left| c_{N+1} (0.5)^{2(N+1)+1} \\right| $$\n$$ |R_N(0.5)| \\le \\frac{2}{\\sqrt{\\pi}} \\frac{(0.5)^{2N+3}}{(N+1)!(2N+3)} $$\n我们要求此误差上界小于 $1.0 \\times 10^{-8}$：\n$$ \\frac{2}{\\sqrt{\\pi}} \\frac{1}{2^{2N+3}(N+1)!(2N+3)} < 10^{-8} $$\n这可简化为：\n$$ \\frac{1}{\\sqrt{\\pi} \\cdot 2^{2N+2}(N+1)!(2N+3)} < 10^{-8} $$\n我们必须找到满足此不等式的最小整数 $N$。我们对 $N$ 的值进行测试。\n当 $N=5$ 时：\n误差上界为 $\\frac{1}{\\sqrt{\\pi} \\cdot 2^{12} \\cdot 6! \\cdot (13)} = \\frac{1}{\\sqrt{\\pi} \\cdot 4096 \\cdot 720 \\cdot 13} = \\frac{1}{\\sqrt{\\pi} \\cdot 38338560}$。\n使用 $\\sqrt{\\pi} \\approx 1.77245$，分母约等于 $1.77245 \\times 38338560 \\approx 6.795 \\times 10^7$。\n误差上界约等于 $\\frac{1}{6.795 \\times 10^7} \\approx 1.47 \\times 10^{-8}$。\n由于 $1.47 \\times 10^{-8} > 1.0 \\times 10^{-8}$，$N=5$ 不满足要求。\n\n当 $N=6$ 时：\n误差上界为 $\\frac{1}{\\sqrt{\\pi} \\cdot 2^{14} \\cdot 7! \\cdot (15)} = \\frac{1}{\\sqrt{\\pi} \\cdot 16384 \\cdot 5040 \\cdot 15} = \\frac{1}{\\sqrt{\\pi} \\cdot 1238630400}$。\n使用 $\\sqrt{\\pi} \\approx 1.77245$，分母约等于 $1.77245 \\times 1238630400 \\approx 2.196 \\times 10^9$。\n误差上界约等于 $\\frac{1}{2.196 \\times 10^9} \\approx 4.55 \\times 10^{-10}$。\n由于 $4.55 \\times 10^{-10} < 1.0 \\times 10^{-8}$，$N=6$ 满足要求。\n\n因此，能够保证所需精度的最小整数 $N$ 值为 $6$。", "answer": "$$ \\boxed{6} $$", "id": "2442184"}, {"introduction": "一种普遍的误解是，使用更高阶的泰勒多项式总能得到更好的近似。然而，事实并非总是如此，尤其是在远离展开点的地方。本练习将挑战这一直觉，引导你推导出一个明确的准则，判断在何种条件下，二阶近似的“最坏情况”误差保证实际上会比一阶近似更差。通过这个思想实验，你将更深刻地理解模型复杂性、近似半径和误差界之间的权衡，这是进行有效降阶建模的关键。[@problem_id:2442165]", "problem": "在计算工程的某个降阶建模程序中，一个标量响应函数 $f:\\mathbb{R}\\to\\mathbb{R}$ 将在点 $a\\in\\mathbb{R}$ 附近被泰勒多项式近似。假设 $f$ 在某个半径 $r>0$ 的闭区间 $[a-r,a+r]$ 上是三阶连续可微的。对于此区间中的所有 $x$，仅给出以下导数界：\n- $\\lvert f^{\\prime\\prime}(x)\\rvert\\leq M_{2}$，\n- $\\lvert f^{\\prime\\prime\\prime}(x)\\rvert\\leq M_{3}$，\n其中 $M_{2}>0$ 和 $M_{3}>0$ 是已知常数。\n\n令 $T_{1}$ 和 $T_{2}$ 分别表示 $f$ 关于点 $a$ 的一阶和二阶泰勒多项式。对于每个半径 $r>0$，定义量 $E_{k}(r)$ 为在闭邻域 $\\{x\\in\\mathbb{R}:\\lvert x-a\\rvert\\leq r\\}$ 上，仅使用给定导数界所能确证的 $T_k$ 绝对截断误差的最小一致上界，其中 $k\\in\\{1,2\\}$。\n\n确定最小半径 $r_{c}=r_{c}(M_{2},M_{3})$，使得对于每个 $r>r_{c}$，二阶多项式的先验最坏情况绝对截断误差界严格大于一阶多项式的误差界；即 $E_{2}(r)>E_{1}(r)$。请用 $M_{2}$ 和 $M_{3}$ 给出最终答案的闭式解析表达式。无需进行数值舍入。", "solution": "问题要求确定一个临界半径 $r_{c}$，当半径超过该值时，二阶泰勒近似的可确证误差界将超过一阶近似的误差界。我们将通过建立这些误差界的表达式来求解。\n\n函数 $f: \\mathbb{R} \\to \\mathbb{R}$ 在闭区间 $[a-r, a+r]$ 上是三阶连续可微的。$f$ 关于点 $a$ 展开的一阶和二阶泰勒多项式（分别记为 $T_1(x)$ 和 $T_2(x)$）是：\n$$T_{1}(x) = f(a) + f^{\\prime}(a)(x-a)$$\n$$T_{2}(x) = f(a) + f^{\\prime}(a)(x-a) + \\frac{f^{\\prime\\prime}(a)}{2!}(x-a)^{2}$$\n\n相应的截断误差，或称余项，由 $R_{1}(x) = f(x) - T_{1}(x)$ 和 $R_{2}(x) = f(x) - T_{2}(x)$ 给出。根据带拉格朗日余项的泰勒定理，对于相关定义域中的任意 $x$，存在数 $\\xi_{1}$ 和 $\\xi_{2}$，两者都严格位于 $a$ 和 $x$ 之间，使得：\n$$R_{1}(x) = \\frac{f^{\\prime\\prime}(\\xi_{1})}{2!}(x-a)^{2}$$\n$$R_{2}(x) = \\frac{f^{\\prime\\prime\\prime}(\\xi_{2})}{3!}(x-a)^{3}$$\n\n量 $E_{k}(r)$ 被定义为在邻域 $\\{x \\in \\mathbb{R} : |x-a| \\leq r\\}$ 上，仅使用给定导数界所能确证的绝对截断误差 $|R_k(x)|$ 的最小一致上界。\n\n对于一阶近似（$k=1$），绝对误差为：\n$$|R_{1}(x)| = \\left| \\frac{f^{\\prime\\prime}(\\xi_{1})}{2!}(x-a)^{2} \\right| = \\frac{|f^{\\prime\\prime}(\\xi_{1})|}{2}|x-a|^{2}$$\n为建立一致界 $E_{1}(r)$，我们必须找到该表达式对于所有满足 $|x-a| \\leq r$ 的 $x$ 的上确界。我们已知在此邻域中对所有 $x$ 都有界 $|f^{\\prime\\prime}(x)| \\leq M_{2}$。项 $|x-a|^{2}$ 在邻域的边界处取得最大值，即 $|x-a| = r$。因此，可确证的最紧密一致上界为：\n$$E_{1}(r) = \\sup_{|x-a|\\leq r} \\frac{|f^{\\prime\\prime}(\\xi_{1})|}{2}|x-a|^{2} = \\frac{M_{2}}{2}r^{2}$$\n\n类似地，对于二阶近似（$k=2$），绝对误差为：\n$$|R_{2}(x)| = \\left| \\frac{f^{\\prime\\prime\\prime}(\\xi_{2})}{3!}(x-a)^{3} \\right| = \\frac{|f^{\\prime\\prime\\prime}(\\xi_{2})|}{6}|x-a|^{3}$$\n使用给定的界 $|f^{\\prime\\prime\\prime}(x)| \\leq M_{3}$ 并在邻域上最大化 $|x-a|^{3}$（在 $|x-a|=r$ 处取得），我们得到可确证的一致上界：\n$$E_{2}(r) = \\sup_{|x-a|\\leq r} \\frac{|f^{\\prime\\prime\\prime}(\\xi_{2})|}{6}|x-a|^{3} = \\frac{M_{3}}{6}r^{3}$$\n\n问题要求找到最小半径 $r_c$，使得对于所有 $r > r_c$，不等式 $E_{2}(r) > E_{1}(r)$ 成立。我们用推导出的表达式构建这个不等式：\n$$\\frac{M_{3}}{6}r^{3} > \\frac{M_{2}}{2}r^{2}$$\n问题指明 $r > 0$，且给定的常数 $M_{2}$ 和 $M_{3}$ 为正数。因此，我们可以将不等式两边同除以正量 $r^{2}$ 而不改变不等号的方向：\n$$\\frac{M_{3}}{6}r > \\frac{M_{2}}{2}$$\n为了分离出 $r$，我们将两边同乘以正常数 $\\frac{6}{M_{3}}$：\n$$r > \\frac{M_{2}}{2} \\cdot \\frac{6}{M_{3}}$$\n$$r > \\frac{3M_{2}}{M_{3}}$$\n这个不等式指明了 $r$ 必须满足的条件。问题要求的是最小的值 $r_c$，使得对于任何大于 $r_c$ 的半径 $r$，该条件都成立。满足所推导不等式的所有 $r$ 值的集合是开区间 $(\\frac{3M_{2}}{M_{3}}, \\infty)$。可以作为所有这些 $r$ 的下界的最小数 $r_c$ 是该集合的下确界。\n因此，临界半径是：\n$$r_{c} = \\frac{3M_{2}}{M_{3}}$$", "answer": "$$\\boxed{\\frac{3M_{2}}{M_{3}}}$$", "id": "2442165"}, {"introduction": "理论上的数学公式在有限精度的计算机上直接实现时，可能会出现灾难性的失败。本练习将以计算 $\\sin(x)$ 函数为例，揭示对较大输入值直接使用麦克劳林级数所导致的数值不稳定性。你将亲手诊断问题（即灾难性舍位误差），并实施一个结合了“参数约简”(argument reduction)的稳健算法，这正是专业数学库中解决此类问题的标准方法。这个实践将理论知识（如余项界）与算法设计融为一体，展示了如何在实践中构建可靠的计算工具。[@problem_id:2442233]", "problem": "您需要编写一个完整、可运行的程序，该程序使用麦克劳林级数计算正弦函数，并严格控制截断误差，同时分析该方法对于大自变量的数值稳定性。计算过程完全使用弧度制。\n\n请从以下基本原理出发：\n- 解析函数的麦克劳林级数定义以及拉格朗日余项形式。对于一个充分可微的函数 $f$，其在 $x=0$ 处的 $m$ 阶麦克劳林多项式的余项为 $R_{m}(x) = \\dfrac{f^{(m+1)}(\\xi)}{(m+1)!} x^{m+1}$，其中 $\\xi$ 是介于 $0$ 和 $x$ 之间的某个值。\n- 三角函数的周期性和奇偶性恒等式：对于任意整数 $k$，有 $ \\sin(x + 2\\pi k) = \\sin(x)$；以及和角与象限对称性，这些对称性可将 $ \\sin(x)$ 与 $ \\sin(r)$ 或 $ \\cos(r)$ 关联起来，其中 $r$ 是通过减去 $ \\dfrac{\\pi}{2}$ 的整数倍得到的微小余量。\n\n您的任务：\n1) 根据麦克劳林定义和拉格朗日余项公式，推导出一个截断 $ \\sin(x)$ 和 $ \\cos(x)$ 麦克劳林级数的停止准则，以达到用户指定的绝对误差容限 $ \\varepsilon > 0$。特别地，请证明如下形式的界：\n$$\n\\left| R_{2N+1}^{\\sin}(x) \\right| \\le \\frac{|x|^{2N+3}}{(2N+3)!}, \n\\qquad\n\\left| R_{2N}^{\\cos}(x) \\right| \\le \\frac{|x|^{2N+2}}{(2N+2)!},\n$$\n利用的性质是 $ \\sin(x)$ 或 $ \\cos(x)$ 的任意阶导数的绝对值在实数线上最大为 $1$。然后，设计一个程序，对于给定的小自变量 $z$，找出最小的整数 $N \\ge 0$，使得相应的余项界小于或等于 $ \\varepsilon$。\n\n2) 设计并实现一个自变量约简策略。对于任意实数 $x$，该策略使用 $ \\dfrac{\\pi}{2}$ 的整数倍将 $x$ 映射到一个位于区间 $[-\\dfrac{\\pi}{4}, \\dfrac{\\pi}{4}]$ 内的余量 $r$ 和一个象限索引 $q \\in \\{0,1,2,3\\}$，使得：\n$$\n\\sin(x) = \n\\begin{cases}\n\\phantom{-}\\sin(r), & q \\equiv 0 \\ (\\text{mod } 4),\\\\\n\\phantom{-}\\cos(r), & q \\equiv 1 \\ (\\text{mod } 4),\\\\\n-\\sin(r), & q \\equiv 2 \\ (\\text{mod } 4),\\\\\n-\\cos(r), & q \\equiv 3 \\ (\\text{mod } 4).\n\\end{cases}\n$$\n使用此映射关系选择应在微小余量 $r$ 处计算哪个麦克劳林级数（正弦或余弦）。使用任务 1 中的停止准则来确定所需的最小级数项数，以保证截断误差不超过 $ \\varepsilon$。\n\n3) 从基本原理出发，解释为什么对一个大的 $|x|$ 直接进行麦克劳林求值在数值上是不稳定的：分析在阶乘的增长占主导地位之前，中间项的量级如何变化，以及有限精度算术如何加剧抵消效应。然后，将其与自变量约简策略的稳定性进行对比，并解释其局限性，即对于极大的 $|x|$，由于尾数位的限制，浮点数约简 $x \\mapsto r$ 本身也可能损失精度。\n\n4) 为一组测试输入实现以下程序化输出。对于每个测试用例的参数对 $(x, \\varepsilon)$：\n- 使用您的自变量约简麦克劳林方法计算 $s_{\\text{approx}}$。\n- 计算一个布尔值 $b_{\\text{ok}}$，当且仅当 $|s_{\\text{approx}} - \\sin(x)| \\le \\varepsilon$ 时为真，其中右侧的 $ \\sin(x)$ 使用一个高质量的库函数作为参考值进行计算。\n- 报告所选级数实际求和的最小非零麦克劳林项数，记为 $T$（对于 $ \\sin$，这是对应于 $1,3,\\dots,2N+1$ 次幂的 $T = N+1$ 项；对于 $ \\cos$，这是对应于 $0,2,\\dots,2N$ 次幂的 $T = N+1$ 项）。\n- 评估在相同容限下，一个朴素的、未约简的 $ \\sin(x)$ 麦克劳林级数是否实际上不可用。评估方法是检查在余项界降至 $ \\varepsilon$ 以下之前，是否必须超过 $T_{\\max} = 1000$ 个非零项的上限，或者中间余项是否上溢为非有限值。如果是，则记录一个布尔值 $b_{\\text{naive\\_impractical}}$ 为真，否则为假。\n\n角度单位：弧度。无物理单位。所有百分比（如有）必须表示为小数。\n\n测试套件：\n- 案例 1：$(x, \\varepsilon) = (100.0, 10^{-12})$。\n- 案例 2：$(x, \\varepsilon) = (10^{6} + 0.1, 10^{-12})$。\n- 案例 3：$(x, \\varepsilon) = (10^{16} + 0.1, 10^{-12})$。\n- 案例 4：$(x, \\varepsilon) = \\left(\\dfrac{\\pi}{2} + 10^{-8}, 10^{-15}\\right)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。对于上述顺序中的第 $k$ 个测试用例，输出三元组 $[b_{\\text{ok}}, T, b_{\\text{naive\\_impractical}}]$，并将这些三元组按测试用例顺序展平为一个单一列表。例如，最后一行应类似于：\n$[b_{\\text{ok},1}, T_{1}, b_{\\text{naive\\_impractical},1}, b_{\\text{ok},2}, T_{2}, b_{\\text{naive\\_impractical},2}, b_{\\text{ok},3}, T_{3}, b_{\\text{naive\\_impractical},3}, b_{\\text{ok},4}, T_{4}, b_{\\text{naive\\_impractical},4}]$。", "solution": "所述问题定义明确、内部一致，并且基于数值分析和微积分的基本原理。它既不模棱两可，也不存在科学上的不严谨之处。因此，我们将按要求进行严格的推导和实现。\n\n任务是实现一种数值稳定的方法，利用其麦克劳林级数展开来计算正弦函数 $\\sin(x)$，并与朴素的直接求值法进行性能分析。解决方案分为三个主要部分：级数截断准则的推导、自变量约简策略的开发以及数值稳定性分析。\n\n**1. 截断准则的推导**\n\n一个解析函数 $f(x)$ 在 $x=0$ 附近的麦克劳林级数展开由 $f(x) = \\sum_{k=0}^{\\infty} \\frac{f^{(k)}(0)}{k!} x^k$ 给出。当这个级数在 $m$ 次项后被截断时，结果是麦克劳林多项式 $P_m(x)$，误差为余项 $R_m(x)$。根据拉格朗日余项形式，$R_m(x) = \\frac{f^{(m+1)}(\\xi)}{(m+1)!} x^{m+1}$，其中 $\\xi$ 介于 $0$ 和 $x$ 之间。\n\n对于 $f(x) = \\sin(x)$，其导数是周期性的：$\\sin'(x) = \\cos(x)$，$\\sin''(x) = -\\sin(x)$，依此类推。关键在于，对于任意整数 $k \\ge 0$，其 $k$ 阶导数满足 $|f^{(k)}(x)| \\le 1$ 对所有实数 $x$ 成立。$\\sin(x)$ 的麦克劳林级数只包含 $x$ 的奇次幂：\n$$\n\\sin(x) = \\sum_{k=0}^{N} \\frac{(-1)^k}{(2k+1)!} x^{2k+1} + R_{2N+1}(x)\n$$\n这里，我们在对应于 $k=N$ 的项（即 $2N+1$ 次幂项）之后截断级数。其多项式部分 $P_{2N+1}(x)$ 与 $P_{2N+2}(x)$ 相同，因为 $x^{2N+2}$ 的系数为零。因此，余项为 $R_{2N+2}(x)$，由下式给出：\n$$\nR_{2N+2}(x) = \\frac{f^{(2N+3)}(\\xi)}{(2N+3)!} x^{2N+3}\n$$\n其中 $f^{(2N+3)}(x)$ 是 $\\pm\\sin(x)$ 或 $\\pm\\cos(x)$。利用界 $|f^{(2N+3)}(\\xi)| \\le 1$，我们为截断到 $2N+1$ 次的正弦级数建立误差界：\n$$\n\\left| R_{2N+1}^{\\sin}(x) \\right| = \\left| R_{2N+2}^{\\sin}(x) \\right| \\le \\frac{|x|^{2N+3}}{(2N+3)!}\n$$\n这验证了问题陈述中给出的不等式。\n\n对于 $f(x) = \\cos(x)$，其麦克劳林级数只包含 $x$ 的偶次幂：\n$$\n\\cos(x) = \\sum_{k=0}^{N} \\frac{(-1)^k}{(2k)!} x^{2k} + R_{2N}(x)\n$$\n多项式 $P_{2N}(x)$ 与 $P_{2N+1}(x)$ 相同。余项为 $R_{2N+1}(x)$:\n$$\nR_{2N+1}(x) = \\frac{f^{(2N+2)}(\\xi)}{(2N+2)!} x^{2N+2}\n$$\n再次利用界 $|f^{(2N+2)}(\\xi)| \\le 1$，我们得到截断到 $2N$ 次的余弦级数的误差界：\n$$\n\\left| R_{2N}^{\\cos}(x) \\right| = \\left| R_{2N+1}^{\\cos}(x) \\right| \\le \\frac{|x|^{2N+2}}{(2N+2)!}\n$$\n这也验证了问题的提法。\n\n为了满足给定的绝对误差容限 $\\varepsilon > 0$，对于一个小自变量 $z$，我们必须找到最小的非负整数 $N$，使得误差界不超过 $\\varepsilon$。\n对于 $\\sin(z)$，我们必须找到最小的 $N \\ge 0$，使得 $\\frac{|z|^{2N+3}}{(2N+3)!} \\le \\varepsilon$。\n对于 $\\cos(z)$，我们必须找到最小的 $N \\ge 0$，使得 $\\frac{|z|^{2N+2}}{(2N+2)!} \\le \\varepsilon$。\n这需要一个迭代搜索过程，从 $N=0$ 开始，递增 $N$ 直到条件满足。需要求和的非零项数则为 $T = N+1$。\n\n**2. 自变量约简策略**\n\n对于大的 $|x|$，直接计算麦克劳林级数是低效且数值不稳定的。一种标准且稳健的技术是自变量约简，它利用了三角函数的周期性。任何实数 $x$ 都可以表示为 $x = q \\cdot \\frac{\\pi}{2} + r$，其中 $q$ 是一个整数，$r$ 是一个小的余量。我们选择 $q$ 为最接近 $x / (\\pi/2)$ 值的整数，这确保了余量 $r$ 位于区间 $[-\\frac{\\pi}{4}, \\frac{\\pi}{4}]$ 内。\n步骤如下：\n1. 计算 $y = x / (\\pi/2)$。\n2. 找到最近的整数 $q = \\text{round}(y)$。\n3. 计算余量 $r = x - q \\cdot (\\pi/2)$。根据构造，有 $|r| \\le \\frac_1{2} \\cdot \\frac{\\pi}{2} = \\frac{\\pi}{4}$。\n\n然后，$\\sin(x)$ 的值根据 $q$ 模 $4$ 的值与 $\\sin(r)$ 或 $\\cos(r)$ 关联起来。设 $q_{\\text{mod} 4} = q \\pmod 4$。我们使用和角恒等式：\n- 如果 $q_{\\text{mod} 4} = 0$: $\\sin(x) = \\sin(4k \\cdot \\frac{\\pi}{2} + r) = \\sin(2k\\pi + r) = \\sin(r)$。\n- 如果 $q_{\\text{mod} 4} = 1$: $\\sin(x) = \\sin((4k+1) \\cdot \\frac{\\pi}{2} + r) = \\sin(2k\\pi + \\frac{\\pi}{2} + r) = \\cos(r)$。\n- 如果 $q_{\\text{mod} 4} = 2$: $\\sin(x) = \\sin((4k+2) \\cdot \\frac{\\pi}{2} + r) = \\sin(2k\\pi + \\pi + r) = -\\sin(r)$。\n- 如果 $q_{\\text{mod} 4} = 3$: $\\sin(x) = \\sin((4k+3) \\cdot \\frac{\\pi}{2} + r) = \\sin(2k\\pi + \\frac{3\\pi}{2} + r) = -\\cos(r)$。\n\n该策略将计算任意 $x$ 的 $\\sin(x)$ 问题简化为计算小自变量 $|r| \\le \\pi/4$ 的 $\\sin(r)$ 或 $\\cos(r)$ 的问题。对于这样的小自变量，麦克劳林级数收敛迅速，并且可以高效地应用上一节推导的截断准则来确定所需的项数。\n\n**3. 数值稳定性分析**\n\n对于大的 $|x|$，直接计算 $\\sin(x)$ 的麦克劳林级数在数值上是不稳定的，这主要源于两个问题：中间项上溢和灾难性抵消。\n\n- **中间项增长和上溢**：$\\sin(x)$ 级数的第 $k$ 项是 $t_k = \\frac{(-1)^k x^{2k+1}}{(2k+1)!}$。这些项的量级最初随着 $k$ 迅速增长。项的量级在比率 $|t_{k+1}/t_k| = \\frac{|x|^2}{(2k+2)(2k+3)} \\approx 1$ 时达到最大，这意味着 $2k+2 \\approx |x|$。对于像 $x=100$ 这样的大值，项会增长到天文数字般的大小（例如，当 $k=49$ 时，项的量级约为 $100^{99}/99!$，这很容易超过标准双精度浮点数的表示范围，约 $10^{308}$）。\n\n- **灾难性抵消**：最终结果 $\\sin(x)$ 必须位于 $[-1, 1]$ 区间内。对于大 $x$ 的级数求值过程涉及将非常大的正项和负项相加，以产生一个很小的最终结果。标准浮点数具有固定数量的有效数字（即尾数）。当两个大小相近的大数相减时，前面的有效数字会相互抵消，导致结果的有效数字位数大大减少。这种相对精度的损失被称为灾难性抵消，并使最终结果毫无意义。\n\n自变量约简策略完全规避了这些问题。自变量 $r$ 很小（$|r| \\le \\pi/4 \\approx 0.785$），因此麦克劳林级数项 $\\frac{r^k}{k!}$ 的量级从一开始就单调递减。中间项不会增长，因此不会发生灾难性抵消。该方法是数值稳定的。\n\n然而，自变量约简本身也有一个局限性。当 $x$ 极大时，步骤 $r = x - q \\cdot (\\pi/2)$ 可能会遭受灾难性抵消。原因是 $\\pi$ 的标准浮点表示具有有限的精度。对于一个非常大的 $x$（例如 $x=10^{16}+0.1$），$x$ 本身在标准 `float64` 算术中可能就会被舍入（对于 $10^{16}$，其末位单位大于 $0.1$，因此 $10^{16}+0.1$ 会被存储为精确的 $10^{16}$）。即使 $x$ 可以精确表示，乘积 $q \\cdot (\\pi/2)$ 将是一个接近 $x$ 的大数。`float64` 表示的 $\\pi$ 的有限精度会给这个乘积带来一个与 $q$ 成正比的绝对误差。当 $x$ 很大时，$q$ 也很大，这个误差可能会变得非常显著，甚至可能大于 $\\pi/2$ 本身。减法 $x - q \\cdot (\\pi/2)$ 随后会抵消掉大部分有效数字，导致得到的 $r$ 值几乎没有（或完全没有）正确的数字。这揭示了在极大的自变量上使用定点精度算术进行计算的根本局限。预计这种现象会导致 $x = 10^{16} + 0.1$ 的测试用例无法通过精度检查。\n\n所提供的程序实现了这些原理，以计算正弦函数并分析其在指定测试用例下的数值特性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef get_required_terms_sin(z_abs, ε):\n    \"\"\"\n    Calculates the minimum number of terms T for the sin Maclaurin series.\n    The error bound after T terms (degree 2T-1) is |z|^(2T+1)/(2T+1)!.\n    \"\"\"\n    if z_abs == 0.0:\n        return 1\n    \n    z2 = z_abs * z_abs\n    \n    # Bound for T=1 term (degree 1)\n    bound = (z_abs**3) / 6.0\n    T = 1\n    \n    denom_fac1 = 4\n    denom_fac2 = 5\n    \n    while bound > ε:\n        T += 1\n        bound *= z2 / (denom_fac1 * denom_fac2)\n        denom_fac1 += 2\n        denom_fac2 += 2\n        if T > 1000: # Safety break\n            return T\n            \n    return T\n\ndef get_required_terms_cos(z_abs, ε):\n    \"\"\"\n    Calculates the minimum number of terms T for the cos Maclaurin series.\n    The error bound after T terms (degree 2T-2) is |z|^(2T)/(2T)!.\n    \"\"\"\n    if z_abs == 0.0:\n        return 1\n    \n    z2 = z_abs * z_abs\n    \n    # Bound for T=1 term (degree 0)\n    bound = z2 / 2.0\n    T = 1\n    \n    denom_fac1 = 3\n    denom_fac2 = 4\n\n    while bound > ε:\n        T += 1\n        bound *= z2 / (denom_fac1 * denom_fac2)\n        denom_fac1 += 2\n        denom_fac2 += 2\n        if T > 1000: # Safety break\n            return T\n            \n    return T\n\ndef eval_sin_series(z, T):\n    \"\"\"Evaluates the sin Maclaurin series for T terms.\"\"\"\n    if z == 0.0:\n        return 0.0\n\n    z2 = z * z\n    term = z\n    total = term\n    for k in range(1, T):\n        # term_k = -term_{k-1} * z^2 / ((2k)(2k+1))\n        term *= -z2 / ((2 * k) * (2 * k + 1))\n        total += term\n    return total\n\ndef eval_cos_series(z, T):\n    \"\"\"Evaluates the cos Maclaurin series for T terms.\"\"\"\n    z2 = z * z\n    term = 1.0\n    total = term\n    for k in range(1, T):\n        # term_k = -term_{k-1} * z^2 / ((2k-1)(2k))\n        term *= -z2 / ((2 * k - 1) * (2 * k))\n        total += term\n    return total\n\ndef compute_sin_reduced(x, ε):\n    \"\"\"\n    Computes sin(x) using argument reduction and Maclaurin series.\n    Returns the computed value and the number of terms used.\n    \"\"\"\n    pi_over_2 = np.pi / 2.0\n    \n    # Argument reduction\n    q_float = x / pi_over_2\n    q = np.round(q_float)\n    r = x - q * pi_over_2\n    \n    q_int = int(q)\n    quadrant = q_int % 4\n    \n    r_abs = abs(r)\n\n    if quadrant == 0:  # sin(r)\n        T = get_required_terms_sin(r_abs, ε)\n        val = eval_sin_series(r, T)\n        return val, T\n    elif quadrant == 1:  # cos(r)\n        T = get_required_terms_cos(r_abs, ε)\n        val = eval_cos_series(r, T)\n        return val, T\n    elif quadrant == 2:  # -sin(r)\n        T = get_required_terms_sin(r_abs, ε)\n        val = eval_sin_series(r, T)\n        return -val, T\n    else:  # quadrant == 3, -cos(r)\n        T = get_required_terms_cos(r_abs, ε)\n        val = eval_cos_series(r, T)\n        return -val, T\n\ndef check_naive_impractical(x, ε, T_max):\n    \"\"\"\n    Checks if a naive Maclaurin series evaluation of sin(x) is impractical.\n    Impractical if > T_max terms are needed or if intermediate terms overflow.\n    \"\"\"\n    x_abs = abs(x)\n    if x_abs == 0.0:\n        return False\n        \n    x2 = x_abs * x_abs\n    \n    # Check terms and remainder bound iteratively for T = 1, 2, ...\n    \n    # T=1 term magnitude (|x|)\n    term_mag = x_abs\n    if np.isinf(term_mag):\n        return True # Overflow\n\n    # Remainder bound for T=1 term\n    remainder_bound = term_mag * x2 / 6.0\n    if remainder_bound = ε:\n        return False # Practical\n    \n    for T in range(2, T_max + 1):\n        # Magnitude of the T-th term\n        # term_mag(T) = term_mag(T-1) * x^2 / ((2T-2)*(2T-1))\n        term_mag *= x2 / ((2*T - 2) * (2*T - 1))\n        if np.isinf(term_mag):\n            return True # Overflow of intermediate term\n\n        # Remainder bound for T terms\n        # bound(T) = term_mag(T) * x^2 / ((2T)*(2T+1))\n        remainder_bound = term_mag * x2 / ((2*T) * (2*T + 1))\n        if np.isinf(remainder_bound):\n            # This can happen if term_mag is huge but finite\n            # and gets multiplied by a large x2\n            return True\n            \n        if remainder_bound = ε:\n            return False # Practical, convergence within T_max terms\n\n    return True # Not converged within T_max terms\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (100.0, 1e-12),\n        (10**6 + 0.1, 1e-12),\n        (10**16 + 0.1, 1e-12),\n        (np.pi/2 + 1e-8, 1e-15),\n    ]\n\n    results = []\n    for x, ε in test_cases:\n        # 1. Compute s_approx and T using the reduced method.\n        s_approx, T = compute_sin_reduced(x, ε)\n        \n        # 2. Compute b_ok by comparing with a high-quality reference.\n        # Use np.longdouble for reference calculation where precision matters\n        ref_val = np.sin(np.longdouble(x))\n        b_ok = np.abs(s_approx - ref_val) = ε\n        \n        # 3. Assess if naive method is impractical.\n        T_max = 1000\n        b_naive_impractical = check_naive_impractical(x, ε, T_max)\n        \n        results.extend([b_ok, T, b_naive_impractical])\n\n    # Final print statement in the exact required format.\n    # Python's str() for a boolean is 'True' or 'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2442233"}]}