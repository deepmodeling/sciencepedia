{"hands_on_practices": [{"introduction": "张量代数的核心由一系列强大的恒等式所支配，特别是涉及列维-奇维塔符号 ($\\epsilon_{ijk}$)和克罗内克 δ ($\\delta_{ij}$) 的恒等式。通过动手编程验证这些基础规则，您可以将抽象的数学关系转化为具体的代码，从而加深对爱因斯坦求和约定和索引操作的直观理解。这个练习 [@problem_id:2442492] 是您掌握张量运算“游戏规则”的第一步。", "problem": "构建一个完整的程序，严格依据三维空间中 Levi-Civita 符号和 Kronecker delta 的定义，使用指标记法和爱因斯坦求和约定来简化和验证张量表达式。在三维（$3$-维）欧几里得设定下工作。指标如 $i$、$j$、$k$、$l$、$m$ 和 $n$ 的取值范围为集合 $\\{1,2,3\\}$。Levi-Civita 符号 $\\epsilon_{ijk}$ 被定义为完全反对称的，其中 $\\epsilon_{123}=+1$，且当 $i$、$j$、$k$ 中任意两个指标相等时 $\\epsilon_{ijk}=0$。Kronecker delta $\\delta_{ij}$ 的定义为：若 $i=j$，则 $\\delta_{ij}=1$；否则 $\\delta_{ij}=0$。采用爱因斯坦求和约定：任意在某一项中恰好出现两次的指标，都隐含对 $\\{1,2,3\\}$ 进行求和；只出现一次的指标是自由指标。当一个表达式被明确声明为分量形式的陈述时，该特定陈述内的重复指标不应用隐式求和。\n\n你的程序必须在不接受任何输入的情况下，评估并验证以下张量关系的测试套件。对每一项，仅使用上述定义和适当的隐式求和来计算左手边和右手边，然后得出要求的结果。所有等式必须在自由指标的所有取值上进行逐分量检查。\n\n- 测试 $1$ (布尔值): 对所有自由指标 $j,k,m,n$，验证恒等式\n$$\n\\sum_{i=1}^{3} \\epsilon_{ijk}\\,\\epsilon_{imn} \\;=\\; \\delta_{jm}\\,\\delta_{kn} \\;-\\; \\delta_{jn}\\,\\delta_{km}.\n$$\n如果对所有的 $j,k,m,n$ 都成立，则返回 $True$，否则返回 $False$。\n\n- 测试 $2$ (整数): 计算标量\n$$\nS \\;=\\; \\sum_{i=1}^{3}\\sum_{j=1}^{3}\\sum_{k=1}^{3} \\epsilon_{ijk}\\,\\epsilon_{ijk}.\n$$\n\n- 测试 $3$ (布尔值): 对所有自由指标 $i,l$，验证\n$$\n\\sum_{j=1}^{3}\\sum_{k=1}^{3} \\epsilon_{ijk}\\,\\epsilon_{ljk} \\;=\\; 2\\,\\delta_{il}.\n$$\n\n- 测试 $4$ (布尔值): 对所有自由指标 $i,m,n$，验证\n$$\n\\sum_{j=1}^{3}\\sum_{k=1}^{3} \\epsilon_{ijk}\\,\\delta_{jm}\\,\\delta_{kn} \\;=\\; \\epsilon_{imn}.\n$$\n\n- 测试 $5$ (布尔值): 对所有自由指标 $k$，验证\n$$\n\\sum_{i=1}^{3}\\sum_{j=1}^{3} \\epsilon_{ijk}\\,\\delta_{ji} \\;=\\; 0.\n$$\n\n- 测试 $6$ (布尔值，逐分量且无隐式求和): 对所有 $i,j \\in \\{1,2,3\\}$，验证分量级别的反对称性陈述\n$$\n\\epsilon_{i\\, i\\, j} \\;=\\; 0,\n$$\n此处不隐含对 $i$ 的求和。\n\n- 测试 $7$ (布尔值): 对所有自由指标 $i,j,k$，验证反对称关系\n$$\n\\epsilon_{ijk} \\;+\\; \\epsilon_{jik} \\;=\\; 0.\n$$\n\n- 测试 $8$ (布尔值): 对所有自由指标 $i,j,m,n$，验证恒等式\n$$\n\\sum_{k=1}^{3} \\epsilon_{ijk}\\,\\epsilon_{mnk} \\;=\\; \\delta_{im}\\,\\delta_{jn} \\;-\\; \\delta_{in}\\,\\delta_{jm}.\n$$\n\n最终输出格式：你的程序应生成单行输出，其中包含一个逗号分隔的结果列表，并用方括号括起，顺序为测试 $1$ 至测试 $8$。例如，格式必须为\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5,\\text{result}_6,\\text{result}_7,\\text{result}_8].\n$$\n每个条目必须是如上指定的布尔值或整数。不涉及物理单位。不使用角度。输出中不得有任何额外的文本或空行。程序必须是自包含的，且不要求用户输入。", "solution": "所提供的问题是计算张量代数领域一个有效的练习。它有科学依据、定义明确且客观。它要求使用 Levi-Civita 符号 $\\epsilon_{ijk}$ 和 Kronecker delta $\\delta_{ij}$ 的定义，以及爱因斯坦求和约定，来验证三维欧几里得空间中的标准张量恒等式。该问题是自包含的，没有矛盾或歧义。因此，我将提供一个完整的解决方案。\n\n该解决方案基于张量对象及其所遵循的代数规则的直接数值实现。基本原理是将数学实体 $\\delta_{ij}$ 和 $\\epsilon_{ijk}$ 表示为离散的数值数组（张量），并对这些数组执行指定的代数运算。爱因斯坦求和约定，即在单个项中重复出现的指标表示对其取值范围 $\\{1, 2, 3\\}$ 进行求和，是该问题的核心组成部分。在利用 Python 进行计算工程的背景下，`NumPy` 库提供了 `numpy.einsum` 函数，该函数专为执行此约定下的张量缩并而设计。使用它不仅仅是为了方便，更是对指定数学记法最直接、计算上最合理的实现。\n\n首先，我们使用基于 0 的索引（指标范围为 $\\{0, 1, 2\\}$）来定义基础张量。\n\nKronecker delta $\\delta_{ij}$ 是一个 2 阶张量。其定义 $\\delta_{ij} = 1$ (当 $i=j$) 和 $\\delta_{ij} = 0$ (当 $i\\neq j$) 恰好对应于一个 $3 \\times 3$ 的单位矩阵。在 `NumPy` 中，这可以通过 `np.eye(3)` 创建。\n\nLevi-Civita 符号 $\\epsilon_{ijk}$ 是一个 3 阶张量。其定义基于其指标的排列：$\\epsilon_{123} = +1$（在使用 1-based 索引时，或 $\\epsilon_{012}=+1$ 在使用 0-based 索引时），它在任意两个指标交换下是完全反对称的，并且如果任意两个指标相同，则其值为零。我们构建一个初始化为零的 $3 \\times 3 \\times 3$ 数组。然后，我们显式设置与 $(0, 1, 2)$ 的偶排列和奇排列对应的非零分量：\n-   偶排列 (值为 $+1$): $\\epsilon_{012}$、$\\epsilon_{120}$、$\\epsilon_{201}$。\n-   奇排列 (值为 $-1$): $\\epsilon_{021}$、$\\epsilon_{210}$、$\\epsilon_{102}$。\n所有其他分量（其中至少有两个指标相等）保持为零，符合定义要求。\n\n有了 $\\delta_{ij}$ 和 $\\epsilon_{ijk}$ 的这些数值表示，我们就可以通过计算每个恒等式的左手边 (LHS) 和右手边 (RHS) 来逐一验证每个测试用例。对于每个布尔值测试，当且仅当 LHS 和 RHS 的结果张量在所有分量上都相等时，该恒等式才被视为已验证。\n\n-   **测试 1**: 验证 $\\sum_{i} \\epsilon_{ijk}\\epsilon_{imn} = \\delta_{jm}\\delta_{kn} - \\delta_{jn}\\delta_{km}$。自由指标为 $j,k,m,n$。重复指标 $i$ 被求和。左手边的 `einsum` 记法 `ijk,imn->jkmn` 完美地捕捉了此操作。右手边由 $\\delta_{ij}$ 张量的外积构成，`einsum` 同样可以处理。\n\n-   **测试 2**: 计算 $S = \\sum_{i,j,k} \\epsilon_{ijk}\\epsilon_{ijk}$。所有指标都是重复的，所以这是一个完全缩并，结果为一个标量。`einsum` 字符串为 `ijk,ijk->`。结果是已知的数值 $6$。\n\n-   **测试 3**: 验证 $\\sum_{j,k} \\epsilon_{ijk}\\epsilon_{ljk} = 2\\delta_{il}$。此处，$j$ 和 $k$ 被求和，留下 $i$ 和 $l$ 作为自由指标。该操作由 `einsum('ijk,ljk->il', ...)` 表示。\n\n-   **测试 4**: 验证 $\\sum_{j,k} \\epsilon_{ijk}\\delta_{jm}\\delta_{kn} = \\epsilon_{imn}$。这展示了 Kronecker delta 的“筛选”性质。对 $j$ 的求和将 $\\epsilon_{ijk}$ 中的每个 $j$ 替换为 $m$，对 $k$ 的求和将每个 $k$ 替换为 $n$。`einsum` 记法为 `ijk,jm,kn->imn`。\n\n-   **测试 5**: 验证 $\\sum_{i,j} \\epsilon_{ijk}\\delta_{ji} = 0$。这是一个在指标 $i,j$ 上反对称的张量 ($\\epsilon_{ijk}$) 与一个在 $i,j$ 上对称的张量 ($\\delta_{ji}=\\delta_{ij}$) 的缩并。结果必须为零。该操作为 `einsum('ijk,ji->k', ...)`。\n\n-   **测试 6**: 验证分量关系 $\\epsilon_{iij}=0$。问题陈述了重复指标 $i$ 不应用隐式求和。这需要小心处理以避免标准的缩并。我们构建一个 2 阶张量，其分量由 T$_{ij} = \\epsilon_{iij}$ 给出。在 `NumPy` 中，这通过使用高级索引来选择前两个轴的对角线元素来实现：`epsilon[indices, indices, :]`，其中 `indices` 是数组 `[0, 1, 2]`。然后将得到的 $3 \\times 3$ 张量与一个零矩阵进行比较。\n\n-   **测试 7**: 验证 $\\epsilon_{ijk} + \\epsilon_{jik} = 0$。这是对反对称性的直接测试。张量 $\\epsilon_{jik}$ 是通过转置 $\\epsilon_{ijk}$ 的前两个轴得到的。然后将其和与一个 3 阶零张量进行比较。\n\n-   **测试 8**: 验证 $\\sum_{k} \\epsilon_{ijk}\\epsilon_{mnk} = \\delta_{im}\\delta_{jn} - \\delta_{in}\\delta_{jm}$。这是 $\\epsilon-\\delta$ 恒等式的另一种形式。自由指标为 $i,j,m,n$，求和指标为 $k$。`einsum` 记法 `ijk,mnk->ijmn` 正确地实现了左手边。\n\n程序系统地执行这些计算，并将结果汇总成所需的输出格式。这种方法基于它们的基本定义，为给定的恒等式提供了严谨的计算证明。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs Levi-Civita and Kronecker delta tensors and uses them to\n    verify a suite of tensor identities in 3D Euclidean space.\n    \"\"\"\n    \n    # Define the fundamental tensors in 3D, using 0-based indexing {0, 1, 2}.\n    \n    # Kronecker Delta (delta_ij): A rank-2 identity tensor.\n    delta = np.eye(3, dtype=int)\n\n    # Levi-Civita Symbol (epsilon_ijk): A rank-3 fully antisymmetric tensor.\n    epsilon = np.zeros((3, 3, 3), dtype=int)\n    # Set non-zero elements for permutations of (0, 1, 2).\n    # Even permutations (+1)\n    epsilon[0, 1, 2] = 1\n    epsilon[1, 2, 0] = 1\n    epsilon[2, 0, 1] = 1\n    # Odd permutations (-1)\n    epsilon[0, 2, 1] = -1\n    epsilon[2, 1, 0] = -1\n    epsilon[1, 0, 2] = -1\n\n    results = []\n\n    # Test 1: Verify \\sum_i \\epsilon_{ijk}\\epsilon_{imn} = \\delta_{jm}\\delta_{kn} - \\delta_{jn}\\delta_{km}\n    lhs1 = np.einsum('ijk,imn->jkmn', epsilon, epsilon)\n    rhs1 = np.einsum('jm,kn->jkmn', delta, delta) - np.einsum('jn,km->jkmn', delta, delta)\n    results.append(np.array_equal(lhs1, rhs1))\n\n    # Test 2: Compute S = \\sum_{i,j,k} \\epsilon_{ijk}\\epsilon_{ijk}\n    # This full contraction results in a scalar.\n    result2 = np.einsum('ijk,ijk->', epsilon, epsilon)\n    results.append(result2.item()) # .item() extracts the scalar value.\n\n    # Test 3: Verify \\sum_{j,k} \\epsilon_{ijk}\\epsilon_{ljk} = 2\\delta_{il}\n    lhs3 = np.einsum('ijk,ljk->il', epsilon, epsilon)\n    rhs3 = 2 * delta\n    results.append(np.array_equal(lhs3, rhs3))\n\n    # Test 4: Verify \\sum_{j,k} \\epsilon_{ijk}\\delta_{jm}\\delta_{kn} = \\epsilon_{imn}\n    lhs4 = np.einsum('ijk,jm,kn->imn', epsilon, delta, delta)\n    rhs4 = epsilon\n    results.append(np.array_equal(lhs4, rhs4))\n\n    # Test 5: Verify \\sum_{i,j} \\epsilon_{ijk}\\delta_{ji} = 0\n    lhs5 = np.einsum('ijk,ji->k', epsilon, delta)\n    rhs5 = np.zeros(3, dtype=int)\n    results.append(np.array_equal(lhs5, rhs5))\n\n    # Test 6: Verify \\epsilon_{iij} = 0 (component-wise, no summation over i)\n    # We construct the tensor T_{ij} = epsilon_{iij} using advanced indexing.\n    indices = np.arange(3)\n    # lhs6[i,j] = epsilon[i,i,j]\n    lhs6 = epsilon[indices, indices, :]\n    rhs6 = np.zeros((3, 3), dtype=int)\n    results.append(np.array_equal(lhs6, rhs6))\n\n    # Test 7: Verify \\epsilon_{ijk} + \\epsilon_{jik} = 0\n    # The term \\epsilon_{jik} is a transposition of \\epsilon_{ijk}.\n    lhs7 = epsilon + epsilon.transpose(1, 0, 2)\n    rhs7 = np.zeros((3, 3, 3), dtype=int)\n    results.append(np.array_equal(lhs7, rhs7))\n\n    # Test 8: Verify \\sum_k \\epsilon_{ijk}\\epsilon_{mnk} = \\delta_{im}\\delta_{jn} - \\delta_{in}\\delta_{jm}\n    lhs8 = np.einsum('ijk,mnk->ijmn', epsilon, epsilon)\n    rhs8 = np.einsum('im,jn->ijmn', delta, delta) - np.einsum('in,jm->ijmn', delta, delta)\n    results.append(np.array_equal(lhs8, rhs8))\n    \n    # Final print statement in the exact required format.\n    # The map(str,...) ensures booleans are converted to \"True\"/\"False\" strings.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2442492"}, {"introduction": "掌握了基本规则后，我们来看看它们在实际工程中的重要性。正确的索引表示法并非学究式的吹毛求疵，而是确保物理准确性的关键。这个练习 [@problem_id:2442467] 将您带入一个真实的“bug排查”场景，其中一个微小的索引错误导致了物理上不正确的结果，这突显了在连续介质力学等领域中精确应用张量语言的必要性。", "problem": "在一个连续体的平面变形中，在某材料点测得的变形梯度张量 $F_{iJ}$，在空间构型和材料构型的标准正交基中，表示为矩阵\n$$\nF_{iJ}=\\begin{pmatrix}\n1.15 & 0.40\\\\\n-0.25 & 0.95\n\\end{pmatrix}.\n$$\n穿过同一点的一根材料纤维，其参考线元为 $dX_{J}=\\begin{pmatrix}2\\\\1\\end{pmatrix}$，长度为 $|dX|=\\sqrt{2^{2}+1^{2}}$，单位为毫米。一个有限元分析的后处理工具报告当前纤维长度为 $\\ell_{\\text{code}}=|d\\tilde{x}|$，其中它通过计算 $d\\tilde{x}_{J}=F_{iJ}\\,dX_{i}$ 得到的数值为 $\\ell_{\\text{code}}=2.695\\,\\mathrm{mm}$（四舍五入到四位有效数字）。该数值在物理上似乎是合理的。\n\n通过使用指标一致的运动学推理，确定纤维在该点的正确当前长度 $\\ell$。最终答案以 $\\mathrm{mm}$ 表示，并四舍五入到四位有效数字。最终答案必须是一个数字。", "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 变形梯度张量: $F_{iJ}=\\begin{pmatrix} 1.15 & 0.40\\\\ -0.25 & 0.95 \\end{pmatrix}$\n- 参考线元: $dX_{J}=\\begin{pmatrix}2\\\\1\\end{pmatrix}$，单位为毫米($\\mathrm{mm}$)。\n- 后处理工具的计算: $d\\tilde{x}_{J}=F_{iJ}\\,dX_{i}$。\n- 工具报告的长度: $\\ell_{\\text{code}}=|d\\tilde{x}|=2.695\\,\\mathrm{mm}$。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题基于连续介质力学的原理，特别是变形运动学，具有科学依据。这是一个适定的问题，提供了确定变形后材料纤维正确长度所需的所有信息。问题的核心是识别张量表示法应用中的一个错误。表达式 $d\\tilde{x}_{J}=F_{iJ}\\,dX_{i}$ 在运动学上是不正确的，因为它指标不匹配，并且意味着一个非物理操作。然而，问题陈述本身没有缺陷；它将这个不正确的计算作为一个前提，以供评判。数值在物理上是合理的，$\\det(F) = (1.15)(0.95) - (0.40)(-0.25) = 1.1925 > 0$，这与物理上可容许的变形是一致的。该问题是客观的，除了为纠正而故意设置的错误外，没有歧义。\n\n**步骤3：结论与行动**\n问题被判定为**有效**。将提供解答。\n\n无穷小材料线元 $d\\mathbf{X}$ 变形为空间线元 $d\\mathbf{x}$ 的基本原理是由变形梯度张量 $\\mathbf{F}$ 的作用给出的。在指标表示法中，根据标准约定，大写指标（例如 $J$）指代材料（参考）构型，小写指标（例如 $i$）指代空间（当前）构型，该关系表示为：\n$$dx_i = F_{iJ} dX_J$$\n此处，右侧的重复指标 $J$ 意味着对材料空间的维度进行求和（在本例中，从1到2）。该操作是一种线性变换，将向量从材料坐标系映射到空间坐标系，被称为推前操作。\n\n问题陈述中，后处理工具使用公式 $d\\tilde{x}_{J}=F_{iJ}\\,dX_{i}$ 计算变形后的向量。从张量分析和连续介质力学的角度来看，该表达式是根本错误的。\n1. 材料线元是 $dX_J$，因此其分量应使用指标 $J$，而不是 $i$。而表达式中使用了 $dX_i$。\n2. 求和是针对指标 $i$ 进行的，而 $i$ 是一个空间指标。缩并操作应在 $F_{iJ}$ 的材料指标和 $dX_J$ 的材料指标之间进行。\n3. 结果向量被记为 $d\\tilde{x}_{J}$，使用的是材料指标 $J$。变形后的向量存在于空间构型中，因此必须带有空间指标，如 $i$。\n\n代码执行的操作 $d\\tilde{x}_{J}=F_{iJ}\\,dX_{i}$ 对应于矩阵运算 $d\\tilde{\\mathbf{x}} = \\mathbf{F}^T d\\mathbf{X}$，其中 $\\mathbf{F}^T$ 是变形梯度的转置。这不是材料线元的正确运动学变换。计算出的长度 $\\ell_{\\text{code}}=2.695\\,\\mathrm{mm}$ 看起来“物理上合理”这一事实，与底层公式的数学和物理正确性无关。\n\n我们现在进行正确的计算。已知量为：\n$$F_{iJ} = \\begin{pmatrix} 1.15 & 0.40 \\\\ -0.25 & 0.95 \\end{pmatrix}$$\n$$dX_J = \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix}$$\n变形后的空间线元 $dx_i$ 的分量通过矩阵-向量乘法 $d\\mathbf{x} = \\mathbf{F} d\\mathbf{X}$ 计算：\n$$\ndx_i = \\begin{pmatrix} 1.15 & 0.40 \\\\ -0.25 & 0.95 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix}\n= \\begin{pmatrix} (1.15)(2) + (0.40)(1) \\\\ (-0.25)(2) + (0.95)(1) \\end{pmatrix}\n= \\begin{pmatrix} 2.3 + 0.4 \\\\ -0.5 + 0.95 \\end{pmatrix}\n= \\begin{pmatrix} 2.7 \\\\ 0.45 \\end{pmatrix}\n$$\n因此，变形后向量在空间基中的分量为 $dx_1 = 2.7$ 和 $dx_2 = 0.45$。\n\n纤维的正确当前长度 $\\ell$ 是向量 $dx_i$ 的欧几里得范数（模）：\n$$\\ell = |d\\mathbf{x}| = \\sqrt{(dx_1)^2 + (dx_2)^2}$$\n代入计算出的分量：\n$$\\ell = \\sqrt{(2.7)^2 + (0.45)^2} = \\sqrt{7.29 + 0.2025} = \\sqrt{7.4925}$$\n数值为：\n$$\\ell \\approx 2.7372431... \\, \\mathrm{mm}$$\n按要求四舍五入到四位有效数字：\n$$\\ell \\approx 2.737 \\, \\mathrm{mm}$$\n这就是材料纤维的正确当前长度。", "answer": "$$\\boxed{2.737}$$", "id": "2442467"}, {"introduction": "最后，我们将理论推导与编程实践相结合，完成一项在计算工程中至关重要的任务。将一个二阶张量 $T_{ij}$ 分解为其对称、反对称和各向同性（球形）部分是在应力应变分析和材料建模中的一个基本操作。这个练习 [@problem_id:2442512] 将指导您从第一性原理出发，推导分解公式并将其实现为一个实用的计算工具，从而巩固您对张量结构和物理意义的理解。", "problem": "在维度为 $n \\in \\{2,3\\}$ 的有限维欧几里得空间中，给定一个任意的实数二阶方张量 $T_{ij}$。请使用计算工程学中张量分析的标准指标约定，实现一个程序，为每个给定的 $T_{ij}$ 计算其三个部分的分解：对称部分 $S_{ij}$、反对称部分 $A_{ij}$ 和各向同性（球形）部分 $J_{ij}$。该分解必须仅使用以下概念基础从第一性原理推导得出：指标换位的定义、作为单位张量的克罗内克δ $ \\delta_{ij} $、迹 $ \\mathrm{tr}(T) = T_{ii} $ 以及爱因斯坦求和约定（ESC）。各向同性部分必须是一个与 $ \\delta_{ij} $ 成比例的张量。您的实现还必须验证由 $D_{ij} = S_{ij} - J_{ij}$ 定义的偏对称部分 $D_{ij}$ 是无迹的，并且重构 $T_{ij} = D_{ij} + A_{ij} + J_{ij}$ 在数值上成立。\n\n您的程序必须：\n- 根据上述定义，推导并实现从 $T_{ij}$ 计算 $S_{ij}$、$A_{ij}$ 和 $J_{ij}$ 的运算。您不得依赖任何未经证明的捷径。\n- 对于每个输入张量 $T_{ij}$，计算 $S_{ij}$、$A_{ij}$ 和 $J_{ij}$，然后验证：\n  1. $J_{ij}$ 与 $ \\delta_{ij} $ 成比例的各向同性。\n  2. $D_{ij} = S_{ij} - J_{ij}$ 的无迹性，即 $D_{ii} = 0$。\n  3. 在浮点误差容限内，精确重构 $T_{ij} = D_{ij} + A_{ij} + J_{ij}$。\n- 在为输出聚合而展开矩阵时，采用行主序（C序）。\n\n测试套件：\n使用以下固定的输入测试套件。每个 $T_{ij}$ 都以矩阵形式给出，用于 $n = 3$ 或 $n = 2$。\n- 情况 $1$ ($n = 3$): \n  $$\n  T^{(1)} = \\begin{bmatrix}\n  2 & -1 & 4 \\\\\n  3 & 0 & 5 \\\\\n  7 & -2 & 1\n  \\end{bmatrix}\n  $$\n- 情况 $2$ ($n = 3$): \n  $$\n  T^{(2)} = \\begin{bmatrix}\n  4 & 1 & -2 \\\\\n  1 & -3 & 0 \\\\\n  -2 & 0 & 5\n  \\end{bmatrix}\n  $$\n- 情况 $3$ ($n = 3$): \n  $$\n  T^{(3)} = \\begin{bmatrix}\n  0 & 2 & -1 \\\\\n  -2 & 0 & 3 \\\\\n  1 & -3 & 0\n  \\end{bmatrix}\n  $$\n- 情况 $4$ ($n = 2$): \n  $$\n  T^{(4)} = \\begin{bmatrix}\n  5 & -7 \\\\\n  9 & -1\n  \\end{bmatrix}\n  $$\n\n输出规范：\n- 对于每种情况 $k \\in \\{1,2,3,4\\}$，通过拼接以下内容构造一个单一列表：\n  1. $S^{(k)}_{ij}$ 按行主序展开的元素，四舍五入到 $6$ 位小数。\n  2. $A^{(k)}_{ij}$ 按行主序展开的元素，四舍五入到 $6$ 位小数。\n  3. $J^{(k)}_{ij}$ 按行主序展开的元素，四舍五入到 $6$ 位小数。\n  4. 标量最大绝对重构误差 $ \\max_{i,j} | T^{(k)}_{ij} - (S^{(k)}_{ij} - J^{(k)}_{ij} + A^{(k)}_{ij} + J^{(k)}_{ij}) | $，四舍五入到 $12$ 位小数。\n- 您的程序应生成单行输出，其中包含四个情况的四个列表的结果，以逗号分隔，并用方括号括起来（例如，一个列表的列表，如 $[ \\ldots ]$）。此问题不涉及单位。不使用角度。\n\n您的实现必须是完全确定性的，完全按照规定使用提供的测试套件，并且不得要求任何用户输入。最终打印的数据类型必须是纯数字（布尔值、整数或浮点数）或这些类型的列表，如上所述。必须对输出中包含的分量应用上述浮点舍入规则。", "solution": "所陈述的问题是有效的。它具有科学依据，定义明确，客观，并包含了获得唯一且有意义解所需的所有必要信息。将张量分解为对称、反对称和各向同性部分是连续介质力学和计算工程学中的基本概念。我们将按部就班地从第一性原理推导解答。\n\n一个 $n$ 维空间中的任意二阶张量 $T_{ij}$ 可以唯一地分解为其对称部分 $S_{ij}$ 和其反对称（或斜对称）部分 $A_{ij}$。该分解是加性的：\n$$T_{ij} = S_{ij} + A_{ij}$$\n根据定义，对称张量在其指标换位后不变，即 $S_{ij} = S_{ji}$。反对称张量则变号，即 $A_{ij} = -A_{ji}$。\n\n为了找到 $S_{ij}$ 和 $A_{ij}$ 的显式形式，我们考虑 $T_{ij}$ 的转置：\n$$T_{ji} = S_{ji} + A_{ji}$$\n利用 $S_{ij}$ 和 $A_{ij}$ 的定义性质，上式变为：\n$$T_{ji} = S_{ij} - A_{ij}$$\n我们现在有两个未知张量 $S_{ij}$ 和 $A_{ij}$ 的线性方程组：\n$$(1) \\quad T_{ij} = S_{ij} + A_{ij}$$\n$$(2) \\quad T_{ji} = S_{ij} - A_{ij}$$\n将方程 $(1)$ 和 $(2)$ 相加得到：\n$$T_{ij} + T_{ji} = (S_{ij} + A_{ij}) + (S_{ij} - A_{ij}) = 2S_{ij}$$\n由此我们分离出对称部分：\n$$S_{ij} = \\frac{1}{2}(T_{ij} + T_{ji})$$\n从方程 $(1)$ 中减去方程 $(2)$ 得到：\n$$T_{ij} - T_{ji} = (S_{ij} + A_{ij}) - (S_{ij} - A_{ij}) = 2A_{ij}$$\n由此我们分离出反对称部分：\n$$A_{ij} = \\frac{1}{2}(T_{ij} - T_{ji})$$\n这完成了分解的第一阶段。注意，反对称部分的迹必然为零：$A_{ii} = \\frac{1}{2}(T_{ii} - T_{ii}) = 0$。因此，张量 $T_{ij}$ 的迹与其对称部分的迹相同：$\\mathrm{tr}(T) = T_{ii} = S_{ii}$。\n\n分解的第二阶段将对称张量 $S_{ij}$ 分离为一个各向同性（或球形）部分 $J_{ij}$ 和一个偏量部分 $D_{ij}$。这个分解也是加性的：\n$$S_{ij} = J_{ij} + D_{ij}$$\n根据定义，各向同性部分 $J_{ij}$ 是一个与单位张量成比例的张量，在指标表示法中单位张量即为克罗内克δ, $\\delta_{ij}$。因此，我们可以写出：\n$$J_{ij} = \\alpha \\delta_{ij}$$\n其中 $\\alpha$ 是一个待定的标量系数。偏量部分 $D_{ij}$ 被定义为无迹的，意味着其迹为零：$D_{ii} = 0$。注意，对于重复指标，隐含了爱因斯坦求和约定。\n\n为了求出标量 $\\alpha$，我们对分解式 $S_{ij} = J_{ij} + D_{ij}$ 取迹：\n$$S_{ii} = (J_{ij} + D_{ij})_{ii} = J_{ii} + D_{ii}$$\n由于根据定义 $D_{ii} = 0$，我们有 $S_{ii} = J_{ii}$。现在我们计算 $J_{ij}$ 的迹：\n$$J_{ii} = (\\alpha \\delta_{ij})_{ii} = \\alpha \\delta_{ii}$$\n在 $n$ 维空间中，克罗内克δ的迹是其对角元素之和，$\\delta_{ii} = \\sum_{i=1}^{n} \\delta_{ii} = \\sum_{i=1}^{n} 1 = n$。\n因此，$J_{ii} = \\alpha n$。\n令迹相等，$S_{ii} = \\alpha n$，我们求得标量系数 $\\alpha$：\n$$\\alpha = \\frac{S_{ii}}{n}$$\n正如我们已经确定的 $S_{ii} = T_{ii} = \\mathrm{tr}(T)$，$\\alpha$ 的表达式简化为 $\\alpha = \\frac{1}{n}\\mathrm{tr}(T)$。\n将其代回，得到各向同性张量的公式：\n$$J_{ij} = \\frac{1}{n} T_{kk} \\delta_{ij}$$\n这里，我们使用 $k$ 作为求和指标，以避免与自由指标 $i$ 和 $j$ 冲突。\n\n然后通过相减得到偏量部分：\n$$D_{ij} = S_{ij} - J_{ij} = S_{ij} - \\frac{1}{n} T_{kk} \\delta_{ij}$$\n原问题要求验证总重构 $T_{ij} = D_{ij} + A_{ij} + J_{ij}$。通过代入各部分的定义，我们看到这在代数上是精确的：\n$$D_{ij} + A_{ij} + J_{ij} = (S_{ij} - J_{ij}) + A_{ij} + J_{ij} = S_{ij} + A_{ij} = T_{ij}$$\n实现将为每个给定的张量在浮点精度范围内数值验证此恒等式。\n\n实现的算法如下：\n对于每个维度为 $n$ 的输入张量 $T_{ij}$：\n$1$. 计算转置 $T_{ji}$。\n$2$. 计算对称部分：$S_{ij} = \\frac{1}{2}(T_{ij} + T_{ji})$。\n$3$. 计算反对称部分：$A_{ij} = \\frac{1}{2}(T_{ij} - T_{ji})$。\n$4$. 计算原始张量的迹：$T_{kk} = \\sum_{k=1}^{n} T_{kk}$。\n$5$. 构建维度为 $n$ 的单位张量 $\\delta_{ij}$。\n$6$. 计算各向同性部分：$J_{ij} = \\left(\\frac{1}{n} T_{kk}\\right) \\delta_{ij}$。\n$7$. 问题要求验证偏量部分 $D_{ij} = S_{ij} - J_{ij}$ 的无迹性。我们可以从解析上确认这一点。其迹为 $D_{ii} = S_{ii} - J_{ii} = T_{kk} - (\\frac{1}{n} T_{ll} \\delta_{ij})_{ii} = T_{kk} - \\frac{1}{n} T_{ll} \\delta_{ii} = T_{kk} - \\frac{1}{n} T_{ll} (n) = T_{kk} - T_{ll} = 0$。实现将数值确认这一点。\n$8$. 重构张量：$T'_{ij} = (S_{ij} - J_{ij}) + A_{ij} + J_{ij} = S_{ij} + A_{ij}$。\n$9$. 计算最大绝对重构误差：$\\epsilon = \\max_{i,j} |T_{ij} - T'_{ij}|$。\n$10$. 遵从舍入规则，将展开的分量 $S_{ij}$、$A_{ij}$、$J_{ij}$ 和误差 $\\epsilon$ 整理成指定的输出格式。\n此过程将应用于所有测试用例。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the tensor decomposition problem for a fixed test suite.\n    The function adheres to the strict output specification.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([[2, -1, 4], [3, 0, 5], [7, -2, 1]], dtype=float),\n        np.array([[4, 1, -2], [1, -3, 0], [-2, 0, 5]], dtype=float),\n        np.array([[0, 2, -1], [-2, 0, 3], [1, -3, 0]], dtype=float),\n        np.array([[5, -7], [9, -1]], dtype=float),\n    ]\n\n    all_results = []\n    \n    for T in test_cases:\n        # Get the dimension of the space\n        n = T.shape[0]\n\n        # 1. Derive Symmetric (S_ij) and Anti-symmetric (A_ij) parts\n        # S_ij = 1/2 * (T_ij + T_ji)\n        S = 0.5 * (T + T.T)\n        \n        # A_ij = 1/2 * (T_ij - T_ji)\n        A = 0.5 * (T - T.T)\n\n        # 2. Decompose Symmetric part S_ij into Isotropic (J_ij) and Deviatoric (D_ij) parts\n        # The isotropic part J_ij is proportional to the identity tensor (Kronecker delta).\n        # J_ij = alpha * delta_ij\n        # The deviatoric part D_ij is traceless: D_ii = 0.\n        # S_ij = J_ij + D_ij\n        # Taking the trace: S_ii = J_ii + D_ii = J_ii\n        # Trace of J_ij is J_ii = alpha * delta_ii = alpha * n\n        # Trace of S_ij is S_ii = tr(S) = tr(T)\n        # So, tr(T) = alpha * n  =>  alpha = tr(T) / n\n        tr_T = np.trace(T)\n        \n        # J_ij = (1/n) * tr(T) * delta_ij\n        J = (tr_T / n) * np.identity(n)\n\n        # D_ij = S_ij - J_ij\n        D = S - J\n        \n        # 3. Verification steps as required by the problem\n        # The problem requires verifying that D is traceless and that reconstruction holds.\n        # Tracelessness of D:\n        tr_D = np.trace(D)\n        # This should be zero up to floating point error. We assert this internally.\n        assert np.isclose(tr_D, 0.0), f\"Deviatoric part is not traceless: trace is {tr_D}\"\n\n        # Reconstruction: T_ij = D_ij + A_ij + J_ij\n        # This simplifies to T_ij = (S_ij - J_ij) + A_ij + J_ij = S_ij + A_ij\n        T_reconstructed = D + A + J\n        \n        # Calculate maximum absolute reconstruction error\n        max_reconstruction_error = np.max(np.abs(T - T_reconstructed))\n\n        # 4. Prepare output per specification\n        # Flattened components with rounding to 6 decimal places\n        s_flat = np.round(S.flatten(), 6).tolist()\n        a_flat = np.round(A.flatten(), 6).tolist()\n        j_flat = np.round(J.flatten(), 6).tolist()\n        \n        # Reconstruction error rounded to 12 decimal places\n        error_rounded = round(max_reconstruction_error, 12)\n\n        # Concatenate into a single list for the current case\n        case_result = s_flat + a_flat + j_flat + [error_rounded]\n        all_results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # Produces a string representation of a list of lists: \"[[...],[...],...]\"\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2442512"}]}