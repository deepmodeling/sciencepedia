{"hands_on_practices": [{"introduction": "让我们从计算数值线性代数中的一个基本构件——吉文斯 (Givens) 旋转矩阵的范数开始。这个练习将引导你将最常见的几种矩阵范数（$1$-范数、$\\\\infty$-范数、$2$-范数和弗罗贝尼乌斯范数）的定义应用到一个具体的例子上。通过比较不同范数的计算结果，你将获得一个至关重要的洞见：矩阵的“大小”并非一个绝对的概念，而是取决于所选择的衡量标准（即范数），并且你会理解为什么 $2$-范数与我们关于旋转的几何直觉最为吻合。[@problem_id:2449542]", "id": "2449542", "problem": "在计算工程的数值线性代数中，Givens 旋转用于在保持欧几里得长度的同时引入零元素。设 $n \\ge 2$ 为整数，考虑一个作用于坐标索引 $p$ 和 $q$（其中 $1 \\le p < q \\le n$）的 $n \\times n$ Givens 旋转矩阵 $G$，该矩阵将行和列 $\\{p,q\\}$ 中的 $2 \\times 2$ 主子矩阵替换为\n$$\n\\begin{pmatrix}\n\\cos\\theta & \\sin\\theta \\\\\n-\\sin\\theta & \\cos\\theta\n\\end{pmatrix},\n$$\n并使所有其他对角线元素等于 $1$，所有其他非对角线元素等于 $0$。仅使用诱导矩阵范数和 Frobenius 范数的定义，确定矩阵 $1$-范数 $\\|G\\|_{1}$、矩阵 $2$-范数 $\\|G\\|_{2}$、矩阵 $\\infty$-范数 $\\|G\\|_{\\infty}$ 和 Frobenius 范数 $\\|G\\|_{F}$ 作为 $n$ 和 $\\theta$ 的函数的精确表达式。请以精确解析表达式的形式提供最终答案。无需四舍五入。最后，根据长度保持性和范数依赖性简要解释你的结果。", "solution": "首先对问题陈述进行验证。\n\n**第 1 步：提取 Givens 相关信息**\n- $n$ 是一个整数， $n \\ge 2$。\n- $G$ 是一个 $n \\times n$ 的 Givens 旋转矩阵。\n- 矩阵作用于坐标索引 $p$ 和 $q$，其中 $1 \\le p < q \\le n$。\n- 在行和列 $\\{p,q\\}$ 上的 $2 \\times 2$ 主子矩阵是 $\\begin{pmatrix} \\cos\\theta & \\sin\\theta \\\\ -\\sin\\theta & \\cos\\theta \\end{pmatrix}$。\n- 所有其他对角线元素为 $1$。\n- 所有其他非对角线元素为 $0$。\n- 任务是仅使用范数的定义来确定 $\\|G\\|_{1}$、$\\|G\\|_{2}$、$\\|G\\|_{\\infty}$ 和 $\\|G\\|_{F}$ 的精确表达式。\n- 需要对结果进行解释。\n\n**第 2 步：使用提取的信息进行验证**\n- **科学依据：** 该问题基于数值线性代数中标准、明确定义的概念，特别是 Givens 旋转和矩阵范数。这些都是计算工程中的基本工具。\n- **适定性：** 对于任何有效的 $n$、$p$、$q$ 和 $\\theta$，矩阵 $G$ 都有明确的定义。矩阵范数是标准的数学函数，对于任何给定的矩阵都有唯一的输出。该问题是适定的。\n- **客观性：** 该问题使用精确的数学语言陈述，没有主观性或模糊性。\n\n**第 3 步：结论与行动**\n该问题具有科学性、适定性、客观性和完整性。因此，该问题被认定为**有效**。我们可以继续进行求解。\n\nGivens 旋转矩阵 $G$ 是一个 $n \\times n$ 矩阵，它与单位矩阵 $I_n$ 相同，只有四个元素不同。$G$ 的元素（记为 $g_{ij}$）是：\n$g_{pp} = \\cos\\theta$\n$g_{qq} = \\cos\\theta$\n$g_{pq} = \\sin\\theta$\n$g_{qp} = -\\sin\\theta$\n$g_{ii} = 1$ 对于 $i \\in \\{1, \\dots, n\\} \\setminus \\{p, q\\}$\n$g_{ij} = 0$ 对于所有其他 $i \\ne j$ 的配对 $(i, j)$。\n\n我们现在将根据它们的基本定义来计算所需的范数。\n\n**1. 矩阵 $1$-范数 ($\\|G\\|_{1}$)**\n矩阵 $1$-范数，或称列和范数，定义为各列绝对值之和的最大值：\n$$ \\|G\\|_{1} = \\max_{1 \\le j \\le n} \\sum_{i=1}^{n} |g_{ij}| $$\n我们检查 $G$ 的各列：\n- 对于任何满足 $j \\ne p$ 且 $j \\ne q$ 的列 $j$，唯一的非零元素是 $g_{jj} = 1$。该列的绝对值之和为 $|1| = 1$。\n- 对于列 $p$，非零元素是 $g_{pp} = \\cos\\theta$ 和 $g_{qp} = -\\sin\\theta$。其和为 $|g_{pp}| + |g_{qp}| = |\\cos\\theta| + |-\\sin\\theta| = |\\cos\\theta| + |\\sin\\theta|$。\n- 对于列 $q$，非零元素是 $g_{pq} = \\sin\\theta$ 和 $g_{qq} = \\cos\\theta$。其和为 $|g_{pq}| + |g_{qq}| = |\\sin\\theta| + |\\cos\\theta|$。\n\n$1$-范数是这些和的最大值：\n$$ \\|G\\|_{1} = \\max(1, |\\cos\\theta| + |\\sin\\theta|) $$\n我们知道，对于任何实数 $\\theta$，$|\\cos\\theta| + |\\sin\\theta| \\ge \\sqrt{\\cos^2\\theta + \\sin^2\\theta} = 1$。等号成立的条件是 $\\theta$ 为 $\\frac{\\pi}{2}$ 的整数倍。因此，最大值总是 $|\\cos\\theta| + |\\sin\\theta|$。\n$$ \\|G\\|_{1} = |\\cos\\theta| + |\\sin\\theta| $$\n\n**2. 矩阵 $\\infty$-范数 ($\\|G\\|_{\\infty}$)**\n矩阵 $\\infty$-范数，或称行和范数，定义为各行绝对值之和的最大值：\n$$ \\|G\\|_{\\infty} = \\max_{1 \\le i \\le n} \\sum_{j=1}^{n} |g_{ij}| $$\n我们检查 $G$ 的各行：\n- 对于任何满足 $i \\ne p$ 且 $i \\ne q$ 的行 $i$，唯一的非零元素是 $g_{ii} = 1$。该行的绝对值之和为 $|1| = 1$。\n- 对于行 $p$，非零元素是 $g_{pp} = \\cos\\theta$ 和 $g_{pq} = \\sin\\theta$。其和为 $|g_{pp}| + |g_{pq}| = |\\cos\\theta| + |\\sin\\theta|$。\n- 对于行 $q$，非零元素是 $g_{qp} = -\\sin\\theta$ 和 $g_{qq} = \\cos\\theta$。其和为 $|g_{qp}| + |g_{qq}| = |-\\sin\\theta| + |\\cos\\theta| = |\\sin\\theta| + |\\cos\\theta|$。\n\n与 $1$-范数的逻辑相同，这些和的最大值为：\n$$ \\|G\\|_{\\infty} = |\\cos\\theta| + |\\sin\\theta| $$\n\n**3. 矩阵 $2$-范数 ($\\|G\\|_{2}$)**\n矩阵 $2$-范数，或称谱范数，定义为矩阵 $G^T G$ 最大特征值的平方根：\n$$ \\|G\\|_{2} = \\sqrt{\\lambda_{\\max}(G^T G)} $$\n矩阵 $G$ 是一个正交矩阵。我们通过计算 $G^T G$ 来验证这一点。转置矩阵 $G^T$ 与 $G$ 相同，只是 $g_{pq}$ 和 $g_{qp}$ 的角色互换了。因此，$g_{pq}^T = g_{qp} = -\\sin\\theta$ 且 $g_{qp}^T = g_{pq} = \\sin\\theta$。\n乘积 $G^T G$ 将是一个单位矩阵。要理解这一点，可以考虑子矩阵的作用。$G$ 的 $2 \\times 2$ 子矩阵是 $R(\\theta) = \\begin{pmatrix} \\cos\\theta & \\sin\\theta \\\\ -\\sin\\theta & \\cos\\theta \\end{pmatrix}$。其转置是 $R(\\theta)^T = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{pmatrix}$。\n乘积为：\n$$ R(\\theta)^T R(\\theta) = \\begin{pmatrix} \\cos^2\\theta + \\sin^2\\theta & \\cos\\theta\\sin\\theta - \\sin\\theta\\cos\\theta \\\\ \\sin\\theta\\cos\\theta - \\cos\\theta\\sin\\theta & \\sin^2\\theta + \\cos^2\\theta \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} $$\n由于 $G$ 的所有其他行和列都是标准基向量，整个矩阵乘积 $G^T G$ 的结果是 $n \\times n$ 的单位矩阵 $I_n$。\n$I_n$ 的特征值都等于 $1$。因此，$\\lambda_{\\max}(G^T G) = 1$。\n所以，$2$-范数为：\n$$ \\|G\\|_{2} = \\sqrt{1} = 1 $$\n\n**4. Frobenius 范数 ($\\|G\\|_{F}$)**\nFrobenius 范数定义为所有元素模的平方和的平方根：\n$$ \\|G\\|_{F} = \\sqrt{\\sum_{i=1}^{n} \\sum_{j=1}^{n} |g_{ij}|^2} $$\n我们对 $G$ 的所有非零元素的平方求和：\n- 有 $(n-2)$ 个元素等于 $1$（索引不是 $p$ 和 $q$ 的对角元素）。它们对平方和的贡献是 $(n-2) \\times 1^2 = n-2$。\n- 在 $\\{p,q\\}$ 子块中的四个元素是 $\\cos\\theta$、$\\sin\\theta$、$-\\sin\\theta$ 和 $\\cos\\theta$。它们对平方和的贡献是 $(\\cos\\theta)^2 + (\\sin\\theta)^2 + (-\\sin\\theta)^2 + (\\cos\\theta)^2 = 2\\cos^2\\theta + 2\\sin^2\\theta = 2(\\cos^2\\theta + \\sin^2\\theta) = 2$。\n\n总平方和为 $(n-2) + 2 = n$。\n因此，Frobenius 范数为：\n$$ \\|G\\|_{F} = \\sqrt{n} $$\n\n**结果的解释**\n问题要求根据长度保持性和范数依赖性来解释结果。\n- **长度保持性：** 结果 $\\|G\\|_{2} = 1$ 是 Givens 旋转在欧几里得空间中是等距变换这一几何性质的数学表述。矩阵的 $2$-范数衡量的是它能将一个向量的欧几里得长度（$\\|x\\|_2$）拉伸的最大因子。值为 $1$ 意味着没有向量的长度被改变，即对于所有 $x \\in \\mathbb{R}^n$，都有 $\\|Gx\\|_{2} = \\|x\\|_{2}$。这正是“保持欧几里得长度”的含义。\n- **范数依赖性：** 这些结果表明，矩阵 $G$ 的“大小”取决于所选择的范数。虽然在欧几里得意义上它是一个大小为 $1$ 的纯旋转（$\\|G\\|_2=1$），但它的 $1$-范数和 $\\infty$-范数，即 $\\|G\\|_{1} = \\|G\\|_{\\infty} = |\\cos\\theta| + |\\sin\\theta|$，却依赖于旋转角 $\\theta$，并且可以大到 $\\sqrt{2}$。这表明，对于欧几里得范数来说是纯旋转的变换，在其他范数（例如，$1$-范数或 $\\infty$-范数）下衡量时，可能起到放大的作用。Frobenius 范数 $\\|G\\|_{F}=\\sqrt{n}$ 仅依赖于空间的维度 $n$，而与角度 $\\theta$ 无关。这是因为旋转仅仅是在活动子块内重新分配矩阵元素的模平方值，使其总和保持不变，而范数则计算所有元素，包括对角线上 $n-2$ 个不变的单位元素。不同范数下的不同结果凸显出，对于线性变换的“大小”，并不存在单一、普适的度量；该度量依赖于所使用的度量标准。", "answer": "$$ \\boxed{\\begin{pmatrix} |\\cos\\theta| + |\\sin\\theta| & 1 & |\\cos\\theta| + |\\sin\\theta| & \\sqrt{n} \\end{pmatrix}} $$"}, {"introduction": "虽然有限维空间中的所有范数在理论上都是“等价”的，但在实际应用中，这种说法可能具有误导性，因为其等价常数可能依赖于空间的维度。本练习将通过构造一个特定的矩阵序列，来探索这种等价关系的局限性，并证明两种常见范数之比会随着矩阵维数的增长而趋于无穷。[@problem_id:2449576] 这个练习有力地揭示了，在计算领域，尤其是在处理由物理问题离散化而来的大规模矩阵时，范数的选择为何至关重要。这是理解算法扩展性（scaling）时必须掌握的关键一课。", "id": "2449576", "problem": "在计算工程学中，性能与稳定性分析经常要比较维数随离散化参数增长的空间上的不同范数。对于每个正整数 $n \\in \\mathbb{N}$，考虑矩阵 $A_n \\in \\mathbb{R}^{n \\times n}$，其元素定义为当 $j=1$ 时 $[A_n]_{i j} = 1$，而当 $j \\neq 1$ 时 $[A_n]_{i j} = 0$。设矩阵 $A$ 的诱导 $1$-范数定义为 $\\|A\\|_1 = \\max_{x \\in \\mathbb{R}^n \\setminus \\{0\\}} \\frac{\\|A x\\|_1}{\\|x\\|_1}$，其中向量 $1$-范数为 $\\|x\\|_1 = \\sum_{i=1}^{n} |x_i|$。设弗罗贝尼乌斯范数定义为 $\\|A\\|_F = \\sqrt{\\sum_{i=1}^{n}\\sum_{j=1}^{n} ([A]_{i j})^2}$。\n\n计算比值 $r(n) = \\frac{\\|A_n\\|_1}{\\|A_n\\|_F}$，并将其表示为关于 $n$ 的闭合形式函数。请以关于 $n$ 的单个解析表达式的形式给出最终答案。无需进行舍入。", "solution": "所述问题是有效的。这是计算工程学中的一个适定数学练习，没有任何科学、逻辑或事实上的缺陷。所有术语均为标准术语，且定义精确。下面我们开始解答。\n\n问题要求计算特定矩阵族 $A_n \\in \\mathbb{R}^{n \\times n}$ 的比值 $r(n) = \\frac{\\|A_n\\|_1}{\\|A_n\\|_F}$。对于每个正整数 $n$，矩阵 $A_n$ 的元素定义如下：\n$$\n[A_n]_{i j} = \\begin{cases} 1 & \\text{if } j = 1 \\\\ 0 & \\text{if } j \\neq 1 \\end{cases}\n$$\n这意味着对于任意给定的 $n$，矩阵 $A_n$ 的第一列元素全为1，而所有其他列的元素全为0。\n$$\nA_n = \\begin{pmatrix}\n1 & 0 & \\dots & 0 \\\\\n1 & 0 & \\dots & 0 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n1 & 0 & \\dots & 0\n\\end{pmatrix}\n$$\n\n首先，我们计算诱导 $1$-范数 $\\|A_n\\|_1$。问题中给出的定义是 $\\|A\\|_1 = \\max_{x \\neq 0} \\frac{\\|Ax\\|_1}{\\|x\\|_1}$。线性代数中的一个标准结论是，矩阵的诱导 $1$-范数等于其最大绝对列和。也就是说，对于任意矩阵 $A \\in \\mathbb{R}^{m \\times n}$：\n$$\n\\|A\\|_1 = \\max_{1 \\le j \\le n} \\sum_{i=1}^{m} |[A]_{ij}|\n$$\n我们将此公式应用于矩阵 $A_n \\in \\mathbb{R}^{n \\times n}$。我们必须计算每列元素的绝对值之和，并找出这些和中的最大值。\n\n对于第一列 ($j=1$):\n$$\n\\sum_{i=1}^{n} |[A_n]_{i1}| = \\sum_{i=1}^{n} |1| = \\sum_{i=1}^{n} 1 = n\n$$\n对于任何其他列 ($j > 1$):\n$$\n\\sum_{i=1}^{n} |[A_n]_{ij}| = \\sum_{i=1}^{n} |0| = 0\n$$\n列和的集合是 $\\{n, 0, 0, \\ldots, 0\\}$。此集合的最大值显然是 $n$。\n因此，$A_n$ 的诱导 $1$-范数为：\n$$\n\\|A_n\\|_1 = n\n$$\n\n接下来，我们计算弗罗贝尼乌斯范数 $\\|A_n\\|_F$。其定义为：\n$$\n\\|A\\|_F = \\sqrt{\\sum_{i=1}^{n}\\sum_{j=1}^{n} ([A]_{i j})^2}\n$$\n我们将此定义应用于矩阵 $A_n$。$A_n$ 的非零元素为 $[A_n]_{i1} = 1$（对于 $i=1, \\ldots, n$）。所有其他元素均为0。\n所有元素的平方和为：\n$$\n\\sum_{i=1}^{n}\\sum_{j=1}^{n} ([A_n]_{i j})^2 = \\sum_{i=1}^{n} ([A_n]_{i 1})^2 + \\sum_{i=1}^{n} \\sum_{j=2}^{n} ([A_n]_{i j})^2\n$$\n代入元素的值：\n$$\n\\sum_{i=1}^{n} (1)^2 + \\sum_{i=1}^{n} \\sum_{j=2}^{n} (0)^2 = \\sum_{i=1}^{n} 1 + 0 = n\n$$\n弗罗贝尼乌斯范数是这个和的平方根。\n$$\n\\|A_n\\|_F = \\sqrt{n}\n$$\n\n最后，我们计算所要求的比值 $r(n)$。\n$$\nr(n) = \\frac{\\|A_n\\|_1}{\\|A_n\\|_F}\n$$\n代入我们求得的范数表达式：\n$$\nr(n) = \\frac{n}{\\sqrt{n}}\n$$\n由于 $n$ 是一个正整数，$n \\ge 1$，我们可以简化此表达式。\n$$\nr(n) = \\frac{(\\sqrt{n})^2}{\\sqrt{n}} = \\sqrt{n}\n$$\n该比值作为 $n$ 的函数，是 $\\sqrt{n}$。", "answer": "$$\n\\boxed{\\sqrt{n}}\n$$"}, {"introduction": "现在，我们从理论计算转向一个直接的计算应用，这个应用揭示了数值计算中最重大的风险之一：病态问题 (ill-conditioning)。这个任务要求你设计一个数值实验，展示矩阵的条件数——一个用范数定义的量——如何预示线性系统解对输入数据微小扰动的敏感性。[@problem_id:2449583] 通过亲手实现这个实验，你将目睹一个看似微不足道的输入误差，在求解一个由病态矩阵构成的线性系统时，如何被灾难性地放大，从而导致完全错误的答案。这段动手实践将巩固范数和条件数在评估数值解的可靠性与稳定性方面不可或缺的作用。", "id": "2449583", "problem": "设计并实现一个完整的可运行程序，该程序执行一个数值实验，以证明对于一个病态矩阵 (ill-conditioned matrix) $A$，向量 $b$ 中的一个微小相对误差可能导致线性系统 $A x = b$ 的解 $x$ 出现巨大的相对误差。该实验必须严格基于第一性原理：范数、相对误差以及线性求解的定义。所有量都必须使用向量和矩阵的 $2$-范数。对于每个指定的测试用例，程序必须计算定义如下的放大因子\n$$\nr \\;=\\; \\frac{\\|x_{\\epsilon} - x^\\star\\|_{2} / \\|x^\\star\\|_{2}}{\\|\\delta b\\|_{2} / \\|b\\|_{2}},\n$$\n其中 $x^\\star$ 是对应于未扰动右端项 $b$ 的精确解，$\\delta b$ 是 $b$ 的一个扰动，而 $x_{\\epsilon}$ 是 $A x = b + \\delta b$ 的解。每个测试用例中，程序必须使用以下实验设置：\n- 令 $x^\\star$ 为 $\\mathbb{R}^n$ 中所有分量均为 $1$ 的向量。\n- 令 $b = A x^\\star$。\n- 令扰动方向 $v \\in \\mathbb{R}^n$ 的分量定义为 $v_i = \\frac{(-1)^{i-1}}{\\sqrt{n}}$ (对于 $i = 1, \\dots, n$），因此 $\\|v\\|_2 = 1$。\n- 令 $\\delta b = \\epsilon \\, \\|b\\|_2 \\, v$，其中 $\\epsilon$ 是为该测试指定的相对扰动大小。\n- 令 $x_{\\epsilon}$ 为 $A x = b + \\delta b$ 的解。\n\n对于每个测试用例，您的程序必须计算放大因子 $r$ (一个浮点数)。测试用例集如下，每个用例由其用例编号标识，并按所列顺序执行：\n- 用例 1：$A$ 是 Hilbert 矩阵 $H \\in \\mathbb{R}^{5 \\times 5}$，其元素为 $H_{ij} = \\frac{1}{i + j - 1}$ (其中 $i, j \\in \\{1,\\dots,5\\}$)，且 $\\epsilon = 10^{-8}$。\n- 用例 2：$A$ 是 Hilbert 矩阵 $H \\in \\mathbb{R}^{10 \\times 10}$，其元素为 $H_{ij} = \\frac{1}{i + j - 1}$ (其中 $i, j \\in \\{1,\\dots,10\\}$)，且 $\\epsilon = 10^{-8}$。\n- 用例 3：$A$ 是单位矩阵 $I \\in \\mathbb{R}^{8 \\times 8}$，且 $\\epsilon = 10^{-8}$。\n- 用例 4：$A \\in \\mathbb{R}^{2 \\times 2}$ 由下式给出\n$$\nA = \\begin{bmatrix}\n1 & 1 \\\\\n1 & 1 + 10^{-10}\n\\end{bmatrix},\n$$\n且 $\\epsilon = 10^{-12}$。\n\n所有范数必须是 $2$-范数。不涉及物理单位。不使用角度。不得使用百分比；所有比率和大小必须表示为十进制浮点数。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[r1,r2,r3,r4]”）。每个条目必须是对应案例的放大因子 $r$，四舍五入至 $6$ 位有效数字，并按用例 1 到 4 的顺序排列。", "solution": "该实验是根据线性代数和基于范数的误差分析的第一性原理设计的。我们考虑一个具有精确数据的线性系统 $A x = b$ 及其受扰动的对应系统 $A x = b + \\delta b$。对于给定的矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和精确解向量 $x^\\star \\in \\mathbb{R}^n$，我们定义 $b = A x^\\star$。然后我们按如下方式构造一个具有指定相对大小 $\\epsilon$ 的扰动 $\\delta b$。令 $v \\in \\mathbb{R}^n$ 的分量为 $v_i = \\frac{(-1)^{i-1}}{\\sqrt{n}}$ (对于 $i = 1, \\dots, n$）。通过构造，这个 $v$ 满足 $\\|v\\|_2 = 1$：\n$$\n\\|v\\|_2^2 = \\sum_{i=1}^n \\left(\\frac{1}{\\sqrt{n}}\\right)^2 = \\frac{n}{n} = 1.\n$$\n我们令 $\\delta b = \\epsilon \\, \\|b\\|_2 \\, v$。那么 $b$ 中的相对扰动恰好是 $\\frac{\\|\\delta b\\|_2}{\\|b\\|_2} = \\epsilon$，因为\n$$\n\\|\\delta b\\|_2 = \\epsilon \\, \\|b\\|_2 \\, \\|v\\|_2 = \\epsilon \\, \\|b\\|_2.\n$$\n令 $x_\\epsilon$ 表示受扰动系统 $A x = b + \\delta b$ 的解。解的误差等于\n$$\nx_\\epsilon - x^\\star = A^{-1}\\,(b+\\delta b) - A^{-1} b = A^{-1}\\,\\delta b.\n$$\n因此，$x$ 中的相对误差为\n$$\n\\frac{\\|x_\\epsilon - x^\\star\\|_2}{\\|x^\\star\\|_2} = \\frac{\\|A^{-1}\\,\\delta b\\|_2}{\\|x^\\star\\|_2}.\n$$\n程序为每个用例报告的放大因子 $r$ 是\n$$\nr = \\frac{\\|x_{\\epsilon} - x^\\star\\|_{2} / \\|x^\\star\\|_{2}}{\\|\\delta b\\|_{2} / \\|b\\|_{2}}.\n$$\n根据范数性质和矩阵 $2$-范数的定义，我们可以将此放大作用与矩阵 $2$-范数的条件数 $\\kappa_2(A) = \\|A\\|_2 \\, \\|A^{-1}\\|_2$ 联系起来。具体来说，利用 $\\|A^{-1} \\delta b\\|_2 \\le \\|A^{-1}\\|_2 \\, \\|\\delta b\\|_2$ 和 $\\|b\\|_2 = \\|A x^\\star\\|_2 \\le \\|A\\|_2 \\, \\|x^\\star\\|_2$，我们得到\n$$\n\\frac{\\|x_\\epsilon - x^\\star\\|_2}{\\|x^\\star\\|_2} \\le \\|A^{-1}\\|_2 \\, \\|\\delta b\\|_2 \\,\\frac{1}{\\|x^\\star\\|_2}\n\\le \\|A^{-1}\\|_2 \\, \\|A\\|_2 \\, \\frac{\\|\\delta b\\|_2}{\\|b\\|_2} = \\kappa_2(A) \\, \\frac{\\|\\delta b\\|_2}{\\|b\\|_2}.\n$$\n因此\n$$\nr \\le \\kappa_2(A).\n$$\n这个不等式表明，解的相对误差最大可被放大至约等于条件数的大小。对于良态矩阵（well-conditioned matrices），例如单位矩阵 $I$，我们有 $\\kappa_2(I) = 1$，因此 $r$ 应该接近 $1$。对于病态矩阵，例如 Hilbert 矩阵，$\\kappa_2(A)$ 非常大，即使一个非常小的 $\\epsilon$ 也可能导致 $x$ 出现巨大的相对误差，从而产生一个很大的 $r$。\n\n测试套件涵盖了几种情况：\n- 用例 1 使用一个尺寸为 5 的 Hilbert 矩阵，该矩阵是病态的，但规模适中。\n- 用例 2 使用一个尺寸为 10 的 Hilbert 矩阵，其病态程度更高，通常会产生大得多的放大因子 $r$。\n- 用例 3 使用一个尺寸为 8 的单位矩阵，该矩阵是完美条件的 (perfectly conditioned)，所以 $r$ 应该约等于 $1$。\n- 用例 4 使用一个近奇异的 $2 \\times 2$ 矩阵，其中一个元素与矩阵其他元素相差 $10^{-10}$，这会产生非常大的放大作用。\n\n对于每个用例，程序构造 $x^\\star$、$b$、单位范数扰动方向 $v$、具有指定 $\\epsilon$ 的扰动 $\\delta b$，求解 $x_\\epsilon$，计算相对误差，并报告四舍五入到 $6$ 位有效数字的 $r$。最终输出是包含列表 $[r_1, r_2, r_3, r_4]$ 的单行文本，按此顺序排列。这个过程直接且清晰地展示了 $A$ 中的病态条件如何将 $b$ 中的微小相对扰动放大为解 $x$ 中的巨大相对误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef hilbert(n: int) -> np.ndarray:\n    # H[i,j] = 1 / (i + j + 1) with zero-based i,j; but use one-based formula directly\n    i = np.arange(1, n + 1).reshape(-1, 1)\n    j = np.arange(1, n + 1).reshape(1, -1)\n    return 1.0 / (i + j - 1.0)\n\ndef alternating_unit_vector(n: int) -> np.ndarray:\n    # v_i = (-1)^(i-1) / sqrt(n), i = 1..n\n    signs = (-1.0) ** np.arange(n)\n    v = signs / np.sqrt(n)\n    # Ensure unit norm numerically\n    return v / np.linalg.norm(v, 2)\n\ndef amplification_factor(A: np.ndarray, eps: float) -> float:\n    n = A.shape[0]\n    x_star = np.ones(n, dtype=float)\n    b = A @ x_star\n    nb = np.linalg.norm(b, 2)\n    if nb == 0.0:\n        # Degenerate, but not expected with provided tests; return NaN-like large value\n        return float('nan')\n    v = alternating_unit_vector(n)\n    delta_b = eps * nb * v\n    b_tilde = b + delta_b\n    # Solve for perturbed solution\n    x_tilde = np.linalg.solve(A, b_tilde)\n    # Relative errors\n    rel_b = np.linalg.norm(delta_b, 2) / nb\n    rel_x = np.linalg.norm(x_tilde - x_star, 2) / np.linalg.norm(x_star, 2)\n    # Amplification factor\n    return rel_x / rel_b\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple: (A_matrix, epsilon)\n    A1 = hilbert(5)\n    eps1 = 1e-8\n\n    A2 = hilbert(10)\n    eps2 = 1e-8\n\n    A3 = np.eye(8, dtype=float)\n    eps3 = 1e-8\n\n    A4 = np.array([[1.0, 1.0],\n                   [1.0, 1.0 + 1e-10]], dtype=float)\n    eps4 = 1e-12\n\n    test_cases = [\n        (A1, eps1),\n        (A2, eps2),\n        (A3, eps3),\n        (A4, eps4),\n    ]\n\n    results = []\n    for A, eps in test_cases:\n        r = amplification_factor(A, eps)\n        # Round to 6 significant digits\n        if np.isnan(r) or np.isinf(r):\n            results.append(\"nan\")\n        else:\n            results.append(f\"{r:.6g}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"}]}