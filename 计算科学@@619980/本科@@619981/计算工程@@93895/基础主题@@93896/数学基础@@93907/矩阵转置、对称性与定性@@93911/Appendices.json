{"hands_on_practices": [{"introduction": "在计算工程中，尤其是在有限元分析等领域，我们经常需要处理大型稀疏对称矩阵。存储这类矩阵的每一个元素会极大地浪费内存资源。本练习旨在将对称性 $A=A^T$ 这一数学性质转化为一种实用的、节约内存的算法，你将只利用矩阵的上三角部分来实现完整的矩阵向量乘法。这项实践将理论与计算实践联系起来，是工程师必须掌握的一项关键技能 [@problem_id:2412069]。", "problem": "您有一项任务，即为一个实的、稀疏的、对称的矩阵设计一种内存高效的表示方法和矩阵向量乘法例程，该矩阵只存储其上三角部分的非零元素（包括对角线）。您必须实现一个完整、可运行的程序，为给定的测试套件构建此表示，仅使用存储的数据计算矩阵向量乘积，评估对称性和定性，并报告与朴素的非对称坐标存储方案的量化内存比较。\n\n定义和要求：\n\n- 令 $A \\in \\mathbb{R}^{n \\times n}$ 是对称矩阵，即 $A^\\top = A$。$A$ 的输入数据以三元组 $(i,j,v)$ 列表的形式给出，其中 $0 \\le i \\le j \\le n-1$，表示 $A_{ij} = v$，并且根据对称性，当 $i \\ne j$ 时，$A_{ji} = v$。\n- 给定一个向量 $x \\in \\mathbb{R}^n$，任务是仅使用上三角存储来计算 $y = A x$。所有算术运算必须遵循实数运算规则。\n- 判断 $A$ 是否为对称正定（SPD）矩阵，其定义为对于所有非零 $x \\in \\mathbb{R}^n$，都有 $x^\\top A x > 0$。报告一个布尔值，指明此属性是否成立。\n- 使用 $A$ 的稠密重构来验证两个正确性属性：\n  1. 从上三角存储计算出的 $y$ 与稠密乘积 $A x$ 在 $10^{-12}$ 的绝对容差内相等；将此报告为一个布尔值。\n  2. $y$ 与 $A^\\top x$ 在 $10^{-12}$ 的绝对容差内相等；将此报告为一个布尔值。请注意，对于对称矩阵 $A$，$A^\\top = A$。\n- 按如下方式量化内存使用。考虑一种朴素的非对称坐标存储（坐标列表），它存储完整对称矩阵中出现的每一个非零元素 $(i,j,v)$，即，对于每个严格非对角线的非零元素，它同时存储 $(i,j,v)$ 和 $(j,i,v)$，而对于对角线元素则只存储一个 $(i,i,v)$。假设索引使用 64 位整数，值使用 64 位浮点数，因此每个存储的三元组消耗 24 字节。您的上三角存储方案对每个提供的三元组只存储一次。对于每个测试用例，报告节省的字节数的整数值：\n  $$\\text{bytes\\_saved} = \\left(\\text{naive\\_entry\\_count} - \\text{upper\\_entry\\_count}\\right) \\times 24.$$\n- 最终输出格式：对于每个测试用例，生成一个列表\n  $$[\\;y\\_as\\_list\\_of\\_floats,\\; \\text{is\\_spd\\_boolean},\\; \\text{matches\\_dense\\_boolean},\\; \\text{transpose\\_consistency\\_boolean},\\; \\text{bytes\\_saved\\_integer}\\;].$$\n  您的程序应生成单行输出，其中包含所有测试用例的结果，结果为逗号分隔的列表，用方括号括起来，并与下面的测试套件顺序相同，例如：`[case1_result,case2_result,...]`。\n\n测试套件（索引是基于零的，即从 $0$ 开始；任何情况下都没有重复的三元组）：\n\n- 案例 1：\n  - $n = 5$\n  - 上三角三元组 $(i,j,v)$：\n    - $(0,0,4.0)$, $(1,1,5.0)$, $(2,2,6.0)$, $(3,3,5.0)$, $(4,4,4.0)$\n    - $(0,1,1.0)$, $(1,2,0.5)$, $(2,3,1.0)$, $(3,4,0.5)$, $(0,4,0.2)$\n  - $x = [1.0, 2.0, 3.0, 4.0, 5.0]$\n\n- 案例 2：\n  - $n = 4$\n  - 上三角三元组 $(i,j,v)$：\n    - $(0,0,2.0)$, $(1,1,3.0)$, $(2,2,4.0)$, $(3,3,5.0)$\n  - $x = [1.0, 0.0, -1.0, 2.0]$\n\n- 案例 3：\n  - $n = 3$\n  - 上三角三元组 $(i,j,v)$：\n    - $(0,0,2.0)$, $(1,1,-1.0)$, $(2,2,3.0)$\n    - $(0,2,0.5)$\n  - $x = [1.0, -2.0, 0.5]$\n\n- 案例 4：\n  - $n = 1$\n  - 上三角三元组 $(i,j,v)$：\n    - $(0,0,0.0)$\n  - $x = [3.0]$\n\n您的程序必须生成上述单行输出，其中每个案例的结果都是一个包含五个项目的列表，并按指定顺序排列。", "solution": "所提出的问题是有效的、适定的，并且基于计算线性代数的基本原理。它解决了为实数、稀疏、对称矩阵实现内存高效的矩阵向量乘法，并随后分析其属性的实际任务。我们将通过严谨的、分步的解决方案来处理。\n\n这个问题的核心是为对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 计算矩阵向量乘积 $y = Ax$，其中只存储了上三角（包括对角线）的非零元素。设存储的索引-值三元组集合为 $U = \\{(i, j, v) \\,|\\, A_{ij} = v, 0 \\le i \\le j < n\\}$。\n\n乘积向量 $y$ 的第 $k$ 个分量定义为 $y_k = \\sum_{l=0}^{n-1} A_{kl} x_l$。为了仅使用上三角元素来计算它，我们必须考虑每个存储的元素如何对乘积做出贡献。对于每个存储的三元组 $(i, j, v) \\in U$：\n\n1. 如果 $i = j$，则此元素在对角线上。这一项 $A_{ii} = v$ 只对乘积的分量 $y_i$ 有贡献。贡献值为 $v \\cdot x_i$。\n\n2. 如果 $i < j$，则此元素在严格上三角部分。这一项 $A_{ij} = v$ 对分量 $y_i$ 的贡献为 $v \\cdot x_j$。由于 $A$ 的对称性，我们有 $A_{ji} = A_{ij} = v$。这个对应的下三角元素对分量 $y_j$ 的贡献为 $A_{ji} \\cdot x_i = v \\cdot x_i$。\n\n因此，可以通过初始化一个零向量 $y \\in \\mathbb{R}^n$ 并遍历存储的三元组来制定一个正确且高效的算法：\n- 对于每个对角线三元组 $(i, i, v)$，更新 $y_i \\leftarrow y_i + v \\cdot x_i$。\n- 对于每个 $i < j$ 的非对角线三元组 $(i, j, v)$，执行两次更新：$y_i \\leftarrow y_i + v \\cdot x_j$ 和 $y_j \\leftarrow y_j + v \\cdot x_i$。\n此过程通过利用对称性正确地计算出完整的乘积 $Ax$。\n\n接下来，我们必须确定 $A$ 是否为对称正定（SPD）。根据定义，一个对称矩阵是正定的，当且仅当其所有特征值都严格为正。这为检查提供了最稳健的标准。步骤如下：\n1. 从给定的上三角三元组重构完整的稠密矩阵 $A$ 。对于每个三元组 $(i, j, v)$，我们设置 $A_{ij} = v$，如果 $i \\neq j$，则同时设置 $A_{ji} = v$。\n2. 计算得到的对称矩阵 $A$ 的特征值。此处适合使用专门用于对称矩阵的数值例程，例如计算实对称矩阵特征值的例程。\n3. 检查每个计算出的特征值 $\\lambda$ 是否满足条件 $\\lambda > 0$。如果所有特征值都满足此条件，则该矩阵是 SPD。\n\n正确性的验证是直接的。通过高效对称算法计算出的乘积向量 $y$ 与一个参考乘积 $y_{\\text{dense}} = A_{\\text{dense}} x$ 进行比较，其中 $A_{\\text{dense}}$ 是完全重构的矩阵。比较必须使用 $10^{-12}$ 的绝对容差进行。此外，由于 $A$ 是对称的（$A = A^\\top$），恒等式 $Ax = A^\\top x$ 必须成立。这提供了第二个相关的一致性检查。\n\n最后，我们量化内存节省。问题指明每个存储的三元组 $(i, j, v)$ 消耗 24 字节（2 个 8 字节的整数索引和 1 个 8 字节的双精度浮点值）。\n- 上三角存储需要 $\\text{upper\\_entry\\_count}$ 个三元组，即输入数据的数量。\n- 一个朴素的坐标存储方案会显式地存储所有非零元素。对于每个严格非对角线元素 $A_{ij} \\neq 0$（$i \\neq j$），它存储两个三元组，$(i, j, A_{ij})$ 和 $(j, i, A_{ji})$。对于每个对角线元素 $A_{ii} \\neq 0$，它存储一个三元组。\n输入中非对角线三元组的数量是 $\\text{num\\_off\\_diagonal}$。因此，朴素存储中的三元组总数为 $\\text{naive\\_entry\\_count} = (\\text{upper\\_entry\\_count} - \\text{num\\_off\\_diagonal}) + 2 \\cdot \\text{num\\_off\\_diagonal} = \\text{upper\\_entry\\_count} + \\text{num\\_off\\_diagonal}$。\n节省的字节数计算为 $(\\text{naive\\_entry\\_count} - \\text{upper\\_entry\\_count}) \\times 24$，可简化为 $\\text{num\\_off\\_diagonal} \\times 24$。这反映了我们的高效方案为每个非零的非对角线元素对节省了一个三元组的存储空间。\n\n实现将根据这些原则处理每个测试用例，为每个用例生成所需的五元素列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 5,\n            \"triplets\": [\n                (0, 0, 4.0), (1, 1, 5.0), (2, 2, 6.0), (3, 3, 5.0), (4, 4, 4.0),\n                (0, 1, 1.0), (1, 2, 0.5), (2, 3, 1.0), (3, 4, 0.5), (0, 4, 0.2)\n            ],\n            \"x\": [1.0, 2.0, 3.0, 4.0, 5.0]\n        },\n        {\n            \"n\": 4,\n            \"triplets\": [\n                (0, 0, 2.0), (1, 1, 3.0), (2, 2, 4.0), (3, 3, 5.0)\n            ],\n            \"x\": [1.0, 0.0, -1.0, 2.0]\n        },\n        {\n            \"n\": 3,\n            \"triplets\": [\n                (0, 0, 2.0), (1, 1, -1.0), (2, 2, 3.0),\n                (0, 2, 0.5)\n            ],\n            \"x\": [1.0, -2.0, 0.5]\n        },\n        {\n            \"n\": 1,\n            \"triplets\": [\n                (0, 0, 0.0)\n            ],\n            \"x\": [3.0]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case[\"n\"], case[\"triplets\"], case[\"x\"])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists.\n    print(str(results).replace(\" \", \"\"))\n\n\ndef process_case(n, triplets, x_vec):\n    \"\"\"\n    Processes a single test case according to the problem specification.\n\n    Args:\n        n (int): The dimension of the matrix.\n        triplets (list of tuple): The upper-triangular non-zero entries (i, j, v).\n        x_vec (list of float): The vector x.\n\n    Returns:\n        list: A list containing [y_as_list, is_spd, matches_dense, transpose_consistency, bytes_saved].\n    \"\"\"\n    x = np.array(x_vec, dtype=float)\n\n    # 1. Efficient matrix-vector multiplication y = Ax from upper-triangular storage\n    y = np.zeros(n, dtype=float)\n    for i, j, v in triplets:\n        if i == j:  # Diagonal element\n            y[i] += v * x[i]\n        else:  # Off-diagonal element, use symmetry\n            y[i] += v * x[j]\n            y[j] += v * x[i]\n\n    # 2. Reconstruct the full dense matrix for verification purposes\n    A_dense = np.zeros((n, n), dtype=float)\n    for i, j, v in triplets:\n        A_dense[i, j] = v\n        if i != j:\n            A_dense[j, i] = v\n\n    # 3. Determine if the matrix is Symmetric Positive Definite (SPD)\n    # A symmetric matrix is SPD iff all its eigenvalues are strictly positive.\n    is_spd = False\n    if n > 0:\n        try:\n            eigenvalues = np.linalg.eigvalsh(A_dense)\n            if np.all(eigenvalues > 0):\n                is_spd = True\n        except np.linalg.LinAlgError:\n            # This case shouldn't happen with the given data but is good practice.\n            is_spd = False\n\n    # 4. Perform correctness and consistency checks\n    tolerance = 1e-12\n    \n    # 4.1. Check against dense matrix-vector product\n    y_dense = A_dense @ x\n    matches_dense = np.allclose(y, y_dense, atol=tolerance, rtol=0)\n\n    # 4.2. Check consistency with A^T x (since A is symmetric, Ax = A^T x)\n    A_transpose = A_dense.T\n    y_transpose = A_transpose @ x\n    transpose_consistency = np.allclose(y, y_transpose, atol=tolerance, rtol=0)\n\n    # 5. Quantify memory savings\n    bytes_per_triplet = 24\n    num_off_diagonal = sum(1 for i, j, v in triplets if i != j)\n    # Savings come from storing each off-diagonal element once instead of twice\n    bytes_saved = num_off_diagonal * bytes_per_triplet\n    \n    # Format the results for the final output\n    return [y.tolist(), is_spd, matches_dense, transpose_consistency, int(bytes_saved)]\n\nsolve()\n```", "id": "2412069"}, {"introduction": "我们知道，对于对称矩阵而言，二次型 $x^T A x$ 是定义正定性的核心。但如果矩阵 $A$ 本身不是对称的，情况会怎样呢？本练习将引导你探索一个普通方阵及与之相关的二次型之间的基本关系。通过推导，你将发现只有矩阵的对称部分对 $x^T A x$ 的值有贡献，从而得出一个关于反对称矩阵的深刻结论 [@problem_id:2412126]。", "problem": "在计算工程中，特别是在有限元法（FEM）中，与类刚度算子相关的能量由二次型 $x^{\\mathsf{T}} A x$ 表示。考虑实矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 以及对所有 $x \\in \\mathbb{R}^{n}$ 都成立的恒等式 $x^{\\mathsf{T}} A x = 0$。\n\n1. 仅使用转置、对称性的定义以及标量 $x^{\\mathsf{T}} A x$ 的性质，从第一性原理出发，推导由恒等式 $x^{\\mathsf{T}} A x = 0$（对所有 $x \\in \\mathbb{R}^{n}$ 成立）所蕴含的对 $A$ 的结构性约束。\n\n2. 现在，将问题特化到 $\\mathbb{R}^{3 \\times 3}$ 并考虑以下设计问题：在所有满足 $x^{\\mathsf{T}} A x = 0$（对所有 $x \\in \\mathbb{R}^{3}$）并且还满足元素约束 $a_{12} = 2$ 的实矩阵 $A \\in \\mathbb{R}^{3 \\times 3}$ 中，确定可能的最小弗罗贝尼乌斯范数 $\\|A\\|_{F}$，其中 $\\|A\\|_{F} = \\sqrt{\\sum_{i=1}^{3} \\sum_{j=1}^{3} a_{ij}^{2}}$。将最小范数报告为精确值。\n\n你的最终答案必须是最小弗罗贝尼乌斯范数，表示为一个实数。无需四舍五入。", "solution": "我们从第一性原理出发进行推导。\n\n第一部分。设 $A \\in \\mathbb{R}^{n \\times n}$ 并假设对所有 $x \\in \\mathbb{R}^{n}$ 都有 $x^{\\mathsf{T}} A x = 0$。对任意的 $u, v \\in \\mathbb{R}^{n}$，展开下式：\n\n$$\n(u+v)^{\\mathsf{T}} A (u+v) = u^{\\mathsf{T}} A u + u^{\\mathsf{T}} A v + v^{\\mathsf{T}} A u + v^{\\mathsf{T}} A v.\n$$\n\n根据假设，对所有 $u, v$，有 $u^{\\mathsf{T}} A u = 0$ 和 $v^{\\mathsf{T}} A v = 0$，所以展开式给出：\n\n$$\n0 = (u+v)^{\\mathsf{T}} A (u+v) = u^{\\mathsf{T}} A v + v^{\\mathsf{T}} A u.\n$$\n\n注意到 $v^{\\mathsf{T}} A u = (u^{\\mathsf{T}} A^{\\mathsf{T}} v)$。因此：\n\n$$\n0 = u^{\\mathsf{T}} A v + u^{\\mathsf{T}} A^{\\mathsf{T}} v = u^{\\mathsf{T}} (A + A^{\\mathsf{T}}) v\n$$\n\n对所有的 $u, v \\in \\mathbb{R}^{n}$ 都成立。定义对称部分 $S = \\tfrac{1}{2}(A + A^{\\mathsf{T}})$。那么上式意味着对所有的 $u, v$ 都有 $u^{\\mathsf{T}} S v = 0$。选择标准基向量 $u = e_{i}$ 和 $v = e_{j}$，可得对所有下标都有 $e_{i}^{\\mathsf{T}} S e_{j} = s_{ij} = 0$，因此 $S = 0$。所以 $A + A^{\\mathsf{T}} = 0$，即 $A$ 是反对称矩阵。因此，对所有 $x$ 成立的恒等式 $x^{\\mathsf{T}} A x = 0$ 迫使 $A$ 是反对称的。\n\n第二部分。我们现在在所有满足 $a_{12} = 2$ 的反对称矩阵 $A \\in \\mathbb{R}^{3 \\times 3}$ 中最小化弗罗贝尼乌斯范数。一个实的 $3 \\times 3$ 反对称矩阵具有如下形式：\n\n$$\nA = \\begin{pmatrix}\n0 & a_{12} & a_{13} \\\\\n-a_{12} & 0 & a_{23} \\\\\n-a_{13} & -a_{23} & 0\n\\end{pmatrix}.\n$$\n\n施加约束 $a_{12} = 2$ 可得：\n\n$$\nA = \\begin{pmatrix}\n0 & 2 & a_{13} \\\\\n-2 & 0 & a_{23} \\\\\n-a_{13} & -a_{23} & 0\n\\end{pmatrix},\n$$\n\n其中 $a_{13}, a_{23} \\in \\mathbb{R}$ 是自由参数。弗罗贝尼乌斯范数的平方为：\n\n$$\n\\|A\\|_{F}^{2} = \\sum_{i=1}^{3} \\sum_{j=1}^{3} a_{ij}^{2} = 0^{2} + 2^{2} + a_{13}^{2} + (-2)^{2} + 0^{2} + a_{23}^{2} + (-a_{13})^{2} + (-a_{23})^{2} + 0^{2}.\n$$\n\n化简后得到：\n\n$$\n\\|A\\|_{F}^{2} = 4 + 4 + 2 a_{13}^{2} + 2 a_{23}^{2} = 8 + 2\\left(a_{13}^{2} + a_{23}^{2}\\right).\n$$\n\n通过选择 $a_{13} = 0$ 和 $a_{23} = 0$，该表达式被最小化，得到最小值为：\n\n$$\n\\|A\\|_{F,\\min} = \\sqrt{8} = 2 \\sqrt{2}.\n$$\n\n对应的最小化矩阵\n\n$$\nA_{\\min} = \\begin{pmatrix}\n0 & 2 & 0 \\\\\n-2 & 0 & 0 \\\\\n0 & 0 & 0\n\\end{pmatrix}\n$$\n\n是实的、非零的、非对称的（实际上是反对称的），并且按要求对所有 $x \\in \\mathbb{R}^{3}$ 满足 $x^{\\mathsf{T}} A x = 0$。因此，最小弗罗贝尼乌斯范数是 $2 \\sqrt{2}$。", "answer": "$$\\boxed{2\\sqrt{2}}$$", "id": "2412126"}, {"introduction": "单个对称正定（SPD）矩阵的性质是众所周知的，但一个自然的问题是：两个SPD矩阵的乘积具有什么性质？本练习将探讨两个SPD矩阵的乘积 $AB$（通常不再是对称矩阵）是否保留了诸如拥有正实数特征值之类的良好特性。你将运用线性代数中的一个关键技巧——相似变换——来证明一个普适而有力的结论，这对于分析许多计算算法的收敛性至关重要 [@problem_id:2412073]。", "problem": "设 $A \\in \\mathbb{R}^{n \\times n}$ 和 $B \\in \\mathbb{R}^{n \\times n}$ 为实对称正定 (SPD) 矩阵，即 $A = A^{\\mathsf{T}}$，$B = B^{\\mathsf{T}}$，且对于所有非零 $x \\in \\mathbb{R}^{n}$，都有 $x^{\\mathsf{T}} A x > 0$ 和 $x^{\\mathsf{T}} B x > 0$。考虑矩阵乘积 $AB$，它不一定是对称的。\n\n任务 1：判断对于任意 SPD 矩阵 $A$ 和 $B$，$AB$ 的所有特征值是否保证为正实数。您的论证必须从对称性、正定性和矩阵相似性的定义出发。\n\n任务 2：设\n$$\nA = \\begin{pmatrix}\n2 & 1 \\\\\n1 & 2\n\\end{pmatrix}, \n\\qquad\nB = \\begin{pmatrix}\n3 & -1 \\\\\n-1 & \\tfrac{3}{2}\n\\end{pmatrix}.\n$$\n$A$ 和 $B$ 都是 SPD 矩阵。计算它们的乘积 $AB$ 的谱半径 $\\rho(AB)$，并以精确的闭式表达式给出最终答案。请勿四舍五入。最终答案只报告 $\\rho(AB)$ 的值，不带单位。", "solution": "问题陈述已根据指定标准进行解析和验证。\n\n**问题验证**\n\n**步骤 1：提取已知条件**\n- $A \\in \\mathbb{R}^{n \\times n}$ 和 $B \\in \\mathbb{R}^{n \\times n}$ 是实矩阵。\n- $A$ 是对称正定（SPD）矩阵，即 $A = A^{\\mathsf{T}}$ 且对于所有非零 $x \\in \\mathbb{R}^{n}$，有 $x^{\\mathsf{T}} A x > 0$。\n- $B$ 是对称正定（SPD）矩阵，即 $B = B^{\\mathsf{T}}$ 且对于所有非零 $x \\in \\mathbb{R}^{n}$，有 $x^{\\mathsf{T}} B x > 0$。\n- 任务 1：判断乘积 $AB$ 的所有特征值是否保证为正实数。\n- 任务 2：对于特定矩阵 $A = \\begin{pmatrix} 2 & 1 \\\\ 1 & 2 \\end{pmatrix}$ 和 $B = \\begin{pmatrix} 3 & -1 \\\\ -1 & \\tfrac{3}{2} \\end{pmatrix}$，计算谱半径 $\\rho(AB)$。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学或事实层面不健全**：该问题基于线性代数的既定原理，特别是关于对称正定矩阵、特征值和相似变换的矩阵理论。没有事实错误或违反数学逻辑之处。\n- **无法形式化或不相关**：该问题是一个形式化的数学问题，与计算工程中的矩阵性质主题直接相关。\n- **不完整或矛盾的设定**：该问题已完全指定。定义已给出，用于计算任务的矩阵也已明确给出。设定是自洽且一致的。\n- **不切实际或不可行**：该问题是线性代数中的一个标准练习，在数学上是健全和可行的。\n- **不适定或结构不良**：该问题是适定的。任务1是一个可证明的命题，任务2是一个可得出唯一答案的直接计算。\n- **超出科学可验证性**：该问题的主张和解法可通过数学证明和直接计算来验证。\n\n**步骤 3：结论与行动**\n此问题有效。将提供严谨的解答。\n\n**解答**\n\n**任务 1：两个 SPD 矩阵乘积的特征值**\n\n设 $A$ 和 $B$ 是大小为 $n \\times n$ 的对称正定 (SPD) 矩阵。我们需要确定乘积矩阵 $AB$ 的特征值是否保证为正实数。\n\n矩阵 $AB$ 的一个特征值 $\\lambda$ 及其对应的特征向量 $v \\neq 0$ 满足方程：\n$$\nABv = \\lambda v\n$$\n乘积 $AB$ 通常不是对称的，因此我们不能立即断定其特征值为实数。但是，我们可以通过相似变换将 $AB$ 与一个对称矩阵联系起来。\n\n由于 $B$ 是一个 SPD 矩阵，它是可逆的，并且其逆矩阵 $B^{-1}$ 也是 SPD 的。此外，一个 SPD 矩阵 $B$ 有一个唯一的 SPD 平方根，记作 $B^{1/2}$，使得 $B = B^{1/2}B^{1/2}$。这个平方根的逆 $(B^{1/2})^{-1} = B^{-1/2}$ 也存在且是 SPD 的。\n\n考虑使用矩阵 $B^{1/2}$ 对 $AB$ 进行相似变换：\n$$\n(B^{1/2}) (AB) (B^{1/2})^{-1} = B^{1/2} A B B^{-1/2} = B^{1/2} A B^{1/2}\n$$\n我们定义一个新矩阵 $C = B^{1/2} A B^{1/2}$。由于 $AB$ 与 $C$ 相似，它们具有相同的特征值集合。我们现在分析 $C$ 的性质。\n\n首先，我们检查 $C$ 是否对称。\n$$\nC^{\\mathsf{T}} = (B^{1/2} A B^{1/2})^{\\mathsf{T}} = (B^{1/2})^{\\mathsf{T}} A^{\\mathsf{T}} (B^{1/2})^{\\mathsf{T}}\n$$\n由于 $A$ 是对称的 ($A=A^{\\mathsf{T}}$)，并且 SPD 平方根 $B^{1/2}$ 也是对称的 ($(B^{1/2})^{\\mathsf{T}} = B^{1/2}$)，我们有：\n$$\nC^{\\mathsf{T}} = B^{1/2} A B^{1/2} = C\n$$\n因此，$C$ 是一个对称矩阵。因此，$C$ 的所有特征值都是实数。\n\n接下来，我们检查 $C$ 是否为正定。对于任意非零向量 $y \\in \\mathbb{R}^{n}$，考虑二次型 $y^{\\mathsf{T}} C y$：\n$$\ny^{\\mathsf{T}} C y = y^{\\mathsf{T}} (B^{1/2} A B^{1/2}) y = (B^{1/2} y)^{\\mathsf{T}} A (B^{1/2} y)\n$$\n令 $x = B^{1/2} y$。由于 $B^{1/2}$ 是可逆的（因为 $B$ 是正定的），一个非零向量 $y$ 映射到一个非零向量 $x$。又因为 $A$ 是正定的，对于所有 $x \\neq 0$，我们有 $x^{\\mathsf{T}} A x > 0$。因此：\n$$\ny^{\\mathsf{T}} C y = x^{\\mathsf{T}} A x > 0\n$$\n这表明 $C$ 是一个正定矩阵。\n\n对称正定矩阵的一个基本性质是其所有特征值都是严格的正实数。设 $\\lambda_C$ 是 $C$ 的一个特征值，其特征向量为 $y \\neq 0$。则有 $Cy=\\lambda_C y$。二次型给出 $y^{\\mathsf{T}} C y = y^{\\mathsf{T}}(\\lambda_C y) = \\lambda_C y^{\\mathsf{T}}y = \\lambda_C ||y||^2$。由于 $C$ 是正定的，所以 $y^{\\mathsf{T}} C y > 0$，又因为 $y \\neq 0$，所以 $||y||^2 > 0$。因此可得 $\\lambda_C = \\frac{y^{\\mathsf{T}} C y}{||y||^2} > 0$。\n\n由于 $AB$ 与 SPD 矩阵 $C$ 相似，所以 $AB$ 与 $C$ 具有相同的特征值。因此，$AB$ 的所有特征值都保证是正实数。\n\n**任务 2：谱半径的计算**\n\n我们给出的矩阵是：\n$$\nA = \\begin{pmatrix}\n2 & 1 \\\\\n1 & 2\n\\end{pmatrix}, \n\\qquad\nB = \\begin{pmatrix}\n3 & -1 \\\\\n-1 & \\tfrac{3}{2}\n\\end{pmatrix}\n$$\n首先，验证 $A$ 和 $B$ 是 SPD 矩阵的说法。\n对于 $A$：它是对称的。其主子式为 $\\det(A_1) = 2 > 0$ 和 $\\det(A_2) = (2)(2) - (1)(1) = 3 > 0$。根据 Sylvester 判据，$A$ 是 SPD 矩阵。\n对于 $B$：它是对称的。其主子式为 $\\det(B_1) = 3 > 0$ 和 $\\det(B_2) = (3)(\\tfrac{3}{2}) - (-1)(-1) = \\tfrac{9}{2} - 1 = \\tfrac{7}{2} > 0$。根据 Sylvester 判据，$B$ 是 SPD 矩阵。\n\n现在我们计算乘积 $AB$：\n$$\nAB = \\begin{pmatrix}\n2 & 1 \\\\\n1 & 2\n\\end{pmatrix}\n\\begin{pmatrix}\n3 & -1 \\\\\n-1 & \\tfrac{3}{2}\n\\end{pmatrix}\n= \\begin{pmatrix}\n(2)(3) + (1)(-1) & (2)(-1) + (1)(\\tfrac{3}{2}) \\\\\n(1)(3) + (2)(-1) & (1)(-1) + (2)(\\tfrac{3}{2})\n\\end{pmatrix}\n$$\n$$\nAB = \\begin{pmatrix}\n6 - 1 & -2 + \\tfrac{3}{2} \\\\\n3 - 2 & -1 + 3\n\\end{pmatrix}\n= \\begin{pmatrix}\n5 & -\\tfrac{1}{2} \\\\\n1 & 2\n\\end{pmatrix}\n$$\n为了求出 $AB$ 的特征值，我们求解特征方程 $\\det(AB - \\lambda I) = 0$：\n$$\n\\det\\begin{pmatrix}\n5 - \\lambda & -\\tfrac{1}{2} \\\\\n1 & 2 - \\lambda\n\\end{pmatrix} = 0\n$$\n$$\n(5 - \\lambda)(2 - \\lambda) - (-\\tfrac{1}{2})(1) = 0\n$$\n$$\n10 - 7\\lambda + \\lambda^2 + \\tfrac{1}{2} = 0\n$$\n$$\n\\lambda^2 - 7\\lambda + \\tfrac{21}{2} = 0\n$$\n我们使用二次方程求根公式来解这个关于 $\\lambda$ 的二次方程：\n$$\n\\lambda = \\frac{-(-7) \\pm \\sqrt{(-7)^2 - 4(1)(\\tfrac{21}{2})}}{2(1)}\n= \\frac{7 \\pm \\sqrt{49 - 42}}{2}\n= \\frac{7 \\pm \\sqrt{7}}{2}\n$$\n特征值为 $\\lambda_1 = \\frac{7 + \\sqrt{7}}{2}$ 和 $\\lambda_2 = \\frac{7 - \\sqrt{7}}{2}$。正如任务 1 中所证明的，这两个都是正实数，因为 $\\sqrt{7} \\approx 2.646 < 7$。\n\n谱半径 $\\rho(AB)$ 定义为特征值绝对值的最大值：\n$$\n\\rho(AB) = \\max \\left\\{ \\left| \\frac{7 + \\sqrt{7}}{2} \\right|, \\left| \\frac{7 - \\sqrt{7}}{2} \\right| \\right\\}\n$$\n由于两个特征值都是正数，谱半径就是较大的那个特征值。\n$$\n\\rho(AB) = \\frac{7 + \\sqrt{7}}{2}\n$$", "answer": "$$\\boxed{\\frac{7 + \\sqrt{7}}{2}}$$", "id": "2412073"}]}