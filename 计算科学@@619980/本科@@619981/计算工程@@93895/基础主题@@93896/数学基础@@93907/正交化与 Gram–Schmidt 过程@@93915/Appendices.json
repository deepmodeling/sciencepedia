{"hands_on_practices": [{"introduction": "格拉姆-施密特正交化过程的威力远不止于处理 $\\mathbb{R}^n$ 空间中的几何向量。这个练习将带你进入函数空间——一个在计算工程中至关重要的抽象领域。你将通过对一个单项式基底应用格拉姆-施密特过程，并使用一个基于积分的内积，来亲手构建出大名鼎鼎的勒让德多项式 (Legendre polynomials)，它们是数值分析的基石，在解决微分方程和高斯求积等高级数值方法中扮演着核心角色 [@problem_id:2422241]。", "problem": "在计算工程中，区间 $[-1,1]$ 上的正交多项式基是构建稳定数值近似的基础。考虑次数至多为 $4$ 的实多项式向量空间，其上定义了内积\n$$\\langle f, g \\rangle = \\int_{-1}^{1} f(x)\\,g(x)\\,\\mathrm{d}x.$$\n存在一个唯一的多项式序列 $\\{P_{n}(x)\\}_{n=0}^{4}$，其中 $\\deg P_{n}=n$。该多项式集合关于内积 $\\langle \\cdot,\\cdot \\rangle$ 相互正交，并且对于 $\\{0,1,2,3,4\\}$ 中的每个 $n$ 都满足归一化条件 $P_{n}(1)=1$。\n\n请确定截至 $4$ 次的这些多项式，并仅提供 $P_{4}(x)$ 的显式封闭形式表达式。请将最终答案表示为含精确有理系数的关于 $x$ 的多项式。无需四舍五入。", "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- **向量空间**：次数至多为 $4$ 的实多项式向量空间，记为 $\\mathcal{P}_4([-1, 1])$。\n- **内积**：对于空间中的任意两个多项式 $f(x)$ 和 $g(x)$，其内积定义为 $\\langle f, g \\rangle = \\int_{-1}^{1} f(x)g(x)\\,\\mathrm{d}x$。\n- **正交序列**：一个多项式序列 $\\{P_{n}(x)\\}_{n=0}^{4}$。\n- **次数条件**：每个多项式 $P_n(x)$ 的次数为 $n$。\n- **正交性条件**：集合 $\\{P_{0}(x), P_{1}(x), P_{2}(x), P_{3}(x), P_{4}(x)\\}$ 是相互正交的，即对于 $n \\neq m$ 有 $\\langle P_n, P_m \\rangle = 0$。\n- **归一化条件**：每个多项式均满足 $P_n(1) = 1$，其中 $n \\in \\{0, 1, 2, 3, 4\\}$。\n- **目标**：确定多项式 $P_4(x)$ 的显式表达式。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，是正交多项式理论中的一个标准练习，而正交多项式在计算工程和应用数学中是基础性的。所指定的多项式是著名的勒让德多项式的一种特定缩放形式。该问题是适定的；将 Gram-Schmidt 正交化过程应用于单项式基 $\\{1, x, x^2, x^3, x^4\\}$，并结合给定的归一化条件，保证了这样一列多项式的存在性和唯一性。问题陈述是客观、完整的，不包含任何矛盾或歧义。\n\n**步骤3：结论与行动**\n该问题是**有效的**。将构建一个解。\n\n正交多项式序列 $\\{P_n(x)\\}$ 可以通过对标准单项式基 $\\{v_n(x) = x^n\\}_{n=0}^{4}$ 使用 Gram-Schmidt 正交化过程来构建。我们首先生成一个未归一化的正交基 $\\{q_n(x)\\}_{n=0}^{4}$，然后对每个多项式进行缩放以满足归一化条件 $P_n(1)=1$。\n\n令 $q_n(x)$ 为未归一化的正交多项式。Gram-Schmidt 过程定义如下：\n$$q_n(x) = v_n(x) - \\sum_{k=0}^{n-1} \\frac{\\langle v_n, q_k \\rangle}{\\langle q_k, q_k \\rangle} q_k(x)$$\n归一化后的多项式为 $P_n(x) = c_n q_n(x)$，其中常数 $c_n$ 由条件 $P_n(1)=1$ 确定。一个有用的内积恒等式是：对于偶数 $k$，有 $\\int_{-1}^{1} x^k \\, \\mathrm{d}x = \\frac{2}{k+1}$；对于奇数 $k$，有 $0$。\n\n对于 $n=0$：\n$v_0(x) = 1$。\n$q_0(x) = v_0(x) = 1$。\n归一化要求 $P_0(1)=1$。令 $P_0(x) = c_0 q_0(x) = c_0$。则 $P_0(1) = c_0 = 1$。\n因此，$P_0(x) = 1$。\n\n对于 $n=1$：\n$v_1(x) = x$。\n$q_1(x) = v_1(x) - \\frac{\\langle v_1, q_0 \\rangle}{\\langle q_0, q_0 \\rangle} q_0(x)$。\n$\\langle v_1, q_0 \\rangle = \\int_{-1}^{1} x \\cdot 1 \\, \\mathrm{d}x = 0$。\n所以，$q_1(x) = x$。\n归一化：$P_1(x) = c_1 x$。$P_1(1) = c_1 \\cdot 1 = 1 \\implies c_1=1$。\n因此，$P_1(x) = x$。\n\n对于 $n=2$：\n$v_2(x) = x^2$。\n$q_2(x) = v_2(x) - \\frac{\\langle v_2, q_0 \\rangle}{\\langle q_0, q_0 \\rangle} q_0(x) - \\frac{\\langle v_2, q_1 \\rangle}{\\langle q_1, q_1 \\rangle} q_1(x)$。\n$\\langle v_2, q_1 \\rangle = \\int_{-1}^{1} x^2 \\cdot x \\, \\mathrm{d}x = \\int_{-1}^{1} x^3 \\, \\mathrm{d}x = 0$。\n$\\langle v_2, q_0 \\rangle = \\int_{-1}^{1} x^2 \\cdot 1 \\, \\mathrm{d}x = \\frac{2}{3}$。\n$\\langle q_0, q_0 \\rangle = \\int_{-1}^{1} 1^2 \\, \\mathrm{d}x = 2$。\n$q_2(x) = x^2 - \\frac{2/3}{2} \\cdot 1 = x^2 - \\frac{1}{3}$。\n归一化：$P_2(x) = c_2 (x^2 - \\frac{1}{3})$。$P_2(1) = c_2(1 - \\frac{1}{3}) = c_2(\\frac{2}{3}) = 1 \\implies c_2 = \\frac{3}{2}$。\n因此，$P_2(x) = \\frac{3}{2}(x^2 - \\frac{1}{3}) = \\frac{3}{2}x^2 - \\frac{1}{2}$。\n\n对于 $n=3$：\n$v_3(x) = x^3$。\n$q_3(x) = v_3(x) - \\frac{\\langle v_3, q_0 \\rangle}{\\langle q_0, q_0 \\rangle} q_0(x) - \\frac{\\langle v_3, q_1 \\rangle}{\\langle q_1, q_1 \\rangle} q_1(x) - \\frac{\\langle v_3, q_2 \\rangle}{\\langle q_2, q_2 \\rangle} q_2(x)$。\n根据奇偶性，$\\langle v_3, q_0 \\rangle = 0$ 且 $\\langle v_3, q_2 \\rangle = 0$。\n$\\langle v_3, q_1 \\rangle = \\int_{-1}^{1} x^3 \\cdot x \\, \\mathrm{d}x = \\int_{-1}^{1} x^4 \\, \\mathrm{d}x = \\frac{2}{5}$。\n$\\langle q_1, q_1 \\rangle = \\int_{-1}^{1} x^2 \\, \\mathrm{d}x = \\frac{2}{3}$。\n$q_3(x) = x^3 - \\frac{2/5}{2/3} x = x^3 - \\frac{3}{5}x$。\n归一化：$P_3(x) = c_3 (x^3 - \\frac{3}{5}x)$。$P_3(1) = c_3(1 - \\frac{3}{5}) = c_3(\\frac{2}{5}) = 1 \\implies c_3 = \\frac{5}{2}$。\n因此，$P_3(x) = \\frac{5}{2}(x^3 - \\frac{3}{5}x) = \\frac{5}{2}x^3 - \\frac{3}{2}x$。\n\n对于 $n=4$：\n$v_4(x) = x^4$。\n$q_4(x) = v_4(x) - \\sum_{k=0}^{3} \\frac{\\langle v_4, q_k \\rangle}{\\langle q_k, q_k \\rangle} q_k(x)$。\n根据奇偶性，$\\langle v_4, q_1 \\rangle = 0$ 且 $\\langle v_4, q_3 \\rangle = 0$。\n$q_4(x) = x^4 - \\frac{\\langle v_4, q_0 \\rangle}{\\langle q_0, q_0 \\rangle} q_0(x) - \\frac{\\langle v_4, q_2 \\rangle}{\\langle q_2, q_2 \\rangle} q_2(x)$。\n$q_0(x) = 1$ 且 $q_2(x) = x^2 - \\frac{1}{3}$。\n第1项：\n$\\langle v_4, q_0 \\rangle = \\int_{-1}^{1} x^4 \\cdot 1 \\, \\mathrm{d}x = \\frac{2}{5}$。\n$\\langle q_0, q_0 \\rangle = 2$。\n在 $q_0$ 上的投影为 $\\frac{2/5}{2} q_0(x) = \\frac{1}{5}$。\n第2项：\n$\\langle v_4, q_2 \\rangle = \\int_{-1}^{1} x^4(x^2 - \\frac{1}{3}) \\, \\mathrm{d}x = \\int_{-1}^{1} (x^6 - \\frac{1}{3}x^4) \\, \\mathrm{d}x = \\frac{2}{7} - \\frac{1}{3}\\frac{2}{5} = \\frac{30-14}{105} = \\frac{16}{105}$。\n$\\langle q_2, q_2 \\rangle = \\int_{-1}^{1} (x^2 - \\frac{1}{3})^2 \\, \\mathrm{d}x = \\int_{-1}^{1} (x^4 - \\frac{2}{3}x^2 + \\frac{1}{9}) \\, \\mathrm{d}x = \\frac{2}{5} - \\frac{2}{3}\\frac{2}{3} + \\frac{1}{9}(2) = \\frac{2}{5} - \\frac{4}{9} + \\frac{2}{9} = \\frac{2}{5} - \\frac{2}{9} = \\frac{18-10}{45} = \\frac{8}{45}$。\n在 $q_2$ 上的投影为 $\\frac{16/105}{8/45} q_2(x) = (\\frac{16}{105} \\cdot \\frac{45}{8}) (x^2 - \\frac{1}{3}) = (\\frac{2 \\cdot 45}{105})(x^2 - \\frac{1}{3}) = \\frac{90}{105}(x^2 - \\frac{1}{3}) = \\frac{6}{7}(x^2 - \\frac{1}{3})$。\n\n组合得到 $q_4(x)$：\n$q_4(x) = x^4 - \\frac{1}{5} - \\frac{6}{7}(x^2 - \\frac{1}{3}) = x^4 - \\frac{6}{7}x^2 - \\frac{1}{5} + \\frac{2}{7} = x^4 - \\frac{6}{7}x^2 + \\frac{-7+10}{35} = x^4 - \\frac{6}{7}x^2 + \\frac{3}{35}$。\n\n归一化：\n$P_4(x) = c_4 q_4(x)$。条件为 $P_4(1) = 1$。\n$q_4(1) = 1^4 - \\frac{6}{7}(1^2) + \\frac{3}{35} = 1 - \\frac{6}{7} + \\frac{3}{35} = \\frac{35-30+3}{35} = \\frac{8}{35}$。\n$P_4(1) = c_4 \\cdot q_4(1) = c_4 \\cdot \\frac{8}{35} = 1 \\implies c_4 = \\frac{35}{8}$。\n\n最终，多项式 $P_4(x)$ 为：\n$P_4(x) = \\frac{35}{8} \\left( x^4 - \\frac{6}{7}x^2 + \\frac{3}{35} \\right) = \\frac{35}{8}x^4 - \\frac{35}{8}\\frac{6}{7}x^2 + \\frac{35}{8}\\frac{3}{35}$。\n$P_4(x) = \\frac{35}{8}x^4 - \\frac{5 \\cdot 6}{8}x^2 + \\frac{3}{8} = \\frac{35}{8}x^4 - \\frac{30}{8}x^2 + \\frac{3}{8}$。\n简化 $x^2$ 的系数：\n$P_4(x) = \\frac{35}{8}x^4 - \\frac{15}{4}x^2 + \\frac{3}{8}$。\n这就是 $P_4(x)$ 的显式封闭形式表达式。\n这些多项式就是标准的勒让德多项式。", "answer": "$$\n\\boxed{\\frac{35}{8}x^4 - \\frac{15}{4}x^2 + \\frac{3}{8}}\n$$", "id": "2422241"}, {"introduction": "在理解了格拉姆-施密特过程可以应用于不同类型的向量空间和内积之后，下一步是将其转化为一个通用且可复用的计算工具。这个编程练习要求你设计一个能够接受自定义内积作为函数参数的算法，这使得核心代码能灵活适应各种数学情境。这种抽象能力是现代计算软件的标志，例如，它让同一个算法可以无缝处理在统计学和优化问题中常见的加权内积 $\\langle x, y \\rangle_W = x^T W y$ [@problem_id:2422280]。", "problem": "给定实向量空间 $\\mathbb{R}^n$ 中的一个有限向量集合，以及 $\\mathbb{R}^n$ 上的一个内积 $\\langle \\cdot,\\cdot \\rangle$。$\\mathbb{R}^n$ 上的内积是一个函数 $\\langle \\cdot,\\cdot \\rangle : \\mathbb{R}^n \\times \\mathbb{R}^n \\to \\mathbb{R}$，它对每个参数都是线性的、对称的且正定的。对于一个对称正定（SPD）矩阵 $W \\in \\mathbb{R}^{n \\times n}$，一类重要的内积由 $\\langle x, y \\rangle_W = x^\\top W y$ 给出。其关联范数为 $\\|x\\|_W = \\sqrt{\\langle x, x \\rangle_W}$。对于一个有限输入向量序列 $\\{v_1, v_2, \\dots, v_m\\} \\subset \\mathbb{R}^n$，任务是关于给定内积，为 $\\operatorname{span}\\{v_1,\\dots,v_m\\}$ 构造一个标准正交基 $\\{q_1, \\dots, q_r\\}$，其中 $r \\le \\min\\{n,m\\}$ 是该生成子空间的维度。在给定内积下，若一个向量的范数小于或等于阈值 $\\tau > 0$，则必须将其视为零向量，并从基的构造中排除。\n\n您的程序必须为下面指定的每个测试用例，从基本原理出发执行以下操作：\n- 将提供的内积视为一个黑盒函数 $\\mathrm{ip}(x,y)$，对于 $x,y \\in \\mathbb{R}^n$，该函数返回标量 $\\langle x, y \\rangle$。\n- 关于所提供的内积，计算一个标准正交族 $\\{q_1,\\dots,q_r\\}$，它与在规定阈值 $\\tau$ 下数值上非零的输入向量生成相同的子空间。\n- 计算整数 $r$（返回的标准正交基向量的数量）。\n- 计算与标准正交性的最大绝对偏差，定义为\n$$\n\\Delta \\;=\\; \\max_{1 \\le i,j \\le r} \\left| \\langle q_i, q_j \\rangle \\;-\\; \\delta_{ij} \\right|,\n$$\n其中 $\\delta_{ij}$ 是克罗内克 δ。按照惯例，如果 $r=0$，则设 $\\Delta=0$。\n\n所有实现都必须是确定性的，不含随机性，并假设所提供的输入是精确的。不涉及角度。没有物理单位。\n\n测试套件。您的程序必须在内部运行以下 4 个测试用例（无需用户输入），每个用例由维度 $n$、定义内积 $\\langle x,y \\rangle_W = x^\\top W y$ 的对称正定矩阵 $W \\in \\mathbb{R}^{n \\times n}$、$\\mathbb{R}^n$ 中的列向量列表以及一个非负阈值 $\\tau$ 指定。\n\n- 测试用例 1（理想情况，欧几里得内积）：\n  - $n = 3$。\n  - $W = I_3$（$3 \\times 3$ 单位矩阵）。\n  - 向量：$v_1 = (1,\\,1,\\,0)^\\top$, $v_2 = (1,\\,0,\\,1)^\\top$, $v_3 = (0,\\,1,\\,1)^\\top$。\n  - 阈值 $\\tau = 10^{-12}$。\n\n- 测试用例 2（对角加权内积）：\n  - $n = 3$。\n  - $W = \\operatorname{diag}(2,\\,3,\\,5)$。\n  - 向量：$v_1 = (1,\\,2,\\,3)^\\top$, $v_2 = (4,\\,5,\\,6)^\\top$, $v_3 = (7,\\,8,\\,10)^\\top$。\n  - 阈值 $\\tau = 10^{-12}$。\n\n- 测试用例 3（近线性相关和零向量，欧几里得内积）：\n  - $n = 3$。\n  - $W = I_3$。\n  - 向量：$v_1 = (1,\\,0,\\,0)^\\top$, $v_2 = (10^{-12},\\,0,\\,0)^\\top$, $v_3 = (0,\\,1,\\,0)^\\top$, $v_4 = (0,\\,0,\\,0)^\\top$。\n  - 阈值 $\\tau = 10^{-9}$。\n\n- 测试用例 4（超完备集与非对角 SPD 权重）：\n  - $n = 3$。\n  - $W = \\begin{bmatrix} 2 & -1 & 0 \\\\ -1 & 2 & -1 \\\\ 0 & -1 & 2 \\end{bmatrix}$。\n  - 向量：$v_1 = (1,\\,0,\\,0)^\\top$, $v_2 = (0,\\,1,\\,0)^\\top$, $v_3 = (0,\\,0,\\,1)^\\top$, $v_4 = (1,\\,1,\\,1)^\\top$。\n  - 阈值 $\\tau = 10^{-12}$。\n\n最终输出格式要求。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试用例，该列表必须按顺序首先包含整数 $r$，然后是浮点值 $\\Delta$，其中浮点值需使用科学计数法格式化，小数点后精确到 12 位。具体而言，输出必须是\n$$\n[\\;r_1,\\;\\Delta_1,\\;r_2,\\;\\Delta_2,\\;r_3,\\;\\Delta_3,\\;r_4,\\;\\Delta_4\\;],\n$$\n其中每个 $\\Delta_k$ 都使用在科学计数法中小数点后有 12 位数字的格式字符串进行打印。不得打印任何其他文本。", "solution": "用户提供的问题陈述是有效的。它在科学上是合理的、适定的和客观的。该问题是数值线性代数中的一个标准任务：使用一个通用内积，为给定向量集合所生成的子空间构造一个标准正交基。完成此任务的方法是 Gram-Schmidt 过程，这是数学和计算工程中的一个基本算法。所有需要的数据和约束都已提供，没有矛盾或歧义。\n\n该问题要求针对给定的内积 $\\langle \\cdot, \\cdot \\rangle_W$，为子空间 $\\operatorname{span}\\{v_1, \\dots, v_m\\} \\subset \\mathbb{R}^n$ 构造一个标准正交基 $\\{q_1, \\dots, q_r\\}$。该内积由一个对称正定（SPD）矩阵 $W \\in \\mathbb{R}^{n \\times n}$ 定义为 $\\langle x, y \\rangle_W = x^\\top W y$。其关联范数为 $\\|x\\|_W = \\sqrt{\\langle x, x \\rangle_W}$。\n\n解决方案的核心是 Gram-Schmidt 正交化算法。该算法迭代进行，每次处理一个输入向量，并生成一个与所有先前生成的基向量正交的新的标准正交向量。\n\n设输入向量的集合为 $\\{v_1, v_2, \\dots, v_m\\}$。我们将逐步构造标准正交基 $Q = \\{q_1, q_2, \\dots, q_r\\}$。设 $Q_{k-1} = \\{q_1, \\dots, q_{k-1}\\}$ 是经过 $k-1$ 步后构造出的标准正交向量集合。为了找到下一个基向量，我们取下一个输入向量，比如 $v_j$，并使其相对于 $Q_{k-1}$ 中的所有向量正交。\n\n处理一个通用向量 $v$ 的过程是从该向量中减去其在由 $Q_{k-1}$ 生成的子空间上的投影。$v$ 在 $Q_{k-1}$ 的生成子空间上的投影由 $\\sum_{i=1}^{k-1} \\operatorname{proj}_{q_i}(v)$ 给出。对于标准正交基，到单个基向量 $q_i$ 上的投影为 $\\operatorname{proj}_{q_i}(v) = \\langle v, q_i \\rangle_W q_i$。\n\n因此，$v_j$ 正交于 $\\operatorname{span}(Q_{k-1})$ 的分量是向量 $u_j$：\n$$\nu_j = v_j - \\sum_{i=1}^{k-1} \\langle v_j, q_i \\rangle_W q_i\n$$\n根据构造，该向量 $u_j$ 与所有向量 $q_1, \\dots, q_{k-1}$ 正交。\n\n在数值计算中，一个关键的考虑是处理线性相关性。如果 $v_j$ 与生成 $Q_{k-1}$ 的先前向量线性相关，那么 $u_j$ 理论上将是零向量。在浮点运算中，这会产生一个范数非常小的向量。为了稳健地处理此问题，我们计算 $u_j$ 的范数，即 $\\|u_j\\|_W = \\sqrt{\\langle u_j, u_j \\rangle_W}$。然后我们将此范数与给定的阈值 $\\tau > 0$ 进行比较。\n\n如果 $\\|u_j\\|_W \\le \\tau$，我们断定 $v_j$ 在数值上位于已处理向量的生成子空间中。在这种情况下，我们舍弃 $u_j$ 并继续处理下一个输入向量 $v_{j+1}$。此步骤对于确定输入向量集的有效秩 $r$ 以及通过避免除以接近零的数来保持数值稳定性至关重要。\n\n如果 $\\|u_j\\|_W > \\tau$，那么 $u_j$ 代表一个新的独立方向。要使其成为标准正交基的一部分，必须将其归一化以具有单位范数。因此，新的基向量 $q_k$ 为：\n$$\nq_k = \\frac{u_j}{\\|u_j\\|_W}\n$$\n然后，这个新向量 $q_k$ 被添加到我们的基集合中，因此 $Q_k = Q_{k-1} \\cup \\{q_k\\}$。\n\n这个过程被称为带阈值处理的经典 Gram-Schmidt (CGS) 算法，它被应用于给定序列中的每个输入向量 $v_j$。\n\n总体算法如下：\n1. 为标准正交基初始化一个空列表，$Q = []$。\n2. 对于输入序列 $\\{v_1, v_2, \\dots, v_m\\}$ 中的每个向量 $v_j$：\n   a. 以 $v_j$ 开始，减去其在 $Q$ 中每个现有基向量上的投影，计算向量 $u_j$。\n   b. 计算范数的平方 $\\|u_j\\|_W^2 = \\langle u_j, u_j \\rangle_W$。\n   c. 如果 $\\|u_j\\|_W^2 > \\tau^2$，则计算范数 $\\|u_j\\|_W = \\sqrt{\\|u_j\\|_W^2}$，归一化向量 $q_{\\text{new}} = u_j / \\|u_j\\|_W$，并将 $q_{\\text{new}}$ 附加到列表 $Q$ 中。\n3. 最终基向量的数量为 $r = |Q|$。\n\n构造基 $Q = \\{q_1, \\dots, q_r\\}$ 后，我们必须验证其质量。一个理想的标准正交基满足 $\\langle q_i, q_j \\rangle_W = \\delta_{ij}$，其中 $\\delta_{ij}$ 是克罗内克 δ（如果 $i=j$ 则为 1，否则为 0）。由于浮点运算，会存在微小的偏差。与标准正交性的最大绝对偏差计算如下：\n$$\n\\Delta = \\max_{1 \\le i, j \\le r} \\left| \\langle q_i, q_j \\rangle_W - \\delta_{ij} \\right|\n$$\n如果 $r=0$（当所有输入向量在数值上都为零时发生），我们按照惯例定义 $\\Delta=0$。这个值 $\\Delta$ 为计算出的基的数值精度提供了一个定量度量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the Gram-Schmidt process,\n    and print the results in the specified format.\n    \"\"\"\n    \n    # Test case 1 (happy path, Euclidean inner product)\n    t1_W = np.identity(3, dtype=float)\n    t1_vectors = [\n        np.array([1.0, 1.0, 0.0]),\n        np.array([1.0, 0.0, 1.0]),\n        np.array([0.0, 1.0, 1.0]),\n    ]\n    t1_tau = 1e-12\n\n    # Test case 2 (diagonal weighted inner product)\n    t2_W = np.diag([2.0, 3.0, 5.0])\n    t2_vectors = [\n        np.array([1.0, 2.0, 3.0]),\n        np.array([4.0, 5.0, 6.0]),\n        np.array([7.0, 8.0, 10.0]),\n    ]\n    t2_tau = 1e-12\n\n    # Test case 3 (near linear dependence and a zero vector, Euclidean inner product)\n    t3_W = np.identity(3, dtype=float)\n    t3_vectors = [\n        np.array([1.0, 0.0, 0.0]),\n        np.array([1e-12, 0.0, 0.0]),\n        np.array([0.0, 1.0, 0.0]),\n        np.array([0.0, 0.0, 0.0]),\n    ]\n    t3_tau = 1e-9\n\n    # Test case 4 (overcomplete set with non-diagonal SPD weight)\n    t4_W = np.array([\n        [2.0, -1.0, 0.0],\n        [-1.0, 2.0, -1.0],\n        [0.0, -1.0, 2.0]\n    ], dtype=float)\n    t4_vectors = [\n        np.array([1.0, 0.0, 0.0]),\n        np.array([0.0, 1.0, 0.0]),\n        np.array([0.0, 0.0, 1.0]),\n        np.array([1.0, 1.0, 1.0]),\n    ]\n    t4_tau = 1e-12\n    \n    test_cases = [\n        (t1_W, t1_vectors, t1_tau),\n        (t2_W, t2_vectors, t2_tau),\n        (t3_W, t3_vectors, t3_tau),\n        (t4_W, t4_vectors, t4_tau),\n    ]\n\n    output_parts = []\n    for W, vectors, tau in test_cases:\n        r, delta = run_gram_schmidt_test(W, vectors, tau)\n        output_parts.append(str(r))\n        output_parts.append(f\"{delta:.12e}\")\n    \n    print(f\"[{','.join(output_parts)}]\")\n\n\ndef run_gram_schmidt_test(W, vectors, tau):\n    \"\"\"\n    Performs the Gram-Schmidt orthogonalization process for a single test case.\n\n    Args:\n        W (np.ndarray): The symmetric positive-definite matrix defining the inner product.\n        vectors (list[np.ndarray]): A list of input vectors to orthonormalize.\n        tau (float): The threshold for treating a vector norm as zero.\n\n    Returns:\n        tuple[int, float]: A tuple containing the number of orthonormal basis vectors (r)\n                           and the maximum absolute deviation from orthonormality (Delta).\n    \"\"\"\n    \n    def inner_product(x, y):\n        # Using np.dot for clarity and efficiency with vector-matrix products\n        return np.dot(x.T, np.dot(W, y))\n\n    orthonormal_basis = []\n    tau_squared = tau**2\n\n    for v in vectors:\n        u = v.copy()\n        # Orthogonalize u against the current basis\n        for q in orthonormal_basis:\n            # Projection of v onto q is <v,q>q. Here, we use v to compute the coefficient.\n            projection_scalar = inner_product(v, q)\n            u -= projection_scalar * q\n        \n        # Check norm of the orthogonalized vector u\n        norm_u_squared = inner_product(u, u)\n        \n        if norm_u_squared > tau_squared:\n            norm_u = np.sqrt(norm_u_squared)\n            new_q = u / norm_u\n            orthonormal_basis.append(new_q)\n    \n    r = len(orthonormal_basis)\n    \n    if r == 0:\n        return 0, 0.0\n\n    # Calculate the maximum deviation from orthonormality\n    max_dev = 0.0\n    for i in range(r):\n        for j in range(r):\n            ip_val = inner_product(orthonormal_basis[i], orthonormal_basis[j])\n            if i == j:\n                # Deviation from 1 on the diagonal\n                dev = abs(ip_val - 1.0)\n            else:\n                # Deviation from 0 on the off-diagonal\n                dev = abs(ip_val)\n            \n            if dev > max_dev:\n                max_dev = dev\n                \n    return r, max_dev\n\nsolve()\n```", "id": "2422280"}, {"introduction": "理论上完美的算法在面对有限精度计算的现实时，往往会暴露出数值不稳定性等问题，经典格拉姆-施密特过程便是一个典型例子。本练习将直面这一挑战，指导你实现数值性能更优越的“改进的格拉姆-施密特” (Modified Gram-Schmidt, MGS) 算法。更重要的是，你将学习如何通过设置阈值来检测和处理向量间的数值线性相关性，从而引入“数值秩”的概念，这是构建能够处理现实世界数据的可靠数值软件的基石 [@problem_id:2422283]。", "problem": "给定一个有限的实数列向量序列，需要使用 Gram-Schmidt 过程对其进行正交化。在计算工程学中，数值鲁棒性要求能够检测一个新向量何时在数值分辨率之外没有增加新的方向。仅从欧几里得空间中内积、投影、范数和正交性的核心定义出发，设计并实现一个算法，该算法对一组输入向量进行标准正交化，同时通过对接近零的范数进行阈值化来检测和处理线性相关性。\n\n定义和要求：\n- 在欧几里得空间 $\\mathbb{R}^n$ 中，使用标准内积 $x^\\top y$ 以及诱导的欧几里得范数 $\\|x\\|_2 = \\sqrt{x^\\top x}$。矩阵的 Frobenius 范数为 $\\|M\\|_F = \\sqrt{\\sum_{i,j} M_{ij}^2}$。\n- 给定 $\\mathbb{R}^n$ 中的一个有序输入向量集 $\\{v_1,\\dots,v_m\\}$，将向量 $v$ 在由两两标准正交的向量 $\\{q_1,\\dots,q_r\\}$ 张成的非空子空间上的正交投影定义为 $\\mathrm{proj}_{\\mathrm{span}\\{q_i\\}}(v) = \\sum_{i=1}^r (q_i^\\top v) q_i$。\n- Gram-Schmidt 正交化通过迭代地减去每个新向量 $v_j$ 在先前已接受的 $q_i$ 所张成的空间上的投影，并对残差进行单位化，从而构建一个标准正交集 $\\{q_1,\\dots,q_r\\}$。您必须使用修正的 Gram-Schmidt 顺序，即在每次减法操作后，立即计算与当前 $q_i$ 的内积并更新残差 $v$。\n- 为了在数值上检测线性相关性，引入一个非负阈值 $\\tau$。在处理输入向量 $v_j$ 时，从其减去在当前已张成的空间上的投影后，计算残差范数 $\\|v_j^\\perp\\|_2$。如果 $\\|v_j^\\perp\\|_2 \\le \\tau$，则将 $v_j$ 视为线性相关，不添加新的 $q$ 向量；否则，将 $q_{r+1} = v_j^\\perp / \\|v_j^\\perp\\|_2$ 加入标准正交集。\n- 构建上三角矩阵 $R \\in \\mathbb{R}^{r \\times m}$，其元素为 $r_{ij} = q_i^\\top v_j$（对于 $i \\le r$），且仅当 $v_j$ 被接受时，对角线元素为 $r_{jj} = \\|v_j^\\perp\\|_2$；否则，对于被拒绝的 $v_j$，不增加 $r$ 的值，并在 $R$ 中省略新的一行。关系式 $A \\approx Q R$ 应该成立，其中 $A \\in \\mathbb{R}^{n \\times m}$ 以 $v_j$ 为列向量，$Q \\in \\mathbb{R}^{n \\times r}$ 以 $q_i$ 为列向量，$\\approx$ 表示在浮点运算法则下的相等。\n- 列的索引是基于零的整数，也就是说，第一列的索引是 $0$，第二列是 $1$，以此类推。\n\n您的程序必须：\n- 实现上述带有相关性检测的修正 Gram-Schmidt 方法。输入为一个实数矩阵 $A \\in \\mathbb{R}^{n \\times m}$ 和一个标量阈值 $\\tau \\ge 0$。输出必须包括：\n  - $Q \\in \\mathbb{R}^{n \\times r}$，其列向量为标准正交向量，\n  - 上三角矩阵 $R \\in \\mathbb{R}^{r \\times m}$，其上三角的意义是，对于 $j  i$，第 $j$ 列中第 $i$ 行以下的条目为零，\n  - 一个包含已接受（独立）列的基于零的索引的列表，\n  - 一个包含已拒绝（相关）列的基于零的索引的列表，\n  - 标准正交性误差 $\\|Q^\\top Q - I_r\\|_F$，\n  - 重构误差 $\\|A - Q R\\|_F$，\n  - 估计的秩 $r$（即接受的向量数量）。\n- 使用双精度浮点运算。\n- 为进行验证，请检查标准正交性误差和重构误差是否均小于或等于 $10^{-10}$。\n\n测试套件：\n对于以下每个案例，将您的实现应用于指定的 $A$ 和 $\\tau$，并验证预期的结果。所有矩阵均以列向量形式给出。\n\n- 案例 $1$（一般独立集）：\n  - $A_1 = \\begin{bmatrix}\n  1  1  0 \\\\\n  0  1  1 \\\\\n  1  0  1\n  \\end{bmatrix}$，$\\tau_1 = 10^{-12}$\n  - 预期结果：秩为 $3$，相关列索引为 $[\\ ]$（空列表）。\n\n- 案例 $2$（精确线性相关和超完备集）：\n  - $A_2 = \\begin{bmatrix}\n  1  0  1  0 \\\\\n  0  1  1  0 \\\\\n  0  0  0  1\n  \\end{bmatrix}$ 其列向量为 $v_0 = [1,0,0]^\\top$，$v_1 = [0,1,0]^\\top$，$v_2 = v_0 + v_1$，$v_3 = [0,0,1]^\\top$；$\\tau_2 = 10^{-12}$\n  - 预期结果：秩为 $3$，相关列索引为 $[2]$。\n\n- 案例 $3$（接近零的列向量）：\n  - $A_3 = \\begin{bmatrix}\n  1  10^{-14}  0 \\\\\n  2  0  1 \\\\\n  3  0  0\n  \\end{bmatrix}$，$\\tau_3 = 10^{-12}$\n  - 预期结果：秩为 $2$，相关列索引为 $[1]$。\n\n- 案例 $4$（在容差下的近似线性相关）：\n  - $A_4 = \\begin{bmatrix}\n  1  1 + 10^{-12}  0  0  0 \\\\\n  0  10^{-12}  1  0  0 \\\\\n  0  0  0  1  0 \\\\\n  0  0  0  0  1\n  \\end{bmatrix}$ 其列向量为 $v_0 = [1,0,0,0]^\\top$，$v_1 = [1+10^{-12}, 10^{-12}, 0, 0]^\\top$，$v_2 = [0,1,0,0]^\\top$，$v_3 = [0,0,1,0]^\\top$，$v_4 = [0,0,0,1]^\\top$；$\\tau_4 = 10^{-10}$\n  - 预期结果：秩为 $4$，相关列索引为 $[1]$。\n\n对于每个案例，您的程序必须计算输出，然后同时验证：\n- 估计的秩 $r$ 等于该案例的预期秩；\n- 相关列索引列表等于该案例的预期列表；\n- 标准正交性误差 $\\le 10^{-10}$；\n- 重构误差 $\\le 10^{-10}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。列表中的每个条目是一个布尔值，按顺序对应案例 1 到 4，当且仅当该案例的所有验证均通过时，该值为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。例如，一个有效的输出形如 $[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{True}]$。", "solution": "所提出的问题是构建一个基于修正 Gram-Schmidt (MGS) 算法的、数值鲁棒的、能够揭示秩的 QR 分解。这是计算工程学和数值线性代数中的一项基本任务。其目标是将一个给定矩阵 $A \\in \\mathbb{R}^{n \\times m}$ 分解为一个具有标准正交列的矩阵 $Q \\in \\mathbb{R}^{n \\times r}$ 和一个矩阵 $R \\in \\mathbb{R}^{r \\times m}$ 的乘积，使得 $A \\approx QR$。此处，$r \\le \\min(n, m)$ 是通过数值确定的矩阵 $A$ 的秩。该过程必须通过使用一个容差阈值 $\\tau$ 来识别和处理 $A$ 各列之间的线性相关性。\n\n设输入矩阵为 $A = [v_0, v_1, \\dots, v_{m-1}]$，其中 $v_j \\in \\mathbb{R}^n$ 是列向量。Gram-Schmidt 过程构建一个标准正交向量集 $\\{q_0, q_1, \\dots, q_{r-1}\\}$，该集合所张成的空间与 $\\{v_j\\}$ 的线性无关子集所张成的空间相同。\n\n经典 Gram-Schmidt (CGS) 过程通过将输入向量 $v_j$ 与所有先前计算出的标准正交向量 $\\{q_0, \\dots, q_{j-1}\\}$ 进行正交化来计算每个新的标准正交向量 $q_j$：\n$$ v_j^\\perp = v_j - \\sum_{i=0}^{j-1} (q_i^\\top v_j) q_i, \\quad q_j = \\frac{v_j^\\perp}{\\|v_j^\\perp\\|_2} $$\n在有限精度算法中，此公式会遭受累积的正交性损失。每个内积 $(q_i^\\top v_j)$ 的计算都使用原始向量 $v_j$，这会因为舍入误差，将本应被移除的、沿着 $q_i$ 方向的分量重新引入。\n\n修正 Gram-Schmidt (MGS) 过程减轻了这种数值不稳定性。MGS 并非一次性将单个向量 $v_j$ 投影到整个已有的标准正交基上，而是在每个新的标准正交向量一经生成，就立即用它来对所有剩余向量进行正交化。该算法按以下步骤进行：\n\n令 $V^{(0)} = A$。对于每一步 $j=0, 1, \\dots, m-1$，我们取向量 $u_j = V^{(j)}_{:,j}$，它是经过 $j$ 步正交化后矩阵的第 $j$ 列。然后将此向量单位化以产生下一个标准正交向量 $q_j$。接着，从所有剩余向量 $V^{(j)}_{:,k}$（其中 $k > j$）中减去其在 $q_j$ 上的投影。\n\n为本问题所指定的算法包含一个用于检测线性相关性的容差 $\\tau$。它可以被形式化地描述如下：\n\n1.  初始化输入矩阵的工作副本，$V \\leftarrow A$。为标准正交向量初始化一个空列表 $Q_{\\text{list}}$，并初始化用于记录已接受和已拒绝向量索引的列表。\n\n2.  从 $j=0$ 到 $m-1$ 遍历 $V$ 的各列。在每次迭代 $j$ 中：\n    a.  提取当前要正交化的向量，$u \\leftarrow V_{:,j}$。\n    b.  计算其欧几里得范数，$\\rho = \\|u\\|_2$。\n    c.  将范数与阈值 $\\tau$ 进行比较。如果 $\\rho > \\tau$，则认为向量 $u$ 贡献了一个新的独立方向。\n        i.  该向量被接受：记录其原始索引 $j$。\n        ii. 计算并存储一个新的标准正交向量：$q = u/\\rho$。\n        iii. 这个新向量 $q$ 被用来更新 $V$ 的所有后续列。对于从 $j+1$ 到 $m-1$ 的每个 $k$，从 $V_{:,k}$ 中减去其在 $q$ 上的投影：$V_{:,k} \\leftarrow V_{:,k} - (q^\\top V_{:,k})q$。这是 MGS 的关键步骤。\n    d. 如果 $\\rho \\le \\tau$，则向量 $u$ 在数值上为零。这表示原始向量 $v_j$ 与前面的向量 $\\{v_0, \\dots, v_{j-1}\\}$ 线性相关。该向量被拒绝，其索引 $j$ 被记录，并且不生成新的标准正交向量。由于更新量将是微不足道的，在此步骤中不更新 $V$ 的后续列。\n\n3.  遍历完所有 $m$ 列后，过程终止。收集到的标准正交向量集 $\\{q_k\\}$ 构成矩阵 $Q$ 的列。秩 $r$ 是接受的向量数量。如果 $r > 0$，则通过堆叠 $Q_{\\text{list}}$ 中的向量来构造 $Q$。如果 $r=0$，$Q$ 是一个 $n \\times 0$ 的空矩阵。\n\n4.  矩阵 $R \\in \\mathbb{R}^{r \\times m}$ 必须满足关系 $A \\approx QR$。由此可得 $Q^\\top A \\approx Q^\\top(QR) = (Q^\\top Q)R = I_r R = R$。因此，在确定 $Q$ 之后，计算 $R$ 最直接且数值上最稳健的方法是通过矩阵乘积 $R = Q^\\top A_{original}$。\n\n5.  问题陈述为 $R$ 的条目提供了定义，我们必须证明这些定义与此构造方法是一致的。条目 $r_{kj}$（使用 $k$ 作为 $R$ 中对应于 $q_k$ 的行索引）被定义为 $r_{kj} = q_k^\\top v_j$。这恰好是 $R = Q^\\top A$ 所给出的定义。问题陈述还指出，对于一个被接受且成为 $q_k$ 来源的向量 $v_j$，“对角线”条目 $r_{kj}$ 应为 $\\|v_j^\\perp\\|_2$，其中 $v_j^\\perp$ 是 $v_j$ 对 $\\{q_0, \\dots, q_{k-1}\\}$ 正交化后的残差。等式 $\\|v_j^\\perp\\|_2 = q_k^\\top v_j$ 成立，因为 $q_k = v_j^\\perp / \\|v_j^\\perp\\|_2$，并且 $q_k$ 与从 $v_j$ 中减去以形成 $v_j^\\perp$ 的各分量正交。因此，这些定义是一致的。\n\n6.  最后，算法必须计算两个误差度量用于验证：\n    - 标准正交性误差：$\\|Q^\\top Q - I_r\\|_F$，它衡量 $Q$ 的列向量在多大程度上构成一个标准正交集。\n    - 重构误差：$\\|A - QR\\|_F$，它衡量该分解在多大程度上重构了原始矩阵 $A$。乘积 $QR = Q(Q^\\top A) = (QQ^\\top)A$ 表示 $A$ 在 $Q$ 的列空间上的投影。此误差是 $A$ 在该空间的正交补空间中的分量的范数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef modified_gram_schmidt(A, tau):\n    \"\"\"\n    Performs rank-revealing QR factorization using the Modified Gram-Schmidt process.\n\n    Args:\n        A (np.ndarray): The input matrix of shape (n, m) with columns to be orthogonalized.\n        tau (float): The non-negative threshold for detecting linear dependence.\n\n    Returns:\n        dict: A dictionary containing the following outputs:\n            'Q': The matrix with orthonormal columns, shape (n, r).\n            'R': The upper-triangular matrix, shape (r, m).\n            'accepted_indices': A list of zero-based indices of accepted columns.\n            'rejected_indices': A list of zero-based indices of rejected columns.\n            'orthonormality_error': The Frobenius norm of ||Q.T @ Q - I||.\n            'reconstruction_error': The Frobenius norm of ||A - Q @ R||.\n            'rank': The computed rank r.\n    \"\"\"\n    n, m = A.shape\n    V = A.copy().astype(np.float64)  # Use double precision\n    \n    Q_list = []\n    accepted_indices = []\n    rejected_indices = []\n    \n    for j in range(m):\n        u = V[:, j]\n        norm_u = np.linalg.norm(u)\n        \n        if norm_u  tau:\n            accepted_indices.append(j)\n            q = u / norm_u\n            Q_list.append(q)\n            \n            # Update subsequent vectors in V using the new q vector\n            for k in range(j + 1, m):\n                V[:, k] -= np.dot(q, V[:, k]) * q\n        else:\n            rejected_indices.append(j)\n\n    rank = len(accepted_indices)\n\n    if rank  0:\n        Q = np.stack(Q_list, axis=1)\n        R = Q.T @ A\n    else:\n        # Handle the case where the rank is 0\n        Q = np.zeros((n, 0), dtype=np.float64)\n        R = np.zeros((0, m), dtype=np.float64)\n\n    # Calculate errors\n    if rank  0:\n        I_r = np.identity(rank, dtype=np.float64)\n        orthonormality_error = np.linalg.norm(Q.T @ Q - I_r, 'fro')\n    else:\n        orthonormality_error = 0.0\n\n    reconstruction_error = np.linalg.norm(A - Q @ R, 'fro')\n\n    return {\n        'Q': Q,\n        'R': R,\n        'accepted_indices': accepted_indices,\n        'rejected_indices': rejected_indices,\n        'orthonormality_error': orthonormality_error,\n        'reconstruction_error': reconstruction_error,\n        'rank': rank\n    }\n\ndef solve():\n    \"\"\"\n    Runs the test suite and validates the results against expectations.\n    \"\"\"\n    test_cases = [\n        {\n            \"A\": np.array([[1, 1, 0], \n                           [0, 1, 1], \n                           [1, 0, 1]], dtype=np.float64),\n            \"tau\": 1e-12,\n            \"expected_rank\": 3,\n            \"expected_dependent_indices\": []\n        },\n        {\n            \"A\": np.array([[1, 0, 1, 0], \n                           [0, 1, 1, 0], \n                           [0, 0, 0, 1]], dtype=np.float64),\n            \"tau\": 1e-12,\n            \"expected_rank\": 3,\n            \"expected_dependent_indices\": [2]\n        },\n        {\n            \"A\": np.array([[1, 1e-14, 0], \n                           [2, 0,     1], \n                           [3, 0,     0]], dtype=np.float64),\n            \"tau\": 1e-12,\n            \"expected_rank\": 2,\n            \"expected_dependent_indices\": [1]\n        },\n        {\n            \"A\": np.array([[1, 1 + 1e-12, 0, 0, 0], \n                           [0, 1e-12,     1, 0, 0],\n                           [0, 0,         0, 1, 0],\n                           [0, 0,         0, 0, 1]], dtype=np.float64),\n            \"tau\": 1e-10,\n            \"expected_rank\": 4,\n            \"expected_dependent_indices\": [1]\n        },\n    ]\n\n    results = []\n    error_tolerance = 1e-10\n\n    for case in test_cases:\n        A = case[\"A\"]\n        tau = case[\"tau\"]\n        \n        output = modified_gram_schmidt(A, tau)\n        \n        rank_check = output['rank'] == case['expected_rank']\n        indices_check = sorted(output['rejected_indices']) == sorted(case['expected_dependent_indices'])\n        ortho_err_check = output['orthonormality_error'] = error_tolerance\n        recon_err_check = output['reconstruction_error'] = error_tolerance\n\n        is_valid = all([rank_check, indices_check, ortho_err_check, recon_err_check])\n        results.append(is_valid)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2422283"}]}