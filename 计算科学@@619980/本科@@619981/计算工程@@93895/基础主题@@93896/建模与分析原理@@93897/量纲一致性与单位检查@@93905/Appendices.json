{"hands_on_practices": [{"introduction": "工程领域经常使用从实验数据中得出的经验公式，例如一个假设的河流流量模型可以表示为 $Q = c A^{1.2} S^{0.5}$。量纲分析对于理解这些公式中经验系数 $c$ 的物理意义至关重要。这个练习将通过分析这个模型来巩固对量纲齐性原则的理解，这是解读和验证物理模型的一项基本技能。[@problem_id:2384795]", "problem": "在计算工程学中的计算水文学领域，考虑一个由 $Q = c\\,A^{1.2}\\,S^{0.5}$ 给出的河流体积流量经验关系式，其中 $Q$ 是体积流量，$A$ 是湿横截面积，$S$ 是河床坡度。假设在国际单位制（SI）中，$Q$ 的单位是 $\\mathrm{m}^{3}\\,\\mathrm{s}^{-1}$，$A$ 的单位是 $\\mathrm{m}^{2}$，而 $S$ 是无量纲的。设基本量纲为质量 $M$、长度 $L$ 和时间 $T$。确定指数 $m$、$l$ 和 $t$，使得 $c$ 的量纲公式可以写为 $[c] = M^{m} L^{l} T^{t}$。以行矩阵 $\\begin{pmatrix} m & l & t \\end{pmatrix}$ 的形式给出你的最终答案。提供精确值，不要四舍五入。", "solution": "首先将对问题陈述进行严格的验证过程。\n\n**步骤 1：提取已知条件**\n以下信息逐字引自问题陈述：\n- 经验关系式：$Q = c\\,A^{1.2}\\,S^{0.5}$\n- $Q$ 是体积流量。\n- $A$ 是湿横截面积。\n- $S$ 是河床坡度。\n- $Q$ 的单位：$\\mathrm{m}^{3}\\,\\mathrm{s}^{-1}$。\n- $A$ 的单位：$\\mathrm{m}^{2}$。\n- $S$ 是无量纲的。\n- 基本量纲：质量 ($M$)、长度 ($L$) 和时间 ($T$)。\n- 常数 $c$ 的量纲公式需表示为 $[c] = M^{m} L^{l} T^{t}$。\n- 目标是确定指数 $m$、$l$ 和 $t$。\n- 最终答案格式为行矩阵 $\\begin{pmatrix} m & l & t \\end{pmatrix}$。\n\n**步骤 2：使用提取的已知条件进行验证**\n根据既定标准对问题进行分析。\n- **科学依据：** 该问题基于量纲齐次性原理，这是物理学和工程学中的一个基本概念。所提供的经验公式类似于著名的水文模型，如 Manning 公式或 Chézy 公式，这些模型将流量与几何和水力特性联系起来。因此，它在科学上是合理的。\n- **适定性：** 该问题提供了确定常数 $c$ 的量纲所需的所有必要信息。$Q$、$A$ 和 $S$ 的量纲已明确说明或可直接从其定义和单位推断。问题结构保证了指数 $m$、$l$ 和 $t$ 存在唯一解。\n- **客观性：** 问题以清晰、精确和定量的语言陈述，没有任何主观性或模糊性。\n\n基于此分析，该问题被认定为没有任何缺陷。它是自洽的、一致的且科学上有效的。因此，将提供解答。\n\n**步骤 3：结论与行动**\n问题有效。开始求解。\n\n支配此问题的基本原理是量纲齐次性原理，该原理指出，对于任何具有物理意义的方程，所有项的量纲必须相同。给定的经验关系式是 $Q = c\\,A^{1.2}\\,S^{0.5}$。\n\n为了求出系数 $c$ 的量纲，我们首先用量纲来表示该方程：\n$$\n[Q] = [c] [A]^{1.2} [S]^{0.5}\n$$\n这里，$[X]$ 表示物理量 $X$ 的量纲。我们必须根据质量 ($M$)、长度 ($L$) 和时间 ($T$) 的基本量纲来确定每个变量的量纲。\n\n1.  体积流量 $Q$ 的单位为 $\\mathrm{m}^{3}\\,\\mathrm{s}^{-1}$。米 ($\\mathrm{m}$) 是长度的基本单位，秒 ($\\mathrm{s}$) 是时间的基本单位。因此，$Q$ 的量纲是单位时间内的体积，即长度的立方除以时间：\n    $$\n    [Q] = \\frac{L^3}{T} = L^{3} T^{-1}\n    $$\n2.  湿横截面积 $A$ 的单位为 $\\mathrm{m}^{2}$。这对应于长度的平方量纲：\n    $$\n    [A] = L^2\n    $$\n3.  河床坡度 $S$ 被说明是无量纲的。无量纲量没有物理单位，其量纲表示为1：\n    $$\n    [S] = M^0 L^0 T^0 = 1\n    $$\n\n现在，我们将这些量纲公式代回量纲方程中：\n$$\nL^{3} T^{-1} = [c] (L^{2})^{1.2} (1)^{0.5}\n$$\n我们化简方程的右边。使用指数法则 $(x^a)^b = x^{ab}$：\n$$\nL^{3} T^{-1} = [c] L^{2 \\times 1.2} \\times 1\n$$\n$$\nL^{3} T^{-1} = [c] L^{2.4}\n$$\n为了确定 $c$ 的量纲，我们分离出 $[c]$：\n$$\n[c] = \\frac{L^{3} T^{-1}}{L^{2.4}}\n$$\n使用除法的指数法则 $x^a / x^b = x^{a-b}$：\n$$\n[c] = L^{3 - 2.4} T^{-1}\n$$\n$$\n[c] = L^{0.6} T^{-1}\n$$\n问题要求答案是精确的。指数 $0.6$ 可以表示为分数 $\\frac{6}{10}$，化简后为 $\\frac{3}{5}$。因此：\n$$\n[c] = L^{3/5} T^{-1}\n$$\n问题要求将量纲公式写成 $[c] = M^{m} L^{l} T^{t}$ 的形式。通过将我们的结果与此通用形式进行比较，我们可以确定指数：\n$$\n[c] = M^0 L^{3/5} T^{-1}\n$$\n通过比较，我们推断出：\n- $m = 0$\n- $l = \\frac{3}{5}$\n- $t = -1$\n\n这些是指数的精确值。按要求，解以行矩阵的形式呈现。", "answer": "$$\n\\boxed{\\begin{pmatrix} 0 & \\frac{3}{5} & -1 \\end{pmatrix}}\n$$", "id": "2384795"}, {"introduction": "在计算工作中，单位错误是导致灾难性故障的常见原因，例如在数值积分 $x_{k+1} = x_k + v_k \\Delta t$ 中误用时间步长的单位。这个练习模拟了这样一个非常现实的编程错误，即错误地将以毫秒为单位的时间步长当作秒来使用。通过这个实践，你将看到一个微小的单位错误是如何在计算中被放大并导致结果出现巨大偏差，从而将量纲分析与软件调试和数值方法的实践联系起来。[@problem_id:2384811]", "problem": "一个计算工程系统中的一维追踪程序通过对记录的速度信号 $v(t)$（单位为 $\\mathrm{m/s}$）进行数值积分来估计位置 $x$。处理器在 $T = 12 \\ \\mathrm{s}$ 的物理时长内，每 $\\Delta t_{\\mathrm{ms}} = 5 \\ \\mathrm{ms}$ 均匀采样一次速度。该代码使用显式前向欧拉更新 $x_{k+1} = x_k + v_k \\,\\Delta t$，其中 $x_0 = 0$，$v_k$ 是第 $k$ 步的采样速度。在所有 $t \\in [0, T]$ 时间内，物理速度是恒定的，等于 $v(t) = 1.8 \\ \\mathrm{m/s}$。由于一个程序错误，来自 $\\Delta t_{\\mathrm{ms}}$ 的数值 $5$ 被直接当作以秒为单位的值使用（即，$\\Delta t$ 被取为 $5$ 而不是正确的 $0.005$）。\n\n哪个选项正确地描述了在 $t = T$ 时的量纲错误及其定量影响，并给出了恢复量纲一致性的最小修改方案？\n\n- A. 计算出的最终位置将是真实位置的 $1000$ 倍。正确的修复方法是在使用前将 $\\Delta t_{\\mathrm{ms}}$ 乘以 $10^{-3}$，以将毫秒转换为秒。\n\n- B. 计算出的最终位置将是真实位置的 $1/1000$。正确的修复方法是在使用前将 $\\Delta t_{\\mathrm{ms}}$ 乘以 $10^{3}$。\n\n- C. 数值计算的位置等于真实位置，因为 $v$ 和 $T$ 都是恒定的，所以在求和过程中单位会抵消，不需要任何更改。\n\n- D. 计算出的最终位置误差因子是 $200$，因为在 $5 \\ \\mathrm{ms}$ 的采样间隔下每秒有 $200$ 个样本。正确的修复方法是保持 $\\Delta t$ 不变，同时将积分步数减少为原来的1/200。", "solution": "提交问题陈述以供验证。\n\n**步骤1：提取已知条件**\n- 系统估计位置 $x$。\n- 积分方法为显式前向欧拉法：$x_{k+1} = x_k + v_k \\,\\Delta t$。\n- 初始条件为 $x_0 = 0$。\n- 物理速度是恒定的：对于 $t \\in [0, T]$，$v(t) = 1.8 \\ \\mathrm{m/s}$。\n- 速度单位为 $\\mathrm{m/s}$。\n- 过程的物理时长为 $T = 12 \\ \\mathrm{s}$。\n- 速度信号以 $\\Delta t_{\\mathrm{ms}} = 5 \\ \\mathrm{ms}$ 的时间步长被均匀采样。\n- 程序错误：代码直接使用来自 $\\Delta t_{\\mathrm{ms}}$ 的数值 $5$ 作为时间步长 $\\Delta t$，将其单位视为秒。因此，计算中使用的时间步长为 $\\Delta t_{bug} = 5 \\ \\mathrm{s}$。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，描述了计算工程中常见的标准数值积分场景（用于运动学的欧拉方法）。该问题是适定的，提供了计算正确物理结果和错误计算结果所需的所有必要数据。语言客观、精确。单位转换错误（毫秒 vs. 秒）的场景是科学编程中一种非常现实且常见的程序错误类型。该问题是自洽的、一致的，并且需要直接应用量纲分析和数值积分原理。没有可识别的缺陷。\n\n**步骤3：结论与行动**\n问题是**有效的**。开始求解。\n\n**求解过程**\n\n首先，我们确定真实的最终位置。位置 $x(t)$ 是速度 $v(t)$ 的时间积分。给定恒定速度 $v(t) = v_{const} = 1.8 \\ \\mathrm{m/s}$ 和初始位置 $x(0) = 0$，在时间 $T = 12 \\ \\mathrm{s}$ 时的真实位置是：\n$$\nx_{true}(T) = \\int_{0}^{T} v_{const} \\, dt = v_{const} \\times T\n$$\n$$\nx_{true}(T) = (1.8 \\ \\mathrm{m/s}) \\times (12 \\ \\mathrm{s}) = 21.6 \\ \\mathrm{m}\n$$\n\n接下来，我们分析代码执行的计算。处理器以 $\\Delta t_{correct} = 5 \\ \\mathrm{ms} = 5 \\times 10^{-3} \\ \\mathrm{s} = 0.005 \\ \\mathrm{s}$ 的物理间隔采样速度。在 $T = 12 \\ \\mathrm{s}$ 的总时长内，总积分步数 $N$为：\n$$\nN = \\frac{T}{\\Delta t_{correct}} = \\frac{12 \\ \\mathrm{s}}{0.005 \\ \\mathrm{s}} = 2400\n$$\n代码执行 $N=2400$ 次更新步骤。在每一步中，它使用采样速度 $v_k = 1.8 \\ \\mathrm{m/s}$（因为速度是恒定的），但应用了不正确的时间步长 $\\Delta t_{bug} = 5 \\ \\mathrm{s}$。数值积分展开为一个和式：\n$$\nx_{computed} = x_0 + \\sum_{k=0}^{N-1} v_k \\Delta t_{bug}\n$$\n当 $x_0 = 0$，$v_k = 1.8 \\ \\mathrm{m/s}$，$N=2400$，以及 $\\Delta t_{bug} = 5 \\ \\mathrm{s}$ 时，计算出的最终位置是：\n$$\nx_{computed} = \\sum_{k=0}^{2399} (1.8 \\ \\mathrm{m/s}) \\times (5 \\ \\mathrm{s}) = N \\times (1.8 \\ \\mathrm{m/s}) \\times (5 \\ \\mathrm{s})\n$$\n$$\nx_{computed} = 2400 \\times 1.8 \\times 5 = 21600 \\ \\mathrm{m}\n$$\n计算出的位置是 $21600 \\ \\mathrm{m}$，即 $21.6 \\ \\mathrm{km}$。\n\n现在我们确定定量影响，即计算位置与真实位置的比值：\n$$\n\\text{误差因子} = \\frac{x_{computed}}{x_{true}} = \\frac{21600 \\ \\mathrm{m}}{21.6 \\ \\mathrm{m}} = 1000\n$$\n计算出的最终位置是真实位置的 $1000$ 倍。\n\n最后，我们给出恢复量纲一致性的最小修改方案。该程序错误之所以产生，是因为变量 $\\Delta t_{\\mathrm{ms}}$（单位为毫秒）的数值 $5$ 被用在了一个期望单位为秒的公式中。以秒为单位的正确时间步长值是 $\\Delta t_{correct} = 5 \\ \\mathrm{ms} = 0.005 \\ \\mathrm{s}$。为了正确执行此转换，必须将以毫秒为单位的值乘以转换因子 $10^{-3} \\ \\mathrm{s/ms}$。\n$$\n\\Delta t (\\text{单位 s}) = \\Delta t_{\\mathrm{ms}} (\\text{单位 ms}) \\times 10^{-3} \\ \\frac{\\mathrm{s}}{\\mathrm{ms}}\n$$\n所以，数值 $5$ 在用于积分公式之前应乘以 $10^{-3}$。\n\n**选项评估**\n\n- **A. 计算出的最终位置将是真实位置的 $1000$ 倍。正确的修复方法是在使用前将 $\\Delta t_{\\mathrm{ms}}$ 乘以 $10^{-3}$，以将毫秒转换为秒。**\n  - 分析表明，误差因子恰好是 $1000$，并且计算出的位置更大。这部分是正确的。\n  - 分析表明，正确的修复方法是将毫秒值乘以 $10^{-3}$ 以获得以秒为单位的值。这部分也是正确的。\n  - **结论：正确。**\n\n- **B. 计算出的最终位置将是真实位置的 $1/1000$。正确的修复方法是在使用前将 $\\Delta t_{\\mathrm{ms}}$ 乘以 $10^{3}$。**\n  - 计算出的位置更大，而不是更小。第一条陈述是错误的。\n  - 乘以 $10^3$ 是将秒转换为毫秒的正确步骤，这与要求相反。这部分也是错误的。\n  - **结论：不正确。**\n\n- **C. 数值计算的位置等于真实位置，因为 $v$ 和 $T$ 都是恒定的，所以在求和过程中单位会抵消，不需要任何更改。**\n  - 这种说法从根本上是错误的。参数（$\\Delta t$）中的单位错误不会消失；它会在整个计算过程中传播和放大。其他参数（$v$，$T$）的恒定性简化了分析，但不能消除错误。我们的计算表明计算结果与真实结果之间存在巨大差异。\n  - **结论：不正确。**\n\n- **D. 计算出的最终位置误差因子是 $200$，因为在 $5 \\ \\mathrm{ms}$ 的采样间隔下每秒有 $200$ 个样本。正确的修复方法是保持 $\\Delta t$ 不变，同时将积分步数减少为原来的1/200。**\n  - 采样率确实是 $1 / (0.005 \\ \\mathrm{s}) = 200 \\ \\mathrm{Hz}$，但这不是误差因子。误差因子是 $1000$，它源于所使用的不正确时间步长（$5 \\ \\mathrm{s}$）与正确时间步长（$0.005 \\ \\mathrm{s}$）的比值。\n  - 改变步数（$N$）并不能解决核心问题，即 $\\Delta t$ 的值量纲不一致。这种“修复”是不合逻辑的，并且不会产生正确的物理结果。\n  - **结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "2384811"}, {"introduction": "防止单位错误的最佳方法是设计具有内在单位意识的软件，即通过代码结构来保证量纲一致性。这项实践将指导你为一个物理量（距离）构建一个自定义数据类型（类），使其能够自动处理不同单位（如米、英尺、光年）的换算与运算。通过这种方式，你将学习一种强大的软件工程模式，即利用类型系统来确保计算的物理正确性，这是编写稳健科学软件的关键技能。[@problem_id:2384770]", "problem": "您必须编写一个完整的程序，该程序能强制执行距离的量纲一致性，并使用一个一致的基本单位进行单位正确的计算。基本单位是米。程序必须定义一个距离量的模型，该模型具有三种允许的单位：米、英尺和光年，并且必须使用以下基于物理的定义。\n\n定义和要求：\n- 物理距离量具有长度量纲。加法和减法仅在两个距离之间有效。允许乘以或除以一个无量纲标量；本任务中不允许两个距离相乘或相除。\n- 所有内部计算都必须以米为基本单位进行。\n- 有效的输入单位是米($\\text{m}$)、英尺($\\text{ft}$)和光年($\\text{ly}$)。\n- 英尺精确定义为 $1\\,\\text{ft} = 0.3048\\,\\text{m}$。\n- 在本问题中，光年定义为光在一个儒略年内传播的距离。使用精确光速 $c = 299{,}792{,}458\\,\\text{m}\\,\\text{s}^{-1}$ 和儒略年时长 $T = 365.25$ 天。一天有 $24$ 小时，一小时有 $3600$ 秒。因此，一个儒略年有 $T_{\\text{s}} = 365.25 \\times 24 \\times 3600 = 31{,}557{,}600\\,\\text{s}$ 秒，一光年为 $1\\,\\text{ly} = c \\times T_{\\text{s}}\\,\\text{m}$。\n- 当跨单位比较距离的相等性时，按如下方式定义相等性谓词：两个距离在转换成米后，如果其绝对差小于或等于容差 $\\varepsilon = 10^{-12}\\,\\text{m}$，则认为它们相等。\n- 所有数值距离输出都必须以米表示，并四舍五入到六位小数。\n- 不涉及角度。不需要角度单位。\n\n需要实现和评估的测试套件：\n按下列顺序列出计算以下结果。如果某个操作在量纲上无效，则根据上述规则输出一个布尔值 $ \\text{True} $ 或 $ \\text{False} $ 来指示量纲有效性。对于数值结果，输出以米为单位并四舍五入后的距离。\n\n1. 计算 $3\\,\\text{m} + 10\\,\\text{ft}$，以米为单位，四舍五入到六位小数。\n2. 计算 $1\\,\\text{ly} - 10^{16}\\,\\text{m}$，以米为单位，四舍五入到六位小数。\n3. 将 $5280\\,\\text{ft}$ 转换为米，四舍五入到六位小数。\n4. 判断 $5\\,\\text{ft} + 3$（其中 $3$ 是无量纲的）在量纲上是否有效。输出一个布尔值。\n5. 判断 $1\\,\\text{m}$ 和 $3.280839895013123\\,\\text{ft}$ 在容差 $\\varepsilon = 10^{-12}\\,\\text{m}$下是否相等。输出一个布尔值。\n6. 计算 $2 \\times \\left(-5\\,\\text{ft}\\right)$，以米为单位，四舍五入到六位小数。\n7. 计算 $0\\,\\text{m} + 0\\,\\text{ft}$，以米为单位，四舍五入到六位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按上述测试套件顺序排列的结果，格式为方括号括起来的逗号分隔列表。数值条目必须是计算出的、以米为单位并四舍五入到六位小数的值，逻辑条目必须是布尔值。例如，输出应如下所示：\"[x1,x2,x3,x4,x5,x6,x7]\"，其中 $x_1$、$x_2$、$x_3$、$x_6$、$x_7$ 是以米为单位、四舍五入到六位小数的浮点数，而 $x_4$、$x_5$ 是布尔值。", "solution": "问题陈述已经过严格审查，并被确定为 **有效的** 。它有科学依据、是良定的、客观的，并包含构建唯一且可验证解所需的所有必要信息。它提出了计算工程领域一个明确的任务，特别是关于量纲一致性和单位管理，这些都是科学计算中的基本概念。\n\n该解将通过设计一个计算模型来实现，该模型表示一个物理距离量，并强制执行量纲分析的规则。我们选择面向对象的方法，因为它适合封装数据和行为。将创建一个名为 `Distance` 的 Python 类来对此数量进行建模。\n\n**核心设计原则**\n\n1.  **基本单位表示**：为确保一致性并简化算术，所有距离值都将以单一基本单位——米（$\\text{m}$）——在内部存储。距离 $d$ 的内部值将表示为 $d_{\\text{m}}$。\n\n2.  **初始化时进行单位转换**：`Distance` 类的构造函数将接受一个数值和一个单位字符串（$\\text{'m'}$、$\\text{'ft'}$ 或 $\\text{'ly'}$）。它将立即使用问题中定义的精确转换因子将输入值转换为米。转换因子如下：\n    - 从英尺到米：$1\\,\\text{ft} = 0.3048\\,\\text{m}$。\n    - 从光年到米：一光年（$1\\,\\text{ly}$）是光在一个儒略年内传播的距离。\n      - 光速 $c = 299{,}792{,}458\\,\\text{m}\\,\\text{s}^{-1}$。\n      - 儒略年的秒数 $T_{\\text{s}} = 365.25\\,\\text{days} \\times 24\\,\\text{h/day} \\times 3600\\,\\text{s/h} = 31{,}557{,}600\\,\\text{s}$。\n      - 因此，$1\\,\\text{ly} = c \\times T_{\\text{s}} = 9{,}460{,}730{,}472{,}580{,}800\\,\\text{m}$。\n\n3.  **感知量纲的算术**：将重载标准算术运算符以强制实现量纲正确性。\n    - **加法和减法**：将定义 `+` 和 `-` 运算符，使其仅在两个 `Distance` 对象之间操作。$d_1 \\pm d_2$ 的结果是一个新的 `Distance` 对象，其内部值为 $d_{1,\\text{m}} \\pm d_{2,\\text{m}}$。`Distance` 对象与无量纲标量之间的运算（例如，$5\\,\\text{ft} + 3$）违反了量纲齐次性原则，因此是无效的。\n    - **标量乘法**：将定义 `*` 运算符，用于 `Distance` 对象与无量纲标量 $\\alpha$ 的乘法。结果是一个新的 `Distance` 对象，其内部值为 $\\alpha \\times d_{\\text{m}}$。\n\n4.  **带容差的相等性判断**：相等运算符 `==` 将通过检查两个 `Distance` 对象 $d_1$ 和 $d_2$ 以米为单位的值的绝对差是否在指定的容差 $\\varepsilon = 10^{-12}\\,\\text{m}$ 范围内，来对它们进行比较。因此，当且仅当 $|d_{1,\\text{m}} - d_{2,\\text{m}}| \\le \\varepsilon$ 时，$d_1 = d_2$。\n\n**评估测试套件**\n\n将使用此 `Distance` 模型评估测试用例。\n\n1.  **计算 $3\\,\\text{m} + 10\\,\\text{ft}$**：\n    - $3\\,\\text{m}$ 的 `Distance` 对象的 $d_{1,\\text{m}} = 3.0\\,\\text{m}$。\n    - $10\\,\\text{ft}$ 的 `Distance` 对象的 $d_{2,\\text{m}} = 10 \\times 0.3048 = 3.048\\,\\text{m}$。\n    - 和的内部值为 $3.0 + 3.048 = 6.048\\,\\text{m}$。四舍五入到六位小数，结果为 $6.048000$。\n\n2.  **计算 $1\\,\\text{ly} - 10^{16}\\,\\text{m}$**：\n    - $1\\,\\text{ly}$ 的 `Distance` 对象的 $d_{1,\\text{m}} = 9{,}460{,}730{,}472{,}580{,}800\\,\\text{m}$。\n    - $10^{16}\\,\\text{m}$ 的 `Distance` 对象的 $d_{2,\\text{m}} = 10{,}000{,}000{,}000{,}000{,}000\\,\\text{m}$。\n    - 差的内部值为 $9{,}460{,}730{,}472{,}580{,}800 - 10{,}000{,}000{,}000{,}000{,}000 = -539{,}269{,}527{,}419{,}200\\,\\text{m}$。四舍五入后，结果为 $-539269527419200.000000$。\n\n3.  **将 $5280\\,\\text{ft}$ 转换为米**：\n    - $5280\\,\\text{ft}$ 的 `Distance` 对象的内部值为 $5280 \\times 0.3048 = 1609.344\\,\\text{m}$。四舍五入后，结果为 $1609.344000$。\n\n4.  **判断 $5\\,\\text{ft} + 3$ 在量纲上是否有效**：\n    - 这是一个 `Distance` 对象（$5\\,\\text{ft}$）与一个无量纲标量（$3$）之间的加法。这违反了量纲齐次性原则。该操作无效。结果是 `False`。\n\n5.  **判断 $1\\,\\text{m}$ 和 $3.280839895013123\\,\\text{ft}$ 是否相等**：\n    - $d_1$ 是 $1\\,\\text{m}$，所以 $d_{1,\\text{m}} = 1.0\\,\\text{m}$。\n    - $d_2$ 是 $3.280839895013123\\,\\text{ft}$。其以米为单位的值是 $d_{2,\\text{m}} = 3.280839895013123 \\times 0.3048 \\approx 0.9999999999999999\\,\\text{m}$。\n    - 绝对差是 $|1.0 - 0.9999999999999999| \\approx 1.11 \\times 10^{-16}\\,\\text{m}$。\n    - 由于 $1.11 \\times 10^{-16} \\le 10^{-12}$，这两个距离被认为是相等的。结果是 `True`。\n\n6.  **计算 $2 \\times (-5\\,\\text{ft})$**：\n    - $-5\\,\\text{ft}$ 的 `Distance` 对象的内部值为 $-5 \\times 0.3048 = -1.524\\,\\text{m}$。\n    - 乘以标量 $2$ 会产生一个新的 `Distance` 对象，其值为 $2 \\times (-1.524) = -3.048\\,\\text{m}$。四舍五入后，结果为 $-3.048000$。\n\n7.  **计算 $0\\,\\text{m} + 0\\,\\text{ft}$**：\n    - $0\\,\\text{m}$ 的 `Distance` 对象的 $d_{1,\\text{m}} = 0.0\\,\\text{m}$。\n    - $0\\,\\text{ft}$ 的 `Distance` 对象的 $d_{2,\\text{m}} = 0 \\times 0.3048 = 0.0\\,\\text{m}$。\n    - 和的值为 $0.0 + 0.0 = 0.0\\,\\text{m}$。四舍五入后，结果为 $0.000000$。\n\n这种系统性的、基于原则的方法确保了正确性和鲁棒性，并构成了以下程序的基础。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a set of problems related to dimensional consistency and unit conversions\n    for a custom Distance quantity.\n    \"\"\"\n\n    # Define physical and problem-specific constants.\n    # Speed of light in m/s (exact by definition).\n    SPEED_OF_LIGHT = 299792458\n    # Duration of a Julian year in seconds.\n    SECONDS_PER_JULIAN_YEAR = 365.25 * 24 * 3600\n    \n    # Define conversion factors to the base unit (meter).\n    CONVERSION_FACTORS = {\n        'm': 1.0,\n        'ft': 0.3048,  # International foot definition\n        'ly': SPEED_OF_LIGHT * SECONDS_PER_JULIAN_YEAR\n    }\n\n    # Tolerance for equality comparison, as per problem specification.\n    EQUALITY_TOLERANCE = 1e-12\n\n    class Distance:\n        \"\"\"\n        Represents a physical distance quantity, enforcing dimensional consistency.\n        All internal calculations are performed in meters.\n        \"\"\"\n        def __init__(self, value, unit):\n            \"\"\"\n            Initializes a Distance object.\n            \n            Args:\n                value (float or int): The magnitude of the distance.\n                unit (str): The unit of the distance ('m', 'ft', 'ly').\n            \n            Raises:\n                ValueError: If the unit is not one of the admissible units.\n            \"\"\"\n            if unit not in CONVERSION_FACTORS:\n                raise ValueError(f\"Unit '{unit}' is not a valid distance unit.\")\n            \n            # Store the value internally in the base unit (meters).\n            self.value_m = float(value) * CONVERSION_FACTORS[unit]\n\n        def __add__(self, other):\n            \"\"\"\n            Defines addition between two Distance objects.\n            \"\"\"\n            if not isinstance(other, Distance):\n                return NotImplemented\n            return Distance(self.value_m + other.value_m, 'm')\n\n        def __sub__(self, other):\n            \"\"\"\n            Defines subtraction between two Distance objects.\n            \"\"\"\n            if not isinstance(other, Distance):\n                return NotImplemented\n            return Distance(self.value_m - other.value_m, 'm')\n\n        def __mul__(self, other):\n            \"\"\"\n            Defines multiplication of a Distance by a scalar.\n            \"\"\"\n            if not isinstance(other, (int, float)):\n                return NotImplemented\n            return Distance(self.value_m * other, 'm')\n\n        def __rmul__(self, other):\n            \"\"\"\n            Handles right-multiplication by a scalar (e.g., 2 * distance).\n            \"\"\"\n            return self.__mul__(other)\n\n        def __eq__(self, other):\n            \"\"\"\n            Defines equality comparison based on a tolerance.\n            \"\"\"\n            if not isinstance(other, Distance):\n                return False\n            return abs(self.value_m - other.value_m) <= EQUALITY_TOLERANCE\n\n        def __repr__(self):\n            \"\"\"\n            Provides a string representation of the Distance object.\n            \"\"\"\n            return f\"Distance({self.value_m} m)\"\n\n    # List to store the results of the test suite.\n    results = []\n\n    # 1. Compute 3 m + 10 ft\n    d1 = Distance(3, 'm')\n    d2 = Distance(10, 'ft')\n    result1 = d1 + d2\n    results.append(f\"{result1.value_m:.6f}\")\n\n    # 2. Compute 1 ly - 10^16 m\n    d3 = Distance(1, 'ly')\n    d4 = Distance(1e16, 'm')\n    result2 = d3 - d4\n    results.append(f\"{result2.value_m:.6f}\")\n\n    # 3. Convert 5280 ft to meters\n    d5 = Distance(5280, 'ft')\n    result3 = d5\n    results.append(f\"{result3.value_m:.6f}\")\n\n    # 4. Determine whether 5 ft + 3 is dimensionally valid\n    # According to the rules, addition is only valid between two distances.\n    # An operation with a scalar is not valid.\n    # We check if the scalar operand is an instance of the Distance class.\n    scalar_val = 3\n    is_valid_op = isinstance(scalar_val, Distance)\n    results.append(is_valid_op)\n\n    # 5. Determine whether 1 m and 3.280839895013123 ft are equal\n    d6 = Distance(1, 'm')\n    d7 = Distance(3.280839895013123, 'ft')\n    result5 = (d6 == d7)\n    results.append(result5)\n\n    # 6. Compute 2 * (-5 ft)\n    d8 = Distance(-5, 'ft')\n    result6 = 2 * d8\n    results.append(f\"{result6.value_m:.6f}\")\n\n    # 7. Compute 0 m + 0 ft\n    d9 = Distance(0, 'm')\n    d10 = Distance(0, 'ft')\n    result7 = d9 + d10\n    results.append(f\"{result7.value_m:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2384770"}]}