{"hands_on_practices": [{"introduction": "在模拟遵守能量守恒等物理定律的系统时，数值积分方法的选择至关重要。本次实践将引导您探索哈密顿系统的长期行为，并比较通用积分器与专门设计的辛积分器的性能。通过这个练习，您将亲身体会到，为什么为特定物理结构选择合适的算法对于保证长期模拟的保真度和避免非物理性的能量漂移是何等重要。[@problem_id:2398024]", "problem": "你的任务是仅使用基本原理，为用于哈密顿动力学的积分器设计并实现一个长时间能量行为的数值诊断方法。考虑一个单自由度哈密顿系统，其广义坐标为 $q$，共轭动量为 $p$，由以下哈密顿量控制\n$$\nH(q,p) \\;=\\; \\frac{p^2}{2 m} \\;+\\; \\frac{k}{2}\\,q^2 \\;+\\; \\frac{\\lambda}{4}\\,q^4,\n$$\n其中 $m$、$k$ 和 $\\lambda$ 是正常数。其连续动力学由哈密顿方程指定\n$$\n\\dot{q} \\;=\\; \\frac{\\partial H}{\\partial p}, \n\\qquad\n\\dot{p} \\;=\\; -\\frac{\\partial H}{\\partial q}.\n$$\n在无量纲单位下，取 $m = 1$、$k = 1$ 和 $\\lambda = 1$。使用初始条件 $q(0) = 0.7$ 和 $p(0) = 0$。\n\n根据基本原理，能量是运动的一个第一积分。将初始能量记为 $H_0 = H(q(0),p(0))$。对于在总时间 $T = N h$ 内，由大小为 $h$ 的时间步长生成的离散时间数值轨迹 $\\{(q_n,p_n)\\}_{n=0}^{N}$，定义以下定量能量诊断指标：\n- 最大相对能量偏差\n$$\n\\Delta_{\\max} \\;=\\; \\max_{0 \\le n \\le N} \\frac{\\left| H(q_n,p_n) - H_0 \\right|}{\\left| H_0 \\right|}.\n$$\n- 归一化线性漂移幅度，通过最小二乘法将离散能量值 $\\{H(q_n,p_n)\\}$ 作为时间 $\\{t_n\\}$（其中 $t_n = n h$）的函数，拟合到一个仿射模型 $H(t) \\approx a + b t$ 后定义：\n$$\nD \\;=\\; \\frac{|b|}{|H_0|}.\n$$\n\n如果满足以下两个标准，则称该积分器对于此系统“在长时间尺度上能量守恒”，其阈值为 $\\varepsilon_{\\max} = 0.05$ 和 $\\varepsilon_{\\text{drift}} = 5\\times 10^{-5}$。\n$$\n\\Delta_{\\max} \\le \\varepsilon_{\\max}\n\\quad\\text{and}\\quad\nD \\le \\varepsilon_{\\text{drift}}\n$$\n\n实现一个程序，该程序在给定方法类别标志 $M \\in \\{0,1\\}$、时间步长 $h$ 和最终时间 $T$ 的情况下，执行以下操作：\n- 如果 $M = 1$，使用任何适用于形式为 $H(q,p) = T(p) + V(q)$ 的可分离哈密顿量的相容辛时间积分器来推进动力学。\n- 如果 $M = 0$，对相同的常微分方程(ODE)组，使用任何相容的显式非辛单步方法来推进动力学。\n- 在两种情况下，都计算数值轨迹，在每个时间层级上计算 $H(q_n,p_n)$，计算 $\\Delta_{\\max}$ 和 $D$，并返回一个布尔值：当且仅当上述两个标准都满足时，该值为 $\\,\\text{True}\\,$，否则为 $\\,\\text{False}\\,$。\n\n测试套件。您的程序必须运行以下五个参数集，并以指定的输出格式汇总这五个布尔值。在所有情况下，均使用相同的初始条件 $q(0) = 0.7$、$p(0) = 0$ 和参数 $m = 1$、$k = 1$、$\\lambda = 1$，最终时间为 $T = 4000$：\n- 情况 1：$(M,h,T) = (1,\\,0.02,\\,4000)$。\n- 情况 2：$(M,h,T) = (1,\\,0.05,\\,4000)$。\n- 情况 3：$(M,h,T) = (1,\\,0.10,\\,4000)$。\n- 情况 4：$(M,h,T) = (0,\\,0.02,\\,4000)$。\n- 情况 5：$(M,h,T) = (0,\\,0.05,\\,4000)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，[True,False,True,False,True]）。此问题中没有物理单位，因为所有量根据构造都是无量纲的。问题中未出现角度，因此不需要角度单位。所有答案都必须是布尔值。最终输出必须只有一行。", "solution": "该问题要求为评估特定哈密顿系统的数值积分器的长时间能量守恒性而设计和实现一个数值诊断方法。这首先需要对问题陈述进行严格验证。\n\n该问题具有科学依据、适定且客观。它涉及对一个具有哈密顿量 $H(q,p) = \\frac{p^2}{2m} + \\frac{k}{2}q^2 + \\frac{\\lambda}{4}q^4$ 的单自由度系统进行哈密顿方程的数值积分。其控制方程 $\\dot{q} = \\partial H / \\partial p$ 和 $\\dot{p} = - \\partial H / \\partial q$ 是经典力学的基本原理。参数 $m=1$、$k=1$、$\\lambda=1$ 和初始条件 $q(0)=0.7$、$p(0)=0$ 均已指定，使得问题是自洽的。诊断指标 $\\Delta_{\\max}$ 和 $D$是能量误差和漂移的标准定量度量。“能量守恒” 的标准通过数值阈值 $\\varepsilon_{\\max}=0.05$ 和 $\\varepsilon_{\\text{drift}}=5 \\times 10^{-5}$ 进行了明确定义。任务是实现一个程序，将这些诊断方法应用于由两类积分器（辛方法 $M=1$ 和非辛方法 $M=0$）生成的轨迹。此问题是计算物理学中一个有效且经典的练习。\n\n我们着手求解。所考虑的系统由具有无量纲参数 $m=1$、$k=1$ 和 $\\lambda=1$ 的哈密顿量指定：\n$$\nH(q,p) = \\frac{p^2}{2} + \\frac{q^2}{2} + \\frac{q^4}{4}.\n$$\n相应的哈密顿运动方程为：\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p} = p,\n$$\n$$\n\\dot{p} = -\\frac{\\partial H}{\\partial q} = -(q + q^3).\n$$\n该系统构成了一组两个耦合的一阶常微分方程(ODE)。对于任意初始条件 $(q_0, p_0)$，精确解轨迹 $(q(t), p(t))$ 能量守恒，即 $H(q(t),p(t))$ 对所有时间 $t$ 恒定。初始能量为 $H_0 = H(q(0), p(0)) = H(0.7, 0) = \\frac{0^2}{2} + \\frac{0.7^2}{2} + \\frac{0.7^4}{4} = 0.305025$。\n\n数值积分器在时间点 $t_n = n h$ 用离散时间序列 $(q_n, p_n)$ 来近似连续时间解。此问题的关键区别在于积分器的几何性质。\n\n对于 $M=1$ 的情况，需要一个辛积分器。这些积分器专为哈密顿系统设计，能精确保守辛2-形式，这是哈密顿流的一个基本几何性质。虽然它们不能精确保守原始哈密顿量 $H$，但它们能精确保守一个邻近的“影子”哈密顿量 $H_h = H + O(h^p)$，其中 $p$ 是方法的阶。这意味着能量误差 $|H(q_n,p_n) - H_0|$ 在指数级长的时间内保持有界，不表现出长期漂移。对于形式为 $H=T(p)+V(q)$ 的可分离哈密顿量，一个标准的选择是二阶 Störmer-Verlet (或蛙跳) 方法。我们选择其速度-Verlet 变体，对于我们的系统，其形式为：\n$$\np_{n+1/2} = p_n + \\frac{h}{2} F(q_n)\n$$\n$$\nq_{n+1} = q_n + h \\, p_{n+1/2}\n$$\n$$\np_{n+1} = p_{n+1/2} + \\frac{h}{2} F(q_{n+1})\n$$\n其中力为 $F(q) = -\\frac{dV}{dq} = -(q + q^3)$。\n\n对于 $M=0$ 的情况，需要一个相容的显式非辛单步方法。像 Runge-Kutta 族这样的标准 ODE 求解器属于这一类。虽然它们对于通用问题通常具有高精度，但它们不保持辛结构。当应用于哈密顿系统时，它们通常会引入系统性的能量漂移，使得数值能量 $H(q_n, p_n)$ 随时间长期增加或减少。我们选择经典的四阶 Runge-Kutta 方法 (RK4)，这是该类方法中广泛使用且高度精确的一员。对于 $\\mathbf{y}=[q, p]^T$ 的系统 $\\dot{\\mathbf{y}} = \\mathbf{f}(\\mathbf{y})$，其更新规则为：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n其中\n$$\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n), \\quad \\mathbf{k}_2 = \\mathbf{f}(\\mathbf{y}_n + \\frac{h}{2}\\mathbf{k}_1), \\quad \\mathbf{k}_3 = \\mathbf{f}(\\mathbf{y}_n + \\frac{h}{2}\\mathbf{k}_2), \\quad \\mathbf{k}_4 = \\mathbf{f}(\\mathbf{y}_n + h\\mathbf{k}_3).\n$$\n这里，$\\mathbf{f}(q, p) = [p, -(q+q^3)]^T$。\n\n程序的核心在于为给定的方法类型 $M$、步长 $h$ 和最终时间 $T=Nh$ 生成数值轨迹 $\\{(q_n,p_n)\\}_{n=0}^N$。生成轨迹后，计算两个指定的诊断指标。\n\n1. 最大相对能量偏差 $\\Delta_{\\max}$ 计算如下：\n$$\n\\Delta_{\\max} = \\frac{\\max_{0 \\le n \\le N} |H(q_n, p_n) - H_0|}{|H_0|}.\n$$\n这个指标衡量能量相对于其初始值的最大涨落。\n\n2. 归一化线性漂移幅度 $D$ 的计算。这需要使用最小二乘法，将能量值的时间序列 $\\{H_n = H(q_n,p_n)\\}$ 相对于时间 $\\{t_n = nh\\}$ 拟合到一个线性模型 $H(t) \\approx a + bt$。斜率 $b$ 量化了整个积分过程中的平均能量变化率。对于 $N+1$ 个数据点 $(t_n, H_n)$ 的简单线性回归，斜率 $b$ 的公式为：\n$$\nb = \\frac{(N+1) \\sum_{n=0}^N (t_n H_n) - (\\sum_{n=0}^N t_n)(\\sum_{n=0}^N H_n)}{(N+1) \\sum_{n=0}^N t_n^2 - (\\sum_{n=0}^N t_n)^2}.\n$$\n这个值可以使用标准数值库函数轻松获得。然后定义诊断指标 $D$ 为：\n$$\nD = \\frac{|b|}{|H_0|}.\n$$\n这个量是专门为检测长期漂移而设计的，而长期漂移是非辛积分器的一个特性。\n\n最后，所实现的程序对每个测试用例评估是否同时满足 $\\Delta_{\\max} \\le \\varepsilon_{\\max}$ 和 $D \\le \\varepsilon_{\\text{drift}}$ 这两个条件，并返回一个布尔结果。这5个指定测试用例的结果被汇总到一个列表中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # System parameters and thresholds are fixed as per the problem statement.\n    # m = 1, k = 1, lambda = 1.\n    # q(0) = 0.7, p(0) = 0.\n    # eps_max = 0.05, eps_drift = 5e-5.\n\n    test_cases = [\n        (1, 0.02, 4000),  # Case 1: Symplectic, h=0.02\n        (1, 0.05, 4000),  # Case 2: Symplectic, h=0.05\n        (1, 0.10, 4000),  # Case 3: Symplectic, h=0.10\n        (0, 0.02, 4000),  # Case 4: Non-symplectic, h=0.02\n        (0, 0.05, 4000),  # Case 5: Non-symplectic, h=0.05\n    ]\n\n    results = []\n    for case in test_cases:\n        M, h, T = case\n        result = run_and_diagnose(M, h, T)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef H(q, p, m, k, lambda_):\n    \"\"\"\n    Computes the Hamiltonian H(q,p).\n    \"\"\"\n    return p**2 / (2 * m) + k/2 * q**2 + lambda_/4 * q**4\n\ndef run_and_diagnose(M, h, T):\n    \"\"\"\n    Runs a single simulation and computes the energy diagnostics.\n\n    Args:\n        M (int): Method flag (1 for symplectic, 0 for non-symplectic).\n        h (float): Time step size.\n        T (float): Total integration time.\n\n    Returns:\n        bool: True if energy conservation criteria are met, False otherwise.\n    \"\"\"\n    # Parameters and initial conditions\n    m, k, lambda_ = 1.0, 1.0, 1.0\n    q0, p0 = 0.7, 0.0\n    eps_max = 0.05\n    eps_drift = 5e-5\n\n    N = int(T / h)\n    q_traj = np.zeros(N + 1)\n    p_traj = np.zeros(N + 1)\n    q_traj[0], p_traj[0] = q0, p0\n\n    # Perform the time integration\n    if M == 1:\n        # Symplectic integrator: Velocity-Verlet (Störmer-Verlet)\n        for n in range(N):\n            q, p = q_traj[n], p_traj[n]\n            force = -(k * q + lambda_ * q**3)\n            p_half = p + 0.5 * h * force\n            q_next = q + h * (p_half / m)\n            force_next = -(k * q_next + lambda_ * q_next**3)\n            p_next = p_half + 0.5 * h * force_next\n            q_traj[n+1], p_traj[n+1] = q_next, p_next\n    elif M == 0:\n        # Non-symplectic integrator: Classical Runge-Kutta 4th order (RK4)\n        def f(y_vec):\n            q, p = y_vec\n            return np.array([p / m, -(k * q + lambda_ * q**3)])\n        \n        y = np.array([q0, p0])\n        for n in range(N):\n            k1 = f(y)\n            k2 = f(y + 0.5 * h * k1)\n            k3 = f(y + 0.5 * h * k2)\n            k4 = f(y + h * k3)\n            y = y + (h / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n            q_traj[n+1], p_traj[n+1] = y\n\n    # Compute diagnostics\n    H_traj = H(q_traj, p_traj, m, k, lambda_)\n    H0 = H_traj[0]\n\n    # This problem's initial conditions ensure H0 is not zero\n    # delta_max calculation\n    delta_max = np.max(np.abs(H_traj - H0)) / np.abs(H0)\n\n    # D (drift) calculation\n    t_vals = np.linspace(0, T, N + 1)\n    # Fit H(t) = b*t + a, np.polyfit returns [b, a]\n    b, _ = np.polyfit(t_vals, H_traj, 1)\n    D = np.abs(b) / np.abs(H0)\n\n    # Check criteria\n    return delta_max <= eps_max and D <= eps_drift\n\nsolve()\n```", "id": "2398024"}, {"introduction": "本练习将挑战您从第一性原理出发，构建一个完整的计算模型来模拟声悬浮现象。您需要综合运用线性声学、流体动力学和力学中的基本控制方程，推导出实现悬浮所需的声压。这项实践完美展示了计算工程师如何将多个物理领域的理论知识相结合，以分析和设计复杂的工程系统。[@problem_id:2398034]", "problem": "您的任务是构建一个完整的、可运行的程序，用于计算在一维无粘性、无损耗流体中，利用声辐射压力悬浮一个小球形粒子所需的最小驻波声压幅值。其推导和算法必须基于线性声学和力学的第一性原理，不得假设任何最终形式的简化结果。\n\n您必须从适用于计算工程的有效控制方程和物理原理出发：\n- 使用无粘性可压缩流体的线性化动量平衡方程和连续性方程，以及适用于小幅度声学涨落的压力与密度之间的等熵关系。\n- 使用两个反向传播的平面波叠加形成驻波。\n- 使用二次声学量的时间平均原理。\n- 使用如下概念：在长波长（Rayleigh）极限下，小球体所受的时间平均声辐射力源于一个势；在驻波中，轴向力沿轴线呈正弦变化。\n- 使用牛顿引力和阿基米德原理来确定净比重。\n\n假设和建模约束：\n- 流体是无粘性、无损耗的，其平衡密度为 $\\,\\rho_0\\,$，声速为 $\\,c_0\\,$。其等熵压缩率为 $\\,\\kappa_0 = 1/(\\rho_0 c_0^2)\\,$。\n- 一个角频率为 $\\,\\omega\\,$、波数为 $\\,k\\,$ 的简谐驻波由两个等幅反向传播的平面波形成，因此瞬时声压随一个空间余弦和一个时间余弦的乘积变化，而粒子速度随一个空间正弦和一个时间正弦的乘积变化。\n- 粒子是一个半径为 $\\,a\\,$、质量密度为 $\\,\\rho_p\\,$、等熵压缩率为 $\\,\\kappa_p\\,$ 的刚性、非吸收球体，满足长波长条件 $\\,k a \\ll 1\\,$。\n- 粒子被放置在向上的时间平均声辐射力达到其最大值的轴向位置，因此您必须使用可达到的最大向上力来平衡重力。\n- 重力大小为 $\\,g\\,$ 方向向下；必须通过阿基米德原理来计入流体中的浮力。\n\n您的任务：\n1. 从线性化的动量和连续性方程，以及小幅度等熵关系出发，求得驻波的压力场和速度场，计算相关的时间平均二次声学量，并利用源于 $\\,\\kappa_p\\,$, $\\,\\kappa_0\\,$, $\\,\\rho_p\\,$ 和 $\\,\\rho_0\\,$ 的材料对比度参数，通过适用于 Rayleigh 极限 $\\,k a \\ll 1\\,$ 的势能方法，表达作用在小球体上的一维轴向辐射力。\n2. 通过包含浮力的力平衡，推导出一个显式表达式，用于计算在最大向上声学力的轴向位置上，恰好抵消粒子净重所需的最小驻波压力幅值 $\\,p_0\\,$（单位为帕斯卡）。您的最终闭式表达式必须用 $\\,\\rho_0\\,$, $\\,c_0\\,$, $\\,\\rho_p\\,$, $\\,\\kappa_p\\,$, $\\,g\\,$ 和频率 $\\,f\\,$ 表示（使用 $\\,k = 2\\pi f / c_0\\,$）。如果净比重的大小 $\\,|\\rho_p - \\rho_0|\\,$ 为零，则所需的 $\\,p_0\\,$ 为零。\n3. 实现一个程序，使用您推导的公式，为下面指定的每个测试用例计算最小 $\\,p_0\\,$。角度不是必需的。答案以帕斯卡表示，四舍五入到两位小数。\n\n测试套件（所有数值均采用国际单位制）：\n- 情况A（理想情况，空气和一种常见的固体球体）：\n  - 流体密度 $\\,\\rho_0 = 1.204\\,$ kg/m$^3$，声速 $\\,c_0 = 343.0\\,$ m/s。\n  - 粒子密度 $\\,\\rho_p = 1050.0\\,$ kg/m$^3$，粒子压缩率 $\\,\\kappa_p = 2.5\\times 10^{-10}\\,$ Pa$^{-1}$。\n  - 频率 $\\,f = 40000.0\\,$ Hz，重力 $\\,g = 9.81\\,$ m/s$^2$。\n- 情况B（低频边界情况，材料同情况A）：\n  - $\\,\\rho_0 = 1.204\\,$ kg/m$^3$，$\\,c_0 = 343.0\\,$ m/s，$\\,\\rho_p = 1050.0\\,$ kg/m$^3$，$\\,\\kappa_p = 2.5\\times 10^{-10}\\,$ Pa$^{-1}$，$\\,f = 2000.0\\,$ Hz，$\\,g = 9.81\\,$ m/s$^2$。\n- 情况C（高频情况，材料同情况A）：\n  - $\\,\\rho_0 = 1.204\\,$ kg/m$^3$，$\\,c_0 = 343.0\\,$ m/s，$\\,\\rho_p = 1050.0\\,$ kg/m$^3$，$\\,\\kappa_p = 2.5\\times 10^{-10}\\,$ Pa$^{-1}$，$\\,f = 200000.0\\,$ Hz，$\\,g = 9.81\\,$ m/s$^2$。\n- 情况D（在空气中接近中性浮力的边界情况）：\n  - $\\,\\rho_0 = 1.204\\,$ kg/m$^3$，$\\,c_0 = 343.0\\,$ m/s，$\\,\\rho_p = 1.204\\,$ kg/m$^3$，$\\,\\kappa_p = 1/(\\rho_0 c_0^2)\\,$ Pa$^{-1}$，$\\,f = 40000.0\\,$ Hz，$\\,g = 9.81\\,$ m/s$^2$。\n- 情况E（流体密度大得多，粒子属性有反差）：\n  - $\\,\\rho_0 = 1000.0\\,$ kg/m$^3$，$\\,c_0 = 1480.0\\,$ m/s。\n  - $\\,\\rho_p = 1.2\\,$ kg/m$^3$，$\\,\\kappa_p = 7.0\\times 10^{-6}\\,$ Pa$^{-1}$。\n  - $\\,f = 100000.0\\,$ Hz，$\\,g = 9.81\\,$ m/s$^2$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其顺序与上述情况相同，例如 $\\,\\left[\\text{result}_A,\\text{result}_B,\\text{result}_C,\\text{result}_D,\\text{result}_E\\right]\\,$。\n- 每个条目必须是一个浮点数，表示最小 $\\,p_0\\,$（单位为帕斯卡），四舍五入到两位小数。", "solution": "所述问题具有科学依据，提法恰当且客观。它基于既定的声学和力学原理，并为获得唯一解提供了一套完整的参数。因此，该问题被认定为有效。我们将从第一性原理出发进行求解。\n\n求解过程需要推导在一维驻波中小球形粒子所受的声辐射力，并使其与净重力（经浮力校正的重量）相平衡。\n\n首先，我们建立声场。在无损耗、无粘性流体中，声压 $p$ 的一维波动方程为：\n$$\n\\frac{\\partial^2 p}{\\partial z^2} - \\frac{1}{c_0^2} \\frac{\\partial^2 p}{\\partial t^2} = 0\n$$\n其中 $c_0$ 是平衡密度为 $\\rho_0$ 的流体中的声速。由两个等幅反向传播平面波形成的驻波解为：\n$$\np(z, t) = p_0 \\cos(kz) \\cos(\\omega t)\n$$\n这里，$p_0$ 是压力幅值，$\\omega=2\\pi f$ 是角频率，$k=\\omega/c_0$ 是波数。沿 $z$ 轴的流体质点速度 $u(z, t)$ 与压力通过线性化动量方程 $\\rho_0 \\frac{\\partial u}{\\partial t} = -\\frac{\\partial p}{\\partial z}$ 相关联：\n$$\n\\rho_0 \\frac{\\partial u}{\\partial t} = - \\frac{\\partial}{\\partial z} [p_0 \\cos(kz) \\cos(\\omega t)] = p_0 k \\sin(kz) \\cos(\\omega t)\n$$\n对时间 $t$ 积分得到速度场：\n$$\nu(z, t) = \\frac{p_0 k}{\\rho_0 \\omega} \\sin(kz) \\sin(\\omega t) = \\frac{p_0}{\\rho_0 c_0} \\sin(kz) \\sin(\\omega t)\n$$\n\n对小球形粒子（$ka \\ll 1$，其中 $a$ 是粒子半径）的时间平均声辐射力 $\\vec{F}_{rad}$ 可通过 Gor'kov 势 $U$ 由 $\\vec{F}_{rad} = -\\nabla U$ 推导得出。势 $U$ 由下式给出：\n$$\nU = V_p \\left( f_1 \\langle E_{pot} \\rangle - f_2 \\langle E_{kin} \\rangle \\right)\n$$\n其中 $V_p = \\frac{4}{3}\\pi a^3$ 是粒子体积。声场的时间平均势能密度和动能密度分别为 $\\langle E_{pot} \\rangle = \\frac{\\langle p^2 \\rangle}{2\\rho_0 c_0^2}$ 和 $\\langle E_{kin} \\rangle = \\frac{\\rho_0 \\langle u^2 \\rangle}{2}$。无量纲系数 $f_1$ 和 $f_2$ 代表对散射的单极子和偶极子贡献，并取决于粒子（压缩率 $\\kappa_p$，密度 $\\rho_p$）和流体（压缩率 $\\kappa_0$，密度 $\\rho_0$）的材料特性：\n$$\nf_1 = 1 - \\frac{\\kappa_p}{\\kappa_0} \\quad \\text{和} \\quad f_2 = \\frac{2(\\rho_p/\\rho_0 - 1)}{2\\rho_p/\\rho_0 + 1}\n$$\n流体压缩率定义为 $\\kappa_0 = 1/(\\rho_0 c_0^2)$。\n\n我们计算驻波的时间平均能量密度。$\\cos^2(\\omega t)$ 和 $\\sin^2(\\omega t)$ 在一个周期内的时间平均值为 $1/2$。\n$$\n\\langle p^2(z) \\rangle = p_0^2 \\cos^2(kz) \\langle \\cos^2(\\omega t) \\rangle = \\frac{1}{2} p_0^2 \\cos^2(kz)\n$$\n$$\n\\langle u^2(z) \\rangle = \\left(\\frac{p_0}{\\rho_0 c_0}\\right)^2 \\sin^2(kz) \\langle \\sin^2(\\omega t) \\rangle = \\frac{p_0^2}{2(\\rho_0 c_0)^2} \\sin^2(kz)\n$$\n将这些代入能量密度表达式：\n$$\n\\langle E_{pot}(z) \\rangle = \\frac{p_0^2}{4\\rho_0 c_0^2} \\cos^2(kz)\n$$\n$$\n\\langle E_{kin}(z) \\rangle = \\frac{\\rho_0}{2} \\left( \\frac{p_0^2}{2(\\rho_0 c_0)^2} \\sin^2(kz) \\right) = \\frac{p_0^2}{4\\rho_0 c_0^2} \\sin^2(kz)\n$$\n由其他作者从基本散射理论推导出的 Gor'kov 势，其动能项包含了不同的加权因子。适用于本问题的正确势形式为：\n$$\nU(z) = V_p \\left(f_1 \\frac{\\langle p^2 \\rangle}{2\\rho_0 c_0^2} - f_2 \\frac{3\\rho_0 \\langle u^2 \\rangle}{4} \\right) = V_p \\frac{p_0^2}{4\\rho_0 c_0^2} \\left[ f_1 \\cos^2(kz) - \\frac{3}{2}f_2 \\sin^2(kz) \\right]\n$$\n轴向辐射力 $F_{rad,z}$ 是该势的负梯度：\n$$\nF_{rad,z}(z) = -\\frac{dU}{dz} = -V_p \\frac{p_0^2}{4\\rho_0 c_0^2} \\frac{d}{dz} \\left[ f_1 \\cos^2(kz) - \\frac{3}{2}f_2 \\sin^2(kz) \\right]\n$$\n使用恒等式 $\\frac{d}{dz}\\cos^2(kz) = -k\\sin(2kz)$ 和 $\\frac{d}{dz}\\sin^2(kz) = k\\sin(2kz)$，我们得到：\n$$\nF_{rad,z}(z) = -V_p \\frac{p_0^2}{4\\rho_0 c_0^2} \\left[ -f_1 k \\sin(2kz) - \\frac{3}{2}f_2 k \\sin(2kz) \\right]\n$$\n$$\nF_{rad,z}(z) = V_p \\frac{p_0^2 k}{4\\rho_0 c_0^2} \\left( f_1 + \\frac{3}{2}f_2 \\right) \\sin(2kz)\n$$\n该力沿 $z$ 轴呈正弦变化。为了悬浮粒子，我们必须用可用的最大向上声学力来平衡其净重。辐射力的最大值为：\n$$\n|F_{rad,max}| = V_p \\frac{p_0^2 k}{4\\rho_0 c_0^2} \\left| f_1 + \\frac{3}{2}f_2 \\right|\n$$\n\n粒子的净重是引力 $F_g = m_p g = \\rho_p V_p g$ 减去浮力 $F_b = \\rho_0 V_p g$：\n$$\nF_{net,w} = (\\rho_p - \\rho_0) g V_p\n$$\n为了悬浮，我们令力的大小相等：$|F_{rad,max}| = |F_{net,w}|$。\n$$\nV_p \\frac{p_0^2 k}{4\\rho_0 c_0^2} \\left| f_1 + \\frac{3}{2}f_2 \\right| = |\\rho_p - \\rho_0| g V_p\n$$\n粒子体积 $V_p$ 从两侧消去，证实了解与粒子半径 $a$ 无关。\n$$\n\\frac{p_0^2 k}{4\\rho_0 c_0^2} \\left| f_1 + \\frac{3}{2}f_2 \\right| = |\\rho_p - \\rho_0| g\n$$\n我们求解压力幅值 $p_0$。如果 $|\\rho_p - \\rho_0| = 0$，则 $p_0 = 0$。否则：\n$$\np_0^2 = \\frac{4 g \\rho_0 c_0^2 |\\rho_p - \\rho_0|}{k \\left| f_1 + \\frac{3}{2}f_2 \\right|}\n$$\n代入 $k = 2\\pi f / c_0$：\n$$\np_0^2 = \\frac{4 g \\rho_0 c_0^2 |\\rho_p - \\rho_0|}{(2\\pi f / c_0) \\left| f_1 + \\frac{3}{2}f_2 \\right|} = \\frac{2 g \\rho_0 c_0^3 |\\rho_p - \\rho_0|}{\\pi f \\left| f_1 + \\frac{3}{2}f_2 \\right|}\n$$\n悬浮所需的最小压力幅值为：\n$$\np_0 = \\sqrt{\\frac{2 g \\rho_0 c_0^3 |\\rho_p - \\rho_0|}{\\pi f \\left| 1 - \\kappa_p \\rho_0 c_0^2 + \\frac{3}{2} \\left( \\frac{2(\\rho_p/\\rho_0 - 1)}{2\\rho_p/\\rho_0 + 1} \\right) \\right|}}\n$$\n这就是需要实现的最终表达式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the minimum standing-wave acoustic pressure amplitude required\n    to levitate a small spherical particle, based on derived first principles.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each tuple contains: (rho_0, c_0, rho_p, kappa_p, f, g)\n    test_cases = [\n        # Case A: happy path, air and a common solid sphere\n        (1.204, 343.0, 1050.0, 2.5e-10, 40000.0, 9.81),\n        # Case B: low frequency boundary, same materials as Case A\n        (1.204, 343.0, 1050.0, 2.5e-10, 2000.0, 9.81),\n        # Case C: high frequency, same materials as Case A\n        (1.204, 343.0, 1050.0, 2.5e-10, 200000.0, 9.81),\n        # Case D: nearly neutral buoyancy boundary in air\n        (1.204, 343.0, 1.204, 1/(1.204 * 343.0**2), 40000.0, 9.81),\n        # Case E: fluid with much larger density, contrasting particle properties\n        (1000.0, 1480.0, 1.2, 7.0e-6, 100000.0, 9.81),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        rho_0, c_0, rho_p, kappa_p, f, g = case\n\n        rho_diff_abs = abs(rho_p - rho_0)\n\n        # If densities are equal, net weight is zero, so no pressure is needed.\n        if np.isclose(rho_diff_abs, 0.0):\n            p0 = 0.0\n        else:\n            # Fluid compressibility\n            kappa_0 = 1.0 / (rho_0 * c_0**2)\n            \n            # Monopole scattering coefficient (compressibility contrast)\n            f1 = 1.0 - (kappa_p / kappa_0)\n            \n            # Dipole scattering coefficient (density contrast)\n            rho_ratio = rho_p / rho_0\n            f2 = (2.0 * (rho_ratio - 1.0)) / (2.0 * rho_ratio + 1.0)\n            \n            # Acoustic contrast factor (overall force characteristic)\n            phi = f1 + 1.5 * f2\n            \n            # If phi is zero, the particle is acoustically transparent.\n            # The required pressure would be infinite. This case is not expected.\n            if np.isclose(phi, 0.0):\n                p0 = np.inf\n            else:\n                # Numerator of the p0^2 expression\n                numerator = 2.0 * g * rho_0 * c_0**3 * rho_diff_abs\n                \n                # Denominator of the p0^2 expression\n                denominator = np.pi * f * abs(phi)\n                \n                p0_squared = numerator / denominator\n                p0 = np.sqrt(p0_squared)\n        \n        results.append(p0)\n\n    # Format the final output string as specified\n    # e.g., [result_A,result_B,result_C,...] with 2 decimal places.\n    formatted_results = [f\"{res:.2f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2398034"}, {"introduction": "计算工程不仅限于根据已知条件进行预测，还常常涉及根据观测结果反推未知原因，即所谓的“逆问题”。本次实践将带您进入这个富有挑战性的领域，您将利用杆中点的温度测量数据，结合热传导方程，来重构其初始温度分布。您将学习如何处理逆问题的“不适定性”，并应用正则化等关键技术来获得稳定且有物理意义的解。[@problem_id:2398006]", "problem": "您会得到一个符合能量守恒和傅里叶热传导定律的一维热传导逆问题。一根长度为 $L$ 的均匀金属棒，其两端始终保持零温度，其热演化遵循一维热方程。其控制偏微分方程 (PDE) 为\n$$\n\\frac{\\partial T}{\\partial t}(x,t) = \\alpha \\frac{\\partial^2 T}{\\partial x^2}(x,t), \\quad 0 < x < L,\\ t > 0,\n$$\n边界条件为\n$$\nT(0,t)=0,\\quad T(L,t)=0,\\quad t>0,\n$$\n以及未知的初始温度分布\n$$\nT(x,0) = T_0(x), \\quad 0 < x < L.\n$$\n此处，$T$ 是温度（单位 K），$x$ 是位置（单位 m），$t$ 是时间（单位 s），$\\alpha$ 是热扩散率（单位 m²/s）。仅测量了中点位置的温度随时间变化的历史数据：\n$$\ny(t_i) = T(L/2, t_i), \\quad i=1,\\dots,m.\n$$\n假设该金属棒是均匀的，具有恒定的 $\\alpha$，且无内部热源。您必须通过假设初始温度 $T_0(x)$ 位于满足边界条件的前 $M$ 个奇正弦本征函数的张成空间中，来重构其近似解：\n$$\nT_0(x) \\approx \\sum_{k=0}^{M-1} b_{2k+1} \\sin\\!\\left(\\frac{(2k+1)\\pi x}{L}\\right),\n$$\n其中，未知系数 $b_{2k+1}$（单位 K）需要通过中点测量值 $y(t_i)$ 来确定。使用一个基于控制方程和边界条件推导出的系统性方法，将 $y(t)$ 表示为未知系数和已知参数的函数，然后构建并求解一个线性逆问题来估计 $b_{2k+1}$。由于此逆问题是病态的，必要时使用带有吉洪诺夫正则化的线性最小二乘法：\n$$\n\\min_{\\mathbf{b}} \\ \\|A\\mathbf{b} - \\mathbf{y}\\|_2^2 + \\lambda_{\\mathrm{reg}}^2 \\|\\mathbf{b}\\|_2^2,\n$$\n其中 $A$ 是从物理原理推导出的设计矩阵，$\\mathbf{b}$ 是未知系数向量 $[b_1,b_3,\\dots,b_{2M-1}]^\\top$，$\\mathbf{y}$ 汇总了测量数据，而 $\\lambda_{\\mathrm{reg}} \\ge 0$ 是正则化参数。\n\n请实现一个完整且可运行的程序，针对下方的测试套件，重构每种情况下的奇正弦系数向量。每个系数以 K 为单位表示，并四舍五入到三位小数。任何三角函数求值中的角度都必须按弧度制解释。\n\n测试套件（每个案例提供长度 $L$ (m)、热扩散率 $\\alpha$ (m²/s)、时间网格 (s)、测量的中点温度 (K)、奇模态数 $M$ 以及正则化参数 $\\lambda_{\\mathrm{reg}}$）：\n- 案例A（理想路径，单模态，无噪声）：\n  - $L = 1.0\\ \\mathrm{m}$，$\\alpha = 1.0\\times 10^{-4}\\ \\mathrm{m^2/s}$，\n  - 时间 $t = [0, 100, 300, 500]\\ \\mathrm{s}$，\n  - 测量值 $y = [10.00000, 9.06018, 7.43722, 6.10497]\\ \\mathrm{K}$，\n  - $M=1$，\n  - $\\lambda_{\\mathrm{reg}} = 0.0$。\n- 案例B（两个可辨识模态，无噪声）：\n  - $L = 1.0\\ \\mathrm{m}$，$\\alpha = 1.0\\times 10^{-4}\\ \\mathrm{m^2/s}$，\n  - 时间 $t = [0, 50, 200, 500]\\ \\mathrm{s}$，\n  - 测量值 $y = [6.00000, 7.57583, 8.83511, 7.25528]\\ \\mathrm{K}$，\n  - $M=2$，\n  - $\\lambda_{\\mathrm{reg}} = 0.0$。\n- 案例C（三模态，含噪数据，不同杆属性）：\n  - $L = 0.8\\ \\mathrm{m}$，$\\alpha = 7.0\\times 10^{-5}\\ \\mathrm{m^2/s}$，\n  - 时间 $t = [0, 40, 120, 240, 400]\\ \\mathrm{s}$，\n  - 测量值 $y = [4.01230, 3.42575, 3.55080, 3.55920, 3.19240]\\ \\mathrm{K}$，\n  - $M=3$，\n  - $\\lambda_{\\mathrm{reg}} = 1.0\\times 10^{-3}$。\n- 案例D（边缘案例：不可观测的偶模态，零信号）：\n  - $L = 1.0\\ \\mathrm{m}$，$\\alpha = 1.0\\times 10^{-4}\\ \\mathrm{m^2/s}$，\n  - 时间 $t = [0, 10, 20, 50, 100]\\ \\mathrm{s}$，\n  - 测量值 $y = [0.0, 0.0, 0.0, 0.0, 0.0]\\ \\mathrm{K}$，\n  - $M=3$，\n  - $\\lambda_{\\mathrm{reg}} = 0.0$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有案例的结果列表。每个案例的结果是重构的奇系数 $[b_1,b_3,\\dots,b_{2M-1}]$（单位 K）的列表，每个系数四舍五入到三位小数。例如，\n$[[b_{1}^{(A)},b_{3}^{(A)},\\dots],[b_{1}^{(B)},b_{3}^{(B)},\\dots],\\dots]$,\n每个案例的内部列表长度截断为 $M$。程序必须严格按照此格式打印一行。", "solution": "所提出的问题是一个有效的一维热传导逆问题。它在科学上基于傅里叶定律和能量守恒原理，这些原理被概括在一维热方程中。该问题通过指定一种标准的正则化技术来处理逆问题固有的病态性，从而使其适于进行数值求解。所有必要的参数和数据均已提供，且目标定义清晰，没有歧义。\n\n任务是重构长度为 $L$ 的均匀杆的初始温度分布 $T_0(x)$。温度演化由以下偏微分方程（PDE）控制：\n$$\n\\frac{\\partial T}{\\partial t}(x,t) = \\alpha \\frac{\\partial^2 T}{\\partial x^2}(x,t), \\quad \\text{for } x \\in (0, L) \\text{ and } t > 0\n$$\n其齐次狄利克雷边界条件为：\n$$\nT(0,t) = 0, \\quad T(L,t) = 0, \\quad \\text{for } t > 0\n$$\n可以使用分离变量法求得该边界值问题的一般解。它表示为一个傅里叶正弦级数：\n$$\nT(x,t) = \\sum_{n=1}^{\\infty} c_n \\sin\\left(\\frac{n\\pi x}{L}\\right) e^{-\\alpha \\left(\\frac{n\\pi}{L}\\right)^2 t}\n$$\n系数 $c_n$ 由初始条件 $T(x,0) = T_0(x)$ 确定，此时级数变为：\n$$\nT_0(x) = \\sum_{n=1}^{\\infty} c_n \\sin\\left(\\frac{n\\pi x}{L}\\right)\n$$\n问题陈述 $T_0(x)$ 将通过前 $M$ 个奇正弦本征函数的有限和来近似：\n$$\nT_0(x) \\approx \\sum_{k=0}^{M-1} b_{2k+1} \\sin\\left(\\frac{(2k+1)\\pi x}{L}\\right)\n$$\n通过将此近似值与初始条件的一般形式进行比较，我们将傅里叶系数 $c_n$ 与未知系数 $b_{2k+1}$ 对应起来。具体而言，我们假设对于 $k \\in \\{0, 1, \\dots, M-1\\}$，有 $c_{2k+1} = b_{2k+1}$，并且所有其他系数，包括所有偶数下标的系数 $c_{2k}$，均为零。这是一个合理的假设，因为任何偶模态 $\\sin(\\frac{2k\\pi x}{L})$ 在中点 $x=L/2$ 处均为零，因此这些模态无法通过中点测量观测到。\n\n将此近似代入 $T(x,t)$ 的时变解中，我们得到：\n$$\nT(x,t) \\approx \\sum_{k=0}^{M-1} b_{2k+1} \\sin\\left(\\frac{(2k+1)\\pi x}{L}\\right) e^{-\\alpha \\left(\\frac{(2k+1)\\pi}{L}\\right)^2 t}\n$$\n可用数据包括在离散时间 $t_i$（其中 $i \\in \\{1, \\dots, m\\}$）下，于杆的中点 $x = L/2$ 处的温度测量值 $y(t_i)$。在 $x=L/2$ 处计算我们的近似解可得：\n$$\ny(t_i) = T(L/2, t_i) \\approx \\sum_{k=0}^{M-1} b_{2k+1} \\sin\\left(\\frac{(2k+1)\\pi (L/2)}{L}\\right) e^{-\\alpha \\left(\\frac{(2k+1)\\pi}{L}\\right)^2 t_i}\n$$\n正弦项可简化为：\n$$\n\\sin\\left(\\frac{(2k+1)\\pi}{2}\\right) = (-1)^k\n$$\n这给出了测量值 $y(t_i)$ 与未知系数 $b_{2k+1}$ 之间的直接关系：\n$$\ny(t_i) \\approx \\sum_{k=0}^{M-1} (-1)^k b_{2k+1} e^{-\\alpha \\left(\\frac{(2k+1)\\pi}{L}\\right)^2 t_i}\n$$\n这构成了一个包含 $M$ 个未知系数的 $m$ 个线性方程组。设系数向量为 $\\mathbf{b} = [b_1, b_3, \\dots, b_{2M-1}]^\\top$，测量向量为 $\\mathbf{y} = [y(t_1), y(t_2), \\dots, y(t_m)]^\\top$。该方程组可以写成矩阵形式 $A\\mathbf{b} \\approx \\mathbf{y}$。设计矩阵 $A$ 是一个 $m \\times M$ 矩阵，其中元素 $A_{ij}$（对应第 $i$ 个时间点和第 $j$ 个模态，其中 $j=k+1$）是系数 $b_{2j-1}$ 的乘数：\n$$\nA_{ij} = (-1)^{j-1} e^{-\\alpha \\left(\\frac{(2j-1)\\pi}{L}\\right)^2 t_i}\n$$\n其中 $i \\in \\{1, \\dots, m\\}$ 且 $j \\in \\{1, \\dots, M\\}$。\n\n为了求得系数向量 $\\mathbf{b}$，我们必须解这个线性系统。如前所述，这个逆问题通常是病态的，意味着测量向量 $\\mathbf{y}$ 中的小误差可能导致解 $\\mathbf{b}$ 发生巨大变化。采用吉洪诺夫正则化，通过增加一个与解向量的欧几里得范数平方成正比的惩罚项来稳定解。因此，问题转化为找到使以下目标函数最小化的 $\\mathbf{b}$：\n$$\n\\min_{\\mathbf{b}} \\|A\\mathbf{b} - \\mathbf{y}\\|_2^2 + \\lambda_{\\mathrm{reg}}^2 \\|\\mathbf{b}\\|_2^2\n$$\n其中 $\\lambda_{\\mathrm{reg}} \\ge 0$ 是正则化参数。此正则化最小二乘问题的解由正规方程给出：\n$$\n(A^\\top A + \\lambda_{\\mathrm{reg}}^2 I) \\mathbf{b} = A^\\top \\mathbf{y}\n$$\n其中 $I$ 是 $M \\times M$ 单位矩阵。为了数值稳定性，最好避免直接计算 $A^\\top A$。一种更稳定的方法是求解一个等价的增广系统上的标准最小二乘问题。我们定义一个增广矩阵 $\\tilde{A}$ 和一个增广测量向量 $\\tilde{\\mathbf{y}}$：\n$$\n\\tilde{A} = \\begin{pmatrix} A \\\\ \\lambda_{\\mathrm{reg}} I \\end{pmatrix}, \\quad \\tilde{\\mathbf{y}} = \\begin{pmatrix} \\mathbf{y} \\\\ \\mathbf{0} \\end{pmatrix}\n$$\n其中 $\\mathbf{0}$ 是一个长度为 $M$ 的零向量。原始的最小化问题等价于最小化 $\\|\\tilde{A}\\mathbf{b} - \\tilde{\\mathbf{y}}\\|_2^2$。这是一个标准的线性最小二乘问题，可以使用数值库进行稳健求解。这个单一框架可以正确处理正则化（$\\lambda_{\\mathrm{reg}} > 0$）和非正则化（$\\lambda_{\\mathrm{reg}} = 0$）两种情况。\n\n对于每个测试案例，实现将按以下步骤进行：\n1. 根据给定的参数 $L$、$\\alpha$ 和时间网格 $t_i$ 构建 $m \\times M$ 矩阵 $A$。\n2. 使用正则化参数 $\\lambda_{\\mathrm{reg}}$ 构建增广矩阵 $\\tilde{A}$ 和增广向量 $\\tilde{\\mathbf{y}}$。\n3. 求解线性最小二乘问题 $\\tilde{A}\\mathbf{b} \\approx \\tilde{\\mathbf{y}}$ 以找到系数向量 $\\mathbf{b}$。\n4. 将所得系数四舍五入到三位小数，并收集它们用于最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef reconstruct_coefficients(L, alpha, times, measurements, M, lambda_reg):\n    \"\"\"\n    Reconstructs the initial temperature distribution coefficients from midpoint measurements.\n\n    Args:\n        L (float): Length of the bar in meters.\n        alpha (float): Thermal diffusivity in m^2/s.\n        times (list or np.ndarray): Measurement times in seconds.\n        measurements (list or np.ndarray): Measured temperatures at the midpoint in Kelvin.\n        M (int): Number of odd sine modes to use for the approximation.\n        lambda_reg (float): Tikhonov regularization parameter.\n\n    Returns:\n        list: A list of the reconstructed coefficients [b_1, b_3, ...], rounded to three decimals.\n    \"\"\"\n    times = np.asarray(times)\n    measurements = np.asarray(measurements)\n    m = len(times)\n\n    # Construct the design matrix A\n    A = np.zeros((m, M))\n    for i in range(m):  # Loop over time points\n        for j in range(M):  # Loop over odd modes (k=j in the formula)\n            mode_index = 2 * j + 1\n            sine_term = (-1)**j\n            exponent = -alpha * (mode_index * np.pi / L)**2 * times[i]\n            A[i, j] = sine_term * np.exp(exponent)\n\n    # Solve the regularized least squares problem using an augmented system\n    # This is numerically more stable than forming A.T @ A\n    A_aug = np.vstack((A, np.eye(M) * lambda_reg))\n    y_aug = np.concatenate((measurements, np.zeros(M)))\n\n    # Use numpy's least squares solver\n    b, _, _, _ = np.linalg.lstsq(A_aug, y_aug, rcond=None)\n\n    # Round the results to three decimal places\n    return np.round(b, 3).tolist()\n\ndef solve():\n    \"\"\"\n    Runs the reconstruction for all test cases and prints the results in the required format.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {\n            \"L\": 1.0, \"alpha\": 1.0e-4, \"times\": [0, 100, 300, 500],\n            \"y\": [10.00000, 9.06018, 7.43722, 6.10497],\n            \"M\": 1, \"lambda_reg\": 0.0\n        },\n        # Case B\n        {\n            \"L\": 1.0, \"alpha\": 1.0e-4, \"times\": [0, 50, 200, 500],\n            \"y\": [6.00000, 7.57583, 8.83511, 7.25528],\n            \"M\": 2, \"lambda_reg\": 0.0\n        },\n        # Case C\n        {\n            \"L\": 0.8, \"alpha\": 7.0e-5, \"times\": [0, 40, 120, 240, 400],\n            \"y\": [4.01230, 3.42575, 3.55080, 3.55920, 3.19240],\n            \"M\": 3, \"lambda_reg\": 1.0e-3\n        },\n        # Case D\n        {\n            \"L\": 1.0, \"alpha\": 1.0e-4, \"times\": [0, 10, 20, 50, 100],\n            \"y\": [0.0, 0.0, 0.0, 0.0, 0.0],\n            \"M\": 3, \"lambda_reg\": 0.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        coeffs = reconstruct_coefficients(\n            L=case[\"L\"],\n            alpha=case[\"alpha\"],\n            times=case[\"times\"],\n            measurements=case[\"y\"],\n            M=case[\"M\"],\n            lambda_reg=case[\"lambda_reg\"]\n        )\n        results.append(coeffs)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2398006"}]}