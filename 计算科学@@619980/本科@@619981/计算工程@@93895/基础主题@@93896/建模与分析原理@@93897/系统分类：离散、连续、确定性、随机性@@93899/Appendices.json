{"hands_on_practices": [{"introduction": "我们常用优美的连续模型，如常微分方程（ODEs），来描述物理现象。但是，当我们将这些模型转化为代码并在本质上是离散的数字计算机上运行时，会发生什么呢？本练习要求你分析*仿真*系统的分类，揭示由于数值积分和有限精度算术所引起的关键转变。[@problem_id:2441632] 理解这种差异对于正确解释任何计算机仿真结果至关重要。", "problem": "一个物理过程由一个确定性常微分方程（ODE）建模，其形式为 $\\dot{x}(t)=f(x(t),t)$，其中状态为 $x(t)\\in\\mathbb{R}^{n}$，右端函数 $f:\\mathbb{R}^{n}\\times\\mathbb{R}\\to\\mathbb{R}^{n}$ 是光滑的。该模型在数字计算机上使用固定步长 $h>0$ 的数值积分器进行仿真。该实现使用有限精度算术，每个状态分量的字长固定为 $b$ 位，并对每次算术运算采用确定性舍入规则。算法在时间点 $t_{k}=t_{0}+k h$ 产生一个序列 $\\{x_{k}\\}_{k=0}^{\\infty}$，其中 $x_{k}\\in\\mathbb{R}^{n}$ 并被存储在机器可表示的浮点向量集合中。在该实现中，任何地方都没有使用随机数或随机化程序，并且初始条件 $x_{0}$ 是精确可表示的。\n\n下列哪项最能描述此实现所产生的仿真系统？\n\nA. 离散时间、离散状态、确定性\n\nB. 离散时间、离散状态、随机性\n\nC. 连续时间、离散状态、确定性\n\nD. 连续时间、连续状态、确定性\n\nE. 离散时间、连续状态、确定性", "solution": "首先将验证问题陈述的科学合理性、自洽性和清晰性。\n\n**第1步：提取已知信息**\n- 物理过程由一个确定性常微分方程（ODE）建模：$\\dot{x}(t)=f(x(t),t)$。\n- 状态是 $\\mathbb{R}^{n}$ 中的一个向量：$x(t)\\in\\mathbb{R}^{n}$。\n- 右端函数 $f$ 是光滑的：$f:\\mathbb{R}^{n}\\times\\mathbb{R}\\to\\mathbb{R}^{n}$。\n- 模型在数字计算机上进行仿真。\n- 使用固定步长 $h>0$ 的数值积分器。\n- 实现使用有限精度算术，每个状态分量的字长固定为 $b$ 位。\n- 对每次算术运算都使用确定性舍入规则。\n- 算法在离散时间点 $t_{k}=t_{0}+k h$ 产生一个状态序列 $\\{x_{k}\\}_{k=0}^{\\infty}$。\n- 计算得到的状态 $x_{k}$ 属于机器可表示的浮点向量集合。\n- 没有使用随机数或随机化程序。\n- 初始条件 $x_{0}$ 是精确可表示的。\n\n**第2步：使用提取的已知信息进行验证**\n问题陈述描述了计算科学中的一个标准场景：在数字计算机上对ODE进行数值求解。\n- **科学依据：** 该问题基于微分方程、数值分析和计算机算术的基本概念。这是一个现实且公认的问题。没有违反任何科学原理。\n- **适定性：** 问题要求对*仿真系统*进行分类。所提供的信息对于进行此分类是充分且必要的。问题没有歧义。\n- **客观性：** 语言正式且精确。没有主观或带有偏见的陈述。\n\n**第3步：结论与行动**\n问题陈述是有效的。这是一个适定的、有科学依据的问题。我将继续进行解答。\n\n此分析需要根据三个特性对*仿真系统*进行分类：其时域、其状态空间以及其确定性或随机性。问题不是关于原始的ODE模型，而是关于其在数字计算机上的实现。\n\n**1. 时域分类（离散时间 vs. 连续时间）**\n原始的ODE $\\dot{x}(t)=f(x(t),t)$ 是一个连续时间系统，因为自变量 $t$ 是一个实数，$t \\in \\mathbb{R}$。然而，仿真是使用固定步长 $h>0$ 的数值积分器进行的。系统的状态仅在离散的时间点 $t_k = t_0 + k h$（其中 $k = 0, 1, 2, \\dots$）上计算和获知。系统的演化被描述为一个状态序列 $\\{x_k\\}$。因此，仿真系统的时域是一个离散集合。\n因此，仿真系统是**离散时间**的。\n\n**2. 状态空间分类（离散状态 vs. 连续状态）**\n原始ODE的状态 $x(t)$ 属于 $\\mathbb{R}^n$，这是一个连续状态空间。相比之下，仿真是在数字计算机上使用有限精度算术进行的，每个状态分量的字长固定为 $b$ 位。有限数量的比特只能表示一个有限的不同数值的集合。对于状态向量的每个分量，存在一个有限（尽管可能非常大）数量的可表示值。因此，计算机可以存储和表示的可能状态向量 $\\{x_k\\}$ 的总数也是有限的。其状态空间为有限（或可数无限）集合的系统被归类为离散状态系统。\n因此，仿真系统是**离散状态**的。\n\n**3. 行为分类（确定性 vs. 随机性）**\n如果一个系统的未来状态由其当前状态和输入唯一确定，则该系统是确定性的。如果在其演化过程中存在随机性因素，则它是随机性的。问题陈述提供了几个关键信息：\n- 原始ODE模型是确定性的。\n- 数值积分算法是一个确定性过程。\n- 每次算术运算后应用的舍入规则被明确说明是确定性的。\n- 在实现的任何地方都没有使用随机数或随机化程序。\n- 初始条件 $x_0$ 是一个固定的、精确可表示的值。\n给定一个特定的初始状态 $x_0$，后续状态 $x_1$ 由积分器和舍入规则唯一计算得出。这个过程对所有后续状态重复进行。整个轨迹 $\\{x_k\\}_{k=0}^{\\infty}$ 由初始条件 $x_0$ 和算法唯一且可重复地确定。不存在任何随机性来源。\n因此，仿真系统是**确定性**的。\n\n**分析结论**\n如上所述，该仿真系统是离散时间、离散状态和确定性的。\n\n**选项评估**\n\n**A. 离散时间、离散状态、确定性**\n这个分类与我们的分析完全一致。\n- **离散时间：** 正确，因为固定步长积分器在时间点 $t_k = t_0 + k h$ 提供解。\n- **离散状态：** 正确，因为数字计算机使用有限精度算术。\n- **确定性：** 正确，因为算法、舍入规则和初始条件都是确定性的。\n**结论：正确。**\n\n**B. 离散时间、离散状态、随机性**\n- **随机性：** 这是不正确的。问题明确指出仿真的所有组成部分，包括舍入规则，都是确定性的。\n**结论：不正确。**\n\n**C. 连续时间、离散状态、确定性**\n- **连续时间：** 这是不正确的。仿真以离散时间步长运行。\n**结论：不正确。**\n\n**D. 连续时间、连续状态、确定性**\n这个选项正确地描述了原始的数学ODE模型 $\\dot{x}(t)=f(x(t),t)$，但没有描述由数字计算机上的实现所产生的*仿真系统*。\n- **连续时间：** 对仿真而言不正确。\n- **连续状态：** 对使用有限精度的仿真而言不正确。\n**结论：不正确。**\n\n**E. 离散时间、连续状态、确定性**\n- **连续状态：** 这是不正确的。具有有限字长的数字计算机无法表示连续状态空间；可表示数值的集合是有限的，因此是离散的。\n**结论：不正确。**\n\n唯一正确分类该仿真系统的选项是 A。", "answer": "$$\\boxed{A}$$", "id": "2441632"}, {"introduction": "许多计算方法，从蒙特卡洛模拟到程序化内容生成，都依赖于“随机性”的来源。然而，计算机是确定性的机器。本练习通过检验计算随机性的核心工具——伪随机数生成器（PRNG），来解决这一悖论。[@problem_id:2441708] 你将探索PRNG的双重性质，区分其理论上确定性的算法本质与在实践中作为随机过程模型的应用——这对任何仿真从业者来说都是一个至关重要的洞见。", "problem": "一个伪随机数生成器 (PRNG)，例如 Mersenne Twister (MT19937)，被实现为一个有状态算法，一旦用一个整数 $s_0$ 作为种子，它就会在由 $k=0,1,2,\\dots$ 索引的离散调用中更新一个内部状态 $x_k$ 并产生输出 $y_k$。更新和输出规则是固定的，不随时间或输出本身而改变，唯一的依赖关系是通过内部状态。在数值模拟的典型应用中，原始整数输出被映射为 $u_k=y_k/2^{32}\\in[0,1)$ 以用作浮点输入流，而播种可以通过读取系统时钟或分析师未观察到的其他外部源来完成。从计算工程中系统分类的角度来看，请考虑离散与连续（在时间和状态上）以及确定性与随机性这些维度。\n\n哪一个选项最能从理论和实践两个角度，描述该生成器是确定性的还是随机性的，以及是离散的还是连续的？\n\nA. 理论上，该生成器是一个确定性的、离散时间的、离散状态的系统：对于给定的种子 $s_0$，整个序列 $\\{x_k,y_k,u_k\\}$ 是唯一确定的，具有有限的状态空间和周期（对于 MT19937，周期为 $2^{19937}-1$）。实践上，如果种子未知并且是由外部熵源（例如，系统时钟中的计时不确定性）产生的，那么输出可以被建模为一个随机过程，近似于在 $[0,1)$ 的一个有限子集上的独立同分布 (i.i.d.) 均匀样本；任何随机性都源于外部播种，而非生成器的更新规则。\n\nB. 理论上，该生成器是随机的，因为其输出通过了随机性统计检验；实践上，它是确定性的，因为如果种子被记录下来，就可以复现一次运行。\n\nC. 理论上，该生成器是确定性的；实践上，即使种子是固定的，它本质上也是随机的，因为不可预测性意味着随机性。\n\nD. 理论上和实践上，该生成器都是随机和连续的，因为将 $y_k$ 映射到 $u_k\\in[0,1)$ 会产生实值输出。\n\nE. 理论上，该生成器是确定性的和连续时间的（可以在任何时间查询）；实践上，它是随机的但状态是离散的。", "solution": "必须首先验证问题陈述的科学性和逻辑完整性。\n\n### 步骤 1：提取已知信息\n问题描述了一个伪随机数生成器 (PRNG)，特别提到了 Mersenne Twister (MT19937)，它具有以下性质：\n- 它是一个有状态算法。\n- 它由一个整数种子 $s_0$ 初始化。\n- 它在由 $k=0,1,2,\\dots$ 索引的离散调用中更新内部状态 $x_k$。\n- 它在这些离散调用中产生输出 $y_k$。\n- 更新和输出规则是固定的。\n- 规则仅依赖于内部状态。\n- 原始整数输出 $y_k$ 被映射为浮点数 $u_k=y_k/2^{32} \\in [0,1)$。\n- 播种可以从外部未观察到的源（如系统时钟）完成。\n- 任务是从理论和实践的角度，根据离散与连续（时间和状态）以及确定性与随机性这些维度对该系统进行分类。\n\n### 步骤 2：使用提取的已知信息进行验证\n对提供的问题陈述进行验证。\n\n- **科学依据**：对 PRNG 的描述是完全准确的。Mersenne Twister 是一种著名的算法，其特性——作为一个确定性状态机，具有巨大的周期 ($2^{19937}-1$)，能产生被设计为具有良好随机性统计特性的序列——都得到了正确的陈述。确定性算法与其在模拟随机现象中的实际应用之间的区别是计算科学和模拟中的一个基本概念。该问题基于计算机科学和数学的既定原则。\n- **良构的 (Well-Posed)**：该问题是良构的。它要求基于清晰且标准的描述，对一个系统的特性进行最佳描述。通过提及固定的算法规则和未知的播种可能性，提供了区分“理论”和“实践”观点所需的必要背景。进行唯一且有意义的分析是可能的。\n- **客观性**：语言精确、技术性强，并且没有主观或含糊的术语。\n\n问题陈述没有科学或事实上的不健全之处，不是不可形式化的，是完整和一致的，是现实的，是良构的，并且是科学上可验证的。\n\n### 步骤 3：结论和行动\n问题陈述是**有效的**。将推导出完整的解决方案。\n\n### 解决方案的推导\n必须根据指定的维度对系统进行分析：确定性与随机性，以及连续与离散。\n\n**1. 理论分析**\n从理论或算法的角度，我们考察系统的基本规则。\n- **确定性与随机性**：如果一个系统的未来状态和输出由其当前状态和输入唯一确定，那么该系统是确定性的。问题陈述指出，对于一个给定的种子 $s_0$（它初始化状态 $x_0$），后续状态 $\\{x_k\\}$ 和输出 $\\{y_k, u_k\\}$ 的整个序列（对于 $k > 0$）是由固定规则唯一确定的。在算法的状态转换或输出生成中没有随机因素。因此，PRNG是一个**确定性**系统。\n- **离散与连续**：\n    - **时间**：系统在离散的步骤中演化，由整数 $k$ 索引。它不是在时间上连续演化的。因此，它是一个**离散时间**系统。\n    - **状态**：对于 MT19937，内部状态 $x_k$ 是一个由 $624$ 个 $32$ 位整数组成的向量。所有可能状态的集合是巨大的，但它是有限且可数的。这定义了一个**离散状态**系统。\n    - **输出**：原始输出 $y_k$ 是 $32$ 位整数，是一个离散集合。缩放后的输出 $u_k = y_k/2^{32}$ 是有理数。虽然它们位于连续区间 $[0,1)$ 内，但所有可能的输出值的集合是有限的（最多 $2^{32}$ 个不同的值）。一个其输出只能从有限或可数无限集合中取值的系统具有离散的输出空间。\n\n总之，从纯理论的角度来看，PRNG是一个**确定性的、离散时间的、离散状态的**系统。\n\n**2. 实践分析**\n从实践或建模的角度，我们考虑该系统是如何被使用的。\n- PRNG的目的是生成*看起来*是随机的序列，这意味着它们应该能通过随机性统计检验，并且对于不知道系统内部状态的观察者来说是不可预测的。\n- 问题指出，种子 $s_0$ 可以从外部“熵源”获取，例如系统时钟计时，这是分析师观察不到的。在这种常见用例中，初始状态 $x_0$ 是未知的。如果初始状态被视为一个随机变量，那么整个输出序列 $\\{u_k\\}$ 就成为一个**随机过程**的实现。\n- 其目标是使这个过程近似于一个独立同分布 (i.i.d.) 的随机变量序列，通常是在区间 $[0,1)$ 上均匀分布。在这种实践情境中，“随机性”并非来自生成器的规则，而是来自其初始条件（种子）的不确定性。\n\n因此，当被视为一个种子未知的黑盒时，在模拟和建模的所有实际应用中，生成器的输出被当作是**随机的**。\n\n### 选项评估\n\n- **A. 理论上，该生成器是一个确定性的、离散时间的、离散状态的系统：对于给定的种子 $s_0$，整个序列 $\\{x_k,y_k,u_k\\}$ 是唯一确定的，具有有限的状态空间和周期（对于 MT19937，周期为 $2^{19937}-1$）。实践上，如果种子未知并且是由外部熵源（例如，系统时钟中的计时不确定性）产生的，那么输出可以被建模为一个随机过程，近似于在 $[0,1)$ 的一个有限子集上的独立同分布 (i.i.d.) 均匀样本；任何随机性都源于外部播种，而非生成器的更新规则。**\n    - 这个陈述与我们的推导完全一致。它正确地指出了其理论性质是确定性、离散时间和离散状态的。它也正确地描述了实践观点，即由于未知的种子，输出被建模为随机过程，并恰当地指出了这种随机性的来源。关于有限状态空间、周期和 i.i.d. 样本近似的细节都是正确的。\n    - **结论：正确。**\n\n- **B. 理论上，该生成器是随机的，因为其输出通过了随机性统计检验；实践上，它是确定性的，因为如果种子被记录下来，就可以复现一次运行。**\n    - 这个选项颠倒了概念。通过随机性统计检验是一个*确定性*算法用来*模拟*随机过程的设计目标；这并不会使算法本身成为随机的。在给定种子的情况下复现序列的能力正是其理论确定性的定义，而不是一个“实践”的考量。\n    - **结论：不正确。**\n\n- **C. 理论上，该生成器是确定性的；实践上，即使种子是固定的，它本质上也是随机的，因为不可预测性意味着随机性。**\n    - 第一部分是正确的。第二部分是有缺陷的。如果种子是固定的且已知的，那么序列是完全可预测的，在任何意义上都不是随机的。“本质上是随机的”这一说法是不正确的，它混淆了计算上的不可预测性与真正的随机性。\n    - **结论：不正确。**\n\n- **D. 理论上和实践上，该生成器都是随机和连续的，因为将 $y_k$ 映射到 $u_k\\in[0,1)$ 会产生实值输出。**\n    - 这在多个方面都是不正确的。理论上，该生成器是确定性的。它也是一个离散时间、离散状态的系统。输出值 $u_k$ 形成一个离散、有限的有理数集合；它们是实数 $\\mathbb{R}$ 的一个子集这一事实并不能使系统成为连续的。如果一个系统的状态变量根据连续时间中的微分方程演化，那么该系统才是连续的。\n    - **结论：不正确。**\n\n- **E. 理论上，该生成器是确定性的和连续时间的（可以在任何时间查询）；实践上，它是随机的但状态是离散的。**\n    - 理论上的分类是错误的。该系统是离散时间的，因为它的状态是在离散的步骤 $k=0,1,2,\\dots$ 中演化的。无法在这些步骤之间查询“状态”。虽然实践部分部分正确（随机模型，离散状态），但理论部分的错误使整个选项无效。\n    - **结论：不正确。**\n\n基于全面的分析，选项A提供了唯一完整且准确的描述。", "answer": "$$\\boxed{A}$$", "id": "2441708"}, {"introduction": "在了解了确定性算法如何能被视为随机性算法之后，现在让我们来构建一个具有内在、可调随机性的系统。本练习从经典的确定性元胞自动机——康威生命游戏（Conway's Game of Life）出发，挑战你引入一个概率性的“噪声”参数。[@problem_id:2441653] 你的任务是分析这个参数如何改变系统的基本分类，并特别关注概率为 $p=0$ 或 $p=1$ 时的边界情况，从而磨练你严格应用形式化定义的能力。", "problem": "你的任务是基于第一性原理，对一个源自康威生命游戏的细胞自动机系统族进行分类。请考虑以下系统描述。\n\n康威生命游戏定义在一个无限的二维细胞网格上。每个细胞具有 $\\{0,1\\}$ 中的一个二元状态，其中 $0$ 表示死细胞，$1$ 表示活细胞。该系统以同步步骤演化，由一个整数时间变量 $t \\in \\mathbb{Z}_{\\ge 0}$ 索引。令 $x_{i,j}(t) \\in \\{0,1\\}$ 表示在时间 $t$、整数坐标 $(i,j)$ 处的细胞状态。标准更新规则将时间 $t$ 的整个构型映射到时间 $t+1$，对每个细胞的规则如下：如果一个活细胞恰好有 $2$ 个或 $3$ 个活邻居，它将保持存活；如果一个死细胞恰好有 $3$ 个活邻居，它将变为活细胞；否则该细胞变为死细胞。邻居是指水平、垂直或对角线方向上相邻的八个细胞。\n\n定义一个由概率 $p \\in [0,1]$ 参数化的增强系统族。在每个时间步 $t \\to t+1$，执行标准的确定性更新以获得一个中间构型，然后对每个细胞以概率 $p$ 独立地翻转其二元状态（即，以概率 $p$ 将 $0$ 替换为 $1$、将 $1$ 替换为 $0$，并以概率 $1-p$ 保持不变）。所有跨细胞和时间的翻转都是相互独立的。\n\n你的任务是沿着两个轴对该族中的每个成员进行分类：\n- 时间索引分类：离散时间与连续时间。\n- 随机性分类：确定性与随机性。\n\n将具有参数 $p$ 的系统的分类编码为单个整数 $C$，定义如下：\n- $t_{\\mathrm{class}} \\in \\{0,1\\}$ 表示时间索引分类，其中 $0$ 代表连续时间，$1$ 代表离散时间。\n- $r_{\\mathrm{class}} \\in \\{0,1\\}$ 表示随机性分类，其中 $0$ 代表确定性，$1$ 代表随机性。\n- 该代码为 $C = 10 \\cdot t_{\\mathrm{class}} + r_{\\mathrm{class}}$。\n\n测试套件：\n评估以下参数值 $p$ 对应的分类代码 $C$：\n- $p = 0$,\n- $p = 0.01$,\n- $p = 0.5$,\n- $p = 1$.\n\n答案规格和输出格式：\n- 对于每个指定的 $p$，你的程序必须计算出如上定义的相应整数代码 $C$。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内无空格，其顺序与上面列出的 $p$ 值顺序相同（例如，$[c_1,c_2,c_3,c_4]$，其中每个 $c_k$ 是第 $k$ 个测试用例的整数代码）。\n- 本问题不涉及任何物理单位或角度。", "solution": "问题陈述已经过验证，被认为是具有科学依据、问题明确且客观的。它为待分类的细胞自动机系统族提供了一个完整且一致的定义。解决方案首先根据系统定义建立通用的分类原则，然后将这些原则应用于具体的测试用例。\n\n该系统由概率 $p$ 参数化，其分类沿着两个独立的轴进行：时间索引的性质和随机性的存在。最终的分类代码 $C$ 计算公式为 $C = 10 \\cdot t_{\\mathrm{class}} + r_{\\mathrm{class}}$，其中 $t_{\\mathrm{class}}$ 和 $r_{\\mathrm{class}}$ 分别是时间分类和随机性分类的整数代码。\n\n**时间索引分类**\n如果一个系统的状态在离散、可数的时间点（例如，由整数索引）演化，则该系统被分类为**离散时间**系统。如果其状态在实值时间区间上连续演化，则被分类为**连续时间**系统。\n\n问题陈述指明“该系统以同步步骤演化，由一个整数时间变量 $t \\in \\mathbb{Z}_{\\ge 0}$ 索引”。时间索引的集合是 $\\{0, 1, 2, \\dots\\}$，这是一个离散且可数的集合。由网格构型 $\\{x_{i,j}(t)\\}$ 表示的系统状态仅在这些整数时间步上定义，并在时间步之间保持不变。此属性与参数 $p$ 的值无关，因为 $p$ 仅影响时间步之间的转换规则，而不影响时间轴本身的性质。\n\n因此，对于任何 $p \\in [0,1]$，该系统都是一个离散时间系统。\n时间索引的分类代码为 $t_{\\mathrm{class}} = 1$。\n\n**随机性分类**\n如果对于时间 $t$ 的任意给定状态，时间 $t+1$ 的状态是唯一确定的，则该系统被分类为**确定性**系统。如果对于时间 $t$ 的一个给定状态，在时间 $t+1$ 可能存在多个后续状态，其结果由概率分布决定，则该系统被分类为**随机性**系统。\n\n系统从时间 $t$ 到 $t+1$ 的状态转换分两个阶段进行：\n$1$. 基于康威生命游戏标准规则的确定性更新。这将构型 $x(t)$ 映射到一个唯一的中间构型 $x'(t+1)$。\n$2$. 对每个细胞进行概率性状态翻转。最终状态 $x_{i,j}(t+1)$ 是通过以概率 $p$ 翻转中间状态 $x'_{i,j}(t+1)$ 得到的。状态以概率 $1-p$ 保持不变。\n\n整个系统的性质关键取决于 $p$ 的值：\n- **情况 $p = 0$**：状态翻转的概率为 $0$。第二阶段没有效果，因为每个细胞的状态以 $1-0 = 1$ 的概率保持不变。系统的演化完全由确定性的生命游戏规则决定。因此，该系统是**确定性**的。随机性分类代码为 $r_{\\mathrm{class}} = 0$。\n- **情况 $p \\in (0,1)$**：在此范围内，翻转的概率（$p$）和不翻转的概率（$1-p$）都严格大于 $0$。这意味着对于任何细胞，其在 $t+1$ 的最终状态不是由中间状态 $x'(t+1)$ 唯一确定的。因此整个网格的演化是概率性的。该系统是**随机性**的。随机性分类代码为 $r_{\\mathrm{class}} = 1$。\n- **情况 $p = 1$**：状态翻转的概率为 $1$。在确定性的生命游戏更新之后，每个细胞的状态都保证被反转。总的更新规则是：（$1$）根据生命游戏规则计算下一个状态，然后（$2$）反转每个细胞的状态。这是一个完全确定的操作序列。对于时间 $t$ 的任何状态，时间 $t+1$ 的状态都是唯一确定的。因此，该系统是**确定性**的。随机性分类代码为 $r_{\\mathrm{class}} = 0$。\n\n**测试套件评估**\n针对每个指定的 $p$ 值计算分类代码 $C$。时间分类始终为 $t_{\\mathrm{class}}=1$。\n\n- **对于 $p = 0$**：\n  该系统是确定性的，所以 $r_{\\mathrm{class}}=0$。\n  $C = 10 \\cdot t_{\\mathrm{class}} + r_{\\mathrm{class}} = 10 \\cdot 1 + 0 = 10$。\n\n- **对于 $p = 0.01$**：\n  由于 $0 < 0.01 < 1$，该系统是随机性的，所以 $r_{\\mathrm{class}}=1$。\n  $C = 10 \\cdot t_{\\mathrm{class}} + r_{\\mathrm{class}} = 10 \\cdot 1 + 1 = 11$。\n\n- **对于 $p = 0.5$**：\n  由于 $0 < 0.5 < 1$，该系统是随机性的，所以 $r_{\\mathrm{class}}=1$。\n  $C = 10 \\cdot t_{\\mathrm{class}} + r_{\\mathrm{class}} = 10 \\cdot 1 + 1 = 11$。\n\n- **对于 $p = 1$**：\n  该系统是确定性的，所以 $r_{\\mathrm{class}}=0$。\n  $C = 10 \\cdot t_{\\mathrm{class}} + r_{\\mathrm{class}} = 10 \\cdot 1 + 0 = 10$。\n\n最终的代码序列是 $[10, 11, 11, 10]$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Classifies a family of cellular automaton systems based on their time and\n    randomness characteristics.\n    \"\"\"\n    \n    # Test suite of probability parameters p.\n    test_cases = [0.0, 0.01, 0.5, 1.0]\n    \n    results = []\n    \n    # Time classification is always discrete for this system.\n    # t_class = 0 for continuous time, 1 for discrete time.\n    t_class = 1\n    \n    for p in test_cases:\n        # Randomness classification depends on the value of p.\n        # r_class = 0 for deterministic, 1 for stochastic.\n        # The system is stochastic if and only if p is in the open interval (0, 1).\n        # At the boundaries p=0 and p=1, the evolution is deterministic.\n        if p > 0.0 and p < 1.0:\n            r_class = 1  # Stochastic\n        else:\n            r_class = 0  # Deterministic\n            \n        # The classification code C is defined as 10 * t_class + r_class.\n        code = 10 * t_class + r_class\n        results.append(code)\n        \n    # The final output must be a single line containing a comma-separated list\n    # of the integer codes, enclosed in square brackets, with no spaces.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2441653"}]}