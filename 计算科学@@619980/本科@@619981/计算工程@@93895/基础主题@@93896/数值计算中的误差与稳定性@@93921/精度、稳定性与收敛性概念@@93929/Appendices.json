{"hands_on_practices": [{"introduction": "理论知识只有在实践中才能真正内化。本节旨在通过一系列动手实践，将准确性、稳定性和收敛性的抽象概念具体化。我们首先从一个关于数值积分准确性的挑战性问题开始。Richardson 外推法是一种强大的通用技术，通常能显著提高数值方法的精度，但它的成功并非无条件的。这个练习将引导我们探索该方法的边界，通过构造一个特殊函数，使得 Richardson 外推法无法提升梯形法则的精度阶数，从而深刻揭示数值算法背后关于函数光滑性的基本假设。[@problem_id:2378435]", "problem": "考虑在均匀网格上使用复合梯形法则对定积分 $I = \\int_{0}^{1} f(x) \\, dx$ 进行数值近似。对于步长 $h = 1/n$ 和 $n \\in \\mathbb{N}$ 个子区间，复合梯形近似为\n$$\nT(h) \\equiv h \\left( \\frac{1}{2} f(0) + \\sum_{j=1}^{n-1} f(jh) + \\frac{1}{2} f(1) \\right).\n$$\n定义第一次 Richardson 外推，它是基于 $T(h)$ 的主误差项与 $h^{2}$ 同阶这一假设构造的，其形式为\n$$\nR(h) \\equiv \\frac{4 T\\!\\left(\\frac{h}{2}\\right) - T(h)}{3}.\n$$\n构造一个显式可积函数 $f:[0,1] \\to \\mathbb{R}$，该函数不能被梯形法则精确积分，并且当 $h \\to 0$ 时，将 $R(h)$ 应用于 $T(h)$ 未能提高其渐近收敛阶，即 $R(h) - I$ 与 $T(h) - I$ 具有相同的 $h$ 阶。\n\n答案形式：以 $f(x)$ 的单个闭式解析表达式的形式提供您的函数。无需单位。无需四舍五入。", "solution": "该问题要求构造一个在区间 $[0,1]$ 上的可积函数 $f(x)$，使得应用于复合梯形法则 $T(h)$ 的第一次 Richardson 外推 $R(h)$ 未能提高其渐近收敛阶。这意味着误差 $R(h) - I$ 必须与误差 $T(h) - I$ 在步长 $h$ 上具有相同的阶，其中 $I = \\int_{0}^{1} f(x) \\, dx$。\n\n复合梯形法则近似由下式给出\n$$T(h) = h \\left( \\frac{1}{2} f(0) + \\sum_{j=1}^{n-1} f(jh) + \\frac{1}{2} f(1) \\right), \\quad \\text{其中 } h = \\frac{1}{n}。$$\n第一次 Richardson 外推定义为\n$$R(h) = \\frac{4 T(h/2) - T(h)}{3}。$$\n这种特定形式的外推旨在消除某一方法的误差主项，该方法的误差 $E(h) = T(h) - I$ 具有以下形式的渐近展开\n$$E(h) = c_1 h^2 + c_2 h^4 + c_3 h^6 + \\dots$$\n其中 $c_j$ 为某些常数。对于在区间 $[0,1]$ 上足够光滑的任何函数 $f(x)$（例如，$f \\in C^{\\infty}[0,1]$），这种误差结构由 Euler-Maclaurin 公式保证。对于此类函数，$R(h)$ 的误差变为\n$$R(h) - I = \\frac{4(I + \\frac{c_1}{4}h^2 + \\frac{c_2}{16}h^4 + \\dots) - (I + c_1 h^2 + c_2 h^4 + \\dots)}{3} - I = -\\frac{1}{4}c_2 h^4 + O(h^6)。$$\n在这种标准情况下，收敛阶从 $T(h)$ 的 $O(h^2)$ 提高到 $R(h)$ 的 $O(h^4)$。\n\n如果关于误差展开的假设被违反，则外推法无法提高收敛阶。如果函数 $f(x)$ 不够光滑，尤其是在积分区间的端点处，就会发生这种情况。如果主误差项不是 $h^2$ 阶，则对消将无法有效提高阶数。\n\n让我们假设一个形式为 $E(h) = T(h) - I = C h^p + O(h^q)$ 的误差展开，其中 $0 < p < q$。Richardson 外推的误差是\n$$R(h) - I = \\frac{4(C(h/2)^p + \\dots) - (C h^p + \\dots)}{3} = C h^p \\frac{4 \\cdot 2^{-p} - 1}{3} + \\dots$$\n仅当 $4 \\cdot 2^{-p} - 1 = 0$ 时，主误差项才会被消除，这意味着 $2^{2-p} = 1$，所以 $p=2$。如果 $p \\neq 2$，主误差项不会被消除，$R(h)$ 的收敛阶仍然是 $p$，与 $T(h)$ 的收敛阶相同。\n\n为实现这种情况，我们必须找到一个函数 $f(x)$，其梯形法则误差展开的主项为 $C h^p$ 且 $p \\neq 2$。此外，为使该项成为主误差项，其阶数 $p$ 必须低于标准的 $O(h^2)$ 项，因此我们要求 $0 < p < 2$。\n\n当 $f(x)$ 的某个导数在端点处有奇点时，就会出现这种误差展开。让我们考虑函数 $f(x) = x^\\alpha$，其中某个 $\\alpha > 0$。为使该函数在 $[0,1]$ 上作为到 $\\mathbb{R}$ 的映射是良定义的，我们必须有 $\\alpha > 0$，以便 $f(0)=0$ 是有限的。为了使问题非平凡，梯形法则不应是精确的。$T(h)$ 对于次数 $\\le 1$ 的多项式是精确的。如果 $\\alpha \\neq 0, 1$，我们的函数 $f(x)=x^\\alpha$ 就不是次数 $\\le 1$ 的多项式。\n\n对于在 $x=0$ 附近具有 $f(x) \\sim x^\\alpha$ 形式的代数奇点的函数，已知其梯形法则误差的渐近展开包含一个 $h^{\\alpha+1}$ 阶的项。如果 $\\alpha+1 < 2$，该项将是主导误差项。此条件等价于 $\\alpha < 1$。\n\n让我们选择 $\\alpha = 1/2$，所以我们的候选函数是\n$$f(x) = \\sqrt{x}。$$\n这个函数在 $[0,1]$ 上是可积的：$I = \\int_0^1 x^{1/2} \\, dx = [\\frac{2}{3} x^{3/2}]_0^1 = \\frac{2}{3}$。\n该函数不能被梯形法则精确积分；对于 $n=1$ ($h=1$)，$T(1) = \\frac{1}{2}(f(0)+f(1)) = \\frac{1}{2}$，而 $I=2/3$。\n函数 $f(x)=\\sqrt{x}$ 在 $x=0$ 处不可微，因为当 $x \\to 0^+$ 时，$f'(x) = \\frac{1}{2}x^{-1/2} \\to \\infty$。因此，标准的 Euler-Maclaurin 公式不适用。已知该函数的梯形法则误差展开具有以下形式：\n$$T(h) - I = C h^{1.5} + D h^2 + \\dots$$\n其中 $C = \\zeta(-1/2)$ 且 $\\zeta$ 是 Riemann zeta 函数。由于 $\\zeta(-1/2) \\approx -0.207886 \\neq 0$，主误差项的阶是 $h^{1.5}$。令 $E_T(h) = T(h) - I$。\nRichardson 外推的误差是\n$$R(h) - I = \\frac{4 E_T(h/2) - E_T(h)}{3}。$$\n带入误差展开式：\n$$R(h) - I = \\frac{4(C(h/2)^{1.5} + D(h/2)^2 + \\dots) - (C h^{1.5} + D h^2 + \\dots)}{3}$$\n$$R(h) - I = \\frac{C h^{1.5}(4 \\cdot 2^{-1.5} - 1) + D h^2(4 \\cdot 2^{-2} - 1) + \\dots}{3}$$\n$$R(h) - I = \\frac{C h^{1.5}(2^2 \\cdot 2^{-1.5} - 1) + D h^2(1 - 1) + \\dots}{3}$$\n$$R(h) - I = \\frac{C h^{1.5}(\\sqrt{2} - 1)}{3} + O(h^{2.5})。$$\n$h^{1.5}$ 项的系数非零。$h^2$ 项的系数为零，这与该方法的设计初衷相符。\n$R(h)$ 的主误差项的阶是 $h^{1.5}$。这与 $T(h)$ 的主误差项的阶相同。因此，Richardson 外推未能提高渐近收敛阶。\n\n函数 $f(x) = \\sqrt{x}$ 满足问题的所有条件。", "answer": "$$\\boxed{\\sqrt{x}}$$", "id": "2378435"}, {"introduction": "接下来，我们将问题从数值积分拓展到常微分方程 (ODEs) 的求解，重点关注长期模拟中的稳定性。许多物理系统，如行星运动或生态系统，都具有内在的守恒量。一个好的数值方法应该在长时间内保持这些守恒特性。本练习通过模拟经典的 Lotka-Volterra 捕食者-被捕食者系统，直观地对比了一个标准的显式欧拉法和一个结构保持的辛欧拉法。你将通过编程实践发现，选择正确的算法（如辛积分器）对于维持解的长期稳定性和物理真实性至关重要。[@problem_id:2378425]", "problem": "您将研究时间积分方法的选择如何影响经典的捕食者-被捕食者 Lotka–Volterra 系统的长期轨道稳定性、精度和收敛性。考虑以下耦合常微分方程组 (ODEs)\n$$\n\\frac{dx}{dt} = a x - b x y,\\quad \\frac{dy}{dt} = -c y + d x y,\n$$\n其中参数和初始条件均严格为正。在本任务中，将参数固定为 $a = 1$、$b = 1$、$c = 1$、$d = 1$，初始条件固定为 $x(0) = 1.5$、$y(0) = 1$。您的任务是实现两种一阶时间步进器，量化它们在短期和长期内的精度和稳定性，并按下文规定的格式将数值诊断结果聚合到单行输出中。所有角度都是无量纲的，且不涉及物理单位。\n\n基础知识：使用常微分方程的基本定义、显式欧拉法、哈密顿系统上的辛方法的概念，以及数值精度（全局误差）、稳定性（不变量和正性的定性保持）和收敛性（时间步长细化下观测到的阶数）的标准概念。使用关于 Lotka–Volterra 系统（其中 $a, b, c, d > 0$）的以下经过充分检验的事实：函数\n$$\nI(x,y) = d\\,x - c \\ln x + b\\,y - a \\ln y\n$$\n对于所有满足 $x(t) > 0$ 和 $y(t) > 0$ 的 $t$，该函数沿着精确轨迹是一个常数。\n\n实现以下组成部分：\n\n1) 时间步进器：\n- 显式欧拉法 (一种非结构保持格式)：给定时间步长 $h > 0$，通过对右端向量场应用显式欧拉更新来推进 $x$ 和 $y$。\n- 辛欧拉法 (一种用于哈密顿流的结构保持格式)：引入典则变量变换 $u = \\ln x$、$v = \\ln y$，该系统可据此写成一个典则哈密顿系统，其哈密顿量为\n$$\nH(u,v) = d\\,e^{u} - c\\,u + b\\,e^{v} - a\\,v,\n$$\n其典则方程为 $u' = -\\partial H/\\partial v$、$v' = \\partial H/\\partial u$。在典则变量 $(u,v)$ 中应用一阶辛欧拉格式，然后在每一步通过 $x = e^{u}$、$y = e^{v}$ 映射回 $(x,y)$。\n\n2) 用于量化精度、稳定性和收敛性的诊断方法：\n- 不变量漂移：对于给定的最终时间 $T > 0$，将不变量的绝对漂移定义为\n$$\n\\Delta I = \\left| I\\!\\left(x(T), y(T)\\right) - I\\!\\left(x(0), y(0)\\right) \\right|.\n$$\n如果在任何步骤中，数值解 $(x,y)$ 离开了正象限 (即 $x \\le 0$ 或 $y \\le 0$)，则不变量未定义；在这种情况下，将漂移报告为浮点数“非数字”(NaN)，并如下文所述单独标记正性违例。\n- 正性标志：对于一条轨迹，返回一个布尔值，指示在到达最终时间前的每个离散步骤 $n$ 是否都有 $x_n > 0$ 和 $y_n > 0$。\n- 最终时间的经验收敛阶：对于固定的 $T > 0$ 和两个步长 $h$ 和 $h/2$，用每个步长计算在时间 $T$ 的数值解。使用由鲁棒的 ODE 求解器计算的高精度参考解来近似时间 $T$ 的精确状态。将误差 $E(h)$ 和 $E(h/2)$ 定义为时间 $T$ 时数值状态和参考状态之差的欧几里得范数。然后通过以下公式估计观测阶\n$$\np = \\log_2\\!\\left(\\frac{E(h)}{E(h/2)}\\right).\n$$\n使用具有严格容差的高精度参考解，以使参考解的误差相对于方法误差可以忽略不计。\n\n3) 测试套件和要求输出：\n固定 $a = 1$、$b = 1$、$c = 1$、$d = 1$、$x(0) = 1.5$、$y(0) = 1$。实现以下五个测试用例，每个用例产生一个待聚合的结果：\n\n- 测试 $1$ (长期漂移和正性，非结构保持)：在 $[0,T]$ (其中 $T = 50$) 上使用步长 $h = 0.05$ 的显式欧拉法。输出一个双元素列表 $[\\Delta I, \\text{pos}]$，其中 $\\Delta I$ 是上文定义的绝对不变量漂移 (一个浮点数)，$\\text{pos}$ 是正性标志 (一个布尔值)。\n- 测试 $2$ (长期漂移和正性，结构保持)：在 $[0,T]$ (其中 $T = 50$) 上使用步长 $h = 0.05$ 的辛欧拉法。如上输出一个双元素列表 $[\\Delta I, \\text{pos}]$。\n- 测试 $3$ (显式欧拉法的经验阶)：使用步长 $h = 0.1$ 和 $h/2 = 0.05$，计算在 $T = 10$ 时的观测阶。使用高精度参考解进行比较。输出标量 $p$ (一个浮点数)。\n- 测试 $4$ (辛欧拉法的经验阶)：使用步长 $h = 0.1$ 和 $h/2 = 0.05$，计算在 $T = 10$ 时的观测阶。使用高精度参考解进行比较。输出标量 $p$ (一个浮点数)。\n- 测试 $5$ (大步长下的边界情况稳定性)：在 $[0,T]$ (其中 $T = 200$) 上使用步长 $h = 0.5$ 的显式欧拉法。输出正性标志 (一个布尔值)。\n\n实现细节和约束：\n- 所有模拟都必须使用固定的参数 $a = 1$、$b = 1$、$c = 1$、$d = 1$ 和初始条件 $x(0) = 1.5$、$y(0) = 1$。\n- 对于高精度参考解，使用一个具有严格容差的自适应 ODE 积分器 (例如，相对容差 $10^{-12}$，绝对容差 $10^{-14}$)。\n- 对于所有测试，使用均匀的时间步长，该步长需能整除最终时间，以使步数 $N = T/h$ 为整数。\n- 您的程序必须按所述实现两种时间步进器，并计算所要求的输出。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表形式的结果，并用方括号括起来，顺序如下：\n$$\n\\big[ [\\Delta I_{\\text{EE}}, \\text{pos}_{\\text{EE}}], [\\Delta I_{\\text{SE}}, \\text{pos}_{\\text{SE}}], p_{\\text{EE}}, p_{\\text{SE}}, \\text{pos}_{\\text{EE,coarse}} \\big].\n$$\n例如，一个语法正确的输出看起来会像 $[[0.123,True],[0.004,True],0.98,1.01,False]$ (此处显示的值仅为示例；您的程序必须计算实际值)。输出不包含单位和角度；布尔值的写法与标准编程语言中的写法一致。", "solution": "该问题要求对用于 Lotka-Volterra 捕食者-被捕食者模型的两种数值积分格式——显式欧拉法和辛欧拉法——进行对比分析。分析将侧重于稳定性、精度和收敛性这些基本的数值概念。问题陈述已经过验证，被认为是科学上合理、适定且完整的。它构成了计算科学领域一个标准且有指导意义的练习。我们现在开始求解。\n\n该系统由以下耦合常微分方程组 (ODEs) 描述：\n$$\n\\frac{dx}{dt} = a x - b x y\n$$\n$$\n\\frac{dy}{dt} = -c y + d x y\n$$\n其中 $x(t)$ 和 $y(t)$ 分别代表被捕食者和捕食者的种群数量。参数固定为 $a = 1$、$b = 1$、$c = 1$ 和 $d = 1$。初始条件为 $x(0) = 1.5$ 和 $y(0) = 1.0$。\n\n该系统的一个关键特征是存在一个守恒量，或称第一积分，由以下函数给出：\n$$\nI(x,y) = d\\,x - c \\ln x + b\\,y - a \\ln y\n$$\n对于 ODE 的精确解，有 $\\frac{dI}{dt} = 0$，这意味着解轨迹 $(x(t), y(t))$ 被限制在 $I(x,y)$ 的等值集上。在相平面中，这些等值集围绕非平凡不动点 $(x_c, y_c) = (c/d, a/b)$ 形成闭合轨道。对于给定的参数，该不动点位于 $(1, 1)$。$I(x,y)$ 的守恒是该系统的一个关键结构性质。一个理想的数值方法应至少能在长时间积分中近似地保持这个守恒性质。\n\n我们将实现并分析两种一阶数值格式。\n\n1.  **显式欧拉法**：\n这是一种标准的、非结构保持的数值方法。给定在时间 $t_n$ 的状态 $(x_n, y_n)$，在 $t_{n+1} = t_n + h$ 的状态通过沿向量场切线的线性外推来近似：\n$$\nx_{n+1} = x_n + h (a x_n - b x_n y_n)\n$$\n$$\ny_{n+1} = y_n + h (-c y_n + d x_n y_n)\n$$\n该方法易于实现，但已知对于振荡系统是耗散的或反耗散的。对于哈密顿系统，它不保持能量或任何相关的不变量，数值轨迹通常会螺旋式地偏离真实的闭合轨道。此外，如果时间步长 $h$ 过大，显式更新可能导致不符合物理意义的负种群数量。\n\n2.  **辛欧拉法**：\n这是一种结构保持积分器，专为哈密顿系统设计的几何积分器。Lotka-Volterra 系统可以被转换为一个典则哈密顿系统。令 $u = \\ln x$ 和 $v = \\ln y$。在这些典则坐标下的动力学由哈密顿量决定：\n$$\nH(u,v) = d\\,e^{u} - c\\,u + b\\,e^{v} - a\\,v\n$$\n运动方程为 $\\dot{u} = -\\partial H / \\partial v = a - b e^v$ 和 $\\dot{v} = \\partial H / \\partial u = d e^u - c$。可以通过分裂共轭变量的更新来构造一阶辛欧拉格式。我们将使用以下变体：\n$$\nv_{n+1} = v_n + h (d e^{u_n} - c)\n$$\n$$\nu_{n+1} = u_n + h (a - b e^{v_{n+1}})\n$$\n在 $(u,v)$ 坐标中的每一步之后，我们变换回原始变量：$x_{n+1} = e^{u_{n+1}}$ 和 $y_{n+1} = e^{v_{n+1}}$。从构造上讲，只要 $u$ 和 $v$ 是实数（它们确实会是），这种方法就能确保 $x$ 和 $y$ 保持为正。辛积分器并不精确地保持哈密顿量 $H$；相反，它们精确地保持一个附近的“影子”哈密顿量。这一性质导致数值能量误差在零附近振荡，从而带来出色的长期稳定性和不变量的有界漂移，这与像显式欧拉法这样的非辛方法中观察到的长期漂移形成鲜明对比。\n\n对这些方法的评估基于三种诊断指标：\n\n-   **不变量漂移 ($\\Delta I$)**：衡量长期稳定性。它被定义为绝对差 $|I(x(T), y(T)) - I(x(0), y(0))|$。对于一个完美的积分器，$\\Delta I$ 应为零。我们预期在长时间范围内，辛欧拉法的 $\\Delta I$ 将显著小于显式欧拉法的 $\\Delta I$。\n\n-   **正性**：种群模型的一个基本物理要求是种群数量保持非负。我们监测在所有步骤中是否有 $x_n > 0$ 和 $y_n > 0$。未能保持正性表明数值格式发生了灾难性失败。\n\n-   **经验收敛阶 ($p$)**：衡量精度。对于一个误差为 $E(h) \\propto h^p$ 的方法，我们可以通过比较使用两个不同步长 $h$ 和 $h/2$ 的模拟所产生的误差来估计阶数 $p$。公式为 $p = \\log_2(E(h)/E(h/2))$。对于正在测试的一阶方法，我们预期会观察到 $p \\approx 1$。\n\n所指定的五个测试旨在突出这两种方法之间的差异：\n-   测试 $1$ 和 $2$ 比较显式欧拉法和辛欧拉法的长期漂移和稳定性。\n-   测试 $3$ 和 $4$ 在数值上验证两种格式的一阶收敛性。\n-   测试 $5$ 展示了显式欧拉法在大时间步长下的不稳定性，在这种情况下，显式更新可能会过冲并违反正性。\n\n以下代码实现了这些测试并计算了所需的数值结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the Lotka-Volterra problem by comparing Explicit and Symplectic Euler methods.\n    \"\"\"\n    # Fixed parameters and initial conditions\n    a, b, c, d = 1.0, 1.0, 1.0, 1.0\n    x0, y0 = 1.5, 1.0\n    state0 = np.array([x0, y0])\n\n    # === Helper Functions ===\n\n    def lotka_volterra_rhs(t, state, a, b, c, d):\n        \"\"\"Right-hand side of the Lotka-Volterra ODEs.\"\"\"\n        x, y = state\n        dxdt = a * x - b * x * y\n        dydt = -c * y + d * x * y\n        return np.array([dxdt, dydt])\n\n    def invariant(state, a, b, c, d):\n        \"\"\"Computes the conserved quantity I(x, y).\"\"\"\n        x, y = state\n        if x <= 0 or y <= 0:\n            return float('nan')\n        return d * x - c * np.log(x) + b * y - a * np.log(y)\n\n    def explicit_euler_step(state, h, a, b, c, d):\n        \"\"\"Performs one step of the Explicit Euler method.\"\"\"\n        x, y = state\n        x_new = x + h * (a * x - b * x * y)\n        y_new = y + h * (-c * y + d * x * y)\n        return np.array([x_new, y_new])\n\n    def symplectic_euler_step(state, h, a, b, c, d):\n        \"\"\"Performs one step of the Symplectic Euler method.\"\"\"\n        x, y = state\n        u, v = np.log(x), np.log(y)\n        v_new = v + h * (d * np.exp(u) - c)\n        u_new = u + h * (a - b * np.exp(v_new))\n        return np.array([np.exp(u_new), np.exp(v_new)])\n\n    def time_integrator(stepper_fn, state0, h, T, params):\n        \"\"\"\n        Integrates the ODEs using a given stepper function.\n        Returns the final state and a positivity flag.\n        \"\"\"\n        state = np.copy(state0)\n        positivity = True\n        num_steps = int(round(T / h))\n        \n        for _ in range(num_steps):\n            state = stepper_fn(state, h, *params)\n            if state[0] <= 0 or state[1] <= 0:\n                positivity = False\n                break\n        return state, positivity\n\n    # Initial invariant value\n    I0 = invariant(state0, a, b, c, d)\n    \n    results = []\n\n    # === Test 1: Explicit Euler, long-horizon drift and positivity ===\n    h1 = 0.05\n    T1 = 50.0\n    final_state_ee, pos_ee = time_integrator(explicit_euler_step, state0, h1, T1, (a, b, c, d))\n    if pos_ee:\n        I_final_ee = invariant(final_state_ee, a, b, c, d)\n        delta_I_ee = abs(I_final_ee - I0)\n    else:\n        delta_I_ee = float('nan')\n    results.append([delta_I_ee, pos_ee])\n\n    # === Test 2: Symplectic Euler, long-horizon drift and positivity ===\n    h2 = 0.05\n    T2 = 50.0\n    final_state_se, pos_se = time_integrator(symplectic_euler_step, state0, h2, T2, (a, b, c, d))\n    if pos_se:\n        I_final_se = invariant(final_state_se, a, b, c, d)\n        delta_I_se = abs(I_final_se - I0)\n    else:\n        delta_I_se = float('nan')\n    results.append([delta_I_se, pos_se])\n\n    # === Setup for Convergence Tests ===\n    T_conv = 10.0\n    h_conv = 0.1\n    \n    # High-accuracy reference solution\n    ref_sol = solve_ivp(\n        lotka_volterra_rhs, [0, T_conv], state0,\n        args=(a, b, c, d),\n        method='DOP853',\n        rtol=1e-12,\n        atol=1e-14\n    )\n    ref_state_T = ref_sol.y[:, -1]\n\n    # === Test 3: Empirical order for Explicit Euler ===\n    state_h_ee, _ = time_integrator(explicit_euler_step, state0, h_conv, T_conv, (a, b, c, d))\n    state_h2_ee, _ = time_integrator(explicit_euler_step, state0, h_conv / 2, T_conv, (a, b, c, d))\n    \n    error_h_ee = np.linalg.norm(state_h_ee - ref_state_T)\n    error_h2_ee = np.linalg.norm(state_h2_ee - ref_state_T)\n    \n    p_ee = np.log2(error_h_ee / error_h2_ee) if error_h2_ee > 0 else float('nan')\n    results.append(p_ee)\n\n    # === Test 4: Empirical order for Symplectic Euler ===\n    state_h_se, _ = time_integrator(symplectic_euler_step, state0, h_conv, T_conv, (a, b, c, d))\n    state_h2_se, _ = time_integrator(symplectic_euler_step, state0, h_conv / 2, T_conv, (a, b, c, d))\n\n    error_h_se = np.linalg.norm(state_h_se - ref_state_T)\n    error_h2_se = np.linalg.norm(state_h2_se - ref_state_T)\n\n    p_se = np.log2(error_h_se / error_h2_se) if error_h2_se > 0 else float('nan')\n    results.append(p_se)\n\n    # === Test 5: Explicit Euler, edge-case stability ===\n    h5 = 0.5\n    T5 = 200.0\n    _, pos_ee_coarse = time_integrator(explicit_euler_step, state0, h5, T5, (a, b, c, d))\n    results.append(pos_ee_coarse)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2378425"}, {"introduction": "最后，我们将挑战升级至偏微分方程 (PDEs) 的求解，这在计算工程中无处不在。谱方法因其高精度而备受青睐，但它们也可能引入独特的数值不稳定性。本练习将通过求解一个非线性波动模型——无粘性伯格斯方程，来演示一种常见且微妙的陷阱：混叠不稳定性 (aliasing instability)。当空间网格不足以解析非线性项产生的高频波时，这些高频信息会“混淆”为低频信号，可能导致能量的非物理增长，最终破坏整个模拟的稳定性。[@problem_id:2378405]", "problem": "考虑定义在周期性域上的一维无粘性伯格斯方程，其偏微分方程为 $$u_t(x,t) + \\partial_x \\left(\\frac{1}{2} u(x,t)^2\\right) = 0$$，定义在区间 $$x \\in [0, 2\\pi]$$（角度以弧度为单位）和时间 $$t \\ge 0$$ 上。初始条件为单一傅里叶模式 $$u(x,0) = A \\sin(m x)$$，其中 $$A > 0$$ 为振幅，$$m \\in \\mathbb{Z}$$ 为波数。只要解保持光滑，其精确解就会守恒二次不变量 $$E(t) = \\frac{1}{2} \\int_{0}^{2\\pi} u(x,t)^2 \\, dx$$。在使用具有有限数量网格点 $$N \\in \\mathbb{N}$$ 的离散傅里叶变换进行傅里叶伪谱离散化时，在物理空间中逐点计算非线性乘积并转换回谱空间会引入混叠。当初始模式的每个波长少于两个网格点时，即 $$N / m < 2$$，离散化必然会将高频内容混叠到较低波数。这可能表现为放大离散能量的数值不稳定性。\n\n实现一个程序，对每个测试用例执行以下操作：\n\n1.  在 $$[0, 2\\pi)$$ 上使用 $$N$$ 个等距网格点，网格间距为 $$\\Delta x = 2\\pi / N$$。\n2.  使用快速傅里叶变换（FFT）的傅里叶伪谱方法对空间进行离散化。谱导数通过将傅里叶系数乘以 $$i k$$ 来计算，其中 $$k$$ 是由 $$2\\pi \\cdot \\mathrm{fftfreq}(N, \\Delta x)$$ 返回的角波数，不进行去混叠。\n3.  使用经典四阶龙格－库塔方法对时间进行离散化。使用自适应时间步长 $$\\Delta t_n = c \\, \\Delta x / \\max_x |u^n(x)|$$，其中 $$c = 0.2$$，在每一步更新 $$\\Delta t_n$$，并通过根据需要截断最后一步来确保最终时间恰好为 $$T$$。如果 $$\\max_x |u^n(x)| = 0$$，则取 $$\\Delta t_n = T - t_n$$。\n4.  从 $$t=0$$ 演化到 $$t=T$$，并使用均匀网格上的梯形法则计算离散能量放大因子 $$R = E(T)/E(0)$$，即 $$E(t) = \\frac{1}{2} \\Delta x \\sum_{j=0}^{N-1} u(x_j,t)^2$$。\n\n所有用例均使用固定参数 $$A = 0.1$$ 和 $$T = 0.1$$。测试套件包含以下四个用例，以 $$(N, m)$$ 对的形式给出：\n- 用例 $$1$$（精细解析，每波长点数多）：$$(256, 16)$$。\n- 用例 $$2$$（奈奎斯特边界，每波长恰好两点）：$$(64, 32)$$。\n- 用例 $$3$$（解析不足，每波长点数少于两点）：$$(64, 40)$$。\n- 用例 $$4$$（严重解析不足）：$$(32, 28)$$。\n\n您的程序必须输出一行，其中包含一个包含四个小数的列表，按顺序对应于用例 $$1$$ 到 $$4$$ 的 $$R$$ 值，每个值都四舍五入到小数点后恰好 $$6$$ 位。所需格式为单行：\n$$[r_1,r_2,r_3,r_4]$$\n其中每个 $$r_j$$ 是用例 $$j$$ 的 $$R$$ 的舍入值。不应打印任何其他文本。答案是无量纲的；不要包含任何单位。", "solution": "该问题已经过验证，并被确定为有效。它在科学上是合理的、适定的、客观的，并包含了唯一解所需的所有必要信息。该问题探讨了使用傅里叶伪谱方法求解无粘性伯格斯方程的数值解，这是计算工程学中的一个标准课题，特别关注混叠引起的数值不稳定性的概念。\n\n控制偏微分方程（PDE）是一维无粘性伯格斯方程的守恒形式：\n$$\nu_t(x,t) + \\partial_x \\left(\\frac{1}{2} u(x,t)^2\\right) = 0\n$$\n该方程定义在周期性空间域 $x \\in [0, 2\\pi]$ 和时间 $t \\ge 0$ 上。初始条件为单一正弦模式：\n$$\nu(x,0) = A \\sin(m x)\n$$\n其中振幅为 $A = 0.1$，波数 $m$ 为整数。对于精确解，只要解保持光滑（即在激波形成之前），总能量（由二次不变量 $E(t) = \\frac{1}{2} \\int_{0}^{2\\pi} u(x,t)^2 \\, dx$ 定义）是守恒的。在所有测试用例中，最终时间 $T=0.1$ 小于激波形成时间 $t_{shock} = 1/(Am)$，因此离散能量的任何变化都是数值产物。\n\n该解是通过首先在空间上半离散化偏微分方程，将其转换为常微分方程组（ODEs），然后在时间上对此系统进行积分来获得的。\n\n**空间离散化：傅里叶伪谱方法**\n空间域 $[0, 2\\pi)$ 使用 $N$ 个等距网格点 $x_j = j \\Delta x$（其中 $j = 0, 1, \\dots, N-1$）进行离散化，网格间距为 $\\Delta x = 2\\pi/N$。解 $u(x,t)$ 由其在这些网格点上的值向量 $\\vec{u}(t) = [u(x_0,t), u(x_1,t), \\dots, u(x_{N-1},t)]^T$ 表示。\n\n方程的半离散化形式为：\n$$\n\\frac{d\\vec{u}}{dt} = \\vec{F}(\\vec{u})\n$$\n其中 $\\vec{F}$ 是空间算子 $-\\partial_x \\left(\\frac{1}{2} u^2\\right)$ 的离散表示。伪谱方法（也称为配置法）用于计算 $\\vec{F}(\\vec{u})$。对于给定的状态向量 $\\vec{u}$，其过程如下：\n1.  在物理空间中逐点计算非线性通量项 $f(\\vec{u}) = \\frac{1}{2} \\vec{u}^2$。这是一个逐元素的平方运算。\n2.  使用快速傅里叶变换（FFT）将通量向量变换到傅里叶空间：$\\widehat{f} = \\mathrm{FFT}(f)$。\n3.  在傅里叶空间中计算空间导数。这是通过将每个傅里叶系数 $\\widehat{f}_k$ 乘以 $ik$ 来实现的，其中 $k$ 是离散角波数。波数由 $k = 2\\pi \\cdot \\mathrm{fftfreq}(N, \\Delta x)$ 给出，对于 $[0, 2\\pi]$ 域，这会产生整数波数。傅里叶空间中的导数为 $\\widehat{f'}_k = ik \\widehat{f}_k$。\n4.  使用逆快速傅里叶变换（IFFT）将结果变换回物理空间：$f' = \\mathrm{IFFT}(\\widehat{f'})$。\n5.  常微分方程组的右端项则为 $\\vec{F}(\\vec{u}) = -f'$。\n\n该方法对于光滑函数非常精确。然而，非线性步骤 $f(\\vec{u}) = \\frac{1}{2} \\vec{u}^2$ 会产生更高频率的模式。如果初始数据包含最高为波数 $m$ 的模式，则二次项将生成最高为波数 $2m$ 的模式。如果 $2m$ 超过网格的奈奎斯特波数 $k_{\\text{Nyquist}} = N/2$，这些高频分量将被错误地表示为较低频率的模式，这种现象称为混叠。问题规定不使用去混叠技术，这意味着这种混叠误差会污染解，并可能导致非物理的能量增长，即数值不稳定性。\n\n**时间离散化：四阶龙格－库塔（RK4）方法**\n常微分方程组 $\\frac{d\\vec{u}}{dt} = \\vec{F}(\\vec{u})$ 使用经典的四阶龙格－库塔方法在时间上进行推进。给定时间 $t_n$ 的解 $\\vec{u}^n$，下一个时间步 $t_{n+1} = t_n + \\Delta t_n$ 的解计算如下：\n$$\n\\begin{aligned}\n    \\vec{k}_1 &= \\vec{F}(\\vec{u}^n) \\\\\n    \\vec{k}_2 &= \\vec{F}(\\vec{u}^n + \\frac{\\Delta t_n}{2} \\vec{k}_1) \\\\\n    \\vec{k}_3 &= \\vec{F}(\\vec{u}^n + \\frac{\\Delta t_n}{2} \\vec{k}_2) \\\\\n    \\vec{k}_4 &= \\vec{F}(\\vec{u}^n + \\Delta t_n \\vec{k}_3) \\\\\n    \\vec{u}^{n+1} &= \\vec{u}^n + \\frac{\\Delta t_n}{6} (\\vec{k}_1 + 2\\vec{k}_2 + 2\\vec{k}_3 + \\vec{k}_4)\n\\end{aligned}\n$$\n时间步长 $\\Delta t_n$ 是自适应的，基于一个类CFL条件：$\\Delta t_n = c \\frac{\\Delta x}{\\max_j |u_j^n|}$，其中常数 $c = 0.2$。此步长在每个时间步开始时重新计算。为确保模拟恰好在时间 $T=0.1$ 结束，如有必要，将截断最后一个时间步。\n\n**能量计算**\n在给定时间 $t$ 的离散能量是使用均匀周期性网格上积分的梯形法则近似来计算的：\n$$\nE(t) = \\frac{1}{2} \\Delta x \\sum_{j=0}^{N-1} u(x_j, t)^2\n$$\n目标是计算能量放大因子 $R = E(T) / E(0)$。对于稳定、精细解析的数值模拟，我们期望 $R \\approx 1$。对于发生混叠不稳定性的解析不足的用例，我们期望 $R > 1$。\n\n四个测试用例探讨了不同的解析度状况：\n-   用例 1 ($N=256, m=16$): 精细解析 $(N/m = 16 \\gg 2)$。生成的最高波数为 $2m = 32$，远低于奈奎斯特极限 $N/2=128$。混叠可以忽略不计；$R$ 应非常接近 $1$。\n-   用例 2 ($N=64, m=32$): 奈奎斯特受限 $(N/m = 2)$。初始模式位于奈奎斯特频率。非线性项生成模式 $2m=64$，在此网格上混叠为波数 $k=0$。这会影响精度，但可能不会引起爆炸性增长。\n-   用例 3 ($N=64, m=40$): 解析不足 $(N/m = 1.6  2)$。初始模式 $m=40$ 被混叠为波数 $40 - 64 = -24$。非线性相互作用将是复杂的，并预计会导致能量增长，使得 $R  1$。\n-   用例 4 ($N=32, m=28$): 严重解析不足 $(N/m \\approx 1.14  2)$。初始模式 $m=28$ 被混叠为 $28 - 32 = -4$。这种严重的解析不足预计会产生显著的混叠诱发的不稳定性，并导致 $R$ 值远大于 $1$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D inviscid Burgers' equation using a Fourier pseudo-spectral method\n    and RK4 time integration to demonstrate aliasing instability.\n    \"\"\"\n    \n    # Fixed parameters for all test cases\n    A = 0.1\n    T = 0.1\n    CFL_CONST = 0.2\n\n    # Test cases: (N, m) pairs\n    test_cases = [\n        (256, 16),  # Case 1: Well-resolved\n        (64, 32),   # Case 2: Nyquist boundary\n        (64, 40),   # Case 3: Under-resolved\n        (32, 28),   # Case 4: Severely under-resolved\n    ]\n\n    results = []\n    for N, m in test_cases:\n        # 1. Setup grid, initial condition, and wavenumbers\n        dx = 2 * np.pi / N\n        x = np.arange(N) * dx\n        # Angular wavenumbers\n        k = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n        \n        u = A * np.sin(m * x)\n        t = 0.0\n\n        # Function to compute the RHS of the semi-discretized equation:\n        # d(u)/dt = -d/dx(0.5 * u^2)\n        def rhs(u_vec):\n            # Compute flux in physical space\n            flux = 0.5 * u_vec**2\n            # Transform to Fourier space\n            flux_hat = np.fft.fft(flux)\n            # Differentiate in Fourier space\n            d_flux_hat = 1j * k * flux_hat\n            # Transform back to physical space. np.fft.ifft handles 1/N normalization.\n            d_flux = np.fft.ifft(d_flux_hat)\n            # The result should be real; discard small imaginary parts from numerical error\n            return -d_flux.real\n\n        # 2. Compute initial discrete energy\n        E0 = 0.5 * dx * np.sum(u**2)\n        \n        if E0 == 0.0:\n            # If initial energy is zero, amplification is undefined or 1.\n            # This case won't be hit with the given parameters.\n            results.append(1.0)\n            continue\n            \n        # 3. Time integration loop\n        while t  T:\n            # Adaptive time step based on CFL-like condition\n            u_max = np.max(np.abs(u))\n            if u_max == 0.0:\n                dt = T - t  # Take one step to the end\n            else:\n                dt = CFL_CONST * dx / u_max\n            \n            # Truncate the last step to end exactly at T\n            if t + dt  T:\n                dt = T - t\n            \n            # Classical 4th-order Runge-Kutta step\n            k1 = rhs(u)\n            k2 = rhs(u + 0.5 * dt * k1)\n            k3 = rhs(u + 0.5 * dt * k2)\n            k4 = rhs(u + dt * k3)\n            u = u + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n            \n            t += dt\n\n        # 4. Compute final energy and amplification factor\n        ET = 0.5 * dx * np.sum(u**2)\n        R = ET / E0\n        results.append(R)\n\n    # Final print statement in the exact required format.\n    # Each value is rounded to exactly 6 digits after the decimal point.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2378405"}]}