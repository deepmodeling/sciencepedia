{"hands_on_practices": [{"introduction": "在数值计算中，一个看似无害的减法操作有时会引发“灾难性抵消”，导致相对精度的灾难性损失。本练习 [@problem_id:2370387] 将通过计算函数 $f(x) = \\dfrac{1 - \\cos(x)}{x^2}$ 在 $x$ 趋近于零时的值，直观地展示这一现象。你的任务是分析这种朴素计算为何会导致巨大的相对误差，并提出一个代数上等价但数值上稳定的计算方法。", "problem": "设一个实值函数由表达式 $f(x) = \\dfrac{1 - \\cos(x)}{x^{2}}$（当 $x \\neq 0$ 时）定义，输入为实数，单位为弧度，并由极限值 $f(0) = \\dfrac{1}{2}$ 定义。在有限精度算术中，当 $x$ 接近 $0$ 时，直接使用表达式 $f(x) = \\dfrac{1 - \\cos(x)}{x^{2}}$ 计算 $f(x)$ 会在分子中引发灾难性抵消，并导致最终结果产生巨大的相对误差。您的任务是量化此效应，并与一个在代数上等价但在 $x = 0$ 附近数值稳定的公式进行比较。\n\n要求：\n1) 将一个近似值 $a$ 相对于一个参考值 $t \\neq 0$ 的相对误差定义为 $\\left|\\dfrac{a - t}{t}\\right|$。\n\n2) 对于集合 $S = \\{\\, 0,\\; 10^{-16},\\; 10^{-12},\\; 10^{-8},\\; 10^{-1},\\; 1 \\,\\}$ 中的每个测试值（单位均为弧度），计算：\n- 将 $x$ 代入 $f(x) = \\dfrac{1 - \\cos(x)}{x^{2}}$（当 $x \\neq 0$ 时）得到的朴素计算值 $a_{\\mathrm{naive}}(x)$。当 $x = 0$ 时，该直接表达式无定义；在这种情况下，为此问题之目的，根据定义将朴素方法的相对误差视为 $+\\infty$。\n- 基于一个代数重构式的数值稳定计算值 $a_{\\mathrm{stable}}(x)$，该重构式在 $x \\neq 0$ 时与 $f(x)$ 完全相等，并且在 $x=0$ 处允许值为 $\\dfrac{1}{2}$ 的连续扩展。\n- $f(x)$ 的一个高精度参考值 $t(x)$，由以下绝对收敛级数定义\n$$\nt(x) \\;=\\; \\sum_{m=0}^{\\infty} (-1)^{m} \\dfrac{x^{2m}}{(2m+2)!},\n$$\n并理解为该级数在 $x=0$ 处的值为 $t(0) = \\dfrac{1}{2}$。\n\n3) 对于每个 $x \\in S$，计算两个相对误差\n$$\nE_{\\mathrm{naive}}(x) = \\left|\\dfrac{a_{\\mathrm{naive}}(x) - t(x)}{t(x)}\\right|, \\qquad\nE_{\\mathrm{stable}}(x) = \\left|\\dfrac{a_{\\mathrm{stable}}(x) - t(x)}{t(x)}\\right|.\n$$\n对于 $x=0$，根据此任务的定义，设置 $E_{\\mathrm{naive}}(0) = +\\infty$。所有量均为无量纲量，所有角度单位均为弧度。\n\n测试套件和最终输出规范：\n- 按顺序准确使用测试输入 $S = \\{\\, 0,\\; 10^{-16},\\; 10^{-12},\\; 10^{-8},\\; 10^{-1},\\; 1 \\,\\}$。\n- 您的程序应生成单行输出，该输出包含一个用方括号括起来的逗号分隔列表，其中每个条目对应于一个测试输入 $x \\in S$，并且本身是一个双元素列表 $[E_{\\mathrm{naive}}(x), E_{\\mathrm{stable}}(x)]$，顺序与 $S$ 中的顺序相同。例如，整体结构必须是\n$[[E_{\\mathrm{naive}}(0),E_{\\mathrm{stable}}(0)],[E_{\\mathrm{naive}}(10^{-16}),E_{\\mathrm{stable}}(10^{-16})],\\ldots,[E_{\\mathrm{naive}}(1),E_{\\mathrm{stable}}(1)]]$ 的形式。\n所有报告的值必须是实数浮点数；$E_{\\mathrm{naive}}(0)$ 允许为值 $+\\infty$。", "solution": "所述问题是有效的。这是一个在计算工程领域内定义明确、有科学依据且无歧义的问题，专门针对有限精度算术中的灾难性抵消现象。所有定义和参数均已提供，且不存在矛盾。因此，我们将着手给出一个完整的解决方案。\n\n任务是分析在计算 $x$ 趋近于零时函数 $f(x) = \\dfrac{1 - \\cos(x)}{x^{2}}$ 的数值误差。该函数在 $x=0$ 处的真值为其极限值，$f(0) = \\lim_{x \\to 0} \\dfrac{1 - \\cos(x)}{x^{2}} = \\dfrac{1}{2}$。\n\n首先，我们讨论计算 $f(x)$ 所需的三种方法。\n\n**1. 高精度参考值 $t(x)$**\n\n参考值 $t(x)$ 由以下无穷级数定义：\n$$\nt(x) = \\sum_{m=0}^{\\infty} (-1)^{m} \\dfrac{x^{2m}}{(2m+2)!}\n$$\n这是 $f(x)$ 的麦克劳林级数。其正确性可以通过从 $\\cos(x)$ 的级数开始验证：\n$$\n\\cos(x) = \\sum_{k=0}^{\\infty} (-1)^{k} \\dfrac{x^{2k}}{(2k)!} = 1 - \\dfrac{x^2}{2!} + \\dfrac{x^4}{4!} - \\dfrac{x^6}{6!} + \\dots\n$$\n由此，我们推导出分子 $1 - \\cos(x)$ 的级数：\n$$\n1 - \\cos(x) = 1 - \\left(1 - \\dfrac{x^2}{2!} + \\dfrac{x^4}{4!} - \\dots\\right) = \\dfrac{x^2}{2!} - \\dfrac{x^4}{4!} + \\dfrac{x^6}{6!} - \\dots = \\sum_{k=1}^{\\infty} (-1)^{k-1} \\dfrac{x^{2k}}{(2k)!}\n$$\n再除以 $x^2$ 得到 $f(x)$ 的级数：\n$$\nf(x) = \\dfrac{1 - \\cos(x)}{x^2} = \\sum_{k=1}^{\\infty} (-1)^{k-1} \\dfrac{x^{2k-2}}{(2k)!}\n$$\n通过替换指数 $m = k-1$，我们得到给定的 $t(x)$ 表达式：\n$$\nt(x) = \\sum_{m=0}^{\\infty} (-1)^{m} \\dfrac{x^{2m}}{(2(m+1))!} = \\sum_{m=0}^{\\infty} (-1)^{m} \\dfrac{x^{2m}}{(2m+2)!}\n$$\n为了计算，这个绝对收敛的级数将被截断。求和将迭代执行，不断添加项，直到新项的量级小到在标准双精度浮点算术中无法改变累加和为止。这确保了参考值达到机器所允许的最高精度。各项的计算将以递归方式进行以保持数值稳定性：如果 $c_m$ 是第 $m$ 项，则 $c_m = c_{m-1} \\cdot \\left( \\dfrac{-x^2}{(2m+1)(2m+2)} \\right)$。\n\n**2. 朴素计算 $a_{\\mathrm{naive}}(x)$**\n\n朴素计算使用直接表达式 $a_{\\mathrm{naive}}(x) = \\dfrac{1 - \\cos(x)}{x^2}$。当 $x$ 接近 $0$ 时, $\\cos(x)$ 非常接近 $1$。在有限精度算术中，减法 $1 - \\cos(x)$ 会损失巨大的相对精度。这是一个灾难性抵消的经典案例。例如，如果 $x$ 足够小（例如，$x < 10^{-8}$），在双精度下计算的 $\\cos(x)$ 可能与 $1$ 无法区分，导致分子计算结果恰好为 $0$，从而产生严重错误的结果和巨大的相对误差。对于 $x=0$，该表达式无定义，且规定相对误差 $E_{\\mathrm{naive}}(0)$ 为 $+\\infty$。\n\n**3. 数值稳定计算 $a_{\\mathrm{stable}}(x)$**\n\n为避免灾难性抵消，我们必须对表达式进行代数重构。我们使用半角三角恒等式 $1 - \\cos(x) = 2 \\sin^2(x/2)$。将此代入 $f(x)$ 的表达式中，得到：\n$$\nf(x) = \\dfrac{2 \\sin^2(x/2)}{x^2}\n$$\n这个形式可以重写以突显其在 $x=0$ 附近的良好性质：\n$$\nf(x) = 2 \\left( \\dfrac{\\sin(x/2)}{x} \\right)^2 = \\dfrac{2}{4} \\left( \\dfrac{\\sin(x/2)}{x/2} \\right)^2 = \\dfrac{1}{2} \\left( \\dfrac{\\sin(x/2)}{x/2} \\right)^2\n$$\n这就是我们的稳定公式 $a_{\\mathrm{stable}}(x)$。当 $x \\to 0$ 时，参数 $u=x/2$ 也趋近于 $0$。子表达式 $\\sin(u)/u$ 在计算上是稳定的，并能精确地逼近其极限值 $1$。因此，不会发生两个几乎相等的数相减的情况，从而实现了数值稳定性。对于 $x=0$，此公式被连续扩展至其极限值 $a_{\\mathrm{stable}}(0) = 1/2$。\n\n**计算流程与误差计算**\n\n对于每个测试值 $x \\in S = \\{\\, 0,\\; 10^{-16},\\; 10^{-12},\\; 10^{-8},\\; 10^{-1},\\; 1 \\,\\}$，我们将执行以下步骤：\n1.  使用收敛级数法计算参考值 $t(x)$。对于 $x=0$，$t(0)=1/2$。\n2.  使用各自的公式计算 $a_{\\mathrm{naive}}(x)$ 和 $a_{\\mathrm{stable}}(x)$。对于 $x=0$，$a_{\\mathrm{stable}}(0)=1/2$，而 $a_{\\mathrm{naive}}(0)$ 无定义。\n3.  按定义计算相对误差：\n    $$\n    E_{\\mathrm{naive}}(x) = \\left|\\dfrac{a_{\\mathrm{naive}}(x) - t(x)}{t(x)}\\right| \\quad \\text{和} \\quad E_{\\mathrm{stable}}(x) = \\left|\\dfrac{a_{\\mathrm{stable}}(x) - t(x)}{t(x)}\\right|\n    $$\n    根据定义，对于 $x=0$，我们将设置 $E_{\\mathrm{naive}}(0) = +\\infty$ 并计算 $E_{\\mathrm{stable}}(0) = \\left|\\dfrac{1/2 - 1/2}{1/2}\\right| = 0$。\n\n最终输出将是一个列表，其中包含测试集 $S$ 中每个 $x$ 对应的配对 $[E_{\\mathrm{naive}}(x), E_{\\mathrm{stable}}(x)]$，并按指定顺序排列。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef high_accuracy_f(x: float) -> float:\n    \"\"\"\n    Computes the reference value t(x) using its Maclaurin series expansion,\n    t(x) = sum_{m=0 to inf} (-1)^m * x^(2m) / (2m+2)!.\n    The sum is computed until the terms become negligible in double precision.\n    \"\"\"\n    if x == 0.0:\n        return 0.5\n\n    # Start with the m=0 term: (-1)^0 * x^0 / 2! = 1/2\n    term = 0.5\n    current_sum = term\n    x_sq = x * x\n\n    # Iterate for m = 1, 2, 3, ...\n    # The ratio term_m / term_{m-1} is -x^2 / ((2m+1)*(2m+2))\n    for m in range(1, 100): # 100 is a safe upper limit for convergence\n        term *= -x_sq / ((2 * m + 1) * (2 * m + 2))\n        \n        # Check if the term is too small to affect the sum in float64 precision.\n        if current_sum + term == current_sum:\n            break\n        \n        current_sum += term\n        \n    return current_sum\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating naive and stable relative errors for a set of test inputs.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [0.0, 1e-16, 1e-12, 1e-8, 1e-1, 1.0]\n\n    results = []\n    for x in test_cases:\n        # Special handling for x = 0 as per the problem definition.\n        if x == 0.0:\n            e_naive = np.inf\n            # a_stable(0) = 1/2, t(0) = 1/2, so the error is zero.\n            e_stable = 0.0\n            results.append([e_naive, e_stable])\n            continue\n\n        # 1. Compute the high-accuracy reference value t(x).\n        t_x = high_accuracy_f(x)\n\n        # 2. Compute the naive evaluation a_naive(x).\n        # This is subject to catastrophic cancellation for small x.\n        a_naive = (1.0 - np.cos(x)) / (x * x)\n\n        # 3. Compute the numerically stable evaluation a_stable(x).\n        # Using the formulation: 0.5 * (sin(x/2) / (x/2))^2\n        u = x / 2.0\n        # The ratio sin(u)/u is evaluated accurately by numpy for small u.\n        a_stable = 0.5 * (np.sin(u) / u)**2\n\n        # 4. Compute the relative errors.\n        # The reference t(x) will not be zero for the given test cases.\n        e_naive = np.abs((a_naive - t_x) / t_x)\n        e_stable = np.abs((a_stable - t_x) / t_x)\n        \n        results.append([e_naive, e_stable])\n\n    # Final print statement in the exact required format.\n    # The format is [[val1_0,val2_0],[val1_1,val2_1],...] with no spaces.\n    formatted_results = ','.join([f'[{e_n},{e_s}]' for e_n, e_s in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n\n```", "id": "2370387"}, {"introduction": "在求解非线性方程时，我们通常期望一个很小的残差（即函数值 $|f(x^*)|$ 接近零）意味着我们的近似解 $x^*$ 非常接近真解。然而，本练习 [@problem_id:2370347] 揭示了一个重要的例外情况，即所谓的“病态问题”。你将看到，对于一个具有高重数根的方程，一个极小的残差可能对应着一个相当大的绝对误差，这凸显了理解问题本身敏感度的重要性。", "problem": "在求解标量非线性方程 $f(x) = (x - 1)^{10} = 0$ 的根时，其真解为 $x^{\\dagger} = 1$。一个迭代求解器返回一个估计值 $x^{*}$，其测得的残差大小为 $\\lvert f(x^{*}) \\rvert = 10^{-12}$。仅使用残差和绝对误差的定义，确定绝对误差 $\\lvert x^{*} - x^{\\dagger} \\rvert$ 的大小。将您的答案四舍五入至四位有效数字。答案以纯数形式表示（不带单位）。", "solution": "对问题陈述进行验证。\n\n从问题陈述中提取的已知条件如下：\n1.  标量非线性方程为 $f(x) = (x - 1)^{10} = 0$。\n2.  真解为 $x^{\\dagger} = 1$。\n3.  来自求解器的估计根记为 $x^{*}$。\n4.  测得的残差大小为 $\\lvert f(x^{*}) \\rvert = 10^{-12}$。\n5.  目标是求绝对误差的大小，即 $\\lvert x^{*} - x^{\\dagger} \\rvert$。\n6.  最终数值答案必须四舍五入至四位有效数字。\n\n经判定，该问题是有效的。它在科学上基于数值分析的原理，特别是求根算法中的误差分析。这是一个适定问题，因为计算唯一解所需的所有信息均已提供。术语精确且客观。所选函数 $f(x) = (x - 1)^{10}$ 是一个经典例子，用于说明高重根的病态性概念，即非常小的残差并不能保证误差也很小。\n\n求解过程如下。\n\n绝对误差 $e_{abs}$ 的定义是近似值 $x^{*}$ 与真值 $x^{\\dagger}$ 之差的大小。\n$$e_{abs} = \\lvert x^{*} - x^{\\dagger} \\rvert$$\n已知真解为 $x^{\\dagger} = 1$，则绝对误差为：\n$$e_{abs} = \\lvert x^{*} - 1 \\rvert$$\n\n残差是函数在近似根 $x^{*}$ 处的值，即 $f(x^{*})$。问题给出了该残差的大小：\n$$\\lvert f(x^{*}) \\rvert = 10^{-12}$$\n函数为 $f(x) = (x - 1)^{10}$。将 $x^{*}$ 代入函数可得：\n$$f(x^{*}) = (x^{*} - 1)^{10}$$\n因此，残差的大小为：\n$$\\lvert (x^{*} - 1)^{10} \\rvert = 10^{-12}$$\n根据绝对值的性质 $\\lvert a^{n} \\rvert = \\lvert a \\rvert^{n}$（对于偶数整数指数 $n=10$），我们可以将表达式重写为：\n$$\\lvert x^{*} - 1 \\rvert^{10} = 10^{-12}$$\n我们注意到 $\\lvert x^{*} - 1 \\rvert$ 正是绝对误差 $e_{abs}$。将其代入方程可得：\n$$(e_{abs})^{10} = 10^{-12}$$\n为求解 $e_{abs}$，我们对等式两边取正10次方根：\n$$e_{abs} = \\left( 10^{-12} \\right)^{\\frac{1}{10}}$$\n使用指数法则 $(a^{b})^{c} = a^{bc}$，我们简化表达式：\n$$e_{abs} = 10^{-12 \\times \\frac{1}{10}} = 10^{-\\frac{12}{10}} = 10^{-1.2}$$\n问题要求将数值答案四舍五入至四位有效数字。我们计算 $10^{-1.2}$ 的值：\n$$e_{abs} \\approx 0.0630957344...$$\n要将其四舍五入至四位有效数字，我们确定前四位有效数字，即 $6$、$3$、$0$ 和 $9$。$9$ 后面的数字是 $5$，因此需要将最后一位有效数字向上取整。因此，$0.06309$ 向上取整后变为 $0.06310$。末尾的零是有效数字，必须保留以表示精度。\n\n因此，绝对误差的大小约为 $0.06310$。这个结果表明，对于一个高重根，一个非常小的残差（量级为 $10^{-12}$）可能对应一个相对较大的误差（量级为 $10^{-2}$），这是病态问题的一个标志。", "answer": "$$\\boxed{0.06310}$$", "id": "2370347"}, {"introduction": "计算机中的每一次浮点运算都会引入微小的舍入误差，虽然单个误差微不足道，但在数百万次运算后它们可能会累积成一个显著的误差。本练习 [@problem_id:2370321] 探讨了计算一个长级数（谐波级数）时，不同的求和顺序如何显著影响最终结果的准确性。通过比较升序求和与降序求和的误差，你将掌握一种提高数值计算精度的基本策略。", "problem": "考虑由部分级数定义的有限谐波数列和 $$S(N)=\\sum_{n=1}^{N}\\frac{1}{n}.$$ 令 $S_{\\text{asc}}(N)$ 表示使用双精度浮点运算按升序索引顺序 $n=1,2,\\dots,N$ 计算的和的结果，令 $S_{\\text{desc}}(N)$ 表示使用相同算法按降序索引顺序 $n=N,N-1,\\dots,1$ 计算的和的结果。定义近似值 $\\widehat{S}(N)$ 相对于精确数学值 $S(N)$ 的绝对误差为 $$E_{\\text{abs}}(\\widehat{S}(N))=\\left|\\widehat{S}(N)-S(N)\\right|.$$ 你的任务是，对每个指定的 $N$，计算数值对 $$\\big(E_{\\text{abs}}(S_{\\text{asc}}(N)),\\;E_{\\text{abs}}(S_{\\text{desc}}(N))\\big),$$ 其中所有算术运算均采用电气和电子工程师协会（IEEE）$754$ 标准的 binary64（双精度）浮点数进行。精确值 $S(N)$ 是如上定义的有限级数值。\n\n$N$ 值的测试集为：$N\\in\\{\\,1,\\;10^{4},\\;10^{6},\\;10^{7}\\,\\}$。\n\n不涉及物理单位。不使用角度。所有输出都必须是实数。你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：$$\\big[E_{\\text{abs}}(S_{\\text{asc}}(1)),\\,E_{\\text{abs}}(S_{\\text{desc}}(1)),\\,E_{\\text{abs}}(S_{\\text{asc}}(10^{4})),\\,E_{\\text{abs}}(S_{\\text{desc}}(10^{4})),\\,E_{\\text{abs}}(S_{\\text{asc}}(10^{6})),\\,E_{\\text{abs}}(S_{\\text{desc}}(10^{6})),\\,E_{\\text{abs}}(S_{\\text{asc}}(10^{7})),\\,E_{\\text{abs}}(S_{\\text{desc}}(10^{7}))\\big]$$最终输出必须是单行，且不得包含任何其他字符或文本。", "solution": "该问题要求分析在计算不同 $N$ 值下的有限谐波数列和 $S(N)=\\sum_{n=1}^{N}\\frac{1}{n}$ 时浮点误差的累积情况。我们需要比较两种求和顺序的结果：升序（$n=1, \\dots, N$）和降序（$n=N, \\dots, 1$），两者均使用 IEEE $754$ binary64（双精度）算法进行。目标是计算每个计算结果相对于该有限和的真实数学值的绝对误差。\n\n此问题是有效的。这是一个数值分析中的良态问题，它展示了浮点计算的一个基本原理：运算顺序至关重要。\n\n其核心科学原理在于浮点加法中舍入误差的管理。一个 IEEE $754$ 双精度数有一个固定大小的尾数（$52$ 位），这将其精度限制在约 $15$ 到 $17$ 个十进制数字。当两个量级差异悬殊的浮点数相加时，会发生精度损失。考虑加法 $x+y$，其中 $|x| \\gg |y|$。为了执行加法，必须对齐阶码。这涉及到将较小数 $y$ 的尾数向右移动。移出尾数容量的比特位将被丢弃。这种现象被称为吸收（absorption）或淹没（swamping），它会导致信息丢失。结果是，较小数 $y$ 的贡献被部分或完全丢失。\n\n让我们根据这一原理分析两种指定的求和方法。\n\n$1$. **升序求和, $S_{\\text{asc}}(N)$**:\n求和按 $S_{\\text{asc}}(N) = (\\dots((1 + \\frac{1}{2}) + \\frac{1}{3}) + \\dots + \\frac{1}{N})$ 的方式执行。\n项 $1/n$ 是按量级递减的顺序相加的。部分和在开始时增长迅速。对于大的 $n$，项 $1/n$ 相对于累积的部分和变得非常小。例如，谐波数列呈对数增长，即 $S(N) \\approx \\ln(N) + \\gamma$，其中 $\\gamma$ 是 Euler–Mascheroni 常数。对于 $N=10^7$，$S(10^7) \\approx \\ln(10^7) \\approx 16.1$。最后加入的项是 $1/10^7 = 10^{-7}$。将 $10^{-7}$ 加到一个量级约为 $16.1$ 的数上将导致显著的精度损失。累积和的量级很大，重复向其添加小值会导致吸收误差的系统性累积。因此，我们预测 $S_{\\text{asc}}(N)$ 将是精度较低的方法。\n\n$2$. **降序求和, $S_{\\text{desc}}(N)$**:\n求和按 $S_{\\text{desc}}(N) = (\\dots((\\frac{1}{N} + \\frac{1}{N-1}) + \\frac{1}{N-2}) + \\dots + 1)$ 的方式执行。\n这里，各项是按量级递增的顺序相加的。求和从最小的项开始。部分和增长缓慢。在每一步中，相加的两个数（当前的部分和与下一项）的量级更有可能相当。这最大限度地减少了尾数的右移，从而减少了每一步的精度损失。这种技术是提高对正向单调递减序列求和准确性的通用启发式方法。我们预测 $S_{\\text{desc}}(N)$ 的精度将显著高于 $S_{\\text{asc}}(N)$。\n\n$3$. **参考值, $S(N)$**:\n为了计算绝对误差 $E_{\\text{abs}}(\\widehat{S}(N))=\\left|\\widehat{S}(N)-S(N)\\right|$，我们需要真实数学和 $S(N)$ 的一个高精度表示。由于我们的计算 $\\widehat{S}(N)$ 是以双精度（约 $16$ 位十进制精度）进行的，我们的参考值必须具有高得多的精度，才能在此目的下被视为“精确”值。例如，使用 $50$ 位十进制数字的精度就绰绰有余了。我们将为此任务使用一个高精度算术库。Python 的 `decimal` 模块提供了必要的功能。\n\n$4$. **算法**:\n对于测试集 $\\{1, 10^4, 10^6, 10^7\\}$ 中的每个 $N$ 值，将执行以下步骤：\n- 对于 $N=1$，情况很简单。$S(1) = 1$，$S_{\\text{asc}}(1) = 1.0$，$S_{\\text{desc}}(1) = 1.0$。数字 $1.0$ 可以被精确表示，因此两个误差都将恰好为 $0$。\n- 对于 $N > 1$:\n    - **步骤 4.1：计算参考和。** 我们将任意精度算术工具（Python 的 `decimal` 模块）的精度设置为 $50$ 位。然后我们使用这个高精度计算 $S(N) = \\sum_{n=1}^{N} \\frac{1}{n}$。结果将作为 `Decimal` 对象存储。\n    - **步骤 4.2：计算升序和。** 一个 `numpy.float64` 变量 `sum_asc` 初始化为 $0.0$。我们从 $n=1$ 迭代到 $N$ 并累加求和 `sum_asc = sum_asc + 1.0/n`。这些项被显式转换为 `float64` 以确保算术运算以正确的精度执行。\n    - **步骤 4.3：计算降序和。** 一个 `numpy.float64` 变量 `sum_desc` 初始化为 $0.0$。我们从 $n=N$ 向下迭代到 $1$ 并累加求和 `sum_desc = sum_desc + 1.0/n`。\n    - **步骤 4.4：计算绝对误差。** 绝对误差计算如下：\n        $$E_{\\text{abs}}(S_{\\text{asc}}(N)) = \\left| \\text{Decimal}(sum\\_asc) - S(N) \\right|$$\n        $$E_{\\text{abs}}(S_{\\text{desc}}(N)) = \\left| \\text{Decimal}(sum\\_desc) - S(N) \\right|$$\n        通过在减法之前将 `float64` 结果转换为 `Decimal` 对象，我们以高精度执行减法，避免了参考值本身的任何精度损失。最终结果是这个差值的绝对值。\n\n将实施此过程以生成八个所需的误差值，并按问题陈述中指定的顺序排列。预计结果将显示，对于大的 $N$，升序和的误差显著大于降序和的误差，从而证实我们的理论分析。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom decimal import Decimal, getcontext\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [1, 10**4, 10**6, 10**7]\n\n    results = []\n\n    # Set precision for the high-accuracy reference calculation.\n    # 50 digits is sufficient to be an \"exact\" reference for double-precision (approx. 16 digits).\n    getcontext().prec = 50\n\n    for N in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        \n        # For N=1, the sums are trivially exact (1.0), so errors are 0.\n        if N == 1:\n            results.extend([0.0, 0.0])\n            continue\n\n        # 1. Compute the reference value S(N) using high-precision arithmetic.\n        # This serves as the \"exact\" value for error calculation.\n        s_exact = Decimal(0)\n        one_decimal = Decimal(1)\n        # Summation order for the exact value does not matter here due to high precision.\n        for i in range(1, N + 1):\n            s_exact += one_decimal / Decimal(i)\n\n        # 2. Compute S_asc(N) summing in ascending order (1 to N).\n        # This is expected to be less accurate due to adding small numbers to a large accumulator.\n        s_asc = np.float64(0.0)\n        for i in range(1, N + 1):\n            # Using np.float64 ensures IEEE 754 double-precision arithmetic.\n            s_asc += np.float64(1.0) / np.float64(i)\n\n        # 3. Compute S_desc(N) summing in descending order (N to 1).\n        # This is expected to be more accurate as it sums numbers of similar magnitude first.\n        s_desc = np.float64(0.0)\n        for i in range(N, 0, -1):\n            s_desc += np.float64(1.0) / np.float64(i)\n\n        # 4. Calculate absolute errors against the high-precision reference.\n        # The float64 results are converted to Decimal to perform the subtraction\n        # at high precision, preserving the accuracy of the reference value.\n        error_asc = abs(Decimal(s_asc) - s_exact)\n        error_desc = abs(Decimal(s_desc) - s_exact)\n        \n        # Append results as standard Python floats.\n        results.extend([float(error_asc), float(error_desc)])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2370321"}]}