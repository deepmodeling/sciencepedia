{"hands_on_practices": [{"introduction": "我们从一个基本但至关重要的实践开始，它将测量不确定度与有效数字的报告方式直接联系起来。通过一个常见的摄氏度到开尔文的温度转换任务，我们将探讨当一个精确值（即没有不确定度的值）与一个测量值相加时，不确定度是如何传播的。这个练习旨在巩固一条核心原则：最终结果的绝对不确定度决定了其应报告至哪一位小数，从而确定了有效数字的位数 [@problem_id:2952336]。", "problem": "一个用摄氏温标校准的定容温度计，测得一个与充分搅拌的热浴处于平衡状态的液体样品的温度为 $25.0 \\pm 0.2\\,^{\\circ}\\text{C}$。利用一开尔文的大小与一摄氏度的大小完全相等，以及开尔文温标和摄氏温标之间相差一个精确的偏移量这一事实，将此测量值转换为开尔文温标，并正确地传递其绝对不确定度。然后，通过引用具有不确定度的测量量的有效数字基本定义，以及常数加法下不确定度的传递规则，确定报告的开尔文值应保留多少位有效数字。将引用的 $\\pm 0.2$ 解读为一个已经适当取整的绝对对称不确定度，不要对其进行再次取整。\n\n仅报告开尔文温度的中心值，并根据您的不确定度分析将其取整至合理的有效数字位数。以 $\\mathrm{K}$ 为单位，用一个数字表示您的最终答案。您的取整必须由不确定度决定，因此也由有效数字决定，而不是由固定的小数位规则决定。", "solution": "题目要求将一个温度测量值从摄氏温标转换为开尔文温标，并伴随着严格的不确定度传递以及确定最终结果的适当有效数字位数。\n\n初始测量值以摄氏度为单位给出，即温度 $T_C$ 及其相关的绝对不确定度 $\\delta T_C$。\n$$T_C = 25.0\\,^{\\circ}\\text{C}$$\n$$\\delta T_C = 0.2\\,^{\\circ}\\text{C}$$\n\n开尔文温标 ($T_K$) 和摄氏温标 ($T_C$) 之间的关系由一个精确的加法偏移量定义。一开尔文的大小与一摄氏度的大小相同。转换公式为：\n$$T_K = T_C + 273.15$$\n在这个定义中，数值 $273.15$ 是一个精确常数，意味着它的不确定度为零 ($\\delta(273.15) = 0$)。\n\n首先，我们转换温度的中心值：\n$$T_K = 25.0 + 273.15 = 298.15 \\, \\mathrm{K}$$\n\n接下来，我们必须传递不确定度。对于函数 $Z = f(X, Y, \\dots)$，（假设变量是独立的）不确定度传递的通用公式由各变量贡献的平方和给出：\n$$(\\delta Z)^2 = \\left(\\frac{\\partial f}{\\partial X}\\right)^2 (\\delta X)^2 + \\left(\\frac{\\partial f}{\\partial Y}\\right)^2 (\\delta Y)^2 + \\dots$$\n在我们的例子中，函数是 $T_K = T_C + K_0$，其中 $K_0 = 273.15$ 是一个常数。唯一具有不确定度的变量是 $T_C$。$K_0$ 的不确定度为零，即 $\\delta K_0 = 0$。\n因此，开尔文温度的传递不确定度 $\\delta T_K$ 为：\n$$(\\delta T_K)^2 = \\left(\\frac{\\partial T_K}{\\partial T_C}\\right)^2 (\\delta T_C)^2 + \\left(\\frac{\\partial T_K}{\\partial K_0}\\right)^2 (\\delta K_0)^2$$\n偏导数是：\n$$\\frac{\\partial T_K}{\\partial T_C} = \\frac{\\partial}{\\partial T_C}(T_C + K_0) = 1$$\n$$\\frac{\\partial T_K}{\\partial K_0} = \\frac{\\partial}{\\partial K_0}(T_C + K_0) = 1$$\n将这些代入不确定度公式：\n$$(\\delta T_K)^2 = (1)^2 (\\delta T_C)^2 + (1)^2 (0)^2 = (\\delta T_C)^2$$\n因此，开尔文温度的绝对不确定度与摄氏温度的绝对不确定度相同：\n$$\\delta T_K = \\delta T_C = 0.2 \\, \\mathrm{K}$$\n\n在考虑有效数字的惯例之前，开尔文温度的完整结果是：\n$$T_K = 298.15 \\pm 0.2 \\, \\mathrm{K}$$\n\n报告测量量的基本原则是：中心值的最后一位有效数字应与其不确定度的最高有效数字位于相同的小数位上。这确保了数值的标明精度与其计算或测量的不确定度相一致。\n\n在我们的结果中，不确定度 $\\delta T_K = 0.2 \\, \\mathrm{K}$ 的最高有效（也是唯一）数字在十分位。因此，温度的中心值必须四舍五入到十分位。\n\n计算出的中心值是 $298.15 \\, \\mathrm{K}$。将此值四舍五入到最近的十分位得到：\n$$298.15 \\rightarrow 298.2$$\n包含不确定度的最终报告结果将是 $T_K = 298.2 \\pm 0.2 \\, \\mathrm{K}$。中心值 $298.2$ 有四位有效数字。这个有效数字的位数不是通过计算输入数据中的数字位数来确定的，而是通过正确的不确定度传递来证明的。\n\n问题要求给出经此分析证明为合理的有效数字位数的开尔文温度中心值。这个值是 $298.2$。", "answer": "$$\\boxed{298.2}$$", "id": "2952336"}, {"introduction": "在计算工程中，一个理论上正确的公式在实际应用中可能会因为数值不稳定性而失效。这个实践通过计算两个几乎相切的圆之间的微小重叠面积，生动地揭示了“灾难性抵消”这一常见陷阱，即两个几乎相等的大数相减会导致有效数字的严重损失。通过对比直接计算与经过几何重构的稳定算法，您将亲身体会到选择正确计算路径的重要性，并学习如何在此类情况下进行可靠的不确定度分析 [@problem_id:2432439]。", "problem": "使用平面成像测量仪检查一个加工零件上两个近乎相切的圆孔之间的微小重叠（“薄片”）。这两个孔被建模为半径为 $R_1$ 和 $R_2$ 的圆，其圆心距为 $d$。测量值和单标准差标准不确定度如下：\n- $R_1 = 50.000 \\ \\mathrm{mm}$，其 $u_{R_1} = 0.001 \\ \\mathrm{mm}$，\n- $R_2 = 80.000 \\ \\mathrm{mm}$，其 $u_{R_2} = 0.001 \\ \\mathrm{mm}$，\n- $d = 129.950 \\ \\mathrm{mm}$，其 $u_{d} = 0.001 \\ \\mathrm{mm}$。\n\n这个微小的重叠区域（一个透镜状薄片）是两个圆盘的交集。要求你计算其面积两次：\n1) 从平面几何的基本原理出发：将每个弓形的面积写为（扇形面积）减去（等腰三角形面积），用构型几何表示扇形角，然后将两个弓形的面积相加，得到精确的透镜面积。所有三角函数均使用弧度制。\n2) 为避免微小重叠情况下的灾难性抵消，重新表述几何关系：用每个弓形的弓高 $h$ 对其进行参数化，并从小角度展开出发，推导出用 $R$ 和 $h$ 表示的弓形面积的前导阶稳定表达式。对两个圆计算此稳定近似值并求和。\n\n然后，使用一个对微小重叠有效、经适当简化且有物理解释的近似公式的偏导数，将 $R_1$、$R_2$ 和 $d$ 的不确定度进行一阶（线性）传播，以计算透镜面积的不确定度。\n\n根据你的不确定度估计值，选择合适的有效数字位数来报告该面积。根据本题要求，将最终报告的面积四舍五入到两位有效数字。最终面积以 $\\mathrm{mm}^2$ 为单位表示。\n\n你的最终数值答案必须是一个实数。不要在最终的方框值中包含单位。始终使用弧度制。", "solution": "本任务是计算两个半径为 $R_1$ 和 $R_2$、圆心距为 $d$ 的圆之间的相交面积（透镜）。首先使用精确几何方法，然后使用一种针对微小重叠情况的数值稳定近似方法。最后，我们传播测量不确定度并设定合适的有效数字。\n\n基本几何基础：\n- 半径为 $R$、圆心角为 $2\\theta$（以弧度计）的扇形面积为 $R^2 \\theta$。\n- 边长为 $R$、$R$ 且夹角为 $2\\theta$ 的相关等腰三角形的面积为 $\\tfrac{1}{2} R^2 \\sin(2\\theta)$。\n- 因此，由一条对向角为 $2\\theta$ 的弦从半径为 $R$ 的圆上切下的弓形面积为 $R^2\\left(\\theta - \\sin\\theta \\cos\\theta\\right)$，因为 $\\sin\\theta \\cos\\theta = \\tfrac{1}{2}\\sin(2\\theta)$。\n- 根据在由两个圆心和任一交点构成的三角形中应用的余弦定理，与透镜的两个弓形对应的中心半角 $\\theta_1$ 和 $\\theta_2$ 满足：\n$$\n\\cos\\theta_1 = \\frac{d^2 + R_1^2 - R_2^2}{2 d R_1}, \\qquad\n\\cos\\theta_2 = \\frac{d^2 + R_2^2 - R_1^2}{2 d R_2}.\n$$\n\n精确计算（标准公式，在重叠很小时容易发生抵消）：\n- 给定 $R_1 = 50.000 \\ \\mathrm{mm}$、$R_2 = 80.000 \\ \\mathrm{mm}$、$d = 129.950 \\ \\mathrm{mm}$，计算\n$$\nd^2 = (129.950)^2 = 16887.0025 \\ \\mathrm{mm}^2.\n$$\n然后\n$$\n\\cos\\theta_1 = \\frac{16887.0025 + 50.000^2 - 80.000^2}{2\\cdot 129.950 \\cdot 50.000}\n= \\frac{16887.0025 + 2500 - 6400}{12995}\n= \\frac{12987.0025}{12995} \\approx 0.9993843,\n$$\n$$\n\\cos\\theta_2 = \\frac{16887.0025 + 80.000^2 - 50.000^2}{2\\cdot 129.950 \\cdot 80.000}\n= \\frac{16887.0025 + 6400 - 2500}{20792}\n= \\frac{20787.0025}{20792} \\approx 0.9997600.\n$$\n因此\n$$\n\\theta_1 \\approx \\arccos(0.9993843) \\approx 0.03509 \\ \\text{rad}, \\qquad\n\\theta_2 \\approx \\arccos(0.9997600) \\approx 0.02192 \\ \\text{rad}.\n$$\n两个弓形的面积为\n$$\nA_1^{\\mathrm{exact}} = R_1^2\\left(\\theta_1 - \\sin\\theta_1 \\cos\\theta_1\\right), \\qquad\nA_2^{\\mathrm{exact}} = R_2^2\\left(\\theta_2 - \\sin\\theta_2 \\cos\\theta_2\\right),\n$$\n透镜面积为 $A^{\\mathrm{exact}} = A_1^{\\mathrm{exact}} + A_2^{\\mathrm{exact}}$。\n\n在数值上，对于每个弓形，中间的扇形和三角形项都很大且几乎相等：\n- 对第一个圆，$R_1^2 \\theta_1 \\approx 2500 \\times 0.03509 \\approx 87.7 \\ \\mathrm{mm}^2$，而 $R_1^2 \\sin\\theta_1 \\cos\\theta_1 \\approx 2500 \\times \\tfrac{1}{2}\\sin(2\\theta_1) \\approx 87.6 \\ \\mathrm{mm}^2$。它们的差仅为 $\\approx 0.072 \\ \\mathrm{mm}^2$。\n- 对第二个圆，$R_2^2 \\theta_2 \\approx 6400 \\times 0.02192 \\approx 140.3 \\ \\mathrm{mm}^2$，而 $R_2^2 \\sin\\theta_2 \\cos\\theta_2 \\approx 6400 \\times \\tfrac{1}{2}\\sin(2\\theta_2) \\approx 140.2 \\ \\mathrm{mm}^2$。它们的差仅为 $\\approx 0.045 \\ \\mathrm{mm}^2$。\n\n减去几乎相等的大数是数值病态的，并且容易丢失有效数字（相减抵消），尤其是在重叠极小的情况下。合并的精确值（如果用足够高的精度计算）是\n$$\nA^{\\mathrm{exact}} \\approx 0.11695 \\ \\mathrm{mm}^2,\n$$\n但如果简单直接地计算，这条路径对舍入误差很敏感。\n\n针对微小重叠的稳定几何重构：\n引入两个弓形的弓高 $h_1$ 和 $h_2$。设 $x_1$ 是从圆1的圆心沿连心线到公共弦的距离。根据几何关系，\n$$\nx_1 = \\frac{d^2 + R_1^2 - R_2^2}{2d}, \\qquad h_1 = R_1 - x_1,\n$$\n类似地，$x_2 = d - x_1$，$h_2 = R_2 - x_2$。代入给定数值，\n$$\nx_1 = \\frac{16887.0025 + 2500 - 6400}{2\\cdot 129.950} = \\frac{12987.0025}{259.9} \\approx 49.96923 \\ \\mathrm{mm},\n$$\n$$\nh_1 = 50.000 - 49.96923 \\approx 0.030771 \\ \\mathrm{mm}, \\quad\nx_2 = 129.950 - 49.96923 \\approx 79.98077 \\ \\mathrm{mm}, \\quad\nh_2 = 80.000 - 79.98077 \\approx 0.019229 \\ \\mathrm{mm}.\n$$\n对于一个半径为 $R$、弓高为 $h$ 的非常小的弓形，从精确的弓形面积公式 $R^2\\left(\\theta - \\sin\\theta \\cos\\theta\\right)$ 出发，其中 $\\cos\\theta = (R-h)/R$，并对小角度 $\\theta$ 进行展开：\n$$\n\\sin\\theta \\cos\\theta = \\tfrac{1}{2}\\sin(2\\theta) = \\theta - \\frac{2}{3}\\theta^3 + O(\\theta^5),\n$$\n所以\n$$\n\\theta - \\sin\\theta \\cos\\theta = \\frac{2}{3}\\theta^3 + O(\\theta^5).\n$$\n由于 $h = R(1 - \\cos\\theta) = \\tfrac{1}{2}R \\theta^2 + O(\\theta^4)$，前导阶关系 $\\theta \\approx \\sqrt{2h/R}$ 得出稳定的前导阶弓形面积为\n$$\nA_{\\mathrm{seg}}(R,h) \\approx \\frac{4}{3} \\sqrt{2R} \\, h^{3/2}.\n$$\n对每个圆进行计算：\n$$\nA_1^{\\mathrm{stab}} \\approx \\frac{4}{3}\\sqrt{2\\cdot 50.000}\\,(0.030771)^{3/2}\n= \\frac{40}{3}\\,(0.030771)^{3/2} \\approx 0.07198 \\ \\mathrm{mm}^2,\n$$\n$$\nA_2^{\\mathrm{stab}} \\approx \\frac{4}{3}\\sqrt{2\\cdot 80.000}\\,(0.019229)^{3/2}\n\\approx 16.86548 \\times (0.019229)^{3/2} \\approx 0.04497 \\ \\mathrm{mm}^2.\n$$\n求和，\n$$\nA^{\\mathrm{stab}} = A_1^{\\mathrm{stab}} + A_2^{\\mathrm{stab}} \\approx 0.11695 \\ \\mathrm{mm}^2.\n$$\n小角度展开中被忽略的主要项是 $O(\\theta^5)$，在此处产生的相对误差量级为 $0.1 \\%$ 或更小，与接下来要估计的测量不确定度相比可以忽略不计。\n\n不确定度传播和有效数字：\n对于近乎相切的圆，将稳定近似式以重叠深度 $\\epsilon = R_1 + R_2 - d$ 和半径和 $S = R_1 + R_2$ 表示成紧凑形式会很方便。\n$$\nA \\approx \\frac{4}{3} \\sqrt{\\frac{2 R_1 R_2}{S}} \\, \\epsilon^{3/2}, \\quad \\text{其中} \\quad \\epsilon = R_1 + R_2 - d, \\ S = R_1 + R_2.\n$$\n为了进行不确定度传播，将 $R_1$、$R_2$ 和 $d$ 视为独立的变量。使用 $A(R_1,R_2,d)$ 的偏导数进行一阶（线性）传播，\n$$\n\\frac{\\partial A}{\\partial d} = -\\frac{3}{2}\\frac{A}{\\epsilon}, \\quad\n\\frac{\\partial A}{\\partial R_1} = A\\left[\\frac{1}{2}\\left(\\frac{1}{R_1} - \\frac{1}{S}\\right) + \\frac{3}{2}\\frac{1}{\\epsilon}\\right], \\quad\n\\frac{\\partial A}{\\partial R_2} = A\\left[\\frac{1}{2}\\left(\\frac{1}{R_2} - \\frac{1}{S}\\right) + \\frac{3}{2}\\frac{1}{\\epsilon}\\right].\n$$\n当 $R_1 = 50.000 \\ \\mathrm{mm}$、$R_2 = 80.000 \\ \\mathrm{mm}$、$S = 130.000 \\ \\mathrm{mm}$、$\\epsilon = 0.050 \\ \\mathrm{mm}$ 且 $A \\approx 0.11695 \\ \\mathrm{mm}^2$ 时，\n$$\n\\left|\\frac{\\partial A}{\\partial d}\\right| \\approx \\frac{3}{2}\\frac{0.11695}{0.050} \\approx 3.5085 \\ \\mathrm{mm},\n$$\n$$\n\\left|\\frac{\\partial A}{\\partial R_1}\\right| \\approx 0.11695\\left[ \\frac{1}{2}\\left(\\frac{1}{50} - \\frac{1}{130}\\right) + \\frac{3}{2}\\frac{1}{0.050} \\right] \\approx 3.509 \\ \\mathrm{mm},\n$$\n$$\n\\left|\\frac{\\partial A}{\\partial R_2}\\right| \\approx 0.11695\\left[ \\frac{1}{2}\\left(\\frac{1}{80} - \\frac{1}{130}\\right) + \\frac{3}{2}\\frac{1}{0.050} \\right] \\approx 3.509 \\ \\mathrm{mm}.\n$$\n当 $u_{R_1} = u_{R_2} = u_d = 0.001 \\ \\mathrm{mm}$ 时，合成标准不确定度为\n$$\nu_A \\approx \\sqrt{\\left(\\frac{\\partial A}{\\partial R_1}u_{R_1}\\right)^2 + \\left(\\frac{\\partial A}{\\partial R_2}u_{R_2}\\right)^2 + \\left(\\frac{\\partial A}{\\partial d}u_d\\right)^2}\n\\approx \\sqrt{(0.003509)^2 + (0.003509)^2 + (0.003509)^2}\n\\approx 0.00608 \\ \\mathrm{mm}^2.\n$$\n相对标准不确定度为 $u_A/A \\approx 0.00608/0.11695 \\approx 0.052 \\ (\\text{约 } 5.2\\%)$，这支持将面积报告为大约两位有效数字。\n\n因此，采纳数值稳定的计算值，并根据题目要求将最终面积四舍五入到两位有效数字，即可得出所报告的面积。\n\n最终数值（按要求，方框内不含单位）：当以 $\\mathrm{mm}^2$ 表示时为 $0.12$。", "answer": "$$\\boxed{0.12}$$", "id": "2432439"}, {"introduction": "有时，数值解的精度损失并非源于算法缺陷，而是问题本身的“病态”性质。本练习将引导您探索著名的病态矩阵——希尔伯特矩阵（Hilbert matrix），并求解相关的线性方程组 $H\\vec{x} = \\vec{b}$。您将量化分析，即使对右侧向量 $\\vec{b}$ 施加微乎其微的扰动，解向量 $\\hat{x}$ 的精度也会发生灾难性的下降。这个实践旨在揭示“条件数”作为误差放大因子的关键作用，并强调在求解看似简单的线性系统时，评估问题内在稳定性的必要性 [@problem_id:2432471]。", "problem": "一位工程师需要评估，对于一个具有病态系数矩阵的线性系统，其数值解中有多少位有效数字是可信的。考虑一个 $n$ 阶 Hilbert 矩阵，其定义为 $H \\in \\mathbb{R}^{n \\times n}$，矩阵元素为 $H_{i,j} = \\dfrac{1}{i + j - 1}$，其中 $1 \\leq i,j \\leq n$。对于 $n = 8$ 的情况，设精确解为 $x^{\\mathrm{true}} \\in \\mathbb{R}^{8}$，其所有分量 $x^{\\mathrm{true}}_i = 1$，并定义 $b = H x^{\\mathrm{true}}$。在所有计算中，假设使用由电气和电子工程师协会 (Institute of Electrical and Electronics Engineers, IEEE) $754$ binary64 格式定义的标准双精度浮点运算。\n\n定义计算解 $\\hat{x}$ 相对于精确解 $x^{\\mathrm{true}}$ 的正确有效数字位数 $s$ 为\n$$\ns = \\max\\left(0,\\; -\\log_{10}\\left(\\frac{\\lVert \\hat{x} - x^{\\mathrm{true}} \\rVert_2}{\\lVert x^{\\mathrm{true}} \\rVert_2}\\right)\\right).\n$$\n\n您的任务是编写一个完整的程序，针对以下四个测试用例，通过求解 $H \\hat{x} = \\tilde{b}$ 计算出 $\\hat{x}$，然后报告每个用例的 $s$ 值：\n\n- 测试用例 1 (基准)：$\\tilde{b} = b$。\n- 测试用例 2 (舍入右端项)：$\\tilde{b}$ 是将 $b$ 的每个分量舍入到 $k = 8$ 位十进制有效数字得到的。\n- 测试用例 3 (更大幅度的舍入)：$\\tilde{b}$ 是将 $b$ 的每个分量舍入到 $k = 6$ 位十进制有效数字得到的。\n- 测试用例 4 (确定性的分量级相对扰动)：$\\tilde{b}$ 的分量定义为 $\\tilde{b}_i = b_i + \\delta b_i$，其中 $\\delta b_i = 10^{-12} \\cdot (-1)^i \\cdot |b_i|$，$i = 1,2,\\dots,8$。\n\n要求和约定：\n- 根据其定义 $H_{i,j} = \\dfrac{1}{i + j - 1}$ 构造 $n = 8$ 的矩阵 $H$。\n- 使用所有分量均为 $1$ 的 $x^{\\mathrm{true}}$，因此 $b = H x^{\\mathrm{true}}$ 可由 $H$ 和 $x^{\\mathrm{true}}$ 精确确定。\n- 对于实数 $y \\neq 0$，实现舍入到 $k$ 位有效数字的操作，即把 $y$ 舍入到具有 $k$ 位有效数字的最近小数，并将 $0$ 映为 $0$。\n- 使用欧几里得范数 $\\lVert \\cdot \\rVert_2$ 根据上述公式计算 $s$。\n\n测试套件和输出规范：\n- 四个测试用例的定义与上文完全一致，并且必须按 $1,2,3,4$ 的顺序进行评估。\n- 对于每个测试用例，将 $s$ 计算为浮点数。\n- 您的程序应生成单行输出，其中包含一个 Python 风格的列表，内含四个 $s$ 值，这些值需舍入到 3 位小数，并按 $[s_1,s_2,s_3,s_4]$ 的顺序排列，分别对应测试用例 1 到 4。\n- 不涉及物理单位。不出现角度。不使用百分比；所有量均为实数。\n\n您的最终程序必须是自包含的，且不需要任何输入。它必须严格按照指定格式输出一行。", "solution": "所提出的问题是数值线性代数中一个有效且适定的练习，旨在探讨病态条件对线性系统解精度的影响。该问题具有科学依据，没有歧义，并为获得唯一的计算解提供了所有必要的信息。该问题要求分析线性系统 $H\\hat{x} = \\tilde{b}$ 中右端向量的扰动如何影响解 $\\hat{x}$，其中 $H$ 是以病态而著称的 Hilbert 矩阵。这是数值不稳定性的一个经典示例，而数值不稳定性是计算工程中的一个关键概念。\n\n问题的核心在于系数矩阵的性质。$n$ 阶 Hilbert 矩阵，其元素为 $H_{ij} = (i+j-1)^{-1}$，是一个对称正定矩阵。然而，其条件数 $\\kappa(H) = \\lVert H \\rVert \\lVert H^{-1} \\rVert$ 随阶数 $n$ 的增长而异常迅速地增大。对于指定的阶数 $n=8$，关于欧几里得范数的条件数 $\\kappa_2(H_8)$ 约为 $1.5 \\times 10^{10}$。\n\n线性系统扰动理论中的一个基本结果指出，对于右端向量 $b$ 中的扰动 $\\delta b$，解 $x$ 中产生的相对误差的界为：\n$$\n\\frac{\\lVert \\delta x \\rVert_2}{\\lVert x^{\\mathrm{true}} \\rVert_2} \\leq \\kappa_2(H) \\frac{\\lVert \\delta b \\rVert_2}{\\lVert b \\rVert_2}\n$$\n其中 $\\delta x = \\hat{x} - x^{\\mathrm{true}}$ 且 $\\delta b = \\tilde{b} - b$。这个不等式表明，条件数充当了输入数据相对误差的放大因子。标准双精度 (binary64) 算术提供大约 15 到 17 位的十进制精度。在条件数约为 $10^{10}$ 的情况下，即使不考虑对右端项的任何显式扰动，我们也可以预期至少会损失 $\\log_{10}(1.5 \\times 10^{10}) \\approx 10.2$ 位的十进制精度。\n\n求解过程如下：\n\n1.  **矩阵和向量的构造**：首先，我们根据定义 $H_{ij} = (i+j-1)^{-1}$ 构造 $8 \\times 8$ 的 Hilbert 矩阵 $H$。在数组实现中，我们必须使用从 0 开始的索引，因此位于 `(row, col)` 索引 `i`, `j` 处的元素是 $1.0 / (i + j + 1)$，其中 $i,j \\in \\{0, 1, \\dots, 7\\}$。精确解是一个全为 1 的向量，$x^{\\mathrm{true}} = [1, 1, \\dots, 1]^T \\in \\mathbb{R}^8$。相应的“精确”右端向量 $b$ 通过矩阵向量乘积 $b = H x^{\\mathrm{true}}$ 计算得出。由于 $x^{\\mathrm{true}}$ 的结构， $b$ 就是 $H$ 的行和向量，即 $b_i = \\sum_{j=1}^8 H_{ij}$。\n\n2.  **测试用例评估**：对于四个测试用例中的每一个，我们定义受扰动的右端向量 $\\tilde{b}$，并求解线性系统 $H \\hat{x} = \\tilde{b}$ 以获得计算解 $\\hat{x}$。这可以通过一个标准的数值求解器来完成，例如基于 LU 分解的求解器，通常通过 `numpy.linalg.solve` 来调用。\n\n    *   **用例 1 (基准)**：$\\tilde{b} = b$。在这里，唯一的误差来源是浮点运算的有限精度。$H$ 的表示和 $b$ 的计算会引入小的舍入误差。线性求解器本身也会引入进一步的误差。$\\hat{x}$ 相对于 $x^{\\mathrm{true}}$ 的最终偏差几乎完全是由于 $H$ 的巨大条件数放大了这些内在的表示和算术误差所致。\n\n    *   **用例 2 (舍入到 $k=8$ 位)**：我们通过将计算向量 $b$ 的每个分量舍入到 8 位十进制有效数字来得到 $\\tilde{b}$。这引入了一个量级为 $10^{-8}$ 的显式相对扰动 $\\delta b / b$。经 $\\kappa_2(H_8) \\approx 10^{10}$ 放大后，解的预期相对误差将在 $10^{10} \\times 10^{-8} = 100$ 的量级。大于 1 的相对误差意味着精度的完全喪失。\n\n    *   **用例 3 (舍入到 $k=6$ 位)**：此处的舍入更为严重。$b$ 中的相对扰动量级为 $10^{-6}$。解的预期相对误差将更大，约为 $10^{10} \\times 10^{-6} = 10^4$。同样，可以预见精度会完全丧失。\n\n    *   **用例 4 (确定性扰动)**：扰动被定义为一个微小的、交替的相对变化：$\\tilde{b}_i = b_i (1 + 10^{-12} \\cdot (-1)^i)$。$b$ 中的相对扰动量级为 $10^{-12}$。解的预期相对误差在 $10^{10} \\times 10^{-12} = 10^{-2}$ 的量级。\n\n3.  **精度计算**：为每个用例计算出 $\\hat{x}$ 后，我们使用正确有效数字位数 $s$ 来量化其精度，定义如下：\n    $$\n    s = \\max\\left(0,\\; -\\log_{10}\\left(\\frac{\\lVert \\hat{x} - x^{\\mathrm{true}} \\rVert_2}{\\lVert x^{\\mathrm{true}} \\rVert_2}\\right)\\right)\n    $$\n    对数内的项是解的相对误差。精确解的欧几里得范数是 $\\lVert x^{\\mathrm{true}} \\rVert_2 = \\sqrt{8}$。我们计算误差向量 $\\hat{x} - x^{\\mathrm{true}}$，求其欧几里得范数，然后代入 $s$ 的公式。\n\n该实现需要一个函数来执行舍入到指定有效数字位数的操作。对于一个非零数 $y$ 和 $k$ 位有效数字，这可以通过将 $y$ 舍入到 $d = k - 1 - \\lfloor\\log_{10}|y|\\rfloor$ 位小数来实现。\n\n这一系统性步骤使得我们能够定量地评估一个病态系统（工程和科学计算中的一个常见风险）在响应各种误差源时，是如何降低数值解质量的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes the number of correct significant digits in the solution of a\n    linear system with the 8x8 Hilbert matrix under various perturbations\n    to the right-hand side vector.\n    \"\"\"\n\n    def round_to_k_significant_digits(y, k):\n        \"\"\"\n        Rounds a number y to k significant digits.\n        \"\"\"\n        if y == 0:\n            return 0.0\n        # Determine the number of decimal places needed for rounding\n        # based on the magnitude of the number.\n        d = k - 1 - math.floor(math.log10(abs(y)))\n        # Python's round() uses round-half-to-even.\n        return round(y, int(d))\n\n    # Define problem parameters\n    n = 8  # Order of the Hilbert matrix\n\n    # Construct the Hilbert matrix H.\n    # H_ij = 1 / (i + j - 1) for 1-based indexing.\n    # For 0-based indices, this is H_ij = 1 / ((i+1) + (j+1) - 1) = 1 / (i+j+1).\n    H = np.zeros((n, n), dtype=np.float64)\n    for i in range(n):\n        for j in range(n):\n            H[i, j] = 1.0 / (i + j + 1)\n\n    # Define the true solution x_true (a vector of ones).\n    x_true = np.ones(n, dtype=np.float64)\n\n    # Calculate the true right-hand side vector b = H * x_true.\n    # Since x_true is all ones, b is the vector of row sums of H.\n    b = H @ x_true\n\n    # The Euclidean norm of the true solution is sqrt(n).\n    norm_x_true = np.linalg.norm(x_true, 2)\n\n    # List to store the results (s values) for each test case.\n    results = []\n    \n    # Define test cases as a list of perturbed right-hand side vectors.\n    # Test Case 1: Baseline (no explicit perturbation)\n    b_tilde_1 = b\n\n    # Test Case 2: Rounding to 8 significant digits\n    b_tilde_2 = np.array([round_to_k_significant_digits(val, 8) for val in b])\n\n    # Test Case 3: Rounding to 6 significant digits\n    b_tilde_3 = np.array([round_to_k_significant_digits(val, 6) for val in b])\n\n    # Test Case 4: Deterministic component-wise relative perturbation\n    # delta_b_i = 10^-12 * (-1)^i * |b_i| for i=1..8\n    # For 0-based index j=0..7, this is (-1)^(j+1).\n    delta_b_4 = np.array([1e-12 * ((-1)**(i + 1)) * abs(b[i]) for i in range(n)])\n    b_tilde_4 = b + delta_b_4\n    \n    test_cases_b = [b_tilde_1, b_tilde_2, b_tilde_3, b_tilde_4]\n\n    for b_tilde in test_cases_b:\n        # Solve the linear system H * x_hat = b_tilde.\n        x_hat = np.linalg.solve(H, b_tilde)\n\n        # Calculate the relative error of the solution.\n        # rel_err = ||x_hat - x_true|| / ||x_true||\n        error_norm = np.linalg.norm(x_hat - x_true, 2)\n        relative_error = error_norm / norm_x_true\n\n        # Calculate the number of correct significant digits, s.\n        # s = max(0, -log10(relative_error))\n        # A check for relative_error == 0 is theoretically needed but\n        # practically impossible in this floating-point context.\n        s = max(0.0, -math.log10(relative_error))\n        \n        # Store the result, rounded to 3 decimal places.\n        results.append(round(s, 3))\n\n    # Format the final output as specified.\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "2432471"}]}