{"hands_on_practices": [{"introduction": "福克-普朗克方程（$FPE$）和随机微分方程（$SDE$）是描述同一随机过程的两种不同视角，前者描述了概率密度的宏观演化，后者则刻画了单个粒子的微观轨迹。本练习旨在通过实践搭建起两者之间的桥梁。您将首先从 $FPE$ 出发，推导系统统计矩（如均值和二阶矩）随时间演化的确定性方程，然后通过编写一个基于朗之万方程的直接数值模拟来验证您的分析结果[@problem_id:2444416]。这项实践不仅能加深您对理论联系的理解，还能锻炼您在计算工程中至关重要的模拟与验证能力。", "problem": "考虑一个朗之万粒子的一维Itô随机微分方程 (SDE)，\n$$\ndX_t = a(X_t)\\,dt + b\\,dW_t,\n$$\n其中 $W_t$ 是一个标准维纳过程，$a(x)$ 是漂移项，$b$ 是扩散振幅。在本问题中，限定于线性漂移、常数扩散模型\n$$\na(x) = u - k x,\\quad b = \\sqrt{2D},\n$$\n参数为 $k \\ge 0$，$u \\in \\mathbb{R}$ 和 $D \\ge 0$。对于概率密度函数 $p(x,t)$，其相关的福克-普朗克方程 (FPE) 为\n$$\n\\frac{\\partial p}{\\partial t} = -\\frac{\\partial}{\\partial x}\\big(a(x)\\,p\\big) + D\\,\\frac{\\partial^2 p}{\\partial x^2}.\n$$\n假设初始分布具有有限矩，并且衰减足够快，以至于在计算矩时，所有由分部积分产生的边界项均为零。\n\n任务 1 (推导)：从福克-普朗克方程以及一阶矩和二阶矩的定义出发，\n$$\n\\langle x \\rangle(t) = \\int_{-\\infty}^{\\infty} x\\,p(x,t)\\,dx,\\quad \\langle x^2 \\rangle(t) = \\int_{-\\infty}^{\\infty} x^2\\,p(x,t)\\,dx,\n$$\n推导出控制 $\\langle x \\rangle(t)$ 和 $\\langle x^2 \\rangle(t)$ 的、针对指定 $a(x)$ 和 $D$ 的封闭常微分方程 (ODE)。然后求解这些常微分方程，以初始均值 $\\langle x \\rangle(0)$ 和初始方差 $\\mathrm{Var}(X_0)$ 的形式，获得 $\\langle x \\rangle(t)$ 和 $\\langle x^2 \\rangle(t)$ 的显式表达式，确保覆盖 $k>0$ 的情况以及 $k \\to 0$ 的极限情况。所有量均为无量纲。\n\n任务 2 (计算)：实现一个程序，该程序：\n- 使用时间步长为 $\\Delta t$ 的欧拉-丸山方法，从一个均值为 $m_0$、方差为 $v_0$ 的初始系综 $X_0$ 出发，模拟 SDE 的 $N$ 条独立轨迹（使用均值为 $m_0$、方差为 $v_0$ 的高斯初始化；当 $v_0 = 0$ 时，将所有粒子初始化在确定性值 $m_0$）。\n- 将状态推进到时间 $T$，并根据在时间 $T$ 模拟出的系综计算经验一阶矩和二阶矩。\n- 使用任务1中推导出的矩解，并采用相同的有效模拟时间 $T_{\\mathrm{eff}} = n_{\\mathrm{steps}}\\,\\Delta t$（其中 $n_{\\mathrm{steps}}$ 是执行的整数步数），计算理论上的 $\\langle x \\rangle(T)$ 和 $\\langle x^2 \\rangle(T)$。\n- 通过绝对误差 $e_1 = \\big|\\langle x \\rangle_{\\mathrm{emp}}(T_{\\mathrm{eff}}) - \\langle x \\rangle_{\\mathrm{theory}}(T_{\\mathrm{eff}})\\big|$ 和 $e_2 = \\big|\\langle x^2 \\rangle_{\\mathrm{emp}}(T_{\\mathrm{eff}}) - \\langle x^2 \\rangle_{\\mathrm{theory}}(T_{\\mathrm{eff}})\\big|$ 比较经验矩和理论矩。\n- 对于每个测试用例，输出一个布尔值，指示两个误差是否都满足 $e_1 \\le \\varepsilon$ 和 $e_2 \\le \\varepsilon$（其中 $\\varepsilon$ 是指定的容差）。\n\n使用以下测试套件，其中所有量均为无量纲：\n- 测试用例 1 (带常数驱动力的一般 Ornstein–Uhlenbeck 过程)：$k = 0.7$, $u = 0.3$, $D = 0.5$, $m_0 = 1.2$, $v_0 = 0.8$, $T = 2.3$, $\\Delta t = 0.005$, $N = 20000$。\n- 测试用例 2 (纯扩散边界情况)：$k = 0$, $u = 0$, $D = 0.2$, $m_0 = 0.0$, $v_0 = 0.0$, $T = 1.5$, $\\Delta t = 0.003$, $N = 20000$。\n- 测试用例 3 (刚性弛豫)：$k = 5.0$, $u = 0.0$, $D = 0.4$, $m_0 = -0.7$, $v_0 = 0.3$, $T = 0.6$, $\\Delta t = 0.0005$, $N = 8000$。\n\n所有用例均使用容差 $\\varepsilon = 0.03$。\n\n你的程序应生成单行输出，其中包含布尔结果，格式为方括号括起来的逗号分隔列表（例如，$[{\\tt True},{\\tt False},{\\tt True}]$），顺序与上述测试套件相同。不应打印其他任何文本。", "solution": "在尝试任何解决方案之前，对问题陈述进行验证。\n\n逐字提取给定条件：\n- 随机微分方程 (SDE)：$dX_t = a(X_t)\\,dt + b\\,dW_t$\n- 漂移：$a(x) = u - k x$\n- 扩散振幅：$b = \\sqrt{2D}$\n- 参数约束：$k \\ge 0$，$u \\in \\mathbb{R}$，$D \\ge 0$\n- Fokker-Planck 方程 (FPE)：$\\frac{\\partial p}{\\partial t} = -\\frac{\\partial}{\\partial x}\\big(a(x)\\,p\\big) + D\\,\\frac{\\partial^2 p}{\\partial x^2}$\n- 矩定义：$\\langle x \\rangle(t) = \\int_{-\\infty}^{\\infty} x\\,p(x,t)\\,dx$，$\\langle x^2 \\rangle(t) = \\int_{-\\infty}^{\\infty} x^2\\,p(x,t)\\,dx$\n- 边界条件假设：由于 $p(x,t)$ 在 $x \\to \\pm\\infty$ 时衰减足够快，所有由分部积分产生的边界项均为零。\n- 任务 $1$：推导并求解 $\\langle x \\rangle(t)$ 和 $\\langle x^2 \\rangle(t)$ 的常微分方程。\n- 任务 $2$：使用 Euler-Maruyama 方法实现数值模拟，并与任务 $1$ 中推导出的理论结果进行比较。\n- 提供了测试用例和容差 $\\varepsilon = 0.03$。\n\n验证结论：该问题是**有效的**。它在科学上植根于随机过程理论，特别是 Ornstein-Uhlenbeck 过程，这是统计物理学及相关领域的基石。该问题是适定的，提供了所有必要的信息、定义和约束，以推导唯一的解析解并执行相应的数值验证。语言客观而精确。该问题是可形式化的，并与计算工程中的 Fokker-Planck 方程主题直接相关。未发现科学、逻辑或结构上的缺陷。\n\n我们继续进行求解。\n\n**任务 1：矩方程的推导与求解**\n\n任何矩 $\\langle f(x) \\rangle(t) = \\int f(x) p(x,t) dx$ 的演化都由 FPE 控制。其时间导数为：\n$$\n\\frac{d}{dt}\\langle f(x) \\rangle = \\int f(x) \\frac{\\partial p}{\\partial t} dx = \\int f(x) \\left[ -\\frac{\\partial}{\\partial x}\\big(a(x)\\,p\\big) + D\\,\\frac{\\partial^2 p}{\\partial x^2} \\right] dx\n$$\n\n**一阶矩 $\\langle x \\rangle(t)$**\n\n令 $f(x) = x$。均值 $\\langle x \\rangle(t)$ 的时间导数为：\n$$\n\\frac{d\\langle x \\rangle}{dt} = \\int x \\left[ -\\frac{\\partial}{\\partial x}\\big((u-kx)p\\big) + D\\,\\frac{\\partial^2 p}{\\partial x^2} \\right] dx\n$$\n我们分别计算积分中的两项。\n\n第 1 项：\n$$\n-\\int_{-\\infty}^{\\infty} x \\frac{\\partial}{\\partial x}\\big((u-kx)p\\big) dx\n$$\n使用分部积分法 $\\int v\\,du' = [vu']_{-\\infty}^{\\infty} - \\int v'u\\,dx$，其中 $v=x$ 且 $u'=\\frac{\\partial}{\\partial x}\\big((u-kx)p\\big)$：\n$$\n-\\left[ x(u-kx)p \\right]_{-\\infty}^{\\infty} + \\int_{-\\infty}^{\\infty} (u-kx)p \\, dx\n$$\n根据假设，边界项为零。剩余的积分为：\n$$\n\\int (u-kx)p \\, dx = u \\int p \\, dx - k \\int xp \\, dx = u \\cdot 1 - k\\langle x \\rangle = u - k\\langle x \\rangle\n$$\n因为 $\\int p(x,t) dx = 1$。\n\n第 2 项：\n$$\n\\int_{-\\infty}^{\\infty} x D \\frac{\\partial^2 p}{\\partial x^2} dx\n$$\n我们进行两次分部积分。首先，设 $v=x$ 和 $u' = D \\frac{\\partial^2 p}{\\partial x^2}$：\n$$\n\\left[ xD\\frac{\\partial p}{\\partial x} \\right]_{-\\infty}^{\\infty} - \\int_{-\\infty}^{\\infty} D\\frac{\\partial p}{\\partial x} dx\n$$\n边界项消失。该积分为 $-D[p]_{-\\infty}^{\\infty}$，也为零。因此，整个项为零。\n\n综合结果，我们得到一阶矩的常微分方程：\n$$\n\\frac{d\\langle x \\rangle}{dt} = u - k\\langle x \\rangle\n$$\n\n**二阶矩 $\\langle x^2 \\rangle(t)$**\n\n令 $f(x) = x^2$。二阶矩 $\\langle x^2 \\rangle(t)$ 的时间导数为：\n$$\n\\frac{d\\langle x^2 \\rangle}{dt} = \\int x^2 \\left[ -\\frac{\\partial}{\\partial x}\\big((u-kx)p\\big) + D\\,\\frac{\\partial^2 p}{\\partial x^2} \\right] dx\n$$\n第 1 项：\n$$\n-\\int_{-\\infty}^{\\infty} x^2 \\frac{\\partial}{\\partial x}\\big((u-kx)p\\big) dx\n$$\n设 $v=x^2$ 进行分部积分：\n$$\n-\\left[ x^2(u-kx)p \\right]_{-\\infty}^{\\infty} + \\int_{-\\infty}^{\\infty} 2x(u-kx)p \\, dx\n$$\n边界项为零。剩余的积分为：\n$$\n\\int (2ux - 2kx^2)p \\, dx = 2u \\int xp \\, dx - 2k \\int x^2p \\, dx = 2u\\langle x \\rangle - 2k\\langle x^2 \\rangle\n$$\n\n第 2 项：\n$$\n\\int_{-\\infty}^{\\infty} x^2 D \\frac{\\partial^2 p}{\\partial x^2} dx\n$$\n设 $v=x^2$ 进行分部积分：\n$$\n\\left[ x^2 D\\frac{\\partial p}{\\partial x} \\right]_{-\\infty}^{\\infty} - \\int_{-\\infty}^{\\infty} 2x D\\frac{\\partial p}{\\partial x} dx\n$$\n边界项为零。我们剩下 $-2D \\int x \\frac{\\partial p}{\\partial x} dx$。再次进行分部积分：\n$$\n-2D \\left( [xp]_{-\\infty}^{\\infty} - \\int p \\, dx \\right) = -2D(0 - 1) = 2D\n$$\n综合结果，得到二阶矩的常微分方程：\n$$\n\\frac{d\\langle x^2 \\rangle}{dt} = 2u\\langle x \\rangle - 2k\\langle x^2 \\rangle + 2D\n$$\n这些矩构成了一个封闭的线性常微分方程组。推导方差 $\\mathrm{Var}(X_t) \\equiv V(t) = \\langle x^2 \\rangle(t) - \\langle x \\rangle(t)^2$ 的方程更为简洁。\n$$\n\\frac{dV}{dt} = \\frac{d\\langle x^2 \\rangle}{dt} - 2\\langle x \\rangle \\frac{d\\langle x \\rangle}{dt} = (2u\\langle x \\rangle - 2k\\langle x^2 \\rangle + 2D) - 2\\langle x \\rangle (u - k\\langle x \\rangle)\n$$\n$$\n\\frac{dV}{dt} = 2u\\langle x \\rangle - 2k\\langle x^2 \\rangle + 2D - 2u\\langle x \\rangle + 2k\\langle x \\rangle^2 = -2k(\\langle x^2 \\rangle - \\langle x \\rangle^2) + 2D\n$$\n这简化为关于方差的一个独立常微分方程：\n$$\n\\frac{dV}{dt} = -2kV + 2D\n$$\n\n**求解常微分方程**\n\n设 $m(t) = \\langle x \\rangle(t)$，$m_0 = \\langle x \\rangle(0)$ 及 $v_0 = \\mathrm{Var}(X_0)$。\n\n情况 1：$k > 0$。\n均值的常微分方程为 $\\frac{dm}{dt} + km = u$。这是一个一阶线性常微分方程，其解为：\n$$\nm(t) = m_0 e^{-kt} + \\frac{u}{k}(1-e^{-kt})\n$$\n方差的常微分方程为 $\\frac{dV}{dt} + 2kV = 2D$。其解为：\n$$\nV(t) = v_0 e^{-2kt} + \\frac{D}{k}(1-e^{-2kt})\n$$\n\n情况 2：$k = 0$。\n均值的常微分方程变为 $\\frac{dm}{dt} = u$，其解为：\n$$\nm(t) = m_0 + ut\n$$\n方差的常微分方程变为 $\\frac{dV}{dt} = 2D$，其解为：\n$$\nV(t) = v_0 + 2Dt\n$$\n对于 $k=0$ 的这些结果与 $k>0$ 表达式在 $k \\to 0$ 时的极限是一致的，这可以通过指数函数的泰勒展开来验证。\n\n二阶矩可以从均值和方差中恢复：\n$$\n\\langle x^2 \\rangle(t) = V(t) + [m(t)]^2\n$$\n任务 1 的推导到此结束。\n\n**任务 2：计算实现**\n\nSDE $dX_t = (u - kX_t)dt + \\sqrt{2D}dW_t$ 使用 Euler-Maruyama 方法进行模拟。在时间步 $n$ 时，单个粒子位置 $X_n$ 的离散化更新规则为：\n$$\nX_{n+1} = X_n + (u - kX_n)\\Delta t + \\sqrt{2D\\Delta t} Z_n\n$$\n其中 $\\Delta t$是时间步长，$Z_n$是从标准正态分布 $N(0,1)$ 中抽取的随机变量。\n\n算法流程如下：\n$1$. 对每个测试用例，初始化 $N$ 条独立的粒子轨迹。初始位置 $X_0$ 构成一个从均值为 $m_0$、方差为 $v_0$ 的高斯分布中抽取的系综。若 $v_0 = 0$，则所有粒子均初始化在确定性位置 $m_0$。\n$2$. 计算模拟步数 $n_{\\mathrm{steps}} = \\mathrm{round}(T/\\Delta t)$ 以便紧密匹配目标时间 $T$。有效总时间为 $T_{\\mathrm{eff}} = n_{\\mathrm{steps}} \\Delta t$。\n$3$. 迭代 $n_{\\mathrm{steps}}$ 次，在每一步根据 Euler-Maruyama 规则更新所有 $N$ 个粒子的位置。每一步都生成一组新的 $N$ 个随机数 $Z_n$。\n$4$. 在最终时间 $T_{\\mathrm{eff}}$，根据 $N$ 个最终粒子位置组成的系综计算经验均值和经验二阶矩：\n$$\n\\langle x \\rangle_{\\mathrm{emp}} = \\frac{1}{N}\\sum_{i=1}^N X_i(T_{\\mathrm{eff}}) \\quad \\text{and} \\quad \\langle x^2 \\rangle_{\\mathrm{emp}} = \\frac{1}{N}\\sum_{i=1}^N [X_i(T_{\\mathrm{eff}})]^2\n$$\n$5$. 使用上面推导出的解析公式计算理论矩 $\\langle x \\rangle_{\\mathrm{theory}}(T_{\\mathrm{eff}})$ 和 $\\langle x^2 \\rangle_{\\mathrm{theory}}(T_{\\mathrm{eff}})$。\n$6$. 计算绝对误差 $e_1 = |\\langle x \\rangle_{\\mathrm{emp}} - \\langle x \\rangle_{\\mathrm{theory}}|$ 和 $e_2 = |\\langle x^2 \\rangle_{\\mathrm{emp}} - \\langle x^2 \\rangle_{\\mathrm{theory}}|$。\n$7$. 如果两个误差都在指定的容差 $\\varepsilon = 0.03$ 内，则测试用例通过。最终输出是一个布尔值列表，指示每个测试用例的通过/失败状态。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by running simulations for each test case and comparing\n    empirical results with theoretical derivations.\n    \"\"\"\n\n    test_cases = [\n        # (k, u, D, m0, v0, T, dt, N)\n        (0.7, 0.3, 0.5, 1.2, 0.8, 2.3, 0.005, 20000),\n        (0.0, 0.0, 0.2, 0.0, 0.0, 1.5, 0.003, 20000),\n        (5.0, 0.0, 0.4, -0.7, 0.3, 0.6, 0.0005, 8000),\n    ]\n    epsilon = 0.03\n    results = []\n\n    for k, u, D, m0, v0, T, dt, N in test_cases:\n        # Run simulation to get empirical moments\n        emp_mean, emp_second_moment, eff_T = run_simulation(\n            k, u, D, m0, v0, T, dt, N\n        )\n\n        # Calculate theoretical moments\n        theory_mean, theory_second_moment = theoretical_moments(\n            k, u, D, m0, v0, eff_T\n        )\n\n        # Compare and check against tolerance\n        e1 = np.abs(emp_mean - theory_mean)\n        e2 = np.abs(emp_second_moment - theory_second_moment)\n        \n        is_within_tolerance = (e1 = epsilon) and (e2 = epsilon)\n        results.append(is_within_tolerance)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(k, u, D, m0, v0, T, dt, N):\n    \"\"\"\n    Simulates N trajectories of the Langevin SDE using Euler-Maruyama method.\n\n    Returns:\n        tuple: (empirical mean, empirical second moment, effective simulation time)\n    \"\"\"\n    num_steps = int(np.round(T / dt))\n    eff_T = num_steps * dt\n\n    # Initial ensemble generation from a Gaussian distribution\n    # np.random.normal's 'scale' parameter is standard deviation (sqrt of variance)\n    if v0 >= 0:\n        std_dev = np.sqrt(v0)\n        x = np.random.normal(loc=m0, scale=std_dev, size=N)\n    else:\n        # This case should not happen based on problem constraints but is good practice\n        raise ValueError(\"Initial variance v0 must be non-negative.\")\n\n    # Pre-calculate constant term for efficiency\n    sde_noise_term = np.sqrt(2 * D * dt)\n\n    # Simulation loop\n    for _ in range(num_steps):\n        # Generate standard normal random numbers for this step\n        Z = np.random.normal(size=N)\n        \n        # Euler-Maruyama step for all N particles\n        drift = (u - k * x) * dt\n        diffusion = sde_noise_term * Z\n        x += drift + diffusion\n    \n    # Compute empirical moments from the final state of the ensemble\n    emp_mean = np.mean(x)\n    emp_second_moment = np.mean(x**2)\n    \n    return emp_mean, emp_second_moment, eff_T\n\ndef theoretical_moments(k, u, D, m0, v0, t):\n    \"\"\"\n    Calculates the theoretical first and second moments at time t.\n\n    Returns:\n        tuple: (theoretical mean, theoretical second moment)\n    \"\"\"\n    if k > 0:\n        # Case for Ornstein-Uhlenbeck process (k > 0)\n        exp_kt = np.exp(-k * t)\n        exp_2kt = np.exp(-2 * k * t)\n        \n        mean_t = m0 * exp_kt + (u / k) * (1 - exp_kt)\n        var_t = v0 * exp_2kt + (D / k) * (1 - exp_2kt)\n    else: # k == 0\n        # Case for pure Wiener process with drift (k = 0)\n        mean_t = m0 + u * t\n        var_t = v0 + 2 * D * t\n    \n    # Second moment is Var(X) + E[X]^2\n    second_moment_t = var_t + mean_t**2\n    \n    return mean_t, second_moment_t\n\nsolve()\n\n```", "id": "2444416"}, {"introduction": "在扩散过程中，一个核心问题是：一个粒子平均需要多长时间才能首次到达某个特定位置或区域？这个问题由“平均首达时间”（$MFPT$）来回答，它在化学反应动力学、神经科学和材料科学等领域都有着广泛应用。本练习将引导您使用与福克-普朗克方程密切相关的向后科尔莫戈洛夫方程，为在一维区间内运动的粒子计算其 $MFPT$ [@problem_id:2444438]。通过分析不同类型的边界条件（如吸收边界和反射边界）如何影响 $MFPT$，您将深刻体会到边界在控制随机动力学过程中的决定性作用。", "problem": "一个一维粒子在闭合区间内进行具有恒定漂移的过阻尼扩散。其位置 $X_t$ 在区间 $\\,[0,L]\\,$ 上遵循随机微分方程 (SDE) $\\,\\mathrm{d}X_t = v\\,\\mathrm{d}t + \\sqrt{2D}\\,\\mathrm{d}W_t\\,$，其中 $v$ 是恒定漂移速度，$D$ 是恒定扩散系数，$W_t$ 是标准维纳过程。粒子从位置 $X_0 = x_0$ 开始，其中 $0 \\le x_0 \\le L$。\n\n定义平均首达时间 (MFPT) $\\,T\\,$ 为从区间 $\\,[0,L]\\,$ 逃逸的时间 $\\,\\tau\\,$ 的期望值，考虑以下两种边界构型：\n\n- 构型 $\\mathcal{R}\\mathcal{A}$：在 $x=0$ 处为反射边界，在 $x=L$ 处为吸收边界。在此构型中，逃逸时间为 $\\tau = \\inf\\{t \\ge 0 : X_t = L\\}$，因为 $x=0$ 处的反射阻止了粒子在此处逃逸。\n- 构型 $\\mathcal{A}\\mathcal{A}$：在 $x=0$ 和 $x=L$ 处均为吸收边界。在此构型中，逃逸时间为 $\\tau = \\inf\\{t \\ge 0 : X_t \\in \\{0,L\\}\\}$。\n\n对于每种构型，MFPT 分别定义为 $\\,T_{\\mathcal{R}\\mathcal{A}}(x_0)\\,$ 和 $\\,T_{\\mathcal{A}\\mathcal{A}}(x_0)\\,$。所有时间都必须以秒为单位表示。\n\n任务：对于下面的参数集，计算每个测试用例的结果三元组 $[\\,T_{\\mathcal{R}\\mathcal{A}}(x_0),\\,T_{\\mathcal{A}\\mathcal{A}}(x_0),\\,T_{\\mathcal{R}\\mathcal{A}}(x_0)-T_{\\mathcal{A}\\mathcal{A}}(x_0)\\,]$。所有输出必须以秒为单位表示，并四舍五入到六位小数。\n\n使用以下测试套件，其中 $L$ 的单位是米，$D$ 的单位是平方米/秒，$v$ 的单位是米/秒，$x_0$ 的单位是米：\n\n- 测试用例 $1$：$L=1.0$，$D=0.1$，$v=0.5$，$x_0=0.2$。\n- 测试用例 $2$：$L=1.0$，$D=0.1$，$v=0.0$，$x_0=0.3$。\n- 测试用例 $3$：$L=1.0$，$D=0.05$，$v=-0.2$，$x_0=0.6$。\n- 测试用例 $4$：$L=2.0$，$D=0.2$，$v=0.3$，$x_0=0.0$。\n- 测试用例 $5$：$L=1.5$，$D=0.15$，$v=0.1$，$x_0=1.5$。\n\n最终输出格式：您的程序应生成一行输出，其中包含所有测试用例的结果，形式为逗号分隔的三元组列表，并包含在一对方括号中。每个三元组必须为 $[\\,T_{\\mathcal{R}\\mathcal{A}},\\,T_{\\mathcal{A}\\mathcal{A}},\\,T_{\\mathcal{R}\\mathcal{A}}-T_{\\mathcal{A}\\mathcal{A}}\\,]$ 的形式，其中每个条目都四舍五入到六位小数，例如 $[\\, [\\,t_{1,\\mathcal{R}\\mathcal{A}},t_{1,\\mathcal{A}\\mathcal{A}},\\Delta_1\\,], [\\,t_{2,\\mathcal{R}\\mathcal{A}},t_{2,\\mathcal{A}\\mathcal{A}},\\Delta_2\\,], \\ldots \\,]$，其中 $t_{k,\\mathcal{R}\\mathcal{A}}$、$t_{k,\\mathcal{A}\\mathcal{A}}$ 和 $\\Delta_k$ 表示测试用例 $k$ 的三个四舍五入后的结果。", "solution": "所述问题具有科学依据、提法恰当且客观。它基于扩散过程的基本理论和平均首达时间，这是统计物理和计算工程中的一个标准课题。所有参数都已明确定义，且前提符合事实。我们将着手进行形式推导和求解。\n\n粒子的运动由一维朗之万方程描述，或更正式地，由随机微分方程 (SDE) 描述：\n$$ \\mathrm{d}X_t = v\\,\\mathrm{d}t + \\sqrt{2D}\\,\\mathrm{d}W_t $$\n其中 $X_t$ 是时间 $t$ 时的位置，$v$ 是恒定漂移速度，$D$ 是恒定扩散系数，$W_t$ 是标准维纳过程。\n\n平均首达时间 (MFPT)，记为 $T(x_0)$，是粒子从 $X_0 = x_0$ 开始，首次到达给定区域边界所需时间 $\\tau$ 的期望值。对于一个通用的一维伊藤过程 $ \\mathrm{d}X_t = a(X_t)\\,\\mathrm{d}t + b(X_t)\\,\\mathrm{d}W_t $，作为起始位置 $x$ 的函数的 MFPT $T(x)$ 满足向后柯尔莫哥洛夫方程，这是一个二阶常微分方程：\n$$ a(x) \\frac{\\mathrm{d}T}{\\mathrm{d}x} + \\frac{1}{2} b^2(x) \\frac{\\mathrm{d}^2T}{\\mathrm{d}x^2} = -1 $$\n对于问题中给出的特定 SDE，漂移系数为 $a(x) = v$，扩散项为 $b(x) = \\sqrt{2D}$，因此 $b^2(x) = 2D$。因此，我们问题的向后柯尔莫哥洛夫方程是：\n$$ v \\frac{\\mathrm{d}T}{\\mathrm{d}x} + D \\frac{\\mathrm{d}^2T}{\\mathrm{d}x^2} = -1 $$\n我们必须在区间 $[0, L]$ 上针对两种指定的边界构型求解这个常微分方程。\n\n**构型 $\\mathcal{R}\\mathcal{A}$：在 $x=0$ 处反射，在 $x=L$ 处吸收**\n\n区域为 $[0, L]$。MFPT $T_{\\mathcal{R}\\mathcal{A}}(x)$ 表示到达边界 $x=L$ 所需的时间。\n边界条件为：\n1.  在 $x=L$ 处的吸收边界：如果粒子从吸收边界开始，逃逸时间为零。因此，$T_{\\mathcal{R}\\mathcal{A}}(L) = 0$。\n2.  在 $x=0$ 处的反射边界：反射边界对概率密度施加了零通量条件，这对应于 MFPT 的零梯度条件。因此，$\\frac{\\mathrm{d}T_{\\mathcal{R}\\mathcal{A}}}{\\mathrm{d}x}\\bigg|_{x=0} = 0$。\n\n我们来求解 $D T'' + v T' = -1$。\n首先，考虑 $v \\neq 0$ 的情况。令 $U(x) = T'(x)$。$U(x)$ 的方程为 $D U' + v U = -1$，这是一个一阶线性常微分方程。其通解为 $U(x) = C_1 e^{-vx/D} - 1/v$。\n使用条件 $U(0) = T'(0) = 0$，我们得到 $C_1 - 1/v = 0 \\Rightarrow C_1 = 1/v$。\n所以，$T'(x) = \\frac{1}{v}(e^{-vx/D} - 1)$。\n对 $x$ 积分得到 $T(x) = \\int \\frac{1}{v}(e^{-vx/D} - 1) \\mathrm{d}x = \\frac{1}{v}(-\\frac{D}{v}e^{-vx/D} - x) + C_2$。\n使用条件 $T(L)=0$，我们求解 $C_2$：$0 = -\\frac{D}{v^2}e^{-vL/D} - \\frac{L}{v} + C_2 \\Rightarrow C_2 = \\frac{D}{v^2}e^{-vL/D} + \\frac{L}{v}$。\n将 $C_2$ 代回，我们得到 $v \\neq 0$ 时的解：\n$$ T_{\\mathcal{R}\\mathcal{A}}(x_0) = \\frac{L-x_0}{v} + \\frac{D}{v^2} \\left( e^{-vL/D} - e^{-vx_0/D} \\right) $$\n对于 $v=0$ 的情况，常微分方程变为 $D T'' = -1$。积分两次得到 $T(x) = -x^2/(2D) + C_1 x + C_2$。\n边界条件为 $T'(0)=0$ 和 $T(L)=0$。\n$T'(x) = -x/D + C_1$。由 $T'(0)=0$ 可得 $C_1=0$。\n然后 $T(L) = -L^2/(2D) + C_2 = 0$，所以 $C_2 = L^2/(2D)$。\n$v = 0$ 时的解是：\n$$ T_{\\mathcal{R}\\mathcal{A}}(x_0) = \\frac{L^2 - x_0^2}{2D} $$\n\n**构型 $\\mathcal{A}\\mathcal{A}$：在 $x=0$ 处吸收，在 $x=L$ 处吸收**\n\n区域为 $[0, L]$。MFPT $T_{\\mathcal{A}\\mathcal{A}}(x)$ 表示到达边界 $x=0$ 或 $x=L$ 所需的时间。\n边界条件为：\n1.  在 $x=0$ 处的吸收边界：$T_{\\mathcal{A}\\mathcal{A}}(0) = 0$。\n2.  在 $x=L$ 处的吸收边界：$T_{\\mathcal{A}\\mathcal{A}}(L) = 0$。\n\n我们求解相同的常微分方程 $D T'' + v T' = -1$。\n首先，考虑 $v \\neq 0$ 的情况。通解为 $T(x) = C_1 + C_2 e^{-vx/D} - x/v$。\n应用边界条件：\n1.  $T(0) = C_1 + C_2 = 0 \\Rightarrow C_1 = -C_2$。\n2.  $T(L) = C_1 + C_2 e^{-vL/D} - L/v = 0$。\n将 $C_1=-C_2$ 代入第二个方程，得到 $-C_2 + C_2 e^{-vL/D} = L/v$，这给出 $C_2 = \\frac{L/v}{e^{-vL/D}-1}$。\n于是 $C_1 = -\\frac{L/v}{e^{-vL/D}-1}$。\n将常数代回通解并简化得到：\n$$ T_{\\mathcal{A}\\mathcal{A}}(x_0) = \\frac{1}{v} \\left( L \\frac{1 - e^{-vx_0/D}}{1 - e^{-vL/D}} - x_0 \\right) $$\n对于 $v=0$ 的情况，常微分方程为 $D T'' = -1$，通解为 $T(x) = -x^2/(2D) + C_1 x + C_2$。\n边界条件为 $T(0)=0$ 和 $T(L)=0$。\n$T(0) = C_2 = 0$。\n$T(L) = -L^2/(2D) + C_1 L = 0 \\Rightarrow C_1 = L/(2D)$。\n$v = 0$ 时的解是：\n$$ T_{\\mathcal{A}\\mathcal{A}}(x_0) = \\frac{x_0(L-x_0)}{2D} $$\n\n**用于计算的公式摘要**\n\n对于每个具有参数 $(L, D, v, x_0)$ 的测试用例：\n\n1.  **构型 $\\mathcal{R}\\mathcal{A}$ 的平均首达时间：**\n    - 若 $v=0$： $T_{\\mathcal{R}\\mathcal{A}}(x_0) = \\frac{L^2 - x_0^2}{2D}$\n    - 若 $v \\neq 0$： $T_{\\mathcal{R}\\mathcal{A}}(x_0) = \\frac{L-x_0}{v} + \\frac{D}{v^2} \\left( e^{-vL/D} - e^{-vx_0/D} \\right)$\n    - 请注意，如果 $x_0 = L$，粒子已经位于吸收边界上，因此 $T_{\\mathcal{R}\\mathcal{A}}(L) = 0$。\n\n2.  **构型 $\\mathcal{A}\\mathcal{A}$ 的平均首达时间：**\n    - 若 $v=0$： $T_{\\mathcal{A}\\mathcal{A}}(x_0) = \\frac{x_0(L-x_0)}{2D}$\n    - 若 $v \\neq 0$： $T_{\\mathcal{A}\\mathcal{A}}(x_0) = \\frac{1}{v} \\left( L \\frac{1 - e^{-vx_0/D}}{1 - e^{-vL/D}} - x_0 \\right)$\n    - 请注意，如果 $x_0 = 0$ 或 $x_0 = L$，粒子位于吸收边界上，因此 $T_{\\mathcal{A}\\mathcal{A}}(0) = 0$ 且 $T_{\\mathcal{A}\\mathcal{A}}(L) = 0$。\n\n这些公式被实现用于计算给定测试用例所需的值。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Mean First Passage Time (MFPT) for a particle in a 1D interval\n    with two different boundary configurations.\n    \"\"\"\n    test_cases = [\n        # (L, D, v, x_0)\n        (1.0, 0.1, 0.5, 0.2),\n        (1.0, 0.1, 0.0, 0.3),\n        (1.0, 0.05, -0.2, 0.6),\n        (2.0, 0.2, 0.3, 0.0),\n        (1.5, 0.15, 0.1, 1.5),\n    ]\n\n    results = []\n    for L, D, v, x0 in test_cases:\n        # Configuration RA: Reflecting at x=0, Absorbing at x=L\n        t_ra = 0.0\n        # If starting at the absorbing boundary, time is 0.\n        if np.isclose(x0, L):\n            t_ra = 0.0\n        elif np.isclose(v, 0.0):\n            # Formula for v=0\n            t_ra = (L**2 - x0**2) / (2 * D)\n        else:\n            # Formula for v!=0\n            term1 = (L - x0) / v\n            term2 = (D / v**2) * (np.exp(-v * L / D) - np.exp(-v * x0 / D))\n            t_ra = term1 + term2\n\n        # Configuration AA: Absorbing at x=0, Absorbing at x=L\n        t_aa = 0.0\n        # If starting at either absorbing boundary, time is 0.\n        if np.isclose(x0, 0.0) or np.isclose(x0, L):\n            t_aa = 0.0\n        elif np.isclose(v, 0.0):\n            # Formula for v=0\n            t_aa = x0 * (L - x0) / (2 * D)\n        else:\n            # Formula for v!=0\n            # Numerator and denominator of the probability term\n            num = 1 - np.exp(-v * x0 / D)\n            den = 1 - np.exp(-v * L / D)\n            term1 = L * (num / den)\n            t_aa = (1 / v) * (term1 - x0)\n        \n        delta_t = t_ra - t_aa\n        \n        # Format triplet as a string \"[val1,val2,val3]\"\n        triplet_str = f\"[{t_ra:.6f},{t_aa:.6f},{delta_t:.6f}]\"\n        results.append(triplet_str)\n\n    # Final print statement in the exact required format \"[triplet1,triplet2,...]\"\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2444438"}, {"introduction": "许多物理和化学系统，例如分子的构象变化或记忆存储单元的翻转，都可以被抽象为粒子在双势阱中的运动。系统在两个稳定状态之间的“跳跃”速率是一个关键的宏观参数。本练习将运用您在前一个练习中学到的平均首达时间（$MFPT$）概念，来解决一个经典的非线性问题：计算粒子逃离一个势阱的速率[@problem_id:2444390]。通过对这一著名双势阱模型的数值求解，您将学会如何将 $FPE$ 框架应用于量化复杂系统中的相变和稀有事件，这是连接微观随机性与宏观可观测速率的关键一步。", "problem": "要求您设计并实现一个数值方法，用于估算在一维双阱势 $V(x) = x^4 - 2x^2$ 中演化的过阻尼扩散过程的阱间跃迁速率。所有计算均在无量纲单位下进行。粒子位置 $x(t)$ 遵循 Itô 过阻尼 Langevin 动力学\n$$\ndx(t) = -V'(x(t))\\,dt + \\sqrt{2D}\\,dW_t,\n$$\n其中 $D \\gt 0$ 是（无量纲）扩散系数，$W_t$ 是标准维纳过程。与上述随机微分方程相关联的、描述概率密度函数 $p(x,t)$ 的对应 Fokker–Planck 方程 (FPE) 是其正向演化方程。\n\n从 Fokker–Planck 方程和反向 (Kolmogorov) 算符的定义出发，推导一个用于计算从起始位置 $x \\in [x_{\\min}, x_{\\max}]$ 到达势垒顶部吸收边界的平均首达时间 $m(x)$ 的适定边值问题。使用以下物理上一致的设置：\n- 势：$V(x) = x^4 - 2x^2$，在 $x = \\pm 1$ 附近有极小值，在 $x = 0$ 处有一个鞍点。\n- 定义域：$[x_{\\min}, x_{\\max}] = [-2.0, 0.0]$。\n- 初始位置：$x_0 = -1.0$。\n- 边界条件：在 $x_{\\min}$ 处为反射边界，在 $x_{\\max}$ 处为吸收边界。\n\n在推导出 $m(x)$ 的边值问题后，实现一种稳定的数值求解策略（例如，在均匀网格上对反向方程进行二阶中心有限差分离散，并适当实现反射和吸收边界条件；或者采用可由相同推导得出的、解析上等价的求积表示法）。根据计算出的初始位置处的平均首达时间 $m(x_0)$，将跃迁速率定义为 $k = 1/m(x_0)$，单位为无量纲时间的倒数。\n\n您的程序必须计算并报告以下测试集中每个扩散系数对应的跃迁速率 $k$：\n- $D = 0.1$（小噪声，稀有跃迁；理想情况）。\n- $D = 0.2$（中等噪声）。\n- $D = 0.5$（较大噪声）。\n- $D = 1.0$（噪声与势垒高度相当）。\n- $D = 1.5$（大噪声；边缘情况）。\n\n要求：\n- 将所有量视为无量纲。以浮点数形式报告跃迁速率 $k$，其单位为无量纲时间的倒数。\n- 您的离散化方法必须足够精确，以捕捉 $k$ 作为 $D$ 的函数的趋势，并且对于上述所有测试用例都应是数值稳定的。\n- 最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来、以逗号分隔的结果列表，结果顺序与上述 $D$ 值的顺序一致，每个数字四舍五入到八位小数（例如：\"[0.12345678,0.23456789,0.34567890,0.45678901,0.56789012]\"）。", "solution": "我们从过阻尼 Langevin 方程开始\n$$\ndx(t) = -V'(x(t))\\,dt + \\sqrt{2D}\\,dW_t,\n$$\n它导出正向 Fokker–Planck 方程\n$$\n\\partial_t p(x,t) = \\partial_x\\!\\left(V'(x)\\,p(x,t)\\right) + D\\,\\partial_{xx} p(x,t).\n$$\n对于此过程的泛函，与生成元相关联的反向 (Kolmogorov) 算符为\n$$\n\\mathcal{L} f(x) = -V'(x)\\,f'(x) + D\\,f''(x).\n$$\n令 $m(x)$ 表示从起点 $x$ 到达位于 $x_{\\max}$ 的吸收边界（在 $x_{\\min}$ 处有反射边界）的平均首达时间 (MFPT)。标准的首达理论指出，$m(x)$ 满足以下边值问题\n$$\n\\mathcal{L} m(x) = -1 \\quad \\text{for } x \\in (x_{\\min}, x_{\\max}),\n$$\n边界条件为\n$$\nm'(x_{\\min}) = 0 \\quad \\text{(reflecting)}, \\qquad m(x_{\\max}) = 0 \\quad \\text{(absorbing)}.\n$$\n对于当前问题，我们设置 $x_{\\min} = -2.0$，$x_{\\max} = 0.0$，以及初始位置 $x_0 = -1.0$。将算符代入反向方程，得到以下常微分方程\n$$\nD\\,m''(x) - V'(x)\\,m'(x) = -1, \\quad x \\in (-2,0),\n$$\n以及\n$$\nm'(-2) = 0, \\qquad m(0) = 0.\n$$\n\n有两种高效且数学上一致的数值策略可以解决这个一维边值问题：\n\n1) 有限差分离散化。用均匀网格离散化区间 $[x_{\\min}, x_{\\max}]$，在内部使用中心差分来近似 $m''(x)$ 和 $m'(x)$，在 $x_{\\min}$ 处使用单边二阶公式施加 Neumann 边界条件，并直接在 $x_{\\max}$ 处施加 Dirichlet 条件。这将得到一个关于 $m(x)$ 节点值的稀疏线性系统，该系统可用标准线性代数求解器求解。\n\n2) 通过积分因子的求积表示法。该常微分方程可以解析地简化为嵌套积分。定义 $\\phi(x) = V(x)/D$。将方程重写为\n$$\nm''(x) - \\phi'(x)\\,m'(x) = -\\frac{1}{D}.\n$$\n令 $y(x) = m'(x)$。则\n$$\ny'(x) - \\phi'(x)\\,y(x) = -\\frac{1}{D}.\n$$\n乘以积分因子 $e^{-\\phi(x)}$ 得到\n$$\n\\frac{d}{dx}\\!\\left(e^{-\\phi(x)} y(x)\\right) = -\\frac{1}{D} e^{-\\phi(x)}.\n$$\n从 $x_{\\min}$ 到 $x$ 积分，并使用反射边界条件 $m'(x_{\\min}) = 0$，得到\n$$\nm'(x) = -\\frac{e^{\\phi(x)}}{D}\\int_{x_{\\min}}^{x} e^{-\\phi(z)}\\,dz.\n$$\n再次从 $x$ 到 $x_{\\max}$ 积分，并使用 $m(x_{\\max}) = 0$，得到经典的一维 MFPT 公式\n$$\nm(x) = \\frac{1}{D} \\int_{x}^{x_{\\max}} e^{\\phi(y)} \\left[\\int_{x_{\\min}}^{y} e^{-\\phi(z)}\\,dz \\right] dy.\n$$\n该表示法在解析上等价于边值问题的有限差分解，并且对于当前势和测试参数，在均匀网格上使用标准求积法则时是数值稳定的。值得注意的是，在区间 $[x_0, x_{\\max}] = [-1,0]$ 上，$V(y) \\le 0$，这使得 $e^{\\phi(y)} \\le 1$，有助于保持外层积分的数值稳定性。当 $D$ 减小时，内层积分会增大，这正确地反映了 MFPT 的增长。\n\n算法设计：\n- 在 $[x_{\\min}, x_{\\max}]$ 上构建一个间距为 $\\Delta x$ 的均匀网格 $x_i$。\n- 预计算 $V(x_i) = x_i^4 - 2 x_i^2$。\n- 对于测试集中的每个 $D$，计算 $\\phi_i = V(x_i)/D$。\n- 通过梯形法则计算内层累积积分 $A(y) = \\int_{x_{\\min}}^{y} e^{-\\phi(z)} dz$，使用累积和方法可以在 $\\mathcal{O}(N)$ 时间内获得所有的 $A(x_i)$。\n- 在网格上构造 $B(y) = e^{\\phi(y)} A(y)$。\n- 对所有 $x$ 使用从右到左的累积梯形和计算外层积分 $C(x) = \\int_{x}^{x_{\\max}} B(y) dy$。然后 $m(x) = C(x)/D$。\n- 在网格上定位 $x_0$ 并计算 $m(x_0)$。跃迁速率为 $k = 1/m(x_0)$。\n\n数值考量：\n- 所选网格大小必须在精度和运行时间之间取得平衡；在 $[-2,0]$ 上使用 $N = 10001$ 个点的均匀网格会得到 $\\Delta x = 2/10000$，这对于所有测试扩散系数下的嵌套梯形积分的精确计算是足够的。\n- 所有计算均采用双精度；对于测试集中最小的 $D$（$D = 0.1$），$e^{1/D}$ 的值仍在安全的浮点数表示范围内。\n- 该算法通过累积和进行了完全向量化，以确保效率。\n\n最后，我们计算并报告测试扩散系数 $D \\in \\{0.1, 0.2, 0.5, 1.0, 1.5\\}$ 对应的跃迁速率 $k$，其单位为无量纲时间的倒数。程序会以指定格式打印一行，包含这五个速率，每个速率都四舍五入到八位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef potential(x):\n    # V(x) = x^4 - 2 x^2\n    return x**4 - 2.0 * x**2\n\ndef compute_rate_via_quadrature(D, x_grid, Vx, x_min, x_max, x0):\n    # Compute phi = V/D\n    phi = Vx / D\n\n    # Grid spacing (assume uniform)\n    h = x_grid[1] - x_grid[0]\n    N = x_grid.size\n\n    # Inner integral A(y) = \\int_{x_min}^y exp(-phi(z)) dz using cumulative trapezoid\n    exp_neg_phi = np.exp(-phi)\n    # Trapezoidal cumulative integral: A[0] = 0; for i>=1, A[i] = sum_{k=0..i-1} 0.5*(f[k]+f[k+1])*h\n    A = np.zeros(N)\n    if N > 1:\n        A[1:] = h * np.cumsum(0.5 * (exp_neg_phi[:-1] + exp_neg_phi[1:]))\n\n    # Outer integrand B(y) = exp(phi(y)) * A(y)\n    exp_phi = np.exp(phi)\n    B = exp_phi * A\n\n    # Outer integral C(x) = \\int_{x}^{x_max} B(y) dy using right-to-left cumulative trapezoid\n    # Define mid-interval averages for trapezoid\n    mid = 0.5 * (B[:-1] + B[1:])  # length N-1\n    # Suffix cumulative sum via reversed cumsum\n    s_rev = np.cumsum(mid[::-1])  # length N-1\n    C = np.zeros(N)\n    if N > 1:\n        # Map back: for node i in [0..N-2], C[i] = h * sum_{j=i}^{N-2} mid[j] = h * s_rev[N-2 - i]\n        C[:-1] = h * s_rev[::-1]\n        C[-1] = 0.0\n\n    # MFPT m(x) = C(x)/D\n    m = C / D\n\n    # Interpolate (or directly index) at x0\n    h_inv = 1.0 / h\n    idx_float = (x0 - x_min) * h_inv\n    idx = int(round(idx_float))\n    idx = max(0, min(N - 1, idx))\n    # If x0 is not exactly on a grid node due to rounding, do linear interpolation\n    x_idx = x_grid[idx]\n    if abs(x_idx - x0)  1e-12 or idx == 0 or idx == N - 1:\n        m_x0 = m[idx]\n    else:\n        if x_idx  x0 and idx + 1  N:\n            t = (x0 - x_idx) * h_inv\n            m_x0 = (1 - t) * m[idx] + t * m[idx + 1]\n        elif x_idx > x0 and idx - 1 >= 0:\n            t = (x_idx - x0) * h_inv\n            m_x0 = (1 - t) * m[idx] + t * m[idx - 1]\n        else:\n            m_x0 = m[idx]\n\n    # Transition rate k = 1 / m(x0)\n    # Guard against zero or negative (should not occur for well-posed MFPT)\n    if m_x0 = 0:\n        return float('nan')\n    return 1.0 / m_x0\n\ndef solve():\n    # Domain and initial position (dimensionless)\n    x_min = -2.0\n    x_max = 0.0\n    x0 = -1.0\n\n    # Uniform grid with sufficient resolution for stable and accurate quadrature\n    N = 10001  # ensures x0 aligns exactly with grid for this domain\n    x_grid = np.linspace(x_min, x_max, N)\n    Vx = potential(x_grid)\n\n    # Test suite diffusion coefficients (dimensionless)\n    test_cases = [0.1, 0.2, 0.5, 1.0, 1.5]\n\n    results = []\n    for D in test_cases:\n        rate = compute_rate_via_quadrature(D, x_grid, Vx, x_min, x_max, x0)\n        # Round to eight decimals as specified\n        results.append(f\"{rate:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2444390"}]}