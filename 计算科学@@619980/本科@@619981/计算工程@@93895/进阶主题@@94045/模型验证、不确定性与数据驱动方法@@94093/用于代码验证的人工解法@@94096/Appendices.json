{"hands_on_practices": [{"introduction": "我们动手实践的第一步，是解决一个我们预期能得到“完美”答案的特殊问题。这个练习为二维泊松方程精心设计了一个二次多项式形式的制造解。由于标准的中心差分格式对于二次多项式恰好是精确的，没有截断误差，因此一个正确编写的求解器应该能够计算出接近于零的误差。这个练习为你提供了一个强有力的初始验证，以确保你的求解器基本实现是正确的 [@problem_id:2444972]。", "problem": "考虑在单位正方形域 $\\Omega = [0,1] \\times [0,1]$ 上的二维泊松问题，边界条件为狄利克雷（Dirichlet）边界条件。请按如下方式应用构造解法进行代码验证。设构造解为一个二次多项式：\n$$\nu_m(x,y) = a x^2 + b x y + c y^2 + d x + e y + f,\n$$\n其中 $a$、$b$、$c$、$d$、$e$ 和 $f$ 为实常数。定义源项 $s(x,y)$，使 $u_m$ 精确满足带有负拉普拉斯算子的泊松方程：\n$$\n- \\Delta u(x,y) = s(x,y) \\quad \\text{在 } \\Omega \\text{ 中},\n$$\n以及狄利克雷边界条件：\n$$\nu(x,y) = u_m(x,y) \\quad \\text{对于 } (x,y) \\in \\partial \\Omega.\n$$\n使用标准的二阶中心有限差分格式，在均匀的笛卡尔网格上对 $-\\Delta$ 进行离散化。该网格在每个空间方向上有 $N$ 个内部节点，网格间距为 $h = \\frac{1}{N+1}$。设内部网格点为 $\\{(x_i,y_j)\\}_{i,j=1}^N$，其中 $x_i = i h$ 且 $y_j = j h$。对于每个内部节点 $(i,j)$，需要执行的离散内部方程为：\n$$\n\\frac{-u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1} + 4 u_{i,j}}{h^2} = s(x_i,y_j),\n$$\n其中边界值由 $\\partial \\Omega$ 上的 $u_m$ 给定。此处 $u_{i,j}$ 表示 $u(x_i,y_j)$ 的离散近似值。\n\n对于下方的每个测试用例，计算包括边界节点在内的完整网格上的离散解，然后报告最大节点绝对误差：\n$$\nE_\\infty = \\max_{0 \\le i \\le N+1,\\; 0 \\le j \\le N+1} \\left| u_{i,j} - u_m(x_i,y_j) \\right|.\n$$\n不涉及物理单位。若出现任何角度，都必须以弧度为单位进行解释，但此处不涉及角度。\n\n测试套件（每个用例为 $(N, a, b, c, d, e, f)$）：\n- 用例 1: $(\\,10,\\, 1.0,\\, 0.5,\\, 2.0,\\, -1.0,\\, 0.25,\\, -0.75\\,)$\n- 用例 2: $(\\,15,\\, 0.0,\\, 3.0,\\, 0.0,\\, 0.0,\\, 0.0,\\, 0.0\\,)$\n- 用例 3: $(\\,8,\\, 0.0,\\, 0.0,\\, 0.0,\\, -2.0,\\, 1.5,\\, 0.1\\,)$\n- 用例 4: $(\\,12,\\, -0.7,\\, 0.0,\\, 0.4,\\, 0.0,\\, 0.0,\\, 2.0\\,)$\n\n您的程序必须按以上列出的顺序为每个用例计算 $E_\\infty$，并生成单行输出。该行输出包含一个由方括号括起来的、以逗号分隔的四个结果列表，例如“[$r_1$,$r_2$,$r_3$,$r_4$]”。每个 $r_k$ 必须是浮点数。不允许有其他输出。", "solution": "用户提供了一个计算工程领域的问题，需要应用构造解法（Method of Manufactured Solutions, MMS）进行代码验证。任务是计算二维泊松方程有限差分解的最大节点误差，其中精确解是一个选定的构造多项式。\n\n**问题验证**\n\n首先，我必须对问题进行严格的验证。\n\n**步骤1：提取已知条件**\n- **控制方程**：二维泊松方程 $-\\Delta u(x,y) = s(x,y)$，定义在 $\\Omega = [0,1] \\times [0,1]$ 上。\n- **构造解**：$u_m(x,y) = a x^2 + b x y + c y^2 + d x + e y + f$。\n- **源项**：$s(x,y)$ 由 $-\\Delta u_m(x,y)$ 推导得出。\n- **边界条件**：狄利克雷边界条件，$u(x,y) = u_m(x,y)$ on $\\partial \\Omega$。\n- **离散化**：均匀网格上的标准二阶中心有限差分格式。\n- **网格**：每个方向 $N$ 个内部节点，间距 $h = 1/(N+1)$。网格点为 $(x_i, y_j) = (ih, jh)$。\n- **离散方程**：$\\frac{4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}}{h^2} = s(x_i,y_j)$，适用于内部节点 $i,j \\in \\{1, \\dots, N\\}$。\n- **误差度量**：$E_\\infty = \\max_{0 \\le i,j \\le N+1} | u_{i,j} - u_m(x_i,y_j) |$。\n- **测试用例**：提供了四组参数 $(N, a, b, c, d, e, f)$。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题在基础上是合理的。它使用了泊松方程、构造解法和有限差分法，这些都是数值分析和计算工程中的标准概念。\n- **适定性**：该问题是适定的。带狄利克雷条件的泊松方程有唯一解。由有限差分离散化得到的相应线性系统是非奇异的，同样有唯一解。计算误差的要求是代码验证中的一个标准程序。\n- **客观性**：问题以精确、客观的数学语言陈述，没有歧义或主观成分。\n\n该问题是自包含的、一致的且科学上有效的。所有必要的信息都已提供。\n\n**步骤3：结论与行动**\n问题有效。我将继续进行求解。\n\n**基于原理的求解设计**\n\n此问题的核心在于理解有限差分格式的截断误差。构造解法专门用于测试代码的实现，其方式是提供一个精确解已知的问题。\n\n1.  **源项推导**：\n    构造解为 $u_m(x,y) = a x^2 + b x y + c y^2 + d x + e y + f$。我们必须首先计算其拉普拉斯算子来定义源项 $s(x,y) = -\\Delta u_m(x,y)$。\n    偏导数如下：\n    $\\frac{\\partial u_m}{\\partial x} = 2ax + by + d$\n    $\\frac{\\partial^2 u_m}{\\partial x^2} = 2a$\n    $\\frac{\\partial u_m}{\\partial y} = bx + 2cy + e$\n    $\\frac{\\partial^2 u_m}{\\partial y^2} = 2c$\n    拉普拉斯算子为 $\\Delta u_m = \\frac{\\partial^2 u_m}{\\partial x^2} + \\frac{\\partial^2 u_m}{\\partial y^2} = 2a + 2c$。\n    因此，源项是一个常数：$s(x,y) = -(2a + 2c)$。\n\n2.  **截断误差分析**：\n    负拉普拉斯算子的离散算子为 $L_h u_{i,j} = \\frac{4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}}{h^2}$。\n    该算子的截断误差 $\\tau$ 由 $\\tau = L_h u - (-\\Delta u)$ 给出。对于一个足够光滑的函数 $u$，泰勒级数展开表明 $\\tau = -\\frac{h^2}{12}(\\frac{\\partial^4 u}{\\partial x^4} + \\frac{\\partial^4 u}{\\partial y^4}) + \\mathcal{O}(h^4)$。\n    该格式具有二阶精度。然而，对于我们特定的构造解 $u_m(x,y)$（一个二次多项式），所有三阶或更高阶的偏导数都恒等于零。\n    具体来说，$\\frac{\\partial^4 u_m}{\\partial x^4} = 0$ 且 $\\frac{\\partial^4 u_m}{\\partial y^4} = 0$。\n    这意味着截断误差的主项为零。实际上，所有高阶项也为零。对于二次多项式，截断误差精确为零：$\\tau = 0$。\n    这意味着当有限差分算子应用于任何二次多项式时，它能精确地再现连续微分算子：\n    $$\n    L_h u_m(x_i, y_j) = -\\Delta u_m(x_i, y_j) = s(x_i, y_j)\n    $$\n    这个恒等式是解决此问题的关键。它表明，在网格点上求值的构造解是离散方程组的精确解。\n\n3.  **数值实现策略**：\n    任务是计算离散解 $u_{i,j}$ 并将其与精确解 $u_m(x_i, y_j)$进行比较。步骤如下：\n    a.  **网格设置**：定义一个 $(N+2) \\times (N+2)$ 点的均匀网格，覆盖区域 $[0,1] \\times [0,1]$。\n    b.  **系统构建**：为 $N^2$ 个内部网格点的未知值构建线性系统 $A \\mathbf{u} = \\mathbf{b}$。矩阵 $A$ 代表五点模板的系数（对角线上为 $4$，相邻点为 $-1$）。向量 $\\mathbf{b}$ 包含源项值 $h^2 s(x_i,y_j)$ 以及从 $u_m$ 导出的已知边界值。\n    c.  **系统求解**：求解该稀疏线性系统，得到内部未知数向量 $\\mathbf{u}$。\n    d.  **误差计算**：通过将解出的内部值与给定的边界值相结合，重构完整的解网格 $u_{i,j}$。然后，计算此数值解与在网格上求值的构造解之间的最大绝对差：$E_\\infty = \\max |u_{i,j} - u_m(x_i,y_j)|$。\n\n    鉴于截断误差为零，数值解 $u_{i,j}$ 在所有网格点上必须与 $u_m(x_i, y_j)$ 相同，直至浮点精度的极限。因此，预期的误差 $E_\\infty$ 将是一个非常小的数，量级为机器ε。非零的结果将表明线性系统求解器或问题设置的实现中存在错误。所提供的代码稳健地实现了这一过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # (N, a, b, c, d, e, f)\n        (10, 1.0, 0.5, 2.0, -1.0, 0.25, -0.75),\n        (15, 0.0, 3.0, 0.0, 0.0, 0.0, 0.0),\n        (8, 0.0, 0.0, 0.0, -2.0, 1.5, 0.1),\n        (12, -0.7, 0.0, 0.4, 0.0, 0.0, 2.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, a, b, c, d, e, f = case\n        error = calculate_max_error(N, a, b, c, d, e, f)\n        results.append(f\"{error:.15e}\")\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_max_error(N, a, b, c, d, e, f):\n    \"\"\"\n    Calculates the maximum absolute nodal error for a single test case by\n    setting up and solving the discrete Poisson equation.\n    \"\"\"\n    h = 1.0 / (N + 1)\n\n    # 1. Set up the grid and coordinates.\n    # The grid is indexed by (j, i) corresponding to (y, x) for standard\n    # row-major array ordering.\n    x_coords = np.linspace(0.0, 1.0, N + 2)\n    y_coords = np.linspace(0.0, 1.0, N + 2)\n    X, Y = np.meshgrid(x_coords, y_coords, indexing='xy')\n\n    # 2. Define manufactured solution and evaluate on the grid.\n    u_m_func = lambda x, y: a*x**2 + b*x*y + c*y**2 + d*x + e*y + f\n    u_m_grid = u_m_func(X, Y)\n\n    # The source term s(x,y) = -Laplacian(u_m) = -(2a + 2c) is a constant.\n    s_val = -(2*a + 2*c)\n\n    # 3. Set up the linear system A*u = b for interior nodes.\n    # The N*N unknowns correspond to interior grid points, flattened using\n    # row-major ordering: k = (j-1)*N + (i-1).\n    \n    # Construct the sparse matrix A for the 5-point stencil:\n    # 4*u_ji - u_{j,i-1} - u_{j,i+1} - u_{j-1,i} - u_{j+1,i}\n    \n    d_main = np.full(N*N, 4.0)\n    d_h_off = np.full(N*N - 1, -1.0)\n    d_v_off = np.full(N*N - N, -1.0)\n    \n    # Zero out connections between the end of a grid row and the start of the next.\n    for j in range(1, N):\n        d_h_off[j*N - 1] = 0.0\n    \n    diagonals = [d_main, d_h_off, d_h_off, d_v_off, d_v_off]\n    offsets = [0, -1, 1, -N, N]\n    A = diags(diagonals, offsets, shape=(N*N, N*N), format='csr')\n\n    # 4. Construct the RHS vector b.\n    b = np.zeros(N*N)\n    for j in range(1, N + 1):      # y-index on grid\n        for i in range(1, N + 1):  # x-index on grid\n            k = (j - 1) * N + (i - 1)  # row-major vector index\n            \n            # Source term contribution\n            b[k] = h**2 * s_val\n            \n            # Add contributions from known boundary values\n            if i == 1:   # Left boundary (x=0)\n                b[k] += u_m_grid[j, 0]\n            if i == N:   # Right boundary (x=1)\n                b[k] += u_m_grid[j, N+1]\n            if j == 1:   # Bottom boundary (y=0)\n                b[k] += u_m_grid[0, i]\n            if j == N:   # Top boundary (y=1)\n                b[k] += u_m_grid[N+1, i]\n\n    # 5. Solve the linear system for interior node values.\n    u_interior_vec = spsolve(A, b)\n\n    # 6. Reconstruct the full solution grid.\n    u_discrete = np.zeros((N + 2, N + 2))\n    \n    # Set boundary values from manufactured solution\n    u_discrete[0, :] = u_m_grid[0, :]\n    u_discrete[N+1, :] = u_m_grid[N+1, :]\n    u_discrete[:, 0] = u_m_grid[:, 0]\n    u_discrete[:, N+1] = u_m_grid[:, N+1]\n    \n    # Fill interior with the solved values, reshaped according to row-major order.\n    u_discrete[1:N+1, 1:N+1] = u_interior_vec.reshape((N, N), order='C')\n\n    # 7. Calculate the maximum absolute error over the entire grid.\n    error = np.max(np.abs(u_discrete - u_m_grid))\n    \n    return error\n\nsolve()\n\n```", "id": "2444972"}, {"introduction": "在用一个“完美”解验证了我们的求解器之后，我们现在转向一个更典型的场景。此实践将使用一个更复杂的制造解，此时数值方法不再能精确表示解。我们的目标是进行一次收敛性研究：通过不断加密网格来测量误差的减小情况，并验证所观察到的收敛阶是否与我们所用格式的理论预期相符。这是制造解方法在实际应用中的核心工作流程 [@problem_id:2444940]。", "problem": "考虑方形域 $\\Omega = [0,1] \\times [0,1]$ 上的二维泊松方程，\n$$\\nabla^2 u(x,y) = f(x,y), \\quad (x,y) \\in \\Omega,$$\n其狄利克雷边界条件由一个制造解 $u_{m}(x,y)$ 指定，\n$$u(x,y)\\big|_{\\partial \\Omega} = u_{m}(x,y),$$\n其中\n$$u_{m}(x,y) = \\sin(\\pi x)\\,\\cosh(y) + x^2 y^3.$$\n所有三角函数的参数都必须以弧度为单位进行解释。\n\n您的任务是使用制造解方法验证泊松方程的数值求解器。具体而言：\n- 通过对制造解 $u_{m}(x,y)$ 应用拉普拉斯算子 $\\nabla^2$，精确推导源项 $f(x,y)$。\n- 在包含边界的、大小为 $N \\times N$ 个节点的均匀笛卡尔网格上，对指定的 $N$ 值，求解使用所推导的 $f(x,y)$ 的边值问题。\n- 在每个网格上，通过在 $\\partial \\Omega$ 上将 $u(x,y)$ 设置为等于 $u_{m}(x,y)$ 来精确施加狄利克雷边界条件。\n- 将计算得到的数值解 $u_{\\text{num}}$ 与网格节点上的精确制造解 $u_{m}$ 进行比较，以量化误差。\n\n为具有 $N \\times N$ 个节点和均匀间距 $h = 1/(N-1)$ 的网格定义以下误差度量：\n- 所有网格节点上的离散最大范数（无穷范数），\n$$E_{\\infty}(N) = \\max_{0 \\le i,j \\le N-1} \\left| u_{\\text{num}}(x_i,y_j) - u_{m}(x_i,y_j) \\right|.$$\n- 所有网格节点上的离散 $L^2$ 范数，\n$$E_{2}(N) = \\left( \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\left( u_{\\text{num}}(x_i,y_j) - u_{m}(x_i,y_j) \\right)^2 \\, h^2 \\right)^{1/2}.$$\n\n使用离散 $L^2$ 误差，计算两个尺寸分别为 $N_1$ 和 $N_2$（其中 $N_2 = 2N_1 - 1$，使得网格间距减半）的网格之间的观测精度阶数 $p$，公式如下\n$$p = \\frac{\\log\\left( \\dfrac{E_{2}(N_1)}{E_{2}(N_2)} \\right)}{\\log(2)}.$$\n\n角度单位说明：所有角度均为弧度。\n\n测试套件和要求的输出：\n- 测试用例 1：$N = 3$。报告 $E_{\\infty}(3)$。\n- 测试用例 2：$N = 9$。报告 $E_{2}(9)$。\n- 测试用例 3：$N_1 = 17$ 和 $N_2 = 33$。根据上述公式，报告由 $E_{2}(17)$ 和 $E_{2}(33)$ 计算出的观测阶数 $p$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序为 $[E_{\\infty}(3), E_{2}(9), p]$。\n- 每个数值条目必须格式化为小数点后恰好有 $10$ 位的小数。\n- 例如，一个有效的输出行格式为：$[0.1234567890,0.0123456789,1.9876543210]$。", "solution": "所述问题构成了一个适定的、具有科学依据的数值方法验证任务。它遵循了计算工程的既定原则，特别是使用制造解方法来验证泊松方程有限差分求解器的实现。所有必要的数据、方程和定义均已提供，不存在内部矛盾或与科学相悖的事实。因此，该问题是有效的，并将构建一个解。\n\n该方法包括两个主要阶段：首先，解析推导制造解所需的源项；其次，对得到的边值问题进行数值求解并计算误差度量。\n\n首先，我们通过对指定的制造解 $u_{m}(x,y)$ 应用拉普拉斯算子 $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$ 来推导源项 $f(x,y)$。\n制造解给出如下：\n$$u_{m}(x,y) = \\sin(\\pi x)\\cosh(y) + x^2 y^3$$\n我们计算关于 $x$ 和 $y$ 的偏导数。\n对于 $x$ 的导数：\n$$ \\frac{\\partial u_{m}}{\\partial x} = \\pi \\cos(\\pi x)\\cosh(y) + 2x y^3 $$\n$$ \\frac{\\partial^2 u_{m}}{\\partial x^2} = -\\pi^2 \\sin(\\pi x)\\cosh(y) + 2 y^3 $$\n对于 $y$ 的导数：\n$$ \\frac{\\partial u_{m}}{\\partial y} = \\sin(\\pi x)\\sinh(y) + 3x^2 y^2 $$\n$$ \\frac{\\partial^2 u_{m}}{\\partial y^2} = \\sin(\\pi x)\\cosh(y) + 6x^2 y $$\n源项 $f(x,y)$ 是这些二阶导数之和：\n$$ f(x,y) = \\nabla^2 u_{m} = \\frac{\\partial^2 u_{m}}{\\partial x^2} + \\frac{\\partial^2 u_{m}}{\\partial y^2} $$\n$$ f(x,y) = \\left(-\\pi^2 \\sin(\\pi x)\\cosh(y) + 2 y^3\\right) + \\left(\\sin(\\pi x)\\cosh(y) + 6x^2 y\\right) $$\n合并各项得到精确的源函数：\n$$ f(x,y) = (1 - \\pi^2)\\sin(\\pi x)\\cosh(y) + 6x^2 y + 2y^3 $$\n\n其次，我们在覆盖域 $\\Omega = [0,1] \\times [0,1]$ 的 $N \\times N$ 个节点的均匀笛卡尔网格上求解泊松方程 $\\nabla^2 u(x,y) = f(x,y)$。网格坐标为 $x_j = j h$ 和 $y_i = i h$，其中 $i,j \\in \\{0, 1, \\dots, N-1\\}$，网格间距为 $h = 1/(N-1)$。令 $U_{i,j}$ 表示 $u(y_i, x_j)$ 的数值近似。在每个内部节点 $(y_i, x_j)$（其中 $i,j \\in \\{1, \\dots, N-2\\}$）处，使用二阶中心有限差分格式来近似拉普拉斯算子：\n$$ \\frac{U_{i,j+1} - 2U_{i,j} + U_{i,j-1}}{h^2} + \\frac{U_{i+1,j} - 2U_{i,j} + U_{i-1,j}}{h^2} = f(y_i, x_j) $$\n整理此差分格式可为每个内部节点得到一个线性方程：\n$$ U_{i,j-1} + U_{i,j+1} + U_{i-1,j} + U_{i+1,j} - 4U_{i,j} = h^2 f(y_i, x_j) $$\n这组针对 $(N-2)^2$ 个未知内部节点值的 $(N-2)^2$ 个方程构成了一个形式为 $A \\mathbf{u} = \\mathbf{b}$ 的线性系统。向量 $\\mathbf{u}$ 包含未知值 $U_{i,j}$，例如，按行主序排列。矩阵 $A$ 是一个稀疏的块三对角矩阵，表示有限差分格式的连通性。右侧向量 $\\mathbf{b}$ 包含经已知边界条件调整后的 $h^2 f(y_i, x_j)$ 值。对于与边界相邻的内部节点 $(y_i, x_j)$，差分格式中的相应项（例如，如果 $i=1$，则为 $U_{0,j}$）是来自狄利克雷条件 $u_m(y_0, x_j)$ 的已知值，并被移到方程的右侧。\n\n通过求解此线性系统得到内部值，并将其与由 $u_m(x,y)$ 指定的精确边界值相结合，从而组装出完整的数值解 $u_{\\text{num}}$。\n\n使用指定的离散范数量化误差。离散最大范数 $E_{\\infty}(N)$ 计算如下：\n$$ E_{\\infty}(N) = \\max_{0 \\le i,j \\le N-1} | u_{\\text{num}}(y_i, x_j) - u_{m}(y_i, x_j) | $$\n离散 $L^2$ 范数 $E_{2}(N)$ 计算如下：\n$$ E_{2}(N) = \\left( \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} ( u_{\\text{num}}(y_i, x_j) - u_{m}(y_i, x_j) )^2 h^2 \\right)^{1/2} $$\n然后，通过比较两个相继加密的网格（$N_1$ 和 $N_2=2N_1-1$, 这对应于网格间距 $h$ 减半）上的 $L^2$ 误差来计算观测精度阶数 $p$：\n$$ p = \\frac{\\log( E_{2}(N_1) / E_{2}(N_2) )}{\\log(2)} $$\n该值预计约为 $2$，与有限差分格式的二阶精度一致。\n\n该实现将为指定的 $N$ 值（$N=3, 9, 17, 33$）构建并求解线性系统，以计算所要求的误差度量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solution process for all test cases.\n    \"\"\"\n    \n    # Define PI for use in trigonometric functions.\n    PI = np.pi\n\n    def u_m(x, y):\n        \"\"\"\n        Computes the manufactured solution u_m(x,y).\n        - x, y can be NumPy arrays.\n        \"\"\"\n        return np.sin(PI * x) * np.cosh(y) + x**2 * y**3\n\n    def f_source(x, y):\n        \"\"\"\n        Computes the source term f(x,y) derived from grad^2(u_m).\n        - x, y can be NumPy arrays.\n        \"\"\"\n        term1 = (1.0 - PI**2) * np.sin(PI * x) * np.cosh(y)\n        term2 = 6.0 * x**2 * y\n        term3 = 2.0 * y**3\n        return term1 + term2 + term3\n\n    def solve_poisson(N):\n        \"\"\"\n        Solves the Poisson equation on an N x N grid using finite differences.\n        \n        Args:\n            N (int): The number of nodes along one dimension of the grid.\n\n        Returns:\n            tuple: A tuple containing:\n                - u_num (np.ndarray): The N x N numerical solution array.\n                - u_exact (np.ndarray): The N x N exact manufactured solution array.\n                - h (float): The grid spacing.\n        \"\"\"\n        if N < 2:\n            raise ValueError(\"Grid size N must be at least 2.\")\n        if N == 2: # No interior points\n            h = 1.0\n            x = np.linspace(0.0, 1.0, N)\n            y = np.linspace(0.0, 1.0, N)\n            xx, yy = np.meshgrid(x, y, indexing='xy')\n            u_exact = u_m(xx, yy)\n            return u_exact, u_exact, h\n\n        # 1. Grid setup\n        h = 1.0 / (N - 1)\n        x = np.linspace(0.0, 1.0, N)\n        y = np.linspace(0.0, 1.0, N)\n        xx, yy = np.meshgrid(x, y, indexing='xy')\n\n        # 2. Evaluate exact solution and source term\n        u_exact = u_m(xx, yy)\n        f_vals = f_source(xx, yy)\n\n        # 3. Setup linear system Ax = b for interior points\n        num_interior_nodes_1d = N - 2\n        num_unknowns = num_interior_nodes_1d**2\n        \n        A = np.zeros((num_unknowns, num_unknowns))\n        b = np.zeros(num_unknowns)\n\n        # The mapping from 2D interior grid index (i_int, j_int) to 1D vector index k\n        # is row-major: k = i_int * num_interior_nodes_1d + j_int\n        # This corresponds to full grid index (i, j) where i = i_int + 1, j = j_int + 1\n        for k in range(num_unknowns):\n            i_int = k // num_interior_nodes_1d\n            j_int = k % num_interior_nodes_1d\n            \n            i = i_int + 1\n            j = j_int + 1\n\n            # Main diagonal coefficient for -4*U_ij\n            A[k, k] = -4.0\n\n            # Right-hand side from source term f(y_i, x_j)\n            b[k] = h**2 * f_vals[i, j]\n\n            # Neighbor contribution (x-direction, j-1)\n            if j == 1:\n                b[k] -= u_exact[i, 0]\n            else:\n                A[k, k - 1] = 1.0\n\n            # Neighbor contribution (x-direction, j+1)\n            if j == N - 2:\n                b[k] -= u_exact[i, N - 1]\n            else:\n                A[k, k + 1] = 1.0\n\n            # Neighbor contribution (y-direction, i-1)\n            if i == 1:\n                b[k] -= u_exact[0, j]\n            else:\n                A[k, k - num_interior_nodes_1d] = 1.0\n\n            # Neighbor contribution (y-direction, i+1)\n            if i == N - 2:\n                b[k] -= u_exact[N - 1, j]\n            else:\n                A[k, k + num_interior_nodes_1d] = 1.0\n\n        # 4. Solve the linear system\n        u_interior_flat = np.linalg.solve(A, b)\n        u_interior = u_interior_flat.reshape((num_interior_nodes_1d, num_interior_nodes_1d))\n\n        # 5. Construct the full numerical solution grid\n        u_num = np.copy(u_exact)  # Initialize with correct boundary values\n        u_num[1:N-1, 1:N-1] = u_interior\n\n        return u_num, u_exact, h\n\n    # Test case 1: N = 3, compute E_infinity\n    u_num_3, u_exact_3, _ = solve_poisson(N=3)\n    e_inf_3 = np.max(np.abs(u_num_3 - u_exact_3))\n\n    # Test case 2: N = 9, compute E_2\n    u_num_9, u_exact_9, h_9 = solve_poisson(N=9)\n    e_2_9 = np.sqrt(np.sum((u_num_9 - u_exact_9)**2) * h_9**2)\n\n    # Test case 3: N1=17, N2=33, compute order of accuracy p\n    # Compute E_2 for N=17\n    u_num_17, u_exact_17, h_17 = solve_poisson(N=17)\n    e_2_17 = np.sqrt(np.sum((u_num_17 - u_exact_17)**2) * h_17**2)\n    \n    # Compute E_2 for N=33\n    u_num_33, u_exact_33, h_33 = solve_poisson(N=33)\n    e_2_33 = np.sqrt(np.sum((u_num_33 - u_exact_33)**2) * h_33**2)\n    \n    # Compute order of accuracy p\n    p = np.log(e_2_17 / e_2_33) / np.log(2.0)\n    \n    # Compile and format results\n    results = [e_inf_3, e_2_9, p]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.10f}' for x in results)}]\")\n\nsolve()\n```", "id": "2444940"}, {"introduction": "掌握了稳态问题后，我们将技能扩展到瞬态（时间依赖）现象。本练习将制造解方法应用于一维热传导方程，这是一个基本的抛物型偏微分方程。你需要实现一个时间步进格式（Crank-Nicolson 方法），并处理在空间和时间上都变化的源项，从而验证代码在时空两个维度上的准确性 [@problem_id:2445001]。", "problem": "您将应用制造解方法 (MMS) 来验证一个用于瞬态热方程的一维数值求解器。考虑在有限区间上的带源项的无量纲热方程，\n$$\nu_t = \\alpha\\,u_{xx} + s(x,t), \\quad x \\in [0,L], \\ t \\in [0,T],\n$$\n其具有狄利克雷边界条件和已知的初始条件。制造解方法 (MMS) 的流程是：选择一个光滑的精确解 $u_m(x,t)$，将其代入微分方程，并定义源项 $s(x,t)$，从而使 $u_m(x,t)$ 同一地满足该方程。通过将数值解与 $u_m(x,t)$ 进行比较，可以实现客观的代码验证。\n\n使用制造解\n$$\nu_m(x,t) = e^{-k t}\\,\\cos(a x),\n$$\n其中 $a \\ge 0$ 和 $k \\ge 0$ 是实数参数，$\\cos(\\cdot)$ 的参数以弧度为单位。所有量均为无量纲。任务是：\n\n- 仅使用微积分和微分算子定义，推导由 $u_m(x,t)$ 的选择所蕴含的源项 $s(x,t)$。\n- 在均匀网格上，使用 Crank–Nicolson 方法进行时间离散，使用二阶中心差分进行空间离散，来对偏微分方程进行离散化。施加来自 $u_m(x,t)$ 的狄利克雷边界条件和初始条件 $u(x,0)=u_m(x,0)$。时间步长 $\\Delta t$ 的选择必须与 $\\Delta x$ 成正比，以平衡时间和空间误差。\n- 对于每个测试用例，在两个连续加密的网格上计算最终时间 $t=T$ 时的数值解（两个网格的空间区间数相差2倍），并通过以下公式估算观测精度阶 $p$：\n$$\np \\;=\\; \\frac{\\log\\left(E_{\\mathrm{coarse}}/E_{\\mathrm{fine}}\\right)}{\\log(2)},\n$$\n其中 $E$ 是在 $t=T$ 时所有网格节点上的离散均方根误差，\n$$\nE \\;=\\; \\sqrt{\\frac{1}{N+1}\\sum_{j=0}^{N}\\left(u_j^N - u_m(x_j,T)\\right)^2},\n$$\n$N$ 为空间区间数，$x_j=j\\,\\Delta x$，$u_j^N$ 为节点 $j$ 在时间层 $N$ 处的数值解。\n- 您的时间步长选择必须近似满足 $\\Delta t = \\gamma\\,\\Delta x$，具体实现为取 $N_t = \\lceil T/(\\gamma\\,\\Delta x)\\rceil$ 个时间步，然后设置 $\\Delta t = T/N_t$。使用 Crank–Nicolson 格式，其中源项通过时间上的梯形法则进行计算。\n\n您的推导仅需基于以下基本事实：\n- 时间和空间偏导数的定义以及链式法则。\n- $\\cos(a x)$ 的空间二阶导数是 $-a^2 \\cos(a x)$。\n- Crank–Nicolson 方法是应用于半离散系统的时间梯形法则，并且二阶中心差分近似 $u_{xx}$。\n\n角度单位说明：计算 $\\cos(\\cdot)$ 时，其参数以弧度为单位。\n\n测试套件：\n- 用例 $1$ (一般情况)：$\\alpha=0.7$, $a=3.0$, $k=2.5$, $L=\\pi$, $T=0.2$, $N_{\\text{coarse}}=50$, $\\gamma=0.4$。\n- 用例 $2$ (弱扩散)：$\\alpha=0.001$, $a=4.0$, $k=0.5$, $L=\\pi$, $T=0.05$, $N_{\\text{coarse}}=60$, $\\gamma=0.4$。\n- 用例 $3$ (空间常数解)：$\\alpha=0.9$, $a=0.0$, $k=1.2$, $L=1.0$, $T=0.3$, $N_{\\text{coarse}}=40$, $\\gamma=0.4$。\n\n对于每个用例，使用两个网格：包含 $N_{\\text{coarse}}$ 个空间区间的粗网格和包含 $2N_{\\text{coarse}}$ 个区间的细网格，时间步长按上述方法选择。根据 $t=T$ 时的两个误差计算观测精度阶 $p$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个用例的观测精度阶，形式为方括号括起来的逗号分隔列表，每个值四舍五入到三位小数，例如 $\\texttt{[2.001,1.998,2.004]}$。", "solution": "首先对问题陈述进行严格验证。\n\n**步骤 1：提取给定信息**\n- **控制方程：** $u_t = \\alpha\\,u_{xx} + s(x,t)$，对于 $x \\in [0,L]$ 和 $t \\in [0,T]$。\n- **制造解：** $u_m(x,t) = e^{-k t}\\,\\cos(a x)$，其中 $a \\ge 0$, $k \\ge 0$。\n- **观测精度阶公式：** $p \\;=\\; \\frac{\\log\\left(E_{\\mathrm{coarse}}/E_{\\mathrm{fine}}\\right)}{\\log(2)}$。\n- **误差度量：** 离散均方根误差为 $E \\;=\\; \\sqrt{\\frac{1}{N+1}\\sum_{j=0}^{N}\\left(u_j^N - u_m(x_j,T)\\right)^2}$。\n- **数值方法：** 时间上采用 Crank–Nicolson 方法，空间上采用二阶中心差分。从 $u_m(x,t)$ 施加狄利克雷边界条件和初始条件。\n- **时间步长规则：** $\\Delta t = \\gamma\\,\\Delta x$ 近似地，通过 $N_t = \\lceil T/(\\gamma\\,\\Delta x)\\rceil$ 和 $\\Delta t = T/N_t$ 实现。源项使用时间上的梯形法则进行计算。\n- **测试套件：**\n    - 用例 1：$\\alpha=0.7$, $a=3.0$, $k=2.5$, $L=\\pi$, $T=0.2$, $N_{\\text{coarse}}=50$, $\\gamma=0.4$。\n    - 用例 2：$\\alpha=0.001$, $a=4.0$, $k=0.5$, $L=\\pi$, $T=0.05$, $N_{\\text{coarse}}=60$, $\\gamma=0.4$。\n    - 用例 3：$\\alpha=0.9$, $a=0.0$, $k=1.2$, $L=1.0$, $T=0.3$, $N_{\\text{coarse}}=40$, $\\gamma=0.4$。\n\n**步骤 2：使用提取的给定信息进行验证**\n根据既定的有效性标准对问题陈述进行评估。\n- **科学依据：** 该问题基于一维热方程，这是物理学中的一个基本偏微分方程。制造解方法 (MMS) 是计算科学中用于代码验证的一种标准、公认的技术。指定的数值方法——Crank-Nicolson 和中心差分——是规范、易于理解的算法。该问题在科学上是合理的。\n- **适定性与完整性：** 该问题描述了一个适定的初边值问题。所有必要的参数、函数、边界条件和离散化规则都已明确定义。计算观测精度阶的任务是明确的。该问题是自洽和完整的。\n- **客观性：** 该问题以精确、客观的数学语言陈述，没有主观或模糊的解释。\n\n**步骤 3：结论与行动**\n该问题是有效的。它是验证偏微分方程数值方法的一个标准练习。我们开始求解。\n\n**源项的推导**\n\n定义源项 $s(x,t)$ 是为了确保制造解 $u_m(x,t)$ 恒满足该偏微分方程。我们重排偏微分方程以求解 $s(x,t)$：\n$$\ns(x,t) = u_t - \\alpha\\,u_{xx}\n$$\n制造解为 $u_m(x,t) = e^{-k t}\\,\\cos(a x)$。我们计算它关于时间和空间的的偏导数。\n\n关于时间 $t$ 的偏导数是：\n$$\nu_t = \\frac{\\partial}{\\partial t}\\left(e^{-k t}\\,\\cos(a x)\\right) = -k\\,e^{-k t}\\,\\cos(a x)\n$$\n关于空间 $x$ 的一阶偏导数是：\n$$\nu_x = \\frac{\\partial}{\\partial x}\\left(e^{-k t}\\,\\cos(a x)\\right) = -a\\,e^{-k t}\\,\\sin(a x)\n$$\n关于空间 $x$ 的二阶偏导数是：\n$$\nu_{xx} = \\frac{\\partial}{\\partial x}\\left(-a\\,e^{-k t}\\,\\sin(a x)\\right) = -a^2\\,e^{-k t}\\,\\cos(a x)\n$$\n将 $u_t$ 和 $u_{xx}$ 的表达式代入 $s(x,t)$ 的方程，得到：\n$$\ns(x,t) = \\left(-k\\,e^{-k t}\\,\\cos(a x)\\right) - \\alpha\\,\\left(-a^2\\,e^{-k t}\\,\\cos(a x)\\right)\n$$\n提取公因式，我们得到源项的最终表达式：\n$$\ns(x,t) = (\\alpha\\,a^2 - k)\\,e^{-k t}\\,\\cos(a x)\n$$\n\n**数值离散化**\n\n偏微分方程在均匀网格上进行离散化，空间步长为 $\\Delta x = L/N$，时间步长为 $\\Delta t = T/N_t$。令 $u_j^n$ 为网格点 $x_j=j\\Delta x$ 和时间 $t_n=n\\Delta t$ 处解 $u(x_j, t_n)$ 的近似值。\n\n将 Crank-Nicolson 方法应用于半离散方程 $u_t = F(u,t)$，其中 $F(u,t) = \\alpha u_{xx} + s(x,t)$。这得到：\n$$\n\\frac{u^{n+1} - u^n}{\\Delta t} = \\frac{1}{2}\\left( F(u^n, t_n) + F(u^{n+1}, t_{n+1}) \\right)\n$$\n空间导数 $u_{xx}$ 使用二阶中心差分进行近似：\n$$\n(u_{xx})_j \\approx \\frac{u_{j+1} - 2u_j + u_{j-1}}{(\\Delta x)^2}\n$$\n将此代入 Crank-Nicolson 格式，得到内部节点 $j \\in \\{1, 2, \\dots, N-1\\}$ 的全离散方程：\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} = \\frac{\\alpha}{2}\\left( \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2} + \\frac{u_{j+1}^{n+1} - 2u_j^{n+1} + u_{j-1}^{n+1}}{(\\Delta x)^2} \\right) + \\frac{1}{2}(s_j^n + s_j^{n+1})\n$$\n其中 $s_j^n = s(x_j, t_n)$。我们重排方程，将时间层 $n+1$ 的未知项归到左侧 (LHS)，将时间层 $n$ 的已知项归到右侧 (RHS)。定义无量纲参数 $\\lambda = \\frac{\\alpha \\Delta t}{2(\\Delta x)^2}$。\n$$\n-\\lambda u_{j-1}^{n+1} + (1+2\\lambda)u_j^{n+1} - \\lambda u_{j+1}^{n+1} = \\lambda u_{j-1}^n + (1-2\\lambda)u_j^n + \\lambda u_{j+1}^n + \\frac{\\Delta t}{2}(s_j^n + s_j^{n+1})\n$$\n这构成了一个关于内部节点未知值向量 $\\mathbf{u}_{\\text{int}}^{n+1} = [u_1^{n+1}, u_2^{n+1}, \\dots, u_{N-1}^{n+1}]^T$ 的三对角线性方程组。该系统形式为 $A \\mathbf{u}_{\\text{int}}^{n+1} = \\mathbf{d}$。矩阵 $A$ 是一个 $(N-1) \\times (N-1)$ 的三对角矩阵，其主对角线元素为 $(1+2\\lambda)$，非对角线元素为 $-\\lambda$。\n\n右侧向量 $\\mathbf{d}$ 取决于时间 $n$ 的解和时间 $n+1$ 的边界条件。狄利克雷边界条件由制造解给出：\n$$\nu_0^{n+1} = u_m(0, t_{n+1}) \\quad \\text{和} \\quad u_N^{n+1} = u_m(L, t_{n+1})\n$$\n右侧向量 $\\mathbf{d}$ 的第 $j$ 个分量（对于 $j \\in \\{1, \\dots, N-1\\}$）是：\n$$\nd_{j-1} = \\lambda u_{j-1}^n + (1-2\\lambda)u_j^n + \\lambda u_{j+1}^n + \\frac{\\Delta t}{2}(s_j^n + s_j^{n+1})\n$$\n将左侧的边界项移到右侧。对于第一个方程（$j=1$），项 $-\\lambda u_0^{n+1}$ 被移走，所以我们将 $\\lambda u_0^{n+1}$ 加到 $d_0$ 上。对于最后一个方程（$j=N-1$），项 $-\\lambda u_N^{n+1}$ 被移走，所以我们将 $\\lambda u_N^{n+1}$ 加到 $d_{N-2}$ 上。\n\n总的算法如下：\n1.  对于给定的测试用例，设置参数 $\\alpha, a, k, L, T, N, \\gamma$。\n2.  计算网格参数：$\\Delta x = L/N$, $N_t = \\lceil T/(\\gamma \\Delta x) \\rceil$, $\\Delta t = T/N_t$。\n3.  初始化 $t=0$ 时的解：$u_j^0 = u_m(x_j, 0)$ 对于所有 $j \\in \\{0, \\dots, N\\}$。\n4.  构造常数三对角矩阵 $A$。\n5.  从 $n=0$ 迭代到 $N_t-1$：\n    a. 使用解 $u^n$ 和 $t_{n+1}$ 时的边界值构造右侧向量 $\\mathbf{d}$。\n    b. 求解线性系统 $A \\mathbf{u}_{\\text{int}}^{n+1} = \\mathbf{d}$ 以得到内部节点的值。为提高效率，使用专门的三对角求解器。\n    c. 用新计算的内部值和已知的边界值更新完整的解向量 $u^{n+1}$。\n6.  在最后的时间步之后，通过将数值解 $u^{N_t}$ 与精确解 $u_m(x, T)$ 进行比较，计算 RMS 误差 $E$。\n7.  对粗网格 ($N_{\\text{coarse}}$) 和细网格 ($2N_{\\text{coarse}}$) 重复步骤 1-6，以获得 $E_{\\text{coarse}}$ 和 $E_{\\text{fine}}$。\n8.  使用提供的公式计算观测精度阶 $p$。\n\nCrank-Nicolson 格式在空间和时间上都是二阶的。当 $\\Delta t \\propto \\Delta x$ 时，预期的精度阶为 $p=2$。这将对所有测试用例进行验证，包括 $a=0$ 的情况，此时空间依赖性消失。对于 $a=0$，空间离散误差恒为零，问题简化为求解一个常微分方程，对此梯形法则（Crank-Nicolson）也具有二阶精度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the Method of Manufactured Solutions verification.\n    \"\"\"\n    test_cases = [\n        # Case 1 (general)\n        {'alpha': 0.7, 'a': 3.0, 'k': 2.5, 'L': np.pi, 'T': 0.2, 'N_coarse': 50, 'gamma': 0.4},\n        # Case 2 (weak diffusion)\n        {'alpha': 0.001, 'a': 4.0, 'k': 0.5, 'L': np.pi, 'T': 0.05, 'N_coarse': 60, 'gamma': 0.4},\n        # Case 3 (spatially constant solution)\n        {'alpha': 0.9, 'a': 0.0, 'k': 1.2, 'L': 1.0, 'T': 0.3, 'N_coarse': 40, 'gamma': 0.4},\n    ]\n\n    orders_of_accuracy = []\n\n    for case in test_cases:\n        N_coarse = case['N_coarse']\n        N_fine = 2 * N_coarse\n\n        error_coarse = run_simulation(N=N_coarse, **case)\n        error_fine = run_simulation(N=N_fine, **case)\n\n        # Handle potential zero errors, which can occur with perfect solutions\n        if error_fine == 0.0 or error_coarse == 0.0:\n            # If the solution is exact, the notion of convergence order is moot.\n            # We can consider it to be infinite, but for practical reporting,\n            # a large number or a special value is appropriate.\n            # Given the problem's focus on 2nd-order schemes, a perfect result\n            # far exceeds expectations. Here, we report 0.0 as it implies no error.\n            p = 0.0 \n        else:\n            p = np.log(error_coarse / error_fine) / np.log(2.0)\n        \n        orders_of_accuracy.append(p)\n\n    # Format the final output string\n    formatted_results = [f\"{p:.3f}\" for p in orders_of_accuracy]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_simulation(N, alpha, a, k, L, T, gamma, **kwargs):\n    \"\"\"\n    Runs a single simulation for the 1D heat equation and returns the RMS error.\n    \n    Args:\n        N (int): Number of spatial intervals.\n        alpha (float): Thermal diffusivity.\n        a (float): Spatial frequency in manufactured solution.\n        k (float): Temporal decay rate in manufactured solution.\n        L (float): Length of the spatial domain [0, L].\n        T (float): Final time of the simulation.\n        gamma (float): Proportionality constant for time step (dt ~ gamma * dx).\n\n    Returns:\n        float: The discrete L2 norm of the error at the final time T.\n    \"\"\"\n    # Manufactured solution and its derivatives\n    def u_m(x, t):\n        return np.exp(-k * t) * np.cos(a * x)\n\n    def s(x, t):\n        return (alpha * a**2 - k) * np.exp(-k * t) * np.cos(a * x)\n\n    # Grid parameters\n    dx = L / N\n    # The number of time steps must be an integer, ceil ensures we reach T\n    Nt = int(np.ceil(T / (gamma * dx)))\n    dt = T / Nt\n    x = np.linspace(0.0, L, N + 1)\n    \n    # Crank-Nicolson parameter\n    lambda_cn = alpha * dt / (2.0 * dx**2)\n\n    # Initialize solution u at t=0\n    u_n = u_m(x, 0.0)\n    \n    # Set up the tridiagonal matrix A for the linear system in banded format\n    # The system is for N-1 internal points\n    N_internal = N - 1\n    if N_internal > 0:\n        A_banded = np.zeros((3, N_internal))\n        A_banded[0, 1:] = -lambda_cn  # Upper diagonal\n        A_banded[1, :] = 1.0 + 2.0 * lambda_cn  # Main diagonal\n        A_banded[2, :-1] = -lambda_cn  # Lower diagonal\n\n    # Time-stepping loop\n    for n in range(Nt):\n        t_n = n * dt\n        t_np1 = (n + 1) * dt\n        \n        u_np1 = np.zeros_like(u_n)\n\n        # Boundary conditions at time t_np1\n        u0_np1 = u_m(0.0, t_np1)\n        uN_np1 = u_m(L, t_np1)\n        u_np1[0] = u0_np1\n        u_np1[-1] = uN_np1\n\n        if N_internal > 0:\n            # Construct the RHS vector d\n            u_internal = u_n[1:-1]\n            x_internal = x[1:-1]\n            \n            # Contribution from known solution at time t_n\n            rhs = (lambda_cn * u_n[:-2] +\n                   (1.0 - 2.0 * lambda_cn) * u_internal +\n                   lambda_cn * u_n[2:])\n            \n            # Contribution from source term\n            s_n = s(x_internal, t_n)\n            s_np1 = s(x_internal, t_np1)\n            rhs += (dt / 2.0) * (s_n + s_np1)\n            \n            # Add boundary condition contributions from LHS\n            rhs[0] += lambda_cn * u0_np1\n            rhs[-1] += lambda_cn * uN_np1\n            \n            # Solve the tridiagonal system for internal nodes\n            u_internal_np1 = solve_banded((1, 1), A_banded, rhs)\n            u_np1[1:-1] = u_internal_np1\n        \n        u_n = u_np1\n\n    # Final solution at t=T\n    u_numerical = u_n\n    u_exact = u_m(x, T)\n\n    # Calculate RMS error over all nodes (including boundaries)\n    error = np.sqrt(np.mean((u_numerical - u_exact)**2))\n    \n    return error\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2445001"}]}