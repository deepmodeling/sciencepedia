{"hands_on_practices": [{"introduction": "工程系统（如通信网络）的性能往往受到不确定性的影响。我们不仅关心其平均表现，更关心性能的波动范围以及发生极端事件（例如高延迟）的可能性。本练习将非侵入式的随机配置 (Stochastic Collocation, SC) 方法应用于一个网络延迟模型，通过与精确解析解进行比较，来验证我们数值方法的准确性，从而为理解 SC 方法奠定坚实的基础。[@problem_id:2439651]", "problem": "考虑一个具有 $n$ 个链路的串联网络，其中链路 $i$ 上的延迟是一个独立的随机变量 $X_i$，服从形状参数为 $k_i \\gt 0$、公共尺度参数为 $\\theta \\gt 0$ 的伽马分布。总延迟为 $L = \\sum_{i=1}^{n} X_i$。对于给定的阈值 $t^\\star \\gt 0$，将超出概率定义为 $\\mathbb{P}(L \\gt t^\\star)$。设 $\\phi_1(L) = L$、$\\phi_2(L) = L^2$ 和 $\\phi_3(L) = \\mathbf{1}_{\\{L \\gt t^\\star\\}}$，其中 $\\mathbf{1}$ 表示指示函数。$\\mathbb{E}[\\phi_1(L)]$、$\\mathrm{Var}(L)$ 和 $\\mathbb{E}[\\phi_3(L)]$ 的精确解析值必须从第一性原理出发进行计算，除了独立性和伽马分布的定义外，不假设任何特殊情况的公式。\n\n通过以下数学构造来定义期望值 $\\mathbb{E}[\\phi_j(L)]$ 的随机配置 (SC) 近似。设 $U_i \\sim \\mathrm{Uniform}(0,1)$ 为独立的随机变量，并使用参数为 $(k_i,\\theta)$ 的伽马分布的逆累积分布函数定义 $X_i = F^{-1}_{X_i}(U_i)$。那么，对于 $L = \\sum_{i=1}^{n} X_i$ 的一个可测函数 $\\phi(L)$，有\n$$\n\\mathbb{E}[\\phi(L)] = \\int_{[0,1]^n} \\phi\\!\\left(\\sum_{i=1}^{n} F^{-1}_{X_i}(u_i)\\right)\\,\\mathrm{d}u_1 \\cdots \\mathrm{d}u_n.\n$$\n对于一个固定的整数 $q \\ge 2$，定义在 $[-1,1]$ 上的 $q$ 点高斯-勒让德节点 $\\{\\xi_\\ell,w_\\ell\\}_{\\ell=1}^{q}$，并通过 $p_\\ell = (\\xi_\\ell+1)/2$（权重为 $\\omega_\\ell = w_\\ell/2$）将它们映射到 $[0,1]$ 上。使用 $q$ 阶张量积求积的 SC 近似为\n$$\n\\mathcal{Q}_q[\\phi] = \\sum_{\\ell_1=1}^{q} \\cdots \\sum_{\\ell_n=1}^{q} \\left(\\prod_{i=1}^{n} \\omega_{\\ell_i}\\right)\\,\n\\phi\\!\\left(\\sum_{i=1}^{n} F^{-1}_{X_i}(p_{\\ell_i})\\right).\n$$\n使用 $\\mathcal{Q}_q[\\phi_1]$ 和 $\\mathcal{Q}_q[\\phi_2]$ 构建均值的 SC 近似 $\\mu_{\\mathrm{SC}} = \\mathcal{Q}_q[\\phi_1]$ 和方差的 SC 近似 $\\sigma^2_{\\mathrm{SC}} = \\mathcal{Q}_q[\\phi_2] - \\left(\\mathcal{Q}_q[\\phi_1]\\right)^2$，并使用 $\\mathcal{Q}_q[\\phi_3]$ 近似超出概率 $p_{\\mathrm{SC}} = \\mathcal{Q}_q[\\phi_3]$。\n\n对于下文中的每个测试用例，计算：\n- 精确均值 $\\mu_{\\mathrm{exact}} = \\mathbb{E}[L]$，单位为秒，\n- 精确方差 $\\sigma^2_{\\mathrm{exact}} = \\mathrm{Var}(L)$，单位为平方秒，\n- 精确超出概率 $p_{\\mathrm{exact}} = \\mathbb{P}(L \\gt t^\\star)$，以小数形式表示，\n以及使用上述定义和指定的 $q$ 计算的 SC 近似值 $\\mu_{\\mathrm{SC}}$、$\\sigma^2_{\\mathrm{SC}}$ 和 $p_{\\mathrm{SC}}$。\n\n您的程序必须为每个测试用例输出绝对误差：\n$$\n|\\mu_{\\mathrm{SC}} - \\mu_{\\mathrm{exact}}| \\text{（单位为秒）},\\quad\n|\\sigma^2_{\\mathrm{SC}} - \\sigma^2_{\\mathrm{exact}}| \\text{（单位为平方秒）},\\quad\n|p_{\\mathrm{SC}} - p_{\\mathrm{exact}}| \\text{（以小数形式表示）}.\n$$\n\n使用以下测试用例集，其中所有形状参数 $k_i$ 和尺度参数 $\\theta$ 都是无量纲的，但 $\\theta$ 的单位是秒，阈值 $t^\\star$ 的单位也是秒：\n- 测试用例 1: $n=1$, $(k_1) = (2.5)$, $\\theta = 1.2$ 秒, $t^\\star = 3.0$ 秒, $q=5$.\n- 测试用例 2: $n=2$, $(k_1,k_2) = (1.0, 4.0)$, $\\theta = 0.8$ 秒, $t^\\star = 3.0$ 秒, $q=5$.\n- 测试用例 3: $n=3$, $(k_1,k_2,k_3) = (0.7, 1.3, 2.0)$, $\\theta = 0.5$ 秒, $t^\\star = 2.0$ 秒, $q=5$.\n- 测试用例 4: $n=2$, $(k_1,k_2) = (0.5, 0.5)$, $\\theta = 1.0$ 秒, $t^\\star = 0.2$ 秒, $q=7$.\n- 测试用例 5: $n=3$, $(k_1,k_2,k_3) = (3.0, 1.0, 2.0)$, $\\theta = 0.9$ 秒, $t^\\star = 5.0$ 秒, $q=7$.\n\n最终输出格式：您的程序应生成一行输出，其中包含按测试用例排序并展平的结果，形式为逗号分隔的列表，并用方括号括起来，即\n$[\\varepsilon_{\\mu}^{(1)}, \\varepsilon_{\\sigma^2}^{(1)}, \\varepsilon_{p}^{(1)}, \\varepsilon_{\\mu}^{(2)}, \\varepsilon_{\\sigma^2}^{(2)}, \\varepsilon_{p}^{(2)}, \\ldots, \\varepsilon_{\\mu}^{(5)}, \\varepsilon_{\\sigma^2}^{(5)}, \\varepsilon_{p}^{(5)}]$,\n其中 $\\varepsilon_{\\mu}^{(i)} = |\\mu_{\\mathrm{SC}} - \\mu_{\\mathrm{exact}}|$（单位为秒），$\\varepsilon_{\\sigma^2}^{(i)} = |\\sigma^2_{\\mathrm{SC}} - \\sigma^2_{\\mathrm{exact}}|$（单位为平方秒），$\\varepsilon_{p}^{(i)} = |p_{\\mathrm{SC}} - p_{\\mathrm{exact}}|$（以小数形式表示）。", "solution": "该问题陈述提出了计算工程领域中的一个明确定义的任务，特别是在不确定性量化领域。它要求将统计矩和概率度量的精确解析解与通过随机配置 (SC) 方法得到的数值近似进行比较。该问题在科学上是合理的，数学上是一致的，并为其解决提供了所有必要的信息。因此，我将着手提供一个完整的解决方案。\n\n解决方案分为三个部分：首先，推导相关量的精确解析表达式；其次，构建随机配置近似；最后，将这些步骤综合成一个计算算法以求得所需的绝对误差。\n\n**1. 基于第一性原理的解析解**\n\n网络总延迟 $L$ 定义为 $n$ 个独立随机变量 $X_i$ 的和，其中每个 $X_i$ 服从形状参数为 $k_i > 0$、公共尺度参数为 $\\theta > 0$ 的伽马分布。我们将其表示为 $X_i \\sim \\mathrm{Gamma}(k_i, \\theta)$。\n\n$X_i$ 的概率密度函数 (PDF) 为\n$$f_{X_i}(x) = \\frac{x^{k_i-1} e^{-x/\\theta}}{\\theta^{k_i} \\Gamma(k_i)} \\quad \\text{for } x > 0,$$\n其中 $\\Gamma(k_i)$ 是伽马函数。伽马分布的基本性质是其均值和方差：\n$$\\mathbb{E}[X_i] = k_i \\theta$$\n$$\\mathrm{Var}(X_i) = k_i \\theta^2$$\n\n问题要求计算精确均值 $\\mu_{\\mathrm{exact}} = \\mathbb{E}[L]$、方差 $\\sigma^2_{\\mathrm{exact}} = \\mathrm{Var}(L)$ 和超出概率 $p_{\\mathrm{exact}} = \\mathbb{P}(L > t^\\star)$。\n\n*   **精确均值 $\\mu_{\\mathrm{exact}}$：**\n    根据期望算子的线性性，和的均值等于均值的和：\n    $$\\mu_{\\mathrm{exact}} = \\mathbb{E}[L] = \\mathbb{E}\\left[\\sum_{i=1}^{n} X_i\\right] = \\sum_{i=1}^{n} \\mathbb{E}[X_i] = \\sum_{i=1}^{n} k_i \\theta = \\theta \\sum_{i=1}^{n} k_i.$$\n\n*   **精确方差 $\\sigma^2_{\\mathrm{exact}}$：**\n    由于随机变量 $X_i$ 被规定为独立的，所以它们和的方差等于它们方差的和：\n    $$\\sigma^2_{\\mathrm{exact}} = \\mathrm{Var}(L) = \\mathrm{Var}\\left[\\sum_{i=1}^{n} X_i\\right] = \\sum_{i=1}^{n} \\mathrm{Var}(X_i) = \\sum_{i=1}^{n} k_i \\theta^2 = \\theta^2 \\sum_{i=1}^{n} k_i.$$\n\n*   **精确超出概率 $p_{\\mathrm{exact}}$：**\n    伽马分布的一个基本性质是在公共尺度参数下对求和具有可加性。独立的伽马分布随机变量 $X_i \\sim \\mathrm{Gamma}(k_i, \\theta)$ 的和也是一个伽马分布的随机变量。设 $K = \\sum_{i=1}^n k_i$。那么，总延迟 $L = \\sum_{i=1}^n X_i$ 服从形状参数为 $K$、尺度参数为 $\\theta$ 的伽马分布，即 $L \\sim \\mathrm{Gamma}(K, \\theta)$。\n\n    超出概率 $p_{\\mathrm{exact}} = \\mathbb{P}(L > t^\\star)$ 是 $L$ 的 PDF 从 $t^\\star$ 到无穷大的积分：\n    $$p_{\\mathrm{exact}} = \\int_{t^\\star}^{\\infty} \\frac{x^{K-1} e^{-x/\\theta}}{\\theta^K \\Gamma(K)} \\, \\mathrm{d}x.$$\n    通过变量代换 $y = x/\\theta$，使得 $\\mathrm{d}x = \\theta \\, \\mathrm{d}y$，该积分变为：\n    $$p_{\\mathrm{exact}} = \\int_{t^\\star/\\theta}^{\\infty} \\frac{(\\theta y)^{K-1} e^{-y}}{\\theta^K \\Gamma(K)} \\, (\\theta \\, \\mathrm{d}y) = \\frac{1}{\\Gamma(K)} \\int_{t^\\star/\\theta}^{\\infty} y^{K-1} e^{-y} \\, \\mathrm{d}y.$$\n    这个积分定义了上不完全伽马函数，$\\Gamma(s, z) = \\int_z^{\\infty} t^{s-1} e^{-t} \\, \\mathrm{d}t$。因此，该表达式等价于正则化上不完全伽马函数，$Q(s, z) = \\Gamma(s, z) / \\Gamma(s)$。\n    所以，精确的超出概率为：\n    $$p_{\\mathrm{exact}} = Q\\left(\\sum_{i=1}^{n} k_i, \\frac{t^\\star}{\\theta}\\right).$$\n\n**2. 随机配置 (SC) 近似**\n\nSC 方法通过用数值求积法则替换概率空间上的高维积分来近似函数 $\\phi(L)$ 的期望值。变换 $X_i = F^{-1}_{X_i}(U_i)$（其中 $U_i \\sim \\mathrm{Uniform}(0,1)$）将问题映射到单位超立方体 $[0,1]^n$ 上的积分。求积法则应用于此空间。\n\n指定的法则是 $q$ 点高斯-勒让德求积法则的 $n$ 维张量积。标准的高斯-勒让德节点 $\\{\\xi_\\ell\\}_{\\ell=1}^q$ 和权重 $\\{w_\\ell\\}_{\\ell=1}^q$ 定义在区间 $[-1,1]$ 上。它们通过仿射变换映射到区间 $[0,1]$ 上：\n$$p_\\ell = \\frac{\\xi_\\ell + 1}{2}, \\quad \\omega_\\ell = \\frac{w_\\ell}{2}.$$\n$\\mathbb{E}[\\phi(L)]$ 的 SC 近似则由以下 $n$ 重求和给出：\n$$\\mathcal{Q}_q[\\phi] = \\sum_{\\ell_1=1}^{q} \\cdots \\sum_{\\ell_n=1}^{q} \\left(\\prod_{i=1}^{n} \\omega_{\\ell_i}\\right)\\, \\phi\\left(L_{\\ell_1, \\dots, \\ell_n}\\right),$$\n其中 $L_{\\ell_1, \\dots, \\ell_n} = \\sum_{i=1}^{n} F^{-1}_{X_i}(p_{\\ell_i})$。此处，$F^{-1}_{X_i}$ 是 $\\mathrm{Gamma}(k_i, \\theta)$ 分布的逆累积分布函数（分位数函数）。\n\n相关量的近似计算如下：\n*   **SC 均值 $\\mu_{\\mathrm{SC}}$：**\n    这是 $\\mathbb{E}[L] = \\mathbb{E}[\\phi_1(L)]$ 的近似，其中 $\\phi_1(L) = L$。\n    $$\\mu_{\\mathrm{SC}} = \\mathcal{Q}_q[\\phi_1].$$\n*   **SC 方差 $\\sigma^2_{\\mathrm{SC}}$：**\n    方差使用关系式 $\\mathrm{Var}(L) = \\mathbb{E}[L^2] - (\\mathbb{E}[L])^2$ 进行近似。我们定义 $\\phi_2(L) = L^2$。\n    $$\\sigma^2_{\\mathrm{SC}} = \\mathcal{Q}_q[\\phi_2] - (\\mathcal{Q}_q[\\phi_1])^2.$$\n*   **SC 超出概率 $p_{\\mathrm{SC}}$：**\n    概率 $\\mathbb{P}(L > t^\\star)$ 是指示函数 $\\phi_3(L) = \\mathbf{1}_{\\{L > t^\\star\\}}$ 的期望值。\n    $$p_{\\mathrm{SC}} = \\mathcal{Q}_q[\\phi_3].$$\n\n**3. 计算算法**\n\n对于每个由参数 $n$, $\\{k_i\\}_{i=1}^n$, $\\theta$, $t^\\star$ 和 $q$ 表征的测试用例，执行以下步骤：\n\n1.  **计算精确值：**\n    *   计算形状参数之和：$K = \\sum_{i=1}^{n} k_i$。\n    *   计算 $\\mu_{\\mathrm{exact}} = K \\theta$。\n    *   计算 $\\sigma^2_{\\mathrm{exact}} = K \\theta^2$。\n    *   使用数值库函数（例如 `scipy.special.gammaincc`）计算 $p_{\\mathrm{exact}} = Q(K, t^\\star/\\theta)$，该函数用于计算正则化上不完全伽马函数。\n\n2.  **计算 SC 近似值：**\n    *   获取 $[-1,1]$ 上的 $q$ 点高斯-勒让德节点 $\\xi$ 和权重 $w$（例如，使用 `scipy.special.roots_legendre`）。\n    *   将这些节点和权重映射到 $[0,1]$ 上的点 $p$ 和权重 $\\omega$。\n    *   初始化求积和 $\\mathcal{Q}_q[\\phi_1] = 0$、$\\mathcal{Q}_q[\\phi_2] = 0$ 和 $\\mathcal{Q}_q[\\phi_3] = 0$。\n    *   遍历 $n$ 维的所有 $q^n$ 种求积点索引组合。对于每个多重索引 $(\\ell_1, \\dots, \\ell_n)$：\n        *   计算此张量积节点的总权重：$W = \\prod_{i=1}^n \\omega_{\\ell_i}$。\n        *   计算样本延迟：$L_{sample} = \\sum_{i=1}^n F^{-1}_{X_i}(p_{\\ell_i})$。$\\mathrm{Gamma}(k_i, \\theta)$ 分布的分位数 $F^{-1}_{X_i}$ 使用合适的库函数（例如 `scipy.stats.gamma.ppf`）计算。\n        *   更新求和：\n            *   $\\mathcal{Q}_q[\\phi_1] \\leftarrow \\mathcal{Q}_q[\\phi_1] + W \\cdot L_{sample}$\n            *   $\\mathcal{Q}_q[\\phi_2] \\leftarrow \\mathcal{Q}_q[\\phi_2] + W \\cdot (L_{sample})^2$\n            *   如果 $L_{sample} > t^\\star$，则 $\\mathcal{Q}_q[\\phi_3] \\leftarrow \\mathcal{Q}_q[\\phi_3] + W$。\n\n    *   遍历所有点后，计算最终的 SC 估计值：$\\mu_{\\mathrm{SC}}$、$\\sigma^2_{\\mathrm{SC}}$ 和 $p_{\\mathrm{SC}}$。\n\n3.  **计算绝对误差：**\n    *   $\\varepsilon_\\mu = |\\mu_{\\mathrm{SC}} - \\mu_{\\mathrm{exact}}|$\n    *   $\\varepsilon_{\\sigma^2} = |\\sigma^2_{\\mathrm{SC}} - \\sigma^2_{\\mathrm{exact}}|$\n    *   $\\varepsilon_p = |p_{\\mathrm{SC}} - p_{\\mathrm{exact}}|$\n\n对所有指定的测试用例重复此过程，并收集产生的误差用于最终输出。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import gamma\nfrom scipy.special import roots_legendre, gammaincc\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating exact and Stochastic Collocation (SC)\n    approximations for network latency statistics and then computes the absolute errors.\n    \"\"\"\n    \n    test_cases = [\n        # n, k_vec, theta, t_star, q\n        (1, [2.5], 1.2, 3.0, 5),\n        (2, [1.0, 4.0], 0.8, 3.0, 5),\n        (3, [0.7, 1.3, 2.0], 0.5, 2.0, 5),\n        (2, [0.5, 0.5], 1.0, 0.2, 7),\n        (3, [3.0, 1.0, 2.0], 0.9, 5.0, 7),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        n, k_vec, theta, t_star, q = case\n\n        # 1. Compute Exact Analytical Values\n        K_sum = np.sum(k_vec)\n        \n        # Exact mean\n        mu_exact = K_sum * theta\n        \n        # Exact variance\n        sigma2_exact = K_sum * theta**2\n        \n        # Exact exceedance probability\n        # p_exact = P(L > t_star) = 1 - CDF(t_star) = Q(K_sum, t_star/theta)\n        # scipy.special.gammaincc is the regularized upper incomplete gamma function Q(a,x)\n        p_exact = gammaincc(K_sum, t_star / theta)\n\n        # 2. Compute Stochastic Collocation (SC) Approximations\n\n        # Get q-point Gauss-Legendre nodes and weights on [-1, 1]\n        nodes_xi, weights_w = roots_legendre(q)\n        \n        # Map nodes and weights to [0, 1]\n        nodes_p = (nodes_xi + 1.0) / 2.0\n        weights_omega = weights_w / 2.0\n\n        # Initialize quadrature sums for E[L], E[L^2], E[1_{L>t*}]\n        Q1 = 0.0  # Approximation for E[L]\n        Q2 = 0.0  # Approximation for E[L^2]\n        Q3 = 0.0  # Approximation for P(L > t_star)\n\n        # Create an iterator for the n-dimensional tensor product of indices\n        # Each index runs from 0 to q-1\n        multi_indices = itertools.product(range(q), repeat=n)\n\n        # Perform the n-dimensional quadrature summation\n        for index_tuple in multi_indices:\n            \n            # Calculate total weight for this tensor product point\n            total_weight = np.prod([weights_omega[idx] for idx in index_tuple])\n\n            # Calculate the sample latency for this point\n            sample_latency = 0.0\n            for i in range(n):\n                k_i = k_vec[i]\n                p_li = nodes_p[index_tuple[i]]\n                # Use inverse CDF (percent-point function) of the Gamma distribution\n                # scipy.stats.gamma uses shape 'a' and 'scale' which map to our k_i and theta\n                x_i = gamma.ppf(p_li, a=k_i, scale=theta)\n                sample_latency += x_i\n            \n            # Update the quadrature sums\n            Q1 += total_weight * sample_latency\n            Q2 += total_weight * sample_latency**2\n            if sample_latency > t_star:\n                Q3 += total_weight\n\n        # Finalize SC approximations\n        mu_sc = Q1\n        sigma2_sc = Q2 - Q1**2\n        p_sc = Q3\n        \n        # 3. Compute Absolute Errors\n        err_mu = np.abs(mu_sc - mu_exact)\n        err_sigma2 = np.abs(sigma2_sc - sigma2_exact)\n        err_p = np.abs(p_sc - p_exact)\n        \n        results.extend([err_mu, err_sigma2, err_p])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2439651"}, {"introduction": "在上一练习的基础上，我们已经了解了非侵入式的随机配置方法。现在，让我们来探索其“侵入式”的对应方法——随机伽辽金 (Stochastic Galerkin, SG) 方法。本练习将这两种方法同时应用于一个经典的物理问题——具有不确定热扩散系数的一维热方程。通过并排比较 SC 和 SG 方法，您将更深入地理解它们在基本原理、实现复杂性和各自优势上的差异。[@problem_id:2439592]", "problem": "考虑具有齐次狄利克雷边界条件和随机热扩散率的一维热方程，\n$$\nu_t(x,t,\\alpha) = \\alpha \\, u_{xx}(x,t,\\alpha), \\quad x \\in [0,1], \\ t \\ge 0,\n$$\n$$\nu(0,t,\\alpha)=0, \\quad u(1,t,\\alpha)=0, \\quad u(x,0,\\alpha)=\\sin(\\pi x),\n$$\n其中热扩散率 $\\alpha$ 是一个在 $[a,b]$ 上均匀分布的标量随机变量，且 $0<a<b<\\infty$。通过仿射映射引入标准化随机变量 $\\xi \\sim \\mathcal{U}([-1,1])$\n$$\n\\alpha(\\xi) = \\frac{a+b}{2} + \\frac{b-a}{2}\\,\\xi.\n$$\n您将比较两种不确定性量化方法：使用勒让德多项式混沌展开的随机伽辽金方法 (SG)，以及使用高斯-勒让德求积的随机配置法 (SC)。\n\n您可以使用的基本原理包括线性偏微分方程的分离变量法，勒让德多项式在 $[-1,1]$ 上关于均匀测度的正交性和完备性，以及期望和方差的标准性质。\n\n任务要求：\n- 从第一性原理出发，推导通过将热方程投影到关于 $\\xi$ 的概率测度的正交归一勒让德多项式混沌基 $\\{\\psi_k(\\xi)\\}_{k=0}^p$ 上所获得的耦合确定性系统。假设\n$$\n\\psi_k(\\xi) = \\sqrt{2k+1}\\,P_k(\\xi),\n$$\n其中 $P_k$ 是 $[-1,1]$ 上的 $k$ 次勒让德多项式，使得相对于 $[-1,1]$ 上的均匀概率测度，有 $\\mathbb{E}[\\psi_i(\\xi)\\psi_j(\\xi)] = \\delta_{ij}$。使用拟设\n$$\nu(x,t,\\xi) \\approx \\sum_{k=0}^{p} u_k(x,t) \\, \\psi_k(\\xi),\n$$\n并展示模态系数如何通过形如 $\\mathbb{E}[\\alpha(\\xi)\\psi_i(\\xi)\\psi_j(\\xi)]$ 的期望耦合在一起。\n- 针对给定的初始条件 $u(x,0,\\xi)=\\sin(\\pi x)$ 和齐次狄利克雷边界，具体化该推导过程，使用分离变量法确定空间依赖关系。将随机伽辽金系统简化为关于随机幅值的时间线性常微分方程组，并用多项式混沌系数表示在固定点 $x^\\star \\in (0,1)$ 处 $u(x,t,\\xi)$ 的均值和方差。\n- 对于随机配置法，使用 $[-1,1]$ 上的 $Q$ 个点 $\\{(\\xi_q,w_q)\\}_{q=1}^Q$ 的高斯-勒让德求积来近似关于 $[-1,1]$ 上均匀分布的期望。明确说明如何根据在配置点上求值的确定性解来计算在 $x^\\star$ 和时间 $t$ 处的近似均值和方差。\n\n数值任务和输出规范：\n- 实现一个完整的程序，该程序：\n  1) 使用 $[-1,1]$ 上的数值积分构建随机伽辽金耦合矩阵，\n  2) 从推导出的初始条件开始，随时间演化随机伽辽金系统的幅值，\n  3) 使用高斯-勒让德求积计算随机配置法的均值和方差估计，\n  4) 对于每个测试用例，返回在指定点 $x^\\star$ 和时间 $t$ 处均值的绝对误差和方差的绝对误差，用以比较 SG 和 SC。\n- 使用以下参数集测试套件 $(a,b,p,Q,t,x^\\star)$:\n  - 测试 1: $(a,b,p,Q,t,x^\\star)= (0.1, 0.5, 3, 8, 0.3, 0.5)$.\n  - 测试 2: $(a,b,p,Q,t,x^\\star)= (0.1, 0.5, 5, 6, 0.0, 0.5)$.\n  - 测试 3: $(a,b,p,Q,t,x^\\star)= (0.01, 1.0, 5, 16, 0.2, 0.3)$.\n  - 测试 4: $(a,b,p,Q,t,x^\\star)= (0.1, 0.9, 7, 20, 2.0, 0.5)$.\n- 对于关于 $\\xi \\sim \\mathcal{U}([-1,1])$ 的期望，请记住 $\\mathbb{E}[f(\\xi)] = \\frac{1}{2}\\int_{-1}^{1} f(\\xi)\\, d\\xi$，并根据需要使用高斯-勒让德求积来近似该积分。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个包含两个浮点数的列表：在 $(x^\\star,t)$ 处的均值绝对误差和方差绝对误差。确切格式必须为 `[[e_1_mean,e_1_var],[e_2_mean,e_2_var],[e_3_mean,e_3_var],[e_4_mean,e_4_var]]`，且不含任何空格。", "solution": "所提出的问题是计算工程领域中一个有效且适定的问题，特别是在不确定性量化领域。它在科学上基于热传递的物理学以及随机分析和数值方法的数学。所有必要的数据和条件都已提供。因此，我将继续提供完整的解决方案。\n\n分析始于具有随机热扩散率 $\\alpha$ 的一维热方程：\n$$\nu_t(x,t,\\alpha) = \\alpha \\, u_{xx}(x,t,\\alpha), \\quad x \\in [0,1], \\ t \\ge 0\n$$\n该方程受齐次狄利克雷边界条件 $u(0,t,\\alpha)=0, u(1,t,\\alpha)=0$ 和初始条件 $u(x,0,\\alpha)=\\sin(\\pi x)$ 的约束。扩散率 $\\alpha$ 在 $[a,b]$ 上均匀分布，它是通过仿射变换从标准均匀随机变量 $\\xi \\sim \\mathcal{U}([-1,1])$ 映射而来的：\n$$\n\\alpha(\\xi) = \\bar{\\alpha} + \\hat{\\alpha}\\xi = \\frac{a+b}{2} + \\frac{b-a}{2}\\xi\n$$\n这里，$\\bar{\\alpha} = \\mathbb{E}[\\alpha]$ 是均值，$\\hat{\\alpha} = (b-a)/2$ 是一个缩放因子。\n\n**随机伽辽金方法推导**\n\n随机伽辽金 (SG) 方法寻求多项式混沌展开 (PCE) 形式的近似解：\n$$\nu(x,t,\\xi) \\approx u_p(x,t,\\xi) = \\sum_{k=0}^{p} u_k(x,t) \\psi_k(\\xi)\n$$\n其中 $\\{\\psi_k(\\xi)\\}$ 是 $[-1,1]$ 上关于均匀概率测度的标准正交勒让德多项式，满足 $\\mathbb{E}[\\psi_i(\\xi)\\psi_j(\\xi)] = \\frac{1}{2}\\int_{-1}^{1} \\psi_i(\\xi)\\psi_j(\\xi) d\\xi = \\delta_{ij}$。\n\n我们将此拟设代入控制偏微分方程：\n$$\n\\frac{\\partial}{\\partial t} \\sum_{k=0}^{p} u_k(x,t) \\psi_k(\\xi) = \\alpha(\\xi) \\frac{\\partial^2}{\\partial x^2} \\sum_{k=0}^{p} u_k(x,t) \\psi_k(\\xi)\n$$\n根据算子的线性性质，这变为：\n$$\n\\sum_{k=0}^{p} \\frac{\\partial u_k(x,t)}{\\partial t} \\psi_k(\\xi) = \\alpha(\\xi) \\sum_{k=0}^{p} \\frac{\\partial^2 u_k(x,t)}{\\partial x^2} \\psi_k(\\xi)\n$$\n通过将此方程与每个基函数 $\\psi_j(\\xi)$ ($j=0, \\dots, p$) 作内积来进行伽辽金投影。内积由期望算子 $\\mathbb{E}[\\cdot]$ 定义。\n$$\n\\mathbb{E}\\left[ \\psi_j(\\xi) \\sum_{k=0}^{p} \\frac{\\partial u_k}{\\partial t} \\psi_k(\\xi) \\right] = \\mathbb{E}\\left[ \\psi_j(\\xi) \\alpha(\\xi) \\sum_{k=0}^{p} \\frac{\\partial^2 u_k}{\\partial x^2} \\psi_k(\\xi) \\right]\n$$\n利用期望的线性和基函数的正交性，左侧简化为：\n$$\n\\sum_{k=0}^{p} \\frac{\\partial u_k}{\\partial t} \\mathbb{E}[\\psi_j \\psi_k] = \\sum_{k=0}^{p} \\frac{\\partial u_k}{\\partial t} \\delta_{jk} = \\frac{\\partial u_j}{\\partial t}\n$$\n右侧变为：\n$$\n\\sum_{k=0}^{p} \\frac{\\partial^2 u_k}{\\partial x^2} \\mathbb{E}[\\alpha(\\xi) \\psi_j(\\xi) \\psi_k(\\xi)]\n$$\n这得到了一个关于模态系数 $u_j(x,t)$ 的包含 $p+1$ 个方程的耦合确定性偏微分方程组：\n$$\n\\frac{\\partial u_j}{\\partial t}(x,t) = \\sum_{k=0}^{p} C_{jk} \\frac{\\partial^2 u_k}{\\partial x^2}(x,t), \\quad j = 0, \\dots, p\n$$\n其中耦合矩阵的元素由 $C_{jk} = \\mathbb{E}[\\alpha(\\xi) \\psi_j(\\xi) \\psi_k(\\xi)]$ 给出。代入 $\\alpha(\\xi)$ 的表达式：\n$$\nC_{jk} = \\mathbb{E}[(\\bar{\\alpha} + \\hat{\\alpha}\\xi) \\psi_j \\psi_k] = \\bar{\\alpha} \\mathbb{E}[\\psi_j \\psi_k] + \\hat{\\alpha} \\mathbb{E}[\\xi \\psi_j \\psi_k] = \\bar{\\alpha} \\delta_{jk} + \\hat{\\alpha} \\mathbb{E}[\\xi \\psi_j \\psi_k]\n$$\n由于勒让德多项式的三项递推关系，元素为 $\\mathbb{E}[\\xi \\psi_j \\psi_k]$ 的矩阵是三对角的。这使得耦合矩阵 $\\mathbf{C}$ 成为一个对称三对角矩阵。\n\n**针对特定问题的简化**\n\n初始条件和边界条件的形式允许使用分离变量法。解在所有时间内都保持 $\\sin(\\pi x)$ 的空间形式。因此，我们可以假设解的形式为 $u(x,t,\\xi) = \\hat{u}(t,\\xi) \\sin(\\pi x)$。将其代入原始偏微分方程，得到关于幅值 $\\hat{u}(t,\\xi)$ 的随机常微分方程：\n$$\n\\frac{d\\hat{u}}{dt} = -\\pi^2 \\alpha(\\xi) \\hat{u}\n$$\n初始条件 $u(x,0,\\xi)=\\sin(\\pi x)$ 意味着 $\\hat{u}(0,\\xi)=1$。精确解为 $\\hat{u}(t,\\xi) = \\exp(-\\pi^2 \\alpha(\\xi) t)$。完整的随机解为 $u(x,t,\\xi) = \\exp(-\\pi^2 \\alpha(\\xi) t) \\sin(\\pi x)$。\n\n这种分离使得可以将 PCE 系数写为 $u_k(x,t) = \\hat{u}_k(t) \\sin(\\pi x)$。将其代入耦合偏微分方程组并注意到 $\\frac{\\partial^2}{\\partial x^2}(\\hat{u}_k \\sin(\\pi x)) = -\\pi^2 \\hat{u}_k \\sin(\\pi x)$，我们得到了关于时间系数 $\\hat{u}_k(t)$ 的一个线性常微分方程组：\n$$\n\\frac{d \\hat{u}_j(t)}{dt} = -\\pi^2 \\sum_{k=0}^{p} C_{jk} \\hat{u}_k(t)\n$$\n以向量形式表示，即为 $\\frac{d\\hat{\\mathbf{u}}}{dt} = -\\pi^2 \\mathbf{C} \\hat{\\mathbf{u}}(t)$，其中 $\\hat{\\mathbf{u}}(t) = [\\hat{u}_0(t), \\dots, \\hat{u}_p(t)]^T$。\n\n该系统的初始条件通过将 $\\hat{u}(0,\\xi)=1$ 投影到基上得到：\n$$\n\\hat{u}_k(0) = \\mathbb{E}[1 \\cdot \\psi_k(\\xi)] = \\mathbb{E}[\\psi_0(\\xi) \\psi_k(\\xi)] = \\delta_{0k}\n$$\n因此，初始向量为 $\\hat{\\mathbf{u}}(0) = [1, 0, \\dots, 0]^T$。该常微分方程组的解由矩阵指数给出：\n$$\n\\hat{\\mathbf{u}}(t) = e^{-\\pi^2 \\mathbf{C} t} \\hat{\\mathbf{u}}(0)\n$$\n\n**从随机伽辽金方法计算均值和方差**\n\n解的均值为：\n$$\n\\mathbb{E}[u_p(x,t,\\xi)] = \\mathbb{E}\\left[\\sin(\\pi x) \\sum_{k=0}^{p} \\hat{u}_k(t) \\psi_k(\\xi)\\right] = \\sin(\\pi x) \\sum_{k=0}^{p} \\hat{u}_k(t) \\mathbb{E}[\\psi_k(\\xi)]\n$$\n由于 $\\mathbb{E}[\\psi_k(\\xi)]=\\delta_{0k}$，均值完全由零阶系数决定：\n$$\n\\mu_{SG}(x,t) = \\mathbb{E}[u_p(x,t,\\xi)] = \\hat{u}_0(t) \\sin(\\pi x)\n$$\n方差为 $\\mathrm{Var}(u_p) = \\mathbb{E}[u_p^2] - (\\mathbb{E}[u_p])^2$。平方的期望值为：\n$$\n\\mathbb{E}[u_p^2] = \\sin^2(\\pi x) \\mathbb{E}\\left[\\left(\\sum_{k=0}^{p} \\hat{u}_k(t) \\psi_k(\\xi)\\right)^2\\right] = \\sin^2(\\pi x) \\sum_{i=0}^{p}\\sum_{j=0}^{p} \\hat{u}_i(t)\\hat{u}_j(t) \\mathbb{E}[\\psi_i\\psi_j] = \\sin^2(\\pi x) \\sum_{k=0}^{p} \\hat{u}_k(t)^2\n$$\n因此，方差由高阶系数的平方和给出：\n$$\n\\sigma^2_{SG}(x,t) = \\left( \\sin^2(\\pi x) \\sum_{k=0}^{p} \\hat{u}_k(t)^2 \\right) - \\left( \\hat{u}_0(t) \\sin(\\pi x) \\right)^2 = \\sin^2(\\pi x) \\sum_{k=1}^{p} \\hat{u}_k(t)^2\n$$\n\n**随机配置法**\n\n随机配置法 (SC) 通过数值积分来近似期望。对于给定函数 $f(\\xi)$，其期望使用 $Q$ 点高斯-勒让德求积法则来近似：\n$$\n\\mathbb{E}[f(\\xi)] = \\frac{1}{2}\\int_{-1}^1 f(\\xi) d\\xi \\approx \\sum_{q=1}^{Q} \\frac{w'_q}{2} f(\\xi_q) = \\sum_{q=1}^{Q} w_q f(\\xi_q)\n$$\n其中 $(\\xi_q, w'_q)$ 是 $[-1,1]$ 上的标准高斯-勒让德节点和权重，而 $w_q = w'_q/2$ 是相应的概率权重。\n\n步骤如下：\n1.  对于每个求积节点 $\\xi_q$，确定物理参数 $\\alpha_q = \\alpha(\\xi_q)$。\n2.  对每个 $\\alpha_q$ 求解确定性问题。在本例中，我们在点 $(x^\\star, t)$ 处计算精确解：\n    $$\n    U_q = u(x^\\star, t; \\alpha_q) = e^{-\\pi^2 \\alpha_q t} \\sin(\\pi x^\\star)\n    $$\n3.  均值被近似为这些解的加权和：\n    $$\n    \\mu_{SC}(x^\\star, t) \\approx \\sum_{q=1}^{Q} w_q U_q\n    $$\n4.  方差被近似为：\n    $$\n    \\sigma^2_{SC}(x^\\star, t) \\approx \\mathbb{E}[u^2] - (\\mathbb{E}[u])^2 \\approx \\left(\\sum_{q=1}^{Q} w_q U_q^2\\right) - \\mu_{SC}^2\n    $$\n对于足够多的配置点 $Q$，此方法提供了对真实统计量的高度精确估计，可作为可靠的基准，用于与 SG 近似进行比较。\n\n**数值实现**\n\n数值任务涉及实现这两种方法。\n对于 SG，矩阵 $\\mathbf{C}$ 使用高阶数值积分构建。通过对角化 $\\mathbf{C} = \\mathbf{V}\\mathbf{\\Lambda}\\mathbf{V}^T$ 并计算 $\\hat{\\mathbf{u}}(t) = \\mathbf{V} e^{-\\pi^2 \\mathbf{\\Lambda} t} \\mathbf{V}^T \\hat{\\mathbf{u}}(0)$ 来求解常微分方程组。\n对于 SC，在 $Q$ 个配置点中的每一个点上评估确定性解，并使用求积法则组合结果。\n然后为每个测试用例计算绝对误差 $| \\mu_{SG} - \\mu_{SC} |$ 和 $| \\sigma^2_{SG} - \\sigma^2_{SC} |$。", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre, eval_legendre\nfrom scipy.linalg import eigh, expm\n\ndef solve():\n    \"\"\"\n    Solves the given problem by comparing Stochastic Galerkin (SG) and\n    Stochastic Collocation (SC) methods for a 1D heat equation with a\n    random parameter.\n    \"\"\"\n    test_cases = [\n        # (a, b, p, Q, t, x_star)\n        (0.1, 0.5, 3, 8, 0.3, 0.5),\n        (0.1, 0.5, 5, 6, 0.0, 0.5),\n        (0.01, 1.0, 5, 16, 0.2, 0.3),\n        (0.1, 0.9, 7, 20, 2.0, 0.5),\n    ]\n\n    results = []\n\n    for a, b, p, Q, t, x_star in test_cases:\n        # --- Stochastic Galerkin (SG) Method ---\n        \n        # 1. Construct the coupling matrix C using numerical quadrature.\n        # The integrand is a polynomial of degree up to 1+2p.\n        # Gauss-Legendre quadrature with N_quad points is exact for polynomials\n        # of degree up to 2*N_quad - 1. We need 2*N_quad - 1 >= 1+2p => N_quad >= p+1.\n        # We choose a safe number of points.\n        N_quad_C = 2 * p + 2\n        nodes_C, weights_C = roots_legendre(N_quad_C)\n        \n        # Orthonormal Legendre polynomials: psi_k(xi) = sqrt(2k+1) * P_k(xi)\n        psi_vals = np.zeros((p + 1, N_quad_C))\n        for k in range(p + 1):\n            psi_vals[k, :] = np.sqrt(2 * k + 1) * eval_legendre(k, nodes_C)\n            \n        alpha_vals = (a + b) / 2.0 + (b - a) / 2.0 * nodes_C\n        \n        C = np.zeros((p + 1, p + 1))\n        # C_jk = E[alpha * psi_j * psi_k] = 0.5 * integral(alpha * psi_j * psi_k, dxi)\n        for j in range(p + 1):\n            for k in range(j, p + 1): # Matrix is symmetric\n                integrand = alpha_vals * psi_vals[j, :] * psi_vals[k, :]\n                integral_val = np.sum(weights_C * integrand)\n                C[j, k] = 0.5 * integral_val\n                if j != k:\n                    C[k, j] = C[j, k]\n\n        # 2. Evolve the system of ODEs for the coefficients\n        u_hat_0 = np.zeros(p + 1)\n        u_hat_0[0] = 1.0\n\n        # Solution: u_hat(t) = expm(-pi^2 * C * t) @ u_hat_0\n        # For symmetric C, diagonalization is numerically stable and efficient.\n        evals, V = eigh(C)\n        exp_lambda_t = np.exp(-np.pi**2 * evals * t)\n        u_hat_t = V @ (exp_lambda_t * (V.T @ u_hat_0))\n\n        # 3. Compute SG mean and variance\n        sin_x_star = np.sin(np.pi * x_star)\n        mean_sg = u_hat_t[0] * sin_x_star\n        var_sg = np.sum(u_hat_t[1:]**2) * sin_x_star**2\n\n        # --- Stochastic Collocation (SC) Method ---\n        \n        # 1. Get Gauss-Legendre nodes and weights for SC\n        nodes_sc, weights_sc = roots_legendre(Q)\n        prob_weights_sc = weights_sc / 2.0\n        \n        # 2. Evaluate deterministic solution at each node\n        alpha_sc = (a + b) / 2.0 + (b - a) / 2.0 * nodes_sc\n        sol_vals_sc = np.exp(-np.pi**2 * alpha_sc * t) * sin_x_star\n        \n        # 3. Compute SC mean and variance\n        mean_sc = np.sum(prob_weights_sc * sol_vals_sc)\n        \n        # Var = E[u^2] - (E[u])^2\n        var_sc = np.sum(prob_weights_sc * sol_vals_sc**2) - mean_sc**2\n\n        # --- Comparison ---\n        error_mean = np.abs(mean_sg - mean_sc)\n        error_var = np.abs(var_sg - var_sc)\n\n        results.append(f\"[{error_mean},{error_var}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2439592"}, {"introduction": "在真实世界的工程问题中，我们很少能奢望有一个精确的解析解来检验结果。那么，我们如何信任随机模拟的答案呢？本练习将介绍一个至关重要的概念：后验误差估计 (a-posteriori error estimation)。通过比较两个连续多项式阶数（$p$ 和 $p+1$）的解，我们可以估算近似误差，这为评估随机配置结果的收敛性和可靠性提供了一种实用的方法。[@problem_id:2439622]", "problem": "考虑以下为标量随机输入定义的参数化模型问题。设随机变量表示为 $\\xi \\sim \\mathcal{U}([-1,1])$（$[-1,1]$上的均匀分布）。定义参数化系数为 $a(\\xi) = a_0 + a_1 \\xi$，其中 $a_0 \\in \\mathbb{R}$ 且 $a_1 \\in \\mathbb{R}$，并假设 $a_0 > |a_1|$，因此对于所有 $\\xi \\in [-1,1]$ 都有 $a(\\xi) &gt; 0$。考虑线性常微分方程\n$$\n\\frac{dy}{dt}(t;\\xi) + a(\\xi)\\,y(t;\\xi) = 1,\\quad t \\in (0,T], \\quad y(0;\\xi) = y_0,\n$$\n其中 $T \\in \\mathbb{R}_{&gt;0}$ 且 $y_0 \\in \\mathbb{R}$。在时间 $T$ 的唯一解为\n$$\nQ(\\xi) = y(T;\\xi) = y_0 e^{-a(\\xi)\\,T} + \\frac{1 - e^{-a(\\xi)\\,T}}{a(\\xi)}.\n$$\n对于给定的非负整数多项式次数 $p \\in \\mathbb{Z}_{\\ge 0}$，定义：\n- 随机配置近似 $u_p(\\xi)$ 是 $\\xi$ 的唯一多项式，其次数至多为 $p$，$u_p(\\xi)$ 在由 $(-1,1)$ 上次数为 $p+1$ 的 Legendre 多项式的零点给出的 $p+1$ 个不同配置点处对 $Q(\\xi)$ 进行插值。\n- 更高次数的近似 $u_{p+1}(\\xi)$ 类似地定义为 $\\xi$ 的唯一多项式，其次数至多为 $p+1$，它在次数为 $p+2$ 的 Legendre 多项式的 $p+2$ 个零点处对 $Q(\\xi)$ 进行插值。\n\n将后验误差指标定义为这两个近似值之差的均方根（关于 $\\xi$ 的分布）：\n$$\n\\eta_p \\equiv \\left( \\mathbb{E}\\left[ \\left(u_p(\\xi)-u_{p+1}(\\xi)\\right)^2 \\right] \\right)^{1/2}\n= \\left( \\frac{1}{2} \\int_{-1}^1 \\left(u_p(\\xi)-u_{p+1}(\\xi)\\right)^2 \\, d\\xi \\right)^{1/2}.\n$$\n\n您的任务是编写一个完整的程序，对于下面测试套件中的每个参数集，计算如上定义的标量误差指标 $\\eta_p$，并将其作为浮点数报告。\n\n测试套件（每个案例为 $(a_0,a_1,y_0,T,p)$）：\n- 案例 1：$(1.0, 0.3, 0.5, 1.0, 2)$。\n- 案例 2：$(1.0, 0.8, 1.0, 2.0, 0)$。\n- 案例 3：$(1.4, 0.0, 0.7, 0.3, 3)$。\n- 案例 4：$(2.0, 0.99, 1.0, 3.0, 4)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含上述案例的结果，以逗号分隔的列表形式包含在方括号内，顺序与测试套件相同，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是相应案例计算出的 $\\eta_p$ 的浮点值。\n- 不应打印任何额外的文本或行。", "solution": "所提出的问题是计算工程领域中的一个定义明确的标准练习，特别是在使用随机谱方法进行不确定性量化方面。该问题有科学依据，内容自洽，且可通过算法求解。所有提供的常数和函数都有明确定义，约束条件确保了问题的适定性。因此，该问题是有效的，并将提供一个解决方案。\n\n目标是计算参数化常微分方程 (ODE) 解的随机配置近似的后验误差指标 $\\eta_p$。\n\n控制 ODE 为：\n$$\n\\frac{dy}{dt}(t;\\xi) + a(\\xi)\\,y(t;\\xi) = 1, \\quad y(0;\\xi) = y_0\n$$\n其中 $\\xi$ 是一个服从 $[-1,1]$ 上均匀分布的随机变量，记为 $\\xi \\sim \\mathcal{U}([-1,1])$。系数 $a(\\xi)$ 是 $\\xi$ 的一个仿射函数：\n$$\na(\\xi) = a_0 + a_1 \\xi\n$$\n问题陈述中指出 $a_0 > |a_1|$，这保证了对于所有 $\\xi \\in [-1,1]$ 都有 $a(\\xi) > 0$。这个条件至关重要，因为它确保了解是良态的并且没有奇点。关注量 $Q(\\xi) = y(T;\\xi)$ 的解析解由下式给出：\n$$\nQ(\\xi) = y_0 e^{-a(\\xi)\\,T} + \\frac{1 - e^{-a(\\xi)\\,T}}{a(\\xi)}\n$$\n\n问题的核心涉及对 $Q(\\xi)$ 的两个多项式近似：\n1.  $u_p(\\xi)$：一个次数至多为 $p$ 的多项式，通过在一组特定的 $p+1$ 个点上对精确解 $Q(\\xi)$ 进行插值来构造。这些点被称为配置点，是次数为 $p+1$ 的 Legendre 多项式 $P_{p+1}(\\xi)$ 的根。\n2.  $u_{p+1}(\\xi)$：类似地，一个次数至多为 $p+1$ 的多项式，它在次数为 $p+2$ 的 Legendre 多项式 $P_{p+2}(\\xi)$ 的 $p+2$ 个根处对 $Q(\\xi)$ 进行插值。\n\n误差指标 $\\eta_p$ 被定义为这两个连续近似值之差的均方根范数。对于函数 $f(\\xi)$ 且 $\\xi \\sim \\mathcal{U}([-1,1])$，其期望 $\\mathbb{E}[\\cdot]$ 由 $\\frac{1}{2}\\int_{-1}^{1} f(\\xi) \\,d\\xi$ 给出。因此，$\\eta_p$ 计算如下：\n$$\n\\eta_p = \\left( \\mathbb{E}\\left[ \\left(u_p(\\xi)-u_{p+1}(\\xi)\\right)^2 \\right] \\right)^{1/2} = \\left( \\frac{1}{2} \\int_{-1}^1 \\left(u_p(\\xi)-u_{p+1}(\\xi)\\right)^2 \\, d\\xi \\right)^{1/2}\n$$\n\n计算每个测试案例的 $\\eta_p$ 的计算策略如下：\n1.  **参数实例化**：对于给定的参数集 $(a_0, a_1, y_0, T, p)$，定义具体的函数 $a(\\xi)$ 和 $Q(\\xi)$。\n2.  **构造 $u_p(\\xi)$**：\n    a. 通过求 Legendre 多项式 $P_{p+1}(\\xi)$ 的根来确定 $p+1$ 个配置点。这可以通过使用标准数值例程来完成，例如 `numpy.polynomial.legendre.leggauss(p+1)`。\n    b. 在这 $p+1$ 个点上计算精确解 $Q(\\xi)$，以获得点对 $(\\xi_i, Q(\\xi_i))$。\n    c. 构造通过这些点的次数为 $p$ 的唯一插值多项式 $u_p(\\xi)$。一个稳健的方法是使用拉格朗日插值，`scipy.interpolate.lagrange` 为此提供了一个方便的实现，返回一个多项式对象。\n3.  **构造 $u_{p+1}(\\xi)$**：对下一个更高的次数重复步骤2中描述的过程。找到 $P_{p+2}(\\xi)$ 的 $p+2$ 个根，在这些新点上计算 $Q(\\xi)$，并构造插值多项式 $u_{p+1}(\\xi)$。\n4.  **误差计算**：\n    a. 定义差分多项式 $d(\\xi) = u_p(\\xi) - u_{p+1}(\\xi)$。由于 $u_p$ 和 $u_{p+1}$ 表示为多项式对象，它们的差也是一个多项式对象。\n    b. 被积函数是 $(d(\\xi))^2$，它也是一个多项式。多项式的积分可以精确计算。我们构建多项式 $(d(\\xi))^2$ 并求其不定积分。然后通过计算不定积分在积分上下限的值来计算在 $[-1, 1]$ 上的定积分。\n    c. 最后，通过取该积分值的一半的平方根来计算 $\\eta_p$。\n\n当 $a_1 = 0$ 时（如案例3），会出现一个特殊情况。此时，$a(\\xi) = a_0$ 是一个常数。因此，解 $Q(\\xi)$ 也是一个与 $\\xi$ 无关的常数。对常数函数的任何多项式插值都会得到该常数本身。因此，$u_p(\\xi) = u_{p+1}(\\xi) = Q$，它们的差为零，$\\eta_p$ 精确为 $0$。这个案例可以作为对实现正确性的合理性检查。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import lagrange\nfrom numpy.polynomial.legendre import leggauss\n\ndef solve():\n    \"\"\"\n    Computes the a-posteriori error indicator for a stochastic collocation method\n    applied to a parametric ODE.\n    \"\"\"\n    # Test suite: (a_0, a_1, y_0, T, p)\n    test_cases = [\n        (1.0, 0.3, 0.5, 1.0, 2),\n        (1.0, 0.8, 1.0, 2.0, 0),\n        (1.4, 0.0, 0.7, 0.3, 3),\n        (2.0, 0.99, 1.0, 3.0, 4),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        a0, a1, y0, T, p = case\n\n        # A special case where the coefficient a(xi) is deterministic.\n        # In this situation, the solution Q is a constant, so any polynomial\n        # interpolant will also be that constant. The difference u_p - u_{p+1}\n        # is identically zero, hence the error indicator eta_p is zero.\n        if a1 == 0.0:\n            results.append(0.0)\n            continue\n\n        # Define the parameterized coefficient a(xi)\n        def a(xi):\n            return a0 + a1 * xi\n\n        # Define the exact solution Q(xi). The condition a0 > |a1| ensures\n        # the denominator a(xi) is never zero for xi in [-1, 1].\n        def Q(xi):\n            a_val = a(xi)\n            exp_term = np.exp(-a_val * T)\n            # The term (1 - exp(-x))/x is evaluated robustly. While a_val > 0 is\n            # guaranteed, this form would be stable even if a_val were close to 0.\n            term2 = (1.0 - exp_term) / a_val\n            return y0 * exp_term + term2\n\n        # --- Construct u_p(xi), the polynomial of degree p ---\n        p_degree = p\n        # Collocation points are the p+1 zeros of the Legendre polynomial of degree p+1.\n        num_points_p = p_degree + 1\n        nodes_p, _ = leggauss(num_points_p)\n        # Evaluate the exact solution Q at these nodes.\n        q_values_p = Q(nodes_p)\n        # Create the interpolating polynomial using Lagrange interpolation.\n        # The result is a numpy.poly1d object.\n        u_p = lagrange(nodes_p, q_values_p)\n\n        # --- Construct u_{p+1}(xi), the polynomial of degree p+1 ---\n        p1_degree = p + 1\n        # Collocation points are the p+2 zeros of the Legendre polynomial of degree p+2.\n        num_points_p1 = p1_degree + 1\n        nodes_p1, _ = leggauss(num_points_p1)\n        # Evaluate the exact solution Q at these new nodes.\n        q_values_p1 = Q(nodes_p1)\n        # Create the interpolating polynomial.\n        u_p1 = lagrange(nodes_p1, q_values_p1)\n\n        # --- Compute the error indicator eta_p ---\n        # The difference d(xi) = u_p(xi) - u_{p+1}(xi) is a polynomial.\n        d = u_p - u_p1\n        \n        # The squared difference is also a polynomial.\n        d_squared = d * d\n        \n        # We integrate d_squared from -1 to 1 exactly.\n        # poly.integ() returns the antiderivative polynomial.\n        integral_poly = d_squared.integ()\n        integral_value = integral_poly(1.0) - integral_poly(-1.0)\n        \n        # Compute eta_p according to its definition.\n        eta_p = np.sqrt(integral_value / 2.0)\n        \n        results.append(eta_p)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```", "id": "2439622"}]}