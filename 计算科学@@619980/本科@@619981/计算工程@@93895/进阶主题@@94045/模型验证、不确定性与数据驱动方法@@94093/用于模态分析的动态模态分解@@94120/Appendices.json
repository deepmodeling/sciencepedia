{"hands_on_practices": [{"introduction": "要真正掌握动态模态分解（DMD），最好的起点是验证其在理想条件下的理论基础。本练习旨在通过实践来巩固一个核心概念：当应用于由线性时不变系统生成的无噪声数据时，“精确DMD”能够完美地重建系统动力学。通过亲手构建合成数据集并验证重构误差是否为零，你将深刻理解DMD算法的基本工作原理和其作为数据驱动模型工具的潜力。[@problem_id:2387371]", "problem": "你的任务是评估通过精确动态模态分解 (DMD) 获得的数据驱动线性模型，在应用于由线性时不变离散时间系统生成的无噪声快照时，是否能实现零重构误差。考虑一个状态序列 $\\{x_k\\}_{k=0}^{m-1}$（位于 $\\mathbb{C}^n$ 中），它由递归式 $x_{k+1} = A x_k$ 生成，其中 $A \\in \\mathbb{C}^{n \\times n}$ 是一个常数矩阵。定义快照矩阵 $X_1 = [x_0, x_1, \\dots, x_{m-2}] \\in \\mathbb{C}^{n \\times (m-1)}$ 和 $X_2 = [x_1, x_2, \\dots, x_{m-1}] \\in \\mathbb{C}^{n \\times (m-1)}$。令 $\\widehat{A}$ 表示通过精确动态模态分解从数据对 $(X_1, X_2)$ 中产生的线性算子，该过程使用 $X_1$ 的完整数值秩。定义归一化重构误差为\n$$\n\\varepsilon = \\frac{\\lVert X_2 - \\widehat{A} X_1 \\rVert_F}{\\lVert X_2 \\rVert_F},\n$$\n其中 $\\lVert \\cdot \\rVert_F$ 表示弗罗贝尼乌斯范数。如果一个数据集是无噪声的，由上述线性时不变模型生成，并且算子 $\\widehat{A}$ 是使用 $X_1$ 的完整数值秩构建的，则该数据集满足精确 DMD 的条件。\n\n通过指定满足这些条件的 $A$、$x_0$ 和 $m$ 来构造三个合成数据集。对于每个数据集，通过 $x_{k+1} = A x_k$ 生成快照 $\\{x_k\\}$，并按上述定义构建 $X_1$ 和 $X_2$。对于每个数据集，计算 $\\varepsilon$ 并返回一个布尔值，该值指示 $\\varepsilon \\leq 10^{-12}$ 是否成立。\n\n你的程序必须为以下测试套件实现此过程。在所有出现复数的情况下，角度均以弧度为单位，并且所有计算都在 $\\mathbb{C}$ 上进行。\n\n测试套件（每个要点完全指定一个数据集）：\n\n- 数据集 1（具有实特征值的可对角化）：\n  - 维度 $n = 3$，快照数量 $m = 6$。\n  - 选择 $W_1 = \\begin{bmatrix} 1 & 2 & 0 \\\\ 0 & 1 & 1 \\\\ 1 & 0 & 1 \\end{bmatrix}$ 和 $\\Lambda_1 = \\mathrm{diag}(0.8,\\, 1.2,\\, -0.5)$，并定义 $A_1 = W_1 \\Lambda_1 W_1^{-1}$。\n  - 初始状态 $x_0^{(1)} = \\begin{bmatrix} 1 \\\\ -1 \\\\ 2 \\end{bmatrix}$。\n\n- 数据集 2（包含一个振荡的复共轭对）：\n  - 维度 $n = 3$，快照数量 $m = 7$。\n  - 选择 $W_2 = I_3$（$3 \\times 3$ 单位矩阵），$\\Lambda_2 = \\mathrm{diag}\\!\\left(\\mathrm{e}^{\\mathrm{i}\\pi/6},\\, \\mathrm{e}^{-\\mathrm{i}\\pi/6},\\, 0.9\\right)$，并定义 $A_2 = \\Lambda_2$。\n  - 初始状态 $x_0^{(2)} = \\begin{bmatrix} 2 \\\\ 1 \\\\ -1 \\end{bmatrix}$。\n\n- 数据集 3（因模态未被激励导致的秩亏快照）：\n  - 维度 $n = 4$，快照数量 $m = 5$。\n  - 选择 $W_3 = I_4$（$4 \\times 4$ 单位矩阵），$\\Lambda_3 = \\mathrm{diag}(0.7,\\, 0.7,\\, 0.3,\\, 1.1)$，并定义 $A_3 = \\Lambda_3$。\n  - 初始状态 $x_0^{(3)} = \\begin{bmatrix} 3 \\\\ -2 \\\\ 0 \\\\ 0 \\end{bmatrix}$。\n\n对于每个数据集，你必须：\n1. 构建 $A$，通过 $x_{k+1} = A x_k$（其中 $k = 0, 1, \\dots, m-2$）生成 $x_k$，并构建 $X_1$ 和 $X_2$。\n2. 对 $(X_1, X_2)$ 应用精确动态模态分解，使用 $X_1$ 的完整数值秩来计算 $\\widehat{A}$。\n3. 按上文定义计算 $\\varepsilon$，并将其与 $10^{-12}$ 进行比较，以获得一个布尔结果。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个布尔值按上述顺序对应一个数据集。例如，一个有效的输出形如“[True,True,True]”。", "solution": "目标是验证当精确动态模态分解 (DMD) 方法使用数据的完整数值秩时，对于由线性时不变系统生成的无噪声快照，其重构误差为零。数据构建和误差度量规定如下。给定 $A \\in \\mathbb{C}^{n \\times n}$、一个初始状态 $x_0 \\in \\mathbb{C}^n$ 和一个整数 $m \\ge 2$，定义 $x_{k+1} = A x_k$（其中 $k = 0, \\dots, m-2$），并设置\n$$\nX_1 = [x_0, x_1, \\dots, x_{m-2}] \\in \\mathbb{C}^{n \\times (m-1)}, \\quad\nX_2 = [x_1, x_2, \\dots, x_{m-1}] \\in \\mathbb{C}^{n \\times (m-1)}.\n$$\n根据构造，有 $X_2 = A X_1$。\n\n精确 DMD 算子 $\\widehat{A}$ 是 $X_1$ 列空间上的一个数据驱动线性映射，它将 $X_1$ 中的每个 $x_k$ 映射到 $X_2$ 中的 $x_{k+1}$。为了从数据中构建 $\\widehat{A}$，我们使用 $X_1$ 的奇异值分解 (SVD)。设 $X_1$ 的 (细) SVD 为\n$$\nX_1 = U_r S_r V_r^*,\n$$\n其中 $U_r \\in \\mathbb{C}^{n \\times r}$，$S_r \\in \\mathbb{R}^{r \\times r}$ 是对角元素为严格正数的对角矩阵，$V_r \\in \\mathbb{C}^{(m-1) \\times r}$ 具有正交标准列，且 $r = \\mathrm{rank}(X_1)$ 是由奇异值确定的完整数值秩。则精确 DMD 算子定义为\n$$\n\\widehat{A} = X_2 V_r S_r^{-1} U_r^*.\n$$\n现在我们证明，对于无噪声序列数据，在精确算术下，这种选择能保证零重构误差。\n\n首先，观察到\n$$\n\\widehat{A} X_1 = X_2 V_r S_r^{-1} U_r^* \\, (U_r S_r V_r^*) = X_2 V_r V_r^*.\n$$\n矩阵 $V_r V_r^*$ 是 $\\mathbb{C}^{(m-1) \\times (m-1)}$ 中到 $X_1$ 行空间的正交投影算子。对于无噪声序列数据，有 $X_2 = A X_1$，这意味着 $X_2$ 的行空间包含于 $X_1$ 的行空间，因为左乘 $A$ 构成了 $X_1$ 各行的线性组合。因此，将 $X_2$ 投影到 $X_1$ 的行空间上并不会改变它：\n$$\nX_2 V_r V_r^* = X_2.\n$$\n因此，\n$$\n\\widehat{A} X_1 = X_2,\n$$\n这意味着由\n$$\n\\varepsilon = \\frac{\\lVert X_2 - \\widehat{A} X_1 \\rVert_F}{\\lVert X_2 \\rVert_F}\n$$\n定义的重构误差在精确算术中恰好为零。\n\n在有限精度算术中，数值舍入误差会导致一个小的非零值。使用一个如 $10^{-12}$ 的严格容差可以捕捉到这一点，并验证理论结果。\n\n接下来，我们证明测试套件中的每个数据集都满足所需条件：\n\n- 数据集 1：$A_1 = W_1 \\Lambda_1 W_1^{-1}$，其中 $W_1$ 可逆，$\\Lambda_1$ 为具有不同实特征值的对角矩阵。这确保 $A_1$ 是可对角化的。快照是无噪声的，并满足 $X_2 = A_1 X_1$。$X_1$ 的数值秩等于由 $x_0^{(1)}$ 激励的不变子空间的维度，由于 $x_0^{(1)}$ 的选择和不同的特征值，这里的秩将是满秩。\n\n- 数据集 2：$A_2 = \\Lambda_2$，其中 $\\Lambda_2 = \\mathrm{diag}\\!\\left(\\mathrm{e}^{\\mathrm{i}\\pi/6}, \\mathrm{e}^{-\\mathrm{i}\\pi/6}, 0.9\\right)$。该矩阵在 $\\mathbb{C}$ 上是对角的，因此是可对角化的，具有一个振荡的复共轭特征对和一个实衰减特征值。快照是无噪声的，并由 $x_{k+1} = A_2 x_k$ 生成，因此 $X_2 = A_2 X_1$。数值秩从 $X_1$ 的奇异值中检测。\n\n- 数据集 3：$A_3 = \\Lambda_3$，其中 $\\Lambda_3 = \\mathrm{diag}(0.7, 0.7, 0.3, 1.1)$ 且 $x_0^{(3)} = [3, -2, 0, 0]^T$。只有前两个特征模态被激励，因此快照位于一个二维不变子空间中，使得 $X_1$ 是秩亏的（秩等于 2），尽管 $n=4$。使用完整数值秩 $r=2$ 构建的精确 DMD 仍然精确满足 $\\widehat{A} X_1 = X_2$，因为数据仍然是无噪声的，且 $X_2 = A_3 X_1$，$X_2$ 的行空间包含在 $X_1$ 的行空间内。\n\n程序的算法规划：\n1. 对于每个数据集，按规定构建 $A$，迭代生成 $x_k$，并构建 $X_1$ 和 $X_2$。\n2. 计算 $X_1$ 的细 SVD 以获得 $U, S, V^*$，使用阈值 $S_i > \\tau$ (其中 $\\tau = \\max(n, m-1) \\cdot \\epsilon \\cdot S_1$，$\\epsilon$ 是机器精度) 确定数值秩 $r$。\n3. 截断以获得 $U_r, S_r, V_r$ 并计算 $\\widehat{A} = X_2 V_r S_r^{-1} U_r^*$。\n4. 计算 $\\varepsilon$ 并与 $10^{-12}$ 进行比较，为每个数据集生成布尔结果。\n5. 以所需的单行格式输出布尔值列表。\n\n由于这些数据集满足精确 DMD 的条件，对于所有三种情况，重构误差在指定容差范围内都应为数值上的零。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef numerical_rank(S, shape, eps=None):\n    \"\"\"\n    Determine the numerical rank based on singular values S and matrix shape.\n    Uses threshold tau = max(shape) * eps * S[0].\n    \"\"\"\n    if eps is None:\n        eps = np.finfo(float).eps\n    if S.size == 0:\n        return 0\n    tau = max(shape) * eps * S[0]\n    return int(np.sum(S > tau))\n\ndef exact_dmd_operator(X1, X2):\n    \"\"\"\n    Compute the exact DMD operator A_hat = X2 V_r S_r^{-1} U_r^* using the full numerical rank.\n    \"\"\"\n    # Compute SVD of X1\n    U, s, Vh = np.linalg.svd(X1, full_matrices=False)\n    # Determine numerical rank\n    r = numerical_rank(s, X1.shape)\n    if r == 0:\n        # Degenerate case: no information\n        return np.zeros((X2.shape[0], X1.shape[0]), dtype=X1.dtype)\n    U_r = U[:, :r]\n    S_r_inv = np.diag(1.0 / s[:r])\n    V_r = Vh.conj().T[:, :r]\n    # Exact DMD operator\n    A_hat = X2 @ V_r @ S_r_inv @ U_r.conj().T\n    return A_hat\n\ndef generate_snapshots(A, x0, m):\n    \"\"\"\n    Generate snapshots x_0, x_1, ..., x_{m-1} using x_{k+1} = A x_k.\n    Returns X1 = [x0 ... x_{m-2}] and X2 = [x1 ... x_{m-1}].\n    \"\"\"\n    n = A.shape[0]\n    X = np.zeros((n, m), dtype=complex)\n    X[:, 0] = x0\n    for k in range(m - 1):\n        X[:, k + 1] = A @ X[:, k]\n    X1 = X[:, :-1]\n    X2 = X[:, 1:]\n    return X1, X2\n\ndef build_dataset_1():\n    # Dataset 1: A = W * Lambda * W^{-1}, real diagonalizable\n    W = np.array([[1, 2, 0],\n                  [0, 1, 1],\n                  [1, 0, 1]], dtype=float)\n    Lambda = np.diag([0.8, 1.2, -0.5])\n    Winv = np.linalg.inv(W)\n    A = (W @ Lambda @ Winv).astype(complex)\n    x0 = np.array([1, -1, 2], dtype=complex)\n    m = 6\n    return A, x0, m\n\ndef build_dataset_2():\n    # Dataset 2: complex conjugate pair and a real eigenvalue\n    lam1 = np.exp(1j * np.pi / 6.0)\n    lam2 = np.exp(-1j * np.pi / 6.0)\n    lam3 = 0.9 + 0j\n    A = np.diag([lam1, lam2, lam3]).astype(complex)\n    x0 = np.array([2, 1, -1], dtype=complex)\n    m = 7\n    return A, x0, m\n\ndef build_dataset_3():\n    # Dataset 3: rank-deficient snapshots (only first two modes excited)\n    A = np.diag([0.7, 0.7, 0.3, 1.1]).astype(complex)\n    x0 = np.array([3, -2, 0, 0], dtype=complex)\n    m = 5\n    return A, x0, m\n\ndef reconstruction_boolean(X1, X2, tol=1e-12):\n    A_hat = exact_dmd_operator(X1, X2)\n    diff = X2 - (A_hat @ X1)\n    num = np.linalg.norm(diff, ord='fro')\n    den = np.linalg.norm(X2, ord='fro')\n    # Handle the degenerate case where X2 is zero matrix\n    rel_err = 0.0 if den == 0.0 else (num / den)\n    return rel_err = tol\n\ndef solve():\n    # Define the test cases from the problem statement.\n    datasets = [\n        build_dataset_1(),\n        build_dataset_2(),\n        build_dataset_3(),\n    ]\n\n    results = []\n    for A, x0, m in datasets:\n        X1, X2 = generate_snapshots(A, x0, m)\n        results.append(reconstruction_boolean(X1, X2, tol=1e-12))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2387371"}, {"introduction": "在解决了理想情况后，我们来探讨在实际应用DMD时一个至关重要的步骤：选择合适的奇异值分解（SVD）截断秩 $r$。这个参数直接决定了我们模型的复杂度和它捕捉系统动态特征的能力。本练习将引导你研究秩 $r$ 的选择如何影响模态识别，特别是在处理频率相近或能量较低的挑战性模态时，从而培养你在实际问题中平衡模型精度与复杂性的关键技能。[@problem_id:2387367]", "problem": "要求您设计并实现一个程序，研究在动态模态分解 (DMD) 中，低秩分解的秩截断如何影响模态识别。请从离散时间线性时不变演化模型出发，并基于一个核心线性代数定义——即可以从数据中推断出将一个快照推进到下一个快照的最佳拟合线性算子。以此为基础，推导出一个计算流程，该流程能根据用户指定的截断秩 $r$，从快照数据中估计主导模态及其相关的离散时间特征值。您的程序必须对几个精心构建的测试用例进行量化，确定有多少真实模态被正确识别。这些测试用例包括频率相近的系统和具有低能量模态的系统。所有角度都必须以弧度为单位进行处理。\n\n此任务必须纯粹用数学和算法术语来表述：\n\n- 考虑一个由 $p$ 个模态线性叠加生成的复值快照序列 $\\{x_k\\}_{k=0}^{m-1}$，其中 $x_k \\in \\mathbb{C}^n$，\n  $$x_k = \\sum_{j=1}^{p} a_j \\, \\phi_j \\, e^{(\\sigma_j + \\mathrm{i}\\,\\omega_j)\\,k},$$\n  式中，$\\phi_j \\in \\mathbb{C}^n$ 是空间模态形状，$a_j \\in \\mathbb{R}_+$ 是模态振幅（能量代理），$\\sigma_j \\in \\mathbb{R}$ 是每个样本的离散时间增长率，而 $\\omega_j \\in \\mathbb{R}$ 是每个样本的角频率（单位为弧度）。与模态 $j$ 相关的离散时间特征值为 $\\lambda_j^\\star = e^{\\sigma_j + \\mathrm{i}\\,\\omega_j}$。这些快照被堆叠成数据矩阵 $X = [x_0,\\dots,x_{m-2}] \\in \\mathbb{C}^{n \\times (m-1)}$ 和 $Y = [x_1,\\dots,x_{m-1}] \\in \\mathbb{C}^{n \\times (m-1)}$。\n- 从线性算子 $A$ 的最小二乘拟合定义（即 $Y \\approx A X$）出发，并利用奇异值分解 (SVD) 来稳定计算并实现低秩近似，推导出一个在用户选择的秩截断 $r$ 下估计降维算子及其特征值的计算流程。除了线性时不变模型和标准线性代数外，不要引入任何其他假设。\n- 实现一个匹配规则来统计正确识别的数量：如果以下两个条件同时成立，则称计算出的特征值 $\\mu$ 与真实值 $\\lambda_j^\\star$ 匹配：\n  1) 其辐角的环绕绝对角差至多为容差 $\\tau_\\omega$，即 $\\arg(\\mu)$ 与 $\\omega_j$ 模 $2\\pi$ 的最小绝对差值 $\\le \\tau_\\omega$（角度单位为弧度）。\n  2) 模长差满足 $\\big|\\,|\\mu| - e^{\\sigma_j}\\,\\big| \\le \\tau_m$。\n  请使用 $\\tau_\\omega = 10^{-3}$ 和 $\\tau_m = 10^{-3}$。\n- 为保证可复现性，当使用随机量（例如空间模态 $\\phi_j$）时，请在构建测试用例前将随机数生成器种子固定为 $12345$。\n\n测试套件。您的程序必须构建以下五个测试用例，生成相应的快照，执行秩为 $r$ 的 DMD 流程，并计算每个用例中被正确识别模态的整数数量。使用 $n=6$ 个传感器和复值快照。在所有用例中，将附加噪声水平设为零。角度单位为弧度，时间以整数采样步长计算。\n\n- 案例 1（基准线，良好分离）：$m=300$, $p=3$, $\\omega=[0.40,\\,1.10,\\,2.20]$, $\\sigma=[0.00,\\,0.00,\\,0.00]$, $a=[1.00,\\,0.80,\\,0.50]$, $r=3$。\n- 案例 2（频率相近对，秩充足）：$m=400$, $p=3$, $\\omega=[0.20,\\,0.205,\\,1.00]$, $\\sigma=[0.00,\\,0.00,\\,0.00]$, $a=[1.00,\\,1.00,\\,0.30]$, $r=3$。\n- 案例 3（频率相近对，秩不足）：$m=400$, $p=3$, $\\omega=[0.20,\\,0.205,\\,1.00]$, $\\sigma=[0.00,\\,0.00,\\,0.00]$, $a=[1.00,\\,1.00,\\,0.30]$, $r=2$。\n- 案例 4（低能量、衰减模态）：$m=300$, $p=3$, $\\omega=[0.50,\\,1.20,\\,1.80]$, $\\sigma=[0.00,\\,0.00,\\,-0.02]$, $a=[1.00,\\,0.80,\\,0.05]$, $r=3$。\n- 案例 5（边界秩）：$m=300$, $p=3$, $\\omega=[0.25,\\,0.80,\\,1.60]$, $\\sigma=[0.00,\\,0.00,\\,0.00]$, $a=[1.00,\\,0.80,\\,0.50]$, $r=1$。\n\n对于每个案例：\n- 构建 $p$ 个单位 2-范数的随机空间模态 $\\phi_j \\in \\mathbb{C}^n$。\n- 使用上述叠加公式（无噪声）为 $k=0,\\dots,m-1$ 形成快照 $x_k$。\n- 从连续的快照构建 $X$ 和 $Y$。\n- 应用您的秩为 $r$ 的 DMD 流程来计算特征值集合 $\\{\\mu_\\ell\\}$。\n- 在所述容差下，通过在 $\\{\\mu_\\ell\\}$ 和 $\\{\\lambda_j^\\star\\}$ 之间进行一一匹配，统计正确识别模态的整数数量。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个 Python 风格的 5 个整数的列表，第 $i$ 个整数是案例 $i$ 中正确识别的模态数。输出必须严格遵循 \"[v1,v2,v3,v4,v5]\" 的格式，不含多余空格或文本。所有角度计算都必须以弧度为单位。除了所有角度都以弧度为单位的指令外，不需要其他物理单位。", "solution": "所述问题在科学上是合理的、数学上是适定的，并包含了获得唯一且可验证解所需的所有信息。它提出了计算工程领域中的一个标准任务：动态模态分解 (DMD) 算法的实现与分析。该研究专注于秩截断（DMD 的一个关键参数）如何影响动态模态的识别，尤其是在涉及频率相近、低能量模态和秩严重受限等挑战性场景中。因此，我将从第一性原理出发推导所需的算法，然后进行实现。\n\nDMD 的基本前提是，一个系统的演化（由一系列状态向量（快照）$\\{x_k\\}_{k=0}^{m-1}$，其中 $x_k \\in \\mathbb{C}^n$ 表示）可以由一个线性时不变算子 $A \\in \\mathbb{C}^{n \\times n}$ 来近似。这意味着存在如下关系：\n$$\nx_{k+1} \\approx A x_k\n$$\n通过构建两个数据矩阵 $X = [x_0, x_1, \\dots, x_{m-2}]$ 和 $Y = [x_1, x_2, \\dots, x_{m-1}]$（均为 $\\mathbb{C}^{n \\times (m-1)}$），这个关系可以扩展到整个快照序列。系统动力学随后可以紧凑地表示为：\n$$\nY \\approx A X\n$$\n通过求解最小二乘问题 $\\min_A \\| Y - A X \\|_F$（其中 $\\| \\cdot \\|_F$ 是弗罗贝尼乌斯范数），可以找到最佳模拟从 $X$ 到 $Y$ 转变的算子 $A$。其解由 $A = Y X^+$ 给出，其中 $X^+$ 表示 $X$ 的 Moore-Penrose 伪逆。\n\n对于状态维度 $n$ 很大的系统，构建和分析 $n \\times n$ 矩阵 $A$ 的计算成本高昂，且通常难以处理。目标是在不显式构建 $A$ 的情况下，确定 $A$ 的谱特性（其特征值和特征向量），这些特性表征了系统的动态模态。这可以通过使用数据矩阵 $X$ 的奇异值分解 (SVD) 并基于投影的方法来实现。\n\n$X$ 的 SVD 分解为 $X = U \\Sigma V^H$，其中 $U \\in \\mathbb{C}^{n \\times q}$ 和 $V \\in \\mathbb{C}^{(m-1) \\times q}$ 是具有正交单位列的矩阵，$\\Sigma \\in \\mathbb{R}^{q \\times q}$ 是由正奇异值 $\\sigma_i$ 构成的对角矩阵，其中 $q = \\min(n, m-1)$。$U$ 的列构成一个能最优捕获快照中能量的基。降秩 DMD 的核心思想是将动力学投影到由 $U$ 的前 $r$ 列张成的秩为 $r \\le q$ 的低维子空间上。这通过截断 SVD 分解实现：\n$$\nX \\approx X_r = U_r \\Sigma_r V_r^H\n$$\n其中 $U_r \\in \\mathbb{C}^{n \\times r}$，$\\Sigma_r \\in \\mathbb{R}^{r \\times r}$ 和 $V_r \\in \\mathbb{C}^{(m-1) \\times r}$是截断后的 SVD 矩阵。秩为 $r$ 的近似数据矩阵的伪逆是 $X_r^+ = V_r \\Sigma_r^{-1} U_r^H$。算子 $A$ 的低秩近似则为：\n$$\nA \\approx Y X_r^+ = Y V_r \\Sigma_r^{-1} U_r^H\n$$\n动力学被投影到由 POD 模态（$U_r$ 的列）张成的子空间上。降维算子 $\\tilde{A} \\in \\mathbb{C}^{r \\times r}$ 代表 $A$ 在此投影子空间中的作用，定义为 $\\tilde{A} = U_r^H A U_r$。$\\tilde{A}$ 的特征值近似于 $A$ 的主导特征值。代入 $A$ 的表达式并利用 $U_r^H U_r = I_r$（大小为 $r$ 的单位矩阵）的性质，我们得到降维算子的最终表达式：\n$$\n\\tilde{A} = U_r^H Y V_r \\Sigma_r^{-1}\n$$\n这个小的 $r \\times r$ 矩阵 $\\tilde{A}$ 的特征值就是秩为 $r$ 的 DMD 特征值。\n\n因此，计算流程如下：\n$1$. 从快照的时间序列构建数据矩阵 $X, Y$。\n$2$. 计算 $X$ 的 SVD 分解 $X = U \\Sigma V^H$。\n$3$. 将 SVD 分解的各部分截断至指定的秩 $r$，以获得 $U_r$、$\\Sigma_r$ 和 $V_r$。\n$4$. 计算低秩系统算子表示 $\\tilde{A} = U_r^H Y V_r \\Sigma_r^{-1}$。\n$5$. 计算 $\\tilde{A}$ 的特征值，即所求的 DMD 特征值 $\\{\\mu_\\ell\\}_{\\ell=1}^r$。\n\n对于给定问题，合成数据由已知的模态叠加生成，$x_k = \\sum_{j=1}^{p} a_j \\phi_j \\lambda_j^{\\star k}$，其中 $\\lambda_j^\\star = e^{\\sigma_j + \\mathrm{i}\\omega_j}$ 是真实的离散时间特征值。计算出的 DMD 特征值 $\\{\\mu_\\ell\\}$ 与真实特征值集合 $\\{\\lambda_j^\\star\\}$ 进行比较。如果模长差 $|\\,|\\mu_\\ell| - |\\lambda_j^\\star|\\,| \\le \\tau_m$ 和环绕角差 $\\min(|\\arg(\\mu_\\ell) - \\arg(\\lambda_j^\\star)|, 2\\pi - |\\arg(\\mu_\\ell) - \\arg(\\lambda_j^\\star)|) \\le \\tau_\\omega$ 均满足（使用指定的容差 $\\tau_m=10^{-3}$ 和 $\\tau_\\omega=10^{-3}$），则宣告匹配。使用一一匹配协议来统计正确识别的模态数量。以下代码针对五个指定的测试用例实现了此流程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DMD problem for a suite of test cases.\n    Derives DMD eigenvalues for different ranks and physical parameters,\n    and counts the number of correctly identified modes.\n    \"\"\"\n\n    # Global parameters as defined in the problem statement\n    n_sensors = 6\n    tau_omega = 1e-3\n    tau_m = 1e-3\n    rng_seed = 12345\n\n    # Define the five test cases\n    test_cases = [\n        # Case 1 (baseline, well-separated)\n        {'m': 300, 'p': 3, 'omega': np.array([0.40, 1.10, 2.20]), \n         'sigma': np.array([0.00, 0.00, 0.00]), 'a': np.array([1.00, 0.80, 0.50]), 'r': 3},\n        # Case 2 (closely spaced pair, adequate rank)\n        {'m': 400, 'p': 3, 'omega': np.array([0.20, 0.205, 1.00]), \n         'sigma': np.array([0.00, 0.00, 0.00]), 'a': np.array([1.00, 1.00, 0.30]), 'r': 3},\n        # Case 3 (closely spaced pair, insufficient rank)\n        {'m': 400, 'p': 3, 'omega': np.array([0.20, 0.205, 1.00]), \n         'sigma': np.array([0.00, 0.00, 0.00]), 'a': np.array([1.00, 1.00, 0.30]), 'r': 2},\n        # Case 4 (low-energy, decaying mode)\n        {'m': 300, 'p': 3, 'omega': np.array([0.50, 1.20, 1.80]), \n         'sigma': np.array([0.00, 0.00, -0.02]), 'a': np.array([1.00, 0.80, 0.05]), 'r': 3},\n        # Case 5 (boundary rank)\n        {'m': 300, 'p': 3, 'omega': np.array([0.25, 0.80, 1.60]), \n         'sigma': np.array([0.00, 0.00, 0.00]), 'a': np.array([1.00, 0.80, 0.50]), 'r': 1},\n    ]\n\n    # Fix the random number generator seed for reproducibility\n    np.random.seed(rng_seed)\n\n    # Generate spatial modes once, as they are used across all cases\n    # The problem implies new random modes for each case. The seed is reset before each construction.\n    # To be safe and compliant, let's create random modes inside the loop.\n\n    results = []\n    for case_params in test_cases:\n        # Unpack parameters for the current case\n        m = case_params['m']\n        p = case_params['p']\n        omega_true = case_params['omega']\n        sigma_true = case_params['sigma']\n        a_true = case_params['a']\n        r = case_params['r']\n\n        # --- 1. Generate Data ---\n        # Generate p random, orthonormal spatial modes phi_j in C^n\n        # Set seed before each case to ensure case-specific reproducibility\n        np.random.seed(rng_seed)\n        phi_modes = np.zeros((n_sensors, p), dtype=np.complex128)\n        for j in range(p):\n            vec = np.random.randn(n_sensors) + 1j * np.random.randn(n_sensors)\n            phi_modes[:, j] = vec / np.linalg.norm(vec)\n\n        # True discrete-time eigenvalues\n        lambda_true = np.exp(sigma_true + 1j * omega_true)\n        \n        # Time steps\n        k_steps = np.arange(m)\n        \n        # Temporal evolution of each mode (Vandermonde matrix)\n        temporal_dynamics = np.exp(np.outer(k_steps, sigma_true + 1j * omega_true))\n        \n        # Superposition of modes to generate snapshots\n        # snapshots = phi * diag(a) * V.T\n        snapshots = phi_modes @ np.diag(a_true) @ temporal_dynamics.T\n\n        # Create data matrices X and Y\n        X = snapshots[:, :-1]\n        Y = snapshots[:, 1:]\n\n        # --- 2. Apply Rank-r DMD ---\n        # SVD of X\n        U, s, Vh = np.linalg.svd(X, full_matrices=False)\n\n        # Truncate to rank r\n        Ur = U[:, :r]\n        Sr = s[:r]\n        Vr = Vh[:r, :].conj().T\n        \n        # Compute reduced operator A_tilde\n        # A_tilde = Ur^H * Y * Vr * inv(Sr)\n        Sr_inv = np.diag(1.0 / Sr)\n        A_tilde = Ur.conj().T @ Y @ Vr @ Sr_inv\n        \n        # Compute DMD eigenvalues\n        dmd_eigvals = np.linalg.eig(A_tilde)[0]\n        \n        # --- 3. Match Eigenvalues and Count ---\n        true_mags = np.exp(sigma_true)\n        true_angles = omega_true\n\n        computed_mags = np.abs(dmd_eigvals)\n        computed_angles = np.angle(dmd_eigvals)\n\n        count = 0\n        matched_computed_indices = set()\n        \n        # One-to-one matching: for each true mode, find one unique matching computed mode\n        for j in range(p):\n            for i in range(r):\n                if i in matched_computed_indices:\n                    continue\n\n                # Check magnitude condition\n                mag_diff = np.abs(computed_mags[i] - true_mags[j])\n                is_mag_match = mag_diff = tau_m\n\n                # Check angle condition (wrapped difference)\n                angle_diff = computed_angles[i] - true_angles[j]\n                wrapped_angle_diff = np.abs((angle_diff + np.pi) % (2 * np.pi) - np.pi)\n                is_angle_match = wrapped_angle_diff = tau_omega\n                \n                if is_mag_match and is_angle_match:\n                    count += 1\n                    matched_computed_indices.add(i)\n                    break # Move to the next true mode\n\n        results.append(count)\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2387367"}]}