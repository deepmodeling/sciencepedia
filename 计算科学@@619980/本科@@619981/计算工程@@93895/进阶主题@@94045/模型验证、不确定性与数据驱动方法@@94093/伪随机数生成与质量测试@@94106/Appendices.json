{"hands_on_practices": [{"introduction": "一个高质量的伪随机数生成器最基本的特性是它应该以正确的概率产生所有可能的结果。此练习将指导您使用统计假设检验的基石——皮尔逊 $\\chi^2$ (卡方) 检验，来检测一个生成器在生成离散符号（如DNA碱基 'A', 'T', 'C', 'G'）时是否存在频率偏差。通过完成这项任务，您将获得量化观测数据与理论模型之间偏差的实践经验，这是验证任何数据生成过程的关键技能。[@problem_id:2429686]", "problem": "您的任务是评估一个伪随机数生成器 (PRNG) 是否从字母表 $\\{ \\texttt{A}, \\texttt{T}, \\texttt{C}, \\texttt{G} \\}$ 中产生一个无偏的离散符号序列。一个无偏的生成器会在每次抽取时，以相等的概率 $1/4$ 生成每个符号，且每次抽取都独立于之前的抽取。请仅使用离散均匀模型下的假设检验第一性原理，构建一个决策规则。该规则在给定一个长度为 $n$、基于字母表 $\\{ \\texttt{A}, \\texttt{T}, \\texttt{C}, \\texttt{G} \\}$ 的有限序列 $s$ 时，会输出一个实值 $p$-value 和一个布尔值决策，用以表明在显著性水平 $\\alpha = 0.01$ 下，是否存在边缘偏差的充分证据。您的决策规则必须基于一个根据观测计数计算出的标量统计量的分布，该分布是在原假设（即每个符号在每次抽取中出现的概率均为 $1/4$）下得出的。该 $p$-value 必须是该统计量在原假设模型下的精确上尾概率，并且当且仅当 $p$-value 严格小于 $\\alpha$ 时，布尔决策必须为 $\\texttt{True}$。\n\n对于一个给定的序列 $s$，令 $O_i$ 为序列 $s$ 中符号 $i \\in \\{ \\texttt{A}, \\texttt{T}, \\texttt{C}, \\texttt{G} \\}$ 的观测计数，令 $E_i = n/4$ 为原假设下的期望计数。请从 $\\{O_i\\}$ 和 $\\{E_i\\}$ 定义一个单一的标量检验统计量，其在原假设下的参考分布具有闭合形式，并且仅依赖于类别数 $k = 4$。使用此参考分布计算已实现的统计量的上尾概率，即为所求的 $p$-value。然后将该 $p$-value 与 $\\alpha = 0.01$ 进行比较，以得出布尔决策。\n\n测试套件。请将您的方法应用于以下五个基于 $\\{ \\texttt{A}, \\texttt{T}, \\texttt{C}, \\texttt{G} \\}$ 的序列：\n- 情况 1：$s_1$ 是字符串 $\\texttt{\"ATCG\"}$ 自身拼接 $25$ 次的结果，因此 $n = 100$。\n- 情况 2：$s_2$ 是字符串 $\\texttt{\"A\"}$ 自身拼接 $100$ 次的结果，因此 $n = 100$。\n- 情况 3：$s_3$ 的计数为 $O_{\\texttt{A}} = 16$, $O_{\\texttt{T}} = 8$, $O_{\\texttt{C}} = 8$, $O_{\\texttt{G}} = 8$（顺序任意），因此 $n = 40$。\n- 情况 4：$s_4 = \\texttt{\"ATCG\"}$，因此 $n = 4$。\n- 情况 5：$s_5$ 的计数为 $O_{\\texttt{A}} = 20$, $O_{\\texttt{T}} = 7$, $O_{\\texttt{C}} = 7$, $O_{\\texttt{G}} = 6$（顺序任意），因此 $n = 40$。\n\n答案规格。对于每种情况 $j \\in \\{1,2,3,4,5\\}$，您的程序必须计算：\n- 一个布尔值 $\\texttt{reject}_j$，当且仅当 $p$-value 小于 $\\alpha = 0.01$ 时为 $\\texttt{True}$，否则为 $\\texttt{False}$；\n- 一个浮点数 $p_j$，其值为 $p$-value。\n\n最终输出格式。您的程序应生成单行输出，包含一个长度为 $5$ 的列表，其中第 $j$ 个元素是一个双元素列表 $[\\texttt{reject}_j, p_j]$，顺序与上述情况一致。例如，输出形式必须为 $[[\\texttt{bool}, \\texttt{float}],[\\texttt{bool}, \\texttt{float}],\\dots]$，包含恰好五个条目，打印在单行上。本问题不涉及物理单位或角度单位。", "solution": "问题陈述已经过严格审阅，并被认为是有效的。它构成了一个在计算统计学领域中定义明确且有科学依据的问题，具体来说是针对离散均匀分布的拟合优度检验。给定条件是完整、一致且客观的，允许使用标准的假设检验原理得出一个唯一且可验证的解。\n\n任务是确定来自字母表 $\\{ \\texttt{A}, \\texttt{T}, \\texttt{C}, \\texttt{G} \\}$ 的符号序列是否显示出边缘偏差的证据。这被表述为一个假设检验问题。原假设 $H_0$ 假定生成器是无偏的，即 $k=4$ 个符号中的每一个都以相等的概率 $p_i = 1/4$ 产生。备择假设 $H_A$ 是至少有一个符号的概率不等于 $1/4$。\n\n为了检验这个假设，我们使用 Pearson 卡方($\\chi^2$)拟合优度检验。该检验基于一个标量统计量，该统计量衡量了观测到的符号计数 $O_i$ 与原假设下的期望计数 $E_i$ 之间的差异。对于一个长度为 $n$ 的序列，每个符号的期望计数为 $E_i = n \\cdot p_i = n/4$。检验统计量定义为：\n$$ \\chi^2 = \\sum_{i=1}^{k} \\frac{(O_i - E_i)^2}{E_i} $$\n在原假设下，该统计量近似服从自由度为 $k-1$ 的卡方分布。由于我们有 $k=4$ 个类别，参考分布是自由度为 $df = 4 - 1 = 3$ 的卡方分布。该分布具有闭合形式，并且仅依赖于类别数量，正如问题陈述所要求的那样。当所有期望计数 $E_i$ 至少为 $5$ 时，这种近似的有效性通常被认为是可接受的。\n\n决策规则构建如下：\n1. 对于给定序列，计算 4 个符号中每个符号的观测计数 $O_i$。\n2. 使用上述公式计算卡方统计量 $\\chi^2_{\\text{calc}}$。\n3. 计算 $p$-value，它是在假设 $H_0$ 为真的情况下，观测到等于或比 $\\chi^2_{\\text{calc}}$ 更极端的检验统计量的概率。这对应于 $\\chi^2_3$ 分布的上尾概率：$p = P(\\chi^2_3 \\ge \\chi^2_{\\text{calc}})$。\n4. 将 $p$-value 与指定的显著性水平 $\\alpha = 0.01$ 进行比较。如果 $p < \\alpha$，我们拒绝原假设，并得出结论认为存在边缘偏差的充分证据。布尔决策 `reject` 为 $\\texttt{True}$。否则，我们未能拒绝 $H_0$，`reject` 为 $\\texttt{False}$。\n\n我们现在将此过程应用于五个测试用例。\n\n情况 1：$s_1$ 是 $\\texttt{\"ATCG\"}$ 重复 $25$ 次。\n序列长度为 $n = 100$。\n观测计数为 $O_{\\texttt{A}} = 25$, $O_{\\texttt{T}} = 25$, $O_{\\texttt{C}} = 25$, $O_{\\texttt{G}} = 25$。\n期望计数对所有 $i$ 均为 $E_i = 100/4 = 25$。\n检验统计量为：\n$$ \\chi^2_{\\text{calc}} = \\frac{(25-25)^2}{25} + \\frac{(25-25)^2}{25} + \\frac{(25-25)^2}{25} + \\frac{(25-25)^2}{25} = 0 $$\n$p$-value 为 $P(\\chi^2_3 \\ge 0) = 1$。由于 $1 \\not< 0.01$，我们未能拒绝 $H_0$。决策：$\\texttt{False}$。\n\n情况 2：$s_2$ 是 $\\texttt{\"A\"}$ 重复 $100$ 次。\n序列长度为 $n = 100$。\n观测计数为 $O_{\\texttt{A}} = 100, O_{\\texttt{T}} = 0, O_{\\texttt{C}} = 0, O_{\\texttt{G}} = 0$。\n期望计数为 $E_i = 100/4 = 25$。\n检验统计量为：\n$$ \\chi^2_{\\text{calc}} = \\frac{(100-25)^2}{25} + \\frac{(0-25)^2}{25} + \\frac{(0-25)^2}{25} + \\frac{(0-25)^2}{25} = \\frac{75^2}{25} + 3 \\cdot \\frac{(-25)^2}{25} = 225 + 75 = 300 $$\n在 $\\alpha=0.01$ 时 $\\chi^2_3$ 的临界值约为 $11.345$。由于 $300 \\gg 11.345$，$p$-value 极小，必然小于 $0.01$。我们拒绝 $H_0$。决策：$\\texttt{True}$。\n\n情况 3：$s_3$ 的计数为 $O_{\\texttt{A}} = 16, O_{\\texttt{T}} = 8, O_{\\texttt{C}} = 8, O_{\\texttt{G}} = 8$。\n序列长度为 $n = 16+8+8+8=40$。\n期望计数为 $E_i = 40/4 = 10$。\n检验统计量为：\n$$ \\chi^2_{\\text{calc}} = \\frac{(16-10)^2}{10} + \\frac{(8-10)^2}{10} + \\frac{(8-10)^2}{10} + \\frac{(8-10)^2}{10} = \\frac{36}{10} + \\frac{4}{10} + \\frac{4}{10} + \\frac{4}{10} = 3.6 + 0.4 + 0.4 + 0.4 = 4.8 $$\n由于 $4.8 < 11.345$，$p$-value 大于 $0.01$。我们未能拒绝 $H_0$。决策：$\\texttt{False}$。\n\n情况 4：$s_4 = \\texttt{\"ATCG\"}$。\n序列长度为 $n = 4$。\n观测计数为 $O_{\\texttt{A}} = 1, O_{\\texttt{T}} = 1, O_{\\texttt{C}} = 1, O_{\\texttt{G}} = 1$。\n期望计数为 $E_i = 4/4 = 1$。此处，条件 $E_i \\ge 5$ 未被满足，因此卡方近似效果不佳。尽管如此，我们仍遵循所述步骤。\n检验统计量为：\n$$ \\chi^2_{\\text{calc}} = \\frac{(1-1)^2}{1} + \\frac{(1-1)^2}{1} + \\frac{(1-1)^2}{1} + \\frac{(1-1)^2}{1} = 0 $$\n$p$-value 为 $P(\\chi^2_3 \\ge 0) = 1$。由于 $1 \\not< 0.01$，我们未能拒绝 $H_0$。决策：$\\texttt{False}$。\n\n情况 5：$s_5$ 的计数为 $O_{\\texttt{A}} = 20, O_{\\texttt{T}} = 7, O_{\\texttt{C}} = 7, O_{\\texttt{G}} = 6$。\n序列长度为 $n = 20+7+7+6=40$。\n期望计数为 $E_i = 40/4 = 10$。\n检验统计量为：\n$$ \\chi^2_{\\text{calc}} = \\frac{(20-10)^2}{10} + \\frac{(7-10)^2}{10} + \\frac{(7-10)^2}{10} + \\frac{(6-10)^2}{10} = \\frac{100}{10} + \\frac{9}{10} + \\frac{9}{10} + \\frac{16}{10} = 10 + 0.9 + 0.9 + 1.6 = 13.4 $$\n由于 $13.4 > 11.345$，$p$-value 小于 $0.01$。我们拒绝 $H_0$。决策：$\\texttt{True}$。\n\n以下程序实现了这一逻辑，用于计算每种情况的精确 $p$-value 和决策。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Applies the chi-squared goodness-of-fit test to evaluate marginal bias\n    in sequences of discrete symbols.\n    \"\"\"\n    # Define the significance level from the problem statement.\n    alpha = 0.01\n    \n    # Define the number of categories (symbols in the alphabet).\n    k = 4\n    \n    # Degrees of freedom for the chi-squared distribution.\n    df = k - 1\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (sequence_length_n, observed_counts_O)\n    test_cases = [\n        # Case 1: \"ATCG\" repeated 25 times. n = 100. Counts are 25 for each.\n        (100, [25, 25, 25, 25]),\n        \n        # Case 2: \"A\" repeated 100 times. n = 100. Counts are 100 for 'A', 0 for others.\n        (100, [100, 0, 0, 0]),\n        \n        # Case 3: n = 40. Counts are O_A=16, O_T=8, O_C=8, O_G=8.\n        (40, [16, 8, 8, 8]),\n        \n        # Case 4: s = \"ATCG\". n = 4. Counts are 1 for each.\n        (4, [1, 1, 1, 1]),\n        \n        # Case 5: n = 40. Counts are O_A=20, O_T=7, O_C=7, O_G=6.\n        (40, [20, 7, 7, 6]),\n    ]\n\n    results = []\n    for n, O in test_cases:\n        # Expected counts under the null hypothesis of a uniform distribution.\n        # E_i = n * (1/k) for all i.\n        E = n / k\n        \n        # Convert observed counts to a NumPy array for vectorized operations.\n        observed_counts = np.array(O)\n        \n        # Calculate Pearson's chi-squared test statistic.\n        # chi2_stat = sum((O_i - E_i)^2 / E_i)\n        # Using a small epsilon to avoid division by zero if E is zero,\n        # although in this problem E is always positive.\n        chi2_stat = np.sum((observed_counts - E)**2 / (E + 1e-9))\n        \n        # Calculate the p-value.\n        # This is the upper-tail probability of the chi-squared distribution\n        # with 'df' degrees of freedom. The survival function (sf) gives P(X > x).\n        p_value = chi2.sf(chi2_stat, df)\n        \n        # Make the decision: reject the null hypothesis if p-value  alpha.\n        # The result must be a native Python boolean (True/False).\n        reject = bool(p_value  alpha)\n        \n        # Store the boolean decision and the p-value.\n        results.append([reject, p_value])\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists: [[reject_1, p_1], [reject_2, p_2], ...]\n    # Using str() on each sublist automatically formats it correctly.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2429686"}, {"introduction": "除了保证正确的输出频率，一个随机序列还必须没有可预测的模式。此练习将向您介绍一种强大的非参数检验方法——游程检验 (runs test)，它专门用于检测序列相关性。您将通过计算中位数之上或之下的连续“游程”数量，来判断一个序列是过于交替还是过于聚集，从而评估其随机性。这项实践将帮助您理解如何检验独立性，这是一个与均匀性同等重要的随机性质。[@problem_id:2429680]", "problem": "你需要编写一个完整、可运行的程序，用于评估一系列有限序列中，值高于和低于中心阈值的游程数量。这些序列由特定的伪随机数生成器（PRNGs, Pseudo-Random Number Generator）生成。目的是判断每个序列所观察到的游程数量，在原假设下是否是异常的。原假设为序列来自连续分布的独立同分布（i.i.d., independent and identically distributed）抽样。该检验应使用二元分类法，将每个值分类为严格高于或严格低于整个序列的样本中位数；在计算游程之前，必须丢弃与中位数完全相等的值。\n\n使用的定义：\n- 给定一个有限实值序列 $\\{x_k\\}_{k=1}^{N}$，令 $m$ 表示其样本中位数。通过设置 $b_k = 1$（若 $x_k  m$）和 $b_k = 0$（若 $x_k  m$）来构建一个二元序列 $\\{b_k\\}$。任何满足 $x_k = m$ 的值必须在计数游程前被移除（包括其位置）。\n- 一个游程是二元序列中连续相同的最大区块。令 $R$ 为最终得到的长度为 $n$ 的二元序列中的总游程数（注意，在丢弃与中位数相等的值后，$n \\le N$）。\n\n原假设与决策：\n- 在原假设（原始序列是来自连续分布的独立同分布样本）下，相对于中位数的符号序列的行为如同连续的 $b_k$ 在类别计数固定的情况下是独立的。决策规则必须是在显著性水平 $\\alpha = 10^{-8}$ 下的双边检验。\n- 如果在丢弃等于中位数的值后，所有剩余值都属于单一类别（即 $n = 0$ 或所有 $b_k$ 都相同），则该情况的决策必须报告为布尔值 `False`（解释为“不拒绝”），因为在这种退化情况下，游程数不提供信息。\n\n测试套件（所有参数均已完全指定；没有用户输入）：\n- 情况 A（长度 $N = 1000$）：交替高/低序列，定义为当 $k$ 为奇数时 $x_k = 0.25$，当 $k$ 为偶数时 $x_k = 0.75$。\n- 情况 B（长度 $N = 1000$）：线性同余生成器（LCG, Linear Congruential Generator），其模数 $m = 2^{31} - 1$，乘数 $a = 16807$，增量 $c = 0$，种子 $x_0 = 1$，输出为 $u_k = x_k / m$，其中 $k = 1,\\dots,N$。\n- 情况 C（长度 $N = 1000$）：具有长持久性的两状态“粘性”生成器。令 $s_1 = 1$。对于 $k \\ge 2$，令 $s_k = s_{k-1}$ 的概率为 $p = 0.95$，令 $s_k = 1 - s_{k-1}$ 的概率为 $1 - p$。通过 $x_k = 0.75 + \\delta_k$ (若 $s_k = 1$) 和 $x_k = 0.25 + \\delta_k$ (若 $s_k = 0$) 将 $s_k$ 映射到实数值，其中 $\\delta_k$ 是在 $[-10^{-12}, 10^{-12}]$ 上独立均匀分布的。此情况下所需的所有随机性必须通过使用与情况 B 中相同的 LCG 来确定性地生成所需的均匀分布变量。\n- 情况 D（长度 $N = 100$）：中位数相等情形。前 $60$ 个值精确为 $x_k = 0.5$。其余 $40$ 个值取自情况 B 中的 LCG 的后 $40$ 个输出 $u_k$（如情况 B 中所述，缩放到 $[0,1)$）。\n- 情况 E（长度 $N = 30$）：单类别退化。所有值均为 $x_k = 0.7$。\n\n程序要求：\n- 对于每种情况，完全按照指定方式构建序列。对于每个序列，使用相对于样本中位数的游程数（如上定义）来计算在双边显著性水平 $\\alpha = 10^{-8}$ 下拒绝或不拒绝原假设的决策。将决策报告为布尔值：`True` 表示“拒绝”，`False` 表示“不拒绝”。如果丢弃值后序列的类别少于两个，则报告 `False`。\n- 最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的布尔值列表（例如，“[True,False,True,False,False]”），顺序固定为情况 A、B、C、D、E。\n\n每个测试用例的答案都是布尔值。此任务不涉及物理单位或角度；除了按指定格式输出所需的单行内容外，不要打印任何其他内容。", "solution": "该问题要求使用游程检验来验证多个序列是否符合随机性的原假设。检验统计量是高于和低于样本中位数的游程数量。对于每个序列，必须在显著性水平 $\\alpha = 10^{-8}$ 下做出拒绝或不拒绝原假设的决策。\n\n首先，我们必须将统计流程形式化。\n\n**问题验证**\n\n步骤 1：提取给定条件\n- **序列生成方法**：\n  - 情况 A：交替序列，$k$为奇数时 $x_k = 0.25$，$k$为偶数时 $x_k = 0.75$，$N=1000$。\n  - 情况 B：线性同余生成器 (LCG)，模数 $m = 2^{31} - 1$，乘数 $a = 16807$，增量 $c = 0$，种子 $x_0 = 1$。序列为 $u_k = x_k/m$，其中 $k=1, \\dots, N$，$N=1000$。\n  - 情况 C：两状态“粘性”生成器。状态 $s_k \\in \\{0, 1\\}$。$s_1=1$。$s_k = s_{k-1}$ 的概率为 $p=0.95$，$s_k=1-s_{k-1}$ 的概率为 $1-p$。输出为 $x_k = 0.75 + \\delta_k$（若 $s_k=1$），$x_k = 0.25 + \\delta_k$（若 $s_k=0$）。$\\delta_k$ 是独立同分布的 $U[-10^{-12}, 10^{-12}]$。随机性来自情况 B 的 LCG。$N=1000$。\n  - 情况 D：中位数相等序列。前 $60$ 个值为 $x_k = 0.5$。后 $40$ 个值来自情况 B 的 LCG。$N=100$。\n  - 情况 E：单类别退化。所有 $x_k = 0.7$，对于 $N=30$。\n- **游程检验定义**：\n  - 阈值为样本中位数 $m$。\n  - 值 $x_k = m$ 被丢弃。剩余序列长度为 $n$。\n  - 形成二元序列：$x_k  m$ 为 $1$，$x_k  m$ 为 $0$。\n  - $R$ 是此二元序列中的游程数。\n- **假设与决策规则**：\n  - 原假设 ($H_0$)：原始序列是来自连续分布的独立同分布样本。\n  - 双边检验的显著性水平为 $\\alpha = 10^{-8}$。\n  - 退化情况规则：如果丢弃相等值后，所有值都在一个类别中（即 $n_0=0$ 或 $n_1=0$）或没有值剩下（$n=0$），则决策为不拒绝 $H_0$（输出 `False`）。\n  - 最终输出是针对情况 A-E 的布尔值列表（`True` 表示拒绝，`False` 表示不拒绝）。\n\n步骤 2：使用提取的给定条件进行验证\n- **科学依据**：该问题基于游程检验，这是一种标准的非参数随机性统计检验。指定的 LCG 是著名的 Park-Miller 生成器。所有概念都来自成熟的统计学和计算科学。\n- **问题定义良好**：每个情况都已完全指定。统计检验，包括对相等值和退化情况的处理，都有明确定义。决策规则毫不含糊。每个情况都有唯一且有意义的解。\n- **客观性**：问题陈述不含主观性语言。所有参数和过程都已量化定义。\n\n步骤 3：结论与行动\n该问题是有效的。这是一个定义明确的计算统计学问题，指令清晰，原理科学。我将继续进行解答。\n\n**方法论与分步解答**\n\n解决方案的核心是实现游程检验。对于一个长度为 $N$ 的序列 $\\{x_k\\}$：\n1.  计算样本中位数 $m$。\n2.  筛选序列，只保留不等于 $m$ 的值。设新序列长度为 $n$。\n3.  令 $n_1$ 为大于 $m$ 的值的数量，$n_0$ 为小于 $m$ 的值的数量。因此，$n = n_0 + n_1$。\n4.  根据问题的明确规则，如果 $n_0=0$ 或 $n_1=0$，则检验无定论，我们不拒绝 $H_0$。结果为 `False`。\n5.  否则，我们继续。计算分类为高于或低于中位数的数值序列中的游程数 $R$。\n6.  在原假设 $H_0$ 下，对于大的 $n_0$和 $n_1$，$R$的分布近似于正态分布，其均值 $\\mu_R$ 和方差 $\\sigma_R^2$ 如下：\n    $$ \\mu_R = \\frac{2 n_0 n_1}{n} + 1 $$\n    $$ \\sigma_R^2 = \\frac{2 n_0 n_1 (2 n_0 n_1 - n)}{(n)^2 (n - 1)} $$\n7.  计算标准化检验统计量 $Z$：\n    $$ Z = \\frac{R - \\mu_R}{\\sigma_R} $$\n8.  对于在显著性水平 $\\alpha = 10^{-8}$ 下的双边检验，我们从标准正态分布中找到临界值 $Z_{\\alpha/2}$。$P(|Z|  Z_{\\alpha/2}) = \\alpha$。临界值对应于 $(1 - \\alpha/2)$ 分位数。对于 $\\alpha = 10^{-8}$，这是 $(1 - 5 \\times 10^{-9})$ 分位数，即 $Z_{crit} \\approx 5.7309$。\n9.  决策规则是如果 $|Z|  Z_{crit}$ 则拒绝 $H_0$。这对应于决策 `True`。否则，我们不拒绝 $H_0$，得到决策 `False`。\n\n**测试用例分析：**\n\n- **情况 A (交替序列)**：交替序列 $\\{0.25, 0.75, 0.25, \\dots\\}$ 长度 $N=1000$，中位数为 $m=0.5$。没有相等值。我们有 $n=1000$，其中 $n_0=500$ 个值低于中位数，$n_1=500$ 个值高于中位数。二元序列为 $\\{0, 1, 0, 1, \\dots\\}$。游程数为 $R=1000$。\n  预期的游程数为 $\\mu_R = \\frac{2(500)(500)}{1000} + 1 = 501$。方差为 $\\sigma_R^2 = \\frac{2(500)(500)(2(500)(500)-1000)}{1000^2(999)} \\approx 249.75$。标准差为 $\\sigma_R \\approx 15.80$。\n  $Z$分数为 $Z = (1000 - 501) / 15.80 \\approx 31.58$。因为 $|31.58|  5.7309$，我们拒绝 $H_0$。结果：`True`。\n\n- **情况 B (LCG)**：一个来自良好伪随机数生成器的 $N=1000$ 的值序列应该看起来是随机的。找到中位数后，我们将得到 $n=1000$，$n_0=500$，$n_1=500$。游程数 $R$ 预计将接近 $\\mu_R = 501$。最终的 $Z$分数会很小，所以我们不拒绝 $H_0$。结果：`False`。\n\n- **情况 C (粘性生成器)**：该生成器被设计为具有强的正序列相关性。对于 $N=1000$，状态预计仅翻转约 $(1-0.95) \\times (N-1) \\approx 50$ 次。这将导致游程数非常小，$R \\approx 50$。假设状态大致均等占据，预期的游程数仍为 $\\mu_R \\approx 501$。观察到的 $R$ 远非预期值，导致一个大的负 $Z$分数，例如 $Z \\approx (50 - 501)/15.80 \\approx -28.5$。我们拒绝 $H_0$。结果：`True`。\n\n- **情况 D (中位数相等)**：长度为 $N=100$ 的序列有 $60$ 个值是 $0.5$，$40$ 个值来自 LCG。中位数为 $m=0.5$。这 $60$ 个相等值被丢弃，剩下 $n=40$ 个随机值。检验是针对这些值相对于原始中位数 $0.5$ 进行的。由于 LCG 值在 $[0,1)$ 上均匀分布，我们预计 $n_0 \\approx 20$，$n_1 \\approx 20$。这个较短的随机序列中的游程数 $R$ 应该接近其预期值，例如 $\\mu_R = \\frac{2(20)(20)}{40} + 1 = 21$。$Z$分数会很小。我们不拒绝 $H_0$。结果：`False`。\n\n- **情况 E (退化情况)**：所有 $N=30$ 的值都是 $0.7$。中位数为 $m=0.7$。所有值都被丢弃。剩余序列长度为 $n=0$。这是问题中定义的退化情况（$n_0=0, n_1=0$）。我们不拒绝 $H_0$。结果：`False`。\n\n实现将为每个情况精确地遵循此逻辑。情况 B、C 和 D 所需的 LCG 将为每个情况重新初始化，以确保确定性和独立的测试条件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    \n    # --- Helper functions ---\n\n    def lcg_generator(n_values, seed=1):\n        \"\"\"Generates a sequence of n_values from a LCG.\"\"\"\n        m = 2**31 - 1\n        a = 16807\n        \n        # Use Python's arbitrary-precision integers for calculations\n        x = seed\n        results = np.zeros(n_values)\n        for i in range(n_values):\n            x = (a * x) % m\n            results[i] = x / m\n        return results\n\n    def runs_test(x, alpha=1e-8):\n        \"\"\"\n        Performs the runs test for randomness on a sequence x.\n        Returns True (1) to reject H0, False (0) to not reject.\n        \"\"\"\n        if len(x) == 0:\n            return False\n\n        median = np.median(x)\n        \n        # Filter out elements equal to the median\n        filtered_x = x[x != median]\n        \n        n = len(filtered_x)\n        if n == 0:\n            return False\n            \n        # Create binary sequence\n        binary_seq = (filtered_x  median).astype(int)\n        \n        n1 = np.sum(binary_seq)\n        n0 = n - n1\n        \n        # Degenerate case rule from problem statement\n        if n0 == 0 or n1 == 0:\n            return False\n\n        # Count runs\n        # A run starts at the beginning, and every time the value changes.\n        runs = 1 + np.sum(np.diff(binary_seq) != 0)\n        \n        # Large sample approximation for runs test\n        mu_r = (2 * n0 * n1) / n + 1\n        \n        # Denominator term to check for n=1 case (already covered by n0/n1 check)\n        denom_var = (n**2) * (n - 1)\n        if denom_var == 0:\n            # This case is avoided by the n0=0 or n1=0 check, but as a safeguard:\n            return False\n            \n        sigma_sq_r = (2 * n0 * n1 * (2 * n0 * n1 - n)) / denom_var\n        \n        if sigma_sq_r = 0:\n            # If R is deterministic, variance is 0. Cannot form Z-stat. Do not reject.\n            return False\n            \n        sigma_r = np.sqrt(sigma_sq_r)\n        \n        # Z-statistic\n        z_score = (runs - mu_r) / sigma_r\n        \n        # Two-sided critical value\n        z_crit = norm.ppf(1 - alpha / 2)\n        \n        # Decision: reject if |Z|  Z_crit\n        return abs(z_score)  z_crit\n\n    # --- Test Case Generators ---\n\n    def generate_case_a():\n        n = 1000\n        x = np.zeros(n)\n        x[::2] = 0.25  # Odd k (indices 0, 2, ...)\n        x[1::2] = 0.75 # Even k (indices 1, 3, ...)\n        return x\n\n    def generate_case_b():\n        n = 1000\n        return lcg_generator(n_values=n, seed=1)\n\n    def generate_case_c():\n        n = 1000\n        p_stay = 0.95\n        \n        # Use a fresh LCG instance for deterministic randomness\n        # We need N-1 values for transitions and N values for noise\n        rand_stream = lcg_generator(n_values=2 * n - 1, seed=1)\n        \n        transition_rands = rand_stream[:n - 1]\n        noise_rands = rand_stream[n - 1:]\n\n        states = np.zeros(n, dtype=int)\n        states[0] = 1\n        for i in range(1, n):\n            if transition_rands[i-1]  (1 - p_stay):\n                states[i] = 1 - states[i-1]\n            else:\n                states[i] = states[i-1]\n        \n        # Generate noise term delta in [-1e-12, 1e-12]\n        deltas = (2 * noise_rands - 1) * 1e-12\n        \n        x = np.zeros(n)\n        x[states == 1] = 0.75 + deltas[states == 1]\n        x[states == 0] = 0.25 + deltas[states == 0]\n        \n        return x\n\n    def generate_case_d():\n        n_ties = 60\n        n_lcg = 40\n        \n        ties = np.full(n_ties, 0.5)\n        lcg_vals = lcg_generator(n_values=n_lcg, seed=1)\n        \n        return np.concatenate((ties, lcg_vals))\n\n    def generate_case_e():\n        n = 30\n        return np.full(n, 0.7)\n\n    # --- Main Logic ---\n\n    test_cases = {\n        'A': generate_case_a,\n        'B': generate_case_b,\n        'C': generate_case_c,\n        'D': generate_case_d,\n        'E': generate_case_e,\n    }\n    \n    results = []\n    # Process cases in the required order A, B, C, D, E\n    for case_id in sorted(test_cases.keys()):\n        generator_func = test_cases[case_id]\n        sequence = generator_func()\n        decision = runs_test(sequence)\n        results.append(decision)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2429680"}, {"introduction": "一个在数学上被证明是“完美随机”的数字，能否成为一个糟糕的伪随机数来源？这项练习将通过一个引人入胜的例子来探讨这个悖论。您将使用 Champernowne 常数 ($C_{10}$) 作为数字来源——这是一个著名的正规数 (normal number)，其中任何数字块的长期出现频率都符合期望——并对其有限序列应用您所学的统计检验。这项实践将揭示数论中的“正态性”与统计学中的“随机性”之间的深刻区别，并展示即使是理论上完美的来源，其在实际应用中也可能因其确定性结构而表现出非随机性。[@problem_id:2429698]", "problem": "您的任务是设计和评估一个用于数字序列的确定性伪随机数生成器（PRNG）。该生成器基于一个以10为底的超越正规数：以10为底的钱珀瑙恩常数（Champernowne constant），记作 $C_{10}$。它通过按顺序连接正整数的十进制表示来定义，即 $C_{10} = 0.123456789101112\\ldots$。目标是实现一个程序，从该源生成数字，并应用标准的随机性统计检验，以评估在固定的显著性水平下，哪些检验通过或失败。您的实现必须是一个完整的、可运行的程序，无需任何用户输入即可产生指定的输出。\n\n请使用以下基本依据：\n- 源自数学定义常数的确定性数字流是可计算和可复现的。\n- 一个数在基$b$下是正规的，如果对于任何固定长度的数字块，其出现频率的极限值为$b^{-k}$。正规性意味着数字块的渐近均匀性，但在任何有限前缀中并不意味着独立性。\n- 对于独立同分布（i.i.d.）的以10为底的数字，高质量的伪随机性需要同时具备均匀的边际分布和跨位置的近似独立性，这可以通过经典的假设检验来探测。\n\n按如下方式构建PRNG：\n- 实现一个生成器，该生成器在跳过给定的起始索引 $s \\ge 0$ 后，生成 $C_{10}$ 的前 $N$ 个以10为底的数字。具体来说，连接正整数的字符串，然后从数字索引 $s$ 处（小数点后的第一位数字索引为 $s=0$）提取长度为 $N$ 的子序列。将这些字符转换为 $\\{0,1,\\ldots,9\\}$ 中的整数。\n\n对生成的数字流 $\\{X_i\\}_{i=1}^N$（其中 $X_i \\in \\{0,1,\\ldots,9\\}$）应用以下检验：\n- 卡方均匀性检验 (以10为底)：检验每个数字出现概率为 $1/10$ 的原假设。计算卡方统计量，该统计量比较了每个数字的观测计数与10个类别中每个类别的期望计数 $N/10$，然后使用具有 $9$ 个自由度的卡方分布获得 $p$ 值。\n- 序列对卡方检验：构建 $(N-1)$ 个重叠的相邻对 $(X_i, X_{i+1})$，将它们映射到 $\\{00,01,\\ldots,99\\}$ 中的100个类别，并检验所有有序对出现概率为 $1/100$ 的原假设。计算卡方统计量，该统计量与100个类别中每个类别的期望计数 $(N-1)/100$ 进行比较，并使用具有 $99$ 个自由度的卡方分布获得 $p$ 值。\n- 固定目标数字的几何间距检验：固定目标数字 $d=0$，并记录间距长度 $G$，定义为连续出现的 $0$ 之间的非零数字的数量。在原假设下，即数字是独立同分布（i.i.d.）且 $\\mathbb{P}(X=0) = 1/10$， G 的分布是参数为 $p=1/10$ 的几何分布，即 $\\mathbb{P}(G=g) = (1-p)^g p$ 对 $g \\in \\{0,1,2,\\ldots\\}$ 成立。构建一个分类卡方检验，类别为 $g=0,1,\\ldots,g_{\\max}-1$ 以及一个尾部类别 $g \\ge g_{\\max}$，使用精确的几何概率和总共 $(\\text{观测到的间距数})$ 次试验。使用 $g_{\\max}=10$，这将产生 $11$ 个类别和 $10$ 个自由度。\n\n对于所有检验，使用相同的显著性水平 $\\alpha = 0.01$。如果检验的 $p$ 值大于或等于 $\\alpha$，则报告检验为“通过”（pass），否则报告为“失败”（fail）。\n\n测试套件和所需参数：\n- 对于 $(N, s, g_{\\max}, \\alpha)$，请精确使用以下三组参数：\n    - 情况 1：$N=200000$, $s=0$, $g_{\\max}=10$, $\\alpha=0.01$。\n    - 情况 2：$N=200000$, $s=9$, $g_{\\max}=10$, $\\alpha=0.01$。\n    - 情况 3：$N=50000$, $s=0$, $g_{\\max}=10$, $\\alpha=0.01$。\n这些情况涵盖了一个通用的大样本情况、一个边界移位的大样本情况（紧接在两位数区块开始之前开始），以及一个较小样本的边缘情况。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。对于每种情况，按顺序附加以下 $6$ 个值：\n    - 均匀性检验的 $p$ 值（浮点数），\n    - 均匀性检验的通过/失败（布尔值），\n    - 序列对检验的 $p$ 值（浮点数），\n    - 序列对检验的通过/失败（布尔值），\n    - 间距检验的 $p$ 值（浮点数），\n    - 间距检验的通过/失败（布尔值）。\n因此，最后一行必须包含对应于三种情况的 $18$ 个条目，例如：\n\"[p1,True,p2,False,p3,True,p4,True,p5,True,p6,False,p7,True,p8,True,p9,True]\"。\n所有数值量都必须以小数形式打印，不带百分号。此问题不涉及物理单位或角度。\n\n您的程序必须完全自包含、确定性、无需用户输入，并符合指定的执行环境。输出必须仅为指定的单行。", "solution": "所述问题已经过严格验证，被认为是科学上合理、定义明确、客观且计算上可行的。从钱珀瑙恩常数 $C_{10}$ 生成数字序列以及后续统计分析所需的所有必要参数和定义均已提供。该问题是计算统计学和数论方面的一个有效练习。因此，我们可以着手提供完整的解决方案。\n\n目标是设计一个伪随机数生成器（PRNG），其数字源自钱珀瑙恩常数 $C_{10}$，并使用一套标准的统计检验来评估其质量。我们将首先描述生成数字流的方法，然后详细说明用于评估的统计检验。\n\n**1. 数字流的生成**\n\n随机性来源是以10为底的钱珀瑙恩常数 $C_{10}$，它通过按顺序连接正整数的十进制表示来构造：\n$$\nC_{10} = 0.123456789101112131415161718192021\\ldots\n$$\n已知这个数是超越数，更重要的是，对于本应用而言，它在以10为底时是正规数。在基$b$下的正规性意味着任何长度为$k$的数字块出现的极限频率为$b^{-k}$，这对于随机序列来说是一个理想的渐近性质。然而，该序列的有限前缀是高度结构化和非随机的，统计检验预计将揭示这一事实。\n\n生成算法如下：\n- 为了获得从零基索引 $s$ 开始的长度为 $N$ 的数字序列，我们必须首先生成一个足够长的 $C_{10}$ 小数部分的字符串表示。\n- 我们通过迭代连接整数 $k=1, 2, 3, \\ldots$ 的字符串形式来实现这一点，直到所得字符串的总长度至少为 $s+N$。\n- 然后，从索引 $s$ 开始提取长度为 $N$ 的子字符串，作为所需的数字序列。\n- 最后，将该子字符串中的每个字符转换为集合 $\\{0, 1, \\ldots, 9\\}$ 中对应的整数值，得到用于检验的序列 $\\{X_i\\}_{i=1}^N$。\n\n**2. 随机性统计检验**\n\n我们对生成的序列 $\\{X_i\\}_{i=1}^N$ 应用三个标准的假设检验。对于所有检验，显著性水平固定为 $\\alpha = 0.01$。如果计算出的 $p$ 值大于或等于 $\\alpha$，则检验被视为“通过”（passed），否则为“失败”（failed）。\n\n**2.1. 卡方均匀性检验**\n该检验也称为拟合优度检验，用于评估序列中的数字是否均匀分布。\n- **原假设 ($H_0$)**: 每个数字 $d \\in \\{0, 1, \\ldots, 9\\}$ 出现的概率相等，即 $\\mathbb{P}(X_i = d) = 1/10$。\n- **检验统计量**: Pearson卡方统计量计算如下：\n$$\n\\chi^2 = \\sum_{d=0}^{9} \\frac{(O_d - E_d)^2}{E_d}\n$$\n其中 $O_d$ 是序列中数字 $d$ 的观测计数，长度为 $N$；$E_d = N/10$ 是在 $H_0$ 下每个数字的期望计数。\n- **分布**: 在原假设下，该统计量服从具有 $k-1 = 10-1 = 9$ 个自由度的卡方分布。$p$ 值是观测到至少与计算出的统计量一样极端的统计量的概率，即 $p = \\mathbb{P}(\\chi^2_9 \\ge \\chi^2_{\\text{obs}})$。\n\n**2.2. 序列对卡方检验**\n该检验通过检查对的分布来检验相邻数字之间的独立性。\n- **原假设 ($H_0$)**: 所有 $100$ 种可能的有序数字对 $(d_1, d_2)$ 均匀分布，即 $\\mathbb{P}((X_i, X_{i+1}) = (d_1, d_2)) = 1/100$。\n- **检验过程**: 我们从序列中形成 $N-1$ 个重叠对 $(X_1, X_2), (X_2, X_3), \\ldots, (X_{N-1}, X_N)$。这些对被映射到 $100$ 个类别（例如，通过映射 $(d_1, d_2) \\to 10d_1 + d_2$ 从 $0$ 映射到 $99$）。\n- **检验统计量**: 卡方统计量是基于这 $100$ 个类别计算的：\n$$\n\\chi^2 = \\sum_{j=0}^{99} \\frac{(O_j - E_j)^2}{E_j}\n$$\n其中 $O_j$ 是第 $j$ 个对的观测计数，$E_j = (N-1)/100$ 是期望计数。\n- **分布**: 在 $H_0$ 下，该统计量服从具有 $k-1 = 100-1 = 99$ 个自由度的卡方分布。$p$ 值也相应计算。\n\n**2.3. 几何间距检验**\n该检验研究不等于特定目标数字的数字构成的游程长度。我们使用目标数字 $d=0$。\n- **原假设 ($H_0$)**: 数字是独立同分布（i.i.d.）的，且 $\\mathbb{P}(X_i=0) = p = 1/10$。这意味着“间距”（连续两个零之间的非零数字个数）的长度 $G$ 服从几何分布：$\\mathbb{P}(G=g) = (1-p)^g p$ 对于 $g \\in \\{0, 1, 2, \\ldots\\}$。\n- **检验过程**: 我们识别出所有连续出现的数字 $0$，并测量它们之间的非零数字个数。这些观测到的间距长度被分到 $g_{\\max}+1$ 个箱中：$g=0, 1, \\ldots, g_{\\max}-1$，以及一个用于所有长度为 $g \\ge g_{\\max}$ 的间距的最终箱。对于此问题，$g_{\\max} = 10$，得到 $11$ 个类别。\n- **检验统计量**: 令 $M$ 为观测到的总间距数。一个间距长度为 $g$ 的期望概率是 $P_g = (0.9)^g(0.1)$，对于尾部类别（$g \\ge 10$）的期望概率是 $P_{\\ge 10} = \\sum_{j=10}^{\\infty} (0.9)^j(0.1) = (0.9)^{10}$。每个类别的期望计数是 $E_g = M \\cdot P_g$。卡方统计量为：\n$$\n\\chi^2 = \\sum_{g=0}^{10} \\frac{(O_g - E_g)^2}{E_g}\n$$\n其中 $O_g$ 是每个类别的观测计数。\n- **分布**: 由于参数 $p=1/10$ 是由假设指定的，而不是从数据中估计的，所以该统计量服从具有 $k-1 = 11-1 = 10$ 个自由度的卡方分布。\n\n实现过程将首先为三种测试情况中的每一种生成所需的数字序列，然后应用三种统计检验中的每一种，最后将结果整理成指定的输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef generate_c10_digits(N, s):\n    \"\"\"\n    Generates N digits of the Champernowne constant C_10 starting from index s.\n    \"\"\"\n    required_length = s + N\n    c10_parts = []\n    current_length = 0\n    i = 1\n    while current_length  required_length:\n        s_i = str(i)\n        c10_parts.append(s_i)\n        current_length += len(s_i)\n        i += 1\n    \n    c10_string = \"\".join(c10_parts)\n    digit_string = c10_string[s:s + N]\n    \n    return np.array([int(d) for d in digit_string], dtype=np.int64)\n\ndef uniformity_test(digits, alpha):\n    \"\"\"\n    Performs a chi-squared test for uniform distribution of base-10 digits.\n    \"\"\"\n    N = len(digits)\n    if N == 0:\n        return 1.0, True # Undefined test, pass by convention\n        \n    observed_counts = np.bincount(digits, minlength=10)\n    expected_count = N / 10.0\n    \n    # Avoid division by zero if N=0 (handled above), but good practice\n    if expected_count == 0:\n        return 1.0, True\n\n    chi2_stat = np.sum((observed_counts - expected_count)**2 / expected_count)\n    df = 9\n    p_value = chi2.sf(chi2_stat, df)\n    \n    return p_value, p_value = alpha\n\ndef serial_pair_test(digits, alpha):\n    \"\"\"\n    Performs a chi-squared test for uniform distribution of adjacent pairs.\n    \"\"\"\n    N = len(digits)\n    if N  2:\n        return 1.0, True # Undefined test\n        \n    pairs = digits[:-1] * 10 + digits[1:]\n    num_pairs = N - 1\n    \n    observed_counts = np.bincount(pairs, minlength=100)\n    expected_count = num_pairs / 100.0\n\n    if expected_count == 0:\n        return 1.0, True\n        \n    chi2_stat = np.sum((observed_counts - expected_count)**2 / expected_count)\n    df = 99\n    p_value = chi2.sf(chi2_stat, df)\n    \n    return p_value, p_value = alpha\n\ndef geometric_gap_test(digits, alpha, g_max):\n    \"\"\"\n    Performs a chi-squared test for the geometric distribution of gaps between zeros.\n    \"\"\"\n    target_digit = 0\n    zero_indices = np.where(digits == target_digit)[0]\n    \n    if len(zero_indices)  2:\n        return 1.0, True # Undefined test, not enough gaps\n        \n    gaps = np.diff(zero_indices) - 1\n    num_gaps = len(gaps)\n\n    # Bin observed gaps into categories 0, 1, ..., g_max-1 and =g_max\n    observed_counts = np.zeros(g_max + 1, dtype=np.int64)\n    binned_gaps = np.bincount(gaps)\n    len_binned = len(binned_gaps)\n    \n    limit = min(g_max, len_binned)\n    observed_counts[:limit] = binned_gaps[:limit]\n    if len_binned  g_max:\n        observed_counts[g_max] = np.sum(binned_gaps[g_max:])\n\n    # Calculate expected counts based on geometric distribution\n    p = 0.1  # Probability of target digit\n    q = 1.0 - p\n    \n    expected_probs = np.zeros(g_max + 1)\n    for g in range(g_max):\n        expected_probs[g] = (q**g) * p\n    expected_probs[g_max] = q**g_max # P(G = g_max)\n    \n    expected_counts = expected_probs * num_gaps\n    \n    # Filter out categories with zero expected counts to avoid division by zero\n    # This shouldn't happen with geometric distribution but is robust practice\n    valid_indices = expected_counts  0\n    if np.sum(valid_indices)  2: # Not enough categories for a meaningful test\n         return 1.0, True\n         \n    chi2_stat = np.sum((observed_counts[valid_indices] - expected_counts[valid_indices])**2 / expected_counts[valid_indices])\n    \n    df = g_max  # k-1 = (g_max+1) - 1\n    p_value = chi2.sf(chi2_stat, df)\n    \n    return p_value, p_value = alpha\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (N, s, g_max, alpha)\n        (200000, 0, 10, 0.01),\n        (200000, 9, 10, 0.01),\n        (50000, 0, 10, 0.01),\n    ]\n\n    results = []\n    for N, s, g_max, alpha in test_cases:\n        digits = generate_c10_digits(N, s)\n        \n        # Uniformity Test\n        p_uniform, pass_uniform = uniformity_test(digits, alpha)\n        results.extend([p_uniform, pass_uniform])\n        \n        # Serial Pair Test\n        p_serial, pass_serial = serial_pair_test(digits, alpha)\n        results.extend([p_serial, pass_serial])\n        \n        # Geometric Gap Test\n        p_gap, pass_gap = geometric_gap_test(digits, alpha, g_max)\n        results.extend([p_gap, pass_gap])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2429698"}]}