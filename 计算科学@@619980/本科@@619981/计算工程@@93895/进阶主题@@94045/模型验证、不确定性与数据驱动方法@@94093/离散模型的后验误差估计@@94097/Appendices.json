{"hands_on_practices": [{"introduction": "第一个实践将引导您了解基于残差的后验误差估计器的基本机制。通过处理一个在非常粗糙网格上的简单泊松问题，您将显式地计算单元残差和通量跳跃——这些是估计器的核心组成部分。这个练习为您提供了一个坚实的具体基础，以便在我们将这些误差指标用于更复杂的自动化算法之前，理解它们是如何产生的 [@problem_id:2370198]。", "problem": "考虑单位正方形域 $\\Omega = [0,1]^{2}$ 上的标量扩散模型问题（一个泊松型偏微分方程（PDE）），其边界条件为齐次狄利克雷边界条件：\n求 $u \\in H_{0}^{1}(\\Omega)$ 使得\n在 $\\Omega$ 中，$\\,-\\Delta u = f \\,$，且在 $\\partial \\Omega$ 上，$\\,u = 0\\,$，\n其中对于所有 $(x,y) \\in \\Omega$，$f(x,y) = 1$。设 $u_{h} \\in V_{h} \\subset H_{0}^{1}(\\Omega)$ 是在三角剖分 $\\mathcal{T}_{h}$ 上的协调有限元法（FEM）逼近，该三角剖分是通过从 $(0,0)$ 到 $(1,1)$ 的对角线将单位正方形分割成 $2$ 个全等直角三角形得到的，其中 $V_{h}$ 由从属于 $\\mathcal{T}_{h}$ 的连续分片线性（$P_{1}$）函数组成。\n\n从弱形式以及单元强残差和内部边通量跳跃的定义出发，构造一个显式基于残差的后验误差估计子 $\\eta$，该估计子针对梯度误差范数 $\\|\\nabla(u - u_{h})\\|_{L^{2}(\\Omega)}$，并用单元残差和内部边通量跳跃来表示。然后，在此网格和数据上评估你所构造的估计子 $\\eta$。将最终的估计子值 $\\eta$ 表示为一个精确的实数。不要四舍五入。", "solution": "对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- **偏微分方程 (PDE)**：在 $\\Omega$ 中 $-\\Delta u = f$。\n- **域**：$\\Omega = [0,1]^{2}$。\n- **边界条件**：在 $\\partial \\Omega$ 上 $u = 0$（齐次狄利克雷）。\n- **源项**：对所有 $(x,y) \\in \\Omega$，$f(x,y) = 1$。\n- **精确解空间**：$u \\in H_{0}^{1}(\\Omega)$。\n- **有限元逼近**：$u_{h} \\in V_{h} \\subset H_{0}^{1}(\\Omega)$，其中 $V_h$ 由连续分片线性（$P_1$）函数组成。\n- **网格**：三角剖分 $\\mathcal{T}_{h}$ 是通过从 $(0,0)$ 到 $(1,1)$ 的对角线将单位正方形分割成 $2$ 个全等直角三角形形成的。\n- **任务**：为梯度误差范数 $\\|\\nabla(u - u_{h})\\|_{L^{2}(\\Omega)}$ 构造并评估一个显式基于残差的后验误差估计子 $\\eta$。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题是有限元法后验误差估计的一个标准应用，这是计算工程和偏微分方程数值分析中一个成熟的课题。它在根本上是合理的。\n- **适定性**：在凸域上的带有齐次狄利克雷条件的泊松问题是适定的。为一个给定的简单网格和数据构造并评估一个特定的误差估计子的任务定义清晰，并会导出一个唯一的解。\n- **客观性**：问题使用精确的数学术语陈述，没有歧义或主观论断。\n- **完备性与一致性**：所有必要组成部分——偏微分方程、域、边界条件、源项、网格和有限元空间——都已完全指定且相互一致。\n\n**步骤 3：结论与行动**\n问题是有效的。将构造一个解。\n\n目标是为能量范数中的误差 $e = u - u_h$ 构造并评估一个基于残差的后验误差估计子，对于此问题，该能量范数为 $\\|\\nabla e\\|_{L^2(\\Omega)}$。\n\n该问题的弱形式是求 $u \\in H_0^1(\\Omega)$ 使得\n$$a(u, v) = L(v) \\quad \\forall v \\in H_0^1(\\Omega)$$\n其中双线性形式为 $a(w,v) = \\int_\\Omega \\nabla w \\cdot \\nabla v \\, d\\mathbf{x}$，线性形式为 $L(v) = \\int_\\Omega f v \\, d\\mathbf{x}$。相应的有限元问题是求 $u_h \\in V_h$ 使得\n$$a(u_h, v_h) = L(v_h) \\quad \\forall v_h \\in V_h$$\n将这两个方程相减，得到误差 $e = u - u_h$ 的伽辽金正交性：\n$$a(e, v_h) = 0 \\quad \\forall v_h \\in V_h$$\n误差的能量范数平方为 $a(e,e)$。我们有 $a(e,e) = a(u,e) - a(u_h,e) = L(e) - a(u_h,e)$。\n在每个单元 $K \\in \\mathcal{T}_h$ 上进行分部积分：\n$$a(u_h, e) = \\sum_{K \\in \\mathcal{T}_h} \\int_K \\nabla u_h \\cdot \\nabla e \\, d\\mathbf{x} = \\sum_{K \\in \\mathcal{T}_h} \\left( -\\int_K (\\Delta u_h) e \\, d\\mathbf{x} + \\int_{\\partial K} (\\nabla u_h \\cdot n_K) e \\, ds \\right)$$\n其中 $n_K$ 是单元 $K$ 边界 $\\partial K$ 的单位外法向量。\n因此，误差方程变为：\n$$\\|\\nabla e\\|_{L^2(\\Omega)}^2 = a(e,e) = \\sum_{K \\in \\mathcal{T}_h} \\int_K (f + \\Delta u_h) e \\, d\\mathbf{x} - \\sum_{K \\in \\mathcal{T}_h} \\int_{\\partial K} (\\nabla u_h \\cdot n_K) e \\, ds$$\n边界积分的和可以分解为来自内部边 $\\mathcal{E}_I$ 和边界边 $\\mathcal{E}_\\partial$ 的贡献。由于 $e \\in H_0^1(\\Omega)$，在 $\\partial\\Omega$ 上 $e=0$，因此在 $\\mathcal{E}_\\partial$ 上的积分为零。对于由单元 $K_1$ 和 $K_2$ 共享的内部边 $E$，其贡献为 $\\int_E ((\\nabla u_h|_{K_1} \\cdot n_1) + (\\nabla u_h|_{K_2} \\cdot n_2)) e \\, ds$。我们将穿过 $E$ 的通量跳跃定义为 $J_E = [\\nabla u_h \\cdot n] = \\nabla u_h|_{K_1} \\cdot n_1 + \\nabla u_h|_{K_2} \\cdot n_2$。单元残差为 $R_K = f + \\Delta u_h$。\n于是误差方程为\n$$\\|\\nabla e\\|_{L^2(\\Omega)}^2 = \\sum_{K \\in \\mathcal{T}_h} \\int_K R_K e \\, d\\mathbf{x} + \\sum_{E \\in \\mathcal{E}_I} \\int_E J_E e \\, ds$$\n为了方便最终的求和，我们重新标记了跳跃的方向。\n通过应用柯西-施瓦茨不等式和插值估计，可以证明可靠性估计 $\\|\\nabla e\\|_{L^2(\\Omega)} \\leq C \\eta$，其中 $\\eta$ 是误差估计子。一个标准的显式基于残差的后验误差估计子由这些残差项构造。我们通过其平方来定义总估计子 $\\eta$：\n$$\\eta^2 = \\sum_{K \\in \\mathcal{T}_h} \\eta_K^2 = \\sum_{K \\in \\mathcal{T}_h} \\left( h_K^2 \\|R_K\\|_{L^2(K)}^2 + \\frac{1}{2} \\sum_{E \\in \\partial K \\cap \\mathcal{E}_I} h_E \\|J_E\\|_{L^2(E)}^2 \\right)$$\n这里 $h_K$ 是单元 $K$ 的直径，$h_E$ 是边 $E$ 的长度。由于 $u_h$ 是分片线性的，对于所有 $K \\in \\mathcal{T}_h$，单元上的拉普拉斯算子 $\\Delta u_h = 0$。源项是 $f=1$。因此，单元残差为 $R_K = 1$。估计子简化为：\n$$\\eta^2 = \\sum_{K \\in \\mathcal{T}_h} \\left( h_K^2 \\|1\\|_{L^2(K)}^2 + \\frac{1}{2} \\sum_{E \\in \\partial K \\cap \\mathcal{E}_I} h_E \\|J_E\\|_{L^2(E)}^2 \\right)$$\n\n现在，我们针对给定的问题评估此估计子。\n域 $\\Omega = [0,1]^2$ 被划分为两个三角形：\n- $K_1$：顶点为 $(0,0), (1,0), (1,1)$。\n- $K_2$：顶点为 $(0,0), (0,1), (1,1)$。\n内部边集合 $\\mathcal{E}_I$ 包含一条沿从 $(0,0)$ 到 $(1,1)$ 的对角线的边 $E_{12}$。\n\n有限元空间 $V_h$ 由连续分片线性函数组成。网格的节点是正方形的四个角：$(0,0)$, $(1,0)$, $(0,1)$ 和 $(1,1)$。所有这些节点都位于边界 $\\partial \\Omega$ 上。由于在 $\\partial\\Omega$ 上的齐次狄利克雷条件 $u=0$，离散解 $u_h$ 在所有这些节点上必须为零。三角形上的线性函数由其在三个顶点处的值唯一确定。由于 $u_h$ 在 $K_1$ 和 $K_2$ 的所有顶点上都为零，因此对于所有 $\\mathbf{x} \\in \\Omega$，$u_h(\\mathbf{x}) = 0$。\n因此，梯度也为零：对于所有 $\\mathbf{x} \\in \\Omega$，$\\nabla u_h(\\mathbf{x}) = \\mathbf{0}$。\n\n当 $u_h \\equiv 0$ 时，穿过任何内部边的通量跳跃为零：\n$$J_E = [\\nabla u_h \\cdot n] = [\\mathbf{0} \\cdot n] = 0$$\n因此，估计子中的第二项消失。估计子简化为单元残差项的和：\n$$\\eta^2 = \\sum_{K \\in \\mathcal{T}_h} h_K^2 \\|1\\|_{L^2(K)}^2$$\n\n我们计算每个单元的组成部分。\n对于单元 $K_1$：\n- 顶点为 $(0,0), (1,0), (1,1)$。边长为 $1$, $1$ 和 $\\sqrt{(1-0)^2 + (1-0)^2} = \\sqrt{2}$。\n- 单元直径是最长边的长度，所以 $h_{K_1} = \\sqrt{2}$。\n- $K_1$ 的面积是 $\\frac{1}{2} \\times 1 \\times 1 = \\frac{1}{2}$。\n- 残差的 $L^2$-范数平方为 $\\|1\\|_{L^2(K_1)}^2 = \\int_{K_1} 1^2 \\, d\\mathbf{x} = \\text{Area}(K_1) = \\frac{1}{2}$。\n- 来自 $K_1$ 的贡献为 $\\eta_{K_1}^2 = h_{K_1}^2 \\|1\\|_{L^2(K_1)}^2 = (\\sqrt{2})^2 \\times \\frac{1}{2} = 2 \\times \\frac{1}{2} = 1$。\n\n对于单元 $K_2$：\n- 顶点为 $(0,0), (0,1), (1,1)$。边长也为 $1$, $1$ 和 $\\sqrt{2}$。\n- 单元直径为 $h_{K_2} = \\sqrt{2}$。\n- $K_2$ 的面积是 $\\frac{1}{2} \\times 1 \\times 1 = \\frac{1}{2}$。\n- 残差的 $L^2$-范数平方为 $\\|1\\|_{L^2(K_2)}^2 = \\int_{K_2} 1^2 \\, d\\mathbf{x} = \\text{Area}(K_2) = \\frac{1}{2}$。\n- 来自 $K_2$ 的贡献为 $\\eta_{K_2}^2 = h_{K_2}^2 \\|1\\|_{L^2(K_2)}^2 = (\\sqrt{2})^2 \\times \\frac{1}{2} = 2 \\times \\frac{1}{2} = 1$。\n\n总估计子值的平方是每个单元贡献的总和：\n$$\\eta^2 = \\eta_{K_1}^2 + \\eta_{K_2}^2 = 1 + 1 = 2$$\n因此，估计子的值为：\n$$\\eta = \\sqrt{2}$$", "answer": "$$\\boxed{\\sqrt{2}}$$", "id": "2370198"}, {"introduction": "误差估计器不仅用于评估精度；其真正的威力在于指导仿真过程本身。本实践将深入探讨自适应网格细化（AMR），这是现代计算工程的基石。您将实现一个 AMR 循环，并研究误差范数（$L^2$ 与 $H^1$）的选择如何显著改变区域中被细化的部分，从而学习到关于目标导向自适应性的关键一课 [@problem_id:2370210]。", "problem": "要求您实现一个自适应网格加密研究，比较对于一个具有尖锐内层的一维函数，误差范数的选择如何影响网格的加密位置。该研究必须从第一性原理出发：范数的定义、一个插值算子，以及一个可由当前网格上的数据计算得出的单元后验误差指标。该实现必须在数学上是通用的，除了标准的数值积分外，不与任何特定的计算平台绑定。\n\n考虑开区间 $\\left(0,1\\right)$ 和标量函数\n$$\nu(x) \\;=\\; \\tfrac{1}{2}\\left(1 + \\tanh\\!\\left(\\dfrac{x-x_{0}}{\\varepsilon}\\right)\\right),\n$$\n其中 $x \\in \\left[0,1\\right]$, $x_{0} \\in \\left(0,1\\right)$ 定位了内层的位置，而 $\\varepsilon \\in \\left(0,1\\right)$ 控制层的厚度。当 $\\varepsilon$ 很小时，该模型会在 $x=x_{0}$ 附近创建一个尖锐的内层。\n\n您将通过划分为线段（单元）来离散化区间 $\\left[0,1\\right]$，并通过在网格节点上对 $u$ 进行采样来定义连续分段线性插值 $I_{h}u$，以此来近似 $u$。对于一个单元 $K = [a,b]$，基于 $L^{2}$ 范数和 $H^{1}$ 半范数的精确定义，定义两个局部后验误差指标：\n\n- 基于 $L^{2}$ 的指标：\n$$\n\\eta_{K}^{L^{2}} \\;=\\; \\left(\\int_{a}^{b} \\left(u(x) - I_{h}u(x)\\right)^{2} \\, dx \\right)^{1/2}.\n$$\n\n- 基于 $H^{1}$ 的指标（在单元上使用 $H^{1}$ 半范数）：\n$$\n\\eta_{K}^{H^{1}} \\;=\\; \\left(\\int_{a}^{b} \\left(u'(x) - \\left(I_{h}u\\right)'(x)\\right)^{2} \\, dx \\right)^{1/2}.\n$$\n\n此处 $u'(x)$ 是 $u(x)$ 的经典导数，而 $\\left(I_{h}u\\right)'(x)$ 在单元 $K$ 上等于恒定斜率 $\\dfrac{u(b)-u(a)}{b-a}$。积分必须使用足够高阶的高斯求积进行数值计算，以确保对于小的 $\\varepsilon$ 能得到稳定和准确的结果。\n\n从 $\\left[0,1\\right]$ 上的一个包含 $N_{0}$ 个等长单元的均匀网格开始，分别使用 $\\eta_{K}^{L^{2}}$ 和 $\\eta_{K}^{H^{1}}$，按照以下通用过程执行指定步数 $S$ 的迭代自适应加密：\n\n1. 在当前网格上，为每个单元 $K$ 计算所选的指标 $\\eta_{K}$。\n2. 标记出指标值最大的前 $\\theta$（其中 $0  \\theta  1$）比例的单元。\n3. 通过在每个被标记单元的中点处进行二等分来加密它，从而创建一个嵌套网格。\n\n完成 $S$ 步加密后，通过计算定义如下的集中度比率 $C$ 来量化网格在内层周围的集中程度：\n$$\nC \\;=\\; \\frac{\\#\\left\\{K : \\text{the midpoint of }K\\text{ satisfies } |x_{\\text{mid}} - x_{0}| \\le \\delta \\right\\}}{\\#\\{\\text{all elements}\\}},\n$$\n其中 $\\delta = m_{\\delta}\\,\\varepsilon$ 且 $m_{\\delta}0$ 是一个选定的乘数。为两次自适应运行计算 $C^{L^{2}}$ 和 $C^{H^{1}}$ 并报告两者。所有比率必须以小数形式报告，而不是百分比。\n\n实现一个程序，执行上述过程，并为每个测试用例输出数对 $\\left[C^{L^{2}},\\,C^{H^{1}}\\right]$。\n\n使用以下测试套件。每个测试用例指定了参数 $\\left(\\varepsilon, x_{0}, N_{0}, S, \\theta, m_{\\delta}\\right)$：\n\n- 测试用例 $1$（内层居中，尖锐）：$\\left(\\varepsilon, x_{0}, N_{0}, S, \\theta, m_{\\delta}\\right) = \\left(0.02,\\, 0.5,\\, 8,\\, 6,\\, 0.3,\\, 3\\right)$。\n- 测试用例 $2$（内层靠近边界，非常尖锐）：$\\left(\\varepsilon, x_{0}, N_{0}, S, \\theta, m_{\\delta}\\right) = \\left(0.01,\\, 0.05,\\, 8,\\, 6,\\, 0.3,\\, 3\\right)$。\n- 测试用例 $3$（较平缓的层）：$\\left(\\varepsilon, x_{0}, N_{0}, S, \\theta, m_{\\delta}\\right) = \\left(0.10,\\, 0.5,\\, 8,\\, 4,\\, 0.3,\\, 3\\right)$。\n\n最终输出格式：您的程序应生成单行输出，包含一个长度为3的列表，其中每个条目是对应测试用例的一个包含两个条目的列表 $\\left[C^{L^{2}}, C^{H^{1}}\\right]$。将每个小数格式化为小数点后恰好六位数字，并将整个结果打印为包含在方括号中的、以逗号分隔的列表，例如：\n$$\n\\left[\\left[c_{1}^{L^{2}},c_{1}^{H^{1}}\\right],\\left[c_{2}^{L^{2}},c_{2}^{H^{1}}\\right],\\left[c_{3}^{L^{2}},c_{3}^{H^{1}}\\right]\\right].\n$$\n本问题不涉及单位，并且所有角度（若有）根据数学约定均以弧度为单位。输出必须是如上所述的小数。", "solution": "所陈述的问题已经过验证。\n\n逐字提取的给定条件如下：\n- 关注域：开区间 $\\left(0,1\\right)$，在闭区间 $\\left[0,1\\right]$ 上进行离散化。\n- 标量函数：$u(x) \\;=\\; \\tfrac{1}{2}\\left(1 + \\tanh\\!\\left(\\dfrac{x-x_{0}}{\\varepsilon}\\right)\\right)$，其中 $x \\in \\left[0,1\\right]$，$x_{0} \\in \\left(0,1\\right)$，以及 $\\varepsilon \\in \\left(0,1\\right)$。\n- 离散化：将 $\\left[0,1\\right]$ 划分为线段单元。\n- 近似：连续分段线性插值 $I_{h}u$，在网格节点处对 $u$ 进行采样。\n- 单元 $K = [a,b]$ 的误差指标：\n  - 基于 $L^{2}$ 的：$\\eta_{K}^{L^{2}} \\;=\\; \\left(\\int_{a}^{b} \\left(u(x) - I_{h}u(x)\\right)^{2} \\, dx \\right)^{1/2}$。\n  - 基于 $H^{1}$ 的：$\\eta_{K}^{H^{1}} \\;=\\; \\left(\\int_{a}^{b} \\left(u'(x) - \\left(I_{h}u\\right)'(x)\\right)^{2} \\, dx \\right)^{1/2}$，其中 $\\left(I_{h}u\\right)'(x) = \\dfrac{u(b)-u(a)}{b-a}$。\n- 自适应加密过程：\n  - 初始状态：包含 $N_{0}$ 个单元的均匀网格。\n  - 步数：$S$。\n  - 标记策略：标记指标值最大的前 $\\theta$ 比例的单元。\n  - 加密方法：将每个被标记的单元在其中心点处二等分。\n- 分析度量：集中度比率 $C \\;=\\; \\frac{\\#\\left\\{K : |x_{\\text{mid}} - x_{0}| \\le \\delta \\right\\}}{\\#\\{\\text{all elements}\\}}$，其中 $\\delta = m_{\\delta}\\,\\varepsilon$。\n- 测试用例：\n  1. $\\left(\\varepsilon, x_{0}, N_{0}, S, \\theta, m_{\\delta}\\right) = \\left(0.02,\\, 0.5,\\, 8,\\, 6,\\, 0.3,\\, 3\\right)$。\n  2. $\\left(\\varepsilon, x_{0}, N_{0}, S, \\theta, m_{\\delta}\\right) = \\left(0.01,\\, 0.05,\\, 8,\\, 6,\\, 0.3,\\, 3\\right)$。\n  3. $\\left(\\varepsilon, x_{0}, N_{0}, S, \\theta, m_{\\delta}\\right) = \\left(0.10,\\, 0.5,\\, 8,\\, 4,\\, 0.3,\\, 3\\right)$。\n\n该问题是计算工程和数值分析中的一个标准练习，具体涉及离散化模型的后验误差估计。它在科学上植根于有限元方法和泛函分析的理论。该过程是适定、客观的，并且所有参数都已指定。因此，该问题是有效的，并将提供解答。\n\n按要求从第一性原理构建解决方案。\n\n首先，我们分析模型函数 $u(x)$ 及其导数。函数 $u(x) = \\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{x-x_0}{\\varepsilon}\\right)\\right)$ 表示在以 $x_0$ 为中心、宽度与 $\\varepsilon$ 成正比的区域内，从大约 $0$ 到 $1$ 的平滑过渡。其一阶导数是 $u'(x) = \\frac{1}{2\\varepsilon} \\text{sech}^2\\left(\\frac{x-x_0}{\\varepsilon}\\right)$。这个函数是一条正的、对称的钟形曲线，在 $x=x_0$ 处有尖锐的峰值，代表了高梯度内层。二阶导数是 $u''(x) = -\\frac{1}{\\varepsilon^2} \\text{sech}^2\\left(\\frac{x-x_0}{\\varepsilon}\\right) \\tanh\\left(\\frac{x-x_0}{\\varepsilon}\\right)$。这个函数关于 $x=x_0$ 是反对称的，在 $x=x_0$ 处为零，并在 $x \\approx x_0 \\pm 0.88\\varepsilon$ 处有两个符号相反的极值点。二阶导数量化了函数的曲率。\n\n其次，我们考虑离散化和插值。区间 $\\left[0,1\\right]$ 被节点 $0=z_0  z_1  \\dots  z_M=1$ 划分。一个单元是区间 $K_i = [z_{i-1}, z_i]$。在每个单元 $K_i$ 上，精确解 $u(x)$ 由连接点 $(z_{i-1}, u(z_{i-1}))$ 和 $(z_i, u(z_i))$ 的线性多项式 $I_h u(x)$ 来近似。其显式形式为，对于 $x \\in K_i$，$I_h u(x) = u(z_{i-1}) + \\frac{u(z_i)-u(z_{i-1})}{z_i-z_{i-1}}(x - z_{i-1})$。因此，导数 $(I_h u)'(x)$ 是分段常数，在每个单元 $K_i$ 上等于斜率 $\\frac{u(z_i)-u(z_{i-1})}{z_i-z_{i-1}}$。\n\n第三，我们分析这两个后验误差指标。这些指标被定义为在两种不同范数下测量的精确局部插值误差。基于 $L^2$ 的指标 $\\eta_K^{L^2}$ 测量函数值本身的均方根误差。线性单元的标准插值理论表明，误差 $u - I_h u$ 与单元尺寸 $h_K$ 和函数的二阶导数成比例，即 $\\|u - I_h u\\|_{L^2(K)} \\sim h_K^2 \\|u''\\|_{L^2(K)}$。由于 $|u''(x)|$ 在层的“肩部”（即偏离 $x_0$ 的位置）达到最大值，因此基于 $L^2$ 的指标将在位于这些区域的单元中最大。因此，由 $\\eta_K^{L^2}$ 驱动的自适应加密将优先在层中心的两侧插入新节点，而不是直接在其最陡峭的点。基于 $H^1$ 的指标 $\\eta_K^{H^1}$ 测量导数的均方根误差。被积函数是 $(u'(x) - (I_h u)'(x))^2$。真实导数 $u'(x)$ 是一个有尖锐峰值的函数，而近似导数 $(I_h u)'(x)$ 仅仅是单元上的一个恒定割线斜率。该积分的主要贡献来自 $u'(x)$ 本身值很大的区域。由于 $u'(x)$ 在 $x=x_0$ 处最大程度地集中，$\\eta_K^{H^1}$ 指标将在包含或紧邻 $x_0$ 的少数单元中最大。因此，由 $\\eta_K^{H^1}$ 驱动的加密将把网格点非常紧密地聚集在内层的中心周围。\n\n第四，数值实现需要一个用于自适应网格加密（AMR）循环的算法。从一个包含 $N_0$ 个单元的均匀网格开始，将以下步骤重复 $S$ 次：1. 对于当前网格中的每个单元 $K$，计算所选的误差指标 $\\eta_K^{L^2}$ 或 $\\eta_K^{H^1}$。这需要数值求积，因为这些积分在解析上并不简单。必须使用一种鲁棒的自适应求积方法，例如由 `scipy.integrate.quad` 提供的方法，以准确地计算积分，特别是当 $\\varepsilon$ 很小，被积函数变得高度局部化时。2. 识别要加密的单元。这是通过 Dörfler 标记策略完成的：按指标值对单元进行排序，并标记前 $\\lceil \\theta \\cdot M \\rceil$ 个单元，其中 $M$ 是当前单元数。3. 通过将所有被标记单元的中点添加到现有节点集中来生成新网格。生成的节点集必须排序并去除重复项，以定义下一级的网格。\n\n最后，在 $S$ 步加密之后，计算集中度比率 $C$。该度量量化了加密策略在将网格集中在感兴趣特征周围的有效性。计算过程包括统计其中心点 $x_{\\text{mid}}$ 落在区间 $[x_0 - \\delta, x_0 + \\delta]$ 内的最终单元数量，然后除以总单元数。我们预期在所有测试用例中，$C^{H^1}$ 将始终大于 $C^{L^2}$，这展示了基于 $H^1$ 的指标在解析尖锐梯度方面卓越的局部化特性。对于所提供的三个测试用例中的每一个，实现都将精确遵循此逻辑。", "answer": "```python\nimport numpy as np\nfrom scipy import integrate\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the adaptive mesh refinement study for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # (epsilon, x0, N0, S, theta, m_delta)\n        (0.02, 0.5, 8, 6, 0.3, 3),\n        (0.01, 0.05, 8, 6, 0.3, 3),\n        (0.10, 0.5, 8, 4, 0.3, 3),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        eps, x0, N0, S, theta, m_delta = case\n        \n        # Run refinement for L2 indicator\n        C_L2 = run_refinement(eps, x0, N0, S, theta, m_delta, indicator_type='L2')\n        \n        # Run refinement for H1 indicator\n        C_H1 = run_refinement(eps, x0, N0, S, theta, m_delta, indicator_type='H1')\n\n        all_results.append([C_L2, C_H1])\n\n    # Format the final output string as per problem specification.\n    formatted_results = []\n    for c_l2, c_h1 in all_results:\n        formatted_results.append(f\"[{c_l2:.6f},{c_h1:.6f}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\ndef u(x, x0, eps):\n    \"\"\"The exact function u(x).\"\"\"\n    return 0.5 * (1.0 + np.tanh((x - x0) / eps))\n\ndef du_dx(x, x0, eps):\n    \"\"\"The exact derivative u'(x).\"\"\"\n    val = (x - x0) / eps\n    return 0.5 / eps * (1.0 / np.cosh(val))**2\n\ndef run_refinement(eps, x0, N0, S, theta, m_delta, indicator_type):\n    \"\"\"\n    Performs the adaptive mesh refinement procedure for a given indicator type.\n    \"\"\"\n    # Initial uniform mesh\n    nodes = np.linspace(0.0, 1.0, N0 + 1)\n\n    for _ in range(S):\n        num_elements = len(nodes) - 1\n        indicators = np.zeros(num_elements)\n        elements = []\n\n        # Compute indicators for all elements\n        for i in range(num_elements):\n            a, b = nodes[i], nodes[i+1]\n            elements.append((a, b))\n            ua, ub = u(a, x0, eps), u(b, x0, eps)\n            \n            if b == a:  # Should not happen with proper refinement\n                indicators[i] = 0.0\n                continue\n            \n            slope = (ub - ua) / (b - a)\n\n            if indicator_type == 'L2':\n                integrand = lambda x: (u(x, x0, eps) - (ua + slope * (x - a)))**2\n            elif indicator_type == 'H1':\n                integrand = lambda x: (du_dx(x, x0, eps) - slope)**2\n            else:\n                raise ValueError(\"Invalid indicator type.\")\n\n            # Numerical integration\n            integral_val, _ = integrate.quad(integrand, a, b, limit=100)\n            indicators[i] = math.sqrt(integral_val)\n\n        # Mark elements for refinement\n        num_to_refine = math.ceil(theta * num_elements)\n        if num_to_refine > 0:\n            # Get indices of elements with largest indicators\n            refine_indices = np.argsort(indicators)[-num_to_refine:]\n        else:\n            refine_indices = []\n\n        # Refine marked elements by bisection\n        new_nodes_to_add = []\n        for index in refine_indices:\n            a, b = elements[index]\n            midpoint = (a + b) / 2.0\n            new_nodes_to_add.append(midpoint)\n        \n        # Create new sorted mesh\n        nodes = np.union1d(nodes, new_nodes_to_add)\n\n    # Compute concentration ratio C\n    delta = m_delta * eps\n    num_final_elements = len(nodes) - 1\n    concentrated_count = 0\n\n    for i in range(num_final_elements):\n        midpoint = (nodes[i] + nodes[i+1]) / 2.0\n        if abs(midpoint - x0) = delta:\n            concentrated_count += 1\n    \n    concentration_ratio = concentrated_count / num_final_elements if num_final_elements > 0 else 0.0\n    \n    return concentration_ratio\n\nsolve()\n\n```", "id": "2370210"}, {"introduction": "对于具有强方向性特征（如边界层或内部层）的问题，各向同性（uniform）的细化通常是浪费的。这个高级实践将探讨各向异性细化，其中网格单元被拉伸以有效捕捉急剧的梯度。您将推导并应用一个方向敏感的误差估计器，亲身体验一个精密的网格化策略如何能以相同的计算成本获得远超预期的精度 [@problem_id:2370208]。", "problem": "考虑单位正方形域 $(x,y) \\in [0,1]\\times[0,1]$ 上的稳态二维对流扩散模型问题，\n$$\n- \\varepsilon \\Delta u + \\boldsymbol{\\beta}\\cdot \\nabla u = f \\quad \\text{in } \\Omega,\\qquad u=g \\quad \\text{on } \\partial\\Omega,\n$$\n其中 $\\varepsilon0$ 是扩散系数，$\\boldsymbol{\\beta}=(1,0)^{\\top}$ 是一个沿 $x$方向的恒定对流场，$f$ 和 $g$ 的选择使得精确解为\n$$\nu(x,y) = 1 - \\exp\\!\\left(\\frac{x-1}{\\varepsilon}\\right).\n$$\n此精确解在 $x=1$ 附近呈现一个厚度为 $O(\\varepsilon)$ 的边界层，其在 $x$方向有剧烈变化，而在 $y$方向近似恒定。我们考虑在结构化张量积矩形网格上使用协调双线性有限元（也称为 $\\mathbb{Q}_1$ 单元），其在 $x$ 和 $y$方向的单元尺寸分别为 $h_x$ 和 $h_y$。我们关注 $u$ 在双线性有限元空间中的插值误差，并将其作为有限元离散误差的一个代理指标。\n\n从每个单元中 $u$ 的 Taylor 展开和 Hessian 矩阵 $H(u)$ 的定义出发，可以根据 $u$ 的二阶导数和方向性单元尺寸，构建一个用于双线性单元的方向敏感的后验插值误差估计子。对于一个其变化主要沿着一个方向（这里是 $x$方向）的函数，该估计子特化为一个表达式，该表达式分离了对解在该方向上的曲率和该方向上网格尺寸 $h_x$ 的依赖关系。\n\n你的任务是：\n- 从第一性原理出发，不使用任何预先给定的插值误差公式，为 $u$ 在尺寸为 $h_x$ 和 $h_y$ 的均匀矩形网格上的双线性插值推导一个方向敏感的后验插值误差估计子。\n- 证明对于给定的 $u(x,y)$，$y$方向的贡献消失，并且域上的总估计 $L^2$ 插值误差随 $h_x$ 的缩放方式由 $u$ 的 $x$方向曲率决定。\n- 使用此估计子比较在固定单元预算 $N$ 和最大单元纵横比约束 $R_{\\max}$ 下的两种加密策略，其中 $N = n_x n_y$，$n_x$ 和 $n_y$ 分别是 $x$ 和 $y$方向的单元数量，纵横比约束为 $n_x/n_y \\le R_{\\max}$。考虑：\n  1. 各向同性加密：$n_x = n_y = \\lfloor \\sqrt{N} \\rfloor$ (因此 $h_x = h_y = 1/\\lfloor \\sqrt{N} \\rfloor$)。\n  2. 纵横比约束下的各向异性加密：选择满足 $n_x n_y \\le N$ 和 $n_x/n_y \\le R_{\\max}$ 的整数 $(n_x,n_y)$，以最小化总的方向敏感估计误差。\n  \n对于上述构造解，$x$方向的曲率由 $u_{xx}(x,y) = -\\varepsilon^{-2} \\exp((x-1)/\\varepsilon)$ 给出，因此出现在全局 $L^2$ 插值误差中的积分 $\\int_0^1 u_{xx}(x,y)^2\\,dx$ 仅是 $\\varepsilon$ 的函数。你可以使用精确积分将此积分表示为关于 $\\varepsilon$ 的闭式形式。\n\n程序规范：\n- 实现一个程序，对于每个参数三元组 $(\\varepsilon, N, R_{\\max})$，计算：\n  1. 各向同性估计 $L^2$ 插值误差 $E_{\\text{iso}}(\\varepsilon,N)$。\n  2. 在整数约束 $n_x n_y \\le N$ 和 $n_x/n_y \\le R_{\\max}$ 下的最佳各向异性估计 $L^2$ 插值误差 $E_{\\text{ani}}(\\varepsilon,N,R_{\\max})$。\n  3. 比率 $\\rho = E_{\\text{ani}}/E_{\\text{iso}}$。\n- 假设估计子有一个未知的正常数乘法因子，该因子对两种策略是共同的；你必须一致地携带此因子，以使其在比率 $\\rho$ 中被消去。你必须使用 $x$方向曲率积分的精确求值，以便在 $E_{\\text{iso}}$ 和 $E_{\\text{ani}}$ 中都捕捉到对 $\\varepsilon$ 的依赖性。\n- 角度单位不适用。不需要物理单位。\n- 数值输出必须是实数。报告所有浮点结果，四舍五入到六位小数。\n- 用于评估您实现的测试套件：\n  1. $(\\varepsilon, N, R_{\\max}) = (0.02, 4096, 64)$\n  2. $(\\varepsilon, N, R_{\\max}) = (0.02, 64, 2)$\n  3. $(\\varepsilon, N, R_{\\max}) = (0.50, 4096, 64)$\n  4. $(\\varepsilon, N, R_{\\max}) = (0.02, 100000, 1)$\n  5. $(\\varepsilon, N, R_{\\max}) = (0.02, 100000, 4)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是按 $[E_{\\text{iso}}, E_{\\text{ani}}, \\rho]$ 顺序排列的三个浮点数的列表，因此最终输出是列表的列表，形式如：\n\"[ [e1_iso,e1_ani,r1], [e2_iso,e2_ani,r2], ... ]\"。", "solution": "问题陈述已经过验证，被认为是科学上合理、适定且客观的。它提出了一个偏微分方程数值分析中的标准练习。注意到在所提供的解的二阶导数中存在一个微小的符号不一致，但由于该项在误差估计子中以平方形式出现，因此该不一致是无关紧要的。我们开始进行解答。\n\n本任务旨在为双线性有限元推导一个方向敏感的后验插值误差估计子，将其应用于一个给定的对流扩散问题的构造解，并用它来比较各向同性和各向异性网格加密策略。\n\n### 第1部分：后验插值误差估计子的推导\n\n我们希望估计误差 $e = u - I_h u$，其中 $u$ 是一个足够光滑的函数，$I_h u$ 是其在矩形网格上的连续分片双线性函数（$\\mathbb{Q}_1$）空间中的插值函数。误差在网格的每个单元 $K$ 上进行局部估计。\n\n设 $K$ 是一个中心为 $(x_K, y_K)$、尺寸为 $h_x \\times h_y$ 的矩形单元。我们使用局部坐标 $(\\xi, \\eta) = (x-x_K, y-y_K)$，其中 $\\xi \\in [-h_x/2, h_x/2]$ 且 $\\eta \\in [-h_y/2, h_y/2]$。\n我们从 $u$ 在单元中心 $(x_K, y_K)$ 处的 Taylor 展开开始：\n$$\nu(x,y) = u(x_K, y_K) + \\xi u_x + \\eta u_y + \\frac{1}{2}\\xi^2 u_{xx} + \\xi\\eta u_{xy} + \\frac{1}{2}\\eta^2 u_{yy} + O(h^3)\n$$\n其中 $h = \\max(h_x, h_y)$，所有导数均在 $(x_K, y_K)$ 处求值。\n双线性插值函数 $I_h u$ 是形式为 $a+b\\xi+c\\eta+d\\xi\\eta$ 的唯一函数，它在单元的四个角点（其中 $\\xi = \\pm h_x/2$ 且 $\\eta = \\pm h_y/2$）处与 $u$ 相匹配。\n\n算子 $I_h$ 是线性的，并能再生由 $\\{1, \\xi, \\eta, \\xi\\eta\\}$ 张成的空间 $\\mathbb{Q}_1$ 中的所有函数。将 $I_h$ 应用于 $u$ 的 Taylor 展开，我们逐项分析误差 $e = u - I_h u \\approx (P_2 - I_h P_2)$，其中 $P_2$ 是展开式的二次项部分。\n\\begin{itemize}\n    \\item 常数项和线性项被精确插值：$I_h(u_0 + \\xi u_x + \\eta u_y) = u_0 + \\xi u_x + \\eta u_y$。\n    \\item 混合双线性项也被精确插值：$I_h(\\xi\\eta u_{xy}) = \\xi\\eta u_{xy}$。\n    \\item 对于纯二次项 $\\frac{1}{2}\\xi^2 u_{xx}$，其在四个角点 $(\\xi=\\pm h_x/2, \\eta=\\pm h_y/2)$ 的值均等于 $\\frac{1}{2}(h_x/2)^2 u_{xx} = \\frac{h_x^2}{8}u_{xx}$。在所有四个角点都取此常数值的唯一双线性函数是该常数函数本身。因此，$I_h(\\frac{1}{2}\\xi^2 u_{xx}) = \\frac{h_x^2}{8}u_{xx}$。\n    \\item 类似地，$I_h(\\frac{1}{2}\\eta^2 u_{yy}) = \\frac{h_y^2}{8}u_{yy}$。\n\\end{itemize}\n结合这些结果，单元 $K$ 上的插值误差可以近似为：\n$$\ne(\\xi, \\eta) \\approx \\left(\\frac{1}{2}\\xi^2 u_{xx} - \\frac{h_x^2}{8}u_{xx}\\right) + \\left(\\frac{1}{2}\\eta^2 u_{yy} - \\frac{h_y^2}{8}u_{yy}\\right) = \\frac{u_{xx}}{2}\\left(\\xi^2 - \\frac{h_x^2}{4}\\right) + \\frac{u_{yy}}{2}\\left(\\eta^2 - \\frac{h_y^2}{4}\\right)\n$$\n局部 $L^2$ 误差为 $\\|e\\|_{L^2(K)}^2 = \\int_K e^2 d\\xi d\\eta$。假设二阶导数 $u_{xx}$ 和 $u_{yy}$ 在单元 $K$ 上近似为常数，我们在 $K$ 上对误差近似的平方进行积分：\n$$\n\\|e\\|_{L^2(K)}^2 \\approx \\int_{-h_y/2}^{h_y/2} \\int_{-h_x/2}^{h_x/2} \\left( \\frac{u_{xx}}{2}\\left(\\xi^2 - \\frac{h_x^2}{4}\\right) + \\frac{u_{yy}}{2}\\left(\\eta^2 - \\frac{h_y^2}{4}\\right) \\right)^2 d\\xi d\\eta\n$$\n函数 $f(\\xi) = \\xi^2 - h_x^2/4$ 和 $g(\\eta) = \\eta^2 - h_y^2/4$ 是偶函数。它们在各自的对称区间上的积分非零。具体来说，$\\int_{-h/2}^{h/2} (z^2 - h^2/4) dz = -h^3/6$。这意味着平方展开中的交叉项积分不为零。然而，使用插值基函数的张量积性质进行的更严格的分析表明，误差的主阶项是正交的。插值误差的一个标准结果具有以下形式：\n$$\n\\|u - I_h u\\|_{L^2(K)}^2 \\approx C_x h_x^4 \\|u_{xx}\\|_{L^2(K)}^2 + C_y h_y^4 \\|u_{yy}\\|_{L^2(K)}^2 + C_{xy} h_x^2 h_y^2 \\|u_{xy}\\|_{L^2(K)}^2\n$$\n其中 $\\|\\cdot\\|_{L^2(K)}^2 = \\int_K (\\cdot)^2 dA$。通过对局部贡献求和，可以得到在域 $\\Omega$ 上的总误差：\n$$\nE^2 = \\|u-I_h u\\|_{L^2(\\Omega)}^2 = \\sum_{K \\in \\mathcal{T}_h} \\|u-I_h u\\|_{L^2(K)}^2\n$$\n对于具有均匀单元尺寸 $h_x=1/n_x$ 和 $h_y=1/n_y$ 的网格，这变为：\n$$\nE^2 \\approx C \\left( h_x^4 \\int_\\Omega u_{xx}^2 dA + h_y^4 \\int_\\Omega u_{yy}^2 dA + h_x^2 h_y^2 \\int_\\Omega u_{xy}^2 dA \\right)\n$$\n其中 $C$ 是一个包含特定系数（$C_x$、$C_y$、$C_{xy}$）的一般常数。这就是方向敏感的后验插值误差估计子。\n\n### 第2部分：应用于给定解\n\n所提供的精确解为 $u(x,y) = 1 - \\exp((x-1)/\\varepsilon)$，它仅依赖于 $x$。因此，所有关于 $y$ 的偏导数均为零：\n$$\nu_{y} = 0, \\quad u_{yy} = 0, \\quad u_{xy} = 0\n$$\n关于 $x$ 的二阶偏导数为：\n$$\nu_{xx}(x) = -\\frac{1}{\\varepsilon^2} \\exp\\left(\\frac{x-1}{\\varepsilon}\\right)\n$$\n将这些代入一般估计子，涉及 $u_{yy}$ 和 $u_{xy}$ 的项消失。总估计误差简化为：\n$$\nE^2 \\approx C h_x^4 \\int_\\Omega u_{xx}(x)^2 dA = C h_x^4 \\int_0^1 \\int_0^1 u_{xx}(x)^2 dx dy\n$$\n由于被积函数与 $y$ 无关，对 $y$ 的积分产生一个因子 1。\n$$\nE^2 \\approx C h_x^4 \\int_0^1 u_{xx}(x)^2 dx\n$$\n这表明，对于给定的解，误差主要由网格尺寸 $h_x$ 和解在 $x$方向的曲率决定，正如所要求的那样。\n\n我们现在计算曲率平方的积分：\n$$\n\\int_0^1 u_{xx}(x)^2 dx = \\int_0^1 \\left( -\\frac{1}{\\varepsilon^2} \\exp\\left(\\frac{x-1}{\\varepsilon}\\right) \\right)^2 dx = \\frac{1}{\\varepsilon^4} \\int_0^1 \\exp\\left(\\frac{2(x-1)}{\\varepsilon}\\right) dx\n$$\n$$\n= \\frac{1}{\\varepsilon^4} \\left[ \\frac{\\varepsilon}{2} \\exp\\left(\\frac{2(x-1)}{\\varepsilon}\\right) \\right]_0^1 = \\frac{1}{2\\varepsilon^3} \\left( e^0 - e^{-2/\\varepsilon} \\right) = \\frac{1 - e^{-2/\\varepsilon}}{2\\varepsilon^3}\n$$\n设此积分为 $I(\\varepsilon)$。误差平方为 $E^2 \\approx C h_x^4 I(\\varepsilon)$。估计误差为 $E \\approx C' h_x^2 \\sqrt{I(\\varepsilon)}$，其中 $C'$ 是一个未知的正常数。在我们的计算中，我们将设置 $C'=1$。\n\n### 第3部分：加密策略的比较\n\n目标是在给定约束条件下，最小化估计误差 $E \\propto h_x^2 = (1/n_x)^2$。这等价于最大化 $x$方向上的单元数量 $n_x$。\n\n1.  **各向同性加密：**\n    规定为 $n_x = n_y = \\lfloor \\sqrt{N} \\rfloor$。设此为 $n_x^{iso}$。误差为：\n    $E_{\\text{iso}} = (1/n_x^{iso})^2 \\sqrt{I(\\varepsilon)}$。\n\n2.  **各向异性加密：**\n    我们寻求找到整数 $(n_x, n_y)$，以在以下约束条件下最大化 $n_x$：\n    (i) $n_x n_y \\le N$\n    (ii) $n_x / n_y \\le R_{\\max}$\n    (iii) $n_x \\ge 1, n_y \\ge 1$\n    由(ii)可知，我们需要 $n_y \\ge n_x / R_{\\max}$。由于 $n_y$ 必须是整数，所以 $n_y \\ge \\lceil n_x/R_{\\max} \\rceil$。为了在 $n_x n_y$ 乘积固定的情况下最大化 $n_x$，我们必须选择最小可能的 $n_y$，即 $n_y^{min} = \\lceil n_x/R_{\\max} \\rceil$。我们必须满足预算约束 $n_x n_y^{min} \\le N$。\n    从约束条件可知，$n_x^2 \\le n_x (R_{\\max} n_y) \\le N R_{\\max}$，这提供了一个上界 $n_x \\le \\sqrt{N R_{\\max}}$。最优的 $n_x^{ani}$ 可以通过从 $n_x = \\lfloor \\sqrt{N R_{\\max}} \\rfloor$ 开始向下搜索，并取第一个满足 $n_x \\cdot \\lceil n_x/R_{\\max} \\rceil \\le N$ 的值来找到。\n    该策略的最小误差为 $E_{\\text{ani}} = (1/n_x^{ani})^2 \\sqrt{I(\\varepsilon)}$。\n\n误差的比率为 $\\rho = E_{\\text{ani}}/E_{\\text{iso}} = (n_x^{iso}/n_x^{ani})^2$。未知常数 $C'$ 和项 $\\sqrt{I(\\varepsilon)}$ 被消去。", "answer": "```python\nimport math\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes a posteriori interpolation error estimates for isotropic and\n    anisotropic refinement strategies for a 2D convection-diffusion problem.\n    \"\"\"\n    test_cases = [\n        # (epsilon, N, R_max)\n        (0.02, 4096, 64),\n        (0.02, 64, 2),\n        (0.50, 4096, 64),\n        (0.02, 100000, 1),\n        (0.02, 100000, 4),\n    ]\n\n    results = []\n\n    for epsilon, N, R_max in test_cases:\n        # Calculate the integral term dependent on epsilon\n        # I(epsilon) = (1 - exp(-2/epsilon)) / (2 * epsilon^3)\n        # We need its square root for the error E.\n        # For small epsilon, exp(-2/epsilon) is negligible.\n        if -2 / epsilon  -700: # Avoid underflow for np.exp\n            i_eps = 1.0 / (2.0 * epsilon**3)\n        else:\n            i_eps = (1.0 - np.exp(-2.0 / epsilon)) / (2.0 * epsilon**3)\n        \n        sqrt_i_eps = math.sqrt(i_eps)\n\n        # 1. Isotropic refinement\n        nx_iso = int(math.sqrt(N))\n        if nx_iso == 0:\n            # Handle cases with N  1, though not in test suite.\n            e_iso = float('inf')\n        else:\n            e_iso = (1.0 / nx_iso**2) * sqrt_i_eps\n\n        # 2. Anisotropic refinement\n        # Search for the optimal nx that maximizes nx subject to constraints.\n        nx_ani = -1\n        # Search range for nx is from floor(sqrt(N*R_max)) down to 1.\n        nx_start = int(math.sqrt(N * R_max))\n        \n        for nx in range(nx_start, 0, -1):\n            # n_y must be at least 1.\n            # From aspect ratio: n_y >= nx / R_max\n            ny_min = math.ceil(nx / R_max)\n            \n            # Check budget constraint\n            if nx * ny_min = N:\n                nx_ani = nx\n                break\n        \n        if nx_ani = 0:\n            # This case should not be reached with the given test cases.\n            e_ani = float('inf')\n            rho = float('nan')\n        else:\n            e_ani = (1.0 / nx_ani**2) * sqrt_i_eps\n            \n            # 3. Ratio\n            # Using nx values is more numerically stable than dividing errors.\n            rho = (nx_iso / nx_ani)**2\n        \n        results.append([\n            round(e_iso, 6),\n            round(e_ani, 6),\n            round(rho, 6)\n        ])\n    \n    # Format the final output string exactly as specified\n    formatted_results = []\n    for res in results:\n        formatted_results.append(f\"[{res[0]},{res[1]},{res[2]}]\")\n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2370208"}]}