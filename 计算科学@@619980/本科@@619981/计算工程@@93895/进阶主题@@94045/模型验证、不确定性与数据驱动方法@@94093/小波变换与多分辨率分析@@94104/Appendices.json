{"hands_on_practices": [{"introduction": "理解一个算法最好的方式就是亲手执行一遍。本练习将引导您使用最简单的小波——Haar小波，逐步完成多层离散小波变换（DWT）及其逆变换的完整过程。通过手动计算近似系数 $c_j$ 和细节系数 $d_j$，并最终完美重构原始信号，您将对滤波器组结构和完美重构原理建立起具体而深刻的理解 [@problem_id:2866836]。在接触更复杂的小波和应用之前，这项基本技能至关重要。", "problem": "考虑离散小波变换 (DWT)，它通过使用正交 Haar 系统实现为一个临界采样的双通道滤波器组。正交 Haar 分析滤波器为低通尺度滤波器 $h[0]=\\frac{1}{\\sqrt{2}}$, $h[1]=\\frac{1}{\\sqrt{2}}$ 和高通小波滤波器 $g[0]=\\frac{1}{\\sqrt{2}}$, $g[1]=-\\frac{1}{\\sqrt{2}}$。使用标准的临界采样树结构，在每一级进行 $2$ 倍抽取，并且无边界扩展（即，对于长度可被 $2^{L}$ 整除的序列，进行成对分组处理有效），并使用相应的正交合成滤波器进行逆变换。设输入序列为 $x[n]=[3,1,0,4,8,6,2,0]$，索引为 $n=0,1,\\dots,7$。\n\n任务：\n- 手动计算 $x[n]$ 的 $3$ 级 Haar DWT，以获得第 $3$ 级的近似系数和第 $1,2,3$ 级的细节系数。\n- 使用逆双通道正交 Haar 滤波器组从这些系数重构 $\\hat{x}[n]$。\n- 定义标量误差能量\n$$E=\\sum_{n=0}^{7}\\left|x[n]-\\hat{x}[n]\\right|^{2}.$$\n报告 $E$ 的值。\n\n提供 $E$ 的精确值（不进行四舍五入）。无需单位。在首次使用时定义所有缩写词：离散小波变换 (Discrete Wavelet Transform, DWT)、快速小波变换 (Fast Wavelet Transform, FWT)、完美重构 (Perfect Reconstruction, PR)。", "solution": "该问题要求计算一个信号经过 $3$ 级离散小波变换 (Discrete Wavelet Transform, DWT) 及其逆变换后的重构误差能量，其中使用正交 Haar 小波基。题目指定了一个临界采样的双通道滤波器组，这是快速小波变换 (Fast Wavelet Transform, FWT) 的标准结构。考察的关键性质是完美重构 (Perfect Reconstruction, PR)，这是正交滤波器组在没有信息损失（如量化）情况下的一个基本特性。我们将通过显式计算正向和逆向变换，然后计算误差能量来求解。\n\n输入信号为 $x[n] = [3, 1, 0, 4, 8, 6, 2, 0]$，其中 $n \\in \\{0, 1, \\dots, 7\\}$。长度为 $N=8$。\n正交 Haar 分析滤波器是低通尺度滤波器 $h[n]$ 和高通小波滤波器 $g[n]$：\n$$h[n] = \\frac{1}{\\sqrt{2}}\\delta[n] + \\frac{1}{\\sqrt{2}}\\delta[n-1]$$\n$$g[n] = \\frac{1}{\\sqrt{2}}\\delta[n] - \\frac{1}{\\sqrt{2}}\\delta[n-1]$$\nDWT 的实现方式是将信号与这些滤波器进行卷积，然后以因子 $2$ 进行抽取。对于 Haar 系统，这简化为成对求均值与差分。我们将第 $j$ 级的近似系数表示为 $c_j$，细节系数表示为 $d_j$。输入信号为 $c_0[n] = x[n]$。\n\n**第1部分：正向 DWT (分析)**\n\n**第 1 级分解：**\n输入为 $c_0 = [3, 1, 0, 4, 8, 6, 2, 0]$。我们成对处理样本。\n近似系数 $c_1[k]$ 计算如下：\n$c_1[0] = \\frac{c_0[0] + c_0[1]}{\\sqrt{2}} = \\frac{3+1}{\\sqrt{2}} = \\frac{4}{\\sqrt{2}} = 2\\sqrt{2}$\n$c_1[1] = \\frac{c_0[2] + c_0[3]}{\\sqrt{2}} = \\frac{0+4}{\\sqrt{2}} = \\frac{4}{\\sqrt{2}} = 2\\sqrt{2}$\n$c_1[2] = \\frac{c_0[4] + c_0[5]}{\\sqrt{2}} = \\frac{8+6}{\\sqrt{2}} = \\frac{14}{\\sqrt{2}} = 7\\sqrt{2}$\n$c_1[3] = \\frac{c_0[6] + c_0[7]}{\\sqrt{2}} = \\frac{2+0}{\\sqrt{2}} = \\frac{2}{\\sqrt{2}} = \\sqrt{2}$\n因此，$c_1 = [2\\sqrt{2}, 2\\sqrt{2}, 7\\sqrt{2}, \\sqrt{2}]$。\n\n细节系数 $d_1[k]$ 计算如下：\n$d_1[0] = \\frac{c_0[0] - c_0[1]}{\\sqrt{2}} = \\frac{3-1}{\\sqrt{2}} = \\frac{2}{\\sqrt{2}} = \\sqrt{2}$\n$d_1[1] = \\frac{c_0[2] - c_0[3]}{\\sqrt{2}} = \\frac{0-4}{\\sqrt{2}} = -\\frac{4}{\\sqrt{2}} = -2\\sqrt{2}$\n$d_1[2] = \\frac{c_0[4] - c_0[5]}{\\sqrt{2}} = \\frac{8-6}{\\sqrt{2}} = \\frac{2}{\\sqrt{2}} = \\sqrt{2}$\n$d_1[3] = \\frac{c_0[6] - c_0[7]}{\\sqrt{2}} = \\frac{2-0}{\\sqrt{2}} = \\frac{2}{\\sqrt{2}} = \\sqrt{2}$\n因此，$d_1 = [\\sqrt{2}, -2\\sqrt{2}, \\sqrt{2}, \\sqrt{2}]$。\n\n**第 2 级分解：**\n输入是上一级的近似系数，$c_1 = [2\\sqrt{2}, 2\\sqrt{2}, 7\\sqrt{2}, \\sqrt{2}]$。\n$c_2[0] = \\frac{c_1[0] + c_1[1]}{\\sqrt{2}} = \\frac{2\\sqrt{2} + 2\\sqrt{2}}{\\sqrt{2}} = \\frac{4\\sqrt{2}}{\\sqrt{2}} = 4$\n$c_2[1] = \\frac{c_1[2] + c_1[3]}{\\sqrt{2}} = \\frac{7\\sqrt{2} + \\sqrt{2}}{\\sqrt{2}} = \\frac{8\\sqrt{2}}{\\sqrt{2}} = 8$\n因此，$c_2 = [4, 8]$。\n\n$d_2[0] = \\frac{c_1[0] - c_1[1]}{\\sqrt{2}} = \\frac{2\\sqrt{2} - 2\\sqrt{2}}{\\sqrt{2}} = 0$\n$d_2[1] = \\frac{c_1[2] - c_1[3]}{\\sqrt{2}} = \\frac{7\\sqrt{2} - \\sqrt{2}}{\\sqrt{2}} = \\frac{6\\sqrt{2}}{\\sqrt{2}} = 6$\n因此，$d_2 = [0, 6]$。\n\n**第 3 级分解：**\n输入是 $c_2 = [4, 8]$。\n$c_3[0] = \\frac{c_2[0] + c_2[1]}{\\sqrt{2}} = \\frac{4+8}{\\sqrt{2}} = \\frac{12}{\\sqrt{2}} = 6\\sqrt{2}$\n因此，$c_3 = [6\\sqrt{2}]$。\n\n$d_3[0] = \\frac{c_2[0] - c_2[1]}{\\sqrt{2}} = \\frac{4-8}{\\sqrt{2}} = -\\frac{4}{\\sqrt{2}} = -2\\sqrt{2}$\n因此，$d_3 = [-2\\sqrt{2}]$。\n\n$x[n]$ 的 $3$ 级 DWT 由 $\\{c_3, d_3, d_2, d_1\\}$ 组成。\n\n**第2部分：逆 DWT (合成)**\n\n逆变换逐级重构信号。对于正交滤波器组，合成运算是分析运算的伴随运算。对于 Haar 基，这导出了简单的重构公式：\n$c_{j-1}[2k] = \\frac{c_j[k] + d_j[k]}{\\sqrt{2}}$\n$c_{j-1}[2k+1] = \\frac{c_j[k] - d_j[k]}{\\sqrt{2}}$\n我们将重构的近似系数表示为 $\\hat{c}_j$。\n\n**第 3 级到第 2 级合成：**\n我们从 $c_3=[6\\sqrt{2}]$ 和 $d_3=[-2\\sqrt{2}]$ 重构 $\\hat{c}_2$。\n$\\hat{c}_2[0] = \\frac{c_3[0] + d_3[0]}{\\sqrt{2}} = \\frac{6\\sqrt{2} + (-2\\sqrt{2})}{\\sqrt{2}} = \\frac{4\\sqrt{2}}{\\sqrt{2}} = 4$\n$\\hat{c}_2[1] = \\frac{c_3[0] - d_3[0]}{\\sqrt{2}} = \\frac{6\\sqrt{2} - (-2\\sqrt{2})}{\\sqrt{2}} = \\frac{8\\sqrt{2}}{\\sqrt{2}} = 8$\n因此，$\\hat{c}_2 = [4, 8]$，与原始的 $c_2$ 相同。\n\n**第 2 级到第 1 级合成：**\n我们从 $\\hat{c}_2=[4, 8]$ 和 $d_2=[0, 6]$ 重构 $\\hat{c}_1$。\n对于 $k=0$：\n$\\hat{c}_1[0] = \\frac{\\hat{c}_2[0] + d_2[0]}{\\sqrt{2}} = \\frac{4+0}{\\sqrt{2}} = \\frac{4}{\\sqrt{2}} = 2\\sqrt{2}$\n$\\hat{c}_1[1] = \\frac{\\hat{c}_2[0] - d_2[0]}{\\sqrt{2}} = \\frac{4-0}{\\sqrt{2}} = \\frac{4}{\\sqrt{2}} = 2\\sqrt{2}$\n对于 $k=1$：\n$\\hat{c}_1[2] = \\frac{\\hat{c}_2[1] + d_2[1]}{\\sqrt{2}} = \\frac{8+6}{\\sqrt{2}} = \\frac{14}{\\sqrt{2}} = 7\\sqrt{2}$\n$\\hat{c}_1[3] = \\frac{\\hat{c}_2[1] - d_2[1]}{\\sqrt{2}} = \\frac{8-6}{\\sqrt{2}} = \\frac{2}{\\sqrt{2}} = \\sqrt{2}$\n因此，$\\hat{c}_1 = [2\\sqrt{2}, 2\\sqrt{2}, 7\\sqrt{2}, \\sqrt{2}]$，与原始的 $c_1$ 相同。\n\n**第 1 级到第 0 级合成：**\n我们从 $\\hat{c}_1$ 和 $d_1=[\\sqrt{2}, -2\\sqrt{2}, \\sqrt{2}, \\sqrt{2}]$ 重构最终信号 $\\hat{x}[n] = \\hat{c}_0[n]$ 。\n对于 $k=0$：\n$\\hat{x}[0] = \\frac{\\hat{c}_1[0] + d_1[0]}{\\sqrt{2}} = \\frac{2\\sqrt{2} + \\sqrt{2}}{\\sqrt{2}} = \\frac{3\\sqrt{2}}{\\sqrt{2}} = 3$\n$\\hat{x}[1] = \\frac{\\hat{c}_1[0] - d_1[0]}{\\sqrt{2}} = \\frac{2\\sqrt{2} - \\sqrt{2}}{\\sqrt{2}} = \\frac{\\sqrt{2}}{\\sqrt{2}} = 1$\n对于 $k=1$：\n$\\hat{x}[2] = \\frac{\\hat{c}_1[1] + d_1[1]}{\\sqrt{2}} = \\frac{2\\sqrt{2} + (-2\\sqrt{2})}{\\sqrt{2}} = 0$\n$\\hat{x}[3] = \\frac{\\hat{c}_1[1] - d_1[1]}{\\sqrt{2}} = \\frac{2\\sqrt{2} - (-2\\sqrt{2})}{\\sqrt{2}} = \\frac{4\\sqrt{2}}{\\sqrt{2}} = 4$\n对于 $k=2$：\n$\\hat{x}[4] = \\frac{\\hat{c}_1[2] + d_1[2]}{\\sqrt{2}} = \\frac{7\\sqrt{2} + \\sqrt{2}}{\\sqrt{2}} = \\frac{8\\sqrt{2}}{\\sqrt{2}} = 8$\n$\\hat{x}[5] = \\frac{\\hat{c}_1[2] - d_1[2]}{\\sqrt{2}} = \\frac{7\\sqrt{2} - \\sqrt{2}}{\\sqrt{2}} = \\frac{6\\sqrt{2}}{\\sqrt{2}} = 6$\n对于 $k=3$：\n$\\hat{x}[6] = \\frac{\\hat{c}_1[3] + d_1[3]}{\\sqrt{2}} = \\frac{\\sqrt{2} + \\sqrt{2}}{\\sqrt{2}} = \\frac{2\\sqrt{2}}{\\sqrt{2}} = 2$\n$\\hat{x}[7] = \\frac{\\hat{c}_1[3] - d_1[3]}{\\sqrt{2}} = \\frac{\\sqrt{2} - \\sqrt{2}}{\\sqrt{2}} = 0$\n重构的信号是 $\\hat{x}[n]=[3, 1, 0, 4, 8, 6, 2, 0]$。\n\n**第3部分：误差能量计算**\n原始信号为 $x[n]=[3, 1, 0, 4, 8, 6, 2, 0]$。\n重构信号为 $\\hat{x}[n]=[3, 1, 0, 4, 8, 6, 2, 0]$。\n显然，对于所有 $n \\in \\{0, 1, \\dots, 7\\}$，都有 $\\hat{x}[n] = x[n]$。\n误差信号为 $e[n] = x[n] - \\hat{x}[n] = [0, 0, 0, 0, 0, 0, 0, 0]$。\n标量误差能量 $E$ 定义为：\n$$E = \\sum_{n=0}^{7} |x[n] - \\hat{x}[n]|^2 = \\sum_{n=0}^{7} |e[n]|^2$$\n代入误差信号：\n$$E = \\sum_{n=0}^{7} |0|^2 = 0$$\n结果 $E=0$ 是符合预期的。问题设定描述了一个正交滤波器组，在分析和合成阶段之间没有对系数进行修改（例如，量化、阈值处理）。这类系统具有完美重构特性，意味着输出与输入完全相同，因此重构误差为零。本计算证实了这一基本原理。", "answer": "$$\\boxed{0}$$", "id": "2866836"}, {"introduction": "小波变换的一个关键优势在于它能够比傅里叶变换等传统方法更有效地（即“稀疏地”）表示某些类型的信号。本实践将通过一个计算实验来阐明这一概念，您将分析几种不同类型的信号，包括平滑的周期信号和含有尖锐局部变化的信号。通过比较傅里叶域和小波域中捕获大部分信号能量所需的系数数量，您将亲身体验到不同基函数对不同信号的适应性 [@problem_id:2450300]。这种洞察力是小波在数据压缩和特征检测等领域大放异彩的基石。", "problem": "您需要编写一个完整、可运行的程序，该程序构建特定的离散时间信号，使用正交 Haar 基分析它们在离散傅里叶变换 (DFT) 域和离散小波变换 (DWT) 域中的表示稀疏性，并对给定的测试套件聚合结果。三角函数中使用的所有角度都必须是弧度。不涉及物理单位。\n\n定义和要求：\n1) 设一个实值离散时间信号由长度为 $N$ 的有限序列 $\\{x[n]\\}_{n=0}^{N-1}$ 表示，其中 $N$ 是一个正偶数。\n2) $\\{x[n]\\}_{n=0}^{N-1}$ 的离散傅里叶变换 (DFT) 是序列 $\\{X[k]\\}_{k=0}^{N-1}$，定义为\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\, 2\\pi \\, \\frac{n k}{N}} \\quad \\text{for} \\quad k=0,1,\\dots,N-1.\n$$\n3) $\\{x[n]\\}_{n=0}^{N-1}$ 的正交 Haar 离散小波变换 (DWT) 是通过重复应用长度为2的正交分析滤波器递归定义的。在每个层级，对于一个长度为偶数 $M$ 的输入序列 $\\{u[m]\\}_{m=0}^{M-1}$，定义近似系数 $\\{a[j]\\}_{j=0}^{\\frac{M}{2}-1}$ 和细节系数 $\\{d[j]\\}_{j=0}^{\\frac{M}{2}-1}$ 如下\n$$\na[j] = \\frac{u[2j] + u[2j+1]}{\\sqrt{2}}, \\quad d[j] = \\frac{u[2j] - u[2j+1]}{\\sqrt{2}},\n$$\n对于 $j=0,1,\\dots,\\frac{M}{2}-1$。使用近似系数作为下一层级的输入 $\\{u[m]\\}$，并持续此过程直到只剩下一个近似系数。全套 Haar DWT 系数由最终的单个近似系数以及来自所有层级的所有细节系数组成。该变换是正交的且能量守恒。\n4) 对于所选域（DFT 幅值或 Haar DWT 系数）中的任意系数向量 $\\{c[\\ell]\\}$，其总能量定义为\n$$\nE = \\sum_{\\ell} |c[\\ell]|^2.\n$$\n给定一个能量捕获分数 $\\alpha \\in (0,1]$，该系数向量的稀疏计数 $S_\\alpha$ 定义为最小的非负整数 $K$，使得 $K$ 个幅值最大（按绝对值）的系数的幅值平方和大于或等于 $\\alpha E$。如果 $E=0$，则定义 $S_\\alpha = 0$。\n5) 对于一个信号 $\\{x[n]\\}$，令 $S_\\alpha^{\\text{DFT}}$ 表示从 DFT 幅值 $\\{|X[k]|\\}$ 计算出的稀疏计数，令 $S_\\alpha^{\\text{DWT}}$ 表示从全套 Haar DWT 系数计算出的稀疏计数。在本问题中，使用 $\\alpha = 0.95$。\n\n测试套件：\n使用 $N=256$ 和以下四个信号 $\\{x^{(q)}[n]\\}$，其中 $q \\in \\{A,B,C,D\\}$，$n=0,1,\\dots,N-1$。\n- 情况 A (两个余弦之和，频率单位为“周期/记录”)：令 $f_1 = 5$ 且 $f_2 = 13$。定义\n$$\nx^{(A)}[n] = \\cos\\!\\left(2\\pi \\frac{f_1 n}{N}\\right) + 0.5 \\cos\\!\\left(2\\pi \\frac{f_2 n}{N}\\right).\n$$\n- 情况 B (分段常数，二进分割)：定义\n$$\nx^{(B)}[n] =\n\\begin{cases}\n0, & 0 \\le n < 64,\\\\\n2, & 64 \\le n < 128,\\\\\n-1.5, & 128 \\le n < 192,\\\\\n0.5, & 192 \\le n < 256.\n\\end{cases}\n$$\n- 情况 C (零信号)：对于所有 $n$，定义 $x^{(C)}[n] = 0$。\n- 情况 D (具有线性增加瞬时频率的线性啁啾信号)：令 $f_0 = 3$ 且 $f_1 = 60$。定义 $t_n = \\frac{n}{N}$ 和相位\n$$\n\\phi[n] = 2\\pi \\left( f_0 \\, t_n + \\frac{1}{2}(f_1 - f_0) \\, t_n^2 \\right),\n$$\n并设置\n$$\nx^{(D)}[n] = \\sin\\!\\big(\\phi[n]\\big).\n$$\n\n角度单位声明：所有三角函数参数均为弧度。\n\n对于每种情况 $q \\in \\{A,B,C,D\\}$，计算数对 $(S_{0.95}^{\\text{DFT}}(x^{(q)}), S_{0.95}^{\\text{DWT}}(x^{(q)}))$ 并计算两个布尔指标：\n- 傅里叶稀疏性指标：$S_{0.95}^{\\text{DFT}}(x^{(q)}) < S_{0.95}^{\\text{DWT}}(x^{(q)})$。\n- 小波稀疏性指标：$S_{0.95}^{\\text{DWT}}(x^{(q)}) < S_{0.95}^{\\text{DFT}}(x^{(q)})$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个含四个结果的列表，顺序为 $[A,B,C,D]$。每个结果必须是 $[K_F, K_W, F_{sparser}, W_{sparser}]$ 形式的列表，其中 $K_F$ 是 $S_{0.95}^{\\text{DFT}}$，$K_W$ 是 $S_{0.95}^{\\text{DWT}}$，$F_{sparser}$ 是傅里叶稀疏性布尔值，$W_{sparser}$ 是小波稀疏性布尔值。整个输出必须是如下所示的单行：\n$[[K_{F,A}, K_{W,A}, F_A, W_A], [K_{F,B}, K_{W,B}, F_B, W_B], [K_{F,C}, K_{W,C}, F_C, W_C], [K_{F,D}, K_{W,D}, F_D, W_D]]$\n无任何额外文本。", "solution": "所呈现的问题是一个定义明确的信号处理计算练习，具体涉及信号表示稀疏性的分析。它要求比较两种基本变换——离散傅里叶变换 (DFT) 和使用 Haar 基的离散小波变换 (DWT)——在表示不同类型信号时的效果。问题陈述在科学上是合理的，在数学上是无歧义的，并包含了解决该问题所需的所有信息。因此，我认为该问题是有效的，并将继续提供完整的解决方案。\n\n需要展示的核心原理是，信号表示的效率关键取决于基函数的选择。在特定基中“稀疏”的信号可以使用少量非零系数被精确地表示或近似。这一特性是现代数据压缩和分析技术的基础。DFT 提供了一组复正弦波基，对于由少数周期性分量组成的信号而言，这是最优稀疏的。另一方面，Haar DWT 提供了一组分段常数函数（缩放和平移的方波）基，对于本身具有二进结构的分段常数信号而言，这是最优稀疏的。\n\n对于每个测试用例，求解方法包括四个主要步骤：\n1.  根据指定的数学公式生成信号。\n2.  计算信号在 DFT 域和 Haar DWT 域中的表示。\n3.  计算两种表示的稀疏计数 $S_{0.95}$。\n4.  比较两个稀疏计数，以确定哪个基提供了更稀疏的表示。\n\n设信号为 $\\{x[n]\\}_{n=0}^{N-1}$，其中 $N=256$。\n\n首先，我们使用以下公式计算 DFT 系数 $\\{X[k]\\}_{k=0}^{N-1}$：\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\, 2\\pi \\, \\frac{n k}{N}}\n$$\n这可以使用快速傅里叶变换 (FFT) 算法高效实现。\n\n其次，我们计算正交 Haar DWT 系数。这个过程是递归的。设初始信号为 $u_0 = x$。对于每个层级 $j=1, 2, \\dots, \\log_2(N)$，我们将前一层级的近似系数 $u_{j-1}$ 作为输入。新的近似系数 $a_j$ 和细节系数 $d_j$ 计算如下：\n$$\na_j[m] = \\frac{u_{j-1}[2m] + u_{j-1}[2m+1]}{\\sqrt{2}}\n$$\n$$\nd_j[m] = \\frac{u_{j-1}[2m] - u_{j-1}[2m+1]}{\\sqrt{2}}\n$$\n下一层级的输入是 $u_j = a_j$。重复此过程，直到只剩下一个近似系数 $a_{\\log_2(N)}$。完整的 DWT 系数向量是最终的近似系数和来自每个层级的所有细节系数的集合：$\\{a_{\\log_2(N)}, d_{\\log_2(N)}, d_{\\log_2(N)-1}, \\dots, d_1\\}$。对于 $N=256$，有 $\\log_2(256)=8$ 个分解层级。\n\n第三，对于每组系数 $\\{c[\\ell]\\}$（无论是 DFT 幅值 $\\{|X[k]|\\}$ 还是 Haar DWT 系数），我们计算 $\\alpha = 0.95$ 时的稀疏计数 $S_\\alpha$。总能量定义为 $E = \\sum_{\\ell} |c[\\ell]|^2$。稀疏计数 $S_\\alpha$ 是系数的最小数量 $K$，其幅值平方和至少为 $\\alpha E$。为了找到 $K$，我们将幅值的平方 $|c[\\ell]|^2$ 按降序排序，并找到最小的 $K$，使得前 $K$ 项的累积和达到或超过阈值 $0.95 E$。如果 $E=0$，则 $S_\\alpha = 0$。\n\n让我们在计算前分析每个案例：\n- **情况 A (余弦之和)**：信号 $x^{(A)}[n] = \\cos(2\\pi \\frac{5 n}{256}) + 0.5 \\cos(2\\pi \\frac{13 n}{256})$ 是两个具有整数频率 $f_1=5$ 和 $f_2=13$ 的纯正弦波之和。一个余弦 $\\cos(2\\pi \\frac{f n}{N})$ 的 DFT 由位于频率 $k=f$ 和 $k=N-f$ 处的两个脉冲组成。因此，$x^{(A)}[n]$ 的 DFT 的几乎所有能量将集中在对应于 $k \\in \\{5, 13, 256-13, 256-5\\}$ 的仅仅四个系数中。DFT 表示将极其稀疏。相反，信号的平滑正弦特性与块状的 Haar 小波不匹配，需要许多 DWT 系数才能进行精确表示。我们预测 $S_{0.95}^{\\text{DFT}} < S_{0.95}^{\\text{DWT}}$。\n\n- **情况 B (分段常数)**：信号 $x^{(B)}[n]$ 在四个长度各为 $64$ 的连续块上是常数。边界位于 $n=64$、$n=128$ 和 $n=192$，它们都是 $N/4 = 256/4 = 64$ 的整数倍。这种二进结构与 Haar 基函数完美对齐。通过逐步应用 DWT 滤波器方程可以表明，只有极少数对应于不连续点的 Haar 系数会是非零的。我们的分析显示恰好有 $4$ 个非零 DWT 系数。相比之下，信号中的急剧不连续点会将能量广泛地分布在整个频谱上，导致一个稠密的 DFT 表示。我们预测 $S_{0.95}^{\\text{DWT}} < S_{0.95}^{\\text{DFT}}$。\n\n- **情况 C (零信号)**：$x^{(C)}[n] = 0$。零信号的 DFT 和 DWT 都是零向量。两个域中的能量均为 $E=0$。根据定义，两者的稀疏计数都是 $S_\\alpha = 0$。因此，$S_{0.95}^{\\text{DFT}} = S_{0.95}^{\\text{DWT}} = 0$。两者都不比另一个更稀疏。\n\n- **情况 D (线性啁啾)**：信号 $x^{(D)}[n] = \\sin(\\phi[n])$ 的瞬时频率从 $f_0=3$ 线性变化到 $f_1=60$。这个信号是非周期且平滑的。它的能量在 DFT 域中分布在一个很宽的频率范围内，所以 $S_{0.95}^{\\text{DFT}}$ 会很大。它也不是分段常数，所以它的 Haar DWT 表示也会是稠密的，使得 $S_{0.95}^{\\text{DWT}}$ 也很大。没有哪个基是理想的。相对性能不是先验地显而易见的，将由计算确定。小波常被引用其分析此类时变信号的能力，但与更平滑的小波相比，基础的 Haar 小波对于这个任务而言是一个较差的选择。\n\n最后一步是在一个程序中实现这个逻辑，为每种情况找到 $S_{0.95}^{\\text{DFT}}$ 和 $S_{0.95}^{\\text{DWT}}$ 的精确量化值以及相应的布尔指标。最终答案部分提供的代码执行了这些计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs, analyzes, and reports the sparsity of four test signals\n    in the DFT and Haar DWT domains.\n    \"\"\"\n\n    def haar_dwt(x: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Computes the full 1D orthonormal Haar Discrete Wavelet Transform.\n        \"\"\"\n        u = x.astype(np.float64)\n        coeffs = []\n        while len(u) > 1:\n            u_even = u[::2]\n            u_odd = u[1::2]\n            a = (u_even + u_odd) / np.sqrt(2)\n            d = (u_even - u_odd) / np.sqrt(2)\n            coeffs.insert(0, d)\n            u = a\n        \n        # The final structure is [a_final, d_logN, d_logN-1, ..., d_1]\n        full_coeffs = [u]\n        for d_level in coeffs:\n            full_coeffs.append(d_level)\n            \n        return np.concatenate(full_coeffs)\n\n    def calculate_sparsity(coeffs: np.ndarray, alpha: float) -> int:\n        \"\"\"\n        Calculates the sparsity count S_alpha for a given coefficient vector.\n        \"\"\"\n        if coeffs.size == 0:\n            return 0\n\n        # Use squared magnitudes for energy calculation\n        coeffs_mag_sq = np.abs(coeffs)**2\n        total_energy = np.sum(coeffs_mag_sq)\n\n        if total_energy == 0:\n            return 0\n\n        target_energy = alpha * total_energy\n        \n        # Sort squared magnitudes in descending order\n        sorted_mag_sq = np.sort(coeffs_mag_sq)[::-1]\n        \n        # Find the number of coefficients needed to capture the target energy\n        cumulative_energy = np.cumsum(sorted_mag_sq)\n        \n        # K is the smallest count such that the energy condition is met.\n        # np.searchsorted finds the index to insert to maintain order.\n        # If the target is met at index i, we need i+1 coefficients.\n        K = np.searchsorted(cumulative_energy, target_energy, side='left') + 1\n        \n        return int(K)\n\n    # General parameters from the problem statement\n    N = 256\n    alpha = 0.95\n    n = np.arange(N)\n\n    # Test Case A: Sum of two cosines\n    f1_A, f2_A = 5, 13\n    x_A = np.cos(2 * np.pi * f1_A * n / N) + 0.5 * np.cos(2 * np.pi * f2_A * n / N)\n\n    # Test Case B: Piecewise-constant signal\n    x_B = np.zeros(N)\n    x_B[64:128] = 2.0\n    x_B[128:192] = -1.5\n    x_B[192:256] = 0.5\n\n    # Test Case C: Zero signal\n    x_C = np.zeros(N)\n\n    # Test Case D: Linear chirp\n    f0_D, f1_D = 3, 60\n    t_n = n / N\n    phase_D = 2 * np.pi * (f0_D * t_n + 0.5 * (f1_D - f0_D) * t_n**2)\n    x_D = np.sin(phase_D)\n    \n    signals = {'A': x_A, 'B': x_B, 'C': x_C, 'D': x_D}\n    all_results = []\n    \n    # Process each case in the required order\n    for key in ['A', 'B', 'C', 'D']:\n        x = signals[key]\n        \n        # DFT Sparsity Calculation\n        dft_coeffs = np.fft.fft(x)\n        K_F = calculate_sparsity(dft_coeffs, alpha)\n        \n        # DWT Sparsity Calculation\n        dwt_coeffs = haar_dwt(x)\n        K_W = calculate_sparsity(dwt_coeffs, alpha)\n        \n        # Sparsity Comparison Indicators\n        F_sparser = K_F < K_W\n        W_sparser = K_W < K_F\n        \n        all_results.append([K_F, K_W, F_sparser, W_sparser])\n\n    # Format the output string exactly as specified\n    case_strings = []\n    for result_case in all_results:\n        kf, kw, fs, ws = result_case\n        case_strings.append(f\"[{kf},{kw},{str(fs)},{str(ws)}]\")\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2450300"}, {"introduction": "在工程和科学领域，我们经常需要将计算模型的输出与实验数据进行比较，它们之间的差异，即“残差”，包含了关于模型不足之处的宝贵信息。本练习将运用多尺度分析的思想，通过离散小波变换（DWT）将残差信号 $r[n] = y_{\\mathrm{exp}}[n] - y_{\\mathrm{model}}[n]$ 分解到不同的尺度（或频率）上。通过分析残差在各个尺度上的能量分布，您可以诊断出模型误差的性质——例如，模型是未能捕捉到缓慢变化的趋势，还是无法准确描述快速发生的瞬态事件 [@problem_id:2450301]。这使得小波分析成为模型验证和改进的强大诊断工具。", "problem": "给定一个离散时间实验信号和一个计算模型的输出，两者均为等长的实值序列。残差定义为 $r[n] = y_{\\mathrm{exp}}[n] - y_{\\mathrm{model}}[n]$，其中 $n \\in \\{0,1,\\dots,N-1\\}$。考虑一种基于 Haar 小波并采用周期性边界条件的正交离散小波变换 (DWT)。单层变换将长度为 $N$ 的序列 $x[n]$ 映射为长度为 $N/2$ 的近似系数序列 $a^{(1)}[k]$ 和细节系数序列 $d^{(1)}[k]$，其计算公式如下：\n$$\na^{(1)}[k] = \\frac{1}{\\sqrt{2}}\\left(x[(2k) \\bmod N] + x[(2k+1) \\bmod N]\\right),\n$$\n$$\nd^{(1)}[k] = \\frac{1}{\\sqrt{2}}\\left(x[(2k) \\bmod N] - x[(2k+1) \\bmod N]\\right),\n$$\n其中 $k \\in \\{0,1,\\dots,N/2-1\\}$。对于深度为 $J$ 的多层分解，递归地定义 $a^{(j)}$，即对 $a^{(j-1)}$ 应用相同的变换，其中 $a^{(0)} \\equiv x$，并收集每一层 $j \\in \\{1,2,\\dots,J\\}$ 的 $d^{(j)}$。对于每一层 $j$，定义细节能量\n$$\nE_j = \\sum_{k=0}^{N/2^j-1} \\left(d^{(j)}[k]\\right)^2.\n$$\n令总细节能量为 $E_{\\mathrm{tot}} = \\sum_{j=1}^{J} E_j$。定义主导层级索引\n$$\nj^{\\star} = \n\\begin{cases}\n\\arg\\max_{j \\in \\{1,\\dots,J\\}} E_j & \\text{若 } E_{\\mathrm{tot}} > 0,\\\\\n0 & \\text{若 } E_{\\mathrm{tot}} = 0,\n\\end{cases}\n$$\n约定如果多个层级达到最大值，则选择其中最小的 $j$。同时定义主导比率\n$$\n\\rho = \n\\begin{cases}\n\\frac{E_{j^{\\star}}}{E_{\\mathrm{tot}}} & \\text{若 } E_{\\mathrm{tot}} > 0,\\\\\n0 & \\text{若 } E_{\\mathrm{tot}} = 0.\n\\end{cases}\n$$\n\n您的任务是，对下方的每个测试用例，确定数对 $[j^{\\star}, \\rho]$，该数对表征了残差能量最集中的尺度以及该尺度的支配程度。三角函数中的角度必须以弧度为单位。使用多层分解深度 $J = 5$ 和信号长度 $N = 256$。\n\n测试套件 (每个用例指定了 $n \\in \\{0,1,\\dots,N-1\\}$ 的 $y_{\\mathrm{exp}}[n]$ 和 $y_{\\mathrm{model}}[n]$)：\n\n- 用例 1 (低频正弦残差)：\n  - $y_{\\mathrm{exp}}[n] = \\sin(2\\pi \\cdot 4 \\cdot \\frac{n}{N})$,\n  - $y_{\\mathrm{model}}[n] = 0$ 对所有 $n$。\n\n- 用例 2 (高频正弦残差)：\n  - $y_{\\mathrm{exp}}[n] = \\sin(2\\pi \\cdot 40 \\cdot \\frac{n}{N})$,\n  - $y_{\\mathrm{model}}[n] = 0$ 对所有 $n$。\n\n- 用例 3 (完美模型，零残差)：\n  - $y_{\\mathrm{exp}}[n] = \\sin(2\\pi \\cdot 10 \\cdot \\frac{n}{N})$,\n  - $y_{\\mathrm{model}}[n] = \\sin(2\\pi \\cdot 10 \\cdot \\frac{n}{N})$。\n\n- 用例 4 (局部瞬态残差)：\n  - $y_{\\mathrm{exp}}[n] = \\exp(-\\frac{(n - 100)^2}{2 \\cdot 5^2})$,\n  - $y_{\\mathrm{model}}[n] = 0$ 对所有 $n$。\n\n您的程序必须为每个用例计算 $r[n]$，执行深度为 $J = 5$ 的 Haar DWT，计算 $j \\in \\{1,2,3,4,5\\}$ 的 $E_j$，然后根据上述定义计算 $j^{\\star}$ 和 $\\rho$。要求的最终输出格式为单行文本，其中包含四个测试用例的结果列表，每个结果是一个数对 $[j^{\\star}, \\rho]$，其中整数 $j^{\\star}$ 和浮点数 $\\rho$ 精确到小数点后六位。该行必须格式化为有效的方括号列表，条目之间用逗号分隔，例如：\n$[[j^{\\star}_1,\\rho_1],[j^{\\star}_2,\\rho_2],[j^{\\star}_3,\\rho_3],[j^{\\star}_4,\\rho_4]]$。", "solution": "用户提供了一个问题，要求使用基于 Haar 小波的多层离散小波变换 (DWT) 分析残差信号。目标是为几个测试用例识别残差中能量集中的主导尺度。从问题验证到求解的整个过程都严格遵守科学和数学上的正确性。\n\n### 步骤 1：问题验证\n\n首先对问题陈述进行严格的验证过程。\n\n- **提取已知条件**：所有定义、常数和公式都按原文提取：\n    - 信号长度 $N=256$，分解深度 $J=5$。\n    - 残差信号：$r[n] = y_{\\mathrm{exp}}[n] - y_{\\mathrm{model}}[n]$。\n    - 对于长度为 $M$ 的序列 $x$ 的单层 Haar DWT 公式：\n        - 近似：$a^{(1)}[k] = \\frac{1}{\\sqrt{2}}(x[(2k) \\bmod M] + x[(2k+1) \\bmod M])$\n        - 细节：$d^{(1)}[k] = \\frac{1}{\\sqrt{2}}(x[(2k) \\bmod M] - x[(2k+1) \\bmod M])$\n        - 变换的递归应用意味着，对于层级 $j$，变换被应用于长度为 $M = N/2^{j-1}$ 的 $a^{(j-1)}$，因此取模运算应相对于 $M$，而不是原始的 $N$。这是对标准多层 DWT 唯一合理的解释。\n    - 层级 $j$ 的细节能量：$E_j = \\sum_{k} (d^{(j)}[k])^2$。\n    - 总细节能量：$E_{\\mathrm{tot}} = \\sum_{j=1}^{J} E_j$。\n    - 主导层级索引 $j^{\\star}$ 和主导比率 $\\rho$，并为 $E_{\\mathrm{tot}}=0$ 的情况和 $\\arg\\max$ 的平局情况制定了特定规则。\n    - 四个测试用例，包含 $y_{\\mathrm{exp}}[n]$ 和 $y_{\\mathrm{model}}[n]$ 的显式函数。\n\n- **验证结论**：问题**有效**。\n    - 它在**科学上基于**成熟的小波分析理论。\n    - 它是**适定的 (well-posed)**，所有定义、算法和参数都已指定，从而导向唯一解。$j^\\star$ 和 $\\rho$ 的定义是明确的。\n    - 它是**客观的**，完全基于数学公式和数值计算。\n    - 它是**完整且一致的**。递归 DWT 的定义略有模糊，但有一个清晰、标准的解释，本解答采用了该解释。\n    - 该问题完全属于计算工程中小波变换的特定主题。\n\n### 步骤 2：求解推导\n\n通过遵循问题陈述中提供的定义来实施解决方案。每个测试用例的总体流程如下：\n1. 计算残差信号 $r[n]$。\n2. 对 $r[n]$ 执行 $J=5$ 层的 DWT，以获得 $j=1, \\dots, 5$ 的细节系数 $d^{(j)}$。\n3. 计算每个细节层级的能量 $E_j$。\n4. 计算总细节能量 $E_{\\mathrm{tot}}$。\n5. 根据提供的规则确定主导层级 $j^{\\star}$ 和主导比率 $\\rho$。\n\n**1. 残差信号生成**\n对于每个测试用例，通过从实验信号 $y_{\\mathrm{exp}}[n]$ 中减去模型输出 $y_{\\mathrm{model}}[n]$ 来计算长度为 $N=256$ 的残差信号 $r[n]$，其中 $n \\in \\{0, 1, \\dots, 255\\}$。\n\n**2. 多层 Haar DWT**\n设计一个函数来执行一层 Haar DWT。输入是长度为 $M$ 的信号 $x$。输出是近似系数 $a$ 和细节系数 $d$，两者长度均为 $M/2$。所提供的公式可以简化为成对操作。对于 $k \\in \\{0, 1, \\dots, M/2-1\\}$：\n$$\na[k] = \\frac{1}{\\sqrt{2}}(x[2k] + x[2k+1])\n$$\n$$\nd[k] = \\frac{1}{\\sqrt{2}}(x[2k] - x[2k+1])\n$$\n该操作可使用 `numpy` 中的向量化运算高效实现。多层分解从残差信号 $r[n]$ 开始，将其作为初始近似系数 $a^{(0)}$。然后递归地应用单层 DWT 共 $J=5$ 次。在每个层级 $j$ 中，近似系数 $a^{(j-1)}$ 被分解为 $a^{(j)}$ 和 $d^{(j)}$。收集每个层级的细节系数 $d^{(j)}$。\n\n**3. 能量计算**\n对于每组细节系数 $d^{(j)}$，通过对其元素平方求和来计算相应的能量 $E_j$，即根据定义 $E_j = \\sum_{k} (d^{(j)}[k])^2$。这等同于系数向量的 $L^2$-范数的平方。总细节能量 $E_{\\mathrm{tot}}$ 是这些单个层级能量的总和。\n\n**4. 主导尺度和比率计算**\n最终分析取决于 $E_{\\mathrm{tot}}$ 的值。\n- 如果 $E_{\\mathrm{tot}}$ 实际上为零（低于一个小的浮点容差，例如 $10^{-12}$），则根据定义，$j^{\\star} = 0$ 且 $\\rho = 0$。这种情况适用于残差信号为常数（包括零）时，因为 Haar 细节系数将全部为零。\n- 如果 $E_{\\mathrm{tot}} > 0$，通过识别具有最大能量的层级来找到主导层级 $j^{\\star}$，$j^{\\star} = \\arg\\max_{j \\in \\{1,\\dots,5\\}} E_j$。问题指定，在出现平局的情况下，选择最小的 $j$。`numpy.argmax` 函数自然满足此要求，因为它返回第一个最大值的索引。然后，主导比率计算为 $\\rho = E_{j^{\\star}} / E_{\\mathrm{tot}}$。\n\n**5. 测试用例分析**\n- **用例 1 (低频)：** 残差是一个频率为 $f=4/256 = 1/64$ 周/样本的正弦波。DWT 充当一个滤波器组，该频率落入与细节层级 $j=5$ 对应的频带中。因此，我们预期 $j^{\\star}=5$。\n- **用例 2 (高频)：** 残差是一个频率为 $f=40/256 = 5/32$ 周/样本的正弦波。该频率在与细节层级 $j=2$ 对应的频带内。因此，我们预期 $j^{\\star}=2$。\n- **用例 3 (零残差)：** 残差恒为零。所有细节系数和能量都将为零。因此，$E_{\\mathrm{tot}}=0$，从而得到 $j^{\\star}=0$ 和 $\\rho=0$。\n- **用例 4 (局部瞬态)：** 残差是一个窄高斯脉冲。这样的特征在时间上是局部的，在频率上是宽泛的，这意味着其能量分布在多个尺度上。该特征的尺度（宽度 $\\sigma=5$）与大小相似的小波尺度最匹配。层级 $j$ 对应于大小为 $2^j$ 的特征。由于 $2^2=4$ 和 $2^3=8$，预计能量将集中在层级 $j=2$ 和 $j=3$ 附近。具体计算将揭示主导的层级。\n\n最终计算出的值按照规定格式化为字符串，其中浮点数 $\\rho$ 使用标准舍入约定（四舍五入）表示，精确到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef dwt_level(x: np.ndarray) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Computes one level of the Haar Discrete Wavelet Transform.\n    The implementation is a vectorized version of the formulas given in the problem.\n    \"\"\"\n    # The formulas are x[2k] and x[2k+1], which corresponds to even and odd indices.\n    x_even = x[0::2]\n    x_odd = x[1::2]\n    \n    inv_sqrt2 = 1.0 / np.sqrt(2.0)\n    \n    # Approximation coefficients\n    a_next = (x_even + x_odd) * inv_sqrt2\n    \n    # Detail coefficients\n    d_next = (x_even - x_odd) * inv_sqrt2\n    \n    return a_next, d_next\n\ndef analyze_residual(r: np.ndarray, J: int) -> list:\n    \"\"\"\n    Performs a J-level DWT on the residual signal r and computes\n    the dominant level index j_star and dominance ratio rho.\n    \"\"\"\n    # Perform J-level DWT and collect detail coefficients\n    all_details = []\n    a_current = r.copy()\n    for _ in range(J):\n        a_current, d_next = dwt_level(a_current)\n        all_details.append(d_next)\n    \n    # Compute energies for each level\n    # E_j = sum(d_j[k]^2)\n    energies = [np.sum(d**2) for d in all_details]\n    \n    # Compute total detail energy\n    total_energy = np.sum(energies)\n    \n    # A small tolerance for floating-point comparison with zero\n    if total_energy > 1e-12:\n        max_energy = np.max(energies)\n        # np.argmax returns the first index of the maximum value,\n        # satisfying the tie-breaking rule (smallest j).\n        # Levels are 1-indexed, so we add 1.\n        j_star = np.argmax(energies) + 1\n        rho = max_energy / total_energy\n    else:\n        # If total energy is zero, use the specified values.\n        j_star = 0\n        rho = 0.0\n        \n    return [j_star, rho]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Global parameters from the problem statement\n    N = 256\n    J = 5\n    n = np.arange(N)\n    \n    # Define the test cases\n    test_cases = [\n        # Case 1: Low-frequency sinusoidal residual\n        (\n            np.sin(2 * np.pi * 4 * n / N),\n            np.zeros(N)\n        ),\n        # Case 2: High-frequency sinusoidal residual\n        (\n            np.sin(2 * np.pi * 40 * n / N),\n            np.zeros(N)\n        ),\n        # Case 3: Perfect model, zero residual\n        (\n            np.sin(2 * np.pi * 10 * n / N),\n            np.sin(2 * np.pi * 10 * n / N)\n        ),\n        # Case 4: Localized transient residual\n        (\n            np.exp(-(n - 100)**2 / (2 * 5**2)),\n            np.zeros(N)\n        )\n    ]\n\n    results = []\n    for y_exp, y_mod in test_cases:\n        # Calculate the residual signal for the current case\n        residual = y_exp - y_mod\n        \n        # Analyze the residual and get [j*, rho]\n        result = analyze_residual(residual, J)\n        results.append(result)\n\n    # Format the final output string precisely as required: [[j1,rho1],[j2,rho2],...]\n    # The format string {res[1]:.6f} ensures rho is rounded to 6 decimal places.\n    result_strings = [f\"[{res[0]},{res[1]:.6f}]\" for res in results]\n    final_output = \"[\" + \",\".join(result_strings) + \"]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2450301"}]}