{"hands_on_practices": [{"introduction": "我们通过最基本的蒙特卡洛方法应用——通过随机抽样估算概率——来开始我们的实践。我们将通过解决一个数论问题来探索这一思想：确定一个随机选择的整数是“无平方因子数”的概率。这个练习 [@problem_id:2415243] 让你亲身体验如何实现一个简单的“接受-拒绝”估计器，其中指标函数的样本均值会收敛到我们试图寻找的真实概率。", "problem": "你需要编写一个完整的程序，该程序计算一个从基本原理定义的概率的估计值。一个正整数 $k$ 被称为无平方因子数（square-free），当且仅当不存在整数 $d \\ge 2$ 使得 $d^2$ 整除 $k$。令 $p$ 表示一个均匀选取的正整数为无平方因子数的极限概率，该概率可理解为自然密度 $$p = \\lim_{n \\to \\infty} \\frac{1}{n}\\sum_{k=1}^{n} \\mathbf{1}\\{\\text{$k$ 是无平方因子数}\\}.$$ 对于有限的 $n$，定义有限总体概率 $$p_n = \\frac{1}{n}\\sum_{k=1}^{n} \\mathbf{1}\\{\\text{$k$ 是无平方因子数}\\}.$$ 对于每个测试用例，你必须输出一个实数，该实数是基于随机抽样得到的 $p_n$ 的估计值，并满足以下条件：对于参数为 $(n,m,s)$ 的测试用例，其计算必须仅依赖于由一个以种子 $s$ 初始化的伪随机数生成器（PRNG）所产生的、从 $\\{1,2,\\dots,n\\}$ 上的离散均匀分布中抽取的 $m$ 个独立随机变量。不提供外部输入。\n\n你的程序必须不接受任何输入，并且必须处理以下有序三元组 $(n,m,s)$ 的测试套件：\n- $(n,m,s) = (10^6, 200000, 17)$\n- $(n,m,s) = (1, 10000, 99)$\n- $(n,m,s) = (100, 5000, 2024)$\n- $(n,m,s) = (10^5, 150000, 123456)$\n- $(n,m,s) = (50, 10000, 314159)$\n\n最终输出要求：\n- 对于每个测试用例，输出一个实数，即为你的 $p_n$ 的估计值，四舍五入到 $6$ 位小数。\n- 将所有测试用例的结果，按所列顺序，汇总到单行输出中，形式为一个由方括号括起来的逗号分隔列表，例如 $[x_1,x_2,x_3,x_4,x_5]$，其中每个 $x_i$ 是一个小数点后恰好有 $6$ 位数字的实数。", "solution": "首先必须对所提出的问题进行科学合理性、清晰性和完整性的验证。\n\n**第一步：提取已知信息**\n- **定义**：一个正整数 $k$ 是无平方因子数，当且仅当不存在整数 $d \\ge 2$ 使得 $d^2$ 整除 $k$。\n- **极限概率**：$p = \\lim_{n \\to \\infty} \\frac{1}{n}\\sum_{k=1}^{n} \\mathbf{1}\\{\\text{$k$ 是无平方因子数}\\}$。\n- **有限总体概率**：$p_n = \\frac{1}{n}\\sum_{k=1}^{n} \\mathbf{1}\\{\\text{$k$ 是无平方因子数}\\}$。\n- **任务**：为每个参数集 $(n, m, s)$ 估计 $p_n$。\n- **方法**：估计值必须仅从 $\\{1, 2, \\dots, n\\}$ 上的离散均匀分布中抽取的 $m$ 个独立随机变量推导得出。\n- **可复现性**：伪随机数生成器（PRNG）必须使用给定的种子 $s$ 进行初始化。\n- **测试用例**：\n    - $(n, m, s) = (10^6, 200000, 17)$\n    - $(n, m, s) = (1, 10000, 99)$\n    - $(n, m, s) = (100, 5000, 2024)$\n    - $(n, m, s) = (10^5, 150000, 123456)$\n    - $(n, m, s) = (50, 10000, 314159)$\n- **输出格式**：包含一个逗号分隔的估计值列表的单行文本，每个估计值四舍五入到 $6$ 位小数。\n\n**第二步：使用提取的已知信息进行验证**\n根据所需标准对问题进行评估：\n- **科学性**：无平方因子数的概念是数论中的一个基本主题。使用蒙特卡洛模拟来估计概率是计算科学与工程中的一种标准且稳健的技术。该问题牢固地植根于已建立的数学和计算原理。\n- **适定性**：该问题对要估计的量 $p_n$ 提供了清晰明确的定义。它指定了总体（$\\{1, \\dots, n\\}$）、抽样分布（均匀分布）、样本大小（$m$）和伪随机数生成器种子（$s$）。这是一个蒙特卡洛实验的完整规范，保证了每个测试用例都有一个唯一的、确定性的结果。\n- **客观性**：该问题以精确的数学语言陈述，没有任何主观性或模糊性。\n\n**第三步：结论与行动**\n问题被判定为**有效**。这是一个基于可靠数学原理的、定义明确的计算问题。现在将开发一个完整的解决方案。\n\n**基于原理的解决方案**\n\n目标是估计从集合 $\\{1, 2, \\dots, n\\}$ 中均匀随机选取一个正整数为无平方因子数的概率 $p_n$。该概率被定义为一个指示随机变量的均值。令 $K$ 为一个在 $\\{1, 2, \\dots, n\\}$ 上服从离散均匀分布的随机变量。那么，\n$$p_n = \\mathbb{E}[\\mathbf{1}\\{K \\text{ 是无平方因子数}\\}]$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。\n\n蒙特卡洛方法为估计此类期望提供了一种强有力的方式。根据大数定律，独立同分布随机变量的样本均值收敛于真实期望。我们从 $K$ 的分布中生成 $m$ 个独立样本 $k_1, k_2, \\dots, k_m$。$p_n$ 的蒙特卡洛估计量，记作 $\\hat{p}_{n,m}$，是在这些样本上评估的指示函数的样本均值：\n$$\\hat{p}_{n,m} = \\frac{1}{m} \\sum_{i=1}^{m} \\mathbf{1}\\{k_i \\text{ 是无平方因子数}\\}$$\n这等价于计算无平方因子样本的数量，然后除以总样本数 $m$。\n\n核心计算任务是实现一个函数，该函数能正确判断一个整数 $k$ 是否是无平方因子数。一个正整数 $k$ 是无平方因子数，如果它不能被任何大于 $1$ 的完全平方数整除。我们只需检查是否能被素数的平方整除。如果 $k$ 能被一个合数的平方 $(ab)^2$ 整除，那么它也能被 $ab$ 的素因子的平方整除。因此，一个数 $k$是无平方因子数，当且仅当对于每个素数 $p$，$p^2$ 都不能整除 $k$。\n\n对于一个给定的整数 $k$，我们只需要对满足 $p^2 \\le k$ 的素数 $p$ 进行检查。为了在多次调用中高效地实现此测试，预先计算出所有素数直到 $\\sqrt{\\max(n)}$ 是有利的，其中 $\\max(n)$ 是所有测试用例中 $n$ 的最大值。在本问题中，$\\max(n) = 10^6$，所以我们需要计算到 $\\sqrt{10^6} = 1000$ 的所有素数。Sieve of Eratosthenes 是一种用于此目的的经典且高效的算法。\n\n对于每个测试用例 $(n, m, s)$ 的总体算法如下：\n1.  **预计算**：使用 Sieve of Eratosthenes 生成所有直到 $1000$ 的素数列表。这个操作对所有测试用例只执行一次。\n2.  **初始化**：使用指定的种子 $s$ 初始化一个伪随机数生成器（PRNG）。\n3.  **抽样**：从 $\\{1, 2, \\dots, n\\}$ 上的离散均匀分布中抽取 $m$ 个随机整数 $k_1, k_2, \\dots, k_m$。\n4.  **计数**：初始化一个计数器为零。对于每个样本 $k_i$，使用预先计算好的素数列表测试它是否为无平方因子数。如果 $k_i$ 是无平方因子数，则计数器加一。\n5.  **估计**：将最终计数值除以样本大小 $m$，计算估计值 $\\hat{p}_{n,m}$。\n6.  **格式化**：将估计值四舍五入到 $6$ 位小数。\n\n对于给定的测试用例，此过程是确定性的，并将产生一个单一、可验证的 $p_n$ 估计值。然后将所有测试用例的结果汇总成指定的最终输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"\n    Generates a list of prime numbers up to a given limit using the Sieve of Eratosthenes.\n    \"\"\"\n    if limit  2:\n        return []\n    \n    prime_flags = [True] * (limit + 1)\n    prime_flags[0] = prime_flags[1] = False\n    \n    for i in range(2, int(np.sqrt(limit)) + 1):\n        if prime_flags[i]:\n            for multiple in range(i * i, limit + 1, i):\n                prime_flags[multiple] = False\n                \n    primes = [i for i, is_p in enumerate(prime_flags) if is_p]\n    return primes\n\ndef is_square_free(k, primes):\n    \"\"\"\n    Checks if an integer k is square-free using a pre-computed list of primes.\n    A number is square-free if it is not divisible by any square of a prime.\n    \"\"\"\n    if k == 1:\n        return True\n    \n    for p in primes:\n        p_squared = p * p\n        if p_squared > k:\n            # If p^2 > k, no larger prime's square can be a factor.\n            break\n        if k % p_squared == 0:\n            return False\n            \n    # If no prime square up to k divides k, it is square-free.\n    return True\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and compute Monte Carlo estimates.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (10**6, 200000, 17),\n        (1, 10000, 99),\n        (100, 5000, 2024),\n        (10**5, 150000, 123456),\n        (50, 10000, 314159)\n    ]\n\n    # Pre-compute primes required for the largest n in the test suite.\n    # The check is efficient if we have primes up to sqrt(max_n).\n    max_n = max(tc[0] for tc in test_cases if tc[0] > 1) if test_cases else 1\n    prime_limit = int(np.sqrt(max_n))\n    primes = sieve_of_eratosthenes(prime_limit)\n\n    results = []\n    for n, m, s in test_cases:\n        # Handle the trivial case where n=1. The only possible sample is 1,\n        # which is square-free. The probability is exactly 1.\n        if n == 1:\n            results.append(1.0)\n            continue\n            \n        # Initialize the random number generator with the specified seed.\n        rng = np.random.default_rng(seed=s)\n        \n        # Generate m independent random integers from {1, 2, ..., n}.\n        samples = rng.integers(low=1, high=n, size=m, endpoint=True)\n        \n        # Count how many of the samples are square-free.\n        square_free_count = 0\n        for k in samples:\n            if is_square_free(k, primes):\n                square_free_count += 1\n                \n        # The estimate for p_n is the fraction of square-free samples.\n        estimate = square_free_count / m\n        results.append(estimate)\n\n    # Format results to 6 decimal places and print in the required format.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2415243"}, {"introduction": "在掌握了基本概率估计之后，我们现在将“接受-拒绝”方法推广到连续的几何情境中。我们将通过在一个简单的形状（超立方体）中进行抽样，来估计一个更复杂的内切形状（超球体）的体积。这个经典的练习 [@problem_id:2415275] 不仅展示了一种估算高维积分的实用方法，还生动地揭示了“维度灾难”——这是高维数据分析和物理学中的一个关键概念。通过解决这个问题，你将对高维空间为何如此违反直觉地“空旷”获得深刻的理解。", "problem": "你的任务是研究一个$d$维超球体的体积与一个$d$维超立方体的体积之比如何随维度$d$变化。令 $C_d = [-1,1]^d \\subset \\mathbb{R}^d$ 表示以原点为中心、边长为2的超立方体，令 $S_d = \\{x \\in \\mathbb{R}^d : \\lVert x \\rVert_2 \\le 1\\}$ 表示$d$维欧几里得空间中的单位超球体。定义比率 $R(d)$ 为\n$$\nR(d) = \\frac{\\mathrm{Vol}(S_d)}{\\mathrm{Vol}(C_d)}.\n$$\n对于给定的正整数 $N$ 和整数种子 $s$，令 $X_1,\\dots,X_N$ 为由以种子 $s$ 初始化的伪随机数生成器确定的、在 $C_d$ 上均匀分布的独立同分布随机向量。定义估计量\n$$\n\\widehat{R}_N(d,s) \\equiv \\frac{1}{N} \\sum_{i=1}^N \\mathbf{1}\\{\\lVert X_i \\rVert_2 \\le 1\\},\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数，$\\lVert \\cdot \\rVert_2$ 是欧几里得范数。对于下方的每个测试用例，计算单个实数 $\\widehat{R}_N(d,s)$。\n\n所有答案必须是无量纲的实数。将每个结果四舍五入到恰好 $6$ 位小数。\n\n测试套件（每项为 $(d,N,s)$）：\n- $(1, 20000, 7)$\n- $(2, 100000, 11)$\n- $(8, 300000, 2025)$\n- $(12, 500000, 123)$\n- $(20, 500000, 99991)$\n\n最终输出格式：你的程序应生成单行输出，其中包含与测试套件顺序相同的、以逗号分隔并用方括号括起来的结果列表。例如，通用格式为 [$x_1,x_2,x_3,x_4,x_5$]，其中每个 $x_i$ 都是如上所述四舍五入到恰好 $6$ 位小数的实数。", "solution": "该问题要求计算一个蒙特卡洛估计量，用于估算$d$维超球体与$d$维超立方体的体积之比。我将首先验证问题陈述，然后基于计算科学的基本原理提供一个完整的解决方案。\n\n### 问题验证\n\n**步骤1：提取给定信息**\n\n问题提供了以下定义和参数：\n- 超立方体：$C_d = [-1,1]^d \\subset \\mathbb{R}^d$。这是一个以原点为中心、边长为2的超立方体。\n- 超球体：$S_d = \\{x \\in \\mathbb{R}^d : \\lVert x \\rVert_2 \\le 1\\}$。这是一个以原点为中心、完全内切于超立方体 $C_d$ 的单位超球体。\n- 体积之比：$R(d) = \\frac{\\mathrm{Vol}(S_d)}{\\mathrm{Vol}(C_d)}$。\n- 随机向量：$X_1,\\dots,X_N$ 是在 $C_d$ 上均匀分布的独立同分布 (i.i.d.) 随机向量。它们的生成由一个以整数种子 $s$ 初始化的伪随机数生成器确定。\n- 估计量：$\\widehat{R}_N(d,s) \\equiv \\frac{1}{N} \\sum_{i=1}^N \\mathbf{1}\\{\\lVert X_i \\rVert_2 \\le 1\\}$，其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数，$\\lVert \\cdot \\rVert_2$ 是欧几里得范数。\n- 测试用例（以 $(d, N, s)$ 元组形式）：\n    - $(1, 20000, 7)$\n    - $(2, 100000, 11)$\n    - $(8, 300000, 2025)$\n    - $(12, 500000, 123)$\n    - $(20, 500000, 99991)$\n- 输出规格：每个数值结果必须四舍五入到恰好 $6$ 位小数。\n\n**步骤2：使用提取的给定信息进行验证**\n\n我现在将根据既定标准评估该问题的有效性。\n- **科学依据**：该问题是蒙特卡洛积分的一个经典应用，这是计算物理、工程和应用数学中一种基础且广泛使用的技术。超球体、超立方体和蒙特卡洛估计量的定义都是标准的且在数学上是正确的。该问题建立在概率论和统计估计的原理之上。它完全合理。\n- **适定性**：该问题是适定的。对于每个测试用例，都提供了所有必需的参数（$d$、$N$、$s$）。使用带种子的伪随机数生成器确保了随机向量序列 $X_i$ 是确定性的，从而为估计量 $\\widehat{R}_N(d,s)$ 带来一个唯一且可计算的值。\n- **客观性**：该问题使用精确、无歧义的数学语言陈述。它不含任何主观或推测性内容。\n\n基于此分析，该问题未表现出验证清单中列出的任何缺陷。它是科学合理的、适定的、客观的，并且与蒙特卡洛方法的指定主题直接相关。\n\n**步骤3：结论与行动**\n\n该问题是**有效的**。我将继续制定并展示解决方案。\n\n### 解决方案\n\n目标是为多个测试用例计算估计量 $\\widehat{R}_N(d,s)$。该估计量近似于比率 $R(d) = \\frac{\\mathrm{Vol}(S_d)}{\\mathrm{Vol}(C_d)}$。所用方法基于蒙特卡洛积分的原理。\n\n令 $X$ 为在超立方体 $C_d$ 中均匀分布的随机向量。此向量落在内切超球体 $S_d$ 内的概率由它们的体积之比给出：\n$$\nP(X \\in S_d) = \\frac{\\int_{C_d} \\mathbf{1}\\{x \\in S_d\\} dx}{\\int_{C_d} 1 dx} = \\frac{\\mathrm{Vol}(S_d)}{\\mathrm{Vol}(C_d)} = R(d)\n$$\n其中 $\\mathbf{1}\\{x \\in S_d\\}$ 是指示函数，如果 $x \\in S_d$ 则为1，否则为0。\n\n问题为此概率定义了一个估计量。我们生成 $N$ 个独立的随机向量 $X_1, X_2, \\dots, X_N$，每个都在 $C_d$ 中均匀分布。对于每个向量 $X_i$，我们定义一个伯努利随机变量 $Z_i = \\mathbf{1}\\{X_i \\in S_d\\}$。条件 $X_i \\in S_d$ 等价于 $\\lVert X_i \\rVert_2 \\le 1$。每个 $Z_i$ 的期望值恰好是概率 $R(d)$：\n$$\nE[Z_i] = 1 \\cdot P(Z_i=1) + 0 \\cdot P(Z_i=0) = P(X_i \\in S_d) = R(d)\n$$\n估计量 $\\widehat{R}_N(d,s)$ 是这 $N$ 次伯努利试验的样本均值：\n$$\n\\widehat{R}_N(d,s) = \\frac{1}{N} \\sum_{i=1}^N Z_i = \\frac{1}{N} \\sum_{i=1}^N \\mathbf{1}\\{\\lVert X_i \\rVert_2 \\le 1\\}\n$$\n根据大数定律，当 $N$ 趋于无穷大时，该样本均值收敛于真实期望值：\n$$\n\\lim_{N \\to \\infty} \\widehat{R}_N(d,s) = R(d)\n$$\n这为该方法提供了理论依据。为给定参数集 $(d, N, s)$ 计算 $\\widehat{R}_N(d,s)$ 的规定算法如下：\n\n1.  **初始化**：使用指定的整数种子 $s$ 初始化一个伪随机数生成器。这确保了结果的可复现性。\n\n2.  **样本生成**：生成一组 $N$ 个随机向量 $\\{X_1, \\dots, X_N\\}$，其中每个 $X_i = (x_{i1}, x_{i2}, \\dots, x_{id})$ 是 $\\mathbb{R}^d$ 中的一个点。为确保向量在超立方体 $C_d = [-1, 1]^d$ 中均匀分布，每个分量 $x_{ij}$ 必须从均匀分布 $U[-1, 1]$ 中抽取。这在计算上通过生成一个 $N \\times d$ 的浮点数矩阵来实现，其中每个条目都是来自 $U[-1, 1]$ 的独立样本。\n\n3.  **条件检查**：对每个向量 $X_i$，判断它是否位于单位超球体 $S_d$ 内。这通过检查其欧几里得范数是否小于或等于1来完成。为提高计算效率，最好检查范数的平方：\n    $$\n    \\lVert X_i \\rVert_2 \\le 1 \\iff \\lVert X_i \\rVert_2^2 \\le 1^2 \\iff \\sum_{j=1}^d x_{ij}^2 \\le 1\n    $$\n    这避免了计算成本高昂的平方根运算。\n\n4.  **估计**：计算满足上一步条件的向量数量，我们称之为 $M$。这个计数等价于指示函数的总和：$M = \\sum_{i=1}^N \\mathbf{1}\\{\\lVert X_i \\rVert_2^2 \\le 1\\}$。然后蒙特卡洛估计值通过以下比率计算得出：\n    $$\n    \\widehat{R}_N(d,s) = \\frac{M}{N}\n    $$\n5.  **最终处理**：对每个测试用例 $(d, N, s)$ 重复此过程，并将所得估计值按要求四舍五入至6位小数。“维度灾难”现象将会变得明显，即对于高维度 $d$，超球体的体积相对于超立方体变得极小，估计值 $\\widehat{R}_N(d,s)$ 会迅速趋近于零。对于 $d=20$，统计上很可能 $M=0$，从而得到估计值0。\n\n这就完成了理论框架和算法设计。实现将基于此逻辑进行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Monte Carlo estimate of the ratio of a d-dimensional hypersphere's\n    volume to that of its enclosing hypercube for a given set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is in the format (d, N, s), where:\n    # d: dimension of the space\n    # N: number of samples\n    # s: seed for the pseudo-random number generator\n    test_cases = [\n        (1, 20000, 7),\n        (2, 100000, 11),\n        (8, 300000, 2025),\n        (12, 500000, 123),\n        (20, 500000, 99991)\n    ]\n\n    results = []\n    for d, N, s in test_cases:\n        # Initialize the pseudo-random number generator with the specified seed for reproducibility.\n        rng = np.random.default_rng(s)\n\n        # Generate N random vectors in d-dimensional space.\n        # Each component of each vector is drawn from the uniform distribution on [-1, 1].\n        # This creates an N x d matrix of points uniformly sampled from the hypercube C_d.\n        # The size parameter is (number of rows, number of columns), i.e., (N, d).\n        samples = rng.uniform(-1, 1, size=(N, d))\n\n        # For each sample vector, calculate its squared Euclidean norm.\n        # This is more computationally efficient than calculating the norm itself,\n        # as it avoids the square root operation.\n        # The condition ||x||_2 = 1 is equivalent to ||x||_2^2 = 1.\n        # The sum is performed along axis=1 to sum the squared components for each vector (row).\n        squared_norms = np.sum(samples**2, axis=1)\n\n        # Count the number of samples whose squared norm is less than or equal to 1.\n        # These are the points that lie within the unit hypersphere S_d.\n        count_inside = np.sum(squared_norms = 1)\n\n        # The estimator is the ratio of points inside the hypersphere to the total number of points.\n        # This ratio approximates the volume ratio R(d).\n        estimate = count_inside / N\n\n        # Per the problem specification, the final result must be rounded to 6 decimal places.\n        # We format the number as a string to ensure exactly 6 decimal places are shown.\n        results.append(f\"{estimate:.6f}\")\n\n    # Final print statement in the exact required format: a comma-separated list in brackets.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2415275"}, {"introduction": "当简单的均匀抽样效率低下时，例如当函数在某些区域出现奇点或尖峰时，我们该怎么办？这个高级练习将介绍一种强大的方差缩减技术：重要性抽样。通过估计一个带有奇点的积分 [@problem_id:2415223]，你将学习如何根据被积函数的形式，明智地选择一个非均匀的“提议分布”，从而显著提高估计器的效率和准确性。这项技能对于解决那些简单抽样方法无能为力的复杂现实世界计算问题是不可或缺的。", "problem": "构建一个 Monte Carlo 重要性抽样估计量，用于计算形如 $$I=\\int_{0}^{1} x^{-a}(1-x)^{-b}\\,g(x)\\,dx$$ 的积分，其中 $0 \\lt a \\lt 1$，$0 \\le b \\lt 1$，且 $g(x)$ 是在 $[0,1]$ 上的有界连续函数。从 Monte Carlo 积分和重要性抽样的核心定义出发：如果 $p(x)$ 是在 $(0,1)$ 上严格为正的任意概率密度函数，那么 $$I=\\int_{0}^{1} \\frac{x^{-a}(1-x)^{-b}\\,g(x)}{p(x)}\\,p(x)\\,dx=\\mathbb{E}_{p}\\!\\left[\\frac{x^{-a}(1-x)^{-b}\\,g(X)}{p(X)}\\right],$$ 其中 $X \\sim p$。您的任务是：\n- 从第一性原理出发，推导对 $p(x)$ 的条件，以确保对于给定这类在端点处具有奇点的被积函数，该估计量是无偏的且具有有限方差。\n- 以一种有原则的方式选择一个能捕捉 $x^{-a}(1-x)^{-b}$ 端点行为的密度函数 $p(x)$，并根据被积函数的结构以及 Beta 函数 $B(\\alpha,\\beta)=\\int_{0}^{1} x^{\\alpha-1}(1-x)^{\\beta-1}\\,dx$（其中 $\\alpha \\gt 0$ 且 $\\beta \\gt 0$）的定义来证明您选择的合理性。\n- 将您的选择转化为一个具体的、可在算法上实现的抽样方案，该方案能为 $I$ 生成一个无偏估计量，并且在端点处不会出现数值不稳定性。\n\n实现一个完整、可运行的程序，该程序：\n- 为了可复现性，使用单一共享的伪随机种子 $s=20231105$。\n- 对于下方的每个测试用例，从您选择的 $p(x)$ 中抽取一个大小为 $N$ 的独立样本，并返回 $I$ 的单个 Monte Carlo 估计值 $\\widehat{I}$。\n- 所有三角函数均使用弧度作为角度单位。\n- 生成仅包含一行输出，其中包含结果，结果为逗号分隔的列表，并用方括号括起，按测试用例的顺序排列。\n\n测试套件（每个用例指定了 $(a,b,g,N)$）：\n- 用例 1：$a=\\tfrac{1}{2}$，$b=0$，$g(x)=\\exp(x)$，$N=200000$。\n- 用例 2：$a=0.9$，$b=0$，$g(x)=\\cos(x)$，$N=600000$。\n- 用例 3：$a=0.49$，$b=0.49$，$g(x)=\\sin(3x)$，$N=400000$。\n- 用例 4：$a=0.99$，$b=0$，$g(x)=1$，$N=100000$。\n- 用例 5：$a=0.1$，$b=0.9$，$g(x)=\\exp(2x)$，$N=500000$。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是用例 $i$ 的 Monte Carlo 估计值。不涉及任何物理单位，输出为实数。三角函数必须使用弧度作为角度单位。不要读取任何输入；程序必须能直接运行，并且仅使用指定的种子和指定的样本大小。", "solution": "在尝试任何解决方案之前，需对问题陈述进行验证。\n\n**步骤 1：提取给定的信息**\n- 待求积分的形式为 $I=\\int_{0}^{1} x^{-a}(1-x)^{-b}\\,g(x)\\,dx$。\n- 参数 $a$ 和 $b$ 受限于 $0  a  1$ 和 $0 \\le b  1$。\n- 函数 $g(x)$ 被指定为区间 $[0,1]$ 上的有界连续函数。\n- Monte Carlo 重要性抽样估计量从其第一性原理定义：$I=\\mathbb{E}_{p}\\!\\left[\\frac{x^{-a}(1-x)^{-b}\\,g(X)}{p(X)}\\right]$，其中 $p(x)$ 是一个支撑集在 $(0,1)$ 上的概率密度函数，且 $X \\sim p$。\n- Beta 函数定义为 $B(\\alpha,\\beta)=\\int_{0}^{1} x^{\\alpha-1}(1-x)^{\\beta-1}\\,dx$，其中 $\\alpha  0$ 且 $\\beta  0$。\n- 实现要求伪随机种子为 $s=20231105$，每个用例的独立样本大小为 $N$，并且三角函数使用弧度作为角度单位。\n- 测试套件如下：\n  - 用例 1：$(a,b,g,N) = (\\tfrac{1}{2}, 0, \\exp(x), 200000)$。\n  - 用例 2：$(a,b,g,N) = (0.9, 0, \\cos(x), 600000)$。\n  - 用例 3：$(a,b,g,N) = (0.49, 0.49, \\sin(3x), 400000)$。\n  - 用例 4：$(a,b,g,N) = (0.99, 0, 1, 100000)$。\n  - 用例 5：$(a,b,g,N) = (0.1, 0.9, \\exp(2x), 500000)$。\n\n**步骤 2：验证给定的信息**\n该问题是科学上合理的、适定的和客观的。这是一个关于 Monte Carlo 方法的计算科学标准问题。约束条件 $0  a  1$ 和 $0 \\le b  1$ 确保了被积函数在 $x=0$ 和 $x=1$ 处的奇点是可积的，从而保证了积分 $I$ 是有限且良定义的。构建解决方案所需的所有必要数据和定义均已提供。该问题没有矛盾、歧义或依赖于非科学前提。\n\n**步骤 3：结论与行动**\n问题有效。将提供一个解决方案。\n\n令被积函数表示为 $f(x) = x^{-a}(1-x)^{-b}\\,g(x)$。积分为 $I = \\int_{0}^{1} f(x) dx$。基于从 $p(x)$ 中抽取的 $N$ 个独立同分布样本 $X_i \\sim p(x)$，对 $I$ 的 Monte Carlo 重要性抽样估计量由下式给出：\n$$ \\widehat{I}_N = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{f(X_i)}{p(X_i)} $$\n\n**无偏性和有限方差条件的推导**\n\n首先，我们讨论估计量无偏的条件。该估计量的期望是：\n$$ \\mathbb{E}_p[\\widehat{I}_N] = \\mathbb{E}_p\\left[\\frac{1}{N} \\sum_{i=1}^{N} \\frac{f(X_i)}{p(X_i)}\\right] = \\frac{1}{N} \\sum_{i=1}^{N} \\mathbb{E}_p\\left[\\frac{f(X_i)}{p(X_i)}\\right] = \\mathbb{E}_p\\left[\\frac{f(X)}{p(X)}\\right] $$\n根据连续随机变量的期望定义，这等于：\n$$ \\mathbb{E}_p\\left[\\frac{f(X)}{p(X)}\\right] = \\int_{\\text{supp}(p)} \\frac{f(x)}{p(x)} p(x) dx = \\int_{\\text{supp}(p)} f(x) dx $$\n为使估计量无偏，即 $\\mathbb{E}_p[\\widehat{I}_N] = I = \\int_{0}^{1} f(x) dx$，我们必须有 $\\int_{\\text{supp}(p)} f(x) dx = \\int_{0}^{1} f(x) dx$。如果 $p(x)$ 的支撑集包含了 $f(x)$ 非零的区域，这个条件就能得到保证。形式上，该条件是对于任何 $x \\in (0,1)$，若 $f(x) \\neq 0$，则 $p(x)  0$。我们将要求对于所有 $x \\in (0,1)$，都有 $p(x)  0$。\n\n其次，我们讨论估计量具有有限方差的条件。该估计量的方差是：\n$$ \\text{Var}_p(\\widehat{I}_N) = \\frac{1}{N} \\text{Var}_p\\left(\\frac{f(X)}{p(X)}\\right) $$\n当且仅当随机变量 $\\frac{f(X)}{p(X)}$ 的二阶矩是有限时，方差才是有限的。这要求：\n$$ \\mathbb{E}_p\\left[\\left(\\frac{f(X)}{p(X)}\\right)^2\\right] = \\int_{0}^{1} \\frac{f(x)^2}{p(x)} dx  \\infty $$\n代入 $f(x) = x^{-a}(1-x)^{-b}\\,g(x)$，该条件变为：\n$$ \\int_{0}^{1} \\frac{\\left(x^{-a}(1-x)^{-b}\\,g(x)\\right)^2}{p(x)} dx = \\int_{0}^{1} \\frac{x^{-2a}(1-x)^{-2b}\\,g(x)^2}{p(x)} dx  \\infty $$\n由于 $g(x)$ 在 $[0,1]$ 上是有界的，因此存在一个常数 $M$ 使得 $g(x)^2 \\le M^2$。因此，有限方差的一个充分条件是：\n$$ \\int_{0}^{1} \\frac{x^{-2a}(1-x)^{-2b}}{p(x)} dx  \\infty $$\n这个条件规定了提议密度 $p(x)$ 在端点附近的行为。为确保收敛，$p(x)$ 在 $x = 0$ 附近的奇性必须至少与 $x^{-2a}$ 相当，在 $x=1$ 附近的奇性必须至少与 $(1-x)^{-2b}$ 相当。\n\n**提议密度 $p(x)$ 的选择**\n\n重要性抽样的原理建议选择一个能模拟被积函数 $|f(x)|$ 行为的提议密度 $p(x)$。我们被积函数的奇异部分是 $w(x) = x^{-a}(1-x)^{-b}$。这种函数形式与 Beta 分布的核成正比。\n具有参数 $\\alpha  0$ 和 $\\beta  0$ 的 Beta 分布随机变量的概率密度函数是：\n$$ p(x; \\alpha, \\beta) = \\frac{x^{\\alpha-1}(1-x)^{\\beta-1}}{B(\\alpha, \\beta)} $$\n为了匹配 $w(x)$ 的形式，我们选择指数使得 $\\alpha-1 = -a$ 和 $\\beta-1 = -b$。这给出了参数选择：\n$$ \\alpha = 1-a \\quad \\text{和} \\quad \\beta = 1-b $$\n给定的约束条件 $0  a  1$ 和 $0 \\le b  1$ 确保了 $\\alpha = 1-a  0$ 且 $\\beta = 1-b  0$。因此，使用这些参数的 Beta 分布是良定义的。我们选择的提议密度是：\n$$ p(x) = \\frac{x^{-a}(1-x)^{-b}}{B(1-a, 1-b)} $$\n这个选择满足无偏性条件，因为对于 $x \\in (0,1)$ 有 $p(x)  0$。\n让我们用这个 $p(x)$ 来验证有限方差条件。二阶矩的积分变为：\n$$ \\int_0^1 \\frac{x^{-2a}(1-x)^{-2b} g(x)^2}{\\frac{x^{-a}(1-x)^{-b}}{B(1-a, 1-b)}} dx = B(1-a, 1-b) \\int_0^1 x^{-a}(1-x)^{-b}g(x)^2 dx $$\n由于 $g(x)^2$ 是一个有界函数，并且积分 $\\int_0^1 x^{-a}(1-x)^{-b} dx = B(1-a, 1-b)$ 收敛，所以整个表达式是有限的。因此，选择这个 $p(x)$ 可以保证估计量具有有限方差。\n\n**算法实现**\n\n使用我们选择的 $p(x)$，估计量中的比率 $\\frac{f(x)}{p(x)}$ 大大简化：\n$$ \\frac{f(x)}{p(x)} = \\frac{x^{-a}(1-x)^{-b}g(x)}{\\frac{x^{-a}(1-x)^{-b}}{B(1-a, 1-b)}} = g(x) B(1-a, 1-b) $$\n那么 Monte Carlo 估计量为：\n$$ \\widehat{I}_N = \\frac{1}{N} \\sum_{i=1}^{N} \\left[ g(X_i) B(1-a, 1-b) \\right] = B(1-a, 1-b) \\left( \\frac{1}{N} \\sum_{i=1}^{N} g(X_i) \\right) $$\n其中 $X_i$ 是从 Beta 分布 $\\text{Beta}(1-a, 1-b)$ 中抽取的样本。\n\n这个公式是数值稳定的，因为它完全从求和中移除了奇异项。算法如下：\n1.  对于每个测试用例 $(a, b, g, N)$，确定提议分布的参数：$\\alpha = 1-a$ 和 $\\beta = 1-b$。\n2.  使用数值库函数预先计算常数 $C = B(\\alpha, \\beta)$。\n3.  从分布 $\\text{Beta}(\\alpha, \\beta)$ 中生成 $N$ 个随机样本 $X_1, X_2, \\dots, X_N$。\n4.  对每个样本 $X_i$ 计算 $g(X_i)$ 的值。\n5.  计算这些值的样本均值：$\\bar{g} = \\frac{1}{N} \\sum_{i=1}^{N} g(X_i)$。\n6.  积分的估计值为 $\\widehat{I} = C \\times \\bar{g}$。\n\n为每个指定的测试用例实现此过程。\n- **用例 1**：$a=\\tfrac{1}{2}, b=0 \\implies \\alpha=0.5, \\beta=1$。\n- **用例 2**：$a=0.9, b=0 \\implies \\alpha=0.1, \\beta=1$。\n- **用例 3**：$a=0.49, b=0.49 \\implies \\alpha=0.51, \\beta=0.51$。\n- **用例 4**：$a=0.99, b=0 \\implies \\alpha=0.01, \\beta=1$。对于这个用例，$g(x)=1$，所以估计量简化为 $\\widehat{I} = B(0.01, 1) \\times \\frac{1}{N}\\sum_i 1 = B(0.01, 1)$，这正是积分的精确值。\n- **用例 5**：$a=0.1, b=0.9 \\implies \\alpha=0.9, \\beta=0.1$。\n实现将使用指定的随机种子以确保可复现性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import beta as beta_function\n\ndef solve():\n    \"\"\"\n    Constructs and applies a Monte Carlo importance sampling estimator for integrals\n    with endpoint singularities, as specified in the problem statement.\n    \"\"\"\n\n    # Initialize a random number generator with the specified seed for reproducibility.\n    seed = 20231105\n    rng = np.random.default_rng(seed)\n\n    # Define the g(x) functions for each test case. Angles are in radians.\n    g1 = lambda x: np.exp(x)\n    g2 = lambda x: np.cos(x)\n    g3 = lambda x: np.sin(3 * x)\n    # For g(x)=1, return an array of ones to ensure correct vectorized computation.\n    g4 = lambda x: np.ones_like(x)\n    g5 = lambda x: np.exp(2 * x)\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (a, b, g(x) function, sample size N)\n    test_cases = [\n        (0.5, 0.0, g1, 200000),\n        (0.9, 0.0, g2, 600000),\n        (0.49, 0.49, g3, 400000),\n        (0.99, 0.0, g4, 100000),\n        (0.1, 0.9, g5, 500000),\n    ]\n\n    results = []\n    for a, b, g, N in test_cases:\n        # Step 1: Define parameters for the Beta proposal distribution.\n        # Naming beta_p to avoid shadowing the imported beta_function.\n        alpha_p = 1.0 - a\n        beta_p = 1.0 - b\n\n        # Step 2: Pre-calculate the constant C = B(alpha, beta).\n        beta_constant = beta_function(alpha_p, beta_p)\n\n        # Step 3: Generate N random samples from the Beta(alpha, beta) distribution.\n        samples = rng.beta(alpha_p, beta_p, size=N)\n\n        # Step 4: Evaluate g(x) on the generated samples.\n        g_values = g(samples)\n\n        # Step 5: Compute the sample mean of g(x) values.\n        mean_g = np.mean(g_values)\n\n        # Step 6: The final estimate is B(alpha, beta) * mean(g(x)).\n        estimate = beta_constant * mean_g\n        \n        results.append(estimate)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2415223"}]}