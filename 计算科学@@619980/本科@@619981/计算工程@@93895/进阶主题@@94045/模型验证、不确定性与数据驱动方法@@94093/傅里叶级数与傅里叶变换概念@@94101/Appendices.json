{"hands_on_practices": [{"introduction": "数学变换的理论性质，例如傅里叶变换的对偶性，有时可能感觉比较抽象。本实践练习将引导您通过数值计算的方式来验证这一基本性质，从而在理论与计算之间架起一座桥梁 [@problem_id:2395492]。通过亲手实现傅里叶变换的积分定义，您将对其数学形式和计算实现之间的联系有更深刻、更直观的理解。", "problem": "考虑为绝对可积函数 $f(t)$ 定义的连续时间傅里叶变换\n$$\\mathcal{F}\\{f\\}(\\omega) = \\int_{-\\infty}^{\\infty} f(t)\\, e^{-i \\omega t}\\, dt,$$\n其中 $\\omega$ 是以弧度为单位的角频率，$i$ 是虚数单位。其对偶性质表明，将同一变换应用两次可得\n$$\\mathcal{F}\\{\\mathcal{F}\\{f\\}\\}(t) = 2\\pi\\, f(-t).$$\n您的任务是通过计算积分 $\\mathcal{F}\\{f\\}(\\omega)$ 和 $\\mathcal{F}\\{\\mathcal{F}\\{f\\}\\}(t)$ 来数值验证此性质，并将结果与在指定的时间 $t$ 和角频率 $\\omega$ 的有限区间上的 $2\\pi\\, f(-t)$ 进行比较。所有角度均以弧度处理。\n\n您必须实现一个单一程序，对于下述每个测试用例，直接从第一性原理逼近这两个积分，并报告在时间网格的指定中心子区间上，数值计算得到的 $\\mathcal{F}\\{\\mathcal{F}\\{f\\}\\}(t)$ 与 $2\\pi\\, f(-t)$ 之间的最大绝对偏差。一个测试用例的偏差定义为\n$$\\max_{t \\in [-\\alpha T, \\alpha T]} \\left| \\widehat{\\widehat{f}}(t) - 2\\pi f(-t) \\right|,$$\n其中 $\\widehat{\\widehat{f}}(t)$ 表示通过在给定的角频率网格上数值计算积分 $\\int_{-W}^{W} \\mathcal{F}\\{f\\}(\\omega) e^{-i t \\omega} d\\omega$ 得到的二次变换，$T$ 和 $W$ 分别是给定的时间和角频率积分的有限半宽度，$\\alpha \\in (0,1)$ 指定了用于误差计算的时间区间的中心部分比例。每个积分必须使用具有给定点数的均匀网格，在相应的指定有限区间上进行计算；所有计算必须使用上文定义的相同核函数 $e^{-i \\cdot \\cdot}$。不得做任何其他假设。\n\n测试套件（对于每个案例，请指定 $f(t)$、$f$ 的参数、时域半宽度 $T$、角频率域半宽度 $W$、每个域中的网格点数 $N$ 以及中心比例 $\\alpha$）：\n- 案例 A（通用、平滑、偶函数）：$f(t) = e^{-a t^2}$，其中 $a = 0.5$，使用 $T = 12.0$，$W = 12.0$，$N = 801$，以及 $\\alpha = 0.9$。\n- 案例 B（奇函数）：$f(t) = t \\, e^{-a t^2}$，其中 $a = 1.0$，使用 $T = 10.0$，$W = 10.0$，$N = 801$，以及 $\\alpha = 0.9$。\n- 案例 C（振荡、调制函数）：$f(t) = \\cos(\\omega_0 t)\\, e^{-a t^2}$，其中 $a = 0.3$ 且 $\\omega_0 = 5.0$，使用 $T = 14.0$，$W = 14.0$，$N = 1001$，以及 $\\alpha = 0.85$。\n\n对每个测试用例：\n- 在 $[-T,T]$ 上建立一个包含 $N$ 个点的均匀时间网格，并在 $[-W,W]$ 上建立一个包含 $N$ 个点的均匀角频率网格。\n- 通过在时间网格上计算定义积分，在角频率网格上数值逼近 $\\mathcal{F}\\{f\\}(\\omega)$。\n- 通过在角频率网格上计算定义积分，在时间网格上数值逼近 $\\mathcal{F}\\{\\mathcal{F}\\{f\\}\\}(t)$。\n- 计算在中心时间子区间 $[-\\alpha T, \\alpha T]$ 上的最大绝对偏差。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\text{案例 A 结果}, \\text{案例 B 结果}, \\text{案例 C 结果}]$。每个结果必须是浮点数，以科学记数法打印，小数点后恰好有六位数字（例如，$[1.234567e-04,2.345678e-05,3.456789e-06]$）。所有角度必须始终以弧度为单位。", "solution": "问题陈述已经过验证，被认为是科学上合理、定义明确且客观的。它提出了一个在计算工程领域内的可验证任务，具体涉及对连续时间傅里叶变换一个基本性质的数值验证。所有必要的参数和定义均已提供。因此，该问题是有效的，解决方案如下。\n\n问题的核心是针对三个不同的函数，数值验证傅里叶变换的对偶性质 $\\mathcal{F}\\{\\mathcal{F}\\{f\\}\\}(t) = 2\\pi f(-t)$。该验证过程涉及一个从第一性原理实现的两步数值积分过程。\n\n首先，对时域进行离散化。在有限区间 $[-T, T]$ 上建立一个由 $N$ 个点组成的均匀网格，记为 $\\{t_k\\}$。网格间距为 $\\Delta t = \\frac{2T}{N-1}$。同样地，角频率域也被离散化为在区间 $[-W, W]$ 上的一个由 $N$ 个点组成的均匀网格，记为 $\\{\\omega_j\\}$，其间距为 $\\Delta \\omega = \\frac{2W}{N-1}$。\n\n第一阶段是对给定函数 $f(t)$ 进行傅里叶变换的数值计算，记为 $\\widehat{f}(\\omega) = \\mathcal{F}\\{f\\}(\\omega)$。定义积分 $\\mathcal{F}\\{f\\}(\\omega) = \\int_{-\\infty}^{\\infty} f(t)\\, e^{-i \\omega t}\\, dt$ 在有限时间区间上对每个离散频率 $\\omega_j$ 进行近似：\n$$ \\widehat{f}(\\omega_j) \\approx \\int_{-T}^{T} f(t) e^{-i \\omega_j t} dt $$\n该积分使用梯形法则在时间网格 $\\{t_k\\}$ 上计算。`scipy.integrate.trapezoid` 函数可用于逼近非均匀间距有序点集 $\\{x_i\\}$ 上的函数 $g(x)$ 的积分。对于均匀网格，它等价于 $\\int_a^b g(x) dx \\approx \\Delta x \\left( \\frac{g(x_0) + g(x_{N-1})}{2} + \\sum_{i=1}^{N-2} g(x_i) \\right)$。我们利用实现了该法则的 `scipy.integrate.trapezoid` 函数。\n\n第二阶段是计算第一阶段结果的傅里叶变换，我们将其记为 $\\widehat{\\widehat{f}}(t) = \\mathcal{F}\\{\\widehat{f}\\}(t)$。先前计算出的离散值 $\\widehat{f}(\\omega_j)$ 被视为在频率网格上定义的函数的样本。该积分在有限频率区间上进行近似：\n$$ \\widehat{\\widehat{f}}(t_k) \\approx \\int_{-W}^{W} \\widehat{f}(\\omega) e^{-i t_k \\omega} d\\omega $$\n对于每个离散时间点 $t_k$，该积分使用梯形法则在频率网格 $\\{\\omega_j\\}$ 上计算，其中被积函数中 $\\widehat{f}(\\omega)$ 的值是第一阶段的数值结果。\n\n为了提高计算效率，这个两阶段过程被向量化。构造一个大小为 $N \\times N$ 的核矩阵 $K$，其元素为 $K_{kj} = e^{-i t_k \\omega_j}$。第一次变换的值数组 $\\widehat{f}(\\omega_j)$，是通过执行一个等效于矩阵-向量乘法的操作来计算的，该操作涉及采样函数 $f(t_k)$ 和核矩阵，然后沿时间轴进行数值积分。第二次变换的计算方法类似，使用得到的变换值 $\\widehat{f}(\\omega_j)$ 并沿频率轴进行积分。\n\n最后，将数值结果 $\\widehat{\\widehat{f}}(t_k)$ 与由对偶性质给出的精确理论结果 $g(t_k) = 2\\pi f(-t_k)$ 进行比较。偏差通过在指定的时间网格中心子区间 $[-\\alpha T, \\alpha T]$ 上的最大绝对误差来量化：\n$$ \\text{偏差} = \\max_{k \\text{ s.t. } t_k \\in [-\\alpha T, \\alpha T]} \\left| \\widehat{\\widehat{f}}(t_k) - 2\\pi f(-t_k) \\right| $$\n对问题陈述中提供的三个测试用例中的每一个都计算此值。主要误差来源是将无限积分域截断为有限区间 $[-T, T]$ 和 $[-W, W]$，以及梯形积分法则固有的离散化误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import trapezoid\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes the discrepancy for the Fourier transform duality property.\n    \"\"\"\n\n    def calculate_discrepancy(f_func, T, W, N, alpha):\n        \"\"\"\n        Calculates the maximum absolute discrepancy for a single test case.\n\n        Args:\n            f_func (callable): The function f(t) to be transformed.\n            T (float): The half-width of the time integration interval.\n            W (float): The half-width of the frequency integration interval.\n            N (int): The number of points in the grids.\n            alpha (float): The central fraction of the time interval for error computation.\n\n        Returns:\n            float: The maximum absolute discrepancy.\n        \"\"\"\n        # Step 1: Create uniform grids for time and frequency\n        t_grid = np.linspace(-T, T, N)\n        w_grid = np.linspace(-W, W, N)\n\n        # Evaluate the input function on the time grid\n        f_on_t_grid = f_func(t_grid)\n\n        # For efficient computation, we vectorize the two-stage integration.\n        # Create kernel matrix K_kj = exp(-i * t_k * w_j)\n        t_col = t_grid.reshape((N, 1))\n        w_row = w_grid.reshape((1, N))\n        kernel = np.exp(-1j * t_col @ w_row)\n\n        # Step 2: First Fourier Transform\n        # Compute F_hat(w_j) = integral(f(t) * exp(-i * w_j * t), t) from -T to T\n        # The integrands for all w_j are computed at once.\n        # Shape: (N_t, N_w), where N_t=N and N_w=N.\n        integrands1 = f_on_t_grid.reshape((N, 1)) * kernel\n        \n        # Integrate along the time axis (axis=0) to get the transform at each w_j\n        F_hat_on_w_grid = trapezoid(integrands1, t_grid, axis=0)\n\n        # Step 3: Second Fourier Transform\n        # Compute F_hat_hat(t_k) = integral(F_hat(w) * exp(-i * t_k * w), w) from -W to W\n        # The integrands for all t_k are computed at once.\n        # Shape: (N_t, N_w)\n        integrands2 = F_hat_on_w_grid.reshape((1, N)) * kernel\n        \n        # Integrate along the frequency axis (axis=1) to get the double transform at each t_k\n        F_hat_hat_on_t_grid = trapezoid(integrands2, w_grid, axis=1)\n\n        # Step 4: Compute the theoretical result based on the duality property\n        # Theoretical result is 2 * pi * f(-t)\n        theoretical_result = 2 * np.pi * f_func(-t_grid)\n\n        # Step 5: Compute the maximum discrepancy on the central subinterval\n        # Identify indices within the central interval [-alpha*T, alpha*T]\n        central_indices = np.where(np.abs(t_grid) <= alpha * T)\n\n        # Calculate the absolute difference between numerical and theoretical results\n        # The result of the transform might have a small imaginary part due to numerical errors.\n        # np.abs computes the complex magnitude, as required.\n        abs_diff = np.abs(F_hat_hat_on_t_grid[central_indices] - theoretical_result[central_indices])\n        \n        max_discrepancy = np.max(abs_diff)\n        \n        return max_discrepancy\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Gaussian function\n        {\"f\": lambda t: np.exp(-0.5 * t**2), \"T\": 12.0, \"W\": 12.0, \"N\": 801, \"alpha\": 0.9},\n        # Case B: Odd function\n        {\"f\": lambda t: t * np.exp(-1.0 * t**2), \"T\": 10.0, \"W\": 10.0, \"N\": 801, \"alpha\": 0.9},\n        # Case C: Modulated Gaussian\n        {\"f\": lambda t: np.cos(5.0 * t) * np.exp(-0.3 * t**2), \"T\": 14.0, \"W\": 14.0, \"N\": 1001, \"alpha\": 0.85},\n    ]\n\n    results = []\n    for case in test_cases:\n        discrepancy = calculate_discrepancy(case[\"f\"], case[\"T\"], case[\"W\"], case[\"N\"], case[\"alpha\"])\n        results.append(f\"{discrepancy:.6e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2395492"}, {"introduction": "傅里叶级数在表示周期函数方面非常强大，但在函数剧烈变化或不连续点附近，其收敛行为表现出一种有趣而重要的特性。本练习将带您探究吉布斯现象 (Gibbs phenomenon)，这是一种即使增加级数项数也不会消失的标志性过冲 [@problem_id:2395550]。通过量化分析锯齿波的这一效应，您将对在信号和图像处理等应用中使用截断傅里叶级数的局限性和实际考量获得关键的洞察。", "problem": "考虑一个实值锯齿波，由函数 $f:\\mathbb{R}\\to\\mathbb{R}$ 定义，其基本周期为 $2\\pi$。在一个周期内，当 $x\\in(-\\pi,\\pi)$ 时，$f(x)=\\dfrac{x}{\\pi}$，并进行周期性延拓，使得对所有 $x\\in\\mathbb{R}$ 都有 $f(x+2\\pi)=f(x)$。所有角度都必须以弧度为单位。对于每个正整数 $N$，令 $S_N(x)$ 表示 $f$ 的傅里叶级数的第 $N$ 个部分和，其构建基于傅里叶级数的定义：\n$$\na_0=\\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x)\\,dx,\\quad a_k=\\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x)\\cos(kx)\\,dx,\\quad b_k=\\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x)\\sin(kx)\\,dx,\n$$\n对于 $k\\in\\mathbb{N}$，以及\n$$\nS_N(x)=\\frac{a_0}{2}+\\sum_{k=1}^{N}\\left(a_k\\cos(kx)+b_k\\sin(kx)\\right).\n$$\n在 $2\\pi$ 周期延拓的跳跃间断点 $x=\\pi$ 处，左极限为 $\\lim_{x\\to\\pi^-}f(x)=1$，右极限为 $\\lim_{x\\to\\pi^+}f(x)=-1$，因此跳跃幅度为 $J=2$。为了量化此跳跃点附近的吉布斯现象，定义第 $N$ 个部分和的过冲比为\n$$\n\\rho_N=\\frac{\\max\\{S_N(x)-1: x\\in(\\pi-\\frac{\\pi}{2},\\pi)\\}_+}{J},\n$$\n其中 $(z)_+=\\max(z,0)$ 且 $J=2$。任务是为给定的一组 $N$ 值计算 $\\rho_N$。请使用以下部分和阶数的测试集：$N\\in\\{1,5,25,101\\}$。您的程序必须生成单行输出，其中包含结果，格式为逗号分隔的浮点数列表，四舍五入到 $6$ 位小数，并用方括号括起来，顺序与测试集相同（例如 $[r_1,r_2,r_3,r_4]$）。不允许有任何其他输出。", "solution": "所提供的问题已经过严格验证，并被确定为有效。该问题在科学上基于已确立的傅里叶分析理论，在数学上是适定的，并以客观、明确的语言表述。所有必要信息均已提供，可得到唯一解。因此，我们可以着手进行推导和计算。\n\n该问题要求计算一个锯齿波的吉布斯现象过冲比。该函数为 $f(x) = \\frac{x}{\\pi}$，定义在 $x \\in (-\\pi, \\pi)$ 上，基本周期为 $T = 2\\pi$。分析将分步进行：首先，确定傅里叶级数系数；其次，构建第 $N$ 个部分和 $S_N(x)$；第三，解析地确定最大过冲的位置；最后，为给定的 $N$ 值计算指定的比率 $\\rho_N$。\n\n首先，我们计算当 $k \\in \\mathbb{N}$ 时的傅里叶系数 $a_0$、$a_k$ 和 $b_k$。函数 $f(x)=x/\\pi$ 是一个奇函数，因为 $f(-x) = (-x)/\\pi = -f(x)$。奇函数在对称区间（如 $[-\\pi, \\pi]$）上的积分为零。\n系数 $a_0$ 由下式给出：\n$$ a_0 = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(x) \\,dx = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} \\frac{x}{\\pi} \\,dx = 0 $$\n系数 $a_k$ 由下式给出：\n$$ a_k = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(x) \\cos(kx) \\,dx = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} \\frac{x}{\\pi} \\cos(kx) \\,dx $$\n由于 $x/\\pi$ 是奇函数，而 $\\cos(kx)$ 是偶函数，它们的乘积是奇函数。这个奇函数乘积在对称区间 $[-\\pi, \\pi]$ 上的积分为零。因此，对于所有 $k \\geq 1$，$a_k = 0$。\n\n系数 $b_k$ 由下式给出：\n$$ b_k = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(x) \\sin(kx) \\,dx = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} \\frac{x}{\\pi} \\sin(kx) \\,dx $$\n两个奇函数 $x/\\pi$ 和 $\\sin(kx)$ 的乘积是偶函数。因此，积分不为零，可以简化为：\n$$ b_k = \\frac{2}{\\pi^2} \\int_{0}^{\\pi} x \\sin(kx) \\,dx $$\n我们使用分部积分法 $\\int u \\,dv = uv - \\int v \\,du$，令 $u=x$ 且 $dv=\\sin(kx)dx$。由此可得 $du=dx$ 和 $v = -\\frac{1}{k}\\cos(kx)$。\n$$ \\int_{0}^{\\pi} x \\sin(kx) \\,dx = \\left[ -\\frac{x}{k}\\cos(kx) \\right]_{0}^{\\pi} - \\int_{0}^{\\pi} \\left(-\\frac{1}{k}\\cos(kx)\\right) \\,dx $$\n$$ = -\\frac{\\pi}{k}\\cos(k\\pi) + \\frac{1}{k} \\int_{0}^{\\pi} \\cos(kx) \\,dx = -\\frac{\\pi}{k}(-1)^k + \\frac{1}{k} \\left[ \\frac{1}{k}\\sin(kx) \\right]_{0}^{\\pi} $$\n$$ = \\frac{\\pi}{k}(-1)^{k+1} + \\frac{1}{k^2}(\\sin(k\\pi) - \\sin(0)) = \\frac{\\pi}{k}(-1)^{k+1} $$\n将此结果代回 $b_k$ 的表达式中：\n$$ b_k = \\frac{2}{\\pi^2} \\left( \\frac{\\pi}{k}(-1)^{k+1} \\right) = \\frac{2}{\\pi k}(-1)^{k+1} $$\n\n因此，傅里叶级数的第 $N$ 个部分和 $S_N(x)$ 为：\n$$ S_N(x) = \\frac{a_0}{2} + \\sum_{k=1}^{N} (a_k \\cos(kx) + b_k \\sin(kx)) = \\sum_{k=1}^{N} \\frac{2}{\\pi k}(-1)^{k+1} \\sin(kx) $$\n\n问题要求计算过冲比 $\\rho_N$，其定义为：\n$$ \\rho_N = \\frac{\\max\\{S_N(x)-1: x \\in (\\pi/2, \\pi)\\}_+}{2} $$\n为了找到这个值，我们必须求出 $S_N(x)$ 在开区间 $x \\in (\\pi/2, \\pi)$ 上的最大值。我们通过将 $S_N(x)$ 的导数设为零来寻找临界点：\n$$ \\frac{dS_N(x)}{dx} = \\frac{d}{dx} \\left( \\frac{2}{\\pi} \\sum_{k=1}^{N} \\frac{(-1)^{k+1}}{k} \\sin(kx) \\right) = \\frac{2}{\\pi} \\sum_{k=1}^{N} (-1)^{k+1} \\cos(kx) = 0 $$\n我们来分析这个和式。使用变换 $x = \\pi - y$，其中 $y \\in (0, \\pi/2)$。\n$$ \\cos(kx) = \\cos(k(\\pi - y)) = \\cos(k\\pi)\\cos(ky) + \\sin(k\\pi)\\sin(ky) = (-1)^k\\cos(ky) $$\n该和式变为：\n$$ \\sum_{k=1}^{N} (-1)^{k+1} (-1)^k \\cos(ky) = \\sum_{k=1}^{N} (-1) \\cos(ky) = -\\sum_{k=1}^{N} \\cos(ky) $$\n临界点是方程 $\\sum_{k=1}^{N} \\cos(ky) = 0$ 的解。这是一个已知的和式，它有一个闭合形式：\n$$ \\sum_{k=1}^{N} \\cos(ky) = \\text{Re}\\left(\\sum_{k=1}^{N} e^{iky}\\right) = \\frac{\\sin(Ny/2)\\cos((N+1)y/2)}{\\sin(y/2)} $$\n当 $y \\neq 0$ 时，若 $\\sin(Ny/2) = 0$ 或 $\\cos((N+1)y/2) = 0$，则该表达式为零。\n解为 $y = 2m\\pi/N$ 和 $y = (2m+1)\\pi/(N+1)$，其中 $m$为整数。\n在 $x=\\pi$ 附近的 $S_N(x)$ 的极值对应于这些 $y=\\pi-x$ 的值。吉布斯过冲表现为间断点左侧的第一个峰值。这对应于 $y$ 的最小正值，即当 $m=0$ 时，$y = \\pi/(N+1)$。这第一个最大值的位置是 $x_{max} = \\pi - \\frac{\\pi}{N+1}$。\n对于 $N>1$，该点位于区间 $(\\pi/2, \\pi)$ 内。对于 $N=1$，该位置为 $x=\\pi/2$，位于区间的边界上。\n\n情况 $N=1$：$S_1(x) = \\frac{2}{\\pi}\\sin(x)$。在区间 $(\\pi/2, \\pi)$ 上，其导数 $S'_1(x) = \\frac{2}{\\pi}\\cos(x)$ 严格为负。因此，$S_1(x)$ 在此区间上是减函数。上确界在边界 $x=\\pi/2$ 处取得，其值为 $S_1(\\pi/2)=2/\\pi \\approx 0.637 < 1$。因此，对于所有 $x \\in (\\pi/2, \\pi)$，都有 $S_1(x) - 1 < 0$。项 $\\max\\{S_1(x)-1, \\dots\\}_+$ 为零，所以 $\\rho_1 = 0$。\n\n情况 $N > 1$：$S_N(x)$ 在区间内的最大值出现在 $x_{max} = \\pi - \\frac{\\pi}{N+1}$ 处。我们计算 $S_N(x_{max})$：\n$$ S_N(x_{max}) = \\frac{2}{\\pi} \\sum_{k=1}^{N} \\frac{(-1)^{k+1}}{k} \\sin\\left(k\\left(\\pi - \\frac{\\pi}{N+1}\\right)\\right) $$\n使用恒等式 $\\sin(k\\pi - \\alpha) = (-1)^{k+1}\\sin(\\alpha):$\n$$ \\sin\\left(k\\pi - \\frac{k\\pi}{N+1}\\right) = (-1)^{k+1}\\sin\\left(\\frac{k\\pi}{N+1}\\right) $$\n$S_N(x_{max})$ 的表达式简化为：\n$$ S_N(x_{max}) = \\frac{2}{\\pi} \\sum_{k=1}^{N} \\frac{1}{k}\\sin\\left(\\frac{k\\pi}{N+1}\\right) $$\n这是部分和的最大值。过冲为 $O_N = S_N(x_{max}) - 1$。由于当 $N > 1$ 时该值为正，所以比率为 $\\rho_N = (S_N(x_{max}) - 1)/2$。\n\n计算算法如下：\n1. 对于 $N=1$，$\\rho_1=0$。\n2. 对于 $N \\in \\{5, 25, 101\\}$，计算 $S_N_max = \\frac{2}{\\pi} \\sum_{k=1}^{N} \\frac{1}{k}\\sin(\\frac{k\\pi}{N+1})$。\n3. 计算 $\\rho_N = (S_N_max - 1)/2$。\n\n这为实现代码提供了完整的解析基础。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Gibbs phenomenon overshoot ratio for a sawtooth wave's Fourier series.\n\n    The sawtooth wave is f(x) = x/pi on (-pi, pi), with period 2*pi.\n    The N-th partial sum is S_N(x) = sum_{k=1 to N} (2/(pi*k))*(-1)^(k+1)*sin(kx).\n    The overshoot ratio is rho_N = max(S_N(x_max) - 1, 0) / 2, where x_max is the location\n    of the first peak to the left of the jump at x=pi.\n\n    The maximum for S_N(x) on (pi/2, pi) is analytically found to be at\n    x_max = pi - pi/(N+1) for N > 1.\n    For N=1, the maximum on the open interval does not exist, and the supremum\n    is less than 1, resulting in zero overshoot.\n    \"\"\"\n\n    test_cases = [1, 5, 25, 101]\n    results = []\n\n    for N in test_cases:\n        if N == 1:\n            # For N=1, S_1(x) = (2/pi)*sin(x). On the interval (pi/2, pi), this\n            # function is strictly decreasing. The supremum is S_1(pi/2) = 2/pi, which\n            # is less than 1. Thus, the overshoot (S_1(x) - 1) is always negative\n            # on the interval. The definition max(overshoot, 0) leads to 0.\n            rho = 0.0\n        else:\n            # For N > 1, the maximum of S_N(x) in the interval (pi/2, pi) occurs\n            # at x = pi - pi/(N+1).\n            # The value at this maximum is S_N(x_max).\n            # S_N(x_max) = (2/pi) * sum_{k=1 to N} (1/k) * sin(k*pi/(N+1)).\n            k_vals = np.arange(1, N + 1)\n            \n            # The argument to the sine function in the simplified sum\n            sin_arg = k_vals * np.pi / (N + 1)\n            \n            # The terms of the sum\n            terms = np.sin(sin_arg) / k_vals\n            \n            # The maximum value of the N-th partial sum\n            s_n_max = (2 / np.pi) * np.sum(terms)\n            \n            # The problem defines the overshoot relative to the limit f(pi-) = 1.\n            overshoot = s_n_max - 1\n            \n            # The jump J is 2. The overshoot ratio rho_N includes max(overshoot, 0).\n            # For N > 1, the overshoot is positive.\n            rho = overshoot / 2.0\n        \n        results.append(rho)\n\n    # Format the results to 6 decimal places as required.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    \n    # Print the final output in the specified format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2395550"}, {"introduction": "在探索了傅里叶分析的基本性质和行为之后，现在让我们将这些概念应用于构建一个受现实世界技术启发的系统。本实践将引入短时傅里叶变换 (Short-Time Fourier Transform, STFT) 作为一种分析信号频率内容如何随时间演变的工具，这对于处理像音乐这样的非平稳信号至关重要 [@problem_id:2395481]。您将实现一个类似“Shazam”的简化版音频指纹识别算法，将抽象的时频分析转化为一个具体而强大的识别工具。", "problem": "您的任务是形式化并实现一个简化的音频指纹及匹配系统，该系统基于从短时傅里叶变换 (STFT) 推导出的时频峰值星座图。目标是设计一个对时间平移和适度的幅度变化具有鲁棒性，但对音高变化不具鲁棒性的数学上精确的匹配准则，并将其应用于一个小型合成信号测试集。下文所有的定义和参数值都必须严格按照规定使用，所有数学实体都必须在标准复分析和线性系统理论的意义上进行解释。\n\n构建一个有限的离散时间信号集合，这些信号以采样频率 $f_s = 8000$ 赫兹采样，并具有以秒为单位的有限时长。对于一个离散时间信号 $x[n]$，将短时傅里叶变换 (STFT) 定义为\n$$\nX[k,m] = \\sum_{n=0}^{N-1} x[n+mH] \\, w[n] \\, e^{-j 2\\pi kn/N},\n$$\n其中 $N$ 是以采样点为单位的窗长，$H$ 是以采样点为单位的跳数，$w[n]$ 是 Hann 窗，$k \\in \\{0,1,\\dots,N/2\\}$ 索引非负频率箱，$m \\in \\mathbb{N}$ 索引时间帧。令幅度谱图为 $S[k,m] = |X[k,m]|$。\n\n将频谱峰值定义为二维数组 $S[k,m]$ 中的严格局部最大值，该定义使用一个大小为 $\\Delta_f$ 个频率箱和 $\\Delta_t$ 个时间箱的矩形邻域，并结合一个全局幅度阈值。形式上，一个时频箱 $(k^\\star,m^\\star)$ 是一个峰值，当且仅当\n- $S[k^\\star,m^\\star] \\ge \\tau$，其中 $\\tau = \\alpha \\cdot \\max_{k,m} S[k,m]$ 且 $\\alpha = 0.1$，以及\n- 对于所有满足 $|k-k^\\star| \\le \\Delta_f$ 和 $|m-m^\\star| \\le \\Delta_t$ 的 $(k,m)$，都有 $S[k^\\star,m^\\star] \\ge S[k,m]$。\n使用 $\\Delta_f = 5$ 和 $\\Delta_t = 3$。\n\n从检测到的峰值集合中，按如下方式定义星座图指纹。对于每个指定为锚点的峰值 $(k_a,m_a)$ 和每个满足时间约束 $t_{\\min} \\le (m_b - m_a) \\le t_{\\max}$（其中 $t_{\\min} = 1$ 和 $t_{\\max} = 10$）的目标峰值 $(k_b,m_b)$，构成一个哈希三元组\n$$\nh = (k_a, k_b, \\Delta m), \\quad \\Delta m = m_b - m_a.\n$$\n为限制组合增长，对于每个锚点 $(k_a,m_a)$ 及其满足时间约束的候选目标 $(k_b,m_b)$，最多选择 $K$ 个具有最大幅度 $S[k_b,m_b]$ 的配对，其中 $K = 5$。一个信号的指纹是所有此类三元组 $h$ 构成的多重集。\n\n将查询指纹 $\\mathcal{F}_Q$ 和参考指纹 $\\mathcal{F}_R$ 之间的匹配得分定义为多重集交集的基数，\n$$\nm(\\mathcal{F}_Q,\\mathcal{F}_R) = \\sum_{h} \\min\\big(c_Q(h), c_R(h)\\big),\n$$\n其中 $c_Q(h)$ 和 $c_R(h)$ 分别是三元组 $h$ 在 $\\mathcal{F}_Q$ 和 $\\mathcal{F}_R$ 中的重数。给定一个参考集 $\\{\\mathcal{F}_{R_i}\\}_{i=0}^{2}$，对于一个查询 $\\mathcal{F}_Q$，将其预测的匹配索引声明为使 $m(\\mathcal{F}_Q,\\mathcal{F}_{R_i})$ 最大化的索引 $i^\\star$，条件是 $\\max_i m(\\mathcal{F}_Q,\\mathcal{F}_{R_i}) \\ge M_{\\min}$，其中 $M_{\\min} = 10$。如果最大得分严格小于 $M_{\\min}$，则返回 $-1$。\n\n使用以下固定的STFT参数：\n- 采样频率 $f_s = 8000$ 赫兹。\n- 窗长 $N = 1024$ 采样点。\n- 跳数 $H = 256$ 采样点。\n- 窗口 $w[n]$ 等于长度为 $N$ 的 Hann 窗。\n- 单边离散傅里叶变换，保留的频率箱对应于 $k \\in \\{0,1,\\dots,N/2\\}$。\n\n构建以下连续时间信号，并以 $f_s$ 赫兹的频率对其进行采样，以获得指定时长的离散时间信号，其中 $t$ 是以秒为单位的时间，所有角度均以弧度为单位：\n- 参考信号 (每个时长 $T_R = 3.0$ 秒):\n  - 参考信号 $R_0$: $x_{R_0}(t) = \\sin(2\\pi \\cdot 440\\, t) + 0.7\\sin(2\\pi \\cdot 660\\, t)$.\n  - 参考信号 $R_1$: $x_{R_1}(t) = \\sin(2\\pi \\cdot 554.365\\, t) + 0.6\\sin(2\\pi \\cdot 659.255\\, t)$.\n  - 参考信号 $R_2$: $x_{R_2}(t) = \\sin(2\\pi \\cdot 300\\, t) + 0.6\\sin(2\\pi \\cdot 900\\, t)$.\n- 查询信号 (每个时长 $T_Q = 1.5$ 秒):\n  - 查询信号 $Q_0$: $x_{R_0}$ 在 $t \\in [0.8, 2.3)$ 秒内的一个时移片段，附加标准差为 $0.02$ 的零均值高斯噪声。\n  - 查询信号 $Q_1$: $x_{R_1}$ 在 $t \\in [0.5, 2.0)$ 秒内的一个时移片段，无噪声。\n  - 查询信号 $Q_2$: $x_{R_2}$ 在 $t \\in [1.0, 2.5)$ 秒内的一个时移片段，乘以一个振幅因子 $0.5$。\n  - 查询信号 $Q_3$: $x_{R_0}$ 的一个音高移位变体，定义为 $x_{Q_3}(t) = \\sin(2\\pi \\cdot 484\\, t) + 0.7\\sin(2\\pi \\cdot 726\\, t)$，无噪声。\n  - 查询信号 $Q_4$: 静音，即对于所有 $t$ 都有 $x_{Q_4}(t) = 0$。\n\n将参考索引定义为：$R_0$ 对应 $0$，$R_1$ 对应 $1$，$R_2$ 对应 $2$。对于每个查询 $Q_j$（其中 $j \\in \\{0,1,2,3,4\\}$），根据上述匹配规则计算预测的参考索引，如果没有匹配则返回 $-1$。\n\n您的程序必须产生单行输出，其中包含对 $[Q_0,Q_1,Q_2,Q_3,Q_4]$ 的预测索引，格式为由方括号括起、无空格的逗号分隔整数列表，例如 $[r_0,r_1,r_2,r_3,r_4]$。不允许有任何其他输出。\n\n测试套件及其覆盖范围如下：\n- 时间平移不变性: $Q_0$ 是 $R_0$ 的一个带有加性噪声的片段。\n- 标称匹配: $Q_1$ 是 $R_1$ 的一个片段。\n- 幅度缩放: $Q_2$ 是 $R_2$ 的一个片段，幅度缩放了 $0.5$。\n- 因音高移位导致不匹配: $Q_3$ 使用了与 $R_0$ 不同的频率。\n- 边界条件: $Q_4$ 是静音。\n\n所有时长必须以秒表示，所有频率必须以赫兹表示。正弦定义中的角度以弧度为单位。最终输出是按规定格式输出的整数，因此没有单位。", "solution": "所呈现的问题陈述经过严格验证。\n\n**步骤1：提取给定条件**\n\n问题提供了以下定义和参数：\n- **采样频率**: $f_s = 8000$ 赫兹。\n- **STFT 定义**: $X[k,m] = \\sum_{n=0}^{N-1} x[n+mH] \\, w[n] \\, e^{-j 2\\pi kn/N}$。\n- **STFT 参数**:\n    - 窗长: $N = 1024$ 采样点。\n    - 跳数: $H = 256$ 采样点。\n    - 窗函数: $w[n]$ 是长度为 $N$ 的 Hann 窗。\n    - 频率箱: $k \\in \\{0, 1, \\dots, N/2\\}$。\n- **幅度谱图**: $S[k,m] = |X[k,m]|$。\n- **频谱峰值定义**: 一个点 $(k^\\star,m^\\star)$ 是一个峰值，如果：\n    1.  幅度阈值: $S[k^\\star,m^\\star] \\ge \\tau$，其中 $\\tau = \\alpha \\cdot \\max_{k,m} S[k,m]$ 且 $\\alpha = 0.1$。\n    2.  局部最大值条件: 对于所有 $(k,m)$，其中 $|k-k^\\star| \\le \\Delta_f$ 且 $|m-m^\\star| \\le \\Delta_t$，都有 $S[k^\\star,m^\\star] \\ge S[k,m]$。\n    3.  邻域大小: $\\Delta_f = 5$ 个箱，$\\Delta_t = 3$ 个帧。\n- **指纹哈希定义**:\n    - 哈希三元组: $h = (k_a, k_b, \\Delta m)$，其中 $(k_a, m_a)$ 是一个锚点峰值，$(k_b, m_b)$ 是一个目标峰值，且 $\\Delta m = m_b - m_a$。\n    - 配对的时间约束: $t_{\\min} \\le \\Delta m \\le t_{\\max}$，其中 $t_{\\min} = 1$ 且 $t_{\\max} = 10$。\n    - 目标削减: 对于每个锚点，最多选择 $K = 5$ 个具有最大幅度 $S[k_b, m_b]$ 的目标峰值。\n- **匹配准则**:\n    - 得分: $m(\\mathcal{F}_Q,\\mathcal{F}_R) = \\sum_{h} \\min\\big(c_Q(h), c_R(h)\\big)$，即指纹 $\\mathcal{F}_Q$ 和 $\\mathcal{F}_R$ 的多重集交集的基数。\n    - 匹配声明: 预测索引为 $\\arg\\max_i m(\\mathcal{F}_Q, \\mathcal{F}_{R_i})$，如果最大得分 $\\ge M_{\\min}$。否则，预测为 $-1$。\n    - 最低得分阈值: $M_{\\min} = 10$。\n- **参考信号** (时长 $T_R = 3.0$ s):\n    - $R_0$: $x_{R_0}(t) = \\sin(2\\pi \\cdot 440\\, t) + 0.7\\sin(2\\pi \\cdot 660\\, t)$。\n    - $R_1$: $x_{R_1}(t) = \\sin(2\\pi \\cdot 554.365\\, t) + 0.6\\sin(2\\pi \\cdot 659.255\\, t)$。\n    - $R_2$: $x_{R_2}(t) = \\sin(2\\pi \\cdot 300\\, t) + 0.6\\sin(2\\pi \\cdot 900\\, t)$。\n- **查询信号** (时长 $T_Q = 1.5$ s):\n    - $Q_0$: $x_{R_0}(t)$ 在 $[0.8, 2.3)$ 内的片段，附加标准差为 $0.02$ 的高斯噪声。\n    - $Q_1$: $x_{R_1}(t)$ 在 $[0.5, 2.0)$ 内的片段，无噪声。\n    - $Q_2$: $x_{R_2}(t)$ 在 $[1.0, 2.5)$ 内的片段，幅度因子缩放为 $0.5$。\n    - $Q_3$: $x_{Q_3}(t) = \\sin(2\\pi \\cdot 484\\, t) + 0.7\\sin(2\\pi \\cdot 726\\, t)$。\n    - $Q_4$: $x_{Q_4}(t) = 0$ (静音)。\n- **输出格式**: 逗号分隔的整数列表 $[r_0,r_1,r_2,r_3,r_4]$。\n\n**步骤2：给定条件的验证**\n\n根据指定标准对问题进行评估：\n- **科学依据**: 问题在数字信号处理和计算工程原理方面有充分的依据。所提出的音频指纹方法，即使用源自STFT的频谱峰值星座图，是一种标准且易于理解的技术。所有数学公式都是正确的。\n- **良态问题**: 问题是完全指定的。产生确定性输出所需的所有参数、函数和约束都已提供。不存在会妨碍唯一解存在的模糊性。\n- **客观性**: 问题陈述以精确、客观、正式的语言编写，不含任何主观或非技术性内容。\n\n该问题**不**包含任何无效标志。它在科学上是合理的、可形式化的、完整的、可行的和良态的。“严格局部最大值”的描述后跟一个非严格不等式 $S[k^\\star,m^\\star] \\ge S[k,m]$，这是一个微小的术语不一致，但其形式化定义是明确的，必须遵循。因此，这不会使问题无效。\n\n**步骤3：结论与行动**\n\n该问题是**有效的**。将根据指定程序构建解决方案。\n\n**解题方法**\n\n解决方案将通过遵循一系列离散步骤来实现，并严格遵守所提供的定义。\n\n**1. 信号合成**\n首先，我们根据连续时间定义生成离散时间信号 $\\{x_{R_i}[n]\\}$ 和 $\\{x_{Q_j}[n]\\}$。为每个信号创建一个时间向量 $t$，采样周期为 $1/f_s$。对于时长为 $T$ 的信号，采样点数为 $L = \\lfloor T \\cdot f_s \\rfloor$。在这些离散时间点上对连续时间函数进行求值。对于 $Q_0$，添加零均值高斯噪声。\n\n**2. 短时傅里叶变换 (STFT)**\n对于每个离散时间信号 $x[n]$，我们根据给定的公式计算其STFT $X[k,m]$。这可以通过使用标准库函数（特别是 `scipy.signal.stft`）高效完成。参数必须正确映射：\n- `fs` = $f_s = 8000$。\n- `window` = `'hann'`。\n- `nperseg` = $N = 1024$。\n- `noverlap` = $N - H = 1024 - 256 = 768$。\n- `nfft` = $N = 1024$。\n此计算的输出是一个复数值矩阵 $X[k,m]$。然后我们计算幅度谱图 $S[k,m] = |X[k,m]|$。\n\n**3. 频谱峰值识别**\n在每个谱图 $S[k,m]$ 中识别峰值。这是一个两步过程。首先，我们处理静音（$Q_4$）的退化情况。如果 $\\max(S) = 0$，则不存在峰值。否则，我们继续进行。\n- **幅度阈值处理**: 我们计算全局阈值 $\\tau = \\alpha \\cdot \\max(S)$，其中 $\\alpha = 0.1$。只有满足 $S[k,m] \\ge \\tau$ 的点 $(k,m)$ 才被视为潜在峰值。\n- **局部最大值滤波**: 我们强制执行局部最大值条件。一个点 $(k^\\star, m^\\star)$ 是一个峰值，仅当其值 $S[k^\\star, m^\\star]$ 在一个大小为 $(2\\Delta_f+1) \\times (2\\Delta_t+1)$（即 $11 \\times 7$）的矩形邻域内是最大的。这可以使用最大值滤波器（例如 `scipy.ndimage.maximum_filter`）高效实现。如果一个点通过了阈值测试并且其值等于以该点为中心的最大值滤波器的输出，则该点为一个峰值。存储所有这些峰值的坐标 $(k,m)$。\n\n**4. 指纹生成**\n对于每个信号，从其频谱峰值列表中构建其指纹，一个哈希三元组的多重集。\n- 遍历峰值集合，每个峰值 $(k_a, m_a)$ 作为“锚点”。\n- 对于每个锚点，将所有其他峰值 $(k_b, m_b)$ 视为潜在的“目标”。\n- 如果目标与锚点的时间偏移 $\\Delta m = m_b - m_a$ 在指定范围 $1 \\le \\Delta m \\le 10$ 内，则该目标有效。\n- 对于给定的锚点，收集所有有效的目标。然后根据这些候选目标的谱图幅度 $S[k_b, m_b]$ 按降序排序。\n- 选择前 $K=5$ 个目标。如果存在的有效目标少于 $K$ 个，则选择所有目标。\n- 对于每个选定的锚点-目标对，形成一个哈希三元组 $h = (k_a, k_b, \\Delta m)$ 并将其添加到信号的指纹中。\n\n**5. 匹配与识别**\n最后一步是将每个查询指纹与参考指纹集进行匹配。\n- 指纹是多重集，可以高效地用频率图（例如 Python的 `collections.Counter`）表示。\n- 对于每个查询 $Q_j$ 和每个参考 $R_i$，计算匹配得分 $m(\\mathcal{F}_{Q_j}, \\mathcal{F}_{R_i})$。该得分是每个共同哈希的最小计数值之和，等同于多重集交集的大小。\n- 对于给定的查询 $Q_j$，我们找到使得分最大化的参考索引 $i^\\star = \\arg\\max_i m(\\mathcal{F}_{Q_j}, \\mathcal{F}_{R_i})$。\n- 仅当最大得分大于或等于最小阈值时，才确认此匹配：$\\max_i m(\\mathcal{F}_{Q_j}, \\mathcal{F}_{R_i}) \\ge M_{\\min} = 10$。\n- 如果满足条件，预测索引为 $i^\\star$。否则，预测为 $-1$。\n\n此过程应用于所有查询 $Q_0$ 到 $Q_4$，并将生成的预测索引列表格式化为最终输出。该设计通过其构造，对时间平移和幅度缩放具有鲁棒性，因为哈希值取决于相对时间差和频率箱索引，而不是绝对时间或幅度。它正确地对音高变化不具鲁棒性，因为音高变化会改变频率箱索引 $k$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\nfrom scipy.ndimage import maximum_filter\nfrom collections import Counter\n\ndef solve():\n    \"\"\"\n    Solves the audio fingerprinting problem as specified.\n    \"\"\"\n\n    #\n    # Global Parameters\n    #\n    FS = 8000  # Sampling frequency in Hz\n    N = 1024  # Window length in samples\n    H = 256  # Hop size in samples\n    \n    # Peak finding parameters\n    ALPHA = 0.1  # Relative threshold for peak magnitude\n    DELTA_F = 5  # Frequency neighborhood in bins\n    DELTA_T = 3  # Time neighborhood in frames\n    \n    # Fingerprinting parameters\n    T_MIN = 1  # Minimum time delta in frames\n    T_MAX = 10  # Maximum time delta in frames\n    K_TARGETS = 5  # Max number of targets per anchor\n    \n    # Matching parameters\n    M_MIN = 10  # Minimum match score\n\n    def generate_signals():\n        \"\"\"Generates all reference and query signals.\"\"\"\n        signals = {}\n        T_R = 3.0\n        T_Q = 1.5\n\n        # Reference Signals\n        t_r = np.arange(0, T_R, 1 / FS)\n        signals['R0'] = np.sin(2 * np.pi * 440 * t_r) + 0.7 * np.sin(2 * np.pi * 660 * t_r)\n        signals['R1'] = np.sin(2 * np.pi * 554.365 * t_r) + 0.6 * np.sin(2 * np.pi * 659.255 * t_r)\n        signals['R2'] = np.sin(2 * np.pi * 300 * t_r) + 0.6 * np.sin(2 * np.pi * 900 * t_r)\n\n        # Query Signals\n        # Q0: Excerpt of R0 with noise\n        np.random.seed(0) # for reproducibility\n        t_q0 = np.arange(0.8, 2.3, 1 / FS)\n        x_q0 = np.sin(2 * np.pi * 440 * t_q0) + 0.7 * np.sin(2 * np.pi * 660 * t_q0)\n        noise = np.random.normal(0, 0.02, len(x_q0))\n        signals['Q0'] = x_q0 + noise\n\n        # Q1: Excerpt of R1\n        t_q1 = np.arange(0.5, 2.0, 1 / FS)\n        signals['Q1'] = np.sin(2 * np.pi * 554.365 * t_q1) + 0.6 * np.sin(2 * np.pi * 659.255 * t_q1)\n\n        # Q2: Excerpt of R2, scaled\n        t_q2 = np.arange(1.0, 2.5, 1 / FS)\n        signals['Q2'] = 0.5 * (np.sin(2 * np.pi * 300 * t_q2) + 0.6 * np.sin(2 * np.pi * 900 * t_q2))\n        \n        # Q3: Pitch-shifted R0\n        t_q = np.arange(0, T_Q, 1 / FS)\n        signals['Q3'] = np.sin(2 * np.pi * 484 * t_q) + 0.7 * np.sin(2 * np.pi * 726 * t_q)\n\n        # Q4: Silence\n        signals['Q4'] = np.zeros(int(T_Q * FS))\n\n        return signals\n\n    def compute_fingerprint(x):\n        \"\"\"Computes the fingerprint for a single discrete-time signal x.\"\"\"\n        \n        # Step 1: STFT\n        _, _, Zxx = signal.stft(\n            x,\n            fs=FS,\n            window='hann',\n            nperseg=N,\n            noverlap=N - H,\n            nfft=N,\n            boundary=None,\n            padded=False\n        )\n        S = np.abs(Zxx)\n\n        # Handle silence case\n        max_S = S.max()\n        if max_S == 0:\n            return []\n\n        # Step 2: Peak Finding\n        # Create a boolean mask for peaks\n        # Condition 1: Magnitude threshold\n        threshold = max_S * ALPHA\n        peaks_mask = (S >= threshold)\n        \n        # Condition 2: Local maximum\n        S_max_filtered = maximum_filter(S, size=(2 * DELTA_F + 1, 2 * DELTA_T + 1), mode='constant')\n        peaks_mask &= (S == S_max_filtered)\n        \n        # Get peak coordinates\n        peak_coords = np.argwhere(peaks_mask) # (k, m) pairs\n        \n        # Step 3: Fingerprint (Hash) Generation\n        hashes = []\n        # Sort peaks by time frame index for efficient pairing\n        peak_coords = sorted(peak_coords, key=lambda p: p[1])\n        num_peaks = len(peak_coords)\n\n        for i in range(num_peaks):\n            k_a, m_a = peak_coords[i]\n            \n            candidate_targets = []\n            for j in range(i + 1, num_peaks):\n                k_b, m_b = peak_coords[j]\n                delta_m = m_b - m_a\n                \n                if T_MIN <= delta_m <= T_MAX:\n                    magnitude_b = S[k_b, m_b]\n                    candidate_targets.append(((k_b, m_b), magnitude_b))\n                \n                # Optimization: since peaks are sorted by time, we can break early\n                if delta_m > T_MAX:\n                    break\n            \n            # Sort candidate targets by magnitude and select top K\n            candidate_targets.sort(key=lambda item: item[1], reverse=True)\n            \n            for (k_b, m_b), _ in candidate_targets[:K_TARGETS]:\n                delta_m = m_b - m_a\n                hashes.append((k_a, k_b, delta_m))\n                \n        return hashes\n\n    # --- Main Execution Logic ---\n    \n    # Generate signals\n    all_signals = generate_signals()\n    \n    # Compute fingerprints for reference tracks\n    ref_fingerprints = []\n    for i in range(3):\n        fp = compute_fingerprint(all_signals[f'R{i}'])\n        ref_fingerprints.append(Counter(fp))\n\n    # Process queries\n    results = []\n    for j in range(5):\n        query_fp_list = compute_fingerprint(all_signals[f'Q{j}'])\n        query_fp_counter = Counter(query_fp_list)\n        \n        scores = []\n        for ref_fp_counter in ref_fingerprints:\n            intersection = query_fp_counter & ref_fp_counter\n            score = sum(intersection.values())\n            scores.append(score)\n            \n        max_score = 0\n        if scores:\n            max_score = max(scores)\n        \n        if max_score >= M_MIN:\n            best_match_idx = np.argmax(scores)\n            results.append(best_match_idx)\n        else:\n            results.append(-1)\n            \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2395481"}]}