{"hands_on_practices": [{"introduction": "让我们从一个非常直观的例子开始，它巧妙地揭示了正则化的核心思想。想象一下，一份文件被切成了许多垂直的纸条，顺序被打乱了。我们的任务是像拼图一样将它们重新组合起来。这个问题可以被看作一个逆问题，其中未知的参数是纸条的正确排列顺序。我们通过最小化相邻纸条边界处的像素差异来解决这个问题 [@problem_id:2405441]，这本质上是施加了一个“平滑性”的正则化约束，即假设原始图像在切割处是连续平滑的。这个练习展示了如何将先验知识（平滑性）转化为一个可计算的目标函数，以解决一个原本不适定的组合优化问题。", "problem": "给定一组从单个底层灰度图像中提取的垂直条带。每个条带是一个像素强度矩阵，具有相同的高度和整数宽度。任务是通过选择一个能最小化跨条带边界的、基于平滑度的目标函数的排列，来重建这些条带从左到右的顺序。这是一个逆问题，其中的未知量是排列，而唯一使用的先验信息是一种平滑度正则化，它惩罚相邻条带边界上像素强度的不匹配。\n\n设有 $n$ 个条带，由 $i \\in \\{0,1,\\dots,n-1\\}$ 索引。条带 $i$ 表示为矩阵 $S_i \\in \\mathbb{R}^{H \\times W_i}$，其中 $H$ 是以像素为单位的共同高度，$W_i$ 是以像素为单位的宽度。对于每个条带 $S_i$，其左边界列 $L_i \\in \\mathbb{R}^{H}$ 和右边界列 $R_i \\in \\mathbb{R}^{H}$ 定义如下：\n$$\nL_i = S_i[:,0], \\quad R_i = S_i[:,W_i-1].\n$$\n对于两个条带 $i$（在左侧）和 $j$（在右侧），定义边界不匹配成本为：\n$$\nd(i,j) = \\lVert R_i - L_j \\rVert_2^2 = \\sum_{r=0}^{H-1} \\left(R_i[r] - L_j[r]\\right)^2.\n$$\n对于条带索引的一个排列 $\\pi = (\\pi_0,\\pi_1,\\dots,\\pi_{n-1})$，定义目标函数为：\n$$\nJ(\\pi) = \\sum_{t=0}^{n-2} d\\big(\\pi_t,\\pi_{t+1}\\big).\n$$\n对于 $n=1$ 的情况，约定 $J(\\pi)=0$。重建问题是：找到一个排列 $\\pi^\\star$ 使得 $J(\\pi)$ 最小。在出现平局（即多个排列达到相同的最小目标值）的情况下，选择字典序最小的排列，其中字典序按常规方式从左到右比较索引序列。\n\n您的程序必须为下面定义的每个测试用例解决重建问题，并以基于零的索引列表的形式输出最优排列。不涉及物理单位。不使用角度。要求的输出是整数列表。\n\n测试套件：\n- 情况 A（理想情况；列强度严格递增，单列条带）：\n  高度 $H=3$。条带数 $n=4$，每个宽度为 $W_i=1$：\n  $$\n  S_0 = \\begin{bmatrix} 10 \\\\ 10 \\\\ 10 \\end{bmatrix},\\quad\n  S_1 = \\begin{bmatrix} 20 \\\\ 20 \\\\ 20 \\end{bmatrix},\\quad\n  S_2 = \\begin{bmatrix} 30 \\\\ 30 \\\\ 30 \\end{bmatrix},\\quad\n  S_3 = \\begin{bmatrix} 40 \\\\ 40 \\\\ 40 \\end{bmatrix}.\n  $$\n- 情况 B（边界条件；单个条带）：\n  高度 $H=3$。条带数 $n=1$，宽度为 $W_0=1$：\n  $$\n  S_0 = \\begin{bmatrix} 7 \\\\ 7 \\\\ 7 \\end{bmatrix}.\n  $$\n- 情况 C（含平局的边界情况；两个相同条带和一个不同条带）：\n  高度 $H=3$。条带数 $n=3$，每个宽度为 $W_i=1$：\n  $$\n  S_0 = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix},\\quad\n  S_1 = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix},\\quad\n  S_2 = \\begin{bmatrix} 100 \\\\ 100 \\\\ 100 \\end{bmatrix}.\n  $$\n- 情况 D（多列条带；宽度可变）：\n  高度 $H=3$。条带数 $n=3$，宽度分别为 $W_0=2, W_1=2, W_2=2$：\n  $$\n  S_0 = \\begin{bmatrix} 20 & 50 \\\\ 20 & 50 \\\\ 20 & 50 \\end{bmatrix},\\quad\n  S_1 = \\begin{bmatrix} 0 & 10 \\\\ 0 & 10 \\\\ 0 & 10 \\end{bmatrix},\\quad\n  S_2 = \\begin{bmatrix} 55 & 60 \\\\ 55 & 60 \\\\ 55 & 60 \\end{bmatrix}.\n  $$\n\n最终输出格式：\n您的程序应生成单行输出，包含一个含四个元素的列表，每个元素是对应情况（A, B, C, D）的最优排列，表示为基于零的整数列表。这四个列表必须包含在一对单独的方括号内，并用逗号分隔，其中不含任何空格。例如，一行输出的形式如下\n$$\n[ [\\pi_A], [\\pi_B], [\\pi_C], [\\pi_D] ]\n$$\n但没有任何空格，只使用方括号和逗号，例如\n$$\n[[0,1,2],[3],[1,0,2],[2,0,1]].\n$$\n您的程序必须且只能输出这样一行，不能有其他任何内容。", "solution": "所提出的问题是一个旨在重建图像条带顺序的组合优化任务。这个问题被严格定义且在科学上是合理的，因此被认为是有效的。这是逆问题的一个实例，其中条带的排序是要确定的未知参数。求解方法利用了一个正则化项，具体来说是一个平滑度先验，它对相邻条带之间的不连续性进行惩罚。这是计算科学与工程中的一种标准方法。该问题可以形式化地建模为在完全加权有向图中寻找最短哈密顿路径。\n\n让我们用图论的语言来定义这个问题。这 $n$ 个条带是一个完全有向图 $G=(V, E)$ 的顶点，其中 $V=\\{0, 1, \\dots, n-1\\}$。从顶点 $i$ 到顶点 $j$ 的有向边的权重由边界不匹配成本给出，$d(i, j) = \\lVert R_i - L_j \\rVert_2^2$。此处，$R_i$ 是条带 $S_i$ 的最右侧列向量，$L_j$ 是条带 $S_j$ 的最左侧列向量。条带索引的一个排列 $\\pi = (\\pi_0, \\pi_1, \\dots, \\pi_{n-1})$ 对应于图中的一条哈密顿路径 $P = (\\pi_0, \\pi_1, \\dots, \\pi_{n-1})$。这条路径的总成本，即要最小化的目标函数，是 $J(\\pi) = \\sum_{t=0}^{n-2} d(\\pi_t, \\pi_{t+1})$。\n\n任务是找到一个最小化 $J(\\pi)$ 的排列 $\\pi^\\star$。由于所提供测试用例中的条带数量 $n$ 很小（最大为 $n=4$），对所有 $n!$ 种可能的排列进行穷举搜索是一种可行且正确的策略。这种暴力方法保证能找到全局最优解。平局打破规则要求在有多个最优解时选择字典序最小的排列，这确保了解决方案的唯一性。\n\n该算法流程如下：\n1. 对于给定的 $n$ 个条带集合 $\\{S_0, S_1, \\dots, S_{n-1}\\}$，我们首先为每个条带 $i$ 提取其左、右边界列 $L_i$ 和 $R_i$。\n2. 计算一个大小为 $n \\times n$ 的成本矩阵 $C$，其中元素 $C_{ij} = d(i,j)$（对于 $i \\ne j$）。\n3. 按定义处理 $n=1$ 的特殊情况：唯一的排列是 $(\\pi_0)=(0)$，成本为 $J=0$。\n4. 对于 $n>1$ 的情况，生成索引 $\\{0, 1, \\dots, n-1\\}$ 的所有 $n!$ 个排列。为了遵守平局打破规则，最好按字典序生成这些排列。\n5. 对每个排列 $\\pi$，计算其总成本 $J(\\pi)$。记录下产生最低成本的排列。如果后续发现具有相同最低成本的排列，则忽略它们，因为（由于是按字典序生成）第一个找到的排列将满足平局打破条件。\n\n让我们将此过程应用于每个测试用例。\n\n**情况 A：** $n=4$, $H=3$, $W_i=1$。\n这些条带是单列向量：$S_0 = [10, 10, 10]^T$, $S_1 = [20, 20, 20]^T$, $S_2 = [30, 30, 30]^T$, $S_3 = [40, 40, 40]^T$。对于单列条带，$L_i = R_i = S_i[:,0]$。成本 $d(i, j)$ 取决于条带强度的平方差。为最小化成本总和，强度相近的条带必须相邻放置。有两个明显的候选序列：$(\\pi_a) = (0,1,2,3)$ 和 $(\\pi_b) = (3,2,1,0)$。\n$J(\\pi_a) = d(0,1) + d(1,2) + d(2,3) = 3 \\times (20-10)^2 + 3 \\times (30-20)^2 + 3 \\times (40-30)^2 = 300 + 300 + 300 = 900$。\n$J(\\pi_b) = d(3,2) + d(2,1) + d(1,0) = 3 \\times (30-40)^2 + 3 \\times (20-30)^2 + 3 \\times (10-20)^2 = 300 + 300 + 300 = 900$。\n任何其他排列都会涉及更大的强度跳跃，从而产生更高的成本。例如，$J((0,2,1,3)) = d(0,2) + d(2,1) + d(1,3) = 3 \\times (30-10)^2 + 3 \\times (20-30)^2 + 3 \\times (40-20)^2 = 1200 + 300 + 1200 = 2700$。\n最小成本为 $900$。最优排列是 $(0,1,2,3)$ 和 $(3,2,1,0)$。根据平局打破规则，我们必须选择字典序最小的那个，即 $(0,1,2,3)$。\n\n**情况 B：** $n=1$, $H=3$, $W_0=1$。\n根据问题对 $n=1$ 的定义，目标函数值为 $J=0$。单个索引 $\\{0\\}$ 唯一可能的排列是 $(0)$。因此，解为 $(0)$。\n\n**情况 C：** $n=3$, $H=3$, $W_i=1$。\n条带为 $S_0 = [0,0,0]^T$, $S_1 = [0,0,0]^T$, $S_2 = [100,100,100]^T$。条带 $S_0$ 和 $S_1$ 是相同的。和之前一样，$L_i = R_i$。涉及不同条带的成本为 $d(0,2) = d(2,0) = d(1,2) = d(2,1) = 3 \\times (100-0)^2 = 30000$。相同条带之间的成本为 $d(0,1) = d(1,0) = 0$。\n为了最小化总成本 $J(\\pi) = d(\\pi_0, \\pi_1)+d(\\pi_1, \\pi_2)$，其中一次转移的成本必须为零，这意味着条带 $0$ 和 $1$ 必须相邻。\n使 $S_0, S_1$ 相邻的排列有：\n- $J((0,1,2)) = d(0,1) + d(1,2) = 0 + 30000 = 30000$。\n- $J((1,0,2)) = d(1,0) + d(0,2) = 0 + 30000 = 30000$。\n- $J((2,0,1)) = d(2,0) + d(0,1) = 30000 + 0 = 30000$。\n- $J((2,1,0)) = d(2,1) + d(1,0) = 30000 + 0 = 30000$。\n$S_0, S_1$ 不相邻的排列会产生更高的成本：$J((0,2,1)) = J((1,2,0)) = 30000 + 30000 = 60000$。\n最小成本为 $30000$。最优排列是 $(0,1,2)$、$(1,0,2)$、$(2,0,1)$ 和 $(2,1,0)$。字典序最小的是 $(0,1,2)$。\n\n**情况 D：** $n=3$, $H=3$, $W_i=2$。\n边界列为：\n$L_0=[20,20,20]^T, R_0=[50,50,50]^T$。\n$L_1=[0,0,0]^T, R_1=[10,10,10]^T$。\n$L_2=[55,55,55]^T, R_2=[60,60,60]^T$。\n成对成本 $d(i,j) = \\lVert R_i - L_j \\rVert_2^2$ 如下：\n$d(0,1) = 3 \\times (50-0)^2 = 7500$。\n$d(0,2) = 3 \\times (50-55)^2 = 75$。\n$d(1,0) = 3 \\times (10-20)^2 = 300$。\n$d(1,2) = 3 \\times (10-55)^2 = 6075$。\n$d(2,0) = 3 \\times (60-20)^2 = 4800$。\n$d(2,1) = 3 \\times (60-0)^2 = 10800$。\n所有 $3!=6$ 个排列的总成本如下：\n- $J((0,1,2)) = d(0,1)+d(1,2) = 7500+6075=13575$。\n- $J((0,2,1)) = d(0,2)+d(2,1) = 75+10800=10875$。\n- $J((1,0,2)) = d(1,0)+d(0,2) = 300+75=375$。\n- $J((1,2,0)) = d(1,2)+d(2,0) = 6075+4800=10875$。\n- $J((2,0,1)) = d(2,0)+d(0,1) = 4800+7500=12300$。\n- $J((2,1,0)) = d(2,1)+d(1,0) = 10800+300=11100$。\n最小成本为 $375$，由排列 $(1,0,2)$ 唯一实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import permutations\n\ndef solve():\n    \"\"\"\n    Solves the strip reconstruction problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A: happy path; strictly increasing column intensities\n        [\n            np.array([[10], [10], [10]]),\n            np.array([[20], [20], [20]]),\n            np.array([[30], [30], [30]]),\n            np.array([[40], [40], [40]]),\n        ],\n        # Case B: boundary condition; single strip\n        [\n            np.array([[7], [7], [7]]),\n        ],\n        # Case C: edge case with ties; two identical strips\n        [\n            np.array([[0], [0], [0]]),\n            np.array([[0], [0], [0]]),\n            np.array([[100], [100], [100]]),\n        ],\n        # Case D: multi-column strips; varying widths\n        [\n            np.array([[20, 50], [20, 50], [20, 50]]),\n            np.array([[0, 10], [0, 10], [0, 10]]),\n            np.array([[55, 60], [55, 60], [55, 60]]),\n        ],\n    ]\n\n    results = []\n    for strips in test_cases:\n        result = find_optimal_permutation(strips)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The replacement of spaces is crucial for matching the output format.\n    print(str(results).replace(' ', ''))\n\ndef find_optimal_permutation(strips):\n    \"\"\"\n    Finds the optimal permutation of strips that minimizes boundary mismatch.\n\n    Args:\n        strips (list of np.ndarray): A list of matrices representing image strips.\n\n    Returns:\n        list: The lexicographically smallest optimal permutation of strip indices.\n    \"\"\"\n    n = len(strips)\n\n    # Handle the base case of a single strip.\n    if n == 1:\n        return [0]\n\n    # Extract left and right boundary columns for each strip.\n    left_boundaries = [s[:, 0] for s in strips]\n    right_boundaries = [s[:, -1] for s in strips]\n\n    # Pre-compute the pairwise cost matrix d(i, j).\n    cost_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            # Cost is the squared L2 norm of the difference between\n            # the right boundary of strip i and the left boundary of strip j.\n            diff = right_boundaries[i] - left_boundaries[j]\n            cost_matrix[i, j] = np.dot(diff, diff)\n\n    min_cost = float('inf')\n    best_perm = None\n\n    # Iterate through all permutations of strip indices.\n    # `itertools.permutations` generates them in lexicographical order.\n    for perm in permutations(range(n)):\n        current_cost = 0.0\n        # Calculate the total cost for the current permutation.\n        for t in range(n - 1):\n            current_cost += cost_matrix[perm[t], perm[t+1]]\n        \n        # If a new minimum cost is found, update the best permutation.\n        # Because we iterate in lexicographical order, the first time we\n        # find a permutation with the minimum cost, it will be the\n        # lexicographically smallest one among all optimal permutations.\n        if current_cost < min_cost:\n            min_cost = current_cost\n            best_perm = perm\n\n    return list(best_perm)\n\nsolve()\n```", "id": "2405441"}, {"introduction": "接下来，我们转向一个计算工程中的经典应用：声学层析成像。在这个练习中，我们的目标是通过测量声波穿过一个介质的传播时间，来重建该介质内部未知的声速分布。这是一个典型的线性逆问题，由于测量数据可能不完整或含有噪声，直接求解往往会导致不稳定且无物理意义的结果。通过引入吉洪诺夫（Tikhonov）正则化 [@problem_id:2405385]，我们在拟合数据的同时，对解的“粗糙度”进行惩罚，从而获得一个平滑且稳定的声速剖面。这个实践将带你体验如何构建正向模型、设计正则化项，并通过求解正规方程来应对不同数据质量下的逆问题挑战。", "problem": "考虑一个占据区间 $[0,L]$ 的一维声学介质，其中 $L = 1000 \\ \\text{m}$。一个点源位于 $x=0$ 处。未知的声速场 $c(x)$ 假定在 $N$ 个等宽单元上是分段常数，每个单元宽度为 $\\Delta x = L/N$，其中 $N = 10$。令 $c_i$ 表示单元 $i \\in \\{1,2,\\dots,N\\}$ 中的声速（单位为 $\\text{m/s}$），令 $s_i$ 表示该单元中的慢度，定义为 $s_i = 1/c_i$（单位为 $\\text{s/m}$）。通过放置在选定单元边界 $x_k = k \\, \\Delta x$（$k \\in \\{1,2,\\dots,N\\}$）处的接收器进行走时测量。到达接收器 $k$ 的走时定义为\n$$\nt_k \\;=\\; \\int_{0}^{x_k} \\frac{1}{c(x)} \\, dx \\;+\\; \\varepsilon_k \\;=\\; \\sum_{i=1}^{k} \\Delta x \\, s_i \\;+\\; \\varepsilon_k,\n$$\n其中 $\\varepsilon_k$ 是一个加性扰动（单位为 $\\text{s}$）。定义测量矩阵 $W \\in \\mathbb{R}^{K \\times N}$，其中 $K$ 是所用接收器的数量，其定义为\n$$\nW_{k,i} \\;=\\; \\begin{cases}\n\\Delta x, & i \\le k,\\\\\n0, & i > k,\n\\end{cases}\n$$\n对于 $k \\in \\{1,\\dots,K\\}$ 和 $i \\in \\{1,\\dots,N\\}$。令 $\\mathbf{t} \\in \\mathbb{R}^{K}$ 汇集所有 $t_k$，$\\mathbf{s} \\in \\mathbb{R}^{N}$ 汇集所有 $s_i$。离散正演模型为 $\\mathbf{t} = W \\mathbf{s} + \\boldsymbol{\\varepsilon}$。\n\n通过将 $\\mathbf{s}$ 重建为以下带二次粗糙度惩罚的正则化最小二乘问题的唯一最小化子，来重建 $\\mathbf{c}$：\n$$\n\\min_{\\mathbf{s} \\in \\mathbb{R}^{N}} \\; J(\\mathbf{s}) \\;=\\; \\frac{1}{2} \\lVert W \\mathbf{s} - \\mathbf{t} \\rVert_2^2 \\;+\\; \\frac{\\lambda}{2} \\lVert D \\mathbf{s} \\rVert_2^2,\n$$\n其中 $\\lambda \\ge 0$ 是一个标量参数，$D \\in \\mathbb{R}^{(N-1)\\times N}$ 是由下式定义的一阶差分算子\n$$\n(D\\mathbf{s})_i \\;=\\; s_{i+1} - s_i, \\quad \\text{for } i \\in \\{1,\\dots,N-1\\},\n$$\n即 $D_{i,i} = -1$，$D_{i,i+1} = 1$，$D$ 的所有其他项均为零。获得最小化子 $\\widehat{\\mathbf{s}}$ 后，按单元计算重建的声速 $\\widehat{c}_i = 1 / \\widehat{s}_i$（单位为 $\\text{m/s}$）。为进行评估，使用均方根误差（单位为 $\\text{m/s}$）\n$$\n\\text{RMSE} \\;=\\; \\sqrt{ \\frac{1}{N} \\sum_{i=1}^{N} \\left( \\widehat{c}_i - c_i^{\\star} \\right)^2 },\n$$\n相对于下文指定的真实值 $\\mathbf{c}^{\\star}$。\n\n使用以下真实值和测试组。各单元的真实声速向量（单位为 $\\text{m/s}$）为\n$$\n\\mathbf{c}^{\\star} \\;=\\; [\\,1480,\\;1480,\\;1500,\\;1520,\\;1550,\\;1550,\\;1530,\\;1500,\\;1490,\\;1480\\,].\n$$\n扰动是确定性的，对于给定的 $\\sigma \\ge 0$ 定义为\n$$\n\\varepsilon_k \\;=\\; \\sigma \\, (-1)^k, \\quad \\text{for } k \\in \\{1,\\dots,K\\},\n$$\n单位为秒。\n\n测试组（每行定义一个测试用例及其参数）：\n- 用例1：$K = 10$，接收器位于所有边界 $x_k = k \\Delta x$，$k \\in \\{1,\\dots,10\\}$，$\\sigma = 0$，$\\lambda = 0$。\n- 用例2：$K = 6$，接收器位于 $x_k = k \\Delta x$，$k \\in \\{1,\\dots,6\\}$，$\\sigma = 0$，$\\lambda = 10^{-2}$。\n- 用例3：$K = 10$，接收器位于 $x_k = k \\Delta x$，$k \\in \\{1,\\dots,10\\}$，$\\sigma = 5 \\times 10^{-4}$，$\\lambda = 10^{-3}$。\n- 用例4：$K = 10$，接收器位于 $x_k = k \\Delta x$，$k \\in \\{1,\\dots,10\\}$，$\\sigma = 5 \\times 10^{-3}$，$\\lambda = 1$。\n\n所有走时必须以秒表示，所有声速必须以米/秒表示。本问题不使用角度。\n\n您的程序必须为每个测试用例，精确地按照定义构建 $W$ 和 $D$，根据 $\\mathbf{c}^{\\star}$ 和指定的 $\\sigma$ 合成 $\\mathbf{t}$，计算 $J(\\mathbf{s})$ 的唯一最小化子 $\\widehat{\\mathbf{s}}$，将其转换为 $\\widehat{\\mathbf{c}}$，并以浮点数形式报告以米/秒为单位的 $\\text{RMSE}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4]$），$r_j$ 是测试用例 $j$ 的 $\\text{RMSE}$（单位为 $\\text{m/s}$）。顺序必须是：用例1，用例2，用例3，用例4。", "solution": "问题陈述已经过严格验证，并被认定为有效。它具有科学依据，是适定的、客观的且内部一致的。它描述了计算科学中的一个标准问题：用于声学走时层析成像的一维正则化线性反演问题。所有参数和必要的定义均已提供，从而可以为每个指定的测试用例计算出唯一且有意义的解。因此，我们可以继续进行解的推导和实现。\n\n问题的核心是找到慢度向量 $\\mathbf{s} \\in \\mathbb{R}^{N}$，以最小化 Tikhonov 正则化目标函数：\n$$\nJ(\\mathbf{s}) \\;=\\; \\frac{1}{2} \\lVert W \\mathbf{s} - \\mathbf{t} \\rVert_2^2 \\;+\\; \\frac{\\lambda}{2} \\lVert D \\mathbf{s} \\rVert_2^2\n$$\n此处，$\\mathbf{s}$ 是未知单元慢度向量，$\\mathbf{t}$ 是测量走时向量，$W$ 是正演模型矩阵，$D$ 是作为正则化矩阵的一阶差分算子，$\\lambda \\ge 0$ 是正则化参数。\n\n$J(\\mathbf{s})$ 函数是关于 $\\mathbf{s}$ 的二次凸函数。其唯一的最小化子（我们表示为 $\\widehat{\\mathbf{s}}$）可以通过计算 $J(\\mathbf{s})$ 相对于 $\\mathbf{s}$ 的梯度并将其设为零向量来找到。梯度由下式给出：\n$$\n\\nabla_{\\mathbf{s}} J(\\mathbf{s}) \\;=\\; \\nabla_{\\mathbf{s}} \\left( \\frac{1}{2} (W\\mathbf{s} - \\mathbf{t})^T (W\\mathbf{s} - \\mathbf{t}) \\right) \\;+\\; \\nabla_{\\mathbf{s}} \\left( \\frac{\\lambda}{2} (D\\mathbf{s})^T (D\\mathbf{s}) \\right)\n$$\n使用标准矩阵微积分法则，这两项的梯度分别为：\n$$\n\\nabla_{\\mathbf{s}} \\left( \\frac{1}{2} \\lVert W \\mathbf{s} - \\mathbf{t} \\rVert_2^2 \\right) = W^T(W\\mathbf{s} - \\mathbf{t})\n$$\n$$\n\\nabla_{\\mathbf{s}} \\left( \\frac{\\lambda}{2} \\lVert D \\mathbf{s} \\rVert_2^2 \\right) = \\lambda D^T D \\mathbf{s}\n$$\n将总梯度设为零，得到以下方程：\n$$\nW^T(W\\widehat{\\mathbf{s}} - \\mathbf{t}) + \\lambda D^T D \\widehat{\\mathbf{s}} = \\mathbf{0}\n$$\n整理各项以分离 $\\widehat{\\mathbf{s}}$，我们得到该正则化最小二乘问题的正规方程：\n$$\n(W^T W + \\lambda D^T D) \\widehat{\\mathbf{s}} \\;=\\; W^T \\mathbf{t}\n$$\n这是一个 $A\\mathbf{x} = \\mathbf{b}$ 形式的线性方程组，其中系统矩阵是 $A = (W^T W + \\lambda D^T D)$，未知向量是 $\\mathbf{x} = \\widehat{\\mathbf{s}}$，右侧向量是 $\\mathbf{b} = W^T \\mathbf{t}$。如验证时所确定，对于所有指定的测试用例，矩阵 $A$ 都是可逆的，这确保了唯一的解 $\\widehat{\\mathbf{s}}$ 存在，并且可以通过求解该线性系统来计算。\n\n每个测试用例的计算流程如下：\n1. 定义物理和离散化参数：$L = 1000 \\ \\text{m}$，$N = 10$，以及 $\\Delta x = L/N = 100 \\ \\text{m}$。\n2. 定义真实声速向量 $\\mathbf{c}^{\\star} \\in \\mathbb{R}^{N}$，并按分量计算相应的真实慢度向量 $\\mathbf{s}^{\\star}$，$s^{\\star}_i = 1/c^{\\star}_i$。\n3. 对于每个由参数 $K$、$\\sigma$ 和 $\\lambda$ 指定的测试用例：\n    a. 根据定义 $W_{k,i} = \\Delta x$（当 $i \\le k$）和 $W_{k,i} = 0$（当 $i > k$）构建测量矩阵 $W \\in \\mathbb{R}^{K \\times N}$，为使问题域清晰，此处使用基于 1 的索引。\n    b. 构建一阶差分算子 $D \\in \\mathbb{R}^{(N-1) \\times N}$，其中每行 $i$ 实现操作 $s_{i+1} - s_i$。\n    c. 合成测量向量 $\\mathbf{t} \\in \\mathbb{R}^{K}$。这包括计算理想的、无扰动的走时 $\\mathbf{t}_{ideal} = W \\mathbf{s}^{\\star}$，并加上确定性扰动向量 $\\boldsymbol{\\varepsilon}$，其中 $\\varepsilon_k = \\sigma (-1)^k$，$k \\in \\{1, \\dots, K\\}$。最终的测量向量是 $\\mathbf{t} = \\mathbf{t}_{ideal} + \\boldsymbol{\\varepsilon}$。\n    d. 构成系统矩阵 $A = W^T W + \\lambda D^T D$ 和右侧向量 $\\mathbf{b} = W^T \\mathbf{t}$。\n    e. 求解线性系统 $A \\widehat{\\mathbf{s}} = \\mathbf{b}$ 以获得估计的慢度向量 $\\widehat{\\mathbf{s}}$。\n    f. 通过 $\\widehat{c}_i = 1/\\widehat{s}_i$ 将估计的慢度向量 $\\widehat{\\mathbf{s}}$ 转换回声速向量 $\\widehat{\\mathbf{c}}$。\n    g. 通过计算重建声速 $\\widehat{\\mathbf{c}}$ 与真实声速 $\\mathbf{c}^{\\star}$ 之间的均方根误差（$\\text{RMSE}$）来评估重建质量：\n    $$\n    \\text{RMSE} \\;=\\; \\sqrt{ \\frac{1}{N} \\sum_{i=1}^{N} \\left( \\widehat{c}_i - c_i^{\\star} \\right)^2 }\n    $$\n此程序将应用于提供的四个测试用例中的每一个，并报告所得的 $\\text{RMSE}$ 值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D acoustic tomography inverse problem for four test cases.\n    \"\"\"\n    # Define physical and discretization parameters\n    L = 1000.0  # m\n    N = 10      # number of cells\n    delta_x = L / N # m\n\n    # Ground-truth sound speed vector (m/s)\n    c_star = np.array([1480., 1480., 1500., 1520., 1550., 1550., 1530., 1500., 1490., 1480.])\n    \n    # Ground-truth slowness vector (s/m)\n    s_star = 1.0 / c_star\n\n    # Define the test suite\n    test_cases = [\n        # Case 1: Full data, no noise, no regularization\n        {'K': 10, 'sigma': 0.0, 'lam': 0.0},\n        # Case 2: Incomplete data, no noise, with regularization\n        {'K': 6, 'sigma': 0.0, 'lam': 1e-2},\n        # Case 3: Full data, small noise, with regularization\n        {'K': 10, 'sigma': 5e-4, 'lam': 1e-3},\n        # Case 4: Full data, larger noise, stronger regularization\n        {'K': 10, 'sigma': 5e-3, 'lam': 1.0},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        K = case['K']\n        sigma = case['sigma']\n        lam = case['lam']\n\n        # 1. Construct the measurement matrix W (K x N)\n        # W_ki = delta_x if i <= k, 0 otherwise (1-based indexing)\n        # In 0-based code: W[k_idx, i_idx] for i_idx <= k_idx\n        W = np.zeros((K, N))\n        for k in range(K):\n            for i in range(k + 1):\n                W[k, i] = delta_x\n\n        # 2. Construct the first-difference operator D ((N-1) x N)\n        # (Ds)_i = s_{i+1} - s_i\n        # This corresponds to a matrix with -1 on the main diagonal and 1 on the first super-diagonal.\n        D = np.eye(N, k=1) - np.eye(N, k=0)\n        D = D[:-1, :] # Keep the first N-1 rows\n\n        # 3. Synthesize the measurement vector t (K x 1)\n        # t = W * s_star + eps\n        t_ideal = W @ s_star\n        \n        # Perturbation vector eps, where eps_k = sigma * (-1)^k for k=1..K\n        k_indices = np.arange(1, K + 1)\n        eps = sigma * ((-1.0)**k_indices)\n        \n        t = t_ideal + eps\n\n        # 4. Form the system matrix A and right-hand side b for the normal equations\n        # (W^T W + lambda * D^T D) * s_hat = W^T * t\n        A = W.T @ W + lam * (D.T @ D)\n        b = W.T @ t\n\n        # 5. Solve the linear system for the estimated slowness s_hat\n        s_hat = np.linalg.solve(A, b)\n\n        # 6. Convert estimated slowness to sound speed\n        c_hat = 1.0 / s_hat\n\n        # 7. Calculate the Root-Mean-Square Error (RMSE)\n        rmse = np.sqrt(np.mean((c_hat - c_star)**2))\n        results.append(rmse)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "2405385"}, {"introduction": "在掌握了如何应用正则化求解逆问题之后，一个更深层次的问题是：我们得到的解到底有多稳定？这个高级练习将引导我们从“求解”问题转向“分析”解的稳定性。我们将挑战一个有趣的任务：构建一个特定模式的噪声，它虽然能量有限（范数为1），但能对吉洪诺夫正则化解造成最大程度的扰动。通过解决这个问题 [@problem_id:2405424]，你将学习到解的扰动与一个特定的线性算子（与正向模型和正则化参数 $\\alpha$ 有关）之间的关系，并利用奇异值分解（SVD）来找到其“最坏情况”下的放大效应。这不仅能加深对正则化作用的理解，还能让你洞悉系统稳定性的本质。", "problem": "给定一个由实数矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 表示的线性正演模型，一个吉洪诺夫(Tikhonov)正则化参数 $\\alpha \\in \\mathbb{R}$ 且 $\\alpha \\gt 0$，以及一个数据向量 $y \\in \\mathbb{R}^{m}$。吉洪诺夫正则化解 $x_{\\alpha}(y) \\in \\mathbb{R}^{n}$ 被定义为如下严格凸目标函数的唯一最小化子：\n$$\n\\min_{x \\in \\mathbb{R}^{n}} \\ \\|A x - y\\|_{2}^{2} + \\alpha^{2} \\|x\\|_{2}^{2}.\n$$\n考虑一个加到数据上的扰动（噪声）向量 $z \\in \\mathbb{R}^{m}$，得到扰动解 $x_{\\alpha}(y+z)$。将解中的扰动定义为\n$$\n\\Delta x_{\\alpha}(z) \\coloneqq x_{\\alpha}(y+z) - x_{\\alpha}(y).\n$$\n在所有欧几里得范数 $\\|z\\|_{2} = 1$ 的扰动 $z$ 中，找到使解扰动的欧几里得范数 $\\|\\Delta x_{\\alpha}(z)\\|_{2}$ 最大化的向量 $z^{\\star}$。如果存在多个最大化子，则采用以下方向约定来选择唯一的 $z^{\\star}$：令 $i$ 为满足 $|z^{\\star}_{i}| \\gt 10^{-12}$ 的最小索引；要求 $z^{\\star}_{i} \\gt 0$。如果不存在这样的索引，则保持 $z^{\\star}$ 不变。\n\n对下面的每个测试用例，计算：\n1) 最大放大值 $a^{\\star} \\coloneqq \\max_{\\|z\\|_{2} = 1} \\|\\Delta x_{\\alpha}(z)\\|_{2}$。\n2) 一个满足方向约定的最大化噪声向量 $z^{\\star}$。\n\n您必须实现一个程序来处理以下测试套件。对于每个用例，使用给定的 $A$ 和 $\\alpha$。数据向量 $y$ 是任意的，并且在此任务中不影响 $\\Delta x_{\\alpha}(z)$。\n\n测试套件：\n- 用例 1：$A \\in \\mathbb{R}^{4 \\times 3}$，其行为 $[\\,1,0,0\\,]$, $[\\,0,2,0\\,]$, $[\\,0,0,3\\,]$, $[\\,1,1,1\\,]$；$\\alpha = 0.7$。\n- 用例 2：$A \\in \\mathbb{R}^{2 \\times 2}$，其行为 $[\\,1,2\\,]$, $[\\,3,4\\,]$；$\\alpha = 10^{-3}$。\n- 用例 3：$A \\in \\mathbb{R}^{3 \\times 2}$，其行为 $[\\,1,2\\,]$, $[\\,2,4\\,]$, $[\\,0,0\\,]$；$\\alpha = 0.05$。\n- 用例 4：$A \\in \\mathbb{R}^{3 \\times 3}$，其行为 $[\\,3,0,0\\,]$, $[\\,0,10^{-2},0\\,]$, $[\\,0,0,2\\,]$；$\\alpha = 10.0$。\n\n您的程序必须输出一个包含列表的列表的单行。对每个测试用例，输出一个列表，其第一个条目是浮点数 $a^{\\star}$，后随 $z^{\\star}$ 的分量。所有浮点数必须使用标准的“四舍五入到最近的偶数”规则四舍五入到 $6$ 位小数，并且 $-0.0$ 的值应打印为 $0.0$。\n\n最终输出格式：\n向标准输出产生仅一行，包含\n$$\n[[a^{\\star}_{1}, z^{\\star}_{1,1}, \\dots, z^{\\star}_{1,m_{1}}], [a^{\\star}_{2}, z^{\\star}_{2,1}, \\dots, z^{\\star}_{2,m_{2}}], [a^{\\star}_{3}, z^{\\star}_{3,1}, \\dots, z^{\\star}_{3,m_{3}}], [a^{\\star}_{4}, z^{\\star}_{4,1}, \\dots, z^{\\star}_{4,m_{4}}]],\n$$\n其中 $m_{i}$ 是用例 $i$ 中 $A$ 的行数。例如，输出必须具有以下语法形式\n$$\n[[a_{1},z_{1,1},\\dots],[a_{2},z_{2,1},\\dots],[a_{3},z_{3,1},\\dots],[a_{4},z_{4,1},\\dots]].\n$$\n不应打印任何额外文本。", "solution": "所述问题在数学上和科学上是合理的。这是一个计算工程领域的适定问题，具体涉及线性逆问题的吉洪诺夫(Tikhonov)正则化解的稳定性分析。我们将着手进行其形式推导和求解。\n\n该问题要求找到单位范数 $\\|z\\|_{2} = 1$ 的噪声向量 $z \\in \\mathbb{R}^{m}$，该向量能最大化吉洪诺夫正则化解中产生的扰动范数 $\\|\\Delta x_{\\alpha}(z)\\|_{2}$。\n\n首先，我们必须推导出解扰动 $\\Delta x_{\\alpha}(z)$ 的显式表达式。吉洪诺夫正则化解 $x_{\\alpha}(y)$ 是以下泛函的唯一最小化子\n$$\nJ(x) = \\|A x - y\\|_{2}^{2} + \\alpha^{2} \\|x\\|_{2}^{2}\n$$\n其中 $A \\in \\mathbb{R}^{m \\times n}$，$y \\in \\mathbb{R}^{m}$，且 $\\alpha > 0$。泛函 $J(x)$ 是严格凸的，其最小化子可以通过将其关于 $x$ 的梯度设为零来找到。该梯度为\n$$\n\\nabla_{x} J(x) = \\nabla_{x} \\left( (Ax - y)^T(Ax-y) + \\alpha^2 x^T x \\right) = 2 A^T(Ax - y) + 2 \\alpha^2 x.\n$$\n将梯度设为零，得到吉洪诺夫问题的正规方程组：\n$$\n(A^T A + \\alpha^2 I) x = A^T y,\n$$\n其中 $I$ 是 $n \\times n$ 的单位矩阵。由于 $A^T A$ 是一个半正定矩阵且 $\\alpha^2 > 0$，矩阵 $(A^T A + \\alpha^2 I)$ 是正定的，因此是可逆的。唯一解是\n$$\nx_{\\alpha}(y) = (A^T A + \\alpha^2 I)^{-1} A^T y.\n$$\n现在，考虑一个加到数据向量 $y$ 上的扰动 $z \\in \\mathbb{R}^{m}$。扰动后的数据是 $y+z$，相应的解是\n$$\nx_{\\alpha}(y+z) = (A^T A + \\alpha^2 I)^{-1} A^T (y+z).\n$$\n解中的扰动 $\\Delta x_{\\alpha}(z)$ 定义为扰动解与原始解之差：\n$$\n\\Delta x_{\\alpha}(z) \\coloneqq x_{\\alpha}(y+z) - x_{\\alpha}(y).\n$$\n代入解的表达式，我们发现从数据到解的映射算子是线性的。因此，\n$$\n\\Delta x_{\\alpha}(z) = (A^T A + \\alpha^2 I)^{-1} A^T (y+z) - (A^T A + \\alpha^2 I)^{-1} A^T y = (A^T A + \\alpha^2 I)^{-1} A^T z.\n$$\n此表达式表明，解扰动 $\\Delta x_{\\alpha}(z)$ 是数据扰动 $z$ 的线性函数，并且与原始数据向量 $y$ 无关。我们定义算子 $K \\in \\mathbb{R}^{n \\times m}$ 为\n$$\nK \\coloneqq (A^T A + \\alpha^2 I)^{-1} A^T.\n$$\n那么，解扰动就是 $\\Delta x_{\\alpha}(z) = Kz$。\n\n问题的核心是解决以下优化问题：\n$$\n\\max_{\\|z\\|_{2} = 1} \\|\\Delta x_{\\alpha}(z)\\|_{2} = \\max_{\\|z\\|_{2} = 1} \\|Kz\\|_{2}.\n$$\n根据定义，在所有单位向量 $z$ 上 $\\|Kz\\|_{2}$ 的最大值是矩阵 $K$ 的谱范数，记为 $\\|K\\|_{2}$。因此，最大放大值为\n$$\na^{\\star} = \\|K\\|_{2}.\n$$\n一个矩阵的谱范数等于其最大的奇异值 $\\sigma_{\\max}(K)$。达到这个最大值的向量 $z^{\\star}$ 是 $K$ 对应于这个最大奇异值的右奇异向量。\n\n设 $K$ 的奇异值分解（SVD）为 $K = U_K \\Sigma_K V_K^T$，其中 $U_K$ 和 $V_K$ 是正交矩阵，$\\Sigma_K$ 是奇异值矩阵（$\\sigma_1 \\ge \\sigma_2 \\ge \\dots$）。那么，\n$$\na^{\\star} = \\sigma_{\\max}(K) = \\sigma_1(K).\n$$\n最大化向量 $z^{\\star}$ 是矩阵 $V_K$ 的第一列，这对应于 $V_K^T$ 的第一行。\n\n右奇异向量的唯一性只在符号上确定。问题规定了一个方向约定来选择唯一的 $z^{\\star}$：对于计算出的 $z^{\\star}$，找到满足 $|z^{\\star}_{i}| > 10^{-12}$ 的最小索引 $i$。如果该分量 $z^{\\star}_{i}$ 为负，则整个向量 $z^{\\star}$ 必须取反。这确保了结果的唯一性，而不改变解扰动的范数，因为 $\\|K(-z^{\\star})\\|_{2} = \\|-Kz^{\\star}\\|_{2} = \\|Kz^{\\star}\\|_{2}$。\n\n计算步骤如下：\n1. 对于给定的矩阵 $A$ 和参数 $\\alpha$，构造矩阵 $K = (A^T A + \\alpha^2 I)^{-1} A^T$。\n2. 计算 $K$ 的奇异值分解（SVD），以获得其奇异值和右奇异向量。\n3. 最大放大值 $a^{\\star}$ 是最大的奇异值。\n4. 初始的最大化噪声向量 $z^{\\star}$ 是对应于 $a^{\\star}$ 的右奇异向量。\n5. 根据指定的方向约定调整 $z^{\\star}$ 的符号。\n6. 遵循指定的舍入和格式化规则，将结果舍入到 $6$ 位小数以供输出。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import svd\n\ndef solve_case(A, alpha):\n    \"\"\"\n    Solves the amplification problem for a given matrix A and parameter alpha.\n\n    Args:\n        A (np.ndarray): The forward model matrix.\n        alpha (float): The Tikhonov regularization parameter.\n\n    Returns:\n        tuple: A tuple containing:\n            - a_star (float): The maximum amplification factor.\n            - z_star (np.ndarray): The maximizing noise vector.\n    \"\"\"\n    m, n = A.shape\n\n    # Step 1: Construct the matrix K = (A^T A + alpha^2 I)^-1 A^T\n    I_n = np.eye(n)\n    AtA = A.T @ A\n    # The matrix G = A^T A + alpha^2 I is always invertible for alpha > 0\n    G = AtA + (alpha**2) * I_n\n    G_inv = np.linalg.inv(G)\n    K = G_inv @ A.T\n\n    # Step 2: Compute the SVD of K.\n    # scipy.linalg.svd returns U, s, Vh, where Vh is V.T.\n    _U, s, Vh = svd(K)\n\n    # Step 3: a_star is the largest singular value.\n    a_star = s[0]\n\n    # Step 4: z_star is the corresponding right singular vector (first row of Vh).\n    z_star = Vh[0, :]\n\n    # Step 5: Apply the specified orientation convention.\n    # The convention ensures a unique maximizer z_star, as singular vectors are\n    # defined up to a sign.\n    # We find the first component with magnitude above a small tolerance\n    # and ensure it is positive.\n    tol = 1e-12\n    # np.where returns a tuple of arrays; we need the first element of the first array.\n    significant_indices = np.where(np.abs(z_star) > tol)[0]\n    if significant_indices.size > 0:\n        first_significant_idx = significant_indices[0]\n        if z_star[first_significant_idx] < 0:\n            z_star = -z_star\n            \n    return a_star, z_star\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        (np.array([[1.0, 0.0, 0.0], \n                   [0.0, 2.0, 0.0], \n                   [0.0, 0.0, 3.0], \n                   [1.0, 1.0, 1.0]]), 0.7),\n        # Case 2\n        (np.array([[1.0, 2.0], \n                   [3.0, 4.0]]), 1e-3),\n        # Case 3\n        (np.array([[1.0, 2.0], \n                   [2.0, 4.0], \n                   [0.0, 0.0]]), 0.05),\n        # Case 4\n        (np.array([[3.0, 0.0, 0.0], \n                   [0.0, 1e-2, 0.0], \n                   [0.0, 0.0, 2.0]]), 10.0)\n    ]\n    \n    all_results_str = []\n    \n    for A, alpha in test_cases:\n        a_star, z_star = solve_case(A, alpha)\n        \n        # Combine results into a single list for formatting\n        case_output = [a_star] + list(z_star)\n        \n        formatted_numbers = []\n        for num in case_output:\n            # Round to 6 decimal places using standard rounding (ties to even)\n            rounded_num = round(num, 6)\n            # Handle the special case where -0.0 should be printed as 0.0\n            if rounded_num == -0.0:\n                rounded_num = 0.0\n            # Format to ensure 6 decimal places are always shown\n            formatted_numbers.append(f\"{rounded_num:.6f}\")\n        \n        all_results_str.append(f\"[{','.join(formatted_numbers)}]\")\n        \n    # Print the final output in the required single-line format\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "2405424"}]}