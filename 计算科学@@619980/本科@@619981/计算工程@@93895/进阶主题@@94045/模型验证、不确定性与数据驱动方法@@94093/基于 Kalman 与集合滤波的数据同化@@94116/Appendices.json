{"hands_on_practices": [{"introduction": "本练习将带领你动手实现卡尔曼滤波器的核心功能，用于解决一个经典的信号处理问题。我们将通过处理模拟的伪距测量数据，来估计GPS卫星时钟相对于主时钟的偏差 $b_k$ 和漂移 $d_k$ 这两个隐藏状态。通过这个实践，你将掌握卡尔曼滤波器在处理线性动态系统时，其预测和更新循环的基本实现方法。[@problem_id:2382578]", "problem": "考虑一颗全球定位系统 (GPS) 卫星，其时钟相对于主时钟在离散时间 $t_k$ (单位：秒) 的模型由未知时钟偏差 $b_k$ (单位：秒) 和未知时钟漂移 $d_k$ (单位：秒/秒) 描述。隐藏状态为 $x_k = \\begin{bmatrix} b_k \\\\ d_k \\end{bmatrix}$。该卫星时钟服从一个线性状态演化模型\n$$\n\\begin{aligned}\nb_{k+1} &= b_k + d_k \\,\\Delta t_k + w_{b,k},\\\\\nd_{k+1} &= d_k + w_{d,k},\n\\end{aligned}\n$$\n其中 $\\Delta t_k = t_{k+1} - t_k$，过程噪声 $w_{b,k}$ 和 $w_{d,k}$ 是相互独立的零均值高斯白噪声，其方差分别为 $\\operatorname{Var}(w_{b,k}) = q_b \\,\\Delta t_k$ 和 $\\operatorname{Var}(w_{d,k}) = q_d \\,\\Delta t_k$。在时间 $t_k$ 的伪距残差测量值 $z_k$ (单位：米) 与时钟偏差的关系为\n$$\nz_k = c\\, b_k + v_k,\n$$\n其中 $c = 299792458$ (单位：米/秒) 是光速，$v_k$ 是零均值高斯噪声，其方差为 $\\operatorname{Var}(v_k) = r^2$ (单位：米的平方)。初始状态服从高斯分布，其均值为 $m_0 = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$，协方差为 $P_0 = \\operatorname{diag}\\!\\big((10^{-6})^2, (10^{-10})^2\\big)$。\n\n任务：对于下方的每个测试用例，给定时间戳 $t_k$、测量值 $z_k$ 以及参数 $r$、$q_b$ 和 $q_d$，计算最终时刻状态的后验均值（即，基于截至并包含最后一个测量值在内的所有测量值，对 $\\begin{bmatrix} b_T \\\\ d_T \\end{bmatrix}$ 的最小均方误差估计）。将最终估计值 $b_T$（单位：秒）和 $d_T$（单位：秒/秒）均表示为浮点数，输出中不含单位符号。\n\n测试套件：\n- 用例 A:\n  - 时间 (秒)：$[0, 1, 2, 3, 4, 5]$。\n  - 测量值 (米)：$[34.775095, 36.924783647, 37.874472334, 36.624161021, 38.073849708, 37.823538395]$。\n  - 测量噪声标准差 (米)：$r = 2.0$。\n  - 过程噪声强度：$q_b = 1.0 \\times 10^{-20}$, $q_d = 1.0 \\times 10^{-22}$。\n\n- 用例 B:\n  - 时间 (秒)：$[0, 1, 2, 3, 4, 5]$。\n  - 测量值 (米)：$[24.18339664, 23.88339664, 24.38339664, 23.68339664, 23.98339664, 24.08339664]$。\n  - 测量噪声标准差 (米)：$r = 1.0$。\n  - 过程噪声强度：$q_b = 1.0 \\times 10^{-22}$, $q_d = 1.0 \\times 10^{-24}$。\n\n- 用例 C:\n  - 时间 (秒)：$[0, 2, 3.5, 7.0, 7.5, 10.0]$。\n  - 测量值 (米)：$[11.9896229, 17.4296644084, 13.3846955397, 15.7797681794, 14.7647785565, 12.689830442]$。\n  - 测量噪声标准差 (米)：$r = 5.0$。\n  - 过程噪声强度：$q_b = 5.0 \\times 10^{-20}$, $q_d = 1.0 \\times 10^{-20}$。\n\n- 用例 D:\n  - 时间 (秒)：$[0, 0.5, 1.0, 1.5, 2.0]$。\n  - 测量值 (米)：$[0.05, 0.729481145, 1.50896229, 2.218443435, 2.99792458]$。\n  - 测量噪声标准差 (米)：$r = 0.1$。\n  - 过程噪声强度：$q_b = 1.0 \\times 10^{-22}$, $q_d = 1.0 \\times 10^{-18}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含四个用例的结果，形式为一个数对列表，顺序与上述用例列表一致。每个数对是估计的最终偏差和漂移，即 $[b_T, d_T]$。因此，总输出必须是一个包含四个数对的单一列表，使用方括号括起来，例如文本结构 \"[[...,...],[...,...],[...,...],[...,...]]\"，不添加任何空格或打印额外文本。如上所述，输出中的所有数值分别代表秒和秒/秒。", "solution": "该问题要求基于一系列测量值，计算一个线性动态系统状态向量的后验均值。这是一个经典的状态估计问题，其最小均方误差意义下的最优解由卡尔曼滤波器 (Kalman filter) 提供。该系统是线性的，且所有噪声过程均被指定为高斯过程，这些是卡尔曼滤波器的理想应用条件。\n\n在时间 $t_k$，系统的状态由向量 $x_k = \\begin{bmatrix} b_k \\\\ d_k \\end{bmatrix}$ 给出，其中 $b_k$ 是时钟偏差（单位：秒），$d_k$ 是时钟漂移（单位：秒/秒）。\n\n状态演化由一个离散时间线性模型控制：\n$$x_{k+1} = F_k x_k + w_k$$\n其中 $F_k$ 是状态转移矩阵，$w_k$ 是过程噪声。根据问题描述，我们有：\n$$\n\\begin{aligned}\nb_{k+1} &= b_k + d_k \\,\\Delta t_k + w_{b,k} \\\\\nd_{k+1} &= d_k + w_{d,k}\n\\end{aligned}\n$$\n这使我们能够确定在时间间隔 $\\Delta t_k = t_{k+1} - t_k$ 上的状态转移矩阵为：\n$$F_k = \\begin{bmatrix} 1 & \\Delta t_k \\\\ 0 & 1 \\end{bmatrix}$$\n过程噪声向量为 $w_k = \\begin{bmatrix} w_{b,k} \\\\ w_{d,k} \\end{bmatrix}$。噪声 $w_{b,k}$ 和 $w_{d,k}$ 是独立的零均值高斯变量。因此，过程噪声协方差矩阵 $Q_k$ 是对角矩阵：\n$$Q_k = \\operatorname{Cov}(w_k) = \\begin{bmatrix} \\operatorname{Var}(w_{b,k}) & 0 \\\\ 0 & \\operatorname{Var}(w_{d,k}) \\end{bmatrix} = \\begin{bmatrix} q_b \\Delta t_k & 0 \\\\ 0 & q_d \\Delta t_k \\end{bmatrix}$$\n\n测量模型将状态 $x_k$ 与测量值 $z_k$ 联系起来：\n$$z_k = H x_k + v_k$$\n其中 $H$ 是测量矩阵，$v_k$ 是测量噪声。给定的关系是 $z_k = c\\, b_k + v_k$。这可以写成矩阵形式，其中测量矩阵是恒定的：\n$$H = \\begin{bmatrix} c & 0 \\end{bmatrix}$$\n光速 $c = 299792458 \\, \\text{m/s}$。测量噪声 $v_k$ 是零均值高斯噪声，其方差为 $\\operatorname{Var}(v_k) = r^2$。因此，测量噪声协方差 $R$ 是一个标量：\n$$R = r^2$$\n\n卡尔曼滤波器算法包含一个两步递归过程：预测和更新。令 $m_{k|k-1}$ 和 $P_{k|k-1}$ 分别表示在给定截至时间 $t_{k-1}$ 的测量值时，状态 $x_k$ 的先验均值和协方差。令 $m_{k|k}$ 和 $P_{k|k}$ 为在给定截至时间 $t_k$ 的测量值时的后验均值和协方差。\n\n该过程从时间 $t_0$ 的初始状态分布开始，该分布在考虑任何测量值之前作为先验给出。\n初始条件（在时间 $t_0$ 进行测量 $z_0$ 之前）：\n$$m_{0|-1} = m_0 = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$$\n$$P_{0|-1} = P_0 = \\begin{bmatrix} (10^{-6})^2 & 0 \\\\ 0 & (10^{-10})^2 \\end{bmatrix} = \\begin{bmatrix} 10^{-12} & 0 \\\\ 0 & 10^{-20} \\end{bmatrix}$$\n\n之后，滤波器对从 $k=0$ 到 $N$ 的每个测量值进行迭代，其中 $N$ 是最终时刻 $t_N$ 的最终测量的索引。\n\n对于每个时间步 $k$：\n首先，如果 $k>0$，则执行一个预测步骤，将估计值从时间 $t_{k-1}$ 传播到 $t_k$。\n1.  **预测步骤**（从 $t_{k-1}$ 到 $t_k$）：\n    -   时间 $t_k$ 的预测（先验）均值：$m_{k|k-1} = F_{k-1} m_{k-1|k-1}$\n    -   时间 $t_k$ 的预测（先验）协方差：$P_{k|k-1} = F_{k-1} P_{k-1|k-1} F_{k-1}^T + Q_{k-1}$\n    此处，$F_{k-1}$ 和 $Q_{k-1}$ 使用 $\\Delta t_{k-1} = t_k - t_{k-1}$ 定义。当 $k=0$ 时，跳过此步骤，我们使用 $m_{0|-1}$ 和 $P_{0|-1}$ 作为先验。\n\n其次，一个更新步骤融合时间 $t_k$ 的测量值 $z_k$，将先验估计精化为后验估计。\n2.  **更新步骤**（在时间 $t_k$）：\n    -   新息（测量残差）：$\\nu_k = z_k - H m_{k|k-1}$\n    -   新息协方差：$S_k = H P_{k|k-1} H^T + R$\n    -   卡尔曼增益：$K_k = P_{k|k-1} H^T S_k^{-1}$\n    -   更新后（后验）均值：$m_{k|k} = m_{k|k-1} + K_k \\nu_k$\n    -   更新后（后验）协方差：$P_{k|k} = (I - K_k H) P_{k|k-1}$，其中 $I$ 是单位矩阵。\n\n算法从 $k=0$ 的给定先验开始，执行一次更新，然后预测到 $k=1$，在 $k=1$ 进行更新，依此类推，直到处理完时间 $t_N$ 的最终测量值。每个测试用例的最终输出是最终时刻的后验状态均值 $m_{N|N}$，其中包含估计的偏差 $b_N$ 和漂移 $d_N$。这代表了基于截至并包含最后一个测量值在内的所有测量值的最小均方误差估计。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the GPS clock state estimation problem for multiple test cases using a Kalman filter.\n    \"\"\"\n    \n    # Define physical and initial state constants\n    C = 299792458.0  # Speed of light in m/s\n    M0 = np.array([[0.0], [0.0]])  # Initial state mean [b_0, d_0]^T\n    P0 = np.array([[1e-12, 0.0], [0.0, 1e-20]])  # Initial state covariance\n\n    test_cases = [\n        {\n            \"times\": [0, 1, 2, 3, 4, 5],\n            \"measurements\": [34.775095, 36.924783647, 37.874472334, 36.624161021, 38.073849708, 37.823538395],\n            \"r\": 2.0, \"qb\": 1.0e-20, \"qd\": 1.0e-22\n        },\n        {\n            \"times\": [0, 1, 2, 3, 4, 5],\n            \"measurements\": [24.18339664, 23.88339664, 24.38339664, 23.68339664, 23.98339664, 24.08339664],\n            \"r\": 1.0, \"qb\": 1.0e-22, \"qd\": 1.0e-24\n        },\n        {\n            \"times\": [0, 2, 3.5, 7.0, 7.5, 10.0],\n            \"measurements\": [11.9896229, 17.4296644084, 13.3846955397, 15.7797681794, 14.7647785565, 12.689830442],\n            \"r\": 5.0, \"qb\": 5.0e-20, \"qd\": 1.0e-20\n        },\n        {\n            \"times\": [0, 0.5, 1.0, 1.5, 2.0],\n            \"measurements\": [0.05, 0.729481145, 1.50896229, 2.218443435, 2.99792458],\n            \"r\": 0.1, \"qb\": 1.0e-22, \"qd\": 1.0e-18\n        }\n    ]\n\n    def run_kalman_filter(times, measurements, r, qb, qd):\n        \"\"\"\n        Implements the Kalman filter for the given time-varying linear system.\n\n        Args:\n            times (list): List of time stamps t_k.\n            measurements (list): List of measurements z_k.\n            r (float): Measurement noise standard deviation.\n            qb (float): Process noise intensity for bias.\n            qd (float): Process noise intensity for drift.\n\n        Returns:\n            list: The final estimated state [b_T, d_T].\n        \"\"\"\n        # Initialize state mean and covariance\n        m = M0.copy()\n        P = P0.copy()\n\n        # Define constant matrices\n        H = np.array([[C, 0.0]])  # Measurement matrix (1x2)\n        R_val = r**2  # Measurement noise variance (scalar)\n        I = np.identity(2)  # Identity matrix\n\n        # Iterate through each measurement\n        for k in range(len(times)):\n            # --- Prediction step (from t_{k-1} to t_k) ---\n            if k > 0:\n                dt = times[k] - times[k-1]\n                \n                # State transition matrix F\n                F = np.array([[1.0, dt], [0.0, 1.0]])\n                \n                # Process noise covariance matrix Q\n                Q = np.array([[qb * dt, 0.0], [0.0, qd * dt]])\n                \n                # Predict state and covariance\n                m = F @ m\n                P = F @ P @ F.T + Q\n            \n            # --- Update step (at t_k) ---\n            z_k = measurements[k]\n            \n            # Innovation (measurement residual)\n            nu = z_k - (H @ m)[0, 0]  # nu is a scalar\n            \n            # Innovation covariance\n            S = (H @ P @ H.T)[0, 0] + R_val  # S is a scalar\n            \n            # Kalman gain (K = P H' / S)\n            K = (P @ H.T) / S  # K is a 2x1 vector\n            \n            # Update state mean\n            m = m + K * nu\n            \n            # Update state covariance using Joseph form for numerical stability\n            P = (I - K @ H) @ P @ (I - K @ H).T + (K * R_val) @ K.T\n\n        return m.flatten().tolist()\n\n    results = []\n    for case in test_cases:\n        final_state = run_kalman_filter(\n            case[\"times\"], case[\"measurements\"], case[\"r\"], case[\"qb\"], case[\"qd\"]\n        )\n        results.append(final_state)\n    \n    # Format the output string as per requirements: [[b,d],[b,d],...]\n    output_str = f\"[{','.join([f'[{b},{d}]' for b, d in results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2382578"}, {"introduction": "真实世界的工程系统常常需要融合来自多个传感器的数据，而这些数据的到达速率和时间点往往并不同步。这个练习将基础的卡尔曼滤波器扩展到能够处理这类异步数据流的场景。你将通过融合高频惯性测量单元（IMU）和低频全球定位系统（GPS）的数据来估计一个移动物体的位置和速度，从而掌握处理不规则和异步传感器输入的关键技能。[@problem_id:2382633]", "problem": "实现一个程序，该程序为受异步传感器数据影响的一维质点计算后验状态均值。其中，惯性测量单元 (IMU) 和全球定位系统 (GPS) 传感器在不同且不规则的时间步长提供数据。状态由位置和速度组成。由于时间步长可变，该模型是线性和时变的。设状态为 $x(t) = \\begin{bmatrix} p(t) \\\\ v(t) \\end{bmatrix}$，其中 $p(t)$ 的单位是米，$v(t)$ 的单位是米/秒。在任意两个时间 $t_{k}$ 和 $t_{k+1}$ 之间，时间步长为 $\\Delta t = t_{k+1} - t_{k}$，运动学演化使用在该区间内保持恒定的测量 IMU 加速度 $u_{k}$（单位：米/秒平方）。离散时间演化为\n$$\nx_{k+1} = F(\\Delta t)\\,x_{k} + G(\\Delta t)\\,u_{k} + w_{k},\n$$\n其中\n$$\nF(\\Delta t) = \\begin{bmatrix} 1 & \\Delta t \\\\ 0 & 1 \\end{bmatrix}, \\quad G(\\Delta t) = \\begin{bmatrix} \\tfrac{1}{2}\\Delta t^{2} \\\\ \\Delta t \\end{bmatrix},\n$$\n过程噪声 $w_{k}$ 是零均值高斯噪声，其协方差为\n$$\nQ(\\Delta t) = \\sigma_{a}^{2}\\,G(\\Delta t)\\,G(\\Delta t)^{\\mathsf T}.\n$$\nGPS 在不规则的时间 $t_{m}$ 提供位置测量，遵循\n$$\nz_{m} = H\\,x(t_{m}) + v_{m}, \\quad H = \\begin{bmatrix} 1 & 0 \\end{bmatrix},\n$$\n其测量噪声 $v_{m}$ 为零均值高斯噪声，方差为 $R = \\sigma_{g}^{2}$。IMU 测量值 $u_{k}$ 用作输入，其不确定性由上述过程噪声建模；IMU 没有单独的测量方程。\n\n在初始时间 $t_{0}$，先验状态均值和协方差给定为 $x(t_{0}) \\sim \\mathcal{N}(m_{0}, P_{0})$。\n\n您的程序必须：\n- 在所有 IMU 和 GPS 时间戳的并集上，演化状态及其协方差。对于每个区间 $[t_{k}, t_{k+1})$，使用最近的可用 IMU 加速度值作为输入 $u_{k}$。\n- 当到达 GPS 测量时间时，将其与当前预测状态相结合，以生成该时间的后验状态均值和协方差，并与上述概率模型保持一致。\n- 持续此过程直到最终事件时间（IMU 和 GPS 时间戳并集中的最晚时间），并报告最终的后验位置均值 $p$。\n\n测试套件。对于以下每个案例，请逐字使用所提供的值。所有时间的单位为秒，位置单位为米，速度单位为米/秒，加速度单位为米/秒平方。初始协方差是对角线上的方差。标准差 $\\sigma_{a}$ 和 $\\sigma_{g}$ 的单位分别与加速度和位置的单位相同。\n\n案例 A（中等噪声下的一般不规则采样）：\n- IMU 时间 $t_{\\text{imu}} = [\\,0.00, 0.07, 0.15, 0.26, 0.38, 0.53, 0.71, 0.93, 1.18\\,]$，\n- IMU 加速度 $u = [\\,0.52, 0.48, 0.51, 0.50, 0.49, 0.50, 0.51, 0.50, 0.49\\,]$，\n- GPS 时间 $t_{\\text{gps}} = [\\,0.50, 1.00, 1.20\\,]$，\n- GPS 位置 $z = [\\,0.064, 0.250, 0.360\\,]$，\n- 初始均值 $m_{0} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$，\n- 初始协方差 $P_{0} = \\operatorname{diag}([\\,0.25, 0.25\\,])$，\n- 加速度标准差 $\\sigma_{a} = 0.05$，\n- GPS 位置标准差 $\\sigma_{g} = 0.02$。\n\n案例 B（单次 GPS 更新前存在长间隙且加速度噪声较大）：\n- IMU 时间 $t_{\\text{imu}} = [\\,0.00, 0.04, 0.09, 0.17, 0.28, 0.44, 0.65, 0.91, 1.30, 1.80, 2.30\\,]$，\n- IMU 加速度 $u = [\\,-0.31, -0.29, -0.30, -0.32, -0.28, -0.30, -0.29, -0.31, -0.30, -0.29, -0.31\\,]$，\n- GPS 时间 $t_{\\text{gps}} = [\\,2.30\\,]$，\n- GPS 位置 $z = [\\,-0.800\\,]$，\n- 初始均值 $m_{0} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$，\n- 初始协方差 $P_{0} = \\operatorname{diag}([\\,1.0, 1.0\\,])$，\n- 加速度标准差 $\\sigma_{a} = 0.10$，\n- GPS 位置标准差 $\\sigma_{g} = 0.05$。\n\n案例 C（稀疏 IMU、大间隙和精确 GPS 的边缘案例）：\n- IMU 时间 $t_{\\text{imu}} = [\\,0.00, 0.20, 0.21, 0.70, 1.50\\,]$，\n- IMU 加速度 $u = [\\,0.00, 0.00, 1.00, 1.00, 0.00\\,]$，\n- GPS 时间 $t_{\\text{gps}} = [\\,0.50, 1.50\\,]$，\n- GPS 位置 $z = [\\,0.042, 0.832\\,]$，\n- 初始均值 $m_{0} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$，\n- 初始协方差 $P_{0} = \\operatorname{diag}([\\,0.04, 0.04\\,])$，\n- 加速度标准差 $\\sigma_{a} = 0.05$，\n- GPS 位置标准差 $\\sigma_{g} = 0.01$。\n\n对于每个案例，计算以米为单位的最后一个事件时间的最终后验位置均值。将每个结果以米为单位表示为一个四舍五入到六位小数的浮点数。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如，$[\\,\\text{result1},\\text{result2},\\text{result3}\\,]$），其中的条目分别是案例 A、案例 B 和案例 C 的最终后验位置均值，单位为米，四舍五入到六位小数。", "solution": "所提出的问题是有效的。这是一个定义明确的线性卡尔曼滤波器应用，用于处理异步数据的传感器融合，这是计算工程和控制理论中的一个标准任务。物理模型基于基础运动学，并提供了所有必需的参数和数据。没有违反任何科学原理。\n\n该问题要求估计一维质点的状态，其中状态由位置 $p(t)$ 和速度 $v(t)$ 定义，表示为向量 $x(t) = \\begin{bmatrix} p(t) \\\\ v(t) \\end{bmatrix}$。由于事件之间的时间间隔不规则，该系统由一个线性时变状态空间模型描述。从带噪声的测量中估计状态的过程是一个经典的滤波问题，对于线性高斯情况，卡尔曼滤波器为此提供了最优解。\n\n解决方案的核心在于按统一的时间顺序处理所有传感器事件——包括来自惯性测量单元 (IMU) 和全球定位系统 (GPS) 的事件。这通过从两个传感器创建唯一事件时间戳的统一时间轴来实现。然后，滤波器从一个事件时间进行到下一个事件时间，迭代地应用预测和更新步骤。\n\n设时间 $t_{k}$ 的状态估计由一个均值为 $m_{k}$、协方差为 $P_{k}$ 的高斯分布所表征。滤波器将此估计传播到下一个事件时间 $t_{k+1}$。\n\n首先，**预测步骤**将状态从时间 $t_{k}$ 演化到 $t_{k+1}$。时间间隔为 $\\Delta t = t_{k+1} - t_{k}$。在时间 $t_{k+1}$ 的预测均值 $m_{k+1|k}$ 和协方差 $P_{k+1|k}$ 由以下公式给出：\n$$\nm_{k+1|k} = F(\\Delta t) m_{k} + G(\\Delta t) u_{k}\n$$\n$$\nP_{k+1|k} = F(\\Delta t) P_{k} F(\\Delta t)^{\\mathsf T} + Q(\\Delta t)\n$$\n其中 $m_k$ 和 $P_k$ 是上一步在时间 $t_k$ 的后验均值和协方差。控制输入 $u_{k}$ 是在时间 $t_{k}$ 或之前可用的最新 IMU 加速度测量值。状态转移矩阵 $F(\\Delta t)$、控制输入矩阵 $G(\\Delta t)$ 和过程噪声协方差 $Q(\\Delta t)$ 定义如下：\n$$\nF(\\Delta t) = \\begin{bmatrix} 1 & \\Delta t \\\\ 0 & 1 \\end{bmatrix}, \\quad G(\\Delta t) = \\begin{bmatrix} \\frac{1}{2}\\Delta t^2 \\\\ \\Delta t \\end{bmatrix}, \\quad Q(\\Delta t) = \\sigma_{a}^{2} G(\\Delta t) G(\\Delta t)^{\\mathsf T}\n$$\n矩阵 $Q(\\Delta t)$ 表示在区间 $\\Delta t$ 内由加速度输入引入的不确定性。\n\n其次，如果在时间 $t_{k+1}$ 有可用的 GPS 测量值 $z_{k+1}$，则执行**测量更新步骤**以使用此新信息校正预测状态。更新方程为：\n$$\ny_{k+1} = z_{k+1} - H m_{k+1|k} \\quad (\\text{新息})\n$$\n$$\nS_{k+1} = H P_{k+1|k} H^{\\mathsf T} + R \\quad (\\text{新息协方差})\n$$\n$$\nK_{k+1} = P_{k+1|k} H^{\\mathsf T} S_{k+1}^{-1} \\quad (\\text{卡尔曼增益})\n$$\n然后计算后验（更新后）均值 $m_{k+1}$ 和协方差 $P_{k+1}$ 如下：\n$$\nm_{k+1} = m_{k+1|k} + K_{k+1} y_{k+1}\n$$\n$$\nP_{k+1} = (I - K_{k+1} H) P_{k+1|k}\n$$\n这里，$H = \\begin{bmatrix} 1 & 0 \\end{bmatrix}$ 是将状态映射到测量量（位置）的观测矩阵，$R = \\sigma_{g}^{2}$ 是测量噪声方差。单位矩阵用 $I$ 表示。如果在 $t_{k+1}$ 没有可用的 GPS 测量值，则跳过更新步骤，后验状态即为预测状态，即 $m_{k+1} = m_{k+1|k}$ 和 $P_{k+1} = P_{k+1|k}$。\n\n算法流程如下：\n1.  在初始时间 $t_{0}$，用先验值 $m_{0}$ 和 $P_{0}$ 初始化状态均值 $m$ 和协方差 $P$。\n2.  将来自 IMU ($t_{\\text{imu}}$) 和 GPS ($t_{\\text{gps}}$) 的所有唯一时间戳聚合成一个单一的、排序的事件时间列表。\n3.  将初始控制输入 $u$ 设置为在 $t_{0}$ 测得的值。\n4.  从 $t_0$ 到最终时间，遍历排序后的事件时间。对于每个区间 $[t_k, t_{k+1})$：\n    a. 计算 $\\Delta t = t_{k+1} - t_k$。如果 $\\Delta t > 0$，执行预测步骤以将状态从 $t_k$ 传播到 $t_{k+1}$。\n    b. 在时间 $t_{k+1}$，检查是否有 GPS 测量值。如果存在，执行测量更新步骤。\n    c. 在时间 $t_{k+1}$，检查是否有新的 IMU 测量值。如果存在，将控制输入 $u$ 更新为此新值，用于后续区间。\n5.  处理完所有事件直到最终时间戳后，最终状态均值向量的第一个分量 $m[0]$ 即为所求的后验位置。\n\n此过程正确地融合了来自两个异步传感器的信息，以生成系统状态随时间的最优估计。实现时需要仔细处理事件时间轴以及事件之间的状态传播。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the sensor fusion problem for three test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"t_imu\": np.array([0.00, 0.07, 0.15, 0.26, 0.38, 0.53, 0.71, 0.93, 1.18]),\n            \"u\": np.array([0.52, 0.48, 0.51, 0.50, 0.49, 0.50, 0.51, 0.50, 0.49]),\n            \"t_gps\": np.array([0.50, 1.00, 1.20]),\n            \"z\": np.array([0.064, 0.250, 0.360]),\n            \"m0\": np.array([0.0, 0.0]),\n            \"P0\": np.diag([0.25, 0.25]),\n            \"sigma_a\": 0.05,\n            \"sigma_g\": 0.02,\n        },\n        {\n            \"name\": \"Case B\",\n            \"t_imu\": np.array([0.00, 0.04, 0.09, 0.17, 0.28, 0.44, 0.65, 0.91, 1.30, 1.80, 2.30]),\n            \"u\": np.array([-0.31, -0.29, -0.30, -0.32, -0.28, -0.30, -0.29, -0.31, -0.30, -0.29, -0.31]),\n            \"t_gps\": np.array([2.30]),\n            \"z\": np.array([-0.800]),\n            \"m0\": np.array([0.0, 0.0]),\n            \"P0\": np.diag([1.0, 1.0]),\n            \"sigma_a\": 0.10,\n            \"sigma_g\": 0.05,\n        },\n        {\n            \"name\": \"Case C\",\n            \"t_imu\": np.array([0.00, 0.20, 0.21, 0.70, 1.50]),\n            \"u\": np.array([0.00, 0.00, 1.00, 1.00, 0.00]),\n            \"t_gps\": np.array([0.50, 1.50]),\n            \"z\": np.array([0.042, 0.832]),\n            \"m0\": np.array([0.0, 0.0]),\n            \"P0\": np.diag([0.04, 0.04]),\n            \"sigma_a\": 0.05,\n            \"sigma_g\": 0.01,\n        },\n    ]\n\n    results = [run_kalman_filter(case) for case in test_cases]\n    \n    # Format the final output string exactly as specified.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_kalman_filter(case_data):\n    \"\"\"\n    Runs the Kalman filter for a single test case.\n    \"\"\"\n    # Unpack data for the current case\n    t_imu = case_data[\"t_imu\"]\n    u_imu = case_data[\"u\"]\n    t_gps = case_data[\"t_gps\"]\n    z_gps = case_data[\"z\"]\n    m = case_data[\"m0\"].reshape(2, 1)\n    P = case_data[\"P0\"]\n    sigma_a = case_data[\"sigma_a\"]\n    sigma_g = case_data[\"sigma_g\"]\n\n    # Create lookup dictionaries for sensor data\n    imu_data = dict(zip(t_imu, u_imu))\n    gps_data = dict(zip(t_gps, z_gps))\n\n    # Combine and sort all unique event timestamps\n    event_times = sorted(list(set(t_imu) | set(t_gps)))\n\n    current_time = event_times[0]\n    # Initialize control input with the value at the first timestamp\n    u_current = imu_data[current_time]\n\n    H = np.array([[1.0, 0.0]])\n    R = np.array([[sigma_g**2]])\n    I = np.eye(2)\n\n    # Main loop: iterate through consecutive event times\n    for i in range(len(event_times) - 1):\n        next_time = event_times[i+1]\n        delta_t = next_time - current_time\n\n        if delta_t > 1e-9: # Propagate only if time has passed\n            # Prediction step\n            F = np.array([[1.0, delta_t], [0.0, 1.0]])\n            G = np.array([[0.5 * delta_t**2], [delta_t]])\n            Q = (sigma_a**2) * (G @ G.T)\n\n            # Predict state mean and covariance\n            m_pred = F @ m + G * u_current\n            P_pred = F @ P @ F.T + Q\n            \n            m, P = m_pred, P_pred\n\n        # Update step if GPS data is available at the new time\n        if next_time in gps_data:\n            z_meas = gps_data[next_time]\n            \n            # Innovation\n            y = z_meas - H @ m\n            \n            # Innovation covariance\n            S = H @ P @ H.T + R\n            \n            # Kalman gain\n            K = P @ H.T / S[0,0] # S is 1x1\n            \n            # Update state mean and covariance\n            m = m + K * y\n            P = (I - K @ H) @ P\n\n        # Update control input if new IMU data is available\n        if next_time in imu_data:\n            u_current = imu_data[next_time]\n            \n        current_time = next_time\n\n    # The final posterior position is the first element of the mean vector\n    return m[0, 0]\n\nsolve()\n```", "id": "2382633"}, {"introduction": "一个稳健的数据同化系统必须能够识别并拒绝异常的测量值，即“离群点”。本练习介绍了一种用于此目的的标准统计方法——卡方检验（$\\chi^2$ test）。我们将对“新息”（innovation）——即观测值与模型预测值之差——进行检验，因为它的大小反映了新数据与现有估计的一致性。通过实现这个质量控制步骤，你将学会如何保护你的滤波器免受传感器故障或意外异常的干扰，从而保证估计结果的可靠性。[@problem_id:2382619]", "problem": "在数据同化的单个分析步骤中，给定一个线性高斯观测设置。设预报状态的均值为 $\\mathbf{x}_f \\in \\mathbb{R}^n$，协方差为 $\\mathbf{P}_f \\in \\mathbb{R}^{n \\times n}$。测量值 $\\mathbf{y} \\in \\mathbb{R}^m$ 通过线性观测算子 $\\mathbf{H} \\in \\mathbb{R}^{m \\times n}$ 与状态相关，并带有协方差为 $\\mathbf{R} \\in \\mathbb{R}^{m \\times m}$ 的附加零均值高斯测量误差。定义新息向量 $\\mathbf{v} = \\mathbf{y} - \\mathbf{H}\\mathbf{x}_f$ 和新息协方差 $\\mathbf{S} = \\mathbf{H}\\mathbf{P}_f\\mathbf{H}^\\top + \\mathbf{R}$。在模型、协方差和观测值与线性 Kalman 滤波器或集合 Kalman 滤波器在统计上一致的原假设下，二次型 $z = \\mathbf{v}^\\top \\mathbf{S}^{-1} \\mathbf{v}$ 服从自由度为 $m$ 的卡方（$\\chi^2$）分布。对于给定的显著性水平 $\\alpha \\in (0,1)$，将临界值 $c$ 定义为自由度为 $m$ 的 $\\chi^2$ 分布的上 $(1-\\alpha)$ 分位数。当且仅当 $z > c$ 时，应将该测量值作为异常值剔除。\n\n请实现一个程序，对下面套件中的每个测试用例，根据上述规则计算接受或剔除该测量值的决策。每个测试用例的输出必须是一个布尔值：如果测量值被剔除，则为 $\\,\\mathrm{True}\\,$，否则为 $\\,\\mathrm{False}\\,$。不涉及物理单位。不出现角度。所有概率和显著性水平都必须视为 $[0,1]$ 区间内的实数。该测试套件指定了不同的场景，包括一个典型情况、一个明显异常值、一个相关的多变量情况，以及一个 $z$ 恰好等于临界值且不得剔除的边界情况。\n\n使用以下测试套件，其中所有矩阵都按要求对称，并在需要时为正定：\n\n- 测试用例 1（单变量，正常接受）：\n  - $\\mathbf{H} = [\\,1.0\\,]$\n  - $\\mathbf{x}_f = [\\,0.0\\,]$\n  - $\\mathbf{P}_f = \\begin{bmatrix} 1.0 \\end{bmatrix}$\n  - $\\mathbf{R} = \\begin{bmatrix} 0.25 \\end{bmatrix}$\n  - $\\mathbf{y} = [\\,0.2\\,]$\n  - $\\alpha = 0.05$\n- 测试用例 2（单变量，明显异常值）：\n  - $\\mathbf{H} = [\\,1.0\\,]$\n  - $\\mathbf{x}_f = [\\,0.0\\,]$\n  - $\\mathbf{P}_f = \\begin{bmatrix} 0.5 \\end{bmatrix}$\n  - $\\mathbf{R} = \\begin{bmatrix} 0.1 \\end{bmatrix}$\n  - $\\mathbf{y} = [\\,3.0\\,]$\n  - $\\alpha = 0.01$\n- 测试用例 3（双变量，相关，接受）：\n  - $\\mathbf{H} = \\begin{bmatrix} 1.0 & 0.0 \\\\ 0.0 & 1.0 \\end{bmatrix}$\n  - $\\mathbf{x}_f = \\begin{bmatrix} 1.0 \\\\ -1.0 \\end{bmatrix}$\n  - $\\mathbf{P}_f = \\begin{bmatrix} 1.0 & 0.5 \\\\ 0.5 & 2.0 \\end{bmatrix}$\n  - $\\mathbf{R} = \\begin{bmatrix} 0.2 & 0.1 \\\\ 0.1 & 0.3 \\end{bmatrix}$\n  - $\\mathbf{y} = \\begin{bmatrix} 1.3 \\\\ -0.8 \\end{bmatrix}$\n  - $\\alpha = 0.05$\n- 测试用例 4（单变量，边界情况；因 $z = c$ 而不剔除）：\n  - $\\mathbf{H} = [\\,1.0\\,]$\n  - $\\mathbf{x}_f = [\\,0.0\\,]$\n  - $\\mathbf{P}_f = \\begin{bmatrix} 0.0 \\end{bmatrix}$\n  - $\\mathbf{R} = \\begin{bmatrix} 1.0 \\end{bmatrix}$\n  - $\\mathbf{y} = [\\,1.959963984540054\\,]$\n  - $\\alpha = 0.05$\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，`[result1,result2,result3,result4]`），其顺序与上述测试用例相同。每个 `result` 必须是 `True` 或 `False`。", "solution": "检查问题陈述的有效性。\n\n步骤 1：提取已知条件\n问题为数据同化情境提供了以下定义和数据：\n- 预报状态均值：$\\mathbf{x}_f \\in \\mathbb{R}^n$\n- 预报状态协方差：$\\mathbf{P}_f \\in \\mathbb{R}^{n \\times n}$\n- 测量向量：$\\mathbf{y} \\in \\mathbb{R}^m$\n- 线性观测算子：$\\mathbf{H} \\in \\mathbb{R}^{m \\times n}$\n- 测量误差协方差：$\\mathbf{R} \\in \\mathbb{R}^{m \\times m}$（零均值高斯误差）\n- 新息向量：$\\mathbf{v} = \\mathbf{y} - \\mathbf{H}\\mathbf{x}_f$\n- 新息协方差：$\\mathbf{S} = \\mathbf{H}\\mathbf{P}_f\\mathbf{H}^\\top + \\mathbf{R}$\n- 检验统计量：$z = \\mathbf{v}^\\top \\mathbf{S}^{-1} \\mathbf{v}$\n- $z$ 的分布：自由度为 $m$ 的卡方（$\\chi^2$）分布。\n- 显著性水平：$\\alpha \\in (0,1)$\n- 临界值 $c$：自由度为 $m$ 的 $\\chi^2$ 分布的上 $(1-\\alpha)$ 分位数。\n- 剔除规则：当且仅当 $z > c$ 时，剔除测量值。\n\n问题为 $\\mathbf{H}$、$\\mathbf{x}_f$、$\\mathbf{P}_f$、$\\mathbf{R}$、$\\mathbf{y}$ 和 $\\alpha$ 提供了四个具有特定数值的不同测试用例。\n\n步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题描述了新息一致性检验，也称为卡方检验，这是数据同化中的一个标准基础流程，特别是在 Kalman 滤波器及其集合变体的背景下。其统计基础——在给定的高斯假设下，二次型 $z = \\mathbf{v}^\\top \\mathbf{S}^{-1} \\mathbf{v}$ 服从 $\\chi^2$ 分布——是多元统计中一个公认的结论。该问题在科学上和数学上都是合理的。\n- **适定性**：每个测试用例都提供了所有必要的输入（$\\mathbf{x}_f, \\mathbf{P}_f, \\mathbf{y}, \\mathbf{H}, \\mathbf{R}, \\alpha$）。目标是根据一个清晰、明确的规则（$z > c$）计算一个布尔决策。对边界情况（$z = c$）的处理已明确说明，确保了对于所有可能的 $z$ 值都有唯一解。所提供的协方差矩阵是对称的，并按需描述为正定，这保证了新息协方差 $\\mathbf{S}$ 是可逆的。因此，该问题是适定的。\n- **客观性**：问题使用了精确的数学术语进行陈述。评估标准是一个严格的不等式，没有任何主观解释的余地。\n- **完整性与一致性**：问题是自洽的。每个测试用例中所有矩阵和向量的维度对于所需的矩阵运算都是一致的。例如，在测试用例 3 中，$\\mathbf{H}$ 是 $2 \\times 2$，$\\mathbf{x}_f$ 是 $2 \\times 1$，因此 $\\mathbf{H}\\mathbf{x}_f$ 是 $2 \\times 1$，这与 $\\mathbf{y}$ 的维度（$2 \\times 1$）兼容。用于计算 $\\mathbf{S}$ 的维度也是一致的。\n- **其他标准**：该问题是可形式化的，与计算工程相关，其设置是现实的（尽管经过简化），并且是科学上可验证的。它没有违反任何指定的无效条件。\n\n步骤 3：结论与行动\n问题有效。将构建一个解决方案。\n\n解决方案要求为每个提供的测试用例实现卡方检验。每个用例的步骤如下：\n\n1.  确定观测空间的维度 $m$，即观测算子 $\\mathbf{H}$ 的行数（或测量向量 $\\mathbf{y}$ 的维度）。该值代表 $\\chi^2$ 分布的自由度。\n2.  计算新息向量 $\\mathbf{v} = \\mathbf{y} - \\mathbf{H}\\mathbf{x}_f$。该向量表示实际测量值 $\\mathbf{y}$ 与投影到观测空间中的预报状态 $\\mathbf{H}\\mathbf{x}_f$ 之间的差异。\n3.  计算新息协方差矩阵 $\\mathbf{S} = \\mathbf{H}\\mathbf{P}_f\\mathbf{H}^\\top + \\mathbf{R}$。该矩阵量化了新息中的总预期不确定性，它结合了来自预报状态的不确定性（通过 $\\mathbf{H}$ 传播）和来自测量本身的不确定性。\n4.  计算检验统计量 $z = \\mathbf{v}^\\top \\mathbf{S}^{-1} \\mathbf{v}$。这是一个标量值，表示新息向量相对于原点的、并由其协方差归一化的马氏距离（Mahalanobis distance）的平方。它衡量了在给定预期不确定性的情况下，新息的“惊奇”程度。该计算需要计算 $\\mathbf{S}$ 的逆矩阵。\n5.  确定给定显著性水平 $\\alpha$ 的临界值 $c$。值 $c$ 是自由度为 $m$ 的 $\\chi^2$ 分布的上分位数，由 $P(\\chi^2_m \\le c) = 1 - \\alpha$ 定义。该值可以使用 $\\chi^2$ 分布的百分点函数（PPF），也称为逆累积分布函数，来获得。\n6.  将检验统计量 $z$ 与临界值 $c$ 进行比较。根据指定规则，如果 $z > c$，则剔除测量值。这将产生一个布尔结果。边界情况 $z = c$ 时不剔除。\n\n该算法将应用于四个测试用例中的每一个。\n\n- 对于**测试用例 1**（单变量，正常接受）：\n  - $m=1$。$\\mathbf{v} = [0.2] - [1.0][0.0] = [0.2]$。\n  - $\\mathbf{S} = [1.0][1.0][1.0]^\\top + [0.25] = [1.25]$。\n  - $z = [0.2]^\\top [1.25]^{-1} [0.2] = 0.2 \\times (1/1.25) \\times 0.2 = 0.032$。\n  - 对于 $\\alpha=0.05$ 和 $m=1$ 的自由度，临界值为 $c = \\chi^2_1\\text{.ppf}(0.95) \\approx 3.841$。\n  - 决策：$0.032 > 3.841$ 为假。接受该测量值。\n\n- 对于**测试用例 2**（单变量，明显异常值）：\n  - $m=1$。$\\mathbf{v} = [3.0] - [1.0][0.0] = [3.0]$。\n  - $\\mathbf{S} = [1.0][0.5][1.0]^\\top + [0.1] = [0.6]$。\n  - $z = [3.0]^\\top [0.6]^{-1} [3.0] = 3.0 \\times (1/0.6) \\times 3.0 = 15.0$。\n  - 对于 $\\alpha=0.01$ 和 $m=1$ 的自由度，临界值为 $c = \\chi^2_1\\text{.ppf}(0.99) \\approx 6.635$。\n  - 决策：$15.0 > 6.635$ 为真。剔除该测量值。\n\n- 对于**测试用例 3**（双变量，相关，接受）：\n  - $m=2$。$\\mathbf{x}_f = \\begin{bmatrix} 1.0 \\\\ -1.0 \\end{bmatrix}$。$\\mathbf{y} = \\begin{bmatrix} 1.3 \\\\ -0.8 \\end{bmatrix}$。$\\mathbf{H} = \\begin{bmatrix} 1.0 & 0.0 \\\\ 0.0 & 1.0 \\end{bmatrix}$。\n  - $\\mathbf{H}\\mathbf{x}_f = \\mathbf{x}_f = \\begin{bmatrix} 1.0 \\\\ -1.0 \\end{bmatrix}$。\n  - $\\mathbf{v} = \\begin{bmatrix} 1.3 \\\\ -0.8 \\end{bmatrix} - \\begin{bmatrix} 1.0 \\\\ -1.0 \\end{bmatrix} = \\begin{bmatrix} 0.3 \\\\ 0.2 \\end{bmatrix}$。\n  - 由于 $\\mathbf{H}$ 是单位矩阵，$\\mathbf{S} = \\mathbf{P}_f + \\mathbf{R} = \\begin{bmatrix} 1.0 & 0.5 \\\\ 0.5 & 2.0 \\end{bmatrix} + \\begin{bmatrix} 0.2 & 0.1 \\\\ 0.1 & 0.3 \\end{bmatrix} = \\begin{bmatrix} 1.2 & 0.6 \\\\ 0.6 & 2.3 \\end{bmatrix}$。\n  - 其逆矩阵为 $\\mathbf{S}^{-1} = \\frac{1}{(1.2)(2.3) - (0.6)(0.6)} \\begin{bmatrix} 2.3 & -0.6 \\\\ -0.6 & 1.2 \\end{bmatrix} = \\frac{1}{2.4} \\begin{bmatrix} 2.3 & -0.6 \\\\ -0.6 & 1.2 \\end{bmatrix}$。\n  - $z = \\begin{bmatrix} 0.3 & 0.2 \\end{bmatrix} \\frac{1}{2.4} \\begin{bmatrix} 2.3 & -0.6 \\\\ -0.6 & 1.2 \\end{bmatrix} \\begin{bmatrix} 0.3 \\\\ 0.2 \\end{bmatrix} = \\frac{1}{2.4} \\begin{bmatrix} 0.3 & 0.2 \\end{bmatrix} \\begin{bmatrix} 0.57 \\\\ 0.06 \\end{bmatrix} = \\frac{1}{2.4} (0.171 + 0.012) = \\frac{0.183}{2.4} = 0.07625$。\n  - 对于 $\\alpha=0.05$ 和 $m=2$ 的自由度，临界值为 $c = \\chi^2_2\\text{.ppf}(0.95) \\approx 5.991$。\n  - 决策：$0.07625 > 5.991$ 为假。接受该测量值。\n\n- 对于**测试用例 4**（单变量，边界情况）：\n  - $m=1$。$\\mathbf{v} = [1.959963984540054] - [1.0][0.0] = [1.959963984540054]$。\n  - $\\mathbf{S} = [1.0][0.0][1.0]^\\top + [1.0] = [1.0]$。\n  - $z = [1.959963984540054]^\\top [1.0]^{-1} [1.959963984540054] = (1.959963984540054)^2 \\approx 3.841458820694124$。\n  - 对于 $\\alpha=0.05$ 和 $m=1$ 的自由度，临界值为 $c = \\chi^2_1\\text{.ppf}(0.95) \\approx 3.841458820694124$。\n  - $\\mathbf{y}$ 的值是构造出来的，使得 $z$ 恰好等于 $c$。\n  - 决策：$z > c$ 为假。接受该测量值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Solves the outlier detection problem for a suite of test cases\n    based on the Chi-squared innovation consistency test.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (univariate, typical acceptance)\n        {\n            \"H\": np.array([[1.0]]),\n            \"x_f\": np.array([0.0]),\n            \"P_f\": np.array([[1.0]]),\n            \"R\": np.array([[0.25]]),\n            \"y\": np.array([0.2]),\n            \"alpha\": 0.05\n        },\n        # Test case 2 (univariate, clear outlier)\n        {\n            \"H\": np.array([[1.0]]),\n            \"x_f\": np.array([0.0]),\n            \"P_f\": np.array([[0.5]]),\n            \"R\": np.array([[0.1]]),\n            \"y\": np.array([3.0]),\n            \"alpha\": 0.01\n        },\n        # Test case 3 (bivariate, correlated, acceptance)\n        {\n            \"H\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"x_f\": np.array([1.0, -1.0]),\n            \"P_f\": np.array([[1.0, 0.5], [0.5, 2.0]]),\n            \"R\": np.array([[0.2, 0.1], [0.1, 0.3]]),\n            \"y\": np.array([1.3, -0.8]),\n            \"alpha\": 0.05\n        },\n        # Test case 4 (univariate, boundary case; do not reject because z = c)\n        {\n            \"H\": np.array([[1.0]]),\n            \"x_f\": np.array([0.0]),\n            \"P_f\": np.array([[0.0]]),\n            \"R\": np.array([[1.0]]),\n            \"y\": np.array([1.959963984540054]),\n            \"alpha\": 0.05\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract matrices and parameters for the current case.\n        H = case[\"H\"]\n        x_f = case[\"x_f\"]\n        P_f = case[\"P_f\"]\n        R = case[\"R\"]\n        y = case[\"y\"]\n        alpha = case[\"alpha\"]\n\n        # Step 1: Determine the degrees of freedom.\n        # m is the dimension of the observation space.\n        m = H.shape[0]\n\n        # Step 2: Compute the innovation vector.\n        # v = y - H * x_f\n        v = y - H @ x_f\n        \n        # Step 3: Compute the innovation covariance matrix.\n        # S = H * P_f * H^T + R\n        S = H @ P_f @ H.T + R\n        \n        # Step 4: Compute the test statistic.\n        # z = v^T * S^-1 * v\n        S_inv = np.linalg.inv(S)\n        # Reshape v to be a column vector for correct matrix multiplication if it's 1D\n        if v.ndim == 1:\n            v_col = v[:, np.newaxis]\n            z = (v_col.T @ S_inv @ v_col)[0, 0]\n        else:\n            z = (v.T @ S_inv @ v)[0, 0]\n\n        # Step 5: Determine the critical value.\n        # c is the upper (1-alpha) quantile of the Chi-squared distribution.\n        c = chi2.ppf(1 - alpha, df=m)\n        \n        # Step 6: Apply the decision rule.\n        # Reject if z > c.\n        is_rejected = z > c\n        \n        # The result must be a standard Python boolean\n        results.append(bool(is_rejected))\n\n    # Format output as a string representation of a list of booleans,\n    # with 'True' and 'False' (capitalized), as per Python's str(bool).\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2382619"}]}