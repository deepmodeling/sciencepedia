{"hands_on_practices": [{"introduction": "在开发或使用数值代码时，一项关键任务是验证其是否按预期工作。验证数值方法的收敛阶是其中最基本也最有效的方法之一。本练习将指导您建立一个自动化程序，通过对数-对数图和线性回归来稳健地估算收敛阶——这是每位计算工程师都应掌握的基本技能。[@problem_id:2389343]", "problem": "给定一个在一维闭区间 $[0,1]$ 上的设定，该区间上有一个包含 $N+1$ 个节点的均匀网格 $x_i = i h$，其中 $h = 1/N$ 且 $i \\in \\{0,1,\\dots,N\\}$。精确的光滑函数为 $u(x) = \\sin(2\\pi x)$。对于一个网格尺寸为 $h$ 的数值方法，将其逐点误差表示为 $e_h(x) = u_h(x) - u(x)$。您需要使用误差范数，在下列假设下，自动检测该方法的收敛阶 $p$。\n\n基本依据：\n- 在均匀网格上，离散 $L^1$、$L^2$ 和 $L^\\infty$ 范数使用黎曼和来近似其对应的连续范数。对于误差向量 $e_i \\approx e_h(x_i)$，\n  - 离散 $L^1$ 范数为 $\\|e_h\\|_{1,h} = h \\sum_{i=0}^N |e_i|$，\n  - 离散 $L^2$ 范数为 $\\|e_h\\|_{2,h} = \\sqrt{h \\sum_{i=0}^N e_i^2}$，\n  - 离散 $L^\\infty$ 范数为 $\\|e_h\\|_{\\infty,h} = \\max_{0 \\le i \\le N} |e_i|$。\n- 在足够小的 $h$ 的渐近区域内，许多相容的数值方法都表现出形式为 $\\|e_h\\| \\approx C h^p$ 的误差范数缩放关系，其中常数 $C > 0$ 和 $p > 0$ 不依赖于 $h$。\n\n任务：\n- 从上述定义和渐近缩放假设出发，推导一个用于计算收敛阶 $p$ 的有理论依据的估计器。该估计器仅使用在多个网格尺寸 $h$ 下计算出的误差范数。您的估计器不能假设已知 $C$ 的值，并且必须对误差中微小的高阶污染项具有鲁棒性。\n- 实现一个完整的程序，该程序能够：\n  1. 为一系列网格尺寸 $h$ 构建一族近似解 $u_h(x)$，并计算相应的误差范数。\n  2. 应用您的估计器，从每种情况的最精细层级中获取 $\\widehat{p}$。\n  3. 汇总给定测试套件的结果，并以要求的最终输出格式打印它们。\n\n综合“未知”方法模型：\n- 对于每个网格尺寸 $h$，近似解定义为\n  $$u_h(x) = u(x) + C\\,h^p\\,w(x) + \\delta(x;h),$$\n  其中 $w(x)$ 是一个光滑的“误差形态”，而 $\\delta(x;h)$ 是一个可选的高阶污染项，用于模拟前渐近效应。$w(x)$ 和 $\\delta(x;h)$ 都在下面的测试套件中被完全指定，但您的估计器除了计算 $e_h(x)$ 的范数外，不得使用任何关于 $C$、$p$、$w(x)$ 或 $\\delta(x;h)$ 的先验知识。\n\n需计算的范数：\n- 对每个测试案例和每个 $h$，根据上面给出的定义，使用包含 $N+1$ 个点且 $h=1/N$ 的均匀网格，计算指定的 $q \\in \\{1,2,\\infty\\}$ 所对应的离散范数 $\\|e_h\\|_{q,h}$。\n\n估计器应用规则：\n- 对每个测试案例，通过将您的估计器应用于三个最细的网格尺寸（即该案例中三个最小的 $h$ 值）来估计 $p$。\n\n测试套件：\n- 在每个案例中使用以下网格尺寸：$N \\in \\{10,20,40,80,160\\}$，因此 $h \\in \\{1/10,1/20,1/40,1/80,1/160\\}$。\n- 案例1（理想情况）：$p = 2$，$C = 0.7$，$w(x) = \\cos(\\pi x)$，$\\delta(x;h) \\equiv 0$，范数为 $L^2$。\n- 案例2（不同范数）：$p = 1$，$C = 1.5$，$w(x) = e^{x}$，$\\delta(x;h) \\equiv 0$，范数为 $L^1$。\n- 案例3（分数阶和 $L^\\infty$）：$p = 1.5$，$C = 0.3$，$w(x) = \\sin(3\\pi x)$，$\\delta(x;h) \\equiv 0$，范数为 $L^\\infty$。\n- 案例4（前渐近污染）：$p = 3$，$C = 0.2$，$w(x) = \\cos(5\\pi x)$，$\\delta(x;h) = D\\,h^{p+1}\\,\\sin(7\\pi x)$，其中 $D = 5.0$，范数为 $L^2$。\n\n算法要求：\n- 在每个案例中，仅使用范数值和网格尺寸来估计 $p$。\n- 为减轻前渐近效应的影响，在每种情况下，仅对三个最细的网格尺寸（即 $N \\in \\{40,80,160\\}$）应用您的估计器。\n\n最终输出规范：\n- 您的程序必须生成单行输出，其中包含一个列表，内含按案例1到4顺序排列的四个估计收敛阶，每个收敛阶四舍五入到3位小数。格式必须严格为方括号内包含的逗号分隔列表，例如 $[a,b,c,d]$，其中 $a$、$b$、$c$ 和 $d$ 均为十进制数。\n\n不涉及物理单位。所有角度均以弧度为单位。最终答案必须在不需要任何用户输入或外部文件的情况下生成。", "solution": "将对所述问题进行验证。\n\n步骤1：提取给定信息\n- 域：闭区间 $[0,1]$。\n- 网格：包含 $N+1$ 个节点的均匀网格 $x_i = i h$，其中 $h = 1/N$ 且 $i \\in \\{0, 1, \\dots, N\\}$。\n- 精确函数：$u(x) = \\sin(2\\pi x)$。\n- 逐点误差：$e_h(x) = u_h(x) - u(x)$。\n- 离散 $L^1$ 范数：$\\|e_h\\|_{1,h} = h \\sum_{i=0}^N |e_i|$。\n- 离散 $L^2$ 范数：$\\|e_h\\|_{2,h} = \\sqrt{h \\sum_{i=0}^N e_i^2}$。\n- 离散 $L^\\infty$ 范数：$\\|e_h\\|_{\\infty,h} = \\max_{0 \\le i \\le N} |e_i|$。\n- 渐近误差缩放：$\\|e_h\\| \\approx C h^p$，其中常数 $C > 0$ 和 $p > 0$。\n- 综合近似模型：$u_h(x) = u(x) + C\\,h^p\\,w(x) + \\delta(x;h)$。\n- 用于分析的网格尺寸：$N \\in \\{10, 20, 40, 80, 160\\}$，这意味着 $h \\in \\{1/10, 1/20, 1/40, 1/80, 1/160\\}$。\n- 估计器应用规则：使用三个最细的网格尺寸，对应 $N \\in \\{40, 80, 160\\}$。\n- 测试案例1：$p = 2$，$C = 0.7$，$w(x) = \\cos(\\pi x)$，$\\delta(x;h) \\equiv 0$，范数为 $L^2$。\n- 测试案例2：$p = 1$，$C = 1.5$，$w(x) = e^{x}$，$\\delta(x;h) \\equiv 0$，范数为 $L^1$。\n- 测试案例3：$p = 1.5$，$C = 0.3$，$w(x) = \\sin(3\\pi x)$，$\\delta(x;h) \\equiv 0$，范数为 $L^\\infty$。\n- 测试案例4：$p = 3$，$C = 0.2$，$w(x) = \\cos(5\\pi x)$，$\\delta(x;h) = D\\,h^{p+1}\\,\\sin(7\\pi x)$，其中 $D = 5.0$，范数为 $L^2$。所有角度均以弧度为单位。\n\n步骤2：使用提取的给定信息进行验证\n根据验证标准对问题进行评估。\n- **科学上成立**：该问题基于数值分析的基本概念，特别是数值方法收敛率的研究，这是计算工程和应用数学中的一个标准课题。定义和模型都是标准的。问题在科学上是合理的。\n- **适定性**：该问题是适定的（或称良构的）。它提供了所有必要的信息——精确函数、数值误差模型、范数定义、要使用的网格尺寸以及明确的目标。任务是推导并应用一个估计器，对此存在唯一且有意义的解。\n- **客观性**：语言精确且量化。没有主观或基于意见的陈述。所有参数都有明确定义。\n- 问题是自包含、一致且可形式化的。没有矛盾、缺失数据或不切实际的要求。\n\n步骤3：结论与行动\n问题有效。将提供完整的解答。\n\n**收敛阶估计器的推导**\n\n问题在于根据误差范数 $\\|e_h\\|$ 作为网格尺寸 $h$ 的函数的渐近关系来确定收敛阶 $p$。控制模型为：\n$$\n\\|e_h\\| \\approx C h^p\n$$\n其中，对于足够小的 $h$，$C$ 和 $p$ 是与 $h$ 无关的常数。常数 $C$ 是未知的。为了消除 $C$ 并求解 $p$，我们可以通过对两边取自然对数将关系式转换为线性形式：\n$$\n\\ln(\\|e_h\\|) \\approx \\ln(C h^p) = \\ln(C) + \\ln(h^p) = \\ln(C) + p \\ln(h)\n$$\n该方程的形式为 $Y = A + p X$，其中 $Y = \\ln(\\|e_h\\|)$，$X = \\ln(h)$，截距 $A = \\ln(C)$ 是一个常数。这揭示了误差范数的对数与网格尺寸的对数之间存在线性关系。收敛阶 $p$ 就是这条线的斜率。\n\n问题要求使用来自三个网格细化层级的数据，我们将其表示为 $h_1, h_2, h_3$，相应的计算误差范数为 $E_1, E_2, E_3$。这为我们提供了三个数据点 $(X_i, Y_i) = (\\ln(h_i), \\ln(E_i))$，其中 $i \\in \\{1, 2, 3\\}$。可以通过线性最小二乘回归获得斜率 $p$ 的一个鲁棒估计。该方法寻找一条线，使数据点到该线的垂直距离的平方和最小。对于一组 $n$ 个点 $(X_i, Y_i)$，最佳拟合线的斜率 $\\hat{p}$ 的公式为：\n$$\n\\hat{p} = \\frac{n \\sum_{i=1}^n X_i Y_i - \\left(\\sum_{i=1}^n X_i\\right) \\left(\\sum_{i=1}^n Y_i\\right)}{n \\sum_{i=1}^n X_i^2 - \\left(\\sum_{i=1}^n X_i\\right)^2}\n$$\n这种方法是有理论依据的，因为它使用了来自三个指定网格层级的所有可用信息。它对理想线性模型的微小扰动也具有鲁棒性，例如由误差中的高阶项（如案例4中的 $\\delta(x;h)$ 项）引入的扰动，因为回归过程具有平均效应。\n\n**实现策略**\n\n对每个测试案例，实现将遵循一个系统性步骤。\n1.  定义测试案例的参数：真实阶数 $p_{true}$、常数 $C$、误差形态函数 $w(x)$、污染项 $\\delta(x;h)$ 以及范数类型 $q \\in \\{1, 2, \\infty\\}$。\n2.  对于三个最细的网格分辨率 $N \\in \\{40, 80, 160\\}$，执行以下步骤：\n    a. 计算网格尺寸 $h=1/N$。\n    b. 生成由 $N+1$ 个点组成的均匀网格，$x_i = i h$，其中 $i=0, \\dots, N$。\n    c. 在网格上计算精确解 $u(x_i) = \\sin(2\\pi x_i)$。\n    d. 在网格上构建近似解 $u_h(x_i) = u(x_i) + C\\,h^{p_{true}}\\,w(x_i) + \\delta(x_i;h, p_{true})$。请注意，这里仅使用真实阶数 $p_{true}$ 来生成综合数据，如题目所规定。\n    e. 计算逐点误差向量 $e_i = u_h(x_i) - u(x_i)$。\n    f. 根据提供的公式计算指定的离散误差范数 $\\|e_h\\|_{q,h}$。\n3.  在为三个网格尺寸（$h_1, h_2, h_3$）计算出三个误差范数（$E_1, E_2, E_3$）后，创建两个向量：$X = [\\ln(h_1), \\ln(h_2), \\ln(h_3)]$ 和 $Y = [\\ln(E_1), \\ln(E_2), \\ln(E_3)]$。\n4.  对数据 $(X, Y)$ 应用线性回归算法以找到斜率。一个标准的数值库函数，例如带有阶数 $1$ 的 `numpy.polyfit`，提供了最小二乘公式的高效实现，它返回的第一个系数即为斜率。这个斜率就是收敛阶的估计值 $\\hat{p}$。\n5.  对所有四个测试案例重复此过程。收集所得的估计值，并按要求格式化为最终输出，即一个包含四舍五入到3位小数的数字列表。\n\n该方法严格遵守了问题的约束：它仅使用范数值和网格尺寸进行估计，并应用了一种有理论依据且鲁棒的技术，适用于分析收敛数据。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by estimating the order of convergence for four test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"case\": 1,\n            \"p_true\": 2.0,\n            \"C\": 0.7,\n            \"w_func\": lambda x: np.cos(np.pi * x),\n            \"delta_func\": lambda x, h, p: 0.0,\n            \"q\": 2\n        },\n        {\n            \"case\": 2,\n            \"p_true\": 1.0,\n            \"C\": 1.5,\n            \"w_func\": lambda x: np.exp(x),\n            \"delta_func\": lambda x, h, p: 0.0,\n            \"q\": 1\n        },\n        {\n            \"case\": 3,\n            \"p_true\": 1.5,\n            \"C\": 0.3,\n            \"w_func\": lambda x: np.sin(3 * np.pi * x),\n            \"delta_func\": lambda x, h, p: 0.0,\n            \"q\": np.inf\n        },\n        {\n            \"case\": 4,\n            \"p_true\": 3.0,\n            \"C\": 0.2,\n            \"w_func\": lambda x: np.cos(5 * np.pi * x),\n            \"delta_func\": lambda x, h, p: 5.0 * h**(p + 1) * np.sin(7 * np.pi * x),\n            \"q\": 2\n        }\n    ]\n\n    results = []\n    # Mesh resolutions to use for the estimator, as per the problem statement.\n    mesh_resolutions_N = [40, 80, 160]\n\n    for case in test_cases:\n        p_true = case[\"p_true\"]\n        C = case[\"C\"]\n        w_func = case[\"w_func\"]\n        delta_func = case[\"delta_func\"]\n        q = case[\"q\"]\n\n        mesh_sizes_h = []\n        error_norms = []\n\n        for N in mesh_resolutions_N:\n            h = 1.0 / N\n            mesh_sizes_h.append(h)\n            \n            # Create the uniform grid from x=0 to x=1 with N+1 points.\n            x = np.linspace(0.0, 1.0, N + 1)\n            \n            # Compute the exact solution u(x) = sin(2*pi*x).\n            u_exact = np.sin(2 * np.pi * x)\n            \n            # Compute the approximate solution using the synthetic model.\n            error_shape = C * h**p_true * w_func(x)\n            contamination = delta_func(x, h, p_true)\n            u_approx = u_exact + error_shape + contamination\n            \n            # Compute the pointwise error.\n            error_vector = u_approx - u_exact\n            \n            # Compute the specified discrete norm of the error.\n            norm = 0.0\n            if q == 1:\n                # Discrete L1 norm: h * sum(|e_i|)\n                norm = h * np.sum(np.abs(error_vector))\n            elif q == 2:\n                # Discrete L2 norm: sqrt(h * sum(e_i^2))\n                norm = np.sqrt(h * np.sum(error_vector**2))\n            elif q == np.inf:\n                # Discrete L-infinity norm: max(|e_i|)\n                norm = np.max(np.abs(error_vector))\n            \n            error_norms.append(norm)\n\n        # Estimate the order of convergence p using linear regression on the log-log data.\n        # The model is log(E) = log(C) + p * log(h).\n        # We find the slope 'p' of the best-fit line for (log(h), log(E)).\n        log_h = np.log(np.array(mesh_sizes_h))\n        log_E = np.log(np.array(error_norms))\n        \n        # np.polyfit with degree 1 fits a line and returns [slope, intercept].\n        # The slope is our estimate for the order of convergence p.\n        p_estimated, _ = np.polyfit(log_h, log_E, 1)        \n        results.append(p_estimated)\n\n    # Final print statement in the exact required format.\n    # The output is a comma-separated list of results rounded to 3 decimal places, inside brackets.\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```", "id": "2389343"}, {"introduction": "虽然收敛阶分析至关重要，但误差范数的选择同样会深刻影响我们对结果的判断。一个数值方法可能在“平均”意义上（如在 $L^2$ 范数下）表现出良好的收敛性，但在某些点上却可能产生完全错误甚至非物理的振荡行为。本练习通过一个经典的刚性常微分方程案例，展示了这种积分范数与逐点行为之间的重要区别，旨在培养您超越单一指标、批判性审视数值结果的能力。[@problem_id:2389318]", "problem": "构建一个完全指定的计算实验，以展示刚性常微分方程下积分范数收敛与逐点行为之间的对比。考虑区间 $[0,1]$ 上的初值问题：\n- 刚性线性常微分方程：$y'(t) = -\\lambda y(t)$，刚性参数 $\\lambda = 100$。\n- 初始条件：$y(0) = 1$。\n- 精确解：$y(t) = e^{-\\lambda t}$。\n\n对于每个均匀时间步数 $N \\in \\mathbb{N}$，定义步长 $h = 1/N$ 和离散近似 $\\{Y_n\\}_{n=0}^{N}$，其通过前向（显式）欧拉 (Forward (Explicit) Euler) 时间步进格式给出：\n$$\nY_{n+1} = Y_n + h(-\\lambda Y_n) = (1 - h\\lambda) Y_n,\\quad Y_0 = 1,\n$$\n并定义连续分段线性插值函数 $y_h:[0,1]\\to\\mathbb{R}$，其通过对节点值 $\\{(t_n,Y_n)\\}_{n=0}^{N}$（其中 $t_n = nh$）进行线性插值得到。\n\n对给定的 $h$，定义时间连续的 $L^2$ 误差范数为\n$$\nE_2(h) = \\left(\\int_0^1 \\lvert y_h(t) - y(t) \\rvert^2\\,dt\\right)^{1/2}。\n$$\n定义离散轨迹的逐点振荡指标，通过计算序列 $\\{Y_n\\}_{n=0}^{N}$ 中的符号变化次数。因为精确解 $y(t)$ 在 $[0,1]$ 上严格为正，所以离散解的任何符号变化都被视为不正确的逐点行为。\n\n您的程序必须对下面列出的每个测试用例，在该测试用例给出的三个步数 $N$ 上评估以下两个布尔度量：\n- 在加密过程中积分范数误差是否严格递减：对于测试用例中按顺序列出的三个步长 $h_i = 1/N_i$，如果 $E_2(h_1) > E_2(h_2) > E_2(h_3)$ 成立，则返回 $\\mathrm{True}$，否则返回 $\\mathrm{False}$。\n- 是否存在逐点振荡：如果在测试用例的三个步数对应的三个离散解 $\\{Y_n\\}$ 中，至少有一个出现至少一次符号变化，则返回 $\\mathrm{True}$，否则返回 $\\mathrm{False}$。\n\n测试套件（每行是一个测试用例，指定三个步数 $N$）：\n- 案例 A（稳定但振荡的区域）：$N \\in \\{52,55,59\\}$。\n- 案例 B（良好解析的区域）：$N \\in \\{200,400,800\\}$。\n- 案例 C（稳定边界及其以外）：$N \\in \\{50,49,48\\}$。\n- 案例 D（混合区域）：$N \\in \\{83,100,125\\}$。\n\n您的程序必须精确计算 $E_2(h)$（对于分段线性的 $y_h$），或通过足够精度的数值积分来计算，以确保布尔比较在每个 $E_2(h)$ 值上的绝对容差 $10^{-8}$ 内是正确的，并且必须严格地在离散节点值 $\\{Y_n\\}$ 上实现符号变化测试。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含八个布尔结果，以逗号分隔的列表形式聚合，并用方括号括起来，顺序如下：\n$$\n[\\text{A\\_dec},\\text{A\\_osc},\\ \\text{B\\_dec},\\text{B\\_osc},\\ \\text{C\\_dec},\\text{C\\_osc},\\ \\text{D\\_dec},\\text{D\\_osc}],\n$$\n例如，$\\text{A\\_dec}$ 是一个布尔值，指示在案例 A 的三个 $N$ 值上 $E_2$ 是否严格递减，而 $\\text{A\\_osc}$ 指示在案例 A 的离散轨迹中是否发生任何符号变化。布尔值必须打印为 $\\mathrm{True}$ 或 $\\mathrm{False}$，该行上不得有其他内容。", "solution": "我们完全根据定义来形式化此计算实验。常微分方程为 $y'(t) = -\\lambda y(t)$，其中 $\\lambda = 100$，$t \\in [0,1]$，$y(0)=1$。精确解是 $y(t) = e^{-\\lambda t}$，它在 $[0,1]$ 上严格为正且严格递减。刚性的产生是因为衰减的时间尺度为 $1/\\lambda$，因此对于 $\\lambda=100$，解在小尺度 $t=\\mathcal{O}(10^{-2})$ 上相对于定义域长度 $1$ 表现出快速衰减。\n\n对于一个具有 $N$ 个步长的均匀网格，$h = 1/N$ 且 $t_n = nh$，前向（显式）欧拉格式从第一性原理出发，通过将导数的定义应用于半离散更新来定义：\n$$\n\\frac{Y_{n+1} - Y_n}{h} \\approx y'(t_n) = -\\lambda y(t_n),\n$$\n通过用 $Y_n$ 替换 $y(t_n)$，我们得到\n$$\nY_{n+1} = Y_n + h(-\\lambda Y_n) = (1 - h\\lambda) Y_n,\\quad Y_0 = 1.\n$$\n这个闭式递推关系得出\n$$\nY_n = (1 - h\\lambda)^n.\n$$\n然后，在每个子区间 $[t_n,t_{n+1}]$ 上，连续分段线性插值函数 $y_h(t)$ 由匹配节点值的唯一线性函数定义：\n$$\ny_h(t) = \\frac{t_{n+1}-t}{h} Y_n + \\frac{t - t_n}{h} Y_{n+1},\\qquad t \\in [t_n,t_{n+1}].\n$$\n\n我们用时间连续的 $L^2$ 范数来度量误差，\n$$\nE_2(h) = \\left(\\int_0^1 \\lvert y_h(t) - e^{-\\lambda t} \\rvert^2\\,dt\\right)^{1/2}。\n$$\n这是差函数的范数，根据定义，它对随时间变化的逐点误差的平方进行积分。因为 $y_h$ 是分段线性的，而 $y$ 是光滑的，$E_2(h)$ 可以通过在每个子区间上进行精确积分（一个二次函数减去一个指数函数（其反导数已知）的展开式）或通过足够精确的数值求积来评估，从而使得不同 $h$ 值之间的比较在小的绝对容差内是正确的。\n\n我们还通过检测离散序列 $\\{Y_n\\}_{n=0}^{N}$ 中的符号变化来量化不正确的逐点行为。由于精确解在 $[0,1]$ 上满足 $y(t)>0$，数值序列中的任何符号变化都是非物理的振荡。对于线性测试方程上的前向欧拉格式，其放大因子为\n$$\nG(h\\lambda) = 1 - h\\lambda.\n$$\n如果 $0 < h\\lambda < 1$，那么 $G(h\\lambda) \\in (0,1)$，因此 $Y_{n+1} = G Y_n$ 保持为正且单调递减，不出现符号变化。如果 $1 < h\\lambda < 2$，那么 $G(h\\lambda) \\in (-1,0)$，因此 $Y_{n+1}$ 符号交替且数值大小衰减，产生逐点振荡。如果 $h\\lambda \\ge 2$，那么 $\\lvert G(h\\lambda) \\rvert \\ge 1$，该方法处于稳定边界或不稳定，通常会产生持续或增长的振荡。\n\n测试套件论证：\n- 案例 A 使用 $N \\in \\{52,55,59\\}$，即 $h\\lambda \\in \\{100/52,100/55,100/59\\} \\subset (1,2)$，因此离散解是振荡但稳定的。随着 $N$ 增加，$h$ 减小，$L^2$ 误差 $E_2(h)$ 预期会严格减小；由于符号交替，振荡指标应为正。\n- 案例 B 使用 $N \\in \\{200,400,800\\}$，即 $h\\lambda \\in \\{0.5,0.25,0.125\\} \\subset (0,1)$，因此该方法是稳定且非振荡的。$E_2(h)$ 应严格减小，且振荡指标应为负（无符号变化）。\n- 案例 C 使用 $N \\in \\{50,49,48\\}$，即 $h\\lambda \\in \\{2.0,\\approx 2.0408,\\approx 2.0833\\}$，跨越稳定边界和不稳定区域。在此顺序下，$L^2$ 误差在序列中并非严格递减（处于稳定边界的第一个值通常远小于后续不稳定情况的值），而由于符号交替和不稳定性，振荡指标为正。\n- 案例 D 使用 $N \\in \\{83,100,125\\}$，即 $h\\lambda \\in \\{\\approx 1.2048,1.0,0.8\\}$，从振荡稳定过渡到非振荡稳定。$L^2$ 误差应严格减小，而振荡指标应为正，因为至少最粗糙的选择会产生符号变化。\n\n基于这些原理的算法实现：\n- 对于每个 $N$，通过递推关系计算节点值 $\\{Y_n\\}$，并通过在 $[0,1]$ 上的线性插值构成 $y_h$。\n- 通过在 $[0,1]$ 的密集均匀划分上对 $\\lvert y_h(t) - e^{-\\lambda t}\\rvert^2$ 进行数值积分来评估 $E_2(h)$，例如，通过使用足够多偶数个子区间的复合梯形法则，以达到优于 $10^{-8}$ 的绝对精度。\n- 通过检查是否存在索引 $n$ 使得 $Y_n Y_{n+1} < 0$ （符号变化）来确定振荡指标。\n- 对于每个由三个按规定顺序排列的 $N$ 值组成的测试用例，计算 $E_2$ 在这三者之间是否严格递减以及这三者中是否存在振荡的布尔值。\n\n最终输出是列表\n$$\n[\\text{A\\_dec},\\text{A\\_osc},\\ \\text{B\\_dec},\\text{B\\_osc},\\ \\text{C\\_dec},\\text{C\\_osc},\\ \\text{D\\_dec},\\text{D\\_osc}],\n$$\n以布尔值的形式打印在单行上。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef forward_euler_linear_decay(lmbda: float, N: int):\n    \"\"\"\n    Solve y' = -lambda*y, y(0)=1 on [0,1] with Forward Euler using N steps.\n    Returns time nodes t (size N+1) and solution values Y (size N+1).\n    \"\"\"\n    h = 1.0 / N\n    t = np.linspace(0.0, 1.0, N + 1)\n    Y = np.empty(N + 1, dtype=float)\n    Y[0] = 1.0\n    factor = 1.0 - h * lmbda\n    # Use recurrence: Y_n = factor^n\n    # Iterative to avoid potential under/overflow in pow for large N and debug clarity\n    for n in range(N):\n        Y[n + 1] = Y[n] * factor\n    return t, Y\n\ndef piecewise_linear_interpolant_values(t_nodes: np.ndarray, y_nodes: np.ndarray, t_query: np.ndarray):\n    \"\"\"\n    Evaluate the piecewise linear interpolant through (t_nodes, y_nodes) at t_query.\n    Uses numpy's linear interpolation.\n    Assumes t_nodes is sorted ascending spanning [0,1].\n    \"\"\"\n    return np.interp(t_query, t_nodes, y_nodes)\n\ndef l2_error(lmbda: float, t_nodes: np.ndarray, y_nodes: np.ndarray, num_subintervals: int = 200000):\n    \"\"\"\n    Compute L2(0,1) error norm between piecewise-linear y_h and exact y(t)=exp(-lambda t).\n    Uses composite trapezoidal rule on a uniform grid with num_subintervals subintervals.\n    \"\"\"\n    # Ensure even number of subintervals for symmetric sampling (not required for trapz but good practice)\n    if num_subintervals % 2 == 1:\n        num_subintervals += 1\n    tq = np.linspace(0.0, 1.0, num_subintervals + 1)\n    yh = piecewise_linear_interpolant_values(t_nodes, y_nodes, tq)\n    y_exact = np.exp(-lmbda * tq)\n    err_sq = (yh - y_exact) ** 2\n    integral = np.trapz(err_sq, tq)\n    return np.sqrt(integral)\n\ndef has_sign_change(y_nodes: np.ndarray):\n    \"\"\"\n    Return True if the discrete sequence y_nodes exhibits any sign change between consecutive nodes.\n    \"\"\"\n    # Consider exact zero as non-negative for sign-change detection\n    prod = y_nodes[:-1] * y_nodes[1:]\n    return np.any(prod < 0.0)\n\ndef evaluate_case(lmbda: float, N_list):\n    \"\"\"\n    For a list of three N values, compute:\n    - strictly decreasing L2 error across the list order\n    - presence of oscillations (any sign change) among the three solutions\n    Returns tuple (dec_bool, osc_bool).\n    \"\"\"\n    E2_vals = []\n    osc_flags = []\n    for N in N_list:\n        t_nodes, y_nodes = forward_euler_linear_decay(lmbda, N)\n        E2 = l2_error(lmbda, t_nodes, y_nodes, num_subintervals=200000)\n        E2_vals.append(E2)\n        osc_flags.append(has_sign_change(y_nodes))\n    dec = (E2_vals[0] > E2_vals[1]) and (E2_vals[1] > E2_vals[2])\n    osc = any(osc_flags)\n    return dec, osc\n\ndef solve():\n    # Define parameters\n    lmbda = 100.0  # stiffness parameter\n    # Test cases: lists of N (number of steps); h = 1/N\n    case_A = [52, 55, 59]     # stable but oscillatory (1 < h*lambda < 2)\n    case_B = [200, 400, 800]  # well-resolved (h*lambda << 1)\n    case_C = [50, 49, 48]     # boundary and unstable (h*lambda >= 2), ordered to break monotonic decrease\n    case_D = [83, 100, 125]   # mixed: oscillatory -> boundary -> non-oscillatory\n\n    test_cases = [case_A, case_B, case_C, case_D]\n\n    results = []\n    for case in test_cases:\n        dec, osc = evaluate_case(lmbda, case)\n        results.append(dec)\n        results.append(osc)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2389318"}, {"introduction": "最后，我们来探讨一个更根本的理论问题：为什么我们需要像 $L^2$ 和 $H^1$ 这样不同的范数？在有限维空间中，所有范数都是“等价”的，它们在衡量收敛性时提供相似的信息。本练习将揭示，在函数空间（无限维）这一有限元方法的自然背景下，情况并非如此。通过构造一个简单的函数序列，您将亲眼看到，在一个范数（$H^1$ 半范数）下保持恒定，可能意味着在另一个范数（$L^2$ 范数）下趋近于零，这凸显了使用不同范数捕捉误差不同方面的必要性。[@problem_id:2389350]", "problem": "考虑区间 $\\left[0,1\\right]$ 以及一个由具有零边界值的连续分段线性函数构成的标准协调有限元空间，这是在区间 $\\left[0,1\\right]$ 上求解泊松问题时，有限元方法（FEM, Finite Element Method）所使用的典型试验空间。对于网格尺寸为 $h \\in \\left(0,\\tfrac{1}{2}\\right]$ 的均匀网格，其中 $\\tfrac{1}{2h}$ 为整数，令 $\\varphi_h$ 表示以 $x=\\tfrac{1}{2}$ 为中心的节点帽状基函数，即\n$$\n\\varphi_h(x) \\;=\\; \\begin{cases}\n1 - \\dfrac{\\left|x - \\tfrac{1}{2}\\right|}{h}, & \\text{若 } \\left|x - \\tfrac{1}{2}\\right| \\le h, \\\\\n0, & \\text{其它。}\n\\end{cases}\n$$\n定义 $u_h(x) = \\alpha_h\\,\\varphi_h(x)$，其中缩放因子 $\\alpha_h > 0$ 的选择应使得 $u_h$ 的 $H^1$ 半范数等于 $1$，即 $\\lVert u_h' \\rVert_{L^2(0,1)} = 1$。当 $h \\to 0$ 时，该构造方法可以得到一个有限元函数序列 $\\left\\{u_h\\right\\}$。\n\n您的任务是利用该序列，通过量化在 $H^1$ 半范数固定的情况下 $L^2$ 范数的行为，来证明在无限维设定中范数的等价性失效。对于每个指定的网格尺寸 $h$，计算 $u_h$ 的以下量值：\n- $L^2$ 范数 $\\lVert u_h \\rVert_{L^2(0,1)}$，\n- $L^\\infty$ 范数 $\\lVert u_h \\rVert_{L^\\infty(0,1)}$。\n\n本问题不涉及物理单位。\n\n测试集：\n使用网格尺寸 $h \\in \\left\\{\\tfrac{1}{2},\\,\\tfrac{1}{4},\\,\\tfrac{1}{8},\\,\\tfrac{1}{16},\\,\\tfrac{1}{32},\\,\\tfrac{1}{64}\\right\\}$。\n\n答案格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。对于上面所列顺序中的每个 $h$，按以下顺序输出两个浮点数：\n$\\left[\\lVert u_h \\rVert_{L^2(0,1)},\\, \\lVert u_h \\rVert_{L^\\infty(0,1)}\\right]$。\n所有数字必须四舍五入到小数点后六位。因此，最终输出必须包含 $12$ 个数字，并采用以下格式：\n$[\\text{L2}_1,\\text{Linfty}_1,\\text{L2}_2,\\text{Linfty}_2,\\ldots,\\text{L2}_6,\\text{Linfty}_6]$,\n其中 $\\text{L2}_k$ 和 $\\text{Linfty}_k$ 对应于测试集中的第 $k$ 个网格尺寸。", "solution": "该问题是有效的，因为它的科学基础在于泛函分析和有限元方法的原理，问题本身是适定的，提供了所有必要信息，并以客观、无歧义的数学语言表述。问题中没有矛盾，可以推导出唯一且可验证的解。\n\n目标是分析对于一个递减的网格尺寸 $h$ 序列，有限元函数序列 $u_h(x) = \\alpha_h \\varphi_h(x)$ 的行为。缩放因子 $\\alpha_h$ 由归一化条件确定，即 $H^1$ 半范数为 1，也就是 $\\lVert u_h' \\rVert_{L^2(0,1)} = 1$。然后，我们必须计算序列中每个函数 $u_h$ 的 $L^2(0,1)$ 和 $L^\\infty(0,1)$ 范数。\n\n分析过程分三步进行：第一步，确定缩放因子 $\\alpha_h$；第二步，计算 $L^2$ 范数；第三步，计算 $L^\\infty$ 范数。\n\n第一步：确定缩放因子 $\\alpha_h$。\n\n通过强制执行条件 $\\lVert u_h' \\rVert_{L^2(0,1)}^2 = 1$ 来求得缩放因子 $\\alpha_h$。\n函数 $u_h(x)$ 定义为 $u_h(x) = \\alpha_h \\varphi_h(x)$。其导数为 $u_h'(x) = \\alpha_h \\varphi_h'(x)$。\n基函数 $\\varphi_h(x)$ 由下式给出\n$$\n\\varphi_h(x) =\n\\begin{cases}\n1 + \\frac{x - 1/2}{h}, & x \\in [1/2 - h, 1/2] \\\\\n1 - \\frac{x - 1/2}{h}, & x \\in [1/2, 1/2 + h] \\\\\n0, & \\text{其它}\n\\end{cases}\n$$\n（弱）导数 $\\varphi_h'(x)$ 是一个分段常数函数：\n$$\n\\varphi_h'(x) =\n\\begin{cases}\n\\frac{1}{h}, & x \\in (1/2 - h, 1/2) \\\\\n-\\frac{1}{h}, & x \\in (1/2, 1/2 + h) \\\\\n0, & \\text{其它}\n\\end{cases}\n$$\n$u_h$ 的 $H^1$ 半范数的平方为：\n$$\n\\lVert u_h' \\rVert_{L^2(0,1)}^2 = \\int_0^1 (u_h'(x))^2 \\, dx = \\alpha_h^2 \\int_0^1 (\\varphi_h'(x))^2 \\, dx\n$$\n我们计算积分项：\n$$\n\\int_0^1 (\\varphi_h'(x))^2 \\, dx = \\int_{1/2 - h}^{1/2} \\left(\\frac{1}{h}\\right)^2 \\, dx + \\int_{1/2}^{1/2+h} \\left(-\\frac{1}{h}\\right)^2 \\, dx\n$$\n$$\n= \\frac{1}{h^2} \\int_{1/2 - h}^{1/2} 1 \\, dx + \\frac{1}{h^2} \\int_{1/2}^{1/2+h} 1 \\, dx = \\frac{1}{h^2} \\cdot h + \\frac{1}{h^2} \\cdot h = \\frac{1}{h} + \\frac{1}{h} = \\frac{2}{h}\n$$\n因此，归一化条件 $\\lVert u_h' \\rVert_{L^2(0,1)}^2 = 1$ 变为：\n$$\n\\alpha_h^2 \\left(\\frac{2}{h}\\right) = 1\n$$\n由于已指定 $\\alpha_h > 0$，我们求解 $\\alpha_h$：\n$$\n\\alpha_h = \\sqrt{\\frac{h}{2}}\n$$\n\n第二步：计算 $L^2$ 范数 $\\lVert u_h \\rVert_{L^2(0,1)}$。\n\n$u_h$ 的 $L^2$ 范数的平方由下式给出：\n$$\n\\lVert u_h \\rVert_{L^2(0,1)}^2 = \\int_0^1 (u_h(x))^2 \\, dx = \\alpha_h^2 \\int_0^1 (\\varphi_h(x))^2 \\, dx\n$$\n该积分仅在 $\\varphi_h$ 的支集 $[1/2 - h, 1/2 + h]$ 上非零。由于 $\\varphi_h(x)$ 关于 $x=1/2$ 对称，我们可以写出：\n$$\n\\int_0^1 (\\varphi_h(x))^2 \\, dx = 2 \\int_{1/2}^{1/2+h} \\left(1 - \\frac{x - 1/2}{h}\\right)^2 \\, dx\n$$\n我们进行换元，$y = x - 1/2$，因此 $dy = dx$。积分上下限从 $x \\in [1/2, 1/2+h]$ 变为 $y \\in [0, h]$。\n$$\n= 2 \\int_0^h \\left(1 - \\frac{y}{h}\\right)^2 \\, dy = 2 \\int_0^h \\left(1 - \\frac{2y}{h} + \\frac{y^2}{h^2}\\right) \\, dy\n$$\n$$\n= 2 \\left[ y - \\frac{y^2}{h} + \\frac{y^3}{3h^2} \\right]_0^h = 2 \\left( h - \\frac{h^2}{h} + \\frac{h^3}{3h^2} \\right) = 2 \\left( h - h + \\frac{h}{3} \\right) = \\frac{2h}{3}\n$$\n现在，我们将 $\\alpha_h^2$ 和积分的表达式代回范数的方程中：\n$$\n\\lVert u_h \\rVert_{L^2(0,1)}^2 = \\alpha_h^2 \\cdot \\frac{2h}{3} = \\left(\\frac{h}{2}\\right) \\cdot \\frac{2h}{3} = \\frac{h^2}{3}\n$$\n取平方根得到 $L^2$ 范数：\n$$\n\\lVert u_h \\rVert_{L^2(0,1)} = \\sqrt{\\frac{h^2}{3}} = \\frac{h}{\\sqrt{3}}\n$$\n\n第三步：计算 $L^\\infty$ 范数 $\\lVert u_h \\rVert_{L^\\infty(0,1)}$。\n\n$L^\\infty$ 范数是函数绝对值的本性上确界。对于像 $u_h(x)$ 这样的连续函数，这即是其最大绝对值。\n$$\n\\lVert u_h \\rVert_{L^\\infty(0,1)} = \\sup_{x \\in (0,1)} |u_h(x)|\n$$\n由于 $\\alpha_h > 0$ 且 $\\varphi_h(x) \\ge 0$，上式可简化为：\n$$\n\\lVert u_h \\rVert_{L^\\infty(0,1)} = \\alpha_h \\cdot \\sup_{x \\in (0,1)} \\varphi_h(x)\n$$\n帽状函数 $\\varphi_h(x)$ 在其中心点 $x=1/2$ 处达到最大值 $1$。\n$$\n\\sup_{x \\in (0,1)} \\varphi_h(x) = \\varphi_h(1/2) = 1\n$$\n因此，$L^\\infty$ 范数等于缩放因子 $\\alpha_h$：\n$$\n\\lVert u_h \\rVert_{L^\\infty(0,1)} = \\alpha_h \\cdot 1 = \\alpha_h = \\sqrt{\\frac{h}{2}}\n$$\n当 $h \\to 0$ 时，根据构造有 $\\lVert u_h' \\rVert_{L^2(0,1)} = 1$，而 $\\lVert u_h \\rVert_{L^2(0,1)} \\sim O(h) \\to 0$ 且 $\\lVert u_h \\rVert_{L^\\infty(0,1)} \\sim O(\\sqrt{h}) \\to 0$。这证明了在作为这些有限元空间之并集的完备化空间的无限维空间上，$H^1$ 半范数与 $L^2$ 范数或 $L^\\infty$ 范数不等价。\n\n最终需要实现的公式是：\n- $L^2$ 范数： $\\lVert u_h \\rVert_{L^2(0,1)} = \\frac{h}{\\sqrt{3}}$\n- $L^\\infty$ 范数： $\\lVert u_h \\rVert_{L^\\infty(0,1)} = \\sqrt{\\frac{h}{2}}$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the L2 and L-infinity norms for a sequence of FEM functions.\n\n    For each mesh size h in the test suite, this function calculates the norms\n    of a function u_h(x) = alpha_h * phi_h(x), where phi_h is a nodal hat\n    basis function and alpha_h is a scaling factor chosen such that the H1\n    seminorm of u_h is 1.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Mesh sizes h.\n    test_cases = [1/2, 1/4, 1/8, 1/16, 1/32, 1/64]\n\n    results = []\n    for h in test_cases:\n        # The analytical formulas for the norms are derived as:\n        # L2 norm: ||u_h||_L2 = h / sqrt(3)\n        # L-infinity norm: ||u_h||_L_inf = sqrt(h / 2)\n\n        # Calculate the L2 norm for the current h.\n        l2_norm = h / np.sqrt(3)\n\n        # Calculate the L-infinity norm for the current h.\n        linf_norm = np.sqrt(h / 2)\n\n        # Append the rounded results to the list.\n        results.append(round(l2_norm, 6))\n        results.append(round(linf_norm, 6))\n\n    # Format the final output string as required.\n    # The map converts each float to its string representation.\n    # The ':.6f' format specifier ensures exactly six digits after the decimal point.\n    formatted_results = [f\"{num:.6f}\" for num in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2389350"}]}