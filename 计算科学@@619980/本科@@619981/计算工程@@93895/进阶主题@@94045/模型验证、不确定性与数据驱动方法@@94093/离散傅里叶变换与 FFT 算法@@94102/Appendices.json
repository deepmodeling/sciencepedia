{"hands_on_practices": [{"introduction": "动手实践是掌握任何算法精髓的最佳途径。本练习将引导你从零开始亲手实现库利-图基（Cooley-Tukey）快速傅里叶变换（FFT）算法，这是计算离散傅里叶变换（DFT）最高效的方法之一。通过构建这个算法并用它来验证诸如圆周卷积定理和帕塞瓦尔定理等基本性质，你将不仅学会如何使用FFT，更能深刻理解其高效背后的“分而治之”思想。[@problem_id:2387187]", "problem": "设 $N$ 是一个正整数，其形式为 $N = 2^m$，其中 $m$ 是某个非负整数。对于一个长度为 $N$ 的复值序列 $x = \\{x_n\\}_{n=0}^{N-1}$，其离散傅里叶变换 (DFT) $X = \\{X_k\\}_{k=0}^{N-1}$ 定义为\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1,\n$$\n以及逆离散傅里叶变换 (IDFT) 定义为\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi i \\, k n / N} \\quad \\text{for } n = 0,1,\\dots,N-1,\n$$\n其中所有角度均以弧度为单位。\n\n编写一个完整的程序，在不调用任何库傅里叶变换例程的情况下，为长度为 $N = 2^m$ 的序列计算 DFT 和 IDFT。您的程序还必须仅使用这些定义，通过显式测试用例来验证以下基本性质：\n\n- 循环卷积定理：对于长度为 $N$ 的序列 $a$ 和 $b$，其长度为 $N$ 的循环卷积 $c$（定义为 $c_n = \\sum_{m=0}^{N-1} a_m \\, b_{(n-m) \\bmod N}$）满足 $C_k = A_k B_k$，其中 $A$、$B$ 和 $C$ 分别是 $a$、$b$ 和 $c$ 的 DFT。\n- Parseval 恒等式（使用上述归一化）：$\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$。\n\n您的程序必须实现自己的快速算法来计算 $N = 2^m$ 情况下的 DFT 和 IDFT，并且必须包含一个直接的 $\\mathcal{O}(N^2)$ DFT 用于验证。在需要进行布尔值验证的地方，使用数值公差 $\\varepsilon = 10^{-9}$。所有角度都必须以弧度为单位进行解释。\n\n使用以下测试套件，并按下面给出的顺序生成输出：\n\n- 测试 1 (DFT 与直接 DFT 的正确性对比，正常路径)：设 $N = 8$ 且 $x = [0,1,2,3,4,3,2,1]$。使用您的快速实现计算 $X$，并使用直接 DFT 计算 $\\tilde{X}$。如果 $\\max_k |X_k - \\tilde{X}_k| \\le \\varepsilon$，则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 2 (逆变换恢复)：使用与测试 1 相同的 $N$ 和 $x$，通过将您的快速实现得到的 $X$ 应用于您的 IDFT 来计算 $x'$。如果 $\\max_n |x'_n - x_n| \\le \\varepsilon$，则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 3 (通过频域的循环卷积)：设 $N = 8$，$a = [1,2,3,0,0,0,0,0]$，$b = [0,1,0,0,0,0,0,0]$。直接根据定义计算长度为 $N$ 的循环卷积 $c$。另外，通过对 $a$ 和 $b$ 进行 DFT、逐点相乘并应用 IDFT 来计算 $\\hat{c}$。以浮点数形式输出标量 $\\max_n |c_n - \\hat{c}_n|$。\n- 测试 4 (Parseval 恒等式)：设 $N = 16$ 且 $x_n = \\sin\\!\\left( \\frac{2\\pi \\cdot 3 \\, n}{N} \\right) + \\frac{1}{2} \\cos\\!\\left( \\frac{2\\pi \\cdot 5 \\, n}{N} \\right)$，其中 $n = 0,1,\\dots,15$。通过您的快速实现计算 $X$。以浮点数形式输出标量 $\\left| \\sum_{n=0}^{N-1} |x_n|^2 - \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2 \\right|$。\n- 测试 5 (边界情况 $N=1$)：设 $N = 1$ 且 $x = [3 + 4i]$。计算 $X$，然后通过 IDFT 计算 $x'$。如果 $|x'_0 - x_0| \\le \\varepsilon$，则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 6 (最小非平凡尺寸 $N=2$)：设 $N = 2$ 且 $x = [1,-1]$。通过您的快速实现计算 $X$。在给定约定下，精确的 DFT 结果为 $[0,2]$。以浮点数形式输出标量 $\\max_k |X_k - [0,2]_k|$。\n\n最终输出格式：您的程序应生成单行输出，其中按顺序包含六个结果，格式为逗号分隔的列表，并用方括号括起来，例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$。所有布尔条目必须是 $\\text{True}$ 或 $\\text{False}$，所有实值条目必须以标准十进制或科学记数法打印。不应打印任何其他文本。", "solution": "所提出的问题是计算物理领域，特别是信号处理方面一个定义明确且科学严谨的练习。它要求实现和验证离散傅里叶变换（DFT）、其逆变换（IDFT）以及相关的基本定理。该问题是完整的、客观的，并且其解决方案是可验证的。我们将继续进行解答。\n\n问题的核心是为给定的长度为 $N$ 的离散复值序列 $x = \\{x_n\\}_{n=0}^{N-1}$ 计算其 DFT $X$。定义如下：\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1.\n$$\n该公式的直接实现涉及两个嵌套循环，一个循环遍历从 $0$ 到 $N-1$ 的每个索引 $k$，另一个循环遍历从 $0$ 到 $N-1$ 的每个索引 $n$。这导致计算复杂度为 $\\mathcal{O}(N^2)$，对于大的 $N$ 来说效率低下。为了验证的目的，我们将实现这样一个直接方法。\n\n问题规定 $N$ 是 2 的幂，即 $N = 2^m$，其中 $m$ 是非负整数。这种结构是采用快速傅里叶变换（FFT）算法的关键，特别是 Cooley-Tukey 时域抽取算法。该算法将复杂度从 $\\mathcal{O}(N^2)$ 降低到 $\\mathcal{O}(N \\log N)$。其原理是分治法。\n\n将序列 $x_n$ 分解为其偶数索引元素，形成一个序列 $x'_m = x_{2m}$，以及其奇数索引元素，形成一个序列 $x''_m = x_{2m+1}$，每个序列的长度均为 $N/2$。DFT 求和可以重写为：\n$$\nX_k = \\sum_{m=0}^{N/2-1} x_{2m} e^{-2\\pi i k (2m) / N} + \\sum_{m=0}^{N/2-1} x_{2m+1} e^{-2\\pi i k (2m+1) / N}\n$$\n$$\nX_k = \\sum_{m=0}^{N/2-1} x'_m e^{-2\\pi i k m / (N/2)} + e^{-2\\pi i k/N} \\sum_{m=0}^{N/2-1} x''_m e^{-2\\pi i k m / (N/2)}\n$$\n设 $X'_k$ 和 $X''_k$ 分别是 $x'_m$ 和 $x''_m$ 的长度为 $(N/2)$ 的 DFT。上述表达式变为：\n$$\nX_k = X'_{k \\bmod (N/2)} + W_N^k X''_{k \\bmod (N/2)}\n$$\n其中 $W_N^k = e^{-2\\pi i k/N}$ 是“旋转因子”。对于索引的前半部分，$0 \\le k < N/2$，我们有：\n$$\nX_k = X'_k + W_N^k X''_k\n$$\n对于后半部分，其中索引为 $k+N/2$（$0 \\le k < N/2$），我们使用性质 $X'_{k+N/2} = X'_k$、$X''_{k+N/2} = X''_k$ 和 $W_N^{k+N/2} = -W_N^k$。这得到：\n$$\nX_{k+N/2} = X'_k - W_N^k X''_k\n$$\n这个递归定义允许构建完整的 DFT。递归在基例 $N=1$ 处终止，此时序列 $\\{x_0\\}$ 的 DFT 就是 $\\{X_0\\} = \\{x_0\\}$。我们的实现将遵循这种递归结构。\n\n逆离散傅里叶变换 (IDFT) 定义为：\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi i \\, k n / N}\n$$\n没有必要单独实现。我们可以将 IDFT 与正向 DFT 联系起来。观察以下推导：\n$$\nN \\cdot \\overline{x_n} = \\overline{\\sum_{k=0}^{N-1} X_k e^{+2\\pi i k n / N}} = \\sum_{k=0}^{N-1} \\overline{X_k} e^{-2\\pi i k n / N}\n$$\n右侧是复共轭序列 $\\{\\overline{X_k}\\}_{k=0}^{N-1}$ 的 DFT。因此，我们可以通过计算 $\\overline{X}$ 的 DFT，对结果取复共轭，然后按 $1/N$ 进行缩放来求得 $x_n$。也就是说，$x = \\frac{1}{N} \\overline{\\text{DFT}(\\overline{X})}$。这也使得我们可以使用我们高效的 FFT 实现来计算逆变换 (IFFT)。\n\n问题进一步要求验证两个基本定理。\n\n首先，循环卷积定理。两个长度为 $N$ 的序列 $a$ 和 $b$ 的循环卷积 $c$ 由 $c_n = \\sum_{m=0}^{N-1} a_m b_{(n-m) \\bmod N}$ 给出。该定理指出，卷积的 DFT 是各个 DFT 的逐点乘积：$C_k = A_k B_k$。因此，可以通过频域计算 $c$：$c = \\text{IDFT}(\\text{DFT}(a) \\odot \\text{DFT}(b))$，其中 $\\odot$ 表示逐元素乘法。我们将通过直接计算 $c$ 和通过频域路径计算 $c$ 并比较结果来测试这一点。\n\n其次是 Parseval 恒等式。对于给定的 DFT 归一化，该恒等式为：\n$$\n\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2\n$$\n该定理将信号在时域中的总能量与其在频域中的能量联系起来。我们将针对一个特定的测试信号来验证这一点。\n\n程序将首先定义必要的函数：一个直接的 $\\mathcal{O}(N^2)$ DFT、一个递归的 $\\mathcal{O}(N \\log N)$ FFT、一个基于 FFT 的 IFFT，以及一个直接的循环卷积函数。然后，它将使用这些函数和一个数值公差 $\\varepsilon = 10^{-9}$ 来执行 6 个指定的测试用例以进行比较。结果将被收集并以要求的格式打印。", "answer": "```python\nimport numpy as np\n\ndef direct_dft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the direct O(N^2) method.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n    n = np.arange(N)\n    k = n.reshape((N, 1))\n    W = np.exp(-2j * np.pi * k * n / N)\n    X = np.dot(W, x)\n    return X\n\ndef fft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the recursive\n    Cooley-Tukey FFT algorithm. Assumes N is a power of 2.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n\n    if N = 1:\n        return x\n\n    # Decimate: split into even and odd subsequences\n    x_even = fft(x[0::2])\n    x_odd = fft(x[1::2])\n\n    # Combine\n    k = np.arange(N // 2)\n    twiddle_factors = np.exp(-2j * np.pi * k / N)\n    \n    X = np.concatenate([x_even + twiddle_factors * x_odd,\n                          x_even - twiddle_factors * x_odd])\n    return X\n\ndef ifft(X):\n    \"\"\"\n    Computes the Inverse Discrete Fourier Transform using the forward FFT algorithm.\n    \"\"\"\n    X = np.asarray(X, dtype=complex)\n    N = X.shape[0]\n    \n    # Use the property: IDFT(X) = (1/N) * conj(DFT(conj(X)))\n    x = np.conjugate(fft(np.conjugate(X))) / N\n    return x\n\ndef circular_conv(a, b):\n    \"\"\"\n    Computes the circular convolution of two sequences a and b directly.\n    \"\"\"\n    a = np.asarray(a, dtype=complex)\n    b = np.asarray(b, dtype=complex)\n    N = len(a)\n    c = np.zeros(N, dtype=complex)\n    for n in range(N):\n        for m in range(N):\n            c[n] += a[m] * b[(n - m) % N]\n    return c\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the formatted results.\n    \"\"\"\n    epsilon = 1e-9\n    results = []\n\n    # Test 1: DFT correctness versus direct DFT\n    N1 = 8\n    x1 = np.array([0, 1, 2, 3, 4, 3, 2, 1], dtype=float)\n    X_fast = fft(x1)\n    X_direct = direct_dft(x1)\n    err1 = np.max(np.abs(X_fast - X_direct))\n    results.append(err1 = epsilon)\n\n    # Test 2: Inverse transform recovery\n    x_prime = ifft(X_fast)\n    err2 = np.max(np.abs(x_prime - x1))\n    results.append(err2 = epsilon)\n\n    # Test 3: Circular convolution via frequency domain\n    N3 = 8\n    a3 = np.array([1, 2, 3, 0, 0, 0, 0, 0], dtype=float)\n    b3 = np.array([0, 1, 0, 0, 0, 0, 0, 0], dtype=float)\n    c_direct = circular_conv(a3, b3)\n    A3 = fft(a3)\n    B3 = fft(b3)\n    C_freq = A3 * B3\n    c_hat = ifft(C_freq)\n    err3 = np.max(np.abs(c_direct - c_hat))\n    results.append(err3)\n\n    # Test 4: Parseval identity\n    N4 = 16\n    n4 = np.arange(N4)\n    x4 = np.sin(2 * np.pi * 3 * n4 / N4) + 0.5 * np.cos(2 * np.pi * 5 * n4 / N4)\n    X4 = fft(x4)\n    sum_sq_x = np.sum(np.abs(x4)**2)\n    sum_sq_X_scaled = np.sum(np.abs(X4)**2) / N4\n    err4 = np.abs(sum_sq_x - sum_sq_X_scaled)\n    results.append(err4)\n\n    # Test 5: Edge case N=1\n    x5 = np.array([3 + 4j])\n    X5 = fft(x5)\n    x5_prime = ifft(X5)\n    err5 = np.abs(x5_prime[0] - x5[0])\n    results.append(err5 = epsilon)\n\n    # Test 6: Smallest nontrivial size N=2\n    x6 = np.array([1, -1], dtype=float)\n    X6 = fft(x6)\n    X_exact = np.array([0, 2], dtype=complex)\n    err6 = np.max(np.abs(X6 - X_exact))\n    results.append(err6)\n\n    # Format and print final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2387187"}, {"introduction": "在理论世界中，信号频率可以完美地落在离散傅里叶变换（DFT）的某个频率“仓”上，但在实际应用中，这种情况极为罕见。本练习旨在揭示当信号频率落在两个频率仓之间时会发生什么，这种现象通常被称为“栅栏效应”。通过理论推导和数值模拟，你将探索并量化由此产生的“谱泄漏”和“扇形损失”，这是准确解读任何频谱分析结果的关键一步。[@problem_id:2443816]", "problem": "考虑一个离散时间复正弦波及其在矩形时间窗下的离散傅里叶变换 (DFT)。使用以下基本依据：(i) DFT作为样本有限和的定义，以及(ii) 用于复指数求和的几何级数恒等式。定义采样信号为 $x[n] = A \\exp\\left(j \\left(2\\pi \\frac{f_0}{F_s} n + \\varphi\\right)\\right)$，其中 $n$ 为整数且 $0 \\le n \\le N-1$，幅度 $A  0$，采样频率 $F_s$ 单位为赫兹，相位 $\\varphi$ 单位为弧度。DFT 索引集为 $k \\in \\{0,1,\\dots,N-1\\}$，对应的 DFT 频率仓中心频率为 $f_k = \\frac{k}{N} F_s$。DFT 定义为 $X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j 2\\pi \\frac{k}{N} n\\right)$。快速傅里叶变换 (FFT) 是一种能以更少的算术运算精确计算此 DFT 的算法。角度必须以弧度为单位。\n\n你的任务是：\n1) 从 DFT 定义和几何级数求和出发，推导当正弦波频率 $f_0$ 不落在 DFT 频率仓上时，矩形窗复正弦波的 DFT 幅度 $|X[k]|$ 的表达式。将你的结果特化到 $f_0$ 恰好在两个相邻频率仓正中间的情况，即对于某个整数 $k_0$，有 $f_0 = \\left(k_0 + \\frac{1}{2}\\right)\\frac{F_s}{N}$。由此，推导“扇形比”$\\rho_{\\mathrm{theory}}$ 的闭式表达式，该比率定义为：在此半频率仓偏移下，最大的 DFT 频率仓幅度 $|X[k]|$ 与当 $f_0$ 恰好为 $f_{k_0}$ 时会出现的仓上幅度 $|X[k_0]|$ 之比。将 $\\rho_{\\mathrm{theory}}$ 表示为仅含 $N$ 的函数。\n2) 实现一个程序，对下述每个指定的测试用例，构建 $f_0$ 恰好在频率仓 $k_0$ 和 $k_0+1$ 正中间的信号 $x[n]$，使用直接 $O(N^2)$ 求和与快速傅里叶变换两种方法计算 DFT，并评估：\n   a) 测量的扇形比 $\\rho_{\\mathrm{meas}} = \\frac{\\max_k |X[k]|}{A N}$，\n   b) 绝对误差 $|\\rho_{\\mathrm{meas}} - \\rho_{\\mathrm{theory}}|$，\n   c) 双仓对称误差，定义为 $\\left|\\frac{|X[k_0]|}{|X[k_0+1]|} - 1\\right|$，以及\n   d) 直接 DFT 和 FFT 之间的无穷范数差，并用 $A N$ 进行归一化，即 $\\frac{\\max_k |X_{\\mathrm{direct}}[k] - X_{\\mathrm{FFT}}[k]|}{A N}$。\n你必须使用两种方法计算 DFT，并报告所要求的标量值。\n\n科学真实性要求：你对 $\\rho_{\\mathrm{theory}}$ 的推导必须从 DFT 定义和有限几何级数恒等式开始。在未展示如何从这些基础推导出来之前，不得引用任何专门的窗函数变换“结果”。所有角度必须以弧度为单位。输出中不出现其他物理单位。所有输出均为无量纲实数。\n\n测试套件：使用以下四组参数集 $(N, F_s, k_0, A, \\varphi)$：\n- 情况 1：$(N=\\,$$64$$,\\, F_s=\\,$$8000$$,\\, k_0=\\,$$10$$,\\, A=\\,$$1.0$$,\\, \\varphi=\\,$$0.3$$)$\n- 情况 2：$(N=\\,$$63$$,\\, F_s=\\,$$1000$$,\\, k_0=\\,$$7$$,\\, A=\\,$$2.0$$,\\, \\varphi=\\,$$1.2$$)$\n- 情况 3：$(N=\\,$$8$$,\\, F_s=\\,$$128$$,\\, k_0=\\,$$0$$,\\, A=\\,$$0.5$$,\\, \\varphi=\\,$$0.0$$)$\n- 情况 4：$(N=\\,$$1024$$,\\, F_s=\\,$$44100$$,\\, k_0=\\,$$123$$,\\, A=\\,$$1.0$$,\\, \\varphi=\\,$$2.3$$)$\n\n对于每种情况，构建 $f_0 = \\left(k_0 + \\frac{1}{2}\\right)\\frac{F_s}{N}$，生成 $0 \\le n \\le N-1$ 的 $x[n]$，并通过两种方法计算 $X[k]$。\n\n最终输出格式：你的程序应生成单行输出，其中包含一个扁平的、逗号分隔的列表，该列表汇集了四个用例的结果，并用方括号括起来。对于按上述顺序列出的每个用例，按此顺序附加三个标量：绝对扇形比误差 $|\\rho_{\\mathrm{meas}} - \\rho_{\\mathrm{theory}}|$、双仓对称误差 $\\left|\\frac{|X[k_0]|}{|X[k_0+1]|} - 1\\right|$，以及归一化的 DFT 与 FFT 的无穷范数差 $\\frac{\\max_k |X_{\\mathrm{direct}}[k] - X_{\\mathrm{FFT}}[k]|}{A N}$。因此，程序必须打印一个包含 12 个浮点数的单一列表。", "solution": "问题陈述已经过严格验证，并被认为是可靠的。它在科学上基于数字信号处理的原理，其定义和目标清晰，问题适定，且没有任何歧义或矛盾。因此，我们可以着手进行正式求解。\n\n按照要求，解法分为两部分：首先，对扇形比进行理论推导；其次，解释用于验证该理论并计算相关误差度量的数值实现。\n\n**第一部分：理论扇形比 $\\rho_{\\mathrm{theory}}$ 的推导**\n\n推导从离散傅里叶变换 (DFT) 的定义开始。信号是在有限区间上采样的复正弦波，这构成了一个隐式的矩形窗。\n\n离散时间信号定义为 $x[n] = A \\exp\\left(j \\left(2\\pi \\frac{f_0}{F_s} n + \\varphi\\right)\\right)$，其中 $n \\in \\{0, 1, \\dots, N-1\\}$。\nDFT, $X[k]$, 定义为：\n$$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j 2\\pi \\frac{kn}{N}\\right)$$\n代入 $x[n]$ 的表达式：\n$$X[k] = \\sum_{n=0}^{N-1} A e^{j\\varphi} \\exp\\left(j 2\\pi \\frac{f_0}{F_s} n\\right) \\exp\\left(-j 2\\pi \\frac{kn}{N}\\right)$$\n我们可以将常数项 $A e^{j\\varphi}$ 提出来，并合并指数项：\n$$X[k] = A e^{j\\varphi} \\sum_{n=0}^{N-1} \\left[\\exp\\left(j 2\\pi \\left(\\frac{f_0}{F_s} - \\frac{k}{N}\\right)\\right)\\right]^n$$\n这是一个形式为 $\\sum_{n=0}^{N-1} r^n$ 的有限几何级数，其中公比为 $r = \\exp\\left(j 2\\pi \\left(\\frac{f_0}{F_s} - \\frac{k}{N}\\right)\\right)$。使用几何级数求和恒等式 $\\sum_{n=0}^{N-1} r^n = \\frac{1-r^N}{1-r}$（此式在 $r \\neq 1$ 时成立）：\n$$X[k] = A e^{j\\varphi} \\frac{1 - \\exp\\left(j 2\\pi \\left(\\frac{f_0}{F_s} - \\frac{k}{N}\\right) N\\right)}{1 - \\exp\\left(j 2\\pi \\left(\\frac{f_0}{F_s} - \\frac{k}{N}\\right)\\right)} = A e^{j\\varphi} \\frac{1 - \\exp\\left(j 2\\pi \\left(\\frac{Nf_0}{F_s} - k\\right)\\right)}{1 - \\exp\\left(j \\frac{2\\pi}{N} \\left(\\frac{Nf_0}{F_s} - k\\right)\\right)}$$\n为了求幅度 $|X[k]|$，我们使用恒等式 $|1 - e^{j\\theta}| = |e^{j\\theta/2}(e^{-j\\theta/2} - e^{j\\theta/2})| = |-2j e^{j\\theta/2}\\sin(\\theta/2)| = 2|\\sin(\\theta/2)|$。将此应用于分子和分母：\n$$|X[k]| = |A e^{j\\varphi}| \\left|\\frac{2\\sin\\left(\\pi \\left(\\frac{Nf_0}{F_s} - k\\right)\\right)}{2\\sin\\left(\\frac{\\pi}{N} \\left(\\frac{Nf_0}{F_s} - k\\right)\\right)}\\right| = A \\left| \\frac{\\sin\\left(\\pi \\left(\\frac{Nf_0}{F_s} - k\\right)\\right)}{\\sin\\left(\\frac{\\pi}{N} \\left(\\frac{Nf_0}{F_s} - k\\right)\\right)} \\right|$$\n这是幅度谱的一般表达式。现在，我们将其特化到频率 $f_0$ 恰好在两个相邻 DFT 频率仓 $k_0$ 和 $k_0+1$ 正中间的情况：$f_0 = \\left(k_0 + \\frac{1}{2}\\right)\\frac{F_s}{N}$。\n项 $\\frac{Nf_0}{F_s} - k$ 变为 $k_0 + \\frac{1}{2} - k$。\n分子中 sine 函数的自变量是 $\\pi \\left(k_0 - k + \\frac{1}{2}\\right)$。由于 $k_0-k$ 是一个整数，设它为 $m$。则该自变量为 $m\\pi + \\frac{\\pi}{2}$。这个角度的正弦值为 $\\sin(m\\pi + \\frac{\\pi}{2}) = \\cos(m\\pi) = (-1)^m$。因此，其幅度始终为 1。\n幅度表达式简化为：\n$$|X[k]| = \\frac{A}{\\left|\\sin\\left(\\frac{\\pi}{N} \\left(k_0 - k + \\frac{1}{2}\\right)\\right)\\right|}$$\n扇形比 $\\rho_{\\mathrm{theory}}$ 比较的是此半频率仓偏移下的最大 DFT 幅度与仓上幅度。仓上幅度是指当信号频率恰好落在一个频率仓上时的 $|X[k_0]|$ 值，即 $f_0 = f_{k_0} = k_0\\frac{F_s}{N}$。在这种仓上情况下，对于 $k=k_0$，公比 $r$ 变为 1，几何级数和的值为 $N$。此时 DFT 为 $X[k_0] = A e^{j\\varphi} N$，因此参考幅度为 $|X[k_0]|_{\\mathrm{on-bin}} = AN$。\n\n对于半频率仓的情况，最大幅度 $\\max_k |X[k]|$ 出现在分母 $\\left|\\sin\\left(\\frac{\\pi}{N} \\left(k_0 - k + \\frac{1}{2}\\right)\\right)\\right|$ 最小时。这发生在自变量最接近 0 时。对于 $k = k_0$ 和 $k = k_0+1$ 时出现这种情况。\n当 $k=k_0$ 时，自变量为 $\\frac{\\pi}{2N}$。\n当 $k=k_0+1$ 时，自变量为 $-\\frac{\\pi}{2N}$。\n在这两种情况下，分母的幅度均为 $\\sin\\left(\\frac{\\pi}{2N}\\right)$（假设 $N \\ge 2$，因此自变量在 $(0, \\pi/2)$ 区间内）。\n因此，最大的 DFT 频率仓幅度为 $\\max_k |X[k]| = \\frac{A}{\\sin\\left(\\frac{\\pi}{2N}\\right)}$。\n\n最后，理论扇形比是这两个幅度的比值：\n$$\\rho_{\\mathrm{theory}} = \\frac{\\max_k |X[k]|_{\\mathrm{half-bin}}}{|X[k_0]|_{\\mathrm{on-bin}}} = \\frac{A / \\sin\\left(\\frac{\\pi}{2N}\\right)}{AN} = \\frac{1}{N \\sin\\left(\\frac{\\pi}{2N}\\right)}$$\n这是所要求的 $\\rho_{\\mathrm{theory}}$ 作为仅含 $N$ 的函数的闭式表达式。对于大的 $N$，使用小 $x$ 的近似 $\\sin(x) \\approx x$，我们得到 $\\rho_{\\mathrm{theory}} \\approx \\frac{1}{N(\\pi/2N)} = \\frac{2}{\\pi} \\approx 0.6366$，这是矩形窗经典的扇形损失数值。\n\n**第二部分：数值实现**\n\n所提供的程序为四个测试用例实现了问题陈述中指定的计算。\n对于每个用例 $(N, F_s, k_0, A, \\varphi)$：\n1. 信号频率 $f_0$ 被设置为 $f_0 = (k_0 + 0.5) \\frac{F_s}{N}$。\n2. 生成 $n \\in \\{0, 1, \\dots, N-1\\}$ 的复值信号 $x[n]$。\n3. 使用两种方法计算 DFT：\n    a) 复杂度为 $O(N^2)$ 的直接求和，通过矩阵-向量积 $X_{\\mathrm{direct}} = \\mathbf{W}x$ 实现，其中 $\\mathbf{W}$ 是 $N \\times N$ 的 DFT 矩阵，其元素为 $W_{kn} = \\exp(-j2\\pi kn/N)$。\n    b) 快速傅里叶变换 (FFT) 算法，使用 `numpy.fft.fft`，它以 $O(N \\log N)$ 的复杂度计算相同的 DFT。\n4. 计算以下量：\n    a) 测量的扇形比 $\\rho_{\\mathrm{meas}} = \\frac{\\max_k |X_{\\mathrm{FFT}}[k]|}{AN}$。我们使用 FFT 的结果，因为它是标准的计算工具。\n    b) 绝对误差 $|\\rho_{\\mathrm{meas}} - \\rho_{\\mathrm{theory}}|$，它量化了我们推导的理论与数值计算之间的一致性。这个值应该接近机器精度。\n    c) 双仓对称误差 $\\left|\\frac{|X_{\\mathrm{FFT}}[k_0]|}{|X_{\\mathrm{FFT}}[k_0+1]|} - 1\\right|$。我们的推导表明这两个幅度应该是相同的，所以这个误差衡量了计算出的频谱的数值对称性。\n    d) 归一化的无穷范数差 $\\frac{\\max_k |X_{\\mathrm{direct}}[k] - X_{\\mathrm{FFT}}[k]|}{A N}$。该度量量化了两种 DFT 计算方法之间的数值差异，这种差异源于不同的浮点运算顺序以及由此产生的舍入误差累积。\n\n程序随后将四个测试用例的这三个标量误差度量汇集成一个包含 12 个值的单一扁平列表作为最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DFT scalloping loss problem for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (N, Fs, k0, A, phi)\n    test_cases = [\n        (64, 8000.0, 10, 1.0, 0.3),\n        (63, 1000.0, 7, 2.0, 1.2),\n        (8, 128.0, 0, 0.5, 0.0),\n        (1024, 44100.0, 123, 1.0, 2.3),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N, Fs, k0, A, phi = case\n\n        # 1. Construct signal\n        # Frequency is exactly halfway between bin k0 and k0+1\n        f0 = (k0 + 0.5) * Fs / N\n        n = np.arange(N)\n        # Complex sinusoid signal x[n]\n        x_n = A * np.exp(1j * (2 * np.pi * f0 / Fs * n + phi))\n\n        # 2. Compute DFT via direct O(N^2) summation\n        # Create the DFT matrix W\n        k = np.arange(N)\n        k_n_prod = np.outer(k, n)\n        W_matrix = np.exp(-1j * 2 * np.pi * k_n_prod / N)\n        # Compute DFT as a matrix-vector product\n        X_direct = W_matrix @ x_n\n\n        # 3. Compute DFT via FFT\n        X_fft = np.fft.fft(x_n)\n\n        # 4. Calculate the required metrics\n        \n        # a) Scalloping ratio error\n        # Theoretical scalloping ratio\n        # The argument of sin is small, so guard against N=0 (not in tests)\n        if N > 0:\n            rho_theory = 1.0 / (N * np.sin(np.pi / (2.0 * N)))\n        else:\n            rho_theory = 1.0 # Trivial case\n            \n        # Measured scalloping ratio using FFT results\n        max_mag_X_fft = np.max(np.abs(X_fft))\n        rho_meas = max_mag_X_fft / (A * N)\n        \n        # Absolute scalloping-ratio error\n        scalloping_ratio_error = np.abs(rho_meas - rho_theory)\n\n        # b) Two-bin symmetry error\n        # Magnitudes at bin k0 and k0+1 should be equal\n        mag_X_k0 = np.abs(X_fft[k0])\n        # The DFT is periodic, k0+1 is safe as k0  N-1 in all test cases.\n        mag_X_k0_plus_1 = np.abs(X_fft[k0 + 1])\n        \n        if mag_X_k0_plus_1 == 0:\n            # Avoid division by zero, though not expected here\n            symmetry_error = np.inf if mag_X_k0 != 0 else 0\n        else:\n            symmetry_error = np.abs(mag_X_k0 / mag_X_k0_plus_1 - 1.0)\n            \n        # c) Normalized difference between direct DFT and FFT\n        # Infinity norm of the difference vector\n        norm_inf_diff = np.max(np.abs(X_direct - X_fft)) / (A * N)\n        \n        # Append results for the current case\n        results.extend([scalloping_ratio_error, symmetry_error, norm_inf_diff])\n\n    # Final print statement in the exact required format.\n    # The format specifier ensures standard floating point representation.\n    print(f\"[{','.join(f'{r:.17e}' for r in results)}]\")\n\nsolve()\n```", "id": "2443816"}, {"introduction": "傅里叶变换不仅能分析信号，还能通过其逆变换从频率分量合成信号。然而，当我们使用有限数量的正弦波来重构一个包含不连续点（如方波的跳变）的信号时，会出现一种特殊的振荡现象。这个练习将让你通过编程直观地观察和量化著名的吉布斯现象——在不连续点附近出现的“过冲”和“下冲”，即使增加谐波分量，这些过冲也不会消失。[@problem_id:2443812]", "problem": "考虑一个离散时间、实值的周期性方波，其一个周期由长度为 $N$ 的序列 $s[n]$ 表示，其中 $n \\in \\{0,1,\\dots,N-1\\}$ 且 $N$ 为偶数。该序列定义如下：\n$$\ns[n] =\n\\begin{cases}\n+1,  0 \\le n  N/2,\\\\\n-1,  N/2 \\le n  N.\n\\end{cases}\n$$\n令 $X[k]$ 表示 $s[n]$ 的离散傅里叶变换 (DFT)，对 $k \\in \\{0,1,\\dots,N-1\\}$ 定义为：\n$$\nX[k] = \\sum_{n=0}^{N-1} s[n] \\, e^{-i 2\\pi nk/N},\n$$\n令逆离散傅里叶变换 (IDFT) 由下式给出：\n$$\nx[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\, e^{i 2\\pi nk/N}.\n$$\n所有角度均以弧度为单位。对于一个整数带宽参数 $K$（满足 $0 \\le K \\le \\left\\lfloor \\frac{N}{2} \\right\\rfloor - 1$），定义索引集\n$$\n\\mathcal{S}_K = \\{0\\} \\cup \\{1,2,\\dots,K\\} \\cup \\{N-K, N-K+1, \\dots, N-1\\},\n$$\n以及截断频谱重构\n$$\nx_K[n] = \\frac{1}{N} \\sum_{k \\in \\mathcal{S}_K} X[k] \\, e^{i 2\\pi nk/N}.\n$$\n令 $M_K = \\max_{0 \\le n \\le N-1} x_K[n]$ 且 $m_K = \\min_{0 \\le n \\le N-1} x_K[n]$。设高平台 $A_{\\text{high}} = +1$，低平台 $A_{\\text{low}} = -1$，跳变幅度 $J = A_{\\text{high}} - A_{\\text{low}} = 2$，定义归一化吉布斯偏差\n$$\nG_K = \\max\\left( \\frac{\\max(0, M_K - A_{\\text{high}})}{J}, \\; \\frac{\\max(0, A_{\\text{low}} - m_K)}{J} \\right).\n$$\n量 $G_K$ 捕捉了在整个重构序列 $x_K[n]$ 中，超出高平台 $A_{\\text{high}}$ 的归一化过冲和低于低平台 $A_{\\text{low}}$ 的归一化下冲的最大值。对于足够大且不太接近奈奎斯特极限的 $K$，对于此方波跳变，$G_K$ 应趋近于著名的吉布斯常数，约 $0.08949$。\n\n你的任务是编写一个完整的程序，对下面指定的每个测试用例，构建 $s[n]$、计算 $X[k]$、根据截断频谱生成 $x_K[n]$、评估 $G_K$ 并输出结果。\n\n测试集（每个测试用例是一个序对 $(N,K)$）：\n- 用例 1：$(4096, 0)$。\n- 用例 2：$(4096, 1)$。\n- 用例 3：$(4096, 3)$。\n- 用例 4：$(4096, 7)$。\n- 用例 5：$(4096, 15)$。\n- 用例 6：$(4096, 63)$。\n- 用例 7：$(4096, 255)$。\n- 用例 8：$(64, 31)$。\n\n对每个用例，计算 $G_K$ 作为一个浮点数，并四舍五入到 $6$ 位小数。\n\n最终输出格式：你的程序应生成单行输出，其中包含八个四舍五入后的值，按上述测试用例的顺序以逗号分隔列表的形式呈现，并用方括号括起来。例如，一个有效的输出格式是 [$0.123456$,$0.234567$,$0.345678$,$0.456789$,$0.567890$,$0.678901$,$0.789012$,$0.890123$]。", "solution": "问题陈述已经过严格验证，并被确定为有效。它在科学上基于傅里叶分析的原理，在数学上是适定的，并且是客观指定的。该问题是自洽的，为得到唯一且可验证的解提供了所有必要的定义、常数和参数。因此，我们将着手进行推导和计算。\n\n目标是为一个周期性方波的截断傅里叶级数重构计算归一化吉布斯偏差 $G_K$。该过程涉及几个不同的步骤，将对每个给定的测试用例 $(N, K)$ 执行这些步骤。\n\n步骤 1：信号生成\n首先，我们为给定的长度 $N$（指定为偶数）构建离散时间信号 $s[n]$。该信号代表方波的一个周期。其定义如下：\n$$\ns[n] =\n\\begin{cases}\n+1,  0 \\le n  N/2,\\\\\n-1,  N/2 \\le n  N.\n\\end{cases}\n$$\n该序列是实值的，长度为 $N$ 个样本，索引从 $n=0$ 到 $n=N-1$。\n\n步骤 2：离散傅里叶变换 (DFT)\n接下来，我们计算信号 $s[n]$ 的 DFT 以获得其频域表示 $X[k]$。DFT 定义为：\n$$\nX[k] = \\sum_{n=0}^{N-1} s[n] \\, e^{-i 2\\pi nk/N}\n$$\n对于 $k \\in \\{0, 1, \\dots, N-1\\}$。为了计算效率，此变换将使用快速傅里叶变换 (FFT) 算法实现，这是合适的，因为测试集中的 $N$ 值是 2 的幂。\n\n步骤 3：频谱截断\n根据整数带宽参数 $K$ 创建频谱的截断版本。通过保留集合 $\\mathcal{S}_K$ 内索引 $k$ 对应的 $X[k]$ 系数，并将所有其他系数设置为零，形成一个新的频谱序列，我们可以将其表示为 $X_K[k]$。索引集 $\\mathcal{S}_K$ 定义为：\n$$\n\\mathcal{S}_K = \\{0\\} \\cup \\{1,2,\\dots,K\\} \\cup \\{N-K, N-K+1, \\dots, N-1\\}\n$$\n该集合包括直流分量 ($k=0$)、前 $K$ 个正频率分量 ($k=1, \\dots, K$) 以及对应的 $K$ 个负频率分量 ($k=N-K, \\dots, N-1$)，这对于确保重构信号是实值的是必要的。因此，$X_K[k]$ 定义为：\n$$\nX_K[k] =\n\\begin{cases}\nX[k],  k \\in \\mathcal{S}_K,\\\\\n0,  k \\notin \\mathcal{S}_K.\n\\end{cases}\n$$\n\n步骤 4：信号重构\n截断信号 $x_K[n]$ 是通过计算截断频谱 $X_K[k]$ 的逆离散傅里叶变换 (IDFT) 来合成的。IDFT 公式为：\n$$\nx_K[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X_K[k] \\, e^{i 2\\pi nk/N}\n$$\n与正向变换类似，为了效率将使用逆快速傅里叶变换 (IFFT) 算法。由于原始信号 $s[n]$ 是实数，并且截断频谱 $X_K[k]$ 是以共轭对称（即 $X_K[k] = X_K[N-k]^*$）方式构造的，因此得到的信号 $x_K[n]$ 将是实值的，尽管由于浮点不精确性可能会出现微小的虚部，这些虚部应被舍弃。\n\n步骤 5：吉布斯偏差计算\n最后，我们通过计算归一化吉布斯偏差 $G_K$ 来量化吉布斯现象。这需要找到重构信号 $x_K[n]$ 在一个周期内的最大值和最小值：\n$$\nM_K = \\max_{0 \\le n \\le N-1} x_K[n]\n$$\n$$\nm_K = \\min_{0 \\le n \\le N-1} x_K[n]\n$$\n问题提供了高平台水平 $A_{\\text{high}} = +1$、低平台水平 $A_{\\text{low}} = -1$ 以及跳变幅度 $J = A_{\\text{high}} - A_{\\text{low}} = 2$。归一化吉布斯偏差 $G_K$ 是归一化过冲和下冲的最大值：\n$$\nG_K = \\max\\left( \\frac{\\max(0, M_K - A_{\\text{high}})}{J}, \\; \\frac{\\max(0, A_{\\text{low}} - m_K)}{J} \\right)\n$$\n代入给定值，上式变为：\n$$\nG_K = \\max\\left( \\frac{\\max(0, M_K - 1)}{2}, \\; \\frac{\\max(0, -1 - m_K)}{2} \\right)\n$$\n对测试集中指定的每个 $(N, K)$ 对执行此计算，并按要求将得到的 $G_K$ 值四舍五入到 $6$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the normalized Gibbs deviation G_K for a truncated Fourier series\n    reconstruction of a square wave for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement as (N, K) pairs.\n    test_cases = [\n        (4096, 0),\n        (4096, 1),\n        (4096, 3),\n        (4096, 7),\n        (4096, 15),\n        (4096, 63),\n        (4096, 255),\n        (64, 31),\n    ]\n\n    # Constants for Gibbs deviation calculation.\n    A_high = 1.0\n    A_low = -1.0\n    J = A_high - A_low  # Jump magnitude\n\n    results = []\n    for N, K in test_cases:\n        # Step 1: Construct the discrete-time square wave signal s[n].\n        # N is guaranteed to be even.\n        s_n = np.ones(N)\n        s_n[N // 2:] = -1.0\n\n        # Step 2: Compute the Discrete Fourier Transform (DFT) of s[n] using FFT.\n        X_k = np.fft.fft(s_n)\n\n        # Step 3: Truncate the spectrum based on the bandwidth parameter K.\n        # Create a new spectrum X_K_k initialized to zeros.\n        X_K_k = np.zeros_like(X_k, dtype=complex)\n\n        # The index set S_K is {0} U {1,...,K} U {N-K,...,N-1}.\n        # Copy the DC component (k=0).\n        if K >= 0:\n            X_K_k[0] = X_k[0]\n        \n        if K > 0:\n            # Copy positive frequency components (k=1,...,K).\n            X_K_k[1:K + 1] = X_k[1:K + 1]\n            # Copy negative frequency components (k=N-K,...,N-1).\n            X_K_k[N - K:] = X_k[N - K:]\n\n        # Step 4: Compute the truncated reconstruction x_K[n] using IFFT.\n        # np.fft.ifft includes the 1/N scaling factor.\n        # The result should be real due to conjugate symmetry, so we take the real part.\n        x_K_n = np.fft.ifft(X_K_k).real\n\n        # Step 5: Find the maximum and minimum values of the reconstructed signal.\n        M_K = np.max(x_K_n)\n        m_K = np.min(x_K_n)\n\n        # Step 6: Calculate the normalized Gibbs deviation G_K.\n        # It is the maximum of the normalized overshoot and undershoot.\n        overshoot_norm = max(0, M_K - A_high) / J\n        undershoot_norm = max(0, A_low - m_K) / J\n        G_K = max(overshoot_norm, undershoot_norm)\n        \n        # Round the result to 6 decimal places and append to the list.\n        results.append(round(G_K, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2443812"}]}