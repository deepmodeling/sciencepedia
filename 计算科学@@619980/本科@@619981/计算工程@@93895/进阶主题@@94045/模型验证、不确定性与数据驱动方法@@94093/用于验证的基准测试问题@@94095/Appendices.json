{"hands_on_practices": [{"introduction": "本节的实践始于一个计算仿真的基本构建模块：卷积运算。你将通过将其输出与一个已知的、涉及误差函数 $\\text{erf}(x)$ 的解析解进行比较，来验证一个数值卷积算法。这个练习将加深你对数值方法如何进行精度基准测试的理解，并揭示了数值误差的来源，例如离散化和域截断 [@problem_id:2373609]。", "problem": "为数字信号处理 (DSP) 中的一个基线卷积测试设计一个自包含的验证程序。考虑 Heaviside 阶跃函数 $H(t - t_0)$，其定义为当 $t  t_0$ 时 $H(t - t_0) = 0$，当 $t \\ge t_0$ 时 $H(t - t_0) = 1$；以及归一化高斯核 $g_{\\sigma}(t)$，其定义为\n$$\ng_{\\sigma}(t) = \\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\exp\\!\\left(-\\frac{t^2}{2\\sigma^2}\\right),\n$$\n其中 $\\sigma > 0$。令 $H$ 和 $g_{\\sigma}$ 的连续时间卷积对每个实数 $t$ 定义为\n$$\n(H * g_{\\sigma})(t) = \\int_{-\\infty}^{\\infty} H(\\tau - t_0)\\,g_{\\sigma}(t - \\tau)\\,d\\tau.\n$$\n仅使用上述定义和基本原理，确定 $(H * g_{\\sigma})(t)$ 以标准特殊函数表示的精确闭式表达式，并在一个均匀网格上计算其值。此外，使用积分的 Riemann 和近似，在同一网格上独立地计算该卷积的离散时间数值近似值。对于每个指定的测试用例，报告在域中所有网格点上，数值近似与精确表达式之间的最大绝对误差。\n\n网格规范：对于每个测试用例，一个均匀网格由实数 $T_{\\min}$、$T_{\\max}$ 和一个采样间隔 $\\Delta t > 0$ 定义，使得 $\\frac{T_{\\max} - T_{\\min}}{\\Delta t}$ 是一个整数。令 $N = 1 + \\frac{T_{\\max} - T_{\\min}}{\\Delta t}$ 且 $t_k = T_{\\min} + k\\,\\Delta t$，其中 $k \\in \\{0,1,\\dots,N-1\\}$。所有计算都应在集合 $\\{t_k\\}_{k=0}^{N-1}$ 上执行。\n\n你的程序必须为每个测试用例计算：\n- 从基本原理推导出的 $(H * g_{\\sigma})(t_k)$ 的精确值 $c_{\\text{exact}}(t_k)$，\n- 使用均匀网格 $\\{t_k\\}$ 上的 Riemann 和计算的卷积的数值近似值 $c_{\\text{num}}(t_k)$，\n- 以及最大绝对误差\n$$\nE = \\max_{0 \\le k \\le N-1} \\left| c_{\\text{num}}(t_k) - c_{\\text{exact}}(t_k) \\right|.\n$$\n\n测试套件（每个用例是一个元组 $(T_{\\min}, T_{\\max}, \\Delta t, \\sigma, t_0)$）：\n- 用例 1：$( -1.0,\\, 1.0,\\, 0.001,\\, 0.1,\\, 0.0 )$。\n- 用例 2：$( -1.0,\\, 1.0,\\, 0.001,\\, 0.1,\\, -0.9 )$。\n- 用例 3：$( -0.1,\\, 0.1,\\, 0.0002,\\, 0.005,\\, 0.02 )$。\n- 用例 4：$( -3.0,\\, 3.0,\\, 0.002,\\, 0.5,\\, 0.3 )$。\n\n答案格式：你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。对于每个测试用例，将 $E$ 的值以小数形式输出，并四舍五入到八位小数。例如，输出格式必须是\n$$\n[\\text{E\\_case1},\\text{E\\_case2},\\text{E\\_case3},\\text{E\\_case4}],\n$$\n其中每个 $\\text{E\\_casei}$ 都四舍五入到八位小数。此问题不涉及物理单位或角度，因此无需进行单位转换。", "solution": "用户提供了一个需要严格验证的问题。\n\n### 步骤 1：提取已知条件\n- **Heaviside 阶跃函数：** $H(t - t_0)$ 定义为当 $t  t_0$ 时为 $0$，当 $t \\ge t_0$ 时为 $1$。\n- **归一化高斯核：** $g_{\\sigma}(t) = \\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\exp(-\\frac{t^2}{2\\sigma^2})$，其中 $\\sigma > 0$。\n- **连续卷积：** $(H * g_{\\sigma})(t) = \\int_{-\\infty}^{\\infty} H(\\tau - t_0)\\,g_{\\sigma}(t - \\tau)\\,d\\tau$。\n- **网格规范：** 一个均匀网格 $\\{t_k\\}_{k=0}^{N-1}$，其中 $t_k = T_{\\min} + k\\,\\Delta t$ 且 $N = 1 + \\frac{T_{\\max} - T_{\\min}}{\\Delta t}$。\n- **数值近似：** 在指定网格上对卷积积分的 Riemann 和近似。\n- **误差度量：** $E = \\max_{0 \\le k \\le N-1} \\left| c_{\\text{num}}(t_k) - c_{\\text{exact}}(t_k) \\right|$。\n- **测试用例**（元组 $(T_{\\min}, T_{\\max}, \\Delta t, \\sigma, t_0)$）：\n    1.  $(-1.0, 1.0, 0.001, 0.1, 0.0)$\n    2.  $(-1.0, 1.0, 0.001, 0.1, -0.9)$\n    3.  $(-0.1, 0.1, 0.0002, 0.005, 0.02)$\n    4.  $(-3.0, 3.0, 0.002, 0.5, 0.3)$\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学性：** 该问题基于数学和数字信号处理中的基本概念：卷积、Heaviside 函数和高斯函数。所有定义都是标准且正确的。\n2.  **良构性：** 该问题是良构的。它要求推导一个已知的解析结果，并将其与指定的数值方案进行比较。任务定义清晰，且存在唯一解。术语“Riemann 和近似”被解释为在给定网格上的标准离散卷积和，这是对积分在网格域上的直接且有效的离散化。\n3.  **客观性：** 该问题以客观和精确的数学语言陈述。所有参数均以数值形式给出。\n4.  **完整性和一致性：** 该问题提供了解决它所需的所有必要信息，包括函数定义、参数、网格规范和误差度量，没有歧义。\n5.  **可行性：** 所要求的计算是标准的，可以使用指定的 Python 环境（`numpy`、`scipy`）实现。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将提供一个解决方案。\n\n### 基于原理的解决方案设计\n\n该问题需要一个分为两部分的计算，然后进行比较。首先，我们推导卷积的精确解析表达式。其次，我们实现一个指定的数值近似。最后，我们在离散网格上计算两者之间的最大绝对误差。\n\n**1. 推导精确闭式表达式**\n\nHeaviside 阶跃函数 $H(t-t_0)$与高斯核 $g_{\\sigma}(t)$ 的卷积由下式给出：\n$$\nc_{\\text{exact}}(t) = (H * g_{\\sigma})(t) = \\int_{-\\infty}^{\\infty} H(\\tau - t_0)\\,g_{\\sigma}(t - \\tau)\\,d\\tau\n$$\n根据定义，$H(\\tau - t_0) = 1$ 对 $\\tau \\ge t_0$ 成立，否则为 $0$。此属性允许我们将积分下限从 $-\\infty$ 更改为 $t_0$：\n$$\nc_{\\text{exact}}(t) = \\int_{t_0}^{\\infty} g_{\\sigma}(t - \\tau)\\,d\\tau = \\int_{t_0}^{\\infty} \\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\exp\\left(-\\frac{(t - \\tau)^2}{2\\sigma^2}\\right)\\,d\\tau\n$$\n为计算该积分，我们进行变量替换。令 $u = \\frac{\\tau - t}{\\sigma}$。这意味着 $\\tau = t + \\sigma u$ 以及 $d\\tau = \\sigma du$。$\\tau$ 的积分限变换为 $u$ 的积分限：\n- 当 $\\tau \\to t_0$ 时，$u \\to \\frac{t_0 - t}{\\sigma}$。\n- 当 $\\tau \\to \\infty$ 时，$u \\to \\infty$。\n\n积分变为：\n$$\nc_{\\text{exact}}(t) = \\int_{(t_0 - t)/\\sigma}^{\\infty} \\frac{1}{\\sqrt{2\\pi}\\,\\sigma} \\exp\\left(-\\frac{(-u\\sigma)^2}{2\\sigma^2}\\right) (\\sigma\\,du) = \\frac{1}{\\sqrt{2\\pi}} \\int_{(t_0 - t)/\\sigma}^{\\infty} e^{-u^2/2}\\,du\n$$\n利用高斯函数的对称性，对于偶函数 $f(x)$ 有 $\\int_a^\\infty f(x)dx = \\int_{-\\infty}^{-a} f(x)dx$，我们得到：\n$$\nc_{\\text{exact}}(t) = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{-(t_0 - t)/\\sigma} e^{-u^2/2}\\,du = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{(t - t_0)/\\sigma} e^{-u^2/2}\\,du\n$$\n这正是标准正态分布的累积分布函数（CDF）的定义，记为 $\\Phi(z)$，其中 $z = \\frac{t - t_0}{\\sigma}$。\n$$\nc_{\\text{exact}}(t) = \\Phi\\left(\\frac{t - t_0}{\\sigma}\\right)\n$$\nCDF $\\Phi(z)$ 与标准误差函数 $\\text{erf}(z)$ 通过恒等式 $\\Phi(z) = \\frac{1}{2}\\left[1 + \\text{erf}\\left(\\frac{z}{\\sqrt{2}}\\right)\\right]$ 相关。代入 $z$，我们得到最终的闭式表达式：\n$$\nc_{\\text{exact}}(t) = \\frac{1}{2}\\left[1 + \\text{erf}\\left(\\frac{t - t_0}{\\sigma\\sqrt{2}}\\right)\\right]\n$$\n此表达式将用于计算网格上的精确值 $c_{\\text{exact}}(t_k)$。\n\n**2. 数值近似**\n\n问题指定了网格 $\\{t_k\\}_{k=0}^{N-1}$ 上的“Riemann 和近似”。这对应于将卷积积分离散化。对 $\\tau$ 的积分通过一个和来近似，其中 $\\tau$ 在网格点 $t_j$ 处采样。微分 $d\\tau$ 被网格间距 $\\Delta t$ 替代。\n$$\nc_{\\text{num}}(t_k) \\approx \\int_{T_{\\min}}^{T_{\\max}} H(\\tau - t_0)\\,g_{\\sigma}(t_k - \\tau)\\,d\\tau \\approx \\sum_{j=0}^{N-1} H(t_j - t_0)\\,g_{\\sigma}(t_k - t_j)\\,\\Delta t\n$$\n这个和是一个离散线性卷积。对于输出网格上的每个点 $t_k$，我们对输入网格上所有点 $t_j$ 的贡献求和。这可以用一个嵌套循环结构来实现。外层循环遍历输出点 $t_k$（索引 $k$），内层循环遍历输入点 $t_j$（索引 $j$）。\n\n**3. 误差分析**\n\n最大绝对误差 $E$ 按指定方式计算：\n$$\nE = \\max_{0 \\le k \\le N-1} \\left| c_{\\text{num}}(t_k) - c_{\\text{exact}}(t_k) \\right|\n$$\n关键是要认识到这个误差来自两个来源：\n1.  **离散化误差：** 用有限和近似积分所产生的误差（即 Riemann 和本身固有的误差），当 $\\Delta t \\to 0$ 时该误差减小。\n2.  **截断误差：** 将精确公式中的积分域从 $(-\\infty, \\infty)$ 限制到数值求和中的 $[T_{\\min}, T_{\\max}]$ 所产生的误差。\n\n在给定的测试用例中，网格边界 $[T_{\\min}, T_{\\max}]$ 距离计算域中心有几个标准差（$\\sigma$），这使得高斯核本身的截断误差最小化。然而，由于 Heaviside 积分的半无限性质，会产生显著的截断误差。数值求和只考虑了 $[T_{\\min}, T_{\\max}]$ 内的输入信号 $H(\\tau - t_0)$，而精确解是在 $[t_0, \\infty)$ 上对其进行积分。这导致在网格边界处（尤其是在 $t_k = T_{\\max}$）出现实质性的、且是刻意设计的差异，这突显了有限域信号处理的后果。这种边界效应是正在测试的一个关键特征。\n\n程序将被构造成对每个测试用例执行这些计算，并报告所产生的最大误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\ndef g_sigma(t, sigma):\n    \"\"\"\n    Computes the normalized Gaussian kernel.\n    \"\"\"\n    return (1 / (np.sqrt(2 * np.pi) * sigma)) * np.exp(-t**2 / (2 * sigma**2))\n\ndef H_func(t, t0):\n    \"\"\"\n    Computes the Heaviside step function, H(t-t0).\n    The value is 1 at t=t0, matching the problem definition.\n    \"\"\"\n    return np.heaviside(t - t0, 1)\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (-1.0, 1.0, 0.001, 0.1, 0.0),\n        (-1.0, 1.0, 0.001, 0.1, -0.9),\n        (-0.1, 0.1, 0.0002, 0.005, 0.02),\n        (-3.0, 3.0, 0.002, 0.5, 0.3)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        T_min, T_max, dt, sigma, t0 = case\n        \n        # 1. Grid Specification\n        # Use a robust method to define the grid to avoid floating point issues.\n        num_points = int(round((T_max - T_min) / dt)) + 1\n        t_grid = np.linspace(T_min, T_max, num_points)\n        \n        # 2. Exact Closed-Form Solution\n        # c_exact(t) = 0.5 * (1 + erf((t - t0) / (sigma * sqrt(2))))\n        arg_erf = (t_grid - t0) / (sigma * np.sqrt(2))\n        c_exact = 0.5 * (1.0 + erf(arg_erf))\n        \n        # 3. Numerical Approximation using Riemann Sum\n        # This implements the discrete convolution sum:\n        # c_num(t_k) = sum_{j=0}^{N-1} H(t_j - t0) * g_sigma(t_k - t_j) * dt\n        H_grid = H_func(t_grid, t0)\n        N = len(t_grid)\n        c_num = np.zeros(N)\n        \n        # This O(N^2) approach is a direct implementation of the sum.\n        # The inner loop is vectorized for performance.\n        for k in range(N):\n            shifted_times = t_grid[k] - t_grid\n            g_values = g_sigma(shifted_times, sigma)\n            c_num[k] = np.sum(H_grid * g_values) * dt\n            \n        # 4. Compute Maximum Absolute Error\n        max_error = np.max(np.abs(c_num - c_exact))\n        results.append(f\"{max_error:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2373609"}, {"introduction": "在确定性验证的基础上，下一个实践将带你进入蒙特卡洛模拟的随机世界。你将模拟一维随机行走，并验证统计物理学的一个基石：均方位移（MSD）$\\langle x^2(t) \\rangle$ 与时间 $t$ 之间的线性关系。通过测试各种步长分布，这个问题展示了普适性这一强大概念，并磨练你分析计算实验中统计数据的技能 [@problem_id:2373658]。", "problem": "考虑如下定义的一维离散时间随机游走。存在 $N$ 个独立的行走者。对于每个行走者 $i \\in \\{1,\\dots,N\\}$ 和每个离散时间步 $t \\in \\{1,\\dots,T\\}$，其位置 $x_i(t)$ 遵循 $x_i(t) = \\sum_{k=1}^{t} s_i(k)$ 进行演化，其中步长 $s_i(k)$ 是独立同分布的，且均值为零。在时间 $t$ 时，对所有行走者系综求取的经验均方位移（mean squared displacement (MSD)）为 $\\widehat{M}(t) = \\frac{1}{N} \\sum_{i=1}^{N} x_i(t)^2$。对于每个测试用例，定义时间集合为 $\\{1,2,\\dots,T\\}$，并考虑最佳仿射函数 $f(t) = \\alpha + \\beta t$，该函数最小化残差平方和 $\\sum_{t=1}^{T} \\left(\\widehat{M}(t) - f(t)\\right)^2$。令 $R^2$ 表示决定系数 $R^2 = 1 - \\frac{\\sum_{t=1}^{T} \\left(\\widehat{M}(t) - f(t)\\right)^2}{\\sum_{t=1}^{T} \\left(\\widehat{M}(t) - \\overline{\\widehat{M}}\\right)^2}$，其中 $\\overline{\\widehat{M}}$ 是 $\\widehat{M}(t)$ 在 $t \\in \\{1,\\dots,T\\}$ 上的平均值。\n\n您的任务是：在指定的步长分布和参数值下模拟随机游走，计算所有 $t \\in \\{1,\\dots,T\\}$ 的 $\\widehat{M}(t)$，以最小二乘法拟合仿射函数 $f(t)$ 以获得 $\\beta$，计算 $R^2$，并为每个测试用例返回一个布尔值，该值指示是否同时满足以下两个验证条件：\n- 绝对偏差 $|\\beta - \\beta_{\\mathrm{expected}}|$ 小于或等于给定的绝对容差 $\\varepsilon$。\n- 决定系数 $R^2$ 大于或等于给定的阈值 $R^2_{\\min}$。\n\n每个测试用例指定了行走者数量 $N$、时间步数 $T$、步长分布族及其参数、预期斜率 $\\beta_{\\mathrm{expected}}$、绝对容差 $\\varepsilon$ 以及可接受的最小决定系数 $R^2_{\\min}$。离散时间步长为 $\\Delta t = 1$，时间指数 $t$ 是无量纲的；不涉及物理单位。\n\n请使用以下测试套件，其中分布完全由其指定参数定义。在所有情况下，步长 $s_i(k)$ 在 $i$ 和 $k$ 上都是独立的。\n- 用例 1（理想情况，对称 Bernoulli）：$N = 40000$，$T = 300$，分布：振幅为 $a$ 的对称 Bernoulli 分布，即 $s_i(k) \\in \\{-a,+a\\}$ 的概率相等，且 $a = 1$。预期斜率 $\\beta_{\\mathrm{expected}} = 1$。绝对容差 $\\varepsilon = 0.02$。最小 $R^2_{\\min} = 0.999$。\n- 用例 2（小样本边界，对称 Bernoulli）：$N = 300$，$T = 25$，分布：振幅为 $a = 1$ 的对称 Bernoulli 分布。预期斜率 $\\beta_{\\mathrm{expected}} = 1$。绝对容差 $\\varepsilon = 0.35$。最小 $R^2_{\\min} = 0.90$。\n- 用例 3（Gaussian 步长）：$N = 40000$，$T = 300$，分布：均值为 $0$、标准差为 $\\sigma = 2$ 的 Gaussian 分布。预期斜率 $\\beta_{\\mathrm{expected}} = 4$。绝对容差 $\\varepsilon = 0.08$。最小 $R^2_{\\min} = 0.999$。\n- 用例 4（方差匹配的均匀步长）：$N = 40000$，$T = 300$，分布：$[-a,a]$ 上的均匀分布，其中 $a = \\sqrt{3}$。预期斜率 $\\beta_{\\mathrm{expected}} = 1$。绝对容差 $\\varepsilon = 0.025$。最小 $R^2_{\\min} = 0.999$。\n- 用例 5（方差匹配的稀疏步长）：$N = 40000$，$T = 300$，分布：以概率 $p$ 从 $\\{-b,+b\\}$ 中等概率取值，否则 $s_i(k) = 0$，其中 $p = 0.1$ 且 $b = \\sqrt{10}$。预期斜率 $\\beta_{\\mathrm{expected}} = 1$。绝对容差 $\\varepsilon = 0.03$。最小 $R^2_{\\min} = 0.999$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与上述用例相同，其中每个条目都是一个布尔值，指示该测试用例是否通过了两个验证条件（例如，“[True,False,True,True,False]”）。不应打印任何额外文本。", "solution": "该问题陈述是有效的。它提出了一个定义明确的计算实验，该实验基于一维离散时间随机游走的标准模型，这是统计力学和随机过程中的一个基本概念。所有参数、定义和条件都已提供，其背后的科学原理是合理的。\n\n其核心原理是随机行走者微观动力学与其宏观扩散行为之间的关系，后者通过均方位移（MSD）来量化。对于单个行走者 $i$，其在离散时间步 $t$ 的位置是其先前所有步长的总和，即 $x_i(t) = \\sum_{k=1}^{t} s_i(k)$。步长 $s_i(k)$ 是独立同分布的随机变量，其均值为零，$\\mathbb{E}[s_i(k)] = 0$，方差为有限值，$\\text{Var}(s_i(k)) = \\sigma_s^2$。\n\n理论 MSD，记为 $M(t)$，是位移平方的系综平均，定义为 $M(t) = \\mathbb{E}[x_i(t)^2]$。我们可以如下推导其形式：\n$$M(t) = \\mathbb{E}\\left[ \\left( \\sum_{k=1}^{t} s_i(k) \\right)^2 \\right] = \\mathbb{E}\\left[ \\sum_{k=1}^{t} \\sum_{l=1}^{t} s_i(k) s_i(l) \\right]$$\n根据期望算子的线性性质，上式变为：\n$$M(t) = \\sum_{k=1}^{t} \\sum_{l=1}^{t} \\mathbb{E}[s_i(k) s_i(l)]$$\n由于在不同时间指数下步长 $s_i(k)$ 是独立的，所以当 $k \\neq l$ 时，其乘积的期望可以分离，即 $\\mathbb{E}[s_i(k)s_i(l)] = \\mathbb{E}[s_i(k)]\\mathbb{E}[s_i(l)]$。由于每一步的均值为零，这些交叉项都为零。唯一非零的贡献来自于 $k=l$ 的项：\n$$\\mathbb{E}[s_i(k)s_i(k)] = \\mathbb{E}[s_i(k)^2] = \\text{Var}(s_i(k)) + (\\mathbb{E}[s_i(k)])^2 = \\sigma_s^2 + 0^2 = \\sigma_s^2$$\n因此，总和简化为：\n$$M(t) = \\sum_{k=1}^{t} \\mathbb{E}[s_i(k)^2] = \\sum_{k=1}^{t} \\sigma_s^2 = \\sigma_s^2 t$$\n这个结果表明，理论 MSD 是时间的线性函数，其斜率等于步长分布的方差。这是正常扩散的一个标志。\n\n问题要求通过对 $N$ 个行走者的有限系综进行平均来计算经验 MSD，即 $\\widehat{M}(t)$：\n$$\\widehat{M}(t) = \\frac{1}{N} \\sum_{i=1}^{N} x_i(t)^2$$\n根据大数定律，对于足够大的 $N$，$\\widehat{M}(t)$ 可以作为理论期望 $M(t)$ 的一个良好近似。因此，我们预期对于 $t \\in \\{1, \\dots, T\\}$，经验数据点 $(t, \\widehat{M}(t))$ 会紧密分布在一条穿过原点的直线上。\n\n任务是通过最小化残差平方和 $\\sum_{t=1}^{T} (\\widehat{M}(t) - f(t))^2$ 来将这些经验数据拟合到一个仿射函数 $f(t) = \\alpha + \\beta t$。这是一个标准的简单线性回归问题。最佳拟合线的斜率 $\\beta$ 是理论斜率 $\\sigma_s^2$ 的一个经验估计。问题为斜率提供了预期值 $\\beta_{\\mathrm{expected}}$，这些值对应于每个指定步长分布的理论方差 $\\sigma_s^2$。例如，对于步长为 $\\pm a$ 的对称 Bernoulli 分布，方差为 $\\sigma_s^2 = (-a)^2(0.5) + (a)^2(0.5) = a^2$。当 $a=1$ 时，$\\sigma_s^2 = 1$，与 $\\beta_{\\mathrm{expected}}$ 相符。所有其他用例也同样一致。\n\n解决每个测试用例的算法步骤如下：\n1.  **步长模拟**：对于 $N$ 个行走者和 $T$ 个时间步，生成一个 $N \\times T$ 的随机步长矩阵，其中每个元素都从指定的概率分布（Bernoulli、Gaussian、均匀或稀疏分布）中独立抽取。\n2.  **轨迹计算**：通过对每个行走者的步长沿时间轴求累积和来计算其轨迹。这将产生一个 $N \\times T$ 的位置矩阵 $x_i(t)$。\n3.  **经验 MSD 计算**：对于从 $1$ 到 $T$ 的每个时间点 $t$，将所有行走者的位置平方，并计算这 $N$ 个行走者的平均值。这将得到一个长度为 $T$ 的向量 $\\widehat{M}(t)$。\n4.  **线性回归**：对数据点 $(t, \\widehat{M}(t))$（其中 $t \\in \\{1, \\dots, T\\}$）执行简单线性回归。这将得到最佳拟合斜率 $\\beta$。\n5.  **决定系数**：计算决定系数 $R^2 = 1 - \\frac{\\sum_{t=1}^{T} (\\widehat{M}(t) - f(t))^2}{\\sum_{t=1}^{T} (\\widehat{M}(t) - \\overline{\\widehat{M}})^2}$ 以量化线性模型的拟合优度。\n6.  **验证**：将计算出的 $\\beta$ 和 $R^2$ 与提供的阈值进行比较。当且仅当 $|\\beta - \\beta_{\\mathrm{expected}}| \\le \\varepsilon$ 和 $R^2 \\ge R^2_{\\min}$ 同时为真时，用例通过。\n\n此过程使用 `numpy` 库进行高效的向量化计算，并使用 `scipy.stats.linregress` 函数来稳健、直接地计算回归斜率和决定系数。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef run_case(case_params):\n    \"\"\"\n    Runs a single simulation case for a random walk ensemble.\n\n    Args:\n        case_params (dict): A dictionary containing all parameters for the case.\n\n    Returns:\n        bool: True if both validation conditions are met, False otherwise.\n    \"\"\"\n    N = case_params['N']\n    T = case_params['T']\n    dist_info = case_params['distribution']\n    beta_expected = case_params['beta_expected']\n    epsilon = case_params['epsilon']\n    r_squared_min = case_params['r_squared_min']\n\n    # Step 1: Generate steps based on the specified distribution.\n    if dist_info['name'] == 'bernoulli':\n        a = dist_info['a']\n        steps = np.random.choice([-a, a], size=(N, T))\n    elif dist_info['name'] == 'gaussian':\n        sigma = dist_info['sigma']\n        steps = np.random.normal(loc=0.0, scale=sigma, size=(N, T))\n    elif dist_info['name'] == 'uniform':\n        a = dist_info['a']\n        steps = np.random.uniform(low=-a, high=a, size=(N, T))\n    elif dist_info['name'] == 'sparse':\n        p = dist_info['p']\n        b = dist_info['b']\n        # Efficiently generate sparse steps:\n        # First, generate choices from {-b, b} for all potential steps.\n        potential_steps = np.random.choice([-b, b], size=(N, T))\n        # Then, create a mask to determine which steps are non-zero.\n        is_step_taken = np.random.rand(N, T)  p\n        steps = potential_steps * is_step_taken\n    else:\n        # This should not be reached with the given problem statement.\n        raise ValueError(f\"Unknown distribution name: {dist_info['name']}\")\n\n    # Step 2: Compute trajectories by taking the cumulative sum of steps.\n    # The positions are the cumulative sum along the time axis (axis=1).\n    positions = np.cumsum(steps, axis=1)\n\n    # Step 3: Compute the empirical Mean Squared Displacement (MSD).\n    # For each time t, average the squared positions over all N walkers (axis=0).\n    msd_empirical = np.mean(np.square(positions), axis=0)\n\n    # Step 4: Perform linear regression on the MSD data.\n    # The time vector t runs from 1 to T.\n    t_values = np.arange(1, T + 1)\n    \n    # Use scipy.stats.linregress for a robust linear fit.\n    # It directly returns slope, intercept, r_value, p_value, and stderr.\n    regression_result = linregress(t_values, msd_empirical)\n    beta_fit = regression_result.slope\n    # The coefficient of determination R^2 is the square of the correlation coefficient r_value.\n    r_squared = regression_result.rvalue**2\n\n    # Step 5: Validate the results against the given conditions.\n    condition_beta = np.abs(beta_fit - beta_expected) = epsilon\n    condition_r2 = r_squared = r_squared_min\n\n    return condition_beta and condition_r2\n\ndef solve():\n    \"\"\"\n    Defines and runs the suite of test cases, then prints the results.\n    \"\"\"\n    test_cases = [\n        # Case 1: Happy path, symmetric Bernoulli\n        {\n            'N': 40000, 'T': 300, \n            'distribution': {'name': 'bernoulli', 'a': 1.0},\n            'beta_expected': 1.0, 'epsilon': 0.02, 'r_squared_min': 0.999\n        },\n        # Case 2: Small-sample boundary, symmetric Bernoulli\n        {\n            'N': 300, 'T': 25,\n            'distribution': {'name': 'bernoulli', 'a': 1.0},\n            'beta_expected': 1.0, 'epsilon': 0.35, 'r_squared_min': 0.90\n        },\n        # Case 3: Gaussian steps\n        {\n            'N': 40000, 'T': 300,\n            'distribution': {'name': 'gaussian', 'sigma': 2.0},\n            'beta_expected': 4.0, 'epsilon': 0.08, 'r_squared_min': 0.999\n        },\n        # Case 4: Uniform steps with matched variance\n        {\n            'N': 40000, 'T': 300,\n            'distribution': {'name': 'uniform', 'a': np.sqrt(3)},\n            'beta_expected': 1.0, 'epsilon': 0.025, 'r_squared_min': 0.999\n        },\n        # Case 5: Sparse steps with matched variance\n        {\n            'N': 40000, 'T': 300,\n            'distribution': {'name': 'sparse', 'p': 0.1, 'b': np.sqrt(10)},\n            'beta_expected': 1.0, 'epsilon': 0.03, 'r_squared_min': 0.999\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(case)\n        results.append(result)\n\n    # Print the final result in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver.\nsolve()\n```", "id": "2373658"}, {"introduction": "最后的这个实践向你提出挑战，要求你将验证原则应用于一个复杂的非线性工程问题。你将实现一个简化的有限元法（FEM）求解器来模拟一个超弹性块的大变形，并通过与均匀压缩下的半解析解进行比较来验证其结果。这个案例研究展示了在现实世界的工程中，复杂的求解器是如何通过在有已知解的问题上确认其准确性来接受严格测试，从而确保其可靠性的 [@problem_id:2373682]。", "problem": "为用于简单弹性体块大变形压缩的非线性有限元法 (FEM) 求解器设计并实现一个基准验证。其目标是通过将计算得到的反力-位移曲线与从可压缩超弹性材料的均匀变形推导出的参考曲线进行比较，来验证求解器的准确性。所有计算都是无量纲的；不使用物理单位。\n\n您必须严格基于基本原理进行推导和算法设计：准静态平衡中的虚功原理、有限变形运动学以及下文指定的超弹性本构模型。除了这些基础理论，请勿使用任何预先推导的简化公式。\n\n假设与模型：\n- 该块体占据一个初始矩形域，沿加载方向（$x$轴）的初始长度为 $L_0$，横向的初始宽度和高度分别为 $W_0$ 和 $H_0$。初始横截面积为 $A_0 = W_0 H_0$。\n- 侧面无牵引，刚性压板通过规定的末端位移沿 $x$ 轴压缩该块体。\n- 材料是均匀的超弹性体，其可压缩 Neo-Hookean 应变能密度为\n$$\n\\psi(\\mathbf{F}) = \\frac{\\mu}{2}\\left(I_1 - 3\\right) - \\mu \\ln J + \\frac{\\kappa}{2} \\left(\\ln J\\right)^2,\n$$\n其中 $\\mathbf{F}$ 是变形梯度，$I_1 = \\mathrm{tr}\\left(\\mathbf{C}\\right)$ 且 $\\mathbf{C} = \\mathbf{F}^\\top \\mathbf{F}$，$J = \\det \\mathbf{F}$，$\\mu$ 是剪切模量，$\\kappa$ 是体积模量。\n\n目标推导与离散化要求：\n- 从最小势能原理及定义 $\\mathbf{P} = \\partial \\psi / \\partial \\mathbf{F}$ 出发，推导名义应力 $\\mathbf{P}$。\n- 通过在横向施加零名义牵引力来强制侧面无牵引。对于具有主伸长率 $\\lambda_x$, $\\lambda_y$, $\\lambda_z$ 的均匀变形，这意味着存在两个标量方程，它们将横向伸长率 $\\lambda_t$ （假设 $\\lambda_y = \\lambda_z = \\lambda_t$）确定为轴向伸长率 $\\lambda_x$ 的函数。\n- 沿 $x$ 轴实现一个包含 $n$ 个线性单元（节点数为 $n+1$）的一维全拉格朗日 (Total Lagrangian) 两节点杆单元网格。使用轴向名义应力分量 $P_{xx}$，并组装全局内力向量和一致切线刚度矩阵。单元 $e$ 中的轴向单元伸长率为 $\\lambda_x = \\ell_e / L_e$，其中 $L_e$ 是初始单元长度，$\\ell_e$ 是当前单元长度。\n- 对于一致算法切线，在此验证中，可通过带有小相对扰动的数值微分来计算 $\\mathrm{d}P_{xx}/\\mathrm{d}\\lambda_x$。\n- 以增量方式施加准静态载荷。施加狄利克雷 (Dirichlet) 条件 $u(0) = 0$ 和 $u(L_0) = -\\Delta$，其中 $\\Delta$ 从 $0$ 单调增加到 $L_0$ 的指定最大分数。通过对自由度进行牛顿-拉夫逊 (Newton–Raphson) 迭代来求解每个加载步。\n- 将加载端的反力计算为平衡相应狄利克雷 (Dirichlet) 自由度上内部节点力的支座反力。将正的反力定义为压缩性的（即，在平衡压缩内力时为正）。\n- 使用均匀变形解为每个载荷水平计算参考反力：对于指定的轴向伸长率 $\\lambda_x = (L_0-\\Delta)/L_0$，求解侧向无牵引条件以获得 $\\lambda_t$，然后计算轴向名义应力 $P_{xx}$；参考反力为 $R_\\mathrm{ref} = -A_0 P_{xx}$。\n- 对每个测试用例，评估所有加载步中的最大绝对相对误差，\n$$\n\\varepsilon_\\mathrm{max} = \\max_{\\text{steps}} \\frac{\\left|R_\\mathrm{FEM} - R_\\mathrm{ref}\\right|}{\\max\\left(\\left|R_\\mathrm{ref}\\right|, \\epsilon\\right)},\n$$\n使用一个小的 $\\epsilon = 10^{-12}$ 以避免在载荷趋于零时出现除以零的情况。\n\n边界条件：\n- 左端固定：$u(0) = 0$。\n- 右端指定位移：$u(L_0) = -\\Delta$，其中 $\\Delta$ 在指定的步数内线性增加。\n\n不使用角度。所有量均为无量纲。\n\n测试套件：\n实现您的程序以运行以下三个测试用例。对于每个用例，载荷在指定的步数内线性施加至指定的最终压缩量。每个测试用例指定为一个元组 $(\\mu,\\kappa,L_0,W_0,H_0,n,\\text{final\\_compression},\\text{n\\_steps})$：\n- 测试用例 A (一般情况): $(1.2, 120.0, 1.0, 0.5, 0.5, 8, 0.30, 15)$。\n- 测试用例 B (大压缩边界情况): $(0.8, 8.0, 1.0, 0.5, 0.5, 3, 0.60, 20)$。\n- 测试用例 C (近乎不可压缩): $(1.0, 1000.0, 1.0, 0.5, 0.5, 20, 0.20, 20)$。\n\n要求的最终输出：\n- 您的程序必须输出一行，其中包含按 A、B、C 顺序排列的三个测试用例的结果，形式为用方括号括起来的逗号分隔列表，例如 $\\left[r_1,r_2,r_3\\right]$，其中每个 $r_i$ 是该测试用例的最大绝对相对误差 $\\varepsilon_\\mathrm{max}$，四舍五入到八位小数。", "solution": "我们为一个应用于单轴压缩下弹性体块的非线性大变形有限元法 (FEM) 求解器开发一个基准验证。其目标是通过将计算得到的反力-位移曲线与基于可压缩 Neo-Hookean 模型的均匀变形推导出的参考曲线进行比较。所有量均为无量纲。\n\n基本原理：\n- 准静态平衡源于虚功原理：对于容许的虚位移，内虚功等于外虚功。在没有体力且在加载边界处进行位移控制的情况下，弱形式简化为内力与边界反力的平衡。\n- 有限变形运动学：变形梯度为 $\\mathbf{F} = \\partial \\mathbf{x} / \\partial \\mathbf{X}$，其中 $J = \\det \\mathbf{F} > 0$。右柯西-格林 (Cauchy–Green) 张量为 $\\mathbf{C} = \\mathbf{F}^\\top \\mathbf{F}$，其第一不变量为 $I_1 = \\mathrm{tr}\\,\\mathbf{C}$。\n- 超弹性本构律：应变能密度为\n$$\n\\psi(\\mathbf{F}) = \\frac{\\mu}{2}\\left(I_1 - 3\\right) - \\mu \\ln J + \\frac{\\kappa}{2}\\left(\\ln J\\right)^2,\n$$\n其中 $\\mu$ 为剪切模量，$\\kappa$ 为体积模量。名义（第一皮奥拉-基尔霍夫 Piola–Kirchhoff）应力由能量共轭关系得出，\n$$\n\\mathbf{P} = \\frac{\\partial \\psi}{\\partial \\mathbf{F}}.\n$$\n\n名义应力的推导：\n我们通过使用 $\\partial I_1 / \\partial \\mathbf{F} = 2\\mathbf{F}$、$\\partial J / \\partial \\mathbf{F} = J \\mathbf{F}^{-\\top}$ 以及 $\\partial \\ln J / \\partial \\mathbf{F} = \\mathbf{F}^{-\\top}$ 的标准操作来计算 $\\partial \\psi / \\partial \\mathbf{F}$。结果是\n$$\n\\mathbf{P} = \\mu\\left(\\mathbf{F} - \\mathbf{F}^{-\\top}\\right) + \\kappa \\left(\\ln J\\right)\\mathbf{F}^{-\\top}.\n$$\n这个表达式被广泛使用，并由给定的能量密度推导得出。\n\n均匀变形和侧向无牵引条件：\n对于具有主伸长率 $\\lambda_x$、$\\lambda_y$、$\\lambda_z$ 的均匀单轴压缩，我们利用对称性设置 $\\lambda_y = \\lambda_z = \\lambda_t$ 和 $\\mathbf{F} = \\mathrm{diag}(\\lambda_x,\\lambda_t,\\lambda_t)$。行列式为 $J = \\lambda_x \\lambda_t^2$，名义应力是对角阵，其分量为\n$$\nP_{ii} = \\mu\\left(\\lambda_i - \\frac{1}{\\lambda_i}\\right) + \\kappa \\frac{\\ln J}{\\lambda_i}.\n$$\n侧向无牵引意味着 $P_{yy} = 0$ 和 $P_{zz} = 0$，由于对称性，这两者是相同的。标量形式的侧向无牵引条件为\n$$\ng(\\lambda_t;\\lambda_x) \\equiv \\mu\\left(\\lambda_t - \\frac{1}{\\lambda_t}\\right) + \\kappa \\frac{\\ln\\left(\\lambda_x \\lambda_t^2\\right)}{\\lambda_t} = 0.\n$$\n给定 $\\lambda_x$，求解这个标量非线性方程以得到 $\\lambda_t > 0$。一个稳健的初始猜测是不可压缩极限 $\\lambda_t^{(0)} = \\lambda_x^{-1/2}$。则轴向名义应力为\n$$\nP_{xx}(\\lambda_x) = \\mu\\left(\\lambda_x - \\frac{1}{\\lambda_x}\\right) + \\kappa \\frac{\\ln\\left(\\lambda_x \\lambda_t^2(\\lambda_x)\\right)}{\\lambda_x}.\n$$\n对于初始横截面积为 $A_0$ 的块体，参考反力为 $R_\\mathrm{ref} = -A_0 P_{xx}(\\lambda_x)$，其符号约定为压缩产生正反力。\n\n一维全拉格朗日 (Total Lagrangian) FEM 离散化：\n我们将杆沿 $x$ 轴离散为 $n$ 个线性两节点单元（节点 $i=0,\\dots,n$）。初始节点位置为 $X_i = i\\,L_0/n$，节点 $i$ 的唯一自由度是轴向位移 $u_i$。对于连接节点 $a$ 和 $b$ 的单元 $e$，其初始长度为 $L_e = L_0/n$，轴向伸长率为\n$$\n\\lambda_x^{(e)} = \\frac{\\ell_e}{L_e} = \\frac{(X_b + u_b) - (X_a + u_a)}{L_e} = 1 + \\frac{u_b - u_a}{L_e}.\n$$\n在全拉格朗日 (Total Lagrangian) 形式下，单元 $e$ 上 $P_{xx}$ 为常数时，其内力向量为\n$$\n\\mathbf{f}_\\mathrm{int}^{(e)} = A_0 P_{xx}\\left(\\lambda_x^{(e)}\\right)\\begin{bmatrix}-1\\\\+1\\end{bmatrix}.\n$$\n单元 $e$ 的一致算法切线通过对节点位移使用链式法则求导得到：\n$$\n\\mathbf{K}^{(e)} = A_0 \\frac{\\mathrm{d}P_{xx}}{\\mathrm{d}\\lambda_x}\\Big|_{\\lambda_x^{(e)}} \\begin{bmatrix} \\frac{1}{L_e}  -\\frac{1}{L_e} \\\\ -\\frac{1}{L_e}  \\frac{1}{L_e} \\end{bmatrix}.\n$$\n在此验证中，我们通过带有小相对扰动的中心有限差分法数值计算 $\\mathrm{d}P_{xx}/\\mathrm{d}\\lambda_x$。全局组装得到内力向量 $\\mathbf{f}_\\mathrm{int}(\\mathbf{u})$ 和切线刚度矩阵 $\\mathbf{K}(\\mathbf{u})$。\n\n边界条件和求解过程：\n我们在每个加载步中施加 $u_0 = 0$ 和 $u_n = -\\Delta$，其中 $\\Delta$ 从 0 线性增加到最终压缩量。自由度是内部节点。在每个加载步，牛顿-拉夫逊 (Newton–Raphson) 迭代通过以下公式更新自由度：\n$$\n\\mathbf{K}_{ff}(\\mathbf{u})\\,\\Delta\\mathbf{u}_f = -\\mathbf{r}_f(\\mathbf{u}), \\quad \\mathbf{r} \\equiv \\mathbf{f}_\\mathrm{int},\n$$\n直到收敛，其中下标 $f$ 表示自由度。通过残差范数或位移增量范数检查收敛性；一个典型的标准是 $\\|\\Delta \\mathbf{u}_f\\|_\\infty  10^{-12} L_0$。加载端的反力计算为平衡狄利克雷 (Dirichlet) 节点上内力的支座反力，即 $R = -f_{\\mathrm{int},n}$，对于负的 $P_{xx}$，该反力在压缩时为正。\n\n参考解和误差度量：\n在每个具有末端缩短量 $\\Delta$ 的载荷水平下，均匀轴向伸长率为 $\\lambda_x = (L_0 - \\Delta)/L_0$。通过标量牛顿法求解 $g(\\lambda_t;\\lambda_x) = 0$ 以获得 $\\lambda_t$。然后计算 $P_{xx}(\\lambda_x)$ 和参考反力 $R_\\mathrm{ref} = -A_0 P_{xx}(\\lambda_x)$。测试度量是所有步中的最大绝对相对误差，\n$$\n\\varepsilon_\\mathrm{max} = \\max_{\\text{steps}} \\frac{\\left|R_\\mathrm{FEM} - R_\\mathrm{ref}\\right|}{\\max\\left(\\left|R_\\mathrm{ref}\\right|, 10^{-12}\\right)}.\n$$\n\n为保证稳健性的算法细节：\n- 求解 $\\lambda_t$ 的标量牛顿法使用导数\n$$\n\\frac{\\mathrm{d}g}{\\mathrm{d}\\lambda_t} = \\mu\\left(1 + \\frac{1}{\\lambda_t^2}\\right) + \\kappa \\frac{2 - \\ln\\left(\\lambda_x \\lambda_t^2\\right)}{\\lambda_t^2},\n$$\n必要时进行回溯以保持 $\\lambda_t > 0$ 并减小 $|g|$。\n- 数值导数 $\\mathrm{d}P_{xx}/\\mathrm{d}\\lambda_x$ 使用带有 $\\lambda_x$ 小相对扰动的中心差分法，以确保尺度不变性和稳定性。\n\n测试套件和预期行为：\n我们运行三个案例：\n- 测试 A: $(\\mu,\\kappa,L_0,W_0,H_0,n,\\text{final\\_compression},\\text{n\\_steps}) = (1.2, 120.0, 1.0, 0.5, 0.5, 8, 0.30, 15)$。这是一个条件良好且具有中等可压缩性的案例。\n- 测试 B: $(0.8, 8.0, 1.0, 0.5, 0.5, 3, 0.60, 20)$。该案例探测具有更高非线性度的大压缩情况。\n- 测试 C: $(1.0, 1000.0, 1.0, 0.5, 0.5, 20, 0.20, 20)$。该案例探测近乎不可压缩的刚度。\n\n因为在位移控制下，使用给定本构更新的杆离散化在平衡状态下会使每个单元具有相同的轴向伸长率，所以 FEM 反力应在数值公差范围内与均匀参考解匹配。因此，最大相对误差 $\\varepsilon_\\mathrm{max}$ 应很小，对于测试 A 和 C，通常接近机器精度；对于测试 B，由于非线性更强，误差会略大但仍然非常小。程序将这三个误差四舍五入到八位小数，以单行列表 $\\left[r_A,r_B,r_C\\right]$ 的形式报告。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_lateral_stretch(lambda_x, mu, kappa, tol=1e-12, max_iter=100):\n    \"\"\"\n    Solve for lateral stretch lambda_t given axial stretch lambda_x\n    under traction-free lateral faces for compressible Neo-Hookean.\n    g(lambda_t) = mu*(lambda_t - 1/lambda_t) + kappa * ln(J)/lambda_t = 0\n    with J = lambda_x * lambda_t^2.\n    \"\"\"\n    # Robust initial guess: incompressible estimate\n    lam_t = max(lambda_x ** (-0.5), 1e-12)\n    for _ in range(max_iter):\n        J = lambda_x * lam_t * lam_t\n        if J = 0 or not np.isfinite(J):\n            # Recover with small positive perturbation\n            lam_t = max(lam_t, 1e-8)\n            J = lambda_x * lam_t * lam_t\n        g = mu * (lam_t - 1.0 / lam_t) + kappa * (np.log(J)) / lam_t\n        if abs(g)  tol:\n            return lam_t\n        # Derivative of g with respect to lambda_t\n        dg = mu * (1.0 + 1.0 / (lam_t * lam_t)) + kappa * (2.0 - np.log(J)) / (lam_t * lam_t)\n        # Newton step with backtracking if needed\n        delta = -g / dg\n        lam_new = lam_t + delta\n        if lam_new = 0 or not np.isfinite(lam_new):\n            # Backtracking line search on lambda_t to keep positivity and reduce |g|\n            alpha = 1.0\n            success = False\n            while alpha  1e-8:\n                cand = lam_t + alpha * delta\n                if cand  0 and np.isfinite(cand):\n                    Jc = lambda_x * cand * cand\n                    if Jc  0 and np.isfinite(Jc):\n                        gc = mu * (cand - 1.0 / cand) + kappa * (np.log(Jc)) / cand\n                        if abs(gc)  abs(g):\n                            lam_new = cand\n                            success = True\n                            break\n                alpha *= 0.5\n            if not success:\n                # Fallback small positive update\n                lam_new = max(lam_t * 0.5, 1e-10)\n        lam_t = lam_new\n    # If not converged, return current estimate (still positive)\n    return max(lam_t, 1e-10)\n\ndef Pxx_given_lambda(lambda_x, mu, kappa):\n    \"\"\"\n    Compute axial nominal stress P_xx for compressible Neo-Hookean\n    under uniaxial stretch lambda_x with traction-free lateral faces.\n    \"\"\"\n    lam_t = solve_lateral_stretch(lambda_x, mu, kappa)\n    J = lambda_x * lam_t * lam_t\n    # P_xx = mu*(lambda_x - 1/lambda_x) + kappa * ln(J) / lambda_x\n    return mu * (lambda_x - 1.0 / lambda_x) + kappa * (np.log(J)) / lambda_x\n\ndef dPxx_dlambda_numeric(lambda_x, mu, kappa, rel_eps=1e-7):\n    \"\"\"\n    Numerical derivative dPxx/dlambda_x via central relative finite difference.\n    \"\"\"\n    h = rel_eps\n    lp = lambda_x * (1.0 + h)\n    lm = lambda_x * (1.0 - h)\n    # Ensure positivity\n    if lm = 0:\n        lm = lambda_x * (1.0 - 0.5 * h)\n        lp = lambda_x * (1.0 + 0.5 * h)\n        h = 0.5 * h\n    Pp = Pxx_given_lambda(lp, mu, kappa)\n    Pm = Pxx_given_lambda(lm, mu, kappa)\n    return (Pp - Pm) / (2.0 * h * lambda_x)\n\ndef assemble_internal_and_tangent(u, L0, A0, n_el, mu, kappa):\n    \"\"\"\n    Assemble global internal force vector and tangent stiffness matrix\n    for a 1D bar with n_el elements and n_el+1 nodes.\n    \"\"\"\n    n_nodes = n_el + 1\n    f_int = np.zeros(n_nodes)\n    K = np.zeros((n_nodes, n_nodes))\n    L_e0 = L0 / n_el\n\n    # Nodal positions in reference\n    # X_i = i * L_e0\n    for e in range(n_el):\n        a = e\n        b = e + 1\n        ua = u[a]\n        ub = u[b]\n        # Axial stretch in element e: lambda_x = 1 + (ub - ua)/L_e0\n        lambda_x = 1.0 + (ub - ua) / L_e0\n        # Compute stress and tangent\n        P = Pxx_given_lambda(lambda_x, mu, kappa)\n        dP = dPxx_dlambda_numeric(lambda_x, mu, kappa)\n\n        # Element internal force: A0 * P * [-1, +1]\n        fe = A0 * P * np.array([-1.0, +1.0])\n        f_int[a] += fe[0]\n        f_int[b] += fe[1]\n\n        # Element tangent: A0 * dP/dlambda * [[1/L_e0, -1/L_e0], [-1/L_e0, 1/L_e0]]\n        coef = A0 * dP / L_e0\n        Ke = coef * np.array([[1.0, -1.0], [-1.0, 1.0]])\n        K[a, a] += Ke[0, 0]\n        K[a, b] += Ke[0, 1]\n        K[b, a] += Ke[1, 0]\n        K[b, b] += Ke[1, 1]\n\n    return f_int, K\n\ndef solve_bar(mu, kappa, L0, W0, H0, n_el, final_compression, n_steps):\n    \"\"\"\n    Solve displacement-controlled compression and return the maximum absolute relative\n    error between FEM reaction and the homogeneous-reference reaction over all steps.\n    \"\"\"\n    A0 = W0 * H0\n    n_nodes = n_el + 1\n    # Initialize displacements\n    u = np.zeros(n_nodes)\n    left = 0\n    right = n_nodes - 1\n    free = np.arange(1, n_nodes - 1, dtype=int)\n    # Track maximum relative error\n    max_rel_err = 0.0\n    # Load path\n    for step in range(1, n_steps + 1):\n        frac = step / n_steps\n        Delta = final_compression * L0 * frac\n        # Apply boundary conditions\n        u[left] = 0.0\n        u[right] = -Delta\n        # Newton-Raphson on free DOFs\n        for it in range(60):\n            f_int, K = assemble_internal_and_tangent(u, L0, A0, n_el, mu, kappa)\n            # Residual on free DOFs: internal forces must vanish on free DOFs\n            r = f_int[free]\n            # Convergence check on displacement increment norm later\n            if free.size  0:\n                Kff = K[np.ix_(free, free)]\n                # Solve for update\n                try:\n                    du = -np.linalg.solve(Kff, r)\n                except np.linalg.LinAlgError:\n                    # Regularize slightly if singular (should not occur with proper setup)\n                    Kff_reg = Kff + 1e-12 * np.eye(Kff.shape[0])\n                    du = -np.linalg.solve(Kff_reg, r)\n                u[free] += du\n                if np.linalg.norm(du, ord=np.inf)  1e-12 * L0:\n                    break\n            else:\n                # No free DOFs; skip\n                break\n        # Post-converged internal forces for reaction\n        f_int, _ = assemble_internal_and_tangent(u, L0, A0, n_el, mu, kappa)\n        R_fem = -f_int[right]  # reaction at right end, positive in compression\n        # Reference reaction from homogeneous solution\n        lambda_x = (L0 - Delta) / L0\n        P_ref = Pxx_given_lambda(lambda_x, mu, kappa)\n        R_ref = -A0 * P_ref\n        denom = max(abs(R_ref), 1e-12)\n        rel_err = abs(R_fem - R_ref) / denom\n        if rel_err  max_rel_err:\n            max_rel_err = rel_err\n    return max_rel_err\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (mu, kappa, L0, W0, H0, n_el, final_compression, n_steps)\n    test_cases = [\n        (1.2, 120.0, 1.0, 0.5, 0.5, 8, 0.30, 15),   # Test A: general case\n        (0.8, 8.0, 1.0, 0.5, 0.5, 3, 0.60, 20),     # Test B: large compression\n        (1.0, 1000.0, 1.0, 0.5, 0.5, 20, 0.20, 20), # Test C: nearly incompressible\n    ]\n\n    results = []\n    for case in test_cases:\n        mu, kappa, L0, W0, H0, n_el, final_comp, n_steps = case\n        err = solve_bar(mu, kappa, L0, W0, H0, n_el, final_comp, n_steps)\n        results.append(round(float(err), 8))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2373682"}]}