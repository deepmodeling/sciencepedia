{"hands_on_practices": [{"introduction": "我们的第一个动手实践将带领你完整地走过贝叶斯推断的全过程，并将其应用于一个具体的工程问题：估算热接触电阻。通过结合傅里叶定律、关于电阻 $R$ 的先验知识以及测量噪声模型，你将为 $R$ 构建后验分布。该练习将通过基本的数值积分方法，巩固你将物理问题转化为贝叶斯模型并求解的能力。[@problem_id:2374140]", "problem": "考虑一个涉及两个接触固体的一维稳态热传导实验。界面处微观粗糙度的净效应被建模为接触热阻，记作 $R$，单位为 $\\mathrm{m^2\\,K/W}$。在穿过界面的均匀热通量 $q$（单位为 $\\mathrm{W/m^2}$）作用下，界面上的温降定义为 $\\Delta T = T^{-} - T^{+}$，其中 $T^{-}$ 和 $T^{+}$ 分别是界面两侧的极限温度。从傅里叶热传导定律和接触热阻的定义出发，界面跳跃条件为界面上的温降满足 $\\Delta T = q\\,R$。\n\n在实践中，测量是有噪声的。假设在第 $i$ 个实验条件下观测到的温降 $\\Delta T_i^{\\mathrm{obs}}$ 服从一个加性高斯噪声模型\n$$\n\\Delta T_i^{\\mathrm{obs}} = q_i\\,R + \\varepsilon_i,\\quad \\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2),\n$$\n其中测量噪声标准差 $\\sigma$（单位为 $\\mathrm{K}$）已知。给定 $R$ 时，各次测量是条件独立的。为 $R$ 采用一个由对数正态分布给出的严格为正的先验：$R \\sim \\mathrm{LogNormal}(\\mu_0, s_0^2)$，意即 $\\ln R \\sim \\mathcal{N}(\\mu_0, s_0^2)$。使用自然对数。对数正态先验密度为\n$$\n\\pi(R) = \\frac{1}{R\\,s_0\\sqrt{2\\pi}} \\exp\\left(-\\frac{(\\ln R - \\mu_0)^2}{2 s_0^2}\\right),\\quad R>0.\n$$\n\n你的任务是执行贝叶斯推断，通过计算后验均值\n$$\n\\mathbb{E}[R \\mid \\{\\Delta T_i^{\\mathrm{obs}}, q_i\\}_{i=1}^{n}],\n$$\n来从数据中估计 $R$。计算过程使用在对数间隔网格上的数值积分，积分范围为 $R \\in [R_{\\min}, R_{\\max}]$。使用贝叶斯法则在该网格上构建未归一化的后验密度，对其进行数值归一化，然后通过数值积分计算后验均值。所有计算必须在国际单位制（SI）下进行。将 $R$ 的最终估计值以 $\\mathrm{m^2\\,K/W}$ 为单位，表示为普通十进制浮点数。\n\n建模基本依据：\n- 傅里叶一维稳态热传导定律：$q = -k\\,\\mathrm{d}T/\\mathrm{d}x$。\n- 来自接触热阻定义的界面跳跃条件：温降与热通量成正比，比例系数为 $R$，因此 $\\Delta T = q\\,R$。\n- 温降的独立高斯测量误差，导致高斯似然。\n\n实现要求：\n- 使用对数间隔网格，其范围为 $R_{\\min} = 10^{-6}\\,\\mathrm{m^2\\,K/W}$ 至 $R_{\\max} = 10^{-2}\\,\\mathrm{m^2\\,K/W}$。网格必须足够密集以产生稳定的数值积分结果。\n- 在每个网格点上计算未归一化的对数后验，其值为对数先验与对数似然之和，在指数化之前通过减去最大对数后验值进行稳定化处理，然后使用关于 $R$ 的数值积分法则进行归一化。\n- 将后验均值 $\\mathbb{E}[R \\mid \\text{data}]$ 计算为两个关于 $R$ 的数值积分之比：$R$ 乘以以后验密度的积分除以后验密度的积分。\n\n先验参数：\n- $\\mu_0 = \\ln(1.5\\times 10^{-4})$,\n- $s_0 = 0.5$。\n\n测试套件：\n对于下方的每个测试用例，使用指定的 $\\{q_i\\}$ 数组（单位为 $\\mathrm{W/m^2}$）、观测到的温降 $\\{\\Delta T_i^{\\mathrm{obs}}\\}$（单位为 $\\mathrm{K}$）以及噪声标准差 $\\sigma$（单位为 $\\mathrm{K}$）。\n\n- 情况 1（良态，多热通量水平）：\n  - $q = [1.00\\times 10^{4},\\, 1.20\\times 10^{4},\\, 0.80\\times 10^{4},\\, 1.50\\times 10^{4}]$,\n  - $\\Delta T^{\\mathrm{obs}} = [2.12,\\, 2.45,\\, 1.50,\\, 3.08]$,\n  - $\\sigma = 0.10$。\n- 情况 2（更宽的热通量范围）：\n  - $q = [0.50\\times 10^{4},\\, 2.00\\times 10^{4},\\, 3.00\\times 10^{4},\\, 4.00\\times 10^{4},\\, 1.00\\times 10^{4}]$,\n  - $\\Delta T^{\\mathrm{obs}} = [0.58,\\, 2.47,\\, 3.55,\\, 4.95,\\, 1.21]$,\n  - $\\sigma = 0.10$。\n- 情况 3（边界情况：信息量低，单一低热通量，较大噪声）：\n  - $q = [0.20\\times 10^{4}]$,\n  - $\\Delta T^{\\mathrm{obs}} = [0.64]$,\n  - $\\sigma = 0.30$。\n\n角度单位不适用。本问题不涉及百分比。\n\n你的程序必须输出单独一行，内容为对应三种情况的三个 $R$ 的后验均值估计值，格式为一个用逗号分隔、并用方括号括起来的 Python 风格列表，例如 $[r_1,r_2,r_3]$，其中每个 $r_i$ 是一个以 $\\mathrm{m^2\\,K/W}$ 为单位的浮点数。", "solution": "问题陈述已经过分析，并被认为是有效的。这是一个基于热传导和统计推断原理的适定贝叶斯参数估计问题。所提供的数据和模型在科学上是合理、完整且一致的。我们将继续进行推导和数值求解。\n\n目标是在给定一组 $n$ 个带噪声的测量值的情况下，计算接触热阻 $R$ 的后验均值。该问题由以下几个部分定义：\n\n1.  **物理模型：** 界面上的温降 $\\Delta T$ 与热通量 $q$ 通过 $\\Delta T = qR$ 相关联。\n2.  **观测模型：** 对于第 $i$ 次测量，观测到的温降 $\\Delta T_i^{\\mathrm{obs}}$ 被建模为 $\\Delta T_i^{\\mathrm{obs}} = q_i R + \\varepsilon_i$，其中噪声项 $\\varepsilon_i$ 从均值为 $0$、已知方差为 $\\sigma^2$ 的正态分布中抽取，即 $\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$。\n3.  **先验分布：** 参数 $R$ 被假定为严格为正。为其赋予一个对数正态先验：$R \\sim \\mathrm{LogNormal}(\\mu_0, s_0^2)$，这意味着 $\\ln R \\sim \\mathcal{N}(\\mu_0, s_0^2)$。\n\n令采集到的数据表示为 $\\mathcal{D} = \\{\\Delta T_i^{\\mathrm{obs}}, q_i\\}_{i=1}^{n}$。我们的目标是计算 $R$ 的后验均值：\n$$\n\\mathbb{E}[R \\mid \\mathcal{D}] = \\int_0^\\infty R \\, p(R \\mid \\mathcal{D}) \\, dR\n$$\n其中 $p(R \\mid \\mathcal{D})$ 是 $R$ 的后验概率密度函数。\n\n根据贝叶斯定理，后验密度与似然和先验密度的乘积成正比：\n$$\np(R \\mid \\mathcal{D}) \\propto p(\\mathcal{D} \\mid R) \\, \\pi(R)\n$$\n其中 $p(\\mathcal{D} \\mid R)$ 是似然函数，$\\pi(R)$ 是先验。\n\n**似然函数**\n根据观测模型，每次测量 $\\Delta T_i^{\\mathrm{obs}}$ 都独立地从正态分布 $\\mathcal{N}(q_i R, \\sigma^2)$ 中抽取。单个观测的概率密度为：\n$$\np(\\Delta T_i^{\\mathrm{obs}} \\mid R) = \\frac{1}{\\sigma\\sqrt{2\\pi}} \\exp\\left( -\\frac{(\\Delta T_i^{\\mathrm{obs}} - q_i R)^2}{2\\sigma^2} \\right)\n$$\n由于在给定 $R$ 的条件下各次测量是条件独立的，因此数据集 $\\mathcal{D}$ 的总似然是各个密度的乘积：\n$$\np(\\mathcal{D} \\mid R) = \\prod_{i=1}^n p(\\Delta T_i^{\\mathrm{obs}} \\mid R)\n$$\n为了数值稳定性，我们使用对数似然。在不考虑一个与 $R$ 无关的加性常数的情况下，对数似然为：\n$$\n\\ln p(\\mathcal{D} \\mid R) \\propto -\\frac{1}{2\\sigma^2} \\sum_{i=1}^n (\\Delta T_i^{\\mathrm{obs}} - q_i R)^2\n$$\n\n**先验分布**\n$R$ 的先验是一个参数为 $\\mu_0$ 和 $s_0^2$ 的对数正态分布，其密度函数由下式给出：\n$$\n\\pi(R) = \\frac{1}{R\\,s_0\\sqrt{2\\pi}} \\exp\\left(-\\frac{(\\ln R - \\mu_0)^2}{2 s_0^2}\\right) \\quad \\text{for } R > 0\n$$\n在不考虑一个加性常数的情况下，对数先验为：\n$$\n\\ln \\pi(R) \\propto -\\ln R - \\frac{(\\ln R - \\mu_0)^2}{2s_0^2}\n$$\n\n**后验分布**\n未归一化的对数后验是对数似然和对数先验之和：\n$$\n\\ln p(R \\mid \\mathcal{D}) \\propto -\\frac{1}{2\\sigma^2} \\sum_{i=1}^n (\\Delta T_i^{\\mathrm{obs}} - q_i R)^2 - \\ln R - \\frac{(\\ln R - \\mu_0)^2}{2s_0^2}\n$$\n\n**数值计算**\n后验均值通过在 $R$ 的离散网格上进行数值积分来计算。我们定义一个跨越区间 $[R_{\\min}, R_{\\max}]$ 的点网格 $\\{R_j\\}$。问题指定了使用对数间隔网格。\n\n后验均值是两个积分之比：\n$$\n\\mathbb{E}[R \\mid \\mathcal{D}] = \\frac{\\int_{R_{\\min}}^{R_{\\max}} R \\, p_{\\text{unnorm}}(R \\mid \\mathcal{D}) \\, dR}{\\int_{R_{\\min}}^{R_{\\max}} p_{\\text{unnorm}}(R \\mid \\mathcal{D}) \\, dR}\n$$\n其中 $p_{\\text{unnorm}}(R \\mid \\mathcal{D}) = \\exp(\\ln p_{\\text{unnorm}}(R \\mid \\mathcal{D}))$ 是未归一化的后验密度。\n\n算法步骤如下：\n1.  定义一个从 $R_{\\min} = 10^{-6}$ 到 $R_{\\max} = 10^{-2}$ 的对数间隔网格，包含 $N_{grid}$ 个点 $\\{R_j\\}$。\n2.  为了计算效率，预先计算似然项所需的和：$S_{qq} = \\sum_{i=1}^n q_i^2$，$S_{qT} = \\sum_{i=1}^n q_i \\Delta T_i^{\\mathrm{obs}}$，以及 $S_{TT} = \\sum_{i=1}^n (\\Delta T_i^{\\mathrm{obs}})^2$。对数似然项变为 $-\\frac{1}{2\\sigma^2}(S_{TT} - 2R S_{qT} + R^2 S_{qq})$。\n3.  在每个网格点 $R_j$ 处计算未归一化的对数后验 $\\mathcal{L}(R_j)$。\n4.  为防止在指数化过程中发生数值下溢，通过减去其最大值来稳定化对数后验：$\\mathcal{L}_{\\text{stab}}(R_j) = \\mathcal{L}(R_j) - \\max_j\\{\\mathcal{L}(R_j)\\}$。\n5.  在网格上计算未归一化的后验值：$p_{\\text{unnorm}}(R_j) = \\exp(\\mathcal{L}_{\\text{stab}}(R_j))$。\n6.  使用梯形法则在非均匀网格 $\\{R_j\\}$ 上近似计算分子和分母（归一化常数）的积分。令 $P_j = p_{\\text{unnorm}}(R_j)$。\n    - 归一化常数：$Z = \\int p_{\\text{unnorm}}(R) \\, dR \\approx \\text{trapz}(\\{P_j\\}, \\{R_j\\})$。\n    - 分子积分：$N = \\int R \\, p_{\\text{unnorm}}(R) \\, dR \\approx \\text{trapz}(\\{R_j \\cdot P_j\\}, \\{R_j\\})$。\n7.  随后，后验均值计算为 $\\mathbb{E}[R \\mid \\mathcal{D}] \\approx N/Z$。\n\n将此过程应用于所提供的三个测试用例中的每一个。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import trapezoid\n\ndef solve():\n    \"\"\"\n    Main function to solve the Bayesian inference problem for all test cases.\n    \"\"\"\n    # Prior parameters\n    mu_0 = np.log(1.5e-4) # mu_0 = ln(1.5 * 10^-4)\n    s_0 = 0.5            # s_0 = 0.5\n\n    # Numerical integration parameters\n    R_min = 1e-6         # R_min = 10^-6 m^2K/W\n    R_max = 1e-2         # R_max = 10^-2 m^2K/W\n    N_grid = 20001       # Number of grid points for integration\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"q\": np.array([1.00e4, 1.20e4, 0.80e4, 1.50e4]), # W/m^2\n            \"delta_T_obs\": np.array([2.12, 2.45, 1.50, 3.08]), # K\n            \"sigma\": 0.10, # K\n        },\n        {\n            \"q\": np.array([0.50e4, 2.00e4, 3.00e4, 4.00e4, 1.00e4]), # W/m^2\n            \"delta_T_obs\": np.array([0.58, 2.47, 3.55, 4.95, 1.21]), # K\n            \"sigma\": 0.10, # K\n        },\n        {\n            \"q\": np.array([0.20e4]), # W/m^2\n            \"delta_T_obs\": np.array([0.64]), # K\n            \"sigma\": 0.30, # K\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_posterior_mean(\n            case[\"q\"],\n            case[\"delta_T_obs\"],\n            case[\"sigma\"],\n            mu_0,\n            s_0,\n            R_min,\n            R_max,\n            N_grid\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\ndef compute_posterior_mean(q, delta_T_obs, sigma, mu_0, s_0, R_min, R_max, N_grid):\n    \"\"\"\n    Computes the posterior mean of R using numerical integration.\n\n    Args:\n        q (np.ndarray): Array of heat flux values [W/m^2].\n        delta_T_obs (np.ndarray): Array of observed temperature drops [K].\n        sigma (float): Standard deviation of measurement noise [K].\n        mu_0 (float): Mean of the logarithm of R for the Log-Normal prior.\n        s_0 (float): Standard deviation of the logarithm of R for the Log-Normal prior.\n        R_min (float): Minimum value for the integration grid for R [m^2K/W].\n        R_max (float): Maximum value for the integration grid for R [m^2K/W].\n        N_grid (int): Number of points in the integration grid.\n\n    Returns:\n        float: The posterior mean of R [m^2K/W].\n    \"\"\"\n    # 1. Create a logarithmically spaced grid for R.\n    R_grid = np.logspace(np.log10(R_min), np.log10(R_max), N_grid)\n\n    # 2. Compute log-likelihood.\n    # Pre-calculate summary statistics for efficiency.\n    S_qq = np.sum(q**2)\n    S_qT = np.sum(q * delta_T_obs)\n    S_TT = np.sum(delta_T_obs**2)\n    \n    # The term in the likelihood sum is a quadratic in R: S_TT - 2*R*S_qT + R^2*S_qq\n    likelihood_quadratic = S_TT - 2 * R_grid * S_qT + R_grid**2 * S_qq\n    log_likelihood = -0.5 / (sigma**2) * likelihood_quadratic\n\n    # 3. Compute log-prior.\n    log_R_grid = np.log(R_grid)\n    log_prior = -log_R_grid - (log_R_grid - mu_0)**2 / (2 * s_0**2)\n\n    # 4. Compute unnormalized log-posterior.\n    log_posterior = log_likelihood + log_prior\n    \n    # 5. Stabilize log-posterior to avoid numerical underflow.\n    log_posterior_stable = log_posterior - np.max(log_posterior)\n    \n    # 6. Exponentiate to get unnormalized posterior.\n    posterior_unnorm = np.exp(log_posterior_stable)\n\n    # 7. Compute integrals using the trapezoidal rule.\n    # Numerator integral: integral of R * posterior(R) dR\n    numerator_integral = trapezoid(R_grid * posterior_unnorm, R_grid)\n    \n    # Denominator integral (normalization constant): integral of posterior(R) dR\n    norm_constant = trapezoid(posterior_unnorm, R_grid)\n\n    # 8. Compute the posterior mean.\n    posterior_mean = numerator_integral / norm_constant\n\n    return posterior_mean\n\nsolve()\n```", "id": "2374140"}, {"introduction": "现在，我们进入计算工程学中最基本的工具之一：线性回归。在本练习中，你将不再局限于单个参数的估计，而是同时推断回归系数 $\\theta_0$、$\\theta_1$ 以及未知的噪声方差 $\\sigma^2$。你将推导并实现一个由共轭正态-逆伽马先验带来的解析解，这个优雅而强大的技术是许多贝叶斯模型的核心。[@problem_id:2374101]", "problem": "给定一个信号加噪声模型，其中观测数据 $\\{(x_i, y_i)\\}_{i=1}^n$ 满足\n$y_i = f(x_i; \\theta) + \\epsilon_i$，\n其中 $\\epsilon_i$ 是独立同分布的高斯噪声项，均值为 $0$，方差 $\\sigma^2$ 未知。考虑参数化情况，其中 $f$ 对参数是线性的，具体为 $f(x_i; \\theta) = \\theta_0 + \\theta_1 x_i$，其中 $\\theta = [\\theta_0, \\theta_1]^\\top$。\n\n任务是对参数 $\\theta$ 和噪声方差 $\\sigma^2$ 进行贝叶斯推断，以实现同步估计。使用如下定义的共轭正态-逆伽马先验：\n- 给定方差下参数的条件先验：$\\theta \\mid \\sigma^2 \\sim \\mathcal{N}(m_0, \\sigma^2 S_0)$，其中 $m_0 \\in \\mathbb{R}^2$ 且 $S_0 \\in \\mathbb{R}^{2 \\times 2}$ 是对称正定矩阵。\n- 方差的先验：$\\sigma^2 \\sim \\text{Inverse-Gamma}(\\alpha_0, \\beta_0)$，其中逆伽马分布的密度为 $p(\\sigma^2 \\mid \\alpha, \\beta) \\propto (\\sigma^2)^{-(\\alpha+1)} \\exp(-\\beta/\\sigma^2)$，对于 $\\sigma^2 > 0$。\n\n您的任务是：\n- 仅从贝叶斯定理、独立观测值的高斯似然、多元正态分布的定义以及逆伽马分布的定义出发，推导 $(\\theta, \\sigma^2)$ 的后验分布（忽略归一化常数）。避免依赖任何无法从这些基础知识推导出来的预先记忆的公式。\n- 基于您的推导，设计一个算法来计算后验均值 $\\mathbb{E}[\\theta \\mid \\mathcal{D}]$ 和 $\\mathbb{E}[\\sigma^2 \\mid \\mathcal{D}]$，其中 $\\mathcal{D}$ 表示数据集。将这些均值完全用先验超参数、数据和基本的线性代数运算来表示。\n- 实现一个完整的、可运行的程序，对下面测试套件中的每个数据集，计算并输出 $\\theta_0$、$\\theta_1$和 $\\sigma^2$ 的后验均值。所有输出必须是四舍五入到 $6$ 位小数的实数。\n\n对所有测试用例使用以下先验超参数：\n- $m_0 = [0, 0]^\\top$，\n- $S_0 = \\mathrm{diag}(100, 100)$，\n- $\\alpha_0 = 2$，\n- $\\beta_0 = 1$。\n\n测试套件（每个用例提供观测输入 $x$ 和输出 $y$）：\n- 用例 A（良态，中等噪声）：\n  - $x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]$，\n  - $y = [1.5, 0.9, 0.04, -0.58, -1.34, -1.92, -2.72, -3.34, -4.18, -4.76]$。\n- 用例 B（小样本，近乎纯噪声）：\n  - $x = [0.0, 0.1, 0.2]$，\n  - $y = [0.002, -0.001, 0.0005]$。\n- 用例 C（中等斜率, 中等噪声, 轻度杠杆）：\n  - $x = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5]$，\n  - $y = [2.03, 2.44, 3.015, 3.5, 4.06, 4.47, 4.985, 5.545]$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。\n- 对于每个用例，按顺序报告后验均值：$\\mathbb{E}[\\theta_0 \\mid \\mathcal{D}]$、$\\mathbb{E}[\\theta_1 \\mid \\mathcal{D}]$、$\\mathbb{E}[\\sigma^2 \\mid \\mathcal{D}]$。\n- 按顺序连接用例 A、用例 B 和用例 C 的结果，形成一个包含 $9$ 个数字的单一扁平列表。\n- 每个数字必须四舍五入到 $6$ 位小数。\n- 示例结构模板（非实际值）：$[a_1,a_2,a_3,a_4,a_5,a_6,a_7,a_8,a_9]$。", "solution": "该问题要求推导并实现一个贝叶斯推断算法，用于估计带高斯噪声的线性模型的参数。分析必须从第一性原理出发。\n\n设观测数据为 $\\mathcal{D} = \\{ (x_i, y_i) \\}_{i=1}^n$。模型由 $y_i = \\theta_0 + \\theta_1 x_i + \\epsilon_i$ 给出，其中噪声项 $\\epsilon_i$ 独立同分布于均值为 $0$、方差 $\\sigma^2$ 未知的高斯分布，即 $\\epsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$。\n\n该模型可以用向量形式表示。设 $y = [y_1, \\dots, y_n]^\\top$ 为观测向量，$\\theta = [\\theta_0, \\theta_1]^\\top$ 为参数向量，$X$ 为 $n \\times 2$ 的设计矩阵，其第 $i$ 行为 $[1, x_i]$。则模型为 $y = X\\theta + \\epsilon$，其中 $\\epsilon \\sim \\mathcal{N}(0, \\sigma^2 I_n)$，$I_n$ 是 $n \\times n$ 的单位矩阵。\n\n给定参数 $\\theta$ 和方差 $\\sigma^2$ 时，数据的似然函数是在该模型下观测到 $y$ 的概率密度：\n$$\np(y \\mid X, \\theta, \\sigma^2) = (2\\pi\\sigma^2)^{-n/2} \\exp\\left(-\\frac{1}{2\\sigma^2}(y - X\\theta)^\\top(y - X\\theta)\\right)\n$$\n\n问题指定了 $(\\theta, \\sigma^2)$ 的共轭正态-逆伽马先验。联合先验分布 $p(\\theta, \\sigma^2)$ 分解为 $p(\\theta \\mid \\sigma^2)p(\\sigma^2)$。\n$\\theta$ 的条件先验是一个多元正态分布，$\\theta \\mid \\sigma^2 \\sim \\mathcal{N}(m_0, \\sigma^2 S_0)$，其中 $k=2$ 是 $\\theta$ 的维度：\n$$\np(\\theta \\mid \\sigma^2) = (2\\pi\\sigma^2)^{-k/2} |\\det(S_0)|^{-1/2} \\exp\\left(-\\frac{1}{2\\sigma^2}(\\theta - m_0)^\\top S_0^{-1}(\\theta - m_0)\\right)\n$$\n方差 $\\sigma^2$ 的先验是一个逆伽马分布，$\\sigma^2 \\sim \\text{Inverse-Gamma}(\\alpha_0, \\beta_0)$，其指定密度为：\n$$\np(\\sigma^2) \\propto (\\sigma^2)^{-(\\alpha_0+1)} \\exp(-\\beta_0/\\sigma^2)\n$$\n\n根据贝叶斯定理，参数的联合后验分布正比于似然函数与先验分布的乘积：\n$$\np(\\theta, \\sigma^2 \\mid \\mathcal{D}) \\propto p(y \\mid X, \\theta, \\sigma^2) p(\\theta \\mid \\sigma^2) p(\\sigma^2)\n$$\n代入给定数据集 $\\mathcal{D}=(X,y)$ 的表达式：\n$$\np(\\theta, \\sigma^2 \\mid \\mathcal{D}) \\propto \\left[ (\\sigma^2)^{-n/2} \\exp\\left(-\\frac{1}{2\\sigma^2}(y - X\\theta)^\\top(y - X\\theta)\\right) \\right] \\times \\left[ (\\sigma^2)^{-k/2} \\exp\\left(-\\frac{1}{2\\sigma^2}(\\theta - m_0)^\\top S_0^{-1}(\\theta - m_0)\\right) \\right] \\times \\left[ (\\sigma^2)^{-(\\alpha_0+1)} \\exp(-\\beta_0/\\sigma^2) \\right]\n$$\n常数因子 $(2\\pi)^{-n/2}$、$(2\\pi)^{-k/2}$ 和 $|\\det(S_0)|^{-1/2}$ 被吸收到比例常数中。合并各项得到：\n$$\np(\\theta, \\sigma^2 \\mid \\mathcal{D}) \\propto (\\sigma^2)^{-(\\alpha_0 + n/2 + k/2 + 1)} \\exp\\left\\{ -\\frac{1}{2\\sigma^2} \\left[ (y - X\\theta)^\\top(y - X\\theta) + (\\theta - m_0)^\\top S_0^{-1}(\\theta - m_0) + 2\\beta_0 \\right] \\right\\}\n$$\n为了识别后验分布的结构，我们分析指数中关于 $\\theta$ 的二次项。令该二次型为 $Q(\\theta) = (y - X\\theta)^\\top(y - X\\theta) + (\\theta - m_0)^\\top S_0^{-1}(\\theta - m_0)$。展开并收集关于 $\\theta$ 的项：\n$$\n\\begin{aligned}\nQ(\\theta) &= (y^\\top y - 2y^\\top X \\theta + \\theta^\\top X^\\top X \\theta) + (\\theta^\\top S_0^{-1}\\theta - 2\\theta^\\top S_0^{-1}m_0 + m_0^\\top S_0^{-1}m_0) \\\\\n&= \\theta^\\top(X^\\top X + S_0^{-1})\\theta - 2\\theta^\\top(X^\\top y + S_0^{-1}m_0) + y^\\top y + m_0^\\top S_0^{-1}m_0\n\\end{aligned}\n$$\n该表达式可以对 $\\theta$ 进行配方。定义后验精度矩阵 $S_n^{-1}$ 和后验均值向量 $m_n$ 如下：\n$$\nS_n^{-1} = X^\\top X + S_0^{-1}\n$$\n$$\nm_n = (S_n^{-1})^{-1}(X^\\top y + S_0^{-1}m_0)\n$$\n注意 $S_n = (X^\\top X + S_0^{-1})^{-1}$。二次型 $Q(\\theta)$ 变为：\n$$\nQ(\\theta) = (\\theta - m_n)^\\top S_n^{-1}(\\theta - m_n) - m_n^\\top S_n^{-1} m_n + y^\\top y + m_0^\\top S_0^{-1}m_0\n$$\n将此代回后验表达式：\n$$\np(\\theta, \\sigma^2 \\mid \\mathcal{D}) \\propto (\\sigma^2)^{-(\\alpha_0 + n/2 + k/2 + 1)} \\exp\\left\\{ -\\frac{1}{2\\sigma^2} \\left[ (\\theta - m_n)^\\top S_n^{-1}(\\theta - m_n) + y^\\top y + m_0^\\top S_0^{-1}m_0 - m_n^\\top S_n^{-1}m_n + 2\\beta_0 \\right] \\right\\}\n$$\n该表达式表明后验分布也呈正态-逆伽马形式。我们可以将其分解为 $p(\\theta, \\sigma^2 \\mid \\mathcal{D}) = p(\\theta \\mid \\sigma^2, \\mathcal{D}) p(\\sigma^2 \\mid \\mathcal{D})$。\n\n$\\theta$ 的条件后验分布为：\n$$\np(\\theta \\mid \\sigma^2, \\mathcal{D}) \\propto \\exp\\left(-\\frac{1}{2\\sigma^2}(\\theta - m_n)^\\top S_n^{-1}(\\theta - m_n)\\right)\n$$\n这是一个多元正态分布的核，$\\theta \\mid \\sigma^2, \\mathcal{D} \\sim \\mathcal{N}(m_n, \\sigma^2 S_n)$。\n\n$\\sigma^2$ 的边际后验分布通过对 $\\theta$ 积分得到。通过识别高斯核的积分，我们发现：\n$$\np(\\sigma^2 \\mid \\mathcal{D}) \\propto (\\sigma^2)^{-(\\alpha_0 + n/2 + k/2 + 1)} (\\sigma^2)^{k/2} \\exp\\left\\{ -\\frac{1}{2\\sigma^2} \\left[ 2\\beta_0 + y^\\top y + m_0^\\top S_0^{-1}m_0 - m_n^\\top S_n^{-1}m_n \\right] \\right\\}\n$$\n$$\np(\\sigma^2 \\mid \\mathcal{D}) \\propto (\\sigma^2)^{-(\\alpha_n+1)} \\exp(-\\beta_n/\\sigma^2)\n$$\n其中后验超参数 $\\alpha_n$ 和 $\\beta_n$ 为：\n$$\n\\alpha_n = \\alpha_0 + \\frac{n}{2}\n$$\n$$\n\\beta_n = \\beta_0 + \\frac{1}{2}\\left(y^\\top y + m_0^\\top S_0^{-1}m_0 - m_n^\\top S_n^{-1}m_n\\right)\n$$\n这是一个逆伽马分布的核，$\\sigma^2 \\mid \\mathcal{D} \\sim \\text{Inverse-Gamma}(\\alpha_n, \\beta_n)$。\n\n后验均值根据这些分布的性质计算。\n$\\theta$ 的后验均值使用全期望定律求得：\n$$\n\\mathbb{E}[\\theta \\mid \\mathcal{D}] = \\mathbb{E}[\\mathbb{E}[\\theta \\mid \\sigma^2, \\mathcal{D}]] = \\mathbb{E}[m_n] = m_n\n$$\n$\\sigma^2$ 的后验均值是 Inverse-Gamma$(\\alpha_n, \\beta_n)$ 分布的均值，当 $\\alpha_n > 1$ 时为 $\\frac{\\beta_n}{\\alpha_n - 1}$。已知 $\\alpha_0=2$ 且 $n \\ge 1$，则 $\\alpha_n = 2 + n/2 > 1$，因此均值是良定义的。\n$$\n\\mathbb{E}[\\sigma^2 \\mid \\mathcal{D}] = \\frac{\\beta_n}{\\alpha_n - 1}\n$$\n\n计算后验均值的算法如下：\n1.  给定数据 $\\{ (x_i, y_i) \\}_{i=1}^n$ 和先验超参数 $m_0, S_0, \\alpha_0, \\beta_0$。\n2.  构建大小为 $n \\times 2$ 的设计矩阵 $X$ 和大小为 $n \\times 1$ 的观测向量 $y$。\n3.  计算 $S_0^{-1}$。\n4.  计算后验参数 $S_n^{-1} = X^\\top X + S_0^{-1}$。\n5.  计算 $\\theta$ 的后验均值：$m_n = (S_n^{-1})^{-1}(X^\\top y + S_0^{-1}m_0)$。这就得到了 $\\mathbb{E}[\\theta \\mid \\mathcal{D}]$。\n6.  计算后验参数 $\\alpha_n = \\alpha_0 + n/2$。\n7.  计算后验参数 $\\beta_n = \\beta_0 + \\frac{1}{2}(y^\\top y + m_0^\\top S_0^{-1}m_0 - m_n^\\top S_n^{-1} m_n)$。最后一项的计算简化形式是 $m_n^\\top(X^\\top y + S_0^{-1}m_0)$。\n8.  计算 $\\sigma^2$ 的后验均值：$\\mathbb{E}[\\sigma^2 \\mid \\mathcal{D}] = \\frac{\\beta_n}{\\alpha_n - 1}$。\n\n这为计算所需的后验期望提供了一个完整的、有原则的步骤。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs Bayesian inference for a linear model to estimate parameters\n    theta = [theta_0, theta_1] and noise variance sigma^2.\n    \"\"\"\n    # Prior hyperparameters\n    m0 = np.array([0.0, 0.0])\n    S0 = np.array([[100.0, 0.0], [0.0, 100.0]])\n    alpha0 = 2.0\n    beta0 = 1.0\n\n    # Test suite\n    test_cases = [\n        # Case A (well-conditioned, moderate noise)\n        {\n            \"x\": np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]),\n            \"y\": np.array([1.5, 0.9, 0.04, -0.58, -1.34, -1.92, -2.72, -3.34, -4.18, -4.76]),\n        },\n        # Case B (small sample, near-noise-only)\n        {\n            \"x\": np.array([0.0, 0.1, 0.2]),\n            \"y\": np.array([0.002, -0.001, 0.0005]),\n        },\n        # Case C (moderate slope, moderate noise, mild leverage)\n        {\n            \"x\": np.array([0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5]),\n            \"y\": np.array([2.03, 2.44, 3.015, 3.5, 4.06, 4.47, 4.985, 5.545]),\n        },\n    ]\n\n    results = []\n\n    # Pre-compute S0 inverse\n    S0_inv = np.linalg.inv(S0)\n\n    for case in test_cases:\n        x_data = case[\"x\"]\n        y_data = case[\"y\"]\n        n = len(x_data)\n\n        # 1. Construct design matrix X and observation vector y\n        X = np.vstack((np.ones(n), x_data)).T\n        y = y_data.reshape(-1, 1)\n\n        # 2. Compute components for posterior updates\n        XTX = X.T @ X\n        XTy = X.T @ y\n\n        # 3. Compute posterior hyperparameters for theta\n        Sn_inv = XTX + S0_inv\n        Sn = np.linalg.inv(Sn_inv)\n        \n        # S0_inv @ m0 is a zero vector since m0 is zero\n        mn = Sn @ XTy\n        \n        # 4. Compute posterior hyperparameters for sigma^2\n        alpha_n = alpha0 + n / 2.0\n        \n        # y.T @ y + m0.T @ S0_inv @ m0 - mn.T @ Sn_inv @ mn\n        # The m0 term is zero\n        # The term mn.T @ Sn_inv @ mn simplifies to mn.T @ (XTy + S0_inv @ m0)\n        # which is mn.T @ XTy since m0 is zero\n        yTy = y.T @ y\n        mnT_Sn_inv_mn = mn.T @ XTy\n        \n        beta_n = beta0 + 0.5 * (yTy - mnT_Sn_inv_mn)\n\n        # 5. Compute posterior means\n        E_theta = mn\n        E_sigma2 = beta_n / (alpha_n - 1)\n\n        # Append results rounded to 6 decimal places\n        results.append(f\"{E_theta[0, 0]:.6f}\")\n        results.append(f\"{E_theta[1, 0]:.6f}\")\n        results.append(f\"{E_sigma2[0, 0]:.6f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2374101"}, {"introduction": "我们的最后一个实践是一项富有挑战性的应用，它展示了贝叶斯方法的全部威力：推断混沌动力学系统的参数。你将利用洛伦兹（Lorenz）系统轨迹的带噪观测数据，反向推断其内在的物理参数 $(\\sigma, \\rho, \\beta)$，从而解决一个复杂的逆问题。这个练习将贝叶斯推断与微分方程数值方法相结合，展示了如何在复杂的、基于仿真的模型中进行不确定性推理。[@problem_id:2374071]", "problem": "给定一个由确定性连续时间动力学系统（即洛伦兹系统）生成的单状态变量的短时含噪时间序列。洛伦兹系统由以下常微分方程定义：\n$$\n\\frac{dx}{dt} = \\sigma (y - x), \\quad\n\\frac{dy}{dt} = x (\\rho - z) - y, \\quad\n\\frac{dz}{dt} = x y - \\beta z,\n$$\n其中 $\\sigma$、$\\rho$ 和 $\\beta$ 是未知的正参数。您将仅在离散时间观测存在加性噪声的 $x$ 分量。假设观测模型为\n$$\ny_i = x(t_i \\mid \\sigma,\\rho,\\beta) + \\varepsilon_i, \\quad \\varepsilon_i \\sim \\mathcal{N}(0,\\tau^2),\n$$\n其中噪声标准差 $\\tau$、初始条件 $(x(0),y(0),z(0))$ 以及均匀时间步长 $\\Delta t$（使得 $t_i = i \\Delta t$）已知。前向映射 $(\\sigma,\\rho,\\beta) \\mapsto x(t_i \\mid \\sigma,\\rho,\\beta)$ 是通过在指定时间网格上从初始条件开始对洛伦兹系统进行数值积分来定义的。对于数值积分，请使用步长等于 $\\Delta t$ 的固定步长四阶龙格—库塔格式。\n\n假设参数的独立均匀先验为：\n$$\n\\sigma \\sim \\mathrm{Uniform}([5,15]), \\quad \\rho \\sim \\mathrm{Uniform}([0,40]), \\quad \\beta \\sim \\mathrm{Uniform}([2,3]).\n$$\n使用一个张量积参数网格，其中包含 $n_\\sigma = 11$ 个线性间隔点，范围为 $[5,15]$；$n_\\rho = 17$ 个线性间隔点，范围为 $[0,40]$；以及 $n_\\beta = 11$ 个线性间隔点，范围为 $[2,3]$。将此先验与观测模型所蕴含的高斯似然相结合，以获得 $(\\sigma,\\rho,\\beta)$ 上的后验分布。使用该网格近似后验分布，并报告每个测试案例中各参数的后验均值。\n\n测试套件包含 3 个案例，分别指定了用于生成合成观测值的真实参数、初始状态、时间步长、观测区间数量、观测噪声标准差以及一个固定的随机种子。对于每个案例，通过使用真实参数模拟洛伦兹系统并在给定种子的基础上添加独立高斯噪声，在内部生成观测值。然后，仅使用带噪观测值（而非真实参数），按上文所述对 $(\\sigma,\\rho,\\beta)$ 执行贝叶斯推断，并输出每个参数的后验均值。\n\n测试套件：\n- 案例 1（混沌，中等噪声）：\n  - 真实参数： $\\sigma^\\star = 10$，$\\rho^\\star = 28$，$\\beta^\\star = 8/3$。\n  - 初始条件： $(x(0),y(0),z(0)) = (-8, 8, 27)$。\n  - 时间步长： $\\Delta t = 0.02$。\n  - 区间数量： $N = 60$ (因此有 $N+1 = 61$ 个观测时间 $t_i$)。\n  - 噪声标准差： $\\tau = 1.0$。\n  - 随机种子： $314159$。\n- 案例 2（混沌，短序列，较高噪声）：\n  - 真实参数： $\\sigma^\\star = 12$，$\\rho^\\star = 35$，$\\beta^\\star = 2.5$。\n  - 初始条件： $(x(0),y(0),z(0)) = (0, 1, 1.05)$。\n  - 时间步长： $\\Delta t = 0.02$。\n  - 区间数量： $N = 40$ (因此有 $N+1 = 41$ 个观测时间 $t_i$)。\n  - 噪声标准差： $\\tau = 2.0$。\n  - 随机种子： $271828$。\n- 案例 3（非混沌，低噪声）：\n  - 真实参数： $\\sigma^\\star = 9$，$\\rho^\\star = 5$，$\\beta^\\star = 2.2$。\n  - 初始条件： $(x(0),y(0),z(0)) = (1, 1, 1)$。\n  - 时间步长： $\\Delta t = 0.02$。\n  - 区间数量： $N = 40$ (因此有 $N+1 = 41$ 个观测时间 $t_i$)。\n  - 噪声标准差： $\\tau = 0.2$。\n  - 随机种子： $42$。\n\n重要实现约束：\n- 使用步长为 $\\Delta t$ 的固定步长四阶龙格—库塔积分器来获得 $i=0,\\dots,N$ 的 $x(t_i \\mid \\sigma,\\rho,\\beta)$。不要使用任何自适应方案。\n- 使用指定的张量积网格，其点数为 $n_\\sigma = 11$、$n_\\rho = 17$、$n_\\beta = 11$。\n- 通过对网格上未归一化的后验权重进行归一化来计算每个参数的后验均值。在需要时使用数值稳定的指数运算策略。\n- 对于每个案例，返回四舍五入到 3 位小数的 $(\\sigma,\\rho,\\beta)$ 的后验均值。\n\n最终输出格式：\n- 您的程序应生成单行内容，包含一个含三个列表的列表，每个内部列表包含该案例的三个后验均值，顺序为 $[\\hat{\\sigma},\\hat{\\rho},\\hat{\\beta}]$。格式必须严格为\n$$\n[[\\hat{\\sigma}_1,\\hat{\\rho}_1,\\hat{\\beta}_1],[\\hat{\\sigma}_2,\\hat{\\rho}_2,\\hat{\\beta}_2],[\\hat{\\sigma}_3,\\hat{\\rho}_3,\\hat{\\beta}_3]]\n$$\n每个数字四舍五入到 3 位小数且无空格。", "solution": "所提出的问题是关于一个常微分方程系统（具体为洛伦兹系统）的贝叶斯参数估计练习。任务是从单个状态变量 $x(t)$ 的带噪观测值中推断参数 $(\\sigma, \\rho, \\beta)$。在进行求解之前，必须对问题陈述进行严格的验证。\n\n**问题验证**\n\n**第 1 步：提取已知条件**\n\n问题提供了以下信息：\n- **动力学系统**：洛伦兹系统，由以下方程定义：\n$$\n\\frac{dx}{dt} = \\sigma (y - x), \\quad\n\\frac{dy}{dt} = x (\\rho - z) - y, \\quad\n\\frac{dz}{dt} = x y - \\beta z\n$$\n- **观测模型**：在离散时间 $t_i = i \\Delta t$ 对状态变量 $x$ 的带噪观测值 $y_i$：\n$$\ny_i = x(t_i \\mid \\sigma,\\rho,\\beta) + \\varepsilon_i, \\quad \\text{其中 } \\varepsilon_i \\sim \\mathcal{N}(0,\\tau^2)\n$$\n- **已知量**：对于推断任务，初始条件 $(x(0),y(0),z(0))$、均匀时间步长 $\\Delta t$ 和噪声标准差 $\\tau$ 是已知的。\n- **数值方法**：前向映射 $(\\sigma,\\rho,\\beta) \\mapsto x(t_i)$ 将通过使用固定步长四阶龙格-库塔格式，以时间步长 $\\Delta t$ 进行计算。\n- **先验分布**：假设参数具有独立的均匀先验：\n$$\n\\sigma \\sim \\mathrm{Uniform}([5,15]), \\quad \\rho \\sim \\mathrm{Uniform}([0,40]), \\quad \\beta \\sim \\mathrm{Uniform}([2,3])\n$$\n- **参数网格**：一个张量积网格，具有 $n_\\sigma = 11$、$n_\\rho = 17$ 和 $n_\\beta = 11$ 个线性间隔点，覆盖先验的支撑集。\n- **任务**：为三个测试案例计算每个参数 $(\\sigma, \\rho, \\beta)$ 的后验均值。\n- **测试案例**：\n    - **案例 1**：真实参数 $(\\sigma^\\star, \\rho^\\star, \\beta^\\star) = (10, 28, 8/3)$。初始条件 $(x(0),y(0),z(0)) = (-8, 8, 27)$。时间步长 $\\Delta t = 0.02$。区间数量 $N = 60$。噪声 $\\tau = 1.0$。随机种子 $= 314159$。\n    - **案例 2**：真实参数 $(\\sigma^\\star, \\rho^\\star, \\beta^\\star) = (12, 35, 2.5)$。初始条件 $(x(0),y(0),z(0)) = (0, 1, 1.05)$。时间步长 $\\Delta t = 0.02$。区间数量 $N = 40$。噪声 $\\tau = 2.0$。随机种子 $= 271828$。\n    - **案例 3**：真实参数 $(\\sigma^\\star, \\rho^\\star, \\beta^\\star) = (9, 5, 2.2)$。初始条件 $(x(0),y(0),z(0)) = (1, 1, 1)$。时间步长 $\\Delta t = 0.02$。区间数量 $N = 40$。噪声 $\\tau = 0.2$。随机种子 $= 42$。\n- **输出格式**：一个单行字符串，表示一个包含三个列表的列表，每个内部列表包含每个案例的后验均值 $[\\hat{\\sigma}, \\hat{\\rho}, \\hat{\\beta}]$，四舍五入到 3 位小数。\n\n**第 2 步：使用提取的已知条件进行验证**\n\n根据既定标准对该问题进行评估：\n1.  **符合科学依据**：该问题建立在标准原理之上。洛伦兹系统是混沌理论中的一个典型模型，贝叶斯推断是统计学的基本方法论，而龙格-库塔方法是常微分方程数值分析的基石。该问题在科学上是合理的。\n2.  **适定性**：该问题是适定的。它要求基于一个完全指定的模型、数据生成过程和计算算法（基于网格的近似）来计算后验均值。指令精确，对于给定的随机种子，可得出一个唯一的、确定性的结果。\n3.  **客观性**：该问题以清晰、客观的数学语言陈述，没有歧义或主观解释。\n4.  **完整性与一致性**：该问题是自洽的。所有必要的组成部分——模型、先验、似然、数值方法、数据生成参数和网格规格——都已明确提供。没有矛盾之处。\n5.  **可行性**：指定的任务是一个合成数据实验，这是方法验证的标准做法。计算负荷涉及在一个短时间跨度（$N \\le 60$ 步）内对一个小型 ODE 系统进行 $11 \\times 17 \\times 11 = 2057$ 次积分，这在现代硬件上是完全可行的。\n\n**第 3 步：结论与行动**\n\n问题陈述有效、完整且适定。我们可以继续进行求解。\n\n**解法推导**\n\n目标是给定一组带噪观测值 $Y = \\{y_0, y_1, \\dots, y_N\\}$，计算参数 $\\theta = (\\sigma, \\rho, \\beta)$ 的后验均值。\n\n**1. 贝叶斯框架**\n根据贝叶斯定理，给定数据时参数的后验概率分布为：\n$$\np(\\theta | Y) = \\frac{p(Y | \\theta) p(\\theta)}{p(Y)} \\propto p(Y | \\theta) p(\\theta)\n$$\n其中 $p(Y | \\theta)$ 是似然，$p(\\theta)$ 是先验。\n\n先验分布 $p(\\theta)$ 被指定为在一个超矩形上的均匀分布：\n$$\np(\\theta) = p(\\sigma)p(\\rho)p(\\beta) \\propto \\mathbb{I}(\\sigma \\in [5,15]) \\cdot \\mathbb{I}(\\rho \\in [0,40]) \\cdot \\mathbb{I}(\\beta \\in [2,3])\n$$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数。由于计算网格完全位于此支撑集内，因此对于所有网格点，先验是常数，在计算后验比例时可以忽略。\n\n似然 $p(Y | \\theta)$ 由观测模型确定。噪声项 $\\varepsilon_i$ 是独立同分布的，服从高斯分布 $\\mathcal{N}(0, \\tau^2)$。对于给定的参数集 $\\theta$，观测到数据序列 $Y$ 的似然是每个观测概率的乘积：\n$$\np(Y | \\theta) = \\prod_{i=0}^{N} p(y_i | \\theta) = \\prod_{i=0}^{N} \\frac{1}{\\sqrt{2\\pi\\tau^2}} \\exp\\left( -\\frac{(y_i - x(t_i | \\theta))^2}{2\\tau^2} \\right)\n$$\n其中 $x(t_i | \\theta)$ 是参数为 $\\theta$ 时洛伦兹系统在时间 $t_i$ 的 $x$ 分量的解。\n\n为了数值稳定性，最好使用对数似然：\n$$\n\\log p(Y | \\theta) = \\sum_{i=0}^{N} \\left( -\\frac{1}{2}\\log(2\\pi\\tau^2) - \\frac{(y_i - x(t_i | \\theta))^2}{2\\tau^2} \\right)\n$$\n由于在网格上后验与似然成正比，我们有：\n$$\np(\\theta | Y) \\propto \\exp\\left( -\\frac{1}{2\\tau^2} \\sum_{i=0}^{N} (y_i - x(t_i | \\theta))^2 \\right)\n$$\n项 $\\sum_{i=0}^{N} (y_i - x(t_i | \\theta))^2$ 是观测值与参数为 $\\theta$ 的模型预测之间的平方误差和 (SSE)。\n\n**2. 数值近似**\n连续的参数空间被离散化为一个有限网格。设网格点为 $\\theta_j$，其中 $j=1, \\dots, M$，且 $M = n_\\sigma n_\\rho n_\\beta$。\n\n- **前向模型仿真**：对于每个网格点 $\\theta_j = (\\sigma, \\rho, \\beta)$，使用给定的初始条件对洛伦兹系统进行数值积分，以获得预测轨迹 $\\{x(t_i | \\theta_j)\\}_{i=0}^N$。问题指定了使用固定时间步长 $\\Delta t$ 的四阶龙格-库塔 (RK4) 方法。对于状态向量 $\\mathbf{s} = (x,y,z)$ 和常微分方程 $\\frac{d\\mathbf{s}}{dt} = f(t, \\mathbf{s})$，RK4 的一步是：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 &= f(t_n, \\mathbf{s}_n) \\\\\n\\mathbf{k}_2 &= f(t_n + \\frac{\\Delta t}{2}, \\mathbf{s}_n + \\frac{\\Delta t}{2}\\mathbf{k}_1) \\\\\n\\mathbf{k}_3 &= f(t_n + \\frac{\\Delta t}{2}, \\mathbf{s}_n + \\frac{\\Delta t}{2}\\mathbf{k}_2) \\\\\n\\mathbf{k}_4 &= f(t_n + \\Delta t, \\mathbf{s}_n + \\Delta t\\mathbf{k}_3) \\\\\n\\mathbf{s}_{n+1} &= \\mathbf{s}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n\\end{aligned}\n$$\n\n- **后验权重计算**：对于每个网格点 $\\theta_j$，我们计算未归一化的对数后验值 $S_j = -\\frac{1}{2\\tau^2} \\text{SSE}(\\theta_j)$。未归一化的后验权重为 $w_j = \\exp(S_j)$。为防止数值上溢或下溢，我们使用一种稳定化技术。设 $S_{\\max} = \\max_j S_j$。稳定化后的权重计算为 $w'_j = \\exp(S_j - S_{\\max})$。\n\n- **后验均值估计**：每个参数后验均值的离散近似是在网格上的加权平均值。对于参数 $\\sigma$，其计算公式为：\n$$\n\\hat{\\sigma} = \\mathbb{E}[\\sigma | Y] \\approx \\frac{\\sum_j \\sigma_j w'_j}{\\sum_j w'_j}\n$$\n$\\hat{\\rho}$ 和 $\\hat{\\beta}$ 的计算公式类似。\n\n**3. 算法步骤**\n\n对于三个测试案例中的每一个：\n1.  **生成数据**：使用指定的真实参数 $(\\sigma^\\star, \\rho^\\star, \\beta^\\star)$、初始条件、时间步长 $\\Delta t$ 和区间数量 $N$，通过 RK4 积分器模拟洛伦兹系统以生成真实轨迹 $\\{x(t_i)\\}_{i=0}^N$。使用提供的随机种子添加标准差为 $\\tau$ 的高斯噪声，以产生观测集 $\\{y_i\\}_{i=0}^N$。\n2.  **定义参数网格**：根据指定的范围和点数，为 $\\sigma$、$\\rho$ 和 $\\beta$ 构建参数值数组。\n3.  **遍历网格**：对于张量积网格中的每个点 $(\\sigma_k, \\rho_l, \\beta_m)$：\n    a. 使用这些参数通过 RK4 积分器模拟洛伦兹系统，以获得预测轨迹 $\\{\\hat{x}_i\\}_{i=0}^N$。\n    b. 计算 SSE：$\\sum_{i=0}^{N} (y_i - \\hat{x}_i)^2$。\n    c. 计算并存储未归一化的对数后验值：$S_{klm} = -\\frac{\\text{SSE}}{2\\tau^2}$。\n4.  **计算后验均值**：\n    a. 找到所有计算出的对数后验值的最大值 $S_{\\max}$。\n    b. 计算归一化的后验权重：$W_{klm} = \\exp(S_{klm} - S_{\\max}) / \\sum_{k',l',m'} \\exp(S_{k'l'm'} - S_{\\max})$。\n    c. 计算后验均值作为加权和：\n    $$\n    \\hat{\\sigma} = \\sum_{k,l,m} \\sigma_k W_{klm}, \\quad \\hat{\\rho} = \\sum_{k,l,m} \\rho_l W_{klm}, \\quad \\hat{\\beta} = \\sum_{k,l,m} \\beta_m W_{klm}\n    $$\n5.  **存储并格式化结果**：将四舍五入到三位小数的三元组 $[\\hat{\\sigma}, \\hat{\\rho}, \\hat{\\beta}]$ 存储起来。在处理完所有案例后，将收集到的结果格式化为所需的字符串表示。\n这个系统化的程序将被实现以得出最终答案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lorenz_rhs(state, sigma, rho, beta):\n    \"\"\"\n    Computes the derivatives of the Lorenz system.\n    Note: The system is autonomous, so the time `t` is not used.\n    \"\"\"\n    x, y, z = state\n    dx_dt = sigma * (y - x)\n    dy_dt = x * (rho - z) - y\n    dz_dt = x * y - beta * z\n    return np.array([dx_dt, dy_dt, dz_dt])\n\ndef rk4_integrator(rhs, initial_state, num_steps, dt, *params):\n    \"\"\"\n    Fixed-step fourth-order Runge-Kutta integrator.\n    Produces a trajectory of num_steps + 1 states.\n    \"\"\"\n    num_vars = len(initial_state)\n    states = np.zeros((num_steps + 1, num_vars))\n    states[0] = initial_state\n    \n    current_state = initial_state.copy()\n    \n    for i in range(num_steps):\n        k1 = rhs(current_state, *params)\n        k2 = rhs(current_state + 0.5 * dt * k1, *params)\n        k3 = rhs(current_state + 0.5 * dt * k2, *params)\n        k4 = rhs(current_state + dt * k3, *params)\n        \n        current_state += (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n        states[i + 1] = current_state\n        \n    return states\n\ndef solve():\n    \"\"\"\n    Main function to solve the Bayesian inference problem for the Lorenz system.\n    \"\"\"\n    test_cases = [\n        # Case 1 (chaotic, moderate noise)\n        {\n            \"true_params\": (10.0, 28.0, 8.0/3.0),\n            \"initial_cond\": np.array([-8.0, 8.0, 27.0]),\n            \"dt\": 0.02,\n            \"N\": 60,\n            \"tau\": 1.0,\n            \"seed\": 314159\n        },\n        # Case 2 (chaotic, short series, higher noise)\n        {\n            \"true_params\": (12.0, 35.0, 2.5),\n            \"initial_cond\": np.array([0.0, 1.0, 1.05]),\n            \"dt\": 0.02,\n            \"N\": 40,\n            \"tau\": 2.0,\n            \"seed\": 271828\n        },\n        # Case 3 (non-chaotic, low noise)\n        {\n            \"true_params\": (9.0, 5.0, 2.2),\n            \"initial_cond\": np.array([1.0, 1.0, 1.0]),\n            \"dt\": 0.02,\n            \"N\": 40,\n            \"tau\": 0.2,\n            \"seed\": 42\n        }\n    ]\n\n    # Define the parameter grid\n    n_sigma, n_rho, n_beta = 11, 17, 11\n    sigma_vals = np.linspace(5, 15, n_sigma)\n    rho_vals = np.linspace(0, 40, n_rho)\n    beta_vals = np.linspace(2, 3, n_beta)\n\n    all_results = []\n    \n    for case in test_cases:\n        # 1. Generate synthetic observations\n        rng = np.random.default_rng(case[\"seed\"])\n        true_trajectory = rk4_integrator(\n            lorenz_rhs, \n            case[\"initial_cond\"], \n            case[\"N\"], \n            case[\"dt\"], \n            *case[\"true_params\"]\n        )\n        x_true = true_trajectory[:, 0]\n        noise = rng.normal(loc=0.0, scale=case[\"tau\"], size=case[\"N\"] + 1)\n        observations_y = x_true + noise\n        \n        # 2. Perform grid search to compute posterior distribution\n        log_posterior = np.zeros((n_sigma, n_rho, n_beta))\n        \n        for i, sigma_val in enumerate(sigma_vals):\n            for j, rho_val in enumerate(rho_vals):\n                for k, beta_val in enumerate(beta_vals):\n                    # Simulate forward model for this grid point\n                    sim_params = (sigma_val, rho_val, beta_val)\n                    sim_trajectory = rk4_integrator(\n                        lorenz_rhs,\n                        case[\"initial_cond\"],\n                        case[\"N\"],\n                        case[\"dt\"],\n                        *sim_params\n                    )\n                    x_sim = sim_trajectory[:, 0]\n                    \n                    # Calculate Sum of Squared Errors (SSE)\n                    sse = np.sum((observations_y - x_sim)**2)\n                    \n                    # Calculate log posterior (proportional to -SSE), ignoring constants\n                    log_posterior[i, j, k] = -sse / (2 * case[\"tau\"]**2)\n\n        # 3. Calculate posterior means from the grid-based posterior\n        # Use log-sum-exp trick for numerical stability\n        log_posterior -= np.max(log_posterior)\n        posterior_weights = np.exp(log_posterior)\n        \n        total_weight = np.sum(posterior_weights)\n        \n        # Use numpy broadcasting to compute weighted sums efficiently\n        sigma_mean = np.sum(posterior_weights * sigma_vals[:, None, None]) / total_weight\n        rho_mean = np.sum(posterior_weights * rho_vals[None, :, None]) / total_weight\n        beta_mean = np.sum(posterior_weights * beta_vals[None, None, :]) / total_weight\n        \n        case_results = [\n            round(sigma_mean, 3), \n            round(rho_mean, 3), \n            round(beta_mean, 3)\n        ]\n        all_results.append(case_results)\n\n    # 4. Format the final output string\n    # Using str() and replace() to ensure the exact format without spaces\n    output_str = str(all_results).replace(' ', '')\n    print(output_str)\n\nsolve()\n```", "id": "2374071"}]}