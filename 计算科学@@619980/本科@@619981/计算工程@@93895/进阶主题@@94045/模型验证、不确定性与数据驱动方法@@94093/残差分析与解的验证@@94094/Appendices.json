{"hands_on_practices": [{"introduction": "我们的第一个练习探讨了计算科学中的一个基本挑战：求解病态线性系统。当一个系统近似奇异时，直接求解可能高度不稳定，并且对数据中的微小噪声非常敏感。本实践将演示吉洪诺夫正则化 (Tikhonov regularization) 如何通过平衡数据保真度与解的稳定性来引入一个稳定的解，并使用*原始*系统的残差作为关键的诊断工具。[@problem_id:2432713]", "problem": "给定一系列形式为 $A\\mathbf{x}=\\mathbf{b}$ 的线性系统，其中矩阵 $A$ 是近奇异或秩亏的。考虑由目标函数\n$$\nJ(\\mathbf{x})=\\lVert A\\mathbf{x}-\\mathbf{b}\\rVert_2^2+\\alpha^2\\lVert \\mathbf{x}\\rVert_2^2,\n$$\n定义的 Tikhonov 正则化问题，其中 $\\alpha > 0$ 是正则化参数。该目标函数的驻定条件导出了正则化正规方程组\n$$\n\\left(A^{\\mathsf{T}}A+\\alpha^2 I\\right)\\mathbf{x}=A^{\\mathsf{T}}\\mathbf{b}.\n$$\n你的任务是，对于每个指定的测试用例，计算满足上述方程组的唯一 Tikhonov 解 $\\mathbf{x}_\\alpha$，并分析原始未正则化系统的残差。对于每个测试用例，你必须计算以下量：\n- 原始残差二范数 $r_{\\mathrm{norm}}=\\lVert A\\mathbf{x}_\\alpha-\\mathbf{b}\\rVert_2$。\n- 相对原始残差二范数 $r_{\\mathrm{rel}}=\\dfrac{\\lVert A\\mathbf{x}_\\alpha-\\mathbf{b}\\rVert_2}{\\lVert \\mathbf{b}\\rVert_2}$。\n- 正则化正规方程残差的二范数 $q_{\\mathrm{norm}}=\\left\\lVert\\left(A^{\\mathsf{T}}A+\\alpha^2 I\\right)\\mathbf{x}_\\alpha-A^{\\mathsf{T}}\\mathbf{b}\\right\\rVert_2$。\n\n使用下面列出的精确矩阵、向量和参数。在每个案例中，$I$ 表示尺寸与 $A$ 的列数相匹配的单位矩阵。所有量都是无量纲的。\n\n测试套件：\n- 案例 1 (方阵，近奇异)：\n  - $A_1=\\begin{bmatrix}\n  1 & 1 & 1\\\\\n  1 & 1 & 1+10^{-8}\\\\\n  1 & 1+10^{-8} & 1\n  \\end{bmatrix}$，\n  $\\mathbf{x}_{\\mathrm{true},1}=\\begin{bmatrix}1\\\\-1\\\\1\\end{bmatrix}$，\n  $\\boldsymbol{\\eta}_1=\\begin{bmatrix}10^{-10}\\\\-10^{-10}\\\\10^{-10}\\end{bmatrix}$，\n  $\\mathbf{b}_1=A_1\\mathbf{x}_{\\mathrm{true},1}+\\boldsymbol{\\eta}_1$，\n  $\\alpha_1=10^{-2}$。\n- 案例 2 (与案例 1 相同的 $A_1$ 和 $\\mathbf{b}_1$，但正则化较弱)：\n  - $\\alpha_2=10^{-6}$。\n- 案例 3 (方阵，秩亏)：\n  - $A_3=\\begin{bmatrix}\n  1 & 2 & 3\\\\\n  2 & 4 & 6\\\\\n  3 & 6 & 9\n  \\end{bmatrix}$，\n  $\\mathbf{x}_{\\mathrm{true},3}=\\begin{bmatrix}1\\\\0\\\\0\\end{bmatrix}$，\n  $\\boldsymbol{\\eta}_3=\\begin{bmatrix}10^{-3}\\\\-10^{-3}\\\\2\\cdot 10^{-3}\\end{bmatrix}$，\n  $\\mathbf{b}_3=A_3\\mathbf{x}_{\\mathrm{true},3}+\\boldsymbol{\\eta}_3$，\n  $\\alpha_3=10^{-1}$。\n- 案例 4 (超定的，病态的，Hilbert 型)：\n  - $A_4=\\begin{bmatrix}\n  1 & \\tfrac{1}{2} & \\tfrac{1}{3}\\\\\n  \\tfrac{1}{2} & \\tfrac{1}{3} & \\tfrac{1}{4}\\\\\n  \\tfrac{1}{3} & \\tfrac{1}{4} & \\tfrac{1}{5}\\\\\n  \\tfrac{1}{4} & \\tfrac{1}{5} & \\tfrac{1}{6}\n  \\end{bmatrix}$，\n  $\\mathbf{x}_{\\mathrm{true},4}=\\begin{bmatrix}1\\\\0\\\\-1\\end{bmatrix}$，\n  $\\boldsymbol{\\eta}_4=\\begin{bmatrix}10^{-6}\\\\-10^{-6}\\\\10^{-6}\\\\-10^{-6}\\end{bmatrix}$，\n  $\\mathbf{b}_4=A_4\\mathbf{x}_{\\mathrm{true},4}+\\boldsymbol{\\eta}_4$，\n  $\\alpha_4=10^{-3}$。\n\n对于每个案例 $k\\in\\{1,2,3,4\\}$，从 $\\left(A_k^{\\mathsf{T}}A_k+\\alpha_k^2 I\\right)\\mathbf{x}=A_k^{\\mathsf{T}}\\mathbf{b}_k$ 计算出 $\\mathbf{x}_{\\alpha_k}$，然后计算上面定义的 $r_{\\mathrm{norm}}$、$r_{\\mathrm{rel}}$ 和 $q_{\\mathrm{norm}}$。\n\n最终输出格式：\n- 你的程序应产生单行输出，包含一个长度为 4 的列表，其中第 $k$ 个元素是一个长度为 3 的列表，按顺序包含案例 $k$ 的值 $[r_{\\mathrm{norm}},r_{\\mathrm{rel}},q_{\\mathrm{norm}}]$。该列表必须用方括号括起来，并用逗号分隔，且包含浮点数。这些值可以以编程语言产生的十进制或科学记数法形式出现。不应打印任何额外文本。", "solution": "该问题要求使用 Tikhonov 正则化求解不适定线性系统，并分析所得残差。该问题在科学上是合理的、定义明确的，并且所有必要的数据都已提供。我们着手求解。\n\n对于矩阵 $A$ 是奇异或病态（即具有大条件数）的线性系统 $A\\mathbf{x}=\\mathbf{b}$，其根本问题在于解 $\\mathbf{x}$ 对右端向量 $\\mathbf{b}$ 的扰动极其敏感。此类问题在科学和工程中很常见，尤其是在反演问题中，其中 $\\mathbf{b}$ 代表包含噪声的测量数据。\n\nTikhonov 正则化通过找到一个近似解 $\\mathbf{x}_\\alpha$ 来最小化一个修正的目标函数，从而解决这个问题：\n$$\nJ(\\mathbf{x})=\\lVert A\\mathbf{x}-\\mathbf{b}\\rVert_2^2+\\alpha^2\\lVert \\mathbf{x}\\rVert_2^2\n$$\n在此，第一项 $\\lVert A\\mathbf{x}-\\mathbf{b}\\rVert_2^2$ 是残差的平方范数，用于衡量解对数据的保真度。第二项 $\\alpha^2\\lVert \\mathbf{x}\\rVert_2^2$ 是正则化项，用于惩罚具有大欧几里得范数的解。正则化参数 $\\alpha > 0$ 控制着两者之间的权衡：较大的 $\\alpha$ 强调解的稳定性（较小的范数），但以牺牲数据保真度为代价；而较小的 $\\alpha$ 则优先拟合数据，这可能导致一个不稳定的解，其中包含了大量的噪声。\n\n为了找到最小化 $J(\\mathbf{x})$ 的向量 $\\mathbf{x}_\\alpha$，我们必须找到 $J(\\mathbf{x})$ 关于 $\\mathbf{x}$ 的梯度为零向量的位置。目标函数可以写成矩阵形式：\n$$\nJ(\\mathbf{x}) = (A\\mathbf{x}-\\mathbf{b})^{\\mathsf{T}}(A\\mathbf{x}-\\mathbf{b}) + \\alpha^2 \\mathbf{x}^{\\mathsf{T}}\\mathbf{x} = \\mathbf{x}^{\\mathsf{T}}A^{\\mathsf{T}}A\\mathbf{x} - 2\\mathbf{b}^{\\mathsf{T}}A\\mathbf{x} + \\mathbf{b}^{\\mathsf{T}}\\mathbf{b} + \\alpha^2 \\mathbf{x}^{\\mathsf{T}}\\mathbf{x}\n$$\n关于 $\\mathbf{x}$ 的梯度是：\n$$\n\\nabla_{\\mathbf{x}} J(\\mathbf{x}) = 2A^{\\mathsf{T}}A\\mathbf{x} - 2A^{\\mathsf{T}}\\mathbf{b} + 2\\alpha^2\\mathbf{x}\n$$\n令 $\\nabla_{\\mathbf{x}} J(\\mathbf{x}) = \\mathbf{0}$ 即可得到前述的正则化正规方程组：\n$$\n\\left(A^{\\mathsf{T}}A+\\alpha^2 I\\right)\\mathbf{x}=A^{\\mathsf{T}}\\mathbf{b}\n$$\n矩阵 $A^{\\mathsf{T}}A$ 总是半正定的。对于任何 $\\alpha > 0$，矩阵 $C = A^{\\mathsf{T}}A+\\alpha^2 I$ 都是正定的。这是因为它的所有特征值都严格为正，这保证了它是可逆的，并且存在唯一的解 $\\mathbf{x}_\\alpha$。\n\n每个测试用例的计算步骤如下：\n1. 根据案例 $k \\in \\{1, 2, 3, 4\\}$ 的规定，构造矩阵 $A_k$ 和向量 $\\mathbf{x}_{\\mathrm{true},k}$、$\\boldsymbol{\\eta}_k$。\n2. 计算右端向量 $\\mathbf{b}_k = A_k\\mathbf{x}_{\\mathrm{true},k} + \\boldsymbol{\\eta}_k$。\n3. 构建正则化系统的矩阵 $C_k = A_k^{\\mathsf{T}}A_k + \\alpha_k^2 I$，其中 $I$ 是维度与 $A_k$ 列数相匹配的单位矩阵。\n4. 构建正则化系统的右端项 $\\mathbf{d}_k = A_k^{\\mathsf{T}}\\mathbf{b}_k$。\n5. 求解适定线性系统 $C_k \\mathbf{x}_{\\alpha_k} = \\mathbf{d}_k$ 以找到 Tikhonov 解 $\\mathbf{x}_{\\alpha_k}$。\n6. 计算所需的分析量：\n   a. 原始残差二范数: $r_{\\mathrm{norm}} = \\lVert A_k\\mathbf{x}_{\\alpha_k}-\\mathbf{b}_k\\rVert_2$。这衡量了正则化解对原始未正则化系统的满足程度。\n   b. 相对原始残差二范数: $r_{\\mathrm{rel}} = \\frac{\\lVert A_k\\mathbf{x}_{\\alpha_k}-\\mathbf{b}_k\\rVert_2}{\\lVert \\mathbf{b}_k\\rVert_2}$。这将残差通过数据向量的范数进行归一化。\n   c. 正则化正规方程残差的二范数: $q_{\\mathrm{norm}} = \\lVert C_k\\mathbf{x}_{\\alpha_k} - \\mathbf{d}_k\\rVert_2$。这个量可作为用于求解 $\\mathbf{x}_{\\alpha_k}$ 的线性求解器精度的数值检验。对于精确计算，它应为零。在浮点运算中，其值应接近机器精度，并按 $C_k$ 的条件数进行缩放。\n\n对四个指定的测试用例分别执行此过程。矩阵 $A_1$、$A_3$ 和 $A_4$ 分别被选为近奇异、精确奇异（秩亏）和病态，代表了需要正则化的典型场景。案例 1 ($\\alpha_1 = 10^{-2}$) 和案例 2 ($\\alpha_2 = 10^{-6}$) 之间的比较特别有启发性，因为它展示了正则化参数的大小对解及其残差的影响。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Tikhonov-regularized solutions and associated residuals for a suite of\n    ill-posed linear systems.\n    \"\"\"\n\n    def process_case(A, b, alpha):\n        \"\"\"\n        Solves the Tikhonov regularized system and computes the required norms.\n\n        Args:\n            A (np.ndarray): The system matrix.\n            b (np.ndarray): The right-hand side vector.\n            alpha (float): The regularization parameter.\n\n        Returns:\n            list: A list containing [r_norm, r_rel, q_norm].\n        \"\"\"\n        num_cols = A.shape[1]\n        I = np.identity(num_cols)\n\n        # Form the regularized normal equations: (A.T @ A + alpha^2 * I) @ x = A.T @ b\n        C = A.T @ A + alpha**2 * I\n        d = A.T @ b\n\n        # Solve for the Tikhonov solution x_alpha\n        x_alpha = np.linalg.solve(C, d)\n\n        # 1. Compute the original residual two-norm: r_norm = ||A*x_alpha - b||_2\n        r_norm = np.linalg.norm(A @ x_alpha - b)\n\n        # 2. Compute the relative original residual two-norm: r_rel = ||A*x_alpha - b||_2 / ||b||_2\n        # np.linalg.norm(b) cannot be zero for the given problem settings.\n        r_rel = r_norm / np.linalg.norm(b)\n\n        # 3. Compute the two-norm of the regularized normal equation residual:\n        #    q_norm = ||(A.T*A + alpha^2*I)*x_alpha - A.T*b||_2\n        q_norm = np.linalg.norm(C @ x_alpha - d)\n\n        return [r_norm, r_rel, q_norm]\n\n    # --- Test Case 1 ---\n    eps1 = 1e-8\n    A1 = np.array([\n        [1.0, 1.0, 1.0],\n        [1.0, 1.0, 1.0 + eps1],\n        [1.0, 1.0 + eps1, 1.0]\n    ])\n    x_true1 = np.array([1.0, -1.0, 1.0])\n    eta1 = np.array([1e-10, -1e-10, 1e-10])\n    b1 = A1 @ x_true1 + eta1\n    alpha1 = 1e-2\n\n    # --- Test Case 2 ---\n    # A2 and b2 are the same as A1 and b1\n    alpha2 = 1e-6\n\n    # --- Test Case 3 ---\n    A3 = np.array([\n        [1.0, 2.0, 3.0],\n        [2.0, 4.0, 6.0],\n        [3.0, 6.0, 9.0]\n    ])\n    x_true3 = np.array([1.0, 0.0, 0.0])\n    eta3 = np.array([1e-3, -1e-3, 2e-3])\n    b3 = A3 @ x_true3 + eta3\n    alpha3 = 1e-1\n\n    # --- Test Case 4 ---\n    A4 = np.array([\n        [1.0, 1/2, 1/3],\n        [1/2, 1/3, 1/4],\n        [1/3, 1/4, 1/5],\n        [1/4, 1/5, 1/6]\n    ])\n    x_true4 = np.array([1.0, 0.0, -1.0])\n    eta4 = np.array([1e-6, -1e-6, 1e-6, -1e-6])\n    b4 = A4 @ x_true4 + eta4\n    alpha4 = 1e-3\n\n    test_cases = [\n        (A1, b1, alpha1),\n        (A1, b1, alpha2),\n        (A3, b3, alpha3),\n        (A4, b4, alpha4),\n    ]\n\n    results = []\n    for case in test_cases:\n        A, b, alpha = case\n        result_metrics = process_case(A, b, alpha)\n        results.append(result_metrics)\n\n    # Format the final output as a string representation of a list of lists.\n    # e.g., [[val1, val2, val3],[val4, val5, val6],...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2432713"}, {"introduction": "我们如何确保我们的模拟代码是正确的？接下来的这个练习为代码验证的实践提供了强有力的见解。通过在一个有限元方法 (FEM) 模拟中故意引入一个错误，您将亲眼看到代码中的局部错误如何在残差场中表现为独特且局部化的模式，如同一个清晰的调试“指纹”。[@problem_id:2432735]", "problem": "您需要编写一个完整的、自包含的程序，为一典型的椭圆型边值问题构建并分析其一维有限元近似，并定量地揭示在单个局部基函数中故意引入的缺陷如何在离散残差场中产生非物理模式。考虑闭区间 $[0,1]$ 上的以下边值问题：\n寻找 $u:[0,1] \\rightarrow \\mathbb{R}$，使得对于 $x \\in (0,1)$，有 $-u''(x)=f(x)$，并且 $u(0)=0$，$u(1)=0$，其中 $f(x)=1$。\n\n设 $N \\in \\mathbb{N}$ 表示 $[0,1]$ 的均匀子区间的数量，节点为 $x_i = i h$, $h = 1/N$, $i=0,1,\\dots,N$。设 $\\{\\varphi_i\\}_{i=0}^N$ 表示与这些节点相关的标准分段线性拉格朗日基函数，并设 $V_h$ 是相关的试验函数与检验函数空间，该空间由在 $[0,1]$ 上连续、在每个子区间上线性且满足 $u_h(0)=u_h(1)=0$ 的函数组成。标准的伽辽金(Galerkin)格式要求找到 $u_h \\in V_h$，使得对于所有 $v_h \\in V_h$，\n$$\n\\int_{0}^{1} u_h'(x)\\,v_h'(x)\\,dx = \\int_{0}^{1} f(x)\\,v_h(x)\\,dx.\n$$\n\n通过引入一种单元素基函数缺陷来定义此离散问题的一个缺陷变体，具体如下。选择一个元素索引 $e^\\star \\in \\{0,1,\\dots,N-1\\}$。仅在该元素上，即子区间 $[x_{e^\\star}, x_{e^\\star+1}]$ 上，将与左端点相关的局部基函数替换为其负值：$\\tilde{\\varphi}_{e^\\star}|_{[x_{e^\\star}, x_{e^\\star+1}]} = -\\,\\varphi_{e^\\star}|_{[x_{e^\\star}, x_{e^\\star+1}]}$，同时保持右侧的局部基函数不变：$\\tilde{\\varphi}_{e^\\star+1}|_{[x_{e^\\star}, x_{e^\\star+1}]} = \\varphi_{e^\\star+1}|_{[x_{e^\\star}, x_{e^\\star+1}]}$。在该元素上，对试验函数和检验函数均使用这些有缺陷的局部基函数。在所有其他元素上，使用标准基函数。设 $u_h^{\\mathrm{def}}$ 表示从这个带有齐次狄利克雷(Dirichlet)边界条件的缺陷离散系统获得的唯一离散解。\n\n将真实的有限元残差向量 $r \\in \\mathbb{R}^{N-1}$（按内部节点 $\\{1,2,\\dots,N-1\\}$ 索引）定义为将正确的（无缺陷的）离散算子应用于 $u_h^{\\mathrm{def}}$ 所得到的精确代数残差，\n$$\nr_i \\;=\\; \\sum_{j=1}^{N-1} K^{\\mathrm{corr}}_{ij}\\, (u_h^{\\mathrm{def}})_j \\;-\\; F^{\\mathrm{corr}}_i,\\quad i=1,2,\\dots,N-1,\n$$\n其中 $K^{\\mathrm{corr}}$ 和 $F^{\\mathrm{corr}}$ 是由 $f(x)=1$ 和齐次狄利克雷边界条件的正确（无缺陷）标准伽辽金格式产生的刚度矩阵和载荷向量。向量 $u_h^{\\mathrm{def}}$ 是限制在内部自由度上的缺陷解。\n\n对于给定的数对 $(N,e^\\star)$，计算 $r$ 的以下两个标量诊断值：\n1. 残差的无穷范数，\n$$\n\\|r\\|_{\\infty} \\;=\\; \\max_{1 \\le i \\le N-1} |r_i|.\n$$\n2. 局部化比率\n$$\nL \\;=\\; \\frac{\\sum_{i \\in I_{\\mathrm{def}}} r_i^2}{\\sum_{i=1}^{N-1} r_i^2},\n$$\n其中 $I_{\\mathrm{def}}$ 是位于缺陷元素 $[x_{e^\\star},x_{e^\\star+1}]$ 上的内部节点索引集合，即 $I_{\\mathrm{def}} = \\{i \\in \\{1,\\dots,N-1\\} : i \\in \\{e^\\star, e^\\star+1\\}\\}$。在“无缺陷”的特殊情况下，按惯例定义 $L=0$。\n\n测试套件。您的程序必须评估以下四组参数：\n- 情况1：$N=8$, $e^\\star=4$.\n- 情况2：$N=8$, $e^\\star=1$.\n- 情况3：$N=32$, $e^\\star=16$.\n- 情况4：$N=8$，无缺陷（在所有元素上使用正确的基）。\n\n答案规格。对于每种情况，您的程序必须计算并返回有序对 $[\\|r\\|_{\\infty}, L]$ 作为实数。最终的程序输出必须是单行文本，其中包含按情况顺序排列的这四个有序对的列表，格式为用方括号括起来的逗号分隔列表，例如，\n\"[[a,b],[c,d],[e,f],[g,h]]\",\n其中 $a,b,c,d,e,f,g,h$ 是对应情况的浮点数。不涉及物理单位。不出现角度。不出现百分比。", "solution": "提交问题陈述进行验证。\n\n步骤1：提取已知条件\n- 微分方程：$-u''(x)=f(x)$ 对于 $x \\in (0,1)$。\n- 强迫函数：$f(x)=1$。\n- 边界条件：$u(0)=0$, $u(1)=0$。\n- 离散化：在 $[0,1]$ 上有 $N$ 个均匀子区间，节点为 $x_i = i h$, $h = 1/N$，对于 $i=0,1,\\dots,N$。\n- 有限元空间：$V_h$ 是在 $[0,1]$ 上连续、分段线性的函数空间，且在 $x=0$ 和 $x=1$ 处为零。基函数是标准的拉格朗日基函数 $\\{\\varphi_i\\}_{i=1}^{N-1}$。\n- 标准伽辽金格式：寻找 $u_h \\in V_h$ 使得对于所有 $v_h \\in V_h$，有 $\\int_{0}^{1} u_h'(x)\\,v_h'(x)\\,dx = \\int_{0}^{1} f(x)\\,v_h(x)\\,dx$。\n- 缺陷基函数定义：对于选定的元素 $e^\\star \\in \\{0,1,\\dots,N-1\\}$，在子区间 $[x_{e^\\star}, x_{e^\\star+1}]$ 上，与左端点 $x_{e^\\star}$ 相关的局部基函数被替换为其负值：$\\tilde{\\varphi}_{e^\\star}|_{[x_{e^\\star}, x_{e^\\star+1}]} = -\\,\\varphi_{e^\\star}|_{[x_{e^\\star}, x_{e^\\star+1}]}$。右端点的基函数不变。此缺陷基用于该元素上的试验函数和检验函数。\n- 缺陷解：$u_h^{\\mathrm{def}}$ 是使用带缺陷的伽辽金系统的解。\n- 残差向量定义：$r_i = \\sum_{j=1}^{N-1} K^{\\mathrm{corr}}_{ij}\\, (u_h^{\\mathrm{def}})_j - F^{\\mathrm{corr}}_i$ 对于 $i=1,2,\\dots,N-1$，其中 $K^{\\mathrm{corr}}$ 和 $F^{\\mathrm{corr}}$ 是正确（无缺陷）的刚度矩阵和载荷向量，而 $(u_h^{\\mathrm{def}})_j$ 是缺陷解在内部节点处的节点值。\n- 诊断值1：$\\|r\\|_{\\infty} = \\max_{1 \\le i \\le N-1} |r_i|$。\n- 诊断值2：$L = \\frac{\\sum_{i \\in I_{\\mathrm{def}}} r_i^2}{\\sum_{i=1}^{N-1} r_i^2}$，其中 $I_{\\mathrm{def}} = \\{i \\in \\{1,\\dots,N-1\\} : i \\in \\{e^\\star, e^\\star+1\\}\\}$。对于“无缺陷”情况，$L=0$。\n- 测试套件：\n  - 情况1：$N=8$, $e^\\star=4$。\n  - 情况2：`N=8`, `e^\\star=1`。\n  - 情况3：`N=32`, `e^\\star=16`。\n  - 情况4：`N=8`，无缺陷。\n\n步骤2：使用提取的已知条件进行验证\n- **科学依据充分**：该问题基于标准且成熟的有限元方法，用于求解二阶椭圆型边值问题（泊松方程）。引入特定基函数缺陷以研究其对残差的影响，是计算工程和数值分析中一个有效且富有启发性的练习。它模拟了一种可能出现的编程错误。\n- **适定性**：该问题是适定的。该方程的标准伽辽金格式产生一个对称正定刚度矩阵，保证了唯一解的存在。在组装后，缺陷单元刚度矩阵对于给定情况会形成一个非奇异的全局缺陷刚度矩阵，从而确保存在唯一的缺陷解 $u_h^{\\mathrm{def}}$。残差和后续的诊断值由明确的确定性公式定义。所有需要的信息都已提供。\n- **客观性**：问题以精确的数学语言表述，没有歧义、主观性或个人观点。\n\n步骤3：结论与行动\n问题有效。可以且必须构建一个严谨的解决方案。\n\n任务是为给定的边值问题实现有限元方法，包括标准形式和带有特定局部缺陷的形式，然后分析由此产生的误差。分析的关键在于构建正确的代数系统并评估指定的诊断值。\n\n首先，我们建立标准（正确）的有限元格式。弱形式为：寻找 $u_h \\in V_h$，使得对所有 $v_h \\in V_h$ 均有 $a(u_h, v_h) = l(v_h)$，其中双线性形式为 $a(u, v) = \\int_{0}^{1} u'(x)v'(x)dx$，线性泛函为 $l(v) = \\int_{0}^{1} f(x)v(x)dx$。解在内部节点的基中展开，$u_h(x) = \\sum_{j=1}^{N-1} U_j \\varphi_j(x)$，其中 $U_j$ 是未知的节点值。这导出了线性系统 $K^{\\mathrm{corr}} U = F^{\\mathrm{corr}}$，其中刚度矩阵和载荷向量的项为 $K^{\\mathrm{corr}}_{ij} = a(\\varphi_j, \\varphi_i)$ 和 $F^{\\mathrm{corr}}_i = l(\\varphi_i)$。\n\n在一个长度为 $h=1/N$ 的通用元素 $[x_k, x_{k+1}]$ 上，两个局部基函数（表示为 $\\psi_1$ 和 $\\psi_2$）的导数分别为 $\\psi_1'(x) = -1/h$ 和 $\\psi_2'(x) = 1/h$。正确的单元刚度矩阵 $k^{\\mathrm{corr}}$ 是：\n$$\nk^{\\mathrm{corr}}_{ij} = \\int_{x_k}^{x_{k+1}} \\psi_i'(x) \\psi_j'(x) dx = \\frac{1}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}\n$$\n当 $f(x)=1$ 时，正确的单元载荷向量 $f^{\\mathrm{corr}}$ 是：\n$$\nf^{\\mathrm{corr}}_{i} = \\int_{x_k}^{x_{k+1}} 1 \\cdot \\psi_i(x) dx = \\frac{h}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}\n$$\n\n接下来，我们构建缺陷系统。缺陷被引入到单个元素 $e^\\star$，即区间 $[x_{e^\\star}, x_{e^\\star+1}]$ 上。左节点的局部基函数 $\\varphi_{e^\\star}$ 被替换为其负值。我们将此元素上的标准局部基函数表示为 $\\psi_1$（用于左节点）和 $\\psi_2$（用于右节点）。标准导数为 $\\psi_1'(x)=-1/h$ 和 $\\psi_2'(x)=1/h$。缺陷基函数变为 $\\tilde{\\psi}_1 = -\\psi_1$ 和 $\\tilde{\\psi}_2 = \\psi_2$。它们的导数是 $\\tilde{\\psi}_1'(x) = -(-1/h) = 1/h$ 和 $\\tilde{\\psi}_2'(x) = 1/h$。\n缺陷单元刚度矩阵 $k^{\\mathrm{def}}$ 使用这些修改后的导数计算：\n$$\nk^{\\mathrm{def}}_{ij} = \\int_{x_{e^\\star}}^{x_{e^\\star+1}} \\tilde{\\psi}_i'(x) \\tilde{\\psi}_j'(x) dx = \\int_{x_{e^\\star}}^{x_{e^\\star+1}} \\frac{1}{h^2} dx = \\frac{1}{h} \\begin{pmatrix} 1 & 1 \\\\ 1 & 1 \\end{pmatrix}\n$$\n缺陷单元载荷向量 $f^{\\mathrm{def}}$ 使用修改后的基函数计算：\n$$\nf^{\\mathrm{def}}_{1} = \\int_{x_{e^\\star}}^{x_{e^\\star+1}} 1 \\cdot \\tilde{\\psi}_1(x) dx = \\int 1 \\cdot (-\\psi_1(x)) dx = -\\frac{h}{2}\n$$\n$$\nf^{\\mathrm{def}}_{2} = \\int_{x_{e^\\star}}^{x_{e^\\star+1}} 1 \\cdot \\tilde{\\psi}_2(x) dx = \\int 1 \\cdot \\psi_2(x) dx = \\frac{h}{2}\n$$\n所以，$f^{\\mathrm{def}} = \\frac{h}{2} \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix}$。\n\n为了找到缺陷解 $u_h^{\\mathrm{def}}$，我们组装全局缺陷系统 $K^{\\mathrm{def}}U^{\\mathrm{def}} = F^{\\mathrm{def}}$。这是通过对所有元素的贡献求和来完成的，对所有元素 $e \\neq e^\\star$ 使用 $k^{\\mathrm{corr}}$ 和 $f^{\\mathrm{corr}}$，对元素 $e=e^\\star$ 使用 $k^{\\mathrm{def}}$ 和 $f^{\\mathrm{def}}$。然后求解得到的 $(N-1) \\times (N-1)$ 线性系统，得到内部节点值的向量 $U^{\\mathrm{def}}$。\n\n分析的核心是计算真实的残差向量 $r$。它被定义为将缺陷解 $U^{\\mathrm{def}}$ 代入*正确*方程组后剩下的部分：$r = K^{\\mathrm{corr}} U^{\\mathrm{def}} - F^{\\mathrm{corr}}$。一个重要的洞察是，残差 $r$ 仅在属于缺陷元素的节点（即节点 $e^\\star$ 和 $e^\\star+1$）处非零。这是因为对于任何不对应这些节点的行 $i$，缺陷系统的第 $i$ 个方程与正确系统的第 $i$ 个方程相同，因此 $(K^{\\mathrm{corr}}U^{\\mathrm{def}})_i - F^{\\mathrm{corr}}_i = (K^{\\mathrm{def}}U^{\\mathrm{def}})_i - F^{\\mathrm{def}}_i = 0$。\n\n最后，我们从残差向量 $r$ 计算两个诊断值。\n1. 无穷范数 $\\|r\\|_{\\infty}$，是 $r$ 各分量绝对值的最大值。\n2. 局部化比率 $L$。鉴于 $r_i$ 仅在 $i \\in I_{\\mathrm{def}} = \\{e^\\star, e^\\star+1\\} \\cap \\{1, ..., N-1\\}$ 时非零，L 的分子中的和 $\\sum_{i \\in I_{\\mathrm{def}}} r_i^2$ 将等于分母中的和 $\\sum_{i=1}^{N-1} r_i^2$。因此，对于任何有缺陷的情况，$L$ 必须恰好为 $1$。对于无缺陷的情况，$U^{\\mathrm{def}}$ 是真解 $U^{\\mathrm{corr}}$，所以 $r = K^{\\mathrm{corr}}U^{\\mathrm{corr}} - F^{\\mathrm{corr}}$ 理论上是零向量。由于浮点运算，其范数将是一个接近机器精度的小数。根据问题的约定，在这种情况下我们设 $L=0$。\n\n实现将遵循以下步骤：\n1. 对于每个测试用例 $(N, e^\\star)$，定义 $h=1/N$。\n2. 构建并组装全局缺陷矩阵 $K^{\\mathrm{def}}$ 和 $F^{\\mathrm{def}}$。\n3. 求解系统 $K^{\\mathrm{def}}U^{\\mathrm{def}} = F^{\\mathrm{def}}$ 以获得 $U^{\\mathrm{def}}$。\n4. 构建全局正确矩阵 $K^{\\mathrm{corr}}$ 和 $F^{\\mathrm{corr}}$。\n5. 计算残差向量 $r = K^{\\mathrm{corr}} U^{\\mathrm{def}} - F^{\\mathrm{corr}}$。\n6. 根据 $r$ 计算 $\\|r\\|_{\\infty}$ 和 $L$。对于无缺陷的情况，特殊处理将 $L$ 设为0。\n7. 存储并按规定格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble(N, h, k_elem, f_elem, apply_bc=True):\n    \"\"\"\n    Assembles the global stiffness matrix and load vector.\n    \n    Args:\n        N (int): Number of subintervals.\n        h (float): Element size.\n        k_elem (np.ndarray): 2x2 element stiffness matrix.\n        f_elem (np.ndarray): 2x1 element load vector.\n        apply_bc (bool): If True, assemble for interior nodes only.\n    \n    Returns:\n        (np.ndarray, np.ndarray): Global stiffness matrix and load vector.\n    \"\"\"\n    if apply_bc:\n        num_dofs = N - 1\n        K = np.zeros((num_dofs, num_dofs))\n        F = np.zeros(num_dofs)\n        \n        for e in range(N):\n            # Global node indices for element e\n            g_idx = [e, e + 1]\n            \n            for i_loc in range(2):\n                for j_loc in range(2):\n                    g_i, g_j = g_idx[i_loc], g_idx[j_loc]\n                    # Check if both nodes are interior\n                    if 1 <= g_i <= N - 1 and 1 <= g_j <= N - 1:\n                        # Map global node index to matrix index\n                        m_i, m_j = g_i - 1, g_j - 1\n                        K[m_i, m_j] += k_elem[i_loc, j_loc]\n                \n                # Assemble load vector (once per row)\n                g_i = g_idx[i_loc]\n                if 1 <= g_i <= N - 1:\n                    m_i = g_i - 1\n                    F[m_i] += f_elem[i_loc]\n    else: # Not used in this problem, but for completeness\n        num_dofs = N + 1\n        K = np.zeros((num_dofs, num_dofs))\n        F = np.zeros(num_dofs)\n        for e in range(N):\n            g_idx = [e, e + 1]\n            K[np.ix_(g_idx, g_idx)] += k_elem\n            F[g_idx] += f_elem\n            \n    return K, F\n\ndef solve_case(N, e_star):\n    \"\"\"\n    Solves one case of the FEM problem with an optional defect.\n\n    Args:\n        N (int): Number of subintervals.\n        e_star (int or None): Index of the defective element. If None, no defect.\n\n    Returns:\n        list: A list containing [||r||_infinity, L].\n    \"\"\"\n    h = 1.0 / N\n    dof = N - 1\n\n    # Define correct element matrices\n    k_corr = (1.0 / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n    f_corr = (h / 2.0) * np.array([1.0, 1.0])\n\n    # Define defective element matrices\n    k_def = (1.0 / h) * np.array([[1.0, 1.0], [1.0, 1.0]])\n    f_def = (h / 2.0) * np.array([-1.0, 1.0])\n\n    # 1. Assemble the defective system (K_def, F_def)\n    K_def_glob = np.zeros((dof, dof))\n    F_def_glob = np.zeros(dof)\n\n    for e in range(N):\n        is_defective_element = (e_star is not None and e == e_star)\n        k_e = k_def if is_defective_element else k_corr\n        f_e = f_def if is_defective_element else f_corr\n        \n        g_nodes = [e, e + 1]\n        for i_loc in range(2):\n            g_i = g_nodes[i_loc]\n            if 1 <= g_i <= N - 1:\n                m_i = g_i - 1\n                F_def_glob[m_i] += f_e[i_loc]\n                for j_loc in range(2):\n                    g_j = g_nodes[j_loc]\n                    if 1 <= g_j <= N - 1:\n                        m_j = g_j - 1\n                        K_def_glob[m_i, m_j] += k_e[i_loc, j_loc]\n\n    # 2. Solve for the defective solution U_def\n    U_def = np.linalg.solve(K_def_glob, F_def_glob)\n\n    # 3. Assemble the correct system (K_corr, F_corr)\n    # The correct global matrix is tridiagonal\n    K_corr_glob = np.zeros((dof, dof))\n    F_corr_glob = np.zeros(dof)\n    main_diag = 2.0 / h\n    off_diag = -1.0 / h\n    np.fill_diagonal(K_corr_glob, main_diag)\n    np.fill_diagonal(K_corr_glob[1:], off_diag)\n    np.fill_diagonal(K_corr_glob[:, 1:], off_diag)\n    # The correct load vector is constant h\n    F_corr_glob.fill(h)\n\n    # 4. Compute the residual r = K_corr * U_def - F_corr\n    r = K_corr_glob @ U_def - F_corr_glob\n\n    # 5. Compute diagnostics\n    # ||r||_infinity\n    r_inf_norm = np.linalg.norm(r, ord=np.inf)\n\n    # Localization ratio L\n    if e_star is None:\n        # Per problem specification for \"no defect\" case\n        L = 0.0\n    else:\n        # Identify interior node indices on the defective element\n        # Problem indices are 1-based, numpy are 0-based\n        num_indices = []\n        # Node e_star is interior if 1 <= e_star <= N-1\n        if 1 <= e_star <= N - 1:\n            num_indices.append(e_star - 1)\n        # Node e_star+1 is interior if 1 <= e_star+1 <= N-1\n        if 1 <= e_star + 1 <= N - 1:\n            num_indices.append(e_star)\n        \n        if not num_indices:\n             # This can happen if defect is on boundary element e.g. e_star=0 with N>1\n             # and we only consider node e_star+1.\n            if 1 <= e_star+1 <= N-1: \n                num_indices.append(e_star)\n            else: # should not be reached with problem constraints\n                L = 0.0\n\n        num_sum_sq = np.sum(r[num_indices]**2)\n        den_sum_sq = np.sum(r**2)\n        \n        if den_sum_sq < 1e-15: # Avoid division by zero\n            L = 0.0\n        else:\n            L = num_sum_sq / den_sum_sq\n\n    return [r_inf_norm, L]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        {'N': 8, 'e_star': 4},         # Case 1\n        {'N': 8, 'e_star': 1},         # Case 2\n        {'N': 32, 'e_star': 16},       # Case 3\n        {'N': 8, 'e_star': None},      # Case 4 (no defect)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case['N'], case['e_star'])\n        results.append(result)\n\n    # Format the final output string exactly as specified\n    formatted_pairs = [f\"[{item[0]},{item[1]}]\" for item in results]\n    final_string = f\"[{','.join(formatted_pairs)}]\"\n    print(final_string)\n\nsolve()\n```", "id": "2432735"}, {"introduction": "在我们最后一个也是最高级的实践中，我们将从定性验证转向对特定工程输出进行定量误差估计。本练习介绍了功能强大的对偶加权残差 (DWR) 方法，这是计算流体动力学 (CFD) 和其他领域中现代目标导向自适应方法的基石。您将学习如何利用一个相关的“伴随”问题的解来对系统残差进行加权，从而在不知道精确解的情况下，获得对目标量（如升力或阻力）误差的精确估计。[@problem_id:2432787]", "problem": "考虑在单位正方形域 $\\Omega = (0,1) \\times (0,1)$ 上，流经翼型的计算流体动力学 (CFD) 气流的一个稳态线性代理模型。令未知场为 $u : \\Omega \\to \\mathbb{R}$，由线性对流扩散算子控制\n$$\n\\mathcal{L}u = -\\nu \\Delta u + \\boldsymbol{\\beta} \\cdot \\nabla u = s,\n$$\n其狄利克雷边界数据为 $u|_{\\partial \\Omega} = g$。取源项 $s \\equiv 0$。边界数据规定如下：在 $x=0$ 的入流边界上，对于 $y \\in [0,1]$，$g(0,y) = \\sin(2\\pi y)$；在 $\\partial \\Omega$ 的其他三个边上（即 $x=1$、$y=0$、$y=1$），施加 $g = 0$。对流速度 $\\boldsymbol{\\beta} = (\\beta_x,\\beta_y)$ 为常数，扩散系数为 $\\nu > 0$。\n\n令 $u \\in H^1(\\Omega)$ 表示该边值问题的精确解，令 $J(u)$ 表示由 $u$ 在一个矩形区域 $\\mathcal{S}$ 上的空间平均值定义的目标标量，该区域代表物体附近升力敏感区的代理模型：\n$$\nJ(u) = \\frac{1}{|\\mathcal{S}|} \\iint_{\\mathcal{S}} u(x,y) \\, dx \\, dy, \\quad \\mathcal{S} = [0.6,0.8] \\times [0.45,0.55].\n$$\n\n在均匀笛卡尔网格上对问题进行离散化，每个坐标方向有 $N$ 个内部点，网格间距为 $h = 1/(N+1)$。内部网格点记为 $(x_i,y_j) = (ih,jh)$，其中 $i,j \\in \\{1,\\dots,N\\}$。对扩散算子使用标准的二阶中心差分5点格式，对对流项的每个分量使用一阶迎风有限差分。具体来说，对于一个内部节点 $(i,j)$，作用于节点值 $u_{i,j}$ 的离散算子 $A \\in \\mathbb{R}^{N^2 \\times N^2}$ 由下式给出\n$$\n(Au)_{i,j} = \\frac{\\nu}{h^2}\\left(4 u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}\\right) + \\text{conv}_x(u)_{i,j} + \\text{conv}_y(u)_{i,j},\n$$\n其中迎风对流项为\n$$\n\\text{conv}_x(u)_{i,j} =\n\\begin{cases}\n\\displaystyle \\beta_x \\frac{u_{i,j} - u_{i-1,j}}{h}, & \\text{if } \\beta_x \\ge 0, \\\\[1.0ex]\n\\displaystyle \\beta_x \\frac{u_{i+1,j} - u_{i,j}}{h}, & \\text{if } \\beta_x  0,\n\\end{cases}\n\\quad\n\\text{and}\n\\quad\n\\text{conv}_y(u)_{i,j} =\n\\begin{cases}\n\\displaystyle \\beta_y \\frac{u_{i,j} - u_{i,j-1}}{h},  \\text{if } \\beta_y \\ge 0, \\\\[1.0ex]\n\\displaystyle \\beta_y \\frac{u_{i,j+1} - u_{i,j}}{h},  \\text{if } \\beta_y  0.\n\\end{cases}\n$$\n狄利克雷边界值 $g$ 是通过以下方式施加的：当格式中的邻点位于内部区域之外时，将其贡献合并到离散右端项 $f \\in \\mathbb{R}^{N^2}$ 中。特别地，对于 $x=0$ 处的左边界，使用 $g(0,y_j) = \\sin(2\\pi y_j)$；所有其他边界均有 $g=0$。\n\n对于具有 $N$ 个内部点的网格，将离散目标量定义为\n$$\nJ_h(u_h) = \\frac{1}{m} \\sum_{(i,j)\\in \\mathcal{I}_h} u_{i,j},\n$$\n其中 $\\mathcal{I}_h = \\{(i,j): x_i \\in [0.6,0.8],\\ y_j \\in [0.45,0.55]\\}$ 是该区域内内部节点的索引集合，$m$ 是此类节点的数量。\n\n假设给定一个在粗网格上计算出的离散近似解 $\\tilde{u}_{H}$，其网格间距为 $H = 1/(N_H+1)$ 且 $N_H  N_h$。现在要求在无法获得精确解 $u$ 的情况下，估计目标量的误差 $J(u) - J(\\tilde{u}_H)$。为此，考虑使用参数 $(\\nu,\\beta_x,\\beta_y)$ 和网格尺寸 $N_h$ 如上构造的细网格算子 $A_h \\in \\mathbb{R}^{N_h^2 \\times N_h^2}$ 和右端项 $f_h \\in \\mathbb{R}^{N_h^2}$。通过使用与狄利克雷边界值 $g$ 一致的双线性插值，将 $\\tilde{u}_H$ 延拓到细网格上，从而形成粗网格解的细网格代理。\n\n您的任务是编写一个完整、可运行的程序，对下方的每个测试用例，构造 $A_h$、$f_h$、延拓后的细网格向量 $\\tilde{u}_h$、残差 $r_h = f_h - A_h \\tilde{u}_h$ 以及一个将 $J_h(\\cdot)$ 表示为线性泛函的细网格向量 $c_h \\in \\mathbb{R}^{N_h^2}$，使得 $J_h(u_h) = c_h^\\top u_h$。然后，仅使用这些组成部分，根据细网格上线性残差加权的第一性原理，计算 $J(u) - J(\\tilde{u}_H)$ 的标量误差估计 $\\eta$。将 $\\eta$ 以十进制实数形式报告。\n\n测试套件：\n- 案例 1：$\\nu = 0.05$, $\\beta_x = 1.0$, $\\beta_y = 0.0$, $N_H = 16$, $N_h = 32$。\n- 案例 2：$\\nu = 0.01$, $\\beta_x = 2.0$, $\\beta_y = 1.0$, $N_H = 24$, $N_h = 48$。\n- 案例 3：$\\nu = 0.10$, $\\beta_x = 0.0$, $\\beta_y = 0.0$, $N_H = 16$, $N_h = 32$。\n- 案例 4：$\\nu = 0.05$, $\\beta_x = 1.0$, $\\beta_y = -1.0$, $N_H = 8$, $N_h = 16$。\n\n角度单位不适用。输出中不含物理单位。对于每个案例，将最终的标量结果表示为小数点后四舍五入到六位的小数。\n\n最终输出格式：\n您的程序应产生单行输出，其中包含四个误差估计值的结果，按上述案例的顺序排列，用逗号分隔并用方括号括起来。例如，使用占位符值的输出如下所示\n$$\n[\\eta_1,\\eta_2,\\eta_3,\\eta_4],\n$$\n其中每个 $\\eta_k$ 是一个小数点后四舍五入到六位的小数。", "solution": "所提出的问题是一个有效且适定的计算工程任务。它要求为一个从二维线性稳态对流扩散方程的解中派生出的标量目标量，实现一个后验误差估计器。该方法基于有限差分离散化和对偶加权残差 (DWR) 误差估计的原理。\n\n任务的核心是为一个在粗网格上计算的近似解 $\\tilde{u}_H$ 估计其目标量 $J(u)$ 的误差。该误差的估计无需获得精确解 $u$。问题要求估计 $J(u) - J(\\tilde{u}_H)$。我们将遵循标准方法，即在更细的网格上计算 DWR 误差表示。\n\n令控制偏微分方程 $\\mathcal{L}u = s$ 的细网格离散化由以下线性系统给出：\n$$\nA_h u_h = f_h\n$$\n其中 $u_h \\in \\mathbb{R}^{N_h^2}$ 是 $N_h^2$ 个内部网格节点上的未知值向量，$A_h \\in \\mathbb{R}^{N_h^2 \\times N_h^2}$ 是离散算子，$f_h \\in \\mathbb{R}^{N_h^2}$ 是包含源项（本例中为零）和边界条件的右端向量。下标 $h$ 表示与间距为 $h = 1/(N_h+1)$ 的细网格相关的量。解 $u_h$ 是精确解 $u$ 的一个细网格近似。\n\n标量目标量 $J(u)$ 也在细网格上进行离散化。由于它是 $u$ 的一个线性泛函，其离散对应项可以写成与向量 $c_h \\in \\mathbb{R}^{N_h^2}$ 的内积：\n$$\nJ_h(u_h) = c_h^\\top u_h\n$$\n\n我们给定一个在具有 $N_H$ 个内部点和间距 $H = 1/(N_H+1)$ 的粗网格上计算出的解 $\\tilde{u}_H$。该解被延拓（插值）到细网格上，得到向量 $\\tilde{u}_h \\in \\mathbb{R}^{N_h^2}$。这个延拓向量可作为细网格解 $u_h$ 的一个近似。\n\n细网格解的误差定义为 $e_h = u_h - \\tilde{u}_h$。目标量中的相应误差为：\n$$\nJ_h(u_h) - J_h(\\tilde{u}_h) = c_h^\\top u_h - c_h^\\top \\tilde{u}_h = c_h^\\top (u_h - \\tilde{u}_h) = c_h^\\top e_h\n$$\n误差向量 $e_h$ 满足其自身的线性系统。通过将 $u_h = e_h + \\tilde{u}_h$ 代入细网格系统，我们得到：\n$$\nA_h (e_h + \\tilde{u}_h) = f_h \\implies A_h e_h = f_h - A_h \\tilde{u}_h\n$$\n项 $r_h = f_h - A_h \\tilde{u}_h$ 是延拓后的粗网格解在细网格上的残差。它衡量了 $\\tilde{u}_h$ 满足细网格方程的程度。因此，误差方程为 $A_h e_h = r_h$。\n\n为了在不求解 $e_h$ (这等同于求解原始的细网格问题) 的情况下评估目标量的误差 $c_h^\\top e_h$，我们引入一个对偶或伴随问题。离散伴随问题定义为求解一个向量 $\\psi_h \\in \\mathbb{R}^{N_h^2}$，使其满足：\n$$\nA_h^\\top \\psi_h = c_h\n$$\n向量 $\\psi_h$ 代表了目标量对局部残差的敏感度。\n\n使用伴随解，我们可以将目标量的误差表示如下：\n$$\nJ_h(u_h) - J_h(\\tilde{u}_h) = c_h^\\top e_h = (A_h^\\top \\psi_h)^\\top e_h = \\psi_h^\\top (A_h e_h) = \\psi_h^\\top r_h\n$$\n这个最终表达式 $\\psi_h^\\top r_h$ 提供了所需的误差估计，我们将其记为 $\\eta$。它是通过计算伴随问题的解与原始问题残差的内积得到的。这是目标导向误差估计中的一种标准且强大的技术。假定项 $J(u) - J_h(u_h)$ 相对于 $\\eta$ 所代表的误差是次要的。\n\n每个测试用例的计算步骤如下：\n1.  **粗网格求解**：对于给定的参数 $(\\nu, \\boldsymbol{\\beta})$ 和网格尺寸 $N_H$，构造粗网格矩阵 $A_H$ 和右端项 $f_H$。求解线性系统 $A_H \\tilde{u}_H = f_H$ 以获得粗网格解向量 $\\tilde{u}_H$。\n2.  **延拓**：通过包含指定的狄利克雷边界值，形成一个完整的粗网格节点场。对此场使用双线性插值，以找到细网格内部节点位置处的解值。这将得到延拓解向量 $\\tilde{u}_h$。\n3.  **细网格残差**：为网格尺寸 $N_h$ 构造细网格矩阵 $A_h$ 和右端向量 $f_h$。计算细网格残差 $r_h = f_h - A_h \\tilde{u}_h$。\n4.  **伴随解**：构造代表离散目标量的向量 $c_h$。求解伴随系统 $A_h^\\top \\psi_h = c_h$ 以获得伴随解 $\\psi_h$。\n5.  **误差估计**：将标量误差估计计算为点积 $\\eta = \\psi_h^\\top r_h$。\n\n此程序将为所提供的四个测试用例中的每一个实现。", "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse import linalg as sla\nfrom scipy.interpolate import RegularGridInterpolator\n\ndef assemble_system(N, nu, beta_x, beta_y):\n    \"\"\"\n    Assembles the sparse matrix A and RHS vector f for the discretized\n    convection-diffusion problem on an N x N interior grid.\n    \n    Args:\n        N (int): Number of interior grid points in one dimension.\n        nu (float): Diffusion coefficient.\n        beta_x (float): Convection velocity in x.\n        beta_y (float): Convection velocity in y.\n        \n    Returns:\n        tuple: (scipy.sparse.csr_matrix, numpy.ndarray) representing A and f.\n    \"\"\"\n    h = 1.0 / (N + 1.0)\n    N2 = N * N\n    \n    # Use lists to build COO-format matrix data\n    data = []\n    row_ind = []\n    col_ind = []\n    f = np.zeros(N2)\n\n    nu_h2 = nu / (h * h)\n    beta_x_h = beta_x / h\n    beta_y_h = beta_y / h\n\n    beta_x_pos = max(0, beta_x_h)\n    beta_x_neg = min(0, beta_x_h)\n    beta_y_pos = max(0, beta_y_h)\n    beta_y_neg = min(0, beta_y_h)\n    \n    diag_coeff = 4.0 * nu_h2 + beta_x_pos - beta_x_neg + beta_y_pos - beta_y_neg\n\n    for j in range(1, N + 1):  # 1-based y-index of grid node\n        for i in range(1, N + 1):  # 1-based x-index of grid node\n            k = (j - 1) * N + (i - 1)  # 0-based row-major 1D index\n            \n            # Diagonal entry\n            data.append(diag_coeff)\n            row_ind.append(k)\n            col_ind.append(k)\n\n            # Neighbor u_{i, j-1}\n            if j  1:\n                data.append(-nu_h2 - beta_y_pos)\n                row_ind.append(k)\n                col_ind.append(k - N)\n            else:  # Boundary at y=0, g=0\n                f[k] += (nu_h2 + beta_y_pos) * 0.0\n\n            # Neighbor u_{i, j+1}\n            if j  N:\n                data.append(-nu_h2 + beta_y_neg)\n                row_ind.append(k)\n                col_ind.append(k + N)\n            else:  # Boundary at y=1, g=0\n                f[k] += (nu_h2 - beta_y_neg) * 0.0\n\n            # Neighbor u_{i-1, j}\n            if i  1:\n                data.append(-nu_h2 - beta_x_pos)\n                row_ind.append(k)\n                col_ind.append(k - 1)\n            else:  # Boundary at x=0, g=sin(2*pi*y)\n                y_j = j * h\n                g_val = np.sin(2.0 * np.pi * y_j)\n                f[k] += (nu_h2 + beta_x_pos) * g_val\n            \n            # Neighbor u_{i+1, j}\n            if i  N:\n                data.append(-nu_h2 + beta_x_neg)\n                row_ind.append(k)\n                col_ind.append(k + 1)\n            else:  # Boundary at x=1, g=0\n                f[k] += (nu_h2 - beta_x_neg) * 0.0\n\n    A = sparse.csr_matrix((data, (row_ind, col_ind)), shape=(N2, N2))\n    return A, f\n\ndef get_qoi_vector(N, h):\n    \"\"\"\n    Constructs the vector c that represents the QoI linear functional.\n    \"\"\"\n    N2 = N * N\n    c = np.zeros(N2)\n    \n    x_min, x_max = 0.6, 0.8\n    y_min, y_max = 0.45, 0.55\n\n    i_min = int(np.ceil(x_min / h))\n    i_max = int(np.floor(x_max / h))\n    j_min = int(np.ceil(y_min / h))\n    j_max = int(np.floor(y_max / h))\n    \n    node_indices = []\n    if i_min = i_max and j_min = j_max:\n        for j in range(j_min, j_max + 1):\n            for i in range(i_min, i_max + 1):\n                k = (j - 1) * N + (i - 1)\n                node_indices.append(k)\n    \n    m = len(node_indices)\n    if m  0:\n        c[node_indices] = 1.0 / m\n    \n    return c\n\ndef prolongate(u_H_vec, N_H, N_h):\n    \"\"\"\n    Prolongates a coarse grid solution to the fine grid using bilinear interpolation.\n    \"\"\"\n    u_H_grid = u_H_vec.reshape((N_H, N_H))\n    \n    u_H_full = np.zeros((N_H + 2, N_H + 2))\n    u_H_full[1:-1, 1:-1] = u_H_grid\n    \n    y_H_pts_full = np.linspace(0, 1, N_H + 2)\n    x_H_pts_full = np.linspace(0, 1, N_H + 2)\n    \n    u_H_full[:, 0] = np.sin(2 * np.pi * y_H_pts_full)  # x=0 boundary\n    # Other boundaries are already 0.0\n\n    # The interpolator expects values indexed as (y, x), which matches u_H_full[j,i]\n    interp_func = RegularGridInterpolator((y_H_pts_full, x_H_pts_full), u_H_full)\n\n    h_h = 1.0 / (N_h + 1.0)\n    x_h_pts_interior = np.arange(1, N_h + 1) * h_h\n    y_h_pts_interior = np.arange(1, N_h + 1) * h_h\n    \n    # Create evaluation points (yy, xx) with 'ij' indexing\n    yy_fine, xx_fine = np.meshgrid(y_h_pts_interior, x_h_pts_interior, indexing='ij')\n    eval_points = np.vstack([yy_fine.ravel(), xx_fine.ravel()]).T\n\n    u_h_tilde_vec = interp_func(eval_points)\n    \n    return u_h_tilde_vec\n\ndef compute_error_estimate(nu, beta_x, beta_y, N_H, N_h):\n    \"\"\"\n    Computes the DWR error estimate for a given set of parameters.\n    \"\"\"\n    # 1. Coarse grid solve\n    A_H, f_H = assemble_system(N_H, nu, beta_x, beta_y)\n    u_H = sla.spsolve(A_H, f_H)\n\n    # 2. Prolongate coarse solution to fine grid\n    u_h_tilde = prolongate(u_H, N_H, N_h)\n    \n    # 3. Fine grid setup and residual computation\n    h_h = 1.0 / (N_h + 1.0)\n    A_h, f_h = assemble_system(N_h, nu, beta_x, beta_y)\n    r_h = f_h - A_h @ u_h_tilde\n\n    # 4. Adjoint problem setup and solve\n    c_h = get_qoi_vector(N_h, h_h)\n    psi_h = sla.spsolve(A_h.transpose(), c_h)\n    \n    # 5. Compute error estimate\n    eta = psi_h.T @ r_h\n\n    return eta\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (nu, beta_x, beta_y, N_H, N_h)\n        (0.05, 1.0, 0.0, 16, 32),\n        (0.01, 2.0, 1.0, 24, 48),\n        (0.10, 0.0, 0.0, 16, 32),\n        (0.05, 1.0, -1.0, 8, 16),\n    ]\n\n    results = []\n    for case in test_cases:\n        nu, beta_x, beta_y, N_H, N_h = case\n        eta = compute_error_estimate(nu, beta_x, beta_y, N_H, N_h)\n        results.append(f\"{eta:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2432787"}]}