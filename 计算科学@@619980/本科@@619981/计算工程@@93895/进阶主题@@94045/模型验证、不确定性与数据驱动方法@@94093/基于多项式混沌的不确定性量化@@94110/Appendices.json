{"hands_on_practices": [{"introduction": "我们从一个基础练习开始，这个练习旨在帮助你熟悉多项式混沌展开 (PCE) 的代数操作。这个问题的核心是探索PCE的线性特性：当你对一个已经由PCE表示的模型输出进行线性变换时，新的PCE系数会如何变化？通过这个练习 [@problem_id:2448490]，你将加深对PCE系数如何编码信息的理解，特别是零阶基函数在表示均值或常数偏移中的关键作用。", "problem": "一个具有单一参数不确定性来源的标量计算模型输出由多项式混沌展开 (PCE) 表示。设输入随机变量为 $\\,\\xi\\,$，服从标准正态分布 $\\,\\mathcal{N}(0,1)\\,$。考虑与高斯测度相关的、由概率论学家的 Hermite 多项式构成的标准正交基，其前四个基函数为\n$$\\Phi_{0}(\\xi) = 1,\\quad \\Phi_{1}(\\xi) = \\xi,\\quad \\Phi_{2}(\\xi) = \\frac{\\xi^{2}-1}{\\sqrt{2}},\\quad \\Phi_{3}(\\xi) = \\frac{\\xi^{3}-3\\xi}{\\sqrt{6}},$$\n它们满足 $\\,\\mathbb{E}[\\Phi_{i}(\\xi)\\,\\Phi_{j}(\\xi)] = \\delta_{ij}\\,$。假设模型输出 $\\,Y(\\xi)\\,$ 具有一个截断至总阶数 $\\,3\\,$ 的 PCE，\n$$Y(\\xi) \\;=\\; 3\\,\\Phi_{0}(\\xi)\\;-\\;\\frac{1}{2}\\,\\Phi_{1}(\\xi)\\;+\\;\\sqrt{2}\\,\\Phi_{2}(\\xi)\\;-\\;2\\,\\Phi_{3}(\\xi).$$\n定义仿射变换后的输出 $\\,Z(\\xi) = a\\,Y(\\xi) + b\\,$，其中 $\\,a=-4\\,$ 和 $\\,b=5\\,$ 是确定性的无量纲常数。确定 $\\,Z(\\xi)\\,$ 在相同基 $\\,\\{\\Phi_{k}(\\xi)\\}_{k=0}^{3}\\,$ 中的 PCE。将您的最终答案表示为关于 $\\,\\Phi_{0}(\\xi),\\Phi_{1}(\\xi),\\Phi_{2}(\\xi),\\Phi_{3}(\\xi)\\,$ 的单一闭式解析表达式。请勿对您的答案进行四舍五入。", "solution": "该问题要求确定一个给定模型输出的仿射变换的多项式混沌展开 (PCE)，而该模型输出本身也由 PCE 表示。\n\n**步骤 1：问题验证**\n\n首先，有必要对问题陈述进行严格验证。\n\n提取的已知条件：\n1.  输入随机变量：$\\xi \\sim \\mathcal{N}(0,1)$，一个标准正态随机变量。\n2.  标准正交基：概率论学家的 Hermite 多项式 $\\{\\Phi_k(\\xi)\\}$。\n    - $\\Phi_{0}(\\xi) = 1$\n    - $\\Phi_{1}(\\xi) = \\xi$\n    - $\\Phi_{2}(\\xi) = \\frac{\\xi^{2}-1}{\\sqrt{2}}$\n    - $\\Phi_{3}(\\xi) = \\frac{\\xi^{3}-3\\xi}{\\sqrt{6}}$\n3.  标准正交性条件：$\\mathbb{E}[\\Phi_{i}(\\xi)\\,\\Phi_{j}(\\xi)] = \\delta_{ij}$。\n4.  模型输出 PCE：$Y(\\xi) = 3\\,\\Phi_{0}(\\xi)\\;-\\;\\frac{1}{2}\\,\\Phi_{1}(\\xi)\\;+\\;\\sqrt{2}\\,\\Phi_{2}(\\xi)\\;-\\;2\\,\\Phi_{3}(\\xi)$。\n5.  仿射变换：$Z(\\xi) = a\\,Y(\\xi) + b$。\n6.  常数：$a=-4$, $b=5$。\n\n验证结论：\n该问题设置在使用多项式混沌展开进行不确定性量化的既定数学框架内。所提供的基函数是针对标准高斯测度的正确的概率论学家 Hermite 多项式，并且它们的标准正交性陈述无误。该任务涉及对 PCE 的直接代数操作，这是该领域的标准程序。所有变量和常数均已明确定义，不存在科学或逻辑上的矛盾、歧义或信息缺失。该问题具有科学依据、适定、客观且完整。因此，该问题被视为有效，可以进行求解。\n\n**步骤 2：求解推导**\n\n目标是求出 $Z(\\xi)$ 的 PCE 表示，其形式为 $Z(\\xi) = \\sum_{k=0}^{3} z_k \\Phi_k(\\xi)$，其中 $z_k$ 是 $Z(\\xi)$ 的 PCE 系数。\n\n给定仿射变换：\n$$Z(\\xi) = a\\,Y(\\xi) + b$$\n模型输出 $Y(\\xi)$ 的 PCE 由下式给出：\n$$Y(\\xi) \\;=\\; 3\\,\\Phi_{0}(\\xi)\\;-\\;\\frac{1}{2}\\,\\Phi_{1}(\\xi)\\;+\\;\\sqrt{2}\\,\\Phi_{2}(\\xi)\\;-\\;2\\,\\Phi_{3}(\\xi)$$\n我们将 $Y(\\xi)$ 的表达式代入 $Z(\\xi)$ 的定义中：\n$$Z(\\xi) = a \\left( 3\\,\\Phi_{0}(\\xi)\\;-\\;\\frac{1}{2}\\,\\Phi_{1}(\\xi)\\;+\\;\\sqrt{2}\\,\\Phi_{2}(\\xi)\\;-\\;2\\,\\Phi_{3}(\\xi) \\right) + b$$\n将常数 $a$ 分配到括号内的各项，我们得到：\n$$Z(\\xi) = 3a\\,\\Phi_{0}(\\xi)\\;-\\;\\frac{a}{2}\\,\\Phi_{1}(\\xi)\\;+\\;a\\sqrt{2}\\,\\Phi_{2}(\\xi)\\;-\\;2a\\,\\Phi_{3}(\\xi) + b$$\n为了将 $Z(\\xi)$ 表示为基函数 $\\{\\Phi_k(\\xi)\\}_{k=0}^{3}$ 的线性组合，我们必须用此基来表示相加常数 $b$。第一个基函数是 $\\Phi_{0}(\\xi) = 1$。因此，我们可以将常数 $b$ 写为 $b \\cdot 1 = b\\,\\Phi_{0}(\\xi)$。\n\n将其代入 $Z(\\xi)$ 的表达式中：\n$$Z(\\xi) = 3a\\,\\Phi_{0}(\\xi)\\;-\\;\\frac{a}{2}\\,\\Phi_{1}(\\xi)\\;+\\;a\\sqrt{2}\\,\\Phi_{2}(\\xi)\\;-\\;2a\\,\\Phi_{3}(\\xi) + b\\,\\Phi_{0}(\\xi)$$\n现在，我们将与同一基函数相关的项进行分组。具体来说，我们合并 $\\Phi_{0}(\\xi)$ 的系数：\n$$Z(\\xi) = (3a+b)\\,\\Phi_{0}(\\xi)\\;-\\;\\frac{a}{2}\\,\\Phi_{1}(\\xi)\\;+\\;a\\sqrt{2}\\,\\Phi_{2}(\\xi)\\;-\\;2a\\,\\Phi_{3}(\\xi)$$\n该表达式即为 $Z(\\xi)$ 的 PCE。其系数 $z_k$ 为：\n- $z_0 = 3a+b$\n- $z_1 = -\\frac{a}{2}$\n- $z_2 = a\\sqrt{2}$\n- $z_3 = -2a$\n\n问题指定了常数 $a$ 和 $b$ 的确定性值为 $a=-4$ 和 $b=5$。我们将这些值代入系数 $z_k$ 的表达式中：\n- $z_0 = 3(-4) + 5 = -12 + 5 = -7$\n- $z_1 = -\\frac{(-4)}{2} = \\frac{4}{2} = 2$\n- $z_2 = (-4)\\sqrt{2} = -4\\sqrt{2}$\n- $z_3 = -2(-4) = 8$\n\n因此，通过将这些计算出的系数代回展开式，可以构建变换后输出 $Z(\\xi)$ 的最终 PCE 表示：\n$$Z(\\xi) \\;=\\; -7\\,\\Phi_{0}(\\xi) \\;+\\; 2\\,\\Phi_{1}(\\xi) \\;-\\; 4\\sqrt{2}\\,\\Phi_{2}(\\xi) \\;+\\; 8\\,\\Phi_{3}(\\xi)$$\n这就是所要求的闭式解析表达式。", "answer": "$$\n\\boxed{-7\\,\\Phi_{0}(\\xi) + 2\\,\\Phi_{1}(\\xi) - 4\\sqrt{2}\\,\\Phi_{2}(\\xi) + 8\\,\\Phi_{3}(\\xi)}\n$$", "id": "2448490"}, {"introduction": "在掌握了PCE的基本代数操作后，我们来探讨其一个核心应用。这个练习展示了PCE最强大的功能之一：直接从展开系数中高效计算统计矩（如均值和方差）。通过这个实践 [@problem_id:2448415]，你将学会推导模型输出的方差与其高阶PCE系数平方和之间的简洁关系，这是利用正交基函数特性的直接结果。这项技能对于高效量化不确定性至关重要，是替代昂贵的蒙特卡洛模拟的关键方法。", "problem": "考虑一个标量随机输入 $\\,\\xi\\,$，其分布为 $\\xi \\sim \\mathrm{Uniform}(-1,1)$。令 $\\{\\psi_{k}(\\xi)\\}_{k=0}^{\\infty}$ 表示关于 $\\,\\xi\\,$ 的概率测度的正交多项式基，其中 $\\psi_{0}(\\xi)=1$ 且对于所有非负整数 $\\,i,j\\,$，有 $\\mathbb{E}[\\psi_{i}(\\xi)\\,\\psi_{j}(\\xi)]=\\delta_{ij}$。一个随时间变化的模型输出 $\\,Y(t,\\xi)\\,$ 具有以下总阶数为 $\\,3\\,$ 的截断多项式混沌展开 (PCE)：\n$$\nY(t,\\xi)=a_{0}(t)\\,\\psi_{0}(\\xi)+a_{1}(t)\\,\\psi_{1}(\\xi)+a_{2}(t)\\,\\psi_{2}(\\xi)+a_{3}(t)\\,\\psi_{3}(\\xi),\n$$\n其随时间变化的确定性系数为：\n$$\na_{0}(t)=1+\\exp(-t),\\quad a_{1}(t)=t\\,\\exp\\!\\left(-\\frac{t}{2}\\right),\\quad a_{2}(t)=\\sin(t),\\quad a_{3}(t)=\\exp(-t)\\,\\cos(t).\n$$\n此处 $\\,t \\ge 0\\,$ 是时间，且所有三角函数参数均以弧度为单位。计算随时间变化的方差 $\\,\\mathrm{Var}[Y(t)]\\,$，结果表示为 $\\,t\\,$ 的闭式函数。将您的最终结果表示为关于 $\\,t\\,$ 的单个解析表达式。无需进行四舍五入。", "solution": "对该问题进行验证。\n\n第 1 步：提取已知条件。\n- 一个标量随机输入 $\\xi$，其分布为 $\\xi \\sim \\mathrm{Uniform}(-1,1)$。\n- 关于 $\\xi$ 的概率测度的正交多项式基 $\\{\\psi_{k}(\\xi)\\}_{k=0}^{\\infty}$。\n- 对于此基，$\\psi_{0}(\\xi)=1$ 且正交性条件为 $\\mathbb{E}[\\psi_{i}(\\xi)\\,\\psi_{j}(\\xi)]=\\delta_{ij}$，适用于所有非负整数 $i,j$。\n- 一个随时间变化的模型输出由总阶数为 $3$ 的截断多项式混沌展开 (PCE) 给出：\n$$Y(t,\\xi)=a_{0}(t)\\,\\psi_{0}(\\xi)+a_{1}(t)\\,\\psi_{1}(\\xi)+a_{2}(t)\\,\\psi_{2}(\\xi)+a_{3}(t)\\,\\psi_{3}(\\xi)$$\n- 随时间变化的系数为：\n$$a_{0}(t)=1+\\exp(-t)$$\n$$a_{1}(t)=t\\,\\exp(-\\frac{t}{2})$$\n$$a_{2}(t)=\\sin(t)$$\n$$a_{3}(t)=\\exp(-t)\\,\\cos(t)$$\n- 时间为 $t \\ge 0$。三角函数参数以弧度为单位。\n- 任务是计算随时间变化的方差 $\\mathrm{Var}[Y(t)]$，作为 $t$ 的闭式函数。\n\n第 2 步：使用提取的已知条件进行验证。\n- 问题具有科学依据。这是一个使用多项式混沌进行不确定性量化的标准问题，多项式混沌是计算工程和应用数学中的一种成熟方法。对于均匀随机变量，基函数 $\\{\\psi_k(\\xi)\\}$ 是经过缩放的 Legendre 多项式，其正交性是一个定义性属性。\n- 问题是适定的。计算方差所需的所有信息均已提供。定义 PCE 系数的函数是标准的且良态的。存在唯一且有意义的解。\n- 问题是客观的，并以精确的数学语言陈述。没有歧义或主观陈述。\n- 问题是完整、一致的，并且不违反任何物理或数学原理。\n\n第 3 步：结论与行动。\n- 问题有效。现在开始推导解。\n\n随机变量 $X$ 的方差定义为 $\\mathrm{Var}[X] = \\mathbb{E}[X^2] - (\\mathbb{E}[X])^2$。我们将此定义应用于固定时间 $t$ 下的随机过程 $Y(t, \\xi)$。\n\n首先，我们计算 $Y(t, \\xi)$ 的期望（均值）。期望算子 $\\mathbb{E}[\\cdot]$ 是线性的。\n$$ \\mathbb{E}[Y(t, \\xi)] = \\mathbb{E}\\left[ \\sum_{k=0}^{3} a_k(t) \\psi_k(\\xi) \\right] = \\sum_{k=0}^{3} a_k(t) \\mathbb{E}[\\psi_k(\\xi)] $$\n我们必须计算每个基多项式的期望。已知 $\\psi_{0}(\\xi)=1$。因此，其期望为 $\\mathbb{E}[\\psi_0(\\xi)] = \\mathbb{E}[1] = 1$。对于任何 $k > 0$，我们可以使用给定的正交性条件 $\\mathbb{E}[\\psi_i(\\xi) \\psi_j(\\xi)] = \\delta_{ij}$，其中 $\\delta_{ij}$ 是克罗内克 delta 符号。\n$$ \\mathbb{E}[\\psi_k(\\xi)] = \\mathbb{E}[\\psi_k(\\xi) \\cdot 1] = \\mathbb{E}[\\psi_k(\\xi) \\psi_0(\\xi)] = \\delta_{k0} $$\n这表明当 $k=0$ 时 $\\mathbb{E}[\\psi_k(\\xi)]$ 为 $1$，当 $k > 0$ 时为 $0$。\n将这些结果代回 $Y(t, \\xi)$ 的期望表达式中：\n$$ \\mathbb{E}[Y(t, \\xi)] = a_0(t) \\mathbb{E}[\\psi_0(\\xi)] + a_1(t) \\mathbb{E}[\\psi_1(\\xi)] + a_2(t) \\mathbb{E}[\\psi_2(\\xi)] + a_3(t) \\mathbb{E}[\\psi_3(\\xi)] $$\n$$ \\mathbb{E}[Y(t, \\xi)] = a_0(t) \\cdot 1 + a_1(t) \\cdot 0 + a_2(t) \\cdot 0 + a_3(t) \\cdot 0 = a_0(t) $$\n该过程的均值就是零阶基多项式的系数。\n\n接下来，我们计算二阶矩 $\\mathbb{E}[Y(t, \\xi)^2]$。\n$$ Y(t, \\xi)^2 = \\left( \\sum_{i=0}^{3} a_i(t) \\psi_i(\\xi) \\right) \\left( \\sum_{j=0}^{3} a_j(t) \\psi_j(\\xi) \\right) = \\sum_{i=0}^{3} \\sum_{j=0}^{3} a_i(t) a_j(t) \\psi_i(\\xi) \\psi_j(\\xi) $$\n取期望：\n$$ \\mathbb{E}[Y(t, \\xi)^2] = \\mathbb{E}\\left[ \\sum_{i=0}^{3} \\sum_{j=0}^{3} a_i(t) a_j(t) \\psi_i(\\xi) \\psi_j(\\xi) \\right] $$\n根据期望的线性性质，并且由于 $a_i(t)$ 是确定性系数：\n$$ \\mathbb{E}[Y(t, \\xi)^2] = \\sum_{i=0}^{3} \\sum_{j=0}^{3} a_i(t) a_j(t) \\mathbb{E}[\\psi_i(\\xi) \\psi_j(\\xi)] $$\n使用正交性性质 $\\mathbb{E}[\\psi_i(\\xi) \\psi_j(\\xi)] = \\delta_{ij}$：\n$$ \\mathbb{E}[Y(t, \\xi)^2] = \\sum_{i=0}^{3} \\sum_{j=0}^{3} a_i(t) a_j(t) \\delta_{ij} $$\n克罗内克 delta 符号 $\\delta_{ij}$ 将双重求和简化为单个求和，因为仅当 $i=j$ 时项才非零。\n$$ \\mathbb{E}[Y(t, \\xi)^2] = \\sum_{k=0}^{3} a_k(t)^2 = a_0(t)^2 + a_1(t)^2 + a_2(t)^2 + a_3(t)^2 $$\n这是基正交性的一个直接推论，称为 PCE 的 Parseval 定理。\n\n最后，我们组合得到方差 $\\mathrm{Var}[Y(t)]$。\n$$ \\mathrm{Var}[Y(t)] = \\mathbb{E}[Y(t, \\xi)^2] - (\\mathbb{E}[Y(t, \\xi)])^2 $$\n代入我们推导出的表达式：\n$$ \\mathrm{Var}[Y(t)] = (a_0(t)^2 + a_1(t)^2 + a_2(t)^2 + a_3(t)^2) - (a_0(t))^2 $$\n$$ \\mathrm{Var}[Y(t)] = a_1(t)^2 + a_2(t)^2 + a_3(t)^2 = \\sum_{k=1}^{3} a_k(t)^2 $$\nPCE 的方差是高阶（即 $k \\ge 1$）基多项式系数的平方和。\n\n现在，代入系数 $a_1(t)$、$a_2(t)$ 和 $a_3(t)$ 的给定函数形式：\n- $a_1(t) = t\\,\\exp(-\\frac{t}{2})$，因此 $a_1(t)^2 = \\left(t\\,\\exp(-\\frac{t}{2})\\right)^2 = t^2 \\exp(-t)$。\n- $a_2(t) = \\sin(t)$，因此 $a_2(t)^2 = \\sin^2(t)$。\n- $a_3(t) = \\exp(-t)\\,\\cos(t)$，因此 $a_3(t)^2 = \\left(\\exp(-t)\\,\\cos(t)\\right)^2 = \\exp(-2t)\\cos^2(t)$。\n\n将这些项组合起来，得到方差作为时间 $t$ 的函数的最终表达式：\n$$ \\mathrm{Var}[Y(t)] = t^2 \\exp(-t) + \\sin^2(t) + \\exp(-2t)\\cos^2(t) $$\n这就是所要求的闭式解析表达式。", "answer": "$$\n\\boxed{t^{2}\\exp(-t) + \\sin^{2}(t) + \\exp(-2t)\\cos^{2}(t)}\n$$", "id": "2448415"}, {"introduction": "最后，我们从纯粹的分析推导转向一个更具挑战性的数值实践。这个练习旨在探讨使用连续的多项式级数来近似一个不连续函数时会发生什么，这种情况会突显一个著名的数值现象——吉布斯现象 (Gibbs phenomenon)。通过这个编码练习 [@problem_id:2448439]，你将为一个阶跃函数实现PCE，并直观地、定量地观察到在不连续点附近的典型过冲和下冲现象。这将让你对PCE在处理非光滑模型响应时的收敛特性和局限性有更深刻的实践理解。", "problem": "设 $\\xi$ 是一个在区间 $[-1,1]$ 上均匀分布的标量随机变量，即 $\\xi \\sim \\mathcal{U}[-1,1]$，其概率密度函数在 $[-1,1]$ 上为 $f_{\\xi}(\\xi)=\\frac{1}{2}$，在其他地方为零。对于给定的阈值 $a \\in [-1,1]$，定义 Heaviside 阶跃函数 $H(\\xi - a)$ 为：当 $\\xi \\ge a$ 时 $H(\\xi - a)=1$，当 $\\xi < a$ 时 $H(\\xi - a)=0$。考虑函数 $f(\\xi)=H(\\xi - a)$ 关于 $\\xi$ 的概率测度的多项式混沌展开 (Polynomial Chaos Expansion, PCE)，使用标准正交 Legendre 多项式基 $\\{\\varphi_n(\\xi)\\}_{n\\ge 0}$，其中 $\\varphi_n(\\xi)=\\sqrt{2n+1}\\,P_n(\\xi)$，$P_n$ 是第 $n$ 阶标准 Legendre 多项式。设总阶数为 $p \\in \\mathbb{N}_0$ 的截断 PCE 为\n$$\nf_p(\\xi)=\\sum_{n=0}^{p} c_n \\,\\varphi_n(\\xi), \\quad \\text{其中} \\quad c_n=\\mathbb{E}[\\,f(\\xi)\\,\\varphi_n(\\xi)\\,],\n$$\n其中期望 $\\mathbb{E}[\\cdot]$ 是关于 $\\xi$ 的概率测度计算的。\n\n对于下面测试套件中指定的每一对 $(p,a)$，确定以下三个标量值：\n1. 超出 $1$ 的非负过冲幅度：\n$$\no_+(p,a)=\\max\\!\\left(0,\\,\\sup_{\\xi \\in [-1,1]} f_p(\\xi) - 1\\right).\n$$\n2. 低于 $0$ 的非负下冲幅度：\n$$\no_-(p,a)=\\max\\!\\left(0,\\,0 - \\inf_{\\xi \\in [-1,1]} f_p(\\xi)\\right).\n$$\n3. 关于概率测度的均方根误差（即均方意义下的 $L^2$ 误差）：\n$$\ne_p(a)=\\sqrt{\\mathbb{E}\\!\\left[\\left(f(\\xi)-f_p(\\xi)\\right)^2\\right]}.\n$$\n\n所有结果必须表示为无量纲的实数。角度单位不适用。不要使用百分号表示任何结果；请使用十进制表示法。您的程序必须完全按照定义计算这些量，并报告四舍五入到六位小数的结果。\n\n测试套件（每个条目是一对 $(p,a)$）：\n- 案例 $1$：$(p,a)=\\left(0,\\,0\\right)$\n- 案例 $2$：$(p,a)=\\left(1,\\,0\\right)$\n- 案例 $3$：$(p,a)=\\left(5,\\,0\\right)$\n- 案例 $4$：$(p,a)=\\left(20,\\,0\\right)$\n- 案例 $5$：$(p,a)=\\left(15,\\,0.5\\right)$\n- 案例 $6$：$(p,a)=\\left(30,\\,0.9\\right)$\n- 案例 $7$：$(p,a)=\\left(20,\\,1\\right)$\n\n最终输出格式：\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中每个元素对应上述顺序的一个测试案例。每个元素本身必须是一个包含三个十进制数的列表 $[o_+(p,a),\\,o_-(p,a),\\,e_p(a)]$，每个数都四舍五入到六位小数。例如：$[[x_{11},x_{12},x_{13}],[x_{21},x_{22},x_{23}],\\dots]$。", "solution": "该问题陈述具有科学依据，是适定的、客观的，并为获得唯一解提供了所有必要信息。因此，该问题被认定为有效。解决方案通过实施用于不确定性量化的多项式混沌展开 (PCE) 原理来推进。\n\n问题的核心是分析一个不连续函数，特别是 Heaviside 阶跃函数 $f(\\xi) = H(\\xi-a)$ 的 PCE，其中 $\\xi$ 是一个在区间 $[-1,1]$ 上具有均匀概率分布的随机变量。与此分布相对应的自然正交多项式基是 Legendre 多项式。标准正交基函数由 $\\varphi_n(\\xi) = \\sqrt{2n+1} P_n(\\xi)$ 给出，其中 $P_n(\\xi)$ 是第 $n$ 阶标准 Legendre 多项式。整个分析基于已建立的数学原理和标准数值技术。\n\n解决方案通过以下三个连续步骤构建：\n\n1.  **PCE 系数的计算**：截断 PCE $f_p(\\xi)=\\sum_{n=0}^{p} c_n \\varphi_n(\\xi)$ 的系数 $c_n$ 是通过将函数 $f(\\xi)$ 投影到基函数上确定的。此投影由期望算子 $\\mathbb{E}[\\cdot]$ 定义，其作用相当于一个由概率密度函数 $f_{\\xi}(\\xi) = 1/2$（在 $[-1,1]$ 上）加权的内积。\n    $$\n    c_n = \\mathbb{E}[f(\\xi)\\,\\varphi_n(\\xi)\\,] = \\int_{-1}^{1} H(x-a) \\varphi_n(x) \\frac{1}{2}\\,dx = \\frac{1}{2} \\int_{a}^{1} \\varphi_n(x)\\,dx\n    $$\n    对于 $n=0$，$\\varphi_0(\\xi) = P_0(\\xi) = 1$。系数 $c_0$ 是函数的均值：\n    $$\n    c_0 = \\frac{1}{2} \\int_{a}^{1} 1\\,dx = \\frac{1-a}{2}\n    $$\n    对于 $n \\ge 1$，我们使用与 Legendre 多项式导数相关的恒等式 $(2k+1)P_k(x) = P_{k+1}'(x) - P_{k-1}'(x)$。对该恒等式积分可得 $\\int P_n(x)\\,dx = \\frac{P_{n+1}(x) - P_{n-1}(x)}{2n+1}$。计算该定积分得出：\n    $$\n    \\int_{a}^{1} P_n(x)\\,dx = \\left[\\frac{P_{n+1}(x) - P_{n-1}(x)}{2n+1}\\right]_a^1 = \\frac{P_{n+1}(1) - P_{n-1}(1)}{2n+1} - \\frac{P_{n+1}(a) - P_{n-1}(a)}{2n+1} = \\frac{P_{n-1}(a) - P_{n+1}(a)}{2n+1}\n    $$\n    其中我们使用了性质 $P_k(1)=1$。将此代回 $c_n$ 的表达式中：\n    $$\n    c_n = \\frac{1}{2} \\sqrt{2n+1} \\left( \\frac{P_{n-1}(a) - P_{n+1}(a)}{2n+1} \\right) = \\frac{P_{n-1}(a) - P_{n+1}(a)}{2\\sqrt{2n+1}}\n    $$\n    这些公式使得所有必要系数的高效计算成为可能。\n\n2.  **Gibbs 现象分析（过冲与下冲）**：截断级数 $f_p(\\xi)$ 是一个 $p$ 阶多项式，它是不连续函数 $f(\\xi)$ 的一个连续近似。这种近似表现出 Gibbs 现象，其特征是在不连续点 $\\xi=a$ 附近出现振荡，导致出现高于 $f(\\xi)$ 最大值（即 $1$）的过冲和低于其最小值（即 $0$）的下冲。为量化这些现象，我们必须找到多项式 $f_p(\\xi)$ 在区间 $[-1,1]$ 上的上确界和下确界。一个多项式在闭区间上的极值点位于区间的端点 $\\xi=-1$ 和 $\\xi=1$，或其导数 $f_p'(\\xi)$ 为零的临界点。算法流程是：数值上构建多项式 $f_p(\\xi)$，找到其导数在 $(-1,1)$ 内的实根，然后在这些临界点和端点处计算 $f_p(\\xi)$ 的值，以确定其全局上确界和下确界。然后根据定义从这些值计算过冲 $o_+$ 和下冲 $o_-$：\n    $$\n    o_+(p,a)=\\max\\!\\left(0,\\,\\sup_{\\xi \\in [-1,1]} f_p(\\xi) - 1\\right) \\quad \\text{和} \\quad o_-(p,a)=\\max\\!\\left(0,\\,0 - \\inf_{\\xi \\in [-1,1]} f_p(\\xi)\\right)\n    $$\n\n3.  **均方根误差的计算**：均方根误差 $e_p(a)$ 在关于概率测度的 $L^2$ 意义下衡量近似的准确性。正交级数展开的一个关键性质是，均方误差可以通过一个类似于勾股定理的关系式来计算。均方误差是函数均方值与其投影均方值之差：\n    $$\n    e_p(a)^2 = \\mathbb{E}\\!\\left[\\left(f(\\xi)-f_p(\\xi)\\right)^2\\right] = \\mathbb{E}[f(\\xi)^2] - \\sum_{n=0}^{p} c_n^2\n    $$\n    函数 $f(\\xi)$ 的均方值为：\n    $$\n    \\mathbb{E}[f(\\xi)^2] = \\mathbb{E}[H(\\xi-a)^2] = \\mathbb{E}[H(\\xi-a)] = c_0 = \\frac{1-a}{2}\n    $$\n    因为 $H^2=H$。这导出了最终的、计算上高效的误差公式：\n    $$\n    e_p(a) = \\sqrt{\\frac{1-a}{2} - \\sum_{n=0}^{p} c_n^2}\n    $$\n    数值程序实现了这三个步骤。它使用 `scipy.special.eval_legendre` 来为系数计算 Legendre 多项式的值，使用 `numpy.poly1d` 和 `scipy.special.legendre` 来构建 PCE 多项式，使用 `numpy.roots` 来寻找临界点，并最终计算和格式化每个测试案例所需的三个量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre, eval_legendre\n\ndef calculate_quantities(p, a):\n    \"\"\"\n    Calculates overshoot, undershoot, and RMS error for the PCE of H(xi - a).\n\n    Args:\n        p (int): The total degree of the truncated PCE.\n        a (float): The threshold parameter of the Heaviside function.\n\n    Returns:\n        list: A list containing [overshoot, undershoot, rms_error].\n    \"\"\"\n    # Step 1: Compute PCE coefficients c_n for n=0,...,p\n    coeffs = np.zeros(p + 1, dtype=np.float64)\n\n    # Handle the edge case a=1. f(xi) = H(xi-1) is zero almost everywhere on [-1,1].\n    # All coefficients are zero, thus f_p(xi) = 0.\n    if a == 1.0:\n        return [0.0, 0.0, 0.0]\n\n    # Coefficient c_0 (mean of the function)\n    coeffs[0] = (1.0 - a) / 2.0\n\n    # Coefficients c_n for n >= 1\n    if p >= 1:\n        # Pn_a will hold values of P_0(a), P_1(a), ..., P_{p+1}(a)\n        # scipy.special.eval_legendre can evaluate for an array of degrees\n        degrees = np.arange(p + 2)\n        Pn_a = eval_legendre(degrees, a)\n        \n        for n in range(1, p + 1):\n            # c_n = (P_{n-1}(a) - P_{n+1}(a)) / (2 * sqrt(2n+1))\n            numerator = Pn_a[n-1] - Pn_a[n+1]\n            denominator = 2.0 * np.sqrt(2 * n + 1)\n            coeffs[n] = numerator / denominator\n\n    # Step 2: Compute overshoot and undershoot\n    # Construct the polynomial f_p(xi) = sum_{n=0 to p} c_n * phi_n(xi)\n    # where phi_n(xi) = sqrt(2n+1) * P_n(xi)\n    fp_poly = np.poly1d([0.0])\n    for n in range(p + 1):\n        # scipy.special.legendre(n) returns a numpy.poly1d object for P_n\n        phi_n_poly = np.sqrt(2 * n + 1) * legendre(n)\n        fp_poly += coeffs[n] * phi_n_poly\n    \n    # Find extrema of fp_poly on [-1, 1]\n    # The derivative of f_p is also a polynomial\n    fp_deriv_poly = fp_poly.deriv()\n\n    # Find the roots of the derivative (critical points)\n    crit_points_all = fp_deriv_poly.roots\n    # Filter for real roots within the open interval (-1, 1)\n    crit_points_real = crit_points_all[np.isreal(crit_points_all)].real\n    crit_points_interval = crit_points_real[(crit_points_real > -1.0) & (crit_points_real < 1.0)]\n\n    # Candidate points for extrema are the boundaries and the internal critical points\n    candidates = np.concatenate(([-1.0, 1.0], crit_points_interval))\n\n    # Evaluate f_p at all candidate points to find sup and inf\n    if candidates.size > 0:\n        values = fp_poly(candidates)\n        sup_fp = np.max(values)\n        inf_fp = np.min(values)\n    else: # This case occurs if the derivative is a non-zero constant (p=1)\n        values = fp_poly(np.array([-1.0, 1.0]))\n        sup_fp = np.max(values)\n        inf_fp = np.min(values)\n\n    # Calculate overshoot (o_+) and undershoot (o_-) based on definitions\n    o_plus = max(0.0, sup_fp - 1.0)\n    o_minus = max(0.0, 0.0 - inf_fp)\n\n    # Step 3: Compute RMS error e_p\n    # Mean square of the function, E[f^2] = (1-a)/2\n    E_f_sq = (1.0 - a) / 2.0\n    # Sum of squares of coefficients\n    sum_c_n_sq = np.sum(coeffs**2)\n    \n    # Mean-square error e_p^2 = E[f^2] - sum_{n=0 to p} c_n^2\n    # The argument to sqrt can be slightly negative due to floating point error, so clip at 0\n    e_p_sq = max(0.0, E_f_sq - sum_c_n_sq)\n    e_p = np.sqrt(e_p_sq)\n\n    return [o_plus, o_minus, e_p]\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0, 0.0),    # Case 1\n        (1, 0.0),    # Case 2\n        (5, 0.0),    # Case 3\n        (20, 0.0),   # Case 4\n        (15, 0.5),   # Case 5\n        (30, 0.9),   # Case 6\n        (20, 1.0)    # Case 7\n    ]\n\n    results = []\n    for p, a in test_cases:\n        o_plus, o_minus, e_p = calculate_quantities(p, a)\n        result_str = f\"[{o_plus:.6f},{o_minus:.6f},{e_p:.6f}]\"\n        results.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2448439"}]}