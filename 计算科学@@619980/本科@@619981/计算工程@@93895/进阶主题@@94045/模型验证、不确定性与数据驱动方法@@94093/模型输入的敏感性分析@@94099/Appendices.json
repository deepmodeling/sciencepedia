{"hands_on_practices": [{"introduction": "为什么一个看起来不直接影响输出的输入参数，其全局重要性可能非常高？这个练习通过一个经典的纯交互作用模型，揭示了一阶灵敏度指数（$S_i$）与总效应指数（$S_{Ti}$）之间的关键区别。通过这个看似简单的函数，你将深入理解为何忽略参数间的交互作用会导致对模型行为的严重误判。[@problem_id:2434812]", "problem": "考虑一个确定性模型，其有两个独立的实值输入 $X_1$ 和 $X_2$，每个输入都服从 $\\mathrm{Uniform}(0,1)$ 分布。标量输出定义为\n$$\nY \\;=\\; \\bigl(X_1 - \\tfrac{1}{2}\\bigr)\\,\\bigl(X_2 - \\tfrac{1}{2}\\bigr).\n$$\n对于输入 $X_i$，其一阶 Sobol' 指数定义为\n$$\nS_i \\;=\\; \\frac{\\mathrm{Var}\\!\\bigl(\\mathbb{E}[Y \\mid X_i]\\bigr)}{\\mathrm{Var}(Y)},\n$$\n其全阶 Sobol' 指数定义为\n$$\nS_{Ti} \\;=\\; \\frac{\\mathbb{E}\\!\\bigl[\\mathrm{Var}(Y \\mid X_{\\sim i})\\bigr]}{\\mathrm{Var}(Y)},\n$$\n其中 $\\mathbb{E}[\\cdot]$ 表示期望，$\\mathrm{Var}(\\cdot)$ 表示方差，而 $X_{\\sim i}$ 表示除 $X_i$ 之外的所有输入的集合。\n\n仅使用这些定义和给定的分布，确定输入 $X_1$ 的全阶 Sobol' 指数 $S_{T1}$ 的精确值，并验证一阶指数 $S_1$ 等于 $0$。给出 $S_{T1}$ 的精确值（不进行四舍五入）作为最终答案。Sobol' 指数是无量纲的，无需报告单位。", "solution": "对问题陈述进行验证。\n**已知条件：**\n1.  模型：$Y = (X_1 - \\tfrac{1}{2})(X_2 - \\tfrac{1}{2})$。\n2.  输入：$X_1, X_2$ 是独立的实值输入。\n3.  分布：$X_1 \\sim \\mathrm{Uniform}(0,1)$ 且 $X_2 \\sim \\mathrm{Uniform}(0,1)$。\n4.  一阶 Sobol' 指数：$S_i = \\frac{\\mathrm{Var}(\\mathbb{E}[Y \\mid X_i])}{\\mathrm{Var}(Y)}$。\n5.  全阶 Sobol' 指数：$S_{Ti} = \\frac{\\mathbb{E}[\\mathrm{Var}(Y \\mid X_{\\sim i})]}{\\mathrm{Var}(Y)}$。\n6.  $X_{\\sim i}$ 表示除 $X_i$ 之外的所有输入。\n\n**验证：**\n该问题具有科学依据，是 Sobol' 敏感性分析中的一个标准练习。这是一个提法恰当的问题，所有必需的数学对象和分布都有清晰且无歧义的定义。该问题是客观的，不包含任何事实性错误、不完整性或矛盾。其前提在数学和统计上均是合理的。因此，该问题被视为有效，并将提供解答。\n\n求解过程首先计算输出的总方差 $\\mathrm{Var}(Y)$，它作为两个指数的分母。随后，我们将计算 $S_1$ 和 $S_{T1}$ 的分子，并验证所述条件。\n\n首先，我们确定输入随机变量的性质。对于输入 $X_i \\sim \\mathrm{Uniform}(0,1)$，其期望为：\n$$\n\\mathbb{E}[X_i] = \\int_0^1 x \\, dx = \\frac{1}{2}\n$$\n方差由 $\\mathrm{Var}(X_i) = \\mathbb{E}[X_i^2] - (\\mathbb{E}[X_i])^2$ 给出。我们计算其二阶矩：\n$$\n\\mathbb{E}[X_i^2] = \\int_0^1 x^2 \\, dx = \\frac{1}{3}\n$$\n因此，方差为：\n$$\n\\mathrm{Var}(X_i) = \\frac{1}{3} - \\left(\\frac{1}{2}\\right)^2 = \\frac{1}{3} - \\frac{1}{4} = \\frac{1}{12}\n$$\n使用中心化变量会很方便。令 $Z_i = X_i - \\frac{1}{2}$。$Z_i$ 的性质如下：\n$$\n\\mathbb{E}[Z_i] = \\mathbb{E}\\left[X_i - \\frac{1}{2}\\right] = \\mathbb{E}[X_i] - \\frac{1}{2} = \\frac{1}{2} - \\frac{1}{2} = 0\n$$\n$$\n\\mathrm{Var}(Z_i) = \\mathrm{Var}\\left(X_i - \\frac{1}{2}\\right) = \\mathrm{Var}(X_i) = \\frac{1}{12}\n$$\n现在，模型可以写为 $Y = Z_1 Z_2$。\n\n现在，我们计算总方差 $\\mathrm{Var}(Y)$。\n$Y$ 的期望是：\n$$\n\\mathbb{E}[Y] = \\mathbb{E}[Z_1 Z_2]\n$$\n因为 $X_1$ 和 $X_2$ 是独立的，所以 $Z_1$ 和 $Z_2$ 也是独立的。因此：\n$$\n\\mathbb{E}[Y] = \\mathbb{E}[Z_1]\\mathbb{E}[Z_2] = (0)(0) = 0\n$$\n$Y$ 的方差是 $\\mathrm{Var}(Y) = \\mathbb{E}[Y^2] - (\\mathbb{E}[Y])^2$。我们计算 $\\mathbb{E}[Y^2]$：\n$$\n\\mathbb{E}[Y^2] = \\mathbb{E}[(Z_1 Z_2)^2] = \\mathbb{E}[Z_1^2 Z_2^2]\n$$\n因为独立性，$\\mathbb{E}[Z_1^2 Z_2^2] = \\mathbb{E}[Z_1^2]\\mathbb{E}[Z_2^2]$。\n根据方差的定义，$\\mathrm{Var}(Z_i) = \\mathbb{E}[Z_i^2] - (\\mathbb{E}[Z_i])^2$。因为 $\\mathbb{E}[Z_i] = 0$，我们有 $\\mathbb{E}[Z_i^2] = \\mathrm{Var}(Z_i) = \\frac{1}{12}$。\n所以，\n$$\n\\mathbb{E}[Y^2] = \\left(\\frac{1}{12}\\right)\\left(\\frac{1}{12}\\right) = \\frac{1}{144}\n$$\n输出的总方差是：\n$$\n\\mathrm{Var}(Y) = \\frac{1}{144} - (0)^2 = \\frac{1}{144}\n$$\n接下来，我们验证一阶指数 $S_1$ 为 $0$。其分子是 $\\mathrm{Var}(\\mathbb{E}[Y \\mid X_1])$。我们计算条件期望：\n$$\n\\mathbb{E}[Y \\mid X_1] = \\mathbb{E}\\left[\\left(X_1 - \\frac{1}{2}\\right)\\left(X_2 - \\frac{1}{2}\\right) \\mid X_1\\right]\n$$\n给定 $X_1$ 时，项 $(X_1 - \\frac{1}{2})$ 是一个常数。\n$$\n\\mathbb{E}[Y \\mid X_1] = \\left(X_1 - \\frac{1}{2}\\right) \\mathbb{E}\\left[\\left(X_2 - \\frac{1}{2}\\right) \\mid X_1\\right]\n$$\n由于 $X_1$ 和 $X_2$ 的独立性，以 $X_1$ 为条件对 $X_2$ 的函数求期望没有影响。\n$$\n\\mathbb{E}\\left[\\left(X_2 - \\frac{1}{2}\\right) \\mid X_1\\right] = \\mathbb{E}\\left[X_2 - \\frac{1}{2}\\right] = \\mathbb{E}[X_2] - \\frac{1}{2} = 0\n$$\n因此，条件期望为：\n$$\n\\mathbb{E}[Y \\mid X_1] = \\left(X_1 - \\frac{1}{2}\\right) \\cdot 0 = 0\n$$\n常数的方差为零，所以 $\\mathrm{Var}(\\mathbb{E}[Y \\mid X_1]) = \\mathrm{Var}(0) = 0$。\n$X_1$ 的一阶指数是：\n$$\nS_1 = \\frac{\\mathrm{Var}(\\mathbb{E}[Y \\mid X_1])}{\\mathrm{Var}(Y)} = \\frac{0}{1/144} = 0\n$$\n这验证了给定的条件。\n\n最后，我们确定全阶指数 $S_{T1}$。其分子是 $\\mathbb{E}[\\mathrm{Var}(Y \\mid X_{\\sim 1})]$。对于这个双输入模型，$X_{\\sim 1}$ 就是输入 $X_2$。我们必须计算 $\\mathbb{E}[\\mathrm{Var}(Y \\mid X_2)]$。首先，我们求条件方差：\n$$\n\\mathrm{Var}(Y \\mid X_2) = \\mathrm{Var}\\left(\\left(X_1 - \\frac{1}{2}\\right)\\left(X_2 - \\frac{1}{2}\\right) \\mid X_2\\right)\n$$\n在以 $X_2$ 为条件的背景下，项 $(X_2 - \\frac{1}{2})$被视为一个常数因子。使用性质 $\\mathrm{Var}(aU) = a^2\\mathrm{Var}(U)$：\n$$\n\\mathrm{Var}(Y \\mid X_2) = \\left(X_2 - \\frac{1}{2}\\right)^2 \\mathrm{Var}\\left(\\left(X_1 - \\frac{1}{2}\\right) \\mid X_2\\right)\n$$\n因为独立性，$\\mathrm{Var}((X_1 - \\frac{1}{2}) \\mid X_2) = \\mathrm{Var}(X_1 - \\frac{1}{2}) = \\mathrm{Var}(X_1) = \\frac{1}{12}$。\n所以，条件方差是：\n$$\n\\mathrm{Var}(Y \\mid X_2) = \\frac{1}{12}\\left(X_2 - \\frac{1}{2}\\right)^2\n$$\n现在，我们对此量求关于 $X_2$ 分布的期望：\n$$\n\\mathbb{E}[\\mathrm{Var}(Y \\mid X_2)] = \\mathbb{E}\\left[\\frac{1}{12}\\left(X_2 - \\frac{1}{2}\\right)^2\\right] = \\frac{1}{12}\\mathbb{E}\\left[\\left(X_2 - \\frac{1}{2}\\right)^2\\right]\n$$\n项 $\\mathbb{E}[(X_2 - \\frac{1}{2})^2]$ 根据定义是 $X_2$ 的二阶中心矩，也就是 $X_2$ 的方差，因为 $\\mathbb{E}[X_2] = \\frac{1}{2}$。\n$$\n\\mathbb{E}\\left[\\left(X_2 - \\frac{1}{2}\\right)^2\\right] = \\mathrm{Var}(X_2) = \\frac{1}{12}\n$$\n因此，全阶指数的分子是：\n$$\n\\mathbb{E}[\\mathrm{Var}(Y \\mid X_2)] = \\frac{1}{12} \\cdot \\frac{1}{12} = \\frac{1}{144}\n$$\n最后，全阶指数 $S_{T1}$ 是：\n$$\nS_{T1} = \\frac{\\mathbb{E}[\\mathrm{Var}(Y \\mid X_{\\sim 1})]}{\\mathrm{Var}(Y)} = \\frac{1/144}{1/144} = 1\n$$\n结果 $S_{T1} = 1$ 意味着输出 $Y$ 的所有方差都可通过输入 $X_1$ 的直接效应（为零）及其交互作用来解释。在这个特定模型中，方差完全源于 $X_1$ 和 $X_2$ 之间的交互作用。", "answer": "$$\\boxed{1}$$", "id": "2434812"}, {"introduction": "灵敏度分析在计算工程中一个至关重要的应用是评估数值模拟的稳定性。本练习将带你亲手实践，通过求解一维波动方程，探索其数值解的误差如何对库朗数（CFL数，$C$）产生高度敏感的依赖。你将直观地看到，当$C$跨越某个临界值时，解的行为会从精确稳定急剧转变为发散崩溃，这是一个典型的非线性敏感现象。[@problem_id:2434821]", "problem": "您需要研究一维双曲型偏微分方程的有限差分解对 Courant–Friedrichs–Lewy (CFL) 数的敏感性。考虑一维线性波动方程\n$$\nu_{tt}(x,t) = u_{xx}(x,t),\n$$\n其空间域为 $[0,1]$，时间为 $t \\ge 0$，并具有齐次狄利克雷边界条件\n$$\nu(0,t) = 0,\\quad u(1,t) = 0,\n$$\n以及初始条件\n$$\nu(x,0) = \\sin(\\pi x),\\quad u_t(x,0) = 0.\n$$\n所有量均为无量纲，三角函数的参数单位为弧度。\n\n设空间网格为均匀网格，有 $N$ 个点，位置为 $x_i = i \\,\\Delta x$（$i=0,1,\\dots,N-1$），且 $\\Delta x = \\frac{1}{N-1}$。设时间步长为 $\\Delta t = C\\,\\Delta x$，其中 $C$ 是 Courant–Friedrichs–Lewy (CFL) 数。使用标准的二阶精度显式中心有限差分格式，其对内部索引 $i=1,2,\\dots,N-2$ 的离散更新定义如下：\n$$\nu_i^{n+1} = 2\\,u_i^{n} - u_i^{n-1} + C^2\\left(u_{i+1}^{n} - 2\\,u_i^{n} + u_{i-1}^{n}\\right),\n$$\n对所有时间索引 $n$，边界值强制设为 $u_0^n = 0$ 和 $u_{N-1}^n = 0$。根据给定的初始条件，使用在 $t=0$ 处的单步泰勒展开（初始速度为零）来初始化，对内部索引 $i=1,2,\\dots,N-2$：\n$$\nu_i^{0} = \\sin(\\pi x_i),\\qquad\nu_i^{1} = u_i^{0} + \\tfrac{1}{2} C^2 \\left(u_{i+1}^{0} - 2\\,u_i^{0} + u_{i-1}^{0}\\right),\n$$\n且 $u_0^{0}=u_{N-1}^{0}=0$, $u_0^{1}=u_{N-1}^{1}=0$。\n\n设目标最终时间为 $T=1$。使用时间步长 $\\Delta t$ 演化该格式，直到不超过 $T$ 的最后一个时间点，即取 $n_{\\text{end}} = \\left\\lfloor \\frac{T}{\\Delta t} \\right\\rfloor$ 并在 $t_{\\text{end}} = n_{\\text{end}}\\,\\Delta t$ 进行比较。此问题的精确解为\n$$\nu(x,t) = \\sin(\\pi x)\\,\\cos(\\pi t).\n$$\n\n对于给定的 $C$，计算在时间 $t_{\\text{end}}$ 时的离散相对 $\\ell^2$ 误差，\n$$\nE(C) = \n\\begin{cases}\n\\dfrac{\\sqrt{\\sum_{i=0}^{N-1}\\left(u_i^{n_{\\text{end}}} - u(x_i,t_{\\text{end}})\\right)^2}}{\\sqrt{\\sum_{i=0}^{N-1} \\left(u(x_i,t_{\\text{end}})\\right)^2}}, & \\text{如果 } \\sum_{i=0}^{N-1} \\left(u(x_i,t_{\\text{end}})\\right)^2 \\ne 0,\n\\\\[1em]\n\\sqrt{\\sum_{i=0}^{N-1}\\left(u_i^{n_{\\text{end}}} - u(x_i,t_{\\text{end}})\\right)^2}, & \\text{否则。}\n\\end{cases}\n$$\n\n如果在到达 $n_{\\text{end}}$ 之前的任何时间步，数值解包含非有限值（非数字或无穷大）或其最大绝对值超过阈值 $M = 10^6$，则对该 $C$ 定义 $E(C) = 10^9$。\n\n对所有测试用例使用以下固定参数：$N = 401$ 和 $T = 1$。测试套件包括五个 CFL 数\n$$\nC \\in \\{0.20,\\; 0.70,\\; 0.99,\\; 1.00,\\; 1.05\\}.\n$$\n\n您的程序必须按给定顺序为每个 $C$ 计算 $E(C)$，并生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表，例如 $[e_1,e_2,e_3,e_4,e_5]$。将每个误差表示为四舍五入到六位小数的小数。最终输出必须是单行，不含其他文本。", "solution": "该问题要求对一维线性波动方程的数值解关于 Courant–Friedrichs–Lewy (CFL) 数（记为 $C$）进行敏感性分析。方程为 $u_{tt} = u_{xx}$，定义在区域 $x \\in [0,1]$ 上，具有齐次狄利克雷边界条件 $u(0,t)=u(1,t)=0$ 和初始条件 $u(x,0) = \\sin(\\pi x)$ 及 $u_t(x,0) = 0$。我们需要实现一个指定的二阶显式中心有限差分格式，并为一组 $C$ 值计算相对 $\\ell^2$ 误差。\n\n此数值格式的理论基础是 CFL 稳定性条件。对于一维波动方程 $u_{tt} = c^2 u_{xx}$，标准的显式中心差分格式保持稳定的条件是 $C = c \\frac{\\Delta t}{\\Delta x} \\le 1$。在给定问题中，波速 $c$ 为 $1$，因此稳定性条件简化为 $C \\le 1$。因此，我们必须预期，对于 $C \\le 1$ 的测试用例，数值解将是稳定的，而对于 $C > 1$ 的情况，解将是不稳定的，表现出振幅的指数增长。\n\n$C=1$ 的情况具有特殊意义。对于应用于一维波动方程的这个特定格式，对于网格所能解析的所有波数，其数值相速度与真实相速度完全匹配。这意味着该格式在 $C=1$ 时是无色散的。考虑到所提供的初始化方法，数值解在网格点上应与解析解完全一致，计算出的误差预计在机器浮点精度的量级。对于 $C < 1$ 的情况，格式是稳定的，但会引入数值色散，这是误差的主要来源。\n\n计算流程如下：\n\n首先，我们建立离散域。空间域 $[0,1]$ 被离散化为 $N=401$ 个点，得到空间步长 $\\Delta x = \\frac{1}{N-1} = \\frac{1}{400}$。我们创建一个向量 $x$，包含网格点坐标 $x_i = i \\Delta x$（$i=0, 1, \\dots, N-1$）。\n\n对于每个指定的 CFL 数 $C \\in \\{0.20, 0.70, 0.99, 1.00, 1.05\\}$，我们进行一次时间演化模拟。\n时间步长计算为 $\\Delta t = C \\Delta x$。模拟运行至最终时间 $T=1$。总步数为 $n_{\\text{end}} = \\lfloor T/\\Delta t \\rfloor$，最终模拟时间为 $t_{\\text{end}} = n_{\\text{end}} \\Delta t$。\n\n模拟需要存储前两个时间层的解来计算下一个时间层的解，我们将其表示为向量 $u^{n-1}$ 和 $u^n$。在实现中，让它们由 `u_prev` 和 `u_curr` 表示。\n初始化分两个阶段进行：\n1.  时间 $n=0$ 时的解由初始条件给出：$u_i^0 = u(x_i, 0) = \\sin(\\pi x_i)$。这被赋值给 `u_prev`。\n2.  时间 $n=1$ 时的解使用所提供的单步泰勒展开公式计算，该公式与 $u_t(x,0)=0$ 的初始条件一致：\n    $$u_i^{1} = u_i^{0} + \\tfrac{1}{2} C^2 \\left(u_{i+1}^{0} - 2 u_i^{0} + u_{i-1}^{0}\\right)$$\n    此公式适用于内部点 $i=1, 2, \\dots, N-2$。边界值为 $u_0^1=0$ 和 $u_{N-1}^1=0$。离散拉普拉斯项 $(u_{i+1}^{0} - 2 u_i^{0} + u_{i-1}^{0})$ 通过对 `u_prev` 进行向量化运算来高效计算。结果存储在 `u_curr` 中。\n\n模拟的核心是时间步进循环，它从 $n=1$ 迭代到 $n=n_{\\text{end}}-1$。在每次迭代中，解 $u^{n+1}$（我们称之为 `u_next`）是根据 $u^n$ 和 $u^{n-1}$，使用显式中心差分公式为内部点 $i=1, 2, \\dots, N-2$ 计算的：\n$$u_i^{n+1} = 2 u_i^{n} - u_i^{n-1} + C^2\\left(u_{i+1}^{n} - 2 u_i^{n} + u_{i-1}^{n}\\right)$$\n通过设置 $u_0^{n+1}=0$ 和 $u_{N-1}^{n+1}=0$ 来强制执行齐次狄利克雷边界条件。为了效率，更新过程是向量化的。\n\n在每一步计算出 `u_next` 之后，我们必须检查数值不稳定性。如果解向量的任何元素变为非有限值（NaN 或无穷大），或者其最大绝对值超过阈值 $M=10^6$，则针对当前 $C$ 的模拟将终止，并且误差 $E(C)$ 被设置为惩罚值 $10^9$。\n\n如果时间步进循环完成而未遇到不稳定性，则向量 `u_curr` 包含数值解 $u^{n_{\\text{end}}}$。然后我们计算误差 $E(C)$。首先，在最终时间 $t_{\\text{end}}$ 处，在网格点上计算精确解：$u(x_i, t_{\\text{end}}) = \\sin(\\pi x_i) \\cos(\\pi t_{\\text{end}})$。然后使用所提供的公式计算相对 $\\ell^2$ 误差：\n$$E(C) = \\frac{\\sqrt{\\sum_{i=0}^{N-1}\\left(u_i^{n_{\\text{end}}} - u(x_i,t_{\\text{end}})\\right)^2}}{\\sqrt{\\sum_{i=0}^{N-1} \\left(u(x_i,t_{\\text{end}})\\right)^2}}$$\n如问题描述中所规定，实现了一个检查来处理分母为零的情况，尽管对于给定的参数，这种情况预计不会发生。\n\n对每个 $C$ 值重复这整个过程，并收集所产生的误差。最终输出是这些误差值的格式化列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D wave equation using a finite difference scheme\n    and computes the numerical error for different CFL numbers.\n    \"\"\"\n    # Define the fixed parameters from the problem statement.\n    N = 401\n    T = 1.0\n    M = 1.0e6\n    C_values = [0.20, 0.70, 0.99, 1.00, 1.05]\n\n    results = []\n\n    # Iterate over each specified CFL number.\n    for C in C_values:\n        # ---- Step 1: Discretization and setup ----\n        dx = 1.0 / (N - 1)\n        dt = C * dx\n\n        if dt = 0:\n            # Handle non-positive time step case to prevent infinite loop or division by zero.\n            results.append(1e9)  # Assign instability error\n            continue\n\n        n_end = int(np.floor(T / dt))\n        t_end = n_end * dt\n        \n        x = np.linspace(0.0, 1.0, N)\n        C2 = C**2\n        is_unstable = False\n\n        # ---- Step 2: Initialization ----\n        # u_prev corresponds to the solution at n=0.\n        u_prev = np.sin(np.pi * x)\n        \n        # u_curr corresponds to the solution at n=1.\n        u_curr = np.zeros(N)\n        \n        # Compute u^1 for interior points using the Taylor expansion formula.\n        laplacian_u0 = u_prev[2:] - 2 * u_prev[1:-1] + u_prev[:-2]\n        u_curr[1:-1] = u_prev[1:-1] + 0.5 * C2 * laplacian_u0\n        # Boundary conditions u_curr[0]=0 and u_curr[N-1]=0 are met by np.zeros.\n\n        # ---- Step 3: Time-stepping loop ----\n        # Loop from n=1 to n_end-1 to compute solutions up to u^{n_end}.\n        for _ in range(1, n_end):\n            u_next = np.zeros(N)\n            \n            # Compute u^{n+1} for interior points using the central difference scheme.\n            laplacian_u_curr = u_curr[2:] - 2 * u_curr[1:-1] + u_curr[:-2]\n            u_next[1:-1] = 2 * u_curr[1:-1] - u_prev[1:-1] + C2 * laplacian_u_curr\n            # Boundary conditions u_next[0]=0 and u_next[N-1]=0 are met.\n            \n            # Check for numerical instability.\n            if not np.all(np.isfinite(u_next)) or np.max(np.abs(u_next)) > M:\n                is_unstable = True\n                break\n            \n            # Update solution vectors for the next time step.\n            u_prev, u_curr = u_curr, u_next\n\n        # ---- Step 4: Error calculation ----\n        if is_unstable:\n            error = 1e9\n        else:\n            # At loop completion, u_curr holds the solution at t_end.\n            u_exact = np.sin(np.pi * x) * np.cos(np.pi * t_end)\n            \n            # Calculate the squared L2 norms.\n            norm_err_sq = np.sum((u_curr - u_exact)**2)\n            norm_exact_sq = np.sum(u_exact**2)\n            \n            # Compute error based on the specified formula.\n            if norm_exact_sq != 0:\n                error = np.sqrt(norm_err_sq / norm_exact_sq)\n            else:\n                error = np.sqrt(norm_err_sq)\n        \n        results.append(error)\n\n    # Format the results to six decimal places for output.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2434821"}, {"introduction": "真实世界的工程模型往往涉及随时间或空间变化的“功能性输入”，例如作用在桥梁上的交通载荷时程。这个高级练习将指导你如何处理这类复杂输入，通过将功能性输入离散化为一系列随机变量，来计算单自由度振子模型位移响应的灵敏度。这项实践是连接理论与复杂工程应用的关键一步，让你掌握分析动态系统输入重要性的实用技能。[@problem_id:2434842]", "problem": "实现一个完整的程序，用于计算由一个在时间上离散化的函数型输入驱动的线性时不变模型输出的一阶基于方差的灵敏度指数。该模型为一个简支桥梁的单模态近似，该桥梁被建模为单自由度 (SDOF) 振子。在最终时刻 $T$ 的模型输出是挠度响应，表示为荷载时程的线性泛函。\n\n模型定义：\n- 设时间区间为 $[0,T]$，其中 $T0$。\n- 设 $N\\ge 2$ 为等距时间样本的数量，时间步长为 $\\Delta t = T/(N-1)$，节点为 $t_i = i\\,\\Delta t$，其中 $i\\in\\{0,1,\\dots,N-1\\}$。\n- 设随机输入向量为 $U=(U_0,\\dots,U_{N-1})$，其分量相互独立，并给定 $\\mathbb{E}[U_i]=0$ 和 $\\operatorname{Var}(U_i)=\\sigma_i^2$。\n- 模型输出为\n$$\nY \\;=\\; \\sum_{i=0}^{N-1} h\\!\\left(T-t_i\\right)\\,U_i\\,\\Delta t,\n$$\n其中权重函数 $h$ 是 SDOF 的单位脉冲响应\n$$\nh(\\tau) \\;=\\; \\frac{\\beta}{\\omega_d}\\, e^{-\\zeta\\,\\omega_n\\,\\tau}\\,\\sin\\!\\left(\\omega_d\\,\\tau\\right), \\quad \\tau\\ge 0,\n$$\n其中参数 $\\omega_n0$ (无阻尼固有频率)，$0\\le \\zeta1$ (阻尼比)，$\\omega_d=\\omega_n\\sqrt{1-\\zeta^2}$ (有阻尼固有频率)，以及增益 $\\beta0$。$\\sin(\\cdot)$ 函数中使用的所有角度均以弧度为单位。\n\n任务：\n- 对于每组给定的参数集，在 $U$ 的分量相互独立的假设下，计算 $Y$ 关于分量 $(U_0,\\dots,U_{N-1})$ 的一阶基于方差的灵敏度指数向量 $S=(S_0,\\dots,S_{N-1})$。分量 $i$ 的一阶指数定义为\n$$\nS_i \\;=\\; \\frac{\\operatorname{Var}\\!\\left(\\mathbb{E}[\\,Y \\mid U_i\\,]\\right)}{\\operatorname{Var}(Y)}.\n$$\n\n测试套件：\n你的程序必须为以下四个参数集中的每一个计算 $S$。在每个项目中，元组列出了 $(T,N,\\omega_n,\\zeta,\\beta,\\{\\sigma_i^2\\}_{i=0}^{N-1})$。\n\n- 情况 1：$(T,N,\\omega_n,\\zeta,\\beta,\\{\\sigma_i^2\\}) = (\\,5.0,\\,5,\\,2.0,\\,0.1,\\,1.0,\\,[\\,1.0,\\,1.0,\\,1.0,\\,1.0,\\,1.0\\,]\\,)$。\n- 情况 2：$(T,N,\\omega_n,\\zeta,\\beta,\\{\\sigma_i^2\\}) = (\\,\\pi,\\,5,\\,1.0,\\,0.0,\\,1.0,\\,[\\,1.0,\\,1.0,\\,1.0,\\,1.0,\\,1.0\\,]\\,)$。\n- 情况 3：$(T,N,\\omega_n,\\zeta,\\beta,\\{\\sigma_i^2\\}) = (\\,4.0,\\,4,\\,1.5,\\,0.2,\\,1.0,\\,[\\,1.0,\\,0.0,\\,2.0,\\,0.0\\,]\\,)$。\n- 情况 4：$(T,N,\\omega_n,\\zeta,\\beta,\\{\\sigma_i^2\\}) = (\\,2.0,\\,6,\\,3.0,\\,0.05,\\,1.0,\\,[\\,0.5,\\,1.5,\\,0.2,\\,2.5,\\,1.0,\\,0.3\\,]\\,)$。\n\n答案规格：\n- 对于每种情况，返回列表 $[S_0,S_1,\\dots,S_{N-1}]$。\n- 你的程序应生成单行输出，其中包含结果，形式为这些列表组成的、以逗号分隔的列表，并用方括号括起来，例如 $[\\,[\\cdot],\\,[\\cdot],\\,[\\cdot],\\,[\\cdot]\\,]$。\n- 每个 $S_i$ 都必须输出为实数 (浮点数)。输出中不需要物理单位。如上所述，角度以弧度为单位。", "solution": "该问题需要进行验证。\n\n步骤 1：提取已知信息\n- 时间区间：$[0,T]$，其中 $T0$。\n- 时间离散化：$N\\ge 2$ 个样本，时间步长 $\\Delta t = T/(N-1)$，节点 $t_i = i\\,\\Delta t$，其中 $i\\in\\{0,1,\\dots,N-1\\}$。\n- 随机输入：$U=(U_0,\\dots,U_{N-1})$，其分量 $U_i$ 相互独立，且 $\\mathbb{E}[U_i]=0$ 和 $\\operatorname{Var}(U_i)=\\sigma_i^2$。\n- 模型输出：$Y \\;=\\; \\sum_{i=0}^{N-1} h\\!\\left(T-t_i\\right)\\,U_i\\,\\Delta t$。\n- 权重函数（单位脉冲响应）：$h(\\tau) \\;=\\; \\frac{\\beta}{\\omega_d}\\, e^{-\\zeta\\,\\omega_n\\,\\tau}\\,\\sin\\!\\left(\\omega_d\\,\\tau\\right)$，对于 $\\tau\\ge 0$。\n- 函数参数：$\\omega_n0$，$0\\le \\zeta1$，$\\omega_d=\\omega_n\\sqrt{1-\\zeta^2}$，$\\beta0$。\n- 任务：计算一阶基于方差的敏感性指数向量 $S=(S_0,\\dots,S_{N-1})$，其中 $S_i \\;=\\; \\frac{\\operatorname{Var}\\!\\left(\\mathbb{E}[\\,Y \\mid U_i\\,]\\right)}{\\operatorname{Var}(Y)}$。\n- 测试数据：提供了四组不同的参数集。\n\n步骤 2：验证\n- 该问题具有科学依据。它描述了对标准线性单自由度（SDOF）振子的敏感性分析，这是物理学和工程学中的一个基本模型。基于方差的敏感性分析方法（Sobol指数）是一种成熟且严谨的数学技术。\n- 该问题是适定的（well-posed）。所有必需的参数、函数形式和输入的统计特性都已定义。对参数的约束（$T0$，$N\\ge 2$，$\\omega_n0$，$0\\le \\zeta  1$）确保了物理模型的良定义，并避免了诸如除以零之类的奇点。对于每组给定的参数集，都存在一个唯一的、稳定的敏感性指数解。\n- 该问题是客观和形式化的。它使用精确的数学语言陈述，没有歧义或主观成分。\n\n步骤 3：结论\n该问题有效。将提供一个合理的解决方案。\n\n模型输出 $Y$ 是随机输入变量 $U_i$ 的线性组合。我们可以将其写为：\n$$\nY = \\sum_{j=0}^{N-1} c_j U_j\n$$\n其中系数 $c_j$ 是确定性的，由下式给出：\n$$\nc_j = h(T-t_j)\\,\\Delta t\n$$\n任务是计算每个输入 $U_i$ 的一阶敏感性指数 $S_i$，其定义为：\n$$\nS_i = \\frac{\\operatorname{Var}(\\mathbb{E}[Y \\mid U_i])}{\\operatorname{Var}(Y)}\n$$\n我们必须首先计算输出的总方差 $\\operatorname{Var}(Y)$ 和偏方差 $\\operatorname{Var}(\\mathbb{E}[Y \\mid U_i])$。\n\n1.  计算总方差 $\\operatorname{Var}(Y)$：\n    输入变量 $U_j$ 是相互独立的。因此，$Y$ 的求和式中的项 $c_j U_j$ 也是相互独立的。独立随机变量之和的方差等于它们方差之和。\n    $$\n    \\operatorname{Var}(Y) = \\operatorname{Var}\\left(\\sum_{j=0}^{N-1} c_j U_j\\right) = \\sum_{j=0}^{N-1} \\operatorname{Var}(c_j U_j)\n    $$\n    使用属性 $\\operatorname{Var}(aX) = a^2\\operatorname{Var}(X)$（其中 $a$ 是常数，$X$ 是随机变量），我们有：\n    $$\n    \\operatorname{Var}(c_j U_j) = c_j^2 \\operatorname{Var}(U_j) = c_j^2 \\sigma_j^2\n    $$\n    因此，总方差为：\n    $$\n    \\operatorname{Var}(Y) = \\sum_{j=0}^{N-1} c_j^2 \\sigma_j^2\n    $$\n\n2.  计算偏方差 $\\operatorname{Var}(\\mathbb{E}[Y \\mid U_i])$：\n    首先，我们求条件期望 $\\mathbb{E}[Y \\mid U_i]$。根据期望的线性性质：\n    $$\n    \\mathbb{E}[Y \\mid U_i] = \\mathbb{E}\\left[\\sum_{j=0}^{N-1} c_j U_j \\;\\Bigg|\\; U_i\\right] = \\sum_{j=0}^{N-1} \\mathbb{E}[c_j U_j \\mid U_i]\n    $$\n    我们将求和式拆分为索引为 $j=i$ 的项和所有索引为 $j \\neq i$ 的项：\n    $$\n    \\mathbb{E}[Y \\mid U_i] = \\mathbb{E}[c_i U_i \\mid U_i] + \\sum_{j \\neq i} \\mathbb{E}[c_j U_j \\mid U_i]\n    $$\n    对于项 $j=i$，$U_i$ 是已知的，因此 $\\mathbb{E}[c_i U_i \\mid U_i] = c_i U_i$。\n    对于任何项 $j \\neq i$，$U_j$ 独立于 $U_i$。因此，以 $U_i$ 为条件不影响 $U_j$ 的期望。\n    $$\n    \\mathbb{E}[c_j U_j \\mid U_i] = c_j \\mathbb{E}[U_j]\n    $$\n    因为给定对所有 $j$ 都有 $\\mathbb{E}[U_j] = 0$，所以该项为零。\n    结合这些结果，条件期望简化为：\n    $$\n    \\mathbb{E}[Y \\mid U_i] = c_i U_i\n    $$\n    现在我们计算该表达式的方差：\n    $$\n    \\operatorname{Var}(\\mathbb{E}[Y \\mid U_i]) = \\operatorname{Var}(c_i U_i) = c_i^2 \\operatorname{Var}(U_i) = c_i^2 \\sigma_i^2\n    $$\n\n3.  构建灵敏度指数 $S_i$ 的公式：\n    将总方差和偏方差的表达式代入 $S_i$ 的定义中：\n    $$\n    S_i = \\frac{c_i^2 \\sigma_i^2}{\\sum_{j=0}^{N-1} c_j^2 \\sigma_j^2}\n    $$\n    现在，我们代入 $c_j = h(T-t_j)\\Delta t$：\n    $$\n    S_i = \\frac{\\left(h(T-t_i)\\Delta t\\right)^2 \\sigma_i^2}{\\sum_{j=0}^{N-1} \\left(h(T-t_j)\\Delta t\\right)^2 \\sigma_j^2}\n    $$\n    因子 $(\\Delta t)^2$ 同时出现在分子和分母求和的每一项中，因此可以消去。这一消去过程显著简化了 $S_i$ 的表达式，消除了对 $\\Delta t$ 的依赖：\n    $$\n    S_i = \\frac{h(T-t_i)^2 \\sigma_i^2}{\\sum_{j=0}^{N-1} h(T-t_j)^2 \\sigma_j^2}\n    $$\n    这是用于计算的最终公式。如果分母中的总方差为零（这意味着输出 $Y$ 是一个常数），则分子中的所有偏方差也必须为零。在这种特殊情况下，输出对所有输入都不敏感，并且所有 $S_i$ 都定义为 $0$。\n\n算法如下：\n对于每组给定的参数集 $(T,N,\\omega_n,\\zeta,\\beta,\\{\\sigma_i^2\\})$：\n1.  计算时间点 $t_i = i \\frac{T}{N-1}$，其中 $i=0,\\dots,N-1$。\n2.  计算脉冲响应函数的参数：$\\tau_i = T - t_i$。\n3.  计算有阻尼固有频率 $\\omega_d = \\omega_n\\sqrt{1-\\zeta^2}$。\n4.  对每个 $\\tau_i$ 求值脉冲响应函数 $h_i = h(\\tau_i)$。\n5.  计算分子项（与偏方差成正比），$D_i = h_i^2 \\sigma_i^2$。\n6.  计算分母（与总方差成正比），$D = \\sum_{j=0}^{N-1} D_j$。\n7.  如果 $D=0$，则所有 $S_i$ 都为 $0$。否则，计算每个灵敏度指数为 $S_i = D_i / D$。\n8.  收集当前情况下的结果列表 $[S_0, \\dots, S_{N-1}]$。\n对所有四种测试情况重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes first-order variance-based sensitivity indices for a linear SDOF model.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (5.0, 5, 2.0, 0.1, 1.0, [1.0, 1.0, 1.0, 1.0, 1.0]),\n        (np.pi, 5, 1.0, 0.0, 1.0, [1.0, 1.0, 1.0, 1.0, 1.0]),\n        (4.0, 4, 1.5, 0.2, 1.0, [1.0, 0.0, 2.0, 0.0]),\n        (2.0, 6, 3.0, 0.05, 1.0, [0.5, 1.5, 0.2, 2.5, 1.0, 0.3]),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        T, N, wn, zeta, beta, sigma_sq_list = case\n        \n        # Convert list to numpy array for vectorized operations\n        sigma_sq = np.array(sigma_sq_list)\n\n        # 1. Calculate time points and arguments for h(tau)\n        # Time nodes t_i from 0 to T\n        t = np.linspace(0, T, N)\n        # Arguments for h are tau_i = T - t_i. This is equivalent to time-reversing\n        # the linspace from T to 0.\n        tau = np.linspace(T, 0, N)\n\n        # 2. Calculate derived physical parameters\n        # Damped natural frequency, wd\n        wd = wn * np.sqrt(1 - zeta**2)\n\n        # 3. Evaluate the impulse response function h(tau)\n        # h(tau) = (beta / wd) * exp(-zeta * wn * tau) * sin(wd * tau)\n        # The case wd = 0 corresponds to zeta = 1 (critical damping), which is\n        # excluded by problem constraints (zeta  1).\n        # However, for numerical stability, if wd is very small, sin(wd*tau)/wd approaches tau.\n        # Given the problem constraints, a direct computation is safe.\n        h_coeffs = (beta / wd) * np.exp(-zeta * wn * tau) * np.sin(wd * tau)\n\n        # 4. Calculate terms proportional to partial variances\n        # D_i = h(T-t_i)^2 * sigma_i^2\n        partial_vars = h_coeffs**2 * sigma_sq\n\n        # 5. Calculate term proportional to total variance\n        # D = sum(D_j)\n        total_var = np.sum(partial_vars)\n\n        # 6. Compute sensitivity indices S_i = D_i / D\n        if total_var == 0:\n            # If total variance is zero, output is constant, so it is insensitive to all inputs.\n            s_indices = np.zeros(N)\n        else:\n            s_indices = partial_vars / total_var\n\n        all_results.append(s_indices.tolist())\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a list of lists.\n    # map(str, ...) converts each inner list to its string form, e.g., '[0.1, 0.2]'.\n    # ','.join(...) joins these strings with commas.\n    # The outer f\"[{...}]\" wraps the result in brackets.\n    # e.g., \"[[0.1, 0.2],[0.3, 0.4]]\"\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2434842"}]}