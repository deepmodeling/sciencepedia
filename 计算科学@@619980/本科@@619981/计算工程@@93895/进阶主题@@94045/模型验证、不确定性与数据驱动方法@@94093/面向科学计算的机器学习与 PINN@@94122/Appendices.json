{"hands_on_practices": [{"introduction": "物理知识通知的神经网络（PINN）的核心在于其损失函数的设计，该函数将物理定律编码为可优化的目标。这个练习将指导你构建一个复合损失函数，它不仅包括偏微分方程（PDE）的残差和初始条件的数据失配，还引入了一个重要的物理守恒定律作为软约束。通过这个实践 [@problem_id:2411025]，你将学会如何将不同的物理原则（如控制方程、边界/初始条件和守恒律）统一到一个目标函数中，这是构建有效 PINN 的基础技能。", "problem": "考虑一个周期性域上的一维热方程。设 $x \\in [0,1]$ 且 $t \\in [0,0.1]$。场 $u(x,t)$ 由一个用于物理信息神经网络 (PINN) 的代理模型建模，其参数化形式如下：\n$$\nu(x,t;\\theta) \\;=\\; \\theta_1 \\cdot 1 \\;+\\; \\theta_2 \\sin(2\\pi x) \\;+\\; \\theta_3 \\cos(2\\pi x) \\;+\\; \\theta_4\\, t\\, \\sin(2\\pi x) \\;+\\; \\theta_5\\, t\\, \\cos(2\\pi x),\n$$\n其中 $\\theta = (\\theta_1,\\theta_2,\\theta_3,\\theta_4,\\theta_5) \\in \\mathbb{R}^5$ 是可训练参数。其控制偏微分方程 (PDE) 为热方程：\n$$\nu_t \\;-\\; \\nu\\, u_{xx} \\;=\\; 0,\n$$\n其中粘度 $\\nu \\ge 0$，且在 $x$ 方向上具有周期性边界条件。初始条件指定为\n$$\nu(x,0) \\;=\\; u_0(x) \\;=\\; 0.5 \\;+\\; \\sin(2\\pi x),\n$$\n因此，由周期性得到的守恒空间积分（总质量）为\n$$\nM_0 \\;=\\; \\int_0^1 u(x,0)\\,dx \\;=\\; 0.5.\n$$\n\n定义一个复合 PINN 损失函数，该函数将 PDE、初始条件数据和守恒定律作为软约束来强制执行：\n$$\n\\mathcal{L}_{\\text{total}}(\\theta;\\nu,w_{\\text{pde}},w_{\\text{data}},w_{\\text{cons}}) \\;=\\; w_{\\text{pde}}\\,\\mathcal{L}_{\\text{pde}}(\\theta;\\nu) \\;+\\; w_{\\text{data}}\\,\\mathcal{L}_{\\text{data}}(\\theta) \\;+\\; w_{\\text{cons}}\\,\\mathcal{L}_{\\text{cons}}(\\theta),\n$$\n其中\n- PDE 残差损失 $\\mathcal{L}_{\\text{pde}}$ 是在固定的配置点网格上计算的残差 $r(x,t;\\theta,\\nu) = u_t(x,t;\\theta) - \\nu\\,u_{xx}(x,t;\\theta)$ 的均方值：\n$$\n\\mathcal{L}_{\\text{pde}}(\\theta;\\nu) \\;=\\; \\frac{1}{|\\mathcal{G}|} \\sum_{(x,t)\\in \\mathcal{G}} \\left[ u_t(x,t;\\theta) \\;-\\; \\nu\\,u_{xx}(x,t;\\theta) \\right]^2,\n$$\n其中配置点网格为 $\\mathcal{G} = \\{0,\\, 0.25,\\, 0.5,\\, 0.75,\\, 1.0\\} \\times \\{0,\\, 0.05,\\, 0.1\\}$。\n- 数据损失 $\\mathcal{L}_{\\text{data}}$ 是在指定的初始数据点上与初始条件的均方不匹配：\n$$\n\\mathcal{L}_{\\text{data}}(\\theta) \\;=\\; \\frac{1}{|\\mathcal{D}|} \\sum_{x\\in \\mathcal{D}} \\left[ u(x,0;\\theta) \\;-\\; u_0(x) \\right]^2,\n$$\n其中初始数据集为 $\\mathcal{D} = \\{0,\\, 0.25,\\, 0.5,\\, 0.75,\\, 1.0\\}$。\n- 守恒软约束损失 $\\mathcal{L}_{\\text{cons}}$ 强制 $u$ 在选定时间点上对 $x$ 的积分保持等于 $M_0$：\n$$\n\\mathcal{L}_{\\text{cons}}(\\theta) \\;=\\; \\frac{1}{|\\mathcal{T}_{\\text{mass}}|} \\sum_{t\\in \\mathcal{T}_{\\text{mass}}} \\left[ \\left( \\int_0^1 u(x,t;\\theta)\\,dx \\right) - M_0 \\right]^2,\n$$\n其中 $\\mathcal{T}_{\\text{mass}} = \\{0,\\, 0.05,\\, 0.1\\}$。对于给定的代理模型 $u$，积分 $\\int_0^1 u(x,t;\\theta)\\,dx$ 必须精确计算。\n\n所需的导数由代理模型通过常规微积分法则定义：\n$$\nu_t(x,t;\\theta) \\;=\\; \\theta_4\\,\\sin(2\\pi x) \\;+\\; \\theta_5\\,\\cos(2\\pi x),\n$$\n$$\nu_{xx}(x,t;\\theta) \\;=\\; - (2\\pi)^2 \\left[ \\theta_2 \\sin(2\\pi x) \\;+\\; \\theta_3 \\cos(2\\pi x) \\;+\\; \\theta_4\\,t\\,\\sin(2\\pi x) \\;+\\; \\theta_5\\,t\\,\\cos(2\\pi x) \\right].\n$$\n所用基函数在一个空间周期上的精确积分为\n$$\n\\int_0^1 \\sin(2\\pi x)\\,dx \\;=\\; 0,\\quad \\int_0^1 \\cos(2\\pi x)\\,dx \\;=\\; 0,\\quad \\int_0^1 1\\,dx \\;=\\; 1,\n$$\n因此对于指定的代理模型，\n$$\n\\int_0^1 u(x,t;\\theta)\\,dx \\;=\\; \\theta_1.\n$$\n\n您的程序必须为以下每个测试用例计算 $\\mathcal{L}_{\\text{total}}$，每个测试用例由一个元组 $(\\theta,\\nu,w_{\\text{pde}},w_{\\text{data}},w_{\\text{cons}})$ 给出：\n- 测试用例 1: $\\theta = (0.3,\\, 0.8,\\, -0.2,\\, 0.1,\\, 0.05)$，$\\nu = 0.1$，$w_{\\text{pde}} = 1.0$，$w_{\\text{data}} = 1.0$，$w_{\\text{cons}} = 0.0$。\n- 测试用例 2: $\\theta = (0.3,\\, 0.8,\\, -0.2,\\, 0.1,\\, 0.05)$，$\\nu = 0.1$，$w_{\\text{pde}} = 1.0$，$w_{\\text{data}} = 1.0$，$w_{\\text{cons}} = 10.0$。\n- 测试用例 3: $\\theta = (0.7,\\, -0.5,\\, 0.25,\\, 0.0,\\, 0.0)$，$\\nu = 0.0$，$w_{\\text{pde}} = 1.0$，$w_{\\text{data}} = 1.0$，$w_{\\text{cons}} = 5.0$。\n- 测试用例 4: $\\theta = (0.5,\\, 0.0,\\, 1.0,\\, 0.0,\\, 0.0)$，$\\nu = 0.05$，$w_{\\text{pde}} = 0.5$，$w_{\\text{data}} = 2.0$，$w_{\\text{cons}} = 2.0$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4]$），其中 $r_i$ 是测试用例 $i$ 的 $\\mathcal{L}_{\\text{total}}$ 计算值。不得打印任何额外文本。", "solution": "问题陈述已被解析并确定为有效。该问题具有科学依据、良定、客观且自洽，代表了计算科学与工程领域的一项标准任务，特别是关于物理信息神经网络 (PINN)。我们可以继续进行求解。\n\n目标是为四个不同的测试用例计算总损失函数 $\\mathcal{L}_{\\text{total}}$。总损失是三个分量的加权和：PDE 残差损失 $\\mathcal{L}_{\\text{pde}}$、数据不匹配损失 $\\mathcal{L}_{\\text{data}}$ 和守恒定律损失 $\\mathcal{L}_{\\text{cons}}$。\n$$\n\\mathcal{L}_{\\text{total}}(\\theta;\\nu,w_{\\text{pde}},w_{\\text{data}},w_{\\text{cons}}) = w_{\\text{pde}}\\,\\mathcal{L}_{\\text{pde}}(\\theta;\\nu) + w_{\\text{data}}\\,\\mathcal{L}_{\\text{data}}(\\theta) + w_{\\text{cons}}\\,\\mathcal{L}_{\\text{cons}}(\\theta)\n$$\n我们将为每个分量损失分析并推导显式计算公式。\n\n**1. 数据损失 $\\mathcal{L}_{\\text{data}}(\\theta)$**\n\n数据损失衡量了代理模型在时间 $t=0$ 时的预测与给定初始条件 $u_0(x)$ 之间的均方误差。代理模型在 $t=0$ 时的形式为\n$$\nu(x,0;\\theta) = \\theta_1 + \\theta_2 \\sin(2\\pi x) + \\theta_3 \\cos(2\\pi x).\n$$\n初始条件为 $u_0(x) = 0.5 + \\sin(2\\pi x)$。在点 $x$ 处的误差为\n$$\ne_d(x;\\theta) = u(x,0;\\theta) - u_0(x) = (\\theta_1 - 0.5) + (\\theta_2 - 1)\\sin(2\\pi x) + \\theta_3 \\cos(2\\pi x).\n$$\n损失是在离散点集 $\\mathcal{D} = \\{0, 0.25, 0.5, 0.75, 1.0\\}$ 上 $e_d(x;\\theta)^2$ 的平均值。该集合的大小为 $|\\mathcal{D}| = 5$。\n$$\n\\mathcal{L}_{\\text{data}}(\\theta) = \\frac{1}{5} \\sum_{x \\in \\mathcal{D}} \\left[ e_d(x;\\theta) \\right]^2.\n$$\n我们在 $\\mathcal{D}$ 中的点上计算三角函数的值：\n- 对于 $x \\in \\{0, 1.0\\}$，$\\sin(2\\pi x)=0$，$\\cos(2\\pi x)=1$。\n- 对于 $x = 0.25$，$\\sin(2\\pi x)=1$，$\\cos(2\\pi x)=0$。\n- 对于 $x = 0.5$，$\\sin(2\\pi x)=0$，$\\cos(2\\pi x)=-1$。\n- 对于 $x = 0.75$，$\\sin(2\\pi x)=-1$，$\\cos(2\\pi x)=0$。\n误差平方和为：\n$$\n\\sum_{x \\in \\mathcal{D}} [e_d(x;\\theta)]^2 = [(\\theta_1-0.5)+\\theta_3]^2_{x=0} + [(\\theta_1-0.5)+(\\theta_2-1)]^2_{x=0.25} + [(\\theta_1-0.5)-\\theta_3]^2_{x=0.5} + [(\\theta_1-0.5)-(\\theta_2-1)]^2_{x=0.75} + [(\\theta_1-0.5)+\\theta_3]^2_{x=1.0}.\n$$\n该表达式可以直接实现。\n\n**2. 守恒损失 $\\mathcal{L}_{\\text{cons}}(\\theta)$**\n\n守恒损失惩罚了对守恒量 $M_0 = 0.5$ 的偏离。代理模型在空间域 $[0,1]$ 上的积分为：\n$$\n\\int_0^1 u(x,t;\\theta)\\,dx = \\int_0^1 \\left( \\theta_1 + \\theta_2 \\sin(2\\pi x) + \\theta_3 \\cos(2\\pi x) + \\theta_4 t \\sin(2\\pi x) + \\theta_5 t \\cos(2\\pi x) \\right) dx.\n$$\n根据正交关系 $\\int_0^1 \\sin(2\\pi x)dx = 0$ 和 $\\int_0^1 \\cos(2\\pi x)dx = 0$，积分简化为：\n$$\n\\int_0^1 u(x,t;\\theta)\\,dx = \\theta_1 \\int_0^1 1\\,dx = \\theta_1.\n$$\n这个结果与时间 $t$ 无关。损失定义为：\n$$\n\\mathcal{L}_{\\text{cons}}(\\theta) = \\frac{1}{|\\mathcal{T}_{\\text{mass}}|} \\sum_{t \\in \\mathcal{T}_{\\text{mass}}} \\left[ \\left( \\int_0^1 u(x,t;\\theta)\\,dx \\right) - M_0 \\right]^2 = \\frac{1}{3} \\sum_{t \\in \\mathcal{T}_{\\text{mass}}} [\\theta_1 - 0.5]^2.\n$$\n由于要求和的项不依赖于 $t$，这可以简化为：\n$$\n\\mathcal{L}_{\\text{cons}}(\\theta) = \\frac{1}{3} \\cdot 3 \\cdot (\\theta_1 - 0.5)^2 = (\\theta_1 - 0.5)^2.\n$$\n\n**3. PDE 残差损失 $\\mathcal{L}_{\\text{pde}}(\\theta; \\nu)$**\n\nPDE 残差为 $r(x,t;\\theta,\\nu) = u_t - \\nu u_{xx}$。使用所提供的导数：\n$$\nu_t(x,t;\\theta) = \\theta_4 \\sin(2\\pi x) + \\theta_5 \\cos(2\\pi x)\n$$\n$$\nu_{xx}(x,t;\\theta) = -(2\\pi)^2 \\left( (\\theta_2 + \\theta_4 t) \\sin(2\\pi x) + (\\theta_3 + \\theta_5 t) \\cos(2\\pi x) \\right)\n$$\n残差为：\n$$\nr(x,t) = [\\theta_4 + \\nu(2\\pi)^2(\\theta_2 + \\theta_4 t)]\\sin(2\\pi x) + [\\theta_5 + \\nu(2\\pi)^2(\\theta_3 + \\theta_5 t)]\\cos(2\\pi x).\n$$\n为简洁起见，我们定义与时间相关的系数：\n$$\nC_s(t) = \\theta_4 + \\nu(2\\pi)^2(\\theta_2 + \\theta_4 t)\n$$\n$$\nC_c(t) = \\theta_5 + \\nu(2\\pi)^2(\\theta_3 + \\theta_5 t)\n$$\n因此，$r(x,t) = C_s(t)\\sin(2\\pi x) + C_c(t)\\cos(2\\pi x)$。损失是在配置点网格 $\\mathcal{G} = \\{0, 0.25, 0.5, 0.75, 1.0\\} \\times \\{0, 0.05, 0.1\\}$ 上 $r(x,t)^2$ 的平均值。网格大小为 $|\\mathcal{G}| = 5 \\times 3 = 15$。\n$$\n\\mathcal{L}_{\\text{pde}}(\\theta; \\nu) = \\frac{1}{15} \\sum_{t \\in \\mathcal{T}_{\\text{pde}}} \\sum_{x \\in \\mathcal{D}} [r(x,t)]^2,\n$$\n其中 $\\mathcal{T}_{\\text{pde}} = \\{0, 0.05, 0.1\\}$。对于固定的时间 $t$，通过计算三角函数项的值，可以简化对 $x \\in \\mathcal{D}$ 的求和：\n$$\n\\sum_{x \\in \\mathcal{D}} [r(x,t)]^2 = [C_c(t)]^2_{x=0} + [C_s(t)]^2_{x=0.25} + [-C_c(t)]^2_{x=0.5} + [-C_s(t)]^2_{x=0.75} + [C_c(t)]^2_{x=1.0}\n= 3[C_c(t)]^2 + 2[C_s(t)]^2.\n$$\n因此，残差平方的总和是：\n$$\n\\sum_{(x,t) \\in \\mathcal{G}} [r(x,t)]^2 = \\sum_{t \\in \\mathcal{T}_{\\text{pde}}} (3[C_c(t)]^2 + 2[C_s(t)]^2).\n$$\n这为计算 $\\mathcal{L}_{\\text{pde}}$ 提供了一种直接的方法。\n\n利用这些显式公式，我们可以通过代入给定的参数值为每个测试用例计算 $\\mathcal{L}_{\\text{total}}$。下面的程序实现了这一逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the total PINN loss for several test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: (theta, nu, w_pde, w_data, w_cons)\n        ((0.3, 0.8, -0.2, 0.1, 0.05), 0.1, 1.0, 1.0, 0.0),\n        # Case 2\n        ((0.3, 0.8, -0.2, 0.1, 0.05), 0.1, 1.0, 1.0, 10.0),\n        # Case 3\n        ((0.7, -0.5, 0.25, 0.0, 0.0), 0.0, 1.0, 1.0, 5.0),\n        # Case 4\n        ((0.5, 0.0, 1.0, 0.0, 0.0), 0.05, 0.5, 2.0, 2.0),\n    ]\n\n    # Define grids and constants\n    X_grid = np.array([0.0, 0.25, 0.5, 0.75, 1.0])\n    T_grid = np.array([0.0, 0.05, 0.1])\n    M0 = 0.5\n    \n    results = []\n\n    for case in test_cases:\n        theta_vec, nu, w_pde, w_data, w_cons = case\n        th1, th2, th3, th4, th5 = theta_vec\n\n        # -- 1. Compute Data Loss (L_data) --\n        # u(x,0) = th1 + th2*sin(2*pi*x) + th3*cos(2*pi*x)\n        # u0(x)  = 0.5 + sin(2*pi*x)\n        # error(x) = (th1-0.5) + (th2-1)*sin(2*pi*x) + th3*cos(2*pi*x)\n        \n        sin_vals = np.sin(2 * np.pi * X_grid)\n        cos_vals = np.cos(2 * np.pi * X_grid)\n        \n        error_data = (th1 - M0) + (th2 - 1.0) * sin_vals + th3 * cos_vals\n        L_data = np.mean(error_data**2)\n        \n        # -- 2. Compute Conservation Loss (L_cons) --\n        # integral u(x,t) dx = th1\n        # L_cons = (th1 - M0)^2\n        L_cons = (th1 - M0)**2\n        \n        # -- 3. Compute PDE Residual Loss (L_pde) --\n        # r(x,t) = u_t - nu * u_xx\n        # u_t = th4*sin(2*pi*x) + th5*cos(2*pi*x)\n        # u_xx = -(2*pi)^2 * [ (th2 + th4*t)*sin(2*pi*x) + (th3 + th5*t)*cos(2*pi*x) ]\n        \n        k = (2 * np.pi)**2\n        \n        sum_sq_res = 0.0\n        for t in T_grid:\n            # Coefficients of sin(2*pi*x) and cos(2*pi*x) in the residual\n            C_s_t = th4 + nu * k * (th2 + th4 * t)\n            C_c_t = th5 + nu * k * (th3 + th5 * t)\n            \n            # r(x,t) = C_s_t * sin(2*pi*x) + C_c_t * cos(2*pi*x)\n            # We calculated the sum over x analytically to simplify:\n            # sum_{x in D} r(x,t)^2 = 2 * C_s_t^2 + 3 * C_c_t^2\n            sum_sq_res_t = 2 * C_s_t**2 + 3 * C_c_t**2\n            sum_sq_res += sum_sq_res_t\n            \n        L_pde = sum_sq_res / (len(X_grid) * len(T_grid))\n\n        # -- 4. Compute Total Loss (L_total) --\n        L_total = w_pde * L_pde + w_data * L_data + w_cons * L_cons\n        results.append(L_total)\n\n    # Format the final output string\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "2411025"}, {"introduction": "除了在损失函数中添加惩罚项，我们还可以将物理知识直接“烘焙”到模型架构中，这被称为施加“硬约束”。本练习将通过一个轴对称管流问题来探索这一强大技术 [@problem_id:2411045]。你将设计一个能够自动满足无滑移边界条件的网络结构，从而简化学习任务并提高模型的鲁棒性。这个实践旨在展示，深思熟虑的模型架构设计如何通过保证某些物理定律的满足来提升 PINN 的效率和精度。", "problem": "您的任务是设计并实现一个物理信息神经网络 (PINN)，该网络结合已知的轴对称性来降低用于稳态、充分发展、不可压缩的直圆管层流的输入空间维度。除非另有明确定义，否则将所有量视为无量纲。目标是在架构层面利用几何对称性和边界条件，然后通过最小化控制方程残差来确定模型参数。\n\n起点 (基本依据)：在轴对称、无旋流、无径向或周向速度以及充分发展的轴向速度 $u(r)$ 的假设下，稳态不可压缩的 Navier–Stokes 方程在柱坐标系下可简化为以下标量常微分方程\n$$ \\frac{1}{r}\\frac{d}{dr}\\left(r \\frac{du}{dr}\\right) = S, $$\n其中 $r \\in [0,R]$ 是径向坐标，$R$ 是管道半径，而 $S = \\frac{1}{\\mu}\\frac{dp}{dx}$ 是一个常数，与轴向压力梯度 $\\frac{dp}{dx}$ 成正比，与动力粘度 $\\mu$ 成反比。符合物理现实的边界条件和正则性条件是\n$$ u(R) = 0, \\quad \\left|\\frac{du}{dr}(0)\\right| < \\infty. $$\n\n对称性感知的架构：通过使用轴对称不变量 $s = r^2$ 降低有效输入维度，并通过构造将边界条件和正则性条件嵌入到试探解中：\n$$ u_{\\theta}(r) = \\phi(r)\\, g_{\\theta}(s), \\quad \\phi(r) = 1 - \\left(\\frac{r}{R}\\right)^2, \\quad s = r^2. $$\n这种选择确保了对于所有参数值 $u_{\\theta}(R)=0$ 均成立，并得出 $\\frac{du_{\\theta}}{dr}(0)=0$，这与轴对称性和轴心处的光滑性要求一致。\n\n模型类别：使用仿射模型\n$$ g_{\\theta}(s) = \\theta_0 + \\theta_1 s, $$\n因此\n$$ u_{\\theta}(r) = \\left(1 - \\left(\\frac{r}{R}\\right)^2\\right)\\left(\\theta_0 + \\theta_1 r^2\\right). $$\n\n物理损失：将控制方程的残差定义为\n$$ \\mathcal{R}(r;\\theta) = \\left(\\frac{d^2}{dr^2} + \\frac{1}{r}\\frac{d}{dr}\\right) u_{\\theta}(r) - S, \\quad r \\in (0,R]. $$\n在一组内部配置点 $\\{r_i\\}_{i=1}^N \\subset (0,R]$ 上最小化均方残差：\n$$ \\min_{\\theta \\in \\mathbb{R}^2} \\frac{1}{N} \\sum_{i=1}^N \\left(\\mathcal{R}(r_i;\\theta)\\right)^2. $$\n请注意，该架构消除了对单独边界损失项的需求。\n\n推导要求：仅从给定的微分算子和架构定义出发，基于在 $g_{\\theta}(s)$ 的仿射选择下残差是关于 $\\theta$ 的线性函数这一认识，推导出模型参数的线性系统。展示如何计算作用于两个基函数上的算子\n$$ u_1(r) = \\phi(r), \\quad u_2(r) = \\phi(r)\\, r^2, $$\n使得\n$$ \\left(\\frac{d^2}{dr^2} + \\frac{1}{r}\\frac{d}{dr}\\right)u_{\\theta}(r) = \\theta_0\\, \\mathcal{L}[u_1](r) + \\theta_1\\, \\mathcal{L}[u_2](r), $$\n其中 $\\mathcal{L}[\\cdot]$ 表示微分算子。利用此结果构建一个超定线性系统 $A \\theta \\approx b$，其中 $A_{i0} = \\mathcal{L}[u_1](r_i)$，$A_{i1} = \\mathcal{L}[u_2](r_i)$，$b_i = S$，并通过最小二乘法估计 $\\theta$。\n\n评估：对于下方的每个测试用例，在估计出 $\\theta$ 后，在一个 $M$ 值足够大的均匀评估网格 $\\{r_j\\}_{j=1}^{M}$ 上，计算学习到的解 $u_{\\theta}(r)$ 与精确解之间的最大绝对逐点误差：\n$$ u_{\\text{exact}}(r) = -\\frac{S R^2}{4} \\left(1 - \\left(\\frac{r}{R}\\right)^2\\right), \\quad \\varepsilon_{\\infty} = \\max_{1 \\le j \\le M} \\left| u_{\\theta}(r_j) - u_{\\text{exact}}(r_j) \\right|. $$\n\n角度单位：不适用。物理单位：将所有变量视为无量纲；以无单位小数形式报告误差。\n\n测试套件：使用以下参数集，每个参数集指定为 $(R,\\mu,dpdx)$，其中 $S = \\frac{dpdx}{\\mu}$：\n- 用例 $1$：$(R,\\mu,dpdx) = (1.0, 1.0, -8.0)$。\n- 用例 $2$：$(R,\\mu,dpdx) = (0.5, 2.0, -5.0)$。\n- 用例 $3$ (边缘情况：零强迫项)：$(R,\\mu,dpdx) = (1.0, 1.0, 0.0)$。\n- 用例 $4$：$(R,\\mu,dpdx) = (1.25, 0.8, -3.333333333333333)$。\n\n您的程序必须：\n- 构建对称性感知的模型，并按所述设置最小二乘系统。\n- 使用一个不包含 $r=0$ 的内部配置点集，以避免在中间表达式中出现除以零的情况，但在评估误差时应包括 $r=0$，必要时使用闭式表达式以避免奇点。\n- 对每个测试用例，计算如上定义的 $\\varepsilon_{\\infty}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，结果按测试套件用例的顺序排列，采用科学记数法并保留六位有效数字，例如 $[a_1,a_2,a_3,a_4]$，其中每个 $a_k$ 是第 $k$ 个用例的 $\\varepsilon_{\\infty}$ 值。", "solution": "问题已经过验证。\n\n### 步骤 1：提取已知条件\n- **控制方程：**稳态、不可压缩、轴对称、充分发展的层流管道流由以下常微分方程 (ODE) 描述：\n$$ \\frac{1}{r}\\frac{d}{dr}\\left(r \\frac{du}{dr}\\right) = S, \\quad r \\in [0,R] $$\n- **常数和变量：**\n    - $u(r)$：轴向速度剖面。\n    - $r$：径向坐标。\n    - $R$：管道半径。\n    - $S = \\frac{1}{\\mu}\\frac{dp}{dx}$：与轴向压力梯度 $\\frac{dp}{dx}$ 和动力粘度 $\\mu$ 相关的常数。\n- **边界与正则性条件：**\n    - 无滑移条件：$u(R) = 0$。\n    - 中心线处的光滑性：$\\left|\\frac{du}{dr}(0)\\right| < \\infty$。\n- **对称性感知的架构：**\n    - 试探解形式：$u_{\\theta}(r) = \\phi(r)\\, g_{\\theta}(s)$。\n    - 输入不变量：$s = r^2$。\n    - 边界条件强制函数：$\\phi(r) = 1 - \\left(\\frac{r}{R}\\right)^2$。\n    - 网络模型类别：$g_{\\theta}(s) = \\theta_0 + \\theta_1 s$。\n    - 组合试探解：$u_{\\theta}(r) = \\left(1 - \\left(\\frac{r}{R}\\right)^2\\right)\\left(\\theta_0 + \\theta_1 r^2\\right)$，其中 $\\theta = [\\theta_0, \\theta_1]^T$ 是可学习参数。\n- **物理损失函数公式：**\n    - 微分算子：$\\mathcal{L}[\\cdot] = \\frac{d^2}{dr^2} + \\frac{1}{r}\\frac{d}{dr}$。\n    - 残差：$\\mathcal{R}(r;\\theta) = \\mathcal{L}[u_{\\theta}(r)] - S$。\n    - 目标函数：在 $N$ 个内部配置点 $\\{r_i\\}_{i=1}^N \\subset (0,R]$ 上最小化均方残差：$\\min_{\\theta} \\frac{1}{N} \\sum_{i=1}^N \\left(\\mathcal{R}(r_i;\\theta)\\right)^2$。\n- **推导要求：**\n    - 分解算子的作用：$\\mathcal{L}[u_{\\theta}(r)] = \\theta_0\\, \\mathcal{L}[u_1](r) + \\theta_1\\, \\mathcal{L}[u_2](r)$。\n    - 基函数：$u_1(r) = \\phi(r)$, $u_2(r) = \\phi(r)\\, r^2$。\n    - 构建超定线性系统 $A \\theta \\approx b$，其中 $A_{i0} = \\mathcal{L}[u_1](r_i)$，$A_{i1} = \\mathcal{L}[u_2](r_i)$，$b_i = S$。\n- **评估指标：**\n    - 精确解：$u_{\\text{exact}}(r) = -\\frac{S R^2}{4} \\left(1 - \\left(\\frac{r}{R}\\right)^2\\right)$。\n    - 最大绝对逐点误差：$\\varepsilon_{\\infty} = \\max_{j} \\left| u_{\\theta}(r_j) - u_{\\text{exact}}(r_j) \\right|$，在一个精细网格 $\\{r_j\\}_{j=1}^{M}$ 上计算。\n- **测试套件：**\n    - 用例 1：$(R,\\mu,dpdx) = (1.0, 1.0, -8.0)$。\n    - 用例 2：$(R,\\mu,dpdx) = (0.5, 2.0, -5.0)$。\n    - 用例 3：$(R,\\mu,dpdx) = (1.0, 1.0, 0.0)$。\n    - 用例 4：$(R,\\mu,dpdx) = (1.25, 0.8, -3.333333333333333)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n- **科学依据：**该问题基于为 Hagen-Poiseuille 流简化的 Navier-Stokes 方程，这是流体动力学的基石。求解方法是加权残差法的一种形式（具体来说是最小二乘配置法），是计算科学与工程中的一种标准而严谨的技术。“PINN” 术语被正确地应用于一个通过最小化基于物理的残差来确定模型参数的场景。\n- **适定性：**该问题提供了一个定义明确的二阶常微分方程和充分的边界条件。所提出的模型架构和损失函数导出一个线性最小二乘问题，已知该问题有唯一且稳定的解。所有必要的数据和定义都已提供。\n- **客观性：**问题以精确、正式和客观的数学和物理语言陈述。它不含主观或模棱两可的术语。\n- **其他缺陷：**该问题是自洽的、一致的且计算上可行的。给定的模型架构足以精确表示已知的解析解，这对该方法构成了强有力的检验。\n\n### 步骤 3：结论与行动\n**问题是有效的**。这是一个在科学计算领域精心设计的好练习，正确地展示了物理信息建模的原理。将提供解答。\n\n### 解答推导\n任务是通过最小化控制方程的残差来找到参数 $\\theta = [\\theta_0, \\theta_1]^T$。试探解是基函数的线性组合：\n$$ u_{\\theta}(r) = \\theta_0 u_1(r) + \\theta_1 u_2(r) $$\n其中基函数为\n$$ u_1(r) = 1 - \\frac{r^2}{R^2} $$\n$$ u_2(r) = \\left(1 - \\frac{r^2}{R^2}\\right)r^2 = r^2 - \\frac{r^4}{R^2} $$\n微分算子为 $\\mathcal{L}[\\cdot] = \\frac{d^2}{dr^2} + \\frac{1}{r}\\frac{d}{dr}$。我们必须计算它作用于每个基函数上的结果。\n\n对于 $u_1(r)$：\n首先，我们求导数：\n$$ \\frac{du_1}{dr} = -\\frac{2r}{R^2} $$\n$$ \\frac{d^2u_1}{dr^2} = -\\frac{2}{R^2} $$\n现在，我们应用算子 $\\mathcal{L}$：\n$$ \\mathcal{L}[u_1](r) = \\frac{d^2u_1}{dr^2} + \\frac{1}{r}\\frac{du_1}{dr} = \\left(-\\frac{2}{R^2}\\right) + \\frac{1}{r}\\left(-\\frac{2r}{R^2}\\right) = -\\frac{2}{R^2} - \\frac{2}{R^2} = -\\frac{4}{R^2} $$\n\n对于 $u_2(r)$：\n首先，我们求导数：\n$$ \\frac{du_2}{dr} = 2r - \\frac{4r^3}{R^2} $$\n$$ \\frac{d^2u_2}{dr^2} = 2 - \\frac{12r^2}{R^2} $$\n现在，我们应用算子 $\\mathcal{L}$：\n$$ \\mathcal{L}[u_2](r) = \\frac{d^2u_2}{dr^2} + \\frac{1}{r}\\frac{du_2}{dr} = \\left(2 - \\frac{12r^2}{R^2}\\right) + \\frac{1}{r}\\left(2r - \\frac{4r^3}{R^2}\\right) $$\n$$ \\mathcal{L}[u_2](r) = 2 - \\frac{12r^2}{R^2} + 2 - \\frac{4r^2}{R^2} = 4 - \\frac{16r^2}{R^2} $$\n\n控制方程的残差由 $\\mathcal{R}(r;\\theta) = \\mathcal{L}[u_{\\theta}(r)] - S$ 给出。利用算子 $\\mathcal{L}$ 的线性性质：\n$$ \\mathcal{R}(r;\\theta) = \\theta_0 \\mathcal{L}[u_1](r) + \\theta_1 \\mathcal{L}[u_2](r) - S $$\n代入推导出的表达式：\n$$ \\mathcal{R}(r;\\theta) = \\theta_0 \\left(-\\frac{4}{R^2}\\right) + \\theta_1 \\left(4 - \\frac{16r^2}{R^2}\\right) - S $$\n为了在一组 $N$ 个配置点 $\\{r_i\\}_{i=1}^N$ 上最小化残差平方和，我们在最小二乘意义上求解线性系统 $A\\theta \\approx b$。对于对应于点 $r_i$的第 $i$ 行，该系统是：\n$$ \\begin{pmatrix} \\mathcal{L}[u_1](r_i) & \\mathcal{L}[u_2](r_i) \\end{pmatrix} \\begin{pmatrix} \\theta_0 \\\\ \\theta_1 \\end{pmatrix} = S $$\n因此，矩阵 $A$ 和向量 $b$ 构建如下：\n$$ A = \\begin{pmatrix} -4/R^2 & 4 - 16r_1^2/R^2 \\\\ -4/R^2 & 4 - 16r_2^2/R^2 \\\\ \\vdots & \\vdots \\\\ -4/R^2 & 4 - 16r_N^2/R^2 \\end{pmatrix}, \\quad b = \\begin{pmatrix} S \\\\ S \\\\ \\vdots \\\\ S \\end{pmatrix} $$\n最优参数 $\\theta$ 通过求解正规方程 $(A^TA)\\theta = A^Tb$ 得到。\n\n一个关键的观察是，解析解 $u_{\\text{exact}}(r)$ 可以写成：\n$$ u_{\\text{exact}}(r) = \\left(-\\frac{SR^2}{4}\\right)\\left(1 - \\frac{r^2}{R^2}\\right) $$\n这与试探解 $u_{\\theta}(r)$ 在特定参数选择 $\\theta_0 = -SR^2/4$ 和 $\\theta_1 = 0$ 时的形式相匹配。对于此选择，残差对所有 $r$ 恒为零：\n$$ \\mathcal{R}(r; \\theta_{exact}) = \\left(-\\frac{SR^2}{4}\\right)\\left(-\\frac{4}{R^2}\\right) + (0)\\left(4 - \\frac{16r^2}{R^2}\\right) - S = S - S = 0 $$\n因为模型类别包含了精确解，所以残差的最小二乘最小化必然会找到这些精确参数，从而得到一个与 $u_{exact}(r)$ 完全相同的解 $u_{\\theta}(r)$。因此，最大绝对误差 $\\varepsilon_{\\infty}$ 预计为零（在浮点精度限制内）。实现过程将验证这一点。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are permitted.\n\ndef solve():\n    \"\"\"\n    Designs and implements a physics-informed model for laminar pipe flow,\n    solves for its parameters using a linear least-squares formulation on the\n    governing equation's residual, and evaluates the error against the\n    analytical solution for several test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple (R, mu, dpdx).\n    test_cases = [\n        (1.0, 1.0, -8.0),\n        (0.5, 2.0, -5.0),\n        (1.0, 1.0, 0.0),\n        (1.25, 0.8, -3.333333333333333),\n    ]\n\n    # Parameters for the numerical method\n    N_collocation = 100  # Number of interior collocation points\n    M_evaluation = 1001 # Number of points for error evaluation grid\n\n    results = []\n\n    for case in test_cases:\n        R, mu, dpdx = case\n        S = dpdx / mu\n\n        # 1. Set up the least-squares problem to find theta = [theta_0, theta_1]\n        \n        # Create a set of N interior collocation points in (0, R].\n        # Avoiding r=0 as per problem, although derived expressions are safe.\n        r_colloc = np.linspace(R / N_collocation, R, N_collocation)\n\n        # Construct the matrix A for the linear system A*theta = b.\n        # A has shape (N_collocation, 2).\n        A = np.zeros((N_collocation, 2))\n\n        # Column 0 corresponds to the operator applied to the first basis function u_1.\n        # L[u_1](r) = -4 / R^2, a constant.\n        A[:, 0] = -4.0 / (R**2)\n\n        # Column 1 corresponds to the operator applied to the second basis function u_2.\n        # L[u_2](r) = 4 - 16 * r^2 / R^2.\n        A[:, 1] = 4.0 - 16.0 * (r_colloc**2) / (R**2)\n\n        # Construct the vector b.\n        # b_i = S for all i.\n        b = np.full(N_collocation, S)\n        \n        # 2. Solve for the model parameters theta using linear least squares.\n        # This minimizes the L2 norm of the residual ||A*theta - b||^2.\n        theta, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n        theta_0, theta_1 = theta[0], theta[1]\n\n        # 3. Evaluate the error between the learned and exact solutions.\n        \n        # Create a fine grid of M evaluation points over [0, R].\n        r_eval = np.linspace(0.0, R, M_evaluation)\n\n        # Calculate the learned solution u_theta(r) on the evaluation grid.\n        # u_theta(r) = (1 - (r/R)^2) * (theta_0 + theta_1 * r^2)\n        phi_r = 1.0 - (r_eval / R)**2\n        g_theta_s = theta_0 + theta_1 * (r_eval**2)\n        u_theta = phi_r * g_theta_s\n\n        # Calculate the exact analytical solution u_exact(r) on the evaluation grid.\n        # u_exact(r) = -S * R^2 / 4 * (1 - (r/R)^2)\n        if S == 0.0:\n            u_exact = np.zeros_like(r_eval)\n        else:\n            u_exact = (-S * R**2 / 4.0) * (1.0 - (r_eval / R)**2)\n\n        # Compute the maximum absolute pointwise error.\n        epsilon_inf = np.max(np.abs(u_theta - u_exact))\n        results.append(epsilon_inf)\n\n    # Final print statement in the exact required format.\n    # Format: [a_1,a_2,...] with each value in scientific notation with 6 significant digits.\n    # The format specifier \".5e\" gives 1 digit before decimal and 5 after, a total of 6.\n    formatted_results = [f\"{res:.5e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2411045"}, {"introduction": "现在，让我们应用所学知识来解决一个计算流体动力学中的经典挑战：如何精确地满足不可压缩流体的无散度约束。在这个练习中，你将针对斯托克斯（Stokes）方程，实现并比较两种主流的策略来强制执行 $\\nabla \\cdot \\mathbf{u} = 0$ 条件。一种方法是在损失函数中添加“软”惩罚项，而另一种则利用流函数（stream-function）公式从结构上“硬”性满足该约束。这项高级实践 [@problem_id:2411040] 为软约束与硬约束提供了一个直接的比较，这对于为复杂的多物理场问题设计有效的 PINN 是一个至关重要的考量。", "problem": "您将实现并比较两种用于稳态、二维不可压缩Navier-Stokes方程在蠕动流极限（Stokes方程）下的物理信息神经网络（PINN）公式，并特别关注无散约束的施加方式。您的实现必须是一个完整、可运行的程序。\n\n控制方程为单位平方域上的稳态Stokes系统，其无量纲形式写作：\n$$\n-\\nabla p + \\nu \\nabla^2 \\mathbf{u} + \\mathbf{f} = \\mathbf{0}, \\quad \\nabla \\cdot \\mathbf{u} = 0,\n$$\n其中 $\\mathbf{u} = (u,v)$ 是速度， $p$ 是压力， $\\nu$ 是运动粘度（一个正常数），$\\mathbf{f}$ 是给定的体积力。\n\n为了提供一个科学上合理且可测试的设置，请使用人造解方法。将精确的流函数、速度和压力定义为：\n$$\n\\psi(x,y) = \\sin(\\pi x)\\sin(\\pi y), \\\\\nu^\\star(x,y) = \\frac{\\partial \\psi}{\\partial y} = \\pi \\sin(\\pi x)\\cos(\\pi y), \\\\\nv^\\star(x,y) = -\\frac{\\partial \\psi}{\\partial x} = -\\pi \\cos(\\pi x)\\sin(\\pi y), \\\\\np^\\star(x,y) = \\cos(\\pi x)\\cos(\\pi y),\n$$\n对于 $(x,y) \\in [0,1]^2$。设运动粘度为 $\\nu = 0.01$（一个正实数）。通过将 $(u^\\star,v^\\star,p^\\star)$ 代入Stokes动量平衡方程来定义体积力：\n$$\n\\mathbf{f} = \\nabla p^\\star - \\nu \\nabla^2 \\mathbf{u}^\\star,\n$$\n这样 $(\\mathbf{u}^\\star,p^\\star)$ 就能精确满足带有此 $\\mathbf{f}$ 的稳态Stokes方程。\n\n您将构建两种PINN变体，它们在一组配置点上最小化残差平方和，并由稀疏数据锚定。两种方法都使用一个小的、固定的特征基（可解释为带有三角激活函数的单隐藏层网络），以使问题在计算上易于处理，并且对输入是可解析微分的。\n\n- 方法A（软散度惩罚）：将 $u$、$v$ 和 $p$ 独立地参数化为三角特征的线性组合，\n$$\nu(x,y) = \\sum_{k=1}^{4} a_k \\,\\phi_k(x,y), \\quad v(x,y) = \\sum_{k=1}^{4} b_k \\,\\psi_k(x,y), \\quad p(x,y) = \\sum_{k=1}^{4} c_k \\,\\chi_k(x,y),\n$$\n其基函数与模式对 $(m,n)\\in\\{(1,1),(2,1),(1,2),(2,2)\\}$ 相关联：\n$$\n\\phi_{(m,n)}(x,y) = \\sin(m\\pi x)\\cos(n\\pi y), \\\\\n\\psi_{(m,n)}(x,y) = -\\cos(m\\pi x)\\sin(n\\pi y), \\\\\n\\chi_{(m,n)}(x,y) = \\cos(m\\pi x)\\cos(n\\pi y).\n$$\n最小化加权残差平方和，该和由内部配置点 $(x_i,y_i)$ 处的Stokes动量残差、一组锚点 $(\\tilde{x}_j,\\tilde{y}_j)$ 处与 $(u^\\star,v^\\star)$ 的稀疏速度数据失配、一个在 $(\\hat{x},\\hat{y})$ 处的标量压力锚点，以及一个权重为 $\\lambda \\ge 0$ 的散度惩罚项组成：\n$$\n\\mathcal{L}_\\text{soft} = \\frac{1}{N_\\Omega}\\sum_{i=1}^{N_\\Omega} \\left( r_u(x_i,y_i)^2 + r_v(x_i,y_i)^2 \\right) + \\alpha \\frac{1}{N_D}\\sum_{j=1}^{N_D} \\left[ \\left(u(\\tilde{x}_j,\\tilde{y}_j)-u^\\star(\\tilde{x}_j,\\tilde{y}_j)\\right)^2 + \\left(v(\\tilde{x}_j,\\tilde{y}_j)-v^\\star(\\tilde{x}_j,\\tilde{y}_j)\\right)^2 \\right] \\\\\n+ \\alpha_p \\left(p(\\hat{x},\\hat{y})-p^\\star(\\hat{x},\\hat{y})\\right)^2 + \\lambda \\frac{1}{N_\\Omega}\\sum_{i=1}^{N_\\Omega} \\left(\\frac{\\partial u}{\\partial x}(x_i,y_i) + \\frac{\\partial v}{\\partial y}(x_i,y_i)\\right)^2,\n$$\n其中\n$$\nr_u = -\\frac{\\partial p}{\\partial x} + \\nu \\nabla^2 u + f_x, \\quad r_v = -\\frac{\\partial p}{\\partial y} + \\nu \\nabla^2 v + f_y.\n$$\n三角基的所有空间导数都是解析的，并且必须使用。权重 $\\alpha$ 和 $\\alpha_p$ 是正实数。使用 $\\alpha = 10$ 和 $\\alpha_p = 10$。选择在 $(0,1)^2$ 上的 $8\\times 8$ 均匀网格上定义的 $N_\\Omega = 64$ 个内部点，以及在 $(0,1)^2$ 中使用固定伪随机种子均匀采样的 $N_D = 10$ 个锚点。\n\n- 方法B（通过流函数的硬散度约束）：通过使用流函数展开来构造性地施加 $\\nabla \\cdot \\mathbf{u} = 0$，\n$$\n\\psi(x,y) = \\sum_{k=1}^{4} s_k \\,\\sigma_k(x,y), \\quad \\sigma_{(m,n)}(x,y) = \\sin(m\\pi x)\\sin(n\\pi y),\n$$\n并定义\n$$\nu(x,y) = \\frac{\\partial \\psi}{\\partial y}(x,y), \\quad v(x,y) = -\\frac{\\partial \\psi}{\\partial x}(x,y), \\quad p(x,y) = \\sum_{k=1}^{4} c_k \\,\\chi_k(x,y),\n$$\n使用相同的压力基 $\\chi_k$。最小化\n$$\n\\mathcal{L}_\\text{hard} = \\frac{1}{N_\\Omega}\\sum_{i=1}^{N_\\Omega} \\left( r_u(x_i,y_i)^2 + r_v(x_i,y_i)^2 \\right) + \\alpha \\frac{1}{N_D}\\sum_{j=1}^{N_D} \\left[ \\left(u(\\tilde{x}_j,\\tilde{y}_j)-u^\\star(\\tilde{x}_j,\\tilde{y}_j)\\right)^2 + \\left(v(\\tilde{x}_j,\\tilde{y}_j)-v^\\star(\\tilde{x}_j,\\tilde{y}_j)\\right)^2 \\right] \\\\\n+ \\alpha_p \\left(p(\\hat{x},\\hat{y})-p^\\star(\\hat{x},\\hat{y})\\right)^2,\n$$\n其中 $r_u$ 和 $r_v$ 的定义同上，并且基的所有导数都是解析的。\n\n因为Stokes方程在 $(u,v,p)$ 上是线性的，并且上述参数化在系数上是线性的，所以残差在系数上是线性的。因此，上述每个优化问题都简化为一个标准线性最小二乘问题，形式为\n$$\n\\min_{\\boldsymbol{\\theta}} \\left\\| \\mathbf{W}(\\mathbf{A}\\boldsymbol{\\theta} - \\mathbf{b}) \\right\\|_2^2,\n$$\n其中 $\\boldsymbol{\\theta}$ 集合了所有系数。您必须根据解析的基导数显式地构建设计矩阵 $\\mathbf{A}$ 和右侧项 $\\mathbf{b}$，并使用一个鲁棒的线性最小二乘方法求解。\n\n测试套件规范：\n\n- 使用上述设置，其中 $\\nu = 0.01$（无单位）。使用已定义的精确解 $(u^\\star,v^\\star,p^\\star)$ 和 $\\mathbf{f}$。\n\n- 对于方法A（软散度），使用散度惩罚权重运行三种情况\n$$\n\\lambda \\in \\{0.0, 1.0, 100.0\\}.\n$$\n\n- 对于方法B（硬散度），求解一次（不需要 $\\lambda$ 参数）。\n\n为了评估，在 $(0,1)^2$ 上定义一个 $20\\times 20$ 的均匀间隔点验证网格。对于每种情况，计算：\n\n- 散度范数\n$$\n\\mathcal{N}_\\text{div} = \\sqrt{ \\frac{1}{N_V} \\sum_{q=1}^{N_V} \\left( \\frac{\\partial u}{\\partial x}(x_q,y_q) + \\frac{\\partial v}{\\partial y}(x_q,y_q) \\right)^2 },\n$$\n其中 $N_V = 400$ 是验证点的数量。\n\n- 动量残差范数\n$$\n\\mathcal{N}_\\text{mom} = \\sqrt{ \\frac{1}{N_V} \\sum_{q=1}^{N_V} \\left[ r_u(x_q,y_q)^2 + r_v(x_q,y_q)^2 \\right] }.\n$$\n\n- 相对速度误差\n$$\n\\mathcal{E}_\\mathbf{u} = \\frac{ \\sqrt{ \\frac{1}{N_V} \\sum_{q=1}^{N_V} \\left[ \\left(u(x_q,y_q)-u^\\star(x_q,y_q)\\right)^2 + \\left(v(x_q,y_q)-v^\\star(x_q,y_q)\\right)^2 \\right] } }{ \\sqrt{ \\frac{1}{N_V} \\sum_{q=1}^{N_V} \\left[ \\left(u^\\star(x_q,y_q)\\right)^2 + \\left(v^\\star(x_q,y_q)\\right)^2 \\right] } }.\n$$\n\n最终输出格式：\n\n- 您的程序必须生成单行输出，其中包含一个十二个浮点数的列表，四舍五入到六位小数，顺序如下：\n$$\n\\left[ \\mathcal{N}_\\text{div}^{(\\lambda=0)}, \\mathcal{N}_\\text{mom}^{(\\lambda=0)}, \\mathcal{E}_\\mathbf{u}^{(\\lambda=0)}, \\mathcal{N}_\\text{div}^{(\\lambda=1)}, \\mathcal{N}_\\text{mom}^{(\\lambda=1)}, \\mathcal{E}_\\mathbf{u}^{(\\lambda=1)}, \\mathcal{N}_\\text{div}^{(\\lambda=100)}, \\mathcal{N}_\\text{mom}^{(\\lambda=100)}, \\mathcal{E}_\\mathbf{u}^{(\\lambda=100)}, \\mathcal{N}_\\text{div}^\\text{(hard)}, \\mathcal{N}_\\text{mom}^\\text{(hard)}, \\mathcal{E}_\\mathbf{u}^\\text{(hard)} \\right].\n$$\n- 数字必须按此确切顺序和格式生成，包括外围的方括号和逗号分隔符。\n\n角度单位不适用。不需要物理单位；所有量都是无量纲的实数。所有随机抽样必须使用固定的种子，以使输出具有确定性。您的代码必须是自包含的，并且不需要用户交互。", "solution": "所提出的问题是计算科学领域中的一个明确定义的练习，特别是在应用于计算流体动力学的物理信息神经网络（PINN）领域。它要求实现和比较两种求解单位平方上稳态Stokes方程的方法，并使用人造解方法进行验证。\n\n**问题验证**\n\n该问题被验证为具有科学依据、良定且客观。它基于流体力学的基本Stokes方程。使用人造解是一种标准的验证技术。通过有限傅里叶类基进行参数化（可以解释为具有固定三角激活函数的简单神经网络）是演示PINN概念的有效方法。问题简化为求解一个线性最小二乘系统，这是一个良定的数学问题。所有常数、方程和评估指标都以足够的精度指定。关于单个压力锚点位置的微小模糊性，通过选择一个固定的、有代表性的点，如域中心 $(0.5, 0.5)$ 来解决，这是一种标准做法，不会影响问题的完整性。因此，该问题被认为是有效的，可以制定严谨的解决方案。\n\n**基于原理的解决方案设计**\n\n问题的核心是找到Stokes方程的近似解 $(\\mathbf{u}, p)$：\n$$\n-\\nabla p + \\nu \\nabla^2 \\mathbf{u} + \\mathbf{f} = \\mathbf{0} \\\\\n\\nabla \\cdot \\mathbf{u} = 0\n$$\n通过将未知场表示为具有未知系数的预定基函数的线性组合。这些系数通过最小化一个由控制方程的残差和数据失配项组成的损失函数来确定。这个过程等同于求解一个线性最小二乘问题。\n\n**1. 人造解和强迫项**\n\n为了提供评估方法准确性的基准真相，定义了一个人造解：\n$$\n\\psi(x,y) = \\sin(\\pi x)\\sin(\\pi y) \\\\\nu^\\star(x,y) = \\pi \\sin(\\pi x)\\cos(\\pi y) \\\\\nv^\\star(x,y) = -\\pi \\cos(\\pi x)\\sin(\\pi y) \\\\\np^\\star(x,y) = \\cos(\\pi x)\\cos(\\pi y)\n$$\n如果体积力 $\\mathbf{f} = (f_x, f_y)$ 定义为：\n$$\n\\mathbf{f} = \\nabla p^\\star - \\nu \\nabla^2 \\mathbf{u}^\\star\n$$\n则这些场精确满足Stokes方程。解析地计算必要的导数，我们得到强迫函数：\n$$\nf_x(x,y) = \\frac{\\partial p^\\star}{\\partial x} - \\nu \\left( \\frac{\\partial^2 u^\\star}{\\partial x^2} + \\frac{\\partial^2 u^\\star}{\\partial y^2} \\right) = (-\\pi + 2\\nu\\pi^3) \\sin(\\pi x)\\cos(\\pi y) \\\\\nf_y(x,y) = \\frac{\\partial p^\\star}{\\partial y} - \\nu \\left( \\frac{\\partial^2 v^\\star}{\\partial x^2} + \\frac{\\partial^2 v^\\star}{\\partial y^2} \\right) = (-\\pi - 2\\nu\\pi^3) \\cos(\\pi x)\\sin(\\pi y)\n$$\n粘度为 $\\nu = 0.01$。\n\n**2. 点离散化**\n\n连续问题使用三组点进行离散化：\n- **配置点 ($N_\\Omega = 64$)**：在 $(0,1)^2$ 内部的 $8 \\times 8$ 均匀网格，用于施加物理残差。\n- **数据锚点 ($N_D = 10$)**：从 $(0,1)^2$ 上的均匀随机分布中抽样的点（使用固定种子以保证可复现性），在这些点上约束速度解以匹配人造解 $u^\\star$ 和 $v^\\star$。\n- **压力锚点**：一个单点，选择为 $(\\hat{x}, \\hat{y}) = (0.5, 0.5)$，以固定压力水平，否则压力仅能确定到一个附加常数。\n\n**3. 线性最小二乘公式**\n\n方法A和方法B都旨在找到一个系数向量 $\\boldsymbol{\\theta}$ 来最小化加权平方误差和。这可以表示为一个标准的线性最小二乘问题：\n$$\n\\min_{\\boldsymbol{\\theta}} \\| \\mathbf{A}\\boldsymbol{\\theta} - \\mathbf{b} \\|_2^2\n$$\n这里，$\\mathbf{A}$ 是设计矩阵，其条目是基函数或其导数在离散点上的评价值；$\\mathbf{b}$ 是右侧向量，包含来自强迫项或人造解的值。损失函数中的权重，如 $\\alpha$、$\\alpha_p$ 和 $\\lambda$，通过将 $\\mathbf{A}$ 和 $\\mathbf{b}$ 的相应行乘以所述权重的平方根来并入。该系统是超定的，并使用像 `scipy.linalg.lstsq` 这样的鲁棒方法求解。\n\n**方法A：软散度约束**\n\n速度分量 $(u,v)$ 和压力 $p$ 被独立参数化：\n$$\nu(x,y) = \\sum_{k=1}^{4} a_k \\phi_k(x,y), \\quad v(x,y) = \\sum_{k=1}^{4} b_k \\psi_k(x,y), \\quad p(x,y) = \\sum_{k=1}^{4} c_k \\chi_k(x,y)\n$$\n系数向量是 $\\boldsymbol{\\theta}_A = [a_1, ..., a_4, b_1, ..., b_4, c_1, ..., c_4]^T$，大小为12。线性系统由以下方程构建：\n- **动量残差 ($2N_\\Omega$ 个方程)**：在每个配置点 $(x_i, y_i)$，\n$$\n\\nu \\sum_{k=1}^{4} a_k \\nabla^2\\phi_k(x_i,y_i) - \\sum_{k=1}^{4} c_k \\frac{\\partial\\chi_k}{\\partial x}(x_i,y_i) = -f_x(x_i,y_i) \\\\\n\\nu \\sum_k b_k \\nabla^2\\psi_k(x_i,y_i) - \\sum_k c_k \\frac{\\partial\\chi_k}{\\partial y}(x_i,y_i) = -f_y(x_i,y_i)\n$$\n这些行按 $\\sqrt{1/N_\\Omega}$ 加权。\n- **速度数据约束 ($2N_D$ 个方程)**：在每个锚点 $(\\tilde{x}_j, \\tilde{y}_j)$，\n$$\n\\sum_{k=1}^{4} a_k \\phi_k(\\tilde{x}_j,\\tilde{y}_j) = u^\\star(\\tilde{x}_j,\\tilde{y}_j) \\\\\n\\sum_k b_k \\psi_k(\\tilde{x}_j,\\tilde{y}_j) = v^\\star(\\tilde{x}_j,\\tilde{y}_j)\n$$\n这些行按 $\\sqrt{\\alpha/N_D}$ 加权。\n- **压力锚点约束 (1 个方程)**：在 $(\\hat{x}, \\hat{y})$，\n$$\n\\sum_{k=1}^{4} c_k \\chi_k(\\hat{x},\\hat{y}) = p^\\star(\\hat{x},\\hat{y})\n$$\n该行按 $\\sqrt{\\alpha_p}$ 加权。\n- **散度惩罚 ($N_\\Omega$ 个方程)**：在每个配置点 $(x_i, y_i)$，\n$$\n\\sum_{k=1}^{4} a_k \\frac{\\partial\\phi_k}{\\partial x}(x_i,y_i) + \\sum_{k=1}^{4} b_k \\frac{\\partial\\psi_k}{\\partial y}(x_i,y_i) = 0\n$$\n这些行按 $\\sqrt{\\lambda/N_\\Omega}$ 加权。对 $\\lambda \\in \\{0.0, 1.0, 100.0\\}$ 重复此过程。\n\n**方法B：硬散度约束**\n\n不可压缩性约束 $\\nabla \\cdot \\mathbf{u} = 0$ 通过使用流函数公式被精确满足（通过构造）：\n$$\n\\psi(x,y) = \\sum_{k=1}^{4} s_k \\sigma_k(x,y) \\implies u = \\frac{\\partial \\psi}{\\partial y}, v = -\\frac{\\partial \\psi}{\\partial x}\n$$\n压力像以前一样参数化。系数向量是 $\\boldsymbol{\\theta}_B = [s_1, ..., s_4, c_1, ..., c_4]^T$，大小为8。线性系统由以下方程构建：\n- **动量残差 ($2N_\\Omega$ 个方程)**：在每个配置点 $(x_i, y_i)$，\n$$\n\\nu \\sum_{k=1}^{4} s_k \\frac{\\partial(\\nabla^2\\sigma_k)}{\\partial y}(x_i,y_i) - \\sum_{k=1}^{4} c_k \\frac{\\partial\\chi_k}{\\partial x}(x_i,y_i) = -f_x(x_i,y_i) \\\\\n\\nu \\sum_k s_k \\left(-\\frac{\\partial(\\nabla^2\\sigma_k)}{\\partial x}\\right)(x_i,y_i) - \\sum_k c_k \\frac{\\partial\\chi_k}{\\partial y}(x_i,y_i) = -f_y(x_i,y_i)\n$$\n这些行按 $\\sqrt{1/N_\\Omega}$ 加权。\n- **速度数据约束 ($2N_D$ 个方程)**：在每个锚点 $(\\tilde{x}_j, \\tilde{y}_j)$，\n$$\n\\sum_{k=1}^{4} s_k \\frac{\\partial\\sigma_k}{\\partial y}(\\tilde{x}_j,\\tilde{y}_j) = u^\\star(\\tilde{x}_j,\\tilde{y}_j) \\\\\n\\sum_k s_k \\left(-\\frac{\\partial\\sigma_k}{\\partial x}\\right)(\\tilde{x}_j,\\tilde{y}_j) = v^\\star(\\tilde{x}_j,\\tilde{y}_j)\n$$\n这些行按 $\\sqrt{\\alpha/N_D}$ 加权。\n- **压力锚点约束 (1 个方程)**：与方法A中相同，按 $\\sqrt{\\alpha_p}$ 加权。\n没有散度惩罚方程，因为约束是结构上满足的。\n\n**4. 评估**\n\n在每种情况下求解系数 $\\boldsymbol{\\theta}$ 后，得到的近似解 $(u,v,p)$ 在一个精细的 $20 \\times 20$ 验证网格上进行评估。计算三个指标：速度散度的均方根范数 $\\mathcal{N}_\\text{div}$、动量残差的均方根范数 $\\mathcal{N}_\\text{mom}$，以及速度场的相对 $L_2$ 误差 $\\mathcal{E}_\\mathbf{u}$。对于方法B，$\\mathcal{N}_\\text{div}$ 预期在机器精度范围内为零，这为实现提供了验证。然后将所有四种情况的结果（方法A的三种 $\\lambda$ 值，以及方法B）汇总并按规定格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import lstsq\n\ndef solve():\n    # --- Problem Parameters ---\n    NU = 0.01\n    ALPHA = 10.0\n    ALPHA_P = 10.0\n    N_OMEGA_SIDE = 8\n    N_OMEGA = N_OMEGA_SIDE * N_OMEGA_SIDE\n    N_D = 10\n    N_VALID_SIDE = 20\n    N_V = N_VALID_SIDE * N_VALID_SIDE\n    SEED = 42\n    MODES = [(1, 1), (2, 1), (1, 2), (2, 2)]\n    LAMBDA_VALS = [0.0, 1.0, 100.0]\n\n    # --- Grids ---\n    # Collocation points\n    x_omega_1d = np.linspace(0, 1, N_OMEGA_SIDE + 2)[1:-1]\n    y_omega_1d = np.linspace(0, 1, N_OMEGA_SIDE + 2)[1:-1]\n    x_omega_grid, y_omega_grid = np.meshgrid(x_omega_1d, y_omega_1d)\n    collocation_pts = np.vstack([x_omega_grid.ravel(), y_omega_grid.ravel()]).T\n\n    # Data anchor points\n    rng = np.random.default_rng(SEED)\n    data_pts = rng.uniform(0, 1, size=(N_D, 2))\n\n    # Pressure anchor point\n    pressure_pt = np.array([[0.5, 0.5]])\n\n    # Validation points\n    x_val_1d = np.linspace(0, 1, N_VALID_SIDE)\n    y_val_1d = np.linspace(0, 1, N_VALID_SIDE)\n    x_val_grid, y_val_grid = np.meshgrid(x_val_1d, y_val_1d)\n    validation_pts = np.vstack([x_val_grid.ravel(), y_val_grid.ravel()]).T\n\n    # --- Manufactured Solution and Forcing Term ---\n    def u_star(x, y):\n        return np.pi * np.sin(np.pi * x) * np.cos(np.pi * y)\n\n    def v_star(x, y):\n        return -np.pi * np.cos(np.pi * x) * np.sin(np.pi * y)\n\n    def p_star(x, y):\n        return np.cos(np.pi * x) * np.cos(np.pi * y)\n\n    def f_x(x, y):\n        return (-np.pi + 2 * NU * np.pi**3) * np.sin(np.pi * x) * np.cos(np.pi * y)\n\n    def f_y(x, y):\n        return (-np.pi - 2 * NU * np.pi**3) * np.cos(np.pi * x) * np.sin(np.pi * y)\n\n    # --- Basis Functions and Derivatives ---\n    pi = np.pi\n\n    # Method A basis\n    def phi(x, y, m, n): return np.sin(m*pi*x) * np.cos(n*pi*y)\n    def dphi_dx(x, y, m, n): return m*pi * np.cos(m*pi*x) * np.cos(n*pi*y)\n    def lapl_phi(x, y, m, n): return -(m*pi)**2 * phi(x,y,m,n) - (n*pi)**2 * phi(x,y,m,n)\n\n    def psi(x, y, m, n): return -np.cos(m*pi*x) * np.sin(n*pi*y)\n    def dpsi_dy(x, y, m, n): return -n*pi * np.cos(m*pi*x) * np.cos(n*pi*y)\n    def lapl_psi(x, y, m, n): return -(m*pi)**2 * psi(x,y,m,n) - (n*pi)**2 * psi(x,y,m,n)\n\n    # Method B basis (streamfunction)\n    def sigma(x, y, m, n): return np.sin(m*pi*x) * np.sin(n*pi*y)\n    def dsigma_dx(x, y, m, n): return m*pi * np.cos(m*pi*x) * np.sin(n*pi*y)\n    def dsigma_dy(x, y, m, n): return n*pi * np.sin(m*pi*x) * np.cos(n*pi*y)\n    def lapl_dsigma_dx(x, y, m, n): return -(n*pi)**2 * dsigma_dx(x,y,m,n) - (m*pi)**2 * dsigma_dx(x,y,m,n)\n    def lapl_dsigma_dy(x, y, m, n): return -(m*pi)**2 * dsigma_dy(x,y,m,n) - (n*pi)**2 * dsigma_dy(x,y,m,n)\n\n    # Common pressure basis\n    def chi(x, y, m, n): return np.cos(m*pi*x) * np.cos(n*pi*y)\n    def dchi_dx(x, y, m, n): return -m*pi * np.sin(m*pi*x) * np.cos(n*pi*y)\n    def dchi_dy(x, y, m, n): return -n*pi * np.cos(m*pi*x) * np.sin(n*pi*y)\n\n    # --- Solver for Method A ---\n    def solve_method_A(lambda_val):\n        num_coeffs = 12\n        num_rows = 2 * N_OMEGA + 2 * N_D + 1 + N_OMEGA\n        A = np.zeros((num_rows, num_coeffs))\n        b = np.zeros(num_rows)\n        \n        x_c, y_c = collocation_pts[:, 0], collocation_pts[:, 1]\n        x_d, y_d = data_pts[:, 0], data_pts[:, 1]\n        x_p, y_p = pressure_pt[0, 0], pressure_pt[0, 1]\n\n        w_mom = np.sqrt(1 / N_OMEGA)\n        w_data = np.sqrt(ALPHA / N_D)\n        w_p = np.sqrt(ALPHA_P)\n        w_div = np.sqrt(lambda_val / N_OMEGA)\n\n        row = 0\n        # Momentum residual (u)\n        for i in range(N_OMEGA):\n            for k, (m, n) in enumerate(MODES):\n                A[row, k] = w_mom * NU * lapl_phi(x_c[i], y_c[i], m, n)\n                A[row, k + 8] = w_mom * -dchi_dx(x_c[i], y_c[i], m, n)\n            b[row] = w_mom * -f_x(x_c[i], y_c[i])\n            row += 1\n        # Momentum residual (v)\n        for i in range(N_OMEGA):\n            for k, (m, n) in enumerate(MODES):\n                A[row, k + 4] = w_mom * NU * lapl_psi(x_c[i], y_c[i], m, n)\n                A[row, k + 8] = w_mom * -dchi_dy(x_c[i], y_c[i], m, n)\n            b[row] = w_mom * -f_y(x_c[i], y_c[i])\n            row += 1\n        # Velocity data\n        for i in range(N_D):\n            for k, (m, n) in enumerate(MODES):\n                A[row, k] = w_data * phi(x_d[i], y_d[i], m, n)\n            b[row] = w_data * u_star(x_d[i], y_d[i])\n            row += 1\n            for k, (m, n) in enumerate(MODES):\n                A[row, k + 4] = w_data * psi(x_d[i], y_d[i], m, n)\n            b[row] = w_data * v_star(x_d[i], y_d[i])\n            row += 1\n        # Pressure anchor\n        for k, (m, n) in enumerate(MODES):\n            A[row, k + 8] = w_p * chi(x_p, y_p, m, n)\n        b[row] = w_p * p_star(x_p, y_p)\n        row += 1\n        # Divergence penalty\n        for i in range(N_OMEGA):\n            for k, (m, n) in enumerate(MODES):\n                A[row, k] = w_div * dphi_dx(x_c[i], y_c[i], m, n)\n                A[row, k + 4] = w_div * dpsi_dy(x_c[i], y_c[i], m, n)\n            b[row] = 0\n            row += 1\n        \n        coeffs, _, _, _ = lstsq(A, b, rcond=None)\n        return coeffs\n\n    # --- Solver for Method B ---\n    def solve_method_B():\n        num_coeffs = 8\n        num_rows = 2 * N_OMEGA + 2 * N_D + 1\n        A = np.zeros((num_rows, num_coeffs))\n        b = np.zeros(num_rows)\n        \n        x_c, y_c = collocation_pts[:, 0], collocation_pts[:, 1]\n        x_d, y_d = data_pts[:, 0], data_pts[:, 1]\n        x_p, y_p = pressure_pt[0, 0], pressure_pt[0, 1]\n\n        w_mom = np.sqrt(1 / N_OMEGA)\n        w_data = np.sqrt(ALPHA / N_D)\n        w_p = np.sqrt(ALPHA_P)\n\n        row = 0\n        # Momentum residual (u)\n        for i in range(N_OMEGA):\n            for k, (m, n) in enumerate(MODES):\n                A[row, k] = w_mom * NU * lapl_dsigma_dy(x_c[i], y_c[i], m, n)\n                A[row, k + 4] = w_mom * -dchi_dx(x_c[i], y_c[i], m, n)\n            b[row] = w_mom * -f_x(x_c[i], y_c[i])\n            row += 1\n        # Momentum residual (v)\n        for i in range(N_OMEGA):\n            for k, (m, n) in enumerate(MODES):\n                A[row, k] = w_mom * NU * -lapl_dsigma_dx(x_c[i], y_c[i], m, n)\n                A[row, k + 4] = w_mom * -dchi_dy(x_c[i], y_c[i], m, n)\n            b[row] = w_mom * -f_y(x_c[i], y_c[i])\n            row += 1\n        # Velocity data\n        for i in range(N_D):\n            for k, (m, n) in enumerate(MODES):\n                A[row, k] = w_data * dsigma_dy(x_d[i], y_d[i], m, n)\n            b[row] = w_data * u_star(x_d[i], y_d[i])\n            row += 1\n            for k, (m, n) in enumerate(MODES):\n                A[row, k] = w_data * -dsigma_dx(x_d[i], y_d[i], m, n)\n            b[row] = w_data * v_star(x_d[i], y_d[i])\n            row += 1\n        # Pressure anchor\n        for k, (m, n) in enumerate(MODES):\n            A[row, k + 4] = w_p * chi(x_p, y_p, m, n)\n        b[row] = w_p * p_star(x_p, y_p)\n        row += 1\n        \n        coeffs, _, _, _ = lstsq(A, b, rcond=None)\n        return coeffs\n\n    # --- Evaluation ---\n    def evaluate(coeffs, method):\n        x_v, y_v = validation_pts[:, 0], validation_pts[:, 1]\n        \n        u_pred, v_pred, p_pred = np.zeros(N_V), np.zeros(N_V), np.zeros(N_V)\n        du_dx, dv_dy = np.zeros(N_V), np.zeros(N_V)\n        lapl_u, lapl_v = np.zeros(N_V), np.zeros(N_V)\n        dp_dx, dp_dy = np.zeros(N_V), np.zeros(N_V)\n\n        if method == 'A':\n            a_coeffs, b_coeffs, c_coeffs = coeffs[0:4], coeffs[4:8], coeffs[8:12]\n            for k, (m, n) in enumerate(MODES):\n                u_pred += a_coeffs[k] * phi(x_v, y_v, m, n)\n                v_pred += b_coeffs[k] * psi(x_v, y_v, m, n)\n                p_pred += c_coeffs[k] * chi(x_v, y_v, m, n)\n                du_dx += a_coeffs[k] * dphi_dx(x_v, y_v, m, n)\n                dv_dy += b_coeffs[k] * dpsi_dy(x_v, y_v, m, n)\n                lapl_u += a_coeffs[k] * lapl_phi(x_v, y_v, m, n)\n                lapl_v += b_coeffs[k] * lapl_psi(x_v, y_v, m, n)\n                dp_dx += c_coeffs[k] * dchi_dx(x_v, y_v, m, n)\n                dp_dy += c_coeffs[k] * dchi_dy(x_v, y_v, m, n)\n        elif method == 'B':\n            s_coeffs, c_coeffs = coeffs[0:4], coeffs[4:8]\n            for k, (m, n) in enumerate(MODES):\n                u_pred += s_coeffs[k] * dsigma_dy(x_v, y_v, m, n)\n                v_pred += s_coeffs[k] * -dsigma_dx(x_v, y_v, m, n)\n                p_pred += c_coeffs[k] * chi(x_v, y_v, m, n)\n                du_dx += s_coeffs[k] * n*pi * m*pi * np.cos(m*pi*x_v)*np.cos(n*pi*y_v) # d/dx(dsigma/dy)\n                dv_dy += s_coeffs[k] * -m*pi * n*pi * np.cos(m*pi*x_v)*np.cos(n*pi*y_v) # d/dy(-dsigma/dx)\n                lapl_u += s_coeffs[k] * lapl_dsigma_dy(x_v, y_v, m, n)\n                lapl_v += s_coeffs[k] * -lapl_dsigma_dx(x_v, y_v, m, n)\n                dp_dx += c_coeffs[k] * dchi_dx(x_v, y_v, m, n)\n                dp_dy += c_coeffs[k] * dchi_dy(x_v, y_v, m, n)\n        \n        # N_div\n        div_u = du_dx + dv_dy\n        n_div = np.sqrt(np.mean(div_u**2))\n        \n        # N_mom\n        r_u = -dp_dx + NU * lapl_u + f_x(x_v, y_v)\n        r_v = -dp_dy + NU * lapl_v + f_y(x_v, y_v)\n        n_mom = np.sqrt(np.mean(r_u**2 + r_v**2))\n        \n        # E_u\n        u_s, v_s = u_star(x_v, y_v), v_star(x_v, y_v)\n        error_num = np.sqrt(np.mean((u_pred - u_s)**2 + (v_pred - v_s)**2))\n        error_den = np.sqrt(np.mean(u_s**2 + v_s**2))\n        e_u = error_num / error_den if error_den > 0 else 0.0\n\n        return n_div, n_mom, e_u\n\n    # --- Main Execution Logic ---\n    results = []\n    \n    # Method A cases\n    for lambda_val in LAMBDA_VALS:\n        coeffs_A = solve_method_A(lambda_val)\n        metrics_A = evaluate(coeffs_A, 'A')\n        results.extend(metrics_A)\n        \n    # Method B case\n    coeffs_B = solve_method_B()\n    metrics_B = evaluate(coeffs_B, 'B')\n    results.extend(metrics_B)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{val:.6f}' for val in results)}]\")\n\nsolve()\n```", "id": "2411040"}]}