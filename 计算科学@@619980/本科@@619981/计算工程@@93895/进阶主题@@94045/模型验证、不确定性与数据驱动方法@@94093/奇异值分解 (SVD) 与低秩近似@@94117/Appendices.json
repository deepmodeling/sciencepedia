{"hands_on_practices": [{"introduction": "第一个练习将我们对低秩近似的理论理解，落实在一个具体的计算上。你将应用 Eckart-Young-Mirsky 定理，为一个给定矩阵的秩-2 近似确定其精确的误差大小。这个实践旨在强化奇异值 $\\sigma_i$ 与 SVD 低秩近似最优性之间的直接联系。[@problem_id:1071275]", "problem": "设 $A$ 是一个实 $m \\times n$ 矩阵。$A$ 的奇异值分解（SVD）是一种形如 $A = U\\Sigma V^T$ 的因式分解，其中 $U$ 是一个 $m \\times m$ 的正交矩阵，$V$ 是一个 $n \\times n$ 的正交矩阵，$\\Sigma$ 是一个 $m \\times n$ 的矩形对角矩阵，其对角线上的元素为非负实数。$\\Sigma$ 的对角元素 $\\sigma_i$ 称为 $A$ 的奇异值，通常按 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_r > 0$ 的顺序排列，其中 $r = \\text{rank}(A)$。\n\n截断奇异值分解（truncated SVD）提供了 $A$ 的一个低秩近似。$A$ 的最佳秩 $k$ 近似，记作 $A_k$，由 $A_k = \\sum_{i=1}^k \\sigma_i u_i v_i^T$ 给出，其中 $u_i$ 和 $v_i$ 分别是 $U$ 和 $V$ 的第 $i$ 列。\n\nEckart-Young-Mirsky 定理指出，对于谱范数（矩阵 2-范数）$\\| \\cdot \\|_2$，$A_k$ 是 $A$ 的最优秩 $k$ 近似。该近似的误差由第一个被截断的奇异值给出：\n$$\n\\|A - A_k\\|_2 = \\sigma_{k+1}\n$$\n\n考虑 3x3 的对称帕斯卡矩阵（Pascal matrix）$P_3$，它由二项式系数 $P_{ij} = \\binom{i+j-2}{i-1}$ 定义，其中 $i,j \\in \\{1, 2, 3\\}$。\n\n当用矩阵 $P_3$ 的最佳秩 $k$ 近似 $(P_3)_k$（其中 $k=2$）来近似它时，确定误差的谱范数 $\\|P_3 - (P_3)_k\\|_2$。", "solution": "1. 根据 Eckart–Young–Mirsky 定理，我们有\n$$\\|P_3 - (P_3)_k\\|_2 = \\sigma_{k+1},$$ \n其中 $\\sigma_i$ 是 $P_3$ 的奇异值，排序为 $\\sigma_1\\ge\\sigma_2\\ge\\sigma_3>0$。\n2. 对于对称矩阵 \n$$P_3=\\begin{pmatrix}1&1&1\\\\1&2&3\\\\1&3&6\\end{pmatrix}$$ \n其奇异值等于其特征值。特征多项式为\n$$\\det(P_3-\\lambda I)=\\lambda^3-9\\lambda^2+9\\lambda-1=0.$$\n3. 提出因子 $(\\lambda-1)$ 后得到\n$$\\lambda^3-9\\lambda^2+9\\lambda-1=(\\lambda-1)(\\lambda^2-8\\lambda+1),$$\n所以特征值为\n$$\\lambda=1,\\quad \\lambda=4\\pm\\sqrt{15}.$$\n4. 将奇异值排序为 $\\sigma_1=4+\\sqrt{15}\\ge\\sigma_2=1\\ge\\sigma_3=4-\\sqrt{15}$，对于 $k=2$，误差范数为\n$$\\|P_3-(P_3)_2\\|_2=\\sigma_3=4-\\sqrt{15}.$$", "answer": "$$\\boxed{4-\\sqrt{15}}$$", "id": "1071275"}, {"introduction": "真实世界的数据很少是完美的，常常包含异常值。这个思想实验通过改变一个异常值的大小 $M$，来分析其如何显著影响数据的主成分，进而探讨奇异值分解 (SVD) 和主成分分析 (PCA) 的鲁棒性。掌握这一概念对于正确解读数据和建立稳健的计算模型至关重要。[@problem_id:2435636]", "problem": "考虑一个在$\\mathbb{R}^d$中按如下方式构建的数据集。有$N$个基线样本 $x_i \\in \\mathbb{R}^d$，其形式为 $x_i = s_i a$，其中 $i \\in \\{1,\\dots,N\\}$。这里 $a \\in \\mathbb{R}^d$ 满足 $\\|a\\|_2 = 1$，标量 $s_i \\in \\mathbb{R}$ 满足 $\\sum_{i=1}^N s_i = 0$，且 $\\sum_{i=1}^N s_i^2$ 为有限值。一个额外的离群样本 $x_{N+1} \\in \\mathbb{R}^d$ 被添加进来，其形式为 $x_{N+1} = M c$，其中 $c \\in \\mathbb{R}^d$ 满足 $\\|c\\|_2 = 1$ 和 $a^\\top c = 0$，且 $M > 0$ 是一个标量参数。令 $X \\in \\mathbb{R}^{(N+1)\\times d}$ 为数据矩阵，其第 $i$ 行为 $x_i^\\top$。令 $\\bar{x} \\in \\mathbb{R}^d$ 表示样本均值 $\\bar{x} = \\frac{1}{N+1}\\sum_{i=1}^{N+1} x_i$，并定义列中心化数据矩阵 $X' = X - \\mathbf{1}\\bar{x}^\\top$，其中 $\\mathbf{1} \\in \\mathbb{R}^{N+1}$ 是全1向量。设奇异值分解 (Singular Value Decomposition, SVD) 为 $X' = U \\Sigma V^\\top$，其中 $U \\in \\mathbb{R}^{(N+1)\\times (N+1)}$，$ \\Sigma \\in \\mathbb{R}^{(N+1)\\times d}$，$V \\in \\mathbb{R}^{d\\times d}$，且 $\\Sigma$ 的对角线上为非负的奇异值，按非增顺序排列。在主成分分析 (Principal Component Analysis, PCA) 中，第一主成分是 $V$ 的第一列（即主导右奇异向量），最大奇异值等于 $(X')^\\top X'$ 的主导特征值的平方根。\n\n关于离群点如何影响 $X'$ 的主成分和低秩结构，以下哪些陈述是正确的？\n\nA. 对于足够大的 $M$，第一主成分与 $c$ 的方向一致。\n\nB. 在通过减去 $\\bar{x}$ 进行中心化后，离群点的贡献被抵消，因此对于所有的 $M$，第一主成分必然保持与 $a$ 的方向一致。\n\nC. 存在一个由 $M^2 \\frac{N}{N+1} = \\sum_{i=1}^N s_i^2$ 决定的切换阈值，在该阈值处，第一主成分的方向在 $a$ 和 $c$ 之间发生改变。\n\nD. 对于大的 $M$，在忽略 $M$ 的低阶项的情况下，$X'$ 的最大奇异值与 $\\sqrt{\\frac{N}{N+1}}\\,M$ 成比例。\n\nE. 如果 $a^\\top c = 0$，那么 $X'$ 的前两个右奇异向量不必须是正交的。\n\nF. 当 $M \\to \\infty$ 时，在弗罗贝尼乌斯范数意义下，最佳秩-1 近似的平方误差收敛于 $\\sum_{i=1}^N s_i^2$。", "solution": "我们首先分析中心化数据矩阵 $X'$ 的结构。数据的主成分是协方差类矩阵 $S = (X')^\\top X'$ 的特征向量。分析过程如下。\n\n首先，我们计算样本均值 $\\bar{x}$：\n$$ \\bar{x} = \\frac{1}{N+1} \\sum_{i=1}^{N+1} x_i = \\frac{1}{N+1} \\left( \\sum_{i=1}^N x_i + x_{N+1} \\right) $$\n给定 $x_i = s_i a$ 对于 $i \\in \\{1,\\dots,N\\}$，$x_{N+1} = M c$，以及条件 $\\sum_{i=1}^N s_i = 0$，上式可简化为：\n$$ \\bar{x} = \\frac{1}{N+1} \\left( \\left(\\sum_{i=1}^N s_i\\right) a + M c \\right) = \\frac{1}{N+1} (0 \\cdot a + M c) = \\frac{M}{N+1} c $$\n\n接下来，我们定义中心化数据点 $x_i' = x_i - \\bar{x}$。\n对于 $i \\in \\{1, \\dots, N\\}$：\n$$ x_i' = s_i a - \\frac{M}{N+1} c $$\n对于 $i = N+1$：\n$$ x_{N+1}' = M c - \\frac{M}{N+1} c = \\left( M - \\frac{M}{N+1} \\right) c = \\frac{M(N+1) - M}{N+1} c = \\frac{MN}{N+1} c $$\n中心化数据矩阵 $X'$ 的行是 $(x_i')^\\top$。\n\n主成分是 $S = (X')^\\top X'$ 的特征向量。我们计算这个矩阵：\n$$ S = \\sum_{i=1}^{N+1} x_i' (x_i')^\\top = \\sum_{i=1}^{N} x_i' (x_i')^\\top + x_{N+1}' (x_{N+1}')^\\top $$\n前 $N$ 个点的和是：\n$$ \\sum_{i=1}^{N} \\left( s_i a - \\frac{M}{N+1} c \\right) \\left( s_i a - \\frac{M}{N+1} c \\right)^\\top $$\n$$ = \\sum_{i=1}^{N} \\left( s_i^2 a a^\\top - \\frac{s_i M}{N+1} a c^\\top - \\frac{s_i M}{N+1} c a^\\top + \\left(\\frac{M}{N+1}\\right)^2 c c^\\top \\right) $$\n使用 $\\sum_{i=1}^N s_i = 0$ 并分配求和：\n$$ = \\left(\\sum_{i=1}^{N} s_i^2\\right) a a^\\top - \\frac{M}{N+1}\\left(\\sum_{i=1}^{N} s_i\\right) (a c^\\top + c a^\\top) + N \\left(\\frac{M}{N+1}\\right)^2 c c^\\top $$\n$$ = \\left(\\sum_{i=1}^{N} s_i^2\\right) a a^\\top + N \\frac{M^2}{(N+1)^2} c c^\\top $$\n现在，加上关于 $x_{N+1}'$ 的项：\n$$ S = \\left(\\sum_{i=1}^{N} s_i^2\\right) a a^\\top + N \\frac{M^2}{(N+1)^2} c c^\\top + \\left(\\frac{MN}{N+1}\\right)^2 c c^\\top $$\n$$ S = \\left(\\sum_{i=1}^{N} s_i^2\\right) a a^\\top + \\left( N \\frac{M^2}{(N+1)^2} + \\frac{M^2 N^2}{(N+1)^2} \\right) c c^\\top $$\n$$ S = \\left(\\sum_{i=1}^{N} s_i^2\\right) a a^\\top + \\frac{M^2 N(1+N)}{(N+1)^2} c c^\\top $$\n$$ S = \\left(\\sum_{i=1}^{N} s_i^2\\right) a a^\\top + \\frac{M^2 N}{N+1} c c^\\top $$\n令 $\\lambda_a = \\sum_{i=1}^N s_i^2$ 和 $\\lambda_c(M) = M^2 \\frac{N}{N+1}$。该矩阵为 $S = \\lambda_a a a^\\top + \\lambda_c(M) c c^\\top$。\n由于 $a$ 和 $c$ 是标准正交的 ($a^\\top c = 0$, $\\|a\\|_2 = 1$, $\\|c\\|_2=1$)，它们是 $S$ 的特征向量：\n$S a = (\\lambda_a a a^\\top + \\lambda_c(M) c c^\\top) a = \\lambda_a a (a^\\top a) = \\lambda_a a$。\n$S c = (\\lambda_a a a^\\top + \\lambda_c(M) c c^\\top) c = \\lambda_c(M) c (c^\\top c) = \\lambda_c(M) c$。\n特征值是 $\\lambda_a$ 和 $\\lambda_c(M)$。在 $\\{a, c\\}$ 生成空间的正交补中的任何向量 $v$ 都是特征值为 $0$ 的特征向量。主成分是 $S$ 对应于非零特征值的特征向量，按特征值的大小排序。第一主成分对应于最大的特征值。\n\n现在我们评估每个陈述。\n\nA. 对于足够大的 $M$，第一主成分与 $c$ 的方向一致。\n与向量 $a$ 相关联的特征值是 $\\lambda_a = \\sum_{i=1}^N s_i^2$，这是一个有限的常数。与向量 $c$ 相关联的特征值是 $\\lambda_c(M) = M^2 \\frac{N}{N+1}$。当 $M \\to \\infty$ 时，$\\lambda_c(M)$ 无界增长，而 $\\lambda_a$ 保持不变。因此，对于足够大的 $M$，有 $\\lambda_c(M) > \\lambda_a$。最大的特征值将是 $\\lambda_c(M)$，其对应的特征向量（即第一主成分）将是 $c$。此说法**正确**。\n\nB. 在通过减去 $\\bar{x}$ 进行中心化后，离群点的贡献被抵消，因此对于所有的 $M$，第一主成分必然保持与 $a$ 的方向一致。\n这个断言是错误的。离群点的贡献没有被抵消。中心化后的离群点是 $x_{N+1}' = \\frac{MN}{N+1} c$，这是非零的。如选项 A 的分析所示，对于大的 $M$，第一主成分与 $c$ 而非 $a$ 的方向一致。此说法**不正确**。\n\nC. 存在一个由 $M^2 \\frac{N}{N+1} = \\sum_{i=1}^N s_i^2$ 决定的切换阈值，在该阈值处，第一主成分的方向在 $a$ 和 $c$ 之间发生改变。\n第一主成分由两个特征值 $\\lambda_a$ 和 $\\lambda_c(M)$ 中较大的一个决定。当这两个特征值相等时，即 $\\lambda_a = \\lambda_c(M)$，第一主成分的身份会发生转换。代入特征值的表达式，我们得到 $\\sum_{i=1}^N s_i^2 = M^2 \\frac{N}{N+1}$。这个方程定义了发生转换时 $M$ 的阈值。此说法**正确**。\n\nD. 对于大的 $M$，在忽略 $M$ 的低阶项的情况下，$X'$ 的最大奇异值与 $\\sqrt{\\frac{N}{N+1}}\\,M$ 成比例。\n$X'$ 的奇异值 $\\sigma_j$ 是 $S = (X')^\\top X'$ 的特征值的平方根。对于大的 $M$，最大特征值是 $\\lambda_{max} = \\lambda_c(M) = M^2 \\frac{N}{N+1}$。相应的最大奇异值是 $\\sigma_1 = \\sqrt{\\lambda_c(M)} = \\sqrt{M^2 \\frac{N}{N+1}} = M \\sqrt{\\frac{N}{N+1}}$。这个表达式与陈述所声称的完全一致，没有低阶项。此说法**正确**。\n\nE. 如果 $a^\\top c = 0$，那么 $X'$ 的前两个右奇异向量不必须是正交的。\n$X'$ 的右奇异向量是 SVD $X' = U \\Sigma V^\\top$ 中矩阵 $V$ 的列。根据奇异值分解的定义，矩阵 $V$ 是一个正交矩阵。因此，它的列构成一个标准正交向量集。所以，任意两个不同的右奇异向量都必须是正交的。该陈述与 SVD 的性质直接矛盾。此说法**不正确**。\n\nF. 当 $M \\to \\infty$ 时，在弗罗贝尼乌斯范数意义下，最佳秩-1 近似的平方误差收敛于 $\\sum_{i=1}^N s_i^2$。\n根据 Eckart-Young-Mirsky 定理，$X'$ 的最佳秩-k 近似的弗罗贝尼乌斯范数平方误差是从 $k+1$ 到矩阵的秩的所有奇异值的平方和。对于秩-1 近似（$k=1$），这个误差是 $\\sum_{j=2}^{\\text{rank}} \\sigma_j^2$。奇异值的平方是 $S$ 的特征值。当 $M \\to \\infty$ 时，最大的特征值是 $\\lambda_1 = \\lambda_c(M) = M^2 \\frac{N}{N+1}$，第二大的特征值是 $\\lambda_2 = \\lambda_a = \\sum_{i=1}^N s_i^2$。所有其他特征值均为 0。因此，平方误差是 $\\lambda_2 + \\lambda_3 + \\dots = \\lambda_a + 0 + \\dots = \\sum_{i=1}^N s_i^2$。这是一个常数值。因此，误差收敛于这个值。此说法**正确**。", "answer": "$$\\boxed{ACDF}$$", "id": "2435636"}, {"introduction": "最后一个练习将我们的视角从分析现有矩阵，转变为构造具有特定性质的新矩阵。你将通过从零开始组装其 SVD 的各个部分（$U, \\Sigma, V^T$），来构建一个具有预设条件数 $\\kappa_\\star$ 的矩阵 $A$ 。这种建构性的方法能加深你对奇异值如何影响矩阵稳定性的理解，并提供有关计算工程中数值实现问题的实践经验。[@problem_id:2435624]", "problem": "使用指定的奇异值分解（singular value decomposition (SVD)）构造一个具有预设 2-范数条件数的实矩阵。\n\n对于每个测试用例，给定正整数 $m$ 和 $n$（满足 $m \\ge n \\ge 2$）、目标条件数 $\\kappa_\\star > 0$，以及定义正交矩阵 $U \\in \\mathbb{R}^{m \\times m}$ 和 $V \\in \\mathbb{R}^{n \\times n}$ 的两个平面旋转列表。每个平面旋转都是一个吉文斯旋转 (Givens rotation) $G(i,j,\\theta) \\in \\mathbb{R}^{p \\times p}$，其中 $p \\in \\{m,n\\}$，$1 \\le i < j \\le p$，角度 $\\theta$ 以弧度为单位。矩阵 $G(i,j,\\theta)$ 等于单位矩阵，但在其第 $i$ 行和第 $j$ 行及第 $i$ 列和第 $j$ 列的 $2 \\times 2$ 子矩阵处为\n$$\n\\begin{bmatrix}\n\\cos(\\theta) & \\sin(\\theta) \\\\\n-\\sin(\\theta) & \\cos(\\theta)\n\\end{bmatrix}.\n$$\n给定这样一个维度为 $p$ 的旋转列表 $(i_1,j_1,\\theta_1),\\dots,(i_r,j_r,\\theta_r)$，将正交矩阵 $Q \\in \\mathbb{R}^{p \\times p}$ 构造成以下乘积形式\n$$\nQ = G(i_1,j_1,\\theta_1)\\,G(i_2,j_2,\\theta_2)\\,\\cdots\\,G(i_r,j_r,\\theta_r),\n$$\n按照列表从左到右的顺序。空列表对应于单位矩阵。\n\n通过选择严格为正的奇异值 $\\sigma_1,\\dots,\\sigma_n$（按非递增顺序排列），定义奇异值对角矩阵 $\\Sigma \\in \\mathbb{R}^{m \\times n}$，使得 2-范数条件数 $\\kappa(\\Sigma) = \\sigma_1/\\sigma_n$ 等于目标值 $\\kappa_\\star$。设奇异值为等比数列\n$$\n\\sigma_j = \\kappa_\\star^{-\\frac{j-1}{n-1}}, \\quad j=1,\\dots,n,\n$$\n使得 $\\sigma_1 = 1$ 且 $\\sigma_n = \\kappa_\\star^{-1}$。构造\n$$\nA = U\\,\\Sigma\\,V^\\top \\in \\mathbb{R}^{m \\times n}.\n$$\n\n对于每个测试用例，计算所达到的 2-范数条件数 $\\kappa_2(A)$（定义为 $A$ 的最大奇异值与最小奇异值之比），并报告绝对相对误差\n$$\n\\varepsilon = \\left|\\frac{\\kappa_2(A)}{\\kappa_\\star} - 1\\right|.\n$$\n角度以弧度为单位。不涉及物理单位。对于所有测试用例，您的程序必须生成单行输出，其中包含用方括号括起来的、以逗号分隔的误差列表。每个误差值必须四舍五入到 $10$ 位小数。例如，输出格式必须如下\n$$\n[\\varepsilon_1,\\varepsilon_2,\\dots].\n$$\n\n使用以下测试套件：\n\n- 测试用例 $1$：$m=5$, $n=5$, $\\kappa_\\star = 10^8$，\n  - $U$ 来自维度 $5$ 的旋转：$(i,j,\\theta) = (1,2,0.7)$, $(3,5,1.1)$，\n  - $V$ 来自维度 $5$ 的旋转：$(i,j,\\theta) = (2,4,0.6)$, $(1,3,1.0)$。\n\n- 测试用例 $2$：$m=6$, $n=4$, $\\kappa_\\star = 10^9$，\n  - $U$ 来自维度 $6$ 的旋转：$(i,j,\\theta) = (1,6,0.5)$, $(2,3,1.2)$, $(4,5,0.9)$，\n  - $V$ 来自维度 $4$ 的旋转：$(i,j,\\theta) = (1,4,0.4)$, $(2,3,1.3)$。\n\n- 测试用例 $3$：$m=4$, $n=4$, $\\kappa_\\star = 1$，\n  - $U$ 来自维度 $4$ 的空旋转列表，\n  - $V$ 来自维度 $4$ 的空旋转列表。\n\n- 测试用例 $4$：$m=8$, $n=5$, $\\kappa_\\star = 10^{12}$，\n  - $U$ 来自维度 $8$ 的旋转：$(i,j,\\theta) = (1,8,0.25)$, $(2,7,0.75)$, $(3,5,1.0)$, $(4,6,0.33)$，\n  - $V$ 来自维度 $5$ 的旋转：$(i,j,\\theta) = (1,3,0.2)$, $(2,5,0.9)$, $(3,4,1.1)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序与测试用例相同，每个值四舍五入到 $10$ 位小数。", "solution": "必须首先对问题陈述进行严格验证，以确定其科学有效性和逻辑一致性。\n\n**步骤 1：提取给定信息**\n\n为每个测试用例提供了以下数据和定义：\n- 正整数 $m$ 和 $n$，约束条件为 $m \\ge n \\ge 2$。\n- 目标 2-范数条件数 $\\kappa_\\star > 0$。\n- 用于构造正交矩阵 $U \\in \\mathbb{R}^{m \\times m}$ 的平面旋转列表。\n- 用于构造正交矩阵 $V \\in \\mathbb{R}^{n \\times n}$ 的平面旋转列表。\n- 平面旋转矩阵 $G(i,j,\\theta) \\in \\mathbb{R}^{p \\times p}$ 的定义，其中 $1 \\le i < j \\le p$，该矩阵是单位矩阵，但在行和列 $i$ 和 $j$ 处的子矩阵除外：\n$$\n\\begin{bmatrix}\n\\cos(\\theta) & \\sin(\\theta) \\\\\n-\\sin(\\theta) & \\cos(\\theta)\n\\end{bmatrix}\n$$\n- 从旋转列表 $(i_k, j_k, \\theta_k)$ 构造正交矩阵 $Q \\in \\mathbb{R}^{p \\times p}$，其形式为乘积 $Q = G(i_1,j_1,\\theta_1)\\,G(i_2,j_2,\\theta_2)\\,\\cdots\\,G(i_r,j_r,\\theta_r)$。空列表将 $Q$ 定义为单位矩阵。\n- 对角奇异值矩阵 $\\Sigma \\in \\mathbb{R}^{m \\times n}$ 的定义，其前 $n$ 个对角线元素是由等比数列定义的奇异值 $\\sigma_j$：\n$$\n\\sigma_j = \\kappa_\\star^{-\\frac{j-1}{n-1}}, \\quad \\text{for } j=1,\\dots,n.\n$$\n- 最终矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 的构造为 $A = U\\,\\Sigma\\,V^\\top$。\n- 要求的输出是绝对相对误差 $\\varepsilon = \\left|\\frac{\\kappa_2(A)}{\\kappa_\\star} - 1\\right|$，其中 $\\kappa_2(A)$ 是 $A$ 的数值计算出的 2-范数条件数。\n\n**步骤 2：使用提取的信息进行验证**\n\n- **科学依据：** 该问题牢固地植根于数值线性代数的原理，特别是关于奇异值分解（SVD）、矩阵条件数以及通过 Givens 旋转实现的正交变换。这些是计算工程学中的标准和基本概念。构造 $A = U\\Sigma V^\\top$ 是 SVD 的定义。\n- **适定性：** 构造矩阵 $A$ 的过程是确定且无歧义的。对于给定的输入集，$U$、$V$ 和 $\\Sigma$ 矩阵是唯一定义的，这反过来也唯一定义了 $A$。$A$ 的奇异值，以及其条件数 $\\kappa_2(A)$，都是唯一的。因此，每个测试用例的误差 $\\varepsilon$ 都存在唯一解。\n- **客观性：** 问题陈述使用精确的数学语言，没有任何主观性或含糊不清之处。\n\n**关于通用性的评述：**\n奇异值的定义为 $\\sigma_j = \\kappa_\\star^{-\\frac{j-1}{n-1}}$。标准的 SVD 约定要求奇异值按非递增顺序排序：$\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_n \\ge 0$。\n- 如果 $\\kappa_\\star > 1$，指数 $-\\frac{j-1}{n-1}$ 是非正且递减的。序列 $\\sigma_j$ 是非递增的，其中 $\\sigma_1 = 1$ 且 $\\sigma_n = \\kappa_\\star^{-1}$。$\\Sigma$ 的条件数是 $\\sigma_1/\\sigma_n = 1/\\kappa_\\star^{-1} = \\kappa_\\star$。这与定义一致。\n- 如果 $\\kappa_\\star = 1$，则所有 $\\sigma_j=1$。条件数为 $1$，等于 $\\kappa_\\star$。这与定义一致。\n- 如果 $0 < \\kappa_\\star < 1$，序列 $\\sigma_j$ 将是严格递增的。最大奇异值将是 $\\sigma_n = \\kappa_\\star^{-1}$，最小奇异值是 $\\sigma_1=1$。其比率将是 $\\kappa_\\star^{-1} \\neq \\kappa_\\star$。这将与为 $\\Sigma$ 实现条件数 $\\kappa_\\star$ 的目标相矛盾。\n然而，所有提供的测试用例都使用 $\\kappa_\\star \\ge 1$。因此，对于待求解的特定实例，该问题是适定的且内部一致的。\n\n**结论：** 该问题具有科学依据、适定且客观。判定其为**有效**。\n\n**求解方法**\n\n该问题要求构造一个具有特定结构的矩阵 $A$，并随后对其条件数进行数值评估。每个测试用例的处理过程如下。\n\n1.  **构造正交矩阵 $U$ 和 $V$**：\n    矩阵 $U \\in \\mathbb{R}^{m \\times m}$ 和 $V \\in \\mathbb{R}^{n \\times n}$ 由其各自的 Givens 旋转列表构造而成。对于给定的维度 $p$ 和旋转列表 $(i_1,j_1,\\theta_1),\\dots,(i_r,j_r,\\theta_r)$，对应的正交矩阵 $Q$ 是乘积 $Q = G_1 G_2 \\cdots G_r$。每个矩阵 $G_k = G(i_k, j_k, \\theta_k)$ 是一个 $p \\times p$ 的单位矩阵，仅有四个由旋转定义的条目不同。对于索引 $i < j$，使用从 0 开始的数组索引，这对应于：\n    $G_{i-1,i-1} = \\cos(\\theta)$、$G_{i-1,j-1} = \\sin(\\theta)$、$G_{j-1,i-1} = -\\sin(\\theta)$ 和 $G_{j-1,j-1} = \\cos(\\theta)$。\n    如果旋转列表为空，则该矩阵为单位矩阵 $I$。这些旋转矩阵的乘积结果是一个正交矩阵 ($Q Q^\\top = Q^\\top Q = I$)，因为每个 $G_k$ 都是正交的，而正交矩阵的乘积也是正交的。\n\n2.  **构造奇异值矩阵 $\\Sigma$**：\n    矩阵 $\\Sigma \\in \\mathbb{R}^{m \\times n}$ 被构造成一个矩形对角矩阵。其对角线元素 $\\Sigma_{j,j}$（对于 $j=0, \\dots, n-1$）被设置为指定的奇异值 $\\sigma_{j+1}$。奇异值 $\\sigma_j$（对于 $j=1, \\dots, n$）使用公式 $\\sigma_j = \\kappa_\\star^{-\\frac{j-1}{n-1}}$ 计算。如前所述，对于给定的 $\\kappa_\\star \\ge 1$ 的测试用例，这将生成一个非递增的非负值序列，符合奇异值的要求。最大奇异值为 $\\sigma_1 = 1$，最小奇异值为 $\\sigma_n = \\kappa_\\star^{-1}$。\n\n3.  **构造矩阵 $A$**：\n    最终矩阵 $A$ 根据 SVD 结构由分量 $U$、$\\Sigma$ 和 $V$ 组装而成：\n    $$A = U \\Sigma V^\\top$$\n    此处，$V^\\top$ 是矩阵 $V$ 的转置。\n\n4.  **计算实现的条件数和误差**：\n    构造 $A = U\\Sigma V^\\top$ 是一个有效的 SVD，因此理论上，$A$ 的奇异值正是我们定义的 $\\sigma_j$ 值。因此，理论条件数 $\\kappa_2(A)$ 精确地等于 $\\kappa_\\star$。然而，问题要求我们通过数值计算来验证这一点。首先使用浮点算术计算矩阵 $A$。然后，将一个标准的数值 SVD 算法应用于 $A$ 以计算其奇异值，我们称之为 $\\hat{\\sigma}_j$。由于有限精度算术，预计会出现微小差异。\n    数值上实现的条件数是 $\\hat{\\kappa}_2(A) = \\max(\\hat{\\sigma}_j) / \\min(\\hat{\\sigma}_j)$。\n    最后，计算绝对相对误差：\n    $$ \\varepsilon = \\left| \\frac{\\hat{\\kappa}_2(A)}{\\kappa_\\star} - 1 \\right| $$\n    该值量化了数值计算出的条件数与目标值的偏差，这主要是由浮点表示和算术误差引起的。最终结果四舍五入到 $10$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_orthogonal_matrix(p, rotations):\n    \"\"\"\n    Constructs an orthogonal matrix from a list of Givens rotations.\n    \n    Args:\n        p (int): The dimension of the square matrix.\n        rotations (list): A list of tuples (i, j, theta) defining the rotations.\n    \n    Returns:\n        numpy.ndarray: The resulting orthogonal matrix of shape (p, p).\n    \"\"\"\n    if not rotations:\n        return np.identity(p, dtype=np.float64)\n    \n    rotation_matrices = []\n    for i, j, theta in rotations:\n        G = np.identity(p, dtype=np.float64)\n        c, s = np.cos(theta), np.sin(theta)\n        \n        # Adjust for 1-based indexing from the problem to 0-based for numpy\n        idx_i, idx_j = i - 1, j - 1\n        \n        G[idx_i, idx_i] = c\n        G[idx_j, idx_j] = c\n        G[idx_i, idx_j] = s\n        G[idx_j, idx_i] = -s\n        rotation_matrices.append(G)\n        \n    # The problem defines Q as G_1 * G_2 * ... * G_r\n    # np.linalg.multi_dot computes this product efficiently.\n    Q = np.linalg.multi_dot(rotation_matrices)\n    return Q\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all specified test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"m\": 5, \"n\": 5, \"kappa_star\": 10**8,\n            \"u_rotations\": [(1, 2, 0.7), (3, 5, 1.1)],\n            \"v_rotations\": [(2, 4, 0.6), (1, 3, 1.0)]\n        },\n        {\n            \"m\": 6, \"n\": 4, \"kappa_star\": 10**9,\n            \"u_rotations\": [(1, 6, 0.5), (2, 3, 1.2), (4, 5, 0.9)],\n            \"v_rotations\": [(1, 4, 0.4), (2, 3, 1.3)]\n        },\n        {\n            \"m\": 4, \"n\": 4, \"kappa_star\": 1.0,\n            \"u_rotations\": [],\n            \"v_rotations\": []\n        },\n        {\n            \"m\": 8, \"n\": 5, \"kappa_star\": 10**12,\n            \"u_rotations\": [(1, 8, 0.25), (2, 7, 0.75), (3, 5, 1.0), (4, 6, 0.33)],\n            \"v_rotations\": [(1, 3, 0.2), (2, 5, 0.9), (3, 4, 1.1)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        m, n, kappa_star = case[\"m\"], case[\"n\"], case[\"kappa_star\"]\n        u_rotations, v_rotations = case[\"u_rotations\"], case[\"v_rotations\"]\n\n        # 1. Construct orthogonal matrices U and V\n        U = build_orthogonal_matrix(m, u_rotations)\n        V = build_orthogonal_matrix(n, v_rotations)\n\n        # 2. Construct singular value matrix Sigma\n        # The case n=1 is ruled out by problem constraints (n>=2), so n-1 is non-zero.\n        sigma_values = np.array([kappa_star**(-(j - 1) / (n - 1)) for j in range(1, n + 1)], dtype=np.float64)\n        Sigma = np.zeros((m, n), dtype=np.float64)\n        np.fill_diagonal(Sigma, sigma_values)\n        \n        # 3. Construct matrix A\n        A = U @ Sigma @ V.T\n\n        # 4. Compute achieved condition number and error\n        # Use numpy.linalg.svd to get the numerically computed singular values of A\n        singular_values_A = np.linalg.svd(A, compute_uv=False)\n        \n        # The condition number is the ratio of the largest to smallest singular value\n        kappa_2_A = np.max(singular_values_A) / np.min(singular_values_A)\n        \n        # Calculate the absolute relative error\n        relative_error = np.abs(kappa_2_A / kappa_star - 1)\n        results.append(relative_error)\n\n    # Format the final output as specified\n    formatted_results = [f\"{res:.10f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2435624"}]}