{"hands_on_practices": [{"introduction": "本练习旨在通过一个清晰的理论计算，来巩固您对多层蒙特卡洛 (MLMC) 方法核心优势的理解。您将直接对比标准蒙特卡洛 (MC) 方法和 MLMC 方法在达到相同精度要求时所需的计算成本。通过此练习，您将定量地看到，当问题结构适当时，MLMC 如何通过在不同精度水平上巧妙地分配计算资源，从而实现计算效率的显著提升。", "problem": "一位计算工程师使用多层蒙特卡洛（MLMC）和标准蒙特卡洛（MC）方法，来估计一个由在网格层级上进行数值求解的随机偏微分方程产生的无量纲关注量（QoI）的均值。在层级 $l \\in \\{0,1,\\dots,L\\}$ 上的数值近似采用的网格尺寸为 $h_l \\propto 2^{-l}$。绝对离散化偏差满足 $|\\mathbb{E}[Q - Q_L]| \\leq c_b 2^{-\\alpha L}$，其中 $c_b = 0.5$ 且 $\\alpha = 2$。在层级 $l$ 上的单个样本成本为 $C_l = 2^{2l}$（两种方法的单位任意但相同）。\n\n对于 MLMC，层级差为 $Y_0 = Q_0$ 以及当 $l \\ge 1$ 时为 $Y_l = Q_l - Q_{l-1}$，通过独立实现进行抽样。层级差的方差为 $V_0 = \\operatorname{Var}(Y_0) = 1.0$，且当 $l \\ge 1$ 时为 $V_l = \\operatorname{Var}(Y_l) = 2^{-2l}$。对于在最精细层级 $L$ 上的标准 MC，QoI 的方差为 $s^2 = \\operatorname{Var}(Q_L) = 1.0$。假设所有样本在所有层级和实现中都是相互独立的。\n\n两种方法都必须为连续均值 $\\mathbb{E}[Q]$ 得出一个总宽度为 $W = 1.0 \\times 10^{-2}$ 的双边 $95\\%$ 置信区间。采用保守要求，即离散化偏差的大小以 $W/4$ 为界，且统计半宽等于 $W/4$。取满足偏差要求的最小整数 $L$，并比较在该 $L$ 下，为满足统计半宽要求，标准 MC 和 MLMC 所需的最小预期计算工作量。\n\n在这些假设下，标准 MC 的最小预期工作量与 MLMC 的最小预期工作量之比是多少？将您的答案四舍五入到三位有效数字。", "solution": "该问题要求在指定的总误差容限下，比较标准蒙特卡洛（MC）和多层蒙特卡洛（MLMC）方法估计关注量均值 $\\mathbb{E}[Q]$ 所需的最小计算工作量。\n\n首先，我们验证问题陈述的有效性。\n已知条件如下：\n- 层级结构 $l \\in \\{0, 1, \\dots, L\\}$。\n- 网格尺寸 $h_l \\propto 2^{-l}$。\n- 离散化偏差界：$|\\mathbb{E}[Q - Q_L]| \\le c_b 2^{-\\alpha L}$，其中 $c_b = 0.5$ 且 $\\alpha = 2$。\n- 层级 $l$ 的单样本成本：$C_l = 2^{2l}$。\n- MLMC 层级差：$Y_0 = Q_0$，当 $l \\ge 1$ 时为 $Y_l = Q_l - Q_{l-1}$。\n- MLMC 方差：$V_0 = \\operatorname{Var}(Y_0) = 1.0$，当 $l \\ge 1$ 时为 $V_l = \\operatorname{Var}(Y_l) = 2^{-2l}$。\n- 标准 MC 方差：$s^2 = \\operatorname{Var}(Q_L) = 1.0$。\n- $\\mathbb{E}[Q]$ 的总置信区间宽度：$W = 1.0 \\times 10^{-2}$。\n- 偏差约束：$|\\mathbb{E}[Q - Q_L]| \\le W/4$。\n- 统计半宽约束：统计半宽 $= W/4$。\n\n该问题具有科学依据，描述了蒙特卡洛方法在计算工程中的一个标准应用。问题是适定的，目标明确，数据充分。语言客观而精确。因此，该问题被认为是有效的。\n\n解题过程分四步：\n1.  确定最精细的分辨率层级 $L$。\n2.  计算标准 MC 的最小工作量 $\\text{Work}_{MC}$。\n3.  计算 MLMC 的最小工作量 $\\text{Work}_{MLMC}$。\n4.  计算比率 $\\frac{\\text{Work}_{MC}}{\\text{Work}_{MLMC}}$。\n\n步骤1：确定最精细层级 $L$。\n选择层级 $L$ 以满足离散化偏差约束。给定偏差以 $c_b 2^{-\\alpha L}$ 为界，且该值必须小于或等于 $W/4$。我们必须找到满足此不等式的最小整数 $L$。\n$$c_b 2^{-\\alpha L} \\le \\frac{W}{4}$$\n代入给定值 $c_b = 0.5$，$\\alpha = 2$ 和 $W = 1.0 \\times 10^{-2}$：\n$$0.5 \\times 2^{-2L} \\le \\frac{1.0 \\times 10^{-2}}{4}$$\n$$0.5 \\times (2^2)^{-L} \\le 0.0025$$\n$$0.5 \\times 4^{-L} \\le 0.0025$$\n$$4^{-L} \\le \\frac{0.0025}{0.5} = 0.005$$\n$$4^L \\ge \\frac{1}{0.005} = 200$$\n我们测试 $L$ 的整数值：$4^3 = 64$ 和 $4^4 = 256$。满足 $4^L \\ge 200$ 的最小整数 $L$ 是 $L=4$。\n\n步骤2：标准 MC 的最小工作量。\n标准 MC 估计器在最精细层级 $L=4$ 上使用 $N_{MC}$ 个样本。估计器为 $\\hat{E}_{MC} = \\frac{1}{N_{MC}} \\sum_{i=1}^{N_{MC}} Q_L^{(i)}$。该估计器的方差为：\n$$\\operatorname{Var}(\\hat{E}_{MC}) = \\frac{\\operatorname{Var}(Q_L)}{N_{MC}} = \\frac{s^2}{N_{MC}}$$\n已知 $s^2 = 1.0$。\n问题陈述，对于 $\\mathbb{E}[Q]$ 的 $95\\%$ 置信区间的总宽度应为 $W$。这个总误差由离散化偏差和统计误差组成。问题为每部分误差提供了预算：偏差 $|\\mathbb{E}[Q - Q_L]|$ 以 $W/4$ 为界，$\\mathbb{E}[Q_L]$ 的置信区间的统计半宽为 $W/4$。\n一个双边 $95\\%$ 置信区间的半宽为 $z \\sqrt{\\operatorname{Var}(\\text{Estimator})}$，其中 z-分数 $z \\approx 1.96$。因此，统计约束为：\n$$z \\sqrt{\\operatorname{Var}(\\hat{E}_{MC})} = \\frac{W}{4}$$\n$$z \\sqrt{\\frac{s^2}{N_{MC}}} = \\frac{W}{4}$$\n求解所需的样本数量 $N_{MC}$：\n$$N_{MC} = \\frac{s^2 z^2}{(W/4)^2}$$\n标准 MC 的计算工作量（成本）是样本数量乘以层级 $L$ 上的单样本成本：\n$$\\text{Work}_{MC} = N_{MC} \\times C_L = \\frac{s^2 z^2}{(W/4)^2} C_L$$\n当 $L=4$ 时，单样本成本为 $C_4 = 2^{2 \\times 4} = 2^8 = 256$。\n\n步骤3：MLMC 的最小工作量。\nMLMC 估计器为 $\\hat{E}_{MLMC} = \\sum_{l=0}^{L} \\frac{1}{N_l} \\sum_{i=1}^{N_l} Y_l^{(i)}$。其方差为：\n$$\\operatorname{Var}(\\hat{E}_{MLMC}) = \\sum_{l=0}^{L} \\frac{\\operatorname{Var}(Y_l)}{N_l} = \\sum_{l=0}^{L} \\frac{V_l}{N_l}$$\n统计误差约束与 MC 的相同：\n$$z \\sqrt{\\operatorname{Var}(\\hat{E}_{MLMC})} = \\frac{W}{4} \\implies \\sum_{l=0}^{L} \\frac{V_l}{N_l} = \\frac{(W/4)^2}{z^2}$$\nMLMC 的总工作量为 $\\text{Work}_{MLMC} = \\sum_{l=0}^{L} N_l C_l$。我们使用拉格朗日乘子法，在方差约束下最小化此工作量。每个层级 $l$ 的最优样本数 $N_l$ 与 $\\sqrt{V_l / C_l}$ 成正比。\n得到的最小工作量由以下公式给出：\n$$\\text{Work}_{MLMC} = \\frac{z^2}{(W/4)^2} \\left( \\sum_{l=0}^{L} \\sqrt{V_l C_l} \\right)^2$$\n我们需要计算当 $L=4$ 时 $\\sum_{l=0}^{L} \\sqrt{V_l C_l}$ 的总和。\n给定值为 $C_l = 2^{2l}$，$V_0 = 1.0$，以及当 $l \\ge 1$ 时 $V_l = 2^{-2l}$。\n对于层级 $l=0$：\n$$\\sqrt{V_0 C_0} = \\sqrt{1.0 \\times 2^{2 \\times 0}} = \\sqrt{1.0 \\times 1} = 1$$\n对于层级 $l \\ge 1$：\n$$\\sqrt{V_l C_l} = \\sqrt{2^{-2l} \\times 2^{2l}} = \\sqrt{1} = 1$$\n当 $L=4$ 时，总和为：\n$$\\sum_{l=0}^{4} \\sqrt{V_l C_l} = \\sqrt{V_0 C_0} + \\sum_{l=1}^{4} \\sqrt{V_l C_l} = 1 + (1+1+1+1) = 5$$\n因此，MLMC 的最小工作量是：\n$$\\text{Work}_{MLMC} = \\frac{z^2}{(W/4)^2} (5)^2 = \\frac{25 z^2}{(W/4)^2}$$\n\n步骤4：计算比率。\n我们现在计算标准 MC 与 MLMC 的最小工作量之比。\n$$\\frac{\\text{Work}_{MC}}{\\text{Work}_{MLMC}} = \\frac{\\frac{s^2 z^2}{(W/4)^2} C_L}{\\frac{z^2}{(W/4)^2} \\left( \\sum_{l=0}^{L} \\sqrt{V_l C_l} \\right)^2} = \\frac{s^2 C_L}{\\left( \\sum_{l=0}^{L} \\sqrt{V_l C_l} \\right)^2}$$\n注意，包含 $z$ 和 $W$ 的项相互抵消。\n代入已知值：$s^2=1.0$，$L=4$，$C_L=C_4=256$，以及 $\\sum_{l=0}^4 \\sqrt{V_l C_l} = 5$：\n$$\\frac{\\text{Work}_{MC}}{\\text{Work}_{MLMC}} = \\frac{1.0 \\times 256}{5^2} = \\frac{256}{25} = 10.24$$\n问题要求将答案四舍五入到三位有效数字。\n$$10.24 \\approx 10.2$$", "answer": "$$\\boxed{10.2}$$", "id": "2416330"}, {"introduction": "在掌握了 MLMC 的理论优势后，本练习将引导您进入算法的核心——最优样本分配。您将编写一个程序，根据问题的方差衰减率 ($\\beta$) 和成本增长率 ($\\gamma$) 来计算各层级所需的最优样本数。通过探索不同参数下的情景，您将亲身体验这些比率如何决定 MLMC 的整体性能，并理解算法在“病态”情景下（即 $\\beta \\approx \\gamma$ 时）的行为。", "problem": "您正在研究不确定性传播场景下，通过多层蒙特卡罗估计量估计的一个标量关注量 (QoI)。对于层级 $l \\in \\{0,1,\\dots,L\\}$，假设成本、方差和偏差的模型如下：\n- 层级 $l$ 的单位样本成本为 $C_l = c_c \\, 2^{\\gamma l}$，其中常数 $c_c > 0$ 和 $\\gamma > 0$。\n- 层级 $l$ 的层级差估计量的方差为 $V_l = c_v \\, 2^{-\\beta l}$，其中常数 $c_v > 0$ 和 $\\beta > 0$。\n- 在层级 $L$ 截断后的绝对偏差为 $B_L = c_b \\, 2^{-\\alpha L}$，其中常数 $c_b > 0$ 和 $\\alpha > 0$。\n\n给定均方误差容差 $\\varepsilon > 0$。定义最小截断层级 $L$ 为满足偏差约束 $B_L \\le \\varepsilon / \\sqrt{2}$ 的最小整数 $L \\ge 0$。在方差约束 $\\sum_{l=0}^{L} V_l / N_l \\le \\varepsilon^2 / 2$ 的条件下，确定能最小化总期望成本 $\\sum_{l=0}^{L} C_l N_l$ 的整数样本数 $\\{N_0,\\dots,N_L\\}$，其中 $N_l$ 是在层级 $l$ 抽取的独立样本数量。返回的样本数必须是此约束问题对应的实值最小化解的按分量取上整的结果。\n\n重点关注方差衰减率 $\\beta$ 与成本增长率 $\\gamma$ 非常接近的情况。分析这种情况如何影响样本 $\\{N_l\\}$ 在各层级间的分布。\n\n使用以下参数化测试套件。在所有测试用例中，使用 $c_b = 1.0$，$c_v = 1.0$，$c_c = 1.0$ 和 $\\alpha = 1.0$。\n- 测试 A (速率平衡): $\\beta = 1.0$, $\\gamma = 1.0$, $\\varepsilon = 2^{-4}$。\n- 测试 B (方差衰减略慢于成本增长): $\\beta = 0.95$, $\\gamma = 1.0$, $\\varepsilon = 2^{-4}$。\n- 测试 C (方差衰减略快于成本增长): $\\beta = 1.05$, $\\gamma = 1.0$, $\\varepsilon = 2^{-4}$。\n- 测试 D (粗容差边界情况): $\\beta = 1.0$, $\\gamma = 1.0$, $\\varepsilon = 1.5$。\n\n您的程序必须为每个测试用例计算指定的整数向量 $[N_0,\\dots,N_L]$。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个元素是对应一个测试用例的方括号括起来的逗号分隔整数列表，顺序为 A、B、C、D。例如，要求的格式为 $[[n_{A,0},\\dots,n_{A,L_A}],[n_{B,0},\\dots,n_{B,L_B}],[n_{C,0},\\dots,n_{C,L_C}],[n_{D,0},\\dots,n_{D,L_D}]]$，不含空格。", "solution": "首先对问题进行严谨的验证。\n\n明确给出的已知条件如下：\n估计一个标量关注量 (QoI)。\n层级由 $l \\in \\{0, 1, \\dots, L\\}$ 表示。\n层级 $l$ 的单位样本成本为 $C_l = c_c \\, 2^{\\gamma l}$，其中常数 $c_c > 0$ 和 $\\gamma > 0$。\n层级 $l$ 的层级差估计量的方差为 $V_l = c_v \\, 2^{-\\beta l}$，其中常数 $c_v > 0$ 和 $\\beta > 0$。\n在层级 $L$ 截断后的绝对偏差为 $B_L = c_b \\, 2^{-\\alpha L}$，其中常数 $c_b > 0$ 和 $\\alpha > 0$。\n均方误差容差为 $\\varepsilon > 0$。\n截断层级 $L$ 是满足偏差约束 $B_L \\le \\varepsilon / \\sqrt{2}$ 的最小整数 $L \\ge 0$。\n方差约束为 $\\sum_{l=0}^{L} V_l / N_l \\le \\varepsilon^2 / 2$，其中 $N_l$ 是层级 $l$ 的样本数。\n目标是确定能最小化总成本 $\\sum_{l=0}^{L} C_l N_l$ 的整数样本数 $\\{N_0, \\dots, N_L\\}$。\n最终的样本数必须是实值最小化解的按分量取上整的结果。\n特别关注的情形是当 $\\beta$ 接近 $\\gamma$ 时。\n测试套件参数为：$c_b = 1.0$，$c_v = 1.0$，$c_c = 1.0$，$\\alpha = 1.0$。\n测试 A: $\\beta = 1.0$, $\\gamma = 1.0$, $\\varepsilon = 2^{-4}$。\n测试 B: $\\beta = 0.95$, $\\gamma = 1.0$, $\\varepsilon = 2^{-4}$。\n测试 C: $\\beta = 1.05$, $\\gamma = 1.0$, $\\varepsilon = 2^{-4}$。\n测试 D: $\\beta = 1.0$, $\\gamma = 1.0$, $\\varepsilon = 1.5$。\n\n该问题被认定为有效。它在科学上基于成熟的用于不确定性量化的多层蒙特卡罗 (MLMC) 方法理论。问题是适定的，构成一个可解的凸优化问题。其语言客观且数学上精确。不存在矛盾、信息缺失或无效前提。因此，我们可以着手推导解决方案。\n\n总均方误差 (MSE) 受偏差平方与总方差之和的限制。该问题对总 MSE 容差 $\\varepsilon^2$ 使用了标准分解，使得 $\\text{Bias}^2 \\le \\varepsilon^2/2$ 且 $\\text{Variance} \\le \\varepsilon^2/2$。\n\n首先，我们确定最小截断层级 $L$。偏差约束为 $B_L \\le \\varepsilon / \\sqrt{2}$。代入 $B_L$ 的模型：\n$$c_b \\, 2^{-\\alpha L} \\le \\frac{\\varepsilon}{\\sqrt{2}}$$\n为求解 $L$，我们对两边取以 2 为底的对数：\n$$-\\alpha L \\le \\log_2\\left(\\frac{\\varepsilon}{c_b\\sqrt{2}}\\right)$$\n$$\\alpha L \\ge -\\log_2\\left(\\frac{\\varepsilon}{c_b\\sqrt{2}}\\right) = \\log_2\\left(\\frac{c_b\\sqrt{2}}{\\varepsilon}\\right)$$\n$$L \\ge \\frac{1}{\\alpha} \\log_2\\left(\\frac{c_b\\sqrt{2}}{\\varepsilon}\\right)$$\n由于 $L$ 必须是满足此不等式的最小非负整数，我们得到：\n$$L = \\max\\left(0, \\left\\lceil \\frac{1}{\\alpha} \\log_2\\left(\\frac{c_b\\sqrt{2}}{\\varepsilon}\\right) \\right\\rceil\\right)$$\n$\\max(0, \\dots)$ 确保了对条件 $L \\ge 0$ 的遵守，这在容差 $\\varepsilon$ 较大时是相关的。\n\n其次，我们确定在 $l \\in \\{0, \\dots, L\\}$ 上的最优样本数 $N_l$。我们必须在方差约束 $\\sum_{l=0}^{L} V_l/N_l \\le \\varepsilon^2/2$ 下最小化总成本 $\\mathcal{C} = \\sum_{l=0}^{L} C_l N_l$。为了在固定预算下最小化线性成本函数，约束必须是活动的，即取等式：$\\sum_{l=0}^{L} V_l/N_l = \\varepsilon^2/2$。\n我们使用拉格朗日乘数法。拉格朗日函数 $\\mathcal{L}$ 为：\n$$\\mathcal{L}(\\{N_l\\}_{l=0}^L, \\lambda) = \\sum_{l=0}^{L} C_l N_l + \\lambda \\left(\\sum_{l=0}^{L} \\frac{V_l}{N_l} - \\frac{\\varepsilon^2}{2}\\right)$$\n对一个通用层级 $k$ 的 $N_k$ 求导并令结果为零，得到实值 $N_k$ 的最优分配：\n$$\\frac{\\partial \\mathcal{L}}{\\partial N_k} = C_k - \\lambda \\frac{V_k}{N_k^2} = 0 \\implies N_k = \\sqrt{\\lambda} \\sqrt{\\frac{V_k}{C_k}}$$\n为求出拉格朗日乘子 $\\lambda$，我们将此 $N_l$ 的表达式代回方差约束中：\n$$\\sum_{l=0}^{L} \\frac{V_l}{\\sqrt{\\lambda} \\sqrt{V_l/C_l}} = \\frac{1}{\\sqrt{\\lambda}} \\sum_{l=0}^{L} \\sqrt{V_l C_l} = \\frac{\\varepsilon^2}{2}$$\n求解 $\\sqrt{\\lambda}$：\n$$\\sqrt{\\lambda} = \\frac{2}{\\varepsilon^2} \\sum_{l=0}^{L} \\sqrt{V_l C_l}$$\n将此结果代回到 $N_k$ 的表达式中：\n$$N_k = \\left(\\frac{2}{\\varepsilon^2} \\sum_{l=0}^{L} \\sqrt{V_l C_l}\\right) \\sqrt{\\frac{V_k}{C_k}}$$\n这就给出了最优的实值样本数。\n\n第三，我们代入给定的成本模型 $C_l = c_c 2^{\\gamma l}$ 和方差模型 $V_l = c_v 2^{-\\beta l}$：\n$$\\sqrt{V_l C_l} = \\sqrt{(c_v 2^{-\\beta l})(c_c 2^{\\gamma l})} = \\sqrt{c_v c_c} \\, 2^{(\\gamma-\\beta)l/2}$$\n$$\\sqrt{\\frac{V_k}{C_k}} = \\sqrt{\\frac{c_v 2^{-\\beta k}}{c_c 2^{\\gamma k}}} = \\sqrt{\\frac{c_v}{c_c}} \\, 2^{-(\\beta+\\gamma)k/2}$$\n求和项变成一个几何级数：\n$$S = \\sum_{l=0}^{L} \\sqrt{V_l C_l} = \\sqrt{c_v c_c} \\sum_{l=0}^{L} \\left(2^{(\\gamma-\\beta)/2}\\right)^l$$\n如果 $\\gamma = \\beta$，则比值为 1，和为 $S = \\sqrt{c_v c_c} (L+1)$。\n如果 $\\gamma \\ne \\beta$，令 $r = 2^{(\\gamma-\\beta)/2}$。和为 $S = \\sqrt{c_v c_c} \\frac{r^{L+1}-1}{r-1}$。\n那么实值 $N_k$ 为：\n$$N_k = \\frac{2 S}{\\varepsilon^2} \\sqrt{\\frac{c_v}{c_c}} \\, 2^{-(\\beta+\\gamma)k/2}$$\n问题陈述，整数样本数是通过对此实值最小化解进行按分量取上整得到的：$N_k^{\\text{int}} = \\lceil N_k \\rceil$。\n\n对 $\\beta \\approx \\gamma$ 的情况进行分析是有启发性的。总成本为 $\\mathcal{C} = \\sum C_l N_l = \\sum C_l \\sqrt{\\lambda}\\sqrt{V_l/C_l} = \\sqrt{\\lambda} \\sum \\sqrt{C_l V_l} = \\frac{2}{\\varepsilon^2}S^2$。总成本与和 $S$ 的平方成正比。表达式 $\\sqrt{V_l C_l} \\propto 2^{(\\gamma-\\beta)l/2}$ 表示在层级 $l$ 上单位标准差缩减所需的计算量。只有当 $\\gamma = \\beta$ 时，这个计算量在所有层级上是恒定的。在这种情况下，对于固定的 $L$，和 $S$ 以及总成本都被最小化。如果 $\\gamma \\ne \\beta$，则成本效益随层级变化，导致所需的总工作量增加。由于项 $2^{-(\\beta+\\gamma)k/2}$ 的存在（因为 $\\beta > 0$ 和 $\\gamma > 0$），样本 $N_k$ 的分布总是随 $k$ 指数衰减。大多数样本被分配到更粗糙、成本更低的层级。\n\n我们现在为给定的测试用例计算结果。对于所有用例，$c_b=1.0, c_v=1.0, c_c=1.0, \\alpha=1.0$。\n$L$ 的公式简化为 $L = \\max(0, \\lceil 0.5 - \\log_2(\\varepsilon) \\rceil)$。\n$N_k$ 的公式简化为 $N_k = \\frac{2}{\\varepsilon^2} \\left(\\sum_{l=0}^{L} 2^{(\\gamma - \\beta)l/2}\\right) 2^{-(\\beta + \\gamma)k/2}$。\n\n测试 A: $\\beta = 1.0, \\gamma = 1.0, \\varepsilon = 2^{-4}$。\n$L = \\max(0, \\lceil 0.5 - (-4) \\rceil) = \\lceil 4.5 \\rceil = 5$。\n$\\gamma = \\beta$，所以和为 $L+1 = 6$。\n$N_k = \\frac{2}{(2^{-4})^2} (6) 2^{-(1.0+1.0)k/2} = 2 \\cdot 2^8 \\cdot 6 \\cdot 2^{-k} = 12 \\cdot 2^{8-k} = 3 \\cdot 2^{10-k}$。\n$N_0=3072, N_1=1536, N_2=768, N_3=384, N_4=192, N_5=96$。\n这些都是整数，所以取上整没有影响。结果：$[3072, 1536, 768, 384, 192, 96]$。\n\n测试 B: $\\beta = 0.95, \\gamma = 1.0, \\varepsilon = 2^{-4}$。\n$L=5$。$\\gamma - \\beta = 0.05$。$\\beta + \\gamma = 1.95$。\n令 $r = 2^{0.025}$。和为 $\\frac{r^6-1}{r-1} \\approx 6.2683$。\n$N_k = \\frac{2}{2^{-8}} (6.2683) 2^{-1.95k/2} = 512 \\cdot (6.2683) \\cdot 2^{-0.975k} \\approx 3209.33 \\cdot 2^{-0.975k}$。\n$N_0 \\approx 3209.33 \\implies \\lceil N_0 \\rceil = 3210$。\n$N_1 \\approx 1632.74 \\implies \\lceil N_1 \\rceil = 1633$。\n$N_2 \\approx 830.61 \\implies \\lceil N_2 \\rceil = 831$。\n$N_3 \\approx 422.58 \\implies \\lceil N_3 \\rceil = 423$。\n$N_4 \\approx 214.97 \\implies \\lceil N_4 \\rceil = 215$。\n$N_5 \\approx 109.37 \\implies \\lceil N_5 \\rceil = 110$。\n结果：$[3210, 1633, 831, 423, 215, 110]$。\n\n测试 C: $\\beta = 1.05, \\gamma = 1.0, \\varepsilon = 2^{-4}$。\n$L=5$。$\\gamma - \\beta = -0.05$。$\\beta + \\gamma = 2.05$。\n令 $r = 2^{-0.025}$。和为 $\\frac{r^6-1}{r-1} \\approx 5.7480$。\n$N_k = \\frac{2}{2^{-8}} (5.7480) 2^{-2.05k/2} = 512 \\cdot (5.7480) \\cdot 2^{-1.025k} \\approx 2942.99 \\cdot 2^{-1.025k}$。\n$N_0 \\approx 2942.99 \\implies \\lceil N_0 \\rceil = 2943$。\n$N_1 \\approx 1445.56 \\implies \\lceil N_1 \\rceil = 1446$。\n$N_2 \\approx 709.97 \\implies \\lceil N_2 \\rceil = 710$。\n$N_3 \\approx 348.72 \\implies \\lceil N_3 \\rceil = 349$。\n$N_4 \\approx 171.27 \\implies \\lceil N_4 \\rceil = 172$。\n$N_5 \\approx 84.11 \\implies \\lceil N_5 \\rceil = 85$。\n结果：$[2943, 1446, 710, 349, 172, 85]$。\n\n测试 D: $\\beta = 1.0, \\gamma = 1.0, \\varepsilon = 1.5$。\n$L = \\max(0, \\lceil 0.5 - \\log_2(1.5) \\rceil) = \\max(0, \\lceil 0.5 - 0.585 \\rceil) = \\max(0, \\lceil -0.085 \\rceil) = \\max(0, 0) = 0$。\n问题简化为单层蒙特卡罗 ($l=0$)。求和只包含一项。\n$N_0 = \\frac{2 V_0}{\\varepsilon^2} = \\frac{2 \\cdot (1.0 \\cdot 2^{-1.0 \\cdot 0})}{1.5^2} = \\frac{2}{2.25} = \\frac{8}{9} \\approx 0.888...$\n$N_0^{\\text{int}} = \\lceil 8/9 \\rceil = 1$。\n结果：$[1]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes optimal integer sample counts for Multilevel Monte Carlo (MLMC)\n    based on given cost, variance, and bias models.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'name': 'A', 'beta': 1.0, 'gamma': 1.0, 'eps': 2**(-4)},\n        {'name': 'B', 'beta': 0.95, 'gamma': 1.0, 'eps': 2**(-4)},\n        {'name': 'C', 'beta': 1.05, 'gamma': 1.0, 'eps': 2**(-4)},\n        {'name': 'D', 'beta': 1.0, 'gamma': 1.0, 'eps': 1.5},\n    ]\n\n    # Common parameters for all test cases\n    cb = 1.0\n    cv = 1.0\n    cc = 1.0\n    alpha = 1.0\n    \n    results = []\n    \n    for case in test_cases:\n        beta = case['beta']\n        gamma = case['gamma']\n        eps = case['eps']\n\n        # Step 1: Determine the truncation level L\n        # L must be the smallest non-negative integer satisfying the bias constraint.\n        # This formula derives from: cb * 2**(-alpha*L) <= eps / sqrt(2)\n        # L >= (1/alpha) * log2(cb*sqrt(2)/eps)\n        log_arg = cb * np.sqrt(2) / eps\n        if log_arg <= 1:\n          # If the argument is <= 1, log2 is <= 0.\n          # The smallest non-negative integer L is 0.\n          L = 0\n        else:\n          L = int(np.ceil((1.0 / alpha) * np.log2(log_arg)))\n        \n        # In this specific problem, the prompt asks for the smallest integer L >= 0.\n        # A more direct implementation is max(0, ceil(...))\n        L_val = (1.0 / alpha) * np.log2(cb * np.sqrt(2) / eps)\n        L = max(0, int(np.ceil(L_val)))\n        \n        levels = np.arange(L + 1)\n        \n        # Step 2: Calculate the sum term for the optimal N_l formula\n        # sum_term = sum_{l=0 to L} sqrt(V_l * C_l)\n        # V_l*C_l = (cv * 2**(-beta*l)) * (cc * 2**(gamma*l)) = cv*cc*2**((gamma-beta)*l)\n        # sqrt(V_l*C_l) = sqrt(cv*cc) * 2**((gamma-beta)*l/2)\n        sum_base = np.sqrt(cv * cc)\n        \n        if gamma == beta:\n            sum_val = sum_base * (L + 1)\n        else:\n            r = 2**((gamma - beta) / 2.0)\n            sum_val = sum_base * (r**(L + 1) - 1) / (r - 1)\n\n        # Step 3: Calculate the integer sample counts N_k for k=0,...,L\n        # N_k = (2/eps^2) * sum_val * sqrt(V_k/C_k)\n        # sqrt(V_k/C_k) = sqrt(cv/cc) * 2**(-(beta+gamma)*k/2)\n        \n        Nk_list = []\n        for k in levels:\n            sqrt_vk_ck_ratio = np.sqrt(cv / cc) * (2**(- (beta + gamma) * k / 2.0))\n            Nk_real = (2.0 / eps**2) * sum_val * sqrt_vk_ck_ratio\n            Nk_int = int(np.ceil(Nk_real))\n            Nk_list.append(Nk_int)\n        \n        results.append(Nk_list)\n\n    # Final print statement in the exact required format.\n    # Format: [[n_A_0,...,n_A_L_A],[n_B_0,...,n_B_L_B],...] with no spaces.\n    results_str_parts = []\n    for res_list in results:\n        part = f\"[{','.join(map(str, res_list))}]\"\n        results_str_parts.append(part)\n    \n    final_output = f\"[{','.join(results_str_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2416356"}, {"introduction": "这个综合性练习将挑战您将前面学到的所有概念——物理建模、数值离散化和 MLMC 估计——融合在一起，解决一个真实的计算工程问题。您将为超大规模集成 (VLSI) 电路中的互连线构建一个信号延迟模型，并使用 MLMC 来量化由制造变异引起的不确定性。这个实践不仅能巩固您的编程和建模技能，还将充分展示 MLMC 在复杂工程系统不确定性传播分析中的强大威力。", "problem": "你需要实现一个完整的、可运行的程序，该程序使用多层蒙特卡洛 (MLMC) 方法，估算在存在制造偏差的情况下，超大规模集成 (VLSI) 互连线中的期望信号延迟。估算目标是远端节点电压达到单位阶跃输入指定阈值分数所需的时间，以秒为单位，四舍五入到浮点精度。\n\n物理模型应基于以下基本原理和核心定义：\n- 电阻介质中的欧姆定律：对于长度为 $L$、横截面积为 $A$ 的均匀导体，其电阻为 $R = \\rho \\, L / A$，其中 $\\rho$ 是电阻率。\n- 平行板电容：对于面积为 $A$、由厚度为 $h$、介电常数为 $\\varepsilon$ 的电介质隔开的极板，其电容为 $C = \\varepsilon \\, A / h$。一个常见的工程修正是针对边缘（边缘）场的，即使用有效板宽 $W_{\\text{eff}} = W + 2h/\\pi$，其中 $W$ 是物理宽度。\n- 一阶系统阶跃响应：对于单位阶跃输入 $u(t)$，单个电阻-电容网络遵循线性微分方程 $C \\, \\mathrm{d}v/\\mathrm{d}t + (1/R)\\,v = (1/R)\\,u(t)$，达到固定阈值（例如 $v^\\star = 0.5$）的时间通过求解阶跃响应中的 $t$ 来确定。在分布式互连中，线路被建模为通过空间离散化获得的电阻-电容梯形网络；其控制性的半离散线性微分系统可以使用无条件稳定的后向欧拉法进行时间积分。\n\n数学和数值模型：\n- 几何与材料：长度为 $L$、矩形横截面宽度为 $W$、厚度为 $T$ 的互连线在一个接地平面上方，由厚度为 $h$、介电常数为 $\\varepsilon = \\varepsilon_{0}\\varepsilon_{r}$ 的电介质隔开，其中 $\\varepsilon_{0}$ 是真空介电常数，$\\varepsilon_{r}$ 是相对介电常数。电阻率为 $\\rho$。\n- 随机输入：由于制造偏差，宽度 $W$ 和厚度 $T$ 是独立的，服从正态分布，其均值分别为 $\\mu_{W}$ 和 $\\mu_{T}$，标准差分别为 $\\sigma_{W}$ 和 $\\sigma_{T}$，为确保物理真实性，在严格为正的下界 $w_{\\min}$ 和 $t_{\\min}$ 处进行截断。也就是说，通过拒绝采样来抽取 $W \\sim \\max(\\mathcal{N}(\\mu_{W}, \\sigma_{W}^{2}), w_{\\min})$ 和 $T \\sim \\max(\\mathcal{N}(\\mu_{T}, \\sigma_{T}^{2}), t_{\\min})$。\n- 空间离散化层次结构：构建 $L+1$ 个层级的均匀空间网格，对于层级 $\\ell \\in \\{0,1,\\dots,L\\}$，有 $N_{\\ell} = N_{0}\\, 2^{\\ell}$ 个分段，其中 $N_{0} \\in \\mathbb{N}$。令 $\\Delta x_{\\ell} = L/N_{\\ell}$。在每个层级上，将互连线表示为电阻-电容梯形网络：每个分段的电阻为 $r_{\\text{seg}} = \\rho \\, \\Delta x_{\\ell} /(W T)$，每个内部节点对地电容为 $c_{\\text{node}} = \\varepsilon \\, W_{\\text{eff}} \\, \\Delta x_{\\ell} / h$，其中 $W_{\\text{eff}} = W + 2h/\\pi$。\n- 时间积分：对节点电压的半离散线性系统应用时间步长为 $\\Delta t_{\\ell}$ 的后向欧拉法。输入端的驱动节点是设置为幅度为 $1$ 的单位阶跃的狄利克雷边界；远端是开路（无负载）。使用固定阈值 $v^{\\star} = 0.5$ 来定义延迟可观测量 $P_{\\ell}(W,T)$，即远端节点电压首次达到 $v^{\\star}$ 的时间 $t$，该时间在时间步之间进行线性插值。选择与扩散时间尺度 $r' c' L^{2}$ 成正比的仿真时域 $T_{\\max}$，其中 $r' = \\rho/(W T)$ 和 $c' = \\varepsilon W_{\\text{eff}}/h$，即对于一个固定因子 $\\alpha>0$，有 $T_{\\max} = \\alpha \\, r' c' L^{2}$。使用依赖于层级的时间步数 $M_{\\ell} = M_{0}\\,2^{\\ell}$ 和 $\\Delta t_{\\ell} = T_{\\max}/M_{\\ell}$。\n- 关注量：对于任意实现 $(W,T)$ 和层级 $\\ell$，计算 $Y_{\\ell}(W,T) := P_{\\ell}(W,T)$，即估计的 $v^{\\star}$ 穿越时间，单位为秒。\n\n多层蒙特卡洛 (MLMC) 估计器：\n- 对最精细层级 $L$ 的期望使用伸缩和表示：$\\mathbb{E}[Y_{L}] = \\mathbb{E}[Y_{0}] + \\sum_{\\ell=1}^{L} \\mathbb{E}[Y_{\\ell} - Y_{\\ell-1}]$，并通过蒙特卡洛样本均值来估计每个期望，其中逐层耦合对同一样本索引的 $Y_{\\ell}$ 和 $Y_{\\ell-1}$ 使用共享的随机输入 $(W,T)$。\n- 方差驱动的样本分配：令 $V_{\\ell}$ 表示 $\\ell=0$ 时 $Y_{0}$ 的方差和 $\\ell \\ge 1$ 时 $(Y_{\\ell}-Y_{\\ell-1})$ 的方差，$C_{\\ell}$ 表示层级 $\\ell$ 的每样本计算量（与 $N_{\\ell} M_{\\ell}$ 成正比）。给定一个均方根误差容限 $\\varepsilon$，将其分解为方差和偏差目标。使用 $V_{\\ell}$ 和 $C_{\\ell}$ 的引导估计，根据标准的渐近最优法则 $N_{\\ell} \\propto \\sqrt{V_{\\ell}/C_{\\ell}}$ 来分配每层的样本数 $N_{\\ell}$，并进行归一化以达到方差目标。通过限制最大层级 $L$ 并确保 $(Y_{L}-Y_{L-1})$ 的均值相对于 $\\varepsilon$ 足够小来控制偏差。\n\n实现要求：\n- 你的程序必须实现上述模型和估计器。它必须使用固定的伪随机数生成器种子，以确保跨次运行的可复现性。\n- 为保证数值鲁棒性，通过拒绝采样确保 $W \\ge w_{\\min}$ 和 $T \\ge t_{\\min}$。\n- 最终答案必须以秒为单位表示，为浮点数。\n\n测试套件：\n实现你的程序，为以下三种情况运行 MLMC 估计器。在所有情况下，使用 $v^{\\star} = 0.5$，$\\alpha = 10$， $N_{0} = 8$， $M_{0} = 80$， $L_{\\max} = 3$， $w_{\\min} = \\mu_{W}/3$，以及 $t_{\\min} = \\mu_{T}/3$。真空介电常数为 $\\varepsilon_{0} = 8.8541878128 \\times 10^{-12}\\ \\text{F/m}$。最终输出必须是单行，包含一个 Python 风格的列表，其中包含三种情况下的期望延迟（以秒为单位），顺序如下，不含任何额外文本。\n\n- 情况 A (正常路径):\n  - $L = 5.0 \\times 10^{-4}\\ \\text{m}$, $h = 2.0 \\times 10^{-7}\\ \\text{m}$, $\\rho = 1.68 \\times 10^{-8}\\ \\Omega\\cdot\\text{m}$, $\\varepsilon_{r} = 3.9$,\n  - $\\mu_{W} = 1.2 \\times 10^{-7}\\ \\text{m}$, $\\sigma_{W} = 1.2 \\times 10^{-8}\\ \\text{m}$,\n  - $\\mu_{T} = 6.0 \\times 10^{-8}\\ \\text{m}$, $\\sigma_{T} = 8.0 \\times 10^{-9}\\ \\text{m}$,\n  - MLMC 容限 $\\varepsilon = 1.0 \\times 10^{-12}\\ \\text{s}$。\n\n- 情况 B (薄金属，延迟较大；对应较高电阻的边缘情况):\n  - $L = 5.0 \\times 10^{-4}\\ \\text{m}$, $h = 2.0 \\times 10^{-7}\\ \\text{m}$, $\\rho = 1.68 \\times 10^{-8}\\ \\Omega\\cdot\\text{m}$, $\\varepsilon_{r} = 3.9$,\n  - $\\mu_{W} = 1.2 \\times 10^{-7}\\ \\text{m}$, $\\sigma_{W} = 1.2 \\times 10^{-8}\\ \\text{m}$,\n  - $\\mu_{T} = 4.0 \\times 10^{-8}\\ \\text{m}$, $\\sigma_{T} = 6.0 \\times 10^{-9}\\ \\text{m}$,\n  - MLMC 容限 $\\varepsilon = 1.5 \\times 10^{-12}\\ \\text{s}$。\n\n- 情况 C (低k介电质，延迟较小；对应电容减小的边缘情况):\n  - $L = 5.0 \\times 10^{-4}\\ \\text{m}$, $h = 2.0 \\times 10^{-7}\\ \\text{m}$, $\\rho = 1.68 \\times 10^{-8}\\ \\Omega\\cdot\\text{m}$, $\\varepsilon_{r} = 2.5$,\n  - $\\mu_{W} = 1.2 \\times 10^{-7}\\ \\text{m}$, $\\sigma_{W} = 1.2 \\times 10^{-8}\\ \\text{m}$,\n  - $\\mu_{T} = 6.0 \\times 10^{-8}\\ \\text{m}$, $\\sigma_{T} = 8.0 \\times 10^{-9}\\ \\text{m}$,\n  - MLMC 容限 $\\varepsilon = 1.0 \\times 10^{-12}\\ \\text{s}$。\n\n输出格式：\n你的程序应生成单行输出，包含一个用方括号括起来的、逗号分隔的结果列表，顺序为 [情况 A 结果, 情况 B 结果, 情况 C 结果]，例如，“[resultA,resultB,resultC]”。每个结果必须是单个浮点数，单位为秒。\n\n所有角度（如有）必须以弧度为单位。此问题中不涉及百分比；任何分数量必须表示为小数。\n\n你的程序必须是完全自包含的，不得要求任何用户输入，也不得访问文件或网络。它必须遵守指定的执行环境。", "solution": "该问题要求使用多层蒙特卡洛（MLMC）方法估计 VLSI 互连线中的期望信号传播延迟。互连线的几何参数，即宽度 $W$ 和厚度 $T$，受制造偏差影响，并被建模为随机变量。\n\n解决方案的制定首先要为互连线的单次实现建立物理和数值模型，然后将此模型嵌入到 MLMC 统计框架中。\n\n### 1. 物理和数值模型\n\n一个长度为 $L$、宽度为 $W$、厚度为 $T$ 且位于接地平面上方的互连线被建模为分布式电阻-电容（RC）线。为了进行数值模拟，这条连续的线在给定的细化层级 $\\ell$ 上被离散化为一个包含 $S_{\\ell}$ 个分段的梯形网络。\n\n**1.1. RC 梯形网络参数**\n\n对于层级 $\\ell$，均匀空间分段的数量为 $S_{\\ell} = N_{0} 2^{\\ell}$，其中 $N_{0}$ 是基础分段数。每个分段的长度为 $\\Delta x_{\\ell} = L / S_{\\ell}$。\n\n- **每分段电阻 ($r_{\\text{seg}}$)**：根据欧姆定律，单个分段的电阻由下式给出：\n$$r_{\\text{seg}} = \\frac{\\rho \\Delta x_{\\ell}}{W T}$$\n其中 $\\rho$ 是电阻率，而 $W$ 和 $T$ 是给定样本的随机宽度和厚度。\n\n- **每节点电容 ($c_{\\text{node}}$)**：对地电容使用带有边缘场校正的平行板公式进行建模。分段的总电容归属于其节点。我们采用标准的 $\\Pi$ 模型，其中分段的电容在其两个端节点之间平分。因此，梯形网络的内部节点会累积来自两个相邻分段的电容，而端节点仅从一个分段接收电容。\n用于电容计算的有效宽度 $W_{\\text{eff}}$ 是 $W_{\\text{eff}} = W + 2h/\\pi$，其中 $h$ 是电介质厚度。长度为 $\\Delta x_{\\ell}$ 的电容为：\n$$c_{\\text{node}} = \\frac{\\varepsilon W_{\\text{eff}} \\Delta x_{\\ell}}{h}$$\n其中 $\\varepsilon = \\varepsilon_{0}\\varepsilon_{r}$ 是电介质介电常数。\n根据 $\\Pi$ 模型，每个内部节点（$i=1, \\dots, S_{\\ell}-1$）的电容为 $C_i = c_{\\text{node}}$，远端节点（$i=S_{\\ell}$）的电容为 $C_{S_{\\ell}} = c_{\\text{node}}/2$。\n\n**1.2. 半离散方程组**\n\nRC 梯形网络由 $S_{\\ell}$ 个电压未知的节点组成，标记为 $v_1, \\dots, v_{S_{\\ell}}$。输入节点 $v_0$ 由单位阶跃电压源驱动，即 $v_0(t)=1$ for $t \\ge 0$。在每个节点 $i$ 应用基尔霍夫电流定律，得到一个一阶常微分方程（ODE）组：\n- 对于内部节点 $i \\in \\{1, \\dots, S_{\\ell}-1\\}$：\n$$C_i \\frac{\\mathrm{d}v_i}{\\mathrm{d}t} = \\frac{v_{i-1} - v_i}{r_{\\text{seg}}} - \\frac{v_i - v_{i+1}}{r_{\\text{seg}}}$$\n- 对于开路远端节点 $i = S_{\\ell}$：\n$$C_{S_{\\ell}} \\frac{\\mathrm{d}v_{S_{\\ell}}}{\\mathrm{d}t} = \\frac{v_{S_{\\ell}-1} - v_{S_{\\ell}}}{r_{\\text{seg}}}$$\n\n该系统可以写成矩阵形式：$\\mathbf{C} \\frac{\\mathrm{d}\\mathbf{v}}{\\mathrm{d}t} = -\\mathbf{K}\\mathbf{v} + \\mathbf{b}$，其中 $\\mathbf{v} = [v_1, \\dots, v_{S_{\\ell}}]^T$，$\\mathbf{C}$ 是节点电容的对角矩阵，$\\mathbf{K}$ 是对称正定电导矩阵，$\\mathbf{b}$ 是来自输入 $v_0$ 的源向量。\n\n**1.3. 时间积分**\n\n该 ODE 系统使用后向欧拉法进行时间积分，该方法是无条件稳定的，因此适用于可能存在的刚性 RC 网络。时域被离散为 $M_{\\ell} = M_{0} 2^{\\ell}$ 个时间步，步长为 $\\Delta t_{\\ell} = T_{\\max} / M_{\\ell}$。选择仿真时域 $T_{\\max} = \\alpha r' c' L^2$ 足够长，以观察到延迟，其中 $r' = \\rho/(WT)$ 和 $c' = \\varepsilon W_{\\text{eff}}/h$。\n\n从时间步 $k$ 到 $k+1$ 的后向欧拉更新由下式给出：\n$$\\mathbf{C} \\frac{\\mathbf{v}^{k+1} - \\mathbf{v}^k}{\\Delta t_{\\ell}} = -\\mathbf{K}\\mathbf{v}^{k+1} + \\mathbf{b}$$\n重新整理后，得到在每个时间步求解 $\\mathbf{v}^{k+1}$ 的线性系统：\n$$(\\mathbf{C} + \\Delta t_{\\ell} \\mathbf{K}) \\mathbf{v}^{k+1} = \\mathbf{C}\\mathbf{v}^k + \\Delta t_{\\ell} \\mathbf{b}$$\n从初始条件 $\\mathbf{v}^0 = \\mathbf{0}$ 开始，我们迭代此方程。矩阵 $\\mathbf{A}_{\\text{BE}} = \\mathbf{C} + \\Delta t_{\\ell} \\mathbf{K}$ 是三对角的，因此该系统可以用 $O(S_{\\ell})$ 的运算量高效求解。\n\n关注量 $P_{\\ell}(W,T)$ 是远端节点电压 $v_{S_{\\ell}}(t)$ 首次达到阈值 $v^{\\star}=0.5$ 的时间。如果 $v_{S_{\\ell}}$ 在时间步 $k$ 和 $k+1$ 之间穿过阈值，则延迟通过线性插值计算。\n\n### 2. 多层蒙特卡洛 (MLMC) 估计器\n\n目标是计算 $\\mathbb{E}[Y_L]$，其中 $Y_\\ell = P_\\ell(W,T)$ 是在层级 $\\ell$ 计算的延迟，$L=L_{\\max}$ 是最精细的层级。MLMC 基于伸缩和：\n$$\\mathbb{E}[Y_L] = \\mathbb{E}[Y_0] + \\sum_{\\ell=1}^{L} \\mathbb{E}[Y_\\ell - Y_{\\ell-1}]$$\n$\\mathbb{E}[Y_L]$ 的 MLMC 估计器 $\\hat{Y}_{L}^{\\text{MLMC}}$ 为：\n$$\\hat{Y}_{L}^{\\text{MLMC}} = \\frac{1}{K_0}\\sum_{i=1}^{K_0} Y_0^{(i)} + \\sum_{\\ell=1}^{L} \\frac{1}{K_\\ell}\\sum_{i=1}^{K_\\ell} (Y_\\ell^{(i)} - Y_{\\ell-1}^{(i)})$$\n这里，$K_\\ell$ 是层级 $\\ell$ 的蒙特卡洛样本数。关键在于耦合：对于层级 $\\ell \\ge 1$ 的求和中的每个样本 $i$，计算 $Y_\\ell^{(i)}$ 和 $Y_{\\ell-1}^{(i)}$ 时使用相同的随机输入 $(W^{(i)}, T^{(i)})$。这确保了差值的方差 $V_\\ell = \\text{Var}[Y_\\ell - Y_{\\ell-1}]$ 随着层级 $\\ell$ 的增加而减小。\n\n**2.1. 最优样本分配**\n\n估计器的总均方误差 (MSE) 为 $\\text{MSE} = \\text{Var}[\\hat{Y}_{L}^{\\text{MLMC}}] + (\\text{Bias})^2 \\le \\varepsilon^2$，其中 $\\varepsilon$ 是期望的均方根误差。方差为 $\\text{Var}[\\hat{Y}_{L}^{\\text{MLMC}}] = \\sum_{\\ell=0}^{L} V_\\ell/K_\\ell$，其中 $V_0 = \\text{Var}[Y_0]$。偏差是由层级 $L$ 的有限离散化引起的。\n\n我们将一半的误差预算分配给方差，即 $\\sum_{\\ell=0}^{L} V_\\ell/K_\\ell \\le \\varepsilon^2/2$。选择每个层级的样本数 $K_\\ell$ 以最小化总计算成本 $\\sum_{\\ell=0}^{L} K_\\ell C_\\ell$，其中 $C_\\ell \\propto S_\\ell M_\\ell$ 是层级 $\\ell$ 上每个样本的成本。最优样本数由下式给出：\n$$K_\\ell = \\left\\lceil \\frac{2}{\\varepsilon^2} \\left(\\sum_{k=0}^{L} \\sqrt{V_k C_k}\\right) \\sqrt{\\frac{V_\\ell}{C_\\ell}} \\right\\rceil$$\n\n**2.2. 算法**\n\n实际算法流程如下：\n1.  **引导阶段**：在所有层级 $\\ell=0, \\dots, L$ 上模拟少量样本 ($K_{\\text{pilot}}$)。这用于获得均值 $\\mathbb{E}[Y_\\ell - Y_{\\ell-1}]$ 和方差 $V_\\ell$ 的初始估计。成本 $C_\\ell = S_\\ell M_\\ell$ 是先验已知的。\n2.  **样本分配**：使用 $V_\\ell$ 的引导估计和已知的成本 $C_\\ell$，根据上述公式计算每个层级的最优样本数 $K_\\ell$。\n3.  **主模拟**：对于每个层级 $\\ell$，运行额外的模拟，直到总样本数达到 $K_\\ell$。计算 $Y_0$ 的样本均值和差值 $(Y_\\ell - Y_{\\ell-1})$ 的样本均值。\n4.  **最终估计**：根据伸缩和公式，将上一步计算出的样本均值相加，得到最终的 MLMC 估计。\n\n随机输入 $W$ 和 $T$ 是通过拒绝采样从截断正态分布中抽取的，以确保它们在物理上是现实的（$W \\ge w_{\\min}, T \\ge t_{\\min}$）。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\nfrom math import pi\n\ndef solve():\n    \"\"\"\n    Main function to solve the VLSI delay estimation problem for all test cases.\n    \"\"\"\n    # Physical and numerical constants\n    EPS0 = 8.8541878128e-12\n    V_STAR = 0.5\n    ALPHA = 10.0\n    N0 = 8\n    M0 = 80\n    L_MAX = 3\n    \n    test_cases = [\n        # Case A\n        {\n            'L': 5.0e-4, 'h': 2.0e-7, 'rho': 1.68e-8, 'eps_r': 3.9,\n            'mu_W': 1.2e-7, 'sigma_W': 1.2e-8,\n            'mu_T': 6.0e-8, 'sigma_T': 8.0e-9,\n            'mlmc_tol': 1.0e-12\n        },\n        # Case B\n        {\n            'L': 5.0e-4, 'h': 2.0e-7, 'rho': 1.68e-8, 'eps_r': 3.9,\n            'mu_W': 1.2e-7, 'sigma_W': 1.2e-8,\n            'mu_T': 4.0e-8, 'sigma_T': 6.0e-9,\n            'mlmc_tol': 1.5e-12\n        },\n        # Case C\n        {\n            'L': 5.0e-4, 'h': 2.0e-7, 'rho': 1.68e-8, 'eps_r': 2.5,\n            'mu_W': 1.2e-7, 'sigma_W': 1.2e-8,\n            'mu_T': 6.0e-8, 'sigma_T': 8.0e-9,\n            'mlmc_tol': 1.0e-12\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        # Add constants to the parameter dictionary\n        params.update({'v_star': V_STAR, 'alpha': ALPHA, 'N0': N0, 'M0': M0, 'eps0': EPS0})\n        result = mlmc_estimator(params, L_MAX)\n        results.append(result)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef generate_wt_sample(params, rng):\n    \"\"\"\n    Generates a sample of (W, T) using rejection sampling from a truncated normal distribution.\n    \"\"\"\n    mu_W, sigma_W = params['mu_W'], params['sigma_W']\n    w_min = mu_W / 3.0\n    while True:\n        W = rng.normal(mu_W, sigma_W)\n        if W >= w_min:\n            break\n            \n    mu_T, sigma_T = params['mu_T'], params['sigma_T']\n    t_min = mu_T / 3.0\n    while True:\n        T = rng.normal(mu_T, sigma_T)\n        if T >= t_min:\n            break\n            \n    return W, T\n\ndef compute_delay(params, W, T, level):\n    \"\"\"\n    Computes the signal delay for a single sample (W, T) at a given discretization level.\n    \"\"\"\n    S_l = params['N0'] * (2**level)\n    M_l = params['M0'] * (2**level)\n    \n    eps = params['eps0'] * params['eps_r']\n    W_eff = W + 2 * params['h'] / pi\n    \n    r_prime = params['rho'] / (W * T)\n    c_prime = eps * W_eff / params['h']\n    \n    delta_x = params['L'] / S_l\n    r_seg = r_prime * delta_x\n    c_node = c_prime * delta_x\n    \n    T_max = params['alpha'] * r_prime * c_prime * params['L']**2\n    delta_t = T_max / M_l\n    \n    if r_seg == 0 or c_node == 0: return 0.0\n    g = 1.0 / r_seg\n\n    # Coefficients for the backward Euler tridiagonal system\n    k1 = delta_t * g / c_node\n    k2 = delta_t * g / (c_node / 2.0)\n    \n    # SciPy's banded solver format: ab[u+i-j, j] = A[i,j]\n    # For u=1, l=1: ab[0,:]=super, ab[1,:]=main, ab[2,:]=sub\n    ab = np.zeros((3, S_l))\n    # Super-diagonal (A[i, i+1]) -> ab[0, i+1]\n    ab[0, 1:] = -k1\n    # Main-diagonal (A[i, i]) -> ab[1, i]\n    ab[1, 0:S_l-1] = 1.0 + 2.0 * k1\n    ab[1, S_l-1] = 1.0 + k2\n    # Sub-diagonal (A[i+1, i]) -> ab[2, i]\n    ab[2, 0:S_l-2] = -k1\n    if S_l > 1:\n        ab[2, S_l-2] = -k2 # A[S_l-1, S_l-2] = -k2\n\n    # Time stepping\n    v = np.zeros(S_l)\n    \n    for k in range(int(M_l)):\n        v_old = v.copy()\n        \n        rhs = v_old\n        rhs[0] += k1 # Add source term\n        \n        v = solve_banded((1, 1), ab, rhs, check_finite=False)\n        \n        if v[-1] >= params['v_star']:\n            v_far_end_old = v_old[-1]\n            v_far_end_new = v[-1]\n            \n            t_old = k * delta_t\n            t_new = (k + 1) * delta_t\n\n            if v_far_end_new == v_far_end_old: return t_new\n            \n            delay = t_old + (t_new - t_old) * (params['v_star'] - v_far_end_old) / (v_far_end_new - v_far_end_old)\n            return delay\n\n    return T_max # Should not be reached with adequate alpha\n\ndef mlmc_estimator(params, L_max):\n    \"\"\"\n    Implements the Multilevel Monte Carlo estimator for a given test case.\n    \"\"\"\n    K_pilot = 200\n    eps = params['mlmc_tol']\n    rng = np.random.default_rng(seed=12345)\n\n    # --- Pilot Stage ---\n    means = [0.0] * (L_max + 1)\n    variances = [0.0] * (L_max + 1)\n    costs = [0.0] * (L_max + 1)\n\n    Y_samples = [np.zeros(K_pilot) for _ in range(L_max + 1)]\n    for i in range(K_pilot):\n        W, T = generate_wt_sample(params, rng)\n        for l in range(L_max + 1):\n            Y_samples[l][i] = compute_delay(params, W, T, l)\n\n    for l in range(L_max + 1):\n        if l == 0:\n            diff_samples = Y_samples[0]\n        else:\n            diff_samples = Y_samples[l] - Y_samples[l-1]\n        \n        means[l] = np.mean(diff_samples)\n        variances[l] = np.var(diff_samples)\n        S_l = params['N0'] * (2**l)\n        M_l = params['M0'] * (2**l)\n        costs[l] = float(S_l * M_l)\n\n    # --- Sample Allocation ---\n    optimal_K = [0] * (L_max + 1)\n    sum_sqrt_V_C = sum(np.sqrt(variances[l] * costs[l]) for l in range(L_max + 1) if variances[l] > 0)\n    \n    for l in range(L_max + 1):\n        if variances[l] > 1e-30: # If variance is non-negligible\n            num = 2.0 / (eps**2) * sum_sqrt_V_C * np.sqrt(variances[l] / costs[l])\n            optimal_K[l] = int(np.ceil(num))\n        else:\n            optimal_K[l] = 0\n    \n    # --- Main Simulation ---\n    final_estimate = 0.0\n    for l in range(L_max + 1):\n        K_l = optimal_K[l]\n        if K_l  2 and variances[l] > 1e-30:\n            K_l = 2\n        \n        # If variance is zero, the pilot mean is exact for the difference term\n        if K_l == 0:\n            final_estimate += means[l]\n            continue\n\n        sum_of_diffs = 0.0\n        for _ in range(K_l):\n            W, T = generate_wt_sample(params, rng)\n            y_fine = compute_delay(params, W, T, l)\n            if l == 0:\n                y_coarse = 0.0\n            else:\n                y_coarse = compute_delay(params, W, T, l-1)\n            sum_of_diffs += y_fine - y_coarse\n        \n        final_estimate += sum_of_diffs / K_l\n        \n    return final_estimate\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2416335"}]}