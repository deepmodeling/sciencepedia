{"hands_on_practices": [{"introduction": "在编写复杂的数值代码之前，通过手动计算来理解算法的核心机制至关重要。这个练习提供了一个小规模、可控的问题，让你亲手执行一步加性 Schwarz 迭代，并将其效果与经典的 Jacobi 迭代进行直接比较。通过这个实践 [@problem_id:2552509]，你将具体地体会到限制与延拓算子、子区域求解以及修正量如何组合在一起，并直观地理解为何 Schwarz 方法通常比简单的迭代法收敛更快。", "problem": "考虑在区间 $[0,6]$ 上的标量扩散问题 $-u''=f$，其齐次 Dirichlet 边界条件为 $u(0)=u(6)=0$。使用步长为 $h=1$ 的均匀网格上的连续分片线性有限元进行离散化，使得在 5 个内部节点 $\\{1,2,3,4,5\\}$ 上组装得到的对称正定 (SPD) 刚度矩阵 $A\\in\\mathbb{R}^{5\\times 5}$ 是一个标准的三对角矩阵，其对角线上元素为 2，第一亚对角线和第一超对角线上元素为 -1。设右端项为向量 $b=e_{3}\\in\\mathbb{R}^{5}$，其中 $e_{3}$ 是在节点 3 处为 1，其余位置为 0 的单位向量，并从初始猜测 $u^{0}=0$ 开始。\n\n定义一个包含三个子区域的重叠区域分解，其子区域索引集为\n- $\\Omega_{1}=\\{1,2,3\\}$，\n- $\\Omega_{2}=\\{3,4,5\\}$，\n- $\\Omega_{3}=\\{2,3,4\\}$。\n\n对每个子区域 $\\Omega_{i}$，设 $R_{i}\\in\\mathbb{R}^{3\\times 5}$ 是按自然顺序提取 $\\Omega_{i}$ 上分量的布尔限制算子，并设局部算子为 $A_{i}=R_{i}AR_{i}^{\\top}\\in\\mathbb{R}^{3\\times 3}$。考虑经典单层加性 Schwarz 稳定迭代（使用简单注入，无单位分解加权），\n$$\nu^{k+1}=u^{k}+\\sum_{i=1}^{3}R_{i}^{\\top}A_{i}^{-1}R_{i}\\,\\bigl(b-Au^{k}\\bigr),\n$$\n以及全局系统上的 Jacobi 迭代，\n$$\nu^{k+1}=u^{k}+D^{-1}\\bigl(b-Au^{k}\\bigr),\n$$\n其中 $D=\\operatorname{diag}(A)$ 是 $A$ 的对角部分。使用 $u^{0}=0$，对每种方法执行一次迭代以获得 $u_{\\mathrm{AS}}^{1}$ 和 $u_{\\mathrm{J}}^{1}$，并计算相应残差的欧几里得范数之比，\n$$\n\\frac{\\|b-Au_{\\mathrm{AS}}^{1}\\|_{2}}{\\|b-Au_{\\mathrm{J}}^{1}\\|_{2}}.\n$$\n\n请以单一精确表达式（无四舍五入，无小数）的形式给出答案。", "solution": "该问题是数值线性代数中一个良构的练习题，具体涉及由微分方程的有限元离散化所产生的线性系统的迭代方法。该问题具有科学依据，定义形式严谨，并包含了进行求解所需的所有信息。不存在不一致之处或无效前提。我们着手进行计算。\n\n全局刚度矩阵 $A \\in \\mathbb{R}^{5\\times 5}$ 和右端向量 $b \\in \\mathbb{R}^{5}$ 如下所示：\n$$\nA = \\begin{pmatrix} 2 & -1 & 0 & 0 & 0 \\\\ -1 & 2 & -1 & 0 & 0 \\\\ 0 & -1 & 2 & -1 & 0 \\\\ 0 & 0 & -1 & 2 & -1 \\\\ 0 & 0 & 0 & -1 & 2 \\end{pmatrix}, \\quad b = e_{3} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n初始猜测为 $u^{0} = 0 \\in \\mathbb{R}^{5}$。\n\n首先，我们计算 Jacobi 方法的一次迭代。Jacobi 迭代定义为 $u^{k+1} = u^{k} + D^{-1}(b - Au^{k})$，其中 $D = \\operatorname{diag}(A)$。\n对于第一次迭代，当 $k=0$ 且 $u^{0} = 0$ 时，我们有：\n$$\nu_{\\mathrm{J}}^{1} = u^{0} + D^{-1}(b - Au^{0}) = D^{-1}b\n$$\n$A$ 的对角部分是 $D = \\operatorname{diag}(2, 2, 2, 2, 2) = 2I$，其中 $I$ 是 $5 \\times 5$ 的单位矩阵。因此，其逆矩阵为 $D^{-1} = \\frac{1}{2}I$。\n第一次 Jacobi 迭代的结果是：\n$$\nu_{\\mathrm{J}}^{1} = \\frac{1}{2}I b = \\frac{1}{2}b = \\frac{1}{2}e_{3} = \\begin{pmatrix} 0 \\\\ 0 \\\\ \\frac{1}{2} \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n对应的残差是 $r_{\\mathrm{J}}^{1} = b - Au_{\\mathrm{J}}^{1}$。我们首先计算 $Au_{\\mathrm{J}}^{1}$：\n$$\nA u_{\\mathrm{J}}^{1} = A \\left(\\frac{1}{2}e_{3}\\right) = \\frac{1}{2} (A e_{3}) = \\frac{1}{2} \\begin{pmatrix} 0 \\\\ -1 \\\\ 2 \\\\ -1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ -\\frac{1}{2} \\\\ 1 \\\\ -\\frac{1}{2} \\\\ 0 \\end{pmatrix}\n$$\n于是残差为：\n$$\nr_{\\mathrm{J}}^{1} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 0 \\\\ -\\frac{1}{2} \\\\ 1 \\\\ -\\frac{1}{2} \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ \\frac{1}{2} \\\\ 0 \\\\ \\frac{1}{2} \\\\ 0 \\end{pmatrix}\n$$\nJacobi 残差的欧几里得范数是：\n$$\n\\|r_{\\mathrm{J}}^{1}\\|_{2} = \\left\\| \\begin{pmatrix} 0 \\\\ \\frac{1}{2} \\\\ 0 \\\\ \\frac{1}{2} \\\\ 0 \\end{pmatrix} \\right\\|_{2} = \\sqrt{0^{2} + \\left(\\frac{1}{2}\\right)^{2} + 0^{2} + \\left(\\frac{1}{2}\\right)^{2} + 0^{2}} = \\sqrt{\\frac{1}{4} + \\frac{1}{4}} = \\sqrt{\\frac{1}{2}}\n$$\n\n接下来，我们计算单层加性 Schwarz 方法的一次迭代。迭代公式为 $u^{k+1} = u^{k} + \\sum_{i=1}^{3} R_{i}^{\\top}A_{i}^{-1}R_{i}\\,(b - Au^{k})$。\n对于第一次迭代，当 $k=0$ 且 $u^{0}=0$ 时，我们有：\n$$\nu_{\\mathrm{AS}}^{1} = \\sum_{i=1}^{3} R_{i}^{\\top}A_{i}^{-1}R_{i}b\n$$\n我们分析每个子区域的贡献。局部矩阵为 $A_{i} = R_{i}AR_{i}^{\\top}$。对于子区域 $\\Omega_{1} = \\{1,2,3\\}$、$\\Omega_{2} = \\{3,4,5\\}$ 和 $\\Omega_{3} = \\{2,3,4\\}$，相应的局部刚度矩阵是 $A$ 的主子矩阵：\n$$\nA_{1} = A_{2} = A_{3} = \\begin{pmatrix} 2 & -1 & 0 \\\\ -1 & 2 & -1 \\\\ 0 & -1 & 2 \\end{pmatrix}\n$$\n需要求该矩阵的逆。其行列式为 $\\det(A_{1}) = 2(2 \\cdot 2 - (-1)(-1)) - (-1)(-1 \\cdot 2 - 0) = 2(3) - 2 = 4$。逆矩阵为：\n$$\nA_{1}^{-1} = A_{2}^{-1} = A_{3}^{-1} = \\frac{1}{4} \\begin{pmatrix} 3 & 2 & 1 \\\\ 2 & 4 & 2 \\\\ 1 & 2 & 3 \\end{pmatrix}\n$$\n现在我们计算局部求解。将右端项 $b=e_{3}$ 限制到每个子区域上，得到局部向量 $b_{i} = R_{i}b$：\n$$\nb_{1} = R_{1}b = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}, \\quad b_{2} = R_{2}b = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad b_{3} = R_{3}b = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}\n$$\n局部解为 $w_{i} = A_{i}^{-1}b_{i}$：\n$$\nw_{1} = A_{1}^{-1}b_{1} = \\frac{1}{4} \\begin{pmatrix} 3 & 2 & 1 \\\\ 2 & 4 & 2 \\\\ 1 & 2 & 3 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\frac{1}{4} \\begin{pmatrix} 1 \\\\ 2 \\\\ 3 \\end{pmatrix}\n$$\n$$\nw_{2} = A_{2}^{-1}b_{2} = \\frac{1}{4} \\begin{pmatrix} 3 & 2 & 1 \\\\ 2 & 4 & 2 \\\\ 1 & 2 & 3 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\frac{1}{4} \\begin{pmatrix} 3 \\\\ 2 \\\\ 1 \\end{pmatrix}\n$$\n$$\nw_{3} = A_{3}^{-1}b_{3} = \\frac{1}{4} \\begin{pmatrix} 3 & 2 & 1 \\\\ 2 & 4 & 2 \\\\ 1 & 2 & 3 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} = \\frac{1}{4} \\begin{pmatrix} 2 \\\\ 4 \\\\ 2 \\end{pmatrix}\n$$\n将这些局部解使用 $R_{i}^{\\top}$ 扩展回全局向量空间并求和，得到第一次加性 Schwarz 迭代的结果：\n$$\nu_{\\mathrm{AS}}^{1} = R_{1}^{\\top}w_{1} + R_{2}^{\\top}w_{2} + R_{3}^{\\top}w_{3} = \\frac{1}{4}\\begin{pmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 0 \\\\ 0 \\end{pmatrix} + \\frac{1}{4}\\begin{pmatrix} 0 \\\\ 0 \\\\ 3 \\\\ 2 \\\\ 1 \\end{pmatrix} + \\frac{1}{4}\\begin{pmatrix} 0 \\\\ 2 \\\\ 4 \\\\ 2 \\\\ 0 \\end{pmatrix} = \\frac{1}{4}\\begin{pmatrix} 1 \\\\ 4 \\\\ 10 \\\\ 4 \\\\ 1 \\end{pmatrix}\n$$\n相应的残差是 $r_{\\mathrm{AS}}^{1} = b - Au_{\\mathrm{AS}}^{1}$。我们首先计算 $Au_{\\mathrm{AS}}^{1}$：\n$$\nAu_{\\mathrm{AS}}^{1} = \\frac{1}{4} \\begin{pmatrix} 2 & -1 & 0 & 0 & 0 \\\\ -1 & 2 & -1 & 0 & 0 \\\\ 0 & -1 & 2 & -1 & 0 \\\\ 0 & 0 & -1 & 2 & -1 \\\\ 0 & 0 & 0 & -1 & 2 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 4 \\\\ 10 \\\\ 4 \\\\ 1 \\end{pmatrix} = \\frac{1}{4} \\begin{pmatrix} 2-4 \\\\ -1+8-10 \\\\ -4+20-4 \\\\ -10+8-1 \\\\ -4+2 \\end{pmatrix} = \\frac{1}{4} \\begin{pmatrix} -2 \\\\ -3 \\\\ 12 \\\\ -3 \\\\ -2 \\end{pmatrix} = \\begin{pmatrix} -1/2 \\\\ -3/4 \\\\ 3 \\\\ -3/4 \\\\ -1/2 \\end{pmatrix}\n$$\n于是残差为：\n$$\nr_{\\mathrm{AS}}^{1} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} -1/2 \\\\ -3/4 \\\\ 3 \\\\ -3/4 \\\\ -1/2 \\end{pmatrix} = \\begin{pmatrix} 1/2 \\\\ 3/4 \\\\ -2 \\\\ 3/4 \\\\ 1/2 \\end{pmatrix}\n$$\n加性 Schwarz 残差的欧几里得范数是：\n$$\n\\|r_{\\mathrm{AS}}^{1}\\|_{2} = \\sqrt{\\left(\\frac{1}{2}\\right)^{2} + \\left(\\frac{3}{4}\\right)^{2} + (-2)^{2} + \\left(\\frac{3}{4}\\right)^{2} + \\left(\\frac{1}{2}\\right)^{2}} = \\sqrt{\\frac{1}{4} + \\frac{9}{16} + 4 + \\frac{9}{16} + \\frac{1}{4}}\n$$\n$$\n\\|r_{\\mathrm{AS}}^{1}\\|_{2} = \\sqrt{2\\left(\\frac{1}{4}\\right) + 2\\left(\\frac{9}{16}\\right) + 4} = \\sqrt{\\frac{1}{2} + \\frac{9}{8} + 4} = \\sqrt{\\frac{4}{8} + \\frac{9}{8} + \\frac{32}{8}} = \\sqrt{\\frac{45}{8}} = \\frac{3\\sqrt{5}}{2\\sqrt{2}} = \\frac{3\\sqrt{10}}{4}\n$$\n最后，我们计算所需的残差范数之比：\n$$\n\\frac{\\|b-Au_{\\mathrm{AS}}^{1}\\|_{2}}{\\|b-Au_{\\mathrm{J}}^{1}\\|_{2}} = \\frac{\\|r_{\\mathrm{AS}}^{1}\\|_{2}}{\\|r_{\\mathrm{J}}^{1}\\|_{2}} = \\frac{\\frac{3\\sqrt{10}}{4}}{\\sqrt{\\frac{1}{2}}} = \\frac{3\\sqrt{10}}{4} \\cdot \\sqrt{2} = \\frac{3\\sqrt{20}}{4} = \\frac{3 \\cdot 2\\sqrt{5}}{4} = \\frac{6\\sqrt{5}}{4} = \\frac{3\\sqrt{5}}{2}\n$$", "answer": "$$\n\\boxed{\\frac{3\\sqrt{5}}{2}}\n$$", "id": "2552509"}, {"introduction": "理论模型中的区域划分往往是理想化的直线，但现实世界工程问题的几何形状要复杂得多。本练习将引导你从纸笔计算过渡到数值实验，通过编写代码来研究一个关键的实际问题：子区域边界的几何形状（例如，其曲率和频率）如何影响乘性 Schwarz 方法的收敛性能 [@problem_id:2387021]。这个实践不仅能锻炼你的编程能力，还能让你深入理解算法性能与问题几何特征之间的联系，架起从教科书示例到应用研究的桥梁。", "problem": "考虑应用于单位正方形上标量泊松方程的经典重叠型Schwarz方法。设区域为 $\\Omega = [0,1]\\times[0,1]$，并考虑如下边值问题\n$$\n-\\Delta u = f \\quad \\text{在 } \\Omega \\text{内},\\qquad u = 0 \\quad \\text{在 } \\partial\\Omega \\text{上},\n$$\n其中右端项 $f$ 是一个光滑函数。在区域分解中，计算区域被一个人工界面分割成两个重叠的子区域。在经典设置中，该界面是一条直线；此处，人工界面被允许为由正弦波定义的光滑曲线。乘法Schwarz迭代顺序求解子问题，并在人工界面上使用取自最近迭代解的狄利克雷传输条件。您的任务是数值研究人工界面的曲率如何影响收敛性。\n\n实现以下规范。\n\n- 离散化。使用一个包含 $N\\times N$ 个内部点的均匀笛卡尔网格覆盖 $\\Omega$，两个方向的网格尺寸均为 $h = \\frac{1}{N+1}$，并对拉普拉斯算子使用标准的5点有限差分格式。在 $\\partial\\Omega$ 上使用齐次狄利克雷边界条件。设所有内部网格点上的右端项为 $f(x,y) = 1$。\n\n- 人工界面和子区域。对于给定的振幅 $A \\ge 0$ 和整数频率 $m \\ge 0$，将人工界面定义为图\n$$\nx_\\Gamma(y) = \\tfrac{1}{2} + A \\sin\\!\\big(2\\pi m\\, y\\big), \\quad y\\in[0,1]。\n$$\n设重叠宽度为 $\\delta = p\\,h$，其中 $p$ 是一个非负整数。在网格上定义重叠子区域如下：\n    - 左子区域：坐标为 $(x_i,y_j)$ 且满足 $x_i \\le x_\\Gamma(y_j) + \\delta$ 的网格点，\n    - 右子区域：坐标为 $(x_i,y_j)$ 且满足 $x_i \\ge x_\\Gamma(y_j) - \\delta$ 的网格点。\n两个子区域在两个不等式均成立的网格点集合上重叠。\n\n- 乘法Schwarz迭代。将全局内部网格函数 $u^{(0)}$ 初始化为零。对于迭代 $k = 0,1,2,\\dots$：\n    1. 在左子区域上求解离散泊松问题，其狄利克雷数据取自当前全局迭代解 $u^{(k)}$ 在所有位于左子区域外的邻点上的值（并在物理边界上取零）。用这个左子区域的解覆盖所有左子区域点上的全局迭代解。\n    2. 在右子区域上求解离散泊松问题，其狄利克雷数据取自当前全局迭代解（它包含了刚更新的左子区域值）在所有位于右子区域外的邻点上的值（并在物理边界上取零）。用这个右子区域的解覆盖所有右子区域点上的全局迭代解。\n每个子区域的求解相对于离散算子是精确的（即，通过直接线性求解器求解至机器精度）。\n\n- 收敛性度量。在每次完整的Schwarz迭代后（即在两个子区域都求解之后），计算所有内部点上的全局离散残差 $r^{(k)} = f - L_h u^{(k)}$，其中 $L_h$是带有齐次狄利克雷边界值的5点离散拉普拉斯算子。设 $\\|r^{(k)}\\|_2$ 表示其欧几里得范数。将观测到的渐近收缩因子 $q$ 定义为在终止前的最后 $K$ 次可用迭代中比率 $\\|r^{(k+1)}\\|_2 / \\|r^{(k)}\\|_2$ 的几何平均值，其中 $K = \\min(5, \\text{已完成的迭代次数})$。当相对残差 $\\|r^{(k)}\\|_2 / \\|f\\|_2$ 低于 $10^{-8}$ 或已完成 $50$ 次迭代时终止迭代，以先发生者为准。\n\n- 网格分辨率。在每个空间方向上使用 $N = 40$ 个内部点。\n\n您的任务是编写一个完整的程序来实现上述规范，并通过改变界面定义中的振幅 $A$ 和频率 $m$，同时保持重叠宽度 $\\delta$ 在网格单位下固定，来报告曲率如何影响收敛性。\n\n测试套件。在以下参数集 $(A,m,p)$ 上运行程序：\n    - 情况1：$(0.0, 0, 3)$，位于 $x=\\tfrac{1}{2}$ 的直线界面，重叠3个网格单元，\n    - 情况2：$(0.1, 1, 3)$，振幅为 $0.1$、频率为 $1$ 的正弦波界面，重叠3个网格单元，\n    - 情况3：$(0.15, 2, 3)$，振幅为 $0.15$、频率为 $2$ 的正弦波界面，重叠3个网格单元，\n    - 情况4：$(0.1, 4, 3)$，振幅为 $0.1$、频率为 $4$ 的正弦波界面，重叠3个网格单元。\n\n要求的最终输出格式。您的程序应生成单行输出，包含四种情况下观测到的渐近收缩因子 $q$，按情况1到情况4的顺序，四舍五入到4位小数，格式为一个由方括号括起来的逗号分隔列表，例如 `[q_1,q_2,q_3,q_4]`。不应打印任何其他文本。此问题不涉及任何物理单位，也未报告任何角度；所有三角函数的参数均被理解为无量纲。", "solution": "所提出的问题是计算工程领域一个有效且定义明确的数值实验。它在科学上植根于偏微分方程和数值方法的理论，特别是区域分解技术。所有参数、条件和目标都已明确规定，从而可以得到唯一且可验证的解。我将着手提供一个完整的解决方案。\n\n该问题要求对单位正方形 $\\Omega = [0,1]\\times[0,1]$ 上的二维泊松问题的乘法Schwarz方法的收敛行为进行数值研究。收敛性将作为分隔两个子区域的人工界面的几何形状的函数来研究。\n\n控制偏微分方程为：\n$$-\\Delta u = f \\quad \\text{在 } \\Omega \\text{内}$$\n边界条件为齐次狄利克雷边界条件 $u=0$ on $\\partial\\Omega$，右端项为常数 $f(x,y)=1$。\n\n首先，我们离散化区域和算子。使用一个在每个方向上有 $N=40$ 个内部点的均匀笛卡尔网格对区域 $\\Omega$ 进行离散化。网格尺寸为 $h = \\frac{1}{N+1}$。网格点为 $(x_i, y_j) = (ih, jh)$，其中 $i,j = 1, \\dots, N$。未知数 $u(x_i, y_j)$ 记为 $u_{i,j}$。对负拉普拉斯算子 $-\\Delta_h$ 使用标准的五点有限差分格式，我们在每个内部网格点 $(i,j)$ 得到离散方程：\n$$ \\frac{1}{h^2} (4u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1}) = f_{i,j} $$\n其中对于所有内部点 $f_{i,j}=1$。这 $N^2$ 个未知数通过行主序被排列成一个向量 $U \\in \\mathbb{R}^{N^2}$，其中点 $(i,j)$（在实现中 $i,j$ 从 0 开始）的全局索引 $k$ 为 $k = j \\cdot N + i$。这导出了一个形如 $L U = F$ 的大型、稀疏、对称正定线性系统，其中 $L \\in \\mathbb{R}^{N^2 \\times N^2}$ 是 $-\\Delta_h$ 的矩阵表示，而 $F \\in \\mathbb{R}^{N^2}$ 是代表离散化右端项的全一向量。\n\n区域被分解为由一条弯曲界面定义的两个重叠子区域 $\\Omega_1$（左）和 $\\Omega_2$（右）。界面由曲线 $x_\\Gamma(y) = \\frac{1}{2} + A \\sin(2\\pi m y)$ 给出。重叠宽度为 $\\delta = p h$。离散子区域由网格点索引集定义：\n$$ \\mathcal{I}_1 = \\{ k=j \\cdot N + i \\mid x_i \\le x_\\Gamma(y_j) + \\delta \\} $$\n$$ \\mathcal{I}_2 = \\{ k=j \\cdot N + i \\mid x_i \\ge x_\\Gamma(y_j) - \\delta \\} $$\n其中 $(x_i, y_j)$ 是对应于全局索引 $k$ 的网格点坐标。\n\n乘法Schwarz迭代过程如下，从初始猜测 $U^{(0)} = 0 \\in \\mathbb{R}^{N^2}$ 开始。对于每次迭代 $k=0, 1, 2, \\dots$：\n\n1.  **左子区域更新：** 我们在 $\\Omega_1$ 上求解问题，使用来自当前全局迭代解 $U^{(k)}$ 的狄利克雷数据。这是通过计算一个仅在 $\\Omega_1$ 上非零的校正量 $E_1$ 来实现的。该校正量通过求解系统 $L_1 E_1 = R_1^{(k)}$ 获得，其中 $L_1$ 是 $L$ 对应于索引 $\\mathcal{I}_1$ 的主子矩阵，而 $R_1^{(k)}$ 是全局残差 $R^{(k)} = F - L U^{(k)}$ 在索引 $\\mathcal{I}_1$ 上的限制。然后更新解以形成中间迭代解 $U^{(k+1/2)}$：\n    $$ U_j^{(k+1/2)} = \\begin{cases} U_j^{(k)} + (E_1)_j & \\text{对于 } j \\in \\mathcal{I}_1 \\\\ U_j^{(k)} & \\text{对于 } j \\notin \\mathcal{I}_1 \\end{cases} $$\n\n2.  **右子区域更新：** 类似地，我们在 $\\Omega_2$ 上求解，使用来自最新迭代解 $U^{(k+1/2)}$ 的狄利克雷数据。一个校正量 $E_2$（仅在 $\\Omega_2$ 上非零）通过求解 $L_2 E_2 = R_2^{(k+1/2)}$ 找到，其中 $L_2$ 是 $L$ 对应于索引 $\\mathcal{I}_2$ 的子矩阵，而 $R_2^{(k+1/2)}$ 是中间残差 $R^{(k+1/2)} = F - L U^{(k+1/2)}$ 在索引 $\\mathcal{I}_2$ 上的限制。此步骤的最终迭代解为：\n    $$ U_j^{(k+1)} = \\begin{cases} U_j^{(k+1/2)} + (E_2)_j & \\text{对于 } j \\in \\mathcal{I}_2 \\\\ U_j^{(k+1/2)} & \\text{对于 } j \\notin \\mathcal{I}_2 \\end{cases} $$\n\n按照规定，子区域线性系统使用直接稀疏LU分解精确求解。\n\n迭代持续进行，直到相对残差范数 $\\|R^{(k+1)}\\|_2 / \\|F\\|_2$ 小于 $10^{-8}$ 或达到最大50次迭代。渐近收缩因子 $q$ 通过最后 $K$ 次迭代的残差缩减因子 $\\|R^{(j+1)}\\|_2 / \\|R^{(j)}\\|_2$ 的几何平均值来估计，其中 $K = \\min(5, \\text{已完成的迭代次数})$。\n\n实现将包括一个主函数，该函数遍历指定的测试用例 $(A,m,p)$。对于每个用例，它将：\na. 构建全局系统矩阵 $L$ 和右端项向量 $F$。\nb. 根据界面参数确定索引集 $\\mathcal{I}_1$ 和 $\\mathcal{I}_2$。\nc. 提取并预分解子区域矩阵 $L_1$ 和 $L_2$。\nd. 执行乘法Schwarz迭代，记录所有残差范数。\ne. 在终止时计算收缩因子 $q$。\n\n最终输出是这些计算出的收缩因子的列表。这个数值实验将揭示Schwarz方法收敛速率对界面曲线振幅和频率的依赖性。预计更大的 $A$ 和 $m$ 导致的更高曲率和更长界面长度会降低收敛速率，从而导致更大的收缩因子 $q$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import splu\nimport math\n\ndef solve_case(params):\n    \"\"\"\n    Implements the multiplicative Schwarz method for a single parameter set.\n    \"\"\"\n    A, m, p = params\n    N = 40\n    MAX_ITER = 50\n    TOL = 1e-8\n\n    # 1. Discretization and System Setup\n    h = 1.0 / (N + 1)\n    \n    # Create global Laplacian matrix L for the operator -Delta_h\n    L = lil_matrix((N * N, N * N))\n    h2 = h * h\n    for j in range(N):\n        for i in range(N):\n            k = j * N + i\n            L[k, k] = 4.0 / h2\n            if i > 0:\n                L[k, k - 1] = -1.0 / h2\n            if i  N - 1:\n                L[k, k + 1] = -1.0 / h2\n            if j > 0:\n                L[k, k - N] = -1.0 / h2\n            if j  N - 1:\n                L[k, k + N] = -1.0 / h2\n    L = L.tocsc()\n\n    # Right-hand side vector F\n    F = np.ones(N * N)\n    f_norm = np.linalg.norm(F)\n\n    # 2. Artificial Interface and Subdomains\n    x_coords = np.linspace(h, 1.0 - h, N)\n    y_coords = np.linspace(h, 1.0 - h, N)\n    xg, yg = np.meshgrid(x_coords, y_coords)\n    \n    delta = p * h\n    x_gamma = 0.5 + A * np.sin(2 * math.pi * m * yg)\n    \n    mask1 = xg = x_gamma + delta\n    mask2 = xg = x_gamma - delta\n    \n    idx1 = np.where(mask1.flatten())[0]\n    idx2 = np.where(mask2.flatten())[0]\n\n    # 3. Subproblem Setup\n    L1 = L[idx1, :][:, idx1].tocsc()\n    L2 = L[idx2, :][:, idx2].tocsc()\n    \n    # Pre-factorize for repeated solves\n    lu_solver1 = splu(L1)\n    lu_solver2 = splu(L2)\n\n    # 4. Multiplicative Schwarz Iteration\n    u = np.zeros(N * N)\n    residual_ratios = []\n    \n    # Initial residual\n    r_old = F - L @ u\n    r_norm_old = np.linalg.norm(r_old)\n\n    for k in range(MAX_ITER):\n        # Step 1: Solve for left subdomain\n        r1 = r_old[idx1]\n        e1 = lu_solver1.solve(r1)\n        u[idx1] += e1\n        \n        # Intermediate residual for multiplicative update\n        r_intermediate = F - L @ u\n        \n        # Step 2: Solve for right subdomain\n        r2 = r_intermediate[idx2]\n        e2 = lu_solver2.solve(r2)\n        u[idx2] += e2\n        \n        # Compute new residual and norm\n        r_new = F - L @ u\n        r_norm_new = np.linalg.norm(r_new)\n        \n        if r_norm_old > 1e-15: # Avoid division by zero\n            residual_ratios.append(r_norm_new / r_norm_old)\n        \n        # Update for next iteration\n        r_old = r_new\n        r_norm_old = r_norm_new\n        \n        # Convergence check\n        if r_norm_new / f_norm  TOL:\n            break\n    \n    # 5. Convergence Metric Calculation\n    num_ratios = len(residual_ratios)\n    if num_ratios == 0:\n        return 0.0\n\n    K = min(5, num_ratios)\n    last_K_ratios = residual_ratios[-K:]\n    \n    # Geometric mean\n    q = np.prod(last_K_ratios)**(1.0 / K)\n    \n    return q\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Test cases: (A, m, p)\n    # A: amplitude, m: frequency, p: overlap in grid cells\n    test_cases = [\n        (0.0, 0, 3),   # Case 1\n        (0.1, 1, 3),   # Case 2\n        (0.15, 2, 3),  # Case 3\n        (0.1, 4, 3)    # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        q = solve_case(case)\n        results.append(np.round(q, 4))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2387021"}, {"introduction": "在求解大规模科学与工程计算问题时，精确求解各个子区域的问题往往成本过高，甚至是不可能的。这个练习引入了“非精确求解” (inexact solves) 的重要概念，即子区域问题本身也通过迭代法进行近似求解。这种“外迭代-内迭代”的嵌套模式是现代高性能计算中区域分解方法的核心 [@problem_id:2387028]。通过本练习，你将实现一个嵌套迭代格式，并探索在子区域求解上花费的计算量与全局方法收敛速度之间的权衡，从而洞察如何设计高效且可扩展的数值算法。", "problem": "考虑在单位区间上，对带齐次狄利克雷边界条件的一维泊松方程使用标准中心有限差分格式离散化后得到的线性系统。连续问题为 $-u''(x) = g(x)$，其中 $x \\in (0,1)$，且 $u(0) = 0$，$u(1) = 0$。将区间离散为 $N$ 个内部点，点间距均匀，为 $h = 1/(N+1)$，由此得到对称正定线性系统 $A u = f$。其中 $A \\in \\mathbb{R}^{N \\times N}$ 的主对角线元素为 $2/h^2$，第一副对角线和第一超对角线元素为 $-1/h^2$。$f \\in \\mathbb{R}^{N}$ 是离散化后的右端项。在整个问题中，设 $f$ 为所有分量均为 1 的常数向量（无量纲）。目标是采用带有非精确子区域求解的双子区域乘性 Schwarz 方法来求解 $A u = f$。\n\n将未知量集合划分为两个可能存在重叠的连续子区域。定义中点索引 $m = \\lfloor N/2 \\rfloor$。对于给定的非负整数重叠参数 $o$，定义索引集如下：\n$$\nI_1 = \\{0,1,\\dots,m+o-1\\}, \\quad I_2 = \\{m-o, m-o+1, \\dots, N-1\\},\n$$\n其中 $I_1$ 和 $I_2$ 需与 $\\{0,1,\\dots,N-1\\}$ 取交集，以确保索引在有效范围内。双子区域乘性 Schwarz 迭代定义如下：从一个全局迭代向量 $x^{(k)} \\in \\mathbb{R}^{N}$ 开始，依次执行\n$$\n\\text{在 } I_1 \\text{ 上求解}: \\quad A_{11} \\, \\delta x_1 = r_1, \\quad \\text{然后更新 } x_{I_1}^{(k+\\frac{1}{2})} = x_{I_1}^{(k)} + \\delta x_1,\n$$\n$$\n\\text{在 } I_2 \\text{ 上求解}: \\quad A_{22} \\, \\delta x_2 = r_2, \\quad \\text{然后更新 } x_{I_2}^{(k+1)} = x_{I_2}^{(k+\\frac{1}{2})} + \\delta x_2,\n$$\n其中 $A_{ii}$ 是 $A$ 限制在 $I_i$ 上的主子矩阵，$r_i$ 是限制残差，其定义为 $r_i = b_i - A_{i, I_i} x_{I_i}$，其中右端项 $b_i = f_{I_i} - A_{i, \\overline{I_i}} x_{\\overline{I_i}}$，包含了来自补集的固定值。这里，$A_{i, I_i}$ 表示 $A$ 中行索引和列索引均在 $I_i$ 内的块，而 $A_{i, \\overline{I_i}}$ 表示行索引在 $I_i$ 中而列索引在 $I_i$ 补集中的块。\n\n在本问题中，子区域求解不是精确的。而是通过对限制系统 $A_{ii} x_{I_i} = b_i$ 应用固定次数 $m_{\\text{in}} \\in \\mathbb{N}_0$ 的加权 Jacobi 迭代来非精确地执行，松弛权重为 $\\omega \\in (0,1)$。对 $A_{ii} x_{I_i} = b_i$ 的一次加权 Jacobi 扫描（迭代步）形式如下：\n$$\nx_{I_i}^{\\text{new}} = x_{I_i}^{\\text{old}} + \\omega D_{ii}^{-1} \\left(b_i - A_{ii} x_{I_i}^{\\text{old}}\\right),\n$$\n其中 $D_{ii}$ 是 $A_{ii}$ 的对角部分。每次子区域求解的初始猜测是全局迭代向量的当前子向量。经过 $m_{\\text{in}}$ 次扫描后，子区域子向量被注回到全局迭代向量中（覆盖该子区域上的分量）。一次完整的外迭代包含 $I_1$ 的更新和其后的 $I_2$ 的更新。\n\n定义全局残差 $r^{(k)} = f - A x^{(k)}$ 及其欧几里得范数 $\\|r^{(k)}\\|_2$。每次外迭代的观测收敛因子由几何平均值量化：\n$$\n\\rho_{\\text{obs}} = \\exp\\left( \\frac{1}{K} \\sum_{k=1}^{K} \\log \\frac{\\|r^{(k)}\\|_2}{\\|r^{(k-1)}\\|_2} \\right),\n$$\n从 $x^{(0)} = 0$ 开始，经过 $K$ 次外迭代计算得出。\n\n任务：实现一个程序，对于下方的每个测试用例，按所述方式构造 $A$ 和 $f$，将索引划分为两个重叠为 $o$ 的子区域，执行 $K$ 次带有非精确子区域求解的乘性 Schwarz 外迭代（其中子区域求解使用 $m_{\\text{in}}$ 次加权 Jacobi 扫描，松弛权重为 $\\omega$），并返回观测收敛因子 $\\rho_{\\text{obs}}$，结果四舍五入到六位小数。\n\n所有计算仅使用无量纲量。不涉及角度。无需报告物理单位。\n\n测试套件（每个元组为 $(N, o, m_{\\text{in}}, \\omega, K)$）：\n-   情况 1：$(127, 2, 0, 2/3, 20)$。\n-   情况 2：$(127, 2, 1, 2/3, 20)$。\n-   情况 3：$(127, 2, 3, 2/3, 20)$。\n-   情况 4：$(127, 0, 10, 2/3, 20)$。\n-   情况 5：$(63, 1, 2, 0.8, 20)$。\n\n最终输出格式：您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表，其中每个收敛因子都四舍五入到六位小数，不含任何额外文本，例如：“[0.950000,0.750000,0.500000]”。", "solution": "该问题已经过严格验证，并被确定为有效。它在计算工程和数值线性代数领域内是一个适定且有科学依据的问题。任务是分析一种针对特定线性系统的、带有非精确子区域求解的双子区域乘性 Schwarz 方法的收敛性。问题表述清晰，无歧义、矛盾或事实错误。现提供完整解法如下。\n\n该方法将按照问题陈述中推导出的精确步骤序列，通过算法实现。\n\n1.  **系统构建**：问题定义在一个一维域上，离散为 $N$ 个内部点，网格间距为 $h = 1/(N+1)$。这导出一个线性系统 $A u = f$。矩阵 $A \\in \\mathbb{R}^{N \\times N}$ 是一个对称正定矩阵，表示负二阶导数算子的中心有限差分近似。它是一个三对角矩阵，其元素为：\n    $$\n    A_{ij} =\n    \\begin{cases}\n    2/h^2  \\text{if } i = j \\\\\n    -1/h^2  \\text{if } |i - j| = 1 \\\\\n    0  \\text{otherwise}\n    \\end{cases}\n    $$\n    右端向量 $f \\in \\mathbb{R}^{N}$ 是一个每个分量都为 1 的常数向量。\n\n2.  **区域分解**：$N$ 个索引的集合 $\\{0, 1, \\dots, N-1\\}$ 被划分为两个重叠子区域 $I_1$ 和 $I_2$。定义中点索引为 $m = \\lfloor N/2 \\rfloor$，对于给定的非负整数重叠参数 $o$，索引集为：\n    $$\n    I_1 = \\{i \\in \\mathbb{Z} \\mid 0 \\le i  m+o \\} \\cap \\{0, \\dots, N-1\\}\n    $$\n    $$\n    I_2 = \\{i \\in \\mathbb{Z} \\mid m-o \\le i  N \\} \\cap \\{0, \\dots, N-1\\}\n    $$\n    对于每个子区域 $I_i$，我们通过将 $A$ 限制在由 $I_i$ 索引的行和列上，来定义相应的 $A$ 的主子矩阵 $A_{ii}$。\n\n3.  **带非精确求解的乘性 Schwarz 迭代**：问题的核心是从初始猜测 $x^{(0)} = 0$ 开始对 $A u = f$ 进行迭代求解。一次外迭代（从 $x^{(k)}$ 计算 $x^{(k+1)}$）包含两个顺序的乘性步骤。\n\n    a.  **子区域 1 求解**：首先，为子区域 $I_1$ 中的变量计算一个更新量。待求解的系统是关于校正量 $\\delta x_1$ 的，由下式给出：\n        $$\n        A_{11} \\delta x_1 = r_1\n        $$\n        这里，$r_1$ 是全局残差 $r^{(k)} = f - A x^{(k)}$ 限制在 $I_1$ 索引上的部分。该系统使用 $m_{\\text{in}}$ 次加权 Jacobi 方法迭代进行非精确求解，初始猜测为 $\\delta x_1 = 0$：\n        $$\n        (\\delta x_1)^{(j+1)} = (\\delta x_1)^{(j)} + \\omega D_{11}^{-1} (r_1 - A_{11} (\\delta x_1)^{(j)}) \\quad \\text{for } j=0, \\dots, m_{\\text{in}}-1\n        $$\n        其中 $D_{11}$ 是 $A_{11}$ 的对角部分，$\\omega$ 是松弛权重。最终的校正量用于更新解向量，得到一个中间解 $x^{(k+1/2)}$：\n        $$\n        x_{I_1}^{(k+1/2)} = x_{I_1}^{(k)} + \\delta x_1\n        $$\n        $x$ 在 $I_1$ 之外的分量保持不变。\n\n    b.  **子区域 2 求解**：其次，对子区域 $I_2$ 重复此过程。通过非精确求解以下系统来计算一个新的校正量 $\\delta x_2$：\n        $$\n        A_{22} \\delta x_2 = r_2\n        $$\n        其中 $r_2$ 是新的全局残差 $r^{(k+1/2)} = f - A x^{(k+1/2)}$ 限制在 $I_2$ 上的部分。同样，使用 $m_{\\text{in}}$ 次加权 Jacobi 迭代。然后通过更新中间解来获得外迭代 $k+1$ 的最终解：\n        $$\n        x_{I_2}^{(k+1)} = x_{I_2}^{(k+1/2)} + \\delta x_2\n        $$\n\n4.  **收敛性分析**：该迭代方法的有效性通过观测收敛因子 $\\rho_{\\text{obs}}$ 来衡量。在执行 $K$ 次外迭代后，我们得到一个残差范数序列 $\\|r^{(k)}\\|_2$（其中 $k=0, \\dots, K$）。因子 $\\rho_{\\text{obs}}$ 是每次迭代缩减因子的几何平均值：\n    $$\n    \\rho_{\\text{obs}} = \\exp\\left( \\frac{1}{K} \\sum_{k=1}^{K} \\log \\frac{\\|r^{(k)}\\|_2}{\\|r^{(k-1)}\\|_2} \\right)\n    $$\n    这个表达式在代数上可以简化为一个数值上更稳定的形式：\n    $$\n    \\rho_{\\text{obs}} = \\left( \\frac{\\|r^{(K)}\\|_2}{\\|r^{(0)}\\|_2} \\right)^{1/K}\n    $$\n    这个公式将用于最终计算。对于 $m_{\\text{in}} = 0$ 的特殊情况，不执行任何 Jacobi 迭代，校正量 $\\delta x_i$ 始终为零，解也永远不会改变。因此，残差范数保持不变，导致 $\\rho_{\\text{obs}} = 1$。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import diags\n\ndef solve():\n    \"\"\"\n    Computes the observed contraction factor for a two-subdomain multiplicative\n    Schwarz method with inexact solves for the 1D Poisson equation.\n    \"\"\"\n    test_cases = [\n        (127, 2, 0, 2/3, 20),  # Case 1\n        (127, 2, 1, 2/3, 20),  # Case 2\n        (127, 2, 3, 2/3, 20),  # Case 3\n        (127, 0, 10, 2/3, 20), # Case 4\n        (63, 1, 2, 0.8, 20),    # Case 5\n    ]\n\n    results = []\n    for N, o, m_in, omega, K in test_cases:\n        # Step 1: System Construction\n        h = 1.0 / (N + 1)\n        h2_inv = 1.0 / (h * h)\n        \n        main_diag = np.full(N, 2.0 * h2_inv)\n        off_diag = np.full(N - 1, -1.0 * h2_inv)\n        \n        A_sparse = diags(\n            [main_diag, off_diag, off_diag], \n            [0, -1, 1], \n            shape=(N, N), \n            format='csr'\n        )\n        A = A_sparse.toarray()\n        f = np.ones(N)\n\n        # Step 2: Domain Decomposition\n        m = N // 2\n        I1 = list(range(m + o))\n        I2 = list(range(m - o, N))\n        \n        A11 = A[np.ix_(I1, I1)]\n        A22 = A[np.ix_(I2, I2)]\n        \n        # The diagonal of A_ii is constant. D_ii_inv is a scalar.\n        D_inv_val = 1.0 / (2.0 * h2_inv)\n\n        # Initialize iteration\n        x = np.zeros(N)\n        residual_norms = []\n        \n        r_initial = f - A @ x\n        residual_norms.append(np.linalg.norm(r_initial))\n        \n        if m_in == 0:\n            # Special case: no inner iterations means no update to x.\n            # Residual norm remains constant, rho = 1.\n            rho_obs = 1.0\n            results.append(f\"{rho_obs:.6f}\")\n            continue\n\n        # Step 3: Multiplicative Schwarz Iterations\n        for _ in range(K):\n            # Subdomain 1 solve\n            r_global = f - A @ x\n            r1 = r_global[I1]\n            delta_x1 = np.zeros(len(I1))\n            for _ in range(m_in):\n                delta_x1 += omega * D_inv_val * (r1 - A11 @ delta_x1)\n            x[I1] += delta_x1\n            \n            # Subdomain 2 solve\n            r_global = f - A @ x\n            r2 = r_global[I2]\n            delta_x2 = np.zeros(len(I2))\n            for _ in range(m_in):\n                delta_x2 += omega * D_inv_val * (r2 - A22 @ delta_x2)\n            x[I2] += delta_x2\n            \n            r_final = f - A @ x\n            residual_norms.append(np.linalg.norm(r_final))\n\n        # Step 4: Convergence Analysis\n        rho_obs = (residual_norms[-1] / residual_norms[0])**(1.0 / K)\n        results.append(f\"{rho_obs:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2387028"}]}