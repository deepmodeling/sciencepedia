{"hands_on_practices": [{"introduction": "本实践是理解现代摩擦接触仿真的基石。我们将实现一个投影高斯-赛德尔 (Projected Gauss-Seidel, PGS) 求解器，这是一种广泛应用的迭代方法，用于求解由非穿透和库仑摩擦约束产生的线性互补问题 (Linear Complementarity Problem, LCP)。通过从零开始为一个平面上的单个物块构建此求解器 [@problem_id:2380912]，你将直接洞察接触力是如何计算的，以便以物理上一致的方式防止穿透并模拟摩擦。", "problem": "您的任务是为一个以线性互补问题（LCP）形式描述、包含库仑摩擦的单点接触、三维摩擦接触时步问题，实现一个投影高斯–赛德尔（PGS）求解器。物理背景是一个质量为 $m$ 的刚性块在三维空间中受重力作用运动，可能与一个单位法向量为 $\\mathbf{n} = [0,1,0]^{\\mathsf{T}}$ 的水平面接触。只考虑该物块的平移运动（旋转被忽略），并且时步方案在一个时长为 $h$ 的时间步内，对接触冲量是隐式的，而对外力是显式的。\n\n从以下基本原理和核心定义开始：\n- 时间步上的冲量形式牛顿第二定律：$\\mathbf{M} (\\mathbf{v}^{+} - \\mathbf{v}^{-}) = h \\mathbf{f}_{\\mathrm{ext}} + \\mathbf{J}^{\\mathsf{T}} \\mathbf{p}$，其中 $\\mathbf{M}$ 是质量矩阵，$\\mathbf{v}^{-}$ 和 $\\mathbf{v}^{+}$ 分别是步前和步后速度，$\\mathbf{f}_{\\mathrm{ext}}$ 是外力，$\\mathbf{J}$ 是接触雅可比矩阵，$\\mathbf{p}$ 是接触冲量。\n- 速度层面上的单边不可穿透性和互补性：$0 \\le p_{n} \\perp \\gamma_{n}^{+} \\ge 0$，其中 $p_{n}$ 是法向冲量，$\\gamma_{n}^{+}$ 是步后法向相对速度。\n- 通过摩擦锥的库仑摩擦模型：$\\|\\mathbf{p}_{t}\\| \\le \\mu p_{n}$，其中 $\\mathbf{p}_{t}$ 是切向冲量，$\\mu$ 是摩擦系数，并且最大耗散原理强制在摩擦锥内部时发生静止（$\\gamma_{t}^{+} = \\mathbf{0}$），在摩擦锥边界上时通过投影实现滑动。\n\n对于物块与平面之间的单点接触，定义一个局部接触坐标系，其基向量为 $\\{\\mathbf{n}, \\mathbf{t}_{1}, \\mathbf{t}_{2}\\}$，其中 $\\mathbf{t}_{1} = [1,0,0]^{\\mathsf{T}}$ 和 $\\mathbf{t}_{2} = [0,0,1]^{\\mathsf{T}}$。平移质量矩阵为 $\\mathbf{M} = m \\mathbf{I}_{3}$。使用冲量-动量离散化，令 $\\mathbf{v}^{+} = \\mathbf{v}^{-} + \\mathbf{M}^{-1} (h \\mathbf{f}_{\\mathrm{ext}} + \\mathbf{J}^{\\mathsf{T}} \\mathbf{p})$。接触点在局部坐标系中的相对速度为 $\\boldsymbol{\\gamma}^{+} = \\mathbf{J} \\mathbf{v}^{+}$。证明在此设定下，有效 Delassus 算子（也称为接触点处的逆质量）简化为 $\\mathbf{A} = \\mathbf{J}\\mathbf{M}^{-1}\\mathbf{J}^{\\mathsf{T}} = \\frac{1}{m}\\mathbf{I}_{3}$，并且 PGS 迭代可以对 $3 \\times 1$ 的冲量向量 $\\mathbf{p} = [p_{n}, p_{t1}, p_{t2}]^{\\mathsf{T}}$ 使用以下方法进行：\n- 法向互补更新：$p_{n} \\leftarrow \\max\\{0, p_{n} - \\gamma_{n} / A_{nn}\\}$，\n- 切向无约束梯度步，随后投影到半径为 $\\mu p_{n}$ 的摩擦盘上：$\\mathbf{p}_{t} \\leftarrow \\operatorname{Proj}_{\\|\\cdot\\| \\le \\mu p_{n}}(\\mathbf{p}_{t} - \\mathbf{A}_{tt}^{-1}\\boldsymbol{\\gamma}_{t})$，\n其中 $\\boldsymbol{\\gamma} = \\mathbf{A}\\mathbf{p} + \\mathbf{c}$，而 $\\mathbf{c}$ 汇集了来自步前速度和外力的已知项。\n\n使用重力 $\\mathbf{f}_{\\mathrm{ext}} = m \\mathbf{g}$，其中 $\\mathbf{g} = [0, -g, 0]^{\\mathsf{T}}$ 且 $g > 0$。时间步长为 $h > 0$。局部“自由”接触速度向量为 $\\mathbf{c} = \\mathbf{J} \\left(\\mathbf{v}^{-} + \\mathbf{M}^{-1} h \\mathbf{f}_{\\mathrm{ext}}\\right)$，在此设置下计算结果为 $\\mathbf{c} = [v_{y}^{-} - h g, v_{x}^{-}, v_{z}^{-}]^{\\mathsf{T}}$。在使用 PGS 求解出 $\\mathbf{p}$ 后，计算步后速度\n$$\n\\mathbf{v}^{+} = \\mathbf{v}^{-} + \\mathbf{M}^{-1} h \\mathbf{f}_{\\mathrm{ext}} + \\mathbf{M}^{-1}\\mathbf{J}^{\\mathsf{T}}\\mathbf{p} = \\mathbf{v}^{-} + [0, -h g, 0]^{\\mathsf{T}} + \\frac{1}{m}[p_{t1}, p_{n}, p_{t2}]^{\\mathsf{T}}.\n$$\n\n您的任务是：\n- 为此单点接触问题实现一个基本的投影高斯–赛德尔（PGS）求解器，并将其作为一个完整的程序。使用固定的迭代次数（例如，$N_{\\mathrm{iter}} = 50$），并在 $\\mathbf{p}$ 的变化量小于一个小的容差（例如，$10^{-12}$）时提前终止。您的实现必须足够通用，以处理 $m$、$h$、$g$、$\\mu$ 和 $\\mathbf{v}^{-}$ 的任何容许输入，尽管对于此问题，您将只求解指定的测试套件。\n- 对于下面的每个测试用例，计算并报告四个量：以 $\\mathrm{m/s}$ 为单位的步后法向速度 $v^{+}_{y}$，以 $\\mathrm{m/s}$ 为单位的步后切向速率 $\\sqrt{(v^{+}_{x})^{2} + (v^{+}_{z})^{2}}$，以 $\\mathrm{N\\cdot s}$ 为单位的法向冲量 $p_{n}$，以及以 $\\mathrm{N\\cdot s}$ 为单位的切向冲量大小 $\\sqrt{p_{t1}^{2} + p_{t2}^{2}}$。所有输出都用指定单位表示，并将报告的每个数字四舍五入到恰好六位小数。\n\n角度单位不适用。百分比不适用。\n\n测试套件（所有量均采用国际单位制）：\n- 案例 1（滑动）：$m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.5$, $\\mathbf{v}^{-} = [2.0,-1.0,0.0]^{\\mathsf{T}}$。\n- 案例 2（静止）：$m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 1.0$, $\\mathbf{v}^{-} = [0.05,-0.01,0.0]^{\\mathsf{T}}$。\n- 案例 3（无摩擦）：$m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.0$, $\\mathbf{v}^{-} = [1.0,-0.2,0.0]^{\\mathsf{T}}$。\n- 案例 4（分离，无接触）：$m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.5$, $\\mathbf{v}^{-} = [0.0,0.5,0.0]^{\\mathsf{T}}$。\n- 案例 5（重块，混合）：$m = 1000.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.6$, $\\mathbf{v}^{-} = [3.0,-0.3,4.0]^{\\mathsf{T}}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。每个测试用例的结果本身必须是一个包含四个四舍五入浮点数的列表，顺序为 $[v^{+}_{y}, \\sqrt{(v^{+}_{x})^{2} + (v^{+}_{z})^{2}}, p_{n}, \\sqrt{p_{t1}^{2} + p_{t2}^{2}}]$。例如，一个包含两个假设结果的输出看起来会是 $[[a_{1},b_{1},c_{1},d_{1}],[a_{2},b_{2},c_{2},d_{2}]]$，其中每个条目都四舍五入到六位小数。", "solution": "此问题已经过验证。\n\n### 步骤 1：提取已知条件\n- **物理系统**：一个质量为 $m$ 的刚性块在三维空间中进行平移运动，可能与一个水平面接触。\n- **接触几何**：该平面的单位法向量为 $\\mathbf{n} = [0,1,0]^{\\mathsf{T}}$。局部接触坐标系的基向量为 $\\{\\mathbf{n}, \\mathbf{t}_{1}, \\mathbf{t}_{2}\\}$，其中 $\\mathbf{t}_{1} = [1,0,0]^{\\mathsf{T}}$ 和 $\\mathbf{t}_{2} = [0,0,1]^{\\mathsf{T}}$。\n- **动力学**：\n    - 质量矩阵：$\\mathbf{M} = m \\mathbf{I}_{3}$。\n    - 外力：重力，$\\mathbf{f}_{\\mathrm{ext}} = m \\mathbf{g}$，其中 $\\mathbf{g} = [0, -g, 0]^{\\mathsf{T}}$ 且 $g > 0$。\n    - 时间步：$h > 0$。\n- **时步公式**：\n    - 冲量-动量方程：$\\mathbf{M} (\\mathbf{v}^{+} - \\mathbf{v}^{-}) = h \\mathbf{f}_{\\mathrm{ext}} + \\mathbf{J}^{\\mathsf{T}} \\mathbf{p}$。\n    - 接触雅可比矩阵 $\\mathbf{J}$ 将全局速度 $\\mathbf{v}$ 映射到局部相对速度 $\\boldsymbol{\\gamma}$。\n    - 接触冲量（局部坐标系）：$\\mathbf{p} = [p_{n}, p_{t1}, p_{t2}]^{\\mathsf{T}}$。\n- **接触定律**：\n    - 单边不可穿透性：$0 \\le p_{n} \\perp \\gamma_{n}^{+} \\ge 0$。\n    - 库仑摩擦：$\\|\\mathbf{p}_{t}\\| \\le \\mu p_{n}$，其中 $\\mathbf{p}_{t} = [p_{t1}, p_{t2}]^{\\mathsf{T}}$ 且 $\\mu$ 是摩擦系数。\n- **线性互补问题（LCP）公式**：\n    - 步后相对速度：$\\boldsymbol{\\gamma}^{+} = \\mathbf{A}\\mathbf{p} + \\mathbf{c}$。\n    - Delassus 算子：$\\mathbf{A} = \\mathbf{J}\\mathbf{M}^{-1}\\mathbf{J}^{\\mathsf{T}} = \\frac{1}{m}\\mathbf{I}_{3}$。\n    - 自由速度项：$\\mathbf{c} = \\mathbf{J} \\left(\\mathbf{v}^{-} + \\mathbf{M}^{-1} h \\mathbf{f}_{\\mathrm{ext}}\\right) = [v_{y}^{-} - h g, v_{x}^{-}, v_{z}^{-}]^{\\mathsf{T}}$。\n- **投影高斯-赛德尔（PGS）更新规则**：\n    - 法向更新：$p_{n} \\leftarrow \\max\\{0, p_{n} - \\gamma_{n} / A_{nn}\\}$。\n    - 切向更新：$\\mathbf{p}_{t} \\leftarrow \\operatorname{Proj}_{\\|\\cdot\\| \\le \\mu p_{n}}(\\mathbf{p}_{t} - \\mathbf{A}_{tt}^{-1}\\boldsymbol{\\gamma}_{t})$。\n- **步后速度计算**：\n    - $\\mathbf{v}^{+} = \\mathbf{v}^{-} + [0, -h g, 0]^{\\mathsf{T}} + \\frac{1}{m}[p_{t1}, p_{n}, p_{t2}]^{\\mathsf{T}}$。\n- **求解器参数**：\n    - 固定迭代次数：$N_{\\mathrm{iter}} = 50$。\n    - 收敛容差：$\\epsilon = 10^{-12}$。\n- **测试套件**：\n    - 案例 1：$m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.5$, $\\mathbf{v}^{-} = [2.0,-1.0,0.0]^{\\mathsf{T}}$。\n    - 案例 2：$m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 1.0$, $\\mathbf{v}^{-} = [0.05,-0.01,0.0]^{\\mathsf{T}}$。\n    - 案例 3：$m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.0$, $\\mathbf{v}^{-} = [1.0,-0.2,0.0]^{\\mathsf{T}}$。\n    - 案例 4：$m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.5$, $\\mathbf{v}^{-} = [0.0,0.5,0.0]^{\\mathsf{T}}$。\n    - 案例 5：$m = 1000.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.6$, $\\mathbf{v}^{-} = [3.0,-0.3,4.0]^{\\mathsf{T}}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对此问题进行评估：\n- **科学依据**：该问题基于经典力学的基础原理（牛顿定律）和计算接触力学中的标准模型（库仑摩擦、互补条件、LCP 公式）。隐式时步方案和 PGS 方法是成熟的技术。该问题在科学上是合理的。\n- **适定性**：该问题要求实现一个特定的、明确定义的算法（PGS）来解决一个摩擦接触问题。对于给定的设置（单点接触、对角 Delassus 算子），PGS 方法保证收敛到唯一解。该问题是适定的。\n- **客观性**：问题陈述使用了精确、明确无歧义的数学和物理术语。没有主观或基于观点的元素。该问题是客观的。\n- **完整性与一致性**：所有必需的方程、参数和边界条件都已提供。问题陈述中给出的关于 $\\mathbf{A}$ 和 $\\mathbf{c}$ 的推导与基础物理以及 $\\mathbf{J}$、$\\mathbf{M}$ 和 $\\mathbf{f}_{\\text{ext}}$ 的定义是一致的。该设置是完整的且内部一致。\n\n### 步骤 3：结论与行动\n该问题有效。这是一个计算力学中的标准、明确定义的问题。将提供一个解决方案。\n\n目标是为一个单点接触摩擦问题实现一个投影高斯–赛德尔（PGS）求解器。该问题被公式化为一个线性互补问题（LCP），其中的未知量是接触冲量 $\\mathbf{p} = [p_n, p_{t1}, p_{t2}]^{\\mathsf{T}}$。\n\n首先，我们定义 LCP 系统。步后相对接触速度 $\\boldsymbol{\\gamma}^{+}$ 通过仿射关系 $\\boldsymbol{\\gamma}^{+} = \\mathbf{A}\\mathbf{p} + \\mathbf{c}$ 与冲量 $\\mathbf{p}$ 相关联，其中 $\\mathbf{A}$ 是 Delassus 算子，$\\mathbf{c}$ 是自由速度项。问题指出，对于这个特定系统，$\\mathbf{A} = \\frac{1}{m}\\mathbf{I}_3$ 是一个对角矩阵。自由速度向量 $\\mathbf{c}$ 汇集了所有独立于未知冲量 $\\mathbf{p}$ 的项，并由 $\\mathbf{c} = [v_{y}^{-} - h g, v_{x}^{-}, v_{z}^{-}]^{\\mathsf{T}}$ 给出。我们将 $\\mathbf{c}$ 的分量表示为 $c_n = v_{y}^{-} - h g$，$c_{t1} = v_{x}^{-}$ 和 $c_{t2} = v_{z}^{-}$。\n\nPGS 方法是一种迭代算法，通过顺序更新解向量 $\\mathbf{p}$ 的分量并将其投影以满足约束来求解 LCP。我们将冲量向量初始化为零，$\\mathbf{p}^{(0)} = \\mathbf{0}$。对于每次迭代 $k$，我们基于 $\\mathbf{p}^{(k)}$ 计算一个新的估计值 $\\mathbf{p}^{(k+1)}$。该迭代对法向和切向分量使用分块更新策略。\n\n**1. 法向冲量更新：**\nPGS 扫描的第一步是更新法向冲量 $p_n$。法向的互补条件是 $0 \\le p_n \\perp \\gamma_n \\ge 0$。PGS 更新执行一个类似梯度下降的步骤，并将结果投影到可行集上，对于 $p_n$ 来说，可行集是非负实数轴。\n更新规则是 $p_n^{(k+1)} = \\max\\{0, p_n^{(k)} - A_{nn}^{-1}\\gamma_n^{(k)}\\}$。相对速度 $\\gamma_n$ 使用最新可用的冲量值计算，但由于 $\\mathbf{A}$ 是对角的，这简化了计算。\n$$ \\gamma_n = (\\mathbf{A}\\mathbf{p}^{(k)} + \\mathbf{c})_n = A_{nn}p_n^{(k)} + c_n = \\frac{1}{m}p_n^{(k)} + c_n $$\n将此代入更新规则得到：\n$$ p_n^{(k+1)} = \\max\\left\\{0, p_n^{(k)} - \\frac{\\frac{1}{m}p_n^{(k)} + c_n}{1/m}\\right\\} = \\max\\left\\{0, p_n^{(k)} - (p_n^{(k)} + m c_n)\\right\\} = \\max\\{0, -m c_n\\} $$\n这表明对于此对角系统，法向冲量在单步内收敛到其最终值。然而，实现必须遵循指定的迭代形式。\n\n**2. 切向冲量更新：**\n接下来，我们更新切向冲量向量 $\\mathbf{p}_t = [p_{t1}, p_{t2}]^{\\mathsf{T}}$。库仑摩擦定律规定，切向冲量必须位于切平面上一个半径为 $R = \\mu p_n$ 的圆盘内。我们以 Gauss-Seidel 的方式，使用最新计算出的法向冲量 $p_n^{(k+1)}$ 来定义当前迭代的摩擦盘半径。更新通过一个无约束步，然后投影到该圆盘上来执行。\n切向块的无约束更新是：$\\mathbf{p}_t^{unc} = \\mathbf{p}_t^{(k)} - \\mathbf{A}_{tt}^{-1}\\boldsymbol{\\gamma}_t^{(k)}$。\n切向相对速度为 $\\boldsymbol{\\gamma}_t^{(k)} = \\mathbf{A}_{tt}\\mathbf{p}_t^{(k)} + \\mathbf{c}_t$。给定 $\\mathbf{A}_{tt} = \\frac{1}{m}\\mathbf{I}_2$，其逆为 $\\mathbf{A}_{tt}^{-1} = m\\mathbf{I}_2$。\n$$ \\mathbf{p}_t^{unc} = \\mathbf{p}_t^{(k)} - m\\left(\\frac{1}{m}\\mathbf{p}_t^{(k)} + \\mathbf{c}_t\\right) = -m\\mathbf{c}_t $$\n最终的切向冲量通过将 $\\mathbf{p}_t^{unc}$ 投影到半径为 $R = \\mu p_n^{(k+1)}$ 的圆盘上获得：\n$$ \\mathbf{p}_t^{(k+1)} = \\operatorname{Proj}_{\\|\\cdot\\| \\le R}(\\mathbf{p}_t^{unc}) $$\n投影定义为：\n$$ \\mathbf{p}_t^{(k+1)} = \\begin{cases} \\mathbf{p}_t^{unc} & \\text{if } \\|\\mathbf{p}_t^{unc}\\| \\le R \\\\ R \\frac{\\mathbf{p}_t^{unc}}{\\|\\mathbf{p}_t^{unc}\\|} & \\text{if } \\|\\mathbf{p}_t^{unc}\\| > R \\end{cases} $$\n如果所需的摩擦冲量在锥内，则对应于静止，否则对应于滑动。\n\n迭代过程重复固定的迭代次数 $N_{\\mathrm{iter}}$，或者直到冲量向量的变化量（由无穷范数 $\\|\\mathbf{p}^{(k+1)} - \\mathbf{p}^{(k)}\\|_{\\infty}$ 衡量）低于指定的容差 $\\epsilon$。\n\n**3. 后处理：**\n在 PGS 求解器收敛到最终冲量 $\\mathbf{p}$ 之后，使用冲量-动量关系计算步后速度 $\\mathbf{v}^{+}$：\n$$ \\mathbf{v}^{+} = \\mathbf{v}^{-} + \\mathbf{M}^{-1} (h \\mathbf{f}_{\\mathrm{ext}} + \\mathbf{J}^{\\mathsf{T}} \\mathbf{p}) $$\n根据所提供的定义，这变为：\n$$ \\begin{bmatrix} v_x^{+} \\\\ v_y^{+} \\\\ v_z^{+} \\end{bmatrix} = \\begin{bmatrix} v_x^{-} \\\\ v_y^{-} \\\\ v_z^{-} \\end{bmatrix} + \\begin{bmatrix} 0 \\\\ -h g \\\\ 0 \\end{bmatrix} + \\frac{1}{m} \\begin{bmatrix} p_{t1} \\\\ p_n \\\\ p_{t2} \\end{bmatrix} $$\n由此，计算所需的输出量：\n- 步后法向速度：$v_y^{+}$\n- 步后切向速率：$\\sqrt{(v_x^{+})^2 + (v_z^{+})^2}$\n- 法向冲量：$p_n$\n- 切向冲量大小：$\\sqrt{p_{t1}^2 + p_{t2}^2}$\n\n实现将遵循此逻辑处理每个提供的测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the specified test cases for the frictional contact problem.\n    \"\"\"\n    \n    # Test suite (m, h, g, mu, v_minus)\n    # All quantities are in SI units.\n    test_cases = [\n        (1.0, 0.01, 9.81, 0.5, np.array([2.0, -1.0, 0.0])),  # Case 1 (sliding)\n        (1.0, 0.01, 9.81, 1.0, np.array([0.05, -0.01, 0.0])),  # Case 2 (sticking)\n        (1.0, 0.01, 9.81, 0.0, np.array([1.0, -0.2, 0.0])),    # Case 3 (frictionless)\n        (1.0, 0.01, 9.81, 0.5, np.array([0.0, 0.5, 0.0])),   # Case 4 (separating)\n        (1000.0, 0.01, 9.81, 0.6, np.array([3.0, -0.3, 4.0])),# Case 5 (heavy block, mixed)\n    ]\n\n    results = []\n    for case in test_cases:\n        m, h, g, mu, v_minus = case\n        result = run_pgs_solver(m, h, g, mu, v_minus)\n        # Round each number in the result to 6 decimal places\n        rounded_result = [round(x, 6) for x in result]\n        results.append(rounded_result)\n\n    # Format the final output string as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_pgs_solver(m, h, g, mu, v_minus):\n    \"\"\"\n    Implements the Projected Gauss-Seidel solver for a single-contact LCP.\n\n    Args:\n        m (float): Mass of the block.\n        h (float): Time step duration.\n        g (float): Acceleration due to gravity.\n        mu (float): Coefficient of friction.\n        v_minus (np.ndarray): Pre-step velocity vector [vx, vy, vz].\n\n    Returns:\n        list: A list of four floats:\n              [v_plus_y, tangential_speed_plus, p_n, p_t_magnitude].\n    \"\"\"\n    \n    # Solver parameters\n    N_iter = 50\n    tolerance = 1e-12\n\n    # Pre-computation of the free velocity vector 'c'\n    # c = [v_y^- - h*g, v_x^-, v_z^-]^T\n    c_n = v_minus[1] - h * g\n    c_t = np.array([v_minus[0], v_minus[2]])\n    \n    # Initialize impulse vector p = [p_n, p_t1, p_t2]^T\n    p = np.zeros(3)\n    \n    # Delassus operator is diagonal A = (1/m) * I\n    # inv_A_nn = m, inv_A_tt = m * I_2\n    inv_A_nn = m\n    \n    # PGS iteration loop\n    for _ in range(N_iter):\n        p_old = p.copy()\n        \n        # 1. Normal impulse update (component p_n)\n        # gamma_n = (1/m)*p_n + c_n\n        gamma_n = (1.0 / m) * p[0] + c_n\n        # p_n_new = max(0, p_n - inv_A_nn * gamma_n)\n        p[0] = max(0.0, p[0] - inv_A_nn * gamma_n)\n        \n        # 2. Tangential impulse update (block p_t)\n        # The update is based on the most recent p_n\n        friction_radius = mu * p[0]\n        \n        # Unconstrained tangential impulse: p_t_unc = -inv_A_tt * c_t = -m * c_t\n        p_t_unc = -m * c_t\n        norm_p_t_unc = np.linalg.norm(p_t_unc)\n        \n        # Project onto friction disk\n        if norm_p_t_unc = friction_radius:\n            # Sticking\n            p[1:] = p_t_unc\n        else:\n            # Sliding\n            if norm_p_t_unc > 1e-15: # Avoid division by zero\n                p[1:] = friction_radius * p_t_unc / norm_p_t_unc\n            else:\n                p[1:] = np.zeros(2)\n\n        # 3. Check for convergence\n        # The change is measured using the infinity norm\n        change = np.linalg.norm(p - p_old, np.inf)\n        if change  tolerance:\n            break\n            \n    p_n = p[0]\n    p_t = p[1:]\n    \n    # Post-processing: Compute post-step velocity v_plus\n    # v+ = v- + [0, -hg, 0]^T + (1/m)*[p_t1, p_n, p_t2]^T\n    v_plus = np.zeros(3)\n    v_plus[0] = v_minus[0] + p_t[0] / m\n    v_plus[1] = v_minus[1] - h * g + p_n / m\n    v_plus[2] = v_minus[2] + p_t[1] / m\n    \n    # Calculate required output quantities\n    v_plus_y = v_plus[1]\n    tangential_speed_plus = np.linalg.norm(np.array([v_plus[0], v_plus[2]]))\n    p_t_magnitude = np.linalg.norm(p_t)\n    \n    return [v_plus_y, tangential_speed_plus, p_n, p_t_magnitude]\n\nsolve()\n```", "id": "2380912"}, {"introduction": "约束强制不仅限于接触力学，它是在仿真中为物理限制建模的一项通用原则。本练习将投影的概念应用于一个不同的领域：对电机的执行器施加扭矩限制。你将推导并实现一种方法，以确保电机在尝试达到目标速度的同时，其扭矩保持在其物理能力范围内，从而阐明相同的数学思想如何处理各种工程约束 [@problem_id:2380886]。", "problem": "一个单自由度 (SDOF) 电机驱动的旋转关节，其绕轴的转动惯量为 $I$，由一个电机扭矩驱动，并受到一个外部扭矩的作用。由于致动器的限制，电机扭矩的大小被一个最大允许值 $\\tau_{\\max}$ 所限制。目标是使用一种有原则的约束实施方法，在执行此边界约束的同时，在持续时间为 $h$ 的单个时间步长内，驱动关节达到一个指定的目标角速度 $\\omega^{\\star}$。物理单位如下：惯量单位为 $\\mathrm{kg \\cdot m^2}$，扭矩单位为 $\\mathrm{N \\cdot m}$，角速度单位为 $\\mathrm{rad/s}$，时间单位为 $\\mathrm{s}$。所有角度和角速度必须分别以弧度和 $\\mathrm{rad/s}$ 为单位处理。\n\n基于牛顿第二转动定律和标准的时间步进思想进行推导。具体来说，使用基本定律 $I \\, \\dot{\\omega} = \\tau_{\\mathrm{ext}} + \\tau_{\\mathrm{motor}}$，其中 $\\tau_{\\mathrm{ext}}$ 是外部扭矩，$\\tau_{\\mathrm{motor}}$ 是电机扭矩，并对角速度在持续时间为 $h$ 的一个步长内进行一致的离散更新。将电机作用视为一个基于约束的速度伺服，试图在步长结束时强制执行速度级条件 $\\omega_{k+1} \\approx \\omega^{\\star}$，其中电机扭矩表示为一个必须服从箱式约束 $-\\tau_{\\max} \\le \\tau_{\\mathrm{motor}} \\le \\tau_{\\max}$ 的决策变量。将其与一个基于物理的投影或拉格朗日乘子解释联系起来，但不要假设任何预先推导的伺服或投影公式；相反，应从离散动力学和速度级目标中推导出扭矩决策的适当表达式。\n\n实现一个程序，对于每个提供的测试用例，该程序使用离散动力学计算施加的、遵循边界约束的电机扭矩，以及由此产生的下一步角速度 $\\omega_{k+1}$。最终程序必须仅输出由此产生的下一步角速度，每个测试用例一个，并聚合成一个单行列表，形式为用方括号括起来的逗号分隔列表。每个结果必须四舍五入到六位小数，并以 $\\mathrm{rad/s}$ 表示。\n\n用于覆盖典型、边界和边缘条件的测试套件：\n- 情况 $1$（存在非零外部扭矩时的非饱和伺服跟踪）：$I = 1.5 \\, \\mathrm{kg \\cdot m^2}$，$h = 0.02 \\, \\mathrm{s}$，$\\omega_k = 1.00 \\, \\mathrm{rad/s}$，$\\omega^{\\star} = 1.02 \\, \\mathrm{rad/s}$，$\\tau_{\\max} = 5.0 \\, \\mathrm{N \\cdot m}$，$\\tau_{\\mathrm{ext}} = 0.5 \\, \\mathrm{N \\cdot m}$。\n- 情况 $2$（强正向饱和）：$I = 0.5 \\, \\mathrm{kg \\cdot m^2}$，$h = 0.01 \\, \\mathrm{s}$，$\\omega_k = 0.00 \\, \\mathrm{rad/s}$，$\\omega^{\\star} = 10.00 \\, \\mathrm{rad/s}$，$\\tau_{\\max} = 2.0 \\, \\mathrm{N \\cdot m}$，$\\tau_{\\mathrm{ext}} = 0.0 \\, \\mathrm{N \\cdot m}$。\n- 情况 $3$（抵抗外部扭矩的强负向饱和）：$I = 1.2 \\, \\mathrm{kg \\cdot m^2}$，$h = 0.02 \\, \\mathrm{s}$，$\\omega_k = 5.00 \\, \\mathrm{rad/s}$，$\\omega^{\\star} = -5.00 \\, \\mathrm{rad/s}$，$\\tau_{\\max} = 1.0 \\, \\mathrm{N \\cdot m}$，$\\tau_{\\mathrm{ext}} = 0.2 \\, \\mathrm{N \\cdot m}$。\n- 情况 $4$（电机能力为零，仅有外部扭矩）：$I = 1.0 \\, \\mathrm{kg \\cdot m^2}$，$h = 0.05 \\, \\mathrm{s}$，$\\omega_k = 2.00 \\, \\mathrm{rad/s}$，$\\omega^{\\star} = 0.00 \\, \\mathrm{rad/s}$，$\\tau_{\\max} = 0.0 \\, \\mathrm{N \\cdot m}$，$\\tau_{\\mathrm{ext}} = -0.5 \\, \\mathrm{N \\cdot m}$。\n- 情况 $5$（边界约束恰好足够的边界相等情况）：$I = 2.0 \\, \\mathrm{kg \\cdot m^2}$，$h = 0.10 \\, \\mathrm{s}$，$\\omega_k = 1.00 \\, \\mathrm{rad/s}$，$\\omega^{\\star} = 1.50 \\, \\mathrm{rad/s}$，$\\tau_{\\max} = 10.0 \\, \\mathrm{N \\cdot m}$，$\\tau_{\\mathrm{ext}} = 0.0 \\, \\mathrm{N \\cdot m}$。\n\n您的程序必须：\n- 对于每种情况，使用一种有原则的约束实施方法计算下一步的角速度（单位为 $\\mathrm{rad/s}$），该方法需遵循 $-\\tau_{\\max} \\le \\tau_{\\mathrm{motor}} \\le \\tau_{\\max}$。\n- 将五个下一步角速度聚合成一个列表。\n- 精确打印一行，包含该列表，格式为 $[\\text{v}_1,\\text{v}_2,\\text{v}_3,\\text{v}_4,\\text{v}_5]$，其中每个 $\\text{v}_i$ 四舍五入到六位小数，单位为 $\\mathrm{rad/s}$。", "solution": "此问题需经过验证。\n\n**第 1 步：提取的已知条件**\n- 控制微分方程：$I \\, \\dot{\\omega} = \\tau_{\\mathrm{ext}} + \\tau_{\\mathrm{motor}}$\n- 转动惯量：$I$\n- 时间步长：$h$\n- 步 $k$ 时的角速度：$\\omega_k$\n- 目标角速度：$\\omega^{\\star}$\n- 最大电机扭矩大小：$\\tau_{\\max}$\n- 外部扭矩：$\\tau_{\\mathrm{ext}}$\n- 电机扭矩约束：$-\\tau_{\\max} \\le \\tau_{\\mathrm{motor}} \\le \\tau_{\\max}$\n- 控制目标：实现 $\\omega_{k+1} \\approx \\omega^{\\star}$\n- 测试用例：\n    1. $I = 1.5 \\, \\mathrm{kg \\cdot m^2}$，$h = 0.02 \\, \\mathrm{s}$，$\\omega_k = 1.00 \\, \\mathrm{rad/s}$，$\\omega^{\\star} = 1.02 \\, \\mathrm{rad/s}$，$\\tau_{\\max} = 5.0 \\, \\mathrm{N \\cdot m}$，$\\tau_{\\mathrm{ext}} = 0.5 \\, \\mathrm{N \\cdot m}$。\n    2. $I = 0.5 \\, \\mathrm{kg \\cdot m^2}$，$h = 0.01 \\, \\mathrm{s}$，$\\omega_k = 0.00 \\, \\mathrm{rad/s}$，$\\omega^{\\star} = 10.00 \\, \\mathrm{rad/s}$，$\\tau_{\\max} = 2.0 \\, \\mathrm{N \\cdot m}$，$\\tau_{\\mathrm{ext}} = 0.0 \\, \\mathrm{N \\cdot m}$。\n    3. $I = 1.2 \\, \\mathrm{kg \\cdot m^2}$，$h = 0.02 \\, \\mathrm{s}$，$\\omega_k = 5.00 \\, \\mathrm{rad/s}$，$\\omega^{\\star} = -5.00 \\, \\mathrm{rad/s}$，$\\tau_{\\max} = 1.0 \\, \\mathrm{N \\cdot m}$，$\\tau_{\\mathrm{ext}} = 0.2 \\, \\mathrm{N \\cdot m}$。\n    4. $I = 1.0 \\, \\mathrm{kg \\cdot m^2}$，$h = 0.05 \\, \\mathrm{s}$，$\\omega_k = 2.00 \\, \\mathrm{rad/s}$，$\\omega^{\\star} = 0.00 \\, \\mathrm{rad/s}$，$\\tau_{\\max} = 0.0 \\, \\mathrm{N \\cdot m}$，$\\tau_{\\mathrm{ext}} = -0.5 \\, \\mathrm{N \\cdot m}$。\n    5. $I = 2.0 \\, \\mathrm{kg \\cdot m^2}$，$h = 0.10 \\, \\mathrm{s}$，$\\omega_k = 1.00 \\, \\mathrm{rad/s}$，$\\omega^{\\star} = 1.50 \\, \\mathrm{rad/s}$，$\\tau_{\\max} = 10.0 \\, \\mathrm{N \\cdot m}$，$\\tau_{\\mathrm{ext}} = 0.0 \\, \\mathrm{N \\cdot m}$。\n\n**第 2 步：使用提取的已知条件进行验证**\n- **科学依据：** 该问题基于牛顿第二转动定律，这是力学的基本原理。离散时间步进和致动器饱和的使用是计算动力学和控制领域的标准方法。其物理基础是可靠的。\n- **适定性：** 问题定义清晰，为每种情况提供了所有必要的参数。目标明确，可导向唯一解。\n- **客观性：** 问题以精确、定量的术语陈述，不含主观或推测性内容。\n- **结论：** 该问题具有科学依据、适定、客观且完整。因此，该问题是有效的。\n\n**第 3 步：裁定与行动**\n问题有效。将推导并提供解答。\n\n推导始于转动动力学的基本原理，即牛顿第二定律。该定律指出，施加于物体的合扭矩等于其转动惯量乘以其角加速度。\n$$ I \\dot{\\omega}(t) = \\tau_{\\text{total}}(t) $$\n总扭矩 $\\tau_{\\text{total}}$ 是外部扭矩 $\\tau_{\\mathrm{ext}}$ 和电机控制扭矩 $\\tau_{\\mathrm{motor}}$ 的和。\n$$ I \\dot{\\omega}(t) = \\tau_{\\mathrm{ext}} + \\tau_{\\mathrm{motor}} $$\n为构建计算算法，我们必须将此连续时间方程离散化。对于正向动力学仿真，一个一致且简单的选择是显式欧拉积分方案。角速度的时间导数 $\\dot{\\omega}$ 在持续时间为 $h$ 的有限时间步长内近似为：\n$$ \\dot{\\omega} \\approx \\frac{\\omega_{k+1} - \\omega_k}{h} $$\n其中 $\\omega_k$ 和 $\\omega_{k+1}$ 分别是时间步长开始和结束时的角速度。将此代入运动方程，得到离散时间动力学方程：\n$$ I \\left( \\frac{\\omega_{k+1} - \\omega_k}{h} \\right) = \\tau_{\\mathrm{ext}} + \\tau_{\\mathrm{motor}} $$\n控制目标是选择一个电机扭矩 $\\tau_{\\mathrm{motor}}$，使得产生的速度 $\\omega_{k+1}$ 与目标速度 $\\omega^{\\star}$ 相匹配。我们首先确定能够完美实现此目标的理想无约束扭矩，记为 $\\tau_{\\mathrm{motor}}^{\\text{ideal}}$。我们在离散动力学方程中设置 $\\omega_{k+1} = \\omega^{\\star}$：\n$$ I \\left( \\frac{\\omega^{\\star} - \\omega_k}{h} \\right) = \\tau_{\\mathrm{ext}} + \\tau_{\\mathrm{motor}}^{\\text{ideal}} $$\n求解此理想电机扭矩，可得：\n$$ \\tau_{\\mathrm{motor}}^{\\text{ideal}} = \\frac{I}{h}(\\omega^{\\star} - \\omega_k) - \\tau_{\\mathrm{ext}} $$\n此表达式代表了在显式欧拉离散化下，系统在一个时间步长内达到目标角速度所需的扭矩。\n\n然而，电机受到物理限制，表现为箱式约束：\n$$ -\\tau_{\\max} \\le \\tau_{\\mathrm{motor}} \\le \\tau_{\\max} $$\n理想扭矩 $\\tau_{\\mathrm{motor}}^{\\text{ideal}}$ 可能会超出这些限制。物理上正确的方法是，在发生饱和时，沿理想扭矩的方向施加最大可能扭矩。这对应于在允许区间 $[-\\tau_{\\max}, \\tau_{\\max}]$ 内找到最接近 $\\tau_{\\mathrm{motor}}^{\\text{ideal}}$ 的扭矩 $\\tau_{\\mathrm{motor}}$。这是理想扭矩在有效集合上的投影。在数学上，此操作是一个钳位或饱和函数：\n$$ \\tau_{\\mathrm{motor}} = \\text{clamp}(\\tau_{\\mathrm{motor}}^{\\text{ideal}}, -\\tau_{\\max}, \\tau_{\\max}) \\equiv \\max(-\\tau_{\\max}, \\min(\\tau_{\\mathrm{motor}}^{\\text{ideal}}, \\tau_{\\max})) $$\n这个公式并非临时构建；它是求解约束优化问题——在不等式约束 $\\tau \\le \\tau_{\\max}$ 和 $-\\tau \\le \\tau_{\\max}$ 下最小化与理想扭矩的偏差 $J(\\tau) = (\\tau - \\tau_{\\mathrm{motor}}^{\\text{ideal}})^2$——的正确解。通过 Karush-Kuhn-Tucker (KKT) 条件求解证实了该投影为最优选择。\n\n确定了受约束的可实现电机扭矩 $\\tau_{\\mathrm{motor}}$ 后，我们现在可以计算下一时间步的实际角速度 $\\omega_{k+1}$。我们重排离散动力学方程以求解 $\\omega_{k+1}$：\n$$ \\omega_{k+1} = \\omega_k + \\frac{h}{I} (\\tau_{\\mathrm{ext}} + \\tau_{\\mathrm{motor}}) $$\n如果 $\\tau_{\\mathrm{motor}} = \\tau_{\\mathrm{motor}}^{\\text{ideal}}$（即无饱和），将其代回方程会正确得到 $\\omega_{k+1} = \\omega^{\\star}$。如果发生饱和，$\\tau_{\\mathrm{motor}}$ 将为 $\\tau_{\\max}$ 或 $-\\tau_{\\max}$，而 $\\omega_{k+1}$ 将是在最大致动器作用下达到的速度。\n\n最终算法如下：\n1. 对于一组给定的参数 $\\{I, h, \\omega_k, \\omega^{\\star}, \\tau_{\\max}, \\tau_{\\mathrm{ext}}\\}$，计算理想电机扭矩 $\\tau_{\\mathrm{motor}}^{\\text{ideal}}$。\n2. 应用饱和约束以找到实际电机扭矩 $\\tau_{\\mathrm{motor}} = \\text{clamp}(\\tau_{\\mathrm{motor}}^{\\text{ideal}}, -\\tau_{\\max}, \\tau_{\\max})$。\n3. 使用受约束的扭矩 $\\tau_{\\mathrm{motor}}$ 计算新的角速度 $\\omega_{k+1}$。\n此过程将应用于每个测试用例，以找到相应的下一步角速度。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the next-step angular velocity for a motor-driven revolute joint,\n    enforcing motor torque limits using a principled constraint method.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    # Each case is a tuple: (I, h, omega_k, omega_star, tau_max, tau_ext)\n    test_cases = [\n        # Case 1: Unsaturated servo tracking\n        (1.5, 0.02, 1.00, 1.02, 5.0, 0.5),\n        # Case 2: Strong positive saturation\n        (0.5, 0.01, 0.00, 10.00, 2.0, 0.0),\n        # Case 3: Strong negative saturation opposing external torque\n        (1.2, 0.02, 5.00, -5.00, 1.0, 0.2),\n        # Case 4: Zero motor capability, external torque only\n        (1.0, 0.05, 2.00, 0.00, 0.0, -0.5),\n        # Case 5: Boundary equality where the bound is just sufficient\n        (2.0, 0.10, 1.00, 1.50, 10.0, 0.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        I, h, omega_k, omega_star, tau_max, tau_ext = case\n\n        # Step 1: Calculate the ideal motor torque to reach omega_star in one step.\n        # This is derived from I * (omega_k+1 - omega_k) / h = tau_ext + tau_motor\n        # by setting omega_k+1 = omega_star and solving for tau_motor.\n        tau_motor_ideal = (I / h) * (omega_star - omega_k) - tau_ext\n        \n        # Step 2: Enforce the motor torque constraint. The applied torque is the\n        # ideal torque projected (clamped) onto the valid interval [-tau_max, tau_max].\n        tau_motor_actual = np.clip(tau_motor_ideal, -tau_max, tau_max)\n        \n        # Step 3: Calculate the actual next-step angular velocity using the\n        # constrained torque and the discrete dynamics equation.\n        # omega_k+1 = omega_k + (h / I) * (tau_ext + tau_motor)\n        omega_next = omega_k + (h / I) * (tau_ext + tau_motor_actual)\n        \n        results.append(omega_next)\n\n    # Format the final output as a single-line, comma-separated list of values\n    # rounded to six decimal places, enclosed in square brackets.\n    # The format string '{r:.6f}' ensures rounding to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2380886"}, {"introduction": "现实世界的机械系统通常在关节处存在“间隙”或“旷量”，这会导致涉及自由飞行、碰撞和持续接触的复杂非光滑动力学。本实践挑战你为一个具有间隙“死区”的系统构建一个时间步进仿真，使用一种预测-校正方案。你将实现检测穿透的逻辑，并根据牛顿恢复定律应用脉冲校正 [@problem_id:2380890]，从而让你实践性地了解仿真器如何随时间处理碰撞和单边约束。", "problem": "考虑一个用于具有对称间隙的松动关节中相对位移的单自由度模型。设标量坐标为 $x(t)$（单位：米），质量为 $m$（单位：千克），外部施加的恒定力为 $F$（单位：牛顿）。该关节具有半宽为 $\\delta$ 米的死区间隙，这意味着当 $x(t) \\in [-\\delta,\\delta]$ 时，不存在约束反力。当与挡块之间的间隙闭合时，会发生碰撞，并通过一个反作用冲量来强制实现非穿透。假设接触面无摩擦，碰撞为无摩擦碰撞，法向恢复系数为 $e \\in [0,1]$。\n\n其动力学由牛顿第二定律以及通过互补性关系描述的单边约束所决定。设上、下间隙分别为 $g_u(x) = \\delta - x$ 和 $g_\\ell(x) = \\delta + x$，并设相应的非负拉格朗日乘子（法向反作用力）为 $\\lambda_u(t) \\ge 0$ 和 $\\lambda_\\ell(t) \\ge 0$。方程如下：\n$$\nm\\,\\ddot{x}(t) = F - \\lambda_u(t) + \\lambda_\\ell(t),\n$$\n$$\ng_u(x(t)) \\ge 0,\\quad \\lambda_u(t) \\ge 0,\\quad g_u(x(t))\\,\\lambda_u(t) = 0,\n$$\n$$\ng_\\ell(x(t)) \\ge 0,\\quad \\lambda_\\ell(t) \\ge 0,\\quad g_\\ell(x(t))\\,\\lambda_\\ell(t) = 0.\n$$\n因此，在死区 $x(t) \\in (-\\delta,\\delta)$ 内，有 $\\lambda_u(t)=\\lambda_\\ell(t)=0$，没有约束力作用。当一个挡块被激活（间隙为零）时，法向反作用力强制实现非穿透。对于发生在挡块处的瞬时碰撞，设 $v^{-}$ 和 $v^{+}$ 分别表示接触构型下碰撞前和碰撞后的速度。法向碰撞定律是牛顿恢复定律，\n$$\nv^{+} = -e v^{-}\n$$\n该定律在物体以一个指向挡块（即离开许可区域）的接近速度 $v^{-}$ 撞击时应用。\n\n从这些原理出发，推导一个一阶时间步进算法，该算法使用固定的时间步长 $\\Delta t$ 秒来推进状态 $(x,v)$，方法如下：\n- 在 $[t_n,t_{n+1}]$ 上进行一次无约束力的自由飞行更新，\n- 然后，如果碰撞时运动是向外的，则通过将位置投影到最近的活动边界并通过一个与上述碰撞定律一致的冲量来校正速度，从而在每一步中最多强制执行一次非穿透。\n\n您的程序必须以纯数学术语实现以下算法：\n- 基于牛顿第二定律 $m\\,\\dot{v} = F$（在步长内 $F$ 为常数）进行自由飞行半隐式更新，以获得一个试验性状态 $(x^{\\mathrm{free}},v^{\\mathrm{free}})$。\n- 如果 $x^{\\mathrm{free}} \\in [-\\delta,\\delta]$，则接受 $(x^{\\mathrm{free}},v^{\\mathrm{free}})$。\n- 如果 $x^{\\mathrm{free}} > \\delta$，则设置 $x^{+} = \\delta$。如果 $v^{\\mathrm{free}} > 0$，则应用碰撞定律设置 $v^{+} = -e v^{\\mathrm{free}}$；否则设置 $v^{+} = v^{\\mathrm{free}}$。\n- 如果 $x^{\\mathrm{free}}  -\\delta$，则设置 $x^{+} = -\\delta$。如果 $v^{\\mathrm{free}}  0$，则应用碰撞定律设置 $v^{+} = -e v^{\\mathrm{free}}$；否则设置 $v^{+} = v^{\\mathrm{free}}$。\n\n在 $t=0$ 时使用以下初始条件校正：如果 $x(0)$ 位于 $[-\\delta,\\delta]$ 之外，则将其投影到最近的边界，并且如果初始速度相对于该边界是向外的，则立即应用相同的碰撞定律。\n\n您的任务是实现此时间步进方案，并为下面给出的每个测试用例计算最终状态 $(x(T),v(T))$。所有物理量都必须使用国际单位制 (SI)：米、千克、秒和牛顿。如有角度，请以弧度表示。输出必须是数值，位置单位为米，速度单位为米/秒。将每个数值输出四舍五入到 $6$ 位小数。\n\n所有测试通用的固定参数如下：\n- 质量 $m = 1.0$ 千克。\n- 间隙半宽 $\\delta = 0.01$ 米。\n- 时间步长 $\\Delta t = 0.0005$ 秒。\n- 最终时间 $T = 0.2$ 秒。\n\n测试套件包括四个案例，用于检验不同的行为：\n- 案例 A（在仿真时长内无接触）：$x(0)=0.0$ 米，$v(0)=0.0$ 米/秒，$F=0.2$ 牛顿，$e=0.6$。\n- 案例 B（在上挡块处发生单次碰撞并部分反弹）：$x(0)=0.0$ 米，$v(0)=0.0$ 米/秒，$F=1.0$ 牛顿，$e=0.5$。\n- 案例 C（在下挡块处发生单次弹性碰撞）：$x(0)=0.0$ 米，$v(0)=0.0$ 米/秒，$F=-1.0$ 牛顿，$e=1.0$。\n- 案例 D（初始穿透通过投影解决，然后静止）：$x(0)=0.015$ 米，$v(0)=0.0$ 米/秒，$F=0.0$ 牛顿，$e=0.0$。\n\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表形式的结果，每个内部列表是按 A、B、C、D 顺序排列的一个案例的最终状态 $[x(T),v(T)]$。确切的所需格式为：\n\"[ [x_A,v_A],[x_B,v_B],[x_C,v_C],[x_D,v_D] ]\"\n每个数字都四舍五入到 $6$ 位小数。", "solution": "所提出的问题具有科学依据、提法恰当且客观。它呈现了一个计算力学中的标准练习，涉及带单边约束系统的数值积分。该物理模型基于牛顿第二定律和接触的互补性表述，是合理的。指定的一阶时间步进数值算法，采用投影方法来强制执行约束，其定义清晰且可实现。所有必要的数据均已提供。因此，该问题是有效的，并将给出一个解。\n\n目标是通过数值积分其运动方程，来确定一个单自由度质点系统的最终状态 $(x(T), v(T))$。该系统受到一个恒定的外力和定义了间隙的单边约束。\n\n系统的动力学由牛顿第二定律对其位置 $x(t)$ 进行描述：\n$$\nm \\ddot{x}(t) = F + F_{\\text{contact}}(t)\n$$\n其中 $m$ 是质量，$F$ 是恒定的外力，$F_{\\text{contact}}(t)$ 代表来自约束的反作用力。约束由一个半宽为 $\\delta$ 的间隙定义，因此容许的位置为 $x(t) \\in [-\\delta, \\delta]$。当质点严格在间隙内部，即 $x(t) \\in (-\\delta, \\delta)$ 时，接触力为零。在边界 $x=\\delta$ 和 $x=-\\delta$ 处，会发生接触。该问题使用由牛顿恢复定律（恢复系数为 $e$）控制的瞬时碰撞来模拟这种接触。\n\n使用固定的时间步长 $\\Delta t$ 构建数值解。系统在时间 $t_n = n \\Delta t$ 的状态由位置和速度对 $(x_n, v_n)$ 给出。将状态从 $t_n$ 推进到 $t_{n+1}$ 的算法是一个两步预测-校正方法。\n\n1.  **自由飞行预测步骤**：首先，通过忽略约束并仅在外力 $F$ 作用下对运动进行积分，计算出 $t_{n+1}$ 时刻的一个试验性状态 $(x^{\\mathrm{free}}, v^{\\mathrm{free}})$。加速度是恒定的，即 $a = F/m$。指定了半隐式欧拉方案：\n    $$\n    v^{\\mathrm{free}} = v_n + a \\Delta t\n    $$\n    $$\n    x^{\\mathrm{free}} = x_n + v^{\\mathrm{free}} \\Delta t\n    $$\n\n2.  **约束强制执行（校正）步骤**：将预测的位置 $x^{\\mathrm{free}}$ 与容许区域 $[-\\delta, \\delta]$ 进行检查。如果位置超出了这个区域（处于穿透状态），则将其投影回最近的边界，并校正速度以模拟碰撞。其逻辑如下：\n\n    - 如果 $x^{\\mathrm{free}} \\in [-\\delta, \\delta]$（无穿透）：接受自由飞行的预测结果。\n      $$\n      x_{n+1} = x^{\\mathrm{free}}, \\quad v_{n+1} = v^{\\mathrm{free}}\n      $$\n\n    - 如果 $x^{\\mathrm{free}} > \\delta$（穿透上边界）：将位置投影到 $x_{n+1} = \\delta$。根据碰撞定律更新速度，该定律仅在预测速度 $v^{\\mathrm{free}}$ 对应于朝向边界的运动（$v^{\\mathrm{free}} > 0$）时适用。\n      $$\n      x_{n+1} = \\delta, \\quad v_{n+1} = \\begin{cases} -e \\, v^{\\mathrm{free}}  \\text{if } v^{\\mathrm{free}} > 0 \\\\ v^{\\mathrm{free}}  \\text{if } v^{\\mathrm{free}} \\le 0 \\end{cases}\n      $$\n\n    - 如果 $x^{\\mathrm{free}}  -\\delta$（穿透下边界）：将位置投影到 $x_{n+1} = -\\delta$。更新速度，对接近速度（$v^{\\mathrm{free}}  0$）应用碰撞定律。\n      $$\n      x_{n+1} = -\\delta, \\quad v_{n+1} = \\begin{cases} -e \\, v^{\\mathrm{free}}  \\text{if } v^{\\mathrm{free}}  0 \\\\ v^{\\mathrm{free}}  \\text{if } v^{\\mathrm{free}} \\ge 0 \\end{cases}\n      $$\n\n**初始条件校正**：在时间步进循环开始之前，检查初始状态 $(x(0), v(0))$。如果 $x(0)$ 已经处于穿透状态，则立即使用与上述校正步骤中描述的相同的投影和碰撞逻辑进行校正。\n\n该算法针对四个指定的测试用例分别实现和执行。仿真从 $t=0$ 运行到最终时间 $T=0.2$ 秒，使用固定参数：质量 $m=1.0$千克，间隙半宽 $\\delta=0.01$米，以及时间步长 $\\Delta t=0.0005$秒。这对应于总共 $N = T/\\Delta t = 400$ 个积分步。最终答案中提供的代码为每个案例计算状态 $(x(T), v(T))$，将数值四舍五入到 $6$ 位小数，并按规定格式化输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a first-order time-stepping algorithm for a 1-DOF system with clearance\n    and computes the final state for several test cases.\n    \"\"\"\n\n    # Fixed physical and simulation parameters\n    m = 1.0  # mass in kg\n    delta = 0.01  # clearance half-width in m\n    dt = 0.0005  # time step in s\n    T = 0.2  # final time in s\n\n    # Test suite: (initial position x0, initial velocity v0, force F, coefficient of restitution e)\n    test_cases = [\n        # Case A: No contact\n        {'x0': 0.0, 'v0': 0.0, 'F': 0.2, 'e': 0.6},\n        # Case B: Single impact, partial rebound\n        {'x0': 0.0, 'v0': 0.0, 'F': 1.0, 'e': 0.5},\n        # Case C: Single impact, elastic\n        {'x0': 0.0, 'v0': 0.0, 'F': -1.0, 'e': 1.0},\n        # Case D: Initial penetration, no force\n        {'x0': 0.015, 'v0': 0.0, 'F': 0.0, 'e': 0.0},\n    ]\n\n    all_final_states = []\n\n    # Calculate the total number of steps\n    num_steps = int(T / dt)\n\n    for case in test_cases:\n        x, v = case['x0'], case['v0']\n        F, e = case['F'], case['e']\n\n        # Step 0: Initial condition correction\n        if x > delta:\n            x = delta\n            # Apply impact law if velocity is outward\n            if v > 0:\n                v = -e * v\n        elif x  -delta:\n            x = -delta\n            # Apply impact law if velocity is outward\n            if v  0:\n                v = -e * v\n        \n        # Calculate constant acceleration\n        accel = F / m\n\n        # Time-stepping loop\n        for _ in range(num_steps):\n            # Step 1: Free-flight prediction (semi-implicit Euler)\n            v_free = v + accel * dt\n            x_free = x + v_free * dt\n\n            # Step 2: Constraint enforcement (projection and correction)\n            if x_free > delta:\n                x = delta\n                if v_free > 0:  # Impact condition\n                    v = -e * v_free\n                else:  # Already separating\n                    v = v_free\n            elif x_free  -delta:\n                x = -delta\n                if v_free  0:  # Impact condition\n                    v = -e * v_free\n                else:  # Already separating\n                    v = v_free\n            else:  # No penetration\n                x = x_free\n                v = v_free\n        \n        # Store the final state, rounded to 6 decimal places\n        all_final_states.append([round(x, 6), round(v, 6)])\n\n    # Format the final output string as per the problem specification\n    # e.g., [[x_A,v_A],[x_B,v_B],...] -> \"[[x_A,v_A],[x_B,v_B],...]\"\n    result_strings = [f\"[{state[0]},{state[1]}]\" for state in all_final_states]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2380890"}]}