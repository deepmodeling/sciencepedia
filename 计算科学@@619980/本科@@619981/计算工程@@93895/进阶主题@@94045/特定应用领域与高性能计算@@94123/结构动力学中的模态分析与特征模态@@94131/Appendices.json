{"hands_on_practices": [{"introduction": "理论知识通过实践才得以升华。我们从一个基本问题开始：我们的主要数值工具——有限元法（FEM）——在多大程度上能够捕捉物理现实？这个练习通过将一个简单的有限元模型与振动弦的精确解析解进行比较，来探讨这一核心问题 [@problem_id:2414089]。这项实践将强化离散化、广义特征值问题 $K\\phi = \\omega^2 M\\phi$ 以及收敛性的概念，是验证计算模型有效性的基础训练。", "problem": "考虑一根长度为 $L$、在恒定张力 $T$ 下、具有均匀线质量密度 $\\mu$ 的理想拉紧弦。其横向位移 $u(x,t)$ 满足一维波动方程，并采用两端固定的边界条件，即 $u(0,t)=0$ 和 $u(L,t)=0$。将该系统作为连续体处理，以获得精确的特征频率和特征模态；同时，使用均匀的分段线性有限元模型对其进行近似，以获得离散的特征频率和特征模态。\n\n对于每个指定的测试用例，您的程序必须从基本原理出发，完成以下任务：\n- 对于连续弦，推导出精确的第 $n$ 阶角特征频率 $\\omega_n^{\\mathrm{exact}}$ 和相应的归一化精确模态振型 $\\phi_n^{\\mathrm{exact}}(x)$，其中归一化是相对于在均匀网格上的节点采样向量的欧几里得范数进行的。\n- 对于在 $[0,L]$ 上使用 $N_e$ 个均匀线性单元的有限元离散化，通过在每个单元上对弱形式进行积分来组装精确的全局刚度矩阵和质量矩阵，施加 $x=0$ 和 $x=L$ 处的固定边界条件，并求解所得的广义特征值问题，以获得第 $n$ 阶离散角特征频率 $\\omega_n^{\\mathrm{fem}}$ 和相应的归一化离散模态振型向量 $\\phi_n^{\\mathrm{fem}}$（通过完整节点向量的欧几里得范数进行归一化，包括值为零的边界节点）。\n- 将离散模态振型与在相同网格节点上采样的精确模态振型进行比较，方法是首先对齐 $\\phi_n^{\\mathrm{fem}}$ 的符号以使其与采样得到的精确模态向量的点积最大化，然后计算最大节点绝对误差。\n- 为每个测试用例计算两个指标：相对角频率误差 $|\\omega_n^{\\mathrm{fem}}-\\omega_n^{\\mathrm{exact}}|/\\omega_n^{\\mathrm{exact}}$（无量纲）和最大节点绝对模态振型误差 $\\max_i|\\phi_{n,i}^{\\mathrm{fem}}-\\phi_{n,i}^{\\mathrm{exact}}|$（无量纲），其中 $i$ 遍历所有网格节点，包括边界节点。\n\n所有测试用例均使用以下物理参数：长度 $L=1\\,\\mathrm{m}$，张力 $T=100\\,\\mathrm{N}$，线密度 $\\mu=0.01\\,\\mathrm{kg/m}$。角量单位必须是弧度/秒。所有误差均以无量纲实数形式报告。\n\n测试套件（每个测试用例是一对 $(N_e,n)$，分别代表均匀单元数量和模态索引）：\n- 用例 1：$(N_e,n)=(2,1)$。\n- 用例 2：$(N_e,n)=(4,1)$。\n- 用例 3：$(N_e,n)=(8,2)$。\n- 用例 4：$(N_e,n)=(16,3)$。\n- 用例 5：$(N_e,n)=(8,7)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身也是一个包含两个实数 $[\\text{frequency\\_relative\\_error},\\text{mode\\_shape\\_max\\_nodal\\_error}]$ 的列表。对于上述五个用例，最终输出格式必须为\n$[[e_{1,f},e_{1,s}],[e_{2,f},e_{2,s}],[e_{3,f},e_{3,s}],[e_{4,f},e_{4,s}],[e_{5,f},e_{5,s}]]$\n其中 $e_{k,f}$ 是用例 $k$ 的相对角频率误差，$e_{k,s}$ 是用例 $k$ 的最大节点绝对模态振型误差。", "solution": "所提出的问题是计算结构动力学中一个明确定义的练习，具体涉及解析解与通过有限元法（FEM）获得的数值近似解的比较。该问题具有科学依据，在数学上是一致的，并且所有必要的参数都已提供。因此，该问题是有效的，我将进行完整的推导和求解。\n\n分析分为三个部分：首先，推导连续系统的精确特征解；其次，建立并求解离散有限元模型；第三，定义用于比较的误差指标。\n\n**1. 连续系统：精确解析解**\n\n理想拉紧弦的横向位移 $u(x,t)$ 由一维波动方程控制：\n$$\n\\mu \\frac{\\partial^2 u}{\\partial t^2} - T \\frac{\\partial^2 u}{\\partial x^2} = 0, \\quad x \\in [0, L]\n$$\n其中 $\\mu$ 是线质量密度， $T$ 是张力， $L$ 是弦的长度， $x$ 是空间坐标， $t$ 是时间。边界条件为两端固定，即 $u(0,t) = 0$ 和 $u(L,t) = 0$。\n\n为了找到自然频率和模态振型（即特征解），我们使用分离变量法寻找驻波解。我们假设解的形式为 $u(x,t) = \\phi(x)q(t)$。将其代入波动方程并整理可得：\n$$\n\\frac{1}{q(t)} \\frac{d^2 q}{dt^2} = \\frac{T}{\\mu} \\frac{1}{\\phi(x)} \\frac{d^2 \\phi}{dx^2}\n$$\n由于左侧仅依赖于 $t$，而右侧仅依赖于 $x$，因此两边必须等于一个常数，我们将其记为 $-\\omega^2$。这产生了两个常微分方程：\n$$\n\\frac{d^2 q}{dt^2} + \\omega^2 q = 0\n$$\n$$\n\\frac{d^2 \\phi}{dx^2} + k^2 \\phi = 0, \\quad \\text{其中 } k^2 = \\frac{\\mu \\omega^2}{T}\n$$\n关于模态振型 $\\phi(x)$ 的空间方程具有以下通解：\n$$\n\\phi(x) = A \\sin(kx) + B \\cos(kx)\n$$\n应用边界条件：\n1.  $\\phi(0) = 0 \\implies A \\sin(0) + B \\cos(0) = 0 \\implies B = 0$。\n2.  $\\phi(L) = 0 \\implies A \\sin(kL) = 0$。对于非平凡解（$A \\neq 0$），我们必须有 $\\sin(kL) = 0$。\n\n当 $kL = n\\pi$（对于任意整数 $n=1, 2, 3, \\dots$）时，此条件得到满足。这使得容许的波数 $k_n$ 被量子化：\n$$\nk_n = \\frac{n\\pi}{L}\n$$\n将此代回关于 $\\omega^2$ 的关系式，我们得到离散的角特征频率集合 $\\omega_n^{\\mathrm{exact}}$：\n$$\n(\\omega_n^{\\mathrm{exact}})^2 = \\frac{T}{\\mu} k_n^2 = \\frac{T}{\\mu} \\left(\\frac{n\\pi}{L}\\right)^2 \\implies \\omega_n^{\\mathrm{exact}} = \\frac{n\\pi}{L} \\sqrt{\\frac{T}{\\mu}}\n$$\n相应的模态振型（特征模态）由下式给出：\n$$\n\\phi_n^{\\mathrm{exact}}(x) = \\sin\\left(\\frac{n\\pi x}{L}\\right)\n$$\n为简单起见，此处振幅已设为1，因为它将通过归一化来处理。为了与具有 $N_e$ 个单元（因此有 $N_e+1$ 个节点）的网格上的FEM解进行比较，我们在节点坐标 $x_i = i \\cdot (L/N_e)$（其中 $i=0, 1, \\dots, N_e$）处对该连续函数进行采样。所得的采样向量必须通过其欧几里得范数进行归一化，得到向量 $\\boldsymbol{\\phi}_n^{\\mathrm{exact}}$。\n\n**2. 离散系统：有限元法**\n\n我们从空间控制方程 $-T u'' = \\omega^2 \\mu u$ 的弱形式开始。对于一个满足相同齐次边界条件（即 $v(0)=v(L)=0$）的测试函数 $v(x)$，其弱形式为：\n$$\n\\int_0^L v(-T u'') dx = \\int_0^L v(\\omega^2 \\mu u) dx\n$$\n对左侧进行分部积分可得：\n$$\n\\int_0^L T u' v' dx - [T u' v]_0^L = \\omega^2 \\int_0^L \\mu u v dx\n$$\n由于 $v(0)=v(L)=0$，边界项 $[T u' v]_0^L$ 为零。弱形式变为：\n$$\n\\int_0^L T u' v' dx = \\omega^2 \\int_0^L \\mu u v dx\n$$\n我们将域 $[0,L]$ 离散为 $N_e$ 个线性单元，每个单元的长度为 $h = L/N_e$。在每个单元内部，位移通过线性形函数 $N_1(\\xi), N_2(\\xi)$ 来近似，其中 $\\xi \\in [0,h]$ 是局部坐标：$u^e(\\xi) = N_1(\\xi) d_1 + N_2(\\xi) d_2$。形函数为 $N_1(\\xi) = 1-\\xi/h$ 和 $N_2(\\xi)=\\xi/h$。\n\n通过将近似解代入弱形式并在一个单元上积分，可以推导出单元刚度矩阵 $k^e$ 和单元质量矩阵 $m^e$：\n$$\nk_{ij}^e = \\int_0^h T N_i' N_j' d\\xi = \\frac{T}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}\n$$\n$$\nm_{ij}^e = \\int_0^h \\mu N_i N_j d\\xi = \\frac{\\mu h}{6} \\begin{pmatrix} 2 & 1 \\\\ 1 & 2 \\end{pmatrix}\n$$\n这是协调质量矩阵（Consistent Mass Matrix）的公式，是进行精确特征分析所必需的。通过对所有 $N_e$ 个单元的贡献求和，可以组装出大小为 $(N_e+1) \\times (N_e+1)$ 的全局矩阵 $K$ 和 $M$。这产生了全局广义特征值问题：\n$$\nK\\boldsymbol{\\phi} = \\omega^2 M\\boldsymbol{\\phi}\n$$\n固定边界条件 $u(0)=0$ 和 $u(L)=0$ 意味着第一个和最后一个节点的位移为零。我们通过从 $K$ 和 $M$ 中移除第一行和最后一行以及第一列和最后一列来施加这一条件，从而为内部节点创建一个大小为 $(N_e-1) \\times (N_e-1)$ 的缩减系统 $K_{red}\\boldsymbol{\\phi}_{red} = \\omega^2 M_{red}\\boldsymbol{\\phi}_{red}$。\n\n求解这个缩减的特征值问题，可以得到 $N_e-1$ 对特征值 $(\\omega_n^{\\mathrm{fem}})^2$ 和特征向量 $\\boldsymbol{\\phi}_{n,red}^{\\mathrm{fem}}$。通过在边界处用零填充缩减后的特征向量，可以重构出完整的模态振型向量 $\\boldsymbol{\\phi}_n^{\\mathrm{fem}}$。然后，该完整向量通过其欧几里得范数进行归一化。\n\n**3. 误差计算**\n\n对于每个测试用例 $(N_e, n)$，我们计算两个指定的指标：\n- **相对频率误差**：第 $n$ 阶有限元特征频率与第 $n$ 阶精确特征频率之间的相对误差。\n$$\ne_f = \\frac{|\\omega_n^{\\mathrm{fem}} - \\omega_n^{\\mathrm{exact}}|}{\\omega_n^{\\mathrm{exact}}}\n$$\n- **最大节点模态振型误差**：首先，我们必须对齐数值计算出的特征向量的符号。一个特征向量 $\\boldsymbol{\\phi}$ 与其负值 $-\\boldsymbol{\\phi}$ 在数学上是等效的。我们通过将 $\\boldsymbol{\\phi}_n^{\\mathrm{fem}}$ 乘以 $\\text{sign}(\\boldsymbol{\\phi}_n^{\\mathrm{fem}} \\cdot \\boldsymbol{\\phi}_n^{\\mathrm{exact}})$ 来确保比较的一致性，其中 $\\boldsymbol{\\phi}_n^{\\mathrm{exact}}$ 是采样得到的精确模态振型值的向量。对齐符号后，误差即为归一化的有限元模态向量和归一化的精确模态向量各分量之差的绝对值的最大值。\n$$\ne_s = \\max_i |\\phi_{n,i}^{\\mathrm{fem}} - \\phi_{n,i}^{\\mathrm{exact}}|\n$$\n此过程为有限元模型在频率和模态振型预测方面的准确性提供了严格的量化。预计更高阶的模态和更粗糙的网格会产生更大的误差。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Solves for the eigenfrequencies and eigenmodes of a taut string using both an\n    analytical continuous model and a discrete finite element model, and computes\n    the error between them for specified test cases.\n    \"\"\"\n    # Physical parameters\n    L = 1.0  # m\n    T = 100.0  # N\n    MU = 0.01  # kg/m\n\n    # Test suite: (Number of elements Ne, Mode index n)\n    test_cases = [\n        (2, 1),\n        (4, 1),\n        (8, 2),\n        (16, 3),\n        (8, 7),\n    ]\n\n    all_results = []\n\n    for Ne, n_mode in test_cases:\n        # --- 1. Exact Analytical Solution ---\n        # Exact angular eigenfrequency\n        omega_exact = (n_mode * np.pi / L) * np.sqrt(T / MU)\n\n        # Nodal coordinates for a mesh with Ne elements\n        num_nodes = Ne + 1\n        nodes = np.linspace(0, L, num_nodes)\n\n        # Sample the exact mode shape at the nodes\n        phi_exact_sampled = np.sin(n_mode * np.pi * nodes / L)\n        \n        # Normalize the sampled exact mode shape vector by its Euclidean norm\n        norm_exact = np.linalg.norm(phi_exact_sampled)\n        # Avoid division by zero if the mode shape is accidentally all zeros\n        phi_exact_normalized = phi_exact_sampled / norm_exact if norm_exact > 0 else phi_exact_sampled\n\n        # --- 2. Finite Element Method (FEM) Solution ---\n        h = L / Ne  # Element length\n\n        # Element stiffness matrix k^e\n        k_e = (T / h) * np.array([[1, -1], [-1, 1]])\n\n        # Element consistent mass matrix m^e\n        m_e = (MU * h / 6.0) * np.array([[2, 1], [1, 2]])\n\n        # Assemble global matrices K and M\n        K_global = np.zeros((num_nodes, num_nodes))\n        M_global = np.zeros((num_nodes, num_nodes))\n\n        for i in range(Ne):\n            # Assembly indices for the two nodes of element i\n            idx = np.array([i, i + 1])\n            K_global[np.ix_(idx, idx)] += k_e\n            M_global[np.ix_(idx, idx)] += m_e\n\n        # Apply fixed-fixed boundary conditions by reducing the system\n        # (remove first and last rows/columns, corresponding to nodes 0 and Ne)\n        internal_dofs = slice(1, Ne)\n        K_red = K_global[internal_dofs, internal_dofs]\n        M_red = M_global[internal_dofs, internal_dofs]\n\n        # Solve the generalized eigenvalue problem: K_red * v = lambda * M_red * v\n        # eigh returns eigenvalues in ascending order and corresponding eigenvectors\n        # The number of internal DoFs is Ne - 1.\n        # This will fail if n_mode > Ne - 1, as the model cannot capture that mode.\n        if n_mode > Ne - 1:\n            # This case is physically not representable by the mesh,\n            # though the problem setup avoids this.\n            all_results.append([np.inf, np.inf])\n            continue\n            \n        eigenvalues, eigenvectors = eigh(K_red, M_red)\n\n        # The n-th eigenvalue (_lambda) corresponds to omega^2\n        # Use (n_mode - 1) for 0-based indexing\n        _lambda = eigenvalues[n_mode - 1]\n        omega_fem = np.sqrt(_lambda)\n\n        # Get the corresponding eigenvector for the reduced system\n        phi_fem_red = eigenvectors[:, n_mode - 1]\n\n        # Reconstruct the full mode shape vector including boundary nodes\n        phi_fem_full = np.zeros(num_nodes)\n        phi_fem_full[internal_dofs] = phi_fem_red\n        \n        # Normalize the full FEM mode shape vector by its Euclidean norm\n        norm_fem = np.linalg.norm(phi_fem_full)\n        phi_fem_normalized = phi_fem_full / norm_fem if norm_fem > 0 else phi_fem_full\n\n        # --- 3. Comparison and Error Calculation ---\n\n        # Align sign of FEM eigenvector to match the exact one\n        if np.dot(phi_fem_normalized, phi_exact_normalized) < 0:\n            phi_fem_normalized *= -1.0\n\n        # Relative angular frequency error\n        freq_rel_error = np.abs(omega_fem - omega_exact) / omega_exact\n\n        # Maximum absolute nodal mode shape error\n        mode_shape_max_error = np.max(np.abs(phi_fem_normalized - phi_exact_normalized))\n\n        all_results.append([freq_rel_error, mode_shape_max_error])\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join([f\"[{e[0]},{e[1]}]\" for e in all_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "2414089"}, {"introduction": "真实的工程结构很少是简单独立的。这个练习将超越解耦的运动，探索几何不对称性如何导致弯曲和扭转振动的耦合——这是航空航天和土木工程中的一个关键现象 [@problem_id:2414127]。通过这个练习，你将学习如何运用基于能量的拉格朗日方法和“假定模态”法来建立一个降阶模型，并理解质量或刚度矩阵中的非对角项如何代表物理耦合。", "problem": "一根长度为 $L$ 的均匀直梁，其截面为开放的非对称形状（例如，C型槽钢），由于剪切中心和质量中心之间存在偏移，会表现出横向弯曲与扭转之间的耦合。假设梁在弯曲方面为简支，在翘曲方面为自由，弯曲中的转动惯量可忽略不计，且无轴向运动。令质量中心的横向位移为 $w(x,t)$，绕梁轴的扭转角为 $\\varphi(x,t)$，两者均相对于剪切中心轴线测量。并令剪切中心与质量中心在 $w$ 方向上存在一个恒定的垂直偏移量 $e$。弯曲采用 Euler–Bernoulli 梁理论，扭转采用 Saint-Venant 理论，并忽略翘曲刚度。使用单项假定模态近似：\n$$\nw(x,t) = q_1(t)\\sin\\left(\\frac{\\pi x}{L}\\right),\\quad \\varphi(x,t) = q_2(t)\\sin\\left(\\frac{\\pi x}{L}\\right),\n$$\n其中 $q_1(t)$ 和 $q_2(t)$ 为广义坐标。\n\n从第一性原理出发，即能量守恒和源自 Newton 定律的 Lagrange 方程，按以下步骤进行，不使用任何专门的简化公式：\n- 使用上述运动学假设，构建梁段的总动能 $T$ 和总势能 $V$。动能必须包括质量中心的平移动能和由扭转引起的转动动能，并明确体现由剪切中心偏移 $e$ 引起的耦合。势能必须包括弯曲应变能和扭转应变能。假设材料密度为 $\\rho$，截面积为 $A$，所关心的弯曲轴的截面二次矩为 $I_b$，（用于质量计算的）绕梁轴的截面极惯性矩为 $I_p$，杨氏模量为 $E$，剪切模量为 $G$， Saint-Venant 扭转常数为 $J$。将 $\\rho$、$A$、$I_b$、$I_p$、$E$、$G$、$J$、$e$ 和 $L$ 视为正常数。角度 $\\varphi$ 使用单位弧度。\n- 应用假定模态分布来计算在 $x\\in[0,L]$ 上的积分，并组装一个 $2\\times 2$ 的质量矩阵 $\\mathbf{M}$ 和一个 $2\\times 2$ 的刚度矩阵 $\\mathbf{K}$，使得运动方程具有以下形式：\n$$\n\\mathbf{M}\\,\\ddot{\\mathbf{q}}(t) + \\mathbf{K}\\,\\mathbf{q}(t) = \\mathbf{0},\\quad \\text{with } \\mathbf{q}(t) = \\begin{bmatrix} q_1(t) \\\\ q_2(t) \\end{bmatrix}.\n$$\n- 建立广义对称特征值问题：\n$$\n\\left(\\mathbf{K} - \\omega^2 \\mathbf{M}\\right)\\mathbf{\\Phi} = \\mathbf{0},\n$$\n并将两个固有圆频率 $\\omega$ 定义为两个特征值 $\\omega^2$ 的正平方根。最终答案以弧度/秒 (rad/s) 表示。\n\n实现一个程序，对下面的每个测试用例，计算两个固有圆频率，按升序排序，并将每个频率四舍五入到恰好 $6$ 位小数。您的程序必须生成单行输出，包含一个由方括号括起来的逗号分隔列表，该列表由按顺序连接每个测试用例的两个频率构成（一个展开的列表）。\n\n始终使用国际单位制（SI）。所有输入均以国际单位制给出。频率以 rad/s 为单位报告。\n\n测试套件（每行定义一个测试用例，形式为元组 $(\\rho, A, I_b, I_p, E, G, J, e, L)$）：\n- 情况 1 (无耦合基线): $(\\; \\rho = 7850,\\; A = 6\\times 10^{-4},\\; I_b = 8\\times 10^{-6},\\; I_p = 6\\times 10^{-6},\\; E = 2.10\\times 10^{11},\\; G = 8.0\\times 10^{10},\\; J = 1.5\\times 10^{-7},\\; e = 0.0,\\; L = 2.0 \\;)$.\n- 情况 2 (通过 $e$ 产生中等耦合): $(\\; \\rho = 7850,\\; A = 6\\times 10^{-4},\\; I_b = 8\\times 10^{-6},\\; I_p = 6\\times 10^{-6},\\; E = 2.10\\times 10^{11},\\; G = 8.0\\times 10^{10},\\; J = 1.5\\times 10^{-7},\\; e = 0.03,\\; L = 2.0 \\;)$.\n- 情况 3 (更强耦合和更弱扭转): $(\\; \\rho = 7850,\\; A = 6\\times 10^{-4},\\; I_b = 8\\times 10^{-6},\\; I_p = 6\\times 10^{-6},\\; E = 2.10\\times 10^{11},\\; G = 8.0\\times 10^{10},\\; J = 8.0\\times 10^{-8},\\; e = 0.05,\\; L = 2.0 \\;)$.\n- 情况 4 (长度效应): $(\\; \\rho = 7850,\\; A = 6\\times 10^{-4},\\; I_b = 8\\times 10^{-6},\\; I_p = 6\\times 10^{-6},\\; E = 2.10\\times 10^{11},\\; G = 8.0\\times 10^{10},\\; J = 1.5\\times 10^{-7},\\; e = 0.03,\\; L = 1.0 \\;)$.\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，例如 $[\\omega_{1,\\text{case }1},\\omega_{2,\\text{case }1},\\omega_{1,\\text{case }2},\\omega_{2,\\text{case }2},\\dots]$，其中每个 $\\omega$ 都四舍五入到恰好 $6$ 位小数，并以 rad/s 表示。", "solution": "该问题要求使用 Lagrange 方法和假定模态离散化，推导具有弯扭耦合动力学特性的梁的运动方程。最终目标是计算系统的固有频率。\n\n问题陈述在其运动学变量的定义上存在一个微小的歧义。它将 $w(x,t)$ 定义为“质量中心的横向位移”，但又说明它是“相对于剪切中心轴线测量的”。在此问题的标准表述中，主要的运动学变量是剪切中心的位移和绕剪切中心的转动，因为这样可以简化势能的表达式。然后，通过考虑质量中心的运动，用这些变量来表达动能。字面上的解释会导致不必要的复杂性。因此，我将在标准的、物理上一致的假设下继续进行，即 $w(x,t)$ 代表剪切中心线的横向位移，而 $\\varphi(x,t)$ 是绕剪切中心线的扭转角。这种解释与问题中引用的 Euler-Bernoulli 弯曲和 Saint-Venant 扭转理论是一致的，这些理论很自然地是相对于剪切中心来建立的。\n\n对于一个保守的线性系统，其控制方程可以从拉格朗日量 $\\mathcal{L} = T - V$ 导出，其中 $T$ 是总动能，$V$ 是总势能。对于一个由一组广义坐标 $\\mathbf{q}$ 描述的系统，其运动方程由 Lagrange 方程给出：\n$$\n\\frac{d}{dt}\\left(\\frac{\\partial \\mathcal{L}}{\\partial \\dot{q}_k}\\right) - \\frac{\\partial \\mathcal{L}}{\\partial q_k} = 0\n$$\n对于平衡位置附近的小振动，动能和势能可以表示为二次型：\n$$\nT = \\frac{1}{2}\\dot{\\mathbf{q}}^T \\mathbf{M} \\dot{\\mathbf{q}}, \\quad V = \\frac{1}{2}\\mathbf{q}^T \\mathbf{K} \\mathbf{q}\n$$\n其中 $\\mathbf{M}$ 是质量矩阵，$\\mathbf{K}$ 是刚度矩阵。这导出矩阵形式的运动方程 $\\mathbf{M}\\ddot{\\mathbf{q}} + \\mathbf{K}\\mathbf{q} = \\mathbf{0}$。\n\n首先，我们构建总动能 $T$。长度为 $dx$ 的梁微元的动能是其质量中心的平移动能与其绕纵轴的转动动能之和。设 $\\rho$ 为材料密度，$A$ 为截面积。单位长度的质量为 $m' = \\rho A$。位于距剪切中心偏移量为 $e$ 处的质量中心，其横向速度 $\\dot{w}_c$ 由刚性截面运动学给出：\n$$\n\\dot{w}_c(x,t) = \\frac{\\partial}{\\partial t} \\left( w(x,t) + e\\varphi(x,t) \\right) = \\dot{w}(x,t) + e\\dot{\\varphi}(x,t)\n$$\n单位长度质量绕剪切中心轴线的极惯性矩为 $I'_p = \\rho I_p$。微分动能 $dT$ 为：\n$$\ndT = \\frac{1}{2} (\\rho A) (\\dot{w}_c)^2 dx + \\frac{1}{2} (\\rho I_p) (\\dot{\\varphi})^2 dx\n$$\n代入 $\\dot{w}_c$ 的表达式：\n$$\ndT = \\frac{1}{2} \\rho A (\\dot{w} + e\\dot{\\varphi})^2 dx + \\frac{1}{2} \\rho I_p \\dot{\\varphi}^2 dx = \\frac{1}{2} \\left[ \\rho A \\dot{w}^2 + 2\\rho A e \\dot{w}\\dot{\\varphi} + \\rho(A e^2 + I_p)\\dot{\\varphi}^2 \\right] dx\n$$\n总动能 $T$ 通过将 $dT$ 在梁长 $L$ 上积分得到。我们代入假定模态 $w(x,t) = q_1(t)\\sin(\\frac{\\pi x}{L})$ 和 $\\varphi(x,t) = q_2(t)\\sin(\\frac{\\pi x}{L})$ 及其时间导数：\n$$\nT = \\frac{1}{2} \\int_0^L \\left[ \\rho A \\dot{q}_1^2\\sin^2\\left(\\frac{\\pi x}{L}\\right) + 2\\rho A e \\dot{q}_1 \\dot{q}_2\\sin^2\\left(\\frac{\\pi x}{L}\\right) + \\rho(A e^2 + I_p) \\dot{q}_2^2\\sin^2\\left(\\frac{\\pi x}{L}\\right) \\right] dx\n$$\n使用定积分 $\\int_0^L \\sin^2(\\frac{\\pi x}{L}) dx = \\frac{L}{2}$，我们得到：\n$$\nT = \\frac{1}{2} \\left[ \\left(\\frac{\\rho A L}{2}\\right)\\dot{q}_1^2 + 2\\left(\\frac{\\rho A e L}{2}\\right)\\dot{q}_1 \\dot{q}_2 + \\left(\\frac{\\rho L(A e^2 + I_p)}{2}\\right)\\dot{q}_2^2 \\right]\n$$\n从这个二次型中，可以确定对称的 $2 \\times 2$ 质量矩阵 $\\mathbf{M}$ 为：\n$$\n\\mathbf{M} = \\begin{bmatrix} M_{11} & M_{12} \\\\ M_{21} & M_{22} \\end{bmatrix} = \\frac{\\rho L}{2} \\begin{bmatrix} A & A e \\\\ A e & A e^2 + I_p \\end{bmatrix}\n$$\n\n接下来，我们构建总势能 $V$。它是弯曲应变能 $V_b$ 和扭转应变能 $V_t$ 的和。根据 Euler-Bernoulli 梁理论，弯曲能为：\n$$\nV_b = \\frac{1}{2} \\int_0^L E I_b \\left(\\frac{\\partial^2 w}{\\partial x^2}\\right)^2 dx\n$$\n根据 Saint-Venant 扭转理论（忽略翘曲），扭转能为：\n$$\nV_t = \\frac{1}{2} \\int_0^L G J \\left(\\frac{\\partial \\varphi}{\\partial x}\\right)^2 dx\n$$\n总势能为 $V = V_b + V_t$。我们代入假定模态及其空间导数：\n$$\n\\frac{\\partial^2 w}{\\partial x^2} = -q_1(t)\\left(\\frac{\\pi}{L}\\right)^2 \\sin\\left(\\frac{\\pi x}{L}\\right), \\quad \\frac{\\partial \\varphi}{\\partial x} = q_2(t)\\left(\\frac{\\pi}{L}\\right) \\cos\\left(\\frac{\\pi x}{L}\\right)\n$$\n$$\nV = \\frac{1}{2} \\int_0^L E I_b \\left[-q_1\\left(\\frac{\\pi}{L}\\right)^2 \\sin\\left(\\frac{\\pi x}{L}\\right)\\right]^2 dx + \\frac{1}{2} \\int_0^L G J \\left[q_2\\left(\\frac{\\pi}{L}\\right) \\cos\\left(\\frac{\\pi x}{L}\\right)\\right]^2 dx\n$$\n$$\nV = \\frac{1}{2} E I_b q_1^2 \\left(\\frac{\\pi}{L}\\right)^4 \\int_0^L \\sin^2\\left(\\frac{\\pi x}{L}\\right) dx + \\frac{1}{2} G J q_2^2 \\left(\\frac{\\pi}{L}\\right)^2 \\int_0^L \\cos^2\\left(\\frac{\\pi x}{L}\\right) dx\n$$\n使用积分 $\\int_0^L \\sin^2(\\frac{\\pi x}{L}) dx = \\frac{L}{2}$ 和 $\\int_0^L \\cos^2(\\frac{\\pi x}{L}) dx = \\frac{L}{2}$：\n$$\nV = \\frac{1}{2} \\left[ \\left(\\frac{E I_b \\pi^4}{2L^3}\\right)q_1^2 + \\left(\\frac{G J \\pi^2}{2L}\\right)q_2^2 \\right]\n$$\n从这个二次型中，可以确定对称的 $2 \\times 2$ 刚度矩阵 $\\mathbf{K}$ 为：\n$$\n\\mathbf{K} = \\begin{bmatrix} K_{11} & K_{12} \\\\ K_{21} & K_{22} \\end{bmatrix} = \\begin{bmatrix} \\frac{E I_b \\pi^4}{2L^3} & 0 \\\\ 0 & \\frac{G J \\pi^2}{2L} \\end{bmatrix}\n$$\n\n在推导出质量和刚度矩阵后，我们建立广义特征值问题。假设谐波运动形式为 $\\mathbf{q}(t) = \\mathbf{\\Phi} e^{i\\omega t}$，其中 $\\mathbf{\\Phi}$ 是模态振型向量，$\\omega$ 是固有频率，则运动方程 $\\mathbf{M}\\ddot{\\mathbf{q}} + \\mathbf{K}\\mathbf{q} = \\mathbf{0}$ 变为：\n$$\n(-\\omega^2 \\mathbf{M} + \\mathbf{K})\\mathbf{\\Phi} = \\mathbf{0} \\quad \\text{or} \\quad (\\mathbf{K} - \\omega^2 \\mathbf{M})\\mathbf{\\Phi} = \\mathbf{0}\n$$\n这是一个关于特征值 $\\lambda = \\omega^2$ 和特征向量 $\\mathbf{\\Phi}$ 的广义特征值问题。对于每组给定的物理参数，我们构建矩阵 $\\mathbf{M}$ 和 $\\mathbf{K}$，并求解两个特征值 $\\lambda_1, \\lambda_2$。然后，两个固有圆频率为 $\\omega_1 = \\sqrt{\\lambda_1}$ 和 $\\omega_2 = \\sqrt{\\lambda_2}$。所提供的代码实现了这个过程，以计算每个测试用例的频率。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eig\n\ndef solve():\n    \"\"\"\n    Computes the first two natural frequencies for a beam with coupled\n    bending-torsion vibrations based on a 2-DOF assumed-mode model.\n    \"\"\"\n\n    # Test suite: (rho, A, I_b, I_p, E, G, J, e, L)\n    test_cases = [\n        # Case 1 (no coupling baseline)\n        (7850, 6e-4, 8e-6, 6e-6, 2.10e11, 8.0e10, 1.5e-7, 0.0, 2.0),\n        # Case 2 (moderate coupling via e)\n        (7850, 6e-4, 8e-6, 6e-6, 2.10e11, 8.0e10, 1.5e-7, 0.03, 2.0),\n        # Case 3 (stronger coupling and weaker torsion)\n        (7850, 6e-4, 8e-6, 6e-6, 2.10e11, 8.0e10, 8.0e-8, 0.05, 2.0),\n        # Case 4 (length effect)\n        (7850, 6e-4, 8e-6, 6e-6, 2.10e11, 8.0e10, 1.5e-7, 0.03, 1.0),\n    ]\n\n    all_frequencies = []\n\n    for case in test_cases:\n        rho, A, I_b, I_p, E, G, J, e, L = case\n\n        # Construct the 2x2 mass matrix M\n        m_factor = rho * L / 2.0\n        M11 = m_factor * A\n        M12 = m_factor * A * e\n        M22 = m_factor * (A * e**2 + I_p)\n        M = np.array([[M11, M12], [M12, M22]])\n\n        # Construct the 2x2 stiffness matrix K\n        K11 = (E * I_b * np.pi**4) / (2.0 * L**3)\n        K22 = (G * J * np.pi**2) / (2.0 * L)\n        K = np.array([[K11, 0.0], [0.0, K22]])\n\n        # Solve the generalized eigenvalue problem (K - w^2 * M) * v = 0\n        # eig returns eigenvalues (w^2) and eigenvectors (v)\n        # We only need the eigenvalues\n        eigenvalues, _ = eig(K, M)\n\n        # The eigenvalues should be real and positive.\n        # Take the real part to handle potential small imaginary parts from numerics.\n        # Frequencies are the square roots of the eigenvalues.\n        frequencies = np.sqrt(np.real(eigenvalues))\n\n        # Sort frequencies in ascending order\n        frequencies.sort()\n\n        # Round to 6 decimal places and add to the final list\n        all_frequencies.extend(np.round(frequencies, 6))\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, all_frequencies))}]\")\n\nsolve()\n```", "id": "2414127"}, {"introduction": "当我们微调一个设计参数，例如某个组件的刚度时，系统的动态特性会发生什么变化？这个练习将研究“模态转向”（Mode Veering）这一微妙但至关重要的现象，即当一个系统参数被调整时，模态似乎会交换其特性 [@problem_id:2414070]。这项实践引入了参数相关的特征值问题和模态置信准则（MAC）这一强大的模态跟踪工具，它揭示了仅仅按频率大小顺序来追踪模态可能会产生误导。", "problem": "考虑一个无阻尼、线性、时不变的多自由度结构系统，其质量矩阵 $M \\in \\mathbb{R}^{n \\times n}$（单位：千克）和刚度矩阵 $K(p) \\in \\mathbb{R}^{n \\times n}$（单位：牛顿/米）均为对称正定矩阵。其中，刚度矩阵依赖于一个标量调谐参数 $p$（单位：牛顿/米）。对于每一个固定的 $p$ 值，自由振动问题由以下广义特征值问题描述：\n$$\nK(p)\\,\\phi = \\lambda\\,M\\,\\phi,\n$$\n其中 $\\lambda \\ge 0$，对应的固有圆频率（单位：弧度/秒）由 $\\omega = \\sqrt{\\lambda}$ 给出。相关的振型是特征向量 $\\phi \\ne 0$，其定义可相差一个非零标量乘子。两个振型 $\\phi$ 和 $\\psi$ 相对于质量矩阵 $M$ 的模态置信准则 (Modal Assurance Criterion, MAC) 定义为：\n$$\n\\mathrm{MAC}_M(\\phi,\\psi) = \\frac{\\left|\\phi^\\top M \\psi\\right|^2}{\\left(\\phi^\\top M \\phi\\right)\\left(\\psi^\\top M \\psi\\right)} \\in [0,1].\n$$\n振型规避（Mode veering）指的是这样一种现象：当参数 $p$ 缓慢变化时，两个相近的模态交换其特性，但并未发生实际的特征频率交叉。这种现象通常在两个子系统之间存在弱耦合时观察到。\n\n您的任务是编写一个完整的、可运行的程序。对于下面指定的每个测试案例，该程序需在给定的有限参数值集合上，评估两个最小的固有圆频率，检测出使它们间隔最小的参数，并使用模态置信准则量化在最小参数值处的第一阶振型与在最大参数值处的第一阶或第二阶振型哪个相关性更强。\n\n对于每个测试案例 $i$，使用所提供的精确参数集执行以下操作：\n1) 对于每个列出的 $p$ 值，求解广义特征值问题，计算两个最小的固有圆频率（单位：弧度/秒），并计算它们的绝对差值（频率间隔，单位：弧度/秒）。确定该间隔最小时的参数值 $p^\\star$（单位：牛顿/米）。如果出现平局，选择达到最小间隔的 $p$ 值中最小的那个。\n2) 令 $p_{\\min}$ 为所列 $p$ 中的最小值，$p_{\\max}$ 为所列 $p$ 中的最大值。令 $\\phi_1(p_{\\min})$ 表示在 $p_{\\min}$ 处的第一阶振型（与最小固有圆频率相关联），令 $\\phi_1(p_{\\max})$ 和 $\\phi_2(p_{\\max})$ 分别表示在 $p_{\\max}$ 处的第一阶和第二阶振型。计算 $\\mathrm{MAC}_M\\!\\left(\\phi_1(p_{\\min}),\\phi_1(p_{\\max})\\right)$ 和 $\\mathrm{MAC}_M\\!\\left(\\phi_1(p_{\\min}),\\phi_2(p_{\\max})\\right)$。定义一个整数交换指示符，如果\n$$\n\\mathrm{MAC}_M\\!\\left(\\phi_1(p_{\\min}),\\phi_2(p_{\\max})\\right) > \\mathrm{MAC}_M\\!\\left(\\phi_1(p_{\\min}),\\phi_1(p_{\\max})\\right),\n$$\n则其值为 $1$，否则为 $0$。\n\n单位和报告要求：\n- 报告 $p^\\star$ 值，单位为牛顿/米，四舍五入到 $6$ 位小数。\n- 报告最小频率间隔，单位为弧度/秒，四舍五入到 $6$ 位小数。\n- 报告交换指示符，为整数 $0$ 或 $1$。\n- 不涉及角度；不需要角度单位。\n- 不涉及百分比。\n\n测试套件（三个案例）：\n- 案例 $1$（双自由度）：$M = \\mathrm{diag}(1,1)$ 千克，以及\n$$\nK(p) = \\begin{bmatrix} p + 0.3 & -0.3 \\\\ -0.3 & 2.0 + 0.3 \\end{bmatrix} \\ \\text{牛顿/米},\n$$\n参数集为\n$$\np \\in \\{\\, 0.5,\\, 0.8,\\, 1.1,\\, 1.4,\\, 1.7,\\, 2.0,\\, 2.3,\\, 2.6,\\, 2.9 \\,\\} \\ \\text{牛顿/米}.\n$$\n- 案例 $2$（双自由度，非耦合边界情况）：$M = \\mathrm{diag}(1,1)$ 千克，以及\n$$\nK(p) = \\begin{bmatrix} p & 0.0 \\\\ 0.0 & 2.0 \\end{bmatrix} \\ \\text{牛顿/米},\n$$\n使用相同的参数集\n$$\np \\in \\{\\, 0.5,\\, 0.8,\\, 1.1,\\, 1.4,\\, 1.7,\\, 2.0,\\, 2.3,\\, 2.6,\\, 2.9 \\,\\} \\ \\text{牛顿/米}.\n$$\n- 案例 $3$（三自由度，具有一个刚性第三模态）：$M = \\mathrm{diag}(1,1,1)$ 千克，以及\n$$\nK(p) = \\begin{bmatrix}\np + 0.2 & -0.2 & 0.0 \\\\\n-0.2 & 2.5 + 0.2 & 0.0 \\\\\n0.0 & 0.0 & 40.0\n\\end{bmatrix} \\ \\text{牛顿/米},\n$$\n参数集为\n$$\np \\in \\{\\, 1.5,\\, 1.8,\\, 2.1,\\, 2.4,\\, 2.7,\\, 3.0 \\,\\} \\ \\text{牛顿/米}.\n$$\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含结果，格式为一个包含三个列表的逗号分隔列表，按案例 $1$、$2$ 和 $3$ 的顺序排列。每个内部列表必须为 $[p^\\star,\\ \\text{gap}_{\\min},\\ \\text{exchange}]$ 的形式，其中 $p^\\star$ 和 $\\text{gap}_{\\min}$ 是四舍五入到 $6$ 位小数的浮点数，$\\text{exchange}$ 是整数 $0$ 或 $1$。\n- 例如，输出必须具有以下形式\n$$\n[\\,[p^\\star_1,\\ \\text{gap}_{\\min,1},\\ \\text{exchange}_1],\\ [p^\\star_2,\\ \\text{gap}_{\\min,2},\\ \\text{exchange}_2],\\ [p^\\star_3,\\ \\text{gap}_{\\min,3},\\ \\text{exchange}_3]\\,],\n$$\n打印在单行上，无其他文本。", "solution": "所述问题是有效的。它在科学上基于线性结构动力学的原理，特别是多自由度系统的自由振动分析。质量矩阵 $M$、刚度矩阵 $K(p)$、广义特征值问题、固有频率 $\\omega$、振型 $\\phi$ 以及模态置信准则 ($\\mathrm{MAC}$) 的定义都是标准且正确的。所提供的矩阵是对称的，并且已经验证，在给定的参数 $p$ 范围内，它们也是正定的，这确保了一个具有实数正频率的适定物理问题。该任务是一个清晰客观的计算练习，可以确定唯一的解。我们将着手求解。\n\n问题的核心是求解结构系统的广义特征值问题：\n$$\nK(p)\\,\\phi = \\lambda\\,M\\,\\phi\n$$\n这里，$K(p)$ 是依赖于参数 $p$ 的刚度矩阵，$M$ 是质量矩阵，$\\lambda$ 是特征值（固有圆频率的平方），$\\phi$ 是特征向量（振型）。我们的任务是分析当 $p$ 在给定的离散集合上变化时，两个最低固有频率 $\\omega_1(p) = \\sqrt{\\lambda_1(p)}$ 和 $\\omega_2(p) = \\sqrt{\\lambda_2(p)}$ 的行为。\n\n对于每个测试案例，将通过以下系统步骤实施解决方案：\n\n1.  **迭代特征求解**：对于指定集合 $\\{p_j\\}$ 中的每个参数值 $p_j$，我们构建特定的刚度矩阵 $K(p_j)$。然后，我们使用可靠的数值算法求解广义特征值问题 $K(p_j)\\phi = \\lambda M \\phi$。这将产生一组按升序排列的特征值 $\\lambda_i(p_j)$ 及其对应的 M-正交归一化的特征向量 $\\phi_i(p_j)$。我们关心的是前两个特征对：($\\lambda_1$, $\\phi_1$) 和 ($\\lambda_2$, $\\phi_2$)。\n\n2.  **频率间隔计算**：根据特征值，我们计算两个最小的固有圆频率，$\\omega_1(p_j) = \\sqrt{\\lambda_1(p_j)}$ 和 $\\omega_2(p_j) = \\sqrt{\\lambda_2(p_j)}$。频率间隔则是它们的绝对差值，$\\Delta\\omega(p_j) = \\omega_2(p_j) - \\omega_1(p_j)$。我们收集所有 $p_j$ 对应的这些间隔。\n\n3.  **确定最小间隔**：我们搜索计算出的间隔以找到最小值。出现此最小值的参数值被指定为 $p^\\star$。如果多个 $p_j$ 值产生相同的最小间隔，则根据问题的平局决胜规则选择其中最小的 $p_j$。最小间隔本身表示为 $\\text{gap}_{\\min}$。\n\n4.  **振型相关性分析**：这一步量化了振型规避现象。我们确定最小参数值处的第一阶振型 $\\phi_1(p_{\\min})$，以及最大参数值处的前两阶振型 $\\phi_1(p_{\\max})$ 和 $\\phi_2(p_{\\max})$。然后我们采用模态置信准则，其定义为：\n    $$\n    \\mathrm{MAC}_M(\\phi_a,\\psi_b) = \\frac{\\left|\\phi_a^\\top M \\psi_b\\right|^2}{\\left(\\phi_a^\\top M \\phi_a\\right)\\left(\\psi_b^\\top M \\psi_b\\right)}\n    $$\n    该准则为任意两个振型 $\\phi_a$ 和 $\\psi_b$ 提供一个介于 $0$（不相关）和 $1$（完全相关）之间的标量值。请注意，由于数值求解器得到的特征向量已经过归一化，使得 $\\phi^\\top M \\phi = 1$，因此 MAC 表达式中的分母为 1，这简化了计算。然而，为了数值稳健性，我们计算完整的表达式。\n\n5.  **交换指示符**：我们计算两个 $\\mathrm{MAC}$ 值：第一个比较初始第一阶振型与最终第一阶振型，$C_{11} = \\mathrm{MAC}_M(\\phi_1(p_{\\min}), \\phi_1(p_{\\max}))$，第二个比较初始第一阶振型与最终第二阶振型，$C_{12} = \\mathrm{MAC}_M(\\phi_1(p_{\\min}), \\phi_2(p_{\\max}))$。如果初始振型与最终第二阶振型更相似，则发生了模态交换。因此，交换指示符定义为一个整数，如果 $C_{12} > C_{11}$ 则为 $1$，否则为 $0$。\n\n这个完整的算法将应用于所提供的三个测试案例中的每一个。结果，包括每个案例的 $p^\\star$、$\\text{gap}_{\\min}$ 和交换指示符，将按要求进行格式化和呈现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to solve the modal analysis problem for the given test cases.\n    \"\"\"\n\n    def mac_m(phi_a, phi_b, M):\n        \"\"\"\n        Calculates the Mass-based Modal Assurance Criterion (MAC).\n        \n        Args:\n            phi_a (np.ndarray): First mode shape vector.\n            phi_b (np.ndarray): Second mode shape vector.\n            M (np.ndarray): Mass matrix.\n        \n        Returns:\n            float: The MAC value.\n        \"\"\"\n        numerator = np.abs(phi_a.T @ M @ phi_b)**2\n        denominator = (phi_a.T @ M @ phi_a) * (phi_b.T @ M @ phi_b)\n        \n        # Avoid division by zero in case of null vectors, though not expected here.\n        if denominator < 1e-12:\n            return 0.0\n        return numerator / denominator\n\n    def process_case(M, K_func, p_values):\n        \"\"\"\n        Processes a single test case to find p_star, min_gap, and exchange_indicator.\n        \"\"\"\n        modal_data = []\n        p_values_sorted = sorted(p_values)\n\n        for p in p_values_sorted:\n            K = K_func(p)\n            \n            # Solve the generalized eigenvalue problem: K*phi = lambda*M*phi\n            # scipy.linalg.eigh returns eigenvalues in ascending order.\n            eigenvalues, eigenvectors = eigh(K, M)\n            \n            # We need the two smallest natural frequencies and their modes.\n            omega_1 = np.sqrt(eigenvalues[0])\n            omega_2 = np.sqrt(eigenvalues[1])\n            gap = omega_2 - omega_1\n            \n            phi_1 = eigenvectors[:, 0]\n            phi_2 = eigenvectors[:, 1]\n            \n            modal_data.append({'p': p, 'gap': gap, 'phi1': phi_1, 'phi2': phi_2})\n            \n        # 1) Find p_star for minimum gap, with tie-breaking for smallest p.\n        min_gap_data = min(modal_data, key=lambda x: (x['gap'], x['p']))\n        p_star = min_gap_data['p']\n        min_gap = min_gap_data['gap']\n        \n        # 2) Get modes at p_min and p_max for MAC calculation.\n        # Since p_values are sorted, modal_data is also implicitly sorted by 'p'.\n        phi1_at_p_min = modal_data[0]['phi1']\n        \n        p_max_data = modal_data[-1]\n        phi1_at_p_max = p_max_data['phi1']\n        phi2_at_p_max = p_max_data['phi2']\n        \n        # Compute MAC values to check for mode exchange.\n        mac_11 = mac_m(phi1_at_p_min, phi1_at_p_max, M)\n        mac_12 = mac_m(phi1_at_p_min, phi2_at_p_max, M)\n        \n        exchange_indicator = 1 if mac_12 > mac_11 else 0\n        \n        return [p_star, min_gap, exchange_indicator]\n\n    # Define the test cases from the problem statement.\n    # --- Case 1 ---\n    M1 = np.diag([1.0, 1.0])\n    def K1_func(p):\n        return np.array([\n            [p + 0.3, -0.3],\n            [-0.3, 2.0 + 0.3]\n        ])\n    p1_values = [0.5, 0.8, 1.1, 1.4, 1.7, 2.0, 2.3, 2.6, 2.9]\n    \n    # --- Case 2 ---\n    M2 = np.diag([1.0, 1.0])\n    def K2_func(p):\n        return np.array([\n            [p, 0.0],\n            [0.0, 2.0]\n        ])\n    p2_values = p1_values\n    \n    # --- Case 3 ---\n    M3 = np.diag([1.0, 1.0, 1.0])\n    def K3_func(p):\n        return np.array([\n            [p + 0.2, -0.2, 0.0],\n            [-0.2, 2.5 + 0.2, 0.0],\n            [0.0, 0.0, 40.0]\n        ])\n    p3_values = [1.5, 1.8, 2.1, 2.4, 2.7, 3.0]\n    \n    test_cases = [\n        (M1, K1_func, p1_values),\n        (M2, K2_func, p2_values),\n        (M3, K3_func, p3_values)\n    ]\n\n    all_results = []\n    for M, K_func, p_values in test_cases:\n        result = process_case(M, K_func, p_values)\n        all_results.append(result)\n\n    # Format the final output string as specified.\n    result_strings = []\n    for res in all_results:\n        p_star, min_gap, exchange = res\n        result_strings.append(f'[{p_star:.6f}, {min_gap:.6f}, {exchange}]')\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "2414070"}]}