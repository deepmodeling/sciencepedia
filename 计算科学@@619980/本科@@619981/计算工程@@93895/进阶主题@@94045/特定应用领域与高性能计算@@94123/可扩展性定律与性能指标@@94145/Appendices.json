{"hands_on_practices": [{"introduction": "理解并行化带来的性能提升通常始于 Amdahl 定律。这一基本原则通过识别任务中固有的串行部分，帮助我们量化最大预期改进。本练习将引导你完成一个经典场景——并行软件编译——来计算理论加速比 $S(N)$，并让你直观地理解，无论增加多少处理器，串行瓶颈都将如何限制性能 [@problem_id:2433433]。", "problem": "一个大型软件项目使用一个支持并行作业执行的依赖感知构建工具进行构建，其最大并发数为 $N$ 个作业（通过一个类似于 \"make -j N\" 的标志来调用）。在单核上，通过仔细的性能分析，得到了一次完整构建单个可执行文件的端到端时间线如下：\n\n- 构建前的依赖发现、规则扩展和全局任务图构建：$12$ s。此阶段由一个单线程工具实现。\n- 真正的编译过程（每个翻译单元的预处理、解析、优化和代码生成）：$340$ s 的中央处理器（CPU）时间，这部分工作一旦输入存在，就可以被划分为独立的任务。\n- 源文件和头文件的输入/输出（I/O）：总计 $48$ s 时间，由于在此环境中存在单个共享存储设备和串行化的文件系统路径，这部分时间无法通过增加更多CPU核心来加速。将其视为固有串行。\n- 最终链接和打包以生成可执行文件：$20$ s。此步骤只有一个消费者，它仅在所有目标文件都存在后才开始，并按顺序执行。\n\n假设只有CPU密集型的编译工作可以在 $N$ 个完美负载均衡的相同核心上并行化，且没有超出所述阶段的额外运行时开销。在此环境中，所有其他阶段都是固有串行的。\n\n仅使用第一性原理（求解时间和加速比的定义）和上述场景，推导理论加速比作为 $N$ 的函数的表达式，然后在 $N=12$ 时求值。将最终答案表示为一个无单位的数，并四舍五入到四位有效数字。", "solution": "对问题陈述进行验证。\n\n步骤1：提取已知条件\n- 最大并发数：$N$ 个作业\n- 预构建阶段时间（串行）：$T_{pre-build} = 12$ s\n- 编译CPU时间（可并行化）：$T_{compile,cpu} = 340$ s\n- 源文件和头文件I/O时间（串行）：$T_{io} = 48$ s\n- 最终链接和打包时间（串行）：$T_{link} = 20$ s\n- 假设编译工作可以在 $N$ 个核心上完美并行化。\n- 所有其他指定的阶段都是固有串行的。\n- 任务是推导理论加速比 $S$ 作为 $N$ 的函数，并在 $N=12$ 时求值，结果四舍五入到四位有效数字。\n\n步骤2：使用提取的已知条件进行验证\n该问题具有科学依据，是适定且客观的。它描述了一个应用 Amdahl's Law 的经典场景，这是计算工程和并行计算中的一个基本原理。所提供的数据是自洽、一致且合理的。诸如完美负载均衡和零开销之类的假设，是用于分离因串行瓶颈导致的可扩展性限制这一核心概念的标准理想化方法。该问题没有缺陷；它是一个直接的性能建模练习。\n\n步骤3：结论与行动\n问题有效。将提供解决方案。\n\n完成一项任务的总时间可以分解为两个部分：一个固有串行的部分和一个可并行的部分。设 $T_{serial}$ 为串行任务消耗的总时间，而 $T_{parallel}$ 为可并行化任务在单核上执行时消耗的时间。\n\n根据问题陈述，总串行时间是预构建、I/O 和链接阶段的时间之和：\n$$T_{serial} = T_{pre-build} + T_{io} + T_{link}$$\n$$T_{serial} = 12\\,\\text{s} + 48\\,\\text{s} + 20\\,\\text{s} = 80\\,\\text{s}$$\n\n可并行化的工作部分是真正的编译过程，在单核上需要 $T_{parallel} = 340\\,\\text{s}$ 的CPU时间。\n\n在单核上的总求解时间，我们记为 $T(1)$，是串行和并行部分之和：\n$$T(1) = T_{serial} + T_{parallel} = 80\\,\\text{s} + 340\\,\\text{s} = 420\\,\\text{s}$$\n\n当任务在 $N$ 个核心上执行时，串行部分的时间保持不变。在完美并行化和负载均衡的假设下，可并行化部分的时间减少为原来的 $1/N$。因此，在 $N$ 个核心上的总求解时间 $T(N)$ 为：\n$$T(N) = T_{serial} + \\frac{T_{parallel}}{N}$$\n代入已知值，我们得到求解时间作为 $N$ 的函数的表达式：\n$$T(N) = 80 + \\frac{340}{N}$$\n\n理论加速比 $S(N)$ 定义为在单个处理器上的求解时间与在 $N$ 个处理器上的求解时间之比。\n$$S(N) = \\frac{T(1)}{T(N)}$$\n\n使用推导出的 $T(1)$ 和 $T(N)$ 表达式，我们得到加速比的通用公式：\n$$S(N) = \\frac{T_{serial} + T_{parallel}}{T_{serial} + \\frac{T_{parallel}}{N}}$$\n将数值代入此表达式可得：\n$$S(N) = \\frac{420}{80 + \\frac{340}{N}}$$\n这就是所要求的理论加速比作为 $N$ 的函数的表达式。\n\n问题要求计算当 $N=12$ 时的加速比。\n$$S(12) = \\frac{420}{80 + \\frac{340}{12}}$$\n我们首先计算分母：\n$$80 + \\frac{340}{12} = 80 + \\frac{85}{3} = \\frac{240}{3} + \\frac{85}{3} = \\frac{325}{3}$$\n现在我们计算加速比：\n$$S(12) = \\frac{420}{\\frac{325}{3}} = \\frac{420 \\times 3}{325} = \\frac{1260}{325}$$\n为简化此分数，我们可以将分子和分母同除以它们的最大公约数。两者均可被 $5$ 整除：\n$$S(12) = \\frac{252}{65}$$\n执行除法以获得小数值：\n$$S(12) = 3.876923...$$\n问题要求将答案四舍五入到四位有效数字。\n$$S(12) \\approx 3.877$$\n此结果与 Amdahl's Law 一致，该定律表明加速比最终受到代码中串行部分比例的限制。在本例中，串行部分比例为 $\\frac{80}{420} \\approx 0.19$，这决定了最大理论加速比为 $\\frac{1}{0.19...} = \\frac{420}{80} = 5.25$，无论使用多少核心。我们计算出的 $N=12$ 时的结果正确地低于此上限。", "answer": "$$\\boxed{3.877}$$", "id": "2433433"}, {"introduction": "尽管某些问题被称为“易于并行”，但它们在现实世界中的性能可能出乎意料地复杂。本练习超越了 Amdahl 定律简单的串行-并行划分，旨在模拟实践中出现的更微妙的瓶颈，例如对共享硬件资源的争用以及合并多处理器结果的成本。通过分析蒙特卡洛模拟，你将看到即使在高度可并行化的任务中，这些因素也可能限制其可扩展性 [@problem_id:2433427]。", "problem": "蒙特卡洛估计量通过对独立试验的贡献进行平均来计算一个量。考虑一个执行总共 $N$ 次独立试验的实现，其中每次试验：\n- 使用随机数生成（RNG）抽取 $k$ 个独立的随机数，以及\n- 对这 $k$ 个数执行一个计算核心程序。\n\n假设具有以下硬件和软件特性：\n- 在中央处理器（CPU）上，每次试验的计算核心程序时间为 $t_{c}$ 秒。\n- CPU 上的软件 RNG 每个随机数需要 $t_{r,\\mathrm{cpu}}$ 秒。\n- 此外，存在一个共享硬件 RNG 服务，其总吞吐量为 $\\Theta$ 个随机数/秒，可供所有进程共同使用。生成随机数的时间受限于 CPU 软件 RNG 能力和共享硬件 RNG 吞吐量中较慢的一个。\n- 所有试验完成后，通过使用深度为 $\\lceil \\log_{2}(p) \\rceil$ 的二叉树对 $p$ 个部分和进行归约，从而获得单个全局标量结果，其中每个归约步骤会产生 $\\alpha$ 秒的延迟和与消息大小 $m$ 字节成正比的时间 $\\beta m$。\n- 存在一个 $t_{0}$ 秒的串行种子设定和设置成本，该成本无法并行化。\n\n将 $p$ 个并行进程上的加速比定义为 $S(p) = \\dfrac{T(1)}{T(p)}$，其中 $T(p)$ 是使用 $p$ 个进程完成所有 $N$ 次试验然后执行归约得到单个结果所需的总挂钟时间。\n\n使用以下参数：\n- $N = 10^{8}$，\n- $k = 2$，\n- $t_{c} = 3.0 \\times 10^{-8}$ 秒，\n- $t_{r,\\mathrm{cpu}} = 1.5 \\times 10^{-8}$ 秒，\n- $\\Theta = 2.0 \\times 10^{9}$ 个随机数/秒，\n- $\\alpha = 1.0 \\times 10^{-6}$ 秒，\n- $\\beta = 5.0 \\times 10^{-10}$ 秒/字节，\n- $m = 16$ 字节，\n- $t_{0} = 5.0 \\times 10^{-2}$ 秒。\n\n假设 $N$ 次试验在 $p$ 个进程之间平均分配，每次试验的计算核心程序时间和 RNG 时间相加，归约使用上述二叉树，并且共享硬件 RNG 吞吐量 $\\Theta$ 是所有 $p$ 个进程的单一全局限制。\n\n计算当 $p = 128$ 时的加速比 $S(p)$。将最终加速比表示为一个无单位的数，并将您的答案四舍五入到四位有效数字。", "solution": "问题要求计算在 $p$ 个并行进程上运行的蒙特卡洛模拟的加速比 $S(p)$，定义为 $S(p) = \\frac{T(1)}{T(p)}$。为了计算这个值，我们必须首先为总挂钟时间 $T(p)$ 建立一个形式化模型。\n\n总时间 $T(p)$ 是三个按顺序执行的不同阶段的总和：一个串行设置阶段，一个并行试验执行阶段，以及一个最终的并行归约阶段。\n$$T(p) = T_{\\text{setup}} + T_{\\text{trials}}(p) + T_{\\text{reduction}}(p)$$\n\n各个组成部分的定义如下：\n$1$. 串行设置时间是一个常数，给定为 $T_{\\text{setup}} = t_{0}$。这个部分不随进程数 $p$ 扩展。\n\n$2$. 并行试验执行时间 $T_{\\text{trials}}(p)$ 是完成分布在 $p$ 个进程上的所有 $N$ 次试验所需的时间。由于 $N$ 次试验被平均分配，每个进程处理 $N/p$ 次试验。此阶段的时间由最后一个完成的进程决定。由于工作负载是均衡的，所有进程会同时完成。每次试验内部的工作包括随机数生成（RNG）和执行一个计算核心程序。问题陈述它们的耗时是相加的。因此，试验阶段的总时间是计算时间和 RNG 时间的总和。\n\n计算部分是完全并行的。总计算工作量为 $N t_c$。在 $p$ 个进程上，这需要：\n$$T_{\\text{compute}}(p) = \\frac{N t_c}{p}$$\n\nRNG 部分更复杂。总共需要生成 $N k$ 个随机数。时间受限于两个资源中较慢的一个：每个 CPU 上的分布式软件 RNG 和共享硬件 RNG。\n- 如果仅受软件 RNG 限制，时间将是一个进程生成其部分随机数所需的时间，即 $\\frac{N}{p} k t_{r,\\mathrm{cpu}}$。\n- 如果仅受共享硬件 RNG 限制，时间由其总吞吐量 $\\Theta$ 决定。生成 $N k$ 个随机数的总时间是 $\\frac{N k}{\\Theta}$。这是一个全局瓶颈，不随 $p$ 扩展。\nRNG 的实际时间是这两个值的最大值，因为进程的完成速度不能快于其最严格的限制。\n$$T_{\\text{RNG}}(p) = \\max\\left(\\frac{N k t_{r,\\mathrm{cpu}}}{p}, \\frac{N k}{\\Theta}\\right)$$\n因此，试验阶段的总时间是：\n$$T_{\\text{trials}}(p) = T_{\\text{compute}}(p) + T_{\\text{RNG}}(p) = \\frac{N t_c}{p} + \\max\\left(\\frac{N k t_{r,\\mathrm{cpu}}}{p}, \\frac{N k}{\\Theta}\\right)$$\n\n$3$. 最终的归约时间 $T_{\\text{reduction}}(p)$，涉及使用二叉树对 $p$ 个部分和进行归约。这样一棵树的深度是 $\\lceil \\log_{2}(p) \\rceil$。每个归约步骤都有一个延迟 $\\alpha$ 和一个数据传输时间 $\\beta m$。对于 $p > 1$，总归约时间是：\n$$T_{\\text{reduction}}(p) = \\lceil \\log_{2}(p) \\rceil (\\alpha + \\beta m)$$\n对于 $p=1$ 的基本情况，不需要进程间的归约，所以 $T_{\\text{reduction}}(1) = 0$，这与 $\\lceil \\log_{2}(1) \\rceil = 0$ 是一致的。\n\n结合这些组成部分，总时间的完整表达式是：\n$$T(p) = t_{0} + \\frac{N t_c}{p} + \\max\\left(\\frac{N k t_{r,\\mathrm{cpu}}}{p}, \\frac{N k}{\\Theta}\\right) + \\lceil \\log_{2}(p) \\rceil (\\alpha + \\beta m)$$\n\n现在，我们代入给定的参数值：\n- $N = 10^{8}$\n- $k = 2$\n- $t_{c} = 3.0 \\times 10^{-8}$ $s$\n- $t_{r,\\mathrm{cpu}} = 1.5 \\times 10^{-8}$ $s$\n- $\\Theta = 2.0 \\times 10^{9}$ $s^{-1}$\n- $\\alpha = 1.0 \\times 10^{-6}$ $s$\n- $\\beta = 5.0 \\times 10^{-10}$ $s/byte$\n- $m = 16$ $bytes$\n- $t_{0} = 5.0 \\times 10^{-2}$ $s$\n- $p = 128$\n\n首先，我们计算串行时间 $T(1)$：\n$$T(1) = t_{0} + N t_c + \\max\\left(N k t_{r,\\mathrm{cpu}}, \\frac{N k}{\\Theta}\\right) + \\lceil \\log_{2}(1) \\rceil (\\alpha + \\beta m)$$\n各个项分别是：\n- $t_{0} = 0.05$ $s$\n- $N t_c = 10^{8} \\times (3.0 \\times 10^{-8}) = 3.0$ $s$\n- 软件 RNG 时间：$N k t_{r,\\mathrm{cpu}} = 10^{8} \\times 2 \\times (1.5 \\times 10^{-8}) = 3.0$ $s$\n- 硬件 RNG 时间限制： $\\frac{N k}{\\Theta} = \\frac{10^{8} \\times 2}{2.0 \\times 10^{9}} = \\frac{2 \\times 10^{8}}{2 \\times 10^{9}} = 0.1$ $s$\n- $\\max(3.0, 0.1) = 3.0$ $s$\n- 归约时间：$\\lceil \\log_{2}(1) \\rceil (\\dots) = 0$\n所以，$T(1) = 0.05 + 3.0 + 3.0 + 0 = 6.05$ $s$。\n\n接下来，我们计算并行时间 $T(128)$：\n$$T(128) = t_{0} + \\frac{N t_c}{128} + \\max\\left(\\frac{N k t_{r,\\mathrm{cpu}}}{128}, \\frac{N k}{\\Theta}\\right) + \\lceil \\log_{2}(128) \\rceil (\\alpha + \\beta m)$$\n各个项分别是：\n- $t_{0} = 0.05$ $s$\n- 并行计算时间： $\\frac{N t_c}{128} = \\frac{3.0}{128} = 0.0234375$ $s$\n- 并行软件 RNG 时间：$\\frac{N k t_{r,\\mathrm{cpu}}}{128} = \\frac{3.0}{128} = 0.0234375$ $s$\n- 硬件 RNG 时间限制： $\\frac{N k}{\\Theta} = 0.1$ $s$\n- $\\max(0.0234375, 0.1) = 0.1$ $s$。这表明 RNG 受到了硬件瓶颈的限制。\n- 归约时间：\n  - $\\lceil \\log_{2}(128) \\rceil = 7$\n  - 每步时间：$\\alpha + \\beta m = 1.0 \\times 10^{-6} + (5.0 \\times 10^{-10} \\times 16) = 1.0 \\times 10^{-6} + 8.0 \\times 10^{-9} = 1.008 \\times 10^{-6}$ $s$\n  - 总归约时间：$7 \\times (1.008 \\times 10^{-6}) = 7.056 \\times 10^{-6}$ $s$\n所以，$T(128) = 0.05 + 0.0234375 + 0.1 + 0.000007056 = 0.173444556$ $s$。\n\n最后，我们计算加速比 $S(128)$：\n$$S(128) = \\frac{T(1)}{T(128)} = \\frac{6.05}{0.173444556} \\approx 34.88053$$\n四舍五入到四位有效数字，加速比为 $34.88$。", "answer": "$$\\boxed{34.88}$$", "id": "2433427"}, {"introduction": "计算工程学的一项关键技能是解读性能数据以诊断系统行为。Gunther 的通用可扩展性定律 (Universal Scalability Law, USL) 提供了一个强大的模型，它不仅考虑了由资源争用（系数为$\\sigma$）引起的串行化，还考虑了因维护数据一致性（系数为$\\kappa$）而产生的开销，后者甚至可能导致高核心数下性能下降。在本练习中，你将扮演性能分析师的角色，利用一组吞吐量测量数据来判断系统是受争用限制还是受一致性限制，这对于做出明智的扩展决策至关重要 [@problem_id:2433475]。", "problem": "一个软件服务部署在多核中央处理器（CPU）上，并使用一个工作线程池来处理独立的请求。当线程数变化时，请求组合和代码路径保持不变。在固定的外部负载生成器下，您测量了稳态吞吐量 $X(N)$（单位为每秒事务数），它是并发工作线程数 $N$ 的函数。获得了以下数据点：$(N, X(N)) \\in \\{(1, 100), (2, 190), (4, 360), (8, 680), (12, 820), (16, 780)\\}$。将加速比定义为 $S(N) = X(N)/X(1)$。假设通用可扩展性定律（USL）在此场景下适用，且其参数分别反映了系数为 $\\sigma$ 的争用效应和系数为 $\\kappa$ 的一致性效应。\n\n仅使用上述测量数据和吞吐量、加速比的基本定义，判断哪种定性模式与数据最一致，并推断其对 $N=16$ 之后的可扩展性意味着什么。选择唯一的最佳选项。\n\nA. 系统主要受争用限制，一致性效应可以忽略（即 $\\sigma > 0$, $\\kappa \\approx 0$）；吞吐量将单调增加，趋向于一个高于 $X(16)$ 的有限渐近线，并且不会随着 $N$ 的增加而减少。\n\nB. 系统主要受一致性限制，具有不可忽略的成对交互成本（即 $\\kappa > 0$ 且不受 $\\sigma$ 主导）；吞吐量在 $N \\approx 12$ 附近表现出最大值，并随着 $N$ 的增大而减少。\n\nC. 系统表现出近乎完美的线性可扩展性（即 $\\sigma \\approx 0$ 和 $\\kappa \\approx 0$）；在观察范围内，吞吐量约为 $X(N) \\approx N \\cdot X(1)$。\n\nD. 系统受到 Amdahl 定律意义下的固定串行部分的限制；吞吐量随 $N$ 次线性但严格单调增加，并且不会在 $N$ 更大时减少。", "solution": "必须首先验证问题陈述的科学性和逻辑完整性。\n\n**步骤1：提取已知条件**\n- 该系统是一个部署在多核CPU上的软件服务，使用一个工作线程池来处理独立的请求。\n- 当线程数变化时，请求组合和代码路径是恒定的。\n- 吞吐量 $X(N)$ 是作为并发工作线程数 $N$ 的函数来测量的。\n- 施加了固定的外部负载。\n- 测得的数据点为 $(N, X(N)) \\in \\{(1, 100), (2, 190), (4, 360), (8, 680), (12, 820), (16, 780)\\}$，其中 $X(N)$ 的单位是每秒事务数。\n- 加速比定义为 $S(N) = X(N)/X(1)$。\n- 假设通用可扩展性定律（USL）适用。\n- USL 参数中，$\\sigma$ 代表争用，$\\kappa$ 代表一致性。\n\n**步骤2：使用提取的已知条件进行验证**\n问题具有科学依据。通用可扩展性定律是分析并行和并发系统性能的广泛接受的模型。所描述的实验设置——测量多核CPU上线程化服务的吞吐量——是此类分析的标准应用领域。所提供的数据对于真实世界的系统是合理的，表现出初始加速后，在更高并发下性能下降。问题是适定的，提供了足够的数据和明确的理论框架（USL）来评估系统的定性行为。术语定义明确。没有矛盾、事实错误或主观论断。\n\n**步骤3：结论与行动**\n问题陈述有效。我将继续进行解答。\n\n**推导**\n\n通用可扩展性定律（USL）将加速比 $S(N)$ 建模为处理器或线程数量 $N$ 的函数。其标准形式由下式给出：\n$$S(N) = \\frac{N}{1 + \\sigma(N-1) + \\kappa N(N-1)}$$\n此处，$\\sigma$ 表示因争用共享资源而串行化的工作部分，$\\kappa$ 表示维护数据一致性所带来的额外开销，该开销通常随工作者数量成二次方扩展（由于成对交互）。\n\n吞吐量 $X(N)$ 通过所给定义与加速比 $S(N)$ 相关联：$S(N) = X(N)/X(1)$。因此，吞吐量的 USL 模型为：\n$$X(N) = X(1) \\cdot S(N) = \\frac{X(1) \\cdot N}{1 + \\sigma(N-1) + \\kappa N(N-1)}$$\n从数据中，我们得到 $X(1) = 100$ 事务/秒。\n\n我们必须在此模型的背景下分析测量的吞吐量数据的行为。让我们为每个测量点计算加速比：\n- 对于 $N=1$：$X(1) = 100$。$S(1) = 100/100 = 1.0$。这是根据定义得出的。\n- 对于 $N=2$：$X(2) = 190$。$S(2) = 190/100 = 1.9$。\n- 对于 $N=4$：$X(4) = 360$。$S(4) = 360/100 = 3.6$。\n- 对于 $N=8$：$X(8) = 680$。$S(8) = 680/100 = 6.8$。\n- 对于 $N=12$：$X(12) = 820$。$S(12) = 820/100 = 8.2$。\n- 对于 $N=16$：$X(16) = 780$。$S(16) = 780/100 = 7.8$。\n\n关键的观察是，吞吐量在 $N=12$ 之前一直在增加，然后在 $N=16$ 时下降，因为 $X(16) = 780 < X(12) = 820$。这种现象被称为回退扩展（retrograde scaling）。\n\n让我们分析 USL 方程来理解导致这种行为的原因。吞吐量 $X(N)$ 是 $N$ 的一个有理函数。其在 $N$ 很大时的行为由分子和分母中的最高阶项决定。\n- 分子是 $N$ 的线性函数。\n- 分母是 $N$ 的二次多项式：$\\kappa N^2 + (\\sigma - \\kappa)N + (1 - \\sigma)$。\n\n如果一致性效应可以忽略（$\\kappa \\approx 0$），USL 就简化为 Amdahl 定律（或仅争用模型）：\n$$X(N) \\approx \\frac{X(1) \\cdot N}{1 + \\sigma(N-1)}$$\n在这种情况下，对于 $\\sigma > 0$，函数 $X(N)$ 是随 $N$ 严格单调递增的。当 $N \\to \\infty$ 时，吞吐量趋近于一个有限的渐近线：\n$$\\lim_{N\\to\\infty} X(N) = \\lim_{N\\to\\infty} \\frac{X(1) \\cdot N}{\\sigma N} = \\frac{X(1)}{\\sigma}$$\n这个模型无法解释吞吐量的下降。\n\n如果一致性效应不可忽略（$\\kappa > 0$），当 $N$ 很大时，分母由 $\\kappa N^2$ 项主导。吞吐量的行为如下：\n$$X(N) \\sim \\frac{X(1) \\cdot N}{\\kappa N^2} = \\frac{X(1)}{\\kappa N}$$\n当 $N \\to \\infty$ 时，$X(N) \\to 0$。由于 $X(N)$ 从 $X(1) > 0$ 开始并最终趋于0，它必须在某个有限的 $N$ 值处达到最大值。这个峰值的位置 $N_{peak}$ 可以通过将 $N$ 视为连续变量并将导数 $dX(N)/dN$ 设为零来找到。计算得出 $N_{peak} \\approx \\sqrt{(1-\\sigma)/\\kappa}$。当且仅当 $\\kappa > 0$ 且 $\\sigma < 1$ 时，对于有限的实数 $N > 1$ 存在一个峰值。\n\n观察到的数据，$X(16) < X(12)$，决定性地表明系统已经越过了其可扩展性峰值。这只在一致性参数 $\\kappa$ 为正且显著的情况下才可能发生。\n\n**逐项分析**\n\nA. 系统主要受争用限制，一致性效应可以忽略（即 $\\sigma > 0$, $\\kappa \\approx 0$）；吞吐量将单调增加，趋向于一个高于 $X(16)$ 的有限渐近线，并且不会随着 $N$ 的增加而减少。\n这对应于 $\\kappa \\approx 0$ 的模型。如上所述，这样的模型预测吞吐量是严格单调递增的。数据明确地反驳了这一预测，因为吞吐量从 $N=12$ 到 $N=16$ 是下降的。\n结论：**错误**。\n\nB. 系统主要受一致性限制，具有不可忽略的成对交互成本（即 $\\kappa > 0$ 且不受 $\\sigma$ 主导）；吞吐量在 $N \\approx 12$ 附近表现出最大值，并随着 $N$ 的增大而减少。\n这个选项假定存在不可忽略的一致性效应（$\\kappa > 0$）。如前所述，这是吞吐量呈现最大值然后下降的必要条件。数据显示，最大吞吐量出现在 $N=12$ 或其附近，随后下降。这与显著的 $\\kappa$ 项的理论含义完全一致。陈述“将随着N的增大而减少”是基于 $\\kappa > 0$ 的USL模型的正确外推。\n结论：**正确**。\n\nC. 系统表现出近乎完美的线性可扩展性（即 $\\sigma \\approx 0$ 和 $\\kappa \\approx 0$）；在观察范围内，吞吐量约为 $X(N) \\approx N \\cdot X(1)$。\n这意味着 $S(N) \\approx N$。与数据核对显示出很大的偏差。例如，对于 $N=12$，线性可扩展性预测 $X(12) = 12 \\cdot X(1) = 12 \\cdot 100 = 1200$。而测量值为 $820$，这是一个显著的次线性。对于 $N=16$，线性可扩展性预测 $X(16) = 1600$，而测量值为 $780$。该模型显然不适用。\n结论：**错误**。\n\nD. 系统受到 Amdahl 定律意义下的固定串行部分的限制；吞吐量随 $N$ 次线性但严格单调增加，并且不会在 $N$ 更大时减少。\nAmdahl 定律是 USL 在 $\\kappa=0$ 时的特例。这与选项 A 中描述的物理模型相同。它只考虑了争用，没有考虑一致性。因此，它不能解释观察到的吞吐量下降。数据证明系统在此范围内不能用 Amdahl 定律来描述。\n结论：**错误**。", "answer": "$$\\boxed{B}$$", "id": "2433475"}]}