{"hands_on_practices": [{"introduction": "在有限元分析中，后处理不仅是为了生成漂亮的云图，更是验证解的物理合理性的关键一步。一个基本检验方法是确认计算结果是否遵循基本的守恒定律，例如能量守恒或质量守恒。本练习将通过一个一维稳态热传导问题，让你亲手验证在没有内部热源的节点上，流入和流出的热通量之和为零，从而体验局部守恒原理在离散系统中的体现。[@problem_id:2426726]", "problem": "考虑一根沿 $x$ 轴放置的复合杆中的稳态一维热传导，该复合杆由两个线性有限元组成，节点位置分别为 $x_0=0$ m, $x_1=0.3$ m 和 $x_2=0.5$ m。横截面积恒定，为 $A=0.01$ m$^2$。热导率是分段恒定的：在区间 $[x_0,x_1]$ 上为 $k_1=48$ W m$^{-1}$ K$^{-1}$，在区间 $[x_1,x_2]$ 上为 $k_2=32$ W m$^{-1}$ K$^{-1}$。杆内任何地方都没有内部热生成，内部节点 $x_1$ 处也没有集中热源或热汇。一次有限元分析得出了以下节点温度：$x_0$ 处为 $T_0=120$ K，$x_1$ 处为 $T_1=100$ K，$x_2$ 处为 $T_2=80$ K。\n\n将进入节点 $x_1$ 的净热率定义为从左侧单元进入的热率和从右侧单元进入的热率的代数和（规定进入节点的热量为正）。仅使用第一性原理，根据给定的节点温度和材料数据，确定进入节点 $x_1$ 的净热率。以瓦特 (W) 为单位表示您的最终答案，并四舍五入到四位有效数字。", "solution": "首先将验证问题陈述的科学和逻辑完整性。\n\n步骤 1：提取已知条件\n问题陈述中提供了以下数据：\n- 节点位置：$x_0 = 0$ m, $x_1 = 0.3$ m, $x_2 = 0.5$ m。\n- 横截面积：$A = 0.01$ m$^2$ (恒定)。\n- 单元 1（在 $[x_0, x_1]$ 上）的热导率：$k_1 = 48$ W m$^{-1}$ K$^{-1}$。\n- 单元 2（在 $[x_1, x_2]$ 上）的热导率：$k_2 = 32$ W m$^{-1}$ K$^{-1}$。\n- 条件：无内部热生成。\n- 条件：节点 $x_1$ 处无集中热源或热汇。\n- 有限元分析得出的节点温度：$T_0 = 120$ K, $T_1 = 100$ K, $T_2 = 80$ K。\n- 定义：进入节点 $x_1$ 的净热率是从左侧单元进入的热率和从右侧单元进入的热率的代数和。\n- 符号约定：正号表示热量进入节点。\n\n步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，因为它基于稳态热传导的基本原理，特别是傅里叶定律 (Fourier's Law)。线性有限元的使用是计算工程中的一种标准技术。该问题是适定的；它提供了计算所求量所需的所有必要信息——几何、材料和热学信息。语言客观、精确。所有术语都有明确的定义。问题不包含任何科学不准确、矛盾或含糊之处。所提供的数据在物理上是一致的。该问题要求基于一组给定的数据进行计算，这是工程分析中的一个标准程序。\n\n步骤 3：结论和行动\n问题被认为是有效的。将提供一个解答。\n\n控制一维稳态热传导的基本原理是傅里叶定律 (Fourier's Law)，该定律指出，热率 $q$ 与面积 $A$ 和温度梯度 $\\frac{dT}{dx}$ 成正比。表达式为：\n$$q = -kA \\frac{dT}{dx}$$\n对于一个线性有限元，温度在节点之间呈线性变化。因此，单元内的温度梯度是恒定的，可以近似为节点温差除以单元长度。\n\n我们必须计算进入节点 $x_1$ 的净热率。这是从左侧单元（单元 1）进入的热率和从右侧单元（单元 2）进入的热率之和。\n\n首先，考虑从跨越区间 $[x_0, x_1]$ 的单元 1 进入节点 $x_1$ 的热率。我们将其记为 $q_{1 \\to 1}$。这是在 $x = x_1$ 处计算的沿 $x$ 正方向的热流。单元 1 的长度为 $L_1 = x_1 - x_0 = 0.3 - 0 = 0.3$ m。该单元内的温度梯度为：\n$$\\left(\\frac{dT}{dx}\\right)_1 = \\frac{T_1 - T_0}{L_1} = \\frac{100 \\text{ K} - 120 \\text{ K}}{0.3 \\text{ m}} = \\frac{-20}{0.3} \\text{ K/m}$$\n沿 $x$ 正方向流过单元 1 的热率是恒定的，由傅里叶定律给出：\n$$q_{1 \\to 1} = -k_1 A \\left(\\frac{dT}{dx}\\right)_1 = -k_1 A \\frac{T_1 - T_0}{L_1}$$\n代入给定值：\n$$q_{1 \\to 1} = -(48 \\text{ W m}^{-1} \\text{K}^{-1})(0.01 \\text{ m}^2) \\frac{100 \\text{ K} - 120 \\text{ K}}{0.3 \\text{ m}} = -0.48 \\left(\\frac{-20}{0.3}\\right) \\text{ W} = 32 \\text{ W}$$\n由于 $q_{1 \\to 1}$ 为正，这表示热量沿 $x$ 正方向流动，因此是从左侧进入节点 $x_1$。\n\n接下来，考虑从跨越区间 $[x_1, x_2]$ 的单元 2 进入节点 $x_1$ 的热率。我们将其记为 $q_{2 \\to 1}$。单元 2 的长度为 $L_2 = x_2 - x_1 = 0.5 - 0.3 = 0.2$ m。该单元内的温度梯度为：\n$$\\left(\\frac{dT}{dx}\\right)_2 = \\frac{T_2 - T_1}{L_2} = \\frac{80 \\text{ K} - 100 \\text{ K}}{0.2 \\text{ m}} = \\frac{-20}{0.2} \\text{ K/m} = -100 \\text{ K/m}$$\n沿 $x$ 正方向流过单元 2 的热率，我们称之为 $q_2$，为：\n$$q_2 = -k_2 A \\left(\\frac{dT}{dx}\\right)_2 = -k_2 A \\frac{T_2 - T_1}{L_2}$$\n这个量 $q_2$ 代表离开节点 $x_1$ 并流入单元 2 的热量。根据指定的符号约定，从单元 2 进入节点 $x_1$ 的热率是 $q_2$ 的负值。\n$$q_{2 \\to 1} = -q_2 = - \\left( -k_2 A \\frac{T_2 - T_1}{L_2} \\right) = k_2 A \\frac{T_2 - T_1}{L_2}$$\n代入给定值：\n$$q_{2 \\to 1} = (32 \\text{ W m}^{-1} \\text{K}^{-1})(0.01 \\text{ m}^2) \\frac{80 \\text{ K} - 100 \\text{ K}}{0.2 \\text{ m}} = 0.32 \\left(\\frac{-20}{0.2}\\right) \\text{ W} = -32 \\text{ W}$$\n负号表示热量从节点 $x_1$ 流出并进入单元 2。这与温度情况一致，因为热量从较热的节点 $T_1 = 100$ K 流向较冷的节点 $T_2 = 80$ K。\n\n进入节点 $x_1$ 的净热率，记为 $Q_{net,1}$，是从每个单元进入该节点的各热率的代数和：\n$$Q_{net,1} = q_{1 \\to 1} + q_{2 \\to 1}$$\n$$Q_{net,1} = 32 \\text{ W} + (-32 \\text{ W}) = 0 \\text{ W}$$\n这个结果是预料之中的。对于一个没有内部热生成且内部节点处没有集中热源或热汇的稳态问题，能量守恒原理规定流入该节点的净热流必须为零。给定的节点温度是有限元方程的精确解，这些方程在每个内部节点上强制执行这种能量平衡。\n\n问题要求答案四舍五入到四位有效数字。由于结果精确为零，它应以反映这种精度的格式表示。\n$$Q_{net,1} = 0.0000 \\text{ W}$$", "answer": "$$\\boxed{0.0000}$$", "id": "2426726"}, {"introduction": "有限元分析中，应力或热通量等导出量通常是在单元内部计算的，这导致它们在单元边界上是不连续的。为了创建用于直观可视化的平滑连续云图，我们需要在共享节点上对这些不连续的值进行平均。本编码练习将指导你实现一种常见且直观的面积加权平均算法，从而揭示有限元分析软件将离散的单元数据转换为工程师所依赖的平滑云图背后的工作机制。[@problem_id:2426709]", "problem": "在二维域上的有限元计算会产生以单元为中心的标量值。对于每个单元 $e$，会给出一个单一的标量值 $q_e$（例如，平均单元应力或能量密度）。考虑具有三个节点的线性三角形单元和具有四个节点的轴对齐矩形四边形单元。将单元 $e$ 对节点 $i$ 贡献的支配面积 $A_{e,i}$ 定义为与节点 $i$ 关联的单元标量形函数在整个单元上的积分。对于所考虑的单元类型，此支配面积等于单元面积除以单元节点数。节点 $i$ 处的节点平均标量 $q_i$ 应定义为使用支配面积作为权重的所有相连单元值的加权平均值：\n$$\nq_i \\;=\\; \\frac{\\sum_{e \\in \\mathcal{E}(i)} A_{e,i}\\, q_e}{\\sum_{e \\in \\mathcal{E}(i)} A_{e,i}},\n$$\n其中 $\\mathcal{E}(i)$ 是包含节点 $i$ 的单元集合。对于面积为 $A_e$ 的线性三角形，$A_{e,i} = A_e/3$。对于面积为 $A_e$ 的轴对齐矩形，$A_{e,i} = A_e/4$。\n\n设顶点为 $(x_1,y_1)$、$(x_2,y_2)$、$(x_3,y_3)$ 的三角形面积 $A_e$ 通过以下公式计算\n$$\nA_e \\;=\\; \\frac{1}{2}\\,\\left|\\,x_1\\,(y_2 - y_3) + x_2\\,(y_3 - y_1) + x_3\\,(y_1 - y_2)\\,\\right|.\n$$\n设顶点为 $(x_1,y_1)$、$(x_2,y_2)$、$(x_3,y_3)$、$(x_4,y_4)$（按逆时针或顺时针顺序列出）的矩形面积 $A_e$ 通过多边形公式计算\n$$\nA_e \\;=\\; \\frac{1}{2}\\,\\left|\\,\\sum_{k=1}^{4} x_k\\,y_{k+1} - y_k\\,x_{k+1}\\,\\right|, \\quad \\text{with } (x_{5},y_{5}) \\equiv (x_1,y_1).\n$$\n假设测试中的所有矩形都是轴对齐的。\n\n给定以下由独立网格组成的测试套件，每个网格都包含节点坐标、单元连接关系、单元中心标量值以及一个指定的目标节点，请为每个网格计算指定节点上的节点平均标量值。在单元连接关系中，节点索引使用从零开始的编号。\n\n测试用例1（矩形和三角形混合，共享节点）：\n- 节点：\n  - 节点0：$(0,0)$\n  - 节点1：$(2,0)$\n  - 节点2：$(2,1)$\n  - 节点3：$(0,1)$\n  - 节点4：$(3,0)$\n  - 节点5：$(3,1)$\n- 单元：\n  - 单元0：类型 quad4，连接关系 $[0,1,2,3]$，$q_{0} = 10$\n  - 单元1：类型 tri3，连接关系 $[2,4,5]$，$q_{1} = 4$\n- 目标节点：$2$\n\n测试用例2（单个三角形与目标节点关联）：\n- 节点：\n  - 节点0：$(0,0)$\n  - 节点1：$(1,0)$\n  - 节点2：$(0,2)$\n- 单元：\n  - 单元0：类型 tri3，连接关系 $[0,1,2]$，$q_{0} = 7$\n- 目标节点：$0$\n\n测试用例3（两个三角形组成一个正方形，面积相等，单元值不同）：\n- 节点：\n  - 节点0：$(0,0)$\n  - 节点1：$(1,0)$\n  - 节点2：$(1,1)$\n  - 节点3：$(0,1)$\n- 单元：\n  - 单元0：类型 tri3，连接关系 $[0,1,2]$，$q_{0} = 9$\n  - 单元1：类型 tri3，连接关系 $[0,2,3]$，$q_{1} = 3$\n- 目标节点：$2$\n\n测试用例4（单个矩形与目标节点关联）：\n- 节点：\n  - 节点0：$(0,0)$\n  - 节点1：$(3,0)$\n  - 节点2：$(3,2)$\n  - 节点3：$(0,2)$\n- 单元：\n  - 单元0：类型 quad4，连接关系 $[0,1,2,3]$，$q_{0} = 5$\n- 目标节点：$1$\n\n您的程序必须严格按照定义实现节点平均方案，使用上述面积公式，并按顺序为每个测试用例计算指定节点上的值 $q_i$。最终输出必须是单行，包含一个用方括号括起来的、逗号分隔的浮点数列表，每个数字在小数点后精确打印六位，按顺序对应测试用例1到4。例如，您的程序应打印一行形式为\n$[v_1,v_2,v_3,v_4]$\n的内容，其中每个 $v_k$ 都格式化为小数点后精确六位。不应打印任何额外文本。", "solution": "问题陈述经过验证，被认为是有效的。它具有科学依据，内容自洽，且提法明确。它描述了一种在有限元分析结果后处理中常用的标准节点平均程序。所提供的数据、定义和公式在数学上是一致的，足以推导出每个测试用例的唯一解。\n\n核心任务是通过对连接到特定节点 $i$ 的所有单元的标量值 $q_e$ 进行加权平均，来计算该节点上的节点标量值 $q_i$。公式如下：\n$$\nq_i \\;=\\; \\frac{\\sum_{e \\in \\mathcal{E}(i)} A_{e,i}\\, q_e}{\\sum_{e \\in \\mathcal{E}(i)} A_{e,i}}\n$$\n这里，$\\mathcal{E}(i)$ 是连接到节点 $i$ 的单元集合，$A_{e,i}$ 是单元 $e$ 对节点 $i$ 的支配面积。该支配面积定义为单元面积 $A_e$ 除以其节点数 $n_e$。对于线性三角形（`tri3`），$n_e=3$。对于轴对齐四边形（`quad4`），$n_e=4$。\n\n对于顶点按序列出的任何多边形 $(x_1, y_1), (x_2, y_2), \\dots, (x_N, y_N)$，其面积 $A_e$ 使用鞋带公式计算：\n$$\nA_e = \\frac{1}{2} \\left| \\sum_{k=1}^{N} (x_k y_{k+1} - x_{k+1} y_k) \\right|, \\quad \\text{with } (x_{N+1}, y_{N+1}) \\equiv (x_1, y_1)\n$$\n该公式适用于指定的三角形和矩形单元。\n\n每个测试用例的步骤如下：\n1.  确定目标节点 $i$。\n2.  确定相连单元的集合 $\\mathcal{E}(i)$。\n3.  对于每个单元 $e \\in \\mathcal{E}(i)$：\n    a. 确定其顶点并计算其面积 $A_e$。\n    b. 确定其节点数 $n_e$。\n    c. 计算支配面积 $A_{e,i} = A_e / n_e$。\n    d. 计算该单元对分子 $A_{e,i} q_e$ 和分母 $A_{e,i}$ 的贡献。\n4.  将所有相连单元的贡献相加，得到总分子和总分母。\n5.  计算最终的节点值 $q_i$。\n\n我们现在将此程序应用于每个测试用例。\n\n**测试用例1**\n目标节点：$i=2$。\n包含节点2的单元集合是 $\\mathcal{E}(2) = \\{0, 1\\}$。\n\n单元0（类型 `quad4`，$n_0 = 4$，$q_0 = 10$）：\n- 顶点：$(0,0), (2,0), (2,1), (0,1)$。\n- 面积：$A_0 = | (0 \\cdot 0 - 2 \\cdot 0) + (2 \\cdot 1 - 2 \\cdot 0) + (2 \\cdot 1 - 0 \\cdot 1) + (0 \\cdot 0 - 0 \\cdot 0) | / 2 = |2 + 2| / 2 = 2.0$。\n- 支配面积：$A_{0,2} = A_0 / n_0 = 2.0 / 4 = 0.5$。\n- 分子贡献：$A_{0,2} q_0 = 0.5 \\times 10 = 5.0$。\n- 分母贡献：$A_{0,2} = 0.5$。\n\n单元1（类型 `tri3`，$n_1 = 3$，$q_1 = 4$）：\n- 顶点：$(2,1), (3,0), (3,1)$。\n- 面积：$A_1 = | (2 \\cdot 0 - 3 \\cdot 1) + (3 \\cdot 1 - 3 \\cdot 0) + (3 \\cdot 1 - 2 \\cdot 1) | / 2 = |-3 + 3 + 1| / 2 = 0.5$。\n- 支配面积：$A_{1,2} = A_1 / n_1 = 0.5 / 3 = 1/6$。\n- 分子贡献：$A_{1,2} q_1 = (1/6) \\times 4 = 4/6 = 2/3$。\n- 分母贡献：$A_{1,2} = 1/6$。\n\n节点2处的节点平均值：\n- $\\sum A_{e,2} q_e = 5.0 + 2/3 = 15/3 + 2/3 = 17/3$。\n- $\\sum A_{e,2} = 0.5 + 1/6 = 3/6 + 1/6 = 4/6 = 2/3$。\n- $q_2 = (17/3) / (2/3) = 17/2 = 8.5$。\n\n**测试用例2**\n目标节点：$i=0$。\n包含节点0的单元集合是 $\\mathcal{E}(0) = \\{0\\}$。\n由于只有一个单元连接到目标节点，加权平均值简化为单元自身的值：$q_0 = q_e = 7$。\n计算确认：\n- 单元0（类型`tri3`，$n_0 = 3$，$q_0 = 7$）：\n- 顶点：$(0,0), (1,0), (0,2)$。\n- 面积：$A_0 = |(0 \\cdot 0 - 1 \\cdot 0) + (1 \\cdot 2 - 0 \\cdot 0) + (0 \\cdot 0 - 0 \\cdot 2)| / 2 = |2| / 2 = 1.0$。\n- 支配面积：$A_{0,0} = A_0 / n_0 = 1.0 / 3 = 1/3$。\n- $q_0 = (A_{0,0} q_0) / A_{0,0} = q_0 = 7.0$。\n\n**测试用例3**\n目标节点：$i=2$。\n包含节点2的单元集合是 $\\mathcal{E}(2) = \\{0, 1\\}$。\n\n单元0（类型 `tri3`，$n_0 = 3$，$q_0 = 9$）：\n- 顶点：$(0,0), (1,0), (1,1)$。\n- 面积：$A_0 = |(0 \\cdot 0 - 1 \\cdot 0) + (1 \\cdot 1 - 1 \\cdot 0) + (1 \\cdot 0 - 0 \\cdot 1)| / 2 = |1| / 2 = 0.5$。\n- 支配面积：$A_{0,2} = A_0 / 3 = 0.5 / 3 = 1/6$。\n- 分子贡献：$A_{0,2} q_0 = (1/6) \\times 9 = 9/6 = 1.5$。\n- 分母贡献：$A_{0,2} = 1/6$。\n\n单元1（类型 `tri3`，$n_1 = 3$，$q_1 = 3$）：\n- 顶点：$(0,0), (1,1), (0,1)$。\n- 面积：$A_1 = |(0 \\cdot 1 - 1 \\cdot 0) + (1 \\cdot 1 - 0 \\cdot 1) + (0 \\cdot 0 - 0 \\cdot 0)| / 2 = |1| / 2 = 0.5$。\n- 支配面积：$A_{1,2} = A_1 / 3 = 0.5 / 3 = 1/6$。\n- 分子贡献：$A_{1,2} q_1 = (1/6) \\times 3 = 3/6 = 0.5$。\n- 分母贡献：$A_{1,2} = 1/6$。\n\n节点2处的节点平均值：\n- $\\sum A_{e,2} q_e = 1.5 + 0.5 = 2.0$。\n- $\\sum A_{e,2} = 1/6 + 1/6 = 2/6 = 1/3$。\n- $q_2 = 2.0 / (1/3) = 6.0$。\n由于支配面积相等（$A_{0,2} = A_{1,2}$），结果是单元值的算术平均值：$(9+3)/2 = 6.0$。\n\n**测试用例4**\n目标节点：$i=1$。\n包含节点1的单元集合是 $\\mathcal{E}(1) = \\{0\\}$。\n与用例2一样，节点值就是单元值：$q_1 = q_e = 5$。\n计算确认：\n- 单元0（类型 `quad4`，$n_0 = 4$，$q_0 = 5$）：\n- 顶点：$(0,0), (3,0), (3,2), (0,2)$。\n- 面积：$A_0 = |(0 \\cdot 0 - 3 \\cdot 0) + (3 \\cdot 2 - 3 \\cdot 0) + (3 \\cdot 2 - 0 \\cdot 2) + (0 \\cdot 0 - 0 \\cdot 0)| / 2 = |6 + 6| / 2 = 6.0$。\n- 支配面积：$A_{0,1} = A_0 / n_0 = 6.0 / 4 = 1.5$。\n- $q_1 = (A_{0,1} q_0) / A_{0,1} = q_0 = 5.0$。\n\n最终计算出的值为：$8.5$、$7.0$、$6.0$ 和 $5.0$。这些值必须格式化为小数点后六位输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are required for this problem.\n\ndef get_polygon_area(vertices):\n    \"\"\"\n    Calculates the area of a polygon given its vertices using the Shoelace formula.\n    Args:\n        vertices (list of tuples): A list of (x, y) coordinates for the polygon's vertices,\n                                   ordered sequentially (clockwise or counter-clockwise).\n    Returns:\n        float: The area of the polygon.\n    \"\"\"\n    n = len(vertices)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n    return abs(area) / 2.0\n\ndef solve():\n    \"\"\"\n    Solves the nodal averaging problem for a predefined suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        ({0: (0.0, 0.0), 1: (2.0, 0.0), 2: (2.0, 1.0), 3: (0.0, 1.0), 4: (3.0, 0.0), 5: (3.0, 1.0)},\n         [{\"type\": \"quad4\", \"conn\": [0, 1, 2, 3], \"q\": 10.0},\n          {\"type\": \"tri3\", \"conn\": [2, 4, 5], \"q\": 4.0}],\n         2),\n        # Test Case 2\n        ({0: (0.0, 0.0), 1: (1.0, 0.0), 2: (0.0, 2.0)},\n         [{\"type\": \"tri3\", \"conn\": [0, 1, 2], \"q\": 7.0}],\n         0),\n        # Test Case 3\n        ({0: (0.0, 0.0), 1: (1.0, 0.0), 2: (1.0, 1.0), 3: (0.0, 1.0)},\n         [{\"type\": \"tri3\", \"conn\": [0, 1, 2], \"q\": 9.0},\n          {\"type\": \"tri3\", \"conn\": [0, 2, 3], \"q\": 3.0}],\n         2),\n        # Test Case 4\n        ({0: (0.0, 0.0), 1: (3.0, 0.0), 2: (3.0, 2.0), 3: (0.0, 2.0)},\n         [{\"type\": \"quad4\", \"conn\": [0, 1, 2, 3], \"q\": 5.0}],\n         1),\n    ]\n\n    results = []\n    for case in test_cases:\n        node_coords, elements, node_idx = case\n\n        numerator = 0.0\n        denominator = 0.0\n        \n        # Find all elements connected to the node of interest and compute their contributions.\n        for elem in elements:\n            if node_idx in elem[\"conn\"]:\n                q_e = elem[\"q\"]\n                conn = elem[\"conn\"]\n                \n                # Get the coordinates of the element's vertices.\n                vertices = [node_coords[node_id] for node_id in conn]\n                \n                # Calculate the element area using the general polygon area formula.\n                A_e = get_polygon_area(vertices)\n                \n                # The number of nodes determines the denominator for the tributary area.\n                n_nodes = len(conn)\n                A_ei = A_e / n_nodes\n                \n                # Accumulate the weighted sum for the numerator and the sum of weights for the denominator.\n                numerator += A_ei * q_e\n                denominator += A_ei\n\n        # The problem statement guarantees the node of interest is part of at least\n        # one element, so the denominator will not be zero.\n        q_i = numerator / denominator\n        results.append(q_i)\n\n    # Format the final output as a bracketed, comma-separated list of floating-point numbers\n    # with exactly six digits after the decimal point.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2426709"}, {"introduction": "我们如何判断有限元分析的结果是否“足够好”？为此，我们需要一种估算误差的方法。著名的 Zienkiewicz-Zhu (ZZ) 误差估计器为此提供了一种实用方案，它将被平滑处理后的梯度场（例如通过前一个练习中的节点平均技术得到）视为对真实解梯度的更优近似，并通过计算原始的、不连续的有限元梯度场与这个“恢复”出的光滑梯度场的差异来量化误差。这个高级练习将向你介绍“后验误差估计”这一核心概念，它是现代有限元分析中实现自适应网格划分和保证解的可靠性的基石。[@problem_id:2426760]", "problem": "给定一个二维稳态热传导问题，其在一个由三个线性三角形有限元组成的单元片上具有标量、各向同性且恒定的热导率 $k$。考虑有限元方法 (FEM) 的温度近似解 $u_h$，该解在三角剖分上是连续且分片线性的。对于每个顶点索引为 $(i,j,\\ell)$ 的三角形 $\\Omega_e$，令其单元上的常梯度为 $\\nabla u_h|_{\\Omega_e}$，并令 Zienkiewicz–Zhu (ZZ) 恢复梯度场 $\\widehat{\\nabla u}$ 为通过对节点恢复梯度进行线性插值得到的连续、分片线性向量场。在单元片中属于每个节点 $n$ 的位置，节点恢复梯度由与该节点关联的所有单元的常梯度的面积加权平均值定义：\n$$\n\\widehat{\\nabla u}^{(n)} \\;=\\; \\frac{\\sum\\limits_{e \\ni n} A_e\\,\\nabla u_h|_{\\Omega_e}}{\\sum\\limits_{e \\ni n} A_e},\n$$\n其中 $A_e$ 是单元 $\\Omega_e$ 的面积。在一个具有局部节点 $(i,j,\\ell)$ 和线性形函数 $(N_i,N_j,N_\\ell)$ 的单元 $\\Omega_e$ 内，恢复梯度场为\n$$\n\\widehat{\\nabla u}(x,y)\\Big|_{\\Omega_e} \\;=\\; N_i(x,y)\\,\\widehat{\\nabla u}^{(i)} \\;+\\; N_j(x,y)\\,\\widehat{\\nabla u}^{(j)} \\;+\\; N_\\ell(x,y)\\,\\widehat{\\nabla u}^{(\\ell)}.\n$$\n单元片的 ZZ 能量范数误差定义为\n$$\n\\left\\|e\\right\\|_{ZZ} \\;=\\; \\left(\\sum_{e=1}^{3} \\int_{\\Omega_e} k\\,\\big\\|\\widehat{\\nabla u}(x,y)-\\nabla u_h|_{\\Omega_e}\\big\\|_2^2\\,\\mathrm{d}\\Omega \\right)^{1/2}.\n$$\n\n此问题中的所有量均为无量纲。您的任务是为以下三个测试用例中的每一个计算 $\\left\\|e\\right\\|_{ZZ}$。在每个用例中，有限元网格都是一个由三个三角形组成的单元片，它们共享索引为 $0$ 的中心节点，并且单元连接关系为 $\\big[(0,1,2),\\,(0,2,3),\\,(0,3,1)\\big]$。FEM 的节点温度值 $u_h$ 应取为给定解析场 $u(x,y)$ 在网格节点处的精确逐点值。\n\n对于每个测试，请使用指定的节点坐标、热导率 $k$ 和解析温度场 $u(x,y)$：\n- 测试 $1$ (精确线性场；在精确算术中预期误差为零):\n  - 节点: $0:(0.0,\\,0.0)$, $1:(1.0,\\,0.0)$, $2:(-0.2,\\,1.1)$, $3:(-0.8,\\,-0.4)$.\n  - 连接关系: $\\big[(0,1,2),\\,(0,2,3),\\,(0,3,1)\\big]$.\n  - 热导率: $k=1.0$.\n  - 场: $u(x,y)=2x - y$.\n- 测试 $2$ (在中等形状单元片上的非线性场):\n  - 节点: $0:(0.1,\\,0.2)$, $1:(0.9,\\,0.1)$, $2:(0.0,\\,1.0)$, $3:(-0.8,\\,0.2)$.\n  - 连接关系: $\\big[(0,1,2),\\,(0,2,3),\\,(0,3,1)\\big]$.\n  - 热导率: $k=2.0$.\n  - 场: $u(x,y)=x^2 + y$.\n- 测试 $3$ (包含一个细长三角形的非线性场):\n  - 节点: $0:(0.0,\\,0.0)$, $1:(0.001,\\,0.0)$, $2:(0.002,\\,0.05)$, $3:(-0.8,\\,0.001)$.\n  - 连接关系: $\\big[(0,1,2),\\,(0,2,3),\\,(0,3,1)\\big]$.\n  - 热导率: $k=0.5$.\n  - 场: $u(x,y)=\\sin(x)+0.5\\,y$.\n\n要求的约定和定义：\n- 对于一个顶点坐标为 $(x_i,y_i)$、$(x_j,y_j)$、$(x_\\ell,y_\\ell)$ 的三角形，令其有符号二倍面积为\n$$\n2A_{\\mathrm{sign}} \\;=\\; (x_j-x_i)(y_\\ell-y_i) - (x_\\ell-x_i)(y_j-y_i),\n$$\n(正)面积为 $A \\,=\\, |A_{\\mathrm{sign}}|$。\n- 对于线性形函数，三角形 $\\Omega_e$ 中 $u_h$ 的单元常梯度为\n$$\n\\nabla u_h\\Big|_{\\Omega_e}\n= \\frac{1}{2A_{\\mathrm{sign}}}\n\\begin{bmatrix}\n(y_j-y_\\ell) & (y_\\ell-y_i) & (y_i-y_j)\\\\\n(x_\\ell-x_j) & (x_i-x_\\ell) & (x_j-x_i)\n\\end{bmatrix}\n\\begin{bmatrix}\nu_i\\\\ u_j\\\\ u_\\ell\n\\end{bmatrix}.\n$$\n\n您的程序必须为每个测试用例计算如上定义的标量 $\\left\\|e\\right\\|_{ZZ}$，并对定义中所包含的单元积分使用精确算术。将三个结果汇总到单行输出中，形式为用方括号括起来的逗号分隔列表，每个值四舍五入到小数点后六位。例如，一个带有占位符值的输出应如下所示：$[0.000000,0.123456,0.654321]$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果 (例如, $[r_1,r_2,r_3]$)。", "solution": "提交分析的问题陈述经过严格审查，被判定为有效。它在科学上基于有限元方法 (FEM) 的原理，特别是关于使用 Zienkiewicz-Zhu (ZZ) 恢复技术的后验误差估计。该问题是适定的，提供了所有必要的数据，包括网格几何、连接关系、材料属性以及用于设置节点值的解析场。所使用的语言客观且数学上精确。不存在矛盾、歧义或违反基本原理的情况。因此，将提供一个合理的解答。\n\n目标是为三个不同的测试用例，计算一个由三个线性三角形有限元组成的单元片上的 Zienkiewicz-Zhu 能量范数误差 $\\left\\|e\\right\\|_{ZZ}$。总误差的平方是每个单元 $\\Omega_e$ 贡献的总和：\n$$\n\\left\\|e\\right\\|_{ZZ}^2 \\;=\\; \\sum_{e=1}^{3} \\left\\|e\\right\\|_{ZZ,e}^2 \\;=\\; \\sum_{e=1}^{3} \\int_{\\Omega_e} k\\,\\big\\|\\widehat{\\nabla u}(x,y)-\\nabla u_h|_{\\Omega_e}\\big\\|_2^2\\,\\mathrm{d}\\Omega\n$$\n计算通过一系列逻辑步骤进行。\n\n**步骤 1：节点温度的评估**\n有限元近似解 $u_h$ 是连续且分片线性的。问题规定，温度场的节点值 $u_i$ 是通过在每个网格节点 $n_i=(x_i, y_i)$ 的坐标处对给定的精确解析场 $u(x,y)$ 进行采样来确定的。\n$$\nu_i = u(x_i, y_i)\n$$\n此操作对单元片中的所有四个节点 $n_0, n_1, n_2, n_3$ 执行。\n\n**步骤 2：单元常梯度的计算**\n在每个线性三角形单元 $\\Omega_e$ 内，有限元解的梯度 $\\nabla u_h|_{\\Omega_e}$ 是一个常向量。对于一个顶点为 $(i,j,\\ell)$、坐标为 $(x_i,y_i)$, $(x_j,y_j)$, $(x_\\ell,y_\\ell)$、节点温度为 $(u_i,u_j,u_\\ell)$ 的单元，此梯度向量 $\\mathbf{g}_e = \\nabla u_h|_{\\Omega_e}$ 使用所提供的公式计算：\n$$\n\\mathbf{g}_e = \\nabla u_h\\Big|_{\\Omega_e}\n= \\frac{1}{2A_{e,\\mathrm{sign}}}\n\\begin{bmatrix}\ny_j-y_\\ell & y_\\ell-y_i & y_i-y_j\\\\\nx_\\ell-x_j & x_i-x_\\ell & x_j-x_i\n\\end{bmatrix}\n\\begin{bmatrix}\nu_i\\\\ u_j\\\\ u_\\ell\n\\end{bmatrix}\n$$\n其中 $2A_{e,\\mathrm{sign}} = (x_j-x_i)(y_\\ell-y_i) - (x_\\ell-x_i)(y_j-y_i)$ 是单元的有符号二倍面积。对单元片中的三个单元分别重复此计算，得到梯度向量 $\\mathbf{g}_1, \\mathbf{g}_2, \\mathbf{g}_3$。每个单元的(正)面积为 $A_e = \\frac{1}{2}|2A_{e,\\mathrm{sign}}|$。\n\n**步骤 3：节点恢复梯度的计算**\nZienkiewicz-Zhu 过程通过首先计算网格节点处的平均梯度，来构建一个连续的、改进的梯度场 $\\widehat{\\nabla u}$。在节点 $n$ 处的恢复梯度，表示为 $\\widehat{\\nabla u}^{(n)}$ 或 $\\mathbf{G}_n$，是与该节点关联的所有单元的常梯度的面积加权平均值：\n$$\n\\mathbf{G}_n = \\widehat{\\nabla u}^{(n)} \\;=\\; \\frac{\\sum\\limits_{e \\ni n} A_e\\,\\mathbf{g}_e}{\\sum\\limits_{e \\ni n} A_e}\n$$\n对所有四个节点执行此计算。例如，中心节点 $n_0$ 由所有三个单元共享，因此其恢复梯度为：\n$$\n\\mathbf{G}_0 \\;=\\; \\frac{A_1\\,\\mathbf{g}_1 + A_2\\,\\mathbf{g}_2 + A_3\\,\\mathbf{g}_3}{A_1+A_2+A_3}\n$$\n一个外部节点，如 $n_1$，仅由单元 $1$ 和 $3$ 共享，因此其恢复梯度为：\n$$\n\\mathbf{G}_1 \\;=\\; \\frac{A_1\\,\\mathbf{g}_1 + A_3\\,\\mathbf{g}_3}{A_1+A_3}\n$$\n恢复梯度 $\\mathbf{G}_0, \\mathbf{G}_1, \\mathbf{G}_2, \\mathbf{G}_3$ 照此计算。\n\n**步骤 4：单元误差积分的求值**\n任务的核心是求值每个单元对总误差贡献的积分。令 $\\boldsymbol{\\delta}(x,y) = \\widehat{\\nabla u}(x,y)-\\nabla u_h|_{\\Omega_e}$。在一个具有节点 $(i,j,\\ell)$ 的单元 $\\Omega_e$ 内，由于 $\\widehat{\\nabla u}$ 和 $u_h$ 都是分片线性的，该差值场是线性的。它可以用单元形函数 $(N_i, N_j, N_\\ell)$ 表示：\n$$\n\\boldsymbol{\\delta}(x,y) = N_i(x,y)\\,\\boldsymbol{\\delta}_i + N_j(x,y)\\,\\boldsymbol{\\delta}_j + N_\\ell(x,y)\\,\\boldsymbol{\\delta}_\\ell\n$$\n其中 $\\boldsymbol{\\delta}_n = \\mathbf{G}_n - \\mathbf{g}_e$ 是节点 $n$ 处的差分向量。单元 $e$ 的积分为：\n$$\n\\left\\|e\\right\\|_{ZZ,e}^2 \\;=\\; k \\int_{\\Omega_e} \\left\\| \\boldsymbol{\\delta}(x,y) \\right\\|_2^2 \\,\\mathrm{d}\\Omega = k \\int_{\\Omega_e} \\left( \\delta_x(x,y)^2 + \\delta_y(x,y)^2 \\right) \\,\\mathrm{d}\\Omega\n$$\n线性标量场 $f(x,y) = N_i f_i + N_j f_j + N_\\ell f_\\ell$ 的平方在一个三角形单元上的积分有一个精确的解析解：\n$$\n\\int_{\\Omega_e} f(x,y)^2 \\,\\mathrm{d}\\Omega = \\frac{A_e}{12}(2f_i^2+2f_j^2+2f_\\ell^2 + 2f_if_j + 2f_if_\\ell + 2f_jf_\\ell) = \\mathbf{f}^T \\mathbf{M} \\mathbf{f}\n$$\n其中 $\\mathbf{f} = [f_i, f_j, f_\\ell]^T$ 是节点值的向量，$\\mathbf{M}$ 是线性三角形的单元质量矩阵：\n$$\n\\mathbf{M} = \\frac{A_e}{12}\n\\begin{pmatrix}\n2 & 1 & 1 \\\\\n1 & 2 & 1 \\\\\n1 & 1 & 2\n\\end{pmatrix}\n$$\n将此应用于 $\\boldsymbol{\\delta}(x,y)$ 的两个分量，我们得到：\n$$\n\\left\\|e\\right\\|_{ZZ,e}^2 = k \\left( \\boldsymbol{\\delta}_x^T \\mathbf{M} \\boldsymbol{\\delta}_x + \\boldsymbol{\\delta}_y^T \\mathbf{M} \\boldsymbol{\\delta}_y \\right)\n$$\n其中 $\\boldsymbol{\\delta}_x = [\\delta_{ix}, \\delta_{jx}, \\delta_{\\ell x}]^T$ 和 $\\boldsymbol{\\delta}_y = [\\delta_{iy}, \\delta_{jy}, \\delta_{\\ell y}]^T$ 是节点差分分量的向量。该精确公式用于计算。\n\n**步骤 5：汇总与最终结果**\n总误差的平方是上一步中计算的逐单元误差平方的总和。\n$$\n\\left\\|e\\right\\|_{ZZ}^2 = \\sum_{e=1}^{3} \\left\\|e\\right\\|_{ZZ,e}^2\n$$\n最终的 ZZ 误差范数是该总和的平方根：\n$$\n\\left\\|e\\right\\|_{ZZ} = \\sqrt{\\left\\|e\\right\\|_{ZZ}^2}\n$$\n这个完整的流程通过编程实现，并应用于三个测试用例中的每一个，以获得所需的数值结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Zienkiewicz-Zhu energy-norm error for three test cases\n    of a 2D steady heat conduction problem on a 3-element patch.\n    \"\"\"\n    test_cases = [\n        {\n            \"nodes\": {0: (0.0, 0.0), 1: (1.0, 0.0), 2: (-0.2, 1.1), 3: (-0.8, -0.4)},\n            \"k\": 1.0,\n            \"u_func\": lambda x, y: 2.0 * x - y\n        },\n        {\n            \"nodes\": {0: (0.1, 0.2), 1: (0.9, 0.1), 2: (0.0, 1.0), 3: (-0.8, 0.2)},\n            \"k\": 2.0,\n            \"u_func\": lambda x, y: x**2 + y\n        },\n        {\n            \"nodes\": {0: (0.0, 0.0), 1: (0.001, 0.0), 2: (0.002, 0.05), 3: (-0.8, 0.001)},\n            \"k\": 0.5,\n            \"u_func\": lambda x, y: np.sin(x) + 0.5 * y\n        }\n    ]\n    \n    # Mesh connectivity is the same for all test cases.\n    connectivity = [(0, 1, 2), (0, 2, 3), (0, 3, 1)]\n    \n    results = []\n\n    for case in test_cases:\n        nodes_coords = case[\"nodes\"]\n        k = case[\"k\"]\n        u_func = case[\"u_func\"]\n        \n        # Step 1: Compute nodal temperatures from the analytical field.\n        nodal_temps = {n: u_func(x, y) for n, (x, y) in nodes_coords.items()}\n\n        elem_data = {}\n        # Step 2: Compute constant element gradients and areas for all elements.\n        for elem_idx, elem_nodes in enumerate(connectivity):\n            n_i, n_j, n_l = elem_nodes\n            (xi, yi), (xj, yj), (xl, yl) = nodes_coords[n_i], nodes_coords[n_j], nodes_coords[n_l]\n\n            # Calculate signed doubled area and positive area.\n            two_A_sign = (xj - xi) * (yl - yi) - (xl - xi) * (yj - yi)\n            area = 0.5 * abs(two_A_sign)\n\n            # Assemble the B matrix for gradient calculation.\n            B_matrix = np.array([\n                [yj - yl, yl - yi, yi - yj],\n                [xl - xj, xi - xl, xj - xi]\n            ])\n            \n            # Vector of nodal temperatures for the element.\n            u_vec = np.array([nodal_temps[n_i], nodal_temps[n_j], nodal_temps[n_l]])\n            \n            # Calculate the constant element gradient.\n            grad_e = (1.0 / two_A_sign) * (B_matrix @ u_vec)\n            \n            elem_data[elem_idx] = {\"nodes\": elem_nodes, \"area\": area, \"grad\": grad_e}\n\n        # Step 3: Compute nodal recovered gradients.\n        # First, map each node to its incident elements.\n        node_to_elems = {n: [] for n in nodes_coords}\n        for elem_idx, elem_nodes in enumerate(connectivity):\n            for node_idx in elem_nodes:\n                node_to_elems[node_idx].append(elem_idx)\n        \n        nodal_recovered_grads = {}\n        for n in nodes_coords:\n            incident_elems = node_to_elems[n]\n            \n            # Perform area-weighted averaging.\n            sum_A_grad = np.zeros(2)\n            sum_A = 0.0\n            for elem_idx in incident_elems:\n                sum_A_grad += elem_data[elem_idx][\"area\"] * elem_data[elem_idx][\"grad\"]\n                sum_A += elem_data[elem_idx][\"area\"]\n            \n            nodal_recovered_grads[n] = sum_A_grad / sum_A\n\n        # Step 4 & 5: Compute element error integrals and aggregate.\n        total_E_squared = 0.0\n        for i in range(len(connectivity)):\n            data = elem_data[i]\n            n_i, n_j, n_l = data[\"nodes\"]\n            area = data[\"area\"]\n            g_e = data[\"grad\"]\n            \n            # Get the nodal recovered gradients for the current element's nodes.\n            G_i = nodal_recovered_grads[n_i]\n            G_j = nodal_recovered_grads[n_j]\n            G_l = nodal_recovered_grads[n_l]\n            \n            # Compute the difference between recovered gradient and FEM gradient at each node.\n            delta_i = G_i - g_e\n            delta_j = G_j - g_e\n            delta_l = G_l - g_e\n            \n            # Assemble vectors of x and y components of the differences.\n            delta_x = np.array([delta_i[0], delta_j[0], delta_l[0]])\n            delta_y = np.array([delta_i[1], delta_j[1], delta_l[1]])\n            \n            # Define the element mass matrix for a linear triangle.\n            M = (area / 12.0) * np.array([\n                [2.0, 1.0, 1.0],\n                [1.0, 2.0, 1.0],\n                [1.0, 1.0, 2.0]\n            ])\n            \n            # Evaluate the integral of the squared error field using the mass matrix.\n            integral_x_sq = delta_x.T @ M @ delta_x\n            integral_y_sq = delta_y.T @ M @ delta_y\n            \n            # The squared error energy for the element.\n            E_e_squared = k * (integral_x_sq + integral_y_sq)\n            total_E_squared += E_e_squared\n            \n        # Final ZZ error norm is the square root of the total squared error energy.\n        zz_error = np.sqrt(total_E_squared)\n        results.append(f\"{zz_error:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2426760"}]}