{"hands_on_practices": [{"introduction": "Verlet积分器因其在分子动力学中的应用而闻名，但其强大功能远不止于此。由引力主导的天体力学就是另一个绝佳的例子，在这些系统中，长期的能量守恒至关重要。本练习将指导您为双星系统构建一个速度Verlet（Velocity Verlet）模拟。您将亲身体验到，时间步长 $\\Delta t$ 的选择如何影响能量守恒这一基本属性，从而对计算成本与准确性之间的权衡有一个直观的认识。[@problem_id:2414438]", "problem": "考虑一个由牛顿引力支配的封闭、孤立的平面二体系统。两个质量分别为 $m_1$ 和 $m_2$ 的质点，在二维空间中受它们之间的相互引力作用而运动，不存在其他力，也没有外部力矩。设万有引力常数（以天文单位、太阳质量和年为单位）为 $G = 4\\pi^2$，其中距离以天文单位（AU）计量，质量以太阳质量（$M_{\\odot}$）计量，时间以年（yr）计量。设位置为 $\\mathbf{r}_1(t), \\mathbf{r}_2(t) \\in \\mathbb{R}^2$，速度为 $\\mathbf{v}_1(t), \\mathbf{v}_2(t) \\in \\mathbb{R}^2$。运动方程由牛顿第二定律和万有引力定律定义。在时间 $t$ 的总能量由下式给出\n$$\nE(t) = \\tfrac{1}{2} m_1 \\|\\mathbf{v}_1(t)\\|^2 + \\tfrac{1}{2} m_2 \\|\\mathbf{v}_2(t)\\|^2 - \\frac{G m_1 m_2}{\\|\\mathbf{r}_1(t) - \\mathbf{r}_2(t)\\|}.\n$$\n将模拟区间 $[0, T_{\\text{end}}]$（时间步长为 $\\Delta t$）内的最大相对能量偏差定义为\n$$\n\\varepsilon_{\\max} = \\max_{t_k \\in \\{0, \\Delta t, 2\\Delta t, \\dots\\}} \\frac{|E(t_k) - E(0)|}{|E(0)|}.\n$$\n为以下测试套件模拟该系统。对于每种情况，使用给定的质量、位置（单位：AU）、速度（单位：AU/yr）、时间步长 $\\Delta t$（单位：yr）和总模拟时长 $T_{\\text{end}}$（单位：yr）来初始化 $t = 0$ 时的状态。计算如上定义的 $\\varepsilon_{\\max}$。将每个结果表示为四舍五入到六位有效数字的十进制浮点数（无量纲）。\n\n测试套件（每行定义一种情况）：\n- 情况1（等质量圆形构型，短步长）：$m_1 = 1.0$, $m_2 = 1.0$, $\\mathbf{r}_1(0) = (-0.5, 0.0)$, $\\mathbf{r}_2(0) = (0.5, 0.0)$, $\\mathbf{v}_1(0) = (0.0, 4.442882938)$, $\\mathbf{v}_2(0) = (0.0, -4.442882938)$, $\\Delta t = 0.001$, $T_{\\text{end}} = 0.707106781$。\n- 情况2（等质量圆形构型，较大步长）：$m_1 = 1.0$, $m_2 = 1.0$, $\\mathbf{r}_1(0) = (-0.5, 0.0)$, $\\mathbf{r}_2(0) = (0.5, 0.0)$, $\\mathbf{v}_1(0) = (0.0, 4.442882938)$, $\\mathbf{v}_2(0) = (0.0, -4.442882938)$, $\\Delta t = 0.01$, $T_{\\text{end}} = 0.707106781$。\n- 情况3（极端质量比，大间距圆形构型）：$m_1 = 1.0$, $m_2 = 0.001$, $\\mathbf{r}_1(0) = (-0.005194805195, 0.0)$, $\\mathbf{r}_2(0) = (5.194805195, 0.0)$, $\\mathbf{v}_1(0) = (0.0, 0.002754177)$, $\\mathbf{v}_2(0) = (0.0, -2.754177)$, $\\Delta t = 0.01$, $T_{\\text{end}} = 11.86$。\n- 情况4（等质量圆形构型，长时长和粗步长）：$m_1 = 1.0$, $m_2 = 1.0$, $\\mathbf{r}_1(0) = (-0.5, 0.0)$, $\\mathbf{r}_2(0) = (0.5, 0.0)$, $\\mathbf{v}_1(0) = (0.0, 4.442882938)$, $\\mathbf{v}_2(0) = (0.0, -4.442882938)$, $\\Delta t = 0.05$, $T_{\\text{end}} = 7.071067811$。\n\n您的程序应生成单行输出，其中包含按测试套件顺序排列的结果，格式为方括号括起来的逗号分隔列表，例如 $[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4]$，其中每个 $\\varepsilon_i$ 是情况 $i$ 的 $\\varepsilon_{\\max}$，四舍五入到六位有效数字。", "solution": "所提出的问题是计算力学中一个适定且有科学依据的任务。它要求对相互牛顿引力作用下的平面二体系统进行数值模拟。目标是计算模拟过程中的最大相对能量偏差，该偏差可作为积分方法的数值精度和能量守恒性的度量。\n\n该系统由牛顿第二定律和万有引力定律支配。对于位置分别为 $\\mathbf{r}_1$ 和 $\\mathbf{r}_2$ 的两个质点 $m_1$ 和 $m_2$，$m_2$ 对 $m_1$ 施加的力为\n$$\n\\mathbf{F}_1 = \\frac{G m_1 m_2}{\\|\\mathbf{r}_2 - \\mathbf{r}_1\\|^3} (\\mathbf{r}_2 - \\mathbf{r}_1).\n$$\n根据牛顿第三定律，$\\mathbf{F}_2 = -\\mathbf{F}_1$。因此，加速度由下式给出：\n$$\n\\mathbf{a}_1(t) = \\frac{\\mathbf{F}_1}{m_1} = \\frac{G m_2}{\\|\\mathbf{r}_2(t) - \\mathbf{r}_1(t)\\|^3} (\\mathbf{r}_2(t) - \\mathbf{r}_1(t))\n$$\n$$\n\\mathbf{a}_2(t) = \\frac{\\mathbf{F}_2}{m_2} = \\frac{G m_1}{\\|\\mathbf{r}_1(t) - \\mathbf{r}_2(t)\\|^3} (\\mathbf{r}_1(t) - \\mathbf{r}_2(t)).\n$$\n此处，$G = 4\\pi^2$ 是在指定单位（AU、太阳质量和年）下的引力常数。\n\n为了数值求解这个常微分方程组，必须采用合适的积分方案。对于此类问题，Velocity Verlet 算法是一个绝佳的选择。它是一种时间可逆的辛积分器，与欧拉积分器等更简单的方法相比，以其出色的长期能量守恒性而闻名。该算法按如下方式将位置和速度从时间 $t$ 更新到 $t + \\Delta t$：\n\n1.  首先，使用当前的速度和加速度更新位置：\n    $$\n    \\mathbf{r}_i(t + \\Delta t) = \\mathbf{r}_i(t) + \\mathbf{v}_i(t) \\Delta t + \\frac{1}{2} \\mathbf{a}_i(t) (\\Delta t)^2 \\quad \\text{for } i \\in \\{1, 2\\}.\n    $$\n\n2.  接下来，计算在新位置 $\\mathbf{r}_i(t + \\Delta t)$ 处的加速度 $\\mathbf{a}_i(t + \\Delta t)$。\n\n3.  最后，使用新旧加速度的平均值更新速度：\n    $$\n    \\mathbf{v}_i(t + \\Delta t) = \\mathbf{v}_i(t) + \\frac{1}{2} (\\mathbf{a}_i(t) + \\mathbf{a}_i(t + \\Delta t)) \\Delta t \\quad \\text{for } i \\in \\{1, 2\\}.\n    $$\n\n模拟通过迭代应用这些步骤进行。算法如下：\n\n1.  使用提供的质量 $m_1, m_2$、初始位置 $\\mathbf{r}_1(0), \\mathbf{r}_2(0)$ 和初始速度 $\\mathbf{v}_1(0), \\mathbf{v}_2(0)$ 初始化 $t=0$ 时的系统状态。\n2.  计算初始总能量 $E(0)$。总能量是动能和势能之和：\n    $$\n    E(t) = \\frac{1}{2} m_1 \\|\\mathbf{v}_1(t)\\|^2 + \\frac{1}{2} m_2 \\|\\mathbf{v}_2(t)\\|^2 - \\frac{G m_1 m_2}{\\|\\mathbf{r}_1(t) - \\mathbf{r}_2(t)\\|}.\n    $$\n    如果 $E(0)=0$，则相对误差是未定义的。然而，对于所提供的对应于束缚（圆形）轨道的初始条件，总能量为负，因此无需担心此问题。\n3.  使用初始位置计算初始加速度 $\\mathbf{a}_1(0)$ 和 $\\mathbf{a}_2(0)$。\n4.  将最大相对能量偏差 $\\varepsilon_{\\max}$ 初始化为 $0$。\n5.  从 $t=0$ 到 $T_{\\text{end}}$ 开始一个时间步进循环，时间步长为 $\\Delta t$。步数由 $N = \\text{round}(T_{\\text{end}} / \\Delta t)$ 给出。\n6.  在循环的每一步中，使用 Velocity Verlet 算法更新两个质点的位置和速度。\n7.  每次更新后，计算当前时间步 $t_k = k\\Delta t$ 的新总能量 $E(t_k)$。\n8.  计算当前步的相对能量偏差：$\\varepsilon_k = \\frac{|E(t_k) - E(0)|}{|E(0)|}$。\n9.  更新 $\\varepsilon_{\\max}$，使得 $\\varepsilon_{\\max} = \\max(\\varepsilon_{\\max}, \\varepsilon_k)$。\n10. 循环完成后，$\\varepsilon_{\\max}$ 的最终值即为给定测试用例的结果。\n\n将此过程应用于问题陈述中指定的四个测试用例中的每一个。然后将得到的 $\\varepsilon_{\\max}$ 值格式化为六位有效数字，并以所需的输出格式呈现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the two-body problem for the given test cases and prints the results.\n    \"\"\"\n\n    # Define the gravitational constant in AU, M_sun, yr units.\n    G = 4.0 * np.pi**2\n\n    # Test suite from the problem statement.\n    test_cases = [\n        # Case 1: m1, m2, r1(0), r2(0), v1(0), v2(0), dt, T_end\n        (1.0, 1.0, [-0.5, 0.0], [0.5, 0.0], [0.0, 4.442882938], [0.0, -4.442882938], 0.001, 0.707106781),\n        # Case 2\n        (1.0, 1.0, [-0.5, 0.0], [0.5, 0.0], [0.0, 4.442882938], [0.0, -4.442882938], 0.01, 0.707106781),\n        # Case 3\n        (1.0, 0.001, [-0.005194805195, 0.0], [5.194805195, 0.0], [0.0, 0.002754177], [0.0, -2.754177], 0.01, 11.86),\n        # Case 4\n        (1.0, 1.0, [-0.5, 0.0], [0.5, 0.0], [0.0, 4.442882938], [0.0, -4.442882938], 0.05, 7.071067811),\n    ]\n\n    def run_simulation(m1, m2, r1_0, r2_0, v1_0, v2_0, dt, T_end):\n        \"\"\"\n        Runs a single two-body simulation using the Velocity Verlet integrator.\n        \"\"\"\n        r1, r2 = np.array(r1_0, dtype=float), np.array(r2_0, dtype=float)\n        v1, v2 = np.array(v1_0, dtype=float), np.array(v2_0, dtype=float)\n\n        def get_energy(cur_r1, cur_r2, cur_v1, cur_v2):\n            r_vec = cur_r1 - cur_r2\n            dist = np.linalg.norm(r_vec)\n            kinetic_energy = 0.5 * m1 * np.dot(cur_v1, cur_v1) + 0.5 * m2 * np.dot(cur_v2, cur_v2)\n            potential_energy = -G * m1 * m2 / dist\n            return kinetic_energy + potential_energy\n\n        def get_accelerations(cur_r1, cur_r2):\n            r_vec = cur_r2 - cur_r1\n            dist_cubed = np.linalg.norm(r_vec)**3\n            if dist_cubed == 0:\n                raise ValueError(\"Collision detected: distance between bodies is zero.\")\n            a1 = G * m2 * r_vec / dist_cubed\n            a2 = -G * m1 * r_vec / dist_cubed\n            return a1, a2\n\n        # Initial conditions\n        E0 = get_energy(r1, r2, v1, v2)\n        if E0 == 0:\n            return 0.0  # Relative error is undefined, but max deviation would be 0 if energy is conserved.\n\n        a1, a2 = get_accelerations(r1, r2)\n        \n        max_rel_error = 0.0\n        num_steps = int(round(T_end / dt))\n\n        for _ in range(num_steps):\n            # Velocity Verlet Integration\n            # 1. Update positions\n            r1_new = r1 + v1 * dt + 0.5 * a1 * dt**2\n            r2_new = r2 + v2 * dt + 0.5 * a2 * dt**2\n\n            # 2. Compute new accelerations\n            a1_new, a2_new = get_accelerations(r1_new, r2_new)\n\n            # 3. Update velocities\n            v1_new = v1 + 0.5 * (a1 + a1_new) * dt\n            v2_new = v2 + 0.5 * (a2 + a2_new) * dt\n            \n            # Update state for next iteration\n            r1, r2 = r1_new, r2_new\n            v1, v2 = v1_new, v2_new\n            a1, a2 = a1_new, a2_new\n\n            # Calculate energy and update max relative error\n            E_t = get_energy(r1, r2, v1, v2)\n            rel_error = abs((E_t - E0) / E0)\n            if rel_error > max_rel_error:\n                max_rel_error = rel_error\n\n        return max_rel_error\n\n    results = []\n    for case in test_cases:\n        epsilon_max = run_simulation(*case)\n        results.append(epsilon_max)\n\n    # Format results to six significant digits. The 'g' format specifier achieves this.\n    formatted_results = [f\"{res:.6g}\" for res in results]\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2414438"}, {"introduction": "尽管我们通常将“Verlet积分”作为一个方法来讨论，但它实际上包含了几个相关的变体，其中最常见的两种是位置Verlet（Position Verlet）和速度Verlet（Velocity Verlet）格式。本练习将要求您实现这两种算法，并在一个要求苛刻的测试案例（高偏心率轨道）中对它们的性能进行正面比较。通过分析长期的能量漂移 [@problem_id:2414503]，您将对这些算法之间细微的实现差异及其对模拟稳定性和准确性的实际影响有更深刻的理解。", "problem": "考虑一个在分子动力学（MD）中常用的无量纲化设置下的平面二体问题，其中质量为 $m$ 的测试粒子通过牛顿引力绕一个固定的中心质量体运行。采用以下基本模型和定义作为您推导和实现的基础：\n\n- 牛顿第二定律：$m \\,\\dfrac{d^{2}\\mathbf{r}}{dt^{2}} = \\mathbf{F}(\\mathbf{r})$。\n- 引力：$\\mathbf{F}(\\mathbf{r}) = -\\,\\mu\\,m\\,\\dfrac{\\mathbf{r}}{\\|\\mathbf{r}\\|^{3}}$，其中 $\\mu$ 是中心质量体的引力参数，$\\|\\mathbf{r}\\|$ 是位置向量 $\\mathbf{r}$ 的欧几里得范数。\n- 动能：$T = \\dfrac{1}{2}\\,m\\,\\|\\mathbf{v}\\|^{2}$。\n- 势能：$U = -\\,\\dfrac{\\mu\\,m}{\\|\\mathbf{r}\\|}$。\n- 总能量：$E = T + U$。\n\n您将比较两种在分子动力学（MD）中常用的二阶辛积分器的长期能量漂移：位置Verlet积分器和速度Verlet积分器。从上述基本原理出发，通过与牛顿第二定律一致的泰勒展开，推导两种更新规则至时间步长的二阶精度。不要使用任何预先给定的积分公式；相反，您需要推导出用于推进状态 $\\left(\\mathbf{r},\\mathbf{v}\\right)$ 及相关加速度 $\\mathbf{a}(\\mathbf{r}) = \\mathbf{F}(\\mathbf{r})/m$ 的离散时间递推关系。\n\n开普勒椭圆的初始条件构建：使用一个无量纲系统，其中引力参数 $\\mu = 1$，质量 $m = 1$，半长轴 $a = 1$。对于给定的离心率 $e \\in [0,1)$，在近心点初始化轨道，即按如下方式设置初始位置和速度：\n- 近心点半径 $r_{\\mathrm{p}} = a\\,(1 - e)$。\n- 位置 $\\mathbf{r}_{0} = (r_{\\mathrm{p}},\\,0)$。\n- 近心点速度 $v_{\\mathrm{p}} = \\sqrt{\\dfrac{\\mu\\,(1+e)}{a\\,(1-e)}}$。\n- 速度 $\\mathbf{v}_{0} = (0,\\,v_{\\mathrm{p}})$。\n\n能量漂移度量：对于给定的积分器、时间步长 $\\Delta t$ 和步数 $N$，模拟该系统并在离散时间 $t_{n} = n\\,\\Delta t$ 记录总能量 $E(t_{n})$。将能量漂移定义为在记录的轨迹上对 $E(t)$ 与 $t$ 进行最小二乘线性拟合所得的最佳拟合斜率 $s$ 的绝对值。即，拟合 $E(t) \\approx s\\,t + b$ 并取 $\\lvert s \\rvert$ 作为漂移。所有能量均以 $\\mu = 1$ 和 $m = 1$ 所隐含的无量纲单位表示，漂移 $s$ 也以这些相同的能量单位每单位时间表示。\n\n算法要求：\n- 位置Verlet：推导并实现二阶、时间可逆的仅位置更新，该更新使用位置 $\\mathbf{r}_{n-1}$ 和 $\\mathbf{r}_{n}$ 来计算 $\\mathbf{r}_{n+1}$，其中加速度由位置评估。为了计算在时间 $t_{n}$ 的动能，使用中心有限差分速度 $\\mathbf{v}_{n} \\approx \\dfrac{\\mathbf{r}_{n+1} - \\mathbf{r}_{n-1}}{2\\,\\Delta t}$。\n- 速度Verlet：推导并实现二阶、时间可逆的更新，该更新使用位置和速度将 $\\left(\\mathbf{r}_{n},\\mathbf{v}_{n}\\right)$ 推进到 $\\left(\\mathbf{r}_{n+1},\\mathbf{v}_{n+1}\\right)$，并在适当阶段评估加速度 $\\mathbf{a}(\\mathbf{r})$。\n\n测试套件：使用以下三组参数集，每组由 $(e,\\Delta t,N)$ 表征，并设 $a = 1$，$\\mu = 1$，$m = 1$：\n- 情况1：$e = 0.9$, $\\Delta t = 0.0015$, $N = 40000$。\n- 情况2：$e = 0.9$, $\\Delta t = 0.003$, $N = 40000$。\n- 情况3：$e = 0.0$, $\\Delta t = 0.01$, $N = 40000$。\n\n对于每种情况，计算两个浮点数：\n- 位置Verlet积分器的绝对漂移 $\\lvert s_{\\mathrm{PV}} \\rvert$。\n- 速度Verlet积分器的绝对漂移 $\\lvert s_{\\mathrm{VV}} \\rvert$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\lvert s_{\\mathrm{PV}} \\rvert^{(1)},\\lvert s_{\\mathrm{VV}} \\rvert^{(1)},\\lvert s_{\\mathrm{PV}} \\rvert^{(2)},\\lvert s_{\\mathrm{VV}} \\rvert^{(2)},\\lvert s_{\\mathrm{PV}} \\rvert^{(3)},\\lvert s_{\\mathrm{VV}} \\rvert^{(3)}]$，其中上标表示上述顺序中的情况索引。所有值都必须以浮点数形式打印，单位为由 $\\mu = 1$，$m = 1$ 和 $a = 1$ 隐含的无量纲能量每时间单位。", "solution": "所提出的问题是计算物理学中的一个标准练习，要求对开普勒问题的两个基本辛积分器进行推导、实现和比较。该问题定义明确，科学上合理，且内部一致。因此，它被认为是有效的。我们着手进行解答。\n\n我们分析的基础是质量为 $m$ 的粒子在中心力 $\\mathbf{F}(\\mathbf{r})$ 作用下的牛顿第二运动定律，由下式给出\n$$ m \\frac{d^2\\mathbf{r}}{dt^2} = \\mathbf{F}(\\mathbf{r}) $$\n此处，$\\mathbf{r}(t) \\in \\mathbb{R}^2$ 是位置向量。加速度为 $\\mathbf{a}(\\mathbf{r}) = \\mathbf{F}(\\mathbf{r})/m$。对于指定的引力，加速度为\n$$ \\mathbf{a}(\\mathbf{r}) = -\\mu \\frac{\\mathbf{r}}{\\|\\mathbf{r}\\|^3} $$\n其中 $\\mu$ 是中心天体的引力参数。\n\n数值积分方案的推导始于位置向量 $\\mathbf{r}(t)$ 在时间 $t_n$ 附近的泰勒级数展开。设 $\\Delta t$ 为离散时间步长。在时间 $t_{n+1} = t_n + \\Delta t$ 和 $t_{n-1} = t_n - \\Delta t$ 的位置为：\n$$ \\mathbf{r}(t_{n+1}) = \\mathbf{r}(t_n) + \\mathbf{v}(t_n)\\Delta t + \\frac{1}{2}\\mathbf{a}(t_n)(\\Delta t)^2 + \\frac{1}{6}\\frac{d\\mathbf{a}}{dt}(t_n)(\\Delta t)^3 + O((\\Delta t)^4) $$\n$$ \\mathbf{r}(t_{n-1}) = \\mathbf{r}(t_n) - \\mathbf{v}(t_n)\\Delta t + \\frac{1}{2}\\mathbf{a}(t_n)(\\Delta t)^2 - \\frac{1}{6}\\frac{d\\mathbf{a}}{dt}(t_n)(\\Delta t)^3 + O((\\Delta t)^4) $$\n设 $\\mathbf{r}_n = \\mathbf{r}(t_n)$，$\\mathbf{v}_n = \\mathbf{v}(t_n)$，以及 $\\mathbf{a}_n = \\mathbf{a}(\\mathbf{r}_n)$。\n\n**1. 位置Verlet积分器的推导**\n\n将两个泰勒展开式相加得到：\n$$ \\mathbf{r}_{n+1} + \\mathbf{r}_{n-1} = 2\\mathbf{r}_n + \\mathbf{a}_n(\\Delta t)^2 + O((\\Delta t)^4) $$\n对 $\\mathbf{r}_{n+1}$ 进行整理，得到位置Verlet（或 Störmer-Verlet）更新规则：\n$$ \\mathbf{r}_{n+1} = 2\\mathbf{r}_n - \\mathbf{r}_{n-1} + \\mathbf{a}(\\mathbf{r}_n)(\\Delta t)^2 $$\n这是一个关于位置的三项递推关系。局部误差为 $O((\\Delta t)^4)$，这导致全局误差为 $O((\\Delta t)^2)$。该方法是显式时间可逆的。\n\n这在形式上是一种单步法，但它需要两个先前的位置值 $\\mathbf{r}_n$ 和 $\\mathbf{r}_{n-1}$。为启动模拟，我们已知 $\\mathbf{r}_0$ 和 $\\mathbf{v}_0$。所需的第一步 $\\mathbf{r}_{-1}$ 未给出。我们使用 $\\mathbf{r}(t_0 - \\Delta t)$ 的泰勒展开来构建它：\n$$ \\mathbf{r}_{-1} \\approx \\mathbf{r}_0 - \\mathbf{v}_0 \\Delta t + \\frac{1}{2}\\mathbf{a}_0 (\\Delta t)^2 $$\n其中 $\\mathbf{a}_0 = \\mathbf{a}(\\mathbf{r}_0)$。\n\n速度 $\\mathbf{v}_n$ 不显式地作为积分状态的一部分。要计算动能 $T = \\frac{1}{2}m\\|\\mathbf{v}\\|^2$，我们需要速度。将两个泰勒展开式相减，可提供一个在时间 $t_n$ 的二阶精确、中心有限差分的速度近似值：\n$$ \\mathbf{v}_n = \\frac{\\mathbf{r}_{n+1} - \\mathbf{r}_{n-1}}{2\\Delta t} + O((\\Delta t)^2) $$\n问题正确地要求使用此公式进行能量计算。\n\n**2. 速度Verlet积分器的推导**\n\n速度Verlet算法以同步方式更新位置和速度。我们从 $\\mathbf{r}_{n+1}$ 的泰勒展开开始：\n$$ \\mathbf{r}_{n+1} = \\mathbf{r}_n + \\mathbf{v}_n\\Delta t + \\frac{1}{2}\\mathbf{a}_n(\\Delta t)^2 + O((\\Delta t)^3) $$\n这提供了位置更新规则。接下来，我们需要对 $\\mathbf{v}_{n+1}$ 进行更新。一个简单的前向欧拉步长是一阶的。为达到二阶精度，我们使用时间步长开始和结束时加速度的平均值来近似速度的变化：\n$$ \\mathbf{v}_{n+1} \\approx \\mathbf{v}_n + \\frac{\\mathbf{a}_n + \\mathbf{a}_{n+1}}{2}\\Delta t $$\n此处，$\\mathbf{a}_{n+1} = \\mathbf{a}(\\mathbf{r}_{n+1})$ 是在新计算位置处的加速度。这构成了速度更新规则。完整的速度Verlet算法是一个两阶段过程：\n1. 更新位置：$\\mathbf{r}_{n+1} = \\mathbf{r}_n + \\mathbf{v}_n\\Delta t + \\frac{1}{2}\\mathbf{a}_n(\\Delta t)^2$\n2. 计算中间加速度：$\\mathbf{a}_{n+1} = \\mathbf{a}(\\mathbf{r}_{n+1})$\n3. 更新速度：$\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\frac{1}{2}(\\mathbf{a}_n + \\mathbf{a}_{n+1})\\Delta t$\n\n此算法也是时间可逆、辛的且二阶精确的。与位置Verlet相比，它的优点是在每个完整时间步长上都能显式获得速度，从而简化了能量计算等分析和诊断。\n\n**3. 模拟设置与分析**\n\n系统在 $\\mu=1$、$m=1$ 和半长轴 $a=1$ 的条件下进行了无量纲化。离心率为 $e$ 的椭圆轨道的初始条件在近心点指定，此时粒子最接近中心质量体，其速度达到最大且纯粹是切向的。\n- 初始位置：$\\mathbf{r}_0 = (a(1-e), 0)$\n- 初始速度：$\\mathbf{v}_0 = (0, \\sqrt{\\mu(1+e)/(a(1-e))})$\n\n系统的总能量是动能和势能之和：\n$$ E = T + U = \\frac{1}{2}m\\|\\mathbf{v}\\|^2 - \\frac{\\mu m}{\\|\\mathbf{r}\\|} $$\n对于开普勒轨道，解析总能量是恒定的，由 $E = -\\frac{\\mu m}{2a}$ 给出。对于指定的参数（$\\mu=1, m=1, a=1$），精确能量为 $E = -0.5$。\n\n长期能量漂移通过使用时间步长 $\\Delta t$ 模拟系统 $N$ 步来量化，在每个时间点 $t_n = n\\Delta t$ 记录总能量 $E_n$。使用最小二乘法将线性模型 $E(t) \\approx s t + b$ 拟合到能量值的时间序列。斜率的绝对值 $|s|$ 被用作单位时间的能量漂移度量。\n\n实现将包括两个不同的函数，每个积分器一个，用于模拟指定步数的轨迹。一个主程序将遍历给定的测试用例，为每个用例执行两种模拟，计算各自的能量漂移，并以指定格式报告结果。线性回归将使用标准数值库函数执行。\n对于位置Verlet积分器，模拟必须运行 $N+1$ 步以生成直至 $\\mathbf{r}_{N+1}$ 的位置，这是使用中心差分公式计算速度 $\\mathbf{v}_N$ 进而计算能量 $E_N$ 所必需的。能量将在从 $t_0$ 到 $t_N$ 的 $N+1$ 个时间点上计算。$N$ 步的速度Verlet模拟自然地产生从 $(\\mathbf{r}_0, \\mathbf{v}_0)$ 到 $(\\mathbf{r}_N, \\mathbf{v}_N)$ 的 $N+1$ 个状态，从而允许在相同的 $N+1$ 个时间点上计算能量。这确保了比较的一致性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants from the problem statement\nMU = 1.0\nM = 1.0\n\ndef get_initial_conditions(e, a=1.0, mu=MU):\n    \"\"\"\n    Computes initial position and velocity at periapsis for a Keplerian orbit.\n    \"\"\"\n    if e >= 1.0 or e  0.0:\n        raise ValueError(\"Eccentricity e must be in [0, 1).\")\n    if a = 0.0:\n        raise ValueError(\"Semi-major axis a must be positive.\")\n        \n    # Periapsis radius\n    r_p = a * (1.0 - e)\n    \n    # Periapsis speed\n    v_p = np.sqrt(mu * (1.0 + e) / (a * (1.0 - e)))\n    \n    # Initial position and velocity vectors\n    r0 = np.array([r_p, 0.0])\n    v0 = np.array([0.0, v_p])\n    \n    return r0, v0\n\ndef acceleration(r, mu=MU):\n    \"\"\"\n    Computes the gravitational acceleration vector.\n    a(r) = -mu * r / ||r||^3\n    \"\"\"\n    norm_r = np.linalg.norm(r)\n    if norm_r == 0:\n        raise ValueError(\"Position vector cannot be zero.\")\n    return -mu * r / (norm_r**3)\n\ndef total_energy(r, v, m=M, mu=MU):\n    \"\"\"\n    Computes the total energy (kinetic + potential) of the particle.\n    \"\"\"\n    kinetic_energy = 0.5 * m * np.dot(v, v)\n    potential_energy = -mu * m / np.linalg.norm(r)\n    return kinetic_energy + potential_energy\n\ndef run_position_verlet(e, dt, N, a=1.0, m=M, mu=MU):\n    \"\"\"\n    Simulates the two-body problem using the Position Verlet integrator\n    and calculates the energy drift.\n    \"\"\"\n    # 1. Initial conditions and startup\n    r0, v0 = get_initial_conditions(e, a, mu)\n    a0 = acceleration(r0, mu)\n    \n    # Compute r_{-1} to kickstart the integrator\n    r_minus_1 = r0 - v0 * dt + 0.5 * a0 * dt**2\n    \n    # Store all positions from r_{-1} to r_{N+1}\n    # We need r_{N+1} to compute v_N for the final energy E_N.\n    # Total positions: r_{-1}, r_0, ..., r_N, r_{N+1} (N+3 points)\n    positions = np.zeros((N + 3, 2))\n    positions[0] = r_minus_1\n    positions[1] = r0\n    \n    # 2. Main integration loop\n    for n in range(1, N + 2):\n        # n corresponds to the time index for pos[n]\n        # We compute pos[n+1] from pos[n] and pos[n-1]\n        r_curr = positions[n]\n        r_prev = positions[n-1]\n        a_curr = acceleration(r_curr, mu)\n        r_next = 2.0 * r_curr - r_prev + a_curr * dt**2\n        positions[n + 1] = r_next\n        \n    # 3. Calculate energies at each step\n    energies = np.zeros(N + 1)\n    times = np.arange(N + 1) * dt\n    \n    for n in range(N + 1):\n        # We want to compute E_n = E(r_n, v_n)\n        r_n = positions[n + 1]  # r_n is at index n+1\n        \n        # v_n = (r_{n+1} - r_{n-1}) / (2*dt)\n        r_n_plus_1 = positions[n + 2]\n        r_n_minus_1 = positions[n]\n        v_n = (r_n_plus_1 - r_n_minus_1) / (2.0 * dt)\n        \n        energies[n] = total_energy(r_n, v_n, m, mu)\n        \n    # 4. Compute energy drift via linear regression\n    slope, _ = np.polyfit(times, energies, 1)\n    return np.abs(slope)\n\ndef run_velocity_verlet(e, dt, N, a=1.0, m=M, mu=MU):\n    \"\"\"\n    Simulates the two-body problem using the Velocity Verlet integrator\n    and calculates the energy drift.\n    \"\"\"\n    # 1. Initial conditions\n    r, v = get_initial_conditions(e, a, mu)\n    a_curr = acceleration(r, mu)\n    \n    energies = np.zeros(N + 1)\n    times = np.arange(N + 1) * dt\n    \n    energies[0] = total_energy(r, v, m, mu)\n    \n    # 2. Main integration loop\n    for n in range(N):\n        # Update position\n        r_next = r + v * dt + 0.5 * a_curr * dt**2\n        \n        # Update acceleration\n        a_next = acceleration(r_next, mu)\n        \n        # Update velocity\n        v_next = v + 0.5 * (a_curr + a_next) * dt\n        \n        # Update state for next iteration\n        r, v, a_curr = r_next, v_next, a_next\n        \n        # 3. Calculate and store energy\n        energies[n + 1] = total_energy(r, v, m, mu)\n        \n    # 4. Compute energy drift via linear regression\n    slope, _ = np.polyfit(times, energies, 1)\n    return np.abs(slope)\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (e, dt, N)\n        (0.9, 0.0015, 40000),  # Case 1\n        (0.9, 0.003, 40000),   # Case 2\n        (0.0, 0.01, 40000),    # Case 3\n    ]\n\n    results = []\n    for e, dt, N in test_cases:\n        # Calculate drift for Position Verlet\n        drift_pv = run_position_verlet(e, dt, N)\n        results.append(drift_pv)\n        \n        # Calculate drift for Velocity Verlet\n        drift_vv = run_velocity_verlet(e, dt, N)\n        results.append(drift_vv)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2414503"}, {"introduction": "Verlet积分器卓越的能量守恒特性源于其为保守系统（能量恒定）量身定制的“辛”性质。但是，在包含摩擦或阻力等耗散力的真实世界场景中，我们该怎么办呢？本练习将挑战您将Verlet方法应用于一个包含速度相关阻力（$F_{\\text{drag}} = - \\gamma v$）的非保守系统。您需要推导并实现一个修正的积分器，并分析它如何正确地捕捉能量耗散过程 [@problem_id:2414487]，这展示了Verlet框架在其传统应用之外的强大适应性。", "problem": "考虑一个质量为 $m$ 的单点粒子，在一维谐振子势 $U(x) = \\tfrac{1}{2} k x^2$ 和线性阻尼力 $F_{\\text{drag}} = - \\gamma v$ 的作用下沿直线运动。总力为 $F(x,v) = -k x - \\gamma v$。其运动遵循牛顿第二定律 $m \\ddot{x}(t) = F\\big(x(t), \\dot{x}(t)\\big)$。机械能为 $E(t) = \\tfrac{1}{2} m \\, v(t)^2 + \\tfrac{1}{2} k \\, x(t)^2$。所有量均使用无量纲单位。\n\n你的任务是从第一性原理出发，推导一个离散时间更新映射 $\\big(x_n, v_n\\big) \\mapsto \\big(x_{n+1}, v_{n+1}\\big)$，该映射具有均匀时间步长 $\\Delta t$，与给定的动力学一致，在 $\\gamma \\to 0$ 时能退化为标准Verlet积分族，并能使系统在时间层 $t_n = n \\, \\Delta t$（其中 $n \\in \\{0,1,2,\\dots\\}$）上前进。实现此更新，以模拟下面列出的参数集下的系统。初始条件为 $x(0) = x_0$ 和 $v(0) = v_0$，它们定义了 $x_0 = x_{n=0}$ 和 $v_0 = v_{n=0}$。\n\n对于每次模拟，计算离散机械能 $E_n = \\tfrac{1}{2} m \\, v_n^2 + \\tfrac{1}{2} k \\, x_n^2$ 并评估所要求的定量指标。所有输出均为无量纲。不出现角度。在计算任何对数时，请使用自然对数。\n\n测试套件和必需的输出：\n- 情况A（能量耗散率估计）：$m = 1$，$k = 1$，$\\gamma = 0.1$，$x_0 = 1$，$v_0 = 0$，$\\Delta t = 0.01$，总时间 $T = 50$，因此步数 $N = T / \\Delta t$。构建时间序列 $\\{(t_n, E_n)\\}_{n=0}^{N}$，其中 $t_n = n \\Delta t$。在子集 $n \\ge N_b$（预烧期 $N_b = 200$）上对 $\\ln E_n$ 与 $t_n$ 进行无权线性最小二乘拟合，得到斜率 $s$。输出浮点数 $|s + \\gamma/m|$。\n- 情况B（守恒极限下的能量漂移）：$m = 1$，$k = 1$，$\\gamma = 0$，$x_0 = 1$，$v_0 = 0$，$\\Delta t = 0.01$，$T = 50$。输出浮点数 $\\max_{0 \\le n \\le N} \\big|E_n - E_0\\big| / E_0$。\n- 情况C（强阻尼下的能量单调递减）：$m = 1$，$k = 1$，$\\gamma = 5$，$x_0 = 1$，$v_0 = 0$，$\\Delta t = 0.001$，$T = 5$。输出一个布尔值，表示对于所有 $0 \\le n  N$，是否都满足 $E_{n+1} \\le E_n + \\varepsilon$，绝对容差 $\\varepsilon = 10^{-12}$。\n- 情况D（粗时间步长下的数值稳定性）：$m = 1$，$k = 1$，$\\gamma = 0.5$，$x_0 = 1$，$v_0 = 0$，$\\Delta t = 0.2$，$T = 100$。输出一个布尔值，表示所有模拟状态的量级是否保持有限且有界（具体为 $\\max_n \\{|x_n|, |v_n|\\}  B$，其中 $B = 10^3$），并且所有能量是否满足 $E_n \\ge - \\delta$（其中 $\\delta = 10^{-12}$）。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含情况A到D的结果，按顺序排列，形式为用方括号括起来的逗号分隔列表，例如 $[a,b,c,d]$，其中 $a$ 和 $b$ 是浮点数， $c$ 和 $d$ 是布尔值。不应打印其他任何文本。", "solution": "所提供的问题陈述经过验证，被认为是科学上可靠、适定且客观的。它描述了一个阻尼谐振子，这是经典力学中的一个典型系统，由二阶线性常微分方程 $m \\ddot{x} + \\gamma \\dot{x} + kx = 0$ 控制。任务是推导一个合适的数值积分方案，并将其应用于多个测试案例。所有参数均已提供，所要求的指标也定义明确。该问题有效。\n\n离散时间更新映射的推导过程如下。运动方程为 $m \\ddot{x}(t) = -k x(t) - \\gamma \\dot{x}(t)$。设 $a(t) = \\ddot{x}(t)$ 为加速度，$v(t) = \\dot{x}(t)$ 为速度，$x(t)$ 为位置。系统在时间 $t_n = n \\Delta t$ 的状态由数对 $(x_n, v_n)$ 给出。我们寻求一个映射 $(x_n, v_n) \\mapsto (x_{n+1}, v_{n+1})$。\n\n分子动力学的一个标准方法是速度Verlet算法。对于一个普遍的随时间变化的加速度 $a(t)$，其更新规则为：\n$$\nx_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n \\Delta t^2\n$$\n$$\nv_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t\n$$\n在我们的系统中，加速度 $a(t)$ 同时依赖于位置和速度：$a(t) = \\frac{1}{m}(-k x(t) - \\gamma v(t))$。因此，$a_n = \\frac{1}{m}(-k x_n - \\gamma v_n)$ 且 $a_{n+1} = \\frac{1}{m}(-k x_{n+1} - \\gamma v_{n+1})$。\n\n位置更新是显式的：$x_{n+1}$ 可以直接由 $x_n$ 和 $v_n$ 计算得出。然而，速度更新变成了隐式的，因为 $a_{n+1}$ 依赖于 $v_{n+1}$，而这正是我们希望计算的量：\n$$\nv_{n+1} = v_n + \\frac{\\Delta t}{2} \\left( a_n + \\frac{-k x_{n+1} - \\gamma v_{n+1}}{m} \\right)\n$$\n这个方程可以重排以求解 $v_{n+1}$：\n$$\nv_{n+1} = v_n + \\frac{\\Delta t}{2} a_n - \\frac{k \\Delta t}{2m} x_{n+1} - \\frac{\\gamma \\Delta t}{2m} v_{n+1}\n$$\n$$\nv_{n+1} \\left(1 + \\frac{\\gamma \\Delta t}{2m}\\right) = v_n + \\frac{\\Delta t}{2} \\left( a_n - \\frac{k}{m} x_{n+1} \\right)\n$$\n由于这种依赖关系是线性的，我们可以找到 $v_{n+1}$ 的一个显式表达式：\n$$\nv_{n+1} = \\left(1 + \\frac{\\gamma \\Delta t}{2m}\\right)^{-1} \\left[ v_n + \\frac{\\Delta t}{2} \\left( \\frac{-k x_n - \\gamma v_n}{m} - \\frac{k x_{n+1}}{m} \\right) \\right]\n$$\n通过对包含 $v_n$ 的项重新组合，可以将其简化为：\n$$\nv_{n+1} = \\left(1 + \\frac{\\gamma \\Delta t}{2m}\\right)^{-1} \\left[ v_n \\left(1 - \\frac{\\gamma \\Delta t}{2m}\\right) - \\frac{k \\Delta t}{2m} (x_n + x_{n+1}) \\right]\n$$\n该方案通常被称为Brünger-Brooks-Karplus (BBK)积分器，它提供了一个完全显式的更新过程。首先，从 $(x_n, v_n)$ 计算出 $x_{n+1}$。然后，使用这个新位置 $x_{n+1}$ 以及 $(x_n, v_n)$ 来计算 $v_{n+1}$。\n\n我们必须验证该方案在极限 $\\gamma \\to 0$ 时能退化为标准的速度Verlet算法。如果我们设置 $\\gamma=0$，方程变为：\n$$\nx_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} \\left( \\frac{-k x_n}{m} \\right) \\Delta t^2 = x_n + v_n \\Delta t + \\frac{1}{2} a_n \\Delta t^2\n$$\n$$\nv_{n+1} = (1+0)^{-1} \\left[ v_n(1-0) - \\frac{k \\Delta t}{2m}(x_n + x_{n+1}) \\right] = v_n + \\frac{\\Delta t}{2} \\left( \\frac{-k x_n}{m} + \\frac{-k x_{n+1}}{m} \\right) = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t\n$$\n这正是在力为 $F(x) = -kx$ 的守恒场中速度Verlet算法的方程。因此，推导出的积分器满足问题的所有要求。\n\n模拟算法如下：\n给定初始条件 $(x_0, v_0)$ 和参数 $m, k, \\gamma, \\Delta t, T$。步数 $N = \\text{round}(T/\\Delta t)$。\n初始化大小为 $N+1$ 的位置数组 $x$、速度数组 $v$ 和能量数组 $E$。设置 $x[0]=x_0, v[0]=v_0$。\n对于 $n$ 从 $0$ 到 $N-1$:\n1. 计算下一个位置 $x_{n+1}$:\n   $$\n   x_{n+1} = x_n + v_n \\Delta t + \\frac{\\Delta t^2}{2m}(-k x_n - \\gamma v_n)\n   $$\n2. 计算下一个速度 $v_{n+1}:\n   $$\n   c = \\frac{\\gamma \\Delta t}{2m}\n   $$\n   $$\n   v_{n+1} = \\frac{1}{1+c} \\left[ v_n(1-c) - \\frac{k \\Delta t}{2m}(x_n + x_{n+1}) \\right]\n   $$\n3. 将 $x_{n+1}$ 和 $v_{n+1}$ 存储在数组中。\n循环结束后，对所有 $n \\in \\{0, 1, \\dots, N\\}$，计算能量时间序列 $E_n = \\frac{1}{2} m v_n^2 + \\frac{1}{2} k x_n^2$。\n此过程应用于指定的四个测试案例中的每一个。\n\n对于情况A，对 $n \\geq N_b=200$ 的数据，执行 $\\ln E_n$ 相对于 $t_n$ 的无权线性最小二乘拟合。得到斜率 $s$。对于小阻尼情况，能量的解析衰减近似为 $E(t) \\approx E_0 e^{-(\\gamma/m) t}$，这意味着 $\\ln E(t) \\approx \\ln E_0 - (\\gamma/m)t$。因此，我们预期斜率 $s$ 会接近 $-\\gamma/m$。指标为 $|s + \\gamma/m|$。\n\n对于情况B，系统是守恒的（$\\gamma=0$），因此能量应该守恒。指标是能量与其初始值的最大相对偏差，$\\max_n |E_n - E_0|/E_0$。\n\n对于情况C，系统是强阻尼的。从解析上看，能量必须是时间的非增函数，因为 $\\frac{dE}{dt} = -\\gamma v^2 \\le 0$。该指标检查是否对所有步都满足 $E_{n+1} \\le E_n + \\varepsilon$，从而验证数值方案在小的浮点容差 $\\varepsilon = 10^{-12}$ 内保持了此属性。\n\n对于情况D，用一个大的时间步长来测试积分器的稳定性。该指标验证轨迹是否保持有界（即 $|x_n|, |v_n|  B = 10^3$），并且能量保持非负（即 $E_n \\ge -\\delta = -10^{-12}$），这证实了没有出现数值爆炸或非物理行为。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    def simulate(m, k, gamma, x0, v0, dt, T):\n        \"\"\"\n        Simulates the damped harmonic oscillator using the derived integrator.\n        \n        Args:\n            m (float): Mass of the particle.\n            k (float): Spring constant.\n            gamma (float): Damping coefficient.\n            x0 (float): Initial position.\n            v0 (float): Initial velocity.\n            dt (float): Time step.\n            T (float): Total simulation time.\n            \n        Returns:\n            tuple: A tuple containing arrays for time, position, velocity, and energy.\n        \"\"\"\n        num_steps = int(round(T / dt))\n        ts = np.linspace(0, T, num_steps + 1)\n        xs = np.zeros(num_steps + 1)\n        vs = np.zeros(num_steps + 1)\n        \n        xs[0] = x0\n        vs[0] = v0\n\n        # Precompute constants for the loop\n        c = (gamma * dt) / (2.0 * m)\n        k_dt_2m = (k * dt) / (2.0 * m)\n\n        for n in range(num_steps):\n            # Current state\n            x_n, v_n = xs[n], vs[n]\n            \n            # 1. Update position\n            a_n = (-k * x_n - gamma * v_n) / m\n            x_n_plus_1 = x_n + v_n * dt + 0.5 * a_n * dt**2\n            \n            # 2. Update velocity\n            # The derived formula:\n            # v_{n+1} = (1/(1+c)) * [v_n*(1-c) - (k*dt/(2*m))*(x_n + x_{n+1})]\n            v_n_plus_1 = (1.0 / (1.0 + c)) * (v_n * (1.0 - c) - k_dt_2m * (x_n + x_n_plus_1))\n            \n            xs[n + 1] = x_n_plus_1\n            vs[n + 1] = v_n_plus_1\n            \n        Es = 0.5 * m * vs**2 + 0.5 * k * xs**2\n        return ts, xs, vs, Es\n\n    # --- Test Cases ---\n    test_cases = [\n        {'m': 1.0, 'k': 1.0, 'gamma': 0.1, 'x0': 1.0, 'v0': 0.0, 'dt': 0.01, 'T': 50.0}, # Case A\n        {'m': 1.0, 'k': 1.0, 'gamma': 0.0, 'x0': 1.0, 'v0': 0.0, 'dt': 0.01, 'T': 50.0}, # Case B\n        {'m': 1.0, 'k': 1.0, 'gamma': 5.0, 'x0': 1.0, 'v0': 0.0, 'dt': 0.001, 'T': 5.0}, # Case C\n        {'m': 1.0, 'k': 1.0, 'gamma': 0.5, 'x0': 1.0, 'v0': 0.0, 'dt': 0.2, 'T': 100.0} # Case D\n    ]\n    \n    results = []\n\n    # Case A: Energy dissipation rate estimation\n    pA = test_cases[0]\n    ts_A, _, _, Es_A = simulate(**pA)\n    N_b = 200\n    # Filter out any non-positive energies before taking the log to avoid warnings/errors\n    valid_indices = (Es_A[N_b:] > 0)\n    t_fit = ts_A[N_b:][valid_indices]\n    log_E_fit = np.log(Es_A[N_b:][valid_indices])\n    \n    # Perform linear least-squares fit (slope is the first element of the result)\n    if len(t_fit) > 1:\n        slope_s = np.polyfit(t_fit, log_E_fit, 1)[0]\n        result_A = abs(slope_s + pA['gamma'] / pA['m'])\n    else: # Handle case where no data is available for fit\n        result_A = np.nan\n    results.append(result_A)\n\n    # Case B: Conservative limit energy drift\n    pB = test_cases[1]\n    _, _, _, Es_B = simulate(**pB)\n    E0_B = Es_B[0]\n    if E0_B > 0:\n        result_B = np.max(np.abs(Es_B - E0_B)) / E0_B\n    else: # Avoid division by zero if initial energy is zero\n        result_B = 0.0 if np.all(Es_B == 0) else np.nan\n    results.append(result_B)\n\n    # Case C: Monotonic energy decrease under strong damping\n    pC = test_cases[2]\n    _, _, _, Es_C = simulate(**pC)\n    epsilon_C = 1e-12\n    result_C = np.all(Es_C[1:] = Es_C[:-1] + epsilon_C)\n    results.append(result_C)\n\n    # Case D: Numerical stability under coarse time step\n    pD = test_cases[3]\n    _, xs_D, vs_D, Es_D = simulate(**pD)\n    bound_B = 1e3\n    delta_D = 1e-12\n    is_bounded = np.max(np.abs(xs_D))  bound_B and np.max(np.abs(vs_D))  bound_B\n    is_energy_physical = np.all(Es_D >= -delta_D)\n    result_D = is_bounded and is_energy_physical\n    results.append(result_D)\n    \n    # Final print statement in the exact required format.\n    # We must explicitly convert booleans to lowercase 'true'/'false' as per common conventions\n    # although standard str() in Python would give 'True'/'False'. The problem is ambiguous.\n    # Assuming standard Python string conversion for bools.\n    results_str = [str(r).lower() if isinstance(r, bool) else f\"{r:.6g}\" for r in results]\n    print(f\"[{','.join(results_str)}]\")\n\n\nsolve()\n```", "id": "2414487"}]}