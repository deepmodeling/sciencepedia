{"hands_on_practices": [{"introduction": "许多科学计算任务受限于内存带宽，尤其是在处理大型数据结构时。本练习将引导你分析一种经典的优化策略：将轻量级的“键-索引”对从大型数据结构中分离出来进行排序，然后再根据排序结果重排原始数据。通过基于屋顶线（roofline）模型的计算，你将能够量化这种方法相比于直接排序大型结构所带来的显著性能提升，从而理解算法设计如何直接影响数据移动和执行效率 [@problem_id:2398440]。", "problem": "您正在为图形处理单元（GPU）设计一个带宽高效的排序流水线，用于对物理模拟中的一个记录数组进行排序。每条记录是一个固定大小的结构体，包含一个32位的键和一个大的有效载荷。该模拟仅需要按键进行排序。目标是设计一个能够隔离内存带宽瓶颈的内核方案，并使用基于 Roofline 视角的第一性原理模型来估算执行时间。\n\n基本原理：\n- Roofline 模型指出，对于一个受内存带宽限制的内核，其执行时间的下限是总传输字节数与持续设备内存带宽之比。如果一个内核通过设备内存移动了总共 $X$ 字节，且持续带宽为每秒 $B$ 字节，则时间 $T$ 满足 $T \\ge X / B$。\n- 对于一个 $w$ 位的键，采用每遍处理 $r$ 位的最低有效位并行基数排序，需要 $p = w / r$ 遍。\n- 在稳定并行基数排序的全局内存乒乓实现中，每一遍都会对被排序的数组执行一次完整的读取和一次完整的写入。\n\n场景与定义：\n- 设 $N$ 为元素数量。\n- 设 $S$ 为结构体大小（字节）。\n- 设 $K$ 为键大小（字节），对于32位键，$K = 4$。\n- 设 $I$ 为索引大小（字节）（对于 $N \\le 2^{32}$，使用 $I = 4$）。\n- 设 $w = 32$ 为键的宽度（位）。\n- 设 $r$ 为每遍基数排序处理的位数，因此遍数为 $p = w / r$。\n- 设 $B$ 为持续设备内存带宽（字节/秒）。\n- 所有时间必须以秒为单位表示。所有角度均不适用。不使用百分比。\n\n两种策略：\n- 策略A（完整结构体排序）：直接对大小为 $S$ 字节的结构体数组执行稳定基数排序。在乒乓模型下，忽略直方图开销，每一遍都会读写整个数组，因此移动的总字节数为\n$$\nX_{\\mathrm{A}}(N,S,p) = N \\cdot (2 S) \\cdot p.\n$$\n受带宽限制的时间估计为\n$$\nT_{\\mathrm{A}} = \\frac{X_{\\mathrm{A}}}{B}.\n$$\n- 策略B（先排序键和索引，然后置换，以隔离带宽）：物化一个单独的键-索引对数组，对这个更轻量的数组进行排序，然后对大的结构体执行一次置换操作。假设物化操作从每个结构体元素中一次性读取 $K$ 字节，并将 $K+I$ 字节写入到键-索引数组中。键-索引对的排序在每一遍中需要对每个元素进行 $K+I$ 字节的读取和写入。最终的结构体置换对每个元素执行一次 $S$ 字节的读取和一次 $S$ 字节的写入。移动的总字节数为\n$$\nX_{\\mathrm{B}}(N,S,K,I,p) = N \\cdot \\Big( (2K + I) + 2 (K+I) p + 2 S \\Big).\n$$\n受带宽限制的时间估计为\n$$\nT_{\\mathrm{B}} = \\frac{X_{\\mathrm{B}}}{B}.\n$$\n策略B相对于策略A的预测加速比为\n$$\n\\text{Speedup} = \\frac{T_{\\mathrm{A}}}{T_{\\mathrm{B}}} = \\frac{X_{\\mathrm{A}}}{X_{\\mathrm{B}}}.\n$$\n\n实现要求：\n- 实现一个程序，为以下每个测试用例计算 $T_{\\mathrm{A}}$、$T_{\\mathrm{B}}$ 和加速比。不要分配大小为 $N$ 的数组；使用上述公式进行解析计算时间。\n- 单位：以秒为单位报告时间 $T_{\\mathrm{A}}$ 和 $T_{\\mathrm{B}}$。所有浮点输出格式化为小数点后恰好六位数字。\n- 此外，通过构建一个微小的结构体数组，分别使用完整结构体排序和键-索引加置换排序（使用中央处理器（CPU）代码），在一个小的合成案例上验证算法转换的正确性，并检查最终的键顺序是否匹配。此正确性检查必须产生一个布尔值。\n- 对于所有情况，使用 $w = 32$ 位和 $K = 4$ 字节。使用 $I = 4$ 字节。使用 $p = w / r$。\n\n测试套件：\n- 情况1：$N = 10^9$，$S = 128$ 字节，$r = 8$ 位/遍，$B = 900 \\times 10^9$ 字节/秒。\n- 情况2：$N = 10^9$，$S = 64$ 字节，$r = 4$ 位/遍，$B = 900 \\times 10^9$ 字节/秒。\n- 情况3：$N = 5 \\times 10^7$，$S = 192$ 字节，$r = 8$ 位/遍，$B = 450 \\times 10^9$ 字节/秒。\n- 情况4：$N = 2 \\times 10^8$，$S = 16$ 字节，$r = 8$ 位/遍，$B = 1.6 \\times 10^{12}$ 字节/秒。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：\n$[T_{\\mathrm{A}}^{(1)}, T_{\\mathrm{B}}^{(1)}, \\text{Speedup}^{(1)}, T_{\\mathrm{A}}^{(2)}, T_{\\mathrm{B}}^{(2)}, \\text{Speedup}^{(2)}, T_{\\mathrm{A}}^{(3)}, T_{\\mathrm{B}}^{(3)}, \\text{Speedup}^{(3)}, T_{\\mathrm{A}}^{(4)}, T_{\\mathrm{B}}^{(4)}, \\text{Speedup}^{(4)}, \\text{Correct}]$\n其中上标 $(i)$ 表示测试用例 $i$，每个时间和加速比都是小数点后有六位数字的浮点数，如果小案例验证显示两种策略排序后的键顺序相同，则 $\\text{Correct}$ 是一个布尔值 `true`。不应打印任何其他文本。", "solution": "问题陈述已经过严格评估，并被认为是有效的。它在科学上基于计算性能建模的原理，特别是应用于GPU内存带宽的Roofline模型。该问题定义明确、客观，并为获得唯一解提供了所有必要的数据和公式。我们将按要求进行解析求解和算法验证。\n\n目标是比较两种策略，用于根据一个 $w$ 位的键对一个包含 $N$ 条记录的数组进行排序，每条记录大小为 $S$ 字节。该比较是通过在内存带宽受限的假设下估算执行时间来进行的。\n\n关键参数定义如下：\n- $N$：记录数。\n- $S$：一条记录（结构体）的大小，以字节为单位。\n- $K$：排序键的大小，以字节为单位，给定为 $K=4$。\n- $I$：索引的大小，以字节为单位，给定为 $I=4$。\n- $w$：键的宽度，以位为单位，给定为 $w=32$。\n- $r$：基数排序每遍处理的位数。\n- $p$：基数排序的遍数，计算为 $p=w/r$。\n- $B$：持续设备内存带宽，以字节/秒为单位。\n\n使用Roofline模型，一个受内存带宽限制的内核的执行时间 $T$ 估计为：\n$$T \\ge \\frac{X}{B}$$\n其中 $X$ 表示与设备内存之间传输的总字节数。我们将使用等式 $T = X/B$ 进行估算。\n\n**策略A：完整结构体排序**\n\n此策略直接对记录数组执行稳定基数排序。根据所提供的乒乓模型，基数排序的 $p$ 遍中的每一遍都涉及读取整个包含 $N$ 条记录的数组并将其写回内存。\n数组的大小为 $N \\cdot S$ 字节。\n一遍的内存流量是一次完整的读取和一次完整的写入：$N \\cdot S + N \\cdot S = 2 N S$ 字节。\n对于 $p$ 遍，总内存流量 $X_{\\mathrm{A}}$ 为：\n$$X_{\\mathrm{A}}(N, S, p) = N \\cdot (2S) \\cdot p$$\n相应的估算执行时间 $T_{\\mathrm{A}}$ 为：\n$$T_{\\mathrm{A}} = \\frac{2NSp}{B}$$\n\n**策略B：键-索引排序和置换**\n\n此策略旨在通过对数据的轻量级表示进行排序，并在最后一步将结果顺序应用于完整记录，从而最小化内存流量。该过程包括三个阶段：\n\n1.  **物化键-索引对：** 创建一个 (键, 索引) 对的临时数组。这需要一个内核，它从 $N$ 个原始结构体中读取键，并写出一个由键和元素的原始索引组成的新对。\n    - 读取字节数：$N \\cdot K$。\n    - 写入字节数：$N \\cdot (K+I)$。\n    - 此阶段的总流量：$N \\cdot K + N \\cdot (K+I) = N \\cdot (2K+I)$。\n\n2.  **排序键-索引对：** 对包含 $N$ 个键-索引对的数组执行稳定基数排序。每个对的大小为 $(K+I)$ 字节。\n    - 一遍的内存流量（读和写）：$N \\cdot (K+I) + N \\cdot (K+I) = 2N(K+I)$。\n    - $p$ 遍的总流量：$p \\cdot 2N(K+I)$。\n\n3.  **置换完整结构体：** 排序后的顺序（现已编码在已排序的键-索引数组中）用于将原始的大结构体重新排列成一个新的已排序数组。该模型将这个复杂的收集（gather）操作简化为对结构体数组的一次完整读取和一次完整写入。\n    - 置换的总流量：$N \\cdot S (\\text{读取}) + N \\cdot S (\\text{写入}) = 2NS$。\n\n策略B的总内存流量 $X_{\\mathrm{B}}$ 是所有三个阶段流量的总和：\n$$X_{\\mathrm{B}}(N, S, K, I, p) = N \\cdot (2K+I) + N \\cdot 2p(K+I) + N \\cdot 2S$$\n$$X_{\\mathrm{B}}(N, S, K, I, p) = N \\cdot \\Big( (2K+I) + 2p(K+I) + 2S \\Big)$$\n相应的估算执行时间 $T_{\\mathrm{B}}$ 为：\n$$T_{\\mathrm{B}} = \\frac{X_{\\mathrm{B}}}{B}$$\n\n**加速比计算**\n\n策略B相对于策略A的加速比是它们执行时间的比率：\n$$\\text{Speedup} = \\frac{T_{\\mathrm{A}}}{T_{\\mathrm{B}}} = \\frac{X_{\\mathrm{A}}/B}{X_{\\mathrm{B}}/B} = \\frac{X_{\\mathrm{A}}}{X_{\\mathrm{B}}}$$\n\n**算法正确性验证**\n\n为了验证策略B产生与策略A相同的排序结果，我们进行了一个小规模测试。首先创建一个包含随机键的初始记录数组。然后使用两种方法对其进行排序：\n1.  直接对记录数组应用稳定排序，按键字段进行排序。\n2.  创建一个 (键, 原始索引) 对的数组，按键进行稳定排序，并使用得到的已排序索引将原始数组置换成一个新数组。\n比较两种方法得到的最终排序数组是否相等。一个布尔值指示结果是否匹配。\n\n**计算示例（情况1）**\n\n- 给定：$N=10^9$，$S=128$，$r=8$，$B=900 \\times 10^9$。\n- 常量：$w=32$，$K=4$，$I=4$。\n- 遍数：$p = w/r = 32/8 = 4$。\n\n- **策略A：**\n  $X_{\\mathrm{A}} = 10^9 \\cdot (2 \\cdot 128) \\cdot 4 = 1.024 \\times 10^{12}$ 字节。\n  $T_{\\mathrm{A}} = \\frac{1.024 \\times 10^{12}}{900 \\times 10^9} \\approx 1.137778$ 秒。\n\n- **策略B：**\n  $X_{\\mathrm{B}} = 10^9 \\cdot \\Big( (2 \\cdot 4 + 4) + 2 \\cdot 4 \\cdot (4+4) + 2 \\cdot 128 \\Big) = 10^9 \\cdot (12 + 64 + 256) = 3.32 \\times 10^{11}$ 字节。\n  $T_{\\mathrm{B}} = \\frac{3.32 \\times 10^{11}}{900 \\times 10^9} \\approx 0.368889$ 秒。\n\n- **加速比：**\n  $\\text{Speedup} = \\frac{T_{\\mathrm{A}}}{T_{\\mathrm{B}}} = \\frac{1.137778}{0.368889} \\approx 3.084337$。\n\n对所有测试用例应用相同的过程，并将结果汇编到最终输出中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes performance estimates for two sorting strategies and verifies\n    algorithmic correctness on a small case.\n    \"\"\"\n\n    # --- Part 1: Algorithmic Correctness Verification ---\n\n    def verify_correctness():\n        \"\"\"\n        Verify that sorting keys-and-indices then permuting produces the\n        same result as sorting the full structs directly.\n        \"\"\"\n        # Create a small, synthetic dataset of structs (records)\n        # A struct has a 'key' and a 'payload'\n        num_records = 20\n        # Use a seed for reproducibility\n        rng = np.random.default_rng(seed=42)\n        # Generate some duplicate keys to test for stability\n        keys = rng.integers(0, 10, size=num_records, dtype=np.uint32)\n        \n        # Create the structured array\n        struct_dtype = np.dtype([('key', np.uint32), ('payload', np.uint8, (12,))])\n        structs = np.zeros(num_records, dtype=struct_dtype)\n        structs['key'] = keys\n        # Assign a unique payload to each record to check permutation\n        for i in range(num_records):\n            structs[i]['payload'] = i\n\n        # --- Strategy A: Sort full structs ---\n        # Use a stable sort to respect original order of duplicate keys\n        result_a = np.sort(structs, order='key', kind='stable')\n\n        # --- Strategy B: Sort key-index pairs, then permute ---\n        # 1. Materialize key-index pairs\n        key_index_dtype = np.dtype([('key', np.uint32), ('index', np.uint32)])\n        key_index_pairs = np.empty(num_records, dtype=key_index_dtype)\n        key_index_pairs['key'] = structs['key']\n        key_index_pairs['index'] = np.arange(num_records, dtype=np.uint32)\n\n        # 2. Sort key-index pairs (stably)\n        sorted_key_index_pairs = np.sort(key_index_pairs, order='key', kind='stable')\n\n        # 3. Permute original structs according to sorted indices\n        # This is a gather operation: result_b[i] = structs[old_index]\n        permuted_indices = sorted_key_index_pairs['index']\n        result_b = structs[permuted_indices]\n\n        # 4. Verification: check if the two results are identical\n        return np.array_equal(result_a, result_b)\n\n    correctness_check_passed = verify_correctness()\n\n    # --- Part 2: Performance Estimation for Test Cases ---\n    \n    # Define constants from the problem statement\n    w = 32  # key width in bits\n    K = 4   # key size in bytes\n    I = 4   # index size in bytes\n\n    # Define the test cases\n    test_cases = [\n        # (N, S, r, B)\n        (10**9, 128, 8, 900 * 10**9),\n        (10**9, 64, 4, 900 * 10**9),\n        (5 * 10**7, 192, 8, 450 * 10**9),\n        (2 * 10**8, 16, 8, 1.6 * 10**12),\n    ]\n\n    results = []\n    \n    for N, S, r, B in test_cases:\n        N, S, r, B = float(N), float(S), float(r), float(B)\n        \n        # Number of radix sort passes\n        p = w / r\n\n        # Strategy A: full-struct sort\n        X_A = N * (2 * S) * p\n        T_A = X_A / B\n\n        # Strategy B: keys-and-indices then permute\n        X_B = N * ((2 * K + I) + 2 * p * (K + I) + 2 * S)\n        T_B = X_B / B\n        \n        # Speedup\n        speedup = T_A / T_B if T_B > 0 else 0.0\n\n        results.extend([T_A, T_B, speedup])\n\n    # Format results to six decimal places\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    \n    # Append the boolean correctness check result\n    formatted_results.append(str(correctness_check_passed).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2398440"}, {"introduction": "为了有效利用GPU的计算能力并克服内存带宽瓶颈，分块（tiling）是一种至关重要的技术，它通过片上共享内存（shared memory）提升了数据复用。本练习将带你深入分析分块矩阵乘法这一典型高性能计算应用，你将学习如何通过模型化计算，评估不同分块策略对共享内存使用、全局内存流量以及算术强度（arithmetic intensity）的影响 [@problem_id:2398448]。", "problem": "要求您设计并实现一个程序，该程序用于模拟在图形处理器 (GPU) 计算中用于科学模拟的经典分块通用矩阵乘法 (GEMM) 内核的内存流量和算术强度。情景设定为非方阵的矩阵乘积 $C = A \\times B$，其中 $A \\in \\mathbb{R}^{M \\times K}$，$B \\in \\mathbb{R}^{K \\times N}$，以及 $C \\in \\mathbb{R}^{M \\times N}$。假设的数值类型为单精度浮点数（$32$位），因此每个矩阵元素在内存中占用 $4$ 字节。推理的数学基础是矩阵乘法的定义、由该定义推导出的浮点运算计数，以及高性能计算中使用的简单分块概念。\n\n从以下基本依据出发：\n- 矩阵乘法的定义：对于每个 $i \\in \\{1,\\dots,M\\}$ 和 $j \\in \\{1,\\dots,N\\}$，$C_{ij} = \\sum_{k=1}^{K} A_{ik} B_{kj}$。\n- 矩阵乘法的浮点运算计数：计算 $C = A \\times B$ 执行 $M \\times N \\times K$ 次乘加对操作（每次操作包含一次乘法和一次加法），即 $2 \\times M \\times N \\times K$ 次浮点运算。\n- 在分块算法中，输出矩阵 $C$ 被划分为大小为 $T_M \\times T_N$ 的块（tile）。对于每个输出块，内核以大小为 $T_K$ 的块遍历 $K$ 维度，从全局内存中加载一个大小为 $T_M \\times T_K$ 的 $A$ 矩阵块和一个大小为 $T_K \\times T_N$ 的 $B$ 矩阵块到片上共享内存中，计算部分和，最后将该块的 $T_M \\times T_N$ 个结果一次性写入全局内存。\n\n用于建模内存移动和并行分解的假设：\n- 不同线程块之间没有缓存或共享内存复用；仅利用块内沿 $K$ 维度遍历时的复用。因此，为一个输出块获取的数据不会被其他块复用。\n- 每个块的共享内存占用主要由同时驻留的 $A$ 和 $B$ 的块决定，即 $A$ 的 $T_M \\times T_K$ 个元素和 $B$ 的 $T_K \\times T_N$ 个元素。\n- 每个矩阵元素占用 $4$ 字节。\n- 沿 $M$ 和 $N$ 维度的分块使用向上取整除法：沿 $M$ 维度的块（tile）数量为 $\\lceil M / T_M \\rceil$，沿 $N$ 维度的块数量为 $\\lceil N / T_N \\rceil$。当维度不能被块大小整除时，边界上的块可能部分填充。\n- 所有大小均以字节表示。不出现物理单位。不出现角度。不需要百分比。\n\n任务：\n- 基于上述依据，推导以下表达式：\n  - 网格维度（以块为单位），即沿 $M$ 和 $N$ 维度的块数量。\n  - 总块数。\n  - 每个块的共享内存使用量（以字节为单位），假设 $A$ 块和 $B$ 块同时驻留。\n  - 一个布尔值，指示每个块的共享内存使用量是否在给定的共享内存预算 $S_{\\max}$（以字节为单位）之内。\n  - 在无块间复用假设下，内核传输的总全局内存字节数，计算整个乘法过程中所有块和所有 $K$ 块的全部读写操作。\n  - 算术强度，定义为总浮点运算次数除以总全局内存传输字节数，针对整个乘法过程。\n- 实现一个程序，为下面的每个测试用例计算并输出：\n  - $\\lceil M / T_M \\rceil$，\n  - $\\lceil N / T_N \\rceil$,\n  - $\\lceil M / T_M \\rceil \\times \\lceil N / T_N \\rceil$,\n  - 每个块的共享内存（字节），\n  - 相对于 $S_{\\max}$ 的适应性布尔值，\n  - 总全局内存传输字节数，\n  - 算术强度（浮点数，四舍五入到 $10^{-6}$）。\n- 程序不得读取任何输入。它必须计算嵌入在代码中的测试套件的结果，并打印包含所有结果的单行输出。\n\n测试套件：\n- 案例 $1$：$M = 1000$, $K = 750$, $N = 1100$, $T_M = 64$, $T_N = 64$, $T_K = 16$, $S_{\\max} = 49152$ 字节。\n- 案例 $2$：$M = 1000$, $K = 750$, $N = 1100$, $T_M = 128$, $T_N = 32$, $T_K = 32$, $S_{\\max} = 16384$ 字节。\n- 案例 $3$：$M = 1000$, $K = 750$, $N = 1100$, $T_M = 32$, $T_N = 128$, $T_K = 32$, $S_{\\max} = 49152$ 字节。\n- 案例 $4$：$M = 2048$, $K = 256$, $N = 96$, $T_M = 128$, $T_N = 16$, $T_K = 64$, $S_{\\max} = 49152$ 字节。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含结果，形式为每个测试用例记录的列表，每个记录本身是按 $[\\lceil M / T_M \\rceil,\\ \\lceil N / T_N \\rceil,\\ \\lceil M / T_M \\rceil \\times \\lceil N / T_N \\rceil,\\ \\text{共享内存字节数},\\ \\text{是否适配},\\ \\text{总字节数},\\ \\text{算术强度}]$ 顺序排列的列表。\n- 打印的行必须是精确的单个 Python 风格列表，例如：$[[\\dots],[\\dots],\\dots]$。\n- 算术强度必须四舍五入到 $10^{-6}$。", "solution": "所提出的问题是并行算法性能建模方面一个明确定义的练习，特别是关于图形处理器 (GPU) 上的分块通用矩阵乘法 (GEMM)。它在科学上植根于计算线性代数和计算机体系结构的原理。所有必要的参数都已提供，假设也已明确说明，这使得问题有效且可解。我们接下来推导所需的性能指标。\n\n问题背景是矩阵乘法 $C = A \\times B$，其中 $A \\in \\mathbb{R}^{M \\times K}$，$B \\in \\mathbb{R}^{K \\times N}$，以及 $C \\in \\mathbb{R}^{M \\times N}$。每个矩阵元素是单精度浮点数，占用 $S_{elem} = 4$ 字节。该算法将输出矩阵 $C$ 划分为大小为 $T_M \\times T_N$ 的块（block），或称 tile。\n\n1.  **网格维度和总块数**\n    计算网格是线程块的二维排列，其中每个块负责计算输出矩阵 $C$ 的一个 $T_M \\times T_N$ 大小的块。\n    沿 $M$ 维度所需的块数，我们记为 $GridDim_{M}$，由覆盖矩阵 $M$ 行需要多少个高度为 $T_M$ 的块决定。这需要向上取整除法。\n    $$GridDim_{M} = \\lceil M / T_M \\rceil$$\n    类似地，沿 $N$ 维度的块数 $GridDim_{N}$ 为：\n    $$GridDim_{N} = \\lceil N / T_N \\rceil$$\n    网格中的总块数 $N_{blocks}$ 是这两个维度的乘积：\n    $$N_{blocks} = GridDim_{M} \\times GridDim_{N} = \\lceil M / T_M \\rceil \\times \\lceil N / T_N \\rceil$$\n\n2.  **每块共享内存使用量**\n    对于每个输出块，一个线程块以大小为 $T_K$ 的步长遍历 $K$ 维度。在每一步中，它将一个大小为 $T_M \\times T_K$ 的 $A$ 的微块（micro-tile）和一个大小为 $T_K \\times T_N$ 的 $B$ 的微块加载到其片上共享内存中。问题陈述中指出，共享内存占用主要由这两个块的同时驻留决定。\n    来自 $A$ 的块的元素数量为 $T_M \\times T_K$。\n    来自 $B$ 的块的元素数量为 $T_K \\times T_N$。\n    所需的总共享内存（以字节为单位）$S_{shared}$ 是这两个块大小的总和：\n    $$S_{shared} = ( (T_M \\times T_K) + (T_K \\times T_N) ) \\times S_{elem}$$\n    $$S_{shared} = T_K \\times (T_M + T_N) \\times 4$$\n\n3.  **共享内存适配布尔值**\n    这是一个简单的逻辑验证。计算出的所需共享内存 $S_{shared}$ 不得超过每个块可用的共享内存预算 $S_{\\max}$。布尔值 $B_{fit}$ 由以下条件确定：\n    $$B_{fit} = (S_{shared} \\le S_{\\max})$$\n\n4.  **总全局内存传输字节数**\n    我们分析 GPU 全局内存与处理单元之间的总数据移动量，假设不同线程块之间没有数据复用。\n    -   **从矩阵 A 读取：** 整个矩阵 $A$（大小为 $M \\times K$）必须被读取。考虑 $C$ 的分块。对于 $C$ 的每一列块，整个矩阵 $A$ 都必须被加载。这样的块列有 $GridDim_{N} = \\lceil N / T_N \\rceil$ 个。因此，$A$ 的每个元素被读取 $\\lceil N / T_N \\rceil$ 次。\n        从 A 读取的总字节数：$Bytes_{A} = M \\times K \\times \\lceil N / T_N \\rceil \\times S_{elem}$。\n    -   **从矩阵 B 读取：** 类似地，对于 $C$ 的每一行块，整个矩阵 $B$（大小为 $K \\times N$）都必须被读取。这样的块行有 $GridDim_{M} = \\lceil M / T_M \\rceil$ 个。因此，$B$ 的每个元素被读取 $\\lceil M / T_M \\rceil$ 次。\n        从 B 读取的总字节数：$Bytes_{B} = K \\times N \\times \\lceil M / T_M \\rceil \\times S_{elem}$。\n    -   **写入矩阵 C：** 输出矩阵 $C$（大小为 $M \\times N$）被计算并恰好一次性写入全局内存。\n        写入 C 的总字节数：$Bytes_{C} = M \\times N \\times S_{elem}$。\n\n    总全局内存传输量 $B_{total}$ 是所有读写操作的总和：\n    $$B_{total} = Bytes_{A} + Bytes_{B} + Bytes_{C}$$\n    $$B_{total} = (M \\times K \\times \\lceil N / T_N \\rceil + K \\times N \\times \\lceil M / T_M \\rceil + M \\times N) \\times S_{elem}$$\n\n5.  **算术强度**\n    算术强度 $I$ 是总浮点运算次数 (FLOPs) 与从全局内存传输的总字节数之比。\n    标准矩阵乘法的总 FLOPs 数 $F$ 为 $2 \\times M \\times N \\times K$，计及每个内循环乘积的一次乘法和一次加法。\n    $$F = 2 \\times M \\times N \\times K$$\n    因此，算术强度为：\n    $$I = \\frac{F}{B_{total}} = \\frac{2 \\times M \\times N \\times K}{(M \\times K \\times \\lceil N / T_N \\rceil + K \\times N \\times \\lceil M / T_M \\rceil + M \\times N) \\times 4}$$\n    简化因子为 $2$：\n    $$I = \\frac{M \\times N \\times K}{2 \\times (M \\times K \\times \\lceil N / T_N \\rceil + K \\times N \\times \\lceil M / T_M \\rceil + M \\times N)}$$\n    该表达式量化了每从全局内存移动一字节数据所执行的运算次数，这是衡量内存带宽受限架构（如 GPU）上算法效率的关键指标。期望有更高的值。\n\n这些推导出的公式足以解决给定测试用例的问题。我们现在将进行实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates performance metrics for a tiled GEMM kernel based on a simplified GPU memory model.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (M, K, N, T_M, T_N, T_K, S_max)\n    test_cases = [\n        (1000, 750, 1100, 64, 64, 16, 49152),\n        (1000, 750, 1100, 128, 32, 32, 16384),\n        (1000, 750, 1100, 32, 128, 32, 49152),\n        (2048, 256, 96, 128, 16, 64, 49152),\n    ]\n\n    results = []\n    \n    # Size of a single-precision float in bytes\n    S_elem = 4\n\n    # Helper function for integer ceiling division\n    def ceil_div(a, b):\n        return (a + b - 1) // b\n\n    for case in test_cases:\n        M, K, N, T_M, T_N, T_K, S_max = case\n\n        # 1. Grid dimensions\n        grid_dim_m = ceil_div(M, T_M)\n        grid_dim_n = ceil_div(N, T_N)\n\n        # 2. Total number of blocks\n        total_blocks = grid_dim_m * grid_dim_n\n\n        # 3. Per-block shared memory usage in bytes\n        shared_bytes = (T_M * T_K + T_K * T_N) * S_elem\n\n        # 4. Shared memory fit boolean\n        fits = shared_bytes = S_max\n\n        # 5. Total global-memory bytes transferred\n        # Bytes read from A: each element of A is read grid_dim_n times\n        bytes_read_A = M * K * grid_dim_n * S_elem\n        # Bytes read from B: each element of B is read grid_dim_m times\n        bytes_read_B = K * N * grid_dim_m * S_elem\n        # Bytes written to C: C is written once\n        bytes_written_C = M * N * S_elem\n        total_bytes = bytes_read_A + bytes_read_B + bytes_written_C\n\n        # 6. Arithmetic intensity\n        # Total floating-point operations\n        flops = 2 * M * N * K\n        # Intensity = FLOPs / Byte\n        # Avoid division by zero, though total_bytes should always be positive for valid inputs\n        if total_bytes > 0:\n            arithmetic_intensity = flops / total_bytes\n        else:\n            arithmetic_intensity = 0.0\n\n        # Round intensity to 10^-6\n        rounded_intensity = round(arithmetic_intensity, 6)\n\n        # Assemble the results for the current case\n        case_result = [\n            grid_dim_m,\n            grid_dim_n,\n            total_blocks,\n            shared_bytes,\n            fits,\n            total_bytes,\n            rounded_intensity\n        ]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    print(results)\n\nsolve()\n```", "id": "2398448"}, {"introduction": "即使有效地使用了共享内存，不当的访问模式也可能导致性能陷阱，其中最常见的就是“银行冲突”（bank conflicts）。本练习通过一个非直观的对角线访问模式，让你模拟并量化一个线程束（warp）内的共享内存银行冲突。通过这个实践，你将学会如何诊断并预测特定内存访问模式对性能的影响，这是进行GPU微观优化的关键技能 [@problem_id:2398488]。", "problem": "要求您对图形处理器（GPU）共享内存中一个线程束（warp）的 bank 冲突进行建模和量化，该冲突源于在二维网格上使用对角模板（diagonal stencil）所产生的非直观访问模式。考虑一个由 $W$ 个线程组成的线程束，访问一个存储在具有 $B$ 个 bank 的共享内存中的数据块（tile）。数据块中的每个元素恰好占用一个 bank 宽度的单元，并且数据块的基地址已对齐，使得线性索引为 $0$ 的元素映射到 bank 0。内存布局为行主序，主维度（行步长）为 $L$ 个元素。对于线程道索引 $\\ell \\in \\{0,1,\\dots,W-1\\}$，所访问的数据块坐标由以下公式给出：\n- 行索引 $r(\\ell) = (r_0 + \\ell) \\bmod T_r$，\n- 列索引 $c(\\ell) = (c_0 + \\ell \\cdot d) \\bmod T_c$，\n\n其中 $T_r$ 和 $T_c$ 分别是数据块的行维度和列维度，$r_0$ 和 $c_0$ 是数据块内的基础行和列偏移量，$d$ 是对角步长。线程 $\\ell$ 所寻址的线性元素索引为\n$$\n\\mathrm{idx}(\\ell) = r(\\ell)\\cdot L + c(\\ell),\n$$\nbank 索引为\n$$\n\\mathrm{bank}(\\ell) = \\mathrm{idx}(\\ell) \\bmod B.\n$$\n\n在冲突建模中，假设如下：\n- 在单条内存指令中，每个 bank 在每个周期内只能服务一个不同的元素。如果一个线程束中的 $m$ 个线程同时访问映射到同一 bank 的 $m$ 个不同元素索引，这些访问将被串行化，并花费该 bank $m$ 个周期。\n- 如果多个线程在同一 bank 内同时访问相同的元素索引，这被视为一次广播，并花费该 bank 1 个周期。\n- 对于该内存指令，线程束的冲突度 $C$ 定义为\n$$\nC = \\max_{b \\in \\{0,1,\\dots,B-1\\}} \\left(\\text{线程中 }\\mathrm{bank}(\\ell)=b\\text{ 的不同 }\\mathrm{idx}(\\ell)\\text{ 的数量}\\right).\n$$\n\n您的任务是编写一个完整的程序，针对每个提供的测试用例，计算如上定义的整数冲突度 $C$。\n\n请使用以下测试套件，其中每个测试用例是一个元组 $(B, W, L, T_r, T_c, d, r_0, c_0)$：\n- 案例 1（由于填充导致的轻微冲突的对角线访问）：$(32, 32, 33, 32, 32, 1, 0, 0)$。\n- 案例 2（单个 bank 内无广播的最差情况串行化）：$(32, 32, 32, 32, 32, 0, 0, 0)$。\n- 案例 3（对角线访问构成 bank 的一种排列，无冲突）：$(32, 32, 33, 32, 32, 0, 0, 0)$。\n- 案例 4（退化的对角线访问导致单个 bank 内的广播）：$(32, 32, 64, 1, 64, 0, 0, 0)$。\n- 案例 5（半个线程束的对角线访问，步长导致偶数 bank 映射，但由于每个 bank 仅使用一次而无冲突）：$(32, 16, 33, 16, 16, 1, 0, 0)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序与测试用例相同，例如 $[x_1,x_2,x_3,x_4,x_5]$，其中每个 $x_i$ 是相应测试用例的整数冲突度 $C$。", "solution": "我们根据共享内存 bank 机制的基本原理来对 bank 冲突进行建模。共享内存被划分为 $B$ 个 bank，每个元素占用一个 bank 宽度的单元。在这些假设下，并且基地址对齐，线性索引为 $\\mathrm{idx}$ 的元素的 bank 映射为 $\\mathrm{bank} = \\mathrm{idx} \\bmod B$。对于一个由 $W$ 个线程组成的线程束，每个线程道 $\\ell \\in \\{0,1,\\dots,W-1\\}$ 访问数据块坐标为\n$$\nr(\\ell) = (r_0 + \\ell) \\bmod T_r,\\quad c(\\ell) = (c_0 + \\ell \\cdot d) \\bmod T_c,\n$$\n的元素，因此线性索引为\n$$\n\\mathrm{idx}(\\ell) = r(\\ell)\\cdot L + c(\\ell),\n$$\nbank 为\n$$\n\\mathrm{bank}(\\ell) = \\mathrm{idx}(\\ell) \\bmod B.\n$$\n\n根据定义，线程束的冲突度 $C$ 是在同一条指令中，所有 bank 上映射到该 bank 的不同请求索引数量的最大值：\n$$\nC = \\max_{b \\in \\{0,1,\\dots,B-1\\}} \\left|\\left\\{ \\mathrm{idx}(\\ell) \\,\\big|\\, \\mathrm{bank}(\\ell)=b,\\ \\ell \\in \\{0,1,\\dots,W-1\\} \\right\\}\\right|.\n$$\n该定义自然地涵盖了广播行为：如果多个线程在同一个 bank 内寻址相同的 $\\mathrm{idx}$，它们对该 bank 的计数仅贡献 1。\n\n我们通过枚举 $\\ell \\in \\{0,\\dots,W-1\\}$，计算 $r(\\ell)$、$c(\\ell)$、$\\mathrm{idx}(\\ell)$ 和 $\\mathrm{bank}(\\ell)$，按 bank 分组，统计每个 bank 的不同索引数，并取这些计数的最大值，来为每个测试用例计算 $C$。\n\n我们也可以对所提供的案例进行解析推理：\n\n- 案例 1：$(B,W,L,T_r,T_c,d,r_0,c_0) = (32,32,33,32,32,1,0,0)$。对于 $\\ell \\in \\{0,\\dots,31\\}$，\n$$\nr(\\ell) = \\ell \\bmod 32 = \\ell,\\quad c(\\ell) = \\ell \\bmod 32 = \\ell,\n$$\n因此 $\\mathrm{idx}(\\ell) = \\ell\\cdot 33 + \\ell = \\ell\\cdot 34$。于是\n$$\n\\mathrm{bank}(\\ell) = (\\ell\\cdot 34) \\bmod 32 = \\ell\\cdot (34 \\bmod 32) \\bmod 32 = \\ell\\cdot 2 \\bmod 32.\n$$\n因此，只有偶数 bank $0,2,4,\\dots,30$ 被使用。对于 $\\ell$ 和 $\\ell+16$，我们有\n$$\n\\mathrm{bank}(\\ell+16) = 2(\\ell+16) \\bmod 32 = (2\\ell + 32) \\bmod 32 = 2\\ell \\bmod 32 = \\mathrm{bank}(\\ell),\n$$\n并且 $\\mathrm{idx}(\\ell+16) = (\\ell+16)\\cdot 34 \\neq \\ell\\cdot 34$，因此每个偶数 bank 恰好接收到两个不同的索引。所以 $C=2$。\n\n- 案例 2：$(32,32,32,32,32,0,0,0)$。此处 $r(\\ell)=\\ell$，$c(\\ell)=0$，因此 $\\mathrm{idx}(\\ell)=\\ell\\cdot 32$。于是\n$$\n\\mathrm{bank}(\\ell) = (\\ell\\cdot 32) \\bmod 32 = 0,\n$$\n所以所有线程都映射到 bank 0，且索引各不相同（因为 $\\ell$ 不同）。因此 $C=32$。\n\n- 案例 3：$(32,32,33,32,32,0,0,0)$。此处 $r(\\ell)=\\ell$，$c(\\ell)=0$，因此 $\\mathrm{idx}(\\ell)=\\ell\\cdot 33$。于是\n$$\n\\mathrm{bank}(\\ell) = (\\ell\\cdot 33) \\bmod 32 = \\ell\\cdot (33 \\bmod 32) \\bmod 32 = \\ell \\bmod 32 = \\ell.\n$$\n每个 bank $b\\in\\{0,\\dots,31\\}$ 恰好接收到一个索引。因此 $C=1$。\n\n- 案例 4：$(32,32,64,1,64,0,0,0)$。此处 $T_r=1$，所以对所有 $\\ell$ 都有 $r(\\ell)=0$；$d=0$ 所以 $c(\\ell)=0$。那么 $\\mathrm{idx}(\\ell)=0$，$\\mathrm{bank}(\\ell)=0$。所有线程访问同一个元素，这是一个广播，因此 bank 0 中不同索引的计数为 1。所以 $C=1$。\n\n- 案例 5：$(32,16,33,16,16,1,0,0)$。对于 $\\ell \\in \\{0,\\dots,15\\}$，$r(\\ell)=\\ell \\bmod 16 = \\ell$，$c(\\ell)=\\ell \\bmod 16 = \\ell$，因此 $\\mathrm{idx}(\\ell)=\\ell\\cdot 34$，且 $\\mathrm{bank}(\\ell)=2\\ell \\bmod 32$。偶数 bank $0,2,\\dots,30$ 每个都恰好接收一个索引（因为 $\\ell$ 的取值范围仅有 16 个值），因此 $C=1$。\n\n因此，这五个案例的冲突度分别为 $[2, 32, 1, 1, 1]$。程序实现了上述的枚举过程，计算了每个 bank 的不同索引集合，并以指定的单行列表格式输出这些整数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef conflict_degree(B, W, L, T_r, T_c, d, r0, c0):\n    # Compute bank mapping and conflict degree C as defined in the problem.\n    # Base address aligned; element size equals bank width unit; bank = idx % B.\n    banks = {}  # bank_id -> set of distinct indices (to model broadcast)\n    for ell in range(W):\n        r = (r0 + ell) % T_r\n        c = (c0 + (ell * d)) % T_c\n        idx = r * L + c\n        bank = idx % B\n        if bank not in banks:\n            banks[bank] = set()\n        banks[bank].add(idx)\n    # Conflict degree is the maximum number of distinct indices per bank.\n    if not banks:\n        return 0\n    return max((len(s) for s in banks.values()), default=0)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (B, W, L, T_r, T_c, d, r0, c0)\n    test_cases = [\n        (32, 32, 33, 32, 32, 1, 0, 0),  # Case 1\n        (32, 32, 32, 32, 32, 0, 0, 0),  # Case 2\n        (32, 32, 33, 32, 32, 0, 0, 0),  # Case 3\n        (32, 32, 64, 1, 64, 0, 0, 0),   # Case 4\n        (32, 16, 33, 16, 16, 1, 0, 0),  # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        B, W, L, T_r, T_c, d, r0, c0 = case\n        result = conflict_degree(B, W, L, T_r, T_c, d, r0, c0)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2398488"}]}