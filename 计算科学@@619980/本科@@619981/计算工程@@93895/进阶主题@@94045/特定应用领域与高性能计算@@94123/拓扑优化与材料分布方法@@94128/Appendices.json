{"hands_on_practices": [{"introduction": "在运行复杂的拓扑优化算法之前，理解其核心的材料模型至关重要。本练习将深入剖析固体各向同性材料惩罚（SIMP）方法，这是最广泛使用的基于密度的方法之一。通过从基本原理出发推导其插值公式，您将亲手揭示 SIMP 如何通过惩罚“灰色”中间密度区域来生成清晰、可制造的黑白设计 [@problem_id:2606482]。", "problem": "考虑一个通过有限元法（FEM）离散化的线性弹性柔度最小化拓扑优化问题。材料分布由固定网格上的单元密度 $\\rho_e \\in [0,1]$ 表示，并采用伪材料法，通过为密度 $\\rho_e \\approx 0$ 的单元赋予一个很小但非零的刚度，以避免出现奇异刚度矩阵。在带有罚函数的固体各向同性材料（SIMP）框架中，等效单元杨氏模量 $E(\\rho_e)$ 需要满足以下从建模假设中导出的基本条件：\n1) $E(\\rho_e)$ 是关于 $\\rho_e$ 的单调递增函数。\n2) $E(0) = E_{\\min}$ 且 $E(1) = E_0$，其中 $E_0$ 是完全实体材料的杨氏模量，$E_{\\min} \\ll E_0$ 是近似空洞单元的伪刚度。\n3) 单元刚度矩阵与 $E(\\rho_e)$ 线性相关，即 $K_e(\\rho_e) = E(\\rho_e)\\,\\tilde{K}_e$，其中 $\\tilde{K}_e$ 是为单位模量计算的参考刚度矩阵。\n4) 罚函数指数 $p>1$ 通过加剧 $E(0)$ 和 $E(1)$ 之间的对比，在能量上抑制中间密度的使用。\n\n仅使用这些条件和量纲一致性，首先对于给定的指数 $p$，重构出与上述约束一致的最简单的 $E(\\rho_e)$ 光滑幂律插值函数。然后，对于 $p=3$，$E_{\\min}=10^{-3}E_0$ 和三个代表性单元密度 $\\rho_e \\in \\{0.1,\\,0.5,\\,0.9\\}$，计算归一化等效刚度 $E(\\rho_e)/E_0$。在拓扑优化的背景下，并与具有清晰材料边界的水平集方法进行对比，解释这些值如何反映对中间密度的惩罚以及 $E_{\\min}$ 在数值稳定性中的作用。\n\n以行向量 $[\\,E(0.1)/E_0,\\;E(0.5)/E_0,\\;E(0.9)/E_0\\,]$ 的形式报告你的答案，使用精确值（不要四舍五入）。由于通过 $E_0$ 归一化使这些量变为无量纲，因此不需要单位。", "solution": "在尝试求解之前，对问题陈述进行验证。\n\n已知条件如下：\n- 一个线性弹性柔度最小化问题使用有限元法（FEM）进行离散化。\n- 材料分布由单元密度 $\\rho_e \\in [0,1]$ 描述。\n- 使用了伪材料法。\n- 框架为带有罚函数的固体各向同性材料（SIMP）模型。\n- 等效单元杨氏模量 $E(\\rho_e)$ 必须满足四个条件：\n    1. $E(\\rho_e)$ 是关于 $\\rho_e$ 的单调递增函数。\n    2. 边界条件：$E(0) = E_{\\min}$ 且 $E(1) = E_0$，其中 $E_0$ 是实体材料模量，$E_{\\min} \\ll E_0$ 是伪刚度。\n    3. 单元刚度矩阵与模量线性相关：$K_e(\\rho_e) = E(\\rho_e)\\,\\tilde{K}_e$。\n    4. 使用罚函数指数 $p > 1$ 在能量上抑制中间密度。\n- 用于计算的具体值：$p=3$，$E_{\\min}=10^{-3}E_0$。\n- 用于评估的代表性密度：$\\rho_e \\in \\{0.1,\\,0.5,\\,0.9\\}$。\n\n问题陈述的验证：\n- **科学依据**：该问题牢固地建立在连续介质力学和计算结构优化的既有理论基础之上。SIMP 方法是拓扑优化中的一种经典且广泛使用的技术。所有假设和条件在该领域都是标准的。\n- **适定性**：该问题是适定的。所提供的约束足以唯一确定插值函数的最简单形式。后续的计算是该导出函数的直接应用。\n- **客观性**：该问题以精确、客观、技术性的语言陈述，没有模糊之处或主观论断。\n\n经检查，问题陈述是科学上合理、适定、客观和完整的。检查清单中未发现任何缺陷。可以开始求解过程。\n\n首先，我们必须根据给定条件重构等效杨氏模量 $E(\\rho_e)$ 的最简单光滑幂律插值函数。设该函数为一般的幂律关系。惩罚（条件4）通过项 $\\rho_e^p$ 引入。为了满足边界条件（条件2），我们寻求一个函数，将惩罚后的密度范围 $[0^p, 1^p] = [0, 1]$ 映射到刚度范围 $[E_{\\min}, E_0]$。将惩罚后的密度变量 $\\rho_e^p$ 线性映射到刚度 $E$ 是最直接的方法。\n\n让我们提出以下函数形式：\n$$\nE(\\rho_e) = A + B \\cdot \\rho_e^p\n$$\n其中 $A$ 和 $B$ 是由边界条件决定的常数。\n\n使用条件2，我们有：\n当 $\\rho_e = 0$ 时：$E(0) = A + B \\cdot (0)^p = A$。已知 $E(0) = E_{\\min}$，因此 $A = E_{\\min}$。\n当 $\\rho_e = 1$ 时：$E(1) = A + B \\cdot (1)^p = A + B$。已知 $E(1) = E_0$。\n代入 $A = E_{\\min}$，我们得到 $E_0 = E_{\\min} + B$，这意味着 $B = E_0 - E_{\\min}$。\n\n将常数 $A$ 和 $B$ 代回所提出的形式，得到插值格式：\n$$\nE(\\rho_e) = E_{\\min} + (E_0 - E_{\\min})\\rho_e^p\n$$\n这是标准的 SIMP 插值模型。我们必须根据其余条件对其进行验证。\n\n- **条件1（单调性）**：我们检查 $E(\\rho_e)$ 关于 $\\rho_e$ 的导数：\n$$\n\\frac{dE}{d\\rho_e} = \\frac{d}{d\\rho_e} \\left( E_{\\min} + (E_0 - E_{\\min})\\rho_e^p \\right) = (E_0 - E_{\\min}) p \\rho_e^{p-1}\n$$\n鉴于 $E_{\\min} \\ll E_0$，项 $(E_0 - E_{\\min})$ 是正的。罚函数指数 $p > 1$ 也是正的。对于 $\\rho_e \\in [0, 1]$，项 $\\rho_e^{p-1}$ 是非负的。因此，在整个定义域上 $\\frac{dE}{d\\rho_e} \\ge 0$，这证实了该函数是单调递增的。\n\n- **条件3（刚度矩阵的线性缩放）**：这由问题本身的设定所满足，其中单元刚度定义为 $K_e(\\rho_e) = E(\\rho_e)\\,\\tilde{K}_e$。我们导出的 $E(\\rho_e)$ 是一个乘以参考刚度矩阵的标量函数，这是相符的。\n\n- **条件4（惩罚）**：对于任何 $\\rho_e \\in (0, 1)$ 和 $p > 1$，我们有 $\\rho_e^p < \\rho_e$。导出的公式表明，模量与 $\\rho_e^p$ 成比例，而不是 $\\rho_e$。在典型的柔度最小化问题中，总材料体积是受约束的，并且与 $\\rho_e$ 线性相关。然而，刚度与 $\\rho_e^p$ 成比例。这种不匹配使得中间密度在结构上效率低下（相对于其体积“成本”而言，刚度较低），从而驱动优化算法选择接近二元（0或1）的密度。\n\n接下来，我们使用给定的参数 $p=3$ 和 $E_{\\min} = 10^{-3}E_0$ 来计算归一化等效刚度 $E(\\rho_e)/E_0$。\n归一化刚度为：\n$$\n\\frac{E(\\rho_e)}{E_0} = \\frac{E_{\\min} + (E_0 - E_{\\min})\\rho_e^p}{E_0} = \\frac{E_{\\min}}{E_0} + \\left(1 - \\frac{E_{\\min}}{E_0}\\right)\\rho_e^p\n$$\n代入给定值 $\\frac{E_{\\min}}{E_0} = 10^{-3} = 0.001$ 和 $p=3$：\n$$\n\\frac{E(\\rho_e)}{E_0} = 0.001 + (1 - 0.001)\\rho_e^3 = 0.001 + 0.999 \\rho_e^3\n$$\n现在我们对三个指定的 $\\rho_e$ 值计算此表达式：\n\n1. 对于 $\\rho_e = 0.1$：\n$$\n\\frac{E(0.1)}{E_0} = 0.001 + 0.999 \\cdot (0.1)^3 = 0.001 + 0.999 \\cdot 0.001 = 0.001 \\cdot (1 + 0.999) = 0.001999\n$$\n\n2. 对于 $\\rho_e = 0.5$：\n$$\n\\frac{E(0.5)}{E_0} = 0.001 + 0.999 \\cdot (0.5)^3 = 0.001 + 0.999 \\cdot 0.125 = 0.001 + 0.124875 = 0.125875\n$$\n\n3. 对于 $\\rho_e = 0.9$：\n$$\n\\frac{E(0.9)}{E_0} = 0.001 + 0.999 \\cdot (0.9)^3 = 0.001 + 0.999 \\cdot 0.729 = 0.001 + 0.728271 = 0.729271\n$$\n\n最后，我们提供所要求的解释。\n\n- **对中间密度的惩罚**：计算出的值展示了惩罚效应。对于密度为 $\\rho_e=0.5$ 的单元，其归一化刚度仅约为 $0.126$。这个值显著低于密度本身。如果没有惩罚（即 $p=1$），归一化刚度将约为 $\\frac{E(0.5)}{E_0} \\approx 0.5$。指数 $p=3$ 将此中间密度单元的刚度贡献降低了约 $0.5 / 0.126 \\approx 4$ 倍。因此，一个旨在在给定材料体积下最大化刚度的优化算法会发现使用此密度的材料效率极低，并会倾向于将密度推向 0 或 1，从而产生更黑白分明、易于制造的设计。\n\n- **$E_{\\min}$ 的作用**：最小模量 $E_{\\min}$ 是一种数值技巧，而非物理实体。在有限元公式中，必须对全局刚度矩阵 $K$ 求逆以求解线性方程组 $KU=F$。如果允许单元具有零刚度（$E=0$），大片“空洞”单元区域可能导致全局矩阵 $K$ 奇异（不可逆），从而导致模拟失败。通过为空洞单元（$\\rho_e \\approx 0$）赋予一个小的非零刚度 $E_{\\min}$，我们保证 $K$ 在整个优化过程中保持正定和可逆。$\\rho_e=0.1$ 的结果显示了这种效果：刚度 $0.001999 E_0$ 非常小，主要由 $E_{\\min}$ 项（贡献了 $0.001 E_0$）主导，但关键是，它不为零。\n\n- **与水平集方法的对比**：SIMP 是一种基于密度的方法，其设计变量是在固定网格上定义的材料属性场 $\\rho_e(x)$。该场可以包含中间密度区域（“灰色”材料），而惩罚格式对于抑制它们至关重要。相比之下，水平集方法是基于边界的。它们通过一个更高维函数 $\\phi(x)$ 的零等值线来隐式地表示结构。区域被划分为具有清晰、明确边界的独立实体区（$\\phi(x)<0$）和空洞区（$\\phi(x)>0$）。在材料模型本身中没有中间密度。因此，“惩罚”中间密度的概念与水平集方法无关。水平集方法中的优化是通过演化边界形状来最小化柔度，而 SIMP 则是演化材料分布。因此，水平集方法能内在地产生清晰、可直接用于分析的设计，但在引发拓扑变化（例如，创建新孔洞）方面面临更大挑战，而这正是 SIMP 能自然处理的任务。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.001999 & 0.125875 & 0.729271\n\\end{pmatrix}\n}\n$$", "id": "2606482"}, {"introduction": "理论通过实践才能真正焕发生机。本练习将指导您从零开始编写一个简单的桁架结构优化器，这是计算工程领域的一项基本技能。更重要的是，通过比较最小化柔度（最大化刚度）和最小化应力这两个不同的设计目标，您将探索一个核心的工程设计原则：最终的“最优”结构形态取决于我们选择的性能衡量标准 [@problem_id:2447108]。", "problem": "构建并求解一个最小化的、自洽的离散拓扑优化问题，该问题旨在使用一个小型桁架基结构，比较最小化结构柔度的材料布局与在 $p \\to \\infty$ 极限情况下最小化 von Mises 应力 $p$-范数 $\\left( \\int \\sigma_{vM}^p \\, dV \\right)^{1/p}$ 的材料布局。全程使用无量纲单位；不需要物理单位。\n\n考虑一个平面桁架，其 3 个节点坐标分别为 $(0,0)$、$(L,0)$ 和 $(L,H)$，最多由 3 根直杆连接，杆件的索引和连接关系按 $[(1\\text{-}2),(2\\text{-}3),(1\\text{-}3)]$ 排序。设位于 $(0,0)$ 的节点 1 在两个方向上均被固定，位于 $(L,0)$ 的节点 2 仅在垂直方向上被固定，位于 $(L,H)$ 的节点 3 为自由节点。在节点 3 上施加一个大小为 $F$ 的垂直向下点荷载。基结构由连接指定节点对的三根候选杆件组成。\n\n使用线弹性桁架模型，弹性模量为 $E>0$。对于每根杆件 $e$，定义其长度 $L_e>0$ 和沿其轴线的方向余弦 $(c_e,s_e)$。用 $u \\in \\mathbb{R}^{2n}$ 表示全局位移向量，其中节点数 $n=3$。全局平衡方程为 $K(\\rho)\\,u=f$，其中 $K(\\rho)$ 是由单元刚度贡献组装而成的总刚度矩阵\n$$\nK_e(\\rho_e) \\;=\\; \\frac{E A_e(\\rho_e)}{L_e} \n\\begin{bmatrix}\nc_e^2 & c_e s_e & -c_e^2 & -c_e s_e \\\\\nc_e s_e & s_e^2 & -c_e s_e & -s_e^2 \\\\\n- c_e^2 & -c_e s_e & c_e^2 & c_e s_e \\\\\n- c_e s_e & -s_e^2 & c_e s_e & s_e^2\n\\end{bmatrix},\n$$\n$A_e(\\rho_e)$ 是杆件 $e$ 的横截面积，通过固体各向同性材料惩罚 (SIMP) 映射成为设计密度 $\\rho_e \\in [0,1]$ 的函数\n$$\nA_e(\\rho_e) \\;=\\; A_{\\min} \\;+\\; A_0\\,\\rho_e^{q},\n$$\n其中 $A_{\\min}>0$，$A_0>0$，惩罚指数 $q \\ge 1$。柔度为\n$$\nJ_C(\\rho) \\;=\\; f^\\top u(\\rho),\n$$\n每根桁架杆件中的 von Mises 应力等于其轴向应力的绝对值 $\\sigma_e(\\rho)= E\\,\\varepsilon_e(\\rho)$，其中轴向应变为\n$$\n\\varepsilon_e(\\rho) \\;=\\; \\frac{ \\big( u_j - u_i \\big) \\cdot \\begin{bmatrix} c_e \\\\ s_e \\end{bmatrix} }{L_e},\n$$\n其中 $i$ 和 $j$ 是单元 $e$ 的节点索引。应力的 $p$-范数目标函数为\n$$\nJ_{S,p}(\\rho) \\;=\\; \\left( \\sum_{e=1}^{3} \\int_{V_e} \\sigma_e(\\rho)^p \\, dV \\right)^{1/p} \n\\;=\\; \\left( \\sum_{e=1}^{3} \\sigma_e(\\rho)^p \\, A_e(\\rho_e)\\,L_e \\right)^{1/p}.\n$$\n当 $p \\to \\infty$ 时，$J_{S,p}$ 收敛于 $|\\sigma|$ 的本性上确界，即\n$$\nJ_{S,\\infty}(\\rho) \\;=\\; \\max_{e \\in \\{1,2,3\\}} |\\sigma_e(\\rho)|.\n$$\n\n施加一个以惩罚后密度表示的全局体积（材料）约束：\n$$\n\\sum_{e=1}^{3} \\rho_e^{q} \\;\\le\\; V_f \\cdot 3,\n$$\n其中 $V_f \\in (0,1]$ 是目标体积分数。对所有 $e$，使用离散设计集 $\\rho_e \\in \\{0, 0.5, 1\\}$，并通过在 0.5 处设置阈值来解释最终拓扑：当且仅当 $\\rho_e \\ge 0.5$ 时，杆件存在。\n\n你的任务是编写一个完整的、可运行的程序，该程序针对下述每个测试用例，对满足体积约束的 $3^3$ 种设计求解两个独立的离散优化问题：\n- 一个最小化柔度 $J_C$ 的问题，\n- 一个最小化 $J_{S,\\infty}$ 的问题，\n然后比较所得的拓扑。在每次最小化过程中，若出现平局，则优先选择 $\\sum_e \\rho_e$ 较小的设计（更稀疏的拓扑），然后再按 $(\\rho_1,\\rho_2,\\rho_3)$ 的字典序排序。程序必须组装桁架刚度矩阵，按规定施加边界条件，求解 $K(\\rho)\\,u=f$，计算应力，并精确地评估所定义的目标函数。\n\n使用以下固定参数（无量纲）：\n- $E = 1.0$, $F = 1.0$, $A_{\\min} = 0.05$, $A_0 = 1.0$, $q = 3$。\n- 离散密度水平 $\\{0,0.5,1\\}$。\n- 杆件顺序固定为 $[(1\\text{-}2),(2\\text{-}3),(1\\text{-}3)]$。\n\n提供以下包含三个用例的测试套件，以检验不同的行为：\n- 测试 1：$(L,H,V_f) = (1.0, 1.0, 2/3)$。\n- 测试 2：$(L,H,V_f) = (1.0, 1.0, 1/3)$。\n- 测试 3：$(L,H,V_f) = (1.0, 2.0, 2/3)$。\n\n对于每个测试用例，要求的结果是一个包含三个条目的列表：\n- 柔度最小化拓扑，表示为一个按固定杆件顺序排列的、长度为 3 的整数（0 或 1）列表，\n- $p \\to \\infty$ 应力最小化拓扑，表示为按相同顺序排列的、长度为 3 的整数（0 或 1）列表，\n- 这两个拓扑之间的汉明距离（一个在 $\\{0,1,2,3\\}$ 之间的整数）。\n\n最终输出格式：你的程序应生成单行输出，其中包含三个测试用例的结果，该结果是一个用方括号括起来的、以逗号分隔的列表，其中每个测试用例的结果本身就是如上所述的一个列表。例如，一个语法上有效的输出形式为\n$[[[1,0,1],[1,1,0],1],[[\\dots],[\\dots],\\dots],[[\\dots],[\\dots],\\dots]]$。", "solution": "问题陈述是有效的。它提出了一个定义明确、内容自洽且具有科学依据的计算结构优化练习。所有必要的参数、控制方程、约束条件和目标函数都得到了清晰而精确的说明，允许通过对离散设计空间的穷举评估得到唯一的解。这个问题是一个经典的例子，用于比较拓扑优化中基于刚度的设计准则和基于应力的设计准则，这是计算工程学的一个基础课题。\n\n我们开始求解。任务是通过最小化两个不同的目标函数——结构柔度（$J_C$）和最大 von Mises 应力（$J_{S,\\infty}$），来确定一个三杆平面桁架结构的最优材料布局。该优化是在一个离散的设计变量集合上进行的，并受到材料体积约束。\n\n首先，我们为该问题建立分析框架。\n\n**1. 系统几何与运动学**\n\n结构由三个坐标分别为 $N_1=(0,0)$、$N_2=(L,0)$ 和 $N_3=(L,H)$ 的节点组成。三根潜在的杆件连接这些节点：\n- 杆 1：连接 $N_1$ 和 $N_2$。其长度为 $L_1 = L$。方向向量为 $(L,0)$，因此方向余弦为 $(c_1, s_1) = (1, 0)$。\n- 杆 2：连接 $N_2$ 和 $N_3$。其长度为 $L_2 = H$。方向向量为 $(0,H)$，因此方向余弦为 $(c_2, s_2) = (0, 1)$。\n- 杆 3：连接 $N_1$ 和 $N_3$。其长度为 $L_3 = \\sqrt{L^2 + H^2}$。方向向量为 $(L,H)$，因此方向余弦为 $(c_3, s_3) = (L/L_3, H/L_3)$。\n\n**2. 有限元公式**\n\n系统有 $n=3$ 个节点，每个节点有两个平动自由度（DOF）。总共有 6 个自由度，由全局位移向量 $u = [u_{1x}, u_{1y}, u_{2x}, u_{2y}, u_{3x}, u_{3y}]^\\top$ 表示。控制平衡方程为 $K(\\rho)u = f$。\n\n设计变量是每根杆件 $e \\in \\{1,2,3\\}$ 的密度 $\\rho_e$，其中 $\\rho_e$ 属于离散集合 $\\{0, 0.5, 1\\}$。每根杆件的横截面积由固体各向同性材料惩罚 (SIMP) 法则确定：\n$$\nA_e(\\rho_e) = A_{\\min} + A_0 \\rho_e^q\n$$\n其中 $A_{\\min} > 0$ 是为防止刚度矩阵奇异而设置的最小面积，$A_0$ 是特征面积，$q$ 是惩罚指数。\n\n全局刚度矩阵 $K(\\rho)$ 是一个 $6 \\times 6$ 的矩阵，由单元刚度矩阵 $K_e(\\rho_e)$ 组装而成：\n$$\nK_e(\\rho_e) = \\frac{E A_e(\\rho_e)}{L_e} \n\\begin{bmatrix}\nc_e^2 & c_e s_e & -c_e^2 & -c_e s_e \\\\\nc_e s_e & s_e^2 & -c_e s_e & -s_e^2 \\\\\n-c_e^2 & -c_e s_e & c_e^2 & c_e s_e \\\\\n-c_e s_e & -s_e^2 & c_e s_e & s_e^2\n\\end{bmatrix}\n$$\n组装过程将每个单元的局部自由度映射到全局自由度索引。\n\n边界条件为：\n- 节点1：固定。$u_{1x} = 0$，$u_{1y} = 0$。（自由度 1, 2）\n- 节点2：滚子支座。$u_{2y} = 0$。（自由度 4）\n- 节点3：自由。\n\n求解方程组以得到自由自由度：$u_{2x}$ (DOF 3)、$u_{3x}$ (DOF 5) 和 $u_{3y}$ (DOF 6)。设自由位移向量为 $u_{\\text{free}} = [u_{2x}, u_{3x}, u_{3y}]^\\top$。我们根据自由和指定自由度对全局矩阵 $K$ 和力向量 $f$ 进行分区。简化后的线性系统为 $K_{\\text{red}} u_{\\text{free}} = f_{\\text{red}}$。\n\n外部荷载是在节点3沿负y方向施加的大小为 $F$ 的点力。全局力向量为 $f = [0, 0, 0, 0, 0, -F]^\\top$。因此，简化后的力向量为 $f_{\\text{red}} = [0, 0, -F]^\\top$。\n\n求解出 $u_{\\text{free}}$ 后，重构完整的位移向量 $u$。\n\n**3. 目标函数与约束**\n\n在位移已知的情况下，我们为每个设计 $\\rho = (\\rho_1, \\rho_2, \\rho_3)$ 评估两个目标：\n\n- **柔度**: $J_C(\\rho) = f^\\top u(\\rho) = (-F) \\cdot u_{3y}(\\rho)$。最小化柔度等效于最大化全局刚度。\n- **最大应力**: $J_{S,\\infty}(\\rho) = \\max_{e} |\\sigma_e(\\rho)|$。每根杆件中的应力为 $\\sigma_e(\\rho) = E \\varepsilon_e(\\rho)$，其中应变 $\\varepsilon_e$ 根据节点位移计算：\n$$\n\\varepsilon_e(\\rho) = \\frac{1}{L_e} \\left( (u_{jx}-u_{ix})c_e + (u_{jy}-u_{iy})s_e \\right)\n$$\n对于连接节点 $i$ 和 $j$ 的杆件。\n\n优化受体积约束：\n$$\n\\sum_{e=1}^{3} \\rho_e^q \\le 3 V_f\n$$\n其中 $V_f$ 是目标体积分数，$q=3$ 是惩罚幂。\n\n**4. 枚举求解**\n\n设计空间很小，包含 $3^3 = 27$ 种可能的设计。因此，我们可以通过枚举所有设计，根据体积约束进行筛选，并为每个有效设计评估目标函数，从而找到精确的最优解。\n\n算法如下：\n1. 对于由 $(L, H, V_f)$ 定义的每个测试用例：\n2. 生成所有 $27$ 种可能的设计向量 $\\rho = (\\rho_1, \\rho_2, \\rho_3)$ 的集合，其中 $\\rho_e \\in \\{0, 0.5, 1\\}$。\n3. 对于每个设计 $\\rho$：\n    a. 检查其是否满足体积约束 $\\sum_{e=1}^{3} \\rho_e^3 \\le 3 V_f$。\n    b. 如果有效，则进行有限元分析：\n        i. 组装 $3 \\times 3$ 的简化刚度矩阵 $K_{\\text{red}}$。\n        ii. 求解 $K_{\\text{red}} u_{\\text{free}} = f_{\\text{red}}$ 以得到 $u_{\\text{free}}$。\n        iii. 计算所有三根杆件的柔度 $J_C$ 和应力 $\\sigma_e$。\n        iv. 确定最大应力 $J_{S,\\infty}$。\n    c. 存储目标函数值和设计向量。\n4. 从有效设计集合中，为每个目标函数找到最优设计。这通过基于一个元组键对所有有效设计进行排序来完成。对于柔度最小化，键为 $(J_C, \\sum_e \\rho_e, \\rho_1, \\rho_2, \\rho_3)$。对于应力最小化，键为 $(J_{S,\\infty}, \\sum_e \\rho_e, \\rho_1, \\rho_2, \\rho_3)$。排序后列表中的第一个元素即为最优解，因为它满足了主要目标的最小化以及所有后续的平局打破规则。\n5. 将最优密度向量 $\\rho^*$ 转换为二元拓扑向量，其中如果 $\\rho_e^* \\ge 0.5$，则单元存在。\n6. 计算两个所得拓扑之间的汉明距离。\n7. 按照最终输出的规定格式化结果。\n\n该过程保证能根据问题定义找到真正的最优解。下面的 Python 代码实现了这一逻辑。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a discrete topology optimization problem for a 3-bar truss.\n    Compares topologies from minimizing compliance vs. minimizing max stress.\n    \"\"\"\n    \n    # Fixed parameters\n    E = 1.0\n    F = 1.0\n    A_min = 0.05\n    A0 = 1.0\n    q = 3.0\n    \n    # Discrete design space for rho_e\n    rho_levels = [0.0, 0.5, 1.0]\n\n    # Test cases\n    test_cases = [\n        (1.0, 1.0, 2.0 / 3.0),  # Test 1\n        (1.0, 1.0, 1.0 / 3.0),  # Test 2\n        (1.0, 2.0, 2.0 / 3.0),  # Test 3\n    ]\n\n    # DOF mapping:\n    # Node 1 (0,0): DOFs 0(x), 1(y) - Prescribed (fixed)\n    # Node 2 (L,0): DOFs 2(x), 3(y) - DOF 3 Prescribed (roller)\n    # Node 3 (L,H): DOFs 4(x), 5(y) - Free\n    free_dofs = [2, 4, 5]\n    dof_map = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5} # Global DOFs\n    \n    # Element connectivity to global DOFs\n    elem_dofs = {\n        0: [0, 1, 2, 3], # Bar 1 (1-2)\n        1: [2, 3, 4, 5], # Bar 2 (2-3)\n        2: [0, 1, 4, 5]  # Bar 3 (1-3)\n    }\n\n    all_results = []\n\n    for L, H, Vf in test_cases:\n        # Geometric properties\n        lengths = np.array([L, H, np.sqrt(L**2 + H**2)])\n        cosines = np.array([L / lengths[0], 0, L / lengths[2]])\n        sines = np.array([0, H / lengths[1], H / lengths[2]])\n        \n        # Volume constraint\n        vol_limit = 3.0 * Vf\n        \n        # Generate all 3^3 = 27 designs\n        designs = []\n        for r1 in rho_levels:\n            for r2 in rho_levels:\n                for r3 in rho_levels:\n                    designs.append(np.array([r1, r2, r3]))\n\n        valid_results = []\n\n        for rho in designs:\n            # Check volume constraint\n            if np.sum(rho**q) > vol_limit:\n                continue\n\n            # Calculate element areas\n            areas = A_min + A0 * rho**q\n\n            # Assemble reduced stiffness matrix K_red (3x3 for free DOFs)\n            K_global = np.zeros((6, 6))\n            for e in range(3):\n                Ae, Le, ce, se = areas[e], lengths[e], cosines[e], sines[e]\n                k_const = E * Ae / Le\n                k_mat_local = k_const * np.array([\n                    [ce**2, ce*se, -ce**2, -ce*se],\n                    [ce*se, se**2, -ce*se, -se**2],\n                    [-ce**2, -ce*se, ce**2, ce*se],\n                    [-ce*se, -se**2, ce*se, se**2]\n                ])\n                \n                # Assemble into global matrix\n                global_indices = np.ix_(elem_dofs[e], elem_dofs[e])\n                K_global[global_indices] += k_mat_local\n            \n            K_red = K_global[np.ix_(free_dofs, free_dofs)]\n            \n            # Solve for displacements\n            f_red = np.array([0.0, 0.0, -F])\n            try:\n                u_free = np.linalg.solve(K_red, f_red)\n            except np.linalg.LinAlgError:\n                # Unstable structure, huge compliance/stress, will not be optimal\n                continue\n\n            # Reconstruct full displacement vector\n            u_full = np.zeros(6)\n            u_full[free_dofs] = u_free\n            \n            # --- Calculate objectives ---\n            # 1. Compliance\n            compliance = -F * u_full[5] # f^T u\n\n            # 2. Stresses\n            stresses = np.zeros(3)\n            # Strain e = (1/L) * [-c, -s, c, s] * u_elem\n            # Bar 1 (1-2)\n            u_elem1 = u_full[[0,1,2,3]]\n            strains_1 = (1/lengths[0]) * (-cosines[0]*u_elem1[0] - sines[0]*u_elem1[1] + cosines[0]*u_elem1[2] + sines[0]*u_elem1[3])\n            stresses[0] = E * strains_1\n            # Bar 2 (2-3)\n            u_elem2 = u_full[[2,3,4,5]]\n            strains_2 = (1/lengths[1]) * (-cosines[1]*u_elem2[0] - sines[1]*u_elem2[1] + cosines[1]*u_elem2[2] + sines[1]*u_elem2[3])\n            stresses[1] = E * strains_2\n            # Bar 3 (1-3)\n            u_elem3 = u_full[[0,1,4,5]]\n            strains_3 = (1/lengths[2]) * (-cosines[2]*u_elem3[0] - sines[2]*u_elem3[1] + cosines[2]*u_elem3[2] + sines[2]*u_elem3[3])\n            stresses[2] = E * strains_3\n            \n            max_stress = np.max(np.abs(stresses))\n\n            valid_results.append({\n                \"rho\": tuple(rho),\n                \"compliance\": compliance,\n                \"max_stress\": max_stress,\n                \"sum_rho\": np.sum(rho)\n            })\n\n        # --- Find optimal designs ---\n        # Sort for compliance minimization with tie-breaking\n        sorted_C = sorted(valid_results, key=lambda x: (x[\"compliance\"], x[\"sum_rho\"], x[\"rho\"]))\n        opt_rho_C = np.array(sorted_C[0][\"rho\"])\n        \n        # Sort for stress minimization with tie-breaking\n        sorted_S = sorted(valid_results, key=lambda x: (x[\"max_stress\"], x[\"sum_rho\"], x[\"rho\"]))\n        opt_rho_S = np.array(sorted_S[0][\"rho\"])\n\n        # Convert optimal rho to topology (0 or 1)\n        topo_C = (opt_rho_C >= 0.5).astype(int).tolist()\n        topo_S = (opt_rho_S >= 0.5).astype(int).tolist()\n\n        # Calculate Hamming distance\n        hamming_dist = sum(x != y for x, y in zip(topo_C, topo_S))\n\n        # Format result string for this test case\n        result_str = f\"[[{','.join(map(str, topo_C))}],[{','.join(map(str, topo_S))}],{hamming_dist}]\"\n        all_results.append(result_str)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2447108"}, {"introduction": "材料分布方法不仅限于决定在何处放置或移除材料。本练习将带您探索一个更高级的场景：混合两种不同材料，其中一种是其属性随空间位置连续变化的功能梯度材料（FGM）。通过解决这个一维杆件问题，您将有机会应用解析优化技术（如KKT条件）来寻找材料的连续最优分布，从而领略该领域的广度与数学上的精妙之处 [@problem_id:2447101]。", "problem": "考虑一根长度为 $L$、横截面积为常数 $A$ 的一维棱柱杆，它被离散为 $N$ 个长度相等的轴向单元，单元长度为 $h=L/N$，中心点位于 $x_i=(i+0.5)h$，$i=0,1,\\dots,N-1$。其左端 $x=0$ 固定，在右端 $x=L$ 施加一个集中轴向力 $F$（单位：牛顿）。该杆可由两种材料制成：(1) 一种均匀的基底材料，其杨氏模量为 $E_{\\mathrm{b}}$（单位：帕斯卡）；(2) 一种功能梯度材料 (FGM)，其局部杨氏模量随位置连续变化，遵循以下公式：\n$$\nE_{\\mathrm{fgm}}(x)=E_0\\left(1+\\alpha \\,\\hat{x}\\right), \\quad \\hat{x}=\\frac{x}{L},\n$$\n其中 $E_0>0$（单位：帕斯卡），$\\alpha$ 为实数参数，且对于所有 $x\\in[0,L]$ 均满足 $E_{\\mathrm{fgm}}(x)>0$。\n\n在每个单元 $i$上，定义一个设计变量 $\\rho_i\\in[0,1]$，表示该单元中使用的 FGM 的体积分数，余下的 $1-\\rho_i$ 为基底材料。单元的有效杨氏模量是线性混合：\n$$\nE_i(\\rho_i)=E_{\\mathrm{b}}+\\rho_i\\left(E_{\\mathrm{fgm}}(x_i)-E_{\\mathrm{b}}\\right).\n$$\n设可用 FGM 的预算受以下约束：\n$$\n\\frac{1}{N}\\sum_{i=0}^{N-1}\\rho_i\\le \\bar{v},\n$$\n其中 $\\bar{v}\\in[0,1]$ 是允许的最大平均 FGM 体积分数。\n\n在轴向载荷作用下，这些单元如同串联的线性弹簧，单元刚度为：\n$$\nk_i=\\frac{E_i(\\rho_i)\\,A}{h}.\n$$\n杆的等效轴向刚度为：\n$$\nK_{\\mathrm{eq}}(\\boldsymbol{\\rho})=\\left(\\sum_{i=0}^{N-1}\\frac{1}{k_i}\\right)^{-1}=\\left(\\sum_{i=0}^{N-1}\\frac{h}{E_i(\\rho_i)\\,A}\\right)^{-1},\n$$\n柔度（外力所做的功），等于载荷乘以端部位移，其表达式为：\n$$\nJ(\\boldsymbol{\\rho})=\\frac{F^2}{K_{\\mathrm{eq}}(\\boldsymbol{\\rho})}=F^2\\sum_{i=0}^{N-1}\\frac{h}{E_i(\\rho_i)\\,A}.\n$$\n\n任务：对于下面指定的每一组参数，确定能最小化 $J(\\boldsymbol{\\rho})$ 的设计向量 $\\boldsymbol{\\rho}=\\{\\rho_i\\}_{i=0}^{N-1}$，其约束条件为：对于所有 $i$，$0\\le \\rho_i\\le 1$ 且 $\\frac{1}{N}\\sum_{i=0}^{N-1}\\rho_i\\le \\bar{v}$。对于每种情况，仅报告最小柔度值 $J^\\star$（单位：牛顿-米）。\n\n所有输入均采用国际单位制。你的程序必须计算每种情况下的最优柔度 $J^\\star$，并在一行中输出结果，结果为方括号内以逗号分隔的列表，按测试用例的顺序排列，每个柔度值以牛顿-米为单位，并四舍五入到六位小数。\n\n测试集（每个用例是一个元组 $(N,L,A,E_{\\mathrm{b}},E_0,\\alpha,\\bar{v},F)$）：\n1. $(10,\\,1.0,\\,1.0\\times 10^{-3},\\,1.0\\times 10^{11},\\,2.0\\times 10^{11},\\,0.5,\\,0.3,\\,1000)$\n2. $(10,\\,1.0,\\,1.0\\times 10^{-3},\\,1.0\\times 10^{11},\\,2.0\\times 10^{11},\\,0.5,\\,0.0,\\,1000)$\n3. $(10,\\,1.0,\\,1.0\\times 10^{-3},\\,1.0\\times 10^{11},\\,2.0\\times 10^{11},\\,0.5,\\,1.0,\\,1000)$\n4. $(10,\\,1.0,\\,1.0\\times 10^{-3},\\,1.0\\times 10^{11},\\,5.0\\times 10^{10},\\,3.0,\\,0.5,\\,1000)$\n\n最终输出格式：你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[j_1,j_2,j_3,j_4]$，其中每个 $j_k$ 是对应测试用例的最小柔度，以牛顿-米为单位，并四舍五入到六位小数（输出中不包含单位或其他附加文本）。", "solution": "我们从轴向弹性和串联弹簧等效性出发。对于一个被细分为 $N$ 个长度为 $h=L/N$、横截面积为 $A$ 的相等轴向单元的一维杆，若单元杨氏模量为 $E_i(\\rho_i)$，则单元轴向刚度为 $k_i=E_i(\\rho_i)A/h$。串联弹簧的刚度以倒数相加，因此等效轴向刚度为\n$$\nK_{\\mathrm{eq}}(\\boldsymbol{\\rho})=\\left(\\sum_{i=0}^{N-1}\\frac{1}{k_i}\\right)^{-1}=\\left(\\sum_{i=0}^{N-1}\\frac{h}{E_i(\\rho_i)\\,A}\\right)^{-1}.\n$$\n对于在 $x=L$ 处施加端部载荷 $F$ 且 $x=0$ 处固定的情况，端部位移为 $u(L)=F/K_{\\mathrm{eq}}(\\boldsymbol{\\rho})$，柔度等于外部载荷所做的功，\n$$\nJ(\\boldsymbol{\\rho})=F\\,u(L)=\\frac{F^2}{K_{\\mathrm{eq}}(\\boldsymbol{\\rho})}=F^2\\sum_{i=0}^{N-1}\\frac{h}{E_i(\\rho_i)\\,A}.\n$$\n单元模量是基底材料和功能梯度材料 (FGM) 之间的线性混合，\n$$\nE_i(\\rho_i)=E_{\\mathrm{b}}+\\rho_i\\left(E_{\\mathrm{fgm}}(x_i)-E_{\\mathrm{b}}\\right), \\quad \\rho_i\\in[0,1],\n$$\n其中 $E_{\\mathrm{fgm}}(x)=E_0(1+\\alpha \\hat{x}), \\hat{x}=x/L$。定义单元特定的模量对比度\n$$\nb_i:=E_{\\mathrm{fgm}}(x_i)-E_{\\mathrm{b}}.\n$$\n那么 $E_i(\\rho_i)=E_{\\mathrm{b}}+b_i\\rho_i$，柔度可以写成\n$$\nJ(\\boldsymbol{\\rho})=F^2\\sum_{i=0}^{N-1}\\frac{h}{A}\\frac{1}{E_{\\mathrm{b}}+b_i\\rho_i}.\n$$\n优化问题为\n$$\n\\min_{\\boldsymbol{\\rho}} \\; F^2\\sum_{i=0}^{N-1}\\frac{h}{A}\\frac{1}{E_{\\mathrm{b}}+b_i\\rho_i}\n\\quad \\text{约束条件为} \\quad 0\\le \\rho_i\\le 1, \\; \\forall i, \\quad \\frac{1}{N}\\sum_{i=0}^{N-1}\\rho_i\\le \\bar{v}.\n$$\n该目标函数是关于 $\\rho_i$ 的可分离凸函数的和，因为对于任何 $b_i$，映射 $\\rho\\mapsto 1/(E_{\\mathrm{b}}+b_i\\rho)$ 在 $[0,1]$ 上都是凸的，并且可行集是凸的。因此，存在唯一的全局最小解。\n\n引入拉格朗日函数，其中预算约束的乘子为 $\\lambda\\ge 0$，边界约束的乘子为 $\\mu_i,\\nu_i\\ge 0$：\n$$\n\\mathcal{L}(\\boldsymbol{\\rho},\\lambda,\\boldsymbol{\\mu},\\boldsymbol{\\nu})=\nF^2\\sum_{i=0}^{N-1}\\frac{h}{A}\\frac{1}{E_{\\mathrm{b}}+b_i\\rho_i}\n+\\lambda\\left(\\sum_{i=0}^{N-1}\\rho_i-N\\bar{v}\\right)\n-\\sum_{i=0}^{N-1}\\mu_i\\rho_i+\\sum_{i=0}^{N-1}\\nu_i(\\rho_i-1).\n$$\nKarush–Kuhn–Tucker (KKT) 条件刻画了最优解的特征。对于任何 $b_i\\le 0$ 的单元，柔度表达式中的求和项随 $\\rho_i$ 增大而增大，因此最优选择是 $\\rho_i^\\star=0$；在此处分配 FGM 会降低刚度。对于 $b_i>0$，考虑一个内点最优解 $0<\\rho_i^\\star<1$；关于 $\\rho_i$ 的平稳性条件得出\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial \\rho_i} = -F^2\\frac{h}{A}\\frac{b_i}{\\left(E_{\\mathrm{b}}+b_i\\rho_i\\right)^2}+\\lambda=0,\n$$\n这意味着\n$$\nE_{\\mathrm{b}}+b_i\\rho_i=\\sqrt{\\frac{F^2 h\\, b_i}{A\\,\\lambda}}.\n$$\n因此，对于 $b_i>0$，无约束的驻点为\n$$\n\\rho_i(\\lambda)=\\frac{\\sqrt{\\frac{F^2 h\\, b_i}{A\\,\\lambda}}-E_{\\mathrm{b}}}{b_i}.\n$$\n施加边界条件给出截断解\n$$\n\\rho_i^\\star(\\lambda)=\n\\begin{cases}\n0, & b_i\\le 0,\\\\[4pt]\n\\min\\left\\{1,\\max\\left\\{0,\\;\\dfrac{\\sqrt{\\frac{F^2 h\\, b_i}{A\\,\\lambda}}-E_{\\mathrm{b}}}{b_i}\\right\\}\\right\\}, & b_i>0.\n\\end{cases}\n$$\n互补松弛条件要求 $\\lambda\\left(\\sum_{i=0}^{N-1}\\rho_i^\\star(\\lambda)-N\\bar{v}\\right)=0$。随之有两种情况：\n1. 如果预算约束不激活（例如，当总预算 $N\\bar{v}$ 大于或等于 $b_i>0$ 的单元数量时），则 $\\lambda=0$，最优解为：对于所有 $b_i>0$ 的单元，设置 $\\rho_i^\\star=1$；对于 $b_i\\le 0$ 的单元，设置 $\\rho_i^\\star=0$。\n2. 如果预算约束是激活的（紧约束），则存在唯一的 $\\lambda>0$ 使得 $\\sum_{i=0}^{N-1}\\rho_i^\\star(\\lambda)=N\\bar{v}$。因为映射 $\\lambda\\mapsto \\sum_i \\rho_i^\\star(\\lambda)$ 在 $\\lambda>0$ 上是严格单调递减的，可以通过一维求根的二分法在任意所需精度内确定 $\\lambda$。\n\n一旦确定了 $\\boldsymbol{\\rho}^\\star$，就可以通过下式计算最优柔度：\n$$\nJ^\\star=F^2\\sum_{i=0}^{N-1}\\frac{h}{A}\\frac{1}{E_{\\mathrm{b}}+b_i\\rho_i^\\star}.\n$$\n\n算法实现：\n- 计算 $h=L/N$ 和 $x_i=(i+0.5)h$，$i=0,\\dots,N-1$。\n- 计算 $E_{\\mathrm{fgm}}(x_i)=E_0(1+\\alpha x_i/L)$ 和 $b_i=E_{\\mathrm{fgm}}(x_i)-E_{\\mathrm{b}}$。\n- 如果 $\\bar{v}=0$ 或者对所有 $i$ 都有 $b_i\\le 0$，则设置 $\\rho_i^\\star=0$。\n- 否则，如果 $N\\bar{v}\\ge \\#\\{i: b_i>0\\}$，则在 $b_i>0$ 的地方设置 $\\rho_i^\\star=1$，其他地方为 0。\n- 否则，通过二分法确定 $\\lambda>0$ 使得 $\\sum_i \\rho_i^\\star(\\lambda)=N\\bar{v}$，其中每个 $\\rho_i^\\star(\\lambda)$ 使用上述闭式表达式，然后计算 $J^\\star$。\n\n此过程仅使用 Hooke’s law、串联弹簧组合、模量的线性混合法则以及带拉格朗日乘子的凸优化。它为每组参数产生唯一的全局最优柔度。最后一步是将每个 $J^\\star$ 四舍五入到六位小数（单位：牛顿-米），并按测试集顺序以单个方括号括住的、逗号分隔的列表形式打印。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef optimal_compliance(N, L, A, E_b, E0, alpha, vbar, F):\n    \"\"\"\n    Compute the minimum compliance for a 1D bar with two-material mixture,\n    where one material is functionally graded: E_fgm(x) = E0 * (1 + alpha * x/L).\n    Design variables rho_i in [0,1] interpolate E_i = E_b + rho_i * (E_fgm_i - E_b),\n    with average constraint (1/N) sum rho_i = vbar.\n    \"\"\"\n    # Discretization\n    h = L / N\n    i = np.arange(N)\n    x_i = (i + 0.5) * h\n    xhat = x_i / L\n\n    # Material properties per element\n    E_fgm = E0 * (1.0 + alpha * xhat)\n    b = E_fgm - E_b  # contrast per element\n\n    # Budget\n    R = vbar * N\n\n    # Helper to compute rho(lambda) for b_i > 0 using stationarity and clipping\n    pos_mask = b > 0.0\n    n_pos = int(np.count_nonzero(pos_mask))\n\n    # Initialize rho\n    rho = np.zeros(N, dtype=float)\n\n    if R = 0.0 or n_pos == 0:\n        # No budget or no beneficial elements: all zeros\n        pass\n    elif R >= n_pos:\n        # Budget not binding: use FGM fully where beneficial\n        rho[pos_mask] = 1.0\n    else:\n        # Budget binding: find lambda > 0 s.t. sum rho = R using bisection\n        bp = b[pos_mask]\n        # Define function to compute sum rho for a given lambda\n        # rho_i(lambda) = ((sqrt(F^2*h*b_i/(A*lambda)) - E_b)/b_i) clipped to [0,1]\n        def sum_rho(lmbd):\n            # Avoid division by zero or negative values\n            # Compute sqrt_term for positive b only\n            sqrt_term = np.sqrt((F * F) * h * bp / (A * lmbd))\n            vals = (sqrt_term - E_b) / bp\n            # Clip to [0,1]\n            vals = np.clip(vals, 0.0, 1.0)\n            return float(np.sum(vals))\n\n        # Bisection bounds for lambda\n        # As lambda -> 0+, rho -> 1 for all positive b; sum -> n_pos\n        # As lambda increases large enough, rho -> 0; sum -> 0\n        # Construct an upper bound ensuring all rhos are ~0:\n        # Condition for rho_i = 0: sqrt(F^2*h*b_i/(A*lambda)) = E_b\n        # => lambda >= F^2*h*b_i/(A*E_b^2). Take max over positive b_i.\n        if E_b = 0.0:\n            # Safety: E_b must be positive in physical settings; enforce a small positive\n            Eb_safe = 1e-12\n        else:\n            Eb_safe = E_b\n        lambda_hi_candidates = (F * F) * h * bp / (A * (Eb_safe ** 2))\n        lambda_hi = float(np.max(lambda_hi_candidates)) if lambda_hi_candidates.size > 0 else 1.0\n        # Inflate upper bound to be safe\n        lambda_hi *= 10.0\n        # Lower bound should be small but positive\n        lambda_lo = np.finfo(float).tiny  # ~5e-324\n\n        # Ensure that at lower bound sum_rho >= R and at upper bound sum_rho = R\n        # Increase lambda_hi until sum_rho(lambda_hi) = R\n        sr_hi = sum_rho(lambda_hi)\n        attempts = 0\n        while sr_hi > R and attempts  60:\n            lambda_hi *= 10.0\n            sr_hi = sum_rho(lambda_hi)\n            attempts += 1\n\n        # Bisection\n        # Tolerance on sum of rho\n        tol = 1e-12\n        max_iter = 200\n        for _ in range(max_iter):\n            lmbd = 0.5 * (lambda_lo + lambda_hi)\n            sr = sum_rho(lmbd)\n            if abs(sr - R) = tol:\n                lambda_lo = lambda_hi = lmbd\n                break\n            if sr > R:\n                # Need to decrease sum: increase lambda\n                lambda_lo = lmbd\n            else:\n                lambda_hi = lmbd\n\n        # Compute final rho using the found lambda\n        lmbd_star = 0.5 * (lambda_lo + lambda_hi)\n        sqrt_term = np.sqrt((F * F) * h * bp / (A * lmbd_star))\n        vals = (sqrt_term - E_b) / bp\n        vals = np.clip(vals, 0.0, 1.0)\n        rho[pos_mask] = vals\n\n    # Compute compliance J* = F^2 * sum_i h/(E_i * A)\n    E_i = E_b + rho * b\n    # Guard against nonpositive E_i due to numerical issues\n    E_i = np.maximum(E_i, 1e-24)\n    J = (F * F) * np.sum(h / (E_i * A))\n    return J\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (N, L, A, E_b, E0, alpha, vbar, F)\n    test_cases = [\n        (10, 1.0, 1.0e-3, 1.0e11, 2.0e11, 0.5, 0.3, 1000.0),\n        (10, 1.0, 1.0e-3, 1.0e11, 2.0e11, 0.5, 0.0, 1000.0),\n        (10, 1.0, 1.0e-3, 1.0e11, 2.0e11, 0.5, 1.0, 1000.0),\n        (10, 1.0, 1.0e-3, 1.0e11, 5.0e10, 3.0, 0.5, 1000.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, A, E_b, E0, alpha, vbar, F = case\n        Jstar = optimal_compliance(N, L, A, E_b, E0, alpha, vbar, F)\n        results.append(Jstar)\n\n    # Final print statement in the exact required format, rounded to six decimals.\n    formatted = \",\".join(f\"{val:.6f}\" for val in results)\n    print(f\"[{formatted}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2447101"}]}