{"hands_on_practices": [{"introduction": "本节练习将深入探讨材料非线性的核心——塑性。我们将通过一个动手实践，为一维弹塑性材料实现一个应力更新算法。这个练习的目标是实现“径向返回”算法，这是计算塑性力学中的基石，它能帮助我们理解当材料屈服后，其应力和内部状态变量是如何在每个增量步中被精确更新的。[@problem_id:2411414]", "problem": "实现一个适用于小应变单轴加载的一维隐式后向欧拉应力更新，该更新针对具有各向同性硬化（径向返回映射）的率无关 von Mises 塑性模型。从固体力学的基本定律开始。该实现必须使用后向欧拉时间离散化方法，为单个应变增量更新应力和内变量。您的程序必须是自包含的，并为每个提供的测试用例计算更新后的应力、塑性应变、累积塑性应变以及一致性算法切线模量。\n\n假设与定义：\n- 小应变运动学。总应变表示为 $\\,\\varepsilon\\,$，塑性应变表示为 $\\,\\varepsilon^{p}\\,$，累积塑性应变表示为 $\\,\\alpha\\,$。\n- 具有杨氏模量 $\\,E\\,$ 的一维线性弹性本构关系：$\\,\\sigma = E\\left(\\varepsilon - \\varepsilon^{p}\\right)\\,$，其中 $\\,\\sigma\\,$ 是 Cauchy 应力。\n- 各向同性硬化，具有恒定硬化模量 $\\,H \\ge 0\\,$ 和初始屈服应力 $\\,\\sigma_{y0} > 0\\,$。当前屈服应力为 $\\,\\sigma_{y}(\\alpha) = \\sigma_{y0} + H\\,\\alpha\\,$。\n- 针对一维特化的 von Mises 屈服函数：$\\,f(\\sigma,\\alpha)=|\\sigma|-\\sigma_{y}(\\alpha)\\,$，容许性条件为 $\\,f \\le 0\\,$。\n- 具有一致性的相关联流动。一维塑性流动方向是 $\\,\\sigma\\,$ 的符号。\n\n离散化目标：\n- 给定材料参数 $\\,E\\,$（单位 $\\mathrm{Pa}$）、$\\,H\\,$（单位 $\\mathrm{Pa}$）和 $\\,\\sigma_{y0}\\,$（单位 $\\mathrm{Pa}$），以及步长 $\\,n\\,$ 时的状态（由 $\\,\\varepsilon^{p}_{n}\\,$ 和 $\\,\\alpha_{n}\\,$ 组成，两者均无量纲），以及步长 $\\,n+1\\,$ 时指定总应变（表示为 $\\,\\varepsilon_{n+1}\\,$，无量纲），使用隐式后向欧拉返回映射格式计算更新后的值 $\\,\\sigma_{n+1}\\,$（单位 $\\mathrm{Pa}$）、$\\,\\varepsilon^{p}_{n+1}\\,$（无量纲）、$\\,\\alpha_{n+1}\\,$（无量纲）以及一致性算法切线模量 $\\,E_{\\mathrm{tan},\\,n+1}\\,$（单位 $\\mathrm{Pa}$）。\n\n数值要求：\n- 如果试探状态违反了容许性条件，您的算法必须实现一个弹性试探状态和到屈服面的径向返回。使用数值上鲁棒的方法处理屈服条件，以判别是弹性响应还是塑性响应。\n- 不涉及角度；无需角度单位。\n- 所有应力必须以 $\\mathrm{Pa}$ 表示，应变为无量纲。\n\n测试套件：\n对每个测试，输入元组为 $\\,\\left(E,\\,H,\\,\\sigma_{y0},\\,\\varepsilon_{n+1},\\,\\varepsilon^{p}_{n},\\,\\alpha_{n}\\right)\\,$。您的程序必须计算输出 $\\,\\left[\\sigma_{n+1},\\,\\varepsilon^{p}_{n+1},\\,\\alpha_{n+1},\\,E_{\\mathrm{tan},\\,n+1}\\right]\\,$。\n\n为以下六个测试用例提供结果：\n1. $\\,\\left( E=210\\times 10^{9}\\,\\mathrm{Pa},\\; H=2\\times 10^{9}\\,\\mathrm{Pa},\\; \\sigma_{y0}=400\\times 10^{6}\\,\\mathrm{Pa},\\; \\varepsilon_{n+1}=1.0\\times 10^{-3},\\; \\varepsilon^{p}_{n}=0,\\; \\alpha_{n}=0 \\right)\\,$\n2. $\\,\\left( E=200\\times 10^{9}\\,\\mathrm{Pa},\\; H=1\\times 10^{9}\\,\\mathrm{Pa},\\; \\sigma_{y0}=250\\times 10^{6}\\,\\mathrm{Pa},\\; \\varepsilon_{n+1}=1.25\\times 10^{-3},\\; \\varepsilon^{p}_{n}=0,\\; \\alpha_{n}=0 \\right)\\,$\n3. $\\,\\left( E=200\\times 10^{9}\\,\\mathrm{Pa},\\; H=1\\times 10^{9}\\,\\mathrm{Pa},\\; \\sigma_{y0}=250\\times 10^{6}\\,\\mathrm{Pa},\\; \\varepsilon_{n+1}=2.0\\times 10^{-3},\\; \\varepsilon^{p}_{n}=0,\\; \\alpha_{n}=0 \\right)\\,$\n4. $\\,\\left( E=210\\times 10^{9}\\,\\mathrm{Pa},\\; H=2\\times 10^{9}\\,\\mathrm{Pa},\\; \\sigma_{y0}=400\\times 10^{6}\\,\\mathrm{Pa},\\; \\varepsilon_{n+1}=3.0\\times 10^{-3},\\; \\varepsilon^{p}_{n}=1.0\\times 10^{-3},\\; \\alpha_{n}=1.0\\times 10^{-3} \\right)\\,$\n5. $\\,\\left( E=210\\times 10^{9}\\,\\mathrm{Pa},\\; H=2\\times 10^{9}\\,\\mathrm{Pa},\\; \\sigma_{y0}=400\\times 10^{6}\\,\\mathrm{Pa},\\; \\varepsilon_{n+1}=-5.0\\times 10^{-4},\\; \\varepsilon^{p}_{n}=1.0\\times 10^{-3},\\; \\alpha_{n}=1.0\\times 10^{-3} \\right)\\,$\n6. $\\,\\left( E=100\\times 10^{9}\\,\\mathrm{Pa},\\; H=0,\\; \\sigma_{y0}=100\\times 10^{6}\\,\\mathrm{Pa},\\; \\varepsilon_{n+1}=2.0\\times 10^{-3},\\; \\varepsilon^{p}_{n}=0,\\; \\alpha_{n}=0 \\right)\\,$\n\n最终输出格式：\n- 您的程序应生成单行输出，包含所有测试用例的结果，格式为列表的列表：\n  $\\,\\bigl[\\,[\\sigma_{1},\\,\\varepsilon^{p}_{1},\\,\\alpha_{1},\\,E_{\\mathrm{tan},1}],\\;[\\sigma_{2},\\,\\varepsilon^{p}_{2},\\,\\alpha_{2},\\,E_{\\mathrm{tan},2}],\\;\\dotsc,\\;[\\sigma_{6},\\,\\varepsilon^{p}_{6},\\,\\alpha_{6},\\,E_{\\mathrm{tan},6}]\\,\\bigr]\\,$\n- 每个 $\\,\\sigma_{i}\\,$ 和 $\\,E_{\\mathrm{tan},i}\\,$ 必须以 $\\mathrm{Pa}$ 为单位，$\\,\\varepsilon^{p}_{i}\\,$ 和 $\\,\\alpha_{i}\\,$ 必须是无量纲的。输出中不要包含任何文本或单位；只须打印数值列表。", "solution": "所述问题是有效的。这是一个来自计算固体力学领域的、适定的、有科学依据的问题，并提供了所有必要的信息。我们将着手进行推导和求解。\n\n该问题要求实现一个带有各向同性硬化的隐式、一维、率无关的弹塑性模型。任务的核心是使用后向欧拉法（一种通常称为径向返回映射算法的技术）为单个时间增量执行应力更新过程。\n\n**$1$。基本本构方程**\n\n我们首先以连续的、基于率的形式陈述控制方程。\n\n- **应变分解**：总应变 $\\varepsilon$ 加性分解为一个弹性部分 $\\varepsilon^{e}$ 和一个塑性部分 $\\varepsilon^{p}$：\n$$ \\varepsilon = \\varepsilon^{e} + \\varepsilon^{p} $$\n其率形式为：\n$$ \\dot{\\varepsilon} = \\dot{\\varepsilon}^{e} + \\dot{\\varepsilon}^{p} $$\n\n- **弹性定律**：应力 $\\sigma$ 通过具有杨氏模量 $E$ 的线性弹性（Hooke）定律与弹性应变相关：\n$$ \\sigma = E \\varepsilon^{e} = E (\\varepsilon - \\varepsilon^{p}) $$\n其率形式为：\n$$ \\dot{\\sigma} = E \\dot{\\varepsilon}^{e} = E (\\dot{\\varepsilon} - \\dot{\\varepsilon}^{p}) $$\n\n- **屈服函数**：弹性域的边界由一维特化的 von Mises 屈服函数 $f$ 定义。它取决于应力 $\\sigma$ 和一个内变量，即累积塑性应变 $\\alpha$：\n$$ f(\\sigma, \\alpha) = |\\sigma| - \\sigma_{y}(\\alpha) \\le 0 $$\n其中 $\\sigma_{y}(\\alpha)$ 是当前屈服应力。\n\n- **各向同性硬化定律**：当前屈服应力 $\\sigma_{y}(\\alpha)$ 根据线性各向同性硬化法则随累积塑性应变 $\\alpha$ 演化：\n$$ \\sigma_{y}(\\alpha) = \\sigma_{y0} + H\\alpha $$\n此处，$\\sigma_{y0}$ 是初始屈服应力，H 是恒定硬化模量。\n\n- **流动法则和硬化演化**：塑性流动是相关联的，意味着塑性应变率 $\\dot{\\varepsilon}^{p}$ 垂直于屈服面。内变量的演化由塑性乘子率 $\\dot{\\gamma}$ 控制：\n$$ \\dot{\\varepsilon}^{p} = \\dot{\\gamma} \\frac{\\partial f}{\\partial \\sigma} = \\dot{\\gamma} \\, \\mathrm{sgn}(\\sigma) $$\n$$ \\dot{\\alpha} = \\dot{\\gamma} \\sqrt{\\left(\\frac{\\partial f}{\\partial \\sigma}\\right)^2} = \\dot{\\gamma} |\\mathrm{sgn}(\\sigma)| = \\dot{\\gamma} $$\n\n- **Karush-Kuhn-Tucker (KKT) 加载/卸载条件**：这些条件控制着塑性流动：\n$$ \\dot{\\gamma} \\ge 0, \\quad f(\\sigma, \\alpha) \\le 0, \\quad \\dot{\\gamma} f(\\sigma, \\alpha) = 0 $$\n如果发生塑性加载（$\\dot{\\gamma} > 0$），状态必须保持在屈服面上（$f=0$），这意味着一致性条件 $\\dot{f}=0$。\n\n**$2$。隐式后向欧拉离散化**\n\n我们使用隐式后向欧拉格式在从 $t_{n}$ 到 $t_{n+1}$ 的时间增量上对率方程进行积分。这意味着所有率项都在步长末端 $t_{n+1}$ 处进行评估。给定步长 $n$ 时的状态 $(\\varepsilon^{p}_{n}, \\alpha_{n})$ 和步长 $n+1$ 时的总应变 $\\varepsilon_{n+1}$，我们必须找到 $(\\sigma_{n+1}, \\varepsilon^{p}_{n+1}, \\alpha_{n+1})$。\n\n离散化的演化方程为：\n$$ \\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta\\varepsilon^{p} = \\varepsilon^{p}_{n} + \\Delta\\gamma \\, \\mathrm{sgn}(\\sigma_{n+1}) $$\n$$ \\alpha_{n+1} = \\alpha_{n} + \\Delta\\alpha = \\alpha_{n} + \\Delta\\gamma $$\n其中 $\\Delta\\gamma = \\int_{t_n}^{t_{n+1}} \\dot{\\gamma} \\, dt$ 是有限塑性乘子增量，它必须是非负的，即 $\\Delta\\gamma \\ge 0$。\n\n步长末端的应力为：\n$$ \\sigma_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^{p}_{n+1}) $$\n\n离散形式的 KKT 条件变为：\n$$ \\Delta\\gamma \\ge 0, \\quad f_{n+1} = |\\sigma_{n+1}| - \\sigma_{y}(\\alpha_{n+1}) \\le 0, \\quad \\Delta\\gamma f_{n+1} = 0 $$\n\n**$3$。返回映射算法**\n\n该算法提供了一种求解离散化系统的鲁棒方法。它包括一个弹性预测，如果预测结果违反了屈服条件，则进行塑性修正。\n\n**步骤 $3.1$：弹性预测器**\n\n首先，我们假设该步是纯弹性的，这意味着 $\\Delta\\gamma = 0$。这给出了一个“试探”状态。\n塑性应变和累积塑性应变不发生改变：\n$$ \\varepsilon^{p, \\mathrm{trial}}_{n+1} = \\varepsilon^{p}_{n} $$\n$$ \\alpha^{\\mathrm{trial}}_{n+1} = \\alpha_{n} $$\n试探应力由 Hooke 定律计算得出：\n$$ \\sigma^{\\mathrm{trial}}_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^{p}_{n}) $$\n\n**步骤 $3.2$：屈服检查**\n\n我们检查该试探状态是否是容许的，通过评估屈服函数。用于此检查的屈服应力基于增量开始时的状态：\n$$ \\sigma_{y,n} = \\sigma_{y0} + H\\alpha_{n} $$\n试探屈服函数值为：\n$$ f^{\\mathrm{trial}}_{n+1} = |\\sigma^{\\mathrm{trial}}_{n+1}| - \\sigma_{y,n} $$\n- 如果 $f^{\\mathrm{trial}}_{n+1} \\le 0$，则弹性假设是正确的。材料响应是弹性的。最终状态即为试探状态：\n  $$ \\sigma_{n+1} = \\sigma^{\\mathrm{trial}}_{n+1}, \\quad \\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n}, \\quad \\alpha_{n+1} = \\alpha_{n} $$\n- 如果 $f^{\\mathrm{trial}}_{n+1} > 0$，则弹性假设被违反。发生塑性变形，需要进行塑性修正。\n\n**步骤 $3.3$：塑性修正器**\n\n对于一个塑性步，我们必须找到 $\\Delta\\gamma > 0$，使得最终状态 $(\\sigma_{n+1}, \\alpha_{n+1})$ 位于更新后的屈服面上，即 $f_{n+1} = 0$。\n$$ |\\sigma_{n+1}| - (\\sigma_{y0} + H\\alpha_{n+1}) = 0 $$\n代入离散化的演化方程：\n$$ |\\sigma_{n+1}| = \\sigma_{y0} + H(\\alpha_{n} + \\Delta\\gamma) = (\\sigma_{y0} + H\\alpha_{n}) + H\\Delta\\gamma = \\sigma_{y,n} + H\\Delta\\gamma $$\n现在，用试探应力和 $\\Delta\\gamma$ 来表示 $\\sigma_{n+1}$：\n$$ \\sigma_{n+1} = E(\\varepsilon_{n+1} - \\varepsilon^{p}_{n+1}) = E(\\varepsilon_{n+1} - (\\varepsilon^{p}_{n} + \\Delta\\gamma \\, \\mathrm{sgn}(\\sigma_{n+1}))) $$\n$$ \\sigma_{n+1} = E(\\varepsilon_{n+1} - \\varepsilon^{p}_{n}) - E\\Delta\\gamma \\, \\mathrm{sgn}(\\sigma_{n+1}) = \\sigma^{\\mathrm{trial}}_{n+1} - E\\Delta\\gamma \\, \\mathrm{sgn}(\\sigma_{n+1}) $$\n该算法的一个关键方面是在返回过程中应力符号不发生改变，因此 $\\mathrm{sgn}(\\sigma_{n+1}) = \\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1})$。取绝对值：\n$$ |\\sigma_{n+1}| = |\\sigma^{\\mathrm{trial}}_{n+1}| - E\\Delta\\gamma $$\n这个方程描述了应力大小从试探值“返回”到屈服面的过程。将 $|\\sigma_{n+1}|$ 的两个表达式相等：\n$$ |\\sigma^{\\mathrm{trial}}_{n+1}| - E\\Delta\\gamma = \\sigma_{y,n} + H\\Delta\\gamma $$\n求解塑性乘子增量 $\\Delta\\gamma$：\n$$ |\\sigma^{\\mathrm{trial}}_{n+1}| - \\sigma_{y,n} = (E+H)\\Delta\\gamma $$\n$$ \\Delta\\gamma = \\frac{|\\sigma^{\\mathrm{trial}}_{n+1}| - \\sigma_{y,n}}{E+H} = \\frac{f^{\\mathrm{trial}}_{n+1}}{E+H} $$\n由于我们处于塑性情况，$f^{\\mathrm{trial}}_{n+1} > 0$。因为 $E > 0$ 且 $H \\ge 0$，我们正确地得到 $\\Delta\\gamma > 0$。\n\n一旦 $\\Delta\\gamma$ 已知，我们更新状态变量：\n$$ \\alpha_{n+1} = \\alpha_{n} + \\Delta\\gamma $$\n$$ \\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta\\gamma \\, \\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1}) $$\n更新后的应力 $\\sigma_{n+1}$ 可以通过从试探应力返回或使用最终屈服条件来计算。使用后者通常更为鲁棒：\n$$ \\sigma_{n+1} = \\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1}) \\times \\sigma_{y}(\\alpha_{n+1}) = \\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1}) \\times (\\sigma_{y,n} + H\\Delta\\gamma) $$\n\n**$4$。一致性算法切线模量**\n\n一致性算法切线模量 $E_{\\mathrm{tan},n+1}$ 定义为最终应力对最终总应变的导数，即 $E_{\\mathrm{tan},n+1} = \\frac{d\\sigma_{n+1}}{d\\varepsilon_{n+1}}$。它对隐式有限元方法至关重要。\n\n- **弹性情况**：如果该步是弹性的，$\\sigma_{n+1} = E(\\varepsilon_{n+1} - \\varepsilon^{p}_{n})$。\n$$ E_{\\mathrm{tan},n+1} = \\frac{d}{d\\varepsilon_{n+1}} [E(\\varepsilon_{n+1} - \\varepsilon^{p}_{n})] = E $$\n\n- **塑性情况**：如果该步是塑性的，我们对最终应力表达式求导。一个便于求导的形式是：\n$$ \\sigma_{n+1} = \\frac{\\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1})E\\sigma_{y,n} + HE(\\varepsilon_{n+1} - \\varepsilon^{p}_n)}{E+H} $$\n对 $\\varepsilon_{n+1}$ 求导（并将 $\\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1})$ 视为对 $\\varepsilon_{n+1}$ 的无穷小变化是常数）：\n$$ E_{\\mathrm{tan},n+1} = \\frac{d\\sigma_{n+1}}{d\\varepsilon_{n+1}} = \\frac{d}{d\\varepsilon_{n+1}} \\left[ \\frac{\\mathrm{const} + HE\\varepsilon_{n+1}}{E+H} \\right] = \\frac{HE}{E+H} $$\n对于理想塑性（$H=0$），这正确地得出 $E_{\\mathrm{tan},n+1} = 0$。\n\n**$5$。实现算法摘要**\n\n对于每个输入元组 $(E, H, \\sigma_{y0}, \\varepsilon_{n+1}, \\varepsilon^{p}_{n}, \\alpha_{n})$：\n1.  计算试探应力：$\\sigma^{\\mathrm{trial}}_{n+1} = E(\\varepsilon_{n+1} - \\varepsilon^{p}_{n})$。\n2.  基于前一状态计算屈服应力：$\\sigma_{y,n} = \\sigma_{y0} + H\\alpha_{n}$。\n3.  评估试探屈服函数：$f^{\\mathrm{trial}}_{n+1} = |\\sigma^{\\mathrm{trial}}_{n+1}| - \\sigma_{y,n}$。\n4.  **如果 $f^{\\mathrm{trial}}_{n+1} \\le 0$ (弹性步):**\n    - $\\sigma_{n+1} = \\sigma^{\\mathrm{trial}}_{n+1}$\n    - $\\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n}$\n    - $\\alpha_{n+1} = \\alpha_{n}$\n    - $E_{\\mathrm{tan},n+1} = E$\n5.  **否则 (塑性步):**\n    - $\\Delta\\gamma = f^{\\mathrm{trial}}_{n+1} / (E+H)$。\n    - $\\alpha_{n+1} = \\alpha_{n} + \\Delta\\gamma$。\n    - $\\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta\\gamma \\cdot \\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1})$。\n    - $\\sigma_{n+1} = \\mathrm{sgn}(\\sigma^{\\mathrm{trial}}_{n+1}) \\cdot (\\sigma_{y,n} + H\\Delta\\gamma)$。\n    - $E_{\\mathrm{tan},n+1} = (E \\cdot H) / (E+H)$。\n6.  返回计算值 $[\\sigma_{n+1}, \\varepsilon^{p}_{n+1}, \\alpha_{n+1}, E_{\\mathrm{tan},n+1}]$。\n\n该算法现在已准备好可以实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef update_stress(E, H, sig_y0, eps_n1, eps_p_n, alpha_n):\n    \"\"\"\n    Computes the updated stress, plastic strain, accumulated plastic strain,\n    and consistent tangent modulus for a 1D J2 plasticity model with\n    isotropic hardening using an implicit backward Euler return-mapping algorithm.\n\n    Args:\n        E (float): Young's modulus in Pa.\n        H (float): Hardening modulus in Pa.\n        sig_y0 (float): Initial yield stress in Pa.\n        eps_n1 (float): Total strain at step n+1 (dimensionless).\n        eps_p_n (float): Plastic strain at step n (dimensionless).\n        alpha_n (float): Accumulated plastic strain at step n (dimensionless).\n\n    Returns:\n        list: A list containing [sig_n1, eps_p_n1, alpha_n1, E_tan_n1].\n    \"\"\"\n    # Step 1: Elastic predictor (trial state)\n    sig_trial_n1 = E * (eps_n1 - eps_p_n)\n\n    # Step 2: Yield check\n    # Yield stress from the previous converged step n\n    sig_y_n = sig_y0 + H * alpha_n\n    \n    # Evaluate yield function at the trial state\n    f_trial_n1 = np.abs(sig_trial_n1) - sig_y_n\n\n    # Step 3: Determine if the step is elastic or plastic\n    if f_trial_n1 <= 0:\n        # Elastic step\n        sig_n1 = sig_trial_n1\n        eps_p_n1 = eps_p_n\n        alpha_n1 = alpha_n\n        E_tan_n1 = E\n    else:\n        # Plastic step (plastic corrector)\n        \n        # Calculate the plastic multiplier increment\n        # E > 0 and H >= 0, so E + H > 0.\n        delta_gamma = f_trial_n1 / (E + H)\n\n        # Update internal variables\n        alpha_n1 = alpha_n + delta_gamma\n        \n        # The sign of trial stress determines the direction of plastic flow.\n        # If sig_trial_n1 were 0, f_trial_n1 would be <= 0, so we would be\n        # in the elastic branch. Thus, sig_trial_n1 is non-zero here.\n        sign_sig_trial = np.sign(sig_trial_n1)\n        \n        eps_p_n1 = eps_p_n + delta_gamma * sign_sig_trial\n\n        # Update stress by returning to the updated yield surface.\n        # This form is numerically stable and directly enforces the yield condition.\n        sig_n1 = sign_sig_trial * (sig_y_n + H * delta_gamma)\n\n        # Calculate the consistent algorithmic tangent modulus for the plastic case\n        E_tan_n1 = (E * H) / (E + H)\n\n    return [sig_n1, eps_p_n1, alpha_n1, E_tan_n1]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (E, H, sigma_y0, epsilon_n+1, epsilon_p_n, alpha_n)\n    test_cases = [\n        (210e9, 2e9, 400e6, 1.0e-3, 0.0, 0.0),\n        (200e9, 1e9, 250e6, 1.25e-3, 0.0, 0.0),\n        (200e9, 1e9, 250e6, 2.0e-3, 0.0, 0.0),\n        (210e9, 2e9, 400e6, 3.0e-3, 1.0e-3, 1.0e-3),\n        (210e9, 2e9, 400e6, -5.0e-4, 1.0e-3, 1.0e-3),\n        (100e9, 0.0, 100e6, 2.0e-3, 0.0, 0.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack the parameters for the current test case\n        E, H, sig_y0, eps_n1, eps_p_n, alpha_n = case\n        \n        # Calculate the updated state\n        result = update_stress(E, H, sig_y0, eps_n1, eps_p_n, alpha_n)\n        results.append(result)\n\n    # Format the output string to be exactly as specified: [[r1,r2,...],[...],...]\n    # without extra spaces.\n    inner_lists = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_output_str = f\"[{','.join(inner_lists)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n```", "id": "2411414"}, {"introduction": "现在我们将注意力转向几何非线性，这是分析结构大位移和稳定性问题的关键。本练习要求您为一个二维桁架单元构建几何刚度矩阵 $K_{\\sigma}$。这个矩阵能够捕捉现有应力状态对结构刚度的影响，例如受拉时刚度增加（应力刚化）或受压时刚度减小（应力软化），后者是结构屈曲的前兆。通过编程实现该矩阵并数值验证其一个重要的理论特性，您将对这个抽象但至关重要的概念有更具体的认识。[@problem_id:2411426]", "problem": "实现一个完整且可运行的程序，该程序计算一个经历大转动和小轴向应变的双节点二维（$2$D）直杆桁架单元的几何刚度矩阵 $K_{\\sigma}$，并在给定的构型集上对其进行验证。\n\n几何刚度矩阵 $K_{\\sigma}$ 被定义为，对于一个每个节点具有两个平动自由度（degrees of freedom (DOF)）的直杆，根据虚功原理导出的一致切线刚度中的初始应力贡献部分。设单元连接节点 $1$（当前位置为 $\\mathbf{x}_1 = (x_1,y_1)$）和节点 $2$（当前位置为 $\\mathbf{x}_2 = (x_2,y_2)$），其当前长度为 $l = \\|\\mathbf{x}_2 - \\mathbf{x}_1\\|$，当前单位切向量为 $\\mathbf{t} = (\\mathbf{x}_2 - \\mathbf{x}_1)/l$。设初始（参考）位置为 $\\mathbf{X}_1 = (X_1,Y_1)$ 和 $\\mathbf{X}_2 = (X_2,Y_2)$，初始长度为 $L_0 = \\|\\mathbf{X}_2 - \\mathbf{X}_1\\|$。材料为线性弹性，杨氏模量为 $E$，横截面积为恒定的 $A$。假设轴向应变为小应变，但允许弦杆有任意大的刚体转动。轴力 $N$ 通过轴向伸长量计算，公式为 $N = (EA/L_0)\\,(l - L_0)$，并用于几何刚度的计算。所有力必须以牛顿（newtons）表示，所有长度必须以米（meters）表示。\n\n您的程序必须：\n- 对于每个测试用例，根据给定的 $E$、$A$、$L_0$ 和当前构型，计算轴力 $N$（单位：牛顿）。\n- 构建全局坐标系中尺寸为 $4\\times 4$ 的几何刚度矩阵 $K_{\\sigma}$，其自由度排序为 $(x_1,y_1,x_2,y_2)$，单位为牛顿/米。\n- 为了验证，计算 Frobenius 范数 $\\|K_{\\sigma}\\|_F$ 并将其与标量 $2|N|/l$（单位：牛顿/米）进行比较。对于每个测试用例，报告标量差 $\\Delta = \\|K_{\\sigma}\\|_F - 2|N|/l$，单位为牛顿/米。\n\n下文指定的角度单位为弧度。所有输出值都必须以牛顿/米报告，并四舍五入到 $9$ 位小数。\n\n测试套件（每个用例相互独立）：\n- 用例 A（刚性转动，零伸长）：\n  - $E = 2.10\\times 10^{11}\\,\\mathrm{Pa}$，$A = 3.0\\times 10^{-4}\\,\\mathrm{m}^2$。\n  - $\\mathbf{X}_1 = (0,0)\\,\\mathrm{m}$，$\\mathbf{X}_2 = (1,0)\\,\\mathrm{m}$，因此 $L_0 = 1.0\\,\\mathrm{m}$。\n  - 当前构型：绕节点 $1$ 纯转动角度 $\\theta = \\pi/3$，即 $\\mathbf{x}_1 = (0,0)\\,\\mathrm{m}$，$\\mathbf{x}_2 = (L_0\\cos\\theta,\\,L_0\\sin\\theta)\\,\\mathrm{m}$。\n- 用例 B（纯轴向拉伸，无转动）：\n  - $E = 7.0\\times 10^{10}\\,\\mathrm{Pa}$，$A = 1.2\\times 10^{-4}\\,\\mathrm{m}^2$。\n  - $\\mathbf{X}_1 = (0,0)\\,\\mathrm{m}$，$\\mathbf{X}_2 = (2,0)\\,\\mathrm{m}$，因此 $L_0 = 2.0\\,\\mathrm{m}$。\n  - 当前构型：$\\mathbf{x}_1 = (0,0)\\,\\mathrm{m}$，$\\mathbf{x}_2 = (2.02,\\,0)\\,\\mathrm{m}$。\n- 用例 C（大转动伴随压缩）：\n  - $E = 2.00\\times 10^{11}\\,\\mathrm{Pa}$，$A = 2.5\\times 10^{-4}\\,\\mathrm{m}^2$。\n  - $\\mathbf{X}_1 = (0,0)\\,\\mathrm{m}$，$\\mathbf{X}_2 = (1.5,0)\\,\\mathrm{m}$，因此 $L_0 = 1.5\\,\\mathrm{m}$。\n  - 当前构型：转动角度 $\\theta = 1.74532925199433$ 并径向缩短 $\\delta = -0.01\\,\\mathrm{m}$，即 $\\mathbf{x}_1 = (0,0)\\,\\mathrm{m}$，$\\mathbf{x}_2 = ((L_0+\\delta)\\cos\\theta,\\,(L_0+\\delta)\\sin\\theta)\\,\\mathrm{m}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的结果列表，顺序为用例 A、B、C，例如 $[\\Delta_A,\\Delta_B,\\Delta_C]$，其中每个 $\\Delta$ 是一个单位为牛顿/米的浮点数，并四舍五入到 $9$ 位小数。", "solution": "用户提交了一个问题以供评估和解决。第一个强制性步骤是对问题陈述进行严格验证。\n\n### 步骤 1：提取已知条件\n\n问题陈述提供了以下信息：\n- **单元定义**：一个具有两个节点的二维（$2$D）直杆桁架单元。\n- **自由度（DOF）**：每个节点两个平动自由度。全局自由度向量排序为 $(x_1, y_1, x_2, y_2)$。\n- **运动学假设**：大刚体转动和小轴向应变。\n- **节点位置**：\n    - 参考（初始）位置：$\\mathbf{X}_1 = (X_1, Y_1)$，$\\mathbf{X}_2 = (X_2, Y_2)$\n    - 当前位置：$\\mathbf{x}_1 = (x_1, y_1)$，$\\mathbf{x}_2 = (x_2, y_2)$\n- **单元长度**：\n    - 初始长度：$L_0 = \\|\\mathbf{X}_2 - \\mathbf{X}_1\\|$\n    - 当前长度：$l = \\|\\mathbf{x}_2 - \\mathbf{x}_1\\|$\n- **单元切向量**：当前单位切向量 $\\mathbf{t} = (\\mathbf{x}_2 - \\mathbf{x}_1)/l$。\n- **材料属性**：线性弹性，杨氏模量为 $E$，横截面积为恒定的 $A$。\n- **本构关系**：轴力 $N = (EA/L_0)\\,(l - L_0)$。\n- **目标量**：全局坐标系中的几何刚度矩阵 $\\mathbf{K}_{\\sigma}$，定义为一致切线刚度中的初始应力贡献。它是一个 $4 \\times 4$ 矩阵。\n- **验证任务**：对于每个测试用例，计算标量差 $\\Delta = \\|K_{\\sigma}\\|_F - 2|N|/l$，其中 $\\|K_{\\sigma}\\|_F$ 是几何刚度矩阵的 Frobenius 范数。\n- **单位**：力以牛顿（N）表示，长度以米（m）表示，压力以帕斯卡（Pa）表示。输出 $\\Delta$ 的单位为 N/m。\n- **输出精度**：所有输出值必须四舍五入到 $9$ 位小数。\n\n- **测试用例 A**：\n  - $E = 2.10 \\times 10^{11}\\,\\mathrm{Pa}$，$A = 3.0 \\times 10^{-4}\\,\\mathrm{m}^2$。\n  - $\\mathbf{X}_1 = (0,0)\\,\\mathrm{m}$，$\\mathbf{X}_2 = (1,0)\\,\\mathrm{m}$（$L_0 = 1.0\\,\\mathrm{m}$）。\n  - 当前构型：绕节点 $1$ 转动角度 $\\theta = \\pi/3$，因此 $\\mathbf{x}_1 = (0,0)\\,\\mathrm{m}$，$\\mathbf{x}_2 = (L_0\\cos\\theta,\\,L_0\\sin\\theta)\\,\\mathrm{m}$。\n\n- **测试用例 B**：\n  - $E = 7.0 \\times 10^{10}\\,\\mathrm{Pa}$，$A = 1.2 \\times 10^{-4}\\,\\mathrm{m}^2$。\n  - $\\mathbf{X}_1 = (0,0)\\,\\mathrm{m}$，$\\mathbf{X}_2 = (2,0)\\,\\mathrm{m}$（$L_0 = 2.0\\,\\mathrm{m}$）。\n  - 当前构型：$\\mathbf{x}_1 = (0,0)\\,\\mathrm{m}$，$\\mathbf{x}_2 = (2.02,\\,0)\\,\\mathrm{m}$。\n\n- **测试用例 C**：\n  - $E = 2.00 \\times 10^{11}\\,\\mathrm{Pa}$，$A = 2.5 \\times 10^{-4}\\,\\mathrm{m}^2$。\n  - $\\mathbf{X}_1 = (0,0)\\,\\mathrm{m}$，$\\mathbf{X}_2 = (1.5,0)\\,\\mathrm{m}$（$L_0 = 1.5\\,\\mathrm{m}$）。\n  - 当前构型：转动角度 $\\theta = 1.74532925199433\\,\\mathrm{rad}$ 并径向缩短 $\\delta = -0.01\\,\\mathrm{m}$，因此 $\\mathbf{x}_1 = (0,0)\\,\\mathrm{m}$，$\\mathbf{x}_2 = ((L_0+\\delta)\\cos\\theta,\\,(L_0+\\delta)\\sin\\theta)\\,\\mathrm{m}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n根据所需标准对问题进行评估：\n- **科学依据**：该问题植根于结构有限元分析，特别是在几何非线性背景下。几何刚度矩阵（$\\mathbf{K}_\\sigma$）的概念是计算固体力学中的一个标准和基本组成部分，用于捕捉现有应力对刚度的影响（例如，应力刚化或软化效应）。提供的轴力公式 $N = (EA/L_0)(l - L_0)$ 是胡克定律直接应用于杆的总伸长，这与共旋列式法或小应变假设下的全拉格朗日列式法是一致的。该问题是此领域的一个标准练习。\n- **适定性**：该问题是适定的。对于每个测试用例，所有必要的数据（$E, A$，初始和当前坐标）都已提供。所有待计算量（$L_0, l, N, \\mathbf{K}_\\sigma, \\|K_{\\sigma}\\|_F, \\Delta$）的定义都是无歧义的。指令对于每个用例都会导出一个唯一的、确定性的结果。\n- **客观性**：语言完全客观，采用精确的数学和工程术语。没有主观或基于观点的陈述。输入和期望输出是可量化的。\n\n该问题未表现出任何列举的无效性缺陷。它在科学上是合理的，与指定主题直接相关，是完整的，物理上可信的，并且结构良好。\n\n### 步骤 3：结论与行动\n\n问题是**有效的**。现在将提供一个完整的、论证充分的解决方案。\n\n### 解法推导\n\n分析经历大位移但小应变的结构需要考虑几何非线性。总切线刚度矩阵 $\\mathbf{K}_T$ 是材料刚度矩阵 $\\mathbf{K}_m$（取决于材料属性和几何形状）与几何刚度矩阵 $\\mathbf{K}_\\sigma$（取决于当前应力状态）之和。\n$$\n\\mathbf{K}_T = \\mathbf{K}_m + \\mathbf{K}_\\sigma\n$$\n本问题仅关注 $\\mathbf{K}_\\sigma$ 的计算。该矩阵源于内力向量相对于几何变化的变分。对于承受轴力 $N$（拉伸为正，压缩为负）的二维桁架单元，其在全局坐标系中的几何刚度矩阵由一个公认的公式给出：\n$$\n\\mathbf{K}_{\\sigma} = \\frac{N}{l}\n\\begin{bmatrix}\n\\mathbf{I} - \\mathbf{t} \\otimes \\mathbf{t} & -(\\mathbf{I} - \\mathbf{t} \\otimes \\mathbf{t}) \\\\\n-(\\mathbf{I} - \\mathbf{t} \\otimes \\mathbf{t}) & \\mathbf{I} - \\mathbf{t} \\otimes \\mathbf{t}\n\\end{bmatrix}\n$$\n在此表达式中，$l$ 是单元的当前长度，$N$ 是轴力，$\\mathbf{I}$ 是 $2 \\times 2$ 单位矩阵，$\\mathbf{t}$ 是单元在当前构型下沿其轴线的单位向量，定义为 $\\mathbf{t} = (t_x, t_y)^T = \\frac{1}{l}(\\mathbf{x}_2 - \\mathbf{x}_1)$。符号 $\\otimes$ 表示张量积。\n\n$2 \\times 2$ 子矩阵 $\\mathbf{I} - \\mathbf{t} \\otimes \\mathbf{t}$ 可以展开。由于 $\\mathbf{t}$ 是一个单位向量，所以 $t_x^2 + t_y^2 = 1$。\n$$\n\\mathbf{t} \\otimes \\mathbf{t} = \\begin{bmatrix} t_x \\\\ t_y \\end{bmatrix} \\begin{bmatrix} t_x & t_y \\end{bmatrix} = \\begin{bmatrix} t_x^2 & t_x t_y \\\\ t_x t_y & t_y^2 \\end{bmatrix}\n$$\n因此，\n$$\n\\mathbf{I} - \\mathbf{t} \\otimes \\mathbf{t} = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} - \\begin{bmatrix} t_x^2 & t_x t_y \\\\ t_x t_y & t_y^2 \\end{bmatrix} = \\begin{bmatrix} 1 - t_x^2 & -t_x t_y \\\\ -t_x t_y & 1 - t_y^2 \\end{bmatrix} = \\begin{bmatrix} t_y^2 & -t_x t_y \\\\ -t_x t_y & t_x^2 \\end{bmatrix}\n$$\n让我们将此子矩阵表示为 $\\mathbf{M}$。那么，对应于全局自由度 $(x_1, y_1, x_2, y_2)$ 的完整 $4 \\times 4$ 几何刚度矩阵为：\n$$\n\\mathbf{K}_{\\sigma} = \\frac{N}{l} \\begin{bmatrix} \\mathbf{M} & -\\mathbf{M} \\\\ -\\mathbf{M} & \\mathbf{M} \\end{bmatrix} = \\frac{N}{l}\n\\begin{bmatrix}\nt_y^2 & -t_x t_y & -t_y^2 & t_x t_y \\\\\n-t_x t_y & t_x^2 & t_x t_y & -t_x^2 \\\\\n-t_y^2 & t_x t_y & t_y^2 & -t_x t_y \\\\\nt_x t_y & -t_x^2 & -t_x t_y & t_x^2\n\\end{bmatrix}\n$$\n问题要求计算该矩阵的 Frobenius 范数 $\\|\\mathbf{K}_{\\sigma}\\|_F$。Frobenius 范数的平方是其所有元素平方的总和。\n$$\n\\|\\mathbf{K}_{\\sigma}\\|_F^2 = \\text{tr}(\\mathbf{K}_{\\sigma}^T \\mathbf{K}_{\\sigma}) = \\sum_{i,j} (K_{\\sigma,ij})^2\n$$\n观察 $\\mathbf{K}_{\\sigma} = \\frac{N}{l} \\begin{bmatrix} \\mathbf{M} & -\\mathbf{M} \\\\ -\\mathbf{M} & \\mathbf{M} \\end{bmatrix}$ 的结构，其 Frobenius 范数的平方为：\n$$\n\\|\\mathbf{K}_{\\sigma}\\|_F^2 = \\left(\\frac{N}{l}\\right)^2 \\left( \\|\\mathbf{M}\\|_F^2 + \\|-\\mathbf{M}\\|_F^2 + \\|-\\mathbf{M}\\|_F^2 + \\|\\mathbf{M}\\|_F^2 \\right) = 4 \\left(\\frac{N}{l}\\right)^2 \\|\\mathbf{M}\\|_F^2\n$$\n让我们计算子矩阵 $\\mathbf{M}$ 的 Frobenius 范数的平方：\n$$\n\\|\\mathbf{M}\\|_F^2 = (t_y^2)^2 + (-t_x t_y)^2 + (-t_x t_y)^2 + (t_x^2)^2 = t_y^4 + t_x^2 t_y^2 + t_x^2 t_y^2 + t_x^4\n$$\n$$\n\\|\\mathbf{M}\\|_F^2 = t_y^2(t_y^2 + t_x^2) + t_x^2(t_y^2 + t_x^2) = (t_y^2 + t_x^2)(t_x^2 + t_y^2) = (1)(1) = 1\n$$\n这是因为 $\\mathbf{t}$ 是一个单位向量，所以 $t_x^2+t_y^2=1$。\n将此结果代回，我们得到：\n$$\n\\|\\mathbf{K}_{\\sigma}\\|_F^2 = 4 \\left(\\frac{N}{l}\\right)^2 (1) = 4 \\frac{N^2}{l^2}\n$$\n取平方根得到 Frobenius 范数：\n$$\n\\|\\mathbf{K}_{\\sigma}\\|_F = \\sqrt{4 \\frac{N^2}{l^2}} = 2 \\frac{|N|}{l}\n$$\n问题要求计算 $\\Delta = \\|K_{\\sigma}\\|_F - 2|N|/l$。基于此分析推导，对于任何有效输入，$\\Delta$ 的值必须恒等于零。此计算可作为该恒等式的数值验证，任何非零结果都可归因于浮点表示和算术误差。\n\n### 计算算法\n\n对于每个测试用例，执行以下步骤：\n1.  定义输入参数：$E, A$，初始节点坐标 $\\mathbf{X}_1, \\mathbf{X}_2$，以及当前节点坐标 $\\mathbf{x}_1, \\mathbf{x}_2$。\n2.  计算初始长度 $L_0 = \\|\\mathbf{X}_2 - \\mathbf{X}_1\\|$。\n3.  计算当前长度 $l = \\|\\mathbf{x}_2 - \\mathbf{x}_1\\|$。如果 $l=0$，则单元已坍缩，后续步骤无定义。测试用例避免了这种奇异情况。\n4.  计算轴力 $N = \\frac{EA}{L_0}(l - L_0)$。\n5.  计算当前单位切向量的分量，$t_x = (x_2 - x_1)/l$ 和 $t_y = (y_2 - y_1)/l$。\n6.  使用推导出的公式构建 $4 \\times 4$ 矩阵 $\\mathbf{K}_{\\sigma}$。\n7.  使用数值库函数计算 Frobenius 范数 $\\|\\mathbf{K}_{\\sigma}\\|_F$。\n8.  计算验证标量 $V = 2|N|/l$。\n9.  计算差值 $\\Delta = \\|\\mathbf{K}_{\\sigma}\\|_F - V$。\n10. 存储 $\\Delta$ 的结果值，该值预计在数值上接近于零。\n\n此算法将应用于三个给定的测试用例中的每一个。最终输出将是计算出的 $\\Delta$ 值的列表，并按规定进行四舍五入。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_delta(E, A, X1, X2, x1, x2):\n    \"\"\"\n    Computes the geometric stiffness matrix K_sigma and the verification difference Delta.\n\n    Args:\n        E (float): Young's modulus in Pa.\n        A (float): Cross-sectional area in m^2.\n        X1 (np.ndarray): Initial coordinates of node 1 (2-element array) in m.\n        X2 (np.ndarray): Initial coordinates of node 2 (2-element array) in m.\n        x1 (np.ndarray): Current coordinates of node 1 (2-element array) in m.\n        x2 (np.ndarray): Current coordinates of node 2 (2-element array) in m.\n\n    Returns:\n        float: The scalar difference Delta = ||K_sigma||_F - 2*|N|/l in N/m.\n    \"\"\"\n    # Calculate initial length\n    if not isinstance(X1, np.ndarray): X1 = np.array(X1, dtype=float)\n    if not isinstance(X2, np.ndarray): X2 = np.array(X2, dtype=float)\n    L0 = np.linalg.norm(X2 - X1)\n\n    # Calculate current length\n    if not isinstance(x1, np.ndarray): x1 = np.array(x1, dtype=float)\n    if not isinstance(x2, np.ndarray): x2 = np.array(x2, dtype=float)\n    dx = x2 - x1\n    l = np.linalg.norm(dx)\n\n    # Handle the case of zero current length to avoid division by zero\n    if l == 0.0:\n        # If length is zero, N is based on L0, K_sigma would be singular.\n        # As per problem context, this case is not expected.\n        # But for robustness, we can define N and state K_sigma is undefined.\n        # Here we assume it implies zero stiffness contribution.\n        return 0.0\n\n    # Calculate axial force N\n    N = (E * A / L0) * (l - L0)\n\n    # Calculate current unit tangent vector t\n    t = dx / l\n    tx, ty = t[0], t[1]\n\n    # Construct the geometric stiffness matrix K_sigma\n    # Submatrix M = [[ty^2, -tx*ty], [-tx*ty, tx^2]]\n    M = np.array([\n        [ty**2, -tx * ty],\n        [-tx * ty, tx**2]\n    ])\n    \n    # K_sigma = (N / l) * [[M, -M], [-M, M]]\n    K_sigma = (N / l) * np.block([\n        [M, -M],\n        [-M, M]\n    ])\n    \n    # Compute the Frobenius norm of K_sigma\n    norm_K_sigma = np.linalg.norm(K_sigma, 'fro')\n    \n    # Compute the verification scalar 2*|N|/l\n    verification_scalar = 2.0 * abs(N) / l\n    \n    # Compute the difference Delta\n    delta = norm_K_sigma - verification_scalar\n    \n    return delta\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases, printing the results in the required format.\n    \"\"\"\n    # Case A: Rigid rotation, zero extension\n    theta_A = np.pi / 3.0\n    L0_A = 1.0\n    case_A = {\n        \"E\": 2.10e11, \"A\": 3.0e-4,\n        \"X1\": (0.0, 0.0), \"X2\": (1.0, 0.0),\n        \"x1\": (0.0, 0.0), \"x2\": (L0_A * np.cos(theta_A), L0_A * np.sin(theta_A))\n    }\n\n    # Case B: Pure axial tension, no rotation\n    case_B = {\n        \"E\": 7.0e10, \"A\": 1.2e-4,\n        \"X1\": (0.0, 0.0), \"X2\": (2.0, 0.0),\n        \"x1\": (0.0, 0.0), \"x2\": (2.02, 0.0)\n    }\n\n    # Case C: Large rotation with compression\n    L0_C = 1.5\n    delta_len_C = -0.01\n    l_C = L0_C + delta_len_C\n    theta_C = 1.74532925199433  # 100 degrees\n    case_C = {\n        \"E\": 2.00e11, \"A\": 2.5e-4,\n        \"X1\": (0.0, 0.0), \"X2\": (1.5, 0.0),\n        \"x1\": (0.0, 0.0), \"x2\": (l_C * np.cos(theta_C), l_C * np.sin(theta_C))\n    }\n\n    test_cases = [case_A, case_B, case_C]\n    \n    results = []\n    for case in test_cases:\n        delta_val = compute_delta(\n            case[\"E\"], case[\"A\"],\n            case[\"X1\"], case[\"X2\"],\n            case[\"x1\"], case[\"x2\"]\n        )\n        results.append(delta_val)\n\n    # Format the final output string as required\n    formatted_results = [f\"{res:.9f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the solver\nsolve()\n```", "id": "2411426"}, {"introduction": "这项综合性练习将材料非线性与几何非线性结合到一个更复杂的工程问题中。我们将模拟一个刚性球体压入一个柔软的超弹性材料块，这种情况在生物力学和软体机器人等领域非常常见。在这个问题中，材料的非线性应力-应变响应（超弹性）和结构的大变形（几何非线性与接触）都至关重要。您将构建一个完整的数值求解过程，包括使用牛顿法求解非线性方程和进行数值积分，从而将前面学到的基本概念应用于一个真实的接触力学问题。[@problem_id:2411424]", "problem": "考虑一个刚性球形压头对一个软超弹性块的轴对称压痕问题。该块体被建模为一组独立的垂直超弹性柱（一种具有非线性材料响应的 Winkler 型地基），初始高度为 $H$，并处于侧向无牵引力的条件下。一个半径为 $R$ 的刚性球体以压痕深度 $\\delta$ 压入其顶面。假设接触是无摩擦的、加载是准静态的，并且材料是可压缩的 neo-Hookean 固体，其剪切模量为 $\\mu$，体积模量为 $\\kappa$。所有量必须以国际单位制（SI）表示：长度单位为米，力单位为牛顿，模量单位为帕斯卡。角度（如有）必须以弧度为单位。\n\n基本建模要素：\n1. 可压缩 neo-Hookean 超弹性的运动学和本构法则。设主拉伸为 $\\lambda_1$、$\\lambda_2$、$\\lambda_3$，左 Cauchy-Green 张量为 $\\mathbf{B} = \\mathrm{diag}(\\lambda_1^2,\\lambda_2^2,\\lambda_3^2)$，体积比为 $J = \\lambda_1 \\lambda_2 \\lambda_3$。使用标准的等容-体积分离，可压缩 neo-Hookean 材料的 Cauchy 应力为\n$$\n\\boldsymbol{\\sigma} = \\frac{\\mu}{J}\\,\\mathrm{dev}(\\mathbf{B}) + \\kappa\\,(J-1)\\,\\mathbf{I},\n$$\n其中 $\\mathrm{dev}(\\mathbf{B}) = \\mathbf{B} - \\tfrac{1}{3}\\mathrm{tr}(\\mathbf{B})\\,\\mathbf{I}$ 且 $\\mathbf{I}$ 是单位张量。\n2. 具有侧向无牵引力条件的柱体的单轴压缩。在局部垂直压缩下，假设主拉伸为 $\\lambda_1=\\lambda_2=\\lambda_t$（侧向）和 $\\lambda_3=\\lambda_z$（垂直）。无牵引力的侧向边界强制使侧向 Cauchy 应力为零，\n$$\n\\sigma_t(\\lambda_t,\\lambda_z) = \\frac{\\mu}{J}\\,\\frac{1}{3}\\left(\\lambda_t^2 - \\lambda_z^2\\right) + \\kappa\\,(J-1) = 0,\\quad J = \\lambda_t^2 \\lambda_z.\n$$\n相应的垂直 Cauchy 应力为\n$$\n\\sigma_z(\\lambda_t,\\lambda_z) = \\frac{2\\mu}{3J}\\left(\\lambda_z^2 - \\lambda_t^2\\right) + \\kappa\\,(J-1).\n$$\n3. 压痕几何形状。对于一个以深度 $\\delta$ 压入平面 $z=0$ 的刚性球体，相对于未变形平面的精确表面轮廓为\n$$\nw(r) = \\delta - \\left( R - \\sqrt{R^2 - r^2} \\right),\\quad 0 \\le r \\le a,\\quad a = \\sqrt{2R\\delta - \\delta^2},\n$$\n其中 $r$ 是径向坐标，$a$ 是接触半径（在 $0&lt;\\delta&lt;2R$ 时有效）。在 Winkler 柱假设下，局部垂直拉伸为\n$$\n\\lambda_z(r) = \\frac{H - w(r)}{H},\n$$\n且接触压力是垂直 Cauchy 应力的压缩部分，\n$$\np(r) = \\max\\left( 0,\\,-\\sigma_z\\big(\\lambda_t(r),\\lambda_z(r)\\big) \\right),\n$$\n其中 $\\lambda_t(r)$ 是对每个 $r$ 求解侧向无牵引力条件 $\\sigma_t(\\lambda_t(r),\\lambda_z(r))=0$ 的解。\n4. 总力。总力是接触压力的轴对称积分，\n$$\nF(\\delta) = 2\\pi \\int_0^{a} p(r)\\, r\\, dr.\n$$\n\n任务：\n从上述基本原理出发，推导一个数值算法。对于给定的 $(R,H,\\mu,\\kappa)$ 和一组压痕深度，该算法通过以下步骤计算 $F(\\delta)$：\n- 在每个径向位置上，使用从本构方程推导的牛顿法求解关于 $\\lambda_t$ 的标量非线性方程 $\\sigma_t(\\lambda_t,\\lambda_z)=0$，并采用物理上可接受的初始猜测和步长控制来维持 $\\lambda_t&gt;0$。\n- 计算 $\\sigma_z$ 进而得到 $p(r)$。\n- 使用一个可靠的复合求积法则在 $[0,a]$ 上对 $2\\pi p(r) r$ 进行数值求积。\n- 确保 $0 &lt; \\delta &lt; H$，从而使接触区域内的 $\\lambda_z(r)&gt;0$。\n\n数值细节：\n- 实现用于求解 $\\sigma_t(\\lambda_t,\\lambda_z)=0$ 的牛顿法，其导数 $\\tfrac{\\partial \\sigma_t}{\\partial \\lambda_t}$ 根据上述公式进行解析计算。\n- 对径向积分使用具有偶数个子区间的复合辛普森法则。选择一个固定的子区间数量，以确保所有测试用例的合理精度，并在代码中记录该选择。\n\n测试套件：\n对于以下每种情况，计算每个所列压痕深度下的力。所有输入均采用国际单位制，力必须以牛顿为单位返回。确保对于所有情况，$0&lt;\\delta&lt;H$ 且 $0&lt;\\delta&lt;2R$。\n\n- 情况 1（理想路径，近不可压缩的软橡胶）：$R=5.0\\times 10^{-3}$，$H=1.0\\times 10^{-2}$，$\\mu=1.0\\times 10^{4}$，$\\kappa=1.0\\times 10^{6}$，$\\delta \\in \\{1.0\\times 10^{-4},\\,3.0\\times 10^{-4},\\,7.0\\times 10^{-4}\\}$。\n- 情况 2（小压痕边界检查）：$R=1.0\\times 10^{-2}$，$H=1.0\\times 10^{-2}$，$\\mu=5.0\\times 10^{3}$，$\\kappa=5.0\\times 10^{5}$，$\\delta \\in \\{1.0\\times 10^{-6},\\,5.0\\times 10^{-6},\\,1.0\\times 10^{-5}\\}$。\n- 情况 3（更可压缩的材料）：$R=5.0\\times 10^{-3}$，$H=5.0\\times 10^{-3}$，$\\mu=2.0\\times 10^{4}$，$\\kappa=1.0\\times 10^{5}$，$\\delta \\in \\{1.0\\times 10^{-4},\\,4.0\\times 10^{-4},\\,8.0\\times 10^{-4}\\}$。\n- 情况 4（更薄的块体）：$R=3.0\\times 10^{-3}$，$H=1.0\\times 10^{-3}$，$\\mu=1.5\\times 10^{4}$，$\\kappa=1.5\\times 10^{6}$，$\\delta \\in \\{1.0\\times 10^{-4},\\,3.0\\times 10^{-4},\\,5.0\\times 10^{-4}\\}$。\n\n最终输出格式：\n您的程序必须生成单行输出，包含一个由四个子列表组成的列表，每个子列表对应一种情况，其中包含以牛顿为单位、四舍五入到六位小数的指定压痕深度下的力。格式必须严格如下：\n[[F11,F12,F13],[F21,F22,F23],[F31,F32,F33],[F41,F42,F43]]\n其中，$Fij$ 表示情况 $i$ 在第 $j$ 个压痕深度下的力，每个力都是以牛顿为单位、小数点后保留六位的小数。", "solution": "该问题陈述已经过严格验证，被认为是计算固体力学中一个有效且适定的问题。它基于 Winkler 地基假设，概述了一个用于描述刚性球体与超弹性块之间轴对称接触的简化但一致的模型。所有物理参数、本构法则和几何约束都已明确定义，从而可以得到唯一的数值解。我们现在将构建此解。\n\n目标是为一组给定的参数 $(R, H, \\mu, \\kappa)$ 和压痕深度 $\\delta$ 计算总压痕力 $F(\\delta)$。问题的核心在于确定压头下的局部压力分布 $p(r)$，这需要在接触区域 $0 \\le r \\le a$ 内的每个径向位置 $r$ 处求解一个非线性材料本构方程。\n\n首先，我们分析单个垂直柱的状态，假设它处于单轴压缩状态，并具有侧向无牵引力边界。主拉伸为 $\\lambda_1 = \\lambda_2 = \\lambda_t$（横向）和 $\\lambda_3 = \\lambda_z$（轴向）。体积比为 $J = \\lambda_t^2 \\lambda_z$。侧向无牵引力条件 $\\sigma_t=0$ 提供了在给定轴向拉伸 $\\lambda_z$ 下关于 $\\lambda_t$ 的控制方程：\n$$ \\sigma_t(\\lambda_t, \\lambda_z) = \\frac{\\mu}{J}\\,\\frac{1}{3}\\left(\\lambda_t^2 - \\lambda_z^2\\right) + \\kappa\\,(J-1) = 0 $$\n对于固定的 $\\lambda_z$，这是一个关于 $\\lambda_t$ 的标量非线性方程。代入 $J = \\lambda_t^2\\lambda_z$，该方程变为：\n$$ g(\\lambda_t) \\equiv \\frac{\\mu}{3\\lambda_t^2\\lambda_z} (\\lambda_t^2 - \\lambda_z^2) + \\kappa(\\lambda_t^2\\lambda_z - 1) = 0 $$\n为了求解此方程以得到 $\\lambda_t$，我们采用牛顿法，这需要计算 $g(\\lambda_t)$ 相对于 $\\lambda_t$ 的导数。为简化求导，我们可以将 $g(\\lambda_t)$ 重写为：\n$$ g(\\lambda_t) = \\frac{\\mu}{3\\lambda_z}(1 - \\lambda_z^2 \\lambda_t^{-2}) + \\kappa(\\lambda_t^2\\lambda_z - 1) $$\n其导数 $g'(\\lambda_t) = \\frac{\\partial \\sigma_t}{\\partial \\lambda_t}$ 则为：\n$$ g'(\\lambda_t) = \\frac{\\mu}{3\\lambda_z} ( - \\lambda_z^2 (-2) \\lambda_t^{-3}) + \\kappa(2\\lambda_t \\lambda_z) = \\frac{2\\mu\\lambda_z}{3\\lambda_t^3} + 2\\kappa\\lambda_z\\lambda_t $$\n鉴于材料参数 $\\mu$ 和 $\\kappa$ 为正，且对于任何物理上有意义的变形 $\\lambda_t&gt;0$ 和 $\\lambda_z&gt;0$，导数 $g'(\\lambda_t)$ 严格为正。这证明了 $g(\\lambda_t)$ 是 $\\lambda_t$ 的单调递增函数，保证了唯一正根的存在。因此，Newton-Raphson 迭代公式为：\n$$ \\lambda_{t,k+1} = \\lambda_{t,k} - \\frac{g(\\lambda_{t,k})}{g'(\\lambda_{t,k})} $$\n一个合适的初始猜测 $\\lambda_{t,0}$ 可从不可压缩极限（$\\kappa \\to \\infty$）推导得出，该极限强制 $J=1$。这得出 $\\lambda_{t,0}^2 \\lambda_z = 1$，所以 $\\lambda_{t,0} = 1/\\sqrt{\\lambda_z}$。这是一个物理上合理的起始点。为确保鲁棒性，必须使用步长控制来防止更新产生非物理的负值 $\\lambda_t$。\n\n一旦找到侧向拉伸 $\\lambda_t(r)$，就可以计算出相应的轴向 Cauchy 应力 $\\sigma_z(r)$。$\\sigma_z$ 的表达式为：\n$$ \\sigma_z(\\lambda_t,\\lambda_z) = \\frac{2\\mu}{3J}\\left(\\lambda_z^2 - \\lambda_t^2\\right) + \\kappa\\,(J-1) $$\n我们可以利用 $\\lambda_t$ 满足 $\\sigma_t=0$ 这一事实来简化此表达式。从 $\\sigma_t=0$ 的条件，我们有 $\\kappa(J-1) = -\\frac{\\mu}{3J}(\\lambda_t^2-\\lambda_z^2) = \\frac{\\mu}{3J}(\\lambda_z^2-\\lambda_t^2)$。将此代入 $\\sigma_z$ 的方程：\n$$ \\sigma_z = \\frac{2\\mu}{3J}(\\lambda_z^2 - \\lambda_t^2) + \\frac{\\mu}{3J}(\\lambda_z^2 - \\lambda_t^2) = \\frac{\\mu}{J}(\\lambda_z^2 - \\lambda_t^2) $$\n这个简化的公式在计算上更高效、更稳定。接触压力则为 $p(r) = \\max(0, -\\sigma_z(r))$。\n\n计算总力 $F(\\delta)$ 的整体数值算法如下：\n1.  对于给定的压痕深度 $\\delta$ 和球体半径 $R$，计算接触半径 $a = \\sqrt{2R\\delta - \\delta^2}$。\n2.  将径向域 $[0, a]$ 离散为偶数个子区间 $N$，创建一组 $N+1$ 个径向点 $r_i$，其中 $i=0, 1, \\dots, N$。\n3.  对于每个点 $r_i$：\n    a. 根据压头几何形状确定局部垂直位移：$w(r_i) = \\delta - (R - \\sqrt{R^2 - r_i^2})$。\n    b. 计算局部轴向拉伸：$\\lambda_z(r_i) = (H - w(r_i)) / H$。条件 $\\delta &lt; H$ 确保了 $\\lambda_z(r_i) &gt; 0$。\n    c. 使用上文概述的 Newton-Raphson 方案求解非线性方程 $g(\\lambda_t) = 0$ 以得到局部横向拉伸 $\\lambda_t(r_i)$。\n    d. 使用简化表达式 $\\sigma_z = (\\mu/J)(\\lambda_z^2 - \\lambda_t^2)$ 计算轴向应力 $\\sigma_z(r_i)$。\n    e. 计算接触压力 $p(r_i) = \\max(0, -\\sigma_z(r_i))$。\n    f. 计算用于力计算的被积函数：$f(r_i) = 2\\pi r_i p(r_i)$。\n4.  通过在计算出的值 $f(r_i)$ 上使用复合辛普森法则，对函数 $f(r)$ 在 $[0, a]$ 上进行数值积分，以计算总力 $F(\\delta)$：\n$$ F(\\delta) = \\int_0^a 2\\pi r p(r) dr \\approx \\frac{h}{3} \\left(f(r_0) + 4\\sum_{j=1}^{N/2} f(r_{2j-1}) + 2\\sum_{j=1}^{N/2-1} f(r_{2j}) + f(r_N)\\right) $$\n其中 $h=a/N$ 是步长。该过程对所有指定的 $\\delta$ 值以及每组材料和几何参数重复进行。在实现时，使用一个可靠的库函数来执行复合辛普森法则是合适的。我们选择 $N=1000$ 个子区间以获得足够的精度。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import simpson\n\ndef solve():\n    \"\"\"\n    Solves the hyperelastic indentation problem for the given test suite.\n    \"\"\"\n    \n    # Constants for the numerical methods\n    NEWTON_TOL = 1e-9\n    NEWTON_MAX_ITER = 20\n    NUM_SUBINTERVALS = 1000  # Must be an even number for Simpson's rule implementation\n\n    def solve_lambda_t(lambda_z, mu, kappa):\n        \"\"\"\n        Solves for the transverse stretch lambda_t using Newton's method.\n        The equation to solve is sigma_t(lambda_t, lambda_z) = 0.\n        \"\"\"\n        # Initial guess from the incompressible case (J=1)\n        if lambda_z <= 0:\n            return np.nan\n        lambda_t = 1.0 / np.sqrt(lambda_z)\n\n        for _ in range(NEWTON_MAX_ITER):\n            # Function g(lambda_t) corresponds to sigma_t\n            J = lambda_t**2 * lambda_z\n            # This form avoids potential floating point issues with very large/small J\n            g = (mu / (3.0 * lambda_z)) * (1.0 - lambda_z**2 / lambda_t**2) + kappa * (J - 1.0)\n\n            if abs(g) < NEWTON_TOL:\n                return lambda_t\n\n            # Derivative g'(lambda_t) = d(sigma_t)/d(lambda_t)\n            dg_dlt = (2.0 * mu * lambda_z) / (3.0 * lambda_t**3) + 2.0 * kappa * lambda_z * lambda_t\n            \n            if dg_dlt == 0: # Avoid division by zero\n                return np.nan\n\n            # Newton step with basic line search for robustness\n            step = g / dg_dlt\n            alpha = 1.0\n            lambda_t_new = lambda_t - alpha * step\n            \n            # Ensure next iterate is physically admissible (lambda_t > 0)\n            while lambda_t_new <= 0:\n                alpha /= 2.0\n                lambda_t_new = lambda_t - alpha * step\n                if alpha < 1e-8: # Line search failed\n                    return np.nan\n            \n            lambda_t = lambda_t_new\n\n        # Return best effort if max iterations are reached, check final residual\n        J = lambda_t**2 * lambda_z\n        g = (mu / (3.0 * lambda_z)) * (1.0 - lambda_z**2 / lambda_t**2) + kappa * (J - 1.0)\n        if abs(g) < 1e-6: # Looser tolerance for convergence at max_iter\n            return lambda_t\n        else:\n            return np.nan\n\n    def calculate_force(R, H, mu, kappa, delta):\n        \"\"\"\n        Calculates the total indentation force for a given set of parameters.\n        \"\"\"\n        # Problem constraints must be met\n        if not (0.0 < delta < 2.0 * R and 0.0 < delta < H):\n            return 0.0\n\n        # Contact radius\n        a = np.sqrt(2.0 * R * delta - delta**2)\n\n        # Radial points for numerical integration\n        num_points = NUM_SUBINTERVALS + 1\n        r_vals = np.linspace(0, a, num_points)\n        \n        integrand = np.zeros(num_points)\n\n        for i, ri in enumerate(r_vals):\n            # At r=0, the integrand 2*pi*r*p(r) is zero\n            if ri == 0:\n                integrand[i] = 0.0\n                continue\n            \n            # Indentation profile w(r)\n            w_r = delta - (R - np.sqrt(R**2 - ri**2))\n            \n            # Axial stretch lambda_z\n            lambda_z_r = (H - w_r) / H\n            \n            if lambda_z_r <= 0:\n                # This should not occur given delta < H\n                pressure = 0.0\n            else:\n                # Solve for transverse stretch lambda_t\n                lambda_t_r = solve_lambda_t(lambda_z_r, mu, kappa)\n                \n                if np.isnan(lambda_t_r):\n                    # If Newton solver fails, assume no pressure develops at this point\n                    pressure = 0.0\n                else:\n                    # Calculate axial stress sigma_z using the simplified formula\n                    J_r = lambda_t_r**2 * lambda_z_r\n                    sigma_z_r = (mu / J_r) * (lambda_z_r**2 - lambda_t_r**2)\n                    \n                    # Contact pressure (compressive stress is negative)\n                    pressure = max(0.0, -sigma_z_r)\n\n            integrand[i] = 2.0 * np.pi * ri * pressure\n            \n        # Integrate using Scipy's composite Simpson's rule implementation\n        force = simpson(integrand, r_vals)\n        \n        return force\n\n    # Test suite provided in the problem description\n    test_cases = [\n        {'R': 5.0e-3, 'H': 1.0e-2, 'mu': 1.0e4, 'kappa': 1.0e6, 'deltas': [1.0e-4, 3.0e-4, 7.0e-4]},\n        {'R': 1.0e-2, 'H': 1.0e-2, 'mu': 5.0e3, 'kappa': 5.0e5, 'deltas': [1.0e-6, 5.0e-6, 1.0e-5]},\n        {'R': 5.0e-3, 'H': 5.0e-3, 'mu': 2.0e4, 'kappa': 1.0e5, 'deltas': [1.0e-4, 4.0e-4, 8.0e-4]},\n        {'R': 3.0e-3, 'H': 1.0e-3, 'mu': 1.5e4, 'kappa': 1.5e6, 'deltas': [1.0e-4, 3.0e-4, 5.0e-4]}\n    ]\n    \n    all_results = []\n    for case in test_cases:\n        case_results = []\n        for delta in case['deltas']:\n            force = calculate_force(case['R'], case['H'], case['mu'], case['kappa'], delta)\n            # Format to 6 decimal places as required\n            case_results.append(f\"{force:.6f}\")\n        all_results.append(f\"[{','.join(case_results)}]\")\n    \n    # Print the final result in the specified format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2411424"}]}