{"hands_on_practices": [{"introduction": "并行计算中的聚合（collective）操作，如 `MPI_Allreduce`，是许多算法的基石，但它们是如何仅通过基本的点对点通信构建的呢？本练习将指导你使用一种高效的“递归倍增”（recursive doubling）算法，通过一个基于位异或（bitwise XOR）寻址的通信模式来实现这一目标。通过亲手模拟这个过程，你将深入理解如何将复杂的聚合通信分解为简单的步骤，并体会到超立方体（hypercube）网络拓扑的优雅与高效。[@problem_id:2413720]", "problem": "给定一个消息传递接口 (Message Passing Interface, MPI) 的计算模型，该模型仅限于点对点操作。考虑一组含有 $P$ 个逻辑进程的集合，进程编号为 $r \\in \\{0,1,\\dots,P-1\\}$，其中 $P$ 是 $2$ 的幂。每个进程 $r$ 初始持有一个整数值 $x_r$。这些进程以同步轮次的方式执行，轮次由 $k \\in \\{0,1,\\dots,R-1\\}$ 索引，其中 $R=\\log_2 P$。在每一轮 $k$ 中，进程 $r$ 被允许执行恰好一次点对点发送和一次点对点接收。在第 $k$ 轮中，进程 $r$ 允许的通信伙伴是进程 $r \\oplus 2^k$，其中 $\\oplus$ 表示按位异或。第 $k$ 轮的通信定义如下：进程 $r$ 必须将其当前整数发送给进程 $r \\oplus 2^k$，并从进程 $r \\oplus 2^k$ 接收一个整数。在第 $k$ 轮接收完成后，进程 $r$ 必须通过整数加法，将其当前整数与接收到的整数相加来更新其值。\n\n经过 $R$ 轮后，要求每个进程的最终整数值等于全局总和 $S=\\sum_{i=0}^{P-1} x_i$。点对点消息的数量定义为所有进程在所有轮次中发送的总次数。在上述约束下，总轮数为 $R=\\log_2 P$，且每一轮恰好发生 $P$ 次发送，因此预期的消息总数为 $P \\log_2 P$。\n\n您的任务是编写一个完整的程序，该程序完全按照所述内容模拟上述模型，并为下面测试套件中的每个测试用例返回一个布尔值。该布尔值为真的条件是当且仅当以下两个条件同时成立：(i) 在最后一轮之后，每个进程都持有正确的最终整数值 $S$；(ii) 点对点消息的总数等于 $P \\log_2 P$。否则，为该测试用例返回假。\n\n测试套件:\n- 用例 A：$P=1$，初始值为 $[42]$。预期 $R=\\log_2 1=0$ 轮和 $P \\log_2 P = 1 \\cdot 0 = 0$ 条消息。\n- 用例 B：$P=2$，初始值为 $[5,-3]$。预期 $R=\\log_2 2 = 1$ 轮和 $P \\log_2 P = 2 \\cdot 1 = 2$ 条消息。\n- 用例 C：$P=4$，初始值为 $[-10,20,0,5]$。预期 $R=\\log_2 4 = 2$ 轮和 $P \\log_2 P = 4 \\cdot 2 = 8$ 条消息。\n- 用例 D：$P=8$，初始值为 $[1,2,3,4,5,6,7,8]$。预期 $R=\\log_2 8 = 3$ 轮和 $P \\log_2 P = 8 \\cdot 3 = 24$ 条消息。\n\n最终输出格式:\n您的程序应生成一行输出，其中包含四个测试用例的结果，格式为用方括号括起来的、无空格的、逗号分隔的布尔值列表，并按 A、B、C、D 的顺序排列。例如，如果所有四个条件都满足，则输出单行“[True,True,True,True]”。", "solution": "问题陈述已经过严格验证，并被认定为有效。\n\n**步骤 1：提取已知条件**\n\n- 一组包含 $P$ 个逻辑进程的集合，进程编号为 $r \\in \\{0, 1, \\dots, P-1\\}$。\n- $P$ 是 $2$ 的幂。\n- 每个进程 $r$ 拥有一个初始整数值 $x_r$。\n- 模拟以同步轮次进行，轮次由 $k \\in \\{0, 1, \\dots, R-1\\}$ 索引，其中 $R=\\log_2 P$。\n- 在每一轮 $k$ 中，进程 $r$ 向进程 $r \\oplus 2^k$ 执行一次发送，并从其接收一次，其中 $\\oplus$ 是按位异或运算符。\n- 在第 $k$ 轮接收到一个值后，进程 $r$ 的更新规则是将其当前整数与接收到的整数相加。\n- 最终条件要求在 $R$ 轮后，每个进程 $r$ 持有的值都等于全局总和 $S=\\sum_{i=0}^{P-1} x_i$。\n- 点对点消息的数量是所有进程在所有轮次中发送的总次数。预期总数为 $P \\log_2 P$。\n- 任务是为每个测试用例返回一个布尔值，该值为真的条件是当且仅当最终值条件和消息总数条件都满足。\n- 测试用例：\n  - A：$P=1$，初始值 $[42]$。\n  - B：$P=2$，初始值 $[5,-3]$。\n  - C：$P=4$，初始值 $[-10,20,0,5]$。\n  - D：$P=8$，初始值 $[1,2,3,4,5,6,7,8]$。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n- **科学依据**：该问题描述了一种众所周知的并行算法，具体来说是超立方体拓扑上的一种全归约 (all-reduce) 操作。进程及其编号可以看作是一个 $d$ 维超立方体的顶点，其中 $d = \\log_2 P$。通信伙伴规则 $r \\leftrightarrow r \\oplus 2^k$ 定义了沿此超立方体第 $k$ 维的通信。指定的更新规则是基于前缀和的全归约操作的标准流程。该问题在科学上和算法上都是合理的。\n- **良构性**：初始状态、通信规则和更新规则都是确定性的。对于任何给定的输入，系统的最终状态是唯一的。验证标准是客观且可量化的。\n- **完整性与一致性**：问题是自洽的。所有必要的参数（$P$、初始值）和规则都已提供。定义是精确的。$P=1$ 的特殊情况意味着 $R=\\log_2 1 = 0$ 轮和 $P \\log_2 P = 0$ 条消息，这在数学上是一致的，并且可以通过零次迭代的循环正确处理。没有矛盾之处。\n\n**步骤 3：结论与行动**\n\n问题是有效的。这是一个良构的、有科学依据的问题，要求对一个标准并行算法进行模拟和验证。将提供一个解决方案。\n\n**解决方案设计**\n\n该问题要求对所描述的消息传递模型进行直接模拟。解决方案的核心是在 $R = \\log_2 P$ 个同步轮次中，精确地对 $P$ 个进程的状态进行建模。\n\n系统在任何时刻的状态都可以用一个包含 $P$ 个整数的向量（数组）来表示，我们可以将其记为 $\\mathbf{x}$。初始时，该向量为 $\\mathbf{x}[0] = [x_0, x_1, \\dots, x_{P-1}]$。\n\n模拟对从 $0$ 到 $R-1$ 的每一轮 $k$ 进行迭代。同步模型的一个关键方面是，一轮中的所有通信都基于该轮开始时的状态。因此，更新不能“原地”应用，因为这会产生数据竞争，即一个进程可能会使用在同一轮中已经被更新过的值。为防止这种情况，需要一个临时缓冲区或第二个向量（比如 $\\mathbf{x}'$）来存储当前轮次的计算结果。\n\n对于每一轮 $k \\in \\{0, 1, \\dots, R-1\\}$：\n1. 初始化一个临时向量 $\\mathbf{x}'$ 以存放下一轮的值。\n2. 对于每个进程 $r \\in \\{0, 1, \\dots, P-1\\}$：\n   a. 识别通信伙伴：$p = r \\oplus 2^k$。\n   b. 进程 $r$ 从进程 $p$ 接收到的值是 $p$ 在该轮开始时持有的值，即 $x_p[k]$。\n   c. 根据更新规则计算进程 $r$ 的新值：$x'_r = x_r[k] + x_p[k]$。\n3. 在所有进程都更新完毕后，下一轮的状态 $\\mathbf{x}[k+1]$ 被设置为计算出的临时向量 $\\mathbf{x}'$。\n\n这个迭代过程重复 $R = \\log_2 P$ 轮。\n\n点对点消息的总数也会被跟踪。在 $R$ 轮中的每一轮， $P$ 个进程中的每一个都执行恰好一次发送操作。因此，每一轮都会为总数贡献 $P$ 条消息。经过 $R$ 轮，消息总数为 $P \\times R = P \\log_2 P$，这与问题中陈述的预期相符。\n\n在所有 $R$ 轮完成后，必须验证两个条件：\n1. **最终值条件**：每个进程中的最终值 $x_r[R]$ 必须等于全局总和 $S = \\sum_{i=0}^{P-1} x_i[0]$。此项检查通过从初始值计算 $S$ 并将其与最终状态向量 $\\mathbf{x}[R]$ 的每个元素进行比较来执行。\n2. **消息计数条件**：累积的消息总数必须等于理论值 $P \\log_2 P$。\n\n一个测试用例评估为真的条件是当且仅当两个条件都满足。将实现该模拟，以对每个提供的测试用例进行运行。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates a message passing model and verifies the outcome against specified conditions.\n    \"\"\"\n    test_cases = [\n        # Case A\n        (1, [42]),\n        # Case B\n        (2, [5, -3]),\n        # Case C\n        (4, [-10, 20, 0, 5]),\n        # Case D\n        (8, [1, 2, 3, 4, 5, 6, 7, 8]),\n    ]\n    \n    results = []\n\n    for case in test_cases:\n        P, initial_x = case\n        \n        # Use 64-bit integers to avoid overflow with large sums, although\n        # Python's native integers have arbitrary precision. Numpy is used\n        # for convenience and adherence to problem constraints.\n        values = np.array(initial_x, dtype=np.int64)\n        \n        # Calculate the number of rounds, R = log2(P).\n        # For P=1, log2(1)=0, so R=0 rounds.\n        # This is safe because P is guaranteed to be a power of 2.\n        R = 0\n        if P > 1:\n            R = int(np.log2(P))\n\n        total_messages = 0\n        \n        # Simulate R synchronous rounds.\n        for k in range(R):\n            # A temporary array is necessary to store the results of the synchronous round\n            # to prevent data races (i.e., using a value updated in the same round).\n            next_values = np.zeros_like(values)\n            \n            for r in range(P):\n                # Determine the communication partner in round k.\n                # The partner is r XOR 2^k. (1 << k) is a fast way to compute 2^k.\n                partner = r ^ (1 << k)\n                \n                # Each process r sends its current value to its partner and receives\n                # the partner's value. The new value is the sum of its own old value\n                # and the received value.\n                # Note: values[partner] refers to the value at the start of the round.\n                received_value = values[partner]\n                next_values[r] = values[r] + received_value\n            \n            # After all processes compute their next value, update the state for the next round.\n            values = next_values\n            \n            # In each round, P processes each perform one send.\n            total_messages += P\n\n        # --- Verification ---\n\n        # Condition 1: Verify all processes hold the correct global sum.\n        expected_sum = np.sum(np.array(initial_x, dtype=np.int64))\n        final_values_correct = np.all(values == expected_sum)\n        \n        # Condition 2: Verify the total number of messages.\n        expected_messages = P * R\n        message_count_correct = (total_messages == expected_messages)\n        \n        # The result is True if and only if both conditions are met.\n        result = final_values_correct and message_count_correct\n        results.append(result)\n\n    # Format the final output as specified: a comma-separated list of booleans.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2413720"}, {"introduction": "在掌握了如何构建基本通信模块后，我们来看看如何利用消息传递来组织实际的并行应用。本练习将引导你通过离散事件模拟，构建经典的“主从（Master-Worker）”计算模型，并评估其性能。你将亲手处理任务分发、非阻塞通信以及结果回收的过程，并分析网络延迟 $L$ 和带宽 $B$ 如何共同决定总完成时间（makespan）。[@problem_id:2413700] 这个实践将理论与应用相结合，让你学会如何对并行计算系统的性能进行建模与预测。", "problem": "实现一个主/从计算模式的离散事件模拟，以研究消息传递和通信模式。主节点使用非阻塞发送方式将独立任务分配给一个固定的工作节点池。每个任务包含一个从主节点到工作节点的请求消息、在工作节点上的一次计算，以及一个从工作节点返回主节点的结果消息。主节点的发送操作不会阻塞；它可以在同一模拟时间瞬间发布多个发送请求。工作节点一次最多处理一个任务，并在完成计算后立即变为空闲状态；发送结果消息不会延迟工作节点的可用性。您的目标是计算一组给定场景的总完成时间 (makespan)。\n\n基本原理与假设：\n- 使用消息传递系统（如消息传递接口 MPI）中的标准定义。特别地，非阻塞发送会立即将控制权返回给调用者，而无需等待消息传输完成。我们使用一个固定的延迟和一个带宽项来模拟网络传输时间。\n- 设 $L$ 为单向延迟（秒），$B$ 为带宽（字节/秒），$s$ 为消息大小（字节）。单向传输时间为\n$$\nT(s) = L + \\frac{s}{B},\n$$\n我们约定，若 $B = \\infty$，则 $\\frac{s}{B} = 0$。\n- 对于每个任务 $i$，其工作节点计算时间为 $c_i$（秒），在计算前有一个从主节点发往工作节点的大小为 $s_\\mathrm{req}$ 的请求消息，计算后有一个从工作节点发往主节点的大小为 $s_\\mathrm{resp}$ 的结果消息。因此，如果一个任务在时间 $t$ 被分配给一个工作节点，它将在时间 $t + T(s_\\mathrm{req})$ 开始计算，并在时间 $t + T(s_\\mathrm{req}) + c_i$ 完成计算。其结果将在时间 $t + T(s_\\mathrm{req}) + c_i + T(s_\\mathrm{resp})$ 到达主节点。\n- 主节点使用非阻塞发送。一旦一个工作节点变为空闲且有待处理的任务，主节点就在那个确切的模拟时间向该工作节点发布一个发送请求。该发送操作不会阻塞主节点，分配时间即为工作节点变为空闲的时刻。工作节点的可用性不会因发送其结果而延迟，因为假设工作节点的发送是非阻塞的。\n- 工作节点一次最多处理一个任务。主节点在时间 $t=0$ 开始，最多分配 $\\min(W, N)$ 个任务，其中 $W$ 是工作节点数量， $N$ 是任务数量。任务不可被抢占。\n\n需要计算的量：\n- 对于每个场景，计算其 makespan $T_\\mathrm{end}$，定义为主节点接收到最后一个结果消息的时间。形式上，\n$$\nT_\\mathrm{end} = \\max_{i=1,\\dots,N} \\left( t_i^\\mathrm{assign} + T(s_\\mathrm{req}) + c_i + T(s_\\mathrm{resp}) \\right),\n$$\n其中 $t_i^\\mathrm{assign}$ 是主节点将任务 $i$ 分配给某个工作节点的时间（由上述事件驱动的调度决定）。\n\n算法要求：\n- 基于上述定义实现一个离散事件模拟。一个正确且高效的方法是使用一个优先队列来模拟工作节点的可用性，该队列以每个工作节点的下一个计算完成时间为键，在工作节点变为空闲的确切时刻发布新的分配。您不得依赖任何外部库来进行消息传递；这是一个纯粹的模拟。\n\n单位与数值规范：\n- 所有时间必须以秒为单位表示。\n- 所有消息大小必须以字节为单位表示。\n- 所有带宽必须以字节/秒为单位表示。\n- 您的程序必须输出每个 makespan（单位为秒），并四舍五入到六位小数。\n\n测试套件：\n对于每个测试用例，指定 $(W, \\{c_i\\}, L, B, s_\\mathrm{req}, s_\\mathrm{resp})$ 并计算 $T_\\mathrm{end}$。\n\n- 测试 1 (一般情况):\n  - $W = 3$\n  - $\\{c_i\\} = [2.0, 3.0, 7.0, 1.0, 4.0]$ (秒)\n  - $L = 0.1$ (秒)\n  - $B = 10^6$ (字节/秒)\n  - $s_\\mathrm{req} = 1000$ (字节)\n  - $s_\\mathrm{resp} = 1000$ (字节)\n- 测试 2 (零通信成本的边界情况):\n  - $W = 1$\n  - $\\{c_i\\} = [1.0, 2.0, 3.0]$ (秒)\n  - $L = 0.0$ (秒)\n  - $B = \\infty$ (字节/秒)\n  - $s_\\mathrm{req} = 100$ (字节)\n  - $s_\\mathrm{resp} = 100$ (字节)\n- 测试 3 (延迟主导的微任务):\n  - $W = 2$\n  - $\\{c_i\\} = [0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05]$ (秒)\n  - $L = 0.2$ (秒)\n  - $B = 10^6$ (字节/秒)\n  - $s_\\mathrm{req} = 100$ (字节)\n  - $s_\\mathrm{resp} = 100$ (字节)\n- 测试 4 (工作节点多，任务少):\n  - $W = 10$\n  - $\\{c_i\\} = [5.0, 1.0, 2.0]$ (秒)\n  - $L = 0.05$ (秒)\n  - $B = 10^6$ (字节/秒)\n  - $s_\\mathrm{req} = 500$ (字节)\n  - $s_\\mathrm{resp} = 500$ (字节)\n- 测试 5 (带宽主导的消息):\n  - $W = 4$\n  - $\\{c_i\\} = [0.5, 1.5, 0.7, 2.0, 1.2, 0.3, 0.9]$ (秒)\n  - $L = 0.02$ (秒)\n  - $B = 2 \\times 10^3$ (字节/秒)\n  - $s_\\mathrm{req} = 4000$ (字节)\n  - $s_\\mathrm{resp} = 8000$ (字节)\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含与五个测试相对应的五个 makespan，格式为逗号分隔的列表并用方括号括起，例如 `[x_1, x_2, x_3, x_4, x_5]`，其中每个 $x_k$ 是以秒为单位、四舍五入到六位小数的 makespan。\n- 您的程序必须是自包含的，不得读取任何输入，也不得访问外部文件或网络。", "solution": "所提出的问题是计算系统建模中一个有效且定义明确的练习。它是一个主/从并行计算模式的标准表述，基于离散事件模拟和网络性能建模的基本原理。参数定义清晰，目标函数明确指定，调度策略是确定性的，这保证了唯一解的存在。该问题提供了一套具体的测试用例以供验证。我们将基于这些原理进行求解。\n\n系统动态由事件控制，特别是工作节点完成计算这一事件。这使得离散事件模拟成为自然且正确的方法。我们通过跟踪每个工作节点的可用性以及待调度任务的队列来对系统状态进行建模。管理工作节点可用性的最有效方法是使用优先队列，其中每个事件的优先级是其时间戳。\n\n设 $W$ 为工作节点数量， $N$ 为任务数量。任务 $i$ 的计算时间为 $c_i$。网络的特征是单向延迟 $L$ 和带宽 $B$。大小为 $s$ 的消息的单向传输时间由线性模型 $T(s) = L + s/B$ 给出。可以理解，如果 $B = \\infty$，则 $s/B$ 项为 $0$。\n\n由此，我们定义请求传输时间 $T_\\mathrm{req} = T(s_\\mathrm{req})$ 和响应传输时间 $T_\\mathrm{resp} = T(s_\\mathrm{resp})$。\n\n一个在时间 $t_\\mathrm{assign}$ 分配的任务将在时间 $t_\\mathrm{assign} + T_\\mathrm{req}$ 在工作节点上开始计算。计算本身需要 $c_i$ 秒。因此，工作节点在时间 $t_\\mathrm{finish\\_compute} = t_\\mathrm{assign} + T_\\mathrm{req} + c_i$ 完成计算。完成计算后，该工作节点立即可以被分配新任务。然后发送结果消息，在时间 $t_\\mathrm{result\\_arrival} = t_\\mathrm{finish\\_compute} + T_\\mathrm{resp}$ 到达主节点。总体目标是找到 makespan $T_\\mathrm{end}$，即主节点接收到最后一个结果消息的时间：\n$$\nT_\\mathrm{end} = \\max_{i=1,\\dots,N} \\{t_\\mathrm{result\\_arrival}^{(i)}\\}\n$$\n其中 $t_\\mathrm{result\\_arrival}^{(i)}$ 是任务 $i$ 的结果到达时间。\n\n我们模拟的核心是一个优先队列，我们称之为 `worker_events`。这个数据结构将存储对应于工作节点完成其计算的事件。队列中的每个元素将是一个元组 $(t, w)$，表示工作节点 $w$ 将在时间 $t$ 完成其当前计算。优先队列按时间 $t$ 排序，因此我们总能高效地检索到下一个变为空闲的工作节点。\n\n模拟过程如下：\n\n1.  **初始化**：\n    *   初始化一个变量 `makespan` 为 $0$。\n    *   初始化一个未分配任务的队列，按其给定的顺序排列。设 `next_task_idx` 為要分配的下一个任务的索引。\n    *   在模拟时间 $t=0$ 时，主节点分配前 $\\min(W, N)$ 个任务。对于这些初始任务中的每一个 $i \\in \\{0, 1, \\dots, \\min(W, N)-1\\}$，分配给工作节点 $i$：\n        *   分配时间为 $t_i^\\mathrm{assign} = 0$。\n        *   计算完成时间为 $t_{i}^\\mathrm{finish\\_compute} = 0 + T_\\mathrm{req} + c_i$。\n        *   将事件 $(t_{i}^\\mathrm{finish\\_compute}, i)$ 推入 `worker_events` 优先队列。\n        *   结果到达时间为 $t_{i}^\\mathrm{result\\_arrival} = t_{i}^\\mathrm{finish\\_compute} + T_\\mathrm{resp}$。\n        *   更新 `makespan` = $\\max(\\text{makespan}, t_{i}^\\mathrm{result\\_arrival})$。\n    *   设置 `next_task_idx` 为 $\\min(W, N)$。\n\n2.  **模拟循环**：\n    *   只要还有待分配的任务（即 `next_task_idx` < $N$），此循环就继续。\n    *   从 `worker_events` 中提取时间最小的事件。这会得到 $(t_\\mathrm{finish}, w_\\mathrm{free})$，即工作节点 $w_\\mathrm{free}$ 变为空闲的时间。\n    *   问题规定，新任务在该工作节点变为空闲的确切时刻被分配。因此，下一个任务（设其索引为 $j = \\text{next\\_task\\_idx}$）的分配时间为 $t_j^\\mathrm{assign} = t_\\mathrm{finish}$。\n    *   将这个新任务 $j$ 调度到工作节点 $w_\\mathrm{free}$ 上：\n        *   该工作节点新的计算完成时间为 $t_{j}^\\mathrm{finish\\_compute} = t_j^\\mathrm{assign} + T_\\mathrm{req} + c_j$。\n        *   将新事件 $(t_{j}^\\mathrm{finish\\_compute}, w_\\mathrm{free})$ 推入 `worker_events` 优先队列。\n        *   任务 $j$ 的结果到达时间为 $t_{j}^\\mathrm{result\\_arrival} = t_{j}^\\mathrm{finish\\_compute} + T_\\mathrm{resp}$。\n        *   更新 `makespan` = $\\max(\\text{makespan}, t_{j}^\\mathrm{result\\_arrival})$。\n    *   递增 `next_task_idx`。\n\n3.  **终止**：\n    *   当 `next_task_idx` 达到 $N$ 时，循环终止，意味着所有任务都已调度。`makespan` 变量所持有的最终值是所有结果到达时间的最大值，这正是 $T_\\mathrm{end}$ 的定义。\n\n该算法正确地模拟了指定的系统，并将被实现以解决给定的测试用例。Python的`heapq`模块提供了合适的最小优先队列实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    # Test cases defined as tuples:\n    # (W, {c_i}, L, B, s_req, s_resp)\n    test_cases = [\n        # Test 1 (general case)\n        (3, [2.0, 3.0, 7.0, 1.0, 4.0], 0.1, 1e6, 1000, 1000),\n        # Test 2 (boundary with zero communication cost)\n        (1, [1.0, 2.0, 3.0], 0.0, np.inf, 100, 100),\n        # Test 3 (latency-dominated micro-tasks)\n        (2, [0.05] * 10, 0.2, 1e6, 100, 100),\n        # Test 4 (many workers, few tasks)\n        (10, [5.0, 1.0, 2.0], 0.05, 1e6, 500, 500),\n        # Test 5 (bandwidth-dominated messages)\n        (4, [0.5, 1.5, 0.7, 2.0, 1.2, 0.3, 0.9], 0.02, 2e3, 4000, 8000),\n    ]\n\n    results = []\n    for case in test_cases:\n        makespan = simulate_master_worker(*case)\n        results.append(f\"{makespan:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef simulate_master_worker(W, c_tasks, L, B, s_req, s_resp):\n    \"\"\"\n    Implements a discrete-event simulation of a master/worker computation.\n\n    Args:\n        W (int): Number of workers.\n        c_tasks (list[float]): List of compute times for each task.\n        L (float): One-way network latency in seconds.\n        B (float): Network bandwidth in bytes per second.\n        s_req (float): Request message size in bytes.\n        s_resp (float): Response message size in bytes.\n\n    Returns:\n        float: The total completion time (makespan) in seconds.\n    \"\"\"\n    num_tasks = len(c_tasks)\n    if num_tasks == 0:\n        return 0.0\n\n    # Calculate one-way transfer times for request and response messages\n    if B == np.inf:\n        t_req = L\n        t_resp = L\n    else:\n        t_req = L + s_req / B\n        t_resp = L + s_resp / B\n\n    # Priority queue stores events of workers finishing computation.\n    # Each item is a tuple: (finish_compute_time, worker_id).\n    worker_events = []\n    \n    # Track the overall makespan (time last result is received by master).\n    makespan = 0.0\n    \n    # Index for the next task to be assigned from the c_tasks list.\n    next_task_idx = 0\n\n    # Initial phase: Assign tasks to all available workers at time t=0.\n    num_initial_tasks = min(W, num_tasks)\n    for i in range(num_initial_tasks):\n        c_i = c_tasks[i]\n        worker_id = i\n        \n        # Assignment time is 0 for the initial batch of tasks.\n        t_assign = 0.0\n        \n        # A worker finishes its computation at t_assign + network_delay + compute_time.\n        finish_compute_time = t_assign + t_req + c_i\n        \n        # The result for this task arrives at the master after the response message is sent.\n        result_arrival_time = finish_compute_time + t_resp\n        \n        # Update the makespan with the latest result arrival.\n        makespan = max(makespan, result_arrival_time)\n        \n        # Add a \"worker free\" event to the priority queue.\n        heapq.heappush(worker_events, (finish_compute_time, worker_id))\n        \n        next_task_idx += 1\n\n    # Main simulation loop: process events until all tasks are assigned.\n    while next_task_idx < num_tasks:\n        # Get the next worker to become free from the priority queue.\n        # This event defines the current simulation time for the new assignment.\n        finish_compute_time, worker_id = heapq.heappop(worker_events)\n        \n        # The worker becomes free at finish_compute_time. This is the assignment\n        # time for the next task scheduled on this worker.\n        t_assign = finish_compute_time\n        \n        # Get the compute time for the next task in the queue.\n        c_i = c_tasks[next_task_idx]\n        \n        # Schedule the new task on the now-free worker.\n        new_finish_compute_time = t_assign + t_req + c_i\n        new_result_arrival_time = new_finish_compute_time + t_resp\n        \n        # Update the overall makespan.\n        makespan = max(makespan, new_result_arrival_time)\n        \n        # Add the new event for this worker finishing its new task.\n        heapq.heappush(worker_events, (new_finish_compute_time, worker_id))\n        \n        next_task_idx += 1\n        \n    return makespan\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2413700"}, {"introduction": "高效的通信是并行的基础，但当进程因争夺有限资源而陷入相互等待的困境时，系统便会发生“死锁（deadlock）”。本练习让你直面这一并行编程中的关键挑战，通过模拟一个环形通信场景，你将观察到阻塞式（blocking）收发操作和有限的系统缓冲区 $S$ 是如何导致灾难性系统停滞的。你的任务不仅仅是观察死锁的发生，更需要从第一性原理出发，分析并计算出确保系统无死锁运行所需的最小缓冲区大小 $S_{\\text{fix}}$。[@problem_id:2413727] 通过这个实践，你将深刻理解并行系统中的资源依赖与循环等待问题，掌握设计稳健通信协议的核心要点。", "problem": "考虑一个离散、确定性的模拟，其中包含$n$个排列在单向环形结构中的顺序进程，它们之间进行阻塞式消息传递。每个进程都按固定顺序精确地执行两个操作：(i) 向其后继进程阻塞式发送一条大小为$m$字节的单条消息，然后 (ii) 从其前驱进程阻塞式接收一条大小为$m$字节的单条消息。进程$i$的后继是$(i+1)\\bmod n$，前驱是$(i-1)\\bmod n$。所有发送操作共享一个大小为$S$字节的全局系统缓冲池。当且仅当全局缓冲池中当前至少有$m$字节可用时，发送操作才会成功；如果成功，它会将消息放入目标进程的收件箱，并从缓冲池中消耗正好$m$字节。当且仅当接收方的收件箱中当前至少包含一条消息时，接收操作才会成功；成功后，它会移除该消息并将$m$字节返还给全局缓冲池。所有信道都是可靠且无损的。没有进程会改变其操作顺序，也没有进程会执行任何其他操作。\n\n将死锁定义为这样一种状态：至少有一个进程尚未完成，且在当前全局缓冲区使用情况和收件箱内容的条件下，没有进程能够完成其下一步操作。模拟通过对进程$0,1,\\dots,n-1,0,1,\\dots$进行重复的确定性轮询扫描来进行。在每次扫描中，每个进程都尝试执行其当前操作；如果操作的条件未满足，则该进程在本次尝试中保持在该操作上阻塞。当所有进程都完成了两个操作，或者在至少一个进程尚未完成的情况下，整整一次扫描没有任何操作成功（即死锁），模拟即告终止。\n\n任务：编写一个完整的程序，完全按照上述规范模拟此系统。对于下面的每个测试用例，运行模拟两次：\n- 首先，使用提供的元组$(n,m,S)$进行模拟，并记录模拟是否以死锁告终（死锁记录为布尔值$true$，否则为$false$）。\n- 其次，在不改变发送/接收顺序或轮询调度的情况下，将$S$替换为能保证此工作负载下不发生死锁的最小全局缓冲池大小$S_{\\text{fix}}$（以字节为单位），并记录在此修复配置下模拟是否以死锁告终。你必须从第一性原理出发确定$S_{\\text{fix}}$。\n\n所有字节量均按字面意义解释为字节。本问题中没有其他单位。你的程序必须生成单行输出，其中包含一个以逗号分隔的布尔值列表，并用方括号括起来，顺序如下所述。对于每个测试用例，按测试用例列出的相同顺序，将布尔值对$[b_{\\text{orig}},b_{\\text{fix}}]$扁平化为单个列表输出。\n\n测试套件（每个元组为$(n,m,S)$，所有量均以字节为单位）：\n- $(2,10,10)$\n- $(2,10,20)$\n- $(3,8,8)$\n- $(4,8,15)$\n- $(5,7,35)$\n\n因此，所要求的单行输出必须包含对应这5个测试用例的10个布尔值，每个测试用例按规定顺序贡献2个布尔值。输出格式必须严格为单行：\n\"[b1,b2,b3,b4,b5,b6,b7,b8,b9,b10]\"\n其中每个$b_i$是\"True\"或\"False\"。", "solution": "对问题陈述进行验证。\n\n步骤1：提取已知条件\n- 进程数量：$n$。\n- 进程排列在单向环形结构中，索引为$i \\in \\{0, 1, \\dots, n-1\\}$。\n- 进程$i$的后继是$(i+1)\\bmod n$。\n- 进程$i$的前驱是$(i-1)\\bmod n$。\n- 每个进程按顺序执行两个固定操作：(i) 阻塞式发送，然后 (ii) 阻塞式接收。\n- 消息大小：$m$字节。\n- 全局系统缓冲池大小：$S$字节。\n- 发送操作条件：如果可用缓冲区至少有$m$字节，则成功。成功时，从缓冲池中消耗$m$字节。\n- 接收操作条件：如果接收方的收件箱中至少有一条消息，则成功。成功时，向缓冲池返还$m$字节。\n- 模拟调度：对进程$0, 1, \\dots, n-1$进行确定性轮询扫描。\n- 死锁定义：至少有一个进程未完成，且整整一次扫描中没有任何操作成功的状态。\n- 终止条件：(i) 所有进程完成两个操作，或 (ii) 发生死锁。\n- 任务：对于每个给定的元组$(n,m,S)$：\n    1.  用$(n,m,S)$进行模拟，并记录死锁状态$b_{\\text{orig}}$。\n    2.  确定不会导致死锁的最小缓冲池大小$S_{\\text{fix}}$。\n    3.  用$(n,m,S_{\\text{fix}})$进行模拟，并记录死锁状态$b_{\\text{fix}}$。\n- 测试套件：$(2,10,10)$、$(2,10,20)$、$(3,8,8)$、$(4,8,15)$、$(5,7,35)$。\n\n步骤2：使用提取的已知条件进行验证\n- **具有科学依据**：该问题描述了并发系统中的一个典型资源分配场景，具体是为通信死锁建模。该模型是计算机科学和计算工程中一个公认的抽象。它在科学上是合理的。\n- **定义明确**：系统的初始状态是隐式定义的（所有进程都处于`send`阶段，缓冲区容量为$S$，所有收件箱为空）。状态转换规则是确定且无歧义的。终止条件是明确的。对于任何给定的参数集，都存在一个唯一的、有意义的结果。\n- **客观性**：问题使用精确、形式化的语言陈述（如“阻塞式发送”、“确定性轮询”、“当且仅当”）。所有参数都是定量的。不含主观或模棱两可的术语。\n\n所有其他验证标准均已满足。该问题并非不合理、不可形式化、不完整、不切实际、不适定或无法验证。\n\n步骤3：结论与行动\n问题有效。将提供解决方案。\n\n所描述的系统是一个通信顺序进程的离散时间模拟。这个问题的关键在于可能发生死锁，即对共享资源的循环依赖。这里的资源是全局缓冲空间和消息本身。我们必须首先分析导致死锁的条件，以确定保证不发生死锁的最小缓冲池大小$S_{\\text{fix}}$。然后，我们构建一个模拟程序来验证给定测试用例的行为。\n\n让我们来分析系统动态。每个进程$i$的状态可以是以下三种之一：`SEND`（发送）、`RECEIVE`（接收）或`DONE`（完成）。最初，所有$n$个进程都处于`SEND`状态，缓冲区拥有$S$字节，所有消息收件箱都为空。模拟以扫描的方式进行，进程$0, 1, \\dots, n-1$依次尝试其操作。\n\n当且仅当系统达到一个状态，其中没有进程可以继续进行，但并非所有进程都处于`DONE`状态时，就会发生死锁。如果缓冲区字节数少于$m$，进程会在`SEND`上阻塞。如果收件箱为空，进程会在`RECEIVE`上阻塞。\n\n考虑初始的几次扫描。在第一次扫描中，所有进程都尝试发送。设$k_{\\max}$为在缓冲区耗尽前能够相继发送的最大进程数。一个`SEND`操作消耗$m$字节，因此$k_{\\max}$次成功发送消耗$k_{\\max} \\cdot m$字节。如果$S \\ge k_{\\max} \\cdot m$，这是可能的。第$(k_{\\max}+1)$个进程会因为$S - k_{\\max} \\cdot m < m$而失败。因此，$k_{\\max} = \\lfloor S/m \\rfloor$。为使问题不至于无意义，我们假设$S \\ge m$且$n \\ge 2$。因此，$k_{\\max} \\ge 1$。\n\n在基于轮询调度$0, 1, \\dots, n-1$的第一轮发送尝试之后：\n- 进程$0, 1, \\dots, k_{\\max}-1$成功发送并转换到`RECEIVE`状态。\n- 进程$k_{\\max}, \\dots, n-1$发送失败并保持在`SEND`状态阻塞。\n- 缓冲区大小减少到$S' = S - k_{\\max} \\cdot m$。根据$k_{\\max}$的定义，我们有$S' < m$。\n- 对于$i \\in \\{1, \\dots, k_{\\max}\\}$中的每个进程$i$，其收件箱包含一条消息。其他收件箱为空。\n\n现在，考虑下一次扫描。\n- 任何进程$j \\in \\{k_{\\max}, \\dots, n-1\\}$都在`SEND`上阻塞，因为缓冲区大小$S'$小于$m$。\n- 如果一个进程$i \\in \\{0, \\dots, k_{\\max}-1\\}$的收件箱为空，它将在`RECEIVE`上阻塞。这意味着它的前驱进程$(i-1) \\bmod n$尚未成功发送消息。\n- 让我们检查处于`RECEIVE`状态的进程：\n    - 进程$0$正在等待来自进程$n-1$的消息。如果$k_{\\max} < n$，那么进程$n-1$在`SEND`上阻塞。因此，进程$0$在`RECEIVE`上阻塞。\n    - 进程$i \\in \\{1, \\dots, k_{\\max}-1\\}$正在等待来自进程$i-1$的消息。在第一次扫描中，进程$i-1$成功发送了一条消息。因此，进程$i$的收件箱不为空。进程$i$可以成功接收。\n\n如果没有进程可以取得进展，就会发生死锁。处于`SEND`阻塞的进程无法前进。处于`RECEIVE`阻塞的进程只有在它们中至少有一个可以接收时才能前进。如分析所示，进程$1, \\dots, k_{\\max}-1$能够接收。当且仅当这个可接收进程集合为空时，才会发生死锁。\n集合$\\{1, \\dots, k_{\\max}-1\\}$为空的条件是$k_{\\max}-1 < 1$，简化为$k_{\\max} < 2$。由于我们假设$S \\ge m$，所以$k_{\\max}$必须至少为$1$。因此，如果$k_{\\max} = 1$，则必然发生死锁。\n\n条件$k_{\\max} = 1$等价于$1 \\le S/m < 2$，即$m \\le S < 2m$。在这种情况下，只有进程$0$发送消息。然后它会阻塞以等待来自进程$n-1$的消息。所有其他进程$1, \\dots, n-1$都因缓冲区不足而在`SEND`上阻塞。没有进程可以前进，系统陷入死锁。\n\n为了保证不发生死锁，我们必须确保避免这种情况。我们必须有$k_{\\max} \\ge 2$。这要求$S/m \\ge 2$，即$S \\ge 2m$。如果$S \\ge 2m$，那么至少进程$0$和$1$可以发送。在下一次扫描中，进程$1$可以接收，这会向缓冲区返还$m$字节。这可能会让进程$2$（如果它被阻塞了）能够发送，从而引发一连串的解锁事件，最终使得所有进程都能完成。\n\n因此，对于任意数量的进程$n \\ge 2$，保证不发生死锁的最小全局缓冲池大小是$S_{\\text{fix}} = 2m$。\n\n该程序将实现对系统的直接模拟。对于每个测试用例$(n, m, S)$，它将首先使用提供的$S$运行模拟以找到$b_{\\text{orig}}$。然后，它将计算$S_{\\text{fix}} = 2m$并使用该值再次运行模拟以找到$b_{\\text{fix}}$。模拟函数将维护每个进程的状态、每个收件箱的内容以及可用的缓冲池大小，执行扫描直至达到终止状态（所有进程`DONE`或死锁）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef simulate(n, m, S):\n    \"\"\"\n    Simulates the message passing system as described.\n\n    Args:\n        n (int): Number of processes.\n        m (int): Message size in bytes.\n        S (int): Global buffer size in bytes.\n\n    Returns:\n        bool: True if deadlock occurs, False otherwise.\n    \"\"\"\n    # States: 0=SEND, 1=RECEIVE, 2=DONE\n    process_states = [0] * n\n    inboxes = [[] for _ in range(n)]\n    buffer_size = S\n    \n    # Handle the trivial case where no process can ever send.\n    if S < m:\n        return True\n\n    while True:\n        num_done = sum(1 for state in process_states if state == 2)\n        if num_done == n:\n            return False  # Success, all processes are done\n\n        progress_in_sweep = False\n        for i in range(n):\n            state = process_states[i]\n\n            if state == 0:  # SEND\n                if buffer_size >= m:\n                    buffer_size -= m\n                    successor = (i + 1) % n\n                    inboxes[successor].append(1)  # Message content is irrelevant\n                    process_states[i] = 1\n                    progress_in_sweep = True\n            \n            elif state == 1:  # RECEIVE\n                if len(inboxes[i]) > 0:\n                    inboxes[i].pop(0)\n                    buffer_size += m\n                    process_states[i] = 2\n                    progress_in_sweep = True\n        \n        if not progress_in_sweep:\n            # If no progress was made, check if we are done or deadlocked.\n            # The check for all_done is at the start of the loop.\n            # So if we are here with no progress, it must be a deadlock.\n            return True  # Deadlock\n\ndef solve():\n    \"\"\"\n    Runs the simulation for all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # (n, m, S)\n        (2, 10, 10),\n        (2, 10, 20),\n        (3, 8, 8),\n        (4, 8, 15),\n        (5, 7, 35),\n    ]\n\n    results = []\n    for n, m, S in test_cases:\n        # Run original simulation\n        b_orig = simulate(n, m, S)\n        results.append(b_orig)\n\n        # Determine S_fix and run fixed simulation\n        # As derived, the minimal buffer size to avoid deadlock for n >= 2\n        # is 2*m, as this ensures at least two processes can send,\n        # allowing the second one to eventually receive and replenish the buffer.\n        S_fix = 2 * m\n        b_fix = simulate(n, m, S_fix)\n        results.append(b_fix)\n\n    # Format output as a single line: \"[True,False,True,...]\"\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2413727"}]}