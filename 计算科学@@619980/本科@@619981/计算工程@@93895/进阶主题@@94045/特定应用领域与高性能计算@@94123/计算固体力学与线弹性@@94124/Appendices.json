{"hands_on_practices": [{"introduction": "在工程分析中，应力张量 $\\boldsymbol{\\sigma}$ 提供了某一点上应力状态的完整描述。然而，为了评估材料失效或确定关键的载荷路径，我们常常需要找出最大拉应力和压应力，即主应力。本实践将指导你完成从给定的柯西应力张量中提取主应力方向的基本计算任务 [@problem_id:2378068]。通过实现特征值分解，你将获得处理模拟数据以揭示物理上有意义的洞察力的实践经验。", "problem": "给定一个三维（$3$D）实体部件在静态载荷作用下，其选定点上的一组对称 Cauchy 应力张量。每个应力状态由一个实对称 $3\\times 3$ 矩阵 $\\boldsymbol{\\sigma}$ 表示，其元素单位为帕斯卡（Pa）。对于每个应力张量，确定第一主应力方向，该方向定义为与最大主应力相关联的单位向量 $\\boldsymbol{v}_{1} \\in \\mathbb{R}^{3}$。第一主应力方向 $\\boldsymbol{v}_{1}$ 是这样一个方向，在该方向上，单位法向量为 $\\boldsymbol{n}=\\boldsymbol{v}_{1}$ 的平面上的面力矢量与 $\\boldsymbol{n}$ 共线，并且相应的标量面力（主应力）在所有此类方向中是最大的。\n\n请遵循以下约定，以确保报告的方向是唯一的：\n- 将方向归一化，使其欧几里得范数为1。\n- 为固定其符号，设 $\\tau = 10^{-12}$。在 $(v_x, v_y, v_z)$ 中找到第一个绝对值超过 $\\tau$ 的分量；如果该分量为负，则将整个向量乘以 $-1$。如果没有分量的绝对值超过 $\\tau$（对于非零单位向量，这种情况不可能发生），则报告 $[1,0,0]$。\n\n将每个方向报告为其笛卡尔分量 $[v_x, v_y, v_z]$ 的列表，每个分量四舍五入到六位小数。这些分量是无量纲的。\n\n测试套件（每个张量以帕斯卡（Pa）为单位给出；条目为精确值）：\n- 情况 $1$：\n  $\\boldsymbol{\\sigma}_{1}=\\begin{bmatrix}\n  1.20\\times 10^{8} & 3.0\\times 10^{7} & 0.0\\\\\n  3.0\\times 10^{7} & 8.0\\times 10^{7} & 1.0\\times 10^{7}\\\\\n  0.0 & 1.0\\times 10^{7} & 6.0\\times 10^{7}\n  \\end{bmatrix}$\n- 情况 $2$：\n  $\\boldsymbol{\\sigma}_{2}=\\begin{bmatrix}\n  5.0\\times 10^{7} & 0.0 & 0.0\\\\\n  0.0 & 2.0\\times 10^{8} & 0.0\\\\\n  0.0 & 0.0 & 1.0\\times 10^{8}\n  \\end{bmatrix}$\n- 情况 $3$：\n  $\\boldsymbol{\\sigma}_{3}=\\begin{bmatrix}\n  0.0 & 5.0\\times 10^{7} & 0.0\\\\\n  5.0\\times 10^{7} & 0.0 & 0.0\\\\\n  0.0 & 0.0 & -1.0\\times 10^{7}\n  \\end{bmatrix}$\n- 情况 $4$：\n  $\\boldsymbol{\\sigma}_{4}=\\begin{bmatrix}\n  1.01\\times 10^{8} & 1.0\\times 10^{6} & 2.0\\times 10^{6}\\\\\n  1.0\\times 10^{6} & 1.00\\times 10^{8} & 1.5\\times 10^{6}\\\\\n  2.0\\times 10^{6} & 1.5\\times 10^{6} & 1.02\\times 10^{8}\n  \\end{bmatrix}$\n- 情况 $5$：\n  $\\boldsymbol{\\sigma}_{5}=\\begin{bmatrix}\n  -1.00\\times 10^{8} & 0.0 & 0.0\\\\\n  0.0 & -5.0\\times 10^{7} & 0.0\\\\\n  0.0 & 0.0 & -7.5\\times 10^{7}\n  \\end{bmatrix}$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个条目本身都是一个对应测试用例的、用方括号括起来的三元组，并且没有空格。例如，一个有效的格式是 `[[0.577350,0.577350,0.577350],[...]]`。", "solution": "对所述问题进行验证。\n\n**步骤 1：提取已知条件**\n- 问题背景设定在 $3$D 实体力学中。\n- 输入为一组对称 $3 \\times 3$ Cauchy 应力张量 $\\boldsymbol{\\sigma}$，其元素为实数，单位是帕斯卡（Pa）。\n- 任务是为每个张量找到第一主应力方向 $\\boldsymbol{v}_{1} \\in \\mathbb{R}^{3}$。\n- 第一主应力方向被定义为与最大主应力相关联的单位特征向量。\n- 规定了一个唯一性约定：\n    1. 向量 $\\boldsymbol{v}_{1}$ 必须被归一化为单位欧几里得范数。\n    2. 给出了一个符号固定规则：设容差 $\\tau = 10^{-12}$，找到向量 $(v_x, v_y, v_z)$ 中第一个绝对值超过 $\\tau$ 的分量。如果此分量为负，则整个向量必须乘以 $-1$。\n- 每个方向的输出是其笛卡尔分量的列表 $[v_x, v_y, v_z]$，每个分量四舍五入到六位小数。\n- 提供了五个具体的应力张量 $\\boldsymbol{\\sigma}_{1}$ 至 $\\boldsymbol{\\sigma}_{5}$ 作为测试用例。\n\n**步骤 2：验证已知条件**\n根据验证标准对问题进行评估：\n- **科学依据充分：** 该问题是线性弹性力学和连续介质力学中的一个基础练习。Cauchy 应力张量、其对称性、主应力和主方向都是核心且完善的概念。该问题在科学上是合理的。\n- **适定性：** 对于任何实对称矩阵，例如应力张量 $\\boldsymbol{\\sigma}$，都存在实数特征值（主应力）和一组相应的正交特征向量（主方向）。问题要求找到与最大特征值相关联的方向。由于所有提供的测试用例都产生不同的特征值，主方向在符号上是唯一的。所提供的符号固定约定解决了这种模糊性，使得问题是适定的。\n- **客观性：** 问题使用精确的数学语言和定量数据进行表述。确定最终向量的程序是算法性的且明确的。不需要主观解释。\n- **完整性和一致性：** 提供了所有必要的信息，包括应力张量和明确的唯一性规则。问题本身是自洽的，没有矛盾。应力的单位（Pa）和大小对于工程材料来说是物理上合理的。\n\n**步骤 3：结论与行动**\n该问题是有效的，因为它科学依据充分、适定、客观且自洽。将提供一个解决方案。\n\n任务是为给定的 Cauchy 应力张量 $\\boldsymbol{\\sigma}$ 找到第一主方向。这等同于找到矩阵 $\\boldsymbol{\\sigma}$ 的最大特征值对应的特征向量。主应力 $\\sigma_{p}$ 与其对应的主方向 $\\boldsymbol{v}$ 之间的关系由特征值问题定义：\n$$\n\\boldsymbol{\\sigma}\\boldsymbol{v} = \\sigma_{p}\\boldsymbol{v}\n$$\n在这里，$\\sigma_{p}$ 是一个特征值，$\\boldsymbol{v}$ 是 $\\boldsymbol{\\sigma}$ 对应的特征向量。由于根据角动量守恒原理，Cauchy 应力张量是一个对称矩阵（$\\boldsymbol{\\sigma} = \\boldsymbol{\\sigma}^{\\mathsf{T}}$），实对称矩阵的谱定理保证了它有三个实数特征值（主应力 $\\sigma_{1}, \\sigma_{2}, \\sigma_{3}$）和一组三个相互正交的特征向量（主方向 $\\boldsymbol{v}_{1}, \\boldsymbol{v}_{2}, \\boldsymbol{v}_{3}$）。\n\n第一主应力定义为代数值最大的特征值，通常表示为 $\\sigma_{1}$，其中 $\\sigma_{1} \\ge \\sigma_{2} \\ge \\sigma_{3}$。对应的第一主方向是其关联的特征向量 $\\boldsymbol{v}_{1}$。\n\n为每个给定的应力张量求解此问题的计算流程如下：\n首先，我们求解特征值问题。这是数值线性代数中的一个标准任务。我们将使用一个稳健的特征值求解器，例如 Python 的 `NumPy` 库中提供的 `numpy.linalg.eigh` 函数。此函数针对对称（或厄米）矩阵进行了优化，并具有一个方便的特性，即返回按升序排序的特征值。因此，最大特征值 $\\sigma_{1}$ 将是返回的特征值数组中的最后一个元素。相应的特征向量 $\\boldsymbol{v}_{1}$ 将是返回的特征向量矩阵的最后一列。\n\n其次，我们必须遵守问题的唯一性约定。`numpy.linalg.eigh` 函数返回的特征向量已经被归一化为单位欧几里得范数，满足了约定的第一部分。第二部分是符号固定规则。特征向量 $\\boldsymbol{v}$ 与 $-\\boldsymbol{v}$ 是等价的，因为它们都定义了相同的方向（特征空间）。为了确保单一的表示方式，我们应用指定的程序。设计算出的单位特征向量为 $\\boldsymbol{v} = [v_x, v_y, v_z]^{\\mathsf{T}}$，容差为 $\\tau = 10^{-12}$。\n1. 检查第一个分量 $v_x$。如果 $|v_x| > \\tau$，其符号决定整个向量的符号。如果 $v_x  0$，我们将最终向量设置为 $-\\boldsymbol{v}$。否则，我们按原样使用 $\\boldsymbol{v}$。\n2. 如果 $|v_x| \\le \\tau$，我们继续检查第二个分量 $v_y$。如果 $|v_y| > \\tau$，其符号决定方向。如果 $v_y  0$，我们使用 $-\\boldsymbol{v}$。否则，我们使用 $\\boldsymbol{v}$。\n3. 如果 $|v_x| \\le \\tau$ 且 $|v_y| \\le \\tau$，我们检查第三个分量 $v_z$。由于向量具有单位范数，因此 $|v_z|$ 必须大于 $\\tau$。如果 $v_z  0$，我们使用 $-\\boldsymbol{v}$。否则，我们使用 $\\boldsymbol{v}$。\n此程序确保报告的向量是唯一的。\n\n最后，按要求将得到的唯一方向向量的分量四舍五入到六位小数。将此完整过程系统地应用于五个给定的应力张量 $\\boldsymbol{\\sigma}_{1}$ 到 $\\boldsymbol{\\sigma}_{5}$。然后将结果汇总成指定的最终输出格式。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the first principal stress direction for a set of Cauchy stress tensors.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each stress tensor is given in units of Pascal (Pa).\n    test_cases = [\n        # Case 1\n        np.array([\n            [1.20e8, 3.0e7, 0.0],\n            [3.0e7, 8.0e7, 1.0e7],\n            [0.0, 1.0e7, 6.0e7]\n        ]),\n        # Case 2\n        np.array([\n            [5.0e7, 0.0, 0.0],\n            [0.0, 2.0e8, 0.0],\n            [0.0, 0.0, 1.0e8]\n        ]),\n        # Case 3\n        np.array([\n            [0.0, 5.0e7, 0.0],\n            [5.0e7, 0.0, 0.0],\n            [0.0, 0.0, -1.0e7]\n        ]),\n        # Case 4\n        np.array([\n            [1.01e8, 1.0e6, 2.0e6],\n            [1.0e6, 1.00e8, 1.5e6],\n            [2.0e6, 1.5e6, 1.02e8]\n        ]),\n        # Case 5\n        np.array([\n            [-1.00e8, 0.0, 0.0],\n            [0.0, -5.0e7, 0.0],\n            [0.0, 0.0, -7.5e7]\n        ])\n    ]\n\n    results = []\n    tau = 1e-12\n\n    for sigma in test_cases:\n        # For a symmetric matrix sigma, np.linalg.eigh returns eigenvalues in\n        # ascending order and the corresponding normalized eigenvectors as columns\n        # of the returned matrix.\n        eigenvalues, eigenvectors = np.linalg.eigh(sigma)\n\n        # The first principal stress is the maximum eigenvalue.\n        # Its direction is the corresponding eigenvector. Due to the ascending sort,\n        # this is the last column of the eigenvectors matrix.\n        v1 = eigenvectors[:, -1]\n\n        # Apply the uniqueness convention to fix the sign of the direction vector.\n        # The eigenvector is already of unit norm.\n        # Find the first component with an absolute value greater than tau.\n        # If this component is negative, flip the sign of the entire vector.\n        for i in range(3):\n            if abs(v1[i]) > tau:\n                if v1[i]  0:\n                    v1 = -v1\n                break\n        \n        # Format the components by rounding to six decimal places,\n        # ensuring trailing zeros are present.\n        v1_formatted = [f\"{comp:.6f}\" for comp in v1]\n\n        # Assemble the formatted vector into a string representation of a list.\n        result_str = f\"[{','.join(v1_formatted)}]\"\n        results.append(result_str)\n\n    # Print the final list of results in the specified format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2378068"}, {"introduction": "有限元法（FEM）依赖于能够精确表示简单变形状态的单元。“分片检验”（Patch Test）是确保单元公式正确并且能够收敛到正确解的基本检验方法。在这个练习中，你将从第一性原理出发，为一个四节点四边形单元实现分片检验 [@problem_id:2378079]。这项实践对于理解有限元法收敛的条件和建立对任何模拟代码构建模块的信心至关重要。", "problem": "您需要实现一个完整的、可运行的程序，用于在小应变、线弹性、平面应力分析的背景下，检查一个自定义的四节点等参四边形有限元是否通过常应变斑块检验。该程序必须是自包含的，并针对指定的测试套件产生单行输出。其目的是验证该单元能够复现一个仿射位移场，并在数值容差范围内产生恒定的应变。\n\n从适用于计算固体力学的第一性原理开始：\n- 在静态情况下，无体力时线性动量的平衡方程为 $\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{0}$，作用于域 $\\Omega$，其中 $\\boldsymbol{\\sigma}$ 是 Cauchy 应力张量。小应变运动学给出的无穷小应变张量为 $\\boldsymbol{\\varepsilon} = \\frac{1}{2}(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\mathsf{T}})$，其中 $\\mathbf{u}(\\mathbf{x})$ 是位移场。\n- 对于平面应力线弹性问题，每个点的本构关系为 $\\boldsymbol{\\sigma} = \\mathbf{D}\\,\\boldsymbol{\\varepsilon}$，其中 $\\mathbf{D}$ 是由杨氏模量 $E$ 和泊松比 $\\nu$ 定义的对称材料矩阵。\n- 弱形式的 Galerkin 有限元离散化导出了线性系统 $\\mathbf{K}\\mathbf{d} = \\mathbf{f}$，其中 $\\mathbf{K} = \\sum_{e} \\int_{A_e} \\mathbf{B}^{\\mathsf{T}} \\mathbf{D} \\mathbf{B}\\,\\mathrm{d}A$，$\\mathbf{d}$ 是节点位移向量，$\\mathbf{f}$ 是外力向量，$A_e$ 是单元面积，$\\mathbf{B}$ 将节点位移映射到工程应变 $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx},\\,\\varepsilon_{yy},\\,\\gamma_{xy}]^{\\mathsf{T}}$，其中 $\\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}$。映射和积分将使用双线性等参形函数在标准二乘二高斯积分的双单位正方形上进行。\n\n您的程序必须：\n- 实现一个在自然坐标 $(\\xi,\\eta)$ 中使用双线性插值的四节点四边形等参单元，并使用 $2 \\times 2$ 高斯积分，积分点位于 $\\xi,\\eta \\in \\{\\pm 1/\\sqrt{3}\\}$ 且权重为单位权重。必须为每个积分点计算从 $(\\xi,\\eta)$ 到物理坐标 $(x,y)$ 的雅可比映射，以评估 $\\mathbf{B}$ 和 $\\det \\mathbf{J}$。\n- 为每个测试案例的网格组装全局刚度矩阵 $\\mathbf{K}$，并通过在网格的外部边界上指定位移来施加 Dirichlet 边界条件。不存在体力，也不施加 Neumann 边界力。程序应通过识别仅属于一个单元的边，从网格连接性中以算法方式确定外部边界节点。\n- 在计算域的边界上指定一个仿射位移场\n  $$u(x,y) = \\gamma + \\alpha\\,x + \\beta\\,y,\\quad v(x,y) = \\zeta + \\delta\\,x + \\varepsilon\\,y,$$\n  其中 $u$ 和 $v$ 分别是位移的 $x$ 和 $y$ 分量。该场会引起一个常应变\n  $$\\varepsilon_{xx} = \\alpha,\\quad \\varepsilon_{yy} = \\varepsilon,\\quad \\gamma_{xy} = \\beta + \\delta.$$\n  使用常数 $\\alpha = 1.0\\times 10^{-3}, \\beta = -2.0\\times 10^{-4}, \\delta = 3.0\\times 10^{-4}, \\varepsilon = 5.0\\times 10^{-4}, \\gamma = 2.5\\times 10^{-3}, \\zeta = -1.1\\times 10^{-3}$。坐标单位为米，位移必须以米为单位进行计算。\n- 求解线性系统以获得自由自由度的解，并计算：\n  1. 最大绝对节点位移误差\n     $$e_u = \\max_{i}\\, \\left\\lvert d_i - d_i^{\\text{exact}} \\right\\rvert,$$\n     其中 $d_i^{\\text{exact}}$ 是由仿射场得到的精确节点位移。\n  2. 计算出的高斯点工程应变与目标常应变的最大绝对偏差\n     $$e_{\\varepsilon} = \\max_{e,\\,g,\\,k} \\left\\lvert \\varepsilon_{k}^{(e,g)} - \\varepsilon_{k}^{\\text{target}} \\right\\rvert,$$\n     其中 $k \\in \\{xx,yy,xy\\}$，$e$ 是单元索引，$g$ 是高斯点索引。\n- 所有测试案例的材料参数：杨氏模量 $E = 210 \\times 10^{9}$ 帕斯卡和泊松比 $\\nu = 0.30$（平面应力）。虽然指定了物理单位，但要求的输出是无量纲的布尔值。\n\n如果 $e_u \\le 10^{-10}$ 和 $e_{\\varepsilon} \\le 10^{-10}$ 同时成立，则称一个测试案例通过了常应变斑块检验。\n\n测试套件（三个网格；所有坐标单位为米；单元连接性使用从零开始的逆时针顺序的节点索引）：\n- 案例 1（单个扭曲的四边形）：\n  - 节点：\n    - $0$: $(0.0,\\,0.0)$\n    - $1$: $(1.2,\\,0.1)$\n    - $2$: $(1.0,\\,1.1)$\n    - $3$: $(0.1,\\,0.9)$\n  - 单元：\n    - $[0,\\,1,\\,2,\\,3]$\n- 案例 2（单位正方形的 $2 \\times 2$ 网格）：\n  - 节点：\n    - $0$: $(0.0,\\,0.0)$, $1$: $(0.5,\\,0.0)$, $2$: $(1.0,\\,0.0)$\n    - $3$: $(0.0,\\,0.5)$, $4$: $(0.5,\\,0.5)$, $5$: $(1.0,\\,0.5)$\n    - $6$: $(0.0,\\,1.0)$, $7$: $(0.5,\\,1.0)$, $8$: $(1.0,\\,1.0)$\n  - 单元：\n    - $[0,\\,1,\\,4,\\,3]$, $[1,\\,2,\\,5,\\,4]$, $[3,\\,4,\\,7,\\,6]$, $[4,\\,5,\\,8,\\,7]$\n- 案例 3（一个平行四边形被一条内部分割成两个四边形）：\n  - 角点：$\\mathrm{A}=(0.0,\\,0.0)$, $\\mathrm{B}=(2.0,\\,0.3)$, $\\mathrm{C}=(2.2,\\,1.2)$, $\\mathrm{D}=(0.2,\\,0.9)$。\n  - 位于 $\\mathrm{AB}$ 和 $\\mathrm{DC}$ 边中点的附加点：$\\mathrm{M}_{\\mathrm{AB}}=(1.0,\\,0.15)$，$\\mathrm{M}_{\\mathrm{DC}}=(1.2,\\,1.05)$。\n  - 节点：\n    - $0$: $\\mathrm{A}$, $1$: $\\mathrm{M}_{\\mathrm{AB}}$, $2$: $\\mathrm{B}$, $3$: $\\mathrm{D}$, $4$: $\\mathrm{M}_{\\mathrm{DC}}$, $5$: $\\mathrm{C}$\n  - 单元：\n    - $[0,\\,1,\\,4,\\,3]$, $[1,\\,2,\\,5,\\,4]$\n\n您的程序必须为每个测试案例计算通过或失败的布尔值，并生成一个单行输出，其中包含三个结果，形式为用方括号括起来的逗号分隔列表，例如 `[True,False,True]`。不允许有其他输出或文本。布尔值分别反映了三个案例是否同时满足 $e_u \\le 10^{-10}$ 和 $e_{\\varepsilon} \\le 10^{-10}$。\n\n角度单位不适用。如果打印物理量，单位将是国际单位制（SI）；但是，要求的输出是无单位的布尔值。确保数值计算在量纲上保持一致，几何形状使用米，材料刚度使用帕斯卡。程序必须是确定性的，并且不需要任何用户输入。", "solution": "所提出的问题要求为一个四节点等参四边形有限元实现一个被称为常应变斑块检验的验证程序。该检验是计算力学中的一个基本基准，旨在确保有限元列式能够精确地复现一个常应变状态，这是收敛的必要条件。分析是在二维、小应变、线弹性、平面应力理论的框架内进行的。我将首先概述理论基础，然后详细说明实现所需的算法步骤。\n\n问题陈述在科学上是合理且适定的。它提供了所有必要的数据，包括三个不同网格的几何描述、材料属性、一个指定的仿射位移场，以及通过检验的精确标准。这是有限元代码验证中的一个标准问题。\n\n**1. 理论公式**\n\n用于固体力学的有限元法（FEM）的基础在于平衡方程弱形式的离散化。对于一个没有体力的静态问题，虚功原理指出，对于任何运动学上容许的虚位移场 $\\delta\\mathbf{u}$，内虚功必须等于外虚功。在没有体力和域边界上的面力的情况下，这可以简化为：\n$$\n\\int_{\\Omega} \\boldsymbol{\\sigma} : \\delta\\boldsymbol{\\varepsilon} \\, \\mathrm{d}V = 0\n$$\n其中 $\\boldsymbol{\\sigma}$ 是 Cauchy 应力张量，$\\delta\\boldsymbol{\\varepsilon}$ 是对应于 $\\delta\\mathbf{u}$ 的虚应变张量。\n\n**1.1. 等参单元公式**\n\n我们采用一个四节点四边形单元。单元内的几何和位移场都使用同一组形函数从节点值进行插值，因此称为“等参”。该单元在一个具有自然坐标 $(\\xi, \\eta)$ 的双单位正方形父域中定义，其中 $\\xi, \\eta \\in [-1, 1]$。\n\n四个节点 $(i=1, 2, 3, 4)$ 的双线性形函数 $N_i(\\xi, \\eta)$ 为：\n$$\nN_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta) \\quad\\quad N_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)\n$$\n$$\nN_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta) \\quad\\quad N_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)\n$$\n单元内任意点的物理坐标 $(x, y)$ 从自然坐标映射而来：\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i \\quad\\quad y(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i\n$$\n其中 $(x_i, y_i)$ 是单元节点的坐标。\n\n类似地，单元内的位移场 $(u, v)$ 从节点位移 $(u_i, v_i)$ 插值得到：\n$$\nu(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) u_i \\quad\\quad v(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) v_i\n$$\n\n**1.2. 应变-位移关系**\n\n工程应变 $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^{\\mathsf{T}}$ 由位移场的空间导数定义：\n$$\n\\varepsilon_{xx} = \\frac{\\partial u}{\\partial x}, \\quad \\varepsilon_{yy} = \\frac{\\partial v}{\\partial y}, \\quad \\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}\n$$\n为了计算这些导数，我们需要使用链式法则将关于物理坐标 $(x, y)$ 的导数与关于自然坐标 $(\\xi, \\eta)$ 的导数联系起来。这种关系通过雅可比矩阵 $\\mathbf{J}$ 表示：\n$$\n\\begin{Bmatrix} \\frac{\\partial}{\\partial \\xi} \\\\ \\frac{\\partial}{\\partial \\eta} \\end{Bmatrix} = \n\\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta}  \\frac{\\partial y}{\\partial \\eta} \\end{bmatrix}\n\\begin{Bmatrix} \\frac{\\partial}{\\partial x} \\\\ \\frac{\\partial}{\\partial y} \\end{Bmatrix} = \\mathbf{J}\n\\begin{Bmatrix} \\frac{\\partial}{\\partial x} \\\\ \\frac{\\partial}{\\partial y} \\end{Bmatrix}\n$$\n$\\mathbf{J}$ 的分量通过对几何映射进行微分得到，例如 $\\frac{\\partial x}{\\partial \\xi} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\xi} x_i$。对 $\\mathbf{J}$ 求逆可得：\n$$\n\\begin{Bmatrix} \\frac{\\partial}{\\partial x} \\\\ \\frac{\\partial}{\\partial y} \\end{Bmatrix} = \\mathbf{J}^{-1}\n\\begin{Bmatrix} \\frac{\\partial}{\\partial \\xi} \\\\ \\frac{\\partial}{\\partial \\eta} \\end{Bmatrix}\n$$\n现在，应变可以通过应变-位移矩阵 $\\mathbf{B}$ 表示为节点位移 $\\mathbf{d}^e = [u_1, v_1, u_2, v_2, u_3, v_3, u_4, v_4]^{\\mathsf{T}}$ 的函数：\n$$\n\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{d}^e\n$$\n矩阵 $\\mathbf{B}$ 是一个 $3 \\times 8$ 的矩阵，由四个 $3 \\times 2$ 的块组成，$\\mathbf{B} = [\\mathbf{B}_1, \\mathbf{B}_2, \\mathbf{B}_3, \\mathbf{B}_4]$，其中每个块 $\\mathbf{B}_i$ 由下式给出：\n$$\n\\mathbf{B}_i = \n\\begin{bmatrix}\n\\frac{\\partial N_i}{\\partial x}  0 \\\\\n0  \\frac{\\partial N_i}{\\partial y} \\\\\n\\frac{\\partial N_i}{\\partial y}  \\frac{\\partial N_i}{\\partial x}\n\\end{bmatrix}\n$$\n形函数的空间导数，例如 $\\frac{\\partial N_i}{\\partial x}$，是使用雅可比矩阵的逆计算的：\n$$\n\\begin{Bmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{Bmatrix} = \\mathbf{J}^{-1}\n\\begin{Bmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{Bmatrix}\n$$\n\n**1.3. 单元刚度矩阵与系统组装**\n\n单元刚度矩阵 $\\mathbf{K}^e$ 建立了单元的节点力与节点位移之间的关系。它通过将离散公式代入弱形式积分得到：\n$$\n\\mathbf{K}^e = \\int_{A_e} \\mathbf{B}^{\\mathsf{T}} \\mathbf{D} \\mathbf{B} \\, \\mathrm{d}A\n$$\n其中 $A_e$ 是单元面积，$\\mathbf{D}$ 是平面应力问题的材料本构矩阵：\n$$\n\\mathbf{D} = \\frac{E}{1-\\nu^2} \n\\begin{bmatrix} \n1  \\nu  0 \\\\ \n\\nu  1  0 \\\\ \n0  0  \\frac{1-\\nu}{2} \n\\end{bmatrix}\n$$\n其中 $E$ 是杨氏模量，$\\nu$ 是泊松比。\n该积分使用高斯积分进行数值计算。变换到父域：\n$$\n\\mathbf{K}^e = \\int_{-1}^{1} \\int_{-1}^{1} \\mathbf{B}(\\xi, \\eta)^{\\mathsf{T}} \\mathbf{D} \\mathbf{B}(\\xi, \\eta) \\det(\\mathbf{J}(\\xi, \\eta)) \\, \\mathrm{d}\\xi \\mathrm{d}\\eta\n$$\n使用 $2 \\times 2$ 高斯积分，积分点位于 $(\\xi_g, \\eta_g) \\in \\{\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3}\\}$ 且权重为单位权重 $(w_g = 1)$：\n$$\n\\mathbf{K}^e \\approx \\sum_{g=1}^{4} \\mathbf{B}(\\xi_g, \\eta_g)^{\\mathsf{T}} \\mathbf{D} \\mathbf{B}(\\xi_g, \\eta_g) \\det(\\mathbf{J}(\\xi_g, \\eta_g)) w_g\n$$\n整个网格的全局刚度矩阵 $\\mathbf{K}$ 是通过将每个单元刚度矩阵 $\\mathbf{K}^e$ 的贡献组装到相应的全局自由度中形成的。这导致了线性系统 $\\mathbf{K}\\mathbf{d} = \\mathbf{f}$。\n\n**2. 斑块检验程序**\n\n斑块检验验证单元是否能精确表示常应变状态。这是通过在一“块”单元的边界上施加一个对应于常应变场的位移场来实现的。然后计算内部节点的有限元解，并与精确的解析解进行比较。\n\n**2.1. 边界条件与系统求解**\n\n在网格的边界节点上施加一个仿射位移场：\n$$\nu(x,y) = \\gamma + \\alpha x + \\beta y \\quad\\quad v(x,y) = \\zeta + \\delta x + \\varepsilon y\n$$\n该场对应于一个常工程应变状态：\n$$\n\\varepsilon_{xx}^{\\text{target}} = \\alpha, \\quad \\varepsilon_{yy}^{\\text{target}} = \\varepsilon, \\quad \\gamma_{xy}^{\\text{target}} = \\beta + \\delta\n$$\n程序必须首先以算法方式识别边界节点。这可以通过遍历所有单元并计算每个边出现的次数来完成。只属于一个单元的边是边界边，其组成节点是边界节点。\n\n全局系统 $\\mathbf{K}\\mathbf{d} = \\mathbf{f}$ 被划分为自由自由度（DOF）和指定自由度，分别用下标 $f$ 和 $p$ 表示：\n$$\n\\begin{bmatrix} \\mathbf{K}_{ff}  \\mathbf{K}_{fp} \\\\ \\mathbf{K}_{pf}  \\mathbf{K}_{pp} \\end{bmatrix}\n\\begin{Bmatrix} \\mathbf{d}_f \\\\ \\mathbf{d}_p \\end{Bmatrix} =\n\\begin{Bmatrix} \\mathbf{f}_f \\\\ \\mathbf{f}_p \\end{Bmatrix}\n$$\n边界节点的位移 $\\mathbf{d}_p$ 从指定的仿射场中是已知的。由于没有外部节点力，自由自由度的力向量 $\\mathbf{f}_f$ 为零。需求解的未知内部节点位移 $\\mathbf{d}_f$ 的系统为：\n$$\n\\mathbf{K}_{ff} \\mathbf{d}_f = - \\mathbf{K}_{fp} \\mathbf{d}_p\n$$\n这个较小的线性系统被求解以得到 $\\mathbf{d}_f$。\n\n**2.2. 误差评估**\n\n一旦计算出位移 $\\mathbf{d}_f$，就组装成完整的位移向量 $\\mathbf{d}$。然后计算两个误差度量：\n1.  **位移误差 $e_u$**：在所有节点上，计算出的节点位移与仿射场得到的精确解析位移之间的最大绝对差。\n    $$\n    e_u = \\max_{i} \\left\\lvert d_i - d_i^{\\text{exact}} \\right\\rvert\n    $$\n    一个正确的公式应该能精确地复现仿射位移场，所以 $e_u$ 应该在机器精度级别。\n2.  **应变误差 $e_{\\varepsilon}$**：在每个单元的每个高斯点上，计算出的应变与目标常应变之间的最大绝对差。\n    $$\n    e_{\\varepsilon} = \\max_{e,g,k} \\left\\lvert \\varepsilon_k^{(e,g)} - \\varepsilon_k^{\\text{target}} \\right\\rvert\n    $$\n    这里，$\\varepsilon_k^{(e,g)}$ 是单元 $e$ 的高斯点 $g$ 处的第 $k$ 个应变分量（xx, yy, 或 xy），使用 $\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{d}^e$ 计算。这个误差也应接近于零。\n\n如果 $e_u$ 和 $e_{\\varepsilon}$ 都低于指定的容差 $10^{-10}$，则一个测试案例算作通过。这证实了该单元满足斑块检验的能力。实现将遵循这一严谨的程序。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef solve():\n    \"\"\"\n    Main function to run the patch test for all specified test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: single distorted quadrilateral\n        {\n            \"nodes\": np.array([\n                [0.0, 0.0], [1.2, 0.1], [1.0, 1.1], [0.1, 0.9]\n            ]),\n            \"elements\": np.array([[0, 1, 2, 3]])\n        },\n        # Case 2: 2x2 mesh of the unit square\n        {\n            \"nodes\": np.array([\n                [0.0, 0.0], [0.5, 0.0], [1.0, 0.0],\n                [0.0, 0.5], [0.5, 0.5], [1.0, 0.5],\n                [0.0, 1.0], [0.5, 1.0], [1.0, 1.0]\n            ]),\n            \"elements\": np.array([\n                [0, 1, 4, 3], [1, 2, 5, 4],\n                [3, 4, 7, 6], [4, 5, 8, 7]\n            ])\n        },\n        # Case 3: parallelogram split into two quads\n        {\n            \"nodes\": np.array([\n                [0.0, 0.0], [1.0, 0.15], [2.0, 0.3],\n                [0.2, 0.9], [1.2, 1.05], [2.2, 1.2]\n            ]),\n            \"elements\": np.array([\n                [0, 1, 4, 3], [1, 2, 5, 4]\n            ])\n        }\n    ]\n\n    # Material parameters\n    E = 210.0e9  # Pascals\n    nu = 0.30\n\n    # Affine displacement field parameters\n    affine_coeffs = {\n        'alpha': 1.0e-3, 'beta': -2.0e-4, 'gamma': 2.5e-3,\n        'delta': 3.0e-4, 'epsilon': 5.0e-4, 'zeta': -1.1e-3\n    }\n    \n    # Pass/fail tolerance\n    tolerance = 1.0e-10\n\n    results = []\n    for case in test_cases:\n        nodes = case[\"nodes\"]\n        elements = case[\"elements\"]\n        passed = run_patch_test(nodes, elements, E, nu, affine_coeffs, tolerance)\n        results.append(passed)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_patch_test(nodes, elements, E, nu, affine_coeffs, tolerance):\n    \"\"\"\n    Performs the patch test for a single mesh configuration.\n    \"\"\"\n    num_nodes = nodes.shape[0]\n    num_dofs = 2 * num_nodes\n    \n    # 1. Material matrix for plane stress\n    D = (E / (1 - nu**2)) * np.array([[1, nu, 0],\n                                     [nu, 1, 0],\n                                     [0, 0, (1 - nu) / 2]])\n    \n    # 2. Gaussian quadrature points and weights (2x2)\n    gp = 1.0 / np.sqrt(3.0)\n    gauss_points = [(-gp, -gp), (gp, -gp), (gp, gp), (-gp, gp)]\n    gauss_weights = [1.0, 1.0, 1.0, 1.0]\n\n    # 3. Assemble global stiffness matrix K\n    K_global = np.zeros((num_dofs, num_dofs))\n    element_gauss_data = [] # To store B matrices and detJ for strain calculations\n\n    for el_nodes_indices in elements:\n        el_nodes_coords = nodes[el_nodes_indices]\n        K_element = np.zeros((8, 8))\n        gauss_data_for_element = []\n\n        for i, (xi, eta) in enumerate(gauss_points):\n            # Shape function derivatives w.r.t. natural coordinates\n            dN_dxi_eta = 0.25 * np.array([\n                [-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)],\n                [-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)]\n            ])\n            \n            # Jacobian matrix\n            J = dN_dxi_eta @ el_nodes_coords\n            detJ = np.linalg.det(J)\n            invJ = np.linalg.inv(J)\n            \n            # Shape function derivatives w.r.t. physical coordinates\n            dN_dxy = invJ @ dN_dxi_eta\n            \n            # Strain-displacement matrix B\n            B = np.zeros((3, 8))\n            for j in range(4):\n                B[0, 2*j] = dN_dxy[0, j]\n                B[1, 2*j+1] = dN_dxy[1, j]\n                B[2, 2*j] = dN_dxy[1, j]\n                B[2, 2*j+1] = dN_dxy[0, j]\n            \n            K_element += B.T @ D @ B * detJ * gauss_weights[i]\n            gauss_data_for_element.append({'B': B, 'detJ': detJ})\n        \n        element_gauss_data.append(gauss_data_for_element)\n\n        # Assemble into global K\n        dof_indices = np.array([[2*i, 2*i+1] for i in el_nodes_indices]).flatten()\n        K_global[np.ix_(dof_indices, dof_indices)] += K_element\n        \n    # 4. Apply boundary conditions\n    boundary_nodes = find_boundary_nodes(elements)\n    prescribed_dofs = []\n    for node_idx in boundary_nodes:\n        prescribed_dofs.extend([2 * node_idx, 2 * node_idx + 1])\n    \n    all_dofs = np.arange(num_dofs)\n    free_dofs = np.setdiff1d(all_dofs, prescribed_dofs)\n\n    # 5. Calculate exact displacements and solve system\n    d_exact = calculate_exact_displacements(nodes, affine_coeffs)\n    d_p = d_exact[prescribed_dofs]\n    \n    K_ff = K_global[np.ix_(free_dofs, free_dofs)]\n    K_fp = K_global[np.ix_(free_dofs, prescribed_dofs)]\n\n    F_eff = -K_fp @ d_p\n    d_f = np.linalg.solve(K_ff, F_eff)\n    \n    d_solution = np.zeros(num_dofs)\n    d_solution[prescribed_dofs] = d_p\n    d_solution[free_dofs] = d_f\n\n    # 6. Calculate errors\n    # Displacement error\n    e_u = np.max(np.abs(d_solution - d_exact))\n    \n    # Strain error\n    alpha, beta, delta, epsilon = [affine_coeffs[k] for k in ['alpha', 'beta', 'delta', 'epsilon']]\n    strain_target = np.array([alpha, epsilon, beta + delta])\n    \n    e_strain = 0.0\n    for i, el_nodes_indices in enumerate(elements):\n        el_dof_indices = np.array([[2*j, 2*j+1] for j in el_nodes_indices]).flatten()\n        d_element = d_solution[el_dof_indices]\n        \n        for gauss_data in element_gauss_data[i]:\n            B = gauss_data['B']\n            strain_computed = B @ d_element\n            e_strain = max(e_strain, np.max(np.abs(strain_computed - strain_target)))\n\n    return e_u = tolerance and e_strain = tolerance\n\ndef find_boundary_nodes(elements):\n    \"\"\"\n    Identifies boundary nodes from an element connectivity list.\n    \"\"\"\n    edge_counts = collections.defaultdict(int)\n    for el in elements:\n        for i in range(4):\n            n1 = el[i]\n            n2 = el[(i + 1) % 4]\n            edge = tuple(sorted((n1, n2)))\n            edge_counts[edge] += 1\n            \n    boundary_edges = {edge for edge, count in edge_counts.items() if count == 1}\n    boundary_nodes = set()\n    for edge in boundary_edges:\n        boundary_nodes.update(edge)\n        \n    return boundary_nodes\n\ndef calculate_exact_displacements(nodes, coeffs):\n    \"\"\"\n    Calculates exact nodal displacements from the affine field.\n    \"\"\"\n    num_nodes = nodes.shape[0]\n    d_exact = np.zeros(2 * num_nodes)\n    alpha, beta, gamma = coeffs['alpha'], coeffs['beta'], coeffs['gamma']\n    delta, epsilon, zeta = coeffs['delta'], coeffs['epsilon'], coeffs['zeta']\n    \n    for i in range(num_nodes):\n        x, y = nodes[i, 0], nodes[i, 1]\n        d_exact[2*i] = gamma + alpha * x + beta * y  # u\n        d_exact[2*i+1] = zeta + delta * x + epsilon * y # v\n        \n    return d_exact\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2378079"}, {"introduction": "数值解只有在其准确性值得信赖时才有用。网格收敛性研究是通过在加密离散网格的同时将其结果与已知解析解进行比较，来验证计算模型的基石。这项综合性实践要求你对经典的受压圆筒的拉梅（Lamé）问题进行建模，使用有限差分法进行数值求解，并量化其收敛性 [@problem_id:2378059]。这个练习囊括了计算工程师的完整工作流程：从理论推导和实现到严格的求解验证。", "problem": "您需要设计并实现一个完整的可运行程序，对一个具有闭式解析解的线弹性边界值问题进行网格收敛性研究。使用轴对称受压厚壁圆筒（也称为 Lame 问题）作为验证问题。此任务必须基于计算固体力学和线弹性的第一性原理进行开发，程序必须将数值解与解析解进行比较，以量化网格加密过程中的收敛性。\n\n物理设置为一个各向同性、均匀、线弹性的厚壁圆筒，其内半径为 $a$，外半径为 $b$，轴向厚度为单位长度，且无体力。该圆筒在 $r=a$ 处承受均匀内压 $p_i$，在 $r=b$ 处承受均匀外压 $p_o$。考虑轴对称、平面应变情况。未知量是径向位移 $u(r)$，其中 $r$ 是径向坐标。\n\n从以下基本原理出发：\n- 圆柱坐标系下轴对称且无体力情况下的线动量平衡（平衡方程）：$\\frac{d\\sigma_r}{dr} + \\frac{\\sigma_r - \\sigma_\\theta}{r} = 0$。\n- 轴对称条件下的运动学定义：$\\varepsilon_r = \\frac{du}{dr}$ 和 $\\varepsilon_\\theta = \\frac{u}{r}$。\n- 平面应变下各向同性材料的线弹性（胡克定律）本构模型，其中 Lamé 常数为 $\\lambda$ 和 $\\mu$：\n$$ \\sigma_r = \\lambda (\\varepsilon_r + \\varepsilon_\\theta + \\varepsilon_z) + 2 \\mu \\varepsilon_r $$\n$$ \\sigma_\\theta = \\lambda (\\varepsilon_r + \\varepsilon_\\theta + \\varepsilon_z) + 2 \\mu \\varepsilon_\\theta $$\n在平面应变中 $\\varepsilon_z = 0$。常数为 $\\mu = E/[2(1+\\nu)]$ 和 $\\lambda = E \\nu / [(1+\\nu)(1-2\\nu)]$，其中 $E$ 是杨氏模量，$\\nu$ 是泊松比。\n- 自然（力）边界条件：$\\sigma_r(a) = -p_i$ 和 $\\sigma_r(b) = -p_o$。\n\n需要执行的任务：\n1. 从上述原理推导出 $r \\in [a,b]$ 上关于 $u(r)$ 的强形式控制常微分方程，以及用 $u$ 和 $du/dr$ 表示的相关边界条件。\n2. 推导应力场 $\\sigma_r(r)$ 和 $\\sigma_\\theta(r)$ 关于 $a$、$b$、$p_i$ 和 $p_o$ 的解析解。\n3. 使用具有 $N$ 个区间和网格间距 $h = (b-a)/N$ 的均匀径向网格，构建强形式的有限差分​​离散化。对内部区域使用标准的二阶中心差分格式，在边界处使用二阶单边有限差分近似 $du/dr$ 以施加力边界条件。组装并求解得到的线性系统，以获得节点 $r_i = a + i h$ 处的节点位移 $\\{u_i\\}_{i=0}^N$。\n4. 根据离散解，使用 $\\sigma_r = (\\lambda + 2\\mu)\\,u' + \\lambda\\,u/r$ 和 $\\sigma_\\theta = \\lambda\\,u' + (\\lambda + 2\\mu)\\,u/r$ 计算节点的数值应力，其中 $u'$ 通过协调的二阶有限差分（内部中心差分，边界单边差分）进行近似。\n5. 计算所有节点上径向应力的相对均方根（RMS）误差：\n$$\n\\mathrm{err} = \\frac{\\sqrt{\\sum_{i=0}^{N} \\left(\\sigma_{r,i}^{\\mathrm{num}} - \\sigma_{r}(r_i)^{\\mathrm{exact}}\\right)^2}}{\\sqrt{\\sum_{i=0}^{N} \\left(\\sigma_{r}(r_i)^{\\mathrm{exact}}\\right)^2}}.\n$$\n误差是无量纲的。\n\n您的程序必须运行以下测试套件，并将每种情况的误差以逗号分隔列表的形式单行输出，并用方括号括起来：\n- 情况 $1$ (正常路径)：$a = 0.5\\,\\mathrm{m}$，$b = 1.0\\,\\mathrm{m}$，$p_i = 1.0\\times 10^{6}\\,\\mathrm{Pa}$，$p_o = 0.0\\,\\mathrm{Pa}$，$E = 2.10\\times 10^{11}\\,\\mathrm{Pa}$，$\\nu = 0.30$，$N = 10$。\n- 情况 $2$ (加密网格)：与情况 $1$ 相同，但 $N = 20$。\n- 情况 $3$ (更加密的网格)：与情况 $1$ 相同，但 $N = 40$。\n- 情况 $4$ (边缘网格尺寸)：与情况 $1$ 相同，但 $N = 2$。\n- 情况 $5$ (不同几何形状和载荷)：$a = 0.3\\,\\mathrm{m}$，$b = 1.0\\,\\mathrm{m}$，$p_i = 2.0\\times 10^{6}\\,\\mathrm{Pa}$，$p_o = 0.5\\times 10^{6}\\,\\mathrm{Pa}$，$E = 7.0\\times 10^{10}\\,\\mathrm{Pa}$，$\\nu = 0.25$，$N = 40$。\n- 情况 $6$ (均匀压力一致性)：$a = 0.7\\,\\mathrm{m}$，$b = 1.0\\,\\mathrm{m}$，$p_i = 1.0\\times 10^{5}\\,\\mathrm{Pa}$，$p_o = 1.0\\times 10^{5}\\,\\mathrm{Pa}$，$E = 1.0\\times 10^{11}\\,\\mathrm{Pa}$，$\\nu = 0.33$，$N = 20$。\n\n物理单位：\n- 半径 $a$ 和 $b$ 的单位必须是 $\\mathrm{m}$。\n- 压力 $p_i$ 和 $p_o$ 的单位必须是 $\\mathrm{Pa}$。\n- 杨氏模量 $E$ 的单位必须是 $\\mathrm{Pa}$。\n- 泊松比 $\\nu$ 是无量纲的。\n- 位移 $u$ 的单位是 $\\mathrm{m}$。\n- 报告的误差是无量纲浮点数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 `[err_1,err_2,...]`，其中每个条目是与上述情况顺序对应的浮点数误差。", "solution": "所提出的问题是线弹性中的一个标准边界值问题，特别是受压厚壁圆筒的 Lamé 问题。我们将首先验证问题陈述，然后继续进行所需的推导和数值实现计划，因为该问题是适定的且在科学上是合理的。\n\n**1. 控制方程（强形式）的推导**\n\n分析从所提供的连续介质力学的基本原理开始。\n在没有体力的情况下，轴对称圆柱坐标系中的线动量平衡由下式给出：\n$$ \\frac{d\\sigma_r}{dr} + \\frac{\\sigma_r - \\sigma_\\theta}{r} = 0 \\quad (1) $$\n连接应变与位移的运动学关系为：\n$$ \\varepsilon_r = \\frac{du}{dr}, \\quad \\varepsilon_\\theta = \\frac{u}{r} \\quad (2) $$\n材料是各向同性线弹性的，状态为平面应变（$\\varepsilon_z = 0$）。本构关系（胡克定律）为：\n$$ \\sigma_r = \\lambda (\\varepsilon_r + \\varepsilon_\\theta) + 2 \\mu \\varepsilon_r \\quad (3a) $$\n$$ \\sigma_\\theta = \\lambda (\\varepsilon_r + \\varepsilon_\\theta) + 2 \\mu \\varepsilon_\\theta \\quad (3b) $$\n其中 $\\lambda$ 和 $\\mu$ 是 Lamé 的第一和第二参数。\n\n首先，我们将 $(2)$ 代入 $(3)$，用径向位移 $u(r)$ 表示应力：\n$$ \\sigma_r = \\lambda \\left(\\frac{du}{dr} + \\frac{u}{r}\\right) + 2 \\mu \\frac{du}{dr} = (\\lambda + 2\\mu) \\frac{du}{dr} + \\lambda \\frac{u}{r} \\quad (4a) $$\n$$ \\sigma_\\theta = \\lambda \\left(\\frac{du}{dr} + \\frac{u}{r}\\right) + 2 \\mu \\frac{u}{r} = \\lambda \\frac{du}{dr} + (\\lambda + 2\\mu) \\frac{u}{r} \\quad (4b) $$\n接下来，我们将这些应力表达式代入平衡方程 $(1)$。我们需要 $\\sigma_r$ 的导数：\n$$ \\frac{d\\sigma_r}{dr} = \\frac{d}{dr} \\left( (\\lambda + 2\\mu) \\frac{du}{dr} + \\lambda \\frac{u}{r} \\right) = (\\lambda + 2\\mu) \\frac{d^2u}{dr^2} + \\lambda \\left( \\frac{1}{r}\\frac{du}{dr} - \\frac{u}{r^2} \\right) $$\n以及应力差：\n$$ \\sigma_r - \\sigma_\\theta = \\left( (\\lambda + 2\\mu) \\frac{du}{dr} + \\lambda \\frac{u}{r} \\right) - \\left( \\lambda \\frac{du}{dr} + (\\lambda + 2\\mu) \\frac{u}{r} \\right) = 2\\mu \\left( \\frac{du}{dr} - \\frac{u}{r} \\right) $$\n将这些代入平衡方程 $(1)$：\n$$ \\left( (\\lambda + 2\\mu) \\frac{d^2u}{dr^2} + \\frac{\\lambda}{r}\\frac{du}{dr} - \\frac{\\lambda u}{r^2} \\right) + \\frac{1}{r} \\left( 2\\mu \\left( \\frac{du}{dr} - \\frac{u}{r} \\right) \\right) = 0 $$\n合并各项：\n$$ (\\lambda + 2\\mu) \\frac{d^2u}{dr^2} + \\frac{(\\lambda + 2\\mu)}{r}\\frac{du}{dr} - \\frac{(\\lambda + 2\\mu)}{r^2}u = 0 $$\n由于对于任何物理材料 $\\lambda + 2\\mu \\neq 0$，我们可以除以该项，得到关于 $u(r)$ 的控制常微分方程的强形式：\n$$ \\frac{d^2u}{dr^2} + \\frac{1}{r}\\frac{du}{dr} - \\frac{u}{r^2} = 0 \\quad (5) $$\n该方程在定义域 $r \\in [a, b]$ 上有效。边界条件以力的形式给出，$\\sigma_r(a) = -p_i$ 和 $\\sigma_r(b) = -p_o$。使用方程 $(4a)$，我们用 $u(r)$ 及其导数表示它们：\n$$ (\\lambda + 2\\mu) \\frac{du}{dr}\\bigg|_{r=a} + \\frac{\\lambda}{a} u(a) = -p_i \\quad (6a) $$\n$$ (\\lambda + 2\\mu) \\frac{du}{dr}\\bigg|_{r=b} + \\frac{\\lambda}{b} u(b) = -p_o \\quad (6b) $$\n\n**2. 解析解的推导**\n\n方程 $(5)$ 是一个柯西-欧拉方程。其通解形式为 $u(r) = C_1 r + C_2/r$。为了确定积分常数，可以使用边界条件 $(6a)$ 和 $(6b)$。然而，直接求解应力场的常数更为直接。与这种位移形式一致的应力场必须具有以下形式：\n$$ \\sigma_r(r) = A - \\frac{B}{r^2} \\quad (7a) $$\n$$ \\sigma_\\theta(r) = A + \\frac{B}{r^2} \\quad (7b) $$\n这种形式恒满足平衡方程 $(1)$。常数 $A$ 和 $B$ 由应力边界条件确定：\n$$ \\sigma_r(a) = A - \\frac{B}{a^2} = -p_i $$\n$$ \\sigma_r(b) = A - \\frac{B}{b^2} = -p_o $$\n这是一个关于 $A$ 和 $B$ 的线性系统。两方程相减得到：\n$$ B \\left( \\frac{1}{b^2} - \\frac{1}{a^2} \\right) = -p_i + p_o \\implies B \\left( \\frac{a^2 - b^2}{a^2 b^2} \\right) = p_o - p_i $$\n$$ B = \\frac{(p_i - p_o) a^2 b^2}{b^2 - a^2} $$\n将 $B$ 代回第一个方程求 $A$：\n$$ A = -p_i + \\frac{B}{a^2} = -p_i + \\frac{(p_i - p_o) b^2}{b^2 - a^2} = \\frac{-p_i (b^2 - a^2) + p_i b^2 - p_o b^2}{b^2 - a^2} = \\frac{p_i a^2 - p_o b^2}{b^2 - a^2} $$\n因此，径向应力的精确解析解为：\n$$ \\sigma_{r}(r)^{\\mathrm{exact}} = \\frac{p_i a^2 - p_o b^2}{b^2 - a^2} - \\frac{(p_i - p_o) a^2 b^2}{b^2 - a^2} \\frac{1}{r^2} \\quad (8) $$\n\n**3. 有限差分法 (FDM) 离散化**\n\n我们在域 $[a, b]$ 上定义一个具有 $N$ 个区间的均匀网格，使得网格间距为 $h = (b-a)/N$。节点位于 $r_i = a + i h$，其中 $i = 0, 1, \\dots, N$。我们寻求在这 $N+1$ 个节点上的近似解 $u_i \\approx u(r_i)$。\n\n对于内部节点（$i = 1, \\dots, N-1$），我们使用二阶中心差分公式对控制常微分方程 $(5)$ 进行离散化：\n$$ u'(r_i) \\approx \\frac{u_{i+1} - u_{i-1}}{2h}, \\quad u''(r_i) \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} $$\n将这些代入 $(5)$ 得到：\n$$ \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} + \\frac{1}{r_i}\\frac{u_{i+1} - u_{i-1}}{2h} - \\frac{u_i}{r_i^2} = 0 $$\n乘以 $h^2$ 并按未知数 $u_j$ 对各项进行分组：\n$$ \\left(1 - \\frac{h}{2r_i}\\right) u_{i-1} + \\left(-2 - \\frac{h^2}{r_i^2}\\right) u_i + \\left(1 + \\frac{h}{2r_i}\\right) u_{i+1} = 0 \\quad (9) $$\n这提供了 $N-1$ 个线性代数方程。\n\n对于边界节点 $i=0$ 和 $i=N$，我们对边界条件 $(6a)$ 和 $(6b)$ 进行离散化。这需要对导数 $du/dr$ 使用二阶单边有限差分近似：\n$$ u'(r_0) \\approx \\frac{-3u_0 + 4u_1 - u_2}{2h}, \\quad u'(r_N) \\approx \\frac{3u_N - 4u_{N-1} + u_{N-2}}{2h} $$\n将这些代入 $(6a)$ 和 $(6b)$：\n在 $r=a$ ($i=0$) 处：\n$$ (\\lambda + 2\\mu) \\left( \\frac{-3u_0 + 4u_1 - u_2}{2h} \\right) + \\frac{\\lambda}{r_0} u_0 = -p_i \\quad (10a) $$\n在 $r=b$ ($i=N$) 处：\n$$ (\\lambda + 2\\mu) \\left( \\frac{3u_N - 4u_{N-1} + u_{N-2}}{2h} \\right) + \\frac{\\lambda}{r_N} u_N = -p_o \\quad (10b) $$\n方程 $(9)$、$(10a)$ 和 $(10b)$ 构成了关于 $N+1$ 个未知数 $\\{u_i\\}_{i=0}^N$ 的 $N+1$ 个线性方程组。该系统写作 $\\mathbf{A} \\mathbf{u} = \\mathbf{f}$，通过数值方法进行组装和求解。矩阵 $\\mathbf{A}$ 是五对角矩阵。\n\n**4. 数值应力计算与误差度量**\n\n在求解节点位移 $\\mathbf{u}$ 后，使用方程 $(4a)$ 计算每个节点 $i$ 处径向应力的数值近似值 $\\sigma_{r,i}^{\\mathrm{num}}$。导数 $u'(r_i)$ 使用协调的二阶格式进行近似：内部节点使用中心差分，边界处使用与边界条件相同的单边差分。\n$$ \\sigma_{r,i}^{\\mathrm{num}} = (\\lambda + 2\\mu) u'_{i} + \\lambda \\frac{u_i}{r_i} $$\n其中 $u'_i$ 是导数的相应有限差分近似值。\n\n然后通过将数值应力向量与在节点处求值的精确应力向量进行比较，计算相对均方根（RMS）误差：\n$$ \\mathrm{err} = \\frac{\\sqrt{\\sum_{i=0}^{N} \\left(\\sigma_{r,i}^{\\mathrm{num}} - \\sigma_{r}(r_i)^{\\mathrm{exact}}\\right)^2}}{\\sqrt{\\sum_{i=0}^{N} \\left(\\sigma_{r}(r_i)^{\\mathrm{exact}}\\right)^2}} $$\n这量化了数值模拟的准确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the Lamé problem convergence study.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path)\n        {'a': 0.5, 'b': 1.0, 'p_i': 1.0e6, 'p_o': 0.0, 'E': 2.10e11, 'nu': 0.30, 'N': 10},\n        # Case 2 (refined mesh)\n        {'a': 0.5, 'b': 1.0, 'p_i': 1.0e6, 'p_o': 0.0, 'E': 2.10e11, 'nu': 0.30, 'N': 20},\n        # Case 3 (more refined mesh)\n        {'a': 0.5, 'b': 1.0, 'p_i': 1.0e6, 'p_o': 0.0, 'E': 2.10e11, 'nu': 0.30, 'N': 40},\n        # Case 4 (edge mesh size)\n        {'a': 0.5, 'b': 1.0, 'p_i': 1.0e6, 'p_o': 0.0, 'E': 2.10e11, 'nu': 0.30, 'N': 2},\n        # Case 5 (different geometry and loads)\n        {'a': 0.3, 'b': 1.0, 'p_i': 2.0e6, 'p_o': 0.5e6, 'E': 7.0e10, 'nu': 0.25, 'N': 40},\n        # Case 6 (uniform pressure consistency)\n        {'a': 0.7, 'b': 1.0, 'p_i': 1.0e5, 'p_o': 1.0e5, 'E': 1.0e11, 'nu': 0.33, 'N': 20},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = compute_error_for_case(**case)\n        results.append(f\"{error:.6g}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef compute_error_for_case(a, b, p_i, p_o, E, nu, N):\n    \"\"\"\n    Solves the Lamé problem for one case and computes the relative RMS error.\n\n    Args:\n        a (float): Inner radius [m].\n        b (float): Outer radius [m].\n        p_i (float): Internal pressure [Pa].\n        p_o (float): External pressure [Pa].\n        E (float): Young's modulus [Pa].\n        nu (float): Poisson's ratio.\n        N (int): Number of intervals in the mesh.\n\n    Returns:\n        float: The relative RMS error for the radial stress.\n    \"\"\"\n    # 1. Calculate constants and set up mesh\n    # Use 'lmbda' for lambda to avoid keyword conflict\n    lmbda = E * nu / ((1 + nu) * (1 - 2 * nu))\n    mu = E / (2 * (1 + nu))\n    h = (b - a) / N\n    r = np.array([a + i * h for i in range(N + 1)])\n\n    # 2. Assemble the linear system A * u = f for N+1 unknowns u_0, ..., u_N\n    num_unknowns = N + 1\n    A = np.zeros((num_unknowns, num_unknowns))\n    f = np.zeros(num_unknowns)\n\n    # Equation for node i=0 (from boundary condition at r=a)\n    # This equation involves u_0, u_1, u_2\n    A[0, 0] = -3 * (lmbda + 2 * mu) / (2 * h) + lmbda / r[0]\n    A[0, 1] = 2 * (lmbda + 2 * mu) / h  # Simplified from 4 * (...) / (2*h)\n    A[0, 2] = -1 * (lmbda + 2 * mu) / (2 * h)\n    f[0] = -p_i\n\n    # Equations for interior nodes i=1 to N-1 (from governing ODE)\n    for i in range(1, N):\n        A[i, i - 1] = 1 - h / (2 * r[i])\n        A[i, i] = -2 - h**2 / r[i]**2\n        A[i, i + 1] = 1 + h / (2 * r[i])\n\n    # Equation for node i=N (from boundary condition at r=b)\n    # This equation involves u_{N-2}, u_{N-1}, u_N\n    A[N, N - 2] = (lmbda + 2 * mu) / (2 * h)\n    A[N, N - 1] = -2 * (lmbda + 2 * mu) / h # Simplified from -4 * (...) / (2*h)\n    A[N, N] = 3 * (lmbda + 2 * mu) / (2 * h) + lmbda / r[N]\n    f[N] = -p_o\n    \n    # 3. Solve for displacement vector u\n    u = np.linalg.solve(A, f)\n\n    # 4. Compute numerical stresses from the displacement solution\n    du_dr_num = np.zeros(num_unknowns)\n    # Derivative at i=0 (second-order forward difference)\n    du_dr_num[0] = (-3 * u[0] + 4 * u[1] - u[2]) / (2 * h)\n    # Derivatives for i=1 to N-1 (second-order central difference)\n    for i in range(1, N):\n        du_dr_num[i] = (u[i + 1] - u[i - 1]) / (2 * h)\n    # Derivative at i=N (second-order backward difference)\n    du_dr_num[N] = (3 * u[N] - 4 * u[N - 1] + u[N - 2]) / (2 * h)\n\n    sigma_r_num = (lmbda + 2 * mu) * du_dr_num + lmbda * u / r\n\n    # 5. Compute analytical stresses at nodes\n    const_A = (p_i * a**2 - p_o * b**2) / (b**2 - a**2)\n    const_B = (p_i - p_o) * a**2 * b**2 / (b**2 - a**2)\n    sigma_r_exact = const_A - const_B / r**2\n\n    # 6. Compute the relative RMS error\n    numerator = np.sqrt(np.sum((sigma_r_num - sigma_r_exact)**2))\n    denominator = np.sqrt(np.sum(sigma_r_exact**2))\n    \n    if abs(denominator)  1e-15:\n        if abs(numerator)  1e-15:\n            return 0.0  # Exact solution found for a zero-norm case if it happens\n        else:\n            return np.inf  # Numerical solution non-zero, but analytical is zero\n    \n    error = numerator / denominator\n    return error\n\nsolve()\n```", "id": "2378059"}]}