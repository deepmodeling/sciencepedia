{"hands_on_practices": [{"introduction": "理论是实践的基石。在使用交错网格的显式时间积分方案时，一个核心问题是数值稳定性。此练习将指导您运用冯·诺依曼稳定性分析，这一基本工具来推导一维对流扩散方程的稳定条件，揭示时间步长 $\\Delta t$、网格间距 $\\Delta x$、对流速度 $U$ 及扩散系数 $\\nu$ 之间的深刻联系。掌握这项分析技能对于确保您的仿真结果不会因数值不稳定性而失效至关重要 [@problem_id:2438292]。", "id": "2438292", "problem": "考虑一维（$1$D）线性平流-扩散方程\n$$\n\\frac{\\partial \\phi}{\\partial t} + U\\,\\frac{\\partial \\phi}{\\partial x} = \\nu\\,\\frac{\\partial^2 \\phi}{\\partial x^2},\n$$\n该方程定义在一个周期性域上，其中 $U$ 是空间均匀的恒定平流速度，$\\nu$ 是一个正常数运动粘性系数。使用间距为 $\\Delta x$ 的均匀网格和一维交错的标记与网格 (Marker-And-Cell, MAC) 布局对空间域进行离散化：标量场 $\\phi$ 存储在由整数 $i$ 索引的网格中心，而速度 $U$ 是一个面心常数，存储在半整数索引 $i+\\tfrac{1}{2}$ 处。使用时间步长为 $\\Delta t$ 的完全显式前向欧拉方法进行时间推进。对于空间离散化，使用：\n- 对流项使用守恒通量差分形式，其面通量 $(U \\phi)_{i+\\frac{1}{2}}$ 由面心速度和 $\\phi$ 到网格面的中心插值 $\\phi_{i+\\frac{1}{2}} = \\tfrac{1}{2}(\\phi_{i+1} + \\phi_i)$ 计算得出，\n- 扩散项在网格中心使用标准的二阶中心差分。\n\n在这些假设下，网格中心值 $\\phi_i$ 在一个时间步长内的更新公式为\n$$\n\\phi_i^{n+1} = \\phi_i^{n} - \\Delta t\\,\\frac{(U\\phi)_{i+\\frac{1}{2}}^{n} - (U\\phi)_{i-\\frac{1}{2}}^{n}}{\\Delta x} + \\Delta t\\,\\nu\\,\\frac{\\phi_{i+1}^{n} - 2\\phi_{i}^{n} + \\phi_{i-1}^{n}}{\\Delta x^2},\n$$\n其中 $(U\\phi)_{i+\\frac{1}{2}}^{n} = U\\,\\tfrac{1}{2}(\\phi_{i+1}^{n} + \\phi_{i}^{n})$，对于 $i-\\tfrac{1}{2}$ 同样适用。假设使用周期性边界条件。\n\n对这个完全显式的交错网格格式进行 von Neumann 稳定性分析，并确定最大的时间步长 $\\Delta t_{\\max}$。该步长应表示为 $U$、$\\nu$ 和 $\\Delta x$ 的解析表达式，并能确保所有傅里叶模态在一个时间步长内其振幅都不会被放大。全过程使用国际单位制 (SI)；时间步长的单位是秒。请以 $U$、$\\nu$ 和 $\\Delta x$ 的单个闭式表达式形式给出最终答案。不需要进行数值取整。", "solution": "首先对问题陈述进行关键验证程序。\n\n步骤 1：提取已知条件。\n控制偏微分方程为一维线性平流-扩散方程：\n$$\n\\frac{\\partial \\phi}{\\partial t} + U\\,\\frac{\\partial \\phi}{\\partial x} = \\nu\\,\\frac{\\partial^2 \\phi}{\\partial x^2}\n$$\n参数为一个空间均匀的恒定平流速度 $U$ 和一个正常数运动粘性系数 $\\nu$。空间域是周期性的，并使用均匀网格间距 $\\Delta x$ 进行离散化。数值格式定义如下：\n- 时间积分：采用时间步长为 $\\Delta t$ 的完全显式前向欧拉方法。\n- 网格布局：交错的标记与网格 (MAC)，标量 $\\phi$ 位于网格中心 $x_i = i \\Delta x$，速度 $U$ 位于网格面 $x_{i+1/2} = (i+1/2)\\Delta x$。\n- 平流项离散化：守恒通量差分形式，其中面通量为 $(U \\phi)_{i+\\frac{1}{2}} = U\\,\\phi_{i+\\frac{1}{2}} = U\\,\\tfrac{1}{2}(\\phi_{i+1} + \\phi_i)$。\n- 扩散项离散化：标准的二阶中心差分。\n由此得到的全离散更新方程给出如下：\n$$\n\\phi_i^{n+1} = \\phi_i^{n} - \\Delta t\\,\\frac{(U\\phi)_{i+\\frac{1}{2}}^{n} - (U\\phi)_{i-\\frac{1}{2}}^{n}}{\\Delta x} + \\Delta t\\,\\nu\\,\\frac{\\phi_{i+1}^{n} - 2\\phi_{i}^{n} + \\phi_{i-1}^{n}}{\\Delta x^2}\n$$\n通量定义如下：\n$$\n(U\\phi)_{i+\\frac{1}{2}}^{n} = U\\,\\frac{\\phi_{i+1}^{n} + \\phi_{i}^{n}}{2} \\quad \\text{和} \\quad (U\\phi)_{i-\\frac{1}{2}}^{n} = U\\,\\frac{\\phi_{i}^{n} + \\phi_{i-1}^{n}}{2}\n$$\n任务是通过执行 von Neumann 稳定性分析来找到最大稳定时间步长 $\\Delta t_{\\max}$。\n\n步骤 2：使用提取的已知条件进行验证。\n评估问题的有效性。\n- **科学依据**：平流-扩散方程是输运现象中的一个基本模型。所描述的数值方法（前向欧拉、中心差分、交错网格）是计算工程中的标准方法。von Neumann 分析是评估线性有限差分格式稳定性的经典技术。该问题在科学上是合理的。\n- **良定性**：问题的阐述足够详细。它提供了控制方程、完整的离散格式和一个明确的目标：确定稳定性极限。稳定性边界存在唯一且有意义的解。\n- **客观性**：问题使用了精确、无歧义的数学和技术语言进行陈述。它不包含主观论断。\n- **完整性与一致性**：分析所需的所有要素都已提供。定义中没有矛盾之处。该问题是自洽的。\n\n步骤 3：结论与行动。\n问题有效。现在开始推导解。\n\n第一步是将给定的通量表达式代入更新方程。\n$$\n\\phi_i^{n+1} = \\phi_i^{n} - \\frac{\\Delta t}{\\Delta x} \\left( U\\,\\frac{\\phi_{i+1}^{n} + \\phi_{i}^{n}}{2} - U\\,\\frac{\\phi_{i}^{n} + \\phi_{i-1}^{n}}{2} \\right) + \\frac{\\nu \\Delta t}{\\Delta x^2} (\\phi_{i+1}^{n} - 2\\phi_i^{n} + \\phi_{i-1}^{n})\n$$\n简化平流项可得：\n$$\n\\phi_i^{n+1} = \\phi_i^{n} - \\frac{U \\Delta t}{2 \\Delta x} (\\phi_{i+1}^{n} - \\phi_{i-1}^{n}) + \\frac{\\nu \\Delta t}{\\Delta x^2} (\\phi_{i+1}^{n} - 2\\phi_i^{n} + \\phi_{i-1}^{n})\n$$\n该格式对于平流项和扩散项都是一种时间前向、空间中心 (FTCS) 的离散格式。为分析其稳定性，我们进行 von Neumann 分析。我们将单个傅里叶模态代入网格点 $i$ 和时间层 $n$ 的解中：\n$$\n\\phi_i^n = \\hat{\\phi}^n(k) \\exp(I k x_i) = \\hat{\\phi}^n(k) \\exp(I k i \\Delta x)\n$$\n其中 $I = \\sqrt{-1}$ 是虚数单位，$k$ 是波数，$\\hat{\\phi}^n(k)$ 是模态在时间 $n$ 的振幅。放大因子定义为 $G(k) = \\hat{\\phi}^{n+1}(k) / \\hat{\\phi}^n(k)$。将傅里叶模态代入离散方程得到：\n$$\nG(k) \\exp(Iki\\Delta x) = \\exp(Iki\\Delta x) - \\frac{U \\Delta t}{2 \\Delta x} (\\exp(Ik(i+1)\\Delta x) - \\exp(Ik(i-1)\\Delta x)) + \\frac{\\nu \\Delta t}{\\Delta x^2} (\\exp(Ik(i+1)\\Delta x) - 2\\exp(Iki\\Delta x) + \\exp(Ik(i-1)\\Delta x))\n$$\n两边同除以 $\\exp(Iki\\Delta x)$ 得到放大因子 $G(k)$：\n$$\nG(k) = 1 - \\frac{U \\Delta t}{2 \\Delta x} (\\exp(Ik\\Delta x) - \\exp(-Ik\\Delta x)) + \\frac{\\nu \\Delta t}{\\Delta x^2} (\\exp(Ik\\Delta x) - 2 + \\exp(-Ik\\Delta x))\n$$\n使用欧拉恒等式 $\\exp(I\\theta) - \\exp(-I\\theta) = 2I\\sin(\\theta)$ 和 $\\exp(I\\theta) + \\exp(-I\\theta) - 2 = 2\\cos(\\theta) - 2 = -4\\sin^2(\\theta/2)$，并令 $\\alpha = k\\Delta x$，我们有：\n$$\nG(\\alpha) = 1 - \\frac{U \\Delta t}{2 \\Delta x} (2I\\sin(\\alpha)) + \\frac{\\nu \\Delta t}{\\Delta x^2} (2\\cos(\\alpha) - 2)\n$$\n令库朗数 $c = \\frac{U \\Delta t}{\\Delta x}$ 和扩散数 $d = \\frac{\\nu \\Delta t}{\\Delta x^2}$。放大因子变为：\n$$\nG(\\alpha) = 1 - I c \\sin(\\alpha) - 4d \\sin^2(\\alpha/2)\n$$\n为使格式稳定，放大因子的模对于所有可能的波数都不得超过 1，即对所有 $\\alpha \\in [-\\pi, \\pi]$ 都有 $|G(\\alpha)| \\le 1$。我们分析其模的平方：\n$$\n|G(\\alpha)|^2 = \\left(1 - 4d \\sin^2(\\alpha/2)\\right)^2 + (-c \\sin(\\alpha))^2 \\le 1\n$$\n$$\n1 - 8d \\sin^2(\\alpha/2) + 16d^2 \\sin^4(\\alpha/2) + c^2 \\sin^2(\\alpha) \\le 1\n$$\n使用恒等式 $\\sin^2(\\alpha) = (2\\sin(\\alpha/2)\\cos(\\alpha/2))^2 = 4\\sin^2(\\alpha/2)\\cos^2(\\alpha/2) = 4\\sin^2(\\alpha/2)(1-\\sin^2(\\alpha/2))$，我们得到：\n$$\n-8d \\sin^2(\\alpha/2) + 16d^2 \\sin^4(\\alpha/2) + 4c^2 \\sin^2(\\alpha/2)(1-\\sin^2(\\alpha/2)) \\le 0\n$$\n令 $S = \\sin^2(\\alpha/2)$。对于 $\\alpha \\in [-\\pi, \\pi]$，$S$ 的取值范围是从 $0$ 到 $1$。当 $S > 0$ 时，我们可以除以 $S$：\n$$\n-8d + 16d^2 S + 4c^2 (1-S) \\le 0\n$$\n$$\n(4c^2 - 8d) + S(16d^2 - 4c^2) \\le 0\n$$\n这个不等式是关于 $S$ 的线性不等式，并且必须对所有 $S \\in [0, 1]$ 成立。这只有在该不等式在端点 $S=0$ 和 $S=1$ 处都成立时才可能。\n对于 $S \\to 0$（长波，$\\alpha \\to 0$）：\n$$\n4c^2 - 8d \\le 0 \\implies c^2 \\le 2d\n$$\n对于 $S=1$（最短波，$\\alpha = \\pm\\pi$）：\n$$\n(4c^2 - 8d) + (16d^2 - 4c^2) \\le 0 \\implies 16d^2 - 8d \\le 0 \\implies 8d(2d-1) \\le 0\n$$\n因为 $\\nu>0$，$\\Delta t>0$ 和 $\\Delta x^2>0$，所以我们有 $d>0$。因此，第二个条件简化为：\n$$\n2d-1 \\le 0 \\implies d \\le \\frac{1}{2}\n$$\n我们现在有两个必须同时满足的稳定性条件：\n1. $c^2 \\le 2d$\n2. $d \\le \\frac{1}{2}$\n\n将 $c$ 和 $d$ 的定义代换回物理参数。对于条件 1：\n$$\n\\left(\\frac{U \\Delta t}{\\Delta x}\\right)^2 \\le 2\\left(\\frac{\\nu \\Delta t}{\\Delta x^2}\\right) \\implies \\frac{U^2 (\\Delta t)^2}{\\Delta x^2} \\le \\frac{2\\nu \\Delta t}{\\Delta x^2}\n$$\n假设 $\\Delta t > 0$，我们可以简化以找到 $\\Delta t$ 的一个界限：\n$$\nU^2 \\Delta t \\le 2\\nu \\implies \\Delta t \\le \\frac{2\\nu}{U^2} \\quad (\\text{对于 } U \\neq 0)\n$$\n对于条件 2：\n$$\n\\frac{\\nu \\Delta t}{\\Delta x^2} \\le \\frac{1}{2} \\implies \\Delta t \\le \\frac{\\Delta x^2}{2\\nu}\n$$\n时间步长 $\\Delta t$ 必须同时满足这两个约束。因此，最大允许时间步长 $\\Delta t_{max}$ 是这两个上界中的较小者：\n$$\n\\Delta t_{\\max} = \\min\\left(\\frac{2\\nu}{U^2}, \\frac{\\Delta x^2}{2\\nu}\\right)\n$$\n此表达式就是给定数值格式的完整且精确的稳定性极限。", "answer": "$$\n\\boxed{\\min\\left(\\frac{2\\nu}{U^2}, \\frac{\\Delta x^2}{2\\nu}\\right)}\n$$"}, {"introduction": "在不可压缩流的 MAC 格式模拟中，求解压力泊松方程是计算量最大、也最关键的步骤之一。本实践将带您亲手实现一个经典的迭代求解器——红黑高斯-赛德尔（RBGS）方法，并用它来探索一个影响求解效率的重要实际问题：网格单元长宽比对收敛速度的影响。通过这个编码练习，您将获得处理大规模线性系统的第一手经验，并直观地理解为何高质量的网格对于计算性能至关重要 [@problem_id:2438296]。", "id": "2438296", "problem": "要求您通过直接数值实验，量化网格单元纵横比对标记网格-单元 (Marker-And-Cell, MAC) 交错网格上压力泊松方程迭代求解器收敛速率的影响。考虑单位正方形域 $[0,1]\\times[0,1]$，压力未知数位于单元中心。令 $N_x$ 和 $N_y$ 分别表示沿 $x$ 和 $y$ 方向的内部压力未知数数量。均匀网格间距为 $\\Delta x = \\dfrac{1}{N_x+1}$ 和 $\\Delta y = \\dfrac{1}{N_y+1}$，因此单元纵横比为 $\\Delta x / \\Delta y = \\dfrac{N_y+1}{N_x+1}$。在 $\\partial \\Omega$ 上施加齐次狄利克雷边界条件 $p=0$，并对所有内部索引 $(i,j)$ 求解离散泊松方程\n$$\n\\frac{p_{i+1,j}-2 p_{i,j}+p_{i-1,j}}{(\\Delta x)^2}+\\frac{p_{i,j+1}-2 p_{i,j}+p_{i,j-1}}{(\\Delta y)^2}=f_{i,j},\n$$\n其中，源项是在内部单元中心位置 $(x_i,y_j)=(i\\,\\Delta x, j\\,\\Delta y)$（其中 $i\\in\\{1,\\dots,N_x\\}$ 且 $j\\in\\{1,\\dots,N_y\\}$）处从连续函数 $f(x,y)=-2\\pi^2\\sin(\\pi x)\\sin(\\pi y)$ 采样得到。使用红黑高斯-赛德尔 (Red-Black Gauss-Seidel, RBGS) 迭代法，从所有内部 $(i,j)$ 的零场 $p_{i,j}^{(0)}=0$ 开始，并在每次迭代中对所有边界节点强制实施 $p=0$。每次完整的 RBGS 扫描（一次红色更新和一次黑色更新）后，计算离散残差\n$$\nr_{i,j}=\\frac{p_{i+1,j}-2 p_{i,j}+p_{i-1,j}}{(\\Delta x)^2}+\\frac{p_{i,j+1}-2 p_{i,j}+p_{i,j-1}}{(\\Delta y)^2}-f_{i,j},\n$$\n和相对残差范数\n$$\n\\mathrm{RelRes}=\\frac{\\left(\\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y} r_{i,j}^2\\right)^{1/2}}{\\left(\\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y} f_{i,j}^2\\right)^{1/2}}.\n$$\n当 $\\mathrm{RelRes}\\le \\varepsilon$（容差 $\\varepsilon=10^{-6}$）或达到 $N_{\\max}=100000$ 次完整扫描的硬上限时，以先到者为准，终止迭代。每个案例中我们关注的量是达到容差所需的完整 RBGS 扫描次数。\n\n测试套件：对于以下每个参数对 $(N_x,N_y)$，运行上述实验并记录所需的扫描次数（整数）：\n- 案例 $1$：$(N_x,N_y)=(32,32)$。\n- 案例 $2$：$(N_x,N_y)=(48,12)$。\n- 案例 $3$：$(N_x,N_y)=(12,48)$。\n- 案例 $4$：$(N_x,N_y)=(8,8)$。\n- 案例 $5$：$(N_x,N_y)=(64,16)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序与上述案例相同，例如 $\\texttt{[r_1,r_2,r_3,r_4,r_5]}$，其中每个 $r_k$ 是案例 $k$ 所需的 RBGS 扫描整数次数。", "solution": "所提出的问题是计算工程中一个良态的数值实验，要求实现一个二维泊松方程的迭代求解器。该问题在科学上是合理的、自成体系的，并且所有数据和约束都已明确指定。既定目标是量化网格单元纵横比对红黑高斯-赛德尔 (Red-Black Gauss-Seidel) 方法收敛速率的影响。我们将着手推导和实现所需的算法。\n\n控制偏微分方程是在单位正方形域 $\\Omega = [0,1]\\times[0,1]$ 上带有齐次狄利克雷边界条件的泊松方程：\n$$\n\\nabla^2 p = \\frac{\\partial^2 p}{\\partial x^2} + \\frac{\\partial^2 p}{\\partial y^2} = f(x,y), \\quad \\text{for } (x,y) \\in \\Omega\n$$\n$$\np(x,y) = 0, \\quad \\text{for } (x,y) \\in \\partial\\Omega\n$$\n我们使用有限差分法在均匀笛卡尔网格上离散化此问题。对于内部索引 $i \\in \\{1, \\dots, N_x\\}$ 和 $j \\in \\{1, \\dots, N_y\\}$，压力未知数 $p_{i,j}$ 位于单元中心 $(x_i, y_j) = (i\\Delta x, j\\Delta y)$。网格间距为 $\\Delta x = \\frac{1}{N_x+1}$ 和 $\\Delta y = \\frac{1}{N_y+1}$。对二阶导数使用二阶中心差分格式，我们得到每个内部节点 $(i,j)$ 的离散泊松方程：\n$$\n\\frac{p_{i+1,j}-2 p_{i,j}+p_{i-1,j}}{(\\Delta x)^2}+\\frac{p_{i,j+1}-2 p_{i,j}+p_{i,j-1}}{(\\Delta y)^2}=f_{i,j}\n$$\n其中 $f_{i,j}$ 是源项 $f(x,y)=-2\\pi^2\\sin(\\pi x)\\sin(\\pi y)$ 在 $(x_i, y_j)$ 处的值。齐次边界条件意味着如果 $i=0$、$i=N_x+1$、$j=0$ 或 $j=N_y+1$，则 $p_{i,j}=0$。\n\n为了迭代求解该系统，我们首先重新整理方程以分离出 $p_{i,j}$。这给出了点迭代法的更新规则。\n$$\np_{i,j} \\left( \\frac{2}{(\\Delta x)^2} + \\frac{2}{(\\Delta y)^2} \\right) = \\frac{p_{i+1,j} + p_{i-1,j}}{(\\Delta x)^2} + \\frac{p_{i,j+1} + p_{i,j-1}}{(\\Delta y)^2} - f_{i,j}\n$$\n令 $\\alpha_x = 1/(\\Delta x)^2$ 和 $\\alpha_y = 1/(\\Delta y)^2$，更新规则变为：\n$$\np_{i,j} = \\frac{ \\alpha_x (p_{i+1,j} + p_{i-1,j}) + \\alpha_y (p_{i,j+1} + p_{i,j-1}) - f_{i,j} }{ 2(\\alpha_x + \\alpha_y) }\n$$\n红黑高斯-赛德尔 (RBGS) 方法通过将网格点划分成“红色”和“黑色”两组（类似于棋盘格）来加速收敛。如果一个节点 $(i,j)$ 的索引之和 $i+j$ 是偶数，则将其指定为红色；如果 $i+j$ 是奇数，则指定为黑色。关键的观察是，任何红色节点的更新仅依赖于其四个邻居，而它们都是黑色的。同样，任何黑色节点的更新仅依赖于其红色的邻居。\n\n一次完整的 RBGS 扫描分两个阶段进行：\n$1$. **红色更新**：所有红色节点同时更新。红色节点 $p_{i,j}$ 的新值使用其黑色邻居在前一次迭代（比如说第 $k$ 次迭代）中的值来计算。\n$$\np_{i,j}^{(k+1/2)} = \\frac{ \\alpha_x (p_{i+1,j}^{(k)} + p_{i-1,j}^{(k)}) + \\alpha_y (p_{i,j+1}^{(k)} + p_{i,j-1}^{(k)}) - f_{i,j} }{ 2(\\alpha_x + \\alpha_y) }, \\quad \\text{for all red } (i,j)\n$$\n$2$. **黑色更新**：所有黑色节点同时更新。黑色节点 $p_{i,j}$ 的新值使用其红色邻居在当前扫描（第 $k+1/2$ 次）中新更新的值来计算。\n$$\np_{i,j}^{(k+1)} = \\frac{ \\alpha_x (p_{i+1,j}^{(k+1/2)} + p_{i-1,j}^{(k+1/2)}) + \\alpha_y (p_{i,j+1}^{(k+1/2)} + p_{i,j-1}^{(k+1/2)}) - f_{i,j} }{ 2(\\alpha_x + \\alpha_y) }, \\quad \\text{for all black } (i,j)\n$$\n这两个阶段的结果是第 $k+1$ 次扫描结束时的压力场，记为 $p^{(k+1)}$。\n\n每次完整扫描后，我们必须检查收敛性。这是通过为所有内部节点计算离散残差场 $r_{i,j}$ 来完成的：\n$$\nr_{i,j} = \\alpha_x(p_{i+1,j}-2 p_{i,j}+p_{i-1,j}) + \\alpha_y(p_{i,j+1}-2 p_{i,j}+p_{i,j-1}) - f_{i,j}\n$$\n收敛性通过相对残差范数来评估，该范数定义为残差的离散 $L_2$-范数与源项的离散 $L_2$-范数之比：\n$$\n\\mathrm{RelRes}=\\frac{\\|r\\|_2}{\\|f\\|_2} = \\frac{\\left(\\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y} r_{i,j}^2\\right)^{1/2}}{\\left(\\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y} f_{i,j}^2\\right)^{1/2}}\n$$\n当 $\\mathrm{RelRes} \\le \\varepsilon = 10^{-6}$ 或扫描次数达到最大限制 $N_{\\max}=100000$ 时，迭代过程终止。记录的结果是执行的完整扫描次数。\n\n对于每个 $(N_x, N_y)$ 对的数值实验步骤如下：\n$1$. 为压力 $p$ 设置一个 $(N_y+2) \\times (N_x+2)$ 的网格数组，并初始化为零。这包含了始终固定为零的齐次狄利克雷边界条件。\n$2$. 计算网格间距 $\\Delta x$ 和 $\\Delta y$，以及系数 $\\alpha_x$、$\\alpha_y$。\n$3$. 为内部节点 $i \\in \\{1, \\dots, N_x\\}$, $j \\in \\{1, \\dots, N_y\\}$ 构建源项数组 $f_{i,j}$。计算并存储其 $L_2$-范数 $\\|f\\|_2$。\n$4$. 根据 $i+j$ 的奇偶性创建布尔掩码以识别红色和黑色内部节点。\n$5$. 开始主迭代循环，将扫描计数器初始化为零。\n$6$. 在每个循环中：\n    a. 增加扫描计数器。\n    b. 使用对压力数组的矢量化操作对所有红色内部节点执行红色更新。\n    c. 使用新更新的红色节点值对所有黑色内部节点执行黑色更新。\n    d. 计算内部网格上的残差场 $r$。\n    e. 计算相对残差范数 $\\mathrm{RelRes}$。\n    f. 如果 $\\mathrm{RelRes} \\le 10^{-6}$，则中断循环。\n$7$. 返回最终的扫描次数。对问题陈述中指定的每个测试案例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_rbgs_solver(Nx, Ny):\n    \"\"\"\n    Solves the 2D Poisson equation using Red-Black Gauss-Seidel iteration.\n\n    Args:\n        Nx (int): Number of interior pressure unknowns along x-direction.\n        Ny (int): Number of interior pressure unknowns along y-direction.\n\n    Returns:\n        int: The number of sweeps required to meet the convergence criteria.\n    \"\"\"\n    # Problem parameters\n    epsilon = 1e-6\n    N_max = 100000\n\n    # Grid setup\n    dx = 1.0 / (Nx + 1)\n    dy = 1.0 / (Ny + 1)\n    ax = 1.0 / (dx**2)\n    ay = 1.0 / (dy**2)\n    inv_denom = 1.0 / (2.0 * (ax + ay))\n\n    # Pressure field with boundary layers, initialized to zero\n    # This automatically enforces p=0 boundary conditions.\n    p = np.zeros((Ny + 2, Nx + 2))\n\n    # Source term f\n    # Create coordinate arrays for the full grid (including boundaries)\n    x = np.linspace(0, 1, Nx + 2)\n    y = np.linspace(0, 1, Ny + 2)\n    # The meshgrid is created for the full (Ny+2)x(Nx+2) domain\n    xx, yy = np.meshgrid(x, y) \n\n    f_full = -2.0 * (np.pi**2) * np.sin(np.pi * xx) * np.sin(np.pi * yy)\n    f_interior = f_full[1:-1, 1:-1]\n    norm_f = np.linalg.norm(f_interior)\n    \n    # Pre-compute Red-Black masks for interior points\n    # Index grid for interior points (1 to N, for formula i+j)\n    J, I = np.meshgrid(np.arange(1, Ny + 1), np.arange(1, Nx + 1), indexing='ij')\n    # red_mask: where i+j is even\n    red_mask = (I + J) % 2 == 0\n    # black_mask: where i+j is odd\n    black_mask = ~red_mask\n\n    sweeps = 0\n    for k in range(N_max):\n        sweeps += 1\n\n        # --- Red Update ---\n        # The update for red points depends on their black neighbors.\n        # We can calculate the update for all interior points based on the current\n        # state of p, and then apply it only to the red points.\n        neighbors_sum = (ax * (p[1:-1, 2:] + p[1:-1, :-2]) +\n                         ay * (p[2:, 1:-1] + p[:-2, 1:-1]))\n        p_new_interior = (neighbors_sum - f_interior) * inv_denom\n        p[1:-1, 1:-1][red_mask] = p_new_interior[red_mask]\n\n        # --- Black Update ---\n        # The update for black points depends on their red neighbors, which\n        # have just been updated. Recalculate and apply.\n        neighbors_sum = (ax * (p[1:-1, 2:] + p[1:-1, :-2]) +\n                         ay * (p[2:, 1:-1] + p[:-2, 1:-1]))\n        p_new_interior = (neighbors_sum - f_interior) * inv_denom\n        p[1:-1, 1:-1][black_mask] = p_new_interior[black_mask]\n\n        # --- Convergence Check after a full sweep ---\n        # Calculate the discrete Laplacian of the updated pressure field p\n        laplacian_p = (ax * (p[1:-1, 2:] + p[1:-1, :-2] - 2.0 * p[1:-1, 1:-1]) +\n                       ay * (p[2:, 1:-1] + p[:-2, 1:-1] - 2.0 * p[1:-1, 1:-1]))\n        \n        # Calculate the residual field r = A*p - f\n        r = laplacian_p - f_interior\n        \n        # Calculate the relative residual norm\n        rel_res = np.linalg.norm(r) / norm_f\n        \n        if rel_res <= epsilon:\n            break\n            \n    return sweeps\n\ndef solve():\n    \"\"\"\n    Main function to run the experiment for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (32, 32), # Case 1\n        (48, 12), # Case 2\n        (12, 48), # Case 3\n        (8, 8),   # Case 4\n        (64, 16), # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny = case\n        result = run_rbgs_solver(Nx, Ny)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "迭代法并非求解压力泊松方程的唯一途径。对于具有周期性边界条件的特殊情况，存在一种更为高效和精确的直接解法。本练习将向您介绍如何利用快速傅里叶变换（FFT）在傅里叶空间中直接求解泊松方程，这种方法被称为谱方法。您不仅将实现一个优雅的算法，还将学习使用“人造解法”（method of manufactured solutions）来验证代码的正确性，这本身就是计算科学中的一项重要技能 [@problem_id:2438385]。", "id": "2438385", "problem": "要求您在标记-单元（MAC）网格上，针对两个空间方向均为周期性边界条件的情况，推导并实现一个压力泊松方程求解器。该求解器使用由快速傅里叶变换（FFT）加速的离散傅里叶变换（DFT）。目标是展示一个正确且高效的谱方法解，该解与交错MAC网格上的二阶中心差分离散格式相一致。本问题设定为无量纲，因此不需要物理单位。三角函数中的角度必须视为弧度。\n\n起始点和定义：\n- 考虑一个矩形域 $\\Omega = [0,L_x) \\times [0,L_y)$，将其离散为 $N_x \\times N_y$ 个均匀尺寸的单元格，间距分别为 $\\Delta x = L_x / N_x$ 和 $\\Delta y = L_y / N_y$。\n- 在MAC网格布局中，压力 $p$ 存储在单元格中心，其索引为 $(i,j)$，其中 $i \\in \\{0,\\dots,N_x-1\\}$ 且 $j \\in \\{0,\\dots,N_y-1\\}$。设中心坐标为 $x_i = (i + \\tfrac{1}{2}) \\Delta x$ 和 $y_j = (j + \\tfrac{1}{2}) \\Delta y$。\n- 单元格中心上的离散拉普拉斯算子由具有周期性索引的标准二阶中心差分模板定义：\n$$\n(\\nabla_h^2 p)_{i,j} = \\frac{p_{i+1,j} - 2 p_{i,j} + p_{i-1,j}}{\\Delta x^2} + \\frac{p_{i,j+1} - 2 p_{i,j} + p_{i,j-1}}{\\Delta y^2},\n$$\n其中索引是周期性环绕的，例如 $p_{-1,j} \\equiv p_{N_x-1,j}$ 和 $p_{N_x,j} \\equiv p_{0,j}$，在 $y$ 方向上类似。\n\n任务A（推导）：\n- 从MAC网格上的不可压缩流投影思想和离散无散度约束出发，论证为何在周期性边界条件下，一个位于单元格中心的压力 $p$ 应满足形式为\n$$\n\\nabla_h^2 p = f,\n$$\n的离散泊松方程（允许相差一个任意的加性常数）。接着，证明对于周期性网格，DFT可以对角化离散拉普拉斯算子。用 $N_x$、$N_y$、$\\Delta x$、$\\Delta y$ 和离散波数索引来推导离散拉普拉斯算子的傅里叶空间特征值。讨论如何处理零波数（平均）模态，以使计算出的压力具有零空间平均值。\n\n任务B（实现）：\n- 实现一个程序，使用FFT求解离散泊松方程，并用几个人工解进行测试。对于每个测试，通过将上述定义的离散拉普拉斯算子应用于一个已知的单元格中心压力场 $p^{\\mathrm{true}}$，来构造一个“右端项”$f$。然后，在傅里叶空间中求解以恢复 $p$，并对恢复的解强制施加零均值规范。报告在减去各自的空间平均值后，恢复的 $p$ 与人工解 $p^{\\mathrm{true}}$ 之间的最大绝对网格点误差。\n\n离散化和数值约定：\n- 所有三角函数的参数均以弧度为单位。\n- 对于每个测试，在单元格中心上定义 $p^{\\mathrm{true}}(x,y)$，并严格按照上面给出的离散算子 $(\\nabla_h^2 p)_{i,j}$ 计算 $f$。\n- 通过使用DFT进行对角化并利用FFT提高效率来求解具有周期性边界条件的 $\\nabla_h^2 p = f$。将 $p$ 的零波数傅里叶系数显式设置为零，以施加零均值规范。\n\n测试套件：\n实现以下测试用例。对于每个用例，计算一个浮点数，其值等于恢复的 $p$ 和人工解 $p^{\\mathrm{true}}$ 在减去各自的空间平均值后的最大绝对误差。\n\n- 测试 1 (理想情况): $N_x = 32$, $N_y = 24$, $L_x = 1$, $L_y = 1$, 以及\n$$\np^{\\mathrm{true}}(x,y) = \\sin(2\\pi x) + \\cos(4\\pi y).\n$$\n- 测试 2 (域长度与波数不成比例): $N_x = 17$, $N_y = 19$, $L_x = 2$, $L_y = 1$, 以及\n$$\np^{\\mathrm{true}}(x,y) = \\sin\\!\\Big(2\\pi \\cdot 3 \\frac{x}{L_x}\\Big) + \\sin\\!\\Big(2\\pi \\cdot 5 \\frac{y}{L_y}\\Big).\n$$\n- 测试 3 (零右端项): $N_x = 20$, $N_y = 12$, $L_x = 1$, $L_y = 1$, 以及\n$$\np^{\\mathrm{true}}(x,y) \\equiv 0.\n$$\n- 测试 4 (各向异性网格和域): $N_x = 64$, $N_y = 8$, $L_x = 1$, $L_y = 2$, 以及\n$$\np^{\\mathrm{true}}(x,y) = \\cos\\!\\Big(2\\pi \\cdot 2 \\frac{x}{L_x}\\Big) + \\cos\\!\\Big(2\\pi \\cdot 1 \\frac{y}{L_y}\\Big).\n$$\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含四个测试的结果，以逗号分隔的列表形式，并用方括号括起来，按测试1到测试4的顺序排列，例如\n$[e_1,e_2,e_3,e_4]$,\n其中每个 $e_k$ 是一个浮点数。", "solution": "所述问题是有效的。它在科学上基于计算流体动力学的原理，特别是不可压缩流的投影方法。其数学表述是适定的，提供了一个具有周期性边界条件和明确规范条件（零平均压力）的离散泊松方程，以确保解的唯一性。所有参数和数值方法都得到了明确的规定，使问题自洽且可解。这是偏微分方程数值方法中的一个标准、客观的练习。\n\n我们将着手进行推导和求解。\n\n压力泊松方程是模拟不可压缩流算法（如投影法）的基石。在这种方法中，首先计算一个中间的、非无散的速度场，然后将其投影到无散度矢量场的空间上。这个投影步骤需要求解一个标量场的泊松方程，该标量场被解释为压力。\n\n在二维域 $\\Omega = [0,L_x) \\times [0,L_y)$ 上待求解的方程的离散形式是\n$$\n\\nabla_h^2 p = f\n$$\n其中 $p$ 是在单元格中心 $(i,j)$（$i \\in \\{0, \\dots, N_x-1\\}$ 且 $j \\in \\{0, \\dots, N_y-1\\}$）上定义的压力场， $f$ 是给定的源项，代表了中间速度场的散度。网格间距为 $\\Delta x = L_x / N_x$ 和 $\\Delta y = L_y / N_y$。离散拉普拉斯算子 $\\nabla_h^2$ 由二阶中心差分公式给出：\n$$\n(\\nabla_h^2 p)_{i,j} = \\frac{p_{i+1,j} - 2 p_{i,j} + p_{i-1,j}}{\\Delta x^2} + \\frac{p_{i,j+1} - 2 p_{i,j} + p_{i,j-1}}{\\Delta y^2}\n$$\n域在两个方向上都是周期性的，这意味着所有索引都对其各自的网格维度取模，例如 $p_{N_x,j} \\equiv p_{0,j}$ 和 $p_{-1,j} \\equiv p_{N_x-1,j}$。\n\n在周期性域上，该方程存在解的一个必要条件是源项 $f$ 必须具有零均值。我们可以通过对所有网格单元上的方程求和来证明这一点：\n$$\n\\sum_{j=0}^{N_y-1} \\sum_{i=0}^{N_x-1} (\\nabla_h^2 p)_{i,j} = \\sum_{j=0}^{N_y-1} \\sum_{i=0}^{N_x-1} f_{i,j}\n$$\n我们来考察拉普拉斯项的和。由于周期性，求和是伸缩式的，其结果为零：\n$$\n\\sum_{i=0}^{N_x-1} (p_{i+1,j} - 2 p_{i,j} + p_{i-1,j}) = (p_{1,j} - p_{0,j}) - (p_{0,j} - p_{N_x-1,j}) + \\dots + (p_{0,j} - p_{N_x-1,j}) - (p_{N_x-1,j} - p_{N_x-2,j}) = 0\n$$\n由于这对拉普拉斯算子的每个分量和每个方向都成立，所以总和为零。\n$$\n\\sum_{j=0}^{N_y-1} \\sum_{i=0}^{N_x-1} (\\nabla_h^2 p)_{i,j} = 0\n$$\n因此，只有当满足相容性条件时，解才可能存在：\n$$\n\\sum_{j=0}^{N_y-1} \\sum_{i=0}^{N_x-1} f_{i,j} = 0\n$$\n在本问题中，右端项 $f$ 是通过将离散拉普拉斯算子应用于已知场 $p^{\\mathrm{true}}$ 来构造的，即 $f = \\nabla_h^2 p^{\\mathrm{true}}$。这种构造方式内在地满足了相容性条件。\n\n解 $p$ 仅在一个加性常数内是唯一的，因为对于任何常数 $C$，$\\nabla_h^2(p+C) = \\nabla_h^2 p$。为了获得唯一解，我们施加一个规范条件。问题指定了一个零均值解，即 $\\sum_{j,i} p_{i,j} = 0$。\n\n对于周期性边界条件，离散拉普拉斯算子是一个线性、移位不变算子。其特征函数是离散傅里叶变换（DFT）的复指数。对于网格函数 $q_{i,j}$ 的二维DFT对由以下公式给出：\n$$\n\\hat{q}_{k,l} = \\sum_{j=0}^{N_y-1} \\sum_{i=0}^{N_x-1} q_{i,j} e^{-i 2\\pi (ki/N_x + lj/N_y)} \\quad \\text{(正变换)}\n$$\n$$\nq_{i,j} = \\frac{1}{N_x N_y} \\sum_{l=0}^{N_y-1} \\sum_{k=0}^{N_x-1} \\hat{q}_{k,l} e^{i 2\\pi (ki/N_x + lj/N_y)} \\quad \\text{(逆变换)}\n$$\n其中 $k \\in \\{0, \\dots, N_x-1\\}$ 和 $l \\in \\{0, \\dots, N_y-1\\}$ 是离散波数索引。为了找到 $\\nabla_h^2$ 的特征值，我们将其应用于单个傅里叶模态 $E_{i,j}^{(k,l)} = e^{i 2\\pi (ki/N_x + lj/N_y)}$：\n$$\n(\\nabla_h^2 E^{(k,l)})_{i,j} = \\frac{E_{i+1,j}^{(k,l)} - 2 E_{i,j}^{(k,l)} + E_{i-1,j}^{(k,l)}}{\\Delta x^2} + \\frac{E_{i,j+1}^{(k,l)} - 2 E_{i,j}^{(k,l)} + E_{i,j-1}^{(k,l)}}{\\Delta y^2}\n$$\n代入 $E_{i,j}^{(k,l)}$ 的表达式：\n$$\n(\\nabla_h^2 E^{(k,l)})_{i,j} = E_{i,j}^{(k,l)} \\left[ \\frac{e^{i 2\\pi k/N_x} - 2 + e^{-i 2\\pi k/N_x}}{\\Delta x^2} + \\frac{e^{i 2\\pi l/N_y} - 2 + e^{-i 2\\pi l/N_y}}{\\Delta y^2} \\right]\n$$\n使用恒等式 $e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$，上式可简化为：\n$$\n(\\nabla_h^2 E^{(k,l)})_{i,j} = E_{i,j}^{(k,l)} \\left[ \\frac{2\\cos(2\\pi k/N_x) - 2}{\\Delta x^2} + \\frac{2\\cos(2\\pi l/N_y) - 2}{\\Delta y^2} \\right]\n$$\n使用半角恒等式 $2\\cos(\\theta) - 2 = -4\\sin^2(\\theta/2)$，我们得到离散拉普拉斯算子的特征值 $\\lambda_{k,l}$：\n$$\n\\lambda_{k,l} = -\\frac{4}{\\Delta x^2} \\sin^2\\left(\\frac{\\pi k}{N_x}\\right) - \\frac{4}{\\Delta y^2} \\sin^2\\left(\\frac{\\pi l}{N_y}\\right)\n$$\n对泊松方程 $\\nabla_h^2 p = f$ 应用正向DFT，会将其转换为傅里叶空间中的一个代数方程：\n$$\n\\lambda_{k,l} \\hat{p}_{k,l} = \\hat{f}_{k,l}\n$$\n其中 $\\hat{p}$ 和 $\\hat{f}$ 分别是 $p$ 和 $f$ 的DFT。解的傅里叶系数则通过除法得到：\n$$\n\\hat{p}_{k,l} = \\frac{\\hat{f}_{k,l}}{\\lambda_{k,l}}\n$$\n我们必须考虑 $(k,l)=(0,0)$ 的情况，它对应于场的平均值（直流分量）。对于该模态，$\\lambda_{0,0} = 0$。相容性条件确保 $\\hat{f}_{0,0} = \\sum_{i,j} f_{i,j} = 0$，导致 $0/0$ 的不定形式。这种不确定性反映了压力解仅在一个常数内唯一的事实。$\\hat{p}_{0,0}$ 的值与 $p$ 的平均值成正比。为了施加指定的零均值规范条件，我们显式地将解的直流分量设置为零：\n$$\n\\hat{p}_{0,0} = 0\n$$\n对于所有其他模态 $(k,l) \\neq (0,0)$，特征值 $\\lambda_{k,l}$ 严格为负，因此除法是良定义的。\n\n总体算法如下：\n1.  构建网格和在单元格中心的真实压力场 $p^{\\mathrm{true}}$。\n2.  通过将离散拉普拉斯算子 $\\nabla_h^2$ 应用于 $p^{\\mathrm{true}}$（使用周期性移位）来计算右端项 $f$。\n3.  使用快速傅里叶变换（FFT）算法计算 $f$ 的二维DFT，以获得 $\\hat{f}_{k,l}$，从而提高效率。\n4.  构造与FFT例程的波数排序相对应的特征值矩阵 $\\lambda_{k,l}$。必须特别注意负频率。\n5.  对于所有非零模态，通过将 $\\hat{f}_{k,l}$ 除以 $\\lambda_{k,l}$ 来计算压力的傅里叶系数 $\\hat{p}_{k,l}$。设置 $\\hat{p}_{0,0}=0$。\n6.  通过对 $\\hat{p}_{k,l}$ 应用二维逆DFT（iFFT）来计算恢复的压力场 $p$。结果将是一个实值场，误差在机器精度范围内。\n7.  为了进行误差检查，从原始的 $p^{\\mathrm{true}}$ 和恢复的 $p$ 中减去其空间平均值。\n8.  误差是这两个零均值场在整个网格上的最大绝对差。由于此构造问题的谱方法是精确的，误差预计在机器爱普西隆的量级上。", "answer": "```python\nimport numpy as np\n\ndef solve_poisson_fft(Nx, Ny, Lx, Ly, p_true_func):\n    \"\"\"\n    Solves the 2D pressure Poisson equation on a periodic MAC grid using FFT.\n\n    Args:\n        Nx (int): Number of cells in the x-direction.\n        Ny (int): Number of cells in the y-direction.\n        Lx (float): Domain length in the x-direction.\n        Ly (float): Domain length in the y-direction.\n        p_true_func (callable): Function defining the true pressure p_true(x, y).\n\n    Returns:\n        float: The maximum absolute error between the recovered pressure and the\n               true pressure, after both are set to have zero mean.\n    \"\"\"\n    # 1. Grid and true pressure setup\n    dx = Lx / Nx\n    dy = Ly / Ny\n\n    # Create cell-centered coordinates\n    x = (np.arange(Nx) + 0.5) * dx\n    y = (np.arange(Ny) + 0.5) * dy\n    x_grid, y_grid = np.meshgrid(x, y, indexing='xy') # Shape: (Ny, Nx)\n\n    p_true = p_true_func(x_grid, y_grid)\n\n    # 2. Compute the right-hand side f = laplacian(p_true)\n    # np.roll provides periodic boundary conditions\n    p_ip1 = np.roll(p_true, -1, axis=1)\n    p_im1 = np.roll(p_true, 1, axis=1)\n    p_jp1 = np.roll(p_true, -1, axis=0)\n    p_jm1 = np.roll(p_true, 1, axis=0)\n\n    laplacian_p = (p_ip1 - 2 * p_true + p_im1) / (dx**2) + \\\n                  (p_jp1 - 2 * p_true + p_jm1) / (dy**2)\n    f = laplacian_p\n\n    # 3. Forward FFT of the RHS\n    f_hat = np.fft.fft2(f)\n\n    # 4. Construct eigenvalues of the discrete Laplacian in Fourier space\n    # Use np.fft.fftfreq to get frequencies in cycles per grid point,\n    # which simplifies the sin argument.\n    freq_x = np.fft.fftfreq(Nx) # Shape (Nx,)\n    freq_y = np.fft.fftfreq(Ny) # Shape (Ny,)\n\n    # Create 2D frequency grids\n    # Note: meshgrid produces arrays with shape (Ny, Nx)\n    freq_x_grid, freq_y_grid = np.meshgrid(freq_x, freq_y, indexing='xy')\n\n    # Eigenvalues: lambda_kl = -4/dx^2 * sin^2(pi*k/Nx) - 4/dy^2 * sin^2(pi*l/Ny)\n    # With k/Nx = freq_x and l/Ny = freq_y\n    lambda_kl = (-4.0 / (dx**2)) * np.sin(np.pi * freq_x_grid)**2 \\\n              + (-4.0 / (dy**2)) * np.sin(np.pi * freq_y_grid)**2\n\n    # 5. Solve for p_hat in Fourier space\n    # Avoid division by zero for the (0,0) mode\n    # The compatibility condition f_hat[0,0] ~ 0 is met by construction\n    # Make a copy to modify\n    lambda_kl_inv = np.zeros_like(lambda_kl)\n    # Set inverse for all non-zero modes\n    non_zero_modes = lambda_kl != 0\n    lambda_kl_inv[non_zero_modes] = 1.0 / lambda_kl[non_zero_modes]\n    \n    # Calculate p_hat, the zero-mean gauge is naturally enforced\n    # because term for k=l=0 is 0 * 0.\n    p_hat = f_hat * lambda_kl_inv\n    \n    # Explicitly enforce zero-mean gauge by setting DC component to zero,\n    # which is good practice. In this case, it's already zero.\n    p_hat[0, 0] = 0.0\n\n    # 6. Inverse FFT to get recovered pressure\n    p_recovered = np.fft.ifft2(p_hat).real\n\n    # 7. Error calculation\n    # Subtract means to compare on an equal footing\n    p_true_zero_mean = p_true - np.mean(p_true)\n    p_recovered_zero_mean = p_recovered - np.mean(p_recovered)\n\n    # 8. Compute max absolute error\n    max_error = np.max(np.abs(p_true_zero_mean - p_recovered_zero_mean))\n    \n    return max_error\n\n\ndef solve():\n    \"\"\"\n    Runs the test suite and prints the final results.\n    \"\"\"\n    test_cases = [\n        # Test 1\n        {\n            \"Nx\": 32, \"Ny\": 24, \"Lx\": 1.0, \"Ly\": 1.0,\n            \"p_true_func\": lambda x, y: np.sin(2 * np.pi * x) + np.cos(4 * np.pi * y)\n        },\n        # Test 2\n        {\n            \"Nx\": 17, \"Ny\": 19, \"Lx\": 2.0, \"Ly\": 1.0,\n            \"p_true_func\": lambda x, y: np.sin(2 * np.pi * 3 * x / 2.0) + np.sin(2 * np.pi * 5 * y / 1.0)\n        },\n        # Test 3\n        {\n            \"Nx\": 20, \"Ny\": 12, \"Lx\": 1.0, \"Ly\": 1.0,\n            \"p_true_func\": lambda x, y: np.zeros_like(x)\n        },\n        # Test 4\n        {\n            \"Nx\": 64, \"Ny\": 8, \"Lx\": 1.0, \"Ly\": 2.0,\n            \"p_true_func\": lambda x, y: np.cos(2 * np.pi * 2 * x / 1.0) + np.cos(2 * np.pi * 1 * y / 2.0)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_poisson_fft(\n            case[\"Nx\"], case[\"Ny\"], case[\"Lx\"], case[\"Ly\"], case[\"p_true_func\"])\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}