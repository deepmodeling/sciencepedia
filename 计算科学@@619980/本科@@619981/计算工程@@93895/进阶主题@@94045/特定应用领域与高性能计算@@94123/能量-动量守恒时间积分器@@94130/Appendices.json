{"hands_on_practices": [{"introduction": "在对行星轨道或分子动力学等保守系统进行长期模拟时，传统的数值方法（如龙格-库塔法）会引入人为的能量漂移，导致结果不符合物理规律。辛积分器（如Verlet方法）旨在保持哈密顿系统的几何结构，从而实现出色的长期能量稳定性。本练习提供了辛积分器和非辛积分器之间的直接上手比较，通过模拟简单的粒子碰撞，你将观察到它们在能量守恒和时间可逆性方面的根本性能差异，从而建立起对为何需要专门积分器的基本理解。[@problem_id:2444593]", "problem": "考虑一个一维哈密顿系统，该系统包含两个相同的点粒子，其位置为 $x_1(t)$ 和 $x_2(t)$，速度为 $v_1(t)$ 和 $v_2(t)$，质量为 $m$。相互作用是一个陡峭的排斥势垒，由以下势能描述：\n$$\nV(r) \\;=\\; \\varepsilon \\left(\\frac{\\sigma}{\\sqrt{r^2+\\delta^2}}\\right)^{12},\n$$\n其中 $r = x_2 - x_1$ 是带符号间距，$\\varepsilon > 0$ 设定了能量标度，$\\sigma > 0$ 设定了长度标度，$\\delta > 0$ 是一个小的软化参数，以确保当 $r \\to 0$ 时 $V(r)$ 保持有限。该系统的哈密顿量为\n$$\nH \\;=\\; \\frac{p_1^2}{2m} + \\frac{p_2^2}{2m} + V(x_2 - x_1),\n$$\n其中正则动量为 $p_i = m v_i$。运动方程为哈密顿方程，\n$$\n\\dot{x}_i \\;=\\; \\frac{\\partial H}{\\partial p_i} \\;=\\; \\frac{p_i}{m}, \\qquad \\dot{p}_i \\;=\\; -\\frac{\\partial H}{\\partial x_i},\n$$\n这等价于由势能推导出的力所描述的牛顿第二定律。对于给定的 $V(r)$ 和带符号间距 $r = x_2 - x_1$，作用于粒子 1 的力为\n$$\nF_1 \\;=\\; -\\frac{\\partial V}{\\partial x_1} \\;=\\; \\frac{\\mathrm{d}V}{\\mathrm{d}r}, \\quad \\text{作用于粒子 2 的力为} \\quad F_2 \\;=\\; -\\frac{\\mathrm{d}V}{\\mathrm{d}r},\n$$\n其中\n$$\n\\frac{\\mathrm{d}V}{\\mathrm{d}r} \\;=\\; -12\\,\\varepsilon\\,\\sigma^{12}\\,\\frac{r}{\\left(r^2+\\delta^2\\right)^{7}}.\n$$\n\n使用约化单位，其中 $\\varepsilon = 1$，$\\sigma = 1$，且 $m = 1$，因此能量是 $\\varepsilon$ 的无量纲倍数，长度以 $\\sigma$ 为单位，时间以 $\\tau = \\sigma \\sqrt{m/\\varepsilon}$ 为单位。本问题不涉及角度。在时间 $t=0$ 初始化系统，设置\n$$\nx_1(0) = -2.0, \\quad x_2(0) = +2.0, \\quad v_1(0) = +0.8, \\quad v_2(0) = -0.8,\n$$\n并使用 $\\delta = 10^{-2}$。设总积分时间为 $T = 8.0$。\n\n对每个指定的时间步长 $\\Delta t$，您的程序必须对上述系统执行两次独立的数值时间积分：一次使用速度 Verlet（辛，二阶）方法，另一次使用经典的显式四阶龙格-库塔方法。对于每次积分，计算以下定量诊断指标：\n- 绝对末态能量误差 $|H(T) - H(0)|$。\n- 轨迹上的最大相对能量误差 $\\max_{0 \\le t \\le T} |H(t) - H(0)| / |H(0)|$。\n- 末态时刻的速度交换误差，定义为末态速度与在中心排斥作用下相同质量粒子对心弹性散射的预期结果之间的欧几里得范数。在此设定的约化单位下，相互作用并再次分离后的预期末态速度为 $v_1^\\star = -0.8$ 和 $v_2^\\star = +0.8$。速度交换误差为\n$$\nE_{\\mathrm{swap}} \\;=\\; \\sqrt{\\left(v_1(T) - v_1^\\star\\right)^2 + \\left(v_2(T) - v_2^\\star\\right)^2}。\n$$\n- 时间可逆性误差，其计算方法是：使用固定的 $\\Delta t$ 从初始状态向前积分时间 $T$，然后使用相同的算法和步长大小但步长为负值 $-\\Delta t$ 向后积分时间 $T$，并将结果与初始状态进行比较。将时间可逆性误差定义为相空间中的欧几里得范数，\n$$\nE_{\\mathrm{rev}} \\;=\\; \\sqrt{\\left(x_1^{\\mathrm{back}} - x_1(0)\\right)^2 + \\left(x_2^{\\mathrm{back}} - x_2(0)\\right)^2 + \\left(v_1^{\\mathrm{back}} - v_1(0)\\right)^2 + \\left(v_2^{\\mathrm{back}} - v_2(0)\\right)^2 }。\n$$\n\n测试套件：\n使用以下三个时间步长 $\\Delta t$：\n- $\\Delta t = 0.02$,\n- $\\Delta t = 0.005$,\n- $\\Delta t = 0.0005$.\n对于每个 $\\Delta t$，执行两种积分（速度 Verlet 和经典的显式四阶龙格-库塔），并按此顺序报告包含八个浮点数的列表\n$$\n\\left[\\, |H(T) - H(0)|_{\\mathrm{Verlet}},\\; |H(T) - H(0)|_{\\mathrm{RK4}},\\; \\max\\frac{|H - H(0)|}{|H(0)|}_{\\mathrm{Verlet}},\\; \\max\\frac{|H - H(0)|}{|H(0)|}_{\\mathrm{RK4}},\\; E_{\\mathrm{swap}}^{\\mathrm{Verlet}},\\; E_{\\mathrm{swap}}^{\\mathrm{RK4}},\\; E_{\\mathrm{rev}}^{\\mathrm{Verlet}},\\; E_{\\mathrm{rev}}^{\\mathrm{RK4}} \\,\\right]。\n$$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。该列表必须为每个测试用例包含一个元素，其中每个元素本身是包含八个所要求的浮点值的、用方括号括起来的逗号分隔列表。例如，总体格式必须是\n$$\n\\big[\\, [a_{11},a_{12},\\dots,a_{18}],\\; [a_{21},\\dots,a_{28}],\\; [a_{31},\\dots,a_{38}] \\,\\big]。\n$$\n所有值在指定的约化单位下都是无量纲的。不要打印任何附加文本。答案必须是执行这些计算并打印所需的单行输出的完整可运行程序。", "solution": "所提出的问题是计算物理学中的一个经典练习，具体涉及哈密顿系统的数值积分。它要求对两种不同的积分算法进行比较分析：速度 Verlet 方法（属于二阶辛积分器）和经典的显式四阶龙格-库塔 (RK4) 方法（一种通用的非辛格式）。目的是评估它们在一个由陡峭排斥势能支配的一维双粒子系统上的性能。评估基于数值积分器的标准度量：能量守恒、相空间轨迹的准确性以及时间可逆性。该问题是适定的，有科学依据，并为完整求解提供了所有必要的参数和初始条件。\n\n系统由约化单位（$m=1, \\varepsilon=1, \\sigma=1$）下的哈密顿量描述：\n$$\nH(x_1, x_2, p_1, p_2) \\;=\\; \\frac{1}{2}(p_1^2 + p_2^2) + V(x_2 - x_1)\n$$\n其中 $p_i = v_i$ 是正则动量（因为 $m=1$），势能由下式给出：\n$$\nV(r) \\;=\\; \\left(\\frac{1}{\\sqrt{r^2+\\delta^2}}\\right)^{12} \\;=\\; (r^2+\\delta^2)^{-6}\n$$\n其中 $r=x_2-x_1$ 是带符号间距，$\\delta=10^{-2}$ 是软化参数。\n\n哈密顿运动方程为 $\\dot{x}_i = \\partial H / \\partial p_i$ 和 $\\dot{p}_i = -\\partial H / \\partial x_i$。由此可得：\n$$\n\\dot{x}_i \\;=\\; p_i\n$$\n$$\n\\dot{p}_1 \\;=\\; -\\frac{\\partial V}{\\partial x_1} \\;=\\; -\\frac{\\mathrm{d}V}{\\mathrm{d}r}\\frac{\\partial r}{\\partial x_1} \\;=\\; -\\frac{\\mathrm{d}V}{\\mathrm{d}r}(-1) \\;=\\; \\frac{\\mathrm{d}V}{\\mathrm{d}r}\n$$\n$$\n\\dot{p}_2 \\;=\\; -\\frac{\\partial V}{\\partial x_2} \\;=\\; -\\frac{\\mathrm{d}V}{\\mathrm{d}r}\\frac{\\partial r}{\\partial x_2} \\;=\\; -\\frac{\\mathrm{d}V}{\\mathrm{d}r}(1) \\;=\\; -\\frac{\\mathrm{d}V}{\\mathrm{d}r}\n$$\n势能对间距 $r$ 的导数为：\n$$\n\\frac{\\mathrm{d}V}{\\mathrm{d}r} \\;=\\; -12\\,r\\,(r^2+\\delta^2)^{-7}\n$$\n由于质量是单位值，加速度为 $a_i = \\dot{p}_i$。因此：\n$$\na_1(r) = -12\\,r\\,(r^2+\\delta^2)^{-7} \\quad \\text{以及} \\quad a_2(r) = 12\\,r\\,(r^2+\\delta^2)^{-7}\n$$\n这些运动方程从初始状态 $(x_1(0), x_2(0), v_1(0), v_2(0)) = (-2.0, 2.0, 0.8, -0.8)$ 进行数值积分，直到最终时间 $T=8.0$。\n\n两种数值积分方法的实现如下：\n\n1.  **速度 Verlet 算法**：这是一种几何积分器，具体来说是一种二阶辛方法，它也是时间可逆的。其对于哈密顿系统的关键特征是能够长期保持一个邻近的“影子”哈密顿量守恒，从而防止长期的能量漂移。对于一个时间步长 $\\Delta t$，状态从时间 $t$ 推进到 $t+\\Delta t$ 经过三个步骤：\n    1.  更新速度半步：$v_i(t + \\Delta t/2) = v_i(t) + \\frac{1}{2} a_i(\\mathbf{x}(t)) \\Delta t$。\n    2.  更新位置一整步：$x_i(t + \\Delta t) = x_i(t) + v_i(t + \\Delta t/2) \\Delta t$。\n    3.  计算新加速度 $a_i(\\mathbf{x}(t+\\Delta t))$ 并更新速度的后半步：$v_i(t + \\Delta t) = v_i(t + \\Delta t/2) + \\frac{1}{2} a_i(\\mathbf{x}(t + \\Delta t)) \\Delta t$。\n\n2.  **经典四阶龙格-库塔 (RK4) 算法**：这是一种广泛使用的高精度通用积分器。它不是辛的，也不是时间可逆的。对于给定的步长，它在短积分周期内通常表现出优越的准确性，但在哈密顿系统的长期模拟中会遭受系统性能量漂移。对于一个常微分方程组 $\\dot{\\mathbf{y}} = \\mathbf{f}(t, \\mathbf{y})$，其中状态向量为 $\\mathbf{y} = (x_1, x_2, v_1, v_2)^T$，从 $\\mathbf{y}_n$ 到 $\\mathbf{y}_{n+1}$ 的更新过程如下：\n    $$\n    \\mathbf{k}_1 = \\mathbf{f}(t_n, \\mathbf{y}_n)\n    $$\n    $$\n    \\mathbf{k}_2 = \\mathbf{f}(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2}\\mathbf{k}_1)\n    $$\n    $$\n    \\mathbf{k}_3 = \\mathbf{f}(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2}\\mathbf{k}_2)\n    $$\n    $$\n    \\mathbf{k}_4 = \\mathbf{f}(t_n + \\Delta t, \\mathbf{y}_n + \\Delta t \\mathbf{k}_3)\n    $$\n    $$\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n    $$\n    在这里，导数函数为 $\\mathbf{f}(\\mathbf{y}) = (v_1, v_2, a_1(x_1,x_2), a_2(x_1,x_2))^T$。\n\n对于每种积分器和每个指定的时间步长 $\\Delta t \\in \\{0.02, 0.005, 0.0005\\}$，计算四个诊断量：\n- **绝对末态能量误差**：$|H(T) - H(0)|$。对于辛积分器，该值预计会很小，但未必是最小的，因为误差是振荡的。对于 RK4，该误差预计会表现出漂移，随时间增长。\n- **最大相对能量误差**：$\\max_{0 \\le t \\le T} |H(t) - H(0)| / |H(0)|$。这衡量了在整个轨迹上能量的峰值偏差。\n- **速度交换误差**：$E_{\\mathrm{swap}} = \\sqrt{(v_1(T) - v_1^\\star)^2 + (v_2(T) - v_2^\\star)^2}$，其中 $(v_1^\\star, v_2^\\star)=(-0.8, 0.8)$ 是理想弹性碰撞的预期末态速度。此度量量化了相空间轨迹的准确性。\n- **时间可逆性误差**：$E_{\\mathrm{rev}}$。其计算方法是向前积分至时间 $T$，然后使用负步长 $-\\Delta t$ 向后积分至时间 $0$。误差是末态与初态偏差的范数。像 Verlet 这样的时间可逆算法应该产生一个非常小的、接近机器精度的误差，而非可逆算法如 RK4 则会显示一个与 $\\Delta t$ 成比例的显著误差。\n\n计算根据这些原则进行，并按规定汇总结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-particle collision problem using Velocity Verlet and RK4 integrators.\n    \"\"\"\n    \n    # System parameters in reduced units\n    m = 1.0\n    epsilon = 1.0\n    sigma = 1.0\n    delta = 1.0e-2\n\n    # Initial conditions\n    x1_0, x2_0 = -2.0, 2.0\n    v1_0, v2_0 = 0.8, -0.8\n    initial_state = np.array([x1_0, x2_0, v1_0, v2_0])\n\n    # Simulation parameters\n    T_final = 8.0\n    test_dts = [0.02, 0.005, 0.0005]\n    \n    v1_star, v2_star = -0.8, 0.8\n\n    # Helper functions\n    def get_potential(r):\n        return (r**2 + delta**2)**(-6)\n\n    def get_accelerations(x1, x2):\n        r = x2 - x1\n        common_factor = -12.0 * r * (r**2 + delta**2)**(-7.0)\n        a1 = common_factor / m\n        a2 = -common_factor / m\n        return a1, a2\n\n    def get_hamiltonian(state):\n        x1, x2, v1, v2 = state\n        kinetic = 0.5 * m * (v1**2 + v2**2)\n        potential = get_potential(x2 - x1)\n        return kinetic + potential\n\n    def step_verlet(state, dt):\n        x1, x2, v1, v2 = state\n        a1_t, a2_t = get_accelerations(x1, x2)\n        \n        v1_half = v1 + 0.5 * a1_t * dt\n        v2_half = v2 + 0.5 * a2_t * dt\n        \n        x1_new = x1 + v1_half * dt\n        x2_new = x2 + v2_half * dt\n        \n        a1_t_dt, a2_t_dt = get_accelerations(x1_new, x2_new)\n        \n        v1_new = v1_half + 0.5 * a1_t_dt * dt\n        v2_new = v2_half + 0.5 * a2_t_dt * dt\n        \n        return np.array([x1_new, x2_new, v1_new, v2_new])\n        \n    def f_ode(state):\n        x1, x2, v1, v2 = state\n        a1, a2 = get_accelerations(x1, x2)\n        return np.array([v1, v2, a1, a2])\n\n    def step_rk4(state, dt):\n        k1 = f_ode(state)\n        k2 = f_ode(state + 0.5 * dt * k1)\n        k3 = f_ode(state + 0.5 * dt * k2)\n        k4 = f_ode(state + dt * k3)\n        return state + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n\n    def run_simulation(stepper, dt):\n        num_steps = int(round(T_final / dt))\n        state = np.copy(initial_state)\n        \n        H0 = get_hamiltonian(state)\n        max_rel_H_err = 0.0\n\n        for _ in range(num_steps):\n            state = stepper(state, dt)\n            H_t = get_hamiltonian(state)\n            rel_H_err = abs(H_t - H0) / abs(H0)\n            if rel_H_err > max_rel_H_err:\n                max_rel_H_err = rel_H_err\n        \n        H_T = get_hamiltonian(state)\n        abs_term_H_err = abs(H_T - H0)\n        \n        v1_T, v2_T = state[2], state[3]\n        swap_err = np.sqrt((v1_T - v1_star)**2 + (v2_T - v2_star)**2)\n\n        # Time-reversibility test\n        state_fwd = np.copy(state) # state at T from forward run\n        state_bwd = np.copy(state_fwd)\n        for _ in range(num_steps):\n            state_bwd = stepper(state_bwd, -dt)\n        \n        rev_err = np.linalg.norm(state_bwd - initial_state)\n\n        return abs_term_H_err, max_rel_H_err, swap_err, rev_err\n\n    all_results = []\n    for dt in test_dts:\n        verlet_diags = run_simulation(step_verlet, dt)\n        rk4_diags = run_simulation(step_rk4, dt)\n\n        case_results = [\n            verlet_diags[0], rk4_diags[0],\n            verlet_diags[1], rk4_diags[1],\n            verlet_diags[2], rk4_diags[2],\n            verlet_diags[3], rk4_diags[3]\n        ]\n        all_results.append(case_results)\n    \n    # Format output string exactly as required\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, res))}]' for res in all_results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2444593"}, {"introduction": "许多物理系统，从机械臂到卫星运动，都涉及几何约束。模拟这些受约束的运动不仅需要积分器能够守恒能量，还必须严格遵守这些几何约束。对于某些系统，例如质点在球面上的测地运动，其精确的解析解（即“流映射”）可以作为一个完美的数值积分器。本练习要求你实现这样一个“精确”的积分器，通过这种方式，你将学会如何完美地保持球面约束以及系统的能量和角动量，从而领略几何积分器所追求的理想性能。[@problem_id:2389083]", "problem": "给定一个质点在单位球面上的约束运动。设其位置为 $q(t)\\in\\mathbb{R}^3$，速度为 $\\dot{q}(t)\\in\\mathbb{R}^3$。完整约束为 $q(t)^{\\top}q(t)=1$ 对所有 $t$ 成立。质点质量为 $m=1$，且无外部势能。机械能为 $E=\\tfrac{1}{2}\\,\\dot{q}^{\\top}\\dot{q}$。角动量为 $L=q\\times\\dot{q}$。初始速度必须满足 $q(0)^{\\top}\\dot{q}(0)=0$。角度必须以弧度为单位。使用无量纲单位。\n\n任务：编写一个完整的程序，对每个测试用例，使用大小为 $h$ 的固定步长，将动力学向前推进 $N$ 步。所用的时间积分器需在每一步都保持约束 $q^{\\top}q=1$，并且对此系统是能量-动量守恒的。对于每个测试用例，计算在所有时间步（包括初始状态）中，以下三种偏差的最大值：\n- 约束偏差 $\\delta_c=\\left|\\lVert q\\rVert-1\\right|$，\n- 能量偏差 $\\delta_e=\\left|E(t)-E(0)\\right|$，\n- 角动量偏差 $\\delta_{\\ell}=\\left\\|L(t)-L(0)\\right\\|$。\n对于每个测试用例，输出一个浮点数，其值为整个轨迹上 $\\varepsilon=\\max\\{\\delta_c,\\delta_e,\\delta_{\\ell}\\}$ 的值。\n\n测试集。使用以下初始条件和参数。所有向量均写作 $\\mathbb{R}^3$中的列向量：\n- 测试用例 1 (一般情况)：$q_0=\\begin{bmatrix}1\\\\0\\\\0\\end{bmatrix}$, $\\dot{q}_0=\\begin{bmatrix}0\\\\1\\\\0\\end{bmatrix}$, $h=0.01$, $N=100$。\n- 测试用例 2 (零速度边界情况)：$q_0=\\begin{bmatrix}0\\\\1\\\\0\\end{bmatrix}$, $\\dot{q}_0=\\begin{bmatrix}0\\\\0\\\\0\\end{bmatrix}$, $h=0.1$, $N=50$。\n- 测试用例 3 (完整一圈)：$q_0=\\begin{bmatrix}0\\\\0\\\\1\\end{bmatrix}$, $\\dot{q}_0=\\begin{bmatrix}\\pi\\\\0\\\\0\\end{bmatrix}$, $h=0.2$, $N=10$。\n- 测试用例 4 (斜轴，长时积分)：$q_0=\\dfrac{1}{\\sqrt{3}}\\begin{bmatrix}1\\\\1\\\\1\\end{bmatrix}$, $\\dot{q}_0=s\\,\\dfrac{1}{\\sqrt{2}}\\begin{bmatrix}1\\\\-1\\\\0\\end{bmatrix}$，其中 $s=0.75$, $h=0.037$, $N=1000$。\n\n最终输出格式。您的程序应产生单行输出，其中包含按测试集顺序排列的结果，形式为逗号分隔的列表并用方括号括起，例如 $\\left[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4\\right]$。每个 $\\varepsilon_i$ 必须是实数（浮点数）。", "solution": "问题陈述已经过分析，并被确定为有效。这是一个计算力学中的适定问题，没有科学或逻辑上的不一致性。它提供了所有必要的数据，并定义了一个清晰、客观的任务。\n\n所研究的系统是一个质量为 $m=1$ 的质点，被约束在单位球面上运动，由完整约束 $g(q) = q(t)^{\\top}q(t) - 1 = 0$ 描述。由于没有外部势能，拉格朗日量纯为动能：$L(q, \\dot{q}) = \\frac{1}{2}\\dot{q}^{\\top}\\dot{q}$。运动方程由约束系统的 Euler-Lagrange 方程导出，即 $\\ddot{q} = \\lambda \\nabla_q g(q)$，其中 $\\lambda$ 是一个用于强制执行约束的拉格朗日乘子。将约束对时间求两次导数，得到 $q^{\\top}\\ddot{q} + \\dot{q}^{\\top}\\dot{q} = 0$。代入运动方程并使用 $q^{\\top} q=1$，我们发现拉格朗日乘子为 $\\lambda = -\\dot{q}^{\\top}\\dot{q}$。因此，连续运动方程为：\n$$ \\ddot{q} = -(\\dot{q}^{\\top}\\dot{q}) q $$\n该方程描述了球面上的测地线运动。质点的轨迹遵循一个大圆。\n\n问题要求一个能精确守恒以下三个量的时间积分器：\n1. 几何约束：$\\lVert q(t) \\rVert = 1$。\n2. 机械能：$E(t) = \\frac{1}{2}\\dot{q}(t)^{\\top}\\dot{q}(t) = E(0)$。\n3. 角动量向量：$L(t) = q(t) \\times \\dot{q}(t) = L(0)$。\n\n标准的数值积分器，如 Euler 或 Verlet 方法，对于此系统不能满足这些严格的守恒性质。有必要构建一个基于运动方程精确解的积分器。球面上测地流的精确解是一个旋转。\n\n设时间 $t_n$ 的状态为 $(q_n, \\dot{q}_n)$。设速率为 $\\omega_n = \\lVert \\dot{q}_n \\rVert$。能量为 $E_n = \\frac{1}{2}\\omega_n^2$。如果 $\\omega_n = 0$，则质点处于静止状态，并将在所有未来时间保持静止。如果 $\\omega_n > 0$，运动发生在由正交单位向量 $q_n$ 和 $v_n = \\dot{q}_n / \\omega_n$ 张成的平面内。初始条件 $q(0)^{\\top}\\dot{q}(0)=0$ 确保了这些向量是正交的，并且动力学过程会保持此性质，因为 $d/dt(q^{\\top}\\dot{q}) = \\dot{q}^{\\top}\\dot{q} + q^{\\top}\\ddot{q} = \\dot{q}^{\\top}\\dot{q} - q^{\\top}((\\dot{q}^{\\top}\\dot{q})q) = \\|\\dot{q}\\|^2 - \\|\\dot{q}\\|^2 \\|q\\|^2 = 0$。\n\n从 $q_n$ 开始、速度为 $\\dot{q}_n$ 的精确轨迹由 Rodrigues 旋转公式给出，该公式描述了沿大圆的旋转：\n$$ q(t_n + \\tau) = q_n \\cos(\\omega_n \\tau) + v_n \\sin(\\omega_n \\tau) $$\n速度是其对时间的导数：\n$$ \\dot{q}(t_n + \\tau) = -\\omega_n \\sin(\\omega_n \\tau) q_n + \\omega_n \\cos(\\omega_n \\tau) v_n $$\n这个解析解提供了一个从时间 $t_n$ 的状态到时间 $t_{n+1} = t_n + h$ 状态的精确映射。通过使用这个映射作为我们的积分器，我们在构造上满足了所有的守恒要求，其精度仅受浮点运算精度的限制。\n\n将状态从第 $n$ 步推进到第 $n+1$ 步的算法如下：\n1. 给定状态 $(q_n, \\dot{q}_n)$，计算速率 $\\omega_n = \\lVert \\dot{q}_n \\rVert$。\n2. 如果 $\\omega_n$ 为零（或数值上与零无法区分），则质点是静止的。状态不发生改变：$q_{n+1} = q_n$ 且 $\\dot{q}_{n+1} = \\dot{q}_n = 0$。\n3. 如果 $\\omega_n > 0$，定义归一化速度向量 $v_n = \\dot{q}_n / \\omega_n$。\n4. 计算时间步长 $h$ 对应的旋转角度：$\\theta = \\omega_n h$。\n5. 使用精确解映射更新位置和速度：\n$$ q_{n+1} = q_n \\cos(\\theta) + v_n \\sin(\\theta) $$\n$$ \\dot{q}_{n+1} = -\\omega_n \\sin(\\theta) q_n + \\omega_n \\cos(\\theta) v_n $$\n\n该方法将为每个测试用例实现。将生成一个包含 $N+1$ 个状态（从 $t=0$ 到 $t=Nh$）的轨迹。对于轨迹中的每个状态 $(q_k, \\dot{q}_k)$，将计算偏差 $\\delta_c = |\\lVert q_k \\rVert-1|$、$\\delta_e = |E_k - E_0|$ 和 $\\delta_{\\ell} = \\lVert L_k - L_0 \\rVert$。每个测试用例的最终结果 $\\varepsilon$ 将是这三种偏差在整个轨迹上的最大值。任何 $\\varepsilon$ 的非零值都将只归因于浮点算术误差，因为所选择的积分器是解析精确的。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of integrating the motion of a point mass on a unit sphere\n    using an energy-momentum conserving integrator and calculating deviations.\n    \"\"\"\n    # Test suite definition\n    # Format: (q0, v0, h, N) where q0 and v0 are lists.\n    test_cases = [\n        (\n            [1.0, 0.0, 0.0],\n            [0.0, 1.0, 0.0],\n            0.01,\n            100\n        ),\n        (\n            [0.0, 1.0, 0.0],\n            [0.0, 0.0, 0.0],\n            0.1,\n            50\n        ),\n        (\n            [0.0, 0.0, 1.0],\n            [np.pi, 0.0, 0.0],\n            0.2,\n            10\n        ),\n        (\n            [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)],\n            [0.75/np.sqrt(2), -0.75/np.sqrt(2), 0.0],\n            0.037,\n            1000\n        )\n    ]\n\n    results = []\n\n    for case in test_cases:\n        q0_list, v0_list, h, N = case\n        q0 = np.array(q0_list, dtype=np.float64)\n        v0 = np.array(v0_list, dtype=np.float64)\n\n        # Store trajectory of positions and velocities\n        qs = [q0]\n        vs = [v0]\n\n        q_curr = q0\n        v_curr = v0\n\n        # Time integration loop\n        for _ in range(N):\n            omega = np.linalg.norm(v_curr)\n\n            # Epsilon for checking if omega is close to zero\n            if omega < np.finfo(float).eps:\n                q_next = q_curr\n                v_next = v_curr\n            else:\n                unit_v = v_curr / omega\n                theta = h * omega\n                \n                cos_theta = np.cos(theta)\n                sin_theta = np.sin(theta)\n\n                # Exact flow map for geodesic motion on a sphere\n                q_next = q_curr * cos_theta + unit_v * sin_theta\n                v_next = -omega * sin_theta * q_curr + omega * cos_theta * unit_v\n            \n            qs.append(q_next)\n            vs.append(v_next)\n            q_curr = q_next\n            v_curr = v_next\n\n        # Calculate initial conserved quantities\n        E0 = 0.5 * np.dot(v0, v0)\n        L0 = np.cross(q0, v0)\n\n        max_delta_c = 0.0\n        max_delta_e = 0.0\n        max_delta_l = 0.0\n\n        # Calculate maximum deviations over the trajectory\n        for i in range(N + 1):\n            q_i = qs[i]\n            v_i = vs[i]\n\n            # Constraint deviation\n            delta_c = np.abs(np.linalg.norm(q_i) - 1.0)\n\n            # Energy deviation\n            E_i = 0.5 * np.dot(v_i, v_i)\n            delta_e = np.abs(E_i - E0)\n            \n            # Angular momentum deviation\n            L_i = np.cross(q_i, v_i)\n            delta_l = np.linalg.norm(L_i - L0)\n\n            if delta_c > max_delta_c:\n                max_delta_c = delta_c\n            if delta_e > max_delta_e:\n                max_delta_e = delta_e\n            if delta_l > max_delta_l:\n                max_delta_l = delta_l\n        \n        epsilon = max(max_delta_c, max_delta_e, max_delta_l)\n        results.append(epsilon)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.17e}' for r in results)}]\")\n\nsolve()\n```", "id": "2389083"}, {"introduction": "现实世界的工程系统通常包含摩擦等耗散能量的非保守力。虽然能量在这种情况下不守恒，但总的功-能平衡原则必须成立。我们可以将能量-动量守恒方法的思想推广到这些系统，通过设计满足离散形式的“功能定理”的积分器，精确地计算每个时间步内耗散的能量。在这个进阶练习中，你将处理一个带有非光滑库仑摩擦的系统，通过精确建模摩擦力所做的功来设计一个保持精确能量平衡的积分器，从而展示这些技术在创建稳健、真实的耗散力学系统仿真中的强大能力。[@problem_id:2389054]", "problem": "为受干摩擦（库仑摩擦）作用、连接到线性弹簧上的单自由度质量块实现一个能量平衡时间积分器，并使用一组指定的测试用例验证离散能量平衡。该力学模型由牛顿第二定律、弹簧力定律和库仑摩擦定律给出。其连续时间方程为\n$$\nM \\,\\ddot{x}(t) + k \\, x(t) + f_{\\mathrm{fric}}(\\dot{x}(t)) = 0,\n$$\n其中\n$$\nf_{\\mathrm{fric}}(\\dot{x}) \\in \\mu N \\,\\mathrm{Sign}(\\dot{x}),\n$$\n其中 $M$ 是质量，$k$ 是弹簧刚度，$\\mu$ 是摩擦系数，$N$ 是法向载荷，$\\mathrm{Sign}(\\cdot)$ 是集值符号函数，定义为\n$$\n\\mathrm{Sign}(v) = \n\\begin{cases}\n\\{\\mathrm{sign}(v)\\}, & \\text{if } v \\ne 0,\\\\\n[-1,1], & \\text{if } v = 0.\n\\end{cases}\n$$\n仅从上述定律和离散功能原理出发，设计一个在大小为 $\\Delta t$ 的均匀步长上的时间步进方法，该方法对保守部分使用中点运动学和中点力，并引入一个与库仑集值定律一致的单步摩擦冲量。您的方法必须满足以下形式的离散能量平衡：\n$$\nE_{n+1} - E_n + W_{\\mathrm{fric}}^{(n)} = 0 \\quad \\text{for each step } n,\n$$\n其中 $E_n$ 是时间步 $n$ 的机械能，$W_{\\mathrm{fric}}^{(n)}$ 是在您的格式中计算得到的在步长 $n$ 内的摩擦耗散能。机械能为\n$$\nE_n = \\tfrac{1}{2} M v_n^2 + \\tfrac{1}{2} k x_n^2,\n$$\n其中 $x_n$ 和 $v_n$ 表示在步长 $n$ 的位置和速度。仅使用标准浮点运算；无需符号操作。\n\n您的程序必须实现您推导的积分器，并对每个测试用例模拟该系统，计算在所有时间步中离散能量平衡的最大绝对误差，\n$$\n\\max_n \\left| E_{n+1} - E_n + W_{\\mathrm{fric}}^{(n)} \\right|.\n$$\n每个测试用例的结果值必须是一个浮点数。不需要进行物理单位转换；以无量纲浮点数的形式报告结果。\n\n使用以下测试套件。每个测试用例指定了 $(M,k,\\mu,N,\\Delta t, \\text{steps}, x_0, v_0)$:\n- 测试 $1$ (一般滑动与粘滞): $(M,k,\\mu,N,\\Delta t,\\text{steps},x_0,v_0) = (1.0, 50.0, 0.2, 1.5, 0.005, 4000, 0.1, 0.0)$。\n- 测试 $2$ (纯保守极限): $(M,k,\\mu,N,\\Delta t,\\text{steps},x_0,v_0) = (1.0, 50.0, 0.0, 1.0, 0.005, 4000, 0.1, 0.2)$。\n- 测试 $3$ (单步阈值边缘情况，无弹簧): $(M,k,\\mu,N,\\Delta t,\\text{steps},x_0,v_0) = (1.0, 0.0, 0.8, 1.0, 1.0, 1, 0.0, 0.4)$。\n- 测试 $4$ (仅摩擦力的滑行与停止): $(M,k,\\mu,N,\\Delta t,\\text{steps},x_0,v_0) = (1.0, 0.0, 0.05, 1.0, 0.01, 1000, 0.0, 1.0)$。\n\n您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表（例如，“[$r_1,r_2,r_3,r_4$]”），其中 $r_i$ 是如上文定义的测试 $i$ 的离散能量平衡最大绝对误差。不允许有其他输出。", "solution": "该问题陈述经评估有效。它具有科学依据、良定且客观，是计算力学中的一个标准问题。我们现在开始推导所需的数值积分器。\n\n目标是为运动方程 $M \\ddot{x}(t) + k x(t) + f_{\\mathrm{fric}}(\\dot{x}(t)) = 0$ 构建一个时间步进格式，该格式通过自身构造即满足离散能量平衡。推导的基础是时间区间 $[t_n, t_{n+1}]$ 上的离散功能原理，其中 $t_{n+1} = t_n + \\Delta t$。\n\n从时间 $t_n$到 $t_{n+1}$ 的动能变化等于所有力所做的总功。\n$$\n\\Delta K^{(n)} = K_{n+1} - K_n = W_{\\mathrm{cons}}^{(n)} + W_{\\mathrm{fric,force}}^{(n)}\n$$\n其中 $K_n = \\frac{1}{2} M v_n^2$ 是动能，$W_{\\mathrm{cons}}^{(n)}$ 是保守弹簧力所做的功，$W_{\\mathrm{fric,force}}^{(n)}$ 是摩擦力所做的功。保守功是势能变化的负值, $W_{\\mathrm{cons}}^{(n)} = -(U_{n+1} - U_n)$，其中 $U_n = \\frac{1}{2} k x_n^2$。摩擦力做功导致能量耗散。设 $W_{\\mathrm{fric}}^{(n)}$ 为在该步长内由摩擦耗散的能量，它是摩擦力所做功的负值，即 $W_{\\mathrm{fric}}^{(n)} = -W_{\\mathrm{fric,force}}^{(n)}$。代入这些定义可得：\n$$\n(K_{n+1} + U_{n+1}) - (K_n + U_n) + W_{\\mathrm{fric}}^{(n)} = 0\n$$\n$$\nE_{n+1} - E_n + W_{\\mathrm{fric}}^{(n)} = 0\n$$\n这就是目标离散能量平衡方程。我们的任务是定义积分器的更新规则和 $W_{\\mathrm{fric}}^{(n)}$，以使该方程成立。\n\n按照指定，我们对运动学采用中点近似。区间中点的状态（用下标 $n+1/2$ 表示）定义为：\n$$\nx_{n+1/2} = \\frac{x_n + x_{n+1}}{2}, \\quad v_{n+1/2} = \\frac{v_n + v_{n+1}}{2}\n$$\n这导出了位置的更新规则：\n$$\nx_{n+1} - x_n = \\int_{t_n}^{t_{n+1}} \\dot{x}(t) \\, dt \\approx v_{n+1/2} \\Delta t\n$$\n现在，我们通过平方差公式分解来重写能量平衡方程：\n$$\n\\frac{1}{2} M (v_{n+1} - v_n)(v_{n+1} + v_n) + \\frac{1}{2} k (x_{n+1} - x_n)(x_{n+1} + x_n) + W_{\\mathrm{fric}}^{(n)} = 0\n$$\n代入中点运动学定义：\n$$\nM (v_{n+1} - v_n) v_{n+1/2} + k (v_{n+1/2} \\Delta t) x_{n+1/2} + W_{\\mathrm{fric}}^{(n)} = 0\n$$\n提出中点速度 $v_{n+1/2}$ 可得：\n$$\nv_{n+1/2} \\left[ M(v_{n+1} - v_n) + k x_{n+1/2} \\Delta t \\right] + W_{\\mathrm{fric}}^{(n)} = 0\n$$\n该方程将能量平衡与动量平衡联系起来。离散动量平衡是通过在一个时间步长上对运动方程进行积分得到的，其中对保守力使用中点法则，并定义一个摩擦冲量 $I_f^{(n)}$：\n$$\nM(v_{n+1} - v_n) = \\int_{t_n}^{t_{n+1}} (-k x(t) - f_{\\mathrm{fric}}(\\dot{x}(t))) dt \\approx -k x_{n+1/2} \\Delta t - I_f^{(n)}\n$$\n其中 $I_f^{(n)} = \\int_{t_n}^{t_{n+1}} f_{\\mathrm{fric}}(\\dot{x}(t)) dt$。这给出了离散动量方程：\n$$\nM(v_{n+1} - v_n) + k x_{n+1/2} \\Delta t + I_f^{(n)} = 0\n$$\n能量方程中方括号内的项恰好是动量方程中的 $-I_f^{(n)}$。代入此关系即得到了耗散能的定义：\n$$\nv_{n+1/2} [-I_f^{(n)}] + W_{\\mathrm{fric}}^{(n)} = 0 \\implies W_{\\mathrm{fric}}^{(n)} = I_f^{(n)} v_{n+1/2}\n$$\n根据此定义，离散能量平衡通过构造得到满足。剩下的任务是求解每个步长中的未知量。该系统由更新规则和摩擦定律定义。我们首先用中点速度 $v_{n+1/2}$ 和摩擦冲量 $I_f^{(n)}$ 来表示所有未知量。\n根据中点运动学，我们有 $v_{n+1} = 2 v_{n+1/2} - v_n$ 和 $x_{n+1/2} = x_n + \\frac{1}{2} v_{n+1/2} \\Delta t$。将这些代入动量方程可得：\n$$\nM((2v_{n+1/2} - v_n) - v_n) + k (x_n + \\frac{1}{2} v_{n+1/2} \\Delta t) \\Delta t + I_f^{(n)} = 0\n$$\n$$\n2M(v_{n+1/2} - v_n) + k x_n \\Delta t + \\frac{1}{2} k (\\Delta t)^2 v_{n+1/2} + I_f^{(n)} = 0\n$$\n合并含有 $v_{n+1/2}$ 的项：\n$$\n\\left( 2M + \\frac{1}{2} k (\\Delta t)^2 \\right) v_{n+1/2} + I_f^{(n)} = 2M v_n - k x_n \\Delta t\n$$\n我们定义 $A = 2M + \\frac{1}{2} k (\\Delta t)^2$ 和 $B = 2M v_n - k x_n \\Delta t$。方程变成了一个简洁的代数关系：\n$$\nA v_{n+1/2} + I_f^{(n)} = B\n$$\n摩擦冲量 $I_f^{(n)}$ 必须与集值库仑定律一致，我们将其应用于中点：$I_f^{(n)} \\in (\\mu N \\Delta t) \\cdot \\mathrm{Sign}(v_{n+1/2})$。设 $P_f = \\mu N \\Delta t$ 为极限摩擦冲量的大小。该定律变为 $I_f^{(n)} \\in P_f \\cdot \\mathrm{Sign}(v_{n+1/2})$，这意味着：\n1.  如果 $v_{n+1/2} > 0$，则 $I_f^{(n)} = P_f$。\n2.  如果 $v_{n+1/2} < 0$，则 $I_f^{(n)} = -P_f$。\n3.  如果 $v_{n+1/2} = 0$，则 $I_f^{(n)} \\in [-P_f, P_f]$。这是粘滞条件。\n\n我们可以通过分析这些情况来求解 $v_{n+1/2}$ 和 $I_f^{(n)}$。量 $B$ 表示为实现粘滞条件（$v_{n+1/2}=0$）所需的摩擦冲量。\n- 如果所需的粘滞冲量 $B$ 大于可提供的摩擦冲量 $P_f$（即 $B > P_f$），系统必须滑动。试验运动是正向的（因为如果摩擦为零，则 $A v_{n+1/2} = B > 0$），因此动摩擦冲量必须是 $I_f^{(n)} = P_f$。这得到 $A v_{n+1/2} + P_f = B$，所以 $v_{n+1/2} = (B - P_f)/A$。结果为正，这与假设是一致的。\n- 如果 $B < -P_f$，系统必须向负方向滑动。摩擦冲量为 $I_f^{(n)} = -P_f$。这得到 $A v_{n+1/2} - P_f = B$，所以 $v_{n+1/2} = (B + P_f)/A$。结果为负，这与假设是一致的。\n- 如果 $|B| \\le P_f$，所需的粘滞冲量在静摩擦的能力范围内。系统发生粘滞，因此 $v_{n+1/2} = 0$。动量平衡给出 $I_f^{(n)} = B$。这与粘滞条件 $I_f^{(n)} \\in [-P_f, P_f]$ 一致。\n\n从状态 $(x_n, v_n)$ 到 $(x_{n+1}, v_{n+1})$ 的单个时间步的完整算法如下：\n1.  计算辅助常数：$A = 2M + \\frac{1}{2} k (\\Delta t)^2$ 和 $P_f = \\mu N \\Delta t$。\n2.  计算试验冲量：$B = 2M v_n - k x_n \\Delta t$。\n3.  判断摩擦状态并求解 $v_{n+1/2}$ 和 $I_f^{(n)}$：\n    - 如果 $B > P_f$：$I_f^{(n)} = P_f$ 且 $v_{n+1/2} = (B - P_f) / A$。\n    - 否则如果 $B < -P_f$：$I_f^{(n)} = -P_f$ 且 $v_{n+1/2} = (B + P_f) / A$。\n    - 否则：$I_f^{(n)} = B$ 且 $v_{n+1/2} = 0$。\n4.  更新状态变量：$v_{n+1} = 2 v_{n+1/2} - v_n$ 和 $x_{n+1} = x_n + v_{n+1/2} \\Delta t$。\n5.  为进行验证，计算能量平衡误差：\n    $E_n = \\frac{1}{2} M v_n^2 + \\frac{1}{2} k x_n^2$\n    $E_{n+1} = \\frac{1}{2} M v_{n+1}^2 + \\frac{1}{2} k x_{n+1}^2$\n    $W_{\\mathrm{fric}}^{(n)} = I_f^{(n)} v_{n+1/2}$\n    误差为 $|E_{n+1} - E_n + W_{\\mathrm{fric}}^{(n)}|$。\n\n对每个测试用例实施此算法，以找到在整个模拟周期内的最大误差。根据构造，该误差预计将接近机器精度。", "answer": "```python\nimport numpy as np\n\ndef run_simulation(case):\n    \"\"\"\n    Simulates the mass-spring-friction system for one test case.\n\n    Args:\n        case (tuple): A tuple containing the parameters for the simulation:\n                      (M, k, mu, N, dt, steps, x0, v0).\n\n    Returns:\n        float: The maximum absolute violation of the discrete energy balance.\n    \"\"\"\n    M, k, mu, N, dt, steps, x_n, v_n = case\n    max_violation = 0.0\n\n    # Pre-calculate constants that do not change during the simulation\n    Pf_mag = mu * N * dt\n    A_const = 2.0 * M + 0.5 * k * dt**2\n\n    for _ in range(steps):\n        # 1. Calculate energy at step n\n        E_n = 0.5 * M * v_n**2 + 0.5 * k * x_n**2\n\n        # 2. Calculate trial impulse B\n        B_impulse = 2.0 * M * v_n - k * x_n * dt\n\n        # 3. Determine friction state and solve for midpoint velocity and friction impulse\n        if B_impulse > Pf_mag:\n            # Sliding with positive velocity\n            I_f = Pf_mag\n            v_mid = (B_impulse - Pf_mag) / A_const\n        elif B_impulse < -Pf_mag:\n            # Sliding with negative velocity\n            I_f = -Pf_mag\n            v_mid = (B_impulse + Pf_mag) / A_const\n        else:\n            # Sticking\n            I_f = B_impulse\n            v_mid = 0.0\n\n        # 4. Update state variables to step n+1\n        v_np1 = 2.0 * v_mid - v_n\n        x_np1 = x_n + v_mid * dt\n\n        # 5. Compute energy at n+1 and dissipated work to verify balance\n        E_np1 = 0.5 * M * v_np1**2 + 0.5 * k * x_np1**2\n        W_fric = I_f * v_mid\n        \n        violation = abs(E_np1 - E_n + W_fric)\n        if violation > max_violation:\n            max_violation = violation\n            \n        # 6. Update state for the next iteration\n        x_n = x_np1\n        v_n = v_np1\n        \n    return max_violation\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (M, k, mu, N, dt, steps, x0, v0)\n        (1.0, 50.0, 0.2, 1.5, 0.005, 4000, 0.1, 0.0),\n        (1.0, 50.0, 0.0, 1.0, 0.005, 4000, 0.1, 0.2),\n        (1.0, 0.0, 0.8, 1.0, 1.0, 1, 0.0, 0.4),\n        (1.0, 0.0, 0.05, 1.0, 0.01, 1000, 0.0, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        max_energy_violation = run_simulation(case)\n        results.append(max_energy_violation)\n\n    # Format and print the final output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2389054"}]}