{"hands_on_practices": [{"introduction": "在多物理场耦合的数值求解中，分区迭代法是一种核心策略。本练习将通过一个简化的热力耦合问题，带你深入理解两种最基本的分区方案：Jacobi法和Gauss-Seidel法。通过推导和比较它们各自的迭代矩阵谱半径，你将掌握定量分析迭代收敛速度的关键技能，并直观地看到信息传递方式的微小差异如何影响整体计算效率。[@problem_id:2416751]", "problem": "考虑一个杆件经过空间离散化后的线性、稳态、一维热力耦合问题，该问题被离散化为一个机械自由度与一个热自由度。未知量为轴向位移 $u$ 和温度 $T$。该耦合代数平衡方程可以写成如下的分块形式：\n$$\n\\begin{bmatrix}\nk_u & -h \\\\\n-g & k_T\n\\end{bmatrix}\n\\begin{bmatrix}\nu \\\\\nT\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nf_u \\\\\nf_T\n\\end{bmatrix},\n$$\n其中 $k_u>0$ 和 $k_T>0$ 分别代表机械和热的正刚度类系数，$h \\ge 0$ 和 $g \\ge 0$ 量化了热子系统和机械子系统之间的耦合程度。右端项 $f_u$ 和 $f_T$ 为给定的载荷。所有参数均为实数。\n\n针对此 $2 \\times 2$ 系统，从初始猜测 $(u^{(0)},T^{(0)})$ 开始，定义两种分区定点耦合方案：\n- Jacobi 分区方案：在每次迭代中，两个子问题都只使用另一个场的前一迭代步的计算结果。\n- Gauss–Seidel 分区方案：在每次迭代中，首先更新机械子问题，然后热子问题使用同一次迭代中最新的机械更新量。\n\n对于每种方案，其线性迭代可以写成如下形式：\n$$\n\\begin{bmatrix}\nu^{(k+1)} \\\\\nT^{(k+1)}\n\\end{bmatrix}\n=\n\\mathbf{M}\n\\begin{bmatrix}\nu^{(k)} \\\\\nT^{(k)}\n\\end{bmatrix}\n+\n\\mathbf{c},\n$$\n其中 $\\mathbf{M}$ 是迭代矩阵，$\\mathbf{c}$ 是一个与迭代无关的向量。线性收敛因子是谱半径 $\\rho(\\mathbf{M})$，它是一个无量纲量。当且仅当 $\\rho(\\mathbf{M}) < 1$ 时，迭代收敛。\n\n任务：对于下面测试套件中列出的参数集，设 $f_u=0$ 和 $f_T=0$（$f_u$ 和 $f_T$ 的值不影响谱半径）。对每种情况，计算以下量值：\n1. Jacobi 分区迭代矩阵的谱半径 $\\rho_J$（无量纲）。\n2. Gauss–Seidel 分区迭代矩阵的谱半径 $\\rho_{GS}$（无量纲）。\n3. 一个布尔值，指示 Jacobi 方案是否收敛，定义为 $\\rho_J < 1$。\n4. 一个布尔值，指示 Gauss–Seidel 方案是否收敛，定义为 $\\rho_{GS} < 1$。\n5. 一个用于比较收敛速率的整数代码：如果 Gauss–Seidel 方案严格更快（即 $\\rho_{GS} < \\rho_J$），输出 $1$；如果 Jacobi 方案严格更快（即 $\\rho_J < \\rho_{GS}$），输出 $2$；如果它们的谱半径在 $10^{-12}$ 的容差范围内相等，则输出 $0$。\n\n测试套件（每种情况是一个元组 $(k_u,k_T,h,g)$，为便于比较，所有量均视为无量纲）：\n- 情况 A: $(100.0, 50.0, 10.0, 5.0)$。\n- 情况 B: $(100.0, 100.0, 0.0, 50.0)$。\n- 情况 C: $(1.0, 1.0, 1.0, 1.0)$。\n- 情况 D: $(2.0, 3.0, 2.0, 4.0)$。\n- 情况 E: $(10^6, 1.0, 100.0, 100.0)$。\n\n您的程序必须生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，每个测试用例对应一个形如 $[\\rho_J,\\rho_{GS},\\text{JacobiConverges},\\text{GaussSeidelConverges},\\text{Winner}]$ 的子列表。浮点数值 $\\rho_J$ 和 $\\rho_{GS}$ 必须四舍五入到小数点后恰好六位。布尔值必须打印为 $True$ 或 $False$。例如，对于两个假设的用例，一个有效的整体输出将如下所示\n$[[0.125000,0.062500,True,True,1],[1.000000,1.000000,False,False,0]]$。", "solution": "所给问题是耦合线性系统迭代方法分析中的一个标准练习，这是计算工程学中的一个基本课题。该问题是适定的、科学上合理的，并包含了获得唯一解所需的所有信息。我们将着手推导所需的量。\n\n控制线性代数方程组为：\n$$\n\\begin{bmatrix}\nk_u & -h \\\\\n-g & k_T\n\\end{bmatrix}\n\\begin{bmatrix}\nu \\\\\nT\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nf_u \\\\\nf_T\n\\end{bmatrix}\n$$\n该系统可以抽象地写为 $\\mathbf{A}\\mathbf{x} = \\mathbf{b}$，其中 $\\mathbf{x} = [u, T]^T$ 是未知量向量，$\\mathbf{A}$ 是系统矩阵。对于 Jacobi 和 Gauss-Seidel 类型的迭代方法，矩阵 $\\mathbf{A}$ 被分解为其对角、严格下三角和严格上三角部分：$\\mathbf{A} = \\mathbf{D} + \\mathbf{L} + \\mathbf{U}$。根据给定的系统，这些矩阵是：\n$$\n\\mathbf{D} = \\begin{bmatrix} k_u & 0 \\\\ 0 & k_T \\end{bmatrix}, \\quad\n\\mathbf{L} = \\begin{bmatrix} 0 & 0 \\\\ -g & 0 \\end{bmatrix}, \\quad\n\\mathbf{U} = \\begin{bmatrix} 0 & -h \\\\ 0 & 0 \\end{bmatrix}\n$$\n约束条件为 $k_u > 0$、$k_T > 0$、$h \\ge 0$ 和 $g \\ge 0$。这确保了对角矩阵 $\\mathbf{D}$ 是可逆的。\n\n首先，我们分析 Jacobi 分区方案。迭代更新由 $\\mathbf{D}\\mathbf{x}^{(k+1)} = -(\\mathbf{L}+\\mathbf{U})\\mathbf{x}^{(k)} + \\mathbf{b}$ 定义。因此，迭代矩阵 $\\mathbf{M}_J$ 为 $\\mathbf{M}_J = -\\mathbf{D}^{-1}(\\mathbf{L}+\\mathbf{U})$。\n$$\n\\mathbf{D}^{-1} = \\begin{bmatrix} 1/k_u & 0 \\\\ 0 & 1/k_T \\end{bmatrix}\n$$\n$$\n-(\\mathbf{L}+\\mathbf{U}) = - \\begin{bmatrix} 0 & -h \\\\ -g & 0 \\end{bmatrix} = \\begin{bmatrix} 0 & h \\\\ g & 0 \\end{bmatrix}\n$$\n$$\n\\mathbf{M}_J = \\begin{bmatrix} 1/k_u & 0 \\\\ 0 & 1/k_T \\end{bmatrix} \\begin{bmatrix} 0 & h \\\\ g & 0 \\end{bmatrix} = \\begin{bmatrix} 0 & h/k_u \\\\ g/k_T & 0 \\end{bmatrix}\n$$\nJacobi 方案的收敛性由谱半径 $\\rho(\\mathbf{M}_J)$ 决定，即其特征值的最大绝对值。特征值 $\\lambda$ 可通过特征方程 $\\det(\\mathbf{M}_J - \\lambda\\mathbf{I}) = 0$ 求得：\n$$\n\\det \\begin{bmatrix} -\\lambda & h/k_u \\\\ g/k_T & -\\lambda \\end{bmatrix} = \\lambda^2 - \\frac{hg}{k_u k_T} = 0\n$$\n这给出特征值 $\\lambda_{1,2} = \\pm \\sqrt{\\frac{hg}{k_u k_T}}$。因此，谱半径为：\n$$\n\\rho_J = \\rho(\\mathbf{M}_J) = \\sqrt{\\frac{hg}{k_u k_T}}\n$$\n\n接下来，我们分析 Gauss-Seidel 分区方案。问题陈述中指出，首先更新机械变量 $u$，这对应于一个前向 Gauss-Seidel 迭代。更新规则为 $(\\mathbf{D}+\\mathbf{L})\\mathbf{x}^{(k+1)} = -\\mathbf{U}\\mathbf{x}^{(k)} + \\mathbf{b}$。迭代矩阵 $\\mathbf{M}_{GS}$ 为 $\\mathbf{M}_{GS} = -(\\mathbf{D}+\\mathbf{L})^{-1}\\mathbf{U}$。\n首先，我们求 $(\\mathbf{D}+\\mathbf{L})$ 的逆矩阵：\n$$\n(\\mathbf{D}+\\mathbf{L}) = \\begin{bmatrix} k_u & 0 \\\\ -g & k_T \\end{bmatrix} \\implies (\\mathbf{D}+\\mathbf{L})^{-1} = \\frac{1}{k_u k_T} \\begin{bmatrix} k_T & 0 \\\\ g & k_u \\end{bmatrix} = \\begin{bmatrix} 1/k_u & 0 \\\\ g/(k_u k_T) & 1/k_T \\end{bmatrix}\n$$\n现在，我们计算 $\\mathbf{M}_{GS}$：\n$$\n\\mathbf{M}_{GS} = - \\begin{bmatrix} 1/k_u & 0 \\\\ g/(k_u k_T) & 1/k_T \\end{bmatrix} \\begin{bmatrix} 0 & -h \\\\ 0 & 0 \\end{bmatrix} = \\begin{bmatrix} 1/k_u & 0 \\\\ g/(k_u k_T) & 1/k_T \\end{bmatrix} \\begin{bmatrix} 0 & h \\\\ 0 & 0 \\end{bmatrix} = \\begin{bmatrix} 0 & h/k_u \\\\ 0 & \\frac{hg}{k_u k_T} \\end{bmatrix}\n$$\n矩阵 $\\mathbf{M}_{GS}$ 是一个上三角矩阵，因此其特征值就是其对角线元素：$\\lambda_1 = 0$ 和 $\\lambda_2 = \\frac{hg}{k_u k_T}$。谱半径是它们绝对值的最大值：\n$$\n\\rho_{GS} = \\rho(\\mathbf{M}_{GS}) = \\left| \\frac{hg}{k_u k_T} \\right| = \\frac{hg}{k_u k_T}\n$$\n由于 $h,g,k_u,k_T$ 都是非负的，所以绝对值是多余的。\n\n通过比较推导出的谱半径，我们观察到一个直接关系：\n$$\n\\rho_{GS} = \\frac{hg}{k_u k_T} = \\left(\\sqrt{\\frac{hg}{k_u k_T}}\\right)^2 = (\\rho_J)^2\n$$\n这个关系式 $\\rho_{GS} = (\\rho_J)^2$ 是相容有序矩阵的一个经典结果，而此 $2 \\times 2$ 的系统矩阵 $\\mathbf{A}$ 正是这种矩阵。这个关系决定了相对收敛速率。当且仅当谱半径严格小于1时，迭代才会收敛。\n\n- 如果 $\\rho_J < 1$，那么 $\\rho_{GS} = (\\rho_J)^2 < \\rho_J$。两种方案都收敛，且 Gauss-Seidel 严格更快。\n- 如果 $\\rho_J = 1$，那么 $\\rho_{GS} = (\\rho_J)^2 = 1$。两种方案都不收敛，且它们的谱半径相等。\n- 如果 $\\rho_J > 1$，那么 $\\rho_{GS} = (\\rho_J)^2 > \\rho_J$。两种方案都发散，且 Gauss-Seidel 的“发散速率”更差，这意味着在这种情况下 Jacobi 被认为是“更快”的。\n\n基于这些公式，可以编写一个程序，为测试套件中提供的每组参数 $(k_u, k_T, h, g)$ 计算所需的量。该程序将计算 $\\rho_J$ 和 $\\rho_{GS}$，通过检查 $\\rho < 1$ 来确定每种方案的收敛性，并比较谱半径以确定哪种方案更快。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the thermo-mechanical coupling problem by analyzing Jacobi and Gauss-Seidel\n    partitioned schemes for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement as tuples of (ku, kT, h, g).\n    test_cases = [\n        # Case A\n        (100.0, 50.0, 10.0, 5.0),\n        # Case B\n        (100.0, 100.0, 0.0, 50.0),\n        # Case C\n        (1.0, 1.0, 1.0, 1.0),\n        # Case D\n        (2.0, 3.0, 2.0, 4.0),\n        # Case E\n        (10**6, 1.0, 100.0, 100.0),\n    ]\n\n    results = []\n    # Tolerance for comparing floating-point numbers for equality.\n    TOLERANCE = 1e-12\n\n    for case in test_cases:\n        ku, kT, h, g = case\n\n        # The core parameter governing convergence is the non-dimensional product 'x'.\n        # The problem constraints ku > 0 and kT > 0 prevent division by zero.\n        x = (h * g) / (ku * kT)\n\n        # Calculate the spectral radius for the Jacobi scheme.\n        # Since h, g, ku, kT are non-negative, x is non-negative, so sqrt is safe.\n        rho_j = np.sqrt(x)\n\n        # Calculate the spectral radius for the Gauss-Seidel scheme.\n        # For this 2x2 system, rho_gs is simply x.\n        rho_gs = x\n\n        # Determine convergence for each scheme. Convergence holds if rho < 1.\n        jacobi_converges = rho_j < 1.0\n        gauss_seidel_converges = rho_gs < 1.0\n\n        # Compare the convergence rates based on the spectral radii.\n        winner = 0  # Default: rates are equal\n        if rho_gs < rho_j - TOLERANCE:\n            winner = 1  # Gauss-Seidel is strictly faster\n        elif rho_j < rho_gs - TOLERANCE:\n            winner = 2  # Jacobi is strictly faster\n        \n        # Format the floating-point results to exactly six decimal places.\n        formatted_rho_j = f\"{rho_j:.6f}\"\n        formatted_rho_gs = f\"{rho_gs:.6f}\"\n\n        # Append the list of results for the current case.\n        # Booleans will be automatically converted to \"True\" or \"False\".\n        case_result = (\n            f\"[{formatted_rho_j},{formatted_rho_gs},\"\n            f\"{jacobi_converges},{gauss_seidel_converges},{winner}]\"\n        )\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The output is a comma-separated list of the individual case results,\n    # all enclosed in a single pair of square brackets.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2416751"}, {"introduction": "理论需与实践相结合，本练习将带你进入一个更具体的物理场景：共轭传热问题。你将实现一个常见的分区耦合策略——Dirichlet-Neumann方法，来求解固体和流体交界面上的热量传递。此练习的重点在于引入和应用“欠松弛”技术，你将亲手验证松弛因子 $ \\omega $ 是如何有效地稳定迭代过程，并确保在物理性质差异悬殊的“刚性”问题中实现收敛。[@problem_id:2416722]", "problem": "考虑一个一维 (1D) 共轭传热问题，其中包含一个占据区间 $\\left[-L_s,0\\right]$ 的固体板和一个占据区间 $\\left[0,L_f\\right]$ 的流体板。设固体的热导率恒为 $k_s$，流体的热导率恒为 $k_f$。假设为稳态、一维热传导，且两个板内均无内部热源。$x=-L_s$ 处的边界温度指定为 $T_{s,0}$（单位：开尔文），$x=+L_f$ 处的边界温度指定为 $T_{f,L}$（单位：开尔文）。将 $x=0$ 处的界面温度记为 $T_i$。\n\n在分区狄利克雷-诺伊曼耦合中，在第 $m$ 次子迭代时，首先使用狄利克雷条件 $T\\left(0\\right)=T_i^{(m)}$ 求解固体子问题，以获得从固体侧来的界面热通量 $q_s^{(m)}$（从固体到流体为正），然后使用诺伊曼条件 $-k_f\\,\\partial_x T\\left(0\\right)=q_s^{(m)}$ 和狄利克雷条件 $T\\left(L_f\\right)=T_{f,L}$ 求解流体子问题，以获得流体侧预测的界面温度 $T_{f,\\mathrm{int}}^{(m)}$。第 $m$ 次子迭代的界面温度失配是绝对差值 $e^{(m)}=\\left|T_i^{(m)}-T_{f,\\mathrm{int}}^{(m)}\\right|$，单位为开尔文。界面温度的欠松弛更新按如下方式执行：\n$$\nT_i^{(m+1)}=(1-\\omega)\\,T_i^{(m)}+\\omega\\,T_{f,\\mathrm{int}}^{(m)},\n$$\n其中 $\\omega\\in(0,1]$ 是欠松弛因子。子迭代持续进行，直到 $e^{(m)}<\\varepsilon$（容差，单位为开尔文）或子迭代次数达到 $M_{\\max}$。\n\n需要应用的基本定律：\n- Fourier 热传导定律 $q=-k\\,\\partial_x T$ 在每个板中均适用。\n- 在一维稳态传导中，若物性恒定且无热源，则每个板内的温度分布是 $x$ 的线性函数。\n\n您的任务是编写一个完整的程序，针对以下每个测试用例，计算在每次子迭代中记录的界面温度失配序列 $\\left\\{e^{(m)}\\right\\}_{m=0,1,2,\\dots}$（单位：开尔文），按其产生的顺序排列，直到满足停止准则。每个记录的 $e^{(m)}$ 必须四舍五入到 $6$ 位小数。最终输出必须将所有测试用例的序列聚合为单行，形式为浮点数列表的列表，括号内任何地方都不能有空格。\n\n使用以下测试套件。对于每个用例，输入为 $(k_s,L_s,k_f,L_f,T_{s,0},T_{f,L},\\omega,\\varepsilon,M_{\\max},T_i^{(0)})$，单位如下：$k_s$ 和 $k_f$ 的单位为瓦/米-开尔文 (W m$^{-1}$ K$^{-1}$)，$L_s$ 和 $L_f$ 的单位为米 (m)，温度的单位为开尔文 (K)，$\\varepsilon$ 的单位为开尔文 (K)。\n- 用例 A（通用情况，收敛）：$(k_s = 50, L_s = 0.2, k_f = 50, L_f = 0.1, T_{s,0} = 400, T_{f,L} = 300, \\omega = 1.0, \\varepsilon = 1\\times 10^{-6}, M_{\\max} = 50, T_i^{(0)} = 350)$。\n- 用例 B（刚性问题，通过松弛收敛）：$(k_s = 200, L_s = 0.1, k_f = 50, L_f = 0.1, T_{s,0} = 400, T_{f,L} = 300, \\omega = 0.35, \\varepsilon = 1\\times 10^{-6}, M_{\\max} = 50, T_i^{(0)} = 320)$。\n- 用例 C（刚性问题，无松弛时发散）：$(k_s = 200, L_s = 0.1, k_f = 50, L_f = 0.1, T_{s,0} = 400, T_{f,L} = 300, \\omega = 1.0, \\varepsilon = 1\\times 10^{-6}, M_{\\max} = 10, T_i^{(0)} = 320)$。\n- 用例 D（对称情况，边界温度相等）：$(k_s = 10, L_s = 0.5, k_f = 10, L_f = 0.5, T_{s,0} = 350, T_{f,L} = 350, \\omega = 0.5, \\varepsilon = 1\\times 10^{-12}, M_{\\max} = 5, T_i^{(0)} = 310)$。\n\n每次子迭代 $m$ 需要计算的量：\n- 使用 Fourier 定律，对固体板 $\\left[-L_s,0\\right]$ 应用边界温度 $T_{s,0}$（在 $x=-L_s$ 处）和 $T_i^{(m)}$（在 $x=0$ 处），计算固体侧界面热通量 $q_s^{(m)}$。\n- 在流体板 $\\left[0,L_f\\right]$ 上，施加 $x=0$ 处的热通量 $q_s^{(m)}$ 和 $x=L_f$ 处的边界温度 $T_{f,L}$，计算流体侧界面温度 $T_{f,\\mathrm{int}}^{(m)}$。\n- 失配 $e^{(m)}=\\left|T_i^{(m)}-T_{f,\\mathrm{int}}^{(m)}\\right|$，单位为开尔文。\n\n最终输出格式：您的程序应生成单行输出，其中包含四个用例的序列，形式为以逗号分隔的浮点数列表的列表，并用方括号括起来，无空格，例如 $\\left[\\left[e_{A}^{(0)},e_{A}^{(1)},\\dots\\right],\\left[e_{B}^{(0)},\\dots\\right],\\left[\\dots\\right],\\left[\\dots\\right]\\right]$。所有打印的浮点数必须精确到 $6$ 位小数，单位为开尔文，并记录从 $m=0$ 开始直到该用例满足停止准则的每一次子迭代的结果。", "solution": "在尝试任何解答之前，对所提供的问题进行了严格验证。\n\n第 1 步：提取已知条件。\n问题描述了一个一维、稳态的共轭传热场景。\n- **域**：固体板位于 $x \\in [-L_s, 0]$；流体板位于 $x \\in [0, L_f]$。\n- **物理性质**：固体的热导率 $k_s$ 和流体的热导率 $k_f$ 均为常数。无内部热源。\n- **控制定律**：Fourier 热传导定律 $q = -k\\,\\partial_x T$。在此背景下，每个板内的温度分布是线性的。\n- **边界条件**：指定温度 $T(-L_s) = T_{s,0}$ 和 $T(L_f) = T_{f,L}$。\n- **耦合算法**：为 $x=0$ 处的界面指定了一个带欠松弛的分区狄利克雷-诺伊曼方案。对于每次子迭代 $m$：\n    1.  **固体子问题**：施加狄利克雷条件 $T(0) = T_i^{(m)}$。计算来自固体的热通量 $q_s^{(m)}$。\n    2.  **流体子问题**：施加诺伊曼条件 $-k_f\\,\\partial_x T(0) = q_s^{(m)}$，以及远场狄利克雷条件 $T(L_f) = T_{f,L}$。计算流体侧得到的界面温度 $T_{f,\\text{int}}^{(m)}$。\n    3.  **误差计算**：失配定义为 $e^{(m)} = \\left|T_i^{(m)} - T_{f,\\text{int}}^{(m)}\\right|$。\n    4.  **界面更新**：使用欠松弛方案更新下一次迭代的温度：$T_i^{(m+1)} = (1-\\omega)\\,T_i^{(m)} + \\omega\\,T_{f,\\text{int}}^{(m)}$，其中 $\\omega \\in (0, 1]$。\n    5.  **终止标准**：如果 $e^{(m)} < \\varepsilon$ 或子迭代次数达到最大值 $M_{\\max}$，则过程停止。\n- **初始条件**：为每个用例提供了界面温度的初始猜测值 $T_i^{(0)}$。\n- **测试用例**：提供了四组不同的参数集：$(k_s, L_s, k_f, L_f, T_{s,0}, T_{f,L}, \\omega, \\varepsilon, M_{\\max}, T_i^{(0)})$。\n- **要求输出**：对于每个用例，生成一个失配值序列 $\\{e^{(m)}\\}$，四舍五入到 $6$ 位小数，并记录每次子迭代直到终止。最终输出是一个表示这些序列列表的单行字符串。\n\n第 2 步：使用提取的已知条件进行验证。\n- **科学依据**：该问题基于传热学的基本原理（Fourier 传导定律）和求解耦合多物理场问题的标准数值方法（分区耦合方案）。狄利克雷-诺伊曼分区和 Aitken 欠松弛是计算工程中成熟的技术。该问题具有科学合理性。\n- **适定性与客观性**：问题以数学上精确、客观、无歧义的语言表述。为迭代过程提供唯一解所需的所有参数和条件都已给出。该问题是适定的。\n- **完整性与一致性**：问题陈述是自洽的。每个测试用例的所有必要数据、边界条件、初始条件和算法参数都已明确定义。没有内部矛盾。\n- **相关性**：该问题与计算工程中多物理场耦合方案这一特定主题直接相关。\n\n第 3 步：结论与行动。\n问题有效，科学依据充分，且适定。将根据提供的规范构建解决方案。\n\n迭代方案的推导。\n解决方案的基础是，在稳态、一维、无热源的传导条件下，每个板内的温度剖面是线性的。通用的线性剖面为 $T(x) = ax + b$。\n\n1.  **固体子问题（子迭代 $m$）**：\n    固体中的温度分布 $T_s(x)$ 定义在 $x \\in [-L_s, 0]$ 上。边界条件为 $T_s(-L_s) = T_{s,0}$ 和 $T_s(0) = T_i^{(m)}$。\n    将这些条件应用于 $T_s(x) = a_s x + b_s$：\n    在 $x=0$ 处，$b_s = T_i^{(m)}$。\n    在 $x=-L_s$ 处，$a_s(-L_s) + b_s = T_{s,0}$，得出 $a_s = \\frac{T_s(-L_s) - b_s}{-L_s} = \\frac{T_{s,0} - T_i^{(m)}}{-L_s} = \\frac{T_i^{(m)} - T_{s,0}}{L_s}$。\n    因此，温度剖面为 $T_s(x) = \\left(\\frac{T_i^{(m)} - T_{s,0}}{L_s}\\right)x + T_i^{(m)}$。\n    从固体到界面的热通量（沿正 $x$ 方向）是恒定的，由 Fourier 定律给出：\n    $$q_s^{(m)} = -k_s \\frac{dT_s}{dx} = -k_s a_s = -k_s \\left(\\frac{T_i^{(m)} - T_{s,0}}{L_s}\\right) = k_s \\frac{T_{s,0} - T_i^{(m)}}{L_s}$$\n\n2.  **流体子问题（子迭代 $m$）**：\n    流体中的温度分布 $T_f(x)$ 定义在 $x \\in [0, L_f]$ 上。边界条件为 $x=0$ 处的指定通量和 $x=L_f$ 处的指定温度。\n    $x=0$ 处的通量条件是流入流体的通量等于离开固体的通量 $q_s^{(m)}$。\n    根据 Fourier 定律，$-k_f \\frac{dT_f}{dx}|_{x=0} = q_s^{(m)}$。对于线性剖面 $T_f(x) = a_f x + b_f$，这意味着 $-k_f a_f = q_s^{(m)}$，所以 $a_f = -\\frac{q_s^{(m)}}{k_f}$。\n    $x=L_f$ 处的温度条件是 $T_f(L_f) = T_{f,L}$。应用该条件得到 $a_f L_f + b_f = T_{f,L}$。\n    我们解出 $b_f$：$b_f = T_{f,L} - a_f L_f = T_{f,L} - \\left(-\\frac{q_s^{(m)}}{k_f}\\right)L_f = T_{f,L} + \\frac{q_s^{(m)} L_f}{k_f}$。\n    流体侧预测的界面温度 $T_{f,\\text{int}}^{(m)}$ 是流体在 $x=0$ 处的温度，即 $T_f(0) = b_f$。\n    $$T_{f,\\text{int}}^{(m)} = T_{f,L} + \\frac{L_f}{k_f} q_s^{(m)}$$\n\n3.  **完整的迭代算法**：\n    对于每次子迭代 $m = 0, 1, 2, \\dots$，最多到 $M_{\\max}-1$：\n    - **第 1 步**：给定当前界面温度猜测值 $T_i^{(m)}$，计算来自固体的热通量：\n      $q_s^{(m)} = k_s \\frac{T_{s,0} - T_i^{(m)}}{L_s}$。\n    - **第 2 步**：使用该通量计算流体侧预测的界面温度：\n      $T_{f,\\text{int}}^{(m)} = T_{f,L} + \\frac{L_f}{k_f} q_s^{(m)}$。\n    - **第 3 步**：计算绝对失配并记录其四舍五入后的值：\n      $e^{(m)} = \\left|T_i^{(m)} - T_{f,\\text{int}}^{(m)}\\right|$。存储的值四舍五入到 $6$ 位小数。\n    - **第 4 步**：检查终止条件。如果未四舍五入的误差 $e^{(m)}$ 小于容差 $\\varepsilon$，则循环终止。否则，继续。\n    - **第 5 步**：使用欠松弛更新下一次迭代的界面温度：\n      $T_i^{(m+1)} = (1-\\omega) T_i^{(m)} + \\omega T_{f,\\text{int}}^{(m)}$。\n\n对四个测试用例中的每一个都执行此过程。收集每个用例记录的、四舍五入的误差序列。最终输出格式化为单个字符串，作为这些列表的列表，确保所有数字都精确打印到六位小数。", "answer": "```python\nimport numpy as np\n\ndef solve_case(ks, Ls, kf, Lf, Ts0, TfL, omega, epsilon, M_max, Ti0):\n    \"\"\"\n    Solves a single case of the 1D conjugate heat transfer problem.\n\n    Implements the partitioned Dirichlet-Neumann iterative scheme.\n    \"\"\"\n    errors = []\n    Ti = float(Ti0)\n\n    for m in range(M_max):\n        # Step 1: Solid subproblem - Calculate interface heat flux from solid\n        # q_s > 0 means flux from solid to fluid (positive x-direction)\n        q_s = ks * (Ts0 - Ti) / Ls\n\n        # Step 2: Fluid subproblem - Calculate fluid-predicted interface temperature\n        Tf_int = TfL + (q_s * Lf / kf)\n\n        # Step 3: Calculate interface temperature mismatch\n        e = abs(Ti - Tf_int)\n        \n        # Record the error, rounded as specified\n        errors.append(e)\n        \n        # Step 4: Check for convergence with unrounded error\n        if e < epsilon:\n            break\n\n        # Step 5: Update interface temperature with under-relaxation\n        Ti = (1.0 - omega) * Ti + omega * Tf_int\n\n    return errors\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Test suite: (ks, Ls, kf, Lf, Ts0, TfL, omega, epsilon, M_max, Ti0)\n    test_cases = [\n        # Case A: general, convergent\n        (50.0, 0.2, 50.0, 0.1, 400.0, 300.0, 1.0, 1e-6, 50, 350.0),\n        # Case B: stiff, convergent with relaxation\n        (200.0, 0.1, 50.0, 0.1, 400.0, 300.0, 0.35, 1e-6, 50, 320.0),\n        # Case C: stiff, divergent without relaxation\n        (200.0, 0.1, 50.0, 0.1, 400.0, 300.0, 1.0, 1e-6, 10, 320.0),\n        # Case D: symmetric, equal boundary temperatures\n        (10.0, 0.5, 10.0, 0.5, 350.0, 350.0, 0.5, 1e-12, 5, 310.0),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        # Unpack case parameters and solve\n        errors = solve_case(*case)\n        # Per problem, \"Each recorded e(m) must be rounded to 6 decimal places\"\n        rounded_errors = [round(err, 6) for err in errors]\n        all_results.append(rounded_errors)\n\n    # Format the final output string exactly as required.\n    # \"a comma-separated list of lists of floats, enclosed in square brackets, with no spaces\"\n    # \"All printed floats must be rounded to exactly 6 decimal places\"\n    \n    outer_list_str = []\n    for case_errors in all_results:\n        # Format numbers to ensure 6 decimal places with trailing zeros\n        inner_list_str = \",\".join([f\"{err:.6f}\" for err in case_errors])\n        outer_list_str.append(f\"[{inner_list_str}]\")\n    \n    final_output = f\"[{','.join(outer_list_str)}]\"\n\n    print(final_output)\n\nsolve()\n```", "id": "2416722"}, {"introduction": "在选择多物理场耦合策略时，工程师必须在“整体求解”（monolithic）和“分区求解”（partitioned）之间做出权衡。本练习聚焦于经典的Biot孔隙弹性问题，指导你从偏微分控制方程出发，推导并构建整体系统的矩阵以及分区后的子系统矩阵。通过计算和比较这些矩阵的条件数 $\\kappa_2$，你将从数值稳定性的角度，深刻理解不同求解方案的优缺点，以及物理参数变化对问题“病态性”的影响。[@problem_id:2416736]", "problem": "考虑在有限区间 $[0,L]$ 上的一维 ($1\\text{-}\\mathrm{D}$) 准静态 Biot 多孔弹性固结问题，其中固体位移和孔隙压力均采用齐次 Dirichlet 边界条件。其控制方程为线动量守恒和质量守恒，两者通过多孔弹性的本构定律耦合。您必须使用的基本依据包括：(i) 线性动量守恒，(ii) 多孔骨架中流体的质量守恒，以及 (iii) 骨架的线性弹性本构行为和单相微可压缩孔隙流体。具体而言，假设以下标准形式：\n- 小应变下的线性动量守恒：$\\dfrac{\\partial}{\\partial x}\\left(\\sigma\\right) = 0$，其中应力 $\\sigma = E \\dfrac{\\partial u}{\\partial x} - \\alpha p$，$E$ 是杨氏模量，$u$ 是位移，$\\alpha$ 是 Biot 系数，$p$ 是孔隙压力。\n- 质量守恒：$S \\dfrac{\\partial p}{\\partial t} + \\alpha \\dfrac{\\partial}{\\partial t}\\left(\\dfrac{\\partial u}{\\partial x}\\right) - \\dfrac{\\partial}{\\partial x}\\left(k \\dfrac{\\partial p}{\\partial x}\\right) = 0$，其中 $S$ 是比储水系数，$k$ 是水力传导系数（假定为常数）。\n- 齐次 Dirichlet 边界条件：$u(0,t)=0$，$u(L,t)=0$，$p(0,t)=0$ 和 $p(L,t)=0$。\n\n用包含 $n$ 个内部节点的均匀网格离散化空间域。设网格间距为 $h = L/(n+1)$。使用二阶中心差分近似空间导数，并使用时间步长为 $\\Delta t$ 的后向欧拉法近似新时间层上的时间导数。使用以下作用于内部节点未知量的纯代数离散算子：\n- 离散拉普拉斯算子 $L_h$，通过主对角线元素为 $2/h^2$、第一副对角线元素为 $-1/h^2$ 的三对角格式来近似 $- \\dfrac{\\partial^2}{\\partial x^2}$。\n- 离散一阶导数算子 $D_h$，在内部节点处通过中心差分来近似 $\\dfrac{\\partial}{\\partial x}$，定义为 $(D_h \\, v)_i = \\dfrac{v_{i+1} - v_{i-1}}{2h}$（当这些索引为内部索引时）。在第一个内部节点 $i=1$ 处，根据齐次 Dirichlet 边界条件 $v_0=0$，使用 $(D_h \\, v)_1 = \\dfrac{v_{2} - v_{0}}{2h}$（即舍去范围外的项）；类似地，在最后一个内部节点 $i=n$ 处，根据 $v_{n+1}=0$，使用 $(D_h \\, v)_n = \\dfrac{v_{n+1} - v_{n-1}}{2h}$。\n\n根据这些定义和基本方程，推导出在新时间层 $t^{m+1}$ 的线性代数系统，该系统将位移向量 $u^{m+1} \\in \\mathbb{R}^n$ 和压力向量 $p^{m+1} \\in \\mathbb{R}^n$ 耦合到一个形式如下的整体块矩阵 $A \\in \\mathbb{R}^{2n \\times 2n}$ 中\n$$\nA \\begin{bmatrix} u^{m+1} \\\\ p^{m+1} \\end{bmatrix} = \\text{rhs},\n$$\n并确定在时间层 $t^{m+1}$ 用于分裂（交错）格式的两个子问题矩阵：力学矩阵 $K \\in \\mathbb{R}^{n \\times n}$ 和流动矩阵 $H \\in \\mathbb{R}^{n \\times n}$。\n\n您的任务是：\n1. 从给定的基本定律和定义出发。使用给定的有限差分算子和时间上的后向欧拉法，推导出整体矩阵 $A$ 以及两个子问题矩阵 $K$（力学）和 $H$（流动）的精确代数表达式。除已声明的内容外，不要做任何额外的建模假设。在离散化过程中明确使用齐次 Dirichlet 边界条件，以确保最终得到的矩阵是非奇异的。\n2. 实现一个程序，该程序为给定的参数集构造 $A$、$K$ 和 $H$，并计算它们的 2-范数条件数，其定义为 $\\kappa_2(M) = \\|M\\|_2 \\|M^{-1}\\|_2$（对于任意非奇异矩阵 $M$）。所有条件数均表示为无量纲浮点数。\n3. 使用以下参数值测试套件，该套件旨在探究不同的条件数状况。在所有情况下，域长度均取 $L = 1$：\n   - 案例 1（一般耦合，中等规模）：$n = 10$，$E = 10^5$，$\\alpha = 0.8$，$k = 10^{-6}$，$S = 10^{-4}$，$\\Delta t = 1$。\n   - 案例 2（解耦极限）：$n = 10$，$E = 10^5$，$\\alpha = 0$，$k = 10^{-6}$，$S = 10^{-4}$，$\\Delta t = 1$。\n   - 案例 3（由于低传导系数和低储水率导致的更刚性的流动，更高空间分辨率）：$n = 50$，$E = 10^5$，$\\alpha = 0.8$，$k = 10^{-10}$，$S = 10^{-6}$，$\\Delta t = 1$。\n   - 案例 4（小时间步长，由储水主导的流动块）：$n = 10$，$E = 10^5$，$\\alpha = 0.8$，$k = 10^{-6}$，$S = 10^{-4}$，$\\Delta t = 10^{-4}$。\n4. 对每个案例，计算三个浮点数：$\\kappa_2(A)$、$\\kappa_2(K)$ 和 $\\kappa_2(H)$。将每个浮点数四舍五入到 6 位有效数字。\n5. 最终输出格式：您的程序应生成一行输出，其中包含四个案例的结果，格式为 Python 字面量的列表的列表。每个内部列表按 $[\\kappa_2(A), \\kappa_2(K), \\kappa_2(H)]$ 的顺序包含单个案例的三个四舍五入后的浮点数。例如，打印的输出必须形如\n$[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3],[a_4,b_4,c_4]]$\n不含任何额外文本，其中每个 $a_i$，$b_i$，$c_i$ 都是四舍五入到 6 位有效数字的无量纲浮点数。此问题中不涉及角度，输出中也不应包含任何物理单位，因为条件数是无量纲的。", "solution": "所述问题具有科学依据、是适定且完整的。它基于准静态多孔弹性的标准方程，并使用了常规的数值离散化技术。所有参数和边界条件都已明确定义。因此，可以进行求解。\n\n代数系统的推导从两个控制偏微分方程开始。所有数学实体均按要求使用 LaTeX 渲染。\n\n首先，考虑线性动量守恒。给定形式为：\n$$ \\frac{\\partial}{\\partial x}\\left(\\sigma\\right) = 0 $$\n其中应力 $\\sigma$ 的本构关系为：\n$$ \\sigma = E \\frac{\\partial u}{\\partial x} - \\alpha p $$\n假设杨氏模量 $E$ 在域上为常数，将应力代入守恒定律可得：\n$$ E \\frac{\\partial^2 u}{\\partial x^2} - \\alpha \\frac{\\partial p}{\\partial x} = 0 $$\n该方程在新时间层 $t^{m+1}$ 上求值。我们使用提供的有限差分算子对空间导数进行离散化。二阶导数 $\\frac{\\partial^2}{\\partial x^2}$ 由 $-L_h$ 近似，一阶导数 $\\frac{\\partial}{\\partial x}$ 由 $D_h$ 近似。将这些算子应用于节点未知量向量 $u^{m+1}$ 和 $p^{m+1}$，可得到代数方程：\n$$ E (-L_h u^{m+1}) - \\alpha (D_h p^{m+1}) = \\mathbf{0} $$\n这可以重排为我们目标线性系统的第一块行：\n$$ (E L_h) u^{m+1} + (\\alpha D_h) p^{m+1} = \\mathbf{0} $$\n\n其次，考虑质量守恒方程：\n$$ S \\frac{\\partial p}{\\partial t} + \\alpha \\frac{\\partial}{\\partial t}\\left(\\frac{\\partial u}{\\partial x}\\right) - \\frac{\\partial}{\\partial x}\\left(k \\frac{\\partial p}{\\partial x}\\right) = 0 $$\n假设水力传导系数 $k$ 为常数，方程变为：\n$$ S \\frac{\\partial p}{\\partial t} + \\alpha \\frac{\\partial}{\\partial t}\\left(\\frac{\\partial u}{\\partial x}\\right) + k \\left(-\\frac{\\partial^2 p}{\\partial x^2}\\right) = 0 $$\n时间导数使用一阶后向欧拉格式近似，例如 $\\frac{\\partial p}{\\partial t} \\approx \\frac{p^{m+1}-p^m}{\\Delta t}$。空间导数同样由其离散对应项替代。在时刻 $t^{m+1}$ 的离散化方程为：\n$$ S \\frac{p^{m+1} - p^m}{\\Delta t} + \\alpha \\frac{D_h u^{m+1} - D_h u^m}{\\Delta t} + k L_h p^{m+1} = \\mathbf{0} $$\n为了构建关于 $t^{m+1}$ 时刻未知数的线性系统，我们重排各项，将所有涉及 $u^{m+1}$ 和 $p^{m+1}$ 的项置于左侧，并将所有来自 $t^m$ 时刻的已知项置于右侧。\n$$ \\frac{\\alpha}{\\Delta t} D_h u^{m+1} + \\left( \\frac{S}{\\Delta t} I + k L_h \\right) p^{m+1} = \\frac{S}{\\Delta t} p^m + \\frac{\\alpha}{\\Delta t} D_h u^m $$\n其中 $I$ 是 $n \\times n$ 的单位矩阵。这构成了系统的第二块行。\n\n合并两个离散化方程，我们构建整体块矩阵系统。该系统形如 $A \\begin{bmatrix} u^{m+1} \\\\ p^{m+1} \\end{bmatrix} = \\text{rhs}$，其中整体矩阵 $A \\in \\mathbb{R}^{2n \\times 2n}$ 由以下公式给出：\n$$ A = \\begin{bmatrix} E L_h & \\alpha D_h \\\\ \\frac{\\alpha}{\\Delta t} D_h & \\frac{S}{\\Delta t} I + k L_h \\end{bmatrix} $$\n\n分裂格式的子问题矩阵通常是块系统主对角线上的矩阵，它们对应于解耦的物理过程。力学子问题控制位移，流动子问题控制压力。从 $A$ 的结构中，我们确定：\n力学矩阵 $K \\in \\mathbb{R}^{n \\times n}$：\n$$ K = E L_h $$\n流动矩阵 $H \\in \\mathbb{R}^{n \\times n}$：\n$$ H = \\frac{S}{\\Delta t} I + k L_h $$\n这些就是需要计算条件数的矩阵。由于 $L_h$ 是对称正定的，且所有物理参数 $E, S, k, \\Delta t$ 均为正，因此 $K$ 和 $H$ 都是对称正定且非奇异的。如果 $\\alpha \\neq 0$ 且 $\\Delta t \\neq 1$，则完整矩阵 $A$ 是非对称的。在这些物理条件下，其非奇异性得到保证。\n\n实现部分将为每组参数构造这些矩阵，然后计算它们的 2-范数条件数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _round_to_significant_digits(x, d=6):\n    \"\"\"\n    Rounds a number to a specified number of significant digits.\n    \"\"\"\n    if x == 0:\n        return 0.0\n    return float(f'{x:.{d-1}e}')\n\ndef solve():\n    \"\"\"\n    Derives and analyzes matrices for a 1D poroelastic consolidation problem.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # (n, E, alpha, k, S, dt, L)\n    test_cases = [\n        (10, 1e5, 0.8, 1e-6, 1e-4, 1.0, 1.0),\n        (10, 1e5, 0.0, 1e-6, 1e-4, 1.0, 1.0),\n        (50, 1e5, 0.8, 1e-10, 1e-6, 1.0, 1.0),\n        (10, 1e5, 0.8, 1e-6, 1e-4, 1e-4, 1.0)\n    ]\n\n    results = []\n\n    for case in test_cases:\n        n, E, alpha, k, S, dt, L = case\n        \n        # Grid spacing\n        h = L / (n + 1)\n        \n        # Construct discrete Laplacian operator L_h (approximates -d^2/dx^2)\n        diag_L = np.full(n, 2.0 / h**2)\n        offdiag_L = np.full(n - 1, -1.0 / h**2)\n        L_h = np.diag(diag_L) + np.diag(offdiag_L, k=1) + np.diag(offdiag_L, k=-1)\n        \n        # Construct discrete first-derivative operator D_h (approximates d/dx)\n        offdiag_D_upper = np.full(n - 1, 1.0 / (2.0 * h))\n        offdiag_D_lower = np.full(n - 1, -1.0 / (2.0 * h))\n        D_h = np.diag(offdiag_D_upper, k=1) + np.diag(offdiag_D_lower, k=-1)\n        \n        # Construct mechanical matrix K\n        K = E * L_h\n        \n        # Construct flow matrix H\n        I = np.identity(n)\n        H = (S / dt) * I + k * L_h\n        \n        # Construct monolithic matrix A\n        A11 = K\n        A12 = alpha * D_h\n        A21 = (alpha / dt) * D_h\n        A22 = H\n        A = np.block([[A11, A12], [A21, A22]])\n        \n        # Compute 2-norm condition numbers\n        cond_A = np.linalg.cond(A, p=2)\n        cond_K = np.linalg.cond(K, p=2)\n        cond_H = np.linalg.cond(H, p=2)\n        \n        # Round results to 6 significant digits\n        rounded_cond_A = _round_to_significant_digits(cond_A, d=6)\n        rounded_cond_K = _round_to_significant_digits(cond_K, d=6)\n        rounded_cond_H = _round_to_significant_digits(cond_H, d=6)\n        \n        results.append([rounded_cond_A, rounded_cond_K, rounded_cond_H])\n\n    # Format output as a Python literal string for a list of lists.\n    # No extra spaces are added to maintain a clean literal format.\n    inner_list_strs = []\n    for res in results:\n        # Convert each float in the sublist to string\n        str_res = [str(val) for val in res]\n        inner_list_strs.append(f\"[{','.join(str_res)}]\")\n    \n    final_output_str = f\"[{','.join(inner_list_strs)}]\"\n\n    print(final_output_str)\n\nsolve()\n```", "id": "2416736"}]}