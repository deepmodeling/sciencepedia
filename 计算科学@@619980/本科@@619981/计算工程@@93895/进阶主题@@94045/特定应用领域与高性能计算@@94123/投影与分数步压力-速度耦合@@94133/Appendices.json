{"hands_on_practices": [{"introduction": "在着手编写任何计算流体动力学（CFD）求解器之前，理解其数值稳定性是至关重要的一步。这个实践练习将引导你通过理论分析，推导出一个显式分数步法的最大稳定时间步长 $Δt_{max}$。通过这个过程，你将亲身体会到对流的 Courant-Friedrichs-Lewy (CFL) 条件和显式扩散项的限制是如何结合起来，共同决定整个数值方案的稳定边界的 [@problem_id:2428893]。", "problem": "考虑一个$2$维不可压缩牛顿流体，其运动粘度为 $\\nu$。该流体位于一个均匀的矩形网格上，网格间距为 $\\Delta x$ 和 $\\Delta y$，且在两个方向上均采用周期性边界条件。压力-速度耦合通过投影法（分数步长法）执行：一个显式速度预测步通过显式处理对流和扩散项来推进动量方程，随后是一个压力投影步，用于强制执行离散无散约束。假设速度场已在其分量的恒定界限附近进行了线性化，最大值为 $|u| \\le U_{\\max}$ 和 $|v| \\le V_{\\max}$，其中 $U_{\\max}$ 和 $V_{\\max}$ 是给定的常数。显式预测器使用单个前向欧拉步和针对对流导数的一阶迎风差分以及针对扩散项的标准$5$点拉普拉斯算子来推进速度。投影步是到离散无散子空间上的一个 $\\ell^2$-正交投影。\n\n数值稳定性的定义如下：对于周期性边界条件，单步更新不得增加预测器任何离散傅里叶模态的 $\\ell^2$ 范数；此外，随后的压力投影也不得增加 $\\ell^2$ 范数。\n\n对于下述测试套件中的每一组参数，确定最大稳定时间步长 $\\Delta t_{\\max}$（单位为秒），即对于所有网格允许的波数，上述稳定性要求都成立的最大 $\\Delta t$。请将每个答案以浮点数形式表示，单位为 $\\mathrm{s}$。\n\n使用以下测试套件，其中每个案例都是一个元组 $(\\Delta x,\\Delta y,U_{\\max},V_{\\max},\\nu)$，其中 $\\Delta x$ 和 $\\Delta y$ 的单位是 $\\mathrm{m}$，$U_{\\max}$ 和 $V_{\\max}$ 的单位是 $\\mathrm{m/s}$，$\\nu$ 的单位是 $\\mathrm{m^2/s}$：\n\n- 案例 $1$：$(0.01, 0.02, 1.0, 0.5, 10^{-3})$\n- 案例 $2$：$(0.005, 0.005, 0.0, 0.0, 10^{-4})$\n- 案例 $3$：$(0.1, 0.05, 2.0, 1.0, 0.0)$\n- 案例 $4$：$(0.01, 0.01, 0.3, 0.1, 10^{-3})$\n- 案例 $5$：$(0.005, 0.005, 0.1, 0.1, 10^{-2})$\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$ [x_1,x_2,x_3,x_4,x_5] $），其中 $x_i$ 是为案例 $i$ 计算出的 $\\Delta t_{\\max}$，单位为 $\\mathrm{s}$。", "solution": "所提出的问题具有科学依据、提法恰当且客观。它提出了一个在计算工程相关的偏微分方程数值分析中的标准问题。因此，我们寻求一个严谨的解法。\n\n该问题要求为一个在周期性域上求解$2$维不可压缩纳维-斯托克斯方程的数值格式，找出其最大稳定时间步长 $\\Delta t_{\\max}$。其控制方程为：\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial t} + (\\mathbf{u} \\cdot \\nabla) \\mathbf{u} = -\\nabla p + \\nu \\nabla^2 \\mathbf{u}\n$$\n$$\n\\nabla \\cdot \\mathbf{u} = 0\n$$\n此处，$\\mathbf{u}=(u,v)$ 是速度矢量，$p$ 是运动压力（压力除以常密度 $\\rho$），$\\nu$ 是运动粘度。\n\n该解法采用分数步长法（或投影法）。此方法将速度和压力的更新解耦。\n$1$. 预测步：通过显式推进动量方程（忽略压力梯度项）来计算一个中间速度场 $\\mathbf{u}^*$。\n$$\n\\frac{\\mathbf{u}^* - \\mathbf{u}^n}{\\Delta t} = -(\\mathbf{u}^n \\cdot \\nabla) \\mathbf{u}^n + \\nu \\nabla^2 \\mathbf{u}^n\n$$\n$2$. 投影步：将中间速度 $\\mathbf{u}^*$ 投影到离散无散向量场的空间上，以获得新时间步的速度 $\\mathbf{u}^{n+1}$。此步强制执行了不可压缩约束。\n\n该问题基于离散傅里叶模态的 $\\ell^2$ 范数来定义稳定性。投影步是一个 $\\ell^2$-正交投影，这是一个非扩张算子；其算子范数至多为 $1$。因此，投影步不会放大任何傅里叶模态，也不会引入不稳定性。所以，整个格式的稳定性完全由显式预测步的稳定性决定。\n\n预测步的稳定性通过 von Neumann 稳定性分析进行评估。该分析在线性化版本的预测器方程上进行，其中非线性对流项 $(\\mathbf{u} \\cdot \\nabla)\\mathbf{u}$ 被替换为 $(\\mathbf{U} \\cdot \\nabla)\\mathbf{u}$，$\\mathbf{U}=(U,V)$ 是一个恒定速度。为了确保在给定界限内的任何流动条件下都保持稳定，我们必须考虑最坏情况，即 $|U| = U_{\\max}$ 和 $|V| = V_{\\max}$。\n\n速度的标量分量（记为 $\\phi$）的预测步采用时间上的前向欧拉法、对流项的一阶迎风格式以及扩散项的标准 $5$ 点模板进行离散。在网格点 $(j,l)$ 处的完全离散方程为：\n$$\n\\frac{\\phi_{j,l}^{n+1} - \\phi_{j,l}^{n}}{\\Delta t} = - \\left( U\\frac{\\phi_{j,l}^n - \\phi_{j-\\sigma_x,l}^n}{\\sigma_x\\Delta x} + V\\frac{\\phi_{j,l}^n - \\phi_{j,l-\\sigma_y}^n}{\\sigma_y\\Delta y} \\right) + \\nu \\left( \\frac{\\phi_{j+1,l}^n - 2\\phi_{j,l}^n + \\phi_{j-1,l}^n}{\\Delta x^2} + \\frac{\\phi_{j,l+1}^n - 2\\phi_{j,l}^n + \\phi_{j,l-1}^n}{\\Delta y^2} \\right)\n$$\n其中 $\\sigma_x = \\text{sgn}(U)$ 且 $\\sigma_y = \\text{sgn}(V)$。为了进行稳定性分析，我们使用其大小 $|U|$ 和 $|V|$。该方程可以写成：\n$$\n\\phi_{j,l}^{n+1} = \\phi_{j,l}^{n} - \\Delta t \\left( \\frac{|U|}{\\Delta x}(\\phi_{j,l}^n - \\phi_{j-\\sigma_x,l}^n) + \\frac{|V|}{\\Delta y}(\\phi_{j,l}^n - \\phi_{j,l-\\sigma_y}^n) \\right) + \\Delta t \\nu [\\nabla_h^2 \\phi^n]_{j,l}\n$$\n我们代入单个傅里叶模态 $\\phi_{j,l}^n = \\hat{\\phi}^n(\\theta_x, \\theta_y) e^{i(j\\theta_x + l\\theta_y)}$，其中 $\\theta_x = k_x\\Delta x$ 和 $\\theta_y = k_y\\Delta y$ 是无量纲波数。放大因子 $G = \\hat{\\phi}^{n+1}/\\hat{\\phi}^n$ 被确定为：\n$$\nG(\\theta_x, \\theta_y) = 1 - \\frac{|U|\\Delta t}{\\Delta x}(1-e^{-i\\sigma_x\\theta_x}) - \\frac{|V|\\Delta t}{\\Delta y}(1-e^{-i\\sigma_y\\theta_y}) + \\frac{\\nu\\Delta t}{\\Delta x^2}(2\\cos\\theta_x-2) + \\frac{\\nu\\Delta t}{\\Delta y^2}(2\\cos\\theta_y-2)\n$$\n令 $C_x = \\frac{|U|\\Delta t}{\\Delta x}$ 和 $C_y = \\frac{|V|\\Delta t}{\\Delta y}$ 为库朗数，令 $D_x = \\frac{\\nu\\Delta t}{\\Delta x^2}$ 和 $D_y = \\frac{\\nu\\Delta t}{\\Delta y^2}$ 为扩散数。\n$$\nG = 1 - C_x(1-\\cos\\theta_x) - C_y(1-\\cos\\theta_y) - 2D_x(1-\\cos\\theta_x) - 2D_y(1-\\cos\\theta_y) - i(C_x \\sigma_x \\sin\\theta_x + C_y \\sigma_y \\sin\\theta_y)\n$$\n稳定性要求对于所有 $\\theta_x, \\theta_y \\in [-\\pi, \\pi]$ 都有 $|G| \\le 1$。最严格的条件通常出现在最高频率的模态，即 $\\theta_x \\to \\pm\\pi$ 且 $\\theta_y \\to \\pm\\pi$。我们来考察 $\\theta_x=\\pi, \\theta_y=\\pi$ 的情况。此时，$\\sin\\theta_x = \\sin\\theta_y = 0$ 且 $1-\\cos\\theta_x = 1-\\cos\\theta_y = 2$。\n放大因子变为纯实数：\n$$\nG(\\pi,\\pi) = 1 - 2C_x - 2C_y - 4D_x - 4D_y = 1 - 2(C_x+C_y+2D_x+2D_y)\n$$\n稳定性条件 $|G| \\le 1$ 变为 $-1 \\le G \\le 1$。\n由于所有项 $C_x, C_y, D_x, D_y$ 都是非负的，$G \\le 1$ 总是成立的。\n条件 $G \\ge -1$ 要求：\n$$\n1 - 2(C_x+C_y+2D_x+2D_y) \\ge -1\n$$\n$$\n2 \\ge 2(C_x+C_y+2D_x+2D_y)\n$$\n$$\n1 \\ge C_x+C_y+2D_x+2D_y\n$$\n代入 $C_x, C_y, D_x, D_y$ 的定义，并使用最大速度值 $U_{\\max}$ 和 $V_{\\max}$：\n$$\n1 \\ge \\frac{U_{\\max}\\Delta t}{\\Delta x} + \\frac{V_{\\max}\\Delta t}{\\Delta y} + \\frac{2\\nu\\Delta t}{\\Delta x^2} + \\frac{2\\nu\\Delta t}{\\Delta y^2}\n$$\n提出 $\\Delta t$，我们得到稳定性约束：\n$$\n\\Delta t \\left( \\frac{U_{\\max}}{\\Delta x} + \\frac{V_{\\max}}{\\Delta y} + 2\\nu \\left(\\frac{1}{\\Delta x^2} + \\frac{1}{\\Delta y^2}\\right) \\right) \\le 1\n$$\n这个从最不稳定模态导出的条件，可以被证明是该格式对所有波数都 $L_2$-稳定的充分必要条件。\n当等式成立时，我们获得最大稳定时间步长 $\\Delta t_{\\max}$：\n$$\n\\Delta t_{\\max} = \\frac{1}{\\frac{U_{\\max}}{\\Delta x} + \\frac{V_{\\max}}{\\Delta y} + 2\\nu \\left(\\frac{1}{\\Delta x^2} + \\frac{1}{\\Delta y^2}\\right)}\n$$\n该公式用于计算每个测试案例的结果。如果分母为零（即 $U_{\\max}=V_{\\max}=\\nu=0$），则 $\\Delta t_{\\max}$ 为无穷大，因为平凡系统 $\\partial \\mathbf{u} / \\partial t = 0$ 是无条件稳定的。对于所有给定的测试案例，分母均为正数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the maximum stable time step for a 2D incompressible\n    Navier-Stokes solver using an explicit fractional-step method.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (delta_x, delta_y, U_max, V_max, nu)\n    test_cases = [\n        (0.01, 0.02, 1.0, 0.5, 1e-3),\n        (0.005, 0.005, 0.0, 0.0, 1e-4),\n        (0.1, 0.05, 2.0, 1.0, 0.0),\n        (0.01, 0.01, 0.3, 0.1, 1e-3),\n        (0.005, 0.005, 0.1, 0.1, 1e-2)\n    ]\n\n    results = []\n    for case in test_cases:\n        dx, dy, u_max, v_max, nu = case\n\n        # Numerator of the stability condition is 1. We compute the denominator.\n        \n        # Convective constraint term\n        # This corresponds to the CFL condition part.\n        conv_term = u_max / dx + v_max / dy\n\n        # Diffusive constraint term\n        # This corresponds to the explicit diffusion stability part.\n        diff_term = 0.0\n        if nu > 0:\n            diff_term = 2.0 * nu * (1.0 / dx**2 + 1.0 / dy**2)\n\n        # The overall stability constraint is the sum of the inverses of the\n        # time steps from each physical process.\n        denominator = conv_term + diff_term\n\n        # The maximum stable time step is the reciprocal of this sum.\n        if denominator == 0:\n            # This case occurs if U_max, V_max, and nu are all zero.\n            # The scheme is unconditionally stable, so dt_max is infinite.\n            dt_max = float('inf')\n        else:\n            dt_max = 1.0 / denominator\n        \n        results.append(dt_max)\n\n    # Final print statement in the exact required format.\n    # A comma-separated list of floating-point numbers in square brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2428893"}, {"introduction": "投影方法的核心在于求解压力泊松方程（Pressure Poisson Equation, PPE）以强制实现流场的无散性。这个编码练习将带你深入该过程的实践核心：你将实现一个基本的分数步法，并研究当使用迭代法（如 Jacobi 或 Gauss-Seidel 迭代）近似求解 PPE 时，求解的精度如何直接影响最终速度场的质量守恒（即无散性） [@problem_id:2428935]。这揭示了计算效率与物理约束满足度之间的一个关键权衡。", "problem": "考虑一个周期性方形域中的二维不可压缩流的投影。设域为 $\\Omega = [0,1] \\times [0,1]$，在两个方向上均具有周期性边界条件。设 $\\rho > 0$ 表示常数密度，$\\nu \\ge 0$ 表示运动粘度。设 $N \\in \\mathbb{N}$为每个方向上均匀分布的网格点数，网格间距为 $h = 1/N$。使用同位网格、单元中心离散化，其离散算子由带有周期性环绕的二阶中心差分构建：\n\n- 离散梯度 $\\nabla_h$ 和离散散度 $\\nabla_h \\cdot$ 使用步长为 $h$ 的中心差分逐分量作用。\n- 离散拉普拉斯算子 $\\Delta_h$ 是标准的五点模板\n$$\n(\\Delta_h \\phi)_{i,j} = \\frac{\\phi_{i+1,j} + \\phi_{i-1,j} + \\phi_{i,j+1} + \\phi_{i,j-1} - 4 \\phi_{i,j}}{h^2},\n$$\n其中 $(i \\pm 1)$ 和 $(j \\pm 1)$ 使用周期性索引。\n\n通过在单元中心 $x_j = (j + \\tfrac{1}{2}) h$，$y_i = (i + \\tfrac{1}{2}) h$ 采样的离散流函数 $\\psi$ 定义初始离散速度场 $u^0 = (u^0_x, u^0_y)$：\n$$\nu^0_x = \\frac{\\partial \\psi}{\\partial y}\\Big|_h, \\quad u^0_y = -\\frac{\\partial \\psi}{\\partial x}\\Big|_h,\n$$\n其中 $\\psi(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$，且 $\\tfrac{\\partial}{\\partial x}\\big|_h$、$\\tfrac{\\partial}{\\partial y}\\big|_h$ 是中心差分算子。这种构造方法产生了一个满足 $\\nabla_h \\cdot u^0 = 0$ 的离散场。\n\n设 $\\phi(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$ 是在相同网格点上采样的离散标量势，并定义离散强迫项 $f = (f_x,f_y)$ 为离散梯度 $f = \\alpha \\nabla_h \\phi$，其中 $\\alpha \\in \\mathbb{R}$ 为某个标量振幅。考虑一个时间步长为 $\\Delta t > 0$ 的单次显式分数步法：\n- 预测速度\n$$\nu^\\star = u^0 + \\Delta t\\left(\\nu\\, \\Delta_h u^0 + f\\right).\n$$\n- 通过离散泊松方程更新压力\n$$\n\\Delta_h p^{1} = \\frac{\\rho}{\\Delta t}\\, \\nabla_h \\cdot u^\\star,\n$$\n该方程具有周期性边界条件，并附加约束条件：$p^{1}$ 在网格上的离散平均值为零。\n- 速度修正\n$$\nu^{1} = u^\\star - \\frac{\\Delta t}{\\rho}\\, \\nabla_h p^{1}.\n$$\n\n投影后质量守恒的质量通过修正后速度散度的离散 $L^2$ 范数来量化，\n$$\nE = \\left( h^2 \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left[\\left(\\nabla_h \\cdot u^{1}\\right)_{i,j}\\right]^2 \\right)^{1/2}.\n$$\n\n在实践中，$p^{1}$ 是通过对线性系统 $\\Delta_h p^{1} = \\tfrac{\\rho}{\\Delta t}\\, \\nabla_h \\cdot u^\\star$ 应用迭代求解器来计算的。在此任务中，必须通过精确应用 $k \\in \\mathbb{N}$ 次下列迭代中的一种来近似 $p^{1}$：\n- 逐点雅可比迭代，\n- 或逐点高斯-赛德尔迭代，\n用于求解带有周期性邻点的五点拉普拉斯算子，从零初始猜测开始，并在每次迭代后对 $p^{1}$ 强制执行零均值。\n\n您的程序必须：\n- 实现上述定义的带有周期性边界条件的算子 $\\nabla_h$、$\\nabla_h \\cdot$ 和 $\\Delta_h$。\n- 如上所述，从 $\\psi$ 构建 $u^0$，从 $\\phi$ 构建 $f$。\n- 形成 $u^\\star$，组装右侧项 $\\tfrac{\\rho}{\\Delta t}\\, \\nabla_h \\cdot u^\\star$，并使用指定迭代方法精确进行 $k$ 次迭代计算 $p^1$，每次迭代后强制执行零均值。\n- 计算 $u^{1}$ 和质量守恒误差 $E$。\n\n使用以下测试套件，其中每个案例由一个元组 $(N, \\Delta t, \\nu, \\rho, \\alpha, k, \\text{solver})$ 指定：\n- 案例 $1$：$(N, \\Delta t, \\nu, \\rho, \\alpha, k, \\text{solver}) = (32, 0.01, 0.01, 1.0, 1.0, 1, \\text{\"jacobi\"})$。\n- 案例 $2$：$(32, 0.01, 0.01, 1.0, 1.0, 20, \\text{\"jacobi\"})$。\n- 案例 $3$：$(32, 0.01, 0.01, 1.0, 1.0, 2000, \\text{\"jacobi\"})$。\n- 案例 $4$：$(32, 0.01, 0.01, 1.0, 1.0, 20, \\text{\"gauss-seidel\"})$。\n- 案例 $5$：$(8, 0.01, 0.01, 1.0, 1.0, 100, \\text{\"jacobi\"})$。\n\n所有物理量和数值量均为无量纲。您的程序的最终输出必须是单行文本，包含一个Python风格的列表，其中有5个浮点数结果 $E$，按上述案例顺序排列，每个结果均采用科学记数法格式化，并保留六位有效数字。例如，要求的格式为 $[a,b,c,d,e]$，其中 $a,b,c,d,e$ 中的每一个都以 $\\texttt{1.234567e-03}$ 的格式打印。\n\n您的程序必须只输出一行此格式的文本，且不得读取任何输入。", "solution": "问题陈述经评估有效。它描述了一个在计算流体动力学领域中定义明确的数值实验，该实验基于已建立的不可压缩流分数步法原理。所有参数、算子和程序都得到了明确且无矛盾的规定，使其具有科学依据、适定性和客观性。任务是实现此数值方案，并为一组给定的测试案例计算特定的误差度量。\n\n解决方案按以下结构化步骤实现：\n\n1.  **离散化与离散算子**\n    连续域 $\\Omega = [0,1] \\times [0,1]$ 被离散化为 $N \\times N$ 单元的均匀网格。网格间距为 $h = 1/N$。所有标量场和矢量场都在单元中心定义，其坐标为 $(x_j, y_i) = ((j + 0.5)h, (i + 0.5)h)$，其中 $i,j \\in \\{0, \\dots, N-1\\}$。\n\n    带有周期性边界条件的离散微分算子实现如下：\n    -   **梯度 ($\\nabla_h$)**：对于标量场 $\\phi$，梯度 $(\\nabla_h \\phi)_{i,j} = ((\\partial_x \\phi)_h, (\\partial_y \\phi)_h)_{i,j}$ 使用二阶中心差分计算：\n        $$(\\partial_x \\phi)_h = \\frac{\\phi_{i,j+1} - \\phi_{i,j-1}}{2h}, \\quad (\\partial_y \\phi)_h = \\frac{\\phi_{i+1,j} - \\phi_{i-1,j}}{2h}$$\n    -   **散度 ($\\nabla_h \\cdot$)**：对于矢量场 $u = (u_x, u_y)$，其散度 $(\\nabla_h \\cdot u)_{i,j}$ 为：\n        $$(\\nabla_h \\cdot u)_{i,j} = \\frac{(u_x)_{i,j+1} - (u_x)_{i,j-1}}{2h} + \\frac{(u_y)_{i+1,j} - (u_y)_{i-1,j}}{2h}$$\n    -   **拉普拉斯算子 ($\\Delta_h$)**：对于标量场 $\\phi$，拉普拉斯算子由标准的五点模板给出：\n        $$(\\Delta_h \\phi)_{i,j} = \\frac{\\phi_{i+1,j} + \\phi_{i-1,j} + \\phi_{i,j+1} + \\phi_{i,j-1} - 4\\phi_{i,j}}{h^2}$$\n    所有算子都使用周期性索引（例如，$\\phi_{N,j} = \\phi_{0,j}$，$\\phi_{i,-1} = \\phi_{i,N-1}$）。\n\n2.  **状态初始化**\n    -   初始速度场 $u^0$ 从离散流函数 $\\psi = \\sin(2\\pi x)\\sin(2\\pi y)$ 构建，以确保其离散散度为零（$\\nabla_h \\cdot u^0 = 0$）。其分量定义如下：\n        $$u^0_x = \\frac{\\partial \\psi}{\\partial y}\\Big|_h, \\quad u^0_y = -\\frac{\\partial \\psi}{\\partial x}\\Big|_h$$\n    -   强迫项 $f$ 定义为标量势 $\\phi = \\sin(2\\pi x)\\sin(2\\pi y)$ 的梯度，振幅为 $\\alpha$：\n        $$f = \\alpha \\nabla_h \\phi$$\n\n3.  **分数步法算法**\n    一个时间步的投影法包括三个主要部分：\n    -   **预测步**：通过对动量方程使用显式欧拉步在时间上推进，计算出预测速度场 $u^\\star$。此步骤包含了粘性项和强迫项，但忽略了未知的压力梯度项。\n        $$u^\\star = u^0 + \\Delta t\\left(\\nu\\, \\Delta_h u^0 + f\\right)$$\n        得到的场 $u^\\star$ 通常不是无散度的。\n\n    -   **投影步**：此步骤通过将 $u^\\star$ 投影到无散度场空间来强制执行不可压缩性约束。这通过寻找一个类似压力的场 $p^1$ 来修正速度来实现。场 $p^1$ 是离散泊松方程的解：\n        $$\\Delta_h p^{1} = \\frac{\\rho}{\\Delta t}\\, \\nabla_h \\cdot u^\\star$$\n        该方程是通过对修正后的速度 $u^1 = u^\\star - \\frac{\\Delta t}{\\rho} \\nabla_h p^1$ 强制施加条件 $\\nabla_h \\cdot u^1 = 0$ 推导出来的。在周期性域上，算子 $\\Delta_h$ 是奇异的。通过施加其离散空间平均值为零的约束，即 $\\sum_{i,j} p^1_{i,j} = 0$，可以获得 $p^1$ 的唯一解。\n\n        这个关于 $p^1$ 的线性系统通过以下方法之一精确迭代 $k$ 次来近似求解，初始猜测为 $p^1=0$：\n        -   **逐点雅可比迭代**：一种显式更新规则，其中下一次迭代 $p^{n+1}$ 在每个网格点上的值仅依赖于当前迭代 $p^n$ 的值。网格点 $(i,j)$ 的更新公式为：\n            $$p_{i,j}^{n+1} = \\frac{1}{4}\\left( p_{i+1,j}^n + p_{i-1,j}^n + p_{i,j+1}^n + p_{i,j-1}^n - h^2 (\\tfrac{\\rho}{\\Delta t} \\nabla_h \\cdot u^\\star)_{i,j} \\right)$$\n        -   **逐点高斯-赛德尔迭代**：一种隐式更新规则，其中每个网格点的计算立即使用当前迭代中最新的可用值。对于光栅扫描顺序，更新公式为：\n            $$p_{i,j}^{n+1} = \\frac{1}{4}\\left( p_{i-1,j}^{n+1} + p_{i,j-1}^{n+1} + p_{i+1,j}^n + p_{i,j+1}^n - h^2 (\\tfrac{\\rho}{\\Delta t} \\nabla_h \\cdot u^\\star)_{i,j} \\right)$$\n        每次迭代（扫描）后，通过从压力场中减去平均值来强制执行零均值约束。\n\n    -   **修正步**：通过使用计算出的压力 $p^1$ 的梯度来修正预测速度 $u^\\star$，从而获得该时间步的最终速度场 $u^1$：\n        $$u^{1} = u^\\star - \\frac{\\Delta t}{\\rho}\\, \\nabla_h p^{1}$$\n        根据构造，该场 $u^1$ 能更好地逼近无散度条件。\n\n4.  **误差量化**\n    质量守恒的质量是通过最终速度场 $u^1$ 散度的离散 $L^2$ 范数来衡量的。误差 $E$ 计算如下：\n    $$E = \\left( h^2 \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left[\\left(\\nabla_h \\cdot u^{1}\\right)_{i,j}\\right]^2 \\right)^{1/2}$$\n    $E$ 的值越小，表示不可压缩性约束的执行越精确。所提供的程序实现了这个完整的算法，以计算每个测试案例的 $E$ 值。", "answer": "```python\nimport numpy as np\n\ndef grad(phi, h):\n    \"\"\"Computes the 2D gradient of a scalar field using central differences.\"\"\"\n    dphi_dx = (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2 * h)\n    dphi_dy = (np.roll(phi, -1, axis=0) - np.roll(phi, 1, axis=0)) / (2 * h)\n    return dphi_dx, dphi_dy\n\ndef div(u, h):\n    \"\"\"Computes the 2D divergence of a vector field using central differences.\"\"\"\n    ux, uy = u\n    dux_dx = (np.roll(ux, -1, axis=1) - np.roll(ux, 1, axis=1)) / (2 * h)\n    duy_dy = (np.roll(uy, -1, axis=0) - np.roll(uy, 1, axis=0)) / (2 * h)\n    return dux_dx + duy_dy\n\ndef laplace(phi, h):\n    \"\"\"Computes the 2D Laplacian of a scalar field using a five-point stencil.\"\"\"\n    return (np.roll(phi, 1, axis=0) + np.roll(phi, -1, axis=0) +\n            np.roll(phi, 1, axis=1) + np.roll(phi, -1, axis=1) - 4 * phi) / h**2\n\ndef jacobi_sweep(p, b, h):\n    \"\"\"Performs one sweep of the Jacobi iteration for the Poisson equation.\"\"\"\n    p_new = 0.25 * (np.roll(p, 1, axis=0) + np.roll(p, -1, axis=0) +\n                    np.roll(p, 1, axis=1) + np.roll(p, -1, axis=1) - h**2 * b)\n    return p_new\n\ndef gauss_seidel_sweep(p, b, h):\n    \"\"\"Performs one sweep of the Gauss-Seidel iteration using raster scan.\"\"\"\n    N = p.shape[0]\n    # This function modifies p in place\n    for i in range(N):\n        for j in range(N):\n            # Neighbors are accessed from the single array 'p'. For a raster scan,\n            # (i-1) and (j-1) elements have already been updated in this sweep.\n            neighbors = (p[(i - 1) % N, j] + p[(i + 1) % N, j] +\n                         p[i, (j - 1) % N] + p[i, (j + 1) % N])\n            p[i, j] = 0.25 * (neighbors - h**2 * b[i, j])\n    return p\n\ndef run_simulation(N, dt, nu, rho, alpha, k, solver_type):\n    \"\"\"\n    Executes one full fractional-step simulation and returns the divergence error E.\n    \"\"\"\n    # 1. Grid setup\n    h = 1.0 / N\n    x = (np.arange(N) + 0.5) * h\n    y = (np.arange(N) + 0.5) * h\n    # Use 'xy' indexing for standard matrix layout: array[i, j] -> (y_i, x_j)\n    xx, yy = np.meshgrid(x, y, indexing='xy')\n\n    # 2. Initial and Forcing Fields\n    psi = np.sin(2 * np.pi * xx) * np.sin(2 * np.pi * yy)\n    grad_psi_x, grad_psi_y = grad(psi, h)\n    u0x = grad_psi_y\n    u0y = -grad_psi_x\n    u0 = (u0x, u0y)\n\n    phi = np.sin(2 * np.pi * xx) * np.sin(2 * np.pi * yy)\n    grad_phi_x, grad_phi_y = grad(phi, h)\n    fx = alpha * grad_phi_x\n    fy = alpha * grad_phi_y\n    f = (fx, fy)\n\n    # 3. Tentative Velocity (Prediction Step)\n    lap_u0x = laplace(u0x, h)\n    lap_u0y = laplace(u0y, h)\n    u_star_x = u0x + dt * (nu * lap_u0x + fx)\n    u_star_y = u0y + dt * (nu * lap_u0y + fy)\n    u_star = (u_star_x, u_star_y)\n\n    # 4. Pressure Poisson (Projection Step)\n    div_u_star = div(u_star, h)\n    poisson_rhs = (rho / dt) * div_u_star\n    \n    p1 = np.zeros((N, N))\n    if solver_type == \"jacobi\":\n        for _ in range(k):\n            p1 = jacobi_sweep(p1, poisson_rhs, h)\n            p1 -= np.mean(p1)  # Enforce zero mean\n    elif solver_type == \"gauss-seidel\":\n        for _ in range(k):\n            p1 = gauss_seidel_sweep(p1, poisson_rhs, h)\n            p1 -= np.mean(p1)  # Enforce zero mean\n            \n    # 5. Velocity Correction\n    grad_p1_x, grad_p1_y = grad(p1, h)\n    u1_x = u_star_x - (dt / rho) * grad_p1_x\n    u1_y = u_star_y - (dt / rho) * grad_p1_y\n    u1 = (u1_x, u1_y)\n\n    # 6. Error Calculation\n    div_u1 = div(u1, h)\n    error_E = np.sqrt(h**2 * np.sum(np.square(div_u1)))\n    \n    return error_E\n\ndef solve():\n    test_cases = [\n        # (N, Δt, ν, ρ, α, k, solver)\n        (32, 0.01, 0.01, 1.0, 1.0, 1, \"jacobi\"),\n        (32, 0.01, 0.01, 1.0, 1.0, 20, \"jacobi\"),\n        (32, 0.01, 0.01, 1.0, 1.0, 2000, \"jacobi\"),\n        (32, 0.01, 0.01, 1.0, 1.0, 20, \"gauss-seidel\"),\n        (8, 0.01, 0.01, 1.0, 1.0, 100, \"jacobi\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        E = run_simulation(*case)\n        results.append(E)\n\n    formatted_results = [f\"{res:.5e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2428935"}, {"introduction": "有了对稳定性和核心投影步骤的理解，我们现在可以构建一个完整的求解器并评估其精度。本练习采用经典的泰勒-格林涡（Taylor-Green vortex）问题作为验证案例，它具有精确的解析解，便于我们衡量数值误差。你将通过比较两种不同的时间积分方案（二阶 Adams-Bashforth 和三阶 Runge-Kutta）在对流-扩散步骤中的表现，来探索分数步法第一步中的选择如何影响最终解的整体精度 [@problem_id:2428920]。", "problem": "考虑在周期性方形域 $\\Omega = [0,2\\pi]\\times[0,2\\pi]$ 上的二维不可压缩Navier–Stokes方程，其运动粘度为 $\\nu$，密度为 $\\rho=1$：\n$$\n\\frac{\\partial \\boldsymbol{u}}{\\partial t} + (\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} = -\\nabla p + \\nu \\nabla^2 \\boldsymbol{u},\\quad \\nabla\\cdot \\boldsymbol{u} = 0,\n$$\n其中 $\\boldsymbol{u}(x,y,t) = (u(x,y,t),v(x,y,t))$ 是速度场，$p(x,y,t)$ 是运动压力。使用Taylor–Green涡作为时间 $t=0$ 时的初始条件：\n$$\nu(x,y,0) = U_0 \\sin(x)\\cos(y),\\quad v(x,y,0) = -U_0 \\cos(x)\\sin(y),\n$$\n在 $\\partial\\Omega$ 上具有周期性边界条件。对于所有 $t\\ge 0$，其精确解为：\n$$\nu(x,y,t) = U_0 \\sin(x)\\cos(y)\\, e^{-2\\nu t},\\quad v(x,y,t) = -U_0 \\cos(x)\\sin(y)\\, e^{-2\\nu t},\n$$\n$$\np(x,y,t) = \\frac{U_0^2}{4}\\left(\\cos(2x)+\\cos(2y)\\right)e^{-4\\nu t} + C(t),\n$$\n其中 $C(t)$ 在空间上是均匀的。\n\n使用分步（投影）压力-速度耦合方法在时间上推进速度，该方法通过仅对对流-扩散算子进行积分来计算一个中间速度，然后通过压力修正来强制施加不可压缩性。具体来说，对于从 $t^n$ 到 $t^{n+1}=t^n+\\Delta t$ 的每个时间步，从以下方程计算中间速度 $\\boldsymbol{u}^\\star$：\n$$\n\\frac{\\partial \\boldsymbol{u}}{\\partial t} = -(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nu \\nabla^2 \\boldsymbol{u},\n$$\n对右侧项使用以下时间离散化选项之一：\n- 选项A（二阶Adams–Bashforth，AB2）：一种二阶的两步显式多步法。对于第一步，使用任意阶数至少为二的相容单步法来启动多步序列。\n- 选项B（三阶Runge–Kutta，RK3）：一种总阶数为三的三级显式Runge-Kutta法。\n\n获得 $\\boldsymbol{u}^\\star$ 后，通过求解满足以下条件的标量势 $\\phi$ 来强制施加不可压缩性：\n$$\n\\nabla^2 \\phi = \\frac{1}{\\Delta t}\\nabla\\cdot \\boldsymbol{u}^\\star,\n$$\n然后设置\n$$\n\\boldsymbol{u}^{n+1} = \\boldsymbol{u}^\\star - \\Delta t \\nabla \\phi.\n$$\n假设周期性边界条件和零均值压力（将 $\\phi$ 的空间平均值设为零）。无需物理单位；将所有量视为无量纲。\n\n对于以下所有测试，使用均匀的 $N\\times N$ 网格，其中 $N=32$，域 $\\Omega=[0,2\\pi]^2$，初始振幅 $U_0=1$，粘度 $\\nu=0.01$，最终时间 $T=0.2$。对于每个测试，计算在 $t=T$ 时速度的离散相对 $L^2$ 误差：\n$$\nE = \\left(\\frac{\\sum_{i,j}\\left[(u_{i,j}-u^{\\text{exact}}_{i,j})^2+(v_{i,j}-v^{\\text{exact}}_{i,j})^2\\right]}{\\sum_{i,j}\\left[(u^{\\text{exact}}_{i,j})^2+(v^{\\text{exact}}_{i,j})^2\\right]}\\right)^{1/2},\n$$\n其中 $(u^{\\text{exact}},v^{\\text{exact}})$ 是在 $t=T$ 时的Taylor–Green精确解。\n\n测试组参数（每个测试是一个指定平流步长时间离散化和时间步长的对）：\n1. 方法 AB2, $\\Delta t = 0.01$。\n2. 方法 RK3, $\\Delta t = 0.01$。\n3. 方法 AB2, $\\Delta t = 0.005$。\n4. 方法 RK3, $\\Delta t = 0.005$。\n5. 方法 AB2, $\\Delta t = 0.0025$。\n6. 方法 RK3, $\\Delta t = 0.0025$。\n\n您的程序必须为每个测试计算相对误差 $E$，并生成单行输出，其中包含六个结果，形式为方括号括起来的逗号分隔列表（例如，$[e_1,e_2,e_3,e_4,e_5,e_6]$）。输出必须是实值浮点数。不应打印任何其他文本。", "solution": "所提出的问题是一个适定的、标准的验证案例，用于二维不可压缩Navier-Stokes方程的数值求解器。所有必要的物理参数、初始条件、边界条件和数值规格均已提供。该问题在科学上是合理的，它基于流体动力学的基础方程和已建立的数值方法。因此，我将继续提供完整的解决方案。\n\n问题的核心是求解Navier-Stokes方程：\n$$\n\\frac{\\partial \\boldsymbol{u}}{\\partial t} + (\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} = -\\nabla p + \\nu \\nabla^2 \\boldsymbol{u}\n$$\n$$\n\\nabla\\cdot \\boldsymbol{u} = 0\n$$\n在一个二维周期性域 $\\Omega=[0,2\\pi]^2$ 上。周期性边界条件使得使用傅里叶谱方法进行空间离散化非常有利，因为它提供了高精度和高计算效率。\n\n**空间离散化：伪谱法**\n\n我们使用一个 $N \\times N$ 的均匀网格来离散化域 $\\Omega$，其中 $N=32$。网格点为 $(x_j, y_l) = (j h, l h)$，对于 $j, l \\in \\{0, 1, \\dots, N-1\\}$，网格间距为 $h = 2\\pi/N$。此网格上的函数 $f(x,y)$ 由其值 $f_{j,l} = f(x_j, y_l)$ 表示。\n\n空间导数在傅里叶空间中计算。二维离散傅里叶变换（DFT）及其逆变换（IDFT）用于在物理空间和谱空间表示之间切换。设 $\\hat{f}(k_x, k_y)$ 是 $f(x,y)$ 的DFT。与网格对应的波数是经过适当缩放的 $k_x, k_y \\in \\{0, 1, \\dots, N-1\\}$。对于长度为 $L=2\\pi$ 的域，整数波数为 $m, n \\in \\{-N/2, \\dots, N/2-1\\}$。空间导数算子在傅里叶空间中是对角的：\n$$\n\\frac{\\widehat{\\partial f}}{\\partial x} = i k_x \\hat{f}, \\quad \\frac{\\widehat{\\partial f}}{\\partial y} = i k_y \\hat{f}\n$$\n类似地，拉普拉斯算子变为：\n$$\n\\widehat{\\nabla^2 f} = -(k_x^2 + k_y^2) \\hat{f} = -| \\boldsymbol{k} |^2 \\hat{f}\n$$\n为了计算导数，我们执行一次正向FFT，乘以适当的波数因子（例如，$i k_x$），然后执行一次逆向IFFT。非线性对流项 $(\\boldsymbol{u} \\cdot \\nabla) \\boldsymbol{u}$ 使用伪谱方法计算：导数在傅里叶空间中计算，转换回物理空间，相乘，然后将结果转换回傅里叶空间以进行时间积分步骤。这避免了纯谱方法所需的计算成本高昂的卷积和。\n\n**时间离散化：分步投影法**\n\n通过不可压缩性约束 $\\nabla \\cdot \\boldsymbol{u} = 0$ 实现的速度 $\\boldsymbol{u}$ 和压力 $p$ 之间的耦合，由分步投影法处理。从 $t^n$ 到 $t^{n+1} = t^n + \\Delta t$ 的每个时间步分为两个阶段。\n\n**阶段1：对流-扩散步**\n\n首先，通过推进不含压力梯度项的动量方程来计算中间速度场 $\\boldsymbol{u}^\\star$：\n$$\n\\frac{\\boldsymbol{u}^\\star - \\boldsymbol{u}^n}{\\Delta t} \\approx -(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nu \\nabla^2 \\boldsymbol{u} \\equiv \\boldsymbol{R}(\\boldsymbol{u})\n$$\n右侧项 $\\boldsymbol{R}(\\boldsymbol{u})$ 包含非线性对流项和粘性扩散项。我们使用指定的两种显式方法对这个常微分方程进行离散化。\n\n对于一个通用ODE $\\frac{d\\boldsymbol{y}}{dt} = f(t, \\boldsymbol{y})$：\n\n1.  **三阶Runge-Kutta（RK3）：** 使用三级、三阶显式方法。一个常见的选择，也是此处实现的选择，是经典Kutta三阶格式：\n    $$\n    \\boldsymbol{k}_1 = \\boldsymbol{R}(\\boldsymbol{u}^n)\n    $$\n    $$\n    \\boldsymbol{k}_2 = \\boldsymbol{R}(\\boldsymbol{u}^n + \\frac{\\Delta t}{2}\\boldsymbol{k}_1)\n    $$\n    $$\n    \\boldsymbol{k}_3 = \\boldsymbol{R}(\\boldsymbol{u}^n - \\Delta t \\boldsymbol{k}_1 + 2\\Delta t \\boldsymbol{k}_2)\n    $$\n    $$\n    \\boldsymbol{u}^\\star = \\boldsymbol{u}^n + \\frac{\\Delta t}{6}(\\boldsymbol{k}_1 + 4\\boldsymbol{k}_2 + \\boldsymbol{k}_3)\n    $$\n\n2.  **二阶Adams-Bashforth（AB2）：** 这是一种两步线性多步法。\n    $$\n    \\boldsymbol{u}^\\star = \\boldsymbol{u}^n + \\Delta t \\left( \\frac{3}{2}\\boldsymbol{R}(\\boldsymbol{u}^n) - \\frac{1}{2}\\boldsymbol{R}(\\boldsymbol{u}^{n-1}) \\right)\n    $$\n    此方法不是自启动的；它需要前两个时间层 $t^n$ 和 $t^{n-1}$ 的解。对于第一个时间步（从 $t^0$ 到 $t^1$），我们使用RK3方法生成 $\\boldsymbol{u}^1$，这符合问题对一个阶数至少为二的启动方法的要求。\n\n**阶段2：投影步**\n\n中间速度 $\\boldsymbol{u}^\\star$ 通常不满足不可压缩性约束。第二阶段将 $\\boldsymbol{u}^\\star$ 投影到无散矢量场空间上，以获得最终速度 $\\boldsymbol{u}^{n+1}$。Hodge分解定理保证 $\\boldsymbol{u}^\\star$ 可以唯一地分解为一个无散部分和一个标量势的梯度。\n$$\n\\boldsymbol{u}^\\star = \\boldsymbol{u}^{n+1} + \\nabla \\phi'\n$$\n其中 $\\nabla \\cdot \\boldsymbol{u}^{n+1} = 0$。对该方程取散度得到：\n$$\n\\nabla \\cdot \\boldsymbol{u}^\\star = \\nabla^2 \\phi'\n$$\n问题将速度更新定义为 $\\boldsymbol{u}^{n+1} = \\boldsymbol{u}^\\star - \\Delta t \\nabla \\phi$，这意味着 $\\phi' = \\Delta t \\phi$。将此代入泊松方程得到：\n$$\n\\nabla^2 \\phi = \\frac{1}{\\Delta t} \\nabla \\cdot \\boldsymbol{u}^\\star\n$$\n这个关于势 $\\phi$ 的泊松方程在傅里叶空间中可以高效求解。变换该方程得到：\n$$\n-|\\boldsymbol{k}|^2 \\hat{\\phi} = \\frac{1}{\\Delta t} \\widehat{\\nabla \\cdot \\boldsymbol{u}^\\star} = \\frac{1}{\\Delta t} (i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star)\n$$\n势的傅里叶系数的解为：\n$$\n\\hat{\\phi} = - \\frac{i}{|\\boldsymbol{k}|^2 \\Delta t} (k_x \\hat{u}^\\star + k_y \\hat{v}^\\star)\n$$\n对于零波数模式（$k_x = k_y = 0$），$|\\boldsymbol{k}|^2=0$。问题指定了零均值压力，这转化为零均值势，所以我们设置 $\\hat{\\phi}(0,0)=0$。对于所有其他模式，$|\\boldsymbol{k}|^2 > 0$。\n\n最终速度更新 $\\boldsymbol{u}^{n+1} = \\boldsymbol{u}^\\star - \\Delta t \\nabla\\phi$ 也在傅里叶空间中执行以优化性能。更新的傅里叶表示为：\n$$\n\\hat{\\boldsymbol{u}}^{n+1} = \\hat{\\boldsymbol{u}}^\\star - \\Delta t (i\\boldsymbol{k}) \\hat{\\phi}\n$$\n代入 $\\hat{\\phi}$ 的表达式，我们直接得到投影操作：\n$$\n\\hat{\\boldsymbol{u}}^{n+1} = \\hat{\\boldsymbol{u}}^\\star - \\frac{\\boldsymbol{k}(\\boldsymbol{k} \\cdot \\hat{\\boldsymbol{u}}^\\star)}{|\\boldsymbol{k}|^2}\n$$\n此操作将傅里叶变换后的中间速度矢量 $\\hat{\\boldsymbol{u}}^\\star$ 投影到垂直于波数矢量 $\\boldsymbol{k}$ 的平面上，从而强制施加无散条件 $\\boldsymbol{k} \\cdot \\hat{\\boldsymbol{u}}^{n+1}=0$。在此投影之后，一次逆FFT得到最终的、无散的速度场 $\\boldsymbol{u}^{n+1}$ 在物理空间中的表示。\n\n**算法总结**\n\n1.  用 $t=0$ 时的Taylor-Green涡解初始化速度场 $\\boldsymbol{u}^0(x,y)$。\n2.  在傅里叶空间中设置计算网格、波数 $\\boldsymbol{k}$ 和逆拉普拉斯算子 $1/|\\boldsymbol{k}|^2$。\n3.  从 $t=0$ 到 $T$ 以步长 $\\Delta t$ 循环时间步：\n    a. 计算对流-扩散项 $\\boldsymbol{R}(\\boldsymbol{u}^n)$，如果使用AB2，则检索 $\\boldsymbol{R}(\\boldsymbol{u}^{n-1})$。\n    b. 使用RK3或AB2格式进行时间推进，以找到中间速度 $\\boldsymbol{u}^\\star$。\n    c. 将 $\\boldsymbol{u}^\\star$ 变换到傅里叶空间以获得 $\\hat{\\boldsymbol{u}}^\\star$。\n    d. 在傅里叶空间中应用投影算子以强制施加不可压缩性，得到 $\\hat{\\boldsymbol{u}}^{n+1}$。\n    e. 将 $\\hat{\\boldsymbol{u}}^{n+1}$ 变换回物理空间以获得 $\\boldsymbol{u}^{n+1}$。\n4.  在最终时间 $t=T$ 时，在网格上计算精确解。\n5.  计算数值解与精确解之间的离散相对 $L^2$ 误差 $E$。\n6.  对所有指定的测试案例重复以上步骤。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 2D incompressible Navier-Stokes equations for the Taylor-Green\n    vortex problem using a fractional-step projection method with a\n    pseudospectral spatial discretization.\n    \"\"\"\n\n    def run_simulation(method, dt, N, U0, nu, T):\n        \"\"\"\n        Runs a single simulation for a given set of parameters.\n\n        Args:\n            method (str): Time integration method, 'AB2' or 'RK3'.\n            dt (float): Time step size.\n            N (int): Grid resolution (N x N).\n            U0 (float): Initial velocity amplitude.\n            nu (float): Kinematic viscosity.\n            T (float): Final time.\n\n        Returns:\n            float: The relative L2 error at the final time.\n        \"\"\"\n        # Grid and wavenumbers\n        L = 2 * np.pi\n        h = L / N\n        x = np.arange(N) * h\n        X, Y = np.meshgrid(x, x, indexing='ij')\n\n        k_ = np.fft.fftfreq(N) * N\n        Kx, Ky = np.meshgrid(k_, k_, indexing='ij')\n        K2 = Kx**2 + Ky**2\n        \n        # Precompute inverse Laplacian for projection step\n        K2_inv = np.zeros_like(K2)\n        K2_inv[K2 > 0] = 1.0 / K2[K2 > 0]\n\n        # Initial condition\n        u = U0 * np.sin(X) * np.cos(Y)\n        v = -U0 * np.cos(X) * np.sin(Y)\n\n        def compute_rhs(u_field, v_field):\n            \"\"\"Computes the advection-diffusion term R(u).\"\"\"\n            u_hat = np.fft.fft2(u_field)\n            v_hat = np.fft.fft2(v_field)\n\n            # Derivatives in Fourier space\n            dudx_hat = 1j * Kx * u_hat\n            dudy_hat = 1j * Ky * u_hat\n            dvdx_hat = 1j * Kx * v_hat\n            dvdy_hat = 1j * Ky * v_hat\n\n            # Transform derivatives to physical space\n            dudx = np.fft.ifft2(dudx_hat).real\n            dudy = np.fft.ifft2(dudy_hat).real\n            dvdx = np.fft.ifft2(dvdx_hat).real\n            dvdy = np.fft.ifft2(dvdy_hat).real\n\n            # Nonlinear advection term\n            conv_u = u_field * dudx + v_field * dudy\n            conv_v = u_field * dvdx + v_field * dvdy\n\n            # Viscous diffusion term\n            lap_u = np.fft.ifft2(-K2 * u_hat).real\n            lap_v = np.fft.ifft2(-K2 * v_hat).real\n            \n            # Combine terms for RHS\n            rhs_u = -conv_u + nu * lap_u\n            rhs_v = -conv_v + nu * lap_v\n            \n            return rhs_u, rhs_v\n\n        def project(u_star, v_star):\n            \"\"\"Projects the intermediate velocity onto a divergence-free field.\"\"\"\n            u_star_hat = np.fft.fft2(u_star)\n            v_star_hat = np.fft.fft2(v_star)\n            \n            # Enforce divergence-free condition in Fourier space\n            k_dot_u_star = Kx * u_star_hat + Ky * v_star_hat\n            proj_factor = k_dot_u_star * K2_inv\n            \n            u_next_hat = u_star_hat - Kx * proj_factor\n            v_next_hat = v_star_hat - Ky * proj_factor\n            \n            u_next = np.fft.ifft2(u_next_hat).real\n            v_next = np.fft.ifft2(v_next_hat).real\n            \n            return u_next, v_next\n\n        num_steps = int(np.ceil(T / dt))\n        t = 0.0\n        \n        # Time-stepping loop\n        if method == 'AB2':\n            # Startup step using RK3\n            k1_u, k1_v = compute_rhs(u, v)\n            \n            u_tmp = u + 0.5 * dt * k1_u\n            v_tmp = v + 0.5 * dt * k1_v\n            k2_u, k2_v = compute_rhs(u_tmp, v_tmp)\n\n            u_tmp2 = u - dt * k1_u + 2.0 * dt * k2_u\n            v_tmp2 = v - dt * k1_v + 2.0 * dt * k2_v\n            k3_u, k3_v = compute_rhs(u_tmp2, v_tmp2)\n\n            u_star = u + (dt / 6.0) * (k1_u + 4.0 * k2_u + k3_u)\n            v_star = v + (dt / 6.0) * (k1_v + 4.0 * k2_v + k3_v)\n\n            u, v = project(u_star, v_star)\n            t += dt\n            \n            rhs_u_prev, rhs_v_prev = k1_u, k1_v\n\n            for _ in range(1, num_steps):\n                rhs_u_curr, rhs_v_curr = compute_rhs(u, v)\n                u_star = u + dt * (1.5 * rhs_u_curr - 0.5 * rhs_u_prev)\n                v_star = v + dt * (1.5 * rhs_v_curr - 0.5 * rhs_v_prev)\n                \n                u, v = project(u_star, v_star)\n                rhs_u_prev, rhs_v_prev = rhs_u_curr, rhs_v_curr\n                t += dt\n\n        elif method == 'RK3':\n            for _ in range(num_steps):\n                k1_u, k1_v = compute_rhs(u, v)\n                \n                u_tmp = u + 0.5 * dt * k1_u\n                v_tmp = v + 0.5 * dt * k1_v\n                k2_u, k2_v = compute_rhs(u_tmp, v_tmp)\n\n                u_tmp2 = u - dt * k1_u + 2.0 * dt * k2_u\n                v_tmp2 = v - dt * k1_v + 2.0 * dt * k2_v\n                k3_u, k3_v = compute_rhs(u_tmp2, v_tmp2)\n\n                u_star = u + (dt / 6.0) * (k1_u + 4.0 * k2_u + k3_u)\n                v_star = v + (dt / 6.0) * (k1_v + 4.0 * k2_v + k3_v)\n\n                u, v = project(u_star, v_star)\n                t += dt\n\n        # Final time might not be exactly T, but problem seems to imply fixed steps\n        final_time = num_steps * dt\n\n        # Exact solution at final time T\n        decay = np.exp(-2.0 * nu * final_time)\n        u_exact = U0 * np.sin(X) * np.cos(Y) * decay\n        v_exact = -U0 * np.cos(X) * np.sin(Y) * decay\n\n        # Compute relative L2 error\n        error_num = np.sum((u - u_exact)**2 + (v - v_exact)**2)\n        error_den = np.sum(u_exact**2 + v_exact**2)\n        \n        return np.sqrt(error_num / error_den)\n\n    # Test suite parameters\n    N = 32\n    U0 = 1.0\n    nu = 0.01\n    T = 0.2\n\n    test_cases = [\n        ('AB2', 0.01),\n        ('RK3', 0.01),\n        ('AB2', 0.005),\n        ('RK3', 0.005),\n        ('AB2', 0.0025),\n        ('RK3', 0.0025),\n    ]\n\n    results = []\n    for method, dt in test_cases:\n        error = run_simulation(method, dt, N, U0, nu, T)\n        results.append(error)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2428920"}]}