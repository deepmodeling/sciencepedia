{"hands_on_practices": [{"introduction": "黄金分割搜索是一种强大的工具，但它的成功依赖于一个关键假设：函数的单峰性。在将一个问题转化为优化问题之前，我们必须仔细审视这种转化的有效性。这个练习将探讨一个常见但充满陷阱的场景：将求根问题 $g(x)=c$ 转化为最小化问题 $\\min (g(x)-c)^2$，从而帮助你深入理解黄金分割搜索的应用前提和潜在的失效模式。[@problem_id:2421149]", "problem": "一位计算工程领域的工程师需要求解闭区间 $[a,b]$ 上的标量方程 $g(x)=c$。为此，该工程师建议使用黄金分割搜索（GSS）在 $[a,b]$ 上最小化残差平方 $f(x)=(g(x)-c)^2$。假设 $g$ 在 $[a,b]$ 上连续，在 $(a,b)$ 上至少一次可微。请选择所有关于此方法有效性及其与局部最小值相关的陷阱的正确陈述。\n\nA. 如果 $g$ 在 $[a,b]$ 上是连续且严格单调的，并且 $c\\in g([a,b])$, 那么 $f(x)$ 在 $[a,b]$ 上是单峰的，在 $g(x)=c$ 的唯一解处有唯一的全局最小值点，因此在任何包含该解的区间 $[a,b]$ 上对 $f$ 应用 GSS 将会返回一个根。\n\nB. $f(x)$ 的驻点仅是 $g(x)=c$ 的解。\n\nC. 如果 $g$ 在 $[a,b]$ 上是非单调的，那么 $f(x)$ 可以在 $g'(x)=0$ 且 $g(x)\\neq c$ 的点处有局部最小值，因此在这样的区间上对 $f$ 运行 GSS 可能会收敛到一个非根的局部最小值点，这取决于初始区间。\n\nD. 如果 $c\\notin g([a,b])$，那么在 $[a,b]$ 上用 GSS 最小化 $f$ 不会产生 $g(x)=c$ 的根；相反，它将收敛到 $[a,b]$ 中的一个点（可能是一个端点），该点具有非零残差。\n\nE. 将残差平方使得对于任何可微的 $g$，$f(x)$ 在 $[a,b]$ 上都是凸的，因此不存在伪局部最小值，并且如果实数线上的任何地方存在根，GSS 总能找到它。", "solution": "对问题陈述进行有效性评估。\n\n**步骤 1：提取已知条件**\n- 待解方程：$g(x) = c$\n- 定义域：闭区间 $[a, b]$\n- 提议方法：最小化函数 $f(x) = (g(x) - c)^2$\n- 优化算法：黄金分割搜索 (GSS)\n- $g(x)$ 的性质：\n    - 在 $[a, b]$ 上连续\n    - 在 $(a, b)$ 上至少一次可微\n- 任务：评估关于此方法有效性及其陷阱的陈述。\n\n**步骤 2：使用已知条件进行验证**\n- **科学依据：** 该问题描述了数值分析中的一种标准技术：将求根问题重构为最小化问题。所涉及的函数、概念（连续性、可微性、单调性、单峰性）和算法（GSS）在数学和计算工程中都有明确的定义。该方法在科学上是有效的。\n- **适定性：** 该问题提供了足够的信息来根据给定的 $g(x)$ 性质分析函数 $f(x)$ 的数学性质。选项中提出的问题是精确的，可以用数学严谨性来回答。\n- **客观性：** 问题和待评估的陈述是客观的，没有主观论断。它们的正确性可以通过数学证明或反例来确定。\n\n该问题不违反任何无效性标准。它是科学合理的、适定的、客观的且可形式化的。\n\n**步骤 3：结论与行动**\n该问题是有效的。将推导完整解法。\n\n**核心原理推导**\n\n该问题建议通过最小化残差平方函数 $f(x) = (g(x) - c)^2$ 来找到 $g(x) = c$ 的根。$f(x)$ 的全局最小值出现在 $f(x) = 0$ 的地方，这当且仅当 $g(x) = c$ 时成立。因此，$f(x)$ 的全局最小值点正是 $g(x) = c$ 的根。\n\n黄金分割搜索（GSS）是一种算法，只有当函数在某个区间上是**单峰**的，才能保证在该区间上找到函数的最小值。一个函数如果在某个区间内只有一个局部最小值，则称其在该区间上是单峰的。如果一个函数有多个局部最小值（即不是单峰的），GSS 可能会收敛到一个非全局最小值的局部最小值，具体取决于初始搜索区间。\n\n为了理解 GSS 在 $f(x)$ 上的行为，我们必须分析 $f(x)$ 的驻点，这些驻点决定了它的局部最小值和最大值。使用链式法则， $f(x)$ 的一阶导数是：\n$$ f'(x) = 2(g(x) - c) \\cdot g'(x) $$\n$f(x)$ 的驻点是使 $f'(x) = 0$ 的 $x$ 值。这当且仅当以下情况发生时成立：\n$$ g(x) - c = 0 \\quad \\text{或} \\quad g'(x) = 0 $$\n这表明 $f(x)$ 的驻点由两组构成：\n$1$. $g(x) = c$ 的根。\n$2$. $g(x)$ 本身的驻点。\n\n后一类点，即 $g'(x)=0$ 但 $g(x) \\neq c$ 的点，可能会在 $f(x)$ 中引入“伪”局部最小值，这些点不是原方程的根。\n\n为了确定一个驻点 $x_0$ 是否为局部最小值，我们可以检查其二阶导数 $f''(x_0)$:\n$$ f''(x) = 2(g'(x))^2 + 2(g(x) - c)g''(x) $$\n在一个驻点 $x_0$ 处，如果 $g'(x_0) = 0$ 且 $g(x_0) \\neq c$，二阶导数简化为：\n$$ f''(x_0) = 2(g(x_0) - c)g''(x_0) $$\n要使 $x_0$ 成为 $f$ 的局部最小值，我们需要 $f''(x_0)  0$。这个条件是可以满足的，如选项C的分析所示。\n\n**逐项分析**\n\n**A. 如果 $g$ 在 $[a,b]$ 上是连续且严格单调的，并且 $c\\in g([a,b])$, 那么 $f(x)$ 在 $[a,b]$ 上是单峰的，在 $g(x)=c$ 的唯一解处有唯一的全局最小值点，因此在任何包含该解的区间 $[a,b]$ 上对 $f$ 应用 GSS 将会返回一个根。**\n\n如果 $g(x)$ 在 $[a,b]$ 上是连续且严格单调的，并且 $c$ 在该区间上 $g$ 的值域内，根据介值定理，保证在 $[a,b]$ 中存在一个唯一的解 $x^*$ 使得 $g(x^*) = c$。在该点，$f(x^*) = (g(x^*) - c)^2 = 0$。由于对所有 $x$ 都有 $f(x) \\ge 0$，$x^*$ 是一个全局最小值点。\n\n因为 $g(x)$ 是严格单调的，$g'(x)$ 在 $(a, b)$ 上不改变符号且非零（可能只在不构成 $g$ 局部极值的孤立点上为零）。$f'(x) = 2(g(x) - c)g'(x)$ 为零的唯一方式是 $g(x) - c = 0$，这只在 $x = x^*$ 时发生。因此，$f(x)$ 在该区间内只有一个驻点。\n假设 $g(x)$ 是严格递增的，所以 $g'(x)  0$。\n- 对于 $x  x^*$，$g(x)  g(x^*) = c$，所以 $g(x) - c  0$。因此，$f'(x) = 2(\\text{负})(\\text{正})  0$。\n- 对于 $x  x^*$，$g(x)  g(x^*) = c$，所以 $g(x) - c  0$。因此，$f'(x) = 2(\\text{正})(\\text{正})  0$。\n这表明 $f(x)$ 在 $x  x^*$ 时是递减的，在 $x  x^*$ 时是递增的。因此，$f(x)$ 在 $[a,b]$ 上是单峰的，其唯一最小值在 $x^*$。GSS 是为单峰函数设计的，将正确地收敛到这个唯一的最小值点。\n结论：**正确**。\n\n**B. $f(x)$ 的驻点仅是 $g(x)=c$ 的解。**\n\n如上推导，当 $f'(x) = 2(g(x) - c) g'(x) = 0$ 时，$f(x)$ 出现驻点。这个方程在 $g(x) = c$ 或 $g'(x) = 0$ 时成立。如果存在一个点 $x_0$，使得 $g(x)$ 在该点有局部极值（因此 $g'(x_0) = 0$）且 $g(x_0) \\neq c$，那么 $x_0$ 是 $f(x)$ 的一个驻点，但不是 $g(x) = c$ 的解。例如，设 $g(x) = x^2$ 且 $c=4$。解是 $x=\\pm 2$。需要最小化的函数是 $f(x) = (x^2 - 4)^2$。其导数是 $f'(x) = 2(x^2 - 4)(2x) = 4x(x-2)(x+2)$。驻点是 $x=0$，$x=2$ 和 $x=-2$。点 $x=0$ 是 $f(x)$ 的一个驻点，因为 $g'(0)=0$，但 $g(0) = 0 \\neq 4$，所以它不是一个解。\n结论：**不正确**。\n\n**C. 如果 $g$ 在 $[a,b]$ 上是非单调的，那么 $f(x)$ 可以在 $g'(x)=0$ 且 $g(x)\\neq c$ 的点处有局部最小值，因此在这样的区间上对 $f$ 运行 GSS 可能会收敛到一个非根的局部最小值点，这取决于初始区间。**\n\n如果 $g(x)$ 是非单调的，那么在 $(a,b)$ 中必须至少存在一个点 $x_0$ 使得 $g'(x_0)=0$。这个点是 $f(x)$ 的一个驻点。我们必须检查它是否能成为一个局部最小值。如一般推导中所示，$f''(x_0) = 2(g(x_0) - c)g''(x_0)$。我们可以使这个值为正。\n考虑 $g(x) = x^3 - 4x$。那么 $g'(x) = 3x^2 - 4$，在 $x_0 = \\pm 2/\\sqrt{3}$ 处为零。我们选择 $x_0 = 2/\\sqrt{3}$。在此点，$g(x)$ 有一个局部最小值：$g(2/\\sqrt{3}) = (8/3\\sqrt{3}) - (8/\\sqrt{3}) = -16/(3\\sqrt{3})$ 且 $g''(x) = 6x$，所以 $g''(2/\\sqrt{3}) = 12/\\sqrt{3}  0$。\n让我们为 $c  g(x_0)$ 找一个根。例如，设 $c = -6$。方程是 $x^3-4x = -6$。要最小化的函数是 $f(x)=(x^3-4x+6)^2$。存在一个实根 $x^*$（例如，$g(-3)=-15$，$g(-2)=0$，所以根在 $-3$ 和 $-2$ 之间）。\n在 $g(x)$ 的驻点 $x_0=2/\\sqrt{3}$ 处，我们有 $g(x_0) = -16/(3\\sqrt{3}) \\approx -3.078$，不等于 $c=-6$。 $f(x)$ 在 $x_0$ 处的二阶导数是 $f''(x_0) = 2(g(x_0)-c)g''(x_0) = 2(-16/(3\\sqrt{3}) - (-6)) (12/\\sqrt{3}) = 2(-3.078+6)(6.928)  0$。\n所以，$x_0 = 2/\\sqrt{3}$ 是 $f(x)$ 的一个局部最小值。由于 $f(x_0) = (g(x_0)-c)^2  0$，而全局最小值是 $f(x^*)=0$，所以 $f(x)$ 不是单峰的。在一个包含 $x_0$ 但不包含 $x^*$ 的区间（例如 $[0,2]$）上启动GSS可能会收敛到局部最小值点 $x_0$，而它不是 $g(x)=c$ 的根。\n结论：**正确**。\n\n**D. 如果 $c\\notin g([a,b])$，那么在 $[a,b]$ 上用 GSS 最小化 $f$ 不会产生 $g(x)=c$ 的根；相反，它将收敛到 $[a,b]$ 中的一个点（可能是一个端点），该点具有非零残差。**\n\n前提是 $c$ 不在区间 $[a,b]$ 上 $g(x)$ 的值域内。这意味着在 $[a,b]$ 中不存在 $x$ 使得 $g(x) = c$。因此，该区间内不存在根。函数 $f(x) = (g(x) - c)^2$ 对于所有 $x \\in [a,b]$ 都是严格为正的。作为一个在紧集 $[a,b]$ 上的连续函数，$f(x)$ 必须在该区间上达到一个全局最小值，并且这个最小值将大于零。这个最小值出现的点 $x_{min}$ 代表了在 $[a,b]$ 中对解的最好“最小二乘”近似。\n由于不存在根，GSS 不能产生根。它要做的是搜索 $f(x)$ 的一个最小值。GSS 迭代地缩小搜索区间。假设它收敛（它会的，因为区间在缩小），它将收敛到初始区间内对应于 $f(x)$ 最小值的一个点。由于 $f(x)$ 的最小值严格为正，找到的点将具有非零残差，即 $f(x_{min})  0$。例如，如果 $f(x)$ 在 $[a,b]$ 上是单调的，这样的最小值可能出现在端点。该陈述准确地描述了结果是一个最小二乘解，而不是一个根。\n结论：**正确**。\n\n**E. 将残差平方使得对于任何可微的 $g$，$f(x)$ 在 $[a,b]$ 上都是凸的，因此不存在伪局部最小值，并且如果实数线上的任何地方存在根，GSS 总能找到它。**\n\n这个陈述有几个不正确的论断。\n$1$. **凸性**：$f(x)$ 通常不是凸的。如上所示，$f''(x) = 2(g'(x))^2 + 2(g(x) - c)g''(x)$。第二项，$2(g(x) - c)g''(x)$，可以是负的，并且足够大以使 $f''(x)  0$。举一个反例，设 $g(x) = \\sin(x)$ 和 $c=0$。那么 $f(x) = \\sin^2(x)$。$f''(x) = 2\\cos(2x)$，它在 $x \\in (\\pi/4, 3\\pi/4)$ 区间内为负，所以 $f(x)$ 在此区间上不是凸的。\n$2$. **无伪局部最小值**：如选项C所证明，当 $g(x)$ 非单调时，伪（非根）局部最小值可能并且确实存在。凸性是单峰性的一个充分（但非必要）条件。由于 $f(x)$ 并不总是凸的，关于不存在伪最小值的说法是错误的。\n$3$. **总能找到任何地方的根**：GSS 是一种局部搜索方法，受限于其初始搜索区间 $[a, b]$。它没有机制去寻找位于该区间之外的根。\n这个陈述的每一部分都是错误的。\n结论：**不正确**。", "answer": "$$\\boxed{ACD}$$", "id": "2421149"}, {"introduction": "理论知识最终需要通过实践来巩固。本练习将指导你从头开始实现黄金分割搜索算法，解决一个经典的几何问题：寻找曲线上离给定点最近的点。通过这个编码实践，你不仅会掌握算法的实现细节，还将学会如何处理实际应用中的数值技巧，例如通过最小化距离的平方来提高计算效率和稳定性。[@problem_id:2398578]", "problem": "要求您实现一个使用黄金分割搜索的一维优化器，以解决曲线上的一维几何投影问题。设曲线由标量函数 $f:\\mathbb{R}\\to\\mathbb{R}$ 给出，并给定一个固定的目标点 $(x_0,y_0)\\in\\mathbb{R}^2$。目标是通过在闭区间 $[a,b]$ 上最小化距离函数 $D(x)=\\sqrt{(x-x_0)^2+(f(x)-y_0)^2}$，找到曲线上与目标点欧几里得距离最近的点。您的程序必须仅依赖于对 $f(x)$ 的函数求值，并且不得使用导数或高阶模型。\n\n使用以下基础理论：\n- 点 $(x,f(x))$ 与 $(x_0,y_0)$ 之间的欧几里得距离为 $D(x)=\\sqrt{(x-x_0)^2+(f(x)-y_0)^2}$。\n- 严格递增的变换不改变最小化点：如果 $g$ 是严格递增的，且 $x^\\ast\\in \\arg\\min_{x\\in[a,b]} h(x)$，那么 $x^\\ast\\in \\arg\\min_{x\\in[a,b]} g(h(x))$。\n- 黄金分割搜索是一种区间收缩法，它通过仅使用函数求值和固定的比例来放置内点，在 $[a,b]$ 上寻找一个连续单峰函数的最小化点，并不断缩小区间，直到满足容差准则。\n\n您的任务：\n1. 实现黄金分割搜索，以在给定区间 $[a,b]$ 上最小化距离 $D(x)$。为了数值稳定性和效率，您可以最小化距离的平方 $S(x)=(x-x_0)^2+(f(x)-y_0)^2$ 来代替 $D(x)$，但需要证明为什么这样做会得到相同的最小化点。\n2. 假设在下述每个测试用例中，$D(x)$ 在给定区间上都是连续且单峰的。您的实现必须：\n   - 仅使用对 $S(x)$（或 $D(x)$）的函数求值。\n   - 当区间长度小于或等于容差 $\\varepsilon$ 或达到最大迭代次数时终止。\n   - 返回一个在 $[a,b]$ 内的近似最小化点 $\\hat{x}$。\n\n测试套件：\n为以下四个测试用例分别实现函数 $f(x)$ 以及参数 $(x_0,y_0)$ 和 $[a,b]$。不涉及物理单位。不使用角度。所有常数均为实数。\n\n- 用例 1（理想情况，平滑凸曲线）：\n  - $f(x)=x^2$\n  - $(x_0,y_0)=(1.0,-1.0)$\n  - $[a,b]=[-2.0,2.0]$\n  - 容差 $\\varepsilon=10^{-8}$\n\n- 用例 2（平滑非多项式，非对称）：\n  - $f(x)=e^x$\n  - $(x_0,y_0)=(0.0,0.5)$\n  - $[a,b]=[-2.0,1.0]$\n  - 容差 $\\varepsilon=10^{-8}$\n\n- 用例 3（边界最小值，区间内单调目标函数）：\n  - $f(x)=0$\n  - $(x_0,y_0)=(2.0,0.7)$\n  - $[a,b]=[-1.0,1.0]$\n  - 容差 $\\varepsilon=10^{-8}$\n\n- 用例 4（平滑、缓曲、非负的 $f$ 与负的 $y_0$）：\n  - $f(x)=\\log(1+x^2)$\n  - $(x_0,y_0)=(0.5,-0.2)$\n  - $[a,b]=[-3.0,3.0]$\n  - 容差 $\\varepsilon=10^{-8}$\n\n要求的最终输出格式：\n- 对于每个用例，计算近似的最小化点 $\\hat{x}$。\n- 将每个 $\\hat{x}$ 四舍五入到 $6$ 位小数。\n- 您的程序应生成单行输出，其中包含按上述用例顺序排列的结果，格式为逗号分隔的列表并用方括号括起，例如 $[\\hat{x}_1,\\hat{x}_2,\\hat{x}_3,\\hat{x}_4]$，其中每个条目都四舍五入到 $6$ 位小数。\n- 程序必须是自包含的，不得读取任何输入，并且只打印这一行。\n\n约束条件：\n- 不得使用导数或任何外部优化程序。\n- 在黄金分割搜索中，仅使用对 $f(x)$ 的函数求值。\n- 对每个用例，函数求值必须在闭区间 $[a,b]$ 内进行。", "solution": "我们从曲线上点 $(x,f(x))$ 与目标点 $(x_0,y_0)$ 之间的欧几里得距离开始，该距离由 $D(x)=\\sqrt{(x-x_0)^2+(f(x)-y_0)^2}$ 给出。定义距离平方为 $S(x)=(x-x_0)^2+(f(x)-y_0)^2$。由于平方根函数在 $[0,\\infty)$ 上是严格递增的，所以 $D(x)$ 和 $S(x)$ 的最小化点是相同的：如果 $x^\\ast\\in\\arg\\min_{x\\in[a,b]} S(x)$，则 $x^\\ast\\in\\arg\\min_{x\\in[a,b]} D(x)$，反之亦然。因此，为了数值上的便利，最小化 $S(x)$ 就足够了，因为这避免了平方根运算，同时保持了最小化点不变。\n\n黄金分割搜索是一种用于单峰函数的区间缩减方法。假设 $S(x)$ 在 $[a,b]$ 上是连续且单峰的。该方法在 $[a,b]$ 内选择两个内点 $c$ 和 $d$，使得 $acdb$，且子区间的长度成固定比例。设黄金比例为 $\\varphi=\\frac{1+\\sqrt{5}}{2}$，其倒数为 $\\tau=\\varphi^{-1}=\\frac{\\sqrt{5}-1}{2}$。选择内点的方式如下：\n$$\nc = b - \\tau\\,(b-a),\\quad d = a + \\tau\\,(b-a),\n$$\n这意味着 $d-a = \\tau\\,(b-a)$ 并且 $b-c = \\tau\\,(b-a)$。其关键设计原理是，在根据 $S(c)$ 和 $S(d)$ 的比较结果舍弃一个子区间后，其中一个内点会成为新区间的端点，而另一个内点则成为新区间中相同相对位置的内点。这种对函数求值的复用使每次迭代的新求值次数最小化。实现复用的不变性特性引出了比例参数的定义关系。设区间长度从 $L$ 缩减到 $\\tau L$，并要求新的内点与旧的内点之一重合。这得出 $\\tau^2 + \\tau - 1 = 0$，其正解为 $\\tau = \\frac{\\sqrt{5}-1}{2}$。\n\n在每次迭代中，计算 $S(c)$ 和 $S(d)$。如果 $S(c) \\le S(d)$，则最小化点位于 $[a,d]$ 中，因此设置 $b\\leftarrow d$，$d\\leftarrow c$，并计算一个新的 $c = b - \\tau\\,(b-a)$。否则，最小化点位于 $[c,b]$ 中，因此设置 $a\\leftarrow c$，$c\\leftarrow d$，并计算一个新的 $d = a + \\tau\\,(b-a)$。持续此过程，直到区间长度满足 $b-a \\le \\varepsilon$（对于给定的容差 $\\varepsilon$），或达到最大迭代次数。终止时，报告的最小化点 $\\hat{x}$ 的一个保守选择是集合 $\\{a,c,d,b\\}$ 中具有最小观测 $S(x)$ 值的点，这对于真实最小化点在边界上或接近边界的情况（例如，区间上的单调目标函数）是稳健的。\n\n对于测试用例：\n\n- 用例 1：$f(x)=x^2$，$(x_0,y_0)=(1.0,-1.0)$，$[a,b]=[-2.0,2.0]$。函数 $S(x)=(x-1)^2+(x^2+1)^2$ 是平滑且严格凸的，因此在 $[-2.0,2.0]$ 上是单峰的。黄金分割搜索会收敛到唯一满足一阶条件 $x-x_0 + (f(x)-y_0)f'(x)=0$ 的最小化点，即 $x-1 + (x^2+1)\\cdot 2x=0$，简化为 $2x^3+3x-1=0$。该算法能可靠地逼近这个根。\n\n- 用例 2：$f(x)=e^x$，$(x_0,y_0)=(0.0,0.5)$，$[a,b]=[-2.0,1.0]$。目标函数 $S(x)=x^2+(e^x-0.5)^2$ 在给定区间上是平滑且严格凸的，因为 $x^2$ 和 $(e^x-0.5)^2$ 都是凸函数，而凸函数之和仍是凸函数。算法会收敛到唯一的最小化点，该点平衡了水平和垂直方向的偏差。\n\n- 用例 3：$f(x)=0$，$(x_0,y_0)=(2.0,0.7)$，$[a,b]=[-1.0,1.0]$。这里 $S(x)=(x-2)^2+(0-0.7)^2=(x-2)^2+0.49$，当 $x$ 在 $[-1.0,1.0]$ 上减小时，该函数是严格递减的，因为其无约束最小化点 $x=2.0$ 在区间之外。因此，有约束最小化点位于边界 $x=1.0$。当 $\\varepsilon\\to 0$ 时，以区间长度为终止条件的黄金分割搜索将返回一个任意接近右端点的近似值。\n\n- 用例 4：$f(x)=\\log(1+x^2)$，$(x_0,y_0)=(0.5,-0.2)$，$[a,b]=[-3.0,3.0]$。目标函数 $S(x)=(x-0.5)^2+(\\log(1+x^2)+0.2)^2$ 在该区间上是平滑且严格凸的，因为 $\\log(1+x^2)$ 在任何紧凑域上都是平滑且曲率有界的，并且一个严格凸二次项与一个在最小化点附近曲率不为零的非负平滑项之和保持了单峰性。算法会收敛到一个唯一的最小化点，该点在水平位移和垂直位移之间取得了有效的权衡。\n\n需要实现的算法细节：\n- 针对每个用例定义 $S(x)=(x-x_0)^2+(f(x)-y_0)^2$。\n- 实现黄金分割搜索，使用 $\\tau=\\frac{\\sqrt{5}-1}{2}$，内点为 $c=b-\\tau(b-a)$ 和 $d=a+\\tau(b-a)$，并根据比较 $S(c)$ 和 $S(d)$ 的结果进行更新。\n- 当 $b-a\\le \\varepsilon$ 或达到最大迭代次数时终止，并返回点集 $\\{a,c,d,b\\}$ 中具有最小观测 $S(x)$ 值的点作为 $\\hat{x}$。\n- 将此过程应用于所有四个测试用例，并将每个 $\\hat{x}$ 四舍五入到 $6$ 位小数。\n\n程序应输出一行形如 $[\\hat{x}_1,\\hat{x}_2,\\hat{x}_3,\\hat{x}_4]$ 的结果，其中每个 $\\hat{x}_i$ 都按用例顺序列出并四舍五入到 $6$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef golden_section_search(fun, a, b, tol=1e-8, max_iter=1000):\n    \"\"\"\n    Minimize a unimodal function fun on [a, b] using golden-section search.\n    Only function evaluations are used. Returns an approximate minimizer x*.\n    \"\"\"\n    phi_inv = (np.sqrt(5.0) - 1.0) / 2.0  # 1/phi\n    phi_inv_sq = (3.0 - np.sqrt(5.0)) / 2.0  # 1/phi^2\n    # Initialize interior points\n    c = a + phi_inv_sq * (b - a)\n    d = a + phi_inv * (b - a)\n    fc = fun(c)\n    fd = fun(d)\n\n    it = 0\n    while (b - a)  tol and it  max_iter:\n        it += 1\n        if fc = fd:\n            # Minimum is in [a, d]\n            b, d, fd = d, c, fc\n            c = a + phi_inv_sq * (b - a)\n            fc = fun(c)\n        else:\n            # Minimum is in [c, b]\n            a, c, fc = c, d, fd\n            d = a + phi_inv * (b - a)\n            fd = fun(d)\n\n    # Pick the best among available sampled points to be robust to boundary minima\n    candidates = [(a, fun(a)), (b, fun(b)), (c, fc), (d, fd)]\n    x_best, _ = min(candidates, key=lambda t: t[1])\n    return x_best\n\n# Define the functions f(x) for the test suite\ndef f_quad(x):\n    return x * x\n\ndef f_exp(x):\n    return np.exp(x)\n\ndef f_const0(x):\n    return 0.0\n\ndef f_log1px2(x):\n    # Use numerically stable log1p\n    return np.log1p(x * x)\n\ndef make_squared_distance(f, x0, y0):\n    def S(x):\n        y = f(x)\n        dx = x - x0\n        dy = y - y0\n        return dx * dx + dy * dy\n    return S\n\ndef solve():\n    # Define the test cases as (function, x0, y0, a, b, tol)\n    test_cases = [\n        (f_quad, 1.0, -1.0, -2.0,  2.0, 1e-8),      # Case 1\n        (f_exp,  0.0,  0.5, -2.0,  1.0, 1e-8),      # Case 2\n        (f_const0, 2.0, 0.7, -1.0, 1.0, 1e-8),      # Case 3\n        (f_log1px2, 0.5, -0.2, -3.0, 3.0, 1e-8),    # Case 4\n    ]\n\n    results = []\n    for f, x0, y0, a, b, tol in test_cases:\n        S = make_squared_distance(f, x0, y0)\n        x_star = golden_section_search(S, a, b, tol=tol, max_iter=10000)\n        results.append(f\"{x_star:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2398578"}, {"introduction": "真正掌握一个算法意味着能够将其核心思想推广到新的领域。传统的黄金分割搜索作用于线性区间，但如果我们的定义域是环形的，比如一个从 $0$ 到 $2\\pi$ 的角度，情况会怎样？这个高级练习挑战你修改和调整黄金分割搜索算法，以适应周期性边界条件，这要求你对算法的“区间包围”逻辑有更深层次的抽象理解。[@problem_id:2421115]", "problem": "给定一个连续的、$2\\pi$周期函数 $f:\\mathbb{R}\\to\\mathbb{R}$，它在单位圆上是严格单峰的：存在一个唯一的极小值点 $\\theta^{\\star}\\in[0,2\\pi)$（模 $2\\pi$），并且在任何包含 $\\theta^{\\star}$、角长度小于 $\\pi$ 的测地线弧（最短弧）上，函数 $f$ 在达到 $\\theta^{\\star}$ 之前严格递减，之后严格递增。角度在模 $2\\pi$ 的意义下是等同的。定义从 $L$到 $R$ 的逆时针方向弧，其角跨度为 $\\Delta = (R-L)\\bmod 2\\pi \\in (0,2\\pi)$。测地线弧是连接 $L$ 和 $R$ 的两条弧中较短的一条，因此一个托架弧必须满足 $\\Delta\\in(0,\\pi)$。\n\n你被要求修改黄金分割搜索算法，以在圆上最小化函数 $f$。一个正确的修改必须指明如何在圆上初始化一个托架，如何在每次迭代中选择内部求值点，如何在保持正确性的前提下更新托架，如何处理环绕问题，以及如何终止。\n\n以下哪个选项正确且充分地将黄金分割搜索应用于此圆形设定？\n\nA. 维持一个角跨度为 $\\Delta\\in(0,\\pi)$ 的测地托架弧 $(L,R)$，该弧包含 $\\theta^{\\star}$ 且 $f$ 在该弧上是单峰的。在每次迭代中，沿逆时针方向选择两个内部点 $c \\equiv L + (1-\\varphi)\\Delta \\pmod{2\\pi}$ 和 $d \\equiv L + \\varphi \\Delta \\pmod{2\\pi}$，其中 $\\varphi=(\\sqrt{5}-1)/2$。计算 $f(c)$ 和 $f(d)$。如果 $f(c)  f(d)$，则设置 $R := d$；否则设置 $L := c$。总是以模 $2\\pi$ 来解释差值和更新，并保持所维持的弧为跨度严格小于 $\\pi$ 的测地线弧。当 $\\Delta \\le \\varepsilon$（其中 $\\varepsilon0$ 是预设的容差）时终止，并返回当前弧的任意代表点（例如，沿弧的中点）作为 $\\theta^{\\star}$ 的估计值。\n\nB. 将圆视为固定区间 $[0,2\\pi]$，并在此区间上应用经典的黄金分割搜索，设置 $a=0, b=2\\pi$，计算 $c=b-\\varphi(b-a)$ 和 $d=a+\\varphi(b-a)$，忽略环绕问题，并且对区间长度相对于 $\\pi$ 没有任何限制。当 $b-a\\le\\varepsilon$ 时终止。\n\nC. 使用逆时针间隔满足 $\\Delta\\in(\\pi,2\\pi)$ 的任意两点 $L$ 和 $R$ 进行初始化，以避免错过极小值点。在每次迭代中，使用与直线上相同的黄金比例选择两个内部点，但总是沿较长的弧进行测量。通过保留较长的子弧来更新，因为它在圆上更可能包含极小值点。当弧长短于预设的容差时终止。\n\nD. 通过半角正切代换 $x=\\tan(\\theta/2)$ 将圆提升到实数线，使得 $\\theta=2\\arctan(x)$ 将 $(-\\infty,\\infty)$ 映射到 $[0,2\\pi)$。使用经典的黄金分割搜索在 $(-\\infty,\\infty)$ 上最小化 $g(x)=f(2\\arctan(x))$，然后通过 $\\theta=2\\arctan(x_{\\min})$ 将极小值点映射回圆上。在圆上不需要对环绕问题或弧长进行特殊处理。\n\nE. 维持一个跨度为 $\\Delta\\in(0,\\pi)$ 的测地托架弧 $(L,R)$，并在每次迭代中，在两个等距的内部点 $c\\equiv L+\\Delta/3$ 和 $d\\equiv L+2\\Delta/3$（均模 $2\\pi$）处计算 $f$ 的值。通过保留具有较小内部函数值的子弧来更新，并在 $\\Delta\\le\\varepsilon$ 时终止。\n\n选择正确的选项。", "solution": "我们从第一性原理开始。直线上的黄金分割搜索假设函数在某个区间上是连续单峰的，并维持一个托架区间 $[a,b]$，函数在该区间上是单峰的。它选择两个内部点 $c=b-\\varphi(b-a)$ 和 $d=a+\\varphi(b-a)$，其中 $\\varphi=(\\sqrt{5}-1)/2$，计算 $f(c)$ 和 $f(d)$，然后丢弃不可能包含极小值点的半个区间，从而在剩余区间上保持单峰性。这依赖于沿着单一线性坐标测量距离，以及存在一个具有唯一极小值且两侧行为严格单调的区间。\n\n在圆上，角度在模 $2\\pi$ 意义下是等同的，并且没有全局线性顺序。为了改编黄金分割搜索，我们必须定义一个区间的概念：两个角度之间的测地线弧（最短弧）。对于两个角度 $L$ 和 $R$，它们的逆时针角差为 $\\Delta = (R-L)\\bmod 2\\pi \\in (0,2\\pi)$。测地线弧是连接 $L$ 和 $R$ 的两条弧中较短的一条，这对应于要求 $\\Delta\\in(0,\\pi)$。在所述的单峰性假设下，任何包含 $\\theta^{\\star}$ 且跨度小于 $\\pi$ 的测地线弧都将表现出与线性情况下相同的单峰结构：在达到 $\\theta^{\\star}$ 之前严格递减，然后严格递增。因此，正确的改编方法是维持这样一个测地托架弧，按弧长的固定比例（如线性情况下的黄金比例）选择内部点，在这些角度（模 $2\\pi$）上计算 $f$ 的值，并使用与直线上相同的逻辑更新弧，始终保持测地线属性并通过模运算处理环绕问题。终止条件是基于弧长 $\\Delta$ 小于某个容差 $\\varepsilon0$。\n\n现在我们来评估每个选项。\n\n选项 A：此选项指定维持一个跨度为 $\\Delta\\in(0,\\pi)$ 的测地托架弧 $(L,R)$，函数 $f$ 在其上是单峰的。它沿着逆时针方向在黄金分割位置选择内部点 $c$ 和 $d$：$c \\equiv L + (1-\\varphi)\\Delta \\pmod{2\\pi}$ 和 $d \\equiv L + \\varphi \\Delta \\pmod{2\\pi}$，其中 $\\varphi=(\\sqrt{5}-1)/2$。然后比较 $f(c)$ 和 $f(d)$；如果 $f(c)  f(d)$，极小值点必定位于从 $L$ 到 $d$ 的测地子弧上，因此将 $R$ 设置为 $d$；否则极小值点位于从 $c$ 到 $R$ 的子弧上，因此将 $L$ 设置为 $c$。这些更新反映了线性情况，并保持新弧是跨度小于 $\\pi$ 的测地线弧，因为每个子弧的跨度为 $\\varphi\\Delta$ 或 $(1-\\varphi)\\Delta$，两者都严格小于 $\\Delta\\pi$。使用模 $2\\pi$ 一致地处理了环绕问题。当 $\\Delta \\le \\varepsilon$ 时终止，提供了角距离上的标准精度保证。这是对黄金分割搜索在圆上正确且充分的改编。\n\n结论：正确。\n\n选项 B：此选项将定义域视为固定区间 $[0,2\\pi]$，并应用线性算法，未考虑圆形的等同性。在 $[0,2\\pi]$ 上，一个在圆上单峰的函数在 $0$ 和 $2\\pi$ 处的人为切口上不一定是单峰的。如果 $\\theta^{\\star}$ 靠近 $0$，那么靠近 $0$ 和靠近 $2\\pi$ 的邻域都包含接近极小值的函数值，函数在区间上可能表现出有两个“下降”的边，违反了算法所需的单峰结构。从 $a=0, b=2\\pi$ 开始并不能建立保证正确性所需的托架区间，该方法可能收敛到边界或表现出非单调的进展。没有确保存在一个包含极小值点且跨度小于 $\\pi$ 的测地线弧，基本的单峰性假设就无法得到保证，因此正确性也无法保证。\n\n结论：不正确。\n\n选项 C：此选项故意使用跨度为 $\\Delta\\in(\\pi,2\\pi)$ 的较长弧，并继续保留较长的子弧。在圆上，较长的弧必然包含极小值点周围的两侧，并且根据其构造，不满足测地线要求；在这样的弧上，不能保证函数是单峰的。黄金分割的逻辑依赖于在单峰性下丢弃不可能包含极小值点的一半；保留较长的子弧会破坏托架属性，并可能保留不满足单峰性的区域，从而破坏了收敛保证。\n\n结论：不正确。\n\n选项 D：半角正切代换 $x=\\tan(\\theta/2)$ 在 $\\theta=\\pi$ 处引入了奇点（即 $x$ 发散），并将圆非均匀地映射到实数线上。即使 $f$ 在圆上的测地线弧上是单峰的，复合函数 $g(x)=f(2\\arctan(x))$ 在 $(-\\infty,\\infty)$ 上虽然连续但通常不是单峰的，因为该映射扭曲了距离并在奇点处分割了邻域。如果在某个区间上不能保证 $g$ 的单峰性，黄金分割搜索的假设就被违反了，因此无法保证正确性。\n\n结论：不正确。\n\n选项 E：此选项维持一个测地托架，并使用两个等距的内部点，即一种类似三分搜索的方案。虽然这种方法在单峰性下可以收敛，但它不是黄金分割搜索，并且没有重用内部点来最小化函数求值次数。题目要求修改黄金分割搜索算法，该算法特别利用黄金比例位置来在迭代之间保留一个内部点。此选项没有实现黄金分割机制，因此没有回答所提出的问题。\n\n结论：不正确。\n\n因此，在所有选项中，唯一正确的改编是选项A中所描述的。", "answer": "$$\\boxed{A}$$", "id": "2421115"}]}