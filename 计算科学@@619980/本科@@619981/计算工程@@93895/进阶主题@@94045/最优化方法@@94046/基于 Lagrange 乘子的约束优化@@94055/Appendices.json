{"hands_on_practices": [{"introduction": "在工程和经济学中，我们经常需要在满足一系列约束（如预算、资源或法规限制）的情况下，最大化收益或最小化成本。这个问题 [@problem_id:2380580] 提供了一个典型的场景：一家工厂需要在满足最低产量和遵守排放上限的双重约束下，最小化其生产成本。通过解决这个问题，你将亲手实践如何处理带有不等式约束的优化问题，并应用卡罗需-库恩-塔克（KKT）条件来寻找最优解。", "problem": "一家工厂运营着两条平行的生产线，其决策变量为 $x$ 和 $y$，分别代表生产线 $1$ 和生产线 $2$ 的产量（单位：件）。总生产成本由以下二次函数建模：\n$$\nC(x,y) \\;=\\; x^{2} \\;+\\; y^{2} \\;+\\; \\frac{1}{2}\\,x\\,y.\n$$\n总产量为 $P(x,y)=x+y$（单位：件），总排放量为 $E(x,y)=x+2y$（单位：排放单位）。工厂必须满足生产要求 $P(x,y)\\ge N$（其中 $N=10$）和排放上限 $E(x,y)\\le E_{\\max}$（其中 $E_{\\max}=14$）。产量为非负值：$x\\ge 0$ 且 $y\\ge 0$。\n\n确定在这些约束条件下可实现的最低总成本 $C_{\\min}$。以成本单位（Cost Units (CU)）表示您的最终答案。请提供精确值（无需四舍五入）。", "solution": "所给出的问题是一个约束优化问题，这是计算工程学和运筹学中的一个标准任务。该问题提法明确且有科学依据。我现在将对其进行形式化求解。\n\n目标是在一组线性不等式约束下，最小化成本函数 $C(x,y) = x^2 + y^2 + \\frac{1}{2}xy$。\n约束条件如下：\n$1.$ 生产要求：$x+y \\ge 10$\n$2.$ 排放上限：$x+2y \\le 14$\n$3.$ 生产线 $1$ 的产量非负：$x \\ge 0$\n$4.$ 生产线 $2$ 的产量非负：$y \\ge 0$\n\n首先，我们来刻画由这些不等式定义的可行域。该区域是 $xy$-平面上的一个凸多边形。该多边形的顶点可通过边界线的交点求得。\n边界线为 $x+y=10$、$x+2y=14$、$x=0$ 和 $y=0$。\n- $y=0$ 和 $x+y=10$ 的交点：得到点 $(10, 0)$。我们验证其可行性：$10+2(0)=10 \\le 14$。该点是可行的。我们称之为 $V_1 = (10, 0)$。\n- $y=0$ 和 $x+2y=14$ 的交点：得到点 $(14, 0)$。我们验证其可行性：$14+0=14 \\ge 10$。该点是可行的。我们称之为 $V_2 = (14, 0)$。\n- $x+y=10$ 和 $x+2y=14$ 的交点：用第二个方程减去第一个方程得到 $(x+2y)-(x+y) = 14-10$，化简为 $y=4$。将 $y=4$ 代入第一个方程得到 $x+4=10$，所以 $x=6$。得到点 $(6, 4)$。我们验证其可行性：$x=6 \\ge 0$ 且 $y=4 \\ge 0$。该点是可行的。我们称之为 $V_3 = (6, 4)$。\n\n可行域是一个以 $V_1(10,0)$、$V_2(14,0)$ 和 $V_3(6,4)$ 为顶点的三角形。\n\n目标函数为 $C(x,y) = x^2 + y^2 + \\frac{1}{2}xy$。为了判断该函数是否为凸函数，我们考察其海森矩阵 $H$：\n$$ H(x,y) = \\begin{pmatrix} \\frac{\\partial^2 C}{\\partial x^2} & \\frac{\\partial^2 C}{\\partial x \\partial y} \\\\ \\frac{\\partial^2 C}{\\partial y \\partial x} & \\frac{\\partial^2 C}{\\partial y^2} \\end{pmatrix} = \\begin{pmatrix} 2 & \\frac{1}{2} \\\\ \\frac{1}{2} & 2 \\end{pmatrix} $$\n一阶主子式为 $2 > 0$。二阶主子式是行列式 $\\det(H) = (2)(2) - (\\frac{1}{2})(\\frac{1}{2}) = 4 - \\frac{1}{4} = \\frac{15}{4} > 0$。由于海森矩阵对所有 $(x,y)$ 都是正定的，因此函数 $C(x,y)$ 是严格凸函数。\n\n一个严格凸函数在一个紧凸集（即我们的三角形可行域）上的最小值是唯一的，并且在满足 Karush-Kuhn-Tucker (KKT) 条件的点上取得。这个点可能在区域的内部或其边界上。\n\n让我们将约束重写为标准形式 $g_i(x,y) \\le 0$：\n$g_1(x,y) = 10 - x - y \\le 0$\n$g_2(x,y) = x + 2y - 14 \\le 0$\n$g_3(x,y) = -x \\le 0$\n$g_4(x,y) = -y \\le 0$\n\n拉格朗日函数为：\n$$ \\mathcal{L}(x, y, \\lambda_1, \\lambda_2, \\mu_1, \\mu_2) = x^2 + y^2 + \\frac{1}{2}xy + \\lambda_1(10-x-y) + \\lambda_2(x+2y-14) - \\mu_1 x - \\mu_2 y $$\n其中 $\\lambda_1, \\lambda_2, \\mu_1, \\mu_2$ 是非负的拉格朗日乘子。\n\nKKT平稳性条件为：\n$$ \\frac{\\partial \\mathcal{L}}{\\partial x} = 2x + \\frac{1}{2}y - \\lambda_1 + \\lambda_2 - \\mu_1 = 0 $$\n$$ \\frac{\\partial \\mathcal{L}}{\\partial y} = 2y + \\frac{1}{2}x - \\lambda_1 + 2\\lambda_2 - \\mu_2 = 0 $$\n\n情况1：最小值在可行域的内部。\n在这种情况下，所有不等式约束都是非激活的，因此 $\\lambda_1 = \\lambda_2 = \\mu_1 = \\mu_2 = 0$。平稳性条件变为：\n$2x + \\frac{1}{2}y = 0$\n$2y + \\frac{1}{2}x = 0$\n唯一的实数解是 $(x,y)=(0,0)$。然而，这个点不在可行域内，因为它违反了约束 $x+y \\ge 10$。因此，最小值必定位于可行域的边界上。\n\n由于这是一个凸优化问题，且无约束最优点在可行域之外，最优点必然位于可行域的边界上。我们通过计算可行域各顶点的成本函数值来寻找候选解。\n- 在点 $V_1(10,0)$ 处：\n$C(10,0) = 10^2 + 0^2 + \\frac{1}{2}(10)(0) = 100$。\n\n- 在点 $V_2(14,0)$ 处：\n$C(14,0) = 14^2 + 0^2 + \\frac{1}{2}(14)(0) = 196$。\n\n- 在点 $V_3(6,4)$ 处：\n$C(6,4) = 6^2 + 4^2 + \\frac{1}{2}(6)(4) = 36 + 16 + 12 = 64$。\n\n比较这些值，最小成本为 $64$，在点 $(x,y)=(6,4)$ 处取得。\n\n为严谨起见，我们验证点 $(6,4)$ 满足 KKT 条件。\n在点 $(x,y)=(6,4)$ 处，约束 $x+y \\ge 10$ 和 $x+2y \\le 14$ 是激活的，即 $g_1(6,4)=0$ 和 $g_2(6,4)=0$。非负性约束是非激活的，因此它们对应的乘子为零：$\\mu_1 = 0$ 且 $\\mu_2 = 0$。\n平稳性条件变为：\n$2(6) + \\frac{1}{2}(4) - \\lambda_1 + \\lambda_2 = 0 \\implies 14 - \\lambda_1 + \\lambda_2 = 0 \\implies \\lambda_1 - \\lambda_2 = 14$。\n$2(4) + \\frac{1}{2}(6) - \\lambda_1 + 2\\lambda_2 = 0 \\implies 11 - \\lambda_1 + 2\\lambda_2 = 0 \\implies \\lambda_1 - 2\\lambda_2 = 11$。\n\n我们求解这个关于 $\\lambda_1$ 和 $\\lambda_2$ 的方程组。用第一个方程减去第二个方程得出：\n$(\\lambda_1 - \\lambda_2) - (\\lambda_1 - 2\\lambda_2) = 14 - 11 \\implies \\lambda_2 = 3$。\n将 $\\lambda_2=3$ 代入第一个方程：$\\lambda_1 - 3 = 14 \\implies \\lambda_1 = 17$。\n\n我们找到了乘子 $\\lambda_1=17$，$\\lambda_2=3$，$\\mu_1=0$，$\\mu_2=0$。\n所有乘子都是非负的，满足对偶可行性条件。原始可行性和互补松弛条件根据构造也得到满足。\n由于 $(x,y)=(6,4)$ 满足凸优化问题的 KKT 条件，因此它是全局最小值点。\n\n可实现的最低总成本是 $C_{\\min} = C(6,4) = 64$。", "answer": "$$\n\\boxed{64}\n$$", "id": "2380580"}, {"introduction": "将一个实际的工程挑战转化为一个可以求解的数学模型，是计算工程师的核心技能之一。这个问题 [@problem_id:2380493] 模拟了一个常见的现代场景：如何放置一个 Wi-Fi 中继器以最大化用户的信号质量，同时受到电源线长度的限制。这个练习的价值在于，它不仅要求你找到最优解，更重要的是引导你思考如何将“最弱链路”的信号质量问题重新表述为一个等效的、更易于处理的凸优化问题。", "problem": "一个无线接入点位于固定位置，坐标为 $\\,(A_x,A_y)\\,$（单位：米），一个用户设备位于固定位置，坐标为 $\\,(U_x,U_y)\\,$（单位：米）。一个 Wi-Fi 中继器必须通过最大长度为 $\\;L\\;$ 米的电源线从坐标为 $\\,(O_x,O_y)\\,$（单位：米）的墙壁插座供电。该中继器可以放置在平面内任何满足可行性条件 $\\;\\|(x,y)-(O_x,O_y)\\|\\leq L\\,$ 的位置 $\\,(x,y)\\,$，其中 $\\;\\|\\cdot\\|\\;$ 表示欧几里得范数。任意位置为 $\\,(p_x,p_y)\\,$ 的发射机与任意位置为 $\\,(q_x,q_y)\\,$ 的接收机之间的大尺度路径损耗模型为：接收功率与 $\\;\\| (p_x,p_y)-(q_x,q_y)\\|^{-\\alpha}\\;$ 成正比，其中 $\\;\\alpha&gt;0\\;$ 是路径损耗指数。假设两跳链路（从接入点到中继器，以及从中继器到用户）的端到端信号质量受限于两跳中较弱的一跳，因此需要最大化的性能指标为\n$$\nt \\;=\\; \\min\\Big\\{\\;\\|(x,y)-(A_x,A_y)\\|^{-\\alpha},\\;\\|(x,y)-(U_x,U_y)\\|^{-\\alpha}\\;\\Big\\}。\n$$\n你必须确定中继器的放置位置 $\\,(x^\\star,y^\\star)\\,$（单位：米），以在满足电缆长度约束 $\\;\\|(x,y)-(O_x,O_y)\\|\\leq L\\,$ 的条件下最大化 $\\;t\\;$。如果存在多个最优放置位置，你必须返回 $x$ 坐标最小的那个；如果仍然存在多个，则选择 $y$ 坐标最小的那个。所有坐标均以米为单位表示，并四舍五入到六位小数。\n\n为了进行数值评估，请使用以下参数值测试套件，每个测试用例以元组 $\\;\\big((A_x,A_y),(U_x,U_y),(O_x,O_y),L,\\alpha\\big)\\;$ 的形式指定：\n\n- 测试 $\\;1$：$\\;\\big((0,0),(10,0),(5,3),3,2\\big)$。\n- 测试 $\\;2$：$\\;\\big((0,0),(10,0),(20,0),3,2\\big)$。\n- 测试 $\\;3$：$\\;\\big((0,0),(10,0),(5,0),5,3.5\\big)$。\n- 测试 $\\;4$：$\\;\\big((-2,1),(4,7),(4,1),2,2.7\\big)$。\n\n你的程序必须为每个测试计算 $\\,(x^\\star,y^\\star)\\,$，并生成单行输出，其中包含四个结果，形式为用方括号括起来的逗号分隔列表，每个结果是一个双元素列表 $\\,[x^\\star,y^\\star]\\,$。例如，要求的输出格式为\n$$\n\\texttt{[[x\\_1,y\\_1],[x\\_2,y\\_2],[x\\_3,y\\_3],[x\\_4,y\\_4]]}\n$$\n其中每个 $\\,x_i\\,$ 和 $\\,y_i\\,$ 均以米为单位，并四舍五入到六位小数。不得打印任何额外文本。", "solution": "我们将该任务形式化为关于中继器位置 $\\,(x,y)\\,$ 的约束优化问题。长度为 $\\;r\\;$ 的一跳的接收功率与 $\\;r^{-\\alpha}\\;$ 成比例，其中 $\\;\\alpha&gt;0\\;$。端到端指标为\n$$\nt(x,y)\\;=\\;\\min\\Big\\{\\;\\|(x,y)-(A_x,A_y)\\|^{-\\alpha},\\;\\|(x,y)-(U_x,U_y)\\|^{-\\alpha}\\;\\Big\\}。\n$$\n因为当 $\\;\\alpha&gt;0\\;$ 时，函数 $\\;r\\mapsto r^{-\\alpha}\\;$ 是严格递减的，所以最大化 $\\;t(x,y)\\;$ 等价于最小化\n$$\ns(x,y)\\;=\\;\\max\\Big\\{\\;\\|(x,y)-(A_x,A_y)\\|,\\;\\|(x,y)-(U_x,U_y)\\|\\;\\Big\\}。\n$$\n因此，一个等价的凸优化公式引入了一个辅助标量 $\\;s\\ge 0\\;$，表述如下\n$$\n\\begin{aligned}\n\\min_{x,y,s}\\quad &amp; s \\\\\n\\text{subject to}\\quad &amp; \\|(x,y)-(A_x,A_y)\\|\\;\\le\\;s,\\\\\n&amp; \\|(x,y)-(U_x,U_y)\\|\\;\\le\\;s,\\\\\n&amp; \\|(x,y)-(O_x,O_y)\\|\\;\\le\\;L.\n\\end{aligned}\n$$\n每个约束 $\\;\\|(x,y)-(P_x,P_y)\\|\\le s\\;$ 都是凸的，因为它是一个二阶（欧几里得范数）锥约束，且目标函数 $\\;s\\;$ 是线性的。可行集 $\\;\\{(x,y):\\|(x,y)-(O_x,O_y)\\|\\le L\\}\\;$ 是一个闭圆盘，也是凸的。因此，该问题是一个凸二阶锥规划问题，任何局部最优解都是全局最优解。\n\n为了从第一性原理出发求解，我们分析 Karush-Kuhn-Tucker (KKT) 最优性条件，对于具有合适约束规范的凸规划问题，该条件是充要的。令\n$$\ng_A(x,y,s)=\\|(x,y)-(A_x,A_y)\\|-s,\\quad\ng_U(x,y,s)=\\|(x,y)-(U_x,U_y)\\|-s,\n$$\n$$\ng_O(x,y)=\\|(x,y)-(O_x,O_y)\\|-L.\n$$\n为这些不等式约束引入拉格朗日乘子 $\\;\\lambda_A\\ge 0,\\;\\lambda_U\\ge 0,\\;\\lambda_O\\ge 0\\;$。拉格朗日函数为\n$$\n\\mathcal{L}(x,y,s,\\lambda_A,\\lambda_U,\\lambda_O)\n\\;=\\; s\\;+\\;\\lambda_A\\big(\\|(x,y)-(A_x,A_y)\\|-s\\big)\\;+\\;\\lambda_U\\big(\\|(x,y)-(U_x,U_y)\\|-s\\big)\\;+\\;\\lambda_O\\big(\\|(x,y)-(O_x,O_y)\\|-L\\big).\n$$\n关于 $\\;s\\;$ 和 $\\;(x,y)\\;$ 的平稳性条件给出\n$$\n\\frac{\\partial\\mathcal{L}}{\\partial s}=1-\\lambda_A-\\lambda_U=0\\quad\\Longrightarrow\\quad \\lambda_A+\\lambda_U=1,\n$$\n以及\n$$\n\\frac{\\partial\\mathcal{L}}{\\partial(x,y)}=\n\\lambda_A\\,\\frac{(x,y)-(A_x,A_y)}{\\|(x,y)-(A_x,A_y)\\|}\n+\\lambda_U\\,\\frac{(x,y)-(U_x,U_y)}{\\|(x,y)-(U_x,U_y)\\|}\n+\\lambda_O\\,\\frac{(x,y)-(O_x,O_y)}{\\|(x,y)-(O_x,O_y)\\|}=\\mathbf{0},\n$$\n只要相应分母不为零。互补松弛性和原始可行性要求\n$$\n\\lambda_A\\,g_A(x,y,s)=0,\\quad \\lambda_U\\,g_U(x,y,s)=0,\\quad \\lambda_O\\,g_O(x,y)=0,\n$$\n$$\ng_A(x,y,s)\\le 0,\\quad g_U(x,y,s)\\le 0,\\quad g_O(x,y)\\le 0,\\quad \\lambda_A,\\lambda_U,\\lambda_O\\ge 0.\n$$\n\n定性结构。在最优点，通常有 $\\;g_A=0\\;$ 和 $\\;g_U=0\\;$（两段链路的距离等于最小化的半径 $\\;s\\;$），除非插座位置和电缆约束迫使中继器离一个端点过近，以至于另一个约束单独决定了 $\\;s\\;$。如果插座约束非激活（$\\;\\lambda_O=0\\;$），平稳性条件简化为\n$$\n\\lambda_A\\,\\mathbf{u}_A+\\lambda_U\\,\\mathbf{u}_U=\\mathbf{0},\\quad \\lambda_A+\\lambda_U=1,\n$$\n其中 $\\;\\mathbf{u}_A=\\frac{(x,y)-(A_x,A_y)}{\\|(x,y)-(A_x,A_y)\\|}\\;$ 且 $\\;\\mathbf{u}_U=\\frac{(x,y)-(U_x,U_y)}{\\|(x,y)-(U_x,U_y)\\|}\\;$。这意味着 $\\;\\mathbf{u}_A=-\\mathbf{u}_U\\;$ 且 $\\;\\lambda_A=\\lambda_U=\\tfrac12\\;$，将 $\\;(x,y)\\;$ 置于 $\\;(A_x,A_y)\\;$ 和 $\\;(U_x,U_y)\\;$ 的垂直平分线上，并且通过最小化 $\\;s\\;$，在可行的情况下将其置于它们的中点。如果插座约束激活（$\\;\\lambda_O&gt;0\\;$），则中继器位于圆 $\\;\\|(x,y)-(O_x,O_y)\\|=L\\;$ 上，平稳性条件通过 $\\;\\lambda_A,\\lambda_U,\\lambda_O\\;$ 重新加权，平衡了朝向三个中心的单位向量。会出现以下特殊情况：\n\n- 若 $\\;g_A=0,\\;g_U&lt;0\\;$，则 $\\;\\lambda_U=0,\\;\\lambda_A=1\\;$ 且 $\\;\\lambda_O\\ge 0\\;$，得到 $\\;\\mathbf{u}_A+\\lambda_O\\,\\mathbf{u}_O=\\mathbf{0}\\;$，即插座约束圆上离 $\\;(A_x,A_y)\\;$ 最近的点。\n- 若 $\\;g_U=0,\\;g_A&lt;0\\;$，类似地，解为插座约束圆上离 $\\;(U_x,U_y)\\;$ 最近的点。\n- 若 $\\;g_A=0$ 且 $\\;g_U=0\\;$ 且 $\\;\\lambda_O&gt;0\\;$，解位于插座约束圆与两个端点垂直平分线的交点上，且在最小化公共距离的那一侧。\n\n由于问题的凸性，这些 KKT 特征是充分的。在数值上，可以直接用变量 $\\;(x,y,s)\\;$ 求解该凸规划问题。\n\n对测试套件进行解析评估：\n\n- 测试 $\\;1$：$\\;(A_x,A_y)=(0,0),\\;(U_x,U_y)=(10,0),\\;(O_x,O_y)=(5,3),\\;L=3\\;$。垂直平分线是 $\\;x=5\\;$。与圆 $\\;(x-5)^2+(y-3)^2=3^2\\;$ 相交得到 $\\;(x,y)=(5,0)\\;$ 和 $\\;(x,y)=(5,6)\\;$。在 $\\;(5,0)\\;$ 处到两个端点的公共距离是 $\\;5\\;$，而在 $\\;(5,6)\\;$ 处是 $\\;\\sqrt{25+36}\\;$。最小化选择 $\\;(x^\\star,y^\\star)=(5,0)\\;$。四舍五入到六位小数：$\\;[5.000000,0.000000]\\;$。\n\n- 测试 $\\;2$：$\\;(A_x,A_y)=(0,0),\\;(U_x,U_y)=(10,0),\\;(O_x,O_y)=(20,0),\\;L=3\\;$。无约束解（A和U的中点(5,0)）在可行域之外，因此解必在约束圆盘 $(x-20)^2+y^2 \\le 9$ 的边界上。该圆盘上的所有点都满足 $x \\ge 17$，因此它们都位于A和U的垂直平分线 ($x=5$) 的右侧。这意味着对于任何可行点R，其到A的距离 $\\|R-A\\|$ 总是大于到U的距离 $\\|R-U\\|$。因此，最小化 $\\max(\\|R-A\\|, \\|R-U\\|)$ 等价于最小化 $\\|R-A\\|$。在可行圆盘上离A最近的点是 $(17,0)$。因此 $(x^\\star,y^\\star)=(17,0)$，即 $[17.000000,0.000000]$。\n\n- 测试 $\\;3$：$\\;(A_x,A_y)=(0,0),\\;(U_x,U_y)=(10,0),\\;(O_x,O_y)=(5,0),\\;L=5\\;$。垂直平分线为 $\\;x=5\\;$。与圆 $\\;(x-5)^2+y^2=25\\;$ 的交点为 $\\;(5,5)\\;$ 和 $\\;(5,-5)\\;$，两者到端点的距离相等，目标函数值也相等。平局打破规则选择较小的 $\\;x\\;$（两者相等），然后选择较小的 $\\;y\\;$，即 $\\;-5\\;$。因此 $\\;[5.000000,-5.000000]\\;$。\n\n- 测试 $\\;4$：$\\;(A_x,A_y)=(-2,1),\\;(U_x,U_y)=(4,7),\\;(O_x,O_y)=(4,1),\\;L=2\\;$。接入点和用户之间线段的垂直平分线是直线 $\\;x+y=5\\;$，该直线穿过插座。从插座沿该平分线向线段中点移动会减小公共距离，直到到达圆的边界。从插座到中点的单位方向与 $\\;(-1,1)\\;$ 成比例，因此最优点是\n$$\n(x^\\star,y^\\star) \\;=\\; (4,1)\\;+\\;2\\;\\frac{(-1,1)}{\\sqrt{2}} \\;=\\; \\big(4-\\sqrt{2},\\;1+\\sqrt{2}\\big),\n$$\n四舍五入后为 $\\;[2.585786,2.414214]\\;$。\n\n这些放置位置与路径损耗指数 $\\;\\alpha\\;$ 无关，因为对于任何固定的 $\\;\\alpha&gt;0\\;$，最大化 $\\;\\min\\{\\|R-A\\|^{-\\alpha},\\|R-U\\|^{-\\alpha}\\}\\;$ 等价于最小化 $\\;\\max\\{\\|R-A\\|,\\|R-U\\|\\;\\}$。\n\n附带的程序为每个测试用例求解所述的凸问题，并应用平局打破规则，返回按要求格式四舍五入到六位小数的坐标。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve_case(A, U, O, L, alpha):\n    # A, U, O are (x, y) tuples; L, alpha are floats\n    Ax, Ay = A\n    Ux, Uy = U\n    Ox, Oy = O\n\n    # Objective: minimize s subject to ||R - A|| <= s, ||R - U|| <= s, ||R - O|| <= L, s >= 0\n    def objective(z):\n        # z = [x, y, s]\n        return z[2]\n\n    def cons_A(z):\n        x, y, s = z\n        return s - np.hypot(x - Ax, y - Ay)  # >= 0 for feasibility form in SLSQP\n\n    def cons_U(z):\n        x, y, s = z\n        return s - np.hypot(x - Ux, y - Uy)\n\n    def cons_O(z):\n        x, y, s = z\n        return L - np.hypot(x - Ox, y - Oy)\n\n    constraints_template = [\n        {'type': 'ineq', 'fun': cons_A},\n        {'type': 'ineq', 'fun': cons_U},\n        {'type': 'ineq', 'fun': cons_O},\n    ]\n\n    # Generate multiple initial guesses to handle symmetry and nonconvex numerics (though problem is convex)\n    initials = []\n\n    # Midpoint projection to circle (if needed)\n    Mx, My = (0.5 * (Ax + Ux), 0.5 * (Ay + Uy))\n    vecMO = np.array([Mx - Ox, My - Oy])\n    normMO = np.hypot(vecMO[0], vecMO[1])\n    if normMO > 1e-12:\n        R0 = np.array([Ox, Oy]) + min(L, normMO) * vecMO / normMO\n    else:\n        # Midpoint equals outlet; pick a point on circle along +x\n        R0 = np.array([Ox + L, Oy])\n    s0 = max(np.hypot(R0[0] - Ax, R0[1] - Ay), np.hypot(R0[0] - Ux, R0[1] - Uy))\n    initials.append(np.array([R0[0], R0[1], s0]))\n\n    # Add several points on the outlet circle\n    if L > 0:\n        for theta in np.linspace(0.0, 2.0 * np.pi, 12, endpoint=False):\n            x = Ox + L * np.cos(theta)\n            y = Oy + L * np.sin(theta)\n            s = max(np.hypot(x - Ax, y - Ay), np.hypot(x - Ux, y - Uy))\n            initials.append(np.array([x, y, s]))\n    else:\n        # L == 0: The only feasible R is at the outlet\n        x = Ox\n        y = Oy\n        s = max(np.hypot(x - Ax, y - Ay), np.hypot(x - Ux, y - Uy))\n        initials.append(np.array([x, y, s]))\n\n    # Bounds: x, y unbounded; s >= 0\n    bounds = [(None, None), (None, None), (0.0, None)]\n\n    candidates = []\n    best_obj = None\n\n    for z0 in initials:\n        res = minimize(\n            objective, z0, method='SLSQP',\n            bounds=bounds,\n            constraints=constraints_template,\n            options={'ftol': 1e-12, 'maxiter': 500}\n        )\n        if not res.success:\n            # Even if not successful, consider if it's nearly feasible; skip otherwise\n            continue\n        x, y, s = res.x\n        # Feasibility check with tolerance\n        feas = (\n            s + 1e-7 >= np.hypot(x - Ax, y - Ay) and\n            s + 1e-7 >= np.hypot(x - Ux, y - Uy) and\n            L + 1e-7 >= np.hypot(x - Ox, y - Oy) and\n            s >= -1e-7\n        )\n        if not feas:\n            continue\n        obj = s\n        candidates.append((obj, x, y, s))\n\n        if best_obj is None or obj < best_obj:\n            best_obj = obj\n\n    if not candidates:\n        # Fallback: enforce at least the outlet point (L could be zero)\n        x = Ox\n        y = Oy\n        s = max(np.hypot(x - Ax, y - Ay), np.hypot(x - Ux, y - Uy))\n        return [x, y]\n\n    # Filter near-optimal candidates within tolerance\n    tol = max(1e-8, 1e-8 * (1.0 + best_obj))\n    near_opt = [(x, y) for (obj, x, y, s) in candidates if obj <= best_obj + tol]\n\n    # Deduplicate near-opt points by proximity\n    unique_pts = []\n    for (x, y) in near_opt:\n        if not any((abs(x - ux) <= 1e-7 and abs(y - uy) <= 1e-7) for (ux, uy) in unique_pts):\n            unique_pts.append((x, y))\n\n    # Apply tie-breaking: smallest x, then smallest y\n    unique_pts.sort(key=lambda p: (p[0], p[1]))\n    x_star, y_star = unique_pts[0]\n    return [x_star, y_star]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: ((Ax,Ay),(Ux,Uy),(Ox,Oy), L, alpha)\n    test_cases = [\n        ((0.0, 0.0), (10.0, 0.0), (5.0, 3.0), 3.0, 2.0),\n        ((0.0, 0.0), (10.0, 0.0), (20.0, 0.0), 3.0, 2.0),\n        ((0.0, 0.0), (10.0, 0.0), (5.0, 0.0), 5.0, 3.5),\n        ((-2.0, 1.0), (4.0, 7.0), (4.0, 1.0), 2.0, 2.7),\n    ]\n\n    results = []\n    for case in test_cases:\n        A, U, O, L, alpha = case\n        x_star, y_star = solve_case(A, U, O, L, alpha)\n        # Round to six decimals as required\n        x_out = float(np.round(x_star, 6))\n        y_out = float(np.round(y_star, 6))\n        results.append([x_out, y_out])\n\n    # Final print statement in the exact required format.\n    # Ensure fixed decimal representation with six decimals.\n    def fmt_pair(p):\n        return f\"[{p[0]:.6f},{p[1]:.6f}]\"\n    print(f\"[{','.join(fmt_pair(p) for p in results)}]\")\n\nsolve()\n```", "id": "2380493"}, {"introduction": "理论的优雅最终需要通过稳健的算法在计算机上实现。在处理复杂的约束优化问题时，增广拉格朗日方法是一种强大而流行的数值技术。这个练习 [@problem_id:2380561] 将引导你从头开始实现这个方法，解决一个二次规划问题。通过编写代码并观察不同惩罚参数 $\\rho$ 对收敛速度的影响，你将获得宝贵的实践经验，深刻理解理论与计算实践之间的联系。", "problem": "考虑一个具有等式约束的二元实变量二次优化问题。设目标函数为\n$$\nf(\\boldsymbol{x}) \\;=\\; \\tfrac{1}{2}\\,\\boldsymbol{x}^\\top Q\\,\\boldsymbol{x} \\;+\\; \\boldsymbol{c}^\\top \\boldsymbol{x},\n$$\n其中 $Q \\in \\mathbb{R}^{2 \\times 2}$ 是对称正定矩阵，$\\boldsymbol{c} \\in \\mathbb{R}^{2}$。线性等式约束为\n$$\nA\\,\\boldsymbol{x} \\;=\\; b,\n$$\n其中 $A \\in \\mathbb{R}^{1 \\times 2}$，$b \\in \\mathbb{R}$。使用以下具体数据\n$$\nQ \\;=\\; \\begin{bmatrix} 4 & 1 \\\\ 1 & 3 \\end{bmatrix}, \\quad \\boldsymbol{c} \\;=\\; \\begin{bmatrix} -1 \\\\ -2 \\end{bmatrix}, \\quad A \\;=\\; \\begin{bmatrix} 1 & 2 \\end{bmatrix}, \\quad b \\;=\\; 1.\n$$\n设初始原始迭代值为\n$$\n\\boldsymbol{x}_0 \\;=\\; \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix},\n$$\n等式约束的初始对偶迭代值（拉格朗日乘子）为\n$$\n\\lambda_0 \\;=\\; 0.\n$$\n将迭代点 $(\\boldsymbol{x}, \\lambda)$ 处的 Karush–Kuhn–Tucker (KKT) 残差定义为原始残差\n$$\nr_p \\;=\\; \\lVert A\\,\\boldsymbol{x} - b \\rVert_2,\n$$\n和平稳性残差\n$$\nr_s \\;=\\; \\lVert Q\\,\\boldsymbol{x} + \\boldsymbol{c} + A^\\top \\lambda \\rVert_2.\n$$\n当满足以下条件时，算法被视为收敛\n$$\n\\max\\{\\, r_p,\\, r_s \\,\\} \\;\\le\\; \\varepsilon,\n$$\n容差为\n$$\n\\varepsilon \\;=\\; 10^{-9}.\n$$\n设定最大外层迭代次数为\n$$\nk_{\\max} \\;=\\; 10000.\n$$\n对于罚参数值（测试集）\n$$\n\\boldsymbol{\\rho}_{\\text{test}} \\;=\\; \\big[\\, 0.01,\\, 0.1,\\, 1.0,\\, 10.0,\\, 1000.0 \\,\\big],\n$$\n对该问题应用数值增广拉格朗日方法，对于 $\\boldsymbol{\\rho}_{\\text{test}}$ 中的每个 $\\rho$ 值，都从 $\\boldsymbol{x}_0$ 和 $\\lambda_0$ 开始。对于每个 $\\rho$，计算满足上述收敛准则所需的外层迭代次数。如果在 $k_{\\max}$ 次迭代内未达到收敛，则该情况下的结果报告为 $k_{\\max}$。\n\n您的程序必须生成单行输出，其中包含与 $\\boldsymbol{\\rho}_{\\text{test}}$ 条目顺序相同的迭代次数，形式为用方括号括起来的逗号分隔列表。例如，如果计数为 $k_1, k_2, k_3, k_4, k_5$，则输出必须是\n$$\n[\\,k_1,k_2,k_3,k_4,k_5\\,].\n$$\n所有数值答案都是无量纲的，并且必须以整数形式返回。本问题不涉及物理单位，也未使用角度。", "solution": "所给出的问题是一个标准的、适定的等式约束二次优化问题。所有必要的数据、初始条件和收敛准则均已提供，并且该问题基于计算工程中数值优化的既定原则。因此，该问题是有效的，并且存在直接解。\n\n任务是最小化二次目标函数\n$$\nf(\\boldsymbol{x}) = \\frac{1}{2}\\boldsymbol{x}^\\top Q\\,\\boldsymbol{x} + \\boldsymbol{c}^\\top \\boldsymbol{x}\n$$\n同时满足线性等式约束\n$$\nA\\,\\boldsymbol{x} - b = 0.\n$$\n该问题将使用增广拉格朗日方法（也称为乘子法）求解。这种迭代方法将拉格朗日函数与一个针对约束违反的二次惩罚项相结合。\n\n该问题的增广拉格朗日函数 $L_{\\rho}(\\boldsymbol{x}, \\lambda)$ 定义为：\n$$\nL_{\\rho}(\\boldsymbol{x}, \\lambda) = f(\\boldsymbol{x}) + \\lambda (A\\,\\boldsymbol{x} - b) + \\frac{\\rho}{2}(A\\,\\boldsymbol{x} - b)^2\n$$\n此处，$\\lambda \\in \\mathbb{R}$ 是与等式约束相关的拉格朗日乘子，$\\rho > 0$ 是罚参数。增广拉格朗日方法通过一系列由 $k$ 索引的“外层”迭代进行，从初始猜测 $(\\boldsymbol{x}_0, \\lambda_0)$ 开始。每次迭代包括两个主要步骤：\n\n1.  **原始变量更新（x-最小化）：** 对于给定的乘子估计值 $\\lambda_k$，通过最小化关于 $\\boldsymbol{x}$ 的增广拉格朗日函数来找到下一个原始迭代值 $\\boldsymbol{x}_{k+1}$：\n    $$\n    \\boldsymbol{x}_{k+1} = \\operatorname*{arg\\,min}_{\\boldsymbol{x}} L_{\\rho}(\\boldsymbol{x}, \\lambda_k)\n    $$\n    由于 $L_{\\rho}(\\boldsymbol{x}, \\lambda_k)$ 是关于 $\\boldsymbol{x}$ 的严格凸二次函数（因为 $Q$ 是正定的且 $\\rho > 0$），这个最小化子问题有唯一解。通过将 $L_{\\rho}$ 对 $\\boldsymbol{x}$ 的梯度置零来找到该解：\n    $$\n    \\nabla_{\\boldsymbol{x}} L_{\\rho}(\\boldsymbol{x}_{k+1}, \\lambda_k) = \\boldsymbol{0}\n    $$\n    计算梯度可得：\n    $$\n    \\nabla_{\\boldsymbol{x}} \\left( \\frac{1}{2}\\boldsymbol{x}^\\top Q\\,\\boldsymbol{x} + \\boldsymbol{c}^\\top \\boldsymbol{x} + \\lambda_k (A\\,\\boldsymbol{x} - b) + \\frac{\\rho}{2}(A\\,\\boldsymbol{x} - b)^2 \\right) = Q\\boldsymbol{x} + \\boldsymbol{c} + A^\\top\\lambda_k + \\rho A^\\top(A\\boldsymbol{x} - b) = \\boldsymbol{0}\n    $$\n    为求解 $\\boldsymbol{x}_{k+1}$，我们将各项重新排列成一个线性方程组：\n    $$\n    (Q + \\rho A^\\top A)\\boldsymbol{x}_{k+1} = - \\boldsymbol{c} - A^\\top\\lambda_k + \\rho A^\\top b\n    $$\n    矩阵 $(Q + \\rho A^\\top A)$ 是对称正定的，这保证了该线性系统可以可靠地求解出唯一的 $\\boldsymbol{x}_{k+1}$。\n\n2.  **对偶变量更新（乘子更新）：** 在找到 $\\boldsymbol{x}_{k+1}$ 后，拉格朗日乘子根据以下规则进行更新：\n    $$\n    \\lambda_{k+1} = \\lambda_k + \\rho(A\\boldsymbol{x}_{k+1} - b)\n    $$\n    该更新规则旨在随着迭代的进行将原始残差 $(A\\boldsymbol{x} - b)$ 驱动至零。\n\n迭代过程从给定的初始值 $\\boldsymbol{x}_0 = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$ 和 $\\lambda_0 = 0$ 开始。在每次迭代 $k$ 中，我们通过评估 Karush–Kuhn–Tucker (KKT) 残差来判断收敛性。原始残差 $r_p = \\lVert A\\,\\boldsymbol{x}_k - b \\rVert_2$ 衡量当前迭代点的可行性，而平稳性残差 $r_s = \\lVert Q\\,\\boldsymbol{x}_k + \\boldsymbol{c} + A^\\top \\lambda_k \\rVert_2$ 衡量迭代点满足拉格朗日平稳性条件的接近程度。\n\n当条件 $\\max\\{r_p, r_s\\} \\le \\varepsilon$ 满足时，算法终止，其中容差为 $\\varepsilon = 10^{-9}$。达到此条件所需的外层迭代次数 $k$ 会被记录下来。如果在 $k_{\\max} = 10000$ 次迭代内未达到收敛，则停止该过程，并将迭代次数报告为 $k_{\\max}$。\n\n对于所提供的测试集 $\\boldsymbol{\\rho}_{\\text{test}} = [0.01, 0.1, 1.0, 10.0, 1000.0]$ 中的每个罚参数 $\\rho$，都独立执行这一完整过程。对于每个 $\\rho$，算法都会重置为初始条件 $(\\boldsymbol{x}_0, \\lambda_0)$，并计算收敛所需的迭代次数。最终输出是这些迭代次数的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the equality-constrained quadratic optimization problem using\n    the augmented Lagrangian method for a range of penalty parameters.\n    \"\"\"\n    # Define problem data\n    Q = np.array([[4., 1.], [1., 3.]])\n    c = np.array([[-1.], [-2.]])\n    A = np.array([[1., 2.]])\n    b = 1.0\n\n    # Initial conditions\n    x0 = np.array([[0.], [0.]])\n    lambda0 = 0.0\n\n    # Algorithm parameters\n    epsilon = 1e-9\n    k_max = 10000\n    rho_test = [0.01, 0.1, 1.0, 10.0, 1000.0]\n\n    # Pre-compute constant matrices\n    At = A.T\n    AtA = At @ A\n\n    def run_augmented_lagrangian(rho):\n        \"\"\"\n        Executes the augmented Lagrangian algorithm for a given penalty parameter rho.\n\n        Returns the number of outer iterations required for convergence.\n        \"\"\"\n        x = x0.copy()\n        lam = lambda0\n        k = 0\n\n        # Pre-compute the system matrix M which depends on rho\n        M = Q + rho * AtA\n        \n        while k <= k_max:\n            # 1. Check for convergence at the current iterate (x, lam)\n            # Primal residual\n            primal_residual_vec = A @ x - b\n            rp = np.linalg.norm(primal_residual_vec)\n            \n            # Stationarity residual\n            stationarity_residual_vec = Q @ x + c + At * lam\n            rs = np.linalg.norm(stationarity_residual_vec)\n\n            if max(rp, rs) <= epsilon:\n                return k\n\n            # If max iterations are reached, stop and return k_max\n            if k == k_max:\n                break\n            \n            # 2. Perform the update step\n            # Primal update (x-minimization)\n            d = -c - lam * At + rho * b * At\n            x_next = np.linalg.solve(M, d)\n            \n            # Dual update (lambda-update)\n            # The expression A @ x_next - b results in a 1x1 array\n            lam_next = lam + rho * (A @ x_next - b)[0, 0]\n\n            # Update iterates for the next loop\n            x = x_next\n            lam = lam_next\n            k += 1\n            \n        return k_max\n\n    results = []\n    for rho in rho_test:\n        iterations = run_augmented_lagrangian(rho)\n        results.append(iterations)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2380561"}]}