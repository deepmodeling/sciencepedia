{"hands_on_practices": [{"introduction": "本练习将引导您解决一个经典的设施选址问题：如何以最少的消防站覆盖城市中的所有建筑。这个问题是著名的“集合覆盖问题” (Set Cover Problem) 的一个实例，它是整数规划和运筹学中的一个基本问题 [@problem_id:2394756]。通过这个实践，您将学习如何将“每个建筑都必须在服务范围内”这类现实世界的需求，转化为精确的数学约束，并构建一个可求解的优化模型。", "problem": "给定一座城市，其中有有限数量的建筑物和有限数量的可供建立消防站的候选位置。对于每个候选位置和建筑物，都给定了以分钟为单位的行驶时间。如果一个消防站到某建筑物的行驶时间小于或等于$5$分钟的响应时间阈值，则称该建筑物被此消防站所覆盖。目标是决定在何处建立消防站，以确保每座建筑物都被覆盖，同时使用尽可能少的消防站数量。\n\n请将此问题表述为一个数学优化问题。设建筑物的集合由 $i \\in \\{0,1,\\dots,n-1\\}$ 索引，候选消防站位置的集合由 $j \\in \\{0,1,\\dots,m-1\\}$ 索引。令 $t_{ij}$ 表示从候选消防站 $j$ 到建筑物 $i$ 的行驶时间（以分钟为单位）。定义一个二元覆盖参数\n$$\na_{ij} = \\begin{cases}\n1, & \\text{如果 } t_{ij} \\le 5 \\\\\n0, & \\text{如果 } t_{ij} > 5\n\\end{cases}.\n$$\n为所有 $j$ 定义决策变量 $x_j \\in \\{0,1\\}$，其中 $x_j = 1$ 表示在候选位置 $j$ 建立一个消防站，否则 $x_j = 0$。该优化问题为：\n$$\n\\min \\sum_{j=0}^{m-1} x_j\n$$\n约束条件为\n$$\n\\sum_{j=0}^{m-1} a_{ij} x_j \\ge 1, \\quad \\forall i \\in \\{0,1,\\dots,n-1\\},\n$$\n$$\nx_j \\in \\{0,1\\}, \\quad \\forall j \\in \\{0,1,\\dots,m-1\\}.\n$$\n\n实现一个完整的、可运行的程序，该程序能对下述的每个测试用例，确定：\n- 所需的最小消防站数量，以及\n- 一个能达到此最小值的最优消防站索引集（使用基于$0$的索引）；如果存在多个最优集，则返回字典序最小的已排序索引集，其中字典序按元组方式比较已排序的索引列表，\n- 或者，确定不存在可行解。\n\n如果不存在可行解（即，至少有一座建筑物不在任何候选消防站的$5$分钟行驶时间内），你的程序必须为该测试用例输出整数 $-1$。否则，对于一个可行的测试用例，你的程序必须输出一个形式为 $[k,[j_1,j_2,\\dots,j_k]]$ 的列表，其中 $k$ 是最小消防站数量，$[j_1,\\dots,j_k]$ 是所选消防站索引的严格递增列表。\n\n测试套件（每个 $T^{(c)}$ 是一个 $m \\times n$ 矩阵；第 $j$ 行和第 $i$ 列给出 $t_{ij}$，单位为分钟）：\n\n- 测试用例 $1$：$m=n=5$，\n$$\nT^{(1)}=\\begin{bmatrix}\n4.0 & 5.0 & 6.0 & 6.0 & 6.2 \\\\\n6.1 & 3.5 & 4.0 & 5.0 & 6.5 \\\\\n3.0 & 6.0 & 6.0 & 6.0 & 4.5 \\\\\n7.0 & 6.8 & 2.5 & 3.5 & 5.5 \\\\\n8.0 & 7.5 & 6.2 & 6.1 & 1.5\n\\end{bmatrix}.\n$$\n\n- 测试用例 $2$：$m=n=3$ （边界覆盖时间恰好为$5$分钟），\n$$\nT^{(2)}=\\begin{bmatrix}\n5.0 & 5.0 & 5.0 \\\\\n5.0 & 6.0 & 6.0 \\\\\n6.0 & 5.0 & 6.0\n\\end{bmatrix}.\n$$\n\n- 测试用例 $3$：$m=n=2$ （不可行），\n$$\nT^{(3)}=\\begin{bmatrix}\n4.0 & 6.0 \\\\\n6.0 & 6.1\n\\end{bmatrix}.\n$$\n\n- 测试用例 $4$：$m=n=4$ （多个最优解；必须选择字典序最小的），\n$$\nT^{(4)}=\\begin{bmatrix}\n4.0 & 6.0 & 5.0 & 6.0 \\\\\n5.0 & 6.0 & 6.0 & 4.0 \\\\\n6.0 & 3.0 & 4.5 & 6.0 \\\\\n6.0 & 4.0 & 6.0 & 3.0\n\\end{bmatrix}.\n$$\n\n最终输出格式：你的程序应生成单行输出，其中包含一个方括号括起来的、以逗号分隔的结果列表，结果顺序与测试用例$1$到$4$的顺序一致。对于每个测试用例，如果不可行则输出 $-1$，或者输出如上定义的 $[k,[j_1,\\dots,j_k]]$ 形式的列表。最终打印的行不得包含任何空格。例如，一个有效的整体输出可能如下所示\n$$\n[[k_1,[j^{(1)}_1,\\dots]],[k_2,[\\dots]],-1,[k_4,[\\dots]]].\n$$", "solution": "所提出的问题是集合覆盖问题的一个经典整数线性规划表述，这是计算工程和运筹学中的一个基本课题。\n\n对问题陈述的验证证实了其自洽、一致且科学上合理。该问题是良构的，为所有测试用例提供了清晰的目标函数、一套完整的约束条件和明确的数据。其数学表述，\n$$\n\\min \\sum_{j=0}^{m-1} x_j\n$$\n约束条件为\n$$\n\\sum_{j=0}^{m-1} a_{ij} x_j \\ge 1, \\quad \\forall i \\in \\{0,1,\\dots,n-1\\},\n$$\n$$\nx_j \\in \\{0,1\\}, \\quad \\forall j \\in \\{0,1,\\dots,m-1\\},\n$$\n是集合覆盖问题的一个标准且正确的表示。其中的符号定义清晰：$x_j$ 是表示是否在候选位置 $j$ 建立消防站的二元决策变量，而 $a_{ij}$ 是一个二元参数，指示消防站 $j$ 是否能在指定的$5$分钟时间阈值内覆盖建筑物 $i$。该问题没有任何科学谬误、模糊之处或矛盾，因此被认为是有效的。\n\n问题的核心是选择一个最小规模的候选消防站位置子集，使得每座建筑物都被覆盖。用集合覆盖问题的术语来说，建筑物集合 $\\{0, 1, \\dots, n-1\\}$ 构成了需要被覆盖的元素全集。对于每个候选消防站位置 $j \\in \\{0, 1, \\dots, m-1\\}$，我们可以定义一个集合 $S_j$，其中包含消防站 $j$ 能覆盖的所有建筑物的索引。问题就变成了找到这些集合 $\\{S_j\\}$ 的一个最小子集族，其并集能覆盖整个建筑物全集。\n\n众所周知，集合覆盖问题是NP难问题。对于大规模实例，通常会采用近似算法或复杂的整数线性规划求解器。然而，鉴于所提供测试用例的维度很小（例如，$m, n \\le 5$），通过穷举搜索的直接精确解法在计算上是可行的，并且能保证最优性。算法流程如下：\n\n首先，我们预处理输入数据。对于每个测试用例，给定一个 $m \\times n$ 的行驶时间矩阵 $T^{(c)}$，其中第 $j$ 行第 $i$ 列的条目是 $t_{ij}$，我们构建一个 $n \\times m$ 的二元覆盖矩阵 $A$ 。该矩阵的元素 $a_{ij}$ 在 $t_{ij} \\le 5$ 时为 $1$，否则为 $0$。这个矩阵直接表示了覆盖关系：$a_{ij}=1$ 意味着消防站 $j$ 覆盖建筑物 $i$。\n\n其次，我们执行不可行性检查。一个可行解的必要前提是每座建筑物都必须能被至少一个候选消防站覆盖。这可以通过检查覆盖矩阵 $A$ 中对应于每个建筑物 $i$ 的行是否至少包含一个非零条目来验证，即 $\\sum_{j=0}^{m-1} a_{ij} \\ge 1$。如果这个条件对任何建筑物不成立，那么没有任何消防站组合能覆盖所有建筑物，问题被判定为不可行。\n\n第三，如果问题是可行的，我们通过从 $k=1$ 到 $m$ 迭代消防站数量 $k$ 来搜索最优解。对于每个 $k$ 值，我们从 $m$ 个可用候选中生成所有 $k$ 个消防站位置的唯一组合。问题要求在所有最优解中找出字典序最小的消防站索引集。通过按字典序生成消防站索引的组合，可以自然地处理这一点。对于最小的 $k$ 值，找到的第一个有效覆盖集，根据其构造方式，即为所求的最优解。\n\n最后，对于每个生成的 $k$ 个消防站的组合，我们验证它是否构成一个有效的覆盖。如果对于每个建筑物 $i$，所选的 $k$ 个消防站中至少有一个能覆盖它，则该组合是一个有效的覆盖。第一个满足此条件的组合即为解。搜索终止，我们报告当前的 $k$ 值和相应的消防站索引集。如果在 $k \\le m$ 的循环中没有找到任何解，那将意味着不可行，而这种情况已由我们最初的检查处理。因为一个可行问题总是存在一个 $k \\le m$ 的解（最坏情况下，使用所有至少覆盖了一个唯一的、否则未被覆盖的建筑物的消防站），所以搜索保证能找到一个解。", "answer": "```python\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Main function to solve the set of test cases for the fire station location problem.\n    \"\"\"\n    T1 = np.array([\n        [4.0, 5.0, 6.0, 6.0, 6.2],\n        [6.1, 3.5, 4.0, 5.0, 6.5],\n        [3.0, 6.0, 6.0, 6.0, 4.5],\n        [7.0, 6.8, 2.5, 3.5, 5.5],\n        [8.0, 7.5, 6.2, 6.1, 1.5]\n    ])\n\n    T2 = np.array([\n        [5.0, 5.0, 5.0],\n        [5.0, 6.0, 6.0],\n        [6.0, 5.0, 6.0]\n    ])\n\n    T3 = np.array([\n        [4.0, 6.0],\n        [6.0, 6.1]\n    ])\n\n    T4 = np.array([\n        [4.0, 6.0, 5.0, 6.0],\n        [5.0, 6.0, 6.0, 4.0],\n        [6.0, 3.0, 4.5, 6.0],\n        [6.0, 4.0, 6.0, 3.0]\n    ])\n\n    test_cases = [T1, T2, T3, T4]\n    \n    results = []\n    for t_matrix in test_cases:\n        result = solve_set_cover(t_matrix)\n        results.append(result)\n\n    # Format the final output string as specified, with no spaces.\n    results_str = []\n    for res in results:\n        if res == -1:\n            results_str.append(\"-1\")\n        else:\n            k, indices = res\n            indices_str = ','.join(map(str, indices))\n            results_str.append(f\"[{k},[{indices_str}]]\")\n            \n    print(f\"[{','.join(results_str)}]\")\n\ndef solve_set_cover(t_matrix):\n    \"\"\"\n    Solves the set cover problem for a single test case.\n\n    Args:\n        t_matrix (np.ndarray): An m x n matrix of travel times, t_ij is at row j, col i.\n\n    Returns:\n        - A list [k, [j1, j2, ...]] for a feasible solution, where k is the minimum\n          number of stations and [j1, ...] are their indices.\n        - The integer -1 if no feasible solution exists.\n    \"\"\"\n    m, n = t_matrix.shape\n    response_time_threshold = 5.0\n\n    # Build the coverage sets for each station.\n    # station_covers[j] is a set of building indices covered by station j.\n    station_covers = [set() for _ in range(m)]\n    for j in range(m):  # station index\n        for i in range(n):  # building index\n            if t_matrix[j, i] = response_time_threshold:\n                station_covers[j].add(i)\n\n    # Check for infeasibility: any building that cannot be covered by any station.\n    all_coverable_buildings = set()\n    for s in station_covers:\n        all_coverable_buildings.update(s)\n    \n    if len(all_coverable_buildings)  n:\n        return -1\n\n    # Brute-force search for the minimum number of stations (k).\n    # Iterate from k=1 up to m.\n    for k in range(1, m + 1):\n        # Generate combinations of k stations. `itertools.combinations`\n        # generates them in lexicographical order.\n        for station_indices in combinations(range(m), k):\n            covered_buildings = set()\n            for station_idx in station_indices:\n                covered_buildings.update(station_covers[station_idx])\n            \n            # Check if all n buildings are covered.\n            if len(covered_buildings) == n:\n                # This is the first solution found for the smallest k, and it's\n                # the lexicographically smallest set of for that_k. So it's optimal.\n                return [k, list(station_indices)]\n    \n    # This part of the code should not be reachable if the initial\n    # feasibility check is correct. A feasible problem always has a solution.\n    return -1\n\nsolve()\n```", "id": "2394756"}, {"introduction": "在资源有限的情况下，如何分配预算以获得最大效益？这个练习模拟了一个常见的商业场景：在多个营销渠道中分配预算以最大化客户转化数 [@problem_id:2394742]。此问题引入了“边际效益递减” (diminishing returns) 的核心经济学概念，通过凹函数 $f_i(x_i)$ 来模拟这一现象。您将探索凸优化的强大原理，即在最优解处，所有投入资源的渠道其边际回报应该相等，这一结论源于 KKT 条件。", "problem": "给定一个必须从数学优化的基本原理进行公式化和求解的分配问题。现有 $n$ 个营销渠道，以 $i \\in \\{1,\\dots,n\\}$ 为索引。设 $x_i \\ge 0$ 表示分配给渠道 $i$ 的非负支出。目标是最大化总转化数，该转化数由渠道特定的转化函数 $f_i(x_i)$ 的总和来建模，同时受限于总预算约束和可选的各渠道支出上限 $u_i \\in (0,+\\infty]$（如果某个渠道未明确指定上限，则取 $u_i=+\\infty$）。待求解的优化问题是：\n最大化 $\\sum_{i=1}^{n} f_i(x_i)$，约束条件为 $\\sum_{i=1}^{n} x_i \\le B$，以及对所有 $i$ 都有 $0 \\le x_i \\le u_i$。\n\n对于此问题，函数 $f_i$ 是从 $[0,+\\infty)$ 到 $[0,+\\infty)$ 的凹、递增、二次连续可微函数，选自以下族群，其参数除非另有说明，否则均为严格为正的实数：\n\n- 对数响应（L型）：$f_i(x) = a_i \\,\\log\\!\\big(1 + b_i x\\big)$，参数 $a_i0, b_i0$。如果指定 $a_i=0$，则对所有 $x$ 都有 $f_i(x)\\equiv 0$。\n- 平方根响应（S型）：$f_i(x) = c_i \\,\\sqrt{x}$，参数 $c_i0$。\n- 指数饱和（E型）：$f_i(x) = d_i \\,\\big(1 - \\exp(-e_i x)\\big)$，参数 $d_i0, e_i0$。\n\n所有对数均为自然对数，$\\exp(\\cdot)$ 表示指数函数。所有预算和支出均为非负实数。\n\n您的任务是，对下面指定的每个测试用例，计算满足约束的最优分配 $(x_1,\\dots,x_n)$ 所能达到的总转化数 $\\sum_{i=1}^{n} f_i(x_i)$ 的最大值。每个测试用例的答案必须报告为一个四舍五入到恰好 $6$ 位小数的实数。\n\n测试套件：\n\n- 测试用例 $1$：\n  - 预算 $B = 100.0$。\n  - 渠道：\n    - 渠道 $1$：L型，参数 $a_1=120.0, b_1=0.015$，无上限（$u_1=+\\infty$）。\n    - 渠道 $2$：L型，参数 $a_2=80.0, b_2=0.03$，无上限（$u_2=+\\infty$）。\n    - 渠道 $3$：E型，参数 $d_3=200.0, e_3=0.02$，无上限（$u_3=+\\infty$）。\n- 测试用例 $2$：\n  - 预算 $B = 0.0$。\n  - 渠道：\n    - 渠道 $1$：L型，参数 $a_1=100.0, b_1=0.02$，无上限（$u_1=+\\infty$）。\n    - 渠道 $2$：S型，参数 $c_2=50.0$，无上限（$u_2=+\\infty$）。\n- 测试用例 $3$：\n  - 预算 $B = 50.0$。\n  - 渠道（每个都有明确的上限）：\n    - 渠道 $1$：S型，参数 $c_1=40.0$，上限 $u_1=10.0$。\n    - 渠道 $2$：S型，参数 $c_2=30.0$，上限 $u_2=5.0$。\n- 测试用例 $4$：\n  - 预算 $B = 120.0$。\n  - 渠道：\n    - 渠道 $1$：L型，参数 $a_1=150.0, b_1=0.01$，上限 $u_1=80.0$。\n    - 渠道 $2$：S型，参数 $c_2=60.0$，无上限（$u_2=+\\infty$）。\n    - 渠道 $3$：E型，参数 $d_3=180.0, e_3=0.05$，上限 $u_3=30.0$。\n    - 渠道 $4$：L型，参数 $a_4=0.0, b_4=0.02$，无上限（$u_4=+\\infty$）。\n\n最终输出格式：\n\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含测试用例 $1、2、3$ 和 $4$ 的最大总转化数，每个都四舍五入到恰好 $6$ 位小数，例如 $[v_1,v_2,v_3,v_4]$，其中每个 $v_k$ 都是一个小数点后恰好有 $6$ 位数字的十进制数。", "solution": "该问题是一个资源分配问题，是凸优化的一个典型例子。目标是在线性预算约束和变量的箱型约束下，最大化一个总目标函数，该函数是各个凹函数的和。\n\n该优化问题可正式表述为：\n$$\n\\begin{aligned}\n\\text{最大化} \\quad  Z = \\sum_{i=1}^{n} f_i(x_i) \\\\\n\\text{约束于} \\quad  \\sum_{i=1}^{n} x_i \\le B \\\\\n 0 \\le x_i \\le u_i, \\quad \\text{对 } i=1, \\dots, n\n\\end{aligned}\n$$\n这里，$x_i$ 是在渠道 $i$ 上的支出，$B$ 是总预算，$u_i$ 是渠道 $i$ 的支出上限。函数 $f_i(x_i)$ 表示渠道 $i$ 在支出为 $x_i$ 时的转化数。问题陈述中指出，每个 $f_i$ 都是凹、递增且二次连续可微的。凹函数的和也是凹函数。在一个凸可行集（由线性不等式定义）上最大化一个凹函数是一个凸优化问题。\n\n我们可以使用 Karush-Kuhn-Tucker (KKT) 条件来解决这个问题。该问题的拉格朗日函数是：\n$$ L(x, \\lambda, \\mu, \\nu) = \\sum_{i=1}^{n} f_i(x_i) - \\lambda \\left( \\sum_{i=1}^{n} x_i - B \\right) - \\sum_{i=1}^{n} \\mu_i (x_i - u_i) + \\sum_{i=1}^{n} \\nu_i x_i $$\n其中 $\\lambda, \\mu_i, \\nu_i \\ge 0$ 分别是与预算约束、上限约束和非负性约束相关的拉格朗日乘子。\n\nKKT 平稳性条件为对每个 $i$ 都有 $\\frac{\\partial L}{\\partial x_i} = 0$：\n$$ f'_i(x_i) - \\lambda - \\mu_i + \\nu_i = 0 $$\n其中 $f'_i(x_i)$ 是 $f_i$ 关于 $x_i$ 的一阶导数，代表边际转化率。\n\n互补松弛条件为最优解提供了以下关系：\n1.  如果 $0  x_i  u_i$，则 $\\nu_i=0$ 且 $\\mu_i=0$，这意味着 $f'_i(x_i) = \\lambda$。\n2.  如果 $x_i = 0$，则 $\\nu_i \\ge 0$ 且 $\\mu_i=0$，这意味着 $f'_i(0) \\le \\lambda$。\n3.  如果 $x_i = u_i$，则 $\\nu_i = 0$ 且 $\\mu_i \\ge 0$，这意味着 $f'_i(u_i) \\ge \\lambda$。\n\n拉格朗日乘子 $\\lambda$ 可以解释为所花费的最后一美元的边际回报（每单位支出的转化数）。在最优点，所有获得非零支出（且未达到其上限）的渠道必须具有相同的边际回报 $\\lambda$。\n\n这一洞见为我们寻找最优分配 $(x_1, \\dots, x_n)$ 提供了一种方法。对于给定的 $\\lambda$ 值，可以确定每个渠道的最优支出 $x_i(\\lambda)$。由于 $f_i$ 是凹函数，所以 $f'_i$ 是一个递减函数。因此，其反函数 $(f'_i)^{-1}$ 也是一个递减函数。对于给定的 $\\lambda$，最优支出 $x_i$ 为：\n$$ x_i(\\lambda) = \\min(u_i, \\max(0, (f'_i)^{-1}(\\lambda))) $$\n\n总支出是 $\\lambda$ 的一个单调非增函数：$X(\\lambda) = \\sum_{i=1}^n x_i(\\lambda)$。\n我们的任务是找到一个 $\\lambda^* \\ge 0$，使得总预算被用完，即 $X(\\lambda^*) = B$，前提是总无约束支出会超过 $B$。\n\n给定函数族的导数 $f'_i$ 及其反函数 $(f'_i)^{-1}$ 如下：\n- **对数型 (L):** $f_i(x) = a_i \\log(1 + b_i x)$\n  - $f'_i(x) = \\frac{a_i b_i}{1 + b_i x}$\n  - $(f'_i)^{-1}(\\lambda) = \\frac{a_i}{\\lambda} - \\frac{1}{b_i}$\n- **平方根型 (S):** $f_i(x) = c_i \\sqrt{x}$\n  - $f'_i(x) = \\frac{c_i}{2\\sqrt{x}}$\n  - $(f'_i)^{-1}(\\lambda) = \\left(\\frac{c_i}{2\\lambda}\\right)^2$\n- **指数饱和型 (E):** $f_i(x) = d_i (1 - \\exp(-e_i x))$\n  - $f'_i(x) = d_i e_i \\exp(-e_i x)$\n  - $(f'_i)^{-1}(\\lambda) = \\frac{1}{e_i} \\log\\left(\\frac{d_i e_i}{\\lambda}\\right)$\n\n总体算法如下：\n1.  处理简单情况。如果 $B=0$，则所有 $x_i=0$，总转化数为 $0$。\n2.  计算所有有限上限的总和，$U_{total} = \\sum_{i \\text{ s.t. } u_i\\infty} u_i$。如果问题中有任何渠道的 $u_i = \\infty$，则总容量是无限的。如果所有 $u_i$ 都是有限的且 $B \\ge U_{total}$，则预算约束不具约束力。最优解是在每个渠道上花费至其上限，$x_i = u_i$。总转化数为 $\\sum_i f_i(u_i)$。\n3.  如果 $0  B  U_{total}$（或 $U_{total}=\\infty$），则预算约束是活跃的。我们需要找到唯一的 $\\lambda  0$ 满足 $\\sum_i x_i(\\lambda) = B$。由于 $X(\\lambda)$ 是单调的，我们可以使用像二分法这样的数值求根算法高效地找到这个 $\\lambda$。我们在一个区间（比如 $[\\lambda_{low}, \\lambda_{high}]$）内搜索一个 $\\lambda$，以求解方程 $g(\\lambda) = X(\\lambda) - B = 0$。\n4.  二分搜索通过反复缩小搜索区间来进行。在每一步中，我们选取当前区间的中点 $\\lambda_{mid}$，计算总支出 $X(\\lambda_{mid})$，并根据 $X(\\lambda_{mid})$ 是大于还是小于 $B$ 来更新区间的下界或上界。\n5.  经过足够次数的迭代后，区间会变得足够小，我们可以取其终点作为最优的 $\\lambda^*$。\n6.  用最优的 $\\lambda^*$，我们计算每个渠道的最终支出分配 $x_i^* = x_i(\\lambda^*)$。\n7.  然后，通过对最优支出的转化数求和来计算最大总转化数：$Z^* = \\sum_i f_i(x_i^*)$。\n\n一个特殊情况是主参数值为零的渠道（例如，L型的 $a_i=0$），这导致 $f_i(x) \\equiv 0$ 和 $f'_i(x) \\equiv 0$。对于任何 $\\lambda  0$，条件 $f'_i(0) \\le \\lambda$ 都得到满足，从而正确地得出该渠道的最优支出为 $x_i=0$。\n\n这种方法为给定类别的优化问题提供了一个稳健且通用的解决方案。实现将包括代表渠道响应及其导数的函数，以及一个协调二分搜索的主求解器函数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve all test cases and print the results.\n    \"\"\"\n\n    class ChannelModel:\n        \"\"\"\n        A class to encapsulate the behavior of a single marketing channel.\n        \"\"\"\n        def __init__(self, ch_type, params, u_i):\n            self.ch_type = ch_type\n            self.params = params\n            self.u_i = u_i if u_i is not None else np.inf\n\n            # Pre-calculate derivatives at boundaries for efficiency\n            self.deriv_at_0 = self._f_prime(1e-12) # Use small epsilon for S-type\n            if self.ch_type == 'S':\n                self.deriv_at_0 = np.inf\n            else:\n                 self.deriv_at_0 = self._f_prime(0)\n            \n            self.deriv_at_u = 0\n            if self.u_i  np.inf:\n                self.deriv_at_u = self._f_prime(self.u_i)\n\n        def f(self, x):\n            \"\"\"Calculates the number of conversions for a given spend x.\"\"\"\n            if x  0: x = 0\n            if self.ch_type == 'L':\n                a, b = self.params\n                if a == 0: return 0.0\n                return a * np.log(1 + b * x)\n            elif self.ch_type == 'S':\n                c, = self.params\n                return c * np.sqrt(x)\n            elif self.ch_type == 'E':\n                d, e = self.params\n                return d * (1 - np.exp(-e * x))\n            return 0.0\n\n        def _f_prime(self, x):\n            \"\"\"Calculates the marginal conversion rate (derivative) at spend x.\"\"\"\n            if self.ch_type == 'L':\n                a, b = self.params\n                if a == 0: return 0.0\n                return (a * b) / (1 + b * x)\n            elif self.ch_type == 'S':\n                c, = self.params\n                if x == 0: return np.inf\n                return c / (2 * np.sqrt(x))\n            elif self.ch_type == 'E':\n                d, e = self.params\n                return d * e * np.exp(-e * x)\n            return 0.0\n\n        def _f_prime_inv(self, lam):\n            \"\"\"Calculates spend x for a given marginal return lambda.\"\"\"\n            if lam = 0: return np.inf\n            if self.ch_type == 'L':\n                a, b = self.params\n                if a == 0: return 0.0\n                if lam >= a * b: return 0.0\n                return a / lam - 1 / b\n            elif self.ch_type == 'S':\n                c, = self.params\n                return (c / (2 * lam))**2\n            elif self.ch_type == 'E':\n                d, e = self.params\n                if lam >= d * e: return 0.0\n                return np.log(d * e / lam) / e\n            return 0.0\n\n        def get_spend(self, lam):\n            \"\"\"Determines optimal spend for a given lambda.\"\"\"\n            if lam >= self.deriv_at_0:\n                return 0.0\n            if lam = self.deriv_at_u and self.u_i  np.inf:\n                return self.u_i\n            \n            unbounded_spend = self._f_prime_inv(lam)\n            return min(self.u_i, max(0, unbounded_spend))\n\n    def solve_one_case(budget, channels_data):\n        \"\"\"\n        Solves a single instance of the allocation problem.\n        \"\"\"\n        if budget == 0.0:\n            return 0.0\n\n        channels = [ChannelModel(c_type, params, u_i) for c_type, params, u_i in channels_data]\n        \n        total_upper_bound = sum(ch.u_i for ch in channels if ch.u_i  np.inf)\n        if all(ch.u_i  np.inf for ch in channels) and budget >= total_upper_bound:\n            total_conversions = sum(ch.f(ch.u_i) for ch in channels)\n            return total_conversions\n\n        # Bisection search to find the optimal lambda\n        low_lam = 1e-9\n        high_lam = 1e6 # A sufficiently large upper bound for lambda\n        \n        for _ in range(100): # 100 iterations are sufficient for double precision\n            mid_lam = (low_lam + high_lam) / 2\n            current_spend = sum(ch.get_spend(mid_lam) for ch in channels)\n            \n            if current_spend > budget:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n        \n        final_lambda = (low_lam + high_lam) / 2\n        \n        # Calculate final conversions with the optimal lambda\n        total_conversions = sum(ch.f(ch.get_spend(final_lambda)) for ch in channels)\n        return total_conversions\n\n    test_cases = [\n        {\n            \"B\": 100.0,\n            \"channels\": [\n                ('L', (120.0, 0.015), None),\n                ('L', (80.0, 0.03), None),\n                ('E', (200.0, 0.02), None),\n            ]\n        },\n        {\n            \"B\": 0.0,\n            \"channels\": [\n                ('L', (100.0, 0.02), None),\n                ('S', (50.0,), None),\n            ]\n        },\n        {\n            \"B\": 50.0,\n            \"channels\": [\n                ('S', (40.0,), 10.0),\n                ('S', (30.0,), 5.0),\n            ]\n        },\n        {\n            \"B\": 120.0,\n            \"channels\": [\n                ('L', (150.0, 0.01), 80.0),\n                ('S', (60.0,), None),\n                ('E', (180.0, 0.05), 30.0),\n                ('L', (0.0, 0.02), None),\n            ]\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_one_case(case[\"B\"], case[\"channels\"])\n        results.append(result)\n\n    # Format the final output string\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2394742"}, {"introduction": "此高级练习挑战您设计一个风力发电场，以最大化总发电量，同时考虑涡轮机之间的“尾流效应” (wake effect) [@problem_id:2394774]。这是一个复杂的系统设计问题，其中一个组件（涡轮机）的决策会非线性地影响其他组件的性能。解决此类问题要求您对具有耦合效应和空间依赖性的系统进行建模和优化，这在许多大规模工程设计中是至关重要的技能。", "problem": "你的任务是构建并解决一个设施布局优化问题，在矩形风电场内的候选场址上放置风力涡轮机，以最大化总发电功率。风向是固定的，并与 $x$ 轴正方向对齐。尾流效应使用简化的 Jensen（也称为 Park）尾流模型进行建模：如果下游涡轮机位于上游涡轮机扩张的锥形尾流内，则每个上游涡轮机会降低下游涡轮机可用的风速。\n\n模型构建要求：\n- 决策变量：对于每个候选场址索引 $n$，定义一个二元变量 $z_n \\in \\{0,1\\}$，表示是否在该场址安装了涡轮机。\n- 必须安装恰好 $T$ 台涡轮机：$\\sum_n z_n = T$。\n- 对于任意一对选定的场址 $n \\neq m$，必须满足最小间距约束：如果 $z_n = 1$ 且 $z_m = 1$，则场址之间的欧几里得距离必须至少为 $s_{\\min}$。\n- 设每个候选场址的坐标为 $(x_n,y_n)$，单位为米。在上风向边界处，风速是均匀的，等于 $V_0$ 米/秒。\n- 设叶轮直径为 $D$ 米，叶轮扫掠面积为 $A = \\pi (D/2)^2$ 平方米，空气密度为 $\\rho$ 千克/立方米，功率系数为 $C_p$（无量纲）。\n- 设轴向诱导因子为 $a$（无量纲），尾流衰减常数为 $k$（无量纲）。对于两个选定的涡轮机 $j$ 和 $i$，其中 $x_j  x_i$，定义顺流向间距 $d_{ji} = x_i - x_j$ 和横向间距 $s_{ji} = |y_i - y_j|$。由涡轮机 $j$ 引起的在 $x_i$ 处的尾流半径为 $r_{ji} = D/2 + k\\, d_{ji}$。涡轮机 $j$ 仅在 $s_{ji} \\le r_{ji}$ 时影响涡轮机 $i$，此时 $j$ 在 $i$ 处造成的单一尾流速度亏损为\n$$\n\\delta_{j\\to i} \\;=\\; \\frac{2a}{\\left(1 + \\frac{2k\\, d_{ji}}{D}\\right)^2}.\n$$\n多个尾流亏损通过平方和-平方根叠加法进行组合。对于一个选定的涡轮机 $i$，设 $\\mathcal{U}(i)$ 为位于 $i$ 上风向并对其产生影响的已选定涡轮机的集合。$i$ 处的有效风速为\n$$\nV_i \\;=\\; V_0 \\,\\Big(1 - \\sqrt{\\sum_{j\\in \\mathcal{U}(i)} \\delta_{j\\to i}^2}\\,\\Big),\n$$\n必要时截断，使其不小于 0。在 $i$ 处提取的电功率为\n$$\nP_i \\;=\\; \\tfrac{1}{2}\\,\\rho\\, A\\, C_p\\, V_i^3.\n$$\n目标是在满足数量和间距约束的条件下，最大化总功率\n$$\n\\max_{z \\in \\{0,1\\}^M} \\;\\; \\sum_{i=1}^{M} z_i\\, P_i(z),\n$$\n其中 $M$ 是候选场址的数量。\n\n单位和最终输出：\n- 所有距离单位必须是米，所有速度单位必须是米/秒，最终功率必须以瓦特表示。对于下面的每个测试用例，你必须报告以瓦特为单位的可实现的最大总功率，结果为四舍五入到最近的整数。\n\n测试套件：\n- 测试用例 1（一般情况）：\n  - $x$ 方向候选网格：$\\{0, 300, 600, 900\\}$ 米。\n  - $y$ 方向候选网格：$\\{0, 300, 600\\}$ 米。\n  - 待放置的涡轮机数量：$T = 4$。\n  - 最小间距：$s_{\\min} = 300$ 米。\n  - 自由来流风速：$V_0 = 12$ 米/秒。\n  - 叶轮直径：$D = 100$ 米。\n  - 空气密度：$\\rho = 1.225$ 千克/立方米。\n  - 功率系数：$C_p = 0.4$。\n  - 轴向诱导因子：$a = \\tfrac{1}{3}$。\n  - 尾流衰减常数：$k = 0.05$。\n- 测试用例 2（单涡轮机边界情况）：\n  - $x$ 方向候选网格：$\\{0, 200, 400\\}$ 米。\n  - $y$ 方向候选网格：$\\{0, 200, 400\\}$ 米。\n  - 待放置的涡轮机数量：$T = 1$。\n  - 最小间距：$s_{\\min} = 300$ 米。\n  - 自由来流风速：$V_0 = 8$ 米/秒。\n  - 叶轮直径：$D = 100$ 米。\n  - 空气密度：$\\rho = 1.225$ 千克/立方米。\n  - 功率系数：$C_p = 0.4$。\n  - 轴向诱导因子：$a = \\tfrac{1}{3}$。\n  - 尾流衰减常数：$k = 0.05$。\n- 测试用例 3（对齐敏感性更强的边缘情况）：\n  - $x$ 方向候选网格：$\\{0, 300, 600, 900\\}$ 米。\n  - $y$ 方向候选网格：$\\{0, 300, 600\\}$ 米。\n  - 待放置的涡轮机数量：$T = 5$。\n  - 最小间距：$s_{\\min} = 300$ 米。\n  - 自由来流风速：$V_0 = 10$ 米/秒。\n  - 叶轮直径：$D = 100$ 米。\n  - 空气密度：$\\rho = 1.225$ 千克/立方米。\n  - 功率系数：$C_p = 0.4$。\n  - 轴向诱导因子：$a = \\tfrac{1}{3}$。\n  - 尾流衰减常数：$k = 0.03$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例 $\\{1,2,3\\}$ 的顺序排列结果，例如 $\\big[$结果$1$,$\\,$结果$2$,$\\,$结果$3\\big]$。每个结果必须是一个整数，表示其测试用例的最优总功率（以瓦特为单位）四舍五入到最近的整数。", "solution": "对问题陈述进行验证。\n\n第 1 步：提取已知条件\n- 决策变量：对于每个候选场址 $n$，$z_n \\in \\{0,1\\}$。如果放置了涡轮机，$z_n=1$，否则 $z_n=0$。\n- 数量约束：必须安装恰好 $T$ 台涡轮机，$\\sum_n z_n = T$。\n- 间距约束：对于任意两个选定的场址 $n \\neq m$（即 $z_n=1, z_m=1$），欧几里得距离 $d_{nm}$ 必须满足 $d_{nm} \\ge s_{\\min}$。\n- 候选场址坐标：$(x_n, y_n)$，单位为米。\n- 风向：固定的，与 $x$ 轴正方向对齐。\n- 自由来流风速：$V_0$ (米/秒)。\n- 叶轮直径：$D$ (米)。\n- 叶轮扫掠面积：$A = \\pi (D/2)^2$ (平方米)。\n- 空气密度：$\\rho$ (千克/立方米)。\n- 功率系数：$C_p$ (无量纲)。\n- 轴向诱导因子：$a$ (无量纲)。\n- 尾流衰减常数：$k$ (无量纲)。\n- 尾流模型：\n  - 顺流向间距：对于 $x_j  x_i$，有 $d_{ji} = x_i - x_j$。\n  - 横向间距：$s_{ji} = |y_i - y_j|$。\n  - 尾流半径：$r_{ji} = D/2 + k\\,d_{ji}$。\n  - 尾流影响条件：如果 $x_j  x_i$ 且 $s_{ji} \\le r_{ji}$，则涡轮机 $j$ 影响 $i$。\n  - 单一尾流速度亏损：$\\delta_{j\\to i} = \\frac{2a}{(1 + \\frac{2k\\, d_{ji}}{D})^2}$。\n  - 尾流叠加：平方和-平方根法。\n  - 涡轮机 $i$ 处的有效风速：$V_i = V_0 (1 - \\sqrt{\\sum_{j\\in \\mathcal{U}(i)} \\delta_{j\\to i}^2})$，其中 $\\mathcal{U}(i)$ 是影响 $i$ 的上风向涡轮机集合。$V_i$ 在 0 处截断。\n- 功率计算：$P_i = \\frac{1}{2}\\,\\rho\\, A\\, C_p\\, V_i^3$。\n- 目标函数：最大化总功率 $\\sum_{i=1}^{M} z_i P_i(z)$，其中 $M$ 是总场址数。\n- 测试用例：\n  - 测试用例 1：候选网格 $x \\in \\{0, 300, 600, 900\\}$ 米, $y \\in \\{0, 300, 600\\}$ 米。$T=4$, $s_{\\min}=300$ 米, $V_0=12$ 米/秒, $D=100$ 米, $\\rho=1.225$ 千克/立方米, $C_p=0.4$, $a=1/3$, $k=0.05$。\n  - 测试用例 2：候选网格 $x \\in \\{0, 200, 400\\}$ 米, $y \\in \\{0, 200, 400\\}$ 米。$T=1$, $s_{\\min}=300$ 米, $V_0=8$ 米/秒, $D=100$ 米, $\\rho=1.225$ 千克/立方米, $C_p=0.4$, $a=1/3$, $k=0.05$。\n  - 测试用例 3：候选网格 $x \\in \\{0, 300, 600, 900\\}$ 米, $y \\in \\{0, 300, 600\\}$ 米。$T=5$, $s_{\\min}=300$ 米, $V_0=10$ 米/秒, $D=100$ 米, $\\rho=1.225$ 千克/立方米, $C_p=0.4$, $a=1/3$, $k=0.03$。\n- 输出要求：总功率以瓦特为单位，四舍五入到最近的整数。\n\n第 2 步：使用提取的已知条件进行验证\n- **科学性**：该问题基于成熟的 Jensen (Park) 尾流模型，这是风能工程中的一种标准简化方法。功率方程是基础物理学原理。所有模型和参数都具有物理意义且在科学上是合理的。\n- **适定性**：该问题是一个组合优化任务。搜索空间由在 $M$ 个离散场址上放置 $T$ 台涡轮机的所有可能布局组成。该空间是有限的。对于任何给定的布局，目标函数（总功率）都是良定义的。因此，可以保证存在一个最大值。该问题是适定的。\n- **客观性**：该问题使用精确的数学方程和明确的物理参数进行规定。它不包含任何主观或基于意见的陈述。\n- **完整性与一致性**：为每个测试用例提供了计算目标函数所需的所有必要数据和模型。约束条件清晰陈述。对最小间距约束的仔细分析表明，对于测试用例 1 和 3，该约束是非限制性的，因为任意两个不同场址之间的最小距离为 300 米，等于 $s_{\\min}$。对于测试用例 2，该约束对点对来说是非平凡的，但由于只放置了 $T=1$ 台涡轮机，所以该约束自然满足。这并不构成矛盾，而是测试用例的特定设置。该问题是自洽且一致的。\n\n第 3 步：结论与行动\n该问题是有效的。将提供一个解决方案。\n\n该问题属于设施选址问题，是组合优化中的一个经典问题。其目标是从总共 $M$ 个候选场址中选择一个包含 $T$ 个场址的子集，以最大化一个目标函数，同时满足特定约束。鉴于候选场址数量较少（情况 1 和 3 为 $M=12$，情况 2 为 $M=9$）以及待放置涡轮机数量较少（$T \\in \\{1, 4, 5\\}$），对所有可能的有效布局进行穷举搜索是一种可行且正确的解决策略。\n\n该算法流程如下：\n1. 对每个测试用例，从指定的网格生成 $M$ 个候选场址坐标 $(x_n, y_n)$ 的集合。\n2. 生成在 $M$ 个场址上放置 $T$ 台涡轮机的所有可能组合。此类组合的数量由二项式系数 $\\binom{M}{T}$ 给出。\n3. 对于每种组合（代表一个潜在的风电场布局），验证其是否满足最小间距约束。如果对于每对选定的涡轮机场址 $i$ 和 $j$，它们的欧几里得距离 $\\sqrt{(x_i-x_j)^2 + (y_i-y_j)^2}$ 大于或等于 $s_{\\min}$，则该布局有效。如前所述，对于所提供的测试用例，此约束不会排除任何组合。\n4. 对于每个有效布局，计算总功率输出。这是对目标函数的评估。此计算本身包括几个步骤：\n    a. 对于布局中的每个涡轮机 $i$，其功率输出 $P_i$ 由其所在位置的有效风速 $V_i$ 决定。\n    b. 为求得 $V_i$，必须首先考虑所有上风向涡轮机的尾流效应。如果 $x_j  x_i$，则涡轮机 $j$ 位于 $i$ 的上风向。\n    c. 对于每个上风向涡轮机 $j$，我们检查涡轮机 $i$ 是否位于其尾流内。如果横向间距 $s_{ji} = |y_i - y_j|$ 不超过该顺风距离处的尾流半径 $r_{ji} = D/2 + k(x_i - x_j)$，则条件成立。\n    d. 如果涡轮机 $i$ 位于一个或多个上风向涡轮机 $j \\in \\mathcal{U}(i)$ 的尾流中，则计算单个的速度亏损 $\\delta_{j\\to i} = \\frac{2a}{(1 + 2k(x_i - x_j)/D)^2}$。\n    e. 使用平方和-平方根法组合这些亏损，以找到总的速度损失分数：$\\sqrt{\\sum_{j \\in \\mathcal{U}(i)} \\delta_{j\\to i}^2}$。\n    f. 于是有效风速为 $V_i = V_0 \\max(0, 1 - \\sqrt{\\sum_{j \\in \\mathcal{U}(i)} \\delta_{j\\to i}^2})$。如果没有影响 $i$ 的上风向涡轮机，则 $V_i = V_0$。\n    g. 来自涡轮机 $i$ 的功率使用标准公式 $P_i = \\frac{1}{2} \\rho A C_p V_i^3$ 计算，其中 $A = \\pi(D/2)^2$。\n    h. 布局的总功率是所有涡轮机功率的总和：$P_{total} = \\sum_i P_i$。\n5. 在所有有效布局中找到的最大总功率即为该测试用例的最优解。然后将此最终值四舍五入到最近的整数，按要求处理。\n\n这种暴力枚举法保证能找到全局最大值，因为它详尽地检查了有限解空间中的每一种可能性。对三个测试用例中的每一个执行该计算，以找到它们各自的最优功率输出。", "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the wind farm layout optimization problem for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"case_id\": 1,\n            \"x_grid\": [0, 300, 600, 900], # meters\n            \"y_grid\": [0, 300, 600], # meters\n            \"T\": 4, # number of turbines\n            \"s_min\": 300.0, # meters\n            \"V0\": 12.0, # m/s\n            \"D\": 100.0, # meters\n            \"rho\": 1.225, # kg/m^3\n            \"Cp\": 0.4,\n            \"a\": 1/3,\n            \"k\": 0.05,\n        },\n        {\n            \"case_id\": 2,\n            \"x_grid\": [0, 200, 400], # meters\n            \"y_grid\": [0, 200, 400], # meters\n            \"T\": 1,\n            \"s_min\": 300.0,\n            \"V0\": 8.0,\n            \"D\": 100.0,\n            \"rho\": 1.225,\n            \"Cp\": 0.4,\n            \"a\": 1/3,\n            \"k\": 0.05,\n        },\n        {\n            \"case_id\": 3,\n            \"x_grid\": [0, 300, 600, 900], # meters\n            \"y_grid\": [0, 300, 600], # meters\n            \"T\": 5,\n            \"s_min\": 300.0,\n            \"V0\": 10.0,\n            \"D\": 100.0,\n            \"rho\": 1.225,\n            \"Cp\": 0.4,\n            \"a\": 1/3,\n            \"k\": 0.03,\n        }\n    ]\n\n    results = []\n\n    for params in test_cases:\n        # Unpack parameters\n        x_grid = params[\"x_grid\"]\n        y_grid = params[\"y_grid\"]\n        T = params[\"T\"]\n        s_min = params[\"s_min\"]\n        V0 = params[\"V0\"]\n        D = params[\"D\"]\n        rho = params[\"rho\"]\n        Cp = params[\"Cp\"]\n        a = params[\"a\"]\n        k = params[\"k\"]\n        \n        # Generate candidate sites\n        sites = np.array([(x, y) for x in x_grid for y in y_grid])\n        num_sites = len(sites)\n        \n        # Rotor swept area\n        A = np.pi * (D / 2.0)**2\n        power_constant = 0.5 * rho * A * Cp\n\n        max_power = 0.0\n\n        # Generate all combinations of T sites\n        site_indices = range(num_sites)\n        for placement_indices in itertools.combinations(site_indices, T):\n            \n            # 1. Check spacing constraint\n            is_valid_spacing = True\n            if T > 1:\n                for i, j in itertools.combinations(placement_indices, 2):\n                    dist = np.linalg.norm(sites[i] - sites[j])\n                    if dist  s_min:\n                        is_valid_spacing = False\n                        break\n            \n            if not is_valid_spacing:\n                continue\n\n            # 2. Calculate total power for the valid layout\n            total_power = 0.0\n            placement_sites = sites[list(placement_indices)]\n\n            for i in range(T):\n                turbine_i_pos = placement_sites[i]\n                xi, yi = turbine_i_pos[0], turbine_i_pos[1]\n                \n                sum_deficit_sq = 0.0\n                \n                # Consider wake effects from other turbines in the placement\n                for j in range(T):\n                    if i == j:\n                        continue\n                    \n                    turbine_j_pos = placement_sites[j]\n                    xj, yj = turbine_j_pos[0], turbine_j_pos[1]\n\n                    # Check if turbine j is upwind of i\n                    if xj  xi:\n                        d_ji = xi - xj\n                        s_ji = np.abs(yi - yj)\n                        \n                        # Calculate wake radius\n                        r_ji = D / 2.0 + k * d_ji\n                        \n                        # Check if i is in the wake of j\n                        if s_ji = r_ji:\n                            deficit = (2.0 * a) / (1.0 + (2.0 * k * d_ji) / D)**2\n                            sum_deficit_sq += deficit**2\n                \n                # Calculate effective wind speed at turbine i\n                velocity_loss_factor = np.sqrt(sum_deficit_sq)\n                Vi = V0 * (1.0 - velocity_loss_factor)\n                Vi = max(0.0, Vi)\n                \n                # Calculate power from turbine i\n                power_i = power_constant * Vi**3\n                total_power += power_i\n            \n            if total_power > max_power:\n                max_power = total_power\n\n        results.append(int(round(max_power)))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2394774"}]}