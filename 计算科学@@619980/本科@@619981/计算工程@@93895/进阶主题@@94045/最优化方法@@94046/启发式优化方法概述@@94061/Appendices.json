{"hands_on_practices": [{"introduction": "伊辛模型（Ising model）是统计物理学的一个基石，但寻找其基态也是一个经典的NP-难优化问题。本练习旨在探索“能量景观”的概念，并揭示“维度灾难”——即问题规模的增长如何导致可能解的数量发生爆炸性增长。通过使用精确方法（穷举搜索）解决小型网格问题，你将具体地体会到为何启发式方法对于应对大规模复杂优化挑战是不可或缺的 [@problem_id:2399217]。", "problem": "给定一个在具有开放边界条件的 $N\\times M$ 矩形网格上的二维Ising模型。每个格点 $(i,j)$ 上有一个二元自旋 $s_{i,j}\\in\\{-1,+1\\}$。一个自旋构型 $s=\\{s_{i,j}\\}$ 的能量为\n$$\nE(s)\\;=\\;-\\sum_{i=0}^{N-1}\\sum_{j=0}^{M-2} J^{(x)}_{i,j}\\,s_{i,j}\\,s_{i,j+1}\\;-\\;\\sum_{i=0}^{N-2}\\sum_{j=0}^{M-1} J^{(y)}_{i,j}\\,s_{i,j}\\,s_{i+1,j},\n$$\n其中 $J^{(x)}_{i,j}$ 是 $(i,j)$ 和 $(i,j+1)$ 之间键的水平耦合，$J^{(y)}_{i,j}$ 是 $(i,j)$ 和 $(i+1,j)$ 之间键的垂直耦合。数组 $J^{(x)}$ 和 $J^{(y)}$ 分别被指定为 $N\\times (M-1)$ 和 $(N-1)\\times M$ 的实值矩阵。\n\n任务。对于下方的每个测试用例，确定最小能量\n$$\nE_{\\min}\\;=\\;\\min_{s\\in\\{-1,+1\\}^{N\\times M}} E(s).\n$$\n\n约定和要求：\n- 自旋必须被视为 $s_{i,j}\\in\\{-1,+1\\}$。\n- 只有由 $J^{(x)}$ 和 $J^{(y)}$ 明确列出的最近邻相互作用对 $E(s)$ 有贡献（无周期性环绕）。\n- 如果精确最小值为整数，则所有答案必须报告为整数（在提供的测试套件中它们是整数）。\n\n测试套件。使用以下 $4$ 个测试用例。每个用例由 $(N,M,J^{(x)},J^{(y)})$ 给出：\n1. 用例 A（边界条件合理性检查）：\n   - $N=1$，$M=1$，\n   - $J^{(x)}=[\\,]$（形状 $1\\times 0$），$J^{(y)}=[\\,]$（形状 $0\\times 1$）。\n2. 用例 B（$2\\times 2$ 网格上的小的混合耦合）：\n   - $N=2$，$M=2$，\n   - $J^{(x)}=\\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix}$（形状 $2\\times 1$），\n   - $J^{(y)}=\\begin{pmatrix} 1 & 1 \\end{pmatrix}$（形状 $1\\times 2$）。\n3. 用例 C（具有反铁磁性水平方向和铁磁性垂直方向的 $2\\times 3$ 矩形网格）：\n   - $N=2$，$M=3$，\n   - $J^{(x)}=\\begin{pmatrix} -1 & -1 \\\\ -1 & -1 \\end{pmatrix}$（形状 $2\\times 2$），\n   - $J^{(y)}=\\begin{pmatrix} 1 & 1 & 1 \\end{pmatrix}$（形状 $1\\times 3$）。\n4. 用例 D（铁磁性 $3\\times 3$ 网格）：\n   - $N=3$，$M=3$，\n   - $J^{(x)}=\\begin{pmatrix} 1 & 1 \\\\ 1 & 1 \\\\ 1 & 1 \\end{pmatrix}$（形状 $3\\times 2$），\n   - $J^{(y)}=\\begin{pmatrix} 1 & 1 & 1 \\\\ 1 & 1 & 1 \\end{pmatrix}$（形状 $2\\times 3$）。\n\n最终输出格式。您的程序应生成一行输出，其中包含用例 A、B、C 和 D 的最小能量，按此顺序聚合为一个用逗号分隔、方括号括起来且不含空格的列表。例如，所需格式为\n“[eA,eB,eC,eD]”。", "solution": "在尝试求解之前，对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- **模型**：一个在具有开放边界条件的 $N \\times M$ 矩形晶格上的二维Ising模型。\n- **自旋**：位于每个晶格点 $(i,j)$ 的二元变量 $s_{i,j} \\in \\{-1, +1\\}$。\n- **能量函数**：一个构型 $s=\\{s_{i,j}\\}$ 的总能量定义为：\n$$\nE(s) = -\\sum_{i=0}^{N-1}\\sum_{j=0}^{M-2} J^{(x)}_{i,j}\\,s_{i,j}\\,s_{i,j+1} - \\sum_{i=0}^{N-2}\\sum_{j=0}^{M-1} J^{(y)}_{i,j}\\,s_{i,j}\\,s_{i+1,j}\n$$\n- **耦合矩阵**：$J^{(x)}$ 是一个 $N \\times (M-1)$ 的水平耦合矩阵，$J^{(y)}$ 是一个 $(N-1) \\times M$ 的垂直耦合矩阵。\n- **任务**：为四个特定的测试用例确定最小能量 $E_{\\min} = \\min_{s} E(s)$。\n- **测试用例**：\n    1. 用例 A：$N=1, M=1$，$J^{(x)}$ 是 $1 \\times 0$（空），$J^{(y)}$ 是 $0 \\times 1$（空）。\n    2. 用例 B：$N=2, M=2$，$J^{(x)}=\\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix}$，$J^{(y)}=\\begin{pmatrix} 1 & 1 \\end{pmatrix}$。\n    3. 用例 C：$N=2, M=3$，$J^{(x)}=\\begin{pmatrix} -1 & -1 \\\\ -1 & -1 \\end{pmatrix}$，$J^{(y)}=\\begin{pmatrix} 1 & 1 & 1 \\end{pmatrix}$。\n    4. 用例 D：$N=3, M=3$，$J^{(x)}=\\begin{pmatrix} 1 & 1 \\\\ 1 & 1 \\\\ 1 & 1 \\end{pmatrix}$，$J^{(y)}=\\begin{pmatrix} 1 & 1 & 1 \\\\ 1 & 1 & 1 \\end{pmatrix}$。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题是基于Ising模型构建的，这是统计物理学中一个被严谨研究的基本模型。它在科学上是合理的。\n- **良定性**：任务是在一个有限的、离散的自旋构型域上找到一个良定义函数 $E(s)$ 的最小值。对于给定的参数集，最小值保证存在且唯一。\n- **客观性**：该问题使用精确的数学语言描述，不包含任何主观或模棱两可的陈述。\n- **完整性和一致性**：为每个测试用例提供了所有必需的参数（$N$、$M$、$J^{(x)}$、$J^{(y)}$），并且它们的维度与能量公式一致。\n\n该问题是一个标准的基态能量计算，是计算物理学中的一个经典问题。它与启发式优化相关，因为对于大型、阻挫的Ising系统，寻找基态是一个NP难优化问题，通常采用启发式方法来解决。\n\n**步骤 3：结论与行动**\n该问题是有效的。我们继续求解。\n\n任务是找到指定Ising模型的最小能量 $E_{\\min}$。系统的态空间由所有可能的自旋构型 $s = \\{s_{i,j}\\}$ 组成。对于一个大小为 $N \\times M$ 的网格，有 $N \\times M$ 个独立的自旋，每个自旋可以处于 $\\{-1, +1\\}$ 两种状态之一。因此，唯一构型的总数为 $2^{N \\times M}$。\n\n寻找一个通用Ising模型的基态是一个计算困难问题。然而，对于测试套件中给定的小网格尺寸，对整个构型空间进行穷举搜索（暴力搜索）在計算上是可行的。这种方法保证能找到绝对最小能量。每个用例的状态数为：\n- 用例 A：$N=1, M=1 \\implies 2^{1 \\times 1} = 2$ 个状态。\n- 用例 B：$N=2, M=2 \\implies 2^{2 \\times 2} = 16$ 个状态。\n- 用例 C：$N=2, M=3 \\implies 2^{2 \\times 3} = 64$ 个状态。\n- 用例 D：$N=3, M=3 \\implies 2^{3 \\times 3} = 512$ 个状态。\n\n寻找 $E_{\\min}$ 的算法如下：\n1. 对于由 $(N, M, J^{(x)}, J^{(y)})$ 定义的每个测试用例，将变量 `min_energy` 初始化为一个非常大的值（无穷大）。\n2. 生成 $N \\times M$ 网格的每一种可能的自旋构型。每种构型都是一个 $N \\times M$ 的自旋值矩阵。\n3. 对于每种构型，使用提供的公式计算其总能量 $E(s)$：对所有相邻自旋对的相互作用能量 $-J \\cdot s \\cdot s'$ 求和。\n4. 将计算出的能量 $E(s)$ 与 `min_energy` 进行比较。如果 $E(s)$ 更小，则将 `min_energy` 更新为此新值。\n5. 在遍历所有 $2^{N \\times M}$ 种构型后，`min_energy` 的最终值即为基态能量 $E_{\\min}$。\n\n为了说明，考虑用例 D，即所有 $J$ 值均为 $1$ 的铁磁性 $3 \\times 3$ 网格。其能量为 $E(s) = -\\sum_{\\langle k,l \\rangle} s_k s_l$，其中求和遍历所有最近邻对。为了最小化 $E(s)$，每个乘积 $s_k s_l$ 都必须最大化，即 $s_k s_l = +1$。如果所有相邻自旋都对齐，则此条件得到满足。一个所有自旋都相同（全部为 $+1$ 或全部为 $-1$）的全局构型可以同时满足每个键的这个条件。该网格有 $3 \\times 2 = 6$ 个水平键和 $3 \\times 2 = 6$ 个垂直键，总共有 $12$ 个键。因此最小能量为 $E_{\\min} = -12 \\times (1) = -12$。\n\n对于涉及阻挫（竞争性相互作用）的用例，如用例 B，或像用例 C 那样的混合相互作用，简单的检视是不够的。需要进行穷举搜索来找到真实的能量最小值。提供的最终答案为所有用例实现了这种穷举搜索。", "answer": "```python\nimport numpy as np\nimport itertools\n\ndef find_min_energy(N, M, Jx, Jy):\n    \"\"\"\n    Finds the minimum energy of an Ising model on an N x M grid\n    by performing an exhaustive search over all spin configurations.\n    \"\"\"\n    num_spins = N * M\n    if num_spins == 0:\n        # For N or M being 0, or Case A with N=1, M=1 and empty J matrices,\n        # the energy sums are empty, so the energy is 0.\n        # The loop logic below correctly handles N=1, M=1, but this check\n        # handles more general zero-size cases.\n        return 0\n\n    min_energy = float('inf')\n    spin_values = [-1, 1]\n\n    # Iterate through all 2^(N*M) possible spin configurations.\n    # itertools.product generates the Cartesian product of input iterables.\n    # repeat=num_spins is equivalent to product(spin_values, ..., spin_values).\n    for flat_s in itertools.product(spin_values, repeat=num_spins):\n        s_grid = np.array(flat_s).reshape((N, M))\n        \n        current_energy = 0.0\n\n        # Calculate energy from horizontal interactions\n        if M > 1:\n            for i in range(N):\n                for j in range(M - 1):\n                    current_energy -= Jx[i, j] * s_grid[i, j] * s_grid[i, j + 1]\n\n        # Calculate energy from vertical interactions\n        if N > 1:\n            for i in range(N - 1):\n                for j in range(M):\n                    current_energy -= Jy[i, j] * s_grid[i, j] * s_grid[i + 1, j]\n        \n        if current_energy < min_energy:\n            min_energy = current_energy\n            \n    # The problem statement guarantees integer results\n    return int(min_energy)\n\ndef solve():\n    \"\"\"\n    Defines the test cases and computes the minimum energy for each,\n    then prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"N\": 1, \"M\": 1,\n            \"Jx\": np.empty((1, 0)),\n            \"Jy\": np.empty((0, 1))\n        },\n        {\n            \"name\": \"Case B\",\n            \"N\": 2, \"M\": 2,\n            \"Jx\": np.array([[1], [-1]]),\n            \"Jy\": np.array([[1, 1]])\n        },\n        {\n            \"name\": \"Case C\",\n            \"N\": 2, \"M\": 3,\n            \"Jx\": np.array([[-1, -1], [-1, -1]]),\n            \"Jy\": np.array([[1, 1, 1]])\n        },\n        {\n            \"name\": \"Case D\",\n            \"N\": 3, \"M\": 3,\n            \"Jx\": np.array([[1, 1], [1, 1], [1, 1]]),\n            \"Jy\": np.array([[1, 1, 1], [1, 1, 1]])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        min_e = find_min_energy(case[\"N\"], case[\"M\"], case[\"Jx\"], case[\"Jy\"])\n        results.append(min_e)\n\n    # Print the final result in the exact format \"[eA,eB,eC,eD]\"\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2399217"}, {"introduction": "遗传算法（Genetic Algorithms, GAs）在演化过程中常常产生违反问题约束的解。一个“修复算子”（repair operator）是修正这些不可行解的巧妙机制，对于保证算法的有效性至关重要。本实践将深入探讨约束处理，这是将启发式方法应用于集合覆盖问题等现实世界难题的一个关键方面。你将学会评估不同的修复策略，在实现可行性与寻找低成本解的目标之间进行权衡，这是启发式算法设计中的一项核心技能 [@problem_id:2399283]。", "problem": "在经典的集合覆盖问题中，给定一个有限基集 $U = \\{1,2,\\dots,m\\}$ 和一个子集族 $\\{S_j \\subseteq U\\}_{j=1}^n$，每个子集都带有正成本 $\\{c_j\\}_{j=1}^n$。一个二元决策向量 $x \\in \\{0,1\\}^n$ 代表一个子集的选择，其中 $x_j = 1$ 表示子集 $S_j$ 被选中。可行性要求基集 $U$ 中的每个元素 $i$ 都至少被一个选中的子集覆盖，即对于所有 $i \\in U$，满足 $\\sum_{j : i \\in S_j} x_j \\ge 1$。目标是在满足可行性的前提下，最小化 $\\sum_{j=1}^n c_j x_j$。假设 $\\bigcup_{j=1}^n S_j = U$，以确保至少存在一个可行解。\n\n遗传算法 (GA) 维护一个由染色体 $x \\in \\{0,1\\}^n$ 组成的种群。交叉和变异操作可能会产生不可行的后代，这些后代违反了一个或多个覆盖约束。在进行评估之前，会应用一个修复算子，将不可行的染色体映射为一个可行的染色体。\n\n考虑一个具体实例，其中 $U = \\{1,2,3,4,5\\}$，子集和成本如下：\n- $S_1 = \\{1,2\\}$，成本 $c_1 = 3$，\n- $S_2 = \\{2,3,4\\}$，成本 $c_2 = 4$，\n- $S_3 = \\{3,5\\}$，成本 $c_3 = 2$，\n- $S_4 = \\{1,4,5\\}$，成本 $c_4 = 5$，\n- $S_5 = \\{2,5\\}$，成本 $c_5 = 2$，\n以及一个不可行的后代染色体 $x = (x_1,x_2,x_3,x_4,x_5) = (1,0,0,0,1)$，它只选择了子集 $S_1$ 和 $S_5$。当前已覆盖的集合是 $S_1 \\cup S_5 = \\{1,2,5\\}$；元素 $\\{3,4\\}$ 未被覆盖。\n\n要求您选择一个修复算子，该算子基于第一性原理（可行性与覆盖的定义）具有合理的论证，并且在成本考量与保证达到可行性之间取得平衡。\n\n下列哪一种修复机制同时满足：\n(i) 保证在每个添加步骤中，未覆盖元素的数量严格减少（因此最多在 $|U|$ 次添加后终止），并且绝不接受会破坏可行性的移除操作，以及\n(ii) 应用于给定实例和染色体 $x$ 时，能在所列机制中得到最低的总成本？\n\nA. 基于单位成本覆盖未覆盖元素的贪心法，并带有冗余消除：\n- 当存在未覆盖元素时，选择一个满足 $x_j=0$ 的索引 $j \\in \\{1,\\dots,5\\}$，使得比率 $c_j / |\\;S_j \\cap \\text{Uncovered}\\;|$, 最小，其中 $\\text{Uncovered} \\subseteq U$ 是当前的未覆盖元素集（若比率相同，则选择 $|\\;S_j \\cap \\text{Uncovered}\\;|$ 更大者）。设置 $x_j \\leftarrow 1$ 并更新 $\\text{Uncovered}$。\n- 达到可行性后，尝试消除冗余：按 $c_j / |S_j|$ 的非增序考虑已选择的集合，当且仅当保持可行性时，设置 $x_j \\leftarrow 0$；当没有可移除的集合时停止。\n\nB. 优先添加成本最低的集合，不考虑边际未覆盖覆盖度：\n- 当解不可行时，重复选择尚未选中的最便宜的集合（即 $x_j=0$ 的 $j$ 中 $c_j$ 最小的），设置 $x_j \\leftarrow 1$，一旦达到可行性即停止；不移除任何集合。\n\nC. 重叠最大化添加法：\n- 当解不可行时，重复选择能够最大化 $|\\;S_j \\cap (\\bigcup_{k : x_k = 1} S_k)\\;|$ 的未选集合 $S_j$（若存在相同值，则选择 $c_j$ 最小的），设置 $x_j \\leftarrow 1$，一旦达到可行性即停止；不移除任何集合。\n\nD. 仅罚分处理法：\n- 不改变 $x$；而是在适应度评估时，为目标函数增加一个大的加性惩罚项 $\\rho \\cdot |\\text{Uncovered}|$，其中 $\\rho \\gg \\max_j c_j$。\n\n请根据上述基本定义，而不是任何未说明的启发式方法或外部公式，选择同时满足 (i) 和 (ii) 的唯一最佳选项。只提供一个答案选项。", "solution": "问题陈述已经过验证，是自洽的、有科学依据且定义明确的。我们可以开始求解。\n\n该问题要求我们评估四种用于解决集合覆盖问题特定实例的遗传算法修复机制。目标是找出满足以下两个条件的机制：\n(i) 它通过在每个添加步骤中严格减少未覆盖元素的数量，并在任何移除步骤中保持可行性，来保证收敛到一个可行解。\n(ii) 对于给定的实例，它生成的修复解在四种机制中总成本最低。\n\n该具体实例如下定义：\n- 基集 $U = \\{1, 2, 3, 4, 5\\}$。\n- 子集和成本：\n  - $S_1 = \\{1, 2\\}$，成本 $c_1 = 3$。\n  - $S_2 = \\{2, 3, 4\\}$，成本 $c_2 = 4$。\n  - $S_3 = \\{3, 5\\}$，成本 $c_3 = 2$。\n  - $S_4 = \\{1, 4, 5\\}$，成本 $c_4 = 5$。\n  - $S_5 = \\{2, 5\\}$，成本 $c_5 = 2$。\n- 初始的不可行染色体是 $x = (1, 0, 0, 0, 1)$。这对应于选择集合 $S_1$ 和 $S_5$。\n\n初始状态如下：\n- 已选集合：$\\{S_1, S_5\\}$。\n- 初始成本：$c_1 + c_5 = 3 + 2 = 5$。\n- 已覆盖集合：$C_0 = S_1 \\cup S_5 = \\{1, 2\\} \\cup \\{2, 5\\} = \\{1, 2, 5\\}$。\n- 未覆盖集合：$\\text{Uncovered}_0 = U \\setminus C_0 = \\{3, 4\\}$。\n\n我们现在逐一分析每个选项。\n\n**A. 基于单位成本覆盖未覆盖元素的贪心法，并带有冗余消除**\n\n首先，我们评估条件 (i)。添加阶段选择一个集合 $S_j$ 使比率 $c_j / |S_j \\cap \\text{Uncovered}|$ 最小化。由于所有成本 $c_j$ 都是正数，为了使该比率有限且最小，分母 $|S_j \\cap \\text{Uncovered}|$ 必须是正整数。这意味着任何添加的集合 $S_j$ 必须至少覆盖一个当前未覆盖的元素，从而严格减少未覆盖元素的数量。移除阶段被明确约束为必须保持可行性。因此，条件 (i) 得到满足。\n\n接下来，我们将此机制应用于该实例。\n1.  **添加阶段：** 初始的未覆盖元素集是 $\\text{Uncovered}_0 = \\{3, 4\\}$。我们必须从 $\\{S_2, S_3, S_4\\}$ (即那些 $x_j=0$ 的集合) 中选择一个集合来添加。我们为每个集合计算选择度量 $c_j / |S_j \\cap \\text{Uncovered}_0|$：\n    - $S_2$：$c_2 = 4$，$S_2 \\cap \\{3, 4\\} = \\{3, 4\\}$，所以 $|S_2 \\cap \\{3, 4\\}| = 2$。比率为 $4/2 = 2$。\n    - $S_3$：$c_3 = 2$，$S_3 \\cap \\{3, 4\\} = \\{3\\}$，所以 $|S_3 \\cap \\{3, 4\\}| = 1$。比率为 $2/1 = 2$。\n    - $S_4$：$c_4 = 5$，$S_4 \\cap \\{3, 4\\} = \\{4\\}$，所以 $|S_4 \\cap \\{3, 4\\}| = 1$。比率为 $5/1 = 5$。\n    $S_2$ 和 $S_3$ 的最小比率均为 $2$，出现了平局。平局打破规则是选择 $|\\;S_j \\cap \\text{Uncovered}\\;|$ 值较大者。对于 $S_2$，该值为 $2$，对于 $S_3$，该值为 $1$。因此，我们选择 $S_2$。\n    我们设置 $x_2 \\leftarrow 1$。新的已选子集集合为 $\\{S_1, S_2, S_5\\}$。已覆盖集合为 $S_1 \\cup S_2 \\cup S_5 = \\{1, 2\\} \\cup \\{2, 3, 4\\} \\cup \\{2, 5\\} = \\{1, 2, 3, 4, 5\\} = U$。解现已可行。\n\n2.  **冗余消除阶段：** 当前解为 $x=(1, 1, 0, 0, 1)$，选择了 $\\{S_1, S_2, S_5\\}$。总成本为 $c_1 + c_2 + c_5 = 3 + 4 + 2 = 9$。我们按 $c_j/|S_j|$ 的非增序考虑移除集合：\n    - $S_1$：$c_1/|S_1| = 3/2 = 1.5$。\n    - $S_2$：$c_2/|S_2| = 4/3 \\approx 1.33$。\n    - $S_5$：$c_5/|S_5| = 2/2 = 1$。\n    考虑的顺序是 $S_1, S_2, S_5$。\n    - 尝试移除 $S_1$：剩下的集合 $\\{S_2, S_5\\}$ 覆盖 $S_2 \\cup S_5 = \\{2, 3, 4, 5\\}$。元素 $1$ 变为未覆盖。移除被拒绝。\n    - 尝试移除 $S_2$：剩下的集合 $\\{S_1, S_5\\}$ 覆盖 $S_1 \\cup S_5 = \\{1, 2, 5\\}$。元素 $3$ 和 $4$ 变为未覆盖。移除被拒绝。\n    - 尝试移除 $S_5$：剩下的集合 $\\{S_1, S_2\\}$ 覆盖 $S_1 \\cup S_2 = \\{1, 2, 3, 4\\}$。元素 $5$ 变为未覆盖。移除被拒绝。\n    没有集合可以被移除。最终的修复解是 $x = (1, 1, 0, 0, 1)$，总成本为 $9$。\n\n对 A 的结论：该机制满足条件 (i)。对于给定实例，它产生一个总成本为 $9$ 的可行解。\n\n**B. 优先添加成本最低的集合，不考虑边际未覆盖覆盖度**\n\n首先，我们评估条件 (i)。该机制添加最便宜的可用集合，而不管它是否覆盖任何当前未覆盖的元素。最便宜的集合 $S_j$ 有可能已经是被覆盖集合的子集（$S_j \\subseteq \\bigcup_{k:x_k=1} S_k$）。在这种情况下，添加 $S_j$ 不会减少未覆盖元素的数量。因此，该机制不保证每一步都严格减少。条件 (i) 被违反。\n\n接下来，我们将此机制应用于该实例。\n1.  **添加阶段：** 未覆盖集合为 $\\{3, 4\\}$。可供添加的集合为 $\\{S_2, S_3, S_4\\}$，成本分别为 $c_2 = 4, c_3 = 2, c_4 = 5$。最便宜的是 $S_3$。我们添加 $S_3$。\n    已选集合现在是 $\\{S_1, S_3, S_5\\}$。已覆盖集合是 $S_1 \\cup S_3 \\cup S_5 = \\{1, 2, 3, 5\\}$。未覆盖集合是 $\\{4\\}$。解仍然不可行。\n2.  我们重复该过程。可供添加的集合为 $\\{S_2, S_4\\}$，成本分别为 $c_2 = 4, c_4 = 5$。最便宜的是 $S_2$。我们添加 $S_2$。\n    已选集合现在是 $\\{S_1, S_2, S_3, S_5\\}$。已覆盖集合是 $S_1 \\cup S_2 \\cup S_3 \\cup S_5 = \\{1, 2, 3, 4, 5\\} = U$。解是可行的。\n机制停止。没有移除阶段。最终解为 $x = (1, 1, 1, 0, 1)$。\n总成本为 $c_1 + c_2 + c_3 + c_5 = 3 + 4 + 2 + 2 = 11$。\n\n对 B 的结论：该机制违反条件 (i)。对于给定实例，它产生一个总成本为 $11$ 的可行解。\n\n**C. 重叠最大化添加法**\n\n首先，我们评估条件 (i)。该机制添加与*当前已覆盖*元素重叠最大的集合。其目标是增强现有覆盖，而不一定是覆盖新元素。具有最大重叠的集合 $S_j$ 可能不覆盖任何新元素（$S_j \\cap \\text{Uncovered} = \\emptyset$）。在这种情况下，未覆盖元素的数量不会减少。因此，该机制不保证每一步都严格减少。条件 (i) 被违反。\n\n接下来，我们将此机制应用于该实例。\n1.  **添加阶段：** 初始已覆盖集合为 $K_0 = \\{1, 2, 5\\}$，未覆盖集合为 $\\{3, 4\\}$。我们从 $\\{S_2, S_3, S_4\\}$ 中根据最大化 $|S_j \\cap K_0|$ 的原则进行选择。\n    - $S_2$：$|S_2 \\cap K_0| = |\\{2, 3, 4\\} \\cap \\{1, 2, 5\\}| = |\\{2\\}| = 1$。\n    - $S_3$：$|S_3 \\cap K_0| = |\\{3, 5\\} \\cap \\{1, 2, 5\\}| = |\\{5\\}| = 1$。\n    - $S_4$：$|S_4 \\cap K_0| = |\\{1, 4, 5\\} \\cap \\{1, 2, 5\\}| = |\\{1, 5\\}| = 2$。\n    $S_4$ 具有最大重叠。我们添加 $S_4$。已选集合现在是 $\\{S_1, S_4, S_5\\}$，已覆盖集合是 $K_1 = S_1 \\cup S_4 \\cup S_5 = \\{1, 2, 4, 5\\}$。未覆盖集合是 $\\{3\\}$。解仍然不可行。\n2.  我们重复该过程。当前已覆盖集合是 $K_1 = \\{1, 2, 4, 5\\}$。可供添加的集合为 $\\{S_2, S_3\\}$。\n    - $S_2$：$|S_2 \\cap K_1| = |\\{2, 3, 4\\} \\cap \\{1, 2, 4, 5\\}| = |\\{2, 4\\}| = 2$。\n    - $S_3$：$|S_3 \\cap K_1| = |\\{3, 5\\} \\cap \\{1, 2, 4, 5\\}| = |\\{5\\}| = 1$。\n    $S_2$ 具有最大重叠。我们添加 $S_2$。已选集合现在是 $\\{S_1, S_2, S_4, S_5\\}$，已覆盖集合是 $S_1 \\cup S_2 \\cup S_4 \\cup S_5 = \\{1, 2, 3, 4, 5\\} = U$。解是可行的。\n没有移除阶段。最终解为 $x = (1, 1, 0, 1, 1)$。\n总成本为 $c_1 + c_2 + c_4 + c_5 = 3 + 4 + 5 + 2 = 14$。\n\n对 C 的结论：该机制违反条件 (i)。对于给定实例，它产生一个总成本为 $14$ 的可行解。\n\n**D. 仅罚分处理法**\n\n该机制不改变染色体。它只是在评估时向目标函数添加一个惩罚项。问题将修复算子定义为一个“将不可行染色体映射为可行染色体”的过程。该机制没有做到这一点。它不包含任何“添加步骤”，因此不能满足条件 (i) 中的保证。它在实现可行性方面没有任何进展。因此，它不是问题所要求意义上的修复算子，故不满足条件 (i)。\n\n此外，由于它不产生可行解，其在集合覆盖目标 $\\sum c_j x_j$下的成本无法与其他产生可行解的机制相比较。可以认为其有效成本是无限的。在任何情况下，它都不可能得到最低的总成本。其受惩罚的成本将是 $5 + 2\\rho$，根据定义这是一个非常大的值。所以它也不满足条件 (ii)。\n\n对 D 的结论：该机制违反条件 (i)，因为它没有将不可行解映射为可行解。它也违反了条件 (ii)。\n\n**结论**\n\n我们总结一下结果：\n- **机制 A：** 满足条件 (i)。产生一个成本为 $9$ 的可行解。\n- **机制 B：** 违反条件 (i)。产生一个成本为 $11$ 的可行解。\n- **机制 C：** 违反条件 (i)。产生一个成本为 $14$ 的可行解。\n- **机制 D：** 违反条件 (i)，且不产生可行解。\n\n只有机制 A 满足条件 (i)。\n对于条件 (ii)，我们比较各机制产生的解的成本：成本(A) = $9$，成本(B) = $11$，成本(C) = $14$。其中最低成本是 $9$，由机制 A 实现。由于机制 D 不产生有效的、有限成本的可行解，因此它不参与最低成本的竞争。\n因此，机制 A 是唯一同时满足条件 (i) 和 (ii) 的选项。", "answer": "$$\\boxed{A}$$", "id": "2399283"}, {"introduction": "粒子群优化（Particle Swarm Optimization, PSO）算法天然适用于连续空间，但许多现实世界的问题本质上是离散的。这项挑战的核心任务是，如何将一个为连续空间设计的算法改编至离散且带约束的搜索空间，这是计算工程中的一项常见工作。通过比较不同的改编方法，你将理解遵循原则性方法的重要性——这种方法能够保留启发式算法的核心逻辑，以确保改编后的算法既有效又合理 [@problem_id:2399268]。", "problem": "要求您将粒子群优化（PSO）算法应用于一个离散整数规划问题。考虑一个决策向量为 $x \\in \\mathbb{Z}^d$ 的约束优化问题：\n最小化 $f(x)$，约束条件为对所有 $j \\in \\{1,\\dots,d\\}$ 有 $0 \\le x_j \\le 5$，且 $\\sum_{j=1}^d x_j = 12$。在连续形式中，一个标准的PSO算法为每个粒子 $i$ 维护一个位置 $x_i^t \\in \\mathbb{R}^d$ 和一个速度 $v_i^t \\in \\mathbb{R}^d$，其更新公式如下：\n$$\nv_i^{t+1} = \\omega\\, v_i^{t} + c_1\\, r_{1}^{t} \\odot \\big(p_i^{t} - x_i^{t}\\big) + c_2\\, r_{2}^{t} \\odot \\big(g^{t} - x_i^{t}\\big), \\quad\nx_i^{t+1} = x_i^{t} + v_i^{t+1},\n$$\n其中 $\\omega, c_1, c_2 \\in \\mathbb{R}$ 是参数，$r_1^{t}, r_2^{t} \\in [0,1]^d$ 是按分量采样的随机向量，$\\odot$ 表示逐分量相乘，$p_i^{t}$ 是粒子 $i$ 的个体最佳位置，$g^{t}$ 是全局最佳位置。您的目标是调整这些更新规则，使得在每次迭代之后，每个粒子的位置都是一个满足箱形约束和总和约束的整数向量。下列哪种策略能产生一个适定的调整方案，既能确保每个更新后的位置都位于可行集 $X = \\{x \\in \\mathbb{Z}^d: 0 \\le x_j \\le 5,\\ \\sum_{j=1}^d x_j = 12\\}$ 内，又能保留“离散更新是连续吸引步骤的最近可行对应体”这一解释？请选择所有适用项。\n\nA. 在计算出连续候选解 $y_i^{t+1} = x_i^{t} + v_i^{t+1}$ 后，将其每个分量四舍五入到最近的整数，并裁剪到 $[0,5]$ 范围内。如果总和约束 $\\sum_{j=1}^d x_{i,j}^{t+1} = 12$ 被违反，则重复随机选取一对不同的索引 $(j,k)$，并将 $x_{i,j}^{t+1}$ 调整+1、$x_{i,k}^{t+1}$ 调整-1（或根据差值的符号反向调整），同时遵守边界条件，直到总和等于12。\n\nB. 用 $\\{0,1\\}^d$ 中的二进制向量替换实数值位置，并通过 sigmoid 映射将每个速度分量解释为翻转概率。根据这些概率独立地翻转比特位来进行更新。如果 $\\sum_{j=1}^d x_{i,j}^{t+1} \\ne 12$，则重复重新采样翻转操作，直到等式成立。\n\nC. 通过将标准PSO速度方程的右侧四舍五入到最近的整数来定义一个整数值的“速度”。通过 $x_i^{t+1} = x_i^{t} + v_i^{t+1}$ 逐分量更新位置，然后对每个分量取模6以强制 $0 \\le x_{i,j}^{t+1} \\le 5$。在更新过程中忽略总和约束。\n\nD. 将 $x$ 编码为 $\\{1,\\dots,d\\}$ 的一个排列，并将速度表示为一个交换序列，该序列将一个排列移向其个体和全局最佳排列。在应用一个组合的交换序列来更新粒子后，通过“缩放”该排列以满足 $\\sum_{j=1}^d x_j = 12$ 并裁剪到 $[0,5]$ 范围内，从而解码回一个整数向量。\n\nE. 在计算出连续候选解 $y_i^{t+1} = x_i^{t} + v_i^{t+1}$ 后，通过求解以下问题将其映射到一个可行的整数向量：\n$$\n\\min_{z \\in \\mathbb{Z}^d} \\ \\|z - y_i^{t+1}\\|_2 \\quad \\text{subject to} \\quad 0 \\le z_j \\le 5,\\ \\sum_{j=1}^d z_j = 12,\n$$\n该问题可通过以下方式高效实现：首先将 $y_i^{t+1}$ 四舍五入到最近的整数，然后通过将总和的差值分配到具有最大（绝对值）小数部分的那些分量上（同时遵守边界条件），来调整舍入后的向量，使得最终的 $z$ 的总和为12，并（在欧几里得范数下）尽可能地接近 $y_i^{t+1}$。", "solution": "首先必须确立问题陈述的有效性。\n\n### 步骤1：提取已知条件\n- 这是一个关于函数 $f(x)$ 的约束优化问题，其决策向量为 $x \\in \\mathbb{Z}^d$。\n- 可行集 $X$ 由两类约束定义：\n    1. 箱形约束：对所有 $j \\in \\{1,\\dots,d\\}$，有 $0 \\le x_j \\le 5$。\n    2. 一个线性等式约束（总和约束）：$\\sum_{j=1}^d x_j = 12$。\n- 任务是为这个离散域调整标准的连续粒子群优化（PSO）算法。\n- 给出了在时间步 $t$ 对粒子 $i$ 的标准连续PSO更新方程：\n$$\nv_i^{t+1} = \\omega\\, v_i^{t} + c_1\\, r_{1}^{t} \\odot \\big(p_i^{t} - x_i^{t}\\big) + c_2\\, r_{2}^{t} \\odot \\big(g^{t} - x_i^{t}\\big)\n$$\n$$\nx_i^{t+1} = x_i^{t} + v_i^{t+1}\n$$\n- 该调整必须满足两个条件：\n    1. 更新后的位置必须始终属于可行集 $X = \\{x \\in \\mathbb{Z}^d: 0 \\le x_j \\le 5, \\sum_{j=1}^d x_j = 12\\}$。\n    2. 该调整必须保留“离散更新是连续吸引步骤的‘最近可行对应体’”这一解释。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据：** 该问题牢固地植根于计算工程和启发式优化领域。将像PSO这样的连续元启发式算法应用于离散或约束问题是一个标准且重要的研究课题。问题表述使用了已确立的数学概念和一个著名算法。这些约束定义了一个有效的整数规划可行域。该问题具有科学合理性。\n- **适定性：** 问题提供了所有必要的信息。它清晰地定义了搜索空间、待调整的更新规则以及成功调整的标准（可行性和“最近对应体”）。“最近可行对应体”一词通过与连续吸引步骤相关联而被赋予了清晰的上下文，这明确地指向了距离最小化原则。问题的结构决定了选项中存在一组唯一的正确答案。\n- **客观性：** 语言精确且专业。评估标准是客观的，并且可以使用数学和算法推理进行评估。\n\n### 步骤3：结论与行动\n问题陈述是有效的。它具有科学依据、适定性且客观。我现在将通过评估每个选项来解决问题。\n\n问题的核心是将一个连续候选解 $y_i^{t+1} = x_i^{t} + v_i^{t+1}$ 映射到点 $z \\in X$，该点既可行又在概念上“接近”$y_i^{t+1}$。“最近可行对应体”这一标准最严谨的解释是找到一个向量 $z$，在满足 $z \\in X$ 的条件下，最小化与 $y_i^{t+1}$ 之间的某个距离度量。对此，标准的选择是欧几里得距离（或其平方），这引出了投影问题：$\\min_{z \\in X} \\|z - y_i^{t+1}\\|_2^2$。\n\n### 逐项分析\n\n**选项 A:**\n该策略首先通过四舍五入和裁剪创建一个中间整数向量，这强制满足了箱形约束 $0 \\le x_j \\le 5$ 和整数要求。然而，它接着试图通过一系列随机调整来满足总和约束 $\\sum x_j = 12$。具体来说，它随机选择索引对 $(j,k)$ 并应用形如 $(x_j, x_k) \\to (x_j+1, x_k-1)$ 或 $(x_j-1, x_k+1)$ 的更新。虽然这种修复机制最终将强制满足总和约束并维持箱形约束，但调整的随机性是其致命缺陷。通过随机选择索引，该过程并未试图最小化与原始连续候选解 $y_i^{t+1}$ 的偏差。最终的向量可能与真正的“最近”可行点任意远，这取决于随机选择的序列。这违反了保留“最近可行对应体”解释的原则。这个过程是临时的、非原则性的。\n**结论：不正确。**\n\n**选项 B:**\n这个策略存在根本性缺陷，因为它重新定义了问题。原始问题指定了整数变量 $x_j \\in \\{0, 1, 2, 3, 4, 5\\}$。该选项建议使用二进制向量 $x_j \\in \\{0, 1\\}$，这是一个不同的搜索空间。它用一个二进制规划问题替换了整数规划问题。此外，它提出了一种“拒绝采样”方法（“重复重新采样翻转操作”）来满足总和约束，这种方法计算效率低下，且不能保证在合理时间内终止。这不是对给定问题的有效调整。\n**结论：不正确。**\n\n**选项 C:**\n该策略在两方面失败了。首先，它明确指出要“忽略总和约束”。这意味着得到的粒子位置 $x_i^{t+1}$ 不能保证在可行集 $X$ 内，违反了调整的一个主要要求。其次，它使用取模运算符 $x_{i,j}^{t+1} \\pmod 6$ 来强制执行箱形约束。取模运算符会产生“环绕”效应。例如，值6变为0，值-1变为5。这不等同于在区间 $[0,5]$ 中寻找最近的整数。对此的标准操作是裁剪，即 $\\max(0, \\min(5, x_j))$。环绕行为与PSO的吸引原则不一致，在吸引原则中，大的速度应该将粒子移动到搜索空间的边界，而不是将其传送到另一侧。\n**结论：不正确。**\n\n**选项 D:**\n该策略建议将整数向量 $x$ 编码为一个排列。这是一种适用于组合优化问题的技术，其解是元素的排序，例如旅行商问题或调度问题。当前的问题是一个整数规划问题，而不是一个基于排列的问题。在此处使用排列编码是不自然的，并将问题强行纳入一个并非为其设计的框架中。此外，描述是模糊的，提到了用“交换序列”表示速度和“缩放”排列以解码回整数向量。这不是对给定的基于向量的PSO更新规则的直接调整，并且完全放弃了粒子在 $d$ 维空间中移动的几何解释。它未能保留“连续吸引步骤”的概念。\n**结论：不正确。**\n\n**选项 E:**\n该策略提供了最严谨和最符合原则的方法。它通过将“最近可行对应体”的概念定义为一个最小化问题的解来使其形式化：在可行集 $X$ 中找到一个点 $z$，该点最小化到连续候选解 $y_i^{t+1}$ 的欧几里得距离。这正是将 $y_i^{t+1}$ 投影到可行集 $X$ 上。这通过构造保证了更新后的粒子位置是可行的，并且是与连续PSO动态本应将其放置的位置最接近的可行点。该选项接着描述了一个著名且高效的贪心算法来解决这个特定的投影问题：首先四舍五入到最近的整数，然后通过在每一步中对引起平方欧几里得距离增量最小的分量加1或减1，来迭代地调整分量以满足总和约束。这对应于根据它们的小数部分，或者更准确地说，根据舍入值与原始连续值之间的差异来调整分量。该策略是适定的，保证了可行性，并完美地符合“最近对应体”原则。\n**结论：正确。**", "answer": "$$\\boxed{E}$$", "id": "2399268"}]}