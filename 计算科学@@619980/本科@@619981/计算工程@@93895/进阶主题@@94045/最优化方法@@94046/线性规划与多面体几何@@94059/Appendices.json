{"hands_on_practices": [{"introduction": "如何在一个给定的多边形区域内找到最“安全”或最“中心”的点？这个练习将挑战你将一个纯粹的几何问题——寻找一个多面体内可以容纳的最大的球——转化为一个线性规划问题。通过掌握此方法，你将学习如何用代数方式对几何约束进行建模，这是从机器人学到设施选址等领域的一项基本技能 [@problem_id:2410361]。", "problem": "考虑由下列联立线性不等式定义的$\\mathbb{R}^{2}$中的多面体$P$\n$$\n-x \\leq 0,\\quad -y \\leq 0,\\quad x \\leq 4,\\quad y \\leq 3,\\quad x + y \\leq 5.\n$$\n一个以$c \\in \\mathbb{R}^{2}$为中心、半径为$r \\geq 0$的$\\mathbb{R}^{2}$中的欧几里得球是集合$B(c,r) = \\{ z \\in \\mathbb{R}^{2} : \\| z - c \\|_{2} \\leq r \\}$。确定完全包含在$P$中的任意欧几里得球的最大半径$r^{\\star}$。将您的最终答案表示为单个精确的解析表达式（不要四舍五入）。", "solution": "问题是要找到一个欧几里得球$B(c, r)$的最大半径$r^{\\star}$，使得$B(c, r) \\subseteq P$。多面体$P$是五个闭半平面的交集。设这些半平面为$H_i = \\{ z \\in \\mathbb{R}^2 : a_i^T z \\leq b_i \\}$，其中$i=1, \\dots, 5$。\n定义不等式可以写成$a_i^T z \\leq b_i$的形式，其中$z = \\begin{pmatrix} x \\\\ y \\end{pmatrix}$：\n1. $H_1$: $-x \\leq 0 \\implies \\begin{pmatrix} -1 & 0 \\end{pmatrix} z \\leq 0$。所以，$a_1 = \\begin{pmatrix} -1 \\\\ 0 \\end{pmatrix}$, $b_1 = 0$。\n2. $H_2$: $-y \\leq 0 \\implies \\begin{pmatrix} 0 & -1 \\end{pmatrix} z \\leq 0$。所以，$a_2 = \\begin{pmatrix} 0 \\\\ -1 \\end{pmatrix}$, $b_2 = 0$。\n3. $H_3$: $x \\leq 4 \\implies \\begin{pmatrix} 1 & 0 \\end{pmatrix} z \\leq 4$。所以，$a_3 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$, $b_3 = 4$。\n4. $H_4$: $y \\leq 3 \\implies \\begin{pmatrix} 0 & 1 \\end{pmatrix} z \\leq 3$。所以，$a_4 = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$, $b_4 = 3$。\n5. $H_5$: $x+y \\leq 5 \\implies \\begin{pmatrix} 1 & 1 \\end{pmatrix} z \\leq 5$。所以，$a_5 = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$, $b_5 = 5$。\n\n一个球$B(c, r)$被包含在半平面$a^T z \\leq b$中，当且仅当其中心$c$位于该半平面内，且从$c$到边界超平面$a^T z = b$的距离至少为$r$。这个条件表示为$a^T c + r \\|a\\|_2 \\leq b$。\n\n为了确保$B(c, r) \\subseteq P$，这个条件必须对所有五个不等式都成立。设$c = \\begin{pmatrix} c_x \\\\ c_y \\end{pmatrix}$。我们首先计算向量$a_i$的欧几里得范数：\n$\\|a_1\\|_2 = \\| \\begin{pmatrix} -1 \\\\ 0 \\end{pmatrix} \\|_2 = 1$。\n$\\|a_2\\|_2 = \\| \\begin{pmatrix} 0 \\\\ -1 \\end{pmatrix} \\|_2 = 1$。\n$\\|a_3\\|_2 = \\| \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\|_2 = 1$。\n$\\|a_4\\|_2 = \\| \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} \\|_2 = 1$。\n$\\|a_5\\|_2 = \\| \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} \\|_2 = \\sqrt{1^2 + 1^2} = \\sqrt{2}$。\n\n球体被包含在$P$中的条件变成了一个关于$c_x$、$c_y$和$r$的不等式组：\n1. $a_1^T c + r\\|a_1\\|_2 \\leq b_1 \\implies -c_x + r \\leq 0 \\implies r \\leq c_x$。\n2. $a_2^T c + r\\|a_2\\|_2 \\leq b_2 \\implies -c_y + r \\leq 0 \\implies r \\leq c_y$。\n3. $a_3^T c + r\\|a_3\\|_2 \\leq b_3 \\implies c_x + r \\leq 4 \\implies r \\leq 4 - c_x$。\n4. $a_4^T c + r\\|a_4\\|_2 \\leq b_4 \\implies c_y + r \\leq 3 \\implies r \\leq 3 - c_y$。\n5. $a_5^T c + r\\|a_5\\|_2 \\leq b_5 \\implies c_x + c_y + r\\sqrt{2} \\leq 5 \\implies r\\sqrt{2} \\leq 5 - c_x - c_y$。\n\n问题现在是找到$r \\geq 0$的最大值，使得存在一个中心$(c_x, c_y)$满足这五个不等式。这是一个线性规划问题。\n我们可以分析在给定固定$r$的情况下，$(c_x, c_y)$的可行集。从不等式中，我们得到：\n$r \\leq c_x \\leq 4 - r$\n$r \\leq c_y \\leq 3 - r$\n$c_x + c_y \\leq 5 - r\\sqrt{2}$\n\n为了使一个可行的中心$(c_x, c_y)$存在，$c_x$和$c_y$的区间必须非空。这要求：\n$r \\leq 4 - r \\implies 2r \\leq 4 \\implies r \\leq 2$。\n$r \\leq 3 - r \\implies 2r \\leq 3 \\implies r \\leq 1.5$。\n所以，我们必须有$r \\leq 1.5$。\n\n设$C_r$是对于给定半径$r$的可行中心$(c_x, c_y)$的集合。$C_r$是矩形区域$R_r = [r, 4-r] \\times [r, 3-r]$和半平面$c_x + c_y \\leq 5 - r\\sqrt{2}$的交集。为了使$C_r$非空，在$R_r$中使函数$f(c_x, c_y) = c_x + c_y$最小化的点必须满足第五个不等式。这个点是$(c_x, c_y) = (r, r)$。\n将这个点代入不等式，得到$C_r$非空的必要条件：\n$r + r \\leq 5 - r\\sqrt{2}$\n$2r \\leq 5 - r\\sqrt{2}$\n$r(2 + \\sqrt{2}) \\leq 5$\n$r \\leq \\frac{5}{2 + \\sqrt{2}}$\n\n为了找到最大半径$r^{\\star}$，我们必须满足所有推导出的$r$的上界：\n$r \\leq 1.5$ 且 $r \\leq \\frac{5}{2 + \\sqrt{2}}$。\n让我们比较一下这两个界限。\n$\\frac{5}{2 + \\sqrt{2}} = \\frac{5(2 - \\sqrt{2})}{(2 + \\sqrt{2})(2 - \\sqrt{2})} = \\frac{5(2 - \\sqrt{2})}{4 - 2} = \\frac{5(2 - \\sqrt{2})}{2} = 5 - \\frac{5}{2}\\sqrt{2}$。\n我们检查是否$5 - \\frac{5}{2}\\sqrt{2} \\leq 1.5 = \\frac{3}{2}$。\n$10 - 5\\sqrt{2} \\leq 3 \\implies 7 \\leq 5\\sqrt{2} \\implies 49 \\leq 25 \\times 2 = 50$。\n该不等式成立。因此，更具限制性的条件是$r \\leq \\frac{5}{2 + \\sqrt{2}}$。\n\n因此，最大半径是$r^{\\star} = \\frac{5}{2 + \\sqrt{2}}$。\n在此半径下，可行中心集合$C_{r^{\\star}}$收缩到单一点。条件$r(2+\\sqrt{2}) \\leq 5$变为等式$r^{\\star}(2+\\sqrt{2}) = 5$，这意味着中心必须是$c_x = c_y = r^{\\star}$。\n最优中心是$c^{\\star} = (r^{\\star}, r^{\\star})$。这个中心到三条直线$x=0$、$y=0$和$x+y=5$的距离相等。另外两个约束，$c_x+r \\leq 4$和$c_y+r \\leq 3$，也得到满足，因为$2r^{\\star} < 3 < 4$。\n最大半径的最终表达式是：\n$r^{\\star} = \\frac{5}{2 + \\sqrt{2}} = \\frac{5(2 - \\sqrt{2})}{2}$。", "answer": "$$\\boxed{\\frac{5(2-\\sqrt{2})}{2}}$$", "id": "2410361"}, {"introduction": "线性规划的威力通过其对偶性概念而大大增强，它为每个线性规划问题揭示了一个隐藏的、互补的问题。本练习将引导你探索优化领域最著名的成果之一：最大流最小割定理。你将为一个网络建立最大流问题的模型，推导其对偶问题，并发现其作为最小割问题的优雅解释，从而巩固你对对偶性实际意义的理解 [@problem_id:2410395]。", "problem": "考虑一个有向网络（图），其节点集为 $V=\\{v_1,v_2,v_3,v_4,v_5,v_6\\}$，源点为 $s=v_1$，汇点为 $t=v_6$。每条有向弧 $(i,j)$ 都有一个非负容量 $c_{ij}$。非零容量如下：\n- $v_1 \\to v_2$ 的容量为 $c_{12}=7$， $v_1 \\to v_3$ 的容量为 $c_{13}=3$，$v_1 \\to v_4$ 的容量为 $c_{14}=4$。\n- $v_2 \\to v_3$ 的容量为 $c_{23}=2$，$v_2 \\to v_4$ 的容量为 $c_{24}=3$，$v_2 \\to v_5$ 的容量为 $c_{25}=5$。\n- $v_3 \\to v_4$ 的容量为 $c_{34}=4$，$v_3 \\to v_5$ 的容量为 $c_{35}=6$，$v_3 \\to v_6$ 的容量为 $c_{36}=2$。\n- $v_4 \\to v_5$ 的容量为 $c_{45}=2$，$v_4 \\to v_6$ 的容量为 $c_{46}=5$。\n- $v_5 \\to v_6$ 的容量为 $c_{56}=8$。\n\n使用有向网络中流和割的第一性原理定义，在线性规划（LP）的框架内完成以下任务：\n1) 为该网络构建最大 $s$–$t$ 流的LP模型，具体说明决策变量、目标函数和所有约束条件。\n2) 推导您所构建的最大流模型的LP对偶问题，并从最小 $s$–$t$ 割LP的角度解释该对偶问题，明确对偶变量与割结构之间的对应关系。\n3) 确定该网络的最小 $s$–$t$ 割的容量。\n\n答案规范：仅报告最小 $s$–$t$ 割的容量，形式为单个实数。无需四舍五入，不涉及单位。", "solution": "该问题要求对给定的有向网络进行三部分分析：将最大流问题构建为线性规划（LP），推导并解释其对偶问题，以及确定最小割容量。\n\n设节点集为 $V = \\{1, 2, 3, 4, 5, 6\\}$，源点为 $s=1$，汇点为 $t=6$。有向弧集记为 $E$。对于每条弧 $(i,j) \\in E$，都有一个给定的容量 $c_{ij} \\ge 0$。\n\n**1. 最大 $s$–$t$ 流的LP构建**\n\n我们定义决策变量并构建LP模型如下。\n决策变量：设 $x_{ij}$ 表示弧 $(i,j) \\in E$ 上的流量。这些变量必须是非负的。\n目标函数：目标是最大化离开源点 $s$ 的总流量。该值记为 $F$，等于从 $s$ 出发的所有弧上的流量之和。\n$$ \\text{最大化 } F = x_{12} + x_{13} + x_{14} $$\n约束条件：流量必须遵守两类约束。\n-容量约束：任何弧 $(i,j)$ 上的流量不能超过其容量 $c_{ij}$。\n-流量守恒约束：对于任意节点 $i \\in V \\setminus \\{s,t\\}$（中间节点），流入该节点的总流量必须等于流出该节点的总流量。\n$$ \\sum_{k:(k,i) \\in E} x_{ki} = \\sum_{j:(i,j) \\in E} x_{ij} \\quad \\text{对于 } i \\in \\{2, 3, 4, 5\\} $$\n给定网络的完整LP构建如下：\n$$ \\text{最大化 } x_{12} + x_{13} + x_{14} $$\n约束条件为：\n- 流量守恒：\n$$ (x_{23} + x_{24} + x_{25}) - x_{12} = 0 \\quad (\\text{节点 } 2) $$\n$$ (x_{34} + x_{35} + x_{36}) - (x_{13} + x_{23}) = 0 \\quad (\\text{节点 } 3) $$\n$$ (x_{45} + x_{46}) - (x_{14} + x_{24} + x_{34}) = 0 \\quad (\\text{节点 } 4) $$\n$$ x_{56} - (x_{25} + x_{35} + x_{45}) = 0 \\quad (\\text{节点 } 5) $$\n- 容量约束：\n$$ 0 \\le x_{12} \\le 7 $$\n$$ 0 \\le x_{13} \\le 3 $$\n$$ 0 \\le x_{14} \\le 4 $$\n$$ 0 \\le x_{23} \\le 2 $$\n$$ 0 \\le x_{24} \\le 3 $$\n$$ 0 \\le x_{25} \\le 5 $$\n$$ 0 \\le x_{34} \\le 4 $$\n$$ 0 \\le x_{35} \\le 6 $$\n$$ 0 \\le x_{36} \\le 2 $$\n$$ 0 \\le x_{45} \\le 2 $$\n$$ 0 \\le x_{46} \\le 5 $$\n$$ 0 \\le x_{56} \\le 8 $$\n\n**2. LP对偶及最小割解释**\n\n为推导对偶问题，我们将原始LP写成更标准的形式。设 $y_i$ 是与节点 $i \\in \\{2,3,4,5\\}$ 的流量守恒约束相关的对偶变量，设 $z_{ij} \\ge 0$ 是与容量约束 $x_{ij} \\le c_{ij}$ 相关的对偶变量。为了与最大流最小割定理正确对应，从概念上讲，更清晰的做法是为所有节点 $i \\in V$ 引入势 $p_i$，并固定 $p_s=1$ 和 $p_t=0$。原始问题可以表示为在所有节点满足流量守恒的条件下最大化变量 $F$。\n原始问题 (P)：\n$$ \\text{最大化 } F $$\n约束条件为：\n$$ \\sum_{j} x_{ji} - \\sum_{j} x_{ij} = \\begin{cases} -F & \\text{若 } i=s=1 \\\\ F & \\text{若 } i=t=6 \\\\ 0 & \\text{其他情况} \\end{cases} \\quad \\forall i \\in V \\quad \\text{(对偶变量 } p_i\\text{)} $$\n$$ x_{ij} \\le c_{ij} \\quad \\forall (i,j) \\in E \\quad \\text{(对偶变量 } z_{ij} \\ge 0\\text{)} $$\n$$ x_{ij} \\ge 0 $$\n那么对偶LP (D) 为：\n$$ \\text{最小化 } \\sum_{(i,j)\\in E} c_{ij} z_{ij} $$\n约束条件为：\n$$ p_i - p_j + z_{ij} \\ge 0 \\quad \\forall (i,j) \\in E $$\n$$ p_6 - p_1 \\ge 1 \\quad (\\text{来自 } F \\text{ 的系数}) $$\n$$ z_{ij} \\ge 0 \\quad \\forall (i,j) \\in E $$\n由于目标是最小化且 $c_{ij} \\ge 0$，在最优解处，我们会将 $z_{ij}$ 设置为满足约束的最小值，即 $z_{ij} = \\max(0, p_j - p_i)$。此外，约束 $p_6 - p_1 \\ge 1$ 将是紧的，因此我们可以根据符号选择将其写为 $p_1 - p_6 = -1$ 或 $p_1 - p_6 \\le -1$。我们使用一种常规的构建方法，将势 $p_i$ 与每个节点关联，使得 $p_s=1$ 和 $p_t=0$。对偶问题在 $p_i - p_j \\le z_{ij}$ 的约束下最小化 $\\sum c_{ij} z_{ij}$。这可变为：\n$$ \\text{最小化 } \\sum_{(i,j)\\in E} c_{ij} \\max(0, p_i - p_j) $$\n约束条件为：\n$$ p_s=1, \\quad p_t=0 $$\n这种构建方式可以直接解释为最小割问题。一个 $s-t$ 割是将顶点集 $V$ 划分为两个不相交的集合 $S$ 和 $T$，使得 $s \\in S$ 且 $t \\in T$。割 $(S,T)$ 的容量为 $\\sum_{i \\in S, j \\in T, (i,j) \\in E} c_{ij}$。如果我们将对偶变量 $p_i$ 限制为二进制，即 $p_i \\in \\{0,1\\}$，那么约束 $p_s=1, p_t=0$ 确保我们定义了一个有效的 $s-t$ 割，其中 $S=\\{i \\in V \\mid p_i=1\\}$ 且 $T=\\{i \\in V \\mid p_i=0\\}$。项 $p_i - p_j$ 仅在 $p_i=1$ 和 $p_j=0$ 时非零，即弧 $(i,j)$ 从 $S$ 跨越到 $T$。在这种情况下，$p_i-p_j=1$，目标函数对所有这些弧的容量 $c_{ij}$ 求和。因此，对偶LP是寻找最小容量 $s-t$ 割问题的一个松弛。由于最大流LP的约束矩阵是全幺模的，该对偶LP的最优解将具有整数（特别是0或1）的 $p_i$ 值，这意味着该LP松弛能精确地解决最小割问题。\n\n**3. 确定最小 $s$–$t$ 割的容量**\n\n根据最大流最小割定理，最小 $s-t$ 割的容量等于最大 $s-t$ 流的值。我们可以通过构建一个有效流并证明其是最大的，或者通过识别一个割并证明其是最小的，来找到这个值。\n\n考虑一个割 $(S,T)$，其中 $S=\\{v_1\\}$，$T=\\{v_2, v_3, v_4, v_5, v_6\\}$。从 $S$ 跨越到 $T$ 的弧是 $(v_1, v_2)$、$(v_1, v_3)$ 和 $(v_1, v_4)$。\n这个割的容量是：\n$$ C(S,T) = c_{12} + c_{13} + c_{14} = 7 + 3 + 4 = 14 $$\n现在，我们必须证明可以实现一个值为14的流。如果存在一个值为14的流，那么根据最大流最小割问题的弱对偶性（最大流 $\\le$ 最小割），这个流必须是最大的，这个割也必须是最小的。\n\n我们构建一个值为14的流：\n1.  从源点 $v_1$：发送流量 $x_{12}=7$，$x_{13}=3$，$x_{14}=4$。这使得从源点出发的所有出弧饱和。总流量为 $7+3+4=14$。\n2.  在节点 $v_2$：流入量为 $x_{12}=7$。我们必须将此流量继续传递。设 $x_{25}=5$（使弧容量饱和）和 $x_{24}=2$（使用 $c_{24}=3$ 的一部分），同时 $x_{23}=0$。流出量为 $5+2+0=7$。流量守恒。\n3.  在节点 $v_3$：流入量为 $x_{13}+x_{23} = 3+0 = 3$。设 $x_{36}=2$（使弧容量饱和）和 $x_{35}=1$（使用 $c_{35}=6$ 的一部分），同时 $x_{34}=0$。流出量为 $2+1+0=3$。流量守恒。\n4.  在节点 $v_4$：流入量为 $x_{14}+x_{24}+x_{34} = 4+2+0=6$。设 $x_{46}=5$（使弧容量饱和）和 $x_{45}=1$（使用 $c_{45}=2$ 的一部分）。流出量为 $5+1=6$。流量守恒。\n5.  在节点 $v_5$：流入量为 $x_{25}+x_{35}+x_{45} = 5+1+1=7$。设 $x_{56}=7$（使用 $c_{56}=8$ 的一部分）。流出量为 $7$。流量守恒。\n6.  到汇点 $v_6$：流入量为 $x_{36}+x_{46}+x_{56} = 2+5+7=14$。这与从源点发送的总流量相匹配。\n\n所有流量守恒和容量约束都得到满足。我们构建了一个总值为14的有效流。\n由于我们找到了一个值为14的流和一个容量为14的割，因此最大流为14，最小割容量也为14。", "answer": "$$\n\\boxed{14}\n$$", "id": "2410395"}, {"introduction": "许多现实世界中的工程问题需要离散决策，这引出了整数线性规划(ILP)问题，它们比连续的LP问题难解得多。这个计算实践深入探讨了LP松弛这一关键技术，即通过求解一个简化的连续版本来近似原问题。通过为最小顶点覆盖问题编写代码并比较不同图上的结果，你将亲身体验“积分间隙”并理解底层多面体结构如何决定了这种强大近似方法的成败 [@problem_id:2410323]。", "problem": "构建一个程序，该程序对每个给定的简单无向图，计算三个密切相关的优化模型的最优目标值并进行比较。设顶点集索引为 $V=\\{0,1,\\dots,n-1\\}$，边集为 $E\\subseteq \\{\\{u,v\\}\\mid u,v\\in V, u\\neq v\\}$。考虑为图 $G=(V,E)$ 定义的以下三个模型：\n\n1. 最小顶点覆盖的整数线性规划（ILP）模型：\n   最小化 $\\sum_{i\\in V} x_i$，约束条件为对所有 $\\{u,v\\}\\in E$ 有 $x_u + x_v \\ge 1$，以及对所有 $i\\in V$ 有 $x_i \\in \\{0,1\\}$。\n\n2. 最小顶点覆盖的线性规划（LP）松弛：\n   最小化 $\\sum_{i\\in V} x_i$，约束条件为对所有 $\\{u,v\\}\\in E$ 有 $x_u + x_v \\ge 1$，以及对所有 $i\\in V$ 有 $0 \\le x_i \\le 1$。\n\n3. 对偶 LP（分数匹配）：\n   最大化 $\\sum_{e\\in E} y_e$，约束条件为对所有 $v\\in V$ 有 $\\sum_{e\\ni v} y_e \\le 1$，以及对所有 $e\\in E$ 有 $y_e \\ge 0$。\n\n对于下面测试套件中的每个图，你的程序必须计算：\n- $s_{\\mathrm{int}}$，ILP 的最优目标值（最小顶点覆盖的大小）。\n- $s_{\\mathrm{lp}}$，LP 松弛的最优目标值。\n- $m_{\\mathrm{frac}}$，对偶 LP（分数匹配）的最优目标值。\n- 一个布尔值 $b_{\\mathrm{dual}}$，指示 $|s_{\\mathrm{lp}}-m_{\\mathrm{frac}}| \\le 10^{-6}$ 是否成立。\n- 一个布尔值 $b_{\\mathrm{int}}$，指示 $|s_{\\mathrm{int}}-s_{\\mathrm{lp}}| \\le 10^{-6}$ 是否成立。\n- 一个布尔值 $b_{\\mathrm{bip}}$，指示该图是否为二分图。\n\n你的程序必须使用以下图的测试套件，每个图由顶点数 $n$ 和作为无序对的边列表 $E$ 给出：\n- 测试 $1$（二分图，完全二分图 $K_{2,3}$）：$n=5$，$E=\\{\\{0,2\\},\\{0,3\\},\\{0,4\\},\\{1,2\\},\\{1,3\\},\\{1,4\\}\\}$。\n- 测试 $2$（非二分图，奇圈 $C_3$）：$n=3$，$E=\\{\\{0,1\\},\\{1,2\\},\\{2,0\\}\\}$。\n- 测试 $3$（空图）：$n=4$，$E=\\emptyset$。\n- 测试 $4$（带一个孤立顶点的单边图）：$n=3$，$E=\\{\\{0,1\\}\\}$。\n\n数值输出要求：\n- 所有浮点值必须使用标准舍入规则，精确到小数点后三位。\n- 不涉及物理单位。\n- 浮点值之间的任何相等性比较都必须使用上述指定的容差 $10^{-6}$。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含一个列表的列表，按上述测试的顺序排列。对于每个测试，输出列表 $[s_{\\mathrm{int}}, s_{\\mathrm{lp}}, m_{\\mathrm{frac}}, b_{\\mathrm{dual}}, b_{\\mathrm{int}}, b_{\\mathrm{bip}}]$。\n- 总输出必须是代表这些每个测试列表的列表的单行，例如 $[[a_1,b_1,c_1,d_1,e_1,f_1],[a_2,b_2,c_2,d_2,e_2,f_2],\\dots]$，其中 $a_i$ 和 $b_i$ 是整数或浮点数，而 $d_i,e_i,f_i$ 是布尔值。\n\n覆盖设计：\n- 测试 $1$ 考察了一个二分图，其中 ILP 和 LP 的最优值重合。\n- 测试 $2$ 考察了一个非二分图，其中 LP 松弛的最优值可能严格小于 ILP 的最优值。\n- 测试 $3$ 是一个没有边的边界情况。\n- 测试 $4$ 是一个只有一条边的最小连通情况。", "solution": "我们从第一性原理开始。图 $G=(V,E)$ 的一个顶点覆盖是一个集合 $C\\subseteq V$，使得每条边 $\\{u,v\\}\\in E$ 至少有一个端点在 $C$ 中。最小顶点覆盖问题旨在在所有这样的 $C$ 中最小化 $|C|$。通过为每个顶点 $i\\in V$ 引入二元决策变量 $x_i$，可以将其自然地表达为整数线性规划（ILP）模型，其中如果 $i\\in C$ 则 $x_i=1$，否则 $x_i=0$。对于每条边 $\\{u,v\\}\\in E$ 的覆盖条件是 $x_u + x_v \\ge 1$。因此，ILP 模型为：\n$$\n\\begin{aligned}\n\\min \\quad & \\sum_{i\\in V} x_i \\\\\n\\text{s.t.} \\quad & x_u + x_v \\ge 1 \\quad \\forall \\{u,v\\}\\in E, \\\\\n& x_i \\in \\{0,1\\} \\quad \\forall i\\in V.\n\\end{aligned}\n$$\n线性规划（LP）松弛将整数约束替换为界限 $0\\le x_i \\le 1$：\n$$\n\\begin{aligned}\n\\min \\quad & \\sum_{i\\in V} x_i \\\\\n\\text{s.t.} \\quad & x_u + x_v \\ge 1 \\quad \\forall \\{u,v\\}\\in E, \\\\\n& 0 \\le x_i \\le 1 \\quad \\forall i\\in V.\n\\end{aligned}\n$$\n与此松弛对应的对偶 LP 是分数匹配问题。为每条边 $e\\in E$ 引入对偶变量 $y_e$，得到：\n$$\n\\begin{aligned}\n\\max \\quad & \\sum_{e\\in E} y_e \\\\\n\\text{s.t.} \\quad & \\sum_{e\\ni v} y_e \\le 1 \\quad \\forall v\\in V, \\\\\n& y_e \\ge 0 \\quad \\forall e\\in E.\n\\end{aligned}\n$$\n根据线性规划对偶性，在两个问题都可行且有界的情况下，LP 松弛和分数匹配对偶的最优目标值相等。这表达了多面体关系，即顶点覆盖多面体的 LP 松弛和匹配多面体的 LP 松弛是对偶的。\n\n对于二分图，其点-边关联矩阵是全幺模的，这意味着顶点覆盖的 LP 松弛具有整数极点。因此，对于二分图，ILP 最优值等于 LP 最优值，也等于分数匹配对偶的最优值，这与 Kőnig 定理一致。对于非二分图，LP 松弛可能会产生一个严格小于 ILP 最优值的值，这反映了整数性间隙。\n\n计算所需输出的算法设计如下：\n- 通过按基数递增的顺序评估所有子集 $C\\subseteq V$ 来精确计算 $s_{\\mathrm{int}}$，直到找到一个顶点覆盖为止；其正确性直接源于顶点覆盖的定义和对 $|C|$ 的最小化。\n- 通过求解 LP 松弛来计算 $s_{\\mathrm{lp}}$。为了将其转换为数值求解器的标准不等式形式，将 $x_u + x_v \\ge 1$ 重写为 $-x_u - x_v \\le -1$，并附带界限 $0\\le x_i \\le 1$。\n- 通过求解对偶 LP 来计算 $m_{\\mathrm{frac}}$。为了适应最小化求解器，通过最小化 $-\\sum y_e$ 来最大化 $\\sum y_e$，约束条件为 $\\sum_{e\\ni v} y_e \\le 1$ 和 $y_e \\ge 0$。\n- 通过检查 $|s_{\\mathrm{lp}} - m_{\\mathrm{frac}}| \\le 10^{-6}$ 来计算 $b_{\\mathrm{dual}}$，这是可行且有界实例的强对偶性所蕴含的。\n- 通过检查 $|s_{\\mathrm{int}} - s_{\\mathrm{lp}}| \\le 10^{-6}$ 来计算 $b_{\\mathrm{int}}$。\n- 通过二着色的广度优先搜索测试来计算 $b_{\\mathrm{bip}}$ 以判断二分性。\n\n我们现在将此应用于测试套件。\n\n测试 $1$：$K_{2,3}$，$n=5$，$E=\\{\\{0,2\\},\\{0,3\\},\\{0,4\\},\\{1,2\\},\\{1,3\\},\\{1,4\\}\\}$。\n- 一个最小顶点覆盖是 $\\{0,1\\}$，大小为 $|C|=2$，所以 $s_{\\mathrm{int}}=2$。\n- 在二分图中，LP 松弛有一个具有相同值的整数最优解；因此 $s_{\\mathrm{lp}}=2.0$。\n- 在 $K_{2,3}$ 中，最大匹配的大小为 $2$，分数匹配的最优值等于此值；因此 $m_{\\mathrm{frac}}=2.0$。\n- 因此 $b_{\\mathrm{dual}}=\\text{True}$，$b_{\\mathrm{int}}=\\text{True}$，$b_{\\mathrm{bip}}=\\text{True}$。\n\n测试 $2$：$C_3$，$n=3$，$E=\\{\\{0,1\\},\\{1,2\\},\\{2,0\\}\\}$。\n- 一个最小顶点覆盖的大小为 $2$，所以 $s_{\\mathrm{int}}=2$。\n- LP 松弛允许 $x_0=x_1=x_2=\\tfrac{1}{2}$，目标值为 $\\tfrac{3}{2}$，这是最优的；因此 $s_{\\mathrm{lp}}=1.5$。\n- 分数匹配设置 $y_{\\{0,1\\}}=y_{\\{1,2\\}}=y_{\\{2,0\\}}=\\tfrac{1}{2}$，目标值为 $\\tfrac{3}{2}$，所以 $m_{\\mathrm{frac}}=1.5$。\n- 因此 $b_{\\mathrm{dual}}=\\text{True}$，$b_{\\mathrm{int}}=\\text{False}$，$b_{\\mathrm{bip}}=\\text{False}$。\n\n测试 $3$：空图，$n=4$，$E=\\emptyset$。\n- 空集是一个顶点覆盖，所以 $s_{\\mathrm{int}}=0$。\n- LP 松弛具有零解，目标值为 $0$，所以 $s_{\\mathrm{lp}}=0.0$。\n- 分数匹配没有边，目标值为 $0$，所以 $m_{\\mathrm{frac}}=0.0$。\n- 因此 $b_{\\mathrm{dual}}=\\text{True}$，$b_{\\mathrm{int}}=\\text{True}$，$b_{\\mathrm{bip}}=\\text{True}$。\n\n测试 $4$：单边图，$n=3$，$E=\\{\\{0,1\\}\\}$。\n- 一个最小顶点覆盖的大小为 $1$，所以 $s_{\\mathrm{int}}=1$。\n- LP 松弛的值也为 $1.0$；因此 $s_{\\mathrm{lp}}=1.0$。\n- 分数匹配设置 $y_{\\{0,1\\}}=1$，目标值为 $1$，所以 $m_{\\mathrm{frac}}=1.0$。\n- 因此 $b_{\\mathrm{dual}}=\\text{True}$，$b_{\\mathrm{int}}=\\text{True}$，$b_{\\mathrm{bip}}=\\text{True}$。\n\n将浮点数四舍五入到三位小数后，每个测试的列表为 $[2,2.000,2.000,\\text{True},\\text{True},\\text{True}]$、$[2,1.500,1.500,\\text{True},\\text{False},\\text{False}]$、$[0,0.000,0.000,\\text{True},\\text{True},\\text{True}]$ 和 $[1,1.000,1.000,\\text{True},\\text{True},\\text{True}]$。程序必须根据定义通用地计算这些值，并按照规定将它们生成为单行的列表的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\nfrom itertools import combinations, product, chain\nfrom collections import deque\n\nTOL = 1e-6\n\ndef is_bipartite(n, edges):\n    if n == 0:\n        return True\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    color = [None] * n\n    for s in range(n):\n        if color[s] is None:\n            color[s] = 0\n            q = deque([s])\n            while q:\n                u = q.popleft()\n                for v in adj[u]:\n                    if color[v] is None:\n                        color[v] = 1 - color[u]\n                        q.append(v)\n                    elif color[v] == color[u]:\n                        return False\n    return True\n\ndef min_vertex_cover_integer(n, edges):\n    # Brute-force exact solution by increasing cardinality subsets\n    # Early exit once a cover is found\n    edge_list = edges\n    if not edge_list:\n        return 0\n    # Precompute for fast checking\n    for k in range(n + 1):\n        for subset in combinations(range(n), k):\n            subset_set = set(subset)\n            ok = True\n            for (u, v) in edge_list:\n                if (u not in subset_set) and (v not in subset_set):\n                    ok = False\n                    break\n            if ok:\n                return k\n    return n  # fallback, full set is always a cover\n\ndef lp_vertex_cover_value(n, edges):\n    # Minimize sum x_i subject to x_u + x_v >= 1, 0 = x_i = 1\n    c = np.ones(n, dtype=float)\n    m = len(edges)\n    if m == 0:\n        return 0.0\n    A = np.zeros((m, n), dtype=float)\n    b = np.full(m, -1.0, dtype=float)\n    for idx, (u, v) in enumerate(edges):\n        A[idx, u] = -1.0\n        A[idx, v] = -1.0\n    bounds = [(0.0, 1.0)] * n\n    res = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method=\"highs\")\n    if not res.success:\n        raise RuntimeError(\"LP vertex cover did not converge\")\n    val = float(res.fun)\n    # Clean small negative zeros\n    if abs(val)  1e-12:\n        val = 0.0\n    return val\n\ndef fractional_matching_value(n, edges):\n    # Maximize sum y_e subject to sum_{e incident to v} y_e = 1, y_e >= 0\n    m = len(edges)\n    if m == 0:\n        return 0.0\n    c = -np.ones(m, dtype=float)  # maximize -> minimize negative\n    A = np.zeros((n, m), dtype=float)\n    b = np.ones(n, dtype=float)\n    for j, (u, v) in enumerate(edges):\n        A[u, j] += 1.0\n        A[v, j] += 1.0\n    bounds = [(0.0, None)] * m\n    res = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method=\"highs\")\n    if not res.success:\n        raise RuntimeError(\"Fractional matching LP did not converge\")\n    val = -float(res.fun)\n    if abs(val)  1e-12:\n        val = 0.0\n    return val\n\ndef format_float(x):\n    return f\"{x:.3f}\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (n, edges)\n    test_cases = [\n        (5, [(0,2),(0,3),(0,4),(1,2),(1,3),(1,4)]),           # K_{2,3}\n        (3, [(0,1),(1,2),(2,0)]),                             # C3\n        (4, []),                                              # Empty graph\n        (3, [(0,1)]),                                         # Single edge with isolated vertex\n    ]\n\n    per_case_outputs = []\n    for n, edges in test_cases:\n        # Normalize edges as unordered pairs (u  v)\n        norm_edges = []\n        for u, v in edges:\n            if u == v:\n                continue\n            a, b = (u, v) if u  v else (v, u)\n            norm_edges.append((a, b))\n        # Remove duplicates if any\n        norm_edges = list(dict.fromkeys(norm_edges).keys()) if hasattr(dict, \"fromkeys\") else list(set(norm_edges))\n        # Compute required quantities\n        s_int = min_vertex_cover_integer(n, norm_edges)\n        s_lp = lp_vertex_cover_value(n, norm_edges)\n        m_frac = fractional_matching_value(n, norm_edges)\n        b_dual = abs(s_lp - m_frac) = TOL\n        b_int = abs(s_int - s_lp) = TOL\n        b_bip = is_bipartite(n, norm_edges)\n        # Prepare string for this case: [s_int, s_lp, m_frac, b_dual, b_int, b_bip]\n        case_str = f\"[{s_int},{format_float(s_lp)},{format_float(m_frac)},{str(b_dual).lower()},{str(b_int).lower()},{str(b_bip).lower()}]\"\n        per_case_outputs.append(case_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(per_case_outputs)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2410323"}]}