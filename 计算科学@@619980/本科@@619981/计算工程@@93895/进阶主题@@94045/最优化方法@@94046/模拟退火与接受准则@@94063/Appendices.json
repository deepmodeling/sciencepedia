{"hands_on_practices": [{"introduction": "理论联系实践是掌握任何算法的关键。本节我们将从模拟退火的物理根源——统计物理学入手，通过一个经典模型来动手实践。我们将应用模拟退火算法来寻找二维伊辛模型的基态，伊辛模型是理解物质相变的基本模型。通过这个练习，你将学习如何实现不同的降温策略，并将模拟结果与已知的解析解进行比较，从而加深对算法工作原理及其物理背景的理解。", "problem": "考虑一个 $N \\times N$ 方形晶格上的二维伊辛模型（Ising model），其自旋为 $s_{i,j} \\in \\{-1,+1\\}$，能量为\n$$\nE(\\mathbf{s}) \\;=\\; -J \\sum_{\\langle (i,j),(i',j') \\rangle} s_{i,j}\\, s_{i',j'} \\;-\\; B \\sum_{i=1}^{N} \\sum_{j=1}^{N} s_{i,j},\n$$\n其中，第一个求和项遍及所有无序的最近邻对，而 $B$ 是一个外部磁场。在本任务中，设 $B=0$ 且 $J>0$（铁磁耦合）。该系统采用开放边界条件（无环绕相邻格点）或周期性边界条件（两个坐标方向上均有环绕相邻格点）。在能量计算中，每条键只计算一次。\n\n模拟退火（simulated annealing）过程定义如下。从一个初始自旋构型开始，该构型中的自旋从 $\\{-1,+1\\}$ 中独立均匀选取。在离散步骤 $k \\in \\{0,1,2,\\dots\\}$，随机均匀地选择单个格点 $(i,j)$，并提出翻转建议 $s_{i,j} \\mapsto -s_{i,j}$。令 $\\Delta E_k$ 表示由这次单自旋翻转导致的能量 $E$ 的变化。该建议以如下概率被接受：\n$$\nA_k \\;=\\; \\min\\!\\left(1, \\exp\\!\\left(-\\frac{\\Delta E_k}{T_k}\\right)\\right),\n$$\n其中 $T_k$ 是步骤 $k$ 的温度。温度表是一个长度为 $K$ 的正序列 $\\{T_k\\}_{k=0}^{K-1}$，本任务的过程在每个温度下使用固定数量的扫描次数（sweeps）。一次扫描定义为在同一温度下进行 $N^2$ 次独立的单自旋翻转建议。总建议次数等于 $K$ 乘以每个温度的扫描次数再乘以 $N^2$。为保证可复现性，每次运行时必须在开始时用种子 $0$ 初始化伪随机数生成器。\n\n对于 $B=0$ 和 $J>0$ 的情况，通过模型的定义，根据第一性原理推导，确定给定晶格尺寸 $N$、耦合常数 $J$ 和边界条件 $\\mathrm{bc} \\in \\{\\text{open},\\text{periodic}\\}$ 下的解析基态能量 $E_{\\mathrm{gs}}(N,J,\\mathrm{bc})$。然后，对于下面指定的每个温度表和参数集，运行上述模拟退火过程，并记录在整个运行过程中达到的最低能量 $E_{\\min}$。对每个测试用例，计算绝对差：\n$$\nD \\;=\\; \\big| E_{\\min} \\;-\\; E_{\\mathrm{gs}}(N,J,\\mathrm{bc}) \\big|.\n$$\n\n在所有情况中均使用 $J=1$。使用以下温度表和参数，其中 $K$ 是温度点的数量，每个温度在指定的扫描次数内保持恒定。温度表如下：\n- 指数型：$T_k = T_0 \\,\\alpha^k$，参数为 $T_0>0$ 和 $\\alpha \\in (0,1)$。\n- 线性型：$T_k = \\dfrac{T_0}{1 + c k}$，参数为 $T_0>0$ 和 $c>0$。\n- 对数型：$T_k = \\dfrac{T_0}{\\log(2 + k)}$，参数为 $T_0>0$。\n\n测试套件（每项代表一次独立运行）：\n- 用例 1：$N=6$，周期性边界条件，指数型温度表，参数为 $T_0=4.0, \\alpha=0.98, K=500$，每个温度扫描 1 次。\n- 用例 2：$N=7$，开放边界条件，线性型温度表，参数为 $T_0=5.0, c=0.01, K=700$，每个温度扫描 1 次。\n- 用例 3：$N=1$，开放边界条件，指数型温度表，参数为 $T_0=1.0, \\alpha=0.5, K=5$，每个温度扫描 1 次。\n- 用例 4：$N=3$，周期性边界条件，对数型温度表，参数为 $T_0=5.0, K=600$，每个温度扫描 2 次。\n\n您的程序应生成单行输出，其中包含按上述用例顺序排列的结果，形式为方括号括起来的逗号分隔列表：\n$$\n[D_1, D_2, D_3, D_4].\n$$\n每个 $D_i$ 必须是浮点数。不涉及物理单位。不使用角度。请将任何分数值表示为小数。", "solution": "该问题要求对 $N \\times N$ 方形晶格上的二维铁磁伊辛模型进行分析和模拟，并对其应用模拟退火过程。目标是计算模拟过程中找到的最小能量 $E_{\\min}$ 与解析确定的基态能量 $E_{\\mathrm{gs}}$ 之间的绝对差。\n\n首先，我们确定解析基态能量 $E_{\\mathrm{gs}}$。系统的哈密顿量由下式给出：\n$$\nE(\\mathbf{s}) = -J \\sum_{\\langle (i,j),(i',j') \\rangle} s_{i,j}\\, s_{i',j'} - B \\sum_{i=1}^{N} \\sum_{j=1}^{N} s_{i,j}\n$$\n问题指定外部磁场为零，$B=0$，耦合常数为正，$J>0$（铁磁相互作用）。能量表达式简化为：\n$$\nE(\\mathbf{s}) = -J \\sum_{\\langle (i,j),(i',j') \\rangle} s_{i,j}\\, s_{i',j'}\n$$\n为了使该能量最小化，必须最大化求和项 $\\sum s_{i,j}\\,s_{i',j'}$。由于每个自旋 $s_{i,j}$ 只能是 $+1$ 或 $-1$，一对相邻自旋的乘积 $s_{i,j}\\,s_{i',j'}$ 在等于 $+1$ 时达到最大值，这发生在 $s_{i,j} = s_{i',j'}$ 的情况下。因此，当所有自旋都对齐时，即所有 $s_{i,j} = +1$ 或所有 $s_{i,j} = -1$ 时，系统达到基态。在此构型中，求和中的每一项都贡献 $+1$。因此，基态能量为 $E_{\\mathrm{gs}} = -J \\times (\\text{最近邻键的总数})$。\n\n键的数量取决于边界条件：\n1.  **周期性边界条件**：晶格是一个环面。$N^2$ 个格点中的每一个都有四个邻居（两个水平方向，两个垂直方向）。为确保每条键只计算一次，我们将每个格点的邻居数相加后除以二。总键数为 $\\frac{1}{2} (N^2 \\times 4) = 2N^2$。基态能量为\n    $$E_{\\mathrm{gs}}(N,J,\\mathrm{periodic}) = -J \\cdot 2N^2$$\n2.  **开放边界条件**：晶格有边缘。有 $N$ 行，每行有 $N-1$ 个水平键，共计 $N(N-1)$ 个水平键。同样，有 $N$ 列，每列有 $N-1$ 个垂直键，共计 $N(N-1)$ 个垂直键。总键数为 $N(N-1) + N(N-1) = 2N(N-1)$。基态能量为\n    $$E_{\\mathrm{gs}}(N,J,\\mathrm{open}) = -J \\cdot 2N(N-1)$$\n\n接下来，我们讨论模拟退火过程。这是一种用于寻找函数全局最小值的概率性优化算法。该过程从一个随机的自旋构型开始。在每一步中，通过翻转一个随机选择的单个自旋来提出一个新状态。计算因此次翻转产生的能量变化 $\\Delta E$。在格点 $(i,j)$ 处，自旋从状态 $s_{i,j}$ 翻转到 $-s_{i,j}$ 会使能量改变：\n$$\n\\Delta E = E_{\\text{new}} - E_{\\text{old}} = \\left(-J \\sum_{k \\in \\text{neigh}} (-s_{i,j})s_k \\right) - \\left(-J \\sum_{k \\in \\text{neigh}} s_{i,j}s_k \\right) = 2J s_{i,j} \\sum_{k \\in \\text{neigh}} s_k\n$$\n其中求和项是对格点 $(i,j)$ 的邻居自旋 $s_k$ 进行的。这种高效的计算方法避免了在每一步都重新计算系统的总能量。\n\n根据 Metropolis 准则，提出的翻转以概率 $A_k = \\min(1, \\exp(-\\Delta E_k / T_k))$ 被接受。这里，$T_k$ 是步骤 $k$ 的温度。如果 $\\Delta E_k \\le 0$，则该移动总是被接受。如果 $\\Delta E_k > 0$，则该移动被接受的概率会随着温度 $T_k$ 的降低而减小。\n\n温度根据一个温度表 $\\{T_k\\}_{k=0}^{K-1}$ 逐渐降低。对于温度表中的每个温度 $T_k$，会执行固定次数的扫描，其中一次扫描包含 $N^2$ 次自旋翻转建议。在整个模拟过程中，记录遇到的最小能量 $E_{\\min}$。\n\n指定的三个温度表是：\n-   **指数型**：$T_k = T_0 \\alpha^k$\n-   **线性型**：$T_k = T_0 / (1 + ck)$\n-   **对数型**：$T_k = T_0 / \\log(2+k)$\n\n实现过程首先使用 $J=1$ 和推导出的公式为每个测试用例计算 $E_{\\mathrm{gs}}$。然后，为每个用例运行一次独立的模拟。为保证可复现性，伪随机数生成器使用种子 $0$ 进行初始化。一个 $N \\times N$ 的自旋网格被随机初始化。模拟随后会遍历指定温度表中的 $K$ 个温度。在每个温度下，它执行所需次数的扫描，每次扫描包含 $N^2$ 个蒙特卡洛步骤（提出建议、计算 $\\Delta E$、接受/拒绝）。当前能量和迄今为止找到的最小能量会相应更新。最后，计算绝对差 $D = |E_{\\min} - E_{\\mathrm{gs}}|$。对所有四个测试用例重复此过程。一个特殊情况是 $N=1$ 且为开放边界，它没有任何键，因此无论自旋构型或退火过程如何，其能量始终为 $0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_analytical_gs_energy(N, J, bc):\n    \"\"\"Calculates the analytical ground state energy for the Ising model.\"\"\"\n    if N == 0:\n        return 0.0\n    if bc == 'periodic':\n        # For a periodic lattice, each of N^2 sites has 4 neighbors.\n        # Number of bonds = (N^2 * 4) / 2 = 2 * N^2\n        return -J * 2.0 * N**2\n    elif bc == 'open':\n        # For an open lattice, there are N*(N-1) horizontal and N*(N-1) vertical bonds.\n        # Number of bonds = 2 * N * (N-1)\n        return -J * 2.0 * N * (N - 1)\n    else:\n        raise ValueError(\"Invalid boundary condition specified.\")\n\ndef calculate_total_energy(spins, N, J, bc):\n    \"\"\"Calculates the total energy of the spin configuration. Used for initialization.\"\"\"\n    energy = 0.0\n    for r in range(N):\n        for c in range(N):\n            spin = spins[r, c]\n            if bc == 'periodic':\n                # Sum over right and down neighbors to count each bond once\n                right_neighbor = spins[r, (c + 1) % N]\n                down_neighbor = spins[(r + 1) % N, c]\n                energy += -J * spin * right_neighbor\n                energy += -J * spin * down_neighbor\n            elif bc == 'open':\n                if c < N - 1:\n                    right_neighbor = spins[r, c + 1]\n                    energy += -J * spin * right_neighbor\n                if r < N - 1:\n                    down_neighbor = spins[r + 1, c]\n                    energy += -J * spin * down_neighbor\n    return energy\n\ndef get_neighbor_sum(spins, pos, N, bc):\n    \"\"\"Calculates the sum of spins of the neighbors of a given site.\"\"\"\n    r, c = pos\n    neighbor_sum = 0.0\n    if bc == 'periodic':\n        neighbor_sum += spins[(r - 1) % N, c]\n        neighbor_sum += spins[(r + 1) % N, c]\n        neighbor_sum += spins[r, (c - 1) % N]\n        neighbor_sum += spins[r, (c + 1) % N]\n    elif bc == 'open':\n        if r > 0: neighbor_sum += spins[r - 1, c]\n        if r < N - 1: neighbor_sum += spins[r + 1, c]\n        if c > 0: neighbor_sum += spins[r, c - 1]\n        if c < N - 1: neighbor_sum += spins[r, c + 1]\n    return neighbor_sum\n\ndef run_simulation(params):\n    \"\"\"Runs a single simulated annealing case.\"\"\"\n    N = params['N']\n    J = params['J']\n    bc = params['bc']\n    schedule_type = params['schedule_type']\n    schedule_params = params['schedule_params']\n    K = params['K']\n    sweeps_per_temp = params['sweeps_per_temp']\n\n    # Seed the RNG for reproducibility for each independent run\n    np.random.seed(0)\n\n    # Initialize spin configuration\n    spins = np.random.choice([-1, 1], size=(N, N)).astype(float)\n    \n    if N == 0:\n        return 0.0\n    \n    current_energy = calculate_total_energy(spins, N, J, bc)\n    min_energy = current_energy\n\n    # Generate temperature schedule\n    temps = np.zeros(K)\n    T0 = schedule_params.get('T0')\n    if schedule_type == 'exponential':\n        alpha = schedule_params['alpha']\n        for k in range(K):\n            temps[k] = T0 * (alpha**k)\n    elif schedule_type == 'linear':\n        c = schedule_params['c']\n        for k in range(K):\n            temps[k] = T0 / (1.0 + c * k)\n    elif schedule_type == 'logarithmic':\n        for k in range(K):\n            temps[k] = T0 / np.log(2.0 + k)\n    \n    steps_per_temp = sweeps_per_temp * N**2\n\n    # Simulated Annealing process\n    for k in range(K):\n        T_k = temps[k]\n        if T_k == 0: continue # Avoid division by zero\n        for _ in range(steps_per_temp):\n            # Propose a flip\n            r, c = np.random.randint(N), np.random.randint(N)\n            \n            # Calculate energy change\n            s_ij = spins[r, c]\n            sum_neighbors = get_neighbor_sum(spins, (r, c), N, bc)\n            delta_E = 2.0 * J * s_ij * sum_neighbors\n\n            # Metropolis acceptance criterion\n            if delta_E < 0 or np.random.rand() < np.exp(-delta_E / T_k):\n                spins[r, c] *= -1\n                current_energy += delta_E\n                if current_energy < min_energy:\n                    min_energy = current_energy\n    \n    return min_energy\n\ndef solve():\n    \"\"\"Main solver function to run all test cases and print results.\"\"\"\n    J_val = 1.0\n\n    test_cases = [\n        {'N': 6, 'bc': 'periodic', 'schedule_type': 'exponential', 'schedule_params': {'T0': 4.0, 'alpha': 0.98}, 'K': 500, 'sweeps_per_temp': 1},\n        {'N': 7, 'bc': 'open', 'schedule_type': 'linear', 'schedule_params': {'T0': 5.0, 'c': 0.01}, 'K': 700, 'sweeps_per_temp': 1},\n        {'N': 1, 'bc': 'open', 'schedule_type': 'exponential', 'schedule_params': {'T0': 1.0, 'alpha': 0.5}, 'K': 5, 'sweeps_per_temp': 1},\n        {'N': 3, 'bc': 'periodic', 'schedule_type': 'logarithmic', 'schedule_params': {'T0': 5.0}, 'K': 600, 'sweeps_per_temp': 2},\n    ]\n\n    results = []\n    for case in test_cases:\n        case['J'] = J_val\n        E_gs = calculate_analytical_gs_energy(case['N'], case['J'], case['bc'])\n        E_min = run_simulation(case)\n        D = abs(E_min - E_gs)\n        results.append(D)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2435206"}, {"introduction": "许多现实世界中的优化问题都具有“欺骗性”的能量景观，其中存在大量远离全局最优解的局部最优解，这使得简单的贪心算法很容易陷入困境。本练习将引导你探索一个二次无约束二元优化（QUBO）问题，该问题就具有这种欺骗性。通过比较不同降温策略在此问题上的表现，你将亲身体会到为何一个精心设计的温度退火方案对于成功跳出局部陷阱、探索整个解空间并最终找到全局最优解是至关重要的。", "problem": "要求您在一个特意设计的二次无约束二元优化（QUBO）问题的欺骗性实例上，实现并分析模拟退火（SA）的降温方案。您的程序必须是一个完整的、可运行的实现，该实现能在同一个问题实例上评估多种降温方案，并报告其成功率。目标是从基本原理出发，分析为何不同的降温方案在局部最优与全局最优相距甚远的优化景观上表现不同。\n\n基本原理：\n- Metropolis 接受准则源于统计力学中的 Boltzmann 分布，其中在温度为 $T$ 时，能量为 $E(x)$ 的构型 $x$ 出现的概率正比于 $\\exp(-E(x)/T)$。Metropolis 准则以概率 $\\exp(-\\Delta E/T)$ 接受一个能量增加的移动，其中 $\\Delta E$ 是提议状态与当前状态之间的能量差。如果 $\\Delta E \\le 0$，则确定性地接受该移动。\n- 一个满足细致平衡条件且具有遍历性提议核的马尔可夫链，在固定温度 $T$ 下，承认 Boltzmann 分布为其稳态分布。当 $T$ 足够缓慢地降低时，该链会集中在低能量状态附近。\n- 理论上的对数降温速率在理想化条件下保证在极限情况下收敛。实际的方案包括几何降温和线性降温，它们在有限的计算预算下平衡了探索与利用。\n\n问题定义：\n- 考虑一个 QUBO 问题，其二元向量为 $x \\in \\{0,1\\}^n$，对称矩阵为 $Q \\in \\mathbb{R}^{n \\times n}$。能量函数为 $E(x) = x^\\top Q x$。\n- 使用以下维度为 $n = 16$ 的特定构造：\n  - 设 $c = 1.0$ 和 $w = 0.2$。\n  - 对所有 $i \\in \\{1,\\dots,n\\}$，定义 $Q_{ii} = c$。\n  - 对所有 $i \\ne j$，定义 $Q_{ij} = -\\tfrac{w}{2}$。\n  - 这得到 $E(x) = c \\sum_{i=1}^n x_i - w \\sum_{1 \\le i < j \\le n} x_i x_j$，这是一个稠密的平均场 QUBO 问题，通常被认为是 NP-难 优化问题。其景观具有欺骗性，因为它包含相距甚远的吸引盆：对于给定参数，$x = \\mathbf{0}$ 在单位比特翻转下是局部最小值，而 $x = \\mathbf{1}$ 是全局最小值，它们之间的汉明距离为 $n$。\n- 初始化：对于每一次独立的 SA 运行，从 $\\{0,1\\}^n$ 中均匀随机地抽取初始状态 $x$。\n- 邻域：在每次迭代中，从 $\\{1,\\dots,n\\}$ 中均匀选择一个比特位进行翻转作为提议。\n- 接受准则：使用 Metropolis 准则，并结合温度 $T$：如果 $\\Delta E \\le 0$ 则接受，否则以概率 $\\exp(-\\Delta E/T)$ 接受。\n\n需要实现的降温方案：\n- 几何降温（也称指数降温）：$T_k = T_0 \\,\\alpha^k$，其中 $0 < \\alpha < 1$。\n- 线性降温：$T_k = \\max\\{T_{\\min}, T_0 \\,(1 - k/K)\\}$，其中迭代索引 $k \\in \\{0,\\dots,K-1\\}$，总预算为 $K$。\n- 对数降温：$T_k = \\dfrac{T_0}{\\log(b + k + 1)}$，其中 $\\log$ 表示自然对数。\n\n成功标准：\n- 如果一次运行在其 $K$ 次迭代中至少有一次精确达到全局最小能量，则该次运行被计为成功。对于此问题实例，您必须在运行 SA 之前，通过对所有 $2^n$ 个二元向量 $x$ 进行穷举来精确计算出真正的全局最小能量。您可以使用任何正确的方法来评估每个 $x$ 的 $E(x)$；例如，直接计算 $E(x) = x^\\top Q x$。\n\n测试套件：\n实现以下四个测试用例。在每个用例中，使用指定的伪随机种子初始化随机数生成器，并根据列出的方案和参数运行 $R$ 次独立的 SA。不涉及角度；没有物理单位。为每个用例报告成功运行的比例，以十进制数表示。\n\n- 用例1（几何降温，足够慢）：\n  - 方案：几何降温，参数 $T_0 = 2.0$, $\\alpha = 0.995$。\n  - 迭代次数：$K = 6000$。\n  - 运行次数：$R = 64$。\n  - 种子：$123$。\n- 用例2（线性降温，过快）：\n  - 方案：线性降温，参数 $T_0 = 2.0$, $T_{\\min} = 0.001$。\n  - 迭代次数：$K = 1500$。\n  - 运行次数：$R = 64$。\n  - 种子：$456$。\n- 用例3（对数降温，非常慢）：\n  - 方案：对数降温，参数 $T_0 = 4.0$, $b = 2.0$。\n  - 迭代次数：$K = 6000$。\n  - 运行次数：$R = 64$。\n  - 种子：$789$。\n- 用例4（几何降温，冷启动）：\n  - 方案：几何降温，参数 $T_0 = 0.05$, $\\alpha = 0.99$。\n  - 迭代次数：$K = 6000$。\n  - 运行次数：$R = 64$。\n  - 种子：$13579$。\n\n要求输出：\n- 对于每个用例，计算至少一次达到全局最小能量的运行比例（一个在 $[0,1]$ 区间内的实数）。\n- 您的程序应生成单行输出，其中包含四个结果，以逗号分隔并用方括号括起来，每个比例值四舍五入到小数点后三位，并按用例1、2、3、4的顺序排列（例如，$\\texttt{[0.734,0.000,0.578,0.016]}$）。\n\n实现约束：\n- 严格按照规定使用 Metropolis 接受准则。\n- 严格按照规定使用邻域和初始化方法。\n- 通过为每个测试用例设定指定的种子来确保可复现性；运行间的内部分割由您决定，但必须是确定性的。\n- 您的解决方案必须是自包含的，并且不能要求任何输入。它必须能在典型的现代计算机上在合理的时间内运行。", "solution": "所呈现的问题陈述经过了严格验证，并被证实是有效的。它在科学上基于统计力学和计算优化的原理，特别是关于使用模拟退火（SA）元启发式算法解决二次无约束二元优化（QUBO）问题。该问题是适定的，所有参数、约束和目标都得到了清晰、客观的定义。这是一个自包含且数值上可行的任务。因此，将提供一个有理有据的解决方案。\n\n目标是实现并分析三种不同的模拟退火降温方案——几何、线性、对数——在一个专门构建的欺骗性QUBO问题实例上的性能。其目的是从基本原理出发，理解方案的选择如何影响算法在一个具有显著局部最小值且该值远离全局最小值的能量景观上定位全局最优解的能力。\n\n首先，我们将能量景观形式化。问题定义在一个维度为 $n=16$ 的二元向量 $x \\in \\{0, 1\\}^n$ 上。能量函数由 $E(x) = x^\\top Q x$ 给出，其中 $Q$ 是一个对称的 $n \\times n$ 矩阵。矩阵 $Q$ 的构造为对角元素 $Q_{ii} = c = 1.0$，非对角元素 $Q_{ij} = -w/2 = -0.1$ (当 $i \\neq j$)。对于二元变量，其中 $x_i^2 = x_i$，能量函数可以写成：\n$$\nE(x) = \\sum_{i=1}^n \\sum_{j=1}^n Q_{ij} x_i x_j = \\sum_{i=1}^n Q_{ii} x_i^2 + \\sum_{i \\neq j} Q_{ij} x_i x_j = c \\sum_{i=1}^n x_i - \\frac{w}{2} \\sum_{i \\neq j} x_i x_j\n$$\n鉴于求和的对称性，$\\sum_{i \\neq j} x_i x_j = 2 \\sum_{1 \\le i < j \\le n} x_i x_j$，这等价于所提供的表达式：\n$$\nE(x) = c \\sum_{i=1}^n x_i - w \\sum_{1 \\le i < j \\le n} x_i x_j\n$$\n一个状态 $x$ 的能量仅取决于非零元素的数量，我们称之为汉明权重 $k = \\sum_{i=1}^n x_i$。当 $x_i=1$ 且 $x_j=1$ 时，$i < j$ 的配对数量为 $\\binom{k}{2}$。因此，能量是 $k$ 的函数：\n$$\nE(k) = c k - w \\frac{k(k-1)}{2}\n$$\n代入给定参数 $n=16$, $c=1.0$, 和 $w=0.2$，我们得到：\n$$\nE(k) = 1.0 \\cdot k - 0.2 \\frac{k(k-1)}{2} = k - 0.1(k^2 - k) = -0.1 k^2 + 1.1 k\n$$\n这是一个关于 $k$ 的开口向下的抛物线。为了找到整数 $k \\in [0, 16]$ 的最小能量，我们计算函数在其边界处的值。\n对于 $k=0$（状态 $x=\\mathbf{0}$），能量为 $E(0) = 0$。\n对于 $k=16$（状态 $x=\\mathbf{1}$），能量为 $E(16) = -0.1(16^2) + 1.1(16) = -25.6 + 17.6 = -8.0$。\n问题陈述指出 $x=\\mathbf{0}$ 在单位比特翻转下是局部最小值。我们来验证这一点。从 $x=\\mathbf{0}$ 翻转一个比特对应于从 $k=0$ 变到 $k=1$。能量变为 $E(1) = -0.1(1)^2 + 1.1(1) = 1.0$。由于 $E(1) > E(0)$，任何从 $x=\\mathbf{0}$ 开始的单位比特翻转都会增加能量，这证实了它是一个局部最小值。此分析证实状态 $x=\\mathbf{1}$ 是全局最小值，能量为 $E_{min} = -8.0$，而 $x=\\mathbf{0}$ 是一个局部最小值，能量为 $E=0$。这两个状态被最大可能的汉明距离 $n=16$ 分隔，为局部搜索算法创造了一个具有挑战性的“欺骗性”景观。需要对所有 $2^{16}$ 个状态进行穷举搜索，以严格确认此全局最小值，这将在实现中执行。\n\n模拟退火算法流程如下。从一个随机初始状态 $x$ 和一个初始温度 $T_0$ 开始，它通过翻转一个随机选择的比特来迭代地提出一个新状态 $x'$。计算能量变化 $\\Delta E = E(x') - E(x)$。如果 $\\Delta E \\le 0$，则接受移动。如果 $\\Delta E > 0$，则根据 Metropolis 准则以概率 $P(\\text{accept}) = \\exp(-\\Delta E / T_k)$ 接受移动，其中 $T_k$ 是第 $k$ 次迭代时的温度。温度根据降温方案逐渐降低。高效计算 $\\Delta E$ 至关重要。如果比特 $j$ 从其当前状态 $x_j$ 翻转到 $1-x_j$，能量变化为：\n$$\n\\Delta E = ( (1-x_j) - x_j ) \\left[ c - w \\sum_{i \\neq j} x_i \\right]\n$$\n这种 $O(n)$ 的计算避免了完全重新计算能量所需的 $O(n^2)$ 运算。\n\n我们现在基于这些原理分析四个指定的测试用例。\n用例1：几何降温 ($T_0=2.0, \\alpha=0.995, K=6000, R=64$)。\n初始温度 $T_0=2.0$ 足够高，可以跨越能垒；例如，一个能量增加 $\\Delta E=1.0$ 的移动被接受的概率约为 $\\exp(-1.0/2.0) \\approx 0.61$。降温因子 $\\alpha=0.995$ 接近 1，导致温度呈缓慢的指数衰减。迭代次数 $K=6000$ 很大。这种组合提供了一个长的探索阶段，在高温下逃离初始的局部最小值，随后随着温度下降进入一个渐进的利用阶段，从而允许向全局最小值收敛。预计此方案将是有效的，并产生高成功率。\n\n用例2：线性降温 ($T_0=2.0, T_{min}=0.001, K=1500, R=64$)。\n初始温度与用例1相同，但迭代预算 $K=1500$ 小得多，且温度线性下降。这是一种快速降温，通常称为“淬火”。系统将迅速失去克服大能垒所需的热能。搜索很可能会被困在它遇到的第一个局部最小值的吸引盆中，这取决于随机的初始状态。鉴于景观的欺骗性，找到遥远的全局最小值的概率非常低。预计此方案表现会很差。\n\n用例3：对数降温 ($T_0=4.0, b=2.0, K=6000, R=64$)。\n此方案 $T_k = T_0 / \\log(b+k+1)$，已知在无限次迭代（$K \\to \\infty$）的极限下保证收敛到全局最优解。然而，在有限次运行中，其行为由其降温速度决定。降温过程异常缓慢。初始温度为 $T_0' = 4.0/\\log(3) \\approx 3.64$。在最后一次迭代 $k=5999$ 时，温度为 $T_{5999} = 4.0/\\log(6002) \\approx 0.46$。在整个过程中温度保持较高水平。虽然这允许对状态空间进行广泛探索，但却阻碍了利用。系统可能会找到全局最小值的吸引盆，但也可能拥有足够的热能逃离它。此方案可能比快速的线性淬火更成功，但可能不如调优良好的几何方案，因为它未能充分冷却以进行最终收敛。\n\n用例4：几何降温与冷启动 ($T_0=0.05, \\alpha=0.99, K=6000, R=64$)。\n这里，初始温度 $T_0=0.05$ 极低。接受一个即使是很小的能量增加移动的概率也微乎其微。对于 $\\Delta E = 1.0$（逃离 $x=\\mathbf{0}$ 最小值的能垒），接受概率为 $\\exp(-1.0/0.05) = \\exp(-20) \\approx 2 \\times 10^{-9}$。算法的行为将几乎与贪心局部搜索完全相同，从其随机起点下降到最近的局部最小值并被永久困住。它几乎没有能力探索景观和克服能垒以找到全局最小值。预计此方案的成功率接近零。\n\n实现将执行这四个测试用例，为每个用例计算成功运行的次数，并报告成功率，这应该会验证上述理论分析。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and analyzes Simulated Annealing (SA) acceptance schedules\n    on a deceptive QUBO problem instance.\n    \"\"\"\n    n = 16\n    c = 1.0\n    w = 0.2\n\n    # Construct the Q matrix for E(x) = x^T Q x\n    Q = np.full((n, n), -w / 2.0)\n    np.fill_diagonal(Q, c)\n\n    def calculate_energy(x, Q_mat):\n        # Using the sum form is faster than matrix multiplication for sparse vectors,\n        # but x.T @ Q_mat @ x is fine for dense numpy arrays.\n        return x.T @ Q_mat @ x\n\n    # Exhaustive search for the global minimum energy\n    # This is feasible for n=16 (2^16 = 65536 states)\n    global_min_energy = float('inf')\n    num_states = 1 << n\n    for i in range(num_states):\n        # Create binary vector x from integer i\n        x = np.array([int(b) for b in bin(i)[2:].zfill(n)])\n        energy = calculate_energy(x, Q)\n        if energy < global_min_energy:\n            global_min_energy = energy\n\n    test_cases = [\n        {\n            \"name\": \"Case 1\", \"schedule\": \"geometric\", \"T0\": 2.0, \"alpha\": 0.995,\n            \"K\": 6000, \"R\": 64, \"seed\": 123, \"Tmin\": None, \"b\": None\n        },\n        {\n            \"name\": \"Case 2\", \"schedule\": \"linear\", \"T0\": 2.0, \"Tmin\": 0.001,\n            \"K\": 1500, \"R\": 64, \"seed\": 456, \"alpha\": None, \"b\": None\n        },\n        {\n            \"name\": \"Case 3\", \"schedule\": \"logarithmic\", \"T0\": 4.0, \"b\": 2.0,\n            \"K\": 6000, \"R\": 64, \"seed\": 789, \"alpha\": None, \"Tmin\": None\n        },\n        {\n            \"name\": \"Case 4\", \"schedule\": \"geometric\", \"T0\": 0.05, \"alpha\": 0.99,\n            \"K\": 6000, \"R\": 64, \"seed\": 13579, \"Tmin\": None, \"b\": None\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        np.random.seed(case[\"seed\"])\n        success_count = 0\n        \n        K = case[\"K\"]\n        R = case[\"R\"]\n        T0 = case[\"T0\"]\n        \n        for r in range(R):\n            # Initialization\n            x_current = np.random.randint(0, 2, size=n)\n            e_current = calculate_energy(x_current, Q)\n            \n            found_global_min = e_current == global_min_energy\n            \n            T = T0\n            \n            for k in range(K):\n                # Propose new state by flipping one bit\n                bit_to_flip = np.random.randint(0, n)\n                \n                # Efficiently calculate energy difference (Delta E)\n                x_val = x_current[bit_to_flip]\n                sum_neighbors = np.sum(x_current) - x_val\n                delta_e = (1 - 2 * x_val) * (c - w * sum_neighbors)\n\n                # Metropolis acceptance criterion\n                if delta_e <= 0 or np.random.rand() < np.exp(-delta_e / T):\n                    x_current[bit_to_flip] = 1 - x_current[bit_to_flip]\n                    e_current += delta_e\n\n                if not found_global_min and np.isclose(e_current, global_min_energy):\n                    found_global_min = True\n                \n                # Update temperature based on schedule\n                if case[\"schedule\"] == \"geometric\":\n                    T = T0 * (case[\"alpha\"] ** (k + 1))\n                elif case[\"schedule\"] == \"linear\":\n                    T = max(case[\"Tmin\"], T0 * (1 - (k + 1) / K))\n                elif case[\"schedule\"] == \"logarithmic\":\n                    T = T0 / np.log(case[\"b\"] + k + 1 + 1) # k+2 for k=0..K-1\n            \n            if found_global_min:\n                success_count += 1\n                \n        success_rate = success_count / R\n        results.append(f\"{success_rate:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2435212"}, {"introduction": "在理解了降温策略的重要性之后，一个自然而然的问题是：我们如何系统地为特定问题找到“最佳”的降温策略？这个高级实践将这一问题本身构建成一个元优化（meta-optimization）任务。在这个练习中，你将不再仅仅是使用一个给定的降温策略，而是通过网格搜索的方法，为参数化的指数降温函数 $T(k) = p_1 \\exp(-p_2 k)$ 寻找最优参数 $(p_1, p_2)$，以期在优化复杂的Rastrigin函数时获得最佳平均性能，这让你得以一窥算法调优这一计算工程中的核心技能。", "problem": "给定一个用于最小化二维多峰目标的模拟退火过程。该算法使用源自玻尔兹曼分布的 Metropolis 接受准则，温度由参数化降温方案控制。您的任务是将降温方案本身作为优化对象。具体来说，考虑一个双参数指数降温方案 $T(k) = p_1 \\exp(-p_2 k)$，其中 $p_1 \\in \\mathbb{R}_{>0}$ 且 $p_2 \\in \\mathbb{R}_{\\ge 0}$，您的任务是在固定的计算预算下，确定 $p_1$ 和 $p_2$ 的值，以最小化在固定测试目标上单次模拟退火运行的平均终端性能。测试目标是二维 Rastrigin 函数，定义为\n$$\nf(\\mathbf{x}) = A n + \\sum_{i=1}^{n} \\left(x_i^2 - A \\cos(2 \\pi x_i)\\right),\n$$\n其中 $n=2$ 且 $A=10$，余弦函数以弧度为单位进行计算。搜索域为方形区域 $\\left[-5.12, 5.12\\right]^2$。\n\n模拟退火过程遵循以下基本组成部分：\n- 初始化：从 $\\left[-5.12, 5.12\\right]^2$ 中均匀抽取 $\\mathbf{x}_0$。\n- 第 $k$ 步的提议：提议 $\\mathbf{x}' = \\mathbf{x} + \\boldsymbol{\\eta}$，其中 $\\boldsymbol{\\eta} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma^2 \\mathbf{I})$，然后如果 $\\mathbf{x}'$ 的任一分量超出定义域，则将其限制回 $\\left[-5.12, 5.12\\right]$。\n- 接受：令 $\\Delta = f(\\mathbf{x}') - f(\\mathbf{x})$。若 $\\Delta \\le 0$，则接受 $\\mathbf{x}'$。否则，以概率 $\\exp(-\\Delta/T(k))$ 接受，其中 $T(k) = p_1 \\exp(-p_2 k)$。\n- 追踪迄今最优值：维持 $f^\\star_k = \\min\\{f(\\mathbf{x}_0), f(\\mathbf{x}_1), \\dots, f(\\mathbf{x}_k)\\}$，并在一次包含 $N$ 次提议的运行结束时报告 $f^\\star_{N}$。\n\n为评估一个方案 $(p_1,p_2)$，将性能泛函定义为基于一个固定的随机种子列表，对终端迄今最优目标值求得的样本均值：\n$$\nJ(p_1,p_2) = \\frac{1}{S} \\sum_{s \\in \\mathcal{S}} f^\\star_{N}(s; p_1,p_2),\n$$\n其中 $\\mathcal{S}$ 是给定的种子集合，而 $S = |\\mathcal{S}|$。对于 $\\mathcal{S}$ 中的每个种子 $s$，使用 $s$ 初始化一个可复现的独立随机数生成器，以驱动初始点的生成以及所有后续的高斯和均匀抽样。您的程序必须在指定的有限网格 $\\mathcal{P}_1 \\times \\mathcal{P}_2$ 上进行搜索，并返回使 $J(p_1,p_2)$ 最小化的参数对 $(p_1,p_2) \\in \\mathcal{P}_1 \\times \\mathcal{P}_2$。如果 $J$ 的值出现平局，选择 $p_1$ 最小的参数对；如果仍然平局，则选择 $p_2$ 最小的参数对。\n\n角度单位：所有三角函数均使用弧度。\n\n为保证数值稳定性和确定性：\n- 每次评估均按规定使用独立种子，不使用任何其他随机性来源。\n- 指数函数应照常使用浮点运算进行求值；接受概率为 $\\min\\{1, \\exp(-\\Delta/T(k))\\}$。\n\n您的任务是实现一个程序，对下方的每个测试用例，在 $(p_1,p_2)$ 上执行穷举网格搜索，并输出最优的 $p_1$、$p_2$ 以及 $J(p_1,p_2)$ 的最小值，每个值都四舍五入到6位小数。\n\n测试套件（每个测试用例定义了 $(N, \\sigma, \\mathcal{S}, \\mathcal{P}_1, \\mathcal{P}_2)$）：\n- 用例 1（一般情况）：\n  - $N = 500$\n  - $\\sigma = 0.5$\n  - $\\mathcal{S} = [7, 11, 19]$\n  - $\\mathcal{P}_1 = [0.5, 1.0, 2.0, 5.0]$\n  - $\\mathcal{P}_2 = [0.001, 0.01, 0.05]$\n- 用例 2（边界包含恒定温度）：\n  - $N = 300$\n  - $\\sigma = 0.3$\n  - $\\mathcal{S} = [101, 202, 303]$\n  - $\\mathcal{P}_1 = [0.2, 0.8, 1.5, 3.0]$\n  - $\\mathcal{P}_2 = [0.0, 0.02, 0.1]$\n- 用例 3（更长的运行时间和更大的提议步长）：\n  - $N = 1000$\n  - $\\sigma = 0.8$\n  - $\\mathcal{S} = [5, 6]$\n  - $\\mathcal{P}_1 = [1.0, 3.0, 6.0]$\n  - $\\mathcal{P}_2 = [0.001, 0.005, 0.02]$\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。按数字顺序连接各个用例的三元组。对于每个用例，追加 $p_1^\\star$、$p_2^\\star$ 和 $J^\\star$（最小化的平均终端最优值），每个值都四舍五入到6位小数。例如，最终输出应类似于\n$[p_{1,1}^\\star,p_{2,1}^\\star,J_1^\\star,p_{1,2}^\\star,p_{2,2}^\\star,J_2^\\star,p_{1,3}^\\star,p_{2,3}^\\star,J_3^\\star]$,\n不含任何额外文本。", "solution": "所呈现的问题是一项元优化任务，具体而言，是为模拟退火算法进行超参数调优。目标是为指数降温方案 $T(k) = p_1 \\exp(-p_2 k)$ 确定最优参数 $(p_1, p_2)$，以在优化二维 Rastrigin 函数时最小化其平均终端性能。对这些最优参数的搜索被限制在给定的有限集合 $\\mathcal{P}_1$ 和 $\\mathcal{P}_2$ 上的穷举网格搜索。\n\n解决方案的核心是实现一个确定性过程，用于评估任何给定方案参数对的性能泛函 $J(p_1,p_2)$。该泛函定义为从一系列独立的模拟退火运行中获得的最佳目标值 $f^\\star_N$ 的样本均值，每次运行由给定集合 $\\mathcal{S}$ 中的唯一随机种子来区分。\n$$\nJ(p_1,p_2) = \\frac{1}{S} \\sum_{s \\in \\mathcal{S}} f^\\star_{N}(s; p_1,p_2)\n$$\n其中 $S = |\\mathcal{S}|$ 是运行次数。使用固定种子确保了对 $J(p_1,p_2)$ 的评估是完全确定且可复现的。\n\n用于计算 $f^\\star_N(s; p_1,p_2)$ 的每次独立模拟退火运行的结构如下：\n\n$1$. **初始化**：使用 $\\mathcal{S}$ 中的特定值 $s$ 为随机数生成器设定种子。从定义域 $[-5.12, 5.12]^2$ 上的均匀分布中抽取初始状态 $\\mathbf{x}_0 \\in \\mathbb{R}^2$。在 $\\mathbf{x}_0$ 处评估目标函数，即 $A=10$ 的二维 Rastrigin 函数：\n$$\nf(\\mathbf{x}) = 20 + \\sum_{i=1}^{2} \\left(x_i^2 - 10 \\cos(2 \\pi x_i)\\right)\n$$\n这个初始值 $f(\\mathbf{x}_0)$ 也同时初始化了迄今最优值 $f^\\star_0$。\n\n$2$. **迭代搜索**：算法进行固定的 $N$ 步。对于从 $0$ 到 $N-1$ 的每一步 $k$：\n    a. 根据降温方案计算温度 $T(k)$：$T(k) = p_1 \\exp(-p_2 k)$。\n    b. 通过用各向同性高斯噪声扰动当前状态 $\\mathbf{x}_k$ 来生成候选状态 $\\mathbf{x}'$：$\\mathbf{x}' = \\mathbf{x}_k + \\boldsymbol{\\eta}$，其中 $\\boldsymbol{\\eta} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma^2 \\mathbf{I})$。$\\mathbf{x}'$ 中任何超出定义域 $[-5.12, 5.12]$ 的分量都将被限制在相应的边界值。\n    c. 应用 Metropolis 接受准则。我们计算目标函数的变化量 $\\Delta = f(\\mathbf{x}') - f(\\mathbf{x}_k)$。如果 $\\Delta \\le 0$，则无条件接受候选状态（$\\mathbf{x}_{k+1} = \\mathbf{x}'$）。如果 $\\Delta > 0$，则以概率 $P_{\\text{accept}} = \\exp(-\\Delta / T(k))$ 接受它。如果未被接受，状态保持不变（$\\mathbf{x}_{k+1} = \\mathbf{x}_k$）。这通过抽取一个随机数 $u \\sim \\mathcal{U}(0,1)$ 并在 $u < P_{\\text{accept}}$ 时接受来实现。\n    d. 更新迄今为止所见到的最佳目标函数值的记录：$f^\\star_{k+1} = \\min(f^\\star_k, f(\\mathbf{x}_{k+1}))$。\n\n$3$. **终止**：在 $N$ 步之后，返回最终的迄今最优值 $f^\\star_N$。\n\n程序的最外层在指定的参数网格上执行此评估。对于每个测试用例，它会遍历 $\\mathcal{P}_1 \\times \\mathcal{P}_2$ 中的所有参数对 $(p_1, p_2)$。它为每对参数计算 $J(p_1, p_2)$，并追踪使该值最小化的参数对 $(p_1^\\star, p_2^\\star)$。为确保最优解的唯一定义，问题指定了一个平局决胜规则：如果两对参数产生相同的最小 $J$ 值，则选择 $p_1$ 较小的那一对。如果 $p_1$ 也相同，则选择 $p_2$ 较小的那一对。\n\n最终程序为三个测试用例中的每一个都实现了这套完整逻辑，收集每个用例的最优三元组 $(p_1^\\star, p_2^\\star, J^\\star)$。然后，这些结果被格式化并打印为单个逗号分隔的列表。数值计算使用 `numpy` 库进行，并遵循指定的依赖项。", "answer": "```python\nimport numpy as np\n\n# Define problem constants\nA = 10.0\nN_DIMS = 2\nDOMAIN_MIN = -5.12\nDOMAIN_MAX = 5.12\n\ndef rastrigin(x: np.ndarray) -> float:\n    \"\"\"\n    Computes the Rastrigin function for a 2D vector.\n    f(x) = An + sum(xi^2 - A*cos(2*pi*xi))\n    \"\"\"\n    if x.shape != (N_DIMS,):\n        raise ValueError(\"Input must be a 2D vector.\")\n    \n    constant_term = A * N_DIMS\n    sum_term = np.sum(x**2 - A * np.cos(2 * np.pi * x))\n    return constant_term + sum_term\n\ndef run_simulated_annealing(N: int, sigma: float, p1: float, p2: float, seed: int) -> float:\n    \"\"\"\n    Performs one full run of the simulated annealing algorithm.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    # Initialization\n    x_current = rng.uniform(DOMAIN_MIN, DOMAIN_MAX, size=N_DIMS)\n    f_current = rastrigin(x_current)\n    best_f_so_far = f_current\n\n    # Simulation loop\n    for k in range(N):\n        # Calculate temperature for step k\n        T_k = p1 * np.exp(-p2 * k)\n\n        # Generate proposal state\n        eta = rng.normal(loc=0.0, scale=sigma, size=N_DIMS)\n        x_proposal = x_current + eta\n        # Clamp proposal to the domain\n        x_proposal = np.clip(x_proposal, DOMAIN_MIN, DOMAIN_MAX)\n\n        f_proposal = rastrigin(x_proposal)\n        delta_f = f_proposal - f_current\n\n        # Metropolis acceptance criterion\n        accepted = False\n        if delta_f <= 0:\n            accepted = True\n        else:\n            # Avoid division by zero, although p1>0 and exp() is always >0\n            if T_k > 1e-12:\n                prob_acceptance = np.exp(-delta_f / T_k)\n                if rng.random() < prob_acceptance:\n                    accepted = True\n\n        if accepted:\n            x_current = x_proposal\n            f_current = f_proposal\n\n        # Update the best-so-far objective value found\n        if f_current < best_f_so_far:\n            best_f_so_far = f_current\n            \n    return best_f_so_far\n\ndef evaluate_schedule(N: int, sigma: float, seeds: list[int], p1: float, p2: float) -> float:\n    \"\"\"\n    Evaluates the performance functional J(p1, p2) by averaging over runs.\n    \"\"\"\n    total_f_star = 0.0\n    for seed in seeds:\n        f_star_N = run_simulated_annealing(N, sigma, p1, p2, seed)\n        total_f_star += f_star_N\n    return total_f_star / len(seeds)\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"N\": 500, \"sigma\": 0.5, \"S\": [7, 11, 19],\n            \"P1\": [0.5, 1.0, 2.0, 5.0], \"P2\": [0.001, 0.01, 0.05]\n        },\n        # Case 2\n        {\n            \"N\": 300, \"sigma\": 0.3, \"S\": [101, 202, 303],\n            \"P1\": [0.2, 0.8, 1.5, 3.0], \"P2\": [0.0, 0.02, 0.1]\n        },\n        # Case 3\n        {\n            \"N\": 1000, \"sigma\": 0.8, \"S\": [5, 6],\n            \"P1\": [1.0, 3.0, 6.0], \"P2\": [0.001, 0.005, 0.02]\n        }\n    ]\n\n    final_results = []\n    \n    for case in test_cases:\n        N, sigma, S_seeds, P1_grid, P2_grid = case[\"N\"], case[\"sigma\"], case[\"S\"], case[\"P1\"], case[\"P2\"]\n        \n        best_p1 = -1.0\n        best_p2 = -1.0\n        min_J = float('inf')\n\n        # Grid search over p1 and p2\n        for p1 in P1_grid:\n            for p2 in P2_grid:\n                current_J = evaluate_schedule(N, sigma, S_seeds, p1, p2)\n\n                # Check for new minimum, applying tie-breaking rules\n                is_better = False\n                if current_J < min_J:\n                    is_better = True\n                elif current_J == min_J:\n                    if p1 < best_p1:\n                        is_better = True\n                    elif p1 == best_p1 and p2 < best_p2:\n                        is_better = True\n                \n                if is_better:\n                    min_J = current_J\n                    best_p1 = p1\n                    best_p2 = p2\n        \n        # Append results for the current case\n        final_results.extend([best_p1, best_p2, min_J])\n\n    # Format the final output string\n    formatted_results = [f\"{val:.6f}\" for val in final_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "2435176"}]}