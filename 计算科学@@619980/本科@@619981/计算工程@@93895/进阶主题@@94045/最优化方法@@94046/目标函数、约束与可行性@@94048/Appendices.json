{"hands_on_practices": [{"introduction": "我们将以一个物理系统的平衡问题为例，学习如何将其建模为一个能量最小化问题。这个练习非常基础，因为它要求你从第一性原理出发，推导并求解 Karush-Kuhn-Tucker (KKT) 条件，这是约束优化理论的基石。通过这个实践，你将学会如何将抽象的数学条件与一个具体的物理状态联系起来，从而加深对理论的理解。[@problem_id:2407324]", "problem": "蜘蛛网的一个平面连接点被建模为一个点 $q \\in \\mathbb{R}^{2}$，该点通过三根弹性丝（理想线性弹簧）连接到固定的锚点 $a_{1}, a_{2}, a_{3} \\in \\mathbb{R}^{2}$。对于刚度为 $k$、静止长度为零的线性弹簧，其应变能是经过充分验证的公式 $U = \\tfrac{1}{2} k \\| \\Delta \\|^{2}$。通过选择一致的单位制和缩放，可将所有弹簧刚度取为 $k = 1$，因此三根丝的总弹性势能为\n$$\nE(q) = \\frac{1}{2} \\sum_{i=1}^{3} \\| q - a_{i} \\|^{2}.\n$$\n为确保材料安全，每根丝的长度都受限于一个最大允许值 $d_{i} > 0$，这被建模为不等式约束\n$$\n\\| q - a_{i} \\| \\le d_{i}, \\quad i \\in \\{1,2,3\\}.\n$$\n这就将连接点的平衡问题定义为一个约束能量最小化问题。\n\n任务：\n- 使用显式函数 $g_{i}(\\cdot)$，根据目标函数 $E(q)$ 和不等式约束 $g_{i}(q) \\le 0$ 建立该约束优化问题。\n- 从约束优化的第一性原理出发，推导此问题的 Karush–Kuhn–Tucker (KKT) 条件（平稳性、原始可行性、对偶可行性和互补松弛性）。不要假设任何快捷公式；从拉格朗日函数开始，并显式地求梯度。\n- 针对以下具体数据：$a_{1} = (0,0)$，$a_{2} = (2,0)$，$a_{3} = (0,2)$，以及边界值 $d_{1} = \\tfrac{1}{2}$，$d_{2} = 2$，$d_{3} = 2$。求解 KKT 系统，以找到唯一的最优节点位置 $q^{\\star} = (x^{\\star}, y^{\\star})$ 和非零的拉格朗日乘子。提供精确值，而非四舍五入值。如果存在多个非零拉格朗日乘子，请全部报告；如果只有一个非零，则仅报告该乘子。\n\n答案格式：\n- 你的最终答案必须是单一的闭式解析表达式。按顺序报告三元组 $(x^{\\star}, y^{\\star}, \\lambda_{1}^{\\star})$。无需单位。不要四舍五入。", "solution": "该问题陈述具有科学依据、良构、客观且自洽。它代表了计算力学中的一个标准约束优化问题。因此，该问题是有效的，并将推导求解。\n\n任务是找到连接点的平衡位置 $q^\\star = (x^\\star, y^\\star)$，方法是在连接丝的长度约束下最小化总弹性势能。\n\n首先，我们建立该约束优化问题。优化变量是节点的位置 $q = (x, y) \\in \\mathbb{R}^{2}$。\n要最小化的目标函数是总弹性势能：\n$$\nE(q) = \\frac{1}{2} \\sum_{i=1}^{3} \\| q - a_{i} \\|^{2}\n$$\n不等式约束由 $\\| q - a_{i} \\| \\le d_{i}$ 给出，其中 $i \\in \\{1, 2, 3\\}$。为确保约束函数处处可微，我们对不等式两边进行平方，这是一个等价变换，因为两边都是非负的。这就得到了标准形式 $g_{i}(q) \\le 0$，其中：\n$$\ng_{i}(q) = \\| q - a_{i} \\|^{2} - d_{i}^{2} \\le 0\n$$\n因此，问题是：\n$$\n\\min_{q \\in \\mathbb{R}^2} E(q) \\quad \\text{subject to} \\quad g_{i}(q) \\le 0, \\quad i \\in \\{1, 2, 3\\}\n$$\n\n接下来，我们从第一性原理推导 Karush-Kuhn-Tucker (KKT) 条件。此问题的拉格朗日函数 $\\mathcal{L}$ 定义为：\n$$\n\\mathcal{L}(q, \\lambda) = E(q) + \\sum_{i=1}^{3} \\lambda_{i} g_{i}(q)\n$$\n其中 $\\lambda = (\\lambda_{1}, \\lambda_{2}, \\lambda_{3})$ 是拉格朗日乘子向量。对于一个最优解 $(q^\\star, \\lambda^\\star)$，必须满足 KKT 条件：\n$1$. 平稳性：拉格朗日函数关于 $q$ 的梯度必须为零。\n$$\n\\nabla_{q} \\mathcal{L}(q^{\\star}, \\lambda^{\\star}) = \\nabla_{q} E(q^{\\star}) + \\sum_{i=1}^{3} \\lambda_{i}^{\\star} \\nabla_{q} g_{i}(q^{\\star}) = 0\n$$\n$2$. 原始可行性：解 $q^\\star$ 必须满足所有约束。\n$$\ng_{i}(q^{\\star}) \\le 0, \\quad \\forall i \\in \\{1, 2, 3\\}\n$$\n$3$. 对偶可行性：所有拉格朗日乘子必须非负。\n$$\n\\lambda_{i}^{\\star} \\ge 0, \\quad \\forall i \\in \\{1, 2, 3\\}\n$$\n$4$. 互补松弛性：每个乘子与其对应约束函数的乘积必须为零。\n$$\n\\lambda_{i}^{\\star} g_{i}(q^{\\star}) = 0, \\quad \\forall i \\in \\{1, 2, 3\\}\n$$\n我们计算必要的梯度。\n目标函数的梯度是：\n$$\n\\nabla_{q} E(q) = \\nabla_{q} \\left( \\frac{1}{2} \\sum_{i=1}^{3} (q - a_{i}) \\cdot (q - a_{i}) \\right) = \\sum_{i=1}^{3} (q - a_{i}) = 3q - \\sum_{i=1}^{3} a_{i}\n$$\n约束函数的梯度是：\n$$\n\\nabla_{q} g_{i}(q) = \\nabla_{q} \\left( \\|q - a_{i}\\|^{2} - d_{i}^{2} \\right) = 2(q - a_{i})\n$$\n将这些代入平稳性条件，得到：\n$$\n\\left( 3q^{\\star} - \\sum_{i=1}^{3} a_{i} \\right) + \\sum_{i=1}^{3} \\lambda_{i}^{\\star} (2(q^{\\star} - a_{i})) = 0\n$$\n\n现在，我们针对给定的具体数据求解 KKT 系统：$a_{1} = (0,0)$，$a_{2} = (2,0)$，$a_{3} = (0,2)$，以及 $d_{1} = \\frac{1}{2}$，$d_{2} = 2$，$d_{3} = 2$。\n令 $q = (x,y)$。目标函数为：\n$$\nE(x,y) = \\frac{1}{2} \\left[ (x^{2} + y^{2}) + ((x-2)^{2} + y^{2}) + (x^{2} + (y-2)^{2}) \\right] = \\frac{1}{2} (3x^{2} - 4x + 3y^{2} - 4y + 8)\n$$\n约束为：\n$g_{1}(x,y) = x^{2} + y^{2} - (\\frac{1}{2})^{2} = x^{2} + y^{2} - \\frac{1}{4} \\le 0$\n$g_{2}(x,y) = (x-2)^{2} + y^{2} - 2^{2} = (x-2)^{2} + y^{2} - 4 \\le 0$\n$g_{3}(x,y) = x^{2} + (y-2)^{2} - 2^{2} = x^{2} + (y-2)^{2} - 4 \\le 0$\n\n首先，我们通过将其梯度设为零来求 $E(q)$ 的无约束最小值：\n$\\nabla_{q} E(q) = (3x-2, 3y-2) = (0,0)$。\n这得出无约束解 $q_{unc} = (\\frac{2}{3}, \\frac{2}{3})$。\n我们通过计算约束来检查此解是否可行：\n$g_{1}(q_{unc}) = (\\frac{2}{3})^{2} + (\\frac{2}{3})^{2} - \\frac{1}{4} = \\frac{4}{9} + \\frac{4}{9} - \\frac{1}{4} = \\frac{8}{9} - \\frac{1}{4} = \\frac{32-9}{36} = \\frac{23}{36} > 0$。\n第一个约束被违反。因此，最优解必定位于可行域的边界上。\n$g_{2}(q_{unc}) = (\\frac{2}{3}-2)^{2} + (\\frac{2}{3})^{2} - 4 = (-\\frac{4}{3})^{2} + \\frac{4}{9} - 4 = \\frac{16}{9} + \\frac{4}{9} - 4 = \\frac{20}{9} - \\frac{36}{9} = -\\frac{16}{9} < 0$。\n$g_{3}(q_{unc}) = (\\frac{2}{3})^{2} + (\\frac{2}{3}-2)^{2} - 4 = \\frac{4}{9} + (-\\frac{4}{3})^{2} - 4 = -\\frac{16}{9} < 0$。\n由于无约束解仅违反了第一个约束，可以合理地假设约束最优解 $q^{\\star}$ 将只有第一个约束是激活的。这意味着 $g_{1}(q^{\\star})=0$，并且 $g_{2}(q^{\\star})<0, g_{3}(q^{\\star})<0$。\n根据互补松弛性，这意味着 $\\lambda_{1}^{\\star} > 0$，$\\lambda_{2}^{\\star}=0$ 且 $\\lambda_{3}^{\\star}=0$。\n\n平稳性条件简化为 $\\nabla_{q} E(q^{\\star}) + \\lambda_{1}^{\\star} \\nabla_{q} g_{1}(q^{\\star}) = 0$。\n代入梯度的表达式：\n$(3x^{\\star}-2, 3y^{\\star}-2) + \\lambda_{1}^{\\star} (2x^{\\star}, 2y^{\\star}) = (0,0)$。\n这得到一个包含两个方程的方程组：\n$1$. $3x^{\\star} - 2 + 2\\lambda_{1}^{\\star} x^{\\star} = 0 \\implies x^{\\star}(3 + 2\\lambda_{1}^{\\star}) = 2$\n$2$. $3y^{\\star} - 2 + 2\\lambda_{1}^{\\star} y^{\\star} = 0 \\implies y^{\\star}(3 + 2\\lambda_{1}^{\\star}) = 2$\n从这些方程中，我们可以看出 $x^{\\star} = y^{\\star}$（因为当 $\\lambda_1^\\star > 0$ 时，$3+2\\lambda_1^\\star$ 不可能为零）。\n我们使用激活约束条件 $g_{1}(q^{\\star}) = 0$：\n$(x^{\\star})^{2} + (y^{\\star})^{2} - \\frac{1}{4} = 0$。\n代入 $y^{\\star} = x^{\\star}$：\n$2(x^{\\star})^{2} = \\frac{1}{4} \\implies (x^{\\star})^{2} = \\frac{1}{8}$。\n这得到 $x^{\\star} = \\pm \\frac{1}{\\sqrt{8}} = \\pm \\frac{1}{2\\sqrt{2}} = \\pm \\frac{\\sqrt{2}}{4}$。\n无约束最小值 $(\\frac{2}{3}, \\frac{2}{3})$ 位于第一象限。约束最小值必须是圆 $x^{2}+y^{2}=\\frac{1}{4}$ 上距离 $(\\frac{2}{3}, \\frac{2}{3})$ 最近的点，该点也必须位于第一象限。因此，我们选择正解。\n$x^{\\star} = \\frac{\\sqrt{2}}{4}$ 且 $y^{\\star} = \\frac{\\sqrt{2}}{4}$。\n所以，$q^{\\star} = (\\frac{\\sqrt{2}}{4}, \\frac{\\sqrt{2}}{4})$。\n\n现在我们从平稳性方程求解 $\\lambda_{1}^{\\star}$：\n$x^{\\star}(3 + 2\\lambda_{1}^{\\star}) = 2 \\implies 3 + 2\\lambda_{1}^{\\star} = \\frac{2}{x^{\\star}} = \\frac{2}{\\sqrt{2}/4} = \\frac{8}{\\sqrt{2}} = 4\\sqrt{2}$。\n$2\\lambda_{1}^{\\star} = 4\\sqrt{2} - 3 \\implies \\lambda_{1}^{\\star} = \\frac{4\\sqrt{2} - 3}{2}$。\n\n我们必须验证我们的解 $(q^{\\star}, \\lambda^{\\star})$，其中 $q^{\\star}=(\\frac{\\sqrt{2}}{4}, \\frac{\\sqrt{2}}{4})$ 且 $\\lambda^{\\star}=(\\frac{4\\sqrt{2}-3}{2}, 0, 0)$，满足所有KKT条件。\n$1$. 平稳性：根据构造已满足。\n$2$. 对偶可行性：$\\lambda_2^\\star=0, \\lambda_3^\\star=0$。对于 $\\lambda_1^\\star$，因为 $4\\sqrt{2} = \\sqrt{32}$ 且 $3 = \\sqrt{9}$，我们有 $4\\sqrt{2} > 3$，所以 $\\lambda_{1}^{\\star} > 0$。条件满足。\n$3$. 原始可行性：\n$g_{1}(q^\\star) = (\\frac{\\sqrt{2}}{4})^2 + (\\frac{\\sqrt{2}}{4})^2 - \\frac{1}{4} = \\frac{2}{16} + \\frac{2}{16} - \\frac{1}{4} = \\frac{4}{16} - \\frac{1}{4} = 0$。（满足）\n$g_{2}(q^\\star) = (\\frac{\\sqrt{2}}{4}-2)^2 + (\\frac{\\sqrt{2}}{4})^2 - 4 = \\frac{2-16\\sqrt{2}+64}{16} + \\frac{2}{16} - 4 = \\frac{68-16\\sqrt{2}}{16} - 4 = \\frac{17-4\\sqrt{2}}{4} - \\frac{16}{4} = \\frac{1 - 4\\sqrt{2}}{4}$。因为 $4\\sqrt{2} > 1$，此值为负。（满足）\n$g_{3}(q^\\star) = (\\frac{\\sqrt{2}}{4})^2 + (\\frac{\\sqrt{2}}{4}-2)^2 - 4 = g_{2}(q^\\star) = \\frac{1 - 4\\sqrt{2}}{4} < 0$。（满足）\n$4$. 互补松弛性：\n$\\lambda_1^\\star g_1(q^\\star) = \\lambda_1^\\star \\cdot 0 = 0$。（满足）\n$\\lambda_2^\\star g_2(q^\\star) = 0 \\cdot g_2(q^\\star) = 0$。（满足）\n$\\lambda_3^\\star g_3(q^\\star) = 0 \\cdot g_3(q^\\star) = 0$。（满足）\n\n所有KKT条件均已满足。由于目标函数是严格凸的，且可行域（闭圆盘的交集）是凸的，KKT条件是唯一全局最小值的充分条件。最优节点位置是 $q^{\\star} = (\\frac{\\sqrt{2}}{4}, \\frac{\\sqrt{2}}{4})$，唯一的非零拉格朗日乘子是 $\\lambda_{1}^{\\star} = \\frac{4\\sqrt{2}-3}{2}$。\n\n最终答案是三元组 $(x^{\\star}, y^{\\star}, \\lambda_{1}^{\\star})$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{\\sqrt{2}}{4} & \\frac{\\sqrt{2}}{4} & \\frac{4\\sqrt{2}-3}{2}\n\\end{pmatrix}\n}\n$$", "id": "2407324"}, {"introduction": "这项实践将我们从物理系统带到几何领域，挑战在于如何为复杂形状定义并找到一个“中心点”，这在机器人路径规划、设施选址等领域中是一个常见任务。这个练习将引导你如何将一个几何目标（最小化到集合内任意点的最大距离）转化为一个标准的、可求解的优化问题。它强调了洞察问题数学本质（如此处的凸包）并将之形式化的重要性，这是工程问题求解的关键一步。[@problem_id:2420377]", "problem": "给定一个由简单多边形的并集描述的平面可行域族。对于每个区域，将其极小化极大中心（minimax center）定义为欧几里得平面中的一个点，该点到区域内任何点的最大欧几里得距离最小。形式上，对于一个非空紧可行集 $\\mathcal{S} \\subset \\mathbb{R}^2$，定义目标函数\n$$\nf(\\mathbf{x}) = \\max_{\\mathbf{y} \\in \\mathcal{S}} \\lVert \\mathbf{x} - \\mathbf{y} \\rVert_2,\n$$\n并将极小化极大中心定义为 $f(\\mathbf{x})$ 的任何一个极小点 $\\mathbf{x}^\\star \\in \\mathbb{R}^2$。相应的最优目标值是极小化极大半径（minimax radius）$r^\\star = f(\\mathbf{x}^\\star)$。注意，$\\mathbf{x}^\\star$ 不要求属于 $\\mathcal{S}$。\n\n您的任务是编写一个完整的程序，对每个指定的测试用例，计算其极小化极大中心 $\\mathbf{x}^\\star$ 和极小化极大半径 $r^\\star$，并以数值形式报告它们。\n\n每个测试用例的可行区域是在 $\\mathbb{R}^2$ 中一个或多个简单多边形的并集，这些多边形由其顶点的逆时针顺序列表给出。每个多边形是由连接连续顶点（最后一个顶点连接回第一个顶点）的直线边所围成的填充区域。所有坐标都以无量纲的笛卡尔单位表示。\n\n您必须遵守以下要求：\n\n- 纯粹从数学角度处理问题：给定 $\\mathcal{S}$ 为多边形的并集，计算能最小化上述定义的 $f(\\mathbf{x})$ 的 $\\mathbf{x}^\\star \\in \\mathbb{R}^2$ 和 $r^\\star \\in \\mathbb{R}_{\\ge 0}$。\n- 答案不需要物理单位，也不需要角度。\n- 您的程序不能硬编码答案。它必须实现一个通用的求解器来完成所述任务。\n\n需要实现和求解的测试套件：\n\n- 用例 $\\mathbf{1}$（两个不相交正方形的非凸并集）：\n  - 多边形 $\\mathbf{A}$ 顶点：$\\left(-4,-1\\right)$, $\\left(-2,-1\\right)$, $\\left(-2,1\\right)$, $\\left(-4,1\\right)$。\n  - 多边形 $\\mathbf{B}$ 顶点：$\\left(2,-1\\right)$, $\\left(4,-1\\right)$, $\\left(4,1\\right)$, $\\left(2,1\\right)$。\n\n- 用例 $\\mathbf{2}$（近乎共线的细长矩形，一个边界条件）：\n  - 单个多边形，顶点为：$\\left(0,0\\right)$, $\\left(10,0\\right)$, $\\left(10,0.001\\right)$, $\\left(0,0.001\\right)$。\n\n- 用例 $\\mathbf{3}$（凹U形多边形）：\n  - 单个多边形，顶点为：$\\left(-3,-2\\right)$, $\\left(3,-2\\right)$, $\\left(3,2\\right)$, $\\left(1,2\\right)$, $\\left(1,0\\right)$, $\\left(-1,0\\right)$, $\\left(-1,2\\right)$, $\\left(-3,2\\right)$。\n\n- 用例 $\\mathbf{4}$（由三点确定最优解的锐角三角形）：\n  - 单个多边形，顶点为：$\\left(0,0\\right)$, $\\left(2,0\\right)$, $\\left(1,\\sqrt{3}\\right)$。\n\n您的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。对于每个用例，按照上述用例的顺序，输出一个包含三个浮点数 $\\left[x^\\star, y^\\star, r^\\star\\right]$ 的列表，每个数值精确到 $6$ 位小数。因此，最终输出必须是以下形式：\n$$\n\\left[\\left[x^\\star_1,y^\\star_1,r^\\star_1\\right],\\left[x^\\star_2,y^\\star_2,r^\\star_2\\right],\\left[x^\\star_3,y^\\star_3,r^\\star_3\\right],\\left[x^\\star_4,y^\\star_4,r^\\star_4\\right]\\right].\n$$\n例如，输出格式应类似于 $\\left[\\left[0.000000,0.000000,1.234567\\right],\\ldots\\right]$，不含空格。\n\n您的实现必须是一个完整的、可运行的程序，该程序在内部构建上述测试用例并打印所需的单行输出。", "solution": "所述问题是有效的。这是一个在计算几何领域内适定（well-posed）的优化问题，其表述客观而精确。所有必要的数据均已提供。我将着手提供一个解决方案。\n\n该问题要求为给定的紧集 $\\mathcal{S} \\subset \\mathbb{R}^2$ 计算其极小化极大中心 $\\mathbf{x}^\\star \\in \\mathbb{R}^2$ 和相应的极小化极大半径 $r^\\star \\in \\mathbb{R}_{\\ge 0}$。集合 $\\mathcal{S}$ 被描述为简单多边形的并集。极小化极大中心是使得到 $\\mathcal{S}$ 中任意点的最大欧几里得距离最小化的点。这可以形式化地表述为找到 $\\mathbf{x}^\\star = \\arg\\min_{\\mathbf{x} \\in \\mathbb{R}^2} f(\\mathbf{x})$，其中目标函数为 $f(\\mathbf{x}) = \\max_{\\mathbf{y} \\in \\mathcal{S}} \\lVert \\mathbf{x} - \\mathbf{y} \\rVert_2$。这等价于寻找集合 $\\mathcal{S}$ 的最小包围圆的圆心和半径。\n\n凸分析的一条基本原则指明了求解的路径。对于任何固定点 $\\mathbf{x}$，函数 $g(\\mathbf{y}) = \\lVert \\mathbf{x} - \\mathbf{y} \\rVert_2$ 是关于 $\\mathbf{y}$ 的凸函数。定义在紧集上的凸函数在其凸包的极点处达到最大值。给定的集合 $\\mathcal{S}$ 是多边形的并集，它是一个紧集。令 $\\text{conv}(\\mathcal{S})$ 表示 $\\mathcal{S}$ 的凸包。$\\text{conv}(\\mathcal{S})$ 的极点是输入多边形顶点集的一个子集。\n\n令 $V$ 为构成 $\\mathcal{S}$ 的所有多边形的所有顶点的集合。$\\mathcal{S}$ 的凸包与其顶点的凸包相同，即 $\\text{conv}(\\mathcal{S}) = \\text{conv}(V)$。令 $V_{\\text{ext}} \\subseteq V$ 为构成 $\\text{conv}(V)$ 边界的顶点集。因此，目标函数可以被简化，因为从 $\\mathbf{x}$ 到 $\\mathcal{S}$ 中任意点的最大距离将是到这些极值顶点之一的最大距离：\n$$\nf(\\mathbf{x}) = \\max_{\\mathbf{y} \\in \\mathcal{S}} \\lVert \\mathbf{x} - \\mathbf{y} \\rVert_2 = \\max_{\\mathbf{y} \\in \\text{conv}(\\mathcal{S})} \\lVert \\mathbf{x} - \\mathbf{y} \\rVert_2 = \\max_{\\mathbf{v} \\in V_{\\text{ext}}} \\lVert \\mathbf{x} - \\mathbf{v} \\rVert_2\n$$\n这将问题从处理 $\\mathcal{S}$ 中的无限点集简化为处理一个有限点集 $V_{\\text{ext}}$。现在的任务是为这个有限点集 $V_{\\text{ext}}$ 找到最小包围圆。\n\n这个问题可以被表述为一个凸优化问题。设圆的未知圆心为 $\\mathbf{x} = (x, y)$，半径为 $r$。我们想要最小化 $r$，这等同于最小化 $r^2$。约束条件是所有点 $\\mathbf{v}_i \\in V_{\\text{ext}}$ 必须位于该圆的内部或边界上。这在数学上表示为：\n$$\n\\lVert \\mathbf{x} - \\mathbf{v}_i \\rVert_2 \\le r \\quad \\forall \\mathbf{v}_i \\in V_{\\text{ext}}\n$$\n为了构建一个更便于标准求解器处理的公式，我们使用半径的平方 $R = r^2$ 和距离的平方：\n$$\n\\lVert \\mathbf{x} - \\mathbf{v}_i \\rVert_2^2 \\le R \\quad \\forall \\mathbf{v}_i \\in V_{\\text{ext}}\n$$\n令 $\\mathbf{v}_i = (v_{ix}, v_{iy})$，优化问题为：\n$$\n\\min_{x, y, R} R\n$$\n约束条件为：\n$$\n(x - v_{ix})^2 + (y - v_{iy})^2 - R \\le 0 \\quad \\forall \\mathbf{v}_i \\in V_{\\text{ext}}\n$$\n$$\nR \\ge 0\n$$\n这是一个具有线性目标函数和凸二次约束的二次约束规划（Quadratically Constrained Program, QCP）。它可以使用标准的优化算法进行数值求解。\n\n算法流程如下：\n$1$. 对每个测试用例，将所有给定多边形的顶点聚合到一个点集 $V$ 中。\n$2$. 计算点集 $V$ 的凸包，以确定极值顶点 $V_{\\text{ext}}$。这可以通过使用 `scipy.spatial` 库中的 `ConvexHull` 函数来完成。\n$3$. 求解上述的 QCP 问题。我们采用 `scipy.optimize` 中的 `minimize` 函数，并使用序列最小二乘规划（`SLSQP`）方法。优化变量是 $(x, y, R)$。\n$4$. 传递给求解器的目标函数就是 $R$。\n$5$. 约束被表述为一系列函数，对于 $V_{\\text{ext}}$ 中的每个顶点 $\\mathbf{v}_i$，确保 $(x - v_{ix})^2 + (y - v_{iy})^2 - R \\le 0$。同时对 $R$ 施加非负性界限。\n$6$. 构建一个优化的初始猜测值。使用 $V_{\\text{ext}}$ 的质心作为初始中心 $(x_0, y_0)$，初始半径平方 $R_0$ 为从该质心到 $V_{\\text{ext}}$ 中任意顶点的最大平方距离。\n$7$. 求解器迭代地改进这个猜测值，以找到最优解 $(x^\\star, y^\\star, R^\\star)$。\n$8$. 最终的极小化极大中心是 $\\mathbf{x}^\\star = (x^\\star, y^\\star)$，极小化极大半径是 $r^\\star = \\sqrt{R^\\star}$。对问题陈述中描述的每个测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial import ConvexHull\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve the minimax center problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: non-convex union of two disjoint squares\n        [[(-4,-1), (-2,-1), (-2,1), (-4,1)],\n         [(2,-1), (4,-1), (4,1), (2,1)]],\n        # Case 2: nearly colinear thin rectangle\n        [[ (0,0), (10,0), (10,0.001), (0,0.001)]],\n        # Case 3: concave U-shaped polygon\n        [[(-3,-2), (3,-2), (3,2), (1,2), (1,0), (-1,0), (-1,2), (-3,2)]],\n        # Case 4: acute triangle\n        [[(0,0), (2,0), (1,math.sqrt(3))]]\n    ]\n\n    def compute_minimax_center(polygons):\n        \"\"\"\n        Computes the minimax center and radius for a set of polygons.\n\n        The problem is reduced to finding the smallest enclosing circle of the\n        set of vertices of the convex hull of the union of the polygons. This\n        is solved as a convex optimization problem.\n        \"\"\"\n        # 1. Aggregate all vertices from all polygons\n        all_vertices = np.vstack([np.array(p, dtype=float) for p in polygons])\n        \n        # Handle cases with few points where ConvexHull would fail\n        unique_vertices = np.unique(all_vertices, axis=0)\n        \n        if unique_vertices.shape[0] < 2:\n            center = unique_vertices[0]\n            return center[0], center[1], 0.0\n\n        if unique_vertices.shape[0] == 2:\n            p1, p2 = unique_vertices[0], unique_vertices[1]\n            center = (p1 + p2) / 2.0\n            radius = np.linalg.norm(p1 - p2) / 2.0\n            return center[0], center[1], radius\n\n        # 2. Compute the convex hull of the vertices\n        try:\n            hull = ConvexHull(unique_vertices)\n            hull_vertices = unique_vertices[hull.vertices]\n        except: # QhullError often for colinear points\n             # For colinear points, the smallest enclosing circle's diameter\n             # is the distance between the two extreme points.\n            max_dist = 0\n            p1_max, p2_max = None, None\n            for i in range(len(unique_vertices)):\n                for j in range(i + 1, len(unique_vertices)):\n                    dist = np.linalg.norm(unique_vertices[i] - unique_vertices[j])\n                    if dist > max_dist:\n                        max_dist = dist\n                        p1_max = unique_vertices[i]\n                        p2_max = unique_vertices[j]\n            center = (p1_max + p2_max) / 2.0\n            radius = max_dist / 2.0\n            return center[0], center[1], radius\n\n        # 3. Set up the optimization problem\n        # Variables: p = [x, y, r_squared]\n\n        # Initial guess based on the centroid of the hull vertices\n        initial_center = np.mean(hull_vertices, axis=0)\n        initial_r_squared = np.max(np.sum((hull_vertices - initial_center)**2, axis=1))\n        p0 = np.array([initial_center[0], initial_center[1], initial_r_squared])\n\n        # Objective function: minimize r_squared (p[2])\n        objective = lambda p: p[2]\n\n        # Constraints: (x - v_x)^2 + (y - v_y)^2 <= r_squared for each v in hull_vertices\n        # The form for SLSQP is fun(p) >= 0.\n        constraints = []\n        for v in hull_vertices:\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda p, v_pt=v: p[2] - ((p[0] - v_pt[0])**2 + (p[1] - v_pt[1])**2)\n            })\n\n        # Bounds for variables: r_squared must be non-negative\n        bounds = [(None, None), (None, None), (0, None)]\n\n        # 4. Run the optimizer\n        result = minimize(\n            objective,\n            p0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            tol=1e-12, # High tolerance for precision\n            options={'maxiter': 1000}\n        )\n        \n        if not result.success:\n            raise RuntimeError(f\"Optimization failed: {result.message}\")\n\n        # 5. Extract and return the results\n        x_star, y_star, r_squared_star = result.x\n        r_star = np.sqrt(r_squared_star)\n\n        return x_star, y_star, r_star\n\n    results = []\n    for case_polygons in test_cases:\n        x_star, y_star, r_star = compute_minimax_center(case_polygons)\n        results.append(f\"[{x_star:.6f},{y_star:.6f},{r_star:.6f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2420377"}, {"introduction": "在我们最后的实践中，我们将解决一个源自计算设计与现代制造业的前沿问题。我们的目标是设计一座质量最轻的桥梁，同时满足增材制造（3D打印）过程中的自支撑约束，即结构在打印的每一层都必须是稳定的。这个练习不仅能让你了解如何将实际的制造限制整合进优化模型中，还能让你掌握如何运用动态规划这一强大工具来解决网格上的复杂路径规划问题。[@problem_id:2420423]", "problem": "您必须编写一个完整的程序，在给定的离散化二维桥梁设计空间中，计算连接两个基座锚点的、在逐层制造约束下的最小质量自支撑结构。最终结构在每个中间打印阶段都必须是可行的。\n\n数学模型。考虑一个由立方体素组成的矩形晶格，其水平索引为 $i \\in \\{0,1,\\dots,W-1\\}$，垂直层索引为 $j \\in \\{0,1,\\dots,H\\}$，其中 $W$ 是域宽度，$H$ 是基板（第 $j=0$ 层）之上允许打印的最大层数。一个二进制设计变量 $x_{i,j} \\in \\{0,1\\}$ 表示坐标为 $(i,j)$ 的体素是否被打印。目标是最小化总质量，该质量被建模为所有打印体素的总和，\n$$\n\\min \\; M(x) = \\sum_{j=0}^{H}\\sum_{i=0}^{W-1} x_{i,j}.\n$$\n制造可行性是通过一个离散的自支撑约束来施加的，该约束源于熔融沉积成型（FDM）的逐层打印特性。具体来说，对于给定的每层最大水平支撑偏移量 $s \\in \\mathbb{Z}_{\\ge 1}$，每个在基板上方的打印体素，在其正下方一层内，必须在最大水平距离 $s$ 范围内至少有一个支撑体素：\n$$\n\\forall\\, j \\in \\{1,\\dots,H\\}, \\; \\forall\\, i \\in \\{0,\\dots,W-1\\}:\\quad\nx_{i,j} = 1 \\;\\Rightarrow\\; \\sum_{k=\\max(0,i-s)}^{\\min(W-1,i+s)} x_{k,j-1} \\ge 1.\n$$\n第 $j=0$ 层的基座体素被视为由构建板支撑，因此不受上述约束的限制。桥梁必须连接位于 $(0,0)$ 和 $(W-1,0)$ 的两个基座锚点。连通性通过向上的自支撑步骤来定义：一条自支撑路径是一系列被占用的体素 $\\{(i_t,j_t)\\}_{t=0}^{T}$，满足对于所有的 $t$ 都有 $j_{t+1}=j_t+1$ 且 $|i_{t+1}-i_t| \\le s$。如果存在两条自支撑路径，一条从 $(0,0)$ 开始，另一条从 $(W-1,0)$ 开始，并且它们终止于一个共同的体素，同时所有打印的体素都满足自支撑规则，则该设计是可行的。在所有这类可行设计中，质量 $M(x)$ 必须被最小化。所有参数均为整数，满足 $W \\in \\mathbb{Z}_{\\ge 1}$，$H \\in \\mathbb{Z}_{\\ge 0}$，以及 $s \\in \\mathbb{Z}_{\\ge 1}$。\n\n您的任务。从上述基本定义出发，推导出一个算法，该算法在给定 $(W,H,s)$ 的情况下，如果问题有可行解，则返回 $M(x)$ 的最小可能值；如果不存在可行设计，则返回 $-1$。对于满足所述边界条件的所有输入，您的算法都必须是正确的。不涉及物理单位。\n\n测试套件。您的程序必须为以下参数集计算结果，每个参数集以三元组 $(W,H,s)$ 的形式提供：\n- 情况 A: $(W,H,s) = (9,5,1)$\n- 情况 B: $(W,H,s) = (13,3,2)$\n- 情况 C: $(W,H,s) = (11,4,1)$\n- 情况 D: $(W,H,s) = (1,0,1)$\n- 情况 E: $(W,H,s) = (20,4,3)$\n\n最终输出格式。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序与上述情况相同。每个条目必须是一个整数：如果可行，则为最小质量；如果不可行，则为 $-1$。例如，输出可能看起来像 $[3,5,-1,7,9]$（这只是一个例子，不是给定情况的正确答案）。", "solution": "所呈现的问题陈述是计算工程领域内一个适定的优化问题。它具有科学依据，是客观的，并包含足够的信息来推导出唯一的解决方案。定义精确且无矛盾。因此，该问题是有效的，并且可以推导出严谨的解决方案。\n\n任务是在一个 $W \\times (H+1)$ 的体素网格上，找到一个连接两个锚点 $(0,0)$ 和 $(W-1,0)$ 的最小质量结构，该结构需满足逐层自支撑的约束。\n\n目标是最小化总质量，即活动体素 $x_{i,j}=1$ 的数量：\n$$\nM(x) = \\sum_{j=0}^{H}\\sum_{i=0}^{W-1} x_{i,j}\n$$\n\n一个可行的结构必须满足两个条件：\n1. 连通性要求：必须存在两条自支撑路径，一条源自左侧锚点 $(0,0)$，另一条源自右侧锚点 $(W-1,0)$，并在一个共同的体素处汇合。自支撑路径是一系列体素 $\\{(i_t, j_t)\\}_{t=0}^{T}$，其中每个后续体素 $(i_{t+1}, j_{t+1})$ 满足 $j_{t+1} = j_t+1$ 且 $|i_{t+1}-i_t| \\le s$。\n2. 全局自支撑规则：对于 $j \\ge 1$，每个活动体素 $x_{i,j}=1$ 都必须由其正下方一层内、水平距离 $s$ 范围内的至少一个活动体素支撑。这表示为：\n$$\nx_{i,j} = 1 \\implies \\exists k \\in [\\max(0, i-s), \\min(W-1, i+s)] \\text{ s.t. } x_{k,j-1} = 1\n$$\n\n最优性原理表明，一个最小质量的结构不会包含任何多余的体素。任何不属于连接路径或不提供必要支撑的体素都将被移除以减少质量。因此，最小结构恰好由两条自支撑路径的并集构成。因此，问题等价于找到这样的两条路径，使其体素的并集最小。\n\n该问题结构适合使用动态规划来解决。我们通过层索引以及两条增长路径端点的水平位置来定义一个状态。设 $dp[j][i_L][i_R]$ 为由两条分别源自 $(0,0)$ 和 $(W-1,0)$ 的自支撑路径组成的结构的最小可能质量，这两条路径终止于第 $j$ 层，水平位置分别为 $i_L$ 和 $i_R$。\n\n状态空间定义为 $j \\in \\{0, \\dots, H\\}$, $i_L \\in \\{0, \\dots, W-1\\}$, 和 $i_R \\in \\{0, \\dots, W-1\\}$。\n\n基本情况是第 $j=0$ 层。两条路径必须从锚点开始。\n如果 $W=1$，两个锚点是同一个点。位于 $(0,0)$ 的单个体素构成一个质量为 $1$ 的有效连接结构。$dp[0][0][0] = 1$。\n如果 $W>1$，路径始于 $(0,0)$ 和 $(W-1,0)$。初始结构包含两个体素。因此，$dp[0][0][W-1] = 2$。\n在 $j=0$ 时的所有其他状态都是不可达的，因此它们的成本被初始化为无穷大：\n$$\ndp[0][i_L][i_R] = \\infty \\quad \\forall (i_L, i_R) \\neq \\begin{cases} (0,0) & \\text{若 } W=1 \\\\ (0,W-1) & \\text{若 } W>1 \\end{cases}\n$$\n\n对于递推关系，考虑 $j>0$ 时的状态 $dp[j][i_L][i_R]$。路径从下方一层的某些有效位置 $(p_L, j-1)$ 和 $(p_R, j-1)$ 到达 $(i_L, j)$ 和 $(i_R, j)$。自支撑约束要求 $|i_L-p_L| \\le s$ 和 $|i_R-p_R| \\le s$。从第 $j-1$ 层的一个状态转换到第 $j$ 层的一个状态的成本是在第 $j$ 层新增的体素数量。如果 $i_L \\neq i_R$，则成本为 $2$；如果 $i_L = i_R$，则成本为 $1$。\n\n为了在 $(j, i_L, i_R)$ 处达到最小质量，我们必须从第 $j-1$ 层中成本最低的有效前驱状态转移而来。因此，递推关系为：\n$$\ndp[j][i_L][i_R] = \\left(2 - \\delta_{i_L, i_R}\\right) + \\min_{\\substack{p_L \\in [\\max(0, i_L-s), \\min(W-1, i_L+s)] \\\\ p_R \\in [\\max(0, i_R-s), \\min(W-1, i_R+s)]}} \\left\\{ dp[j-1][p_L][p_R] \\right\\}\n$$\n其中 $\\delta_{i_L, i_R}$ 是克罗内克（Kronecker）$\\delta$ 函数，当 $i_L=i_R$ 时为 $1$，否则为 $0$。\n\n最小化项代表了对 $dp[j-1]$ 成本矩阵中一个矩形区域的二维范围最小值查询。这可以被高效地计算。对于每个状态 $(j, i_L, i_R)$，我们在由支撑约束定义的 $dp[j-1]$ 子矩阵中找到最小值。\n\n在填充从 $j=1$ 到 $H$ 的整个 DP 表之后，通过在所有可行的最终结构中识别最小质量来找到解决方案。一个可行的结构是路径汇合的结构，即 $i_L = i_R$。汇合可以发生在任何体素 $(i, j)$，其中 $j \\in \\{0, \\dots, H\\}$ 且 $i \\in \\{0, \\dots, W-1\\}$。这种结构的成本由 $dp[j][i][i]$ 给出。总的最小质量是所有可能汇合点的这些值中的最小值。\n$$\nM_{min} = \\min_{\\substack{j \\in \\{0, \\dots, H\\} \\\\ i \\in \\{0, \\dots, W-1\\}}} \\left\\{ dp[j][i][i] \\right\\}\n$$\n\n如果这个最小值为无穷大，则意味着在给定的约束（$W, H, s$）下，路径不可能汇合，问题是不可行的。在这种情况下，指定的输出为 $-1$。\n\n算法总结：\n1. 处理 $W=1$ 的平凡情况：质量为 $1$。\n2. 用 $\\infty$ 初始化一个三维 DP 表 $dp[H+1][W][W]$。\n3. 设置基本情况：当 $W>1$ 时，$dp[0][0][W-1] = 2$。\n4. 从 $j=1$ 到 $H$ 迭代。对于每个 $j$，使用递推关系基于 $dp[j-1]$ 计算 $dp[j]$ 矩阵。对每个状态 $(i_L, i_R)$ 的最小化是在 $dp[j-1]$ 矩阵中一个尺寸最大为 $(2s+1) \\times (2s+1)$ 的矩形窗口上执行的。\n5. DP 表完成后，在所有层矩阵的对角线上找到最小值：对于所有的 $i$，求 $\\min(dp[:, i, i])$。\n6. 如果得到的最小值为 $\\infty$，则返回 $-1$。否则，返回最小质量的整数值。该算法能够为任何有效输入正确地确定最小质量。", "answer": "```python\nimport numpy as np\n\ndef solve_case(W, H, s):\n    \"\"\"\n    Computes the minimal mass of a self-supporting bridge structure.\n\n    This function uses dynamic programming to solve the problem. The state is\n    defined as dp[j][i_L][i_R], representing the minimum mass of a structure\n    with two paths ending at layer j, at horizontal positions i_L and i_R.\n    \"\"\"\n    if W <= 0 or H < 0 or s <= 0:\n        # Invalid parameters based on problem constraints\n        return -1\n\n    if W == 1:\n        # If width is 1, anchors are at the same point. A single voxel is sufficient.\n        return 1\n\n    # dp[j][i_L][i_R]: min mass for paths ending at (i_L, j) and (i_R, j)\n    # Using np.inf for unreachable states.\n    dp = np.full((H + 1, W, W), np.inf, dtype=np.float64)\n\n    # Base case at j=0 (build plate)\n    # The two paths start at the anchors (0,0) and (W-1,0). Mass is 2.\n    dp[0, 0, W - 1] = 2.0\n\n    # Iterate through layers from 1 to H\n    for j in range(1, H + 1):\n        # We can optimize the search for the minimum in the previous layer's window.\n        # Instead of a complex sliding window, a direct slicing approach with NumPy\n        # is clear and fast enough for the given constraints.\n        prev_dp = dp[j - 1, :, :]\n        \n        # This part can be slow if written with Python loops.\n        # Let's vectorize or use efficient lookups.\n        # A 2D range minimum query structure would be optimal, but let's precompute.\n        \n        # Precompute horizontal sliding window minimums\n        h_min_vals = np.full((W, W), np.inf)\n        for r in range(W):\n            if np.all(np.isinf(prev_dp[r, :])):\n                continue\n            # Deque-based sliding window minimum for O(W) per row\n            q = []\n            for c in range(W):\n                # Window is [max(0, c-s), min(W-1, c+s)]\n                # Add current element\n                while q and prev_dp[r, q[-1]] >= prev_dp[r, c]:\n                    q.pop()\n                q.append(c)\n                # Remove elements outside the right boundary of the *first* window C belongs to\n                # The window is centered at an index k, [k-s, k+s]\n                # We are at c. We want to find min for window centered at c-s.\n                # Window for k is [k-s, k+s]\n                # We need min for all k in range(W)\n            # The above logic is complex to map to a single pass. Let's use a simpler method.\n            # Simple (but slower O(W*s)) implementation of sliding window min for each row\n            for c in range(W):\n                c_min = max(0, c - s)\n                c_max = min(W, c + s + 1)\n                h_min_vals[r, c] = np.min(prev_dp[r, c_min:c_max])\n\n        # Precompute vertical sliding window minimums on the result of horizontal mins\n        min_prev_dp = np.full((W, W), np.inf)\n        for c in range(W):\n            if np.all(np.isinf(h_min_vals[:, c])):\n                continue\n            for r in range(W):\n                r_min = max(0, r - s)\n                r_max = min(W, r + s + 1)\n                min_prev_dp[r, c] = np.min(h_min_vals[r_min:r_max, c])\n        \n        # Compute dp for current layer j\n        for i_L in range(W):\n            for i_R in range(W):\n                min_cost = min_prev_dp[i_L, i_R]\n                if np.isinf(min_cost):\n                    continue\n                \n                cost_increment = 2.0 if i_L != i_R else 1.0\n                dp[j, i_L, i_R] = min_cost + cost_increment\n\n    # The minimal mass is the minimum of all states where the paths meet (i_L == i_R)\n    min_mass = np.inf\n    for j in range(H + 1):\n        for i in range(W):\n            min_mass = min(min_mass, dp[j, i, i])\n    \n    if np.isinf(min_mass):\n        return -1\n    else:\n        return int(min_mass)\n\ndef solve():\n    \"\"\"\n    Runs the solver for the given test suite and prints the formatted output.\n    \"\"\"\n    test_cases = [\n        (9, 5, 1),   # Case A\n        (13, 3, 2),  # Case B\n        (11, 4, 1),  # Case C\n        (1, 0, 1),   # Case D\n        (20, 4, 3),  # Case E\n    ]\n\n    results = []\n    for W, H, s in test_cases:\n        result = solve_case(W, H, s)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2420423"}]}