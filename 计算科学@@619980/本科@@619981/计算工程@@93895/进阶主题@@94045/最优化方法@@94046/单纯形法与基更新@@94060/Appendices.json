{"hands_on_practices": [{"introduction": "单纯形法的一个基本要求是从一个基本可行解开始迭代。然而，在许多实际问题中，一个明显的初始基本可行解（例如，所有决策变量为零）并不存在。本练习将引导你使用“两阶段法”来解决这一挑战：首先通过求解一个辅助线性规划问题找到一个初始基本可行解（第一阶段），然后以此为起点求解原始问题（第二阶段）[@problem_id:2446110]。掌握两阶段法对于求解任意形式的线性规划问题至关重要。", "problem": "考虑以下标准的以决策变量表示的线性规划 (LP) 问题。该问题经过设计，使得朴素的全松弛变量基不能直接使用，需要通过一个寻求可行解的过程来获得初始基本可行解。确定目标函数的最优值。\n最大化 $z = x_{1} + 3 x_{2}$\n约束条件为\n$x_{1} + 2 x_{2} = 4$，\n$2 x_{1} + x_{2} \\ge 3$，\n$x_{1} + x_{2} \\le 6$，\n$x_{1} \\ge 0$, $x_{2} \\ge 0$。\n请提供 $z$ 的精确最优值。无需进行四舍五入。", "solution": "该问题陈述构成一个标准的线性规划 (LP)。在进行求解之前，必须确定其有效性。\n\n**问题验证**\n\n已知条件如下：\n目标函数：最大化 $z = x_{1} + 3 x_{2}$\n约束条件：\n1. $x_{1} + 2 x_{2} = 4$\n2. $2 x_{1} + x_{2} \\ge 3$\n3. $x_{1} + x_{2} \\le 6$\n4. $x_{1} \\ge 0$, $x_{2} \\ge 0$\n\n该问题具有科学依据，因为它是一个定义明确的数学优化问题。它是适定的、客观的且自洽的。约束条件之间不矛盾，并且存在一个可行域。例如，点 $(x_1, x_2) = (4, 0)$ 满足所有约束条件：$4+2(0)=4$，$2(4)+0=8 \\ge 3$，$4+0=4 \\le 6$，$4 \\ge 0$, $0 \\ge 0$。因此，该问题是有效的，可以进行求解。\n\n由于存在等式约束和“大于等于”约束，原点 $(x_1, x_2) = (0, 0)$ 不是一个可行点，因此需要一个寻求可行解的过程。两阶段单纯形法是适用的方法。\n\n**第一阶段：寻找一个基本可行解**\n\n首先，通过引入一个剩余变量 $s_1$、一个松弛变量 $s_2$ 以及人工变量 $a_1$ 和 $a_2$，将该线性规划问题转化为标准形式。\n约束条件变为：\n$x_{1} + 2 x_{2} + a_{1} = 4$\n$2 x_{1} + x_{2} - s_{1} + a_{2} = 3$\n$x_{1} + x_{2} + s_{2} = 6$\n其中所有变量 $x_{1}, x_{2}, s_{1}, s_{2}, a_{1}, a_{2} \\ge 0$。\n\n第一阶段的目标是最小化人工变量之和 $w = a_{1} + a_{2}$，这等价于最大化 $z' = -w = -a_{1} - a_{2}$。我们必须将 $z'$ 用非基变量来表示。\n根据前两个约束条件：\n$a_{1} = 4 - x_{1} - 2 x_{2}$\n$a_{2} = 3 - 2 x_{1} - x_{2} + s_{1}$\n将它们代入 $z'$ 的表达式中：\n$z' = -(4 - x_{1} - 2 x_{2}) - (3 - 2 x_{1} - x_{2} + s_{1}) = -7 + 3 x_{1} + 3 x_{2} - s_{1}$\n因此，初始单纯形表的目标函数行为 $z' - 3 x_{1} - 3 x_{2} + s_{1} = -7$。\n\n初始的第一阶段单纯形表为：\n$$\n\\begin{array}{c|c|cccccc|c}\n\\text{基} & z' & x_1 & x_2 & s_1 & s_2 & a_1 & a_2 & \\text{右端项} \\\\\n\\hline\nz' & 1 & -3 & -3 & 1 & 0 & 0 & 0 & -7 \\\\\n\\hline\na_1 & 0 & 1 & 2 & 0 & 0 & 1 & 0 & 4 \\\\\na_2 & 0 & 2 & 1 & -1 & 0 & 0 & 1 & 3 \\\\\ns_2 & 0 & 1 & 1 & 0 & 1 & 0 & 0 & 6\n\\end{array}\n$$\n$z'$ 行中最小的负系数是 $-3$，对应于 $x_1$ 和 $x_2$。我们选择 $x_1$ 作为进基变量。最小比率检验确定出基变量：$\\min\\{ \\frac{4}{1}, \\frac{3}{2}, \\frac{6}{1} \\} = \\frac{3}{2}$。主元行是 $a_2$ 所在行。主元是 $2$。\n在进行行变换使 $x_1$ 成为基变量后，单纯形表变为：\n$$\n\\begin{array}{c|c|cccccc|c}\n\\text{基} & z' & x_1 & x_2 & s_1 & s_2 & a_1 & a_2 & \\text{右端项} \\\\\n\\hline\nz' & 1 & 0 & -\\frac{3}{2} & -\\frac{1}{2} & 0 & 0 & \\frac{3}{2} & -\\frac{5}{2} \\\\\n\\hline\na_1 & 0 & 0 & \\frac{3}{2} & \\frac{1}{2} & 0 & 1 & -\\frac{1}{2} & \\frac{5}{2} \\\\\nx_1 & 0 & 1 & \\frac{1}{2} & -\\frac{1}{2} & 0 & 0 & \\frac{1}{2} & \\frac{3}{2} \\\\\ns_2 & 0 & 0 & \\frac{1}{2} & \\frac{1}{2} & 1 & 0 & -\\frac{1}{2} & \\frac{9}{2}\n\\end{array}\n$$\n下一个进基变量是 $x_2$，其系数为 $-\\frac{3}{2}$。最小比率检验：$\\min\\{ \\frac{5/2}{3/2}, \\frac{3/2}{1/2}, \\frac{9/2}{1/2} \\} = \\min\\{ \\frac{5}{3}, 3, 9 \\} = \\frac{5}{3}$。主元行是 $a_1$ 所在行。主元是 $\\frac{3}{2}$。\n经过行变换后，单纯形表为：\n$$\n\\begin{array}{c|c|cccccc|c}\n\\text{基} & z' & x_1 & x_2 & s_1 & s_2 & a_1 & a_2 & \\text{右端项} \\\\\n\\hline\nz' & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 0 \\\\\n\\hline\nx_2 & 0 & 0 & 1 & \\frac{1}{3} & 0 & \\frac{2}{3} & -\\frac{1}{3} & \\frac{5}{3} \\\\\nx_1 & 0 & 1 & 0 & -\\frac{2}{3} & 0 & -\\frac{1}{3} & \\frac{2}{3} & \\frac{2}{3} \\\\\ns_2 & 0 & 0 & 0 & \\frac{1}{3} & 1 & -\\frac{1}{3} & -\\frac{1}{3} & \\frac{11}{3}\n\\end{array}\n$$\n第一阶段的目标函数值为 $0$，且 $z'$ 行中没有负系数。第一阶段完成。人工变量 $a_1$ 和 $a_2$ 的值已变为 $0$，可以从问题中移除。我们找到了一个基本可行解：$x_1 = \\frac{2}{3}$，$x_2 = \\frac{5}{3}$，$s_2 = \\frac{11}{3}$，非基变量为 $s_1=0$。\n\n**第二阶段：求解原问题**\n\n我们现在使用第一阶段的最终单纯形表来开始第二阶段。去掉人工变量所在的列，并将目标函数替换为原问题的目标函数 $z = x_{1} + 3 x_{2}$。目标函数行必须用当前的非基变量 ($s_1$) 来表示。\n基变量为：\n$x_{1} = \\frac{2}{3} + \\frac{2}{3} s_{1}$\n$x_{2} = \\frac{5}{3} - \\frac{1}{3} s_{1}$\n代入目标函数 $z$ 中：\n$z = (\\frac{2}{3} + \\frac{2}{3} s_{1}) + 3 (\\frac{5}{3} - \\frac{1}{3} s_{1}) = \\frac{2}{3} + \\frac{2}{3} s_{1} + 5 - s_{1} = \\frac{17}{3} - \\frac{1}{3} s_{1}$\n第二阶段的目标函数行为 $z + \\frac{1}{3} s_{1} = \\frac{17}{3}$。\n\n初始的第二阶段单纯形表为：\n$$\n\\begin{array}{c|c|cccc|c}\n\\text{基} & z & x_1 & x_2 & s_1 & s_2 & \\text{右端项} \\\\\n\\hline\nz & 1 & 0 & 0 & \\frac{1}{3} & 0 & \\frac{17}{3} \\\\\n\\hline\nx_2 & 0 & 0 & 1 & \\frac{1}{3} & 0 & \\frac{5}{3} \\\\\nx_1 & 0 & 1 & 0 & -\\frac{2}{3} & 0 & \\frac{2}{3} \\\\\ns_2 & 0 & 0 & 0 & \\frac{1}{3} & 1 & \\frac{11}{3}\n\\end{array}\n$$\n对于一个最大化问题，如果目标函数行中所有非基变量的系数（检验数的相反数）均为非负，则当前解为最优解。在此单纯形表中，非基变量 $s_1$ 的系数为 $\\frac{1}{3}$，是正数。不存在系数为负的非基本变量。\n因此，当前基本可行解即为最优解。目标函数的最优值可以在 $z$ 行的右端项列中找到。\n\n最优值为 $z = \\frac{17}{3}$。最优解为 $x_1 = \\frac{2}{3}$ 和 $x_2 = \\frac{5}{3}$。", "answer": "$$\n\\boxed{\\frac{17}{3}}\n$$", "id": "2446110"}, {"introduction": "除了标准的（原始）单纯形法，对偶单纯形法是另一种强大的求解工具，尤其在敏感性分析和整数规划中非常高效。当一个解满足对偶可行性（即满足最优性条件）但违反了原始可行性（例如，某些变量为负）时，便可使用对偶单纯形法。该练习将让你执行一步对偶单纯形迭代，从一个“超优”但不可行的解出发，通过恢复可行性来逼近最优解，从而加深你对原始-对偶理论及其几何意义的理解[@problem_id:2446085]。", "problem": "考虑以下处于最大化标准形式的线性规划（LP）问题，其决策变量为 $x_1$ 和 $x_2$，松弛变量为 $s_1$ 和 $s_2$：\n最大化 $-x_1 - 3 x_2$\n约束条件为\n$-2 x_1 + x_2 + s_1 = -2$，\n$x_1 + x_2 + s_2 = 4$，\n$x_1 \\ge 0$, $x_2 \\ge 0$, $s_1 \\ge 0$, $s_2 \\ge 0$。\n取初始基为松弛变量 $\\{s_1, s_2\\}$，因此初始基解为 $x_1 = 0$, $x_2 = 0$, $s_1 = -2$, $s_2 = 4$。该基是对偶可行的，但原始不可行。请执行一次对偶单纯形法（DSM）的迭代，更新一次基，并获得新的基解和目标值。然后，从激活约束和向相邻基的移动方面，解释这次对偶单纯形法单步迭代的几何意义。\n在这次对偶单纯形法枢轴变换后，仅提供更新后的目标值 $z$。无需四舍五入；请提供精确值。", "solution": "用户提供了一个线性规划（LP）问题，并要求进行一次对偶单纯形法（DSM）的迭代。我将首先验证问题陈述。\n\n第一步：提取已知条件\n问题是最大化目标函数 $z = -x_1 - 3x_2$。\n约束条件是：\n$c_1: -2 x_1 + x_2 + s_1 = -2$\n$c_2: x_1 + x_2 + s_2 = 4$\n非负性条件是 $x_1 \\ge 0$, $x_2 \\ge 0$, $s_1 \\ge 0$, $s_2 \\ge 0$。\n初始基给定为 $\\{s_1, s_2\\}$。\n初始基解给定为 $x_1 = 0$, $x_2 = 0$, $s_1 = -2$, $s_2 = 4$。\n问题陈述该基是对偶可行的，但原始不可行。\n\n第二步：使用提取的条件进行验证\n该问题是一个标准的LP公式。它在计算工程和优化理论领域具有科学依据。语言客观而精确。我必须验证关于可行性的声明。\n\n原始可行性检查：如果所有变量值均为非负，则一个基解是原始可行的。初始解中 $s_1 = -2$，这违反了非负性约束 $s_1 \\ge 0$。因此，初始基解确实是原始不可行的。\n\n对偶可行性检查：对于一个最大化问题，如果所有非基变量的检验数（reduced costs）都为非正，则该基是对偶可行的。或者，在一个单纯形表中，如果目标行写作 $z - \\sum c'_j x_j = z_0$，则对偶可行性要求所有 $c'_j \\le 0$。这里使用的、我也将采纳的通常惯例是将目标函数写作 $z + \\sum \\bar{c}_j x_j = z_0$，其中 $\\bar{c}_j$ 是检验数的相反数。对于最大化问题，此形式要求所有 $\\bar{c}_j \\ge 0$ 以满足对偶可行性（最优性条件）。\n目标函数是 $z = -x_1 - 3x_2$，可以重写为 $z + x_1 + 3x_2 = 0$。\n非基变量是 $x_1$ 和 $x_2$。它们在目标行中的系数是 $\\bar{c}_{x_1} = 1$ 和 $\\bar{c}_{x_2} = 3$。两者均为非负。因此，初始基解确实是对偶可行的。\n\n该问题是自洽、一致、适定且有科学依据的。它需要一个标准的、可验证的计算过程。\n\n第三步：结论与行动\n问题有效。我将继续进行求解。\n\n初始单纯形表由给定的方程组构建。目标行源于 $z + x_1 + 3x_2 = 0$。基变量是 $s_1$ 和 $s_2$。\n\n初始单纯形表：\n$$\n\\begin{array}{c|c|cccc|c}\n\\text{基} & z & x_1 & x_2 & s_1 & s_2 & \\text{右端项} \\\\\n\\hline\nz & 1 & 1 & 3 & 0 & 0 & 0 \\\\\n\\hline\ns_1 & 0 & -2 & 1 & 1 & 0 & -2 \\\\\ns_2 & 0 & 1 & 1 & 0 & 1 & 4 \\\\\n\\end{array}\n$$\n\n一次对偶单纯形法的迭代包括以下步骤：\n\n1.  选择离基变量（主元行）：离基变量是在右端项（RHS）列中具有最负值的基变量。在这里，唯一具有负值的基变量是 $s_1 = -2$。因此，$s_1$ 是离基变量，对应于 $s_1$ 的行是主元行。\n\n2.  选择入基变量（主元列）：通过应用对偶比例检验，从非基变量（$x_1, x_2$）中选择入基变量。该比例计算为 $|\\frac{\\bar{c}_j}{a_{ij}}|$，其中 $i$ 是主元行的索引，$\\bar{c}_j$ 是目标行中的系数，$a_{ij}$ 是主元行中的系数。此检验仅适用于主元行系数 $a_{ij} < 0$ 的列 $j$。\n在主元行（$s_1$ 行）中，$x_1$ 的系数是 $a_{1,x_1} = -2$，$x_2$ 的系数是 $a_{1,x_2} = 1$。我们只考虑 $x_1$，因为它的系数为负。\n$x_1$ 的比值为：\n$$ \\left| \\frac{\\bar{c}_{x_1}}{a_{1,x_1}} \\right| = \\left| \\frac{1}{-2} \\right| = \\frac{1}{2} $$\n由于 $x_1$ 是唯一的候选者，它成为入基变量。主元是 $-2$，位于 $s_1$ 行和 $x_1$ 列的交点。\n\n3.  执行枢轴变换操作：我们通过将主元变为 $1$ 并将主元列中的所有其他元素变为 $0$ 来更新单纯形表。\n设 $R_0, R_1, R_2$ 分别为目标行、$s_1$ 行和 $s_2$ 行。设新行为 $R'_0, R'_1, R'_2$。\n新的主元行 $R'_1$ 通过将 $R_1$ 除以主元 $-2$ 得到。\n$$ R'_1 = \\frac{R_1}{-2} = \\frac{1}{-2} \\begin{pmatrix} 0 & -2 & 1 & 1 & 0 & -2 \\end{pmatrix} = \\begin{pmatrix} 0 & 1 & -\\frac{1}{2} & -\\frac{1}{2} & 0 & 1 \\end{pmatrix} $$\n新的目标行是 $R'_0 = R_0 - (1) R'_1$。\n$$ R'_0 = \\begin{pmatrix} 1 & 1 & 3 & 0 & 0 & 0 \\end{pmatrix} - \\begin{pmatrix} 0 & 1 & -\\frac{1}{2} & -\\frac{1}{2} & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 1 & 0 & \\frac{7}{2} & \\frac{1}{2} & 0 & -1 \\end{pmatrix} $$\n新的 $s_2$ 行是 $R'_2 = R_2 - (1) R'_1$。\n$$ R'_2 = \\begin{pmatrix} 0 & 1 & 1 & 0 & 1 & 4 \\end{pmatrix} - \\begin{pmatrix} 0 & 1 & -\\frac{1}{2} & -\\frac{1}{2} & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 0 & 0 & \\frac{3}{2} & \\frac{1}{2} & 1 & 3 \\end{pmatrix} $$\n\n一次迭代后更新的单纯形表是：\n$$\n\\begin{array}{c|c|cccc|c}\n\\text{基} & z & x_1 & x_2 & s_1 & s_2 & \\text{右端项} \\\\\n\\hline\nz & 1 & 0 & \\frac{7}{2} & \\frac{1}{2} & 0 & -1 \\\\\n\\hline\nx_1 & 0 & 1 & -\\frac{1}{2} & -\\frac{1}{2} & 0 & 1 \\\\\ns_2 & 0 & 0 & \\frac{3}{2} & \\frac{1}{2} & 1 & 3 \\\\\n\\end{array}\n$$\n\n通过将非基变量 $x_2$ 和 $s_1$ 设置为 $0$ 来找到新的基解。从表中，我们读出基变量的值：$x_1 = 1$，$s_2 = 3$。完整的解是 $(x_1, x_2, s_1, s_2) = (1, 0, 0, 3)$。这个解现在是原始可行的，因为所有变量都是非负的。更新后的目标值从目标行的右端项（RHS）读取。目标行代表方程 $z + \\frac{7}{2}x_2 + \\frac{1}{2}s_1 = -1$。当非基变量等于零时，我们得到 $z = -1$。\n我们可以用原始目标函数验证这一点：$z = -x_1 - 3x_2 = -(1) - 3(0) = -1$。\n\n几何解释：\n初始基解 $(x_1, x_2, s_1, s_2) = (0, 0, -2, 4)$ 对应于决策变量空间中的顶点 $(x_1, x_2) = (0, 0)$。激活约束是 $x_1=0$ 和 $x_2=0$。该点是原始不可行的，因为它违反了约束 $-2x_1 + x_2 \\le -2$（因为 $0 \\not\\le -2$）。这种不可行性由负的松弛变量 $s_1=-2$ 表示。\n对偶单纯形法步骤执行了一次基变换。离基变量 $s_1$ 意味着与其相关的约束 $-2x_1 + x_2 = -2$（即 $s_1=0$）变为激活状态。入基变量 $x_1$ 意味着约束 $x_1=0$ 变为非激活状态。\n新的基 $\\{x_1, s_2\\}$ 对应一个新的顶点，在该顶点处，新的非基变量为零：$x_2=0$ 和 $s_1=0$。此时的激活约束是 $x_2=0$ 和 $-2x_1+x_2 = -2$。解这个方程组得到 $x_1 = 1$ 和 $x_2 = 0$。\n几何上，这次单一的对偶单纯形法步骤从原始不可行的顶点 $(0,0)$ 移动到了相邻的顶点 $(1,0)$。新的顶点 $(1,0)$ 是原始可行的，因为它满足所有约束：$-2(1)+0 = -2 \\le -2$ 以及 $1+0=1 \\le 4$。该方法从一个“超最优”但不可行的点向可行域移动，到达一个基本可行解。目标值从 $z=0$ 变为 $z=-1$，这是一个减少，这与在最大化问题中从不可行区域移动到可行区域时的预期相符。\n\n问题要求在这次单一枢轴变换后更新后的目标值 $z$。该值为 $-1$。", "answer": "$$ \\boxed{-1} $$", "id": "2446085"}, {"introduction": "理论上，单纯形法的每次迭代都涉及基矩阵的更新，但在计算实践中，我们如何高效地执行这一步呢？直接对每个新的基矩阵求逆的计算成本非常高。本编程练习将让你从理论走向实践，通过实现 Sherman-Morrison-Woodbury 公式来高效更新基矩阵的逆矩阵 $B^{-1}$ [@problem_id:2446121]。这个练习将揭示数值线性代数技巧在构建高性能优化求解器中的核心作用，这是计算工程领域的关键技能。", "problem": "你需要编写一个完整的程序，该程序针对单纯形法中出现的一组预定义基更新场景，从当前的逆矩阵计算更新后基矩阵的逆，并通过与直接求逆的结果进行比较来验证其正确性。背景设定如下：一个基矩阵 $B \\in \\mathbb{R}^{n \\times n}$ 是非奇异的，其一部分列被新向量替换，形成一个更新后的矩阵 $B_{\\text{new}}$。被替换列的位置由索引集 $J = \\{j_{1}, \\dots, j_{k}\\}$ 给出，其中 $j_{p} \\in \\{1, \\dots, n\\}$，相应的替换向量为 $a^{(p)} \\in \\mathbb{R}^{n}$，其中 $p \\in \\{1, \\dots, k\\}$。给定 $B$、$B^{-1}$、$J$ 以及替换向量列表。你的任务是，通过任何数学上有效的方法，从 $B^{-1}$ 计算出更新后的逆矩阵 $B_{\\text{new}}^{-1}$，并通过与直接对 $B_{\\text{new}}$ 求逆的结果进行比较，来量化你的结果的准确性。\n\n对于下述每个测试用例，你的程序必须：\n- 通过用提供的替换向量替换 $B$ 中索引集 $J$ 指定的列来构成 $B_{\\text{new}}$。\n- 从给定的 $B^{-1}$ 计算更新后的逆矩阵 $B_{\\text{new}}^{-1}$，而不是直接对 $B_{\\text{new}}$ 求逆。\n- 使用标准的稠密线性代数方法直接对 $B_{\\text{new}}$ 求逆，以计算参考逆矩阵 $\\widehat{B_{\\text{new}}^{-1}}$。\n- 计算元素级的最大绝对差异\n$$\n\\Delta \\;=\\; \\max_{1 \\le i \\le n,\\, 1 \\le j \\le n} \\left| \\left(B_{\\text{new}}^{-1}\\right)_{ij} - \\left(\\widehat{B_{\\text{new}}^{-1}}\\right)_{ij} \\right|.\n$$\n\n测试套件：\n你必须硬编码以下四个测试用例。在每个用例中，$J$ 中的索引采用基于 1 的表示法；在代码实现中，你可以使用任何一致的内部索引方式。所有矩阵和向量都是实数域上的。\n\n- 测试用例 $1$ (单列更新，中等条件数):\n  - $n = 3$,\n  - $B^{(1)} = \\begin{bmatrix} 2 & 1 & 0 \\\\ 1 & 3 & 1 \\\\ 0 & 1 & 2 \\end{bmatrix}$,\n  - $J^{(1)} = \\{2\\}$,\n  - 替换向量 $a^{(1)} = \\begin{bmatrix} 1 \\\\ 2 \\\\ 1 \\end{bmatrix}$ 用于第 $2$ 列。\n\n- 测试用例 $2$ (带状矩阵中的双列更新):\n  - $n = 4$,\n  - $B^{(2)} = \\begin{bmatrix} 4 & 1 & 0 & 0 \\\\ 1 & 4 & 1 & 0 \\\\ 0 & 1 & 4 & 1 \\\\ 0 & 0 & 1 & 3 \\end{bmatrix}$,\n  - $J^{(2)} = \\{1, 3\\}$,\n  - 替换向量:\n    - $a^{(2,1)} = \\begin{bmatrix} 5 \\\\ 1 \\\\ 0 \\\\ 0 \\end{bmatrix}$ 用于第 $1$ 列,\n    - $a^{(2,3)} = \\begin{bmatrix} 0 \\\\ 2 \\\\ 5 \\\\ 0 \\end{bmatrix}$ 用于第 $3$ 列。\n\n- 测试用例 $3$ (从单位矩阵出发的近奇异更新):\n  - $n = 3$,\n  - $B^{(3)} = I_{3}$，其中 $I_{3}$ 是 $3 \\times 3$ 单位矩阵,\n  - $J^{(3)} = \\{2\\}$,\n  - 替换向量 $a^{(3)} = \\begin{bmatrix} 10^{-8} \\\\ 10^{-8} \\\\ 0 \\end{bmatrix}$ 用于第 $2$ 列。\n\n- 测试用例 $4$ (包含零差异列的混合更新):\n  - $n = 5$,\n  - $B^{(4)} = \\operatorname{diag}(2, 3, 4, 5, 6)$,\n  - $J^{(4)} = \\{2, 5\\}$,\n  - 替换向量:\n    - $a^{(4,2)} = \\begin{bmatrix} 0 \\\\ 3 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix}$ 用于第 $2$ 列 (即无变化),\n    - $a^{(4,5)} = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 6 \\end{bmatrix}$ 用于第 $5$ 列。\n\n对于每个测试用例，所需的答案是上面定义的单个实数 $\\Delta$。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例 $1$、$2$、$3$、$4$ 的顺序列出结果。例如，输出行的格式为\n\"[r1,r2,r3,r4]\"\n其中 $r1$、$r2$、$r3$、$r4$ 是针对四个用例计算出的 $\\Delta$ 值。不涉及单位，也不出现角度；所有量都是无量纲的实数。", "solution": "所提出的问题是适定的，并且涉及计算线性代数中的一个基本操作：在低秩修改后更新矩阵的逆。此过程对于优化中迭代方法的效率至关重要，尤其是在线性规划的单纯形算法中，其中基矩阵每次更新一列。正确且计算高效的方法是应用 Sherman-Morrison-Woodbury 公式，该公式避免了从头开始重新计算逆矩阵的高昂代价。\n\n设非奇异基矩阵为 $B \\in \\mathbb{R}^{n \\times n}$。我们已知其逆矩阵 $B^{-1}$。更新后的基矩阵 $B_{\\text{new}}$ 是通过替换 $B$ 的 $k$ 个列而形成的。设待替换列的索引集为 $J = \\{j_{1}, \\dots, j_{k}\\}$，其中每个 $j_{p} \\in \\{1, \\dots, n\\}$。$B$ 的第 $j_{p}$ 列（表示为 $b_{j_p}$）被一个新向量 $a^{(p)} \\in \\mathbb{R}^{n}$ 替换。\n\n这个替换操作可以表示为对矩阵 $B$ 的一个秩为 $k$ 的更新。设 $e_{j_p}$ 为在位置 $j_p$ 处为 $1$、其余位置为零的标准基向量。原始列 $b_{j_p}$ 可以写为 $B e_{j_p}$。更新后的矩阵 $B_{\\text{new}}$ 由下式给出：\n$$\nB_{\\text{new}} = B - \\sum_{p=1}^{k} (B e_{j_p}) e_{j_p}^T + \\sum_{p=1}^{k} a^{(p)} e_{j_p}^T = B + \\sum_{p=1}^{k} (a^{(p)} - B e_{j_p}) e_{j_p}^T\n$$\n这可以写成紧凑形式 $B_{\\text{new}} = B + UV^T$，其中 $U$ 和 $V$ 是大小为 $n \\times k$ 的矩阵。$U$ 的列是更新向量 $u_p = a^{(p)} - B e_{j_p}$，$V$ 的列是标准基向量 $v_p = e_{j_p}$。\n\nSherman-Morrison-Woodbury 公式为此类秩-k 更新矩阵的逆提供了一个表达式：\n$$\n(B + UV^T)^{-1} = B^{-1} - B^{-1} U (I_k + V^T B^{-1} U)^{-1} V^T B^{-1}\n$$\n这里，$I_k$ 是 $k \\times k$ 单位矩阵。这个公式的优势在于它仅需要对一个更小的 $k \\times k$ 矩阵 $C = I_k + V^T B^{-1} U$ 求逆。在单纯形法的背景下，通常只更新一列（$k=1$），此时 $C$ 是一个标量，其求逆是微不足道的。\n\n为了实现此解决方案，我们对每个测试用例遵循以下步骤：\n\n$1$. **初始化**：给定 $B$，$B^{-1}$（我们从 $B$ 计算，因为它没有明确提供），基于 1 的索引集 $J$，以及替换向量 $\\{a^{(p)}\\}_{p=1}^k$。我们将 $J$ 转换为基于 0 的索引以便计算。替换次数为 $k = |J|$。\n\n$2$. **构造更新矩阵**：我们构成一个 $n \\times k$ 矩阵 $U$，其列为 $u_p = a^{(p)} - b_{j_p}$。我们不需要显式地构造矩阵 $V$，因为它的操作可以通过索引来执行。\n\n$3$. **应用 Woodbury 公式**：我们计算该公式的各个组成部分：\n    - 令 $W = B^{-1} U$。这是一个 $n \\times k$ 矩阵。\n    - 令 $Z = V^T B^{-1}$。由于 $V^T$ 的行是 $e_{j_p}^T$，因此 $Z$ 的行就是 $B^{-1}$ 中对应于 $J$ 中索引的那些行。所以，$Z$ 是一个 $k \\times n$ 矩阵。\n    - 需要求逆的小矩阵是 $C = I_k + V^T B^{-1} U = I_k + ZU$。或者，$C = I_k + V^T W$。$V^T W$ 的第 $(p,q)$ 个元素是 $e_{j_p}^T w_q$，即向量 $w_q$ 的第 $j_p$ 个元素。因此，$V^T W$ 是通过选择 $W$ 中对应于 $J$ 中索引的行来构成的。\n    - 我们计算 $C^{-1}$。\n    - 更新后的逆矩阵则为 $B_{\\text{new}}^{-1} = B^{-1} - W C^{-1} Z$。\n\n$4$. **验证**：\n    - 我们通过替换 $B$ 的指定列来显式构造矩阵 $B_{\\text{new}}$。\n    - 我们通过使用标准的数值线性代数库例程直接对 $B_{\\text{new}}$ 求逆，来计算一个参考逆矩阵 $\\widehat{B_{\\text{new}}^{-1}}$。\n    - 我们计算我们的计算逆与参考逆之间的元素级最大绝对差异 $\\Delta$：\n    $$\n    \\Delta \\;=\\; \\max_{1 \\le i \\le n,\\, 1 \\le j \\le n} \\left| \\left(B_{\\text{new}}^{-1}\\right)_{ij} - \\left(\\widehat{B_{\\text{new}}^{-1}}\\right)_{ij} \\right|\n    $$\n此过程应用于所有提供的测试用例。请注意，在测试用例 4 中，其中一个替换向量与其替换的列完全相同。这会导致更新矩阵 $U$ 中出现一个零列，该公式无需任何特殊逻辑即可正确处理这种情况。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the basis update problem for a suite of test cases.\n    For each case, it computes the inverse of an updated basis matrix using the\n    Sherman-Morrison-Woodbury formula and compares it to a direct inversion.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (B, J, replacements)\n    # J contains 1-based indices.\n    # replacements is a list of column vectors corresponding to indices in J.\n    test_cases = [\n        # Test case 1 (single-column update, moderate conditioning)\n        (\n            np.array([[2., 1., 0.], [1., 3., 1.], [0., 1., 2.]]),\n            [2],\n            [np.array([1., 2., 1.])]\n        ),\n        # Test case 2 (two-column update in a banded matrix)\n        (\n            np.array([[4., 1., 0., 0.], [1., 4., 1., 0.], [0., 1., 4., 1.], [0., 0., 1., 3.]]),\n            [1, 3],\n            [np.array([5., 1., 0., 0.]), np.array([0., 2., 5., 0.])]\n        ),\n        # Test case 3 (near-singular update from the identity)\n        (\n            np.eye(3),\n            [2],\n            [np.array([1e-8, 1e-8, 0.])]\n        ),\n        # Test case 4 (mixed update with a zero-difference column)\n        (\n            np.diag([2., 3., 4., 5., 6.]),\n            [2, 5],\n            [np.array([0., 3., 0., 0., 0.]), np.array([1., 0., 0., 0., 6.])]\n        )\n    ]\n\n    results = []\n    for B, J_one_based, replacements in test_cases:\n        n = B.shape[0]\n        k = len(J_one_based)\n\n        # Convert 1-based indices to 0-based for numpy\n        J_zero_based = [j - 1 for j in J_one_based]\n\n        # Step 1: Compute given inverse B_inv and form B_new\n        B_inv = np.linalg.inv(B)\n        B_new = B.copy()\n        for i, j in enumerate(J_zero_based):\n            B_new[:, j] = replacements[i]\n\n        # Step 2: Compute reference inverse by direct inversion\n        B_new_inv_ref = np.linalg.inv(B_new)\n\n        # Step 3: Compute updated inverse using Sherman-Morrison-Woodbury formula\n        # B_new = B + U @ V.T\n        \n        # Construct the n x k matrix U\n        U_cols = []\n        for i, j in enumerate(J_zero_based):\n            b_j = B[:, j]\n            a_p = replacements[i]\n            u_p = a_p - b_j\n            U_cols.append(u_p)\n        U = np.column_stack(U_cols)\n\n        # Apply the formula: B_new_inv = B_inv - B_inv @ U @ inv(I + V.T @ B_inv @ U) @ V.T @ B_inv\n        # Let W = B_inv @ U\n        # Let Z = V.T @ B_inv\n        \n        W = B_inv @ U\n        \n        # The matrix V consists of standard basis vectors e_j.\n        # V.T @ M selects rows from M.\n        # So, Z = B_inv[J_zero_based, :]\n        Z = B_inv[J_zero_based, :]\n        \n        # The core k x k matrix to invert is C = I_k + V.T @ W\n        # V.T @ W selects rows from W. So C = I_k + W[J_zero_based, :]\n        C = np.eye(k) + W[J_zero_based, :]\n        C_inv = np.linalg.inv(C)\n        \n        # Compute the final updated inverse\n        B_new_inv_calc = B_inv - W @ C_inv @ Z\n        \n        # Step 4: Compute the maximum absolute entry-wise discrepancy\n        discrepancy = np.max(np.abs(B_new_inv_calc - B_new_inv_ref))\n        results.append(discrepancy)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2446121"}]}