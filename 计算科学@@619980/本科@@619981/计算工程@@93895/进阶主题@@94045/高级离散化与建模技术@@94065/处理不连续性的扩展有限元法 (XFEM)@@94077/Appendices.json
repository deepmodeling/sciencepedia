{"hands_on_practices": [{"introduction": "扩展有限元方法 (XFEM) 的核心思想是通过使用与物理相关的函数来增强标准有限元逼近，从而在不改变网格的情况下模拟不连续性。这个练习将带您从头开始，为单个单元构建最基本的增强类型——亥维赛德函数 (Heaviside function)。通过亲手实现并可视化一个被不连续面切割的单元的增强基函数，您将对 XFEM 如何在单元内部引入“跳跃”有一个直观而深刻的理解 [@problem_id:2390842]。", "problem": "实现一个完整的程序，用于构建在扩展有限元方法 (XFEM) 中使用的二维双线性四边形单元的 Heaviside 丰富。从有限元形函数的基本定义和不连续性的水平集表示开始。考虑一个占据单位正方形域 $\\Omega_{e} = [0,1] \\times [0,1]$ 的单个等参四边形单元，其四个节点位于 $\\mathbf{x}_1 = (0,0)$、$\\mathbf{x}_2 = (1,0)$、$\\mathbf{x}_3 = (1,1)$ 和 $\\mathbf{x}_4 = (0,1)$。标准的双线性形函数为\n$$\nN_1(x,y) = (1-x)(1-y),\\quad N_2(x,y) = x(1-y),\\quad N_3(x,y) = xy,\\quad N_4(x,y) = (1-x)y,\n$$\n对于所有 $(x,y) \\in \\Omega_{e}$，它们满足单位分解性质 $\\sum_{i=1}^{4} N_i(x,y) = 1$。材料界面由水平集函数 $\\phi(\\mathbf{x})$ 隐式表示，其零等值线 $\\{\\mathbf{x} \\mid \\phi(\\mathbf{x}) = 0\\}$ 定义了不连续性。\n\n将 Heaviside 函数 $H(\\phi)$ 定义为\n$$\nH(\\phi) = \\begin{cases}\n+1,  \\phi  0,\\\\\n0,  \\phi = 0,\\\\\n-1,  \\phi  0.\n\\end{cases}\n$$\n将节点 $i$ 的 Heaviside 丰富基函数定义为\n$$\n\\psi_i(\\mathbf{x}) = \\begin{cases}\nN_i(\\mathbf{x})\\left(H(\\phi(\\mathbf{x})) - H(\\phi(\\mathbf{x}_i))\\right),  \\text{if the element is cut},\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n其中，如果 $\\min_{j \\in \\{1,2,3,4\\}} \\phi(\\mathbf{x}_j)  0$ 且 $\\max_{j \\in \\{1,2,3,4\\}} \\phi(\\mathbf{x}_j)  0$，则认为该单元被切割。该准则确保了只有当不连续性穿过单元内部时，丰富才被激活。该定义满足对于所有节点 $j$ 都有 $\\psi_i(\\mathbf{x}_j) = 0$，并引入一个与 $H(\\phi)$ 符号变化一致的位移跳跃。\n\n您的任务是实现：\n- 下方测试套件中指定的水平集函数 $\\phi(\\mathbf{x})$。\n- Heaviside 函数 $H(\\phi)$。\n- 节点 $i=1$ 的丰富基函数 $\\psi_i(\\mathbf{x})$。\n- 在一个 $M \\times M$ 的网格上对 $\\Omega_e$ 进行均匀采样，其中 $M=101$，即对于 $k,\\ell \\in \\{0,1,\\dots,M-1\\}$，有 $x_k = k/(M-1)$ 和 $y_\\ell = \\ell/(M-1)$。\n\n对于下方的每个测试用例，计算 $\\psi_1(\\mathbf{x})$ 的以下量化诊断指标：\n1. $z_{\\text{nodes}}$：最大节点绝对值 $\\max_{j \\in \\{1,2,3,4\\}} \\left|\\psi_1(\\mathbf{x}_j)\\right|$。这验证了丰富项在节点处为零的性质。\n2. $z_{\\text{grid}}$：网格上的最大绝对值 $\\max_{(x,y)\\in \\mathcal{G}} \\left|\\psi_1(x,y)\\right|$，其中 $\\mathcal{G}$ 是网格点集。\n3. $z_{\\text{jump}}$：$\\psi_1$ 在单元中心 $\\mathbf{p}_c=(0.5,0.5)$ 处跨越界面的近似跳跃，计算方法如下。如果 $\\left|\\phi(\\mathbf{p}_c)\\right| \\le \\tau$，容差为 $\\tau = 10^{-12}$，则跳跃可近似为\n$$\nz_{\\text{jump}} \\approx \\psi_1(\\mathbf{p}_c + \\varepsilon \\mathbf{n}) - \\psi_1(\\mathbf{p}_c - \\varepsilon \\mathbf{n}),\n$$\n其中 $\\mathbf{n} = \\nabla \\phi(\\mathbf{p}_c)/\\|\\nabla \\phi(\\mathbf{p}_c)\\|$ 是单位法向量，通过步长 $h = 10^{-8}$ 的中心有限差分计算得出，且 $\\varepsilon = 10^{-6}$。如果 $\\left|\\phi(\\mathbf{p}_c)\\right|  \\tau$，则设 $z_{\\text{jump}} = 0$。\n4. $z_{\\text{L2}}$：单元上 $\\psi_1$ 的 $L^2$ 范数的离散近似，\n$$\nz_{\\text{L2}} \\approx \\left(\\sum_{(x,y) \\in \\mathcal{G}} \\psi_1(x,y)^2 \\,\\Delta x \\,\\Delta y \\right)^{1/2},\n$$\n其中 $\\Delta x = \\Delta y = 1/(M-1)$。\n\n测试套件 (所有情况均使用节点索引 $i=1$)：\n- 情况 A (穿过中心的内部切割)：$\\phi(x,y) = x + y - 1$。\n- 情况 B (与边界对齐的零水平集，无内部切割)：$\\phi(x,y) = x$。\n- 情况 C (无任何切割)：$\\phi(x,y) = x + y + 1$。\n\n科学真实性：上述定义在扩展有限元方法 (XFEM) 中是标准的，而基于网格的诊断指标通过表征单元上丰富基的大小和跳跃，作为可视化的数值代理。\n\n您的程序必须输出一行包含结果列表的内容，每个测试用例一个列表，格式严格为 $[ [z_{\\text{nodes}}^{(A)}, z_{\\text{grid}}^{(A)}, z_{\\text{jump}}^{(A)}, z_{\\text{L2}}^{(A)}], [z_{\\text{nodes}}^{(B)}, z_{\\text{grid}}^{(B)}, z_{\\text{jump}}^{(B)}, z_{\\text{L2}}^{(B)}], [z_{\\text{nodes}}^{(C)}, z_{\\text{grid}}^{(C)}, z_{\\text{jump}}^{(C)}, z_{\\text{L2}}^{(C)} ] ]$，每个数字四舍五入到六位小数。此问题不使用物理单位。不使用角度。输出必须是单行，不含任何附加文本。", "solution": "用户已提交问题陈述以供验证和求解。\n\n### 第 1 步：提取已知条件\n- **域**：由单位正方形 $[0,1] \\times [0,1]$ 定义的二维双线性等参四边形单元 $\\Omega_{e}$。\n- **节点**：四个节点，坐标分别为 $\\mathbf{x}_1 = (0,0)$、$\\mathbf{x}_2 = (1,0)$、$\\mathbf{x}_3 = (1,1)$ 和 $\\mathbf{x}_4 = (0,1)$。\n- **标准基函数**：标准的双线性形函数为 $N_1(x,y) = (1-x)(1-y)$、$N_2(x,y) = x(1-y)$、$N_3(x,y) = xy$ 和 $N_4(x,y) = (1-x)y$。\n- **不连续性表示**：使用一个水平集函数 $\\phi(\\mathbf{x})$，不连续性由零等值线 $\\phi(\\mathbf{x}) = 0$ 定义。\n- **Heaviside 函数**：Heaviside 函数定义为，当 $\\phi  0$ 时 $H(\\phi)=+1$，当 $\\phi  0$ 时 $H(\\phi)=-1$，当 $\\phi=0$ 时 $H(\\phi)=0$。\n- **丰富基函数**：节点 $i$ 的 Heaviside 丰富基函数为 $\\psi_i(\\mathbf{x}) = N_i(\\mathbf{x})\\left(H(\\phi(\\mathbf{x})) - H(\\phi(\\mathbf{x}_i))\\right)$（如果单元被切割），否则为 $\\psi_i(\\mathbf{x})=0$。\n- **切割单元准则**：如果水平集函数在其节点上同时具有正值和负值，即 $\\min_{j} \\phi(\\mathbf{x}_j)  0$ 且 $\\max_{j} \\phi(\\mathbf{x}_j)  0$，则认为单元被切割。\n- **任务细节**：实现必须专注于节点 $i=1$ 的丰富。\n- **数值网格**：将域 $\\Omega_e$ 离散为一个 $M \\times M$ 点的均匀网格，其中 $M=101$。\n- **$\\psi_1(\\mathbf{x})$ 的诊断量**：\n    1. $z_{\\text{nodes}} = \\max_{j \\in \\{1,2,3,4\\}} \\left|\\psi_1(\\mathbf{x}_j)\\right|$。\n    2. $z_{\\text{grid}} = \\max_{(x,y)\\in \\mathcal{G}} \\left|\\psi_1(x,y)\\right|$，在网格 $\\mathcal{G}$ 上。\n    3. $z_{\\text{jump}}$：在单元中心 $\\mathbf{p}_c=(0.5,0.5)$ 处的近似跳跃。仅当 $|\\phi(\\mathbf{p}_c)| \\le \\tau=10^{-12}$ 时非零。跳跃计算为 $\\psi_1(\\mathbf{p}_c + \\varepsilon \\mathbf{n}) - \\psi_1(\\mathbf{p}_c - \\varepsilon \\mathbf{n})$，其中 $\\varepsilon = 10^{-6}$，$\\mathbf{n}$ 是在 $\\mathbf{p}_c$ 处 $\\phi$ 的归一化梯度。梯度通过步长 $h=10^{-8}$ 的中心差分计算。\n    4. $z_{\\text{L2}}$：离散 $L^2$ 范数，$z_{\\text{L2}} \\approx \\left(\\sum_{(x,y) \\in \\mathcal{G}} \\psi_1(x,y)^2 \\,\\Delta x \\,\\Delta y \\right)^{1/2}$，网格间距为 $\\Delta x = \\Delta y = 1/(M-1)$。\n- **测试套件**：\n    - 情况 A：$\\phi(x,y) = x + y - 1$ (内部切割)。\n    - 情况 B：$\\phi(x,y) = x$ (与边界对齐，无内部切割)。\n    - 情况 C：$\\phi(x,y) = x + y + 1$ (无切割)。\n\n### 第 2 步：使用提取的已知条件进行验证\n对问题陈述进行严格验证。\n1.  **科学基础**：该问题牢固地植根于扩展有限元方法 (XFEM) 的既定原理，XFEM 是计算力学中用于模拟不连续性问题的标准技术。水平集、Heaviside 丰富和基函数的定义都是权威性的。\n2.  **适定性**：该问题是一个定义明确的计算任务。所有函数、参数和测试用例都得到了明确的规定，确保可以确定一组唯一的数值结果。\n3.  **客观性**：语言是客观和数学化的。不需要主观解释。\n4.  **完整性与一致性**：问题是自洽的。提供了所有必要的信息。定义在内部是一致的；例如，根据设计，丰富基函数 $\\psi_i(\\mathbf{x})$ 在所有节点位置 $\\mathbf{x}_j$ 处均为零，而诊断指标 $z_{\\text{nodes}}$ 正是为了验证这一性质。\n5.  **可行性**：所需的计算在计算上是可行的，并且是数值分析的标准操作。\n\n满足了有效问题的所有标准。没有科学、逻辑或结构上的缺陷。\n\n### 第 3 步：结论与行动\n问题是**有效的**。将提供一个解决方案。\n\n---\n\n### 基于原理的解决方案设计\n\n目标是为双线性四边形单元实现和分析一个 Heaviside 丰富的基函数 $\\psi_1(\\mathbf{x})$。这是扩展有限元方法 (XFEM) 的一个基本组成部分。XFEM 丰富了有限元方法 (FEM) 的标准多项式逼近空间，以便在不要求网格与不连续性几何形状共形的情况下模拟不连续性。\n\n算法设计直接源于所提供的定义。\n\n**1. 单元与基函数定义**\n基础是单位正方形 $\\Omega_e = [0,1] \\times [0,1]$ 上的标准双线性单元。节点 1（位于原点 $(0,0)$）的形函数是 $N_1(x,y) = (1-x)(1-y)$。Heaviside 函数 $H(\\phi)$ 被实现为符号函数 (signum function)，它将水平集函数 $\\phi$ 的正值、负值和零值分别映射到 $+1$、$-1$ 和 $0$。\n\n**2. 丰富激活**\nXFEM 的核心思想是仅对那些被不连续性实际穿过的单元应用丰富。这由“切割单元准则”(`cut element criterion`) 确定。算法首先在四个单元节点 $\\mathbf{x}_j$ 处评估水平集函数 $\\phi(\\mathbf{x})$。如果 $\\phi(\\mathbf{x}_j)$ 的符号不全相同（且不全为零），具体来说，如果 $\\min_j \\phi(\\mathbf{x}_j)  0$ 且 $\\max_j \\phi(\\mathbf{x}_j)  0$，则该单元被标记为“切割”(cut)。对于所有其他情况（例如，不连续性位于单元外部，或在边界上相切而未穿过），丰富项处于非激活状态，且丰富基函数 $\\psi_1(\\mathbf{x})$ 在整个单元上恒为零。\n\n**3. 丰富基函数 $\\psi_1(\\mathbf{x})$ 的构建**\n如果单元被切割，节点 1 的丰富基函数构建如下：\n$$\n\\psi_1(\\mathbf{x}) = N_1(\\mathbf{x}) \\left( H(\\phi(\\mathbf{x})) - H(\\phi(\\mathbf{x}_1)) \\right)\n$$\n在这里，$H(\\phi(\\mathbf{x}_1))$ 是一个由节点 1 处水平集的符号决定的常数标量值。项 $H(\\phi(\\mathbf{x}))$ 在单元内空间变化，从而产生所需的跳跃。与形函数 $N_1(\\mathbf{x})$ 的乘积确保了丰富是局部的，并且其影响在远离节点 1 的地方消失。关键的是，此公式保证了在所有节点 $j=1,2,3,4$ 处 $\\psi_1(\\mathbf{x}_j) = 0$，因为对于 $j \\neq 1$，$N_1(\\mathbf{x}_j)=0$；而对于 $j=1$，括号中的项变为零。\n\n**4. 诊断指标的计算**\n四个诊断指标用于表征 $\\psi_1(\\mathbf{x})$ 的行为。\n- $z_{\\text{nodes}}$：这验证了 $\\psi_1(\\mathbf{x})$ 在所有节点处为零的理论性质。通过在四个节点处计算 $|\\psi_1(\\mathbf{x}_j)|$ 并找到最大值来得到。预期结果总是 $0$。\n- $z_{\\text{grid}}$：这测量了单元上丰富函数的最大振幅。通过在一个 $101 \\times 101$ 点的精细网格上计算 $|\\psi_1(x,y)|$ 并确定最大值来找到。\n- $z_{\\text{jump}}$：该诊断指标量化了函数 $\\psi_1$ 穿过不连续线 $\\phi=0$ 时的跳跃幅度，特别是在单元中心 $\\mathbf{p}_c=(0.5,0.5)$ 附近。如果不连续性不穿过中心（即 $|\\phi(\\mathbf{p}_c)|  \\tau$），则跳跃定义为 $0$。否则，不连续线的法向量 $\\mathbf{n}$ 通过对 $\\phi$ 使用中心有限差分来近似。然后通过在跨越界面的两个点 $\\mathbf{p}_c \\pm \\varepsilon\\mathbf{n}$ 上对 $\\psi_1$ 进行采样并取其差值来计算跳跃。对于 Heaviside 丰富，$\\psi_1$ 跨界面的跳跃预期约为 $N_1(\\mathbf{x}) \\times (H(\\phi0) - H(\\phi0)) = N_1(\\mathbf{x}) \\times (1 - (-1)) = 2 N_1(\\mathbf{x})$。在中心点，这预测的跳跃为 $2 \\times N_1(0.5,0.5) = 2 \\times 0.25 = 0.5$。\n- $z_{\\text{L2}}$：这计算了丰富函数的能量。它通过网格点上的离散和来近似，这对应于积分 $\\int_{\\Omega_e} \\psi_1(x,y)^2 \\, dA$ 的数值求积（黎曼和, Riemann sum）。\n\n**5. 测试用例分析**\n- **情况 A ($\\phi = x+y-1$)**: $\\phi$ 的节点值为 $\\{-1, 0, 1, 0\\}$。由于存在负值和正值，单元被切割。除 $z_{\\text{nodes}}$ 外，所有诊断指标都应为非零。界面穿过中心，因此将计算 $z_{\\text{jump}}$，其值应接近 $0.5$。\n- **情况 B ($\\phi = x$)**: 节点值为 $\\{0, 1, 1, 0\\}$。由于 $\\min_j \\phi(\\mathbf{x}_j)$ 不小于 $0$，不满足“切割”(`cut`) 准则。丰富项处于非激活状态，且 $\\psi_1(\\mathbf{x})=0$。所有诊断指标将为 $0$。\n- **情况 C ($\\phi = x+y+1$)**: 节点值为 $\\{1, 2, 3, 2\\}$。所有值均为正。单元未被切割。所有诊断指标将为 $0$。\n\n这个系统化的程序能够鲁棒且正确地实现指定的 XFEM 构造及其数值分析。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and evaluates a Heaviside-enriched basis function for a bilinear\n    quadrilateral element in XFEM.\n    \"\"\"\n\n    test_cases = [\n        {'name': 'A', 'phi': lambda x, y: x + y - 1},\n        {'name': 'B', 'phi': lambda x, y: x},\n        {'name': 'C', 'phi': lambda x, y: x + y + 1},\n    ]\n\n    all_results = []\n\n    M = 101\n    tau = 1e-12\n    h_grad = 1e-8\n    epsilon_jump = 1e-6\n    \n    nodes = np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]])\n    node_of_interest_idx = 0  # Node 1 is at index 0\n\n    x_grid_vals = np.linspace(0.0, 1.0, M)\n    y_grid_vals = np.linspace(0.0, 1.0, M)\n    xx, yy = np.meshgrid(x_grid_vals, y_grid_vals, indexing='xy')\n    dx = 1.0 / (M - 1)\n    dy = 1.0 / (M - 1)\n\n    def N1_func(x, y):\n        return (1.0 - x) * (1.0 - y)\n\n    def H_func(val):\n        return np.sign(val)\n\n    for case in test_cases:\n        phi_func = case['phi']\n\n        # Determine if the element is cut\n        phi_at_nodes = np.array([phi_func(n[0], n[1]) for n in nodes])\n        is_cut = np.min(phi_at_nodes)  0 and np.max(phi_at_nodes)  0\n\n        # Pre-calculate values for the enriched basis function psi_1\n        phi_at_node1 = phi_at_nodes[node_of_interest_idx]\n        H_phi_at_node1 = H_func(phi_at_node1)\n\n        # --- Define psi_1 for pointwise and grid evaluation ---\n        \n        # Pointwise function for z_jump calculation\n        def psi_1_pointwise(x, y):\n            if not is_cut:\n                return 0.0\n            phi_val = phi_func(x, y)\n            H_phi_val = H_func(phi_val)\n            return N1_func(x, y) * (H_phi_val - H_phi_at_node1)\n\n        # Vectorized grid evaluation for z_grid and z_L2\n        if not is_cut:\n            psi_grid = np.zeros_like(xx)\n        else:\n            phi_grid = phi_func(xx, yy)\n            H_phi_grid = H_func(phi_grid)\n            N1_grid = N1_func(xx, yy)\n            psi_grid = N1_grid * (H_phi_grid - H_phi_at_node1)\n\n        # --- Compute diagnostics ---\n\n        # 1. z_nodes\n        psi_at_nodes = np.array([psi_1_pointwise(n[0], n[1]) for n in nodes])\n        z_nodes = np.max(np.abs(psi_at_nodes))\n\n        # 2. z_grid\n        z_grid = np.max(np.abs(psi_grid))\n\n        # 3. z_jump\n        pc = np.array([0.5, 0.5])\n        phi_at_pc = phi_func(pc[0], pc[1])\n        \n        if np.abs(phi_at_pc)  tau or not is_cut:\n            z_jump = 0.0\n        else:\n            # Gradient by central finite differences\n            dphi_dx = (phi_func(pc[0] + h_grad, pc[1]) - phi_func(pc[0] - h_grad, pc[1])) / (2 * h_grad)\n            dphi_dy = (phi_func(pc[0], pc[1] + h_grad) - phi_func(pc[0], pc[1] - h_grad)) / (2 * h_grad)\n            grad_phi = np.array([dphi_dx, dphi_dy])\n            \n            norm_grad = np.linalg.norm(grad_phi)\n            if norm_grad  1e-15: # Avoid division by zero\n                 n_vec = np.array([0.0, 0.0])\n            else:\n                 n_vec = grad_phi / norm_grad\n            \n            p_plus = pc + epsilon_jump * n_vec\n            p_minus = pc - epsilon_jump * n_vec\n            \n            psi_plus = psi_1_pointwise(p_plus[0], p_plus[1])\n            psi_minus = psi_1_pointwise(p_minus[0], p_minus[1])\n            \n            z_jump = psi_plus - psi_minus\n\n        # 4. z_L2\n        z_L2 = np.sqrt(np.sum(psi_grid**2) * dx * dy)\n\n        all_results.append([z_nodes, z_grid, z_jump, z_L2])\n\n    # Format the final output string as specified in the problem\n    formatted_cases = []\n    for case_result in all_results:\n        formatted_numbers = ', '.join([f'{num:.6f}' for num in case_result])\n        formatted_cases.append(f'[{formatted_numbers}]')\n    \n    final_string = f\"[{', '.join(formatted_cases)}]\"\n    print(final_string)\n\nsolve()\n```", "id": "2390842"}, {"introduction": "在定义了增强基函数之后，下一个关键挑战是如何计算包含这些不连续函数的单元的积分，例如刚度矩阵。由于被切割后积分区域形状不规则，且被积函数存在不连续性，标准的数值积分方法（如高斯求积）可能不再适用或精度不足。这个实践练习将引导您为被直线任意切割的三角形单元开发一种定制的数值积分方案 [@problem_id:2390826]。掌握这种技术对于在 XFEM 中获得准确的数值解至关重要。", "problem": "在扩展有限元法 (XFEM) 的背景下，考虑一个二维空间中的单个三角形有限元。该单元被一条代表不连续性（例如，裂纹表面）的直线所切割。设该三角形的顶点位于平面坐标系中，该直线由标量函数 $\\phi(x,y) = a x + b y + c$ 隐式表示，其正半平面定义为 $\\{(x,y) \\, | \\, \\phi(x,y) \\ge 0\\}$。将单位阶跃（Heaviside）富集域定义为该三角形单元与此正半平面的交集。目标是构建一个自定义的数值求积法则，能够对位于 Heaviside 域内的那部分三角形单元上的多项式场进行积分。\n\n对于每个给定的测试用例，计算标量积分\n$$\nI \\;=\\; \\iint_{\\Omega_+} f(x,y) \\,\\mathrm{d}A,\n$$\n其中 $\\Omega_+ = \\{(x,y) \\in T \\, | \\, \\phi(x,y) \\ge 0\\}$ 且 $T$ 是由测试用例中提供的三个顶点构成的闭合三角形区域。所有测试用例的被积函数均为多项式\n$$\nf(x,y) \\;=\\; x^2 + y.\n$$\n量 $I$ 不附带任何物理单位；以实数形式报告数值。问题中不涉及角度。每个测试用例的最终答案必须以浮点数形式返回。\n\n使用以下测试套件。在每个用例中，三角形由一个有序的顶点三元组给出，直线由其在隐式形式 $\\phi(x,y) = a x + b y + c$ 中的系数 $(a,b,c)$ 给出。\n\n- 测试用例 1（一般切割，产生一个凸四边形子域）：\n  - 三角形顶点：$(0,0)$, $(1,0)$, $(0,1)$。\n  - 直线系数：$(a,b,c) = (1,1,-0.5)$，即 $\\phi(x,y) = x + y - 0.5$。\n\n- 测试用例 2（无切割，整个三角形位于正半平面内）：\n  - 三角形顶点：$(0,0)$, $(1,0)$, $(0,1)$。\n  - 直线系数：$(a,b,c) = (1,1,1)$，即 $\\phi(x,y) = x + y + 1$。\n\n- 测试用例 3（边界情况，直线穿过一个顶点并切割单元）：\n  - 三角形顶点：$(0,0)$, $(2,0)$, $(0,1)$。\n  - 直线系数：$(a,b,c) = (-1,1,0)$，即 $\\phi(x,y) = -x + y$。\n\n- 测试用例 4（空交集，正半平面不与三角形内部相交）：\n  - 三角形顶点：$(0,0)$, $(1,0)$, $(0,1)$。\n  - 直线系数：$(a,b,c) = (1,1,-2)$，即 $\\phi(x,y) = x + y - 2$。\n\n您的程序必须按上述顺序为每个测试用例计算 $I$，并生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的四个结果列表，例如 [$r_1$,$r_2$,$r_3$,$r_4$]，其中每个 $r_i$ 是对应于测试用例 $i$ 的浮点数结果。", "solution": "问题陈述提出了计算工程领域中的一个明确定义的任务，特别是在扩展有限元法 (XFEM) 的背景下。它要求计算一个多项式函数在一个由三角形和半平面交集定义的域上的定积分。\n\n### 步骤 1：提取已知条件\n- **积分域**：区域 $\\Omega_+ = \\{(x,y) \\in T \\, | \\, \\phi(x,y) \\ge 0\\}$，其中 $T$ 是一个闭合三角形区域，$\\phi(x,y) = ax + by + c$ 是一个线性函数。\n- **被积函数**：$f(x,y) = x^2 + y$。\n- **待积积分**：$I = \\iint_{\\Omega_+} f(x,y) \\, \\mathrm{d}A$。\n- **测试用例**：\n    1.  $T_1$：顶点 $\\{(0,0), (1,0), (0,1)\\}$；$\\phi_1(x,y) = x + y - 0.5$。\n    2.  $T_2$：顶点 $\\{(0,0), (1,0), (0,1)\\}$；$\\phi_2(x,y) = x + y + 1$。\n    3.  $T_3$：顶点 $\\{(0,0), (2,0), (0,1)\\}$；$\\phi_3(x,y) = -x + y$。\n    4.  $T_4$：顶点 $\\{(0,0), (1,0), (0,1)\\}$；$\\phi_4(x,y) = x + y - 2$。\n\n### 步骤 2：使用提取的已知条件进行验证\n对问题进行验证：\n- **科学依据**：该问题是 XFEM 中处理与网格不一致的不连续性的标准程序。它基于微积分和计算几何的基本原理。问题有效。\n- **适定性**：积分域 $\\Omega_+$ 是一个紧致凸集（一个多边形、完整的三角形或空集）。被积函数 $f(x,y)$ 是一个多项式，因此在 $\\Omega_+$ 上是连续且有界的。该积分是明确定义的，并具有唯一值。问题有效。\n- **客观性**：问题使用精确的数学语言陈述，没有任何主观或模棱两可的术语。问题有效。\n- **完整性与一致性**：为每个测试用例提供了所有必要的数据（顶点、直线系数、被积函数）。没有矛盾之处。问题有效。\n\n### 步骤 3：结论与行动\n该问题被判定为**有效**。将构建一个严谨的解决方案。\n\n### 求解方法\n\n问题的核心是计算积分 $I = \\iint_{\\Omega_+} (x^2+y) \\, \\mathrm{d}A$。域 $\\Omega_+$ 是父三角形 $T$ 中水平集函数 $\\phi(x,y)$ 为非负的部分。$\\Omega_+$ 的性质取决于在 $T$ 的顶点处计算出的 $\\phi$ 值的符号。设三角形顶点为 $V_1, V_2, V_3$。我们计算 $i=1,2,3$ 的 $\\phi_i = \\phi(V_i)$。\n\n策略是根据位于正半平面（其中 $\\phi \\ge 0$）内的顶点数量对构型进行分类。\n\n1.  **所有顶点均在正半平面内**：如果所有 $\\phi_i \\ge 0$，则整个三角形 $T$ 就是积分域，$\\Omega_+ = T$。\n2.  **所有顶点均在负半平面内**：如果所有 $\\phi_i  0$，则 $\\Omega_+$ 为空集，积分为 $0$。\n3.  **直线切割三角形**：如果顶点处的 $\\phi$ 值符号正负混合，则直线 $\\phi(x,y)=0$ 与三角形相交。积分域 $\\Omega_+$ 是一个凸多边形（三角形或四边形）。\n    - **一个顶点在正半平面内**：如果一个顶点（比如 $V_p$）满足 $\\phi(V_p) \\ge 0$，而另外两个顶点 $V_{n1}$ 和 $V_{n2}$ 的 $\\phi$ 值为负，那么积分域 $\\Omega_+$ 是一个较小的三角形。其顶点是 $V_p$ 以及直线 $\\phi=0$ 与边 $(V_p, V_{n1})$ 和 $(V_p, V_{n2})$ 的两个交点。\n    - **两个顶点在正半平面内**：如果两个顶点（比如 $V_{p1}, V_{p2}$）满足 $\\phi \\ge 0$，而一个顶点 $V_n$ 满足 $\\phi  0$，那么积分域 $\\Omega_+$ 是一个四边形。一种直接且鲁棒的计算积分的方法是从整个三角形的积分中减去被切掉的小块部分的积分。被切掉的部分是一个三角形，其顶点为 $V_n$ 和直线 $\\phi=0$ 与边 $(V_n, V_{p1})$ 和 $(V_n, V_{p2})$ 的两个交点。\n\n连接顶点 $A$ 和 $B$ 的边上的交点 $P_{int}$ 可以通过将该边参数化为 $P(t) = A + t(B-A)$（其中 $t \\in [0,1]$）来找到。根据 $\\phi$ 的线性性质，我们有 $\\phi(P(t)) = (1-t)\\phi(A) + t\\phi(B) = 0$。求解 $t$ 可得 $t = \\phi(A) / (\\phi(A) - \\phi(B))$。那么交点就是 $P_{int} = A + t(B-A)$。\n\n为了计算多项式 $f(x,y)=x^2+y$ 在任意三角形上的积分，我们使用一个对二次多项式精确的数值求积法则。一个位于三角形各边中点的三点高斯求积法则满足此要求。对于一个面积为 $A'$ 的三角形 $T'$，该积分由下式给出：\n$$\n\\iint_{T'} f(x,y) \\, \\mathrm{d}A = \\frac{A'}{3} \\sum_{k=1}^{3} f(m_k)\n$$\n其中 $m_k$ 是 $T'$ 三条边的中点。具有顶点 $(x_1, y_1), (x_2, y_2), (x_3, y_3)$ 的三角形的面积 $A'$ 计算公式为 $A' = \\frac{1}{2} |x_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3(y_1 - y_2)|$。\n\n该方法为解决所有给定的测试用例提供了一个完整且系统的方法。\n\n### 逐案分析\n\n- **测试用例 1**：顶点 $V_1(0,0), V_2(1,0), V_3(0,1)$。直线 $\\phi(x,y) = x+y-0.5$。\n$\\phi(V_1) = -0.5$，$\\phi(V_2) = 0.5$，$\\phi(V_3)=0.5$。\n这是一个“两正一负”的情况。我们计算整个父三角形 $T$ 上的积分，然后减去由顶点 $V_1$ 以及在边 $(V_1,V_2)$ 和 $(V_1,V_3)$ 上的交点形成的小切割三角形上的积分。\n- **测试用例 2**：顶点 $V_1(0,0), V_2(1,0), V_3(0,1)$。直线 $\\phi(x,y) = x+y+1$。\n$\\phi(V_1)=1$，$\\phi(V_2)=2$，$\\phi(V_3)=2$。全部为正。积分在整个三角形 $T$ 上进行。\n- **测试用例 3**：顶点 $V_1(0,0), V_2(2,0), V_3(0,1)$。直线 $\\phi(x,y) = -x+y$。\n$\\phi(V_1)=0$，$\\phi(V_2)=-2$，$\\phi(V_3)=1$。这被视为“两正（$\\phi \\ge 0$），一负”的情况。\n- **测试用例 4**：顶点 $V_1(0,0), V_2(1,0), V_3(0,1)$。直线 $\\phi(x,y) = x+y-2$。\n$\\phi(V_1)=-2$，$\\phi(V_2)=-1$，$\\phi(V_3)=-1$。全部为负。积分域为空，因此积分为 $0$。\n\n实现将遵循此逻辑来计算所需的值。", "answer": "```python\nimport numpy as np\n\ndef integrate_over_triangle(vertices):\n    \"\"\"\n    Computes the integral of f(x,y) = x^2 + y over a triangle using a\n    3-point midpoint quadrature rule, which is exact for quadratic polynomials.\n    \n    Args:\n        vertices (list of tuples): A list of three (x, y) tuples for the triangle vertices.\n\n    Returns:\n        float: The value of the integral.\n    \"\"\"\n    p1, p2, p3 = np.array(vertices[0]), np.array(vertices[1]), np.array(vertices[2])\n\n    # Integrand function\n    f = lambda p: p[0]**2 + p[1]\n\n    # Area of the triangle\n    area = 0.5 * abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n\n    if area  1e-12:  # Degenerate triangle\n        return 0.0\n\n    # Midpoints of the edges\n    m1 = (p1 + p2) / 2.0\n    m2 = (p2 + p3) / 2.0\n    m3 = (p3 + p1) / 2.0\n\n    # Evaluate function at midpoints\n    f_vals = [f(m1), f(m2), f(m3)]\n\n    # Apply quadrature rule\n    integral = (area / 3.0) * sum(f_vals)\n    return integral\n\n\ndef calculate_integral_for_case(triangle_verts, line_coeffs):\n    \"\"\"\n    Calculates the integral for a single test case by determining the\n    integration domain and applying the appropriate integration strategy.\n    \n    Args:\n        triangle_verts (list of tuples): Vertices of the parent triangle.\n        line_coeffs (tuple): Coefficients (a, b, c) of the line ax+by+c=0.\n    \n    Returns:\n        float: The final computed integral.\n    \"\"\"\n    a, b, c = line_coeffs\n    phi = lambda p: a*p[0] + b*p[1] + c\n    \n    V = [np.array(v) for v in triangle_verts]\n    phi_vals = np.array([phi(v) for v in V])\n    \n    pos_indices = [i for i, pv in enumerate(phi_vals) if pv = 0]\n    neg_indices = [i for i, pv in enumerate(phi_vals) if pv  0]\n\n    # Case 1: All vertices in the positive half-plane (phi = 0)\n    if len(pos_indices) == 3:\n        return integrate_over_triangle(V)\n        \n    # Case 2: All vertices in the negative half-plane (phi  0)\n    if len(neg_indices) == 3:\n        return 0.0\n\n    # Case 3: Line cuts the triangle.\n    # Case 3a: One vertex has phi = 0, two have phi  0.\n    # The integration domain is a small triangle.\n    if len(pos_indices) == 1:\n        p_idx = pos_indices[0]\n        n_idx1, n_idx2 = neg_indices\n        \n        Vp, Vn1, Vn2 = V[p_idx], V[n_idx1], V[n_idx2]\n        phi_p, phi_n1, phi_n2 = phi_vals[p_idx], phi_vals[n_idx1], phi_vals[n_idx2]\n        \n        # Intersection on edge (Vp, Vn1)\n        t1 = phi_p / (phi_p - phi_n1)\n        I1 = Vp + t1 * (Vn1 - Vp)\n        \n        # Intersection on edge (Vp, Vn2)\n        t2 = phi_p / (phi_p - phi_n2)\n        I2 = Vp + t2 * (Vn2 - Vp)\n        \n        integration_triangle = [Vp, I1, I2]\n        return integrate_over_triangle(integration_triangle)\n\n    # Case 3b: Two vertices have phi = 0, one has phi  0.\n    # The integration domain is a quadrilateral. We compute its integral by subtraction.\n    if len(pos_indices) == 2:\n        n_idx = neg_indices[0]\n        p_idx1, p_idx2 = pos_indices\n        \n        integral_total = integrate_over_triangle(V)\n        \n        Vn, Vp1, Vp2 = V[n_idx], V[p_idx1], V[p_idx2]\n        phi_n, phi_p1, phi_p2 = phi_vals[n_idx], phi_vals[p_idx1], phi_vals[p_idx2]\n        \n        # Intersection on edge (Vn, Vp1)\n        t1 = phi_n / (phi_n - phi_p1)\n        I1 = Vn + t1 * (Vp1 - Vn)\n        \n        # Intersection on edge (Vn, Vp2)\n        t2 = phi_n / (phi_n - phi_p2)\n        I2 = Vn + t2 * (Vp2 - Vn)\n        \n        cutoff_triangle = [Vn, I1, I2]\n        integral_cutoff = integrate_over_triangle(cutoff_triangle)\n\n        return integral_total - integral_cutoff\n    \n    return 0.0 # Should not be reached with valid triangle inputs\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        ([(0, 0), (1, 0), (0, 1)], (1, 1, -0.5)),\n        # Test case 2\n        ([(0, 0), (1, 0), (0, 1)], (1, 1, 1)),\n        # Test case 3\n        ([(0, 0), (2, 0), (0, 1)], (-1, 1, 0)),\n        # Test case 4\n        ([(0, 0), (1, 0), (0, 1)], (1, 1, -2)),\n    ]\n\n    results = []\n    for triangle_verts, line_coeffs in test_cases:\n        result = calculate_integral_for_case(triangle_verts, line_coeffs)\n        results.append(result)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.16f}'.rstrip('0').rstrip('.') for r in results)}]\")\n\nsolve()\n```", "id": "2390826"}, {"introduction": "对于更复杂的裂纹问题，XFEM 不仅需要模拟裂纹体本身的不连续位移，还需要捕捉裂纹尖端的应力奇异性。这通常需要两种不同类型的增强：用于裂纹体的亥维赛德函数和用于裂纹尖端的渐近场函数。因此，一个强大的 XFEM 程序必须能够自动识别哪些单元需要哪种类型的增强。本练习将让您基于水平集 (level-set) 的几何信息，设计并实现一个稳健的单元分类准则，以区分标准单元、亥维赛德增强单元和尖端增强单元 [@problem_id:2551522]。", "problem": "给定一个凸四边形二维有限元，其节点按逆时针顺序索引为 $i \\in \\{0,1,2,3\\}$。设 $\\phi(\\mathbf{x})$ 和 $\\psi(\\mathbf{x})$ 为两个用于表示裂纹的水平集场，具体如下：裂纹面是零等值线 $\\{\\mathbf{x} : \\phi(\\mathbf{x}) = 0\\}$，裂纹尖端是零等值线的交集 $\\{\\mathbf{x} : \\phi(\\mathbf{x}) = 0\\} \\cap \\{\\mathbf{x} : \\psi(\\mathbf{x}) = 0\\}$。假设在每个单元内，水平集是根据其节点值沿每条边进行线性插值的。你的任务是推导、论证并实现一个稳健的分类准则，将每个单元分配到扩展有限元法中使用的三个不相交集合之一：尖端富集、Heaviside 富集或标准。\n\n基本依据和允许的假设：\n- 扩展有限元法 (XFEM) 采用单位分解法 (PUM) 来富集不连续性附近的近似空间。裂纹内部通过 Heaviside 函数富集来表示，裂纹尖端则通过反映近尖端渐近场的函数来表示。\n- 在直边上线性插值的标量场，如果其节点值符号相反，则是严格单调的，因此在该边上恰好有一个零点。如果两个节点值符号相同且非零，则该边上没有零点。如果一个节点值为零，则零等值线穿过该节点。这些论述在单元各向异性的情况下均成立。\n- 设 $\\tau$ 表示一个很小的容差，取 $\\tau = 10^{-12}$，用于判断一个浮点数值是否可被视为零。\n\n任务 1：基于这些依据，仅使用节点坐标 $\\{(x_i,y_i)\\}_{i=0}^3$ 和节点水平集值 $\\{(\\phi_i,\\psi_i)\\}_{i=0}^3$ 制定一个准则，将一个单元分类为：\n- 尖端富集，当且仅当 $\\phi$ 和 $\\psi$ 的零等值线在闭合单元内部相交，即它们的交点位于多边形内（包括其边界）。此外，如果存在一个节点 $k$ 使得 $|\\phi_k| \\le \\tau$ 且 $|\\psi_k| \\le \\tau$，则该单元必须被分类为尖端富集。\n- Heaviside 富集，当且仅当 $\\phi$ 的零等值线穿过该单元，但该单元不属于尖端富集。\n- 标准，其他所有情况。\n\n你的准则必须从水平集沿边插值的基本原理推导得出。具体而言，对于每条边 $(i,j)$，使用节点值的符号来判断 $\\ell \\in \\{\\phi,\\psi\\}$ 是否改变符号。如果改变，则当 $\\ell_i \\cdot \\ell_j  0$ 时，通过线性插值计算唯一的过零点：\n$$\nt = \\frac{\\ell_i}{\\ell_i - \\ell_j}, \\qquad \\mathbf{p}_{\\ell,ij} = (1-t)\\,\\mathbf{x}_i + t\\,\\mathbf{x}_j,\n$$\n并将 $\\ell_i = 0$ 或 $\\ell_j = 0$（在容差 $\\tau$ 范围内）的情况视作在相应节点处的零点。使用 $\\phi$ 在单元边界上的所有零点集合，通过连接两个相距最远的离散边界零点，来生成一个近似 $\\{\\mathbf{x}:\\phi(\\mathbf{x})=0\\}$ 在单元内部的线段（如果存在的不同点少于两个，则零等值线不穿过该单元）。对 $\\psi$ 也进行同样的操作。当且仅当得到的 $\\phi$-线段和 $\\psi$-线段在闭合单元内相交，或者存在一个节点其 $\\phi$ 和 $\\psi$ 值在容差 $\\tau$ 内都为零时，声明为“尖端富集”。当且仅当 $\\phi$-线段存在但单元不属于尖端富集时，声明为“Heaviside 富集”。否则，声明为“标准”。\n\n任务 2：通过仅引用上述基本依据，论证这个基于边、符号变化和插值的准则是如何在网格各向异性下保持稳健的。具体来说，需要论证符号变化检测和沿边的线性插值与单元拉伸和扭曲无关，并且线段相交逻辑仅依赖于边界上过零点的几何形状。\n\n任务 3：实现一个程序，将你的分类方法应用于以下测试套件。每个测试用例提供固定节点顺序 $i=0,1,2,3$ 下的节点坐标 $(x_i,y_i)$ 和节点水平集值 $(\\phi_i,\\psi_i)$。\n\n- 测试用例 1（Heaviside 富集，“理想情况”）：\n  - $(x_i,y_i) = [ (\\,0\\,,\\,0\\,), (\\,1\\,,\\,0\\,), (\\,1\\,,\\,1\\,), (\\,0\\,,\\,1\\,) ]$\n  - $\\phi_i = [ -1, 1, 1, -1 ]$\n  - $\\psi_i = [ 2, 2, 2, 2 ]$\n\n- 测试用例 2（尖端富集，内部相交）：\n  - $(x_i,y_i) = [ (\\,0\\,,\\,0\\,), (\\,1\\,,\\,0\\,), (\\,1\\,,\\,1\\,), (\\,0\\,,\\,1\\,) ]$\n  - $\\phi_i = [ -0.5, 0.5, 0.5, -0.5 ]$\n  - $\\psi_i = [ -0.5, -0.5, 0.5, 0.5 ]$\n\n- 测试用例 3（标准，无裂纹穿过）：\n  - $(x_i,y_i) = [ (\\,0\\,,\\,0\\,), (\\,1\\,,\\,0\\,), (\\,1\\,,\\,1\\,), (\\,0\\,,\\,1\\,) ]$\n  - $\\phi_i = [ -1, -1, -1, -1 ]$\n  - $\\psi_i = [ -1, -1, -1, -1 ]$\n\n- 测试用例 4（尖端富集，简并尖端位于节点上）：\n  - $(x_i,y_i) = [ (\\,0\\,,\\,0\\,), (\\,1\\,,\\,0\\,), (\\,1\\,,\\,1\\,), (\\,0\\,,\\,1\\,) ]$\n  - $\\phi_i = [ 0, 1, 1, 0 ]$\n  - $\\psi_i = [ 0, 0, 1, 1 ]$\n\n- 测试用例 5（Heaviside 富集，各向异性矩形）：\n  - $(x_i,y_i) = [ (\\,0\\,,\\,0\\,), (\\,10\\,,\\,0\\,), (\\,10\\,,\\,1\\,), (\\,0\\,,\\,1\\,) ]$\n  - $\\phi_i = [ -5, 5, 5, -5 ]$\n  - $\\psi_i = [ 1, 1, 1, 1 ]$\n\n- 测试用例 6（Heaviside 富集，两条等值线均穿过但不在单元内相交）：\n  - $(x_i,y_i) = [ (\\,0\\,,\\,0\\,), (\\,1\\,,\\,0\\,), (\\,1\\,,\\,1\\,), (\\,0\\,,\\,1\\,) ]$\n  - $\\phi_i = [ -0.5, 0.5, 0.5, -0.5 ]$\n  - $\\psi_i = [ -0.4, 0.6, 1.6, 0.6 ]$\n\n使用以下整数代码进行分类：尖端富集 $\\to 2$，Heaviside 富集 $\\to 1$，标准 $\\to 0$。你的程序必须使用上述通用准则处理所有测试用例，并生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[a_1,a_2,\\dots,a_6]$，其中每个 $a_k$ 是第 $k$ 个测试用例的整数代码（按顺序）。此问题不涉及单位或角度，也无需外部输入。在需要时，使用容差 $\\tau = 10^{-12}$ 进行零值测试和几何谓词判断。", "solution": "任务是为在扩展有限元法 (XFEM) 中使用的二维四边形有限元制定、论证并实现一个稳健的分类准则。分类取决于单元与由两个水平集函数 $\\phi(\\mathbf{x})$ 和 $\\psi(\\mathbf{x})$ 表示的裂纹之间的关系。必须仅根据节点坐标 $\\{\\mathbf{x}_i\\}_{i=0}^3$ 和水平集函数的节点值 $\\{(\\phi_i, \\psi_i)\\}_{i=0}^3$ 将单元归类为尖端富集、Heaviside 富集或标准。\n\n推导过程从基本原理出发，遵循所提供的关于水平集场沿单元边进行线性插值的假设。最终的算法分三个阶段构建：识别边界过零点、近似等值线和应用分类逻辑。\n\n**1. 准则推导**\n\n**步骤 1.1：边界过零点的识别**\n令 $\\ell(\\mathbf{x})$ 代表 $\\phi(\\mathbf{x})$ 或 $\\psi(\\mathbf{x})$ 水平集场。在单元内部，真实的等值线 $\\{\\mathbf{x} : \\ell(\\mathbf{x})=0\\}$ 是未知的。然而，在沿边线性插值的假设下，可以精确确定其与单元边界的交点。我们检查四边形的四条边，由节点对 $(0,1)$、$(1,2)$、$(2,3)$ 和 $(3,0)$ 表示。对于连接节点 $i$ 和 $j$（坐标为 $\\mathbf{x}_i$ 和 $\\mathbf{x}_j$，节点水平集值为 $\\ell_i$ 和 $\\ell_j$）的任意边：\n\n- 如果一个节点值在给定的容差 $\\tau$ 内为零，即对于 $k \\in \\{i, j\\}$ 有 $|\\ell_k| \\le \\tau$，则等值线穿过该节点 $\\mathbf{x}_k$。\n- 如果节点值符号相反，即 $\\ell_i \\cdot \\ell_j  0$，则线性插值函数必须在边的内部有且仅有一个零点。通过求解参数 $t \\in (0,1)$ 的方程 $\\ell(t) = (1-t)\\ell_i + t\\ell_j = 0$ 来找到该过零点的位置。这得到 $t = \\ell_i / (\\ell_i - \\ell_j)$。对应的坐标为 $\\mathbf{p}_{\\ell,ij} = (1-t)\\mathbf{x}_i + t\\mathbf{x}_j$。\n- 如果节点值符号相同且非零，即 $\\ell_i \\cdot \\ell_j  0$，则等值线不穿过该边。\n\n通过将此逻辑应用于 $\\phi$ 和 $\\psi$ 的所有四条边，我们生成两组唯一的边界过零点集合 $Z_\\phi$ 和 $Z_\\psi$。\n\n**步骤 1.2：构建线性等值线近似**\n边界点集 $Z_\\ell$ 代表了等值线 $\\{\\mathbf{x} : \\ell(\\mathbf{x})=0\\}$ 与单元边界的离散交点。为了近似等值线穿过单元内部的路径，我们连接其中的两个点。根据规定，如果集合 $Z_\\ell$ 包含少于两个不同点，则认为等值线不穿过该单元，不形成线段。如果 $|Z_\\ell| \\ge 2$，我们通过识别集合 $Z_\\ell$ 中欧几里得距离最大的点对 $\\{\\mathbf{p}_{\\ell,1}, \\mathbf{p}_{\\ell,2}\\} \\subseteq Z_\\ell$ 来构建一个单线段：\n$$\n(\\mathbf{p}_{\\ell,1}, \\mathbf{p}_{\\ell,2}) = \\arg\\max_{\\mathbf{p}_a, \\mathbf{p}_b \\in Z_\\ell} \\|\\mathbf{p}_a - \\mathbf{p}_b\\|_2\n$$\n只要各自的过零点集合至少包含两个点，此过程就会产生一个连接 $\\mathbf{p}_{\\phi,1}$ 和 $\\mathbf{p}_{\\phi,2}$ 的 $\\phi$-线段 $S_\\phi$，以及一个连接 $\\mathbf{p}_{\\psi,1}$ 和 $\\mathbf{p}_{\\psi,2}$ 的 $\\psi$-线段 $S_\\psi$。\n\n**步骤 1.3：分类算法**\n在具备了必要的几何构造后，根据以下分级准则对单元进行分类：\n\n1.  **尖端富集 (代码 2)：** 如果裂纹尖端位于单元域内（包括边界），则该单元被分类为尖端富集。这通过满足以下两个条件之一来确定：\n    a. **节点尖端：** 存在一个节点 $k \\in \\{0,1,2,3\\}$，在该节点上两个水平集函数在容差 $\\tau$ 内同时为零：$|\\phi_k| \\le \\tau$ 且 $|\\psi_k| \\le \\tau$。这代表裂纹尖端恰好位于一个节点上。\n    b. **内部尖端：** 如果不满足节点尖端条件，我们检查近似的等值线是否相交。如果 $\\phi$-线段 $S_\\phi$ 和 $\\psi$-线段 $S_\\psi$ 都存在，并且它们相交（$S_\\phi \\cap S_\\psi \\neq \\emptyset$），则该单元为尖端富集。这需要一个标准的计算几何算法来判断线段相交。\n\n2.  **Heaviside 富集 (代码 1)：** 如果单元未被分类为尖端富集，则检查其是否需要使用不连续的 Heaviside 函数进行富集。如果裂纹体穿过该单元但尖端不在其中，则此分类是合适的。当且仅当 $\\phi$-等值线穿过单元时，此条件成立，即边界交点集 $Z_\\phi$ 包含至少两个不同点（即线段 $S_\\phi$ 存在）。\n\n3.  **标准 (代码 0)：** 如果一个单元既不是尖端富集也不是 Heaviside 富集，它就是一个标准的、未富集的单元。这种情况发生在 $\\phi$-等值线没有在两个或更多不同点上穿过单元边界时。\n\n**2. 稳健性论证**\n\n所提出的准则对于网格各向异性（即单元拉伸和扭曲）是稳健的，因为其基本操作在仿射变换下是不变的。\n\n一个仿射变换 $T(\\mathbf{x}) = A\\mathbf{x} + \\mathbf{b}$（其中 $A$ 是可逆矩阵，$\\mathbf{b}$ 是平移向量）将直线映射为直线，并保持平行性和沿直线的距离比。一个通用的凸四边形将被映射到另一个凸四边形。\n\n1.  **符号变化检测：** 第一步，检测两个节点之间水平集函数的符号变化，是一个纯粹的拓扑操作。它仅依赖于标量值 $\\ell_i$ 和 $\\ell_j$，这些值在坐标系变换下是不变的。因此，边上是否存在过零点与单元几何形状无关。\n\n2.  **线性插值：** 插值参数 $t = \\ell_i/(\\ell_i - \\ell_j)$ 的计算仅依赖于标量水平集值，因此是不变的。过零点的位置是节点坐标的凸组合，$\\mathbf{p} = (1-t)\\mathbf{x}_i + t\\mathbf{x}_j$。如果单元经历一次仿射变换 $T$，新的节点坐标为 $\\mathbf{x}'_i = T(\\mathbf{x}_i)$ 和 $\\mathbf{x}'_j = T(\\mathbf{x}_j)$。新的过零点是：\n    $$\n    \\mathbf{p}' = (1-t)\\mathbf{x}'_i + t\\mathbf{x}'_j = (1-t)T(\\mathbf{x}_i) + tT(\\mathbf{x}_j) = T((1-t)\\mathbf{x}_i + t\\mathbf{x}_j) = T(\\mathbf{p})\n    $$\n    这表明，变换后边上的过零点就是原过零点的变换结果。过零点在边上的相对位置得以保持。\n\n3.  **线段构建与相交：** 后续步骤——识别最远点对和检查线段相交——是纯粹的几何过程。由于仿射变换将边界过零点集 $Z_\\ell$ 映射到一个新集合 $Z'_\\ell = \\{T(\\mathbf{p}) : \\mathbf{p} \\in Z_\\ell\\}$，并且仿射变换通常不保持距离，因此“最远”点对的选择可能会改变。然而，对于一个凸四边形，等值线的线性近似通常穿过两条边，导致 $|Z_\\ell| = 2$。在这种常见且稳定的情况下，线段端点的选择是唯一的，因此其变换也是唯一的。即使有更多的交点，相交测试本身基于方向谓词（共线性和转向），这些谓词在仿射变换下是保持不变的。如果两条线段相交，它们的变换版本也必将相交。\n\n因此，整个分类逻辑建立在仿射不变操作之上，是稳健的，并且对于任意形状的单元（包括具有高纵横比或扭曲的单元）都能产生一致的结果。", "answer": "```python\nimport numpy as np\n\n# Geometric helper functions with a tolerance for floating-point comparisons\n_GEOM_TOL = 1e-9\n\ndef orientation(p, q, r):\n    \"\"\"\n    Computes the orientation of the ordered triplet (p, q, r).\n    Returns:\n      0 for counter-clockwise\n      0 for clockwise\n     = 0 for collinear\n    \"\"\"\n    val = (q[1] - p[1]) * (r[0] - q[0]) - \\\n          (q[0] - p[0]) * (r[1] - q[1])\n    if abs(val)  _GEOM_TOL:\n        return 0\n    return 1 if val  0 else -1\n\ndef on_segment(p, q, r):\n    \"\"\"Given three collinear points p, q, r, checks if q lies on segment pr.\"\"\"\n    return (q[0] = max(p[0], r[0]) + _GEOM_TOL and q[0] = min(p[0], r[0]) - _GEOM_TOL and\n            q[1] = max(p[1], r[1]) + _GEOM_TOL and q[1] = min(p[1], r[1]) - _GEOM_TOL)\n\ndef segments_intersect(seg1, seg2):\n    \"\"\"Checks if two segments, seg1=(p1, q1) and seg2=(p2, q2), intersect.\"\"\"\n    p1, q1 = seg1\n    p2, q2 = seg2\n\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    # General case: segments cross each other\n    if o1 != 0 and o2 != 0 and o3 != 0 and o4 != 0:\n        if o1 != o2 and o3 != o4:\n            return True\n\n    # Special Cases for collinearity\n    if o1 == 0 and on_segment(p1, p2, q1): return True\n    if o2 == 0 and on_segment(p1, q2, q1): return True\n    if o3 == 0 and on_segment(p2, p1, q2): return True\n    if o4 == 0 and on_segment(p2, q1, q2): return True\n\n    return False\n\ndef classify_element(coords, phi_vals, psi_vals, tau):\n    \"\"\"\n    Classifies an element as standard (0), Heaviside-enriched (1), or tip-enriched (2).\n    \"\"\"\n    coords = np.array(coords, dtype=float)\n    phi_vals = np.array(phi_vals, dtype=float)\n    psi_vals = np.array(psi_vals, dtype=float)\n\n    # Primary Criterion: Check for tip located at a node\n    for i in range(4):\n        if abs(phi_vals[i]) = tau and abs(psi_vals[i]) = tau:\n            return 2  # Tip-enriched\n\n    def find_zeros(ls_vals):\n        points = []\n        # Check nodes for zero value\n        for i in range(4):\n            if abs(ls_vals[i]) = tau:\n                points.append(coords[i])\n        \n        # Check edges for sign change\n        for i in range(4):\n            j = (i + 1) % 4\n            val_i, val_j = ls_vals[i], ls_vals[j]\n            if val_i * val_j  0:\n                # Denominator is non-zero if signs are strictly opposite\n                t = val_i / (val_i - val_j)\n                p_ij = (1.0 - t) * coords[i] + t * coords[j]\n                points.append(p_ij)\n        \n        if not points:\n            return []\n        \n        # Filter for unique points using a distance tolerance\n        unique_points = [points[0]]\n        for p in points[1:]:\n            is_duplicate = any(np.linalg.norm(p - up)  _GEOM_TOL for up in unique_points)\n            if not is_duplicate:\n                unique_points.append(p)\n        return unique_points\n\n    def form_segment(zero_points):\n        if len(zero_points)  2:\n            return None\n        \n        max_dist_sq = -1.0\n        best_pair = (None, None)\n        for i in range(len(zero_points)):\n            for j in range(i + 1, len(zero_points)):\n                p1, p2 = zero_points[i], zero_points[j]\n                dist_sq = np.sum((p1 - p2)**2)\n                if dist_sq  max_dist_sq:\n                    max_dist_sq = dist_sq\n                    best_pair = (p1, p2)\n        return best_pair\n\n    # Find zero crossings for phi and psi\n    phi_zeros = find_zeros(phi_vals)\n    psi_zeros = find_zeros(psi_vals)\n    \n    # Form segments by connecting the two farthest zero-crossing points\n    phi_segment = form_segment(phi_zeros)\n    psi_segment = form_segment(psi_zeros)\n\n    # Tip-Enriched Criterion: Check for segment intersection\n    if phi_segment is not None and psi_segment is not None:\n        if segments_intersect(phi_segment, psi_segment):\n            return 2  # Tip-enriched\n\n    # Heaviside-Enriched Criterion: Check if phi-isocontour crosses the element\n    if phi_segment is not None:\n        return 1  # Heaviside-enriched\n\n    # Otherwise, it's a standard element\n    return 0  # Standard\n\ndef solve():\n    test_cases = [\n        # 1. Heaviside-enriched, \"happy path\"\n        {'coords': [[0,0], [1,0], [1,1], [0,1]], 'phi': [-1, 1, 1, -1], 'psi': [2, 2, 2, 2]},\n        # 2. Tip-enriched, interior intersection\n        {'coords': [[0,0], [1,0], [1,1], [0,1]], 'phi': [-0.5, 0.5, 0.5, -0.5], 'psi': [-0.5, -0.5, 0.5, 0.5]},\n        # 3. Standard, no crack crossing\n        {'coords': [[0,0], [1,0], [1,1], [0,1]], 'phi': [-1, -1, -1, -1], 'psi': [-1, -1, -1, -1]},\n        # 4. Tip-enriched, degenerate tip at a node\n        {'coords': [[0,0], [1,0], [1,1], [0,1]], 'phi': [0, 1, 1, 0], 'psi': [0, 0, 1, 1]},\n        # 5. Heaviside-enriched, anisotropic rectangle\n        {'coords': [[0,0], [10,0], [10,1], [0,1]], 'phi': [-5, 5, 5, -5], 'psi': [1, 1, 1, 1]},\n        # 6. Heaviside-enriched, both isocontours cross but do not intersect within the element\n        {'coords': [[0,0], [1,0], [1,1], [0,1]], 'phi': [-0.5, 0.5, 0.5, -0.5], 'psi': [-0.4, 0.6, 1.6, 0.6]}\n    ]\n    tau = 1e-12\n\n    results = []\n    for case in test_cases:\n        result = classify_element(case['coords'], case['phi'], case['psi'], tau)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2551522"}]}