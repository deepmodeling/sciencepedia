{"hands_on_practices": [{"introduction": "理论知识只有通过实践才能真正内化。本练习将引导你手动构建并求解一个边界元方法（BEM）系统，从而将抽象的积分方程转化为具体的线性代数问题。通过为二维拉普拉斯方程在单位正方形上的一个简单问题从零开始组装一个 $4 \\times 4$ 的矩阵，你将亲身体验 BEM 的核心机制，并深刻理解影响系数矩阵的计算方法。[@problem_id:2374819]", "problem": "考虑单位正方形区域 $\\Omega = (0,1)\\times(0,1)$ 上的二维 ($2$D) 拉普拉斯方程的内边值问题，其边界为 $\\Gamma = \\partial\\Omega$。令 $u$ 表示势，令 $q = \\partial u/\\partial n$ 表示外法向通量。使用拉普拉斯算子的直接边界积分方程，采用二维自由空间格林函数\n$$\nG(\\mathbf{x},\\mathbf{y}) \\;=\\; -\\frac{1}{2\\pi}\\,\\ln|\\mathbf{x}-\\mathbf{y}|\\;,\n$$\n并在光滑边界点 $\\mathbf{x}\\in\\Gamma$ 处采用标准内部约定 $c(\\mathbf{x}) = \\tfrac{1}{2}$。用每边一个直线常强度单元（共四个单元）来离散化边界，并在每个单元的中点进行配置。按如下方式为单元编号：\n- $\\Gamma_{1}: \\{(s,0)\\,|\\,0\\le s\\le 1\\}$，外法向为 $\\mathbf{n}_{1}=(0,-1)$，\n- $\\Gamma_{2}: \\{(1,s)\\,|\\,0\\le s\\le 1\\}$，外法向为 $\\mathbf{n}_{2}=(1,0)$，\n- $\\Gamma_{3}: \\{(s,1)\\,|\\,0\\le s\\le 1\\}$，外法向为 $\\mathbf{n}_{3}=(0,1)$，\n- $\\Gamma_{4}: \\{(0,s)\\,|\\,0\\le s\\le 1\\}$，外法向为 $\\mathbf{n}_{4}=(-1,0)$，\n及配置点\n$$\n\\mathbf{x}_{1}=(\\tfrac{1}{2},0),\\quad \\mathbf{x}_{2}=(1,\\tfrac{1}{2}),\\quad \\mathbf{x}_{3}=(\\tfrac{1}{2},1),\\quad \\mathbf{x}_{4}=(0,\\tfrac{1}{2}).\n$$\n施加狄利克雷数据\n$u=0$ 在 $\\Gamma_{1}\\cup\\Gamma_{4}$ 上，且 $u=1$ 在 $\\Gamma_{2}\\cup\\Gamma_{3}$ 上。\n假设每个单元上的 $u$ 和 $q$ 为分段常数，并在中点进行配置，通过精确计算所需的边界积分，从第一性原理出发组装得到的 $4\\times 4$ 线性系统。然后求解该系统，得到四个未知的单元常数外法向通量 $\\{q_{j}\\}_{j=1}^{4}$。使用以弧度为单位的反三角函数主值，并将您的最终结果精确地（无数值舍入）表示为一个行矩阵 $(q_{1}\\ q_{2}\\ q_{3}\\ q_{4})$。", "solution": "所提出的问题是一个良定的二维拉普拉斯方程边值问题，将使用直接边界元法求解。所有需要的数据，包括几何形状、边界条件和离散格式，均已提供。该问题具有科学依据、内容自洽且客观。因此，该问题被认为是有效的，并将提供解答。\n\n由拉普拉斯方程控制的内部势问题的直接边界积分方程 (BIE) 由下式给出：\n$$c(\\mathbf{x}) u(\\mathbf{x}) + \\int_{\\Gamma} u(\\mathbf{y}) \\frac{\\partial G(\\mathbf{x}, \\mathbf{y})}{\\partial n_y} \\, d\\Gamma_y = \\int_{\\Gamma} q(\\mathbf{y}) G(\\mathbf{x}, \\mathbf{y}) \\, d\\Gamma_y$$\n其中 $\\mathbf{x}$ 是边界 $\\Gamma$ 上的一个点，$c(\\mathbf{x})$ 是立体系数，$u$ 是势，$q = \\partial u/\\partial n$ 是法向通量，$G(\\mathbf{x},\\mathbf{y})$ 是自由空间格林函数。对于这个问题，$G(\\mathbf{x},\\mathbf{y}) = -\\frac{1}{2\\pi}\\ln|\\mathbf{x}-\\mathbf{y}|$。格林函数的法向导数为 $\\frac{\\partial G}{\\partial n_y} = \\nabla_y G \\cdot \\mathbf{n}_y = -\\frac{1}{2\\pi} \\frac{(\\mathbf{y}-\\mathbf{x})\\cdot\\mathbf{n}_y}{|\\mathbf{y}-\\mathbf{x}|^2}$。\n\n边界 $\\Gamma$ 被离散为四个常强度单元 $\\Gamma_j$，$j=1,2,3,4$。假设在每个单元 $\\Gamma_j$ 上，势 $u$ 和通量 $q$ 是分段常数，分别为 $u_j$ 和 $q_j$。将 BIE 应用于每个单元 $\\Gamma_i$ 的中点 $\\mathbf{x}_i$，可以得到一个线性代数方程组。由于配置点位于直线段的中点，它们是边界上的光滑点，因此对所有 $i$ 都有 $c(\\mathbf{x}_i) = 1/2$。离散化的 BIE 为：\n$$\\frac{1}{2} u_i + \\sum_{j=1}^{4} u_j \\left( \\int_{\\Gamma_j} \\frac{\\partial G(\\mathbf{x}_i, \\mathbf{y})}{\\partial n_y} \\, d\\Gamma_y \\right) = \\sum_{j=1}^{4} q_j \\left( \\int_{\\Gamma_j} G(\\mathbf{x}_i, \\mathbf{y}) \\, d\\Gamma_y \\right)$$\n这可以写成矩阵形式 $(\\mathbf{H} + \\frac{1}{2}\\mathbf{I})\\mathbf{u} = \\mathbf{G}\\mathbf{q}$，其中矩阵元素由下式给出：\n$$H_{ij} = \\int_{\\Gamma_j} \\frac{\\partial G(\\mathbf{x}_i, \\mathbf{y})}{\\partial n_y} \\, d\\Gamma_y \\quad \\text{和} \\quad G_{ij} = \\int_{\\Gamma_j} G(\\mathbf{x}_i, \\mathbf{y}) \\, d\\Gamma_y$$\n已知量是每个单元上的势，由狄利克雷边界条件给出：$u_1 = 0$，$u_2 = 1$，$u_3 = 1$，$u_4 = 0$。势向量为 $\\mathbf{u} = (0, 1, 1, 0)^T$。未知量是通量 $\\mathbf{q} = (q_1, q_2, q_3, q_4)^T$。\n\n我们现在必须计算矩阵系数 $H_{ij}$ 和 $G_{ij}$。\n由于正方形几何形状和配置点的选择，矩阵 $\\mathbf{H}$ 和 $\\mathbf{G}$ 将呈现出对称结构。我们将有对角元素 ($i=j$)、相邻元素 (例如 $i=1, j=2$) 和相对元素 ($i=1, j=3$)。\n\n计算 $H_{ij}$：\n对于直线单元，当 $i=j$ 时，向量 $\\mathbf{y}-\\mathbf{x}_i$ 与单元 $\\Gamma_i$ 相切。法向量 $\\mathbf{n}_i$ 与单元正交。因此，$(\\mathbf{y}-\\mathbf{x}_i) \\cdot \\mathbf{n}_i = 0$，这意味着对所有 $i=1,2,3,4$ 都有 $H_{ii} = 0$。\n对于非对角元素，我们计算积分。让我们计算第一行（$i=1$，$\\mathbf{x}_1 = (1/2, 0)$）。\n$H_{12}$：在 $\\Gamma_2$ 上积分，其中 $\\mathbf{y}=(1,s)$，对于 $s\\in[0,1]$ 且 $\\mathbf{n}_2=(1,0)$。\n$H_{12} = -\\frac{1}{2\\pi} \\int_0^1 \\frac{((1,s)-(1/2,0))\\cdot(1,0)}{|(1,s)-(1/2,0)|^2} ds = -\\frac{1}{2\\pi} \\int_0^1 \\frac{1/2}{(1/2)^2+s^2} ds = -\\frac{1}{4\\pi} \\left[2\\arctan(2s)\\right]_0^1 = -\\frac{\\arctan(2)}{2\\pi}$。\n$H_{14}$：在 $\\Gamma_4$ 上积分，其中 $\\mathbf{y}=(0,s)$，对于 $s\\in[0,1]$ 且 $\\mathbf{n}_4=(-1,0)$。\n$H_{14} = -\\frac{1}{2\\pi} \\int_0^1 \\frac{((0,s)-(1/2,0))\\cdot(-1,0)}{|(0,s)-(1/2,0)|^2} ds = -\\frac{1}{2\\pi} \\int_0^1 \\frac{1/2}{(-1/2)^2+s^2} ds = H_{12} = -\\frac{\\arctan(2)}{2\\pi}$。\n$H_{13}$：在 $\\Gamma_3$ 上积分，其中 $\\mathbf{y}=(s,1)$，对于 $s\\in[0,1]$ 且 $\\mathbf{n}_3=(0,1)$。\n$H_{13} = -\\frac{1}{2\\pi} \\int_0^1 \\frac{((s,1)-(1/2,0))\\cdot(0,1)}{|(s,1)-(1/2,0)|^2} ds = -\\frac{1}{2\\pi} \\int_0^1 \\frac{1}{(s-1/2)^2+1^2} ds = -\\frac{1}{2\\pi} \\left[\\arctan(s-1/2)\\right]_0^1 = -\\frac{1}{2\\pi}(\\arctan(1/2)-\\arctan(-1/2)) = -\\frac{\\arctan(1/2)}{\\pi}$。\n根据对称性，令 $h_a = H_{12} = H_{14} = H_{21} = \\dots = -\\frac{\\arctan(2)}{2\\pi}$ 且 $h_o = H_{13} = H_{31} = \\dots = -\\frac{\\arctan(1/2)}{\\pi}$。\n矩阵 $\\mathbf{H}$ 为：\n$$\n\\mathbf{H} = \\begin{pmatrix} 0 & h_a & h_o & h_a \\\\ h_a & 0 & h_a & h_o \\\\ h_o & h_a & 0 & h_a \\\\ h_a & h_o & h_a & 0 \\end{pmatrix}\n$$\n注意，每一行的和为 $2h_a+h_o = -\\frac{\\arctan(2)}{\\pi} - \\frac{\\arctan(1/2)}{\\pi} = -\\frac{1}{\\pi}(\\arctan(2)+\\arctan(1/2)) = -\\frac{1}{\\pi}(\\frac{\\pi}{2}) = -1/2$，这满足求和规则 $\\sum_j H_{ij} = -c(\\mathbf{x}_i)$。\n\n计算 $G_{ij}$：\n我们使用通用积分公式：$\\int \\ln(t^2+c^2)dt = t\\ln(t^2+c^2) - 2t + 2c\\arctan(t/c)$。\n$G_{11}$：在 $\\Gamma_1$ 上积分，其中 $\\mathbf{y}=(s,0)$，对于 $s\\in[0,1]$。\n$G_{11} = -\\frac{1}{2\\pi}\\int_0^1 \\ln|s-1/2| ds = -\\frac{1}{2\\pi} (2 \\int_0^{1/2} \\ln(t) dt) = -\\frac{1}{\\pi}[t\\ln t - t]_0^{1/2} = -\\frac{1}{\\pi}(\\frac{1}{2}\\ln(1/2)-\\frac{1}{2}) = \\frac{1+\\ln 2}{2\\pi}$。\n$G_{12}$：在 $\\Gamma_2$ 上积分，$\\mathbf{y}=(1,s)$，$s\\in[0,1]$。\n$G_{12} = -\\frac{1}{2\\pi} \\int_0^1 \\ln\\sqrt{(1/2)^2+s^2} ds = -\\frac{1}{4\\pi}\\int_0^1 \\ln(s^2+(1/2)^2) ds = -\\frac{1}{4\\pi}[s\\ln(s^2+1/4)-2s+\\arctan(2s)]_0^1 = -\\frac{1}{4\\pi}(\\ln(5/4)-2+\\arctan(2)) = \\frac{2-\\ln(5/4)-\\arctan(2)}{4\\pi}$。\n$G_{13}$：在 $\\Gamma_3$ 上积分，$\\mathbf{y}=(s,1)$，$s\\in[0,1]$。\n$G_{13} = -\\frac{1}{2\\pi} \\int_0^1 \\ln\\sqrt{(s-1/2)^2+1^2} ds = -\\frac{1}{4\\pi}\\int_{-1/2}^{1/2} \\ln(t^2+1) dt = -\\frac{2}{4\\pi}\\int_0^{1/2} \\ln(t^2+1) dt = -\\frac{1}{2\\pi}[t\\ln(t^2+1)-2t+2\\arctan(t)]_0^{1/2} = -\\frac{1}{2\\pi}(\\frac{1}{2}\\ln(5/4)-1+2\\arctan(1/2)) = \\frac{1-\\frac{1}{2}\\ln(5/4)-2\\arctan(1/2)}{2\\pi}$。\n根据对称性，令 $g_d = G_{11} = G_{22} = \\dots = \\frac{1+\\ln 2}{2\\pi}$，$g_a = G_{12} = G_{14} = \\dots = \\frac{2-\\ln(5/4)-\\arctan(2)}{4\\pi}$，且 $g_o = G_{13} = G_{31} = \\dots = \\frac{2-\\ln(5/4)-4\\arctan(1/2)}{4\\pi}$。\n矩阵 $\\mathbf{G}$ 为：\n$$\n\\mathbf{G} = \\begin{pmatrix} g_d & g_a & g_o & g_a \\\\ g_a & g_d & g_a & g_o \\\\ g_o & g_a & g_d & g_a \\\\ g_a & g_o & g_a & g_d \\end{pmatrix}\n$$\n\n现在我们组装并求解系统 $\\mathbf{G}\\mathbf{q}=\\mathbf{v}$，其中 $\\mathbf{v} = (\\mathbf{H} + \\frac{1}{2}\\mathbf{I})\\mathbf{u}$。\n当 $\\mathbf{u}=(0,1,1,0)^T$ 时：\n$v_1 = \\frac{1}{2}u_1 + H_{12}u_2 + H_{13}u_3 + H_{14}u_4 = h_a(1) + h_o(1) = h_a+h_o$。\n$v_2 = H_{21}u_1 + \\frac{1}{2}u_2 + H_{23}u_3 + H_{24}u_4 = \\frac{1}{2}(1) + h_a(1) = 1/2+h_a$。\n$v_3 = H_{31}u_1 + H_{32}u_2 + \\frac{1}{2}u_3 + H_{34}u_4 = h_a(1) + \\frac{1}{2}(1) = 1/2+h_a$。\n$v_4 = H_{41}u_1 + H_{42}u_2 + H_{43}u_3 + \\frac{1}{2}u_4 = h_o(1) + h_a(1) = h_a+h_o$。\n所以，$\\mathbf{v} = (h_a+h_o, 1/2+h_a, 1/2+h_a, h_a+h_o)^T$。\n\n该问题关于直线 $y=x$ 具有轴对称性。边界条件保持了这种对称性。因此，通量的解也必须是对称的：$q_1=q_4$ 且 $q_2=q_3$。令 $q_1=q_4=A$ 且 $q_2=q_3=B$。这个 $4 \\times 4$ 系统可简化为一个 $2 \\times 2$ 系统：\n$$\n\\begin{align*} (g_d+g_a)A + (g_a+g_o)B &= h_a+h_o \\\\ (g_a+g_o)A + (g_d+g_a)B &= 1/2+h_a \\end{align*}\n$$\n两方程相减得到：\n$((g_d+g_a)-(g_a+g_o))A + ((g_a+g_o)-(g_d+g_a))B = (h_a+h_o)-(1/2+h_a)$\n$(g_d-g_o)A - (g_d-g_o)B = h_o-1/2$\n$(g_d-g_o)(A-B) = h_o-1/2$。\n两方程相加得到：\n$((g_d+g_a)+(g_a+g_o))(A+B) = (h_a+h_o) + (1/2+h_a)$\n$(g_d+2g_a+g_o)(A+B) = 1/2+2h_a+h_o$。\n由于 $2h_a+h_o = -1/2$，右侧为 $0$。和 $g_d+2g_a+g_o$ 是非零的，因此我们必须有 $A+B=0$，即 $B=-A$。这与无源区域的总通量为零的物理要求是一致的：$\\sum q_j L_j = q_1(1)+q_2(1)+q_3(1)+q_4(1) = A+B+B+A = 2(A+B)=0$。\n将 $B=-A$ 代入 $2 \\times 2$ 系统的第一个方程：\n$(g_d+g_a)A - (g_a+g_o)A = h_a+h_o$\n$(g_d-g_o)A = h_a+h_o \\implies A = \\frac{h_a+h_o}{g_d-g_o}$。\n我们计算分子和分母。\n$h_a+h_o = -\\frac{\\arctan(2)}{2\\pi} - \\frac{\\arctan(1/2)}{\\pi} = -\\frac{1}{2\\pi}(\\arctan(2)+2\\arctan(1/2))$。使用恒等式 $\\arctan(2)+\\arctan(1/2)=\\pi/2$，所以 $\\arctan(2)=\\pi/2-\\arctan(1/2)$，我们得到：\n$h_a+h_o = -\\frac{1}{2\\pi}(\\pi/2 - \\arctan(1/2) + 2\\arctan(1/2)) = -\\frac{1}{2\\pi}(\\frac{\\pi}{2}+\\arctan(1/2))$。\n对于分母：\n$g_d=\\frac{1+\\ln 2}{2\\pi}$ 且 $g_o=\\frac{2-\\ln(5/4)-4\\arctan(1/2)}{4\\pi}=\\frac{1-\\frac{1}{2}(\\ln 5 - 2\\ln 2)-2\\arctan(1/2)}{2\\pi}$。\n$g_d-g_o = \\frac{1}{2\\pi}[(1+\\ln 2) - (1-\\frac{1}{2}\\ln 5 + \\ln 2-2\\arctan(1/2))] = \\frac{1}{2\\pi}(\\frac{1}{2}\\ln 5 + 2\\arctan(1/2))$。\n因此，\n$A = \\frac{-\\frac{1}{2\\pi}(\\frac{\\pi}{2}+\\arctan(1/2))}{\\frac{1}{2\\pi}(\\frac{1}{2}\\ln 5+2\\arctan(1/2))} = -\\frac{\\frac{\\pi}{2}+\\arctan(1/2)}{\\frac{1}{2}\\ln 5+2\\arctan(1/2)}$。\n于是通量为：\n$q_1=q_4=A = -\\frac{\\pi/2+\\arctan(1/2)}{1/2\\ln 5+2\\arctan(1/2)}$\n$q_2=q_3=B=-A = \\frac{\\pi/2+\\arctan(1/2)}{1/2\\ln 5+2\\arctan(1/2)}$。\n\n最终结果是行矩阵 $(q_1 \\ q_2 \\ q_3 \\ q_4)$。\n令常数 $C = \\frac{\\frac{\\pi}{2}+\\arctan(\\frac{1}{2})}{\\frac{1}{2}\\ln 5+2\\arctan(\\frac{1}{2})} = \\frac{\\pi+2\\arctan(\\frac{1}{2})}{\\ln 5+4\\arctan(\\frac{1}{2})}$。\n则 $q_1 = -C$，$q_2 = C$，$q_3 = C$，$q_4 = -C$。\n最终答案如下所示。", "answer": "$$ \\boxed{ \\begin{pmatrix} -\\frac{\\pi+2\\arctan(\\frac{1}{2})}{\\ln 5+4\\arctan(\\frac{1}{2})} & \\frac{\\pi+2\\arctan(\\frac{1}{2})}{\\ln 5+4\\arctan(\\frac{1}{2})} & \\frac{\\pi+2\\arctan(\\frac{1}{2})}{\\ln 5+4\\arctan(\\frac{1}{2})} & -\\frac{\\pi+2\\arctan(\\frac{1}{2})}{\\ln 5+4\\arctan(\\frac{1}{2})} \\end{pmatrix} } $$", "id": "2374819"}, {"introduction": "直接边界元方法的一个主要挑战是其计算复杂度。随着问题规模（即边界单元数量 $N$）的增大，稠密的系统矩阵会导致计算成本以 $O(N^2)$ 的速度增长。本练习将通过一个思想实验，让你分析快速多极子方法（FMM）的计算复杂度，从而揭示其为何能成为一种强大的加速工具。通过剖析 FMM 各个阶段的计算工作量，你将从理论上证明其如何将复杂度降低到近线性的 $O(N)$，为学习 FMM 的具体实现提供坚实的理论依据。[@problem_id:2374839]", "problem": "考虑在二维空间域中，为求解拉普拉斯方程(Laplace equation)的边界元方法(Boundary Element Method, BEM)所产生的单层势(single-layer potential)的求值问题。所有源点位于线段 $\\{(x,0): 0 \\le x \\le 1\\}$ 上，所有目标点位于与之平行的线段 $\\{(x,d): 0 \\le x \\le 1\\}$ 上，其中 $d>0$ 为一固定值。源点和目标点各有 $N$ 个，且均在各自的线段上均匀分布。其核函数为二维空间中拉普拉斯方程的自由空间格林函数(Green's function)，$G(\\mathbf{r}) = -\\frac{1}{2\\pi}\\ln|\\mathbf{r}|$。\n\n假设在 $N$ 个目标点上的势计算通过快速多极子方法(Fast Multipole Method, FMM)进行加速。FMM对每条线段使用二分支（分支因子为$2$）的层次化剖分，将其划分为多个“盒子”，直至叶节点盒子最多包含 $n_{0}$ 个点，其中 $n_{0}$ 是固定的且与 $N$ 无关。多极展开和局部展开在阶数 $p$ 处截断，该 $p$ 值的选取是为了满足预设的精度 $\\varepsilon$，由于 $d$ 是固定的，所以 $p$ 与 $N$ 无关。假设分离距离 $d$ 严格大于最大叶节点盒子的宽度，因此源点和目标点之间不进行直接的粒子间近场求值；所有相互作用都通过展开式来介导。对于成本模型，我们做如下假设：\n- 一个叶节点盒子中，单个源点的源点到多极展开（S2M）操作成本为 $c_{\\mathrm{S2M}}\\,p$。\n- 一个盒子的多极到多极（M2M）转换操作成本为 $c_{\\mathrm{M2M}}\\,p^{2}$。\n- 一对分离良好的源-目标盒子对的多极到局部（M2L）转换操作成本为 $c_{\\mathrm{M2L}}\\,p^{2}$。\n- 一个盒子的局部到局部（L2L）转换操作成本为 $c_{\\mathrm{L2L}}\\,p^{2}$。\n- 单个目标点的局部到目标点（L2T）求值操作成本为 $c_{\\mathrm{L2T}}\\,p$。\n\n假设存在一个与层级无关的常数 $q$，使得在层次结构的任何层级上，任何目标盒子的远场相互作用列表（well-separated interaction list）最多包含 $q$ 个源盒子。所有常数 $c_{\\mathrm{S2M}}$, $c_{\\mathrm{M2M}}$, $c_{\\mathrm{M2L}}$, $c_{\\mathrm{L2L}}$, $c_{\\mathrm{L2T}}$, $n_{0}$, $p$, $q$ 和 $d$ 均为正数且与 $N$ 无关。\n\n当 $N \\to \\infty$ 时，令 $T(N)$ 表示此模型下FMM的总算术功。确定指数 $\\alpha$ 使得 $T(N) = \\Theta(N^{\\alpha})$。请提供 $\\alpha$ 的实数值，无需四舍五入。", "solution": "用户提供了一个关于快速多极子方法（FMM）计算复杂性的问题，该方法应用于一个嵌入在二维空间中的特定一维粒子分布。我必须首先验证该问题陈述，如果有效，则提供一个严谨的解答推导过程。\n\n### 步骤1：提取已知条件\n- **系统**：$N$个源点和$N$个目标点。\n- **源域**：线段 $\\{(x,0): 0 \\le x \\le 1\\}$，均匀分布。\n- **目标域**：线段 $\\{(x,d): 0 \\le x \\le 1\\}$，均匀分布，其中$d>0$。\n- **相互作用核**：$G(\\mathbf{r}) = -\\frac{1}{2\\pi}\\ln|\\mathbf{r}|$，即二维拉普拉斯算子(Laplacian)的格林函数。\n- **FMM层次结构**：一维线段的二分支剖分（分支因子为$2$）。\n- **叶节点盒子准则**：每个叶节点盒子最多包含$n_{0}$个点，其中$n_{0}$为常数。\n- **展开阶数**：常数整数$p$，与$N$无关。\n- **相互作用条件**：无直接近场相互作用；所有相互作用均通过展开式处理。\n- **相互作用列表**：任何层级的任何目标盒子最多与$q$个源盒子发生相互作用，其中$q$为常数。\n- **成本模型**：\n    - S2M（每个源点）：$c_{\\mathrm{S2M}}\\,p$\n    - M2M（每个盒子）：$c_{\\mathrm{M2M}}\\,p^{2}$\n    - M2L（每对分离良好的盒子）：$c_{\\mathrm{M2L}}\\,p^{2}$\n    - L2L（每个盒子）：$c_{\\mathrm{L2L}}\\,p^{2}$\n    - L2T（每个目标点）：$c_{\\mathrm{L2T}}\\,p$\n- **常数**：$c_{\\mathrm{S2M}}$, $c_{\\mathrm{M2M}}$, $c_{\\mathrm{M2L}}$, $c_{\\mathrm{L2L}}$, $c_{\\mathrm{L2T}}$, $n_{0}$, $p$, $q$, $d$ 均为与$N$无关的正数常数。\n- **目标**：在$N \\to \\infty$时，确定总计算成本标度律$T(N) = \\Theta(N^{\\alpha})$中的指数$\\alpha$。\n\n### 步骤2：使用提取的已知条件进行验证\n根据验证标准对问题陈述进行评估。\n1.  **科学依据**：该问题是关于FMM的标准理论分析，FMM是计算工程和物理学中的一个基石算法。其成本模型与关于二维FMM的既有文献一致。该问题是合理的。\n2.  **适定性**：问题定义清晰。它提供了一个完整的成本模型，并要求一个具体、可计算的量（标度指数$\\alpha$）。预期会有一个唯一解。\n3.  **客观性**：问题使用科学计算领域常见的精确、形式化语言陈述，没有主观性。\n\n该问题没有表现出任何已定义的缺陷。它不是科学上不合理、不可形式化、不完整、矛盾、不现实或不适定的。这是一个计算复杂性理论中有效且结构良好的问题。\n\n### 步骤3：结论与行动\n该问题被判定为**有效**。将提供完整解答。\n\n### 解答推导\n总算术功$T(N)$是FMM算法五个阶段的成本之和。我们将分析每个阶段的成本作为$N$的函数。\n\n首先，我们必须描述层次树结构。源点和目标点分布在长度为$1$的线段上。点密度为$\\rho = N/1 = N$。该域被二分剖分，意味着每个盒子被分裂成$2$个子盒子。树的第$l$层有$2^l$个盒子。当一个盒子中的点数约为$n_{0}$时，树的递归在叶子层$L$停止。第$l$层的盒子长度为$2^{-l}$。第$L$层盒子中的点数为$\\rho \\cdot 2^{-L} = N \\cdot 2^{-L}$。叶节点条件是$N \\cdot 2^{-L} \\lesssim n_{0}$，这意味着$2^L \\gtrsim N/n_{0}$。因此，树的深度为$L = \\Theta(\\log N)$。\n\n树中盒子的总数是所有层级（从$l=0$到$l=L$）的盒子数量之和：\n$$\n\\text{Total boxes} = \\sum_{l=0}^{L} 2^l = 2^{L+1} - 1 = \\Theta(2^L)\n$$\n由于$2^L = \\Theta(N)$，树中盒子的总数是$\\Theta(N)$。\n\n现在，我们分析FMM每个阶段的成本：\n\n1.  **S2M（源点到多极展开）成本**：对$N$个源点中的每一个执行此操作，以在叶节点盒子中形成多极展开。\n    - 每个源点的成本为 $c_{\\mathrm{S2M}}\\,p$。\n    - S2M总成本：$T_{\\mathrm{S2M}} = N \\cdot (c_{\\mathrm{S2M}}\\,p)$。\n    - 由于$c_{\\mathrm{S2M}}$和$p$是常数，所以$T_{\\mathrm{S2M}} = \\Theta(N)$。\n\n2.  **M2M（多极到多极）成本**：这构成了FMM的上行遍历。在从$L-1$到$0$的每个层级$l$，每个父盒子的多极展开由其子盒子的展开计算得出。此操作对每个非叶节点盒子执行一次。\n    - 非叶节点盒子的数量为$\\sum_{l=0}^{L-1} 2^l = 2^L-1 = \\Theta(N)$。\n    - 每次M2M转换的成本为$c_{\\mathrm{M2M}}\\,p^2$。\n    - M2M总成本：$T_{\\mathrm{M2M}} = \\Theta(N) \\cdot (c_{\\mathrm{M2M}}\\,p^2) = \\Theta(N)$。\n\n3.  **M2L（多极到局部）成本**：这是将分离良好的源盒子的多极展开转换为目标盒子的局部展开。这发生在树的每个层级。\n    - 在任何层级$l$，有$2^l$个目标盒子。\n    - 问题陈述指出，任何目标盒子的相互作用列表最多包含$q$个源盒子，其中$q$是常数。\n    - 因此，在层级$l$的M2L转换次数最多为$q \\cdot 2^l$。\n    - 每次M2L转换的成本为$c_{\\mathrm{M2L}}\\,p^2$。\n    - M2L总成本是所有层级$l=0, \\dots, L$的总和：\n      $$\n      T_{\\mathrm{M2L}} = \\sum_{l=0}^{L} (\\text{Num. target boxes at level }l) \\cdot (\\text{Avg. interaction list size}) \\cdot (\\text{Cost per translation})\n      $$\n      $$\n      T_{\\mathrm{M2L}} \\leq \\sum_{l=0}^{L} (2^l \\cdot q \\cdot c_{\\mathrm{M2L}}\\,p^2) = (q \\cdot c_{\\mathrm{M2L}}\\,p^2) \\sum_{l=0}^{L} 2^l = (q \\cdot c_{\\mathrm{M2L}}\\,p^2) (2^{L+1}-1)\n      $$\n    - 由于$p$, $q$和$c_{\\mathrm{M2L}}$是常数，且$2^L = \\Theta(N)$，所以M2L总成本是$T_{\\mathrm{M2L}} = \\Theta(N)$。\n\n4.  **L2L（局部到局部）成本**：这构成了下行遍历。在从$1$到$L$的每个层级$l$，每个盒子的局部展开由其父盒子的局部展开计算得出。此操作对每个非根节点盒子执行。\n    - 非根节点盒子的数量为$\\sum_{l=1}^{L} 2^l = 2^{L+1}-2 = \\Theta(N)$。\n    - 每次L2L转换的成本为$c_{\\mathrm{L2L}}\\,p^2$。\n    - L2L总成本：$T_{\\mathrm{L2L}} = \\Theta(N) \\cdot (c_{\\mathrm{L2L}}\\,p^2) = \\Theta(N)$。\n\n5.  **L2T（局部到目标点）成本**：这最后一步操作是在$N$个目标点位置中的每一个上评估局部展开。这发生在叶节点盒子中。\n    - 每个目标点的成本为$c_{\\mathrm{L2T}}\\,p$。\n    - L2T总成本：$T_{\\mathrm{L2T}} = N \\cdot (c_{\\mathrm{L2T}}\\,p)$。\n    - 由于$c_{\\mathrm{L2T}}$和$p$是常数，所以$T_{\\mathrm{L2T}} = \\Theta(N)$。\n\n总算术功$T(N)$是这五个阶段的成本之和：\n$$\nT(N) = T_{\\mathrm{S2M}} + T_{\\mathrm{M2M}} + T_{\\mathrm{M2L}} + T_{\\mathrm{L2L}} + T_{\\mathrm{L2T}}\n$$\n$$\nT(N) = \\Theta(N) + \\Theta(N) + \\Theta(N) + \\Theta(N) + \\Theta(N) = \\Theta(N)\n$$\n问题指明，总功的标度为$T(N) = \\Theta(N^{\\alpha})$。将此与我们推导出的结果进行比较，我们得到：\n$$\n\\Theta(N^{\\alpha}) = \\Theta(N^1)\n$$\n这意味着指数$\\alpha$必须为$1$。", "answer": "$$\\boxed{1}$$", "id": "2374839"}, {"introduction": "在理解了 FMM 为何高效之后，是时候亲手构建一个了。这个编程练习将指导你实现一个简化的一维快速多极子方法，以加速对数势的求和。你将把 FMM 的关键概念——例如分层树结构、多极矩和局部展开——转化为实际的代码，并处理远场近似与近场直接计算的切换。这个实践是检验和巩固 FMM 理论知识的最终试金石。[@problem_id:2374805]", "problem": "实现一个完整的程序，该程序针对直线上若干指定的带标量源强度的点集，使用一种基于对数核的 Taylor 级数的分层展开方案，近似计算这些源在源自身位置处产生的对数势，并将其结果与直接求和法进行比较。令目标点索引 $i$ 处的势定义为\n$$\nS_i = \\sum_{\\substack{j=1 \\\\ j \\ne i}}^{N} q_j \\,\\log\\!\\left|x_i - x_j\\right|,\n$$\n其中 $N$ 是源的数量，$x_j \\in \\mathbb{R}$ 是实线上的源位置，$q_j \\in \\mathbb{R}$ 是源强度。\n\n您的程序必须计算一个近似值 $S^{(\\mathrm{approx})}_i$。为此，您需要使用一种方法，将包围区间分层划分为一个二叉树（其盒子具有中心 $c$ 和半长 $a$），并将核 $\\log|x - x'|$ 关于盒子中心的 Taylor 级数截断至 $p$ 阶。对于一个中心为 $c$ 且与位置 $x$ 处的目标点良好分离的盒子，您必须使用基于 $\\log|x - x'|$ 的 Taylor 展开的截断多极展开：\n$$\n\\log|x - x'| = \\log|x - c| + \\log\\!\\left(1 - \\frac{x' - c}{x - c}\\right),\n$$\n当 $\\left|x' - c\\right| < \\left|x - c\\right|$ 时，可得：\n$$\n\\log|x - x'| = \\log|x - c| - \\sum_{n=1}^{\\infty} \\frac{1}{n}\\,\\frac{(x' - c)^n}{(x - c)^n}.\n$$\n通过定义盒子矩，将级数截断至 $p$ 阶\n$$\nM_n = \\sum_{j \\in \\text{box}} q_j (x_j - c)^n,\\quad n=0,1,\\dots,p,\n$$\n因此，该盒子对位置 $x$ 处目标点的贡献可近似为\n$$\n\\Phi_{\\text{box}}(x) \\approx M_0 \\,\\log|x - c| - \\sum_{n=1}^{p} \\frac{1}{n}\\,\\frac{M_n}{(x - c)^n}.\n$$\n\n为根据子盒子的矩构建父盒子的矩，使用二项式平移恒等式，将关于父盒子中心 $c_{\\text{par}}$ 的矩用关于子盒子中心 $c_{\\text{ch}}$ 的矩重新表示：\n$$\nM_n^{(\\text{par})} = \\sum_{k=0}^{n} \\binom{n}{k} \\,(c_{\\text{ch}} - c_{\\text{par}})^{\\,n-k}\\, M_k^{(\\text{ch})},\\quad n=0,1,\\dots,p.\n$$\n\n将良好分离接受准则定义如下：对于一个中心为 $c$、半长为 $a$ 的盒子，如果满足以下条件，则位置 $x$ 处的目标点与该盒子是良好分离的\n$$\n|x - c| \\ge \\lambda\\, a,\n$$\n其中 $\\lambda = 2$。如果满足该准则，则使用上述截断展开式来近似计算盒子中所有源对该目标点的贡献。如果不满足该准则且该盒子不是叶节点，则细化至其子节点。如果不满足该准则且该盒子是叶节点，则直接计算该叶节点中所有源的贡献，当 $x$ 与叶节点中的某个源位置重合时，需排除自相互作用。使用最大树深度 $D = 20$ 和叶节点容量 $L = 8$ 作为细化的停止准则。\n\n在所有近似计算中，使用展开阶数 $p = 12$。对于每个测试用例，计算：\n- 根据定义为所有 $i = 1,\\dots,N$ 计算的直接结果 $S^{(\\mathrm{direct})}_i$。\n- 使用上文定义的分层截断展开计算的近似结果 $S^{(\\mathrm{approx})}_i$。\n- 最大绝对误差\n$$\nE = \\max_{1 \\le i \\le N} \\left| S^{(\\mathrm{approx})}_i - S^{(\\mathrm{direct})}_i \\right|.\n$$\n\n您的程序必须对以下测试套件执行上述计算（每个项目定义了 $N$、$\\{x_j\\}_{j=1}^N$ 和 $\\{q_j\\}_{j=1}^N$）：\n\n- 测试用例 1（均匀网格，交替电荷）：\n  - $N = 16$,\n  - $x_j = \\dfrac{j-1}{N-1}$ 对于 $j = 1,2,\\dots,N$,\n  - $q_j = (-1)^{\\,j-1}$ 对于 $j = 1,2,\\dots,N$。\n\n- 测试用例 2（两个紧密簇，电荷符号按簇交替）：\n  - $N = 20$,\n  - $x_j$ 由 $\\left\\{10^{-3}\\, j\\right\\}_{j=1}^{10}$ 和 $\\left\\{1 - 10^{-3}\\, j\\right\\}_{j=1}^{10}$ 拼接组成，\n  - $q_j$ 由 $\\left\\{\\dfrac{1}{j}\\right\\}_{j=1}^{10}$ 和 $\\left\\{-\\dfrac{1}{j}\\right\\}_{j=1}^{10}$ 拼接组成，顺序与位置相同。\n\n- 测试用例 3（单源，平凡边界情况）：\n  - $N = 1$,\n  - $x_1 = \\dfrac{1}{2}$,\n  - $q_1 = 2$。\n\n- 测试用例 4（非均匀二次网格，正弦电荷）：\n  - $N = 32$,\n  - $x_j = \\left(\\dfrac{j-1}{N-1}\\right)^{2}$ 对于 $j = 1,2,\\dots,N$,\n  - $q_j = \\sin\\!\\left(\\dfrac{2\\pi (j-1)}{N}\\right)$ 对于 $j = 1,2,\\dots,N$。\n\n您的程序必须输出一行，其中包含一个 Python 风格的列表，该列表含有 4 个误差值 $E$（每个测试用例一个），每个值均使用标准四舍五入规则保留 8 位小数。列表的顺序必须与上述测试用例的顺序相匹配。例如，一个包含四个占位符值的输出将如下所示：“[0.00000000,0.12345678,0.00000000,0.00000123]”。", "solution": "所提出的问题是实现并验证一个用于计算对数势的一维分层快速多极类方法。这是计算科学中的一个标准问题，旨在将 N 体问题的计算复杂度从直接求和法的朴素 $O(N^2)$ 标度降低到大约 $O(N)$。问题陈述在科学上是合理的，在数学上是一致的，并提供了所有必要的参数和公式。因此，该问题被认为是有效的。\n\n该方法的核心原理是对问题域进行分层分解，并使用级数展开来近似遥远源集群的影响。我们将首先建立理论和算法框架，然后介绍实现。\n\n**1. 空间分层分解**\n\n该方法的基础是一个二叉树结构，它递归地划分包含源的一维域。\n该过程始于一个单一的根“盒子”，它代表一个包围所有 $N$ 个源点 $\\{x_j\\}$ 的区间 $[c-a, c+a]$。此处，$c$ 是区间的中心，$a$ 是其半长。这个根盒子位于树的第 0 层。\n\n如果一个任意层级的盒子包含的点数超过了预设的最大数量 $L$（叶节点容量），并且尚未达到最大树深度 $D$，那么它将被细分为两个等半长的子盒子。对于一个中心为 $c$、半长为 $a$ 的父盒子，其两个子盒子的中心将是 $c - a/2$ 和 $c + a/2$，且两者的半长均为 $a/2$。此细分过程递归地进行，从而生成一个树结构。未被细分的盒子称为“叶”盒子。\n\n**2. 上行遍：多极矩计算**\n\n构建树之后，我们执行一次从叶节点到根节点的“上行遍”，以计算每个盒子的多极矩。多极展开为从远处观察盒子内部的源分布提供了一种紧凑的表示。矩就是这种展开的系数。\n\n对于一个中心为 $c$ 的叶盒子，其 $n=0, 1, \\ldots, p$ 阶的矩 $M_n$ 直接根据该盒子内包含的源点 $\\{x_j\\}$ 及其强度 $\\{q_j\\}$ 计算得出：\n$$\nM_n = \\sum_{j \\in \\text{box}} q_j (x_j - c)^n\n$$\n对于一个非叶（父）盒子，其矩不是直接从源计算的，而是由其子节点已经计算出的矩合成而来。这是通过矩到矩（M2M）平移实现的。如果一个中心为 $c_{\\text{ch}}$ 的子盒子具有矩 $\\{M_k^{(\\text{ch})}\\}$，这些矩可以重新表示为关于其父盒子中心 $c_{\\text{par}}$ 的级数。平移矩的公式由 $(x_j - c_{\\text{par}})^n = ((x_j - c_{\\text{ch}}) + (c_{\\text{ch}} - c_{\\text{par}}))^n$ 的二项式展开推导得出。对子盒子中的所有源求和，得到对父盒子矩的贡献：\n$$\nM_n^{(\\text{par})} = \\sum_{k=0}^{n} \\binom{n}{k} (c_{\\text{ch}} - c_{\\text{par}})^{n-k} M_k^{(\\text{ch})}\n$$\n父盒子的总矩是其两个子盒子平移后的矩之和。此过程从叶节点向上递归应用，确保树中的每个盒子都有一套完整的多极矩 $\\{M_n\\}_{n=0}^p$。\n\n**3. 下行遍：势评估**\n\n每个目标位置 $x_i$ 处的势 $S_i$ 是通过一次从根节点开始遍历树的“下行遍”来计算的。对于给定的目标点 $x_i$，算法在每个节点上决定是使用多极近似来计算该盒子的贡献，还是通过下降到其子节点来细化计算。\n\n该决策由一个良好分离准则控制。如果一个中心为 $c$、半长为 $a$ 的盒子到目标点 $x_i$ 中心的距离与其尺寸相比足够大，则认为该盒子与目标点是良好分离的（即，在“远场”中）：\n$$\n|x_i - c| \\ge \\lambda a\n$$\n其中 $\\lambda$ 是分离参数，给定为 $\\lambda=2$。\n\n对单个目标点 $x_i$ 的评估过程如下，从根盒子开始：\n1.  **远场相互作用**：如果当前盒子与 $x_i$ 良好分离，则其对 $x_i$ 处势的贡献将使用 $p$ 阶截断多极展开进行近似。该公式由对数核 $\\log|x_i - x'|$ 在盒子中心 $c$ 附近的 Taylor 级数推导得出。其贡献为：\n    $$\n    \\Phi_{\\text{box}}(x_i) \\approx M_0 \\log|x_i - c| - \\sum_{n=1}^{p} \\frac{1}{n} \\frac{M_n}{(x_i - c)^n}\n    $$\n    这是一个多极到点（M2P）的计算。沿该树分支的遍历终止。\n\n2.  **近场相互作用**：如果盒子与 $x_i$ 未良好分离，我们必须细化计算。\n    *   如果该盒子不是叶节点，算法会递归地下降到其两个子节点，并将每个子节点的贡献相加。\n    *   如果该盒子是叶节点，多极近似不再准确。该叶节点内源的贡献必须通过直接求和来计算。对于叶节点中的每个源 $x_j$，将其精确贡献 $q_j \\log|x_i - x_j|$ 加到总势中，并小心地排除 $j=i$ 时的自相互作用项。\n\n总势 $S_i^{(\\mathrm{approx})}$ 是所有来自远场多极近似和近场直接求和的贡献之和。对每个目标点 $x_i$ 重复整个过程。这种分层方法的效率源于将许多遥远源的影响聚合到一次廉价的多极计算中，从而避免了直接方法中成本高昂的成对求和。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import comb\n\n# --- GLOBAL PARAMETERS ---\nP_ORDER = 12\nMAX_DEPTH = 20\nLEAF_CAPACITY = 8\nLAMBDA_SEP = 2.0\n\nclass Box:\n    \"\"\"Represents a box in the binary tree.\"\"\"\n    def __init__(self, center, half_length, level, point_indices):\n        self.center = center\n        self.half_length = half_length\n        self.level = level\n        self.point_indices = np.array(point_indices, dtype=int)\n        self.moments = np.zeros(P_ORDER + 1, dtype=float)\n        self.parent = None\n        self.left_child = None\n        self.right_child = None\n\n    @property\n    def is_leaf(self):\n        return self.left_child is None and self.right_child is None\n\ndef build_tree(x, n):\n    \"\"\"Builds the binary tree for the given points.\"\"\"\n    if n == 0:\n        return None\n    \n    min_x, max_x = np.min(x), np.max(x)\n    center = (min_x + max_x) / 2.0\n    half_length = (max_x - min_x) / 2.0\n    # Handle case where all points are at the same location\n    if half_length == 0.0:\n        half_length = 1e-5 # A small non-zero value\n\n    root = Box(center, half_length, 0, np.arange(n))\n    \n    queue = [root]\n    while queue:\n        current_box = queue.pop(0)\n        \n        # Subdivision criteria\n        if len(current_box.point_indices) <= LEAF_CAPACITY or current_box.level >= MAX_DEPTH:\n            continue\n\n        # Subdivide\n        c, a = current_box.center, current_box.half_length\n        point_pos = x[current_box.point_indices]\n        \n        left_indices = current_box.point_indices[point_pos < c]\n        right_indices = current_box.point_indices[point_pos >= c]\n\n        if len(left_indices) > 0:\n            left_child = Box(c - a/2.0, a/2.0, current_box.level + 1, left_indices)\n            left_child.parent = current_box\n            current_box.left_child = left_child\n            queue.append(left_child)\n\n        if len(right_indices) > 0:\n            right_child = Box(c + a/2.0, a/2.0, current_box.level + 1, right_indices)\n            right_child.parent = current_box\n            current_box.right_child = right_child\n            queue.append(right_child)\n            \n    return root\n\ndef calculate_moments_upward_pass(box, x, q):\n    \"\"\"Recursively computes moments in a post-order traversal (upward pass).\"\"\"\n    if not box.is_leaf:\n        if box.left_child:\n            calculate_moments_upward_pass(box.left_child, x, q)\n        if box.right_child:\n            calculate_moments_upward_pass(box.right_child, x, q)\n        \n        # M2M translation from children to parent\n        box.moments.fill(0.0)\n        for child in [box.left_child, box.right_child]:\n            if child:\n                c_ch, c_par = child.center, box.center\n                dist_vec = c_ch - c_par\n                for n in range(P_ORDER + 1):\n                    m_n_par_contrib = 0.0\n                    for k in range(n + 1):\n                        m_n_par_contrib += comb(n, k, exact=True) * (dist_vec)**(n - k) * child.moments[k]\n                    box.moments[n] += m_n_par_contrib\n    else: # It is a leaf\n        # Compute moments directly from sources\n        for idx in box.point_indices:\n            dist_vec = x[idx] - box.center\n            for n in range(P_ORDER + 1):\n                box.moments[n] += q[idx] * (dist_vec)**n\n\ndef _recursive_potential_eval(target_idx, x, q, box):\n    \"\"\"Recursive helper for the downward pass potential evaluation.\"\"\"\n    target_pos = x[target_idx]\n    dist_to_center = np.abs(target_pos - box.center)\n    \n    # Well-separation criterion\n    is_well_separated = dist_to_center >= LAMBDA_SEP * box.half_length\n\n    if is_well_separated:\n        # Far-field: Use multipole expansion (M2P)\n        potential = 0.0\n        m = box.moments\n        dist = target_pos - box.center\n\n        # Handle log(|dist|) case where dist is 0, though separation criterion should prevent this.\n        if abs(dist) < 1e-15: return 0.0\n        \n        potential += m[0] * np.log(np.abs(dist))\n        \n        dist_inv = 1.0 / dist\n        dist_inv_n = dist_inv # Starts with n=1\n        for n in range(1, P_ORDER + 1):\n            potential -= (1.0/n) * m[n] * dist_inv_n\n            dist_inv_n *= dist_inv\n        return potential\n    else:\n        # Near-field\n        if box.is_leaf:\n            # Direct summation for near-field leaf\n            potential = 0.0\n            for j in box.point_indices:\n                if j != target_idx:\n                    dist = np.abs(target_pos - x[j])\n                    if dist > 1e-15: # Avoid log(0)\n                        potential += q[j] * np.log(dist)\n            return potential\n        else:\n            # Refine to children\n            potential = 0.0\n            if box.left_child:\n                potential += _recursive_potential_eval(target_idx, x, q, box.left_child)\n            if box.right_child:\n                potential += _recursive_potential_eval(target_idx, x, q, box.right_child)\n            return potential\n\ndef compute_approximate(n, x, q):\n    \"\"\"Computes potentials using the hierarchical method.\"\"\"\n    if n <= 1:\n        return np.zeros(n, dtype=float)\n\n    root = build_tree(x, n)\n    calculate_moments_upward_pass(root, x, q)\n    \n    s_approx = np.zeros(n, dtype=float)\n    for i in range(n):\n        s_approx[i] = _recursive_potential_eval(i, x, q, root)\n        \n    return s_approx\n\ndef compute_direct(n, x, q):\n    \"\"\"Computes potentials using direct summation.\"\"\"\n    s_direct = np.zeros(n, dtype=float)\n    if n <= 1:\n        return s_direct\n        \n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dist = np.abs(x[i] - x[j])\n                # Safety for log(0) though i != j should prevent it for distinct points.\n                if dist > 1e-15:\n                     s_direct[i] += q[j] * np.log(dist)\n    return s_direct\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = []\n\n    # Test case 1\n    n_1 = 16\n    x_1 = np.arange(n_1, dtype=float) / (n_1 - 1)\n    q_1 = (-1.0)**np.arange(n_1)\n    test_cases.append((n_1, x_1, q_1))\n    \n    # Test case 2\n    n_2 = 20\n    x_2_part1 = 1e-3 * np.arange(1, 11)\n    x_2_part2 = 1.0 - 1e-3 * np.arange(1, 11)\n    x_2 = np.concatenate([x_2_part1, x_2_part2])\n    q_2_part1 = 1.0 / np.arange(1, 11)\n    q_2_part2 = -1.0 / np.arange(1, 11)\n    q_2 = np.concatenate([q_2_part1, q_2_part2])\n    test_cases.append((n_2, x_2, q_2))\n\n    # Test case 3\n    n_3 = 1\n    x_3 = np.array([0.5])\n    q_3 = np.array([2.0])\n    test_cases.append((n_3, x_3, q_3))\n\n    # Test case 4\n    n_4 = 32\n    u_4 = np.arange(n_4, dtype=float) / (n_4 - 1)\n    x_4 = u_4**2\n    q_4 = np.sin(2 * np.pi * np.arange(n_4) / n_4)\n    test_cases.append((n_4, x_4, q_4))\n    \n    results = []\n    for n, x, q in test_cases:\n        s_direct = compute_direct(n, x, q)\n        s_approx = compute_approximate(n, x, q)\n        \n        if n == 0:\n            error = 0.0\n        else:\n            error = np.max(np.abs(s_approx - s_direct))\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "2374805"}]}