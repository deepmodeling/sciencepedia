{"hands_on_practices": [{"introduction": "水平集方法的一个核心优势在于其能够以隐式方式表示复杂的几何形状。这项练习将帮助你掌握一个基本原则：如何通过对简单区域执行逻辑运算来组合出复杂区域。通过这个实践，你将学会如何利用标量场来思考和构建几何，而非仅仅依赖于显式的点和线 [@problem_id:2408611]。", "problem": "一个二维区域 $R \\subset \\mathbb{R}^{2}$ 由两个标量场不等式的逻辑合取定义：$f(x,y) > C_{1}$ 且 $g(x,y) < C_{2}$。代表 $R$ 的水平集函数 $\\phi(x,y)$ 是任意一个标量场，其零水平集与 $R$ 的边界重合，并且该函数在 $R$ 上恰好为负值。考虑标量场 $f(x,y) = (x-1)^{2} + (y+2)^{2}$ 和 $g(x,y) = y^{2} - x$，以及常数 $C_{1} = 4$ 和 $C_{2} = 1$。仅使用上述定义和基本运算，构建一个单一的、显式的水平集函数 $\\Phi(x,y)$，该函数在集合 $R = \\{(x,y) \\in \\mathbb{R}^{2} : f(x,y) > C_{1} \\text{ and } g(x,y) < C_{2}\\}$ 上恰好为负，且其零水平集等于 $R$ 的边界。请以一个关于 $x$ 和 $y$ 的单一闭式解析表达式的形式给出 $\\Phi(x,y)$。", "solution": "在尝试给出任何解答之前，本问题将首先经过一个严格的验证程序。\n\n**问题验证**\n\n**步骤 1：提取已知条件**\n\n问题陈述逐字提供了以下信息：\n*   一个二维区域 $R \\subset \\mathbb{R}^{2}$ 由两个标量场不等式的逻辑合取定义：$f(x,y) > C_{1}$ 且 $g(x,y) < C_{2}$。\n*   代表 $R$ 的水平集函数 $\\phi(x,y)$ 是任意一个标量场，其零水平集与 $R$ 的边界重合，并且该函数在 $R$ 上恰好为负值。\n*   标量场 $f(x,y) = (x-1)^{2} + (y+2)^{2}$。\n*   标量场 $g(x,y) = y^{2} - x$。\n*   常数 $C_{1} = 4$。\n*   常数 $C_{2} = 1$。\n*   目标是为集合 $R = \\{(x,y) \\in \\mathbb{R}^{2} : f(x,y) > C_{1} \\text{ and } g(x,y) < C_{2}\\}$ 构建一个单一的、显式的水平集函数 $\\Phi(x,y)$。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n根据所需标准对问题进行评估：\n*   **科学依据**：该问题根植于水平集方法的数学理论，这是一种在计算工程、应用数学和计算机图形学中用于追踪界面和形状的标准且成熟的技术。标量场、不等式和逻辑合取等概念是基本的数学原理。该问题不包含伪科学或臆测。\n*   **适定性**：该问题提供了所有必要的组成部分：两个标量场 $f(x,y)$ 和 $g(x,y)$，两个常数 $C_1$ 和 $C_2$，以及区域 $R$ 的清晰定义。水平集函数的定义是标准的。任务是构建*一个*合适的函数，而不是*唯一的*函数，这是恰当的，因为可能存在多个这样的函数。解可以通过对水平集函数的标准逻辑运算来构建。\n*   **客观性**：问题以精确、无歧义的数学语言陈述。没有主观或基于观点的陈述。\n\n该问题不具有验证协议中列出的任何缺陷。它在数学和科学上是合理的、自洽的，并且是可形式化的。\n\n**步骤 3：结论与行动**\n\n问题被判定为**有效**。现在将提供解答。\n\n**解**\n\n我们所关注的区域 $R$ 定义为 $\\mathbb{R}^{2}$ 中满足以下两个联立不等式的点 $(x,y)$ 的集合：\n$$R = \\{ (x,y) \\in \\mathbb{R}^{2} \\mid f(x,y) > C_{1} \\text{ and } g(x,y) < C_{2} \\}$$\n任务是找到一个函数 $\\Phi(x,y)$，使得 $\\Phi(x,y) < 0$ 当且仅当 $(x,y) \\in R$，并且 $\\Phi(x,y) = 0$ 当且仅当 $(x,y)$ 在 $R$ 的边界上（记为 $\\partial R$）。\n\n我们可以通过首先为两个不等式分别构建各自的水平集函数来解决这个问题。设两个子区域为 $R_1 = \\{ (x,y) \\mid f(x,y) > C_{1} \\}$ 和 $R_2 = \\{ (x,y) \\mid g(x,y) < C_{2} \\}$。那么 $R = R_1 \\cap R_2$。\n\n对于第一个不等式 $f(x,y) > C_{1}$，我们可以将其重排为 $C_{1} - f(x,y) < 0$。我们为区域 $R_1$ 定义一个水平集函数 $\\phi_{1}(x,y)$：\n$$ \\phi_{1}(x,y) = C_{1} - f(x,y) $$\n根据此定义，对于 $R_1$ 内的点，$\\phi_{1}(x,y) < 0$；对于 $R_1$ 边界上的点（其中 $f(x,y)=C_{1}$），$\\phi_{1}(x,y) = 0$；对于 $R_1$ 外部的点，$\\phi_{1}(x,y) > 0$。\n\n对于第二个不等式 $g(x,y) < C_{2}$，我们可以将其重排为 $g(x,y) - C_{2} < 0$。我们为区域 $R_2$ 定义一个水平集函数 $\\phi_{2}(x,y)$：\n$$ \\phi_{2}(x,y) = g(x,y) - C_{2} $$\n根据此定义，对于 $R_2$ 内的点，$\\phi_{2}(x,y) < 0$；对于 $R_2$ 边界上的点（其中 $g(x,y)=C_{2}$），$\\phi_{2}(x,y) = 0$；对于 $R_2$ 外部的点，$\\phi_{2}(x,y) > 0$。\n\n区域 $R$ 是 $R_1$ 和 $R_2$ 的交集。一个点 $(x,y)$ 位于 $R$ 内当且仅当 $(x,y)$ 同时在 $R_1$ 和 $R_2$ 内。用我们的水平集函数来表示，这意味着 $\\phi_{1}(x,y) < 0$ 且 $\\phi_{2}(x,y) < 0$。\n\n为了将它们组合成一个表示该交集的单一水平集函数 $\\Phi(x,y)$，我们使用最大值算子。由水平集函数 $\\phi_1$ 和 $\\phi_2$ 表示的两个区域的交集由 $\\Phi = \\max(\\phi_1, \\phi_2)$ 表示。让我们来验证这一点：\n*   如果 $(x,y) \\in R$，那么 $\\phi_{1}(x,y) < 0$ 且 $\\phi_{2}(x,y) < 0$。因此，$\\Phi(x,y) = \\max(\\phi_{1}(x,y), \\phi_{2}(x,y)) < 0$。\n*   如果 $(x,y) \\notin R$，那么至少有一个条件不成立。这意味着 $\\phi_{1}(x,y) \\ge 0$ 或 $\\phi_{2}(x,y) \\ge 0$。在任何一种情况下，都有 $\\Phi(x,y) = \\max(\\phi_{1}(x,y), \\phi_{2}(x,y)) \\ge 0$。\n*   零水平集 $\\Phi(x,y)=0$ 在 $\\max(\\phi_1, \\phi_2)=0$ 时出现。这种情况发生在一个函数为零而另一个为非正数时（即，在 $R$ 的边界上）。\n\n所以， $\\Phi(x,y)$ 的正确构造是：\n$$ \\Phi(x,y) = \\max(\\phi_{1}(x,y), \\phi_{2}(x,y)) $$\n\n现在，我们代入 $f(x,y)$、$g(x,y)$、$C_{1}$ 和 $C_{2}$ 的给定表达式：\n$$ \\phi_{1}(x,y) = C_{1} - f(x,y) = 4 - ((x-1)^{2} + (y+2)^{2}) $$\n$$ \\phi_{2}(x,y) = g(x,y) - C_{2} = (y^{2} - x) - 1 $$\n因此，\n$$ \\Phi(x,y) = \\max(4 - (x-1)^{2} - (y+2)^{2}, y^{2} - x - 1) $$\n为了将其写成一个不含分段 max 函数的单一闭式解析表达式，我们使用恒等式 $\\max(a, b) = \\frac{1}{2}(a+b + |a-b|)$。令 $a = 4 - (x-1)^{2} - (y+2)^{2}$ 且 $b = y^{2} - x - 1$。\n首先，展开并化简 $a$ 和 $b$：\n$$ a = 4 - (x^{2}-2x+1) - (y^{2}+4y+4) = -x^{2} + 2x - y^{2} - 4y - 1 $$\n$$ b = y^{2} - x - 1 $$\n接下来，计算 $a+b$ 和 $a-b$：\n$$ a+b = (-x^{2} + 2x - y^{2} - 4y - 1) + (y^{2} - x - 1) = -x^{2} + x - 4y - 2 $$\n$$ a-b = (-x^{2} + 2x - y^{2} - 4y - 1) - (y^{2} - x - 1) = -x^{2} + 3x - 2y^{2} - 4y $$\n将这些代入 $\\max(a, b)$ 的恒等式中：\n$$ \\Phi(x,y) = \\frac{1}{2} \\left( (-x^{2} + x - 4y - 2) + |-x^{2} + 3x - 2y^{2} - 4y| \\right) $$\n这就是所要求的水平集函数 $\\Phi(x,y)$ 的单一、显式、闭式解析表达式。", "answer": "$$\n\\boxed{\\frac{1}{2} \\left( -x^{2} + x - 4y - 2 + |-x^{2} + 3x - 2y^{2} - 4y| \\right)}\n$$", "id": "2408611"}, {"introduction": "现在，我们将注意力转向基于热力学基础的相场模型。Allen-Cahn 方程不仅仅是一个数学结构，它描述了一个系统自由能 $ \\mathcal{F} $ 最小化的物理过程，即梯度流。这项编程实践将让你亲手验证这一抽象的物理原理，将偏微分方程与其背后的能量泛函联系起来，从而加深你对模型物理一致性的理解 [@problem_id:2408607]。", "problem": "考虑一个定义在周期性一维域上的标量相场 $ \\phi(x,t) $ 的 Ginzburg–Landau 自由能泛函，\n$$\n\\mathcal{F}[\\phi] \\;=\\; \\int_{0}^{L} \\left( \\frac{\\varepsilon^2}{2}\\, |\\partial_x \\phi|^2 \\;+\\; \\frac{1}{4}\\,(\\phi^2 - 1)^2 \\right)\\, \\mathrm{d}x,\n$$\n其中迁移率为 $ M > 0 $，界面厚度参数为 $ \\varepsilon > 0 $。Allen–Cahn 动力学是 $ \\mathcal{F} $ 的 $L^2$ 梯度流，即偏微分方程 (PDE)\n$$\n\\partial_t \\phi \\;=\\; -\\, M \\,\\frac{\\delta \\mathcal{F}}{\\delta \\phi}\n\\;=\\; -\\, M \\,\\Big( -\\,\\varepsilon^2 \\,\\partial_{xx}\\phi \\;+\\; \\phi^3 \\;-\\; \\phi \\Big),\n$$\n该方程定义在 $ x \\in [0,L] $ 上，并采用周期性边界条件。假设初始条件为\n$$\n\\phi(x,0) \\;=\\; 0.3\\,\\sin\\!\\Big(\\frac{2\\pi x}{L}\\Big) \\;+\\; 0.2\\,\\sin\\!\\Big(\\frac{4\\pi x}{L}\\Big).\n$$\n设时间范围为 $ t \\in [0, T] $，以均匀步长 $ \\Delta t > 0 $ 采样；空间域使用 $ N \\in \\mathbb{N} $ 个点进行均匀离散化，并采用周期性边界条件。定义化学势\n$$\n\\mu \\;=\\; \\frac{\\delta \\mathcal{F}}{\\delta \\phi} \\;=\\; -\\,\\varepsilon^2 \\,\\partial_{xx}\\phi \\;+\\; \\phi^3 \\;-\\; \\phi.\n$$\n从基本原理可知，\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}\\,\\mathcal{F}[\\phi(t)] \\;=\\; -\\, M \\int_{0}^{L} \\mu(x,t)^2 \\,\\mathrm{d}x \\;\\le\\; 0,\n$$\n因此该动力学是 $ \\mathcal{F} $ 的一个梯度下降过程。\n\n任务：编写一个完整且可运行的程序，对于下述每个测试用例，在 $ t \\in [0,T] $ 上模拟 $ \\phi(x,t) $，计算沿轨迹的离散自由能 $ \\mathcal{F} $，并返回：\n- 一个布尔值，指示计算出的离散能量序列在容差 $ \\tau_{\\mathrm{mono}} $ 范围内是否非递增，要求是在所有离散时间点均满足 $ \\mathcal{F}(t_{n+1}) \\le \\mathcal{F}(t_n) + \\tau_{\\mathrm{mono}} $，其中 $ \\tau_{\\mathrm{mono}} = 10^{-8}\\,\\mathcal{F}(t_0) $，\n- 一个浮点数，其值等于净能量降与梯度下降恒等式所预测的时间积分耗散之间的相对差异，即\n$$\nr \\;=\\; \\frac{\\big| \\, \\big( \\mathcal{F}(T) - \\mathcal{F}(0) \\big) \\;+\\; M \\int_{0}^{T}\\!\\!\\int_{0}^{L} \\mu(x,t)^2 \\,\\mathrm{d}x\\,\\mathrm{d}t \\,\\big|}{\\max\\!\\big(1,\\,|\\mathcal{F}(0)|\\big)}.\n$$\n\n所有量均为无量纲；无需物理单位。三角函数中的角度单位为弧度。您所采用的数值近似方法必须与上述定义一致。\n\n测试套件（每个用例是一个元组 $(L, N, \\varepsilon, M, \\Delta t, T)$）：\n- 用例 $1$：$(L, N, \\varepsilon, M, \\Delta t, T) = (1.0,\\, 256,\\, 0.02,\\, 1.0,\\, 5\\times 10^{-5},\\, 0.02)$。\n- 用例 $2$：$(L, N, \\varepsilon, M, \\Delta t, T) = (1.0,\\, 128,\\, 0.03,\\, 0.5,\\, 5\\times 10^{-5},\\, 0.015)$。\n- 用例 $3$：$(L, N, \\varepsilon, M, \\Delta t, T) = (1.0,\\, 256,\\, 0.05,\\, 1.0,\\, 1\\times 10^{-4},\\, 0.03)$。\n\n您的程序必须生成单行输出，其中包含测试套件的汇总结果，格式为方括号内以逗号分隔的列表，并严格遵循以下顺序：$[\\text{is\\_decreasing}_{1}, r_{1}, \\text{is\\_decreasing}_{2}, r_{2}, \\text{is\\_decreasing}_{3}, r_{3}]$，其中 $ \\text{is\\_decreasing}_{i} $ 是用例 $i$ 的布尔值，$r_i$ 是相应的浮点数。", "solution": "该问题要求对一维周期性域上的 Allen-Cahn 偏微分方程（PDE）进行数值模拟。该方程描述了标量相场 $\\phi(x,t)$ 的时间演化，并代表了 Ginzburg-Landau 自由能泛函 $\\mathcal{F}[\\phi]$ 的 $L^2$ 梯度流。目标是使用一种数值格式来验证该梯度流的两个基本性质：自由能的单调递减性，以及关联总能量变化与时间积分耗散的守恒律。\n\n求解 Allen-Cahn 方程需要一种鲁棒的数值方法，该方程是一个刚性的非线性反应扩散方程。其刚性源于拉普拉斯项 $\\varepsilon^2 \\partial_{xx}\\phi$，特别是当界面厚度参数 $\\varepsilon$ 很小时，因为它会引入与不同空间频率相关的广泛时间尺度。\n\n此处采用的数值策略基于用于空间离散化的傅里叶伪谱方法和用于时间积分的一阶隐式-显式 (IMEX) 格式。对于周期性域上的此类问题，这种组合非常有效。\n\n首先，我们将空间域 $x \\in [0, L]$ 离散化为 $N$ 个等距点 $x_j = j \\Delta x$，其中 $j = 0, 1, \\ldots, N-1$，网格间距为 $\\Delta x = L/N$。相场由向量 $\\boldsymbol{\\phi}(t)$ 表示，其中分量 $\\phi_j(t)$ 近似于 $\\phi(x_j, t)$。\n\n选择傅里叶伪谱方法是因为在周期性边界条件下，它在近似空间导数方面具有谱精度。我们使用离散傅里叶变换 (DFT)（记作 $\\mathcal{F}_k$）及其逆变换 $\\mathcal{F}_k^{-1}$。相场向量 $\\boldsymbol{\\phi}$ 的 DFT 为 $\\hat{\\boldsymbol{\\phi}} = \\mathcal{F}_k[\\boldsymbol{\\phi}]$。然后，在傅里叶空间中高效地计算空间导数。具体来说，二阶导数 $\\partial_{xx}\\phi$ 的计算方式如下：\n$$\n\\partial_{xx}\\boldsymbol{\\phi} = \\mathcal{F}_k^{-1}[-k_m^2 \\hat{\\boldsymbol{\\phi}}]\n$$\n其中 $k_m = \\frac{2\\pi m}{L}$ 是与 DFT 的离散频率 $m$ 相对应的角波数。\n\n对于时间积分，PDE $\\partial_t \\phi = M(\\varepsilon^2 \\partial_{xx}\\phi - \\phi^3 + \\phi)$ 被分裂为一个刚性线性部分和一个非刚性非线性部分：\n$$\n\\partial_t \\phi = \\underbrace{M\\varepsilon^2 \\partial_{xx}\\phi}_{\\text{Linear, stiff}} + \\underbrace{M(\\phi - \\phi^3)}_{\\text{Nonlinear, non-stiff}}\n$$\n我们应用一阶 IMEX 格式，对刚性线性项进行隐式处理（使用后向欧拉法），对非刚性非线性项进行显式处理（使用前向欧拉法）。对于从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的一个时间步，该格式为：\n$$\n\\frac{\\boldsymbol{\\phi}^{n+1} - \\boldsymbol{\\phi}^n}{\\Delta t} = M\\varepsilon^2 \\partial_{xx}\\boldsymbol{\\phi}^{n+1} + M(\\boldsymbol{\\phi}^n - (\\boldsymbol{\\phi}^n)^3)\n$$\n将此方程变换到傅里叶空间，可以得到关于下一时间步解的傅里叶系数 $\\hat{\\boldsymbol{\\phi}}^{n+1}$ 的代数方程：\n$$\n\\frac{\\hat{\\boldsymbol{\\phi}}^{n+1} - \\hat{\\boldsymbol{\\phi}}^n}{\\Delta t} = M\\varepsilon^2(-k_m^2) \\hat{\\boldsymbol{\\phi}}^{n+1} + \\mathcal{F}_k[M(\\boldsymbol{\\phi}^n - (\\boldsymbol{\\phi}^n)^3)]\n$$\n这样就可以直接求解每个傅里叶模式：\n$$\n\\hat{\\boldsymbol{\\phi}}^{n+1} = \\frac{\\hat{\\boldsymbol{\\phi}}^n + \\Delta t \\, \\mathcal{F}_k[M(\\boldsymbol{\\phi}^n - (\\boldsymbol{\\phi}^n)^3)]}{1 + \\Delta t M \\varepsilon^2 k_m^2}\n$$\n然后通过逆 DFT 恢复更新后的场 $\\boldsymbol{\\phi}^{n+1}$。相对于刚性扩散项，该格式是无条件稳定的，因此允许使用比完全显式方法更大的时间步长。\n\n为了评估所需的量，我们必须对泛函 $\\mathcal{F}[\\phi]$ 和耗散积分进行离散化。在每个时间步，自由能 $\\mathcal{F}[\\phi]$ 使用数值求积法计算。空间积分通过对所有网格点求和来近似，并以 $\\Delta x$ 加权：\n$$\n\\mathcal{F}[\\boldsymbol{\\phi}] \\approx \\Delta x \\sum_{j=0}^{N-1} \\left( \\frac{\\varepsilon^2}{2} (\\partial_x \\phi_j)^2 + \\frac{1}{4}(\\phi_j^2 - 1)^2 \\right)\n$$\n空间导数 $\\partial_x \\phi_j$ 通过 $\\partial_x \\boldsymbol{\\phi} = \\mathcal{F}_k^{-1}[i k_m \\hat{\\boldsymbol{\\phi}}]$ 以谱方法计算，从而与求解器保持一致性。\n\n能量平衡关系需要计算空间积分后的化学势平方的时间积分，即 $M \\int_{0}^{T}\\int_{0}^{L} \\mu(x,t)^2 \\,\\mathrm{d}x\\,\\mathrm{d}t$。化学势 $\\mu = -\\varepsilon^2 \\partial_{xx}\\phi + \\phi^3 - \\phi$ 在每个时间步 $t_n$ 的每个网格点上计算，其中拉普拉斯算子也使用谱方法计算。令 $D(t_n) = M \\int_{0}^{L} \\mu(x,t_n)^2 \\,\\mathrm{d}x \\approx M \\Delta x \\sum_{j=0}^{N-1} \\mu_j(t_n)^2$。时间积分则使用梯形法则近似：\n$$\n\\int_0^T D(t) \\,\\mathrm{d}t \\approx \\Delta t \\sum_{n=0}^{N_t-1} \\frac{D(t_n) + D(t_{n+1})}{2}\n$$\n其中 $N_t = T/\\Delta t$ 是总时间步数。这为积分提供了二阶精确的近似，适用于验证该 PDE 的能量耗散性质。\n\n算法流程如下：\n1. 初始化空间网格、波数和初始相场 $\\boldsymbol{\\phi}^0$。\n2. 计算并存储初始能量 $\\mathcal{F}(t_0)$ 和初始耗散率项 $D(t_0)$。\n3. 对 $n$ 从 $0$ 到 $N_t-1$ 进行循环：\n    a. 在实空间中计算非线性项。\n    b. 将当前状态 $\\boldsymbol{\\phi}^n$ 和非线性项变换到傅里叶空间。\n    c. 在傅里叶空间中应用 IMEX 更新公式以得到 $\\hat{\\boldsymbol{\\phi}}^{n+1}$。\n    d. 变换回实空间以获得 $\\boldsymbol{\\phi}^{n+1}$。\n    e. 计算并存储能量 $\\mathcal{F}(t_{n+1})$ 和耗散率项 $D(t_{n+1})$。\n4. 模拟结束后，根据指定的容差 $\\tau_{\\mathrm{mono}}$ 验证存储的能量序列的单调性。\n5. 使用初始和最终能量以及对耗散率项的梯形法则积分，计算相对差异 $r$。\n\n这种基于原理的方法确保了问题的数值解是可靠的，从而可以精确验证系统的指定物理性质。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Allen-Cahn equation for given test cases and verifies\n    energy properties.\n    \"\"\"\n    test_cases = [\n        # Case 1: (L, N, ε, M, Δt, T)\n        (1.0, 256, 0.02, 1.0, 5e-5, 0.02),\n        # Case 2: (L, N, ε, M, Δt, T)\n        (1.0, 128, 0.03, 0.5, 5e-5, 0.015),\n        # Case 3: (L, N, ε, M, Δt, T)\n        (1.0, 256, 0.05, 1.0, 1e-4, 0.03),\n    ]\n\n    # Use scipy.fft if available, fall back to numpy.fft\n    try:\n        from scipy.fft import fft, ifft, fftfreq\n    except ImportError:\n        from numpy.fft import fft, ifft, fftfreq\n\n    def run_simulation(L, N, epsilon, M, dt, T):\n        \"\"\"\n        Performs a single simulation run for a given set of parameters.\n        \"\"\"\n        # 1. Discretization and Initialization\n        dx = L / N\n        x = np.linspace(0, L, N, endpoint=False)\n        num_steps = int(round(T / dt))\n\n        # Wavenumbers for Fourier transforms\n        k = 2 * np.pi * fftfreq(N, d=dx)\n        k_sq = k**2\n\n        # Initial condition\n        phi = 0.3 * np.sin(2 * np.pi * x / L) + 0.2 * np.sin(4 * np.pi * x / L)\n\n        # Helper functions for diagnostics\n        def compute_energy(phi_vec):\n            phi_hat = fft(phi_vec)\n            d_phi_dx_hat = 1j * k * phi_hat\n            d_phi_dx = ifft(d_phi_dx_hat).real\n            \n            grad_energy_density = (epsilon**2 / 2) * d_phi_dx**2\n            potential_energy_density = 0.25 * (phi_vec**2 - 1)**2\n            \n            return np.sum(grad_energy_density + potential_energy_density) * dx\n\n        def compute_mu(phi_vec):\n            phi_hat = fft(phi_vec)\n            d2_phi_dx2_hat = -k_sq * phi_hat\n            d2_phi_dx2 = ifft(d2_phi_dx2_hat).real\n            \n            mu = -epsilon**2 * d2_phi_dx2 + phi_vec**3 - phi_vec\n            return mu\n\n        # Store results\n        energies = np.zeros(num_steps + 1)\n        dissipation_integrals = np.zeros(num_steps + 1)\n\n        # Initial state diagnostics\n        energies[0] = compute_energy(phi)\n        mu_0 = compute_mu(phi)\n        dissipation_integrals[0] = M * np.sum(mu_0**2) * dx\n\n        # Denominator for the IMEX scheme update\n        imex_denominator = 1 + dt * M * epsilon**2 * k_sq\n\n        # 2. Time-stepping loop\n        phi_current = phi.copy()\n        for i in range(num_steps):\n            # Explicit part (nonlinear term)\n            nl_term = M * (phi_current - phi_current**3)\n            \n            # Update in Fourier space\n            phi_hat = fft(phi_current)\n            nl_term_hat = fft(nl_term)\n            \n            phi_hat_new = (phi_hat + dt * nl_term_hat) / imex_denominator\n            \n            # Update in real space\n            phi_current = ifft(phi_hat_new).real\n            \n            # Diagnostics at the new time step\n            energies[i + 1] = compute_energy(phi_current)\n            mu_current = compute_mu(phi_current)\n            dissipation_integrals[i + 1] = M * np.sum(mu_current**2) * dx\n\n        # 3. Post-processing\n        # Monotonicity check\n        F0 = energies[0]\n        tau_mono = 1e-8 * F0\n        is_decreasing = np.all(energies[1:] = energies[:-1] + tau_mono)\n\n        # Relative discrepancy 'r'\n        delta_F_actual = energies[-1] - energies[0]\n        \n        # Integrate dissipation using trapezoidal rule\n        integrated_dissipation = np.trapz(dissipation_integrals, dx=dt)\n        \n        numerator = np.abs(delta_F_actual + integrated_dissipation)\n        denominator = np.max([1.0, np.abs(F0)])\n        relative_discrepancy = numerator / denominator\n\n        return bool(is_decreasing), relative_discrepancy\n\n    results = []\n    for case in test_cases:\n        L, N, epsilon, M, dt, T = case\n        is_dec, r_val = run_simulation(L, N, epsilon, M, dt, T)\n        results.extend([is_dec, r_val])\n\n    # Final print statement in the exact required format.\n    # The boolean values are automatically converted to 'True' or 'False'.\n    output_str = ','.join(map(str, results))\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "2408607"}, {"introduction": "在分别了解了水平集和相场模型的基本原理后，这个对比性实践将探索它们最显著的共同优点之一：自动处理拓扑变化的能力。通过模拟两个界面从碰撞到融合的过程，你将直接观察和比较纯几何驱动的水平集方法与基于物理的相场模型如何处理这一复杂事件。这项练习将巩固你对这两种方法在动态、拓扑非平凡场景中行为特性的理解 [@problem_id:2408605]。", "problem": "考虑在周期性方形域上的两种替代隐式界面模型，它们通过在二维平面中传输闭合曲线来近似两个同轴涡环横截面的碰撞。设计算域为方形区域 $\\left[-1,1\\right]\\times\\left[-1,1\\right]$，在两个方向上均具有周期性边界。设 $N\\times N$ 为均匀网格分辨率，网格间距为 $\\Delta x=\\Delta y=\\dfrac{2}{N}$。定义一个空间变化、时间无关的速度场 $\\mathbf{u}(x,y)=\\left(u_x(x),u_y(x)\\right)$，其中\n$$\nu_x(x)=-U\\tanh\\!\\left(\\dfrac{x}{\\delta}\\right),\\quad u_y(x)=0,\n$$\n其中 $U0$ 和 $\\delta0$ 是给定常数。两个初始圆形界面代表两个相同涡环的横截面：分别是半径为 $R$、圆心位于 $\\left(-a,0\\right)$ 和 $\\left(+a,0\\right)$ 的圆，且满足 $0Ra1$。\n\n您必须实现以下两种界面描述，并将其在时间上推进到指定的最终时刻 $T$：\n\n1. 水平集（Level-set）公式。设 $\\phi(x,y,t)$ 是一个标量场，其零水平集代表界面，其负值区域代表“涡核”集合的内部。其演化由线性平流方程给出\n$$\n\\partial_t \\phi + \\mathbf{u}\\cdot\\nabla \\phi = 0,\n$$\n初始条件为 $\\phi(x,y,0)=d(x,y)$，等于到两个初始圆并集的有符号距离，即\n$$\nd(x,y)=\\min\\!\\Big(\\sqrt{(x+a)^2+y^2}-R,\\;\\sqrt{(x-a)^2+y^2}-R\\Big),\n$$\n在任一圆内部 $d(x,y)0$。\n\n2. 相场（Phase-field）公式（平流 Allen–Cahn）。设 $c(x,y,t)$ 是一个标量序参数，用于近似一个由 $\\epsilon0$ 控制厚度的弥散界面。其演化由平流 Allen–Cahn 方程给出\n$$\n\\partial_t c + \\mathbf{u}\\cdot\\nabla c = \\dfrac{1}{\\tau}\\Big(\\epsilon^2\\nabla^2 c - f'(c)\\Big),\n$$\n其中 $\\tau0$ 是一个弛豫时间，且 $f(c)=\\dfrac{1}{2}c^2(1-c)^2$，因此 $f'(c)=c(1-c)(1-2c)$。初始条件是同样两个圆的光滑弥散表示，\n$$\nc(x,y,0)=\\dfrac{1}{2}\\left(1-\\tanh\\!\\left(\\dfrac{d(x,y)}{\\sqrt{2}\\,\\epsilon}\\right)\\right),\n$$\n使得在内部 $c\\approx 1$，在外部 $c\\approx 0$。\n\n对于每种公式，在时间 $t=T$ 时，定义二元“核”集合\n$$\n\\Omega_{\\mathrm{LS}}(T)=\\{(x,y):\\phi(x,y,T)0\\},\\qquad \\Omega_{\\mathrm{PF}}(T)=\\{(x,y):c(x,y,T)\\tfrac{1}{2}\\}.\n$$\n在周期性域上，使用带有周期性环绕的 $8$-连通性来定义二元集合的连通分量数量。为了减少虚假的数值斑点，在计数分量之前，丢弃任何面积（以网格点数计）严格小于 $A_{\\min}$ 的连通分量，其中\n$$\nA_{\\min}=\\left\\lfloor \\theta N^2 \\right\\rfloor,\\quad \\theta=0.002.\n$$\n\n您的任务是为下面的测试套件中的每个参数集计算整数对 $\\left(C_{\\mathrm{LS}},C_{\\mathrm{PF}}\\right)$，其中 $C_{\\mathrm{LS}}$ 是 $\\Omega_{\\mathrm{LS}}(T)$ 的连通分量数，而 $C_{\\mathrm{PF}}$ 是 $\\Omega_{\\mathrm{PF}}(T)$ 的连通分量数。\n\n测试套件（每个案例指定 $\\left(N,R,a,U,\\delta,\\epsilon,\\tau,T\\right)$）：\n\n- 案例 1：$\\left(96,\\;0.22,\\;0.34,\\;0.40,\\;0.10,\\;0.03,\\;1.0,\\;0.295\\right)$。\n- 案例 2：$\\left(96,\\;0.22,\\;0.34,\\;0.20,\\;0.10,\\;0.02,\\;1.0,\\;0.12\\right)$。\n- 案例 3：$\\left(96,\\;0.22,\\;0.34,\\;0.50,\\;0.10,\\;0.03,\\;1.0,\\;0.35\\right)$。\n\n所有量均为无量纲。如果在您的实现中出现任何角度，必须以弧度为单位。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的六个整数列表，顺序如下\n$$\n\\left[C_{\\mathrm{LS}}^{(1)},C_{\\mathrm{PF}}^{(1)},C_{\\mathrm{LS}}^{(2)},C_{\\mathrm{PF}}^{(2)},C_{\\mathrm{LS}}^{(3)},C_{\\mathrm{PF}}^{(3)}\\right],\n$$\n分别对应于测试套件中的案例 1、2 和 3。例如，形如 $\\left[2,1,2,2,1,1\\right]$ 的输出表示在案例 1 中，水平集有两个分量，相场有一个分量；在案例 2 中，各有二个分量；在案例 3 中，各有一个分量。", "solution": "问题陈述经过验证，被认为是科学上合理、适定且完整的。它描述了计算工程中的一个标准数值实验，比较了两种经典的界面追踪方法——水平集模型和相场模型。所有参数、方程以及初始和边界条件都得到了明确的规定，从而保证了解的唯一性。该问题是有效的。\n\n该解决方案要求在二维周期性域上对两个偏微分方程（PDE）进行数值积分。控制方程是用于水平集场 $\\phi$ 的线性平流方程和用于相场序参数 $c$ 的平流 Allen-Cahn 方程。\n\n首先，建立一个计算网格。将域 $\\left[-1,1\\right]\\times\\left[-1,1\\right]$ 离散化为一个 $N\\times N$ 点的均匀网格，网格间距为 $\\Delta x = \\Delta y = 2/N$。网格坐标定义为 $x_i = -1 + i\\Delta x$ 和 $y_j = -1 + j\\Delta y$，其中 $i,j \\in \\{0, \\dots, N-1\\}$。速度场 $\\mathbf{u}(x,y)$ 是纯水平的，其表达式为 $u_x(x)=-U\\tanh(x/\\delta)$，$u_y=0$，并在每个网格点 $x_i$ 上进行计算。\n\nPDE 中的空间算子使用尊重周期性边界条件的有限差分法进行离散化。周期性通过使用 `numpy.roll` 来移动网格数据得到高效处理。\n平流项 $\\mathbf{u}\\cdot\\nabla\\psi = u_x(x)\\partial_x\\psi$ 使用一阶迎风格式进行离散化。在平流主导的问题中，这一选择对于维持数值稳定性至关重要。该格式在速度 $u_x$ 为正时使用后向差分计算空间导数 $\\partial_x\\psi$，在 $u_x$ 为负时使用前向差分。\nAllen-Cahn 方程中的拉普拉斯算子 $\\nabla^2 c$ 使用标准的五点模板进行离散化，这是一种二阶精确的中心差分近似。\n\n场 $\\phi(x,y,t)$ 和 $c(x,y,t)$ 的时间演化是通过将半离散化方程（一个关于时间的常微分方程组）从 $t=0$ 积分到最终时间 $T$ 来实现的。由于其高精度和良好的稳定性，采用四阶龙格-库塔（RK4）方法进行此积分。时间步长 $\\Delta t$ 的选择必须满足所有参数集下，平流和扩散过程的 Courant-Friedrichs-Lewy (CFL) 稳定性条件。一个保守的全局 $\\Delta t$ 是基于最严格的条件计算的：$\\Delta t \\le \\nu \\cdot \\min(\\Delta x/U_{max}, \\tau (\\Delta x)^2/(4\\epsilon_{min}^2))$，其中使用了一个安全系数 $\\nu  1$。\n\n单个测试案例的演化过程如下：\n1. 根据提供的基于到初始双圆的有符号距离函数 $d(x,y)$ 的初始条件公式，在网格上初始化场 $\\phi_0 = \\phi(x,y,0)$ 和 $c_0 = c(x,y,0)$。\n2. 对于每个模型（水平集和相场），使用 RK4 格式在时间上向前积分，直到 $t=T$。\n3. 在 $t=T$ 时，通过应用指定的阈值：$\\phi(x,y,T)  0$ 和 $c(x,y,T)  1/2$，分别创建二元核集合 $\\Omega_{\\mathrm{LS}}(T)$ 和 $\\Omega_{\\mathrm{PF}}(T)$。\n\n最后一步是计算每个二元集合的连通分量数量，这需要满足两个关键约束：周期性边界和最小面积过滤器。\n标准的连通分量算法，例如 `scipy.ndimage.label`，本身不处理周期性连接。因此，需要一个适用于周期性域的正确实现。流程如下：\n1. 对二元掩码应用具有 $8$-连通性的标准 `scipy.ndimage.label`，这会为每个非周期性分量分配一个唯一的整数标签。\n2. 创建一个并查集（Disjoint Set Union, DSU）数据结构，以追踪跨周期性边界连接的标签的合并情况。\n3. 遍历域边界上的像素（例如，$x=-1$ 和 $y=-1$）。对于属于某个分量的每个像素，检查其在周期意义下的八个邻居。如果一个邻居属于具有不同标签的分量，则使用 DSU 的 `union` 操作合并这两个标签。\n4. 处理完所有边界像素后，DSU 结构包含了形成真实周期性分量的标签等价类。\n5. 通过将其所有组成标签的面积（像素计数）相加，来计算每个周期性分量的总面积。初始标签的像素计数可以通过 `numpy.bincount` 高效获得。\n6. 最后，计算总面积大于或等于最小面积阈值 $A_{\\min} = \\lfloor \\theta N^2 \\rfloor$ 的合并分量数量。这就得出了最终的分量计数 $C_{\\mathrm{LS}}$ 和 $C_{\\mathrm{PF}}$。\n\n对测试套件中提供的三个参数集中的每一个都重复此整个过程，并将得到的六个整数格式化为所需的输出字符串。", "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import label\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve the vortex collision problem for all test cases.\n    \"\"\"\n\n    # --- Data structure for periodic component merging ---\n    class DSU:\n        def __init__(self, n):\n            self.parent = list(range(n))\n        def find(self, i):\n            if self.parent[i] == i:\n                return i\n            self.parent[i] = self.find(self.parent[i])\n            return self.parent[i]\n        def union(self, i, j):\n            root_i = self.find(i)\n            root_j = self.find(j)\n            if root_i != root_j:\n                self.parent[root_j] = root_i\n\n    # --- Periodic connected component counting function ---\n    def count_components_periodic(mask, N, theta):\n        s = np.ones((3, 3), dtype=int)  # 8-connectivity\n        labeled_array, num_features = label(mask, structure=s, output=np.int32)\n\n        if num_features == 0:\n            return 0\n\n        dsu = DSU(num_features + 1)\n        \n        # Check connections across periodic boundaries (8-connectivity)\n        # Left-Right boundary\n        for i in range(N):\n            if mask[i, 0]:\n                label_left = labeled_array[i, 0]\n                # Neighbors of (i, 0) across the boundary are at x = -1 (N-1)\n                for i_offset in [-1, 0, 1]:\n                    ni = (i + i_offset + N) % N\n                    if mask[ni, -1]:\n                        dsu.union(label_left, labeled_array[ni, -1])\n        \n        # Top-Bottom boundary\n        for j in range(N):\n            if mask[0, j]:\n                label_top = labeled_array[0, j]\n                # Neighbors of (0, j) across the boundary are at y = -1 (N-1)\n                for j_offset in [-1, 0, 1]:\n                    nj = (j + j_offset + N) % N\n                    if mask[-1, nj]:\n                        dsu.union(label_top, labeled_array[-1, nj])\n\n        # Calculate areas of merged components\n        pixel_counts = np.bincount(labeled_array.ravel())\n        root_areas = {}\n        for i in range(1, num_features + 1):\n            if pixel_counts[i] > 0:\n                root = dsu.find(i)\n                if root not in root_areas:\n                    root_areas[root] = 0\n                root_areas[root] += pixel_counts[i]\n\n        # Filter by area\n        A_min = math.floor(theta * N**2)\n        valid_components = sum(1 for area in root_areas.values() if area >= A_min)\n        \n        return valid_components\n\n    # --- PDE Solver for a single case ---\n    def solve_single_case(params):\n        N, R, a, U, delta, epsilon, tau, T = params\n        theta = 0.002\n        \n        # Grid setup\n        dx = 2.0 / N\n        grid_pts = np.linspace(-1, 1, N, endpoint=False)\n        x, y = np.meshgrid(grid_pts, grid_pts)\n\n        # Velocity field\n        ux = -U * np.tanh(x / delta)\n\n        # Initial conditions\n        d = np.minimum(np.sqrt((x + a)**2 + y**2) - R, np.sqrt((x - a)**2 + y**2) - R)\n        phi0 = d\n        c0 = 0.5 * (1.0 - np.tanh(d / (np.sqrt(2.0) * epsilon)))\n        \n        # --- Spatial operators ---\n        inv_dx = 1.0 / dx\n        inv_dx2 = 1.0 / (dx**2)\n\n        def advection(field, u_field):\n            grad_fwd = (np.roll(field, -1, axis=1) - field) * inv_dx\n            grad_bwd = (field - np.roll(field, 1, axis=1)) * inv_dx\n            return np.where(u_field >= 0, u_field * grad_bwd, u_field * grad_fwd)\n\n        def laplacian(field):\n            return (np.roll(field, -1, axis=1) + np.roll(field, 1, axis=1) +\n                    np.roll(field, -1, axis=0) + np.roll(field, 1, axis=0) - 4 * field) * inv_dx2\n\n        # --- RHS of PDEs for RK4 ---\n        def rhs_ls(phi):\n            return -advection(phi, ux)\n\n        def rhs_pf(c):\n            f_prime = c * (1.0 - c) * (1.0 - 2.0 * c)\n            adv = advection(c, ux)\n            reaction_diffusion = (1.0 / tau) * (epsilon**2 * laplacian(c) - f_prime)\n            return -adv + reaction_diffusion\n            \n        # --- RK4 Time Stepper ---\n        def rk4_step(field, rhs_func, dt):\n            k1 = rhs_func(field)\n            k2 = rhs_func(field + 0.5 * dt * k1)\n            k3 = rhs_func(field + 0.5 * dt * k2)\n            k4 = rhs_func(field + dt * k3)\n            return field + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n\n        # CFL-based time step\n        dt_adv = dx / U if U > 0 else float('inf')\n        dt_diff = tau * dx**2 / (4 * epsilon**2) if epsilon > 0 else float('inf')\n        dt = 0.25 * min(dt_adv, dt_diff)\n        \n        # --- Time integration loop ---\n        # Level-Set\n        phi = np.copy(phi0)\n        t = 0.0\n        while t  T:\n            current_dt = min(dt, T - t)\n            phi = rk4_step(phi, rhs_ls, current_dt)\n            t += current_dt\n\n        # Phase-Field\n        c = np.copy(c0)\n        t = 0.0\n        while t  T:\n            current_dt = min(dt, T - t)\n            c = rk4_step(c, rhs_pf, current_dt)\n            t += current_dt\n        \n        # --- Component Counting ---\n        mask_ls = phi  0\n        mask_pf = c > 0.5\n        \n        C_LS = count_components_periodic(mask_ls, N, theta)\n        C_PF = count_components_periodic(mask_pf, N, theta)\n\n        return C_LS, C_PF\n\n    # --- Test Suite ---\n    test_cases = [\n        (96, 0.22, 0.34, 0.40, 0.10, 0.03, 1.0, 0.295),\n        (96, 0.22, 0.34, 0.20, 0.10, 0.02, 1.0, 0.12),\n        (96, 0.22, 0.34, 0.50, 0.10, 0.03, 1.0, 0.35),\n    ]\n\n    results = []\n    for params in test_cases:\n        C_LS, C_PF = solve_single_case(params)\n        results.extend([C_LS, C_PF])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2408605"}]}