{"hands_on_practices": [{"introduction": "我们为什么应该使用高阶基函数？本练习通过将高阶基函数应用于一个经典的流体动力学问题，为我们提供了直接的答案。你将使用一个二次有限元来模拟泊肃叶流 (Poiseuille flow)，并发现高阶近似如何能够以惊人的效率和精度捕捉复杂的物理行为 [@problem_id:2399658]。这个练习突显了有限元方法中p-refinement的核心优势。", "problem": "考虑在位于 $y=0$ 和 $y=H$ 的两个平行板之间，沿 $x$ 方向的稳态、完全发展的平面泊肃叶流。设恒定压力梯度为 $g \\equiv -\\mathrm{d}p/\\mathrm{d}x > 0$，动力粘度为 $\\mu > 0$。轴向速度 $u(y)$ 满足一维边值问题\n$$-\\mu \\, u''(y) = g \\quad \\text{对于 } y \\in (0,H), \\qquad u(0)=0, \\quad u(H)=0.$$\n使用标准伽辽金有限元方法 (FEM)，在区间 $[0,H]$ 上采用一个多项式次数为 $p=2$ 的二次单元，并使用与节点 $y=0$、$y=H/2$ 和 $y=H$ 相关联的拉格朗日基函数。在边界节点上强施加本质边界条件。\n\n确定此离散化产生的节点值的三分量向量 $\\big(u(0),\\,u(H/2),\\,u(H)\\big)$。将最终答案以无量纲 $1 \\times 3$ 行向量的形式报告，该向量通过将每个分量除以 $(g H^{2}/\\mu)$ 得到。无需进行数值四舍五入，报告的向量中不应包含任何单位。", "solution": "首先对问题进行验证。\n\n**第一步：提取已知条件**\n- 控制方程：$-\\mu \\, u''(y) = g$，对于 $y \\in (0,H)$。\n- 常数：$g \\equiv -\\mathrm{d}p/\\mathrm{d}x > 0$ 和 $\\mu > 0$。\n- 边界条件：$u(0)=0$，$u(H)=0$。\n- 方法：标准伽辽金有限元方法 (FEM)。\n- 离散化：在域 $[0,H]$ 上使用一个二次单元（$p=2$）。\n- 节点坐标：$y=0$，$y=H/2$，$y=H$。\n- 基函数：与节点相关联的拉格朗日基函数。\n- 边界条件施加方式：在边界节点上强施加。\n- 要求输出：节点值 $\\big(u(0), u(H/2), u(H)\\big)$ 在除以 $(g H^{2}/\\mu)$ 后得到的无量纲 $1 \\times 3$ 行向量。\n\n**第二步：使用提取的已知条件进行验证**\n- **科学依据：** 该问题描述了平面泊肃叶流，这是流体动力学中的一个基本概念。控制方程是针对此流动状态的纳维-斯托克斯方程的有效简化。该问题在科学上是合理的。\n- **适定性：** 该问题是一个带狄利克雷边界条件的一维二阶椭圆边值问题。保证存在唯一且稳定的解。有限元(FEM)列式也是标准的和适定的。\n- **客观性：** 问题陈述使用了精确的数学和物理术语，没有任何主观性或模糊性。\n- **完备性与一致性：** 问题提供了所有必要的信息（控制方程、域、边界条件和离散化细节），并且不包含内部矛盾。\n\n**第三步：结论与行动**\n此问题是有效的。这是一个在计算工程中定义明确的问题，具有科学依据、适定性和完备性。可以推导出严谨的解。\n\n边值问题的弱形式通过将控制方程乘以一个来自合适空间的测试函数 $v(y)$ 并在域 $\\Omega = (0,H)$ 上积分得到。\n$$\n\\int_{0}^{H} -\\mu u''(y) v(y) \\, dy = \\int_{0}^{H} g v(y) \\, dy\n$$\n对左侧应用分部积分得到：\n$$\n\\int_{0}^{H} \\mu u'(y) v'(y) \\, dy - \\big[ \\mu u'(y) v(y) \\big]_{0}^{H} = \\int_{0}^{H} g v(y) \\, dy\n$$\n测试函数 $v(y)$ 必须属于这样一个函数空间：在该空间中积分有定义，并且函数满足齐次本质边界条件，即 $v(0)=0$ 和 $v(H)=0$。因此，边界项 $\\big[ \\mu u'(y) v(y) \\big]_{0}^{H}$ 为零。弱形式为：找到满足本质边界条件的 $u(y)$，使得\n$$\n\\int_{0}^{H} \\mu u'(y) v'(y) \\, dy = \\int_{0}^{H} g v(y) \\, dy\n$$\n对于所有容许的测试函数 $v(y)$ 成立。\n\n在有限元方法中，未知函数 $u(y)$ 由基函数的线性组合近似，即 $u_h(y) = \\sum_{j=1}^{3} U_j N_j(y)$，其中 $U_j$ 是未知的节点值，$N_j(y)$ 是基函数。问题指定了一个在节点 $y_1=0$、$y_2=H/2$ 和 $y_3=H$ 处的二次单元。满足 $N_j(y_i) = \\delta_{ij}$ 的相应拉格朗日基函数为：\n$$\nN_1(y) = \\frac{(y - H/2)(y - H)}{(0 - H/2)(0 - H)} = \\frac{2}{H^2} \\left(y^2 - \\frac{3}{2}Hy + \\frac{H^2}{2}\\right)\n$$\n$$\nN_2(y) = \\frac{(y - 0)(y - H)}{(H/2 - 0)(H/2 - H)} = -\\frac{4}{H^2} (y^2 - Hy)\n$$\n$$\nN_3(y) = \\frac{(y - 0)(y - H/2)}{(H - 0)(H - H/2)} = \\frac{2}{H^2} \\left(y^2 - \\frac{1}{2}Hy\\right)\n$$\n问题指出，本质边界条件 $u(0)=0$ 和 $u(H)=0$ 是强施加的。这意味着边界上的节点值是固定的：$U_1 = u(0) = 0$ 和 $U_3 = u(H) = 0$。速度场的近似简化为 $u_h(y) = U_2 N_2(y)$，因为包含 $N_1(y)$ 和 $N_3(y)$ 的项为零。\n\n在伽辽金方法中，测试函数选自与基函数相同的集合。对于单一未知数 $U_2$，我们只需要一个方程，该方程通过选择测试函数 $v(y) = N_2(y)$ 得到。这是唯一一个在内部节点非零、在边界上为零的基函数。将 $u_h(y)$ 和 $v(y)=N_2(y)$ 代入弱形式，得到：\n$$\n\\int_{0}^{H} \\mu (U_2 N_2'(y)) (N_2'(y)) \\, dy = \\int_{0}^{H} g N_2(y) \\, dy\n$$\n这是一个关于未知数 $U_2$ 的单线性方程：\n$$\n\\left( \\mu \\int_{0}^{H} (N_2'(y))^2 \\, dy \\right) U_2 = g \\int_{0}^{H} N_2(y) \\, dy\n$$\n我们必须计算这两个积分。首先是 $N_2(y)$ 的导数：\n$$\nN_2'(y) = \\frac{d}{dy}\\left(-\\frac{4y^2}{H^2} + \\frac{4y}{H}\\right) = -\\frac{8y}{H^2} + \\frac{4}{H}\n$$\n左侧的积分是：\n$$\n\\int_{0}^{H} (N_2'(y))^2 \\, dy = \\int_{0}^{H} \\left(\\frac{4}{H} - \\frac{8y}{H^2}\\right)^2 \\, dy = \\int_{0}^{H} \\left(\\frac{16}{H^2} - \\frac{64y}{H^3} + \\frac{64y^2}{H^4}\\right) \\, dy\n$$\n$$\n= \\left[ \\frac{16y}{H^2} - \\frac{32y^2}{H^3} + \\frac{64y^3}{3H^4} \\right]_{0}^{H} = \\frac{16}{H} - \\frac{32}{H} + \\frac{64}{3H} = \\left(16 - 32 + \\frac{64}{3}\\right)\\frac{1}{H} = \\left(-16 + \\frac{64}{3}\\right)\\frac{1}{H} = \\frac{-48+64}{3H} = \\frac{16}{3H}\n$$\n右侧的积分是：\n$$\n\\int_{0}^{H} N_2(y) \\, dy = \\int_{0}^{H} \\left(-\\frac{4y^2}{H^2} + \\frac{4y}{H}\\right) \\, dy = \\left[ -\\frac{4y^3}{3H^2} + \\frac{2y^2}{H} \\right]_{0}^{H} = -\\frac{4H}{3} + 2H = \\frac{2H}{3}\n$$\n将这些结果代回到关于 $U_2$ 的方程中：\n$$\n\\left( \\mu \\frac{16}{3H} \\right) U_2 = g \\frac{2H}{3}\n$$\n求解 $U_2$：\n$$\nU_2 = \\frac{g \\cdot 2H/3}{\\mu \\cdot 16/(3H)} = \\frac{2gH}{3} \\cdot \\frac{3H}{16\\mu} = \\frac{6gH^2}{48\\mu} = \\frac{1}{8} \\frac{gH^2}{\\mu}\n$$\n节点值的向量为 $\\big(U_1, U_2, U_3\\big) = \\left(0, \\frac{1}{8}\\frac{gH^2}{\\mu}, 0\\right)$。\n为了得到所需的无量纲向量，将每个分量除以缩放因子 $(gH^2/\\mu)$：\n$$\n\\left( \\frac{0}{gH^2/\\mu}, \\frac{\\frac{1}{8}gH^2/\\mu}{gH^2/\\mu}, \\frac{0}{gH^2/\\mu} \\right) = \\left(0, \\frac{1}{8}, 0\\right)\n$$\n这个结果是精确的，因为该问题的解析解 $u(y) = \\frac{g}{2\\mu}(Hy - y^2)$ 是一个二次多项式，可以由离散化中使用的二次基函数精确表示。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0 & \\frac{1}{8} & 0\n\\end{pmatrix}\n}\n$$", "id": "2399658"}, {"introduction": "高阶方法的威力依赖于精确的计算，尤其是在通过数值积分构建系统矩阵时。本实践探讨了当积分不够精确时会发生什么，即一种被称为“混叠误差”(aliasing error) 的现象。通过研究使用不充分求积点对勒让德 (Legendre) 多项式进行积分的情况 [@problem_id:2399644]，您将亲身体会到为何选择恰当的求积法则是任何高阶数值方案成功的关键。", "problem": "您的任务是研究在一维情况下，使用高阶基函数时因积分不足（under-integration）而产生的混叠误差（aliasing error）。考虑区间 $[-1,1]$ 上的 $p$ 次 Legendre 多项式，记为 $P_{p}(x)$，其中 $P_{0}(x)=1$ 且 $P_{p}(x)$ 满足标准的 Legendre 多项式三项递推关系。内积是 $[-1,1]$ 上权重为 $1$ 的标准 $L^{2}$ 内积。多项式 $P_{p}(x)$ 的次数为 $p$。在 $[-1,1]$ 上使用 $n$ 个 Gauss–Legendre 点的 Gaussian Quadrature (GQ) 对次数最高为 $2n-1$ 的所有多项式都是精确的。\n\n您的任务是编写一个程序来：\n- 基于 $P_{p}(x)$ 的正交性和归一化，通过解析推理计算积分 $\\int_{-1}^{1} \\left(P_{p}(x)\\right)^{2}\\,dx$ 的精确值。\n- 使用 $[-1,1]$ 上的 $n$ 点 Gauss–Legendre 求积法来近似计算同一个积分。\n- 将绝对混叠误差量化为求积近似值与精确值之间的绝对差。\n\n推导的基本依据：\n- Legendre 多项式 $\\{P_{k}(x)\\}_{k\\ge 0}$ 构成 $[-1,1]$ 上关于权重 $1$ 的一个正交基。\n- $n$ 点 Gauss–Legendre 求积法对次数最高为 $2n-1$ 的所有多项式都是精确的。\n\n在一个独立的、自包含的程序中实现该算法。对于解析值，不使用任何数值积分；仅使用从 $P_{p}(x)$ 作为 $L^{2}([-1,1])$ 中的基的正交性和归一化性质得出的属性。\n\n测试套件：\n- 使用以下 $(p,n)$ 对来检验一般、精确和积分不足（混叠）的场景：$(p,n)\\in\\{(0,1),(1,1),(1,2),(3,3),(3,4),(5,5),(5,6),(10,5),(10,11)\\}$。\n- 对于每一对 $(p,n)$，计算绝对误差 $E(p,n)=\\left|\\;\\text{GQ}_{n}\\left[\\int_{-1}^{1}\\left(P_{p}(x)\\right)^{2}\\,dx\\right]-\\int_{-1}^{1}\\left(P_{p}(x)\\right)^{2}\\,dx\\;\\right|$。\n- 将每个 $E(p,n)$ 报告为一个四舍五入到 $12$ 位小数的浮点数。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表的结果（例如，[$r_{1}$,$r_{2}$,$r_{3}$]），其顺序与上述测试套件的顺序相同。\n- 不应打印任何附加文本。\n\n角度单位不适用。不涉及物理单位。所有计算都是无量纲的。程序不得要求任何用户输入或外部文件，并且必须在标准环境中确定性地运行。", "solution": "我们从适用于一维高阶基函数的基本原理开始，具体来说是 Legendre 多项式和 Gaussian Quadrature (GQ)。Legendre 多项式 $\\{P_{p}(x)\\}_{p\\ge 0}$ 构成了在 $[-1,1]$ 上关于权重函数 $w(x)=1$ 的平方可积函数的完备正交基。正交性意味着对于整数 $p\\neq q$，\n$$\n\\int_{-1}^{1} P_{p}(x)\\,P_{q}(x)\\,dx=0.\n$$\n此外，$P_{p}(x)$ 是一个 $p$ 次多项式，按照惯例 $P_{0}(x)=1$ 和 $P_{p}(1)=1$ 进行归一化。$P_{p}$ 在 $[-1,1]$ 上的精确 $L^{2}$ 范数平方由经过充分检验的标准恒等式给出\n$$\n\\int_{-1}^{1} \\left(P_{p}(x)\\right)^{2}\\,dx=\\frac{2}{2p+1}.\n$$\n这个归一化常数可以通过 Rodrigues 公式和分部积分法来证明。Rodrigues 公式表述为\n$$\nP_{p}(x)=\\frac{1}{2^{p}p!}\\frac{d^{p}}{dx^{p}}\\left(x^{2}-1\\right)^{p}.\n$$\n那么\n$$\n\\int_{-1}^{1}\\left(P_{p}(x)\\right)^{2}\\,dx=\\frac{1}{(2^{p}p!)^{2}}\\int_{-1}^{1}\\left[\\frac{d^{p}}{dx^{p}}\\left(x^{2}-1\\right)^{p}\\right]P_{p}(x)\\,dx.\n$$\n进行 $p$ 次分部积分，将导数从 $\\left(x^{2}-1\\right)^{p}$ 移到 $P_{p}(x)$ 上，边界项的贡献为零，因为 $\\left(x^{2}-1\\right)^{p}$ 在 $x=\\pm 1$ 处有 $p$ 阶零点。这得到\n$$\n\\int_{-1}^{1}\\left(P_{p}(x)\\right)^{2}\\,dx=\\frac{1}{(2^{p}p!)^{2}}\\int_{-1}^{1}\\left(x^{2}-1\\right)^{p}\\frac{d^{p}}{dx^{p}}P_{p}(x)\\,dx.\n$$\n由于 $P_{p}(x)$ 是一个 $p$ 次多项式，其首项系数为 $\\frac{1}{2^{p}}\\binom{2p}{p}$，它的 $p$ 阶导数是常数\n$$\n\\frac{d^{p}}{dx^{p}}P_{p}(x)=p!\\cdot\\frac{1}{2^{p}}\\binom{2p}{p}=\\frac{(2p)!}{2^{p}p!}.\n$$\n因此，\n$$\n\\int_{-1}^{1}\\left(P_{p}(x)\\right)^{2}\\,dx=\\frac{1}{(2^{p}p!)^{2}}\\cdot\\frac{(2p)!}{2^{p}p!}\\int_{-1}^{1}\\left(x^{2}-1\\right)^{p}\\,dx.\n$$\n使用被积函数的偶数性质、Beta 函数恒等式或直接求值，可以得到封闭形式\n$$\n\\int_{-1}^{1}\\left(P_{p}(x)\\right)^{2}\\,dx=\\frac{2}{2p+1}.\n$$\n这个精确值将作为解析基准。\n\n接下来，考虑 $[-1,1]$ 上的 $n$ 点 Gauss–Legendre 求积法。Gauss–Legendre 求积法的一个基本性质是对于次数最高为 $2n-1$ 的多项式是精确的。函数 $f(x)=\\left(P_{p}(x)\\right)^{2}$ 是一个 $2p$ 次多项式。因此：\n- 如果 $2p\\le 2n-1$，即 $n\\ge p+1$，则求积法对 $f$ 是精确的，数值积分在舍入误差范围内等于解析值 $\\frac{2}{2p+1}$。\n- 如果 $2p>2n-1$，即 $n\\le p$，则求积法对 $f$ 积分不足。在这种积分不足的情况下，求积法则无法精确表示 $f$ 的高次分量，这些分量在离散意义上会有效地混叠到低次模式中。这就是混叠误差：求积返回的是 $f$ 在次数最高为 $2n-1$ 的多项式空间中的最佳逼近的精确积分，而不是 $f$ 的真实积分。\n\n算法计划：\n- 对于给定的整数 $p$ 和 $n$，定义 $f(x)=\\left(P_{p}(x)\\right)^{2}$。\n- 计算精确值 $I_{\\text{exact}}(p)=\\frac{2}{2p+1}$。\n- 计算 $[-1,1]$ 上的 $n$ 点 Gauss–Legendre 求积节点 $\\{x_{i}\\}_{i=1}^{n}$ 和权重 $\\{w_{i}\\}_{i=1}^{n}$。计算\n$$\nI_{\\text{GQ}}(p,n)=\\sum_{i=1}^{n}w_{i}\\,f(x_{i}).\n$$\n- 报告绝对误差 $E(p,n)=\\left|I_{\\text{GQ}}(p,n)-I_{\\text{exact}}(p)\\right|$。\n\n实现细节：\n- 使用一个稳定的 Legendre 多项式基函数求值例程来计算 $P_{p}(x)$；在代码中，可以使用一个基表示和求值函数来计算 $P_{p}(x)$。\n- 以编程方式获取 Gauss–Legendre 节点和权重。\n- 对于测试套件 $(p,n)\\in\\{(0,1),(1,1),(1,2),(3,3),(3,4),(5,5),(5,6),(10,5),(10,11)\\}$，计算 $E(p,n)$ 并按顺序打印它们，每个都四舍五入到 $12$ 位小数，作为一个单一的、用方括号括起来的逗号分隔列表。\n\n预期的定性行为：\n- 对于 $n\\ge p+1$ 的情况，产生的误差应接近机器精度，在四舍五入到 $12$ 位小数时约为 $0$。\n- 对于 $n\\le p$ 的情况，由于 $2p>2n-1$，会表现出非零的混叠误差。\n\n这种方法将高阶基函数 $P_{p}(x)$、Gaussian Quadrature 的精确度性质以及当求积阶数不足以精确积分基函数平方时混叠误差的出现直接联系起来。", "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss, legval\n\ndef legendre_P(p, x):\n    \"\"\"\n    Evaluate the Legendre polynomial P_p(x) at x using numpy's Legendre basis.\n    \"\"\"\n    # Coefficients in the Legendre basis: c[k] corresponds to P_k(x).\n    c = np.zeros(p + 1, dtype=float)\n    c[p] = 1.0\n    return legval(x, c)\n\ndef exact_integral_Pp_squared(p):\n    \"\"\"\n    Exact value of the integral of (P_p(x))^2 over [-1,1]:\n        ∫_{-1}^{1} (P_p(x))^2 dx = 2 / (2p + 1)\n    \"\"\"\n    return 2.0 / (2 * p + 1)\n\ndef gauss_legendre_integral_Pp_squared(p, n):\n    \"\"\"\n    Compute the n-point Gauss-Legendre quadrature of (P_p(x))^2 over [-1,1].\n    \"\"\"\n    x, w = leggauss(n)\n    P_vals = legendre_P(p, x)\n    f_vals = P_vals * P_vals\n    return np.dot(w, f_vals)\n\ndef solve():\n    # Define the test cases (p, n) as specified in the problem statement.\n    test_cases = [\n        (0, 1),\n        (1, 1),\n        (1, 2),\n        (3, 3),\n        (3, 4),\n        (5, 5),\n        (5, 6),\n        (10, 5),\n        (10, 11),\n    ]\n\n    results = []\n    for p, n in test_cases:\n        I_exact = exact_integral_Pp_squared(p)\n        I_quad = gauss_legendre_integral_Pp_squared(p, n)\n        err = abs(I_quad - I_exact)\n        # Round to 12 decimal places as required\n        results.append(f\"{err:.12f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2399644"}, {"introduction": "尽管高阶多项式基函数在处理光滑问题时非常强大，但在逼近具有阶跃等剧烈变化的函数时会面临挑战。本练习将指导您将一个阶跃函数投影到多项式基上，并观察由此产生的“吉布斯现象”(Gibbs phenomenon)——在不连续点附近出现的持续过冲 [@problem_id:2399650]。这项实践为了解全局多项式逼近的局限性提供了重要的洞见，并强调了将逼近方法与问题本身的光滑度相匹配的重要性。", "problem": "您将编写一个完整、可运行的程序，构建一个不连续函数在一维多项式子空间上的平方可积（勒贝格 $L^2$）正交投影，并量化在不连续点附近产生的类吉布斯过冲随多项式次数的变化。在参考区间 $[-1,1]$ 上进行计算。考虑阶跃函数 $f:[-1,1]\\to\\mathbb{R}$，定义为当 $x<0$ 时 $f(x)=0$，当 $x\\ge 0$ 时 $f(x)=1$。对于给定的非负整数次数 $p$，将多项式子空间 $\\mathcal{P}_p$ 定义为所有次数至多为 $p$ 的实多项式的集合。在 $[-1,1]$ 上使用等于 $1$ 的权函数，将 $f$ 的 $L^2$ 投影 $u_p\\in \\mathcal{P}_p$ 定义为在所有 $u\\in\\mathcal{P}_p$ 中使 $L^2$ 误差 $\\|f-u\\|_{L^2([-1,1])}$ 最小化的唯一元素。将 $u_p$ 在勒让德多项式 $\\{P_n\\}_{n=0}^p$ 的模态基中表示，这些多项式在 $[-1,1]$ 上关于单位权的 $L^2$ 内积是正交的。仅从勒让德多项式的正交性和 $L^2$ 投影的定义出发，推导 $u_p$ 在此基下的系数。请勿使用任何预先推导的投影公式；推导过程必须遵循正交关系和投影的定义。然后，在一个均匀网格上计算 $u_p$ 的值，以测量在 $x=0$ 跳变点附近的类吉布斯过冲。对于固定的窗口半宽 $w=0.2$，定义右邻域 $\\Omega_R=(0,w]$ 和左邻域 $\\Omega_L=[-w,0)$。在一个覆盖 $[-w,w]$ 的包含 $M=20001$ 个点的均匀网格上，计算过冲幅度\n$$\n\\Gamma_p=\\max\\left\\{\\max_{x\\in\\Omega_R}\\left(u_p(x)-1\\right),\\ \\max_{x\\in\\Omega_L}\\left(-u_p(x)\\right),\\ 0\\right\\}。\n$$\n您的程序必须对指定测试集中的每个次数 $p$ 执行以下步骤：通过 $L^2$ 投影到勒让德基中的 $\\mathcal{P}_p$ 来构造 $u_p$，在指定的网格上计算 $u_p$，并计算如上定义的 $\\Gamma_p$。使用以下多项式次数的测试集：$\\{0,1,3,5,10,20\\}$。所有计算都是无量纲的，不涉及物理单位。最终输出格式必须是单行，包含一个 Python 浮点数值列表 $[\\Gamma_{p_1},\\Gamma_{p_2},\\dots]$，其顺序与次数 $[0,1,3,5,10,20]$ 相对应。您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[r_1,r_2,r_3,r_4,r_5,r_6]$）。每个 $p$ 的结果必须是一个浮点数。通过遵循上述精确定义来确保科学真实性，并设计您的计算过程，使其在指定的网格参数 $w=0.2$ 和 $M=20001$ 个点下是数值稳定且可复现的。该算法必须能够从勒让德多项式的正交性和 $L^2$ 投影的定义推导得出，不得在问题陈述中引入任何外部的简化公式。", "solution": "该问题要求构造和分析一个不连续函数在一维多项式空间上的 $L^2$ 正交投影。目的是量化吉布斯现象，特别是当多项式次数 $p$ 变化时，在 $x=0$ 不连续点附近的过冲。\n\n待近似的函数是阶跃函数 $f:[-1,1] \\to \\mathbb{R}$，定义为\n$$\nf(x) = \\begin{cases} 0 & \\text{if } x < 0 \\\\ 1 & \\text{if } x \\ge 0 \\end{cases}\n$$\n我们寻求其在次数至多为 $p$ 的多项式子空间 $\\mathcal{P}_p$ 上的 $L^2$ 投影，记为 $u_p$。空间 $\\mathcal{P}_p$ 是希尔伯特空间 $L^2([-1, 1])$ 的一个子空间，该空间配备了内积 $(g, h) = \\int_{-1}^{1} g(x)h(x)dx$ 和范数 $\\|g\\|_{L^2} = \\sqrt{(g, g)}$。根据定义，投影 $u_p \\in \\mathcal{P}_p$ 是在所有可能的 $u_p \\in \\mathcal{P}_p$ 中使误差范数 $\\|f-u_p\\|_{L^2}$ 最小化的唯一元素。\n\n$L^2$ 投影的一个基本性质是误差向量 $f-u_p$ 与子空间 $\\mathcal{P}_p$ 正交。这被称为伽辽金正交条件：\n$$\n(f - u_p, v) = 0, \\quad \\forall v \\in \\mathcal{P}_p.\n$$\n我们将近似 $u_p(x)$ 在勒让德多项式基 $\\{P_n(x)\\}_{n=0}^p$ 中表示，这些多项式在区间 $[-1, 1]$ 上对于单位权函数是正交的。展开式为\n$$\nu_p(x) = \\sum_{n=0}^{p} \\hat{f}_n P_n(x),\n$$\n其中系数 $\\{\\hat{f}_n\\}_{n=0}^p$ 有待确定。由于勒让德多项式 $\\{P_k(x)\\}_{k=0}^p$ 构成了 $\\mathcal{P}_p$ 的一个基，伽辽金条件当且仅当误差与每个基函数正交时才满足：\n$$\n(f - u_p, P_k) = 0, \\quad \\text{for } k=0, 1, \\dots, p.\n$$\n将 $u_p$ 的展开式代入此方程，我们得到：\n$$\n\\left(f - \\sum_{n=0}^{p} \\hat{f}_n P_n, P_k\\right) = 0.\n$$\n根据内积的线性性：\n$$\n(f, P_k) - \\sum_{n=0}^{p} \\hat{f}_n (P_n, P_k) = 0.\n$$\n现在我们引用勒让德多项式的正交关系：\n$$\n(P_n, P_k) = \\int_{-1}^{1} P_n(x) P_k(x) dx = \\frac{2}{2n+1}\\delta_{nk},\n$$\n其中 $\\delta_{nk}$ 是克罗内克δ函数。由于只有当 $n=k$ 时项才非零，所以求和式得以简化：\n$$\n(f, P_k) - \\hat{f}_k (P_k, P_k) = 0 \\implies (f, P_k) - \\hat{f}_k \\frac{2}{2k+1} = 0.\n$$\n解出系数 $\\hat{f}_k$ 即可得到投影系数的通用公式：\n$$\n\\hat{f}_k = \\frac{2k+1}{2} (f, P_k) = \\frac{2k+1}{2} \\int_{-1}^{1} f(x)P_k(x) dx.\n$$\n此推导直接源于 $L^2$ 投影的定义和基的正交性，符合问题陈述的要求。\n\n接下来，我们计算指定阶跃函数 $f(x)$ 的系数。积分变为：\n$$\n\\int_{-1}^{1} f(x)P_k(x) dx = \\int_{-1}^{0} (0) \\cdot P_k(x) dx + \\int_{0}^{1} (1) \\cdot P_k(x) dx = \\int_{0}^{1} P_k(x) dx.\n$$\n因此，系数由 $\\hat{f}_k = \\frac{2k+1}{2} \\int_{0}^{1} P_k(x) dx$ 给出。为计算此积分，我们使用对于 $k \\ge 1$ 成立的勒让德多项式恒等式：$(2k+1)P_k(x) = P'_{k+1}(x) - P'_{k-1}(x)$。从 $0$ 积分到 $1$：\n$$\n\\int_{0}^{1} (2k+1)P_k(x) dx = \\left[ P_{k+1}(x) - P_{k-1}(x) \\right]_0^1.\n$$\n$$\n(2k+1)\\int_{0}^{1} P_k(x) dx = (P_{k+1}(1) - P_{k-1}(1)) - (P_{k+1}(0) - P_{k-1}(0)).\n$$\n使用对所有 $n \\ge 0$ 成立的性质 $P_n(1) = 1$，第一项消失：$1-1=0$。这对于 $k \\ge 1$ 给出：\n$$\n\\int_{0}^{1} P_k(x) dx = \\frac{P_{k-1}(0) - P_{k+1}(0)}{2k+1}.\n$$\n将此结果代回 $\\hat{f}_k$ 的公式：\n$$\n\\hat{f}_k = \\frac{2k+1}{2} \\left(\\frac{P_{k-1}(0) - P_{k+1}(0)}{2k+1}\\right) = \\frac{P_{k-1}(0) - P_{k+1}(0)}{2}, \\quad \\text{for } k \\ge 1.\n$$\n对于基本情况 $k=0$，我们直接计算：\n$$\n\\hat{f}_0 = \\frac{2(0)+1}{2} \\int_{0}^{1} P_0(x) dx = \\frac{1}{2} \\int_{0}^{1} 1 dx = \\frac{1}{2}.\n$$\n我们还知道，对于所有奇数 $n$，$P_n(0) = 0$。因此，对于偶数索引 $k \\ge 2$, $k-1$ 和 $k+1$ 都是奇数，这意味着 $P_{k-1}(0)=0$ 和 $P_{k+1}(0)=0$。所以，对于所有偶数 $k \\ge 2$，$\\hat{f}_k = 0$。\n总结来说，系数为：\n$$\n\\hat{f}_k = \\begin{cases} 1/2 & \\text{if } k = 0 \\\\ 0 & \\text{if } k \\ge 2 \\text{ is even} \\\\ \\frac{P_{k-1}(0) - P_{k+1}(0)}{2} & \\text{if } k \\text{ is odd} \\end{cases}\n$$\n有了这些系数，对于任何次数 $p$，多项式近似 $u_p(x)$ 就被完全定义了。\n\n最后一步是为给定的次数 $p \\in \\{0, 1, 3, 5, 10, 20\\}$ 量化过冲幅度 $\\Gamma_p$。在区间 $[-w, w]$（其中 $w=0.2$）上生成一个包含 $M=20001$ 个点的均匀网格。在该网格的每个点上计算近似值 $u_p(x)$。然后根据以下公式计算过冲：\n$$\n\\Gamma_p=\\max\\left\\{\\max_{x\\in\\Omega_R}\\left(u_p(x)-1\\right),\\ \\max_{x\\in\\Omega_L}\\left(-u_p(x)\\right),\\ 0\\right\\},\n$$\n其中 $\\Omega_R=(0, w]$ 和 $\\Omega_L=[-w, 0)$。在最终答案中实现的算法计算这些系数，为每个指定的次数构造 $u_p(x)$，在网格上对其求值，并通过寻找不连续点左右邻域中的最大偏差来计算 $\\Gamma_p$。在外层 $\\max$ 函数中包含 $0$ 可确保在出现下冲（或无过冲）的情况下，报告值为 $0$。", "answer": "```python\nimport numpy as np\nfrom scipy.special import eval_legendre\nfrom numpy.polynomial.legendre import Legendre\n\ndef solve():\n    \"\"\"\n    Computes the Gibbs-like overshoot for the L2 projection of a step function\n    onto polynomial subspaces of varying degrees.\n    \"\"\"\n    # Define the test cases (polynomial degrees) from the problem statement.\n    test_cases = [0, 1, 3, 5, 10, 20]\n\n    # Grid parameters for overshoot evaluation\n    w = 0.2\n    M = 20001\n    \n    # Generate the grid on which the approximation is evaluated.\n    x_grid = np.linspace(-w, w, M)\n    results = []\n\n    for p in test_cases:\n        # Step 1: Compute coefficients of the L2 projection in the Legendre basis.\n        # This implementation follows the derivation from first principles.\n        coeffs = np.zeros(p + 1)\n        \n        # Coefficient for k=0 is always 0.5 for this step function.\n        coeffs[0] = 0.5\n        \n        # Coefficients for k > 0.\n        if p > 0:\n            for k in range(1, p + 1):\n                if k % 2 == 1:  # k is odd\n                    # Formula from derivation: f_hat_k = (P_{k-1}(0) - P_{k+1}(0)) / 2\n                    p_km1_at_0 = eval_legendre(k - 1, 0)\n                    p_kp1_at_0 = eval_legendre(k + 1, 0)\n                    coeffs[k] = (p_km1_at_0 - p_kp1_at_0) / 2.0\n                else:  # k is even and k >= 2. The coefficient is 0.\n                    coeffs[k] = 0.0\n        \n        # Step 2: Construct the polynomial approximation u_p(x) using the coefficients.\n        # The Legendre class from numpy.polynomial creates a callable polynomial object.\n        u_p = Legendre(coeffs, domain=[-1, 1])\n        \n        # Step 3: Evaluate u_p on the specified grid near the discontinuity.\n        u_p_vals = u_p(x_grid)\n        \n        # Step 4: Compute the overshoot magnitude Gamma_p.\n        # The problem defines Omega_R = (0, w] and Omega_L = [-w, 0).\n        # Using boolean masks correctly partitions the grid according to these definitions.\n        \n        # Right-neighborhood Omega_R = (0, w]\n        mask_R = x_grid > 0\n        u_p_R = u_p_vals[mask_R]\n        \n        if u_p_R.size > 0:\n            overshoot_R = np.max(u_p_R - 1.0)\n        else:\n            # This case would occur if the grid had no points > 0.\n            overshoot_R = -np.inf\n\n        # Left-neighborhood Omega_L = [-w, 0)\n        mask_L = x_grid  0\n        u_p_L = u_p_vals[mask_L]\n        \n        if u_p_L.size > 0:\n            overshoot_L = np.max(-u_p_L)\n        else:\n            # This case would occur if the grid had no points  0.\n            overshoot_L = -np.inf\n        \n        # Gamma_p is the maximum of the right overshoot, left overshoot, and zero.\n        # The max with zero ensures no negative value is reported (i.e., accounts for undershoot).\n        gamma_p = np.max([overshoot_R, overshoot_L, 0.0])\n        results.append(gamma_p)\n\n    # Final print statement must be in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2399650"}]}