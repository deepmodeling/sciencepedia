{"hands_on_practices": [{"introduction": "B样条和贝塞尔曲线是几何造型领域的两大基石，在计算机辅助设计和图形学中无处不在。理解它们之间的转换关系不仅对于确保不同系统间的互操作性至关重要，更能帮助我们深入洞察其内在结构。本练习 [@problem_id:2372217] 将引导您从第一性原理出发，推导出将一段三次均匀B样条转换为等效贝塞尔曲线的变换矩阵，这是一个巩固您对两种基函数理解的绝佳机会。", "problem": "一条具有开放均匀节点矢量和单位间距的三次B样条曲线，用于在计算工程流程中近似一个光滑轮廓。考虑一个内部节点区间 $\\left[u_k, u_{k+1}\\right]$，其中 $u_{k+1} - u_k = 1$。设此区间上的曲线段可以写成两种等价形式：\n- 作为使用 $4$ 个控制点 $\\boldsymbol{P}_{k-3}, \\boldsymbol{P}_{k-2}, \\boldsymbol{P}_{k-1}, \\boldsymbol{P}_{k}$ 和非零基函数 $N_{k-3,3}(u), \\dots, N_{k,3}(u)$ 的 $3$ 次B样条曲线段。\n- 作为使用 $4$ 个Bézier控制点 $\\boldsymbol{Q}_0, \\boldsymbol{Q}_1, \\boldsymbol{Q}_2, \\boldsymbol{Q}_3$ 和 $3$ 次Bernstein多项式的三次Bézier曲线。\n\n仅从B样条基函数的Cox–de Boor递推公式和Bernstein多项式的基本定义出发，按以下步骤进行：\n- 使用 $s = u - u_k$ 将该区间重新参数化为 $s \\in [0,1]$。\n- 推导此区间上 $4$ 个非零三次均匀B样条基函数在 $[0,1]$ 上的多项式形式。\n- 将B样条和Bézier表示都表示在单项式幂基 $\\left[s^3, s^2, s, 1\\right]$ 中，以获得它们各自的 $4 \\times 4$ 基矩阵。\n- 从基本定义出发，推导 $4 \\times 4$ 线性变换矩阵 $\\boldsymbol{T}$，使得\n$$\n\\begin{pmatrix}\n\\boldsymbol{Q}_0 \\\\ \\boldsymbol{Q}_1 \\\\ \\boldsymbol{Q}_2 \\\\ \\boldsymbol{Q}_3\n\\end{pmatrix}\n=\n\\boldsymbol{T}\n\\begin{pmatrix}\n\\boldsymbol{P}_{k-3} \\\\ \\boldsymbol{P}_{k-2} \\\\ \\boldsymbol{P}_{k-1} \\\\ \\boldsymbol{P}_k\n\\end{pmatrix}.\n$$\n\n请给出您最终的答案，形式为一个具有有理数元素的单一显式 $4 \\times 4$ 矩阵。除了基本定义外，不要使用任何预先制表的转换公式或结果。最终答案必须是单一的闭合形式表达式。无需四舍五入。", "solution": "所述问题是有效的。它在科学上基于计算几何的原理，特别是B样条和Bézier曲线的理论。该问题是适定的、客观的，并包含从第一性原理推导出唯一解所需的所有必要信息。我们接下来进行推导。\n\n目标是找到线性变换矩阵 $\\boldsymbol{T}$，该矩阵将一组四个均匀三次B样条控制点 $\\{\\boldsymbol{P}_{k-3}, \\boldsymbol{P}_{k-2}, \\boldsymbol{P}_{k-1}, \\boldsymbol{P}_{k}\\}$ 映射到一组四个等价的三次Bézier控制点 $\\{\\boldsymbol{Q}_0, \\boldsymbol{Q}_1, \\boldsymbol{Q}_2, \\boldsymbol{Q}_3\\}$。曲线段定义在节点区间 $[u_k, u_{k+1}]$ 上，通过 $s = u - u_k$ 重新参数化到区间 $[0,1]$。\n\n对于 $s \\in [0,1]$ 的曲线段 $\\boldsymbol{C}(s)$ 可以用两种形式表示：\n$1$. 作为B样条段：$\\boldsymbol{C}(s) = \\sum_{i=0}^{3} \\boldsymbol{P}_{k-3+i} b_i(s)$，其中 $b_i(s) = N_{k-3+i, 3}(u)$ 是在该区间上求值的B样条基函数。\n$2$. 作为Bézier段：$\\boldsymbol{C}(s) = \\sum_{j=0}^{3} \\boldsymbol{Q}_j B_{j,3}(s)$，其中 $B_{j,3}(s)$ 是Bernstein基多项式。\n\n两种表示都可以使用单项式基 $[s^3, s^2, s, 1]$ 写成矩阵形式。设 $\\boldsymbol{S}(s) = \\begin{pmatrix} s^3 & s^2 & s & 1 \\end{pmatrix}$。\n那么，\n$$ \\boldsymbol{C}(s) = \\boldsymbol{S}(s) \\boldsymbol{M}_{B-spline} \\begin{pmatrix} \\boldsymbol{P}_{k-3} \\\\ \\boldsymbol{P}_{k-2} \\\\ \\boldsymbol{P}_{k-1} \\\\ \\boldsymbol{P}_k \\end{pmatrix} = \\boldsymbol{S}(s) \\boldsymbol{M}_{Bezier} \\begin{pmatrix} \\boldsymbol{Q}_0 \\\\ \\boldsymbol{Q}_1 \\\\ \\boldsymbol{Q}_2 \\\\ \\boldsymbol{Q}_3 \\end{pmatrix} $$\n由于单项式基是线性无关的，$\\boldsymbol{S}(s)$ 的系数必须相等：\n$$ \\boldsymbol{M}_{B-spline} \\begin{pmatrix} \\boldsymbol{P}_{k-3} \\\\ \\boldsymbol{P}_{k-2} \\\\ \\boldsymbol{P}_{k-1} \\\\ \\boldsymbol{P}_k \\end{pmatrix} = \\boldsymbol{M}_{Bezier} \\begin{pmatrix} \\boldsymbol{Q}_0 \\\\ \\boldsymbol{Q}_1 \\\\ \\boldsymbol{Q}_2 \\\\ \\boldsymbol{Q}_3 \\end{pmatrix} $$\n由此，我们可以解出Bézier控制点：\n$$ \\begin{pmatrix} \\boldsymbol{Q}_0 \\\\ \\boldsymbol{Q}_1 \\\\ \\boldsymbol{Q}_2 \\\\ \\boldsymbol{Q}_3 \\end{pmatrix} = (\\boldsymbol{M}_{Bezier})^{-1} \\boldsymbol{M}_{B-spline} \\begin{pmatrix} \\boldsymbol{P}_{k-3} \\\\ \\boldsymbol{P}_{k-2} \\\\ \\boldsymbol{P}_{k-1} \\\\ \\boldsymbol{P}_k \\end{pmatrix} $$\n因此，所求的变换矩阵是 $\\boldsymbol{T} = (\\boldsymbol{M}_{Bezier})^{-1} \\boldsymbol{M}_{B-spline}$。我们现在将从其基本定义推导矩阵 $\\boldsymbol{M}_{B-spline}$ 和 $\\boldsymbol{M}_{Bezier}$。\n\n步骤1：推导均匀三次B样条基函数\n我们使用 $p$ 次B样条基函数的Cox-de Boor递推公式：\n$$ N_{i,p}(u) = \\frac{u-u_i}{u_{i+p}-u_i}N_{i,p-1}(u) + \\frac{u_{i+p+1}-u}{u_{i+p+1}-u_{i+1}}N_{i+1,p-1}(u) $$\n其中，如果 $u_i \\le u < u_{i+1}$，则 $N_{i,0}(u) = 1$，否则为 $0$。\n对于具有单位间距的均匀节点矢量，不失一般性地，我们可以设 $u_i = i$。递推公式简化为：\n$$ N_{i,p}(u) = \\frac{u-i}{p}N_{i,p-1}(u) + \\frac{i+p+1-u}{p}N_{i+1,p-1}(u) $$\n我们感兴趣的是区间 $[u_k, u_{k+1}] = [k, k+1]$，由 $s = u-k \\in [0,1]$ 参数化，因此 $u=s+k$。\n此区间上四个非零三次 ($p=3$) 基函数是 $N_{k-3,3}(u), N_{k-2,3}(u), N_{k-1,3}(u), N_{k,3}(u)$。我们将其重新参数化后的形式记为 $b_0(s), b_1(s), b_2(s), b_3(s)$。我们从0次开始构建它们。\n\n在 $u \\in [k, k+1)$ 上，唯一的非零0次基函数是 $N_{k,0}(u)=1$。对于1次，支撑集与此区间重叠的函数是 $N_{k-1,1}(u) = k+1-u = 1-s$ 和 $N_{k,1}(u) = u-k = s$。\n\n对于2次 ($p=2$):\n$N_{k-2,2}(u) = \\frac{u-(k-2)}{2}N_{k-2,1}(u) + \\frac{k+1-u}{2}N_{k-1,1}(u) = 0 + \\frac{1-s}{2}(1-s) = \\frac{1}{2}(1-s)^2$.\n$N_{k-1,2}(u) = \\frac{u-(k-1)}{2}N_{k-1,1}(u) + \\frac{k+2-u}{2}N_{k,1}(u) = \\frac{s+1}{2}(1-s) + \\frac{2-s}{2}(s) = \\frac{1}{2}(-2s^2+2s+1)$.\n$N_{k,2}(u) = \\frac{u-k}{2}N_{k,1}(u) + \\frac{k+3-u}{2}N_{k+1,1}(u) = \\frac{s}{2}(s) + 0 = \\frac{1}{2}s^2$.\n\n对于3次 ($p=3$):\n$b_0(s) = N_{k-3,3}(u) = \\frac{k+1-u}{3}N_{k-2,2}(u) = \\frac{1-s}{3} \\frac{(1-s)^2}{2} = \\frac{1}{6}(1-s)^3 = \\frac{1}{6}(-s^3+3s^2-3s+1)$.\n$b_1(s) = N_{k-2,3}(u) = \\frac{u-(k-2)}{3}N_{k-2,2}(u) + \\frac{k+2-u}{3}N_{k-1,2}(u) = \\frac{s+2}{3}\\frac{(1-s)^2}{2} + \\frac{2-s}{3}\\frac{-2s^2+2s+1}{2} = \\frac{1}{6}(3s^3-6s^2+4)$.\n$b_2(s) = N_{k-1,3}(u) = \\frac{u-(k-1)}{3}N_{k-1,2}(u) + \\frac{k+3-u}{3}N_{k,2}(u) = \\frac{s+1}{3}\\frac{-2s^2+2s+1}{2} + \\frac{3-s}{3}\\frac{s^2}{2} = \\frac{1}{6}(-3s^3+3s^2+3s+1)$.\n$b_3(s) = N_{k,3}(u) = \\frac{u-k}{3}N_{k,2}(u) = \\frac{s}{3}\\frac{s^2}{2} = \\frac{1}{6}s^3$.\n\nB样条基矩阵 $\\boldsymbol{M}_{B-spline}$ 由这些多项式在基 $[s^3, s^2, s, 1]$ 中的系数构成。第 $j$ 列对应于 $b_{j-1}(s)$。\n$$ \\boldsymbol{M}_{B-spline} = \\frac{1}{6} \\begin{pmatrix} -1 & 3 & -3 & 1 \\\\ 3 & -6 & 0 & 0 \\\\ -3 & 3 & 3 & 0 \\\\ 1 & 4 & 1 & 0 \\end{pmatrix} $$\n\n步骤2：推导Bézier基矩阵\n三次Bernstein基多项式定义为 $B_{i,3}(s) = \\binom{3}{i} s^i (1-s)^{3-i}$，其中 $i=0,1,2,3$。\n$B_{0,3}(s) = (1-s)^3 = -s^3 + 3s^2 - 3s + 1$.\n$B_{1,3}(s) = 3s(1-s)^2 = 3s^3 - 6s^2 + 3s$.\n$B_{2,3}(s) = 3s^2(1-s) = -3s^3 + 3s^2$.\n$B_{3,3}(s) = s^3$.\n\nBézier基矩阵 $\\boldsymbol{M}_{Bezier}$ 由这些多项式的系数构成。\n$$ \\boldsymbol{M}_{Bezier} = \\begin{pmatrix} -1 & 3 & -3 & 1 \\\\ 3 & -6 & 3 & 0 \\\\ -3 & 3 & 0 & 0 \\\\ 1 & 0 & 0 & 0 \\end{pmatrix} $$\n\n步骤3：推导Bézier基矩阵的逆\n要找到 $\\boldsymbol{T}$，我们需要 $(\\boldsymbol{M}_{Bezier})^{-1}$。我们可以通过将Bézier控制点与单项式幂基的系数联系起来推导这个逆矩阵。对于曲线 $\\boldsymbol{C}(s) = \\boldsymbol{c}_3 s^3 + \\boldsymbol{c}_2 s^2 + \\boldsymbol{c}_1 s + \\boldsymbol{c}_0$，Bézier点由其端点导数给出。\n$\\boldsymbol{Q}_0 = \\boldsymbol{C}(0) = \\boldsymbol{c}_0$.\n$\\boldsymbol{Q}_1 = \\boldsymbol{C}(0) + \\frac{1}{3}\\boldsymbol{C}'(0) = \\boldsymbol{c}_0 + \\frac{1}{3}\\boldsymbol{c}_1$.\n$\\boldsymbol{Q}_3 = \\boldsymbol{C}(1) = \\boldsymbol{c}_3 + \\boldsymbol{c}_2 + \\boldsymbol{c}_1 + \\boldsymbol{c}_0$.\n$\\boldsymbol{Q}_2 = \\boldsymbol{C}(1) - \\frac{1}{3}\\boldsymbol{C}'(1) = (\\boldsymbol{c}_3+\\boldsymbol{c}_2+\\boldsymbol{c}_1+\\boldsymbol{c}_0) - \\frac{1}{3}(3\\boldsymbol{c}_3+2\\boldsymbol{c}_2+\\boldsymbol{c}_1) = \\boldsymbol{c}_0 + \\frac{2}{3}\\boldsymbol{c}_1 + \\frac{1}{3}\\boldsymbol{c}_2$.\n\n以矩阵形式表示，此关系为：\n$$ \\begin{pmatrix} \\boldsymbol{Q}_0 \\\\ \\boldsymbol{Q}_1 \\\\ \\boldsymbol{Q}_2 \\\\ \\boldsymbol{Q}_3 \\end{pmatrix} = \\begin{pmatrix} 0 & 0 & 0 & 1 \\\\ 0 & 0 & 1/3 & 1 \\\\ 0 & 1/3 & 2/3 & 1 \\\\ 1 & 1 & 1 & 1 \\end{pmatrix} \\begin{pmatrix} \\boldsymbol{c}_3 \\\\ \\boldsymbol{c}_2 \\\\ \\boldsymbol{c}_1 \\\\ \\boldsymbol{c}_0 \\end{pmatrix} $$\n向量 $(\\boldsymbol{c}_3, \\boldsymbol{c}_2, \\boldsymbol{c}_1, \\boldsymbol{c}_0)^T$ 是 $\\boldsymbol{M}_{B-spline} \\boldsymbol{P}_{vec}$ 的结果。因此，上述矩阵是 $(\\boldsymbol{M}_{Bezier})^{-1}$。\n$$ (\\boldsymbol{M}_{Bezier})^{-1} = \\begin{pmatrix} 0 & 0 & 0 & 1 \\\\ 0 & 0 & \\frac{1}{3} & 1 \\\\ 0 & \\frac{1}{3} & \\frac{2}{3} & 1 \\\\ 1 & 1 & 1 & 1 \\end{pmatrix} $$\n\n步骤4：计算变换矩阵T\n最后，我们计算乘积 $\\boldsymbol{T} = (\\boldsymbol{M}_{Bezier})^{-1} \\boldsymbol{M}_{B-spline}$。\n$$ \\boldsymbol{T} = \\begin{pmatrix} 0 & 0 & 0 & 1 \\\\ 0 & 0 & \\frac{1}{3} & 1 \\\\ 0 & \\frac{1}{3} & \\frac{2}{3} & 1 \\\\ 1 & 1 & 1 & 1 \\end{pmatrix} \\frac{1}{6} \\begin{pmatrix} -1 & 3 & -3 & 1 \\\\ 3 & -6 & 0 & 0 \\\\ -3 & 3 & 3 & 0 \\\\ 1 & 4 & 1 & 0 \\end{pmatrix} $$\n$$ \\boldsymbol{T} = \\frac{1}{6} \\begin{pmatrix}\n(1) & (4) & (1) & (0) \\\\\n\\frac{1}{3}(-3)+1(1) & \\frac{1}{3}(3)+1(4) & \\frac{1}{3}(3)+1(1) & \\frac{1}{3}(0)+1(0) \\\\\n\\frac{1}{3}(3)+\\frac{2}{3}(-3)+1(1) & \\frac{1}{3}(-6)+\\frac{2}{3}(3)+1(4) & \\frac{1}{3}(0)+\\frac{2}{3}(3)+1(1) & \\frac{1}{3}(0)+\\frac{2}{3}(0)+1(0) \\\\\n(-1)+3-3+1 & 3-6+3+4 & -3+0+3+1 & 1+0+0+0\n\\end{pmatrix} $$\n$$ \\boldsymbol{T} = \\frac{1}{6} \\begin{pmatrix}\n1 & 4 & 1 & 0 \\\\\n0 & 5 & 2 & 0 \\\\\n0 & 4 & 3 & 0 \\\\\n0 & 4 & 1 & 1\n\\end{pmatrix} $$\n问题要求最终答案是具有有理数元素的单一显式矩阵。我们将标量乘数并入矩阵元素中。\n$$ \\boldsymbol{T} = \\begin{pmatrix}\n\\frac{1}{6} & \\frac{4}{6} & \\frac{1}{6} & 0 \\\\\n0 & \\frac{4}{6} & \\frac{2}{6} & 0 \\\\\n0 & \\frac{2}{6} & \\frac{4}{6} & 0 \\\\\n0 & \\frac{1}{6} & \\frac{4}{6} & \\frac{1}{6}\n\\end{pmatrix} = \\begin{pmatrix}\n\\frac{1}{6} & \\frac{2}{3} & \\frac{1}{6} & 0 \\\\\n0 & \\frac{2}{3} & \\frac{1}{3} & 0 \\\\\n0 & \\frac{1}{3} & \\frac{2}{3} & 0 \\\\\n0 & \\frac{1}{6} & \\frac{2}{3} & \\frac{1}{6}\n\\end{pmatrix} $$\n这就是所求的变换矩阵。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{6} & \\frac{2}{3} & \\frac{1}{6} & 0 \\\\\n0 & \\frac{2}{3} & \\frac{1}{3} & 0 \\\\\n0 & \\frac{1}{3} & \\frac{2}{3} & 0 \\\\\n0 & \\frac{1}{6} & \\frac{2}{3} & \\frac{1}{6}\n\\end{pmatrix}\n}\n$$", "id": "2372217"}, {"introduction": "在掌握了B样条的数学基础之后，我们现在转向一个核心的实际应用：构建一条精确通过一系列指定数据点的B样条曲线。这个练习 [@problem_id:2372182] 旨在引导您完成曲线插值的完整流程，从基于弦长对点集进行参数化，到构建合适的节点向量，并最终通过求解线性方程组来确定控制点。通过这项实践，您将学会如何利用B样条进行精确的几何形状设计。", "problem": "设计一个程序，该程序为每个给定的测试用例，构建一条 $p$ 次的非有理 B 样条曲线，该曲线通过在一组给定的参数值处强制精确插值，来插值欧几里得空间中的一个指定点序列。设数据点序列为 $\\{\\mathbf{Q}_i\\}_{i=0}^{n}$，其中 $\\mathbf{Q}_i \\in \\mathbb{R}^d$，且 $d \\in \\{2,3\\}$。在一个固支开放的节点向量 $\\mathbf{U} = \\{U_0,\\dots,U_{n+p+1}\\}$ 上定义 B 样条基函数 $\\{N_{j,p}(u)\\}_{j=0}^{n}$，并定义 B 样条曲线 $ \\mathbf{C}(u) = \\sum_{j=0}^{n} N_{j,p}(u)\\,\\mathbf{P}_j$，其中 $\\{\\mathbf{P}_j\\}_{j=0}^{n}$ 是 $\\mathbb{R}^d$ 中未知的控制点。插值要求为 $\\mathbf{C}(t_i) = \\mathbf{Q}_i$（对于 $i = 0,\\dots,n$）。其中 $\\{t_i\\}_{i=0}^{n}$ 是在 $[0,1]$ 区间内严格递增的参数值，通过弦长参数化方法获得，定义为 $t_0 = 0$，$t_i = \\left(\\sum_{k=1}^{i} \\|\\mathbf{Q}_k - \\mathbf{Q}_{k-1}\\|_2\\right) / \\left(\\sum_{k=1}^{n} \\|\\mathbf{Q}_k - \\mathbf{Q}_{k-1}\\|_2\\right)$（对于 $i=1,\\dots,n$），因此 $t_n = 1$。固支开放的节点向量两端必须具有 $p+1$ 的重数：$U_0 = \\cdots = U_p = 0$ 和 $U_{n+1} = \\cdots = U_{n+p+1} = 1$，内部节点（对于 $j=1,\\dots,n-p$）通过平均法设置：\n$$\nU_{j+p} = \\frac{1}{p}\\sum_{i=j}^{j+p-1} t_i.\n$$\n对于每个测试用例，计算满足插值约束的控制点 $\\{\\mathbf{P}_j\\}_{j=0}^{n}$，在相同的参数值 $\\{t_i\\}$ 处评估曲线，并返回以欧几里得范数测量的最大插值残差，即 $\\max_{0\\le i\\le n} \\|\\mathbf{C}(t_i)-\\mathbf{Q}_i\\|_2$，作为一个实数。不涉及物理单位。\n\n测试套件：\n- 案例 A (理想情况，二维三次)：$p=3$，$\\mathbf{Q}_0=\\left(0,0\\right)$，$\\mathbf{Q}_1=\\left(1,2\\right)$，$\\mathbf{Q}_2=\\left(3,3\\right)$，$\\mathbf{Q}_3=\\left(4,2\\right)$，$\\mathbf{Q}_4=\\left(5,0\\right)$。\n- 案例 B (边界次数，具有多个内部节点的二维线性)：$p=1$，$\\mathbf{Q}_0=\\left(0,0\\right)$，$\\mathbf{Q}_1=\\left(1,2\\right)$，$\\mathbf{Q}_2=\\left(2,2\\right)$，$\\mathbf{Q}_3=\\left(3,0\\right)$。\n- 案例 C (三维二次，非均匀间距)：$p=2$，$\\mathbf{Q}_0=\\left(0,0,0\\right)$，$\\mathbf{Q}_1=\\left(1,0.5,0.1\\right)$，$\\mathbf{Q}_2=\\left(2,0.0,0.2\\right)$，$\\mathbf{Q}_3=\\left(3,-0.5,0.0\\right)$，$\\mathbf{Q}_4=\\left(4,0.0,-0.1\\right)$。\n\n您的程序必须按照 A、B、C 的顺序为每个案例执行以下操作：构建参数值 $\\{t_i\\}$，按规定构建固支开放的节点向量 $\\mathbf{U}$，建立由 $\\mathbf{C}(t_i)=\\mathbf{Q}_i$（对于 $i=0,\\dots,n$）所蕴含的插值方程，计算控制点 $\\{\\mathbf{P}_j\\}$，并为该案例输出一个等于 $\\max_{i}\\|\\mathbf{C}(t_i)-\\mathbf{Q}_i\\|_2$ 的单一实数。\n\n最终输出格式：\n您的程序应产生一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如 $\\left[ \\text{resultA}, \\text{resultB}, \\text{resultC} \\right]$），其中每个条目是相应测试用例的最大插值残差，表示为一个实数。", "solution": "用户提供了一个要求设计 B 样条曲线插值程序的问题。该问题定义明确，科学上合理，并且属于计算工程领域。它已被验证为一个有效的问题。\n\n问题的核心是为一条 $p$ 次的 B 样条曲线找到一组控制点 $\\{\\mathbf{P}_j\\}_{j=0}^{n}$，使得该曲线穿过一个给定的数据点序列 $\\{\\mathbf{Q}_i\\}_{i=0}^{n}$。插值条件由 $\\mathbf{C}(t_i) = \\mathbf{Q}_i$ 给出，针对一组特定的参数值 $\\{t_i\\}_{i=0}^{n}$。\n\nB 样条曲线被定义为 B 样条基函数 $N_{j,p}(u)$ 和未知控制点 $\\mathbf{P}_j$ 的线性组合：\n$$\n\\mathbf{C}(u) = \\sum_{j=0}^{n} N_{j,p}(u)\\,\\mathbf{P}_j\n$$\n将插值条件代入此定义，得到一个关于 $n+1$ 个未知控制点的 $n+1$ 个线性方程组：\n$$\n\\mathbf{Q}_i = \\sum_{j=0}^{n} N_{j,p}(t_i)\\,\\mathbf{P}_j \\quad \\text{for } i = 0, \\dots, n\n$$\n该方程组可以表示为矩阵形式 $N \\mathbf{P} = \\mathbf{Q}$，其中 $N$ 是一个 $(n+1) \\times (n+1)$ 的矩阵，其元素为 $N_{ij} = N_{j,p}(t_i)$，$\\mathbf{P}$ 是控制点矩阵（行向量为 $\\mathbf{P}_j^T$），$\\mathbf{Q}$ 是数据点矩阵（行向量为 $\\mathbf{Q}_i^T$）。注意，该方程组对点的每个坐标独立求解。\n\n求解过程通过以下明确定义的步骤进行：\n\n1.  **参数化**：参数值 $\\{t_i\\}_{i=0}^{n}$ 使用弦长法确定。该方法根据连续数据点之间的累积欧几里得距离按比例分配参数值。总弦长为 $L = \\sum_{k=1}^{n} \\|\\mathbf{Q}_k - \\mathbf{Q}_{k-1}\\|_2$。那么参数为：\n    $$\n    t_0 = 0, \\quad t_i = \\frac{1}{L} \\sum_{k=1}^{i} \\|\\mathbf{Q}_k - \\mathbf{Q}_{k-1}\\|_2 \\quad \\text{for } i=1,\\dots,n\n    $$\n\n2.  **节点向量生成**：构建一个大小为 $n+p+2$ 的固支开放节点向量 $\\mathbf{U}$。固支（clamping）确保曲线起始于 $\\mathbf{P}_0$ 并终止于 $\\mathbf{P}_n$。节点定义如下：\n    - 端节点：$U_0 = \\dots = U_p = 0$ 和 $U_{n+1} = \\dots = U_{n+p+1} = 1$。\n    - 内部节点：问题指定了一种平均法，其中内部节点根据参数值 $\\{t_i\\}$ 计算：\n    $$\n    U_{j+p} = \\frac{1}{p}\\sum_{i=j}^{j+p-1} t_i \\quad \\text{for } j=1, \\dots, n-p\n    $$\n    这种节点放置方法旨在满足 Schoenberg-Whitney 条件，确保生成的插值矩阵 $N$ 非奇异且良态。\n\n3.  **基函数求值**：B 样条基函数 $N_{j,p}(u)$ 使用 Cox-de Boor 递推公式进行求值。对于 $p > 0$：\n    $$\n    N_{j,p}(u) = \\frac{u - U_j}{U_{j+p} - U_j} N_{j,p-1}(u) + \\frac{U_{j+p+1} - u}{U_{j+p+1} - U_{j+1}} N_{j+1,p-1}(u)\n    $$\n    递推的基例是：\n    $$\n    N_{j,0}(u) = \\begin{cases} 1 & \\text{if } U_j \\le u < U_{j+1} \\\\ 0 & \\text{otherwise} \\end{cases}\n    $$\n    按照惯例，任何分母为零的项都视为零。对于最后一个节点区间 $[U_n, U_{n+1}]$，为处理 $u=1$ 的情况，该区间被视为右端闭合。在计算上，这个过程是通过计算递增次数的值来高效实现的，而无需递归。\n\n4.  **方程组求解**：通过在每个参数值 $t_i$ 处求值基函数来填充插值矩阵 $N$。然后使用标准的数值线性代数求解器（如 `numpy.linalg.solve`）求解线性方程组 $N \\mathbf{P} = \\mathbf{Q}$ 以获得控制点矩阵 $\\mathbf{P}$。该求解器对于潜在的数值不稳定性具有鲁棒性。\n\n5.  **残差计算**：计算出控制点 $\\{\\mathbf{P}_j\\}$ 后，B 样条曲线 $\\mathbf{C}(u)$ 就完全确定了。为了验证插值，在原始参数值 $\\mathbf{C}(t_i)$ 处对曲线进行求值。由于浮点运算的限制，计算出的 $\\mathbf{C}(t_i)$ 可能不完全等于 $\\mathbf{Q}_i$。每个点的插值残差计算为差值的欧几里得范数 $\\|\\mathbf{C}(t_i) - \\mathbf{Q}_i\\|_2$。每个测试用例的最终结果是所有 $i=0, \\dots, n$ 的残差中的最大值。该值可作为衡量数值实现准确性的指标。对于正确的实现，该残差应在机器精度级别。", "answer": "```python\nimport numpy as np\n\ndef find_span(n, p, u, U):\n    \"\"\"\n    Determine the knot span index for a given parameter u.\n    This implementation is based on Algorithm A2.1 from \"The NURBS Book\".\n    \n    Args:\n        n (int): Number of control points minus 1.\n        p (int): Degree of the B-spline.\n        u (float): Parameter value.\n        U (np.ndarray): Knot vector.\n    \n    Returns:\n        int: The index of the knot span that contains u.\n    \"\"\"\n    if u >= U[n + 1]:  # Special case for u at the end of the domain\n        return n\n    \n    # Binary search for the span\n    low = p\n    high = n + 1\n    mid = (low + high) // 2\n    \n    while u < U[mid] or u >= U[mid + 1]:\n        if u < U[mid]:\n            high = mid\n        else:\n            low = mid\n        mid = (low + high) // 2\n    return mid\n\ndef basis_funs(i, u, p, U):\n    \"\"\"\n    Compute the non-zero B-spline basis functions.\n    This implementation is based on Algorithm A2.2 from \"The NURBS Book\".\n\n    Args:\n        i (int): Knot span index.\n        u (float): Parameter value.\n        p (int): Degree of the B-spline.\n        U (np.ndarray): Knot vector.\n\n    Returns:\n        np.ndarray: An array of p+1 non-zero basis function values.\n    \"\"\"\n    N = np.zeros(p + 1, dtype=np.float64)\n    N[0] = 1.0\n    left = np.zeros(p + 1, dtype=np.float64)\n    right = np.zeros(p + 1, dtype=np.float64)\n\n    for j in range(1, p + 1):\n        left[j] = u - U[i + 1 - j]\n        right[j] = U[i + j] - u\n        saved = 0.0\n        for r in range(j):\n            # The denominator can be zero if knots are repeated. The formula\n            # requires this term to be zero, which is handled implicitly\n            # if the numerator is also zero, but we add a check for robustness.\n            den = right[r + 1] + left[j - r]\n            if den == 0.0:\n                temp = 0.0\n            else:\n                temp = N[r] / den\n            N[r] = saved + right[r + 1] * temp\n            saved = left[j - r] * temp\n        N[j] = saved\n    return N\n\ndef solve_interpolation(p, Q_points):\n    \"\"\"\n    Computes the maximum interpolation residual for a single test case.\n\n    Args:\n        p (int): Degree of the B-spline.\n        Q_points (list of tuples): Sequence of data points to interpolate.\n\n    Returns:\n        float: The maximum interpolation residual.\n    \"\"\"\n    Q = np.array(Q_points, dtype=np.float64)\n    n = Q.shape[0] - 1\n    \n    # Step 1: Chord-length parameterization\n    t = np.zeros(n + 1, dtype=np.float64)\n    chord_lengths = np.linalg.norm(np.diff(Q, axis=0), axis=1)\n    total_length = np.sum(chord_lengths)\n    \n    if total_length < 1e-12: # Handle degenerate case where all points coincide.\n        return 0.0\n\n    cumulative_lengths = np.cumsum(chord_lengths)\n    t[1:] = cumulative_lengths / total_length\n    \n    # Step 2: Knot vector construction\n    num_knots = n + p + 2\n    U = np.zeros(num_knots, dtype=np.float64)\n    U[0:p+1] = 0.0\n    U[n+1:] = 1.0\n    \n    if p > 0 and n > p:\n        for j in range(1, n - p + 1):\n            U[p + j] = (1.0 / p) * np.sum(t[j : j + p])\n    elif p == 1 and n > 1: # The general formula covers this, but for clarity:\n        for j in range(1, n):\n            U[1 + j] = t[j]\n\n    # Step 3: Set up interpolation matrix N\n    N_matrix = np.zeros((n + 1, n + 1), dtype=np.float64)\n    for i in range(n + 1):\n        u_param = t[i]\n        span = find_span(n, p, u_param, U)\n        basis_values = basis_funs(span, u_param, p, U)\n        start_idx = span - p\n        N_matrix[i, start_idx : start_idx + p + 1] = basis_values\n\n    # Step 4: Solve for control points P\n    try:\n        P = np.linalg.solve(N_matrix, Q)\n    except np.linalg.LinAlgError:\n        return np.inf\n\n    # Step 5: Evaluate the curve and compute the maximum residual\n    Q_reconstructed = N_matrix @ P\n    residuals = np.linalg.norm(Q_reconstructed - Q, axis=1)\n    max_residual = np.max(residuals)\n    \n    return max_residual\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case A: 2D cubic B-spline\n        (3, [ (0.0, 0.0), (1.0, 2.0), (3.0, 3.0), (4.0, 2.0), (5.0, 0.0) ]),\n        # Case B: 2D linear B-spline\n        (1, [ (0.0, 0.0), (1.0, 2.0), (2.0, 2.0), (3.0, 0.0) ]),\n        # Case C: 3D quadratic B-spline\n        (2, [ (0.0, 0.0, 0.0), (1.0, 0.5, 0.1), (2.0, 0.0, 0.2), (3.0, -0.5, 0.0), (4.0, 0.0, -0.1) ])\n    ]\n\n    results = []\n    for p, Q_points in test_cases:\n        result = solve_interpolation(p, Q_points)\n        # Format to scientific notation for consistent output of small numbers.\n        results.append(f\"{result:.17e}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2372182"}, {"introduction": "最后的练习将我们的学习范围从B样条曲线扩展到更通用、更强大的非均匀有理B样条 (NURBS) 曲面。计算曲面上任意一点的切平面是许多高级应用（如真实感渲染、路径规划和应力分析）中的一项基本操作。这项编程挑战 [@problem_id:2372227] 要求您从基本定义出发，实现一个能够计算NURBS曲面及其偏导数的完整算法，从而全面检验您对曲面几何性质的理解。", "problem": "设计并实现一个完整的、可运行的程序，该程序用于计算在指定参数值处，一个非均匀有理B样条（NURBS）张量积曲面的切平面系数。解决方案必须从B样条和有理曲面的基本原理推导得出，并且不得依赖外部数据或交互性。\n\n您的推导和实现必须基于以下基本定义和事实：\n- $p$ 次B样条基函数由 Cox–de Boor 递归公式递归定义：\n  - 对于 $p=0$，$N_{i,0}(u) = 1$ 若 $u \\in [U_i, U_{i+1})$，否则为 $0$。\n  - 对于 $p \\ge 1$，\n  $$\n  N_{i,p}(u) = \\frac{u-U_i}{U_{i+p}-U_i} N_{i,p-1}(u) + \\frac{u_{i+p+1}-u}{U_{i+p+1}-U_{i+1}} N_{i+1,p-1}(u),\n  $$\n  约定分母为零的项贡献为零。\n- 一个 $p$ 次和 $q$ 次的张量积NURBS曲面由控制点 $\\mathbf{P}_{i,j} \\in \\mathbb{R}^3$、相关的非负权重 $w_{i,j}$ 以及节点矢量 $U$ 和 $V$ 定义：\n  $$\n  \\mathbf{S}(u,v) = \\frac{\\sum_{i=0}^{n}\\sum_{j=0}^{m} N_{i,p}(u) \\, M_{j,q}(v) \\, w_{i,j} \\, \\mathbf{P}_{i,j}}{\\sum_{i=0}^{n}\\sum_{j=0}^{m} N_{i,p}(u) \\, M_{j,q}(v) \\, w_{i,j}},\n  $$\n  其中 $M_{j,q}(v)$ 是关于 $v$ 且节点矢量为 $V$ 的B样条基函数。\n- 在 $(u_0,v_0)$ 处的切平面是通过曲面点 $\\mathbf{S}(u_0,v_0)$ 且法向量为 $\\mathbf{n}(u_0,v_0) = \\mathbf{S}_u(u_0,v_0) \\times \\mathbf{S}_v(u_0,v_0)$ 的平面，假定 $\\|\\mathbf{n}\\| \\ne 0$。平面系数 $(a,b,c,d)$ 满足 $a x + b y + c z + d = 0$，其中 $(a,b,c) = \\mathbf{\\hat n}$ 是单位法向量，且 $d = -\\mathbf{\\hat n}\\cdot \\mathbf{S}(u_0,v_0)$。\n\n您必须通过结合以下方法，实现用于计算 $\\mathbf{S}(u,v)$ 及其一阶偏导数 $\\mathbf{S}_u(u,v)$ 和 $\\mathbf{S}_v(u,v)$ 的算法：\n- 非有理B样条基函数的导数（通过一个基于原理的基函数导数递归公式）。\n- 有理函数的商法则，从带权重的分子和权重分母的导数中获得 $\\mathbf{S}(u,v)$ 的导数。\n\n程序中要使用的曲面规格如下：\n- 次数: $p=q=2$。\n- 节点矢量（开区间均匀）:\n  $$\n  U = [\\,0,\\,0,\\,0,\\,\\tfrac{1}{2},\\,1,\\,1,\\,1\\,], \\quad V = [\\,0,\\,0,\\,0,\\,\\tfrac{1}{2},\\,1,\\,1,\\,1\\,].\n  $$\n- 控制网格 $\\mathbf{P}_{i,j}$，对于 $i \\in \\{0,1,2,3\\}$ 和 $j \\in \\{0,1,2,3\\}$，由程序定义如下：\n  $$\n  \\mathbf{P}_{i,j} = \\big(i,\\; j,\\; 0.2\\,(i-1.5)^2 + 0.1\\,(j-1.5)^2\\big).\n  $$\n- 权重 $w_{i,j}$ 分段定义如下：\n  $$\n  w_{i,j} = \\begin{cases}\n  2, & \\text{若 } i \\in \\{1,2\\} \\text{ 且 } j \\in \\{1,2\\},\\\\\n  1, & \\text{否则}.\n  \\end{cases}\n  $$\n\n算法要求：\n- 使用节点区间查找例程和稳定的基函数导数算法，实现B样条基函数及其一阶导数的稳健求值。\n- 通过在非零基函数支集上组合加权和，并应用商法则将非有理导数转换为有理导数，来计算 $\\mathbf{S}(u,v)$、$\\mathbf{S}_u(u,v)$ 和 $\\mathbf{S}_v(u,v)$。\n- 计算单位法向量 $\\mathbf{\\hat n} = \\frac{\\mathbf{S}_u \\times \\mathbf{S}_v}{\\|\\mathbf{S}_u \\times \\mathbf{S}_v\\|}$ 并强制执行确定性方向规则以避免符号模糊性：如果 $\\mathbf{\\hat n}$ 的第三个分量为负，则翻转 $\\mathbf{\\hat n}$ 的符号；如果为零，则要求第二个分量为非负；如果也为零，则要求第一个分量为非负。\n- 计算平面系数 $(a,b,c,d)$，其中 $(a,b,c)=\\mathbf{\\hat n}$ 且 $d=-\\mathbf{\\hat n}\\cdot \\mathbf{S}(u_0,v_0)$。\n- 如果 $\\|\\mathbf{S}_u \\times \\mathbf{S}_v\\|$ 低于一个小公差（例如，实际上为零），则该平面未定义；在这种情况下，返回四个非数字（Not-a-Number）值。\n\n数值输出要求：\n- 使用以下参数对 $(u,v)$ 的测试套件：\n  - 案例1：$(u,v)=(0.3,\\,0.6)$\n  - 案例2：$(u,v)=(0.5,\\,0.5)$\n  - 案例3：$(u,v)=(0,\\,0)$\n  - 案例4：$(u,v)=(1,\\,1)$\n- 对于每个案例，将切平面系数 $(a,b,c,d)$ 作为四个浮点数输出，四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素是对应案例的列表 $[a,b,c,d]$，不含空格。例如：\n  $$\n  [ [a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3],[a_4,b_4,c_4,d_4] ]\n  $$\n  但打印时不含空格，且每个数字都四舍五入到六位小数，例如：\n  $[[0.123456,0.234567,0.945678,-1.234567],[\\dots],\\dots]$。\n\n角度单位不适用。没有物理单位。所有数值必须遵循上述四舍五入要求。最终程序必须是自包含的，无需输入，并遵守指定的输出格式。", "solution": "该问题要求计算非均匀有理B样条（NURBS）曲面在指定参数值处的切平面系数。这是计算几何和计算机辅助设计中的一个标准问题。解决方案将按规定从基本原理推导得出。\n\n张量积NURBS曲面 $\\mathbf{S}(u,v)$ 是一个定义如下的有理函数：\n$$\n\\mathbf{S}(u,v) = \\frac{\\mathbf{A}(u,v)}{w(u,v)}\n$$\n其中 $\\mathbf{A}(u,v)$ 是控制点的加权和，而 $w(u,v)$ 是权重的和。\n$$\n\\mathbf{A}(u,v) = \\sum_{i=0}^{n}\\sum_{j=0}^{m} N_{i,p}(u) M_{j,q}(v) w_{i,j} \\mathbf{P}_{i,j}\n$$\n$$\nw(u,v) = \\sum_{i=0}^{n}\\sum_{j=0}^{m} N_{i,p}(u) M_{j,q}(v) w_{i,j}\n$$\n此处，$N_{i,p}(u)$ 和 $M_{j,q}(v)$ 分别是次数为 $p$ 和 $q$、节点矢量为 $U$ 和 $V$ 的B样条基函数。控制点为 $\\mathbf{P}_{i,j}$ ，权重为 $w_{i,j}$。\n\n在点 $\\mathbf{S}(u_0, v_0)$ 处的切平面由该点本身和一个法向量 $\\mathbf{n}$ 定义。法向量由曲面关于其参数的偏导数 $\\mathbf{S}_u$ 和 $\\mathbf{S}_v$ 的叉积给出。\n$$\n\\mathbf{n}(u,v) = \\mathbf{S}_u(u,v) \\times \\mathbf{S}_v(u,v)\n$$\n偏导数使用向量值函数的商法则求得：\n$$\n\\mathbf{S}_u = \\frac{\\partial}{\\partial u} \\left( \\frac{\\mathbf{A}}{w} \\right) = \\frac{\\frac{\\partial \\mathbf{A}}{\\partial u} w - \\mathbf{A} \\frac{\\partial w}{\\partial u}}{w^2} = \\frac{\\mathbf{A}_u w - \\mathbf{A} w_u}{w^2}\n$$\n$$\n\\mathbf{S}_v = \\frac{\\partial}{\\partial v} \\left( \\frac{\\mathbf{A}}{w} \\right) = \\frac{\\frac{\\partial \\mathbf{A}}{\\partial v} w - \\mathbf{A} \\frac{\\partial w}{\\partial v}}{w^2} = \\frac{\\mathbf{A}_v w - \\mathbf{A} w_v}{w^2}\n$$\n项 $\\mathbf{A}_u, w_u, \\mathbf{A}_v, w_v$ 是非有理的分子和分母部分的偏导数：\n$$\n\\mathbf{A}_u(u,v) = \\sum_{i=0}^{n}\\sum_{j=0}^{m} N'_{i,p}(u) M_{j,q}(v) w_{i,j} \\mathbf{P}_{i,j}\n$$\n$$\nw_u(u,v) = \\sum_{i=0}^{n}\\sum_{j=0}^{m} N'_{i,p}(u) M_{j,q}(v) w_{i,j}\n$$\n对于 $\\mathbf{A}_v$ 和 $w_v$ 存在类似的表达式，其中涉及基函数 $M'_{j,q}(v)$ 的导数。\n\nB样条基函数 $N_{i,p}(u)$ 的导数由标准公式给出，该公式本身可以从 Cox-de Boor 递归公式推导得出：\n$$\nN'_{i,p}(u) = \\frac{p}{U_{i+p}-U_i} N_{i,p-1}(u) - \\frac{p}{U_{i+p+1}-U_{i+1}} N_{i+1,p-1}(u)\n$$\n同样，分母为零的项被视为零。此公式表明，$p$ 次基函数的导数可以由 $(p-1)$ 次基函数的值计算得出。\n\n算法流程如下：\n1.  **寻找节点区间**：对于给定的参数值 $u$，找到其所在的节点区间 $[U_k, U_{k+1})$。索引 $k$ 即为该区间。这使计算局部化，因为在此区间上只有 $p+1$ 个基函数是非零的。\n2.  **求值基函数及其导数**：\n    -   实现一个函数，使用 Cox-de Boor 递归公式计算所有非零基函数 $N_{k-p,p}(u), \\dots, N_{k,p}(u)$ 的值。\n    -   实现一个函数来计算这些基函数的一阶导数。此函数将首先调用 $p-1$ 次的基函数求值例程，然后应用上述导数公式。\n3.  **求值曲面点及其导数**：对于给定的参数对 $(u,v)$：\n    -   在各自的节点矢量 $U$ 和 $V$ 中找到 $u$ 和 $v$ 的节点区间。\n    -   在相关区间内求值 $u$ 和 $v$ 的基函数及其一阶导数。这将产生值的数组 $\\{N_i(u)\\}, \\{N'_i(u)\\}, \\{M_j(v)\\}, \\{M'_j(v)\\}$。\n    -   通过在基函数的局部支集（即一个 $(p+1) \\times (q+1)$ 的控制点块）上迭代，计算六个必要的和（$\\mathbf{A}, w, \\mathbf{A}_u, w_u, \\mathbf{A}_v, w_v$）。\n    -   使用商法则公式组合出 $\\mathbf{S}(u,v)$、$\\mathbf{S}_u(u,v)$ 和 $\\mathbf{S}_v(u,v)$。\n4.  **计算平面系数**：\n    -   计算法向量 $\\mathbf{n} = \\mathbf{S}_u \\times \\mathbf{S}_v$。\n    -   检查其模 $\\|\\mathbf{n}\\|$ 是否接近于零。如果是，则该平面是病态的（ill-defined）。\n    -   将向量归一化以获得单位法向量 $\\mathbf{\\hat n} = \\mathbf{n} / \\|\\mathbf{n}\\|$。\n    -   应用指定的方向规则以确保法向量方向的唯一性。如果 $\\hat{n}_z < 0$，翻转向量符号。如果 $\\hat{n}_z = 0$，确保 $\\hat{n}_y \\ge 0$。如果两者都为零，确保 $\\hat{n}_x \\ge 0$。\n    -   平面系数为 $(a,b,c,d)$，其中 $(a,b,c) = \\mathbf{\\hat n}$ 且 $d = -\\mathbf{\\hat n} \\cdot \\mathbf{S}(u,v)$。\n\n所提供的曲面次数为 $p=q=2$，拥有 $4 \\times 4$ 的控制点 $\\mathbf{P}_{i,j}$ 和权重 $w_{i,j}$，定义在开区间均匀节点矢量 $U=V = [0, 0, 0, \\frac{1}{2}, 1, 1, 1]$ 上。参数域为 $[0,1] \\times [0,1]$。需要特别注意处理定义域的边界（$u,v \\in \\{0,1\\}$）和内部节点 $u=v=0.5$ 处的情况，尽管只要正确实现了基函数和导数公式（特别是 `0/0=0` 的约定），通用算法对这些情况是稳健的。\n\n实现将遵循这种基于原理的结构，从基函数求值开始，逐步构建到最终的平面方程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define the NURBS surface, compute tangent planes for test cases,\n    and print the results in the specified format.\n    \"\"\"\n\n    # --- Surface Specification ---\n    p = 2  # Degree in u\n    q = 2  # Degree in v\n    U = np.array([0., 0., 0., 0.5, 1., 1., 1.])  # Knot vector in u\n    V = np.array([0., 0., 0., 0.5, 1., 1., 1.])  # Knot vector in v\n\n    n = len(U) - p - 2  # Number of control points in u is n+1 = 4\n    m = len(V) - q - 2  # Number of control points in v is m+1 = 4\n\n    # Procedurally generate control points P_ij\n    P = np.zeros((n + 1, m + 1, 3))\n    for i in range(n + 1):\n        for j in range(m + 1):\n            x = float(i)\n            y = float(j)\n            z = 0.2 * (i - 1.5)**2 + 0.1 * (j - 1.5)**2\n            P[i, j] = [x, y, z]\n\n    # Procedurally generate weights w_ij\n    W = np.ones((n + 1, m + 1))\n    W[1:3, 1:3] = 2.0\n\n    # --- Test Cases ---\n    test_cases = [\n        (0.3, 0.6),\n        (0.5, 0.5),\n        (0.0, 0.0),\n        (1.0, 1.0),\n    ]\n\n    results = []\n    for u_eval, v_eval in test_cases:\n        coeffs = compute_plane_coeffs(u_eval, v_eval, p, q, U, V, P, W)\n        results.append(coeffs)\n\n    # --- Format and Print Output ---\n    result_str_parts = []\n    for res in results:\n        if np.isnan(res[0]):\n            part = '[nan,nan,nan,nan]'\n        else:\n            part = '[' + ','.join([f\"{x:.6f}\" for x in res]) + ']'\n        result_str_parts.append(part)\n    \n    print(f\"[{','.join(result_str_parts)}]\")\n\ndef find_span(u, p, U):\n    \"\"\"\n    Find the knot span index i such that U_i <= u < U_{i+1}.\n    n is the number of control points minus 1.\n    \"\"\"\n    n = len(U) - p - 2\n    if u == U[n + 1]:\n        return n\n    \n    # Binary search for the span\n    low = p\n    high = n + 1\n    mid = (low + high) // 2\n    while u < U[mid] or u >= U[mid + 1]:\n        if u < U[mid]:\n            high = mid\n        else:\n            low = mid\n        mid = (low + high) // 2\n    return mid\n\ndef basis_funs(span, u, p, U):\n    \"\"\"\n    Compute the non-zero B-spline basis functions for a given span.\n    Uses the Cox-de Boor recursion.\n    Returns: A (p+1) element array with N_{span-p,p}(u), ..., N_{span,p}(u)\n    \"\"\"\n    N = np.zeros(p + 1)\n    left = np.zeros(p + 1)\n    right = np.zeros(p + 1)\n    N[0] = 1.0\n\n    for j in range(1, p + 1):\n        left[j] = u - U[span + 1 - j]\n        right[j] = U[span + j] - u\n        saved = 0.0\n        for r in range(j):\n            den = right[r + 1] + left[j - r]\n            temp = 0.0\n            if den != 0.0:\n                temp = N[r] / den\n            N[r] = saved + right[r + 1] * temp\n            saved = left[j - r] * temp\n        N[j] = saved\n    return N\n\ndef ders_basis_funs(span, u, p, U):\n    \"\"\"\n    Compute derivatives of B-spline basis functions.\n    Returns: A (p+1) element array with the first derivatives.\n    \"\"\"\n    if p == 0:\n        return np.zeros(1)\n        \n    N_prev = basis_funs(span, u, p - 1, U)\n    ders = np.zeros(p + 1)\n    \n    for j in range(p + 1):\n        i = span - p + j\n        term1 = 0.0\n        den1 = U[i + p] - U[i]\n        if den1 != 0.0 and j > 0:\n            term1 = N_prev[j - 1] / den1\n\n        term2 = 0.0\n        den2 = U[i + p + 1] - U[i + 1]\n        if den2 != 0.0 and j < p:\n            term2 = N_prev[j] / den2\n        \n        ders[j] = p * (term1 - term2)\n        \n    return ders\n\ndef surface_pt_and_ders(u, v, p, q, U, V, P, W):\n    \"\"\"\n    Computes the surface point S(u,v) and its first partial derivatives S_u, S_v.\n    \"\"\"\n    n = len(U) - p - 2\n    m = len(V) - q - 2\n\n    u_span = find_span(u, p, U)\n    v_span = find_span(v, q, V)\n    \n    Nu = basis_funs(u_span, u, p, U)\n    Nv = basis_funs(v_span, v, q, V)\n    \n    dNu = ders_basis_funs(u_span, u, p, U)\n    dNv = ders_basis_funs(v_span, v, q, V)\n\n    S_num = np.zeros(3)\n    S_den = 0.0\n    Su_num = np.zeros(3)\n    Su_den = 0.0\n    Sv_num = np.zeros(3)\n    Sv_den = 0.0\n\n    for i in range(p + 1):\n        for j in range(q + 1):\n            ii = u_span - p + i\n            jj = v_span - q + j\n            \n            w_ij = W[ii, jj]\n            P_ij = P[ii, jj]\n            \n            temp = Nu[i] * Nv[j] * w_ij\n            S_num += temp * P_ij\n            S_den += temp\n            \n            temp_u = dNu[i] * Nv[j] * w_ij\n            Su_num += temp_u * P_ij\n            Su_den += temp_u\n            \n            temp_v = Nu[i] * dNv[j] * w_ij\n            Sv_num += temp_v * P_ij\n            Sv_den += temp_v\n\n    if S_den == 0.0:\n        return np.full(3, np.nan), np.full(3, np.nan), np.full(3, np.nan)\n\n    S = S_num / S_den\n    Su = (Su_num * S_den - S_num * Su_den) / (S_den**2)\n    Sv = (Sv_num * S_den - S_num * Sv_den) / (S_den**2)\n\n    return S, Su, Sv\n\ndef compute_plane_coeffs(u, v, p, q, U, V, P, W):\n    \"\"\"\n    Computes the tangent plane coefficients (a, b, c, d) for the NURBS surface.\n    \"\"\"\n    S, Su, Sv = surface_pt_and_ders(u, v, p, q, U, V, P, W)\n    if np.any(np.isnan(S)):\n        return [np.nan, np.nan, np.nan, np.nan]\n\n    normal = np.cross(Su, Sv)\n    norm_mag = np.linalg.norm(normal)\n    \n    tolerance = 1e-12\n    if norm_mag < tolerance:\n        return [np.nan, np.nan, np.nan, np.nan]\n\n    n_hat = normal / norm_mag\n\n    # Deterministic orientation rule\n    if n_hat[2] < 0.0:\n        n_hat = -n_hat\n    elif abs(n_hat[2]) < tolerance:\n        if n_hat[1] < 0.0:\n            n_hat = -n_hat\n        elif abs(n_hat[1]) < tolerance:\n            if n_hat[0] < 0.0:\n                n_hat = -n_hat\n    \n    a, b, c = n_hat\n    d = -np.dot(n_hat, S)\n\n    return [a, b, c, d]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2372227"}]}