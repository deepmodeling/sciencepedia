{"hands_on_practices": [{"introduction": "谱方法的核心威力之一在于其能够将微分运算转换为频域中的代数运算。这个练习将指导你利用这一原理，直接求解一个受周期性外力驱动的二阶常微分方程的稳态解，而无需进行耗时的时域步进。通过这个实践，你将亲身体验到傅里叶谱方法如何将一个动态问题简化为频域中的简单代数关系，从而高效地获得精确解。[@problem_id:2437054]", "problem": "考虑一个带有周期性驱动力的线性时不变二阶常微分方程 (ODE)，作用于一个周期内：\n$$\n\\frac{d^2 y}{dt^2} + 2 \\zeta \\omega_0 \\frac{d y}{dt} + \\omega_0^2 y = f(t),\n$$\n其中 $y(t)$ 是未知函数，$\\omega_0 > 0$ 是固有频率，$\\zeta \\ge 0$ 是阻尼比，$f(t)$ 是一个给定的周期函数，周期为 $T$，即对所有 $t$ 都有 $f(t + T) = f(t)$。目标是直接计算满足该 ODE 和周期性条件 $y_{\\mathrm{per}}(t+T) = y_{\\mathrm{per}}(t)$ 的周期性稳态解 $y_{\\mathrm{per}}(t)$，而无需通过时间步进方法达到稳态。\n\n使用的基本原理：\n- 复指数集合 $\\{ e^{i \\omega_k t} \\}$（其中 $\\omega_k = \\frac{2\\pi k}{T}$，k 为整数）构成了一个周期内平方可积的 T-周期函数的正交基。\n- 对于任何周期为 T 的足够平滑的周期函数 $g(t)$，在傅里叶级数表示中，对时间求导对应于乘以 $i \\omega_k$；具体来说，如果 $g(t) = \\sum_{k=-\\infty}^{\\infty} \\hat{g}_k e^{i \\omega_k t}$，则 $\\frac{dg}{dt} = \\sum_{k=-\\infty}^{\\infty} (i \\omega_k) \\hat{g}_k e^{i \\omega_k t}$ 且 $\\frac{d^2 g}{dt^2} = \\sum_{k=-\\infty}^{\\infty} (-\\omega_k^2) \\hat{g}_k e^{i \\omega_k t}$。\n\n任务：\n1. 从这些原理出发，推导如何使用时间上的傅里叶谱方法在频域中直接计算 $y_{\\mathrm{per}}(t)$。推导过程必须清楚地说明为什么该问题在傅里叶基下是对角化的，以及为什么这种方法能够无需时间步进即可得到周期性稳态解。\n2. 实现一个程序，该程序：\n   - 使用 N 个等距节点对一个周期 $[0, T)$ 进行离散化，其中 N 在每个测试用例中指定。\n   - 在此网格上构建 $f(t)$ 的样本，并使用离散傅里叶变换（通过快速傅里叶变换(FFT)）来获得离散傅里叶系数。\n   - 通过与 ODE 和周期性一致的频域代数操作，计算 $y_{\\mathrm{per}}(t)$ 的离散傅里叶系数。\n   - 通过逆变换在网格上恢复 $y_{\\mathrm{per}}(t)$。\n   - 通过将数值解 $y_{\\mathrm{per}}(t)$ 与下面测试套件中为特定驱动函数提供的解析周期性稳态解进行比较，来验证其正确性。\n   - 报告每个测试用例在 N 个网格点上的最大绝对误差。\n3. 所有角度必须以弧度处理。时间，如果进行物理解释，单位是秒，但您不需要输出单位。最终报告的误差是无量纲实数。\n\n测试套件：\n实现并评估以下四个测试用例，这些用例共同涵盖了一系列行为，包括多谐波驱动、零频驱动和近共振响应。在所有情况下，请确保所有评估都在一个周期 T 内使用 N 个等距点上进行。\n\n- 用例 $1$（单音驱动，基频周期）：\n  - 参数：$\\omega_0 = 1$，$\\zeta = 0.05$，$\\Omega = 1$，$T = \\frac{2\\pi}{\\Omega} = 2\\pi$，$N = 256$。\n  - 驱动力：$f(t) = \\sin(\\Omega t)$。\n  - 解析稳态参考解：一个频率为 $\\Omega$ 的正弦波，其振幅和相位由该 ODE 的频率响应确定。\n- 用例 $2$（双谐波驱动）：\n  - 参数：$\\omega_0 = 3$，$\\zeta = 0.1$，$\\Omega = 2$，$T = \\frac{2\\pi}{\\Omega} = \\pi$，$N = 256$。\n  - 驱动力：$f(t) = \\sin(\\Omega t) + 0.5 \\cos(2\\Omega t)$。\n  - 解析稳态参考解：频率为 $\\Omega$ 和 $2\\Omega$ 的响应的叠加。\n- 用例 $3$（恒定驱动，零频内容）：\n  - 参数：$\\omega_0 = 2$，$\\zeta = 0.2$，$T = 2\\pi$，$N = 256$。\n  - 驱动力：对所有 t，$f(t) = 1.5$。\n  - 解析稳态参考解：一个常数 $y_{\\mathrm{per}}(t) = \\frac{1.5}{\\omega_0^2}$。\n- 用例 $4$（小阻尼下的近共振驱动）：\n  - 参数：$\\omega_0 = 2$，$\\zeta = 0.01$，$\\Omega = 1.98$，$T = \\frac{2\\pi}{\\Omega}$，$N = 256$。\n  - 驱动力：$f(t) = \\cos(\\Omega t)$。\n  - 解析稳态参考解：一个频率为 $\\Omega$ 的正弦波，其振幅和相位由频率响应确定。\n\n对于用例 1、2 和 4 中的解析稳态参考解，使用该 ODE 的频率响应：对于角频率为 $\\omega$ 的谐波输入，稳态输出是通过将输入的复振幅与传递函数\n$$\nH(i\\omega) = \\frac{1}{\\omega_0^2 - \\omega^2 + i \\, 2 \\zeta \\omega_0 \\omega},\n$$\n相乘得到的，因此，对于 $\\cos(\\omega t)$ 的实数输出是 $|H(i\\omega)| \\cos(\\omega t - \\phi)$，对于 $\\sin(\\omega t)$ 的实数输出是 $|H(i\\omega)| \\sin(\\omega t - \\phi)$，其中\n$$\n|H(i\\omega)| = \\frac{1}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2 \\zeta \\omega_0 \\omega)^2}}, \\quad \\phi = \\operatorname{atan2}(2 \\zeta \\omega_0 \\omega, \\omega_0^2 - \\omega^2).\n$$\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含结果，格式为用方括号括起来的逗号分隔列表，顺序为 [用例 1 的误差, 用例 2 的误差, 用例 3 的误差, 用例 4 的误差]，例如 $[e_1,e_2,e_3,e_4]$。每个 $e_j$ 必须是实值浮点数。", "solution": "我们从带周期性驱动力的线性时不变二阶常微分方程开始，\n$$\n\\frac{d^2 y}{dt^2} + 2 \\zeta \\omega_0 \\frac{d y}{dt} + \\omega_0^2 y = f(t),\n$$\n该方程定义在区间 $[0, T)$ 上，具有周期性边界条件 $y(t+T) = y(t)$，其导数也同样。我们寻求其周期性稳态解 $y_{\\mathrm{per}}(t)$。\n\n使用谱方法的基于原理的推导：\n1. 任何足够平滑的 T-周期函数 $g(t)$ 都可以展开为傅里叶级数 $g(t) = \\sum_{k=-\\infty}^{\\infty} \\hat{g}_k e^{i \\omega_k t}$，其中 $\\omega_k = \\frac{2\\pi k}{T}$。微分算子在此基上是对角作用的：\n   $$\n   \\frac{dg}{dt} = \\sum_{k=-\\infty}^{\\infty} (i \\omega_k) \\hat{g}_k e^{i \\omega_k t}, \\quad \\frac{d^2 g}{dt^2} = \\sum_{k=-\\infty}^{\\infty} (-\\omega_k^2) \\hat{g}_k e^{i \\omega_k t}.\n   $$\n   这是基于复指数是常系数微分算子特征函数这一基本事实。\n2. 将未知函数 $y(t) = \\sum_{k} \\hat{y}_k e^{i \\omega_k t}$ 和驱动力函数 $f(t) = \\sum_{k} \\hat{f}_k e^{i \\omega_k t}$ 都进行展开。代入 ODE 中，并利用线性和正交性，对每个整数 k，令 $e^{i \\omega_k t}$ 的系数相等：\n   $$\n   \\left(-\\omega_k^2\\right) \\hat{y}_k + 2 \\zeta \\omega_0 \\left(i \\omega_k\\right) \\hat{y}_k + \\omega_0^2 \\hat{y}_k = \\hat{f}_k.\n   $$\n   因此，对于每个模式 k，\n   $$\n   \\hat{y}_k = \\frac{\\hat{f}_k}{\\omega_0^2 - \\omega_k^2 + i \\, 2 \\zeta \\omega_0 \\omega_k}.\n   $$\n   当 $\\omega_0 > 0$ 时，分母对所有 $\\omega_k$ 都不为零，因此该映射是良定义的。在傅里叶基下的这种对角化表明，通过用传递函数 $H(i\\omega_k)$ 对驱动力的傅里叶系数进行滤波，可以直接获得周期性稳态解。\n3. 因此，对任何周期性驱动力的稳态响应由下式给出\n   $$\n   y_{\\mathrm{per}}(t) = \\sum_{k=-\\infty}^{\\infty} \\frac{\\hat{f}_k}{\\omega_0^2 - \\omega_k^2 + i \\, 2 \\zeta \\omega_0 \\omega_k} \\, e^{i \\omega_k t}.\n   $$\n   不需要进行时间步进，因为解是在频域中直接计算，然后变换回时域。\n\n使用快速傅里叶变换 (FFT) 的离散算法：\n- 用 N 个等距节点 $t_j = \\frac{j T}{N}$（其中 $j = 0, 1, \\dots, N-1$）离散化时间区间 $[0, T)$。\n- 在这些节点上对 $f(t)$ 进行采样，得到值 $f_j = f(t_j)$。\n- 通过 FFT 计算离散傅里叶变换 $\\hat{f}_k$。第 k 个 FFT 仓位对应的角频率是 $\\omega_k = 2\\pi \\nu_k$，其中 $\\nu_k$ 从 FFT 频率网格 $\\nu_k = \\operatorname{fftfreq}(N, \\Delta t)$ 获得，且 $\\Delta t = \\frac{T}{N}$。\n- 对每个仓位，计算谱响应\n  $$\n  \\hat{y}_k = \\frac{\\hat{f}_k}{\\omega_0^2 - \\omega_k^2 + i \\, 2 \\zeta \\omega_0 \\omega_k}.\n  $$\n- 使用逆 FFT 进行逆变换，得到网格上的样本 $y_j \\approx y_{\\mathrm{per}}(t_j)$。因为 $f(t)$ 和算子都是实的，数值解 $y_j$ 在机器精度内是实数；取实部以去除可忽略的虚部。\n\n用于验证的解析参考解：\n- 对于单音输入 $f(t) = \\cos(\\omega t)$，稳态解为 $y_{\\mathrm{per}}(t) = |H(i\\omega)| \\cos(\\omega t - \\phi)$，其中\n  $$\n  |H(i\\omega)| = \\frac{1}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2 \\zeta \\omega_0 \\omega)^2}}, \\quad \\phi = \\operatorname{atan2}(2 \\zeta \\omega_0 \\omega, \\omega_0^2 - \\omega^2).\n  $$\n  对于 $f(t) = \\sin(\\omega t)$，等效地有 $y_{\\mathrm{per}}(t) = |H(i\\omega)| \\sin(\\omega t - \\phi)$。\n- 对于常数输入 $f(t) = f_0$，只有零频模式有贡献，得到 $y_{\\mathrm{per}}(t) = \\frac{f_0}{\\omega_0^2}$。\n- 对于多谐波驱动，线性原理表明解是各个稳态响应之和。\n\n误差度量和输出：\n- 对于每个测试用例，计算最大绝对误差\n  $$\n  e = \\max_{0 \\le j \\le N-1} \\left| y_{\\mathrm{spec}}(t_j) - y_{\\mathrm{ref}}(t_j) \\right|.\n  $$\n  这里 $y_{\\mathrm{spec}}$ 是谱方法解，$y_{\\mathrm{ref}}$ 是根据上述公式构建的解析参考解。误差是无量纲实数。\n- 程序必须输出一行，包含列表 $[e_1,e_2,e_3,e_4]$，按顺序对应四个指定的用例。\n\n正确性成立的原因：\n- 连续算子在傅里叶基下是对角的，因为复指数是常系数微分算子的特征函数，其二阶导数的特征值为 $-\\omega^2$，一阶导数的特征值为 $i\\omega$。因此，从 $\\hat{f}_k$到 $\\hat{y}_k$ 的映射是通过传递函数分母进行代数除法。\n- 使用 FFT 的离散实现是一个周期上的伪谱配置法：它在周期性网格的采样频率上，在傅里叶域中强制满足 ODE。对于平滑的周期性数据，该方法谱收敛（指数级快速），因此对于平滑的正弦波和常数可以观察到很小的误差。\n\n实现细节：\n- 按规定，所有用例均使用 $N = 256$，$\\Delta t = \\frac{T}{N}$，$\\omega_k = 2\\pi \\operatorname{fftfreq}(N, \\Delta t)$。\n- 使用 $|H(i\\omega)|$ 和 $\\phi$ 的公式，在相应的角频率上构建解析参考解。\n- 以要求的单行格式报告四个误差。", "answer": "```python\nimport numpy as np\n\ndef spectral_steady_response(omega0, zeta, T, f_func, N):\n    \"\"\"\n    Compute the periodic steady-state solution y(t) on one period [0, T)\n    for y'' + 2*zeta*omega0*y' + omega0**2*y = f(t) using a Fourier spectral method.\n    \"\"\"\n    t = np.arange(N) * (T / N)\n    f_samples = f_func(t)\n\n    # FFT of forcing\n    Fk = np.fft.fft(f_samples)\n\n    # Angular frequency grid corresponding to FFT bins\n    dt = T / N\n    freq = np.fft.fftfreq(N, d=dt)  # in cycles per unit time\n    omega = 2 * np.pi * freq        # angular frequencies\n\n    # Transfer function denominator at i*omega: -omega^2 + i*2*zeta*omega0*omega + omega0^2\n    denom = (-omega**2) + 1j * (2.0 * zeta * omega0 * omega) + (omega0**2)\n\n    # Avoid division by zero is not needed here since omega0 > 0 ensures denom != 0 for all omega\n    Yk = Fk / denom\n\n    # Inverse FFT to get y on grid\n    y = np.fft.ifft(Yk).real\n    return t, y\n\ndef amp_phase(omega0, zeta, omega):\n    # Compute |H(i*omega)| and phase phi\n    re = omega0**2 - omega**2\n    im = 2.0 * zeta * omega0 * omega\n    mag = 1.0 / np.sqrt(re**2 + im**2)\n    phi = np.arctan2(im, re)\n    return mag, phi\n\ndef case1():\n    # Case 1: omega0=1, zeta=0.05, Omega=1, T=2*pi, N=256, f=sin(Omega t)\n    omega0 = 1.0\n    zeta = 0.05\n    Omega = 1.0\n    T = 2.0 * np.pi / Omega\n    N = 256\n    f_func = lambda t: np.sin(Omega * t)\n    t, y_spec = spectral_steady_response(omega0, zeta, T, f_func, N)\n    A, phi = amp_phase(omega0, zeta, Omega)\n    y_true = A * np.sin(Omega * t - phi)\n    err = np.max(np.abs(y_spec - y_true))\n    return err\n\ndef case2():\n    # Case 2: omega0=3, zeta=0.1, Omega=2, T=pi, N=256, f=sin(Omega t) + 0.5*cos(2 Omega t)\n    omega0 = 3.0\n    zeta = 0.1\n    Omega = 2.0\n    T = 2.0 * np.pi / Omega  # = pi\n    N = 256\n    f_func = lambda t: np.sin(Omega * t) + 0.5 * np.cos(2.0 * Omega * t)\n    t, y_spec = spectral_steady_response(omega0, zeta, T, f_func, N)\n    A1, phi1 = amp_phase(omega0, zeta, Omega)\n    A2, phi2 = amp_phase(omega0, zeta, 2.0 * Omega)\n    y_true = A1 * np.sin(Omega * t - phi1) + 0.5 * A2 * np.cos(2.0 * Omega * t - phi2)\n    err = np.max(np.abs(y_spec - y_true))\n    return err\n\ndef case3():\n    # Case 3: omega0=2, zeta=0.2, T=2*pi, N=256, f=1.5 constant\n    omega0 = 2.0\n    zeta = 0.2\n    T = 2.0 * np.pi\n    N = 256\n    f0 = 1.5\n    f_func = lambda t: f0 * np.ones_like(t)\n    t, y_spec = spectral_steady_response(omega0, zeta, T, f_func, N)\n    y_true = (f0 / (omega0**2)) * np.ones_like(t)\n    err = np.max(np.abs(y_spec - y_true))\n    return err\n\ndef case4():\n    # Case 4: omega0=2, zeta=0.01, Omega=1.98, T=2*pi/Omega, N=256, f=cos(Omega t)\n    omega0 = 2.0\n    zeta = 0.01\n    Omega = 1.98\n    T = 2.0 * np.pi / Omega\n    N = 256\n    f_func = lambda t: np.cos(Omega * t)\n    t, y_spec = spectral_steady_response(omega0, zeta, T, f_func, N)\n    A, phi = amp_phase(omega0, zeta, Omega)\n    y_true = A * np.cos(Omega * t - phi)\n    err = np.max(np.abs(y_spec - y_true))\n    return err\n\ndef solve():\n    results = [case1(), case2(), case3(), case4()]\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2437054"}, {"introduction": "傅里叶谱方法虽然强大，但其卓越的收敛性严格依赖于问题的周期性假设。当函数或其导数在周期域的边界上不连续时，近似解的质量会显著下降，这就是所谓的吉布斯现象（Gibbs phenomenon）。这个练习旨在让你通过代码，直观地观察并量化这一效应，通过对比周期性问题与非周期性问题，你将深刻理解纯傅里叶方法的适用边界，并认识到为何对于更一般性的边值问题，我们需要发展基于其他基函数（如切比雪夫多项式）的方法。[@problem_id:2437055]", "problem": "考虑未知函数 $u(x)$ 的一维边值问题，\n$$u''(x) = f(x), \\quad x \\in (0,1),$$\n其边界数据可以是周期性的，也可以是非周期性的。令 $u_{\\mathrm{per}}$ 表示满足周期性边界数据 $u(0)=u(1)$ 和 $u'(0)=u'(1)$ 的解，令 $u_{\\mathrm{D}}$ 表示满足非周期性狄利克雷（Dirichlet）边界数据 $u(0)=0$ 和 $u(1)=0$ 的解。\n\n对于任意正偶数 $N$，定义等距网格 $\\{x_j\\}_{j=0}^{N-1}$，其中 $x_j = j/N$。令 $f_N$ 为 $f$ 在此网格上的限制。定义 $u_N$ 为唯一的 1-周期三角多项式（空间平均值为零），其在三角多项式意义下的离散二阶导数等于移除了离散平均值的 $f_N$。更准确地说，在对应于该网格的离散傅里叶表示中，对于整数 $m$ 的波数 $k_m = 2\\pi m$，$u_N$ 满足\n$$ -(k_m)^2 \\widehat{u}_m = \\widehat{f}_m \\quad \\text{对于所有 } m \\neq 0 \\text{ 的模式} $$\n且 $\\widehat{u}_0 = 0$，其中帽子符号表示 $N$ 点网格上的离散傅里叶系数，波数的运算在模 $N$ 意义下理解。角度应以弧度为单位。\n\n对于下面的每个测试用例，您必须计算 $u_N$ 相较于网格上指定的目标解 $u_\\star$ 的离散 $L^2$ 误差，定义为\n$$ E_N = \\left(\\frac{1}{N} \\sum_{j=0}^{N-1} \\left(u_N(x_j) - u_\\star(x_j)\\right)^2 \\right)^{1/2}. $$\n所有答案必须是无单位的实数。\n\n使用以下包含四个案例的测试套件，并按所列顺序给出误差 $E_N$。每个案例都指定了 $f$、目标解 $u_\\star$ 和 $N$：\n\n- 案例 1（周期性，理想情况）：$f(x) = \\sin(2\\pi x)$，目标解 $u_\\star(x) = -\\sin(2\\pi x)/(2\\pi)^2$，$N = 64$。\n- 案例 2（非周期性狄利克雷，常数强迫项）：$f(x) = -2$，目标解 $u_\\star(x) = x(1-x)$，$N = 64$。\n- 案例 3（非周期性狄利克雷，端点导数不匹配）：$f(x) = -\\pi^2 \\sin(\\pi x)$，目标解 $u_\\star(x) = \\sin(\\pi x)$，$N = 64$。\n- 案例 4（案例 2 的细化）：$f(x) = -2$，目标解 $u_\\star(x) = x(1-x)$，$N = 128$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[E_{64}^{(1)},E_{64}^{(2)},E_{64}^{(3)},E_{128}^{(4)}]$，其中每个条目是相应案例的离散 $L^2$ 误差 $E_N$。", "solution": "在尝试任何求解之前，首先对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- **控制方程**：$u''(x) = f(x)$，对于 $x \\in (0,1)$。\n- **未知函数**：$u(x)$。\n- **边界条件**：\n    - 周期性：$u_{\\mathrm{per}}(0)=u_{\\mathrm{per}}(1)$ 且 $u'_{\\mathrm{per}}(0)=u'_{\\mathrm{per}}(1)$。\n    - 狄利克雷：$u_{\\mathrm{D}}(0)=0$ 且 $u_{\\mathrm{D}}(1)=0$。\n- **离散化**：\n    - 网格：等距点 $\\{x_j\\}_{j=0}^{N-1}$，其中 $x_j = j/N$，$N$ 为正偶数。\n    - 离散函数：$f_N$ 是 $f(x)$ 在网格上的限制。\n- **数值解定义**：$u_N$ 是一个空间平均值为零（$\\widehat{u}_0 = 0$）的 1-周期三角多项式。它由离散傅里叶空间中的关系式定义：\n  $$ -(k_m)^2 \\widehat{u}_m = \\widehat{f}_m \\quad \\text{对于所有 } m \\neq 0 \\text{ 的模式} $$\n  其中 $\\widehat{u}_m$ 和 $\\widehat{f}_m$ 是离散傅里叶系数，$k_m = 2\\pi m$ 是波数。右侧项被表述为对应“移除了离散平均值的 $f_N$”，这通过仅求解 $m \\neq 0$ 的模式得到隐式处理。\n- **误差度量**：离散 $L^2$ 误差，$$ E_N = \\left(\\frac{1}{N} \\sum_{j=0}^{N-1} \\left(u_N(x_j) - u_\\star(x_j)\\right)^2 \\right)^{1/2} $$。\n- **测试用例**：\n    1.  $f(x) = \\sin(2\\pi x)$，$u_\\star(x) = -\\sin(2\\pi x)/(2\\pi)^2$，$N = 64$。\n    2.  $f(x) = -2$，$u_\\star(x) = x(1-x)$，$N = 64$。\n    3.  $f(x) = -\\pi^2 \\sin(\\pi x)$，$u_\\star(x) = \\sin(\\pi x)$，$N = 64$。\n    4.  $f(x) = -2$，$u_\\star(x) = x(1-x)$，$N = 128$。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据所需准则对问题进行评估。\n\n- **科学依据**：该问题描述了应用傅里叶谱方法求解一维泊松（Poisson）方程。这是计算科学与工程中的一项基本且标准的技术。该方法和原理都已非常成熟。此准则已满足。\n- **适定性**：连续边值问题（包括周期性和狄利克雷）都是适定的。数值格式也是适定的。傅里叶系数的方程 $-(k_m)^2 \\widehat{u}_m = \\widehat{f}_m$ 对于所有非零波数（$k_m \\neq 0$）都可以求解 $\\widehat{u}_m$。$k_0 = 0$ 处的奇异性通过周期性泊松方程的可解性条件（要求强迫项的平均值为零，数值方法强制执行了这一点）以及通过将解的平均值设为零（$\\widehat{u}_0 = 0$）来施加唯一解来处理。此准则已满足。\n- **客观性**：问题使用了精确的数学语言和定义进行陈述。没有主观或含糊的术语。此准则已满足。\n- **完整性与一致性**：问题提供了构建解所需的所有必要函数、参数和定义。所提供的信息中没有矛盾。此准则已满足。\n\n### 步骤 3：结论与操作\n该问题是有效的。它具有科学合理性、适定性、客观性和自洽性。将提供一个解。\n\n### 解法\n该问题要求使用傅里叶谱方法在域 $x \\in (0,1)$ 上求解一维泊松方程 $u''(x) = f(x)$。傅里叶谱方法的核心原理是将微分算子在傅里叶空间中转换为代数算子。\n\n在 1-周期域上，函数 $u(x)$ 的傅里叶级数表示为 $u(x) = \\sum_{m=-\\infty}^{\\infty} \\check{u}_m e^{i 2\\pi m x}$。对 $x$ 求导对应于将第 $m$ 个傅里叶系数 $\\check{u}_m$ 乘以 $i 2\\pi m$。因此，二阶导数 $u''(x)$ 的傅里叶系数为 $(- (2\\pi m)^2) \\check{u}_m = -k_m^2 \\check{u}_m$，其中 $k_m = 2\\pi m$ 是波数。\n\n所规定的数值方法是这一原理的离散模拟。算法流程如下：\n\n1.  **离散化**：对于给定的偶数 $N$，将域 $[0,1)$ 离散为 $N$ 个等距点的网格，$x_j = j/N$，其中 $j = 0, 1, \\dots, N-1$。\n\n2.  **强迫项求值**：在这些网格点上计算强迫函数 $f(x)$，得到一个值向量 $\\mathbf{f} = [f(x_0), f(x_1), \\dots, f(x_{N-1})]^T$。\n\n3.  **正向傅里叶变换**：使用离散傅里叶变换（DFT）将向量 $\\mathbf{f}$ 变换到傅里叶空间，通常通过快速傅里叶变换（FFT）算法实现。这会产生离散傅里叶系数向量 $\\hat{\\mathbf{f}}$：\n    $$ \\widehat{f}_m = \\sum_{j=0}^{N-1} f(x_j) e^{-i 2\\pi m j / N} $$\n    索引 $m$ 对应离散频率，对于长度为 $L=1$ 的域，这些频率是整数。标准数值库提供例程来正确排序这些频率，通常为 $m \\in \\{0, 1, \\dots, N/2-1, -N/2, \\dots, -1\\}$。\n\n4.  **在傅里叶空间求解**：微分方程 $u''(x) = f(x)$ 变为离散傅里叶系数的代数方程。离散二阶导数算子对应于乘以 $-(k_m)^2$，其中 $k_m$ 是与离散频率 $m$ 相关联的波数。对于长度为 1 的域，$k_m = 2\\pi m$。系数 $\\widehat{u}_m$ 的问题是：\n    $$ -(k_m)^2 \\widehat{u}_m = \\widehat{f}_m $$\n    按照规定，此方程仅对非零模式（$m \\neq 0$）求解。对于零频率模式（$m=0$），波数 $k_0$ 为零，导致奇异性。这反映了周期性泊松问题仅在强迫项的积分（或离散和）为零时才有解。此外，解的唯一性仅在相差一个加性常数的情况下成立。问题通过指定解 $u_N$ 的平均值必须为零来解决此问题，这等效于将其第零个傅里叶系数设为零：$\\widehat{u}_0 = 0$。因此，解系数向量 $\\hat{\\mathbf{u}}$ 的计算方式如下：\n    $$ \\widehat{u}_m = \\begin{cases} 0 & \\text{if } m = 0 \\\\ -\\frac{\\widehat{f}_m}{k_m^2} & \\text{if } m \\neq 0 \\end{cases} $$\n\n5.  **傅里叶逆变换**：通过对系数向量 $\\hat{\\mathbf{u}}$ 应用离散傅里叶逆变换（IDFT，通过 IFFT 实现），可以恢复物理空间中的数值解 $u_N(x_j)$：\n    $$ u_N(x_j) = \\frac{1}{N} \\sum_{m=0}^{N-1} \\widehat{u}_m e^{i 2\\pi m j / N} $$\n    由于原始强迫函数 $f(x)$ 是实值的，解 $u_N(x_j)$ 也必须是实数。取 IFFT 结果的实部，以舍弃由浮点算术误差产生的可忽略的虚部。\n\n6.  **误差计算**：在网格 $x_j$ 上计算目标解 $u_\\star(x)$ 得到 $\\mathbf{u}_\\star$。然后将离散 $L^2$ 误差 $E_N$ 计算为数值解 $\\mathbf{u}_N$ 与目标解 $\\mathbf{u}_\\star$ 之间的均方根误差：\n    $$ E_N = \\sqrt{\\frac{1}{N} \\sum_{j=0}^{N-1} (u_N(x_j) - u_\\star(x_j))^2} $$\n\n### 测试用例分析\n- **案例 1**：$f(x) = \\sin(2\\pi x)$，$u_\\star(x) = -\\sin(2\\pi x)/(2\\pi)^2$，$N = 64$。函数 $f(x)$ 是一个单一的、1-周期的、平均值为零的傅里叶模式。目标解 $u_\\star(x)$ 是平均值为零的精确周期解。对于解包含在三角多项式基函数中的问题，傅里叶谱方法是精确的。因此，误差 $E_{64}$ 预计将接近机器精度。\n\n- **案例 2**：$f(x) = -2$，$u_\\star(x) = x(1-x)$，$N = 64$。目标解 $u_\\star(x)$ 满足狄利克雷边界条件 $u_\\star(0) = u_\\star(1) = 0$。然而，它不是一个 1-周期的函数，因为其在边界处的导数不匹配：$u'_\\star(0) = 1$ 而 $u'_\\star(1) = -1$。谱方法计算的是一个周期解 $u_N$。误差 $u_N - u_\\star$ 主要源于周期性三角多项式无法精确表示非周期目标函数，尤其是在边界处。这种边界条件不匹配导致收敛缓慢（吉布斯现象，Gibbs phenomenon），误差 $E_{64}$ 将会很大。\n\n- **案例 3**：$f(x) = -\\pi^2 \\sin(\\pi x)$，$u_\\star(x) = \\sin(\\pi x)$，$N = 64$。此案例与案例 2 类似。目标解 $u_\\star(x)$ 满足狄利克雷边界条件，但不满足周期性条件，因为 $u'_\\star(0) = \\pi \\neq u'_\\star(1) = -\\pi$。出于同样的原因，预计误差会很大。\n\n- **案例 4**：$f(x) = -2$，$u_\\star(x) = x(1-x)$，$N = 128$。这是对案例 2 的网格细化。虽然预计误差会很大，但增加 $N$ 应该会减小误差。误差减小的速率将是代数阶的（对于某个小的 $p>0$ 是 $O(N^{-p})$），而不是在光滑周期性问题中观察到的指数收敛。将此结果与案例 2 进行比较，将显示这种次优的收敛性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the discrete L2 error for a Fourier spectral solution to u''=f\n    for four different test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (periodic, happy path)\n        (lambda x: np.sin(2 * np.pi * x), \n         lambda x: -np.sin(2 * np.pi * x) / (2 * np.pi)**2, \n         64),\n        # Case 2 (non-periodic Dirichlet, constant forcing)\n        (lambda x: -2.0 + 0*x, \n         lambda x: x * (1 - x), \n         64),\n        # Case 3 (non-periodic Dirichlet, endpoint-derivative mismatch)\n        (lambda x: -(np.pi**2) * np.sin(np.pi * x), \n         lambda x: np.sin(np.pi * x), \n         64),\n        # Case 4 (refinement of Case 2)\n        (lambda x: -2.0 + 0*x, \n         lambda x: x * (1 - x), \n         128),\n    ]\n\n    results = []\n    for f_func, u_star_func, N in test_cases:\n        # 1. Define the grid\n        # x_j = j/N for j = 0, ..., N-1\n        x = np.arange(N) / N\n\n        # 2. Evaluate the forcing function on the grid\n        f_vals = f_func(x)\n\n        # 3. Compute the DFT of the forcing function\n        f_hat = np.fft.fft(f_vals)\n\n        # 4. Define wavenumbers and solve in Fourier space\n        # Frequencies m = [0, 1, ..., N/2-1, -N/2, ..., -1] for L=1\n        # The grid spacing d = 1/N\n        freqs = np.fft.fftfreq(N, d=1.0/N)\n        # Wavenumbers k_m = 2*pi*m\n        k = 2 * np.pi * freqs\n        \n        # The equation for Fourier coefficients is -(k_m)^2 * u_hat_m = f_hat_m\n        # We solve for u_hat_m = -f_hat_m / k_m^2 for m != 0\n        # and set u_hat_0 = 0\n        \n        # To avoid division by zero for k_0 = 0, we can use np.divide with a 'where' clause.\n        # Initialize u_hat to zeros.\n        u_hat = np.zeros_like(f_hat, dtype=complex)\n        \n        # Calculate k^2, avoiding direct computation at k=0 to prevent warnings.\n        k_squared = k**2\n        \n        # The condition k != 0 is equivalent to freqs != 0\n        nonzero_mask = (freqs != 0)\n        \n        u_hat[nonzero_mask] = -f_hat[nonzero_mask] / k_squared[nonzero_mask]\n\n        # 5. Transform back to physical space via Inverse FFT\n        u_N_vals = np.fft.ifft(u_hat)\n        \n        # The solution should be real; take the real part to discard numerical noise.\n        u_N_vals = u_N_vals.real\n\n        # 6. Evaluate the target solution and compute the error\n        u_star_vals = u_star_func(x)\n        \n        # Discrete L2 error (Root Mean Square Error)\n        error = np.sqrt(np.mean((u_N_vals - u_star_vals)**2))\n        results.append(error)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.10e}' for r in results)}]\")\n\nsolve()\n```", "id": "2437055"}, {"introduction": "“谱方法”中的“谱”并不仅仅局限于傅里叶级数。其更深层的思想是利用一个相关算子（如拉普拉斯算子）的特征函数作为展开基底。这一概念可以被有力地推广到非结构化域，例如通过图拉普拉斯算子（graph Laplacian）的特征向量来处理网络或非结构化网格上的问题。在这个练习中，你将求解一个定义在图上的扩散方程，这个过程将展示谱分析的基本原理如何应用于复杂的、非网格状的几何结构，为你理解从经典谱方法到图信号处理等现代领域的联系架起一座桥梁。[@problem_id:2436990]", "problem": "考虑一个具有 $N=5$ 个节点（标记为 $\\{0,1,2,3,4\\}$）的无向、加权、连通图。其边集和权重如下所示（每条无向边 $\\{i,j\\}$ 具有对称权重 $w_{ij}=w_{ji}$）：\n- $\\{0,1\\}$，权重 $1.0$，\n- $\\{0,2\\}$，权重 $0.4$，\n- $\\{0,4\\}$，权重 $0.2$，\n- $\\{1,2\\}$，权重 $0.3$，\n- $\\{1,3\\}$，权重 $0.8$，\n- $\\{2,4\\}$，权重 $0.6$，\n- $\\{3,4\\}$，权重 $0.5$。\n\n定义加权邻接矩阵 $A \\in \\mathbb{R}^{5 \\times 5}$，其中若节点 $i$ 和 $j$ 之间存在边，则 $A_{ij}=w_{ij}$，否则 $A_{ij}=0$，且对于所有 $i$，$A_{ii}=0$。定义对角度矩阵 $D \\in \\mathbb{R}^{5 \\times 5}$，其中 $D_{ii}=\\sum_{j=0}^{4} A_{ij}$。组合图拉普拉斯算子为 $L=D-A$。\n\n设 $u(t) \\in \\mathbb{R}^{5}$ 是网络上线性时不变偏微分方程 (PDE) 的解\n$$\n\\frac{d}{dt}u(t) = -\\alpha L\\,u(t) + b, \\quad u(0)=u_0,\n$$\n其中 $\\alpha \\ge 0$ 是一个标量扩散参数，$b \\in \\mathbb{R}^{5}$ 是一个常数源向量，$u_0 \\in \\mathbb{R}^{5}$ 是初始条件。对于下方的每个测试用例，计算在指定的最终时间 $T$ 的状态 $u(T)$。\n\n根据上述图构建 $L$，并对每个测试用例精确计算 $u(T)$（允许数值舍入误差），然后将 $u(T)$ 的每个分量四舍五入到小数点后六位。\n\n测试套件（每个元组为 $(\\alpha, T, u_0, b)$，所有向量均按节点顺序 $[0,1,2,3,4]$ 排列）：\n1. $\\left(1.0,\\;1.0,\\;[1.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0],\\;[0.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0]\\right)$\n2. $\\left(0.0,\\;2.5,\\;[-1.0,\\,2.0,\\,0.0,\\,1.0,\\,0.0],\\;[0.3,\\,-0.2,\\,0.1,\\,0.0,\\,-0.1]\\right)$\n3. $\\left(2.0,\\;0.0,\\;[0.5,\\,-0.5,\\,1.0,\\,0.0,\\,2.0],\\;[1.0,\\,-1.0,\\,0.0,\\,0.5,\\,-0.5]\\right)$\n4. $\\left(0.7,\\;0.8,\\;[0.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0],\\;[1.0,\\,-0.5,\\,0.0,\\,0.25,\\,-0.25]\\right)$\n\n最终输出格式：\n您的程序必须打印单行内容，该行包含一个由方括号括起来的逗号分隔列表，其中每个条目对应给定顺序的一个测试用例，其本身是 $u(T)$ 的5个分量按节点顺序 $[0,1,2,3,4]$ 排列并四舍五入后的列表。输出中不得包含任何空格。具体而言，输出必须采用以下格式\n[ [x_{1,0},x_{1,1},x_{1,2},x_{1,3},x_{1,4}], [x_{2,0},...,x_{2,4}], [x_{3,0},...,x_{3,4}], [x_{4,0},...,x_{4,4}] ]\n但无空格，且每个 $x_{k,i}$ 都四舍五入到小数点后六位。", "solution": "问题陈述已经过验证，被认定为科学上合理、适定且完整。它描述了一个关于线性常微分方程组的标准初值问题，该问题代表了图上的一个扩散过程。所有必要的数据和定义都已提供，不存在内部矛盾或歧义。因此，我将继续提供完整的解法。\n\n控制方程是一个线性时不变 (LTI) 系统，由下式给出\n$$\n\\frac{d}{dt}u(t) = -\\alpha L\\,u(t) + b, \\quad u(0)=u_0\n$$\n其中 $u(t) \\in \\mathbb{R}^{N}$ 是状态向量，$L \\in \\mathbb{R}^{N \\times N}$ 是组合图拉普拉斯算子，$\\alpha \\ge 0$ 是标量扩散参数，$b \\in \\mathbb{R}^{N}$ 是常数源向量，$u_0 \\in \\mathbb{R}^{N}$ 是初始条件。此处，$N=5$。\n\n该系统的解析解可以通过特征分解方法求得，这是合适的，因为无向图的图拉普拉斯算子 $L$ 是一个实对称矩阵。因此，$L$ 可由其特征向量构成的正交矩阵 $V$ 对角化：\n$$\nL = V \\Lambda V^T\n$$\n其中 $\\Lambda$ 是由 $L$ 的实特征值 $\\lambda_i$ 构成的对角矩阵，而 $V$ 是一个正交矩阵（$V^T V = V V^T = I$），其列是相应的标准正交特征向量。这种分解是图上谱方法的核心。\n\n我们通过将状态向量 $u(t)$ 投影到 $L$ 的特征基上引入变量替换：\n$$\nv(t) = V^T u(t) \\quad \\iff \\quad u(t) = V v(t)\n$$\n将此代入控制方程可得：\n$$\n\\frac{d}{dt}(V v(t)) = -\\alpha (V \\Lambda V^T) (V v(t)) + b\n$$\n$$\nV \\frac{d v(t)}{dt} = -\\alpha V \\Lambda v(t) + b\n$$\n从左侧乘以 $V^T$ 并利用 $V$ 的正交性：\n$$\n\\frac{d v(t)}{dt} = -\\alpha \\Lambda v(t) + V^T b\n$$\n这将原始的耦合系统转化为一组 $N$ 个独立的标量线性常微分方程。令 $c = V^T b$。第 $i$ 个方程为：\n$$\n\\frac{d v_i(t)}{dt} = -\\alpha \\lambda_i v_i(t) + c_i, \\quad v_i(0) = (V^T u_0)_i\n$$\n每个分量 $v_i(t)$ 的解取决于 $\\lambda_i$ 的值。对于连通图，拉普拉斯算子 $L$ 有一个单特征值 $\\lambda_0 = 0$，所有其他特征值均为严格正值（对于 $i > 0$，$\\lambda_i > 0$）。\n\n情况 1：$\\alpha \\lambda_i \\neq 0$。解为\n$$\nv_i(t) = e^{-\\alpha \\lambda_i t} v_i(0) + \\frac{1 - e^{-\\alpha \\lambda_i t}}{\\alpha \\lambda_i} c_i\n$$\n情况 2：$\\alpha \\lambda_i = 0$。方程变为 $\\frac{d v_i(t)}{dt} = c_i$，其解为\n$$\nv_i(t) = v_i(0) + c_i t\n$$\n这种情况适用于 $\\alpha=0$ 或 $\\lambda_i=0$。所提供的测试用例包含 $\\alpha=0$ 和 $T=0$ 的情况，这些作为简单的特殊情况处理：\n- 若 $T=0$，解显然为 $u(T) = u(0) = u_0$。\n- 若 $\\alpha=0$，方程简化为 $\\frac{d u(t)}{dt} = b$，其解为 $u(T) = u_0 + bT$。\n\n一旦在最终时间 $T$ 计算出向量 $v(T)=[v_0(T), v_1(T), \\dots, v_{N-1}(T)]^T$，就可以通过逆变换恢复原始基中的解：\n$$\nu(T) = V v(T)\n$$\n实现将首先根据给定的图结构构建拉普拉斯矩阵 $L$。然后，对每个测试用例，它将应用上面推导出的适当公式来计算解 $u(T)$。对于需要特征分解的一般情况，我们将使用数值稳健的线性代数例程。最终 $u(T)$ 的分量将按照问题说明进行四舍五入和格式化。\n\n该图由 $N=5$ 个节点及以下边和权重定义：$w_{01}=1.0$、$w_{02}=0.4$、$w_{04}=0.2$、$w_{12}=0.3$、$w_{13}=0.8$、$w_{24}=0.6$、$w_{34}=0.5$。\n邻接矩阵 $A$ 为：\n$$\nA = \\begin{pmatrix}\n0.0 & 1.0 & 0.4 & 0.0 & 0.2 \\\\\n1.0 & 0.0 & 0.3 & 0.8 & 0.0 \\\\\n0.4 & 0.3 & 0.0 & 0.0 & 0.6 \\\\\n0.0 & 0.8 & 0.0 & 0.0 & 0.5 \\\\\n0.2 & 0.0 & 0.6 & 0.5 & 0.0\n\\end{pmatrix}\n$$\n对角度矩阵 $D$ 通过对 $A$ 的行求和得到：$D_{00}=1.6$、$D_{11}=2.1$、$D_{22}=1.3$、$D_{33}=1.3$、$D_{44}=1.3$。\n图拉普拉斯算子 $L=D-A$ 为：\n$$\nL = \\begin{pmatrix}\n 1.6 & -1.0 & -0.4 &  0.0 & -0.2 \\\\\n-1.0 &  2.1 & -0.3 & -0.8 &  0.0 \\\\\n-0.4 & -0.3 &  1.3 &  0.0 & -0.6 \\\\\n 0.0 & -0.8 &  0.0 &  1.3 & -0.5 \\\\\n-0.2 &  0.0 & -0.6 & -0.5 &  1.3\n\\end{pmatrix}\n$$\n该矩阵将用于所有测试用例的计算。", "answer": "```python\nimport numpy as np\n\ndef compute_u_T(L, alpha, T, u0, b):\n    \"\"\"\n    Computes the solution u(T) for the differential equation du/dt = -alpha*L*u + b.\n    \"\"\"\n    N = L.shape[0]\n\n    # Handle special cases for T=0 and alpha=0\n    if np.isclose(T, 0.0):\n        return u0\n    \n    if np.isclose(alpha, 0.0):\n        return u0 + b * T\n\n    # General case: alpha > 0 and T > 0\n    # The solution is found via eigendecomposition of L.\n    # L = V Lambda V^T\n    # u(T) = V [exp(-alpha*Lambda*T) V^T u0 + G V^T b]\n    # where G is a diagonal matrix with elements g_i.\n    \n    # Eigendecomposition of the symmetric matrix L\n    lambdas, V = np.linalg.eigh(L)\n    \n    # Transform initial condition and source term to the eigenbasis\n    v0 = V.T @ u0\n    c = V.T @ b\n    \n    # Compute the solution v(T) in the eigenbasis\n    vt = np.zeros(N, dtype=np.float64)\n    \n    for i in range(N):\n        lam = lambdas[i]\n        \n        # Homogeneous part of the solution for v_i(T)\n        hom_part = np.exp(-alpha * lam * T) * v0[i]\n        \n        # Inhomogeneous part of the solution for v_i(T)\n        inhom_part = 0.0\n        # The form of the inhomogeneous term depends on whether lambda_i is zero\n        if np.isclose(lam, 0.0):\n            # For lambda_i = 0, the coefficient of c_i is T\n            inhom_part = c[i] * T\n        else:\n            # For lambda_i != 0, the coefficient is (1-exp(-a*l*T))/(a*l)\n            # We use a numerically stable implementation using np.expm1(x) for e^x-1\n            x = -alpha * lam * T\n            coeff = -np.expm1(x) / (alpha * lam)\n            inhom_part = c[i] * coeff\n            \n        vt[i] = hom_part + inhom_part\n        \n    # Transform the solution back to the original basis\n    uT = V @ vt\n    \n    return uT\n\ndef solve():\n    \"\"\"\n    Main function to define the problem, run test cases, and print the output.\n    \"\"\"\n    # Define graph properties\n    N = 5\n    edges_with_weights = {\n        (0, 1): 1.0, (0, 2): 0.4, (0, 4): 0.2,\n        (1, 2): 0.3, (1, 3): 0.8,\n        (2, 4): 0.6,\n        (3, 4): 0.5\n    }\n\n    # Construct the adjacency matrix A\n    A = np.zeros((N, N))\n    for (i, j), w in edges_with_weights.items():\n        A[i, j] = A[j, i] = w\n\n    # Construct the degree matrix D\n    D = np.diag(np.sum(A, axis=1))\n\n    # Construct the combinatorial graph Laplacian L\n    L = D - A\n\n    # Test suite from the problem description\n    test_cases = [\n        (1.0, 1.0, [1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0]),\n        (0.0, 2.5, [-1.0, 2.0, 0.0, 1.0, 0.0], [0.3, -0.2, 0.1, 0.0, -0.1]),\n        (2.0, 0.0, [0.5, -0.5, 1.0, 0.0, 2.0], [1.0, -1.0, 0.0, 0.5, -0.5]),\n        (0.7, 0.8, [0.0, 0.0, 0.0, 0.0, 0.0], [1.0, -0.5, 0.0, 0.25, -0.25])\n    ]\n\n    all_results = []\n    for case in test_cases:\n        alpha, T, u0_list, b_list = case\n        u0 = np.array(u0_list, dtype=np.float64)\n        b = np.array(b_list, dtype=np.float64)\n        \n        u_T = compute_u_T(L, alpha, T, u0, b)\n        \n        # Append the result vector to the list of all results\n        all_results.append(u_T)\n\n    # Format the final output string as specified\n    formatted_results = []\n    for res_vec in all_results:\n        # Format each number to exactly six decimal places\n        str_vec = [f\"{x:.6f}\" for x in res_vec]\n        formatted_results.append(f\"[{','.join(str_vec)}]\")\n    \n    final_output_str = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```", "id": "2436990"}]}