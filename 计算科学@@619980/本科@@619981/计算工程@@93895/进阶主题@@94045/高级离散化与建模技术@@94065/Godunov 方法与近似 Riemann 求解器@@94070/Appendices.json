{"hands_on_practices": [{"introduction": "理论学习的最佳方式莫过于亲手实践。这项练习将引导你为最简单的双曲型偏微分方程——线性平流方程——实现戈杜诺夫方法。通过编写一阶迎风格式的代码，你将建立起对信息传播和守恒型有限体积法核心思想的直观理解，为后续更复杂的挑战奠定坚实基础。[@problem_id:2448979]", "problem": "考虑周期性域 $\\Omega = [0,1]$ 上的一维线性平流方程，\n$$\nu_t + a\\,u_x = 0,\n$$\n其平流速度 $a \\in \\mathbb{R}$ 为常数，初始条件为 $u(x,0) = u_0(x)$，其中 $x \\in \\Omega$ 且 $t \\ge 0$。设空间网格是均匀的，有 $N$ 个网格单元，宽度为 $\\Delta x = 1/N$，网格中心为 $x_i = \\left(i+\\tfrac{1}{2}\\right)\\Delta x$，其中 $i = 0,1,\\dots,N-1$。该方法采用守恒型有限体积格式，在时间层 $t^n$ 上对网格平均值 $u_i^n$ 进行演化，其数值通量通过求解每个网格界面上的局部黎曼问题的精确自相似解来计算。在 $x=0$ 和 $x=1$ 处施加周期性条件。时间步长 $\\Delta t$ 必须满足 Courant–Friedrichs–Lewy (CFL) 条件 $|a|\\,\\Delta t \\le \\Delta x$。当 $|a|>0$ 时，选择一个库朗数 $\\nu \\in (0,1]$，使得 $\\Delta t = \\nu \\,\\Delta x/|a|$；当 $a=0$ 时，可取任意 $\\Delta t>0$。当最终时间 $T$ 不是 $\\Delta t$ 的整数倍时，必须缩短最后一个时间步，以便精确地在 $t=T$ 刻停止。精确解是周期性平移 $u(x,T) = u_0\\!\\big((x - aT)\\bmod 1\\big)$。在 $t=T$ 时刻，离散 $L^1$ 误差的计算公式为\n$$\nE_{L^1} = \\sum_{i=0}^{N-1} \\left| u_i(T) - u_0\\!\\big((x_i - aT)\\bmod 1\\big) \\right|\\,\\Delta x.\n$$\n\n对于下面的每个测试用例，你的程序必须计算在时间 $T$ 时的数值解，并输出相应的 $E_{L^1}$ 值（浮点数）。不涉及任何物理单位。三角函数中出现的角度均以弧度为单位。\n\n测试套件：\n- 用例 $1$（间断剖面，正速度）：$a=1$，$N=200$，$\\nu=0.9$，$T=0.25$，其中\n  $$\n  u_0(x) = \\begin{cases}\n  1, & 0.1 \\le x < 0.3,\\\\\n  0, & \\text{其它情况},\n  \\end{cases}\n  $$\n  在 $[0,1]$ 上作周期性解释。\n- 用例 $2$（光滑剖面，负速度）：$a=-0.7$，$N=200$，$\\nu=0.9$，$T=0.4$，其中\n  $$\n  u_0(x) = \\sin(2\\pi x).\n  $$\n- 用例 $3$（零速边界情况）：$a=0$，$N=200$，$\\nu=0.9$，$T=0.3$，其中\n  $$\n  u_0(x) = \\begin{cases}\n  1, & x < 0.5,\\\\\n  0, & x \\ge 0.5,\n  \\end{cases}\n  $$\n  在 $[0,1]$ 上作周期性解释。\n- 用例 $4$（稳定性边界 $\\nu=1$）：$a=1$，$N=100$，$\\nu=1$，$T=0.37$，其中\n  $\n  u_0(x) = \\cos(2\\pi x).\n  $\n\n最终输出格式：你的程序应生成单行输出，其中包含按用例 $1$ 到 $4$ 的顺序排列的四个 $L^1$ 误差，格式为一个用方括号括起来的逗号分隔列表。每个浮点值必须四舍五入到 $8$ 位小数。例如，使用占位符值的输出将如下所示\n$\n[\\!0.12345678,0.00000000,0.31415927,0.27182818\\!].\n$", "solution": "该问题要求我们对一维线性平流方程进行数值求解，\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0,\n$$\n该方程定义在周期性域 $\\Omega = [0,1]$上，具有恒定的平流速度 $a \\in \\mathbb{R}$。初始条件由 $u(x,0) = u_0(x)$ 给出。我们将采用一种守恒型有限体积方法。\n\n这个问题是计算流体力学中一个标准的、适定的问题，并且在科学上是合理的。它描述了一阶迎风法，这是双曲守恒律的一个基本格式。所有参数、条件和目标都定义清晰且一致。该问题是有效的。\n\n求解过程如下：\n\n首先，我们将空间域 $\\Omega$ 离散化为 $N$ 个均匀的网格单元 $C_i = [x_{i-1/2}, x_{i+1/2}]$，其中 $i=0, \\dots, N-1$。每个单元的宽度为 $\\Delta x = 1/N$。网格界面的位置在 $x_{i+1/2} = (i+1)\\Delta x$。网格中心的位置在 $x_i = (i+1/2)\\Delta x$。数值解由离散时间层 $t^n$ 上的网格平均值组成：\n$$\nu_i^n \\approx \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x, t^n) \\, dx.\n$$\n将偏微分方程（PDE）在网格单元 $C_i$ 和时间区间 $[t^n, t^{n+1}]$ 上积分，可以得到网格平均值的精确关系式：\n$$\nu_i^{n+1} = u_i^n - \\frac{1}{\\Delta x} \\int_{t^n}^{t^{n+1}} \\left( f(u(x_{i+1/2}, t)) - f(u(x_{i-1/2}, t)) \\right) dt,\n$$\n其中 $f(u) = au$ 是线性平流方程的通量函数。用在 $t^n$ 时刻的单点估值来近似时间积分，可得到半离散守恒形式：\n$$\n\\frac{du_i}{dt} = -\\frac{1}{\\Delta x} (F_{i+1/2} - F_{i-1/2}),\n$$\n其中 $F_{i+1/2}$ 和 $F_{i-1/2}$ 是网格界面上的数值通量。使用前向欧拉时间积分可得到全离散形式：\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} (F_{i+1/2}^n - F_{i-1/2}^n).\n$$\n问题规定，数值通量需要通过求解每个界面上的局部黎曼问题的精确解来确定。这定义了 Godunov 方法。对于线性平流方程，初始状态为 $u_L$ 和 $u_R$ 的黎曼问题的解是，当 $x/t < a$ 时 $u(x/t) = u_L$，当 $x/t > a$ 时 $u(x/t) = u_R$。界面处（$x/t=0$）的值取自迎风方向。\n因此，界面 $x_{i+1/2}$ 处的状态是：如果 $a>0$，则 $u_{i+1/2} = u_i^n$；如果 $a<0$，则 $u_{i+1/2} = u_{i+1}^n$。\n因此，数值通量 $F_{i+1/2}^n = f(u_{i+1/2}) = a u_{i+1/2}$ 为：\n$$\nF_{i+1/2}^n = \\begin{cases}\na u_i^n, & a > 0, \\\\\na u_{i+1}^n, & a < 0, \\\\\n0, & a = 0.\n\\end{cases}\n$$\n这是一阶迎风通量。\n\n更新格式根据 $a$ 的符号而不同：\n情况 1：$a > 0$。通量差为 $F_{i+1/2}^n - F_{i-1/2}^n = a u_i^n - a u_{i-1}^n$。更新格式为：\n$$\nu_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x} (u_i^n - u_{i-1}^n).\n$$\n情况 2：$a < 0$。通量差为 $F_{i+1/2}^n - F_{i-1/2}^n = a u_{i+1}^n - a u_i^n$。更新格式为：\n$$\nu_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x} (u_{i+1}^n - u_i^n).\n$$\n情况 3：$a=0$。通量为零，因此 $u_i^{n+1} = u_i^n$。解是静态的。\n\n库朗数定义为 $\\nu = |a| \\Delta t / \\Delta x$。更新格式可以用 $\\nu$ 来表示：\n对于 $a > 0$：$u_i^{n+1} = u_i^n - \\nu (u_i^n - u_{i-1}^n)$。\n对于 $a < 0$：$u_i^{n+1} = u_i^n + \\nu (u_{i+1}^n - u_i^n)$，因为 $a\\Delta t/\\Delta x = -|a|\\Delta t/\\Delta x = -\\nu$。\n周期性边界条件意味着索引按模 $N$ 处理，即 $u_{-1}^n = u_{N-1}^n$ 且 $u_N^n = u_0^n$。\n\n当 $a \\neq 0$ 时，时间步长为 $\\Delta t = \\nu \\Delta x / |a|$。模拟从 $t=0$ 运行到 $t=T$。如果 $T$ 不是 $\\Delta t$ 的整数倍，则将最后一个时间步调整为较小的 $T - t^n$，以确保在最终时间精确停止。\n\n初始网格平均值 $u_i^0$ 的正式定义为 $u_i^0 = \\frac{1}{\\Delta x} \\int_{i\\Delta x}^{(i+1)\\Delta x} u_0(x) \\, dx$。对于光滑的初始剖面（用例 $2$ 和 $4$），一个二阶精确的近似是 $u_i^0 \\approx u_0(x_i)$。对于间断剖面（用例 $1$ 和 $3$），间断点与网格界面对齐，即它们出现在 $\\Delta x$ 的整数倍处。在这种特殊情况下，网格平均值 $u_i^0$ 精确等于网格中心处的点值 $u_0(x_i)$。因此，对于所有给定的测试用例，我们可以通过点采样来初始化解：$u_i^0 = u_0(x_i)$。\n\n最后，通过将数值解 $u_i(T)$ 与在网格中心处求值的精确解进行比较，来计算 $t=T$ 时的离散 $L^1$ 误差。精确解为 $u(x,T) = u_0((x - aT) \\pmod 1)$。误差为：\n$$\nE_{L^1} = \\sum_{i=0}^{N-1} \\left| u_i(T) - u_0\\big((x_i - aT)\\bmod 1\\big) \\right|\\,\\Delta x.\n$$\n模运算符确保 $u_0$ 的自变量被映射回域 $[0,1]$ 中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation using a first-order upwind\n    finite volume method for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: a=1, N=200, nu=0.9, T=0.25, u0=square pulse\n        {\n            \"a\": 1.0, \"N\": 200, \"nu\": 0.9, \"T\": 0.25,\n            \"u0_func\": lambda x: np.where((x >= 0.1) & (x < 0.3), 1.0, 0.0),\n        },\n        # Case 2: a=-0.7, N=200, nu=0.9, T=0.4, u0=sine wave\n        {\n            \"a\": -0.7, \"N\": 200, \"nu\": 0.9, \"T\": 0.4,\n            \"u0_func\": lambda x: np.sin(2 * np.pi * x),\n        },\n        # Case 3: a=0, N=200, nu=0.9, T=0.3, u0=step function\n        {\n            \"a\": 0.0, \"N\": 200, \"nu\": 0.9, \"T\": 0.3,\n            \"u0_func\": lambda x: np.where(x < 0.5, 1.0, 0.0),\n        },\n        # Case 4: a=1, N=100, nu=1, T=0.37, u0=cosine wave\n        {\n            \"a\": 1.0, \"N\": 100, \"nu\": 1.0, \"T\": 0.37,\n            \"u0_func\": lambda x: np.cos(2 * np.pi * x),\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        a = case[\"a\"]\n        N = case[\"N\"]\n        nu = case[\"nu\"]\n        T = case[\"T\"]\n        u0_func = case[\"u0_func\"]\n\n        # Spatial grid setup\n        dx = 1.0 / N\n        x = (np.arange(N) + 0.5) * dx\n\n        # Initialization of cell averages\n        # For the given problems, discontinuities are grid-aligned, so a\n        # point-wise sampling at cell centers is equivalent to cell-averaging.\n        u = u0_func(x)\n\n        t = 0.0\n\n        if a == 0.0:\n            # For a=0, the solution is static. u(T) is the same as u(0).\n            # No time stepping is necessary.\n            pass\n        else:\n            # Time step based on CFL condition\n            dt = nu * dx / abs(a)\n            \n            # Time-stepping loop\n            while t < T:\n                # Ensure the last step lands exactly on T\n                current_dt = min(dt, T - t)\n                \n                # The upwind scheme is implemented using vector operations and np.roll\n                # for efficient handling of periodic boundary conditions.\n                if a > 0:\n                    # Information propagates from left to right (increasing index)\n                    # Flux at interface i+1/2 is F = a * u_i\n                    # Update: u_i^{n+1} = u_i^n - (dt/dx) * (F_{i+1/2} - F_{i-1/2})\n                    # F_{i-1/2} corresponds to flux from u_{i-1}\n                    u_left = np.roll(u, 1)\n                    u = u - (a * current_dt / dx) * (u - u_left)\n                else: # a < 0\n                    # Information propagates from right to left (decreasing index)\n                    # Flux at interface i+1/2 is F = a * u_{i+1}\n                    # Update: u_i^{n+1} = u_i^n - (dt/dx) * (F_{i+1/2} - F_{i-1/2})\n                    # F_{i-1/2} corresponds to flux from u_i\n                    u_right = np.roll(u, -1)\n                    u = u - (a * current_dt / dx) * (u_right - u)\n                \n                t += current_dt\n\n        # Calculate exact solution at time T at cell centers\n        # The Python modulo operator % handles negative arguments correctly for this periodic domain.\n        x_shifted = (x - a * T) % 1.0\n        u_exact = u0_func(x_shifted)\n        \n        # Calculate discrete L1 error\n        l1_error = np.sum(np.abs(u - u_exact)) * dx\n        results.append(l1_error)\n\n    # Format the output as specified\n    formatted_results = [f\"{r:.8f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2448979"}, {"introduction": "不同的数值格式在求解相同问题时会表现出不同的特性。本练习旨在让你比较戈杜诺夫（迎风）格式与另一种经典格式——Lax-Friedrichs 格式，并聚焦于一个关键特性：数值耗散。你将学习使用总变差（Total Variation, TV）作为量化工具，来衡量一个格式在多大程度上模糊了不连续界面，从而掌握一种评估和选择数值方法的实用技能。[@problem_id:2397651]", "problem": "考虑标量线性平流方程 $u_t + a\\,u_x = 0$，定义在周期性域 $x \\in [0,L)$ 上，其中平流速度 $a \\in \\mathbb{R}$ 为常数。初始条件为一个由下式定义的孤立方波（顶帽函数）：\n$$\nu(x,0) = \\begin{cases}\nu_{\\text{high}}, & \\text{if } (x - x_0) \\bmod L \\in [0,w),\\\\\nu_{\\text{low}}, & \\text{otherwise},\n\\end{cases}\n$$\n其中 $L$、$x_0$、$w$、$u_{\\text{low}}$ 和 $u_{\\text{high}}$均为给定常数。空间域被划分为 $M$ 个宽度为 $\\Delta x = L/M$ 的均匀单元，单元中心为 $x_i = (i + \\tfrac{1}{2})\\,\\Delta x$，其中 $i \\in \\{0,1,\\dots,M-1\\}$。假设采用周期性边界条件。\n\n使用两种不同的守恒型有限体积离散化方法：一阶Godunov格式和Lax–Friedrichs格式，将单元平均值从时间 $t=0$ 演化到最终时间 $T = L/|a|$（一个平流周期）。时间步长 $\\Delta t$ 由Courant–Friedrichs–Lewy (CFL) 数确定：$\\text{CFL} = \\dfrac{|a|\\,\\Delta t}{\\Delta x}$。恰好使用 $N = T/\\Delta t$ 个时间步，对于以下测试用例，该值保证为整数。\n\n对于每种格式，通过相对全变分来量化其数值耗散：\n$$\nR = \\frac{\\operatorname{TV}(u(\\cdot,T))}{\\operatorname{TV}(u(\\cdot,0))},\n$$\n其中，对于周期性网格函数 $\\{u_i\\}_{i=0}^{M-1}$,\n$$\n\\operatorname{TV}(u) = \\sum_{i=0}^{M-1} \\left|u_{i} - u_{i-1}\\right|, \\quad \\text{其中约定 } u_{-1} \\equiv u_{M-1}.\n$$\n$R$ 的值越小，格式的耗散性越强。对每个测试用例，计算并报告浮点数对 $[R_{\\text{Godunov}}, R_{\\text{LaxFriedrichs}}]$。报告的每个浮点数必须四舍五入到6位小数。\n\n测试套件（请精确使用以下数值）：\n- 所有用例的全局常数：$L = 1$, $x_0 = 0.1$, $u_{\\text{low}} = 0$, $u_{\\text{high}} = 1$。\n- 用例 A：$M = 200$, $a = 1$, $\\text{CFL} = 0.5$, $w = 0.2$。\n- 用例 B：$M = 120$, $a = 1$, $\\text{CFL} = 0.8$, $w = 0.1$。\n- 用例 C：$M = 180$, $a = -1$, $\\text{CFL} = 0.9$, $w = 0.33$。\n\n最终输出格式：您的程序应生成单行输出，包含一个由方括号括起的逗号分隔列表。其中每个元素是对应于 A、B、C 顺序的用例的双浮点数列表。例如，格式必须是\n$[[R_{\\text{Godunov},A},R_{\\text{LaxFriedrichs},A}],[R_{\\text{Godunov},B},R_{\\text{LaxFriedrichs},B}],[R_{\\text{Godunov},C},R_{\\text{LaxFriedrichs},C}]]$\n，每个 $R$ 值都四舍五入到6位小数，且无任何附加文本。", "solution": "该问题要求对标量线性平流方程进行数值求解，该方程是双曲守恒律的一个原型。方程由下式给出：\n$$u_t + a\\,u_x = 0$$\n该方程定义于周期性空间域 $x \\in [0,L)$ 上。此守恒律的通量函数为 $f(u) = a\\,u$。该问题将使用守恒型有限体积法求解，其一维通用形式如下：\n$$U_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right)$$\n此处，$U_i^n$ 是在时间 $t_n = n\\Delta t$ 时单元 $i$ 中解的平均值，$\\Delta x$ 是均匀单元宽度，$\\Delta t$ 是时间步长，$F_{i+1/2}$ 是单元 $i$ 和单元 $i+1$ 交界面处的数值通量。\n\n首先，我们必须对初始条件进行离散化。连续的初始状态是一个方波，\n$$\nu(x,0) = \\begin{cases}\nu_{\\text{high}}, & \\text{if } (x - x_0) \\bmod L \\in [0,w),\\\\\nu_{\\text{low}}, & \\text{otherwise}.\n\\end{cases}\n$$\n区域 $[0,L)$ 被划分为 $M$ 个单元，其中单元 $i$ 覆盖空间区间 $[i\\Delta x, (i+1)\\Delta x)$，其中 $i \\in \\{0, 1, \\dots, M-1\\}$ 且 $\\Delta x=L/M$。初始单元平均值 $U_i^0$ 通过在每个单元上对 $u(x,0)$ 进行积分来计算：\n$$U_i^0 = \\frac{1}{\\Delta x} \\int_{i\\Delta x}^{(i+1)\\Delta x} u(x,0) \\,dx$$\n该积分计算的是单元区间与 $u=u_{\\text{high}}$ 区域之间交集的体积。对于定义在 $[x_0, x_0+w)$ 上的波，其与单元 $i$ 的重叠长度为 $\\max(0, \\min((i+1)\\Delta x, x_0+w) - \\max(i\\Delta x, x_0))$。因此，单元平均值为 $U_i^0 = u_{\\text{low}} + (u_{\\text{high}} - u_{\\text{low}}) \\frac{\\text{重叠长度}}{\\Delta x}$。\n\n时间演化使用两种不同的格式进行，这两种格式由其各自的数值通量函数定义。\n\n1.  **Godunov格式**：这是一个迎风格式。数值通量由单元交界面上的黎曼问题的解确定。对于线性平流方程，特征速度是常数 ($a$)，因此当 $a>0$ 时信息从左侧传播，当 $a<0$ 时信息从右侧传播。最终的通量为\n    $$F_{i+1/2}^{\\text{Godunov}} = \\begin{cases} f(U_i^n) = a\\,U_i^n, & \\text{if } a \\geq 0 \\\\ f(U_{i+1}^n) = a\\,U_{i+1}^n, & \\text{if } a < 0 \\end{cases}$$\n    更新法则可以写成：\n    $$U_i^{n+1} = U_i^n - \\frac{a \\Delta t}{\\Delta x}(U_i^n - U_{i-1}^n), \\quad \\text{for } a \\geq 0$$\n    $$U_i^{n+1} = U_i^n - \\frac{a \\Delta t}{\\Delta x}(U_{i+1}^n - U_i^n), \\quad \\text{for } a < 0$$\n    使用Courant数 $\\nu = a \\frac{\\Delta t}{\\Delta x}$（其中 $|\\nu|$ 是CFL数），当 $a \\geq 0$ 时，公式为 $U_i^{n+1} = U_i^n - \\nu(U_i^n - U_{i-1}^n)$；当 $a < 0$ 时，公式为 $U_i^{n+1} = U_i^n - \\nu(U_{i+1}^n - U_i^n)$。\n\n2.  **Lax–Friedrichs格式**：该格式通过对相邻状态进行平均，引入了显著的数值耗散。数值通量为\n    $$F_{i+1/2}^{\\text{LF}} = \\frac{1}{2}\\left( f(U_i^n) + f(U_{i+1}^n) \\right) - \\frac{1}{2}\\frac{\\Delta x}{\\Delta t}\\left( U_{i+1}^n - U_i^n \\right)$$\n    将此通量代入守恒型更新公式，得到直接的更新法则：\n    $$U_i^{n+1} = \\frac{1}{2}(U_{i+1}^n + U_{i-1}^n) - \\frac{a \\Delta t}{2 \\Delta x}(U_{i+1}^n - U_{i-1}^n)$$\n    使用Courant数 $\\nu = a \\frac{\\Delta t}{\\Delta x}$，该式变为 $U_i^{n+1} = \\frac{1}{2}(U_{i+1}^n + U_{i-1}^n) - \\frac{\\nu}{2}(U_{i+1}^n - U_{i-1}^n)$。\n\n解从 $t=0$ 演化到最终时间 $T=L/|a|$，这对应一个完整的平流周期。时间步数 $N = T/\\Delta t = (L/|a|)/(\\text{CFL} \\cdot \\Delta x/|a|) = L/(\\text{CFL} \\cdot L/M) = M/\\text{CFL}$，对于所有测试用例，该值均为整数。\n\n为了量化数值耗散，我们计算离散解 $\\{u_i\\}_{i=0}^{M-1}$ 的全变分 (TV) 如下：\n$$\\operatorname{TV}(u) = \\sum_{i=0}^{M-1} |u_i - u_{i-1}|$$\n其中周期性意味着 $u_{-1} \\equiv u_{M-1}$。由于周期性平流，时间 $T$ 时的精确解与初始条件完全相同，因此其全变分保持不变。然而，数值格式会引入耗散，这通常会减少解的全变分，从而抹平尖锐的梯度。我们计算初始全变分 $\\operatorname{TV}(U^0)$ 和最终全变分 $\\operatorname{TV}(U^N)$。相对全变分 $R = \\operatorname{TV}(U^N) / \\operatorname{TV}(U^0)$ 用作耗散的度量标准。$R$ 值接近 $1$ 表示耗散较低，而较小的值表示耗散较高。我们将为每个指定的测试用例计算两种格式的该比率 $R$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the linear advection problem using Godunov and Lax-Friedrichs schemes\n    and computes the relative total variation for a set of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A: M = 200, a = 1, CFL = 0.5, w = 0.2\n        {'M': 200, 'a': 1.0, 'CFL': 0.5, 'w': 0.2},\n        # Case B: M = 120, a = 1, CFL = 0.8, w = 0.1\n        {'M': 120, 'a': 1.0, 'CFL': 0.8, 'w': 0.1},\n        # Case C: M = 180, a = -1, CFL = 0.9, w = 0.33\n        {'M': 180, 'a': -1.0, 'CFL': 0.9, 'w': 0.33},\n    ]\n    \n    # Global constants\n    L = 1.0\n    x0 = 0.1\n    u_low = 0.0\n    u_high = 1.0\n\n    results = []\n\n    for case in test_cases:\n        M = case['M']\n        a = case['a']\n        CFL = case['CFL']\n        w = case['w']\n\n        # Discretization parameters\n        dx = L / M\n        T = L / abs(a)\n        dt = CFL * dx / abs(a)\n        N = int(round(T / dt)) # Ensure integer number of steps\n\n        # Initialize cell averages U0\n        U0 = np.full(M, u_low)\n        x_cells_L = np.arange(M) * dx\n        x_cells_R = x_cells_L + dx\n        \n        # Wave region (assuming no wrap-around for given x0, w, L)\n        wave_start = x0\n        wave_end = x0 + w\n\n        for i in range(M):\n            # Calculate overlap length of cell i with the wave region\n            overlap = max(0, min(x_cells_R[i], wave_end) - max(x_cells_L[i], wave_start))\n            if overlap > 0:\n                U0[i] = u_low + (u_high - u_low) * overlap / dx\n\n        # Function to calculate Total Variation\n        def calculate_tv(u):\n            # The convention u_{-1} = u_{M-1} is handled by np.roll\n            return np.sum(np.abs(u - np.roll(u, 1)))\n\n        tv0 = calculate_tv(U0)\n\n        # Evolve solution for both schemes\n        U_godunov = np.copy(U0)\n        U_lf = np.copy(U0)\n        \n        # Courant number nu = a * dt / dx\n        nu = a * dt / dx\n\n        for _ in range(N):\n            # --- Godunov (Upwind) Scheme ---\n            U_prev_g = np.roll(U_godunov, 1)\n            U_next_g = np.roll(U_godunov, -1)\n            if a >= 0:\n                U_godunov = U_godunov - nu * (U_godunov - U_prev_g)\n            else: # a < 0\n                U_godunov = U_godunov - nu * (U_next_g - U_godunov)\n\n            # --- Lax-Friedrichs Scheme ---\n            U_prev_lf = np.roll(U_lf, 1)\n            U_next_lf = np.roll(U_lf, -1)\n            U_lf = 0.5 * (U_next_lf + U_prev_lf) - 0.5 * nu * (U_next_lf - U_prev_lf)\n\n        # Calculate final total variations\n        tvf_godunov = calculate_tv(U_godunov)\n        tvf_lf = calculate_tv(U_lf)\n\n        # Calculate relative total variation R\n        R_godunov = tvf_godunov / tv0 if tv0 != 0 else 0\n        R_lf = tvf_lf / tv0 if tv0 != 0 else 0\n        \n        # Round and append results\n        results.append([round(R_godunov, 6), round(R_lf, 6)])\n\n    # Format the final output string\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2397651"}, {"introduction": "现在，让我们从单一方程的理想世界进入模拟真实流体问题的复杂领域——求解欧拉方程组。这项压轴实践将揭示 HLL 和 HLLC 这两种近似黎曼求解器之间一个微妙但至关重要的区别。通过一个精心设计的静止接触间断问题，你将亲眼见证并理解为何更复杂的 HLLC 求解器对于精确捕捉某些物理现象是不可或缺的，而这些现象是 HLL 这类更简单的求解器所无法处理的。[@problem_id:2397623]", "problem": "实现针对一维可压缩欧拉方程的一阶 Godunov 有限体积法单步更新，使用两种近似黎曼求解器：Harten-Lax-van Leer (HLL) 求解器和 Harten-Lax-van Leer-Contact (HLLC) 求解器。其目标是从第一性原理出发，证明 HLL 求解器会错误地耗散静止的接触间断，而 HLLC 求解器能精确地解析它。\n\n从质量、动量和能量在一维空间中的基本守恒律出发，其守恒形式由状态向量 $U$ 和通量 $F(U)$ 表示为：\n$$\n\\frac{\\partial U}{\\partial t} + \\frac{\\partial F(U)}{\\partial x} = 0,\n$$\n对于欧拉方程，\n$$\nU = \n\\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\nE\n\\end{bmatrix},\n\\quad\nF(U) = \n\\begin{bmatrix}\n\\rho u \\\\\n\\rho u^2 + p \\\\\nu (E + p)\n\\end{bmatrix},\n$$\n总能量满足\n$$\nE = \\frac{p}{\\gamma - 1} + \\frac{1}{2}\\rho u^2.\n$$\n假设为理想气体，比热比为 $\\gamma$。在单位长度的域上使用包含 $N$ 个网格单元的均匀网格，网格宽度为 $\\Delta x = 1/N$。对于网格单元 $i$，在一个时间步长 $\\Delta t$ 内的一阶 Godunov 更新为\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right),\n$$\n其中 $F_{i+\\frac{1}{2}}$ 是通过使用近似黎曼求解器求解左状态 $U_i^n$ 和右状态 $U_{i+1}^n$ 之间的黎曼问题而得到的数值通量。\n\n您必须使用基于特征速度界限的波速估计来实现 HLL 和 HLLC 的数值通量。您还必须在两侧各使用一个虚拟网格来实现透射（零梯度）边界条件。\n\n使用 Courant-Friedrichs-Lewy (CFL) 条件来设计数值时间步长：\n$$\n\\Delta t = \\text{CFL}\\,\\frac{\\Delta x}{\\max_i \\left(|u_i| + a_i\\right)},\n\\quad a_i = \\sqrt{\\gamma \\frac{p_i}{\\rho_i}}.\n$$\n所有量均为无量纲；不需要物理单位。\n\n您的程序必须为每个测试用例执行一个显式 Godunov 时间步，并报告预期现象是否发生：即 HLL 求解器耗散静止接触间断，而 HLLC 求解器精确地保持它。为量化耗散，使用一步之后密度的总变差，\n$$\n\\Delta \\rho_{\\text{L1}} = \\sum_{i=1}^{N} \\left|\\rho_i^{n+1} - \\rho_i^n\\right|.\n$$\n对于一个与网格单元面重合且压力和速度均匀的完全静止接触间断，HLLC 通量应得到 $\\Delta \\rho_{\\text{L1}} \\approx 0$，而 HLL 通量应得到 $\\Delta \\rho_{\\text{L1}} > 0$。使用数值容差 $10^{-12}$ 来判断是否等于零。\n\n测试套件：\n对于每个测试用例，用一个位于域中点 $x = 0.5$ 的间断来分段常数地初始化原始变量 $(\\rho, u, p)$。左状态 $(\\rho_L, u_L, p_L)$ 填充中心点 $x < 0.5$ 的网格单元，右状态 $(\\rho_R, u_R, p_R)$ 填充中心点 $x \\ge 0.5$ 的网格单元。使用 $\\gamma = 1.4$，$N = 10$，以及 $\\text{CFL} = 0.4$。四个测试用例如下：\n\n- 用例 A（静止接触间断，中等跳跃）：$(\\rho_L, u_L, p_L, \\rho_R, u_R, p_R) = (1.0, 0.0, 1.0, 0.125, 0.0, 1.0)$。\n- 用例 B（静止接触间断，强跳跃）：$(\\rho_L, u_L, p_L, \\rho_R, u_R, p_R) = (10.0, 0.0, 1.0, 0.1, 0.0, 1.0)$。\n- 用例 C（无间断）：$(\\rho_L, u_L, p_L, \\rho_R, u_R, p_R) = (1.0, 0.0, 1.0, 1.0, 0.0, 1.0)$。\n- 用例 D（静止接触间断，弱跳跃）：$(\\rho_L, u_L, p_L, \\rho_R, u_R, p_R) = (1.0, 0.0, 1.0, 0.8, 0.0, 1.0)$。\n\n对于每个用例，用 HLL 和 HLLC 分别计算一次单步更新。然后为该用例返回一个定义如下的布尔值：\n$$\n\\text{result} = \\left(\\Delta \\rho_{\\text{L1}}^{\\text{HLL}} > 10^{-12}\\right) \\wedge \\left(\\Delta \\rho_{\\text{L1}}^{\\text{HLLC}} \\le 10^{-12}\\right).\n$$\n对于用例 A、B 和 D，此布尔值应为 true，对于用例 C，应为 false。\n\n最终输出格式：\n您的程序应产生单行输出，其中包含四个测试用例的结果，形式为方括号括起来的逗号分隔列表，例如 $[\\text{true},\\text{false},\\text{true},\\text{true}]$，使用您所用语言的原生布尔字面量。", "solution": "本文档针对实现一维可压缩欧拉方程的一阶 Godunov 有限体积法单步更新问题，给出了一个验证及后续的解决方案。其目标是从第一性原理出发，展示 Harten-Lax-van Leer (HLL) 和 Harten-Lax-van Leer-Contact (HLLC) 近似黎曼求解器在应用于静止接触间断时的不同行为。\n\n首先，该问题经过一个严格的验证过程。\n\n**问题验证**\n\n**步骤1：提取的已知条件**\n- **控制方程**：一维欧拉方程的守恒形式：\n$$\n\\frac{\\partial U}{\\partial t} + \\frac{\\partial F(U)}{\\partial x} = 0\n$$\n- **状态向量和通量向量**：\n$$\nU = \n\\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\nE\n\\end{bmatrix},\n\\quad\nF(U) = \n\\begin{bmatrix}\n\\rho u \\\\\n\\rho u^2 + p \\\\\nu (E + p)\n\\end{bmatrix}\n$$\n- **状态方程**：对于比热比为 $\\gamma$ 的理想气体：\n$$\nE = \\frac{p}{\\gamma - 1} + \\frac{1}{2}\\rho u^2\n$$\n- **数值格式**：一阶 Godunov 有限体积法：\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right)\n$$\n- **网格**：单位长度域上的均匀网格，含 $N$ 个网格单元，网格宽度 $\\Delta x = 1/N$。\n- **数值通量**：$F_{i+\\frac{1}{2}}$ 是网格单元 $i$ 和 $i+1$ 之间界面处的数值通量，通过使用近似黎曼求解器求解状态 $U_i^n$ 和 $U_{i+1}^n$ 之间的黎曼问题得到。\n- **求解器**：HLL 和 HLLC 近似黎曼求解器。\n- **边界条件**：透射（零梯度）边界条件，通过在两侧各使用一个虚拟网格来实现。\n- **时间步长**：Courant-Friedrichs-Lewy (CFL) 条件：\n$$\n\\Delta t = \\text{CFL}\\,\\frac{\\Delta x}{\\max_i \\left(|u_i| + a_i\\right)},\n\\quad \\text{其中声速 } a_i = \\sqrt{\\gamma \\frac{p_i}{\\rho_i}}。\n$$\n- **耗散度量**：一个时间步后密度变化的 L1 范数：\n$$\n\\Delta \\rho_{\\text{L1}} = \\sum_{i=1}^{N} \\left|\\rho_i^{n+1} - \\rho_i^n\\right|\n$$\n- **数值容差**：$10^{-12}$，用于判断是否等于零。\n- **参数**：$\\gamma = 1.4$，$N = 10$，$\\text{CFL} = 0.4$。\n- **测试用例**：初始分段常数状态 $(\\rho, u, p)$，在 $x = 0.5$ 处有间断。\n    - 用例 A: $(1.0, 0.0, 1.0, 0.125, 0.0, 1.0)$\n    - 用例 B: $(10.0, 0.0, 1.0, 0.1, 0.0, 1.0)$\n    - 用例 C: $(1.0, 0.0, 1.0, 1.0, 0.0, 1.0)$\n    - 用例 D: $(1.0, 0.0, 1.0, 0.8, 0.0, 1.0)$\n- **要求输出**：对于每个用例，一个由以下公式定义的布尔值：\n$$\n\\text{result} = \\left(\\Delta \\rho_{\\text{L1}}^{\\text{HLL}} > 10^{-12}\\right) \\wedge \\left(\\Delta \\rho_{\\text{L1}}^{\\text{HLLC}} \\le 10^{-12}\\right)\n$$\n\n**步骤2：验证分析**\n根据规定的有效性标准对问题进行审查。\n- **科学基础**：该问题基于欧拉方程和 Godunov 方法，它们是计算流体动力学中的经典课题。HLL 和 HLLC 求解器是标准的、有详细文档的算法。该问题在科学上是合理的。\n- **适定性**：该问题指定了一个确定性的显式数值算法，并提供了所有必要的初始条件、边界条件和参数。保证了单步之后状态的唯一解。\n- **客观性**：该问题使用精确的数学和算法语言来表述，没有任何主观或模糊的术语。\n- **完整性和一致性**：提供了实现所需的所有信息。网格设置（$N=10$，间断点在 $x=0.5$）正确地将初始跳跃放置在网格单元5和网格单元6之间的界面上。参数在物理上和数值上是一致的。\n\n**步骤3：结论**\n该问题是**有效的**。它是一个计算工程领域内适定、完整且科学严谨的问题。我们继续进行求解。\n\n**基于原理的求解**\n\n目标是使用有限体积法求解双曲守恒律方程组——欧拉方程。对于一个控制体（网格单元）$[x_{i-1/2}, x_{i+1/2}]$，守恒律的积分形式为\n$$\n\\frac{d}{dt} \\int_{x_{i-1/2}}^{x_{i+1/2}} U(x, t) dx + F(U(x_{i+1/2}, t)) - F(U(x_{i-1/2}, t)) = 0\n$$\n在网格宽度 $\\Delta x = x_{i+1/2} - x_{i-1/2}$ 上进行平均，得到\n$$\n\\frac{d U_i(t)}{dt} + \\frac{1}{\\Delta x}\\left(F(U(x_{i+1/2}, t)) - F(U(x_{i-1/2}, t))\\right) = 0,\n$$\n其中 $U_i(t)$ 是网格平均状态。从 $t^n$ 到 $t^{n+1} = t^n + \\Delta t$ 的一阶显式时间积分给出了 Godunov 更新公式：\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right)\n$$\n此处，$F_{i+1/2}$ 是数值通量，它必须近似于界面处的时间平均物理通量。Godunov 方法使用界面处黎曼问题的自相似解来定义此通量，该解沿直线 $x/t=0$ 进行求值。界面 $x_{i+1/2}$ 处的黎曼问题由包含两个常数状态 $U_L = U_i^n$ 和 $U_R = U_{i+1}^n$ 的初始条件定义。\n\n**HLL 近似黎曼求解器**\nHLL 求解器用一个双波模型来近似黎曼问题的解。它假设左状态 $U_L$ 和右状态 $U_R$ 被一个中间常数状态 $U_*$ 分隔，并由最快的左行波速 $S_L$ 和最快的右行波速 $S_R$ 所界定。在区域 $[x_L, x_R] \\times [0, T]$（其中 $x_L < 0 < x_R$）上对守恒定律进行积分并应用散度定理，可以得到 Rankine-Hugoniot 条件的积分形式。这导出了 HLL 状态 $U_* = \\frac{S_R U_R - S_L U_L - (F_R - F_L)}{S_R - S_L}$。界面 $x/t=0$ 处的数值通量则由简化波结构的哪个区域包含该界面来确定。这就得到了 HLL 通量 $F^{\\text{HLL}}$：\n$$\nF^{\\text{HLL}} = \\begin{cases}\nF_L & \\text{若 } 0 \\le S_L \\\\\n\\frac{S_R F_L - S_L F_R + S_L S_R (U_R - U_L)}{S_R - S_L} & \\text{若 } S_L < 0 < S_R \\\\\nF_R & \\text{若 } 0 > S_R\n\\end{cases}\n$$\n波速 $S_L$ 和 $S_R$ 必须包围所有物理特征速度。我们使用 Davis-Yee 估计：\n$$\nS_L = \\min(u_L - a_L, u_R - a_R), \\quad S_R = \\max(u_L + a_L, u_R + a_R)\n$$\n其中 $a_K = \\sqrt{\\gamma p_K / \\rho_K}$ 对于 $K \\in \\{L, R\\}$。HLL 求解器简单且鲁棒，但众所周知它具有过度的耗散性，尤其对于接触间断，因为它没有显式地对它们建模。对于静止接触（$u_L=u_R=0, p_L=p_R$），如果 $\\rho_L \\neq \\rho_R$，通量会有一个非零的质量分量，这会引入伪速度和密度剖面的涂抹。\n\n**HLLC 近似黎曼求解器**\nHLLC 求解器恢复了 HLL 模型中缺失的接触间断和剪切波。它假设一个具有速度 $S_L$、$S_*$（接触波）和 $S_R$ 的三波结构，分隔了四个常数状态：$U_L$、$U_{L*}$、$U_{R*}$ 和 $U_R$。波速 $S_L$ 和 $S_R$ 的估计方法与 HLL 中相同。接触波速度 $S_*$ 和“星区”中的压力 ($p_{L*} = p_{R*} = p_*$) 是通过在 $S_L$ 和 $S_R$ 波上强制执行 Rankine-Hugoniot 条件来找到的。这给出了：\n$$\nS_* = \\frac{p_R - p_L + \\rho_L u_L(S_L - u_L) - \\rho_R u_R(S_R - u_R)}{\\rho_L (S_L - u_L) - \\rho_R (S_R - u_R)}\n$$\n然后，中间状态 $U_{K*}$（对于 $K \\in \\{L,R\\}$）通过在外波上应用 Rankine-Hugoniot 条件给出：\n$$\nU_{K*} = \\rho_K \\left(\\frac{S_K - u_K}{S_K - S_*}\\right) \\begin{bmatrix} 1 \\\\ S_* \\\\ E_K/\\rho_K + (S_* - u_K)(S_* + p_K/(\\rho_K(S_K-u_K))) \\end{bmatrix}\n$$\nHLLC 通量 $F^{\\text{HLLC}}$ 是根据界面 $x/t=0$ 在该波结构中的位置来选择的：\n$$\nF^{\\text{HLLC}} = \\begin{cases}\nF_L & \\text{若 } 0 \\le S_L \\\\\nF_L + S_L(U_{L*} - U_L) & \\text{若 } S_L < 0 \\le S_* \\\\\nF_R + S_R(U_{R*} - U_R) & \\text{若 } S_* < 0 < S_R \\\\\nF_R & \\text{若 } 0 > S_R\n\\end{cases}\n$$\n对于由 $(\\rho_L, 0, p_0)$ 和 $(\\rho_R, 0, p_0)$ 定义的静止接触间断，可以证明 $S_* = 0$。于是，HLLC 公式在接触间断处产生的数值通量等于物理通量 $F = [0, p_0, 0]^T$。因此，对于任何网格单元，传入和传出的通量都相同（$F_{i-1/2} = F_{i+1/2}$），导致 $U_i^{n+1} = U_i^n$。因此，HLLC 求解器能精确地保持静止接触间断，直至机器精度。\n\n提供的测试用例旨在验证此行为。用例 A、B 和 D 是具有不同密度跳跃的静止接触间断。预计 HLL 求解器将产生非零的 $\\Delta \\rho_{\\text{L1}}$，而 HLLC 求解器应产生 $\\Delta \\rho_{\\text{L1}} \\approx 0$。用例 C 是一个无间断的平凡情况，对于此情况，两种求解器都应得到 $\\Delta \\rho_{\\text{L1}} \\approx 0$。下面的实现将量化这些效应。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a one-step first-order Godunov solver for the 1D Euler equations\n    to compare HLL and HLLC approximate Riemann solvers on stationary contacts.\n    \"\"\"\n    \n    # Test cases: (rho_L, u_L, p_L, rho_R, u_R, p_R)\n    test_cases = [\n        (1.0, 0.0, 1.0, 0.125, 0.0, 1.0),  # Case A\n        (10.0, 0.0, 1.0, 0.1, 0.0, 1.0),   # Case B\n        (1.0, 0.0, 1.0, 1.0, 0.0, 1.0),    # Case C\n        (1.0, 0.0, 1.0, 0.8, 0.0, 1.0),     # Case D\n    ]\n    \n    N = 10\n    CFL = 0.4\n    GAMMA = 1.4\n    TOL = 1e-12\n\n    def prim_to_cons(rho, u, p, gamma):\n        \"\"\"Convert primitive variables to conservative variables.\"\"\"\n        U = np.zeros((3, len(rho)))\n        U[0] = rho\n        U[1] = rho * u\n        U[2] = p / (gamma - 1.0) + 0.5 * rho * u**2\n        return U\n\n    def cons_to_prim(U, gamma):\n        \"\"\"Convert conservative variables to primitive variables and flux.\"\"\"\n        rho = U[0]\n        u = U[1] / rho\n        E = U[2]\n        p = (gamma - 1.0) * (E - 0.5 * rho * u**2)\n        \n        F = np.zeros_like(U)\n        F[0] = rho * u\n        F[1] = rho * u**2 + p\n        F[2] = u * (E + p)\n        \n        # Add a floor for pressure and density to avoid numerical issues\n        p = np.maximum(p, 1e-9)\n        rho = np.maximum(rho, 1e-9)\n\n        return rho, u, p, F\n\n    def hll_flux(U_L, U_R, gamma):\n        \"\"\"Calculate HLL flux for an array of interfaces.\"\"\"\n        rho_L, u_L, p_L, F_L = cons_to_prim(U_L, gamma)\n        rho_R, u_R, p_R, F_R = cons_to_prim(U_R, gamma)\n\n        a_L = np.sqrt(gamma * p_L / rho_L)\n        a_R = np.sqrt(gamma * p_R / rho_R)\n\n        S_L = np.minimum(u_L - a_L, u_R - a_R)\n        S_R = np.maximum(u_L + a_L, u_R + a_R)\n\n        F_hll = np.zeros_like(F_L)\n        \n        # Vectorized conditions\n        mask1 = S_L >= 0\n        mask3 = S_R <= 0\n        mask2 = ~mask1 & ~mask3 # S_L < 0 < S_R\n        \n        F_hll[:, mask1] = F_L[:, mask1]\n        F_hll[:, mask3] = F_R[:, mask3]\n\n        if np.any(mask2):\n            S_L_m2 = S_L[mask2]\n            S_R_m2 = S_R[mask2]\n            F_L_m2 = F_L[:, mask2]\n            F_R_m2 = F_R[:, mask2]\n            U_L_m2 = U_L[:, mask2]\n            U_R_m2 = U_R[:, mask2]\n            \n            F_hll[:, mask2] = (S_R_m2 * F_L_m2 - S_L_m2 * F_R_m2 + S_L_m2 * S_R_m2 * (U_R_m2 - U_L_m2)) / (S_R_m2 - S_L_m2)\n            \n        return F_hll\n\n    def hllc_flux(U_L, U_R, gamma):\n        \"\"\"Calculate HLLC flux for an array of interfaces.\"\"\"\n        rho_L, u_L, p_L, F_L = cons_to_prim(U_L, gamma)\n        rho_R, u_R, p_R, F_R = cons_to_prim(U_R, gamma)\n        \n        E_L = U_L[2]\n        E_R = U_R[2]\n        \n        a_L = np.sqrt(gamma * p_L / rho_L)\n        a_R = np.sqrt(gamma * p_R / rho_R)\n\n        S_L = np.minimum(u_L - a_L, u_R - a_R)\n        S_R = np.maximum(u_L + a_L, u_R + a_R)\n\n        p_star_num = p_R - p_L + rho_L * u_L * (S_L - u_L) - rho_R * u_R * (S_R - u_R)\n        p_star_den = rho_L * (S_L - u_L) - rho_R * (S_R - u_R)\n        S_star = p_star_num / p_star_den\n        \n        p_star = p_L + rho_L * (u_L - S_L) * (u_L - S_star)\n\n        F_hllc = np.zeros_like(F_L)\n\n        # Vectorized conditions\n        mask1 = 0.0 <= S_L\n        mask2 = (S_L < 0.0) & (0.0 <= S_star)\n        mask3 = (S_star < 0.0) & (0.0 < S_R)\n        mask4 = S_R <= 0.0\n\n        if np.any(mask1):\n            F_hllc[:, mask1] = F_L[:, mask1]\n        \n        if np.any(mask2):\n            factor_L = rho_L[mask2] * (S_L[mask2] - u_L[mask2]) / (S_L[mask2] - S_star[mask2])\n            U_star_L = np.zeros((3, np.sum(mask2)))\n            U_star_L[0] = factor_L\n            U_star_L[1] = factor_L * S_star[mask2]\n            U_star_L[2] = factor_L * (E_L[mask2] / rho_L[mask2] + (S_star[mask2] - u_L[mask2]) * (S_star[mask2] + p_L[mask2] / (rho_L[mask2] * (S_L[mask2] - u_L[mask2]))))\n            F_hllc[:, mask2] = F_L[:, mask2] + S_L[mask2] * (U_star_L - U_L[:, mask2])\n\n        if np.any(mask3):\n            factor_R = rho_R[mask3] * (S_R[mask3] - u_R[mask3]) / (S_R[mask3] - S_star[mask3])\n            U_star_R = np.zeros((3, np.sum(mask3)))\n            U_star_R[0] = factor_R\n            U_star_R[1] = factor_R * S_star[mask3]\n            U_star_R[2] = factor_R * (E_R[mask3] / rho_R[mask3] + (S_star[mask3] - u_R[mask3]) * (S_star[mask3] + p_R[mask3] / (rho_R[mask3] * (S_R[mask3] - u_R[mask3]))))\n            F_hllc[:, mask3] = F_R[:, mask3] + S_R[mask3] * (U_star_R - U_R[:, mask3])\n\n        if np.any(mask4):\n            F_hllc[:, mask4] = F_R[:, mask4]\n\n        return F_hllc\n\n    def run_one_step(U_n, dx, cfl, gamma, flux_solver):\n        \"\"\"Performs a single first-order Godunov time step.\"\"\"\n        num_cells = U_n.shape[1]\n        \n        # Apply boundary conditions (zero-gradient)\n        U_ext = np.zeros((3, num_cells + 2))\n        U_ext[:, 1:-1] = U_n\n        U_ext[:, 0] = U_n[:, 0]\n        U_ext[:, -1] = U_n[:, -1]\n        \n        rho_ext, u_ext, p_ext, _ = cons_to_prim(U_ext, gamma)\n        a_ext = np.sqrt(gamma * p_ext / rho_ext)\n        \n        # Calculate time step\n        max_speed = np.max(np.abs(u_ext) + a_ext)\n        dt = cfl * dx / max_speed\n        \n        # Left and right states for interfaces\n        U_L = U_ext[:, :-1]\n        U_R = U_ext[:, 1:]\n        \n        # Calculate fluxes at all interfaces\n        fluxes = flux_solver(U_L, U_R, gamma)\n        \n        # Update conservative variables\n        U_np1 = U_n - (dt / dx) * (fluxes[:, 1:] - fluxes[:, :-1])\n        \n        return U_np1\n\n    results = []\n    domain_length = 1.0\n    dx = domain_length / N\n    x = np.linspace(dx / 2.0, domain_length - dx / 2.0, N)\n\n    for case in test_cases:\n        rho_L, u_L, p_L, rho_R, u_R, p_R = case\n        \n        # Initial conditions\n        rho_initial = np.where(x < 0.5, rho_L, rho_R)\n        u_initial = np.where(x < 0.5, u_L, u_R)\n        p_initial = np.where(x < 0.5, p_L, p_R)\n        \n        U_initial = prim_to_cons(rho_initial, u_initial, p_initial, GAMMA)\n        \n        # Run HLL solver\n        U_final_hll = run_one_step(U_initial.copy(), dx, CFL, GAMMA, hll_flux)\n        rho_final_hll, _, _, _ = cons_to_prim(U_final_hll, GAMMA)\n        delta_rho_l1_hll = np.sum(np.abs(rho_final_hll - rho_initial))\n        \n        # Run HLLC solver\n        U_final_hllc = run_one_step(U_initial.copy(), dx, CFL, GAMMA, hllc_flux)\n        rho_final_hllc, _, _, _ = cons_to_prim(U_final_hllc, GAMMA)\n        delta_rho_l1_hllc = np.sum(np.abs(rho_final_hllc - rho_initial))\n        \n        # Evaluate condition\n        # The condition for Case C (no discontinuity) should be false.\n        # HLL will have zero dissipation, HLLC will have zero dissipation.\n        # So delta_rho_hll will be  TOL. The condition (delta > TOL) will be false.\n        # This means the logic is also correct for the no-discontinuity case.\n        is_contact = rho_L != rho_R\n        if is_contact:\n            condition_met = (delta_rho_l1_hll > TOL) and (delta_rho_l1_hllc = TOL)\n        else: # Case C\n            condition_met = (delta_rho_l1_hll = TOL) and (delta_rho_l1_hllc = TOL)\n            # The problem asks for the single boolean check, which for case C will evaluate to False\n            # because (delta_rho_l1_hll > TOL) is false. So we don't need special logic.\n            condition_met = (delta_rho_l1_hll > TOL) and (delta_rho_l1_hllc = TOL)\n\n\n        results.append(condition_met)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\".replace(\"True\", \"true\").replace(\"False\", \"false\"))\n\nsolve()\n\n```", "id": "2397623"}]}