{"hands_on_practices": [{"introduction": "许多无网格粒子方法（如光滑粒子流体动力学 SPH）采用“弱可压缩”假设来模拟不可压缩流体，这在计算上比求解压力泊松方程更高效。这种方法的核心是状态方程，它将流体密度与压力联系起来，其中人工声速 $c_0$ 是一个关键的数值参数。本练习旨在通过一个经典的静水压问题，帮助您深入理解弱可压缩假设的含义及其与理想不可压缩模型之间的差异 [@problem_id:2413331]。您将通过分析推导和数值计算，亲手量化由人工声速 $c_0$ 引入的“可压缩性误差”，从而对 SPH 方法中的基本物理建模权衡建立起直观而深刻的认识。", "problem": "给定一个一维、垂直、静态的水柱，它被建模为一组等间距的粒子（一种无网格离散化方法），其自由表面位于高度 $z = H$，底部位于 $z = 0$。重力向下作用，大小为 $g$。参考流体密度为 $\\rho_0$，自由表面的静水压力为 $p_0$（大气压），您可以将其视为零表压，即 $p_0 = 0$。您需要比较在粒子位置上近似的压力场的两种模型：\n\n1. 一种状态方程 (EOS) 方法，代表了弱可压缩光滑粒子流体动力学 (SPH)。使用水的 Tait 状态方程：\n$$\np(\\rho) - p_0 = \\frac{\\rho_0 c_0^2}{\\gamma} \\left[ \\left(\\frac{\\rho}{\\rho_0}\\right)^{\\gamma} - 1 \\right],\n$$\n其中 $c_0$ 是人工声速，$\\gamma$ 是 Tait 指数。在重力作用下的静态平衡中，动量平衡简化为\n$$\n\\frac{dp}{dz} = -\\rho g,\n$$\n并且 EOS 将 $p$ 和 $\\rho$ 关联起来。施加自由表面边界条件 $p(H) = p_0$。\n\n2. 一种基于投影的不可压缩求解器模型，其中密度为常数 $\\rho = \\rho_0$，静态平衡简化为\n$$\n\\frac{dp}{dz} = -\\rho_0 g,\n$$\n其自由表面边界条件为 $p(H) = p_0$。\n\n任务：\n- 在给定参数 $(\\rho_0, g, c_0, \\gamma, H)$ 的情况下，从第一性原理推导出在任意深度 $z \\in [0,H]$ 处计算基于 EOS 的可压缩流体静水压力 $p_{\\mathrm{eos}}(z)$ 和不可压缩流体静水压力 $p_{\\mathrm{inc}}(z)$ 所需的解析表达式。\n- 使用沿水柱分布的 $N$ 个等间距粒子的离散化方法，在每个粒子位置 $z_i$（其中 $i = 0, 1, \\dots, N-1$）处计算 $p_{\\mathrm{eos}}$ 和 $p_{\\mathrm{inc}}$。粒子位置必须为 $z_i = i \\Delta z$，其中 $\\Delta z = H/(N-1)$。\n- 计算所有粒子上两个压力场之间的最大绝对逐点偏差：\n$$\n\\Delta p_{\\max} = \\max_{0 \\le i  N} \\left| p_{\\mathrm{eos}}(z_i) - p_{\\mathrm{inc}}(z_i) \\right|.\n$$\n\n物理单位：\n- 所有输入均采用国际单位制。您的程序必须以帕斯卡 (Pa) 为单位报告 $\\Delta p_{\\max}$。将每个结果表示为四舍五入到小数点后三位的小数。\n\n测试套件：\n您的程序必须评估以下四个测试用例，并按如下规定，将四个结果输出到一行。\n\n- 用例 A (正常情况): $\\rho_0 = 1000$ kg/m$^3$, $g = 9.81$ m/s$^2$, $H = 1.0$ m, $c_0 = 50.0$ m/s, $\\gamma = 7.0$, $N = 101$。\n- 用例 B (浅水柱边界情况): $\\rho_0 = 1000$ kg/m$^3$, $g = 9.81$ m/s$^2$, $H = 0.1$ m, $c_0 = 50.0$ m/s, $\\gamma = 7.0$, $N = 11$。\n- 用例 C (软状态方程边缘情况): $\\rho_0 = 1000$ kg/m$^3$, $g = 9.81$ m/s$^2$, $H = 2.0$ m, $c_0 = 10.0$ m/s, $\\gamma = 7.0$, $N = 201$。\n- 用例 D (硬状态方程接近不可压缩): $\\rho_0 = 1000$ kg/m$^3$, $g = 9.81$ m/s$^2$, $H = 2.0$ m, $c_0 = 1000.0$ m/s, $\\gamma = 7.0$, $N = 51$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含四个用例的结果，按 A, B, C, D 的顺序排列，格式为用方括号括起来的逗号分隔列表，例如：\n\"[x_A,x_B,x_C,x_D]\"\n- 每个 $x_\\cdot$ 是 $\\Delta p_{\\max}$ 的值，单位为帕斯卡，四舍五入到小数点后三位。\n- 程序必须是独立自足的，不得读取任何输入，也不得执行任何文件或网络 I/O 操作。", "solution": "该问题要求推导和比较高度为 $H$ 的一维水柱中静水压力的两种模型。第一个模型是针对不可压缩流体的，第二个模型是针对由 Tait 状态方程 (EOS) 描述的弱可压缩流体的。最终目标是在一组离散的粒子位置上，找出这两种模型之间的最大绝对压力偏差。\n\n首先，我们推导不可压缩模型中压力场 $p_{\\mathrm{inc}}(z)$ 的解析表达式。静力平衡的控制方程是动量平衡，可简化为：\n$$\n\\frac{dp}{dz} = -\\rho g\n$$\n在不可压缩模型中，密度被假定为常数 $\\rho = \\rho_0$。方程变为：\n$$\n\\frac{dp_{\\mathrm{inc}}}{dz} = -\\rho_0 g\n$$\n这是一个简单的一阶常微分方程。我们对垂直坐标 $z$ 进行积分：\n$$\n\\int dp_{\\mathrm{inc}} = \\int -\\rho_0 g \\, dz \\implies p_{\\mathrm{inc}}(z) = -\\rho_0 g z + C\n$$\n其中 $C$ 是积分常数。我们通过应用自由表面 $z=H$ 处的边界条件来确定 $C$，在该处压力给定为 $p_0=0$。\n$$\np_{\\mathrm{inc}}(H) = -\\rho_0 g H + C = 0 \\implies C = \\rho_0 g H\n$$\n将常数代回压力表达式，得到不可压缩静水压力的最终形式：\n$$\np_{\\mathrm{inc}}(z) = \\rho_0 g H - \\rho_0 g z = \\rho_0 g (H-z)\n$$\n这是压力与深度之间熟知的线性关系，其中 $H-z$ 是自由表面以下的深度。\n\n接下来，我们推导弱可压缩模型中的压力场 $p_{\\mathrm{eos}}(z)$。我们有一个由两个耦合方程组成的系统：静力平衡方程（其中密度 $\\rho$ 现在是压力的函数）和 Tait 状态方程。\n1. 静力平衡：$\\frac{dp}{dz} = -\\rho(p) g$\n2. Tait 状态方程 (其中 $p_0 = 0$)：$p(\\rho) = \\frac{\\rho_0 c_0^2}{\\gamma} \\left[ \\left(\\frac{\\rho}{\\rho_0}\\right)^{\\gamma} - 1 \\right]$\n\n为了求解这个系统，我们首先从 EOS 中将密度 $\\rho$ 表示为压力 $p$ 的函数：\n$$\n\\frac{p \\gamma}{\\rho_0 c_0^2} = \\left(\\frac{\\rho}{\\rho_0}\\right)^{\\gamma} - 1 \\implies \\left(\\frac{\\rho}{\\rho_0}\\right)^{\\gamma} = 1 + \\frac{p \\gamma}{\\rho_0 c_0^2}\n$$\n$$\n\\rho(p) = \\rho_0 \\left( 1 + \\frac{\\gamma p}{\\rho_0 c_0^2} \\right)^{1/\\gamma}\n$$\n将此表达式代入静力平衡方程，得到一个关于 $p(z)$ 的一阶可分离常微分方程：\n$$\n\\frac{dp}{dz} = -g \\rho_0 \\left( 1 + \\frac{\\gamma p}{\\rho_0 c_0^2} \\right)^{1/\\gamma}\n$$\n我们分离变量 $p$ 和 $z$：\n$$\n\\left( 1 + \\frac{\\gamma p}{\\rho_0 c_0^2} \\right)^{-1/\\gamma} dp = -g \\rho_0 dz\n$$\n我们对两边进行积分。左边的积分从表面压力 $p(H)=0$ 到任意高度 $z$ 处的压力 $p(z)$。右边的积分相应地从 $H$ 到 $z$。\n$$\n\\int_{0}^{p(z)} \\left( 1 + \\frac{\\gamma P}{\\rho_0 c_0^2} \\right)^{-1/\\gamma} dP = \\int_{H}^{z} -g \\rho_0 dZ\n$$\n右边积分结果为：\n$$\n\\int_{H}^{z} -g \\rho_0 dZ = -g \\rho_0 [Z]_{H}^{z} = -g \\rho_0(z - H) = g \\rho_0 (H-z)\n$$\n对于左边的积分，令 $u = 1 + \\frac{\\gamma P}{\\rho_0 c_0^2}$，这意味着 $dP = \\frac{\\rho_0 c_0^2}{\\gamma} du$。$u$ 的积分上下限分别为 $1$（对应 $P=0$）和 $1 + \\frac{\\gamma p(z)}{\\rho_0 c_0^2}$（对应 $P=p(z)$）。积分变为：\n$$\n\\int_{1}^{1 + \\frac{\\gamma p(z)}{\\rho_0 c_0^2}} u^{-1/\\gamma} \\left(\\frac{\\rho_0 c_0^2}{\\gamma}\\right) du = \\frac{\\rho_0 c_0^2}{\\gamma} \\left[ \\frac{u^{1 - 1/\\gamma}}{1 - 1/\\gamma} \\right]_{1}^{1 + \\frac{\\gamma p(z)}{\\rho_0 c_0^2}}\n$$\n$$\n= \\frac{\\rho_0 c_0^2}{\\gamma} \\frac{\\gamma}{\\gamma-1} \\left[ u^{(\\gamma-1)/\\gamma} \\right]_{1}^{1 + \\frac{\\gamma p(z)}{\\rho_0 c_0^2}} = \\frac{\\rho_0 c_0^2}{\\gamma-1} \\left[ \\left(1 + \\frac{\\gamma p(z)}{\\rho_0 c_0^2}\\right)^{(\\gamma-1)/\\gamma} - 1 \\right]\n$$\n令两边的结果相等，可得：\n$$\n\\frac{\\rho_0 c_0^2}{\\gamma-1} \\left[ \\left(1 + \\frac{\\gamma p(z)}{\\rho_0 c_0^2}\\right)^{(\\gamma-1)/\\gamma} - 1 \\right] = g \\rho_0 (H-z)\n$$\n现在，我们求解 $p_{\\mathrm{eos}}(z)$：\n$$\n\\left(1 + \\frac{\\gamma p(z)}{\\rho_0 c_0^2}\\right)^{(\\gamma-1)/\\gamma} = 1 + \\frac{g(\\gamma-1)(H-z)}{c_0^2}\n$$\n$$\n1 + \\frac{\\gamma p(z)}{\\rho_0 c_0^2} = \\left( 1 + \\frac{g(\\gamma-1)(H-z)}{c_0^2} \\right)^{\\gamma/(\\gamma-1)}\n$$\n$$\np_{\\mathrm{eos}}(z) = \\frac{\\rho_0 c_0^2}{\\gamma} \\left\\{ \\left( 1 + \\frac{g(\\gamma-1)(H-z)}{c_0^2} \\right)^{\\gamma/(\\gamma-1)} - 1 \\right\\}\n$$\n这就是弱可压缩静水压力的解析表达式。\n\n任务是找到 $\\Delta p_{\\max} = \\max_{0 \\le i  N} \\left| p_{\\mathrm{eos}}(z_i) - p_{\\mathrm{inc}}(z_i) \\right|$。一种暴力方法是在所有 $N$ 个粒子位置上计算这个值。然而，我们可以分析偏差函数 $\\Delta p(z) = p_{\\mathrm{eos}}(z) - p_{\\mathrm{inc}}(z)$ 的行为。让我们定义表面以下的深度为一个新变量 $X = H-z$。对于 $z \\in [0, H]$，有 $X \\in [0, H]$。压力表达式变为：\n$$\np_{\\mathrm{inc}}(X) = \\rho_0 g X\n$$\n$$\np_{\\mathrm{eos}}(X) = \\frac{\\rho_0 c_0^2}{\\gamma} \\left\\{ \\left( 1 + \\frac{g(\\gamma-1)X}{c_0^2} \\right)^{\\gamma/(\\gamma-1)} - 1 \\right\\}\n$$\n在 $X=0$（表面）处，两种压力都为 $0$，所以偏差为 $0$。我们来考察偏差对 $X$ 的导数。\n$$\n\\frac{dp_{\\mathrm{inc}}}{dX} = \\rho_0 g\n$$\n$$\n\\frac{dp_{\\mathrm{eos}}}{dX} = \\frac{\\rho_0 c_0^2}{\\gamma} \\left[ \\frac{\\gamma}{\\gamma-1} \\left( 1 + \\frac{g(\\gamma-1)X}{c_0^2} \\right)^{\\frac{\\gamma}{\\gamma-1}-1} \\cdot \\frac{g(\\gamma-1)}{c_0^2} \\right] = \\rho_0 g \\left( 1 + \\frac{g(\\gamma-1)X}{c_0^2} \\right)^{1/(\\gamma-1)}\n$$\n鉴于对于表面以下的任何点，$g$、$\\gamma-1$（因为 $\\gamma=7.0$）和 $X$ 都是正数，所以括号中的项大于 $1$。由于指数 $1/(\\gamma-1)$ 也是正数，我们有：\n$$\n\\frac{dp_{\\mathrm{eos}}}{dX} > \\rho_0 g = \\frac{dp_{\\mathrm{inc}}}{dX} \\quad \\text{for } X > 0\n$$\n由于 $p_{\\mathrm{eos}}(0) = p_{\\mathrm{inc}}(0) = 0$，并且对于 $X>0$，$p_{\\mathrm{eos}}(X)$ 的斜率始终大于 $p_{\\mathrm{inc}}(X)$ 的斜率，因此函数 $p_{\\mathrm{eos}}(X)$ 总是大于 $p_{\\mathrm{inc}}(X)$，它们的差值 $\\Delta p(X) = p_{\\mathrm{eos}}(X) - p_{\\mathrm{inc}}(X)$ 是关于深度 $X$ 的单调递增函数。\n因此，最大偏差必然出现在最大深度处，即 $X=H$，对应于水柱底部 $z=0$ 处。离散化对于找到最大值是无关紧要的，因为可以保证最大值出现在粒子集所包含的空间域的某个端点，具体来说是 $z_0=0$。\n计算简化为：\n$$\n\\Delta p_{\\max} = |p_{\\mathrm{eos}}(0) - p_{\\mathrm{inc}}(0)|\n$$\n其中\n$$\np_{\\mathrm{inc}}(0) = \\rho_0 g H\n$$\n$$\np_{\\mathrm{eos}}(0) = \\frac{\\rho_0 c_0^2}{\\gamma} \\left\\{ \\left( 1 + \\frac{g(\\gamma-1)H}{c_0^2} \\right)^{\\gamma/(\\gamma-1)} - 1 \\right\\}\n$$\n这一洞见极大地简化了数值实现，因为每个测试用例只需要在一个点上进行评估。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the maximum absolute pressure deviation between an incompressible\n    and a weakly compressible hydrostatic model for a set of test cases.\n    \"\"\"\n    \n    # Test cases: (rho_0, g, H, c_0, gamma, N)\n    test_cases = [\n        # Case A: Happy path\n        (1000.0, 9.81, 1.0, 50.0, 7.0, 101),\n        # Case B: Shallow column\n        (1000.0, 9.81, 0.1, 50.0, 7.0, 11),\n        # Case C: Soft EOS\n        (1000.0, 9.81, 2.0, 10.0, 7.0, 201),\n        # Case D: Stiff EOS (near-incompressible)\n        (1000.0, 9.81, 2.0, 1000.0, 7.0, 51),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        rho_0, g, H, c_0, gamma, N = case\n        \n        # As derived in the solution, the maximum pressure deviation occurs at the\n        # maximum depth, z=0. We only need to calculate the pressures at this point.\n        z = 0.0\n        \n        # 1. Incompressible pressure at z=0\n        p_inc_at_0 = rho_0 * g * (H - z)\n        \n        # 2. EOS-based pressure at z=0\n        # The term H-z is the depth below the free surface.\n        depth = H - z\n        \n        # The term inside the power function\n        base_term = 1.0 + (g * (gamma - 1.0) * depth) / (c_0**2)\n        \n        # The exponent\n        exponent = gamma / (gamma - 1.0)\n        \n        # Full expression for p_eos at z=0\n        p_eos_at_0 = (rho_0 * c_0**2 / gamma) * (base_term**exponent - 1.0)\n        \n        # 3. Maximum absolute deviation\n        delta_p_max = abs(p_eos_at_0 - p_inc_at_0)\n        \n        # Round to three decimal places and append to results list\n        results.append(f\"{delta_p_max:.3f}\")\n\n    # Format the final output string as per requirements\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2413331"}, {"introduction": "任何数值方法在求解连续方程时都会引入离散化误差，这些误差通常表现为数值色散（导致波形变形）和数值耗散（导致波幅衰减）。本练习将指导您使用傅里叶分析这一强大工具，对一个简化的粒子平流格式进行严格的数值属性评估 [@problem_id:2413385]。通过分析该方法如何处理单个正弦波，您将学会如何量化其数值相速度和等效扩散系数，这直接对应于色散和耗散误差。这项实践不仅能让您了解粒子法的误差来源，更重要的是，它将教会您一种评估任何数值算法保真度的基本技能。", "problem": "考虑周期域上的一维线性平流方程，\n$$\\partial_t u(x,t)+c\\,\\partial_x u(x,t)=0,$$\n该方程定义在区间 $[0,L)$ 上，具有周期性边界条件和恒定的平流速度 $c$。设 $N$ 个拉格朗日粒子初始放置在位置 $x_i=i\\,h$（其中 $i\\in\\{0,1,\\dots,N-1\\}$，$h=L/N$），每个粒子携带初始条件\n$$u_0(x)=\\cos(k\\,x),\\quad k=\\frac{2\\pi n}{L},$$\n的标量值 $u_i^0=u_0(x_i)$，其中 $n$ 为给定的整数模态指数。经过一个时间步长 $\\Delta t$，粒子位置通过精确的拉格朗日映射进行更新\n$$x_i'=(x_i+c\\,\\Delta t)\\bmod L,$$\n而其携带的值保持不变，$u_i'=u_i^0$。为了在这一步之后估计原始粒子位置 $\\{x_j\\}_{j=0}^{N-1}$ 上的场，定义核函数平滑重构\n$$u^{\\mathrm{rec}}(x_j)=\\frac{\\sum_{i=0}^{N-1} u_i'\\,W\\!\\big(d(x_j-x_i')\\big)}{\\sum_{i=0}^{N-1} W\\!\\big(d(x_j-x_i')\\big)},$$\n其中 $W(r)=\\exp\\!\\big(-[r/(\\beta h)]^2\\big)$ 是一个高斯核函数，$\\beta0$ 是无量纲平滑参数，$d(r)$ 是 $r$ 模 $L$ 的等价类在 $(-L/2,L/2]$ 中的唯一代表，即\n$$d(r)=r-mL\\quad\\text{其中}\\quad m=\\operatorname{round}\\!\\left(\\frac{r}{L}\\right),\\quad d(r)\\in(-L/2,L/2].$$\n对于网格采样场 $v(x_j)$，定义其在波数 $k$ 处的离散傅里叶系数为\n$$\\hat{v}(k)=\\frac{1}{N}\\sum_{j=0}^{N-1} v(x_j)\\,e^{-i k x_j}。$$\n令 $\\hat{U}_0=\\hat{u}_0(k)$ 为初始场的系数，$\\hat{U}_1=\\widehat{u^{\\mathrm{rec}}}(k)$ 为一个时间步长后重构场的系数。定义复数比\n$$R=\\frac{\\hat{U}_1}{\\hat{U}_0}。$$\n使用 $R$，定义数值相速度\n$$c_{\\mathrm{num}}=-\\frac{\\arg(R)}{k\\,\\Delta t}，$$\n以及与模态振幅衰减相关的等效扩散系数，\n$$D_{\\mathrm{eq}}=-\\frac{1}{k^2\\,\\Delta t}\\,\\ln|R|。$$\n色散误差为 $c_{\\mathrm{num}}-c$。所有量均为无量纲，所有角度均以弧度为单位。对于以下测试集，请为每种情况计算如上定义的色散误差和等效扩散系数，重构时使用相同的 $W(r)$ 和 $d(r)$。按指定顺序汇总结果，并生成单行输出，其中包含所有数值，形式为方括号内的逗号分隔列表。\n\n测试集：\n- 情况 A（良好解析，小位移）：$L=1$，$N=200$，$c=1$，$\\beta=0.6$，$n=3$，$\\Delta t=0.2\\,h$。\n- 情况 B（近奈奎斯特模态，中等位移）：$L=1$，$N=128$，$c=1$，$\\beta=0.6$，$n=60$，$\\Delta t=0.5\\,h$。\n- 情况 C（网格偏移位移）：$L=1$，$N=150$，$c=1$，$\\beta=0.6$，$n=10$，$\\Delta t=1.0\\,h$。\n\n您的程序应生成单行输出，其中包含以下顺序的结果，格式为方括号内的逗号分隔列表：\n$$[\\,(c_{\\mathrm{num}}-c)_{\\mathrm{A}},\\,D_{\\mathrm{eq,A}},\\,(c_{\\mathrm{num}}-c)_{\\mathrm{B}},\\,D_{\\mathrm{eq,B}},\\,(c_{\\mathrm{num}}-c)_{\\mathrm{C}},\\,D_{\\mathrm{eq,C}}\\,].$$", "solution": "该问题要求计算一种基于拉格朗日粒子的方法在应用于一维线性平流方程时的数值误差度量——具体而言是色散误差和等效扩散。对此类数值格式的恰当科学分析不涉及暴力、逐步的模拟，而是要求对其在傅里叶模态上的行为进行更基本的分析，因为控制方程和数值算子的线性特性允许进行分解和叠加。\n\n完整的数值方法包括两个阶段：拉格朗日粒子的精确平流，以及随后将场通过基于核函数的方法重构到原始网格上。这个两阶段过程可以看作一个单一的线性算子 $\\mathcal{L}$，它将初始网格采样场 $u^0 = \\{u_j^0\\}_{j=0}^{N-1}$ 映射到一个时间步长后的重构场 $u^1 = \\{u_j^{\\mathrm{rec}}\\}_{j=0}^{N-1}$。即，$u^1 = \\mathcal{L}(u^0)$。\n\n该问题设置的初始条件为 $u_0(x) = \\cos(kx)$，其中 $k = \\frac{2\\pi n}{L}$。在离散网格 $x_j=j h$ 上，初始条件为 $u_j^0 = \\cos(k x_j)$。使用 Euler 恒等式，我们可以将其写为 $u_j^0 = \\frac{1}{2}(e^{i k x_j} + e^{-i k x_j})$。分析的本质在于确定算子 $\\mathcal{L}$ 对单个复傅里叶模态 $v_j = e^{i k x_j}$ 的作用。由于网格的空间均匀性以及重构核函数的平移不变性，算子 $\\mathcal{L}$ 是一个关于空间位置的线性时不变 (LTI) 系统。因此，它对傅里叶模态的作用是乘以一个复常数，该常数被称为放大因子或特征值 $R(k)$。\n$$ \\mathcal{L}(\\{e^{i k x_j}\\}) = R(k) \\cdot \\{e^{i k x_j}\\} $$\n问题中定义了比值 $R = \\hat{U}_1/\\hat{U}_0$，其中 $\\hat{U}_0$ 和 $\\hat{U}_1$ 分别是初始场和重构场在波数 $k$ 处的离散傅里叶系数。对于初始条件 $u_0(x)=\\cos(kx)$，其离散傅里叶变换 $\\hat{u}_0(k)$ 仅在波数 $\\pm k$ 处非零。可以证明，对于 $n \\in \\{1, \\dots, N/2 - 1\\}$，$\\hat{U}_0 = \\hat{u}_0(k) = 1/2$。重构场的傅里叶系数将是 $\\hat{U}_1 = \\hat{u}^{\\mathrm{rec}}(k) = \\frac{1}{2}R(k)$，因此比值 $R = R(k)$。于是，我们的任务简化为求解放大因子 $R(k)$。\n\n让我们推导 $R(k)$ 的表达式。第 $i$ 个粒子携带的值为 $u_i' = u_i^0$。对于输入模态 $e^{ikx}$，该值为 $u_i' = e^{ikx_i}$。粒子的新位置是 $x_i' = (x_i + c\\Delta t) \\bmod L$。我们定义 $\\Delta x = c\\Delta t$。\n在网格点 $x_j$ 处的重构场由下式给出\n$$ u^{\\mathrm{rec}}(x_j) = \\frac{\\sum_{i=0}^{N-1} u_i'\\,W(d(x_j-x_i'))}{\\sum_{i=0}^{N-1} W(d(x_j-x_i'))} $$\n分母是相同位移核函数的和。由于平流后的粒子位置集合 $\\{x_i'\\}$ 只是一个平移了 $\\Delta x$ 的均匀网格，这个和与重构点 $x_j$ 无关。我们用 $B$ 表示这个恒定的分母。\n$$ B = \\sum_{i=0}^{N-1} W(d(x_j-x_i')) = \\sum_{m=0}^{N-1} W(d(mh-\\Delta x)) $$\n对于输入 $u_i' = e^{ikx_i}$，分子为\n$$ \\text{Numerator} = \\sum_{i=0}^{N-1} e^{ikx_i} W(d(x_j - (x_i+\\Delta x))) $$\n将 $x_i$ 表示为 $x_j - (j-i)h$ 并令 $m=j-i \\pmod N$，我们得到：\n$$ \\text{Numerator} = \\sum_{m=0}^{N-1} e^{ik(x_j - mh)} W(d(mh-\\Delta x)) = e^{ikx_j} \\sum_{m=0}^{N-1} W(d(mh-\\Delta x)) e^{-ikmh} $$\n令 $G = \\sum_{m=0}^{N-1} W(d(mh-\\Delta x)) e^{-ikmh}$。\n重构场为 $u^{\\mathrm{rec}}(x_j) = \\frac{G}{B} e^{ikx_j}$。因此，放大因子为 $R(k) = G/B$。\n$$ R = R(k) = \\frac{\\sum_{m=0}^{N-1} W(d(mh-c\\Delta t)) e^{-ikmh}}{\\sum_{m=0}^{N-1} W(d(mh-c\\Delta t))} $$\n这个表达式是精确的，能够直接高效地计算 $R$。\n\n数值相速度 $c_{\\mathrm{num}}$ 和等效扩散 $D_{\\mathrm{eq}}$ 是通过将数值放大因子 $R$ 与解析平流扩散方程的放大因子 $e^{(-ikc_{\\mathrm{num}} - k^2 D_{\\mathrm{eq}})\\Delta t}$ 相关联来定义的。将其与 $R = |R|e^{i\\arg(R)}$ 等同，可得：\n$$ c_{\\mathrm{num}} = -\\frac{\\arg(R)}{k\\,\\Delta t} \\quad \\text{以及} \\quad D_{\\mathrm{eq}} = -\\frac{\\ln|R|}{k^2\\,\\Delta t} $$\n于是色散误差为 $c_{\\mathrm{num}}-c$。\n\n通过对每个测试用例实施这些公式来获得解答。\n对于每种情况，我们确定参数 $L, N, c, \\beta, n, \\Delta t$。根据这些参数，我们计算 $h=L/N$、$k=2\\pi n/L$ 和 $\\Delta x=c\\Delta t$。然后，我们对指数 $m \\in \\{0, 1, ..., N-1\\}$ 进行求和，计算分子 $G$ 和分母 $B$。比值 $R=G/B$ 提供了计算色散误差和等效扩散所需的所有信息。所有测试用例的计算都基于这个稳健的分析框架。", "answer": "```python\n# The final implementation adheres to the specified execution environment.\n# language: Python\n# version: 3.12\n# libraries: numpy==1.23.5, scipy==1.11.4\n\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating dispersion error and equivalent diffusion\n    for a particle-based advection scheme based on an analytical formula\n    for the amplification factor.\n    \"\"\"\n\n    # Test suite as defined in the problem statement.\n    # Each tuple contains: (L, N, c, beta, n, dt_h), where dt_h is Delta t in units of h.\n    test_cases = [\n        # Case A (well-resolved, small displacement)\n        (1.0, 200, 1.0, 0.6, 3, 0.2),\n        # Case B (near-Nyquist mode, moderate displacement)\n        (1.0, 128, 1.0, 0.6, 60, 0.5),\n        # Case C (grid-shift displacement)\n        (1.0, 150, 1.0, 0.6, 10, 1.0),\n    ]\n\n    results = []\n    \n    # Per the problem, round(r/L) is used for the periodic distance function.\n    # numpy.round rounds to the nearest even integer for halves, a standard\n    # and deterministic choice.\n    def periodic_distance(r, L):\n        \"\"\"\n        Calculates the periodic distance representative in (-L/2, L/2].\n        The problem defines this via d(r) = r - m*L where m = round(r/L).\n        \"\"\"\n        return r - L * np.round(r / L)\n\n    def kernel_W(r, beta, h):\n        \"\"\"\n        Gaussian kernel function W(r) = exp(-[r/(beta*h)]^2).\n        \"\"\"\n        arg = r / (beta * h)\n        return np.exp(-arg**2)\n\n    for case in test_cases:\n        L, N, c, beta, n, dt_h = case\n        \n        # Calculate derived parameters for the case.\n        h = L / N\n        dt = dt_h * h\n        k = 2.0 * np.pi * n / L\n        delta_x = c * dt\n        \n        # Array of indices for the summation, m = 0, 1, ..., N-1.\n        m_vals = np.arange(N)\n        \n        # Calculate the arguments for the periodic distance function.\n        r_vals = m_vals * h - delta_x\n        \n        # Apply the periodic distance function to all arguments.\n        d_vals = periodic_distance(r_vals, L)\n        \n        # Evaluate the kernel function for all periodic distances.\n        W_vals = kernel_W(d_vals, beta, h)\n        \n        # The denominator B is the sum of kernel values.\n        B = np.sum(W_vals)\n        \n        # The numerator G is the discrete Fourier-like sum.\n        exp_vals = np.exp(-1j * k * m_vals * h)\n        G = np.sum(W_vals * exp_vals)\n        \n        # R is the complex amplification factor.\n        # Guard against division by zero, though unlikely with a Gaussian kernel.\n        if B == 0:\n            R = 0.0 + 0.0j\n        else:\n            R = G / B\n        \n        # Calculate numerical phase speed and equivalent diffusion.\n        # These definitions are singular if k=0 or dt=0, but test cases avoid this.\n        if k == 0 or dt == 0:\n            c_num = c\n            D_eq = 0.0\n        else:\n            c_num = -np.angle(R) / (k * dt)\n            \n            # Use a tolerance to avoid taking the log of zero.\n            abs_R = np.abs(R)\n            if abs_R > 1e-16:\n                D_eq = -np.log(abs_R) / (k**2 * dt)\n            else:\n                D_eq = np.inf\n        \n        # The dispersion error is the difference between numerical and exact phase speeds.\n        dispersion_error = c_num - c\n        \n        results.append(dispersion_error)\n        results.append(D_eq)\n\n    # Print the final results in the specified single-line format.\n    # Using scientific notation for consistent formatting and precision.\n    print(f\"[{','.join(f'{val:.10e}' for val in results)}]\")\n\nsolve()\n```", "id": "2413385"}, {"introduction": "在真实的粒子模拟中，尤其是在三维情况下，计算成本可能非常高昂，其中最耗时的部分通常是为每个粒子寻找其邻居。一个常见的优化策略是“延迟”邻居列表的更新，即并非在每个时间步都重新构建邻居列表，而是每隔 $N$ 步更新一次。本练习将引导您亲手探索这一在实际应用中至关重要的权衡：计算效率与模拟精度 [@problem_id:2413353]。您将针对一个粒子轨迹已知的 SPH 密度计算问题，通过编程实现并量化不同更新频率对最终结果精度和总计算量的影响，从而深刻理解在开发高性能粒子模拟程序时所面临的核心挑战与决策依据。", "problem": "考虑一个一维系综，由 $M$ 个相同的拉格朗日粒子组成，分布在长度为 $L$ 的周期性区域上，每个粒子的质量均为 $m$。设初始位置均匀分布，为 $x_i^0 = \\left(i + \\tfrac{1}{2}\\right)\\Delta x$，其中 $\\Delta x = L/M$，对于 $i=0,1,\\dots,M-1$。粒子的运动轨迹由与时间相关的映射规定：\n$$\nx_i(t) = \\left[x_i^0 + A \\sin\\!\\left(\\tfrac{2\\pi}{L} x_i^0\\right)\\sin(\\omega t)\\right] \\bmod L,\n$$\n所有物理量均为无量纲。两两之间的距离采用在 $[0,L)$ 上的最小镜像约定：\n$$\nd(x,y) = \\min\\!\\left(|x-y|,\\, L - |x-y|\\right).\n$$\n将粒子 $i$ 在时间 $t$ 的光滑粒子流体动力学（SPH）密度估计定义为：\n$$\n\\rho_i(t) = \\sum_{j=0}^{M-1} m \\, W\\!\\left(d\\!\\left(x_i(t),x_j(t)\\right), h\\right),\n$$\n其中，平滑长度为 $h$ 的一维三次样条核函数 $W$ 为：\n$$\nW(r,h) = \\begin{cases}\n\\dfrac{1}{h}\\left(\\dfrac{2}{3} - q^2 + \\dfrac{1}{2}q^3\\right),  0 \\le q  1 \\\\\n\\dfrac{1}{h}\\left(\\dfrac{1}{6}(2 - q)^3\\right),  1 \\le q  2 \\\\\n0,  q \\ge 2\n\\end{cases}\n\\quad \\text{其中 } q = \\dfrac{r}{h}.\n$$\n考虑离散时间 $t_s = s\\,\\Delta t$，其中 $s=0,1,\\dots,S-1$。在时间步 $s$ 的邻居列表是对于每个粒子 $i$ 的一组索引 $j$，满足 $d\\!\\left(x_i(t_s),x_j(t_s)\\right)  2h$。假设邻居列表仅每 $N$ 步重新计算一次：在满足 $s \\equiv 0 \\pmod N$ 的时间步 $s$ 构建邻居列表；在其他时间步，则重用最近一次构建的邻居列表来计算 $\\rho_i(t_s)$，而粒子位置 $x_i(t_s)$ 继续按照规定的轨迹演化。在计算 $\\rho_i(t_s)$ 时，必须始终包含自身贡献（即 $j=i$ 的情况）。\n\n将给定步长 $N$ 的精度度量定义为相对于参考情况 $N=1$ 的所有粒子和所有时间的均方根（RMS）密度误差：\n$$\nE_N = \\left(\\frac{1}{MS}\\sum_{s=0}^{S-1}\\sum_{i=0}^{M-1}\\left[\\rho_i^{(N)}(t_s)-\\rho_i^{(1)}(t_s)\\right]^2\\right)^{1/2}.\n$$\n将中央处理器（CPU）时间的代理指标定义为在整个模拟过程中，对于步长 $N$，两两之间绝对距离计算的总次数 $C_N$，其中：\n- 在每个邻居列表重建步骤中，所有 $i \\ne j$ 的无序对 $\\{i,j\\}$ 都被检查一次（每次重建计为 $\\tfrac{M(M-1)}{2}$ 次绝对距离计算）。\n- 在每个时间步，使用当前邻居列表计算密度总和时，求和中使用的每个邻居对（不包括自身贡献）计为一次绝对距离计算。\n\n所有量均为无量纲。使用以下固定参数：\n- $L = 1$，$M = 64$，$\\Delta x = L/M$，$m = 1/M$，\n- $h = 0.98\\,\\Delta x$，\n- $A = 0.25\\,\\Delta x$，\n- $\\omega = 2\\pi$，\n- $\\Delta t = 0.01$，$S = 200$。\n\n测试集（需要评估的邻居列表步长 $N$ 值）：\n- 情况 1: $N = 1$,\n- 情况 2: $N = 2$,\n- 情况 3: $N = 5$,\n- 情况 4: $N = 200$.\n\n对于每种情况，计算数对 $[E_N, C_N]$，其中 $E_N$ 是一个四舍五入到六位小数的浮点数，$C_N$ 是一个整数。您的程序应生成单行输出，其中包含按测试集顺序排列的结果，形式为由逗号分隔的数对列表，并用方括号括起来。例如：\n\"[[E_1,C_1],[E_2,C_2],[E_3,C_3],[E_4,C_4]]\"", "solution": "该问题是有效的。它提出了一个在光滑粒子流体动力学（SPH）领域定义明确的计算实验。SPH 是一种用于计算工程和物理学的无网格方法。该问题具有科学依据，数学上一致，并且所有参数和步骤都得到了明确的规定。其目标是分析在使用一种常见的优化技术——不频繁更新邻居列表时，计算成本和精度之间的权衡。\n\n解决方案是通过执行所述的直接数值模拟获得的。问题的核心在于为具有规定轨迹的一维粒子系统实现 SPH 形式体系。算法的主要步骤如下：\n\n1.  **系统初始化**：定义所有指定的物理和数值参数：区域长度 $L$、粒子数 $M$、粒子质量 $m$、平滑长度 $h$、轨迹振幅 $A$ 和频率 $\\omega$，以及时间步进参数 $\\Delta t$ 和 $S$。$M$ 个粒子的初始位置 $x_i^0$ 被设定为在周期性区域 $[0, L)$ 上均匀分布。\n\n2.  **核心函数的实现**：需要三个关键函数：\n    *   **粒子轨迹 $x_i(t)$**：一个根据规定的映射计算任何粒子 $i$ 在任何给定时间 $t$ 的位置的函数：\n        $$x_i(t) = \\left[x_i^0 + A \\sin\\!\\left(\\tfrac{2\\pi}{L} x_i^0\\right)\\sin(\\omega t)\\right] \\bmod L$$\n    *   **周期性距离 $d(x,y)$**：一个使用最小镜像约定计算周期性区域上两点之间距离的函数：\n        $$d(x,y) = \\min\\!\\left(|x-y|,\\, L - |x-y|\\right)$$\n    *   **SPH 核函数 $W(r,h)$**：一个实现一维三次样条核函数的函数。其值取决于归一化距离 $q = r/h$：\n        $$W(r,h) = \\begin{cases} \\frac{1}{h}(\\frac{2}{3} - q^2 + \\frac{1}{2}q^3)  0 \\le q  1 \\\\ \\frac{1}{h}(\\frac{1}{6}(2-q)^3)  1 \\le q  2 \\\\ 0  q \\ge 2 \\end{cases}$$\n\n3.  **针对不同步长 $N$ 的模拟**：算法的主体部分是一个循环，遍历邻居列表更新步长 $N \\in \\{1, 2, 5, 200\\}$ 的指定测试用例。对于每个 $N$，执行一个包含 $S$ 个时间步的完整模拟。\n\n4.  **时间步进循环**：对于给定的 $N$，模拟在离散时间步 $t_s = s\\Delta t$（$s=0, 1, \\dots, S-1$）上进行。在每个时间步 $s$：\n    *   更新所有粒子的位置 $x_i(t_s)$。\n    *   通过检查 `if s % N == 0` 来确定是否应重建邻居列表。\n    *   **邻居列表重建**：如果需要重建，则检查所有唯一的无序粒子对 $\\{i,j\\}$。计算每对粒子之间的距离 $d(x_i(t_s), x_j(t_s))$。如果此距离小于核函数的支持域截断半径 $2h$，则将这两个粒子添加到彼此的邻居列表中。计算成本代理指标 $C_N$ 因这次 N 体检查而增加 $\\frac{M(M-1)}{2}$。\n    *   **密度计算**：使用当前的邻居列表（如果未发生重建，则该列表可能来自之前的步骤），为每个粒子计算密度 $\\rho_i^{(N)}(t_s)$。公式为：\n        $$\\rho_i^{(N)}(t_s) = m W(0, h) + \\sum_{j \\in \\text{neighbors}(i)} m W(d(x_i(t_s), x_j(t_s)), h)$$\n        自身贡献项 $m W(0, h)$ 总是被包括在内。请注意，即使邻居列表本身是“过时的”，距离 $d(x_i(t_s), x_j(t_s))$ 也必须在当前时间 $t_s$ 重新计算。\n    *   **成本累积**：成本 $C_N$ 会进一步增加，增量为密度求和所需的成对距离计算次数。根据问题描述，这是该时间步使用的所有邻居列表中的条目总数，代表了在求和中计算的有序对 $(i,j)$ 的数量。\n\n5.  **误差计算**：\n    *   以 $N=1$ 的模拟作为高保真度参考。其密度历史 $\\rho_i^{(1)}(t_s)$ 被存储下来。根据定义，其误差 $E_1=0$。\n    *   对于每个后续的 $N  1$ 的模拟，将其产生的密度历史 $\\rho_i^{(N)}(t_s)$ 与参考值进行比较。均方根误差 $E_N$ 使用提供的公式计算：\n        $$E_N = \\left(\\frac{1}{MS}\\sum_{s=0}^{S-1}\\sum_{i=0}^{M-1}\\left[\\rho_i^{(N)}(t_s)-\\rho_i^{(1)}(t_s)\\right]^2\\right)^{1/2}$$\n\n6.  **最终输出**：对于每个 $N$，存储计算出的数对 $[E_N, C_N]$，其中 $E_N$ 四舍五入到六位小数。将这些数对的最终集合格式化为指定的字符串格式。\n\n整个过程使用 Python 的 `NumPy` 库实现，以便对粒子数组进行高效的矢量化操作。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the SPH neighbor list accuracy vs. cost problem.\n    \"\"\"\n    # Define fixed parameters\n    L = 1.0\n    M = 64\n    dx = L / M\n    m = 1.0 / M\n    h = 0.98 * dx\n    A = 0.25 * dx\n    omega = 2.0 * np.pi\n    dt = 0.01\n    S = 200\n\n    # Test cases for neighbor-list stride N\n    test_cases = [1, 2, 5, 200]\n\n    # --- Helper Functions ---\n    def min_image_dist(p1, p2, domain_length):\n        \"\"\"\n        Calculates the minimum image distance in a periodic domain.\n        Can handle p1 being a scalar and p2 being a numpy array.\n        \"\"\"\n        delta = np.abs(p1 - p2)\n        return np.minimum(delta, domain_length - delta)\n\n    def kernel_W(r, h_val):\n        \"\"\"\n        Computes the 1D cubic spline kernel value.\n        Handles both scalar and numpy array inputs for r.\n        \"\"\"\n        was_scalar = np.isscalar(r)\n        r = np.atleast_1d(r)\n        \n        q = r / h_val\n        \n        # Branch for 0 = q  1\n        term1 = (1/h_val) * (2/3 - q**2 + 0.5 * q**3)\n        # Branch for 1 = q  2\n        term2 = (1/h_val) * (1/6) * (2 - q)**3\n        \n        w = np.where(q  1, term1, np.where(q  2, term2, 0.0))\n        \n        return w.item() if was_scalar else w\n\n    # --- Simulation Logic ---\n\n    # Initial particle positions\n    x0 = (np.arange(M) + 0.5) * dx\n\n    final_results = []\n    rho_ref_history = None\n    \n    # Pre-calculate self-contribution term for density\n    self_contrib_rho = m * kernel_W(0.0, h)\n\n    for N in test_cases:\n        cost_N = 0\n        rho_N_history = np.zeros((S, M))\n        neighbor_lists = [[] for _ in range(M)]\n\n        for s in range(S):\n            t = s * dt\n            \n            # Calculate current particle positions\n            positions = (x0 + A * np.sin(2 * np.pi / L * x0) * np.sin(omega * t)) % L\n\n            # Rebuild neighbor list if s is a multiple of N\n            if s % N == 0:\n                cost_N += M * (M - 1) // 2\n                neighbor_lists = [[] for _ in range(M)]\n                for i in range(M):\n                    for j in range(i + 1, M):\n                        dist = min_image_dist(positions[i], positions[j], L)\n                        if dist  2 * h:\n                            neighbor_lists[i].append(j)\n                            neighbor_lists[j].append(i)\n\n            # Calculate SPH density for each particle\n            current_densities = np.full(M, self_contrib_rho)\n            density_eval_cost = 0\n            for i in range(M):\n                if not neighbor_lists[i]:\n                    continue\n                \n                # Vectorized calculation for all neighbors of particle i\n                neighbor_indices = np.array(neighbor_lists[i])\n                neighbor_pos = positions[neighbor_indices]\n                \n                distances = min_image_dist(positions[i], neighbor_pos, L)\n                kernel_values = kernel_W(distances, h)\n                \n                current_densities[i] += m * np.sum(kernel_values)\n                density_eval_cost += len(neighbor_indices)\n\n            cost_N += density_eval_cost\n            rho_N_history[s, :] = current_densities\n\n        # Post-simulation processing for this N\n        if N == 1:\n            rho_ref_history = rho_N_history\n            E_N = 0.0\n        else:\n            # Calculate RMS error relative to N=1 case\n            diff_sq = (rho_N_history - rho_ref_history)**2\n            mean_sq_err = np.mean(diff_sq)\n            E_N = np.sqrt(mean_sq_err)\n\n        final_results.append([round(E_N, 6), int(cost_N)])\n\n    # Format the final output string exactly as required\n    output_str = f\"[{','.join([f'[{e},{c}]' for e, c in final_results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2413353"}]}