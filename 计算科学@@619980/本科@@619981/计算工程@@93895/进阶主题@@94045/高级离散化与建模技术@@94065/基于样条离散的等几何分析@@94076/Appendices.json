{"hands_on_practices": [{"introduction": "构建精确的仿真模型始于组装系统矩阵的基本步骤。在等几何分析中，元素域上的积分是通过数值方法计算的。本练习旨在解决一个关键的实践问题：对于给定的样条次数 $p$，精确计算质量矩阵所需的最小高斯积分点数是多少？掌握这一计算是确保有限元模型基本完整性的基石。[@problem_id:2405752]", "problem": "在等几何分析 (IGA) 的背景下，考虑参数域 $\\xi \\in [0,1]$ 上的一个一维模型问题，该问题使用在一个开放、非递减且具有简单内部节点的节点向量上定义的 $p$ 次B样条基 $\\{B_{i}^{p}(\\xi)\\}$ 进行离散。重点关注单个非零节点区间 $[\\xi_{a},\\xi_{b}] \\subset [0,1]$。假设物理域映射为单位映射，即 $x=\\xi$，因此雅可比行列式为 $1$，并且质量密度 $\\rho$ 在 $[\\xi_{a},\\xi_{b}]$上是常数。此节点区间上的单元质量矩阵项为\n$$\nM_{ij}^{(e)} \\;=\\; \\int_{\\xi_{a}}^{\\xi_{b}} \\rho\\, B_{i}^{p}(\\xi)\\, B_{j}^{p}(\\xi)\\, \\mathrm{d}\\xi.\n$$\n使用每个节点区间 $n$ 个点的高斯-勒让德求积法，为每一对支集与 $[\\xi_{a},\\xi_{b}]$ 相交的索引 $(i,j)$ 精确组装 $M_{ij}^{(e)}$，请确定为实现精确积分，每个节点区间所需的最少高斯点数 $n$ 作为样条次数 $p$ 的函数。请以关于 $p$ 的单个闭式表达式给出您的答案。", "solution": "该问题要求确定为精确计算单个节点区间 $[\\xi_{a},\\xi_{b}]$ 上的单元质量矩阵项 $M_{ij}^{(e)}$ 所需的高斯-勒让德求积点数的最少数量，记为 $n$。这些矩阵项的公式由下式给出\n$$\nM_{ij}^{(e)} = \\int_{\\xi_{a}}^{\\xi_{b}} \\rho\\, B_{i}^{p}(\\xi)\\, B_{j}^{p}(\\xi)\\, \\mathrm{d}\\xi\n$$\n其中 $\\rho$ 是一个恒定的质量密度，$B_{i}^{p}(\\xi)$ 是 $p$ 次B样条基函数。\n\n问题的核心在于分析该积分的被积函数。质量密度 $\\rho$ 被说明是常数。函数 $B_{i}^{p}(\\xi)$ 是 $p$ 次B样条基函数。B样条的一个关键性质是，在任何给定的非零节点区间（如 $[\\xi_{a}, \\xi_{b}]$）上，每个在该区间上有支集的基函数 $B_{i}^{p}(\\xi)$ 都是一个次数恰好为 $p$ 的多项式。\n\n被积函数是三项的乘积：$\\rho$、$B_{i}^{p}(\\xi)$ 和 $B_{j}^{p}(\\xi)$。由于 $\\rho$ 是一个常数（0次多项式），整个被积函数（我们称之为 $f(\\xi) = \\rho\\, B_{i}^{p}(\\xi)\\, B_{j}^{p}(\\xi)$）的次数由两个B样条基函数的乘积决定。多项式乘积的次数是它们各自次数的和。\n因此，在区间 $[\\xi_{a}, \\xi_{b}]$ 上，多项式 $B_{i}^{p}(\\xi)\\, B_{j}^{p}(\\xi)$ 的次数是 $p + p = 2p$。于是，被积函数 $f(\\xi)$ 是一个 $2p$ 次多项式。\n\n该问题指定使用高斯-勒让德求积法进行数值积分。数值分析的一个基本定理指出，一个具有 $n$ 个积分点的高斯-勒让德求积法则可以精确积分次数最高（含）为 $2n-1$ 的任何多项式。\n\n为了精确计算 $M_{ij}^{(e)}$ 的积分，求积法则的代数精度必须足以处理被积函数的次数。这导致以下不等式：\n$$\n2n-1 \\ge \\deg(f(\\xi))\n$$\n代入我们被积函数的次数，我们得到：\n$$\n2n-1 \\ge 2p\n$$\n我们必须找到满足此条件的 $n$ 的最小整数值。重新整理不等式以求解 $n$：\n$$\n2n \\ge 2p + 1\n$$\n$$\nn \\ge p + \\frac{1}{2}\n$$\n由于求积点数 $n$ 必须是整数，我们必须取大于或等于 $p + \\frac{1}{2}$ 的最小整数。这等价于取 $p + \\frac{1}{2}$ 的上取整。\n$$\nn_{\\min} = \\lceil p + 0.5 \\rceil\n$$\n鉴于样条次数 $p$ 是一个整数（例如 $1, 2, 3, \\ldots$），量 $p+0.5$ 永远不是整数。因此，上取整函数将总是向上取到下一个整数。\n$$\nn_{\\min} = p + 1\n$$\n为了验证这个结果：如果我们选择 $n = p+1$ 个点，高斯-勒让德法则将精确积分次数最高为 $2(p+1) - 1 = 2p+2-1=2p+1$ 的多项式。由于我们的被积函数是一个 $2p$ 次多项式，并且 $2p+1 \\ge 2p$，这个点数是足够的。如果我们选择 $n=p$ 个点，该法则将只能保证对次数最高为 $2p-1$ 的多项式是精确的，这对于一个 $2p$ 次多项式是不够的。\n\n因此，为精确组装质量矩阵，每个节点区间所需的最少高斯点数是 $p+1$。这个结果与具体的索引 $i$ 和 $j$ 无关（只要它们对应的基函数在所讨论的节点区间上有重叠的支集），也与恒定密度 $\\rho$ 和单位映射无关。", "answer": "$$\\boxed{p+1}$$", "id": "2405752"}, {"introduction": "现实世界的工程问题常常涉及由多种材料组成的部件，这导致其交界面处存在不连续的材料属性。本练习将探讨等几何分析中固有的光滑样条基函数如何与这类不连续性相互作用。你将研究由此产生的数值伪影——即吉布斯现象 (Gibbs phenomenon)，并分析在这些具有挑战性但又普遍存在的场景中，获得精确解的不同实用策略。[@problem_id:2405715]", "problem": "考虑物理域 $[0,1]$ 上的一维扩散问题：求 $u:[0,1]\\to\\mathbb{R}$ 使得\n$$\n-\\frac{\\mathrm{d}}{\\mathrm{d}x}\\Big(a(x)\\,\\frac{\\mathrm{d}u}{\\mathrm{d}x}(x)\\Big)=f(x)\\quad\\text{在 }(0,1)\\text{ 内},\\qquad u(0)=0,\\quad u(1)=1,\n$$\n其中体力项 $f(x)=0$，材料属性 $a(x)$ 是一个不连续的正值函数\n$$\na(x)=\\begin{cases}\na_1,& x<\\xi,\\\\\na_2,& x>\\xi,\n\\end{cases}\n$$\n其中 $a_1>0$，$a_2>0$，且跳跃位置 $\\xi\\in(0,1)$ 不是下述离散化中的一个节点。在等几何分析 (IGA) 离散化中，试探空间和检验空间被选为次数为 $p\\ge 2$ 的单变量 B 样条空间，其在 $[0,1]$ 上具有开放、均匀的节点矢量，并具有最大的单元间连续性 $C^{p-1}$。假设采用标准的伽辽金法，其双线性形式为\n$$\nB(u,v)=\\int_0^1 a(x)\\,u'(x)\\,v'(x)\\,\\mathrm{d}x,\n$$\n并且 IGA 近似解 $u_h$ 和 $v_h$ 取自上述 B 样条空间。\n\n在实践中，考虑两种组装变体：\n\n(i) 系数投影：不连续系数 $a(x)$ 被其在同一个 $C^{p-1}$ B 样条空间 $S_p$ 上的 $L^2$-投影 $a_h\\in S_p$ 所取代，定义为\n$$\n\\int_0^1\\big(a(x)-a_h(x)\\big)\\,w(x)\\,\\mathrm{d}x=0\\quad\\forall w\\in S_p,\n$$\n并且双线性形式使用 $a_h(x)$ 进行组装。\n\n(ii) 界面感知积分：通过在任何被切割的单元内部，在 $x=\\xi$ 处分割求积点来使用精确的不连续系数 $a(x)$ 进行积分（不对 $a$ 进行投影），同时保持 $u_h$ 和 $v_h$ 的试探和检验空间为同样的光滑空间。\n\n术语 “Gibbs 现象” 在此指当一个不连续函数被一个全局光滑的展开式逼近时，在 $x=\\xi$ 附近出现的伪振荡过冲和下冲。\n\n在此背景下，下列哪些陈述是正确的？\n\nA. 在变体 (i) 下，投影系数 $a_h(x)$ 通常在 $x=\\xi$ 附近相对于真值 $a_1$ 和 $a_2$ 表现出过冲和下冲，这会在计算出的通量 $q_h(x)=a_h(x)\\,u_h'(x)$ 中，在 $x=\\xi$ 附近引发局部振荡。\n\nB. 如果对同一个 $C^{p-1}$ 空间进行均匀的 $h$-细化，而不在 $x=\\xi$ 处插入节点，那么当 $h\\to 0$ 时，最大范数 $\\|a-a_h\\|_{L^\\infty(0,1)}$ 中的过冲会完全消除。\n\nC. 如果在 $x=\\xi$ 处插入一个重数为 $p$ 的节点（从而将试探/检验空间在 $x=\\xi$ 处的连续性降低到 $C^0$），并将 $a_h$ 计算为在每个节点区间上为常数的分段表示（这样就允许在 $x=\\xi$ 处出现跳跃），那么 $a_h$ 中的 Gibbs 型过冲就会被消除。\n\nD. 在固定的节点位置（其中 $\\xi$ 不是节点）和固定的网格尺寸下，增加样条次数 $p$ 同时保持单元间连续性为 $C^{p-1}$，必然会减小投影系数 $a_h$ 中过冲的振幅。\n\nE. 在变体 (ii) 下，组装通过求积点分割来使用精确的不连续系数 $a(x)$，因此在 $x=\\xi$ 附近没有对 $a$ 的振荡近似，同时用于 $u_h$ 的 IGA 解空间的光滑性保持不变。\n\n选择所有适用的选项。", "solution": "问题陈述已经过分析并被确定为有效。它提出了一个清晰、有科学依据且适定的计算科学问题，具体涉及具有不连续系数的扩散问题的等几何分析。该问题适合进行严格分析。我将继续推导解决方案。\n\n控制方程是一维稳态扩散方程，$-\\frac{\\mathrm{d}}{\\mathrm{d}x}\\big(a(x)\\,\\frac{\\mathrm{d}u}{\\mathrm{d}x}(x)\\big)=0$，在域 $[0,1]$ 上，狄利克雷边界条件为 $u(0)=0$ 和 $u(1)=1$。系数 $a(x)$ 是一个分段常数函数，在 $x=\\xi \\in (0,1)$ 处有跳跃不连续性，其中当 $x<\\xi$ 时 $a(x)=a_1$，当 $x>\\xi$ 时 $a(x)=a_2$。\n这个问题的精确解 $u(x)$ 是连续且分段线性的，在 $x=\\xi$ 处其一阶导数不连续（有一个“扭结”）。具体来说，$u(x) \\in H^1(0,1)$ 但 $u(x) \\notin H^2(0,1)$。数值近似解 $u_h$ 在次数为 $p \\ge 2$、具有最大单元间连续性 $C^{p-1}$ 的 B 样条空间 $S_p$ 中寻找。由于不连续点位置 $\\xi$ 不是一个节点，所以 $S_p$ 中的任何函数在整个域上都是 $C^{p-1}$ 光滑的，包括在 $x=\\xi$ 处。\n\n我们必须基于这些事实来评估每个陈述。\n\n**选项 A 的分析**\n这个选项描述了变体 (i)，其中不连续系数 $a(x)$ 首先被其在光滑样条空间 $S_p$ 上的 $L^2$-投影 $a_h(x)$ 所逼近。将一个不连续函数 $L^2$-投影到一个全局光滑函数空间（在本例中是 $p-1 \\ge 1$ 的 $C^{p-1}$ 连续样条空间）是导致 Gibbs 现象的典型例子。这种现象的特点是在不连续点附近出现伪振荡，包括超过和低于真值的过冲和下冲。因此，投影系数 $a_h(x)$ 确实会在 $x=\\xi$ 附近表现出这种振荡。\n\n在此变体中，计算出的通量是 $q_h(x) = a_h(x)u_h'(x)$。梯度的数值解 $u_h'(x)$ 是一个在次数为 $p-1$、连续性为 $C^{p-2}$ 的样条空间中的光滑函数。在界面 $x=\\xi$ 附近，$u_h'(x)$ 将是某个光滑的非零函数。当它与振荡的近似 $a_h(x)$ 相乘时，得到的通量 $q_h(x)$ 将继承这些振荡。这个问题的精确通量是恒定的，这意味着 $q_h(x)$中的这些振荡纯粹是数值伪影。因此，该陈述是对这种数值方案行为的正确描述。\n\n对 A 的裁定：**正确**。\n\n**选项 B 的分析**\n这个选项声称，均匀的 $h$-细化（即通过让节点间距 $h \\to 0$ 来使网格更密）将导致系数近似的最大误差 $\\|a-a_h\\|_{L^\\infty(0,1)}$ 收敛到零。这是关于 Gibbs 现象的一个典型谬论。虽然近似 $a_h$ 确实在 $L^2$ 范数下收敛于 $a$，但它不在 $L^\\infty$ 范数下（一致地）收敛。不连续点附近主过冲的幅度保持为跳跃高度 $|a_2 - a_1|$ 的一个固定百分比，并且不会随着 $h \\to 0$ 而减小。振荡只是被限制在 $\\xi$ 周围一个更小的区间内。因此，该陈述在事实上是不正确的。\n\n对 B 的裁定：**不正确**。\n\n**选项 C 的分析**\n这个选项提出了一个不同的策略。首先，它建议通过在不连续点 $x=\\xi$ 处插入一个重数为 $p$ 的节点来修改解 $u_h$ 的样条空间。对于一个次数为 $p$ 的 B 样条，这会将该节点的连续性降低到 $C^{p-p} = C^0$。这使得近似解 $u_h$ 可以在 $x=\\xi$ 处形成一个扭结（一个导数不连续的连续函数），从而正确地模仿了真解的正则性。其次，它建议将系数 $a(x)$ 表示为这个新网格单元上的分段常数函数。由于 $x=\\xi$ 现在是一个节点，它标记了单元之间的边界。一个分段常数函数可以精确地表示原始的分段常数系数 $a(x)$。也就是说，我们可以对所有 $x$ 设置 $a_h(x) = a(x)$。这消除了系数中的任何近似误差，因此没有 Gibbs 现象，没有过冲，也没有下冲。这是有限元分析和等几何分析中处理材料界面的标准且可靠的技术。\n\n对 C 的裁定：**正确**。\n\n**选项 D 的分析**\n这个选项声称，对于固定的网格，增加样条次数 $p$（同时保持 $C^{p-1}$ 连续性）*必然*会减小 $a_h$ 中过冲的振幅。这是不正确的。这个过程被称为 $p$-细化。当应用于不连续点与网格不对齐的问题时，使用高连续性基函数的 $p$-细化可能会表现不佳。用更光滑、次数更高的多项式来近似不连续函数 $a(x)$，并不能保证在跳跃点处有更好的点态行为。Gibbs 振荡的振幅不保证随 $p$ 单调减小；它可能会波动甚至增加。这个说法过于绝对，且没有样条近似理论的支持。\n\n对 D 的裁定：**不正确**。\n\n**选项 E 的分析**\n这个选项正确地描述了变体 (ii)，即“界面感知积分”方法。在这种方法中，双线性形式的积分 $B(u_h, v_h) = \\int_0^1 a(x) u_h'(x) v_h'(x) \\mathrm{d}x$ 是使用能够感知不连续性的数值求积来计算的。具体来说，对于任何被界面 $x=\\xi$“切割”的单元，该单元上的积分被分成两个子积分，一个从单元起点到 $\\xi$，另一个从 $\\xi$ 到单元终点。这使得精确值 $a_1$ 和 $a_2$ 可以在它们各自的子域中使用。因此，从未构造出像变体 (i) 中的 $a_h(x)$ 那样对 $a(x)$ 的振荡近似。该陈述还正确地指出，解的近似空间 $S_p$ 仍然是原始的全局 $C^{p-1}$ 光滑空间。整个陈述是对该过程在事实上的准确描述。\n\n对 E 的裁定：**正确**。", "answer": "$$\\boxed{ACE}$$", "id": "2405715"}, {"introduction": "为了创建高效且可靠的仿真，我们必须智能地将计算资源集中在误差最大的区域。本实践将带你进入后验误差估计这一高级主题，它是自适应分析的基石。你将通过编程实现一个基于跳跃的误差指示器，它通过量化解在元素边界上的不光滑程度来评估误差，从而为你提供一个指导网格加密、提升整体仿真精度的实用工具。[@problem_id:2405738]", "problem": "在等几何分析（IGA）的一维设定中，给定试探空间由定义在区间 $[0,1]$ 的一个剖分上的分片三次、全局连续可微样条（即 $C^1$ 样条）组成。对于一个属于 $C^1$ 类的分片三次函数 $u(x)$，其三阶导数 $u^{(3)}(x)$ 在每个单元上是常数，并可能在单元交界面处不连续。请仅使用 $u^{(3)}(x)$ 在单元边界上的跳跃，为每个单元定义一个局部的、基于跳跃的误差指示子。\n\n设网格由节点 $x_0, x_1, \\dots, x_N$ 定义，其中 $0 = x_0 < x_1 < \\dots < x_N = 1$。对于单元 $e \\in \\{1, \\dots, N\\}$，定义 $E_e = [x_{e-1}, x_e]$，单元尺寸为 $h_e = x_e - x_{e-1}$。在每个单元 $E_e$ 上，三阶导数为常数，记作 $g_e = u^{(3)}|_{E_e}$。在内部节点 $x_i$（其中 $i \\in \\{1, \\dots, N-1\\}$）处，三阶导数的跳跃定义为\n$$\n[u^{(3)}]_{x_i} = \\lim_{x \\to x_i^+} u^{(3)}(x) - \\lim_{x \\to x_i^-} u^{(3)}(x) = g_{i+1} - g_i.\n$$\n在边界节点 $x_0$ 和 $x_N$ 处，将跳跃设置为零：\n$$\n[u^{(3)}]_{x_0} = 0, \\quad [u^{(3)}]_{x_N} = 0.\n$$\n单元 $e$ 的局部指示子定义为\n$$\n\\eta_e = \\sqrt{h_e} \\, \\sqrt{ \\left( [u^{(3)}]_{x_{e-1}} \\right)^2 + \\left( [u^{(3)}]_{x_e} \\right)^2 }.\n$$\n\n您的任务是为以下每个测试用例计算每个单元的局部指示子 $\\eta_e$ 的列表。每个测试用例都由其节点坐标和 $u^{(3)}$ 的各单元常数值 $g_e$ 完全指定。\n\n测试套件（每个用例给出 $(x_0, \\dots, x_N)$ 和 $(g_1, \\dots, g_N)$）：\n- 用例 1（均匀网格，非平凡内部跳跃）：节点 $[0, 0.25, 0.5, 0.75, 1]$，值 $[2, 2, 5, 1]$。\n- 用例 2（均匀网格，无跳跃）：节点 $[0, \\tfrac{1}{3}, \\tfrac{2}{3}, 1]$，值 $[-1.2, -1.2, -1.2]$。\n- 用例 3（非均匀网格，大反差）：节点 $[0, 0.1, 0.4, 1]$，值 $[0, 7, -7]$。\n- 用例 4（单一单元，仅边界）：节点 $[0, 1]$，值 $[3.14]$。\n\n所有计算都是无量纲的，不需要物理单位。不涉及角度。每个测试用例的结果是浮点数列表 $[\\eta_1, \\dots, \\eta_N]$。\n\n最终输出格式：您的程序应生成一行输出，其中包含四个用例的结果，形式为列表的列表。其中每个内部列表对应一个测试用例，顺序与上文指定相同。每个浮点数必须四舍五入到 6 位小数。打印的格式必须不含空格。例如：`[[0.000000,1.500000,2.500000,2.000000],[0.000000,0.000000,0.000000],[2.213594,8.573214,10.844353],[0.000000]]`", "solution": "所提出的问题具有坚实的科学基础且是良定的，完全属于微分方程数值解的后验误差估计领域。具体来说，它涉及为一维、$C^1$ 连续的三次样条计算局部误差指示子，这是等几何分析（IGA）中的一种常见情景。这个问题完全是形式化和程序化的，需要直接应用所提供的数学定义。我们将对计算方法进行系统的阐述。\n\n设关注的区域为区间 $[0,1]$。该区域由一个包含 $N+1$ 个节点的网格剖分，节点为 $x_0, x_1, \\dots, x_N$，满足 $0 = x_0 < x_1 < \\dots < x_N = 1$。此剖分创建了 $N$ 个单元，其中第 $e$ 个单元是子区间 $E_e = [x_{e-1}, x_e]$（$e \\in \\{1, \\dots, N\\}$）。单元 $E_e$ 的长度（或尺寸）由 $h_e = x_e - x_{e-1}$ 给出。\n\n近似解 $u(x)$ 是一个全局连续可微（$C^1$ 类）的分片三次样条。这意味着其三阶导数 $u^{(3)}(x)$ 是一个分片常数函数。问题为每个单元提供了这些常数值，记为 $g_e = u^{(3)}|_{E_e}$。\n\n误差指示子基于此三阶导数在单元交界面（即节点）处的不连续性（或称跳跃）。对于任何内部节点 $x_i$（其中 $i \\in \\{1, \\dots, N-1\\}$），其跳跃定义为 $u^{(3)}(x)$ 在该节点右侧的值与左侧值之差：\n$$\n[u^{(3)}]_{x_i} = \\lim_{x \\to x_i^+} u^{(3)}(x) - \\lim_{x \\to x_i^-} u^{(3)}(x) = g_{i+1} - g_i.\n$$\n根据问题陈述，边界节点 $x_0$ 和 $x_N$ 处的跳跃定义为零：\n$$\n[u^{(3)}]_{x_0} = 0, \\quad [u^{(3)}]_{x_N} = 0.\n$$\n\n有了这些定义，单元 $E_e$ 的局部误差指示子 $\\eta_e$ 便可由其尺寸 $h_e$ 和其两个边界节点 $x_{e-1}$ 和 $x_e$ 处的跳跃值构建。显式公式为：\n$$\n\\eta_e = \\sqrt{h_e} \\sqrt{ \\left( [u^{(3)}]_{x_{e-1}} \\right)^2 + \\left( [u^{(3)}]_{x_e} \\right)^2 }.\n$$\n\n为了计算所提供测试用例的指示子 $\\eta_e$，我们实现一个清晰的分步算法：\n1.  根据一个测试用例的输入数据，我们确定节点坐标 $(x_0, \\dots, x_N)$ 和分片常数三阶导数值 $(g_1, \\dots, g_N)$。单元数量为 $N$。\n2.  我们计算长度为 $N$ 的单元尺寸向量 $\\mathbf{h}$，其中分量 $h_e$ 对应于单元 $E_e$ 的尺寸。\n3.  我们计算长度为 $N+1$ 的节点跳跃向量 $\\mathbf{J}$。分量 $J_i = [u^{(3)}]_{x_i}$（其中 $i \\in \\{0, \\dots, N\\}$）按如下方式填充：\n    - 边界分量设为零：$J_0 = 0$ 且 $J_N = 0$。\n    - 内部分量由导数值计算得出：$J_i = g_{i+1} - g_i$（其中 $i \\in \\{1, \\dots, N-1\\}$）。\n    - 对于单单元网格（$N=1$），没有内部节点，跳跃向量就是 $\\mathbf{J} = [0, 0]$。\n4.  最后，我们计算长度为 $N$ 的局部指示子向量 $\\boldsymbol{\\eta}$。对每个单元 $E_e$（其中 $e \\in \\{1, \\dots, N\\}$），我们使用预先计算好的尺寸和跳跃值应用该公式：\n    $$\n    \\eta_e = \\sqrt{h_e} \\sqrt{ (J_{e-1})^2 + (J_e)^2 }.\n    $$\n最终答案中提供的 Python 程序为每个测试用例执行了这个定义明确的算法，生成了所需的局部指示子列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes local, jump-based error indicators for C^1 cubic splines\n    for a series of test cases in a 1D setting.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (list of node coordinates, list of g_e values).\n    test_cases = [\n        ([0, 0.25, 0.5, 0.75, 1], [2, 2, 5, 1]),\n        ([0, 1/3, 2/3, 1], [-1.2, -1.2, -1.2]),\n        ([0, 0.1, 0.4, 1], [0, 7, -7]),\n        ([0, 1], [3.14])\n    ]\n\n    all_results = []\n    for nodes_list, g_values_list in test_cases:\n        nodes = np.array(nodes_list, dtype=np.float64)\n        g_values = np.array(g_values_list, dtype=np.float64)\n\n        # N is the number of elements\n        N = len(g_values)\n        \n        # Calculate element sizes h_e = x_e - x_{e-1}\n        # h has N elements. h[i] corresponds to h_{i+1}.\n        h = np.diff(nodes)\n        \n        # Calculate jumps of the third derivative at each node.\n        # The jumps array has N+1 elements, for nodes x_0 to x_N.\n        # jumps[i] corresponds to the jump at node x_i.\n        jumps = np.zeros(N + 1, dtype=np.float64)\n        \n        # Jumps at internal nodes x_i for i=1,...,N-1\n        # Formula: [u^(3)]_{x_i} = g_{i+1} - g_i\n        # In 0-based indexing for g_values array:\n        # g_i corresponds to g_values[i-1]\n        # g_{i+1} corresponds to g_values[i]\n        # So jump at node x_i is g_values[i] - g_values[i-1].\n        for i in range(1, N):\n            jumps[i] = g_values[i] - g_values[i-1]\n        \n        # Jumps at boundary nodes x_0 and x_N are 0, which is the default\n        # value from np.zeros.\n        \n        # Calculate local indicators eta_e for each element e=1,...,N.\n        # The indicators array has N elements.\n        # Formula: eta_e = sqrt(h_e) * sqrt(([u^(3)]_{x_{e-1}})^2 + ([u^(3)]_{x_e})^2)\n        # In 0-based indexing:\n        # e_idx from 0 to N-1 refers to element E_{e_idx+1}.\n        # h_{e_idx+1} is h[e_idx].\n        # Jumps at its ends (x_{e_idx}, x_{e_idx+1}) are jumps[e_idx] and jumps[e_idx+1].\n        indicators = []\n        for e_idx in range(N):\n            h_e = h[e_idx]\n            jump_left = jumps[e_idx]\n            jump_right = jumps[e_idx+1]\n            eta_e = np.sqrt(h_e) * np.sqrt(jump_left**2 + jump_right**2)\n            indicators.append(eta_e)\n            \n        all_results.append(indicators)\n\n    # Format the final output string as specified.\n    # e.g., [[0.000000,1.500000],[...]] without spaces.\n    formatted_inner_lists = []\n    for res_list in all_results:\n        formatted_numbers = [f\"{num:.6f}\" for num in res_list]\n        formatted_inner_lists.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    final_output = f\"[{','.join(formatted_inner_lists)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "2405738"}]}