{"hands_on_practices": [{"introduction": "在计算工程的许多领域，从点云数据生成高质量的网格是进行仿真的第一步。Delaunay 三角剖分是迄今为止最重要和最普适的非结构化网格生成算法之一，它遵循一个优雅的几何准则——空外接圆准则。通过亲手实现经典的 Bowyer-Watson 增量插入算法，您将深入理解如何将抽象的几何原理转化为健壮的计算机程序，为后续的数值分析奠定坚实的基础。[@problem_id:2412570]", "problem": "实现一个完整的程序，该程序使用Bowyer-Watson增量插入法为一个给定的有限平面点集构建二维Delaunay三角剖分，并对生成的网格的关键属性进行定量验证。您的实现必须以平面三角剖分和Delaunay空外接圆条件的初始定义为基础，并且必须是自包含的。\n\n从以下基本定义开始：\n- $\\mathbb{R}^2$中一个有限点集的平面三角剖分，是指将这些点的凸包分解为多个不重叠的三角形，这些三角形的顶点是点集中的点，且它们的并集等于该凸包。\n- $\\mathbb{R}^2$中一个有限点集的Delaunay三角剖分（由Boris Delaunay首次定义）是满足以下条件的任意一种三角剖分：其中每个三角形的开放外接圆内不包含点集中的任何其他点。等价地，对于每个顶点为$\\mathbf{a}$、$\\mathbf{b}$和$\\mathbf{c}$的三角形，若$\\mathbf{o}$是其外心，$r$是其外接圆半径，则对于任何其他点$\\mathbf{p}$，必须满足$\\|\\mathbf{p}-\\mathbf{o}\\|_2 > r$，允许$\\|\\mathbf{p}-\\mathbf{o}\\|_2 = r$作为非唯一边的特殊情况。\n- 一个非退化三角形的外心是其三条边的垂直平分线的唯一交点。\n\n您的程序必须：\n1. 根据第一性原理实现Bowyer-Watson插入方案，步骤如下。首先使用一个严格包含所有输入点的超级三角形。逐一插入点。对于每个插入的点，找出其外接圆包含该点的所有当前三角形（这些是“坏”三角形），删除它们，计算所得空腔的边界多边形（即那些仅与一个被删除三角形相邻的边），最后通过将新点连接到每个边界边来对空腔进行重新三角剖分。插入所有点后，移除任何包含超级三角形顶点的三角形。\n2. 使用基于上述定义构建的稳定数值谓词。当测试点$\\mathbf{p}$是否位于外接圆内时，计算外心$\\mathbf{o}$和外接圆半径的平方$r^2$，并将$\\|\\mathbf{p}-\\mathbf{o}\\|_2^2$与$r^2$使用一个小的容差$\\varepsilon > 0$进行比较，以实现严格的“内部”不等式$\\|\\mathbf{p}-\\mathbf{o}\\|_2^2 \\le r^2 - \\varepsilon$。面积小于某个容差的退化三角形应在包含性测试中被忽略。\n3. 在一个小的容差范围内对输入点进行去重，以避免顶点重复，并确保算法在遇到近似共线和近似共圆配置时保持鲁棒性。\n\n对于下述每个测试用例，您的程序必须返回三个量：\n- 最终三角剖分中的三角形数量$T$（一个整数）。\n- 一个布尔值，表示在使用上述带容差的严格内部定义对所有其他点进行检查时，空外接圆条件是否对所有三角形都成立。\n- 所有三角形的面积之和（一个浮点数），四舍五入到$6$位小数。此数值必须根据第一性原理计算，即使用每个顶点为$\\mathbf{a}$、$\\mathbf{b}$和$\\mathbf{c}$的三角形的欧几里得面积公式$\\frac{1}{2}\\left|(\\mathbf{b}-\\mathbf{a}) \\times (\\mathbf{c}-\\mathbf{a})\\right|$，其中$\\times$表示二维向量叉积的标量$z$分量。\n\n本问题不使用角度单位。所有量均为无量纲。\n\n测试套件：\n- 用例A（带一个内部点的凸正方形）：点集 $[(0,0),(1,0),(1,1),(0,1),(0.5,0.5)]$。\n- 用例B（单位圆上的正五边形，一个近似共圆的压力测试）：点集 $\\left[\\left(\\cos\\left(\\frac{2\\pi k}{5}\\right),\\sin\\left(\\frac{2\\pi k}{5}\\right)\\right)\\right]$，其中$k \\in \\{0,1,2,3,4\\}$。\n- 用例C（沿一条凸包边的共线子集）：点集 $[(0,0),(1,0),(2,0),(2,1),(0,1)]$。\n- 用例D（存在重复点）：点集 $[(0,0),(1,0),(1,1),(0,1),(1,1)]$。\n- 用例E（单位正方形内的一般内部点集）：点集 $[(0.1,0.1),(0.9,0.1),(0.9,0.9),(0.1,0.9),(0.5,0.2),(0.8,0.5),(0.3,0.6),(0.5,0.8)]$。\n\n输出规范：\n- 对每个用例，输出一个形式为 $[T, `delaunay_ok`, `area_sum`]$ 的列表，其中 $T$ 是一个整数，`delaunay_ok` 是一个布尔值，`area_sum` 是一个按上述定义四舍五入到$6$位小数的浮点数。\n- 您的程序应该生成一行输出，其中包含所有五个用例的结果，形式为一个用方括号括起来的、以逗号分隔的列表，例如：$[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$。", "solution": "所提出的问题要求实现用于二维Delaunay三角剖分的Bowyer-Watson算法。解决方案必须从基本原理构建，并且必须包括对所得网格属性的验证。该问题经确认为科学上合理、定义明确且客观。它涉及计算几何中的一个标准主题，并提供了清晰、可测试的要求。\n\n解决方案的核心是逐步实现Bowyer-Watson算法。该算法是一种增量方法，通过一次添加一个点来构建三角剖分。首先定义基本的几何构造。一个点是向量$\\mathbf{p} \\in \\mathbb{R}^2$。一个三角形由三个顶点$(\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3)$定义，它们是主点坐标列表中的索引。\n\n顶点为$\\mathbf{a}=(a_x, a_y)$、$\\mathbf{b}=(b_x, b_y)$和$\\mathbf{c}=(c_x, c_y)$的三角形面积使用二维叉积公式计算：\n$$ A = \\frac{1}{2} |a_x(b_y - c_y) + b_x(c_y - a_y) + c_x(a_y - b_y)| $$\n如果一个三角形的面积小于一个小的容差$\\tau_{area}$，则认为它是退化的，这发生在它的顶点近似共线时。\n\n对于一个非退化三角形，其外接圆是唯一确定的。外心$\\mathbf{o}=(o_x, o_y)$是三角形各边垂直平分线的交点。其坐标可以直接从顶点坐标计算得出：\n$$ D = 2 (a_x(b_y - c_y) + b_x(c_y - a_y) + c_x(a_y - b_y)) $$\n$$ o_x = \\frac{1}{D} ( (a_x^2+a_y^2)(b_y-c_y) + (b_x^2+b_y^2)(c_y-a_y) + (c_x^2+c_y^2)(a_y-b_y) ) $$\n$$ o_y = \\frac{1}{D} ( (a_x^2+a_y^2)(c_x-b_x) + (b_x^2+b_y^2)(a_x-c_x) + (c_x^2+c_y^2)(b_x-a_x) ) $$\n分母$D$是带符号面积的两倍。如果$|D|$小于一个容差，则外心计算是病态的，并应中止。外接圆半径的平方则为$r^2 = \\|\\mathbf{a} - \\mathbf{o}\\|_2^2$。\n\nBowyer-Watson算法中的关键测试是确定一个点$\\mathbf{p}$是否位于三角形的外接圆内。根据问题描述，这被实现为一个带容差$\\varepsilon > 0$的严格“内部”测试：\n$$ \\|\\mathbf{p}-\\mathbf{o}\\|_2^2 \\le r^2 - \\varepsilon $$\n这种形式通过将位于或非常接近圆边界的点归类为“外部”，从而鲁棒地处理了点近似共圆的情况。\n\n算法按以下步骤进行：\n$1$. **预处理**：对输入点进行去重。如果两个点$\\mathbf{p}_i, \\mathbf{p}_j$之间的欧几里得距离$\\|\\mathbf{p}_i - \\mathbf{p}_j\\|_2$小于一个容差$\\tau_{dist}$，则认为它们是相同的。\n$2$. **初始化**：创建一个保证能包围所有输入点的“超级三角形”。这通过找到点的边界框并在其周围构建一个明显更大的三角形来完成。初始三角剖分仅包含这个超级三角形。其顶点被添加到全局点列表中。\n$3$. **增量插入**：将每个输入点$\\mathbf{p}_{new}$插入到三角剖分中：\n    a. 找到“坏”三角形的集合。如果$\\mathbf{p}_{new}$位于一个三角形的外接圆内，则该三角形是坏的。\n    b. 移除坏三角形，形成一个多边形空腔。这个空腔的边界由那些恰好属于一个坏三角形的边组成。\n    c. 通过创建新的三角形来重新三角剖分该空腔，每个新三角形由边界多边形的一条边和点$\\mathbf{p}_{new}$形成。\n    d. 用新的三角形替换坏三角形来更新活动三角形列表。\n$4$. **最终化**：在插入所有点之后，任何与超级三角形共享顶点的三角形都将被丢弃。剩下的集合就是输入点的Delaunay三角剖分。\n\n最后，对于每个测试用例，从最终的三角剖分中计算所需的度量指标：\n- `$T$`: 最终网格中的三角形总数。\n- `` `delaunay_ok` ``: 一个布尔标志。如果对于网格中的每个三角形，输入集中的没有其他点严格位于其外接圆内部（使用相同的带容差检查进行验证），则设置为 `True`。否则，为 `False`。\n- `` `area_sum` ``: 最终网格中所有三角形的面积之和，四舍五入到$6$位小数。在最终四舍五入之前，使用保持精度的方法计算总和。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nfrom collections import Counter\n\n# Global tolerances for numerical stability\nEPSILON_CIRCUMCIRCLE = 1e-9\nDEDUPLICATION_TOL = 1e-9\nAREA_TOL = 1e-12\n\nclass Triangle:\n    \"\"\"\n    Represents a triangle with vertices and its circumcircle.\n    Vertices are stored as indices into a global list of points.\n    \"\"\"\n    def __init__(self, v1_idx, v2_idx, v3_idx, points):\n        self.v_indices = (v1_idx, v2_idx, v3_idx)\n        self.vertices = (points[v1_idx], points[v2_idx], points[v3_idx])\n        \n        self.circumcenter = None\n        self.radius_sq = None\n        \n        self.area = self._calculate_area()\n        if self.area < AREA_TOL:\n            self.is_degenerate = True\n        else:\n            self.is_degenerate = False\n            self._calculate_circumcircle()\n\n    def _calculate_area(self):\n        a, b, c = self.vertices\n        # Using the Shoelace formula for area\n        return 0.5 * abs(a[0]*(b[1]-c[1]) + b[0]*(c[1]-a[1]) + c[0]*(a[1]-b[1]))\n\n    def _calculate_circumcircle(self):\n        a, b, c = self.vertices\n        ax, ay = a\n        bx, by = b\n        cx, cy = c\n        \n        D = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by))\n\n        if abs(D) < AREA_TOL:\n            # This should be caught by the area check, but as a safeguard\n            self.is_degenerate = True\n            return\n\n        asq = ax**2 + ay**2\n        bsq = bx**2 + by**2\n        csq = cx**2 + cy**2\n\n        ux = (asq * (by - cy) + bsq * (cy - ay) + csq * (ay - by)) / D\n        uy = (asq * (cx - bx) + bsq * (ax - cx) + csq * (bx - ax)) / D\n        \n        self.circumcenter = np.array([ux, uy])\n        self.radius_sq = (ax - ux)**2 + (ay - uy)**2\n\n    def contains_point_in_circumcircle(self, p):\n        if self.is_degenerate or self.circumcenter is None:\n            return False\n        \n        dist_sq = np.sum((p - self.circumcenter)**2)\n        # Strict inequality check with tolerance\n        return dist_sq <= self.radius_sq - EPSILON_CIRCUMCIRCLE\n\n    def get_edges(self):\n        # Return edges with sorted vertex indices to make them canonical for comparison\n        v1, v2, v3 = self.v_indices\n        return [\n            tuple(sorted((v1, v2))),\n            tuple(sorted((v2, v3))),\n            tuple(sorted((v3, v1)))\n        ]\n\ndef bowyer_watson(points):\n    \"\"\"\n    Constructs a Delaunay triangulation of a set of 2D points.\n    \"\"\"\n    # 1. Deduplicate points\n    unique_points_list = []\n    if points:\n        unique_points_list.append(points[0])\n        for p_in in points[1:]:\n            p_arr = np.array(p_in)\n            is_duplicate = False\n            for up in unique_points_list:\n                if np.linalg.norm(p_arr - np.array(up)) < DEDUPLICATION_TOL:\n                    is_duplicate = True\n                    break\n            if not is_duplicate:\n                unique_points_list.append(p_in)\n    \n    unique_points = [np.array(p) for p in unique_points_list]\n    num_input_points = len(unique_points)\n    \n    if num_input_points < 3:\n        return [], unique_points\n\n    # 2. Create super-triangle\n    min_x = min(p[0] for p in unique_points)\n    max_x = max(p[0] for p in unique_points)\n    min_y = min(p[1] for p in unique_points)\n    max_y = max(p[1] for p in unique_points)\n    \n    dx = max_x - min_x\n    dy = max_y - min_y\n    delta_max = max(dx, dy, 1.0) # Ensure non-zero for single-point case\n    center = np.array([(min_x + max_x) / 2, (min_y + max_y) / 2])\n    \n    # Large triangle enclosing the bounding box\n    s_v1 = center + np.array([-3 * delta_max, -3 * delta_max])\n    s_v2 = center + np.array([3 * delta_max, -3 * delta_max])\n    s_v3 = center + np.array([0, 3 * delta_max])\n    \n    all_points = unique_points + [s_v1, s_v2, s_v3]\n    st_idx1, st_idx2, st_idx3 = num_input_points, num_input_points + 1, num_input_points + 2\n\n    triangulation = [Triangle(st_idx1, st_idx2, st_idx3, all_points)]\n\n    # 3. Incremental insertion\n    for i in range(num_input_points):\n        point_to_add = all_points[i]\n        \n        bad_triangles = [t for t in triangulation if t.contains_point_in_circumcircle(point_to_add)]\n        \n        polygon_edges = []\n        for t in bad_triangles:\n            polygon_edges.extend(t.get_edges())\n        \n        edge_counts = Counter(polygon_edges)\n        boundary_edges = [edge for edge, count in edge_counts.items() if count == 1]\n        \n        triangulation = [t for t in triangulation if t not in bad_triangles]\n        \n        for edge in boundary_edges:\n            new_triangle = Triangle(edge[0], edge[1], i, all_points)\n            triangulation.append(new_triangle)\n            \n    # 4. Finalization\n    final_triangulation = []\n    for t in triangulation:\n        is_super_triangle = any(v_idx >= num_input_points for v_idx in t.v_indices)\n        if not is_super_triangle:\n            final_triangulation.append(t)\n            \n    return final_triangulation, all_points[:num_input_points]\n\ndef process_case(points):\n    \"\"\"\n    Runs the full process for one test case and returns the required metrics.\n    \"\"\"\n    final_triangulation, final_points = bowyer_watson(points)\n    \n    # 1. Number of triangles\n    T = len(final_triangulation)\n    \n    # 2. Verify Delaunay condition\n    delaunay_ok = True\n    if T > 0:\n        for t in final_triangulation:\n            # We don't verify against degenerate triangles in the mesh\n            if t.is_degenerate:\n                continue\n            \n            for i, p in enumerate(final_points):\n                if i in t.v_indices:\n                    continue\n                \n                if t.contains_point_in_circumcircle(p):\n                    delaunay_ok = False\n                    break\n            if not delaunay_ok:\n                break\n    \n    # 3. Sum of areas\n    area_sum = math.fsum(t.area for t in final_triangulation)\n    \n    return [T, delaunay_ok, round(area_sum, 6)]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: convex square with interior point\n        [(0,0),(1,0),(1,1),(0,1),(0.5,0.5)],\n        # Case B: regular pentagon\n        [(np.cos(2 * np.pi * k / 5), np.sin(2 * np.pi * k / 5)) for k in range(5)],\n        # Case C: collinear subset\n        [(0,0),(1,0),(2,0),(2,1),(0,1)],\n        # Case D: duplicate point present\n        [(0,0),(1,0),(1,1),(0,1),(1,1)],\n        # Case E: general interior set\n        [(0.1,0.1),(0.9,0.1),(0.9,0.9),(0.1,0.9),(0.5,0.2),(0.8,0.5),(0.3,0.6),(0.5,0.8)]\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, which str() handles correctly.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2412570"}, {"introduction": "生成网格后，我们必须评估其质量，因为网格单元的几何形状直接影响数值求解的精度、收敛性和稳定性。本练习将指导您从第一性原理出发，实现评估三维四面体单元几何质量的三个核心指标：纵横比 $\\mathrm{AR}$、偏斜度 $\\mathrm{SK}$ 和雅可比行列式 $\\det(J)$。掌握这些度量标准的计算是量化评估网格是否“良好”并诊断潜在数值问题的关键技能。[@problem_id:2412640]", "problem": "您的任务是设计并实现一个完整的、可运行的程序，该程序用于评估非结构化三维线性四面体网格单元的三种几何质量度量。该网格由三维欧氏空间 $\\mathbb{R}^3$中的节点坐标和单元连接关系定义。您的实现必须从线性映射和欧氏几何的基本原理出发，并且必须为每个四面体单元计算以下指标，然后在网格级别进行聚合：纵横比、偏斜度和等参映射的雅可比行列式。所有计算都应使用无量纲量进行；不涉及物理单位。\n\n基本定义与假设：\n\n- 一个线性四面体单元由四个不同节点定义，其坐标为 $\\mathbf{x}_1,\\mathbf{x}_2,\\mathbf{x}_3,\\mathbf{x}_4 \\in \\mathbb{R}^3$。从参考四面体到物理四面体的相应仿射映射为\n$$\n\\mathbf{x}(\\boldsymbol{\\xi}) \\;=\\; \\mathbf{x}_1 \\;+\\; J \\,\\boldsymbol{\\xi},\n$$\n其中 $J \\in \\mathbb{R}^{3 \\times 3}$ 是雅可比矩阵，其列为 $J = \\begin{bmatrix} \\mathbf{x}_2-\\mathbf{x}_1 & \\mathbf{x}_3-\\mathbf{x}_1 & \\mathbf{x}_4-\\mathbf{x}_1 \\end{bmatrix}$，且 $\\boldsymbol{\\xi}\\in\\mathbb{R}^3$ 位于参考四面体内。对于线性四面体，$J$ 在整个单元上是恒定的。单元的有符号体积 $V$ 满足 $V = \\det(J)/6$。\n\n- 向量 $\\mathbf{v}\\in\\mathbb{R}^3$的欧氏范数为 $\\lVert \\mathbf{v}\\rVert_2 = \\sqrt{\\mathbf{v}^\\top \\mathbf{v}}$。\n\n- 奇异值分解 (SVD) 将 $J$ 写为 $J = U \\Sigma V^\\top$，其中 $U,V\\in\\mathbb{R}^{3\\times 3}$ 是正交矩阵，$\\Sigma = \\operatorname{diag}(\\sigma_1,\\sigma_2,\\sigma_3)$，奇异值为 $\\sigma_1 \\ge \\sigma_2 \\ge \\sigma_3 \\ge 0$。行列式满足 $\\det(J) = \\sigma_1 \\sigma_2 \\sigma_3 \\cdot \\det(U)\\det(V)$，其绝对值为 $\\lvert \\det(J)\\rvert = \\sigma_1 \\sigma_2 \\sigma_3$。\n\n需从基本原理计算的单元级质量度量：\n\n1. 纵横比。设六条边的长度为 $l_{ij} = \\lVert \\mathbf{x}_i - \\mathbf{x}_j\\rVert_2$，其中索引对 $(i,j)\\in\\{(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)\\}$。定义单元纵横比为\n$$\n\\mathrm{AR} \\;=\\; \\frac{\\max l_{ij}}{\\min l_{ij}}.\n$$\n若任意 $l_{ij} = 0$（退化边），则定义 $\\mathrm{AR}$ 为 $+\\infty$。\n\n2. 偏斜度。使用 $J$ 的奇异值，定义偏斜度为\n$$\n\\mathrm{SK} \\;=\\; 1 - \\frac{\\sigma_{\\min}(J)}{\\sigma_{\\max}(J)} \\;=\\; 1 - \\frac{\\sigma_3}{\\sigma_1}.\n$$\n若 $\\sigma_1 = 0$（完全退化），则定义 $\\mathrm{SK} = 1$。对于非退化单元，该度量值在 $[0,1]$ 区间内，$\\mathrm{SK}=0$ 表示映射列的各向同性，接近 $1$ 的值表示严重的各向异性或近退化。\n\n3. 雅可比行列式。为每个单元计算有符号的雅可比行列式\n$$\n\\mathrm{JAC} \\;=\\; \\det(J).\n$$\n负值表示反向。单元体积为 $V = \\mathrm{JAC}/6$。\n\n网格级聚合：\n\n- 对于给定网格，将其最差纵横比定义为所有单元中 $\\mathrm{AR}$ 的最大值。\n- 将其最差偏斜度定义为所有单元中 $\\mathrm{SK}$ 的最大值。\n- 将其最小雅可比行列式定义为所有单元中 $\\mathrm{JAC}$ 的最小值。\n\n程序要求：\n\n- 实现一个解析器，用于解析代表非结构化四面体网格的简单内存网格描述格式。每个网格包含一组节点和一组引用这些节点的四面体单元。您的程序必须将网格作为字符串常量嵌入内部；不得读取外部文件或要求用户输入。格式如下：\n  - 一行 “NODES $N$”，后跟 $N$ 行，每行包含“$\\text{id}\\; x\\; y\\; z$”，其中 $\\text{id}$ 为整数， $x,y,z$ 为实数坐标。\n  - 一行 “ELEMENTS $M$”，后跟 $M$ 行，每行包含“$\\text{id}\\; n_1\\; n_2\\; n_3\\; n_4$”，其中 $\\text{id}$ 为整数， $n_k$ 为整数节点索引。\n\n- 为每个四面体单元，仅使用提供的基本操作和定义来计算上文定义的 $\\mathrm{AR}$、$\\mathrm{SK}$ 和 $\\mathrm{JAC}$。\n\n- 按照规定对每个网格进行聚合，为每个网格生成三个值：最差纵横比、最差偏斜度和最小雅可比行列式。\n\n待嵌入并由程序评估的测试套件：\n\n- 测试网格 A（形状良好，类似等边）。节点：\n  - $\\mathbf{x}_1 = (0,\\,0,\\,0)$,\n  - $\\mathbf{x}_2 = (1,\\,0,\\,0)$,\n  - $\\mathbf{x}_3 = \\left(\\tfrac{1}{2},\\,\\tfrac{\\sqrt{3}}{2},\\,0\\right)$,\n  - $\\mathbf{x}_4 = \\left(\\tfrac{1}{2},\\,\\tfrac{\\sqrt{3}}{6},\\,\\tfrac{\\sqrt{6}}{3}\\right)$.\n  一个单元，连接关系为 $(1,2,3,4)$。\n\n- 测试网格 B（近退化的薄片单元，体积非常小）。节点：\n  - $\\mathbf{x}_1 = (0,\\,0,\\,0)$,\n  - $\\mathbf{x}_2 = (2,\\,0,\\,0)$,\n  - $\\mathbf{x}_3 = (0,\\,2,\\,0)$,\n  - $\\mathbf{x}_4 = (1,\\,1,\\,10^{-6})$.\n  一个单元，连接关系为 $(1,2,3,4)$。\n\n- 测试网格 C（反向）。节点坐标与测试网格 A 相同，但单个单元的连接关系为 $(1,3,2,4)$，因此映射为反向。\n\n要求的最终输出格式：\n\n- 您的程序必须生成单行输出，其中包含一个含三个列表的列表，每个列表对应一个测试网格，严格按照 A、B、C 的顺序排列。每个内部列表必须按 $[\\mathrm{AR}_\\text{worst}, \\mathrm{SK}_\\text{worst}, \\mathrm{JAC}_\\text{min}]$ 的顺序包含该网格的三个浮点数。将每个数字四舍五入到六位小数。整体输出格式必须严格为\n$$\n\\big[ [a_1,s_1,j_1], [a_2,s_2,j_2], [a_3,s_3,j_3] \\big]\n$$\n其中数值条目以四舍五入到六位小数的小数形式呈现，且无附加文本。例如，一个可接受的结构是\n$[[1.000000,0.375000,0.707107],[\\dots],[\\dots]]$。", "solution": "该问题要求设计并实现一个程序，用以评估三维四面体网格的三项基本几何质量度量：纵横比、偏斜度以及等参映射的雅可比行列式。评估必须针对几个测试网格进行，并且结果需在网格级别上进行聚合。问题陈述的验证已经完成，其科学基础扎实、提法恰当且内容完整。我们现在开始阐述详细的解决方案，从指定的基本原理入手。\n\n任务的核心是分析每个四面体单元的几何形状。一个线性四面体由四个节点 $\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{x}_3, \\mathbf{x}_4 \\in \\mathbb{R}^3$ 定义。其几何特性由一个仿射变换来描述，该变换将一个标准参考四面体映射到 $\\mathbb{R}^3$ 中的物理单元。该映射由 $\\mathbf{x}(\\boldsymbol{\\xi}) = \\mathbf{x}_1 + J \\boldsymbol{\\xi}$ 给出，其中 $\\boldsymbol{\\xi}$ 是参考空间中的坐标，$J \\in \\mathbb{R}^{3 \\times 3}$ 是变换的雅可比矩阵。对于线性四面体，该雅可比矩阵在整个单元上是恒定的。\n\n计算力学中的标准参考四面体，其顶点位于坐标元组 $(0,0,0)$、$(1,0,0)$、$(0,1,0)$ 和 $(0,0,1)$ 处。仿射映射的构造方式使得这些参考顶点分别映射到物理节点 $\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{x}_3, \\mathbf{x}_4$。这引出了雅可比矩阵列的定义，即由从第一个节点 $\\mathbf{x}_1$ 出发的物理四面体的边向量构成：\n$$\nJ = \\begin{bmatrix} (\\mathbf{x}_2 - \\mathbf{x}_1) & (\\mathbf{x}_3 - \\mathbf{x}_1) & (\\mathbf{x}_4 - \\mathbf{x}_1) \\end{bmatrix}.\n$$\n这个矩阵 $J$ 和单元的所有边长集合是推导所有所需度量的基本量。\n\n计算流程结构如下：\n1.  解析所提供的特定字符串格式的网格数据，以建立节点坐标和单元连接关系。\n2.  对网格中的每个单元，检索其四个定义节点的坐标。\n3.  计算三个指定的单元级质量度量：纵横比 (AR)、偏斜度 (SK) 和雅可比行列式 (JAC)。\n4.  在网格中的所有单元上聚合这些度量，以找出最差纵横比、最差偏斜度和最小雅可比行列式。\n5.  对所有测试网格重复上述过程，并按要求格式化最终结果。\n\n我们现在详细说明每项度量的计算方法。\n\n1.  **纵横比 ($\\mathrm{AR}$)**\n    纵横比是衡量单元相对于理想形状（例如，等边四面体）扭曲程度的度量。它基于单元的六条边的长度来定义。对于具有节点 $\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{x}_3, \\mathbf{x}_4$ 的四面体，其六条边长为 $l_{ij} = \\lVert \\mathbf{x}_i - \\mathbf{x}_j \\rVert_2$，其中索引对 $(i,j)$ 属于 $\\{(1,2), (1,3), (1,4), (2,3), (2,4), (3,4)\\}$。向量 $\\mathbf{v} = (v_x, v_y, v_z)$ 的欧氏范数 $\\lVert \\mathbf{v} \\rVert_2$ 为 $\\sqrt{v_x^2 + v_y^2 + v_z^2}$。\n    纵横比即为最长边与最短边的比值：\n    $$\n    \\mathrm{AR} = \\frac{\\max_{i,j} l_{ij}}{\\min_{i,j} l_{ij}}.\n    $$\n    一个理想的等边四面体的 $\\mathrm{AR}$ 为 $1$。更高的值表示更大的扭曲。如果任意边的长度为零，即 $\\min l_{ij} = 0$，则该单元是退化的，其纵横比定义为无穷大 ($\\infty$)。\n\n2.  **雅可比行列式 ($\\mathrm{JAC}$)**\n    雅可比矩阵的行列式, $\\mathrm{JAC} = \\det(J)$, 与单元的体积直接相关。四面体的有符号体积为 $V = \\det(J)/6$。\n    -   正行列式 $\\det(J) > 0$ 表示单元的节点排序（连接关系）保持了参考单元的方向。这是有效网格的标准。\n    -   负行列式 $\\det(J) < 0$ 表示一个反向或“内外颠倒”的单元，对于大多数模拟目的而言，这在几何上和物理上都是无效的。\n    -   零行列式 $\\det(J) = 0$ 意味着一个体积为零的退化单元（例如，所有四个节点共面）。\n\n3.  **偏斜度 ($\\mathrm{SK}$)**\n    偏斜度衡量从参考单元到物理单元的仿射映射的各向异性程度。它使用雅可比矩阵 $J$ 的奇异值来定义。$J$ 的奇异值分解 (SVD) 为 $J = U \\Sigma V^\\top$，其中 $\\Sigma = \\operatorname{diag}(\\sigma_1, \\sigma_2, \\sigma_3)$ 且 $\\sigma_1 \\ge \\sigma_2 \\ge \\sigma_3 \\ge 0$ 是奇异值。这些值代表了沿主方向变换的缩放因子。\n    偏斜度定义为：\n    $$\n    \\mathrm{SK} = 1 - \\frac{\\sigma_{\\min}(J)}{\\sigma_{\\max}(J)} = 1 - \\frac{\\sigma_3}{\\sigma_1}.\n    $$\n    该度量值的范围是 $0$ 到 $1$。当 $\\sigma_1=\\sigma_2=\\sigma_3$ 时，$\\mathrm{SK}=0$，这对应于一个纯粹的各向同性缩放（尽管不一定是等边四面体，因为参考单元本身不是等边的）。一个接近 $1$ 的值表示严重的各向异性或近退化（即 $\\sigma_3 \\ll \\sigma_1$）。如果 $\\sigma_1 = 0$，则单元是完全退化的，$\\mathrm{SK}$ 定义为 $1$。\n\n实现将利用 `numpy` 库进行高效的向量和矩阵运算，包括范数、行列式和奇异值分解的计算，这些都是上述基本原理的标准数值实现。\n\n最后，对每个网格，逐单元的度量被聚合：\n-   最差纵横比: $\\mathrm{AR}_{\\text{worst}} = \\max_{\\text{elements}} \\mathrm{AR}$。\n-   最差偏斜度: $\\mathrm{SK}_{\\text{worst}} = \\max_{\\text{elements}} \\mathrm{SK}$。\n-   最小雅可比行列式: $\\mathrm{JAC}_{\\text{min}} = \\min_{\\text{elements}} \\mathrm{JAC}$。\n\n这三个聚合值提供了整个网格质量的简明摘要。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define, process, and evaluate the quality of test meshes.\n    \"\"\"\n    \n    # Test suite to be embedded and evaluated.\n    mesh_A_string = \"\"\"\n    NODES 4\n    1 0.0 0.0 0.0\n    2 1.0 0.0 0.0\n    3 0.5 0.8660254037844386 0.0\n    4 0.5 0.2886751345948129 0.816496580927726\n    ELEMENTS 1\n    1 1 2 3 4\n    \"\"\"\n\n    mesh_B_string = \"\"\"\n    NODES 4\n    1 0.0 0.0 0.0\n    2 2.0 0.0 0.0\n    3 0.0 2.0 0.0\n    4 1.0 1.0 0.000001\n    ELEMENTS 1\n    1 1 2 3 4\n    \"\"\"\n\n    mesh_C_string = \"\"\"\n    NODES 4\n    1 0.0 0.0 0.0\n    2 1.0 0.0 0.0\n    3 0.5 0.8660254037844386 0.0\n    4 0.5 0.2886751345948129 0.816496580927726\n    ELEMENTS 1\n    1 1 3 2 4\n    \"\"\"\n    \n    test_cases = [mesh_A_string, mesh_B_string, mesh_C_string]\n\n    all_results = []\n    for mesh_data in test_cases:\n        result = process_mesh(mesh_data)\n        all_results.append(result)\n\n    # Format the final output string as specified.\n    list_of_lists_str = []\n    for res in all_results:\n        # Format each number to 6 decimal places.\n        formatted_res = [f\"{x:.6f}\" for x in res]\n        list_of_lists_str.append(f\"[{','.join(formatted_res)}]\")\n    \n    final_output_str = f\"[{','.join(list_of_lists_str)}]\"\n    print(final_output_str)\n\ndef parse_mesh(mesh_string: str) -> (dict, list):\n    \"\"\"\n    Parses a mesh description from a string into node and element data structures.\n    \n    Args:\n        mesh_string: A multiline string containing the mesh definition.\n        \n    Returns:\n        A tuple containing:\n        - A dictionary of nodes {node_id: np.array([x, y, z])}.\n        - A list of element connectivities [(n1, n2, n3, n4), ...].\n    \"\"\"\n    lines = mesh_string.strip().split('\\n')\n    nodes = {}\n    elements = []\n    \n    mode = None # \"NODES\" or \"ELEMENTS\"\n\n    for line in lines:\n        line = line.strip()\n        if not line:\n            continue\n        \n        parts = line.split()\n        if parts[0] == \"NODES\":\n            mode = \"NODES\"\n            continue\n        elif parts[0] == \"ELEMENTS\":\n            mode = \"ELEMENTS\"\n            continue\n\n        if mode == \"NODES\":\n            node_id = int(parts[0])\n            coords = np.array([float(p) for p in parts[1:]])\n            nodes[node_id] = coords\n        elif mode == \"ELEMENTS\":\n            # Element ID is ignored as per logic, only connectivity matters\n            node_ids = tuple(int(p) for p in parts[1:])\n            elements.append(node_ids)\n            \n    return nodes, elements\n\ndef compute_aspect_ratio(node_coords: list) -> float:\n    \"\"\"\n    Computes the aspect ratio for a single tetrahedral element.\n    Aspect Ratio = max_edge_length / min_edge_length.\n    \"\"\"\n    points = [np.array(c) for c in node_coords]\n    \n    edge_indices = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\n    edge_lengths = [np.linalg.norm(points[i] - points[j]) for i, j in edge_indices]\n        \n    min_len = min(edge_lengths)\n    max_len = max(edge_lengths)\n    \n    if min_len < 1e-12: # Treat very small lengths as zero to handle degeneracy\n        return np.inf\n    \n    return max_len / min_len\n\ndef compute_jacobian_metrics(node_coords: list) -> (float, float):\n    \"\"\"\n    Computes the Jacobian determinant and skewness for a single tetrahedral element.\n    \"\"\"\n    x1, x2, x3, x4 = [np.array(c) for c in node_coords]\n    \n    # Construct the Jacobian matrix J = [x2-x1, x3-x1, x4-x1], where each\n    # difference vector is a column.\n    J = np.vstack((x2 - x1, x3 - x1, x4 - x1)).T\n    \n    # Compute the signed Jacobian determinant.\n    jac_det = np.linalg.det(J)\n    \n    # Compute singular values for skewness. np.linalg.svd returns them sorted.\n    singular_values = np.linalg.svd(J, compute_uv=False)\n    \n    sigma_max = singular_values[0]\n    sigma_min = singular_values[-1]\n    \n    if sigma_max < 1e-12:\n        skewness = 1.0\n    else:\n        skewness = 1.0 - (sigma_min / sigma_max)\n        \n    return jac_det, skewness\n\ndef process_mesh(mesh_string: str) -> list:\n    \"\"\"\n    Processes a mesh, computes quality metrics for all its elements,\n    and returns the aggregated mesh-level quality indicators.\n    \n    Args:\n        mesh_string: The string defining the mesh.\n        \n    Returns:\n        A list containing [worst_aspect_ratio, worst_skewness, min_jacobian_determinant].\n    \"\"\"\n    nodes, elements = parse_mesh(mesh_string)\n    \n    worst_ar = 0.0\n    worst_sk = 0.0\n    min_jac = np.inf\n    \n    for elem_node_ids in elements:\n        # Node IDs in the mesh file are 1-based.\n        node_coords = [nodes[nid] for nid in elem_node_ids]\n        \n        # 1. Aspect Ratio\n        ar = compute_aspect_ratio(node_coords)\n        if ar > worst_ar:\n            worst_ar = ar\n\n        # 2. Jacobian Determinant and 3. Skewness\n        jac, sk = compute_jacobian_metrics(node_coords)\n        if sk > worst_sk:\n            worst_sk = sk\n        if jac < min_jac:\n            min_jac = jac\n            \n    return [worst_ar, worst_sk, min_jac]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2412640"}, {"introduction": "在实际的仿真分析中，我们常常需要在模型的边界上施加特定的物理条件，例如力、热通量或固定位移。因此，准确地识别出哪些网格面位于边界上是一项至关重要的预处理任务。这个练习将带您脱离几何坐标的束缚，仅利用网格的连接关系（拓扑信息），通过发生率计数原理来识别边界，这是一种在高级网格处理和有限元软件开发中广泛应用的基础算法。[@problem_id:2412652]", "problem": "给定一个由四面体构成的三维非结构化单纯形网格，但只提供其单元到节点的连接关系。没有坐标信息。一个四面体单元由一个有序的四元组表示，其中包含四个不同的非负整数，每个整数都是一个全局节点标识符。根据单纯复形的代数拓扑第一性原理，当忽略定向时，一组四面体的边界由那些与奇数个四面体相关联的三角面构成；在通常的流形情况下，这意味着恰好与一个四面体相关联。形式上，对于一个节点集为 $\\{i,j,k,\\ell\\}$ 的四面体，其三角面元集是 2-单纯形的集合 $\\{\\{i,j,k\\},\\{i,j,\\ell\\},\\{i,k,\\ell\\},\\{j,k,\\ell\\}\\}$。给定网格中所有四面体的所有此类面元三元组的多重集并集，一个面是边界面的充要条件是它在该多重集中仅出现一次，这等价于其关联计数等于 $1$。\n \n任务：编写一个完整的程序，为每个提供的测试用例识别所有边界三角面，并为每个这样的面标记上边界标签 $1$。请使用以下基础和要求。\n \n在您的推理和算法设计中使用的基本原理：\n- 单纯复形及其面的定义：一个 $3$-单纯形的边界由其四个 $2$-单纯形组成。\n- 关联计数原理：在一组四面体中，如果一个三角面的关联计数为 $1$，则它位于边界上；否则，它位于内部。由于我们将每个三角面视为一个无序节点集，因此该定义与局部定向无关，始终保持一致。\n- 集合与多重集计数规则：三角面是否相等由其无序节点标识符三元组是否相等决定，计数是在这些规范化的无序三元组上进行的。\n \n算法要求：\n- 对于每个具有节点 $\\{a,b,c,d\\}$ 的四面体，将其四个三角面枚举为无序三元组 $\\{a,b,c\\}$、$\\{a,b,d\\}$、$\\{a,c,d\\}$ 和 $\\{b,c,d\\}$。\n- 通过将其三个节点标识符按升序排序来规范化每个面，以将其表示为一个唯一的键。这消除了对单元定向的依赖。\n- 统计整个网格连接关系中每个面键的出现次数。面键计数等于 $1$ 的面是边界-面。\n- 标记规则：为每个边界-面附加整数边界标签 $1$。在此问题中，每个边界面的标签值就是整数 $1$。\n- 面的输出表示：每个面必须输出为一个包含三个严格递增的节点标识符及其后跟随的标签的列表，即形式为 $[i,j,k,1]$，其中 $i<j<k$。\n \n测试套件：\n为以下五个独立的测试用例提供结果，每个用例都是一个四面体列表，每个四面体是一个节点的有序四元组。所有节点标识符均为非负整数。\n- 用例 1（单个四面体）：$[[0,1,2,3]]$。\n- 用例 2（两个四面体共享一个面，在该共享面上具有相反的局部定向）：$[[0,1,2,3],[0,2,1,4]]$。\n- 用例 3（三个四面体非流形地交于一个公共面）：$[[1,2,3,0],[2,1,3,4],[3,1,2,5]]$。\n- 用例 4（不连通网格：一个孤立的四面体和一对共享一个面的四面体）：$[[10,11,12,13],[20,21,22,23],[22,21,20,24]]$。\n- 用例 5（重复的四面体占据相同的连接关系，测试鲁棒性）：$[[0,1,2,3],[0,1,2,3]]$。\n \n对于每个测试用例，您的程序必须计算：\n- 边界-面的整数数量。\n- 按字典序排序的边界-面列表，每个面的形式为 $[i,j,k,1]$，其中 $i<j<k$。\n \n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有五个用例的结果，形式为一个以方括号括起来的逗号分隔列表。每个用例的结果本身必须是一个双元素列表：$[\\text{boundary\\_count}, \\text{boundary\\_faces}]$，其中 $\\text{boundary\\_faces}$ 是按规定格式表示的、经字典序排序的带标签面列表。例如，总输出格式为 $[[c_1,F_1],[c_2,F_2],[c_3,F_3],[c_4,F_4],[c_5,F_5]]$，其中 $c_m$ 是一个整数，$F_m$ 是一个整数列表的列表。\n \n角度和物理单位不适用于此问题。所有输出均为整数值或整数列表。您的程序必须完全自包含，无需输入，并且必须为上述五个指定用例精确计算结果。", "solution": "所提出的问题是计算拓扑学中一个明确定义的练习，该学科是计算工程和物理学的一门基础学科。任务是识别一个三维单纯复形的边界-面，该单纯复形由其构成的 $3$-单纯形（四面体）列表定义。我们只获得了组合连接数据，特别是每个四面体的节点标识符，而没有几何坐标。\n\n该问题基于代数拓扑学中关于单纯复形上边界算子的一个基本原理。单纯复形是单纯形（顶点、边、三角形、四面体及其高维对应物）的集合，该集合在取面和非空交集的操作下是封闭的。设 $K$ 是一个单纯复形。一个 $p$-链是 $K$ 中 $p$-单纯形的一个形式和，记作 $\\sum_{i} c_i \\sigma_i^p$，其中 $\\sigma_i^p$ 是 $p$-单纯形，$c_i$ 是来自某个环的系数，通常是整数环 $\\mathbb{Z}$ 或像 $\\mathbb{Z}_2 = \\{0, 1\\}$ 这样的有限域。\n\n边界算子 $\\partial_p$ 将一个 $p$-单纯形映射为其 $(p-1)$-维面（面元）的和。对于一个由其 $p+1$ 个顶点定义的 $p$-单纯形 $\\sigma^p = [v_0, v_1, \\dots, v_p]$，其边界是由以下公式给出的 $(p-1)$-链：\n$$\n\\partial_p(\\sigma^p) = \\sum_{j=0}^{p} (-1)^j [v_0, \\dots, \\hat{v}_j, \\dots, v_p]\n$$\n其中 $[v_0, \\dots, \\hat{v}_j, \\dots, v_p]$ 表示省略顶点 $v_j$ 后形成的 $(p-1)$-单纯形。符号 $(-1)^j$ 用于说明定向。\n\n问题陈述通过有效地考虑在域 $\\mathbb{Z}_2$ 上的链来简化了这一点。在此背景下，加法是模 $2$ 运算，因此可以忽略定向符号（因为 $-1 \\equiv 1 \\pmod 2$）。一个 $3$-单纯形（四面体）$\\sigma^3 = [v_0, v_1, v_2, v_3]$ 的边界就是其四个 $2$-单纯形（三角）面的和：\n$$\n\\partial_3(\\sigma^3) = [v_1, v_2, v_3] + [v_0, v_2, v_3] + [v_0, v_1, v_3] + [v_0, v_1, v_2]\n$$\n现在，考虑一个 $3$-链 $C = \\sum_{i} \\sigma_i^3$，它代表我们网格中所有四面体的集合。利用边界算子的线性性，可以找到整个集合的边界 $\\partial_3(C)$：\n$$\n\\partial_3(C) = \\partial_3\\left(\\sum_{i} \\sigma_i^3\\right) = \\sum_{i} \\partial_3(\\sigma_i^3)\n$$\n在这个基于 $\\mathbb{Z}_2$ 的求和中，一个给定的三角面 $\\tau$ 每被一个包含它的四面体作为面元，就会出现一次。如果 $\\tau$ 是集合中偶数个（比如 $2k$ 个）四面体的面元，其对总和的贡献是 $2k \\cdot \\tau \\equiv 0 \\pmod 2$。如果 $\\tau$ 是奇数个（比如 $2k+1$ 个）四面体的面元，其总贡献是 $(2k+1) \\cdot \\tau \\equiv 1 \\cdot \\tau \\pmod 2$。因此，边界 $\\partial_3(C)$ 精确地是网格中每个都与奇数个四面体相关联的三角面的集合。\n\n该问题将“边界-面”定义为关联计数恰好为 $1$ 的面。这是对于单纯伪流形这一常见情况的一般原理的特例，在单纯伪流形中，任何内部面都由恰好两个四面体共享。算法要求正确地将这一原理形式化，以便于计算实现。\n\n算法如下：\n$1$. 我们需要一个数据结构来存储每个唯一三角面的关联计数。哈希映射（或 Python 中的字典）是理想的数据结构，其中键代表面，值存储其计数。\n$2$. 为了处理定向无关性并为每个面提供唯一表示，我们必须对其进行规范化。一个由三个节点标识符 $\\{i, j, k\\}$ 定义的面，通过将这些整数排序成一个元组来进行规范化，例如 $(i', j', k')$，其中 $i' < j' < k'$。这个排序后的元组将作为我们哈希映射中的唯一键。\n$3$. 我们遍历输入连接关系列表中的每个四面体。对于每个由其四个节点标识符 $\\{v_0, v_1, v_2, v_3\\}$ 表示的四面体，我们生成其四个三角面：$\\{v_0, v_1, v_2\\}$、$\\{v_0, v_1, v_3\\}$、$\\{v_0, v_2, v_3\\}$ 和 $\\{v_1, v_2, v_3\\}$。\n$4$. 对于每个生成的面，我们按照步骤 $2$ 中描述的方法生成其规范键。然后我们更新哈希映射：如果该键已存在，我们增加其关联的计数值；否则，我们将该键添加到映射中，计数值为 $1$。\n$5$. 处理完所有四面体后，哈希映射包含了网格中每个唯一的面及其总关联计数。然后我们遍历该映射。任何计数恰好为 $1$ 的面（键）都被识别为边界-面。\n$6$. 收集这些被识别出的边界-面，它们是包含三个已排序节点标识符的元组。将边界标签 $1$ 附加到每个面上，形成一个列表 $[i', j', k', 1]$。\n$7$. 最终的带标签边界-面列表按字典序排序，以确保输出的唯一性和有序性，正如要求所规定的。同时计算这些面的总数。\n\n此过程是确定性的，对于给定的约束条件具有计算效率，并且正确地实现了底层的拓扑原理。例如，在用例 2 中，四面体为 $[[0,1,2,3],[0,2,1,4]]$，由节点 $\\{0,1,2\\}$ 定义的面会由两个四面体生成。其规范形式，即元组 $(0,1,2)$，的计数值将被增加两次，最终计数为 $2$。因此，它被正确地识别为内部面。所有其他面，例如来自第一个四面体的 $\\{0,1,3\\}$ 和来自第二个四面体的 $\\{0,1,4\\}$，只出现一次，并被正确地识别为边界-面。此逻辑适用于所有测试用例，包括非流形配置（用例 3），其中一个面可能由两个以上的单元共享，以及重复单元（用例 5），其中每个面的计数只是简单地加倍。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport collections\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves for boundary faces in five test cases of tetrahedral meshes.\n    \"\"\"\n    test_cases = [\n        # Case 1: single tetrahedron\n        [[0, 1, 2, 3]],\n        # Case 2: two tetrahedra sharing one face\n        [[0, 1, 2, 3], [0, 2, 1, 4]],\n        # Case 3: three tetrahedra meeting non-manifoldly on one common face\n        [[1, 2, 3, 0], [2, 1, 3, 4], [3, 1, 2, 5]],\n        # Case 4: disconnected mesh\n        [[10, 11, 12, 13], [20, 21, 22, 23], [22, 21, 20, 24]],\n        # Case 5: duplicate tetrahedra\n        [[0, 1, 2, 3], [0, 1, 2, 3]],\n    ]\n\n    results = []\n    for connectivity in test_cases:\n        # Use a dictionary to store face counts.\n        # Key: canonical face (sorted tuple of 3 node IDs)\n        # Value: incidence count\n        face_counts = collections.defaultdict(int)\n\n        # Iterate through each tetrahedron in the mesh\n        for tet_nodes in connectivity:\n            # A tetrahedron has 4 nodes. A triangular face is formed by 3 nodes.\n            # We generate all combinations of 3 nodes from the 4.\n            for face_nodes in combinations(tet_nodes, 3):\n                # Canonicalize the face by sorting its node IDs.\n                # This makes the representation unique regardless of orientation.\n                canonical_face = tuple(sorted(face_nodes))\n                face_counts[canonical_face] += 1\n\n        # Identify boundary faces\n        # A face is a boundary face if its incidence count is exactly 1.\n        boundary_faces = []\n        for face, count in face_counts.items():\n            if count == 1:\n                # The output format for a face is [i, j, k, 1]\n                tagged_face = list(face) + [1]\n                boundary_faces.append(tagged_face)\n        \n        # Sort the boundary faces lexicographically for a consistent output.\n        boundary_faces.sort()\n        \n        # Get the count of boundary faces.\n        boundary_count = len(boundary_faces)\n\n        # Store the result for this test case.\n        results.append([boundary_count, boundary_faces])\n\n    # The final output must be a single line string representation of the list\n    # of results, with no spaces. str() adds spaces, so we remove them.\n    final_output_string = str(results).replace(\" \", \"\")\n    print(final_output_string)\n\nsolve()\n```", "id": "2412652"}]}