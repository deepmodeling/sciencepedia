{"hands_on_practices": [{"introduction": "网格质量的评估是多维度的。尽管像纵横比这样的简单几何度量很有用，但它们并不能完全反映网格的有效性。这个练习是一个关键的思想实验，它揭示了一个重要的陷阱：一个几何形状看似“完美”的单元，在数学上可能对于模拟是无效的。通过亲手计算，你将理解为何基于等参映射的雅可比行列式是判断单元有效性的一个更根本的度量。[@problem_id:2412959]", "problem": "在计算工程中，网格质量通常通过将几何形状度量（如纵横比）与基于映射的度量（如等参变换的雅可比行列式）相结合来评估。考虑一个二维（$2$D）双线性等参四边形单元，它将具有参数坐标 $(\\xi,\\eta) \\in [-1,1] \\times [-1,1]$ 的参考正方形映射到物理平面中的一个直边四边形。请使用以下构造来说明完美的纵横比并不保证映射有效。\n\n定义物理节点坐标（按逆时针参考节点顺序）如下：\n$$\n(x_1,y_1)=(0,a),\\quad (x_2,y_2)=(a,0),\\quad (x_3,y_3)=(0,-a),\\quad (x_4,y_4)=(-a,0),\n$$\n其中 $a>0$。为进行网格质量评估，采用基于边长的纵横比\n$$\nr=\\frac{\\max\\{\\ell_1,\\ell_2,\\ell_3,\\ell_4\\}}{\\min\\{\\ell_1,\\ell_2,\\ell_3,\\ell_4\\}},\n$$\n其中 $\\ell_i$ 是由连续节点 $i$ 和 $i+1$（节点5与节点1视为同一节点）构成的第 $i$ 条物理边的欧几里得长度。\n\n从4节点四边形的标准双线性等参映射和映射的雅可比矩阵 $J(\\xi,\\eta)$ 的定义出发，完成以下任务：\n- 证明所构造的单元具有 $r=1$。\n- 计算单元中心 $(\\xi,\\eta)=(0,0)$ 处的雅可比行列式，并用 $a$ 精确表示。\n\n请以 $a$ 表示的单个闭式表达式给出单元中心处雅可比行列式的最终答案。不包含单位。无需舍入。", "solution": "该问题要求分析一个特定的二维双线性等参四边形单元，以证明完美的纵横比并不能保证映射的有效性。这将通过首先计算该单元基于边长的纵横比 $r$，然后计算单元中心处映射的雅可比行列式来完成。\n\n首先，我们证明纵横比 $r=1$。四个节点的物理坐标按逆时针参考节点顺序列出，分别为 $(x_1, y_1) = (0, a)$、$(x_2, y_2) = (a, 0)$、$(x_3, y_3) = (0, -a)$ 和 $(x_4, y_4) = (-a, 0)$，其中常数 $a > 0$。纵横比定义为最大边长与最小边长之比，即 $r = \\frac{\\max\\{\\ell_i\\}}{\\min\\{\\ell_i\\}}$。我们使用欧几里得距离公式 $\\ell = \\sqrt{\\Delta x^2 + \\Delta y^2}$ 来计算四条边中每条边的长度 $\\ell_i$。\n\n第一条边 $\\ell_1$（节点1和节点2之间）的长度为：\n$$\n\\ell_1 = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2} = \\sqrt{(a - 0)^2 + (0 - a)^2} = \\sqrt{a^2 + (-a)^2} = \\sqrt{2a^2} = a\\sqrt{2}\n$$\n\n第二条边 $\\ell_2$（节点2和节点3之间）的长度为：\n$$\n\\ell_2 = \\sqrt{(x_3 - x_2)^2 + (y_3 - y_2)^2} = \\sqrt{(0 - a)^2 + (-a - 0)^2} = \\sqrt{(-a)^2 + (-a)^2} = \\sqrt{2a^2} = a\\sqrt{2}\n$$\n\n第三条边 $\\ell_3$（节点3和节点4之间）的长度为：\n$$\n\\ell_3 = \\sqrt{(x_4 - x_3)^2 + (y_4 - y_3)^2} = \\sqrt{(-a - 0)^2 + (0 - (-a))^2} = \\sqrt{(-a)^2 + a^2} = \\sqrt{2a^2} = a\\sqrt{2}\n$$\n\n第四条边 $\\ell_4$（节点4和节点1之间）的长度为：\n$$\n\\ell_4 = \\sqrt{(x_1 - x_4)^2 + (y_1 - y_4)^2} = \\sqrt{(0 - (-a))^2 + (a - 0)^2} = \\sqrt{a^2 + a^2} = \\sqrt{2a^2} = a\\sqrt{2}\n$$\n\n由于所有边长相等，$\\ell_1 = \\ell_2 = \\ell_3 = \\ell_4 = a\\sqrt{2}$，因此最大长度和最小长度相同。所以，纵横比为：\n$$\nr = \\frac{\\max\\{\\ell_i\\}}{\\min\\{\\ell_i\\}} = \\frac{a\\sqrt{2}}{a\\sqrt{2}} = 1\n$$\n这证明了该单元具有完美的纵横比，即为1。\n\n接下来，我们计算雅可比行列式。从参考坐标 $(\\xi, \\eta)$ 到物理坐标 $(x, y)$ 的等参映射定义为：\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i \\quad \\text{和} \\quad y(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i\n$$\n对于参考正方形 $[-1,1] \\times [-1,1]$，其标准双线性形函数 $N_i(\\xi, \\eta)$ 与从 $(\\xi, \\eta) = (-1,-1)$ 开始逆时针排列的节点相关联：\n$N_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)$\n$N_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)$\n$N_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)$\n$N_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)$\n\n代入给定的物理节点坐标：\n$x(\\xi, \\eta) = N_1(0) + N_2(a) + N_3(0) + N_4(-a) = a N_2 - a N_4$\n$y(\\xi, \\eta) = N_1(a) + N_2(0) + N_3(-a) + N_4(0) = a N_1 - a N_3$\n\n代入形函数的表达式：\n$$\nx(\\xi, \\eta) = a \\left( \\frac{1}{4}(1+\\xi)(1-\\eta) \\right) - a \\left( \\frac{1}{4}(1-\\xi)(1+\\eta) \\right) = \\frac{a}{4} ((1-\\eta+\\xi-\\xi\\eta) - (1+\\eta-\\xi-\\xi\\eta)) = \\frac{a}{4}(2\\xi - 2\\eta) = \\frac{a}{2}(\\xi - \\eta)\n$$\n$$\ny(\\xi, \\eta) = a \\left( \\frac{1}{4}(1-\\xi)(1-\\eta) \\right) - a \\left( \\frac{1}{4}(1+\\xi)(1+\\eta) \\right) = \\frac{a}{4} ((1-\\eta-\\xi+\\xi\\eta) - (1+\\eta+\\xi+\\xi\\eta)) = \\frac{a}{4}(-2\\eta - 2\\xi) = -\\frac{a}{2}(\\xi + \\eta)\n$$\n变换的雅可比矩阵为 $J(\\xi, \\eta) = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix}$。我们计算其偏导数：\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi}\\left(\\frac{a}{2}(\\xi - \\eta)\\right) = \\frac{a}{2}\n$$\n$$\n\\frac{\\partial x}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta}\\left(\\frac{a}{2}(\\xi - \\eta)\\right) = -\\frac{a}{2}\n$$\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi}\\left(-\\frac{a}{2}(\\xi + \\eta)\\right) = -\\frac{a}{2}\n$$\n$$\n\\frac{\\partial y}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta}\\left(-\\frac{a}{2}(\\xi + \\eta)\\right) = -\\frac{a}{2}\n$$\n因此，雅可比矩阵在整个单元上是恒定的：\n$$\nJ = \\begin{pmatrix} \\frac{a}{2} & -\\frac{a}{2} \\\\ -\\frac{a}{2} & -\\frac{a}{2} \\end{pmatrix}\n$$\n雅可比行列式 $\\det(J)$ 为：\n$$\n\\det(J) = \\left(\\frac{a}{2}\\right)\\left(-\\frac{a}{2}\\right) - \\left(-\\frac{a}{2}\\right)\\left(-\\frac{a}{2}\\right) = -\\frac{a^2}{4} - \\frac{a^2}{4} = -\\frac{2a^2}{4} = -\\frac{a^2}{2}\n$$\n由于雅可比行列式是常数，其在单元中心 $(\\xi, \\eta)=(0,0)$ 处的值为 $-\\frac{a^2}{2}$。负的雅可比行列式表示该映射是局部方向反转的，意味着单元发生了“扭曲”或“翻转”。在有限元方法的背景下，这是一个无效单元。本练习正确地说明了完美的几何纵横比（$r=1$）并不能保证映射的有效性。", "answer": "$$\n\\boxed{-\\frac{a^2}{2}}\n$$", "id": "2412959"}, {"introduction": "在诊断出无效单元（如“翻转”单元）后，下一步自然是学习如何修复它们。本练习将引导你通过编程实践，比较两种不同的平滑策略：一种是简单直观的拉普拉斯平滑，另一种是更为稳健的基于优化的方法。通过对比它们在处理翻转网格时的不同表现，你将亲身体会到算法在简单性与鲁棒性之间的权衡，并加深对网格“解缠”重要性的理解。[@problem_id:2412991]", "problem": "您必须编写一个完整且可运行的程序，该程序构建一个小的二维（$2$-D）三角形网格，刻意引入一个翻转的单元，然后比较简单的 Laplacian 平滑器与基于优化的平滑器在解开翻转方面的能力。您的程序必须从第一性原理实现这两种平滑器，将它们应用于所提供的网格配置测试套件，并以布尔值的形式报告每种方法在每种情况下是否成功解开了网格。\n\n从以下基本概念开始：平面中三角形的带符号面积，对于顶点 $\\mathbf{p}_0=(x_0,y_0)$、$\\mathbf{p}_1=(x_1,y_1)$ 和 $\\mathbf{p}_2=(x_2,y_2)$，其定义为\n$$\nA_s(\\mathbf{p}_0,\\mathbf{p}_1,\\mathbf{p}_2) = \\tfrac{1}{2}\\,\\det\\begin{bmatrix}x_1-x_0 & x_2-x_0\\\\ y_1-y_0 & y_2-y_0\\end{bmatrix} = \\tfrac{1}{2}\\big((x_1-x_0)(y_2-y_0)-(x_2-x_0)(y_1-y_0)\\big).\n$$\n对于选定的顶点顺序，如果 $A_s \\le 0$，则三角形是翻转的。如果一个网格中所有三角形的带符号面积都严格为正，则该网格是未翻转的。对于迭代 $k$ 时的内部顶点 $\\mathbf{x}_i^{(k)}$，Laplacian 平滑器是如下的显式更新\n$$\n\\mathbf{x}_i^{(k+1)} = \\mathbf{x}_i^{(k)} + \\alpha\\left(\\frac{1}{|\\mathcal{N}(i)|}\\sum_{j\\in \\mathcal{N}(i)} \\mathbf{x}_j^{(k)} - \\mathbf{x}_i^{(k)}\\right),\n$$\n其中 $\\mathcal{N}(i)$ 表示 $1$-环邻域集， $|\\mathcal{N}(i)|$ 是其基数，$\\alpha\\in(0,1]$ 是步长。边界顶点保持固定。基于优化的平滑器是通过最小化一个能量函数来获得的，该函数惩罚负面积，同时鼓励短而平滑的边。对负带符号面积 $A_s$ 的一个平滑惩罚项可以通过将 softplus 函数 $\\operatorname{softplus}(z;\\beta) = \\tfrac{1}{\\beta}\\log(1+e^{\\beta z})$ 应用于 $z=-A_s$ 来获得，这会产生一个类似铰链（hinge-like）的可微惩罚项，当 $A_s$ 为负时其值很大，而当 $A_s$ 足够大时其值接近于零。设目标函数为\n$$\nE(\\mathbf{X}) = w_{\\ell}\\sum_{(i,j)\\in \\mathcal{E}} \\|\\mathbf{x}_i-\\mathbf{x}_j\\|_2^2 \\;+\\; w_{a}\\sum_{t\\in\\mathcal{T}} \\operatorname{softplus}\\!\\left(-A_s(t);\\beta\\right)^2,\n$$\n其中 $\\mathcal{E}$ 是无向网格边的集合，$\\mathcal{T}$ 是三角形的集合，$\\mathbf{X}$ 堆叠了所有顶点坐标，边界顶点是固定的，而内部顶点是待优化的。\n\n编程任务规范：\n- 构建一个方形边界，其顶点为 $\\mathbf{v}_0=(0,0)$、$\\mathbf{v}_1=(1,0)$、$\\mathbf{v}_2=(1,1)$、$\\mathbf{v}_3=(0,1)$，以及一个内部顶点 $\\mathbf{c}=(x_c,y_c)$，连接它们以形成四个具有一致逆时针方向的三角形：$(\\mathbf{v}_0,\\mathbf{v}_1,\\mathbf{c})$、$(\\mathbf{v}_1,\\mathbf{v}_2,\\mathbf{c})$、$(\\mathbf{v}_2,\\mathbf{v}_3,\\mathbf{c})$、$(\\mathbf{v}_3,\\mathbf{v}_0,\\mathbf{c})$。边界顶点的索引是固定的。\n- 实现一个 Laplacian 平滑器，该平滑器仅使用上述显式迭代更新内部顶点，步长 $\\alpha = 0.25$，迭代次数恰好为 $5$ 次。使用由三角形导出的 $1$-环邻域。\n- 实现一个基于优化的平滑器，该平滑器在以下参数下仅对内部顶点最小化 $E(\\mathbf{X})$：$w_{\\ell} = 1.0$、$w_{a} = 100.0$ 和 $\\beta = 10.0$。使用带有边界约束 $-2 \\le x_c \\le 2$、$-2 \\le y_c \\le 2$ 的数值优化。根据三角形的连接关系，将 $\\mathcal{E}$ 构建为无向边的唯一集合。\n- 如果所有三角形的带符号面积都严格大于阈值 $\\varepsilon = 10^{-12}$，则定义该网格为未翻转的。\n\n测试套件：\n- 情况 $1$（轻度翻转）：$\\mathbf{c}=(0.5,-0.05)$。\n- 情况 $2$（严重翻转）：$\\mathbf{c}=(0.5,-1.0)$。\n- 情况 $3$（已是有效网格）：$\\mathbf{c}=(0.5,0.5)$。\n\n对于每种情况，从指定的初始 $\\mathbf{c}$ 开始运行两种平滑器，并根据所有三角形满足 $A_s > \\varepsilon$ 的标准，评估一个布尔值，以指示生成的网格是否未翻转。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果必须按以下确切顺序排列：$[$情况 $1$ 上的 Laplacian，情况 $1$ 上的优化，情况 $2$ 上的 Laplacian，情况 $2$ 上的优化，情况 $3$ 上的 Laplacian，情况 $3$ 上的优化$]$，例如 $[b_1,b_2,b_3,b_4,b_5,b_6]$，其中每个 $b_i$ 为 True 或 False。", "solution": "该问题要求实现和比较两种网格平滑算法——Laplacian 平滑和一种基于优化的方法——以评估它们在解开一个翻转的二维三角形网格方面的有效性。对问题陈述的验证证实了其科学上的合理性、问题的良态性，并且包含了进行求解所需的所有必要信息。解决方法是首先建立网格几何形状和单元有效性的度量标准，然后按规定实现每种平滑算法，最后将它们应用于提供的测试用例，以确定它们在生成有效、未翻转网格方面的成功率。\n\n首先，我们定义计算域和网格拓扑。该网格由五个顶点组成：四个固定的边界顶点构成一个单位正方形，分别为 $\\mathbf{v}_0=(0,0)$、$\\mathbf{v}_1=(1,0)$、$\\mathbf{v}_2=(1,1)$ 和 $\\mathbf{v}_3=(0,1)$，以及一个可移动的内部顶点 $\\mathbf{c}=(x_c, y_c)$。这些顶点形成四个三角形的集合，其连接关系被定义为确保一个位于边界内部的有效（非翻转）网格具有一致的逆时针方向：$T_0 = (\\mathbf{v}_0, \\mathbf{v}_1, \\mathbf{c})$、$T_1 = (\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{c})$、$T_2 = (\\mathbf{v}_2, \\mathbf{v}_3, \\mathbf{c})$ 和 $T_3 = (\\mathbf{v}_3, \\mathbf{v}_0, \\mathbf{c})$。\n\n三角形的质量由其带符号面积决定。对于具有顶点 $\\mathbf{p}_0=(x_0,y_0)$、$\\mathbf{p}_1=(x_1,y_1)$ 和 $\\mathbf{p}_2=(x_2,y_2)$ 的三角形，其带符号面积 $A_s$ 由以下公式给出：\n$$\nA_s(\\mathbf{p}_0, \\mathbf{p}_1, \\mathbf{p}_2) = \\frac{1}{2} \\det\\begin{bmatrix}x_1-x_0 & x_2-x_0 \\\\ y_1-y_0 & y_2-y_0\\end{bmatrix}\n$$\n正的带符号面积对应于顶点的逆时针排序，这是有效单元的约定。如果 $A_s \\le 0$，则认为三角形是翻转的。如果一个网格的所有组成三角形的带符号面积都严格大于一个很小的容差 $A_s > \\varepsilon$（其中 $\\varepsilon = 10^{-12}$），则该网格被定义为未翻转的。\n\n第一种方法是 Laplacian 平滑，它是一种迭代启发式方法，将内部顶点重新定位到其相邻顶点的几何中心。在迭代 $k$ 时，内部顶点 $\\mathbf{x}_i$ 的位置更新公式为：\n$$\n\\mathbf{x}_i^{(k+1)} = \\mathbf{x}_i^{(k)} + \\alpha \\left( \\frac{1}{|\\mathcal{N}(i)|} \\sum_{j \\in \\mathcal{N}(i)} \\mathbf{x}_j^{(k)} - \\mathbf{x}_i^{(k)} \\right)\n$$\n在我们的特定网格中，只有一个内部顶点 $\\mathbf{c}$。它的 $1$-环邻域 $\\mathcal{N}(\\mathbf{c})$ 是四个边界顶点 $\\{\\mathbf{v}_0, \\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3\\}$。这些固定邻域的质心是一个常数点 $\\bar{\\mathbf{v}} = \\frac{1}{4}(\\mathbf{v}_0 + \\mathbf{v}_1 + \\mathbf{v}_2 + \\mathbf{v}_3) = (\\frac{0+1+1+0}{4}, \\frac{0+0+1+1}{4}) = (0.5, 0.5)$。对 $\\mathbf{c}$ 的迭代更新简化为：\n$$\n\\mathbf{c}^{(k+1)} = \\mathbf{c}^{(k)} + \\alpha (\\bar{\\mathbf{v}} - \\mathbf{c}^{(k)})\n$$\n此过程以步长 $\\alpha = 0.25$ 执行固定的 $5$ 次迭代。边界顶点保持不变。\n\n第二种方法是基于优化的平滑器，它试图最小化一个全局目标函数 $E(\\mathbf{X})$，其中 $\\mathbf{X}$ 代表所有顶点的坐标。该函数是两项的加权和：一项是对边长平方的惩罚，另一项是对非正三角形面积的惩罚。\n$$\nE(\\mathbf{X}) = w_{\\ell}\\sum_{(i,j)\\in \\mathcal{E}} \\|\\mathbf{x}_i-\\mathbf{x}_j\\|_2^2 \\;+\\; w_{a}\\sum_{t\\in\\mathcal{T}} \\operatorname{softplus}\\!\\left(-A_s(t);\\beta\\right)^2\n$$\n边的集合 $\\mathcal{E}$ 包括 $4$ 条边界边和 $4$ 条连接 $\\mathbf{c}$ 与每个边界顶点的边。三角形的集合 $\\mathcal{T}$ 包含四个三角形 $\\{T_0, T_1, T_2, T_3\\}$。项 $\\operatorname{softplus}(z;\\beta) = \\frac{1}{\\beta}\\log(1+e^{\\beta z})$ 是 ReLU 函数的一个平滑近似，当其参数为 $z = -A_s$ 时，它充当对负带符号面积的可微惩罚项。优化仅针对内部顶点 $\\mathbf{c}$ 的坐标进行，并受限于箱式约束 $-2 \\le x_c, y_c \\le 2$。指定的参数为 $w_{\\ell} = 1.0$、$w_{a} = 100.0$ 和 $\\beta = 10.0$。我们将使用 `scipy` 库中的一个数值优化例程来找到最小化此目标函数的 $\\mathbf{c}$ 的坐标。\n\n对于每个测试用例，首先设置 $\\mathbf{c}$ 的初始位置。然后应用两种平滑算法中的每一种。每次运行后，使用 $\\mathbf{c}$ 的最终位置计算所有四个三角形的带符号面积。当且仅当所有四个面积都大于 $\\varepsilon = 10^{-12}$ 时，该网格被认证为未翻转。对于每种方法和每个测试用例，都会记录此检查的布尔结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.5, -0.05),  # Case 1 (mild inversion)\n        (0.5, -1.0),   # Case 2 (severe inversion)\n        (0.5, 0.5),    # Case 3 (already valid)\n    ]\n\n    # Global parameters\n    EPSILON = 1e-12\n    BOUNDARY_VERTS = np.array([\n        [0.0, 0.0],  # v0 (index 0)\n        [1.0, 0.0],  # v1 (index 1)\n        [1.0, 1.0],  # v2 (index 2)\n        [0.0, 1.0],  # v3 (index 3)\n    ])\n    # Vertex indices for the four triangles, with interior vertex at index 4\n    TRIANGLES_CONN = [\n        (0, 1, 4),\n        (1, 2, 4),\n        (2, 3, 4),\n        (3, 0, 4),\n    ]\n    # Unique undirected edges for the objective function\n    EDGES_CONN = [\n        (0, 1), (1, 2), (2, 3), (3, 0), # boundary edges\n        (0, 4), (1, 4), (2, 4), (3, 4)  # interior edges\n    ]\n\n    def signed_area(p0, p1, p2):\n        \"\"\"Calculates the signed area of a triangle given its vertices.\"\"\"\n        return 0.5 * ((p1[0] - p0[0]) * (p2[1] - p0[1]) - \n                      (p2[0] - p0[0]) * (p1[1] - p0[1]))\n\n    def check_untangled(interior_vert_pos):\n        \"\"\"Checks if the mesh is untangled given the position of the interior vertex.\"\"\"\n        all_verts = np.vstack((BOUNDARY_VERTS, interior_vert_pos))\n        for i, j, k in TRIANGLES_CONN:\n            p0, p1, p2 = all_verts[i], all_verts[j], all_verts[k]\n            if signed_area(p0, p1, p2) <= EPSILON:\n                return False\n        return True\n\n    def run_laplacian_smoother(initial_c):\n        \"\"\"Runs the Laplacian smoother for a specified number of iterations.\"\"\"\n        alpha = 0.25\n        num_iterations = 5\n        c_current = np.array(initial_c, dtype=float)\n        centroid = np.mean(BOUNDARY_VERTS, axis=0)\n\n        for _ in range(num_iterations):\n            # Update rule: c_new = c_old + alpha * (centroid - c_old)\n            c_current += alpha * (centroid - c_current)\n        \n        return c_current\n\n    def objective_function(c_coords, wl, wa, beta):\n        \"\"\"Objective function for optimization-based smoothing.\"\"\"\n        all_verts = np.vstack((BOUNDARY_VERTS, c_coords))\n        \n        # Edge length term\n        edge_energy = 0.0\n        for i, j in EDGES_CONN:\n            p1 = all_verts[i]\n            p2 = all_verts[j]\n            edge_energy += np.sum((p1 - p2)**2)\n            \n        # Area penalty term\n        area_penalty = 0.0\n        for i, j, k in TRIANGLES_CONN:\n            p0, p1, p2 = all_verts[i], all_verts[j], all_verts[k]\n            area = signed_area(p0, p1, p2)\n            \n            # softplus(-area; beta)\n            z = -area\n            # Use a numerically stable implementation for softplus\n            if beta * z > 700: # Avoid overflow in exp\n                 softplus_val = z\n            else:\n                 softplus_val = (1.0 / beta) * np.log1p(np.exp(beta * z))\n            area_penalty += softplus_val**2\n\n        return wl * edge_energy + wa * area_penalty\n\n    def run_optimization_smoother(initial_c):\n        \"\"\"Runs the optimization-based smoother.\"\"\"\n        wl, wa, beta = 1.0, 100.0, 10.0\n        bounds = [(-2.0, 2.0), (-2.0, 2.0)]\n        initial_c_np = np.array(initial_c, dtype=float)\n\n        result = minimize(\n            fun=objective_function,\n            x0=initial_c_np,\n            args=(wl, wa, beta),\n            method='L-BFGS-B',\n            bounds=bounds\n        )\n        return result.x\n\n    results = []\n    for case in test_cases:\n        initial_c = case\n        \n        # Run and evaluate Laplacian smoother\n        final_c_laplacian = run_laplacian_smoother(initial_c)\n        laplacian_success = check_untangled(final_c_laplacian)\n        results.append(laplacian_success)\n        \n        # Run and evaluate Optimization-based smoother\n        final_c_optimization = run_optimization_smoother(initial_c)\n        optimization_success = check_untangled(final_c_optimization)\n        results.append(optimization_success)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2412991"}, {"introduction": "在真实的工程应用中，网格通常需要附着在复杂的曲面之上，而非简单的平面。传统的平滑算法可能会导致顶点偏离原始几何表面，从而破坏模型的准确性。这个高级实践将挑战你实现一种约束平滑算法，该算法在改善网格质量的同时能够保持其紧贴于底层曲面。通过在球面上进行操作，你将掌握切平面投影与重投影等核心技术，这是几何感知网格处理的基石。[@problem_id:2412997]", "problem": "给定一个嵌入在三维欧几里得空间中的解析曲面，以及一小组其顶点位于该曲面上的三角形表面网格。对于每个网格，请对顶点位置执行单次约束平滑扫描，并评估其对单元质量的影响。\n\n曲面与切平面约束。设该曲面为以原点为中心、半径为 $R$ 的球面，\n$$\n\\mathcal{S} = \\left\\{ \\mathbf{x} \\in \\mathbb{R}^3 \\;\\middle|\\; \\|\\mathbf{x}\\|_2 = R \\right\\}.\n$$\n对于任何 $\\mathbf{x} \\in \\mathcal{S}$，其单位法向量为 $\\mathbf{n}(\\mathbf{x}) = \\mathbf{x}/R$，其仿射切平面为\n$$\n\\mathcal{T}_{\\mathbf{x}}\\mathcal{S} = \\left\\{ \\mathbf{y} \\in \\mathbb{R}^3 \\;\\middle|\\; (\\mathbf{y} - \\mathbf{x}) \\cdot \\mathbf{n}(\\mathbf{x}) = 0 \\right\\}.\n$$\n\n各顶点的平滑目标。考虑一个顶点集为 $V=\\{\\mathbf{p}_i\\}_{i=1}^N \\subset \\mathcal{S}$、面集为 $F \\subset \\{1,\\dots,N\\}^3$ 的三角形网格。对于每个不在网格边界上的顶点索引 $i$，令 $\\mathcal{N}(i)$ 表示其相邻顶点的索引集合（即通过边与 $i$ 连接的顶点）。通过以下最小化问题定义受约束的最优中间位置 $\\mathbf{y}_i$：\n$$\n\\mathbf{y}_i \\in \\underset{\\mathbf{y} \\in \\mathcal{T}_{\\mathbf{p}_i}\\mathcal{S}}{\\arg\\min}\\;\\sum_{j \\in \\mathcal{N}(i)} \\|\\mathbf{y} - \\mathbf{p}_j\\|_2^2.\n$$\n通过径向投影回球面来定义更新后的位置 $\\mathbf{z}_i$，\n$$\n\\mathbf{z}_i = \\frac{R}{\\|\\mathbf{y}_i\\|_2}\\,\\mathbf{y}_i.\n$$\n边界上的顶点不移动，也就是说，如果 $i$ 在边界上，则设 $\\mathbf{z}_i = \\mathbf{p}_i$。如果一个顶点属于至少一条仅包含在一个面中的边，则该顶点位于边界上。一次平滑扫描会同时将所有 $\\mathbf{p}_i$ 替换为相应的 $\\mathbf{z}_i$。\n\n三角形质量。对于任意顶点为 $\\mathbf{a},\\mathbf{b},\\mathbf{c} \\in \\mathbb{R}^3$ 的三角形，定义其面积\n$$\nA(\\mathbf{a},\\mathbf{b},\\mathbf{c}) = \\tfrac{1}{2}\\,\\|(\\mathbf{b}-\\mathbf{a}) \\times (\\mathbf{c}-\\mathbf{a})\\|_2,\n$$\n及其边长 $\\ell_1=\\|\\mathbf{b}-\\mathbf{a}\\|_2$、 $\\ell_2=\\|\\mathbf{c}-\\mathbf{b}\\|_2$、 $\\ell_3=\\|\\mathbf{a}-\\mathbf{c}\\|_2$。该三角形的质量为\n$$\nq(\\mathbf{a},\\mathbf{b},\\mathbf{c}) = \\frac{4\\sqrt{3}\\,A(\\mathbf{a},\\mathbf{b},\\mathbf{c})}{\\ell_1^2 + \\ell_2^2 + \\ell_3^2},\n$$\n该质量满足 $0 < q \\le 1$，且对于等边三角形，$q=1$。对于一个网格，其平均质量是所有面上 $q$ 值的算术平均值。\n\n任务。对于下面描述的每个测试用例，计算平滑扫描前后的平均三角形质量，并返回差值 $\\Delta = \\overline{q}_{\\text{after}} - \\overline{q}_{\\text{before}}$。\n\n测试用例中使用的定义。对于任何非零向量 $\\mathbf{v} \\in \\mathbb{R}^3$，令 $\\operatorname{normalize}(\\mathbf{v}) = \\mathbf{v}/\\|\\mathbf{v}\\|_2$。在所有情况下均使用 $R=1$。角度（如果出现）以弧度为单位，但不需要三角函数输入；所有顶点坐标都已直接给出。\n\n测试套件。共有三个网格。\n\n测试用例 $1$（一个内部顶点和三个边界顶点）。顶点：\n- $\\mathbf{p}_0 = (0,0,1)$,\n- $\\mathbf{p}_1 = \\operatorname{normalize}(1,0,0.2)$,\n- $\\mathbf{p}_2 = \\left(-\\tfrac{1}{2},\\tfrac{\\sqrt{3}}{2},0\\right)$,\n- $\\mathbf{p}_3 = \\left(-\\tfrac{1}{2},-\\tfrac{\\sqrt{3}}{2},0\\right)$。\n面：$(0,1,2)$、$(0,2,3)$、$(0,3,1)$。\n\n测试用例 $2$（单个边界三角形）。顶点：\n- $\\mathbf{p}_1 = (1,0,0)$,\n- $\\mathbf{p}_2 = \\left(-\\tfrac{1}{2},\\tfrac{\\sqrt{3}}{2},0\\right)$,\n- $\\mathbf{p}_3 = \\left(-\\tfrac{1}{2},-\\tfrac{\\sqrt{3}}{2},0\\right)$。\n面：$(1,2,3)$。\n\n测试用例 $3$（一个内部顶点和一个四顶点边界环）。顶点：\n- $\\mathbf{p}_c = \\operatorname{normalize}(0.2,-0.1,0.97)$,\n- $\\mathbf{p}_a = \\operatorname{normalize}(0.9,0.0,0.435)$,\n- $\\mathbf{p}_b = \\operatorname{normalize}(0.0,0.9,0.435)$,\n- $\\mathbf{p}_d = \\operatorname{normalize}(-0.9,0.0,0.435)$,\n- $\\mathbf{p}_e = \\operatorname{normalize}(0.0,-0.9,0.435)$。\n面：$(c,a,b)$、$(c,b,d)$、$(c,d,e)$、$(c,e,a)$。\n\n要求的最终输出。您的程序应生成一行输出，其中包含测试用例 $1$、 $2$ 和 $3$ 的 $\\Delta$ 值，按顺序排列，形式为用方括号括起来的逗号分隔列表。每个 $\\Delta$ 值必须四舍五入到小数点后恰好 $6$ 位。例如：\"[$\\Delta_1,\\Delta_2,\\Delta_3$]\"，其中每个 $\\Delta_k$ 都格式化为 $6$ 位小数。不应打印任何其他文本。单位不适用；以十进制形式报告纯实数。", "solution": "该问题要求对几个三角形表面网格执行单次约束平滑扫描，并评估平均单元质量的变化。该曲面是一个以原点为中心的单位球面。\n\n对于每个给定的网格，解决方案分四个主要阶段进行：\n1.  **网格分析**：识别网格的边界顶点。根据问题定义，属于仅一个三角形的任何边的顶点都被视为边界顶点。所有其他顶点都是内部顶点。\n2.  **初始质量评估**：计算初始网格中每个三角形面的质量，并计算平均质量 $\\overline{q}_{\\text{before}}$。\n3.  **约束平滑**：计算所有顶点的新位置。边界顶点保持固定。对于每个内部顶点，其新位置是通过首先解决一个约束优化问题，然后将结果投影回球面上来找到的。\n4.  **最终质量评估与比较**：使用新的顶点位置计算平滑后网格的平均质量 $\\overline{q}_{\\text{after}}$。最终结果是差值 $\\Delta = \\overline{q}_{\\text{after}} - \\overline{q}_{\\text{before}}$。\n\n下面我们详细阐述每个阶段的数学和算法细节。\n\n**1. 边界顶点的识别**\n\n如果一个顶点是恰好属于一个面的某条边的一部分，则该顶点位于边界上。为了实现这一点，我们可以计算网格中每条边的出现次数。一条边由两个顶点索引 $(i, j)$ 定义。由于顺序无关紧要，我们使用一种规范表示，例如 $(\\min(i,j), \\max(i,j))$ 来表示该边。我们遍历网格的所有面。对于每个面 $(v_1, v_2, v_3)$，我们识别出它的三条边 $(v_1, v_2)$、$(v_2, v_3)$ 和 $(v_3, v_1)$，并在一个哈希表或字典中增加它们的计数。处理完所有面后，我们遍历该哈希表。计数为 1 的边是边界边。构成这些边界边的所有顶点的集合就是边界顶点的集合。\n\n**2. 三角形质量度量**\n\n一个顶点为 $\\mathbf{a}, \\mathbf{b}, \\mathbf{c} \\in \\mathbb{R}^3$ 的三角形的质量 $q$ 由公式给出：\n$$\nq(\\mathbf{a},\\mathbf{b},\\mathbf{c}) = \\frac{4\\sqrt{3}\\,A}{\\ell_1^2 + \\ell_2^2 + \\ell_3^2}\n$$\n其中 $A$ 是三角形的面积，$\\ell_1, \\ell_2, \\ell_3$ 是其边长。面积可以使用两个边向量的叉积计算：\n$$\nA(\\mathbf{a},\\mathbf{b},\\mathbf{c}) = \\frac{1}{2} \\|(\\mathbf{b}-\\mathbf{a}) \\times (\\mathbf{c}-\\mathbf{a})\\|_2\n$$\n边长由 $\\ell_1 = \\|\\mathbf{b}-\\mathbf{a}\\|_2$、$\\ell_2 = \\|\\mathbf{c}-\\mathbf{b}\\|_2$ 和 $\\ell_3 = \\|\\mathbf{a}-\\mathbf{c}\\|_2$ 给出。该质量度量是归一化的，因此对于等边三角形，其值为 1，而对于退化三角形，其值趋近于 0。一个网格的平均质量是其所有面上 $q$ 值的算术平均值。\n\n**3. 约束平滑算法**\n\n平滑过程更新每个内部顶点 $\\mathbf{p}_i$ 的位置。边界顶点不移动。对内部顶点 $\\mathbf{p}_i$ 的更新是一个两步过程。\n\n**步骤 3.1：切平面上的最优位置**\n\n首先，我们找到一个中间位置 $\\mathbf{y}_i$，它在 $\\mathbf{y}_i$ 必须位于球面在 $\\mathbf{p}_i$ 点的切平面上的约束下，最小化到其相邻顶点的平方距离之和。要最小化的目标函数是：\n$$\nf(\\mathbf{y}) = \\sum_{j \\in \\mathcal{N}(i)} \\|\\mathbf{y} - \\mathbf{p}_j\\|_2^2\n$$\n其中 $\\mathcal{N}(i)$ 是与顶点 $i$ 相邻的顶点索引集合。此函数的无约束最小值是相邻顶点的质心，$\\mathbf{c}_i = \\frac{1}{|\\mathcal{N}(i)|} \\sum_{j \\in \\mathcal{N}(i)} \\mathbf{p}_j$。\n\n约束条件是 $\\mathbf{y}_i$ 必须位于仿射切平面 $\\mathcal{T}_{\\mathbf{p}_i}\\mathcal{S}$ 中。对于以原点为中心的单位球面（$R=1$），在 $\\mathbf{p}_i$ 处的单位法向量是 $\\mathbf{n}(\\mathbf{p}_i) = \\mathbf{p}_i$。切平面的方程是 $(\\mathbf{y} - \\mathbf{p}_i) \\cdot \\mathbf{p}_i = 0$。\n\n这个约束最小化问题的解是无约束最小值 $\\mathbf{c}_i$ 在切平面上的正交投影。该投影的公式为：\n$$\n\\mathbf{y}_i = \\mathbf{c}_i - ((\\mathbf{c}_i - \\mathbf{p}_i) \\cdot \\mathbf{n}(\\mathbf{p}_i)) \\mathbf{n}(\\mathbf{p}_i)\n$$\n代入 $\\mathbf{n}(\\mathbf{p}_i) = \\mathbf{p}_i$ 并利用 $\\|\\mathbf{p}_i\\|_2=1$（因此 $\\mathbf{p}_i \\cdot \\mathbf{p}_i = 1$）这一事实，我们简化表达式：\n$$\n\\mathbf{y}_i = \\mathbf{c}_i - (\\mathbf{c}_i \\cdot \\mathbf{p}_i - \\mathbf{p}_i \\cdot \\mathbf{p}_i) \\mathbf{p}_i = \\mathbf{c}_i - (\\mathbf{c}_i \\cdot \\mathbf{p}_i - 1) \\mathbf{p}_i\n$$\n这就得到了中间位置 $\\mathbf{y}_i$。\n\n**步骤 3.2：投影回球面**\n\n点 $\\mathbf{y}_i$ 位于切平面上，但不一定在球面上。最终的更新位置 $\\mathbf{z}_i$ 是通过将 $\\mathbf{y}_i$ 径向投影回单位球面上得到的：\n$$\n\\mathbf{z}_i = \\frac{R}{\\|\\mathbf{y}_i\\|_2}\\,\\mathbf{y}_i = \\frac{\\mathbf{y}_i}{\\|\\mathbf{y}_i\\|_2} \\quad (\\text{因为 } R=1)\n$$\n这个过程对所有内部顶点同时执行，意味着每个 $\\mathbf{z}_i$ 的计算都使用原始位置 $\\{\\mathbf{p}_k\\}$。平滑后网格的新顶点集是 $\\{\\mathbf{z}_i\\}$，其中如果 $i$ 是边界顶点，则 $\\mathbf{z}_i=\\mathbf{p}_i$。\n\n**4. 计算**\n\n对于每个测试用例，我们实现以下算法：\n1.  定义初始顶点坐标和面连接关系。所有用 `normalize()` 指定的顶点都被归一化，使其欧几里得范数为 $1$。\n2.  计算初始平均质量 $\\overline{q}_{\\text{before}}$。\n3.  通过计算面之间的边共享情况来识别边界和内部顶点。同时构建一个将每个顶点映射到其邻居的邻接表。\n4.  为更新后的顶点位置创建一个新数组，用原始位置进行初始化。\n5.  遍历每个内部顶点 $i$：\n    a. 使用其邻居的原始位置计算质心 $\\mathbf{c}_i$。\n    b. 通过将 $\\mathbf{c}_i$ 投影到 $\\mathbf{p}_i$ 处的切平面上来计算中间位置 $\\mathbf{y}_i$。\n    c. 通过归一化 $\\mathbf{y}_i$ 来计算最终位置 $\\mathbf{z}_i$。\n    d. 将 $\\mathbf{z}_i$ 存储在新的位置数组中。\n6.  使用更新后的顶点位置和原始的面连接关系计算最终平均质量 $\\overline{q}_{\\text{after}}$。\n7.  计算并记录差值 $\\Delta = \\overline{q}_{\\text{after}} - \\overline{q}_{\\text{before}}$。\n\n将此过程应用于所有三个测试用例，以获得所需的 $\\Delta$ 值。对于测试用例 2，所有顶点都在边界上，因此不会发生平滑，故 $\\Delta = 0$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the mesh smoothing problem for all test cases.\n    \"\"\"\n\n    def normalize(v):\n        \"\"\" Normalizes a 3D vector to unit length. \"\"\"\n        norm = np.linalg.norm(v)\n        if norm == 0:\n            return v\n        return v / norm\n\n    def get_triangle_quality(a, b, c):\n        \"\"\" Calculates the quality of a single triangle. \"\"\"\n        l1_sq = np.sum((b - a)**2)\n        l2_sq = np.sum((c - b)**2)\n        l3_sq = np.sum((a - c)**2)\n        \n        sum_l_sq = l1_sq + l2_sq + l3_sq\n        if sum_l_sq == 0:\n            return 0.0\n\n        area = 0.5 * np.linalg.norm(np.cross(b - a, c - a))\n        \n        quality = (4.0 * np.sqrt(3.0) * area) / sum_l_sq\n        return quality\n\n    def get_avg_quality(vertices, faces):\n        \"\"\" Calculates the average quality of all triangles in a mesh. \"\"\"\n        if not faces:\n            return 0.0\n        total_quality = sum(get_triangle_quality(vertices[i], vertices[j], vertices[k]) for i, j, k in faces)\n        return total_quality / len(faces)\n\n    def get_mesh_info(num_vertices, faces):\n        \"\"\" Identifies boundary vertices and creates an adjacency list. \"\"\"\n        adj = {i: set() for i in range(num_vertices)}\n        edge_counts = {}\n        for i, j, k in faces:\n            edges = [tuple(sorted((i, j))), tuple(sorted((j, k))), tuple(sorted((k, i)))]\n            for edge in edges:\n                edge_counts[edge] = edge_counts.get(edge, 0) + 1\n            adj[i].update([j, k])\n            adj[j].update([i, k])\n            adj[k].update([i, j])\n\n        boundary_edges = {edge for edge, count in edge_counts.items() if count == 1}\n        boundary_vertices = set()\n        for i, j in boundary_edges:\n            boundary_vertices.add(i)\n            boundary_vertices.add(j)\n        \n        return adj, boundary_vertices\n\n    def process_case(vertices, faces_map):\n        \"\"\"\n        Processes a single test case: computes initial quality, performs smoothing,\n        computes final quality, and returns the difference.\n        \"\"\"\n        # Map faces to 0-based indices\n        faces = []\n        for face_tuple in faces_map:\n            faces.append(tuple(face_tuple))\n\n        num_vertices = len(vertices)\n        \n        # Calculate initial average quality\n        q_before = get_avg_quality(vertices, faces)\n\n        # Get adjacency list and boundary vertices\n        adj, boundary_vertices = get_mesh_info(num_vertices, faces)\n        \n        # Perform one smoothing sweep\n        new_vertices = np.copy(vertices)\n        interior_vertices = set(range(num_vertices)) - boundary_vertices\n\n        for i in interior_vertices:\n            p_i = vertices[i]\n            neighbors = list(adj[i])\n            \n            if not neighbors:\n                continue\n\n            # Calculate centroid of neighbors\n            neighbor_coords = np.array([vertices[j] for j in neighbors])\n            c_i = np.mean(neighbor_coords, axis=0)\n\n            # Project centroid onto the tangent plane at p_i (R=1)\n            # y_i = c_i - (<c_i - p_i, p_i>) * p_i\n            # y_i = c_i - (<c_i, p_i> - <p_i, p_i>) * p_i\n            # Since ||p_i||=1, <p_i,p_i>=1\n            y_i = c_i - (np.dot(c_i, p_i) - 1) * p_i\n            \n            # Project y_i back to the sphere\n            z_i = normalize(y_i)\n            new_vertices[i] = z_i\n\n        # Calculate final average quality\n        q_after = get_avg_quality(new_vertices, faces)\n\n        return q_after - q_before\n\n    # --- Test Case 1 ---\n    v0 = np.array([0.0, 0.0, 1.0])\n    v1 = normalize(np.array([1.0, 0.0, 0.2]))\n    v2 = np.array([-0.5, np.sqrt(3.0)/2.0, 0.0])\n    v3 = np.array([-0.5, -np.sqrt(3.0)/2.0, 0.0])\n    vertices1 = np.array([v0, v1, v2, v3])\n    faces1 = [(0, 1, 2), (0, 2, 3), (0, 3, 1)]\n    delta1 = process_case(vertices1, faces1)\n\n    # --- Test Case 2 ---\n    v1_tc2 = np.array([1.0, 0.0, 0.0])\n    v2_tc2 = np.array([-0.5, np.sqrt(3.0)/2.0, 0.0])\n    v3_tc2 = np.array([-0.5, -np.sqrt(3.0)/2.0, 0.0])\n    vertices2 = np.array([v1_tc2, v2_tc2, v3_tc2])\n    faces2 = [(0, 1, 2)]\n    delta2 = process_case(vertices2, faces2)\n\n    # --- Test Case 3 ---\n    vc = normalize(np.array([0.2, -0.1, 0.97]))\n    va = normalize(np.array([0.9, 0.0, 0.435]))\n    vb = normalize(np.array([0.0, 0.9, 0.435]))\n    vd = normalize(np.array([-0.9, 0.0, 0.435]))\n    ve = normalize(np.array([0.0, -0.9, 0.435]))\n    vertices3 = np.array([vc, va, vb, vd, ve])\n    # Mapping: c:0, a:1, b:2, d:3, e:4\n    faces3 = [(0, 1, 2), (0, 2, 3), (0, 3, 4), (0, 4, 1)]\n    delta3 = process_case(vertices3, faces3)\n    \n    results = [delta1, delta2, delta3]\n    formatted_results = [\"{:.6f}\".format(d) for d in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2412997"}]}