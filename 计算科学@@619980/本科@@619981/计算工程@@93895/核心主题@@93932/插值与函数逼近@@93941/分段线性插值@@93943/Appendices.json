{"hands_on_practices": [{"introduction": "为了巩固基础，我们从一个直接的计算练习开始。这个实践将直接对比分段线性插值和更平滑的三次样条插值。通过亲手计算同一个数据集在两种不同方法下的插值结果 [@problem_id:2164998]，你将直观地理解计算简易性与插值函数平滑度之间的权衡。", "problem": "一位工程师正在为一个细柔性杆的形状建模，该杆被约束穿过二维笛卡尔平面上的三个点：$P_0=(-1, 1)$、$P_1=(0, 0)$ 和 $P_2=(1, 1)$。提出了两种简单的模型来估计杆在其他水平位置 $x$ 处的垂直位置 $y$。\n\n模型A是分段线性插值，它用直线段连接指定的点。\n模型B是自然三次样条，它通过匹配内部点的一阶和二阶导数来确保曲线光滑，并且在端点处的二阶导数为零。\n\n计算由模型A和模型B预测的，当 $x=0.5$ 时杆的垂直位置。设这些值分别为 $y_A$ 和 $y_B$。请将您的答案以一对精确分数 $(y_A, y_B)$ 的形式呈现。", "solution": "我们将节点标记为 $x_{0}=-1$、$x_{1}=0$、$x_{2}=1$，对应的函数值为 $y_{0}=1$、$y_{1}=0$、$y_{2}=1$。\n\n模型A（分段线性插值）：对于 $x \\in [x_{1},x_{2}]$，经过 $(0,0)$ 和 $(1,1)$ 的直线的斜率为\n$$\nm=\\frac{y_{2}-y_{1}}{x_{2}-x_{1}}=\\frac{1-0}{1-0}=1,\n$$\n所以插值函数为\n$$\ny(x)=y_{1}+m(x-x_{1})=0+1\\cdot(x-0)=x.\n$$\n在 $x=\\frac{1}{2}$ 处求值得到\n$$\ny_{A}=y\\!\\left(\\frac{1}{2}\\right)=\\frac{1}{2}.\n$$\n\n模型B（自然三次样条）：设 $M_{i}=S''(x_{i})$。自然边界条件给出 $M_{0}=0$ 和 $M_{2}=0$。当 $h_{0}=x_{1}-x_{0}=1$ 且 $h_{1}=x_{2}-x_{1}=1$ 时，在内部节点 $i=1$ 处的三次样条方程为\n$$\nh_{0}M_{0}+2(h_{0}+h_{1})M_{1}+h_{1}M_{2}=6\\left(\\frac{y_{2}-y_{1}}{h_{1}}-\\frac{y_{1}-y_{0}}{h_{0}}\\right).\n$$\n代入数值，\n$$\n1\\cdot 0+2(1+1)M_{1}+1\\cdot 0=6\\left(\\frac{1-0}{1}-\\frac{0-1}{1}\\right)=6(1-(-1))=12,\n$$\n所以\n$$\n4M_{1}=12 \\quad \\Rightarrow \\quad M_{1}=3.\n$$\n在区间 $[x_{1},x_{2}]=[0,1]$ 上，样条函数为\n$$\nS(x)=\\frac{M_{1}}{6h_{1}}(x_{2}-x)^{3}+\\frac{M_{2}}{6h_{1}}(x-x_{1})^{3}+\\left(y_{1}-\\frac{M_{1}h_{1}^{2}}{6}\\right)\\frac{x_{2}-x}{h_{1}}+\\left(y_{2}-\\frac{M_{2}h_{1}^{2}}{6}\\right)\\frac{x-x_{1}}{h_{1}}.\n$$\n当 $h_{1}=1$，$M_{1}=3$，$M_{2}=0$，$y_{1}=0$ 且 $y_{2}=1$ 时，上式简化为\n$$\nS(x)=\\frac{3}{6}(1-x)^{3}+0+\\left(0-\\frac{3}{6}\\right)(1-x)+\\left(1-0\\right)x\n=\\frac{1}{2}(1-x)^{3}-\\frac{1}{2}(1-x)+x.\n$$\n展开并合并同类项，\n$$\nS(x)=\\frac{1}{2}-\\frac{3}{2}x+\\frac{3}{2}x^{2}-\\frac{1}{2}x^{3}-\\frac{1}{2}+\\frac{1}{2}x+x\n=\\frac{3}{2}x^{2}-\\frac{1}{2}x^{3}.\n$$\n在 $x=\\frac{1}{2}$ 处求值得到\n$$\ny_{B}=S\\!\\left(\\frac{1}{2}\\right)=\\frac{3}{2}\\left(\\frac{1}{2}\\right)^{2}-\\frac{1}{2}\\left(\\frac{1}{2}\\right)^{3}\n=\\frac{3}{2}\\cdot\\frac{1}{4}-\\frac{1}{2}\\cdot\\frac{1}{8}\n=\\frac{3}{8}-\\frac{1}{16}\n=\\frac{5}{16}.\n$$\n\n因此，所求的数值对为 $\\left(\\frac{1}{2},\\frac{5}{16}\\right)$。", "answer": "$$\\boxed{\\begin{pmatrix}\\frac{1}{2} & \\frac{5}{16}\\end{pmatrix}}$$", "id": "2164998"}, {"introduction": "现实世界中的数据和函数并非总是光滑连续的。这个实践将带你应对一个关键挑战：如何对包含已知跳跃不连续点的函数进行插值 [@problem_id:2423753]。通过设计并实现一个能够显式处理不连续点的插值方案，你将学会如何避免产生巨大的、不符合物理实际的插值误差，从而构建更稳健的数值模型。", "problem": "给定一个实值函数，其在点 $x=c$ 处存在一个已知的跳跃间断点。该函数由两个分支定义，\n$$\nf_L(x) = e^{-x/3} \\quad \\text{for } x < c, \\qquad f_R(x) = e^{-x/3} + J \\quad \\text{for } x \\ge c,\n$$\n其中跳跃幅度 $J$ 是一个正常数。我们关注的定义域是闭区间 $[a,b]$，其中 $a \\lt c \\lt b$。给定一个包含在 $[a,b]$ 中的严格递增的有限样本横坐标集合 $X=\\{x_0,x_1,\\dots,x_n\\}$，该集合不一定包含 $c$。对于每个 $x_i \\in X$，函数值从相应的分支获取：如果 $x_i \\lt c$，则为 $f_L(x_i)$；如果 $x_i \\gt c$，则为 $f_R(x_i)$。$x=c$ 处的值不包含在 $X$ 中。\n\n设计一个数学上良定义的分段线性插值方案，该方案在间断点位置 $x=c$ 强制设置一个显式节点，并防止跨越跳跃点进行插值。插值必须按如下方式定义。\n\n- 构建左侧节点集 $X_L = \\{x \\in X \\mid x \\lt c\\} \\cup \\{c\\}$ 及其对应的左侧值 $Y_L = \\{f_L(x) \\text{ for } x \\in X \\text{ with } x \\lt c\\} \\cup \\{f_L(c)\\}$。\n\n- 构建右侧节点集 $X_R = \\{c\\} \\cup \\{x \\in X \\mid x \\gt c\\}$ 及其对应的右侧值 $Y_R = \\{f_R(c)\\} \\cup \\{f_R(x) \\text{ for } x \\in X \\text{ with } x \\gt c\\}$。\n\n- 通过在每一侧进行线性插值来定义插值函数 $I(x)$，仅使用该侧内部的节点：\n  - 对于 $x \\lt c$，$I(x)$ 是在 $[x_k,x_{k+1}] \\subseteq [a,c]$ 上的唯一线性插值，其中 $x_k,x_{k+1} \\in X_L$，满足 $I(x_k)=Y_L(x_k)$ 和 $I(x_{k+1})=Y_L(x_{k+1})$。\n  - 对于 $x \\gt c$，$I(x)$ 是在 $[x_k,x_{k+1}] \\subseteq [c,b]$ 上的唯一线性插值，其中 $x_k,x_{k+1} \\in X_R$，满足 $I(x_k)=Y_R(x_k)$ 和 $I(x_{k+1})=Y_R(x_{k+1})$。\n  - 在 $x=c$ 处，强制右连续性：$I(c)=f_R(c)$。\n\n所有插值都必须限制在完全位于 $c$ 一侧的区间内；任何插值区间都不得跨越 $c$。如果查询点 $x$ 与一个节点重合，则返回相关侧的精确节点值。\n\n使用以下具体参数值来定义一个测试套件：\n- 定义域端点：$a=0$, $b=6$。\n- 跳跃位置和幅度：$c=2.5$, $J=1.2$。\n- 样本横坐标：$X=\\{0.0, 1.7, 2.2, 3.1, 4.4, 6.0\\}$。\n- 查询点：$Q=\\{0.0, 1.9, 2.45, 2.5, 2.7, 3.5, 6.0\\}$。\n\n对于每个 $x_q \\in Q$，根据上述定义计算 $I(x_q)$。需要报告的最终输出是值集合 $\\{I(x_q) \\mid x_q \\in Q\\}$，其顺序与 $Q$ 相同，每个值四舍五入到小数点后六位。不涉及角度。不涉及物理单位。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，形如“[r_a,r_b,r_c]”的列表）。", "solution": "任务是构建一个分段线性插值函数，该函数通过在 $x=c$ 处显式引入一个节点，并防止任何插值区间跨越 $x=c$ 来处理已知的跳跃间断点。该构建可以从第一性原理出发，通过定义两个独立的线性插值函数来完成：一个在 $[a,c]$ 上使用左极限值，另一个在 $[c,b]$ 上使用右极限值，并结合 $x=c$ 处的右连续性约定。\n\n首先，该函数由其两个分支指定，\n$$\nf_L(x) = e^{-x/3} \\quad \\text{for } x < c, \\qquad f_R(x) = e^{-x/3} + J \\quad \\text{for } x \\ge c,\n$$\n其中 $J \\gt 0$。$x=c$ 处的跳跃等于 $J$，因为\n$$\n\\lim_{x \\to c^-} f(x) = f_L(c) = e^{-c/3}, \\qquad \\lim_{x \\to c^+} f(x) = f_R(c) = e^{-c/3} + J.\n$$\n\n给定一个严格递增的集合 $X=\\{x_0,x_1,\\dots,x_n\\}$，满足 $a \\le x_0 \\lt \\dots \\lt x_n \\le b$ 且 $c \\not\\in X$，通过插入 $c$ 来定义两个增广节点集：\n- 左侧节点 $X_L = \\{x \\in X \\mid x \\lt c\\} \\cup \\{c\\}$ 及其值 $Y_L = \\{f_L(x) \\mid x \\in X, x \\lt c\\} \\cup \\{f_L(c)\\}$。\n- 右侧节点 $X_R = \\{c\\} \\cup \\{x \\in X \\mid x \\gt c\\}$ 及其值 $Y_R = \\{f_R(c)\\} \\cup \\{f_R(x) \\mid x \\in X, x \\gt c\\}$。\n\n在每一侧，线性插值函数在连续节点之间的每个子区间上定义。对于一侧的任何区间 $[x_k,x_{k+1}]$，当查询点 $x$ 满足 $x_k \\le x \\le x_{k+1}$ 时，线性插值公式为\n$$\nI(x) = Y(x_k) + \\left( \\frac{Y(x_{k+1}) - Y(x_k)}{x_{k+1} - x_k} \\right) (x - x_k),\n$$\n其中 $Y$ 表示左侧的 $Y_L$ 或右侧的 $Y_R$，而 $\\{x_k,x_{k+1}\\}$ 分别是 $X_L$ 或 $X_R$ 中的连续节点。如果 $x$ 与一个节点重合，插值函数返回相应的节点值。在 $x=c$ 处，通过设置以下值来强制右连续性\n$$\nI(c) = f_R(c) = e^{-c/3} + J.\n$$\n\n对于具体的测试套件，使用 $a=0$, $b=6$, $c=2.5$, $J=1.2$, $X=\\{0.0, 1.7, 2.2, 3.1, 4.4, 6.0\\}$，以及 $Q=\\{0.0, 1.9, 2.45, 2.5, 2.7, 3.5, 6.0\\}$。左侧节点集为\n$$\nX_L = \\{0.0, 1.7, 2.2, 2.5\\},\n$$\n其值为\n$$\nY_L = \\left\\{ e^{-0.0/3},\\, e^{-1.7/3},\\, e^{-2.2/3},\\, e^{-2.5/3} \\right\\}。\n$$\n右侧节点集为\n$$\nX_R = \\{2.5, 3.1, 4.4, 6.0\\},\n$$\n其值为\n$$\nY_R = \\left\\{ e^{-2.5/3} + J,\\, e^{-3.1/3} + J,\\, e^{-4.4/3} + J,\\, e^{-6.0/3} + J \\right\\}。\n$$\n\n对于每个查询点 $x_q \\in Q$，通过将 $x_q$ 与 $c$ 比较来选择相应的一侧。如果 $x_q \\lt c$，在 $X_L$ 中找到包含 $x_q$ 的相邻节点对，并使用 $Y_L$ 应用上述线性公式。如果 $x_q \\gt c$，在 $X_R$ 中找到包含 $x_q$ 的相邻节点对，并使用 $Y_R$ 应用相同的线性公式。如果 $x_q = c$，则设置 $I(x_q)=e^{-c/3} + J$。这种构造方法保证了没有插值段会跨越 $x=c$，在间断点处显式地强制设置了一个节点，并生成了一个在 $x=c$ 处右连续的插值函数。\n\n最后，将每个计算出的值 $I(x_q)$ 四舍五入到小数点后六位，并以指定的单行列表格式输出结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef f_left(x):\n    return np.exp(-x / 3.0)\n\ndef f_right(x, J):\n    return np.exp(-x / 3.0) + J\n\ndef linear_interp_sorted(x_nodes, y_nodes, xq):\n    \"\"\"\n    Perform linear interpolation on sorted nodes (strictly increasing).\n    Returns the exact nodal value if xq equals a node (within tolerance).\n    Assumes xq lies within [x_nodes[0], x_nodes[-1]].\n    \"\"\"\n    # Tolerance for equality checks to handle floating point comparisons\n    tol = 1e-12\n\n    # Exact node match\n    for xi, yi in zip(x_nodes, y_nodes):\n        if abs(xq - xi) <= tol:\n            return float(yi)\n\n    # Find interval [x_k, x_{k+1}] containing xq\n    # searchsorted returns insertion index; we want the left index\n    idx = np.searchsorted(x_nodes, xq, side='right') - 1\n    if idx < 0:\n        idx = 0\n    if idx >= len(x_nodes) - 1:\n        idx = len(x_nodes) - 2\n\n    x0 = x_nodes[idx]\n    x1 = x_nodes[idx + 1]\n    y0 = y_nodes[idx]\n    y1 = y_nodes[idx + 1]\n\n    # Linear interpolation formula\n    t = (xq - x0) / (x1 - x0)\n    return float(y0 + t * (y1 - y0))\n\ndef solve():\n    # Parameters as specified in the problem\n    a = 0.0\n    b = 6.0\n    c = 2.5\n    J = 1.2\n\n    # Base sample abscissae (do not include c)\n    X_base = np.array([0.0, 1.7, 2.2, 3.1, 4.4, 6.0], dtype=float)\n\n    # Construct left nodes and values (including c with left value)\n    X_left = np.array([x for x in X_base if x < c] + [c], dtype=float)\n    X_left.sort()\n    Y_left = np.array([f_left(x) for x in X_left], dtype=float)\n\n    # Construct right nodes and values (including c with right value)\n    X_right = np.array([c] + [x for x in X_base if x > c], dtype=float)\n    X_right.sort()\n    Y_right = np.empty_like(X_right)\n    for i, x in enumerate(X_right):\n        if abs(x - c) <= 1e-12:\n            Y_right[i] = f_right(c, J)\n        else:\n            Y_right[i] = f_right(x, J)\n\n    # Query points Q\n    Q = np.array([0.0, 1.9, 2.45, 2.5, 2.7, 3.5, 6.0], dtype=float)\n\n    results = []\n    for xq in Q:\n        # Right-continuous convention at x=c\n        if xq > c:\n            val = linear_interp_sorted(X_right, Y_right, xq)\n        elif xq < c:\n            val = linear_interp_sorted(X_left, Y_left, xq)\n        else:\n            # xq == c -> right-continuous value\n            val = f_right(c, J)\n        # Round to six decimal places for output formatting\n        results.append(val)\n\n    # Format with exactly six digits after the decimal point, no spaces\n    formatted = \"[\" + \",\".join(f\"{v:.6f}\" for v in results) + \"]\"\n    print(formatted)\n\nsolve()\n```", "id": "2423753"}, {"introduction": "当函数的复杂性在不同区域变化时，为什么还要使用均匀网格呢？这项高级实践将指导你构建一个“智能”的插值算法 [@problem_id:2423835]。该算法能自动在函数“弯曲”的区域增加采样点，而在函数接近直线的部分减少采样点，其核心思想是基于我们之前讨论的插值误差与二阶导数 $\\lvert f^{\\prime\\prime}(x)\\rvert$ 的关系。这个练习将向你介绍强大的自适应网格剖分概念，它是创建精确、高效计算模拟的基石技术之一。", "problem": "给定一个闭区间上的一族标量函数，要求你构建一个用于分段线性插值的自适应网格生成器。该生成器应在二阶导数 $\\lvert f^{\\prime\\prime}(x)\\rvert$ 的可计算估计值较大的地方进行网格加密。你必须从基本定义和经过充分检验的事实出发，并且必须实现一个完全确定的算法，该算法能够在一个固定的测试套件上进行验证。三角函数中使用的所有角度都应以弧度为单位。本问题不涉及任何物理单位。\n\n你的程序必须实现以下要求。\n\n- 输入和初始化：\n  - 一个函数 $f:[a,b]\\to\\mathbb{R}$，一个区间 $[a,b]$（其中 $a<b$），一个初始网格点数 $m_{0}\\in\\mathbb{N}$（其中 $m_{0}\\geq 3$），一个非负容差 $\\mathrm{tol}>0$，以及一个允许的最大网格点数 $N_{\\max}\\in\\mathbb{N}$（其中 $N_{\\max}\\geq m_{0}$）。\n  - 将一个由 $m_{0}$ 个在 $[a,b]$ 上的等距点组成的严格递增的节点网格 $a=x_{0}<x_{1}<\\dots<x_{m_{0}-1}=b$ 初始化。对于每个节点 $x_{i}$，存储 $y_{i}=f(x_{i})$。\n\n- 非均匀网格上的局部二阶导数估计器：\n  - 对于当前网格有 $n$ 个节点时的每一组连续三个节点 $(x_{k-1},x_{k},x_{k+1})$（其中 $k\\in\\{1,2,\\dots,n-2\\}$），将 $D2_{k}$ 定义为对三个点 $(x_{k-1},y_{k-1})$、$(x_{k},y_{k})$、$(x_{k+1},y_{k+1})$ 进行插值的唯一二次多项式在 $x_{k}$ 处的二阶导数。\n  - 对于每个长度为 $h_{i}=x_{i+1}-x_{i}$ 的区间 $I_{i}=[x_{i},x_{i+1}]$，通过以下方式定义一个标量曲率指标 $s_{i}$：\n    - $s_{0}=\\lvert D2_{1}\\rvert$，\n    - 对于 $i\\in\\{1,2,\\dots,n-3\\}$，$s_{i}=\\max\\{\\lvert D2_{i}\\rvert,\\lvert D2_{i+1}\\rvert\\}$，\n    - $s_{n-2}=\\lvert D2_{n-2}\\rvert$。\n  - 定义区间误差指标 $e_{i}=s_{i}\\,h_{i}^{2}$。\n\n- 贪婪加密规则和停止准则：\n  - 当最大区间指标满足 $\\max_{i} e_{i}>\\mathrm{tol}$ 并且节点数 $n<N_{\\max}$ 时，每次迭代按如下方式加密单个区间：\n    - 选择使 $e_{i}$ 达到最大值的最小索引 $i^{\\star}$。\n    - 将中点 $m=(x_{i^{\\star}}+x_{i^{\\star}+1})/2$ 作为新节点插入，计算 $f(m)$，并保持网格及其关联函数值有序。\n  - 当 $\\max_{i} e_{i}\\leq \\mathrm{tol}$ 或网格达到 $N_{\\max}$ 个节点时停止。\n\n- 最终质量评估：\n  - 令 $L(x)$ 表示通过最终网格节点的分段线性插值函数。通过在 $[a,b]$ 上的 $10001$ 个等距点 $\\{x^{\\mathrm{test}}_{j}\\}_{j=0}^{10000}$ 上对 $L(x)$ 和 $f(x)$ 进行采样，来近似计算插值误差在 $[a,b]$ 上的上确界范数，并计算 $E=\\max_{0\\leq j\\leq 10000}\\lvert f(x^{\\mathrm{test}}_{j})-L(x^{\\mathrm{test}}_{j})\\rvert$。\n\n你的程序必须精确实现上述算法，并在以下测试套件上运行。对于每个测试用例，输出最终的节点数和测得的最大绝对误差 $E$。\n\n- 测试套件（角度以弧度为单位）：\n  - 测试 1：$f(x)=\\sin(6x)$，区间为 $[0,1]$，$m_{0}=5$，$\\mathrm{tol}=0.02$， $N_{\\max}=200$。\n  - 测试 2：$f(x)=2x+3$，区间为 $[0,1]$，$m_{0}=3$，$\\mathrm{tol}=10^{-6}$，$N_{\\max}=50$。\n  - 测试 3：$f(x)=\\arctan\\!\\big(50(x-0.5)\\big)$，区间为 $[0,1]$，$m_{0}=5$，$\\mathrm{tol}=0.005$，$N_{\\max}=200$。\n  - 测试 4：$f(x)=\\exp(x)$，区间为 $[0,5]$，$m_{0}=5$，$\\mathrm{tol}=0.5$，$N_{\\max}=300$。\n  - 测试 5：$f(x)=\\sin(x)$，区间为 $[0,0.01]$，$m_{0}=3$，$\\mathrm{tol}=10^{-4}$，$N_{\\max}=50$。\n\n最终输出格式：\n\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表。每个测试用例的结果本身必须是一个形如 $[n,E]$ 的双元素列表，其中 $n$ 是最终的节点数（一个整数），$E$ 是最大绝对误差（一个浮点数）。例如，整体格式必须类似于 $[[n_{1},E_{1}],[n_{2},E_{2}],\\dots]$，不插入任何额外的空格。", "solution": "问题陈述经过严格验证，被认定为具有科学依据、适定、客观且完整。它描述了一种用于分段线性插值的标准自适应网格加密算法。该问题是有效的。下面提供了一个完整的解决方案。\n\n自适应网格生成背后的基本原理是高效地分布有限数量的网格点，将被插值函数变化迅速的区域的网格点分布得密集，而在函数平滑的区域则分布得稀疏。对于分段线性插值，区间 $[x_i, x_{i+1}]$ 上的插值误差由函数二阶导数的绝对值 $\\lvert f^{\\prime\\prime}(x)\\rvert$ 和区间长度 $h_i = x_{i+1} - x_i$ 控制。标准的误差界由下式给出：\n$$ \\max_{x \\in [x_i, x_{i+1}]} \\lvert f(x) - L(x) \\rvert \\le \\frac{h_i^2}{8} \\max_{z \\in [x_i, x_{i+1}]} \\lvert f^{\\prime\\prime}(z) \\rvert $$\n其中 $L(x)$ 是该区间上的线性插值函数。这启发我们为每个区间 $I_i = [x_i, x_{i+1}]$ 构建一个形式为 $e_i = s_i h_i^2$ 的误差指标，其中 $s_i$ 是在该区间上或其附近的二阶导数绝对值的估计。\n\n该算法按以下步骤进行：\n1.  在区间 $[a, b]$ 上初始化一个由 $m_0$ 个点组成的粗糙均匀网格。\n2.  基于局部误差指标迭代地加密网格。在每一步中，将具有最大误差指标的区间进行二等分。\n3.  当最大的误差指标低于指定的容差 $\\mathrm{tol}$，或网格点总数达到最大限制 $N_{\\max}$ 时，过程终止。\n\n该算法的核心是误差指标 $e_i$ 的计算。这需要对二阶导数进行数值估计，因为我们不假定 $f^{\\prime\\prime}(x)$ 是可解析获得的。问题指定了一种基于局部二次插值的方法。\n\n对于每一组连续的三个节点 $(x_{k-1}, y_{k-1})$、$(x_k, y_k)$、$(x_{k+1}, y_{k+1})$，我们构建一个穿过这些点的唯一二次多项式 $P_k(x)$。该多项式的二阶导数 $P_k^{\\prime\\prime}(x)$ 是一个常数，并作为 $f^{\\prime\\prime}(x_k)$ 的一个近似。这个近似值记为 $D2_k$。\n$D2_k$ 的公式可以从插值多项式的牛顿形式导出。二阶差商由下式给出：\n$$ f[x_{k-1}, x_k, x_{k+1}] = \\frac{f[x_k, x_{k+1}] - f[x_{k-1}, x_k]}{x_{k+1} - x_{k-1}} $$\n其中 $f[x_i, x_j] = (y_j - y_i) / (x_j - x_i)$。插值二次多项式的二阶导数是 $P_k^{\\prime\\prime}(x) = 2 f[x_{k-1}, x_k, x_{k+1}]$。令 $h_{k-1} = x_k - x_{k-1}$ 和 $h_k = x_{k+1} - x_k$。$D2_k$ 的公式变为：\n$$ D2_k = 2 \\frac{ \\frac{y_{k+1} - y_k}{h_k} - \\frac{y_k - y_{k-1}}{h_{k-1}} }{ x_{k+1} - x_{k-1} } = \\frac{2}{h_k + h_{k-1}} \\left( \\frac{y_{k+1} - y_k}{h_k} - \\frac{y_k - y_{k-1}}{h_{k-1}} \\right) $$\n对于一个有 $n$ 个点的网格，该公式对每个内部网格点 $x_k$（其中 $k \\in \\{1, 2, \\dots, n-2\\}$）都有定义。\n\n在计算出 $D2_k$ 的值后，问题为每个区间 $I_i=[x_i,x_{i+1}]$ 定义了一个标量曲率指标 $s_i$。该指标聚合了区间端点处（或对于边界区间，则是在最近的内部点处）的二阶导数信息。对于一个有 $n$ 个节点（即 $n-1$ 个区间）的网格，定义如下：\n-   对于第一个区间 $I_0$：$s_0 = \\lvert D2_1 \\rvert$\n-   对于内部区间 $I_i$，$i \\in \\{1, \\dots, n-3\\}$：$s_i = \\max\\{\\lvert D2_i \\rvert, \\lvert D2_{i+1} \\rvert\\}$\n-   对于最后一个区间 $I_{n-2}$：$s_{n-2} = \\lvert D2_{n-2} \\rvert$\n\n于是区间误差指标为 $e_i = s_i h_i^2$。\n\n加密策略是一种贪婪算法。在每次迭代中，我们识别出具有最大误差指标的区间 $I_{i^{\\star}}$，$e_{i^{\\star}} = \\max_j e_j$。如果有多个区间共享此最大值，则选择索引最小的那个 $i^{\\star}$。通过将其中心点 $m = (x_{i^{\\star}} + x_{i^{\\star}+1})/2$ 作为新节点插入，来二等分此区间。计算函数值 $f(m)$，并更新网格数据数组。\n\n这个迭代过程持续进行，直到满足停止准则：$\\max_i e_i \\le \\mathrm{tol}$ 或节点数 $n = N_{\\max}$。\n\n最后，为了评估最终网格的质量，需要对插值误差的上确界范数 $\\lVert f-L \\rVert_{\\infty}$ 进行近似。这是通过在 $[a,b]$ 上均匀分布的大量测试点 $\\{x^{\\mathrm{test}}_j\\}_{j=0}^{10000}$ 上对真实函数 $f(x)$ 和最终的分段线性插值函数 $L(x)$ 进行采样来完成的。最大绝对差被计算为误差估计 $E$：\n$$ E = \\max_{0 \\le j \\le 10000} \\lvert f(x^{\\mathrm{test}}_j) - L(x^{\\mathrm{test}}_j) \\rvert $$\n每个测试用例的最终输出包括最终节点数 $n$ 和这个估计误差 $E$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_adaptive_interpolation(f, a, b, m0, tol, N_max):\n    \"\"\"\n    Constructs an adaptive grid for piecewise linear interpolation.\n\n    Args:\n        f (callable): The function to interpolate, f(x).\n        a (float): The start of the interval.\n        b (float): The end of the interval.\n        m0 (int): The initial number of grid points.\n        tol (float): The error tolerance for stopping.\n        N_max (int): The maximum number of grid points.\n\n    Returns:\n        list: A list containing the final number of nodes and the maximum error, [n, E].\n    \"\"\"\n    # 1. Initialization\n    # Using lists for efficient insertion of new nodes\n    x_nodes = np.linspace(a, b, m0).tolist()\n    y_nodes = [f(x) for x in x_nodes]\n\n    # 2. Refinement Loop\n    while len(x_nodes) < N_max:\n        n = len(x_nodes)\n        \n        # Guard against grids too small to compute second derivatives\n        if n < 3:\n            break\n\n        # Compute D2_k values for all interior nodes\n        D2_values = []\n        for k in range(1, n - 1):\n            x_km1, x_k, x_kp1 = x_nodes[k-1], x_nodes[k], x_nodes[k+1]\n            y_km1, y_k, y_kp1 = y_nodes[k-1], y_nodes[k], y_nodes[k+1]\n            \n            h_km1 = x_k - x_km1\n            h_k = x_kp1 - x_k\n            \n            # This should not happen with a strictly increasing grid\n            if h_km1 <= 0 or h_k <= 0 or (h_k + h_km1) == 0:\n                D2_k = 0.0\n            else:\n                term1 = (y_kp1 - y_k) / h_k\n                term2 = (y_k - y_km1) / h_km1\n                D2_k = 2.0 * (term1 - term2) / (h_k + h_km1)\n            D2_values.append(D2_k)\n\n        # Compute error indicators e_i for each interval\n        errors = []\n        num_intervals = n - 1\n        for i in range(num_intervals):\n            h_i = x_nodes[i+1] - x_nodes[i]\n            \n            # Compute curvature indicator s_i\n            if num_intervals == 1: # Only two points, D2 cannot be computed.\n                # This case is avoided by m0>=3, so n-2 >= 1, D2_values is non-empty.\n                # If n=3, num_intervals=2. Then D2_values has 1 element.\n                s_i = abs(D2_values[0])\n            elif i == 0: # First interval\n                s_i = abs(D2_values[0]) # |D2_1|\n            elif i == num_intervals - 1: # Last interval\n                s_i = abs(D2_values[-1]) # |D2_{n-2}|\n            else: # Interior intervals\n                # s_i = max(|D2_i|, |D2_{i+1}|)\n                # D2_values[k-1] corresponds to D2_k\n                s_i = max(abs(D2_values[i-1]), abs(D2_values[i]))\n            \n            e_i = s_i * h_i**2\n            errors.append(e_i)\n        \n        # Check stopping criterion\n        max_error_indicator = max(errors)\n        if max_error_indicator <= tol:\n            break\n\n        # Refine grid: find smallest index i_star with max error and insert midpoint\n        i_star = errors.index(max_error_indicator)\n        \n        m = (x_nodes[i_star] + x_nodes[i_star+1]) / 2.0\n        fm = f(m)\n        \n        x_nodes.insert(i_star + 1, m)\n        y_nodes.insert(i_star + 1, fm)\n\n    # 3. Final Quality Assessment\n    n_final = len(x_nodes)\n    x_test = np.linspace(a, b, 10001)\n    y_true = np.array([f(x) for x in x_test])\n    \n    x_nodes_np = np.array(x_nodes)\n    y_nodes_np = np.array(y_nodes)\n    y_interp = np.interp(x_test, x_nodes_np, y_nodes_np)\n    \n    E = np.max(np.abs(y_true - y_interp))\n    \n    return [n_final, E]\n    \n\ndef solve():\n    \"\"\"\n    Runs the adaptive interpolation algorithm on a predefined test suite.\n    \"\"\"\n    # Define test functions\n    f1 = lambda x: np.sin(6 * x)\n    f2 = lambda x: 2 * x + 3\n    f3 = lambda x: np.arctan(50 * (x - 0.5))\n    f4 = lambda x: np.exp(x)\n    f5 = lambda x: np.sin(x)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (f1, 0.0, 1.0, 5, 0.02, 200),\n        (f2, 0.0, 1.0, 3, 1e-6, 50),\n        (f3, 0.0, 1.0, 5, 0.005, 200),\n        (f4, 0.0, 5.0, 5, 0.5, 300),\n        (f5, 0.0, 0.01, 3, 1e-4, 50)\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack case parameters and call the solver\n        f, a, b, m0, tol, N_max = case\n        result = run_adaptive_interpolation(f, a, b, m0, tol, N_max)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'[{n},{E}]' for n, E in results])}]\")\n\nsolve()\n\n```", "id": "2423835"}]}