{"hands_on_practices": [{"introduction": "理解分段多项式的第一步是掌握其基本构件——基函数。本练习将引导你使用经典的 Cox-de Boor 递推公式，亲手构造一个 B 样条基函数。通过这个过程，你将深刻体会到局部支撑性和连续性等关键属性是如何从节点向量的定义中产生的。[@problem_id:2424168]", "problem": "在计算工程中，基样条（B样条）提供了具有紧支集和可控连续性的稳健分段多项式逼近。考虑开放、非均匀节点向量 $t = \\{0, 0, 0, 1, 3, 3, 4, 4, 4\\}$ 和二次次数 $p = 2$。从零次B样条基函数的基本定义和Cox–de Boor递推公式出发，手动推导与此节点向量相关的二次B样条基函数 $N_{3,2}(x)$ 的显式分段多项式表达式。使用标准约定：如果递推式中的分母为零，则相应项取为零；特征区间取为 $[a,b)$ 形式的半开区间。将最终结果表示为关于 $x$ 的单个分段定义解析表达式。不需要数值舍入，也不涉及单位。最终答案必须仅为闭式表达式。", "solution": "在尝试进行任何解算之前，所提出的问题须经过严格验证。\n\n### 步骤1：提取给定条件\n-   **领域**：计算工程\n-   **主题**：分段多项式逼近，B样条\n-   **节点向量**：$t = \\{0, 0, 0, 1, 3, 3, 4, 4, 4\\}$\n-   **次数**：$p = 2$（二次）\n-   **目标基函数**：$N_{3,2}(x)$\n-   **方法**：Cox–de Boor递推法，从零次基函数开始。\n-   **约定1**：若递推公式中分母为零，则相应项为零。\n-   **约定2**：特征区间为半开区间 $[a,b)$。\n\n### 步骤2：使用提取的给定条件进行验证\n1.  **科学依据**：该问题是B样条理论中的一个标准基础练习，B样条是数值分析和计算机辅助几何设计的核心课题。所有概念，包括节点向量、次数和Cox-de Boor递推法，都已是公认的。该问题具有科学合理性。\n2.  **适定性**：问题描述精确。节点向量、多项式次数和目标基函数均已明确给出。处理零分母和区间形式的约定消除了计算中的任何潜在歧义。存在一个唯一、稳定且有意义的分段多项式解，并且可以推导出来。\n3.  **客观性**：语言清晰、精确且完全客观。它陈述了一个数学任务，不含主观或推测性内容。\n\n### 步骤3：结论与行动\n问题被判定为**有效**。它自洽、有科学依据且适定。将进行求解。\n\n### 推导过程\nB样条基函数 $N_{i,p}(x)$ 的推导遵循Cox-de Boor递推公式。我们从零次基函数 $N_{i,0}(x)$ 的定义开始：\n$$\nN_{i,0}(x) =\n\\begin{cases}\n1 & \\text{if } t_i \\le x < t_{i+1} \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\n对于次数 $p > 0$，更高次的基函数通过递推方式定义：\n$$\nN_{i,p}(x) = \\frac{x - t_i}{t_{i+p} - t_i} N_{i, p-1}(x) + \\frac{t_{i+p+1} - x}{t_{i+p+1} - t_{i+1}} N_{i+1, p-1}(x)\n$$\n所给定的约定指出，任何分母为零的项都取为零。\n\n问题指定的节点向量 $t = \\{t_0, t_1, \\dots, t_8\\}$ 为：\n$$\nt = \\{0, 0, 0, 1, 3, 3, 4, 4, 4\\}\n$$\n次数为 $p=2$。我们需要求出基函数 $N_{3,2}(x)$ 的表达式。\n\n首先，我们确定 $N_{3,2}(x)$ 的支集。B样条基函数 $N_{i,p}(x)$ 的支集是区间 $[t_i, t_{i+p+1})$。对于 $N_{3,2}(x)$，这对应于区间 $[t_3, t_{3+2+1}) = [t_3, t_6)$。从节点向量可知，$t_3=1$ 且 $t_6=4$。因此，$N_{3,2}(x)$ 仅在 $x \\in [1, 4)$ 上非零。\n\n我们应用递推公式来求解 $N_{3,2}(x)$：\n$$\nN_{3,2}(x) = \\frac{x - t_3}{t_{3+2} - t_3} N_{3,1}(x) + \\frac{t_{3+2+1} - x}{t_{3+2+1} - t_{3+1}} N_{4,1}(x) = \\frac{x - t_3}{t_5 - t_3} N_{3,1}(x) + \\frac{t_6 - x}{t_6 - t_4} N_{4,1}(x)\n$$\n代入节点值 $t_3=1$、$t_4=3$、$t_5=3$ 和 $t_6=4$：\n$$\nN_{3,2}(x) = \\frac{x - 1}{3 - 1} N_{3,1}(x) + \\frac{4 - x}{4 - 3} N_{4,1}(x) = \\frac{x - 1}{2} N_{3,1}(x) + (4 - x) N_{4,1}(x)\n$$\n接下来，我们必须求出一次基函数 $N_{3,1}(x)$ 和 $N_{4,1}(x)$ 的表达式。\n\n对于 $N_{3,1}(x)$，递推式为：\n$$\nN_{3,1}(x) = \\frac{x - t_3}{t_{3+1} - t_3} N_{3,0}(x) + \\frac{t_{3+1+1} - x}{t_{3+1+1} - t_{3+1}} N_{4,0}(x) = \\frac{x - t_3}{t_4 - t_3} N_{3,0}(x) + \\frac{t_5 - x}{t_5 - t_4} N_{4,0}(x)\n$$\n代入节点值 $t_3=1$、$t_4=3$、$t_5=3$：\n$$\nN_{3,1}(x) = \\frac{x - 1}{3 - 1} N_{3,0}(x) + \\frac{3 - x}{3 - 3} N_{4,0}(x)\n$$\n分母 $t_5 - t_4$ 为零，所以第二项为零。\n$$\nN_{3,1}(x) = \\frac{x - 1}{2} N_{3,0}(x)\n$$\n$N_{3,0}(x)$ 的支集是 $[t_3, t_4) = [1, 3)$，在此区间上其值为 $1$。因此，$N_{3,1}(x)$ 为：\n$$\nN_{3,1}(x) = \\begin{cases} \\frac{x-1}{2} & 1 \\le x < 3 \\\\ 0 & \\text{otherwise} \\end{cases}\n$$\n对于 $N_{4,1}(x)$，递推式为：\n$$\nN_{4,1}(x) = \\frac{x - t_4}{t_{4+1} - t_4} N_{4,0}(x) + \\frac{t_{4+1+1} - x}{t_{4+1+1} - t_{4+1}} N_{5,0}(x) = \\frac{x - t_4}{t_5 - t_4} N_{4,0}(x) + \\frac{t_6 - x}{t_6 - t_5} N_{5,0}(x)\n$$\n代入节点值 $t_4=3$、$t_5=3$、$t_6=4$：\n$$\nN_{4,1}(x) = \\frac{x - 3}{3 - 3} N_{4,0}(x) + \\frac{4 - x}{4 - 3} N_{5,0}(x)\n$$\n分母 $t_5 - t_4$ 为零，所以第一项为零。\n$$\nN_{4,1}(x) = \\frac{4 - x}{1} N_{5,0}(x) = (4 - x) N_{5,0}(x)\n$$\n$N_{5,0}(x)$ 的支集是 $[t_5, t_6) = [3, 4)$，在此区间上其值为 $1$。因此，$N_{4,1}(x)$ 为：\n$$\nN_{4,1}(x) = \\begin{cases} 4 - x & 3 \\le x < 4 \\\\ 0 & \\text{otherwise} \\end{cases}\n$$\n现在，我们将 $N_{3,1}(x)$ 和 $N_{4,1}(x)$ 的这些分段表达式代入 $N_{3,2}(x)$ 的方程中。我们考虑其支集 $[1, 4)$ 上的区间。\n\n情况1：$x \\in [1, 3)$\n在此区间内，$N_{3,1}(x) = \\frac{x-1}{2}$ 且 $N_{4,1}(x) = 0$。\n$$\nN_{3,2}(x) = \\frac{x - 1}{2} \\left( \\frac{x-1}{2} \\right) + (4 - x)(0) = \\frac{(x-1)^2}{4}\n$$\n\n情况2：$x \\in [3, 4)$\n在此区间内，$N_{3,1}(x) = 0$ 且 $N_{4,1}(x) = 4-x$。\n$$\nN_{3,2}(x) = \\frac{x-1}{2}(0) + (4 - x)(4 - x) = (4-x)^2\n$$\n\n综合这些结果，我们得到 $N_{3,2}(x)$ 的完整分段定义表达式：\n$$\nN_{3,2}(x) =\n\\begin{cases}\n\\frac{(x-1)^2}{4} & \\text{if } 1 \\leq x < 3 \\\\\n(4-x)^2 & \\text{if } 3 \\leq x < 4 \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\n该函数的支集为 $[1,4)$。在节点 $x=3$ 处，其重复度 $k=2$，连续性为 $C^{p-k} = C^{2-2} = C^0$。我们验证如下：\n$\\lim_{x \\to 3^-} N_{3,2}(x) = \\frac{(3-1)^2}{4} = 1$。\n$N_{3,2}(3) = (4-3)^2 = 1$。\n函数是连续的，符合要求。", "answer": "$$\n\\boxed{\nN_{3,2}(x) = \n\\begin{cases}\n\\frac{(x-1)^{2}}{4} & 1 \\le x < 3 \\\\\n(4-x)^{2} & 3 \\le x < 4 \\\\\n0 & \\text{otherwise}\n\\end{cases}\n}\n$$", "id": "2424168"}, {"introduction": "掌握了基函数后，我们就可以构建完整的插值曲线来拟合数据，这是工程中的一项核心任务。本练习将带你处理一个典型场景：构造一条通过一组离散数据点的光滑“非扭结”（not-a-knot）三次样条曲线 $S(x)$。你需要从第一性原理出发，通过建立并求解保证各阶导数（$S(x)$, $S'(x)$, $S''(x)$）连续性的方程组来完成整个过程，这将锻炼你解决计算问题的核心能力。[@problem_id:2424185]", "problem": "在某个计算工程工作流中，您必须通过一个分段多项式对离散的仿真输出进行插值，并使人为振荡最小化。给定五个严格递增的节点 $x_0, x_1, x_2, x_3, x_4$ 及对应的标量数据值 $y_0, y_1, y_2, y_3, y_4$：\n- $(x_0,y_0) = (\\,0,\\,1\\,)$,\n- $(x_1,y_1) = (\\,1,\\,0\\,)$,\n- $(x_2,y_2) = (\\,2,\\,5\\,)$,\n- $(x_3,y_3) = (\\,3,\\,22\\,)$,\n- $(x_4,y_4) = (\\,5,\\,116\\,)$.\n\n在剖分 $0=x_0<x_1<x_2<x_3<x_4=5$ 上，仅使用三次样条的定义性质和 not-a-knot 端点条件，构造 not-a-knot 三次样条插值函数 $S(x)$。具体来说，从基本定义出发：三次样条函数 $S$ 在每个区间 $[x_i,x_{i+1}]$ 上是一个三次多项式，并且 $S$、$S'$ 和 $S''$ 在每个内部节点处连续，而 not-a-knot 条件强制要求三阶导数在第一个和最后一个内部节点处连续。请勿调用任何预封装的样条系数公式。\n\n然后，显式地验证 not-a-knot 条件，即 $S'''$ 在 $x_1$ 和 $x_3$ 处连续。\n\n最后，计算插值函数在 $x=4$ 处的值。将您的最终答案表示为一个无舍入、无单位的精确数。您最终报告的答案必须是单个值 $S(4)$。", "solution": "对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- **数据点**：提供了五个点 $(x_i, y_i)$：$(x_0,y_0) = (0,1)$、$(x_1,y_1) = (1,0)$、$(x_2,y_2) = (2,5)$、$(x_3,y_3) = (3,22)$ 和 $(x_4,y_4) = (5,116)$。\n- **节点**：节点为 $x_0=0$, $x_1=1$, $x_2=2$, $x_3=3$ 和 $x_4=5$。\n- **函数类型**：一个分段三次样条函数，记为 $S(x)$。\n- **插值条件**：对于 $i=0, 1, 2, 3, 4$，$S(x_i) = y_i$。\n- **连续性条件**：$S(x)$、$S'(x)$ 和 $S''(x)$ 必须在内部节点 $x_1$、$x_2$ 和 $x_3$ 处连续。\n- **端点条件**：指定了 \"not-a-knot\" 条件，这要求三阶导数 $S'''(x)$ 在第一个和最后一个内部节点 $x_1$ 和 $x_3$ 处连续。\n- **任务**：首先，根据这些定义性质构造样条函数 $S(x)$。其次，显式地验证 not-a-knot 条件。第三，计算 $S(4)$。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学性**：该问题基于样条插值理论，这是数值分析和计算工程中的一个基础且成熟的课题。所有概念在数学上都是合理的。\n- **适定性**：为 $n+1$ 个点构造一个 not-a-knot 三次样条的问题是适定的，并且有唯一解。所提供的数据包含 5 个点，这是一个标准配置。\n- **客观性**：问题以精确、客观的数学语言陈述，没有任何主观性或模糊性。\n- **完备性与一致性**：约束的数量与自由度的数量相匹配。对于一个有 4 个三次多项式片段（$S_0, S_1, S_2, S_3$）的样条函数，有 $4 \\times 4 = 16$ 个系数需要确定。条件如下：在每个区间的端点有 $2 \\times 4 = 8$ 个插值条件，在 $x_1, x_2, x_3$ 处有 $3$ 个关于 $S'(x)$ 的连续性条件，在 $x_1, x_2, x_3$ 处有 $3$ 个关于 $S''(x)$ 的连续性条件，以及在 $x_1, x_3$ 处有 $2$ 个关于 $S'''(x)$ 的 not-a-knot 条件。总共有 $8+3+3+2=16$ 个条件。该设定是完备且一致的。\n\n**步骤 3：结论与行动**\n问题被判定为有效。将提供一个严格的解法。\n\n三次样条函数 $S(x)$ 是一组定义在区间 $[x_i, x_{i+1}]$ 上的三次多项式 $S_i(x)$。每个三次多项式片段的二阶导数 $S_i''(x)$ 是一个线性函数。我们可以通过对节点上二阶导数值 $M_i = S''(x_i)$ 进行线性插值来表示它：\n$$S_i''(x) = M_i \\frac{x_{i+1} - x}{h_i} + M_{i+1} \\frac{x - x_i}{h_i}$$\n其中 $h_i = x_{i+1} - x_i$。这种表示方法内在地保证了 $S''(x)$ 在内部节点处的连续性。\n\n对 $S_i''(x)$ 关于 $x$ 积分两次，得到：\n$$S_i(x) = M_i \\frac{(x_{i+1} - x)^3}{6h_i} + M_{i+1} \\frac{(x - x_i)^3}{6h_i} + C_i(x-x_i) + D_i$$\n积分常数 $C_i$ 和 $D_i$ 由插值条件 $S_i(x_i) = y_i$ 和 $S_i(x_{i+1}) = y_{i+1}$ 确定。这导出了样条段的标准形式：\n$$S_i(x) = \\frac{M_i}{6h_i}(x_{i+1}-x)^3 + \\frac{M_{i+1}}{6h_i}(x-x_i)^3 + \\left(y_i - \\frac{M_i h_i^2}{6}\\right)\\frac{x_{i+1}-x}{h_i} + \\left(y_{i+1} - \\frac{M_{i+1} h_i^2}{6}\\right)\\frac{x-x_i}{h_i}$$\n这种形式确保了 $S(x)$ 是连续的并满足插值条件。剩下的未知量是在节点上的二阶导数值 $M_i$（其中 $i=0, \\dots, 4$）。\n\n为了求出 $M_i$，我们强制要求一阶导数 $S'(x)$ 在内部节点 $x_1, x_2, x_3$ 处连续。条件 $S'_{i-1}(x_i) = S'_{i}(x_i)$（对于 $i=1, 2, 3$）导出了以下线性方程组：\n$$h_{i-1}M_{i-1} + 2(h_{i-1} + h_i)M_i + h_i M_{i+1} = 6 \\left( \\frac{y_{i+1}-y_i}{h_i} - \\frac{y_i-y_{i-1}}{h_{i-1}} \\right)$$\n\n问题指定了 not-a-knot 端点条件。这意味着三阶导数在节点 $x_1$ 和 $x_3$ 处连续。$S_i(x)$ 的三阶导数在 $(x_i, x_{i+1})$ 上是常数：\n$$S_i'''(x) = \\frac{M_{i+1} - M_i}{h_i}$$\n在 $x_1$ 处的连续性意味着 $S_0'''(x_1) = S_1'''(x_1)$，这给出 $\\frac{M_1 - M_0}{h_0} = \\frac{M_2 - M_1}{h_1}$。\n在 $x_3$ 处的连续性意味着 $S_2'''(x_3) = S_3'''(x_3)$，这给出 $\\frac{M_3 - M_2}{h_2} = \\frac{M_4 - M_3}{h_3}$。\n\n现在我们将这些一般关系应用于具体的题目数据。区间长度为：\n$h_0 = x_1 - x_0 = 1 - 0 = 1$\n$h_1 = x_2 - x_1 = 2 - 1 = 1$\n$h_2 = x_3 - x_2 = 3 - 2 = 1$\n$h_3 = x_4 - x_3 = 5 - 3 = 2$\n\n关于五个未知二阶导数值 $M_0, M_1, M_2, M_3, M_4$ 的方程组是：\n1.  在 $x_1$ 处的 not-a-knot 条件：$\\frac{M_1 - M_0}{1} = \\frac{M_2 - M_1}{1} \\implies -M_0 + 2M_1 - M_2 = 0$。\n2.  在 $x_1$ 处 $S'$ 的连续性 ($i=1$)：$h_0M_0 + 2(h_0+h_1)M_1 + h_1M_2 = 6(\\frac{y_2-y_1}{h_1} - \\frac{y_1-y_0}{h_0})$\n    $$1 \\cdot M_0 + 2(1+1)M_1 + 1 \\cdot M_2 = 6\\left(\\frac{5-0}{1} - \\frac{0-1}{1}\\right) = 6(5+1)=36 \\implies M_0 + 4M_1 + M_2 = 36$$\n3.  在 $x_2$ 处 $S'$ 的连续性 ($i=2$)：$h_1M_1 + 2(h_1+h_2)M_2 + h_2M_3 = 6(\\frac{y_3-y_2}{h_2} - \\frac{y_2-y_1}{h_1})$\n    $$1 \\cdot M_1 + 2(1+1)M_2 + 1 \\cdot M_3 = 6\\left(\\frac{22-5}{1} - \\frac{5-0}{1}\\right) = 6(17-5)=72 \\implies M_1 + 4M_2 + M_3 = 72$$\n4.  在 $x_3$ 处 $S'$ 的连续性 ($i=3$)：$h_2M_2 + 2(h_2+h_3)M_3 + h_3M_4 = 6(\\frac{y_4-y_3}{h_3} - \\frac{y_3-y_2}{h_2})$\n    $$1 \\cdot M_2 + 2(1+2)M_3 + 2 \\cdot M_4 = 6\\left(\\frac{116-22}{2} - \\frac{22-5}{1}\\right) = 6(47-17)=180 \\implies M_2 + 6M_3 + 2M_4 = 180$$\n5.  在 $x_3$ 处的 not-a-knot 条件：$\\frac{M_3 - M_2}{1} = \\frac{M_4 - M_3}{2} \\implies 2(M_3 - M_2) = M_4 - M_3 \\implies -2M_2 + 3M_3 - M_4 = 0$。\n\n我们求解这个 $5 \\times 5$ 的方程组。\n由 (1) 和 (2) 得：\n将 (1) 与 (2) 相加：$(-M_0 + 2M_1 - M_2) + (M_0 + 4M_1 + M_2) = 0 + 36 \\implies 6M_1 = 36 \\implies M_1 = 6$。\n将 $M_1=6$ 代入 (1)：$-M_0 + 12 - M_2 = 0 \\implies M_2 = 12 - M_0$。\n\n由 (5) 得，$M_4 = 3M_3 - 2M_2$。\n将此代入 (4)：$M_2 + 6M_3 + 2(3M_3 - 2M_2) = 180 \\implies M_2 + 6M_3 + 6M_3 - 4M_2 = 180 \\implies -3M_2 + 12M_3 = 180 \\implies -M_2 + 4M_3 = 60$。\n\n现在使用 (3) 和 $M_1=6$：$6 + 4M_2 + M_3 = 72 \\implies 4M_2 + M_3 = 66$。\n\n我们得到一个关于 $M_2$ 和 $M_3$ 的 $2 \\times 2$ 方程组：\n(A) $4M_2 + M_3 = 66$\n(B) $-M_2 + 4M_3 = 60 \\implies M_2 = 4M_3 - 60$\n将 (B) 代入 (A)：$4(4M_3 - 60) + M_3 = 66 \\implies 16M_3 - 240 + M_3 = 66 \\implies 17M_3 = 306 \\implies M_3 = 18$。\n那么 $M_2 = 4(18) - 60 = 72 - 60 = 12$。\n\n现在我们求出剩余的二阶导数值：\n从 $M_2 = 12 - M_0$ 可得，$12 = 12 - M_0 \\implies M_0 = 0$。\n从 $M_4 = 3M_3 - 2M_2$ 可得，$M_4 = 3(18) - 2(12) = 54 - 24 = 30$。\n\n计算出的二阶导数值为：$M_0=0$, $M_1=6$, $M_2=12$, $M_3=18$, $M_4=30$。\n\n接下来，我们按照要求显式地验证 not-a-knot 条件。\n在 $x_1=1$ 处的条件：证明 $\\frac{M_1 - M_0}{h_0} = \\frac{M_2 - M_1}{h_1}$。\n左边：$\\frac{6-0}{1} = 6$。\n右边：$\\frac{12-6}{1} = 6$。\n条件满足。对于 $x \\in [0,2]$，$S'''(x)=6$。\n\n在 $x_3=3$ 处的条件：证明 $\\frac{M_3 - M_2}{h_2} = \\frac{M_4 - M_3}{h_3}$。\n左边：$\\frac{18-12}{1} = 6$。\n右边：$\\frac{30-18}{2} = \\frac{12}{2} = 6$。\n条件满足。对于 $x \\in [2,5]$，$S'''(x)=6$。\n这证实了三阶导数在 $x_1$ 和 $x_3$ 处是连续的。\n\n最后，我们计算插值函数在 $x=4$ 处的值。点 $x=4$ 位于区间 $[x_3, x_4] = [3, 5]$ 中，所以我们必须使用 $S_3(x)$ 的表达式。\n所需参数为：$i=3$, $x_3=3$, $y_3=22$, $x_4=5$, $y_4=116$, $h_3=2$, $M_3=18$, $M_4=30$。\n$$S_3(x) = \\frac{M_3}{6h_3}(x_4-x)^3 + \\frac{M_4}{6h_3}(x-x_3)^3 + \\left(y_3 - \\frac{M_3 h_3^2}{6}\\right)\\frac{x_4-x}{h_3} + \\left(y_4 - \\frac{M_4 h_3^2}{6}\\right)\\frac{x-x_3}{h_3}$$\n代入数值：\n$$S_3(x) = \\frac{18}{6(2)}(5-x)^3 + \\frac{30}{6(2)}(x-3)^3 + \\left(22 - \\frac{18 \\cdot 2^2}{6}\\right)\\frac{5-x}{2} + \\left(116 - \\frac{30 \\cdot 2^2}{6}\\right)\\frac{x-3}{2}$$\n$$S_3(x) = \\frac{3}{2}(5-x)^3 + \\frac{5}{2}(x-3)^3 + \\left(22 - \\frac{72}{6}\\right)\\frac{5-x}{2} + \\left(116 - \\frac{120}{6}\\right)\\frac{x-3}{2}$$\n$$S_3(x) = \\frac{3}{2}(5-x)^3 + \\frac{5}{2}(x-3)^3 + (22 - 12)\\frac{5-x}{2} + (116 - 20)\\frac{x-3}{2}$$\n$$S_3(x) = \\frac{3}{2}(5-x)^3 + \\frac{5}{2}(x-3)^3 + 10\\frac{5-x}{2} + 96\\frac{x-3}{2}$$\n$$S_3(x) = \\frac{3}{2}(5-x)^3 + \\frac{5}{2}(x-3)^3 + 5(5-x) + 48(x-3)$$\n现在，我们在 $x=4$ 处求值：\n$$S_3(4) = \\frac{3}{2}(5-4)^3 + \\frac{5}{2}(4-3)^3 + 5(5-4) + 48(4-3)$$\n$$S_3(4) = \\frac{3}{2}(1)^3 + \\frac{5}{2}(1)^3 + 5(1) + 48(1)$$\n$$S_3(4) = \\frac{3}{2} + \\frac{5}{2} + 5 + 48$$\n$$S_3(4) = \\frac{8}{2} + 53 = 4 + 53 = 57$$\n插值函数在 $x=4$ 处的值是 $57$。", "answer": "$$\n\\boxed{57}\n$$", "id": "2424185"}, {"introduction": "分段多项式近似的真正威力在于其应用，它们常被用作复杂函数或离散数据的高效、光滑的代理模型。本编程练习将让你从“构建”转向“使用”。你需要在一个函数 $f(x)$ 本身未知、仅能通过其保形分段三次插值（shape-preserving piecewise cubic interpolant）获得的情况下，找出其所有实数根，这在处理实验数据或复杂模拟输出时是一种非常实用的技术。[@problem_id:2424134]", "problem": "给定您的数据集包含严格递增的横坐标 $x_0 < x_1 < \\dots < x_{n-1}$ 和对应的纵坐标 $y_0, y_1, \\dots, y_{n-1}$。标量函数 $f(x)$ 并非直接可用；它被定义为使用逐段三次Hermite插值法从数据集构建的唯一保形逐段三次插值函数。您的任务是编写一个程序，为测试套件中的每个数据集找到在闭区间 $[x_0, x_{n-1}]$ 内 $f(x)=0$ 的所有实数根。\n\n基本原理和建模假设：\n- 在每个子区间 $[x_k,x_{k+1}]$ 上，该插值函数由一个三次Hermite多项式定义，该多项式满足在子区间端点处的函数值和斜率匹配条件。令 $h_k = x_{k+1}-x_k$ 且 $t=(x-x_k)/h_k\\in[0,1]$。在 $[x_k,x_{k+1}]$上，插值函数 $p_k(x)$ 定义为\n$$\np_k(x) = y_k h_{00}(t) + h_k m_k h_{10}(t) + y_{k+1} h_{01}(t) + h_k m_{k+1} h_{11}(t),\n$$\n其中三次Hermite基多项式为\n$$\nh_{00}(t) = 2t^3 - 3t^2 + 1,\\quad\nh_{10}(t) = t^3 - 2t^2 + t,\\quad\nh_{01}(t) = -2t^3 + 3t^2,\\quad\nh_{11}(t) = t^3 - t^2.\n$$\n- 斜率 $m_k$ 是通过将一个保持单调性的规则（Fritsch–Carlson方法）应用于割线斜率 $\\delta_k = \\dfrac{y_{k+1}-y_k}{x_{k+1}-x_k}$ 来选择的，这确保了如果 $y_k$ 随 $x$ 单调变化，插值函数就不会引入虚假的振荡或过冲。具体而言，如果 $\\delta_{k-1}$ 和 $\\delta_k$ 的符号相反或其中任一为零，则 $m_k=0$；否则，$m_k$ 是 $\\delta_{k-1}$ 和 $\\delta_k$ 的一个加权调和平均值，以保持局部形状。端点斜率 $m_0$ 和 $m_{n-1}$ 的选择方式与此一致，以避免过冲。\n- 根是任何满足 $f(x^\\star)=0$ 的 $x^\\star \\in [x_0,x_{n-1}]$。根可能严格存在于子区间内部（作为三次方程 $p_k(x)=0$ 的解），也可能正好出现在 $y_k=0$ 的节点 $x_k$ 上。\n\n算法要求：\n- 对于每个数据集，按照描述构建逐段三次Hermite插值函数 $f(x)$。然后，对每个子区间，求解三次方程 $p_k(x)=0$ 以得到位于 $[x_k, x_{k+1}]$ 内的实数根。同时，将任何满足 $y_k=0$ 的节点 $x_k$ 也视为根。舍弃因数值舍入误差而落在 $[x_0,x_{n-1}]$ 区间之外的任何根。移除间距小于一个很小容差的重复根。\n- 将根按升序排序。将每个根四舍五入到小数点后 $6$ 位。\n\n角度单位：每当数据集中出现三角函数时，应将角度解释为弧度。\n\n输出格式：\n- 您的程序应生成单行输出，其中包含一个列表的列表形式的结果，每个数据集对应一个列表，每个内部列表包含按升序排列并四舍五入后的根。使用逗号分隔的表示法，并用方括号括起来，不含任何空白字符。例如：\"[[r11,r12],[r21],[...]]\"。根应使用小数点后恰好有 $6$ 位数字的标准十进制浮点表示法。空列表应表示为 \"[]\"。\n\n测试套件：\n为了进行稳健的评估，请在以下四个数据集上运行您的程序。对于每个数据集，$x$ 都是严格递增的。\n\n- 测试用例 1 (一个内部根，不在节点上)：\n  - $x = [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5]$\n  - $y = [\\sin(0.5), \\sin(1.0), \\sin(1.5), \\sin(2.0), \\sin(2.5), \\sin(3.0), \\sin(3.5)]$，其中角度以弧度为单位。\n\n- 测试用例 2 (定义域内无根)：\n  - $x = [-2.0, -1.0, 0.0, 1.0, 2.0]$\n  - $y = [(-2.0)^2 + 1.0, (-1.0)^2 + 1.0, 0.0^2 + 1.0, 1.0^2 + 1.0, 2.0^2 + 1.0]$。\n\n- 测试用例 3 (多个根恰好在节点上)：\n  - $x = [0, \\tfrac{\\pi}{4}, \\tfrac{\\pi}{2}, \\tfrac{3\\pi}{4}, \\pi, \\tfrac{5\\pi}{4}, \\tfrac{3\\pi}{2}, \\tfrac{7\\pi}{4}, 2\\pi]$\n  - $y = [\\sin(0), \\sin(\\tfrac{\\pi}{4}), \\sin(\\tfrac{\\pi}{2}), \\sin(\\tfrac{3\\pi}{4}), \\sin(\\pi), \\sin(\\tfrac{5\\pi}{4}), \\sin(\\tfrac{3\\pi}{2}), \\sin(\\tfrac{7\\pi}{4}), \\sin(2\\pi)]$，角度以弧度为单位。\n\n- 测试用例 4 (根位于右边界)：\n  - $x = [0.0, 0.5, 1.0, 1.5, 2.0]$\n  - $y = [0.0-2.0, 0.5-2.0, 1.0-2.0, 1.5-2.0, 2.0-2.0]$。\n\n数值和验证细节：\n- 使用一个很小的绝对容差（例如，$10^{-12}$）来判断一个值是否为零（用于检测节点上的根）以及对来自相邻子区间的根进行去重。\n- 只必须报告闭区间内的实数根。\n- 将每个根四舍五入到小数点后恰好 $6$ 位，并确保四舍五入后，内部列表严格按升序排列。\n\n您的程序必须实现以上要求，并生成一行包含四个测试用例汇总结果的输出，该输出行需采用指定格式，且其中任何位置均不得包含额外的打印内容或空白字符。", "solution": "所述问题是有效的。它提出了一个计算工程领域内明确定义的任务，具体属于数值分析和逼近理论领域。该问题在科学上基于逐段多项式插值理论，是客观的，并提供了构建唯一、可验证解所需的所有必要信息。问题中不存在矛盾、歧义，也不依赖于非科学的前提。\n\n目标是找到函数 $f(x)$ 在闭区间 $[x_0, x_{n-1}]$ 上的所有实数根，其中 $f(x)$ 是根据给定数据集 $(x_k, y_k)$（$k=0, 1, \\dots, n-1$）构建的保形逐段三次Hermite插值函数。\n\n逐段三次Hermite插值是一种样条函数，通过连接多个三次多项式构成，每个子区间 $[x_k, x_{k+1}]$ 对应一个多项式。为使插值函数平滑，函数值和一阶导数必须在节点 $x_k$ 处匹配。设 $p_k(x)$ 是区间 $[x_k, x_{k+1}]$ 上的三次多项式。它由四条信息定义：函数值 $y_k = f(x_k)$ 和 $y_{k+1} = f(x_{k+1})$，以及导数值 $m_k = f'(x_k)$ 和 $m_{k+1} = f'(x_{k+1})$。\n\n区间 $[x_k, x_{k+1}]$ 上的插值函数 $p_k(x)$ 可以用Hermite基多项式表示。令 $h_k = x_{k+1} - x_k$ 并定义一个归一化变量 $t = (x - x_k) / h_k$，这样当 $x$ 从 $x_k$ 变化到 $x_{k+1}$ 时，$t \\in [0, 1]$。该插值函数由下式给出：\n$$\np_k(x(t)) = y_k h_{00}(t) + y_{k+1} h_{01}(t) + h_k m_k h_{10}(t) + h_k m_{k+1} h_{11}(t)\n$$\n其中Hermite基函数为：\n$$\n\\begin{aligned}\nh_{00}(t) &= 2t^3 - 3t^2 + 1 \\\\\nh_{01}(t) &= -2t^3 + 3t^2 \\\\\nh_{10}(t) &= t^3 - 2t^2 + t \\\\\nh_{11}(t) &= t^3 - t^2\n\\end{aligned}\n$$\n这些基函数具有属性 $h_{00}(0)=1$, $h_{01}(1)=1$, $h'_{10}(0)=1$, $h'_{11}(1)=1$，而在 $0$ 和 $1$ 处的其他值和导数均为零，从而确保满足插值条件。\n\n关键部分是导数值 $m_k$ 的选择。标准的三次样条强制二阶导数连续，但这可能会引入原始数据中不存在的虚假振荡。问题指定了一种“保形”或“保持单调性”的方法，具体是 Fritsch–Carlson 方法。该方法根据数据的局部几何形状确定斜率 $m_k$，该几何形状由割线斜率 $\\delta_k = (y_{k+1} - y_k) / (x_{k+1} - x_k)$ 定义。\n对于内部节点 $x_k$（$k=1, \\dots, n-2$），其原理如下：\n1. 如果相邻的割线斜率符号不同，即 $\\delta_{k-1} \\delta_k \\le 0$，则数据在 $x_k$ 周围不是单调的。为防止过冲，此非单调点处的导数设为零：$m_k = 0$。\n2. 如果割线斜率符号相同，即 $\\delta_{k-1} \\delta_k > 0$，则数据是局部单调的。选择导数 $m_k$ 以保持这种单调性。一种常见的选择（如标准库中所实现的）是 $\\delta_{k-1}$ 和 $\\delta_k$ 的加权调和平均值，以确保 $|m_k|$ 得到适当的界定。\n端点斜率 $m_0$ 和 $m_{n-1}$ 使用与这些原则一致的单边方案来确定，以避免在边界附近出现过冲。\n\n一旦所有 $k$ 的斜率 $m_k$ 都被确定，逐段多项式 $f(x)$ 就被完全定义了。任务简化为在 $[x_0, x_{n-1}]$ 上寻找 $f(x)=0$ 的根。这涉及两种不同的情况：\n1. 节点处的根：如果节点 $x_k$ 对应的纵坐标 $y_k = 0$，则该节点处存在一个根。\n2. 子区间内的根：如果三次多项式 $p_k(x)$ 在开区间 $(x_k, x_{k+1})$ 内有零点，则该区间内存在一个根。\n\n为了找到区间内的根，我们必须求解 $p_k(x) = 0$。通过代入Hermite基函数并按 $t$ 的幂次收集项，方程变为一个标准的三次方程 $at^3 + bt^2 + ct + d = 0$，其中系数为：\n$$\n\\begin{aligned}\na &= 2(y_k - y_{k+1}) + h_k(m_k + m_{k+1}) \\\\\nb &= 3(y_{k+1} - y_k) - h_k(2m_k + m_{k+1}) \\\\\nc &= h_k m_k \\\\\nd &= y_k\n\\end{aligned}\n$$\n可以求解这个三次方程以得到其实数根 $t^\\star$。任何位于 $[0, 1]$ 范围内的根 $t^\\star$ 都对应于插值函数的一个有效根 $x^\\star = x_k + t^\\star h_k$。\n\n计算策略如下：\n1.  对每个数据集，使用 `scipy.interpolate.PchipInterpolator` 类。该类为构建保形逐段三次插值函数提供了 Fritsch-Carlson 方法的稳健且数值稳定的实现。\n2.  为确保完整性，求根过程分为两部分：\n    a. 通过检查输入纵坐标值 $y_k$ 是否在很小的容差 $\\epsilon = 10^{-12}$ 内接近于零，来识别节点处的根。\n    b. 使用插值器对象的 `.roots()` 方法寻找开区间 $(x_k, x_{k+1})$ 内的根。该方法能高效、准确地找到逐段多项式在其定义域内的所有实数根，但它不会报告位于全局边界 $x_0$ 和 $x_{n-1}$ 上的根。\n3.  将来自这两个来源的根收集到一个集合中。\n4.  将此集合按升序排序。如果一个在节点上的根被两种方法同时找到，可能会出现重复根。通过遍历排序后的列表，并仅保留那些间距大于容差 $\\epsilon$ 的根来移除重复项。\n5.  最后，将唯一的、排序后的根四舍五入到小数点后 $6$ 位，并按要求格式化。这种方法保证了在闭区间 $[x_0, x_{n-1}]$ 内的所有实数根都能被找到并正确报告。", "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import PchipInterpolator\n\ndef solve():\n    \"\"\"\n    Solves for the real roots of shape-preserving piecewise cubic Hermite interpolants\n    for a suite of test cases.\n    \"\"\"\n    # Tolerance for floating-point comparisons (zero-checking and de-duplication).\n    TOL = 1e-12\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: one interior root, not at a knot\n        {\n            \"x\": np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5]),\n            \"y\": np.sin(np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5]))\n        },\n        # Test case 2: no roots in the domain\n        {\n            \"x\": np.array([-2.0, -1.0, 0.0, 1.0, 2.0]),\n            \"y\": np.array([-2.0, -1.0, 0.0, 1.0, 2.0])**2 + 1.0\n        },\n        # Test case 3: multiple roots exactly at knots\n        {\n            \"x\": np.array([0, np.pi/4, np.pi/2, 3*np.pi/4, np.pi, 5*np.pi/4, 3*np.pi/2, 7*np.pi/4, 2*np.pi]),\n            \"y\": np.sin(np.array([0, np.pi/4, np.pi/2, 3*np.pi/4, np.pi, 5*np.pi/4, 3*np.pi/2, 7*np.pi/4, 2*np.pi]))\n        },\n        # Test case 4: root at the right boundary\n        {\n            \"x\": np.array([0.0, 0.5, 1.0, 1.5, 2.0]),\n            \"y\": np.array([0.0, 0.5, 1.0, 1.5, 2.0]) - 2.0\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        x_data, y_data = case[\"x\"], case[\"y\"]\n\n        # 1. Construct the shape-preserving piecewise cubic Hermite interpolant.\n        #    PchipInterpolator implements the Fritsch–Carlson method.\n        interpolator = PchipInterpolator(x_data, y_data)\n\n        # 2. Find roots. This requires a two-pronged approach.\n        \n        # 2a. Find roots within open subintervals using the PPoly.roots() method.\n        # This method correctly finds roots within (x_k, x_{k+1}) for all k,\n        # but does not report roots at the global boundaries x_0 and x_{n-1}.\n        interior_roots = interpolator.roots(extrapolate=False)\n\n        # 2b. Find roots that occur exactly at the knots.\n        knot_roots = x_data[np.abs(y_data) < TOL]\n        \n        # 3. Combine, sort, and de-duplicate the roots.\n        if interior_roots.size == 0 and knot_roots.size == 0:\n            unique_sorted_roots = []\n        else:\n            all_found_roots = np.concatenate((interior_roots, knot_roots))\n            # Sort all roots to prepare for de-duplication.\n            all_found_roots.sort()\n\n            # De-duplicate roots that are closer than the tolerance.\n            if len(all_found_roots) > 0:\n                unique_sorted_roots = [all_found_roots[0]]\n                for root in all_found_roots[1:]:\n                    if root - unique_sorted_roots[-1] > TOL:\n                        unique_sorted_roots.append(root)\n            else:\n                unique_sorted_roots = []\n\n        # 4. Format the output: round to 6 decimal places.\n        # The f-string format ensures exactly 6 digits are printed, even for whole numbers.\n        formatted_roots = [f\"{root:.6f}\" for root in unique_sorted_roots]\n        all_results.append(f\"[{','.join(formatted_roots)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2424134"}]}