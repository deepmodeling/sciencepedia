{"hands_on_practices": [{"introduction": "拉格朗日插值公式为我们提供了一种直接构建插值多项式的有力工具。然而，在深入进行繁琐的计算之前，深刻理解其背后的理论往往能带来更简洁、更高效的解题路径。本练习旨在强调多项式插值唯一性定理的强大威力，展示理论洞察力在解决实际问题中的价值。[@problem_id:2425975]", "problem": "在一个计算工程背景下，考虑一个由多项式 $P(x) = x^{3} - 2x^{2} + 5$（其中 $x \\in \\mathbb{R}$）给出的精确已知的标量响应模型。您在不同的输入位置 $x_{0} = -1$、$x_{1} = 0$、$x_{2} = 2$ 和 $x_{3} = 3$ 处获得了 $4$ 个测量值，其输出由 $y_{i} = P(x_{i})$ 定义（$i \\in \\{0,1,2,3\\}$）。设 $L(x)$ 表示以拉格朗日形式对数据集 $\\{(x_{i},y_{i})\\}_{i=0}^{3}$ 进行插值的唯一的三次多项式。\n\n计算 $L\\!\\left(\\frac{1}{2}\\right)$ 的精确值。请以单个精确值的形式给出答案，无需四舍五入。答案没有物理单位。", "solution": "首先对问题陈述的科学合理性、完整性和客观性进行验证。\n\n**步骤 1：提取已知条件**\n- 标量响应模型：$P(x) = x^{3} - 2x^{2} + 5$。\n- 定义域：$x \\in \\mathbb{R}$。\n- 测量次数：$4$。\n- 输入位置（节点）：$x_{0} = -1$，$x_{1} = 0$，$x_{2} = 2$ 和 $x_{3} = 3$。\n- 输出生成规则：$y_{i} = P(x_{i})$，其中 $i \\in \\{0, 1, 2, 3\\}$。\n- 插值多项式：$L(x)$ 是对数据集 $\\{(x_{i}, y_{i})\\}_{i=0}^{3}$ 进行插值的唯一的三次多项式。\n- 目标：计算 $L\\!\\left(\\frac{1}{2}\\right)$ 的精确值。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在数学上是明确定义的，涉及数值分析中多项式插值的基本原理。不同的数据点数量为 $n+1 = 4$，这对应于存在一个次数至多为 $n=3$ 的唯一插值多项式。数据是自洽、一致的，并且不需要任何外部信息。该问题有科学依据、是良置的且客观的。\n\n**步骤 3：结论与行动**\n问题有效。将提供解答。\n\n这个问题的核心在于多项式插值的唯一性定理。该定理指出，对于一组 $n+1$ 个不同的点 $\\{(x_{i}, y_{i})\\}_{i=0}^{n}$，存在一个且仅有一个次数至多为 $n$ 的多项式，它穿过该集合中的每一个点。\n\n在本问题中，给定了 $n+1 = 4$ 个不同的输入位置 $x_{0} = -1$，$x_{1} = 0$，$x_{2} = 2$ 和 $x_{3} = 3$。相应的输出值 $y_{i}$ 由已知的多项式模型 $P(x) = x^{3} - 2x^{2} + 5$ 生成。\n因此，数据点为：\n- $(x_{0}, y_{0}) = (-1, P(-1)) = (-1, (-1)^{3} - 2(-1)^{2} + 5) = (-1, -1 - 2 + 5) = (-1, 2)$\n- $(x_{1}, y_{1}) = (0, P(0)) = (0, (0)^{3} - 2(0)^{2} + 5) = (0, 5)$\n- $(x_{2}, y_{2}) = (2, P(2)) = (2, (2)^{3} - 2(2)^{2} + 5) = (2, 8 - 8 + 5) = (2, 5)$\n- $(x_{3}, y_{3}) = (3, P(3)) = (3, (3)^{3} - 2(3)^{2} + 5) = (3, 27 - 18 + 5) = (3, 14)$\n\n问题陈述指出，$L(x)$ 是对这四个点进行插值的唯一的三次多项式。给定多项式 $P(x)$ 的次数为 $3$。根据其构造方式，$P(x)$ 本身就是一个穿过所有四个数据点的3次多项式。\n\n根据唯一性定理，次数至多为3的此类多项式只能有一个。因此，拉格朗日插值多项式 $L(x)$ 必须对所有 $x$ 值都与原始多项式 $P(x)$ 完全相同。\n$$L(x) \\equiv P(x) = x^{3} - 2x^{2} + 5$$\n这一见解使得构造拉格朗日基多项式（一项计算密集型任务）变得完全没有必要。问题被简化为在指定点对多项式 $P(x)$ 进行一次简单的求值。\n\n题目要求我们计算 $L\\!\\left(\\frac{1}{2}\\right)$。由于 $L(x) = P(x)$，我们只需计算 $P\\!\\left(\\frac{1}{2}\\right)$。\n$$L\\!\\left(\\frac{1}{2}\\right) = P\\!\\left(\\frac{1}{2}\\right) = \\left(\\frac{1}{2}\\right)^{3} - 2\\left(\\frac{1}{2}\\right)^{2} + 5$$\n我们逐项计算该表达式：\n$$L\\!\\left(\\frac{1}{2}\\right) = \\frac{1}{8} - 2\\left(\\frac{1}{4}\\right) + 5$$\n$$L\\!\\left(\\frac{1}{2}\\right) = \\frac{1}{8} - \\frac{2}{4} + 5$$\n为了合并这些项，我们找到公分母 $8$：\n$$L\\!\\left(\\frac{1}{2}\\right) = \\frac{1}{8} - \\frac{4}{8} + \\frac{40}{8}$$\n$$L\\!\\left(\\frac{1}{2}\\right) = \\frac{1 - 4 + 40}{8}$$\n$$L\\!\\left(\\frac{1}{2}\\right) = \\frac{37}{8}$$\n精确值为 $\\frac{37}{8}$。", "answer": "$$\\boxed{\\frac{37}{8}}$$", "id": "2425975"}, {"introduction": "掌握了如何构建和使用插值多项式之后，理解其局限性也同样至关重要。本练习将展示一个经典场景：尽管在数学上完全正确，多项式插值的结果却可能完全无法代表真实的潜在函数。这个引人深思的例子揭示了采样和插值之间一个深刻而关键的联系，即“混叠”现象。[@problem_id:2425926]", "problem": "考虑函数 $f(x) = \\sin(2\\pi x)$，其中正弦函数的参数以弧度为单位。设 $N \\in \\mathbb{N}$，等距插值节点为 $x_k = k$，其中 $k = 0, 1, \\dots, N$。定义 $P_N(x)$ 为在这些节点上插值 $f(x)$ 的、次数至多为 $N$ 的唯一多项式。请以单一闭式解析表达式的形式确定 $P_N(x)$。请将您的最终答案表示为单个表达式。无需四舍五入。", "solution": "该问题要求确定次数至多为 $N$ 的唯一多项式 $P_N(x)$，该多项式在 $N+1$ 个整数节点 $x_k = k$（其中 $k = 0, 1, \\dots, N$）上插值函数 $f(x) = \\sin(2\\pi x)$。该多项式需要用单一闭式解析表达式来表示。\n\n多项式插值的条件是，在每个插值节点上，多项式的值必须与函数的值相等。也就是说，对于每个 $k \\in \\{0, 1, \\dots, N\\}$，必须满足以下条件：\n$$P_N(x_k) = f(x_k)$$\n\n首先，我们必须计算函数 $f(x)$ 在指定节点 $x_k = k$ 处的值。函数在第 $k$ 个节点处的值用 $y_k$ 表示：\n$$y_k = f(x_k) = f(k) = \\sin(2\\pi k)$$\n对于任何整数值 $k$，正弦函数的参数 $2\\pi k$ 都是 $2\\pi$ 的整数倍。正弦函数对于 $\\pi$ 的所有整数倍其值都为零，因此对于 $2\\pi$ 的所有整数倍其值也特别为零。\n$$y_k = \\sin(2\\pi k) = 0 \\quad \\text{for all } k \\in \\{0, 1, \\dots, N\\}$$\n\n因此，多项式 $P_N(x)$ 的插值条件为：\n$$P_N(0) = 0$$\n$$P_N(1) = 0$$\n$$\\vdots$$\n$$P_N(N) = 0$$\n这组条件意味着多项式 $P_N(x)$ 在 $x = 0, 1, 2, \\dots, N$ 处有 $N+1$ 个不同的根。\n\n问题指出 $P_N(x)$ 必须是一个次数至多为 $N$ 的多项式。根据代数基本定理，一个次数为 $d$ 的非零多项式在复平面上至多有 $d$ 个根。如果多项式 $P_N(x)$ 非零，那么它的次数（至多为 $N$）将小于其根的数目（$N+1$）。这是一个矛盾。\n\n唯一一个根的数目可以超过其次数的多项式是零多项式，$P_N(x) \\equiv 0$。零多项式的次数通常定义为 $-\\infty$ 或 $-1$，对于任何 $N \\in \\mathbb{N}$，这都满足次数至多为 $N$ 的条件。因此，满足这 $N+1$ 个插值条件的、次数至多为 $N$ 的唯一多项式是零多项式。\n\n这个结论可以用插值多项式的拉格朗日形式进行形式化验证，其形式如下：\n$$P_N(x) = \\sum_{j=0}^{N} y_j L_j(x)$$\n其中 $y_j = f(x_j)$，$L_j(x)$ 是拉格朗日基多项式，定义为：\n$$L_j(x) = \\prod_{\\substack{k=0 \\\\ k \\ne j}}^{N} \\frac{x-x_k}{x_j-x_k}$$\n如前所述，$y_j = 0$ 对所有 $j=0, 1, \\dots, N$ 成立。将这些值代入拉格朗日公式，我们得到：\n$$P_N(x) = \\sum_{j=0}^{N} (0) \\cdot L_j(x) = \\sum_{j=0}^{N} 0 = 0$$\n这严格地证实了插值多项式恒等于零。这里展示的现象是混叠的一个经典例子，其中采样率不足以捕捉振荡函数在节点之间的行为。\n\n所要求的 $P_N(x)$ 的单一闭式解析表达式就是 $0$。", "answer": "$$\\boxed{0}$$", "id": "2425926"}, {"introduction": "在计算工程领域，衡量理解深度的真正标准之一，是将数学原理转化为稳健可靠的算法的能力。本练习将带你从纯理论走向实际编程，要求你利用多项式插值的性质来解决一个几何问题。你需要通过检验插值多项式的阶数，设计一个程序来判断一组点是否共线。[@problem_id:2425948]", "problem": "给定平面点的有限集合 $\\{(x_i,y_i)\\}_{i=0}^{n}$，其中 $n \\ge 1$。一个点集是共线的，当且仅当存在一条包含所有点的直线。直线可以表示为 $y = a x + b$（对于某些实数 $a$ 和 $b$），此为非垂直线；或者表示为 $x = c$（对于某个实数 $c$），此为垂直线。你的任务是设计并实现一个程序，该程序通过检验为非垂直情况构建的 Lagrange 形式唯一插值多项式的次数，并结合逻辑上必要的前置检查以正确处理垂直情况，来判断点集的共线性。\n\n使用的基本原理：\n- 多项式次数的定义，即 $x$ 的具有非零系数的最高次幂。\n- 对于不同的横坐标 $x_0,\\dots,x_n$，存在一个次数至多为 $n$ 的唯一多项式 $p(x)$ 对数据 $(x_i,y_i)$ 进行插值，并且任何这样的多项式在 $n+1$ 个插值节点上都与数据完全吻合。\n- 平面点共线性的定义，即所有点位于同一直线上。\n\n算法设计要求：\n- 如果所有点的 $x$ 坐标在数值容差 $\\tau$ 内相等，则判断这些点在一条垂直线上共线，并返回 $\\mathrm{True}$。\n- 如果存在两个点具有相同的 $x$ 坐标但不同的 $y$ 坐标（差异大于 $\\tau$），而并非所有点的 $x$ 坐标都在 $\\tau$ 范围内相等，则判断该点集不可能位于任何单一直线上，并返回 $\\mathrm{False}$。\n- 否则，移除完全重复的点，确保余下的插值节点具有不同的 $x$ 坐标，构建将 $y$ 作为 $x$ 的函数的 Lagrange 插值多项式 $p(x)$，将其转换为单项式系数，通过将绝对值小于等于 $\\tau$ 的任何系数视为零来确定其有效次数，并当且仅当有效次数至多为 $1$ 时，声明该点集共线。\n- 对所有零值检验和垂直线检查使用固定容差 $\\tau = 10^{-10}$，并使用实数算术处理所有计算。程序不得假设此处声明之外的任何特殊结构。\n- 如果唯一（不重复的）点的数量（移除重复点后）至多为 $2$，则返回 $\\mathrm{True}$，因为任意两点都是共线的。\n\n你的程序的输入由以下直接嵌入源代码中的测试套件固定。对于每种情况，将每对 $(x,y)$ 解释为使用无量纲单位。\n- 案例 #1 (非垂直，线性): $\\{(-1, -1), (0, 1), (2, 5)\\}$。\n- 案例 #2 (非垂直，非线性): $\\{(0, 0), (1, 1), (2, 2.1)\\}$。\n- 案例 #3 (垂直线): $\\{(3, 0), (3, 5), (3, -2)\\}$。\n- 案例 #4 (包含重复点，线性): $\\{(1, 2), (1, 2), (2, 4), (3, 6)\\}$。\n- 案例 #5 (存在 $x$ 相同但 $y$ 不同的冲突点，且存在其他 $x$ 值的点): $\\{(1, 2), (1, 3), (2, 4)\\}$。\n- 案例 #6 (恰好两个点): $\\{(-100, 50), (200, -250)\\}$。\n- 案例 #7 (近线性，微小扰动远低于容差): $\\{(0, 1), (1, 0.5), (2, 0), (3, -0.5 + 10^{-12})\\}$。\n\n输出规格：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表顺序与上述测试用例相同。每个结果必须是布尔值 $\\mathrm{True}$ 或 $\\mathrm{False}$，不带空格。例如，格式必须类似于 $[r_A,r_B,r_C]$。\n\n约束与说明：\n- 仅使用实数算术，并根据规定对系数修剪和相等性检查使用固定容差 $\\tau = 10^{-10}$。\n- 实现必须是自包含的，并且不需要任何输入。输出必须从硬编码的测试套件计算得出。", "solution": "问题在于确定一个给定的包含 $n+1$ 个平面点的集合 $\\{(x_i, y_i)\\}_{i=0}^{n}$（其中 $n \\ge 1$）是否共线。共线性要求所有点必须位于同一直线上，该直线可以是非垂直的（形式为 $y = ax + b$）或垂直的（形式为 $x = c$）。指定的方法是使用多项式插值，其原理是：一个点集位于非垂直线上，当且仅当穿过这些点的唯一插值多项式的次数至多为 $1$。该方法必须辅以相应的逻辑来处理数值精度问题和垂直线的特殊情况。这个问题是适定的且在科学上是合理的，因此我们着手设计一个严谨的算法。\n\n算法流程由一系列逻辑步骤构成，旨在系统地处理所有情况和数值偏差。所有浮点数比较均使用数值容差 $\\tau = 10^{-10}$。\n\n首先，必须对输入数据进行清理。我们得到一个可能包含重复点的点集。任意两点可定义一条直线，因此如果唯一（不重复）点的数量小于或等于 $2$，则该点集是平凡共线的。我们首先将输入简化为一个唯一（不重复）点的集合，记为 $S$。如果 $|S| \\le 2$，我们判断这些点共线并终止算法。\n\n其次，我们必须处理垂直线的情况。一条垂直线由方程 $x=c$（$c$ 为某个常数）描述。这不属于 $y=f(x)$ 形式的函数，因此不能用一个关于 $x$ 的标准多项式来表示。这种情况可以通过检查唯一（不重复）点集 $S$ 中的所有点是否具有相同的 $x$ 坐标（在容差 $\\tau$ 范围内）来识别。令 $X = \\{x | (x, y) \\in S\\}$。如果 $\\max(X) - \\min(X) \\le \\tau$，则所有点都位于一条垂直线上，我们判断它们是共线的。\n\n第三，对于非垂直情况，这些点必须表示一个单值函数。也就是说，对于 $S$ 中的任意两点 $(x_i, y_i)$ 和 $(x_j, y_j)$，如果 $x_i$ 和 $x_j$ 在数值上不可区分，那么 $y_i$ 和 $y_j$ 也必须在数值上不可区分。如果我们发现两点满足 $|x_i - x_j| \\le \\tau$ 但 $|y_i - y_j| > \\tau$，则没有任何函数 $y=f(x)$ 能同时穿过这两点。由于垂直线的情况已被排除，因此没有任何单一直线能包含这些点。因此我们必须检查此条件，如果满足，则判断这些点不共线。这一步也为插值准备了数据。我们可以将 $x$ 坐标在 $\\tau$ 范围内的点分组。如果任何这样的分组中 $y$ 坐标的分布范围大于 $\\tau$，我们就找到了一个矛盾。否则，我们可以用一个代表性单点（例如，通过对组内坐标取平均值）来替换每组点。此过程产生一个新的点集 $S'$，其中所有 $x$ 坐标都是不同的（相差大于 $\\tau$）。如果在这次合并后，点的数量 $|S'| \\le 2$，则该点集再次被视为平凡共线。\n\n第四，对于一个清理过的、包含 $N+1$ 个点且具有不同横坐标的集合 $S' = \\{(x'_j, y'_j)\\}_{j=0}^{N}$（其中 $N+1 = |S'| > 2$），我们可以应用多项式插值的基本定理。存在一个次数至多为 $N$ 的唯一多项式 $p(x)$，使得对所有 $j \\in \\{0, \\dots, N\\}$ 都有 $p(x'_j) = y'_j$。这个多项式可以用 Lagrange 形式构建：\n$$\np(x) = \\sum_{j=0}^{N} y'_j L_j(x), \\quad \\text{其中} \\quad L_j(x) = \\prod_{k=0, k \\ne j}^{N} \\frac{x - x'_k}{x'_j - x'_k}\n$$\n这些点共线的充分必要条件是它们位于一条直线 $y = ax+b$ 上，这是一个次数为 $1$ 的多项式（如果 $a=0$，则次数为 $0$）。因此，共线性条件等价于唯一插值多项式 $p(x)$ 的次数至多为 $1$。\n\n为了确定次数，我们必须将 $p(x)$ 转换为其单项式表示 $p(x) = \\sum_{k=0}^{N} c_k x^k$。在用浮点数进行的实际计算中，理论上为零的系数可能会显示为非常小的非零值。因此，我们必须确定多项式的“有效次数”。有效次数定义为使得相应系数的绝对值 $|c_k|$ 大于容差 $\\tau$ 的最大整数 $k$。如果对于所有 $k > 1$ 的系数 $c_k$ 都满足 $|c_k| \\le \\tau$，则有效次数至多为 $1$，我们判断这些点是共线的。否则，这些点不共线。如果所有系数都满足 $|c_k| \\le \\tau$，则有效次数被认为小于或等于 $1$，这些点是共线的（表示一条接近 $y=0$ 的水平线）。至此，算法完成。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import lagrange\n\ndef solve():\n    \"\"\"\n    Solves the collinearity problem for a predefined suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case #1 (non-vertical, linear)\n        [(-1, -1), (0, 1), (2, 5)],\n        # Case #2 (non-vertical, non-linear)\n        [(0, 0), (1, 1), (2, 2.1)],\n        # Case #3 (vertical line)\n        [(3, 0), (3, 5), (3, -2)],\n        # Case #4 (duplicates included, linear)\n        [(1, 2), (1, 2), (2, 4), (3, 6)],\n        # Case #5 (conflicting equal x with different y and a different x present)\n        [(1, 2), (1, 3), (2, 4)],\n        # Case #6 (exactly two points)\n        [(-100, 50), (200, -250)],\n        # Case #7 (near-linear with tiny perturbation well below tolerance)\n        [(0, 1), (1, 0.5), (2, 0), (3, -0.5 + 1e-12)],\n    ]\n\n    tolerance = 1e-10\n    \n    results = []\n    for points in test_cases:\n        result = is_collinear(points, tolerance)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef is_collinear(points, tau):\n    \"\"\"\n    Determines if a set of points is collinear based on the degree of the\n    interpolating polynomial and special case checks.\n\n    Args:\n        points (list of tuples): A list of (x, y) coordinates.\n        tau (float): The numerical tolerance for floating-point comparisons.\n\n    Returns:\n        bool: True if the points are collinear, False otherwise.\n    \"\"\"\n    # 1. Remove exact duplicates and handle trivial cases.\n    unique_points = sorted(list(set(points)))\n    if len(unique_points) = 2:\n        return True\n\n    x_coords = np.array([p[0] for p in unique_points])\n    y_coords = np.array([p[1] for p in unique_points])\n\n    # 2. Check for vertical line.\n    # np.ptp (peak-to-peak) is equivalent to max(arr) - min(arr)\n    if np.ptp(x_coords) = tau:\n        return True\n\n    # 3. Consolidate points with close x-coordinates and check for function validity.\n    # This step ensures that for each x, there is a unique y (within tolerance)\n    # and prepares a set of nodes with distinct x for interpolation.\n    consolidated_points = []\n    \n    # The unique_points are already sorted by x-coordinate (default tuple sort).\n    # We group points with numerically equal x-coordinates.\n    i = 0\n    while i  len(unique_points):\n        # Start a new group\n        group_indices = [i]\n        j = i + 1\n        while j  len(unique_points) and abs(unique_points[j][0] - unique_points[i][0]) = tau:\n            group_indices.append(j)\n            j += 1\n        \n        # Process the group\n        group_y = y_coords[group_indices]\n        if np.ptp(group_y) > tau:\n            # Contradiction: same x, different y. Not a function.\n            return False\n        \n        # The group is valid, consolidate into a single point by averaging.\n        group_x = x_coords[group_indices]\n        avg_x = np.mean(group_x)\n        avg_y = np.mean(group_y)\n        consolidated_points.append((avg_x, avg_y))\n        \n        i = j # Move to the start of the next group\n\n    if len(consolidated_points) = 2:\n        return True\n\n    # 4. Perform Lagrange interpolation and check the degree.\n    x_final = np.array([p[0] for p in consolidated_points])\n    y_final = np.array([p[1] for p in consolidated_points])\n    \n    # Construct the unique interpolating polynomial.\n    poly = lagrange(x_final, y_final)\n    \n    # 5. Determine the effective degree.\n    effective_degree = 0\n    # a_n is the coefficient of the highest power\n    coeffs = poly.coeffs\n    for i, coeff in enumerate(coeffs):\n        if abs(coeff) > tau:\n            # Degree is (number of coeffs - 1) for the first element,\n            # and decreases with index.\n            effective_degree = len(coeffs) - 1 - i\n            break\n    \n    return effective_degree = 1\n\n# Execute the solution\nsolve()\n```", "id": "2425948"}]}