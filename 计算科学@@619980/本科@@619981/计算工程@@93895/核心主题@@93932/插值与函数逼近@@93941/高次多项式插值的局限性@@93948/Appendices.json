{"hands_on_practices": [{"introduction": "在数据拟合中，一个常见的直觉是使用更多的数据点和更高阶的模型会得到更准确的结果。本练习将挑战这一观念，引导您探究著名的龙格现象（Runge phenomenon），即使用等距节点的高次多项式插值会在区间端点附近产生剧烈振荡，反而增大误差。通过编程计算误差开始增大的“临界阶数”，您将对这一高次插值方法的根本局限性获得切实的理解 [@problem_id:2436036]。", "problem": "对于给定的参数 $a>0$，考虑闭区间 $[-1,1]$ 上的龙格函数 $f(x)=\\dfrac{1}{1+a x^{2}}$。对于每个整数阶 $n \\ge 0$，令 $P_{n}(x)$ 表示一个次数至多为 $n$ 的唯一多项式，该多项式在 $n+1$ 个等距节点 $x_{k}=-1+\\dfrac{2k}{n}$（其中 $k=0,1,\\dots,n$）上对 $f(x)$ 进行插值。定义积分绝对插值误差\n$$\nE(n)=\\int_{-1}^{1}\\left|f(x)-P_{n}(x)\\right|\\,dx.\n$$\n定义临界阶数 $N_{\\text{crit}}$ 为在指定搜索范围内的最小整数 $n$，使得增加一个等距插值节点会导致积分误差在以下意义上严格增加：\n$$\nE(n+1) > \\left(1+\\tau\\right) E(n),\n$$\n其中 $\\tau$ 是一个固定的相对裕度。如果在指定范围内不存在这样的 $n$，则设 $N_{\\text{crit}}=-1$。\n\n您的任务是为下面列出的每个测试用例计算 $N_{\\text{crit}}$。定义 $E(n)$ 的积分必须在 $[-1,1]$ 上进行数值计算，其绝对误差不大于 $10^{-6}$。\n\n测试套件（每个项目是一个三元组 $(a,n_{\\min},n_{\\max})$，指定了龙格参数和包含端点的阶数搜索范围）：\n- 案例 1：$(a,n_{\\min},n_{\\max})=(25,2,80)$\n- 案例 2：$(a,n_{\\min},n_{\\max})=(5,2,80)$\n- 案例 3：$(a,n_{\\min},n_{\\max})=(100,2,80)$\n- 案例 4：$(a,n_{\\min},n_{\\max})=(1,2,10)$\n\n在 $N_{\\text{crit}}$ 的定义中使用相对裕度 $\\tau=10^{-4}$。对于每个案例，确定满足 $n_{\\min}\\le n < n_{\\max}$ 且 $E(n+1)>\\left(1+\\tau\\right)E(n)$ 的最小整数 $n$；如果在指定范围内不存在，则报告 $-1$。\n\n最终输出格式：您的程序应生成一行输出，其中包含四个按顺序排列的结果，形式为逗号分隔的列表并用方括号括起来，例如 $[N_{\\text{crit},1},N_{\\text{crit},2},N_{\\text{crit},3},N_{\\text{crit},4}]$，其中每个 $N_{\\text{crit},j}$ 都是一个整数。", "solution": "所提出的问题是计算物理和数值分析领域中的一个有效练习。该问题定义明确，有科学依据，并包含了获得唯一解所需的所有信息。该任务涉及研究龙格函数 $f(x)=\\dfrac{1}{1+ax^2}$ 在区间 $[-1,1]$ 上的多项式插值的龙格现象。具体来说，我们要确定“临界阶数”$N_{\\text{crit}}$，它被定义为在指定范围 $[n_{\\min}, n_{\\max}-1]$ 内的最小整数阶 $n$，使得积分绝对误差 $E(n+1)$ 相对于 $E(n)$ 有显著增加。这种在等距节点上使用高阶多项式进行插值时，误差在区间边界附近发散的现象，是一个基本概念，它说明了朴素插值策略的局限性。\n\n解决该问题的方法是直接根据所提供的定义进行计算实现。对于每个由参数 $a$ 和搜索范围 $[n_{\\min}, n_{\\max}]$ 表征的测试用例，我们必须系统地计算阶数为 $n$ 和 $n+1$ 时的积分误差 $E(n)$ 和 $E(n+1)$，并检查指定的条件。\n\n首先，我们为给定的阶数 $n$ 定义核心量，即积分绝对插值误差：\n$$\nE(n) = \\int_{-1}^{1} \\left|f(x) - P_{n}(x)\\right|\\,dx\n$$\n这里，$f(x) = \\dfrac{1}{1+ax^2}$ 是待插值的函数。$P_n(x)$ 项代表次数至多为 $n$ 的唯一插值多项式，它穿过 $f(x)$ 曲线上的 $n+1$ 个特定点。这些点由 $n+1$ 个等距节点集合确定：\n$$\nx_k = -1 + \\frac{2k}{n}, \\quad k = 0, 1, \\dots, n\n$$\n相应的值为 $y_k = f(x_k)$。多项式 $P_n(x)$ 可以使用这些点对 $(x_k, y_k)$ 来构建。虽然拉格朗日形式是经典的表示方法，但重心形式在数值上更稳定、评估效率更高，是高质量数值库中的标准选择。\n\n定义 $E(n)$ 的积分通常没有简单的解析闭式解。因此，其评估必须以数值方式进行。一个鲁棒的自适应求积算法是合适的，例如 `scipy.integrate.quad` 中实现的算法，它基于一个 QUADPACK 例程。为满足问题要求积分的绝对误差不大于 $10^{-6}$，数值积分子程序必须配置足够小的容差，例如，绝对容差为 $10^{-9}$。\n\n对于每个测试用例 $(a, n_{\\min}, n_{\\max})$ 和固定的相对裕度 $\\tau = 10^{-4}$，总体算法如下：\n1. 初始化临界阶数 $N_{\\text{crit}} = -1$。\n2. 从 $n_{\\min}$ 到 $n_{\\max}-1$ 遍历整数阶 $n$。\n3. 在每次迭代中，计算误差积分 $E(n)$ 和 $E(n+1)$。为优化起见，可以重用上一次迭代中的 $E(n)$ 值。对于第一次迭代 $n=n_{\\min}$，必须计算 $E(n_{\\min})$ 和 $E(n_{\\min}+1)$。对于后续迭代 $n > n_{\\min}$， $E(n)$ 的值已在上一步作为 $E((n-1)+1)$ 计算过。\n4. 检查临界条件：\n   $$\n   E(n+1) > (1+\\tau) E(n)\n   $$\n5. 如果满足此条件，则当前阶数 $n$ 是满足条件的最小整数。我们设置 $N_{\\text{crit}} = n$ 并终止对此测试用例的搜索。\n6. 如果循环完成而条件从未满足，则 $N_{\\text{crit}}$ 保持其初始值 $-1$。\n\n对所有四个测试用例重复此计算过程，并收集所得的 $N_{\\text{crit}}$ 值。参数 $a$ 控制 $f(x)$ 中峰值的尖锐程度。较大的 $a$ 值会导致更显著的龙格现象，我们预计误差会在较低的阶数 $n$ 处开始发散，从而导致较小的 $N_{\\text{crit}}$。反之，较小的 $a$ 会产生更平滑的函数，延迟发散的开始，这应对应于较大的 $N_{\\text{crit}}$ 或在给定范围内没有临界点。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import BarycentricInterpolator\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves for the crossover degree N_crit for the Runge function interpolation error\n    across several test cases.\n    \"\"\"\n\n    def calculate_error(n: int, a: float) -> float:\n        \"\"\"\n        Calculates the integrated absolute interpolation error E(n) for a given degree n and parameter a.\n\n        Args:\n            n: The degree of the interpolating polynomial.\n            a: The parameter of the Runge function.\n\n        Returns:\n            The value of the integral E(n).\n        \"\"\"\n        if n < 0:\n            # A degree cannot be negative.\n            raise ValueError(\"Degree n must be non-negative.\")\n\n        # Define the Runge function f(x)\n        runge_func = lambda x: 1.0 / (1.0 + a * x**2)\n\n        # Generate n+1 equispaced nodes in [-1, 1]\n        x_nodes = np.linspace(-1.0, 1.0, n + 1)\n        y_nodes = runge_func(x_nodes)\n\n        # Construct the barycentric interpolating polynomial P_n(x)\n        poly = BarycentricInterpolator(x_nodes, y_nodes)\n\n        # Define the absolute error function |f(x) - P_n(x)|\n        error_func = lambda x: np.abs(runge_func(x) - poly(x))\n\n        # Numerically integrate the error function from -1 to 1.\n        # Set a small absolute tolerance to ensure the result is accurate to 1e-6 as required.\n        integral_val, _ = quad(error_func, -1.0, 1.0, epsabs=1e-9)\n\n        return integral_val\n\n    def find_Ncrit(a: float, n_min: int, n_max: int, tau: float) -> int:\n        \"\"\"\n        Finds the smallest integer n in [n_min, n_max-1] such that E(n+1) > (1+tau)E(n).\n        \n        Args:\n            a: The parameter of the Runge function.\n            n_min: The minimum degree to start the search from.\n            n_max: The exclusive upper bound for the search degree n.\n            tau: The relative margin for error increase.\n            \n        Returns:\n            The crossover degree N_crit, or -1 if not found.\n        \"\"\"\n        N_crit = -1\n\n        # Check for valid range\n        if n_min >= n_max:\n            return N_crit\n\n        # Use an error cache to avoid recomputing integrals\n        error_cache = {}\n\n        def get_E(n_val):\n            if n_val not in error_cache:\n                error_cache[n_val] = calculate_error(n_val, a)\n            return error_cache[n_val]\n        \n        # Loop n from n_min to n_max-1\n        for n in range(n_min, n_max):\n            E_n = get_E(n)\n            E_n_plus_1 = get_E(n + 1)\n\n            if E_n_plus_1 > (1.0 + tau) * E_n:\n                N_crit = n\n                break  # Found the smallest n, terminate search for this case\n        \n        return N_crit\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (25, 2, 80),   # Case 1\n        (5, 2, 80),    # Case 2\n        (100, 2, 80),  # Case 3\n        (1, 2, 10),    # Case 4\n    ]\n    \n    # Relative margin\n    tau = 1e-4\n\n    results = []\n    for a, n_min, n_max in test_cases:\n        result = find_Ncrit(a, n_min, n_max, tau)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2436036"}, {"introduction": "龙格现象揭示了理论上的陷阱，但在真实的计算机上用有限精度实现插值时又会发生什么呢？本实践将探讨插值节点的选择不仅影响理论误差，也决定了计算过程本身的数值稳定性。您将亲眼见证，不佳的节点排布如何在有限精度下导致灾难性的误差，而精心选择的节点，如切比雪夫（Chebyshev）节点，如何成为一个稳健的解决方案 [@problem_id:2409001]。", "problem": "一项计算任务是量化在采用差商以牛顿基表示高阶插值多项式时，有限精度算术对其构建和求值过程的影响。运算应在由电气与电子工程师协会（IEEE）$754$ binary64 格式指定的标准双精度算术中进行，并将所有操作和结果视为在该模型中发生。对于给定的节点集 $\\{x_k\\}_{k=0}^n \\subset \\mathbb{R}$ 和函数 $f:\\mathbb{R}\\to\\mathbb{R}$，其在牛顿基下的唯一、阶数至多为 n 的插值多项式 $p_n$ 定义为\n$$\np_n(x) \\;=\\; \\sum_{k=0}^{n} c_k \\prod_{j=0}^{k-1} (x - x_j),\n$$\n其中 $c_k$ 是标准数学意义上的第 k 个差商 $f[x_0,\\dots,x_k]$。所有量都必须以双精度进行数值计算和求值。\n\n对于下述每个测试用例，请为指定的函数 $f$ 和节点构建 $p_n$，然后在指定区间内一个包含 $m$ 个点的均匀求值网格上对 $p_n$ 和 $f$ 进行求值，并计算最大绝对求值误差\n$$\nE \\;=\\; \\max_{t \\in T} \\big|p_n(t) - f(t)\\big|,\n$$\n其中 $T$ 是求值网格。如果在任何阶段出现非有限值（例如，任何系数 $c_k$ 不是有限值，或 $p_n$ 的任何求值结果不是有限值），则该测试用例的 $E$ 报告为 $+\\infty$。\n\n测试套件：\n- 用例 A（等距节点下的一般行为，以及一个已知在等距插值下会发生振荡的函数）：函数 $f(x) = \\dfrac{1}{1+25x^2}$，定义在 $[-1,1]$ 上，节点 $x_k$ 在 $[-1,1]$ 上等距分布，其中 $n=20$（即 $21$ 个节点），求值点为 $[-1,1]$ 上的 $m=1001$ 个均匀间隔点。\n- 用例 B（解析函数的良态节点）：函数 $f(x) = e^x$，定义在 $[-1,1]$ 上，节点 $x_k = \\cos\\!\\left(\\dfrac{k\\pi}{n}\\right)$（第二类切比雪夫节点），其中 $n=30$，求值点为 $[-1,1]$ 上的 $m=1001$ 个均匀间隔点。\n- 用例 C（强节点聚集以探测差商的敏感性）：函数 $f(x) = \\sin(x)$，定义在 $[0,1]$ 上，节点为 $x_k = 10^{-k}$，其中 $k=18,17,\\dots,0$（即从 $10^{-18}$ 严格递增至 $10^0$），$n=18$，求值点为 $[0,1]$ 上的 $m=1001$ 个均匀间隔点。\n- 用例 D（解析函数的极高阶良态节点插值）：函数 $f(x) = e^x$，定义在 $[-1,1]$ 上，节点 $x_k = \\cos\\!\\left(\\dfrac{k\\pi}{n}\\right)$，其中 $n=80$，求值点为 $[-1,1]$ 上的 $m=1001$ 个均匀间隔点。\n\n你的程序必须按顺序生成与上述用例相对应的四个结果，每个结果都是该用例定义的标量 $E$。最终输出格式必须是单行文本，包含一个用方括号括起来的逗号分隔列表，例如 $[E_A,E_B,E_C,E_D]$。", "solution": "所提出的问题要求在有限精度算术的约束下验证多项式插值方法，这是计算工程和数值分析中的一个基本课题。任务是为给定的函数和节点集，在牛顿基下构建一个插值多项式 $p_n(x)$，然后在一个精细的求值网格上量化其与真实函数之间的最大绝对误差 $E$。所有计算都将使用标准的 IEEE $754$ 双精度浮点算术执行。\n\n穿过 $n+1$ 个点 $\\{(x_k, f(x_k))\\}_{k=0}^n$ 且阶数至多为 $n$ 的插值多项式 $p_n(x)$ 是唯一确定的。在牛顿基下，其形式为：\n$$\np_n(x) \\;=\\; \\sum_{k=0}^{n} c_k \\prod_{j=0}^{k-1} (x - x_j)\n$$\n在数值构建中，这种表示法通常优于单项式基，因为后者常常导致一个严重病态的范德蒙矩阵。\n\n系数 $c_k$ 是差商，定义为 $c_k = f[x_0, \\dots, x_k]$。它们通过递归方式计算：\n$$\nf[x_i] \\;=\\; f(x_i)\n$$\n$$\nf[x_i, \\dots, x_j] \\;=\\; \\frac{f[x_{i+1}, \\dots, x_j] - f[x_i, \\dots, x_{j-1}]}{x_j - x_i}\n$$\n在数值上，这些系数是通过构建一个差商表来生成的。所需的系数 $c_k = f[x_0, \\dots, x_k]$ 构成了这个表的顶部对角线。\n\n一旦系数 $\\{c_k\\}_{k=0}^n$ 被确定，多项式 $p_n(x)$ 就会在指定的求值网格 $T$ 中的每个点 $t$ 上进行求值。为了数值稳定性和效率，求值过程采用霍纳法（Horner's method，或称嵌套求值）：\n$$\np_n(t) = ((\\dots(c_n(t-x_{n-1}) + c_{n-1})(t-x_{n-2}) + \\dots) + c_1)(t-x_0) + c_0\n$$\n与逐项直接求和相比，该方法最小化了算术运算的次数，并减少了浮点误差的累积。\n\n最终误差计算为 $E = \\max_{t \\in T} |p_n(t) - f(t)|$。如果在任何阶段产生了非有限值（如 `Infinity` 或 `NaN`），该用例的误差则报告为 $E = +\\infty$。\n\n四个测试用例旨在探究此数值过程的不同方面：\n\n用例 A：函数 $f(x) = \\frac{1}{1+25x^2}$，在 $[-1, 1]$ 上使用 $n=20$ 个等距节点。这是龙格现象 (Runge's phenomenon) 的典型例子。对于此函数，使用等距节点进行高阶多项式插值时，在区间端点附近会发散，导致大幅振荡和巨大的误差 $E$。这是逼近方法本身的性质，而有限精度效应会加剧此问题。\n\n用例 B：函数 $f(x) = e^x$，在 $[-1, 1]$ 上使用 $n=30$ 个切比雪夫节点。函数 $e^x$ 在整个复平面上是解析的。在切比雪夫节点上对解析函数进行插值，在精确算术中已知会以指数速度收敛。切比雪夫节点 $x_k = \\cos(k\\pi/n)$ 在端点附近聚集，这恰好是抵消龙格现象 (Runge's phenomenon) 所需的特性。因此，预计会得到一个非常小的误差 $E$，这表明这是一个良态问题。\n\n用例 C：函数 $f(x) = \\sin(x)$，使用 $n=18$ 个节点 $x_k = 10^{-k}$（其中 $k=18,17,\\dots,0$）。这些节点在 $x=0$ 附近极度聚集。差商的递归计算涉及到形如 $x_j - x_i$ 的分母，其值将非常小。此外，分子是两个几乎相等的值之差，会遭受灾难性抵消，导致相对精度的严重损失。这种严重的数值不稳定性预计会破坏系数 $c_k$，可能使它们变为非有限值，或产生一个巨大而无意义的误差 $E$。\n\n用例 D：函数 $f(x) = e^x$，在 $[-1, 1]$ 上使用 $n=80$ 个切比雪夫节点。此用例将用例 B 扩展到了一个更高的阶数。尽管理论预测插值会继续收敛，但该测试挑战了双精度算术下稳定性的极限。即使使用最优节点，对于像 $n=80$ 这样的高阶情况，经过大量运算后微小浮点误差的累积也可能变得显著。此用例将揭示即使在有利条件下，高阶插值的实践极限。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_newton_coeffs(x_nodes: np.ndarray, y_nodes: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the coefficients of the Newton interpolating polynomial.\n    \n    Args:\n        x_nodes: The interpolation nodes (n+1 points).\n        y_nodes: The function values at the interpolation nodes (n+1 values).\n    \n    Returns:\n        An array of the n+1 Newton coefficients.\n    \"\"\"\n    n = len(x_nodes)\n    # Use a copy to avoid modifying the original y_nodes array if it was passed.\n    # Ensure all calculations are done in float64.\n    coeffs = np.copy(y_nodes).astype(np.float64)\n    \n    # Iterate to compute the divided differences\n    for j in range(1, n):\n        for i in range(n - 1, j - 1, -1):\n            denominator = x_nodes[i] - x_nodes[i - j]\n            # The problem statement guarantees distinct nodes, but in a general\n            # setting, a zero denominator would lead to non-finite results.\n            # numpy handles division by zero, resulting in inf, which is\n            # handled later as per the problem requirements.\n            coeffs[i] = (coeffs[i] - coeffs[i - 1]) / denominator\n            \n    return coeffs\n\ndef evaluate_newton_poly(x_nodes: np.ndarray, coeffs: np.ndarray, t_eval: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Evaluates the Newton polynomial at given points using Horner's method.\n    \n    Args:\n        x_nodes: The interpolation nodes.\n        coeffs: The Newton coefficients.\n        t_eval: The points at which to evaluate the polynomial.\n        \n    Returns:\n        The polynomial values at the evaluation points.\n    \"\"\"\n    n = len(coeffs)\n    p_values = np.zeros_like(t_eval, dtype=np.float64)\n    \n    for i, t in enumerate(t_eval):\n        # Horner's method for a single evaluation point t\n        val = coeffs[n - 1]\n        for k in range(n - 2, -1, -1):\n            val = val * (t - x_nodes[k]) + coeffs[k]\n        p_values[i] = val\n        \n    return p_values\n\ndef solve():\n    \"\"\"\n    Solves the interpolation problem for all four specified test cases.\n    \"\"\"\n    test_cases = [\n        # Case A: Runge's phenomenon\n        {\n            'f': lambda x: 1.0 / (1.0 + 25.0 * x**2),\n            'interval': np.array([-1.0, 1.0], dtype=np.float64),\n            'n': 20,\n            'node_type': 'equidistant',\n            'm': 1001\n        },\n        # Case B: Well-conditioned problem\n        {\n            'f': lambda x: np.exp(x),\n            'interval': np.array([-1.0, 1.0], dtype=np.float64),\n            'n': 30,\n            'node_type': 'chebyshev',\n            'm': 1001\n        },\n        # Case C: Extreme node clustering\n        {\n            'f': lambda x: np.sin(x),\n            'interval': np.array([0.0, 1.0], dtype=np.float64),\n            'n': 18,\n            'node_type': 'custom_clustered',\n            'm': 1001\n        },\n        # Case D: Very high degree with good nodes\n        {\n            'f': lambda x: np.exp(x),\n            'interval': np.array([-1.0, 1.0], dtype=np.float64),\n            'n': 80,\n            'node_type': 'chebyshev',\n            'm': 1001\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        n = case['n']\n        f = case['f']\n        interval = case['interval']\n        m = case['m']\n\n        # Step 1: Generate interpolation nodes\n        if case['node_type'] == 'equidistant':\n            x_nodes = np.linspace(interval[0], interval[1], n + 1, dtype=np.float64)\n        elif case['node_type'] == 'chebyshev':\n            k = np.arange(n + 1, dtype=np.float64)\n            # Chebyshev nodes of the second kind on [-1, 1]\n            x_nodes = np.cos(k * np.pi / n)\n        elif case['node_type'] == 'custom_clustered':\n            k = np.arange(18, -1, -1, dtype=np.float64)\n            x_nodes = 10.0**(-k)\n        \n        y_nodes = f(x_nodes)\n\n        # Step 2: Compute Newton coefficients\n        coeffs = compute_newton_coeffs(x_nodes, y_nodes)\n\n        # Check for non-finite coefficients\n        if not np.all(np.isfinite(coeffs)):\n            results.append(np.inf)\n            continue\n            \n        # Step 3: Evaluate polynomial and true function on the grid\n        t_eval = np.linspace(interval[0], interval[1], m, dtype=np.float64)\n        p_values = evaluate_newton_poly(x_nodes, coeffs, t_eval)\n\n        # Check for non-finite evaluation results\n        if not np.all(np.isfinite(p_values)):\n            results.append(np.inf)\n            continue\n            \n        f_values = f(t_eval)\n\n        # Step 4: Compute the maximum absolute error\n        error = np.max(np.abs(p_values - f_values))\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2409001"}, {"introduction": "在许多工程和科学应用中，我们需要从测量数据中估计导数，例如从位移数据计算速度。本练习深入探讨了将高次多项式插值应用于含噪声数据并求导的危险后果。您将分析微小的测量噪声在对插值函数求导时如何被急剧放大，从而使结果失去意义，并理解节点的策略性选择（如切比雪夫节点）是如何缓解这一关键问题的 [@problem_id:2409024]。", "problem": "一位计算工程师在一个时间区间 $[-1,1]$ 内记录了一个来自机械系统的一维位移信号 $s(t)$。已知该信号足够光滑，具体来说，对于某个整数 $m \\ge 2$，有 $s \\in C^{m}([-1,1])$。该工程师在 $[-1,1]$ 区间内的 $n+1$ 个不同节点 $x_0, x_1, \\dots, x_n$ 上对 $s(t)$ 进行采样，并构建了一个次数至多为 $n$ 的唯一多项式 $p_n(t)$，该多项式对测量数据 $\\{(x_i, y_i)\\}_{i=0}^n$ 进行插值，其中 $y_i = s(x_i) + \\eta_i$。考虑了两种噪声模式：\n- 有界噪声：对于一个固定的 $\\varepsilon > 0$，有 $|\\eta_i| \\le \\varepsilon$。\n- 随机噪声：$\\eta_i$ 是独立的、零均值的随机变量，其方差为 $\\operatorname{Var}(\\eta_i) = \\sigma^2$。\n\n该工程师使用导数 $p_n'(t)$ 作为真实速度 $v(t) = s'(t)$ 的近似，并且，在力计算的背景下，如果再次求导，则将其作为加速度的近似。假设该工程师关心在一个固定的内点 $x_0 \\in (-1,1)$ 处的 $p_n'(x_0)$。考虑在区间 $[-1,1]$ 上选择等距节点和第一类切比雪夫节点这两种情况。\n\n关于误差传播到 $p_n'(x_0)$ 的影响，以下哪些陈述是正确的？选择所有适用项。\n\nA. 对于 $[-1,1]$ 上的等距节点和一个固定的内点 $x_0$，从数据扰动 $\\{\\eta_i\\}$（其中 $|\\eta_i| \\le \\varepsilon$）到导数误差 $|p_n'(x_0) - \\tilde p_n'(x_0)|$（其中 $\\tilde p_n$ 是扰动数据的插值多项式）的映射，其算子范数随着 $n$ 的增加而无界增长。\n\nB. 将等距节点切换为切比雪夫节点可以减少数据扰动在 $p_n'(x_0)$ 中最坏情况下的放大效应；特别地，使用切比雪夫节点时的放大效应至多以多项式级别（而非指数级别）随 $n$ 增长。\n\nC. 即使数据精确（$\\eta_i = 0$），如果 $s$ 在 $[-1,1]$ 上是解析的并且节点是等距的，那么最大点态导数误差 $\\max_{x \\in [-1,1]} |s'(x) - p_n'(x)|$ 必然随着 $n$ 的增加而单调递减至 $0$。\n\nD. 在具有独立、零均值、共同方差 $\\sigma^2$ 的随机噪声模型下，有 $\\operatorname{Var}(p_n'(x_0)) = \\sigma^2 \\sum_{i=0}^n \\left(\\ell_i'(x_0)\\right)^2$，其中 $\\ell_i$ 是所选节点的拉格朗日基多项式。因此，对于等距节点，$p_n'(x_0)$ 的标准差会随着 $n$ 的增加而显著增长。", "solution": "首先必须验证问题陈述的科学合理性和一致性。\n\n### 第一步：提取已知条件\n- 一个位移信号 $s(t)$，它是一个属于 $C^{m}([-1,1])$ 类的函数，其中 $m \\ge 2$ 为某个整数。\n- 时间区间为 $[-1,1]$。\n- 区间 $[-1,1]$ 内的一组 $n+1$ 个不同的插值节点 $\\{x_i\\}_{i=0}^n$。\n- 测量数据为 $(x_i, y_i)$，其中 $i=0, \\dots, n$。\n- 测量数据与真实信号之间的关系是 $y_i = s(x_i) + \\eta_i$，其中 $\\eta_i$ 是一个噪声项。\n- 考虑两种噪声模型：\n    1. 有界噪声：对于一个常数 $\\varepsilon > 0$，有 $|\\eta_i| \\le \\varepsilon$。\n    2. 随机噪声：$\\eta_i$ 是独立的、零均值（$\\mathbb{E}[\\eta_i] = 0$）的随机变量，具有共同方差 $\\operatorname{Var}(\\eta_i) = \\sigma^2$。\n- 通过数据点 $\\{(x_i, y_i)\\}_{i=0}^n$ 构建一个次数至多为 $n$ 的插值多项式 $p_n(t)$。\n- 插值多项式的导数 $p_n'(t)$ 被用作真实速度 $s'(t)$ 的一个近似。\n- 分析集中在某个固定内点 $x_0 \\in (-1,1)$ 的导数误差上。题目似乎暗示求值点 $x_0$ 也是插值节点之一。这是一个记号上的选择，我们将予以尊重。\n- 考虑两组节点：等距节点和 $[-1,1]$ 上的第一类切比雪夫节点。\n\n### 第二步：使用提取的已知条件进行验证\n该问题描述了数值分析和计算科学中的一个经典场景：使用多项式插值对带噪数据进行微分。在许多需要从采样测量中估计导数的工程应用中，这项任务是基础性的。\n\n- **科学依据**：该问题牢固地植根于多项式插值、数值微分和误差分析的理论。拉格朗日多项式、切比雪夫节点、龙格现象和误差传播等概念都是数学和工程领域中标准且已被充分研究的课题。该问题在科学上是合理的。\n- **适定性**：对于 $n+1$ 个不同的节点，插值多项式 $p_n(t)$ 的存在性和唯一性是有保证的。所提出的问题是关于当节点数 $n$ 增加时误差度量的渐进行为，这些是明确定义的数学问题。\n- **客观性**：问题以精确、客观的数学语言陈述。没有主观或含糊的术语。使用 $x_0$ 同时表示一个特定节点和节点序列中的第一个元素，这一记号选择虽然有点令人困惑，但并未造成逻辑矛盾，因为节点可以任意标记。对于任何在 $[-1,1]$ 上且 $n>1$ 的节点集，等距节点集和切比雪夫节点集都包含内点。可以选择其中一个点作为 $x_0$ 进行分析。\n\n### 第三步：结论与行动\n问题陈述是有效的。这是一个数值分析领域中适定且具有科学依据的问题。现在可以推导解决方案。\n\n通过点 $\\{(x_i, y_i)\\}_{i=0}^n$ 的插值多项式 $p_n(t)$ 可以用拉格朗日基写成：\n$$p_n(t) = \\sum_{i=0}^n y_i \\ell_i(t)$$\n其中 $\\ell_i(t)$ 是拉格朗日基多项式，定义为\n$$\\ell_i(t) = \\prod_{j=0, j \\neq i}^n \\frac{t-x_j}{x_i-x_j}$$\n插值多项式的导数是：\n$$p_n'(t) = \\sum_{i=0}^n y_i \\ell_i'(t)$$\n令 $p_n^*(t)$ 是对精确、无噪声数据进行插值的假设多项式，即 $p_n^*(t) = \\sum_{i=0}^n s(x_i) \\ell_i(t)$。对带噪数据进行插值的多项式是 $p_n(t) = \\sum_{i=0}^n (s(x_i) + \\eta_i) \\ell_i(t)$。由数据噪声 $\\eta_i$ 引起的多项式导数误差为：\n$$\\Delta p_n'(t) \\equiv p_n'(t) - p_n^{*\\prime}(t) = \\sum_{i=0}^n \\eta_i \\ell_i'(t)$$\n问题询问的是这个误差在固定内点 $x_0 \\in (-1,1)$ 处的大小。选项A中将扰动数据的插值多项式称为 $\\tilde{p}_n$；我们把问题陈述中的 $p_n$ 等同于 $\\tilde{p}_n$，把 $p_n^*$ 等同于未受扰动的多项式。因此，选项A中的量 $|p_n'(x_0) - \\tilde{p}_n'(x_0)|$ 对应于 $|\\Delta p_n'(x_0)| = |\\sum_{i=0}^n \\eta_i \\ell_i'(x_0)|$，其中一组数据有 $\\eta_i=0$。\n\n现在我们逐一评估每个选项。\n\n**A. 对于 $[-1,1]$ 上的等距节点和一个固定的内点 $x_0$，从数据扰动 $\\{\\eta_i\\}$（其中 $|\\eta_i| \\le \\varepsilon$）到导数误差 $|p_n'(x_0) - \\tilde p_n'(x_0)|$（其中 $\\tilde p_n$ 是扰动数据的插值多项式）的映射，其算子范数随着 $n$ 的增加而无界增长。**\n\n导数的误差是 $\\Delta p_n'(x_0) = \\sum_{i=0}^n \\eta_i \\ell_i'(x_0)$。在有界噪声模型下，有 $|\\eta_i| \\le \\varepsilon$。最坏情况下的误差是通过对所有可能的扰动取最大值得到的：\n$$\\max_{|\\eta_i| \\le \\varepsilon} |\\Delta p_n'(x_0)| = \\max_{|\\eta_i| \\le \\varepsilon} \\left| \\sum_{i=0}^n \\eta_i \\ell_i'(x_0) \\right| = \\varepsilon \\sum_{i=0}^n |\\ell_i'(x_0)|$$\n从扰动向量 $\\vec{\\eta} = (\\eta_0, \\dots, \\eta_n)$（使用 $\\ell_\\infty$ 范数 $\\|\\vec{\\eta}\\|_\\infty = \\max_i |\\eta_i|$）到标量输出 $\\Delta p_n'(x_0)$ 的线性映射的算子范数是放大因子 $\\sum_{i=0}^n |\\ell_i'(x_0)|$。这个量是在点 $x_0$ 进行微分的条件数。\n对于 $[-1,1]$ 上的等距节点，数值分析中一个公认的结论是，这个条件数随 $n$ 指数增长。其根本原因与龙格现象有关；拉格朗日基函数的导数会变得非常大，尤其是在边界附近，但即使在内点，增长也是指数级的。由于指数增长是无界的，该陈述是正确的。\n**结论：正确。**\n\n**B. 将等距节点切换为切比雪夫节点可以减少数据扰动在 $p_n'(x_0)$ 中最坏情况下的放大效应；特别地，使用切比雪夫节点时的放大效应至多以多项式级别（而非指数级别）随 $n$ 增长。**\n\n最坏情况下的放大因子是 $\\sum_{i=0}^n |\\ell_i'(x_0)|$。正如在A中所述，对于等距节点，这个因子呈指数增长。对于第一类切比雪夫节点（$x_i = \\cos(\\frac{(2i+1)\\pi}{2(n+1)})$），插值多项式及其导数的行为要好得多。勒贝格常数 $\\Lambda_n = \\max_{x \\in [-1,1]} \\sum_{i=0}^n |\\ell_i(x)|$ 仅以 $O(\\log n)$ 的速度增长。微分的条件数 $\\sum_{i=0}^n |\\ell_i'(x_0)|$ 的行为也更好。对于任何固定点 $x_0 \\in [-1,1]$，已知这个和被一个关于 $n$ 的多项式所约束。具体来说，对于内点 $x_0 \\in (-1,1)$，这个和以 $O(n^2)$ 的速度增长。\n从等距节点的指数增长切换到切比雪夫节点的多项式（$O(n^2)$）增长，是误差放大效应的一个显著减小。因此，该陈述是正确的。\n**结论：正确。**\n\n**C. 即使数据精确（$\\eta_i = 0$），如果 $s$ 在 $[-1,1]$ 上是解析的并且节点是等距的，那么最大点态导数误差 $\\max_{x \\in [-1,1]} |s'(x) - p_n'(x)|$ 必然随着 $n$ 的增加而单调递减至 $0$。**\n\n该陈述关注的是逼近误差，而不是数据噪声的传播。它声称对于任何解析函数 $s(t)$，基于等距节点的插值多项式导数 $p_n'(t)$ 会一致且单调地收敛于真实导数 $s'(t)$。这是错误的。\n一个著名的事实是，对于等距节点，多项式插值并不能保证对所有解析函数都一致收敛。经典的例子是龙格函数 $s(x) = 1/(1+25x^2)$，对于这个函数，最大插值误差 $\\max_{x \\in [-1,1]}|s(x) - p_n(x)|$ 在 $n \\to \\infty$ 时是发散的。导数的误差 $|s'(x) - p_n'(x)|$ 通常表现得更差，因为微分会放大误差 $s(x) - p_n(x)$ 的高频振荡。因此，不保证导数会一致收敛到零。\n关于误差“必然单调递减”的附加声明也是错误的。数值方法中的误差很少表现出严格的单调行为；当参数 $n$ 变化时，它通常会振荡。\n**结论：不正确。**\n\n**D. 在具有独立、零均值、共同方差 $\\sigma^2$ 的随机噪声模型下，有 $\\operatorname{Var}(p_n'(x_0)) = \\sigma^2 \\sum_{i=0}^n \\left(\\ell_i'(x_0)\\right)^2$，其中 $\\ell_i$ 是所选节点的拉格朗日基多项式。因此，对于等距节点，$p_n'(x_0)$ 的标准差会随着 $n$ 的增加而显著增长。**\n\n插值多项式的导数是 $p_n'(x_0) = \\sum_{i=0}^n y_i \\ell_i'(x_0)$。数据点是 $y_i = s(x_i) + \\eta_i$。由于 $s(x_i)$ 和 $\\ell_i'(x_0)$ 是确定性常数，$p_n'(x_0)$ 的方差完全由噪声项 $\\eta_i$ 引起。\n$$\\operatorname{Var}(p_n'(x_0)) = \\operatorname{Var}\\left(\\sum_{i=0}^n (s(x_i) + \\eta_i) \\ell_i'(x_0)\\right) = \\operatorname{Var}\\left(\\sum_{i=0}^n \\eta_i \\ell_i'(x_0)\\right)$$\n由于噪声项 $\\eta_i$ 是独立的，和的方差等于各项方差的和：\n$$\\operatorname{Var}(p_n'(x_0)) = \\sum_{i=0}^n \\operatorname{Var}(\\eta_i \\ell_i'(x_0)) = \\sum_{i=0}^n (\\ell_i'(x_0))^2 \\operatorname{Var}(\\eta_i)$$\n给定对所有 $i$ 都有 $\\operatorname{Var}(\\eta_i) = \\sigma^2$，我们得到：\n$$\\operatorname{Var}(p_n'(x_0)) = \\sum_{i=0}^n (\\ell_i'(x_0))^2 \\sigma^2 = \\sigma^2 \\sum_{i=0}^n (\\ell_i'(x_0))^2$$\n该陈述的第一部分是正确的。\n标准差是 $\\operatorname{StdDev}(p_n'(x_0)) = \\sqrt{\\operatorname{Var}(p_n'(x_0))} = \\sigma \\sqrt{\\sum_{i=0}^n (\\ell_i'(x_0))^2}$。\n项 $\\sqrt{\\sum_{i=0}^n (\\ell_i'(x_0))^2}$ 是在 $x_0$ 处求值的导数基函数向量的欧几里得范数（$\\ell_2$-范数）。正如在A部分所确定的，对于等距节点，该向量的 $\\ell_1$-范数 $\\sum_{i=0}^n |\\ell_i'(x_0)|$ 呈指数增长。根据有限维向量空间中范数的等价性（在 $\\mathbb{R}^{n+1}$ 上，$\\|\\cdot\\|_1$ 和 $\\|\\cdot\\|_2$ 等价），我们有 $\\|\\mathbf{v}\\|_2 \\le \\|\\mathbf{v}\\|_1 \\le \\sqrt{n+1}\\|\\mathbf{v}\\|_2$。由于 $\\|\\mathbf{v}\\|_1$ 指数增长，而 $\\sqrt{n+1}$ 仅多项式增长，因此 $\\|\\mathbf{v}\\|_2$ 也必须指数增长。所以，导数误差的标准差呈指数增长，即“显著”增长。该陈述的第二部分也是正确的。\n**结论：正确。**", "answer": "$$\\boxed{ABD}$$", "id": "2409024"}]}