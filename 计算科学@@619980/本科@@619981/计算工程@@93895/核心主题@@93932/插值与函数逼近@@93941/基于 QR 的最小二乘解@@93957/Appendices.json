{"hands_on_practices": [{"introduction": "许多现实世界中的工程和科学问题本质上是“不适定的”或“病态的”，这意味着输入数据的微小扰动可能导致解发生剧烈变化。Tikhonov 正则化是一种应对该挑战的经典而强大的技术，它通过在最小二乘目标函数中加入一个惩罚项来约束解的范数，从而获得稳定且有意义的解。本练习将指导你如何通过构建一个增广系统，并利用数值稳定的 QR 分解来高效地实现 Tikhonov 正则化，这是解决反问题和数据科学中各种挑战的核心技能。[@problem_id:2430326]", "problem": "您需要实现一个程序，该程序使用基于正交三角分解（也称为 QR 分解）的因式分解方法，来计算 Tikhonov 正则化最小二乘解。该问题通过一个增广超定系统求解正则化最小二乘问题，以解决不适定或病态的线性系统。\n\n出发点与基本原理：对于给定的矩阵 $A \\in \\mathbb{R}^{m \\times n}$、数据向量 $b \\in \\mathbb{R}^{m}$ 和正则化参数 $\\lambda \\ge 0$，正则化最小二乘问题旨在寻找一个向量 $x \\in \\mathbb{R}^{n}$，以最小化目标函数 $\\lVert A x - b \\rVert_2^2 + \\lambda^2 \\lVert x \\rVert_2^2$，其中 $\\lVert \\cdot \\rVert_2$ 表示欧几里得范数。这可以通过考虑增广系统 $\\begin{pmatrix} A \\\\ \\lambda I \\end{pmatrix} x \\approx \\begin{pmatrix} b \\\\ 0 \\end{pmatrix}$ 重新表述为一个标准最小二乘问题，其中 $I \\in \\mathbb{R}^{n \\times n}$ 是单位矩阵，$0 \\in \\mathbb{R}^{n}$ 是零向量。\n\n您的任务是：\n1. 实现一个函数，在给定 $A$、$b$ 和 $\\lambda$ 的情况下，构建增广矩阵 $C = \\begin{pmatrix} A \\\\ \\lambda I \\end{pmatrix}$ 和增广右端项 $d = \\begin{pmatrix} b \\\\ 0 \\end{pmatrix}$，计算经济型 QR 分解 $C = Q R$（其中 $Q \\in \\mathbb{R}^{(m+n) \\times n}$ 具有标准正交列，$R \\in \\mathbb{R}^{n \\times n}$ 是上三角矩阵），然后通过回代法求解三角系统 $R x = Q^\\top d$ 以得到 $x$。不要构建或求解正规方程，也不要使用奇异值分解。\n2. 对于下面列出的每个测试用例，使用您基于 QR 的方法所获得的解 $x$，计算增广残差的欧几里得范数，其定义为 $\\lVert C x - d \\rVert_2 = \\left\\lVert \\begin{pmatrix} A \\\\ \\lambda I \\end{pmatrix} x - \\begin{pmatrix} b \\\\ 0 \\end{pmatrix} \\right\\rVert_2$。\n3. 生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的浮点数列表，每个浮点数四舍五入到六位小数，并按下面描述的测试用例顺序排列。\n\n算法约束：\n- 对增广系统应用正交三角分解，然后对三角因子进行回代。这利用了正交性来避免对条件数进行平方运算，而构建正规方程时会发生这种情况。\n\n测试套件：\n在以下四个确定性测试用例上实现并评估您的求解器。在下文所有定义中，索引从 $0$ 开始。\n\n- 测试用例 $1$ (超定、病态、无正则化):\n  - 维度: $m = 30$, $n = 10$。\n  - 矩阵 $A \\in \\mathbb{R}^{30 \\times 10}$，其元素定义为 $A_{i,j} = \\dfrac{1}{i + j + 1}$，其中 $0 \\le i \\le 29$ 且 $0 \\le j \\le 9$。\n  - 真实向量 $x_{\\text{true}} \\in \\mathbb{R}^{10}$，其定义为：如果 $j$ 是偶数，则 $(x_{\\text{true}})_j = 1$；如果 $j$ 是奇数，则 $(x_{\\text{true}})_j = -1$，其中 $0 \\le j \\le 9$。\n  - 噪声向量 $\\varepsilon \\in \\mathbb{R}^{30}$，其定义为 $\\varepsilon_i = 10^{-4} \\cos(i)$，其中 $0 \\le i \\le 29$。\n  - 右端项 $b = A x_{\\text{true}} + \\varepsilon$。\n  - 正则化参数 $\\lambda = 0$。\n\n- 测试用例 $2$ (与测试用例 1 系统相同，但进行正则化):\n  - 使用与测试用例 $1$ 中相同的 $A$、$x_{\\text{true}}$、$\\varepsilon$ 和 $b$。\n  - 正则化参数 $\\lambda = 10^{-2}$。\n\n- 测试用例 $3$ (方阵、秩亏、精确数据、轻微正则化):\n  - 维度: $m = 8$, $n = 6$。\n  - 按如下方式构造列向量 $c_k \\in \\mathbb{R}^{8}$：\n    - $c_0$ 是一个向量，其元素为 $c_{0,i} = 1 + \\dfrac{i}{7}$，其中 $0 \\le i \\le 7$。\n    - $c_1 = c_0$（重复列以确保秩亏）。\n    - $c_2$ 的元素为 $c_{2,i} = \\sin\\!\\left(\\dfrac{\\pi i}{7}\\right)$。\n    - $c_3$ 的元素为 $c_{3,i} = \\cos\\!\\left(\\dfrac{\\pi i}{3}\\right)$。\n    - $c_4 = c_2 + c_3$。\n    - $c_5$ 是一个常数向量，其所有元素均为 $1$。\n  - 构成矩阵 $A = [c_0\\, c_1\\, c_2\\, c_3\\, c_4\\, c_5] \\in \\mathbb{R}^{8 \\times 6}$。\n  - 定义 $x_{\\text{true}} \\in \\mathbb{R}^{6}$，其元素为 $(x_{\\text{true}})_j = [0.5, -0.5, 1.0, -1.0, 0.0, 2.0]_j$，其中 $0 \\le j \\le 5$。\n  - 右端项 $b = A x_{\\text{true}}$。\n  - 正则化参数 $\\lambda = 10^{-6}$。\n\n- 测试用例 $4$ (欠定、含噪声、正则化):\n  - 维度: $m = 5$, $n = 10$。\n  - 矩阵 $A \\in \\mathbb{R}^{5 \\times 10}$，其元素为 $A_{i,j} = \\sin(i + j) + \\cos(2 i + 3 j)$，其中 $0 \\le i \\le 4$ 且 $0 \\le j \\le 9$，其中三角函数以弧度为参数。\n  - 真实向量 $x_{\\text{true}} \\in \\mathbb{R}^{10}$，其元素为 $(x_{\\text{true}})_j = \\sin(j)$，其中 $0 \\le j \\le 9$。\n  - 噪声向量 $\\varepsilon \\in \\mathbb{R}^{5}$，其元素为 $\\varepsilon_i = 10^{-5} \\sin(i)$，其中 $0 \\le i \\le 4$。\n  - 右端项 $b = A x_{\\text{true}} + \\varepsilon$。\n  - 正则化参数 $\\lambda = 10^{-1}$。\n\n输出规格：\n- 对于每个测试用例 $k \\in \\{1,2,3,4\\}$，使用您基于 QR 的解 $x$ 计算标量 $r_k = \\left\\lVert \\begin{pmatrix} A \\\\ \\lambda I \\end{pmatrix} x - \\begin{pmatrix} b \\\\ 0 \\end{pmatrix} \\right\\rVert_2$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、按 $[r_1, r_2, r_3, r_4]$ 顺序排列的逗号分隔列表，其中每个 $r_k$ 四舍五入至六位小数，例如 $[0.123456,0.234567,0.345678,0.456789]$。\n\n角度单位：\n- 所有三角函数均使用弧度参数。\n\n此问题不涉及物理单位。\n\n您的实现必须是完全确定性的，并且不得依赖用户输入或外部数据。程序必须是一个完整的、可运行的脚本，且仅打印所需的输出行。", "solution": "所提出的问题是有效且适定的。它解决了计算科学中的一个基本任务：使用 Tikhonov 正则化对病态或欠定线性系统进行稳定求解。所指定的方法依赖于对增广系统进行正交三角 ($QR$) 分解，这是一种标准且数值稳健的技术。\n\n其目标是找到一个向量 $x \\in \\mathbb{R}^{n}$，以最小化 Tikhonov 正则化目标函数：\n$$ \\underset{x}{\\text{minimize}} \\quad \\lVert A x - b \\rVert_2^2 + \\lambda^2 \\lVert x \\rVert_2^2 $$\n其中 $A \\in \\mathbb{R}^{m \\times n}$ 是系统矩阵，$b \\in \\mathbb{R}^{m}$ 是数据向量，$\\lambda \\ge 0$ 是正则化参数。项 $\\lambda^2 \\lVert x \\rVert_2^2$ 惩罚具有大范数的解，这对于在 $A$ 是病态或秩亏时稳定问题至关重要。\n\n该目标函数可以表示为单个向量的欧几里得范数的平方，从而将问题转化为标准线性最小二乘格式。我们构造一个增广矩阵 $C \\in \\mathbb{R}^{(m+n) \\times n}$ 和一个增广向量 $d \\in \\mathbb{R}^{m+n}$：\n$$ C = \\begin{pmatrix} A \\\\ \\lambda I \\end{pmatrix}, \\quad d = \\begin{pmatrix} b \\\\ 0 \\end{pmatrix} $$\n此处，$I$ 是 $n \\times n$ 的单位矩阵，$0$ 是 $\\mathbb{R}^{n}$ 中的零向量。原始的最小化问题等价于：\n$$ \\underset{x}{\\text{minimize}} \\quad \\left\\lVert \\begin{pmatrix} A \\\\ \\lambda I \\end{pmatrix} x - \\begin{pmatrix} b \\\\ 0 \\end{pmatrix} \\right\\rVert_2^2 = \\underset{x}{\\text{minimize}} \\quad \\lVert C x - d \\rVert_2^2 $$\n此最小二乘问题的解 $x$ 满足正规方程：\n$$ C^\\top C x = C^\\top d $$\n然而，问题陈述正确地禁止显式构造矩阵 $C^\\top C$。这是因为 $C^\\top C$ 的条件数是 $C$ 的条件数的平方，即 $\\kappa(C^\\top C) = \\kappa(C)^2$。因此，构造正规方程会引入不必要的数值不稳定性，特别是对于病态系统。\n\n一种数值上更优的方法是使用 $C$ 的正交三角分解。我们计算增广矩阵 $C$ 的经济型 $QR$ 分解：\n$$ C = QR $$\n其中 $Q \\in \\mathbb{R}^{(m+n) \\times n}$ 是一个具有标准正交列的矩阵（即 $Q^\\top Q = I_n$），$R \\in \\mathbb{R}^{n \\times n}$ 是一个上三角矩阵。\n\n将 $C = QR$ 代入最小二乘问题，我们寻求最小化 $\\lVert QRx - d \\rVert_2$。由于 $Q$ 具有标准正交列，乘以 $Q^\\top$ 能够保持 $Q$ 列空间中残差分量的欧几里得范数。通过求解变换后的系统找到解 $x$。代入正规方程得到：\n$$ (QR)^\\top (QR) x = (QR)^\\top d $$\n$$ R^\\top Q^\\top Q R x = R^\\top Q^\\top d $$\n$$ R^\\top R x = R^\\top Q^\\top d $$\n为使问题有唯一解，矩阵 $R$ 必须是可逆的。如果 $\\lambda > 0$，即使 $A$ 不是满列秩，矩阵 $C$ 也保证是满列秩的。这是因为对应于 $\\lambda I$ 的行确保了 $C$ 的列的线性无关性。因此，上三角矩阵 $R$ 将是满秩的，因而是可逆的。如果 $\\lambda = 0$ 且 $A$ 是满列秩，则 $R$ 也是可逆的。在这些情况下，我们可以乘以 $(R^\\top)^{-1}$ 以获得上三角系统：\n$$ R x = Q^\\top d $$\n该系统可以通过回代法高效地求解出 $x$。\n\n一旦计算出解向量 $x$，最后一步是按要求计算增广残差的欧几里得范数。这可直接计算：\n$$ r = \\lVert C x - d \\rVert_2 = \\left\\lVert \\begin{pmatrix} A \\\\ \\lambda I \\end{pmatrix} x - \\begin{pmatrix} b \\\\ 0 \\end{pmatrix} \\right\\rVert_2 $$\n此过程将应用于四个指定的测试用例中的每一个。每个用例的矩阵和向量的构造都严格按照问题陈述中的定义执行。最终输出由计算出的残差范数组成。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_triangular\n\ndef solve_regularized_ls_qr(A, b, lam):\n    \"\"\"\n    Solves the Tikhonov-regularized least squares problem min ||Ax-b||^2 + lam^2||x||^2\n    using QR factorization of the augmented system.\n\n    Args:\n        A (np.ndarray): The matrix A of shape (m, n).\n        b (np.ndarray): The vector b of shape (m,).\n        lam (float): The regularization parameter lambda.\n\n    Returns:\n        float: The Euclidean norm of the augmented residual, ||Cx - d||_2.\n    \"\"\"\n    m, n = A.shape\n\n    # 1. Construct the augmented matrix C and augmented vector d.\n    if lam > 0:\n        C = np.vstack((A, lam * np.eye(n)))\n    else:\n        # Handle lambda = 0 case to avoid creating a zero matrix and then multiplying\n        C = np.vstack((A, np.zeros((n, n))))\n        \n    d = np.hstack((b, np.zeros(n)))\n\n    # 2. Compute the economy-size QR factorization of C.\n    Q, R = np.linalg.qr(C, mode='reduced')\n\n    # 3. Solve the upper triangular system Rx = Q^T d by back substitution.\n    qT_d = Q.T @ d\n    # SciPy's solver is efficient for this.\n    x = solve_triangular(R, qT_d, check_finite=False)\n\n    # 4. Compute the Euclidean norm of the augmented residual.\n    residual_norm = np.linalg.norm(C @ x - d)\n    \n    return residual_norm\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = []\n\n    # Test case 1: overdetermined, ill-conditioned, unregularized\n    m1, n1 = 30, 10\n    lam1 = 0.0\n    i1 = np.arange(m1)[:, np.newaxis]\n    j1 = np.arange(n1)\n    A1 = 1.0 / (i1 + j1 + 1)\n    x_true1 = np.array([(-1)**k for k in range(n1)])\n    epsilon1 = 1e-4 * np.cos(np.arange(m1))\n    b1 = A1 @ x_true1 + epsilon1\n    test_cases.append({'A': A1, 'b': b1, 'lam': lam1})\n\n    # Test case 2: same system as test case 1 but with regularization\n    lam2 = 1e-2\n    test_cases.append({'A': A1, 'b': b1, 'lam': lam2})\n\n    # Test case 3: square, rank-deficient, exact data, slight regularization\n    m3, n3 = 8, 6\n    lam3 = 1e-6\n    i3 = np.arange(m3)\n    c0 = 1 + i3 / 7.0\n    c1 = c0\n    c2 = np.sin(np.pi * i3 / 7.0)\n    c3 = np.cos(np.pi * i3 / 3.0)\n    c4 = c2 + c3\n    c5 = np.ones(m3)\n    A3 = np.column_stack([c0, c1, c2, c3, c4, c5])\n    x_true3 = np.array([0.5, -0.5, 1.0, -1.0, 0.0, 2.0])\n    b3 = A3 @ x_true3\n    test_cases.append({'A': A3, 'b': b3, 'lam': lam3})\n\n    # Test case 4: underdetermined, noisy, regularized\n    m4, n4 = 5, 10\n    lam4 = 1e-1\n    i4 = np.arange(m4)[:, np.newaxis]\n    j4 = np.arange(n4)\n    A4 = np.sin(i4 + j4) + np.cos(2 * i4 + 3 * j4)\n    x_true4 = np.sin(np.arange(n4))\n    epsilon4 = 1e-5 * np.sin(np.arange(m4))\n    b4 = A4 @ x_true4 + epsilon4\n    test_cases.append({'A': A4, 'b': b4, 'lam': lam4})\n\n    results = []\n    for case in test_cases:\n        residual = solve_regularized_ls_qr(case['A'], case['b'], case['lam'])\n        results.append(residual)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2430326"}, {"introduction": "将理论应用于实际数据是检验模型有效性的关键，时间序列分析便是一个重要的应用领域。本练习旨在通过拟合自回归（AR）模型来预测数据点的未来走向，这在金融、信号处理和控制系统等领域非常普遍。你将学习如何将 AR 模型构建为一个最小二乘问题，并使用带列主元的 QR 分解来求解模型系数，这种方法对于处理真实数据中可能存在的共线性或秩亏问题尤为稳健。[@problem_id:2430292]", "problem": "给定您时间序列数据，要求您使用基于带列主元的正交三角 (QR) 分解的数值稳定线性最小二乘法来拟合一个自回归 (AR) 模型。该模型为 $p$ 阶自回归 (AR) 模型，定义如下\n$$\nx_t \\;=\\; \\sum_{i=1}^{p} \\phi_i \\, x_{t-i} \\;+\\; \\varepsilon_t,\n$$\n其中 $x_t$ 是观测到的标量时间序列，$\\phi_i$ 是待估计的 AR 系数，$\\varepsilon_t$ 是未观测到的扰动项。\n\n基本出发点：\n- 最小二乘估计旨在最小化残差平方和\n$$\n\\min_{\\phi \\in \\mathbb{R}^p} \\;\\left\\| H \\, \\phi - y \\right\\|_2^2,\n$$\n其中 $H$ 是滞后观测值的数据矩阵，而 $y$ 是当前观测值的向量。具体来说，对于序列 $\\{x_1,\\dots,x_N\\}$ 和阶数 $p$，定义 $m = N - p$，那么对于每个 $t \\in \\{p+1,\\dots,N\\}$，$H \\in \\mathbb{R}^{m \\times p}$ 的第 $t-p$ 行为 $[x_{t-1}, x_{t-2}, \\dots, x_{t-p}]$，而 $y \\in \\mathbb{R}^{m}$ 的相应条目为 $x_t$。\n- 带列主元的正交三角 (QR) 分解是一种经过充分检验且数值稳定的方法，用于解决最小二乘问题，包括秩亏情况。如果 $H \\, P = Q \\, R$，其中 $Q$ 是标准正交矩阵，$R$ 是上三角矩阵，$P$ 是列置换矩阵，则通过截断到数值秩，可以获得秩亏情况下的最小欧几里得范数解。\n\n您的任务是编写一个完整的程序，该程序：\n1. 根据上述描述，为每个给定的时间序列 $\\{x_t\\}$ 和 AR 阶数 $p$ 构建 $H$ 和 $y$。\n2. 使用带列主元的 QR 分解计算最小二乘 AR 系数向量 $\\hat{\\phi}$。通过容差\n$$\n\\tau \\;=\\; \\max(m,p)\\, \\epsilon \\, |R_{11}|,\n$$\n来确定数值秩 $r$，其中 $\\epsilon$ 是双精度机器精度，而 $R_{11}$ 是 $R$ 的左上角元素。如果 $|R_{11}| = 0$，则取 $r = 0$。如果 $r > 0$，令 $R_1 \\in \\mathbb{R}^{r \\times r}$ 为前导三角块，$Q_1 \\in \\mathbb{R}^{m \\times r}$ 为相应的标准正交列；那么最小范数解为\n$$\n\\hat{z}_1 \\;=\\; R_1^{-1} \\, Q_1^\\top \\, y, \n\\quad\n\\hat{z}_2 \\;=\\; 0 \\in \\mathbb{R}^{p-r},\n\\quad\n\\hat{z} \\;=\\; \\begin{bmatrix}\\hat{z}_1 \\\\ \\hat{z}_2\\end{bmatrix},\n\\quad\n\\hat{\\phi} \\;=\\; P \\, \\hat{z}.\n$$\n如果 $r = 0$，则设 $\\hat{\\phi} = 0 \\in \\mathbb{R}^p$。\n3. 对于每个测试用例，输出估计的系数向量 $\\hat{\\phi}$，每个分量四舍五入到六位小数。\n\n测试套件：\n- 测试用例 $1$ (一般良态情况，精确的 2 阶 AR)：\n  - 阶数：$p = 2$。\n  - 时间序列 $\\{x_t\\}_{t=1}^{7}$: $[100.0, 110.0, 80.0, 67.5, 53.75, 43.75, 35.3125]$。\n- 测试用例 $2$ ($p = 1$ 的最小样本边界情况)：\n  - 阶数：$p = 1$。\n  - 时间序列 $\\{x_t\\}_{t=1}^{2}$: $[100.0, 102.0]$。\n- 测试用例 $3$ ($p = 2$ 的近秩亏设计，几何增长)：\n  - 阶数：$p = 2$。\n  - 时间序列 $\\{x_t\\}_{t=1}^{8}$: $[100.0, 102.0, 104.04, 106.1208, 108.243216, 110.40808032, 112.6162419264, 114.868566764928]$。\n- 测试用例 $4$ (用过参数化模型 $p = 3$ 拟合精确的一阶动态，秩亏)：\n  - 阶数：$p = 3$。\n  - 时间序列 $\\{x_t\\}_{t=1}^{8}$: $[100.0, 50.0, 25.0, 12.5, 6.25, 3.125, 1.5625, 0.78125]$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含四个测试用例的系数向量，形式为包含在方括号内的逗号分隔列表。每个系数向量本身必须是一个带方括号的、逗号分隔的列表，其中每个浮点数条目都四舍五入到六位小数。例如：$[[\\phi^{(1)}_1,\\dots,\\phi^{(1)}_{p_1}],[\\phi^{(2)}_1,\\dots],[\\phi^{(3)}_1,\\dots],[\\phi^{(4)}_1,\\dots]]$。\n- 具体来说，程序必须精确打印一行格式如下 $[[ \\cdot, \\cdot ],[ \\cdot ],[ \\cdot, \\cdot ],[ \\cdot, \\cdot, \\cdot ]]$ 的文本，数字或括号之间没有空格，每个数字格式化为六位小数。", "solution": "该问题要求估计一个 $p$ 阶自回归 (AR) 模型的系数，其形式为\n$$\nx_t = \\sum_{i=1}^{p} \\phi_i x_{t-i} + \\varepsilon_t\n$$\n其中 $\\{x_t\\}$ 是一个时间序列，$\\phi = [\\phi_1, \\dots, \\phi_p]^\\top$ 是待确定的系数向量，$\\varepsilon_t$ 是一个随机扰动项。该估计被表述为一个线性最小二乘问题，必须使用带列主元的 QR 分解来解决，以确保数值稳定性。\n\n首先，我们将问题形式化。给定一个长度为 $N$ 的时间序列 $\\{x_1, \\dots, x_N\\}$ 和一个 AR 阶数 $p$，我们构建一个线性系统。令 $m = N - p$。如果 $m \\le 0$，则数据不足以构建问题；所有提供的测试用例都满足 $m > 0$。我们定义一个响应向量 $y \\in \\mathbb{R}^m$ 和一个数据矩阵 $H \\in \\mathbb{R}^{m \\times p}$。向量 $y$ 包含待预测的观测值，矩阵 $H$ 包含用作预测变量的滞后观测值。\n$$\ny = \\begin{bmatrix} x_{p+1} \\\\ x_{p+2} \\\\ \\vdots \\\\ x_N \\end{bmatrix}, \\quad\nH = \\begin{bmatrix}\nx_p & x_{p-1} & \\cdots & x_1 \\\\\nx_{p+1} & x_p & \\cdots & x_2 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nx_{N-1} & x_{N-2} & \\cdots & x_{N-p}\n\\end{bmatrix}\n$$\nAR 模型可以表示为矩阵形式 $y \\approx H\\phi$。最小二乘估计 $\\hat{\\phi}$ 是最小化残差平方和的向量，即残差向量的欧几里得范数的平方：\n$$\n\\hat{\\phi} = \\arg\\min_{\\phi \\in \\mathbb{R}^p} \\| H\\phi - y \\|_2^2\n$$\n解决此问题的一种常用方法是通过正规方程 $H^\\top H \\phi = H^\\top y$。然而，这在数值上是不明智的。$H^\\top H$ 的条件数是 $H$ 的条件数的平方，即 $\\kappa(H^\\top H) = \\kappa(H)^2$。如果 $H$ 是病态的，则 $H^\\top H$ 将会更加病态，导致浮点运算在计算解时产生巨大误差。\n\n一种数值上更优越的方法是使用 $H$ 的正交分解。问题指定了带列主元的 QR 分解。这将计算分解 $HP = QR$，其中 $P$ 是一个 $p \\times p$ 的置换矩阵，$Q$ 是一个 $m \\times m$ 的正交矩阵（其列是标准正交的，$Q^\\top Q=I$），$R$ 是一个 $m \\times p$ 的上梯形矩阵。选择置换矩阵 $P$ 是为了确保 $R$ 的对角元素的绝对值非递增，这对于可靠地确定 $H$ 的数值秩至关重要。\n\n将 $H = QRP^{-1}$ 代入目标函数，并利用欧几里得范数在正交变换下不变的性质（即 $\\|Qz\\|_2 = \\|z\\|_2$），我们得到：\n$$\n\\| H\\phi - y \\|_2^2 = \\| QRP^{-1}\\phi - y \\|_2^2 = \\| Q(RP^{-1}\\phi - Q^\\top y) \\|_2^2 = \\| RP^{-1}\\phi - Q^\\top y \\|_2^2\n$$\n令 $z = P^{-1}\\phi$，这意味着 $\\phi = Pz$。向量 $z$ 表示与 $H$ 的置换列相对应的系数。问题变为最小化 $\\|Rz - Q^\\top y\\|_2^2$。\n\n矩阵 $H$ 可能是秩亏的或接近秩亏，特别是当底层时间序列表现出强烈的趋势或周期性时，这会导致 $H$ 的列向量（滞后观测向量）近似线性相关。带列主元的 QR 分解对这种情况具有鲁棒性。我们通过检查 $R$ 的对角元素来确定 $H$ 的数值秩 $r$。使用容差 $\\tau = \\max(m,p) \\cdot \\epsilon \\cdot |R_{11}|$，其中 $\\epsilon$ 是机器精度。秩 $r$ 是对角元素 $|R_{ii}|$ 中满足 $|R_{ii}| > \\tau$ 的数量。如果 $|R_{11}|=0$，则矩阵为零，所以 $r=0$。\n\n基于秩 $r$，我们对 $R$、$z$ 和 $c = Q^\\top y$ 进行分块：\n$$\nR = \\begin{bmatrix} R_{11} & R_{12} \\\\ 0 & R_{22} \\end{bmatrix}, \\quad z = \\begin{bmatrix} z_1 \\\\ z_2 \\end{bmatrix}, \\quad c = Q^\\top y = \\begin{bmatrix} c_1 \\\\ c_2 \\end{bmatrix}\n$$\n这里，$R_{11}$ 是一个 $r \\times r$ 的对角元素非零的上三角矩阵，$z_1 \\in \\mathbb{R}^r$，$c_1 \\in \\mathbb{R}^r$。需要最小化的范数变为：\n$$\n\\| Rz - c \\|_2^2 = \\| R_{11}z_1 + R_{12}z_2 - c_1 \\|_2^2 + \\| R_{22}z_2 - c_2 \\|_2^2\n$$\n$(m-r) \\times (p-r)$ 分块 $R_{22}$ 的对角元素在数值上为零（小于或等于 $\\tau$）。为求得最小范数解，我们设 $z_2 = 0 \\in \\mathbb{R}^{p-r}$。这一选择消除了最不确定分量的贡献。问题简化为求解 $z_1$ 的满秩上三角系统：\n$$\nR_{11} z_1 = c_1\n$$\n该系统可通过回代法高效求解。置换后系数的解为 $\\hat{z} = [\\hat{z}_1^\\top, 0, \\dots, 0]^\\top \\in \\mathbb{R}^p$。\n\n最后，通过应用置换 $P$ 来恢复原始、未置换模型的系数向量 $\\hat{\\phi}$。如果来自 QR 例程的置换索引为 `piv`，使得 `H_perm = H[:, piv]`，则系数之间的关系为 $\\hat{\\phi}_{\\text{piv}[k]} = \\hat{z}_k$。\n在数值秩 $r=0$ 的边缘情况下（例如，$H$ 是零矩阵），最小范数解就是 $\\hat{\\phi}=0$。\n\n总体算法如下：\n1. 根据时间序列 $\\{x_t\\}$ 和阶数 $p$，构建矩阵 $H$ 和向量 $y$。\n2. 计算带列主元的 QR 分解：$H P = Q R$。大多数数值库会返回 $Q$、$R$ 和一个置换索引向量。\n3. 使用指定的容差 $\\tau$ 确定数值秩 $r$。\n4. 如果 $r=0$，则设 $\\hat{\\phi}=0$。\n5. 如果 $r>0$，求解 $r \\times r$ 三角系统 $R_{1:r, 1:r} \\, \\hat{z}_{1:r} = (Q^\\top y)_{1:r}$ 以得到 $\\hat{z}_{1:r}$。\n6. 通过用 $p-r$ 个零填充 $\\hat{z}_{1:r}$ 来构造 $\\hat{z} \\in \\mathbb{R}^p$。\n7. 对 $\\hat{z}$ 应用逆置换以获得最终的系数向量 $\\hat{\\phi}$。\n这个过程可以得到 AR 系数的鲁棒且数值稳定的估计，并在秩亏情况下提供唯一的最小范数解。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import qr, solve_triangular\n\ndef solve():\n    \"\"\"\n    Main function to solve the autoregressive model fitting problem\n    for all test cases as specified.\n    \"\"\"\n\n    # Test cases as defined in the problem description.\n    test_cases = [\n        # (order p, time series x_t)\n        (2, [100.0, 110.0, 80.0, 67.5, 53.75, 43.75, 35.3125]),\n        (1, [100.0, 102.0]),\n        (2, [100.0, 102.0, 104.04, 106.1208, 108.243216, 110.40808032, 112.6162419264, 114.868566764928]),\n        (3, [100.0, 50.0, 25.0, 12.5, 6.25, 3.125, 1.5625, 0.78125]),\n    ]\n\n    results = []\n    for p, x_ts in test_cases:\n        phi_hat = estimate_ar_coeffs(np.array(x_ts, dtype=float), p)\n        results.append(phi_hat)\n\n    # Format the final output string as required.\n    # e.g., [[c1,c2],[c1],[c1,c2],[c1,c2,c3]]\n    # with 6 decimal places and no spaces.\n    output_parts = []\n    for res in results:\n        formatted_coeffs = \",\".join([f\"{c:.6f}\" for c in res])\n        output_parts.append(f\"[{formatted_coeffs}]\")\n    \n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\ndef estimate_ar_coeffs(x, p):\n    \"\"\"\n    Estimates AR(p) coefficients for a time series x using QR factorization\n    with column pivoting.\n\n    Args:\n        x (np.ndarray): The time series data.\n        p (int): The order of the autoregressive model.\n\n    Returns:\n        np.ndarray: The estimated AR coefficients phi_hat.\n    \"\"\"\n    N = len(x)\n    m = N - p\n\n    if m <= 0:\n        # Not enough data points to form the least squares problem.\n        # This case is not in the test suite but is a necessary check.\n        return np.zeros(p)\n\n    # 1. Construct the Hankel matrix H and response vector y.\n    # H is m x p, y is m x 1\n    H = np.zeros((m, p))\n    y = x[p:]\n    \n    for i in range(m):\n        # The i-th row of H corresponds to predicting x_{p+i+1}\n        # using [x_{p+i}, x_{p+i-1}, ..., x_{i+1}]\n        # In array indexing, this is y[i] from x[p+i-1:i-1:-1]\n        H[i, :] = x[i:i+p][::-1]\n\n    # 2. Compute QR factorization with column pivoting: H P = Q R\n    Q, R, piv = qr(H, pivoting=True)\n    \n    # 3. Determine numerical rank r.\n    m_eff, p_eff = H.shape\n    eps = np.finfo(float).eps\n    \n    # Check for the case where H is the zero matrix.\n    if R.shape[0] == 0 or np.abs(R[0, 0]) == 0:\n        r = 0\n    else:\n        tau = np.max(H.shape) * eps * np.abs(R[0, 0])\n        diag_R = np.abs(np.diag(R))\n        r = np.sum(diag_R > tau)\n    \n    if r == 0:\n        # If rank is 0, the minimal norm solution is phi_hat = 0.\n        return np.zeros(p)\n\n    # 4. Solve the least squares problem using the factorization.\n    # We want to solve H * phi = y, which is (Q R P^T) * phi = y\n    # Let z = P^T * phi. Then Q R z = y, or R z = Q^T y.\n    # Scipy's output `piv` is such that H[:,piv] = Q @ R.\n    # We solve for z in (H[:,piv]) @ z = y.\n    # The coefficients are then `phi[piv] = z`.\n\n    # Calculate c = Q^T * y\n    c = Q.T @ y\n\n    # 5. Solve the upper triangular system for the first r components of z.\n    # R_sub @ z_sub = c_sub\n    R1 = R[:r, :r]\n    c1 = c[:r]\n    z_hat_r = solve_triangular(R1, c1, lower=False)\n\n    # 6. Construct full z_hat vector with zeros for components beyond rank r.\n    z_hat = np.zeros(p)\n    z_hat[:r] = z_hat_r\n    \n    # 7. Apply inverse permutation to get phi_hat.\n    # The `piv` array maps new column index `j` to old column index `piv[j]`.\n    # z_hat[j] is the coefficient for old column `piv[j]`.\n    # So, phi_hat[piv[j]] = z_hat[j]\n    phi_hat = np.zeros(p)\n    phi_hat[piv] = z_hat\n        \n    return phi_hat\n\nsolve()\n```", "id": "2430292"}, {"introduction": "求解一个问题只是第一步，理解解的可靠性同样至关重要。如果我们的测量数据存在微小误差（这在实践中几乎是不可避免的），我们的解会受到多大影响？本练习将我们的关注点从“求解”转向“分析”，通过一个具体的思想实验来量化最小二乘解对数据扰动的敏感度。你将发现，问题的几何结构（由矩阵 $A$ 体现）及其 QR 分解能够揭示关于解的稳定性的深刻见解，这对于评估任何基于数据建模结果的置信度都至关重要。[@problem_id:2430336]", "problem": "给定一组独立的线性回归测试用例，每个用例由一个满列秩的实矩阵 $A \\in \\mathbb{R}^{m \\times n}$、一个基线测量向量 $b \\in \\mathbb{R}^{m}$、一个从零开始索引的下标 $p \\in \\{0,1,\\dots,m-1\\}$ 和一个标量离群值幅度 $\\delta \\in \\mathbb{R}$ 来描述。对于每个测试用例，考虑最小化 $\\lVert A x - b \\rVert_{2}$ 的基线最小二乘 (LS) 解 $x \\in \\mathbb{R}^{n}$，以及最小化 $\\lVert A x - \\tilde{b} \\rVert_{2}$ 的扰动解 $\\tilde{x} \\in \\mathbb{R}^{n}$，其中 $\\tilde{b} = b + \\delta e_{p}$ 且 $e_{p} \\in \\mathbb{R}^{m}$ 是第 $p$ 个标准基向量（其第 $p$ 个元素为 $1$，其余元素为 $0$）。将该测试用例的灵敏度放大系数定义为标量\n$$\ns \\;=\\; \\frac{\\lVert \\tilde{x} - x \\rVert_{2}}{|\\delta|}.\n$$\n你的任务是为以下每个测试用例计算 $s$。\n\n测试用例 $1$：\n- $A = \\begin{bmatrix}\n1 & 0 & 1\\\\\n0 & 1 & 1\\\\\n1 & 1 & 0\\\\\n2 & 1 & 1\\\\\n1 & 2 & 1\n\\end{bmatrix}$，$b = \\begin{bmatrix} 1\\\\ 2\\\\ 3\\\\ 4\\\\ 5 \\end{bmatrix}$，$p = 2$，$\\delta = 10$。\n\n测试用例 $2$：\n- $A = \\begin{bmatrix}\n1 & 1.0000 & 2.0000\\\\\n2 & 2.0005 & 4.0009\\\\\n3 & 3.0008 & 6.0012\\\\\n4 & 4.0011 & 8.0015\\\\\n5 & 5.0014 & 10.0018\n\\end{bmatrix}$，$b = \\begin{bmatrix} 1\\\\ 1\\\\ 1\\\\ 1\\\\ 1 \\end{bmatrix}$，$p = 0$，$\\delta = 50$。\n\n测试用例 $3$：\n- $A = \\begin{bmatrix}\n1 & 0 & 0\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\\\\\n0 & 0 & 0\\\\\n0 & 0 & 0\n\\end{bmatrix}$，$b = \\begin{bmatrix} 2\\\\ -1\\\\ 3\\\\ 10\\\\ -100 \\end{bmatrix}$，$p = 4$，$\\delta = 1000$。\n\n测试用例 $4$：\n- $A = \\begin{bmatrix}\n3 & 0 & 0\\\\\n0 & 2 & 0\\\\\n0 & 0 & 1\\\\\n1 & 1 & 1\\\\\n4 & 5 & 6\n\\end{bmatrix}$，$b = \\begin{bmatrix} 1\\\\ 2\\\\ 3\\\\ 4\\\\ 5 \\end{bmatrix}$，$p = 1$，$\\delta = 10^{-6}$。\n\n为每个测试用例计算 $s$，结果为实数，四舍五入保留 $6$ 位小数。\n\n最终输出格式：你的程序应输出一行，其中包含用方括号括起来、以逗号分隔的结果列表，结果的顺序与测试用例的顺序一致，例如\n$[s_{1},s_{2},s_{3},s_{4}]$。", "solution": "必须首先验证问题陈述的科学性和逻辑一致性。\n\n**步骤 1：提取已知条件**\n对于一组测试用例，每个用例由以下条件定义：\n- 一个满列秩矩阵 $A \\in \\mathbb{R}^{m \\times n}$。\n- 一个向量 $b \\in \\mathbb{R}^{m}$。\n- 一个从零开始的索引 $p \\in \\{0, 1, \\dots, m-1\\}$。\n- 一个标量扰动大小 $\\delta \\in \\mathbb{R}$。\n\n定义了以下量：\n- 基线最小二乘解 $x$，它最小化 $\\lVert A x - b \\rVert_{2}$。\n- 扰动测量向量 $\\tilde{b} = b + \\delta e_{p}$，其中 $e_p$ 是第 $p$ 个标准基向量。\n- 扰动最小二乘解 $\\tilde{x}$，它最小化 $\\lVert A x - \\tilde{b} \\rVert_{2}$。\n- 灵敏度放大系数 $s = \\frac{\\lVert \\tilde{x} - x \\rVert_{2}}{|\\delta|}$。\n\n任务是为四个指定的测试用例计算 $s$。\n\n**步骤 2：使用提取的已知条件进行验证**\n1.  **科学依据**：该问题设置在线性最小二乘的背景下，这是数值线性代数和计算科学中的一个基本课题。最小二乘解、矩阵秩、向量范数和灵敏度分析等概念都是标准且成熟的。该问题在科学上是合理的。\n2.  **适定性**：问题陈述指出，每个测试用例中的矩阵 $A$ 都具有满列秩。对于一个矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 且 $m \\ge n$，满列秩意味着 $A$ 的列是线性无关的。这确保了格拉姆矩阵 (Gram matrix) $A^T A$ 是可逆的，从而保证了基线问题和扰动问题都存在唯一的最小二乘解。对测试用例中提供的矩阵的检查证实，它们都具有满列秩，即使在用例2中，列是近似线性相关的，导致矩阵是病态的但仍然是满秩的。因此，每个问题都是适定的。\n3.  **客观性**：该问题使用精确的数学语言和定义进行表述，没有任何主观性或模糊性。\n\n该问题没有违反任何无效性标准。它是完整的、一致的并且是可形式化的。\n\n**步骤 3：结论与行动**\n问题有效。将提供解决方案。\n\n**解的推导**\n\n对于一个满秩矩阵 $A$，线性最小二乘问题 $\\min_x \\lVert Ax - y \\rVert_2$ 的解由正规方程组给出：\n$$\nx = (A^T A)^{-1} A^T y\n$$\n将此应用于基线问题和扰动问题：\n$$\nx = (A^T A)^{-1} A^T b\n$$\n$$\n\\tilde{x} = (A^T A)^{-1} A^T \\tilde{b}\n$$\n扰动解与基线解之差 $\\Delta x = \\tilde{x} - x$，推导如下：\n$$\n\\Delta x = (A^T A)^{-1} A^T \\tilde{b} - (A^T A)^{-1} A^T b = (A^T A)^{-1} A^T (\\tilde{b} - b)\n$$\n代入 $\\tilde{b} = b + \\delta e_p$：\n$$\n\\Delta x = (A^T A)^{-1} A^T (b + \\delta e_p - b) = \\delta (A^T A)^{-1} A^T e_p\n$$\n那么灵敏度放大系数 $s$ 为：\n$$\ns = \\frac{\\lVert \\Delta x \\rVert_{2}}{|\\delta|} = \\frac{\\lVert \\delta (A^T A)^{-1} A^T e_p \\rVert_{2}}{|\\delta|} = \\frac{|\\delta| \\lVert (A^T A)^{-1} A^T e_p \\rVert_{2}}{|\\delta|} = \\lVert (A^T A)^{-1} A^T e_p \\rVert_{2}\n$$\n这个结果表明，灵敏度 $s$ 既与测量向量 $b$ 无关，也与扰动大小 $\\delta$ 无关。它是一个仅由矩阵 $A$ 和扰动索引 $p$ 决定的内在属性。\n\n尽管涉及正规方程组的公式在分析上是正确的，但通过构建 $A^T A$ 进行直接计算在数值上是不稳定的，特别是对于病态矩阵。$A^T A$ 的条件数是 $A$ 条件数的平方，即 $\\kappa(A^T A) = \\kappa(A)^2$。这种平方运算可能导致严重的精度损失。\n\n一种数值上更优越的方法是使用 $A$ 的 QR 分解。让我们使用简约（或瘦）QR分解，其中 $A = QR$，$Q \\in \\mathbb{R}^{m \\times n}$ 具有标准正交列（$Q^T Q = I_n$），$R \\in \\mathbb{R}^{n \\times n}$ 是一个上三角可逆矩阵。\n\n最小二乘解可以表示为：\n$$\nx = R^{-1} Q^T b\n$$\n依循同样的逻辑，解的差值为：\n$$\n\\Delta x = \\tilde{x} - x = R^{-1} Q^T \\tilde{b} - R^{-1} Q^T b = R^{-1} Q^T (\\delta e_p) = \\delta (R^{-1} Q^T e_p)\n$$\n因此，灵敏度 $s$ 为：\n$$\ns = \\frac{\\lVert \\Delta x \\rVert_{2}}{|\\delta|} = \\lVert R^{-1} (Q^T e_p) \\rVert_{2}\n$$\n$Q^T e_p$ 项表示矩阵 $Q^T$ 的第 $p$ 列。这等价于 $Q$ 的第 $p$ 行的转置。让我们将对应于 $Q$ 的第 $p$ 行的向量表示为 $q_p \\in \\mathbb{R}^n$。那么 $Q^T e_p = q_p$。\n灵敏度的最终表达式为：\n$$\ns = \\lVert R^{-1} q_p \\rVert_{2}\n$$\n这个表达式是数值稳定的，并构成了我们计算算法的基础。\n\n**算法**\n对于每个由矩阵 $A$ 和索引 $p$ 指定的测试用例：\n1.  计算 $A$ 的简约 QR 分解以获得 $Q \\in \\mathbb{R}^{m \\times n}$ 和 $R \\in \\mathbb{R}^{n \\times n}$。\n2.  提取 $Q$ 的第 $p$ 行以构成向量 $q_p$。\n3.  求解上三角系统 $Rv = q_p$ 以得到向量 $v = R^{-1}q_p$。这可以通过回代法高效完成。\n4.  计算欧几里得范数 $s = \\lVert v \\rVert_2$。\n5.  按要求将结果四舍五入至 6 位小数。\n\n将此程序应用于四个测试用例中的每一个。对于用例 3，其中 $A = [I_3; 0_{2\\times3}]$，QR 分解是平凡的，$Q=A$ 且 $R=I_3$。索引 $p=4$ 对应于 $Q$ 的第五行，它是一个零向量。因此，$q_4 = (0,0,0)$，且 $s = \\lVert I_3^{-1} \\cdot 0 \\rVert_2 = 0$，正如预期。对 $A$ 中零行对应的测量值进行扰动，对解向量 $x$ 没有影响。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_triangular\n\ndef solve():\n    \"\"\"\n    Computes the sensitivity amplification for a series of linear regression problems.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (A, p), as b and delta are not needed for the calculation of s.\n    test_cases = [\n        (\n            np.array([\n                [1., 0., 1.],\n                [0., 1., 1.],\n                [1., 1., 0.],\n                [2., 1., 1.],\n                [1., 2., 1.]\n            ]),\n            2\n        ),\n        (\n            np.array([\n                [1., 1.0000, 2.0000],\n                [2., 2.0005, 4.0009],\n                [3., 3.0008, 6.0012],\n                [4., 4.0011, 8.0015],\n                [5., 5.0014, 10.0018]\n            ]),\n            0\n        ),\n        (\n            np.array([\n                [1., 0., 0.],\n                [0., 1., 0.],\n                [0., 0., 1.],\n                [0., 0., 0.],\n                [0., 0., 0.]\n            ]),\n            4\n        ),\n        (\n            np.array([\n                [3., 0., 0.],\n                [0., 2., 0.],\n                [0., 0., 1.],\n                [1., 1., 1.],\n                [4., 5., 6.]\n            ]),\n            1\n        )\n    ]\n\n    results = []\n    for A, p in test_cases:\n        # The sensitivity amplification s is given by ||inv(R) * q_p||,\n        # where A = QR (thin QR decomposition) and q_p is the p-th row of Q.\n        \n        # Step 1: Compute the reduced QR decomposition of A.\n        # mode='reduced' gives Q (m x n) and R (n x n).\n        Q, R = np.linalg.qr(A, mode='reduced')\n\n        # Step 2: Extract the p-th row of Q to form the vector q_p.\n        q_p = Q[p, :]\n\n        # Step 3: Solve the upper triangular system Rv = q_p for the vector v.\n        # This is equivalent to calculating v = inv(R) * q_p.\n        # lower=False indicates that R is an upper triangular matrix.\n        v = solve_triangular(R, q_p, lower=False)\n\n        # Step 4: Compute the Euclidean norm (L2 norm) of v.\n        s = np.linalg.norm(v)\n        \n        # Round the result to 6 decimal places.\n        results.append(round(s, 6))\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2430336"}]}