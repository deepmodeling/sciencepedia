{"hands_on_practices": [{"introduction": "理论知识是基础，但真正的理解来自于实践。这个练习将指导你从头开始编写一个完整的自然三次样条插值程序。通过亲手实现求解三次样条系数所需的三对角线性系统的托马斯（Thomas）算法，你将不再把样条插值看作一个“黑匣子”，而是能够深入理解其内部工作机制。这项实践是掌握样条方法计算核心的宝贵一步。[@problem_id:2384309]", "problem": "给定在严格递增节点上采样的一维数据。对于一组节点 $x_0 < x_1 < \\dots < x_n$ 及其对应的值 $y_0, y_1, \\dots, y_n$，考虑由以下属性定义的唯一自然三次样条 $S(x)$：在每个区间 $[x_i, x_{i+1}]$ 上，函数 $S(x)$ 是一个三次多项式；函数 $S(x)$ 满足插值条件 $S(x_i) = y_i$（对所有 $0 \\le i \\le n$ 均成立）；一阶导数 $S'(x)$ 在 $[x_0, x_n]$ 上连续；二阶导数 $S''(x)$ 在 $[x_0, x_n]$ 上连续；并且满足自然边界条件 $S''(x_0) = 0$ 和 $S''(x_n) = 0$。您的任务是编写一个完整的程序，对下面的每个测试用例，根据所提供的数据集构建唯一的自然三次样条 $S(x)$，并在指定的查询点 $x_q$ 处计算 $S(x)$ 的值。\n\n测试套件中的所有输入都在下面明确给出。每个测试用例都是独立的。在每种情况下，使用所提供的数组 $x$ 和 $y$ 作为精确数据来构建 $S(x)$，然后计算标量值 $S(x_q)$。不允许也不需要使用任何外部数据源。所有计算都是纯数值的，无量纲；不涉及任何物理单位。\n\n测试套件（每一项都是一个三元组 $(x, y, x_q)$，需按给定顺序独立处理）：\n- 测试用例 1：$x = [\\,0,\\,0.5,\\,1.7,\\,2.2,\\,3.0\\,]$，$y = [\\,0.0,\\,0.5,\\,1.8,\\,2.1,\\,1.2\\,]$，$x_q = 1.3$。\n- 测试用例 2：$x = [\\,0,\\,0.5,\\,1.7,\\,2.2,\\,3.0\\,]$，$y = [\\,0.0,\\,0.5,\\,1.8,\\,2.1,\\,1.2\\,]$，$x_q = 0.0$。\n- 测试用例 3：$x = [\\,0,\\,0.5,\\,1.7,\\,2.2,\\,3.0\\,]$，$y = [\\,0.0,\\,0.5,\\,1.8,\\,2.1,\\,1.2\\,]$，$x_q = 3.0$。\n- 测试用例 4：$x = [\\,0,\\,0.5,\\,1.7,\\,2.2,\\,3.0\\,]$，$y = [\\,0.0,\\,0.5,\\,1.8,\\,2.1,\\,1.2\\,]$，$x_q = 2.2$。\n- 测试用例 5：$x = [\\,-1.0,\\,2.0\\,]$，$y = [\\,-1.0,\\,4.0\\,]$，$x_q = 0.5$。\n\n您的程序必须按顺序计算上述 5 个用例中每个用例的 $S(x_q)$ 值，并生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。输出列表中的每个数字都必须是精确到小数点后 $8$ 位的浮点值。例如，要求的输出格式为 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是第 $i$ 个测试用例中 $S(x_q)$ 精确到小数点后 8 位的值。", "solution": "目标是根据给定的数据 $(x_i, y_i)$（其中 $0 \\le i \\le n$ 且 $x_0 < x_1 < \\dots < x_n$）构建唯一的自然三次样条 $S(x)$。根据定义，$S(x)$ 在每个区间 $[x_i, x_{i+1}]$ 上是分段三次的，它对数据进行插值 $S(x_i) = y_i$，其一阶和二阶导数在 $[x_0, x_n]$ 上连续，并满足自然边界条件 $S''(x_0) = 0$ 和 $S''(x_n) = 0$。\n\n一种标准的构建方法是引入节点处的二阶导数未知向量，记为 $M_i = S''(x_i)$（其中 $0 \\le i \\le n$）。步长为 $h_i = x_{i+1} - x_i$（其中 $0 \\le i \\le n-1$）。对于内部索引 $i$（其中 $1 \\le i \\le n-1$），跨节点处 $S'(x)$ 和 $S''(x)$ 的连续性可导出一个关于内部二阶导数 $M_1, M_2, \\dots, M_{n-1}$ 的线性方程组：\n$$\nh_{i-1} M_{i-1} + 2(h_{i-1} + h_{i}) M_i + h_i M_{i+1} = 6\\left( \\frac{y_{i+1} - y_i}{h_i} - \\frac{y_i - y_{i-1}}{h_{i-1}} \\right),\n$$\n并附有自然边界条件 $M_0 = 0$ 和 $M_n = 0$。当 $n = 1$（即两个节点）时，没有内部未知数，自然三次样条完全退化为两点之间的线性插值，这与 $M_0 = 0$ 和 $M_1 = 0$ 是一致的。\n\n关于 $(M_1, \\dots, M_{n-1})$ 的系统系数矩阵是三对角的，其各项对于 $1 \\le i \\le n-1$ 如下：\n- 主对角线：$b_i = 2(h_{i-1} + h_i)$。\n- 次对角线：$a_i = h_{i-1}$，对于 $i \\ge 2$。\n- 超对角线：$c_i = h_i$，对于 $i \\le n-2$。\n右侧项为 $d_i = 6\\left( \\frac{y_{i+1} - y_i}{h_i} - \\frac{y_i - y_{i-1}}{h_{i-1}} \\right)$。\n\n对于严格递增且 $h_i > 0$ 的 $x_i$，该线性系统是严格对角占优的，这确保了唯一解的存在。一种在 $\\mathcal{O}(n)$ 时间内高效精确求解三对角线性系统的方法包括一个消除次对角线项的前向消元阶段，以及一个恢复未知数的反向代入阶段。具体来说，假设系统用紧凑符号表示为\n$$\na_i M_{i-1} + b_i M_i + c_i M_{i+1} = d_i, \\quad \\text{对于 } i = 1, 2, \\dots, n-1,\n$$\n并约定 $a_1 = 0$ 和 $c_{n-1} = 0$。前向消元步骤构建修正后的对角线和右侧项：\n对于 $i = 2, 3, \\dots, n-1$，\n$$\nw = \\frac{a_i}{b_{i-1}}, \\quad\nb_i \\leftarrow b_i - w c_{i-1}, \\quad\nd_i \\leftarrow d_i - w d_{i-1}.\n$$\n然后反向代入计算\n$$\nM_{n-1} = \\frac{d_{n-1}}{b_{n-1}}, \\quad\nM_i = \\frac{d_i - c_i M_{i+1}}{b_i} \\quad \\text{对于 } i = n-2, n-3, \\dots, 1.\n$$\n最后，设置 $M_0 = 0$ 和 $M_n = 0$ 以获得完整的向量 $(M_0, M_1, \\dots, M_n)$。\n\n在求出二阶导数后，可以使用类似 Hermite 的表示法来计算样条在区间 $[x_i, x_{i+1}]$ 上任意点 $x \\in [x_i, x_{i+1}]$ 的值\n$$\nS(x) = A y_i + B y_{i+1} + \\frac{h_i^2}{6} \\left[ (A^3 - A) M_i + (B^3 - B) M_{i+1} \\right],\n$$\n其中 $h_i = x_{i+1} - x_i$，$A = \\frac{x_{i+1} - x}{h_i}$，以及 $B = \\frac{x - x_i}{h_i}$。通过构造，该表示法满足 $S(x_i) = y_i$、$S(x_{i+1}) = y_{i+1}$ 以及连续性条件。如果 $n = 1$，则所有索引的 $M_i = 0$，公式简化为线性插值 $S(x) = A y_0 + B y_1$。\n\n要计算 $S(x_q)$，首先确定包含 $x_q$ 的区间 $[x_i, x_{i+1}]$，即 $x_q \\in [x_i, x_{i+1}]$。如果 $x_q = x_n$，则选择最后一个区间 $[x_{n-1}, x_n]$。通过上述公式计算 $A$、$B$，然后计算 $S(x_q)$。对每个测试用例重复此过程，即可得到所需的标量输出。最后，将每个结果精确到小数点后 $8$ 位，并按指定顺序以单个方括号括起的逗号分隔列表形式输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef natural_cubic_spline_second_derivatives(x, y):\n    \"\"\"\n    Compute second derivatives M at knots for the natural cubic spline.\n    x: list or array of strictly increasing floats\n    y: list or array of floats of same length as x\n    Returns: list of M values (second derivatives) at each knot.\n    \"\"\"\n    n = len(x) - 1  # number of intervals\n    if n < 1:\n        raise ValueError(\"At least two data points are required.\")\n    if n == 1:\n        # Two nodes: linear interpolation, M = 0 at both ends.\n        return [0.0, 0.0]\n\n    h = [x[i+1] - x[i] for i in range(n)]\n    # Build tridiagonal system for M[1..n-1]\n    m = n - 1  # number of interior unknowns\n    a = [0.0] * m  # sub-diagonal (a[0] unused or zero)\n    b = [0.0] * m  # main diagonal\n    c = [0.0] * m  # super-diagonal (c[m-1] unused or zero)\n    d = [0.0] * m  # right-hand side\n\n    for i in range(m):\n        hi_prev = h[i] if i >= 0 else None\n        hi = h[i+1] if (i + 1) < n else None\n        # Using indices: interior i corresponds to global index i+1\n        if i == 0:\n            a[i] = 0.0\n        else:\n            a[i] = h[i]\n        if i == m - 1:\n            c[i] = 0.0\n        else:\n            c[i] = h[i+1]\n        b[i] = 2.0 * (h[i] + h[i+1])\n\n        # Right-hand side\n        yi_minus = y[i]\n        yi = y[i+1]\n        yi_plus = y[i+2]\n        d[i] = 6.0 * ((yi_plus - yi) / h[i+1] - (yi - yi_minus) / h[i])\n\n    # Thomas algorithm: forward elimination\n    for i in range(1, m):\n        if b[i-1] == 0.0:\n            raise ZeroDivisionError(\"Singular tridiagonal system encountered.\")\n        w = a[i] / b[i-1]\n        b[i] -= w * c[i-1]\n        d[i] -= w * d[i-1]\n\n    # Back substitution\n    M_interior = [0.0] * m\n    M_interior[-1] = d[-1] / b[-1]\n    for i in range(m - 2, -1, -1):\n        M_interior[i] = (d[i] - c[i] * M_interior[i + 1]) / b[i]\n\n    # Assemble full M with natural boundary conditions\n    M = [0.0] + M_interior + [0.0]\n    return M\n\ndef evaluate_natural_cubic_spline(x, y, M, xq):\n    \"\"\"\n    Evaluate the natural cubic spline defined by (x, y, M) at xq.\n    x: list of knots (strictly increasing)\n    y: list of values\n    M: list of second derivatives at knots\n    xq: query point within [x[0], x[-1]]\n    \"\"\"\n    n = len(x) - 1\n    if xq <= x[0]:\n        i = 0\n    elif xq >= x[-1]:\n        i = n - 1\n    else:\n        # Find right interval i such that x[i] <= xq <= x[i+1]\n        # Using binary search\n        left, right = 0, n\n        while left <= right:\n            mid = (left + right) // 2\n            if x[mid] <= xq:\n                left = mid + 1\n            else:\n                right = mid - 1\n        i = max(0, min(right, n - 1))\n\n    h = x[i+1] - x[i]\n    if h == 0.0:\n        raise ZeroDivisionError(\"Zero interval width encountered.\")\n    A = (x[i+1] - xq) / h\n    B = (xq - x[i]) / h\n    # S(x) formula using second derivatives M\n    term = ((A**3 - A) * M[i] + (B**3 - B) * M[i+1]) * (h**2) / 6.0\n    Sx = A * y[i] + B * y[i+1] + term\n    return Sx\n\ndef solve():\n    # Define the test cases from the problem statement.\n    xA = [0.0, 0.5, 1.7, 2.2, 3.0]\n    yA = [0.0, 0.5, 1.8, 2.1, 1.2]\n    test_cases = [\n        (xA, yA, 1.3),\n        (xA, yA, 0.0),\n        (xA, yA, 3.0),\n        (xA, yA, 2.2),\n        ([-1.0, 2.0], [-1.0, 4.0], 0.5),\n    ]\n\n    results = []\n    for x, y, xq in test_cases:\n        # Compute second derivatives for the dataset\n        M = natural_cubic_spline_second_derivatives(x, y)\n        # Evaluate spline at query point\n        val = evaluate_natural_cubic_spline(x, y, M, xq)\n        results.append(val)\n\n    # Final print statement in the exact required format: 8 decimal places, no spaces\n    formatted = \"[\" + \",\".join(f\"{r:.8f}\" for r in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2384309"}, {"introduction": "掌握了如何构建样条之后，下一个关键问题是：应该选择哪种边界条件？此练习通过一个具体的例子——使用正弦函数生成的周期性数据——来揭示不同边界条件的性能差异。你将比较“自然”边界条件和“周期性”边界条件的插值效果，并量化它们在边界处对导数估计的准确性。这个对比将清晰地展示，选择与数据内在特性（如此处的周期性）相匹配的边界条件对于提高模型精度至关重要。[@problem_id:2382247]", "problem": "考虑定义在闭区间 $[0, 2\\pi]$ 上的函数 $f(x) = \\sin(x)$，其中所有角度均以弧度为单位。设 $x_0 = 0$ 和 $x_{N-1} = 2\\pi$。对于给定的整数 $N \\geq 4$，定义一组在 $[0, 2\\pi]$ 上均匀分布的 $N$ 个采样点 $\\{x_i\\}_{i=0}^{N-1}$，以及对所有 $i$ 对应的数值 $y_i = f(x_i)$。构建两个对数据 $\\{(x_i, y_i)\\}$ 进行插值的三次样条插值函数 $S_{\\mathrm{nat}}(x)$ 和 $S_{\\mathrm{per}}(x)$，其中：\n- $S_{\\mathrm{nat}}(x)$ 是自然三次样条，满足边界条件 $S_{\\mathrm{nat}}''(x_0) = 0$ 和 $S_{\\mathrm{nat}}''(x_{N-1}) = 0$。\n- $S_{\\mathrm{per}}(x)$ 是周期三次样条，对于 $k \\in \\{0, 1, 2\\}$ 满足 $S_{\\mathrm{per}}^{(k)}(x_0) = S_{\\mathrm{per}}^{(k)}(x_{N-1})$。\n\n定义边界处的真实导数为 $f'(x_0) = \\cos(0)$ 和 $f'(x_{N-1}) = \\cos(2\\pi)$。对于每种样条类型 $\\tau \\in \\{\\mathrm{nat}, \\mathrm{per}\\}$，定义边界导数误差\n$$\nE_{\\tau}(N) = \\max\\left( \\left| S_{\\tau}'(x_0) - f'(x_0) \\right|, \\left| S_{\\tau}'(x_{N-1}) - f'(x_{N-1}) \\right| \\right).\n$$\n对于测试套件中的每个 $N$，计算比率\n$$\nR(N) = \\frac{E_{\\mathrm{nat}}(N)}{E_{\\mathrm{per}}(N)}.\n$$\n\n您的程序必须：\n- 在 $[0, 2\\pi]$ 上使用函数 $f(x) = \\sin(x)$，角度以弧度为单位。\n- 对每个指定的 $N$，形成包括两个端点的均匀网格，按上述定义构建 $S_{\\mathrm{nat}}(x)$ 和 $S_{\\mathrm{per}}(x)$，评估 $E_{\\mathrm{nat}}(N)$ 和 $E_{\\mathrm{per}}(N)$，并报告 $R(N)$。\n\n测试套件：\n- $N \\in \\{5, 9, 17, 64\\}$。\n\n要求的最终输出格式为单行，包含 $[R(5), R(9), R(17), R(64)]$ 这四个值的列表，形式为逗号分隔并用方括号括起，每个浮点值四舍五入到恰好 $8$ 位小数（例如，$[1.23456789,2.34567891,3.45678912,4.56789123]$）。不应打印任何其他文本。", "solution": "该任务是比较自然三次样条和周期三次样条在逼近函数 $f(x) = \\sin(x)$ 在区间 $[0, 2\\pi]$ 上边界导数的精度。三次样条插值函数 $S(x)$ 是一个分段函数，其中在每个区间 $[x_i, x_{i+1}]$ 上的每一段 $S_i(x)$ 都是一个三次多项式，形式为：\n$$S_i(x) = a_i + b_i(x-x_i) + c_i(x-x_i)^2 + d_i(x-x_i)^3$$\n这些系数通过强制施加几个条件来确定：\n1.  插值：对于所有 $i=0, \\dots, N-1$，有 $S(x_i) = y_i$。\n2.  连续性：样条 $S(x)$、其一阶导数 $S'(x)$ 和二阶导数 $S''(x)$ 在整个区间 $[x_0, x_{N-1}]$ 上是连续的。\n\n这些条件产生一个线性方程组。通常求解节点处的二阶导数 $M_i = S''(x_i)$。对于间距为 $h = (x_{N-1}-x_0)/(N-1)$ 的均匀网格，内部节点（$i=1, \\dots, N-2$）的方程由下式给出：\n$$M_{i-1} + 4M_i + M_{i+1} = \\frac{6}{h^2}(y_{i-1} - 2y_i + y_{i+1})$$\n为了获得所有 $M_i$ 的唯一解，需要两个额外的边界条件。这些条件的选择定义了样条的类型。\n\n1.  **自然三次样条 ($S_{\\mathrm{nat}}(x)$)**：\n    边界条件为 $S_{\\mathrm{nat}}''(x_0) = 0$ 和 $S_{\\mathrm{nat}}''(x_{N-1}) = 0$。这意味着 $M_0 = 0$ 和 $M_{N-1} = 0$。这些约束闭合了方程组，形成一个关于未知内部二阶导数 $M_1, \\dots, M_{N-2}$ 的严格对角占优三对角系统，这保证了唯一解的存在。\n    对于这个特定问题，一个关键的观察是，被插值的函数 $f(x) = \\sin(x)$ 在边界处的真实二阶导数为 $f''(0) = -\\sin(0) = 0$ 和 $f''(2\\pi) = -\\sin(2\\pi) = 0$。因此，自然样条的边界条件恰好与函数的真实二阶导数相匹配。这种情况类似于提供了真实二阶导数的“钳位”样条，众所周知，这会比一般的自然样条带来更高阶的精度。\n\n2.  **周期三次样条 ($S_{\\mathrm{per}}(x)$)**：\n    边界条件是周期性的：对于 $k=0, 1, 2$，有 $S_{\\mathrm{per}}^{(k)}(x_0) = S_{\\mathrm{per}}^{(k)}(x_{N-1})$。函数 $f(x) = \\sin(x)$ 及其导数在 $[0, 2\\pi]$ 上是周期的，因此这些条件与底层函数的性质是一致的。这些条件产生一个关于 $M_0, \\dots, M_{N-1}$ 的循环三对角方程组，该系统也是非奇异的并有唯一解。理论上，这类样条最适合用于插值周期函数。\n\n为了计算误差，需要样条在端点处的一阶导数。这些可以从 $y_i$ 和 $M_i$ 的值计算得出。在左边界 $x_0$ 处：\n$$S'(x_0) = \\frac{y_1 - y_0}{h} - \\frac{h}{6}(2M_0 + M_1)$$\n在右边界 $x_{N-1}$ 处：\n$$S'(x_{N-1}) = \\frac{y_{N-1} - y_{N-2}}{h} + \\frac{h}{6}(M_{N-2} + 2M_{N-1})$$\n函数 $f(x) = \\sin(x)$ 的真实导数是 $f'(x) = \\cos(x)$。在边界处，真实值为 $f'(0) = \\cos(0) = 1$ 和 $f'(2\\pi) = \\cos(2\\pi) = 1$。\n对于每种样条类型 $\\tau \\in \\{\\mathrm{nat}, \\mathrm{per}\\}$，误差定义为样条导数与真实导数在两个边界处绝对差的最大值：\n$$E_{\\tau}(N) = \\max\\left( \\left| S_{\\tau}'(0) - 1 \\right|, \\left| S_{\\tau}'(2\\pi) - 1 \\right| \\right)$$\n最后，对测试套件中的每个 $N$ 计算比率 $R(N) = E_{\\mathrm{nat}}(N) / E_{\\mathrm{per}}(N)$。\n\n算法流程如下：\n对于每个给定的 $N$ 值：\n1.  在 $[0, 2\\pi]$ 上生成 $N$ 个均匀分布的点 $\\{x_i\\}$ 和相应的数据值 $y_i = \\sin(x_i)$。\n2.  使用 `scipy.interpolate.CubicSpline` 库函数，设置 `bc_type='natural'`，构建自然三次样条 $S_{\\mathrm{nat}}(x)$。\n3.  使用相同的函数，设置 `bc_type='periodic'`，构建周期三次样条 $S_{\\mathrm{per}}(x)$。\n4.  评估一阶导数 $S_{\\mathrm{nat}}'(0)$、 $S_{\\mathrm{nat}}'(2\\pi)$、 $S_{\\mathrm{per}}'(0)$ 和 $S_{\\mathrm{per}}'(2\\pi)$。\n5.  计算误差 $E_{\\mathrm{nat}}(N)$ 和 $E_{\\mathrm{per}}(N)$。\n6.  计算比率 $R(N)$。\n\n对集合 $\\{5, 9, 17, 64\\}$ 中的每个 $N$ 重复此过程。收集所得比率，并按指定格式输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\n\ndef solve():\n    \"\"\"\n    Solves the cubic spline boundary derivative error problem.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [5, 9, 17, 64]\n\n    results = []\n    for N in test_cases:\n        # Step 1: Define the grid and data points for f(x) = sin(x) on [0, 2*pi].\n        # The grid is uniform and includes both endpoints.\n        x_points = np.linspace(0.0, 2.0 * np.pi, N)\n        y_points = np.sin(x_points)\n\n        # Step 2: Define the true derivative at the boundaries.\n        # f'(x) = cos(x), so f'(0) = 1 and f'(2*pi) = 1.\n        f_prime_true = 1.0\n\n        # Step 3: Construct the natural cubic spline and calculate its boundary derivative error.\n        # 'natural' sets the second derivative at the endpoints to zero.\n        # S_nat''(x_0) = 0, S_nat''(x_{N-1}) = 0.\n        s_nat = CubicSpline(x_points, y_points, bc_type='natural')\n        \n        # Evaluate the first derivative (nu=1) at the boundaries.\n        s_nat_prime_x0 = s_nat(x_points[0], nu=1)\n        s_nat_prime_x_end = s_nat(x_points[-1], nu=1)\n        \n        # Calculate the error E_nat(N).\n        error_nat = max(abs(s_nat_prime_x0 - f_prime_true), abs(s_nat_prime_x_end - f_prime_true))\n\n        # Step 4: Construct the periodic cubic spline and calculate its boundary derivative error.\n        # 'periodic' enforces S^(k)(x_0) = S^(k)(x_{N-1}) for k=0,1,2.\n        # This is valid because y_points[0] is numerically equal to y_points[-1].\n        s_per = CubicSpline(x_points, y_points, bc_type='periodic')\n\n        # Evaluate the first derivative (nu=1) at the boundaries.\n        s_per_prime_x0 = s_per(x_points[0], nu=1)\n        s_per_prime_x_end = s_per(x_points[-1], nu=1)\n        \n        # Calculate the error E_per(N).\n        error_per = max(abs(s_per_prime_x0 - f_prime_true), abs(s_per_prime_x_end - f_prime_true))\n\n        # Step 5: Compute the ratio R(N).\n        # We check for division by zero, although it is not expected for this problem.\n        if error_per == 0.0:\n            # If the periodic spline is perfectly accurate, the ratio is either 0 (if natural is also perfect)\n            # or infinite (if natural has error). In a computational context, we would report a very large number\n            # or handle as a special case. Given the problem, it's safe to assume error_per > 0.\n            ratio = np.inf if error_nat > 0 else 0.0\n        else:\n            ratio = error_nat / error_per\n        \n        results.append(ratio)\n\n    # Final print statement in the exact required format.\n    # Each float is formatted to 8 decimal places.\n    formatted_results = [f\"{r:.8f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2382247"}, {"introduction": "三次样条在数据点之间提供了平滑的插值，但当我们需要预测数据范围之外的值（即外插）时，必须格外小心。这个练习旨在探讨外插的内在风险，并分析不同边界条件如何影响外插的稳定性和准确性。通过比较自然样条、钳制样条和“非节点”（not-a-knot）样条在外插点的表现，并引入一个量化敏感度的指标，你将学习到如何评估和理解不同模型在外插应用中的可靠性。这是将理论知识应用于实际工程决策的关键一课。[@problem_id:2382282]", "problem": "您的任务是实现一个完整、可运行的程序，该程序使用不同的端点边界条件构建和评估立方样条插值，然后量化这些条件如何影响数据范围之外的外插。您的程序必须是确定性的，并生成下述的确切输出格式。\n\n考虑由函数 $f(x) = \\sin(x)$ 在闭区间 $[0,\\pi]$ 上生成的数据，角度以弧度为单位。设 $n = 8$ 个采样点在 $[0,\\pi]$ 上均匀分布，即 $x_i = 0 + (i-1)\\,\\Delta x$，其中 $\\Delta x = \\pi/(n-1)$，$i = 1,2,\\dots,n$。并设 $y_i = f(x_i)$，$i = 1,2,\\dots,n$。您将为数据 $\\{(x_i,y_i)\\}_{i=1}^n$ 在端点 $x_1$ 和 $x_n$ 处采用以下每种边界条件来构建一个立方样条插值 $s(x)$：\n\n- 自然边界条件: $s''(x_1) = 0$ 且 $s''(x_n) = 0$。\n- 钳位边界条件: $s'(x_1) = f'(x_1)$ 且 $s'(x_n) = f'(x_n)$，其中 $f'(x) = \\cos(x)$。\n- 非节点 (Not-a-knot) 边界条件：三阶导数在第一个内部节点 $x_2$ 和最后一个内部节点 $x_{n-1}$ 处连续，这迫使前两段和后两段多项式各自合并成单一个三次多项式。\n\n立方样条 $s(x)$ 是一个具有全局 $C^2$ 光滑性（即 $s(x)$、$s'(x)$ 和 $s''(x)$ 对所有 $x$ 都连续）的分段三次多项式，满足所有 $i$ 的插值条件 $s(x_i) = y_i$。上述边界条件完善了定义，从而确保了唯一插值函数的存在。$s(x)$ 在 $[x_1,x_n]$ 之外的外插定义为延续最近的边界区间上的三次多项式。\n\n您的程序必须计算以下定量诊断指标：\n\n- 定义两个外插目标点：$x_L = -0.5$（在 $x_1$ 左侧）和 $x_R = \\pi + 0.5$（在 $x_n$ 右侧），角度以弧度为单位。\n- 对于每种边界条件，计算在 $x_L$ 和 $x_R$ 处的绝对外插误差，定义为 $E_{\\text{left}} = |s(x_L) - f(x_L)|$ 和 $E_{\\text{right}} = |s(x_R) - f(x_R)|$。\n- 为了评估由边界条件控制的外插稳定性，基于一个小的扰动 $\\varepsilon = 10^{-6}$ 定义以下单边端点敏感度指标：\n  - 右端点在 $x_R$ 处的敏感度：构建一个扰动数据集，仅将最右侧的数据值更改为 $y_n^{\\text{pert}} = y_n + \\varepsilon$，保持所有其他 $y_i$ 不变并使用相同的边界条件。设 $s^{\\text{pert}}(x)$ 为对应的样条。定义 $S_{\\text{right}} = |s^{\\text{pert}}(x_R) - s(x_R)| / \\varepsilon$。\n  - 左端点在 $x_L$ 处的敏感度：构建一个扰动数据集，仅将最左侧的数据值更改为 $y_1^{\\text{pert}} = y_1 + \\varepsilon$，保持所有其他 $y_i$ 不变并使用相同的边界条件。定义 $S_{\\text{left}} = |s^{\\text{pert}}(x_L) - s(x_L)| / \\varepsilon$。\n这些敏感度量化了在每种边界条件下，最近的端点数据值的单位变化如何影响紧邻该端点之外的外插预测。\n\n测试套件和要求输出：\n- 严格使用上述三种边界条件，并按固定顺序：自然、钳位、非节点。\n- 严格使用 $n = 8$、函数 $f(x) = \\sin(x)$、$x_L = -0.5$、$x_R = \\pi + 0.5$ 和 $\\varepsilon = 10^{-6}$，角度以弧度为单位。\n- 您的程序必须按所示确切顺序计算并汇总以下四个浮点数结果列表：\n  1. $[E_{\\text{right}}^{\\text{natural}}, E_{\\text{right}}^{\\text{clamped}}, E_{\\text{right}}^{\\text{not-a-knot}}]$,\n  2. $[E_{\\text{left}}^{\\text{natural}}, E_{\\text{left}}^{\\text{clamped}}, E_{\\text{left}}^{\\text{not-a-knot}}]$,\n  3. $[S_{\\text{right}}^{\\text{natural}}, S_{\\text{right}}^{\\text{clamped}}, S_{\\text{right}}^{\\text{not-a-knot}}]$,\n  4. $[S_{\\text{left}}^{\\text{natural}}, S_{\\text{left}}^{\\text{clamped}}, S_{\\text{left}}^{\\text{not-a-knot}}]$.\n- 最终输出格式：您的程序应生成单行输出，其中包含结果，格式为一个由四个列表组成的顶层 Python 风格列表，以逗号分隔，并按上述指定顺序排列（例如，类似 `[[a,b,c],[d,e,f],[g,h,i],[j,k,l]]` 的一行）。数值必须是浮点数。\n\n您在推理和实现中必须依赖的科学和算法基础：\n- 立方样条的定义：具有 $C^2$ 连续性并满足插值条件的分段三次函数。\n- 边界条件在封闭求解样条系数的线性系统中的作用。\n- 立方样条的外插：作为边界区间三次函数的自然延续。\n- 敏感度：作为关于数据扰动的方向导数的有限差分近似。\n\n角度必须以弧度为单位，所有要求的数值答案必须以所描述的精确输出格式作为浮点值返回。", "solution": "一个对 $n$ 个数据点 $\\{(x_i, y_i)\\}_{i=1}^n$ 进行插值的立方样条 $s(x)$ 是一个分段函数。在每个子区间 $[x_i, x_{i+1}]$（其中 $i=1, \\dots, n-1$）上，$s(x)$ 是一个三次多项式，我们将其表示为 $s_i(x)$。\n$$s_i(x) = a_i + b_i(x-x_i) + c_i(x-x_i)^2 + d_i(x-x_i)^3$$\n总共有 $4(n-1)$ 个系数 $\\{a_i, b_i, c_i, d_i\\}_{i=1}^{n-1}$ 需要确定。施加以下条件：\n1. 插值条件: $s_i(x_i) = y_i$ (对 $i=1, \\dots, n-1$）和 $s_{n-1}(x_n) = y_n$。这提供了 $n$ 个条件。从第一部分，我们得到 $a_i = y_i$。\n2. 连续性条件: 在 $n-2$ 个内部节点 $x_2, \\dots, x_{n-1}$ 处，函数值、一阶导数和二阶导数必须连续。\n   - $s_{i-1}(x_i) = s_i(x_i) (= y_i)$\n   - $s'_{i-1}(x_i) = s'_i(x_i)$\n   - $s''_{i-1}(x_i) = s''_i(x_i)$\n这些连续性约束提供了 $3(n-2)$ 个条件。总共，对于 $4(n-1) = 4n-4$ 个未知数，我们有 $n + 3(n-2) = 4n-6$ 个条件。我们还缺少两个条件。这两个条件由端点 $x_1$ 和 $x_n$ 处的边界条件提供。\n\n指定的边界条件是：\n- **自然边界**: 端点的二阶导数为零：$s''(x_1)=0$ 和 $s''(x_n)=0$。这意味着样条以零曲率接近端点，模拟一条直线。当没有关于端点导数的信息时，通常使用这种条件。\n- **钳位边界**: 端点的一阶导数是指定的。在这里，它们被匹配为基础函数 $f(x)$ 的真实导数：$s'(x_1) = f'(x_1)$ 和 $s'(x_n) = f'(x_n)$。对于 $f(x)=\\sin(x)$，我们有 $f'(x)=\\cos(x)$，所以 $s'(0) = \\cos(0) = 1$ 和 $s'(\\pi) = \\cos(\\pi) = -1$。\n- **非节点 (Not-a-knot) 边界**: 此条件强制要求前两个和后两个三次函数段分别为同一个多项式。这是通过在第一个内部节点 $x_2$ 和最后一个内部节点 $x_{n-1}$ 处强制三阶导数连续来实现的。即，$s'''(x_2^-) = s'''(x_2^+)$ 和 $s'''(x_{n-1}^-) = s'''(x_{n-1}^+)$。\n\n该问题要求外插，即在区间 $[x_1, x_n]$ 之外的点上评估样条 $s(x)$。这是通过延续定义在最近的边界区间上的三次多项式来执行的。对于 $x < x_1$，我们使用 $s_1(x)$；对于 $x > x_n$，我们使用 $s_{n-1}(x)$。\n\n敏感度指标 $S_{\\text{left}}$ 和 $S_{\\text{right}}$ 是外插值相对于端点数据值的偏导数的有限差分近似：\n$$ S_{\\text{left}} \\approx \\frac{\\partial s(x_L)}{\\partial y_1}, \\quad S_{\\text{right}} \\approx \\frac{\\partial s(x_R)}{\\partial y_n} $$\n这些指标量化了外插的稳定性。大的敏感度值表示端点测量中的一个微小变化或误差可能导致外插预测中一个被放大的巨大误差。\n\n解决方案按以下步骤进行：\n1.  设置常量 $n=8$、$\\varepsilon=10^{-6}$，以及评估点 $x_L=-0.5$ 和 $x_R=\\pi+0.5$。\n2.  从 $f(x)=\\sin(x)$ 在 $[0, \\pi]$ 上使用 $x_i = (i-1)\\pi/(n-1)$ 生成数据点 $\\{x_i, y_i\\}_{i=1}^n$。\n3.  遍历三种边界条件：自然、钳位和非节点。\n4.  对于每种条件：\n    a. 使用原始数据 $\\{x_i, y_i\\}$ 构建基线立方样条 $s(x)$。对于钳位情况，提供导数 $s'(0)=1$ 和 $s'(\\pi)=-1$。启用外插。\n    b. 评估 $s(x_L)$ 和 $s(x_R)$。计算外插误差 $E_{\\text{left}} = |s(x_L) - \\sin(x_L)|$ 和 $E_{\\text{right}} = |s(x_R) - \\sin(x_R)|$。\n    c. 为了找到 $S_{\\text{right}}$，创建一个扰动数据集，其中 $y_n$ 被替换为 $y_n + \\varepsilon$。使用相同类型的边界条件构建扰动后的样条 $s^{\\text{pert}}(x)$。计算 $S_{\\text{right}} = |s^{\\text{pert}}(x_R) - s(x_R)| / \\varepsilon$。\n    d. 为了找到 $S_{\\text{left}}$，创建一个扰动数据集，其中 $y_1$ 被替换为 $y_1 + \\varepsilon$。构建扰动后的样条 $s^{\\text{pert}}(x)$。计算 $S_{\\text{left}} = |s^{\\text{pert}}(x_L) - s(x_L)| / \\varepsilon$。\n5.  将 $E_{\\text{right}}$、$E_{\\text{left}}$、$S_{\\text{right}}$ 和 $S_{\\text{left}}$ 的结果收集到四个独立的列表中，并保持边界条件的顺序。\n6.  将这四个列表格式化为单个列表的列表作为最终输出。实现将利用 `scipy.interpolate.CubicSpline` 类，该类为执行这些构建提供了健壮而高效的方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\n\ndef solve():\n    \"\"\"\n    Constructs cubic splines with different boundary conditions,\n    evaluates extrapolation error and endpoint sensitivity.\n    \"\"\"\n\n    # Step 1: Define constants and problem parameters as per the statement.\n    n = 8\n    epsilon = 1e-6\n    x_left_target = -0.5\n    x_right_target = np.pi + 0.5\n    \n    # Define the true function and its derivative.\n    true_func = np.sin\n    true_func_deriv = np.cos\n    \n    # Step 2: Generate the sample data points.\n    # The problem statement uses 1-based indexing i=1,...,n.\n    # We use 0-based indexing for arrays.\n    # x_i = (i-1)*pi/(n-1) for i=1..n becomes x_j = j*pi/(n-1) for j=0..n-1.\n    x_nodes = np.linspace(0, np.pi, n)\n    y_nodes = true_func(x_nodes)\n\n    # Define the boundary conditions and their order for processing.\n    boundary_conditions = ['natural', 'clamped', 'not-a-knot']\n    \n    # Lists to store the computed diagnostics.\n    errors_right = []\n    errors_left = []\n    sensitivities_right = []\n    sensitivities_left = []\n    \n    # Step 3: Loop through each boundary condition type.\n    for bc_type in boundary_conditions:\n        \n        # --- Baseline Spline Calculation ---\n        # Special handling for 'clamped' condition which requires derivative values.\n        if bc_type == 'clamped':\n            # Derivatives at endpoints x_1=0 and x_n=pi.\n            # f'(x) = cos(x), so f'(0)=1, f'(pi)=-1.\n            deriv_at_endpoints = (true_func_deriv(x_nodes[0]), true_func_deriv(x_nodes[-1]))\n            # The bc_type argument for clamped specifies derivative order and value.\n            # (order, value) for left, (order, value) for right.\n            spline = CubicSpline(x_nodes, y_nodes, bc_type=((1, deriv_at_endpoints[0]), (1, deriv_at_endpoints[1])), extrapolate=True)\n        else:\n            # For 'natural' and 'not-a-knot', the string name is sufficient.\n            spline = CubicSpline(x_nodes, y_nodes, bc_type=bc_type, extrapolate=True)\n\n        # Evaluate extrapolation errors.\n        s_left = spline(x_left_target)\n        s_right = spline(x_right_target)\n        \n        f_left = true_func(x_left_target)\n        f_right = true_func(x_right_target)\n        \n        error_left = np.abs(s_left - f_left)\n        error_right = np.abs(s_right - f_right)\n        \n        errors_left.append(error_left)\n        errors_right.append(error_right)\n        \n        # --- Sensitivity Analysis: Right End ---\n        y_perturbed_right = y_nodes.copy()\n        y_perturbed_right[-1] += epsilon\n        \n        if bc_type == 'clamped':\n            # Per the problem, we keep the original boundary conditions.\n            spline_pert_right = CubicSpline(x_nodes, y_perturbed_right, bc_type=((1, deriv_at_endpoints[0]), (1, deriv_at_endpoints[1])), extrapolate=True)\n        else:\n            spline_pert_right = CubicSpline(x_nodes, y_perturbed_right, bc_type=bc_type, extrapolate=True)\n        \n        s_pert_right = spline_pert_right(x_right_target)\n        sensitivity_right = np.abs(s_pert_right - s_right) / epsilon\n        sensitivities_right.append(sensitivity_right)\n        \n        # --- Sensitivity Analysis: Left End ---\n        y_perturbed_left = y_nodes.copy()\n        y_perturbed_left[0] += epsilon\n\n        if bc_type == 'clamped':\n            # Keeping the same boundary condition.\n            spline_pert_left = CubicSpline(x_nodes, y_perturbed_left, bc_type=((1, deriv_at_endpoints[0]), (1, deriv_at_endpoints[1])), extrapolate=True)\n        else:\n            spline_pert_left = CubicSpline(x_nodes, y_perturbed_left, bc_type=bc_type, extrapolate=True)\n            \n        s_pert_left = spline_pert_left(x_left_target)\n        sensitivity_left = np.abs(s_pert_left - s_left) / epsilon\n        sensitivities_left.append(sensitivity_left)\n        \n    # Step 4: Assemble final results in the required list-of-lists format.\n    final_results = [\n        errors_right,\n        errors_left,\n        sensitivities_right,\n        sensitivities_left\n    ]\n    \n    # Final print statement must match the required format exactly.\n    # Convert list of lists to the string representation.\n    # Example: [[a,b,c],[d,e,f],[g,h,i],[j,k,l]]\n    result_str = str(final_results).replace(\" \", \"\")\n\n    print(result_str)\n\nsolve()\n```", "id": "2382282"}]}