{"hands_on_practices": [{"introduction": "这个练习将引导我们处理一个看似简单的任务：为三次多项式 $f(x) = 4x^3-3x$ 找到其在区间 $[-1,1]$ 上的最佳二次多项式逼近。这个问题的精妙之处在于，它不仅仅是一个计算练习，而是切比雪夫交错点定理 (Chebyshev Equioscillation Theorem) 的直接应用。通过识别给定函数与第三类切比雪夫多项式 $T_3(x)$ 的内在联系，你将发现一个出人意料的简洁答案，深刻揭示极小极大逼近的本质。[@problem_id:2425564]", "problem": "设函数 $f(x)=4x^{3}-3x$ 定义在区间 $[-1,1]$上。设 $\\mathcal{P}_{2}$ 表示所有次数至多为 $2$ 的实系数多项式的集合。使用一致范数 $\\|g\\|_{\\infty,[-1,1]}=\\max_{x\\in[-1,1]}|g(x)|$，求唯一的极小极大二次逼近多项式 $p^{\\star}\\in\\mathcal{P}_{2}$，使得 $\\|f-p\\|_{\\infty,[-1,1]}$ 在所有 $p\\in\\mathcal{P}_{2}$ 中最小。请以简化的精确表达式明确给出 $p^{\\star}(x)$。你的最终答案必须是单一的解析表达式。", "solution": "首先必须对问题陈述的科学合理性、完整性和客观性进行验证。\n\n**步骤1：提取已知条件**\n- 待逼近的函数是 $f(x)=4x^{3}-3x$。\n- 逼近区间是 $[-1,1]$。\n- 逼近多项式空间是 $\\mathcal{P}_{2}$，即所有次数至多为 $2$ 的实系数多项式的集合。\n- 用于度量误差的范数是一致范数，$\\|g\\|_{\\infty,[-1,1]}=\\max_{x\\in[-1,1]}|g(x)|$。\n- 目标是确定唯一的极小极大二次逼近多项式 $p^{\\star}\\in\\mathcal{P}_{2}$，使得它在所有 $p\\in\\mathcal{P}_{2}$ 中最小化 $\\|f-p\\|_{\\infty,[-1,1]}$。\n- 要求以明确、简化的精确表达式给出 $p^{\\star}(x)$ 的输出。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，是逼近论中的一个标准问题，而逼近论是数值分析和计算工程的一个子领域。这是一个适定问题；基础定理保证了这种多项式逼近的存在性和唯一性。问题以客观、精确的数学语言陈述，没有歧义或信息缺失。不存在矛盾或不科学的前提。\n\n**步骤3：结论与行动**\n问题有效。将提供完整的解答。\n\n该问题要求在区间 $[-1,1]$ 上，用一个次数至多为 $2$ 的多项式 $p(x)$ 来最佳逼近函数 $f(x) = 4x^{3}-3x$，其最佳的意义是最小化最大绝对误差 $\\|f - p\\|_{\\infty,[-1,1]}$。这是一个经典的极小极大逼近问题。\n\n解决这个问题的基石是切比雪夫交错点定理 (Chebyshev Equioscillation Theorem)。该定理指出，一个多项式 $p^{\\star} \\in \\mathcal{P}_{n}$ 是区间 $[a,b]$ 上连续函数 $f(x)$ 的唯一最佳一致逼近的充要条件是，误差函数 $e(x) = f(x) - p^{\\star}(x)$ 表现出至少 $n+2$ 个交错点。也就是说，在 $[a,b]$ 中必须存在至少 $n+2$ 个点 $x_0 < x_1 < \\dots < x_{n+1}$，使得 $|e(x_i)| = \\|e\\|_{\\infty, [a,b]}}$，并且误差的符号交替出现，即对 $i=0, 1, \\dots, n$ 都有 $e(x_i) = -e(x_{i+1})$。\n\n在这个具体问题中，逼近多项式空间是 $\\mathcal{P}_{2}$，所以次数至多为 $n=2$。区间是 $[-1,1]$。因此，我们必须找到一个多项式 $p^{\\star}(x) \\in \\mathcal{P}_2$，使得误差函数 $e(x) = f(x) - p^{\\star}(x)$ 在 $[-1,1]$ 上有至少 $n+2 = 4$ 个交错点。\n\n关键的第一步是识别函数 $f(x)$。给定的函数是 $f(x) = 4x^{3}-3x$。这是次数为 $3$ 的第一类切比雪夫多项式 (Chebyshev polynomial of the first kind) 的定义，记作 $T_3(x)$。所以，我们的任务是在 $[-1,1]$ 上找到 $T_3(x)$ 的最佳二次逼近。\n\n让我们检验一下 $T_3(x)$ 的性质。根据定义，$T_n(x) = \\cos(n \\arccos(x))$。对于 $x \\in [-1,1]$，$T_n(x)$ 的值被限制在 $[-1,1]$ 内。$T_n(x)$ 在 $[-1,1]$ 上的极值点出现在 $x_k = \\cos\\left(\\frac{k\\pi}{n}\\right)$，其中 $k = 0, 1, \\dots, n$。在这些点上，$T_n(x_k) = \\cos(k\\pi) = (-1)^k$。\n\n对于我们的函数 $f(x) = T_3(x)$，我们有 $n=3$。极值点出现在 $3+1=4$ 个点上：\n$x_k = \\cos\\left(\\frac{k\\pi}{3}\\right)$，其中 $k = 0, 1, 2, 3$。\n让我们列出这些点以及对应的 $f(x)$ 值：\n- 对于 $k=0$：$x_0 = \\cos(0) = 1$。函数值为 $f(1) = T_3(1) = (-1)^0 = 1$。\n- 对于 $k=1$：$x_1 = \\cos\\left(\\frac{\\pi}{3}\\right) = \\frac{1}{2}$。函数值为 $f\\left(\\frac{1}{2}\\right) = T_3\\left(\\frac{1}{2}\\right) = (-1)^1 = -1$。\n- 对于 $k=2$：$x_2 = \\cos\\left(\\frac{2\\pi}{3}\\right) = -\\frac{1}{2}$。函数值为 $f\\left(-\\frac{1}{2}\\right) = T_3\\left(-\\frac{1}{2}\\right) = (-1)^2 = 1$。\n- 对于 $k=3$：$x_3 = \\cos(\\pi) = -1$。函数值为 $f(-1) = T_3(-1) = (-1)^3 = -1$。\n\n让我们为最佳逼近多项式 $p^{\\star}(x)$ 提出一个候选。一个简单但合乎逻辑的选择是零多项式，$p^{\\star}(x) = 0$。这个多项式显然是 $\\mathcal{P}_2$ 的一个元素。\n\n现在，我们必须验证这个选择是否满足交错点定理的条件。误差函数是：\n$e(x) = f(x) - p^{\\star}(x) = (4x^{3}-3x) - 0 = 4x^{3}-3x = T_3(x)$。\n\n误差的一致范数是：\n$\\|e\\|_{\\infty, [-1,1]} = \\|T_3\\|_{\\infty, [-1,1]} = \\max_{x \\in [-1,1]} |T_3(x)| = 1$。\n\n我们在区间 $[-1,1]$ 中找到了四个点，即 $\\{-1, -1/2, 1/2, 1\\}$，在这些点上误差函数 $|e(x)|$ 达到了最大值 $1$。这些点的数量是 $4$，满足了至少为 $n+2 = 2+2=4$ 的要求。\n\n让我们检查在这些点上的符号交替条件，按 $x_3 < x_2 < x_1 < x_0$ 排序：\n- $e(-1) = T_3(-1) = -1$\n- $e\\left(-\\frac{1}{2}\\right) = T_3\\left(-\\frac{1}{2}\\right) = 1$\n- $e\\left(\\frac{1}{2}\\right) = T_3\\left(\\frac{1}{2}\\right) = -1$\n- $e(1) = T_3(1) = 1$\n\n在这四个点上，误差的值分别为 $-1, 1, -1, 1$。它们的绝对值等于最大误差，并且符号交替出现。\n\n对于 $p^{\\star}(x)=0$ 和 $n=2$，切比雪夫交错点定理的所有条件都得到了满足。因此，在区间 $[-1,1]$ 上，对于 $f(x)=4x^3-3x$，唯一的次数至多为 $2$ 的极小极大逼近多项式是 $p^{\\star}(x)=0$。", "answer": "$$\\boxed{0}$$", "id": "2425564"}, {"introduction": "从纯粹的理论转向实际的工程应用，这个练习要求你为一个喷气发动机涡轮叶片的剩余使用寿命 (RUL) 建立一个预测模型。我们的目标是构建一个二元多项式模型，使其在给定运行参数范围内的最坏情况预测误差最小化，这是一个经典的极小极大问题。你会发现，当问题离散化后，可以通过线性规划 (Linear Programming) 这一强大的优化工具来精确求解，展示了极小极大原理在解决现实世界挑战中的价值。[@problem_id:2425556]", "problem": "给定一个确定性退化规律，用于描述涡轮叶片的剩余使用寿命 (RUL) 与运行小时数和负载循环次数之间的函数关系。令 $h$ 表示运行小时数（单位：小时），$c$ 表示高应力循环次数（无量纲计数）。在本练习中，真实但未知的 RUL 函数由一个已知的映射 $R(h,c)$ 建模，其定义如下：\n$$\nR(h,c) \\;=\\; \\max\\!\\Big(0,\\; L_0 \\;-\\; \\alpha\\,h \\;-\\; \\beta\\,c \\;-\\; \\gamma\\,\\sqrt{h+1} \\;-\\; \\delta\\,h\\,c \\Big),\n$$\n其中常数 $L_0 = 5000$、$\\alpha = 0.8$、$\\beta = 0.2$、$\\gamma = 30$ 以及 $\\delta = 8\\times 10^{-5}$。输出 $R(h,c)$ 的单位为小时。以上所有数值均为固定标量。\n\n对于每个指定情况，您必须构建一个总次数至多为 $d$ 的二元多项式模型，该模型使用归一化的无量纲变量\n$$\nx \\;=\\; \\frac{h - h_{\\min}}{h_{\\max}-h_{\\min}}, \\qquad\ny \\;=\\; \\frac{c - c_{\\min}}{c_{\\max}-c_{\\min}},\n$$\n定义域为一个矩形区域 $[h_{\\min},h_{\\max}]\\times [c_{\\min},c_{\\max}]$，其中 $h_{\\min}$、$h_{\\max}$、$c_{\\min}$、$c_{\\max}$ 是下面给出的各情况的具体边界。该多项式的形式为\n$$\np(x,y) \\;=\\; \\sum_{\\substack{i,j\\ge 0\\\\ i+j\\le d}} a_{ij}\\,x^{i}\\,y^{j},\n$$\n其中 $a_{ij}$ 为实系数。对于每个情况，确定系数 $\\{a_{ij}\\}$ 以最小化在有限训练集上的最大绝对建模误差，\n$$\n\\min_{\\{a_{ij}\\}} \\; \\max_{(h_k,c_k)\\in \\mathcal{T}} \\; \\big|\\,p(x_k,y_k) \\;-\\; R(h_k,c_k)\\,\\big| ,\n$$\n其中 $\\mathcal{T}$ 是域上大小为 $N_h\\times N_c$ 的均匀间隔训练网格（网格包括端点），而 $(x_k,y_k)$ 是 $(h_k,c_k)$ 的归一化坐标。\n\n为进行评估，需在同一域上的一个大小为 $N_h^{\\mathrm{val}}\\times N_c^{\\mathrm{val}}$ 的独立均匀间隔验证网格 $\\mathcal{V}$ 上计算最大绝对误差，\n$$\nE_{\\max} \\;=\\; \\max_{(h,c)\\in \\mathcal{V}} \\; \\big|\\,p(x,y) \\;-\\; R(h,c)\\,\\big| .\n$$\n报告每种情况下以小时为单位的 $E_{\\max}$。\n\n测试套件规范（每个情况提供 $(d,\\;[h_{\\min},h_{\\max}],\\;[c_{\\min},c_{\\max}],\\;N_h\\times N_c,\\;N_h^{\\mathrm{val}}\\times N_c^{\\mathrm{val}})$）：\n- 情况 1：$d=2$, $[0,2000]$, $[0,4000]$, $21\\times 21$, $41\\times 41$.\n- 情况 2：$d=1$, $[0,200]$, $[0,200]$, $11\\times 11$, $41\\times 41$.\n- 情况 3：$d=3$, $[0,3500]$, $[0,7000]$, $25\\times 25$, $51\\times 51$.\n- 情况 4：$d=2$, $[3000,4500]$, $[6000,9000]$, $15\\times 15$, $41\\times 41$.\n\n对于每种情况，您的程序必须计算使训练网格上最大绝对误差最小化的系数 $\\{a_{ij}\\}$，然后评估验证网格上的 $E_{\\max}$。最终输出是四个验证集上的最大绝对误差，每个误差都以小时为单位，表示为四舍五入到三位小数的浮点数。\n\n最终输出格式：您的程序应生成单行结果，格式为方括号内包含的逗号分隔列表，例如 $[e_1,e_2,e_3,e_4]$，其中每个 $e_k$ 是情况 $k$ 的四舍五入后的最大绝对误差（单位：小时）。", "solution": "该问题是有效的。这是一个在计算工程领域中适定 (well-posed) 且具有科学依据的问题，特别是在使用极小化极大原则 (minimax principles) 进行函数逼近的领域。所有必要的数据和定义都已提供，不存在内部矛盾或逻辑缺陷。\n\n核心任务是确定二元多项式 $p(x,y)$ 的系数 $\\{a_{ij}\\}$，使其在有限训练集 $\\mathcal{T}$ 上最佳地逼近给定函数 $R(h,c)$。“最佳”的标准是最小化最大绝对误差，这是切比雪夫（Chebyshev）或 $L_{\\infty}$ 逼近的一个应用。这个极小化极大问题可以被严格地转化为一个线性规划（LP）问题。\n\n设总次数至多为 $d$ 的二元多项式为\n$$\np(x,y) = \\sum_{\\substack{i,j\\ge 0\\\\ i+j\\le d}} a_{ij}\\,x^{i}\\,y^{j}.\n$$\n为便于计算，我们将系数 $\\{a_{ij}\\}$ 展平成一个长度为 $N_{coeffs} = (d+1)(d+2)/2$ 的单一向量 $\\boldsymbol{\\alpha}$。于是，该多项式可以表示为\n$$\np(x,y) = \\sum_{k=1}^{N_{coeffs}} \\alpha_k \\phi_k(x,y),\n$$\n其中 $\\{\\phi_k(x,y) = x^{i_k}y^{j_k}\\}$ 是多项式空间的一个有序基。问题在于找到一个系数向量 $\\boldsymbol{\\alpha}$，该向量能解决以下优化问题：\n$$\n\\min_{\\boldsymbol{\\alpha}} \\max_{(h_m,c_m)\\in\\mathcal{T}} |p(x_m,y_m) - R(h_m,c_m)|,\n$$\n其中索引 $m$ 遍历训练集 $\\mathcal{T}$ 中的 $M = N_h \\times N_c$ 个点，而 $(x_m, y_m)$ 是对应于 $(h_m,c_m)$ 的归一化坐标。\n\n这个极小化极大问题等价于找到一个最小值 $\\epsilon$，使得存在一组系数 $\\boldsymbol{\\alpha}$ 满足\n$$\n|p(x_m,y_m) - R(h_m,c_m)| \\le \\epsilon, \\quad \\forall (h_m,c_m) \\in \\mathcal{T}.\n$$\n因此，该问题被重新表述为：\n$$\n\\min_{\\boldsymbol{\\alpha}, \\epsilon} \\epsilon\n$$\n约束条件为以下 $2M$ 个线性不等式：\n$$\n- \\epsilon \\le p(x_m,y_m) - R(h_m,c_m) \\le \\epsilon, \\quad \\text{for } m=1, \\dots, M.\n$$\n代入多项式表达式后，这些不等式变为：\n$$\n\\sum_{k=1}^{N_{coeffs}} \\alpha_k \\phi_k(x_m,y_m) - \\epsilon \\le R(h_m,c_m)\n$$\n$$\n-\\sum_{k=1}^{N_{coeffs}} \\alpha_k \\phi_k(x_m,y_m) - \\epsilon \\le -R(h_m,c_m)\n$$\n这是一个关于未知变量 $\\mathbf{u} = [\\alpha_1, \\dots, \\alpha_{N_{coeffs}}, \\epsilon]^T$ 的线性规划问题。在标准形式 $\\min \\mathbf{c}^T\\mathbf{u}$，约束为 $A_{ub}\\mathbf{u} \\le \\mathbf{b}_{ub}$ 中，各组成部分如下：\n1. 未知数向量 $\\mathbf{u}$ 的维度为 $N_{coeffs}+1$。系数 $\\alpha_k$ 无界，而误差 $\\epsilon$ 必须为非负数。\n2. 目标向量为 $\\mathbf{c} = [0, \\dots, 0, 1]^T$，维度为 $N_{coeffs}+1$，用以最小化 $\\epsilon$。\n3. 令 $V$ 是 $M \\times N_{coeffs}$ 的广义范德蒙德矩阵，其中 $V_{mk} = \\phi_k(x_m, y_m)$。令 $\\mathbf{r}$ 是 $M \\times 1$ 的向量，其中 $r_m = R(h_m, c_m)$。大小为 $(2M) \\times (N_{coeffs}+1)$ 的约束矩阵 $A_{ub}$ 和大小为 $2M$ 的向量 $\\mathbf{b}_{ub}$ 的构造如下：\n$$\nA_{ub} = \\begin{pmatrix} V & -\\mathbf{1} \\\\ -V & -\\mathbf{1} \\end{pmatrix}, \\quad \\mathbf{b}_{ub} = \\begin{pmatrix} \\mathbf{r} \\\\ -\\mathbf{r} \\end{pmatrix},\n$$\n其中 $\\mathbf{1}$ 是一个由 1 组成的 $M \\times 1$ 列向量。\n\n每个测试用例的计算步骤如下：\n1. 定义情况参数：次数 $d$、域边界 $[h_{\\min}, h_{\\max}]$ 和 $[c_{\\min}, c_{\\max}]$，以及网格大小 $N_h \\times N_c$ 和 $N_h^{\\mathrm{val}} \\times N_c^{\\mathrm{val}}$。\n2. 生成 $M = N_h \\times N_c$ 个训练点，归一化其坐标，并评估真实函数 $R(h,c)$ 以构成向量 $\\mathbf{r}$。\n3. 构建多项式基和相应的范德蒙德矩阵 $V$。\n4. 使用数值求解器建立并求解 LP 问题，指定系数变量 $\\alpha_k$ 无界且误差变量 $\\epsilon$ 非负。这将得到最优系数向量 $\\boldsymbol{\\alpha}^*$。\n5. 使用 $\\boldsymbol{\\alpha}^*$ 构建最优多项式 $p^*(x,y)$。\n6. 生成验证网格 $\\mathcal{V}$ 并在每个验证点上评估模型误差。\n7. 该情况的最终结果 $E_{\\max}$ 是在验证网格上找到的最大绝对误差：\n$$\nE_{\\max} = \\max_{(h,c) \\in \\mathcal{V}} |p^*(x,y) - R(h,c)|.\n$$\n此过程将应用于所有四个指定的情况，以获得所需的验证误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves the polynomial minimax approximation problem for a set of test cases.\n    \"\"\"\n    # Define problem constants for the RUL function\n    L0 = 5000.0\n    alpha = 0.8\n    beta = 0.2\n    gamma = 30.0\n    delta = 8e-5\n\n    def R(h, c):\n        \"\"\"\n        Calculates the true Remaining Useful Life (RUL) based on the given degradation law.\n        The function is vectorized to handle numpy arrays for h and c.\n        \"\"\"\n        val = L0 - alpha * h - beta * c - gamma * np.sqrt(h + 1.0) - delta * h * c\n        return np.maximum(0, val)\n\n    # Test suite specification\n    # Each case: (d, [h_min, h_max], [c_min, c_max], (N_h, N_c), (N_h_val, N_c_val))\n    test_cases = [\n        (2, [0.0, 2000.0], [0.0, 4000.0], (21, 21), (41, 41)),\n        (1, [0.0, 200.0], [0.0, 200.0], (11, 11), (41, 41)),\n        (3, [0.0, 3500.0], [0.0, 7000.0], (25, 25), (51, 51)),\n        (2, [3000.0, 4500.0], [6000.0, 9000.0], (15, 15), (41, 41)),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        d, h_bounds, c_bounds, train_grid_size, val_grid_size = case\n        h_min, h_max = h_bounds\n        c_min, c_max = c_bounds\n        N_h, N_c = train_grid_size\n        N_h_val, N_c_val = val_grid_size\n\n        # 1. Generate polynomial basis exponents (i, j) for total degree <= d\n        exponents = []\n        for total_degree in range(d + 1):\n            for i in range(total_degree + 1):\n                j = total_degree - i\n                exponents.append((i, j))\n        num_coeffs = len(exponents)\n\n        # 2. Generate training grid and evaluate the RUL function\n        h_train_pts = np.linspace(h_min, h_max, N_h)\n        c_train_pts = np.linspace(c_min, c_max, N_c)\n        h_train_grid, c_train_grid = np.meshgrid(h_train_pts, c_train_pts)\n        \n        h_train_flat = h_train_grid.flatten()\n        c_train_flat = c_train_grid.flatten()\n        num_train_pts = len(h_train_flat)\n\n        x_train_flat = (h_train_flat - h_min) / (h_max - h_min)\n        y_train_flat = (c_train_flat - c_min) / (c_max - c_min)\n        R_train_flat = R(h_train_flat, c_train_flat)\n\n        # 3. Construct the Linear Programming problem\n        # Generalized Vandermonde matrix V for training points\n        V_train = np.zeros((num_train_pts, num_coeffs))\n        for i, (p, q) in enumerate(exponents):\n            V_train[:, i] = x_train_flat**p * y_train_flat**q\n        \n        # LP objective: minimize epsilon (the last variable)\n        c_lp = np.zeros(num_coeffs + 1)\n        c_lp[num_coeffs] = 1.0\n\n        # LP inequality constraints matrix A_ub\n        A_ub = np.zeros((2 * num_train_pts, num_coeffs + 1))\n        A_ub[:num_train_pts, :num_coeffs] = V_train\n        A_ub[num_train_pts:, :num_coeffs] = -V_train\n        A_ub[:, -1] = -1.0\n\n        # LP inequality constraints vector b_ub\n        b_ub = np.concatenate([R_train_flat, -R_train_flat])\n        \n        # Bounds for variables: coefficients are unbounded, epsilon >= 0\n        bounds = [(None, None)] * num_coeffs + [(0, None)]\n\n        # 4. Solve the LP problem\n        res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        coeffs = res.x[:num_coeffs]\n\n        # 5. Evaluate the obtained polynomial on the validation grid\n        h_val_pts = np.linspace(h_min, h_max, N_h_val)\n        c_val_pts = np.linspace(c_min, c_max, N_c_val)\n        h_val_grid, c_val_grid = np.meshgrid(h_val_pts, c_val_pts)\n        \n        h_val_flat = h_val_grid.flatten()\n        c_val_flat = c_val_grid.flatten()\n\n        x_val_flat = (h_val_flat - h_min) / (h_max - h_min)\n        y_val_flat = (c_val_flat - c_min) / (c_max - c_min)\n        R_val_flat = R(h_val_flat, c_val_flat)\n\n        # Vandermonde matrix for validation points\n        V_val = np.zeros((len(x_val_flat), num_coeffs))\n        for i, (p, q) in enumerate(exponents):\n            V_val[:, i] = x_val_flat**p * y_val_flat**q\n\n        # Predictions from the fitted polynomial\n        p_val = V_val @ coeffs\n        \n        # Compute maximum absolute error on the validation set\n        E_max = np.max(np.abs(p_val - R_val_flat))\n        \n        results.append(round(E_max, 3))\n\n    # Print the final results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2425556"}, {"introduction": "本练习将我们带入计算机图形学和几何造型的世界，这是一个极小极大概念大放异彩的领域。我们的任务是使用最少数量的三次贝塞尔曲线段来逼近一个复杂的字形轮廓，同时确保近似误差（以豪斯多夫距离衡量）低于给定的视觉阈值。这个问题以一种新的方式诠释了极小极大思想：不是在固定模型复杂度下最小化误差，而是在固定的误差容限下最小化模型复杂度。解决这个问题需要一种不同的算法策略——动态规划 (Dynamic Programming)，进一步展示了极小极大思维的灵活性和广泛适用性。[@problem_id:2425561]", "problem": "给定一条平面曲线，它代表一个单笔画的“类字形”轮廓，其形态定性地类似于一个风格化的 Fraktur 字体字母。该曲线被定义为一个参数映射 $\\gamma:[0,1]\\to\\mathbb{R}^2$，在 $N$ 个等距参数 $t_k=\\frac{k}{N-1}$（其中 $k\\in\\{0,1,\\dots,N-1\\}$）处进行采样。采样点为 $P_k=\\gamma(t_k)=(x(t_k),y(t_k))$。该类字形曲线通过以下良定且平滑的构造方法合成：\n- 令 $u(t)=2t-1$。\n- 令包络线为 $e(t)=0.9-0.4\\cos(2\\pi t)$。\n- 定义 $x(t)=u(t)+0.06\\sin(8\\pi t)+0.02\\sin(14\\pi t)$ 和 $y(t)=0.9\\,e(t)\\sin(\\pi u(t))+0.2\\sin(3\\pi u(t))+0.08\\sin(5\\pi u(t))$。\n- 使用 $N=140$ 个采样点。\n\n分段三次贝塞尔逼近是一系列三次贝塞尔段 $\\{B_m\\}_{m=1}^M$，其控制点为 $\\{Q_{m,0},Q_{m,1},Q_{m,2},Q_{m,3}\\}$，其中每一段由下式参数化\n$$\nB_m(\\tau)=(1-\\tau)^3 Q_{m,0}+3\\tau(1-\\tau)^2 Q_{m,1}+3\\tau^2(1-\\tau)Q_{m,2}+\\tau^3 Q_{m,3},\\quad \\tau\\in[0,1],\n$$\n并且连续的段满足 $Q_{m,3}=Q_{m+1,0}$（对于 $m\\in\\{1,\\dots,M-1\\}$），以确保 $C^0$ 连续性。逼近必须从 $P_0$ 开始并在 $P_{N-1}$ 结束，即 $Q_{1,0}=P_0$ 且 $Q_{M,3}=P_{N-1}$。\n\n误差度量（离散对称豪斯多夫距离）：对于覆盖连续样本 $P_i,\\dots,P_j$（其中 $0\\le i<j\\le N-1$）的任意候选段，定义两个离散点集：\n- 一个加密折线集 $A_{i:j}$，通过在每个直线子线段 $[P_k,P_{k+1}]$（其中 $k\\in\\{i,\\dots,j-1\\}$）上采样 $q$ 个等距点获得，包含端点，其中 $q=4$。\n- 一个贝塞尔点集 $B_{i:j}$，通过在 $M_B$ 个均匀间隔的参数 $\\tau_\\ell=\\frac{\\ell}{M_B-1}$（其中 $\\ell\\in\\{0,1,\\dots,M_B-1\\}$）处评估拟合的三次贝塞尔段获得，其中 $M_B=20$。\n\n给定 $\\mathbb{R}^2$ 中的两个有限点集 $A$ 和 $B$，离散对称豪斯多夫距离为\n$$\nd_H(A,B)=\\max\\left\\{\\max_{a\\in A}\\min_{b\\in B}\\|a-b\\|_2,\\ \\max_{b\\in B}\\min_{a\\in A}\\|a-b\\|_2\\right\\}.\n$$\n\n候选段的拟合规则：对于索引 $i<j$，通过设置 $Q_{0}=P_i$、$Q_{3}=P_j$，并选择 $Q_1,Q_2\\in\\mathbb{R}^2$ 以最小化贝塞尔曲线与数据在弦长参数处的残差平方和，从而将单个三次贝塞尔曲线 $B_{i:j}$ 拟合到数据 $P_i,\\dots,P_j$。具体来说，令 $s_k$ 为沿 $P_i,\\dots,P_j$ 的累积弦长，并归一化为 $t_k=\\frac{s_k-s_i}{s_j-s_i}\\in[0,1]$。然后从下式以最小二乘意义求解 $Q_1$ 和 $Q_2$：\n$$\n(1-t_k)^3 Q_0+3t_k(1-t_k)^2 Q_1+3t_k^2(1-t_k) Q_2+t_k^3 Q_3\\approx P_k\n$$\n对于所有 $k\\in\\{i,\\dots,j\\}$。如果 $j=i+1$，使用直线特例 $Q_1=Q_0+\\frac{1}{3}(Q_3-Q_0)$ 和 $Q_2=Q_0+\\frac{2}{3}(Q_3-Q_0)$。\n\n优化目标（极小化极大约束）：对于给定的容差 $\\varepsilon>0$，找到三次贝塞尔段的最小数量 $M$ 和一个划分 $0=i_0<i_1<\\dots<i_M=N-1$，使得对于每个 $m\\in\\{1,\\dots,M\\}$，拟合的贝塞尔曲线 $B_{i_{m-1}:i_m}$ 满足\n$$\nd_H\\!\\left(A_{i_{m-1}:i_m}, B_{i_{m-1}:i_m}\\right)\\le \\varepsilon.\n$$\n\n您的任务是实现一个程序，该程序：\n- 根据指定，构造类字形曲线的 $N$ 个采样点。\n- 对于每对满足 $0\\le i<j\\le N-1$ 的 $(i,j)$，根据上述规则计算拟合的三次贝塞尔曲线 $B_{i:j}$ 和相应的离散对称豪斯多夫误差 $E_{i,j}=d_H\\!\\left(A_{i:j}, B_{i:j}\\right)$。\n- 对于测试套件中的每个容差 $\\varepsilon$，找到所需分段的最小数量 $M(\\varepsilon)$，使得存在一个划分，其中所有分段误差都 $\\le \\varepsilon$。如果不存在这样的划分，则对该 $\\varepsilon$ 返回 $-1$。\n\n测试套件：\n- 使用容差值 $\\varepsilon\\in\\{0.12,\\ 0.08,\\ 0.05,\\ 0.03\\}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表项按测试套件中容差的顺序排列。每个条目必须是对应容差的整数最小分段数 $M(\\varepsilon)$。例如，形如 $[M(0.12),M(0.08),M(0.05),M(0.03)]$ 的输出。\n- 不使用角度。不涉及物理单位。最终输出中的所有数值答案必须是整数。", "solution": "所提出的问题是计算工程领域中一个定义明确的练习，特别是在几何逼近和优化领域。它要求在离散对称豪斯多夫距离定义的逼近误差约束下，找到近似给定平面曲线所需的最少分段三次贝塞尔段数。该问题是有效的，因为它在数学上是合理的、自洽的，并且是算法可解的。\n\n解决方案是一个系统的、多步骤的过程：\n1.  **曲线离散化**：首先，在 $N=140$ 个等距参数值 $t_k = \\frac{k}{N-1}$（其中 $k \\in \\{0, 1, \\dots, N-1\\}$）处对目标参数曲线 $\\gamma(t)$ 进行采样。参数方程如下：\n    $$u(t) = 2t-1$$\n    $$e(t) = 0.9-0.4\\cos(2\\pi t)$$\n    $$x(t) = u(t)+0.06\\sin(8\\pi t)+0.02\\sin(14\\pi t)$$\n    $$y(t) = 0.9\\,e(t)\\sin(\\pi u(t))+0.2\\sin(3\\pi u(t))+0.08\\sin(5\\pi u(t))$$\n    这将生成一组 $N$ 个有序点 $P_k = (x(t_k), y(t_k))$，它们构成了待逼近曲线的离散表示。\n\n2.  **误差预计算**：问题的核心是决定如何划分点序列 $\\{P_k\\}_{k=0}^{N-1}$。为了高效地做出决策，我们预先计算将单个三次贝塞尔段拟合到从 $P_i$ 到 $P_j$ 的每个可能点子序列的逼近误差 $E_{i,j}$，其中 $0 \\le i < j \\le N-1$。\n\n    a.  **贝塞尔拟合**：对于每个子序列 $P_i, \\dots, P_j$，拟合一条三次贝塞尔曲线。控制点表示为 $\\{Q_0, Q_1, Q_2, Q_3\\}$。端点是固定的：$Q_0 = P_i$ 和 $Q_3 = P_j$。内部控制点 $Q_1$ 和 $Q_2$ 通过最小化误差平方和来确定。拟合过程的参数化基于折线 $P_i, \\dots, P_j$ 的归一化累积弦长。令 $s_k$ 为从 $P_i$ 到 $P_k$ 的累积弦长。点 $P_k$ 的归一化参数是 $t_k = (s_k-s_i)/(s_j-s_i)$。拟合目标是求解线性最小二乘问题以得到 $Q_1$ 和 $Q_2$，从而最小化 $\\sum_{k=i+1}^{j-1} \\|B(t_k) - P_k\\|^2$，其中 $B(t)$ 是贝塞尔曲线方程。这可以表示为 $A\\mathbf{x} \\approx \\mathbf{b}$，其中未知数是 $Q_1$ 和 $Q_2$ 的坐标。对于 $j=i+1$ 的简单情况，选择控制点以形成表示为退化三次贝塞尔曲线的直线段。\n\n    b.  **误差计算**：误差 $E_{i,j}$ 是离散对称豪斯多夫距离 $d_H(A_{i:j}, B_{i:j})$。集合 $A_{i:j}$ 是通过加密折线 $P_i, \\dots, P_j$ 生成的，在每个子线段 $[P_k, P_{k+1}]$ 上采样 $q=4$ 个点。集合 $B_{i:j}$ 是通过从拟合的贝塞尔曲线上采样 $M_B=20$ 个点生成的。距离 $d_H(A, B)$ 定义为 $\\max\\left\\{\\max_{a\\in A}\\min_{b\\in B}\\|a-b\\|_2, \\max_{b\\in B}\\min_{a\\in A}\\|a-b\\|_2\\right\\}$。将这些误差存储在一个大小为 $N \\times N$ 的矩阵 $E$ 中，有助于最终的优化步骤。\n\n3.  **通过动态规划进行最优划分**：主要的优化目标是为给定的容差 $\\varepsilon$ 找到最小分段数 $M$。这是一个有向无环图（DAG）上的经典最短路径问题。图的节点是点的索引 $\\{0, 1, \\dots, N-1\\}$。如果从 $P_j$ 到 $P_k$ 拟合单个分段的误差（即 $E_{j,k}$）小于或等于容差 $\\varepsilon$，则从节点 $j$ 到节点 $k$（$j < k$）存在一条有向边。每条这样的边的权重为 $1$。问题就变成了寻找从节点 $0$ 到节点 $N-1$ 的最短路径。\n\n    令 $M[k]$ 为从 $P_0$ 逼近到 $P_k$ 所需的最小分段数。我们可以建立一个动态规划递推关系：\n    $$M[k] = \\min_{0 \\le j < k, \\text{ s.t. } E_{j,k} \\le \\varepsilon} \\{M[j] + 1\\}$$\n    基本情况是 $M[0] = 0$。我们计算 $k=1, \\dots, N-1$ 的 $M[k]$。对于给定的 $\\varepsilon$，最终答案是 $M[N-1]$。如果 $M[N-1]$ 保持为其初始的无穷大值，则表示不存在有效划分，结果为 $-1$。对提供的测试套件中的每个容差 $\\varepsilon$ 重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef solve():\n    \"\"\"\n    Main function to solve the glyph approximation problem.\n    It orchestrates curve generation, error precomputation, and optimization.\n    \"\"\"\n    \n    # Define problem constants.\n    N = 140\n    Q_DENSITY = 4\n    BEZIER_SAMPLES = 20\n    TEST_TOLERANCES = [0.12, 0.08, 0.05, 0.03]\n\n    def generate_curve_points(num_points):\n        \"\"\"Generates the N sample points of the glyph-like curve.\"\"\"\n        t = np.linspace(0, 1, num_points)\n        u = 2 * t - 1\n        envelope = 0.9 - 0.4 * np.cos(2 * np.pi * t)\n        \n        x = u + 0.06 * np.sin(8 * np.pi * t) + 0.02 * np.sin(14 * np.pi * t)\n        y = (0.9 * envelope * np.sin(np.pi * u) + \n             0.2 * np.sin(3 * np.pi * u) + \n             0.08 * np.sin(5 * np.pi * u))\n        \n        return np.vstack((x, y)).T\n\n    def fit_bezier(points_segment):\n        \"\"\"\n        Fits a cubic Bézier curve to a segment of points.\n        Returns the four control points.\n        \"\"\"\n        n_pts = len(points_segment)\n        q0 = points_segment[0]\n        q3 = points_segment[-1]\n        \n        if n_pts == 2:\n            # Special case for j = i + 1, a straight line\n            q1 = q0 + (q3 - q0) / 3.0\n            q2 = q0 + 2.0 * (q3 - q0) / 3.0\n            return np.array([q0, q1, q2, q3])\n\n        # Chord length parameterization for non-linear segments\n        chord_lengths = np.linalg.norm(np.diff(points_segment, axis=0), axis=1)\n        s = np.concatenate(([0], np.cumsum(chord_lengths)))\n        \n        # Avoid division by zero for coincident points\n        if s[-1] == 0:\n            t = np.linspace(0, 1, n_pts)\n        else:\n            t = s / s[-1]\n\n        t_interior = t[1:-1]\n        p_interior = points_segment[1:-1]\n        \n        # Bernstein basis polynomials\n        c1 = 3 * t_interior * (1 - t_interior)**2\n        c2 = 3 * t_interior**2 * (1 - t_interior)\n        \n        # System matrix A for Ax = b\n        a_mat = np.vstack([c1, c2]).T\n        \n        # RHS vector b\n        rhs = (p_interior - \n               (1 - t_interior)[:, np.newaxis]**3 * q0 - \n               t_interior[:, np.newaxis]**3 * q3)\n        \n        # Solve least-squares for inner control points Q1, Q2\n        try:\n            q12, _, _, _ = np.linalg.lstsq(a_mat, rhs, rcond=None)\n            q1, q2 = q12[0], q12[1]\n        except np.linalg.LinAlgError:\n            # Fallback for singular matrix (e.g., collinear points)\n            q1 = q0 + (q3 - q0) / 3.0\n            q2 = q0 + 2.0 * (q3 - q0) / 3.0\n        \n        return np.array([q0, q1, q2, q3])\n\n    def evaluate_bezier(ctrl_pts, num_points):\n        \"\"\"Evaluates a Bézier curve at uniformly spaced parameters.\"\"\"\n        tau = np.linspace(0, 1, num_points)\n        tau_ = 1 - tau\n        \n        b = (tau_[:, np.newaxis]**3 * ctrl_pts[0] + \n             3 * tau_[:, np.newaxis]**2 * tau[:, np.newaxis] * ctrl_pts[1] + \n             3 * tau_[:, np.newaxis] * tau[:, np.newaxis]**2 * ctrl_pts[2] + \n             tau[:, np.newaxis]**3 * ctrl_pts[3])\n        return b\n\n    def get_densified_polyline(points_segment, q_val):\n        \"\"\"Densifies a polyline segment by sampling each sub-segment.\"\"\"\n        points_list = []\n        for k in range(len(points_segment) - 1):\n            points_list.append(np.linspace(points_segment[k], points_segment[k+1], q_val, endpoint=False))\n        points_list.append(points_segment[-1].reshape(1, 2))\n        return np.vstack(points_list)\n\n    def symmetric_hausdorff(set_a, set_b):\n        \"\"\"Computes the discrete symmetric Hausdorff distance between two point sets.\"\"\"\n        dists_ab = cdist(set_a, set_b, 'euclidean')\n        h_a_b = np.max(np.min(dists_ab, axis=1))\n        h_b_a = np.max(np.min(dists_ab, axis=0))\n        return np.max([h_a_b, h_b_a])\n\n    def precompute_errors(p_all):\n        \"\"\"Precomputes the fitting error for all possible segments (i, j).\"\"\"\n        num_points = len(p_all)\n        error_matrix = np.full((num_points, num_points), np.inf)\n        \n        for i in range(num_points):\n            for j in range(i + 1, num_points):\n                segment = p_all[i:j+1]\n                ctrl_pts = fit_bezier(segment)\n                \n                a_set = get_densified_polyline(segment, Q_DENSITY)\n                b_set = evaluate_bezier(ctrl_pts, BEZIER_SAMPLES)\n                \n                error_matrix[i, j] = symmetric_hausdorff(a_set, b_set)\n        return error_matrix\n\n    def find_min_segments(errors, epsilon):\n        \"\"\"Finds the minimum number of segments using dynamic programming.\"\"\"\n        num_points = errors.shape[0]\n        dp = np.full(num_points, np.inf)\n        dp[0] = 0\n        \n        for k in range(1, num_points):\n            for j in range(k):\n                if errors[j, k] <= epsilon:\n                    if dp[j] != np.inf:\n                        dp[k] = min(dp[k], dp[j] + 1)\n        \n        result = dp[-1]\n        return int(result) if result != np.inf else -1\n\n    # Main execution flow\n    points = generate_curve_points(N)\n    errors = precompute_errors(points)\n    \n    results = []\n    for eps in TEST_TOLERANCES:\n        min_segs = find_min_segments(errors, eps)\n        results.append(min_segs)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2425561"}]}