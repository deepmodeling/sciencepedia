{"hands_on_practices": [{"introduction": "现实世界中的许多现象呈现出简单的线性模型无法捕捉的非线性关系。一个强大的策略是使用多项式回归，它将原始输入特征转换为一个更高维的多项式项空间。本练习 [@problem_id:2425201] 将指导您从第一性原理出发，构建一个多元多项式模型来预测材料属性，从而巩固您在特征工程、数据标准化以及通过最小二乘估计求解线性系统方面的技能。", "problem": "考虑使用多元多项式回归模型，学习从分子描述符到正常沸点的非线性映射任务。给定一个化合物训练集，其包含三个描述符：分子量 $M$（单位：克/摩尔），拓扑极性表面积 $A$（单位：平方埃），以及氢键供体数量 $H$（无单位）。目标是正常沸点 $T_b$（单位：开尔文）。您的目标是设计并实现一个程序，从最小二乘估计的基本原理出发，将一个二阶多元多项式模型拟合到训练数据，然后预测一组测试化合物的沸点。\n\n基本原理和约束：\n- 从最小二乘估计的定义出发，即最小化观测目标与预测目标之间残差的平方和。\n- 通过在标准化输入上构建一个最高总阶数为 $2$ 的多项式特征映射来处理非线性关系。具体来说，对于一个描述符向量 $\\mathbf{x} = [M,A,H]^\\top$，将其标准化为 $\\mathbf{z} = ( \\mathbf{x} - \\boldsymbol{\\mu} ) \\oslash \\boldsymbol{\\sigma}$，其中 $\\boldsymbol{\\mu}$ 和 $\\boldsymbol{\\sigma}$ 是根据训练描述符计算的分量均值和标准差，$\\oslash$ 表示逐元素除法。\n- 然后构建特征向量 $\\boldsymbol{\\phi}(\\mathbf{z})$，该向量包含常数项、所有线性项、所有唯一的成对交互项以及所有最高为 $2$ 阶的平方项。\n- 通过最小化训练集上的平方残差来拟合模型参数。不包含任何正则化项。\n- 使用拟合后的模型为提供的测试描述符预测 $T_b$。\n\n训练数据 (每个元组为 $(M,A,H,T_b)$；$M$ 单位为克/摩尔, $A$ 单位为平方埃, $T_b$ 单位为开尔文):\n- $\\left(60,\\,20,\\,1,\\,369.0\\right)$\n- $\\left(80,\\,35,\\,0,\\,382.6\\right)$\n- $\\left(120,\\,40,\\,2,\\,440.0\\right)$\n- $\\left(150,\\,70,\\,1,\\,503.95\\right)$\n- $\\left(90,\\,25,\\,2,\\,401.9\\right)$\n- $\\left(110,\\,60,\\,0,\\,446.45\\right)$\n- $\\left(140,\\,50,\\,1,\\,449.5\\right)$\n- $\\left(70,\\,15,\\,0,\\,343.6\\right)$\n- $\\left(180,\\,80,\\,2,\\,557.4\\right)$\n- $\\left(200,\\,30,\\,3,\\,433.7\\right)$\n- $\\left(100,\\,45,\\,1,\\,429.95\\right)$\n- $\\left(130,\\,55,\\,2,\\,478.4\\right)$\n\n特征构建要求：\n- 仅使用训练描述符计算 $M$、$A$ 和 $H$ 的训练集均值 $\\boldsymbol{\\mu}$ 和标准差 $\\boldsymbol{\\sigma}$。\n- 对于每个描述符向量，计算标准化描述符 $\\mathbf{z} = \\left[z_1, z_2, z_3\\right]^\\top$，即 $z_i = \\left(x_i - \\mu_i\\right)/\\sigma_i$，其中 $i \\in \\{1,2,3\\}$。\n- 构建 $2$ 阶多项式特征向量\n$$\n\\boldsymbol{\\phi}(\\mathbf{z}) = \\left[1,\\, z_1,\\, z_2,\\, z_3,\\, z_1^2,\\, z_2^2,\\, z_3^2,\\, z_1 z_2,\\, z_1 z_3,\\, z_2 z_3 \\right]^\\top.\n$$\n\n模型拟合要求：\n- 在特征空间 $\\boldsymbol{\\phi}(\\mathbf{z})$ 中拟合一个线性模型来预测 $T_b$，方法是使用无正则化的普通最小二乘法，最小化训练集上的残差平方和。\n\n测试集：\n- 为以下四个描述符三元组 $(M,A,H)$ 预测 $T_b$：\n  1. $\\left(95,\\,38,\\,1\\right)$\n  2. $\\left(160,\\,65,\\,2\\right)$\n  3. $\\left(50,\\,10,\\,0\\right)$\n  4. $\\left(210,\\,85,\\,3\\right)$\n\n答案规格和单位：\n- 以开尔文为单位报告每个预测的正常沸点。\n- 将每个预测值四舍五入到最近的 $0.01$ 开尔文。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个四舍五入后的预测值，格式为逗号分隔的列表并用方括号括起来，不含任何额外文本。例如，要求的格式为 [$r_1$,$r_2$,$r_3$,$r_4$]，其中每个 $r_i$ 是一个四舍五入到最近 $0.01$ 开尔文的浮点数。", "solution": "提交审议的问题陈述是有效的。它提出了一个计算工程领域中的适定问题 (well-posed problem)，特别是在定量构效关系 (QSPR) 领域。任务是基于一组分子描述符，为化合物的正常沸点构建一个预测模型。问题提供了所有必要的数据、清晰的模型结构定义，以及基于普通最小二乘法的精确参数估计方法。该问题具有科学依据，逻辑上一致，且没有歧义。因此，可以推导出一个严谨的解。\n\n问题的核心是拟合一个多元多项式回归模型。虽然目标变量沸点 $T_b$ 与原始描述符 $\\mathbf{x} = [M, A, H]^\\top$ 之间的关系是非线性的，但通过构建一组新的特征 $\\boldsymbol{\\phi}(\\mathbf{z})$，该问题被转化为一个线性回归问题。相对于这些工程化的特征，模型假设在系数 $\\mathbf{w}$ 上是线性的：\n$$\n\\hat{T}_b = f(\\mathbf{x}; \\mathbf{w}) = \\mathbf{w}^\\top \\boldsymbol{\\phi}(\\mathbf{z}(\\mathbf{x}))\n$$\n其中 $\\mathbf{z}$ 是标准化后的描述符向量，$\\mathbf{w}$ 是待确定的模型参数向量。\n\n参数 $\\mathbf{w}$ 是通过最小化 $N$ 个样本的训练集上的残差平方和 (SSR) 来找到的。作为成本函数 $J(\\mathbf{w})$ 的 SSR 由下式给出：\n$$\nJ(\\mathbf{w}) = \\sum_{i=1}^{N} (T_{b,i} - \\hat{T}_{b,i})^2 = \\sum_{i=1}^{N} (T_{b,i} - \\mathbf{w}^\\top \\boldsymbol{\\phi}(\\mathbf{z}_i))^2\n$$\n其中 $T_{b,i}$ 是第 $i$ 个样本的观测沸点。\n\n为了便于推导，我们用矩阵表示法来表达。设 $\\mathbf{y}$ 为观测沸点的 $N \\times 1$ 向量，$\\Phi$ 为 $N \\times D$ 的设计矩阵，其中第 $i$ 行是第 $i$ 个训练样本的特征向量 $\\boldsymbol{\\phi}(\\mathbf{z}_i)^\\top$，$D$ 是特征的数量（包括常数项）。在此问题中，$N=12$ 且 $D=10$。成本函数变为：\n$$\nJ(\\mathbf{w}) = (\\mathbf{y} - \\Phi\\mathbf{w})^\\top (\\mathbf{y} - \\Phi\\mathbf{w})\n$$\n展开此表达式可得：\n$$\nJ(\\mathbf{w}) = \\mathbf{y}^\\top\\mathbf{y} - \\mathbf{y}^\\top\\Phi\\mathbf{w} - (\\Phi\\mathbf{w})^\\top\\mathbf{y} + (\\Phi\\mathbf{w})^\\top(\\Phi\\mathbf{w}) = \\mathbf{y}^\\top\\mathbf{y} - 2\\mathbf{w}^\\top\\Phi^\\top\\mathbf{y} + \\mathbf{w}^\\top\\Phi^\\top\\Phi\\mathbf{w}\n$$\n为了找到这个二次函数的最小值，我们计算它关于 $\\mathbf{w}$ 的梯度，并将其设为零向量：\n$$\n\\nabla_{\\mathbf{w}} J(\\mathbf{w}) = -2\\Phi^\\top\\mathbf{y} + 2\\Phi^\\top\\Phi\\mathbf{w} = \\mathbf{0}\n$$\n这就得到了正规方程组：\n$$\n(\\Phi^\\top\\Phi)\\mathbf{w} = \\Phi^\\top\\mathbf{y}\n$$\n假设矩阵 $\\Phi^\\top\\Phi$ 是可逆的（如果 $\\Phi$ 的列是线性无关的，这通常成立），则最优权重向量 $\\mathbf{w}_{\\text{OLS}}$ 的唯一解是：\n$$\n\\mathbf{w}_{\\text{OLS}} = (\\Phi^\\top\\Phi)^{-1} \\Phi^\\top\\mathbf{y}\n$$\n该方程提供了普通最小二乘法的解析解。$(\\Phi^\\top\\Phi)^{-1}\\Phi^\\top$ 这一项被称为 $\\Phi$ 的 Moore-Penrose 伪逆。\n\n实现将遵循以下程序步骤：\n1.  **数据标准化：**\n    首先，使用训练描述符数据（一个 $N \\times 3$ 的矩阵 $\\mathbf{X}_{\\text{train}}$）来计算分量均值向量 $\\boldsymbol{\\mu}$ 和标准差向量 $\\boldsymbol{\\sigma}$。标准差计算时分母使用 $N$，对应于总体标准差。\n    $$\n    \\mu_j = \\frac{1}{N} \\sum_{i=1}^{N} X_{ij}, \\quad \\sigma_j = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} (X_{ij} - \\mu_j)^2}\n    $$\n    然后对每个训练描述符向量 $\\mathbf{x}_i$ 进行标准化：$\\mathbf{z}_i = (\\mathbf{x}_i - \\boldsymbol{\\mu}) \\oslash \\boldsymbol{\\sigma}$。\n\n2.  **特征工程：**\n    对于每个标准化向量 $\\mathbf{z}_i = \\left[z_{i,1}, z_{i,2}, z_{i,3}\\right]^\\top$，按规定构建特征向量 $\\boldsymbol{\\phi}(\\mathbf{z}_i)$：\n    $$\n    \\boldsymbol{\\phi}(\\mathbf{z}_i) = \\left[1,\\, z_{i,1},\\, z_{i,2},\\, z_{i,3},\\, z_{i,1}^2,\\, z_{i,2}^2,\\, z_{i,3}^2,\\, z_{i,1} z_{i,2},\\, z_{i,1} z_{i,3},\\, z_{i,2} z_{i,3} \\right]^\\top\n    $$\n    将这 $N$ 个特征向量按行堆叠，形成 $N \\times D$ 的设计矩阵 $\\Phi$，其中 $N=12$，$D=10$。\n\n3.  **求解正规方程组：**\n    从给定的 $T_b$ 值构成训练目标向量 $\\mathbf{y}$。求解线性系统 $(\\Phi^\\top\\Phi)\\mathbf{w} = \\Phi^\\top\\mathbf{y}$ 以得到 $\\mathbf{w}$。虽然可以直接计算逆矩阵 $(\\Phi^\\top\\Phi)^{-1}$，但其数值稳定性不如使用专用的线性系统求解器。\n\n4.  **预测：**\n    对于每个测试描述符三元组 $\\mathbf{x}_{\\text{test}}$，必须首先使用从训练集计算出的相同 $\\boldsymbol{\\mu}$ 和 $\\boldsymbol{\\sigma}$ 对其进行标准化。然后，构建相应的特征向量 $\\boldsymbol{\\phi}(\\mathbf{z}_{\\text{test}})$。预测值通过点积计算得出：\n    $$\n    \\hat{T}_{b, \\text{test}} = \\mathbf{w}_{\\text{OLS}}^\\top \\boldsymbol{\\phi}(\\mathbf{z}_{\\text{test}})\n    $$\n    最终结果四舍五入到小数点后两位。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the multivariate polynomial regression problem using ordinary least squares.\n    \"\"\"\n    # Training data: (M, A, H, T_b)\n    # M in g/mol, A in Angstrom^2, H is unitless, T_b in Kelvin.\n    training_data = np.array([\n        (60, 20, 1, 369.0),\n        (80, 35, 0, 382.6),\n        (120, 40, 2, 440.0),\n        (150, 70, 1, 503.95),\n        (90, 25, 2, 401.9),\n        (110, 60, 0, 446.45),\n        (140, 50, 1, 449.5),\n        (70, 15, 0, 343.6),\n        (180, 80, 2, 557.4),\n        (200, 30, 3, 433.7),\n        (100, 45, 1, 429.95),\n        (130, 55, 2, 478.4)\n    ])\n\n    # Test data: (M, A, H)\n    test_cases = np.array([\n        (95, 38, 1),\n        (160, 65, 2),\n        (50, 10, 0),\n        (210, 85, 3)\n    ])\n\n    # Step 1: Separate descriptors and targets from training data\n    X_train = training_data[:, :3]\n    y_train = training_data[:, 3]\n\n    # Step 2: Compute standardization parameters from the training set\n    mu = np.mean(X_train, axis=0)\n    # ddof=0 for population standard deviation, as is standard when not specified\n    sigma = np.std(X_train, axis=0, ddof=0)\n\n    # Standardize the training descriptors\n    Z_train = (X_train - mu) / sigma\n\n    # Step 3: Construct the design matrix Phi from the standardized training data\n    def construct_feature_matrix(Z):\n        \"\"\"Constructs the polynomial feature matrix from standardized descriptors.\"\"\"\n        n_samples = Z.shape[0]\n        z1, z2, z3 = Z[:, 0], Z[:, 1], Z[:, 2]\n        \n        # The feature vector is [1, z1, z2, z3, z1^2, z2^2, z3^2, z1*z2, z1*z3, z2*z3]\n        phi = np.zeros((n_samples, 10))\n        phi[:, 0] = 1\n        phi[:, 1] = z1\n        phi[:, 2] = z2\n        phi[:, 3] = z3\n        phi[:, 4] = z1**2\n        phi[:, 5] = z2**2\n        phi[:, 6] = z3**2\n        phi[:, 7] = z1 * z2\n        phi[:, 8] = z1 * z3\n        phi[:, 9] = z2 * z3\n        return phi\n\n    Phi_train = construct_feature_matrix(Z_train)\n\n    # Step 4: Solve the normal equations to find the weight vector w\n    # (Phi^T * Phi) * w = Phi^T * y\n    # Use np.linalg.solve for numerical stability instead of direct inversion.\n    try:\n        A = Phi_train.T @ Phi_train\n        b = Phi_train.T @ y_train\n        w = np.linalg.solve(A, b)\n    except np.linalg.LinAlgError:\n        # Fallback to least-squares solver if matrix is singular.\n        # This is more robust and directly minimizes the sum of squares.\n        w, _, _, _ = np.linalg.lstsq(Phi_train, y_train, rcond=None)\n\n    # Step 5: Predict T_b for the test cases\n    # Standardize test data using training set parameters\n    Z_test = (test_cases - mu) / sigma\n    \n    # Construct the feature matrix for the test data\n    Phi_test = construct_feature_matrix(Z_test)\n    \n    # Perform prediction\n    predictions = Phi_test @ w\n\n    # Round the predictions to the nearest 0.01 Kelvin\n    rounded_predictions = np.round(predictions, 2)\n    \n    # Format the final output string\n    result_str = \",\".join([f\"{p:.2f}\" for p in rounded_predictions])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```", "id": "2425201"}, {"introduction": "当一个模型的参数本身就是非线性的时候，我们必须转向迭代优化方法。高斯-牛顿算法是解决此类非线性最小二乘问题的基础技术。本实践 [@problem_id:2425266] 要求您为一个常见的药物代谢动力学模型推导并实现雅可比矩阵，让您亲身体验迭代参数更新的核心机制，并理解导数在指导优化过程中的核心作用。", "problem": "您的任务是为一个双室药代动力学浓度-时间模型的非线性最小二乘拟合推导并实现雅可比矩阵。该模型由两个衰减指数项之和给出：对于时间 $t$（单位为小时）和浓度 $C(t)$（单位为毫克/升，mg/L），\n$$\nC(t) = A e^{-\\alpha t} + B e^{-\\beta t},\n$$\n其中 $A$ 和 $B$ 是振幅（单位为毫克/升），$\\alpha$ 和 $\\beta$ 是衰减率（单位为小时的倒数）。请从非线性最小二乘和雅可比矩阵的标准定义出发，推导残差向量关于参数向量 $\\theta = [A, B, \\alpha, \\beta]^T$ 的雅可比矩阵，并在程序中实现它。使用该雅可比矩阵为一组测试用例执行单步带有Levenberg–Marquardt阻尼的高斯-牛顿迭代。\n\n请仅基于以下基本事实进行推导：\n- 对于数据 $\\{(t_i, y_i)\\}_{i=1}^N$，残差向量分量为 $r_i(\\theta) = y_i - C(t_i; \\theta)$。\n- 雅可比矩阵定义为 $J_{ij} = \\frac{\\partial r_i}{\\partial \\theta_j}$。\n- 高斯-牛顿步 $\\Delta \\theta$ 通过求解线性系统来近似最小化残差平方和\n$$\n\\left(J^T J + \\lambda I\\right) \\Delta \\theta = J^T r,\n$$\n其中 $\\lambda$ 是一个阻尼参数，$I$ 是单位矩阵。\n\n实现要求：\n1. 根据上述定义解析推导雅可比矩阵。除模型定义外，不要假定任何预先推导的公式。\n2. 实现一个函数，用于计算 $C(t; \\theta)$ 以及残差关于 $\\theta$ 的雅可比矩阵。\n3. 实现一次带有Levenberg–Marquardt阻尼的高斯-牛顿迭代来计算 $\\theta_{\\text{new}} = \\theta_{\\text{old}} + \\Delta \\theta$，使用固定的阻尼参数 $\\lambda = 10^{-6}$。\n4. 使用以下测试套件。在每种情况下，使用给定的真实参数从模型中精确生成合成观测值 $y_i$（无噪声），然后从给定的初始猜测值开始，精确计算一个更新步。所有时间输入单位为小时，所有浓度单位为毫克/升。输出参数估计值 $A$ 和 $B$（单位为毫克/升）以及 $\\alpha$ 和 $\\beta$（单位为小时的倒数）。\n   - 情况1（包含 $t=0$ 的一般情况）： \n     - 时间：$0$, $0.5$, $1$, $2$, $4$, $8$。\n     - 真实参数：$A = 5$, $B = 2$, $\\alpha = 0.8$, $\\beta = 0.1$。\n     - 初始猜测：$A = 4.5$, $B = 1$, $\\alpha = 0.6$, $\\beta = 0.2$。\n   - 情况2（近似共线的指数项，测试条件性）：\n     - 时间：$0$, $1$, $2$, $3$, $6$。\n     - 真实参数：$A = 3$, $B = 3$, $\\alpha = 0.2$, $\\beta = 0.2001$。\n     - 初始猜测：$A = 2.5$, $B = 3.5$, $\\alpha = 0.22$, $\\beta = 0.19$。\n   - 情况3（一个振幅等于零）：\n     - 时间：$0$, $1$, $3$, $5$, $10$。\n     - 真实参数：$A = 2$, $B = 0$, $\\alpha = 0.5$, $\\beta = 0.2$。\n     - 初始猜测：$A = 1$, $B = 0.5$, $\\alpha = 0.3$, $\\beta = 0.3$。\n   - 情况4（长时间内的慢衰减）：\n     - 时间：$0$, $6$, $12$, $18$, $24$。\n     - 真实参数：$A = 1.5$, $B = 0.5$, $\\alpha = 0.05$, $\\beta = 0.01$。\n     - 初始猜测：$A = 1.2$, $B = 0.4$, $\\alpha = 0.06$, $\\beta = 0.008$。\n5. 最终输出格式：您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。按顺序连接每种情况更新后的参数，格式为 $[A_1, B_1, \\alpha_1, \\beta_1, A_2, B_2, \\alpha_2, \\beta_2, A_3, B_3, \\alpha_3, \\beta_3, A_4, B_4, \\alpha_4, \\beta_4]$，其中下标表示情况编号。参数 $A$ 和 $B$ 以毫克/升表示，$\\alpha$ 和 $\\beta$ 以小时的倒数表示。每个数值打印时保留六位小数。不涉及角度。最终输出中不出现百分比。", "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 浓度模型 $C(t)$: $C(t) = A e^{-\\alpha t} + B e^{-\\beta t}$。\n- 参数向量：$\\theta = [A, B, \\alpha, \\beta]^T$。\n- 残差向量分量：对于数据 $\\{(t_i, y_i)\\}_{i=1}^N$，$r_i(\\theta) = y_i - C(t_i; \\theta)$。\n- 雅可比矩阵定义：$J_{ij} = \\frac{\\partial r_i}{\\partial \\theta_j}$。\n- 带Levenberg-Marquardt阻尼的高斯-牛顿线性系统：$(J^T J + \\lambda I) \\Delta \\theta = J^T r$。\n- 阻尼参数：$\\lambda = 10^{-6}$。\n- 参数更新规则：$\\theta_{\\text{new}} = \\theta_{\\text{old}} + \\Delta \\theta$。\n- 测试用例：提供了四个用例，每个用例都有一组时间点 $t_i$、用于生成合成数据 $y_i$ 的真实参数，以及一个初始参数猜测值 $\\theta_{\\text{old}}$。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题基于双室药代动力学模型，这是药理学中的一个标准模型。求解方法，即带Levenberg-Marquardt阻尼的高斯-牛顿法，是非线性最小二乘优化的一个基本且广泛使用的算法。所有定义都是标准且正确的。\n- **适定性**：该问题是适定的。它要求计算一个迭代算法的单个、明确定义的步骤。所有必要的数据和常量（$\\lambda$、初始猜测值、时间点）都已提供。Levenberg-Marquardt修正 $(J^T J + \\lambda I)$ 确保了对于$\\lambda > 0$，矩阵是正定的，因而是可逆的，从而保证了参数更新量 $\\Delta \\theta$ 有唯一解。\n- **客观性**：该问题使用精确、客观的数学语言陈述。\n- **结论**：该问题科学上合理、适定、客观，并包含足够的信息以获得唯一解。该问题是有效的。\n\n**步骤3：裁定与行动**\n问题有效。将提供完整解决方案。\n\n**推导与实现**\n\n目标是使用带Levenberg–Marquardt阻尼的高斯-牛顿法，为一个非线性最小二乘问题计算单步参数更新。这需要解析推导残差的雅可比矩阵。\n\n参数向量为 $\\theta = [\\theta_1, \\theta_2, \\theta_3, \\theta_4]^T = [A, B, \\alpha, \\beta]^T$。\n在时间 $t_i$ 的浓度模型函数为：\n$$C(t_i; \\theta) = A e^{-\\alpha t_i} + B e^{-\\beta t_i}$$\n第 $i$ 个观测值 $(t_i, y_i)$ 的残差为：\n$$r_i(\\theta) = y_i - C(t_i; \\theta)$$\n雅可比矩阵 $J$ 的元素为 $J_{ij} = \\frac{\\partial r_i}{\\partial \\theta_j}$。由于观测数据 $y_i$ 相对于参数 $\\theta$ 是常数，因此微分仅适用于模型函数：\n$$J_{ij} = \\frac{\\partial}{\\partial \\theta_j} (y_i - C(t_i; \\theta)) = -\\frac{\\partial C(t_i; \\theta)}{\\partial \\theta_j}$$\n雅可比矩阵将有 $N$ 行，对应 $N$ 个数据点，以及4列，对应 $\\theta$ 中的四个参数。我们现在计算 $C(t_i; \\theta)$ 关于每个参数的偏导数。\n\n1.  **关于 $A$ ($\\theta_1$) 的偏导数：**\n    $$\\frac{\\partial C(t_i)}{\\partial A} = \\frac{\\partial}{\\partial A} (A e^{-\\alpha t_i} + B e^{-\\beta t_i}) = e^{-\\alpha t_i}$$\n    因此，雅可比矩阵的第一列是 $J_{i1} = -e^{-\\alpha t_i}$。\n\n2.  **关于 $B$ ($\\theta_2$) 的偏导数：**\n    $$\\frac{\\partial C(t_i)}{\\partial B} = \\frac{\\partial}{\\partial B} (A e^{-\\alpha t_i} + B e^{-\\beta t_i}) = e^{-\\beta t_i}$$\n    因此，雅可比矩阵的第二列是 $J_{i2} = -e^{-\\beta t_i}$。\n\n3.  **关于 $\\alpha$ ($\\theta_3$) 的偏导数：**\n    $$\\frac{\\partial C(t_i)}{\\partial \\alpha} = \\frac{\\partial}{\\partial \\alpha} (A e^{-\\alpha t_i} + B e^{-\\beta t_i}) = A \\cdot (e^{-\\alpha t_i} \\cdot (-t_i)) = -A t_i e^{-\\alpha t_i}$$\n    因此，雅可比矩阵的第三列是 $J_{i3} = -(-A t_i e^{-\\alpha t_i}) = A t_i e^{-\\alpha t_i}$。\n\n4.  **关于 $\\beta$ ($\\theta_4$) 的偏导数：**\n    $$\\frac{\\partial C(t_i)}{\\partial \\beta} = \\frac{\\partial}{\\partial \\beta} (A e^{-\\alpha t_i} + B e^{-\\beta t_i}) = B \\cdot (e^{-\\beta t_i} \\cdot (-t_i)) = -B t_i e^{-\\beta t_i}$$\n    因此，雅可比矩阵的第四列是 $J_{i4} = -(-B t_i e^{-\\beta t_i}) = B t_i e^{-\\beta t_i}$。\n\n綜合这些结果，雅可比矩阵 $J$ 的第 $i$ 行由下式给出：\n$$[J]_{i,:} = \\begin{bmatrix} -e^{-\\alpha t_i} & -e^{-\\beta t_i} & A t_i e^{-\\alpha t_i} & B t_i e^{-\\beta t_i} \\end{bmatrix}$$\n该雅可比矩阵使用当前的参数估计值 $\\theta_{\\text{old}}$ 进行计算。\n\n对每个测试用例，高斯-牛顿算法按以下步骤进行：\n1.  使用提供的真实参数 $(\\theta_{\\text{true}})$ 和时间点 $t_i$ 生成合成数据点 $y_i$：$y_i = C(t_i; \\theta_{\\text{true}})$。\n2.  将当前参数 $\\theta$ 设置为初始猜测值 $\\theta_{\\text{old}}$。\n3.  计算残差向量 $r$，其中每个元素为 $r_i = y_i - C(t_i; \\theta_{\\text{old}})$。\n4.  使用推导出的公式计算雅可比矩阵 $J$，在 $\\theta_{\\text{old}}$ 和所有 $t_i$ 处求值。\n5.  构建近似Hessian矩阵 $H = J^T J + \\lambda I$，其中 $J^T$ 是 $J$ 的转置，$\\lambda = 10^{-6}$ 是阻尼参数，$I$ 是 $4 \\times 4$ 单位矩阵。\n6.  构建右侧向量 $g = J^T r$。\n7.  求解正规方程组的线性系统 $H \\Delta \\theta = g$，得到参数更新向量 $\\Delta \\theta$。\n8.  计算新的参数估计值 $\\theta_{\\text{new}} = \\theta_{\\text{old}} + \\Delta \\theta$。\n\n此过程将针对问题陈述中指定的四个测试用例进行实现和执行。每个用例得到的 $\\theta_{\\text{new}}$ 向量将被连接起来，形成最终输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements the Jacobian for a two-compartment pharmacokinetic model,\n    and performs a single Gauss-Newton step with Levenberg-Marquardt damping\n    for several test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general case with t=0 included)\n        {\n            \"times\": np.array([0, 0.5, 1, 2, 4, 8], dtype=np.float64),\n            \"true_params\": np.array([5.0, 2.0, 0.8, 0.1], dtype=np.float64),\n            \"initial_guess\": np.array([4.5, 1.0, 0.6, 0.2], dtype=np.float64),\n        },\n        # Case 2 (nearly collinear exponentials, tests conditioning)\n        {\n            \"times\": np.array([0, 1, 2, 3, 6], dtype=np.float64),\n            \"true_params\": np.array([3.0, 3.0, 0.2, 0.2001], dtype=np.float64),\n            \"initial_guess\": np.array([2.5, 3.5, 0.22, 0.19], dtype=np.float64),\n        },\n        # Case 3 (one amplitude equal to zero)\n        {\n            \"times\": np.array([0, 1, 3, 5, 10], dtype=np.float64),\n            \"true_params\": np.array([2.0, 0.0, 0.5, 0.2], dtype=np.float64),\n            \"initial_guess\": np.array([1.0, 0.5, 0.3, 0.3], dtype=np.float64),\n        },\n        # Case 4 (slow decays over long times)\n        {\n            \"times\": np.array([0, 6, 12, 18, 24], dtype=np.float64),\n            \"true_params\": np.array([1.5, 0.5, 0.05, 0.01], dtype=np.float64),\n            \"initial_guess\": np.array([1.2, 0.4, 0.06, 0.008], dtype=np.float64),\n        }\n    ]\n\n    lambda_damping = 1e-6\n    all_results = []\n\n    def model(t, params):\n        \"\"\"Computes C(t) = A*exp(-alpha*t) + B*exp(-beta*t)\"\"\"\n        A, B, alpha, beta = params\n        return A * np.exp(-alpha * t) + B * np.exp(-beta * t)\n\n    def jacobian(t, params):\n        \"\"\"\n        Computes the Jacobian of the residuals vector with respect to the parameters.\n        The i-th row is [d(r_i)/dA, d(r_i)/dB, d(r_i)/d_alpha, d(r_i)/d_beta].\n        Since r_i = y_i - C_i, d(r_i)/d(theta_j) = -d(C_i)/d(theta_j).\n        \"\"\"\n        A, B, alpha, beta = params\n        num_points = len(t)\n        J = np.zeros((num_points, 4), dtype=np.float64)\n\n        exp_alpha_t = np.exp(-alpha * t)\n        exp_beta_t = np.exp(-beta * t)\n\n        # dC/dA = exp(-alpha*t)\n        J[:, 0] = -exp_alpha_t\n        # dC/dB = exp(-beta*t)\n        J[:, 1] = -exp_beta_t\n        # dC/d_alpha = -A*t*exp(-alpha*t)\n        J[:, 2] = -(-A * t * exp_alpha_t)\n        # dC/d_beta = -B*t*exp(-beta*t)\n        J[:, 3] = -(-B * t * exp_beta_t)\n        \n        return J\n\n    for case in test_cases:\n        times = case[\"times\"]\n        true_params = case[\"true_params\"]\n        theta_old = case[\"initial_guess\"]\n\n        # Step 1: Generate synthetic observation data (without noise)\n        y_obs = model(times, true_params)\n\n        # Step 2: Calculate residuals based on the initial guess\n        y_pred = model(times, theta_old)\n        residuals = y_obs - y_pred\n\n        # Step 3: Calculate the Jacobian matrix at the initial guess\n        J = jacobian(times, theta_old)\n\n        # Step 4: Form and solve the Gauss-Newton system with LM damping\n        # (J^T J + lambda I) * delta_theta = J^T * r\n        J_T = J.T\n        J_T_J = J_T @ J\n        \n        # Add damping factor\n        H = J_T_J + lambda_damping * np.identity(4)\n        \n        rhs = J_T @ residuals\n\n        delta_theta = np.linalg.solve(H, rhs)\n\n        # Step 5: Update the parameters for one iteration\n        theta_new = theta_old + delta_theta\n        all_results.extend(theta_new)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.6f}' for x in all_results)}]\")\n\nsolve()\n```", "id": "2425266"}, {"introduction": "非线性回归技术对于解释来自复杂物理系统的数据至关重要。这项高级实践 [@problem_id:2425215] 将挑战您将一个基于物理的等效电路模型拟合到电化学实验产生的复阻抗数据，这是一项在材料科学和电池工程中的常见任务。通过为复数值数据实现非线性拟合，您将学会如何从实验测量中提取有意义的物理参数，并体验基于模型的分析相对于纯粹经验曲线拟合的优越性。", "problem": "您面临一项基于电化学阻抗谱 (EIS) 的建模任务。目标是根据第一性原理，建立一个非线性回归模型，以拟合一个简单等效电路的频率相关复阻抗，并将其与奈奎斯特平面上的局部多项式近似进行比较。该等效电路是一个串联电阻与一个由电荷转移电阻和恒相元件组成的并联电路相串联。请使用以下核心定义作为您推导和实现的起点。\n\n1) 电路与阻抗基础：\n- 电阻为 $R$ 的电阻器的复阻抗为 $Z_R(\\omega)=R$。\n- 幅度参数为 $Q$、指数为 $\\alpha$ 的恒相元件 (CPE) 的导纳为 $Y_{\\mathrm{CPE}}(\\omega) = Q\\,(i\\,\\omega)^{\\alpha}$，其中 $i$ 是虚数单位，$\\omega = 2\\pi f$ 是角频率（单位为弧度/秒），对应于频率 $f$（单位为赫兹）。\n- 对于串联元件，阻抗相加：$Z_{\\mathrm{series}} = \\sum_k Z_k$。\n- 对于并联元件，导纳相加：$Y_{\\mathrm{parallel}} = \\sum_k Y_k$，且 $Z_{\\mathrm{parallel}} = 1 / Y_{\\mathrm{parallel}}$。\n\n2) 待建模的等效电路：\n- 一个串联电阻 $R_s$与一个由电荷转移电阻 $R_{ct}$ 和参数为 $(Q,\\alpha)$ 的恒相元件 (CPE) 组成的并联电路相串联。根据上述定义，推导出复阻抗模型 $Z(\\omega;\\theta)$，其中 $\\theta = (R_s, R_{ct}, Q, \\alpha)$。\n\n3) 奈奎斯特平面量：\n- 对于复阻抗 $Z(\\omega) = X(\\omega) + i Y(\\omega)$，奈奎斯特图使用 $x = \\mathrm{Re}(Z) = X(\\omega)$ 和 $y = -\\mathrm{Im}(Z) = -Y(\\omega)$。\n- 在局部，通过一个2次多项式回归 $y(x) \\approx a x^2 + b x + c$ 来近似圆弧顶点附近的部分，并利用解析几何计算顶点的位置和高度。如果 $a \\neq 0$，顶点出现在 $x^\\star = -\\frac{b}{2a}$ 处，高度为 $y^\\star = c - \\frac{b^2}{4a}$。\n\n4) 估计任务：\n- 将参数估计视为复平面上的一个非线性最小二乘问题，通过最小化所有频率上实部和虚部的残差平方和来求解。\n- 通过将模型阻抗与带噪观测值在所有频率上的实部和虚部差异堆叠起来，构建一个实值残差向量。\n\n5) 数据生成协议（确定性与可复现性）：\n- 使用一个包含 $N = 81$ 个点的对数间隔频率网格，频率范围从 $f_{\\min} = 10^{-1}$ 赫兹到 $f_{\\max} = 10^{5}$ 赫兹。所有涉及频率的计算都必须使用角频率（单位为弧度/秒），其中 $\\omega = 2\\pi f$。\n- 对于下面的每个测试用例，生成无噪声的复阻抗 $Z_{\\mathrm{true}}(\\omega;\\theta_{\\mathrm{true}})$，然后对其的实部和虚部分别添加独立的、均值为零、标准差为 $\\sigma = 0.05$ 欧姆的高斯噪声。使用一个固定的随机数生成器，种子为 $12345$。\n- 对于多项式回归，使用按 $y$ 值（$y = -\\mathrm{Im}(Z)$ 的最大值）排序的前 $K$ 个点，其中 $K = \\min(25, N)$，来拟合2次多项式 $y(x)$ 并计算 $y^\\star$。如果拟合的二次项系数 $a = 0$，则将 $y^\\star$ 设置为所选点中的最大 $y$ 值。\n\n6) 非线性回归模型：\n- 拟合参数矢量 $\\theta = (R_s, R_{ct}, Q, \\alpha)$，并施加边界约束以确保 $R_s > 0$、$R_{ct} > 0$、$Q > 0$ 和 $0 < \\alpha \\le 1$。根据数据使用合理的初始化，并使用标准的信赖域方法解决非线性最小二乘问题。\n\n7) 测试套件（四个测试用例）：\n对于每个用例，按规定生成数据，然后通过多项式回归估计参数和奈奎斯特顶点高度。报告 $R_s$ 和 $R_{ct}$（单位：欧姆），$Q$（单位：法拉-秒的 $(\\alpha-1)$ 次方），$\\alpha$（无单位），以及 $y^\\star$（单位：欧姆）。所有报告的数值四舍五入到六位小数。\n\n- 用例 1: $R_s = 5.0$ 欧姆, $R_{ct} = 50.0$ 欧姆, $Q = 10^{-3}$ 法拉-秒的 $(\\alpha-1)$ 次方, $\\alpha = 0.9$。\n- 用例 2: $R_s = 2.0$ 欧姆, $R_{ct} = 20.0$ 欧姆, $Q = 2\\times 10^{-3}$ 法拉-秒的 $(\\alpha-1)$ 次方, $\\alpha = 1.0$。\n- 用例 3: $R_s = 20.0$ 欧姆, $R_{ct} = 5.0$ 欧姆, $Q = 5\\times 10^{-4}$ 法拉-秒的 $(\\alpha-1)$ 次方, $\\alpha = 0.8$。\n- 用例 4: $R_s = 1.0$ 欧姆, $R_{ct} = 200.0$ 欧姆, $Q = 10^{-4}$ 法拉-秒的 $(\\alpha-1)$ 次方, $\\alpha = 0.95$。\n\n8) 要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。\n- 对于每个用例 $j \\in \\{1,2,3,4\\}$，按以下顺序附加五个数字：$\\widehat{R_s}$、$\\widehat{R_{ct}}$、$\\widehat{Q}$、$\\widehat{\\alpha}$ 和 $y^\\star$（二次拟合的顶点高度），每个数字四舍五入到六位小数。\n- 因此，最终输出必须是按用例 1 到 4 顺序排列的长度为 20 的单个列表，例如：$[\\widehat{R_s^{(1)}},\\widehat{R_{ct}^{(1)}},\\widehat{Q^{(1)}},\\widehat{\\alpha^{(1)}},y^{\\star (1)},\\dots,\\widehat{R_s^{(4)}},\\widehat{R_{ct}^{(4)}},\\widehat{Q^{(4)}},\\widehat{\\alpha^{(4)}},y^{\\star (4)}]$。", "solution": "我们从线性时不变电路分析和复阻抗的基本原理出发。目标电路是一个串联电阻与一个由电荷转移电阻和恒相元件 (CPE) 组成的并联电路相串联。参数集为 $\\theta = (R_s, R_{ct}, Q, \\alpha)$，其中 $R_s > 0$, $R_{ct} > 0$, $Q > 0$, 且 $0 < \\alpha \\le 1$。\n\n1) 基本定义。电阻器的阻抗为 $Z_R(\\omega) = R$。CPE 是一种分数阶元件，常用于模拟分布电容行为或表面非均一性。其导纳为 $Y_{\\mathrm{CPE}}(\\omega) = Q (i \\omega)^\\alpha$，其中 $Q > 0$ 是幅度参数，$0 < \\alpha \\le 1$ 是指数。角频率为 $\\omega = 2 \\pi f$，其中 $f$ 的单位是赫兹，$i$ 是虚数单位。对于串联连接，阻抗相加：$Z_{\\mathrm{series}} = \\sum_k Z_k$。对于并联连接，导纳相加：$Y_{\\mathrm{parallel}} = \\sum_k Y_k$，净阻抗为 $Z_{\\mathrm{parallel}} = 1/ Y_{\\mathrm{parallel}}$。\n\n2) 模型推导。并联子电路包含一个电阻为 $R_{ct}$ 的电阻器和一个 CPE，因此其导纳为 $Y_{\\parallel}(\\omega) = \\frac{1}{R_{ct}} + Q (i \\omega)^\\alpha$。所以，其阻抗为 $Z_{\\parallel}(\\omega) = \\frac{1}{\\frac{1}{R_{ct}} + Q (i \\omega)^\\alpha}$。完整的等效电路是 $R_s$ 与该并联阻抗的串联组合。因此，根据串联加法规则，\n$$\nZ(\\omega;\\theta) = R_s + \\frac{1}{\\frac{1}{R_{ct}} + Q (i \\omega)^\\alpha}.\n$$\n这个表达式对于参数 $Q$ 和 $\\alpha$ 是非线性的，并且作为 $\\omega$ 的函数是复数值的。\n\n3) 奈奎斯特表示法。对于任何复阻抗 $Z(\\omega) = X(\\omega) + i Y(\\omega)$，奈奎斯特图显示的点坐标为 $x = X(\\omega) = \\mathrm{Re}(Z)$ 和 $y = -Y(\\omega) = -\\mathrm{Im}(Z)$。对于一个串联电阻与一个并联支路的组合，奈奎斯特轨迹通常形成一个圆弧，其顶点对应于一个特征弛豫频率。在顶点附近局部，该曲线可以用二次模型 $y(x) \\approx a x^2 + b x + c$ 来近似。\n\n4) 非线性最小二乘公式。假设我们在角频率 $\\{\\omega_k\\}_{k=1}^N$ 处测量了复阻抗 $Z_{\\mathrm{obs}}(\\omega_k)$。一个自然的实值残差向量将实部和虚部的误差堆叠起来：\n$$\nr(\\theta) = \\begin{bmatrix}\n\\mathrm{Re}\\left(Z(\\omega_1;\\theta)\\right) - \\mathrm{Re}\\left(Z_{\\mathrm{obs}}(\\omega_1)\\right) \\\\\n\\vdots \\\\\n\\mathrm{Re}\\left(Z(\\omega_N;\\theta)\\right) - \\mathrm{Re}\\left(Z_{\\mathrm{obs}}(\\omega_N)\\right) \\\\\n\\mathrm{Im}\\left(Z(\\omega_1;\\theta)\\right) - \\mathrm{Im}\\left(Z_{\\mathrm{obs}}(\\omega_1)\\right) \\\\\n\\vdots \\\\\n\\mathrm{Im}\\left(Z(\\omega_N;\\theta)\\right) - \\mathrm{Im}\\left(Z_{\\mathrm{obs}}(\\omega_N)\\right)\n\\end{bmatrix}.\n$$\n非线性回归问题旨在最小化目标函数\n$$\n\\min_{\\theta} \\; \\| r(\\theta) \\|_2^2\n$$\n同时满足边界约束 $R_s > 0$, $R_{ct} > 0$, $Q > 0$, 和 $0 < \\alpha \\le 1$。信赖域反射算法能有效解决此类问题，并在标准数值库中有很好的实现。\n\n5) 初始化和约束。合理的初始化可以提高鲁棒性：\n- $R_s$ 的一个粗略估计是所有频率下测得的 $\\mathrm{Re}(Z)$ 的最小值，即 $R_s^{(0)} \\approx \\min_k \\mathrm{Re}\\left(Z_{\\mathrm{obs}}(\\omega_k)\\right)$。\n- 实轴的总跨度表明 $R_{ct}^{(0)} \\approx \\max_k \\mathrm{Re}(Z_{\\mathrm{obs}}(\\omega_k)) - R_s^{(0)}$。\n- 初始指数 $\\alpha^{(0)}$ 接近 $0.9$ 通常是合理的。\n- $Q^{(0)}$ 的一个启发式方法是使用观测到的奈奎斯特圆弧的峰值频率。对于一个电阻与 CPE 的并联，特征频率通常遵循 $(\\omega_{\\mathrm{peak}} R_{ct} Q)^{\\alpha} \\approx 1$，这表明 $Q^{(0)} \\approx \\frac{1}{R_{ct}^{(0)} \\, \\omega_{\\mathrm{peak}}^{\\alpha^{(0)}}}$，其中 $\\omega_{\\mathrm{peak}}$ 通过 $y = -\\mathrm{Im}(Z_{\\mathrm{obs}})$ 达到最大值时的频率指数来估计。\n\n我们施加边界约束，如 $R_s \\in [10^{-6}, 10^{3}]$、$R_{ct} \\in [10^{-6}, 10^{4}]$、$Q \\in [10^{-6}, 1]$ 和 $\\alpha \\in [0.4, 1.0]$，以保持物理合理性。\n\n6) 奈奎斯特平面上的多项式回归。为了估计顶点高度 $y^\\star$，我们按 $y = -\\mathrm{Im}(Z_{\\mathrm{obs}})$ 的值选择前 $K = \\min(25, N)$ 个点，并以最小二乘法拟合一个2次多项式 $y(x) \\approx a x^2 + b x + c$。对于一个开口向下的二次曲线（$a < 0$），顶点位于 $x^\\star = -\\frac{b}{2a}$，高度为 $y^\\star = c - \\frac{b^2}{4a}$。如果 $a=0$，我们将 $y^\\star$ 设为所选点中的最大 $y$ 值。这构成了一种局部多项式回归，展示了与基于物理的非线性拟合不同的回归模式。\n\n7) 数据生成和测试套件。我们为从 $f_{\\min} = 10^{-1}$ 赫兹到 $f_{\\max} = 10^{5}$ 赫兹的 $N = 81$ 个对数间隔频率生成合成观测数据。对于每个测试用例，我们计算 $Z_{\\mathrm{true}}(\\omega;\\theta_{\\mathrm{true}})$，然后分别向实部和虚部添加独立的、均值为零、标准差为 $\\sigma = 0.05$ 欧姆的高斯噪声。为了可复现性，随机种子固定为 $12345$。四个测试用例如下：\n- 用例 1: $R_s = 5.0$, $R_{ct} = 50.0$, $Q = 10^{-3}$, $\\alpha = 0.9$。\n- 用例 2: $R_s = 2.0$, $R_{ct} = 20.0$, $Q = 2\\times 10^{-3}$, $\\alpha = 1.0$。\n- 用例 3: $R_s = 20.0$, $R_{ct} = 5.0$, $Q = 5\\times 10^{-4}$, $\\alpha = 0.8$。\n- 用例 4: $R_s = 1.0$, $R_{ct} = 200.0$, $Q = 10^{-4}$, $\\alpha = 0.95$。\n\n8) 输出与单位。对于每个用例，报告拟合的参数 $\\widehat{R_s}$ 和 $\\widehat{R_{ct}}$（单位：欧姆），$\\widehat{Q}$（单位：法拉-秒的 $(\\alpha-1)$ 次方），$\\widehat{\\alpha}$（无单位），以及多项式顶点高度 $y^\\star$（单位：欧姆）。所有值四舍五入到六位小数。将所有四个用例的结果汇总成一个长度为 20 的列表，顺序为 $[\\widehat{R_s^{(1)}},\\widehat{R_{ct}^{(1)}},\\widehat{Q^{(1)}},\\widehat{\\alpha^{(1)}},y^{\\star (1)},\\dots,\\widehat{R_s^{(4)}},\\widehat{R_{ct}^{(4)}},\\widehat{Q^{(4)}},\\widehat{\\alpha^{(4)}},y^{\\star (4)}]$ 并精确打印此列表。\n\n算法实现细节：\n- 计算 $\\omega_k = 2\\pi f_k$，其中 $f_k$ 是对数间隔的。\n- 给定 $\\theta$，通过首先构造 $Y_{\\parallel}(\\omega) = \\frac{1}{R_{ct}} + Q (i \\omega)^\\alpha$，然后是 $Z_{\\parallel}(\\omega) = \\frac{1}{Y_{\\parallel}(\\omega)}$，最后是 $Z(\\omega;\\theta) = R_s + Z_{\\parallel}(\\omega)$ 来评估 $Z(\\omega;\\theta)$。\n- 通过将所有频率的实部差异后跟虚部差异堆叠起来，来构造残差向量。\n- 解决有界非线性最小二乘问题以获得 $\\widehat{\\theta}$。\n- 通过对 $y = -\\mathrm{Im}(Z_{\\mathrm{obs}})$ 的最高 $K$ 个值进行2次多项式拟合来计算 $y^\\star$。\n\n这种方法将用于参数估计的、基于物理信息的非线性回归与用于量化几何特征（顶点高度）的奈奎斯特平面上的局部多项式回归相结合。两种方法都完全基于所提供的定义和标准回归公式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef randles_cpe_impedance(params, omega):\n    \"\"\"\n    Compute Z(omega) for a Randles circuit with a CPE in parallel with R_ct,\n    in series with R_s.\n\n    params: array-like [R_s, R_ct, Q, alpha]\n        R_s: series resistance (ohm)\n        R_ct: charge-transfer resistance (ohm)\n        Q: CPE magnitude (F*s^(alpha-1))\n        alpha: CPE exponent (dimensionless, 0 < alpha <= 1)\n    omega: array of angular frequencies (rad/s)\n\n    Returns: complex ndarray Z(omega)\n    \"\"\"\n    Rs, Rct, Q, alpha = params\n    # Admittance of parallel branch: 1/Rct + Q*(i*omega)^alpha\n    Y_par = (1.0 / Rct) + Q * (1j * omega) ** alpha\n    Z_par = 1.0 / Y_par\n    Z_total = Rs + Z_par\n    return Z_total\n\ndef residuals(params, omega, Z_obs):\n    \"\"\"\n    Construct real-valued residual vector by stacking real and imaginary parts.\n    \"\"\"\n    Z_model = randles_cpe_impedance(params, omega)\n    r_real = np.real(Z_model) - np.real(Z_obs)\n    r_imag = np.imag(Z_model) - np.imag(Z_obs)\n    return np.concatenate([r_real, r_imag])\n\ndef initial_guess(omega, Z_obs):\n    \"\"\"\n    Heuristic initial guess for [R_s, R_ct, Q, alpha].\n    \"\"\"\n    x = np.real(Z_obs)\n    y = -np.imag(Z_obs)\n    Rs0 = np.clip(np.min(x), 1e-6, 1e3)\n    Rct0 = np.clip(np.max(x) - Rs0, 1e-6, 1e4)\n    alpha0 = 0.9\n    # Estimate omega_peak from max y\n    idx_peak = np.argmax(y)\n    omega_peak = np.clip(omega[idx_peak], 1e-3, 1e9)\n    # Q0 from (omega_peak * Rct0 * Q0)^alpha0 ~ 1\n    Q0 = 1.0 / (Rct0 * (omega_peak ** alpha0))\n    Q0 = np.clip(Q0, 1e-6, 1.0)\n    return np.array([Rs0, Rct0, Q0, alpha0], dtype=float)\n\ndef fit_parameters(omega, Z_obs):\n    \"\"\"\n    Fit [R_s, R_ct, Q, alpha] by bounded nonlinear least squares.\n    \"\"\"\n    x0 = initial_guess(omega, Z_obs)\n    lower = np.array([1e-6, 1e-6, 1e-6, 0.4])\n    upper = np.array([1e3, 1e4, 1.0, 1.0])\n    res = least_squares(residuals, x0, bounds=(lower, upper), args=(omega, Z_obs), method='trf', max_nfev=20000)\n    return res.x\n\ndef nyquist_quadratic_apex(Z_obs, K):\n    \"\"\"\n    Fit y = a x^2 + b x + c to the top-K points by y = -Im(Z_obs),\n    return the apex height y* = c - b^2/(4a). If a is zero, return max(y).\n    \"\"\"\n    x = np.real(Z_obs)\n    y = -np.imag(Z_obs)\n    # Select top-K points by y\n    K = int(min(K, len(x)))\n    idx_sorted = np.argsort(y)[::-1]\n    idx_sel = np.sort(idx_sorted[:K])  # keep in ascending x order for stability\n    x_sel = x[idx_sel]\n    y_sel = y[idx_sel]\n    # Fit quadratic\n    # Handle potential ill-conditioning by centering x\n    x_mean = np.mean(x_sel)\n    x_c = x_sel - x_mean\n    # Fit in centered coordinates: y = a*(x_c)^2 + b*(x_c) + c\n    A = np.vstack([x_c**2, x_c, np.ones_like(x_c)]).T\n    coef, *_ = np.linalg.lstsq(A, y_sel, rcond=None)\n    a_c, b_c, c_c = coef\n    if np.isclose(a_c, 0.0):\n        y_apex = float(np.max(y_sel))\n    else:\n        # Apex in centered coordinates\n        x_star_c = -b_c / (2.0 * a_c)\n        y_apex = c_c - (b_c ** 2) / (4.0 * a_c)\n        # x_star = x_mean + x_star_c  # not needed for output\n    return y_apex\n\ndef simulate_data(params, freqs, rng, noise_sigma=0.05):\n    \"\"\"\n    Generate noisy impedance data for given params and frequencies.\n    Adds Gaussian noise with std = noise_sigma to Re and Im parts separately.\n    \"\"\"\n    omega = 2.0 * np.pi * freqs\n    Z_true = randles_cpe_impedance(params, omega)\n    noise_re = rng.normal(loc=0.0, scale=noise_sigma, size=freqs.shape)\n    noise_im = rng.normal(loc=0.0, scale=noise_sigma, size=freqs.shape)\n    Z_noisy = (np.real(Z_true) + noise_re) + 1j * (np.imag(Z_true) + noise_im)\n    return omega, Z_true, Z_noisy\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (Rs, Rct, Q, alpha)\n    test_cases = [\n        (5.0, 50.0, 1e-3, 0.9),\n        (2.0, 20.0, 2e-3, 1.0),\n        (20.0, 5.0, 5e-4, 0.8),\n        (1.0, 200.0, 1e-4, 0.95),\n    ]\n\n    # Frequency grid: N=81 log-spaced from 1e-1 to 1e5 Hz\n    freqs = np.logspace(-1, 5, 81)\n    rng = np.random.default_rng(12345)\n\n    results = []\n    for case in test_cases:\n        true_params = np.array(case, dtype=float)\n        omega, Z_true, Z_noisy = simulate_data(true_params, freqs, rng, noise_sigma=0.05)\n\n        # Fit nonlinear model\n        theta_hat = fit_parameters(omega, Z_noisy)\n        Rs_hat, Rct_hat, Q_hat, alpha_hat = theta_hat\n\n        # Polynomial apex on Nyquist plane (top K points)\n        y_apex = nyquist_quadratic_apex(Z_noisy, K=min(25, len(freqs)))\n\n        # Append rounded results as specified\n        rounded = [\n            f\"{Rs_hat:.6f}\",\n            f\"{Rct_hat:.6f}\",\n            f\"{Q_hat:.6f}\",\n            f\"{alpha_hat:.6f}\",\n            f\"{y_apex:.6f}\",\n        ]\n        results.extend(rounded)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2425215"}]}