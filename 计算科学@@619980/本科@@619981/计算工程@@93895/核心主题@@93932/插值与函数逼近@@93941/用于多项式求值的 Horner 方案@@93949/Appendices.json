{"hands_on_practices": [{"introduction": "霍纳方案的优雅之处不仅在于其对单变量多项式的效率，还在于其核心思想可以扩展到更复杂的情况。这个练习将指导您如何将霍纳方法推广应用于二元多项式。通过将问题分解为一系列嵌套的一维求值，您可以亲身体会到在计算科学中将高维问题简化为低维问题的强大策略 [@problem_id:2177827]。", "problem": "在数值分析中，霍纳法（Horner's method）为计算单变量多项式的值提供了一种高效的算法。本问题探讨将此思想推广到二元多项式。\n\n考虑一个一般的二元多项式 $P(x,y)$，其关于变量 $x$ 的次数为 $n$，关于变量 $y$ 的次数为 $m$，定义如下：\n$$P(x,y) = \\sum_{i=0}^{n} \\sum_{j=0}^{m} c_{ij} x^i y^j$$\n其中 $c_{ij}$ 是常数系数。\n\n可以通过首先按 $x$ 的幂次对各项进行分组，来设计一种嵌套求值方案。这将 $P(x,y)$ 视为一个以 $x$ 为变量的多项式，其系数本身是关于 $y$ 的多项式：\n$$P(x,y) = \\sum_{i=0}^{n} Q_i(y) x^i, \\quad \\text{其中} \\quad Q_i(y) = \\sum_{j=0}^{m} c_{ij} y^j$$\n对于某些特定值 $(x_0, y_0)$，计算 $P(x_0, y_0)$ 的值的步骤如下：\n1.  首先，对于每个 $i \\in \\{0, 1, \\dots, n\\}$，在 $y=y_0$ 处计算单变量多项式 $Q_i(y)$ 的值，以获得一个数值。每次计算都使用霍纳法进行。\n2.  其次，使用这组 $n+1$ 个数值 $\\{Q_0(y_0), Q_1(y_0), \\dots, Q_n(y_0)\\}$ 作为新的关于 $x$ 的单变量多项式的系数，并同样使用霍纳法在 $x=x_0$ 处计算该多项式的值。\n\n回顾一下，使用霍纳法计算一个 $k$ 次单变量多项式的值，恰好需要 $k$ 次乘法和 $k$ 次加法。\n\n设 $M$ 为使用此嵌套方案计算 $P(x_0, y_0)$ 所需的总乘法次数， $A$ 为所需的总加法次数。以下哪个选项正确地用 $n$ 和 $m$ 表示了 $M$ 和 $A$？\n\nA. $M = nm + m$, $A = nm + m$\n\nB. $M = nm + n$, $A = nm + n$\n\nC. $M = (n+1)(m+1)$, $A = (n+1)(m+1)$\n\nD. $M = nm + n + m$, $A = nm + n + m$\n\nE. $M = nm$, $A = nm - 1$\n\nF. $M = nm + n + m + 1$, $A = nm + n + m + 1$", "solution": "我们给定一个二元多项式 $P(x,y)=\\sum_{i=0}^{n}\\sum_{j=0}^{m} c_{ij} x^{i} y^{j}$，并使用嵌套的霍纳方案在点 $(x_{0},y_{0})$ 处对其求值：\n1. 对于每个 $i \\in \\{0,1,\\dots,n\\}$，定义 $Q_{i}(y)=\\sum_{j=0}^{m} c_{ij} y^{j}$ 并使用霍纳法计算 $Q_{i}(y_{0})$。由于每个 $Q_{i}(y)$ 都是一个 $m$ 次单变量多项式，因此对于每个 $i$，霍纳法需要恰好 $m$ 次乘法和 $m$ 次加法。共有 $n+1$ 个这样的多项式，所以此步骤的总计算量为：\n$$\nM_{1}=(n+1)m, \\quad A_{1}=(n+1)m.\n$$\n2. 接下来，使用霍纳法对以 $Q_{i}(y_{0})$ 为系数的 $x$ 的单变量多项式：\n$$\n\\sum_{i=0}^{n} Q_{i}(y_{0}) x^{i}\n$$\n在 $x=x_{0}$ 处求值。该多项式的次数为 $n$，因此这一步需要：\n$$\nM_{2}=n, \\quad A_{2}=n.\n$$\n将两步相加，总的乘法和加法次数为\n$$\nM=M_{1}+M_{2}=(n+1)m+n=nm+n+m,\n$$\n$$\nA=A_{1}+A_{2}=(n+1)m+n=nm+n+m.\n$$\n这与选项 D 相符。", "answer": "$$\\boxed{D}$$", "id": "2177827"}, {"introduction": "在数值计算中，一个核心挑战是维持计算精度，尤其是在处理由于“相近数相减”导致的灾难性舍入误差时。本练习介绍了一种强大的技术，即“泰勒移位”，它通过重复应用霍纳方法来重新构造多项式，从而实现在某点附近的稳定求值。这个过程不仅展示了霍纳方法作为求值工具的用途，还揭示了它在数值分析中作为代数变换工具的深刻应用 [@problem_id:2400090]。", "problem": "在计算工程的模型校准任务中，必须在参考点附近对一个高阶响应多项式进行求值，以减轻由相消抵消引起的舍入误差。设响应由多项式\n$$\nP(x) = 5x^{5} - 4x^{4} + 3x^{3} - 2x^{2} + x - 1.\n$$\n建模。参考点为 $c = 2$，求值点为 $x = c + \\delta$，其中有一个小偏移量 $\\delta = 7.5 \\times 10^{-4}$。定义移位多项式\n$$\nQ(\\delta) = P(c + \\delta) = \\sum_{k=0}^{5} q_{k} \\,\\delta^{k}.\n$$\n仅从多项式的定义和 Horner's method 中使用的嵌套求值结构出发，通过在 $x=c$ 处重复应用 Horner's method 来执行泰勒移位，并确定将 $Q(\\delta)$ 表示为 $\\delta$ 幂次的系数 $q_{k}$。然后通过将 $\\delta$ 代入 $Q(\\delta)$ 来求值 $P(c+\\delta)$。将您的最终数值结果四舍五入至8位有效数字。请仅提供所要求的最终数值；不要在最终答案中包含中间系数。", "solution": "给定的多项式为 $P(x) = 5x^{5} - 4x^{4} + 3x^{3} - 2x^{2} + x - 1$。要求我们在 $x = c + \\delta$ 处对其求值，其中参考点为 $c=2$，偏移量为 $\\delta = 7.5 \\times 10^{-4}$。目标是首先找到移位多项式 $Q(\\delta) = P(c+\\delta) = \\sum_{k=0}^{5} q_k \\delta^k$ 的系数 $q_k$。\n\n系数 $q_k$ 是 $P(x)$ 关于 $x=c$ 的泰勒展开的系数。这些系数可以通过重复应用除法算法找到。一个 $n$ 次多项式 $P(x)$ 可以写成 $P(x) = (x-c)P_1(x) + q_0$，其中 $P_1(x)$ 是一个 $n-1$ 次的商，而 $q_0 = P(c)$ 是余数。这种分解可以使用 Horner's method（也称为综合除法）高效地执行。对连续的商重复此过程，可以得到所有必需的系数。\n$P(x) = q_0 + (x-c)P_1(x)$\n$P(x) = q_0 + (x-c)(q_1 + (x-c)P_2(x)) = q_0 + q_1(x-c) + P_2(x)(x-c)^2$\n...\n$P(x) = q_0 + q_1(x-c) + q_2(x-c)^2 + \\dots + q_n(x-c)^n$。\n令 $x = c+\\delta$，我们得到 $Q(\\delta) = \\sum_{k=0}^{n} q_k \\delta^k$。系数 $q_k$ 正是 $P(x)$ 被 $(x-c)$ 重复进行综合除法时得到的余数。\n\n$P(x)$ 的系数为 $\\{5, -4, 3, -2, 1, -1\\}$。我们用 $c=2$ 进行重复的综合除法。\n\n步骤 1：将 $P(x)$ 除以 $(x-2)$。\n商的系数和余数 $q_0$ 计算如下：\n$$\n\\begin{array}{c|rrrrrr}\n2 & 5 & -4 & 3 & -2 & 1 & -1 \\\\\n& & 10 & 12 & 30 & 56 & 114 \\\\\n\\hline\n& 5 & 6 & 15 & 28 & 57 & \\boxed{113}\n\\end{array}\n$$\n第一个余数是 $q_0 = 113$。商多项式 $P_1(x)$ 的系数是 $\\{5, 6, 15, 28, 57\\}$。\n\n步骤 2：将 $P_1(x)$ 除以 $(x-2)$。\n$$\n\\begin{array}{c|rrrrr}\n2 & 5 & 6 & 15 & 28 & 57 \\\\\n& & 10 & 32 & 94 & 244 \\\\\n\\hline\n& 5 & 16 & 47 & 122 & \\boxed{301}\n\\end{array}\n$$\n第二个余数是 $q_1 = 301$。商 $P_2(x)$ 的系数是 $\\{5, 16, 47, 122\\}$。\n\n步骤 3：将 $P_2(x)$ 除以 $(x-2)$。\n$$\n\\begin{array}{c|rrrr}\n2 & 5 & 16 & 47 & 122 \\\\\n& & 10 & 52 & 198 \\\\\n\\hline\n& 5 & 26 & 99 & \\boxed{320}\n\\end{array}\n$$\n第三个余数是 $q_2 = 320$。商 $P_3(x)$ 的系数是 $\\{5, 26, 99\\}$。\n\n步骤 4：将 $P_3(x)$ 除以 $(x-2)$。\n$$\n\\begin{array}{c|rrr}\n2 & 5 & 26 & 99 \\\\\n& & 10 & 72 \\\\\n\\hline\n& 5 & 36 & \\boxed{171}\n\\end{array}\n$$\n第四个余数是 $q_3 = 171$。商 $P_4(x)$ 的系数是 $\\{5, 36\\}$。\n\n步骤 5：将 $P_4(x)$ 除以 $(x-2)$。\n$$\n\\begin{array}{c|rr}\n2 & 5 & 36 \\\\\n& & 10 \\\\\n\\hline\n& 5 & \\boxed{46}\n\\end{array}\n$$\n第五个余数是 $q_4 = 46$。商是常数 $5$。\n\n步骤 6：最后一个系数是最后的商，$q_5 = 5$。\n\n因此，移位多项式 $Q(\\delta)$ 的系数是：\n$q_0 = 113$\n$q_1 = 301$\n$q_2 = 320$\n$q_3 = 171$\n$q_4 = 46$\n$q_5 = 5$\n\n所以，移位多项式为：\n$Q(\\delta) = 5\\delta^{5} + 46\\delta^{4} + 171\\delta^{3} + 320\\delta^{2} + 301\\delta + 113$。\n\n现在，我们必须对 $\\delta = 7.5 \\times 10^{-4}$ 求 $Q(\\delta)$ 的值。求值此多项式的最数值稳定和高效的方法仍然是 Horner's method，使用其嵌套结构：\n$Q(\\delta) = ((((5\\delta + 46)\\delta + 171)\\delta + 320)\\delta + 301)\\delta + 113$。\n我们代入 $\\delta = 0.00075$ 并从内向外计算值：\n\\begin{itemize}\n    \\item $v_4 = 5 \\times 0.00075 + 46 = 0.00375 + 46 = 46.00375$\n    \\item $v_3 = v_4 \\times 0.00075 + 171 = 46.00375 \\times 0.00075 + 171 = 0.0345028125 + 171 = 171.0345028125$\n    \\item $v_2 = v_3 \\times 0.00075 + 320 = 171.0345028125 \\times 0.00075 + 320 = 0.128275877109375 + 320 = 320.128275877109375$\n    \\item $v_1 = v_2 \\times 0.00075 + 301 = 320.128275877109375 \\times 0.00075 + 301 = 0.24009620690791015625 + 301 = 301.24009620690791015625$\n    \\item $v_0 = v_1 \\times 0.00075 + 113 = 301.24009620690791015625 \\times 0.00075 + 113 = 0.2259300721551809326171875 + 113 = 113.2259300721551809326171875$\n\\end{itemize}\n精确值为 $P(2.00075) = Q(0.00075) = 113.2259300721551809326171875$。\n\n问题要求将最终结果四舍五入到8位有效数字。计算出的值为 $113.22593007...$。\n前8位有效数字是 $1, 1, 3, 2, 2, 5, 9, 3$。第9位有效数字是 $0$，小于 $5$，所以我们向下舍入（截断）。\n最终的数值结果是 $113.22593$。", "answer": "$$\n\\boxed{113.22593}\n$$", "id": "2400090"}, {"introduction": "虽然霍纳方案对于系数“稠密”的多项式非常高效，但它并非总是最佳选择。本练习旨在挑战您对算法选择的思维定势，您将面对一个“稀疏”多项式，其中大部分系数为零。在这种情况下，直接应用霍纳方法会进行大量不必要的乘法运算，而一种利用指数结构的替代算法（例如重复平方法）会显著更优。这个实践旨在培养您根据问题具体结构来选择最有效算法的批判性思维能力 [@problem_id:2400102]。", "problem": "稀疏多项式是指相对于其次数而言，只有少数系数为非零的多项式。考虑多项式 $p(x)=x^{2048}+x^{256}+x^{16}+7$。您必须只使用实数加法和实数乘法，对一个任意非零实数输入 $x$ 来计算 $p(x)$ 的值，其中两个实数（包括与常数相乘）的每次乘法计为单位成本，而加法不计成本。您可以重复使用计算过程中得到的任何 $x$ 的中间幂次。不执行与零相乘的运算。请设计一个求值算法，利用 $p(x)$ 的稀疏性来最小化对任意非零输入 $x$ 计算 $p(x)$ 所需的实数乘法次数。请给出在该模型下，任何正确算法所需的最少实数乘法次数作为您的最终答案。最终答案必须是一个数字。", "solution": "目标是确定对任意非零实数输入 $x$ 求多项式 $p(x) = x^{2048} + x^{256} + x^{16} + 7$ 的值所需的最少实数乘法次数。成本模型规定每次实数乘法的成本为 $1$，而加法的成本为 $0$。\n\n首先，我们确定所需乘法次数的理论下界。任何从初始值集合 $\\{1, x\\}$ 开始计算多项式的算法，都会构造出次数递增的表达式。两个次数分别为 $d_1$ 和 $d_2$ 的多项式进行一次乘法运算，最多能产生一个次数为 $d_1 + d_2$ 的多项式。使用 $k$ 次乘法可以计算出的多项式的最大可能次数是 $2^k$。这是通过从 $x$ 开始的一系列平方运算实现的：$x \\rightarrow x^2 \\rightarrow x^4 \\rightarrow \\dots \\rightarrow x^{2^k}$。\n\n给定多项式 $p(x)$ 的次数为 $d=2048$。因此，任何计算 $p(x)$ 的算法都必须执行 $k$ 次乘法，使得可达到的最大次数至少为 $2048$。\n$$\n2^k \\ge 2048\n$$\n对两边取以 2 为底的对数，我们得到：\n$$\nk \\ge \\log_2(2048)\n$$\n由于 $2048 = 2^{11}$，该不等式变为：\n$$\nk \\ge 11\n$$\n这证明了计算多项式 $p(x)$ 至少需要 $11$ 次乘法。\n\n接下来，我们必须证明这个下界是可达到的。我们提出了一个使用恰好 $11$ 次乘法来计算 $p(x)$ 的算法。该算法基于平方求幂法（也称为二进制法）。\n\n我们需要计算 $x^{16}$、$x^{256}$ 和 $x^{2048}$ 这几项。观察到指数 $16$、$256$ 和 $2048$ 都是 $2$ 的幂：\n$$\n16 = 2^4\n$$\n$$\n256 = 2^8\n$$\n$$\n2048 = 2^{11}\n$$\n我们可以通过执行一连串 $11$ 次的连续平方运算来计算 $x^{2048}$：\n1.  计算 $x^2 = x \\cdot x$。（1 次乘法）\n2.  计算 $x^4 = x^2 \\cdot x^2$。（1 次乘法）\n3.  计算 $x^8 = x^4 \\cdot x^4$。（1 次乘法）\n4.  计算 $x^{16} = x^8 \\cdot x^8$。（1 次乘法）。此时已得到第一个所需的幂。\n5.  计算 $x^{32} = x^{16} \\cdot x^{16}$。（1 次乘法）\n6.  计算 $x^{64} = x^{32} \\cdot x^{32}$。（1 次乘法）\n7.  计算 $x^{128} = x^{64} \\cdot x^{64}$。（1 次乘法）\n8.  计算 $x^{256} = x^{128} \\cdot x^{128}$。（1 次乘法）。此时已得到第二个所需的幂。\n9.  计算 $x^{512} = x^{256} \\cdot x^{256}$。（1 次乘法）\n10. 计算 $x^{1024} = x^{512} \\cdot x^{512}$。（1 次乘法）\n11. 计算 $x^{2048} = x^{1024} \\cdot x^{1024}$。（1 次乘法）。此时已得到最后一个所需的幂。\n\n这个过程总共需要 $11$ 次乘法。关键的是，中间幂次 $x^{16}$ 和 $x^{256}$ 在此过程中也被生成了。\n\n一旦这些幂被计算出来，多项式的最终值就可以通过求和得到：\n$$\np(x) = x^{2048} + x^{256} + x^{16} + 7\n$$\n$x$ 的各次幂的系数都为 $1$，因此不需要额外的乘法来对这些项进行缩放。常数项 $7$ 是通过加法并入的。根据问题陈述，加法是无成本的。\n\n所提出的算法使用恰好 $11$ 次乘法来计算 $p(x)$。由于我们已经严格地证明了 $11$ 次乘法的理论下界，因此该算法是最优的。没有任何正确的算法可以使用更少的乘法次数。\n\n因此，所需的最少实数乘法次数是 $11$。", "answer": "$$\\boxed{11}$$", "id": "2400102"}]}