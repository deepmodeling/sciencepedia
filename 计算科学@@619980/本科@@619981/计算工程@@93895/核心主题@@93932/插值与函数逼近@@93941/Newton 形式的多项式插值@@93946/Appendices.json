{"hands_on_practices": [{"introduction": "牛顿形式多项式插值的核心在于计算其系数，即差商。本练习将引导你手动执行一个内存高效的原地算法，这与教科书中理论上的二维差商表不同。通过追踪该算法在给定数据集上的每一步，你将对牛顿插值的底层计算机制建立起直观而深刻的理解，为后续编写更复杂的插值程序打下坚实基础。[@problem_id:2189914]", "problem": "在数值分析中，Newton 形式的插值多项式是构造一个穿过一组给定数据点的多项式的强大工具。该多项式的系数是均差，记为 $f[x_0, \\dots, x_k]$。计算这些系数的一种常用方法是构建一个大型的二维表格。\n\n考虑一个内存高效的原地算法，它旨在仅使用一个大小为 $n+1$ 的一维数组来计算这些系数。该算法处理一组 $n+1$ 个数据点 $(x_0, y_0), (x_1, y_1), \\dots, (x_n, y_n)$。\n\n算法流程如下：\n1.  初始化一个大小为 $n+1$ 的一维数组，我们称之为 $A$，并用因变量的值填充它。即，对于 $i = 0, 1, \\dots, n$，将 $A_i$ 设置为 $y_i$。\n2.  执行一个嵌套循环。外层循环的索引 $k$ 从 $1$ 遍历到 $n$。内层循环的索引 $j$ 从 $n$ 递减遍历到 $k$。\n3.  在内层循环中，使用以下公式更新数组元素 $A_j$：\n    $$A_j \\leftarrow \\frac{A_j - A_{j-1}}{x_j - x_{j-k}}$$\n\n算法终止后，数组 $A$ 将包含 Newton 多项式所需的系数，即对于 $k=0, \\dots, n$，有 $A_k = f[x_0, \\dots, x_k]$。\n\n假设给定以下四个数据点（因此 $n=3$）：\n- $(x_0, y_0) = (-2, -5)$\n- $(x_1, y_1) = (-1, 1)$\n- $(x_2, y_2) = (1, 1)$\n- $(x_3, y_3) = (2, 7)$\n\n请将上述内存高效的算法应用于这些数据点。算法执行完毕后，数组 $A$ 的最终内容是什么？请将答案表示为一个由四个数字组成的序列，分别代表元素 $A_0, A_1, A_2, A_3$。", "solution": "给定数据点 $(x_{0},y_{0})=(-2,-5)$, $(x_{1},y_{1})=(-1,1)$, $(x_{2},y_{2})=(1,1)$, $(x_{3},y_{3})=(2,7)$，我们必须运行原地均差算法：\n1) 初始化 $A_{i}=y_{i}$，对于 $i=0,1,2,3$，所以\n$$A_{0}=-5,\\quad A_{1}=1,\\quad A_{2}=1,\\quad A_{3}=7.$$\n\n2) 对于 $k=1$ 到 $3$，对于 $j=3$ 递减到 $k$，更新\n$$A_{j}\\leftarrow \\frac{A_{j}-A_{j-1}}{x_{j}-x_{j-k}}.$$\n\n外层循环 $k=1$：\n- 对于 $j=3$：\n$$A_{3}\\leftarrow \\frac{A_{3}-A_{2}}{x_{3}-x_{2}}=\\frac{7-1}{2-1}=6.$$\n- 对于 $j=2$：\n$$A_{2}\\leftarrow \\frac{A_{2}-A_{1}}{x_{2}-x_{1}}=\\frac{1-1}{1-(-1)}=\\frac{0}{2}=0.$$\n- 对于 $j=1$：\n$$A_{1}\\leftarrow \\frac{A_{1}-A_{0}}{x_{1}-x_{0}}=\\frac{1-(-5)}{-1-(-2)}=\\frac{6}{1}=6.$$\n$k=1$ 后的数组：\n$$A=\\left(-5,\\ 6,\\ 0,\\ 6\\right).$$\n\n外层循环 $k=2$：\n- 对于 $j=3$：\n$$A_{3}\\leftarrow \\frac{A_{3}-A_{2}}{x_{3}-x_{1}}=\\frac{6-0}{2-(-1)}=\\frac{6}{3}=2.$$\n- 对于 $j=2$：\n$$A_{2}\\leftarrow \\frac{A_{2}-A_{1}}{x_{2}-x_{0}}=\\frac{0-6}{1-(-2)}=\\frac{-6}{3}=-2.$$\n$k=2$ 后的数组：\n$$A=\\left(-5,\\ 6,\\ -2,\\ 2\\right).$$\n\n外层循环 $k=3$：\n- 对于 $j=3$：\n$$A_{3}\\leftarrow \\frac{A_{3}-A_{2}}{x_{3}-x_{0}}=\\frac{2-(-2)}{2-(-2)}=\\frac{4}{4}=1.$$\n$k=3$ 后的数组：\n$$A=\\left(-5,\\ 6,\\ -2,\\ 1\\right).$$\n\n因此最终内容为 $A_{0}=-5$, $A_{1}=6$, $A_{2}=-2$, $A_{3}=1$。", "answer": "$$\\boxed{\\begin{pmatrix}-5 & 6 & -2 & 1\\end{pmatrix}}$$", "id": "2189914"}, {"introduction": "理论联系实际是工程学的重要一环。这个练习将带你进入一个模拟场景：利用历史数据点构建插值多项式来“预测”未来经济趋势。你的任务是实现牛顿插值算法，并观察当使用高阶多项式进行外插（即在数据范围之外进行预测）时，预测结果会如何剧烈偏离真实情况。这个实践旨在揭示高阶多项式插值在预测应用中的一个关键陷阱——过拟合与外插的不稳定性。[@problem_id:2426366]", "problem": "令 $f:\\mathbb{R}\\to\\mathbb{R}$ 为一个平滑指数，旨在模拟类似于国内生产总值 (GDP) 的季节性波动增长信号。$f$ 的定义如下：\n$$\nf(q) = \\exp\\!\\left(0.015\\,q\\right)\\,\\bigl(1 + 0.04\\,\\sin(0.5\\,q)\\bigr),\n$$\n其中 $q$ 是一个代表季度指数的实数，所有角度均以弧度为单位。考虑从 $f$ 中采样得到的离散的过去季度指数 $q_i$ 及其精确值 $f(q_i)$。对于下述每个指定的测试用例，令 $p_n$ 为次数最多为 $n$ 的唯一牛顿形式插值多项式，它与给定节点集 $\\{q_0,\\dots,q_n\\}$ 的数据点对 $(q_i, f(q_i))$ 相匹配。对于一个指定的预测指数 $q^\\star$，计算绝对预测误差\n$$\nE = \\lvert p_n(q^\\star) - f(q^\\star)\\rvert.\n$$\n\n你的程序必须处理包含以下节点集和预测位置的测试套件：\n\n- 用例 $1$（中等次数，多步外插）：节点 $q_i \\in \\{0,1,2,3,4\\}$，预测点 $q^\\star = 6$。\n- 用例 $2$（高次数，单步外插）：节点 $q_i \\in \\{0,1,2,3,4,5,6,7,8,9,10\\}$，预测点 $q^\\star = 12$。\n- 用例 $3$（低次数，单步外插）：节点 $q_i \\in \\{0,1,2\\}$，预测点 $q^\\star = 3$。\n- 用例 $4$（边界情况，0 次）：节点 $q_0 = 0$，预测点 $q^\\star = 4$。\n- 用例 $5$（域内求值检查）：节点 $q_i \\in \\{0,1,2,3,4,5,6,7,8,9,10\\}$，求值点 $q^\\star = 5$。\n\n对于每个用例，使用提供的节点及其从 $f$ 得到的精确函数值来构建牛顿形式的 $p_n$，在 $q^\\star$ 处对 $p_n$ 求值，并计算如上定义的绝对误差 $E$。\n\n最终输出格式：你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，结果按用例 1 到用例 5 的顺序排列。每个条目是 $E$ 的浮点值，精确到 8 位小数（例如，$[0.12345678,0.00000000,0.87654321,0.01000000,0.00000001]$）。", "solution": "所述问题是有效的。这是数值分析中一个适定的练习，具体涉及牛顿形式的多项式插值。所有定义在数学上都是精确的，所提供的数据是完整且一致的，并且该问题在科学上基于成熟的计算方法。我将继续进行求解。\n\n目标是使用插值多项式 $p_n(q)$ 逼近给定函数 $f(q)$，并确定在指定点 $q^\\star$ 处的逼近误差。该函数定义如下：\n$$\nf(q) = \\exp(0.015\\,q)\\,\\bigl(1 + 0.04\\,\\sin(0.5\\,q)\\bigr)\n$$\n其中 $q$ 代表一个季度指数。\n\n对于一组给定的 $n+1$ 个不同数据点 $(q_0, y_0), (q_1, y_1), \\dots, (q_n, y_n)$，其中 $y_i = f(q_i)$，存在一个次数最多为 $n$ 的唯一插值多项式 $p_n(q)$，使得对所有 $i \\in \\{0, 1, \\dots, n\\}$ 都有 $p_n(q_i) = y_i$。问题指定使用该多项式的牛顿形式。\n\n插值多项式 $p_n(q)$ 的牛顿形式表示为：\n$$\np_n(q) = c_0 + c_1(q - q_0) + c_2(q - q_0)(q - q_1) + \\dots + c_n \\prod_{k=0}^{n-1} (q - q_k)\n$$\n这可以紧凑地写为：\n$$\np_n(q) = \\sum_{j=0}^{n} c_j \\prod_{k=0}^{j-1} (q - q_k)\n$$\n系数 $c_j$ 是均差 (divided differences)，定义为 $c_j = f[q_0, q_1, \\dots, q_j]$。这些系数通过递归计算得出。基本情况是 0 阶均差，它就是函数值本身：\n$$\nf[q_i] = y_i = f(q_i)\n$$\n高阶均差使用以下公式计算：\n$$\nf[q_i, q_{i+1}, \\dots, q_{i+j}] = \\frac{f[q_{i+1}, \\dots, q_{i+j}] - f[q_i, \\dots, q_{i+j-1}]}{q_{i+j} - q_i}\n$$\n牛顿多项式的系数 $c_0, c_1, \\dots, c_n$ 对应于均差表的上对角线：\n$$\nc_0 = f[q_0], \\quad c_1 = f[q_0, q_1], \\quad c_2 = f[q_0, q_1, q_2], \\quad \\dots, \\quad c_n = f[q_0, q_1, \\dots, q_n]\n$$\n在计算上，这些系数可以高效地生成，而无需构建完整的表格。一个最初存储函数值 $\\{y_0, y_1, \\dots, y_n\\}$ 的数组可以通过原地更新来生成所需的系数。\n\n一旦系数 $c_j$ 确定，就必须在预测点 $q^\\star$ 处对多项式 $p_n(q)$ 进行求值。直接计算乘积求和形式效率低下。一种更稳定、更高效的方法是使用嵌套形式，也称为适用于牛顿多项式的霍纳 (Horner) 方法：\n$$\np_n(q^\\star) = c_0 + (q^\\star - q_0)\\Bigl(c_1 + (q^\\star - q_1)\\bigl(c_2 + \\dots + (q^\\star - q_{n-1})c_n\\bigr)\\dots\\Bigr)\n$$\n这可以通过向后递推来求值。令多项式的值为 $P$：\n初始化：$P \\leftarrow c_n$。\n对 $j = n-1, n-2, \\dots, 0$ 进行迭代：\n$P \\leftarrow c_j + (q^\\star - q_j) P$。\n$P$ 的最终值即为 $p_n(q^\\star)$。\n\n最后，通过将多项式在 $q^\\star$ 处的预测值与真实函数值进行比较，来计算绝对预测误差 $E$：\n$$\nE = \\lvert p_n(q^\\star) - f(q^\\star)\\rvert\n$$\n此过程将应用于指定的 5 个测试用例中的每一个。\n\n关于特殊情况的说明：\n- 用例 4 只涉及一个节点 $q_0 = 0$，因此 $n=0$。插值多项式为 0 次，即一个常数：$p_0(q) = f(q_0) = f(0) = 1$。误差就是 $|1 - f(4)|$。\n- 用例 5 涉及在点 $q^\\star = 5$ 处对多项式进行求值，该点是插值节点 $\\{0, 1, \\dots, 10\\}$ 之一。根据插值多项式的定义，$p_{10}(5) = f(5)$。因此，精确的理论误差为 $E=0$。任何非零结果都可归因于浮点表示误差，该误差应可忽略不计，并四舍五入为 $0.00000000$。\n\n以下代码实现了这个稳健的数值过程。代码中定义了函数 `f(q)`，一个子程序根据节点和函数值计算牛顿系数，另一个子程序使用霍纳方法对多项式求值。该过程被应用于每个测试用例，以计算相应的误差 $E$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the polynomial interpolation problem for all test cases.\n    \"\"\"\n\n    def f(q: np.ndarray or float) -> np.ndarray or float:\n        \"\"\"\n        The given seasonally fluctuating growth signal function.\n        f(q) = exp(0.015*q) * (1 + 0.04*sin(0.5*q))\n        \"\"\"\n        return np.exp(0.015 * q) * (1.0 + 0.04 * np.sin(0.5 * q))\n\n    def get_newton_coeffs(nodes: np.ndarray, y_values: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Computes the coefficients for the Newton form of the interpolating polynomial.\n        These are the divided differences f[q_0], f[q_0, q_1], ..., f[q_0, ..., q_n].\n        \"\"\"\n        n = len(nodes)\n        coeffs = np.copy(y_values)\n        for j in range(1, n):\n            # For each column j of the divided difference table\n            for i in range(n - 1, j - 1, -1):\n                # Update the value based on the previous column's values\n                coeffs[i] = (coeffs[i] - coeffs[i - 1]) / (nodes[i] - nodes[i - j])\n        return coeffs\n\n    def evaluate_newton_poly(coeffs: np.ndarray, nodes: np.ndarray, q_star: float) -> float:\n        \"\"\"\n        Evaluates the Newton polynomial at a point q_star using Horner's method.\n        p_n(q) = c_0 + (q-q_0)(c_1 + (q-q_1)(...))\n        \"\"\"\n        n = len(nodes) - 1\n        p_val = coeffs[n]\n        for i in range(n - 1, -1, -1):\n            p_val = coeffs[i] + (q_star - nodes[i]) * p_val\n        return p_val\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: moderate degree, multi-step extrapolation\n        {'nodes': np.arange(5, dtype=float), 'q_star': 6.0},\n        # Case 2: high degree, one-step extrapolation\n        {'nodes': np.arange(11, dtype=float), 'q_star': 12.0},\n        # Case 3: low degree, one-step extrapolation\n        {'nodes': np.arange(3, dtype=float), 'q_star': 3.0},\n        # Case 4: boundary case, degree 0\n        {'nodes': np.array([0.0]), 'q_star': 4.0},\n        # Case 5: in-domain evaluation check\n        {'nodes': np.arange(11, dtype=float), 'q_star': 5.0}\n    ]\n\n    results = []\n    for case in test_cases:\n        nodes = case['nodes']\n        q_star = case['q_star']\n\n        # Get function values at nodes\n        y_values = f(nodes)\n        \n        # Handle the n=0 case (degree 0 polynomial, a constant)\n        if len(nodes) == 1:\n            p_n_q_star = y_values[0]\n        else:\n            # Compute Newton coefficients\n            coeffs = get_newton_coeffs(nodes, y_values)\n            # Evaluate polynomial at q_star\n            p_n_q_star = evaluate_newton_poly(coeffs, nodes, q_star)\n\n        # Compute true function value at q_star\n        f_q_star = f(q_star)\n\n        # Compute absolute error\n        error = np.abs(p_n_q_star - f_q_star)\n        \n        # Format result to 8 decimal places\n        results.append(f\"{error:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2426366"}, {"introduction": "上一个练习展示了外插的风险，但即使在插值区间内部，使用高阶多项式和等距节点也可能导致剧烈振荡，这个现象被称为“龙格现象”（Runge's phenomenon）。本练习将通过对经典的龙格函数 $f(x) = 1/(1+25x^2)$ 进行插值，让你亲手重现这一问题。更重要的是，你将实现并对比两种不同的节点选择策略（等距节点与切比雪夫节点），从而验证一个关键的数值分析结论：明智地选择插值节点可以极大地抑制振荡，显著提高插值的精度和稳定性。[@problem_id:2426405]", "problem": "你需要使用两种节点生成策略，为 Runge 函数实现牛顿形式的多项式插值。从基本定义开始：对于 $n+1$ 个互不相同的节点 $\\{x_0,\\dots,x_n\\}$ 和函数值 $\\{f(x_0),\\dots,f(x_n)\\}$，存在一个唯一的次数至多为 $n$ 的多项式 $p_n(x)$，对所有 $i$ 满足 $p_n(x_i)=f(x_i)$。利用差分的递归定义和牛顿基，推导出一个数值稳定的求值算法。目标函数是区间 $[-1,1]$ 上的 Runge 函数 $f(x)=\\dfrac{1}{1+25x^2}$。所有角度都必须以弧度为单位。\n\n你的任务是：\n- 实现一个函数，为节点 $\\{x_i\\}_{i=0}^n$ 和函数值 $\\{f(x_i)\\}_{i=0}^n$ 计算差分，从而生成多项式 $p_n(x)$ 的牛顿形式系数 $\\{c_0,\\dots,c_n\\}$。\n- 实现一个函数，使用基于牛顿基 $\\{1,(x-x_0),(x-x_0)(x-x_1),\\dots\\}$ 和先前计算出的系数 $\\{c_k\\}_{k=0}^n$ 的嵌套乘法，在任意点 $x$ 处对牛顿形式的插值多项式求值。\n- 对每个次数 $n$，在 $[-1,1]$ 上生成两组插值节点：\n  - 等距节点：$x_i=-1+\\dfrac{2i}{n}$，其中 $i=0,\\dots,n$。\n  - $[-1,1]$ 上的第一类切比雪夫节点(极值点)：$x_i=\\cos\\!\\left(\\dfrac{i\\pi}{n}\\right)$，其中 $i=0,\\dots,n$。使用弧度。\n- 对每个插值多项式，在一个由 $[-1,1]$ 上 $M$ 个均匀分布点构成的密集网格上计算 $p_n(x)$，并计算最大绝对误差 $E_{\\max}=\\max_{x\\in\\mathcal{G}}|p_n(x)-f(x)|$，其中 $\\mathcal{G}$ 是求值网格。\n- 所有算术运算均使用双精度。\n\n测试套件规范：\n- 使用区间 $[-1,1]$ 上的 Runge 函数 $f(x)=\\dfrac{1}{1+25x^2}$。\n- 使用一个由 $[-1,1]$ 上 $M=10001$ 个等距点组成的求值网格 $\\mathcal{G}$。\n- 使用以下次数（每个次数对应 $n+1$ 个节点）：$n\\in\\{0,1,5,10,20\\}$。\n- 对于上述集合中的每个 $n$，计算两个数值：$E_{\\max}^{\\text{eq}}(n)$（等距节点）和 $E_{\\max}^{\\text{ch}}(n)$（切比雪夫节点，角度使用弧度）。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。该列表必须按以下顺序包含实数：\n  - $\\big[E_{\\max}^{\\text{eq}}(0),E_{\\max}^{\\text{ch}}(0),E_{\\max}^{\\text{eq}}(1),E_{\\max}^{\\text{ch}}(1),E_{\\max}^{\\text{eq}}(5),E_{\\max}^{\\text{ch}}(5),E_{\\max}^{\\text{eq}}(10),E_{\\max}^{\\text{ch}}(10),E_{\\max}^{\\text{eq}}(20),E_{\\max}^{\\text{ch}}(20)\\big]$。\n- 输出必须是单行，且不得包含任何附加文本。", "solution": "该问题从插值的核心定义出发：给定 $n+1$ 个互不相同的节点 $\\{x_0,\\dots,x_n\\}$ 和数据值 $\\{y_0,\\dots,y_n\\}$（其中 $y_i=f(x_i)$），存在一个唯一的次数至多为 $n$ 的多项式 $p_n(x)$，使得对于 $i=0,\\dots,n$ 均有 $p_n(x_i)=y_i$。一种构造性表示是牛顿形式，它结合了两个基本部分：差分和牛顿基。牛顿基的递归定义为 $N_0(x)=1$，当 $k\\ge 1$ 时为 $N_k(x)=(x-x_{k-1})N_{k-1}(x)$，这可以导出 $N_k(x)=\\prod_{j=0}^{k-1}(x-x_j)$。插值多项式可以表示为 $p_n(x)=\\sum_{k=0}^n c_k N_k(x)$，其中系数 $c_k$ 是差分 $c_k=f[x_0,\\dots,x_k]$。这些差分通过递归从数据中确定：$f[x_i]=y_i$，以及当 $k\\ge 1$ 时，$f[x_i,\\dots,x_{i+k}]=\\dfrac{f[x_{i+1},\\dots,x_{i+k}]-f[x_i,\\dots,x_{i+k-1}]}{x_{i+k}-x_i}$。这种构造通过对 $i$ 进行归纳直接编码了数据约束 $p_n(x_i)=y_i$，从而确保了存在性和唯一性。\n\n算法设计如下。首先，计算差分。我们可以在一个初始化为 $d_i^{(0)}=y_i$ 的数组 $d$上进行原地递归计算。对于每个阶数 $k=1,\\dots,n$ 和索引 $i=0,\\dots,n-k$，更新 $d_i^{(k)}=\\dfrac{d_{i+1}^{(k-1)}-d_i^{(k-1)}}{x_{i+k}-x_i}$。完成所有阶数的计算后，牛顿系数为 $c_k=d_0^{(k)}$，其中 $k=0,\\dots,n$。这是一个 $O(n^2)$ 的操作，且仅使用核心递归。\n\n其次，通过嵌套乘法（一种适用于牛顿基的类 Horner 方案）高效且稳定地对插值多项式求值。从 $v=c_n$ 开始，对于 $k=n-1,\\dots,0$ 累积计算 $v \\leftarrow c_{k}+ (x-x_k)\\,v$。这源于基的恒等式 $N_k(x)=(x-x_k)N_{k+1}(x)$，将其重排以将 $p_n$ 表示为嵌套形式：$p_n(x)=c_0+(x-x_0)\\left(c_1+(x-x_1)\\left(\\dots+(x-x_{n-1})c_n\\right)\\right)$。每次求值的复杂度为 $O(n)$，并且相对于朴素的基展开，这种方法在数值上是稳定的。\n\n对于节点放置，我们在 $[-1,1]$上比较两种策略。等距节点使用 $x_i=-1+\\dfrac{2i}{n}$，其中 $i=0,\\dots,n$。第一类切比雪夫节点（极值点）为 $x_i=\\cos\\!\\left(\\dfrac{i\\pi}{n}\\right)$，其中 $i=0,\\dots,n$。这些节点在端点附近聚集，并且已知对于解析函数能减小最大插值误差。所有三角函数计算均按规定使用弧度。Runge 函数 $f(x)=\\dfrac{1}{1+25x^2}$ 在 $[-1,1]$ 及其周围是解析的，然而，当使用等距节点进行插值时，它会显著地表现出 Runge 现象：随着 $n$ 的增加，由于在 $x=\\pm 1$ 附近的振荡，最大误差 $E_{\\max}$ 可能会恶化。切比雪夫节点通过最小化 Lebesgue 常数的增长并将节点密度分布在最需要的地方来缓解这一问题。\n\n为量化其行为，我们在一个由 $[-1,1]$ 上 $M=10001$ 个等距点组成的密集网格 $\\mathcal{G}$ 上进行求值。对于每个 $n\\in\\{0,1,5,10,20\\}$ 和每种节点策略，我们在 $\\mathcal{G}$ 上计算插值多项式 $p_n(x)$，然后计算最大绝对误差 $E_{\\max}=\\max_{x\\in\\mathcal{G}}|p_n(x)-f(x)|$。程序在单行上输出序列 $[E_{\\max}^{\\text{eq}}(0),E_{\\max}^{\\text{ch}}(0),E_{\\max}^{\\text{eq}}(1),E_{\\max}^{\\text{ch}}(1),E_{\\max}^{\\text{eq}}(5),E_{\\max}^{\\text{ch}}(5),E_{\\max}^{\\text{eq}}(10),E_{\\max}^{\\text{ch}}(10),E_{\\max}^{\\text{eq}}(20),E_{\\max}^{\\text{ch}}(20)]$。我们预期由于 Runge 现象，$E_{\\max}^{\\text{eq}}(n)$ 会先减小后随 $n$ 增大而增大，而 $E_{\\max}^{\\text{ch}}(n)$ 则应更稳定地减小。\n\n实现细节确保了数值鲁棒性：\n- 差分使用双精度数组进行原地计算，以避免不必要的复制。\n- 求值过程在网格上使用向量化的嵌套乘法以提高效率。\n- 对于切比雪夫节点生成器，当 $n=0$ 时，会显式处理，产生单个节点 $x_0=\\cos(0)=1$。当 $n\\ge 1$ 时，生成节点 $\\cos\\!\\left(\\dfrac{i\\pi}{n}\\right)$（其中 $i=0,\\dots,n$）并按升序排序；当为排序后的节点重新计算系数时，排序不会改变插值多项式，并且它能在不同策略间产生一致的顺序。\n\n这种有原则的方法直接反映了插值和差分的核心定义，采用牛顿基以获得高效算法，并在固定网格上计算所要求的误差度量，以便在不同节点集和次数之间进行客观比较。", "answer": "```python\nimport numpy as np\n\ndef runge_function(x: np.ndarray) -> np.ndarray:\n    # f(x) = 1 / (1 + 25 x^2)\n    return 1.0 / (1.0 + 25.0 * x * x)\n\ndef divided_differences(x: np.ndarray, y: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute Newton divided differences coefficients.\n    x: nodes (n+1,)\n    y: values at nodes (n+1,)\n    Returns coefficients c such that p(x) = c0 + c1*(x-x0) + ... in Newton form.\n    \"\"\"\n    n = x.size - 1\n    dd = y.astype(float).copy()\n    # In-place computation: dd[i] overwritten by higher-order divided differences\n    for k in range(1, n + 1):\n        # Update dd[0..n-k]\n        denom = x[k:] - x[:-k]\n        # Avoid division by zero; nodes are distinct by construction\n        dd[: n - k + 1] = (dd[1: n - k + 2] - dd[: n - k + 1]) / denom\n    # Coefficients are dd[0] at each order; we need to reconstruct them\n    # We can recompute to capture dd[0] at each stage by re-running but more efficient:\n    # Build the table once and collect c's\n    # Rebuild more explicitly:\n    dd_table = y.astype(float).copy()\n    coeffs = [dd_table[0]]\n    for k in range(1, n + 1):\n        dd_table[: n - k + 1] = (dd_table[1: n - k + 2] - dd_table[: n - k + 1]) / (x[k:] - x[:-k])\n        coeffs.append(dd_table[0])\n    return np.array(coeffs, dtype=float)\n\ndef newton_evaluate(x_eval: np.ndarray, x_nodes: np.ndarray, coeffs: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Evaluate Newton-form polynomial with given nodes and coefficients at x_eval.\n    Uses nested multiplication (Horner-like) for Newton basis.\n    \"\"\"\n    # Start from highest-order coefficient\n    p = np.full_like(x_eval, fill_value=coeffs[-1], dtype=float)\n    # Iterate backwards over nodes\n    for k in range(len(coeffs) - 2, -1, -1):\n        p = coeffs[k] + (x_eval - x_nodes[k]) * p\n    return p\n\ndef equispaced_nodes(n: int) -> np.ndarray:\n    # n+1 nodes from -1 to 1 inclusive\n    return np.linspace(-1.0, 1.0, n + 1, dtype=float)\n\ndef chebyshev_extrema_nodes(n: int) -> np.ndarray:\n    # Chebyshev nodes of the first kind (extrema): x_i = cos(i*pi/n), i=0..n\n    if n == 0:\n        nodes = np.array([1.0], dtype=float)\n    else:\n        i = np.arange(0, n + 1, dtype=float)\n        nodes = np.cos(np.pi * i / float(n))\n    # Sort ascending for consistency\n    nodes.sort()\n    return nodes\n\ndef max_abs_error_on_grid(n: int, node_strategy: str, grid: np.ndarray) -> float:\n    if node_strategy == \"equispaced\":\n        x_nodes = equispaced_nodes(n)\n    elif node_strategy == \"chebyshev\":\n        x_nodes = chebyshev_extrema_nodes(n)\n    else:\n        raise ValueError(\"Unknown node strategy\")\n\n    y_nodes = runge_function(x_nodes)\n    coeffs = divided_differences(x_nodes, y_nodes)\n    p_vals = newton_evaluate(grid, x_nodes, coeffs)\n    f_vals = runge_function(grid)\n    err = np.abs(p_vals - f_vals)\n    return float(np.max(err))\n\ndef solve():\n    # Define the test cases: degrees n\n    n_values = [0, 1, 5, 10, 20]\n    # Evaluation grid of M=10001 points on [-1,1]\n    M = 10001\n    grid = np.linspace(-1.0, 1.0, M, dtype=float)\n\n    results = []\n    for n in n_values:\n        e_eq = max_abs_error_on_grid(n, \"equispaced\", grid)\n        e_ch = max_abs_error_on_grid(n, \"chebyshev\", grid)\n        results.append(e_eq)\n        results.append(e_ch)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2426405"}]}