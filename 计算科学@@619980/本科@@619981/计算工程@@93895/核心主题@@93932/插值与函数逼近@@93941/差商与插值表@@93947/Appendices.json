{"hands_on_practices": [{"introduction": "理论学习之后，最好的巩固方式莫过于亲手实践。第一个练习将引导你完成构建牛顿差商表和使用插值多项式进行预测的核心流程。通过一个材料科学中的实际场景——估算合金在特定温度下的热导率，你将掌握从离散数据点出发，构建一个连续函数模型来做估计的基本技能。这个练习是后续更复杂应用的基础。[@problem_id:2189672]", "problem": "一个材料科学实验室正在表征一种用于高性能热交换器的新型金属合金。该合金的热导率 $k$ 在几个不同的温度 $T$ 下进行了测量。实验数据如下：\n\n- 在 $T_0 = 100$ K 时，热导率为 $k_0 = 400$ W/(m·K)。\n- 在 $T_1 = 200$ K 时，热导率为 $k_1 = 390$ W/(m·K)。\n- 在 $T_2 = 400$ K 时，热导率为 $k_2 = 350$ W/(m·K)。\n- 在 $T_3 = 600$ K 时，热导率为 $k_3 = 300$ W/(m·K)。\n\n为了预测该合金在中间温度下的行为，一位工程师决定使用一个经过所有四个数据点的牛顿形式的三次插值多项式 $P_3(T)$ 来模拟其热导率。\n\n你的任务是，从一个差商表中确定该多项式的系数，然后使用霍纳（Horner）嵌套求值法来估计该合金在温度 $T = 300$ K 时的热导率。\n\n请将你计算出的最终热导率结果以 W/(m·K) 为单位表示，并四舍五入到四位有效数字。", "solution": "给定数据点 $(T_{0},k_{0})=(100,400)$，$(T_{1},k_{1})=(200,390)$，$(T_{2},k_{2})=(400,350)$，$(T_{3},k_{3})=(600,300)$，我们构造牛顿形式的三次插值多项式\n$$\nP_{3}(T)=f[T_{0}]+f[T_{0},T_{1}](T-T_{0})+f[T_{0},T_{1},T_{2}](T-T_{0})(T-T_{1})+f[T_{0},T_{1},T_{2},T_{3}](T-T_{0})(T-T_{1})(T-T_{2}).\n$$\n逐步计算差商。一阶差商：\n$$\nf[T_{0},T_{1}]=\\frac{k_{1}-k_{0}}{T_{1}-T_{0}}=\\frac{390-400}{200-100}=-\\frac{1}{10},\n$$\n$$\nf[T_{1},T_{2}]=\\frac{k_{2}-k_{1}}{T_{2}-T_{1}}=\\frac{350-390}{400-200}=-\\frac{1}{5},\n$$\n$$\nf[T_{2},T_{3}]=\\frac{k_{3}-k_{2}}{T_{3}-T_{2}}=\\frac{300-350}{600-400}=-\\frac{1}{4}.\n$$\n二阶差商：\n$$\nf[T_{0},T_{1},T_{2}]=\\frac{f[T_{1},T_{2}]-f[T_{0},T_{1}]}{T_{2}-T_{0}}=\\frac{-\\frac{1}{5}-\\left(-\\frac{1}{10}\\right)}{400-100}=-\\frac{1}{3000},\n$$\n$$\nf[T_{1},T_{2},T_{3}]=\\frac{f[T_{2},T_{3}]-f[T_{1},T_{2}]}{T_{3}-T_{1}}=\\frac{-\\frac{1}{4}-\\left(-\\frac{1}{5}\\right)}{600-200}=-\\frac{1}{8000}.\n$$\n三阶差商：\n$$\nf[T_{0},T_{1},T_{2},T_{3}]=\\frac{f[T_{1},T_{2},T_{3}]-f[T_{0},T_{1},T_{2}]}{T_{3}-T_{0}}=\\frac{-\\frac{1}{8000}-\\left(-\\frac{1}{3000}\\right)}{600-100}=\\frac{1}{2400000}.\n$$\n因此，牛顿形式的系数为\n$$\na_{0}=f[T_{0}]=400,\\quad a_{1}=f[T_{0},T_{1}]=-\\frac{1}{10},\\quad a_{2}=f[T_{0},T_{1},T_{2}]=-\\frac{1}{3000},\\quad a_{3}=f[T_{0},T_{1},T_{2},T_{3}]=\\frac{1}{2400000}.\n$$\n因此\n$$\nP_{3}(T)=400-\\frac{1}{10}(T-100)-\\frac{1}{3000}(T-100)(T-200)+\\frac{1}{2400000}(T-100)(T-200)(T-400).\n$$\n在 $T=300$ 处使用霍纳嵌套求值法：\n$$\nb_{2}=a_{2}+(T-T_{2})a_{3}=-\\frac{1}{3000}+(-100)\\cdot\\frac{1}{2400000}=-\\frac{1}{3000}-\\frac{1}{24000}=-\\frac{3}{8000},\n$$\n$$\nb_{1}=a_{1}+(T-T_{1})b_{2}=-\\frac{1}{10}+100\\left(-\\frac{3}{8000}\\right)=-\\frac{1}{10}-\\frac{3}{80}=-\\frac{11}{80},\n$$\n$$\nP_{3}(300)=a_{0}+(T-T_{0})b_{1}=400+200\\left(-\\frac{11}{80}\\right)=400-\\frac{2200}{80}=372.5.\n$$\n四舍五入到四位有效数字，得到 $372.5$ W/(m·K)。", "answer": "$$\\boxed{372.5}$$", "id": "2189672"}, {"introduction": "差商表不仅是一个计算工具，它还蕴含了关于数据背后规律的深刻信息。这个练习将挑战你从计算者转变为分析者。通过观察高阶差商是否趋近于零，你可以判断一组数据点是否可能由一个低阶多项式生成。这项技能在数据分析和模型选择中至关重要，它能帮助我们仅通过数据本身来推断其内在的数学结构。[@problem_id:2386657]", "problem": "一个由标量对 $(x_i, y_i)$ 组成的数据集在五个不同的节点上被记录，用于计算工程中的代理模型。这些节点和值是：\n$(-2, -17)$、_(-1, 0)_、_(0, 4)_、_(1, 4)_、_(2, 9)_。\n请仅根据差分所反映的多项式的数学性质，选择一个关于能够精确生成所有五个数据点的单变量多项式最小次数的最精确陈述。\n\nA. 数据与一个次数至多为 $2$ 的多项式一致。\n\nB. 数据与一个次数至多为 $3$ 的多项式一致，但与任何次数至多为 $2$ 的多项式都不一致。\n\nC. 数据与一个次数至多为 $4$ 的多项式一致，但与任何次数至多为 $3$ 的多项式都不一致。\n\nD. 没有次数至多为 $4$ 的多项式可以插值所有这些点。", "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n所提供的数据包含一组五个标量对 $(x_i, y_i)$：\n$(-2, -17)$、_(-1, 0)_、_(0, 4)_、_(1, 4)_、_(2, 9)_。\n目标是使用差分法，确定关于对这五个数据点进行插值的单变量多项式最小次数的最精确陈述。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题有其科学基础，即多项式插值理论，这是数值分析中的一个基本课题。差分的概念是构造和分析插值多项式的一种标准技术。该问题是适定的：对于一组 $n+1$ 个不同的点，存在一个次数至多为 $n$ 的唯一插值多项式。寻找*最小*次数的任务是一个定义明确的子问题，可通过检查差分表来解决。数据是完整且一致的。不存在科学或逻辑上的缺陷。\n\n**步骤3：结论与行动**\n问题有效。我们将进行严谨的求解。\n\n拟合给定数据集的多项式的最小次数可以通过构建一个牛顿差分表来确定。对于一个 $n$ 次多项式，其 $n$ 阶差分是常数，其 $(n+1)$ 阶差分为零。\n\n设给定的数据点为 $(x_i, y_i)$，其中 $i=0, 1, 2, 3, 4$。\n$x_0 = -2, y_0 = -17$\n$x_1 = -1, y_1 = 0$\n$x_2 = 0, y_2 = 4$\n$x_3 = 1, y_3 = 4$\n$x_4 = 2, y_4 = 9$\n\n零阶差分就是函数值本身，$f[x_i] = y_i$。\n\n一阶差分计算如下：\n$f[x_0, x_1] = \\frac{y_1 - y_0}{x_1 - x_0} = \\frac{0 - (-17)}{-1 - (-2)} = \\frac{17}{1} = 17$\n$f[x_1, x_2] = \\frac{y_2 - y_1}{x_2 - x_1} = \\frac{4 - 0}{0 - (-1)} = \\frac{4}{1} = 4$\n$f[x_2, x_3] = \\frac{y_3 - y_2}{x_3 - x_2} = \\frac{4 - 4}{1 - 0} = \\frac{0}{1} = 0$\n$f[x_3, x_4] = \\frac{y_4 - y_3}{x_4 - x_3} = \\frac{9 - 4}{2 - 1} = \\frac{5}{1} = 5$\n\n二阶差分如下：\n$f[x_0, x_1, x_2] = \\frac{f[x_1, x_2] - f[x_0, x_1]}{x_2 - x_0} = \\frac{4 - 17}{0 - (-2)} = \\frac{-13}{2}$\n$f[x_1, x_2, x_3] = \\frac{f[x_2, x_3] - f[x_1, x_2]}{x_3 - x_1} = \\frac{0 - 4}{1 - (-1)} = \\frac{-4}{2} = -2$\n$f[x_2, x_3, x_4] = \\frac{f[x_3, x_4] - f[x_2, x_3]}{x_4 - x_2} = \\frac{5 - 0}{2 - 0} = \\frac{5}{2}$\n\n三阶差分如下：\n$f[x_0, x_1, x_2, x_3] = \\frac{f[x_1, x_2, x_3] - f[x_0, x_1, x_2]}{x_3 - x_0} = \\frac{-2 - (-\\frac{13}{2})}{1 - (-2)} = \\frac{- \\frac{4}{2} + \\frac{13}{2}}{3} = \\frac{\\frac{9}{2}}{3} = \\frac{3}{2}$\n$f[x_1, x_2, x_3, x_4] = \\frac{f[x_2, x_3, x_4] - f[x_1, x_2, x_3]}{x_4 - x_1} = \\frac{\\frac{5}{2} - (-2)}{2 - (-1)} = \\frac{\\frac{5}{2} + \\frac{4}{2}}{3} = \\frac{\\frac{9}{2}}{3} = \\frac{3}{2}$\n\n三阶差分是常数且非零。这已经表明多项式的最小次数是 $3$。为确认这一点，我们计算四阶差分。\n\n四阶差分如下：\n$f[x_0, x_1, x_2, x_3, x_4] = \\frac{f[x_1, x_2, x_3, x_4] - f[x_0, x_1, x_2, x_3]}{x_4 - x_0} = \\frac{\\frac{3}{2} - \\frac{3}{2}}{2 - (-2)} = \\frac{0}{4} = 0$\n\n由于三阶差分是常数且等于 $\\frac{3}{2} \\neq 0$，而四阶差分为 $0$，因此这些数据精确地对应一个 $3$ 次多项式。该多项式的牛顿形式是 $P_3(x) = f[x_0] + f[x_0,x_1](x-x_0) + f[x_0,x_1,x_2](x-x_0)(x-x_1) + f[x_0,x_1,x_2,x_3](x-x_0)(x-x_1)(x-x_2)$。最高次项 $x^3$ 的系数是 $f[x_0,x_1,x_2,x_3] = \\frac{3}{2}$，它不为零。因此，最小次数恰好是 $3$。\n\n现在我们评估给定的选项。\n\nA. 数据与一个次数至多为 $2$ 的多项式一致。\n该陈述意味着数据可以由一个次数为 $2$、$1$ 或 $0$ 的多项式表示。要使其为真，所有三阶差分必须为零。我们的计算显示三阶差分为 $\\frac{3}{2}$，不为零。因此，多项式的最小次数必须大于 $2$。\n结论：**错误**。\n\nB. 数据与一个次数至多为 $3$ 的多项式一致，但与任何次数至多为 $2$ 的多项式都不一致。\n该陈述由两个论断组成。首先，“与一个次数至多为 $3$ 的多项式一致”。如果四阶差分为零，则此论断为真。我们发现 $f[x_0, x_1, x_2, x_3, x_4] = 0$，这证实了这一部分。其次，“与任何次数至多为 $2$ 的多项式都不一致”。因为三阶差分非零，所以此论断为真。由于两个论断都正确，该陈述准确地描述了插值多项式的最小次数恰好为 $3$。\n结论：**正确**。\n\nC. 数据与一个次数至多为 $4$ 的多项式一致，但与任何次数至多为 $3$ 的多项式都不一致。\n第一部分，“与一个次数至多为 $4$ 的多项式一致”，对于任何五个点来说都是不证自明的。一个 $3$ 次多项式是次数至多为 $4$ 的多项式的一个特例（其 $x^4$ 系数为零）。然而，第二部分，“与任何次数至多为 $3$ 的多项式都不一致”，是错误的。正如我们所证明的，这些数据可以被一个 $3$ 次多项式完美描述。\n结论：**错误**。\n\nD. 没有次数至多为 $4$ 的多项式可以插值所有这些点。\n该陈述与多项式插值基本定理相矛盾，该定理保证了对于任意 $n+1$ 个不同的点，都存在一个唯一的、次数至多为 $n$ 的多项式穿过它们。这里我们有 $5$ 个点，所以 $n=4$。必须存在一个次数至多为 $4$ 的唯一多项式。我们已经明确地发现它是一个 $3$ 次多项式。\n结论：**错误**。", "answer": "$$\\boxed{B}$$", "id": "2386657"}, {"introduction": "现在，让我们进入一个更高级的计算实践，它揭示了多项式插值中一个著名且重要的问题——龙格现象（Runge phenomenon）。通过编程实现对龙格函数 $f(x) = 1/(1+25x^2)$ 的插值，你将亲眼见证在均匀间隔节点上插值失败的惊人结果，以及通过理论指导选择更优的切比雪夫节点（Chebyshev nodes）如何巧妙地解决这一难题。这个练习完美地连接了数值理论与计算实践，展示了理论知识在解决实际工程问题中的强大威力。[@problem_id:2426405]", "problem": "您需要使用两种节点生成策略，为 Runge 函数实现牛顿形式的多项式插值。从基本定义出发：对于 $n+1$ 个互异节点 $\\{x_0,\\dots,x_n\\}$ 和相应的函数值 $\\{f(x_0),\\dots,f(x_n)\\}$，存在一个次数至多为 $n$ 的唯一多项式 $p_n(x)$，满足对所有 $i$ 都有 $p_n(x_i)=f(x_i)$。请使用差商的递归定义和牛顿基，推导出一个数值稳定的求值算法。目标函数为区间 $[-1,1]$ 上的 Runge 函数 $f(x)=\\dfrac{1}{1+25x^2}$。所有角度必须以弧度为单位。\n\n您的任务是：\n- 实现一个函数，用于计算节点 $\\{x_i\\}_{i=0}^n$ 和函数值 $\\{f(x_i)\\}_{i=0}^n$ 的差商，从而得到 $p_n(x)$ 的牛顿形式系数 $\\{c_0,\\dots,c_n\\}$。\n- 实现一个函数，基于牛顿基 $\\{1,(x-x_0),(x-x_0)(x-x_1),\\dots\\}$ 和先前计算出的系数 $\\{c_k\\}_{k=0}^n$，使用嵌套乘法在任意点 $x$ 处对牛顿形式的插值多项式进行求值。\n- 对于每个次数 $n$，在区间 $[-1,1]$ 上生成两组插值节点：\n  - 等距节点：$x_i=-1+\\dfrac{2i}{n}$，其中 $i=0,\\dots,n$。\n  - 第一类切比雪夫节点（极值点）在 $[-1,1]$ 上：$x_i=\\cos\\!\\left(\\dfrac{i\\pi}{n}\\right)$，其中 $i=0,\\dots,n$。使用弧度。\n- 对于每个插值多项式，在一个由 $[-1,1]$ 上的 $M$ 个均匀分布点构成的密集网格 $\\mathcal{G}$ 上计算 $p_n(x)$ 的值，并计算最大绝对误差 $E_{\\max}=\\max_{x\\in\\mathcal{G}}|p_n(x)-f(x)|$。\n- 所有算术运算均使用双精度。\n\n测试套件规范：\n- 使用区间 $[-1,1]$ 上的 Runge 函数 $f(x)=\\dfrac{1}{1+25x^2}$。\n- 使用一个包含 $M=10001$ 个在 $[-1,1]$ 上等距分布的点的求值网格 $\\mathcal{G}$。\n- 使用以下次数（每个次数对应 $n+1$ 个节点）：$n\\in\\{0,1,5,10,20\\}$。\n- 对于上述集合中的每个 $n$，计算两个数值：等距节点的 $E_{\\max}^{\\text{eq}}(n)$ 和切比雪夫节点的 $E_{\\max}^{\\text{ch}}(n)$（角度使用弧度）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。该列表必须按以下顺序包含实数：\n  - $\\big[E_{\\max}^{\\text{eq}}(0),E_{\\max}^{\\text{ch}}(0),E_{\\max}^{\\text{eq}}(1),E_{\\max}^{\\text{ch}}(1),E_{\\max}^{\\text{eq}}(5),E_{\\max}^{\\text{ch}}(5),E_{\\max}^{\\text{eq}}(10),E_{\\max}^{\\text{ch}}(10),E_{\\max}^{\\text{eq}}(20),E_{\\max}^{\\text{ch}}(20)\\big]$。\n- 输出必须是单行，且不得包含任何附加文本。", "solution": "该问题从插值的核心定义出发：给定 $n+1$ 个互异节点 $\\{x_0,\\dots,x_n\\}$ 和数据值 $\\{y_0,\\dots,y_n\\}$（其中 $y_i=f(x_i)$），存在一个次数至多为 $n$ 的唯一多项式 $p_n(x)$，满足对所有 $i=0,\\dots,n$ 都有 $p_n(x_i)=y_i$。牛顿形式是一种构造性表示，它结合了两个基本部分：差商和牛顿基。牛顿基递归定义为 $N_0(x)=1$，当 $k\\ge 1$ 时 $N_k(x)=(x-x_{k-1})N_{k-1}(x)$，即 $N_k(x)=\\prod_{j=0}^{k-1}(x-x_j)$。插值多项式可以表示为 $p_n(x)=\\sum_{k=0}^n c_k N_k(x)$，其中系数 $c_k$ 是差商 $c_k=f[x_0,\\dots,x_k]$。差商通过递归从数据中确定：$f[x_i]=y_i$，且当 $k\\ge 1$ 时，$f[x_i,\\dots,x_{i+k}]=\\dfrac{f[x_{i+1},\\dots,x_{i+k}]-f[x_i,\\dots,x_{i+k-1}]}{x_{i+k}-x_i}$。这种构造通过对 $i$ 进行归纳，直接体现了数据约束 $p_n(x_i)=y_i$，从而保证了存在性和唯一性。\n\n算法设计如下。首先，计算差商。我们可以在一个初始化为 $d_i^{(0)}=y_i$ 的数组 $d$ 上原地实现递归。对于每个阶 $k=1,\\dots,n$ 和索引 $i=0,\\dots,n-k$，更新 $d_i^{(k)}=\\dfrac{d_{i+1}^{(k-1)}-d_i^{(k-1)}}{x_{i+k}-x_i}$。完成所有阶的计算后，牛顿系数为 $c_k=d_0^{(k)}$，其中 $k=0,\\dots,n$。这是一个 $O(n^2)$ 时间复杂度的操作，且仅使用核心递归。\n\n其次，通过嵌套乘法（一种适用于牛顿基的、类似 Horner 的方案）来高效且稳定地对插值多项式求值。从 $v=c_n$ 开始，对 $k=n-1,\\dots,0$ 迭代计算 $v \\leftarrow c_{k}+ (x-x_k)\\,v$。此方法基于将 $p_n$ 以嵌套形式表示：$p_n(x)=c_0+(x-x_0)\\left(c_1+(x-x_1)\\left(\\dots+(x-x_{n-1})c_n\\right)\\right)$，该形式由基恒等式 $N_{k+1}(x)=(x-x_k)N_k(x)$ 经重排得到。这种对每个点的求值是 $O(n)$ 的，并且相对于朴素的基展开是数值稳定的。\n\n对于节点布局，我们比较了在 $[-1,1]$ 上的两种策略。等距节点使用 $x_i=-1+\\dfrac{2i}{n}$（其中 $i=0,\\dots,n$）。第一类切比雪夫节点（极值点）为 $x_i=\\cos\\!\\left(\\dfrac{i\\pi}{n}\\right)$（其中 $i=0,\\dots,n$），这些节点在区间端点附近聚集，已知可以减小解析函数的最大插值误差。按照规定，所有三角函数计算都使用弧度。Runge 函数 $f(x)=\\dfrac{1}{1+25x^2}$ 在区间 $[-1,1]$ 上及其周围是解析的，但它在使用等距节点进行插值时会表现出著名的 Runge 现象：随着 $n$ 的增加，由于在 $x=\\pm 1$ 附近出现振荡，最大误差 $E_{\\max}$ 可能会变差。切比雪夫节点通过最小化 Lebesgue 常数的增长，并将节点密度分布在最需要的地方来缓解这一问题。\n\n为了量化这种行为，我们在一个由 $[-1,1]$ 上的 $M=10001$ 个等距点构成的密集网格 $\\mathcal{G}$ 上进行求值。对于每个 $n\\in\\{0,1,5,10,20\\}$ 和每种节点策略，我们计算插值多项式 $p_n(x)$ 在 $\\mathcal{G}$ 上的值，然后计算最大绝对误差 $E_{\\max}=\\max_{x\\in\\mathcal{G}}|p_n(x)-f(x)|$。程序输出序列 $[E_{\\max}^{\\text{eq}}(0),E_{\\max}^{\\text{ch}}(0),E_{\\max}^{\\text{eq}}(1),E_{\\max}^{\\text{ch}}(1),E_{\\max}^{\\text{eq}}(5),E_{\\max}^{\\text{ch}}(5),E_{\\max}^{\\text{eq}}(10),E_{\\max}^{\\text{ch}}(10),E_{\\max}^{\\text{eq}}(20),E_{\\max}^{\\text{ch}}(20)]$ 于单行。我们预计，由于 Runge 现象，$E_{\\max}^{\\text{eq}}(n)$ 会随着 $n$ 先减小后增大，而 $E_{\\max}^{\\text{ch}}(n)$ 则应更稳定地减小。\n\n实现细节确保了数值鲁棒性：\n- 差商使用双精度数组进行原地计算，以避免不必要的拷贝。\n- 求值过程在整个网格上使用向量化的嵌套乘法以提高效率。\n- 对于切比雪夫节点生成器，$n=0$ 的情况被显式处理，生成单个节点 $x_0=\\cos(0)=1$。对于 $n\\ge 1$，生成节点 $\\cos\\!\\left(\\dfrac{i\\pi}{n}\\right)$（其中 $i=0,\\dots,n$）并按升序排序；当系数根据排序后的节点重新计算时，排序不会改变插值多项式，并且它能在不同策略间产生一致的节点顺序。\n\n这种有原则的方法直接反映了插值和差商的核心定义，采用牛顿基以获得高效算法，并在固定网格上计算所要求的误差度量，以便对不同节点集和次数进行客观比较。", "answer": "```python\nimport numpy as np\n\ndef runge_function(x: np.ndarray) -> np.ndarray:\n    # f(x) = 1 / (1 + 25 x^2)\n    return 1.0 / (1.0 + 25.0 * x * x)\n\ndef divided_differences(x: np.ndarray, y: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute Newton divided differences coefficients.\n    x: nodes (n+1,)\n    y: values at nodes (n+1,)\n    Returns coefficients c such that p(x) = c0 + c1*(x-x0) + ... in Newton form.\n    \"\"\"\n    n = x.size - 1\n    dd = y.astype(float).copy()\n    # In-place computation: dd[i] overwritten by higher-order divided differences\n    for k in range(1, n + 1):\n        # Update dd[0..n-k]\n        denom = x[k:] - x[:-k]\n        # Avoid division by zero; nodes are distinct by construction\n        dd[: n - k + 1] = (dd[1: n - k + 2] - dd[: n - k + 1]) / denom\n    # Coefficients are dd[0] at each order; we need to reconstruct them\n    # We can recompute to capture dd[0] at each stage by re-running but more efficient:\n    # Build the table once and collect c's\n    # Rebuild more explicitly:\n    dd_table = y.astype(float).copy()\n    coeffs = [dd_table[0]]\n    for k in range(1, n + 1):\n        dd_table[: n - k + 1] = (dd_table[1: n - k + 2] - dd_table[: n - k + 1]) / (x[k:] - x[:-k])\n        coeffs.append(dd_table[0])\n    return np.array(coeffs, dtype=float)\n\ndef newton_evaluate(x_eval: np.ndarray, x_nodes: np.ndarray, coeffs: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Evaluate Newton-form polynomial with given nodes and coefficients at x_eval.\n    Uses nested multiplication (Horner-like) for Newton basis.\n    \"\"\"\n    # Start from highest-order coefficient\n    p = np.full_like(x_eval, fill_value=coeffs[-1], dtype=float)\n    # Iterate backwards over nodes\n    for k in range(len(coeffs) - 2, -1, -1):\n        p = coeffs[k] + (x_eval - x_nodes[k]) * p\n    return p\n\ndef equispaced_nodes(n: int) -> np.ndarray:\n    # n+1 nodes from -1 to 1 inclusive\n    return np.linspace(-1.0, 1.0, n + 1, dtype=float)\n\ndef chebyshev_extrema_nodes(n: int) -> np.ndarray:\n    # Chebyshev nodes of the first kind (extrema): x_i = cos(i*pi/n), i=0..n\n    if n == 0:\n        nodes = np.array([1.0], dtype=float)\n    else:\n        i = np.arange(0, n + 1, dtype=float)\n        nodes = np.cos(np.pi * i / float(n))\n    # Sort ascending for consistency\n    nodes.sort()\n    return nodes\n\ndef max_abs_error_on_grid(n: int, node_strategy: str, grid: np.ndarray) -> float:\n    if node_strategy == \"equispaced\":\n        x_nodes = equispaced_nodes(n)\n    elif node_strategy == \"chebyshev\":\n        x_nodes = chebyshev_extrema_nodes(n)\n    else:\n        raise ValueError(\"Unknown node strategy\")\n\n    y_nodes = runge_function(x_nodes)\n    coeffs = divided_differences(x_nodes, y_nodes)\n    p_vals = newton_evaluate(grid, x_nodes, coeffs)\n    f_vals = runge_function(grid)\n    err = np.abs(p_vals - f_vals)\n    return float(np.max(err))\n\ndef solve():\n    # Define the test cases: degrees n\n    n_values = [0, 1, 5, 10, 20]\n    # Evaluation grid of M=10001 points on [-1,1]\n    M = 10001\n    grid = np.linspace(-1.0, 1.0, M, dtype=float)\n\n    results = []\n    for n in n_values:\n        e_eq = max_abs_error_on_grid(n, \"equispaced\", grid)\n        e_ch = max_abs_error_on_grid(n, \"chebyshev\", grid)\n        results.append(e_eq)\n        results.append(e_ch)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2426405"}]}