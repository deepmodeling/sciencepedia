{"hands_on_practices": [{"introduction": "这第一个练习是您进入抛物线型偏微分方程数值求解世界的起点。您将实现经典的前向时间中心空间（FTCS）显式格式，来模拟一维热传导，这是许多工程领域中的一个基本问题。通过将您的数值结果与已知的解析解进行比较，您将获得关于离散化、实现时间步进循环和评估数值准确性的实践经验 [@problem_id:2483476]。", "problem": "您的任务是使用显式时间前向中心空间 (FTCS) 格式，实现一个用于一维瞬态热传导的数值模拟器。从能量守恒和 Fourier 热传导定律出发，推导出一维热方程，该方程描述了具有恒定热扩散系数 $\\alpha$ 的均匀杆，并采用齐次 Dirichlet 边界条件。杆占据的空间为 $x \\in [0,L]$。对于所有 $t \\ge 0$，边界温度固定为 $T(0,t)=0$ 和 $T(L,t)=0$。初始条件为单模正弦函数 $T(x,0) = T_{\\mathrm{amp}} \\sin\\!\\left(\\frac{\\pi x}{L}\\right)$。\n\n您的任务是：\n- 将空间域离散化为包含两个边界在内的 $N$ 个节点的均匀网格，节点间距为 $\\Delta x = L/(N-1)$，并使用恒定时间步长 $\\Delta t$ 将时间离散化。使用 FTCS 显式格式更新内部节点，并在每个时间步施加边界条件。\n- 对于每个提供的测试用例，选择 $\\Delta t$ 以满足指定的无量纲比 $r = \\alpha \\,\\Delta t/\\Delta x^2$。$r$ 的值以及所有其他参数在下面的测试套件中给出。假设所选的 $\\Delta t$ 使得 $t_{\\mathrm{end}}/\\Delta t$ 为整数。将解从 $t=0$ 演化到 $t=t_{\\mathrm{end}}$。\n- 在指定的节点索引 $i_{\\star}$（采用从零开始的索引）处，计算时间 $t_{\\mathrm{end}}$ 时的数值解温度 $T_{\\mathrm{num}}$ 和同一位置和时间的解析解温度 $T_{\\mathrm{ana}}$，并为每个测试用例返回绝对误差 $|T_{\\mathrm{num}} - T_{\\mathrm{ana}}|$。\n\n使用的基本原理：\n- 微分控制体的能量守恒结合 Fourier 定律，可推导出均匀介质（具有恒定 $\\alpha$）的一维瞬态热方程 $\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}$。\n- 对于给定的初始条件和边界条件，通过分离变量法得到的解析解为单个衰减模态 $T(x,t) = T_{\\mathrm{amp}} \\sin\\!\\left(\\frac{\\pi x}{L}\\right) \\exp\\!\\left(-\\alpha \\left(\\frac{\\pi}{L}\\right)^2 t\\right)$。\n- FTCS 格式是一种显式时间步进方法，它在时间上使用前向差分，在空间上使用中心二阶差分。\n\n假设与要求：\n- 对节点 $i=0,1,\\dots,N-1$ 使用从零开始的索引，其中 $x_i = i\\,\\Delta x$。\n- 将所有节点的数值解初始化为 $T_i^0 = T_{\\mathrm{amp}} \\sin\\!\\left(\\frac{\\pi x_i}{L}\\right)$，并对所有时间步 $n$ 施加 $T_0^n=0$ 和 $T_{N-1}^n=0$。\n- 对于每个测试用例，计算 $\\Delta x$，然后根据给定的 $r$ 计算 $\\Delta t = r\\,\\Delta x^2/\\alpha$，并精确执行 $n_{\\mathrm{steps}} = t_{\\mathrm{end}}/\\Delta t$ 个时间步。\n- 计算指定节点 $i_{\\star}$ 处的绝对误差，结果为一个实数。\n\n物理单位：\n- 所有温度均以开尔文表示。最终报告的误差也必须以开尔文表示。时间单位为秒，长度单位为米，热扩散系数单位为 $\\mathrm{m^2/s}$。\n\n测试套件：\n- 用例 $1$：$L=1\\,\\mathrm{m}$，$\\alpha=1.0\\times 10^{-4}\\,\\mathrm{m^2/s}$，$T_{\\mathrm{amp}}=10\\,\\mathrm{K}$，$N=51$，$r=0.4$，$t_{\\mathrm{end}}=160\\,\\mathrm{s}$，$i_{\\star}=25$。\n- 用例 $2$：$L=1\\,\\mathrm{m}$，$\\alpha=1.0\\times 10^{-4}\\,\\mathrm{m^2/s}$，$T_{\\mathrm{amp}}=10\\,\\mathrm{K}$，$N=41$，$r=0.5$，$t_{\\mathrm{end}}=31.25\\,\\mathrm{s}$，$i_{\\star}=20$。\n- 用例 $3$：$L=1\\,\\mathrm{m}$，$\\alpha=1.0\\times 10^{-4}\\,\\mathrm{m^2/s}$，$T_{\\mathrm{amp}}=5\\,\\mathrm{K}$，$N=11$，$r=0.2$，$t_{\\mathrm{end}}=200\\,\\mathrm{s}$，$i_{\\star}=5$。\n- 用例 $4$：$L=1\\,\\mathrm{m}$，$\\alpha=1.0\\times 10^{-4}\\,\\mathrm{m^2/s}$，$T_{\\mathrm{amp}}=10\\,\\mathrm{K}$，$N=101$，$r=0.1$，$t_{\\mathrm{end}}=10\\,\\mathrm{s}$，$i_{\\star}=0$。\n\n数值输出规范：\n- 对每个用例，计算在 $t=t_{\\mathrm{end}}$ 和节点 $i_{\\star}$ 处的标量绝对误差 $|T_{\\mathrm{num}} - T_{\\mathrm{ana}}|$，单位为开尔文。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按用例 1 到 4 的顺序列出结果（例如，`[结果_1,结果_2,结果_3,结果_4]`）。每个条目都必须是一个表示开尔文的浮点数。", "solution": "在尝试求解之前，对问题陈述进行验证。\n\n### 问题验证\n\n#### 第 1 步：提取已知条件\n\n控制偏微分方程是均匀介质（具有恒定热扩散系数 $\\alpha$）的一维热方程：\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}\n$$\n域为长度为 $L$ 的杆，定义为 $x \\in [0, L]$。\n\n边界条件 (BCs)：齐次 Dirichlet 条件。\n$$\nT(0, t) = 0 \\quad \\text{对于所有 } t \\ge 0\n$$\n$$\nT(L, t) = 0 \\quad \\text{对于所有 } t \\ge 0\n$$\n\n初始条件 (IC)：单模正弦函数。\n$$\nT(x, 0) = T_{\\mathrm{amp}} \\sin\\left(\\frac{\\pi x}{L}\\right)\n$$\n\n解析解：\n$$\nT(x, t) = T_{\\mathrm{amp}} \\sin\\left(\\frac{\\pi x}{L}\\right) \\exp\\left(-\\alpha \\left(\\frac{\\pi}{L}\\right)^2 t\\right)\n$$\n\n数值格式：显式时间前向中心空间 (FTCS)。\n-   空间离散化：包含 $N$ 个节点的均匀网格，间距 $\\Delta x = L/(N-1)$。\n-   节点索引：$i = 0, 1, \\dots, N-1$，其中 $x_i = i\\,\\Delta x$。\n-   时间离散化：恒定时间步长 $\\Delta t$。\n-   无量纲比：$r = \\alpha \\,\\Delta t/\\Delta x^2$。\n-   时间演化：从 $t=0$ 到 $t=t_{\\mathrm{end}}$。步数 $t_{\\mathrm{end}}/\\Delta t$ 是一个整数。\n-   初始数值解：$T_i^0 = T_{\\mathrm{amp}} \\sin\\left(\\frac{\\pi x_i}{L}\\right)$。\n-   任务：在时间 $t_{\\mathrm{end}}$，计算节点索引 $i_{\\star}$ 处的数值解温度 $T_{\\mathrm{num}}$ 和解析解温度 $T_{\\mathrm{ana}}$，并返回绝对误差 $|T_{\\mathrm{num}} - T_{\\mathrm{ana}}|$。\n\n测试套件参数：\n-   用例 $1$：$L=1\\,\\mathrm{m}$，$\\alpha=1.0\\times 10^{-4}\\,\\mathrm{m^2/s}$，$T_{\\mathrm{amp}}=10\\,\\mathrm{K}$，$N=51$，$r=0.4$，$t_{\\mathrm{end}}=160\\,\\mathrm{s}$，$i_{\\star}=25$。\n-   用例 $2$：$L=1\\,\\mathrm{m}$，$\\alpha=1.0\\times 10^{-4}\\,\\mathrm{m^2/s}$，$T_{\\mathrm{amp}}=10\\,\\mathrm{K}$，$N=41$，$r=0.5$，$t_{\\mathrm{end}}=31.25\\,\\mathrm{s}$，$i_{\\star}=20$。\n-   用例 $3$：$L=1\\,\\mathrm{m}$，$\\alpha=1.0\\times 10^{-4}\\,\\mathrm{m^2/s}$，$T_{\\mathrm{amp}}=5\\,\\mathrm{K}$，$N=11$，$r=0.2$，$t_{\\mathrm{end}}=200\\,\\mathrm{s}$，$i_{\\star}=5$。\n-   用例 $4$：$L=1\\,\\mathrm{m}$，$\\alpha=1.0\\times 10^{-4}\\,\\mathrm{m^2/s}$，$T_{\\mathrm{amp}}=10\\,\\mathrm{K}$，$N=101$，$r=0.1$，$t_{\\mathrm{end}}=10\\,\\mathrm{s}$，$i_{\\star}=0$。\n\n#### 第 2 步：使用提取的已知条件进行验证\n\n1.  **科学依据充分**：该问题基于权威的一维热方程，这是一个从能量守恒和 Fourier 传导定律推导出的基本原理。FTCS 方法是用于抛物线型偏微分方程的一种标准的、有详细文献记载的有限差分格式。所提供的解析解是给定初始和边界条件下的正确解。该问题在科学和数学上是合理的。\n\n2.  **适定性**：该问题是一个适定的抛物线型偏微分方程的初边值问题。FTCS 格式对于一维热方程的稳定性由 Courant–Friedrichs–Lewy (CFL) 条件决定，该条件要求无量纲参数 $r = \\alpha \\,\\Delta t/\\Delta x^2$ 满足 $r \\le 0.5$。\n    -   用例 $1$：$r = 0.4 \\le 0.5$。稳定。\n    -   用例 $2$：$r = 0.5 \\le 0.5$。临界稳定，这是一个有效条件。\n    -   用例 $3$：$r = 0.2 \\le 0.5$。稳定。\n    -   用例 $4$：$r = 0.1 \\le 0.5$。稳定。\n    所有测试用例都遵守稳定性判据，确保了数值解有意义。\n\n3.  **客观性**：问题陈述语言清晰、客观，所有参数都用精确的数值定义。没有主观或基于观点的陈述。\n\n4.  **完整性与一致性**：问题提供了所有必要的信息：控制方程、初始和边界条件、离散化方法、每个测试用例的所有物理和数值参数，以及对所需输出的明确定义。这些参数是自洽的。例如，在用例 4 中，评估节点为 $i_{\\star}=0$。边界条件固定了 $T(0,t)=0$，解析解同样得到 $T(0,t)=0$。因此，预期的绝对误差为 0，这是对边界条件实现的一个有效测试。\n\n#### 第 3 步：结论与行动\n\n该问题是**有效的**。它科学合理、适定、完整且没有歧义。将提供解答。\n\n### 解的推导与算法\n\n控制方程是一维热方程：\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}\n$$\n我们在网格上离散化该方程，其中 $T_i^n$ 表示空间节点 $i$ 和时间步 $n$ 处的温度。空间坐标为 $x_i = i\\Delta x$（对于 $i=0, 1, \\dots, N-1$），时间为 $t_n = n\\Delta t$。\n\nFTCS 格式对时间导数采用前向差分，对空间导数采用二阶中心差分：\n$$\n\\frac{\\partial T}{\\partial t}\\bigg|_{(x_i, t_n)} \\approx \\frac{T_i^{n+1} - T_i^n}{\\Delta t}\n$$\n$$\n\\frac{\\partial^2 T}{\\partial x^2}\\bigg|_{(x_i, t_n)} \\approx \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{\\Delta x^2}\n$$\n\n将这些近似代入热方程，得到：\n$$\n\\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\alpha \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{\\Delta x^2}\n$$\n\n求解下一个时间步的温度 $T_i^{n+1}$，得到显式更新规则：\n$$\nT_i^{n+1} = T_i^n + \\frac{\\alpha \\Delta t}{\\Delta x^2} \\left( T_{i+1}^n - 2T_i^n + T_{i-1}^n \\right)\n$$\n\n引入无量纲扩散数 $r = \\frac{\\alpha \\Delta t}{\\Delta x^2}$，可简化表达式：\n$$\nT_i^{n+1} = T_i^n + r \\left( T_{i+1}^n - 2T_i^n + T_{i-1}^n \\right)\n$$\n为了计算效率，可以将其重新排列为：\n$$\nT_i^{n+1} = r T_{i-1}^n + (1 - 2r) T_i^n + r T_{i+1}^n\n$$\n此更新规则应用于所有内部节点，即 $i = 1, 2, \\dots, N-2$。根据 Dirichlet 边界条件，边界节点 $i=0$ 和 $i=N-1$ 在所有时间步都固定为 $0\\,\\mathrm{K}$。\n\n每个测试用例的算法如下：\n1.  从测试用例中定义物理和数值参数：$L$、$\\alpha$、$T_{\\mathrm{amp}}$、$N$、$r$、$t_{\\mathrm{end}}$ 和 $i_{\\star}$。\n2.  计算网格间距 $\\Delta x = L / (N - 1)$ 和时间步长 $\\Delta t = r \\cdot \\Delta x^2 / \\alpha$。\n3.  计算达到 $t_{\\mathrm{end}}$ 所需的总时间步数，即 $n_{\\mathrm{steps}} = \\text{round}(t_{\\mathrm{end}} / \\Delta t)$。问题陈述保证这是一个整数。\n4.  创建空间网格 $x_i = i \\Delta x$，其中 $i=0, \\dots, N-1$。\n5.  使用初始条件在时间 $t=0$ 初始化温度数组 $T$：对所有 $i$，有 $T_i = T_{\\mathrm{amp}} \\sin(\\pi x_i / L)$。\n6.  开始时间步进循环，从 $n=0$ 到 $n_{\\mathrm{steps}}-1$：\n    a. 创建一个新数组 $T_{\\text{new}}$，用于存储下一个时间步 $n+1$ 的温度。\n    b. 对于从 $1$ 到 $N-2$ 的每个内部节点 $i$，使用 FTCS 更新规则计算 $T_{\\text{new},i}$：$T_{\\text{new},i} = r T_{i-1} + (1-2r) T_i + r T_{i+1}$。\n    c. 施加边界条件：$T_{\\text{new},0} = 0$ 和 $T_{\\text{new},N-1} = 0$。\n    d. 为下一次迭代更新当前温度数组：$T \\leftarrow T_{\\text{new}}$。\n7.  循环完成后，数组 $T$ 包含 $t = t_{\\mathrm{end}}$ 时的数值解。指定节点的数值解温度为 $T_{\\mathrm{num}} = T_{i_{\\star}}$。\n8.  计算同一位置和时间的解析解。该位置为 $x_{\\star} = i_{\\star} \\Delta x$。\n    $$\n    T_{\\mathrm{ana}} = T_{\\mathrm{amp}} \\sin\\left(\\frac{\\pi x_{\\star}}{L}\\right) \\exp\\left(-\\alpha \\left(\\frac{\\pi}{L}\\right)^2 t_{\\mathrm{end}}\\right)\n    $$\n9.  计算并记录绝对误差 $|T_{\\mathrm{num}} - T_{\\mathrm{ana}}|$。\n\n对所有四个测试用例重复此过程，以生成最终结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a 1D transient heat conduction simulator using the FTCS scheme\n    and computes the error against the analytical solution for given test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'L': 1.0, 'alpha': 1.0e-4, 'T_amp': 10.0, 'N': 51, 'r': 0.4, 't_end': 160.0, 'i_star': 25},\n        # Case 2\n        {'L': 1.0, 'alpha': 1.0e-4, 'T_amp': 10.0, 'N': 41, 'r': 0.5, 't_end': 31.25, 'i_star': 20},\n        # Case 3\n        {'L': 1.0, 'alpha': 1.0e-4, 'T_amp': 5.0, 'N': 11, 'r': 0.2, 't_end': 200.0, 'i_star': 5},\n        # Case 4\n        {'L': 1.0, 'alpha': 1.0e-4, 'T_amp': 10.0, 'N': 101, 'r': 0.1, 't_end': 10.0, 'i_star': 0},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract parameters\n        L = case['L']\n        alpha = case['alpha']\n        T_amp = case['T_amp']\n        N = case['N']\n        r = case['r']\n        t_end = case['t_end']\n        i_star = case['i_star']\n\n        # Discretization parameters\n        dx = L / (N - 1)\n        dt = r * dx**2 / alpha\n        \n        # Ensure n_steps is an integer as per problem statement\n        n_steps = int(round(t_end / dt))\n\n        # Spatial grid\n        x = np.linspace(0, L, N)\n\n        # Initialize temperature array based on the initial condition\n        T = T_amp * np.sin(np.pi * x / L)\n\n        # Time-stepping loop\n        for _ in range(n_steps):\n            # Store the current temperature profile\n            T_old = T.copy()\n            # Update interior nodes using the FTCS formula\n            for i in range(1, N - 1):\n                T[i] = T_old[i] + r * (T_old[i+1] - 2*T_old[i] + T_old[i-1])\n            # The boundary conditions T[0]=0 and T[N-1]=0 are enforced implicitly\n            # by the loop range and because the initial values at boundaries\n            # are already 0 from the sin function. A more robust implementation\n            # would explicitly set them after each update.\n            T[0] = 0.0\n            T[N-1] = 0.0\n\n        # Numerical solution at the specified node and time\n        T_num = T[i_star]\n\n        # Analytical solution at the same position and time\n        x_star = i_star * dx\n        decay_term = -alpha * (np.pi / L)**2 * t_end\n        T_ana = T_amp * np.sin(np.pi * x_star / L) * np.exp(decay_term)\n\n        # Compute the absolute error\n        error = abs(T_num - T_ana)\n        results.append(error)\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2483476"}, {"introduction": "在实现了基本的显式求解器之后，我们现在来探讨其在面对“刚性”问题——即包含极大不同物理尺度的问题——时的局限性。本实践提供了一个关于复合杆的思想实验，其材料热扩散率存在1000倍的差异，这种情况对显式方法施加了严格的稳定性约束。您将分析显式和隐式方案的计算成本，从而定量地揭示显式步长的简便性与隐式方法处理刚性系统时的高效性之间的关键权衡 [@problem_id:2390373]。", "problem": "考虑在占据区间 $[0,L]$ 的复合杆中的一维热传导，其材料界面位于 $x=L/2$。令 $T(x,t)$ 表示温度。其控制方程为具有分段常数热扩散系数 $ \\alpha(x) $ 的线性热方程，\n$$\n\\frac{\\partial T}{\\partial t}(x,t) = \\alpha(x)\\,\\frac{\\partial^2 T}{\\partial x^2}(x,t),\\quad x\\in(0,L),\\ t>0,\n$$\n该方程满足齐次狄利克雷边界条件 $T(0,t)=0$ 和 $T(L,t)=0$（对所有 $t\\ge 0$），以及一个有界且与边界条件相容的任意初始条件 $T(x,0)=T_0(x)$。热扩散系数为分段常数：\n$$\n\\alpha(x)=\\begin{cases}\n\\alpha_1,& 0\\le x < L/2,\\\\\n\\alpha_2,& L/2 \\le x \\le L,\n\\end{cases}\n$$\n两种材料的热导率对比度为 $1000\\times$，而体积热容相同；通过取 $\\alpha_2 = 1000\\,\\alpha_1$ 对此进行建模。\n\n使用包含端点的 $N$ 个点的均匀网格对空间进行离散化，网格间距为 $h=L/(N-1)$。令 $M=N-2$ 表示内部点的数量。考虑两种时间离散化方法：\n- 将显式前向欧拉法应用于由均匀网格上 $\\partial^2 T/\\partial x^2$ 的二阶中心有限差分近似所形成的半离散系统。\n- 将隐式后向欧拉法应用于相同的空间离散化，在每个时间步中需求解一个大小为 $M\\times M$ 的对称三对角线性系统。\n\n对于显式方法，使用保证该均匀网格上离散化线性稳定的最大时间步长。对于存在空间变化的分段常数值 $\\alpha(x)$ 的情况，采用保守估计：\n$$\n\\Delta t_{\\mathrm{exp},\\max} = \\frac{h^2}{2\\,\\max(\\alpha_1,\\alpha_2)}.\n$$\n对于隐式方法，假设其无条件线性稳定，并将每个时间步的计算成本定义为通过最优直接法求解三对角线性系统所需的浮点加法和乘法次数。使用以下运算计数模型：\n- 对于显式更新，每个内部网格点在每个时间步精确计数为 $6$ 次浮点运算，因此一个显式步的成本为 $6\\,M$ 次运算。忽略所有一次性预计算。\n- 对于隐式步，求解三对角系统时，每个内部网格点在每个步长中精确计数为 $8$ 次浮点运算，因此一个隐式步的成本为 $8\\,M$ 次运算。忽略组装和任何其他开销。\n\n给定最终模拟时间 $T_{\\mathrm{final}}$，为每个参数集定义以下待计算的量：\n1. 最大稳定显式时间步长 $\\Delta t_{\\mathrm{exp},\\max}$（单位：秒），如上定义。\n2. 使用 $\\Delta t_{\\mathrm{exp},\\max}$ 达到 $T_{\\mathrm{final}}$ 所需的最小显式时间步数，$N_{\\mathrm{exp}}=\\lceil T_{\\mathrm{final}}/\\Delta t_{\\mathrm{exp},\\max}\\rceil$。\n3. 使用 $\\Delta t_{\\mathrm{exp},\\max}$ 达到 $T_{\\mathrm{final}}$ 的总显式成本，$C_{\\mathrm{exp}}=6\\,M\\,N_{\\mathrm{exp}}$。\n4. 每时间步的隐式成本，$C_{\\mathrm{imp,step}}=8\\,M$。\n5. 如果使用与显式方法相同的步数，达到 $T_{\\mathrm{final}}$ 的总隐式成本，$C_{\\mathrm{imp,same}}=8\\,M\\,N_{\\mathrm{exp}}$。\n6. 如果在单个步长内推进整个时间区间 $[0,T_{\\mathrm{final}}]$ 的最小隐式总成本，$C_{\\mathrm{imp,min}}=8\\,M$。\n\n所有物理单位必须作如下解释：长度单位为米，时间单位为秒，热扩散系数单位为 $\\mathrm{m}^2/\\mathrm{s}$。所有成本都是浮点加法或乘法的纯计数值，并且是无单位整数。所有角度量均与本问题无关。任何比率都必须以十进制数报告。\n\n测试套件。使用以下三个参数集，每个参数集指定为 $(L,N,\\alpha_1,\\alpha_2,T_{\\mathrm{final}})$：\n- 测试 $1$（双材料对比度案例）：$(L,N,\\alpha_1,\\alpha_2,T_{\\mathrm{final}}) = (1.0,\\ 1001,\\ 10^{-6},\\ 10^{-3},\\ 0.5)$。\n- 测试 $2$（均匀低扩散率案例）：$(L,N,\\alpha_1,\\alpha_2,T_{\\mathrm{final}}) = (1.0,\\ 201,\\ 10^{-6},\\ 10^{-6},\\ 0.1)$。\n- 测试 $3$（高对比度细网格案例）：$(L,N,\\alpha_1,\\alpha_2,T_{\\mathrm{final}}) = (0.2,\\ 2001,\\ 10^{-5},\\ 10^{-2},\\ 0.01)$。\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。对于每个测试案例，按顺序输出列表 $[\\Delta t_{\\mathrm{exp},\\max}, N_{\\mathrm{exp}}, C_{\\mathrm{exp}}, C_{\\mathrm{imp,step}}, C_{\\mathrm{imp,same}}, C_{\\mathrm{imp,min}}]$。将三个测试案例的列表聚合为单个列表，不含任何空格，例如 `[[\\cdot],[\\cdot],[\\cdot]]`。所有时间步长值必须以秒为单位，所有成本和计数必须是整数。不应打印任何其他文本。", "solution": "该问题陈述已经过严格验证，并被确定为有效。这是一个在偏微分方程数值分析领域内的、基于已确立的科学和数学原理的良构计算练习。所有必要的参数和定义都已提供，任务没有歧义、矛盾或事实错误。因此，我们可以着手求解。\n\n该问题要求计算与具有分段常数热扩散系数的一维热方程的显式和隐式时间步进格式的计算成本及稳定性相关的若干量。控制方程由下式给出\n$$\n\\frac{\\partial T}{\\partial t}(x,t) = \\alpha(x)\\,\\frac{\\partial^2 T}{\\partial x^2}(x,t)\n$$\n定义在空间域 $x \\in [0,L]$ 上，并具有齐次狄利克雷边界条件。热扩散系数 $\\alpha(x)$ 是分段常数。\n\n求解方法包括对每个由元组 $(L, N, \\alpha_1, \\alpha_2, T_{\\mathrm{final}})$ 指定的测试案例，直接应用所提供的公式。计算步骤如下：\n\n1.  **离散化参数**：长度为 $L$ 的空间域使用一个包含 $N$ 个点的均匀网格进行离散化。网格间距 $h$ 是相邻点之间的距离，计算公式为 $h = L / (N-1)$。在齐次狄利克雷边界条件下，内部网格点的数量 $M$ 为 $M = N-2$。\n\n2.  **最大显式时间步长 ($\\Delta t_{\\mathrm{exp},\\max}$)**：应用于热方程的中心有限差分空间离散化的前向欧拉格式是条件稳定的。其稳定性由柯朗-弗里德里希斯-列维（CFL）条件决定。对于一维热方程，该条件为 $\\alpha \\Delta t / h^2 \\le 1/2$。在存在空间变化的扩散系数的情况下，保守的稳定性判据使用域上的最大扩散系数值。因此，最大稳定时间步长由以下公式给出：\n    $$\n    \\Delta t_{\\mathrm{exp},\\max} = \\frac{h^2}{2\\,\\max(\\alpha_1, \\alpha_2)}\n    $$\n    该值表示能保证显式数值解不出现无界增长的最大时间步长。\n\n3.  **显式步数 ($N_{\\mathrm{exp}}$)**：为使用最大稳定时间步长模拟到最终时间 $T_{\\mathrm{final}}$，所需的步数 $N_{\\mathrm{exp}}$ 通过将总模拟时间除以步长并对结果取上整来确定。这确保了模拟时间达到或超过 $T_{\\mathrm{final}}$。\n    $$\n    N_{\\mathrm{exp}} = \\left\\lceil \\frac{T_{\\mathrm{final}}}{\\Delta t_{\\mathrm{exp},\\max}} \\right\\rceil\n    $$\n\n4.  **总显式成本 ($C_{\\mathrm{exp}}$)**：计算成本被建模为浮点运算的计数。给定显式方法每时间步的成本为 $6M$ 次运算，达到 $T_{\\mathrm{final}}$ 的总成本是每步成本与步数的乘积：\n    $$\n    C_{\\mathrm{exp}} = 6 \\cdot M \\cdot N_{\\mathrm{exp}}\n    $$\n\n5.  **隐式方法成本**：后向欧拉法是无条件稳定的，这意味着时间步长不受稳定性约束，而是受精度考量约束。\n    - 每步成本 $C_{\\mathrm{imp,step}}$ 给定为 $8M$。这反映了在每个隐式步中求解 $M \\times M$ 对称三对角线性系统（例如，使用托马斯算法）的成本。\n      $$\n      C_{\\mathrm{imp,step}} = 8 \\cdot M\n      $$\n    - 为了与显式方法进行直接比较，使用与显式方法*相同步数* $N_{\\mathrm{exp}}$ 的隐式方法的总成本计算如下：\n      $$\n      C_{\\mathrm{imp,same}} = 8 \\cdot M \\cdot N_{\\mathrm{exp}}\n      $$\n    - 隐式方法的理论最小成本 $C_{\\mathrm{imp,min}}$ 对应于在单个时间步内将解从 $t=0$ 推进到 $t=T_{\\mathrm{final}}$。虽然这会产生非常大的时间误差，但它代表了计算成本的下限。\n      $$\n      C_{\\mathrm{imp,min}} = 8 \\cdot M\n      $$\n\n对问题陈述中提供的三个测试案例中的每一个都执行这些计算。然后将结果聚合，并按要求精确格式化。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational engineering problem for three test cases,\n    calculating stability and cost metrics for explicit and implicit schemes\n    for the 1D heat equation.\n    \"\"\"\n    # Test cases defined as (L, N, alpha1, alpha2, T_final)\n    test_cases = [\n        (1.0, 1001, 1e-6, 1e-3, 0.5),\n        (1.0, 201, 1e-6, 1e-6, 0.1),\n        (0.2, 2001, 1e-5, 1e-2, 0.01)\n    ]\n\n    all_results_str = []\n\n    for case in test_cases:\n        L, N, alpha1, alpha2, T_final = case\n\n        # Step 1: Calculate discretization parameters\n        h = L / (N - 1)\n        M = N - 2\n\n        # Step 2: Calculate maximum stable explicit time step\n        max_alpha = max(alpha1, alpha2)\n        dt_exp_max = h**2 / (2 * max_alpha)\n\n        # Step 3: Calculate the minimum number of explicit steps\n        # The result must be an integer. np.ceil returns a float.\n        N_exp = int(np.ceil(T_final / dt_exp_max))\n\n        # Step 4: Calculate total explicit cost\n        C_exp = 6 * M * N_exp\n\n        # Step 5: Calculate implicit method costs\n        C_imp_step = 8 * M\n        C_imp_same = 8 * M * N_exp\n        C_imp_min = 8 * M\n\n        # Assemble the list of results for the current test case\n        case_results = [\n            dt_exp_max,\n            N_exp,\n            C_exp,\n            C_imp_step,\n            C_imp_same,\n            C_imp_min\n        ]\n\n        # Format the list into a string representation with no spaces\n        case_str = f\"[{','.join(map(str, case_results))}]\"\n        all_results_str.append(case_str)\n\n    # Aggregate the string representations of each test case's results\n    # into a final string representing a list of lists, with no spaces.\n    final_output_str = f\"[{','.join(all_results_str)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "2390373"}, {"introduction": "我们的最终实践将挑战升级到二维，并深入高性能计算的世界，在这里，算法的选择与硬件架构紧密相连。您将构建并应用一个性能模型，为一个大规模二维传热问题，比较GPU并行化的显式求解器与基于CPU的隐式求解器。此练习将帮助您理解算法复杂度、内存带宽和计算吞吐量等因素如何决定现代科学计算中最有效的求解策略 [@problem_id:2390421]。", "problem": "考虑一个定义在矩形域上的二维热传导方程，这是一种典型的抛物型偏微分方程 (PDE)，其边界条件为齐次 Dirichlet 边界条件。设区域为 $[0,L_x]\\times[0,L_y]$，热扩散系数为 $\\alpha$ (单位为 $\\mathrm{m}^2/\\mathrm{s}$)，最终物理时间为 $T$ (单位为 $\\mathrm{s}$)。场变量 $u(x,y,t)$ 满足方程 $u_t=\\alpha(u_{xx}+u_{yy})$，并且对于所有 $t\\in[0,T]$，在边界上 $u=0$。使用均匀张量积网格对内部区域进行离散化，该网格在 $x$ 和 $y$ 方向上分别有 $N_x$ 和 $N_y$ 个内部点，并使用二阶中心差分来近似空间导数。所得的半离散系统可采用显式前向 Euler 方法或隐式后向 Euler 方法进行时间推进。您必须构建一个有理论依据的性能模型，用以在特定的硬件假设下预测两种方法的总墙上时钟时间，并对它们进行比较。\n\n基本和建模假设：\n- 对于显式前向 Euler 格式，在间距为 $h_x=L_x/(N_x+1)$ 和 $h_y=L_y/(N_y+1)$ 的均匀网格上应用五点差分格式时，其 Courant–Friedrichs–Lewy (CFL) 稳定性条件为\n$$\n\\Delta t_{\\text{CFL}} \\le \\frac{1}{2\\,\\alpha\\left(\\frac{1}{h_x^2}+\\frac{1}{h_y^2}\\right)}.\n$$\n在实践中，使用此上限的一个保守系数 $\\theta\\in(0,1)$：$\\Delta t_{\\text{exp}}=\\theta\\,\\Delta t_{\\text{CFL}}$，以及 $n_{\\text{exp}}=\\left\\lceil T/\\Delta t_{\\text{exp}}\\right\\rceil$ 个显式步。\n- 对于隐式后向 Euler 格式，其无条件稳定性允许使用更大的时间步长，但精度要求仍然会限制步长。为了参数化可接受的精度，假设对于给定的乘数 $m\\ge 1$，有 $\\Delta t_{\\text{imp}} = m\\,\\Delta t_{\\text{exp}}$，以及 $n_{\\text{imp}}=\\left\\lceil T/\\Delta t_{\\text{imp}}\\right\\rceil$ 个隐式步。如果时间步长固定，线性系统矩阵不随时间改变，其分解结果可以在不同时间步之间重用。\n- 对于显式方法的图形处理器 (GPU) 性能，使用 roofline 模型。假设为双精度，字长为 $b=8$ 字节。将每个单元、每一步的浮点运算次数建模为 $c_{\\text{exp,flop}}$ 次浮点运算 (flops)，将每个单元、每一步的内存流量建模为 $c_{\\text{exp,bytes}}$ 字节。设 GPU 峰值浮点吞吐率为 $F_{\\text{GPU}}$ (单位 flops/s)，GPU 可持续内存带宽为 $B_{\\text{GPU}}$ (单位 bytes/s)，则每步所需时间为\n$$\nt_{\\text{exp,step}}=\\max\\left(\\frac{N\\,c_{\\text{exp,flop}}}{F_{\\text{GPU}}},\\;\\frac{N\\,c_{\\text{exp,bytes}}}{B_{\\text{GPU}}}\\right),\n$$\n其中 $N=N_x N_y$ 是内部未知数的数量。总显式时间为 $t_{\\text{exp}}=n_{\\text{exp}}\\,t_{\\text{exp,step}}$。\n- 对于在中央处理器 (CPU) 上使用基于 LU (Lower–Upper) 分解和减少填充排序的稀疏直接求解器求解隐式方法，假设在 $N_x\\times N_y$ 网格上的二维五点差分格式具有以下经过充分测试的复杂度缩放规律：一次性分解的成本为\n$$\n\\text{flops}_{\\text{fac}} = C_{\\text{fac}}\\,N^{3/2},\n$$\n以及每次求解右端项的三角系统成本为\n$$\n\\text{flops}_{\\text{solve}} = C_{\\text{solve}}\\,N\\,\\log_2 N.\n$$\n设 CPU 峰值浮点吞吐率为 $F_{\\text{CPU}}$ (单位 flops/s)，则总隐式时间为\n$$\nt_{\\text{imp}}=\\frac{\\text{flops}_{\\text{fac}}}{F_{\\text{CPU}}}+n_{\\text{imp}}\\,\\frac{\\text{flops}_{\\text{solve}}}{F_{\\text{CPU}}}.\n$$\n\n在所有算例中，使用以下固定的建模常数，以避免底层核函数细节带来的歧义：\n- $c_{\\text{exp,flop}}=13$,\n- $c_{\\text{exp,bytes}}=6\\,b=48$ 字节,\n- $C_{\\text{fac}}=30$,\n- $C_{\\text{solve}}=10$.\n\n您的任务：\n- 实现一个程序，针对下面指定的每个测试算例，计算 $t_{\\text{exp}}$ 和 $t_{\\text{imp}}$ (单位为秒)，然后输出比率 $r=t_{\\text{exp}}/t_{\\text{imp}}$ (以浮点数形式)。比率 $r<1$ 表示 GPU 并行的显式方法更快；比率 $r>1$ 表示基于 CPU 的隐式方法更快。\n- 程序必须将测试套件硬编码，使用上述公式执行所有计算，并生成单行输出，其中包含按测试算例顺序排列的比率列表。\n- 所有时间在内部以秒表示；输出的比率是无量纲的。在最终输出中将每个比率四舍五入到小数点后 6 位。\n\n测试套件 (每个项目符号代表一组完整的参数)：\n- 算例 A (大网格，中等扩散系数，预计 GPU 为内存受限)：$N_x=2048$, $N_y=2048$, $L_x=1$, $L_y=1$, $\\alpha=1\\times 10^{-4}$, $T=1$, $\\theta=0.9$, $m=10$, $F_{\\text{GPU}}=1\\times 10^{12}$, $B_{\\text{GPU}}=6\\times 10^{11}$, $F_{\\text{CPU}}=2\\times 10^{11}$。\n- 算例 B (非常大的网格，较高扩散系数，预计隐式方法有优势)：$N_x=4096$, $N_y=4096$, $L_x=1$, $L_y=1$, $\\alpha=5\\times 10^{-4}$, $T=0.5$, $\\theta=0.9$, $m=100$, $F_{\\text{GPU}}=1\\times 10^{12}$, $B_{\\text{GPU}}=6\\times 10^{11}$, $F_{\\text{CPU}}=2\\times 10^{11}$。\n- 算例 C (小网格，分解开销在隐式方法中占主导)：$N_x=128$, $N_y=128$, $L_x=1$, $L_y=1$, $\\alpha=1\\times 10^{-4}$, $T=0.1$, $\\theta=0.9$, $m=50$, $F_{\\text{GPU}}=5\\times 10^{11}$, $B_{\\text{GPU}}=2\\times 10^{11}$, $F_{\\text{CPU}}=2\\times 10^{11}$。\n- 算例 D (计算受限的 GPU 配置)：$N_x=1024$, $N_y=1024$, $L_x=1$, $L_y=1$, $\\alpha=2\\times 10^{-4}$, $T=0.2$, $\\theta=0.9$, $m=20$, $F_{\\text{GPU}}=8\\times 10^{10}$, $B_{\\text{GPU}}=6\\times 10^{11}$, $F_{\\text{CPU}}=1.5\\times 10^{11}$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 `[0.123456,1.234567,0.000100,9.876543]`，按顺序对应于算例 A、B、C 和 D。", "solution": "该问题要求构建并评估一个性能模型，用以比较求解定义在矩形域 $\\Omega = [0, L_x] \\times [0, L_y]$ 上的二维热传导方程 $u_t = \\alpha(u_{xx} + u_{yy})$ 的两种不同数值方法。第一种方法是在图形处理器 (GPU) 上并行的显式前向 Euler 时间积分格式。第二种是在中央处理器 (CPU) 上使用稀疏直接求解器求解的隐式后向 Euler 格式。我们将计算每种方法的总墙上时钟时间（分别表示为 $t_{\\text{exp}}$ 和 $t_{\\text{imp}}$），并针对几个测试算例确定它们的比率 $r = t_{\\text{exp}}/t_{\\text{imp}}$。所有的数学实体，包括数值，都按要求使用 LaTeX 渲染。\n\n空间域使用均匀网格进行离散化，在相应维度上分别有 $N_x$ 和 $N_y$ 个内部点。未知数的总数为 $N = N_x N_y$。网格间距为 $h_x = L_x / (N_x + 1)$ 和 $h_y = L_y / (N_y + 1)$。\n\n首先，我们分析显式方法。前向 Euler 格式受到严格的稳定性约束。对于五点有限差分格式，这个 Courant–Friedrichs–Lewy (CFL) 条件规定了最大允许时间步长：\n$$\n\\Delta t_{\\text{CFL}} \\le \\frac{1}{2\\,\\alpha\\left(\\frac{1}{h_x^2}+\\frac{1}{h_y^2}\\right)}\n$$\n我们使用一个保守的时间步长 $\\Delta t_{\\text{exp}} = \\theta\\,\\Delta t_{\\text{CFL}}$，其中 $\\theta \\in (0,1)$ 是一个安全因子。为达到最终时间 $T$，所需的步数为 $n_{\\text{exp}} = \\lceil T/\\Delta t_{\\text{exp}}\\rceil$。\nGPU 实现的性能由 roofline 模型决定。每步的时间 $t_{\\text{exp,step}}$ 是计算限制的时间和内存带宽限制的时间中的最大值。\n$$\nt_{\\text{exp,step}} = \\max\\left(t_{\\text{comp}}, t_{\\text{mem}}\\right) = \\max\\left(\\frac{N\\,c_{\\text{exp,flop}}}{F_{\\text{GPU}}}, \\frac{N\\,c_{\\text{exp,bytes}}}{B_{\\text{GPU}}}\\right)\n$$\n此处，$c_{\\text{exp,flop}} = 13$ 是每步每个网格点的浮点运算次数，$c_{\\text{exp,bytes}} = 48$ 是每步每个网格点传输的字节数。$F_{\\text{GPU}}$ 是 GPU 的峰值浮点吞吐率，$B_{\\text{GPU}}$ 是其可持续内存带宽。显式方法的总时间是步数与每步时间的乘积：\n$$\nt_{\\text{exp}} = n_{\\text{exp}} \\cdot t_{\\text{exp,step}}\n$$\n\n接下来，我们分析隐式方法。后向 Euler 格式是无条件稳定的，允许使用更大的时间步长。这个时间步长相对于显式方法的时间步长进行参数化：$\\Delta t_{\\text{imp}} = m\\,\\Delta t_{\\text{exp}}$，其中 $m \\ge 1$。所需的步数为 $n_{\\text{imp}} = \\lceil T/\\Delta t_{\\text{imp}}\\rceil$。每个时间步都需要求解一个大型稀疏线性系统。稀疏直接求解器对系统矩阵执行一次性的 LU 分解，然后在每个时间步进行一次三角求解。其计算成本由下式给出：\n$$\n\\text{flops}_{\\text{fac}} = C_{\\text{fac}}\\,N^{3/2} \\quad \\text{和} \\quad \\text{flops}_{\\text{solve}} = C_{\\text{solve}}\\,N\\,\\log_2 N\n$$\n其中常数 $C_{\\text{fac}} = 30$ 和 $C_{\\text{solve}} = 10$。在峰值吞吐率为 $F_{\\text{CPU}}$ 的 CPU 上，隐式方法的总时间是分解时间与所有求解总时间的和：\n$$\nt_{\\text{imp}} = \\frac{\\text{flops}_{\\text{fac}}}{F_{\\text{CPU}}} + n_{\\text{imp}}\\,\\frac{\\text{flops}_{\\text{solve}}}{F_{\\text{CPU}}}\n$$\n\n在建立了 $t_{\\text{exp}}$ 和 $t_{\\text{imp}}$ 的模型后，我们接着评估四个指定的测试算例。\n\n**算例 A：** $N_x=2048$, $N_y=2048$, $L_x=1$, $L_y=1$, $\\alpha=1 \\times 10^{-4}$, $T=1$, $\\theta=0.9$, $m=10$, $F_{\\text{GPU}}=1 \\times 10^{12}$, $B_{\\text{GPU}}=6 \\times 10^{11}$, $F_{\\text{CPU}}=2 \\times 10^{11}$。\n- 网格：$N = 4194304$, $h_x = h_y = 1/2049$。\n- 显式法：$\\Delta t_{\\text{exp}} \\approx 5.359 \\times 10^{-4}\\,\\text{s}$，$n_{\\text{exp}} = 1866$。该核函数是内存受限的，$t_{\\text{exp,step}} \\approx 3.355 \\times 10^{-4}\\,\\text{s}$。因此，$t_{\\text{exp}} \\approx 0.626155\\,\\text{s}$。\n- 隐式法：$\\Delta t_{\\text{imp}} \\approx 5.359 \\times 10^{-3}\\,\\text{s}$，$n_{\\text{imp}} = 187$。分解时间为 $t_{\\text{fac}} \\approx 1.288490\\,\\text{s}$，总求解时间为 $t_{\\text{solves}} \\approx 0.862768\\,\\text{s}$。因此，$t_{\\text{imp}} \\approx 2.151259\\,\\text{s}$。\n- 比率：$r = t_{\\text{exp}}/t_{\\text{imp}} \\approx 0.291062$。\n\n**算例 B：** $N_x=4096$, $N_y=4096$, $L_x=1$, $L_y=1$, $\\alpha=5 \\times 10^{-4}$, $T=0.5$, $\\theta=0.9$, $m=100$, $F_{\\text{GPU}}=1 \\times 10^{12}$, $B_{\\text{GPU}}=6 \\times 10^{11}$, $F_{\\text{CPU}}=2 \\times 10^{11}$。\n- 网格：$N = 16777216$, $h_x = h_y = 1/4097$。\n- 显式法：$\\Delta t_{\\text{exp}} \\approx 2.681 \\times 10^{-5}\\,\\text{s}$，$n_{\\text{exp}} = 18651$。该核函数是内存受限的，$t_{\\text{exp,step}} \\approx 1.342 \\times 10^{-3}\\,\\text{s}$。因此，$t_{\\text{exp}} \\approx 25.034000\\,\\text{s}$。\n- 隐式法：$\\Delta t_{\\text{imp}} \\approx 2.681 \\times 10^{-3}\\,\\text{s}$，$n_{\\text{imp}} = 187$。分解时间为 $t_{\\text{fac}} \\approx 10.307921\\,\\text{s}$，总求解时间为 $t_{\\text{solves}} \\approx 3.764811\\,\\text{s}$。因此，$t_{\\text{imp}} \\approx 14.072732\\,\\text{s}$。\n- 比率：$r = t_{\\text{exp}}/t_{\\text{imp}} \\approx 1.779031$。\n\n**算例 C：** $N_x=128$, $N_y=128$, $L_x=1$, $L_y=1$, $\\alpha=1 \\times 10^{-4}$, $T=0.1$, $\\theta=0.9$, $m=50$, $F_{\\text{GPU}}=5 \\times 10^{11}$, $B_{\\text{GPU}}=2 \\times 10^{11}$, $F_{\\text{CPU}}=2 \\times 10^{11}$。\n- 网格：$N = 16384$, $h_x = h_y = 1/129$。\n- 显式法：$\\Delta t_{\\text{exp}} \\approx 0.13521\\,\\text{s}$，$n_{\\text{exp}} = 1$。该核函数是内存受限的，$t_{\\text{exp,step}} \\approx 3.932 \\times 10^{-6}\\,\\text{s}$。因此，$t_{\\text{exp}} \\approx 3.932 \\times 10^{-6}\\,\\text{s}$。\n- 隐式法：$\\Delta t_{\\text{imp}} \\approx 6.7605\\,\\text{s}$，$n_{\\text{imp}} = 1$。分解时间为 $t_{\\text{fac}} \\approx 3.146 \\times 10^{-4}\\,\\text{s}$，总求解时间为 $t_{\\text{solves}} \\approx 1.147 \\times 10^{-5}\\,\\text{s}$。因此，$t_{\\text{imp}} \\approx 3.260 \\times 10^{-4}\\,\\text{s}$。\n- 比率：$r = t_{\\text{exp}}/t_{\\text{imp}} \\approx 0.012060$。\n\n**算例 D：** $N_x=1024$, $N_y=1024$, $L_x=1$, $L_y=1$, $\\alpha=2 \\times 10^{-4}$, $T=0.2$, $\\theta=0.9$, $m=20$, $F_{\\text{GPU}}=8 \\times 10^{10}$, $B_{\\text{GPU}}=6 \\times 10^{11}$, $F_{\\text{CPU}}=1.5 \\times 10^{11}$。\n- 网格：$N = 1048576$, $h_x = h_y = 1/1025$。\n- 显式法：$\\Delta t_{\\text{exp}} \\approx 1.071 \\times 10^{-3}\\,\\text{s}$，$n_{\\text{exp}} = 187$。该核函数是计算受限的，$t_{\\text{exp,step}} \\approx 1.704 \\times 10^{-4}\\,\\text{s}$。因此，$t_{\\text{exp}} \\approx 0.031859\\,\\text{s}$。\n- 隐式法：$\\Delta t_{\\text{imp}} \\approx 0.02142\\,\\text{s}$，$n_{\\text{imp}} = 10$。分解时间为 $t_{\\text{fac}} \\approx 0.214748\\,\\text{s}$，总求解时间为 $t_{\\text{solves}} \\approx 0.013981\\,\\text{s}$。因此，$t_{\\text{imp}} \\approx 0.228729\\,\\text{s}$。\n- 比率：$r = t_{\\text{exp}}/t_{\\text{imp}} \\approx 0.139281$。\n\n最终计算出的比率为 $[0.291062, 1.779031, 0.012060, 0.139281]$。", "answer": "```python\nimport math\n\ndef solve():\n    \"\"\"\n    Computes performance ratios for explicit vs. implicit solvers\n    for the 2D heat equation based on a given performance model.\n    \"\"\"\n\n    # Fixed modeling constants\n    C_EXP_FLOP = 13\n    C_EXP_BYTES = 48  # 6 * b, where b=8 for double precision\n    C_FAC = 30\n    C_SOLVE = 10\n\n    test_cases = [\n        # Case A: large grid, moderate diffusivity, memory-bound GPU expected\n        {\"name\": \"A\", \"Nx\": 2048, \"Ny\": 2048, \"Lx\": 1.0, \"Ly\": 1.0, \n         \"alpha\": 1e-4, \"T\": 1.0, \"theta\": 0.9, \"m\": 10, \n         \"F_GPU\": 1e12, \"B_GPU\": 6e11, \"F_CPU\": 2e11},\n        \n        # Case B: very large grid, higher diffusivity, implicit advantage expected\n        {\"name\": \"B\", \"Nx\": 4096, \"Ny\": 4096, \"Lx\": 1.0, \"Ly\": 1.0, \n         \"alpha\": 5e-4, \"T\": 0.5, \"theta\": 0.9, \"m\": 100, \n         \"F_GPU\": 1e12, \"B_GPU\": 6e11, \"F_CPU\": 2e11},\n\n        # Case C: small grid, factorization overhead dominates implicit\n        {\"name\": \"C\", \"Nx\": 128, \"Ny\": 128, \"Lx\": 1.0, \"Ly\": 1.0, \n         \"alpha\": 1e-4, \"T\": 0.1, \"theta\": 0.9, \"m\": 50, \n         \"F_GPU\": 5e11, \"B_GPU\": 2e11, \"F_CPU\": 2e11},\n\n        # Case D: compute-bound GPU configuration\n        {\"name\": \"D\", \"Nx\": 1024, \"Ny\": 1024, \"Lx\": 1.0, \"Ly\": 1.0, \n         \"alpha\": 2e-4, \"T\": 0.2, \"theta\": 0.9, \"m\": 20, \n         \"F_GPU\": 8e10, \"B_GPU\": 6e11, \"F_CPU\": 1.5e11},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Extract parameters\n        Nx, Ny = case[\"Nx\"], case[\"Ny\"]\n        Lx, Ly = case[\"Lx\"], case[\"Ly\"]\n        alpha, T = case[\"alpha\"], case[\"T\"]\n        theta, m = case[\"theta\"], case[\"m\"]\n        F_GPU, B_GPU, F_CPU = case[\"F_GPU\"], case[\"B_GPU\"], case[\"F_CPU\"]\n\n        # Common grid parameters\n        N = Nx * Ny\n        hx = Lx / (Nx + 1)\n        hy = Ly / (Ny + 1)\n\n        # --- Explicit Method (GPU) ---\n        dt_cfl = 1.0 / (2.0 * alpha * (1.0/hx**2 + 1.0/hy**2))\n        dt_exp = theta * dt_cfl\n        n_exp = math.ceil(T / dt_exp)\n\n        # Roofline model for per-step time\n        t_comp_per_step = (N * C_EXP_FLOP) / F_GPU\n        t_mem_per_step = (N * C_EXP_BYTES) / B_GPU\n        t_exp_step = max(t_comp_per_step, t_mem_per_step)\n        \n        t_exp = n_exp * t_exp_step\n\n        # --- Implicit Method (CPU) ---\n        dt_imp = m * dt_exp\n        n_imp = math.ceil(T / dt_imp)\n\n        # Factorization cost. Since Nx=Ny in all cases, N is a perfect square.\n        # N^(3/2) = (Nx^2)^(3/2) = Nx^3, which avoids floating-point exponentiation.\n        if Nx == Ny:\n            flops_fac = C_FAC * (Nx**3)\n        else: # General case, not present in test suite\n            flops_fac = C_FAC * (N**1.5)\n        \n        t_fac = flops_fac / F_CPU\n        \n        # Solve cost\n        flops_solve = C_SOLVE * N * math.log2(N)\n        t_solves_total = n_imp * (flops_solve / F_CPU)\n        \n        t_imp = t_fac + t_solves_total\n\n        # Ratio of explicit to implicit time\n        ratio = t_exp / t_imp\n        results.append(ratio)\n\n    # Format the final output string with rounding to 6 decimal places.\n    output_str = \",\".join([f\"{r:.6f}\" for r in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "2390421"}]}