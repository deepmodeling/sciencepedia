{"hands_on_practices": [{"introduction": "我们将从一个典型的双曲型问题——线性对流方程开始。这个练习旨在让你亲手体验在使用显式方法求解这类方程时最关键的概念：Courant-Friedrichs-Lewy (CFL) 条件。通过亲手编码并观察当 CFL 数 $\\nu = c \\Delta t / \\Delta x$ 超过稳定性极限时，数值解如何迅速崩溃，你将深刻理解为什么它被誉为显式双曲型求解器的“第一法则”[@problem_id:2388289]。", "problem": "考虑在周期性域 $x \\in [0,1]$ 上的线性平流方程 $u_t + c\\,u_x = 0$，其周期为 $1$，即对所有 $t \\ge 0$ 都有 $u(0,t)=u(1,t)$。初始条件为 $u(x,0) = \\sin(2\\pi x)$。设空间网格是均匀的，有 $N$ 个点 $x_i = i\\,\\Delta x$（$i=0,1,\\dots,N-1$），其中 $\\Delta x = 1/N$。设时间层为 $t^n = n\\,\\Delta t$（$n=0,1,2,\\dots$）。定义库兰特数 (Courant number) $\\nu = c\\,\\Delta t/\\Delta x$。使用如下给出的显式一阶迎风有限差分格式来近似求解：\n$$\nu_i^{n+1} = u_i^n \\;-\\; \\nu^{+}\\,\\big(u_i^n - u_{i-1}^n\\big)\\;-\\;\\nu^{-}\\,\\big(u_{i+1}^n - u_i^n\\big),\n$$\n其中 $\\nu^{+}=\\max(\\nu,0)$ 且 $\\nu^{-}=\\min(\\nu,0)$，指数对 $N$ 取模以施加周期性边界条件。对于每个指定的参数集，从 $u_i^0 = \\sin(2\\pi x_i)$ 开始，将解推进指定数量的时间步，并报告增长因子\n$$\nG \\;=\\; \\frac{\\max_i |u_i^{n_f}|}{\\max_i |u_i^{0}|},\n$$\n其中 $n_f$ 是该参数集中执行的总时间步数。\n\n您的程序必须为以下五个测试用例中的每一个计算 $G$，并生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个条目都四舍五入到恰好六位小数。不允许有其他输出。\n\n测试套件：\n- 案例 1：$c=1.0$，$N=200$，$\\Delta t=0.0035$，时间步数 $n_f=400$。此处 $\\Delta x = 1/200 = 0.005$，因此 $\\nu = c\\,\\Delta t/\\Delta x = 1.0 \\times 0.0035 / 0.005 = 0.7$。\n- 案例 2：$c=1.0$，$N=100$，$\\Delta t=0.01$，时间步数 $n_f=50$。此处 $\\Delta x = 1/100 = 0.01$，因此 $\\nu = 1.0 \\times 0.01 / 0.01 = 1.0$。\n- 案例 3：$c=1.0$，$N=100$，$\\Delta t=0.012$，时间步数 $n_f=50$。此处 $\\Delta x = 1/100 = 0.01$，因此 $\\nu = 1.0 \\times 0.012 / 0.01 = 1.2$。\n- 案例 4：$c=-2.0$，$N=200$，$\\Delta t=0.00225$，时间步数 $n_f=300$。此处 $\\Delta x = 1/200 = 0.005$，因此 $\\nu = -2.0 \\times 0.00225 / 0.005 = -0.9$。\n- 案例 5：$c=0.5$，$N=40$，$\\Delta t=0.06$，时间步数 $n_f=40$。此处 $\\Delta x = 1/40 = 0.025$，因此 $\\nu = 0.5 \\times 0.06 / 0.025 = 1.2$。\n\n最终输出格式：\n- 单行列表 $[G_1,G_2,G_3,G_4,G_5]$，其中每个 $G_k$ 是案例 $k$ 的增长因子，四舍五入到恰好六位小数（例如，$[1.000000,0.998532,12.345678,1.000000,345678.901234]$）。任何角度（如有）都必须以弧度为单位进行解释；不涉及物理单位；数值答案必须是无量纲实数。", "solution": "所给出的问题已经过验证，并被认定是有效的。这是一个计算工程中的适定问题，其根植于偏微分方程数值分析的基本原理。所有参数和条件都已明确指定，其表述在科学上和数学上都是合理的。\n\n该问题要求对一维线性平流方程进行数值求解：\n$$\n\\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = 0\n$$\n该方程是一阶双曲型偏微分方程的典范模型。其精确解描述了一个波形 $u(x,0)$ 以恒定速度 $c$ 平移且形状保持不变，即 $u(x,t) = u(x-ct, 0)$。域被指定为 $x \\in [0,1]$，具有周期性边界条件 $u(0,t) = u(1,t)$，初始条件为正弦波 $u(x,0) = \\sin(2\\pi x)$。\n\n该方程将在均匀网格上使用一阶显式有限差分格式进行求解。空间网格点为 $x_i = i\\Delta x$（$i=0, 1, \\dots, N-1$），网格间距为 $\\Delta x = 1/N$。时间层为 $t^n = n\\Delta t$。令 $u_i^n$ 为 $u(x_i, t^n)$ 的数值近似。所提出的格式为：\n$$\nu_i^{n+1} = u_i^n - \\nu^{+}\\,\\big(u_i^n - u_{i-1}^n\\big) - \\nu^{-}\\,\\big(u_{i+1}^n - u_i^n\\big)\n$$\n此处，$\\nu = c\\Delta t/\\Delta x$ 是无量纲库兰特数 (Courant number)，分裂系数为 $\\nu^{+} = \\max(\\nu, 0)$ 和 $\\nu^{-} = \\min(\\nu, 0)$。指数对 $N$ 取模，这正确地实现了周期性边界条件。\n\n该格式是一阶迎风法的一种通用形式。让我们根据平流速度 $c$ 的符号对两种可能的情况进行分析。\n\n情况 1：$c  0$。这意味着 $\\nu  0$。此时 $\\nu^{+} = \\nu$ 且 $\\nu^{-} = 0$。该格式简化为：\n$$\nu_i^{n+1} = u_i^n - \\nu(u_i^n - u_{i-1}^n) = (1-\\nu)u_i^n + \\nu u_{i-1}^n\n$$\n这是用于正速度的经典迎风格式。空间导数 $\\partial u/\\partial x$ 由后向差分 $(u_i^n - u_{i-1}^n)/\\Delta x$ 近似，使用了来自波传播的“迎风”方向的信息。\n\n情况 2：$c  0$。这意味着 $\\nu  0$。此时 $\\nu^{+} = 0$ 且 $\\nu^{-} = \\nu$。该格式简化为：\n$$\nu_i^{n+1} = u_i^n - \\nu(u_{i+1}^n - u_i^n) = (1+\\nu)u_i^n - \\nu u_{i+1}^n\n$$\n这是用于负速度的迎风格式。空间导数由前向差分 $(u_{i+1}^n - u_i^n)/\\Delta x$ 近似，同样使用了来自迎风方向的信息。\n\n任何显式有限差分格式的一个关键方面是其数值稳定性。对于一阶迎风格式，冯·诺依曼 (Von Neumann) 稳定性分析表明，该格式稳定当且仅当满足 Courant-Friedrichs-Lewy (CFL) 条件。对于这个特定的格式，该条件是 $|\\nu| \\le 1$。\n- 如果 $|\\nu|  1$，格式是稳定的，但会引入数值耗散，这会人为地衰减解的振幅。增长因子 $G$ 预期将小于 $1$。\n- 如果 $|\\nu| = 1$，格式是稳定的且非耗散的。对于 $\\nu=1$，$u_i^{n+1} = u_{i-1}^n$，这是离散解向右精确平移一个网格单元。对于 $\\nu=-1$，$u_i^{n+1} = u_{i+1}^n$，是向左的精确平移。在这种特殊情况下，数值解在网格点上是精确的，增长因子 $G$ 将恰好为 $1$。\n- 如果 $|\\nu|  1$，格式是不稳定的。数值误差会随着每个时间步指数级放大，导致解无界增长。增长因子 $G$ 将显著大于 $1$。\n\n解决每个测试用例问题的算法步骤如下：\n1. 定义该案例的参数：$c$、$N$、$\\Delta t$ 和 $n_f$。\n2. 计算派生参数：$\\Delta x = 1/N$ 和库兰特数 (Courant number) $\\nu = c\\Delta t/\\Delta x$。确定 $\\nu^{+}$ 和 $\\nu^{-}$。\n3. 初始化大小为 $N$ 的解向量 $u$。网格点为 $x_i = i/N$（$i=0, \\dots, N-1$）。初始条件为 $u_i^0 = \\sin(2\\pi x_i)$。\n4. 计算初始解的最大绝对值 $\\max_i |u_i^0|$。对于给定的初始条件和 $N$ 值，网格采样到了正弦函数的峰值，所以这个最大值为 $1$。\n5. 执行一个 $n_f$ 步的时间步循环。在每一步中，使用有限差分格式的向量化实现从 $u^n$ 计算解向量 $u^{n+1}$。使用数组移位操作（例如 Python 中的 `numpy.roll`）可以高效地处理周期性边界条件。更新规则是：\n   $$\n   u^{n+1} = u^n - \\nu^{+} (u^n - \\text{roll}(u^n, 1)) - \\nu^{-} (\\text{roll}(u^n, -1) - u^n)\n   $$\n6. 在 $n_f$ 个时间步之后，计算最终解的最大绝对值 $\\max_i |u_i^{n_f}|$。\n7. 增长因子计算为 $G = (\\max_i |u_i^{n_f}|) / (\\max_i |u_i^0|)$。\n\n对所有五个测试用例重复此过程，这些测试用例旨在探究数值格式的不同稳定性区域。然后按要求收集并格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the linear advection equation using a first-order upwind scheme\n    for a series of test cases and computes the growth factor for each.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (c, N, dt, n_f)\n        (1.0, 200, 0.0035, 400),\n        (1.0, 100, 0.01, 50),\n        (1.0, 100, 0.012, 50),\n        (-2.0, 200, 0.00225, 300),\n        (0.5, 40, 0.06, 40),\n    ]\n\n    results = []\n    for c, N, dt, n_f in test_cases:\n        # Step 1: Discretization and parameters\n        dx = 1.0 / N\n        nu = c * dt / dx\n        nu_plus = max(nu, 0.0)\n        nu_minus = min(nu, 0.0)\n\n        # Step 2: Initial condition\n        x = np.arange(N) * dx\n        u = np.sin(2.0 * np.pi * x)\n        \n        # The initial maximum amplitude is calculated for correctness,\n        # although it is 1.0 for the given N values.\n        max_u0 = np.max(np.abs(u))\n        \n        # Step 3: Time-stepping loop\n        for _ in range(n_f):\n            # The periodic boundary conditions are handled by np.roll.\n            # u_im1 corresponds to u_{i-1}\n            u_im1 = np.roll(u, 1)\n            # u_ip1 corresponds to u_{i+1}\n            u_ip1 = np.roll(u, -1)\n            \n            # Apply the explicit upwind scheme in vectorized form\n            u = u - nu_plus * (u - u_im1) - nu_minus * (u_ip1 - u)\n\n        # Step 4: Calculate the growth factor\n        max_uf = np.max(np.abs(u))\n        \n        # Avoid division by zero if initial condition is zero everywhere\n        if max_u0 > 1e-12:\n            growth_factor = max_uf / max_u0\n        else:\n            growth_factor = 1.0 if max_uf  1e-12 else float('inf')\n\n        results.append(growth_factor)\n\n    # Final print statement in the exact required format.\n    # The results are formatted to six decimal places.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "2388289"}, {"introduction": "接下来，我们转向抛物线型偏微分方程，使用对流扩散方程作为模型，它描述了一个物质如何被输运并同时扩散开来的过程。在本练习中，你将研究一个常见的陷阱：当对流远强于扩散时，即使数值格式是稳定的，解中也会出现非物理的振荡[@problem_id:2388332]。这个实践凸显了选择与底层物理相适应的离散化方案（例如迎风格式）的重要性。", "problem": "编写一个完整、可运行的程序，该程序使用空间上的标准中心差分格式和时间上的全隐式积分器，对一个一维、瞬态对流扩散方程（一个代表性的抛物线模型问题）进行数值求解，并定量地展示在对流主导的情况下，不使用迎风格式时出现的伪振荡。\n\n控制方程为线性平流-扩散方程\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = \\nu \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in (0,1), \\ t \\in (0,T],\n$$\n其 Dirichlet 边界条件和初始条件如下\n$$\nu(0,t) = 1, \\quad u(1,t) = 0, \\quad u(x,0) = 0 \\ \\text{for all} \\ x \\in (0,1).\n$$\n此处，$a$ 是恒定的平流速度，$\\nu$ 是恒定的扩散系数。这是一个抛物线型偏微分方程，源于带扩散的输运量守恒。\n\n您必须：\n- 用 $n_x$ 个点对空间域进行均匀离散化（包括两个边界点），空间步长为 $h = 1/(n_x-1)$。\n- 对所有内部网格点的一阶导数 $\\partial u/\\partial x$ 和二阶导数 $\\partial^2 u/\\partial x^2$ 均使用二阶中心有限差分，不使用任何迎风格式或通量限制器。\n- 使用全隐式（Backward Euler）时间步进法，时间步长 $\\Delta t$ 由您自行选择以确保稳定性和鲁棒性。您不得使用任何人工扩散或迎风格式。\n- 在时间上推进到 $t=T$，然后通过计算有多少内部网格值违反了由数据所隐含的极值原理界限来诊断伪振荡，即，有多少内部 $u$ 值在误差 $\\varepsilon$ 内超出了区间 $[0,1]$。使用 $\\varepsilon = 10^{-8}$。\n\n您的程序必须实现以下参数化测试套件，其中每个测试用例是一个元组 $(a,\\nu,n_x,T)$：\n- 测试A（扩散主导的“理想情况”）： $(a,\\nu,n_x,T) = (1.0, 0.05, 101, 2.0)$。\n- 测试B（对流主导）： $(a,\\nu,n_x,T) = (1.0, 0.001, 101, 2.0)$。\n- 测试C（强对流主导）： $(a,\\nu,n_x,T) = (5.0, 0.001, 101, 2.0)$。\n\n只能使用中心差分和全隐式时间积分器；不允许使用迎风格式、人工粘性、通量限制器和斜率限制器。\n\n对于每个测试用例，计算一个单独的整数：\n- 在 $t=T$ 时，满足 $u(x_i,T)  -\\varepsilon$ 或 $u(x_i,T)  1+\\varepsilon$ 的内部网格点 $x_i$ 的数量。\n\n您的程序应生成单行输出，其中包含测试A、B和C的三个整数结果，按顺序排列，并以逗号分隔的列表形式用方括号括起来，例如 $[r_1,r_2,r_3]$。\n\n您必须遵循的实现细节：\n- 通过以下方式对间距为 $h$ 的内部节点 $x_i$ 处的空间导数进行离散化\n$$\n\\left.\\frac{\\partial u}{\\partial x}\\right|_{x_i} \\approx \\frac{u_{i+1}-u_{i-1}}{2h}, \\qquad\n\\left.\\frac{\\partial^2 u}{\\partial x^2}\\right|_{x_i} \\approx \\frac{u_{i-1}-2u_i+u_{i+1}}{h^2}.\n$$\n- 使用全隐式（Backward Euler）时间离散化\n$$\n\\frac{u^{n+1} - u^n}{\\Delta t} + a \\, D_0 u^{n+1} = \\nu \\, D_2 u^{n+1},\n$$\n其中 $D_0$ 和 $D_2$ 是上述定义的中心有限差分算子，应用于时间层 $n+1$。\n- 在每个时间步中，为内部未知数构建所得的三对角线性系统，并使用直接法精确求解（达到数值精度），而非迭代求解器，同时始终保持 Dirichlet 边界值。\n- 根据平流时间尺度和网格间距，以科学合理的方式选择 $\\Delta t$（例如，与 $h/a$ 成正比），并在代码中以注释形式记录您的选择。您不得依赖用户输入。\n\n本问题中的所有量都是无量纲和无单位的。最终输出必须是整数。程序必须是自包含的，不需要任何输入。输出必须是符合上述确切格式的单行文本。", "solution": "所提出的问题是计算工程领域一个有效且适定的练习。它涉及一维线性对流扩散方程的数值解，这是一个典型的抛物线型偏微分方程（PDE）。所有必要数据，包括控制方程、域、边界和初始条件、离散化格式以及具体的测试参数，均已提供。该问题具有科学依据，因为它关注的是一个有充分文献记载的现象：在对流主导的流动中使用中心差分格式会产生伪振荡。这是偏微分方程数值方法研究中的一个基本课题。目标明确，方法论具体。因此，可以构建一个解。\n\n控制方程如下：\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = \\nu \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in (0,1), \\ t \\in (0,T]\n$$\n初始条件为 $u(x,0) = 0$（对于 $x \\in (0,1)$），Dirichlet 边界条件为 $u(0,t) = 1$，$u(1,t) = 0$。\n\n我们首先将空间域 $x \\in [0,1]$ 离散化为 $n_x$ 个点，得到均匀的网格间距 $h = 1 / (n_x - 1)$。解 $u(x,t)$ 在离散点 $(x_i, t_n)$ 处进行近似，其中 $x_i = (i-1)h$（$i=1, 2, \\dots, n_x$），$t_n = n \\Delta t$。令 $u_i^n \\approx u(x_i, t_n)$。\n\n问题要求使用全隐式时间积分格式（Backward Euler）。将此格式应用于控制偏微分方程，我们在未来的时间层 $n+1$ 评估空间导数：\n$$\n\\frac{u^{n+1}_i - u^{n}_i}{\\Delta t} + a \\left. \\frac{\\partial u}{\\partial x} \\right|_i^{n+1} = \\nu \\left. \\frac{\\partial^2 u}{\\partial x^2} \\right|_i^{n+1}\n$$\n此方程是为所有内部网格点（即 $i = 2, 3, \\dots, n_x-1$）建立的。\n\n接下来，我们代入指定的二阶中心有限差分近似来表示空间导数：\n$$\n\\left. \\frac{\\partial u}{\\partial x} \\right|_i^{n+1} \\approx \\frac{u_{i+1}^{n+1} - u_{i-1}^{n+1}}{2h}\n$$\n$$\n\\left. \\frac{\\partial^2 u}{\\partial x^2} \\right|_i^{n+1} \\approx \\frac{u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}}{h^2}\n$$\n将这些表达式代入时间离散化的方程，得到：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\left( \\frac{u_{i+1}^{n+1} - u_{i-1}^{n+1}}{2h} \\right) = \\nu \\left( \\frac{u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}}{h^2} \\right)\n$$\n为了求解新时间步的未知值 $u_i^{n+1}$，我们重新整理方程，将所有在时间层 $n+1$ 的项组合到左侧，所有来自时间层 $n$ 的已知项放在右侧。\n$$\nu_i^{n+1} + \\frac{a \\Delta t}{2h} (u_{i+1}^{n+1} - u_{i-1}^{n+1}) - \\frac{\\nu \\Delta t}{h^2} (u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}) = u_i^n\n$$\n收集与网格点 $i-1$、$i$ 和 $i+1$ 对应的项：\n$$\n\\left( -\\frac{a \\Delta t}{2h} - \\frac{\\nu \\Delta t}{h^2} \\right) u_{i-1}^{n+1} + \\left( 1 + \\frac{2\\nu \\Delta t}{h^2} \\right) u_i^{n+1} + \\left( \\frac{a \\Delta t}{2h} - \\frac{\\nu \\Delta t}{h^2} \\right) u_{i+1}^{n+1} = u_i^n\n$$\n这就构成了一个关于内部节点未知值 $\\mathbf{u}_{\\text{int}}^{n+1} = [u_2^{n+1}, u_3^{n+1}, \\dots, u_{n_x-1}^{n+1}]^T$ 的线性方程组。该系统可以写成矩阵形式 $A \\mathbf{u}_{\\text{int}}^{n+1} = \\mathbf{b}$。矩阵 $A$ 是一个大小为 $(n_x-2) \\times (n_x-2)$ 的三对角矩阵。我们定义下对角线（$l$）、主对角线（$d$）和上对角线（$r$）的系数：\n$$\nl = -\\frac{a \\Delta t}{2h} - \\frac{\\nu \\Delta t}{h^2} \\quad \\text{(次对角线)}\n$$\n$$\nd = 1 + \\frac{2\\nu \\Delta t}{h^2} \\quad \\text{(主对角线)}\n$$\n$$\nr = \\frac{a \\Delta t}{2h} - \\frac{\\nu \\Delta t}{h^2} \\quad \\text{(超对角线)}\n$$\n右侧向量 $\\mathbf{b}$ 由前一时间步的值 $u_i^n$ 组成，并根据边界条件进行调整。边界条件为 $u(0,t) = u_1 = 1$ 和 $u(1,t) = u_{n_x} = 0$。这些是时间层 $n+1$ 的已知值。\n\n对于第一个内部点（$i=2$）：\n$l u_1^{n+1} + d u_2^{n+1} + r u_3^{n+1} = u_2^n$。由于 $u_1^{n+1}=1$，这变为 $d u_2^{n+1} + r u_3^{n+1} = u_2^n - l$。\n右侧向量的第一个条目是 $b_1 = u_2^n - l$。\n\n对于最后一个内部点（$i=n_x-1$）：\n$l u_{n_x-2}^{n+1} + d u_{n_x-1}^{n+1} + r u_{n_x}^{n+1} = u_{n_x-1}^n$。由于 $u_{n_x}^{n+1}=0$，这变为 $l u_{n_x-2}^{n+1} + d u_{n_x-1}^{n+1} = u_{n_x-1}^n$。\n右侧向量的最后一个条目是 $b_{n_x-2} = u_{n_x-1}^n$。\n\n对于所有其他内部点（$2  i  n_x-1$），右侧向量中对应的条目就是 $b_{i-1} = u_i^n$。\n\n非物理振荡的出现由网格 Péclet 数 $Pe_h = \\frac{|a|h}{2\\nu}$ 决定。中心差分格式的理论表明，当 $Pe_h > 1$ 时，解容易出现伪的、非物理的振荡，因为矩阵 $A$ 可能会失去其对角占优性，而对角占优性是满足离散极值原理的一个条件。\n让我们用 $h=1/(101-1) = 0.01$ 来为给定的测试用例计算 $Pe_h$：\n- 测试 A: $Pe_h = \\frac{1.0 \\times 0.01}{2 \\times 0.05} = 0.1$。由于 $Pe_h  1$，解应该是光滑且物理上正确的。\n- 测试 B: $Pe_h = \\frac{1.0 \\times 0.01}{2 \\times 0.001} = 5$。由于 $Pe_h  1$，预计会出现振荡。\n- 测试 C: $Pe_h = \\frac{5.0 \\times 0.01}{2 \\times 0.001} = 25$。由于 $Pe_h \\gg 1$，预计会出现严重振荡。\n\n总体算法如下：\n1. 对于每个测试用例 $(a, \\nu, n_x, T)$，初始化计算参数。基于 Courant-Friedrichs-Lewy (CFL) 条件选择一个合理的时间步长 $\\Delta t$，例如 $\\Delta t = C \\frac{h}{a}$ 且 $C=0.5$，以确保时间分辨率足以解析平流过程。\n2. 根据初始条件 $u(x,0)=0$ 初始化解向量 $\\mathbf{u}^0$。\n3. 使用系数 $l$，$d$ 和 $r$ 组装常数三对角矩阵 $A$。\n4. 从 $t=0$ 到 $t=T$ 进行时间迭代。在每个步骤中：\n   a. 使用上一步的解 $\\mathbf{u}^n$ 并结合边界条件来构建右侧向量 $\\mathbf{b}$。\n   b. 使用直接求解器求解线性系统 $A \\mathbf{u}_{\\text{int}}^{n+1} = \\mathbf{b}$，以找到新时间步的内部解。\n   c. 更新完整的解向量 $\\mathbf{u}^{n+1}$。\n5. 在最后一个时间步之后，分析 $t=T$ 时的解 $\\mathbf{u}$。计算内部网格点中解违反极值原理（即超出 $[0, 1]$ 范围超过一个容差 $\\varepsilon = 10^{-8}$）的数量。\n6. 记录每个测试用例的这个计数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the 1D convection-diffusion problem.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (a, nu, n_x, T)\n    test_cases = [\n        (1.0, 0.05, 101, 2.0),   # Test A: Diffusion-dominated\n        (1.0, 0.001, 101, 2.0),  # Test B: Convection-dominated\n        (5.0, 0.001, 101, 2.0),  # Test C: Strongly convection-dominated\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_case(a, nu, n_x, T):\n    \"\"\"\n    Solves the 1D convection-diffusion equation for a single test case.\n\n    Args:\n        a (float): Advection speed.\n        nu (float): Diffusivity.\n        n_x (int): Number of spatial grid points.\n        T (float): Final time.\n\n    Returns:\n        int: The count of interior grid points where the solution violates\n             the maximum principle at the final time T.\n    \"\"\"\n    epsilon = 1e-8\n\n    # Spatial discretization\n    h = 1.0 / (n_x - 1)\n\n    # Time discretization\n    # A reasonable time step is chosen to ensure temporal accuracy,\n    # based on a Courant number C=0.5.\n    # The implicit scheme is unconditionally stable, but this choice\n    # ensures the advection process is well-resolved in time.\n    cfl_number = 0.5\n    dt = cfl_number * h / a\n    n_t = int(T / dt)\n\n    # Initial condition: u(x, 0) = 0 for all x in (0, 1)\n    u_n = np.zeros(n_x)\n\n    # Boundary conditions: u(0, t) = 1, u(1, t) = 0\n    u_bc_left = 1.0\n    u_bc_right = 0.0\n    \n    # Set boundary values on the initial solution vector. These are constant in time.\n    u_n[0] = u_bc_left\n    u_n[-1] = u_bc_right\n\n    # Assemble the tridiagonal matrix for the linear system A*u_np1 = b\n    # The system is for the n_x - 2 interior points.\n    num_interior_points = n_x - 2\n    \n    # Coefficients for the tridiagonal matrix A\n    l = -a * dt / (2 * h) - nu * dt / h**2   # Lower diagonal\n    d = 1 + 2 * nu * dt / h**2               # Main diagonal\n    r = a * dt / (2 * h) - nu * dt / h**2    # Upper diagonal\n\n    A = np.zeros((num_interior_points, num_interior_points))\n\n    # Populate the matrix A\n    np.fill_diagonal(A, d)\n    if num_interior_points > 1:\n        np.fill_diagonal(A[1:], l)\n        np.fill_diagonal(A[:, 1:], r)\n\n    # Time-marching loop\n    for _ in range(n_t):\n        # Construct the right-hand-side vector b\n        b = u_n[1:-1].copy()\n        \n        # Incorporate boundary conditions into the RHS\n        # For the first interior point (i=2)\n        b[0] -= l * u_bc_left\n        \n        # For the last interior point (i=n_x-1), the contribution is zero\n        # because u_bc_right is 0.\n        # b[-1] -= r * u_bc_right\n\n        # Solve the linear system for interior points at time n+1\n        try:\n            u_interior_np1 = np.linalg.solve(A, b)\n        except np.linalg.LinAlgError:\n            print(\"Error: Singular matrix. The simulation cannot proceed.\")\n            # Return an error code, e.g., -1.\n            return -1\n\n        # Update the solution vector for the next time step\n        u_n[1:-1] = u_interior_np1\n\n    # After the loop, u_n holds the solution at t=T\n    # Diagnose spurious oscillations by counting violations of the maximum principle\n    interior_solution = u_n[1:-1]\n    violations = np.sum((interior_solution  -epsilon) | (interior_solution > 1.0 + epsilon))\n    \n    return int(violations)\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2388332"}, {"introduction": "最后，我们来解决一个椭圆型模型问题——泊松方程，它描述了诸如稳态热分布或静电势等平衡系统。本练习将向你介绍“人造解法”，这是一种用于验证代码正确性并衡量其收敛阶的强大技术。你将在一个非简单的 L 型区域上实现一个求解器，并亲自验证你的数值方法的精度是否达到了理论预期[@problem_id:2388329]。", "problem": "您需要实现、执行并分析一个数值实验，以验证一个标准格式在应用于计算工程中的一个椭圆模型问题时的收敛阶。考虑泊松方程，这是一个椭圆偏微分方程，定义在一个 L 形域上。该 L 形域由正方形 $\\Omega_{\\mathrm{sq}} = [-1,1]\\times[-1,1]$ 去掉右下象限而定义：$\\Omega = \\Omega_{\\mathrm{sq}} \\setminus \\left([0,1]\\times[-1,0]\\right)$。设在 $\\Omega$ 内有 $-\\Delta u = f$，并在边界 $\\partial\\Omega$ 上有狄利克雷边界条件 $u = g$。您必须使用光滑数据的制造解方法来验证二阶有限差分法的收敛率，从而使得精确解 $u$ 已知。\n\n从基本原理出发，利用 $-\\Delta$ 是椭圆算子的分类，通过对 $u$ 的泰勒展开和拉普拉斯算子的定义，在均匀笛卡尔网格上推导出一个相容的二阶离散格式。通过在边界网格节点上强制施加 $u=g$ 来施加狄利克雷边界条件。通过屏蔽掉 $\\Omega$ 外部的网格点来处理非矩形几何形状，并将离散边界定义为那些在掩码内且至少有一个在掩码外的邻居节点，或位于 $\\Omega_{\\mathrm{sq}}$ 边界上的节点。在 $\\Omega$ 的内部（非边界）节点上，组装并求解得到的稀疏线性系统。\n\n使用制造解方法：对于一个给定的光滑函数 $u(x,y)$，在 $\\Omega$ 内设置 $f(x,y)=-\\Delta u(x,y)$，并在 $\\partial\\Omega$ 上设置 $g(x,y)=u(x,y)$。对于每个在 $[-1,1]$ 上每个坐标方向有 $N$ 个子区间的网格（因此网格间距 $h = 2/N$，网格节点为 $\\{x_i\\}_{i=0}^N$，$\\{y_j\\}_{j=0}^N$），计算数值解，然后计算在 $\\Omega$ 上的离散 $L^2$ 误差，\n$$\nE_h = \\left( \\sum_{(x_i,y_j)\\in\\Omega_h} \\left(u_h(x_i,y_j) - u(x_i,y_j)\\right)^2\\, h^2 \\right)^{1/2},\n$$\n其中 $\\Omega_h$ 是位于 $\\Omega$ 内的网格节点集合，$u_h$ 是施加了狄利克雷数据的离散解，$u$ 是解析解。通过以下公式估算连续细化之间的观测收敛阶：\n$$\np \\approx \\frac{\\log(E_{h}/E_{h/2})}{\\log(2)}.\n$$\n您必须实现所需的算法步骤，以构建带掩码的 L 形网格，识别 $\\Omega$ 的内部和边界节点，使用二阶中心差分法组装五点离散拉普拉斯算子，通过消元法应用狄利克雷边界条件，并求解得到的线性系统。\n\n测试套件：\n实现三个独立的制造解测试用例，每个用例在三个连续细化的网格上进行评估，并对每个用例报告观测到的平均收敛阶 $\\bar{p}$，该值由两次连续细化估算值的算术平均值计算得出。\n\n- 用例 $\\mathsf{A}$ (理想情况): $u(x,y) = \\sin(\\pi x)\\sin(\\pi y)$, $f(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$，其中 $N \\in \\{16,32,64\\}$。\n\n- 用例 $\\mathsf{B}$ (粗网格边界情况): $u(x,y) = e^{x+y}$, $f(x,y) = -2 e^{x+y}$，其中 $N \\in \\{8,16,32\\}$。\n\n- 用例 $\\mathsf{C}$ (各向异性光滑模态): $u(x,y) = \\cos(2x)\\cos(3y)$, $f(x,y) = 13 \\cos(2x)\\cos(3y)$，其中 $N \\in \\{24,48,96\\}$。\n\n要求的最终输出格式：\n您的程序必须生成单行输出，其中包含用例 $\\mathsf{A}$、$\\mathsf{B}$ 和 $\\mathsf{C}$ 的三个平均观测阶，按此顺序排列，形式为用逗号分隔并用方括号括起来的列表，例如 $[p_A,p_B,p_C]$。每个 $p$ 值都必须以浮点数形式打印。不允许有任何其他输出。不涉及任何物理单位，因此仅报告纯数字。三角函数中隐含的角度单位是弧度。任何地方都不使用百分比；所有量都应以普通十进制数报告。", "solution": "我们考虑由泊松方程 $-\\Delta u = f$ 给出的椭圆模型问题，该问题定义在 L 形域 $\\Omega = [-1,1]^2 \\setminus \\left([0,1]\\times[-1,0]\\right)$ 上，并在边界 $\\partial \\Omega$ 上具有狄利克雷边界条件 $u=g$。拉普拉斯算子 $\\Delta$ 是椭圆的，因为其主特征 $\\sigma(\\Delta)(\\xi) = -|\\xi|^2$ 对于非零的 $\\xi$ 是负定的，这确保了该模型问题是椭圆的。\n\n数值格式的推导基于以下基本原理：(i) 笛卡尔坐标系中拉普拉斯算子的定义，$\\Delta u = u_{xx} + u_{yy}$，(ii) 对光滑函数进行泰勒展开以获得中心差分公式，以及 (iii) 制造解方法，即预先指定一个精确解 $u$，并由此导出 $f=-\\Delta u$ 以及边界数据 $g=u$。\n\n为了在均匀网格上获得二阶相容的离散近似，设网格点为 $(x_i,y_j)$，其中 $i,j=0,\\dots,N$，网格间距为 $h=2/N$，覆盖区域 $[-1,1]\\times[-1,1]$。对于光滑函数 $u$，泰勒展开可得到标准的二阶中心差分近似：\n$$\nu_{xx}(x_i,y_j) \\approx \\frac{u(x_{i+1},y_j) - 2u(x_i,y_j) + u(x_{i-1},y_j)}{h^2},\\quad\nu_{yy}(x_i,y_j) \\approx \\frac{u(x_i,y_{j+1}) - 2u(x_i,y_j) + u(x_i,y_{j-1})}{h^2}.\n$$\n求和即可得到具有二阶截断误差的拉普拉斯算子五点格式：\n$$\n-\\Delta u(x_i,y_j) \\approx \\frac{4 u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}}{h^2},\n$$\n其中 $u_{i,j} = u(x_i,y_j)$。在足够的光滑性条件下，局部截断误差为 $\\mathcal{O}(h^2)$。\n\n通过掩码处理几何形状：在网格点上定义一个布尔掩码，如果 $(x_i,y_j) \\in \\Omega$，则标记为“内部”，否则标记为“外部”。对于 L 形域 $\\Omega = [-1,1]^2 \\setminus ([0,1]\\times[-1,0])$，只要网格节点不同时满足 $x_i \\ge 0$ 和 $y_j \\le 0$，它就位于内部。边界节点是位于内部的节点，它或者位于外部方框的边界上（$i\\in\\{0,N\\}$ 或 $j\\in\\{0,N\\}$），或者其（轴向）直接邻居中至少有一个位于外部。内部未知量是那些不属于边界节点的内部节点。通过在边界节点上设置 $u=g$ 来施加狄利克雷边界条件，并将与边界节点相邻的内部节点的已知邻居贡献移到方程的右侧。\n\n代数系统：对内部未知量进行编号，并组装一个表示五点格式的稀疏矩阵 $\\mathbf{A}$。对于一个内部节点 $(i,j)$，\n$$\n\\frac{4}{h^2} u_{i,j} - \\frac{1}{h^2}\\big(u_{i+1,j} + u_{i-1,j} + u_{i,j+1} - u_{i,j-1}\\big) = f(x_i,y_j),\n$$\n其中，位于相邻边界节点上的 $u$ 项被移到右侧。求解得到的线性系统 $\\mathbf{A}\\mathbf{u}=\\mathbf{b}$ 以获得内部未知量。通过用精确的狄利克雷数据 $g=u$ 填充边界节点，并用数值解填充内部节点，来获得完整的网格解。\n\n误差测量与收敛阶：域上的离散 $L^2$ 误差计算如下：\n$$\nE_h = \\left( \\sum_{(x_i,y_j)\\in\\Omega_h} \\left(u_h(x_i,y_j) - u(x_i,y_j)\\right)^2\\, h^2 \\right)^{1/2},\n$$\n这是连续 $L^2$ 范数的标准求积近似。对于间距分别为 $h$ 和 $h/2$ 的两个连续网格，观测到的收敛阶为\n$$\np = \\frac{\\log(E_h/E_{h/2})}{\\log(2)}.\n$$\n对于光滑解和五点中心差分近似，该格式是二阶相容的。在稳定性条件下（对于带有狄利克雷条件的椭圆算子的这种对称正定离散化，稳定性是成立的），Lax-Richtmyer 等价性原理保证了二阶收敛性，因此对于足够精细的网格，预期 $p\\approx 2$。\n\n测试套件中使用的制造解：\n- 用例 $\\mathsf{A}$: $u(x,y)=\\sin(\\pi x)\\sin(\\pi y)$，那么 $\\Delta u = -2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$，所以 $f(x,y)=2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$，其中 $N\\in\\{16,32,64\\}$。\n- 用例 $\\mathsf{B}$: $u(x,y)=e^{x+y}$，那么 $\\Delta u = 2 e^{x+y}$，所以 $f(x,y)=-2 e^{x+y}$，其中 $N\\in\\{8,16,32\\}$。\n- 用例 $\\mathsf{C}$: $u(x,y)=\\cos(2x)\\cos(3y)$，那么 $\\Delta u = -(2^2+3^2)\\cos(2x)\\cos(3y)=-13\\cos(2x)\\cos(3y)$，所以 $f(x,y)=13\\cos(2x)\\cos(3y)$，其中 $N\\in\\{24,48,96\\}$。\n\n连接原理与实现的算法设计摘要：\n- 定义具有 $N$ 个子区间和间距 $h=2/N$ 的均匀网格。\n- 为 $\\Omega$ 构建内部掩码，并使用邻居检查来检测边界节点。\n- 对每个内部节点，将五点拉普拉斯算子组装成一个稀疏矩阵，并通过加上 $f(x_i,y_j)$ 和减去已知边界值的贡献来构建右侧向量。\n- 求解内部节点的稀疏线性系统，并通过在边界节点处插入狄利克雷值来组合成完整的网格解。\n- 为每个网格计算 $E_h$，然后在连续细化中计算两个 $p$ 值并将其平均，以报告每个用例的 $\\bar{p}$。\n- 因为 $u$ 是光滑的且格式是二阶精确的，所以对于所有三种情况，观测到的阶数应接近于 2。由于前渐近效应和离散边界上由几何形状引起的非规则性，预计在粗网格上会出现微小偏差，但平均值仍应接近 2。\n\n程序输出单行 $[p_A,p_B,p_C]$，包含三个平均观测阶，三角函数使用弧度单位，不带任何物理单位，满足格式规范。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import coo_matrix, csr_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef build_domain_masks(N):\n    \"\"\"\n    Build grid coordinates and masks for the L-shaped domain.\n    Domain: [-1,1]^2 minus the lower-right quadrant [0,1] x [-1,0].\n    \"\"\"\n    h = 2.0 / N\n    x = np.linspace(-1.0, 1.0, N + 1)\n    y = np.linspace(-1.0, 1.0, N + 1)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # Inside if not simultaneously (x >= 0 and y = 0)\n    inside = np.logical_not((X >= 0.0)  (Y = 0.0))\n\n    # Boundary: inside but on outer box, or has a neighbor outside\n    boundary = np.zeros_like(inside, dtype=bool)\n    boundary |= (np.arange(N + 1)[:, None] == 0) | (np.arange(N + 1)[:, None] == N)\n    boundary |= (np.arange(N + 1)[None, :] == 0) | (np.arange(N + 1)[None, :] == N)\n    boundary = inside  # ensure boundary only flagged inside\n\n    # neighbor-based boundary detection\n    # shift masks for 4-neighborhood\n    # For neighbors, use 'outside' as False arrays where appropriate\n    outside = ~inside\n    # Check any of the 4 axial neighbors is outside\n    neighbor_outside = np.zeros_like(inside, dtype=bool)\n    neighbor_outside[1:, :] |= outside[:-1, :]   # left neighbor outside\n    neighbor_outside[:-1, :] |= outside[1:, :]   # right neighbor outside\n    neighbor_outside[:, 1:] |= outside[:, :-1]   # bottom neighbor outside\n    neighbor_outside[:, :-1] |= outside[:, 1:]   # top neighbor outside\n\n    boundary |= (inside  neighbor_outside)\n\n    # Interior unknowns: inside but not boundary\n    unknown = inside  (~boundary)\n\n    return X, Y, inside, boundary, unknown, h\n\ndef assemble_and_solve(N, u_exact_func, f_func):\n    \"\"\"\n    Assemble the 5-point Laplacian system on the L-shaped domain mask and solve.\n    Enforce Dirichlet boundary using u_exact_func on boundary nodes.\n    \"\"\"\n    X, Y, inside, boundary, unknown, h = build_domain_masks(N)\n\n    # Map unknown nodes to indices\n    idx = -np.ones_like(inside, dtype=int)\n    unknown_positions = np.argwhere(unknown)\n    for k, (i, j) in enumerate(unknown_positions):\n        idx[i, j] = k\n    n_unknowns = unknown_positions.shape[0]\n\n    # Precompute exact u and f on all nodes\n    U_exact = u_exact_func(X, Y)\n    F = f_func(X, Y)\n\n    # Sparse matrix triplets\n    rows = []\n    cols = []\n    data = []\n    rhs = np.zeros(n_unknowns, dtype=float)\n\n    # For each unknown, add 5-point stencil and boundary contributions\n    for k, (i, j) in enumerate(unknown_positions):\n        # Diagonal entry\n        diag = 4.0 / (h * h)\n        rows.append(k); cols.append(k); data.append(diag)\n\n        # Neighbors: (i+1,j), (i-1,j), (i,j+1), (i,j-1)\n        for (ip, jp) in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n            if unknown[ip, jp]:\n                # neighbor unknown -> coefficient -1/h^2\n                rows.append(k); cols.append(idx[ip, jp]); data.append(-1.0 / (h * h))\n            elif boundary[ip, jp]:\n                # neighbor boundary -> move known Dirichlet to RHS\n                rhs[k] += (1.0 / (h * h)) * U_exact[ip, jp]\n            else:\n                # Should not happen for interior unknowns: all neighbors must be inside.\n                # But we keep a safe-guard; in L-shaped aligned domain this case is absent.\n                pass\n\n        # Right-hand side f at (i,j)\n        rhs[k] += F[i, j]\n\n    if n_unknowns > 0:\n        A = coo_matrix((data, (rows, cols)), shape=(n_unknowns, n_unknowns)).tocsr()\n        u_int = spsolve(A, rhs)\n    else:\n        u_int = np.array([])\n\n    # Compose full grid solution: boundary from U_exact, interior from u_int\n    U_num = np.array(U_exact)  # start from exact for convenience (boundary exact)\n    if n_unknowns > 0:\n        for val, (i, j) in zip(u_int, unknown_positions):\n            U_num[i, j] = val\n\n    # Compute discrete L2 error over inside nodes\n    err_sq = ((U_num - U_exact) ** 2) * inside.astype(float)\n    E_h = np.sqrt(np.sum(err_sq) * (h * h))\n    return E_h\n\ndef observed_order(errors, hs):\n    \"\"\"\n    Compute observed orders between successive refinements and return average.\n    \"\"\"\n    orders = []\n    for k in range(len(errors) - 1):\n        if errors[k+1] > 0 and errors[k] > 0:\n            p = np.log(errors[k] / errors[k+1]) / np.log(hs[k] / hs[k+1])\n            orders.append(p)\n    if len(orders) == 0:\n        return float('nan')\n    return float(np.mean(orders))\n\ndef case_A():\n    # u = sin(pi x) sin(pi y); f = 2*pi^2 * sin(pi x) sin(pi y)\n    def u_exact(X, Y):\n        return np.sin(np.pi * X) * np.sin(np.pi * Y)\n    def f_func(X, Y):\n        return 2.0 * (np.pi ** 2) * np.sin(np.pi * X) * np.sin(np.pi * Y)\n\n    Ns = [16, 32, 64]\n    errors = []\n    hs = []\n    for N in Ns:\n        E = assemble_and_solve(N, u_exact, f_func)\n        errors.append(E)\n        hs.append(2.0 / N)\n    return observed_order(errors, hs)\n\ndef case_B():\n    # u = exp(x+y); f = -2*exp(x+y)\n    def u_exact(X, Y):\n        return np.exp(X + Y)\n    def f_func(X, Y):\n        return -2.0 * np.exp(X + Y)\n\n    Ns = [8, 16, 32]\n    errors = []\n    hs = []\n    for N in Ns:\n        E = assemble_and_solve(N, u_exact, f_func)\n        errors.append(E)\n        hs.append(2.0 / N)\n    return observed_order(errors, hs)\n\ndef case_C():\n    # u = cos(2x) cos(3y); f = 13 cos(2x) cos(3y)\n    def u_exact(X, Y):\n        return np.cos(2.0 * X) * np.cos(3.0 * Y)\n    def f_func(X, Y):\n        return 13.0 * np.cos(2.0 * X) * np.cos(3.0 * Y)\n\n    Ns = [24, 48, 96]\n    errors = []\n    hs = []\n    for N in Ns:\n        E = assemble_and_solve(N, u_exact, f_func)\n        errors.append(E)\n        hs.append(2.0 / N)\n    return observed_order(errors, hs)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case returns an average observed order of convergence.\n    results = []\n    results.append(case_A())\n    results.append(case_B())\n    results.append(case_C())\n\n    # Format each result to a reasonable number of decimals\n    formatted = [\"{:.6f}\".format(r) for r in results]\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2388329"}]}