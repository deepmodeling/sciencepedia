{"hands_on_practices": [{"introduction": "将连续的偏微分方程离散化是数值求解的第一步，但这种近似会引入怎样的非物理效应呢？本练习通过分析亥姆霍兹方程来探讨一个核心概念：数值色散。通过将一个平面波解代入由五点格式离散化的方程中，你将推导出数值波数与物理波数 $k$ 之间的关系，即数值色散关系 [@problem_id:2438676]。理解这一关系对于评估数值格式在模拟波动现象（如声波或电磁波）时的保真度至关重要。", "problem": "考虑在一个无穷均匀的笛卡尔网格上定义的二维亥姆霍兹方程 $\\nabla^{2}\\phi + k^{2}\\phi = 0$，该网格在两个空间方向上的间距均为 $h$。令 $\\phi_{m,n}$ 表示在节点 $(m h, n h)$ 处的网格函数，其中 $m,n \\in \\mathbb{Z}$。拉普拉斯算子 $\\nabla^{2}\\phi$ 通过标准的中心 5 点模板进行离散化：\n$$\n\\left.\\nabla^{2}\\phi\\right|_{m,n} \\approx \\frac{\\phi_{m+1,n} + \\phi_{m-1,n} + \\phi_{m,n+1} + \\phi_{m,n-1} - 4\\,\\phi_{m,n}}{h^{2}}.\n$$\n定义数值色散函数 $D(\\xi,\\eta;h,k)$ 为一个标量函数，其变量为离散波数 $(\\xi,\\eta)$、网格间距 $h$ 和亥姆霍兹参数 $k$。当且仅当 $D(\\xi,\\eta;h,k) = 0$ 时，形如 $\\phi_{m,n} = A\\,\\exp\\!\\big(\\mathrm{i}(\\xi m + \\eta n)\\big)$ 的离散平面波满足离散化的亥姆霍兹方程。推导并给出 $D(\\xi,\\eta;h,k)$ 的闭合形式表达式。\n\n你的最终答案必须是 $D(\\xi,\\eta;h,k)$ 的一个单一闭合形式的解析表达式（不要将其表示为设为零的方程）。不需要取整，也不涉及单位。", "solution": "对问题陈述进行验证。\n\n第 1 步：提取已知条件。\n- 控制偏微分方程是二维亥姆霍兹方程：$\\nabla^{2}\\phi + k^{2}\\phi = 0$。\n- 区域是一个无穷均匀的笛卡尔网格，在两个空间方向上的网格间距均为 $h$。\n- 节点 $(m h, n h)$ 处的网格函数表示为 $\\phi_{m,n}$，其中 $m,n \\in \\mathbb{Z}$。\n- 拉普拉斯算子 $\\nabla^{2}\\phi$ 使用标准的 5 点模板进行离散化：\n$$\n\\left.\\nabla^{2}\\phi\\right|_{m,n} \\approx \\frac{\\phi_{m+1,n} + \\phi_{m-1,n} + \\phi_{m,n+1} + \\phi_{m,n-1} - 4\\,\\phi_{m,n}}{h^{2}}.\n$$\n- 提出了一个离散平面波解：$\\phi_{m,n} = A\\,\\exp\\!\\big(\\mathrm{i}(\\xi m + \\eta n)\\big)$，其中 $\\xi$ 和 $\\eta$ 是离散波数。\n- 数值色散函数 $D(\\xi,\\eta;h,k)$ 定义为离散平面波成为有效解所必须等于零的函数。\n\n第 2 步：使用提取的已知条件进行验证。\n- **科学依据：** 该问题是偏微分方程数值分析中的一个基本练习，特别是有限差分法。亥姆霍兹方程、5 点模板以及数值色散的概念都是计算科学与工程中标准且成熟的课题。该问题在科学上是合理的。\n- **适定性：** 问题提供了推导所求函数所需的所有必要部分——方程、离散格式和试探解形式。目标明确，并且预期有唯一解。\n- **客观性：** 问题以客观的数学语言表述，没有主观或含糊的术语。\n\n第 3 步：结论与行动。\n问题被认为是有效的，因为它具有科学依据、适定、客观且完整。我将继续推导解答。\n\n将拉普拉斯算子的 5 点模板近似代入连续方程，得到亥姆霍兹方程的离散形式：\n$$\n\\frac{\\phi_{m+1,n} + \\phi_{m-1,n} + \\phi_{m,n+1} + \\phi_{m,n-1} - 4\\,\\phi_{m,n}}{h^{2}} + k^{2}\\phi_{m,n} = 0\n$$\n为了找到数值色散关系，我们将离散平面波拟设 $\\phi_{m,n} = A\\,\\exp\\!\\big(\\mathrm{i}(\\xi m + \\eta n)\\big)$ 代入此离散方程中。涉及相邻网格点的各项可以用 $\\phi_{m,n}$ 表示：\n- $\\phi_{m+1,n} = A\\,\\exp\\!\\big(\\mathrm{i}(\\xi (m+1) + \\eta n)\\big) = A\\,\\exp\\!\\big(\\mathrm{i}(\\xi m + \\eta n)\\big) \\exp(\\mathrm{i}\\xi) = \\phi_{m,n} \\exp(\\mathrm{i}\\xi)$\n- $\\phi_{m-1,n} = A\\,\\exp\\!\\big(\\mathrm{i}(\\xi (m-1) + \\eta n)\\big) = \\phi_{m,n} \\exp(-\\mathrm{i}\\xi)$\n- $\\phi_{m,n+1} = A\\,\\exp\\!\\big(\\mathrm{i}(\\xi m + \\eta (n+1))\\big) = \\phi_{m,n} \\exp(\\mathrm{i}\\eta)$\n- $\\phi_{m,n-1} = A\\,\\exp\\!\\big(\\mathrm{i}(\\xi m + \\eta (n-1))\\big) = \\phi_{m,n} \\exp(-\\mathrm{i}\\eta)$\n\n将这些表达式代入离散方程中，得到：\n$$\n\\frac{\\phi_{m,n}\\exp(\\mathrm{i}\\xi) + \\phi_{m,n}\\exp(-\\mathrm{i}\\xi) + \\phi_{m,n}\\exp(\\mathrm{i}\\eta) + \\phi_{m,n}\\exp(-\\mathrm{i}\\eta) - 4\\,\\phi_{m,n}}{h^{2}} + k^{2}\\phi_{m,n} = 0\n$$\n对于非平凡解（即 $A \\neq 0$，因此 $\\phi_{m,n}$ 不恒为零），我们可以将整个方程除以 $\\phi_{m,n}$：\n$$\n\\frac{\\exp(\\mathrm{i}\\xi) + \\exp(-\\mathrm{i}\\xi) + \\exp(\\mathrm{i}\\eta) + \\exp(-\\mathrm{i}\\eta) - 4}{h^{2}} + k^{2} = 0\n$$\n使用欧拉恒等式 $\\exp(\\mathrm{i}\\theta) + \\exp(-\\mathrm{i}\\theta) = 2\\cos(\\theta)$，我们可以简化该表达式：\n$$\n\\frac{2\\cos(\\xi) + 2\\cos(\\eta) - 4}{h^{2}} + k^{2} = 0\n$$\n根据定义，数值色散函数 $D(\\xi,\\eta;h,k)$ 是该方程的左侧。\n$$\nD(\\xi,\\eta;h,k) = \\frac{2\\cos(\\xi) + 2\\cos(\\eta) - 4}{h^{2}} + k^{2}\n$$\n该表达式可以进一步简化。我们从分子中提出公因子 2：\n$$\nD(\\xi,\\eta;h,k) = \\frac{2(\\cos(\\xi) - 1) + 2(\\cos(\\eta) - 1)}{h^{2}} + k^{2}\n$$\n使用三角半角恒等式 $1 - \\cos(\\theta) = 2\\sin^{2}(\\theta/2)$，或等效地 $\\cos(\\theta) - 1 = -2\\sin^{2}(\\theta/2)$，我们替换余弦项：\n$$\nD(\\xi,\\eta;h,k) = \\frac{2\\left(-2\\sin^{2}\\left(\\frac{\\xi}{2}\\right)\\right) + 2\\left(-2\\sin^{2}\\left(\\frac{\\eta}{2}\\right)\\right)}{h^{2}} + k^{2}\n$$\n$$\nD(\\xi,\\eta;h,k) = \\frac{-4\\sin^{2}\\left(\\frac{\\xi}{2}\\right) - 4\\sin^{2}\\left(\\frac{\\eta}{2}\\right)}{h^{2}} + k^{2}\n$$\n提出公因子，得到数值色散函数的最终闭合形式表达式：\n$$\nD(\\xi,\\eta;h,k) = k^{2} - \\frac{4}{h^{2}}\\left(\\sin^{2}\\left(\\frac{\\xi}{2}\\right) + \\sin^{2}\\left(\\frac{\\eta}{2}\\right)\\right)\n$$\n这就是所求的函数。", "answer": "$$\n\\boxed{k^{2} - \\frac{4}{h^{2}} \\left( \\sin^{2}\\left(\\frac{\\xi}{2}\\right) + \\sin^{2}\\left(\\frac{\\eta}{2}\\right) \\right)}\n$$", "id": "2438676"}, {"introduction": "掌握了理论基础后，是时候动手构建一个完整且高效的求解器了。这个综合性练习将引导你使用五点格式，从零开始编写一个二维泊松方程求解器。你将实践如何利用克罗内克积（Kronecker product）高效地组装稀疏矩阵，如何正确地施加狄利克雷（Dirichlet）边界条件，以及如何通过“制造解方法”（method of manufactured solutions）来验证代码的正确性和精度 [@problem_id:2438628]。完成此练习将使你对有限差分法的完整流程有深入的理解，并为你解决更复杂的科学与工程问题打下坚实基础。", "problem": "您的任务是在一个矩形网格上，使用标准的五点差分格式，为二维泊松方程构建一个完整且高效的数值求解器。该问题将在纯粹的数学和算法背景下进行提出和求解，不依赖任何物理单位。求解器必须使用 Scientific Python (SciPy) 库的稀疏矩阵功能，以确保在组装和求解过程中的效率。\n\n起始点（基本基础）：\n- 二维泊松方程由 $-\\Delta u = f$ 给出，定义在矩形域 $\\Omega = [a_x,b_x] \\times [a_y,b_y]$ 上，其中 $\\Delta$ 表示拉普拉斯算子 $\\Delta u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$。\n- 狄利克雷边界条件规定在边界 $\\partial \\Omega$ 上 $u = g$。\n- 离散逼近必须基于一个均匀的张量积网格上的二阶中心有限差分，该网格在 $x$ 方向有 $N_x$ 个内部点，在 $y$ 方向有 $N_y$ 个内部点。网格间距为 $h_x = \\frac{b_x - a_x}{N_x + 1}$ 和 $h_y = \\frac{b_y - a_y}{N_y + 1}$。\n- 五点差分格式是通过组合每个坐标方向上的一维二阶中心差分得到的。\n\n您的任务：\n- 从泰勒展开式出发，推导出一个拉普拉斯算子的一致离散逼近，该逼近能够为内部网格点上的 $u$ 值导出一个对称正定线性系统。\n- 设计一个高效的线性系统稀疏组装方法，该方法使用 SciPy 的稀疏矩阵运算，利用网格引出的张量积（克罗内克积）结构，并在构建矩阵时避免对所有网格点进行显式循环。\n- 通过边界贡献的方式，将狄利克雷边界条件合并到右端项中。\n- 使用一个合适的稀疏求解器求解得到的稀疏线性系统。\n- 通过计算数值解与内部网格上一个已知的制造精确解之间的离散 $L^2$ 误差范数来评估精度，其定义为：\n$$\n\\|e\\|_{L^2(\\Omega_h)} \\equiv \\left( \\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} \\left(u_{ij}^{\\text{num}} - u(x_i,y_j)\\right)^2 h_x h_y \\right)^{1/2},\n$$\n其中 $(x_i,y_j)$ 是内部网格节点，$u_{ij}^{\\text{num}}$ 是在这些节点上计算出的解，而 $u(x,y)$ 是制造的精确解。\n\n测试套件：\n实现您的求解器，并在以下三个制造解算例上进行评估。在每个算例中，$f$ 和 $g$ 必须根据精确解 $u$ 构建，以便连续解是已知的。所有函数都是无量纲的，没有物理单位。\n\n- 算例 1（理想情况，单位正方形上的零狄利克雷边界）：\n  - 区域：$[a_x,b_x] \\times [a_y,b_y] = [0,1] \\times [0,1]$。\n  - 网格：$N_x = 32$，$N_y = 32$。\n  - 精确解：$u(x,y) = \\sin(\\pi x)\\sin(\\pi y)$。\n  - 右端项：$f(x,y)$ 与 $-\\Delta u = f$ 一致。\n  - 边界条件：$g(x,y) = u(x,y)$ 在 $\\partial \\Omega$ 上（对于此精确解，在整个边界上的计算结果为 $0$）。\n\n- 算例 2（非零狄利克雷边界，多项式精确解）：\n  - 区域：$[a_x,b_x] \\times [a_y,b_y] = [0,1] \\times [0,1]$。\n  - 网格：$N_x = 10$，$N_y = 10$。\n  - 精确解：$u(x,y) = x^2 + y^2$。\n  - 右端项：$f(x,y)$ 与 $-\\Delta u = f$ 一致。\n  - 边界条件：$g(x,y) = u(x,y)$ 在 $\\partial \\Omega$ 上。\n\n- 算例 3（矩形域上的各向异性间距）：\n  - 区域：$[a_x,b_x] \\times [a_y,b_y] = [0,2] \\times [0,1]$。\n  - 网格：$N_x = 15$，$N_y = 9$。\n  - 精确解：$u(x,y) = \\sin\\!\\left(\\frac{\\pi}{2} x\\right)\\sin(\\pi y)$。\n  - 右端项：$f(x,y)$ 与 $-\\Delta u = f$ 一致。\n  - 边界条件：$g(x,y) = u(x,y)$ 在 $\\partial \\Omega$ 上（对于此精确解，在整个边界上的计算结果为 $0$）。\n\n输出规格：\n- 对每个算例，按照上述规定计算内部网格上的离散 $L^2$ 误差范数。\n- 您的程序应产生单行输出，其中包含三个结果，形式为方括号括起来的逗号分隔列表，每个浮点值四舍五入到八位小数。例如：$[0.00123456,0.00000000,0.01234567]$。\n- 不应产生任何其他输出。\n\n实现约束：\n- 最终程序必须是一个完整、可运行的 Python 脚本，该脚本使用 Scientific Python (SciPy) 的稀疏矩阵工具进行组装和求解，并使用 Numerical Python (NumPy) 库进行数组操作。\n- 为提高效率，组装过程应利用离散算子的张量积结构。", "solution": "所提出的问题是数值分析中一个标准的、适定的练习题。它要求实现一个用于二维泊松方程的有限差分求解器。该问题具有科学依据、内部一致，并包含进行求解所需的所有必要信息。因此，我们将提供一个完整的解决方案。\n\n整个过程是有条不紊的。首先，我们从连续偏微分方程导出离散代数系统。其次，我们形式化系统矩阵的结构并确定其性质。第三，我们为其组装和求解构建一个高效的算法。最后，我们通过制造解来验证实现。\n\n**1. 泊松方程的离散化**\n\n控制方程是在矩形域 $\\Omega = [a_x, b_x] \\times [a_y, b_y]$ 上的泊松方程：\n$$\n-\\Delta u = -\\left(\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}\\right) = f(x,y)\n$$\n附带狄利克雷边界条件 $u(x,y) = g(x,y)$，适用于 $(x,y) \\in \\partial\\Omega$。\n\n我们引入一个均匀网格，在 $x$ 方向上有 $N_x$ 个内部点，在 $y$ 方向上有 $N_y$ 个内部点。网格坐标为 $x_i = a_x + i \\cdot h_x$（其中 $i=0, 1, \\dots, N_x+1$）和 $y_j = a_y + j \\cdot h_y$（其中 $j=0, 1, \\dots, N_y+1$）。网格间距为 $h_x = \\frac{b_x - a_x}{N_x + 1}$ 和 $h_y = \\frac{b_y - a_y}{N_y + 1}$。待求解的未知量是内部网格点上的函数值 $u_{ij} \\equiv u(x_i, y_j)$，其中 $i \\in \\{1, \\dots, N_x\\}$ 且 $j \\in \\{1, \\dots, N_y\\}$。\n\n为了逼近二阶导数，我们使用二阶中心有限差分。该推导依赖于泰勒级数展开。对于一个足够光滑的函数 $u(x,y)$，我们有：\n$$\nu(x_i \\pm h_x, y_j) = u(x_i, y_j) \\pm h_x \\frac{\\partial u}{\\partial x}\\bigg|_{ij} + \\frac{h_x^2}{2} \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{ij} \\pm \\frac{h_x^3}{6} \\frac{\\partial^3 u}{\\partial x^3}\\bigg|_{ij} + O(h_x^4)\n$$\n将 $u(x_i + h_x, y_j)$ 和 $u(x_i - h_x, y_j)$ 的展开式相加，可以消去奇数阶导数项：\n$$\nu(x_i + h_x, y_j) + u(x_i - h_x, y_j) = 2 u(x_i, y_j) + h_x^2 \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{ij} + O(h_x^4)\n$$\n对二阶导数求解，得到中心差分逼近式：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{ij} = \\frac{u(x_{i-1}, y_j) - 2u(x_i, y_j) + u(x_{i+1}, y_j)}{h_x^2} + O(h_x^2)\n$$\n对于 $\\frac{\\partial^2 u}{\\partial y^2}$ 也存在一个类似的表达式。将这些逼近式代入内部点 $(x_i, y_j)$ 处的泊松方程，得到离散方程：\n$$\n-\\left( \\frac{u_{i-1,j} - 2u_{ij} + u_{i+1,j}}{h_x^2} + \\frac{u_{i,j-1} - 2u_{ij} + u_{i,j+1}}{h_y^2} \\right) = f_{ij}\n$$\n其中 $f_{ij} = f(x_i, y_j)$。整理各项后，我们得到五点差分格式公式：\n$$\n\\left(\\frac{2}{h_x^2} + \\frac{2}{h_y^2}\\right)u_{ij} - \\frac{1}{h_x^2}u_{i-1,j} - \\frac{1}{h_x^2}u_{i+1,j} - \\frac{1}{h_y^2}u_{i,j-1} - \\frac{1}{h_y^2}u_{i,j+1} = f_{ij}\n$$\n这个包含 $N_x \\times N_y$ 个线性代数方程的系统必须被求解，以得到未知数 $u_{ij}$。\n\n**2. 线性系统组装与克罗内克积结构**\n\n为求解此系统，我们必须将其表示为矩阵形式 $A\\mathbf{u} = \\mathbf{b}$。这需要将二维网格上的未知数 $\\{u_{ij}\\}$ 映射到一个大小为 $N_x N_y$ 的一维向量 $\\mathbf{u}$ 上。我们采用列主序（字典序）编号，其中未知数 $u_{ij}$ 的索引 $k$ 由 $k = (i-1) + (j-1)N_x$ 给出，适用于 $i \\in \\{1,\\dots,N_x\\}$ 和 $j \\in \\{1,\\dots,N_y\\}$。\n\n离散负拉普拉斯算子可以表示为两个算子之和，每个空间维度对应一个：$L_h = L_x + L_y$。通过所选的向量化方法，这种变量分离在系统矩阵 $A$ 中引入了一种张量积（也称为克罗内克积）结构。\n\n令 $A_x$ 为表示在含 $N_x$ 个点的网格上的一维负二阶导数算子 $-\\frac{d^2}{dx^2}$ 的矩阵。它是一个 $N_x \\times N_x$ 的三对角矩阵：\n$$\nA_x = \\frac{1}{h_x^2} \\begin{pmatrix} 2 & -1 & & \\\\ -1 & 2 & -1 & \\\\ & \\ddots & \\ddots & \\ddots \\\\ & & -1 & 2 & -1 \\\\ & & & -1 & 2 \\end{pmatrix}\n$$\n类似地，令 $A_y$ 为对应于 $y$ 方向的 $N_y \\times N_y$ 矩阵。令 $I_x$ 和 $I_y$ 分别为大小为 $N_x \\times N_x$ 和 $N_y \\times N_y$ 的单位矩阵。表示二维离散负拉普拉斯算子的矩阵 $A$ 由两个克罗内克积之和给出：\n$$\nA = (I_y \\otimes A_x) + (A_y \\otimes I_x)\n$$\n其中 $\\otimes$ 表示克罗内克积。这种构造产生一个 $(N_x N_y) \\times (N_x N_y)$ 的块三对角矩阵。该结构对于使用稀疏矩阵库进行高效组装至关重要。矩阵 $A$ 是对称的，并且对于此问题是正定的，这保证了解的唯一性。\n\n**3. 合并边界条件**\n\n当一个内部点 $(x_i, y_j)$ 与边界 $\\partial\\Omega$ 相邻时，其差分格式中的一个或多个邻点（例如，$u_{i-1,j}$）的值由狄利克雷条件 $g(x,y)$ 规定，是已知值。这些已知值必须移到线性系统的右端。例如，对于一个与左边界 $x=a_x$ 相邻的点 $(x_1, y_j)$，项 $-\\frac{1}{h_x^2} u_{0,j}$ 变为 $-\\frac{1}{h_x^2} g(x_0, y_j)$，这是一个已知量。该项被加到右端项 $f_{1j}$ 上。\n\n对应于点 $(x_i, y_j)$ 的右端向量 $\\mathbf{b}$ 的第 $k$ 个元素的一般形式是：\n$$\nb_k = f_{ij} + C_{bc}\n$$\n其中 $C_{bc}$ 表示来自任何相邻边界点的贡献之和。对于一个点 $(x_i, y_j)$：\n- 如果 $i=1$：$C_{bc}$ 包含 $\\frac{1}{h_x^2} g(a_x, y_j)$。\n- 如果 $i=N_x$：$C_{bc}$ 包含 $\\frac{1}{h_x^2} g(b_x, y_j)$。\n- 如果 $j=1$：$C_{bc}$ 包含 $\\frac{1}{h_y^2} g(x_i, a_y)$。\n- 如果 $j=N_y$：$C_{bc}$ 包含 $\\frac{1}{h_y^2} g(x_i, b_y)$。\n\n**4. 数值实现与误差评估**\n\n算法如下：\n1.  对于给定的测试用例，确定域 $[a_x,b_x] \\times [a_y,b_y]$、网格维度 $N_x, N_y$ 以及精确解 $u(x,y)$ 的解析函数。\n2.  解析计算源项 $f(x,y) = -\\Delta u(x,y)$ 和边界函数 $g(x,y) = u(x,y)|_{\\partial\\Omega}$。\n3.  使用 `scipy.sparse.diags` 构建稀疏矩阵 $A_x$（$N_x \\times N_x$）和 $A_y$（$N_y \\times N_y$）。\n4.  使用 `scipy.sparse.kron` 构建大小为 $(N_x N_y) \\times (N_x N_y)$ 的完整稀疏系统矩阵 $A$。\n5.  通过在所有内部网格点上计算 $f$ 并如上所述添加边界贡献来构建右端向量 $\\mathbf{b}$。\n6.  使用直接稀疏求解器（如 `scipy.sparse.linalg.spsolve`）求解稀疏线性系统 $A\\mathbf{u} = \\mathbf{b}$，以得到未知向量 $\\mathbf{u}$。\n7.  将解向量 $\\mathbf{u}$ 重塑为 $N_x \\times N_y$ 的网格 `U_num`。\n8.  在内部网格上计算精确解 $u(x,y)$ 以得到 `U_exact`。\n9.  计算离散 $L^2$ 误差范数：\n    $$\n    \\|e\\|_{L^2(\\Omega_h)} = \\left( \\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} (u_{ij}^{\\text{num}} - u(x_i,y_j))^2 h_x h_y \\right)^{1/2}\n    $$\n\n**测试用例详情：**\n\n对于每个用例，我们首先推导源函数 $f(x,y)$：\n- **算例 1：** $u(x,y) = \\sin(\\pi x)\\sin(\\pi y)$。\n  $$f = -\\Delta u = -(-\\pi^2\\sin(\\pi x)\\sin(\\pi y) - \\pi^2\\sin(\\pi x)\\sin(\\pi y)) = 2\\pi^2\\sin(\\pi x)\\sin(\\pi y)$$\n- **算例 2：** $u(x,y) = x^2 + y^2$。\n  $$f = -\\Delta u = -(2 + 2) = -4$$\n- **算例 3：** $u(x,y) = \\sin(\\frac{\\pi}{2} x)\\sin(\\pi y)$。\n  $$f = -\\Delta u = -(-(\\frac{\\pi}{2})^2\\sin(\\frac{\\pi}{2} x)\\sin(\\pi y) - \\pi^2\\sin(\\frac{\\pi}{2} x)\\sin(\\pi y)) = \\frac{5\\pi^2}{4}\\sin(\\frac{\\pi}{2} x)\\sin(\\pi y)$$\n\n现在，实现将遵循这些步骤来计算每个用例的误差。", "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef solve_poisson_2d(domain, grid_size, u_exact_func, f_func, g_func):\n    \"\"\"\n    Solves the 2D Poisson equation -Delta u = f on a rectangular domain\n    with Dirichlet boundary conditions u = g using a 5-point finite difference\n    stencil and sparse matrix representation.\n\n    Args:\n        domain (tuple): (ax, bx, ay, by) defining the domain [ax, bx] x [ay, by].\n        grid_size (tuple): (Nx, Ny) of interior grid points.\n        u_exact_func (callable): The exact solution u(x, y).\n        f_func (callable): The source term f(x, y).\n        g_func (callable): The Dirichlet boundary condition function g(x, y).\n\n    Returns:\n        float: The discrete L2-error norm of the solution.\n    \"\"\"\n    ax, bx, ay, by = domain\n    Nx, Ny = grid_size\n    N = Nx * Ny\n\n    hx = (bx - ax) / (Nx + 1)\n    hy = (by - ay) / (Ny + 1)\n\n    # Create grid for interior points\n    x_int = np.linspace(ax + hx, bx - hx, Nx)\n    y_int = np.linspace(ay + hy, by - hy, Ny)\n    X_int, Y_int = np.meshgrid(x_int, y_int, indexing='ij')\n\n    # Construct 1D Laplacian matrices\n    diagonals_x = [-1, 2, -1]\n    Ax = sparse.diags(diagonals_x, [-1, 0, 1], shape=(Nx, Nx)) / (hx**2)\n\n    diagonals_y = [-1, 2, -1]\n    Ay = sparse.diags(diagonals_y, [-1, 0, 1], shape=(Ny, Ny)) / (hy**2)\n\n    # Create identity matrices\n    Ix = sparse.identity(Nx)\n    Iy = sparse.identity(Ny)\n\n    # Construct 2D Laplacian matrix using Kronecker product (column-major ordering)\n    A = sparse.kron(Iy, Ax) + sparse.kron(Ay, Ix)\n    A = A.tocsr()\n\n    # Construct the right-hand side (RHS) vector b\n    # 1. Source term f\n    b = f_func(X_int, Y_int).flatten('F') # Use Fortran order for column-major\n\n    # 2. Boundary conditions\n    # We add contributions to b for interior points adjacent to the boundary.\n    \n    # Left and Right boundaries (x=ax, x=bx)\n    y_bnd = np.linspace(ay + hy, by - hy, Ny)\n    g_left = g_func(ax, y_bnd)\n    g_right = g_func(bx, y_bnd)\n    for j in range(Ny):\n        # A point (i=0, j) is adjacent to the left boundary\n        k = 0 + j * Nx\n        b[k] += g_left[j] / hx**2\n        # A point (i=Nx-1, j) is adjacent to the right boundary\n        k = (Nx - 1) + j * Nx\n        b[k] += g_right[j] / hx**2\n        \n    # Bottom and Top boundaries (y=ay, y=by)\n    x_bnd = np.linspace(ax + hx, bx - hx, Nx)\n    g_bottom = g_func(x_bnd, ay)\n    g_top = g_func(x_bnd, by)\n    for i in range(Nx):\n        # A point (i, j=0) is adjacent to the bottom boundary\n        k = i + 0 * Nx\n        b[k] += g_bottom[i] / hy**2\n        # A point (i, j=Ny-1) is adjacent to the top boundary\n        k = i + (Ny - 1) * Nx\n        b[k] += g_top[i] / hy**2\n\n    # Solve the linear system\n    u_vec = spsolve(A, b)\n\n    # Reshape solution vector to 2D grid\n    U_num = u_vec.reshape((Nx, Ny), order='F') # Fortran order for column-major\n\n    # Evaluate exact solution on the interior grid\n    U_exact = u_exact_func(X_int, Y_int)\n\n    # Compute discrete L2 error norm\n    error = np.sqrt(np.sum((U_num - U_exact)**2) * hx * hy)\n\n    return error\n\ndef solve():\n    \"\"\"Defines and runs the test suite.\"\"\"\n    \n    pi = np.pi\n    \n    test_cases = [\n        # Case 1: Happy path, zero Dirichlet BC\n        {\n            \"domain\": (0.0, 1.0, 0.0, 1.0),\n            \"grid_size\": (32, 32),\n            \"u_exact\": lambda x, y: np.sin(pi * x) * np.sin(pi * y),\n            \"f\": lambda x, y: 2 * pi**2 * np.sin(pi * x) * np.sin(pi * y),\n        },\n        # Case 2: Nonzero Dirichlet BC, polynomial solution\n        {\n            \"domain\": (0.0, 1.0, 0.0, 1.0),\n            \"grid_size\": (10, 10),\n            \"u_exact\": lambda x, y: x**2 + y**2,\n            \"f\": lambda x, y: -4.0 * np.ones_like(x),\n        },\n        # Case 3: Anisotropic spacings\n        {\n            \"domain\": (0.0, 2.0, 0.0, 1.0),\n            \"grid_size\": (15, 9),\n            \"u_exact\": lambda x, y: np.sin(pi/2 * x) * np.sin(pi * y),\n            \"f\": lambda x, y: (pi**2 / 4 + pi**2) * np.sin(pi/2 * x) * np.sin(pi * y),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        # For all cases, the boundary condition g is simply the exact solution evaluated on the boundary.\n        g_func = case[\"u_exact\"]\n        \n        error = solve_poisson_2d(\n            domain=case[\"domain\"],\n            grid_size=case[\"grid_size\"],\n            u_exact_func=case[\"u_exact\"],\n            f_func=case[\"f\"],\n            g_func=g_func\n        )\n        results.append(error)\n\n    # Format the final output string as required.\n    formatted_results = ','.join([f\"{r:.8f}\" for r in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```", "id": "2438628"}, {"introduction": "我们构建的求解器看似通用，但它对所有类型的物理特征都同样准确吗？本练习旨在通过实验揭示标准五点格式的一个固有局限性：网格各向异性（grid-aligned anisotropy）。通过对比求解器在处理与网格轴对齐的特征和与网格对角线对齐的特征时的精度差异，你将定量地发现该格式的误差具有方向依赖性 [@problem_id:2393578]。这个实践让你明白，选择离散格式不仅要考虑其精度阶数，还需评估其在模拟没有特定方向偏好的物理问题时的公正性。", "problem": "考虑单位正方形域上的二维泊松方程，其解具有强但平滑的特征，主方向与网格轴对齐或沿对角线方向。该数学模型是针对 $[0,1]\\times[0,1]$ 上标量场 $u(x,y)$ 的边值问题，\n$$- \\nabla^2 u(x,y) = f(x,y), \\quad (x,y)\\in (0,1)\\times(0,1),$$\n边界条件为狄利克雷边界条件 $u(x,y) = u_{\\text{exact}}(x,y)$，作用于边界 $\\partial([0,1]\\times[0,1])$ 上。拉普拉斯算子 $\\nabla^2$ 定义为 $\\nabla^2 u = \\partial^2 u / \\partial x^2 + \\partial^2 u / \\partial y^2$。您必须在均匀网格上使用标准的五点中心差分有限差分法来近似算子 $\\nabla^2$，并求解得到的关于内部网格点上 $u(x,y)$ 的线性系统。\n\n使用人造解法定义两个精确解 $u_{\\text{exact}}(x,y)$，其尖锐度由宽度参数 $\\sigma > 0$ 控制，方向分别为：\n- 与直线 $x=y$ 对齐的对角线脊：\n  $$u_{\\mathrm{diag}}(x,y;\\sigma) = \\exp\\!\\left(-\\frac{(x-y)^2}{2\\sigma^2}\\right)。$$\n- 沿 $x$ 轴方向、以 $x=0.5$ 为中心的轴对齐脊：\n  $$u_{\\mathrm{axis}}(x,y;\\sigma) = \\exp\\!\\left(-\\frac{(x-0.5)^2}{2\\sigma^2}\\right)。$$\n\n对于每个人造解，通过将连续拉普拉斯算子 $\\nabla^2$ 应用于 $u_{\\text{exact}}$ 并设置 $f(x,y) = -\\nabla^2 u_{\\text{exact}}(x,y)$，来计算其连续的右端项 $f(x,y)$。对于对角线脊，请注意 $u_{\\mathrm{diag}}(x,y;\\sigma)$ 仅依赖于 $s=x-y$；对于函数 $g(s)$，使用恒等式 $\\partial^2 g/\\partial x^2 = g''(s)$ 和 $\\partial^2 g/\\partial y^2 = g''(s)$，这两个式子共同意味着 $\\nabla^2 g(s) = 2 g''(s)$。对于轴对齐脊，请注意 $u_{\\mathrm{axis}}(x,y;\\sigma)$ 仅依赖于 $x$，因此 $\\nabla^2 u_{\\mathrm{axis}} = \\partial^2 u_{\\mathrm{axis}}/\\partial x^2$。这些运算都是连续导数；不要使用离散近似来构造 $f(x,y)$。\n\n使用一个包含 $N\\times N$ 个点的均匀笛卡尔网格对域进行离散化，网格间距为 $h = 1/(N-1)$，其中 $N$ 是一个奇数，以确保直线 $y=0.5$ 是一条网格行。在内部点 $(i,j)$ 上组装用于拉普拉斯算子的标准五点格式，通过将边界设置为精确的人造解来施加狄利克雷边界条件。仅使用标准五点格式来建立并求解关于内部未知数的线性系统；不要使用任何更高阶或九点格式。\n\n在同一网格和相同 $\\sigma$ 下，计算出对角线人造解和轴对齐人造解的数值解后，通过插入精确的边界值来重构整个网格。然后，评估以下两种逐线的最大绝对误差：\n- 对角线误差 $E_{\\mathrm{diag}}$：沿离散对角网格线 $x=y$（即索引为 $i=j$ 的节点）的数值解与精确解之间的最大绝对差，并根据该线上的精确最大振幅进行归一化。对于 $u_{\\mathrm{diag}}$，沿 $x=y$ 的线上所有点的精确值均为 $1$。\n- 轴线误差 $E_{\\mathrm{axis}}$：沿水平线 $y=0.5$（即索引为 $j=(N-1)/2$ 的节点）的数值解与精确解之间的最大绝对差，并根据该线上的精确最大振幅进行归一化。对于 $u_{\\mathrm{axis}}$，沿 $y=0.5$ 线的精确峰值出现在 $x=0.5$ 处，值为 $1$。\n\n定义失效比\n$$R(N,\\sigma) = \\frac{E_{\\mathrm{diag}}}{E_{\\mathrm{axis}}}。$$\n当 $R(N,\\sigma) > 1$ 时，表示五点格式对于对角线对齐的尖锐特征产生的误差大于轴对齐特征产生的误差，这表明了网格对齐的各向异性，以及在可比分辨率下未能解析对角线尖锐度的问题。\n\n您的程序必须：\n- 使用相同的网格和 $\\sigma$ 参数，实现五点中心差分法来求解 $u_{\\mathrm{diag}}$ 和 $u_{\\mathrm{axis}}$ 的泊松问题。\n- 为每个测试用例计算 $E_{\\mathrm{diag}}$、$E_{\\mathrm{axis}}$ 和 $R(N,\\sigma)$。\n- 按照下述规定，将所有比率在一行中以单个列表的形式输出。\n\n不涉及物理单位。不使用角度。所有浮点输出均以普通十进制表示法表示。\n\n用于评估覆盖范围的测试套件：\n- 用例 1（分辨率不足的对角线特征）：$N=33$，$\\sigma=0.02$。\n- 用例 2（提高分辨率）：$N=65$，$\\sigma=0.02$。\n- 用例 3（粗网格上更宽的特征）：$N=33$，$\\sigma=0.04$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含与上述用例相对应的三个比率 $R(N,\\sigma)$，形式为用方括号括起来的逗号分隔列表，且每个值都四舍五入到 6 位小数（例如，$[r_1,r_2,r_3]$）。", "solution": "所提出的问题是一个有效且适定的数值分析练习。它涉及使用五点有限差分法求解二维泊松方程，并使用人造解法来分析该格式的各向异性误差特性。所有必需的信息都已提供，其物理和数学基础合理，目标明确且可验证。\n\n该问题是在单位正方形域 $\\Omega = [0,1]\\times[0,1]$ 上求解泊松方程：\n$$ - \\nabla^2 u(x,y) = f(x,y), \\quad (x,y) \\in (0,1)\\times(0,1) $$\n边界条件为狄利克雷边界条件 $u(x,y) = u_{\\text{exact}}(x,y)$，适用于 $(x,y) \\in \\partial\\Omega$。算子 $\\nabla^2$ 是拉普拉斯算子，$\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$。\n\n此处采用了人造解法。我们定义了两个精确解，$u_{\\mathrm{diag}}$ 和 $u_{\\mathrm{axis}}$，并通过应用连续算子 $f = -\\nabla^2 u_{\\text{exact}}$ 来推导相应的右端项函数 $f(x,y)$。\n\n对于对角线脊，$u_{\\mathrm{diag}}(x,y;\\sigma) = \\exp(-\\frac{(x-y)^2}{2\\sigma^2})$。令 $g(s) = \\exp(-s^2/(2\\sigma^2))$，其中 $s=x-y$。其导数为 $g'(s) = -\\frac{s}{\\sigma^2}g(s)$ 和 $g''(s) = (\\frac{s^2}{\\sigma^4} - \\frac{1}{\\sigma^2})g(s)$。使用恒等式 $\\nabla^2 g(x-y) = 2g''(x-y)$，右端项函数为：\n$$ f_{\\mathrm{diag}}(x,y;\\sigma) = -2 g''(x-y) = -2 \\left(\\frac{(x-y)^2}{\\sigma^4} - \\frac{1}{\\sigma^2}\\right) \\exp\\left(-\\frac{(x-y)^2}{2\\sigma^2}\\right) = 2\\left(\\frac{1}{\\sigma^2} - \\frac{(x-y)^2}{\\sigma^4}\\right) \\exp\\left(-\\frac{(x-y)^2}{2\\sigma^2}\\right) $$\n\n对于轴对齐脊，$u_{\\mathrm{axis}}(x,y;\\sigma) = \\exp(-\\frac{(x-0.5)^2}{2\\sigma^2})$。该函数仅依赖于 $x$。令 $h(x) = \\exp(-(x-0.5)^2/(2\\sigma^2))$。拉普拉斯算子为 $\\nabla^2 h(x) = \\frac{d^2h}{dx^2}$。二阶导数为 $\\frac{d^2h}{dx^2} = (\\frac{(x-0.5)^2}{\\sigma^4} - \\frac{1}{\\sigma^2})h(x)$。右端项函数为：\n$$ f_{\\mathrm{axis}}(x,y;\\sigma) = -\\frac{d^2u_{\\mathrm{axis}}}{dx^2} = -\\left(\\frac{(x-0.5)^2}{\\sigma^4} - \\frac{1}{\\sigma^2}\\right) \\exp\\left(-\\frac{(x-0.5)^2}{2\\sigma^2}\\right) = \\left(\\frac{1}{\\sigma^2} - \\frac{(x-0.5)^2}{\\sigma^4}\\right) \\exp\\left(-\\frac{(x-0.5)^2}{2\\sigma^2}\\right) $$\n\n该域使用包含 $N \\times N$ 个点的均匀笛卡尔网格进行离散化，其中 $N$ 是一个奇数。网格间距为 $h = 1/(N-1)$。设网格点为 $(x_i, y_j) = (ih, jh)$，其中 $i,j \\in \\{0, 1, \\dots, N-1\\}$。设 $U_{i,j}$ 为 $u(x_i, y_j)$ 的数值近似。\n\n对于内部网格点 $(x_i, y_j)$（其中 $i,j \\in \\{1, \\dots, N-2\\}$），负拉普拉斯算子的标准五点中心差分近似为：\n$$ -\\nabla^2 u(x_i, y_j) \\approx \\frac{-U_{i+1,j} - U_{i-1,j} - U_{i,j+1} - U_{i,j-1} + 4U_{i,j}}{h^2} $$\n将此式等于右端项 $f(x_i, y_j) = f_{i,j}$，得到离散方程：\n$$ 4U_{i,j} - U_{i+1,j} - U_{i-1,j} - U_{i,j+1} - U_{i,j-1} = h^2 f_{i,j} $$\n必须求解此线性方程组，以得到 $(N-2) \\times (N-2)$ 个未知的内部值 $U_{i,j}$。边界上（$i=0, i=N-1, j=0$ 或 $j=N-1$）的值由狄利克雷条件 $U_{i,j} = u_{\\text{exact}}(x_i, y_j)$ 给出，是已知的。这些已知的边界值被移到与边界相邻的内部点的方程的右侧。\n\n这就形成了一个形式为 $A\\mathbf{u} = \\mathbf{b}$ 的线性系统，其中 $\\mathbf{u}$ 是一个由 $(N-2)^2$ 个未知内部网格值组成的向量，$A$ 是一个大小为 $(N-2)^2 \\times (N-2)^2$ 的稀疏、对称正定、块三对角矩阵，$\\mathbf{b}$ 是包含了右端项 $f$ 和边界条件的右端向量。矩阵 $A$ 的主对角线元素为 $4$，对应于五点格式中四个相邻点的元素为 $-1$。这个稀疏系统通过数值方法求解。\n\n求出内部值后，通过将内部解嵌入到已知的精确边界值中，重构完整的数值解网格。\n\n然后沿特定线评估误差。对于 $u_{\\mathrm{diag}}$ 情况，计算对角线误差 $E_{\\mathrm{diag}}$：\n$$ E_{\\mathrm{diag}} = \\frac{\\max_{i \\in \\{0, \\dots, N-1\\}} |U_{i,i} - u_{\\mathrm{diag}}(x_i, x_i)|}{\\max_{i} u_{\\mathrm{diag}}(x_i, x_i)} = \\max_{i} |U_{i,i} - 1| $$\n对于 $u_{\\mathrm{axis}}$ 情况，沿 $y=0.5$ 线（对应于网格索引 $j_{\\text{mid}} = (N-1)/2$）计算轴线误差 $E_{\\mathrm{axis}}$：\n$$ E_{\\mathrm{axis}} = \\frac{\\max_{i \\in \\{0, \\dots, N-1\\}} |U_{i,j_{\\text{mid}}} - u_{\\mathrm{axis}}(x_i, y_{j_{\\text{mid}}})|}{\\max_{i} u_{\\mathrm{axis}}(x_i, y_{j_{\\text{mid}}})} = \\max_{i} |U_{i,j_{\\text{mid}}} - u_{\\mathrm{axis}}(x_i, y_{j_{\\text{mid}}})| $$\n在这两种情况下，精确解在相应线上的归一化最大振幅均为 $1$。\n\n最后，计算失效比 $R(N,\\sigma) = E_{\\mathrm{diag}} / E_{\\mathrm{axis}}$ 来量化该格式的各向异性误差。所提供的程序为每个指定的测试用例实现了这整个过程。", "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef u_diag_func(X, Y, sigma):\n    \"\"\"Computes the exact solution for the diagonal ridge case.\"\"\"\n    s_sq = (X - Y)**2\n    sigma_sq = sigma**2\n    return np.exp(-s_sq / (2 * sigma_sq))\n\ndef f_diag_func(X, Y, sigma):\n    \"\"\"Computes the forcing term for the diagonal ridge case.\"\"\"\n    s_sq = (X - Y)**2\n    sigma_sq = sigma**2\n    sigma_4 = sigma**4\n    exp_term = np.exp(-s_sq / (2 * sigma_sq))\n    return 2 * (1 / sigma_sq - s_sq / sigma_4) * exp_term\n\ndef u_axis_func(X, Y, sigma):\n    \"\"\"Computes the exact solution for the axis-aligned ridge case.\"\"\"\n    z_sq = (X - 0.5)**2\n    sigma_sq = sigma**2\n    return np.exp(-z_sq / (2 * sigma_sq))\n\ndef f_axis_func(X, Y, sigma):\n    \"\"\"Computes the forcing term for the axis-aligned ridge case.\"\"\"\n    z_sq = (X - 0.5)**2\n    sigma_sq = sigma**2\n    sigma_4 = sigma**4\n    exp_term = np.exp(-z_sq / (2 * sigma_sq))\n    return (1 / sigma_sq - z_sq / sigma_4) * exp_term\n\ndef solve_poisson(N, sigma, u_exact_func, f_func):\n    \"\"\"\n    Solves the 2D Poisson equation using a 5-point finite difference stencil.\n    \"\"\"\n    h = 1.0 / (N - 1)\n    x = np.linspace(0.0, 1.0, N)\n    y = np.linspace(0.0, 1.0, N)\n    X, Y = np.meshgrid(x, y, indexing='xy')\n\n    # Evaluate exact solution and forcing term on the full grid\n    u_exact = u_exact_func(X, Y, sigma)\n    f = f_func(X, Y, sigma)\n    \n    # Number of interior points in one dimension\n    M = N - 2\n    \n    # Construct the sparse matrix A for the linear system\n    main_diag = np.ones(M) * 4\n    off_diag = np.ones(M - 1) * -1\n    T = sparse.diags([off_diag, main_diag, off_diag], [-1, 0, 1], shape=(M, M), format='csr')\n    I_M = sparse.eye(M, format='csr')\n    A = sparse.kron(I_M, T) + sparse.diags([np.ones(M*(M-1))*-1, np.ones(M*(M-1))*-1], [-M, M], format='csr')\n    A = A.tocsc()\n\n    # Construct the right-hand side vector b\n    b_2d = h**2 * f[1:-1, 1:-1]\n    \n    # Add boundary condition contributions to b\n    # Note: U[j, i] corresponds to u at (x_i, y_j)\n    b_2d[:, 0] += u_exact[1:-1, 0]   # Left boundary (x=0)\n    b_2d[:, -1] += u_exact[1:-1, -1] # Right boundary (x=1)\n    b_2d[0, :] += u_exact[0, 1:-1]   # Bottom boundary (y=0)\n    b_2d[-1, :] += u_exact[-1, 1:-1] # Top boundary (y=1)\n    \n    b = b_2d.flatten(order='F') # Flatten column-major, for (i,j) -> k=(i-1)*M+(j-1)\n\n    # Solve the linear system\n    u_vec = spsolve(A, b)\n    \n    # Reshape solution vector to grid and insert into full solution grid\n    U_interior = u_vec.reshape((M, M), order='F')\n    U_numerical = np.copy(u_exact)\n    U_numerical[1:-1, 1:-1] = U_interior\n    \n    return U_numerical, u_exact\n\ndef solve():\n    test_cases = [\n        (33, 0.02),\n        (65, 0.02),\n        (33, 0.04),\n    ]\n\n    results = []\n    for N, sigma in test_cases:\n        # Diagonal case\n        U_diag_numerical, u_exact_diag_grid = solve_poisson(N, sigma, u_diag_func, f_diag_func)\n        diag_numerical = np.diag(U_diag_numerical)\n        diag_exact = np.diag(u_exact_diag_grid)\n        E_diag = np.max(np.abs(diag_numerical - diag_exact))\n\n        # Axis-aligned case\n        U_axis_numerical, u_exact_axis_grid = solve_poisson(N, sigma, u_axis_func, f_axis_func)\n        j_mid = (N - 1) // 2\n        axis_numerical_row = U_axis_numerical[j_mid, :]\n        axis_exact_row = u_exact_axis_grid[j_mid, :]\n        E_axis = np.max(np.abs(axis_numerical_row - axis_exact_row))\n        \n        # Failure ratio\n        R = E_diag / E_axis\n        results.append(R)\n\n    # Format results for printing\n    formatted_results = [f'{r:.6f}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2393578"}]}