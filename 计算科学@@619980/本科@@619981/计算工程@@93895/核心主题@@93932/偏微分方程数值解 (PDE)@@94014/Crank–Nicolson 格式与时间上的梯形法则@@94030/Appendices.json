{"hands_on_practices": [{"introduction": "本次实践是您掌握 Crank-Nicolson 方法的第一步。我们将把它应用于经典的一维热传导方程，从基本原理出发推导该格式。核心挑战在于为您在每个时间步中遇到的三对角线性系统实现一个求解器，从而为隐式方法的实际应用打下坚实的基础。[@problem_id:2397387]", "problem": "您需要编写一个完整、可运行的程序，使用隐式 Crank–Nicolson 方法推进一维热传导方程，并在每个时间步长使用带部分主元的高斯消元法求解所得到的三对角线性系统。请从热传导方程的基本原理、有限差分的定义以及梯形法则出发。考虑一维热传导方程的初边值问题：\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\alpha \\frac{\\partial^2 u}{\\partial x^2}(x,t),\n$$\n其空间域为 $x \\in (0,1)$，时间区间为 $t \\in [0,T]$，并具有齐次 Dirichlet 边界条件：\n$$\nu(0,t) = 0,\\quad u(1,t) = 0 \\quad \\text{for all } t \\ge 0,\n$$\n以及初始条件：\n$$\nu(x,0) = \\sin(\\pi x),\n$$\n其中所有角度均以弧度为单位。参数 $\\alpha$ 是一个正的扩散系数。空间网格使用 $N$ 个内部点，其位置为 $x_i = i h$，其中 $i \\in \\{1,2,\\dots,N\\}$，间距为 $h = 1/(N+1)$。时间网格使用 $M$ 个步长，时间步长为 $\\Delta t$，因此 $t^n = n \\Delta t$，其中 $n \\in \\{0,1,\\dots,M\\}$，且 $T = M \\Delta t$。\n\n请从空间二阶导数的二阶中心差分定义和时间积分的梯形法则定义出发，推导出关联内部值 $u_i^{n+1}$ 和 $u_i^n$（其中 $i \\in \\{1,2,\\dots,N\\}$）的 Crank–Nicolson 更新方程。证明此更新方程在每个时间步都为内部未知量向量 $u^{n+1}$ 定义了一个系数矩阵为三对角矩阵的线性系统。您必须使用带部分主元的高斯消元法 (GEPP) 来实现线性求解器，即在每个消元步骤中，根据当前列中可用的最大绝对值进行行交换。您不能调用任何直接求解线性系统或执行分解的库函数；相反，您必须自己实现 GEPP。\n\n为了验证正确性，请将最终时间 $T$ 的数值解与通过分离变量法针对给定初始条件得到的解析解进行比较，该解析解为：\n$$\nu(x,T) = e^{-\\alpha \\pi^2 T} \\sin(\\pi x).\n$$\n对于下面指定的每个测试用例，计算在时间 $T$ 时内部网格点上的最大绝对误差：\n$$\nE_{\\max} = \\max_{1 \\le i \\le N} \\left| u_i^{\\text{num}}(T) - u(x_i,T) \\right|,\n$$\n并将此值报告为一个无物理单位（无量纲）的浮点数。sin 函数中的所有角度都必须以弧度为单位。您的程序必须打印单行输出，其中包含所有测试用例的结果列表，格式为方括号括起来的逗号分隔列表，每个数字使用科学记数法，小数点后精确到八位（例如，`[1.23456789e-04,2.34567890e-05]`）。不允许有其他输出。\n\n请使用以下测试套件，其中每个元组为 $(\\alpha, N, \\Delta t, T)$，并且在每种情况下 $T/\\Delta t$ 都是整数：\n- 测试 1：$(\\alpha, N, \\Delta t, T) = (1.0, 10, 0.01, 0.10)$。\n- 测试 2：$(\\alpha, N, \\Delta t, T) = (1.0, 2, 0.05, 0.10)$。\n- 测试 3：$(\\alpha, N, \\Delta t, T) = (1.0, 50, 0.001, 0.10)$。\n- 测试 4：$(\\alpha, N, \\Delta t, T) = (0.1, 20, 0.10, 0.50)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，`[r_1,r_2,r_3,r_4]`）。", "solution": "该问题陈述已经过严格验证，被认为是有效的。它具有科学依据、适定、客观、自洽，且没有矛盾或含糊之处。该问题描述了一个标准的一维热传导方程初边值问题，并要求使用自行构建的带部分主元的高斯消元法 (GEPP) 线性求解器来实现 Crank-Nicolson 方法。所有必要的参数和条件都已提供。\n\n问题的核心是求解一维热传导方程：\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}\n$$\nCrank-Nicolson 方法是通过对时间积分应用梯形法则和对空间导数应用二阶中心差分来推导的。时间导数在时间区间 $[t^n, t^{n+1}]$ 的中点处近似：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} \\approx \\left. \\frac{\\partial u}{\\partial t} \\right|_{x_i, t^{n+1/2}}\n$$\n其中 $u_i^n$ 是 $u(x_i, t^n)$ 的数值近似。梯形法则通过平均右端项在时间 $t^n$ 和 $t^{n+1}$ 的值来近似它：\n$$\n\\left. \\alpha \\frac{\\partial^2 u}{\\partial x^2} \\right|_{x_i, t^{n+1/2}} \\approx \\frac{\\alpha}{2} \\left( \\left. \\frac{\\partial^2 u}{\\partial x^2} \\right|_{x_i, t^n} + \\left. \\frac{\\partial^2 u}{\\partial x^2} \\right|_{x_i, t^{n+1}} \\right)\n$$\n空间二阶导数使用二阶中心差分格式来近似：\n$$\n\\left. \\frac{\\partial^2 u}{\\partial x^2} \\right|_{x_i} \\approx \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2}\n$$\n其中 $h$ 是空间步长。结合这些近似，得到 Crank-Nicolson 有限差分方程：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\frac{\\alpha}{2h^2} \\left( (u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}) + (u_{i-1}^n - 2u_i^n + u_{i+1}^n) \\right)\n$$\n令无量纲参数为 $\\lambda = \\frac{\\alpha \\Delta t}{h^2}$。我们重新整理方程，将时间层 $n+1$ 的未知项置于左侧 (LHS)，将时间层 $n$ 的已知项置于右侧 (RHS)：\n$$\n-\\frac{\\lambda}{2} u_{i-1}^{n+1} + (1 + \\lambda) u_i^{n+1} - \\frac{\\lambda}{2} u_{i+1}^{n+1} = \\frac{\\lambda}{2} u_{i-1}^n + (1 - \\lambda) u_i^n + \\frac{\\lambda}{2} u_{i+1}^n\n$$\n此方程对所有内部网格点 $i \\in \\{1, 2, \\dots, N\\}$ 均有效。齐次 Dirichlet 边界条件意味着对所有 $n$，都有 $u_0^n = u_{N+1}^n = 0$。\n\n这个关于内部值未知向量 $\\mathbf{u}^{n+1} = [u_1^{n+1}, \\dots, u_N^{n+1}]^T$ 的 $N$ 个线性方程组可以写成矩阵形式 $A \\mathbf{u}^{n+1} = B \\mathbf{u}^n$。代表左侧的矩阵 $A$ 是一个 $N \\times N$ 的对称三对角矩阵：\n$$\nA = \\begin{pmatrix}\n1+\\lambda & -\\lambda/2 & 0 & \\dots & 0 \\\\\n-\\lambda/2 & 1+\\lambda & -\\lambda/2 & \\dots & 0 \\\\\n0 & \\ddots & \\ddots & \\ddots & 0 \\\\\n\\vdots & & -\\lambda/2 & 1+\\lambda & -\\lambda/2 \\\\\n0 & \\dots & 0 & -\\lambda/2 & 1+\\lambda\n\\end{pmatrix}\n$$\n类似地，作用于已知向量 $\\mathbf{u}^n$ 的矩阵 $B$ 也是一个 $N \\times N$ 的对称三对角矩阵：\n$$\nB = \\begin{pmatrix}\n1-\\lambda & \\lambda/2 & 0 & \\dots & 0 \\\\\n\\lambda/2 & 1-\\lambda & \\lambda/2 & \\dots & 0 \\\\\n0 & \\ddots & \\ddots & \\ddots & 0 \\\\\n\\vdots & & \\lambda/2 & 1-\\lambda & \\lambda/2 \\\\\n0 & \\dots & 0 & \\lambda/2 & 1-\\lambda\n\\end{pmatrix}\n$$\n在每个时间步，我们必须求解线性系统 $A \\mathbf{u}^{n+1} = \\mathbf{d}^n$，其中右端项向量是 $\\mathbf{d}^n = B \\mathbf{u}^n$。根据要求，该系统将使用带部分主元的高斯消元法 (GEPP) 求解。GEPP 算法包括两个阶段：向前消元和回代。\n在向前消元阶段，对于从 $0$ 到 $N-2$ 的每一列 $k$：\n$1$. 我们在当前列 $k$ 中从第 $k$ 行向下搜索绝对值最大的元素。该元素是主元。\n$2$. 包含主元的行与当前第 $k$ 行进行交换。这个步骤，即部分主元法，增强了数值稳定性。\n$3$. 通过从后续行中减去主元行的适当倍数，来消除列 $k$ 中主元下方的元素。\n向前消元后，矩阵 $A$ 被转换为一个上三角矩阵 $U$。系统变为 $U \\mathbf{u}^{n+1} = \\mathbf{d}'$，其中 $\\mathbf{d}'$是相应转换后的右端项向量。\n然后，回代阶段求解这个上三角系统，从最后一个未知数 $u_N^{n+1}$ 开始，逐步求解其他未知数，直到 $u_1^{n+1}$。\n\n总体算法流程如下：\n$1$. 离散化求解域：定义空间步长 $h = 1/(N+1)$ 和时间步数 $M = T/\\Delta t$。\n$2$. 使用初始条件 $u(x,0) = \\sin(\\pi x)$ 在内部网格点 $x_i = ih$（$i=1,\\dots,N$）上初始化解向量 $\\mathbf{u}^0$。\n$3$. 构建常数矩阵 $A$。\n$4$. 对 $n$ 从 $0$ 到 $M-1$ 进行循环：\n    a. 计算右端项向量 $\\mathbf{d}^n = B \\mathbf{u}^n$。\n    b. 使用自行实现的 GEPP 求解系统 $A \\mathbf{u}^{n+1} = \\mathbf{d}^n$ 以得到 $\\mathbf{u}^{n+1}$。\n    c. 为下一次迭代更新解：$\\mathbf{u}^n \\leftarrow \\mathbf{u}^{n+1}$。\n$5$. 循环结束后，最终向量 $\\mathbf{u}^M$ 是时间 $T$ 时的数值解。\n$6$. 通过与给定的解析解 $u(x,T) = e^{-\\alpha \\pi^2 T} \\sin(\\pi x)$ 进行比较，计算最大绝对误差 $E_{\\max} = \\max_{1 \\le i \\le N} |u_i^M - u(x_i, T)|$。\n对提供的每个测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_gepp(A, b):\n    \"\"\"\n    Solves the linear system Ax = b using Gaussian Elimination with Partial Pivoting.\n\n    Args:\n        A (np.ndarray): The N x N coefficient matrix.\n        b (np.ndarray): The N-element right-hand side vector.\n\n    Returns:\n        np.ndarray: The solution vector x.\n    \"\"\"\n    n = len(b)\n    # Create an augmented matrix to work on\n    Ab = np.hstack([A.astype(float), b.reshape(-1, 1).astype(float)])\n\n    # Forward elimination\n    for k in range(n - 1):\n        # Partial Pivoting: find the row with the largest pivot\n        pivot_row = k\n        for i in range(k + 1, n):\n            if abs(Ab[i, k]) > abs(Ab[pivot_row, k]):\n                pivot_row = i\n        \n        # Swap rows if necessary\n        if pivot_row != k:\n            Ab[[k, pivot_row]] = Ab[[pivot_row, k]]\n\n        pivot_val = Ab[k, k]\n        # Check for singularity (not expected in this problem, but good practice)\n        if abs(pivot_val)  1e-15:\n            # For a strictly diagonally dominant matrix, this should not occur.\n            raise ValueError(\"Matrix is singular or near-singular.\")\n\n        # Elimination\n        for i in range(k + 1, n):\n            factor = Ab[i, k] / pivot_val\n            Ab[i, k:] -= factor * Ab[k, k:]\n\n    # Backward substitution\n    x = np.zeros(n)\n    for i in range(n - 1, -1, -1):\n        sum_ax = np.dot(Ab[i, i + 1:n], x[i + 1:n])\n        x[i] = (Ab[i, n] - sum_ax) / Ab[i, i]\n        \n    return x\n\ndef run_simulation(alpha, N, dt, T):\n    \"\"\"\n    Runs the Crank-Nicolson simulation for the 1D heat equation.\n\n    Args:\n        alpha (float): The thermal diffusivity.\n        N (int): The number of interior spatial points.\n        dt (float): The time step size.\n        T (float): The final time.\n\n    Returns:\n        float: The maximum absolute error at the final time T.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    num_steps = int(round(T / dt))\n    \n    # Spatial grid (interior points only)\n    x = np.linspace(h, 1.0 - h, N)\n\n    # Dimensionless parameter lambda\n    lambda_val = alpha * dt / (h * h)\n\n    # Initial condition\n    u_current = np.sin(np.pi * x)\n\n    # Construct matrix A (LHS)\n    A = np.zeros((N, N))\n    diag_A = 1.0 + lambda_val\n    off_diag_A = -lambda_val / 2.0\n    for i in range(N):\n        A[i, i] = diag_A\n        if i > 0:\n            A[i, i - 1] = off_diag_A\n        if i  N - 1:\n            A[i, i + 1] = off_diag_A\n            \n    # Time-stepping loop\n    for _ in range(num_steps):\n        # Construct RHS vector d = B * u_current\n        d = np.zeros(N)\n        diag_B = 1.0 - lambda_val\n        off_diag_B = lambda_val / 2.0\n        \n        # First element\n        if N > 1:\n            d[0] = diag_B * u_current[0] + off_diag_B * u_current[1]\n        else: # N=1 case\n            d[0] = diag_B * u_current[0]\n        \n        # Middle elements\n        for i in range(1, N - 1):\n            d[i] = off_diag_B * u_current[i - 1] + diag_B * u_current[i] + off_diag_B * u_current[i + 1]\n        \n        # Last element\n        if N > 1:\n            d[N - 1] = off_diag_B * u_current[N - 2] + diag_B * u_current[N - 1]\n\n        # Solve the linear system A * u_next = d\n        u_next = solve_gepp(A, d)\n        \n        u_current = u_next\n\n    # Final numerical solution\n    u_numerical = u_current\n\n    # Analytic solution at time T\n    u_analytic = np.exp(-alpha * np.pi**2 * T) * np.sin(np.pi * x)\n\n    # Calculate maximum absolute error\n    max_error = np.max(np.abs(u_numerical - u_analytic))\n    \n    return max_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # (alpha, N, dt, T)\n    test_cases = [\n        (1.0, 10, 0.01, 0.10),\n        (1.0, 2, 0.05, 0.10),\n        (1.0, 50, 0.001, 0.10),\n        (0.1, 20, 0.10, 0.50),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, N, dt, T = case\n        error = run_simulation(alpha, N, dt, T)\n        results.append(error)\n\n    # Format the output as specified\n    formatted_results = [f\"{res:.8e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2397387"}, {"introduction": "虽然 Crank-Nicolson 格式是无条件稳定的，但这种稳定性并不总能保证解的物理真实性，尤其是在时间步长较大时。本练习将揭示一个关键现象：伪振荡的出现。通过模拟一个非光滑初始剖面的热扩散过程，您将研究大的扩散数 $r = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$ 如何在稳定格式下仍然导致非物理结果。[@problem_id:2443615]", "problem": "考虑一维热方程\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in (0,1), \\quad t > 0,\n$$\n其齐次狄利克雷边界条件为\n$$\nu(0,t) = 0, \\quad u(1,t) = 0, \\quad t \\ge 0,\n$$\n初始条件由一个紧支集高帽剖面给出\n$$\nu(x,0) = \\begin{cases}\n1,  |x - 1/2| \\le w/2 \\\\\n0,  \\text{其他情况}\n\\end{cases}\n$$\n其中宽度为 $w = 0.1$。在 $[0,1]$ 上使用一个包含 $M$ 个相等子区间的均匀空间网格，因此空间步长为 $\\Delta x = 1/M$，网格点为 $x_i = i \\,\\Delta x$，其中 $i = 0,1,\\ldots,M$。内部未知数位于索引 $i = 1,2,\\ldots,M-1$ 处。时间积分将通过对空间上二阶中心有限差分产生的半离散系统应用时间上的梯形法则（也称为 Crank–Nicolson 格式）来执行。设扩散数为\n$$\nr = \\frac{\\alpha \\,\\Delta t}{(\\Delta x)^2},\n$$\n其中 $\\alpha = 1$ 为固定值。通过由指定 $r$ 值决定的恒定时间步长 $\\Delta t$，将数值解从 $t=0$ 演化到 $t = T_{\\text{end}}$。目标是检测在 $r$ 较大时可能出现的时间上物理不准确的振荡，其表现为尽管在给定条件下精确解在 $t>0$ 时保持非负，数值解中却出现了负值。\n\n对于给定的参数集，定义一个“检测到振荡”的布尔值如下：在每个时间步之后，如果在任何时间 $t \\in (0, T_{\\text{end}}]$，任何内部网格值严格低于 $-10^{-10}$ 的容差阈值，则将该布尔值设置为 $\\text{True}$；否则设置为 $\\text{False}$。在 $x=0$ 和 $x=1$ 处的边界值固定为 $0$，不应用于检测标准。\n\n您的程序必须为以下参数值 $(M, r, T_{\\text{end}})$ 的测试套件实现上述数学模型和检测规则，其中 $\\alpha = 1$ 和 $w = 0.1$ 保持固定：\n- 测试 A (正常路径，小扩散数): $(M, r, T_{\\text{end}}) = (100, 0.1, 0.05)$。\n- 测试 B (接近符号改变阈值的边界状态): $(M, r, T_{\\text{end}}) = (100, 0.5, 0.05)$。\n- 测试 C (中等大的扩散数): $(M, r, T_{\\text{end}}) = (100, 0.6, 0.05)$。\n- 测试 D (非常大的扩散数): $(M, r, T_{\\text{end}}) = (100, 5.0, 0.05)$。\n\n对于每个测试，唯一的结果是如上定义的布尔值“检测到振荡”。您的程序应生成单行输出，其中包含测试 A–D 的四个布尔结果，按顺序以逗号分隔的列表形式放在方括号内（例如，`[False,True,True,False]`）。输出中不需要物理单位。不涉及角度。不涉及百分比。输出必须严格遵守指定格式。", "solution": "所提出的问题是有效的。这是一个在计算科学领域中定义明确的问题，基于偏微分方程数值分析的基本原理。所有必要的参数和条件都已提供，不存在科学或逻辑上的矛盾。我们将继续进行求解。\n\n该问题要求对一维热方程进行数值求解：\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in (0,1), \\quad t > 0\n$$\n热扩散系数给定为 $\\alpha = 1$。边界条件为齐次狄利克雷类型：\n$$\nu(0,t) = 0, \\quad u(1,t) = 0, \\quad t \\ge 0\n$$\n初始条件是宽度为 $w = 0.1$ 的高帽函数：\n$$\nu(x,0) = \\begin{cases}\n1,  \\text{if } |x - 1/2| \\le 0.1/2 \\\\\n0,  \\text{otherwise}\n\\end{cases}\n$$\n这对应于在 $x \\in [0.45, 0.55]$ 上 $u(x,0)=1$。\n\n首先，我们进行空间上的半离散化。空间域 $[0,1]$ 被离散化为 $M$ 个等长的子区间，长度为 $\\Delta x = 1/M$。网格点为 $x_i = i \\Delta x$，其中 $i = 0, 1, \\ldots, M$。令 $u_i(t)$ 为 $u(x_i, t)$ 的数值近似。二阶空间导数使用二阶中心差分公式进行近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x=x_i} \\approx \\frac{u_{i+1}(t) - 2u_i(t) + u_{i-1}(t)}{(\\Delta x)^2}\n$$\n将此应用于内部网格点 $i = 1, 2, \\ldots, M-1$，我们得到一个常微分方程组 (ODEs)：\n$$\n\\frac{d u_i}{dt} = \\frac{\\alpha}{(\\Delta x)^2} (u_{i+1} - 2u_i + u_{i-1})\n$$\n令 $\\mathbf{u}(t) = [u_1(t), u_2(t), \\ldots, u_{M-1}(t)]^T$ 为内部点上的解向量。该常微分方程组可以写成矩阵形式：\n$$\n\\frac{d\\mathbf{u}}{dt} = \\frac{\\alpha}{(\\Delta x)^2} L_{1D} \\mathbf{u}\n$$\n其中 $L_{1D}$ 是一个 $(M-1) \\times (M-1)$ 的三对角矩阵，表示带有齐次狄利克雷边界条件的离散拉普拉斯算子：\n$$\nL_{1D} = \\begin{pmatrix}\n-2  1  0  \\dots  0 \\\\\n1  -2  1  \\dots  0 \\\\\n0  1  -2  \\dots  0 \\\\\n\\vdots  \\ddots  \\ddots  \\ddots  \\vdots \\\\\n0  \\dots  0  1  -2\n\\end{pmatrix}\n$$\n\n接下来，我们使用梯形法则（也称为 Crank-Nicolson 方法）在时间上进行离散化。给定时间步长 $\\Delta t$，令 $\\mathbf{u}^n$ 表示在时间 $t_n = n \\Delta t$ 的解向量。该格式为：\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2} \\left( \\frac{\\alpha}{(\\Delta x)^2} L_{1D} \\mathbf{u}^{n+1} + \\frac{\\alpha}{(\\Delta x)^2} L_{1D} \\mathbf{u}^n \\right)\n$$\n引入扩散数 $r = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$，我们可以重新整理方程以求解 $\\mathbf{u}^{n+1}$：\n$$\n\\left(I - \\frac{r}{2} L_{1D}\\right) \\mathbf{u}^{n+1} = \\left(I + \\frac{r}{2} L_{1D}\\right) \\mathbf{u}^n\n$$\n其中 $I$ 是 $(M-1) \\times (M-1)$ 的单位矩阵。在每个时间步，我们必须求解一个形式为 $A \\mathbf{x} = \\mathbf{b}$ 的线性系统，其中：\n- 系统矩阵是 $A_{CN} = I - \\frac{r}{2} L_{1D}$。\n- 未知向量是 $\\mathbf{x} = \\mathbf{u}^{n+1}$。\n- 右端向量是 $\\mathbf{b}_{CN} = (I + \\frac{r}{2} L_{1D}) \\mathbf{u}^n$。\n\n矩阵 $A_{CN}$ 是三对角的，主对角线上的元素为 $(1+r)$，次对角线和超对角线上的元素为 $-r/2$。对于任何 $r > 0$，该系统都是非奇异且对角占优的，因此可以使用处理三对角系统的算法（如 Thomas 算法）高效求解。\n\n模拟过程如下：\n1.  对每个由 $(M, r, T_{\\text{end}})$ 指定的测试用例，我们设置 $\\alpha=1$ 和 $w=0.1$。\n2.  空间步长为 $\\Delta x = 1/M$。时间步长由扩散数决定，即 $\\Delta t = r (\\Delta x)^2 / \\alpha$。\n3.  通过在内部网格点 $x_i$（其中 $i=1, \\ldots, M-1$）上对高帽函数进行采样来构建初始解向量 $\\mathbf{u}^0$。\n4.  构建用于 Crank-Nicolson 步骤的矩阵。左侧矩阵 $A_{CN}$ 在整个模拟过程中保持不变。\n5.  一个时间步进循环将解从 $t=0$ 演化到 $t=T_{\\text{end}}$。在每一步中：\n    a. 通过将算子 $(I + \\frac{r}{2} L_{1D})$ 应用于当前解 $\\mathbf{u}^n$ 来计算右端向量 $\\mathbf{b}_{CN}$。\n    b. 求解线性系统 $A_{CN} \\mathbf{u}^{n+1} = \\mathbf{b}_{CN}$ 以得到 $\\mathbf{u}^{n+1}$。\n    c. 检查新的解向量 $\\mathbf{u}^{n+1}$ 是否存在振荡。如果其任何分量小于容差 $-10^{-10}$，则将一个布尔标志 `oscillation_detected` 设置为 `True`，并终止此测试用例的模拟。\n6.  如果时间循环完成而标志未被设置，则其值保持为 `False`。\n\nCrank-Nicolson 格式对于任何 $r > 0$ 在 $L_2$ 范数意义下都是无条件稳定的。然而，对于非光滑的初始条件，除非时间步长足够小，否则它可能无法保持正性，并可能引入伪振荡。对非负性进行的傅里叶稳定性分析表明，如果所有模式的放大因子都非负，则可以避免振荡。对于最高频率的模式，这导致条件 $1 - 2r \\ge 0$，即 $r \\le 0.5$。因此，我们预期对于 $r > 0.5$ 的测试用例将检测到振荡。具体来说，对于测试 C ($r=0.6$) 和测试 D ($r=5.0$)，我们期望会发现负值。对于测试 A ($r=0.1$) 和测试 B ($r=0.5$)，我们期望解将保持非负。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n\n    def run_simulation(M, r, T_end, alpha, w):\n        \"\"\"\n        Solves the 1D heat equation using the Crank-Nicolson method for one set of parameters.\n\n        Args:\n            M (int): Number of spatial subintervals.\n            r (float): Diffusion number.\n            T_end (float): End time for the simulation.\n            alpha (float): Thermal diffusivity.\n            w (float): Width of the initial top-hat profile.\n\n        Returns:\n            bool: True if oscillations are detected, False otherwise.\n        \"\"\"\n        # --- 1. Setup simulation parameters ---\n        dx = 1.0 / M\n        dt = r * dx**2 / alpha\n        num_steps = int(np.ceil(T_end / dt))\n        tol = -1.0e-10\n        \n        # --- 2. Create spatial grid and initial condition ---\n        # Grid consists of M-1 interior points.\n        x_interior = np.linspace(dx, 1.0 - dx, M - 1)\n        \n        u = np.zeros(M - 1)\n        left_bound = 0.5 - w / 2.0\n        right_bound = 0.5 + w / 2.0\n        \n        # Set initial condition u(x,0) based on the top-hat profile.\n        # N.B. Using a small epsilon for float comparison safety is good practice,\n        # but for M=100, the boundaries 0.45 and 0.55 are exact grid points.\n        u[(x_interior >= left_bound)  (x_interior = right_bound)] = 1.0\n        \n        # --- 3. Construct matrices for the Crank-Nicolson scheme ---\n        # The scheme is (I - r/2 * L) u_next = (I + r/2 * L) u_current\n        # Let A = (I - r/2 * L) and B = (I + r/2 * L). We solve A * u_next = B * u_current.\n        \n        # A matrix in banded form for Scipy's solver.\n        # It has 1 lower, 1 upper diagonal. Shape (3, M-1).\n        # Row 0: super-diagonal, Row 1: main diagonal, Row 2: sub-diagonal.\n        A_banded = np.zeros((3, M - 1))\n        A_banded[0, 1:] = -r / 2.0\n        A_banded[1, :] = 1.0 + r\n        A_banded[2, :-1] = -r / 2.0\n        \n        # --- 4. Time-stepping loop ---\n        u_current = u\n        oscillation_detected = False\n        \n        for _ in range(num_steps):\n            # Calculate the right-hand side vector: rhs = B * u_current\n            # B is tridiagonal with (1-r) on the main diagonal and r/2 on off-diagonals.\n            # We compute the matrix-vector product efficiently without forming B.\n            rhs = np.zeros(M - 1)\n            \n            # For interior points of the u_current vector (indices 1 to M-3)\n            rhs[1:-1] = (r / 2.0) * u_current[:-2] + \\\n                        (1.0 - r) * u_current[1:-1] + \\\n                        (r / 2.0) * u_current[2:]\n            \n            # Handle endpoints with homogeneous Dirichlet BCs (u_0=0, u_M=0)\n            if M - 1 > 0: # Ensure u_current is not empty\n                rhs[0] = (1.0 - r) * u_current[0] + (r / 2.0) * u_current[1] if M - 1 > 1 else (1.0 - r) * u_current[0]\n            if M - 1 > 1:\n                rhs[-1] = (r / 2.0) * u_current[-2] + (1.0 - r) * u_current[-1]\n            \n            # Solve the tridiagonal system A * u_next = rhs\n            u_next = solve_banded((1, 1), A_banded, rhs)\n            \n            # Check for oscillations\n            if np.any(u_next  tol):\n                oscillation_detected = True\n                break\n            \n            u_current = u_next\n            \n        return oscillation_detected\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (100, 0.1, 0.05),  # Test A\n        (100, 0.5, 0.05),  # Test B\n        (100, 0.6, 0.05),  # Test C\n        (100, 5.0, 0.05),  # Test D\n    ]\n\n    # Fixed parameters\n    alpha = 1.0\n    w = 0.1\n    \n    results = []\n    for case in test_cases:\n        M, r, T_end = case\n        result = run_simulation(M, r, T_end, alpha, w)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2443615"}, {"introduction": "我们如何确定我们的数值代码是正确的？本实践将向您介绍“制造解方法”（Method of Manufactured Solutions, MMS），这是一种严谨的代码验证技术。您将设计一个解析解，为热传导方程导出相应的源项，然后用您的代码求解这个“制造”出来的问题，以验证其是否达到了预期的二阶精度。[@problem_id:2445001]", "problem": "您将应用制造解方法 (MMS) 来验证一个用于瞬态热方程的一维数值求解器。考虑在有限区间上的带有源项的无量纲热方程，\n$$\nu_t = \\alpha\\,u_{xx} + s(x,t), \\quad x \\in [0,L], \\ t \\in [0,T],\n$$\n该方程具有狄利克雷边界条件和已知的初始条件。制造解方法 (MMS) 要求选择一个光滑的精确解 $u_m(x,t)$，将其代入微分方程中，并定义源项 $s(x,t)$，使得 $u_m(x,t)$ 恒等地满足该方程。这通过将数值解与 $u_m(x,t)$ 进行比较，实现了客观的代码验证。\n\n使用制造解\n$$\nu_m(x,t) = e^{-k t}\\,\\cos(a x),\n$$\n其中 $a \\ge 0$ 和 $k \\ge 0$ 是实数参数，且 $\\cos(\\cdot)$ 的参数以弧度为单位。所有量均为无量纲。任务是：\n\n- 仅使用微积分和微分算子定义，推导由所选 $u_m(x,t)$ 蕴含的源项 $s(x,t)$。\n- 使用时间上的 Crank–Nicolson 方法和空间上均匀网格的二阶中心差分来离散化偏微分方程。从 $u_m(x,t)$ 施加狄利克雷边界条件，并从 $u(x,0)=u_m(x,0)$ 施加初始条件。时间步长 $\\Delta t$ 必须选择与 $\\Delta x$ 成正比，以平衡时间和空间误差。\n- 对于每个测试用例，在两个相继加密的网格上计算最终时刻 $t=T$ 时的数值解，这两个网格的空间区间数量相差2倍，并通过下式估算观测到的精度阶 $p$\n$$\np \\;=\\; \\frac{\\log\\left(E_{\\mathrm{coarse}}/E_{\\mathrm{fine}}\\right)}{\\log(2)},\n$$\n其中 $E$ 是在 $t=T$ 时所有网格节点上的离散均方根误差，\n$$\nE \\;=\\; \\sqrt{\\frac{1}{N+1}\\sum_{j=0}^{N}\\left(u_j^N - u_m(x_j,T)\\right)^2},\n$$\n$N$ 为空间区间的数量，$x_j=j\\,\\Delta x$，$u_j^N$ 为在节点 $j$ 和时间层 $N$ 上的数值解。\n- 您的时间步长选择必须近似满足 $\\Delta t = \\gamma\\,\\Delta x$，这通过取 $N_t = \\lceil T/(\\gamma\\,\\Delta x)\\rceil$ 个时间步长，然后设置 $\\Delta t = T/N_t$ 来实现。使用 Crank–Nicolson 格式，其中源项通过时间上的梯形法则进行评估。\n\n您的推导仅基于以下基本事实：\n- 偏导数的定义以及时间和空间的链式法则。\n- $\\cos(a x)$ 关于空间的二阶导数是 $-a^2 \\cos(a x)$。\n- Crank–Nicolson 方法是应用于半离散系统的梯形法则，且二阶中心差分近似 $u_{xx}$。\n\n角度单位规范：计算 $\\cos(\\cdot)$ 时，其参数以弧度为单位。\n\n测试套件：\n- 案例 1 (一般情况)：$\\alpha=0.7$，$a=3.0$，$k=2.5$，$L=\\pi$，$T=0.2$，$N_{\\text{coarse}}=50$，$\\gamma=0.4$。\n- 案例 2 (弱扩散)：$\\alpha=0.001$，$a=4.0$，$k=0.5$，$L=\\pi$，$T=0.05$，$N_{\\text{coarse}}=60$，$\\gamma=0.4$。\n- 案例 3 (空间常数解)：$\\alpha=0.9$，$a=0.0$，$k=1.2$，$L=1.0$，$T=0.3$，$N_{\\text{coarse}}=40$，$\\gamma=0.4$。\n\n对于每个案例，使用两个网格：具有 $N_{\\text{coarse}}$ 个空间区间的粗网格和具有 $2N_{\\text{coarse}}$ 个区间的细网格，时间步长按所述方式选择。根据在 $t=T$ 时的两个误差计算观测到的精度阶 $p$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含三个案例的观测精度阶，格式为用方括号括起来的逗号分隔列表，每个值四舍五入到三位小数，例如 `[2.001,1.998,2.004]`。", "solution": "首先对问题陈述进行严格验证。\n\n**第 1 步：提取给定信息**\n- **控制方程：** $u_t = \\alpha\\,u_{xx} + s(x,t)$，对于 $x \\in [0,L]$ 和 $t \\in [0,T]$。\n- **制造解：** $u_m(x,t) = e^{-k t}\\,\\cos(a x)$，其中 $a \\ge 0$，$k \\ge 0$。\n- **观测精度阶公式：** $p \\;=\\; \\frac{\\log\\left(E_{\\mathrm{coarse}}/E_{\\mathrm{fine}}\\right)}{\\log(2)}$。\n- **误差度量：** 离散均方根误差为 $E \\;=\\; \\sqrt{\\frac{1}{N+1}\\sum_{j=0}^{N}\\left(u_j^N - u_m(x_j,T)\\right)^2}$。\n- **数值方法：** 时间上采用 Crank–Nicolson 方法，空间上采用二阶中心差分。狄利克雷边界条件和初始条件由 $u_m(x,t)$ 施加。\n- **时间步长规则：** $\\Delta t = \\gamma\\,\\Delta x$ 近似成立，通过 $N_t = \\lceil T/(\\gamma\\,\\Delta x)\\rceil$ 和 $\\Delta t = T/N_t$ 实现。源项使用时间上的梯形法则进行评估。\n- **测试套件：**\n    - 案例 1：$\\alpha=0.7$，$a=3.0$，$k=2.5$，$L=\\pi$，$T=0.2$，$N_{\\text{coarse}}=50$，$\\gamma=0.4$。\n    - 案例 2：$\\alpha=0.001$，$a=4.0$，$k=0.5$，$L=\\pi$，$T=0.05$，$N_{\\text{coarse}}=60$，$\\gamma=0.4$。\n    - 案例 3：$\\alpha=0.9$，$a=0.0$，$k=1.2$，$L=1.0$，$T=0.3$，$N_{\\text{coarse}}=40$，$\\gamma=0.4$。\n\n**第 2 步：使用提取的给定信息进行验证**\n根据已建立的有效性标准对问题陈述进行评估。\n- **科学基础：** 问题基于一维热方程，这是物理学中的一个基本偏微分方程。制造解方法 (MMS) 是计算科学中用于代码验证的一种标准的、公认的技术。指定的数值方法——Crank-Nicolson 和中心差分——是典型的、易于理解的算法。问题在科学上是合理的。\n- **适定性和完整性：** 问题描述了一个适定的初边值问题。所有必要的参数、函数、边界条件和离散化规则都已明确定义。计算观测精度阶的任务是明确的。问题是自洽且完整的。\n- **客观性：** 问题以精确、客观的数学语言陈述，没有主观或模糊的解释。\n\n**第 3 步：结论与行动**\n问题是有效的。这是偏微分方程数值方法验证中的一个标准练习。我们继续进行求解。\n\n**源项的推导**\n\n源项 $s(x,t)$ 的定义是为了确保制造解 $u_m(x,t)$ 恒等地满足偏微分方程。我们重新整理偏微分方程以求解 $s(x,t)$：\n$$\ns(x,t) = u_t - \\alpha\\,u_{xx}\n$$\n制造解为 $u_m(x,t) = e^{-k t}\\,\\cos(a x)$。我们计算它关于时间和空间的偏导数。\n\n关于时间 $t$ 的偏导数是：\n$$\nu_t = \\frac{\\partial}{\\partial t}\\left(e^{-k t}\\,\\cos(a x)\\right) = -k\\,e^{-k t}\\,\\cos(a x)\n$$\n关于空间 $x$的一阶偏导数是：\n$$\nu_x = \\frac{\\partial}{\\partial x}\\left(e^{-k t}\\,\\cos(a x)\\right) = -a\\,e^{-k t}\\,\\sin(a x)\n$$\n关于空间 $x$的二阶偏导数是：\n$$\nu_{xx} = \\frac{\\partial}{\\partial x}\\left(-a\\,e^{-k t}\\,\\sin(a x)\\right) = -a^2\\,e^{-k t}\\,\\cos(a x)\n$$\n将 $u_t$ 和 $u_{xx}$ 的表达式代入 $s(x,t)$ 的方程中，得到：\n$$\ns(x,t) = \\left(-k\\,e^{-k t}\\,\\cos(a x)\\right) - \\alpha\\,\\left(-a^2\\,e^{-k t}\\,\\cos(a x)\\right)\n$$\n提取公因式，我们得到源项的最终表达式：\n$$\ns(x,t) = (\\alpha\\,a^2 - k)\\,e^{-k t}\\,\\cos(a x)\n$$\n\n**数值离散化**\n\n偏微分方程在空间步长为 $\\Delta x = L/N$、时间步长为 $\\Delta t = T/N_t$ 的均匀网格上进行离散化。令 $u_j^n$ 近似网格点 $x_j=j\\Delta x$ 和时间 $t_n=n\\Delta t$ 处的解 $u(x_j, t_n)$。\n\nCrank-Nicolson 方法应用于半离散方程 $u_t = F(u,t)$，其中 $F(u,t) = \\alpha u_{xx} + s(x,t)$。这导致：\n$$\n\\frac{u^{n+1} - u^n}{\\Delta t} = \\frac{1}{2}\\left( F(u^n, t_n) + F(u^{n+1}, t_{n+1}) \\right)\n$$\n空间导数 $u_{xx}$ 使用二阶中心差分进行近似：\n$$\n(u_{xx})_j \\approx \\frac{u_{j+1} - 2u_j + u_{j-1}}{(\\Delta x)^2}\n$$\n将此代入 Crank-Nicolson 格式，得到内部节点 $j \\in \\{1, 2, \\dots, N-1\\}$ 的全离散方程：\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} = \\frac{\\alpha}{2}\\left( \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2} + \\frac{u_{j+1}^{n+1} - 2u_j^{n+1} + u_{j-1}^{n+1}}{(\\Delta x)^2} \\right) + \\frac{1}{2}(s_j^n + s_j^{n+1})\n$$\n其中 $s_j^n = s(x_j, t_n)$。我们重新整理方程，将时间层 $n+1$ 的未知项分组到左侧 (LHS)，将时间层 $n$ 的已知项分组到右侧 (RHS)。定义无量纲参数 $\\lambda = \\frac{\\alpha \\Delta t}{2(\\Delta x)^2}$。\n$$\n-\\lambda u_{j-1}^{n+1} + (1+2\\lambda)u_j^{n+1} - \\lambda u_{j+1}^{n+1} = \\lambda u_{j-1}^n + (1-2\\lambda)u_j^n + \\lambda u_{j+1}^n + \\frac{\\Delta t}{2}(s_j^n + s_j^{n+1})\n$$\n这构成了一个关于内部节点值未知向量 $\\mathbf{u}_{\\text{int}}^{n+1} = [u_1^{n+1}, u_2^{n+1}, \\dots, u_{N-1}^{n+1}]^T$ 的三对角线性方程组。该系统的形式为 $A \\mathbf{u}_{\\text{int}}^{n+1} = \\mathbf{d}$。矩阵 $A$ 是一个 $(N-1) \\times (N-1)$ 的三对角矩阵，其主对角线元素为 $(1+2\\lambda)$，非对角线元素为 $-\\lambda$。\n\n右侧向量 $\\mathbf{d}$ 取决于时间 $n$ 的解和时间 $n+1$ 的边界条件。狄利克雷边界条件由制造解给出：\n$$\nu_0^{n+1} = u_m(0, t_{n+1}) \\quad \\text{和} \\quad u_N^{n+1} = u_m(L, t_{n+1})\n$$\n右侧向量 $\\mathbf{d}$ 的第 $j$ 个分量（对于 $j \\in \\{1, \\dots, N-1\\}$）是：\n$$\nd_{j-1} = \\lambda u_{j-1}^n + (1-2\\lambda)u_j^n + \\lambda u_{j+1}^n + \\frac{\\Delta t}{2}(s_j^n + s_j^{n+1})\n$$\n来自左侧的边界项被移到右侧。对于第一个方程 ($j=1$)，项 $-\\lambda u_0^{n+1}$ 被移动，所以我们将 $\\lambda u_0^{n+1}$ 加到 $d_0$ 上。对于最后一个方程 ($j=N-1$)，项 $-\\lambda u_N^{n+1}$ 被移动，所以我们将 $\\lambda u_N^{n+1}$ 加到 $d_{N-2}$ 上。\n\n总体算法如下：\n1. 对于给定的测试案例，设置参数 $\\alpha, a, k, L, T, N, \\gamma$。\n2. 计算网格参数：$\\Delta x = L/N$，$N_t = \\lceil T/(\\gamma \\Delta x) \\rceil$，$\\Delta t = T/N_t$。\n3. 初始化 $t=0$ 时的解：$u_j^0 = u_m(x_j, 0)$，对于所有 $j \\in \\{0, \\dots, N\\}$。\n4. 构造常数三对角矩阵 $A$。\n5. 从 $n=0$ 迭代到 $N_t-1$：\n    a. 使用解 $u^n$ 和 $t_{n+1}$ 时的边界值构造右侧向量 $\\mathbf{d}$。\n    b. 求解线性系统 $A \\mathbf{u}_{\\text{int}}^{n+1} = \\mathbf{d}$ 以获得内部节点的值。为提高效率，使用专门的三对角求解器。\n    c. 使用新计算的内部值和已知的边界值更新完整的解向量 $u^{n+1}$。\n6. 在最后一个时间步之后，通过将数值解 $u^{N_t}$ 与精确解 $u_m(x, T)$ 进行比较来计算均方根误差 $E$。\n7. 对粗网格 ($N_{\\text{coarse}}$) 和细网格 ($2N_{\\text{coarse}}$) 重复步骤 1-6，以获得 $E_{\\text{coarse}}$ 和 $E_{\\text{fine}}$。\n8. 使用提供的公式计算观测到的精度阶 $p$。\n\nCrank-Nicolson 格式在时间和空间上都是二阶的。当 $\\Delta t \\propto \\Delta x$ 时，期望的精度阶为 $p=2$。这将对所有测试案例进行验证，包括 $a=0$ 的情况，此时空间依赖性消失。对于 $a=0$，空间离散误差恒为零，问题简化为求解一个常微分方程，对此梯形法则 (Crank-Nicolson) 也是二阶精确的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the Method of Manufactured Solutions verification.\n    \"\"\"\n    test_cases = [\n        # Case 1 (general)\n        {'alpha': 0.7, 'a': 3.0, 'k': 2.5, 'L': np.pi, 'T': 0.2, 'N_coarse': 50, 'gamma': 0.4},\n        # Case 2 (weak diffusion)\n        {'alpha': 0.001, 'a': 4.0, 'k': 0.5, 'L': np.pi, 'T': 0.05, 'N_coarse': 60, 'gamma': 0.4},\n        # Case 3 (spatially constant solution)\n        {'alpha': 0.9, 'a': 0.0, 'k': 1.2, 'L': 1.0, 'T': 0.3, 'N_coarse': 40, 'gamma': 0.4},\n    ]\n\n    orders_of_accuracy = []\n\n    for case in test_cases:\n        N_coarse = case['N_coarse']\n        N_fine = 2 * N_coarse\n\n        error_coarse = run_simulation(N=N_coarse, **case)\n        error_fine = run_simulation(N=N_fine, **case)\n\n        # Handle potential zero errors, which can occur with perfect solutions\n        if error_fine == 0.0 or error_coarse == 0.0:\n            # If the solution is exact, the notion of convergence order is moot.\n            # We can consider it to be infinite, but for practical reporting,\n            # a large number or a special value is appropriate.\n            # Given the problem's focus on 2nd-order schemes, a perfect result\n            # far exceeds expectations. Here, we report 0.0 as it implies no error.\n            p = 0.0 \n        else:\n            p = np.log(error_coarse / error_fine) / np.log(2.0)\n        \n        orders_of_accuracy.append(p)\n\n    # Format the final output string\n    formatted_results = [f\"{p:.3f}\" for p in orders_of_accuracy]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_simulation(N, alpha, a, k, L, T, gamma, **kwargs):\n    \"\"\"\n    Runs a single simulation for the 1D heat equation and returns the RMS error.\n    \n    Args:\n        N (int): Number of spatial intervals.\n        alpha (float): Thermal diffusivity.\n        a (float): Spatial frequency in manufactured solution.\n        k (float): Temporal decay rate in manufactured solution.\n        L (float): Length of the spatial domain [0, L].\n        T (float): Final time of the simulation.\n        gamma (float): Proportionality constant for time step (dt ~ gamma * dx).\n\n    Returns:\n        float: The discrete L2 norm of the error at the final time T.\n    \"\"\"\n    # Manufactured solution and its derivatives\n    def u_m(x, t):\n        return np.exp(-k * t) * np.cos(a * x)\n\n    def s(x, t):\n        return (alpha * a**2 - k) * np.exp(-k * t) * np.cos(a * x)\n\n    # Grid parameters\n    dx = L / N\n    # The number of time steps must be an integer, ceil ensures we reach T\n    Nt = int(np.ceil(T / (gamma * dx)))\n    dt = T / Nt\n    x = np.linspace(0.0, L, N + 1)\n    \n    # Crank-Nicolson parameter\n    lambda_cn = alpha * dt / (2.0 * dx**2)\n\n    # Initialize solution u at t=0\n    u_n = u_m(x, 0.0)\n    \n    # Set up the tridiagonal matrix A for the linear system in banded format\n    # The system is for N-1 internal points\n    N_internal = N - 1\n    if N_internal > 0:\n        A_banded = np.zeros((3, N_internal))\n        A_banded[0, 1:] = -lambda_cn  # Upper diagonal\n        A_banded[1, :] = 1.0 + 2.0 * lambda_cn  # Main diagonal\n        A_banded[2, :-1] = -lambda_cn  # Lower diagonal\n\n    # Time-stepping loop\n    for n in range(Nt):\n        t_n = n * dt\n        t_np1 = (n + 1) * dt\n        \n        u_np1 = np.zeros_like(u_n)\n\n        # Boundary conditions at time t_np1\n        u0_np1 = u_m(0.0, t_np1)\n        uN_np1 = u_m(L, t_np1)\n        u_np1[0] = u0_np1\n        u_np1[-1] = uN_np1\n\n        if N_internal > 0:\n            # Construct the RHS vector d\n            u_internal = u_n[1:-1]\n            x_internal = x[1:-1]\n            \n            # Contribution from known solution at time t_n\n            rhs = (lambda_cn * u_n[:-2] +\n                   (1.0 - 2.0 * lambda_cn) * u_internal +\n                   lambda_cn * u_n[2:])\n            \n            # Contribution from source term\n            s_n = s(x_internal, t_n)\n            s_np1 = s(x_internal, t_np1)\n            rhs += (dt / 2.0) * (s_n + s_np1)\n            \n            # Add boundary condition contributions from LHS\n            rhs[0] += lambda_cn * u0_np1\n            rhs[-1] += lambda_cn * uN_np1\n            \n            # Solve the tridiagonal system for internal nodes\n            u_internal_np1 = solve_banded((1, 1), A_banded, rhs)\n            u_np1[1:-1] = u_internal_np1\n        \n        u_n = u_np1\n\n    # Final solution at t=T\n    u_numerical = u_n\n    u_exact = u_m(x, T)\n\n    # Calculate RMS error over all nodes (including boundaries)\n    error = np.sqrt(np.mean((u_numerical - u_exact)**2))\n    \n    return error\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2445001"}]}