{"hands_on_practices": [{"introduction": "守恒形式和非守恒形式的方程在连续形式下可能代数等价，但在数值计算中却有着天壤之别。本练习将直接探讨这种差异在离散层面上的核心。我们将以伯格斯方程（Burgers' equation）为例，通过推导和实现一个守恒的有限体积格式与一个非守恒的有限差分格式，您将从解析上证明并从数值上验证为何前者能够保持总质量守恒，而后者则不能。这项实践旨在为您建立对“离散守恒”真实含义的基础理解。[@problem_id:2379409]", "problem": "考虑在一个周期性一维域 $[0,1)$ 上的标量无粘性 Burgers 方程，它可写成两种代数上等价但在数值上不同的形式：\n1) 守恒形式：$u_t + (f(u))_x = 0$，其中 $f(u) = \\tfrac{u^2}{2}$。\n2) 非守恒形式：$u_t + u\\,u_x = 0$。\n\n您的任务是：\nA) 从积分守恒律和单元平均的观点出发，使用数值界面通量为守恒形式推导一个全离散的有限体积更新格式。在一个包含 $N$ 个宽度为 $\\Delta x = 1/N$ 的单元和周期性边界条件的均匀网格上，使用以下离散更新格式：\n$$\nu_i^{n+1} \\;=\\; u_i^n \\;-\\; \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\tfrac{1}{2}}^n - F_{i-\\tfrac{1}{2}}^n\\right),\n$$\n其中使用 Rusanov (局部 Lax–Friedrichs) 数值通量\n$$\nF_{i+\\tfrac{1}{2}}^n \\;=\\; \\tfrac{1}{2}\\left(f(u_i^n) + f(u_{i+1}^n)\\right) \\;-\\; \\tfrac{1}{2}\\, a_{i+\\tfrac{1}{2}}^n \\left(u_{i+1}^n - u_i^n\\right),\n\\quad f(u) = \\tfrac{u^2}{2},\n\\quad a_{i+\\tfrac{1}{2}}^n = \\max\\left(\\lvert u_i^n\\rvert, \\lvert u_{i+1}^n\\rvert\\right).\n$$\n从第一性原理（周期性网格上的离散散度定理）证明，总离散质量\n$$\nM^n \\;=\\; \\sum_{i=0}^{N-1} u_i^n \\,\\Delta x\n$$\n对所有时间步 $n$ 都是精确守恒的，即 $M^{n+1} = M^n$。\n\nB) 考虑非守恒形式 $u_t + u\\,u_x = 0$，在单元中心进行离散，其中空间导数使用前向有限差分，时间推进使用前向欧拉法：\n$$\nu_i^{n+1} \\;=\\; u_i^n \\;-\\; \\Delta t\\,u_i^n\\,\\frac{u_{i+1}^n - u_i^n}{\\Delta x},\n$$\n使用周期性索引 $u_{N}^n \\equiv u_0^n$。通过将 $M^{n+1} - M^n$ 用离散场 $u_i^n$ 表示，并证明对于一般数据它不为零，从而解析地证明总离散质量 $M^n$ 在此更新下通常不保持不变。\n\nC) 实现任务。编写一个满足以下条件的完整、可运行的程序：\n- 在 $[0,1)$ 上使用周期性边界条件，并使用一个均匀网格，其单元中心位于 $x_i = \\left(i + \\tfrac{1}{2}\\right)\\Delta x$。\n- 对两种更新格式均使用前向欧拉法进行时间推进。\n- 根据 Courant–Friedrichs–Lewy (CFL) 准则在每一步动态选择时间步长\n$$\n\\Delta t \\;=\\; \\text{CFL}\\cdot \\frac{\\Delta x}{\\max_i \\lvert u_i^n\\rvert + 10^{-12}},\n$$\n其中加上一个极小值仅是为了避免除以零。\n- 演化到指定的最终时间 $T$。\n\n测试套件。对于每个测试，返回一个等于质量差 $\\Delta M = M^{\\text{final}} - M^{\\text{initial}}$ 的浮点数。使用以下测试：\n- 测试 1 (守恒格式)：$N = 200$, $\\text{CFL} = 0.9$, $T = 0.1$, 初始条件 $u(x,0) = 0.5 + 0.5\\sin(2\\pi x)$。预期 $\\Delta M$ 因周期性网格上通量差的精确对消求和而约等于机器精度的零。\n- 测试 2 (非守恒格式)：$N = 200$, $\\text{CFL} = 0.4$, $T = 0.1$, 初始条件 $u(x,0) = 0.5 + 0.5\\sin(2\\pi x)$。预期 $\\Delta M$ 为非零值。\n- 测试 3 (非守恒格式)：$N = 200$, $\\text{CFL} = 0.4$, $T = 0.1$, 初始条件 $u(x,0) = \\sin(2\\pi x)$。预期 $\\Delta M$ 为非零值。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表（例如，“[r1,r2,r3]”），其中每个 $r_k$ 是对应测试的浮点数质量差，顺序与上面列出的完全一致。不应打印任何额外文本。此问题中没有物理单位；所有量均为无量纲。", "solution": "对所述问题进行验证。\n\n**步骤 1：提取给定条件**\n- **方程：**\n    1. 守恒形式：$u_t + (\\frac{u^2}{2})_x = 0$。\n    2. 非守恒形式：$u_t + u\\,u_x = 0$。\n- **区域：** 周期性，$[0,1)$。\n- **任务 A (守恒格式)：**\n    - 有限体积更新：$u_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\tfrac{1}{2}}^n - F_{i-\\tfrac{1}{2}}^n\\right)$。\n    - Rusanov 数值通量：$F_{i+\\tfrac{1}{2}}^n = \\tfrac{1}{2}\\left(f(u_i^n) + f(u_{i+1}^n)\\right) - \\tfrac{1}{2}\\, a_{i+\\tfrac{1}{2}}^n \\left(u_{i+1}^n - u_i^n\\right)$，其中 $f(u) = \\tfrac{u^2}{2}$ 且 $a_{i+\\tfrac{1}{2}}^n = \\max\\left(\\lvert u_i^n\\rvert, \\lvert u_{i+1}^n\\rvert\\right)$。\n    - 离散质量：$M^n = \\sum_{i=0}^{N-1} u_i^n \\,\\Delta x$。\n    - 目标：证明 $M^{n+1} = M^n$。\n- **任务 B (非守恒格式)：**\n    - 离散化：$u_i^{n+1} = u_i^n - \\Delta t\\,u_i^n\\,\\frac{u_{i+1}^n - u_i^n}{\\Delta x}$，使用周期性索引 $u_N^n \\equiv u_0^n$。\n    - 目标：证明在一般情况下 $M^{n+1} \\neq M^n$。\n- **任务 C (实现)：**\n    - 网格：均匀网格，含 $N$ 个单元，中心位于 $x_i = \\left(i + \\tfrac{1}{2}\\right)\\Delta x$，其中 $\\Delta x = 1/N$。\n    - 时间步长：$\\Delta t = \\text{CFL}\\cdot \\frac{\\Delta x}{\\max_i \\lvert u_i^n\\rvert + 10^{-12}}$。\n    - 最终时间：$T$。\n- **测试套件：**\n    - 测试 1：守恒格式，$N=200$，$\\text{CFL}=0.9$，$T=0.1$，$u(x,0) = 0.5 + 0.5\\sin(2\\pi x)$。\n    - 测试 2：非守恒格式，$N=200$，$\\text{CFL}=0.4$，$T=0.1$，$u(x,0) = 0.5 + 0.5\\sin(2\\pi x)$。\n    - 测试 3：非守恒格式，$N=200$，$\\text{CFL}=0.4$，$T=0.1$，$u(x,0) = \\sin(2\\pi x)$。\n- **输出：** 每个测试的质量差 $\\Delta M = M^{\\text{final}} - M^{\\text{initial}}$。\n\n**步骤 2：使用提取的给定条件进行验证**\n该问题定义明确、科学上合理且客观。它涉及守恒律数值方法的基本概念，特别是 Burgers 方程的守恒与非守恒离散化之间的区别。进行解析推导和数值实现所需的所有参数和条件均已提供。该问题是计算数学和工程领域的一个标准练习题。\n\n**步骤 3：结论与操作**\n该问题有效。将提供严谨的解答。\n\n---\n\n**A) 守恒格式的质量守恒证明**\n\n在时间步 $n+1$ 的总离散质量定义为\n$$\nM^{n+1} = \\sum_{i=0}^{N-1} u_i^{n+1} \\Delta x.\n$$\n代入 $u_i^{n+1}$ 的有限体积更新法则：\n$$\nM^{n+1} = \\sum_{i=0}^{N-1} \\left[ u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\tfrac{1}{2}}^n - F_{i-\\tfrac{1}{2}}^n\\right) \\right] \\Delta x.\n$$\n分配求和项与 $\\Delta x$ 项：\n$$\nM^{n+1} = \\sum_{i=0}^{N-1} u_i^n \\Delta x - \\Delta t \\sum_{i=0}^{N-1} \\left(F_{i+\\tfrac{1}{2}}^n - F_{i-\\tfrac{1}{2}}^n\\right).\n$$\n第一项是在时间步 $n$ 的总质量 $M^n$。方程变为：\n$$\nM^{n+1} = M^n - \\Delta t \\sum_{i=0}^{N-1} \\left(F_{i+\\tfrac{1}{2}}^n - F_{i-\\tfrac{1}{2}}^n\\right).\n$$\n为证明守恒，我们必须证明求和项为零。该求和是域上散度积分的离散模拟。我们展开此求和：\n$$\n\\sum_{i=0}^{N-1} \\left(F_{i+\\tfrac{1}{2}}^n - F_{i-\\tfrac{1}{2}}^n\\right) = \\left(F_{\\tfrac{1}{2}}^n - F_{-\\tfrac{1}{2}}^n\\right) + \\left(F_{\\tfrac{3}{2}}^n - F_{\\tfrac{1}{2}}^n\\right) + \\left(F_{\\tfrac{5}{2}}^n - F_{\\tfrac{3}{2}}^n\\right) + \\dots + \\left(F_{N-\\tfrac{1}{2}}^n - F_{N-\\tfrac{3}{2}}^n\\right).\n$$\n这是一个对消求和（伸缩求和）。各项成对抵消：来自单元 $i$ 的正项 $F_{i+\\tfrac{1}{2}}^n$ 与来自单元 $j=i+1$ 的负项 $F_{j-\\tfrac{1}{2}}^n$ 相互抵消。我们将其形式化。设数值通量函数为 $\\mathcal{F}(u_L, u_R)$，使得 $F_{i+\\tfrac{1}{2}}^n = \\mathcal{F}(u_i^n, u_{i+1}^n)$。对所有单元 $i = 0, \\dots, N-1$ 的求和为：\n$$\n\\sum_{i=0}^{N-1} \\left( \\mathcal{F}(u_i^n, u_{i+1}^n) - \\mathcal{F}(u_{i-1}^n, u_i^n) \\right).\n$$\n由于周期性边界条件，网格索引在模 $N$ 的意义下解释。具体来说，$u_{N}^n = u_0^n$ 且 $u_{-1}^n = u_{N-1}^n$。\n我们通过重新索引来审视此求和。令 $G_i = \\mathcal{F}(u_{i-1}^n, u_i^n)$。该求和为 $\\sum_{i=0}^{N-1} G_{i+1} - \\sum_{i=0}^{N-1} G_i$。\n我们改变第一个求和中的索引，令 $j=i+1$。当 $i=0$ 时，$j=1$；当 $i=N-1$ 时，$j=N$。所以得到 $\\sum_{j=1}^{N} G_j$。\n该求和变为 $\\sum_{j=1}^{N} G_j - \\sum_{i=0}^{N-1} G_i = (G_1 + \\dots + G_{N-1} + G_N) - (G_0 + G_1 + \\dots + G_{N-1}) = G_N - G_0$。\n根据定义，$G_N = \\mathcal{F}(u_{N-1}^n, u_N^n)$ 且 $G_0 = \\mathcal{F}(u_{-1}^n, u_0^n)$。\n利用周期性，$u_N^n = u_0^n$ 且 $u_{-1}^n = u_{N-1}^n$。\n因此，$G_N = \\mathcal{F}(u_{N-1}^n, u_0^n)$ 且 $G_0 = \\mathcal{F}(u_{N-1}^n, u_0^n)$。\n于是，$G_N - G_0 = 0$。\n在周期性域上，通量差之和恒为零。这是离散环面（discrete torus）上离散散度定理的一种体现。\n因此，\n$$\nM^{n+1} = M^n - \\Delta t \\cdot 0 = M^n.\n$$\n总离散质量在每个时间步都精确守恒，这与一致且守恒的数值通量 $\\mathcal{F}$ 的具体形式无关。证明完毕。\n\n**B) 非守恒格式的质量守恒分析**\n\n非守恒格式由以下更新法则给出：\n$$\nu_i^{n+1} = u_i^n - \\Delta t\\,u_i^n\\,\\frac{u_{i+1}^n - u_i^n}{\\Delta x}.\n$$\n从时间步 $n$ 到 $n+1$ 的总离散质量变化为\n$$\nM^{n+1} - M^n = \\sum_{i=0}^{N-1} \\left(u_i^{n+1} - u_i^n\\right) \\Delta x.\n$$\n代入更新法则中 $u_i^{n+1} - u_i^n$ 的表达式：\n$$\nM^{n+1} - M^n = \\sum_{i=0}^{N-1} \\left( -\\Delta t\\,u_i^n\\,\\frac{u_{i+1}^n - u_i^n}{\\Delta x} \\right) \\Delta x.\n$$\n$\\Delta x$ 项相互抵消：\n$$\nM^{n+1} - M^n = -\\Delta t \\sum_{i=0}^{N-1} u_i^n \\left(u_{i+1}^n - u_i^n\\right).\n$$\n展开求和内的乘积：\n$$\nM^{n+1} - M^n = -\\Delta t \\sum_{i=0}^{N-1} \\left( u_i^n u_{i+1}^n - (u_i^n)^2 \\right) = \\Delta t \\left( \\sum_{i=0}^{N-1} (u_i^n)^2 - \\sum_{i=0}^{N-1} u_i^n u_{i+1}^n \\right).\n$$\n由于周期性边界条件，索引 $i+1$ 在模 $N$ 意义下取值。为使质量守恒，括号中的项必须为零。\n$$\n\\sum_{i=0}^{N-1} (u_i^n)^2 - \\sum_{i=0}^{N-1} u_i^n u_{i+1}^n = 0.\n$$\n对于一般的场数据 $u_i^n$，此条件不成立。考虑一个 $N=2$ 的简单情况。该条件变为：\n$$\n(u_0^n)^2 + (u_1^n)^2 - (u_0^n u_1^n + u_1^n u_0^n) = (u_0^n-u_1^n)^2 = 0,\n$$\n这要求 $u_0^n=u_1^n$。对于一个值不全相等的非平凡场，例如 $u_0^n=1$ 和 $u_1^n=2$，表达式为 $(1-2)^2=1 \\neq 0$。质量不守恒。\n连续方程 $u_t + (u^2/2)_x = 0$ 和 $u_t + u u_x = 0$ 的代数等价性依赖于链式法则，该法则仅对光滑解有效。非守恒形式的离散化不会继承原始积分律的守恒性质，并且在出现间断时无法捕捉正确的物理现象（例如激波速度）。该推导在离散层面证明了这一点。\n\n**C) 数值实现**\n\n实现将包含两个主要函数：一个用于守恒有限体积格式，另一个用于非守恒有限差分格式。两者都将使用前向欧拉法进行时间步进，并根据 CFL 条件动态确定时间步长。\n\n- **网格与状态：**使用 $[0, 1)$ 上的一个包含 $N$ 个单元的均匀网格。状态向量 `u` 存储单元平均值 $u_i$。周期性边界条件通过数组移位操作（例如，`numpy.roll`）来处理。\n- **守恒格式：**更新需要计算每个单元界面上的 Rusanov 通量 $F_{i+\\frac{1}{2}}$。通过创建状态向量 `u` 的移位版本来表示 $u_{i+1}$，从而实现向量化。所有界面的通量被同时计算。$u_i$ 的更新涉及其左右边界的通量差 $F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}$。这也可以通过计算通量向量 `F` 及其移位版本 `numpy.roll(F, 1)` 来实现向量化。\n- **非守恒格式：**更新更简单。空间导数项 $u_x$ 通过前向差分 $\\frac{u_{i+1}-u_i}{\\Delta x}$ 来近似。这通过使用 `numpy.roll` 获得 $u_{i+1}$ 的值来实现向量化。\n- **时间循环：**对于每个测试用例，系统使用给定的初始条件进行初始化，并从 $t=0$ 演化到最终时间 $T$。在每一步中，找到最大波速 $\\max_i|u_i^n|$ 以根据 CFL 准则计算稳定的 $\\Delta t$，同时确保时间步长不超过到达 $T$ 的剩余时间。\n- **质量计算：**在时间循环开始前计算初始质量 $M^{\\text{initial}}$。循环结束后计算最终质量 $M^{\\text{final}}$。然后报告每个测试的质量差 $\\Delta M = M^{\\text{final}} - M^{\\text{initial}}$。对于测试1，预期该值接近机器精度，从而证实了解析证明。对于测试2和3，预期结果为非零值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_conservative(N, CFL, T, u0_func):\n    \"\"\"\n    Solves the Burgers' equation using the conservative finite volume scheme.\n    \"\"\"\n    dx = 1.0 / N\n    x = (np.arange(N) + 0.5) * dx\n    u = u0_func(x)\n\n    M_initial = np.sum(u) * dx\n    \n    t = 0.0\n    while t  T:\n        max_abs_u = np.max(np.abs(u))\n        dt = CFL * dx / (max_abs_u + 1e-12)\n        if t + dt > T:\n            dt = T - t\n        \n        # Periodic boundary conditions via np.roll\n        u_right = np.roll(u, -1) # u_{i+1}\n\n        # Physical flux f(u) = u^2 / 2\n        f_u = 0.5 * u**2\n        f_u_right = 0.5 * u_right**2\n\n        # Rusanov flux (Local Lax-Friedrichs)\n        # a_{i+1/2} = max(|u_i|, |u_{i+1}|)\n        a = np.maximum(np.abs(u), np.abs(u_right))\n        \n        # F_{i+1/2}\n        flux = 0.5 * (f_u + f_u_right) - 0.5 * a * (u_right - u)\n        \n        # F_{i-1/2} via roll\n        flux_left = np.roll(flux, 1)\n\n        # Update u\n        u = u - (dt / dx) * (flux - flux_left)\n        \n        t += dt\n    \n    M_final = np.sum(u) * dx\n    return M_final - M_initial\n\ndef run_nonconservative(N, CFL, T, u0_func):\n    \"\"\"\n    Solves the Burgers' equation using the nonconservative finite difference scheme.\n    \"\"\"\n    dx = 1.0 / N\n    x = (np.arange(N) + 0.5) * dx\n    u = u0_func(x)\n\n    M_initial = np.sum(u) * dx\n\n    t = 0.0\n    while t  T:\n        max_abs_u = np.max(np.abs(u))\n        dt = CFL * dx / (max_abs_u + 1e-12)\n        if t + dt > T:\n            dt = T - t\n        \n        # Periodic boundary conditions for u_{i+1}\n        u_right = np.roll(u, -1)\n\n        # Forward difference for u_x\n        ux = (u_right - u) / dx\n\n        # Update u\n        u = u - dt * u * ux\n        \n        t += dt\n\n    M_final = np.sum(u) * dx\n    return M_final - M_initial\n\n\ndef solve():\n    \"\"\"\n    Executes the test suite and prints the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"scheme\": \"conservative\",\n            \"N\": 200, \"CFL\": 0.9, \"T\": 0.1,\n            \"u0_func\": lambda x: 0.5 + 0.5 * np.sin(2 * np.pi * x)\n        },\n        {\n            \"scheme\": \"nonconservative\",\n            \"N\": 200, \"CFL\": 0.4, \"T\": 0.1,\n            \"u0_func\": lambda x: 0.5 + 0.5 * np.sin(2 * np.pi * x)\n        },\n        {\n            \"scheme\": \"nonconservative\",\n            \"N\": 200, \"CFL\": 0.4, \"T\": 0.1,\n            \"u0_func\": lambda x: np.sin(2 * np.pi * x)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        if case[\"scheme\"] == \"conservative\":\n            delta_M = run_conservative(case[\"N\"], case[\"CFL\"], case[\"T\"], case[\"u0_func\"])\n        else:\n            delta_M = run_nonconservative(case[\"N\"], case[\"CFL\"], case[\"T\"], case[\"u0_func\"])\n        results.append(delta_M)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2379409"}, {"introduction": "在理解了离散守恒的数学性质之后，下一个关键问题是它的物理意义。此练习专注于使用非守恒格式最严重的后果：对激波（shock wave）传播速度的错误预测。源自守恒律积分形式的兰金-雨果尼奥条件（Rankine-Hugoniot condition）决定了间断的正确传播速度。您将实现两种类型的格式来模拟一个激波，并将非守恒方法得到的数值激波位置与精确的解析解进行比较，这将直观地展示为何不满足守恒性会导致物理上不正确的结果，即便模拟本身看起来是稳定的。[@problem_id:2379415]", "problem": "考虑一维域上的标量守恒律及其非守恒对应形式：\n1) 守恒形式：$\\partial_t u + \\partial_x f(u) = 0$，其中 $f(u) = \\tfrac{1}{2} u^2$。\n2) 非守恒（平流）形式：$\\partial_t u + u \\, \\partial_x u = 0$。\n\n在空间区间 $[0,L]$ 上（$L=6$），给定一个在 $x = x_0$ 处存在单个间断的分段常数初值数据，其中 $x_0 = 1$。令左右常数状态分别为 $u_L$ 和 $u_R$，使得\n$u(x,0) = \\begin{cases}\nu_L,  x  x_0,\\\\\nu_R,  x \\ge x_0.\n\\end{cases}$\n在所有 $t \\ge 0$ 的时刻，施加固定的边界状态（随时间变化的 Dirichlet 条件）$u(0,t) = u_L$ 和 $u(L,t) = u_R$。\n\n对于守恒律问题，当 $u_L  u_R$ 且 $u_L \\ge 0$, $u_R \\ge 0$ 时，其唯一的熵解是一个以 Rankine–Hugoniot 速度 $s = \\dfrac{f(u_L) - f(u_R)}{u_L - u_R} = \\dfrac{u_L + u_R}{2}$ 传播的激波，因此精确的激波位置为 $x_{\\text{exact}}(t) = x_0 + s \\, t$。\n\n任务。在一个包含 $N$ 个单元的均匀网格上，实现两种显式、时间一阶的有限差分或有限体积半离散近似。其中 $N = 1200$，网格间距为 $\\Delta x = L/N$，并使用一个共享的时间步长 $\\Delta t$，该步长在每一步动态选择，以确保 Courant–Friedrichs–Lewy (CFL) 数在每一步都严格小于 $1$。在每一步中，对两种近似方法使用相同的 $\\Delta t$。\n- 一种近似方法必须是针对守恒形式 $\\partial_t u + \\partial_x f(u) = 0$ 的守恒格式，这意味着其在每个时间步长的更新可以写成一种伸缩通量差分形式，在没有边界通量变化的情况下，该形式能够保持 $u$ 的离散总积分守恒。\n- 另一种近似方法必须以一种非守恒的方式离散化非守恒形式 $\\partial_t u + u \\, \\partial_x u = 0$，这意味着它不能被写成伸缩通量差分形式，因此通常不能保持 $u$ 的离散总积分守恒。\n\n在相同的网格上，将两种近似方法从 $t=0$ 演化到 $t=T$。在最终时刻 $t=T$，从每个数值解中近似激波位置 $x_{\\text{num}}$。该位置被定义为 $u(x,T)$ 等于中点值 $\\tfrac{u_L + u_R}{2}$ 的唯一位置，通过在跨越该中点值的相邻网格节点之间进行线性插值来确定；如果没有出现这样的跨越情况，则取 $|u(x,T) - \\tfrac{u_L + u_R}{2}|$ 最小的网格位置。\n\n对于下面的每个测试用例，计算非守恒近似的激波位置相对于精确激波位置的有符号误差，定义为 $E_{\\text{nc}} = x_{\\text{nc}}(T) - x_{\\text{exact}}(T)$，以与 $x$ 相同的空间单位表示（此处为无量纲）。正的 $E_{\\text{nc}}$ 表示非守恒近似的激波位于精确位置的右侧；负值表示位于左侧。对时间步进，使用 $L = 6$, $x_0 = 1$, $N = 1200$ 以及固定的 Courant–Friedrichs–Lewy (CFL) 数 $0.45$。在所有情况下，假设 $u_L \\ge 0$ 且 $u_R \\ge 0$。\n\n测试套件。使用以下参数集，每组为三元组 $(u_L, u_R, T)$：\n- 用例 $1$：$(2.0, 0.0, 0.5)$。\n- 用例 $2$：$(2.0, 0.0, 2.0)$。\n- 用例 $3$：$(2.0, 0.0, 4.0)$。\n- 用例 $4$：$(1.5, 0.2, 4.0)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含按上述用例顺序列出的结果，格式为逗号分隔的列表并用方括号括起来：\n$[E_{\\text{nc}}^{(1)}, E_{\\text{nc}}^{(2)}, E_{\\text{nc}}^{(3)}, E_{\\text{nc}}^{(4)}]$。", "solution": "所述问题需要进行验证。\n\n**第 1 步：提取已知条件**\n- 控制方程：\n  1. 守恒形式：$\\partial_t u + \\partial_x f(u) = 0$，通量函数 $f(u) = \\tfrac{1}{2} u^2$。\n  2. 非守恒形式：$\\partial_t u + u \\, \\partial_x u = 0$。\n- 区域与参数：空间区间 $x \\in [0,L]$，$L=6$；网格单元数 $N=1200$；网格间距 $\\Delta x = L/N$。\n- 初始条件 (IC)：在 $x_0=1$ 处有间断的 Riemann 问题。\n  $u(x,0) = \\begin{cases} u_L,  x  x_0 \\\\ u_R,  x \\ge x_0 \\end{cases}$\n- 边界条件 (BCs)：对于 $t \\ge 0$，$u(0,t) = u_L$ 且 $u(L,t) = u_R$。\n- 解的性质：问题考虑 $u_L  u_R$ 且 $u_L, u_R \\ge 0$ 的情况，此时熵解为激波。\n- 精确激波传播：Rankine-Hugoniot 速度 $s = \\dfrac{f(u_L) - f(u_R)}{u_L - u_R} = \\dfrac{u_L + u_R}{2}$。精确位置为 $x_{\\text{exact}}(t) = x_0 + s \\, t$。\n- 数值方法要求：\n  - 两种显式、时间一阶的半离散近似。一种必须是守恒的，另一种是非守恒的。\n  - 在每一步使用 Courant–Friedrichs–Lewy (CFL) 数 $0.45$ 计算一个共享的动态时间步长 $\\Delta t$。\n- 任务：\n  - 将两种数值近似从 $t=0$ 演化到最终时间 $t=T$。\n  - 在 $t=T$ 时，从每个解中确定数值激波位置 $x_{\\text{num}}$。该位置定义为 $u(x,T) = \\tfrac{u_L + u_R}{2}$ 的所在位置，通过线性插值找到。如果没有网格单元跨越此值，则取 $|u(x,T) - \\tfrac{u_L + u_R}{2}|$ 最小的网格点位置。\n  - 计算非守恒格式的有符号误差：$E_{\\text{nc}} = x_{\\text{nc}}(T) - x_{\\text{exact}}(T)$。\n- 测试套件：为四个不同情况提供了参数 $(u_L, u_R, T)$。\n\n**第 2 步：问题陈述的验证**\n根据科学和数学原理对问题进行审查。\n- **科学依据**：该问题涉及无粘性 Burgers 方程，它是研究双曲型偏微分方程和流体动力学时一个基础且重要的模型方程。守恒与非守恒数值格式之间的区别，以及它们对于间断解（激波）的不同收敛性质，是计算物理学的基石。该问题在科学上是合理的。\n- **适定性**：标量双曲守恒律的初边值问题是适定的。对于指定的条件 $u_L  u_R$ 和凸通量 $f(u) = \\frac{1}{2}u^2$，解析解是一个唯一的、稳定的激波。数值任务以所有必需的参数明确定义，使其没有歧义。\n- **客观性**：该问题使用精确、客观的数学语言进行阐述，没有任何主观或推测性内容。\n\n**第 3 步：结论**\n该问题是有效的。这是一个定义明确的数值分析练习，它演示了一个关键原则：对于包含激波的问题，非守恒数值格式无法收敛到正确的弱解，具体表现为以不正确的速度传播间断。我们继续进行求解。\n\n**基于原理的求解**\n\n目标是比较通过守恒格式与非守恒格式获得的 Burgers 方程数值解中的激波传播。这证明了守恒形式对于捕捉正确的激波物理现象至关重要。\n\n**1. 区域离散化**\n空间域 $[0, L]$ 被离散化为 $N$ 个均匀单元。我们采用以单元为中心的有限体积/差分方法。单元的索引为 $i = 0, 1, \\dots, N-1$。单元 $i$ 的中心位于 $x_i = (i + 0.5)\\Delta x$，其中 $\\Delta x = L/N$。离散解变量 $U_i(t)$ 代表 $u(x,t)$ 在单元 $i$ 上的单元平均值。\n\n**2. 守恒数值格式**\n对于允许激波解的问题，守恒形式 $\\partial_t u + \\partial_x f(u) = 0$ 是正确的出发点。在一个控制体积（单元 $i$）上从 $x_{i-1/2}$ 到 $x_{i+1/2}$ 进行积分，得到：\n$$ \\frac{d}{dt} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) \\,dx + f(u(x_{i+1/2},t)) - f(u(x_{i-1/2},t)) = 0 $$\n定义单元平均值 $U_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) \\,dx$ 和单元界面上的数值通量 $F_{i\\pm1/2}$，我们得到半离散的有限体积形式：\n$$ \\frac{d U_i}{dt} = -\\frac{1}{\\Delta x} (F_{i+1/2} - F_{i-1/2}) $$\n这种形式显然是守恒的：当对所有单元求和时，内部通量以伸缩方式抵消，确保了总量 $\\sum_i U_i \\Delta x$ 仅因边界通量而改变。\n\n对于一阶格式，我们使用迎风通量。特征速度为 $f'(u) = u$。给定 $u_L, u_R \\ge 0$，解 $u(x,t)$ 保持非负，信息从左向右传播。因此，界面 $i+1/2$ 处的迎风通量由其左侧的状态 $U_i$ 决定。\n$$ F_{i+1/2} = f(U_i) = \\frac{1}{2} U_i^2 $$\n将其代入半离散形式得到：\n$$ \\frac{d U_i}{dt} = -\\frac{1}{\\Delta x} (f(U_i) - f(U_{i-1})) $$\n应用显式欧拉时间积分（$U_i^{n+1} = U_i^n + \\Delta t \\frac{d U_i}{dt}|_n$），得到完全离散的守恒格式：\n$$ U_{i,\\text{c}}^{n+1} = U_{i,\\text{c}}^n - \\frac{\\Delta t}{\\Delta x} \\left( \\frac{1}{2}(U_{i,\\text{c}}^n)^2 - \\frac{1}{2}(U_{i-1,\\text{c}}^n)^2 \\right) $$\n\n**3. 非守恒数值格式**\n对于光滑解，非守恒形式 $\\partial_t u + u \\partial_x u = 0$ 在数学上与守恒形式等价，但这种等价性在间断处失效。基于这种形式的数值格式不能保证满足积分守恒性质，并且通常会计算出不正确的激波速度。\n\n我们直接离散这个方程。对时间使用显式欧拉法，对空间导数 $\\partial_x u$ 使用一阶迎风（后向）差分以遵循信息流动的方向：\n$$ \\frac{U_i^{n+1} - U_i^n}{\\Delta t} + U_i^n \\frac{U_i^n - U_{i-1}^n}{\\Delta x} = 0 $$\n这得到了完全离散的非守恒格式：\n$$ U_{i,\\text{nc}}^{n+1} = U_{i,\\text{nc}}^n - \\frac{\\Delta t}{\\Delta x} U_{i,\\text{nc}}^n (U_{i,\\text{nc}}^n - U_{i-1,\\text{nc}}^n) $$\n此更新规则无法写成守恒所需的通量差分形式。\n\n**4. 边界和初始条件**\n- **初始条件：** 通过对单元中心 $x_i  x_0$ 设置 $U_i(0) = u_L$ 以及对 $x_i \\ge x_0$ 设置 $U_i(0) = u_R$，将分段常数初值数据映射到网格上。对于 $x_0 = 1$ 和 $N=1200$，间断点落在单元 $i=199$ 和 $i=200$ 之间。\n- **边界条件：** 对于 $u0$，边界 $x=0$ 是流入边界，而 $x=L$ 是流出边界。\n  - 在流入边界（$x=0$），状态由外部条件 $u(0,t)=u_L$ 决定。这通过使用一个索引为 $i=-1$ 的虚拟单元来处理，对两种格式都设置其值为 $U_{-1}^n = u_L$。\n  - 在流出边界（$x=L$），状态由域内的动力学决定。无需施加边界条件。我们选择的迎风格式的单边性质自然地处理了这一点，因为它不需要来自最右侧单元之外的信息。因此，给定条件 $u(L,t)=u_R$ 是对预期流出状态的观察，而不是针对此流动方向施加的约束。\n\n**5. 时间步进与稳定性**\n显式向前欧拉法要求对时间步长的大小进行限制以保证稳定性，这由 Courant–Friedrichs–Lewy (CFL) 条件决定。时间步长 $\\Delta t$ 必须满足：\n$$ \\Delta t \\le \\text{CFL} \\frac{\\Delta x}{\\max_i |u_i|} $$\n问题指定使用 $\\text{CFL} = 0.45$ 的动态 $\\Delta t$。在每个时间步 $n$，我们计算两个解中的全局最大速度 $u_{\\max}^n = \\max(\\max_i |U_{i,\\text{c}}^n|, \\max_i |U_{i,\\text{nc}}^n|)$，以确保两种格式在使用共享 $\\Delta t$ 时的稳定性。然后，时间步长为 $\\Delta t^n = 0.45 \\cdot \\Delta x / u_{\\max}^n$。仿真时间逐步推进，直到达到最终时间 $T$。\n\n**6. 激波位置定位与误差计算**\n在最终时间 $T$，找到非守恒解的数值激波位置 $x_{\\text{nc}}$。我们搜索跨越中点值 $u_{\\text{mid}} = (u_L+u_R)/2$ 的相邻网格点 $(x_i, U_{i,\\text{nc}})$ 和 $(x_{i+1}, U_{i+1,\\text{nc}})$。如果找到，则通过线性插值确定位置：\n$$ x_{\\text{nc}} = x_i + \\Delta x \\frac{u_{\\text{mid}} - U_{i,\\text{nc}}}{U_{i+1,\\text{nc}} - U_{i,\\text{nc}}} $$\n如果不存在这样的点对，$x_{\\text{nc}}$ 则取为使 $|U_{j,\\text{nc}} - u_{\\text{mid}}|$ 最小的网格位置 $x_j$。精确的激波位置计算为 $x_{\\text{exact}}(T) = x_0 + sT$。所要求的误差为 $E_{\\text{nc}} = x_{\\text{nc}}(T) - x_{\\text{exact}}(T)$。\n将此程序系统地应用于所有测试用例，以量化由非守恒离散化产生的激波速度误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_burgers(u_L, u_R, T, L, N, cfl, x0):\n    \"\"\"\n    Solves Burgers' equation using conservative and non-conservative schemes\n    and returns the final state of the non-conservative solution.\n    \"\"\"\n    dx = L / N\n    x = np.linspace(dx / 2, L - dx / 2, N)\n\n    # Initial conditions\n    u_c = np.full_like(x, u_R)\n    u_nc = np.full_like(x, u_R)\n    \n    # Locate the discontinuity index\n    # Based on x_i  x0 ==> (i+0.5)*dx  x0 ==> i  x0/dx - 0.5\n    split_idx_float = x0 / dx - 0.5\n    split_idx = int(np.floor(split_idx_float)) + 1\n    \n    u_c[:split_idx] = u_L\n    u_nc[:split_idx] = u_L\n\n    t = 0.0\n    while t  T:\n        # Determine shared dynamic time step\n        u_max_c = np.max(np.abs(u_c))\n        u_max_nc = np.max(np.abs(u_nc))\n        u_max = max(u_max_c, u_max_nc, 1e-9) # Avoid division by zero\n        \n        dt = cfl * dx / u_max\n        if t + dt > T:\n            dt = T - t\n        \n        # --- Conservative Scheme (Upwind Finite Volume) ---\n        # Extend solution array with ghost cell for inflow BC\n        u_c_ghost = np.concatenate(([u_L], u_c))\n        \n        # Flux at cell interfaces (f(u) = 0.5*u^2). Upwind implies f(u_left).\n        # We need N fluxes for N cells updates\n        # The flux at the right of cell i is f(u_i)\n        # The flux at the left of cell i is f(u_{i-1})\n        # F_{i+1/2} corresponds to f(U_i), so the flux vector would be f(U_i) for i in 0..N-1\n        # The update is U_i^{n+1} = U_i^n - dt/dx * (F_{i+1/2} - F_{i-1/2})\n        #                         = U_i^n - dt/dx * (f(U_i) - f(U_{i-1}))\n        # Vectorized implementation:\n        flux_c = 0.5 * u_c_ghost**2\n        flux_diff_c = flux_c[1:] - flux_c[:-1]\n        u_c = u_c - (dt / dx) * flux_diff_c\n\n        # --- Non-Conservative Scheme (Upwind Finite Difference) ---\n        u_nc_ghost = np.concatenate(([u_L], u_nc))\n        \n        # Advective term: u * (u_i - u_{i-1})/dx\n        adv_term_nc = u_nc_ghost[1:] * (u_nc_ghost[1:] - u_nc_ghost[:-1])\n        u_nc = u_nc - (dt / dx) * adv_term_nc\n        \n        t += dt\n\n    return u_nc, x\n\ndef find_shock_pos(u_final, x_grid, u_L, u_R):\n    \"\"\"\n    Finds the numerical shock position by interpolation.\n    \"\"\"\n    u_mid = (u_L + u_R) / 2.0\n    \n    # Search for straddling grid cells\n    for i in range(len(u_final) - 1):\n        # (u[i] - u_mid) and (u[i+1] - u_mid) have different signs\n        if (u_final[i] - u_mid) * (u_final[i+1] - u_mid) = 0:\n            u_i = u_final[i]\n            u_i1 = u_final[i+1]\n            x_i = x_grid[i]\n            dx = x_grid[1] - x_grid[0]\n            \n            # Avoid division by zero if u_i1 == u_i\n            if abs(u_i1 - u_i)  1e-9:\n                return x_i + dx/2.0\n                \n            # Linear interpolation\n            return x_i + dx * (u_mid - u_i) / (u_i1 - u_i)\n\n    # If no straddling found, find closest point\n    min_dist_idx = np.argmin(np.abs(u_final - u_mid))\n    return x_grid[min_dist_idx]\n    \ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    # Problem definition\n    L = 6.0\n    x0 = 1.0\n    N = 1200\n    CFL = 0.45\n    \n    test_cases = [\n        (2.0, 0.0, 0.5),  # Case 1\n        (2.0, 0.0, 2.0),  # Case 2\n        (2.0, 0.0, 4.0),  # Case 3\n        (1.5, 0.2, 4.0),  # Case 4\n    ]\n\n    results = []\n    for u_L, u_R, T in test_cases:\n        # Calculate exact shock position\n        s_exact = (u_L + u_R) / 2.0\n        x_exact = x0 + s_exact * T\n        \n        # Run simulation to get final state\n        u_nc_final, x_grid = solve_burgers(u_L, u_R, T, L, N, CFL, x0)\n        \n        # Find numerical shock position for non-conservative scheme\n        x_nc = find_shock_pos(u_nc_final, x_grid, u_L, u_R)\n        \n        # Compute the error\n        error_nc = x_nc - x_exact\n        results.append(error_nc)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```", "id": "2379415"}, {"introduction": "我们已经看到了显式守恒和非守恒离散化之间的差异。现在，让我们来探索一个更微妙但常见的陷阱：一个看起来是守恒的“通量差分”形式，但其根本上是有缺陷的格式。一个有限体积格式的正确性取决于其数值通量（numerical flux）与守恒律的物理通量（physical flux）是否*相容*（consistent），本练习将通过一个有意构造的错误通量来阐释这一原则。通过实现一个违反相容性条件的非守恒通量，您将能够诊断出由此产生的激波速度误差和解的整体精度问题，从而深化对数值格式设计的理解——仅仅拥有守恒形式是不够的，数值通量的细节至关重要。[@problem_id:2379435]", "problem": "你的任務是研究在有限體積離散中破壞守恆形式所帶來的影響，具體方法是比較一個正確的守恆數值通量與一個為純量守恆律設定的、故意不正確的非守恆數值通量。考慮一維純量守恆律\n$$\nu_t + f(u)_x = 0 \\quad \\text{on} \\quad [x_L,x_R] \\times [0,T],\n$$\n其通量為\n$$\nf(u) = \\tfrac{1}{2} u^2,\n$$\n初始黎曼數據為\n$$\nu(x,0) =\n\\begin{cases}\nu_L,  x  x_0,\\\\\nu_R,  x \\ge x_0,\n\\end{cases}\n$$\n在端點處為出流邊界條件。通量的雅可比矩陣為\n$$\nA(u) = f'(u) = u.\n$$\n使用均勻網格，其中包含 $N$ 個寬度為 $\\Delta x = (x_R - x_L)/N$ 的控制體積，以及滿足 Courant-Friedrichs-Lewy (CFL) 條件的時間步長 $\\Delta t$，CFL 數 $c \\in (0,1)$。\n\n為單元 $[x_{i-1/2},x_{i+1/2}]$ 上的單元平均值 $u_i(t)$ 定義兩種半離散有限體積更新格式，其形式為標準的通量差分：\n$$\n\\frac{d u_i}{d t} = -\\frac{1}{\\Delta x}\\left( \\hat{F}_{i+1/2} - \\hat{F}_{i-1/2} \\right).\n$$\n\n對於守恆離散格式，使用局部 Lax-Friedrichs（也称为 Rusanov）數值通量\n$$\n\\hat{F}^{\\text{cons}}(u_L,u_R) = \\tfrac{1}{2}\\big(f(u_L)+f(u_R)\\big) - \\tfrac{1}{2} a(u_L,u_R) (u_R - u_L),\n$$\n其中\n$$\na(u_L,u_R) = \\max\\big(|f'(u_L)|, |f'(u_R)|\\big) = \\max\\big(|u_L|,|u_R|\\big).\n$$\n\n對於故意設定的非守恆離散格式，將中心通量項替換為一個由 $A(u)$ 的平均值和 $u$ 的平均值構成的非守恆近似：\n$$\n\\hat{F}^{\\text{noncons}}(u_L,u_R) = \\left(\\tfrac{1}{2}\\big(A(u_L)+A(u_R)\\big)\\right)\\left(\\tfrac{1}{2}\\big(u_L+u_R\\big)\\right) - \\tfrac{1}{2} a(u_L,u_R) (u_R - u_L),\n$$\n其中耗散項 $a(u_L,u_R)$ 與上述相同。使用前向歐拉法隨時間推進求解，時間步長 $\\Delta t$ 在每個時間步都滿足 CFL 條件 $\\Delta t \\le c \\, \\Delta x / \\max_i |u_i|$。\n\n對於下述的每個測試案例，計算在最終時間 $T$ 的以下診斷量：\n\n- 對於 $u_L  u_R$ 的激波案例，使用非守恆格式計算觀測到的激波速度\n$$\ns_{\\text{obs}} = \\frac{x_{\\text{shock}}(T) - x_0}{T},\n$$\n其中 $x_{\\text{shock}}(T)$ 是 $u$ 穿過中點值 $m = \\tfrac{1}{2}(u_L+u_R)$ 的位置，該位置由相鄰單元中心之間的線性插值確定。計算守恆律的精確 Rankine–Hugoniot 激波速度，\n$$\ns_{\\text{exact}} = \\frac{f(u_L)-f(u_R)}{u_L - u_R} = \\tfrac{1}{2}(u_L + u_R),\n$$\n並報告其差值\n$$\nd_s = s_{\\text{obs}} - s_{\\text{exact}}.\n$$\n\n- 對於 $u_L  u_R$ 的稀疏波案例，計算在時間 $T$ 時每個格式相對於 Burgers 方程稀疏波的精確自相似解的 $L^1$ 誤差，\n$$\nu(x,T) =\n\\begin{cases}\nu_L,  x - x_0 \\le u_L T,\\\\\n\\dfrac{x - x_0}{T},  u_L T \\le x - x_0 \\le u_R T,\\\\\nu_R,  x - x_0 \\ge u_R T,\n\\end{cases}\n$$\n並報告 $L^1$ 誤差的差值\n$$\nd_{L^1} = \\|u^{\\text{noncons}}(\\cdot,T) - u^{\\text{exact}}(\\cdot,T)\\|_{L^1} - \\|u^{\\text{cons}}(\\cdot,T) - u^{\\text{exact}}(\\cdot,T)\\|_{L^1}.\n$$\n\n- 對於 $u_L = u_R$ 的常數數據案例，報告非守恆解與初始常數值的最大絕對偏差，\n$$\nd_{\\max} = \\max_i \\big| u^{\\text{noncons}}_i(T) - u_L \\big|.\n$$\n\n使用以下參數值，這些參數構成了測試套件：\n\n- 空間域：$[x_L,x_R] = [-1,1]$。\n- 單元數量：$N = 800$。\n- Courant-Friedrichs-Lewy 數：$c = 0.45$。\n- 邊界條件：出流。\n- 測試案例 $(u_L,u_R,x_0,T)$:\n  1. $(1.0, 0.0, 0.0, 0.2)$ 激波案例；報告 $d_s$。\n  2. $(0.0, 1.0, 0.0, 0.2)$ 稀疏波案例；報告 $d_{L^1}$。\n  3. $(0.5, 0.5, 0.0, 0.2)$ 常數案例；報告 $d_{\\max}$。\n  4. $(0.2, 0.0, -0.1, 0.3)$ 小振幅激波；報告 $d_s$。\n\n你的程式必須產生單行輸出，其中包含一個列表，列表內含按測試案例順序排列的四個結果，結果以逗號分隔並用方括號括起來，例如\n$$\n[\\;r_1,r_2,r_3,r_4\\;],\n$$\n其中每個 $r_i$ 是如上定義的實數。不應打印任何額外的文本或行。輸出中的所有數值都必須表示為不帶單位的普通十進制數。", "solution": "該問題要求研究對純量守恆律（具體來說是無粘性 Burgers 方程 $u_t + f(u)_x = 0$，其通量為 $f(u) = \\frac{1}{2}u^2$）使用非守恆數值格式所帶來的後果。採用有限體積法，比較一個守恆格式（使用局部 Lax-Friedrichs 或 Rusanov 通量）與一個故意設定的非守恆格式。分析是針對激波、稀疏波和常數數據的初始條件進行的。\n\n首先，讓我們建立理論基礎。對於守恆律 $\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0$，在一個控制體積 $[x_{i-1/2}, x_{i+1/2}]$上積分，可得到單元平均值 $u_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) dx$ 的精確關係式：\n$$\n\\frac{d u_i}{d t} = -\\frac{1}{\\Delta x}\\left( F(u(x_{i+1/2}, t)) - F(u(x_{i-1/2}, t)) \\right).\n$$\n此處，$F(u(x,t))$ 是在單元交界處計算的物理通量。在數值格式中，它被一個數值通量函數 $\\hat{F}(u_L, u_R)$ 所取代，該函數在給定交界處左側狀態為 $u_L$ 和右側狀態為 $u_R$ 的情況下近似物理通量。半離散格式於是為：\n$$\n\\frac{d u_i}{d t} = -\\frac{1}{\\Delta x}\\left( \\hat{F}_{i+1/2} - \\hat{F}_{i-1/2} \\right),\n$$\n其中 $\\hat{F}_{i+1/2} = \\hat{F}(u_i, u_{i+1})$。這種形式是內在守恆的；總量 $\\sum_i u_i \\Delta x$ 的變化僅由域邊界上的通量決定。然而，為使格式能夠收斂到守恆律的正確弱解，尤其是在存在間斷（激波）的情況下，數值通量 $\\hat{F}(u_L, u_R)$ 必須與物理通量 $f(u)$ 保持一致，即 $\\hat{F}(u, u) = f(u)$。\n\n守恆的 Rusanov 通量定義為：\n$$\n\\hat{F}^{\\text{cons}}(u_L,u_R) = \\tfrac{1}{2}\\big(f(u_L)+f(u_R)\\big) - \\tfrac{1}{2} a(u_L,u_R) (u_R - u_L).\n$$\n當 $u_L=u_R=u$ 時，耗散項消失，我們得到 $\\hat{F}^{\\text{cons}}(u,u) = \\frac{1}{2}(f(u)+f(u)) = f(u)$。該通量是一致的。\n\n指定的「非守恆」通量是：\n$$\n\\hat{F}^{\\text{noncons}}(u_L,u_R) = \\left(\\tfrac{1}{2}\\big(A(u_L)+A(u_R)\\big)\\right)\\left(\\tfrac{1}{2}\\big(u_L+u_R\\big)\\right) - \\tfrac{1}{2} a(u_L,u_R) (u_R - u_L).\n$$\n對於 $f(u) = \\frac{1}{2}u^2$，我們有 $A(u) = f'(u) = u$。讓我們檢查其一致性：\n$$\n\\hat{F}^{\\text{noncons}}(u,u) = \\left(\\tfrac{1}{2}\\big(u+u\\big)\\right)\\left(\\tfrac{1}{2}\\big(u+u\\big)\\right) = u \\cdot u = u^2.\n$$\n物理通量是 $f(u) = \\frac{1}{2}u^2$。由於 $\\hat{F}^{\\text{noncons}}(u,u) = u^2 \\neq f(u)$，这个數值通量與原始守恆律不一致。該格式不會收斂到正確的解。相反，它會試圖求解一個不正確的守恆律 $u_t + g(u)_x = 0$，其中等效的數值通量為 $g(u) = u^2$。\n\n這種不一致性會帶來深刻的後果：\n1.  對於激波（$u_L  u_R$），間斷的速度必須滿足 Rankine-Hugoniot 條件，$s = [f]/[u] = (f(u_L)-f(u_R))/(u_L-u_R)$。我們的守恆格式將近似此速度。非守恆格式將近似錯誤守恆律的激波速度：$s_{\\text{noncons}} = (g(u_L)-g(u_R))/(u_L-u_R) = (u_L^2-u_R^2)/(u_L-u_R) = u_L+u_R$。而正確守恆律的精確速度是 $s_{\\text{exact}} = (\\frac{1}{2}u_L^2-\\frac{1}{2}u_R^2)/(u_L-u_R) = \\frac{1}{2}(u_L+u_R)$。因此，預計來自不一致格式的數值解將表現出一個以不正確速度傳播的激波，其預測速度差為 $d_s \\approx s_{\\text{noncons}} - s_{\\text{exact}} = \\frac{1}{2}(u_L+u_R)$。\n\n2.  對於稀疏波（$u_L  u_R$），流動是平滑的，不一致性會引入誤差從而污染解。$L^1$ 誤差的差值 $d_{L^1}$ 將量化非守恆格式相較於守恆基準的表現有多差。\n\n3.  對於常數初始數據（$u_L = u_R = u_c$），一個精確求解器將維持此狀態。然而，非守恆格式可能不穩定。微小的數值擾動會被放大，導致偽振盪並偏離常數狀態。所需的診斷量 $d_{\\max}$ 將測量這種偏差的大小。\n\n實作過程如下：在域 $[x_L, x_R] = [-1, 1]$ 上定義一個包含 $N=800$ 個單元的均勻網格。為每個測試案例設置初始黎曼數據。使用前向歐拉法在時間上推進求解。在每一步計算時間步長 $\\Delta t$ 以滿足 CFL 條件 $\\Delta t = c \\cdot \\Delta x / \\max_i|u_i|$，其中 $c=0.45$，從而確保穩定性。最大波速 $\\max_i|u_i|$ 在整個數值解域中取值。通過將虛擬單元中的值設置為與相鄰內部單元相等來實現出流邊界條件。\n\n對於每個測試案例，運行適當的模擬直到最終時間 $T$。\n-   對於激波案例，運行非守恆模擬。通過搜索解穿過中點值 $m = \\frac{1}{2}(u_L+u_R)$ 的單元交界，並應用線性插值，找到激波的最終位置 $x_{\\text{shock}}(T)$。然後計算觀測速度 $s_{\\text{obs}}$ 和差異 $d_s = s_{\\text{obs}} - s_{\\text{exact}}$。\n-   對於稀疏波案例，運行守恆和非守恆兩種模擬。在時間 $T$ 時在網格上計算精確的自相似解。每个數值解的 $L^1$ 誤差計算為 $\\|u_{\\text{num}} - u_{\\text{exact}}\\|_{L^1} = \\sum_i |u_{i, \\text{num}} - u_{i, \\text{exact}}| \\Delta x$。最終報告的值是這些誤差的差值 $d_{L^1}$。\n-   對於常數數據案例，運行非守恆模擬。在所有單元上計算最終數值解與初始常數值 $u_L$ 之間的最大絕對差值，以找到 $d_{\\max}$。\n\n程式為四個指定的測試案例執行此邏輯，並報告產生的診斷量。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing conservative and nonconservative finite volume schemes\n    for the inviscid Burgers' equation.\n    \"\"\"\n\n    test_cases = [\n        {'uL': 1.0, 'uR': 0.0, 'x0': 0.0, 'T': 0.2, 'type': 'shock'},\n        {'uL': 0.0, 'uR': 1.0, 'x0': 0.0, 'T': 0.2, 'type': 'rarefaction'},\n        {'uL': 0.5, 'uR': 0.5, 'x0': 0.0, 'T': 0.2, 'type': 'constant'},\n        {'uL': 0.2, 'uR': 0.0, 'x0': -0.1, 'T': 0.3, 'type': 'shock'},\n    ]\n\n    results = []\n    \n    # Global parameters\n    xL, xR = -1.0, 1.0\n    N = 800\n    cfl = 0.45\n    dx = (xR - xL) / N\n    x = np.linspace(xL + dx / 2.0, xR - dx / 2.0, N)\n\n    def f(u):\n        return 0.5 * u**2\n\n    def A(u):\n        return u\n\n    def F_cons(ul, ur):\n        a = np.maximum(np.abs(ul), np.abs(ur))\n        return 0.5 * (f(ul) + f(ur)) - 0.5 * a * (ur - ul)\n\n    def F_noncons(ul, ur):\n        a = np.maximum(np.abs(ul), np.abs(ur))\n        avg_u = 0.5 * (ul + ur)\n        avg_A = 0.5 * (A(ul) + A(ur))\n        return avg_A * avg_u - 0.5 * a * (ur - ul)\n\n    def run_sim(u0, T_final, schemes):\n        solutions = {s: u0.copy() for s in schemes}\n        \n        t = 0.0\n        while t  T_final:\n            max_u_abs = 1e-9 # Avoid division by zero\n            for u in solutions.values():\n                max_u_abs = np.maximum(max_u_abs, np.max(np.abs(u)))\n\n            dt = cfl * dx / max_u_abs\n            dt = min(dt, T_final - t)\n\n            for s_name, u in solutions.items():\n                u_ext = np.concatenate(([u[0]], u, [u[-1]]))\n                \n                ul = u_ext[:-1]\n                ur = u_ext[1:]\n                \n                if s_name == 'cons':\n                    flux = F_cons(ul, ur)\n                else:\n                    flux = F_noncons(ul, ur)\n                \n                u -= (dt / dx) * (flux[1:] - flux[:-1])\n            \n            t += dt\n            \n        return solutions\n\n    for case in test_cases:\n        uL, uR, x0, T, case_type = case['uL'], case['uR'], case['x0'], case['T'], case['type']\n        \n        # Initial condition - use np.where for robust floating point comparison\n        u0 = np.where(x  x0, uL, uR).astype(float)\n\n        if case_type == 'shock':\n            final_states = run_sim(u0, T, ['noncons'])\n            u_final = final_states['noncons']\n            \n            m = 0.5 * (uL + uR)\n            # Find the first index where u drops below the midpoint m\n            indices = np.where(u_final = m)[0]\n            if len(indices) == 0 or indices[0] == 0:\n                # Shock has not entered or is at the very beginning\n                x_shock = x[np.argmin(u_final)]\n            else:\n                i = indices[0]\n                u_i = u_final[i]\n                u_im1 = u_final[i-1]\n                x_i = x[i]\n                x_im1 = x[i-1]\n                \n                if abs(u_i - u_im1)  1e-9:\n                    x_shock = x_i\n                else:\n                    # Linear interpolation\n                    x_shock = x_im1 + (x_i - x_im1) * (m - u_im1) / (u_i - u_im1)\n\n            s_obs = (x_shock - x0) / T if T > 0 else 0\n            s_exact = 0.5 * (uL + uR)\n            ds = s_obs - s_exact\n            results.append(ds)\n\n        elif case_type == 'rarefaction':\n            final_states = run_sim(u0, T, ['cons', 'noncons'])\n            u_cons = final_states['cons']\n            u_noncons = final_states['noncons']\n            \n            # Exact solution\n            xi_t = (x - x0) / T if T > 0 else np.zeros_like(x)\n            u_exact = np.full_like(x, 0.0)\n            u_exact = np.where(xi_t = uL, uL, u_exact)\n            u_exact = np.where(xi_t >= uR, uR, u_exact)\n            mask = (xi_t > uL)  (xi_t  uR)\n            u_exact[mask] = xi_t[mask]\n\n            l1_err_cons = np.sum(np.abs(u_cons - u_exact)) * dx\n            l1_err_noncons = np.sum(np.abs(u_noncons - u_exact)) * dx\n            d_l1 = l1_err_noncons - l1_err_cons\n            results.append(d_l1)\n            \n        elif case_type == 'constant':\n            final_states = run_sim(u0, T, ['noncons'])\n            u_final = final_states['noncons']\n            d_max = np.max(np.abs(u_final - uL))\n            results.append(d_max)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2379435"}]}