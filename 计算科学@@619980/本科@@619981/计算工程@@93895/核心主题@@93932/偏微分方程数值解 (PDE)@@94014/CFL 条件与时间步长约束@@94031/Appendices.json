{"hands_on_practices": [{"introduction": "在数值方法中，一些看似直观的方案可能隐藏着令人意外的缺陷。我们将通过冯·诺依曼稳定性分析来探究经典的“前向时间、中心空间”（FTCS）格式。这个练习是计算科学中一个经典的警示故事：通过证明该格式对于平流方程是无条件不稳定的，你将深刻体会到为什么严格的稳定性分析（如CFL条件所要求的）不仅仅是理论上的形式，更是实践中的必需。[@problem_id:2442990]", "problem": "在周期性域 $x \\in [0,L]$上，给定一个波速为常数 $a$ 的一维线性平流方程：\n$$\nu_{t} + a\\,u_{x} = 0,\n$$\n其中 $j$ 为整数的均匀网格为 $x_{j} = j\\,\\Delta x$， $n$ 为整数的时间层为 $t^{n} = n\\,\\Delta t$。考虑显式向前时间、中心空间格式\n$$\nu_{j}^{n+1} = u_{j}^{n} - \\frac{a\\,\\Delta t}{2\\,\\Delta x}\\left(u_{j+1}^{n} - u_{j-1}^{n}\\right).\n$$\n令柯朗数 (Courant number) 为 $C = \\dfrac{a\\,\\Delta t}{\\Delta x}$，并考虑一个无量纲波数为 $\\theta \\in [0,\\pi]$的离散傅里叶模态。对于该模态，将此格式的单步放大因子 $G(C,\\theta)$ 定义为 $u_{j}^{n+1} = G(C,\\theta)\\,u_{j}^{n}$，并令\n$$\nS(C) = \\max_{\\theta \\in [0,\\pi]} \\left|G(C,\\theta)\\right|.\n$$\n求出 $S(C)$ 的闭式解。请以 $C$ 的单个解析表达式形式给出最终答案。无需四舍五入，答案是无量纲的。", "solution": "该问题要求确定应用于一维线性平流方程的显式向前时间、中心空间 (FTCS) 数值格式的最大单步放大因子 $S(C)$。此过程从 von Neumann 稳定性分析开始。\n\n给定的数值格式是：\n$$\nu_{j}^{n+1} = u_{j}^{n} - \\frac{a\\,\\Delta t}{2\\,\\Delta x}\\left(u_{j+1}^{n} - u_{j-1}^{n}\\right)\n$$\n柯朗数定义为 $C = \\dfrac{a\\,\\Delta t}{\\Delta x}$。将其代入该格式得到：\n$$\nu_{j}^{n+1} = u_{j}^{n} - \\frac{C}{2}\\left(u_{j+1}^{n} - u_{j-1}^{n}\\right)\n$$\n对于 von Neumann 分析，我们考虑解的单个傅里叶模态。设在网格点 $j$ 和时间层 $n$ 的数值解表示为：\n$$\nu_{j}^{n} = \\hat{u}^{n}(k) e^{i k x_{j}}\n$$\n其中 $k$ 是波数，$x_{j} = j\\,\\Delta x$ 是空间坐标，$i = \\sqrt{-1}$。放大因子（为简单起见，我们将其记为 $G$）关联了连续时间步长上模态的振幅：\n$$\n\\hat{u}^{n+1}(k) = G \\, \\hat{u}^{n}(k)\n$$\n这意味着 $u_{j}^{n+1} = G \\, u_{j}^{n}$。我们也可以将相邻项写作：\n$$\nu_{j+1}^{n} = \\hat{u}^{n}(k) e^{i k (j+1)\\Delta x} = \\hat{u}^{n}(k) e^{i k j\\Delta x} e^{i k \\Delta x} = u_{j}^{n} e^{i k \\Delta x}\n$$\n$$\nu_{j-1}^{n} = \\hat{u}^{n}(k) e^{i k (j-1)\\Delta x} = \\hat{u}^{n}(k) e^{i k j\\Delta x} e^{-i k \\Delta x} = u_{j}^{n} e^{-i k \\Delta x}\n$$\n将这些表达式代入数值格式得到：\n$$\nG \\, u_{j}^{n} = u_{j}^{n} - \\frac{C}{2}\\left(u_{j}^{n} e^{i k \\Delta x} - u_{j}^{n} e^{-i k \\Delta x}\\right)\n$$\n对于非平凡解（$u_{j}^{n} \\neq 0$），我们可以将整个方程除以 $u_{j}^{n}$ 来求解放大因子 $G$：\n$$\nG = 1 - \\frac{C}{2}\\left(e^{i k \\Delta x} - e^{-i k \\Delta x}\\right)\n$$\n使用欧拉恒等式 $e^{i\\phi} - e^{-i\\phi} = 2i\\sin(\\phi)$，我们可以简化括号中的表达式：\n$$\ne^{i k \\Delta x} - e^{-i k \\Delta x} = 2i\\sin(k \\Delta x)\n$$\n这导出了放大因子的以下表达式：\n$$\nG = 1 - \\frac{C}{2} \\left(2i\\sin(k \\Delta x)\\right) = 1 - iC\\sin(k \\Delta x)\n$$\n问题指定使用无量纲波数 $\\theta = k \\Delta x$，其中 $\\theta \\in [0, \\pi]$。放大因子作为 $C$ 和 $\\theta$ 的函数是：\n$$\nG(C, \\theta) = 1 - iC\\sin(\\theta)\n$$\n这是一个复数，其实部为 $1$，虚部为 $-C\\sin(\\theta)$。放大因子的模 $|G(C, \\theta)|$ 计算如下：\n$$\n|G(C, \\theta)| = \\sqrt{(\\text{Re}(G))^2 + (\\text{Im}(G))^2} = \\sqrt{(1)^2 + (-C\\sin(\\theta))^2} = \\sqrt{1 + C^2\\sin^2(\\theta)}\n$$\n问题要求 $S(C) = \\max_{\\theta \\in [0,\\pi]} |G(C,\\theta)|$。为求此最大值，我们需要在区间 $[0, \\pi]$ 上关于 $\\theta$ 最大化表达式 $\\sqrt{1 + C^2\\sin^2(\\theta)}$。由于平方根函数对于非负参数是单调递增的，因此最大化 $|G(C,\\theta)|$ 等价于最大化其平方 $|G(C,\\theta)|^2 = 1 + C^2\\sin^2(\\theta)$。\n\n表达式 $1 + C^2\\sin^2(\\theta)$ 对 $\\theta$ 的依赖性仅通过 $\\sin^2(\\theta)$ 项体现。我们需要求出当 $\\theta \\in [0, \\pi]$ 时 $\\sin^2(\\theta)$ 的最大值。在此区间内，函数 $\\sin(\\theta)$ 在 $\\theta = \\frac{\\pi}{2}$ 时达到其最大值 $1$。因此，$\\sin^2(\\theta)$ 的最大值也是 $1$，发生在同一点 $\\theta = \\frac{\\pi}{2}$。\n\n因此， $|G(C,\\theta)|^2$ 的最大值是：\n$$\n\\max_{\\theta \\in [0,\\pi]} \\left(1 + C^2\\sin^2(\\theta)\\right) = 1 + C^2 (\\max_{\\theta \\in [0,\\pi]} \\sin^2(\\theta)) = 1 + C^2(1) = 1 + C^2\n$$\n量 $S(C)$是这个最大值的平方根：\n$$\nS(C) = \\sqrt{1 + C^2}\n$$\n这个结果表明，对于任何非零的柯朗数 $C$，对于某些波数（具体来说，对于任何使得 $\\sin(\\theta) \\neq 0$ 的 $\\theta$），放大因子的模都大于 $1$，这表明 FTCS 格式对于线性平流方程是无条件不稳定的。然而，问题只要求 $S(C)$ 的闭式表达式。", "answer": "$$\\boxed{\\sqrt{1+C^2}}$$", "id": "2442990"}, {"introduction": "在满足稳定性条件后，我们面临一个新的问题：如何选择最优的时间步长？本练习将通过编程实践，让你直观地探索库朗数 $C$ 对稳定的一阶迎风格式精度的影响。[@problem_id:2443006] 你将发现，一个过于保守的小时间步长虽然稳定，却可能因过度的数值扩散而损害精度，从而学会平衡稳定性和准确性这一关键技能。", "problem": "考虑定义在周期性域上的一维线性平流方程，\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0,\n$$\n其中平流速度 $a > 0$ 为常数，空间周期为 $L$。设空间网格是均匀的，有 $N$ 个点，网格间距为 $\\Delta x = L/N$，网格点为 $x_i = i\\,\\Delta x$，其中 $i \\in \\{0,1,\\dots,N-1\\}$。定义库朗数为 $C = \\dfrac{a\\,\\Delta t}{\\Delta x}$，其中 $\\Delta t$ 是时间步长。考虑 $a>0$ 情况下的显式一阶迎风格式更新，\n$$\nu_i^{n+1} \\;=\\; u_i^n \\;-\\; C\\left(u_i^n - u_{i-1}^n\\right),\n$$\n其中使用周期性索引，使得 $u_{-1}^n = u_{N-1}^n$。设时间 $t$ 的精确解为 $u(x,t) = u_0\\!\\left((x - a t) \\bmod L\\right)$，其中 $u_0(x)$ 是初始条件。\n\n您必须编写一个完整、可运行的程序，对于固定的无量纲配置，\n- $L = 1$，\n- $a = 1$，\n- $N = 128$，\n- 最终目标时间 $T = 0.02$，\n为下面列出的每个测试用例执行以下操作：\n1. 使用测试用例的 $C$ 值，设置 $\\Delta x = L/N$ 和 $\\Delta t = C\\,\\Delta x / a$。\n2. 令 $n_{\\text{steps}} = \\text{round}\\!\\left(T/\\Delta t\\right)$ 为整数时间步数。从指定的初始条件 $u_0(x)$ 开始，将给定格式精确推进 $n_{\\text{steps}}$ 步，以获得在时间 $t' = n_{\\text{steps}} \\Delta t$ 的数值解。\n3. 计算在时间 $t'$ 的精确解，公式为 $u_{\\text{exact}}(x_i,t') = u_0\\!\\left((x_i - a t') \\bmod L\\right)$。\n4. 计算离散、归一化的 $\\ell^2$ 误差\n$$\nE = \\frac{\\left(\\frac{1}{N}\\sum_{i=0}^{N-1}\\left(u_i^{n_{\\text{steps}}} - u_{\\text{exact}}(x_i,t')\\right)^2\\right)^{1/2}}{\\left(\\frac{1}{N}\\sum_{i=0}^{N-1}\\left(u_{\\text{exact}}(x_i,t')\\right)^2\\right)^{1/2}}.\n$$\n所有变量都是无量纲的；不需要物理单位。\n\n测试套件（每一项都是一个由初始条件和库朗数定义的独立测试用例）：\n- 光滑初始条件 $u_0(x) = \\sin\\!\\left(2\\pi x\\right)$，其中 $C = 0.9$。\n- 光滑初始条件 $u_0(x) = \\sin\\!\\left(2\\pi x\\right)$，其中 $C = 0.5$。\n- 光滑初始条件 $u_0(x) = \\sin\\!\\left(2\\pi x\\right)$，其中 $C = 0.1$。\n- 光滑初始条件 $u_0(x) = \\sin\\!\\left(2\\pi x\\right)$，其中 $C = 10^{-4}$。\n- 不连续初始条件\n$$\nu_0(x) =\n\\begin{cases}\n1, & 0.25 \\le x < 0.75,\\\\\n0, & \\text{其他情况},\n\\end{cases}\n$$\n其中 $C = 0.9$。\n- 如上的不连续初始条件，其中 $C = 0.5$。\n- 如上的不连续初始条件，其中 $C = 0.1$。\n- 如上的不连续初始条件，其中 $C = 10^{-4}$。\n\n您的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，顺序如下：\n$$\n\\big[ E_{\\text{smooth},\\,0.9},\\; E_{\\text{smooth},\\,0.5},\\; E_{\\text{smooth},\\,0.1},\\; E_{\\text{smooth},\\,10^{-4}},\\; E_{\\text{box},\\,0.9},\\; E_{\\text{box},\\,0.5},\\; E_{\\text{box},\\,0.1},\\; E_{\\text{box},\\,10^{-4}} \\big].\n$$\n每个条目必须是一个浮点数。该测试套件旨在揭示，尽管对于所有 $C \\in (0,1]$ 格式都是稳定的，但过小的 $C$（例如 $C = 10^{-4}$）会降低精度，因为即使在固定网格上，在积分时间内累积的格式诱导的数值扩散也很大。", "solution": "我们分析用于一维线性平流方程的一阶迎风法。平流方程为\n$$\nu_t + a u_x = 0,\n$$\n其中 $a > 0$。在均匀网格 $x_i = i\\,\\Delta x$ 上，显式迎风格式更新为\n$$\nu_i^{n+1} = u_i^n - C\\left(u_i^n - u_{i-1}^n\\right),\n$$\n其中库朗数为 $C = \\dfrac{a\\,\\Delta t}{\\Delta x}$，并使用周期性索引以使 $u_{-1}^n = u_{N-1}^n$。在 Courant–Friedrichs–Lewy (CFL) 条件下，该格式对于所有 $C \\in (0,1]$ 都是单调且稳定的。\n\n理解其精度影响的一个基本方法是通过修正方程。在时间和空间上进行泰勒展开并匹配各项。迎风法的领先阶修正方程为\n$$\nu_t + a u_x = \\nu_{\\text{num}}\\,u_{xx} + \\mathcal{O}(\\Delta x^2, \\Delta t^2),\n$$\n其中格式诱导的数值扩散系数为\n$$\n\\nu_{\\text{num}} = \\frac{a\\,\\Delta x}{2}\\,(1 - C).\n$$\n这表明离散化表现为带有附加扩散项的平流：$C$ 越小（在固定的 $\\Delta x$ 和 $a$ 下），$\\nu_{\\text{num}}$ 就越大，当 $C \\to 0$ 时达到 $\\nu_{\\text{num}} \\approx \\frac{a\\,\\Delta x}{2}$。反之，当 $C \\to 1$ 时，$\\nu_{\\text{num}} \\to 0$，这解释了一个众所周知的事实：一阶迎风法在 $C=1$ 附近扩散性最小。在固定的物理时长内，累积扩散随 $\\nu_{\\text{num}}$ 增长，因此在固定网格上随着 $C$ 的减小而增加，从而导致尽管稳定但精度较差。\n\n我们也可以在傅里叶域中分析该格式。对于离散傅里叶模 $e^{\\mathrm{i}\\theta i}$（其中 $\\theta \\in [-\\pi,\\pi]$），迎风格式的放大因子为\n$$\nG(\\theta) = (1 - C) + C\\,e^{-\\mathrm{i}\\theta}.\n$$\n其模长为\n$$\n|G(\\theta)| = \\sqrt{(1 - C + C\\cos\\theta)^2 + (C\\sin\\theta)^2} \\le 1,\n$$\n仅当 $\\theta = 0$ 或 $C = 1$ 时等号成立。对于 $C \\in (0,1)$ 和 $\\theta \\ne 0$，我们有 $|G(\\theta)| < 1$，这会衰减模式并模拟扩散。经过 $n$ 个时间步，该模式被乘以 $G(\\theta)^n$，在连续统中对应于一个近似为 $\\exp\\left(-\\nu_{\\text{num}} k^2 t\\right)$ 的有效扩散衰减，其中 $k = \\theta/\\Delta x$ 且 $t = n\\Delta t$。\n\n为了计算效率和相对于周期网格上离散格式的精确性，我们避免显式地迭代 $n$ 步。相反，我们计算初始数据的离散傅里叶变换（通过离散傅里叶变换），将每个傅里叶系数乘以 $G(\\theta)^n$，然后应用逆变换以获得 $n$ 步后的数值解：\n$$\n\\widehat{u}^{\\,n}_m = \\left(G(\\theta_m)\\right)^n \\widehat{u}^{\\,0}_m, \\quad \\theta_m = \\frac{2\\pi m}{N},\n$$\n其中 $m$ 是快速傅里叶变换标准排序中的离散傅里叶模式的索引。此过程提供了线性格式在周期网格上 $n$ 步后的精确结果，而不会因多次时间循环迭代而产生舍入误差累积。\n\n对于每个测试用例，我们按以下步骤进行：\n1. 设置 $L = 1$, $a = 1$, $N = 128$, $\\Delta x = L/N$ 和目标库朗数 $C$。\n2. 设置 $\\Delta t = C\\,\\Delta x / a$。计算 $n_{\\text{steps}} = \\operatorname{round}(T/\\Delta t)$ 和 $t' = n_{\\text{steps}}\\Delta t$。\n3. 按规定定义初始条件 $u_0(x)$。对于光滑情况， $u_0(x) = \\sin(2\\pi x)$。对于不连续（方波）情况，\n$$\nu_0(x) = \\begin{cases}\n1, & 0.25 \\le x < 0.75,\\\\\n0, & \\text{其他情况}.\n\\end{cases}\n$$\n4. 计算在 $t'$ 的精确解：$u_{\\text{exact}}(x_i, t') = u_0\\!\\left((x_i - a t') \\bmod L\\right)$。\n5. 通过应用上述带有放大因子 $G(\\theta_m)$ 的格式的谱形式，计算 $n_{\\text{steps}}$ 步后的数值解。\n6. 计算归一化的离散 $\\ell^2$ 误差\n$$\nE = \\frac{\\left(\\frac{1}{N}\\sum_{i=0}^{N-1}\\left(u_i^{n_{\\text{steps}}} - u_{\\text{exact}}(x_i,t')\\right)^2\\right)^{1/2}}{\\left(\\frac{1}{N}\\sum_{i=0}^{N-1}\\left(u_{\\text{exact}}(x_i,t')\\right)^2\\right)^{1/2}}.\n$$\n\n因为在固定 $\\Delta x$ 的情况下，$\\nu_{\\text{num}}$ 随着 $C$ 的减小而增长，我们预计当 $C$ 接近 1 时误差最小，并且随着 $C$ 减小到 0.5，再到 0.1，特别是到 $10^{-4}$ 时，误差会增加。这对于光滑和不连续的初始数据都成立，其中不连续情况表现出更强的可见涂抹效应，这是因为其高频模式含量更高，而当 $C$ 非常小时，这些模式被 $|G(\\theta)|^n$ 更严重地衰减。程序实现了这一逻辑，并以要求的单行列表格式报告了八个指定测试用例的误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef initial_condition(x, kind):\n    if kind == \"smooth\":\n        return np.sin(2.0 * np.pi * x)\n    elif kind == \"box\":\n        # Indicator: 1 on [0.25, 0.75), 0 elsewhere\n        return ((x >= 0.25) & (x < 0.75)).astype(float)\n    else:\n        raise ValueError(\"Unknown initial condition kind.\")\n\ndef exact_solution(x, t, a, L, kind):\n    # Periodic shift by a*t\n    x_shift = (x - a * t) % L\n    return initial_condition(x_shift, kind)\n\ndef upwind_after_n_steps_fft(u0, C, nsteps):\n    \"\"\"\n    Compute the result of nsteps of explicit upwind for a>0 on a periodic grid\n    by applying the scheme's amplification factor in Fourier space.\n    \"\"\"\n    N = u0.size\n    # Discrete Fourier mode angles theta_m = 2*pi*m/N in FFT ordering.\n    m = np.fft.fftfreq(N, d=1.0 / N)  # integer mode indices in FFT order\n    theta = 2.0 * np.pi * m / N\n    G = (1.0 - C) + C * np.exp(-1j * theta)\n    # Raise symbol to power nsteps; this is exact for the linear scheme.\n    G_n = G ** int(nsteps)\n    U0 = np.fft.fft(u0)\n    Un = np.fft.ifft(G_n * U0).real\n    return Un\n\ndef normalized_l2_error(u_num, u_ex):\n    diff = u_num - u_ex\n    num = np.sqrt(np.mean(diff * diff))\n    den = np.sqrt(np.mean(u_ex * u_ex))\n    # To avoid division by zero in degenerate cases\n    if den == 0.0:\n        return float(num)\n    return float(num / den)\n\ndef solve():\n    # Fixed configuration (nondimensional)\n    L = 1.0\n    a = 1.0\n    N = 128\n    T = 0.02\n    dx = L / N\n    x = np.linspace(0.0, L, N, endpoint=False)\n\n    # Test suite: list of (initial_condition_kind, Courant number)\n    test_cases = [\n        (\"smooth\", 0.9),\n        (\"smooth\", 0.5),\n        (\"smooth\", 0.1),\n        (\"smooth\", 1e-4),\n        (\"box\", 0.9),\n        (\"box\", 0.5),\n        (\"box\", 0.1),\n        (\"box\", 1e-4),\n    ]\n\n    results = []\n    for kind, C in test_cases:\n        dt = C * dx / a\n        # Integer number of steps; use round to get the nearest integer\n        nsteps = int(np.round(T / dt)) if dt > 0 else 0\n        # Actual time reached\n        t_prime = nsteps * dt\n\n        # Initial condition and exact solution at t_prime\n        u0 = initial_condition(x, kind)\n        u_exact = exact_solution(x, t_prime, a, L, kind)\n\n        # Numerical solution after nsteps using FFT representation\n        u_num = upwind_after_n_steps_fft(u0, C, nsteps)\n\n        # Normalized L2 error\n        E = normalized_l2_error(u_num, u_exact)\n        results.append(E)\n\n    # Final print statement in the exact required format.\n    print(\"[\" + \",\".join(f\"{val:.12g}\" for val in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2443006"}, {"introduction": "真实世界的仿真常常涉及变化的物理参数，例如波速，这使得固定时间步长不再适用。本练习将指导你从理论走向实践，设计一个自适应时间步长控制器，它会根据变化的波速 $V(t)$ 动态调整 $\\Delta t$，以维持一个理想的库朗数。[@problem_id:2443027] 这是一项计算工程师的核心实践，通过构建一个稳健的控制器，你将学会如何将CFL理论应用于开发高效且可靠的仿真代码。", "problem": "请为一个一维显式格式实现一个自适应时间步长控制器。该格式用于推进一个双曲守恒律问题，其中信息以速度 $V(t) \\ge 0$ 沿特征线传播。数值网格的间距是均匀的 $\\,\\Delta x\\,$，显式时间积分器在时间 $\\,t_n\\,$ 处以步长 $\\,\\Delta t_n\\,$ 向前推进。Courant–Friedrichs–Lewy (CFL) 条件要求数值依赖域必须包含物理依赖域，这给由 $\\,\\sigma_n = V(t_n)\\,\\Delta t_n / \\Delta x\\,$ 定义的无量纲 Courant 数 $\\,\\sigma_n\\,$ 施加了限制。在本问题中，您将从第一性原理出发，推导如何维持一个目标 Courant 数 $\\,\\sigma_\\star \\in (0,1)\\,$，并实现一个施加额外实际约束的自适应控制器。\n\n您必须设计一个控制器，在每个被接受的时间 $\\,t_n\\,$ 处执行以下操作：\n- 基于瞬时特征速度 $\\,V(t_n)\\,$ 和 CFL 思想计算一个候选步长 $\\,\\Delta t^{\\text{cand}}_{n+1}\\,$，旨在使 $\\,\\sigma_{n+1}\\,$ 保持在固定的目标值 $\\,\\sigma_\\star\\,$ 附近。\n- 施加步长下限和上限 $\\,\\Delta t_{\\min} \\le \\Delta t_{n+1} \\le \\Delta t_{\\max}\\,$，其中 $\\,\\Delta t_{\\min} > 0\\,$ 且 $\\,\\Delta t_{\\max} \\ge \\Delta t_{\\min}\\,$，单位为秒。\n- 施加一个步长变化限制器 $\\,\\varrho \\ge 1\\,$，使得连续步长满足 $\\,\\Delta t_{n+1} \\le \\varrho\\,\\Delta t_n\\,$ 和 $\\,\\Delta t_{n+1} \\ge \\Delta t_n/\\varrho\\,$，从而防止步长的剧烈变化。\n- 应用终端限制，以使时间不会超过预设的最终时间 $\\,t_{\\text{end}}\\,$；也就是说，如果 $\\,t_n + \\Delta t_{n+1} > t_{\\text{end}}\\,$，则将 $\\,\\Delta t_{n+1}\\,$ 替换为 $\\,t_{\\text{end}} - t_n\\,$。该终端限制可以违反步长下限和变化限制器，但其值不得为负。\n- 将 $\\,V(t_n) = 0\\,$ 的情况视为不施加 CFL 限制，因此旨在在满足各项界限、变化限制器和终端限制的条件下，采用允许的最大步长。\n\n请从 Courant 数的定义和双曲问题的依赖域概念开始。除了它是一个具有标准 CFL 型限制的显式格式外，不要假定任何特定的有限差分模板。根据这些原理推导控制器公式，不要预先引用目标公式。清楚地证明您所选择的 $\\,\\Delta t^{\\text{cand}}_{n+1}\\,$ 为何具有您所实现的形式。\n\n为了验证，请实现一个程序，通过重复根据控制器选择 $\\,\\Delta t_n\\,$ 来从 $\\,t_0\\,$ 积分到 $\\,t_{\\text{end}}\\,$，并记录在每个被接受的步长（包括终端步长）处实现的 Courant 数 $\\,\\sigma_n = V(t_n)\\,\\Delta t_n/\\Delta x\\,$。对于每个测试用例，请报告以下列表：\n- 接受的步长总数（整数）$\\,N\\,$。\n- 实现的最大 Courant 数 $\\,\\max_n \\sigma_n\\,$（无量纲）。\n- 实现的最小 Courant 数 $\\,\\min_n \\sigma_n\\,$（无量纲）。\n- 实现的 Courant 数的算术平均值 $\\,\\frac{1}{N}\\sum_{n=1}^{N} \\sigma_n\\,$（无量纲）。\n- 最后一个被接受的步长大小 $\\,\\Delta t_N\\,$，单位为秒。\n\n所有物理量必须使用国际单位制。具体来说，$\\,\\Delta x\\,$ 以米为单位，$\\,V(t)\\,$ 以米/秒为单位，$\\,\\Delta t\\,$ 以秒为单位，$\\,t\\,$ 以秒为单位。当出现三角函数时，其参数必须以弧度为单位。\n\n测试套件。使用以下三个案例，每个案例都有一个速度函数 $\\,V(t)\\,$、一个目标值 $\\,\\sigma_\\star\\,$、界限 $\\,\\Delta t_{\\min}\\,$ 和 $\\,\\Delta t_{\\max}\\,$、一个步长变化限制器 $\\,\\varrho\\,$、一个空间步长 $\\,\\Delta x\\,$ 和一个时间区间 $[t_0, t_{\\text{end}}]$：\n- 案例 A (理想情况，恒定速度):\n  - $\\,\\Delta x = 0.5\\,\\text{m}\\,$, $\\,\\sigma_\\star = 0.8\\,$, $\\,\\Delta t_{\\min} = 0.01\\,\\text{s}\\,$, $\\,\\Delta t_{\\max} = 1.0\\,\\text{s}\\,$, $\\,\\varrho = 1.5\\,$, $\\,t_0 = 0.0\\,\\text{s}\\,$, $\\,t_{\\text{end}} = 5.0\\,\\text{s}\\,$,\n  - 对所有 $\\,t\\,$，$\\,V(t) = 1.25\\,\\text{m}/\\text{s}\\,$。\n- 案例 B (速度时变且增量有界，角度以弧度为单位):\n  - $\\,\\Delta x = 0.2\\,\\text{m}\\,$, $\\,\\sigma_\\star = 0.9\\,$, $\\,\\Delta t_{\\min} = 0.001\\,\\text{s}\\,$, $\\,\\Delta t_{\\max} = 0.08\\,\\text{s}\\,$, $\\,\\varrho = 1.1\\,$, $\\,t_0 = 0.0\\,\\text{s}\\,$, $\\,t_{\\text{end}} = 1.0\\,\\text{s}\\,$,\n  - $\\,V(t) = 0.5 + 0.45 \\sin(2\\pi t)\\,$，单位为米/秒，其中 $\\,2\\pi t\\,$ 以弧度为单位。\n- 案例 C (速度在某一子区间内消失):\n  - $\\,\\Delta x = 1.0\\,\\text{m}\\,$, $\\,\\sigma_\\star = 0.7\\,$, $\\,\\Delta t_{\\min} = 0.05\\,\\text{s}\\,$, $\\,\\Delta t_{\\max} = 0.5\\,\\text{s}\\,$, $\\,\\varrho = 1.2\\,$, $\\,t_0 = 0.0\\,\\text{s}\\,$, $\\,t_{\\text{end}} = 2.0\\,\\text{s}\\,$,\n  - $\\,V(t) = \\max\\{0,\\, 1.0 - 0.8\\,t\\}\\,$，单位为米/秒。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个案例产生一个列表 $[N,\\max\\sigma,\\min\\sigma,\\overline{\\sigma},\\Delta t_N]$。例如，输出格式必须为 $[\\,[\\cdots],\\,[\\cdots],\\,[\\cdots]\\,]$ 的形式，不含额外文本。所有 $\\,\\Delta t\\,$ 值必须以秒表示，所有 Courant 数都是无量纲的。报告的每个量必须是布尔值、整数、浮点数或这些基本类型的列表。", "solution": "该问题陈述科学严谨、定义明确，并包含了推导和实现自适应时间步长控制器所需的所有信息。因此，该问题被认定为有效。我们着手进行解答。\n\nCourant–Friedrichs–Lewy (CFL) 条件是用于求解双曲偏微分方程的显式数值格式的一个基本稳定性判据。它源于这样一个原理：数值算法必须能够获取确定未来某一时刻状态所需的所有物理信息。对于一维双曲系统，信息以有限速度沿特征线传播，我们将其表示为 $V(t) \\ge 0$。点 $(x_j, t_{n+1})$ 的物理依赖域是在前一时刻 $t_n$ 能够影响它的所有点的集合。对于以速度 $V$ 传播的波，假设 $V$ 在小时间间隔 $\\Delta t_n = t_{n+1} - t_n$ 内是恒定的，则在 $t_n$ 时刻的这个依赖域是区间 $[x_j - V(t_n) \\Delta t_n, x_j + V(t_n) \\Delta t_n]$。一个显式数值格式使用 $t_n$ 时刻有限个邻近网格点（例如 $\\{x_{j-k}, \\ldots, x_{j+k}\\}$）的信息来计算 $(x_j, t_{n+1})$ 处的解。数值依赖域是跨越这些点的区间 $[x_{j-k}, x_{j+k}]$。CFL 条件要求物理依赖域必须被包含在数值依赖域之内。对于标准的最近邻模板 ($k=1$)，这意味着 $V(t_n) \\Delta t_n \\le \\Delta x$。这可以用无量纲的 Courant 数 $\\sigma_n$ 来表示：\n$$ \\sigma_n = \\frac{V(t_n) \\Delta t_n}{\\Delta x} \\le 1 $$\n为了稳定性，$\\sigma_n$ 不得超过某个限制，通常是 $1$。为了效率，希望使用允许的最大时间步长，这意味着 $\\sigma_n$ 应接近这个限制。自适应时间步长控制器旨在将 $\\sigma_n$ 维持在一个目标值 $\\sigma_\\star \\in (0, 1)$ 附近，其中 $\\sigma_\\star < 1$ 提供了一个安全裕度。\n\n我们的任务是设计一个控制器，在当前时间 $t_n$ 选择时间步长 $\\Delta t_{n+1}$。我们的目标是使随后的 Courant 数 $\\sigma_{n+1} = V(t_{n+1}) \\Delta t_{n+1} / \\Delta x$ 约等于 $\\sigma_\\star$。由于我们在 $t_n$ 时刻不知道 $V(t_{n+1})$，我们使用可用的信息 $V(t_n)$ 作为区间 $[t_n, t_{n+1}]$ 内特征速度的最佳估计。因此，我们的目标是：\n$$ \\sigma_\\star \\approx \\frac{V(t_n) \\Delta t_{n+1}}{\\Delta x} $$\n求解 $\\Delta t_{n+1}$ 得出纯粹基于 CFL 条件的候选时间步长：\n$$ \\Delta t^{\\text{cand}}_{n+1} = \\sigma_\\star \\frac{\\Delta x}{V(t_n)} $$\n此公式在 $V(t_n) > 0$ 时有效。如果 $V(t_n) = 0$，特征线在 $x$-$t$ 平面上是垂直的，不存在空间上的传播。CFL 条件对 $\\Delta t$ 不施加上限。在这种情况下，问题陈述指出我们应该争取允许的最大步长，这将由其他约束条件确定。一种实际的实现方式是，在 $V(t_n) = 0$ 时，将候选步长设置为允许的最大步长 $\\Delta t_{\\max}$。\n\n然后，该候选步长必须受到一系列实际约束，以确保积分过程的鲁棒性和平滑性：\n\n1.  **步长变化限制器**：为防止时间步长发生突然的、可能破坏稳定性的变化，我们强制要求连续步长的比率受一个因子 $\\varrho \\ge 1$ 的限制。对于 $n \\ge 1$，其中 $\\Delta t_n$ 是前一步长，下一步长 $\\Delta t_{n+1}$ 必须满足：\n    $$ \\frac{\\Delta t_n}{\\varrho} \\le \\Delta t_{n+1} \\le \\varrho \\Delta t_n $$\n    此限制器不适用于第一个时间步长 $\\Delta t_1$，因为没有前一步长 $\\Delta t_0$。\n\n2.  **绝对步长界限**：无论其他因素如何，时间步长也必须处于一个固定的范围内：\n    $$ \\Delta t_{\\min} \\le \\Delta t_{n+1} \\le \\Delta t_{\\max} $$\n    其中 $\\Delta t_{\\min} > 0$ 确保时间向前推进。\n\n3.  **终端限制**：为确保模拟在最终时间 $t_{\\text{end}}$ 精确停止，必须调整最后一步，使其不越过该时间。如果一个在其他方面可接受的步长 $\\Delta t'_{n+1}$ 会导致 $t_n + \\Delta t'_{n+1} > t_{\\text{end}}$，则必须将其替换为 $\\Delta t_{n+1} = t_{\\text{end}} - t_n$。这个最终调整具有优先权，可能导致步长小于 $\\Delta t_{\\min}$ 或违反步长变化限制器。\n\n结合这些约束，我们形成了一个在时间 $t_n$ 选择 $\\Delta t_{n+1}$ 的完整算法，给定前一步长 $\\Delta t_n$（对于 $n \\ge 1$）：\n\n首先，我们确定候选步长 $\\Delta t_{\\text{cand}}$：\n$$ \\Delta t_{\\text{cand}} = \\begin{cases} \\sigma_\\star \\frac{\\Delta x}{V(t_n)} & \\text{若 } V(t_n) > 0 \\\\ \\Delta t_{\\max} & \\text{若 } V(t_n) = 0 \\end{cases} $$\n接下来，我们定义在施加终端限制之前的步长下限和上限。设 $\\Delta t_{\\text{lower}}$ 和 $\\Delta t_{\\text{upper}}$ 为这些界限。初始时，它们由绝对限制设定：$\\Delta t_{\\text{lower}} = \\Delta t_{\\min}$ 和 $\\Delta t_{\\text{upper}} = \\Delta t_{\\max}$。如果不是第一步（$n \\ge 1$），步长变化限制器会进一步约束这些界限：\n$$ \\Delta t_{\\text{lower}} \\leftarrow \\max(\\Delta t_{\\text{lower}}, \\Delta t_n / \\varrho) $$\n$$ \\Delta t_{\\text{upper}} \\leftarrow \\min(\\Delta t_{\\text{upper}}, \\varrho \\Delta t_n) $$\n然后，通过将候选步长限制在这些界限内，得到初步步长 $\\Delta t'_{n+1}$：\n$$ \\Delta t'_{n+1} = \\max(\\Delta t_{\\text{lower}}, \\min(\\Delta t_{\\text{upper}}, \\Delta t_{\\text{cand}})) $$\n最后，应用终端限制来确定最终的步长大小 $\\Delta t_{n+1}$：\n$$ \\Delta t_{n+1} = \\min(\\Delta t'_{n+1}, t_{\\text{end}} - t_n) $$\n这个多阶段过程定义了一个鲁棒且确定性的时间步长控制器。\n\n模拟过程迭代进行。从 $t_0$ 开始，我们计算 $\\Delta t_1$（不使用步长变化限制器）。在每一步 $n=1, 2, \\dots, N$，我们处于时间 $t_{n-1}$，并计算 $\\Delta t_n$。我们记录实现的 Courant 数 $\\sigma_n = V(t_{n-1}) \\Delta t_n / \\Delta x$。然后，我们将时间推进到 $t_n = t_{n-1} + \\Delta t_n$，并存储 $\\Delta t_n$ 以用于下一步的变化限制器计算。该过程持续进行，直到 $t_n \\ge t_{\\text{end}}$。然后，从记录的历史数据中计算最终的统计数据——步数 $N$、$\\{\\sigma_n\\}$ 的最大值、最小值和平均值，以及最终步长 $\\Delta t_N$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n\n    # Define velocity functions for each case\n    def V_A(t: float) -> float:\n        \"\"\"Velocity for Case A: constant speed.\"\"\"\n        return 1.25\n\n    def V_B(t: float) -> float:\n        \"\"\"Velocity for Case B: time-varying speed.\"\"\"\n        return 0.5 + 0.45 * np.sin(2 * np.pi * t)\n\n    def V_C(t: float) -> float:\n        \"\"\"Velocity for Case C: speed with a zero interval.\"\"\"\n        return max(0.0, 1.0 - 0.8 * t)\n\n    def run_simulation(dx, sigma_star, dt_min, dt_max, rho, t_0, t_end, V_func):\n        \"\"\"\n        Performs the time integration with the adaptive step controller.\n\n        Args:\n            dx (float): Grid spacing.\n            sigma_star (float): Target Courant number.\n            dt_min (float): Minimum allowed time step.\n            dt_max (float): Maximum allowed time step.\n            rho (float): Step change limiter factor.\n            t_0 (float): Start time.\n            t_end (float): End time.\n            V_func (callable): Function V(t) for characteristic speed.\n\n        Returns:\n            list: A list containing [N, max_sigma, min_sigma, mean_sigma, last_dt].\n        \"\"\"\n        t = t_0\n        dt_prev = None\n        sigmas = []\n        num_steps = 0\n        last_dt = 0.0\n\n        # Use a small tolerance for floating-point comparisons to avoid issues near t_end\n        epsilon = 1e-12\n\n        while t < t_end - epsilon:\n            # 1. Compute candidate step from CFL condition\n            v_at_t = V_func(t)\n            if v_at_t > 0:\n                dt_cand = sigma_star * dx / v_at_t\n            else:  # v_at_t == 0, no CFL restriction, aim for largest step\n                dt_cand = dt_max\n\n            # 2. Determine constraint bounds from absolute limits and rate limiter\n            dt_upper_bound = dt_max\n            dt_lower_bound = dt_min\n            if dt_prev is not None:\n                dt_upper_bound = min(dt_upper_bound, rho * dt_prev)\n                dt_lower_bound = max(dt_lower_bound, dt_prev / rho)\n\n            # 3. Apply constraints by clamping the candidate step\n            dt_next = max(dt_lower_bound, min(dt_upper_bound, dt_cand))\n\n            # 4. Apply terminal cap: ensure the step does not overshoot t_end\n            dt_next = min(dt_next, t_end - t)\n\n            # Safeguard against non-positive steps after terminal cap\n            if dt_next <= 0:\n                break\n\n            # 5. Record realized Courant number for the current step\n            realized_sigma = v_at_t * dt_next / dx\n            sigmas.append(realized_sigma)\n\n            # 6. Advance time and update state for the next iteration\n            t += dt_next\n            dt_prev = dt_next\n            last_dt = dt_next\n            num_steps += 1\n        \n        if not sigmas:  # Handle case of no steps being taken\n            return [0, 0.0, 0.0, 0.0, 0.0]\n\n        # Calculate final statistics\n        N = num_steps\n        max_sigma = max(sigmas)\n        min_sigma = min(sigmas)\n        mean_sigma = sum(sigmas) / N\n\n        return [N, max_sigma, min_sigma, mean_sigma, last_dt]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {'dx': 0.5, 'sigma_star': 0.8, 'dt_min': 0.01, 'dt_max': 1.0, 'rho': 1.5, 't_0': 0.0, 't_end': 5.0, 'V_func': V_A},\n        # Case B\n        {'dx': 0.2, 'sigma_star': 0.9, 'dt_min': 0.001, 'dt_max': 0.08, 'rho': 1.1, 't_0': 0.0, 't_end': 1.0, 'V_func': V_B},\n        # Case C\n        {'dx': 1.0, 'sigma_star': 0.7, 'dt_min': 0.05, 'dt_max': 0.5, 'rho': 1.2, 't_0': 0.0, 't_end': 2.0, 'V_func': V_C}\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = run_simulation(**case_params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2443027"}]}