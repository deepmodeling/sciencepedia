{"hands_on_practices": [{"introduction": "任何实际问题的数值模拟都离不开对边界条件的精确处理。如何将物理边界（如固定的温度或热流密度）准确地转化为离散代数方程，是决定计算结果可靠性的关键。本练习将通过一个混合边界值问题，带你亲手推导并实现不同精度的诺伊曼 (Neumann) 边界条件，并借助“人造解”方法来严格检验你的代码，这是计算科学家必须掌握的一项基本功 [@problem_id:2392121]。", "problem": "考虑二维拉普拉斯方程，该方程指出，对于域 $\\Omega \\subset \\mathbb{R}^2$ 上的一个充分光滑的标量场 $u(x,y)$，其控制方程为 $\\nabla^2 u = \\partial^2 u/\\partial x^2 + \\partial^2 u/\\partial y^2 = 0$。你将在方形域 $\\Omega = [0,1]\\times[0,1]$ 上进行研究，并探讨一个混合边值问题，其中狄利克雷条件与诺伊曼条件在一个角点相遇。\n\n从拉普拉斯算子的基本定义和标准的泰勒展开出发，构建内部方程的有限差分-离散化以及一致的边界封闭格式。目标是检验在狄利克雷条件与诺伊曼条件相遇的角点附近，离散解的行为。\n\n问题说明如下。\n\n- 控制偏微分方程(PDE)：在 $\\Omega$ 内 $\\nabla^2 u = 0$。\n- 精确的调和人造解：$u_e(x,y) = e^x \\cos(y)$。\n- 由 $u_e$ 确定的边界条件：\n  - 底边 ($y=0$)：狄利克雷条件 $u(x,0) = u_e(x,0) = e^x$。\n  - 顶边 ($y=1$)：狄利克雷条件 $u(x,1) = u_e(x,1) = e^x \\cos(1)$。\n  - 右边 ($x=1$)：狄利克雷条件 $u(1,y) = u_e(1,y) = e \\cos(y)$。\n  - 左边 ($x=0$)：诺伊曼条件，指定外法向导数。在 $x=0$ 处，单位外法向量指向 x 负方向，因此 $\\partial u/\\partial n = -\\partial u/\\partial x$。规定 $\\partial u/\\partial n \\big|_{x=0} = -\\cos(y)$，这与精确解相符，因为 $\\partial u_e/\\partial x \\big|_{x=0} = \\cos(y)$。\n\n使用一个均匀的笛卡尔网格，每个坐标方向有 $n$ 个内部点，网格间距为 $h = 1/(n+1)$，网格点为 $(x_i,y_j) = (ih,jh)$，其中整数 $i,j \\in \\{0,1,\\dots,n+1\\}$。设未知量集合为内部值 $u_{i,j} \\approx u(x_i,y_j)$，其中 $i,j \\in \\{1,2,\\dots,n\\}$。\n\n- 内部离散化：通过将泰勒展开截断至 $h$ 的二阶，推导内部节点处拉普拉斯算子的标准 $5$ 点有限差分近似。\n- 狄利克雷边界：将狄利克雷数据以与内部模板一致的方式整合到右端项中。\n- $x=0$ 上的诺伊曼边界：在第一个内部列 $i=1$ 处推导两种不同的边界封闭格式，用内部值和已知的诺伊曼数据来消去未知的边界值 $u_{0,j}$：\n  - 基于在 $x=0$ 处使用 $(u_{1,j}-u_{0,j})/h$ 对 $\\partial u/\\partial x$ 进行单边差分的一阶封闭格式。\n  - 基于在 $x=0$ 处使用 $(-3u_{0,j}+4u_{1,j}-u_{2,j})/(2h)$ 对 $\\partial u/\\partial x$ 进行单边三点计算的二阶封闭格式。\n在两种情况下，都使用规定的外法向导数与 $\\partial u/\\partial x$ 之间的关系，将 $x=0$ 处的诺伊曼数据代入离散方程中。\n\n你的任务：\n- 从泰勒展开出发，推导与上述诺伊曼条件一致的内部 $5$ 点模板和在 $x=0$ 处的两种边界封闭格式。\n- 对多个网格尺寸 $n$，组合并求解得到的关于内部未知数的线性系统。\n- 量化数值解在狄利克雷边界和诺伊曼边界相遇的角点附近的具体行为，即在最靠近角点 $(x,y)=(0,0)$ 的内部节点 $(x,y)=(h,h)$ 处的行为。\n\n测试套件与答案规范：\n- 使用三个 $n$ 值：$n \\in \\{15,31,63\\}$。\n- 对于每个 $n$，求解系统两次，一次使用一阶诺伊曼封闭格式，一次使用二阶诺伊曼封闭格式。\n- 对于每次求解，计算在邻近角的内部节点 $(i,j)=(1,1)$ 处的绝对点误差，即 $\\lvert u_{1,1} - u_e(h,h)\\rvert$。\n- 另外，仅对于 $n=63$，分别对一阶和二阶诺伊曼封闭格式，计算所有内部节点上的最大范数误差，即 $\\max_{1\\le i,j\\le n} \\lvert u_{i,j} - u_e(x_i,y_j)\\rvert$。\n\n最终输出格式：\n- 你的程序必须生成单行结果，该结果是包含在方括号内的逗号分隔列表。列表必须按以下顺序排列：\n  - 在 $n=15$、$n=31$ 和 $n=63$ 时，使用一阶诺伊曼封闭格式的三个邻近角点的绝对误差。\n  - 在 $n=15$、$n=31$ 和 $n=63$ 时，使用二阶诺伊曼封闭格式的三个邻近角点的绝对误差。\n  - 对于 $n=63$，所有内部节点上的两个最大范数误差，首先是一阶封闭格式，然后是二阶封闭格式。\n- 所有数字必须以科学记数法打印为浮点值，并四舍五入到八位有效数字。\n- 所需格式示例（仅为说明）：[$1.23456789e-03,5.67891234e-04,9.10111213e-05, \\dots$]。\n\n本问题不涉及物理单位。当角度出现在三角函数内部时，单位为弧度。输出必须严格遵循指定的单行格式，包含正好八个数字。", "solution": "所给问题是一个关于二维拉普拉斯方程的适定边值问题，利用人造解方法进行验证。该问题具有科学依据、内容完备且客观，不存在不一致或谬误之处。因此，我们着手求解。\n\n分析的结构如下：首先，我们从基本的泰勒级数展开推导内部节点和边界节点的有限差分模板。其次，我们将全局线性方程组的组合过程形式化。最后，我们实现这一公式来计算指定的误差度量。\n\n设域 $\\Omega = [0,1]\\times[0,1]$ 被一个间距为 $h = 1/(n+1)$ 的均匀网格离散化。网格点为 $(x_i, y_j) = (ih, jh)$，其中 $i,j \\in \\{0, 1, \\dots, n+1\\}$。数值解 $u_{i,j}$ 近似于精确解 $u(x_i, y_j)$。未知数是内部节点处的值，$u_{i,j}$，其中 $i,j \\in \\{1, \\dots, n\\}$。\n\n控制偏微分方程(PDE)是拉普拉斯方程：\n$$\n\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = 0\n$$\n\n**第一部分：有限差分模板的推导**\n\n**1.1. 内部节点模板**\n我们考虑一个内部节点 $(x_i, y_j)$，其中 $1 < i,j < n$。我们使用函数 $u(x,y)$ 在此点周围的泰勒级数展开。\n对于 $x$ 方向：\n$$\nu(x_i+h, y_j) = u(x_i, y_j) + h \\frac{\\partial u}{\\partial x} \\bigg|_{(x_i,y_j)} + \\frac{h^2}{2!} \\frac{\\partial^2 u}{\\partial x^2} \\bigg|_{(x_i,y_j)} + \\frac{h^3}{3!} \\frac{\\partial^3 u}{\\partial x^3} \\bigg|_{(x_i,y_j)} + O(h^4)\n$$\n$$\nu(x_i-h, y_j) = u(x_i, y_j) - h \\frac{\\partial u}{\\partial x} \\bigg|_{(x_i,y_j)} + \\frac{h^2}{2!} \\frac{\\partial^2 u}{\\partial x^2} \\bigg|_{(x_i,y_j)} - \\frac{h^3}{3!} \\frac{\\partial^3 u}{\\partial x^3} \\bigg|_{(x_i,y_j)} + O(h^4)\n$$\n将这两个展开式相加，可以消去奇数阶导数项：\n$$\nu(x_i+h, y_j) + u(x_i-h, y_j) = 2u(x_i, y_j) + h^2 \\frac{\\partial^2 u}{\\partial x^2} \\bigg|_{(x_i,y_j)} + O(h^4)\n$$\n整理得到二阶偏导数的二阶精确中心差分格式：\n$$\n\\frac{\\partial^2 u}{\\partial x^2} \\bigg|_{(x_i,y_j)} = \\frac{u(x_{i+1}, y_j) - 2u(x_i, y_j) + u(x_{i-1}, y_j)}{h^2} + O(h^2)\n$$\n用离散对应值 $u_{i,j}$ 替换函数值，我们得到：\n$$\n\\frac{\\partial^2 u}{\\partial x^2} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2}\n$$\n同理，对于 $y$ 方向导数的离散化为：\n$$\n\\frac{\\partial^2 u}{\\partial y^2} \\approx \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2}\n$$\n将它们代入拉普拉斯方程 $\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = 0$，我们发现：\n$$\n\\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} = 0\n$$\n两边乘以 $h^2$ 得到内部节点的标准 $5$ 点模板：\n$$\nu_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j} = 0\n$$\n\n**1.2. $x=0$ 处的诺伊曼边界封闭格式**\n左边界（$x=0$）上的诺伊曼条件为 $\\frac{\\partial u}{\\partial n} = -\\frac{\\partial u}{\\partial x} = -\\cos(y)$。这意味着我们必须强制 $\\frac{\\partial u}{\\partial x}(0,y) = \\cos(y)$。\n我们在此边界附近的节点处，也就是对于 $i=1$ 和 $j \\in \\{1,\\dots,n\\}$，应用 $5$ 点模板。此模板涉及值 $u_{0,j}$，这些值位于边界上，不属于主要未知数集合。我们必须使用诺伊曼条件来消去 $u_{0,j}$。\n\n令 $g_j = \\cos(y_j) = \\cos(jh)$。\n\n**情况1：一阶封闭格式**\n我们使用一阶精确的前向差分来近似边界 $(x_0, y_j)$ 处的导数：\n$$\n\\frac{\\partial u}{\\partial x} \\bigg|_{(0,y_j)} = \\frac{u(h,y_j) - u(0,y_j)}{h} + O(h)\n$$\n使用离散符号并将其设置为规定值：\n$$\n\\frac{u_{1,j} - u_{0,j}}{h} = g_j \\implies u_{0,j} = u_{1,j} - h g_j\n$$\n将这个关于“虚拟”值 $u_{0,j}$ 的表达式代入 $(1,j)$ 处的标准模板中：\n$$\nu_{2,j} + u_{0,j} + u_{1,j+1} + u_{1,j-1} - 4u_{1,j} = 0\n$$\n$$\nu_{2,j} + (u_{1,j} - h g_j) + u_{1,j+1} + u_{1,j-1} - 4u_{1,j} = 0\n$$\n这简化为 $i=1$ 处节点的修正模板：\n$$\nu_{2,j} + u_{1,j+1} + u_{1,j-1} - 3u_{1,j} = h g_j\n$$\n\n**情况2：二阶封闭格式**\n为了保持内部离散化的二阶精度，我们按要求使用一个二阶单边格式来计算导数。我们从泰勒级数推导此格式。设 $u_x = \\frac{\\partial u}{\\partial x}|_{(0,y_j)}$ 和 $u_{xx} = \\frac{\\partial^2 u}{\\partial x^2}|_{(0,y_j)}$。\n$$\nu_{1,j} = u_{0,j} + h u_x + \\frac{h^2}{2} u_{xx} + O(h^3) \\quad (1)\n$$\n$$\nu_{2,j} = u_{0,j} + 2h u_x + \\frac{(2h)^2}{2} u_{xx} + O(h^3) = u_{0,j} + 2h u_x + 2h^2 u_{xx} + O(h^3) \\quad (2)\n$$\n为了消去 $u_{xx}$，我们计算 $4 \\times (1) - (2)$：\n$$\n4u_{1,j} - u_{2,j} = (4u_{0,j} - u_{0,j}) + (4h u_x - 2h u_x) + O(h^3) = 3u_{0,j} + 2h u_x + O(h^3)\n$$\n解出 $u_x$ 得到所需的格式：\n$$\nu_x = \\frac{-3u_{0,j} + 4u_{1,j} - u_{2,j}}{2h} + O(h^2)\n$$\n将其设为 $g_j$，允许我们用内部点来表示 $u_{0,j}$：\n$$ \\frac{-3u_{0,j} + 4u_{1,j} - u_{2,j}}{2h} = g_j \\implies u_{0,j} = \\frac{1}{3}(4u_{1,j} - u_{2,j} - 2h g_j) $$\n将此代入 $(1,j)$ 处的标准模板中：\n$$\nu_{2,j} + \\frac{1}{3}(4u_{1,j} - u_{2,j} - 2h g_j) + u_{1,j+1} + u_{1,j-1} - 4u_{1,j} = 0\n$$\n两边乘以 $3$ 以消去分母：\n$$\n3u_{2,j} + (4u_{1,j} - u_{2,j} - 2h g_j) + 3u_{1,j+1} + 3u_{1,j-1} - 12u_{1,j} = 0\n$$\n这简化为 $i=1$ 处节点的二阶精确修正模板：\n$$\n2u_{2,j} + 3u_{1,j+1} + 3u_{1,j-1} - 8u_{1,j} = 2h g_j\n$$\n\n**1.3. 狄利克雷边界**\n狄利克雷边界条件通过将已知的边界值移到线性系统的右端来施加。边界值由精确解 $u_e(x,y) = e^x \\cos(y)$ 确定。\n- 底部 ($j=0$)：$u_{i,0} = u_e(x_i, 0) = e^{ih}$\n- 顶部 ($j=n+1$)：$u_{i,n+1} = u_e(x_i, 1) = e^{ih} \\cos(1)$\n- 右侧 ($i=n+1$)：$u_{n+1,j} = u_e(1, y_j) = e \\cos(jh)$\n\n对于邻近狄利克雷边界的内部节点 $(i,j)$，模板方程包含已知值。例如，在靠近底部边界的点 $(i,1)$ 处，标准模板 $u_{i+1,1} + u_{i-1,1} + u_{i,2} + u_{i,0} - 4u_{i,1} = 0$ 变为 $u_{i+1,1} + u_{i-1,1} + u_{i,2} - 4u_{i,1} = -u_{i,0} = -e^{ih}$。\n\n在邻近角点的节点 $(1,1)$ 处，模板必须同时考虑左侧的诺伊曼条件和底部的狄利克雷条件。例如，对于二阶封闭格式，对于 $j=1$ 的方程是 $2u_{2,1} + 3u_{1,2} + 3u_{1,0} - 8u_{1,1} = 2h g_1$。项 $u_{1,0}$ 是已知的（$u_{1,0} = e^h$），因此方程变为 $2u_{2,1} + 3u_{1,2} - 8u_{1,1} = 2h \\cos(h) - 3e^h$。\n\n**第二部分：线性系统的组合与求解**\n所有 $n^2$ 个内部节点的离散方程构成一个大型稀疏线性系统，形式为 $\\mathbf{A} \\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u}$ 是一个包含 $n^2$ 个未知值 $u_{i,j}$ 的向量，例如，可以按行排序。矩阵 $\\mathbf{A}$ 和向量 $\\mathbf{b}$ 是通过遍历每个内部节点 $(i,j)$（其中 $i,j \\in \\{1,\\dots,n\\}$）并根据推导的模板填充系统的相应行来构建的。\n\n实现将使用稀疏矩阵格式（`scipy.sparse`）来构建此系统以提高效率，并使用直接稀疏求解器（`scipy.sparse.linalg.spsolve`）来求解它。对每个指定的 $n$ 值以及一阶和二阶诺伊曼封闭格式都执行此过程。然后将数值解 $\\mathbf{u}$ 与网格点处的精确解 $u_e(x,y)$ 进行比较，以计算所需的误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to solve the Laplace problem for specified test cases\n    and print the results in the required format.\n    \"\"\"\n\n    def solve_laplace(n, neumann_order):\n        \"\"\"\n        Assembles and solves the linear system for Laplace's equation for a given\n        grid size 'n' and Neumann boundary closure 'neumann_order'.\n\n        Args:\n            n (int): Number of interior points in each direction.\n            neumann_order (int): Order of the Neumann boundary condition (1 or 2).\n\n        Returns:\n            tuple: A tuple containing:\n                - corner_error (float): Absolute error at the node (h, h).\n                - max_norm_error (float): Maximum absolute error over all interior nodes.\n        \"\"\"\n        h = 1.0 / (n + 1)\n        num_unknowns = n * n\n\n        A = lil_matrix((num_unknowns, num_unknowns))\n        b = np.zeros(num_unknowns)\n\n        # Exact solution and its derivatives for boundary conditions\n        def u_exact(x, y):\n            return np.exp(x) * np.cos(y)\n\n        # Neumann data g(y) = du/dx at x=0\n        def g(y):\n            return np.cos(y)\n\n        # Map 2D grid index (i, j) to 1D vector index k\n        def get_k(i, j):\n            return (j - 1) * n + (i - 1)\n\n        # Populate the matrix A and vector b\n        for j_idx in range(1, n + 1):  # 1-based indexing for grid\n            for i_idx in range(1, n + 1):  # 1-based indexing for grid\n                k = get_k(i_idx, j_idx)\n                x_i, y_j = i_idx * h, j_idx * h\n\n                # --- Left boundary (i_idx=1), Neumann condition ---\n                if i_idx == 1:\n                    if neumann_order == 1:\n                        # Stencil: u(2,j) + u(1,j+1) + u(1,j-1) - 3u(1,j) = h*g(y_j)\n                        A[k, k] = -3.0\n                        A[k, get_k(i_idx + 1, j_idx)] = 1.0  # u(2,j)\n                        b[k] = h * g(y_j)\n\n                        if j_idx > 1:\n                            A[k, get_k(i_idx, j_idx - 1)] = 1.0 # u(1,j-1)\n                        else:  # j_idx == 1 (Bottom boundary)\n                            b[k] -= u_exact(x_i, 0)\n                        \n                        if j_idx < n:\n                            A[k, get_k(i_idx, j_idx + 1)] = 1.0 # u(1,j+1)\n                        else:  # j_idx == n (Top boundary)\n                            b[k] -= u_exact(x_i, 1)\n\n                    elif neumann_order == 2:\n                        # Stencil: 2u(2,j) + 3u(1,j+1) + 3u(1,j-1) - 8u(1,j) = 2h*g(y_j)\n                        A[k, k] = -8.0\n                        A[k, get_k(i_idx + 1, j_idx)] = 2.0  # u(2,j)\n                        b[k] = 2.0 * h * g(y_j)\n\n                        if j_idx > 1:\n                            A[k, get_k(i_idx, j_idx - 1)] = 3.0 # u(1,j-1)\n                        else:  # j_idx == 1 (Bottom boundary)\n                            b[k] -= 3.0 * u_exact(x_i, 0)\n\n                        if j_idx < n:\n                            A[k, get_k(i_idx, j_idx + 1)] = 3.0 # u(1,j+1)\n                        else:  # j_idx == n (Top boundary)\n                            b[k] -= 3.0 * u_exact(x_i, 1)\n\n                # --- Standard interior or right boundary (i_idx > 1) ---\n                else:\n                    # Stencil: u(i-1,j) + u(i+1,j) + u(i,j-1) + u(i,j+1) - 4u(i,j) = 0\n                    A[k, k] = -4.0\n                    A[k, get_k(i_idx - 1, j_idx)] = 1.0  # u(i-1,j)\n                    \n                    if i_idx < n:\n                        A[k, get_k(i_idx + 1, j_idx)] = 1.0  # u(i+1,j)\n                    else:  # i_idx == n (Right boundary)\n                        b[k] -= u_exact(1.0, y_j)\n                    \n                    if j_idx > 1:\n                        A[k, get_k(i_idx, j_idx - 1)] = 1.0  # u(i,j-1)\n                    else:  # j_idx == 1 (Bottom boundary)\n                        b[k] -= u_exact(x_i, 0)\n                    \n                    if j_idx < n:\n                        A[k, get_k(i_idx, j_idx + 1)] = 1.0  # u(i,j+1)\n                    else:  # j_idx == n (Top boundary)\n                        b[k] -= u_exact(x_i, 1)\n        \n        # Convert A to CSR format for efficient solving\n        A_csr = A.tocsr()\n        u_sol_vec = spsolve(A_csr, b)\n        \n        # Reshape solution vector to 2D grid (row-major)\n        u_sol_grid = u_sol_vec.reshape((n, n), order='C')\n\n        # Create grid of exact solution for error calculation\n        x_coords = np.linspace(h, 1.0 - h, n)\n        y_coords = np.linspace(h, 1.0 - h, n)\n        x_grid, y_grid = np.meshgrid(x_coords, y_coords)\n        u_exact_grid = u_exact(x_grid, y_grid)\n\n        # Compute errors\n        # Python index [0, 0] corresponds to grid point (j=1, i=1) or (h,h)\n        corner_error = np.abs(u_sol_grid[0, 0] - u_exact_grid[0, 0])\n        max_norm_error = np.max(np.abs(u_sol_grid - u_exact_grid))\n        \n        return corner_error, max_norm_error\n\n    n_vals = [15, 31, 63]\n    results = []\n\n    # Calculate corner errors for 1st-order closure\n    corner_errors_order1 = []\n    max_error_order1_n63 = 0.0\n    for n_val in n_vals:\n        corner_err, max_err = solve_laplace(n_val, neumann_order=1)\n        corner_errors_order1.append(corner_err)\n        if n_val == 63:\n            max_error_order1_n63 = max_err\n\n    # Calculate corner errors for 2nd-order closure\n    corner_errors_order2 = []\n    max_error_order2_n63 = 0.0\n    for n_val in n_vals:\n        corner_err, max_err = solve_laplace(n_val, neumann_order=2)\n        corner_errors_order2.append(corner_err)\n        if n_val == 63:\n            max_error_order2_n63 = max_err\n\n    # Assemble final list in specified order\n    results.extend(corner_errors_order1)\n    results.extend(corner_errors_order2)\n    results.append(max_error_order1_n63)\n    results.append(max_error_order2_n63)\n\n    # Format for printing\n    formatted_results = [\"{:.8e}\".format(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2392121"}, {"introduction": "构建了可靠的求解器之后，我们可以用它来探索复杂现象，加深对控制方程内在属性的理解。当模型的输入数据不光滑时（例如，边界上存在温度突变），解会如何表现？本练习将引导你研究当边界条件包含跳跃间断时拉普拉斯方程的解，通过观察边界上臭名昭著的吉布斯 (Gibbs) 现象在区域内部被迅速“平滑”掉的过程，你将对椭圆型偏微分方程的平滑特性建立起深刻的直观认识 [@problem_id:2392134]。", "problem": "考虑单位正方形域 $\\Omega = (0,1) \\times (0,1)$ 上的带有狄利克雷边界条件的拉普拉斯方程。令 $u(x,y)$ 满足\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x,y) + \\frac{\\partial^2 u}{\\partial y^2}(x,y) = 0 \\quad \\text{for all } (x,y) \\in \\Omega,\n$$\n在边界 $\\partial \\Omega$ 上，边界数据为 $u(x,y) = g(x,y)$，其中 $g(x,y)$ 的具体规定如下。在上边界 $\\{(x,1) : x \\in [0,1]\\}$，于 $x_0 = 0.5$ 处定义一个单位高度的跳跃间断点。将使用两种上边界数据的变体：\n- 精确阶跃：当 $x \\in [x_0,1]$ 时，$g(x,1) = 1$；当 $x \\in [0,x_0)$ 时，$g(x,1) = 0$。\n- 截断傅里叶部分和：令 $f(x)$ 为在 $[0,x_0)$ 上取0、在 $[x_0,1)$ 上取1的阶跃函数的周期为1的延拓；对于给定的整数 $K \\ge 1$，定义\n$$\ng_K(x,1) = \\frac{1}{2} + \\frac{2}{\\pi} \\sum_{j=1}^{K} \\frac{1}{2j-1} \\sin\\!\\big(2\\pi (2j-1)(x - x_0)\\big).\n$$\n在其余三条边 $\\{(x,0): x \\in [0,1]\\}、\\{(0,y): y \\in [0,1]\\}$ 和 $\\{(1,y): y \\in [0,1]\\}$ 上，设置 $g(x,y) = 0$。在顶部两个角点 $\\{(0,1),(1,1)\\}$，采用上边界的值（即，在此处使用上边界的 $g$）。不涉及物理单位。\n\n使用间距为 $h = 1/N$ 的 $(N+1)\\times(N+1)$ 个节点的均匀网格对区域进行离散化，其中 $N$ 是一个正整数。令 $u_{i,j}$ 为网格点 $(x_i, y_j) = (ih, jh)$ 处 $u(x_i, y_j)$ 的近似值，其中整数 $i,j \\in \\{0,1,\\dots,N\\}$。在内部节点 $(i,j)$（其中 $i,j \\in \\{1,2,\\dots,N-1\\}$）上，施加标准的五点有限差分离散格式\n$$\n4 u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1} = 0,\n$$\n并在边界节点上施加狄利克雷边界值 $u_{i,j} = g(x_i,y_j)$。\n\n定义离散函数 $v_i$ 相对于一个上参考值 $U$ 的归一化正向上冲为\n$$\n\\mathcal{O}^+(v; U) = \\max\\big(0, \\max_i v_i - U\\big).\n$$\n对于下面的每种配置，您必须按规定计算两个标量值：\n1. 所选上边界数据的边界上冲（使用 $U=1$），即 $\\mathcal{O}^+\\big(\\{g(x_i,1)\\}_{i=0}^N; 1\\big)$。\n2. 沿距离上边界一步之遥的域内网格线（即 $y = 1 - h$）的内部近边界上冲，由离散解计算得出，使用 $U=1$：\n$$\n\\mathcal{O}^+\\big(\\{u(x_i,1-h)\\}_{i=0}^N; 1\\big).\n$$\n\n使用以下参数值测试套件：\n- 情况A：$N = 64$，上边界为精确阶跃。仅报告内部近边界上冲（此情况不报告边界上冲）。\n- 情况B：$N = 64$，上边界为截断傅里叶，其中 $K = 11$。报告边界上冲和内部近边界上冲。\n- 情况C：$N = 128$，上边界为截断傅里叶，其中 $K = 21$。报告边界上冲和内部近边界上冲。\n- 情况D：$N = 256$，上边界为截断傅里叶，其中 $K = 51$。报告边界上冲和内部近边界上冲。\n\n您的程序必须产生单行输出，其中包含一个方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$$\n[\\text{A\\_interior}, \\text{B\\_boundary}, \\text{B\\_interior}, \\text{C\\_boundary}, \\text{C\\_interior}, \\text{D\\_boundary}, \\text{D\\_interior}],\n$$\n每个实数四舍五入到六位小数。不应打印其他任何文本。", "solution": "问题陈述已经过验证，并被认为是有效的。它具有科学依据，是适定的和客观的。它提出了计算工程领域中的一个标准、明确定义的问题，特别是使用有限差分法对拉普拉斯方程进行数值求解。所有必要的数据和条件都已提供，不存在矛盾。在偏微分方程解的背景下研究 Gibbs 现象是一项有意义且可验证的数值实验。\n\n该问题要求解二维拉普拉斯方程，\n$$\n\\nabla^2 u(x,y) = \\frac{\\partial^2 u}{\\partial x^2}(x,y) + \\frac{\\partial^2 u}{\\partial y^2}(x,y) = 0,\n$$\n在单位正方形域 $\\Omega = (0,1) \\times (0,1)$上。解 $u(x,y)$ 必须满足指定的狄利克雷边界条件 $u(x,y) = g(x,y)$ 在边界 $\\partial \\Omega$ 上。在下、左、右边界上，边界值保持在 $g(x,y)=0$。在上边界 $y=1$ 处，边界条件由一个精确阶跃函数或其截断傅里叶级数近似给出，两者都以 $x_0=0.5$ 为中心。\n\n使用具有 $(N+1) \\times (N+1)$ 个节点 $(x_i, y_j) = (ih, jh)$ 的均匀网格对区域进行离散化，其中 $h=1/N$ 是网格间距，且 $i, j \\in \\{0, 1, \\dots, N\\}$。这些节点上的数值解记为 $u_{i,j}$。在内部节点（其中 $i,j \\in \\{1, 2, \\dots, N-1\\}$）处，使用标准的五点有限差分模板来近似拉普拉斯方程：\n$$\n\\frac{u_{i-1,j} - 2u_{i,j} + u_{i+1,j}}{h^2} + \\frac{u_{i,j-1} - 2u_{i,j} + u_{i,j+1}}{h^2} \\approx 0.\n$$\n乘以 $h^2$ 并整理各项，得到每个内部节点 $(i,j)$ 的代数方程：\n$$\n4 u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1} = 0.\n$$\n这个针对所有 $(N-1)^2$ 个内部节点的方程组构成了一个形如 $A \\mathbf{u} = \\mathbf{b}$ 的大型稀疏线性系统。未知数向量 $\\mathbf{u}$ 包含内部节点处的解值，按字典序排列：$\\mathbf{u} = [u_{1,1}, u_{2,1}, \\dots, u_{N-1,1}, u_{1,2}, \\dots, u_{N-1,N-1}]^T$。\n\n矩阵 $A$ 是一个大小为 $(N-1)^2 \\times (N-1)^2$ 的方阵。对于五点模板，它是一个对称正定的块三对角矩阵。它可以使用克罗内克积高效地构建。令 $T_{N-1}$ 为一个 $(N-1) \\times (N-1)$ 的三对角矩阵，其在次对角线和超对角线上为1，其他位置为0；令 $I_{N-1}$ 为相同大小的单位矩阵。该系统的矩阵可以表示为：\n$$\nA = 4 I_{(N-1)^2} - (I_{N-1} \\otimes T_{N-1}) - (T_{N-1} \\otimes I_{N-1}).\n$$\n右端向量 $\\mathbf{b}$ 包含了已知的边界值。当一个内部节点 $(i,j)$ 的方程涉及边界上的邻居节点时，该边界值被移到方程的右边。在这个问题中，除了上边界 $y=1$ 外，其他地方的边界值都为零。因此，$\\mathbf{b}$ 中唯一的非零项来自于最上面一行内部节点（即 $j=N-1$）的方程。对于这些节点，模板中包含了项 $u_{i,N}$，这是一个已知的边界值 $g(x_i, 1)$。相应的方程变为：\n$$\n4 u_{i,N-1} - u_{i-1,N-1} - u_{i+1,N-1} - u_{i,N-2} = g(x_i, 1).\n$$\n因此，$\\mathbf{b}$ 中对应于节点 $(i, N-1)$（其中 $i=1, \\dots, N-1$）的项等于 $g(x_i, 1)$，而所有其他项都为零。\n\n在求解线性系统 $A \\mathbf{u} = \\mathbf{b}$ 得到内部值 $\\mathbf{u}$ 之后，我们计算所需的上冲量。归一化正向上冲定义为 $\\mathcal{O}^+(v; U) = \\max(0, \\max_i v_i - U)$。\n两个关注的量是：\n1.  边界上冲：$\\mathcal{O}^+\\big(\\{g(x_i,1)\\}_{i=0}^N; 1\\big)$。这个量测量了上边界数据超过参考值 $U=1$ 的最大值。\n2.  内部近边界上冲：$\\mathcal{O}^+\\big(\\{u_{i,N-1}\\}_{i=0}^N; 1\\big)$。这个量测量了紧邻上边界内侧的网格线（在 $y=1-h$ 处）上的上冲。注意，该集合包括边界点 $u_{0,N-1}=g(0, 1-h)=0$ 和 $u_{N,N-1}=g(1, 1-h)=0$。\n\n对于情况A，上边界是一个取值为0和1的精确阶跃函数。边界上的最大值恰好是1。拉普拉斯方程的离散极值原理保证了离散解 $u_{i,j}$ 的最大值不会超过边界值的最大值。因此，对于所有内部节点，$u_{i,j} \\le 1$。所以，内部近边界上冲必须为0。\n\n对于情况B、C和D，上边界由一个截断傅里叶级数定义。具有跳跃间断点的函数的傅里叶级数近似的一个已知性质是，它们在间断点附近会表现出上冲，这一现象被称为 Gibbs 现象。这种上冲的幅度大约是跳跃高度的 $9\\%$。因此，我们预期边界函数 $g_K(x_i,1)$ 的最大值会大于1，从而导致一个正的边界上冲。内部解 $u_{i,j}$ 将会受到这个边界上冲的影响。然而，拉普拉斯算子的椭圆性质具有平滑效应。根据强极值原理，非常数解的最大值必定出现在边界上。因此，我们预期内部上冲将严格小于边界上冲，这表明了当我们进入域内部时振荡的衰减效应。\n\n计算流程包括：\n1.  对每个测试用例，定义参数 $N$ 和 $K$（如果适用）。\n2.  生成网格点 $x_i = i/N$，其中 $i=0, \\dots, N$。\n3.  根据具体情况（精确阶跃或傅里叶和）计算上边界值 $g(x_i, 1)$。\n4.  对于傅里叶情况，计算边界上冲。\n5.  构建稀疏矩阵 $A$ 和右端向量 $\\mathbf{b}$。\n6.  使用稀疏线性代数求解器求解线性系统 $A \\mathbf{u} = \\mathbf{b}$。\n7.  提取在直线 $y=1-h$ 上的解值，它们是解向量 $\\mathbf{u}$ 的最后 $N-1$ 个分量。\n8.  组合完整的行值 $\\{u_{i,N-1}\\}_{i=0}^N$，包括在 $i=0$ 和 $i=N$ 处的零边界条件。\n9.  计算内部近边界上冲。\n10. 存储结果并按要求进行格式化。\n此流程将为所有指定的测试用例实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, identity, kron\nfrom scipy.sparse.linalg import spsolve\n\ndef solve_laplace(N, g_top):\n    \"\"\"\n    Solves the 2D Laplace equation on a unit square using a 5-point\n    finite difference scheme.\n\n    Args:\n        N (int): Number of intervals in each dimension. The grid is (N+1)x(N+1).\n        g_top (np.ndarray): Array of N+1 boundary values on the top edge y=1.\n\n    Returns:\n        np.ndarray: Array of N+1 solution values u(x_i, 1-h) along the line y=1-h.\n    \"\"\"\n    N_inner = N - 1\n    M = N_inner**2\n\n    # Assemble the sparse matrix A using Kronecker products.\n    # The matrix represents the operator 4*I - (Laplacian_x + Laplacian_y)\n    # in matrix form for the interior grid points.\n    T1D = diags([1, 1], [-1, 1], shape=(N_inner, N_inner), format='csr')\n    I_n = identity(N_inner, format='csr')\n\n    A = 4 * identity(M, format='csr') - kron(I_n, T1D) - kron(T1D, I_n)\n    \n    # Assemble the right-hand side vector b.\n    # Non-zero entries only come from the top boundary condition g(x,1).\n    # These affect the equations for the top row of interior nodes (j=N-1).\n    b = np.zeros(M)\n    start_idx = (N - 2) * N_inner\n    b[start_idx:] = g_top[1:N]  # Values at x_1, ..., x_{N-1}\n\n    # Solve the sparse linear system A * u = b.\n    u_interior_flat = spsolve(A, b)\n\n    # Extract the solution at the line y = 1 - h.\n    # These correspond to the last (N-1) elements of the solution vector.\n    u_near_boundary_interior = u_interior_flat[start_idx:]\n\n    # Assemble the full row, including the boundary values u(0, 1-h) and u(1, 1-h).\n    # These are 0 as per the problem statement.\n    u_full_row = np.zeros(N + 1)\n    u_full_row[1:N] = u_near_boundary_interior\n\n    return u_full_row\n\ndef calculate_overshoot(v, U=1.0):\n    \"\"\"Calculates the normalized positive overshoot.\"\"\"\n    return max(0.0, np.max(v) - U)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'case': 'A', 'N': 64, 'type': 'exact_step'},\n        {'case': 'B', 'N': 64, 'K': 11, 'type': 'fourier'},\n        {'case': 'C', 'N': 128, 'K': 21, 'type': 'fourier'},\n        {'case': 'D', 'N': 256, 'K': 51, 'type': 'fourier'},\n    ]\n\n    results = []\n    for params in test_cases:\n        N = params['N']\n        x = np.linspace(0.0, 1.0, N + 1)\n        x0 = 0.5\n\n        if params['type'] == 'exact_step':\n            g_top = np.where(x >= x0, 1.0, 0.0)\n            \n            # Case A: only interior overshoot is reported.\n            # As per the discrete maximum principle, this must be 0.\n            # We compute it for verification.\n            u_row = solve_laplace(N, g_top)\n            interior_overshoot = calculate_overshoot(u_row)\n            results.append(interior_overshoot)\n        \n        elif params['type'] == 'fourier':\n            K = params['K']\n            g_top = np.full_like(x, 0.5, dtype=float)\n            \n            # Vectorized calculation of the truncated Fourier sum\n            j_vals = np.arange(1, K + 1)\n            coeffs = (2.0 / np.pi) * (1.0 / (2 * j_vals - 1))\n            arg_x = 2.0 * np.pi * (x[:, np.newaxis] - x0)\n            arg_j = (2 * j_vals - 1)\n            sines = np.sin(arg_x * arg_j)\n            g_top += np.sum(coeffs * sines, axis=1)\n\n            # Calculate boundary overshoot\n            boundary_overshoot = calculate_overshoot(g_top)\n            results.append(boundary_overshoot)\n\n            # Solve for and calculate interior overshoot\n            u_row = solve_laplace(N, g_top)\n            interior_overshoot = calculate_overshoot(u_row)\n            results.append(interior_overshoot)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2392134"}, {"introduction": "对于大规模科学计算，求解器的效率至关重要。经典的高斯-赛德尔 (Gauss-Seidel) 迭代法由于其固有的数据依赖性，在现代并行计算机上的性能受到限制。本练习将介绍红黑着色排序 (red-black ordering)，这是一种为并行计算而重构算法的经典技巧。你将亲手实现该算法，并与标准的逐行扫描顺序进行比较，从而深入理解如何为高性能计算优化数值算法 [@problem_id:2392150]。", "problem": "考虑在开放单位正方形域 $\\Omega=(0,1)\\times(0,1)$ 上的二维拉普拉斯方程，其带有狄利克雷边界数据。令 $u:\\overline{\\Omega}\\to\\mathbb{R}$ 满足\n$$\n\\nabla^2 u(x,y) \\;=\\; 0 \\quad \\text{for } (x,y)\\in\\Omega,\n$$\n其边界值由下式给出\n$$\nu(x,0)=0,\\quad u(0,y)=0,\\quad u(1,y)=0,\\quad u(x,1)=\\sin(\\pi x)\\quad \\text{for } (x,y)\\in\\partial\\Omega.\n$$\n使用均匀笛卡尔网格对 $\\Omega$ 进行离散化，该网格沿 $x$ 和 $y$ 方向分别有 $N_x$ 和 $N_y$ 个内部点。网格间距为 $h_x=1/(N_x+1)$ 和 $h_y=1/(N_y+1)$，网格点为 $(x_j,y_i)=(j\\,h_x,i\\,h_y)$，其中整数 $i\\in\\{0,1,\\dots,N_y+1\\}$ 和 $j\\in\\{0,1,\\dots,N_x+1\\}$。在边界网格点上精确施加边界值，并用 $u_{i,j}$ 表示在网格节点上对 $u(y_i,x_j)$ 的离散近似。\n\n在内部节点上使用拉普拉斯算子的标准五点有限差分离散。一个内部节点 $(i,j)$ 满足\n$$\nu_{i,j} \\;=\\; \\frac{1}{4}\\,\\Big(u_{i-1,j}+u_{i+1,j}+u_{i,j-1}+u_{i,j+1}\\Big)\n\\quad \\text{for all } i\\in\\{1,\\dots,N_y\\},\\; j\\in\\{1,\\dots,N_x\\}.\n$$\n\n将在一次迭代 $u$ 时的离散残差定义为\n$$\nr_{i,j} \\;=\\; \\big(u_{i-1,j}+u_{i+1,j}+u_{i,j-1}+u_{i,j+1}-4\\,u_{i,j}\\big),\n$$\n对于内部索引 $(i,j)$，残差范数由欧几里得范数定义为\n$$\n\\|r\\|_2 \\;=\\; \\Bigg(\\sum_{i=1}^{N_y}\\sum_{j=1}^{N_x} r_{i,j}^2\\Bigg)^{1/2}.\n$$\n内部节点从零初始猜测开始，边界节点由给定数据固定。\n\n单次“迭代”定义为对所有内部节点的一次完整更新。考虑两种迭代顺序：\n- 字典序，它按 $i$ 递增然后按 $j$ 递增的顺序更新内部节点。\n- 双色棋盘格排序，它根据 $i+j$ 的奇偶性将内部节点划分为两个不相交的集合，并对一种颜色进行一次子扫描，然后对另一种颜色进行一次子扫描，将两次子扫描共同计为一次迭代。\n\n对于每种方法，将 $k$ 次迭代后的相对残差定义为 $\\|r_k\\|_2/\\|r_0\\|_2$。当相对残差首次低于容差 $\\tau$（其中 $\\tau=10^{-8}$）时，或者当达到最大迭代次数 $K_{\\max}$（其中 $K_{\\max}=10^5$）时，终止迭代。对于每种方法，记录：\n- 达到停止准则所需的迭代次数 $I$（如果未达到容差，则使用 $I=K_{\\max}$），\n- 一个经验渐进收敛因子 $\\rho$，定义为在终止前的最后 $m$ 次连续迭代中比率 $\\|r_{k+1}\\|_2/\\|r_k\\|_2$ 的算术平均值，其中 $m=\\min\\{10,\\,I-1\\}$（如果 $I < 2$，则定义 $\\rho=0$）。\n\n为了分析双色棋盘格方案的并行化潜力，将理想化的每次迭代并行化潜力 $\\mathcal{P}$ 定义为两种颜色类别中较大者所占内部节点的比例，即\n$$\n\\mathcal{P} \\;=\\; \\frac{\\max\\{n_{\\text{red}},\\,n_{\\text{black}}\\}}{N_x N_y},\n$$\n其中 $n_{\\text{red}}$ 和 $n_{\\text{black}}$ 分别是 $(i+j)$ 为偶数和奇数的内部节点数量。\n\n你的程序必须为每个测试用例计算一个列表，其中包含 $I_{\\text{lex}}$、$I_{\\text{rb}}$、$\\rho_{\\text{lex}}$、$\\rho_{\\text{rb}}$ 和 $\\mathcal{P}$，其中下标“lex”和“rb”分别指字典序和双色棋盘格排序。值 $I_{\\text{lex}}$ 和 $I_{\\text{rb}}$ 必须是整数。值 $\\rho_{\\text{lex}}$、$\\rho_{\\text{rb}}$ 和 $\\mathcal{P}$ 必须报告为四舍五入到小数点后恰好 $6$ 位的小数。\n\n测试套件：\n- 案例 A：$(N_x,N_y)=(30,30)$。\n- 案例 B：$(N_x,N_y)=(1,1)$。\n- 案例 C：$(N_x,N_y)=(63,31)$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个结果列表，每个测试用例一个，按案例 A、案例 B、案例 C 的顺序排列。每个结果都是一个列表 $[I_{\\text{lex}},I_{\\text{rb}},\\rho_{\\text{lex}},\\rho_{\\text{rb}},\\mathcal{P}]$。整个输出必须是以下形式的单行字符串\n$$\n\\big[\\,[I_{\\text{lex}},I_{\\text{rb}},\\rho_{\\text{lex}},\\rho_{\\text{rb}},\\mathcal{P}],\\;[I_{\\text{lex}},I_{\\text{rb}},\\rho_{\\text{lex}},\\rho_{\\text{rb}},\\mathcal{P}],\\;[I_{\\text{lex}},I_{\\text{rb}},\\rho_{\\text{lex}},\\rho_{\\text{rb}},\\mathcal{P}]\\,\\big],\n$$\n其中每个内部列表中的三个小数值四舍五入到小数点后恰好 $6$ 位，并且没有额外文本。此问题不涉及任何物理单位，并且如果三角函数中隐式出现任何角度，根据定义均以弧度为单位。", "solution": "在 $\\Omega=(0,1)\\times(0,1)$ 上带有指定边界条件的拉普拉斯方程 $\\nabla^2 u = 0$ 存在唯一的调和解。为了进行数值近似，我们使用一个均匀笛卡尔网格对 $\\Omega$ 进行离散化，该网格在 $x$ 和 $y$ 方向上分别有 $N_x$ 和 $N_y$ 个内部点，从而得到网格间距 $h_x=1/(N_x+1)$ 和 $h_y=1/(N_y+1)$。使用标准五点模板，在内部网格索引 $(i,j)$ 处的离散拉普拉斯算子强制要求\n$$\nu_{i,j} \\;=\\; \\frac{1}{4}\\,\\Big(u_{i-1,j}+u_{i+1,j}+u_{i,j-1}+u_{i,j+1}\\Big),\n$$\n该式由 $x$ 和 $y$ 方向二阶导数的二阶中心差分推导而来，并且由于网格是均匀且各向同性的，此处简化为算术平均。边界值被直接施加：$u_{i,0}=0$，$u_{i,N_x+1}=0$，$u_{0,j}=0$，以及 $u_{N_y+1,j}=\\sin(\\pi x_j)$，其中 $x_j=j\\,h_x$。所选的边界数据与精确的调和函数 $u(x,y)=\\sin(\\pi x)\\,\\sinh(\\pi y)/\\sinh(\\pi)$ 是一致的，这确保了 $\\nabla^2 u=0$ 并且当 $N_x,N_y\\to\\infty$ 时，离散解会收敛到一个一致的极限。\n\n为了评估每次迭代的收敛性，我们将第 $k$ 次迭代 $u^{(k)}$ 的离散残差定义为\n$$\nr^{(k)}_{i,j} \\;=\\; u^{(k)}_{i-1,j}+u^{(k)}_{i+1,j}+u^{(k)}_{i,j-1}+u^{(k)}_{i,j+1}-4\\,u^{(k)}_{i,j},\n$$\n对于内部点 $(i,j)$，其欧几里得范数为\n$$\n\\|r^{(k)}\\|_2 \\;=\\; \\left(\\sum_{i=1}^{N_y}\\sum_{j=1}^{N_x}\\big(r^{(k)}_{i,j}\\big)^2\\right)^{1/2}.\n$$\n迭代线性求解器的一个标准停止条件是将相对残差 $\\|r^{(k)}\\|_2/\\|r^{(0)}\\|_2$ 界定在一个容差 $\\tau$ 之内。我们使用 $\\tau=10^{-8}$。最大迭代上限 $K_{\\max}=10^5$ 确保了在边缘情况下的终止。\n\n考虑两种迭代顺序：\n\n$1.$ 字典序更新 $u_{i,j}$，顺序为 $i=1,2,\\dots,N_y$，对于每个固定的 $i$，$j=1,2,\\dots,N_x$。每次更新都会在 $(i,j)$ 处强制执行离散方程：\n$$\nu_{i,j}^{(k+1)} \\;\\gets\\; \\frac{1}{4}\\,\\Big(u_{i-1,j}^{(k+1)}+u_{i+1,j}^{(k)}+u_{i,j-1}^{(k+1)}+u_{i,j+1}^{(k)}\\Big),\n$$\n即，在同一次扫描中新更新的值会被立即重用，这是在固定线性化顺序下的 Gauss–Seidel 迭代。\n\n$2.$ 双色棋盘格排序按奇偶性将内部索引划分为两个不相交的集合：定义“红色”集合 $\\mathcal{R}=\\{(i,j):\\,1\\le i\\le N_y,\\,1\\le j\\le N_x,\\,(i+j)\\text{ 为偶数}\\}$ 和“黑色”集合 $\\mathcal{B}=\\{(i,j):\\,1\\le i\\le N_y,\\,1\\le j\\le N_x,\\,(i+j)\\text{ 为奇数}\\}$。因为五点模板仅与其四个最近的邻居耦合，并且红色节点的每个邻居都是黑色的（反之亦然），所以给定颜色的所有节点都可以同时更新，而没有颜色内部的数据依赖性。一次完整迭代包含两次子扫描：\n$$\n\\text{红色扫描：} u_{i,j}^{(k+\\frac{1}{2})} \\;\\gets\\; \\frac{1}{4}\\,\\Big(u_{i-1,j}^{(k)}+u_{i+1,j}^{(k)}+u_{i,j-1}^{(k)}+u_{i,j+1}^{(k)}\\Big)\\quad \\text{for }(i,j)\\in\\mathcal{R},\n$$\n接着是\n$$\n\\text{黑色扫描：} u_{i,j}^{(k+1)} \\;\\gets\\; \\frac{1}{4}\\,\\Big(u_{i-1,j}^{(k+\\frac{1}{2})}+u_{i+1,j}^{(k+\\frac{1}{2})}+u_{i,j-1}^{(k+\\frac{1}{2})}+u_{i,j+1}^{(k+\\frac{1}{2})}\\Big)\\quad \\text{for }(i,j)\\in\\mathcal{B}.\n$$\n根据构造，这种排序保留了 Gauss–Seidel 属性（使用最新的可用邻居值），同时揭示了潜在的并行性，因为 $\\mathcal{R}$ 中的所有节点（以及随后的 $\\mathcal{B}$ 中的所有节点）在它们各自的子扫描期间是相互独立的。\n\n对于每种方法，我们测量两个量：\n\n$-$ 迭代次数 $I$ 是满足 $\\|r^{(k)}\\|_2/\\|r^{(0)}\\|_2\\le \\tau$ 的最小 $k$ 值，其中 $\\tau=10^{-8}$，如果未达到则 $I=K_{\\max}$。\n\n$-$ 经验渐进收敛因子 $\\rho$ 估计了在渐近状态下每次迭代的线性收缩。给定残差范数 $\\{\\|r^{(0)}\\|_2,\\dots,\\|r^{(I)}\\|_2\\}$，我们定义 $m=\\min\\{10,\\,I-1\\}$ 并计算\n$$\n\\rho \\;=\\; \\begin{cases}\n0, & I < 2,\\\n$$4pt]\n\\dfrac{1}{m}\\sum\\limits_{s=I-m}^{I-1}\\dfrac{\\|r^{(s+1)}\\|_2}{\\|r^{(s)}\\|_2}, & I \\ge 2.\n\\end{cases}\n$$\n对最后 $m$ 个比率进行平均可以抑制瞬态效应，并近似于迭代算子在主导误差模式上的谱半径。\n\n为了量化双色排序的并行化潜力，注意到红色和黑色集合划分了 $N_xN_y$ 个内部节点。它们的大小是\n$$\nn_{\\text{red}} \\;=\\; \\left\\lceil \\frac{N_xN_y}{2}\\right\\rceil,\\qquad\nn_{\\text{black}} \\;=\\; N_xN_y - n_{\\text{red}},\n$$\n因此，在每次子扫描中，较大颜色类中可并发更新的节点比例为\n$$\n\\mathcal{P} \\;=\\; \\frac{\\max\\{n_{\\text{red}},\\,n_{\\text{black}}\\}}{N_xN_y} \\;=\\; \\frac{\\left\\lceil \\frac{N_xN_y}{2}\\right\\rceil}{N_xN_y}.\n$$\n这是一个理想化的并发性度量；在实践中，硬件和内存带宽的考量会影响实际的加速效果。\n\n与这些原则一致的实现细节如下。我们使用 $u(x,1)=\\sin(\\pi x)$ 和其他地方为零来组装边界值。字典序 Gauss–Seidel 更新在 $(i,j)$ 的嵌套循环中应用平均公式，而双色更新在两次子扫描中对 $\\mathcal{R}$ 和 $\\mathcal{B}$ 应用相同的公式，这可以通过使用数组切片来高效实现，以模拟每种颜色内的同时更新。在每次完整迭代之后，我们通过将离散拉普拉斯算子应用于当前迭代并在内部节点上进行聚合来计算残差范数 $\\|r^{(k)}\\|_2$。然后我们将相对残差与 $\\tau=10^{-8}$ 进行比较，并记录如上定义的 $I$ 和 $\\rho$。对于每个测试用例 $(N_x,N_y)$，即 $\\{(30,30),(1,1),(63,31)\\}$，我们返回列表 $[I_{\\text{lex}},I_{\\text{rb}},\\rho_{\\text{lex}},\\rho_{\\text{rb}},\\mathcal{P}]$，将三个小数值四舍五入到小数点后恰好 $6$ 位，并保持迭代次数为整数。最终程序按指定顺序和格式打印一个包含这些逐案例列表的单行列表。", "answer": "```python\nimport numpy as np\n\ndef build_boundary(Nx, Ny):\n    # Full grid size includes boundaries\n    u = np.zeros((Ny + 2, Nx + 2), dtype=np.float64)\n    # Grid spacing\n    hx = 1.0 / (Nx + 1)\n    # Top boundary: y = 1 => sin(pi x)\n    x = np.linspace(0.0, 1.0, Nx + 2)\n    u[Ny + 1, :] = np.sin(np.pi * x)\n    # Other boundaries are already zero\n    return u\n\ndef residual_norm(u):\n    # Compute discrete Laplacian residual on interior using 5-point stencil\n    r = (u[0:-2, 1:-1] + u[2:, 1:-1] + u[1:-1, 0:-2] + u[1:-1, 2:] - 4.0 * u[1:-1, 1:-1])\n    return float(np.linalg.norm(r.ravel(), 2))\n\ndef iterate_lex(u, Nx, Ny, tau, kmax):\n    # Lexicographic Gauss-Seidel iterations\n    res = []\n    r0 = residual_norm(u)\n    res.append(r0)\n    if r0 == 0.0:\n        return 0, 0.0  # already converged\n    for k in range(1, kmax + 1):\n        # sweep\n        for i in range(1, Ny + 1):\n            ui_minus = u[i - 1, :]\n            ui_plus = u[i + 1, :]\n            ui = u[i, :]\n            for j in range(1, Nx + 1):\n                ui[j] = 0.25 * (ui_minus[j] + ui_plus[j] + ui[j - 1] + ui[j + 1])\n        rk = residual_norm(u)\n        res.append(rk)\n        if rk / r0 <= tau:\n            I = k\n            break\n    else:\n        I = kmax\n    # Empirical asymptotic factor\n    if len(res) < 2:\n        rho = 0.0\n    else:\n        m = min(10, len(res) - 1)\n        tail = np.array(res[-(m + 1):], dtype=np.float64)\n        # Avoid division by zero; if previous residual is zero, ratio taken as 0\n        prev = tail[:-1]\n        nxt = tail[1:]\n        ratios = np.where(prev > 0.0, nxt / prev, 0.0)\n        rho = float(np.mean(ratios))\n    return I, rho\n\ndef iterate_red_black(u, Nx, Ny, tau, kmax):\n    # Red-black Gauss-Seidel with vectorized color updates\n    res = []\n    r0 = residual_norm(u)\n    res.append(r0)\n    if r0 == 0.0:\n        return 0, 0.0\n    for k in range(1, kmax + 1):\n        # Red sweep: (i+j) even.\n        # Odd interior rows (i=1,3,...) with odd columns (j=1,3,...)\n        u[1:Ny+1:2, 1:Nx+1:2] = 0.25 * (\n            u[0:Ny:2, 1:Nx+1:2] + u[2:Ny+2:2, 1:Nx+1:2] +\n            u[1:Ny+1:2, 0:Nx:2] + u[1:Ny+1:2, 2:Nx+2:2]\n        )\n        # Even interior rows (i=2,4,...) with even columns (j=2,4,...)\n        if Ny >= 2 and Nx >= 2:\n            u[2:Ny+1:2, 2:Nx+1:2] = 0.25 * (\n                u[1:Ny:2, 2:Nx+1:2] + u[3:Ny+2:2, 2:Nx+1:2] +\n                u[2:Ny+1:2, 1:Nx:2] + u[2:Ny+1:2, 3:Nx+2:2]\n            )\n        # Black sweep: (i+j) odd.\n        # Odd interior rows (i=1,3,...) with even columns (j=2,4,...)\n        if Nx >= 1:\n            u[1:Ny+1:2, 2:Nx+1:2] = 0.25 * (\n                u[0:Ny:2, 2:Nx+1:2] + u[2:Ny+2:2, 2:Nx+1:2] +\n                u[1:Ny+1:2, 1:Nx:2] + u[1:Ny+1:2, 3:Nx+2:2]\n            )\n        # Even interior rows (i=2,4,...) with odd columns (j=1,3,...)\n        u[2:Ny+1:2, 1:Nx+1:2] = 0.25 * (\n            u[1:Ny:2, 1:Nx+1:2] + u[3:Ny+2:2, 1:Nx+1:2] +\n            u[2:Ny+1:2, 0:Nx:2] + u[2:Ny+1:2, 2:Nx+2:2]\n        )\n        rk = residual_norm(u)\n        res.append(rk)\n        if rk / r0 <= tau:\n            I = k\n            break\n    else:\n        I = kmax\n    if len(res) < 2:\n        rho = 0.0\n    else:\n        m = min(10, len(res) - 1)\n        tail = np.array(res[-(m + 1):], dtype=np.float64)\n        prev = tail[:-1]\n        nxt = tail[1:]\n        ratios = np.where(prev > 0.0, nxt / prev, 0.0)\n        rho = float(np.mean(ratios))\n    return I, rho\n\ndef parallel_fraction(Nx, Ny):\n    n = Nx * Ny\n    if n == 0:\n        return 0.0\n    # Largest color class size under checkerboard coloring\n    red = (n + 1) // 2\n    black = n - red\n    return float(max(red, black) / n)\n\ndef run_case(Nx, Ny, tau=1e-8, kmax=100000):\n    # Build boundary-initialized grid\n    u_lex = build_boundary(Nx, Ny)\n    u_rb = u_lex.copy()\n\n    # Run lexicographic GS\n    I_lex, rho_lex = iterate_lex(u_lex, Nx, Ny, tau, kmax)\n\n    # Run red-black GS\n    I_rb, rho_rb = iterate_red_black(u_rb, Nx, Ny, tau, kmax)\n\n    # Parallelization potential\n    P = parallel_fraction(Nx, Ny)\n\n    return I_lex, I_rb, rho_lex, rho_rb, P\n\ndef format_case_result(res):\n    I_lex, I_rb, rho_lex, rho_rb, P = res\n    # Integers for iterations, floats with exactly 6 decimals for the others\n    return f\"[{I_lex},{I_rb},{rho_lex:.6f},{rho_rb:.6f},{P:.6f}]\"\n\ndef solve():\n    # Test suite: Case A, B, C\n    test_cases = [\n        (30, 30),  # Case A\n        (1, 1),    # Case B\n        (63, 31),  # Case C\n    ]\n    results = []\n    for Nx, Ny in test_cases:\n        # Initialize anew for each case and run\n        I_lex, I_rb, rho_lex, rho_rb, P = run_case(Nx, Ny, tau=1e-8, kmax=100000)\n        results.append((I_lex, I_rb, rho_lex, rho_rb, P))\n    # Print in the required single-line format\n    inner = \",\".join(format_case_result(r) for r in results)\n    print(f\"[{inner}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2392150"}]}