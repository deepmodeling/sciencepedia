{"hands_on_practices": [{"introduction": "动手实践的核心目标之一，是将连续的微分方程转化为计算机可以求解的代数方程组。本练习是这一过程的基础，我们将学习如何将中心差分公式应用于一个具体的二阶常微分方程。通过这个实践，你将掌握将微积分问题代数化的关键技能，为数值求解更复杂的问题打下坚实的基础。", "problem": "考虑在给定区间上，由常微分方程 $y'' - 3y' + 2y = 0$ 定义的两点边值问题。为对该问题进行数值求解，我们将定义域离散化为一组节点 $x_i$，步长均匀为 $h$。令 $y_i$ 表示解 $y(x_i)$ 在节点 $x_i$ 处的数值近似值。\n\n在内部节点 $x_i$ 处，对一阶和二阶导数均使用二阶中心有限差分近似，可以形成一个将 $y_i$ 与其近邻 $y_{i-1}$ 和 $y_{i+1}$ 联系起来的线性代数方程。\n\n推导此关系，并将 $y_i$ 表示为 $y_{i-1}$、$y_{i+1}$ 和步长 $h$ 的函数。您的最终表达式必须是一个单一的分数，其系数为最简的整数或多项式。", "solution": "我们从微分方程 $y'' - 3y' + 2y = 0$ 开始，并在步长均匀为 $h$ 的内部节点 $x_{i}$ 处应用二阶中心有限差分。标准近似式为\n$$\ny''(x_{i}) \\approx \\frac{y_{i+1} - 2y_{i} + y_{i-1}}{h^{2}}, \n\\qquad\ny'(x_{i}) \\approx \\frac{y_{i+1} - y_{i-1}}{2h}.\n$$\n将这些近似式代入在 $x_{i}$ 处的方程，得到\n$$\n\\frac{y_{i+1} - 2y_{i} + y_{i-1}}{h^{2}} - 3\\frac{y_{i+1} - y_{i-1}}{2h} + 2y_{i} = 0.\n$$\n方程两边同乘以 $2h^{2}$ 以消去分母：\n$$\n2(y_{i+1} - 2y_{i} + y_{i-1}) - 3h(y_{i+1} - y_{i-1}) + 4h^{2}y_{i} = 0.\n$$\n合并同类项：\n$$\n(2 - 3h)y_{i+1} + 4(h^{2} - 1)y_{i} + (2 + 3h)y_{i-1} = 0.\n$$\n求解 $y_{i}$：\n$$\n4(h^{2} - 1)y_{i} = -(2 - 3h)y_{i+1} - (2 + 3h)y_{i-1},\n$$\n可以写成\n$$\ny_{i} = \\frac{(2 - 3h)y_{i+1} + (2 + 3h)y_{i-1}}{4(1 - h^{2})}.\n$$\n这就将 $y_i$ 表示为了一个以 $y_{i-1}$、$y_{i+1}$ 和 $h$ 为变量、系数为多项式的单一分数形式。", "answer": "$$\\boxed{\\frac{(2 - 3h)\\,y_{i+1} + (2 + 3h)\\,y_{i-1}}{4\\,(1 - h^{2})}}$$", "id": "2157255"}, {"introduction": "在掌握了如何近似导数之后，我们自然会问：这种近似的精度究竟如何？本练习引导我们进行一个有趣的思维实验，探讨在何种特殊情况下，我们的近似解能够出人意料地达到“完美”的精确度。通过分析为何中心差分法能在一个特定问题上得到精确的节点解，我们将深刻理解截断误差的本质，以及它如何依赖于待解函数本身的光滑度特性。", "problem": "考虑边值问题 (BVP) $-u''(x)=1$（定义在 $x\\in(0,1)$ 上），其边界条件为 $u(0)=0$ 和 $u(1)=0$。令网格点为 $x_i=i\\,h$，$i=0,1,\\dots,N+1$，步长 $h=1/(N+1)$。考虑在均匀网格上使用标准的二阶中心差分离散：对每个内部节点 $i=1,2,\\dots,N$，强制执行以下方程\n$$-\\frac{u_{i+1}-2u_i+u_{i-1}}{h^2}=1,$$\n并结合 $u_0=0$ 和 $u_{N+1}=0$。观察到，对于任意 $N\\ge 1$，数值解 $\\{u_i\\}_{i=0}^{N+1}$ 都精确地等于连续解 $u(x)$ 在网格节点 $\\{x_i\\}_{i=0}^{N+1}$ 上的值。\n\n哪个选项能从基本原理出发，并结合差分格式的局部截断误差，最好地解释为什么在节点上会出现这种精确性？\n\nA. 在 $x_i$ 处，$u''(x)$ 的中心差分近似的局部截断误差包含四阶导数 $u^{(4)}(x)$ 乘以 $h^2$ 的项，因此对于该边值问题的二次精确解，有 $u^{(4)}(x)\\equiv 0$，从而在每个内部节点上的截断误差都为零，这使得离散方程对于 $u(x_i)$ 精确成立。\n\nB. 该方法在这里是精确的，因为对于任意 $h$，舍入误差会因差分格式的对称性而抵消，所以计算出的解与精确的节点值相吻合。\n\nC. 由于中心差分公式的对称双边形式，它对于任何光滑函数都等于其真实的二阶导数，因此离散方程总是与微分方程逐点匹配。\n\nD. 由于源项是常数 $1$ 且边界条件是齐次的，极值原理保证了任何相容的有限差分方法都会产生零全局误差，而与网格无关。", "solution": "对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- 边值问题 (BVP) 由微分方程 $-u''(x)=1$ 定义，定义域为 $x \\in (0,1)$。\n- 边界条件为 $u(0)=0$ 和 $u(1)=0$。\n- 定义域使用均匀网格 $x_i=i\\,h$（$i=0,1,\\dots,N+1$）进行离散化，步长为 $h=1/(N+1)$。\n- BVP 在内部节点 $i=1,2,\\dots,N$ 处的有限差分近似由 $-\\frac{u_{i+1}-2u_i+u_{i-1}}{h^2}=1$ 给出。\n- 离散边界条件为 $u_0=0$ 和 $u_{N+1}=0$。\n- 提供了一个观察结果：数值解 $\\{u_i\\}_{i=0}^{N+1}$ 精确匹配连续解 $u(x)$ 在网格节点上的值，即对所有 $i$ 都有 $u_i = u(x_i)$。\n- 任务是基于数值方法的局部截断误差来解释这种精确性。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据，涉及微分方程数值分析中的一个标准课题。它是适定的，因为该边值问题有唯一解，并且由有限差分法得到的线性系统是非奇异的。问题陈述是客观且内部一致的。\n\n为了验证核心论点，我们首先求出精确解 $u(x)$。\n对 $-u''(x)=1$ 积分一次，得到 $u'(x) = -x + C_1$。\n再次积分，得到 $u(x) = -\\frac{1}{2}x^2 + C_1x + C_2$。\n应用边界条件：\n$u(0)=0 \\implies -\\frac{1}{2}(0)^2 + C_1(0) + C_2 = 0 \\implies C_2=0$。\n$u(1)=0 \\implies -\\frac{1}{2}(1)^2 + C_1(1) = 0 \\implies C_1 = \\frac{1}{2}$。\n精确解为 $u(x) = \\frac{1}{2}x - \\frac{1}{2}x^2 = \\frac{1}{2}x(1-x)$。这是一个二次多项式。\n\n有限差分格式的局部截断误差 $\\tau_i$ 是将精确解 $u(x)$ 代入离散方程后得到的残差。离散模型是 $L_h u_i = f_i$，其中 $L_h u_i = -\\frac{u_{i+1}-2u_i+u_{i-1}}{h^2}$ 且 $f_i=1$。连续模型是 $L u = f$，其中 $L u = -u''$ 且 $f(x)=1$。\n局部截断误差为 $\\tau_i = L_h u(x_i) - f(x_i)$。\n$$ \\tau_i = -\\frac{u(x_{i+1}) - 2u(x_i) + u(x_{i-1})}{h^2} - 1 $$\n我们使用 $u(x)$ 在 $x_i$ 附近的泰勒级数展开：\n$u(x_{i+1}) = u(x_i+h) = u(x_i) + h u'(x_i) + \\frac{h^2}{2!} u''(x_i) + \\frac{h^3}{3!} u'''(x_i) + \\frac{h^4}{4!} u^{(4)}(x_i) + O(h^5)$。\n$u(x_{i-1}) = u(x_i-h) = u(x_i) - h u'(x_i) + \\frac{h^2}{2!} u''(x_i) - \\frac{h^3}{3!} u'''(x_i) + \\frac{h^4}{4!} u^{(4)}(x_i) - O(h^5)$。\n将这两个展开式相加，得到：\n$u(x_{i+1}) + u(x_{i-1}) = 2u(x_i) + h^2 u''(x_i) + \\frac{h^4}{12} u^{(4)}(x_i) + O(h^6)$。\n整理上式可得二阶导数中心差分近似的标准表达式：\n$$ \\frac{u(x_{i+1}) - 2u(x_i) + u(x_{i-1})}{h^2} = u''(x_i) + \\frac{h^2}{12}u^{(4)}(x_i) + O(h^4) $$\n将此代入 $\\tau_i$ 的表达式中：\n$$ \\tau_i = -\\left( u''(x_i) + \\frac{h^2}{12}u^{(4)}(x_i) + O(h^4) \\right) - 1 $$\n根据原始微分方程，我们有对所有 $x$（包括 $x=x_i$）都成立的 $u''(x) = -1$。\n$$ \\tau_i = -(-1 + \\frac{h^2}{12}u^{(4)}(x_i) + O(h^4) ) - 1 = 1 - \\frac{h^2}{12}u^{(4)}(x_i) - O(h^4) - 1 = -\\frac{h^2}{12}u^{(4)}(x_i) - O(h^4) $$\n这证实了该方法通常是二阶精确的。然而，对于特定的解 $u(x) = \\frac{1}{2}x - \\frac{1}{2}x^2$，我们计算其导数：\n$u'(x) = \\frac{1}{2} - x$\n$u''(x) = -1$\n$u'''(x) = 0$\n$u^{(4)}(x) = 0$\n由于 $u(x)$ 的四阶导数（以及所有更高阶的导数）恒等于零，因此对于所有内部节点 $i=1,\\dots,N$，局部截断误差的表达式变为 $\\tau_i = 0$。\n全局误差 $e_i = u(x_i) - u_i$ 满足线性方程组 $A \\mathbf{e} = \\boldsymbol{\\tau}$，其中 $\\mathbf{e}$ 是节点误差向量，$\\boldsymbol{\\tau}$ 是截断误差向量。由于 $\\boldsymbol{\\tau} = \\mathbf{0}$ 并且该问题的矩阵 $A$ 是可逆的，唯一解是 $\\mathbf{e} = \\mathbf{0}$。这意味着对所有 $i$ 都有 $e_i = 0$，因此 $u_i = u(x_i)$。这样，该观察结果就在数学上得到了验证。\n\n**步骤 3：结论与行动**\n问题陈述有效。现在将推导出一个完整的解答。\n\n解释的核心在于对给定问题的局部截断误差进行分析。如上所述，对 $-u''(x)=1$ 的中心差分近似的局部截断误差 $\\tau_i$ 由 $\\tau_i = -\\frac{h^2}{12}u^{(4)}(x_i) - O(h^4)$ 给出。该 BVP 的精确解是二次多项式 $u(x) = \\frac{1}{2}x(1-x)$。对于这个函数，其四阶导数 $u^{(4)}(x)$ 对所有 $x$ 都恒等于零。因此，截断误差的整个泰勒级数都为零，这意味着对所有内部网格点 $x_i$，都有 $\\tau_i = 0$。当每个节点上的局部截断误差都为零时，连续问题的精确解就完美地满足了离散方程。由于离散系统有唯一解，因此数值解必定与在网格节点上求值的精确解完全相同。\n\n现在，我们根据这个推理来评估每个选项。\n\n**A. 在 $x_i$ 处，$u''(x)$ 的中心差分近似的局部截断误差包含四阶导数 $u^{(4)}(x)$ 乘以 $h^2$ 的项，因此对于该边值问题的二次精确解，有 $u^{(4)}(x)\\equiv 0$，从而在每个内部节点上的截断误差都为零，这使得离散方程对于 $u(x_i)$ 精确成立。**\n这个陈述与我们的推导完全一致。它正确地指出了局部截断误差的首项取决于 $u^{(4)}(x)$。它正确地说明了对于这个特定 BVP 的二次解，$u^{(4)}(x)$ 恒等于零。它正确地得出结论，这导致截断误差为零，结果是离散方程被连续解的节点值精确满足。这从基本原理出发提供了一个完整而准确的解释。\n结论：**正确**。\n\n**B. 该方法在这里是精确的，因为对于任意 $h$，舍入误差会因差分格式的对称性而抵消，所以计算出的解与精确的节点值相吻合。**\n这个选项有根本性缺陷。它混淆了离散误差（或截断误差）和舍入误差。前者是近似方法的数学属性，而后者是有限精度计算机运算的产物。问题中讨论的解在节点上的精确性是一个即使在精确算术中也成立的数学事实。虽然差分格式的对称性可能对误差抵消有影响，但这并不意味着舍入误差在一般情况下会抵消，舍入误差也不是离散化精确的原因。\n结论：**错误**。\n\n**C. 由于中心差分公式的对称双边形式，它对于任何光滑函数都等于其真实的二阶导数，因此离散方程总是与微分方程逐点匹配。**\n这个选项做出了一个错误的论断。中心差分公式 $\\frac{u(x_{i+1})-2u(x_i)+u(x_{i-1})}{h^2}$ 是对 $u''(x_i)$ 的一个 *近似*，而不是对“任何光滑函数”都成立的恒等式。如推导所示，此近似的误差是 $\\frac{h^2}{12}u^{(4)}(x_i) + O(h^4)$。对于大多数光滑函数（例如，$u(x)=\\sin(x)$），这个误差是非零的。该公式仅对次数小于四的多项式是精确的。因此，离散方程与连续方程总是匹配的结论是错误的。\n结论：**错误**。\n\n**D. 由于源项是常数 $1$ 且边界条件是齐次的，极值原理保证了任何相容的有限差分方法都会产生零全局误差，而与网格无关。**\n这个选项滥用了极值原理并得出了一个错误的结论。离散极值原理是用于证明稳定性和获得误差界（例如，证明全局误差受局部截断误差最大值的限制）的工具。它并*不*保证全局误差为零。“任何相容的有限差分方法”都将是精确的这一说法也是错误的。例如，另一个虽然也相容但不同的格式可能不是精确的。源项和边界条件的特定属性并不足够；关键的事实是它们导致了一个多项式解，而对于该多项式的次数，所选的有限差分格式恰好是精确的。\n结论：**错误**。", "answer": "$$\\boxed{A}$$", "id": "2391599"}, {"introduction": "教科书中的均匀网格在现实世界的复杂问题中往往力不从心，例如，我们需要在边界层等梯度剧烈变化的区域加密网格。本练习将挑战你推导并实现一个在非均匀网格上依然保持二阶精度的二阶导数近似格式。这是从理想到实践的关键一步，将帮助你掌握为实际工程与科学应用开发更强大、更灵活数值求解器的核心技术。", "problem": "考虑一维热传导偏微分方程 (PDE) $u_t = \\alpha u_{xx}$，其定义在空间区间 $x \\in [0,1]$ 上，并带有齐次狄利克雷边界条件 $u(0,t)=0$ 和 $u(1,t)=0$（对所有 $t \\ge 0$ 成立）。设空间网格为非均匀网格，节点为 $x_0=0 < x_1 < \\cdots < x_{N} < x_{N+1}=1$，其中 $N \\ge 1$ 是内部节点的数量。用 $u_i(t) \\approx u(x_i,t)$ 表示节点值。您的任务是：\n- 从第一性原理出发，推导在每个内部节点 $x_i$ 处二阶导数 $u_{xx}$ 的二阶精度有限差分近似，推导过程仅使用相邻节点值 $u_{i-1}(t)$、$u_i(t)$ 和 $u_{i+1}(t)$，其中 $i \\in \\{1,2,\\dots,N\\}$。\n- 实现所得到的离散算子，该算子将节点值 $\\{u_j\\}_{j=0}^{N+1}$ 映射到内部节点上 $\\{u_{xx}(x_i)\\}_{i=1}^{N}$ 的近似值。\n- 为定量验证离散化的二阶空间精度，对下述每个指定的测试用例，将算子应用于光滑函数 $u(x) = \\sin(k \\pi x)$，并与内部节点上的精确二阶导数 $u''(x) = - (k \\pi)^2 \\sin(k \\pi x)$ 进行比较。计算均方根 (RMS) 误差，其定义为\n$$\nE_{\\mathrm{RMS}} \\;=\\; \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left( D^{(2)}u(x_i) \\;-\\; u''(x_i) \\right)^2 } \\, ,\n$$\n其中 $D^{(2)}u(x_i)$ 表示您对 $u_{xx}(x_i)$ 的离散近似。\n\n此任务不要求时间积分；仅需专注于非均匀网格上 $u_{xx}$ 的精确空间离散化。\n\n使用以下网格生成规则。令 $\\xi_i = \\dfrac{i}{N+1}$（对于 $i \\in \\{0,1,\\dots,N+1\\}$），并通过映射 $x(\\xi)$ 定义物理节点 $\\{x_i\\}$：\n- 均匀网格：$x_i = \\xi_i$。\n- 余弦聚集网格：$x_i = \\dfrac{1 - \\cos(\\pi \\xi_i)}{2}$。\n- 幂律网格：$x_i = \\xi_i^{p}$，其中幂 $p > 0$ 为给定值。\n\n使用下面的测试套件。对每个用例，在节点上计算 $u(x) = \\sin(k \\pi x)$ 的值，应用您的有限差分算子计算内部节点上的 $D^{(2)}u(x_i)$，并以浮点数形式报告 RMS 误差 $E_{\\mathrm{RMS}}$：\n- 用例 1：$N = 80$，余弦聚集网格，$k = 1$。\n- 用例 2：$N = 80$，幂律网格，$p = 3$，$k = 2$。\n- 用例 3：$N = 10$，均匀网格，$k = 3$。\n- 用例 4：$N = 2$，幂律网格，$p = 2$，$k = 1$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个 RMS 误差结果，按用例 1 到 4 的顺序排列，以逗号分隔，并置于方括号内。每个值都应四舍五入到 $10$ 位小数，并采用科学记数法（例如，$[1.2345678901e-04,2.3456789012e-05,3.4567890123e-06,4.5678901234e-07]$）。", "solution": "提交分析的问题陈述表述严谨、内容自洽且科学合理。它提出了一个计算工程中的标准任务：在非均匀网格上离散化一个微分算子，并定量验证其精度。所有提供的信息都是一致的，足以得出一个唯一的解。此问题有效。\n\n核心任务是推导在一维非均匀网格的内部节点 $x_i$ 处二阶导数 $u_{xx}$ 的有限差分近似。计算模板仅限于该节点本身及其直接相邻的节点 $x_{i-1}$ 和 $x_{i+1}$。该近似必须达到二阶精度。设节点间距为非均匀的，记为 $h_i = x_i - x_{i-1}$ 和 $h_{i+1} = x_{i+1} - x_i$。\n\n推导从第一性原理出发，使用泰勒级数展开。我们将函数 $u(x)$ 在点 $x_i$ 附近展开。因此，相邻点 $u(x_{i-1})$ 和 $u(x_{i+1})$ 的值可以表示为：\n$$\nu(x_{i-1}) = u(x_i - h_i) = u(x_i) - h_i u'(x_i) + \\frac{h_i^2}{2} u''(x_i) - \\frac{h_i^3}{6} u'''(x_i) + \\frac{h_i^4}{24} u^{(4)}(x_i) - \\dots\n$$\n$$\nu(x_{i+1}) = u(x_i + h_{i+1}) = u(x_i) + h_{i+1} u'(x_i) + \\frac{h_{i+1}^2}{2} u''(x_i) + \\frac{h_{i+1}^3}{6} u'''(x_i) + \\frac{h_{i+1}^4}{24} u^{(4)}(x_i) + \\dots\n$$\n为简洁起见，我们采用记法 $u_j = u(x_j)$，$u'_i = u'(x_i)$ 等。\n\n我们寻求三个节点值的线性组合 $D^{(2)}u_i = a u_{i-1} + b u_i + c u_{i+1}$ 来近似 $u''(x_i)$。将泰勒级数展开式代入此形式可得：\n$$\nD^{(2)}u_i = a\\left(u_i - h_i u'_i + \\frac{h_i^2}{2}u''_i - \\dots\\right) + b u_i + c\\left(u_i + h_{i+1}u'_i + \\frac{h_{i+1}^2}{2}u''_i + \\dots\\right)\n$$\n按 $u$ 在 $x_i$ 处的导数阶数整理各项：\n$$\nD^{(2)}u_i = (a+b+c)u_i + (-ah_i + ch_{i+1})u'_i + \\left(a\\frac{h_i^2}{2} + c\\frac{h_{i+1}^2}{2}\\right)u''_i + \\left(-a\\frac{h_i^3}{6} + c\\frac{h_{i+1}^3}{6}\\right)u'''_i + \\dots\n$$\n为确保 $D^{(2)}u_i$ 是 $u''_i$ 的一个相容近似，我们必须使其导数的系数与 $u''_i$ 的系数相匹配（$u_i$ 和 $u'_i$ 的系数为 $0$，$u''_i$ 的系数为 $1$）。由此得到一个关于三个未知系数 $a, b, c$ 的三元线性方程组：\n1. $u_i$ 的系数：$a+b+c = 0$\n2. $u'_i$ 的系数：$-ah_i + ch_{i+1} = 0$\n3. $u''_i$ 的系数：$a\\frac{h_i^2}{2} + c\\frac{h_{i+1}^2}{2} = 1$\n\n由方程 (2) 可得 $c = a \\frac{h_i}{h_{i+1}}$。将其代入方程 (3)：\n$$\na\\frac{h_i^2}{2} + \\left(a \\frac{h_i}{h_{i+1}}\\right)\\frac{h_{i+1}^2}{2} = 1 \\implies a\\left(\\frac{h_i^2}{2} + \\frac{h_i h_{i+1}}{2}\\right) = 1\n$$\n求解 $a$ 可得：\n$$\na = \\frac{2}{h_i^2 + h_i h_{i+1}} = \\frac{2}{h_i(h_i + h_{i+1})}\n$$\n系数 $c$ 则为：\n$$\nc = \\frac{2}{h_i(h_i + h_{i+1})} \\cdot \\frac{h_i}{h_{i+1}} = \\frac{2}{h_{i+1}(h_i + h_{i+1})}\n$$\n最后，由方程 (1) 可求得 $b$：\n$$\nb = -a - c = -\\frac{2}{h_i(h_i + h_{i+1})} - \\frac{2}{h_{i+1}(h_i + h_{i+1})} = -\\frac{2(h_{i+1} + h_i)}{h_i h_{i+1}(h_i + h_{i+1})} = -\\frac{2}{h_i h_{i+1}}\n$$\n由此得到的有限差分算子为：\n$$\nD^{(2)}u_i = \\frac{2}{h_i(h_i+h_{i+1})} u_{i-1} - \\frac{2}{h_i h_{i+1}} u_i + \\frac{2}{h_{i+1}(h_i+h_{i+1})} u_{i+1}\n$$\n这可以改写为一种更直观的形式，它表示为一阶导数近似的差分：\n$$\nD^{(2)}u_i = \\frac{2}{h_i+h_{i+1}} \\left( \\frac{u_{i+1}-u_i}{h_{i+1}} - \\frac{u_i-u_{i-1}}{h_i} \\right)\n$$\n截断误差 $\\tau_i$ 可通过考察泰勒级数中的下一项，即 $u'''_i$ 的系数，来求得：\n$$\n\\tau_i = \\left(-a\\frac{h_i^3}{6} + c\\frac{h_{i+1}^3}{6}\\right)u'''_i + O(h^2) = \\left(-\\frac{2}{h_i(h_i+h_{i+1})}\\frac{h_i^3}{6} + \\frac{2}{h_{i+1}(h_i+h_{i+1})}\\frac{h_{i+1}^3}{6}\\right)u'''_i + \\dots\n$$\n$$\n\\tau_i = \\frac{1}{3(h_i+h_{i+1})} (-h_i^2 + h_{i+1}^2) u'''_i + \\dots = \\frac{h_{i+1}-h_i}{3}u'''_i + O(h^2)\n$$\n乍一看，首项误差项为 $O(h_{i+1}-h_i)$，这表明该格式在一般的非均匀网格上仅为一阶精度。然而，问题指定网格是通过一个从均匀计算网格 $\\xi_i = i/(N+1)$ 到物理网格的光滑映射 $x(\\xi)$ 生成的。令 $\\Delta\\xi = 1/(N+1)$ 为 $\\xi$ 中的均匀间距。物理网格间距为 $h_i = x(\\xi_i) - x(\\xi_{i-1}) \\approx x'(\\xi_{i-1/2})\\Delta\\xi$。那么相邻间距的差为：\n$$\nh_{i+1} - h_i \\approx (x'(\\xi_{i+1/2}) - x'(\\xi_{i-1/2}))\\Delta\\xi \\approx x''(\\xi_i)(\\Delta\\xi)^2\n$$\n由于 $\\Delta\\xi$ 是特征网格尺寸，$h_{i+1}-h_i$ 的阶数为 $(\\Delta\\xi)^2$。因此，首项误差项 $\\frac{h_{i+1}-h_i}{3}u'''_i$ 在 $\\Delta\\xi$ 上是二阶的，所以该格式对于由足够光滑的变换生成的网格确实是二阶精度的，正如要求所述。\n\n为了进行数值验证，我们计算均方根 (RMS) 误差。对于每个测试用例，我们首先根据指定规则生成物理网格 $\\{x_i\\}$。然后，在所有节点上计算函数 $u(x_i) = \\sin(k \\pi x_i)$ 的值。在 $N$ 个内部节点上计算精确的二阶导数 $u''(x_i) = -(k\\pi)^2 \\sin(k \\pi x_i)$。将离散算子 $D^{(2)}$ 应用于节点值 $\\{u_i\\}$ 以获得内部节点上二阶导数的近似值。然后 RMS 误差计算如下：\n$$\nE_{\\mathrm{RMS}} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left( D^{(2)}u(x_i) - u''(x_i) \\right)^2 }\n$$\n成功执行此过程并处理指定的测试用例，将验证所推导的公式及其精度分析的正确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of deriving and testing a finite difference scheme\n    for the second derivative on non-uniform grids.\n    \"\"\"\n\n    test_cases = [\n        {'N': 80, 'grid_type': 'cosine', 'k': 1, 'p': None},\n        {'N': 80, 'grid_type': 'power', 'k': 2, 'p': 3.0},\n        {'N': 10, 'grid_type': 'uniform', 'k': 3, 'p': None},\n        {'N': 2, 'grid_type': 'power', 'k': 1, 'p': 2.0},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        grid_type = case['grid_type']\n        k = case['k']\n        p = case['p']\n\n        # Step 1: Generate the grid\n        num_points = N + 2\n        xi = np.linspace(0.0, 1.0, num_points)\n        \n        if grid_type == 'uniform':\n            x = xi\n        elif grid_type == 'cosine':\n            x = (1.0 - np.cos(np.pi * xi)) / 2.0\n        elif grid_type == 'power':\n            x = xi**p\n        else:\n            raise ValueError(\"Invalid grid type specified.\")\n\n        # Step 2: Evaluate the function and its exact second derivative\n        u_vals = np.sin(k * np.pi * x)\n        \n        # Exact second derivative at interior nodes\n        x_interior = x[1:-1]\n        u_xx_exact = -(k * np.pi)**2 * np.sin(k * np.pi * x_interior)\n\n        # Step 3: Apply the finite difference operator at interior nodes\n        u_xx_approx = np.zeros(N)\n        for i in range(1, N + 1):\n            h_left = x[i] - x[i-1]\n            h_right = x[i+1] - x[i]\n            \n            u_i_minus_1 = u_vals[i-1]\n            u_i = u_vals[i]\n            u_i_plus_1 = u_vals[i+1]\n            \n            # Derived finite difference formula for non-uniform grid\n            # D^2 u_i = 2/(h_i+h_{i+1}) * ( (u_{i+1}-u_i)/h_{i+1} - (u_i-u_{i-1})/h_i )\n            term1 = (u_i_plus_1 - u_i) / h_right\n            term2 = (u_i - u_i_minus_1) / h_left\n            \n            approx = (2.0 / (h_left + h_right)) * (term1 - term2)\n            u_xx_approx[i-1] = approx\n\n        # Step 4: Compute the RMS error\n        error = u_xx_approx - u_xx_exact\n        rms_error = np.sqrt(np.mean(error**2))\n        results.append(rms_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10e}' for r in results)}]\")\n\nsolve()\n```", "id": "2391620"}]}