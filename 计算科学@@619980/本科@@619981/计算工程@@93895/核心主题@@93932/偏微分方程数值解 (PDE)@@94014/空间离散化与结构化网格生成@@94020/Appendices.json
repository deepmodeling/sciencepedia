{"hands_on_practices": [{"introduction": "理论知识只有通过实践才能真正内化。本节的第一个动手实践将引导你计算结构化网格的基石——度量张量和雅可比行列式。通过为几种不同的坐标变换编写程序，你将直接应用微分几何的定义，量化计算空间到物理空间的映射如何拉伸、剪切和缩放。这项练习是后续在曲线坐标系下分析和实现数值格式的基础。[@problem_id:2436332]", "problem": "给定从计算坐标系 $(\\xi,\\eta)$ 到物理坐标系 $(x,y)$ 的光滑、二维、解析变换。令 $\\boldsymbol{r}(\\xi,\\eta) = (x(\\xi,\\eta), y(\\xi,\\eta))$。协变基向量定义为 $\\boldsymbol{r}_{\\xi} = \\dfrac{\\partial \\boldsymbol{r}}{\\partial \\xi}$ 和 $\\boldsymbol{r}_{\\eta} = \\dfrac{\\partial \\boldsymbol{r}}{\\partial \\eta}$。协变度量张量分量由 $g_{ij} = \\boldsymbol{r}_{i} \\cdot \\boldsymbol{r}_{j}$ 定义，其中 $i,j \\in \\{\\xi,\\eta\\}$，具体为 $g_{\\xi\\xi}$、$g_{\\xi\\eta}$ 和 $g_{\\eta\\eta}$。雅可比行列式定义为 $J = \\det\\left(\\dfrac{\\partial(x,y)}{\\partial(\\xi,\\eta)}\\right)$。所有量均为无量纲。当变换中出现角度时，必须以弧度为单位处理。\n\n编写一个程序，针对下面列出的每个变换和求值点，计算列表 $[g_{\\xi\\xi}, g_{\\xi\\eta}, g_{\\eta\\eta}, J]$，并将每个条目四舍五入到 $8$ 位小数。\n\n所需的测试套件如下，其中每个参数和求值坐标都已明确给出：\n\n- 测试用例 $1$ (仿射映射)：$x(\\xi,\\eta) = a\\,\\xi + b\\,\\eta + c$， $y(\\xi,\\eta) = d\\,\\xi + e\\,\\eta + f$，参数为 $(a,b,c,d,e,f) = (\\,2,\\,1,\\,0.5,\\,-1,\\,3,\\,1\\,)$，求值点为 $(\\xi,\\eta) = (\\,0.3,\\,-0.7\\,)$。\n- 测试用例 $2$ (多项式偏斜)：$x(\\xi,\\eta) = \\xi + \\alpha\\,\\xi\\,\\eta$， $y(\\xi,\\eta) = \\eta + \\beta\\,\\xi^{2}$，参数为 $(\\alpha,\\beta) = (\\,0.4,\\,-0.2\\,)$，求值点为 $(\\xi,\\eta) = (\\,0.5,\\,-1.0\\,)$。\n- 测试用例 $3$ (极坐标类型映射)：$x(\\xi,\\eta) = r\\cos\\theta$， $y(\\xi,\\eta) = r\\sin\\theta$，其中 $(\\xi,\\eta) = (r,\\theta)$，求值点为 $(r,\\theta) = (\\,2.0,\\,\\pi/6\\,)$。角度以弧度为单位。\n- 测试用例 $4$ (三角扭曲)：$x(\\xi,\\eta) = \\xi + A\\sin(\\pi \\xi)\\sin(\\pi \\eta)$， $y(\\xi,\\eta) = \\eta + B\\sin(\\pi \\xi)\\sin(\\pi \\eta)$，参数为 $(A,B) = (\\,0.1,\\,-0.15\\,)$，求值点为 $(\\xi,\\eta) = (\\,0.25,\\,0.75\\,)$。\n\n你的程序必须输出一行，该行包含一个列表的列表（嵌套列表），其中每个内部列表按上述顺序对应一个测试用例，并且每个内部列表的形式为 $[g_{\\xi\\xi}, g_{\\xi\\eta}, g_{\\eta\\eta}, J]$，其中每个浮点数都四舍五入到 $8$ 位小数。例如，你的输出应具有形式\n$[[v_{11},v_{12},v_{13},v_{14}],[v_{21},v_{22},v_{23},v_{24}],[v_{31},v_{32},v_{33},v_{34}],[v_{41},v_{42},v_{43},v_{44}]]$\n其中每个 $v_{ij}$ 是一个四舍五入到 $8$ 位小数的浮点数。不应打印任何额外文本。", "solution": "所述问题是有效的。这是一个应用微分几何学中的适定问题，是计算工程领域的基础，特别用于结构化网格的分析。所有的定义、变换和参数均已提供，它们在科学上是合理的，并且没有歧义或矛盾。每个测试用例都存在唯一解。求解过程将基于所提供的定义进行直接计算。\n\n从计算坐标 $(\\xi, \\eta)$ 到物理坐标 $(x, y)$ 的变换由 $\\boldsymbol{r}(\\xi, \\eta) = (x(\\xi, \\eta), y(\\xi, \\eta))$ 给出。协变基向量为 $\\boldsymbol{r}_{\\xi} = \\frac{\\partial \\boldsymbol{r}}{\\partial \\xi} = (\\frac{\\partial x}{\\partial \\xi}, \\frac{\\partial y}{\\partial \\xi})$ 和 $\\boldsymbol{r}_{\\eta} = \\frac{\\partial \\boldsymbol{r}}{\\partial \\eta} = (\\frac{\\partial x}{\\partial \\eta}, \\frac{\\partial y}{\\partial \\eta})$。\n\n由这些向量，可以计算出协变度量张量 $g_{ij}$ 的分量和雅可比行列式 $J$。\n度量张量分量由基向量的点积给出：\n$$g_{\\xi\\xi} = \\boldsymbol{r}_{\\xi} \\cdot \\boldsymbol{r}_{\\xi} = \\left(\\frac{\\partial x}{\\partial \\xi}\\right)^2 + \\left(\\frac{\\partial y}{\\partial \\xi}\\right)^2$$\n$$g_{\\eta\\eta} = \\boldsymbol{r}_{\\eta} \\cdot \\boldsymbol{r}_{\\eta} = \\left(\\frac{\\partial x}{\\partial \\eta}\\right)^2 + \\left(\\frac{\\partial y}{\\partial \\eta}\\right)^2$$\n$$g_{\\xi\\eta} = \\boldsymbol{r}_{\\xi} \\cdot \\boldsymbol{r}_{\\eta} = \\frac{\\partial x}{\\partial \\xi}\\frac{\\partial x}{\\partial \\eta} + \\frac{\\partial y}{\\partial \\xi}\\frac{\\partial y}{\\partial \\eta}$$\n雅可比行列式，表示局部面积元的比率，由以下公式给出：\n$$J = \\det\\left(\\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix}\\right) = \\frac{\\partial x}{\\partial \\xi}\\frac{\\partial y}{\\partial \\eta} - \\frac{\\partial x}{\\partial \\eta}\\frac{\\partial y}{\\partial \\xi}$$\n我们现在将为每个指定的测试用例计算这四个量。\n\n测试用例 $1$：仿射映射\n变换为 $x(\\xi,\\eta) = a\\xi + b\\eta + c$ 和 $y(\\xi,\\eta) = d\\xi + e\\eta + f$，参数为 $(a,b,c,d,e,f) = (2, 1, 0.5, -1, 3, 1)$。偏导数为常数：\n$\\frac{\\partial x}{\\partial \\xi} = a = 2$\n$\\frac{\\partial x}{\\partial \\eta} = b = 1$\n$\\frac{\\partial y}{\\partial \\xi} = d = -1$\n$\\frac{\\partial y}{\\partial \\eta} = e = 3$\n这些值与求值点 $(\\xi,\\eta) = (0.3, -0.7)$ 无关。\n$g_{\\xi\\xi} = (2)^2 + (-1)^2 = 4 + 1 = 5$\n$g_{\\eta\\eta} = (1)^2 + (3)^2 = 1 + 9 = 10$\n$g_{\\xi\\eta} = (2)(1) + (-1)(3) = 2 - 3 = -1$\n$J = (2)(3) - (1)(-1) = 6 + 1 = 7$\n所需的列表是 $[5.0, -1.0, 10.0, 7.0]$。\n\n测试用例 $2$：多项式偏斜\n变换为 $x(\\xi,\\eta) = \\xi + \\alpha\\xi\\eta$ 和 $y(\\xi,\\eta) = \\eta + \\beta\\xi^2$，参数为 $(\\alpha, \\beta) = (0.4, -0.2)$。\n偏导数为：\n$\\frac{\\partial x}{\\partial \\xi} = 1 + \\alpha\\eta$\n$\\frac{\\partial x}{\\partial \\eta} = \\alpha\\xi$\n$\\frac{\\partial y}{\\partial \\xi} = 2\\beta\\xi$\n$\\frac{\\partial y}{\\partial \\eta} = 1$\n在 $(\\xi, \\eta) = (0.5, -1.0)$ 点求值：\n$\\frac{\\partial x}{\\partial \\xi} = 1 + (0.4)(-1.0) = 1 - 0.4 = 0.6$\n$\\frac{\\partial x}{\\partial \\eta} = (0.4)(0.5) = 0.2$\n$\\frac{\\partial y}{\\partial \\xi} = 2(-0.2)(0.5) = -0.2$\n$\\frac{\\partial y}{\\partial \\eta} = 1$\n$g_{\\xi\\xi} = (0.6)^2 + (-0.2)^2 = 0.36 + 0.04 = 0.4$\n$g_{\\eta\\eta} = (0.2)^2 + (1)^2 = 0.04 + 1 = 1.04$\n$g_{\\xi\\eta} = (0.6)(0.2) + (-0.2)(1) = 0.12 - 0.2 = -0.08$\n$J = (0.6)(1) - (0.2)(-0.2) = 0.6 + 0.04 = 0.64$\n所需的列表是 $[0.4, -0.08, 1.04, 0.64]$。\n\n测试用例 $3$：极坐标类型映射\n变换为 $x(r,\\theta) = r\\cos\\theta$ 和 $y(r,\\theta) = r\\sin\\theta$，计算坐标可视为 $(\\xi, \\eta) = (r, \\theta)$。\n关于 $\\xi=r$ 和 $\\eta=\\theta$ 的偏导数为：\n$\\frac{\\partial x}{\\partial \\xi} = \\cos\\eta$\n$\\frac{\\partial x}{\\partial \\eta} = -\\xi\\sin\\eta$\n$\\frac{\\partial y}{\\partial \\xi} = \\sin\\eta$\n$\\frac{\\partial y}{\\partial \\eta} = \\xi\\cos\\eta$\n在 $(\\xi, \\eta) = (2.0, \\pi/6)$ 点求值：\n$\\frac{\\partial x}{\\partial \\xi} = \\cos(\\pi/6) = \\frac{\\sqrt{3}}{2}$\n$\\frac{\\partial x}{\\partial \\eta} = -2\\sin(\\pi/6) = -2(\\frac{1}{2}) = -1$\n$\\frac{\\partial y}{\\partial \\xi} = \\sin(\\pi/6) = \\frac{1}{2}$\n$\\frac{\\partial y}{\\partial \\eta} = 2\\cos(\\pi/6) = 2(\\frac{\\sqrt{3}}{2}) = \\sqrt{3}$\n$g_{\\xi\\xi} = (\\frac{\\sqrt{3}}{2})^2 + (\\frac{1}{2})^2 = \\frac{3}{4} + \\frac{1}{4} = 1$\n$g_{\\eta\\eta} = (-1)^2 + (\\sqrt{3})^2 = 1 + 3 = 4$\n$g_{\\xi\\eta} = (\\frac{\\sqrt{3}}{2})(-1) + (\\frac{1}{2})(\\sqrt{3}) = 0$\n$J = (\\frac{\\sqrt{3}}{2})(\\sqrt{3}) - (-1)(\\frac{1}{2}) = \\frac{3}{2} + \\frac{1}{2} = 2$\n所需的列表是 $[1.0, 0.0, 4.0, 2.0]$。\n\n测试用例 $4$：三角扭曲\n变换为 $x(\\xi,\\eta) = \\xi + A\\sin(\\pi\\xi)\\sin(\\pi\\eta)$ 和 $y(\\xi,\\eta) = \\eta + B\\sin(\\pi\\xi)\\sin(\\pi\\eta)$，参数为 $(A, B) = (0.1, -0.15)$。\n偏导数为：\n$\\frac{\\partial x}{\\partial \\xi} = 1 + A\\pi\\cos(\\pi\\xi)\\sin(\\pi\\eta)$\n$\\frac{\\partial x}{\\partial \\eta} = A\\pi\\sin(\\pi\\xi)\\cos(\\pi\\eta)$\n$\\frac{\\partial y}{\\partial \\xi} = B\\pi\\cos(\\pi\\xi)\\sin(\\pi\\eta)$\n$\\frac{\\partial y}{\\partial \\eta} = 1 + B\\pi\\sin(\\pi\\xi)\\cos(\\pi\\eta)$\n在 $(\\xi, \\eta) = (0.25, 0.75)$ 点求值：\n我们有 $\\pi\\xi = \\pi/4$ 和 $\\pi\\eta = 3\\pi/4$。\n$\\cos(\\pi/4) = \\frac{\\sqrt{2}}{2}$，$\\sin(\\pi/4) = \\frac{\\sqrt{2}}{2}$，$\\cos(3\\pi/4) = -\\frac{\\sqrt{2}}{2}$，$\\sin(3\\pi/4) = \\frac{\\sqrt{2}}{2}$。\n因此，$\\cos(\\pi\\xi)\\sin(\\pi\\eta) = (\\frac{\\sqrt{2}}{2})(\\frac{\\sqrt{2}}{2}) = 0.5$ 和 $\\sin(\\pi\\xi)\\cos(\\pi\\eta) = (\\frac{\\sqrt{2}}{2})(-\\frac{\\sqrt{2}}{2}) = -0.5$。\n代入这些值：\n$\\frac{\\partial x}{\\partial \\xi} = 1 + (0.1)\\pi(0.5) = 1 + 0.05\\pi$\n$\\frac{\\partial x}{\\partial \\eta} = (0.1)\\pi(-0.5) = -0.05\\pi$\n$\\frac{\\partial y}{\\partial \\xi} = (-0.15)\\pi(0.5) = -0.075\\pi$\n$\\frac{\\partial y}{\\partial \\eta} = 1 + (-0.15)\\pi(-0.5) = 1 + 0.075\\pi$\n$g_{\\xi\\xi} = (1+0.05\\pi)^2 + (-0.075\\pi)^2 = 1 + 0.1\\pi + 0.0025\\pi^2 + 0.005625\\pi^2 = 1 + 0.1\\pi + 0.008125\\pi^2 \\approx 1.39435068$\n$g_{\\eta\\eta} = (-0.05\\pi)^2 + (1+0.075\\pi)^2 = 0.0025\\pi^2 + 1 + 0.15\\pi + 0.005625\\pi^2 = 1 + 0.15\\pi + 0.008125\\pi^2 \\approx 1.55142551$\n$g_{\\xi\\eta} = (1+0.05\\pi)(-0.05\\pi) + (-0.075\\pi)(1+0.075\\pi) = -0.05\\pi - 0.0025\\pi^2 - 0.075\\pi - 0.005625\\pi^2 = -0.125\\pi - 0.008125\\pi^2 \\approx -0.47289237$\n$J = (1+0.05\\pi)(1+0.075\\pi) - (-0.05\\pi)(-0.075\\pi) = 1 + 0.125\\pi + 0.00375\\pi^2 - 0.00375\\pi^2 = 1 + 0.125\\pi \\approx 1.39269908$\n所需的列表，四舍五入到 $8$ 位小数，是 $[1.39435068, -0.47289237, 1.55142551, 1.39269908]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the metric tensor components and Jacobian for four\n    different coordinate transformations.\n    \"\"\"\n\n    def case1():\n        \"\"\"Affine mapping.\"\"\"\n        a, b, c, d, e, f = 2, 1, 0.5, -1, 3, 1\n        # xi, eta = 0.3, -0.7 # Not needed as derivatives are constant\n        \n        # Partial derivatives\n        x_xi = a\n        x_eta = b\n        y_xi = d\n        y_eta = e\n        \n        # Metric components\n        g_xixi = x_xi**2 + y_xi**2\n        g_etaeta = x_eta**2 + y_eta**2\n        g_xieta = x_xi * x_eta + y_xi * y_eta\n        \n        # Jacobian\n        J = x_xi * y_eta - x_eta * y_xi\n        \n        return [g_xixi, g_xieta, g_etaeta, J]\n\n    def case2():\n        \"\"\"Polynomial skew.\"\"\"\n        alpha, beta = 0.4, -0.2\n        xi, eta = 0.5, -1.0\n        \n        # Partial derivatives\n        x_xi = 1 + alpha * eta\n        x_eta = alpha * xi\n        y_xi = 2 * beta * xi\n        y_eta = 1\n        \n        # Metric components\n        g_xixi = x_xi**2 + y_xi**2\n        g_etaeta = x_eta**2 + y_eta**2\n        g_xieta = x_xi * x_eta + y_xi * y_eta\n        \n        # Jacobian\n        J = x_xi * y_eta - x_eta * y_xi\n        \n        return [g_xixi, g_xieta, g_etaeta, J]\n\n    def case3():\n        \"\"\"Polar-type mapping.\"\"\"\n        xi, eta = 2.0, np.pi / 6.0 # (r, theta)\n        \n        # Partial derivatives\n        x_xi = np.cos(eta)       # dx/dr\n        x_eta = -xi * np.sin(eta) # dx/dtheta\n        y_xi = np.sin(eta)       # dy/dr\n        y_eta = xi * np.cos(eta)  # dy/dtheta\n        \n        # Metric components\n        g_xixi = x_xi**2 + y_xi**2\n        g_etaeta = x_eta**2 + y_eta**2\n        g_xieta = x_xi * x_eta + y_xi * y_eta\n        \n        # Jacobian\n        J = x_xi * y_eta - x_eta * y_xi\n        \n        return [g_xixi, g_xieta, g_etaeta, J]\n\n    def case4():\n        \"\"\"Trigonometric warp.\"\"\"\n        A, B = 0.1, -0.15\n        xi, eta = 0.25, 0.75\n        \n        pi_xi = np.pi * xi\n        pi_eta = np.pi * eta\n        \n        # Common trigonometric terms\n        cos_xi_sin_eta = np.cos(pi_xi) * np.sin(pi_eta)\n        sin_xi_cos_eta = np.sin(pi_xi) * np.cos(pi_eta)\n        \n        # Partial derivatives\n        x_xi = 1 + A * np.pi * cos_xi_sin_eta\n        x_eta = A * np.pi * sin_xi_cos_eta\n        y_xi = B * np.pi * cos_xi_sin_eta\n        y_eta = 1 + B * np.pi * sin_xi_cos_eta\n        \n        # Metric components\n        g_xixi = x_xi**2 + y_xi**2\n        g_etaeta = x_eta**2 + y_eta**2\n        g_xieta = x_xi * x_eta + y_xi * y_eta\n        \n        # Jacobian\n        J = x_xi * y_eta - x_eta * y_xi\n        \n        return [g_xixi, g_xieta, g_etaeta, J]\n\n    results = []\n    case_functions = [case1, case2, case3, case4]\n\n    for func in case_functions:\n        raw_result = func()\n        rounded_result = [round(val, 8) for val in raw_result]\n        results.append(rounded_result)\n    \n    # Generate the output string exactly as specified, without spaces\n    print(repr(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2436332"}, {"introduction": "在掌握了如何描述网格的几何特性之后，我们将在一个实际的偏微分方程求解问题中应用这些知识。这个练习聚焦于一个常见且关键的挑战：坐标奇点，例如极坐标系的原点。你将通过编程对比一种朴素方法和一种经过数学修正的方法，来解决一个轴对称泊松方程，并亲眼见证不正确的奇点处理如何污染数值解的精度。这个实践将深化你对坐标变换如何影响离散算子准确性的理解。[@problem_id:2436320]", "problem": "考虑在闭合单位圆盘上，极坐标系下的轴对称泊松方程。设 $u(r)$ 表示一个仅依赖于半径 $r \\in [0,1]$ 的标量场。其控制方程为\n$$\n\\frac{\\partial^2 u}{\\partial r^2} + \\frac{1}{r}\\frac{\\partial u}{\\partial r} = f(r),\n$$\n边界条件为 $u(1)=0$，以及正则性条件，即当 $r \\to 0$ 时 $u(r)$ 保持有限。对于此问题，使用精确光滑解 $u_{\\text{exact}}(r) = 1 - r^2$，这意味着对于所有 $r \\in [0,1]$，源项 $f(r) = -4$。\n\n您必须研究 $r=0$ 处极坐标映射的奇异性如何影响结构化网格上的数值近似，并展示一种缓解策略。请按照以下步骤进行，仅使用此处提供的数学定义：\n\n- 构建一个具有 $N$ 个区间和间距 $h = 1/N$ 的均匀结构化径向网格，节点位置为 $r_i = i h$，其中 $i=0,1,\\dots,N$。\n- 在此网格上计算 $u(r)$ 的两个独立的数值近似解：\n  1. 一个基准近似解，它将 $r=0$ 视为普通网格点，但在原点施加不一致的边界值 $u(0)=0$，并在外边界施加 $u(1)=0$。该基准解在 $r=0$ 处与真实解故意不一致，旨在量化奇异映射如何污染离散解。\n  2. 一个缓解近似解，它使用任何从第一性原理推导出的、数学上合理的策略，来正确消除 $r=0$ 处奇异映射的影响，同时强制执行 $u(1)=0$。任何与底层连续问题一致且能产生适定离散系统的选择都是可接受的。\n\n对于每个近似解，通过在圆盘上计算相对面积加权的离散$L^2$范数来量化误差：\n$$\nE = \\frac{\\left(\\int_0^1 2\\pi r \\left(u_{\\text{num}}(r) - u_{\\text{exact}}(r)\\right)^2 \\, dr\\right)^{1/2}}{\\left(\\int_0^1 2\\pi r \\left(u_{\\text{exact}}(r)\\right)^2 \\, dr\\right)^{1/2}}.\n$$\n在您的程序中，使用关于 $r$ 的复合梯形法则在网格 $\\{r_i\\}_{i=0}^N$ 上近似这些积分，即权重为 $w_0 = w_N = \\tfrac{1}{2}$ 和 $w_i = 1$（对于 $i=1,\\dots,N-1$），间距为 $h = 1/N$。\n\n测试套件：\n- 使用 $N \\in \\{8,16,32,64\\}$。\n- 对于每个 $N$，计算并报告两个数值：如上定义的 $E_{\\text{baseline}}(N)$ 和 $E_{\\text{mitigated}}(N)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下\n$$\n\\left[E_{\\text{baseline}}(8), E_{\\text{mitigated}}(8), E_{\\text{baseline}}(16), E_{\\text{mitigated}}(16), E_{\\text{baseline}}(32), E_{\\text{mitigated}}(32), E_{\\text{baseline}}(64), E_{\\text{mitigated}}(64)\\right].\n$$\n不涉及物理单位。角度（在极坐标中隐含相关）以弧度为单位，但当前问题纯粹是径向的。", "solution": "对问题陈述进行验证。\n\n**步骤 1：提取给定条件**\n- **控制方程**: $\\frac{\\partial^2 u}{\\partial r^2} + \\frac{1}{r}\\frac{\\partial u}{\\partial r} = f(r)$ 于 $r \\in [0,1]$。\n- **边界与正则性条件**: $u(1)=0$ 且当 $r \\to 0$ 时 $u(r)$ 为有限值。\n- **精确解**: $u_{\\text{exact}}(r) = 1 - r^2$。\n- **源项**: $f(r) = -4$。\n- **网格**: 均匀网格，有 $N$ 个区间，间距 $h = 1/N$，节点 $r_i = i h$，其中 $i=0,1,\\dots,N$。\n- **基准近似**: $u(0)=0$，$u(1)=0$，且对 $r_i, i \\in \\{1, \\dots, N-1\\}$ 使用标准有限差分。\n- **缓解近似**: 采用数学上合理的策略来处理 $r=0$ 处的奇异性，并满足 $u(1)=0$。\n- **误差度量**: 相对面积加权的离散 $L^2$ 范数，$E = \\frac{\\left(\\int_0^1 2\\pi r \\left(u_{\\text{num}}(r) - u_{\\text{exact}}(r)\\right)^2 \\, dr\\right)^{1/2}}{\\left(\\int_0^1 2\\pi r \\left(u_{\\text{exact}}(r)\\right)^2 \\, dr\\right)^{1/2}}$。\n- **数值积分**: 在 $\\{r_i\\}_{i=0}^N$ 上使用复合梯形法则。\n- **测试套件**: $N \\in \\{8,16,32,64\\}$。\n\n**步骤 2：使用提取的给定条件进行验证**\n该问题具有科学依据，因为它涉及极坐标中泊松方程的数值解，这是工程和物理学中的一个基本问题。$r=0$ 处的坐标奇异点是一个经典的数值挑战，需要特殊处理。该问题正确地将其构建为一个“朴素”方法与“有原则”方法之间的比较研究。该问题是适定的；它为每种情况提供了构建唯一数值解所需的所有方程、边界条件和定义。语言客观且数学上精确。没有科学或逻辑上的缺陷、矛盾或含糊之处。\n\n**步骤 3：结论与行动**\n问题有效。将提供完整解答。\n\n**数学公式与离散化**\n\n控制方程是关于一维空间变量（半径 $r$）的轴对称泊松方程：\n$$\n\\frac{d^2 u}{d r^2} + \\frac{1}{r}\\frac{d u}{d r} = f(r)\n$$\n对于 $r \\in (0, 1]$，边界条件为 $u(1)=0$，源项为 $f(r)=-4$。定义一个具有 $N$ 个区间、间距为 $h=1/N$ 的均匀网格，网格节点位于 $r_i=ih$，其中 $i=0, 1, \\dots, N$。这些节点上的数值解记为 $u_i \\approx u(r_i)$。\n\n对于内部节点 $r_i$（其中 $i \\in \\{1, \\dots, N-1\\}$），使用二阶中心有限差分来近似导数：\n$$\n\\frac{d^2 u}{d r^2}\\bigg|_{r_i} \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\n$$\n$$\n\\frac{d u}{d r}\\bigg|_{r_i} \\approx \\frac{u_{i+1} - u_{i-1}}{2h}\n$$\n将这些近似代入控制方程，并使用 $r_i=ih$，得到内部节点的一般离散方程：\n$$\n\\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} + \\frac{1}{ih} \\left(\\frac{u_{i+1} - u_{i-1}}{2h}\\right) = f_i\n$$\n其中 $f_i = f(r_i) = -4$。此方程可以重排为相邻节点值之间的线性关系：\n$$\n\\left(1 - \\frac{1}{2i}\\right)u_{i-1} - 2u_i + \\left(1 + \\frac{1}{2i}\\right)u_{i+1} = h^2 f_i\n$$\n这构成了一个线性代数方程组的基础。对 $i=0$ 和 $i=N$ 处边界的处理区分了两种所需的近似方案。\n\n**基准近似**\n\n该方法施加狄利克雷（Dirichlet）边界条件 $u_0 = 0$ 和 $u_N = 0$。条件 $u_0=0$ 与精确解 $u_{\\text{exact}}(0) = 1 - 0^2 = 1$ 不一致，它被用来展示不正确处理原点所带来的影响。未知数为节点值 $u_1, u_2, \\dots, u_{N-1}$。通过对每个 $i \\in \\{1, \\dots, N-1\\}$ 应用一般离散方程，形成一个包含 $N-1$ 个线性方程的方程组。这会得到一个 $(N-1) \\times (N-1)$ 的三对角方程组 $A_{\\text{base}} \\mathbf{u}_{\\text{base}} = \\mathbf{b}_{\\text{base}}$，可以求解得到未知向量 $\\mathbf{u}_{\\text{base}} = [u_1, \\dots, u_{N-1}]^T$。\n\n**缓解近似**\n\n一个正确的公式必须妥善处理在 $r=0$ 处的奇异项 $\\frac{1}{r}\\frac{du}{dr}$。根据正则性条件，解 $u(r)$ 在圆盘上必须是光滑的。对于轴对称函数，由于对称性，这意味着一阶导数在原点必须为零：$\\frac{du}{dr}|_{r=0} = 0$。对奇异项应用 L'Hôpital 法则可得：\n$$\n\\lim_{r\\to 0} \\frac{1}{r}\\frac{du}{dr} = \\lim_{r\\to 0} \\frac{\\frac{d^2u}{dr^2}}{\\frac{d}{dr}(r)} = \\frac{d^2u}{dr^2}\\bigg|_{r=0}\n$$\n因此，在 $r=0$ 处，控制方程呈现非奇异形式：\n$$\n2 \\frac{d^2u}{dr^2}\\bigg|_{r=0} = f(0)\n$$\n为了在 $r_0=0$ 处离散化此方程，我们对二阶导数使用二阶中心差分。根据轴对称性，解的轮廓是偶函数，因此 $u(-r) = u(r)$，这意味着 $u(r_{-1}) = u(-h) = u(h) = u_1$。在 $r_0=0$ 处的有限差分近似为：\n$$\n\\frac{d^2u}{dr^2}\\bigg|_{r_0} \\approx \\frac{u_1 - 2u_0 + u_{-1}}{h^2} = \\frac{u_1 - 2u_0 + u_1}{h^2} = \\frac{2u_1 - 2u_0}{h^2}\n$$\n将此代入 $r=0$ 处的特定控制方程，得到中心节点 $u_0$ 的离散方程：\n$$\n2 \\left( \\frac{2u_1 - 2u_0}{h^2} \\right) = f_0 \\quad \\implies \\quad -4u_0 + 4u_1 = h^2f_0\n$$\n缓解情况的方程组由 $i=0$ 处的这个方程和 $i = 1, \\dots, N-1$ 处的一般有限差分方程组成。再加上边界条件 $u_N=0$，这就构成了一个适定的 $N \\times N$ 方程组 $A_{\\text{mit}} \\mathbf{u}_{\\text{mit}} = \\mathbf{b}_{\\text{mit}}$，其中未知量为 $\\mathbf{u}_{\\text{mit}} = [u_0, \\dots, u_{N-1}]^T$。\n\n**误差量化**\n\n误差通过相对面积加权的 $L^2$ 范数来量化。面积元 $2\\pi r \\, dr$ 中的因子 $2\\pi$ 在分子和分母中被消去：\n$$\nE = \\frac{\\left(\\int_0^1 r \\left(u_{\\text{num}}(r) - u_{\\text{exact}}(r)\\right)^2 \\, dr\\right)^{1/2}}{\\left(\\int_0^1 r \\left(u_{\\text{exact}}(r)\\right)^2 \\, dr\\right)^{1/2}}\n$$\n这些积分使用复合梯形法则进行数值近似。对于一个被积函数 $g(r)$，其积分为 $\\int_0^1 g(r) \\, dr \\approx h \\sum_{i=0}^N w_i g(r_i)$，权重为 $w_0=w_N=1/2$ 和 $w_i=1$（对于 $i \\in \\{1,\\dots,N-1\\}$）。对于分子，被积函数为 $g_{\\text{num}}(r) = r(u_{\\text{num}}(r)-u_{\\text{exact}}(r))^2$。对于分母，被积函数为 $g_{\\text{den}}(r) = r(u_{\\text{exact}}(r))^2$。两个被积函数在 $r=0$（由于因子 $r$）和 $r=1$（由于 $u_{\\text{num}}(1)=u_{\\text{exact}}(1)=0$）处均为零。对每个 $N \\in \\{8,16,32,64\\}$ 求得数值解，并计算相应的误差 $E_{\\text{baseline}}(N)$ 和 $E_{\\text{mitigated}}(N)$。", "answer": "```python\nimport numpy as np\n\ndef calculate_error(u_num, u_exact, r):\n    \"\"\"\n    Calculates the relative area-weighted discrete L2 norm.\n    The area element is 2*pi*r*dr, but 2*pi cancels.\n    \"\"\"\n    # Numerator integrand: r * (u_num - u_exact)^2\n    error_sq = (u_num - u_exact)**2\n    integrand_num = r * error_sq\n    \n    # Denominator integrand: r * (u_exact)^2\n    u_exact_sq = u_exact**2\n    integrand_den = r * u_exact_sq\n    \n    # Integrate using the composite trapezoidal rule provided by numpy.\n    # np.trapz(y, x) computes the integral of y(x) dx.\n    integral_num = np.trapz(integrand_num, r)\n    integral_den = np.trapz(integrand_den, r)\n    \n    if integral_den == 0:\n        # This case is unlikely with the given exact solution.\n        return np.inf\n\n    # The error E is the square root of the ratio of the integrals.\n    E = np.sqrt(integral_num / integral_den)\n    return E\n\ndef solve():\n    \"\"\"\n    Solves the axisymmetric Poisson equation using two different treatments\n    of the singularity at r=0 and computes the error for each case.\n    \"\"\"\n    test_cases = [8, 16, 32, 64]\n    results = []\n\n    for N in test_cases:\n        h = 1.0 / N\n        # Grid points r_i = i*h for i = 0, ..., N\n        r = np.linspace(0.0, 1.0, N + 1)\n        # Exact solution u(r) = 1 - r^2\n        u_exact = 1.0 - r**2\n        # Source term f(r) = -4\n        f = -4.0\n\n        # --- Baseline Approximation ---\n        # Solves for unknowns u_1, ..., u_{N-1}. Size (N-1)x(N-1).\n        # Boundary conditions: u_0 = 0, u_N = 0.\n        size_base = N - 1\n        if size_base > 0:\n            # Main diagonal of the matrix A\n            diag_main = -2.0 * np.ones(size_base)\n\n            # Sub-diagonal terms: (1 - 1/(2*i)) for u_{i-1}\n            # Matrix index k = i - 1. So i = k + 1.\n            i_sub = np.arange(2, N) # i goes from 2 to N-1\n            diag_sub = 1.0 - 1.0 / (2.0 * i_sub)\n\n            # Super-diagonal terms: (1 + 1/(2*i)) for u_{i+1}\n            # Matrix index k = i - 1. So i = k + 1.\n            i_sup = np.arange(1, N - 1) # i goes from 1 to N-2\n            diag_sup = 1.0 + 1.0 / (2.0 * i_sup)\n            \n            A_base = np.diag(diag_main) + np.diag(diag_sub, k=-1) + np.diag(diag_sup, k=1)\n            b_base = np.full(size_base, f * h**2)\n\n            u_sol_base = np.linalg.solve(A_base, b_base)\n\n            # Construct full solution vector [u_0, ..., u_N]\n            u_num_base = np.zeros(N + 1)\n            u_num_base[1:N] = u_sol_base # u_num_base at 0 and N remain 0\n        else: # Case N=1\n             u_num_base = np.zeros(N + 1)\n        \n        error_base = calculate_error(u_num_base, u_exact, r)\n        results.append(error_base)\n\n        # --- Mitigated Approximation ---\n        # Solves for unknowns u_0, ..., u_{N-1}. Size NxN.\n        # Boundary conditions: Special equation at r=0, and u_N = 0.\n        size_mit = N\n        A_mit = np.zeros((size_mit, size_mit))\n        b_mit = np.full(size_mit, f * h**2)\n\n        # Row 0: Equation at r=0 is -4*u_0 + 4*u_1 = f*h^2\n        A_mit[0, 0] = -4.0\n        if size_mit > 1:\n            A_mit[0, 1] = 4.0\n\n        # Rows 1 to N-1 (grid indices i=1 to N-1)\n        for i in range(1, size_mit): # i is both matrix row and grid index\n            # Main diagonal term\n            A_mit[i, i] = -2.0\n            # Sub-diagonal term: (1 - 1/(2i)) for u_{i-1}\n            A_mit[i, i - 1] = 1.0 - 1.0 / (2.0 * i)\n            # Super-diagonal term: (1 + 1/(2i)) for u_{i+1}\n            if i  size_mit - 1:\n                A_mit[i, i + 1] = 1.0 + 1.0 / (2.0 * i)\n\n        u_sol_mit = np.linalg.solve(A_mit, b_mit)\n\n        # Construct full solution vector [u_0, ..., u_N]\n        u_num_mit = np.zeros(N + 1)\n        u_num_mit[0:N] = u_sol_mit # u_num_mit at N remains 0\n\n        error_mit = calculate_error(u_num_mit, u_exact, r)\n        results.append(error_mit)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{res:.10f}' for res in results)}]\")\n\nsolve()\n```", "id": "2436320"}, {"introduction": "最后一个练习将挑战升级到一个更复杂的场景：在球面上进行建模。这个实践旨在揭示网格拓扑与数值性能之间的另一个关键联系——由网格引起的刚性问题。通过分析球面上的扩散方程，你将发现纬度-经度网格在极点附近的汇集如何严重限制显式时间积分方法的稳定时间步长。这不仅是数值分析中的一个深刻概念，也是全球气候和天气预报等领域面临的一个核心计算挑战。[@problem_id:2436359]", "problem": "您的任务是在球带上构建结构化的纬度-经度网格，并以守恒形式离散化一个偏微分方程 (PDE)，以分析在极点附近产生的数值刚度。考虑单位球面上的线性扩散方程（热传导方程）：\n$$\n\\frac{\\partial u}{\\partial t} = \\kappa \\,\\Delta_S u,\n$$\n其中 $u = u(\\phi,\\lambda,t)$，$\\kappa  0$ 是一个常数扩散系数，$\\phi \\in [-\\phi_{\\max}, \\phi_{\\max}]$ 是纬度（弧度），$\\lambda \\in [0,2\\pi)$ 是经度（弧度）。在纬度-经度坐标系中，单位球面上的 Laplace–Beltrami 算子为\n$$\n\\Delta_S u = \\frac{1}{\\cos \\phi}\\,\\frac{\\partial}{\\partial \\phi}\\!\\left(\\cos \\phi \\,\\frac{\\partial u}{\\partial \\phi}\\right) + \\frac{1}{\\cos^2 \\phi}\\,\\frac{\\partial^2 u}{\\partial \\lambda^2}.\n$$\n在整个过程中，角度必须以弧度处理。\n\n您的任务是：\n\n1) 从 Laplace–Beltrami 算子的定义和单位球面的度量出发，在球带 $\\phi \\in [-\\phi_{\\max}, \\phi_{\\max}]$, $\\lambda \\in [0,2\\pi)$ 上的均匀纬度-经度网格上，推导一个二阶精度的守恒通量形式的中心有限差分格式。不要包含极冠；即，强制 $\\phi_{\\max}  \\frac{\\pi}{2}$，从而确保 $\\cos \\phi$ 在计算域上保持严格为正。\n\n2) 在经度方向上使用周期性边界条件，在人工边界 $\\phi = \\pm \\phi_{\\max}$ 处使用零法向通量条件。零法向通量条件意味着通过边界的经向通量为零，这与从球面上切下一个带状区域的情况相符。\n\n3) 将离散空间算子组装成一个作用于矢量化网格函数值的矩阵。您的构建必须精确地遵循连续算子所隐含的度量因子。为实现稳健和准确的谱特征分析，您的推导结构应保证组装出的矩阵与一个实对称矩阵对角相似。\n\n4) 对于应用于半离散系统 $\\frac{d\\mathbf{u}}{dt} = \\kappa A \\mathbf{u}$ 的显式（前向）Euler 时间步进法，确定由 $\\kappa A$ 的谱所决定的最大稳定时间步长 $\\Delta t_{\\max}$。使用应用于具有实数非正特征值的线性系统的显式 Euler 法的标准线性稳定性要求。\n\n5) 通过量化 $\\Delta t_{\\max}$ 如何随着网格接近极点（即，当 $\\phi_{\\max} \\to \\frac{\\pi}{2}$ 时）以及随着经度分辨率的增加而变化，来研究由极点奇性引起的数值刚度。使用离散算子计算时间步长限制所需的谱半径。\n\n构建一个程序，对以下每个测试用例，构建离散算子，并返回相应的最大稳定显式 Euler 时间步长 $\\Delta t_{\\max}$（作为一个浮点数）：\n\n- 情况1：$N_\\phi = 24$, $N_\\lambda = 48$, $\\phi_{\\max} = \\frac{\\pi}{2} - 0.2$, $\\kappa = 1$。\n- 情况2：$N_\\phi = 24$, $N_\\lambda = 96$, $\\phi_{\\max} = \\frac{\\pi}{2} - 0.02$, $\\kappa = 1$。\n- 情况3：$N_\\phi = 24$, $N_\\lambda = 48$, $\\phi_{\\max} = \\frac{\\pi}{4}$, $\\kappa = 1$。\n- 情况4：$N_\\phi = 24$, $N_\\lambda = 96$, $\\phi_{\\max} = \\frac{\\pi}{2} - 0.2$, $\\kappa = 1$。\n\n这里 $N_\\phi$ 和 $N_\\lambda$ 分别表示纬度和经度方向上均匀分布的网格点数。均匀间距为 $\\Delta \\phi = \\frac{2\\phi_{\\max}}{N_\\phi - 1}$ 和 $\\Delta \\lambda = \\frac{2\\pi}{N_\\lambda}$。\n\n最终程序必须为每种情况计算由组装算子的谱决定的最大允许显式 Euler 时间步长 $\\Delta t_{\\max}$。所有角度均以弧度为单位。不涉及除弧度以外的任何物理单位。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3,result4]”）。每个结果必须是一个浮点数。程序必须是自包含的，并且不需要任何输入。四个输出必须按顺序对应于情况1到情况4。", "solution": "该问题要求推导球带上线性扩散方程的稳定数值格式，然后对其数值刚度进行定量分析。分析将通过严格离散化控制偏微分方程、组装离散算子以及进行谱分析来确定显式时间积分格式的稳定性极限。\n\n控制方程是单位球面上的热传导方程，由下式给出\n$$\n\\frac{\\partial u}{\\partial t} = \\kappa \\,\\Delta_S u\n$$\n其中 $u(\\phi, \\lambda, t)$ 是我们关注的物理量（例如，温度），$\\kappa  0$ 是扩散系数，$\\phi$ 是纬度，$\\lambda$ 是经度，$\\Delta_S$ 是 Laplace-Beltrami 算子：\n$$\n\\Delta_S u = \\frac{1}{\\cos \\phi}\\,\\frac{\\partial}{\\partial \\phi}\\!\\left(\\cos \\phi \\,\\frac{\\partial u}{\\partial \\phi}\\right) + \\frac{1}{\\cos^2 \\phi}\\,\\frac{\\partial^2 u}{\\partial \\lambda^2}.\n$$\n计算域是由 $\\phi \\in [-\\phi_{\\max}, \\phi_{\\max}]$（其中 $\\phi_{\\max}  \\pi/2$）和 $\\lambda \\in [0, 2\\pi)$ 定义的球带。\n\n定义一个均匀网格，在纬度方向有 $N_\\phi$ 个点，在经度方向有 $N_\\lambda$ 个点。网格点为 $(\\phi_j, \\lambda_k)$，其中 $j=0, \\dots, N_\\phi-1$，$k=0, \\dots, N_\\lambda-1$。网格间距是均匀的：$\\Delta \\phi = \\frac{2\\phi_{\\max}}{N_\\phi - 1}$ 和 $\\Delta \\lambda = \\frac{2\\pi}{N_\\lambda}$。纬度坐标为 $\\phi_j = -\\phi_{\\max} + j\\Delta\\phi$。\n\n空间算子使用二阶中心有限差分进行离散。令 $u_{j,k} \\approx u(\\phi_j, \\lambda_k)$。\n纬向（经度）项离散为：\n$$\n\\left. \\frac{1}{\\cos^2 \\phi}\\,\\frac{\\partial^2 u}{\\partial \\lambda^2} \\right|_{j,k} \\approx \\frac{1}{\\cos^2 \\phi_j} \\frac{u_{j, k+1} - 2u_{j,k} + u_{j, k-1}}{\\Delta\\lambda^2}.\n$$\n经度方向的周期性意味着 $u_{j, N_\\lambda} = u_{j,0}$ 以及 $u_{j, -1} = u_{j, N_\\lambda-1}$。\n\n经向（纬度）项处于守恒形式，通过在网格线（单元面）之间的中点 $\\phi_{j\\pm1/2} = \\phi_j \\pm \\Delta\\phi/2$ 处定义经向通量来进行离散。通量为 $F_\\phi = \\cos\\phi \\, \\frac{\\partial u}{\\partial \\phi}$。\n$$\n\\left. F_\\phi \\right|_{\\phi_{j+1/2}} \\approx \\cos(\\phi_{j+1/2}) \\frac{u_{j+1,k} - u_{j,k}}{\\Delta\\phi}\n$$\n然后，网格点 $\\phi_j$ 处的通量散度通过单元面通量的中心差分来近似：\n$$\n\\left. \\frac{1}{\\cos \\phi} \\frac{\\partial F_\\phi}{\\partial \\phi} \\right|_{j,k} \\approx \\frac{1}{\\cos \\phi_j} \\frac{F_{\\phi, j+1/2} - F_{\\phi, j-1/2}}{\\Delta\\phi}\n$$\n$$\n= \\frac{1}{\\cos \\phi_j \\Delta\\phi^2} \\left( \\cos(\\phi_{j+1/2})(u_{j+1,k} - u_{j,k}) - \\cos(\\phi_{j-1/2})(u_{j,k} - u_{j-1,k}) \\right).\n$$\n此表达式对内部点 $j = 1, \\dots, N_\\phi-2$ 有效。\n\n边界条件为在 $\\phi = \\pm\\phi_{\\max}$ 处法向通量为零。在这些边界上，经向通量 $F_\\phi$ 必须为零。由于 $\\phi_{\\max}  \\pi/2$，$\\cos(\\pm\\phi_{\\max}) \\neq 0$，因此条件简化为在 $\\phi = \\pm\\phi_{\\max}$ 处 $\\frac{\\partial u}{\\partial \\phi} = 0$。\n在下边界 $\\phi_0 = -\\phi_{\\max}$ 处，入通量 $F_{\\phi, -1/2}$ 为零。在 $j=0$ 处的离散格式变为：\n$$\n\\left. \\Delta_S u \\right|_{0,k} \\approx \\frac{1}{\\cos \\phi_0 \\Delta\\phi^2} \\left( \\cos(\\phi_{1/2})(u_{1,k} - u_{0,k}) \\right) + \\frac{u_{0,k+1} - 2u_{0,k} + u_{0,k-1}}{\\cos^2 \\phi_0 \\Delta\\lambda^2}.\n$$\n在上边界 $\\phi_{N_\\phi-1} = \\phi_{\\max}$ 处，出通量 $F_{\\phi, N_\\phi-1/2}$ 为零。在 $j=N_\\phi-1$ 处的离散格式变为：\n$$\n\\left. \\Delta_S u \\right|_{N_\\phi-1,k} \\approx \\frac{1}{\\cos \\phi_{N_\\phi-1} \\Delta\\phi^2} \\left( -\\cos(\\phi_{N_\\phi-3/2})(u_{N_\\phi-1,k} - u_{N_\\phi-2,k}) \\right) + \\frac{u_{N_\\phi-1,k+1} - 2u_{N_\\phi-1,k} + u_{N_\\phi-1,k-1}}{\\cos^2 \\phi_{N_\\phi-1} \\Delta\\lambda^2}.\n$$\n常微分方程的半离散系统为 $\\frac{d\\mathbf{u}}{dt} = \\kappa A \\mathbf{u}$，其中 $\\mathbf{u}$ 是所有网格点值 $u_{j,k}$ 构成的向量，$A$ 是离散 Laplace-Beltrami 算子的矩阵表示。$A$ 的元素由上述推导的差分格式确定。矩阵 $A$ 的大小为 $(N_\\phi N_\\lambda) \\times (N_\\phi N_\\lambda)$。\n\n问题要求 $A$ 与一个实对称矩阵对角相似。连续算子 $\\Delta_S$ 对于包含曲面面积元素的内积 $\\langle f, g \\rangle = \\iint f g \\cos\\phi \\,d\\phi\\,d\\lambda$ 是自伴的。该性质的离散模拟是矩阵 $D A$ 应该是对称的，其中 $D$ 是对角矩阵，其元素为 $d_{j,k} = \\cos \\phi_j$。我们来验证这一点。将方程的第 $j$ 行乘以 $\\cos\\phi_j$，经向部分变为：\n$$\n\\frac{1}{\\Delta\\phi^2} \\left( \\cos(\\phi_{j+1/2}) u_{j+1,k} - (\\cos(\\phi_{j+1/2}) + \\cos(\\phi_{j-1/2})) u_{j,k} + \\cos(\\phi_{j-1/2}) u_{j-1,k} \\right).\n$$\n对于固定的经度 $k$，这对应于一个对称三对角矩阵。纬向部分变为：\n$$\n\\frac{1}{\\cos \\phi_j \\Delta\\lambda^2} (u_{j, k+1} - 2u_{j,k} + u_{j, k-1}).\n$$\n当将包含这两项的算子组装成完整矩阵 $M = D A$ 时，该矩阵是对称的。由于 $D$ 是对角矩阵，且对于 $|\\phi_j|  \\pi/2$ 其对角元素 $\\cos \\phi_j  0$ 为正，因此 $A$ 与对称矩阵 $D^{1/2} A D^{-1/2} = D^{-1/2} M D^{-1/2}$ 相似。这保证了 $A$ 的特征值是实数。此外，算子 $A$ 代表扩散，因此其特征值 $\\lambda_i$ 是非正的，即 $\\lambda_i \\le 0$。\n\n对于显式（前向）Euler 格式 $\\mathbf{u}^{n+1} = (I + \\Delta t \\kappa A)\\mathbf{u}^n$ 的数值稳定性，每个本征模的放大因子其绝对值不得大于 1。对于实数非正特征值 $\\kappa \\lambda_i$，该条件为 $|1 + \\Delta t \\kappa \\lambda_i| \\le 1$。这意味着 $-2 \\le \\Delta t \\kappa \\lambda_i \\le 0$。由于 $\\Delta t, \\kappa  0$ 且 $\\lambda_i \\le 0$，这可简化为 $\\Delta t \\kappa \\lambda_{\\min} \\ge -2$，其中 $\\lambda_{\\min}$ 是 $A$ 的最小（最负）特征值。因此，最大稳定时间步长为\n$$\n\\Delta t_{\\max} = \\frac{-2}{\\kappa \\lambda_{\\min}(A)}.\n$$\n数值刚度源于纬向项中的 $1/\\cos^2\\phi$ 因子。当 $\\phi_{\\max} \\to \\pi/2$ 时，经度网格线会收敛。对于固定的 $\\Delta\\lambda$，纬向方向上网格点之间的物理距离 $\\cos\\phi_j \\Delta\\lambda$ 变得非常小。对 $\\Delta t$ 的稳定性限制受限于域中最小网格间距的平方，导致 $\\Delta t_{\\max} \\propto (\\cos\\phi_{\\max} \\Delta\\lambda)^2$。因此，对于延伸到靠近极点的网格或具有高纬向分辨率（$N_\\lambda$）的网格，$\\Delta t_{\\max}$ 会变得过小，这是数值刚度的典型症状。\n\n最后一步是按计算实现此过程：组装矩阵 $A$，找到其最小特征值，并为给定的测试用例计算 $\\Delta t_{\\max}$。", "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef construct_operator_and_solve(N_phi, N_lambda, phi_max, kappa):\n    \"\"\"\n    Constructs the discrete operator for the heat equation on a spherical band\n    and computes the maximum stable time step for the explicit Euler method.\n    \"\"\"\n    # 1. Define grid parameters\n    phi = np.linspace(-phi_max, phi_max, N_phi, dtype=np.float64)\n    # Ensure robust calculation of delta_phi, especially if N_phi=1\n    if N_phi > 1:\n        delta_phi = (2.0 * phi_max) / (N_phi - 1)\n    else:\n        delta_phi = 1.0 # arbitrary, will not be used\n    delta_lambda = (2.0 * np.pi) / N_lambda\n\n    # 2. Assemble the discrete operator matrix A\n    N_total = N_phi * N_lambda\n    A = np.zeros((N_total, N_total), dtype=np.float64)\n\n    for j in range(N_phi):  # Latitude index from 0 to N_phi-1\n        # Precompute latitude-dependent coefficients\n        cos_phi_j = np.cos(phi[j])\n        lambda_coeff = 1.0 / (cos_phi_j**2 * delta_lambda**2)\n\n        for k in range(N_lambda):  # Longitude index from 0 to N_lambda-1\n            row_idx = j * N_lambda + k\n\n            # Zonal (longitude) part of the operator (periodic)\n            col_idx_km1 = j * N_lambda + (k - 1 + N_lambda) % N_lambda\n            col_idx_kp1 = j * N_lambda + (k + 1) % N_lambda\n            A[row_idx, col_idx_km1] += lambda_coeff\n            A[row_idx, col_idx_kp1] += lambda_coeff\n            A[row_idx, row_idx] -= 2.0 * lambda_coeff\n\n            # Meridional (latitude) part of the operator\n            if N_phi > 1:\n                phi_coeff_denom = cos_phi_j * delta_phi**2\n\n                if j == 0:  # Lower boundary (j=0), zero flux\n                    phi_j_plus_half = phi[j] + delta_phi / 2.0\n                    c_j_plus_half = np.cos(phi_j_plus_half)\n                    \n                    col_idx_jp1 = (j + 1) * N_lambda + k\n                    A[row_idx, col_idx_jp1] += c_j_plus_half / phi_coeff_denom\n                    A[row_idx, row_idx] -= c_j_plus_half / phi_coeff_denom\n\n                elif j == N_phi - 1:  # Upper boundary (j=N_phi-1), zero flux\n                    phi_j_minus_half = phi[j] - delta_phi / 2.0\n                    c_j_minus_half = np.cos(phi_j_minus_half)\n                    \n                    col_idx_jm1 = (j - 1) * N_lambda + k\n                    A[row_idx, col_idx_jm1] += c_j_minus_half / phi_coeff_denom\n                    A[row_idx, row_idx] -= c_j_minus_half / phi_coeff_denom\n\n                else:  # Interior points\n                    phi_j_plus_half = phi[j] + delta_phi / 2.0\n                    c_j_plus_half = np.cos(phi_j_plus_half)\n                    phi_j_minus_half = phi[j] - delta_phi / 2.0\n                    c_j_minus_half = np.cos(phi_j_minus_half)\n\n                    col_idx_jm1 = (j - 1) * N_lambda + k\n                    col_idx_jp1 = (j + 1) * N_lambda + k\n                    A[row_idx, col_idx_jm1] += c_j_minus_half / phi_coeff_denom\n                    A[row_idx, col_idx_jp1] += c_j_plus_half / phi_coeff_denom\n                    A[row_idx, row_idx] -= (c_j_plus_half + c_j_minus_half) / phi_coeff_denom\n\n    # 3. Compute eigenvalues and the minimum eigenvalue\n    # The matrix A is diagonally similar to a symmetric matrix, so eigenvalues are real.\n    eigenvalues = scipy.linalg.eigvals(A)\n    # Due to floating point arithmetic, small imaginary parts might appear.\n    lambda_min = np.min(np.real(eigenvalues))\n\n    # 4. Calculate the maximum stable time step\n    # The PDE system is du/dt = kappa * A * u. Eigenvalues of (kappa*A) are kappa*lambda_i.\n    # The stability condition is dt = -2 / (kappa * lambda_min).\n    if lambda_min >= 0:\n        # This case should not happen for a diffusion operator with at least 2 points.\n        # It implies the only eigenvalue is 0, e.g., for a 1-point grid.\n        # A matrix of zeros leads to lambda_min = 0, so dt_max would be infinite.\n        if N_total = 1:\n            return np.inf\n        else: # Should not happen, implies error in matrix construction\n            raise ValueError(\"Minimum eigenvalue is non-negative, invalid for diffusion.\")\n\n    dt_max = -2.0 / (kappa * lambda_min)\n    return dt_max\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (N_phi, N_lambda, phi_max, kappa)\n        (24, 48, np.pi / 2.0 - 0.2, 1.0),\n        (24, 96, np.pi / 2.0 - 0.02, 1.0),\n        (24, 48, np.pi / 4.0, 1.0),\n        (24, 96, np.pi / 2.0 - 0.2, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        dt_max = construct_operator_and_solve(*case)\n        results.append(dt_max)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2436359"}]}