{"hands_on_practices": [{"introduction": "有限差分法的核心在于用离散的节点值来近似导数。这个练习将带您亲历这一基本过程，运用泰勒级数展开来推导一个四阶导数（即双调和算子）的高阶近似格式 [@problem_id:2385929]。掌握此方法是至关重要的，因为它不仅是构建数值方案的基石，而且在梁理论和板壳力学等领域有着直接应用。", "problem": "考虑一个一维均匀网格，其节点为 $x_i = x_0 + i h$（$i$ 为整数），网格间距 $h>0$。设函数 $u:\\mathbb{R}\\to\\mathbb{R}$ 在 $x_i$ 的邻域内至少是 $C^6$ 光滑的，并设 $u_i \\equiv u(x_i)$。在一个内部节点 $x_i$ 处，仅使用节点值 $u_{i-2}, u_{i-1}, u_i, u_{i+1}, u_{i+2}$ 和 $h$ 的幂，构建一个对双调和算子（即四阶导数 $u_{xxxx}(x_i)$）的对称、紧凑的 5 点有限差分近似。所得的近似必须与四阶导数的定义相一致，并且使用的点数不超过这 5 个点。\n\n请以 $u_{i-2}, u_{i-1}, u_i, u_{i+1}, u_{i+2}$ 和 $h$ 的单一闭式解析表达式形式给出最终的近似。无需四舍五入。最终表达式中不要包含任何等号。", "solution": "问题陈述需要经过验证。\n\n**步骤 1：提取已知条件**\n- 网格：一维均匀网格，节点为 $x_i = x_0 + i h$，$i$ 为整数。\n- 网格间距：$h > 0$。\n- 函数：$u:\\mathbb{R}\\to\\mathbb{R}$ 在 $x_i$ 的邻域内至少是 $C^6$ 光滑的。\n- 节点值：$u_i \\equiv u(x_i)$。\n- 目标：在一个内部节点 $x_i$ 处，构建对双调和算子 $u_{xxxx}(x_i)$ 的对称、紧凑的 5 点有限差分近似。\n- 模板：近似必须仅使用节点值 $u_{i-2}, u_{i-1}, u_i, u_{i+1}, u_{i+2}$ 及 $h$ 的幂。\n\n**步骤 2：使用提取的已知条件进行验证**\n根据所需标准对问题进行分析。\n- **科学依据**：该问题是数值分析中离散化微分算子的一个标准练习。双调和算子在固体力学和流体动力学中是基础性的。这在科学上是合理的。\n- **适定性**：该问题是适定的。它要求在给定清晰的模板和对称性约束的条件下，推导一个特定的有限差分公式。使用泰勒级数的待定系数法为求唯一解提供了一条路径。\n- **客观性**：问题以精确、客观的数学语言陈述。\n- **结论**：该问题没有科学缺陷、歧义或信息缺失。它是计算工程中一个有效、定义明确的问题。\n\n**步骤 3：结论与行动**\n问题有效。将推导解答。\n\n目标是找到系数 $c_{-2}, c_{-1}, c_0, c_1, c_2$，使得线性组合\n$$\n\\mathcal{L}[u] = c_{-2}u_{i-2} + c_{-1}u_{i-1} + c_0u_i + c_1u_{i+1} + c_2u_{i+2}\n$$\n为四阶导数 $u_{xxxx}(x_i) \\equiv \\frac{d^4u}{dx^4}\\big|_{x=x_i}$ 提供一个一致的近似。问题指定了一个对称模板，这意味着 $c_{-k} = c_k$。因此，我们只需要找到三个系数：$c_0$、$c_1$ 和 $c_2$。近似式具有以下形式：\n$$\n\\mathcal{L}[u] = c_2(u_{i-2} + u_{i+2}) + c_1(u_{i-1} + u_{i+1}) + c_0u_i\n$$\n\n确定这些系数的标准方法是对每个节点值 $u_{i+k}$ 在中心点 $x_i$ 周围进行泰勒级数展开。给定函数 $u(x)$ 至少是 $C^6$ 光滑的，这使得我们可以写出足够精度的展开式。设 $u^{(n)}_i$ 表示 $\\frac{d^n u}{dx^n}\\big|_{x=x_i}$。\n\n$u(x_i \\pm k h)$ 的泰勒展开式为：\n$$\nu_{i \\pm k} = u(x_i \\pm kh) = \\sum_{n=0}^{\\infty} \\frac{(\\pm kh)^n}{n!} u^{(n)}_i\n$$\n具体来说，对于 $k=1$ 和 $k=2$：\n$$\nu_{i+1} = u_i + h u^{(1)}_i + \\frac{h^2}{2} u^{(2)}_i + \\frac{h^3}{6} u^{(3)}_i + \\frac{h^4}{24} u^{(4)}_i + \\frac{h^5}{120} u^{(5)}_i + \\frac{h^6}{720} u^{(6)}_i + O(h^7)\n$$\n$$\nu_{i-1} = u_i - h u^{(1)}_i + \\frac{h^2}{2} u^{(2)}_i - \\frac{h^3}{6} u^{(3)}_i + \\frac{h^4}{24} u^{(4)}_i - \\frac{h^5}{120} u^{(5)}_i + \\frac{h^6}{720} u^{(6)}_i + O(h^7)\n$$\n$$\nu_{i+2} = u_i + 2h u^{(1)}_i + \\frac{(2h)^2}{2} u^{(2)}_i + \\frac{(2h)^3}{6} u^{(3)}_i + \\frac{(2h)^4}{24} u^{(4)}_i + \\frac{(2h)^5}{120} u^{(5)}_i + \\frac{(2h)^6}{720} u^{(6)}_i + O(h^7)\n$$\n$$\nu_{i-2} = u_i - 2h u^{(1)}_i + \\frac{(2h)^2}{2} u^{(2)}_i - \\frac{(2h)^3}{6} u^{(3)}_i + \\frac{(2h)^4}{24} u^{(4)}_i - \\frac{(2h)^5}{120} u^{(5)}_i + \\frac{(2h)^6}{720} u^{(6)}_i + O(h^7)\n$$\n由于模板的对称性，将成对的项 $u_{i+k} + u_{i-k}$ 相加是有利的。这会自动消去所有奇数阶导数项。\n$$\nu_{i+1} + u_{i-1} = 2u_i + h^2 u^{(2)}_i + \\frac{h^4}{12} u^{(4)}_i + \\frac{h^6}{360} u^{(6)}_i + O(h^8)\n$$\n$$\nu_{i+2} + u_{i-2} = 2u_i + (2h)^2 u^{(2)}_i + \\frac{(2h)^4}{12} u^{(4)}_i + \\frac{(2h)^6}{360} u^{(6)}_i + O(h^8) = 2u_i + 4h^2 u^{(2)}_i + \\frac{16h^4}{12} u^{(4)}_i + \\frac{64h^6}{360} u^{(6)}_i + O(h^8)\n$$\n将这些和代入近似形式 $\\mathcal{L}[u]$ 中：\n$$\n\\mathcal{L}[u] = c_2 \\left( 2u_i + 4h^2 u^{(2)}_i + \\frac{4h^4}{3} u^{(4)}_i + \\dots \\right) + c_1 \\left( 2u_i + h^2 u^{(2)}_i + \\frac{h^4}{12} u^{(4)}_i + \\dots \\right) + c_0u_i\n$$\n我们按 $u_i$ 的导数阶数对各项进行分组：\n$$\n\\mathcal{L}[u] = (2c_1 + 2c_2 + c_0)u_i + h^2(c_1 + 4c_2)u^{(2)}_i + h^4\\left(\\frac{c_1}{12} + \\frac{4c_2}{3}\\right)u^{(4)}_i + \\dots\n$$\n为使此表达式成为 $u^{(4)}_i$ 的一个一致近似，我们必须使各阶导数的系数与目标 $1 \\cdot u^{(4)}_i$ 相匹配。这意味着 $u^{(4)}_i$ 的系数必须是 $1$，并且低阶导数（$u_i$ 和 $u^{(2)}_i$）的系数必须是 $0$。这就得到了关于 $c_0, c_1, c_2$ 的一个三元线性方程组：\n\\begin{enumerate}\n    \\item $u_i$ 的系数：$c_0 + 2c_1 + 2c_2 = 0$\n    \\item $u^{(2)}_i$ 的系数：$h^2(c_1 + 4c_2) = 0 \\implies c_1 + 4c_2 = 0$\n    \\item $u^{(4)}_i$ 的系数：$h^4\\left(\\frac{c_1}{12} + \\frac{4c_2}{3}\\right) = 1 \\implies \\frac{c_1}{12} + \\frac{4c_2}{3} = \\frac{1}{h^4}$\n\\end{enumerate}\n由方程 (2)，我们得到 $c_1 = -4c_2$。\n将此代入方程 (3)：\n$$\n\\frac{-4c_2}{12} + \\frac{4c_2}{3} = \\frac{1}{h^4} \\implies -\\frac{c_2}{3} + \\frac{4c_2}{3} = \\frac{1}{h^4} \\implies c_2 = \\frac{1}{h^4}\n$$\n已知 $c_2$，我们求出 $c_1$：\n$$\nc_1 = -4c_2 = -\\frac{4}{h^4}\n$$\n最后，我们使用方程 (1) 来求 $c_0$：\n$$\nc_0 + 2\\left(-\\frac{4}{h^4}\\right) + 2\\left(\\frac{1}{h^4}\\right) = 0 \\implies c_0 - \\frac{8}{h^4} + \\frac{2}{h^4} = 0 \\implies c_0 = \\frac{6}{h^4}\n$$\n因此，系数为：\n$c_2 = c_{-2} = \\frac{1}{h^4}$、$c_1 = c_{-1} = -\\frac{4}{h^4}$ 以及 $c_0 = \\frac{6}{h^4}$。\n将这些系数代回线性组合，得到所需的 $u_{xxxx}(x_i)$ 近似：\n$$\n\\frac{1}{h^4} u_{i-2} - \\frac{4}{h^4} u_{i-1} + \\frac{6}{h^4} u_i - \\frac{4}{h^4} u_{i+1} + \\frac{1}{h^4} u_{i+2}\n$$\n这可以写得更紧凑。四阶导数的有限差分近似的最终表达式是：\n$$\n\\frac{u_{i-2} - 4u_{i-1} + 6u_i - 4u_{i+1} + u_{i+2}}{h^4}\n$$\n这个结果就是四阶导数的中心有限差分公式，它是通过两次应用中心二阶差分算子得到的。系数 $1, -4, 6, -4, 1$ 对应于带交替符号的帕斯卡三角形的第四行，这是四阶中心差分算子的一个特征。", "answer": "$$\n\\boxed{\\frac{u_{i-2} - 4 u_{i-1} + 6 u_i - 4 u_{i+1} + u_{i+2}}{h^{4}}}\n$$", "id": "2385929"}, {"introduction": "从理论推导转向实际编程，我们来解决一个更贴近工程现实的问题。真实世界的问题常常涉及具有不同物理属性的多种材料。本练习要求您应用以其守恒特性而著称的有限体积法，来求解一个包含材料界面的热扩散问题 [@problem_id:2385950]。通过这个实践，您将学会如何确保物理通量（如热流）在整个离散区域，尤其是在界面处，得到正确的保持。", "problem": "考虑在区间 $[0,L]$ 上的稳态一维扩散问题，其材料属性（热导率）为分段常数，由下式给出：\n$$\nk(x) = \\begin{cases}\nk_1, & 0 \\le x < x_{\\mathrm{int}},\\\\\nk_2, & x_{\\mathrm{int}} \\le x \\le L.\n\\end{cases}\n$$\n状态变量 $T(x)$ 满足以下边值问题：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(k(x)\\frac{\\mathrm{d}T}{\\mathrm{d}x}\\right) = 0,\\quad T(0)=T_0,\\quad T(L)=T_L.\n$$\n所有量均为无量纲。\n\n您必须编写一个完整、可运行的程序。对于下述每个测试用例，该程序需使用一维有限体积法 (FVM) 将区间 $[0,L]$ 离散化为 $N$ 个控制体积。该方法需确保在一个可能非均匀的网格上，所有面上的局部通量守恒。该网格由公比为 $r>0$ 的等比数列定义（当 $r=1$ 时为均匀网格）。网格由宽度 $\\Delta x_i$ 定义，其与 $r^{i-1}$ 成正比（其中 $i\\in\\{1,2,\\dots,N\\}$），并进行缩放以满足 $\\sum_{i=1}^N \\Delta x_i = L$，控制体积的中心位于其中点。根据阶跃函数 $k(x)$ 和控制体积中心的位置，为每个控制体积分配 $k(x)$ 的值。施加狄利克雷边界条件 $T(0)=T_0$ 和 $T(L)=T_L$。计算数值稳态解及相应的恒定扩散通量，并计算从所述边值问题的精确解中得到的精确通量。对于每个测试用例，输出数值计算的左边界通量与精确通量之间的绝对差值，结果为单个实数。\n\n测试套件（五个用例）。对于每个项目符号，参数为 $(L, N, k_1, k_2, x_{\\mathrm{int}}, T_0, T_L, r)$:\n- 案例1：$(L=\\;1.0,\\; N=\\;10,\\; k_1=\\;10.0,\\; k_2=\\;1.0,\\; x_{\\mathrm{int}}=\\;0.4,\\; T_0=\\;100.0,\\; T_L=\\;0.0,\\; r=\\;1.0)$。\n- 案例2：$(L=\\;1.0,\\; N=\\;9,\\; k_1=\\;1.0,\\; k_2=\\;100.0,\\; x_{\\mathrm{int}}=\\;0.5,\\; T_0=\\;0.0,\\; T_L=\\;1.0,\\; r=\\;1.0)$。\n- 案例3：$(L=\\;1.0,\\; N=\\;7,\\; k_1=\\;0.1,\\; k_2=\\;5.0,\\; x_{\\mathrm{int}}=\\;0.0,\\; T_0=\\;20.0,\\; T_L=\\;50.0,\\; r=\\;1.0)$。\n- 案例4：$(L=\\;2.0,\\; N=\\;12,\\; k_1=\\;15.0,\\; k_2=\\;2.0,\\; x_{\\mathrm{int}}=\\;1.4,\\; T_0=\\;300.0,\\; T_L=\\;200.0,\\; r=\\;3.0)$。\n- 案例5：$(L=\\;1.0,\\; N=\\;8,\\; k_1=\\;5.0,\\; k_2=\\;5.0,\\; x_{\\mathrm{int}}=\\;0.3,\\; T_0=\\;10.0,\\; T_L=\\;0.0,\\; r=\\;1.0)$。\n\n每个测试用例的要求：\n- 按照描述，使用 $N$ 个控制体积和公比 $r$ 构建非均匀网格。\n- 使用一维保守有限体积法 (FVM) 进行离散化，确保在稳态下通过共享面的通量相同，且每个控制体积的分段常数 $k$ 与 $k(x)$ 一致。\n- 在 $x=0$ 和 $x=L$ 处施加狄利克雷边界条件。\n- 计算左边界的数值通量，并计算由边值问题的精确解所隐含的精确通量。\n- 将这两个通量值之间的绝对差值作为一个实数输出。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含五个测试用例的结果。结果应为逗号分隔的列表，包含在方括号内，不含空格，并按上述顺序列出；例如，输出形式为 $[a_1,a_2,a_3,a_4,a_5]$，其中每个 $a_i$ 是用例 $i$ 的绝对误差。", "solution": "问题陈述已经过严格验证，并被认为是有效的。它具有科学依据、适定、客观，并包含构建唯一且有意义的解所需的所有必要信息。该问题要求使用有限体积法 (FVM) 求解一维稳态扩散方程，这在计算工程中是一种标准且适用的技术。\n\n我们首先推导扩散通量的精确解，然后阐述数值方法的构建。\n\n稳态一维扩散的控制方程为\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(k(x)\\frac{\\mathrm{d}T}{\\mathrm{d}x}\\right) = 0\n$$\n其中 $T(x)$ 是温度场，$k(x)$ 是热导率。将该方程对 $x$ 积分一次，得到：\n$$\nk(x)\\frac{\\mathrm{d}T}{\\mathrm{d}x} = C\n$$\n其中 $C$ 是一个积分常数。扩散通量定义为 $q(x) = -k(x)\\frac{\\mathrm{d}T}{\\mathrm{d}x}$。因此，通量 $q$ 在整个域内是恒定的，这是稳态、无源问题中守恒的直接结果。我们可以写成 $q = -C$，因此有 $\\frac{\\mathrm{d}T}{\\mathrm{d}x} = -\\frac{q_{\\text{exact}}}{k(x)}$。\n\n为了求出这个恒定通量 $q_{\\text{exact}}$ 的值，我们将 $\\frac{\\mathrm{d}T}{\\mathrm{d}x}$ 在整个域上从 $x=0$ 到 $x=L$ 进行积分：\n$$\n\\int_{0}^{L} \\frac{\\mathrm{d}T}{\\mathrm{d}x} \\mathrm{d}x = T(L) - T(0) = T_L - T_0\n$$\n同时，\n$$\n\\int_{0}^{L} \\left(-\\frac{q_{\\text{exact}}}{k(x)}\\right) \\mathrm{d}x = -q_{\\text{exact}} \\int_{0}^{L} \\frac{1}{k(x)} \\mathrm{d}x\n$$\n根据 $k(x)$ 的分段常数定义，其倒数的积分为：\n$$\n\\int_{0}^{L} \\frac{1}{k(x)} \\mathrm{d}x = \\int_{0}^{x_{\\mathrm{int}}} \\frac{1}{k_1} \\mathrm{d}x + \\int_{x_{\\mathrm{int}}}^{L} \\frac{1}{k_2} \\mathrm{d}x = \\frac{x_{\\mathrm{int}}}{k_1} + \\frac{L - x_{\\mathrm{int}}}{k_2}\n$$\n该表达式表示复合介质的总热阻。通过令两个表示温差的表达式相等，我们得到：\n$$\nT_L - T_0 = -q_{\\text{exact}} \\left( \\frac{x_{\\mathrm{int}}}{k_1} + \\frac{L - x_{\\mathrm{int}}}{k_2} \\right)\n$$\n求解精确通量，得到：\n$$\nq_{\\text{exact}} = \\frac{T_0 - T_L}{\\frac{x_{\\mathrm{int}}}{k_1} + \\frac{L - x_{\\mathrm{int}}}{k_2}}\n$$\n这个公式给出了精确的、恒定的通量，数值结果将与之进行比较。\n\n接下来，我们构建有限体积法。将域 $[0, L]$ 离散化为 $N$ 个控制体积 (CV)。第 $i$ 个控制体积（$i \\in \\{1, 2, \\dots, N\\}$）的宽度为 $\\Delta x_i$。这些宽度形成一个等比数列 $\\Delta x_i = C r^{i-1}$，其中常数 $C$ 的选择需满足 $\\sum_{i=1}^N \\Delta x_i = L$。该和为一个等比级数，因此当 $r \\ne 1$ 时，$C = L\\frac{r-1}{r^N-1}$，而当 $r=1$ 时，$C = L/N$。第 $i$ 个控制体积的中心记为 $x_{c,i}$，该体积的热导率 $k_i$ 被赋值为 $k_i = k(x_{c,i})$。\n\nFVM 基于控制方程在每个控制体积上的积分形式。对于第 $i$ 个控制体积，其范围从面 $x_{f,i-1}$ 到 $x_{f,i}$，我们有：\n$$\n\\int_{x_{f,i-1}}^{x_{f,i}} \\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(k(x)\\frac{\\mathrm{d}T}{\\mathrm{d}x}\\right) \\mathrm{d}x = \\left[k(x)\\frac{\\mathrm{d}T}{\\mathrm{d}x}\\right]_{x_{f,i-1}}^{x_{f,i}} = 0\n$$\n这可以简化为 $q_{f,i-1} - q_{f,i} = 0$，其中 $q_{f,i}$ 是分隔控制体积 $i$ 和 $i+1$ 的面上的通量。这表明，从左侧进入控制体积的通量必须等于从右侧流出的通量。\n\n面通量通过使用相邻控制体积中心 $T_{i}$ 和 $T_{i+1}$ 的温度来近似。通量 $q_{f,i}$ 由节点间的温差除以热阻给出：\n$$\nq_{f,i} = \\frac{T_i - T_{i+1}}{R_{i,i+1}}\n$$\n对于一个保守格式，电阻 $R_{i,i+1}$ 被正确地建模为两个串联的电阻，对应于相邻两个控制体积的半部分。这导致了有效界面热导率的调和平均值：\n$$\nR_{i,i+1} = \\frac{\\Delta x_i / 2}{k_i} + \\frac{\\Delta x_{i+1} / 2}{k_{i+1}}\n$$\n对于内部的控制体积 $i$ （其中 $i \\in \\{2, \\dots, N-1\\}$），通量平衡 $q_{f,i-1} - q_{f,i} = 0$ 变为：\n$$\n\\frac{T_{i-1} - T_i}{R_{i-1,i}} - \\frac{T_i - T_{i+1}}{R_{i,i+1}} = 0\n$$\n整理后得到一个关于 $T_{i-1}$、$T_i$ 和 $T_{i+1}$ 的线性方程：\n$$\n\\left(\\frac{1}{R_{i-1,i}}\\right)T_{i-1} - \\left(\\frac{1}{R_{i-1,i}} + \\frac{1}{R_{i,i+1}}\\right)T_i + \\left(\\frac{1}{R_{i,i+1}}\\right)T_{i+1} = 0\n$$\n\n边界条件在第一个和最后一个控制体积处被引入。对于控制体积 1，其左侧面是域边界 $x=0$，在该处 $T(0)=T_0$。从边界到控制体积 1 中心的电阻为 $R_{B,1} = (\\Delta x_1/2)/k_1$。其通量平衡为：\n$$\n\\frac{T_0 - T_1}{R_{B,1}} - \\frac{T_1 - T_2}{R_{1,2}} = 0\n$$\n对于控制体积 $N$，其右侧面是域边界 $x=L$，在该处 $T(L)=T_L$。从控制体积 $N$ 的中心到边界的电阻为 $R_{N,B} = (\\Delta x_N/2)/k_N$：\n$$\n\\frac{T_{N-1} - T_N}{R_{N-1,N}} - \\frac{T_N - T_L}{R_{N,B}} = 0\n$$\n这 $N$ 个关于 $N$ 个未知温度 $T_1, \\dots, T_N$ 的线性方程构成一个三对角系统 $A\\vec{T} = \\vec{b}$，该系统可以被高效求解。\n\n一旦求出单元中心温度向量 $\\vec{T}$，左边界的数值通量可按如下方式计算：\n$$\nq_{\\text{num}} = \\frac{T_0 - T_1}{R_{B,1}} = \\frac{T_0 - T_1}{(\\Delta x_1 / 2) / k_1}\n$$\n由于离散化的保守性，在数值解中，该通量值在所有控制体积的面上都是恒定的。每个测试用例的最终结果是绝对误差 $|q_{\\text{num}} - q_{\\text{exact}}|$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D steady-state diffusion problem for a suite of test cases\n    using a conservative Finite Volume Method.\n    \"\"\"\n    test_cases = [\n        # (L, N, k1, k2, x_int, T0, TL, r)\n        (1.0, 10, 10.0, 1.0, 0.4, 100.0, 0.0, 1.0),\n        (1.0, 9, 1.0, 100.0, 0.5, 0.0, 1.0, 1.0),\n        (1.0, 7, 0.1, 5.0, 0.0, 20.0, 50.0, 1.0),\n        (2.0, 12, 15.0, 2.0, 1.4, 300.0, 200.0, 3.0),\n        (1.0, 8, 5.0, 5.0, 0.3, 10.0, 0.0, 1.0),\n    ]\n\n    results = []\n    for params in test_cases:\n        error = process_case(*params)\n        results.append(error)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef process_case(L, N, k1, k2, x_int, T0, TL, r):\n    \"\"\"\n    Computes the absolute flux error for a single test case.\n    \"\"\"\n    # 1. Exact Flux Calculation\n    # The total thermal resistance is the sum of resistances of the two sections.\n    #Resistance R = length / conductivity.\n    res_1 = x_int / k1 if k1 != 0 else np.inf\n    res_2 = (L - x_int) / k2 if k2 != 0 else np.inf\n    total_resistance = res_1 + res_2\n    \n    if total_resistance == 0:\n        # Avoid division by zero if conductivities are infinite\n        q_exact = np.inf if T0 != TL else 0.0\n    else:\n        q_exact = (T0 - TL) / total_resistance\n\n    # 2. Grid Generation\n    if r == 1.0:\n        deltas = np.full(N, L / N)\n    else:\n        # Sum of geometric series: C * (r^N - 1)/(r - 1) = L\n        # This determines the scaling constant C.\n        C = L * (r - 1) / (r**N - 1)\n        deltas = C * (r ** np.arange(N))\n\n    # Face positions (x_f) and cell center positions (x_c)\n    x_f = np.zeros(N + 1)\n    x_f[1:] = np.cumsum(deltas)\n    x_c = x_f[:-1] + deltas / 2.0\n\n    # 3. Assign Material Properties to Cells\n    # k_cell[i] is k1 if center of cell i is less than x_int, else k2.\n    k_cell = np.where(x_c < x_int, k1, k2)\n\n    # 4. Assemble Linear System Ax = b for cell temperatures\n    A = np.zeros((N, N))\n    b = np.zeros(N)\n\n    # Handle N=1 explicitly for robustness, though test cases have N>=7.\n    if N == 1:\n        R_left_bnd = 0.5 * deltas[0] / k_cell[0]\n        R_right_bnd = 0.5 * deltas[0] / k_cell[0]\n        A[0, 0] = -(1 / R_left_bnd + 1 / R_right_bnd)\n        b[0] = -(T0 / R_left_bnd + TL / R_right_bnd)\n    else:\n        # First row (cell i=0)\n        C_L_bnd = 1 / (0.5 * deltas[0] / k_cell[0])\n        C_R_face = 1 / (0.5 * deltas[0] / k_cell[0] + 0.5 * deltas[1] / k_cell[1])\n        A[0, 0] = -(C_L_bnd + C_R_face)\n        A[0, 1] = C_R_face\n        b[0] = -C_L_bnd * T0\n        \n        # Internal rows (cell i=1 to N-2)\n        for i in range(1, N - 1):\n            C_W = 1 / (0.5 * deltas[i-1] / k_cell[i-1] + 0.5 * deltas[i] / k_cell[i])\n            C_E = 1 / (0.5 * deltas[i] / k_cell[i] + 0.5 * deltas[i+1] / k_cell[i+1])\n            A[i, i-1] = C_W\n            A[i, i]   = -(C_W + C_E)\n            A[i, i+1] = C_E\n        \n        # Last row (cell i=N-1)\n        C_W_face = 1 / (0.5 * deltas[N-2] / k_cell[N-2] + 0.5 * deltas[N-1] / k_cell[N-1])\n        C_R_bnd = 1 / (0.5 * deltas[N-1] / k_cell[N-1])\n        A[N-1, N-2] = C_W_face\n        A[N-1, N-1] = -(C_W_face + C_R_bnd)\n        b[N-1] = -C_R_bnd * TL\n    \n    # 5. Solve System for cell temperatures T_vec\n    T_vec = np.linalg.solve(A, b)\n\n    # 6. Calculate Numerical Flux at the left boundary\n    # Resistance from boundary x=0 to center of first cell\n    R_bc_left = 0.5 * deltas[0] / k_cell[0]\n    q_num = (T0 - T_vec[0]) / R_bc_left\n\n    # 7. Calculate and return absolute error\n    error = abs(q_num - q_exact)\n    return error\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2385950"}, {"introduction": "获得数值解后，我们如何评估其质量，甚至在不开发全新高阶格式的情况下提升其精度？本练习介绍了一种强大而优雅的技术——理查森外推法（Richardson extrapolation） [@problem_id:2385975]。通过结合在不同密度网格上计算出的数值解，该方法能够系统性地消除低阶误差项，从而以较小的计算代价获得更高阶的精确解。", "problem": "考虑单位区间上的一维泊松边界值问题：求一个足够光滑的函数 $u(x)$，使得对于 $x \\in (0,1)$，有 $-u''(x) = f(x)$，并满足狄利克雷边界条件 $u(0) = 0$ 和 $u(1) = 0$。采用一个具有 $N$ 个等长子区间的均匀网格，子区间长度为 $h = 1/N$，内部节点为 $x_i = i h$，其中 $i = 1,2,\\dots,N-1$。使用标准的二阶中心差分近似来表示二阶导数，推导用于近似具有 $N$ 个子区间的网格上内部节点处 $u(x)$ 的线性系统。然后，利用一个经过充分检验的事实：对于光滑解和光滑的 $f$，在固定内点上的点态有限差分误差可表示为 $h$ 的偶数次幂的渐近展开，形式为 $U_h(x_*) = u(x_*) + a h^2 + b h^4 + \\mathcal{O}(h^6)$，其中常数 $a$ 和 $b$ 与 $h$ 无关。基于此，构建一个理查森外推公式，以消除首项 $\\mathcal{O}(h^2)$ 误差项，从而在固定点 $x_*$ 处实现四阶精确近似。你的推导必须从中心差分定义开始，并且你的外推必须由所述的渐近误差展开来证明，不得假定任何其他未声明的性质。\n\n实现要求：\n- 分别在具有 $N$、 $2N$ 和 $4N$ 个均匀子区间的三个嵌套网格上求解离散泊松问题，每个网格都使用相同的二阶中心差分格式和相同的狄利克雷边界条件。\n- 选择一个点 $x_* = m/N$（其中 $m$ 为整数且 $1 \\le m \\le N-1$），使得 $x_*$ 是最粗糙网格上的一个内部节点，因此也是更精细网格上的节点（具体来说，在 $2N$ 和 $4N$ 网格上，其索引分别为 $2m$ 和 $4m$）。\n- 计算每个网格上的离散解，并提取节点值 $U_h(x_*)$、$U_{h/2}(x_*)$ 和 $U_{h/4}(x_*)$，其中 $h = 1/N$。\n- 使用你推导出的四阶理查森外推公式，利用两个最精细的网格（$2N$ 和 $4N$）构造 $u(x_*)$ 的四阶近似。报告绝对误差 $|U^{(4)}(x_*) - u(x_*)|$，其中 $U^{(4)}(x_*)$ 表示你在 $x_*$ 处的四阶近似值。\n- 所有三角函数求值必须使用弧度作为角度单位。\n\n测试套件：\n实现你的程序以运行以下三个独立的测试用例。对于每个用例，按照上述方法计算由 $2N$ 和 $4N$ 网格构成的四阶近似在 $x_*$ 处的绝对误差。\n- 用例 A（理想情况，光滑正弦函数）：$u(x) = \\sin(\\pi x)$，因此 $f(x) = \\pi^2 \\sin(\\pi x)$。使用 $N = 8$ 和 $x_* = 1/2$（即 $m = 4$）。\n- 用例 B（更高频率，内点非中点）：$u(x) = \\sin(3\\pi x)$，因此 $f(x) = 9\\pi^2 \\sin(3\\pi x)$。使用 $N = 10$ 和 $x_* = 3/10$（即 $m = 3$）。\n- 用例 C（多项式，精确性边界情况）：$u(x) = x(1-x)$，因此 $f(x) = 2$。使用 $N = 12$ 和 $x_* = 1/3$（即 $m = 4$）。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含用例 A、B 和 C 的三个绝对误差，按顺序排列，形式为用方括号括起来的逗号分隔列表。每个数字必须以科学记数法打印，小数点后保留 $12$ 位数字。例如，你的输出必须具有“[a,b,c]”的形式，其中 a、b 和 c 均使用小数点后有 $12$ 位数字的科学记数法格式打印。\n\n无需用户输入；所有参数均已在上面指定。不涉及物理单位。所有三角函数中的角度均为弧度。每个用例的最终数值答案是简单的浮点数。", "solution": "问题陈述经评估有效。这是一个计算工程领域的适定问题，具体关注偏微分方程的数值解。该问题具有科学依据，没有歧义，并包含了求解所需的所有必要信息。我们将按要求进行推导和实现。\n\n问题的主体是一维泊松边界值问题：\n$$\n-u''(x) = f(x) \\quad \\text{for } x \\in (0,1)\n$$\n并带有齐次狄利克雷边界条件 $u(0) = 0$ 和 $u(1) = 0$。\n\n首先，我们推导有限差分近似。我们将域 $[0,1]$ 离散化为 $N$ 个宽度为 $h = 1/N$ 的相等子区间。网格点为 $x_i = i h$，其中 $i = 0, 1, \\dots, N$。内部点为 $x_i$，其中 $i = 1, 2, \\dots, N-1$。令 $U_i$ 为精确解 $u(x_i)$ 在网格点 $x_i$ 处的数值近似。\n\n内部节点 $x_i$ 处的二阶导数 $u''(x_i)$ 使用二阶中心差分公式近似：\n$$\nu''(x_i) \\approx \\frac{u(x_{i-1}) - 2u(x_i) + u(x_{i+1})}{h^2} = \\frac{u((i-1)h) - 2u(ih) + u((i+1)h)}{h^2}\n$$\n将此式代入节点 $x_i$ 处的泊松方程，我们得到：\n$$\n-\\frac{U_{i-1} - 2U_i + U_{i+1}}{h^2} = f(x_i)\n$$\n此方程可以整理为：\n$$\n-U_{i-1} + 2U_i - U_{i+1} = h^2 f(x_i)\n$$\n此关系对每个内部节点 $i = 1, 2, \\dots, N-1$ 均成立。边界条件给出 $U_0 = u(0) = 0$ 和 $U_N = u(1) = 0$。\n\n将边界条件应用于 $i=1$ 和 $i=N-1$ 的方程：\n对于 $i=1$：$-U_0 + 2U_1 - U_2 = h^2 f(x_1)$，简化为 $2U_1 - U_2 = h^2 f(x_1)$。\n对于 $i=N-1$：$-U_{N-2} + 2U_{N-1} - U_N = h^2 f(x_{N-1})$，简化为 $-U_{N-2} + 2U_{N-1} = h^2 f(x_{N-1})$。\n\n这 $N-1$ 个线性方程可以写成矩阵形式 $A \\mathbf{U} = \\mathbf{b}$，其中 $\\mathbf{U} = [U_1, U_2, \\dots, U_{N-1}]^T$ 是未知节点值的向量。矩阵 $A$ 是一个 $(N-1) \\times (N-1)$ 的对称正定三对角矩阵：\n$$\nA = \\begin{pmatrix}\n2 & -1 & 0 & \\cdots & 0 \\\\\n-1 & 2 & -1 & \\cdots & 0 \\\\\n0 & -1 & 2 & \\ddots & \\vdots \\\\\n\\vdots & \\ddots & \\ddots & \\ddots & -1 \\\\\n0 & \\cdots & 0 & -1 & 2\n\\end{pmatrix}\n$$\n右端向量 $\\mathbf{b}$ 由下式给出：\n$$\n\\mathbf{b} = h^2 \\begin{pmatrix} f(x_1) \\\\ f(x_2) \\\\ \\vdots \\\\ f(x_{N-1}) \\end{pmatrix}\n$$\n求解此线性系统可得到内部网格点上的近似解 $\\mathbf{U}$。\n\n接下来，我们推导理查森外推公式。问题陈述指出，在固定点 $x_*$ 处的有限差分解 $U_h(x_*)$ 的误差具有以下渐近展开：\n$$\nU_h(x_*) = u(x_*) + a h^2 + b h^4 + \\mathcal{O}(h^6) \\quad (1)\n$$\n其中 $u(x_*)$ 是精确解，而 $a$ 和 $b$ 是与步长 $h$ 无关的常数。\n\n为了消除 $\\mathcal{O}(h^2)$ 阶的主导误差项，我们在一个更细的网格上计算解，其步长为 $h_2 = h/2$。在此网格上的解 $U_{h/2}(x_*)$ 具有以下展开式：\n$$\nU_{h/2}(x_*) = u(x_*) + a (h/2)^2 + b (h/2)^4 + \\mathcal{O}((h/2)^6)\n$$\n$$\nU_{h/2}(x_*) = u(x_*) + \\frac{1}{4} a h^2 + \\frac{1}{16} b h^4 + \\mathcal{O}(h^6) \\quad (2)\n$$\n我们寻求 $U_h(x_*)$ 和 $U_{h/2}(x_*)$ 的一个线性组合，以消去 $a h^2$ 项。将方程 $(2)$ 乘以 $4$ 并减去方程 $(1)$：\n$$\n4 U_{h/2}(x_*) - U_h(x_*) = 4\\left(u(x_*) + \\frac{1}{4} a h^2 + \\frac{1}{16} b h^4\\right) - \\left(u(x_*) + a h^2 + b h^4\\right) + \\mathcal{O}(h^6)\n$$\n$$\n4 U_{h/2}(x_*) - U_h(x_*) = (4-1)u(x_*) + (1-1)a h^2 + \\left(\\frac{4}{16}-1\\right)b h^4 + \\mathcal{O}(h^6)\n$$\n$$\n4 U_{h/2}(x_*) - U_h(x_*) = 3u(x_*) - \\frac{3}{4} b h^4 + \\mathcal{O}(h^6)\n$$\n对 $u(x_*)$ 求解，我们得到一个新的近似值，记为 $U^{(4)}(x_*)$：\n$$\nU^{(4)}(x_*) = \\frac{4 U_{h/2}(x_*) - U_h(x_*)}{3} = u(x_*) - \\frac{1}{4} b h^4 + \\mathcal{O}(h^6)\n$$\n这个外推值 $U^{(4)}(x_*)$ 是对 $u(x_*)$ 的一个四阶精确近似。问题要求使用 $2N$ 和 $4N$ 子区间网格的解来计算它。设 $h' = 1/(2N)$。那么这两个网格的步长分别为 $h'$ 和 $h'/2$。公式为：\n$$\nU^{(4)}(x_*) = \\frac{4 U_{1/(4N)}(x_*) - U_{1/(2N)}(x_*)}{3}\n$$\n\n实现将包含一个函数，对于给定的 $N$ 和 $f(x)$，该函数构建并求解线性系统 $A \\mathbf{U} = \\mathbf{b}$。对于每个测试用例，将对具有 $2N$ 和 $4N$ 子区间的网格调用此函数。将提取指定点 $x_*$ 处的节点值。$x_* = m/N$ 在具有 $k \\cdot N$ 个区间的网格上的索引是 $k \\cdot m$。对应的从0开始的数组索引是 $k \\cdot m - 1$。然后使用推导出的公式计算四阶近似，并确定其相对于已知精确解的绝对误差。\n\n对于用例 C，即 $u(x) = x(1-x)$，精确解是一个二次多项式。其四阶导数为零，即 $u^{(4)}(x) = 0$。中心差分格式的局部截断误差与 $h^2 u^{(4)}(x)$ 成正比，因此精确为零。因此，在机器浮点精度范围内，数值解 $U_i$ 将与节点处的精确解 $u(x_i)$ 完全相同。外推值也将是精确的，计算出的误差应接近于零。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve as solve_linear_system\n\ndef solve_poisson(N, f_func):\n    \"\"\"\n    Solves the 1D Poisson problem -u''=f on (0,1) with u(0)=u(1)=0\n    using a uniform grid with N subintervals.\n\n    Args:\n        N (int): The number of subintervals.\n        f_func (callable): The source function f(x).\n\n    Returns:\n        numpy.ndarray: The vector of numerical solutions at interior nodes.\n    \"\"\"\n    if N <= 1:\n        return np.array([])\n    \n    h = 1.0 / N\n    n_interior = N - 1\n    \n    # Construct the tridiagonal matrix A\n    A = 2 * np.eye(n_interior) - np.eye(n_interior, k=1) - np.eye(n_interior, k=-1)\n    \n    # Construct the right-hand side vector b\n    x_nodes = np.linspace(h, 1.0 - h, n_interior)\n    b = h**2 * f_func(x_nodes)\n    \n    # Solve the linear system AU = b\n    U = solve_linear_system(A, b)\n    \n    return U\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement\n    test_cases = [\n        {\n            'name': 'A',\n            'u_exact': lambda x: np.sin(np.pi * x),\n            'f': lambda x: np.pi**2 * np.sin(np.pi * x),\n            'N': 8,\n            'm': 4\n        },\n        {\n            'name': 'B',\n            'u_exact': lambda x: np.sin(3 * np.pi * x),\n            'f': lambda x: 9 * np.pi**2 * np.sin(3 * np.pi * x),\n            'N': 10,\n            'm': 3\n        },\n        {\n            'name': 'C',\n            'u_exact': lambda x: x * (1 - x),\n            'f': lambda x: 2.0 + 0*x,  # 0*x to ensure vectorization\n            'N': 12,\n            'm': 4\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N_base = case['N']\n        m = case['m']\n        f_func = case['f']\n        u_exact_func = case['u_exact']\n        \n        # Grid sizes for computation\n        N2 = 2 * N_base\n        N3 = 4 * N_base\n\n        # Solve the problem on the two finest grids\n        U2 = solve_poisson(N2, f_func)\n        U3 = solve_poisson(N3, f_func)\n        \n        # Identify the point of interest x_*\n        x_star = m / N_base\n        \n        # Extract nodal values at x_star\n        # The 0-based index for x_* on a grid k*N is k*m - 1\n        idx2 = 2 * m - 1\n        idx3 = 4 * m - 1\n        \n        u_N2_star = U2[idx2]\n        u_N3_star = U3[idx3]\n        \n        # Apply Richardson extrapolation\n        # U^(4) = (4*U_finer - U_coarser)/3\n        u_extrapolated = (4 * u_N3_star - u_N2_star) / 3.0\n        \n        # Calculate the exact solution at x_star\n        u_true = u_exact_func(x_star)\n        \n        # Calculate the absolute error\n        error = np.abs(u_extrapolated - u_true)\n        results.append(error)\n\n    # Format the final output as specified\n    formatted_results = [f\"{res:.12e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2385975"}]}