{"hands_on_practices": [{"introduction": "牛顿-科茨公式的一个核心概念是其“精度阶数”，即一个公式能够精确积分的多项式的最高次数。这个概念并非纯粹的理论抽象，它直接关系到我们为特定问题选择最有效数值方法的决策。通过这个练习[@problem_id:2419300]，我们将利用布尔法则（Boole's rule）来处理一个四次多项式，亲手验证高阶公式在特定条件下如何能够给出积分的精确解，而不仅仅是一个近似值。", "problem": "在计算模型中，一个标量响应函数在一个单元上由四次多项式 $f(x) = 2x^{4} - x^{3} + 3x^{2} - 5x + 1$ 在区间 $[0,4]$ 上精确表示。在整个区间 $[0,4]$ 上，使用单次应用的 $n=4$ 的闭式 Newton–Cotes 公式（Boole 法则），计算积分 $I = \\displaystyle \\int_{0}^{4} f(x)\\,dx$ 的值。报告精确值，无需四舍五入。", "solution": "对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- 待积函数为 $f(x) = 2x^{4} - x^{3} + 3x^{2} - 5x + 1$。\n- 积分区间为 $[0, 4]$。\n- 数值积分方法为单次应用的 $n=4$ 的闭式 Newton–Cotes 公式（Boole 法则）。\n- 任务是计算积分 $I = \\displaystyle \\int_{0}^{4} f(x)\\,dx$ 的精确值。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据。它要求将一个标准、定义明确的数值积分公式，即 Boole 法则，应用于一个多项式函数。该函数是一个 4 次多项式。闭式 $n$ 点 Newton-Cotes 公式的一个关键性质是其代数精度。对于偶数 $n$，该公式对所有次数不超过 $n+1$ 的多项式都是精确的。在本例中，$n=4$（偶数），所以代数精度为 $4+1 = 5$。由于给定函数是一个 4 次多项式，其次数小于等于 5，因此 Boole 法则将得到积分的精确值，而不是一个近似值。该问题是适定的，提供了所有必要信息，且没有矛盾或歧义。\n\n**步骤 3：结论与行动**\n问题有效。将提供完整的解答。\n\n对于区间 $[a, b]$ 上的积分，$n=4$ 的闭式 Newton–Cotes 公式（即 Boole 法则）由下式给出：\n$$ \\int_a^b f(x) \\, dx \\approx \\frac{b-a}{90} [7f(x_0) + 32f(x_1) + 12f(x_2) + 32f(x_3) + 7f(x_4)] $$\n这也可以用步长 $h = \\frac{b-a}{n}$ 来表示。当 $n=4$ 时，公式变为：\n$$ \\int_a^b f(x) \\, dx \\approx \\frac{4h}{90} [7f(x_0) + 32f(x_1) + 12f(x_2) + 32f(x_3) + 7f(x_4)] = \\frac{2h}{45} [7f(x_0) + 32f(x_1) + 12f(x_2) + 32f(x_3) + 7f(x_4)] $$\n其中求值点为 $x_i = a + ih$，对于 $i=0, 1, 2, 3, 4$。\n\n对于这个具体问题，我们有：\n- 区间 $[a, b] = [0, 4]$。\n- 子区间数 $n=4$。\n- 步长为 $h = \\frac{b-a}{n} = \\frac{4-0}{4} = 1$。\n\n五个等距点是：\n- $x_0 = a + 0h = 0 + 0(1) = 0$\n- $x_1 = a + 1h = 0 + 1(1) = 1$\n- $x_2 = a + 2h = 0 + 2(1) = 2$\n- $x_3 = a + 3h = 0 + 3(1) = 3$\n- $x_4 = a + 4h = 0 + 4(1) = 4$\n\n接下来，我们在这些点上计算函数 $f(x) = 2x^{4} - x^{3} + 3x^{2} - 5x + 1$ 的值：\n- $f(x_0) = f(0) = 2(0)^{4} - (0)^{3} + 3(0)^{2} - 5(0) + 1 = 1$\n- $f(x_1) = f(1) = 2(1)^{4} - (1)^{3} + 3(1)^{2} - 5(1) + 1 = 2 - 1 + 3 - 5 + 1 = 0$\n- $f(x_2) = f(2) = 2(2)^{4} - (2)^{3} + 3(2)^{2} - 5(2) + 1 = 2(16) - 8 + 3(4) - 10 + 1 = 32 - 8 + 12 - 10 + 1 = 27$\n- $f(x_3) = f(3) = 2(3)^{4} - (3)^{3} + 3(3)^{2} - 5(3) + 1 = 2(81) - 27 + 3(9) - 15 + 1 = 162 - 27 + 27 - 15 + 1 = 148$\n- $f(x_4) = f(4) = 2(4)^{4} - (4)^{3} + 3(4)^{2} - 5(4) + 1 = 2(256) - 64 + 3(16) - 20 + 1 = 512 - 64 + 48 - 20 + 1 = 477$\n\n现在，将这些值代入 Boole 法则：\n$$ I = \\frac{2(1)}{45} [7f(0) + 32f(1) + 12f(2) + 32f(3) + 7f(4)] $$\n$$ I = \\frac{2}{45} [7(1) + 32(0) + 12(27) + 32(148) + 7(477)] $$\n$$ I = \\frac{2}{45} [7 + 0 + 324 + 4736 + 3339] $$\n括号内的和为：\n$$ 7 + 324 + 4736 + 3339 = 331 + 4736 + 3339 = 5067 + 3339 = 8406 $$\n将此和代回到 $I$ 的表达式中：\n$$ I = \\frac{2}{45} (8406) = \\frac{16812}{45} $$\n为了化简该分数，我们注意到分子的各位数字之和为 $1+6+8+1+2=18$，可以被 $9$ 整除。分母 $45$ 也可以被 $9$ 整除。\n$$ I = \\frac{16812 \\div 9}{45 \\div 9} = \\frac{1868}{5} $$\n如前所述，这个结果是精确的。为了完整起见，我们通过直接解析积分来验证此结果：\n$$ \\int_{0}^{4} (2x^{4} - x^{3} + 3x^{2} - 5x + 1) \\,dx = \\left[ \\frac{2x^{5}}{5} - \\frac{x^{4}}{4} + \\frac{3x^{3}}{3} - \\frac{5x^{2}}{2} + x \\right]_{0}^{4} $$\n$$ = \\left[ \\frac{2}{5}x^{5} - \\frac{1}{4}x^{4} + x^{3} - \\frac{5}{2}x^{2} + x \\right]_{0}^{4} $$\n$$ = \\left( \\frac{2}{5}(4)^{5} - \\frac{1}{4}(4)^{4} + (4)^{3} - \\frac{5}{2}(4)^{2} + 4 \\right) - (0) $$\n$$ = \\frac{2}{5}(1024) - \\frac{1}{4}(256) + 64 - \\frac{5}{2}(16) + 4 $$\n$$ = \\frac{2048}{5} - 64 + 64 - 40 + 4 $$\n$$ = \\frac{2048}{5} - 36 $$\n$$ = \\frac{2048}{5} - \\frac{180}{5} = \\frac{1868}{5} $$\n解析结果证实了通过 Boole 法则得到的值。所求值为 $\\frac{1868}{5}$。", "answer": "$$\\boxed{\\frac{1868}{5}}$$", "id": "2419300"}, {"introduction": "在工程和科学计算中，我们通常无法得到精确解，因此控制和量化误差至关重要。理论误差界限公式为我们提供了一个强有力的工具，用以预估为达到特定精度要求所需的计算量。本练习[@problem_id:2419302]将理论付诸实践，要求你确定使用辛普森3/8法则（Simpson's 3/8 rule）时，为保证积分误差低于一个给定阈值所需的最小子区间数$n$，这是数值任务规划中的一项基本技能。", "problem": "一个阶数为$3$的闭合牛顿-柯特斯(Newton–Cotes)公式，即复化辛普森(Simpson)3/8法则，将用于等距子区间来近似计算定积分\n$$\n\\int_{0}^{\\pi} \\sin(x)\\,dx,\n$$\n其中$x$的单位是弧度。设$n$表示子区间的数量，步长为$h = (\\pi - 0)/n$。对于此数值积分，$n$必须是$3$的整数倍。确定能保证复化辛普森3/8法则近似的绝对误差严格小于$10^{-6}$的最小$n$值。以整数形式给出$n$的值。", "solution": "首先将对问题的科学性、适定性和客观性进行验证。\n\n**第1步：提取已知条件**\n- 使用的公式：复化辛普森3/8法则，一个阶数为$3$的闭合牛顿-柯特斯公式。\n- 待近似的积分：$\\int_{0}^{\\pi} \\sin(x)\\,dx$。\n- 变量$n$：子区间数量。\n- 步长$h$：$h = (\\pi - 0)/n = \\pi/n$。\n- 对$n$的约束：$n$必须是3的整数倍。\n- 误差条件：绝对误差必须严格小于$10^{-6}$。\n- 目标：确定满足给定条件的最小整数$n$。\n\n**第2步：使用提取的已知条件进行验证**\n该问题是数值分析中的一个标准练习，数值分析是计算工程和应用数学的一个子领域。\n- **科学依据**：该问题基于已确立的数学原理，特别是牛顿-柯特斯公式的数值积分理论和误差分析。所有概念，包括正弦函数的积分和辛普森法则，在事实上都是正确的。\n- **适定性**：问题定义清晰。它要求满足由特定数值方法的误差界导出的精确不等式的最小整数$n$。这样的问题有唯一、稳定且有意义的解。\n- **客观性**：问题以精确、无歧义的数学语言陈述。没有主观或基于观点的陈述。\n- **完整性与一致性**：问题提供了所有必要信息：函数、积分区间、数值方法、误差容限以及对参数$n$的所有约束。没有矛盾之处。\n\n**第3步：结论与行动**\n该问题被判定为**有效**。现在将提供一个严谨的解答。\n\n对于在区间$[a, b]$上使用$n$个子区间（其中$n$是3的倍数）对函数$f(x)$应用复化辛普森3/8法则，其误差项$E_n$由以下公式给出：\n$$\nE_n = -\\frac{(b-a)^5}{80 n^4} f^{(4)}(\\xi)\n$$\n其中$\\xi$是开区间$(a, b)$内的某个值。\n\n在本题中，我们已知：\n- 函数 $f(x) = \\sin(x)$。\n- 积分区间 $[a, b] = [0, \\pi]$。\n\n首先，我们必须计算$f(x)$的四阶导数：\n$$\nf(x) = \\sin(x)\n$$\n$$\nf'(x) = \\cos(x)\n$$\n$$\nf''(x) = -\\sin(x)\n$$\n$$\nf'''(x) = -\\cos(x)\n$$\n$$\nf^{(4)}(x) = \\sin(x)\n$$\n将这些部分代入误差公式，得到绝对误差$|E_n|$的表达式：\n$$\n|E_n| = \\left| -\\frac{(\\pi - 0)^5}{80 n^4} \\sin(\\xi) \\right| = \\frac{\\pi^5}{80 n^4} |\\sin(\\xi)|\n$$\n其中 $\\xi \\in (0, \\pi)$。\n\n为保证误差小于指定的容限，我们必须找到$|E_n|$的一个上界。这需要求出$|f^{(4)}(\\xi)| = |\\sin(\\xi)|$在积分区间上的最大值。对于$\\xi \\in [0, \\pi]$，函数$\\sin(\\xi)$是非负的，所以$|\\sin(\\xi)| = \\sin(\\xi)$。在$[0, \\pi]$上，$\\sin(\\xi)$的最大值是$1$，在$\\xi = \\frac{\\pi}{2}$处取得。\n因此，绝对误差的一个上界是：\n$$\n|E_n| \\le \\frac{\\pi^5}{80 n^4} \\max_{\\xi \\in [0, \\pi]}|\\sin(\\xi)| = \\frac{\\pi^5}{80 n^4}\n$$\n题目要求绝对误差严格小于$10^{-6}$。我们将此条件施加于我们导出的上界：\n$$\n\\frac{\\pi^5}{80 n^4} < 10^{-6}\n$$\n我们现在对这个不等式求解整数$n$。\n$$\nn^4 > \\frac{\\pi^5}{80} \\times 10^6\n$$\n对两边取四次方根，得到：\n$$\nn > \\left( \\frac{\\pi^5 \\times 10^6}{80} \\right)^{1/4}\n$$\n计算右侧表达式的值，我们得到：\n$$\nn > (3825246.03...)^{1/4}\n$$\n$$\nn > 44.2235...\n$$\n题目规定$n$必须是整数，且必须是3的倍数。\n根据不等式$n > 44.2235...$，$n$的最小整数值为$45$。我们必须验证这个整数是否满足第二个条件。数字$45$是$3$的倍数，因为$45 = 3 \\times 15$。\n由于$45$是大于$44.2235...$的最小整数，并且它也是$3$的倍数，因此它是保证指定精度所需的最小子区间数。任何更小的3的倍数，例如$n=42$，都会导致误差界大于或等于$10^{-6}$。\n\n因此，最小子区间数$n$是$45$。", "answer": "$$\n\\boxed{45}\n$$", "id": "2419302"}, {"introduction": "理论告诉我们，当我们增加子区间数量时，数值积分的误差会以特定速率下降，这个速率被称为“收敛阶”。通过编程实现来经验性地验证这一理论，是加深理解的绝佳方式。在这个实践中[@problem_id:2419339]，你将通过编写复合辛普森法则的程序来计算圆周率$\\pi$的近似值，并分析随着子区间数量的增加，计算误差是如何减小的，从而直观地观察到该方法的四阶收敛特性。", "problem": "本题要求您通过一个详细指定的计算任务，来研究使用闭合型Newton–Cotes公式的数值积分方法。令 $I$ 表示定积分\n$$\nI \\;=\\; \\int_{0}^{1} \\frac{4}{1+x^{2}}\\,dx,\n$$\n此积分值为 $\\pi$，可通过 $\\frac{4}{1+x^{2}}$ 的反导数求得。使用$2$次闭合型Newton–Cotes公式（即复合Simpson法则）将区间划分为 $N$ 个等宽子区间（其中 $N$ 为偶数），计算 $I$ 的近似值 $S_{N}$，并量化其精度。对于每个给定的 $N$，计算绝对误差 $E_{N} = \\lvert S_{N} - \\pi \\rvert$。对于测试集中的每对连续的 $\\left(N_{k},N_{k+1}\\right)$，计算观测收敛阶\n$$\np_{k} \\;=\\; \\log_{2}\\!\\left(\\frac{E_{N_{k}}}{E_{N_{k+1}}}\\right),\n$$\n该阶数量化了当区间从 $N_{k}$ 细化到 $N_{k+1}$ 时误差的变化情况。\n\n测试集：\n- 使用以下子区间数量 $N$ 的值：$\\{2,4,8,16,32,64\\}$。该集合包含了最小的允许偶数情况 $N=2$，几次连续的2倍细化，以及一个中等精细的分辨率。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，包含一个嵌套的、逗号分隔的列表，不含空格，格式为\n$[ [S_{N_{1}},S_{N_{2}},\\dots], [E_{N_{1}},E_{N_{2}},\\dots], [p_{1},p_{2},\\dots] ]$，\n即一个包含三个列表的列表：按测试集顺序排列的近似值 $S_{N}$、按相同顺序排列的相应绝对误差 $E_{N}$，以及测试集中每对连续 $(N_{k},N_{k+1})$ 的观测阶 $p_{k}$。因此，第三个列表比前两个列表少一个条目。例如，其语法形式（而非数值）为\n\"[[S_{1},S_{2},\\dots],[E_{1},E_{2},\\dots],[p_{1},p_{2},\\dots]]\"\n该行中任何地方都没有空格。\n\n所有答案都是纯数（无量纲实数）。不使用角度，也不涉及物理单位。程序必须是自包含的，且不需要任何输入。", "solution": "问题陈述已经过验证，被认为是适定的、有科学依据且无歧义的。这是数值分析中的一个标准练习。我们将着手进行求解。\n\n任务是使用复合Simpson法则对一系列划分来近似定积分\n$$\nI = \\int_{0}^{1} f(x) \\,dx \\quad \\text{其中} \\quad f(x) = \\frac{4}{1+x^2}\n$$\n并分析近似的收敛性。已知该积分的精确值为 $I = \\pi$。\n\n复合Simpson法则是2次闭合型Newton-Cotes公式，它通过将积分区间 $[a, b]$ 划分为 $N$ 个等宽子区间（$N$为偶数，宽度为 $h = (b-a)/N$）来近似积分。其公式为：\n$$\nS_N = \\frac{h}{3} \\left[ f(x_0) + 4\\sum_{i=1, i \\text{ odd}}^{N-1} f(x_i) + 2\\sum_{i=2, i \\text{ even}}^{N-2} f(x_i) + f(x_N) \\right]\n$$\n其中 $x_i = a + ih$，$i = 0, 1, \\dots, N$。对于本问题，积分区间是 $[0, 1]$，因此 $a=0$，$b=1$，步长为 $h=1/N$。求值点或节点为 $x_i = i/N$。\n\n对于给定的 $N$，此近似的精度由绝对误差衡量，定义为：\n$$\nE_N = \\lvert S_N - \\pi \\rvert\n$$\n\n为量化当 $N$ 增加时收敛的速度，我们对测试集 $\\{2, 4, 8, 16, 32, 64\\}$ 中每一对连续的子区间数 $(N_k, N_{k+1})$ 计算观测收敛阶 $p_k$。该度量的公式为：\n$$\np_{k} = \\log_{2}\\!\\left(\\frac{E_{N_{k}}}{E_{N_{k+1}}}\\right)\n$$\n该计算与特定的细化策略相关，即每一步将子区间数量加倍，即 $N_{k+1} = 2N_k$。\n\n对于一个足够光滑的函数，复合Simpson法则的误差由Euler-Maclaurin公式的主项给出，即：\n$$\nI - S_N = -\\frac{(b-a)h^4}{180} f^{(4)}(\\xi)\n$$\n对于某个 $\\xi \\in (a,b)$。这意味着误差依赖关系为 $E_N \\propto h^4$，或等价地，$E_N \\propto N^{-4}$。当我们将子区间数量加倍，使得 $N_{k+1} = 2N_k$ 时，步长减半，即 $h_{k+1} = h_k/2$。因此，随着 $N \\to \\infty$，连续误差之比预期会趋近一个常数：\n$$\n\\frac{E_{N_k}}{E_{N_{k+1}}} \\approx \\frac{C \\cdot h_k^4}{C \\cdot (h_k/2)^4} = 2^4 = 16\n$$\n因此，理论收敛阶为 $p = \\log_2(16) = 4$。随着 $N$ 变大且渐进行为误差占主导，计算出的 $p_k$ 值预计将趋近于4。对于较小的 $N$，预期会出现与此值的偏差，这是由于高阶误差项的影响以及四阶导数 $f^{(4)}(x)$ 在区间 $[0, 1]$ 上的非恒定性。\n\n计算步骤如下：\n1. 定义被积函数 $f(x) = \\frac{4}{1+x^2}$。\n2. 对于集合 $\\{2, 4, 8, 16, 32, 64\\}$ 中的每个子区间数 $N$：\n   a. 计算步长 $h = 1/N$。\n   b. 生成节点 $x_i = i \\cdot h$，$i=0, \\dots, N$。\n   c. 在所有节点上计算 $f(x_i)$ 的值。\n   d. 使用复合Simpson法则公式计算总和 $S_N$。\n   e. 使用数值库提供的高精度 $\\pi$ 值，计算绝对误差 $E_N = |S_N - \\pi|$。\n3. 存储计算出的值序列 $\\{S_N\\}$ 和 $\\{E_N\\}$。\n4. 使用序列 $\\{E_N\\}$，计算观测阶序列 $\\{p_k\\}$，$k=1, \\dots, 5$。\n5. 最终结果将按照问题陈述中的规定，以一个包含这三个数值序列的嵌套列表形式呈现。解决方案的形式化设计到此结束。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes an approximation of pi using the composite Simpson's rule\n    and analyzes its convergence properties.\n    \"\"\"\n    # Define the set of subinterval counts for the test suite.\n    subinterval_counts = [2, 4, 8, 16, 32, 64]\n\n    # The exact value of the integral is pi. Use numpy's high-precision value.\n    pi_exact = np.pi\n\n    # Define the integrand function f(x) = 4 / (1 + x^2).\n    def f(x):\n        return 4.0 / (1.0 + x**2)\n\n    # Lists to store the results: approximations, errors, and convergence orders.\n    approximations = []\n    errors = []\n    \n    # Iterate through each specified number of subintervals N.\n    for N in subinterval_counts:\n        # The integration interval is [0, 1].\n        a, b = 0.0, 1.0\n        \n        # Calculate the step size h.\n        h = (b - a) / N\n        \n        # Generate N+1 equally spaced nodes from a to b.\n        x_nodes = np.linspace(a, b, N + 1)\n        \n        # Evaluate the function at the nodes.\n        y_values = f(x_nodes)\n        \n        # Apply the composite Simpson's rule formula:\n        # S_N = (h/3) * [f(x_0) + 4*f(x_1) + 2*f(x_2) + ... + f(x_N)]\n        # The sum is structured as: y[0] + y[-1] + 4*sum(odd_indices) + 2*sum(even_indices)\n        s_approx = (h / 3.0) * (\n            y_values[0] \n            + y_values[-1] \n            + 4.0 * np.sum(y_values[1:-1:2]) \n            + 2.0 * np.sum(y_values[2:-1:2])\n        )\n        \n        # Store the computed approximation.\n        approximations.append(s_approx)\n        \n        # Calculate the absolute error and store it.\n        error = np.abs(s_approx - pi_exact)\n        errors.append(error)\n\n    # Compute the observed convergence orders for successive pairs of errors.\n    # The list of orders will have one fewer element than the lists of errors/approximations.\n    orders = []\n    for k in range(len(errors) - 1):\n        # p_k = log2(E_{N_k} / E_{N_{k+1}})\n        order = np.log2(errors[k] / errors[k+1])\n        orders.append(order)\n\n    # Format the results into the required single-line string format.\n    # e.g., \"[[S1,S2,...],[E1,E2,...],[p1,p2,...]]\" with no spaces.\n    s_str = \",\".join(map(str, approximations))\n    e_str = \",\".join(map(str, errors))\n    p_str = \",\".join(map(str, orders))\n    \n    final_output = f\"[[{s_str}],[{e_str}],[{p_str}]]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2419339"}]}