{"hands_on_practices": [{"introduction": "我们通常将有限差分看作是一种逐点进行的局部计算。但是，如果我们把整个网格上的求导运算看作一个整体呢？这个练习将向您介绍微分矩阵 $D$ 这一强大概念，它将微分算子表示为作用于网格值向量的线性变换。通过为周期性区域构建这个矩阵并检验其特征值，您将对数值微分的结构特性及其与线性代数和傅里叶分析的联系有更深刻的理解 [@problem_id:2418819]。", "problem": "考虑一个长度为 $L$ 的一维域上的均匀周期网格，其上有 $N$ 个网格点，位置为 $x_j = jh$，其中 $j \\in \\{0,1,\\ldots,N-1\\}$，网格间距为 $h = L/N$。定义作用于网格函数 $\\mathbf{u} = (u_0,\\ldots,u_{N-1})^\\top$ 上的离散一阶导数算子 $D$ 为以下反对称最近邻线性形式\n$$(D\\mathbf{u})_j = \\frac{u_{j+1} - u_{j-1}}{2h},$$\n其中，下标按模 $N$ 解释以强制执行周期性，即 $u_{-1} \\equiv u_{N-1}$ 且 $u_{N} \\equiv u_{0}$。这定义了一个具有周期性边界条件的 $N \\times N$ 实矩阵 $D$。\n\n任务：对于下面列出的每个测试用例 $(N,L)$，构造如上定义的矩阵 $D$，计算其所有特征值，并返回这些特征值的虚部。\n\n测试集（每对为 $(N,L)$，其中 $L$ 无单位）：\n- 用例 $1$：$(N,L) = (2, 1)$。\n- 用例 $2$：$(N,L) = (3, 2\\pi)$。\n- 用例 $3$：$(N,L) = (5, 1)$。\n- 用例 $4$：$(N,L) = (8, 2)$。\n\n答案规格：\n- 对于每个测试用例，输出一个列表，其中包含 $D$ 的所有 $N$ 个特征值的虚部，并按非递减顺序排序。\n- 将每个值四舍五入到 $12$ 位小数。\n- 将所有测试用例的结果汇总到一个列表的列表中。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的列表的列表（例如，“[[a_1,a_2,\\ldots,a_N],[b_1,b_2,\\ldots,b_N],\\ldots]”），其中每个内部列表按上面列出的顺序对应一个测试用例。", "solution": "该问题要求计算均匀周期网格上离散一阶导数算子的特征值。问题陈述的有效性得到了证实，因为它在数值分析方面有科学依据，是适定且客观的。\n\n算子 $D$ 近似于一阶导数 $\\frac{d}{dx}$，由二阶中心差分公式定义：\n$$ (D\\mathbf{u})_j = \\frac{u_{j+1} - u_{j-1}}{2h} $$\n此处，$\\mathbf{u} = (u_0, u_1, \\ldots, u_{N-1})^\\top$ 是一个向量，表示一个函数在 $N$ 个网格点 $x_j = jh$（其中 $j \\in \\{0, 1, \\ldots, N-1\\}$）上的取值。网格间距为 $h=L/N$，$L$ 是域的长度。下标是周期性的，即 $u_{N} \\equiv u_0$ 且 $u_{-1} \\equiv u_{N-1}$。\n\n这个线性算子可以由一个 $N \\times N$ 矩阵 $D$ 表示。该矩阵的元素 $D_{jk}$ 由 $(D\\mathbf{u})_j$ 表达式中 $u_k$ 的系数确定。根据公式，第 $j$ 行中唯一的非零元素是：\n$$ D_{j, (j+1) \\pmod N} = \\frac{1}{2h} $$\n$$ D_{j, (j-1) \\pmod N} = -\\frac{1}{2h} $$\n得到的矩阵 $D$ 是一个实的、稀疏的循环矩阵。它也是反对称的，即 $D^\\top = -D$。实反对称矩阵的一个基本性质是其特征值为纯虚数。这与连续算子 $\\frac{d}{dx}$ 在周期域上的特征值为 $i k$（其中 $k$ 为波数）这一事实相符。\n\n任务是为几对 $(N, L)$ 找出该矩阵 $D$ 的特征值。对于给定的 $N$ 和 $L$，首先构造矩阵 $D$。然后，使用标准的数值算法计算其 $N$ 个特征值 $\\lambda_k$。根据理论，这些特征值将是纯虚数，因此其实部为零（或由于浮点误差，在数值上是一个非常小的数）。问题要求我们提取这些特征值的虚部。\n\n特征值的解析解是已知的，可用于理论验证：\n$$ \\lambda_k = i \\frac{N}{L} \\sin\\left(\\frac{2\\pi k}{N}\\right) \\quad \\text{for } k \\in \\{0, 1, \\ldots, N-1\\} $$\n因此，虚部为 $\\text{Im}(\\lambda_k) = \\frac{N}{L} \\sin\\left(\\frac{2\\pi k}{N}\\right)$。该公式证实了特征值是纯虚数，并为数值计算过程的验证提供了期望值。对于 $N=2$ 的特殊情况，在模 $2$ 运算下，模板点 $j+1$ 和 $j-1$ 变得相同，导致分子 $u_{j+1} - u_{j-1}$ 为零。因此，对于 $N=2$，矩阵 $D$ 是零矩阵，其特征值均为 $0$。解析公式正确地预测了这一点，因为当 $k$ 为整数时，$\\sin(\\pi k) = 0$。\n\n每个测试用例 $(N, L)$ 的计算流程如下：\n$1$. 计算网格间距 $h = L/N$。\n$2$. 构造 $N \\times N$ 矩阵 $D$。对于 $N>2$，这是一个带状矩阵，其非零元素位于第一上对角线和下对角线上，以及由于周期性而产生的角元素。对于 $N \\le 2$，它是零矩阵。\n$3$. 使用数值库函数（如 `numpy.linalg.eigvals`）计算 $D$ 的特征值。\n$4$. 提取每个特征值的虚部。\n$5$. 将虚部列表按非递减顺序排序。\n$6$. 将排序后列表中的每个值四舍五入到 $12$ 位小数。\n\n此流程被系统地应用于每个测试用例，并将结果列表汇总成一个最终的列表的列表用于输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all specified test cases.\n    Constructs the differentiation matrix, computes its eigenvalues,\n    and formats the imaginary parts as required.\n    \"\"\"\n\n    def construct_differentiation_matrix(N, L):\n        \"\"\"\n        Constructs the N x N differentiation matrix D for a domain of length L.\n\n        Args:\n            N (int): The number of grid points.\n            L (float): The length of the periodic domain.\n\n        Returns:\n            numpy.ndarray: The N x N matrix D.\n        \"\"\"\n        if N <= 2:\n            # For N=2, j+1 and j-1 are the same point modulo 2, so D is the zero matrix.\n            # This also handles trivial cases N=0, 1.\n            return np.zeros((N, N))\n\n        h = L / N\n        c = 1.0 / (2.0 * h)\n        \n        # Diagonal for u_{j+1} term\n        diag_p1 = c * np.ones(N - 1)\n        # Diagonal for u_{j-1} term\n        diag_m1 = -c * np.ones(N - 1)\n        \n        D = np.diag(diag_p1, k=1) + np.diag(diag_m1, k=-1)\n        \n        # Add corner elements for periodic boundary conditions\n        D[0, N - 1] = -c  # u_{-1} term for j=0 is u_{N-1}\n        D[N - 1, 0] = c   # u_{N} term for j=N-1 is u_{0}\n        \n        return D\n\n    def solve_case(params):\n        \"\"\"\n        Computes the imaginary parts of the eigenvalues for a single test case.\n\n        Args:\n            params (tuple): A tuple (N, L) defining the test case.\n\n        Returns:\n            list: A sorted list of the imaginary parts of the eigenvalues,\n                  rounded to 12 decimal places.\n        \"\"\"\n        N, L = params\n        D_matrix = construct_differentiation_matrix(N, L)\n        \n        # Compute eigenvalues\n        eigenvalues = np.linalg.eigvals(D_matrix)\n        \n        # Extract imaginary parts. Due to the matrix being real and skew-symmetric,\n        # eigenvalues are purely imaginary. Numerical computation might yield\n        # negligible real parts, which are discarded.\n        imag_parts = np.imag(eigenvalues)\n        \n        # Sort in nondecreasing order\n        sorted_imag_parts = np.sort(imag_parts)\n        \n        # Round to 12 decimal places\n        rounded_parts = np.round(sorted_imag_parts, 12)\n        \n        return rounded_parts.tolist()\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (2, 1.0),\n        (3, 2 * np.pi),\n        (5, 1.0),\n        (8, 2.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case)\n        results.append(result)\n\n    def format_list_no_spaces(lst):\n        \"\"\"Formats a list into a string like '[item1,item2]' without spaces.\"\"\"\n        return '[' + ','.join(map(str, lst)) + ']'\n\n    # Final print statement in the exact required format.\n    # The output format must be a list of lists with no spaces, e.g., [[1,2],[3,4]].\n    # The default str(list) adds spaces, so we build the string manually.\n    results_as_strings = [format_list_no_spaces(res) for res in results]\n    final_output_string = '[' + ','.join(results_as_strings) + ']'\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "2418819"}, {"introduction": "在使用有限差分时，一个很自然的想法是让步长 $h$ 尽可能小以获得更高的精度。然而，这总是正确的吗？本实践将引导您进行一个数值实验，以探究截断误差（随 $h$ 减小而减小）与舍入误差（随 $h$ 减小而增大）之间的权衡关系 [@problem_id:2418870]。您将发现标准有限差分方法的实际局限性，并探索一种非常巧妙且稳健的技术——复步长法，它能有效避免相减抵消问题，从而达到接近机器精度的准确性。", "problem": "考虑使用实数步长 $h \\gt 0$ 对一个足够光滑的实值函数 $f$ 在实数点 $x$ 处的导数进行三种数值近似：\n1) 前向有限差分 $D_{\\mathrm{fwd}}(f,x,h) = \\dfrac{f(x+h) - f(x)}{h}$。\n2) 中心有限差分 $D_{\\mathrm{ctr}}(f,x,h) = \\dfrac{f(x+h) - f(x-h)}{2h}$。\n3) 复步近似 $D_{\\mathrm{cs}}(f,x,h) = \\dfrac{\\operatorname{Im}\\!\\left[f(x + i h)\\right]}{h}$，其中 $\\operatorname{Im}[\\cdot]$ 表示虚部，且 $i^2 = -1$。\n\n对于以下每个测试用例，令 $E_{\\mathrm{method}}(h) = \\left|D_{\\mathrm{method}}(f,x_0,h) - f'(x_0)\\right|$ 表示指定方法在步长为 $h$ 时的绝对误差。三角函数的角度必须以弧度为单位进行解释。对于每个测试用例，计算每种方法在离散步长集合 $\\mathcal{H} = \\{10^{-k} : k \\in \\{1,2,\\dots,16\\}\\}$ 上的最小绝对误差。\n\n测试套件：\n- 测试用例 1：$f(x) = e^{x}$，$f'(x) = e^{x}$，$x_0 = 1.0$。\n- 测试用例 2：$f(x) = \\sin(x)$，$f'(x) = \\cos(x)$，$x_0 = 1.0$。\n- 测试用例 3：$f(x) = \\cos(x)$，$f'(x) = -\\sin(x)$，$x_0 = 0.0$。\n\n对于每个测试用例，你的程序必须返回列表 $\\left[\\min_{h \\in \\mathcal{H}} E_{\\mathrm{fwd}}(h),\\, \\min_{h \\in \\mathcal{H}} E_{\\mathrm{ctr}}(h),\\, \\min_{h \\in \\mathcal{H}} E_{\\mathrm{cs}}(h)\\right]$。将所有测试用例的结果按上述顺序聚合到一个列表中。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个逗号分隔的列表，列表用方括号括起来，其中每个测试用例由一个包含三个浮点数的列表表示，这些浮点数采用12位有效数字的科学记数法，即 $[\\text{case}_1,\\text{case}_2,\\text{case}_3]$，其中 $\\text{case}_j = [E_{\\mathrm{fwd}},E_{\\mathrm{ctr}},E_{\\mathrm{cs}}]$。行内任何位置均不允许有多余的空格。", "solution": "该问题陈述清晰，是良置的、计算上可行的，并且在科学上是合理的。它代表了数值分析中的一个标准练习，涉及数值微分中截断误差和舍入误差之间的权衡。我们将采用系统化的方法进行求解。\n\n目标是通过在一组给定的离散步长中找到使绝对误差最小化的最佳步长 $h$，来比较三种数值微分方法的精度。此分析揭示了在使用有限精度算术进行数值计算时两种主要误差来源之间的根本冲突：截断误差和舍入误差。\n\n**1. 数值微分误差的理论基础**\n\n数值导数近似的总绝对误差 $E(h)$ 是截断误差和舍入误差的量值之和。\n\n*   **截断误差**：这是一种固有的数学误差，源于使用有限步长 $h$ 来近似微分算子。对于一个足够光滑的函数 $f(x)$，可以使用泰勒级数展开来量化它。\n\n    *   对于**前向有限差分** $D_{\\mathrm{fwd}}(f,x,h)$，$f(x+h)$ 在 $x$ 附近的泰勒展开为：\n        $$f(x+h) = f(x) + hf'(x) + \\frac{h^2}{2}f''(x) + \\mathcal{O}(h^3)$$\n        整理以求解 $f'(x)$：\n        $$f'(x) = \\frac{f(x+h) - f(x)}{h} - \\frac{h}{2}f''(x) - \\mathcal{O}(h^2)$$\n        $D_{\\mathrm{fwd}}$ 的公式与右侧的第一项匹配。因此，截断误差的主项为 $E_{T, \\mathrm{fwd}} \\approx -\\frac{h}{2}f''(x)$。该方法为一阶精度，误差阶为 $\\mathcal{O}(h)$。\n\n    *   对于**中心有限差分** $D_{\\mathrm{ctr}}(f,x,h)$，我们使用两个泰勒展开：\n        $$f(x+h) = f(x) + hf'(x) + \\frac{h^2}{2}f''(x) + \\frac{h^3}{6}f'''(x) + \\mathcal{O}(h^4)$$\n        $$f(x-h) = f(x) - hf'(x) + \\frac{h^2}{2}f''(x) - \\frac{h^3}{6}f'''(x) + \\mathcal{O}(h^4)$$\n        用第一个方程减去第二个方程得到：\n        $$f(x+h) - f(x-h) = 2hf'(x) + \\frac{h^3}{3}f'''(x) + \\mathcal{O}(h^5)$$\n        整理以求解 $f'(x)$：\n        $$f'(x) = \\frac{f(x+h) - f(x-h)}{2h} - \\frac{h^2}{6}f'''(x) - \\mathcal{O}(h^4)$$\n        截断误差的主项为 $E_{T, \\mathrm{ctr}} \\approx -\\frac{h^2}{6}f'''(x)$。该方法为二阶精度，误差阶为 $\\mathcal{O}(h^2)$。\n\n    *   对于**复步近似** $D_{\\mathrm{cs}}(f,x,h)$，我们假设 $f$ 是解析函数，并考虑其对复自变量 $x+ih$ 的泰勒级数：\n        $$f(x+ih) = f(x) + (ih)f'(x) + \\frac{(ih)^2}{2!}f''(x) + \\frac{(ih)^3}{3!}f'''(x) + \\mathcal{O}(h^4)$$\n        $$f(x+ih) = \\left(f(x) - \\frac{h^2}{2}f''(x) + \\mathcal{O}(h^4)\\right) + i\\left(hf'(x) - \\frac{h^3}{6}f'''(x) + \\mathcal{O}(h^5)\\right)$$\n        取虚部 $\\operatorname{Im}[\\cdot]$ 并除以 $h$：\n        $$\\frac{\\operatorname{Im}[f(x+ih)]}{h} = f'(x) - \\frac{h^2}{6}f'''(x) + \\mathcal{O}(h^4)$$\n        截断误差的主项为 $E_{T, \\mathrm{cs}} \\approx -\\frac{h^2}{6}f'''(x)$。该方法也是二阶精度，误差阶为 $\\mathcal{O}(h^2)$。\n\n*   **舍入误差**：这是一种计算误差，源于浮点算术的有限精度，由机器ε $\\epsilon_{\\text{mach}}$ 决定（对于 IEEE $754$ 双精度，$\\epsilon_{\\text{mach}} \\approx 2.22 \\times 10^{-16}$）。\n\n    *   对于 $D_{\\mathrm{fwd}}$ 和 $D_{\\mathrm{ctr}}$，当 $h \\to 0$ 时，分子涉及两个几乎相等的数的减法。这种现象称为**相减抵消**，会导致有效数字的灾难性损失。对于这些方法，舍入误差 $E_{R}$ 随着 $h$ 的减小而被放大，其量级为 $E_{R} \\approx \\mathcal{O}(\\epsilon_{\\text{mach}}/h)$。\n\n    *   对于 $D_{\\mathrm{cs}}$，计算 $\\operatorname{Im}[f(x+ih)]$ 不涉及两个几乎相等的数的减法。例如，$\\operatorname{Im}[\\sin(x+ih)] = \\cos(x)\\sinh(h)$。对于小的 $h$，$\\sinh(h)\\approx h$，因此 $\\operatorname{Im}[\\sin(x+ih)]\\approx h\\cos(x)$。没有发生抵消。因此，舍入误差不会被小的 $h$ 放大，并保持在 $\\mathcal{O}(\\epsilon_{\\text{mach}})$ 的量级。\n\n*   **总误差与最佳步长**：对于实值方法，随着 $h$ 的减小，截断误差减小，而舍入误差增大。这种权衡导致存在一个使总误差最小化的最佳步长 $h_{\\text{opt}}$。\n    *   对于 $D_{\\mathrm{fwd}}$，总误差 $E_{\\mathrm{fwd}}(h) \\approx C_1 h + C_2 \\frac{\\epsilon_{\\text{mach}}}{h}$ 在 $h_{\\text{opt}} \\approx \\mathcal{O}(\\sqrt{\\epsilon_{\\text{mach}}})$ 时最小化。最小误差也约为 $\\mathcal{O}(\\sqrt{\\epsilon_{\\text{mach}}})$。\n    *   对于 $D_{\\mathrm{ctr}}$，总误差 $E_{\\mathrm{ctr}}(h) \\approx C_3 h^2 + C_4 \\frac{\\epsilon_{\\text{mach}}}{h}$ 在 $h_{\\text{opt}} \\approx \\mathcal{O}(\\epsilon_{\\text{mach}}^{1/3})$ 时最小化。最小误差约为 $\\mathcal{O}(\\epsilon_{\\text{mach}}^{2/3})$。\n    *   对于 $D_{\\mathrm{cs}}$，总误差 $E_{\\mathrm{cs}}(h) \\approx C_5 h^2 + C_6 \\epsilon_{\\text{mach}}$。由于舍入误差项没有被放大，误差随 $h^2$ 减小，直到达到由机器精度决定的一个下限。集合 $\\mathcal{H}$ 中最小的 $h$ 很可能会产生最小误差，该误差将接近 $\\mathcal{O}(\\epsilon_{\\text{mach}})$。\n\n**2. 计算策略**\n\n求解算法是问题需求的直接实现。我们必须在给定的离散步长集合 $\\mathcal{H} = \\{10^{-k} : k \\in \\{1, 2, \\dots, 16\\}\\}$ 上进行穷举搜索。\n\n1.  对于由元组 $(f, f', x_0)$ 定义的每个测试用例：\n2.  预先计算真导数值 $d_{\\text{exact}} = f'(x_0)$。\n3.  为每种方法初始化最小误差变量，例如 $\\min E_{\\mathrm{fwd}}$、$\\min E_{\\mathrm{ctr}}$ 和 $\\min E_{\\mathrm{cs}}$，将其设为代表无穷大的值。\n4.  遍历集合 $\\mathcal{H}$ 中的每个步长 $h$。\n    a. 对于每个 $h$，计算三种导数近似值：$D_{\\mathrm{fwd}}(f,x_0,h)$、$D_{\\mathrm{ctr}}(f,x_0,h)$ 和 $D_{\\mathrm{cs}}(f,x_0,h)$。\n    b. 计算每个近似值的绝对误差：$E(h) = |D(h) - d_{\\text{exact}}|$。\n    c. 将计算出的误差与该方法的当前最小误差进行比较，如果新误差更小，则更新最小值。\n5. 遍历完所有 $h \\in \\mathcal{H}$ 后，最小误差的三元组 $[\\min E_{\\mathrm{fwd}}, \\min E_{\\mathrm{ctr}}, \\min E_{\\mathrm{cs}}]$ 构成了给定测试用例的结果。\n6. 按规定将所有测试用例的结果聚合到最终的列表结构中。实现将使用 `numpy` 库，该库能正确处理标准解析函数的复值参数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the minimum absolute error for three numerical differentiation methods\n    (forward difference, central difference, complex-step) over a range of step sizes.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (function, derivative_function, evaluation_point_x0).\n    # Numpy functions (exp, sin, cos) are used as they correctly handle complex inputs,\n    # which is required for the complex-step method.\n    test_cases = [\n        (np.exp, np.exp, 1.0),\n        (np.sin, np.cos, 1.0),\n        (np.cos, lambda x: -np.sin(x), 0.0)\n    ]\n\n    # Define the discrete set of step sizes H.\n    H = [10.0**(-k) for k in range(1, 17)]  # k from 1 to 16 inclusive.\n\n    all_case_results = []\n    for f, f_prime, x0 in test_cases:\n        # Calculate the exact derivative value for reference.\n        exact_derivative = f_prime(float(x0))\n\n        # Initialize minimum errors for the current test case.\n        min_err_fwd = float('inf')\n        min_err_ctr = float('inf')\n        min_err_cs = float('inf')\n\n        for h in H:\n            # 1. Forward finite difference\n            d_fwd = (f(x0 + h) - f(x0)) / h\n            err_fwd = abs(d_fwd - exact_derivative)\n            if err_fwd < min_err_fwd:\n                min_err_fwd = err_fwd\n\n            # 2. Central finite difference\n            d_ctr = (f(x0 + h) - f(x0 - h)) / (2 * h)\n            err_ctr = abs(d_ctr - exact_derivative)\n            if err_ctr < min_err_ctr:\n                min_err_ctr = err_ctr\n            \n            # 3. Complex-step approximation\n            # The imaginary unit in Python is 1j.\n            d_cs = np.imag(f(x0 + 1j * h)) / h\n            err_cs = abs(d_cs - exact_derivative)\n            if err_cs < min_err_cs:\n                min_err_cs = err_cs\n\n        # Collect the minimum errors for the current case.\n        all_case_results.append([min_err_fwd, min_err_ctr, min_err_cs])\n\n    # Format the final output string as per the problem specification.\n    # The output must be a single-line string representing a list of lists,\n    # with no spaces and with numbers in scientific notation to 12 significant digits.\n    # The format specifier \"{:.11e}\" ensures 1 digit before and 11 after the decimal point.\n    \n    formatted_case_strings = []\n    for case_res in all_case_results:\n        # Format each sublist of 3 floats into a string like \"[num1,num2,num3]\"\n        formatted_numbers = [f\"{num:.11e}\" for num in case_res]\n        formatted_case_strings.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    # Join the formatted case strings into the final output string \"[case1,case2,case3]\"\n    final_output = f\"[{','.join(formatted_case_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "2418870"}, {"introduction": "到目前为止，我们主要关注一维标量函数的导数。那么，这些思想如何推广到高维度的矢量场呢？这个练习将挑战您计算三维矢量场的散度，这是物理和工程学中的一个基本算子。您需要组合应用简单的一维有限差分公式来近似 $\\nabla \\cdot \\mathbf{F} = \\frac{\\partial P}{\\partial x} + \\frac{\\partial Q}{\\partial y} + \\frac{\\partial R}{\\partial z}$。这项实践性的编程任务将巩固您在多维环境中应用数值微分的技能，特别是学习如何处理需要与内部点采用不同格式的边界点，这是一项关键的实用技能 [@problem_id:2418896]。", "problem": "给定一个三维均匀笛卡尔网格，其节点索引为 $\\{i,j,k\\}$，其中 $i \\in \\{0,1,\\dots,N_x-1\\}$，$j \\in \\{0,1,\\dots,N_y-1\\}$，$k \\in \\{0,1,\\dots,N_z-1\\}$。节点 $(i,j,k)$ 的物理坐标由 $x_i = x_{\\min} + i\\,\\Delta x$、$y_j = y_{\\min} + j\\,\\Delta y$、$z_k = z_{\\min} + k\\,\\Delta z$ 定义，其中均匀间距为 $\\Delta x = \\dfrac{x_{\\max}-x_{\\min}}{N_x-1}$，$\\Delta y = \\dfrac{y_{\\max}-y_{\\min}}{N_y-1}$，以及 $\\Delta z = \\dfrac{z_{\\max}-z_{\\min}}{N_z-1}$。一个矢量场 $\\mathbf{F}(x,y,z)$（其分量为 $\\mathbf{F} = (P,Q,R)$）通过解析表达式在每个网格节点上被给定。如果出现三角函数，其参数必须被解释为以弧度为单位的角度。\n\n节点 $(i,j,k)$ 处的离散散度定义为分别应用于分量 $P,Q,R$ 的三个离散一阶偏导数之和。在 $x$ 方向上，节点 $(i,j,k)$ 处的一阶离散偏导数定义如下：\n- 对于 $x$ 方向的内部节点，即 $1 \\le i \\le N_x - 2$：\n$$\\left.\\frac{\\partial P}{\\partial x}\\right|_{i,j,k} \\approx \\frac{P_{i+1,j,k} - P_{i-1,j,k}}{2\\,\\Delta x}.$$\n- 对于 $x$ 方向的左边界，即 $i = 0$：\n$$\\left.\\frac{\\partial P}{\\partial x}\\right|_{0,j,k} \\approx \\frac{-3\\,P_{0,j,k} + 4\\,P_{1,j,k} - P_{2,j,k}}{2\\,\\Delta x}.$$\n- 对于 $x$ 方向的右边界，即 $i = N_x - 1$：\n$$\\left.\\frac{\\partial P}{\\partial x}\\right|_{N_x-1,j,k} \\approx \\frac{3\\,P_{N_x-1,j,k} - 4\\,P_{N_x-2,j,k} + P_{N_x-3,j,k}}{2\\,\\Delta x}.$$\n\n在 $y$ 方向上对 $Q$ 使用 $\\Delta y$，以及在 $z$ 方向上对 $R$ 使用 $\\Delta z$ 时，必须使用类似的公式。节点 $(i,j,k)$ 处的离散散度是这三个近似值之和：\n$$\\left.\\nabla \\cdot \\mathbf{F}\\right|_{i,j,k} \\approx \\left.\\frac{\\partial P}{\\partial x}\\right|_{i,j,k} + \\left.\\frac{\\partial Q}{\\partial y}\\right|_{i,j,k} + \\left.\\frac{\\partial R}{\\partial z}\\right|_{i,j,k}.$$\n\n使用上述定义为以下每个测试用例计算离散散度。对于每个用例，构建网格，在所有节点上计算场分量，计算离散散度场，并提取指定节点处的值。您的程序必须将这四个结果作为单个列表输出，每个值需四舍五入到小数点后恰好 $6$ 位。\n\n测试套件：\n- 用例 $1$：\n  - 定义域： $x \\in [-1,1]$，$y \\in [-1,1]$，$z \\in [-1,1]$。\n  - 网格尺寸：$N_x = 3$，$N_y = 4$，$N_z = 3$。\n  - 场：$P(x,y,z) = 2\\,x$，$Q(x,y,z) = -3\\,y$，$R(x,y,z) = 4\\,z$。\n  - 报告的节点索引：$(i,j,k) = (0,0,0)$。\n- 用例 $2$：\n  - 定义域：$x \\in [0,1]$，$y \\in [0,1]$，$z \\in [0,1]$。\n  - 网格尺寸：$N_x = 5$，$N_y = 5$，$N_z = 5$。\n  - 场：$P(x,y,z) = x^2$，$Q(x,y,z) = y^2$，$R(x,y,z) = z^2$。\n  - 报告的节点索引：$(i,j,k) = (2,2,3)$。\n- 用例 $3$：\n  - 定义域：$x \\in [0,\\pi]$，$y \\in \\left[0,\\frac{\\pi}{2}\\right]$，$z \\in [0,1]$。\n  - 网格尺寸：$N_x = 8$，$N_y = 7$，$N_z = 6$。\n  - 场：$P(x,y,z) = \\sin(x)$，$Q(x,y,z) = \\cos(y)$，$R(x,y,z) = e^{z}$。\n  - 报告的节点索引：$(i,j,k) = (4,3,2)$。\n- 用例 $4$：\n  - 定义域：$x \\in \\left[-\\frac{1}{2},\\frac{1}{2}\\right]$，$y \\in [0,1]$，$z \\in [-1,1]$。\n  - 网格尺寸：$N_x = 4$，$N_y = 3$，$N_z = 5$。\n  - 场：$P(x,y,z) = e^{x}$，$Q(x,y,z) = y^3$，$R(x,y,z) = z$。\n  - 报告的节点索引：$(i,j,k) = (3,0,4)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[r_1,r_2,r_3,r_4]$）。\n- 每个 $r_m$ 必须是四舍五入到小数点后恰好 $6$ 位的小数。\n- 不应打印其他任何文本。", "solution": "所给问题要求在三维均匀笛卡尔网格上计算矢量场 $\\mathbf{F}(x,y,z) = (P, Q, R)$ 的离散散度。该问题定义明确、科学上合理且完整。所有必要的组成部分，包括网格结构、矢量场的解析表达式以及用于近似偏导数的特定有限差分公式，均已提供。该问题是计算工程和应用数学中的一个标准练习，特别是在微分算子数值离散化领域。因此，该问题是有效的，并且可以得出直接、明确的解。\n\n问题的核心是计算散度，其定义为 $\\nabla \\cdot \\mathbf{F} = \\frac{\\partial P}{\\partial x} + \\frac{\\partial Q}{\\partial y} + \\frac{\\partial R}{\\partial z}$。我们必须在网格上的指定节点 $(i,j,k)$ 处，用一个离散等价形式来近似这个连续算子。任意节点 $(i,j,k)$ 的物理坐标由以下公式给出：\n$$x_i = x_{\\min} + i\\,\\Delta x, \\quad \\text{for } i \\in \\{0, 1, \\dots, N_x-1\\}$$\n$$y_j = y_{\\min} + j\\,\\Delta y, \\quad \\text{for } j \\in \\{0, 1, \\dots, N_y-1\\}$$\n$$z_k = z_{\\min} + k\\,\\Delta z, \\quad \\text{for } k \\in \\{0, 1, \\dots, N_z-1\\}$$\n其中网格间距是均匀的：\n$$\\Delta x = \\frac{x_{\\max}-x_{\\min}}{N_x-1}, \\quad \\Delta y = \\frac{y_{\\max}-y_{\\min}}{N_y-1}, \\quad \\Delta z = \\frac{z_{\\max}-z_{\\min}}{N_z-1}$$\n\n分量 $P$ 关于 $x$ 的离散偏导数由二阶精确的有限差分公式给出，具体公式取决于节点索引 $i$ 的位置：\n对于内部节点 $1 \\le i \\le N_x-2$，使用中心差分公式：\n$$\\left.\\frac{\\partial P}{\\partial x}\\right|_{i,j,k} \\approx \\frac{P(x_{i+1}, y_j, z_k) - P(x_{i-1}, y_j, z_k)}{2\\,\\Delta x}$$\n对于左边界节点 $i=0$，使用前向差分公式：\n$$\\left.\\frac{\\partial P}{\\partial x}\\right|_{0,j,k} \\approx \\frac{-3\\,P(x_0, y_j, z_k) + 4\\,P(x_1, y_j, z_k) - P(x_2, y_j, z_k)}{2\\,\\Delta x}$$\n对于右边界节点 $i = N_x-1$，使用后向差分公式：\n$$\\left.\\frac{\\partial P}{\\partial x}\\right|_{N_x-1,j,k} \\approx \\frac{3\\,P(x_{N_x-1}, y_j, z_k) - 4\\,P(x_{N_x-2}, y_j, z_k) + P(x_{N_x-3}, y_j, z_k)}{2\\,\\Delta x}$$\n\n对于 $Q$ 关于 $y$ 的偏导数（使用索引 $j$、间距 $\\Delta y$ 和网格尺寸 $N_y$）以及 $R$ 关于 $z$ 的偏导数（使用索引 $k$、间距 $\\Delta z$ 和网格尺寸 $N_z$），也应用相同的模板结构。节点 $(i,j,k)$ 处的离散散度是这三个数值近似之和：\n$$\\left.\\nabla \\cdot \\mathbf{F}\\right|_{i,j,k} \\approx \\left.\\frac{\\partial P}{\\partial x}\\right|_{i,j,k} + \\left.\\frac{\\partial Q}{\\partial y}\\right|_{i,j,k} + \\left.\\frac{\\partial R}{\\partial z}\\right|_{i,j,k}$$\n\n求解过程是为所提供的四个测试用例中的每一个系统地实现这一计算。对于每个用例，我们首先确定网格参数（$x_{\\min}$、$x_{\\max}$、$N_x$ 等）。然后，我们确定网格间距（$\\Delta x$、$\\Delta y$、$\\Delta z$）和每个坐标轴的物理坐标集。对于指定的节点索引 $(i,j,k)$，我们识别其在每个维度上的位置是在边界上还是在内部。在此基础上，我们选择合适的有限差分公式。然后，我们在必要的相邻网格点上计算场分量 $P$、$Q$ 和 $R$，计算每个偏导数的近似值，并将结果求和以获得最终的离散散度。对所有四个测试用例重复此过程，以生成所需的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the discrete divergence of a vector field on a 3D Cartesian grid\n    for a series of test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1\n        {\n            \"domain\": {'x': (-1, 1), 'y': (-1, 1), 'z': (-1, 1)},\n            \"grid_sizes\": {'Nx': 3, 'Ny': 4, 'Nz': 3},\n            \"field\": {\n                'P': lambda x, y, z: 2 * x,\n                'Q': lambda x, y, z: -3 * y,\n                'R': lambda x, y, z: 4 * z\n            },\n            \"node_index\": (0, 0, 0)\n        },\n        # Case 2\n        {\n            \"domain\": {'x': (0, 1), 'y': (0, 1), 'z': (0, 1)},\n            \"grid_sizes\": {'Nx': 5, 'Ny': 5, 'Nz': 5},\n            \"field\": {\n                'P': lambda x, y, z: x**2,\n                'Q': lambda x, y, z: y**2,\n                'R': lambda x, y, z: z**2\n            },\n            \"node_index\": (2, 2, 3)\n        },\n        # Case 3\n        {\n            \"domain\": {'x': (0, np.pi), 'y': (0, np.pi / 2), 'z': (0, 1)},\n            \"grid_sizes\": {'Nx': 8, 'Ny': 7, 'Nz': 6},\n            \"field\": {\n                'P': lambda x, y, z: np.sin(x),\n                'Q': lambda x, y, z: np.cos(y),\n                'R': lambda x, y, z: np.exp(z)\n            },\n            \"node_index\": (4, 3, 2)\n        },\n        # Case 4\n        {\n            \"domain\": {'x': (-0.5, 0.5), 'y': (0, 1), 'z': (-1, 1)},\n            \"grid_sizes\": {'Nx': 4, 'Ny': 3, 'Nz': 5},\n            \"field\": {\n                'P': lambda x, y, z: np.exp(x),\n                'Q': lambda x, y, z: y**3,\n                'R': lambda x, y, z: z\n            },\n            \"node_index\": (3, 0, 4)\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # Extract parameters for the current case\n        x_min, x_max = case[\"domain\"]['x']\n        y_min, y_max = case[\"domain\"]['y']\n        z_min, z_max = case[\"domain\"]['z']\n        \n        Nx = case[\"grid_sizes\"]['Nx']\n        Ny = case[\"grid_sizes\"]['Ny']\n        Nz = case[\"grid_sizes\"]['Nz']\n\n        P = case[\"field\"]['P']\n        Q = case[\"field\"]['Q']\n        R = case[\"field\"]['R']\n        \n        i, j, k = case[\"node_index\"]\n\n        # Calculate grid spacings\n        # Handle division by zero for single-point dimensions (N=1)\n        delta_x = (x_max - x_min) / (Nx - 1) if Nx > 1 else 0\n        delta_y = (y_max - y_min) / (Ny - 1) if Ny > 1 else 0\n        delta_z = (z_max - z_min) / (Nz - 1) if Nz > 1 else 0\n\n        # Generate coordinate arrays\n        x_coords = np.linspace(x_min, x_max, Nx)\n        y_coords = np.linspace(y_min, y_max, Ny)\n        z_coords = np.linspace(z_min, z_max, Nz)\n        \n        x_target, y_target, z_target = x_coords[i], y_coords[j], z_coords[k]\n\n        # --- Calculate dP/dx ---\n        if Nx < 3:\n            # Not enough points for the specified stencils. Problem implies N>=3.\n            # However, for robustness, we can assume derivative is 0 if not computable.\n            dP_dx = 0.0\n        elif i == 0: # Forward difference at left boundary\n            p0 = P(x_coords[0], y_target, z_target)\n            p1 = P(x_coords[1], y_target, z_target)\n            p2 = P(x_coords[2], y_target, z_target)\n            dP_dx = (-3 * p0 + 4 * p1 - p2) / (2 * delta_x)\n        elif i == Nx - 1: # Backward difference at right boundary\n            p0 = P(x_coords[Nx-1], y_target, z_target)\n            p1 = P(x_coords[Nx-2], y_target, z_target)\n            p2 = P(x_coords[Nx-3], y_target, z_target)\n            dP_dx = (3 * p0 - 4 * p1 + p2) / (2 * delta_x)\n        else: # Central difference for interior\n            p_minus = P(x_coords[i-1], y_target, z_target)\n            p_plus = P(x_coords[i+1], y_target, z_target)\n            dP_dx = (p_plus - p_minus) / (2 * delta_x)\n\n        # --- Calculate dQ/dy ---\n        if Ny < 3:\n            dQ_dy = 0.0\n        elif j == 0: # Forward difference at 'left' boundary\n            q0 = Q(x_target, y_coords[0], z_target)\n            q1 = Q(x_target, y_coords[1], z_target)\n            q2 = Q(x_target, y_coords[2], z_target)\n            dQ_dy = (-3 * q0 + 4 * q1 - q2) / (2 * delta_y)\n        elif j == Ny - 1: # Backward difference at 'right' boundary\n            q0 = Q(x_target, y_coords[Ny-1], z_target)\n            q1 = Q(x_target, y_coords[Ny-2], z_target)\n            q2 = Q(x_target, y_coords[Ny-3], z_target)\n            dQ_dy = (3 * q0 - 4 * q1 + q2) / (2 * delta_y)\n        else: # Central difference for interior\n            q_minus = Q(x_target, y_coords[j-1], z_target)\n            q_plus = Q(x_target, y_coords[j+1], z_target)\n            dQ_dy = (q_plus - q_minus) / (2 * delta_y)\n\n        # --- Calculate dR/dz ---\n        if Nz < 3:\n            dR_dz = 0.0\n        elif k == 0: # Forward difference at 'left' boundary\n            r0 = R(x_target, y_target, z_coords[0])\n            r1 = R(x_target, y_target, z_coords[1])\n            r2 = R(x_target, y_target, z_coords[2])\n            dR_dz = (-3 * r0 + 4 * r1 - r2) / (2 * delta_z)\n        elif k == Nz - 1: # Backward difference at 'right' boundary\n            r0 = R(x_target, y_target, z_coords[Nz-1])\n            r1 = R(x_target, y_target, z_coords[Nz-2])\n            r2 = R(x_target, y_target, z_coords[Nz-3])\n            dR_dz = (3 * r0 - 4 * r1 + r2) / (2 * delta_z)\n        else: # Central difference for interior\n            r_minus = R(x_target, y_target, z_coords[k-1])\n            r_plus = R(x_target, y_target, z_coords[k+1])\n            dR_dz = (r_plus - r_minus) / (2 * delta_z)\n            \n        divergence = dP_dx + dQ_dy + dR_dz\n        results.append(divergence)\n\n    # Format the final output string\n    # The requirement is to round to 6 decimal places.\n    # The f-string format specifier f'{x:.6f}' does this.\n    output_str = \"[\" + \",\".join(f\"{res:.6f}\" for res in results) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "2418896"}]}