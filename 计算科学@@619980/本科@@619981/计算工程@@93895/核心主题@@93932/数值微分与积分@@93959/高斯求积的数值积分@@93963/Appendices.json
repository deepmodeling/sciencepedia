{"hands_on_practices": [{"introduction": "高斯求积的卓越精度根植于其构造所依赖的正交多项式理论。本练习旨在通过实践来验证高斯-勒让德求积法的核心原理：即 $N$ 点求积对于最高 $2N-1$ 次的多项式是精确的。通过数值计算勒让德多项式的正交性积分 [@problem_id:2419561]，你将亲眼见证理论的数学之美如何转化为计算中的极致效率。", "problem": "实现一个程序，该程序针对指定的阶数组合，使用高斯求积法 (GQ) 数值计算两个 Legendre 多项式的内积积分。令 $P_n(x)$ 表示在区间 $[-1,1]$ 上的 $n$ 阶 Legendre 多项式，其标准归一化为 $P_n(1)=1$。定义内积为\n$$\nJ_{m,n} \\equiv \\int_{-1}^{1} P_m(x)\\,P_n(x)\\,dx.\n$$\n你的任务是使用在 $[-1,1]$ 上的 $N$ 点 Gauss–Legendre 求积法则（即，在区间 $[-1,1]$ 上权重函数为 $w(x)=1$ 的高斯求积法）来计算 $J_{m,n}$ 的数值近似值。高斯求积和具有以下形式\n$$\nQ_N[f] \\equiv \\sum_{i=1}^{N} w_i\\,f(x_i),\n$$\n其中 $\\{x_i\\}_{i=1}^N \\subset (-1,1)$ 是 Gauss–Legendre 节点，$\\{w_i\\}_{i=1}^N$ 是相应的正权重。\n\n从第一性原理出发，回顾以下与本任务相关的基本原理：\n- Legendre 多项式 $\\{P_n(x)\\}_{n\\ge 0}$ 在区间 $[-1,1]$ 上关于常数权重 $w(x)=1$ 构成一个正交序列。\n- 对所有阶数至多为 $d$ 的多项式，$N$ 点 Gauss-Legendre 求积法则都是精确的，其中 $d$ 取决于 $N$ 和该法则的构造方式，并使用 $P_N(x)$ 的根作为节点。\n\n你的程序必须：\n- 对每个测试用例 $(m,n,N)$，使用数值生成的 Gauss-Legendre 节点和权重来计算 $Q_N[P_m P_n]$。\n- 返回原始的求积值（浮点数），除了标准的双精度算术外，不进行任何后处理或舍入。\n\n测试套件：\n- 用例 1： $(m,n,N)=(2,3,3)$。\n- 用例 2： $(m,n,N)=(0,1,1)$。\n- 用例 3： $(m,n,N)=(10,9,10)$。\n- 用例 4： $(m,n,N)=(4,6,2)$。\n- 用例 5： $(m,n,N)=(7,7,8)$。\n\n覆盖性设计：\n- 用例 1、2 和 3 使用了足够多的节点，可以通过高斯求积法精确计算多项式 $P_m(x)P_n(x)$ 的积分，并探测了不同的奇偶性组合以及更高的阶数。\n- 用例 4 故意使用过少的节点，以揭示积分不足对偶函数被积函数的影响。\n- 用例 5 使用相等的阶数，来探测一个可被求积法捕获的非零自身内积。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含按上述测试套件顺序排列的结果，格式为方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_k$ 是对应情况下求积法返回的浮点值。", "solution": "如题所述，问题是使用 $N$ 点 Gauss-Legendre 求积法则来数值近似两个 Legendre 多项式的内积积分，该积分定义为\n$$\nJ_{m,n} \\equiv \\int_{-1}^{1} P_m(x)\\,P_n(x)\\,dx\n$$\n待积函数是 $f(x) = P_m(x) P_n(x)$。其数值近似由以下求和给出\n$$\nQ_N[f] = \\sum_{i=1}^{N} w_i\\,f(x_i)\n$$\n其中 $\\{x_i\\}_{i=1}^N$ 是求积节点，$\\{w_i\\}_{i=1}^N$ 是在区间 $[-1, 1]$ 上的相应权重。\n\n首先，我们必须回顾一下支配此问题的基本原理。Legendre 多项式，记为 $P_n(x)$（阶数 $n \\ge 0$），在区间 $[-1, 1]$上对于单位权重函数 $w(x) = 1$ 构成了平方可积函数空间的一个完备正交基。它们的正交关系由下式给出\n$$\n\\int_{-1}^{1} P_m(x) P_n(x) dx = \\frac{2}{2n+1} \\delta_{mn}\n$$\n其中 $\\delta_{mn}$ 是 Kronecker delta，当 $m=n$ 时为 $1$，当 $m \\neq n$ 时为 $0$。这就是积分 $J_{m,n}$ 的精确解析值。\n\n其次，$N$ 点 Gauss-Legendre 求积法的构造使其对于阶数最高为 $2N-1$ 的任何多项式都是精确的。我们问题中的被积函数 $f(x) = P_m(x) P_n(x)$ 本身是一个 $m+n$ 阶的多项式。因此，当且仅当被积函数的阶数不超过求积法则的精度阶数时，数值求积 $Q_N[P_m P_n]$ 才能得到积分 $J_{m,n}$ 的精确值。也就是说，如果\n$$\nm+n \\le 2N-1\n$$\n该近似就是精确的。当此条件满足时，数值结果必须与正交性决定的解析结果相符。如果 $m+n > 2N-1$，则不保证求积是精确的，并将产生一个近似值，其精度取决于 $N$ 和被积函数的具体性质。\n\n现在，我们将此理论框架应用于每个测试用例。\n\n**用例 1: $(m,n,N) = (2,3,3)$**\n被积函数的阶数是 $m+n = 2+3 = 5$。\n$N=3$ 点求积的精确阶数是 $2N-1 = 2(3)-1 = 5$。\n由于 $m+n \\le 2N-1$ (具体来说，$5 \\le 5$)，求积是精确的。\n由于 $m=2 \\neq n=3$，积分的解析值为 $J_{2,3} = 0$。\n因此，计算值 $Q_3[P_2 P_3]$ 在浮点精度范围内必须为 $0$。\n\n**用例 2: $(m,n,N) = (0,1,1)$**\n被积函数的阶数是 $m+n = 0+1 = 1$。\n$N=1$ 点求积的精确阶数是 $2N-1 = 2(1)-1 = 1$。\n条件 $m+n \\le 2N-1$ 得到满足 ($1 \\le 1$)，所以求积是精确的。\n由于 $m=0 \\neq n=1$，解析值为 $J_{0,1} = 0$。\n计算值 $Q_1[P_0 P_1]$ 必须为 $0$。\n\n**用例 3: $(m,n,N) = (10,9,10)$**\n被积函数的阶数是 $m+n = 10+9 = 19$。\n$N=10$ 点求积的精确阶数是 $2N-1 = 2(10)-1 = 19$。\n条件 $m+n \\le 2N-1$ 得到满足 ($19 \\le 19$)，所以求积是精确的。\n由于 $m=10 \\neq n=9$，解析值为 $J_{10,9} = 0$。\n计算值 $Q_{10}[P_{10} P_9]$ 必须为 $0$。\n\n**用例 4: $(m,n,N) = (4,6,2)$**\n被积函数的阶数是 $m+n = 4+6 = 10$。\n$N=2$ 点求积的精确阶数是 $2N-1 = 2(2)-1 = 3$。\n此处，$m+n > 2N-1$ ($10 > 3$)，所以求积**不**是精确的。我们预期得到一个非零结果，这展示了积分不足的后果。解析结果是 $J_{4,6} = 0$，但数值方法不足以捕捉到这一点。\n对于 $N=2$，节点是 $P_2(x) = \\frac{1}{2}(3x^2-1)$ 的根，即 $x_{1,2} = \\pm 1/\\sqrt{3}$。权重为 $w_{1,2} = 1$。\n求积和为 $Q_2[P_4 P_6] = w_1 P_4(x_1)P_6(x_1) + w_2 P_4(x_2)P_6(x_2)$。\n$Q_2[P_4 P_6] = (1) \\cdot P_4(-1/\\sqrt{3})P_6(-1/\\sqrt{3}) + (1) \\cdot P_4(1/\\sqrt{3})P_6(1/\\sqrt{3})$。\n由于当 n 为偶数时 $P_n(x)$ 是偶函数，所以 $P_n(-x) = P_n(x)$。因此，和式简化为 $2 P_4(1/\\sqrt{3})P_6(1/\\sqrt{3})$。\n使用标准定义 $P_4(x) = \\frac{1}{8}(35x^4 - 30x^2 + 3)$ 和 $P_6(x) = \\frac{1}{16}(231x^6 - 315x^4 + 105x^2 - 5)$，我们在 $x=1/\\sqrt{3}$ 处求值：\n$P_4(1/\\sqrt{3}) = \\frac{1}{8}\\left(35(\\frac{1}{9}) - 30(\\frac{1}{3}) + 3\\right) = \\frac{1}{8}\\left(\\frac{35}{9} - 10 + 3\\right) = \\frac{1}{8}\\left(\\frac{35-63}{9}\\right) = -\\frac{28}{72} = -\\frac{7}{18}$。\n$P_6(1/\\sqrt{3}) = \\frac{1}{16}\\left(231(\\frac{1}{27}) - 315(\\frac{1}{9}) + 105(\\frac{1}{3}) - 5\\right) = \\frac{1}{16}\\left(\\frac{77}{9} - 35 + 35 - 5\\right) = \\frac{1}{16}\\left(\\frac{77-45}{9}\\right) = \\frac{32}{144} = \\frac{2}{9}$。\n结果是 $Q_2[P_4 P_6] = 2 \\cdot (-\\frac{7}{18}) \\cdot (\\frac{2}{9}) = -\\frac{28}{162} = -\\frac{14}{81} \\approx -0.1728395$。\n\n**用例 5: $(m,n,N) = (7,7,8)$**\n被积函数的阶数是 $m+n = 7+7 = 14$。\n$N=8$ 点求积的精确阶数是 $2N-1 = 2(8)-1 = 15$。\n条件 $m+n \\le 2N-1$ 得到满足 ($14 \\le 15$)，所以求积是精确的。\n由于 $m=n=7$，解析值非零：\n$J_{7,7} = \\frac{2}{2(7)+1} = \\frac{2}{15}$。\n计算值 $Q_8[P_7 P_7]$ 必须等于 $\\frac{2}{15} \\approx 0.133333...$。\n\n计算过程将涉及：对于给定的 $N$，获取相应的 Gauss-Legendre 节点和权重；在这些节点上计算两个指定的 Legendre 多项式的乘积；并执行加权求和。像 `SciPy` 这样的库为生成求积法则和 Legendre 多项式都提供了稳健的实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre, roots_legendre\n\ndef solve():\n    \"\"\"\n    Computes numerical approximations of the inner product of Legendre polynomials\n    using Gauss-Legendre quadrature for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is in the format (m, n, N) where m and n are the polynomial\n    # degrees and N is the number of quadrature points.\n    test_cases = [\n        (2, 3, 3),   # Case 1\n        (0, 1, 1),   # Case 2\n        (10, 9, 10), # Case 3\n        (4, 6, 2),   # Case 4\n        (7, 7, 8),   # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        m, n, N = case\n\n        # Generate the N-point Gauss-Legendre quadrature nodes and weights.\n        # roots_legendre(N) returns the roots of P_N(x) and the corresponding weights.\n        nodes, weights = roots_legendre(N)\n        \n        # Create callable Legendre polynomial functions for degrees m and n.\n        # The standard normalization P_k(1) = 1 is default in scipy.special.legendre.\n        P_m = legendre(m)\n        P_n = legendre(n)\n\n        # Evaluate the integrand, which is the product of the two polynomials,\n        # at the quadrature nodes.\n        integrand_values = P_m(nodes) * P_n(nodes)\n\n        # Compute the quadrature sum: sum(w_i * f(x_i)).\n        # This is the numerical approximation of the integral.\n        # np.dot is an efficient way to compute the sum of element-wise products.\n        integral_approximation = np.dot(weights, integrand_values)\n        \n        results.append(integral_approximation)\n\n    # Final print statement in the exact required format.\n    # The format is a comma-separated list of floating-point numbers\n    # enclosed in square brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2419561"}, {"introduction": "在解决了理想的多项式积分后，我们将注意力转向更常见的现实世界问题：近似计算复杂函数的积分。此时，评估近似的准确性变得至关重要，而这正是误差分析的用武之地。本练习将指导你应用高斯求积的理论误差界公式 [@problem_id:2419598]，通过计算高阶导数的上确界，来量化一个非多项式函数积分的近似误差，从而建立起对数值解可靠性的深刻理解。", "problem": "考虑函数 $f(x) = e^{\\cos(x)}$，该函数对实数 $x$ 有定义，其中角度以弧度为单位。令 $[a,b] = [0,2\\pi]$，并令 $n$ 表示用于近似定积分 $I = \\int_{0}^{2\\pi} e^{\\cos(x)}\\,dx$ 的高斯-勒让德求积法则中的节点数。对于每个指定的 $n$ 值，从第一性原理出发，以数学上一致的方式执行以下所有任务：\n\n1. 在区间 $[0,2\\pi]$ 上，使用 $n$ 点高斯-勒让德法则计算 $I$ 的高斯求积近似值 $Q_n$。\n2. 计算 $I$ 的闭合形式精确值，用标准特殊函数表示，并将其用作数值评估的基准真值。\n3. 计算绝对误差 $E_{\\mathrm{abs}} = |I - Q_n|$。\n4. 根据 $n$ 点高斯-勒让德法则的经典误差理论，计算 $|I - Q_n|$ 的一个严格上界 $B_n$。该界必须用 $f$ 的 $(2n)$ 阶导数在 $x \\in [0,2\\pi]$ 上的绝对值的上确界以及区间长度来表示，这是高斯-勒让德求积误差分析的标准做法。任何能够为此上确界获得正确数值的、在数学上有效的方法都是可接受的。\n5. 确定是否满足 $E_{\\mathrm{abs}} \\le B_n$。\n\n所有浮点结果必须报告为无量纲量。角度必须以弧度处理。\n\n测试套件。使用以下三种情况：\n- 情况1：$n = 1$。\n- 情况2：$n = 3$。\n- 情况3：$n = 5$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个列表，每个测试用例对应一个条目，并按上面列出的顺序排列。每个条目本身必须是一个形式为 $[n, Q_n, I, E_{\\mathrm{abs}}, B_n, \\mathrm{within}]$ 的列表，其中 $n$ 是一个整数，$Q_n$、$I$、$E_{\\mathrm{abs}}$ 和 $B_n$ 是四舍五入到十二位小数的浮点数，而 $\\mathrm{within}$ 是一个整数，如果 $E_{\\mathrm{abs}} \\le B_n$ 则为 $1$，否则为 $0$。因此，整行必须具有以下形式：\n[ [n1,Qn1,I1,Eabs1,Bn1,within1], [n2,Qn2,I2,Eabs2,Bn2,within2], [n3,Qn3,I3,Eabs3,Bn3,within3] ]。", "solution": "问题陈述已经过分析，并被认为是有效的。这是一个数值分析中的适定问题，它基于既定的数学原理，并包含唯一解所需的所有必要信息。我们将从第一性原理出发，进行系统性的、分步的求解。\n\n问题的核心是使用 $n$ 点高斯-勒让德求积法则来近似定积分 $I = \\int_{0}^{2\\pi} e^{\\cos(x)}\\,dx$，并将所得的绝对误差与其理论上界进行比较。\n\n首先，我们定义相关的函数和积分区间：\n- 被积函数为 $f(x) = e^{\\cos(x)}$。\n- 积分区间为 $[a, b] = [0, 2\\pi]$。\n\n对于每个指定的 $n$ 值，求解过程需要五项独立的计算：求积近似值 $Q_n$、积分精确值 $I$、绝对误差 $E_{\\mathrm{abs}}$、理论误差上界 $B_n$ 以及对上界的验证。\n\n1.  **高斯-勒让德求积近似值 ($Q_n$)**\n    标准的 $n$ 点高斯-勒让德求积法则定义于区间 $[-1, 1]$ 上的积分：\n    $$ \\int_{-1}^{1} g(t) \\,dt \\approx \\sum_{i=1}^{n} w_i g(t_i) $$\n    此处，$t_i$ 是 $n$ 阶勒让德多项式 $P_n(t)$ 的 $n$ 个根（节点），而 $w_i$ 是相应的权重。\n\n    为了将此法则应用于我们的积分 $I = \\int_{a}^{b} f(x) \\,dx$，我们必须对变量 $x \\in [a, b]$ 进行线性变换，将其转换为新变量 $t \\in [-1, 1]$。该变换为：\n    $$ x(t) = \\frac{b-a}{2}t + \\frac{a+b}{2} $$\n    微分元变换为 $dx = \\frac{b-a}{2}dt$。\n    对于我们的特定区间 $[0, 2\\pi]$，我们有 $a=0$ 和 $b=2\\pi$。该变换简化为：\n    $$ x(t) = \\frac{2\\pi-0}{2}t + \\frac{0+2\\pi}{2} = \\pi t + \\pi = \\pi(t+1) $$\n    微分则为 $dx = \\pi dt$。\n\n    将此代入积分可得：\n    $$ I = \\int_{0}^{2\\pi} f(x) \\,dx = \\int_{-1}^{1} f(\\pi(t+1)) \\pi \\,dt $$\n    将高斯-勒让德求积法则应用于变换后的积分，得到近似值 $Q_n$：\n    $$ Q_n = \\pi \\sum_{i=1}^{n} w_i f(\\pi(t_i+1)) = \\pi \\sum_{i=1}^{n} w_i e^{\\cos(\\pi(t_i+1))} $$\n    节点 $t_i$ 和权重 $w_i$ 是标准的制表值，我们将通过计算得到它们。\n\n2.  **积分的精确值 ($I$)**\n    积分 $I = \\int_{0}^{2\\pi} e^{\\cos(x)} \\,dx$ 可以使用记为 $I_{\\nu}(z)$ 的第一类 $\\nu$ 阶修正贝塞尔函数的积分表示以闭合形式求值：\n    $$ I_{\\nu}(z) = \\frac{1}{\\pi} \\int_{0}^{\\pi} e^{z \\cos(\\theta)} \\cos(\\nu \\theta) \\,d\\theta $$\n    对于阶数 $\\nu=0$，上式简化为：\n    $$ I_0(z) = \\frac{1}{\\pi} \\int_{0}^{\\pi} e^{z \\cos(\\theta)} \\,d\\theta $$\n    被积函数 $e^{\\cos(x)}$ 是一个周期为 $2\\pi$ 的周期函数。在区间 $[0, 2\\pi]$ 上，它也关于 $x=\\pi$ 对称，因为 $\\cos(x) = \\cos(2\\pi - x)$。因此，在 $[0, 2\\pi]$ 上的积分是在 $[0, \\pi]$ 上的积分的两倍：\n    $$ I = \\int_{0}^{2\\pi} e^{\\cos(x)} \\,dx = 2 \\int_{0}^{\\pi} e^{\\cos(x)} \\,dx $$\n    在 $I_0(z)$ 的定义中令 $z=1$，我们发现 $\\int_{0}^{\\pi} e^{\\cos(x)} \\,dx = \\pi I_0(1)$。\n    因此，积分的精确值为：\n    $$ I = 2\\pi I_0(1) $$\n    该值将作为我们的基准真值。\n\n3.  **绝对误差 ($E_{\\mathrm{abs}}$)**\n    绝对误差可以简单地计算为精确值 $I$ 和我们的近似值 $Q_n$ 之间的绝对差值：\n    $$ E_{\\mathrm{abs}} = |I - Q_n| $$\n\n4.  **理论误差上界 ($B_n$)**\n    应用于积分 $\\int_{a}^{b} f(x) \\,dx$ 的 $n$ 点高斯-勒让德求积法则的经典误差公式由下式给出：\n    $$ I - Q_n = \\frac{(b-a)^{2n+1} (n!)^4}{(2n+1) [(2n)!]^3} f^{(2n)}(\\eta) $$\n    其中 $\\eta \\in (a, b)$。只要 $f(x)$ 在 $[a, b]$ 上是 $2n$ 次连续可微的，就能保证存在这样一个 $\\eta$，对于我们的函数 $f(x) = e^{\\cos(x)}$，这一点是成立的。\n\n    为了找到绝对误差的上界，我们取导数项的绝对值在区间上的上确界：\n    $$ B_n = \\frac{(b-a)^{2n+1} (n!)^4}{(2n+1) [(2n)!]^3} \\sup_{x \\in [a,b]} |f^{(2n)}(x)| $$\n    对于我们的问题，当 $[a, b] = [0, 2\\pi]$ 时，这变为：\n    $$ B_n = \\frac{(2\\pi)^{2n+1} (n!)^4}{(2n+1) [(2n)!]^3} \\sup_{x \\in [0, 2\\pi]} |f^{(2n)}(x)| $$\n    主要挑战是计算 $(2n)$ 阶导数 $f^{(2n)}(x)$ 并找到其上确界。直接的解析方法极为繁琐。因此我们设计一个计算策略。\n\n    令 $D_k(x) = \\frac{f^{(k)}(x)}{e^{\\cos(x)}}$。使用乘法法则，我们可以推导出 $D_k(x)$ 的递推关系：\n    $$ f^{(k+1)}(x) = \\frac{d}{dx} \\left( e^{\\cos(x)} D_k(x) \\right) = e^{\\cos(x)}(-\\sin(x))D_k(x) + e^{\\cos(x)}D_k'(x) $$\n    两边除以 $e^{\\cos(x)}$ 得到递推式：\n    $$ D_{k+1}(x) = D_k'(x) - \\sin(x)D_k(x) $$\n    初始条件为 $D_0(x) = f^{(0)}(x)/f(x) = 1$。每个 $D_k(x)$ 都是 $\\sin(x)$ 和 $\\cos(x)$ 的多项式。我们将实现一个类似于符号微分的程序，以生成 $D_{2n}(x)$ 所需的系数。\n\n    一旦获得了 $D_{2n}(x)$ 的表达式，函数 $g(x) = |f^{(2n)}(x)| = |e^{\\cos(x)} D_{2n}(x)|$ 便可以进行数值计算。然后可以使用数值优化技术找到上确界 $\\sup_{x \\in [0, 2\\pi]} g(x)$。由于 $f^{(2n)}(x)$ 是一个周期为 $2\\pi$ 的偶函数，其在 $[0, 2\\pi]$ 上的上确界与其在 $[0, \\pi]$ 上的上确界相同。我们将通过计算找到 $g(x)$ 在 $[0, \\pi]$ 上的最大值，根据问题陈述，这是一种有效的方法。\n\n5.  **上界验证**\n    最后一步是比较计算出的绝对误差 $E_{\\mathrm{abs}}$ 与理论上界 $B_n$，并确定不等式 $E_{\\mathrm{abs}} \\le B_n$ 是否成立。如果成立，我们将一个二进制标志设置为 $1$，否则设置为 $0$。\n\n至此，理论框架完成。实现将通过为每个测试用例（$n=1, 3, 5$）执行这些步骤来进行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import i0, roots_legendre, factorial\nfrom scipy.optimize import minimize_scalar\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Solves the Gaussian quadrature problem for f(x) = e^cos(x) on [0, 2*pi].\n    \"\"\"\n\n    class SinCosPoly:\n        \"\"\"\n        A class to represent and manipulate polynomials of sin(x) and cos(x).\n        A polynomial is stored as a dictionary mapping (sin_power, cos_power)\n        to a coefficient.\n        \"\"\"\n        def __init__(self, terms=None):\n            self.terms = defaultdict(float)\n            if terms:\n                self.terms.update(terms)\n\n        def __add__(self, other):\n            new_terms = self.terms.copy()\n            for k, v in other.terms.items():\n                new_terms[k] += v\n            return SinCosPoly(new_terms)\n\n        def __sub__(self, other):\n            new_terms = self.terms.copy()\n            for k, v in other.terms.items():\n                new_terms[k] -= v\n            return SinCosPoly(new_terms)\n\n        def differentiate(self):\n            \"\"\"Differentiates the polynomial with respect to x.\"\"\"\n            new_terms = defaultdict(float)\n            for (i, j), c in self.terms.items():\n                if i > 0: # a*sin(x)^(a-1)*cos(x)\n                    new_terms[(i - 1, j + 1)] += c * i\n                if j > 0: # -b*sin(x)^(b+1)*cos(x)^(b-1)\n                    new_terms[(i + 1, j - 1)] -= c * j\n            return SinCosPoly(new_terms)\n\n        def multiply_by_sin(self):\n            \"\"\"Multiplies the polynomial by sin(x).\"\"\"\n            new_terms = defaultdict(float)\n            for (i, j), c in self.terms.items():\n                new_terms[(i + 1, j)] = c\n            return SinCosPoly(new_terms)\n\n        def evaluate(self, x):\n            \"\"\"Evaluates the polynomial at a given x.\"\"\"\n            sin_x = np.sin(x)\n            cos_x = np.cos(x)\n            total = 0.0\n            for (i, j), c in self.terms.items():\n                total += c * (sin_x ** i) * (cos_x ** j)\n            return total\n\n    # Memoization cache for the derivative polynomials D_k\n    d_poly_cache = {}\n    \n    def get_d_poly(k):\n        \"\"\"\n        Computes the k-th derivative polynomial D_k using recurrence.\n        D_{k+1} = D_k' - sin(x)*D_k\n        \"\"\"\n        if k in d_poly_cache:\n            return d_poly_cache[k]\n        if k == 0:\n            d_poly_cache[0] = SinCosPoly({(0, 0): 1.0})\n            return d_poly_cache[0]\n        \n        d_k_minus_1 = get_d_poly(k - 1)\n        d_k = d_k_minus_1.differentiate() - d_k_minus_1.multiply_by_sin()\n        d_poly_cache[k] = d_k\n        return d_k\n\n    def get_f_derivative(k):\n        \"\"\"\n        Returns a function that computes the k-th derivative of f(x) = e^cos(x).\n        \"\"\"\n        d_k_poly = get_d_poly(k)\n        \n        def f_k(x):\n            return np.exp(np.cos(x)) * d_k_poly.evaluate(x)\n            \n        return f_k\n\n    # Problem parameters\n    a, b = 0.0, 2 * np.pi\n    test_cases = [1, 3, 5]\n    results = []\n    \n    # Exact integral value I = 2*pi*I_0(1)\n    I_exact = 2 * np.pi * i0(1)\n\n    for n in test_cases:\n        # Task 1: Compute Gaussian quadrature approximation Q_n\n        nodes, weights = roots_legendre(n)\n        x_nodes = np.pi * (nodes + 1)\n        f_values = np.exp(np.cos(x_nodes))\n        Q_n = np.pi * np.sum(weights * f_values)\n\n        # Task 2: Exact value I (already computed)\n        \n        # Task 3: Compute absolute error E_abs\n        E_abs = np.abs(I_exact - Q_n)\n        \n        # Task 4: Compute theoretical error bound B_n\n        m = 2 * n\n        \n        # Factorial calculations\n        n_fact = factorial(n)\n        m_fact = factorial(m)\n\n        # Constant part of the error bound formula\n        bound_constant = ((b - a)**(m + 1) * n_fact**4) / \\\n                         ((m + 1) * m_fact**3)\n\n        # Find supremum of |f^(2n)(x)| on [0, 2*pi]\n        # Since f^(2n) is even and 2pi-periodic, we search on [0, pi]\n        f_2n = get_f_derivative(m)\n        \n        # We need to maximize |f_2n(x)|, which is equivalent to\n        # minimizing -|f_2n(x)|.\n        opt_res = minimize_scalar(lambda x: -np.abs(f_2n(x)),\n                                  bounds=(0, np.pi), method='bounded')\n        \n        # Supremum is the max of values at boundaries and found minimum\n        sup_f_2n_abs = max(np.abs(f_2n(0)), np.abs(f_2n(np.pi)), -opt_res.fun)\n\n        B_n = bound_constant * sup_f_2n_abs\n        \n        # Task 5: Determine if E_abs = B_n\n        is_within_bound = 1 if E_abs = B_n else 0\n\n        # Format results for output, rounding floats to 12 decimal places\n        case_result = [\n            n,\n            round(Q_n, 12),\n            round(I_exact, 12),\n            round(E_abs, 12),\n            round(B_n, 12),\n            is_within_bound\n        ]\n        results.append(case_result)\n\n    # Format the final output string exactly as specified.\n    # We construct the string representation manually to avoid unwanted characters.\n    inner_strings = []\n    for res in results:\n        # Format numbers to string with 12 decimal places\n        formatted_floats = [f\"{v:.12f}\" for v in res[1:5]]\n        inner_strings.append(f\"[{res[0]},{','.join(formatted_floats)},{res[5]}]\")\n    \n    output_str = f\"[{','.join(inner_strings)}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2419598"}, {"introduction": "当被积函数包含奇点时，如工程和物理中常见的对数奇点，标准求积法则可能会失效。本练习将引导你掌握一种高级技巧：通过巧妙的变量替换，将奇点分离到新的权函数中。这种方法使我们能够应用一个不同的、更适合该问题的高斯求积族（高斯-拉盖尔求积）[@problem_id:2419634]，这不仅解决了难题，更展示了从第一性原理出发设计定制化数值工具的强大能力。", "problem": "设计并实现一个完整的程序，推导并应用一种自定义的高斯求积法，以精确逼近以下形式的积分：\n$$I[f] = \\int_{0}^{1} \\ln(x)\\, f(x)\\, dx,$$\n其中 $f$ 在 $[0,1]$ 上是光滑的，且被积函数在 $x=0$ 处有一个对数奇点。你的推导必须从适用于计算工程和数值分析的基本原理出发，即：定积分的变量替换公式、正交多项式的性质，以及针对给定权函数的高斯求积的基本定义。你不得预先假设或陈述任何直接针对对数奇点的专用求积法则；相反，你必须通过将该积分转换为一个在无限区间上具有标准非负权函数的形式，然后应用适当的高斯求积法来推导出这样的法则。该方法必须基于所述原理进行逻辑论证，并保持科学上的现实性。\n\n实现要求：\n- 从 $I[f] = \\int_{0}^{1} \\ln(x)\\, f(x)\\, dx$ 出发，推导一个变量变换，将对数项移入一个定义在 $[0,\\infty)$ 上的积分的权函数中。\n- 识别与变换后的积分相匹配的、在 $[0,\\infty)$ 上的正交多项式族和权函数，并解释为什么相应的高斯求积法是合适的。\n- 实现一个函数，对于给定的正整数 $n$，使用为所推导的权函数量身定制的 $n$ 点高斯求积法，返回 $I[f]$ 的一个求积近似值 $Q_{n}[f]$。你可以使用编程环境中的任何标准例程来获取高斯求积的节点和权重。\n\n角度单位要求：\n- 当函数 $f$ 涉及正弦函数时，其参数应解释为弧度。例如，$f(x) = \\sin(\\pi x)$ 中的 $\\pi$ 使用的是弧度。\n\n测试套件：\n- 你的程序必须计算并返回以下五个测试用例的求积近似值 $Q_{n}[f]$：\n  1. $f(x) = 1$，其中 $n = 2$。\n  2. $f(x) = x$，其中 $n = 8$。\n  3. $f(x) = \\sin(\\pi x)$，其中 $n = 8$。\n  4. $f(x) = \\sin(\\pi x)$，其中 $n = 16$。\n  5. $f(x) = \\sin(\\pi x)$，其中 $n = 32$。\n- 所有计算都是无量纲的；没有物理单位。如前所述，对于三角函数，角度以弧度为单位。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的、按上述测试用例顺序排列的、以逗号分隔的结果列表。\n- 每个浮点数必须精确到小数点后 $12$ 位。\n- 例如，格式必须类似于 $[\\text{value\\_1},\\text{value\\_2},\\text{value\\_3},\\text{value\\_4},\\text{value\\_5}]$，其中每个 $\\text{value\\_k}$ 都四舍五入到小数点后 $12$ 位，并且不打印任何额外文本。\n\n这个问题具有普遍适用性：使用任何现代编程语言的开发者都可以实现变量替换，获取在 $[0,\\infty)$ 上适用于相应权函数的高斯求积节点和权重，在变换后的节点上计算 $f$ 的值，并构造加权和以生成所需的输出。最终答案是浮点数，因此是可量化的。\n\n你的最终程序必须是完整的，并且能够按规定在没有任何用户输入或外部数据的情况下运行，同时必须遵循上述确切的输出格式。", "solution": "该问题要求设计并实现一种数值求积方案，以逼近积分\n$$I[f] = \\int_{0}^{1} \\ln(x)\\, f(x)\\, dx$$\n其中函数 $f(x)$ 在区间 $[0,1]$ 上是光滑的。被积函数在 $x=0$ 处具有对数奇点，这使得标准的数值积分方法变得复杂。推导过程必须从基本原理出发，通过将该积分变换为适合标准高斯求积法则的形式。\n\n该问题陈述已经过验证，被认为是具有科学依据、适定且客观的。它为计算工程和数值分析中的一个标准问题提供了一套清晰、自洽的要求。因此，我们可以着手进行推导和求解。\n\n该方法的核心是应用变量替换，将给定的、定义在有限区间 $[0,1]$ 上且包含一个棘手的对数项的积分，变换为一个在无限区间 $[0, \\infty)$ 上且带有适合高斯求积的非负权函数的等价积分。\n\n让我们引入变量替换 $x = e^{-t}$。由此，我们得到 $dx = -e^{-t}\\, dt$。积分限也必须进行变换：\n- 当 $x \\to 0^{+}$ 时，我们有 $e^{-t} \\to 0^{+}$，这意味着 $t \\to \\infty$。\n- 当 $x \\to 1^{-}$ 时，我们有 $e^{-t} \\to 1^{-}$，这意味着 $t \\to 0^{+}$。\n\n将这些代入原始积分表达式，我们得到：\n$$I[f] = \\int_{\\infty}^{0} \\ln(e^{-t})\\, f(e^{-t})\\, (-e^{-t}\\, dt)$$\n$\\ln(e^{-t})$ 项简化为 $-t$。表达式变为：\n$$I[f] = \\int_{\\infty}^{0} (-t)\\, f(e^{-t})\\, (-e^{-t}\\, dt) = \\int_{\\infty}^{0} t\\, e^{-t}\\, f(e^{-t})\\, dt$$\n通过反转积分限，我们引入一个负号：\n$$I[f] = - \\int_{0}^{\\infty} t\\, e^{-t}\\, f(e^{-t})\\, dt$$\n这个变换后的积分形式为 $-\\int_{0}^{\\infty} w(t) g(t) dt$，其中权函数是 $w(t) = e^{-t}$，要积分的新函数是 $g(t) = t\\, f(e^{-t})$。权函数 $w(t) = e^{-t}$ 在定义域 $[0, \\infty)$ 上是非负的，这满足了应用标准高斯求积理论的要求。\n\n高斯求积是基于正交多项式族构建的。在区间 $[0, \\infty)$ 上关于权函数 $w(t) = e^{-t}$ 正交的多项式族是 **Laguerre 多项式**，记为 $L_n(t)$。相关的求积法则被称为 **Gauss-Laguerre 求积法**。\n\n$n$ 点 Gauss-Laguerre 求积公式将形如 $\\int_{0}^{\\infty} e^{-t} h(t) dt$ 的积分近似为一个加权和：\n$$\\int_{0}^{\\infty} e^{-t}\\, h(t)\\, dt \\approx \\sum_{i=1}^{n} w_i\\, h(t_i)$$\n其中 $t_i$ 是 $n$ 次 Laguerre 多项式 $L_n(t)$ 的根（节点），$w_i$ 是相应的求积权重。如果 $h(t)$ 是一个次数至多为 $2n-1$ 的多项式，则此近似是精确的。由于函数 $f(x)$ 被指定为光滑的，变换后的函数 $g(t) = t\\, f(e^{-t})$ 也是光滑的，因此我们可以预期当 $n$ 增加时，这种求积法会快速收敛。\n\n将此应用于我们变换后的积分，我们设 $h(t) = g(t) = t\\, f(e^{-t})$。因此，$I[f]$ 的求积近似值（我们将其表示为 $Q_n[f]$）为：\n$$Q_n[f] = - \\sum_{i=1}^{n} w_i\\, g(t_i)$$\n代入 $g(t_i)$ 的表达式：\n$$Q_n[f] = - \\sum_{i=1}^{n} w_i\\, t_i\\, f(e^{-t_i})$$\n这就是自定义求积法则的最终公式。计算 $Q_n[f]$ 的步骤如下：\n1. 对于给定的点数 $n$，获取 $n$ 点 Gauss-Laguerre 求积法则的节点 $t_i$ 和权重 $w_i$（针对标准权函数 $w(t)=e^{-t}$）。这些可以从标准的数值库中获得。\n2. 对于每个节点 $t_i$，计算对应的 $x_i = e^{-t_i}$ 的值。\n3. 在这些点 $x_i$ 上计算函数 $f$ 的值，即 $f(x_i)$。\n4. 计算总和 $\\sum_{i=1}^{n} w_i\\, t_i\\, f(x_i)$。\n5. 最终结果是该总和的负数。\n\n该过程被实现以评估指定的测试用例。对于 $f(x)=1$ 的情况，其解析解是 $I[1] = \\int_0^1 \\ln(x) dx = [x \\ln(x) - x]_0^1 = -1$。一个 $n$ 点的 Gauss-Laguerre 求积法对于次数最高为 $2n-1$ 的多项式是精确的。对于 $f(x)=1$，变换后的函数是 $g(t) = t f(e^{-t}) = t$。这是一个 $1$ 次多项式。当 $n=2$ 时，该求积法对于次数最高为 $2(2)-1=3$ 的多项式是精确的。由于 $1  3$，第一个测试用例的求积结果必须精确地是 $-1$。对于其他函数，该求积法提供一个近似值，其精度随 $n$ 的增加而提高。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_laguerre\n\ndef solve():\n    \"\"\"\n    Derives and applies a custom Gaussian quadrature for integrals with a logarithmic singularity.\n    \"\"\"\n\n    # Define the functions for the test suite.\n    def f1(x):\n        return 1.0\n\n    def f2(x):\n        return x\n\n    def f3(x):\n        return np.sin(np.pi * x)\n\n    # Test cases as tuples of (function, number of quadrature points n).\n    # The functions are passed as callables.\n    test_cases = [\n        (f1, 2),\n        (f2, 8),\n        (f3, 8),\n        (f3, 16),\n        (f3, 32),\n    ]\n\n    results = []\n    \n    for f_func, n in test_cases:\n        # Step 1: Obtain nodes (t_i) and weights (w_i) for n-point Gauss-Laguerre quadrature.\n        # The weight function for standard Laguerre polynomials is exp(-t) on [0, inf).\n        # This corresponds to alpha=0 in the generalized Laguerre polynomial L_n^(alpha).\n        nodes, weights = roots_laguerre(n)\n\n        # Step 2: Transform nodes t_i to x_i = exp(-t_i).\n        # The original integration variable x is on [0, 1].\n        x_vals = np.exp(-nodes)\n\n        # Step 3: Evaluate the function f at the transformed points x_i.\n        f_vals = f_func(x_vals)\n\n        # Step 4: Compute the quadrature sum.\n        # The formula is Q_n[f] = - sum_{i=1 to n} w_i * t_i * f(exp(-t_i)).\n        # Here, nodes are t_i, weights are w_i, and f_vals are f(exp(-t_i)).\n        quadrature_sum = np.sum(weights * nodes * f_vals)\n        \n        # Step 5: The final approximation is the negative of the sum.\n        result = -quadrature_sum\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Each floating-point number is formatted to 12 decimal places.\n    print(f\"[{','.join([f'{r:.12f}' for r in results])}]\")\n\nsolve()\n```", "id": "2419634"}]}