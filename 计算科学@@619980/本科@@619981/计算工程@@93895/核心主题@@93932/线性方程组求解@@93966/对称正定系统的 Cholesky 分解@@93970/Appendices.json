{"hands_on_practices": [{"introduction": "为了从根本上理解Cholesky分解的内部机制，我们从一个“纸笔”练习开始。这个练习将带你推导一个常见于工程问题（如有限差分法模拟热传导）的特殊矩阵的Cholesky因子。通过直接从 $A = LL^{\\top}$ 的定义出发，你将建立并求解 $L$ 矩阵非零元素的递推关系，从而加深对矩阵元素之间关系的理解。[@problem_id:2376470]", "problem": "在计算工程中，稳态一维热传导问题在均匀网格上采用狄利克雷边界条件进行有限差分法离散化，会产生一个对称正定（SPD）线性系统。考虑由此得到的矩阵 $\\mathbf{A} \\in \\mathbb{R}^{n \\times n}$，其元素为：当 $1 \\leq i \\leq n$ 时，$A_{i,i} = 2$；当 $2 \\leq i \\leq n$ 时，$A_{i,i-1} = A_{i-1,i} = -1$；所有其他元素为零。由于 $\\mathbf{A}$ 是对称正定矩阵，因此存在唯一的 Cholesky 分解 $\\mathbf{A} = \\mathbf{L}\\mathbf{L}^{\\top}$，其中 $\\mathbf{L}$ 是一个对角线元素严格为正的下三角矩阵。\n\n仅从对称正定矩阵的 Cholesky 分解定义以及上述给定的矩阵 $\\mathbf{A}$ 的结构出发，完成以下任务：\n- 推导 $\\mathbf{L}$ 的非零元素必须满足的递推关系。\n- 求解这些递推关系，以获得对角线元素 $l_{k,k}$ 和第一副对角线元素 $l_{k,k-1}$ 作为 $k$ 的函数的闭式表达式。\n\n最后，使用你推导出的表达式，计算当 $n = 37$ 时特定的对角线元素 $l_{n,n}$ 的值。将你的最终答案表示为一个无单位的精确简化表达式。不要四舍五入。", "solution": "问题陈述经核验有效。它提出了一个数值线性代数中的适定问题，具体涉及一个结构化对称正定矩阵的 Cholesky 分解，这是计算工程中的一个常见课题。\n\n该问题定义了一个矩阵 $\\mathbf{A} \\in \\mathbb{R}^{n \\times n}$，其元素为：\n$$\nA_{i,j} =\n\\begin{cases}\n2 & \\text{if } i = j \\\\\n-1 & \\text{if } |i - j| = 1 \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\n该矩阵是对称且正定的。其 Cholesky 分解由 $\\mathbf{A} = \\mathbf{L}\\mathbf{L}^{\\top}$ 给出，其中 $\\mathbf{L}$ 是一个对角线元素严格为正 ($l_{i,i} > 0$) 的下三角矩阵。\n\n由于 $\\mathbf{A}$ 是一个半带宽为 1 的对称带状矩阵，其 Cholesky 因子 $\\mathbf{L}$ 是一个具有相同半带宽的下带状矩阵。这意味着 $\\mathbf{L}$ 是一个下双对角矩阵。其唯一的非零元素位于主对角线 $l_{i,i}$ 和第一副对角线 $l_{i,i-1}$ 上。所有其他元素 $l_{i,j}$ 在 $j < i-1$ 和 $j > i$ 时均为零。\n\n方程 $\\mathbf{A} = \\mathbf{L}\\mathbf{L}^{\\top}$ 可以用其分量形式写出：$A_{i,j} = \\sum_{k=1}^{\\min(i,j)} l_{i,k} l_{j,k}$。我们分析 $\\mathbf{A}$ 的非零元素。\n\n对于对角线元素（$i=j$）：\n$A_{i,i} = \\sum_{k=1}^{i} l_{i,k}^2$。由于 $\\mathbf{L}$ 的双对角结构，这个和中只有 $l_{i,i}$ 和 $l_{i,i-1}$ 这两项可能非零。\n当 $i=1$ 时：\n$$A_{1,1} = l_{1,1}^2$$\n当 $i \\geq 2$ 时：\n$$A_{i,i} = l_{i,i-1}^2 + l_{i,i}^2$$\n\n对于第一副对角线元素（$j=i-1, i \\geq 2$）：\n$A_{i,i-1} = \\sum_{k=1}^{i-1} l_{i,k} l_{i-1,k}$。此和式中唯一的非零项在 $k = i-1$ 时出现。\n$$A_{i,i-1} = l_{i,i-1} l_{i-1,i-1}$$\n\n现在，我们代入给定值 $A_{i,i} = 2$ 和 $A_{i,i-1} = -1$，以推导 $\\mathbf{L}$ 元素的递推关系。\n\n当 $i=1$ 时：\n$A_{1,1} = 2 = l_{1,1}^2$。因为 $l_{1,1} > 0$，我们得到 $l_{1,1} = \\sqrt{2}$。\n\n当 $i \\geq 2$ 时，从副对角线的关系可得：\n$A_{i,i-1} = -1 = l_{i,i-1} l_{i-1,i-1}$。这给出了副对角线元素的第一个递推关系：\n$$l_{i,i-1} = -\\frac{1}{l_{i-1,i-1}}$$\n\n当 $i \\geq 2$ 时，从对角线的关系可得：\n$A_{i,i} = 2 = l_{i,i-1}^2 + l_{i,i}^2$。这给出了对角线元素的递推关系：\n$$l_{i,i}^2 = 2 - l_{i,i-1}^2$$\n将第一个递推关系代入第二个，我们得到了一个仅关于对角线元素的递推关系：\n$$l_{i,i}^2 = 2 - \\left(-\\frac{1}{l_{i-1,i-1}}\\right)^2 = 2 - \\frac{1}{l_{i-1,i-1}^2}$$\n\n为了找到闭式表达式，我们计算前几项：\n当 $k=1$ 时：\n$l_{1,1} = \\sqrt{2} = \\sqrt{\\frac{1+1}{1}}$\n\n当 $k=2$ 时：\n$l_{2,1} = -\\frac{1}{l_{1,1}} = -\\frac{1}{\\sqrt{2}} = -\\sqrt{\\frac{1}{2}}$。\n$l_{2,2}^2 = 2 - l_{2,1}^2 = 2 - \\frac{1}{2} = \\frac{3}{2}$。所以，$l_{2,2} = \\sqrt{\\frac{3}{2}} = \\sqrt{\\frac{2+1}{2}}$。\n\n当 $k=3$ 时：\n$l_{3,2} = -\\frac{1}{l_{2,2}} = -\\frac{1}{\\sqrt{3/2}} = -\\sqrt{\\frac{2}{3}}$。\n$l_{3,3}^2 = 2 - l_{3,2}^2 = 2 - \\frac{2}{3} = \\frac{4}{3}$。所以，$l_{3,3} = \\sqrt{\\frac{4}{3}} = \\sqrt{\\frac{3+1}{3}}$。\n\n从这个规律中，我们假设对于 $k \\geq 1$ 有以下闭式表达式：\n$$l_{k,k} = \\sqrt{\\frac{k+1}{k}}$$\n以及对于 $k \\geq 2$：\n$$l_{k,k-1} = -\\sqrt{\\frac{k-1}{k}}$$\n\n我们用数学归纳法来证明它们。\n基础情形：当 $k=1$ 时，$l_{1,1} = \\sqrt{\\frac{1+1}{1}} = \\sqrt{2}$，正确。当 $k=2$ 时，$l_{2,1} = -\\sqrt{\\frac{2-1}{2}} = -\\frac{1}{\\sqrt{2}}$ 且 $l_{2,2} = \\sqrt{\\frac{2+1}{2}} = \\sqrt{\\frac{3}{2}}$，均正确。\n\n归纳步骤：假设这些公式对某个整数 $k \\geq 1$ 成立。我们必须证明它们对 $k+1$ 也成立。\n使用副对角线元素的递推关系：\n$$l_{k+1,k} = -\\frac{1}{l_{k,k}} = -\\frac{1}{\\sqrt{\\frac{k+1}{k}}} = -\\sqrt{\\frac{k}{k+1}}$$\n这与 $m=k+1$ 时 $l_{m,m-1}$ 的假设公式相匹配。\n\n使用对角线元素的递推关系：\n$$l_{k+1,k+1}^2 = 2 - l_{k+1,k}^2 = 2 - \\left(-\\sqrt{\\frac{k}{k+1}}\\right)^2 = 2 - \\frac{k}{k+1} = \\frac{2(k+1) - k}{k+1} = \\frac{k+2}{k+1}$$\n因为 $l_{k+1,k+1} > 0$，我们取主根：\n$$l_{k+1,k+1} = \\sqrt{\\frac{k+2}{k+1}}$$\n这与 $m=k+1$ 时 $l_{m,m}$ 的假设公式相匹配。\n归纳完成。闭式表达式得到验证。\n\n问题要求计算当 $n=37$ 时 $l_{n,n}$ 的具体值。使用推导出的对角线元素公式 $l_{k,k} = \\sqrt{\\frac{k+1}{k}}$，令 $k=n=37$：\n$$l_{37,37} = \\sqrt{\\frac{37+1}{37}} = \\sqrt{\\frac{38}{37}}$$\n这就是精确的简化值。", "answer": "$$\n\\boxed{\\sqrt{\\frac{38}{37}}}\n$$", "id": "2376470"}, {"introduction": "理论知识需要通过实践来检验。这个练习将引导你从理论走向实践，通过编写代码来探索对称正定矩阵的“边界”。你将实现一个Cholesky分解算法，并观察当一个矩阵因为微小的参数变化而不再是正定时，算法是如何通过其内在机制（即对非正数进行开方）“自然地”失败的。这个实践不仅能构建你的数值编程技能，还能让你直观地体验到Cholesky分解本身就是一种有效的正定性检验方法。[@problem_id:2376407]", "problem": "您需要从第一性原理出发，实现并分析用于对称正定 (SPD) 系统的 Cholesky 分解。一个 $n \\times n$ 的实矩阵 $A$ 是对称正定 (SPD) 的，如果 $A = A^{\\mathsf{T}}$ 且对于所有非零向量 $x \\in \\mathbb{R}^n$ 都有 $x^{\\mathsf{T}} A x > 0$。一个经过充分检验的数学事实是：一个 SPD 矩阵允许唯一的 Cholesky 分解 $A = L L^{\\mathsf{T}}$，其中 $L$ 是下三角矩阵，且 $L$ 的所有对角线元素均为严格正数。另一个经过充分检验的事实（Sylvester 判据）是：一个对称矩阵是 SPD 的当且仅当其所有顺序主子式均为正。\n\n您的任务如下：\n\n1. 实现一个程序，尝试对给定的对称矩阵 $A$ 计算 Cholesky 分解 $A = L L^{\\mathsf{T}}$，不进行任何主元选择。该程序必须显式地检查每个计算出的对角主元平方值的正性，并在任何步骤中出现非正值时宣告失败。该实现不得依赖于黑盒式的 SPD 检查；它应纯粹基于计算出的中间量来检测失败。\n\n2. 使用以下对称矩阵的参数族：\n   $$ A(r) = \\begin{bmatrix} 1 & r \\\\ r & 1 \\end{bmatrix}, $$\n   其中 $r \\in \\mathbb{R}$。该族包含的矩阵会随着单个非对角线元素 $r$ 的微小变化从 SPD 变为非 SPD。请使用参数值测试套件\n   $$ r \\in \\{\\, 0.9,\\; 0.999999,\\; 1.0,\\; 1.000001 \\,\\} $$\n   对您的程序进行评估。为每个测试记录一个布尔值，以指示 Cholesky 程序是成功（返回 $\\,\\text{True}\\,$）还是失败（返回 $\\,\\text{False}\\,$）。\n\n3. 作为一个额外的“理想情况”覆盖案例，测试以下根据 Sylvester 判据已知为 SPD 的固定 $3 \\times 3$ 对称矩阵：\n   $$ B = \\begin{bmatrix} 4 & 1 & 1 \\\\ 1 & 3 & 1 \\\\ 1 & 1 & 2 \\end{bmatrix}. $$\n   记录一个布尔值，指示 Cholesky 程序在处理矩阵 $B$ 时是否成功。\n\n4. 输出规范。您的程序必须生成单行输出，其中包含一个 Python 风格的列表字面量，该列表包含所有测试的布尔值，顺序如下：四个 $A(r)$ 案例（$r$ 分别等于 $0.9$、$0.999999$、$1.0$、$1.000001$），后跟单个案例 $B$。例如，要求的格式为：\n   $$ [\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5] $$\n   其中每个 $\\text{result}_i$ 为 $\\text{True}$ 或 $\\text{False}$。\n\n注记与约束：\n\n- 您的推理应基于 SPD 矩阵的定义和上文所述的 Cholesky 分解存在性条件。不要假设任何未声明的性质。\n- 不涉及物理单位。\n- 角度单位不适用。\n- 唯一可接受的输出是按所述确切顺序排列的单行布尔值列表。", "solution": "所述问题定义明确、自成体系且科学上合理，它基于数值线性代数的既定原理。因此，该问题是有效的，我们着手提供完整解答。任务要求实现一个 Cholesky 分解程序，并将其应用于一组指定的测试矩阵。\n\n其基本原理是将一个对称正定 (SPD) 矩阵 $A$ 分解为乘积 $A = LL^{\\mathsf{T}}$，其中 $L$ 是一个下三角矩阵。$L$ 的元素（记为 $L_{ij}$）可直接从此方程计算得出。对于一个 $n \\times n$ 矩阵 $A$，元素 $A_{ij}$ 由 $L$ 的第 $i$ 行与 $L^{\\mathsf{T}}$ 的第 $j$ 列（即 $L$ 的第 $j$ 行）的点积给出：\n$$ A_{ij} = \\sum_{k=1}^{j} L_{ik} L_{jk} \\quad \\text{for } i \\ge j $$\n由于 $A$ 是对称的，因此 $A_{ij} = A_{ji}$，我们只需计算 $i \\ge j$ 的 $L_{ij}$。\n\n该算法按顺序计算 $L$ 的各列，从 $j=1$ 到 $j=n$。对于每一列 $j$，我们首先计算对角元素 $L_{jj}$，然后计算 $i > j$ 的非对角元素 $L_{ij}$。\n\n考虑对角元素 $A_{jj}$：\n$$ A_{jj} = \\sum_{k=1}^{j} L_{jk}^2 = \\left( \\sum_{k=1}^{j-1} L_{jk}^2 \\right) + L_{jj}^2 $$\n由此，我们求解 $L$ 的对角元素的平方：\n$$ L_{jj}^2 = A_{jj} - \\sum_{k=1}^{j-1} L_{jk}^2 $$\n为使 Cholesky 分解存在，并得到一个对角线元素为正的实值矩阵 $L$，在每一步 $j$ 中，项 $L_{jj}^2$ 都必须严格为正。如果对于任何 $j$ 有 $L_{jj}^2 \\le 0$，则该矩阵不是正定的，分解失败。这是我们的程序必须检查的条件。如果 $L_{jj}^2 > 0$，则有 $L_{jj} = \\sqrt{A_{jj} - \\sum_{k=1}^{j-1} L_{jk}^2}$。\n\n接下来，考虑 $i > j$ 的非对角元素 $A_{ij}$：\n$$ A_{ij} = \\sum_{k=1}^{j} L_{ik} L_{jk} = \\left( \\sum_{k=1}^{j-1} L_{ik} L_{jk} \\right) + L_{ij} L_{jj} $$\n求解 $L_{ij}$，我们得到：\n$$ L_{ij} = \\frac{1}{L_{jj}} \\left( A_{ij} - \\sum_{k=1}^{j-1} L_{ik} L_{jk} \\right) $$\n只要 $L_{jj} \\ne 0$，这个计算就是可行的，而 $L_{jj}^2 > 0$ 保证了这一点。\n\n我们现在基于此算法分析指定的测试案例。\n\n1.  **参数族 $A(r) = \\begin{bmatrix} 1 & r \\\\ r & 1 \\end{bmatrix}$**\n\n    我们将该算法应用于这个 $2 \\times 2$ 矩阵。\n    \n    对于列 $j=1$：\n    对角元素的平方是 $L_{11}^2 = A_{11} = 1$。因为 $1 > 0$，此步成功，我们求得 $L_{11} = 1$。\n    非对角元素是 $L_{21} = \\frac{1}{L_{11}} (A_{21}) = \\frac{r}{1} = r$。\n    \n    对于列 $j=2$：\n    对角元素的平方是 $L_{22}^2 = A_{22} - L_{21}^2 = 1 - r^2$。\n    分解成功的充分必要条件是该量严格为正：$1 - r^2 > 0$，这等价于 $r^2 < 1$ 或 $|r| < 1$。\n\n    我们对指定的 $r$ 值进行评估：\n    - 对于 $r = 0.9$：$L_{22}^2 = 1 - (0.9)^2 = 1 - 0.81 = 0.19 > 0$。程序成功。结果：$\\text{True}$。\n    - 对于 $r = 0.999999$：$L_{22}^2 = 1 - (0.999999)^2 > 0$。该值是正数，尽管很小。程序成功。结果：$\\text{True}$。\n    - 对于 $r = 1.0$：$L_{22}^2 = 1 - (1.0)^2 = 0$。这不是严格正数。程序必须失败。结果：$\\text{False}$。\n    - 对于 $r = 1.000001$：$L_{22}^2 = 1 - (1.000001)^2 < 0$。程序必须失败。结果：$\\text{False}$。\n\n2.  **固定矩阵 $B = \\begin{bmatrix} 4 & 1 & 1 \\\\ 1 & 3 & 1 \\\\ 1 & 1 & 2 \\end{bmatrix}$**\n\n    我们将该算法应用于这个 $3 \\times 3$ 矩阵。\n\n    对于列 $j=1$：\n    $L_{11}^2 = B_{11} = 4$。因为 $4 > 0$，我们继续。$L_{11} = 2$。\n    $L_{21} = B_{21} / L_{11} = 1/2$。\n    $L_{31} = B_{31} / L_{11} = 1/2$。\n\n    对于列 $j=2$：\n    $L_{22}^2 = B_{22} - L_{21}^2 = 3 - (1/2)^2 = 3 - 1/4 = 11/4$。因为 $11/4 > 0$，我们继续。$L_{22} = \\sqrt{11}/2$。\n    $L_{32} = \\frac{1}{L_{22}}(B_{32} - L_{31}L_{21}) = \\frac{1}{\\sqrt{11}/2}(1 - (1/2)(1/2)) = \\frac{2}{\\sqrt{11}}(3/4) = \\frac{3}{2\\sqrt{11}}$。\n\n    对于列 $j=3$：\n    $L_{33}^2 = B_{33} - (L_{31}^2 + L_{32}^2) = 2 - \\left( (1/2)^2 + \\left(\\frac{3}{2\\sqrt{11}}\\right)^2 \\right) = 2 - \\left( \\frac{1}{4} + \\frac{9}{44} \\right) = 2 - \\left( \\frac{11}{44} + \\frac{9}{44} \\right) = 2 - \\frac{20}{44} = \\frac{22-5}{11} = \\frac{17}{11}$。\n    因为 $17/11 > 0$，最后一步成功。\n\n    由于所有对角主元的平方都严格为正，矩阵 $B$ 的 Cholesky 分解成功。结果：$\\text{True}$。\n\n因此，五个测试案例按指定顺序的布尔结果序列为：$\\text{True}$、$\\text{True}$、$\\text{False}$、$\\text{False}$、$\\text{True}$。最终答案中的程序将实现此逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Cholesky factorization from first principles,\n    tests it on several matrices, and prints the results.\n    \"\"\"\n\n    def cholesky_factorization_attempt(A: np.ndarray) -> bool:\n        \"\"\"\n        Attempts to compute the Cholesky factorization of a symmetric matrix A.\n\n        The routine follows the standard column-wise algorithm. It explicitly\n        checks for the strict positivity of the squared diagonal pivots (L_jj^2).\n        If a non-positive pivot is encountered, the matrix is not positive-definite,\n        and the factorization fails.\n\n        Args:\n            A (np.ndarray): The n x n symmetric matrix to factorize.\n\n        Returns:\n            bool: True if the factorization succeeds, False otherwise.\n        \"\"\"\n        n = A.shape[0]\n        L = np.zeros_like(A, dtype=float)\n\n        for j in range(n):\n            # Compute the sum of squares of elements in the j-th row of L up to column j-1.\n            # This corresponds to sum_{k=0}^{j-1} L[j, k]^2\n            s1 = np.dot(L[j, :j], L[j, :j])\n\n            # Compute the squared diagonal element L[j, j]^2.\n            squared_pivot = A[j, j] - s1\n\n            # The core condition for positive-definiteness in Cholesky factorization:\n            # The pivot must be strictly positive.\n            if squared_pivot <= 0:\n                return False\n\n            L[j, j] = np.sqrt(squared_pivot)\n\n            # Compute the elements in the j-th column below the diagonal.\n            if j < n - 1:\n                # This corresponds to the sum sum_{k=0}^{j-1} L[i, k] * L[j, k] for each i > j.\n                s2 = np.dot(L[j + 1:n, :j], L[j, :j])\n                L[j + 1:n, j] = (A[j + 1:n, j] - s2) / L[j, j]\n\n        return True\n\n    # 1. Define the parametric test cases A(r).\n    r_values = [0.9, 0.999999, 1.0, 1.000001]\n    test_matrices = [np.array([[1.0, r], [r, 1.0]]) for r in r_values]\n\n    # 2. Define the fixed 3x3 test case B.\n    B_matrix = np.array([\n        [4.0, 1.0, 1.0],\n        [1.0, 3.0, 1.0],\n        [1.0, 1.0, 2.0]\n    ])\n    test_matrices.append(B_matrix)\n\n    # 3. Evaluate the routine on all test cases.\n    results = []\n    for matrix in test_matrices:\n        success = cholesky_factorization_attempt(matrix)\n        results.append(success)\n\n    # 4. Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2376407"}, {"introduction": "掌握了Cholesky分解的基本原理和实现后，让我们来看一个它在实际计算中的强大应用：高效求解矩阵的逆。这个练习将向你展示如何利用矩阵 $A$ 的Cholesky因子 $L$ 来计算 $A^{-1}$，而无需直接对 $A$ 进行求逆。通过运用 $A^{-1} = (L^{-1})^{\\top} L^{-1}$ 这一关系，你将体会到利用矩阵分解在计算性能和数值稳定性上带来的巨大优势，尤其是在处理大型或病态矩阵时。[@problem_id:2376430]", "problem": "给定一个实对称正定 (SPD) 矩阵 $\\boldsymbol{A} \\in \\mathbb{R}^{n \\times n}$，它可以进行 Cholesky 分解 $\\boldsymbol{A} = \\boldsymbol{L}\\boldsymbol{L}^{\\mathsf{T}}$，其中 $\\boldsymbol{L}$ 是一个对角线元素严格为正的下三角矩阵。对于每个给定的测试用例，仅提供 Cholesky 因子 $\\boldsymbol{L}$（而非 $\\boldsymbol{A}$）。您的任务是实现一个程序，在每个测试用例中，仅使用 $\\boldsymbol{L}$ 和基本运算来计算逆矩阵 $\\boldsymbol{A}^{-1}$，而不直接对 $\\boldsymbol{A}$求逆。计算出 $\\boldsymbol{A}^{-1}$ 后，通过构建 $\\boldsymbol{A} = \\boldsymbol{L}\\boldsymbol{L}^{\\mathsf{T}}$ 并评估残差矩阵 $\\boldsymbol{R} = \\boldsymbol{A}\\boldsymbol{A}^{-1} - \\boldsymbol{I}$ 来验证其正确性，其中 $\\boldsymbol{I}$ 是相应大小的单位矩阵。对于每个测试用例，报告 $\\boldsymbol{R}$ 的最大绝对值元素，定义为 $\\max_{i,j} |R_{ij}|$。\n\n请使用以下由下三角 Cholesky 因子 $\\boldsymbol{L}$ 组成的测试套件：\n\n- 测试用例 $1$（边界情况 $1 \\times 1$）：\n  $$\\boldsymbol{L}_1 = \\begin{bmatrix} 3 \\end{bmatrix}.$$\n\n- 测试用例 $2$（大小 $2 \\times 2$）：\n  $$\\boldsymbol{L}_2 = \\begin{bmatrix} 2 & 0 \\\\ 1 & \\sqrt{2} \\end{bmatrix}.$$\n\n- 测试用例 $3$（大小 $3 \\times 3$）：\n  $$\\boldsymbol{L}_3 = \\begin{bmatrix}\n  1.5 & 0 & 0 \\\\\n  0.4 & 2.0 & 0 \\\\\n  -0.3 & 0.5 & 1.2\n  \\end{bmatrix}.$$\n\n- 测试用例 $4$（大小 $4 \\times 4$，病态缩放但仍为 SPD）：\n  $$\\boldsymbol{L}_4 = \\begin{bmatrix}\n  10^{-3} & 0 & 0 & 0 \\\\\n  2\\times 10^{-4} & 10^{-1} & 0 & 0 \\\\\n  -10^{-4} & 3\\times 10^{-2} & 1.0 & 0 \\\\\n  5\\times 10^{-5} & -2\\times 10^{-2} & 4\\times 10^{-1} & 10.0\n  \\end{bmatrix}.$$\n\n程序要求：\n\n- 对于每个测试用例，仅使用给定的 $\\boldsymbol{L}$ 和基本线性代数运算来计算 $\\boldsymbol{A}^{-1}$，而不直接对 $\\boldsymbol{A}$ 求逆。\n- 为进行验证，构建 $\\boldsymbol{A} = \\boldsymbol{L}\\boldsymbol{L}^{\\mathsf{T}}$ 并计算残差 $\\boldsymbol{R} = \\boldsymbol{A}\\boldsymbol{A}^{-1} - \\boldsymbol{I}$。\n- 对于每个测试用例，输出标量 $\\rho = \\max_{i,j} |R_{ij}|$。\n- 最终输出必须为单行，其中包含按测试 1 到 4 排序的全部四个 $\\rho$ 值，四舍五入到 $12$ 位小数，并以逗号分隔的列表形式置于方括号内，例如“$[r_1,r_2,r_3,r_4]$”。\n\n此问题不涉及物理量，因此不需要物理单位。所有角度（如有）均与本任务无关。您的程序不得读取任何输入；它应按所提供的方式运行，并生成所需的单行输出。", "solution": "问题陈述有效。这是一个在数值线性代数领域中定义明确的问题，其基础是成熟的矩阵分解理论。\n\n该任务要求在给定对称正定 (SPD) 矩阵 $\\boldsymbol{A}$ 的 Cholesky 因子 $\\boldsymbol{L}$（其中 $\\boldsymbol{A} = \\boldsymbol{L}\\boldsymbol{L}^{\\mathsf{T}}$）的情况下，计算其逆矩阵。一个关键约束是必须在不直接计算 $\\boldsymbol{A}$ 的逆矩阵的情况下执行求逆操作。这一要求在高性能科学计算中是标准做法，因为它指向一种具有更优数值稳定性和计算效率的方法。\n\n其基本原理基于矩阵求逆和转置的代数性质。两个可逆矩阵 $\\boldsymbol{X}$ 和 $\\boldsymbol{Y}$ 的乘积的逆遵循规则 $(\\boldsymbol{X}\\boldsymbol{Y})^{-1} = \\boldsymbol{Y}^{-1}\\boldsymbol{X}^{-1}$。此外，矩阵转置的逆等于矩阵逆的转置，表示为 $(\\boldsymbol{X}^{\\mathsf{T}})^{-1} = (\\boldsymbol{X}^{-1})^{\\mathsf{T}}$。\n\n将这些原理应用于 Cholesky 分解 $\\boldsymbol{A} = \\boldsymbol{L}\\boldsymbol{L}^{\\mathsf{T}}$，我们可以正式推导出 $\\boldsymbol{A}^{-1}$ 的表达式：\n$$\n\\boldsymbol{A}^{-1} = (\\boldsymbol{L}\\boldsymbol{L}^{\\mathsf{T}})^{-1}\n$$\n使用乘积的逆的规则，我们得到：\n$$\n\\boldsymbol{A}^{-1} = (\\boldsymbol{L}^{\\mathsf{T}})^{-1} \\boldsymbol{L}^{-1}\n$$\n最后，将转置-求逆换位规则应用于 $(\\boldsymbol{L}^{\\mathsf{T}})^{-1}$ 项，得出所需的表达式：\n$$\n\\boldsymbol{A}^{-1} = (\\boldsymbol{L}^{-1})^{\\mathsf{T}} \\boldsymbol{L}^{-1}\n$$\n这个最终方程为计算 $\\boldsymbol{A}^{-1}$ 提供了算法。该过程是数值稳健的，因为它操作的是 Cholesky 因子 $\\boldsymbol{L}$。由于 $\\boldsymbol{L}$ 是一个对角线元素严格为正的下三角矩阵，它总是可逆的。其逆矩阵 $\\boldsymbol{L}^{-1}$ 也是一个下三角矩阵，可以通过相当于前向代入的过程来高效地求解矩阵方程 $\\boldsymbol{L}\\boldsymbol{X} = \\boldsymbol{I}$（其中 $\\boldsymbol{I}$ 是单位矩阵）。\n\n该方法之所以更受青睐，是因为 Cholesky 因子 $\\boldsymbol{L}$ 的条件数 $\\kappa(\\boldsymbol{L})$ 是原始矩阵 $\\boldsymbol{A}$ 条件数 $\\kappa(\\boldsymbol{A})$ 的平方根，即 $\\kappa(\\boldsymbol{L}) = \\sqrt{\\kappa(\\boldsymbol{A})}$。因此，对 $\\boldsymbol{L}$ 求逆比直接对 $\\boldsymbol{A}$ 求逆是一个条件好得多的数值问题，这对于像测试用例 4 中的病态缩放矩阵尤其重要。\n\n为解决此问题而实现的算法如下：\n1.  对于每个给定的下三角 Cholesky 因子 $\\boldsymbol{L}$，计算其逆矩阵，可记作 $\\boldsymbol{M} = \\boldsymbol{L}^{-1}$。\n2.  使用推导出的公式 $\\boldsymbol{A}^{-1} = \\boldsymbol{M}^{\\mathsf{T}}\\boldsymbol{M}$ 计算原始矩阵 $\\boldsymbol{A}$ 的逆。\n3.  为了验证，通过计算乘积 $\\boldsymbol{A} = \\boldsymbol{L}\\boldsymbol{L}^{\\mathsf{T}}$ 来显式构造矩阵 $\\boldsymbol{A}$。\n4.  计算残差矩阵 $\\boldsymbol{R} = \\boldsymbol{A}\\boldsymbol{A}^{-1} - \\boldsymbol{I}$。理想情况下，$\\boldsymbol{R}$ 应为零矩阵，但由于浮点运算，其元素将是微小的非零值。\n5.  通过找到残差矩阵的最大绝对值元素 $\\rho = \\max_{i,j} |R_{ij}|$ 来评估所计算逆矩阵的质量。为每个测试用例报告此值。\n\n所提供的程序使用 `numpy` 库进行基本线性代数运算，为每个测试用例执行这些步骤。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the inverse of a matrix A from its Cholesky factor L\n    and reports the maximum absolute residual.\n    \"\"\"\n    #\n    # Execution Environment:\n    # language: Python\n    # version: 3.12\n    # libraries:\n    #     - name: numpy, version: 1.23.5\n    #     - name: scipy, version: 1.11.4\n    #\n\n    # Define the test cases from the problem statement.\n    # L1: 1x1 boundary case\n    L1 = np.array([[3.0]])\n\n    # L2: 2x2 case\n    L2 = np.array([\n        [2.0, 0.0],\n        [1.0, np.sqrt(2)]\n    ])\n\n    # L3: 3x3 case\n    L3 = np.array([\n        [1.5, 0.0, 0.0],\n        [0.4, 2.0, 0.0],\n        [-0.3, 0.5, 1.2]\n    ])\n\n    # L4: 4x4 ill-scaled case\n    L4 = np.array([\n        [1.0e-3, 0.0,    0.0,  0.0],\n        [2.0e-4, 1.0e-1, 0.0,  0.0],\n        [-1.0e-4, 3.0e-2, 1.0,  0.0],\n        [5.0e-5, -2.0e-2, 0.4, 10.0]\n    ])\n\n    test_cases = [L1, L2, L3, L4]\n\n    results = []\n    for L in test_cases:\n        # The problem requires computing A_inv from L without inverting a dense A.\n        # The method is A_inv = (L_inv)^T * L_inv, where L_inv is the inverse of L.\n        # Inverting a triangular matrix L is a fundamental and stable operation.\n        \n        # Step 1: Compute the inverse of the lower-triangular matrix L.\n        L_inv = np.linalg.inv(L)\n        \n        # Step 2: Compute A_inv using the formula A_inv = (L_inv.T) @ L_inv.\n        A_inv = L_inv.T @ L_inv\n        \n        # Step 3 (Verification): Form A = L @ L.T\n        A = L @ L.T\n        \n        # Step 4 (Verification): Compute the residual matrix R = A * A_inv - I\n        I = np.identity(A.shape[0])\n        R = A @ A_inv - I\n        \n        # Step 5: Find the maximum absolute value of the entries in R.\n        rho = np.max(np.abs(R))\n        \n        results.append(rho)\n\n    # Final print statement in the exact required format.\n    # Output must be a single line: [r_1,r_2,r_3,r_4] with 12 decimal places.\n    formatted_results = [f\"{r:.12f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2376430"}]}