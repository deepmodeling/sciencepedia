{"hands_on_practices": [{"introduction": "本练习将数值稳定性的抽象概念带入生态系统建模的具体世界中。我们将使用简单的前向欧拉方法来模拟一个捕食者-被捕食者系统。通过这个实践 [@problem_id:2437681]，你将亲眼见证一个不恰当的大时间步长 $h$ 如何导致数值不稳定性，产生像负种群数量这样物理上不可能的结果，并理解为什么在数值求解微分方程时，稳定性是首要关注的问题。", "problem": "考虑由 Lotka-Volterra 常微分方程 (ODE) 建模的经典捕食者-猎物动力学：\n$$\n\\begin{aligned}\n\\frac{dx}{dt} &= a\\,x - b\\,x\\,y,\\\\\n\\frac{dy}{dt} &= -c\\,y + d\\,x\\,y,\n\\end{aligned}\n$$\n其中 $x$ 表示猎物种群，$y$ 表示捕食者种群，$a,b,c,d$ 是严格为正的实数参数。定义时间步长为 $h>0$、时间范围为 $T>0$ 的前向欧拉迭代过程，其递推关系为\n$$\n\\begin{aligned}\nx_{n+1} &= x_n + h\\left(a\\,x_n - b\\,x_n\\,y_n\\right) = x_n\\left(1 + h(a - b\\,y_n)\\right),\\\\\ny_{n+1} &= y_n + h\\left(-c\\,y_n + d\\,x_n\\,y_n\\right) = y_n\\left(1 + h(-c + d\\,x_n)\\right),\n\\end{aligned}\n$$\n对于整数索引 $n=0,1,\\dots,N-1$，其中 $N=T/h$ 假定为整数，初始条件为 $x_0>0$, $y_0>0$。在这种离散时间设置中，$x_n$ 或 $y_n$ 的负值代表物理上不可能的负种群，并被解释为由过大的时间步长 $h$ 引起的数值不稳定性。\n\n对于下面的每个测试用例，使用指定的参数和初始条件，模拟从 $n=0$ 到 $n=N$（包括两个端点）的前向欧拉递推。对于每次模拟，确定：\n- 一个布尔标志，指示在任何迭代中是否遇到任何严格为负的种群（即，是否存在索引 $n$ 使得 $x_n<0$ 或 $y_n<0$），\n- $\\{x_n\\}_{n=0}^N$ 的最小值，\n- $\\{y_n\\}_{n=0}^N$ 的最小值。\n\n报告最小值，使用标准舍入规则保留六位小数。此任务不涉及物理单位。不涉及角度。所有输出都是无单位的实数。\n\n所有用例使用相同的参数值 $a=1$, $b=0.5$, $c=1$, $d=0.5$。该测试套件包含四个用例，旨在探测一个典型的良好解析场景、一个边界条件和不稳定的区域：\n\n- 用例 1 (小步长，良好解析)：$x_0=10$, $y_0=5$, $h=0.01$, $T=0.01$。\n- 用例 2 (猎物更新因子的边界条件，第一步结果为零)：$x_0=8$, $y_0=12$, $h=0.2$, $T=0.2$。\n- 用例 3 (大步长导致猎物立即变为负值)：$x_0=8$, $y_0=30$, $h=0.2$, $T=0.2$。\n- 用例 4 (极大步长导致捕食者和猎物都变为负值)：$x_0=0.5$, $y_0=10$, $h=2.0$, $T=2.0$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个结果都是一个列表，按 [negativity_flag, min_x, min_y] 的顺序包含三个条目。例如，一个包含四个用例的有效输出格式是\n$$\n[\\,[\\text{True},-1.234000,0.500000],[\\text{False},0.000000,2.000000],[\\text{False},1.000000,1.000000],[\\text{True},-0.100000,-0.200000]\\,].\n$$", "solution": "问题陈述已经过严格验证，并被认定为有效。这是一个计算数学中的适定问题，特别是将数值方法应用于常微分方程组。所有参数、初始条件和程序步骤都得到了明确的定义。该问题具有科学依据、客观且自成体系。\n\n任务是使用前向欧拉方法模拟 Lotka-Volterra 捕食者-猎物模型。该连续模型由以下常微分方程组给出：\n$$\n\\begin{aligned}\n\\frac{dx}{dt} &= a\\,x - b\\,x\\,y \\\\\n\\frac{dy}{dt} &= -c\\,y + d\\,x\\,y\n\\end{aligned}\n$$\n其中 $x(t)$ 是猎物种群，$y(t)$ 是捕食者种群，$a, b, c, d$ 是正实数参数。\n\n前向欧拉方法以时间步长 $h > 0$ 对该系统进行离散化。时间步 $n+1$ 的种群由时间步 $n$ 的种群通过以下递推关系计算得出：\n$$\n\\begin{aligned}\nx_{n+1} &= x_n + h(a\\,x_n - b\\,x_n\\,y_n) = x_n\\left(1 + h(a - b\\,y_n)\\right) \\\\\ny_{n+1} &= y_n + h(-c\\,y_n + d\\,x_n\\,y_n) = y_n\\left(1 + h(-c + d\\,x_n)\\right)\n\\end{aligned}\n$$\n模拟从初始状态 $(x_0, y_0)$ 开始，对 $n=0, 1, \\dots, N-1$ 进行，其中 $N=T/h$ 是达到时间范围 $T$ 所需的总步数。为具有物理意义，所有 $n$ 的种群数量必须保持非负，即 $x_n \\ge 0$ 和 $y_n \\ge 0$。\n\n如果时间步长 $h$ 过大，就会出现表现为负种群数量的数值不稳定性。给定 $x_n > 0$ 和 $y_n > 0$，确保 $x_{n+1} \\ge 0$ 和 $y_{n+1} \\ge 0$ 的条件是：\n$$\n\\begin{aligned}\n1 + h(a - b\\,y_n) \\ge 0 \\\\\n1 + h(-c + d\\,x_n) \\ge 0\n\\end{aligned}\n$$\n如果 $a - b\\,y_n < 0$，第一个条件对时间步长施加了稳定性约束：$h \\le \\frac{1}{b\\,y_n - a}$。类似地，如果 $-c + d\\,x_n < 0$，第二个条件施加了 $h \\le \\frac{1}{c - d\\,x_n}$。如果违反这些条件，前向欧拉格式可能会产生不符合物理实际的负值结果。\n\n每个测试用例的算法如下：\n1. 设置常量参数：$a=1$, $b=0.5$, $c=1$, $d=0.5$。\n2. 对于给定的初始条件 $(x_0, y_0)$ 和时间参数 $(h, T)$ 的用例，计算步数 $N = T/h$。对于所有提供的用例，$N=1$。\n3. 生成种群序列 $\\{x_n\\}_{n=0}^N$ 和 $\\{y_n\\}_{n=0}^N$。由于 $N=1$，我们仅从 $(x_0, y_0)$ 计算 $(x_1, y_1)$。\n4. 分析完整的迭代序列 $\\{x_0, x_1\\}$ 和 $\\{y_0, y_1\\}$。\n5. 确定是否有任何值严格为负，即 $x_1<0$ 或 $y_1<0$。这将设置布尔标志。\n6. 找出最小值 $\\min\\{x_0, x_1\\}$ 和 $\\min\\{y_0, y_1\\}$。\n7. 报告结果，其中最小值四舍五入到六位小数。\n\n让我们对每个用例进行计算。\n\n用例 1: $x_0=10$, $y_0=5$, $h=0.01$, $T=0.01$。此处 $N=1$。\n$x_1 = 10 \\left( 1 + 0.01(1 - 0.5 \\times 5) \\right) = 10 \\left( 1 + 0.01(-1.5) \\right) = 10(0.985) = 9.85$。\n$y_1 = 5 \\left( 1 + 0.01(-1 + 0.5 \\times 10) \\right) = 5 \\left( 1 + 0.01(4) \\right) = 5(1.04) = 5.2$。\n序列为 $x = \\{10, 9.85\\}$ 和 $y = \\{5, 5.2\\}$。\n- 负值标志：无负值。`False`。\n- 最小 $x$ 值：$\\min\\{10, 9.85\\} = 9.85$。\n- 最小 $y$ 值：$\\min\\{5, 5.2\\} = 5$。\n结果：$[\\text{False}, 9.850000, 5.000000]$。\n\n用例 2: $x_0=8$, $y_0=12$, $h=0.2$, $T=0.2$。此处 $N=1$。\n$x_1 = 8 \\left( 1 + 0.2(1 - 0.5 \\times 12) \\right) = 8 \\left( 1 + 0.2(-5) \\right) = 8(1-1) = 0$。\n$y_1 = 12 \\left( 1 + 0.2(-1 + 0.5 \\times 8) \\right) = 12 \\left( 1 + 0.2(3) \\right) = 12(1.6) = 19.2$。\n序列为 $x = \\{8, 0\\}$ 和 $y = \\{12, 19.2\\}$。\n- 负值标志：无严格负值。`False`。\n- 最小 $x$ 值：$\\min\\{8, 0\\} = 0$。\n- 最小 $y$ 值：$\\min\\{12, 19.2\\} = 12$。\n结果：$[\\text{False}, 0.000000, 12.000000]$。\n\n用例 3: $x_0=8$, $y_0=30$, $h=0.2$, $T=0.2$。此处 $N=1$。\n$x_1 = 8 \\left( 1 + 0.2(1 - 0.5 \\times 30) \\right) = 8 \\left( 1 + 0.2(-14) \\right) = 8(1 - 2.8) = 8(-1.8) = -14.4$。\n$y_1 = 30 \\left( 1 + 0.2(-1 + 0.5 \\times 8) \\right) = 30 \\left( 1 + 0.2(3) \\right) = 30(1.6) = 48$。\n序列为 $x = \\{8, -14.4\\}$ 和 $y = \\{30, 48\\}$。\n- 负值标志：$x_1 = -14.4 < 0$。`True`。\n- 最小 $x$ 值：$\\min\\{8, -14.4\\} = -14.4$。\n- 最小 $y$ 值：$\\min\\{30, 48\\} = 30$。\n结果：$[\\text{True}, -14.400000, 30.000000]$。\n\n用例 4: $x_0=0.5$, $y_0=10$, $h=2.0$, $T=2.0$。此处 $N=1$。\n$x_1 = 0.5 \\left( 1 + 2.0(1 - 0.5 \\times 10) \\right) = 0.5 \\left( 1 + 2.0(-4) \\right) = 0.5(1 - 8) = 0.5(-7) = -3.5$。\n$y_1 = 10 \\left( 1 + 2.0(-1 + 0.5 \\times 0.5) \\right) = 10 \\left( 1 + 2.0(-0.75) \\right) = 10(1 - 1.5) = 10(-0.5) = -5$。\n序列为 $x = \\{0.5, -3.5\\}$ 和 $y = \\{10, -5\\}$。\n- 负值标志：$x_1 = -3.5 < 0$ 且 $y_1 = -5 < 0$。`True`。\n- 最小 $x$ 值：$\\min\\{0.5, -3.5\\} = -3.5$。\n- 最小 $y$ 值：$\\min\\{10, -5\\} = -5$。\n结果：$[\\text{True}, -3.500000, -5.000000]$。\n\n现在的实现将遵循这一精确逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates the Lotka-Volterra equations using the Forward Euler method for\n    a given set of test cases and analyzes the stability and population minima.\n    \"\"\"\n    # Define the Lotka-Volterra parameters, constant for all cases.\n    a = 1.0\n    b = 0.5\n    c = 1.0\n    d = 0.5\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (x0, y0, h, T)\n    test_cases = [\n        (10.0, 5.0, 0.01, 0.01),  # Case 1\n        (8.0, 12.0, 0.2, 0.2),    # Case 2\n        (8.0, 30.0, 0.2, 0.2),    # Case 3\n        (0.5, 10.0, 2.0, 2.0),    # Case 4\n    ]\n\n    all_results = []\n    for case in test_cases:\n        x0, y0, h, T = case\n        \n        # Calculate the number of steps. The problem statement guarantees this is an integer.\n        N = int(T / h)\n        \n        # Initialize lists to store the history of populations, including initial values.\n        x_history = [x0]\n        y_history = [y0]\n        \n        # Set current population values.\n        x_n, y_n = x0, y0\n        \n        # Perform the Forward Euler iteration.\n        for _ in range(N):\n            # Calculate the next population values based on the recurrence relations.\n            x_n_plus_1 = x_n * (1 + h * (a - b * y_n))\n            y_n_plus_1 = y_n * (1 + h * (-c + d * x_n))\n            \n            # Append new values to history.\n            x_history.append(x_n_plus_1)\n            y_history.append(y_n_plus_1)\n            \n            # Update current values for the next iteration.\n            x_n, y_n = x_n_plus_1, y_n_plus_1\n            \n        # Analyze the results for the current case.\n        min_x = np.min(x_history)\n        min_y = np.min(y_history)\n        \n        # Check for strictly negative populations.\n        negativity_flag = (min_x < 0) or (min_y < 0)\n        \n        # Store the results for this case.\n        all_results.append([negativity_flag, min_x, min_y])\n\n    # Format the final output string according to the specified format.\n    # [ [flag,min_x,min_y],[flag,min_x,min_y],... ]\n    # with floats formatted to 6 decimal places and no spaces.\n    result_strings = []\n    for res in all_results:\n        flag, mx, my = res\n        # Apply standard rounding to 6 decimal places, then format.\n        mx_fmt = f\"{round(mx, 6):.6f}\"\n        my_fmt = f\"{round(my, 6):.6f}\"\n        # The boolean needs to be capitalized, which str() does by default.\n        result_strings.append(f\"[{str(flag)},{mx_fmt},{my_fmt}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "2437681"}, {"introduction": "一个保证长期稳定的系统，其行为总是可预测的吗？本练习通过探索“瞬态增长”现象来挑战这一直观想法。对于某些系统，特别是那些由非正规矩阵描述的系统，其状态在最终衰减之前可能会经历显著的暂时性放大。这个实践 [@problem_id:2437705] 将指导你模拟这样一个系统，揭示长期渐近稳定性与短期性能之间的关键差异，这是许多工程应用中的一个重要考量。", "problem": "给定一个在二维实向量空间上的离散时间线性迭代过程族，由以下递归式定义\n$$\n\\mathbf{x}_{k+1} = M \\,\\mathbf{x}_{k},\n$$\n其中\n$$\nM = \\begin{bmatrix}\nr & L\\\\\n0 & r\n\\end{bmatrix},\n$$\n参数为 $r \\in (0,1)$ 和 $L \\ge 0$，初始状态为 $\\mathbf{x}_0 \\in \\mathbb{R}^2$。对于每个过程，定义其欧几里得范数序列\n$$\nn_k = \\|\\mathbf{x}_k\\|_2\n$$\n其中 $k \\ge 0$ 为整数迭代次数。收敛被理解为 $\\lim_{k \\to \\infty} \\mathbf{x}_k = \\mathbf{0}$，在计算中，当 $n_k \\le \\text{tol}$ 时判定为收敛，其中 $\\text{tol} > 0$ 是一个预设的容差。\n\n您的任务是编写一个完整的、可运行的程序。对于每一组指定的参数集，该程序需要模拟上述递归过程，并报告其稳定性与瞬态行为的量化指标。对于每个参数集，您的程序必须计算以下量：\n\n- 一个布尔值 $B$，指示范数是否在最初的 $N_{\\mathrm{inc}}$ 步内严格递增，即对于所有满足 $1 \\le k \\le N_{\\mathrm{inc}}$ 的整数 $k$，属性 $n_k > n_{k-1}$ 是否成立。如果过程在达到 $N_{\\mathrm{inc}}$ 步之前达到了收敛阈值，则此属性视为假 (false)。\n- 一个整数 $k_{\\mathrm{conv}}$，它是满足 $n_k \\le \\text{tol}$ 的最小整数 $k \\ge 0$。如果在规定的迭代预算内不存在这样的整数，则报告 $k_{\\mathrm{conv}} = -1$。\n- 一个整数 $k_{\\mathrm{peak}}$，在该迭代步数达到最大范数\n$$\nn_{\\max} = \\max \\{ n_k : 0 \\le k \\le k_{\\mathrm{end}} \\}\n$$\n其中，当 $k_{\\mathrm{conv}} \\ne -1$ 时，$k_{\\mathrm{end}} = k_{\\mathrm{conv}}$，否则 $k_{\\mathrm{end}} = K_{\\max}$，$K_{\\max}$ 是允许的最大迭代次数。如果存在多个索引达到最大值，则报告最小的那个索引。\n- 一个浮点数 $n_{\\max}$，其定义如上。\n\n您的程序必须使用以下的参数集测试套件。在每种情况下，迭代必须从以下初始状态开始：\n$$\n\\mathbf{x}_0 = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix},\n$$\n并且使用欧几里得范数。收敛容差为 $\\text{tol} = 10^{-6}$ (无量纲)，角度单位不适用。对于每个测试用例，按规定模拟最多 $K_{\\max}$ 次迭代。\n\n测试套件：\n- 用例 1：$r = 0.99$, $L = 100.0$, $N_{\\mathrm{inc}} = 100$, $K_{\\max} = 10000$。\n- 用例 2：$r = 0.99$, $L = 0.0$, $N_{\\mathrm{inc}} = 100$, $K_{\\max} = 10000$。\n- 用例 3：$r = 0.995$, $L = 100.0$, $N_{\\mathrm{inc}} = 100$, $K_{\\max} = 20000$。\n- 用例 4：$r = 0.9$, $L = 1000.0$, $N_{\\mathrm{inc}} = 100$, $K_{\\max} = 2000$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有测试用例的结果。这些结果按顺序排列，形式为一个由方括号括起来的逗号分隔列表，每个测试用例的结果本身是一个格式如下的列表：\n$$\n[B, k_{\\mathrm{conv}}, k_{\\mathrm{peak}}, n_{\\max}],\n$$\n其中 $B$ 是一个布尔值，$k_{\\mathrm{conv}}$ 和 $k_{\\mathrm{peak}}$ 是整数，$n_{\\max}$ 是一个浮点数。例如，两个用例的输出可能如下所示：\n$$\n[[\\text{True}, 1234, 100, 3.14159],[\\text{False}, -1, 57, 2.71828]].\n$$", "solution": "所陈述的问题是有效的。它是一个适定 (well-posed)、自洽 (self-contained) 且有科学依据的练习，涉及线性离散时间系统的分析，这是计算工程和应用数学中的一个基本课题。所有参数和条件都已足够精确地指定，可以得出一个唯一且可验证的解。\n\n该问题研究了迭代过程 $\\mathbf{x}_{k+1} = M \\mathbf{x}_{k}$ 的稳定性和瞬态行为，其中矩阵 $M$ 由下式给出：\n$$\nM = \\begin{bmatrix}\nr & L\\\\\n0 & r\n\\end{bmatrix}.\n$$\n该矩阵有一个重特征值 $\\lambda = r$。由于问题指定 $r \\in (0,1)$，该矩阵的谱半径为 $\\rho(M) = r < 1$。此条件保证了系统是渐近稳定的，即对于任何初始状态 $\\mathbf{x}_0$，都有 $\\lim_{k \\to \\infty} M^k = \\mathbf{0}$，因此 $\\lim_{k \\to \\infty} \\mathbf{x}_k = \\mathbf{0}$。\n\n然而，当 $L > 0$ 时，矩阵 $M$ 不是正规矩阵 (normal matrix)，因为 $MM^T \\neq M^T M$。非正规系统的一个关键特性是其可能出现瞬态增长 (transient growth)，即状态向量的范数 $n_k = \\|\\mathbf{x}_k\\|_2$ 可能会在最终的渐近衰减生效之前经历一个增长阶段。在许多工程应用中，这种现象至关重要，因为即使系统理论上是稳定的，暂时的巨幅偏移 (large excursions) 也可能导致系统失效。\n\n为了分析这种行为，我们可以推导出 $\\mathbf{x}_k$ 的闭式表达式 (closed-form expression)。矩阵 $M$ 可以分解为 $M = rI + N$，其中 $I$ 是 $2 \\times 2$ 单位矩阵，$N$ 是一个幂零矩阵 (nilpotent matrix)：\n$$\nN = \\begin{bmatrix}\n0 & L\\\\\n0 & 0\n\\end{bmatrix}, \\quad N^2 = \\mathbf{0}.\n$$\n使用二项式定理，我们可以找到 $M$ 的 $k$ 次幂：\n$$\nM^k = (rI + N)^k = \\binom{k}{0} (rI)^k N^0 + \\binom{k}{1} (rI)^{k-1} N^1 + \\dots = r^k I + k r^{k-1} N.\n$$\n具体写出来就是：\n$$\nM^k = \\begin{bmatrix}\nr^k & k r^{k-1} L \\\\\n0 & r^k\n\\end{bmatrix}.\n$$\n对于初始状态 $\\mathbf{x}_0 = [1.0, 1.0]^T$，第 $k$ 次迭代的状态向量为：\n$$\n\\mathbf{x}_k = M^k \\mathbf{x}_0 = \\begin{bmatrix}\nr^k & k r^{k-1} L \\\\\n0 & r^k\n\\end{bmatrix}\n\\begin{bmatrix}\n1.0 \\\\\n1.0\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nr^k + k r^{k-1} L \\\\\nr^k\n\\end{bmatrix}.\n$$\n因此，欧几里得范数的平方，$n_k^2 = \\|\\mathbf{x}_k\\|_2^2$，为：\n$$\nn_k^2 = (r^k + k r^{k-1} L)^2 + (r^k)^2 = r^{2k} \\left( \\left(1 + \\frac{kL}{r}\\right)^2 + 1 \\right).\n$$\n该表达式展示了由 $(kL/r)^2$ 主导的多项式增长项与指数衰减项 $r^{2k}$ 之间的竞争。当 $L>0$ 且 $r$ 接近 $1$ 时，多项式项可能导致 $n_k$ 初始时增加，从而产生瞬态增长。\n\n尽管此解析形式提供了完整的理论理解，但该问题要求进行直接的数值模拟来找出指定的量化指标。为解决每个测试用例的问题，我们实现了以下算法。\n\n**算法：**\n对于给定的一组参数 $(r, L, N_{\\mathrm{inc}}, K_{\\max})$、容差 $\\text{tol}$ 和初始状态 $\\mathbf{x}_0$：\n\n1.  **初始化**：\n    - 设置迭代计数器 $k=0$。\n    - 初始化状态向量 $\\mathbf{x} \\leftarrow \\mathbf{x}_0$。\n    - 计算初始范数 $n_0 = \\|\\mathbf{x}\\|_2$。\n    - 用 $n_0$ 初始化一个范数列表 `norm_history`。\n    - 初始化最大范数 $n_{\\max} \\leftarrow n_0$ 和峰值索引 $k_{\\mathrm{peak}} \\leftarrow 0$。\n    - 初始化收敛索引 $k_{\\mathrm{conv}} \\leftarrow -1$。\n    - 初始化一个布尔标志 `is_strictly_increasing` 为 `True`。此标志用于跟踪在 $1 \\le k \\le N_{\\mathrm{inc}}$ 范围内是否有 $n_k > n_{k-1}$。\n\n2.  **迭代**：对于 $k$ 从 $1$ 到 $K_{\\max}$ 进行循环：\n    a. 更新状态：$\\mathbf{x} \\leftarrow M \\mathbf{x}$。\n    b. 计算新范数 $n_k = \\|\\mathbf{x}\\|_2$ 并记录下来。\n    c. 检查严格递增：如果 $k \\le N_{\\mathrm{inc}}$ 且 $n_k \\le n_{k-1}$，则将 `is_strictly_increasing` 设置为 `False`。\n    d. 更新峰值：如果 $n_k > n_{\\max}$，则更新 $n_{\\max} \\leftarrow n_k$ 和 $k_{\\mathrm{peak}} \\leftarrow k$。\n    e. 检查收敛：如果 $n_k \\le \\text{tol}$，则设置 $k_{\\mathrm{conv}} \\leftarrow k$ 并终止循环。\n\n3.  **最终处理**：循环结束后（无论是由于收敛还是达到 $K_{\\max}$）：\n    a. 确定布尔值 $B$。根据问题描述，$B$ 为假的情况是：范数在最初的 $N_{\\mathrm{inc}}$ 步内不严格递增，或者过程在第 $N_{\\mathrm{inc}}$ 步或之前收敛。这可以计算为 $B = \\text{is\\_strictly\\_increasing} \\land (k_{\\mathrm{conv}} = -1 \\lor k_{\\mathrm{conv}} > N_{\\mathrm{inc}})$。这正确地实现了问题的指令。\n    b. 值 $k_{\\mathrm{conv}}$、$k_{\\mathrm{peak}}$ 和 $n_{\\max}$ 取自模拟过程中记录的值。\n\n这种直接模拟方法能为每个测试用例稳健地计算出所需的量。最终输出是所有指定测试用例结果的汇总。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(r, L, N_inc, K_max, x0, tol):\n    \"\"\"\n    Simulates the linear iterative process and computes stability indicators.\n\n    Args:\n        r (float): Parameter r of the matrix M.\n        L (float): Parameter L of the matrix M.\n        N_inc (int): Number of initial steps to check for norm increase.\n        K_max (int): Maximum number of iterations.\n        x0 (np.ndarray): Initial state vector.\n        tol (float): Convergence tolerance.\n\n    Returns:\n        list: A list containing [B, k_conv, k_peak, n_max].\n    \"\"\"\n    M = np.array([[r, L], [0, r]], dtype=np.float64)\n    x = np.array(x0, dtype=np.float64)\n\n    n_k = np.linalg.norm(x)\n    \n    # Store history of norms to check for increase\n    norm_history = [n_k]\n    \n    n_max = n_k\n    k_peak = 0\n    k_conv = -1\n    \n    is_strictly_increasing = True\n\n    for k in range(1, K_max + 1):\n        x = M @ x\n        n_k = np.linalg.norm(x)\n        norm_history.append(n_k)\n\n        # Check for strict increase property up to N_inc steps\n        if k <= N_inc:\n            if n_k <= norm_history[k - 1]:\n                is_strictly_increasing = False\n        \n        # Update peak norm and its index\n        if n_k > n_max:\n            n_max = n_k\n            k_peak = k\n        \n        # Check for convergence\n        if n_k <= tol:\n            k_conv = k\n            break\n\n    # Determine the final boolean value B\n    # B is True iff the norm is strictly increasing for the first N_inc steps\n    # AND the process does not converge within N_inc steps.\n    converged_early = (k_conv != -1 and k_conv <= N_inc)\n    B = is_strictly_increasing and not converged_early\n\n    return [B, k_conv, k_peak, n_max]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Common parameters for all test cases\n    x0 = [1.0, 1.0]\n    tol = 1e-6\n\n    # Test suite from the problem statement\n    test_cases = [\n        # Case 1: r, L, N_inc, K_max\n        (0.99, 100.0, 100, 10000),\n        # Case 2\n        (0.99, 0.0, 100, 10000),\n        # Case 3\n        (0.995, 100.0, 100, 20000),\n        # Case 4\n        (0.9, 1000.0, 100, 2000),\n    ]\n\n    results = []\n    for case in test_cases:\n        r, L, N_inc, K_max = case\n        result = run_simulation(r, L, N_inc, K_max, x0, tol)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list in Python matches the desired format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2437705"}, {"introduction": "我们如何能超越简单的“稳定/不稳定”二元分类，来描述迭代过程更丰富的动态行为，例如周期循环和混沌？最大李雅普诺夫指数 (Largest Lyapunov Exponent, LLE) 为此提供了一个强有力的定量工具。在这个实践中 [@problem_id:2437680]，你将为著名的逻辑斯谛映射计算 LLE，这是一个研究通往混沌之路的经典模型。这将为你提供一个动手实践的工具，用于将动力系统的长期行为分类为稳定、周期性或混沌。", "problem": "考虑由逻辑斯谛映射定义的一维迭代映射 $$x_{n+1} = f_r(x_n) = r\\,x_n\\,(1 - x_n),$$ 其中 $r \\in (0,4]$ 是一个实数参数，且对于所有整数迭代次数 $n \\ge 0$，$x_n \\in [0,1]$。设最大李亚普诺夫指数（LLE）根据基本原理定义为无穷小邻近轨道分离的渐近指数率。具体而言，给定两个初始条件 $x_0$ 和 $x_0 + \\delta x_0$，其中 $|\\delta x_0|$ 足够小，则对于固定的 $r$，LLE $\\lambda$ 定义为 $$\\lambda = \\lim_{n \\to \\infty} \\frac{1}{n} \\ln \\left( \\frac{|\\delta x_n|}{|\\delta x_0|} \\right),$$ 其中 $\\delta x_n$ 表示在相同映射参数 $r$ 下经过 $n$ 次迭代后的扰动。您的任务是为指定的 $r$ 值数值估计 $\\lambda$，然后利用 $\\lambda$ 的值将长期动力学行为分为三类之一：稳定不动点、周期至少为二的周期轨道或混沌。\n\n在所有计算中使用以下精确参数化设置：\n- 初始条件：$x_0 = 0.123456789$。\n- 总迭代次数：$N = 100000$。\n- 在进行任何估计或分类前需要舍弃的暂态迭代次数：$T = 1000$。\n- 为进行分类，对 LLE 使用以下容差：$\\tau = 10^{-3}$。\n- 在 $\\lambda \\le \\tau$ 时，为区分稳定不动点和周期轨道，依据轨道的渐近行为进行判断：在舍弃暂态后，检查 $x_n$ 的最后 $W = 2048$ 个迭代值，并定义此窗口内的两个值 $x_i$ 和 $x_j$ 在满足 $|x_i - x_j| \\le \\delta$（其中 $\\delta = 10^{-6}$）时为等价。如果此窗口中的等价类收缩为单个类，则判定为稳定不动点；如果存在至少两个等价类，则判定为周期至少为二的周期轨道。如果 $|\\lambda| \\le \\tau$，就本问题而言，将此动力学行为视为上述意义上的周期性行为。\n- 分类编码：稳定不动点输出 $0$，周期至少为二的周期轨道输出 $1$，混沌动力学行为输出 $2$。\n\n测试集：\n- 情况 1：$r = 2.8$。\n- 情况 2：$r = 3.2$。\n- 情况 3：$r = 3.5$。\n- 情况 4：$r = 3.58$。\n- 情况 5：$r = 3.9$。\n\n要求输出：\n- 对于每个测试情况，返回一个包含两个元素的列表：估计的 LLE $\\lambda$（四舍五入到六位小数）和分类编码（如上定义）。\n- 您的程序应生成单行输出，其中包含按顺序排列的测试情况结果，聚合为一个用逗号分隔并由方括号括起来的列表，其中每个元素是对应测试情况的双元素列表。例如：$[\\,[\\lambda_1, c_1],[\\lambda_2, c_2],\\dots]$，其中每个 $\\lambda_k$ 是一个四舍五入到六位小数的浮点数，每个 $c_k$ 是 $\\{0,1,2\\}$ 中的一个整数。输出字符串中不应出现空格。\n\n本问题不涉及物理单位或角度单位。所有数值必须是无量纲的。您的实现必须是自包含的，且不得需要任何外部输入。最终输出格式必须严格遵循上述单行输出的规范。", "solution": "问题陈述已经过严格验证，被认定具有科学依据、适定且客观。它提出了一个动力系统理论领域的标准计算任务，具体是对逻辑斯谛映射进行数值刻画，该映射是研究混沌的典范模型。获得唯一、可验证解所需的所有参数、定义和条件均已提供，无任何歧义或矛盾。因此，我将着手提供一个完整的解答。\n\n该问题要求对一维逻辑斯谛映射进行最大李亚普诺夫指数（LLE，记为 $\\lambda$）的数值估计，并随后对系统的长期动力学行为进行分类。逻辑斯谛映射由以下迭代方程定义：\n$$x_{n+1} = f_r(x_n) = r\\,x_n\\,(1 - x_n)$$\n其中 $r \\in (0,4]$ 是控制参数，状态 $x_n$ 被限制在区间 $[0,1]$ 内。\n\nLLE量化了相空间中邻近轨道的平均指数发散率或收敛率。问题给出了其基本定义：\n$$\\lambda = \\lim_{n \\to \\infty} \\frac{1}{n} \\ln \\left( \\frac{|\\delta x_n|}{|\\delta x_0|} \\right)$$\n其中 $\\delta x_n$ 是两条初始相近的轨道在 $n$ 次迭代后的分离距离。\n\n对于一维映射 $x_{n+1} = f(x_n)$，对于无穷小扰动 $\\delta x_n$，分离距离的演化遵循 $\\delta x_{n+1} \\approx f'(x_n) \\delta x_n$。迭代此关系可得 $\\delta x_n \\approx \\delta x_0 \\prod_{i=0}^{n-1} f'(x_i)$。将此式代入 $\\lambda$ 的定义，可以得到一个更便于计算的公式：\n$$ \\lambda = \\lim_{n \\to \\infty} \\frac{1}{n} \\sum_{i=0}^{n-1} \\ln |f'(x_i)| $$\n此结果表明，LLE 是映射导数的绝对值的对数沿着一条典型轨道所取值的长期平均值。对于逻辑斯谛映射，其导数为：\n$$f'_r(x) = \\frac{d}{dx} (r x - r x^2) = r - 2rx = r(1 - 2x)$$\n因此，LLE 的表达式变为：\n$$ \\lambda = \\lim_{n \\to \\infty} \\frac{1}{n} \\sum_{i=0}^{n-1} \\ln |r(1 - 2x_i)| $$\n\n在进行数值估计时，极限由大量迭代次数 $N$ 的平均值替代，并舍弃初始的 $T$ 次暂态迭代，以确保轨道已稳定到其吸引子上。因此，数值近似公式为：\n$$ \\lambda \\approx \\frac{1}{N-T} \\sum_{i=T}^{N-1} \\ln |r(1 - 2x_i)| $$\n\n动力学行为的分类基于此估计的 $\\lambda$ 值：\n1.  如果 $\\lambda > \\tau$，其中 $\\tau = 10^{-3}$ 是一个小的正容差，这标志着邻近轨道呈指数性发散。这种对初始条件的敏感依赖性是混沌的标志。该动力学行为被分类为混沌（编码 $2$）。\n2.  如果 $\\lambda \\le \\tau$，轨道不呈指数性发散，表明系统行为是规则的、非混沌的。这包括稳定不动点和周期轨道。需要进行进一步的测试来区分这两种情况。\n    - 为了进行区分，我们分析吸引子本身的结构。我们检查计算出的轨道的最后 $W = 2048$ 个点，即 $\\{x_{N-W}, \\dots, x_{N-1}\\}$。\n    - 我们将这些点分组成等价类。如果两个点 $x_i$ 和 $x_j$ 的绝对差小于或等于一个小编容差，即 $|x_i - x_j| \\le \\delta$（其中 $\\delta = 10^{-6}$），则它们被认为是等价的。\n    - 如果此窗口中的所有点都落入单个等价类，则吸引子是一个单点，动力学行为被分类为稳定不动点（编码 $0$）。\n    - 如果这些点形成两个或更多个不同的等价类，则吸引子是一个多点周期轨道，动力学行为被分类为周期至少为二的周期性行为（编码 $1$）。\n\n对于每个给定的 $r$ 值，计算步骤如下：\n1.  在 $x_0 = 0.123456789$ 处初始化系统。\n2.  将映射迭代 $N = 100000$ 步。\n3.  对于从 $T = 1000$ 到 $N-1$ 的迭代 $n$，计算并求和 $\\ln|r(1 - 2x_n)|$ 的值。同时，存储轨道点 $x_n$。\n4.  将总和除以项数 $N-T$ 来计算 $\\lambda$。\n5.  基于 $\\lambda$ 应用分类规则，并在必要时分析存储的轨道的最后 $W=2048$ 个点。\n6.  存储结果对 $[\\lambda, \\text{编码}]$，其中 $\\lambda$ 四舍五入到六位小数，并对所有测试情况重复此过程。\n\n这个严谨的、分步的过程确保了获得一个与非线性动力学原理一致的正确且可复现的解。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the logistic map problem by calculating the Largest Lyapunov Exponent (LLE)\n    and classifying the dynamics for a given set of parameters.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        2.8,\n        3.2,\n        3.5,\n        3.58,\n        3.9,\n    ]\n\n    # Global parameters for the simulation\n    x0 = 0.123456789\n    N = 100000\n    T = 1000\n    tau = 1e-3\n    W = 2048\n    delta = 1e-6\n    \n    results = []\n    \n    for r in test_cases:\n        lambda_val, code = compute_and_classify(r, x0, N, T, W, tau, delta)\n        results.append([lambda_val, code])\n\n    # Format the final output string precisely as required:\n    # \"[[l1,c1],[l2,c2],...]\" with no spaces.\n    string_parts = []\n    for lambda_val, code in results:\n        # Round lambda to 6 decimal places for printing.\n        # The f-string format specifier handles rounding correctly.\n        formatted_lambda = f\"{lambda_val:.6f}\"\n        string_parts.append(f\"[{formatted_lambda},{code}]\")\n    \n    final_output_string = f\"[{','.join(string_parts)}]\"\n\n    print(final_output_string)\n\ndef compute_and_classify(r, x0, N, T, W, tau, delta):\n    \"\"\"\n    Computes the LLE and classifies the dynamics for a single parameter r.\n\n    Args:\n        r (float): The parameter of the logistic map.\n        x0 (float): The initial condition.\n        N (int): Total number of iterations.\n        T (int): Number of transient iterations to discard.\n        W (int): Window size for orbit analysis.\n        tau (float): Tolerance for LLE-based chaos classification.\n        delta (float): Tolerance for orbit point equivalence.\n\n    Returns:\n        tuple[float, int]: A tuple containing the estimated LLE and the classification code.\n    \"\"\"\n    x = x0\n    log_df_sum = 0.0\n    trajectory_post_transient = []\n\n    # Iterate the map\n    for n in range(N):\n        # Discard transient iterations for LLE and orbit analysis\n        if n >= T:\n            # The derivative is f'(x) = r * (1 - 2*x)\n            # We need log|f'(x)|\n            # Using numpy for safe log/abs operations\n            df = r * (1.0 - 2.0 * x)\n            log_df_sum += np.log(np.abs(df))\n            \n            # Store the last W points of the post-transient trajectory\n            if n >= N - W:\n                trajectory_post_transient.append(x)\n\n        # Apply the logistic map for the next iteration\n        x = r * x * (1.0 - x)\n\n    # Calculate the Largest Lyapunov Exponent (LLE)\n    num_post_transient_steps = N - T\n    lle = log_df_sum / num_post_transient_steps\n    \n    # Classify the dynamics\n    if lle > tau:\n        # Chaotic dynamics\n        code = 2\n    else:\n        # Non-chaotic dynamics: stable fixed point or periodic orbit\n        # We use the last W points saved in trajectory_post_transient\n        \n        # This list will store representatives of each equivalence class\n        unique_points = []\n        \n        for p in trajectory_post_transient:\n            is_new = True\n            for u in unique_points:\n                # Check if p is close to an existing representative\n                if np.abs(p - u) <= delta:\n                    is_new = False\n                    break\n            if is_new:\n                unique_points.append(p)\n        \n        num_classes = len(unique_points)\n        \n        if num_classes == 1:\n            # Stable fixed point\n            code = 0\n        else:\n            # Periodic orbit of period >= 2\n            code = 1\n            \n    return lle, code\n\nsolve()\n```", "id": "2437680"}]}