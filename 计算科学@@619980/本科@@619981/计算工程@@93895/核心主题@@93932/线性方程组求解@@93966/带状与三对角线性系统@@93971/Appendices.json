{"hands_on_practices": [{"introduction": "理论在应用于实际问题时才真正焕发生机。第一个练习将展示三对角系统如何从微分方程的数值解中自然产生，而微分方程是物理和工程学的基石。通过使用有限差分法离散化艾里方程（Airy equation），你将构建并求解一个三对角系统来近似其解，从而直接体验一个强大的问题解决流程 [@problem_id:2373161]。", "problem": "考虑一个在有限区间上的 Airy 微分方程边值问题：求函数 $y(x)$ 使得\n$$\ny''(x) - x\\,y(x) = 0 \\quad \\text{for} \\quad x \\in [x_{\\mathrm{L}},x_{\\mathrm{R}}],\n$$\n并满足 Dirichlet 边值条件 $y(x_{\\mathrm{L}}) = \\alpha$ 和 $y(x_{\\mathrm{R}}) = \\beta$。其精确解具有如下形式\n$$\ny(x) = c_1\\,\\operatorname{Ai}(x) + c_2\\,\\operatorname{Bi}(x),\n$$\n其中 $\\operatorname{Ai}(x)$ 和 $\\operatorname{Bi}(x)$ 分别是第一类和第二类 Airy 函数，常数 $c_1$ 和 $c_2$ 由边值条件唯一确定。\n\n在 $[x_{\\mathrm{L}},x_{\\mathrm{R}}]$ 上定义一个包含 $n$ 个内部点的均匀网格，各点由 $x_i = x_{\\mathrm{L}} + i\\,h$ 给出，其中 $i \\in \\{0,1,\\dots,n+1\\}$，$h = (x_{\\mathrm{R}} - x_{\\mathrm{L}})/(n+1)$，且 $x_0 = x_{\\mathrm{L}}$，$x_{n+1} = x_{\\mathrm{R}}$。令 $y_i$ 表示在网格点上对 $y(x_i)$ 的近似值。对每个内部索引 $i \\in \\{1,2,\\dots,n\\}$，施加以下线性关系\n$$\n\\frac{y_{i-1} - 2 y_i + y_{i+1}}{h^2} - x_i\\,y_i = 0.\n$$\n将边界值视为已知数据：$y_0 = \\alpha$ 和 $y_{n+1} = \\beta$。这将产生一个关于未知向量 $\\mathbf{u} = (y_1,y_2,\\dots,y_n)^\\top$ 的三对角线性系统，其形式为 $\\mathbf{A}\\,\\mathbf{u} = \\mathbf{d}$，其中 $\\mathbf{A} \\in \\mathbb{R}^{n \\times n}$ 的次对角线和超对角线元素为常数 $1/h^2$，第 $i$ 行的对角线元素为 $-2/h^2 - x_i$，而右端项 $\\mathbf{d} \\in \\mathbb{R}^{n}$ 除了边界贡献 $d_1 = -\\alpha/h^2$ 和 $d_n = -\\beta/h^2$ 外，其余元素均为零。\n\n你的任务是，对下方指定的每个测试用例，计算最大绝对网格误差\n$$\nE_{\\infty} = \\max_{0 \\le j \\le n+1} \\left| y_j - y(x_j) \\right|,\n$$\n其中 $y_j$ 表示在 $x_j$ 处的数值近似解，并满足 $y_0 = \\alpha$ 和 $y_{n+1} = \\beta$，而 $y(x)$ 是精确解，其常数 $c_1$ 和 $c_2$ 由以下边值条件确定：\n$$\n\\begin{bmatrix}\n\\operatorname{Ai}(x_{\\mathrm{L}}) & \\operatorname{Bi}(x_{\\mathrm{L}}) \\\\\n\\operatorname{Ai}(x_{\\mathrm{R}}) & \\operatorname{Bi}(x_{\\mathrm{R}})\n\\end{bmatrix}\n\\begin{bmatrix}\nc_1 \\\\ c_2\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\alpha \\\\ \\beta\n\\end{bmatrix}.\n$$\n\n测试套件。对于以下各组参数，将边界值设置为与端点处的第一类 Airy 函数值相匹配，即 $\\alpha = \\operatorname{Ai}(x_{\\mathrm{L}})$ 和 $\\beta = \\operatorname{Ai}(x_{\\mathrm{R}})$：\n- 情况 1 (一般情况)：$x_{\\mathrm{L}} = 0$, $x_{\\mathrm{R}} = 1$, $n = 100$。\n- 情况 2 (单个内部未知数)：$x_{\\mathrm{L}} = 0$, $x_{\\mathrm{R}} = 1$, $n = 1$。\n- 情况 3 (更大的区间)：$x_{\\mathrm{L}} = 0$, $x_{\\mathrm{R}} = 5$, $n = 500$。\n- 情况 4 (包含负值的区间)：$x_{\\mathrm{L}} = -2$, $x_{\\mathrm{R}} = 2$, $n = 400$。\n\n最终输出格式。你的程序应生成单行输出，其中包含四个 $E_{\\infty}$ 的值，每个值按上面列出的顺序对应一种情况，形式为用方括号括起来的逗号分隔列表，例如 $[e_1,e_2,e_3,e_4]$。每个 $e_k$ 必须是实数（十进制表示）。不应打印任何其他文本。", "solution": "所提出的问题是计算科学与工程领域中一个有效且适定的边值问题。该问题要求使用有限差分格式对 Airy 微分方程进行数值求解，这将得到一个三对角线性系统。任务是计算在几种参数配置下，相对于已知精确解的最大网格误差。该问题有科学依据、内容完备且客观。不存在矛盾、歧义或违反基本原则之处。我们着手求解。\n\n问题在于，对于给定的 Airy 微分方程\n$$\ny''(x) - x\\,y(x) = 0,\n$$\n在一个有限域 $x \\in [x_{\\mathrm{L}}, x_{\\mathrm{R}}]$ 上，并在满足 Dirichlet 边值条件 $y(x_{\\mathrm{L}}) = \\alpha$ 和 $y(x_{\\mathrm{R}}) = \\beta$ 的情况下，求其解 $y(x)$ 的一个数值近似。\n\n首先，我们建立一个均匀的计算网格。区间 $[x_{\\mathrm{L}}, x_{\\mathrm{R}}]$ 被离散化为 $n+1$ 个等宽的子区间，宽度为 $h = (x_{\\mathrm{R}} - x_{\\mathrm{L}})/(n+1)$。这定义了一组共 $n+2$ 个网格点 $x_i = x_{\\mathrm{L}} + i\\,h$（其中 $i \\in \\{0, 1, \\dots, n+1\\}$），满足 $x_0 = x_{\\mathrm{L}}$ 和 $x_{n+1} = x_{\\mathrm{R}}$。设 $y_i$ 为精确解 $y(x_i)$ 在每个网格点上的数值近似值。边界点的值由给定条件固定：$y_0 = \\alpha$ 和 $y_{n+1} = \\beta$。未知量是 $n$ 个内部网格点上的值，$y_1, y_2, \\dots, y_n$。\n\n为了将连续微分方程转化为一个代数方程组，我们采用有限差分近似。在内部网格点 $x_i$ 处，二阶导数 $y''(x)$ 可以用一个二阶精度的中心差分公式来近似：\n$$\ny''(x_i) \\approx \\frac{y(x_{i-1}) - 2y(x_i) + y(x_{i+1})}{h^2}.\n$$\n将这个近似代入每个内部点 $x_i$（其中 $i \\in \\{1, 2, \\dots, n\\}$）的 Airy 方程，我们得到一个包含 $n$ 个线性方程的方程组：\n$$\n\\frac{y_{i-1} - 2y_i + y_{i+1}}{h^2} - x_i y_i = 0.\n$$\n重新整理此方程，将未知项（$y_1, \\dots, y_n$）归到左侧，可得：\n$$\n\\frac{1}{h^2} y_{i-1} + \\left(-\\frac{2}{h^2} - x_i\\right) y_i + \\frac{1}{h^2} y_{i+1} = 0.\n$$\n对于 $i = 1, \\dots, n$，这组方程构成一个形如 $\\mathbf{A} \\mathbf{u} = \\mathbf{d}$ 的线性系统，其中 $\\mathbf{u} = (y_1, y_2, \\dots, y_n)^\\top$ 是未知内部值的向量。\n\n对于第一个方程（$i=1$），$y_0$ 项是已知的（$\\alpha$），因此将其移到右侧：\n$$\n\\left(-\\frac{2}{h^2} - x_1\\right) y_1 + \\frac{1}{h^2} y_2 = -\\frac{1}{h^2} y_0 = -\\frac{\\alpha}{h^2}.\n$$\n对于最后一个方程（$i=n$），$y_{n+1}$ 项是已知的（$\\beta$），也将其移到右侧：\n$$\n\\frac{1}{h^2} y_{n-1} + \\left(-\\frac{2}{h^2} - x_n\\right) y_n = -\\frac{1}{h^2} y_{n+1} = -\\frac{\\beta}{h^2}.\n$$\n对于 $i \\in \\{2, \\dots, n-1\\}$ 的任何其他内部方程，其右侧为 0。\n\n因此，系数矩阵 $\\mathbf{A} \\in \\mathbb{R}^{n \\times n}$ 是三对角的，具有以下结构：\n- 主对角线元素：$A_{i,i} = -2/h^2 - x_i$\n- 次对角线和超对角线元素：$A_{i, i+1} = A_{i+1, i} = 1/h^2$\n\n右端向量 $\\mathbf{d} \\in \\mathbb{R}^n$ 由下式给出：\n$$\nd_i = \\begin{cases}\n    -\\alpha/h^2 & \\text{如果 } i = 1, \\\\\n    0 & \\text{如果 } 1 < i < n, \\\\\n    -\\beta/h^2 & \\text{如果 } i = n \\text{ 且 } n > 1, \\\\\n    -(\\alpha+\\beta)/h^2 & \\text{如果 } i = 1 \\text{ 且 } n = 1.\n\\end{cases}\n$$\n这种结构可以使用针对带状矩阵的专门算法（例如 SciPy 库中提供的算法）高效求解。\n\n为了计算误差，我们需要精确解。Airy 方程的通解是 $y(x) = c_1 \\operatorname{Ai}(x) + c_2 \\operatorname{Bi}(x)$。常数 $c_1$ 和 $c_2$ 由边值条件确定。对于所有测试用例，边界值被设为 $\\alpha = \\operatorname{Ai}(x_{\\mathrm{L}})$ 和 $\\beta = \\operatorname{Ai}(x_{\\mathrm{R}})$。因此边值条件变为：\n$$\nc_1 \\operatorname{Ai}(x_{\\mathrm{L}}) + c_2 \\operatorname{Bi}(x_{\\mathrm{L}}) = \\operatorname{Ai}(x_{\\mathrm{L}})\n$$\n$$\nc_1 \\operatorname{Ai}(x_{\\mathrm{R}}) + c_2 \\operatorname{Bi}(x_{\\mathrm{R}}) = \\operatorname{Ai}(x_{\\mathrm{R}})\n$$\n通过观察可知，该方程组的唯一解是 $c_1=1$ 和 $c_2=0$，因为 Airy 函数 $\\operatorname{Ai}(x)$ 和 $\\operatorname{Bi}(x)$ 构成了一个基本解组。因此，所有测试用例的精确解就是 $y(x) = \\operatorname{Ai}(x)$。\n\n每个测试用例的数值计算步骤如下：\n1.  定义参数 $x_{\\mathrm{L}}$、$x_{\\mathrm{R}}$ 和 $n$。\n2.  计算网格间距 $h$、内部网格点 $x_i$ 以及边界值 $\\alpha = \\operatorname{Ai}(x_{\\mathrm{L}})$ 和 $\\beta = \\operatorname{Ai}(x_{\\mathrm{R}})$。\n3.  以带状格式构建三对角矩阵 $\\mathbf{A}$ 和右端向量 $\\mathbf{d}$。\n4.  求解线性系统 $\\mathbf{A}\\mathbf{u} = \\mathbf{d}$，得到数值近似向量 $\\mathbf{u} = (y_1, \\dots, y_n)^\\top$。\n5.  构成完整的数值解向量 $(y_0, y_1, \\dots, y_n, y_{n+1}) = (\\alpha, u_1, \\dots, u_n, \\beta)$。\n6.  在所有网格点 $x_j$（其中 $j \\in \\{0, \\dots, n+1\\}$）上计算精确解 $y(x_j) = \\operatorname{Ai}(x_j)$。\n7.  计算最大绝对误差 $E_{\\infty} = \\max_{0 \\le j \\le n+1} |y_j - y(x_j)|$。由于根据构造，边界处的误差为零，因此这可以简化为计算内部点的最大误差。\n\n对四个指定的测试用例均执行此过程，以获得所需的误差值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import airy\nfrom scipy.linalg import solve_banded\n\ndef solve_airy_bvp(x_L: float, x_R: float, n: int) -> float:\n    \"\"\"\n    Solves the Airy BVP using finite differences and returns the max grid error.\n\n    Args:\n        x_L (float): Left boundary of the interval.\n        x_R (float): Right boundary of the interval.\n        n (int): Number of interior grid points.\n\n    Returns:\n        float: The maximum absolute error E_infinity.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Number of interior points n must be non-negative.\")\n\n    # 1. Setup grid\n    # The total number of points is n+2. The number of intervals is n+1.\n    h = (x_R - x_L) / (n + 1)\n    \n    # Generate the full grid from x_0 to x_{n+1}\n    x_full = np.linspace(x_L, x_R, n + 2)\n    \n    # The interior points are x_1 to x_n\n    x_interior = x_full[1:-1]\n\n    # 2. Define boundary conditions based on the problem statement\n    # The exact solution is y(x) = Ai(x).\n    # alpha = y(x_L), beta = y(x_R)\n    alpha, _, _, _ = airy(x_L)\n    beta, _, _, _ = airy(x_R)\n\n    # If there are no interior points, the error is 0 as boundaries are exact.\n    if n == 0:\n        return 0.0\n\n    # 3. Construct the tridiagonal linear system A*u = d\n    # A is represented in a banded format for scipy.linalg.solve_banded.\n    # The banded matrix `ab` has 3 rows for a tridiagonal matrix:\n    # row 0: super-diagonal (shifted)\n    # row 1: main-diagonal\n    # row 2: sub-diagonal (shifted)\n    ab = np.zeros((3, n))\n    h2_inv = 1.0 / (h * h)\n\n    # Populate the main, sub-, and super-diagonals of matrix A\n    ab[0, 1:] = h2_inv  # Super-diagonal\n    ab[1, :] = -2.0 * h2_inv - x_interior  # Main-diagonal\n    ab[2, :-1] = h2_inv  # Sub-diagonal\n\n    # Construct the right-hand side vector d\n    d = np.zeros(n)\n    d[0] = -alpha * h2_inv\n    # The beta contribution is added to the last element.\n    # This correctly handles the n=1 case where the first and last elements are the same.\n    d[-1] += -beta * h2_inv\n\n    # 4. Solve the linear system for u = (y_1, ..., y_n)\n    u = solve_banded((1, 1), ab, d)\n\n    # 5. Assemble the full numerical solution and find the exact solution\n    # The full numerical solution includes the boundary values.\n    y_numerical = np.concatenate(([alpha], u, [beta]))\n    \n    # The exact solution is Ai(x) evaluated at all grid points.\n    y_exact, _, _, _ = airy(x_full)\n\n    # 6. Compute the maximum absolute grid error E_infinity\n    error = np.max(np.abs(y_numerical - y_exact))\n    \n    return error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (x_L, x_R, n).\n    test_cases = [\n        (0.0, 1.0, 100),    # Case 1\n        (0.0, 1.0, 1),      # Case 2\n        (0.0, 5.0, 500),    # Case 3\n        (-2.0, 2.0, 400),   # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        x_L, x_R, n = case\n        e_infinity = solve_airy_bvp(x_L, x_R, n)\n        results.append(e_infinity)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2373161"}, {"introduction": "尽管像托马斯算法（Thomas algorithm）这样的专门算法效率极高，但它们也有其局限性。本练习将探讨数值线性代数的一个关键方面：稳定性。你将遇到标准托马斯算法会失效的三对角系统，因此必须实现一个采用部分主元消去法（partial pivoting）的更稳健的方法，这突显了即使是结构化问题，在某些情况下也需要通用求解器的重要性 [@problem_id:2447586]。", "problem": "给定严格三对角线性系统，形式为 $A \\mathbf{x} = \\mathbf{d}$，其中 $A \\in \\mathbb{R}^{n \\times n}$ 的非零元素仅存在于主对角线、第一下对角线和第一上对角线上。该三对角矩阵由三个数组指定：下对角线 $\\{a_i\\}_{i=1}^{n}$ (其中 $a_1 = 0$)，主对角线 $\\{b_i\\}_{i=1}^{n}$，以及上对角线 $\\{c_i\\}_{i=1}^{n}$ (其中 $c_n = 0$)。对于下方的每个测试用例，右端项 $\\mathbf{d}$ 是通过一个已知的解向量 $\\mathbf{x}^{\\mathrm{true}}$ 构造的，即 $\\mathbf{d} = A \\mathbf{x}^{\\mathrm{true}}$。\n\n您的任务是编写一个完整的程序，为每个测试用例计算 $A \\mathbf{x} = \\mathbf{d}$ 的解 $\\mathbf{x}$。该程序需使用一种稳健的直接法，即使某些 $b_i$ 等于零，该方法也依然正确。然后，程序必须为每个测试用例输出计算出的解向量 $\\mathbf{x}$。\n\n不涉及物理单位。不涉及角度。所有输出必须是数值。\n\n测试套件（请使用以下确切的用例）：\n\n- 用例 $1$（理想情况，严格对角占优）：$n = 5$。系数：$a_1 = 0$，对于 $i \\in \\{2,3,4,5\\}$，$a_i = -1$；对于 $i \\in \\{1,2,3,4,5\\}$，$b_i = 2$；对于 $i \\in \\{1,2,3,4\\}$，$c_i = -1$，且 $c_5 = 0$。令 $\\mathbf{x}^{\\mathrm{true}} = [1,1,1,1,1]^\\top$。计算 $\\mathbf{d} = A \\mathbf{x}^{\\mathrm{true}}$。\n- 用例 $2$（边界情况，第一个方程的主对角线上为零，但系统非奇异）：$n = 4$。系数：$a_1 = 0$，$a_2 = 1$，$a_3 = 1$，$a_4 = 1$；$b_1 = 0$，$b_2 = 2$，$b_3 = 2$，$b_4 = 2$；$c_1 = 1$，$c_2 = 1$，$c_3 = 1$，$c_4 = 0$。令 $\\mathbf{x}^{\\mathrm{true}} = [1,1,1,1]^\\top$。计算 $\\mathbf{d} = A \\mathbf{x}^{\\mathrm{true}}$。\n- 用例 $3$（不进行行交换时接近崩溃，数值上敏感的主元）：$n = 6$。系数：$a_1 = 0$，对于 $i \\in \\{2,3,4,5,6\\}$，$a_i = -1$；$b_1 = 10^{-16}$，对于 $i \\in \\{2,3,4,5,6\\}$，$b_i = 2$；对于 $i \\in \\{1,2,3,4,5\\}$，$c_i = -1$，且 $c_6 = 0$。令 $\\mathbf{x}^{\\mathrm{true}} = [1,1,1,1,1,1]^\\top$。计算 $\\mathbf{d} = A \\mathbf{x}^{\\mathrm{true}}$。\n\n最终输出格式：\n\n- 对于每个测试用例 $k$，计算 $A^{(k)} \\mathbf{x}^{(k)} = \\mathbf{d}^{(k)}$ 的数值解 $\\mathbf{x}^{(k)}$。\n- 您的程序应生成单行输出，其中包含一个由三个列表组成的逗号分隔列表，第 $k$ 个内部列表是解 $\\mathbf{x}^{(k)}$，四舍五入到 $10$ 位小数。例如，输出格式为\n  \"[[$1.0000000000$,$1.0000000000$],[$\\dots$],[$\\dots$]]\"。\n- 所需答案（每个 $\\mathbf{x}^{(k)}$ 的条目）为浮点数。这三个测试用例必须按上述方式汇总到单行中。", "solution": "该问题要求对三种不同情况下的严格三对角线性方程组 $A \\mathbf{x} = \\mathbf{d}$ 进行求解。矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的非零元素仅存在于其主对角线 ($b_i$)、下对角线 ($a_i$) 和上对角线 ($c_i$) 上。一个关键要求是，所选的求解方法必须是一种稳健的直接法，能够处理对角元素 $b_i$ 为零的情况，而标准托马斯算法在这种情况下会失效。\n\n首先，对给定问题进行验证。该问题陈述在科学上基于数值线性代数，这是计算科学的核心组成部分。问题是适定的，因为每个测试用例都对应一个非奇异线性系统，保证了唯一解的存在。定义客观明确，并且提供了复现测试用例所需的所有信息。因此，该问题是有效的。\n\n求解三对角系统的标准直接法是托马斯算法，它是高斯消元法的一种特殊形式。该算法包括一个向前消元过程和一个向后回代过程。在向前消元过程中，系统被转换为一个上双对角系统。对于第 $i$ 个方程 $a_i x_{i-1} + b_i x_i + c_i x_{i+1} = d_i$，这一步通过消去 $x_{i-1}$ 来实现。这会产生修正系数的递推关系。例如，一种常见的形式如下修改对角线和右端项：\n$$ b'_1 = b_1, \\quad d'_1 = d_1 $$\n对于 $i = 2, \\dots, n$:\n$$ m_i = \\frac{a_i}{b'_{i-1}} $$\n$$ b'_i = b_i - m_i c_{i-1} $$\n$$ d'_i = d_i - m_i d'_{i-1} $$\n然后通过向后回代求解该系统：\n$$ x_n = \\frac{d'_n}{b'_n} $$\n$$ x_i = \\frac{d'_i - c_i x_{i+1}}{b'_i} \\quad \\text{for } i = n-1, \\dots, 1 $$\n该算法效率很高，时间复杂度为 $\\mathcal{O}(n)$。然而，其关键缺陷是在每一步都除以主元 $b'_{i-1}$。如果任何一个 $b'_{i-1}$ 为零或在数值上接近于零，算法就会失效或变得数值不稳定。这正是测试用例 2（其中 $b_1 = 0$）和测试用例 3（其中 $b_1 = 10^{-16}$）所突显的问题。\n\n为了解决这个缺陷，需要一种稳健的直接法。对于此类问题，典型的选择是带部分主元的高斯消元法（GEPP）。GEPP 的原理是通过确保主元在量级上尽可能大来减轻数值不稳定性。在消元的每一步 $j$，算法会检查当前列 $j$ 中从第 $j$ 行开始向下的所有元素。然后，它将当前行 $j$ 与包含绝对值最大元素（即主元）的行进行交换。\n\n对于三对角矩阵，在列 $j$ 的选主元步骤得以简化。在列 $j$ 中对角线及其下方的潜在非零元素只有 $A_{j,j}$（即 $b_j$）和 $A_{j+1,j}$（即 $a_{j+1}$）。因此，部分选主元仅需比较 $|A_{j,j}|$ 和 $|A_{j+1,j}|$，如果后者更大，则交换第 $j$ 行和第 $j+1$ 行。这样的交换可能会在三对角结构之外引入一个非零元素（即“填充元”），具体来说，如果第 $j$ 行与第 $j+1$ 行交换，则会出现在位置 $(j, j+2)$。由此产生的矩阵变为上三角矩阵，其上带宽为 $2$。\n\nGEPP 算法流程如下：\n1.  **带部分主元的向前消元**：对于从 $1$ 到 $n-1$ 的每一列 $j$：\n    a.  **选主元**：找到行索引 $p \\ge j$，使得 $|A_{p,j}|$ 最大化。对于初始为三对角系统的矩阵，$p$ 将是 $j$ 或 $j+1$。交换第 $j$ 行和第 $p$ 行。同时交换向量 $\\mathbf{d}$ 中对应的元素。\n    b.  **消元**：对于从 $j+1$ 到 $n$ 的每一行 $i$，计算乘数 $m = A_{i,j} / A_{j,j}$。通过从第 $i$ 行中减去 $m$ 倍的主元行 $j$ 来更新该行：$R_i \\leftarrow R_i - m R_j$。此操作将元素 $A_{i,j}$ 清零。同样的操作也应用于右端项向量：$d_i \\leftarrow d_i - m d_j$。对于初始为三对角系统的矩阵，在步骤 $j$ 中只有第 $j+1$ 行有需要被消元的非零元素 $A_{j+1,j}$。\n\n2.  **向后回代**：向前消元过程结束后，矩阵 $A$ 被转换为一个上三角矩阵 $U$。然后，从最后一个变量 $x_n$ 开始，向后至 $x_1$，求解系统 $U \\mathbf{x} = \\mathbf{d'}$：\n    $$ x_n = \\frac{d'_n}{U_{n,n}} $$\n    $$ x_i = \\frac{1}{U_{i,i}} \\left( d'_i - \\sum_{k=i+1}^{n} U_{i,k} x_k \\right) \\quad \\text{for } i = n-1, \\dots, 1 $$\n该算法对于零对角元素是稳健的（前提是矩阵非奇异）并且数值稳定。对于指定的小问题规模（$n \\le 6$），使用 $A$ 的稠密矩阵表示来实现此算法是直接且计算上可接受的，避免了管理带填充元的带状矩阵结构的复杂性。因此，提供的解决方案代码将对稠密矩阵表示实现带部分主元的高斯消元法。", "answer": "```python\nimport numpy as np\n\ndef solve_gepp(A_in, d_in):\n    \"\"\"\n    Solves the linear system Ax=d using Gaussian Elimination with Partial Pivoting.\n\n    Args:\n        A_in (np.ndarray): A square n x n matrix.\n        d_in (np.ndarray): A vector of length n.\n\n    Returns:\n        np.ndarray: The solution vector x.\n    \"\"\"\n    A = np.copy(A_in).astype(np.float64)\n    d = np.copy(d_in).astype(np.float64)\n    n = len(d)\n\n    # Forward elimination with partial pivoting\n    for j in range(n - 1):\n        # Find the row with the largest pivot in column j (from j downwards)\n        pivot_row_index = j + np.argmax(np.abs(A[j:, j]))\n\n        # Swap rows if a larger pivot is found\n        if pivot_row_index != j:\n            A[[j, pivot_row_index], :] = A[[pivot_row_index, j], :]\n            d[j], d[pivot_row_index] = d[pivot_row_index], d[j]\n\n        # The pivot element is A[j, j]. For a non-singular matrix, it must be non-zero\n        # after pivoting. The problems are guaranteed to be non-singular.\n        if A[j, j] == 0:\n            # This path should not be taken for the given problems.\n            continue\n\n        # Elimination step: zero out entries in column j below the pivot\n        for i in range(j + 1, n):\n            if A[i, j] != 0:\n                multiplier = A[i, j] / A[j, j]\n                A[i, j:] -= multiplier * A[j, j:]\n                d[i] -= multiplier * d[j]\n\n    # Backward substitution to solve the upper triangular system\n    x = np.zeros(n)\n    for i in range(n - 1, -1, -1):\n        # The problems are non-singular, so division by zero is not expected.\n        if A[i, i] == 0:\n            # This indicates a singular matrix\n            raise ValueError(\"Matrix is singular and cannot be solved.\")\n        \n        sum_ax = np.dot(A[i, i + 1:], x[i + 1:])\n        x[i] = (d[i] - sum_ax) / A[i, i]\n        \n    return x\n\ndef create_tridiagonal_matrix(n, a_coeffs, b_coeffs, c_coeffs):\n    \"\"\"Helper function to create the dense tridiagonal matrix.\"\"\"\n    A = np.zeros((n, n), dtype=np.float64)\n    # Note: a_coeffs and c_coeffs are expected to have n-1 elements\n    for i in range(n):\n        A[i, i] = b_coeffs[i]\n        if i > 0:\n            A[i, i-1] = a_coeffs[i-1]\n        if i  n - 1:\n            A[i, i+1] = c_coeffs[i]\n    return A\n\ndef solve():\n    \"\"\"\n    Solves the tridiagonal systems for the specified test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 5,\n            \"a\": [-1., -1., -1., -1.],  # indices i=2 to n, so n-1 elements\n            \"b\": [2., 2., 2., 2., 2.],\n            \"c\": [-1., -1., -1., -1.],  # indices i=1 to n-1, so n-1 elements\n            \"xtrue\": np.array([1., 1., 1., 1., 1.])\n        },\n        {\n            \"n\": 4,\n            \"a\": [1., 1., 1.],\n            \"b\": [0., 2., 2., 2.],\n            \"c\": [1., 1., 1.],\n            \"xtrue\": np.array([1., 1., 1., 1.])\n        },\n        {\n            \"n\": 6,\n            \"a\": [-1., -1., -1., -1., -1.],\n            \"b\": [1e-16, 2., 2., 2., 2., 2.],\n            \"c\": [-1., -1., -1., -1., -1.],\n            \"xtrue\": np.array([1., 1., 1., 1., 1., 1.])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        a = case[\"a\"]\n        b = case[\"b\"]\n        c = case[\"c\"]\n        xtrue = case[\"xtrue\"]\n        \n        # Construct the dense matrix A\n        A = create_tridiagonal_matrix(n, a, b, c)\n\n        # Compute the right-hand side vector d\n        d = A @ xtrue\n        \n        # Solve the system Ax = d using the robust GEPP method\n        x_computed = solve_gepp(A, d)\n        results.append(x_computed)\n\n    # Format the output as specified\n    formatted_results = []\n    for res in results:\n        formatted_res = '[' + ','.join([f\"{val:.10f}\" for val in res]) + ']'\n        formatted_results.append(formatted_res)\n    \n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2447586"}, {"introduction": "我们的探索将在创建一个通用且强大的工具——一个求解一般带状矩阵的求解器——中达到高潮。本练习基于 $LU$ 分解的原理，将三对角系统的思想推广到具有任意下带宽和上带宽的系统。你将实现一个使用紧凑存储方案的求解器，真正掌握利用矩阵结构以实现计算效率的艺术 [@problem_id:2373172]。", "problem": "要求您编写一个完整且可运行的程序，该程序使用下-上 (LU) 分解（不进行主元选择）为非中心带状线性系统实现一个求解器。如果一个方阵 $A \\in \\mathbb{R}^{n \\times n}$ 在 $j  i - p$ 或 $j  i + q$ 时满足 $A_{i,j} = 0$，则称其为下带宽为 $p$、上带宽为 $q$ 的带状矩阵。换句话说，其非零元素模式被限制在主对角线下方的 $p$ 条次对角线和上方的 $q$ 条超对角线之内。目标是利用其带状结构，将运算限制在带内，从而求解 $A x = b$。\n\n从 Gaussian 消元法的定义和 LU 分解 $A = L U$（其中 $L$ 是单位下三角矩阵，即对角线元素为 $1$，$U$ 是上三角矩阵）的概念出发，推导一种算法，该算法应：\n- 假设不需要主元选择，仅在由 $p$ 和 $q$ 确定的带内执行消元步骤。\n- 将对角线下方的乘子存储为 $L$ 的元素，将变换后的上三角部分存储为 $U$ 的元素。\n- 使用前向代换求解 $L y = b$，然后使用回溯代换求解 $U x = y$。\n\n您的实现不得依赖任何直接求解带状系统的库例程；相反，它必须显式地实现 LU 分解和三角系统求解，并仅使用带宽参数 $p$ 和 $q$ 来限制运算范围。\n\n测试套件。您的程序必须将求解器应用于以下五个测试用例。在每个用例中，完全按照规定构造 $A$、$x_{\\text{true}}$ 和 $b = A x_{\\text{true}}$，然后使用您的带状 LU 求解器计算数值解 $\\hat{x}$，并报告误差的无穷范数 $\\lVert \\hat{x} - x_{\\text{true}} \\rVert_{\\infty} = \\max_i | \\hat{x}_i - (x_{\\text{true}})_i |$（以浮点数形式）。\n\n- 用例 $1$ (一般非中心带)：$n=7$, $p=2$, $q=1$。按如下方式定义 $A \\in \\mathbb{R}^{7 \\times 7}$：\n  - $A_{i,i} = 5 + i$，对于 $1 \\le i \\le 7$，\n  - $A_{i,i+1} = -1$，对于 $1 \\le i \\le 6$，\n  - $A_{i,i-1} = -2$，对于 $2 \\le i \\le 7$，\n  - $A_{i,i-2} = 0.5$，对于 $3 \\le i \\le 7$，\n  - 所有其他元素 $A_{i,j} = 0$。\n  令 $x_{\\text{true}} = [1,-2,3,-4,5,-6,7]^{\\top}$。\n\n- 用例 $2$ (三对角)：$n=6$, $p=1$, $q=1$。按如下方式定义 $A \\in \\mathbb{R}^{6 \\times 6}$：\n  - $A_{i,i} = 4$，对于 $1 \\le i \\le 6$，\n  - $A_{i,i+1} = -1$，对于 $1 \\le i \\le 5$，\n  - $A_{i,i-1} = -1$，对于 $2 \\le i \\le 6$，\n  - 所有其他元素 $A_{i,j} = 0$。\n  令 $x_{\\text{true}} = [1,1,1,1,1,1]^{\\top}$。\n\n- 用例 $3$ (上带宽为 $q=3$ 的上带状)：$n=5$, $p=0$, $q=3$。按如下方式定义 $A \\in \\mathbb{R}^{5 \\times 5}$：\n  - $A_{i,i} = 4 + i$，对于 $1 \\le i \\le 5$，\n  - $A_{i,i+1} = 0.5$，对于 $1 \\le i \\le 4$，\n  - $A_{i,i+2} = -0.25$，对于 $1 \\le i \\le 3$，\n  - $A_{i,i+3} = 0.125$，对于 $1 \\le i \\le 2$，\n  - 所有其他元素 $A_{i,j} = 0$。\n  令 $x_{\\text{true}} = [2,-1,0.5,-0.5,1]^{\\top}$。\n\n- 用例 $4$ (下带宽为 $p=2$ 的下带状)：$n=5$, $p=2$, $q=0$。按如下方式定义 $A \\in \\mathbb{R}^{5 \\times 5}$：\n  - $A_{i,i} = 5$，对于 $1 \\le i \\le 5$，\n  - $A_{i,i-1} = -1$，对于 $2 \\le i \\le 5$，\n  - $A_{i,i-2} = 0.3$，对于 $3 \\le i \\le 5$，\n  - 所有其他元素 $A_{i,j} = 0$。\n  令 $x_{\\text{true}} = [1,2,3,4,5]^{\\top}$。\n\n- 用例 $5$ (对角)：$n=6$, $p=0$, $q=0$。按如下方式定义 $A \\in \\mathbb{R}^{6 \\times 6}$：\n  - $A_{i,i} = 2 + 0.1 i$，对于 $1 \\le i \\le 6$，\n  - 所有其他元素 $A_{i,j} = 0$。\n  令 $x_{\\text{true}} = [-1,2,-3,4,-5,6]^{\\top}$。\n\n在所有用例中，构造 $b = A x_{\\text{true}}$，用您的带状 LU 求解器求解 $A \\hat{x} = b$，计算无穷范数误差 $\\lVert \\hat{x} - x_{\\text{true}} \\rVert_{\\infty}$，并收集这五个误差值。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按用例 1 到 5 的顺序列出结果，例如 $[e_1,e_2,e_3,e_4,e_5]$，其中每个 $e_k$ 是为用例 $k$ 计算出的无穷范数误差（浮点数）。", "solution": "所提出的问题是数值线性代数领域，特别是计算工程领域中一个标准且定义明确的练习。它要求推导并实现一个线性系统 $A x = b$ 的求解器，其中 $A$ 是一个带状矩阵，并使用无主元选择的 LU 分解。唯一解所需的所有组成部分均已提供：带状矩阵的定义、所需的方法以及一组五个不同的、数值上指定的测试用例。该问题在科学上是合理的、客观的且完整的，不存在逻辑矛盾、模糊之处或事实错误。因此，该问题被视为有效，并将提供完整的解决方案。\n\n任务是求解线性系统 $A x = b$，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个下带宽为 $p$、上带宽为 $q$ 的方阵。这意味着如果 $j  i - p$ 或 $j  i + q$，则 $A_{i,j} = 0$。求解方法是 LU 分解，将 $A$ 分解为一个单位下三角矩阵 $L$ 和一个上三角矩阵 $U$ 的乘积，使得 $A = LU$。然后通过一个两步过程求解该系统：首先求解 $L y = b$（前向代换），然后求解 $U x = y$（回溯代换）。\n\n一个关键的观察是，如果不执行行置换（主元选择），则在 Gaussian 消元过程中带状结构得以保留。生成的矩阵 $L$ 将具有 $p$ 的下带宽，而 $U$ 将具有 $q$ 的上带宽。这可以显著节省计算和存储开销。\n\n为了利用带状结构，我们避免存储整个 $n \\times n$ 矩阵 $A$。取而代之，我们只将非零带存储在一个大小为 $(p+q+1) \\times n$ 的紧凑矩阵中，记作 $A_{band}$。原始矩阵中的一个元素 $A_{i,j}$ 被映射到紧凑存储中的一个元素。我们在此采用一个标准约定，将 $A_{i,j}$ 映射到元素 $A_{band}[i-j+q, j]$（使用 0-基索引）。在这种方案中，$A$ 的主对角线位于 $A_{band}$ 的第 $q$ 行，$q$ 条超对角线位于第 $0, \\dots, q-1$ 行，而 $p$ 条次对角线位于第 $q+1, \\dots, q+p$ 行。\n\nLU 分解过程是对 $A_{band}$ 矩阵的原位修改。该算法源自标准的 Gaussian 消元法。该过程遍历列 $k$（从 $0$ 到 $n-2$），利用主元 $A_{k,k}$ 来消去同一列中其下方的非零项。\n\n对于每个主元列 $k \\in \\{0, 1, \\dots, n-2\\}$：\n待消元的元素是 $A_{i,k}$，其中行 $i$ 满足 $k+1 \\le i \\le \\min(n-1, k+p)$。对于每个这样的行 $i$，计算乘子 $m_{i,k} = A_{i,k} / A_{k,k}$。此乘子 $m_{i,k}$ 成为矩阵 $L$ 的元素 $L_{i,k}$。我们将其存储在先前由 $A_{i,k}$ 占据的位置。消元更新规则为 $A_{i,j} \\leftarrow A_{i,j} - m_{i,k} A_{k,j}$。此更新只需应用于 $A_{i,j}$ 和 $A_{k,j}$ 都可能非零的列 $j$。这对应于列 $j \\in \\{k+1, \\dots, \\min(n-1, k+q)\\}$。\n\n就紧凑存储 $A_{band}$ 而言，分解算法对于 $k \\in \\{0, \\dots, n-2\\}$ 如下：\n1. 对于每个行索引 $i \\in \\{k+1, \\dots, \\min(n-1, k+p)\\}$：\n   a. 主元是 $U_{k,k} = A_{band}[q, k]$。\n   b. 待消元的元素是 $A_{i,k}$，位于 $A_{band}[i-k+q, k]$。\n   c. 计算乘子 $m_{i,k} = \\frac{A_{band}[i-k+q, k]}{A_{band}[q, k]}$。\n   d. 将此乘子存储在原位：$A_{band}[i-k+q, k] = m_{i,k}$。此项现在代表 $L_{i,k}$。\n   e. 对于每个列索引 $j \\in \\{k+1, \\dots, \\min(n-1, k+q)\\}$，更新行 $i$ 的相应元素：\n      $$ A_{band}[i-j+q, j] \\leftarrow A_{band}[i-j+q, j] - m_{i,k} \\times A_{band}[k-j+q, j] $$\n此过程完成后，$A_{band}$ 的上半部分（第 $0$ 行到第 $q$ 行）包含矩阵 $U$，而严格下半部分（第 $q+1$ 行到第 $q+p$ 行）包含 $L$ 的非对角线元素。\n\n在原位完成 $A=LU$ 分解后，我们接着求解两个三角系统。\n\n首先，通过前向代换求解 $L y = b$：\n由于 $L$ 是一个下带宽为 $p$ 的单位下三角矩阵，每个分量 $y_i$ 的公式为：\n$$ y_i = b_i - \\sum_{j=\\max(0, i-p)}^{i-1} L_{i,j} y_j \\quad \\text{for } i = 0, \\dots, n-1 $$\n其中的元素 $L_{i,j}$ 是存储在 $A_{band}[i-j+q, j]$ 中的乘子。向量 $y$ 可以通过从 $0$ 到 $n-1$ 迭代 $i$ 来计算。\n\n其次，通过回溯代换求解 $U x = y$：\n由于 $U$ 是一个上带宽为 $q$ 的上三角矩阵，我们通过从 $i = n-1$ 递减迭代到 $0$ 来求解 $x$：\n$$ x_i = \\frac{1}{U_{i,i}} \\left( y_i - \\sum_{j=i+1}^{\\min(n-1, i+q)} U_{i,j} x_j \\right) \\quad \\text{for } i = n-1, \\dots, 0 $$\n其中的元素 $U_{i,j}$ 存储在 $A_{band}[i-j+q, j]$ 中。对角线元素 $U_{i,i}$ 位于 $A_{band}[q, i]$。\n\n至此，算法的推导完成。接下来将构建一个实现这些步骤的程序，以解决给定的测试用例。对于每个用例，将定义矩阵 $A$ 和向量 $x_{\\text{true}}$，计算 $b = A x_{\\text{true}}$，使用推导出的带状 LU 求解器找到数值解 $\\hat{x}$，并报告误差的无穷范数 $\\lVert \\hat{x} - x_{\\text{true}} \\rVert_{\\infty}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef full_to_banded(A, p, q):\n    \"\"\"\n    Converts a full numpy matrix A to its compact banded representation.\n    \"\"\"\n    n = A.shape[0]\n    A_band = np.zeros((p + q + 1, n))\n    for i in range(n):\n        for j in range(max(0, i - p), min(n, i + q + 1)):\n            # Mapping A[i, j] to A_band[row, col]\n            # row = i - j + q, col = j\n            A_band[i - j + q, j] = A[i, j]\n    return A_band\n\ndef banded_lu_factorization(A_band, p, q):\n    \"\"\"\n    Performs LU factorization in-place on a banded matrix.\n    The upper part of A_band will store U, the lower part will store L.\n    \"\"\"\n    n = A_band.shape[1]\n    # k is the pivot column (0-indexed)\n    for k in range(n - 1):\n        # Pivot element U_kk is at A_band[q, k]\n        pivot = A_band[q, k]\n        if pivot == 0:\n            # This would require pivoting, which is not implemented as per problem spec.\n            # For the given test cases, this should not occur.\n            raise ValueError(\"Zero pivot encountered.\")\n        \n        # i is the row to be updated\n        for i in range(k + 1, min(n, k + p + 1)):\n            # Multiplier L_ik = A_ik / U_kk\n            # Element A_ik is at A_band[i-k+q, k]\n            multiplier = A_band[i - k + q, k] / pivot\n            A_band[i - k + q, k] = multiplier  # Store L_ik\n\n            # Update row i from column k+1 to k+q\n            # A_ij - A_ij - L_ik * U_kj\n            for j in range(k + 1, min(n, k + q + 1)):\n                # U_kj is at A_band[k-j+q, j]\n                # A_ij is at A_band[i-j+q, j]\n                A_band[i - j + q, j] -= multiplier * A_band[k - j + q, j]\n\ndef solve_banded_lu(A_band, p, q, b):\n    \"\"\"\n    Solves A x = b for a banded system A, given its in-place LU factorization A_band.\n    \"\"\"\n    n = A_band.shape[1]\n    y = b.copy()\n\n    # Forward substitution to solve L y = b\n    # L is unit lower triangular with lower bandwidth p\n    for i in range(n):\n        s = 0.0\n        # Sum over L_ij * y_j\n        for j in range(max(0, i - p), i):\n            # L_ij is at A_band[i-j+q, j]\n            s += A_band[i - j + q, j] * y[j]\n        y[i] -= s\n\n    # Backward substitution to solve U x = y\n    # U is upper triangular with upper bandwidth q\n    x = y.copy()\n    for i in range(n - 1, -1, -1):\n        s = 0.0\n        # Sum over U_ij * x_j\n        for j in range(i + 1, min(n, i + q + 1)):\n            # U_ij is at A_band[i-j+q, j]\n            s += A_band[i - j + q, j] * x[j]\n        \n        # U_ii is at A_band[q, i]\n        x[i] = (y[i] - s) / A_band[q, i]\n        \n    return x\n\ndef get_test_cases():\n    \"\"\"\n    Generates the five test cases as specified in the problem.\n    Returns a list of tuples, each containing (A, p, q, x_true).\n    \"\"\"\n    cases = []\n\n    # Case 1\n    n1, p1, q1 = 7, 2, 1\n    A1 = np.zeros((n1, n1))\n    for i in range(n1):\n        A1[i, i] = 5.0 + (i + 1)\n        if i + 1  n1: A1[i, i + 1] = -1.0\n        if i - 1 = 0: A1[i, i - 1] = -2.0\n        if i - 2 = 0: A1[i, i - 2] = 0.5\n    x_true1 = np.array([1.0, -2.0, 3.0, -4.0, 5.0, -6.0, 7.0])\n    cases.append((A1, p1, q1, x_true1))\n\n    # Case 2\n    n2, p2, q2 = 6, 1, 1\n    A2 = np.zeros((n2, n2))\n    for i in range(n2):\n        A2[i, i] = 4.0\n        if i + 1  n2: A2[i, i + 1] = -1.0\n        if i - 1 = 0: A2[i, i - 1] = -1.0\n    x_true2 = np.ones(n2)\n    cases.append((A2, p2, q2, x_true2))\n\n    # Case 3\n    n3, p3, q3 = 5, 0, 3\n    A3 = np.zeros((n3, n3))\n    for i in range(n3):\n        A3[i, i] = 4.0 + (i + 1)\n        if i + 1  n3: A3[i, i + 1] = 0.5\n        if i + 2  n3: A3[i, i + 2] = -0.25\n        if i + 3  n3: A3[i, i + 3] = 0.125\n    x_true3 = np.array([2.0, -1.0, 0.5, -0.5, 1.0])\n    cases.append((A3, p3, q3, x_true3))\n\n    # Case 4\n    n4, p4, q4 = 5, 2, 0\n    A4 = np.zeros((n4, n4))\n    for i in range(n4):\n        A4[i, i] = 5.0\n        if i - 1 = 0: A4[i, i - 1] = -1.0\n        if i - 2 = 0: A4[i, i - 2] = 0.3\n    x_true4 = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    cases.append((A4, p4, q4, x_true4))\n\n    # Case 5\n    n5, p5, q5 = 6, 0, 0\n    A5 = np.zeros((n5, n5))\n    for i in range(n5):\n        A5[i, i] = 2.0 + 0.1 * (i + 1)\n    x_true5 = np.array([-1.0, 2.0, -3.0, 4.0, -5.0, 6.0])\n    cases.append((A5, p5, q5, x_true5))\n\n    return cases\n\ndef solve():\n    test_cases = get_test_cases()\n    results = []\n\n    for A_full, p, q, x_true in test_cases:\n        # 1. Create the banded system\n        b = A_full @ x_true\n        A_band = full_to_banded(A_full, p, q)\n\n        # 2. Perform LU factorization on the banded matrix\n        banded_lu_factorization(A_band, p, q)\n\n        # 3. Solve using forward/backward substitution\n        x_hat = solve_banded_lu(A_band, p, q, b)\n\n        # 4. Compute the infinity norm of the error\n        error = np.linalg.norm(x_hat - x_true, ord=np.inf)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2373172"}]}