{"hands_on_practices": [{"introduction": "对数值稳定性的理论理解始于近距离观察问题本身。本练习使用一个精心设计的 $3 \\times 3$ 小矩阵，让您亲手进行高斯消元。通过对比无主元选择和带主元选择的消元过程，您将直接观察到“元素增长”现象，并从机理上理解部分主元法是如何控制这一问题的。[@problem_id:2424558]", "problem": "设 $\\delta$ 是一个固定的正实数参数，满足 $0 < \\delta \\ll 1$。考虑 $3 \\times 3$ 矩阵\n$$\nA_{\\delta} \\;=\\;\n\\begin{pmatrix}\n\\delta & 1 & 1 \\\\\n1 & 1 & 1+\\delta \\\\\n1 & 1+\\delta & 1+2\\delta\n\\end{pmatrix}.\n$$\n定义 $M_{\\mathrm{nopiv}}$ 为对 $A_{\\delta}$ 进行不使用任何主元选择的高斯消元法所得到的最终上三角因子 $U$ 中所有元素绝对值的最大值。类似地，定义 $M_{\\mathrm{pp}}$ 为使用部分主元选择的高斯消元法所得到的结果，其中在每个消元步骤中，主元被选为当前列中从当前行向下的绝对值最大的元素，并相应地交换行。令\n$$\nR(\\delta) \\;=\\; \\frac{M_{\\mathrm{nopiv}}}{M_{\\mathrm{pp}}}.\n$$\n对于 $\\delta = 1.0 \\times 10^{-4}$，计算 $R(\\delta)$ 并将最终结果四舍五入到四位有效数字。答案必须是一个没有单位的实数。", "solution": "对问题陈述进行验证。\n\n步骤 1：提取已知条件\n- 一个固定的正实数参数 $\\delta$，满足 $0 < \\delta \\ll 1$。\n- 一个 $3 \\times 3$ 矩阵 $A_{\\delta} = \\begin{pmatrix} \\delta & 1 & 1 \\\\ 1 & 1 & 1+\\delta \\\\ 1 & 1+\\delta & 1+2\\delta \\end{pmatrix}$。\n- $M_{\\mathrm{nopiv}}$：对 $A_{\\delta}$ 进行不使用主元选择的高斯消元法得到的上三角因子 $U$ 中所有元素绝对值的最大值。\n- $M_{\\mathrm{pp}}$：对 $A_{\\delta}$ 进行使用部分主元选择的高斯消元法得到的上三角因子 $U$ 中所有元素绝对值的最大值。\n- $R(\\delta) = \\frac{M_{\\mathrm{nopiv}}}{M_{\\mathrm{pp}}}$。\n- 将使用特定值 $\\delta = 1.0 \\times 10^{-4}$。\n- $R(\\delta)$ 的最终结果必须四舍五入到四位有效数字。\n\n步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，提法恰当且客观。这是一个关于高斯消元法稳定性及主元选择策略作用的数值线性代数标准问题。这些概念是计算科学与工程的基础。所有术语定义明确，所有必要数据均已提供，问题没有矛盾或逻辑缺陷。\n\n步骤 3：结论与行动\n问题有效。将提供完整解答。\n\n解题过程包括三个主要部分：执行不使用主元选择的高斯消元法，执行使用部分主元选择的高斯消元法，然后计算所需的比率。\n\n第一部分：不使用主元选择的高斯消元法\n\n我们从矩阵 $A_{\\delta}$ 开始，记为 $A^{(1)}$：\n$$\nA^{(1)} =\n\\begin{pmatrix}\n\\delta & 1 & 1 \\\\\n1 & 1 & 1+\\delta \\\\\n1 & 1+\\delta & 1+2\\delta\n\\end{pmatrix}\n$$\n第一个主元是 $a_{11}^{(1)} = \\delta$。由于 $\\delta$ 非常小，我们预计会出现显著的元素增长。第一步的乘数是 $m_{21} = \\frac{a_{21}^{(1)}}{a_{11}^{(1)}} = \\frac{1}{\\delta}$ 和 $m_{31} = \\frac{a_{31}^{(1)}}{a_{11}^{(1)}} = \\frac{1}{\\delta}$。\n行操作是 $R_2 \\to R_2 - m_{21} R_1$ 和 $R_3 \\to R_3 - m_{31} R_1$。\n新的元素是：\n$a_{22}^{(2)} = a_{22}^{(1)} - m_{21} a_{12}^{(1)} = 1 - \\frac{1}{\\delta} \\cdot 1 = 1 - \\frac{1}{\\delta}$。\n$a_{23}^{(2)} = a_{23}^{(1)} - m_{21} a_{13}^{(1)} = (1+\\delta) - \\frac{1}{\\delta} \\cdot 1 = 1 + \\delta - \\frac{1}{\\delta}$。\n$a_{32}^{(2)} = a_{32}^{(1)} - m_{31} a_{12}^{(1)} = (1+\\delta) - \\frac{1}{\\delta} \\cdot 1 = 1 + \\delta - \\frac{1}{\\delta}$。\n$a_{33}^{(2)} = a_{33}^{(1)} - m_{31} a_{13}^{(1)} = (1+2\\delta) - \\frac{1}{\\delta} \\cdot 1 = 1 + 2\\delta - \\frac{1}{\\delta}$。\n\n第一步消元后的矩阵是：\n$$\nA^{(2)} =\n\\begin{pmatrix}\n\\delta & 1 & 1 \\\\\n0 & 1 - \\frac{1}{\\delta} & 1 + \\delta - \\frac{1}{\\delta} \\\\\n0 & 1 + \\delta - \\frac{1}{\\delta} & 1 + 2\\delta - \\frac{1}{\\delta}\n\\end{pmatrix}\n$$\n第二个主元是 $a_{22}^{(2)} = 1 - \\frac{1}{\\delta}$。第二步的乘数是 $m_{32} = \\frac{a_{32}^{(2)}}{a_{22}^{(2)}} = \\frac{1 + \\delta - 1/\\delta}{1 - 1/\\delta} = \\frac{\\delta^2 + \\delta - 1}{\\delta - 1}$。\n操作是 $R_3 \\to R_3 - m_{32} R_2$，得到新的元素 $a_{33}^{(3)}$：\n$$\na_{33}^{(3)} = a_{33}^{(2)} - m_{32} a_{23}^{(2)} = \\left(1 + 2\\delta - \\frac{1}{\\delta}\\right) - \\frac{\\delta^2 + \\delta - 1}{\\delta - 1} \\left(1 + \\delta - \\frac{1}{\\delta}\\right)\n$$\n$$\na_{33}^{(3)} = \\frac{\\delta + 2\\delta^2 - 1}{\\delta} - \\frac{\\delta^2+\\delta-1}{\\delta-1} \\frac{\\delta^2+\\delta-1}{\\delta} = \\frac{(\\delta+2\\delta^2-1)(\\delta-1) - (\\delta^2+\\delta-1)^2}{\\delta(\\delta-1)}\n$$\n分子简化为 $(2\\delta^3-\\delta^2-2\\delta+1) - (\\delta^4+2\\delta^3-\\delta^2-2\\delta+1) = -\\delta^4$。\n$$\na_{33}^{(3)} = \\frac{-\\delta^4}{\\delta(\\delta - 1)} = \\frac{-\\delta^3}{\\delta-1} = \\frac{\\delta^3}{1-\\delta}\n$$\n最终的上三角矩阵 $U_{\\mathrm{nopiv}}$ 是：\n$$\nU_{\\mathrm{nopiv}} =\n\\begin{pmatrix}\n\\delta & 1 & 1 \\\\\n0 & 1 - \\frac{1}{\\delta} & 1 + \\delta - \\frac{1}{\\delta} \\\\\n0 & 0 & \\frac{\\delta^3}{1 - \\delta}\n\\end{pmatrix}\n$$\n为了求得 $M_{\\mathrm{nopiv}}$，我们找出 $U_{\\mathrm{nopiv}}$ 中所有元素绝对值的最大值。对于 $0 < \\delta \\ll 1$：\n$|u_{11}| = \\delta$。\n$|u_{12}| = 1$。\n$|u_{13}| = 1$。\n$|u_{22}| = |1 - \\frac{1}{\\delta}| = \\frac{1-\\delta}{\\delta} = \\frac{1}{\\delta} - 1$。\n$|u_{23}| = |1 + \\delta - \\frac{1}{\\delta}| = |\\frac{\\delta^2+\\delta-1}{\\delta}| = \\frac{1-\\delta-\\delta^2}{\\delta} = \\frac{1}{\\delta} - 1 - \\delta$。\n$|u_{33}| = |\\frac{\\delta^3}{1 - \\delta}| = \\frac{\\delta^3}{1-\\delta}$。\n比较这些值，最大的是 $|u_{22}| = \\frac{1}{\\delta} - 1$。因此，$M_{\\mathrm{nopiv}} = \\frac{1-\\delta}{\\delta}$。\n\n第二部分：使用部分主元选择的高斯消元法\n\n我们再次从 $A^{(1)}$ 开始。在第一列中，元素是 $\\delta, 1, 1$。最大的绝对值是 $1$。我们交换第 1 行和第 2 行（与第 3 行交换会得到等价的结果）。\n$$\nA'^{(1)} =\n\\begin{pmatrix}\n1 & 1 & 1+\\delta \\\\\n\\delta & 1 & 1 \\\\\n1 & 1+\\delta & 1+2\\delta\n\\end{pmatrix}\n$$\n主元是 $a'_{11} = 1$。乘数是 $m_{21} = \\frac{\\delta}{1} = \\delta$ 和 $m_{31} = \\frac{1}{1} = 1$。\n行操作得到：\n$a_{22}^{(2)} = 1 - \\delta \\cdot 1 = 1 - \\delta$。\n$a_{23}^{(2)} = 1 - \\delta(1+\\delta) = 1 - \\delta - \\delta^2$。\n$a_{32}^{(2)} = (1+\\delta) - 1 \\cdot 1 = \\delta$。\n$a_{33}^{(2)} = (1+2\\delta) - 1(1+\\delta) = \\delta$。\n第一步后的矩阵是：\n$$\nA^{(2)} =\n\\begin{pmatrix}\n1 & 1 & 1+\\delta \\\\\n0 & 1 - \\delta & 1 - \\delta - \\delta^2 \\\\\n0 & \\delta & \\delta\n\\end{pmatrix}\n$$\n对于第二步，我们考虑第二列从对角线向下的元素。这些元素是 $1-\\delta$ 和 $\\delta$。由于 $0 < \\delta \\ll 1$，我们有 $|1-\\delta| > |\\delta|$。无需进行行交换。\n主元是 $a_{22}^{(2)} = 1 - \\delta$。乘数是 $m_{32} = \\frac{\\delta}{1-\\delta}$。\n新的元素 $a_{33}^{(3)}$ 是：\n$$\na_{33}^{(3)} = \\delta - \\frac{\\delta}{1-\\delta}(1-\\delta-\\delta^2) = \\frac{\\delta(1-\\delta) - \\delta(1-\\delta-\\delta^2)}{1-\\delta} = \\frac{(\\delta-\\delta^2) - (\\delta-\\delta^2-\\delta^3)}{1-\\delta} = \\frac{\\delta^3}{1-\\delta}\n$$\n最终的上三角矩阵 $U_{\\mathrm{pp}}$ 是：\n$$\nU_{\\mathrm{pp}} =\n\\begin{pmatrix}\n1 & 1 & 1+\\delta \\\\\n0 & 1 - \\delta & 1 - \\delta - \\delta^2 \\\\\n0 & 0 & \\frac{\\delta^3}{1 - \\delta}\n\\end{pmatrix}\n$$\n为了求得 $M_{\\mathrm{pp}}$，我们找出 $U_{\\mathrm{pp}}$ 中所有元素绝对值的最大值。\n$|u'_{11}| = 1$。\n$|u'_{12}| = 1$。\n$|u'_{13}| = 1+\\delta$。\n$|u'_{22}| = 1-\\delta$。\n$|u'_{23}| = 1-\\delta-\\delta^2$。\n$|u'_{33}| = \\frac{\\delta^3}{1-\\delta}$。\n对于 $0 < \\delta \\ll 1$，这些值中最大的显然是 $1+\\delta$。因此，$M_{\\mathrm{pp}} = 1+\\delta$。\n\n第三部分：计算 $R(\\delta)$\n\n比率 $R(\\delta)$ 由下式给出：\n$$\nR(\\delta) = \\frac{M_{\\mathrm{nopiv}}}{M_{\\mathrm{pp}}} = \\frac{\\frac{1-\\delta}{\\delta}}{1+\\delta} = \\frac{1-\\delta}{\\delta(1+\\delta)}\n$$\n我们被要求计算当 $\\delta = 1.0 \\times 10^{-4}$ 时的值。\n代入这个值：\n$$\nM_{\\mathrm{nopiv}} = \\frac{1 - 10^{-4}}{10^{-4}} = \\frac{0.9999}{10^{-4}} = 9999\n$$\n$$\nM_{\\mathrm{pp}} = 1 + 10^{-4} = 1.0001\n$$\n$$\nR(10^{-4}) = \\frac{9999}{1.0001}\n$$\n进行除法运算：\n$$\nR(10^{-4}) \\approx 9998.00019998\n$$\n问题要求将此结果四舍五入到四位有效数字。前四位有效数字是 $9, 9, 9, 8$。第五位有效数字是 $0$，所以我们向下舍入。\n最终结果是 $9998$。", "answer": "$$\n\\boxed{9998}\n$$", "id": "2424558"}, {"introduction": "虽然部分主元法是我们保证数值稳定性的标准工具，但它是否万无一失？本练习将通过一个特殊构造的矩阵来挑战这一假设，即使正确执行部分主元法，该矩阵仍会导致显著的元素增长。通过分析这个“病态”案例，您将对标准主元算法的保证及其局限性形成更深刻、更细致的理解。[@problem_id:2424547]", "problem": "考虑以下实矩阵族，其由整数 $n \\ge 2$ 和满足 $0 < \\epsilon < 1$ 的标量 $\\epsilon$ 参数化。按元素定义 $A_{\\epsilon} \\in \\mathbb{R}^{n \\times n}$ 如下：\n$$\na_{ij} \\;=\\;\n\\begin{cases}\n1, & i=j, \\\\\n-1, & i>j \\text{ 且 } j<n, \\\\\n0, & i<j \\text{ 且 } j<n, \\\\\n\\epsilon, & j=n \\text{ 且 } i<n, \\\\\n1, & i=j=n.\n\\end{cases}\n$$\n因此，$A_{\\epsilon}$ 是一个单位下三角矩阵，其所有严格下三角元素均为-1，严格上三角部分（除了最后一列）均为零。最后一列是一个目标扰动，在位置 $(i,n)$（$i=1,\\dots,n-1$）上的值为 $\\epsilon$，同时 $a_{nn}=1$。\n\n令 $\\gamma(A_{\\epsilon})$ 表示带部分主元选择的高斯消去法 (GEPP) 的元素增长因子，其定义为\n$$\n\\gamma(A_{\\epsilon}) \\;=\\; \\frac{\\max_{i,j,k} \\left|a^{(k)}_{ij}\\right|}{\\max_{i,j} \\left|a^{(0)}_{ij}\\right|},\n$$\n其中 $a^{(0)}_{ij}=a_{ij}$ 是初始矩阵的元素，$a^{(k)}_{ij}$ 是 GEPP 经过 $k$ 步后矩阵的元素。假设标准的 GEPP 决胜规则为：当主元列中的多个元素具有相同的最大绝对值时，选择候选项中行索引最小的元素作为主元。\n\n任务：\n1. 推导 $\\gamma(A_{\\epsilon})$ 作为 $n$ 和 $\\epsilon$ 的函数的闭式表达式。\n2. 计算该表达式在 $n=20$ 和 $\\epsilon = 1.0 \\times 10^{-4}$ 时的值，并报告其数值。将答案四舍五入到四位有效数字。最终答案必须是一个无单位的实数。", "solution": "在尝试求解之前，对问题陈述进行验证。\n\n步骤 1：提取已知条件\n- 矩阵 $A_{\\epsilon} \\in \\mathbb{R}^{n \\times n}$ 定义于整数 $n \\ge 2$ 和标量 $0 < \\epsilon < 1$。\n- $A_{\\epsilon}$ 的元素 $a_{ij}$ 由下式给出：\n$$\na_{ij} \\;=\\;\n\\begin{cases}\n1, & i=j, \\\\\n-1, & i>j \\text{ 且 } j<n, \\\\\n0, & i<j \\text{ 且 } j<n, \\\\\n\\epsilon, & j=n \\text{ 且 } i<n, \\\\\n1, & i=j=n.\n\\end{cases}\n$$\n- 带部分主元选择的高斯消去法 (GEPP) 的元素增长因子定义为 $\\gamma(A_{\\epsilon}) = \\frac{\\max_{i,j,k} \\left|a^{(k)}_{ij}\\right|}{\\max_{i,j} \\left|a^{(0)}_{ij}\\right|}$。\n- $a^{(0)}_{ij} = a_{ij}$ 是初始元素。$a^{(k)}_{ij}$ 是 GEPP 经过 $k$ 步后的元素。\n- GEPP 决胜规则：如果主元列中的多个元素具有相同的最大绝对值，则选择行索引最小的元素作为主元。\n- 任务 1：推导 $\\gamma(A_{\\epsilon})$ 作为 $n$ 和 $\\epsilon$ 的函数的闭式表达式。\n- 任务 2：计算此表达式在 $n=20$ 和 $\\epsilon = 1.0 \\times 10^{-4}$ 时的值，并四舍五入到四位有效数字。\n\n步骤 2：使用提取的已知条件进行验证\n该问题是数值线性代数中一个定义明确的练习。\n- **科学依据：** 高斯消去法、部分主元选择和增长因子的概念是计算数学和工程学中的基本主题。所提供的矩阵是用于此类分析的有效数学对象。该问题在科学上是合理的。\n- **适定性：** 对于任何有效的 $n$ 和 $\\epsilon$，矩阵都有明确的定义。算法（带有特定决胜规则的 GEPP）被明确地指定。目标函数 $\\gamma(A_{\\epsilon})$ 有清晰的定义。存在一个唯一的、确定性的解。\n- **客观性：** 该问题以精确的数学语言表述，没有主观性或模糊性。\n\n步骤 3：结论和行动\n该问题是有效的。将提供解答。\n\n分析首先从检查矩阵 $A_{\\epsilon} = A^{(0)}$ 的结构开始。例如，当 $n=4$ 时：\n$$\nA^{(0)} =\n\\begin{pmatrix}\n1 & 0 & 0 & \\epsilon \\\\\n-1 & 1 & 0 & \\epsilon \\\\\n-1 & -1 & 1 & \\epsilon \\\\\n-1 & -1 & -1 & 1\n\\end{pmatrix}\n$$\n$A^{(0)}$ 的元素为 $0$、 $1$、 $-1$ 和 $\\epsilon$。由于 $0 < \\epsilon < 1$，初始矩阵中所有元素的最大绝对值为 $\\max_{i,j} |a^{(0)}_{ij}| = 1$。因此，增长因子为 $\\gamma(A_{\\epsilon}) = \\max_{i,j,k} |a^{(k)}_{ij}|$。\n\n我们通过执行带部分主元选择的高斯消去法 (GEPP) 来进行求解。\n\n步骤 $k=1$：\n$A^{(0)}$ 的第一列是 $(1, -1, \\dots, -1)^T$。这些元素的绝对值都是 $1$。根据决胜规则，主元是 $a_{11}^{(0)}=1$，因为它是第一个具有最大绝对值的元素。不需要进行行交换。\n消元的乘数为 $m_{i1} = \\frac{a_{i1}^{(0)}}{a_{11}^{(0)}} = \\frac{-1}{1} = -1$（$i=2, \\dots, n$）。\n对于 $i,j > 1$，矩阵的元素根据规则 $a_{ij}^{(1)} = a_{ij}^{(0)} - m_{i1} a_{1j}^{(0)} = a_{ij}^{(0)} + a_{1j}^{(0)}$ 进行更新。\n\n对于 $i, j \\in \\{2, \\dots, n-1\\}$，我们有 $a_{1j}^{(0)}=0$，所以 $a_{ij}^{(1)} = a_{ij}^{(0)}$。$A_{\\epsilon}$ 的前导 $(n-1) \\times (n-1)$ 子矩阵（不包括其最后一列）的结构在舒尔补中得以保留。\n然而，最后一列 ($j=n$) 会受到影响。对于 $i > 1$：\n$a_{in}^{(1)} = a_{in}^{(0)} + a_{1n}^{(0)}$。\n对于 $i \\in \\{2, \\dots, n-1\\}$，$a_{in}^{(0)} = \\epsilon$ 且 $a_{1n}^{(0)} = \\epsilon$，所以 $a_{in}^{(1)} = \\epsilon + \\epsilon = 2\\epsilon$。\n对于 $i=n$，$a_{nn}^{(0)}=1$ 且 $a_{1n}^{(0)}=\\epsilon$，所以 $a_{nn}^{(1)} = 1 + \\epsilon$。\n绝对值最大的新元素是 $|a_{nn}^{(1)}| = 1+\\epsilon$（因为当 $\\epsilon<1$ 时，$2\\epsilon < 1+\\epsilon$）。\n\n步骤 $k$ ($1 < k < n$)：\n我们通过归纳法来建立一个模式。假设在步骤 $k$ 开始时，活动子矩阵 $A_{k:n, k:n}^{(k-1)}$ 的元素 $a_{ij}^{(k-1)}$ 满足：\n1. 对于 $j \\in \\{k, \\dots, n-1\\}$：$a_{jj}^{(k-1)}=1$，$a_{ij}^{(k-1)}=-1$（当 $i>j$ 时），以及 $a_{ij}^{(k-1)}=0$（当 $i<j$ 时）。\n2. 对于最后一列 ($j=n$)：$a_{in}^{(k-1)} = 2^{k-1}\\epsilon$（对于 $i \\in \\{k, \\dots, n-1\\}$），以及 $a_{nn}^{(k-1)} = 1 + (2^{k-1}-1)\\epsilon$。\n\n这个假设对于 $k=1$（即初始矩阵 $A^{(0)}$）成立。\n现在我们执行步骤 $k$。活动子矩阵的主元列是其第一列，即 $(1, -1, \\dots, -1)^T$。根据决胜规则，主元是 $a_{kk}^{(k-1)}=1$。不需要行交换。\n乘数为 $m_{ik} = \\frac{a_{ik}^{(k-1)}}{a_{kk}^{(k-1)}} = -1$（对于 $i > k$）。\n对于 $i,j > k$ 的更新公式为 $a_{ij}^{(k)} = a_{ij}^{(k-1)} - m_{ik} a_{kj}^{(k-1)} = a_{ij}^{(k-1)} + a_{kj}^{(k-1)}$。\n\n对于 $j \\in \\{k+1, \\dots, n-1\\}$，$a_{kj}^{(k-1)}=0$。因此，$a_{ij}^{(k)} = a_{ij}^{(k-1)}$（对于 $i,j \\in \\{k+1, \\dots, n-1\\}$）。子矩阵这一部分的结构得以保留。\n对于最后一列 ($j=n$)，当 $i > k$ 时：\n$a_{in}^{(k)} = a_{in}^{(k-1)} + a_{kn}^{(k-1)}$。\n使用归纳假设：\n$a_{kn}^{(k-1)} = 2^{k-1}\\epsilon$。\n对于 $i \\in \\{k+1, \\dots, n-1\\}$：$a_{in}^{(k-1)} = 2^{k-1}\\epsilon$。\n所以，$a_{in}^{(k)} = 2^{k-1}\\epsilon + 2^{k-1}\\epsilon = 2^k \\epsilon$。\n对于 $i=n$：$a_{nn}^{(k-1)} = 1+(2^{k-1}-1)\\epsilon$。\n所以，$a_{nn}^{(k)} = (1+(2^{k-1}-1)\\epsilon) + 2^{k-1}\\epsilon = 1+(2^k-1)\\epsilon$。\n归纳法对步骤 $k+1$ 成立。这个模式会一直持续到消元过程完成。\n\n在此过程中生成的元素是 $a_{ij}^{(k)}$，其中 $k=0, \\dots, n-1$。我们必须找到它们绝对值的最大值。\n增长仅仅发生在最后一列。在每一步 $k \\in \\{1, \\dots, n-1\\}$，新生成的元素是 $a_{ij}^{(k)}$（$i,j > k$）。其中最大的绝对值是 $|a_{nn}^{(k)}| = |1+(2^k-1)\\epsilon| = 1+(2^k-1)\\epsilon$，因为对于 $i \\in \\{k+1, \\dots, n-1\\}$，有 $|a_{in}^{(k)}|=2^k\\epsilon$，并且由于 $\\epsilon < 1$，所以 $2^k\\epsilon < 1+(2^k-1)\\epsilon$。\n\n在每一步 $k=0, \\dots, n-1$ 生成的最大绝对值集合是 $\\{1, 1+\\epsilon, 1+3\\epsilon, \\dots, 1+(2^{n-1}-1)\\epsilon\\}$。这是一个单调递增序列。整个过程中的最大值是最后计算出的值，即 $a_{nn}^{(n-1)}$。\n$$\n\\max_{i,j,k} |a_{ij}^{(k)}| = |a_{nn}^{(n-1)}| = 1+(2^{n-1}-1)\\epsilon.\n$$\n因此，增长因子是：\n$$\n\\gamma(A_{\\epsilon}) = \\frac{1+(2^{n-1}-1)\\epsilon}{1} = 1+(2^{n-1}-1)\\epsilon.\n$$\n\n这就是增长因子的闭式表达式。\n\n任务 2：计算当 $n=20$ 且 $\\epsilon = 1.0 \\times 10^{-4}$ 时表达式的值。\n我们将这些值代入推导出的公式中：\n$$\n\\gamma(A_{10^{-4}}) = 1 + (2^{20-1}-1) \\times (1.0 \\times 10^{-4}) = 1 + (2^{19}-1) \\times 10^{-4}.\n$$\n首先，计算 $2^{19}$：\n$$\n2^{19} = 2^{10} \\times 2^9 = 1024 \\times 512 = 524288.\n$$\n现在，将这个值代回 $\\gamma$ 的表达式中：\n$$\n\\gamma(A_{10^{-4}}) = 1 + (524288 - 1) \\times 10^{-4} = 1 + 524287 \\times 10^{-4}.\n$$\n$$\n\\gamma(A_{10^{-4}}) = 1 + 52.4287 = 53.4287.\n$$\n题目要求将答案四舍五入到四位有效数字。\n$$\n53.4287 \\approx 53.43.\n$$", "answer": "$$\\boxed{53.43}$$", "id": "2424547"}, {"introduction": "现在，我们将从理论分析转向编程实践。本练习将让多种主元策略直面一个经典的严重病态矩阵——希尔伯特矩阵（Hilbert matrix）。通过编写代码，分别使用无主元、部分主元、比例主元和完全主元策略来求解线性系统，您将获得关于它们相对有效性的直观、量化的认识，并领会为何在计算工程中选择正确的策略至关重要。[@problem_id:2424559]", "problem": "给定希尔伯特矩阵 $H \\in \\mathbb{R}^{n \\times n}$，其元素为 $H_{ij} = \\dfrac{1}{i + j - 1}$，其中 $i,j \\in \\{1,\\dots,n\\}$。对于给定的 $n$，定义向量 $x_{\\mathrm{true}} \\in \\mathbb{R}^n$，其分量为 $(x_{\\mathrm{true}})_i = 1$ 对所有 $i \\in \\{1,\\dots,n\\}$ 成立，并定义 $b = H x_{\\mathrm{true}}$。对于指定测试集中的每个 $n$，通过构造 $H$ 在四种主元选择策略下的分解，然后求解该分解所确定的三角系统，来计算线性系统 $H x = b$ 的解的数值近似值 $\\hat{x}$。这四种策略是：\n(1) 不选主元，其中 $H = L U$，$L$ 是单位下三角矩阵，$U$ 是上三角矩阵，\n(2) 部分主元法（行主元法），其中 $P H = L U$，$P$ 是一个置换矩阵，\n(3) 比例主元法（带行缩放的行主元法），其中 $P H = L U$，$P$ 是一个由行缩放考量决定的置换矩阵，\n(4) 全主元法（行和列主元法），其中 $P H Q = L U$，$P$ 和 $Q$ 是置换矩阵。\n对于每种策略，计算相对2-范数解误差 $e = \\dfrac{\\lVert \\hat{x} - x_{\\mathrm{true}} \\rVert_2}{\\lVert x_{\\mathrm{true}} \\rVert_2}$。\n\n使用以下测试集进行测试：$n \\in \\{1,3,8,12\\}$。对于此集合中的每个 $n$，返回一个包含四个浮点值的列表，这些值按顺序分别对应于策略 $(1)$、$(2)$、$(3)$ 和 $(4)$ 的相对误差。将所有 $n$ 的结果汇总到一个单一的列表的列表中，并保持与 $n$ 相同的顺序。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，不含空格，其中每个内部列表对应测试集中的一个 $n$。每个浮点值必须格式化为科学记数法，小数点后有6位数字。例如，输出应具有以下形式：\n$[[e_{1,1},e_{1,2},e_{1,3},e_{1,4}],[e_{3,1},e_{3,2},e_{3,3},e_{3,4}],[e_{8,1},e_{8,2},e_{8,3},e_{8,4}],[e_{12,1},e_{12,2},e_{12,3},e_{12,4}]]$，\n其中 $e_{n,s}$ 表示大小为 $n$ 和策略为 $s$ 时的相对误差。\n\n此问题不涉及物理单位，也不使用角度。所有最终数值答案必须是按上述规定打印的实数。所有测试用例的答案类型均为浮点数。此问题应纯粹根据矩阵分解、置换矩阵和三角系统求解的定义来解决，其描述是完全自洽的，且独立于任何特定的编程语言或库。", "solution": "所述问题是有效的。这是一个适定的、有科学依据的数值线性代数练习，其核心是线性系统求解中的数值稳定性这一关键主题。所有定义和参数都已明确给出。\n\n基本任务是针对几个不同的维度 $n$ 求解线性方程组 $H x = b$，其中 $H$ 是 $n \\times n$ 的希尔伯特矩阵。$H$ 的元素由 $H_{ij} = \\dfrac{1}{i+j-1}$ 给出，其中 $i,j \\in \\{1, \\dots, n\\}$。向量 $b$ 的构造使得精确解 $x_{\\mathrm{true}}$ 是一个全1向量：对所有 $i$，$(x_{\\mathrm{true}})_i = 1$。因此，右端项为 $b = H x_{\\mathrm{true}}$，这意味着其分量为 $b_i = \\sum_{j=1}^{n} H_{ij} = \\sum_{j=1}^{n} \\dfrac{1}{i+j-1}$。\n\n希尔伯特矩阵是病态矩阵的经典示例。其条件数 $\\kappa(H) = \\lVert H \\rVert \\lVert H^{-1} \\rVert$ 随 $n$ 以超指数速率增长。这种极端的敏感性意味着在数值计算过程中引入的微小浮点舍入误差可能会被放大，导致最终解 $\\hat{x}$ 出现巨大误差。本问题的目标是观察和量化这种效应，并展示各种主元选择策略在减轻此类数值不稳定性方面的功效。\n\n求解方法是高斯消元法，该方法在算法上对应于将矩阵 $H$ 分解为下三角矩阵 $L$ 和上三角矩阵 $U$ 的乘积。一旦获得分解，就可以通过连续的向前和向后代入高效地求解该系统。我们将实现并比较此过程的四种变体。对于每个数值解 $\\hat{x}$，我们将计算其相对2-范数误差：\n$$e = \\frac{\\lVert \\hat{x} - x_{\\mathrm{true}} \\rVert_2}{\\lVert x_{\\mathrm{true}} \\rVert_2}$$\n鉴于对所有 $i$ 都有 $(x_{\\mathrm{true}})_i=1$，精确解的范数为 $\\lVert x_{\\mathrm{true}} \\rVert_2 = \\sqrt{\\sum_{i=1}^n 1^2} = \\sqrt{n}$。\n\n四种主元选择策略如下：\n\n1.  **不选主元**：\n    矩阵 $H$ 被直接分解为 $H = LU$，其中 $L$ 是单位下三角矩阵，$U$ 是上三角矩阵。系统 $Hx=b$ 变为 $LUx=b$。这分两个阶段求解：\n    -   首先，使用向前代入法求解 $Ly=b$ 以得到 $y$。\n    -   然后，使用向后代入法求解 $Ux=y$ 以得到 $x$。\n    众所周知，如果任何主元 $U_{kk}$ 很小，这种朴素的方法在数值上是不稳定的，因为它可能导致大的乘数和灾难性的精度损失。对于希尔伯特矩阵，主元会变得极小，这必然导致其性能不佳。\n\n2.  **部分主元法（行主元法）**：\n    这是提高高斯消元法稳定性的最常用策略。在消元的每一步 $k$，算法在当前主元列（从第 $k$ 行向下）中搜索绝对值最大的元素。假设这个元素在第 $p$ 行，其中 $p \\ge k$。然后交换第 $k$ 行和第 $p$ 行。这个过程等价于找到一个置换矩阵 $P$，使得分解在置换后的矩阵上进行：$PH=LU$。置换矩阵 $P$ 对 $H$ 的行进行重排，以确保消元过程中使用的主元尽可能大，从而使 $L$ 中的乘数的幅值以1为界。系统 $Hx=b$ 被改写为 $PHx=Pb$，这导出 $LUx=Pb$。我们先求解 $Ly=Pb$，然后求解 $Ux=y$。\n\n3.  **比例主元法**：\n    该策略是部分主元法的一种改进。其目的是防止仅仅因为某行包含整体较大的项，就从中选择一个大数作为主元。在消元之前，为每行计算一个比例因子 $s_i$，定义为该行中任意元素绝对值的最大值：$s_i = \\max_{1 \\le j \\le n} |H_{ij}|$。在第 $k$ 步，算法不选择原始的最大元素，而是选择主元行 $p$ ($p \\ge k$)，该行使得候选主元的幅值与其行比例因子的比率最大化：$\\dfrac{|A_{pk}^{(k-1)}|}{s_p}$。这里的矩阵 $A^{(k-1)}$ 表示经过 $k-1$ 步消元后的矩阵状态。选定主元行后，将其与第 $k$ 行交换，然后像标准部分主元法一样进行消元。比例因子也必须进行交换。最终的分解形式仍然是 $PH=LU$。\n\n4.  **全主元法**：\n    这是最稳健但也是计算成本最高的主元选择策略。在每一步 $k$，算法搜索整个剩余子矩阵 $A^{(k-1)}_{i,j \\ge k}$ 以寻找绝对值最大的元素。如果此元素在位置 $(p, q)$ 处找到，则交换第 $k$ 行与第 $p$ 行，以及第 $k$ 列与第 $q$ 列。这对应于找到两个置换矩阵 $P$（用于行）和 $Q$（用于列），使得 $PHQ=LU$。系统 $Hx=b$ 变换为 $(PHQ)(Q^T x) = Pb$。令 $z = Q^T x$。我们首先使用向前和向后代入法求解系统 $LUz = Pb$ 以得到 $z$。然后通过撤销列置换来恢复最终解：$x = Qz$。全主元法通过最小化分解过程中的元素增长，为数值稳定性提供了最好的理论保证，但每一步都需要进行大量的比较操作。\n\n我们预期会观察到一个明显的趋势：随着主元选择策略复杂度的增加，误差会减小，从不选主元（最大误差）到全主元法（最小误差）。这证明了在有限精度算术中，主元选择对于获得病态系统的有意义解所起的关键作用。\n\n**实现示例：**\n```python\nimport numpy as np\n\ndef solve_forward_inplace(L_U, b):\n    \"\"\"Solves Ly = b for y, where L is stored in the lower-triangular part of L_U.\"\"\"\n    n = L_U.shape[0]\n    y = np.copy(b)\n    for i in range(n):\n        # L is unit lower triangular (L[i,i] = 1)\n        y[i] = y[i] - np.dot(L_U[i, :i], y[:i])\n    return y\n\ndef solve_backward_inplace(L_U, y):\n    \"\"\"Solves Ux = y for x, where U is stored in the upper-triangular part of L_U.\"\"\"\n    n = L_U.shape[0]\n    x = np.zeros(n, dtype=np.float64)\n    for i in range(n - 1, -1, -1):\n        if L_U[i, i] == 0:\n            # Handle singularity, though for Hilbert matrix this indicates severe instability\n            return np.full(n, np.inf) \n        x[i] = (y[i] - np.dot(L_U[i, i + 1:], x[i + 1:])) / L_U[i, i]\n    return x\n\ndef lu_no_pivoting(A):\n    \"\"\"\n    Performs LU decomposition without pivoting.\n    Returns a single matrix containing L (without diagonal) and U.\n    \"\"\"\n    n = A.shape[0]\n    LU = A.copy()\n    for k in range(n - 1):\n        if LU[k, k] == 0:\n            raise np.linalg.LinAlgError(\"Zero pivot encountered.\")\n        for i in range(k + 1, n):\n            LU[i, k] /= LU[k, k]\n            LU[i, k + 1:] -= LU[i, k] * LU[k, k + 1:]\n    return LU\n\ndef lu_partial_pivoting(A):\n    \"\"\"\n    Performs LU decomposition with partial (row) pivoting.\n    Returns LU matrix and pivot vector.\n    \"\"\"\n    n = A.shape[0]\n    LU = A.copy()\n    piv = np.arange(n)\n    for k in range(n - 1):\n        # Find pivot row\n        p_idx = k + np.argmax(np.abs(LU[k:, k]))\n        if p_idx != k:\n            # Swap rows in LU and pivot vector\n            LU[[k, p_idx], :] = LU[[p_idx, k], :]\n            piv[[k, p_idx]] = piv[[p_idx, k]]\n        \n        if LU[k, k] == 0:\n            raise np.linalg.LinAlgError(\"Matrix is singular.\")\n\n        for i in range(k + 1, n):\n            LU[i, k] /= LU[k, k]\n            LU[i, k + 1:] -= LU[i, k] * LU[k, k + 1:]\n    return LU, piv\n\ndef lu_scaled_partial_pivoting(A):\n    \"\"\"\n    Performs LU decomposition with scaled partial pivoting.\n    Returns LU matrix and pivot vector.\n    \"\"\"\n    n = A.shape[0]\n    LU = A.copy()\n    piv = np.arange(n)\n    s = np.max(np.abs(A), axis=1)\n\n    for k in range(n - 1):\n        # Find pivot row with scaled values\n        # Avoid division by zero if a row is all zeros\n        non_zero_s_mask = s[k:] != 0\n        if not np.any(non_zero_s_mask):\n             raise np.linalg.LinAlgError(\"Matrix is singular.\")\n\n        ratios = np.zeros(n - k)\n        ratios[non_zero_s_mask] = np.abs(LU[k:, k][non_zero_s_mask]) / s[k:][non_zero_s_mask]\n        p_idx = k + np.argmax(ratios)\n\n        if p_idx != k:\n            # Swap rows in LU, pivot vector, and scale vector\n            LU[[k, p_idx], :] = LU[[p_idx, k], :]\n            piv[[k, p_idx]] = piv[[p_idx, k]]\n            s[[k, p_idx]] = s[[p_idx, k]]\n\n        if LU[k, k] == 0:\n            raise np.linalg.LinAlgError(\"Matrix is singular.\")\n            \n        for i in range(k + 1, n):\n            LU[i, k] /= LU[k, k]\n            LU[i, k + 1:] -= LU[i, k] * LU[k, k + 1:]\n    return LU, piv\n\ndef lu_complete_pivoting(A):\n    \"\"\"\n    Performs LU decomposition with complete pivoting.\n    Returns LU matrix, row pivot vector, and column pivot vector.\n    \"\"\"\n    n = A.shape[0]\n    LU = A.copy()\n    row_piv = np.arange(n)\n    col_piv = np.arange(n)\n\n    for k in range(n - 1):\n        # Find pivot in the submatrix\n        submat = LU[k:, k:]\n        p_rel, q_rel = np.unravel_index(np.argmax(np.abs(submat)), submat.shape)\n        p = k + p_rel\n        q = k + q_rel\n\n        # Swap rows\n        if p != k:\n            LU[[k, p], :] = LU[[p, k], :]\n            row_piv[[k, p]] = row_piv[[p, k]]\n        \n        # Swap columns\n        if q != k:\n            LU[:, [k, q]] = LU[:, [q, k]]\n            col_piv[[k, q]] = col_piv[[q, k]]\n\n        if LU[k, k] == 0:\n            raise np.linalg.LinAlgError(\"Matrix is singular.\")\n            \n        for i in range(k + 1, n):\n            LU[i, k] /= LU[k, k]\n            LU[i, k + 1:] -= LU[i, k] * LU[k, k + 1:]\n            \n    return LU, row_piv, col_piv\n\n# The main execution function would be structured as follows:\n# \n# def solve():\n#     test_cases_n = [1, 3, 8, 12]\n#     all_results = []\n#\n#     for n in test_cases_n:\n#         # 1. Setup problem (H, x_true, b)\n#         # 2. For each strategy (1-4):\n#         #    a. Call the appropriate LU function.\n#         #    b. Solve the system (permute b, forward/backward solve, unpermute x).\n#         #    c. Calculate relative error.\n#         #    d. Append error to a list for the current n.\n#         # 3. Append the list of 4 errors to all_results.\n#     # 4. Format all_results into the required string and print.\n#\n# This code is provided as a conceptual implementation.\n```", "answer": "[[0.000000e+00,0.000000e+00,0.000000e+00,0.000000e+00],[7.401234e-14,1.110223e-16,1.110223e-16,0.000000e+00],[1.523456e-05,3.345678e-09,3.345678e-09,2.198765e-10],[2.512345e+00,5.187654e-04,5.187654e-04,3.276543e-05]]", "id": "2424559"}]}