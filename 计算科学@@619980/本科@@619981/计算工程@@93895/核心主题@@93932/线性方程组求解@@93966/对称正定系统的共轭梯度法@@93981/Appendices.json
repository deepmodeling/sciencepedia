{"hands_on_practices": [{"introduction": "要真正理解一个算法，没有什么能比亲手应用它更好的方法了。第一个练习邀请您完整地执行共轭梯度（Conjugate Gradient, CG）方法的单次迭代。通过手动计算残差、搜索方向和步长，您将对驱动这个强大求解器的核心机制有一个具体的感受。[@problem_id:2207655]", "problem": "在科学计算和工程领域，求解线性方程组 $Ax=b$ 是一个常见且基础的任务，其中 $A$ 是一个对称正定矩阵。这种情况通常源于使用诸如有限元法 (FEM) 等方法对偏微分方程进行离散化。共轭梯度 (CG) 算法是一种强大的迭代方法，专为求解此类方程组而设计，特别是当矩阵 $A$ 是大型稀疏矩阵时。\n\n给定以下线性方程组 $Ax=b$：\n$$\nA = \\begin{pmatrix} 3 & -1 & 0 \\\\ -1 & 2 & -1 \\\\ 0 & -1 & 3 \\end{pmatrix}, \\quad b = \\begin{pmatrix} 1 \\\\ 2 \\\\ -1 \\end{pmatrix}\n$$\n矩阵 $A$ 是对称正定的。\n\n从初始猜测 $x_0 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}$ 开始，执行共轭梯度算法的第一次完整迭代，以计算下一个近似解 $x_1$。\n\n得到的向量 $x_1$ 是什么？", "solution": "我们从 $x_{0}=\\begin{pmatrix}0 \\\\ 0 \\\\ 0\\end{pmatrix}$ 开始，对对称正定系统 $Ax=b$ 应用共轭梯度 (CG) 方法。标准的 CG 初始化和第一次迭代步骤如下：\n- 残差：$r_{0}=b-Ax_{0}=b$。\n- 搜索方向：$p_{0}=r_{0}$。\n- 步长：$\\alpha_{0}=\\dfrac{r_{0}^{T}r_{0}}{p_{0}^{T}Ap_{0}}$。\n- 更新：$x_{1}=x_{0}+\\alpha_{0}p_{0}$。\n\n对于 $A=\\begin{pmatrix}3 & -1 & 0 \\\\ -1 & 2 & -1 \\\\ 0 & -1 & 3\\end{pmatrix}$ 和 $b=\\begin{pmatrix}1 \\\\ 2 \\\\ -1\\end{pmatrix}$，我们有\n$$\nr_{0}=b=\\begin{pmatrix}1 \\\\ 2 \\\\ -1\\end{pmatrix}, \\quad p_{0}=r_{0}=\\begin{pmatrix}1 \\\\ 2 \\\\ -1\\end{pmatrix}.\n$$\n计算 $Ap_{0}$：\n$$\nAp_{0}=\\begin{pmatrix}3 & -1 & 0 \\\\ -1 & 2 & -1 \\\\ 0 & -1 & 3\\end{pmatrix}\\begin{pmatrix}1 \\\\ 2 \\\\ -1\\end{pmatrix}\n=\\begin{pmatrix}3\\cdot 1+(-1)\\cdot 2+0\\cdot(-1) \\\\ (-1)\\cdot 1+2\\cdot 2+(-1)\\cdot(-1) \\\\ 0\\cdot 1+(-1)\\cdot 2+3\\cdot(-1)\\end{pmatrix}\n=\\begin{pmatrix}1 \\\\ 4 \\\\ -5\\end{pmatrix}.\n$$\n计算 $\\alpha_{0}$ 中的标量：\n$$\nr_{0}^{T}r_{0}=1^{2}+2^{2}+(-1)^{2}=6, \\quad p_{0}^{T}Ap_{0}=\\begin{pmatrix}1 & 2 & -1\\end{pmatrix}\\begin{pmatrix}1 \\\\ 4 \\\\ -5\\end{pmatrix}=1+8+5=14.\n$$\n因此\n$$\n\\alpha_{0}=\\frac{r_{0}^{T}r_{0}}{p_{0}^{T}Ap_{0}}=\\frac{6}{14}=\\frac{3}{7}.\n$$\n更新 $x$：\n$$\nx_{1}=x_{0}+\\alpha_{0}p_{0}=\\begin{pmatrix}0 \\\\ 0 \\\\ 0\\end{pmatrix}+\\frac{3}{7}\\begin{pmatrix}1 \\\\ 2 \\\\ -1\\end{pmatrix}\n=\\begin{pmatrix}\\frac{3}{7} \\\\ \\frac{6}{7} \\\\ -\\frac{3}{7}\\end{pmatrix}.\n$$\n这就是第一次完整迭代步骤后所要求的下一个近似解。", "answer": "$$\\boxed{\\begin{pmatrix}\\frac{3}{7} \\\\ \\frac{6}{7} \\\\ -\\frac{3}{7}\\end{pmatrix}}$$", "id": "2207655"}, {"introduction": "共轭梯度法出色的效率仅在求解对称正定系统时才能得到保证。本练习将探讨当这一关键假设被违反时会发生什么，从而展示一种常见的失败模式。通过找出导致除零错误的精确条件，您将对该方法的应用边界有更深刻的理解。[@problem_id:2379067]", "problem": "在计算工程学中，共轭梯度（CG）法通常是为对称正定系统而设计的。为了说明当正定性要求不被满足时所发生的中断情况，考虑如下给出的对称不定矩阵 $A \\in \\mathbb{R}^{2 \\times 2}$ 和右端向量 $b \\in \\mathbb{R}^{2}$：\n$$\nA = \\begin{pmatrix}\n1 & 0 \\\\\n0 & -1\n\\end{pmatrix}, \\quad\nb = \\begin{pmatrix}\n1 \\\\\n0\n\\end{pmatrix}.\n$$\n设初始猜测值由一个实标量 $t \\in \\mathbb{R}$ 参数化为\n$$\n\\boldsymbol{x}_{0}(t) = t \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}.\n$$\n对于应用于线性系统 $A \\boldsymbol{x} = b$ 的标准共轭梯度法，确定实数 $t$ 的值，使得在第一次迭代计算步长时会遇到除以零的错误。请以单个实数的形式给出你的答案。无需进行四舍五入。", "solution": "问题要求找到参数 $t$ 的值，使得共轭梯度（CG）法的第一次迭代因除以零而失败。CG 法被应用于线性系统 $A \\boldsymbol{x} = b$，其中矩阵 $A$ 是对称但非正定的。\n\n标准的共轭梯度算法从一个初始猜测值 $\\boldsymbol{x}_{0}$ 开始。第一次迭代（$k=0$）按以下步骤进行：\n1.  计算初始残差：$\\boldsymbol{r}_{0} = b - A \\boldsymbol{x}_{0}$。\n2.  设置初始搜索方向：$\\boldsymbol{p}_{0} = \\boldsymbol{r}_{0}$。\n3.  计算步长：$\\alpha_{0} = \\frac{\\boldsymbol{r}_{0}^T \\boldsymbol{r}_{0}}{\\boldsymbol{p}_{0}^T A \\boldsymbol{p}_{0}}$。\n4.  更新解：$\\boldsymbol{x}_{1} = \\boldsymbol{x}_{0} + \\alpha_{0} \\boldsymbol{p}_{0}$。\n\n问题指出，在计算步长 $\\alpha_{0}$ 期间发生了除以零的错误。这意味着 $\\alpha_{0}$ 表达式的分母必须为零，而分子为非零。\n$\\alpha_{0}$ 的分母是 $\\boldsymbol{p}_{0}^T A \\boldsymbol{p}_{0}$。由于 $\\boldsymbol{p}_{0} = \\boldsymbol{r}_{0}$，中断的条件是 $\\boldsymbol{r}_{0}^T A \\boldsymbol{r}_{0} = 0$。\n\n给定：\n$$\nA = \\begin{pmatrix} 1 & 0 \\\\ 0 & -1 \\end{pmatrix}, \\quad b = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}, \\quad \\boldsymbol{x}_{0}(t) = t \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} t \\\\ t \\end{pmatrix}.\n$$\n首先，我们计算作为 $t$ 的函数的初始残差 $\\boldsymbol{r}_{0}$。\n$$\nA \\boldsymbol{x}_{0} = \\begin{pmatrix} 1 & 0 \\\\ 0 & -1 \\end{pmatrix} \\begin{pmatrix} t \\\\ t \\end{pmatrix} = \\begin{pmatrix} t \\\\ -t \\end{pmatrix}.\n$$\n$$\n\\boldsymbol{r}_{0} = b - A \\boldsymbol{x}_{0} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} t \\\\ -t \\end{pmatrix} = \\begin{pmatrix} 1-t \\\\ t \\end{pmatrix}.\n$$\n初始搜索方向为 $\\boldsymbol{p}_{0} = \\boldsymbol{r}_{0} = \\begin{pmatrix} 1-t \\\\ t \\end{pmatrix}$。\n\n接下来，我们计算构成 $\\alpha_{0}$ 分母的项 $\\boldsymbol{p}_{0}^T A \\boldsymbol{p}_{0}$。\n首先，我们求出向量 $A \\boldsymbol{p}_{0}$：\n$$\nA \\boldsymbol{p}_{0} = \\begin{pmatrix} 1 & 0 \\\\ 0 & -1 \\end{pmatrix} \\begin{pmatrix} 1-t \\\\ t \\end{pmatrix} = \\begin{pmatrix} 1-t \\\\ -t \\end{pmatrix}.\n$$\n现在，我们计算点积 $\\boldsymbol{p}_{0}^T (A \\boldsymbol{p}_{0})$：\n$$\n\\boldsymbol{p}_{0}^T A \\boldsymbol{p}_{0} = \\begin{pmatrix} 1-t & t \\end{pmatrix} \\begin{pmatrix} 1-t \\\\ -t \\end{pmatrix} = (1-t)(1-t) + t(-t) = (1-t)^2 - t^2.\n$$\n要发生除以零的情况，该分母必须等于 $0$：\n$$\n(1-t)^2 - t^2 = 0.\n$$\n展开表达式：\n$$\n(1 - 2t + t^2) - t^2 = 0.\n$$\n$$\n1 - 2t = 0.\n$$\n解出 $t$：\n$$\n2t = 1 \\implies t = \\frac{1}{2}.\n$$\n要使中断确实是因除以零而发生，对于这个 $t$ 值，分子 $\\boldsymbol{r}_{0}^T \\boldsymbol{r}_{0}$ 必须为非零。我们来验证这一点。\n当 $t = \\frac{1}{2}$ 时，残差为：\n$$\n\\boldsymbol{r}_{0} = \\begin{pmatrix} 1-\\frac{1}{2} \\\\ \\frac{1}{2} \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{2} \\\\ \\frac{1}{2} \\end{pmatrix}.\n$$\n分子项是残差的二范数平方：\n$$\n\\boldsymbol{r}_{0}^T \\boldsymbol{r}_{0} = \\left(\\frac{1}{2}\\right)^2 + \\left(\\frac{1}{2}\\right)^2 = \\frac{1}{4} + \\frac{1}{4} = \\frac{1}{2}.\n$$\n由于分子为 $\\frac{1}{2} \\ne 0$ 而分母为 $0$，当 $t = \\frac{1}{2}$ 时，$\\alpha_{0}$ 的计算确实会导致除以零。这种 $\\boldsymbol{p}_{k}^T A \\boldsymbol{p}_{k} \\le 0$ 的现象是可能发生的，因为矩阵 $A$ 不是正定的，这也是标准CG法仅限于对称正定系统的主要原因。对于一个不定矩阵，搜索方向 $\\boldsymbol{p}_{k}$ 可能与其自身是 A-正交的，这正是在 $t = \\frac{1}{2}$ 时我们对 $\\boldsymbol{p}_{0}$ 所发现的情况。", "answer": "$$\\boxed{\\frac{1}{2}}$$", "id": "2379067"}, {"introduction": "理论知识在计算验证中才能真正焕发生机。这最后一个练习要求您实现CG算法，并用它来经验性地探究矩阵的谱条件数 $\\kappa_2(A)$ 与算法收敛速度之间的关系。这个编程练习将理论与实践联系起来，是任何计算工程师都应具备的基本技能。[@problem_id:2379089]", "problem": "设计并实现一个完整的程序，该程序针对一组指定的对称正定线性系统，通过实验量化谱条件数与求解系统时达到预定残差缩减所需的迭代次数之间的关系。该程序必须构建每个系统矩阵 $A \\in \\mathbb{R}^{n \\times n}$、右端项 $b \\in \\mathbb{R}^{n}$（其所有元素 $b_i = 1$），并使用初始猜测值 $x^{(0)} = 0$。对于每个系统，计算谱条件数 $\\kappa_2(A)$（定义为 $A$ 的最大特征值与最小特征值之比），并确定最小的非负整数 $k$，使得残差的欧几里得范数满足\n$$\n\\frac{\\lVert r^{(k)} \\rVert_2}{\\lVert r^{(0)} \\rVert_2} \\leq 10^{-6},\n$$\n其中 $r^{(k)} = b - A x^{(k)}$。所用的迭代求解器必须适用于对称正定矩阵，并且仅通过矩阵-向量乘积和向量内积进行运算。对所有残差范数均使用欧几里得范数（即 $\\ell_2$-范数）。程序必须使用浮点运算。\n\n测试套件规范：\n- 案例 1：单位系统。令 $A = I_n$，其中 $n = 50$，且 $b \\in \\mathbb{R}^{50}$ 定义为对所有 $i$ 都有 $b_i = 1$。\n- 案例 2：大小为 $n=3$ 的 Hilbert 系统。令 $A = H_3$，其元素为 $A_{ij} = \\frac{1}{i + j - 1}$（$1 \\leq i,j \\leq 3$），且 $b \\in \\mathbb{R}^{3}$ 定义为对所有 $i$ 都有 $b_i = 1$。\n- 案例 3：大小为 $n=4$ 的 Hilbert 系统。令 $A = H_4$，其元素为 $A_{ij} = \\frac{1}{i + j - 1}$（$1 \\leq i,j \\leq 4$），且 $b \\in \\mathbb{R}^{4}$ 定义为对所有 $i$ 都有 $b_i = 1$。\n- 案例 4：大小为 $n=5$ 的 Hilbert 系统。令 $A = H_5$，其元素为 $A_{ij} = \\frac{1}{i + j - 1}$（$1 \\leq i,j \\leq 5$），且 $b \\in \\mathbb{R}^{5}$ 定义为对所有 $i$ 都有 $b_i = 1$。\n- 案例 5：大小为 $n=6$ 的 Hilbert 系统。令 $A = H_6$，其元素为 $A_{ij} = \\frac{1}{i + j - 1}$（$1 \\leq i,j \\leq 6$），且 $b \\in \\mathbb{R}^{6}$ 定义为对所有 $i$ 都有 $b_i = 1$。\n\n对于每个案例，程序必须输出由谱条件数 $\\kappa_2(A)$ 和达到上述停止准则的迭代次数 $k$ 组成的数对。将所有结果聚合到一行，作为方括号内以逗号分隔的列表，按以下顺序并展平为标量：\n$$\n[\\ \\kappa_2(A_1),\\ k_1,\\ \\kappa_2(A_2),\\ k_2,\\ \\kappa_2(A_3),\\ k_3,\\ \\kappa_2(A_4),\\ k_4,\\ \\kappa_2(A_5),\\ k_5\\ ],\n$$\n其中下标表示从 $1$ 到 $5$ 的案例索引。例如，一个有效的格式将类似于 $[r_1,k_1,r_2,k_2,\\ldots,r_5,k_5]$，其中每个 $r_i$ 是浮点数，每个 $k_i$ 是整数。输出中不允许有任何额外的文本或换行。", "solution": "该问题陈述是有效的。它提出了一个在数值线性代数和计算工程领域的标准、适定的练习。任务是通过实验研究对称正定（SPD）矩阵的谱条件数与合适的迭代求解器收敛速度之间的关系。所有定义和参数都已提供，问题具有科学依据、客观且内部一致。\n\n这个问题的核心在于求解线性系统 $Ax=b$，其中矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是对称正定的。这个 SPD 属性是基础，因为它保证了 $A$ 的所有特征值都是实数且为正，使得谱条件数 $\\kappa_2(A)$ 是良定义且为正的。此外，它还确保了唯一解 $x = A^{-1}b$ 的存在。单位矩阵 $I_n$ 和 Hilbert 矩阵 $H_n$ 都是 SPD 矩阵的经典示例。\n\n问题指定了一个仅使用矩阵-向量乘积和向量内积进行运算的迭代求解器。对于 SPD 系统，共轭梯度（CG）法是满足此约束的权威算法。它是一种最优方法，因为在每次迭代中，它都能在扩展的 Krylov 子空间上最小化误差的 $A$-范数。\n\nCG 算法的实现如下。给定初始猜测值 $x^{(0)} = 0$。\n首先，我们为第 $k=0$ 次迭代初始化状态变量：\n初始残差为 $r^{(0)} = b - A x^{(0)} = b$。\n初始搜索方向为 $p^{(0)} = r^{(0)}$。\n\n对于后续的由 $k=1, 2, 3, \\ldots$ 索引的迭代，我们使用以下操作序列计算下一个近似解 $x^{(k)}$：\n1. 计算步长 $\\alpha_{k-1}$：\n$$ \\alpha_{k-1} = \\frac{\\langle r^{(k-1)}, r^{(k-1)} \\rangle}{\\langle p^{(k-1)}, A p^{(k-1)} \\rangle} = \\frac{{r^{(k-1)}}^T r^{(k-1)}}{{p^{(k-1)}}^T A p^{(k-1)}} $$\n2. 更新解向量：\n$$ x^{(k)} = x^{(k-1)} + \\alpha_{k-1} p^{(k-1)} $$\n3. 更新残差。使用一种计算上更高效的形式，以避免从头重新计算 $b - Ax^{(k)}$：\n$$ r^{(k)} = r^{(k-1)} - \\alpha_{k-1} A p^{(k-1)} $$\n4. 检查停止准则。如果满足以下条件，则过程终止，所用迭代次数为 $k$：\n$$ \\frac{\\lVert r^{(k)} \\rVert_2}{\\lVert r^{(0)} \\rVert_2} \\leq 10^{-6} $$\n其中 $\\lVert \\cdot \\rVert_2$ 表示欧几里得范数。\n5. 如果未满足准则，则构造一个新的搜索方向。首先，计算 $\\beta_{k-1}$：\n$$ \\beta_{k-1} = \\frac{\\langle r^{(k)}, r^{(k)} \\rangle}{\\langle r^{(k-1)}, r^{(k-1)} \\rangle} = \\frac{{r^{(k)}}^T r^{(k)}}{{r^{(k-1)}}^T r^{(k-1)}} $$\n6. 更新搜索方向：\n$$ p^{(k)} = r^{(k)} + \\beta_{k-1} p^{(k-1)} $$\n\n谱条件数 $\\kappa_2(A)$ 定义为 $A$ 的最大特征值与最小特征值之比：\n$$ \\kappa_2(A) = \\frac{\\lambda_{\\text{max}}(A)}{\\lambda_{\\text{min}}(A)} $$\n由于 $A$ 是对称的，其特征值是实数。它们将通过数值方法计算。对于对称矩阵，`numpy.linalg.eigvalsh` 是用于此目的的一个合适且高效的工具。\n\n程序将按顺序处理每个指定的测试案例。对于每个案例，它将首先构建矩阵 $A$ 和向量 $b$。然后，它将计算 $A$ 的特征值以确定 $\\kappa_2(A)$。最后，它将执行 CG 算法，计算直到达到规定的残差缩减所需的迭代次数 $k$。生成的数对 $(\\kappa_2(A), k)$ 将被收集并格式化为所需的输出结构。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import hilbert\n\ndef count_cg_iterations(A: np.ndarray, b: np.ndarray, tol: float = 1e-6) -> int:\n    \"\"\"\n    Solves the system Ax=b for a symmetric positive-definite matrix A\n    using the Conjugate Gradient method and counts the iterations.\n\n    Args:\n        A: The symmetric positive-definite matrix of the system.\n        b: The right-hand side vector.\n        tol: The relative tolerance for the residual norm.\n\n    Returns:\n        The number of iterations k to satisfy the stopping criterion.\n    \"\"\"\n    n = A.shape[0]\n    x = np.zeros(n, dtype=float)\n    r = b.copy()\n    p = r.copy()\n\n    # Initial residual norm for the stopping criterion denominator\n    norm_r0 = np.linalg.norm(r)\n    \n    # If b is the zero vector, the solution is x=0 in 0 iterations.\n    if norm_r0 == 0:\n        return 0\n\n    # Check the condition for k=0 (initial state)\n    if np.linalg.norm(r) / norm_r0 <= tol:\n        return 0\n\n    rs_old = np.dot(r, r)\n    \n    # In exact arithmetic, CG converges in at most n iterations.\n    # We use a slightly larger limit to account for floating-point effects.\n    max_k = 2 * n\n\n    for k in range(1, max_k + 1):\n        Ap = A @ p\n        p_dot_Ap = np.dot(p, Ap)\n\n        # For an SPD matrix A, p_dot_Ap > 0 unless p=0.\n        # If p=0, then the previous residual r_old must have been 0.\n        if p_dot_Ap <= 0:\n            break\n\n        alpha = rs_old / p_dot_Ap\n        \n        x += alpha * p\n        r -= alpha * Ap\n\n        if np.linalg.norm(r) / norm_r0 <= tol:\n            return k\n            \n        rs_new = np.dot(r, r)\n        p = r + (rs_new / rs_old) * p\n        rs_old = rs_new\n    \n    # This should not be reached for the given problems, as convergence is expected.\n    # It would indicate failure to converge within max_k iterations.\n    return max_k\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and produce the final output.\n    \"\"\"\n    test_cases_spec = [\n        {'type': 'identity', 'n': 50},\n        {'type': 'hilbert', 'n': 3},\n        {'type': 'hilbert', 'n': 4},\n        {'type': 'hilbert', 'n': 5},\n        {'type': 'hilbert', 'n': 6},\n    ]\n\n    results = []\n    \n    for spec in test_cases_spec:\n        n = spec['n']\n        \n        if spec['type'] == 'identity':\n            A = np.identity(n)\n        elif spec['type'] == 'hilbert':\n            A = hilbert(n)\n        else:\n            raise ValueError(\"Unknown matrix type specified.\")\n            \n        b = np.ones(n)\n\n        # Compute spectral condition number\n        # eigvalsh returns eigenvalues in ascending order for symmetric matrices\n        eigenvalues = np.linalg.eigvalsh(A)\n        # Check for singularity or non-positive definite matrix\n        if eigenvalues[0] <= 0:\n            cond_num = np.inf\n        else:\n            cond_num = eigenvalues[-1] / eigenvalues[0]\n        \n        # Compute number of iterations\n        iterations = count_cg_iterations(A, b, tol=1e-6)\n        \n        results.extend([cond_num, iterations])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2379089"}]}