{"hands_on_practices": [{"introduction": "在我们运用像通用最小残差法（GMRES）这样强大的方法之前，我们必须首先理解它们的基石：Krylov 子空间。本练习提供了一个具体、分步的实践，指导你使用 Gram-Schmidt 过程为这个子空间，即 $\\mathcal{K}_m(A, b)$，构建正交基。这相当于 Arnoldi 迭代最初几步的纸笔演算，能为你深入理解这些方法如何探索解空间建立坚实的直觉。[@problem_id:2214825]", "problem": "在数值线性代数中，克雷洛夫子空间方法是用于求解大型线性方程组的迭代技术。像广义最小残差法（GMRES）这类算法的一个关键组成部分是为克雷洛夫子空间构造一个标准正交基。维度为 $m$ 的克雷洛夫子空间，记作 $\\mathcal{K}_m(A, b)$，定义为向量 $\\{b, Ab, A^2b, \\dots, A^{m-1}b\\}$ 的线性张成。\n\n考虑一个线性系统 $Ax=b$，其矩阵 $A$ 和初始向量 $b$ 给定如下：\n$$A = \\begin{pmatrix} 1 & 2 & 0 \\\\ 0 & 1 & 3 \\\\ 1 & 0 & 1 \\end{pmatrix}, \\quad b = \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix}$$\n请使用格拉姆-施密特过程为克雷洛夫子空间 $\\mathcal{K}_2(A, b)$ 构造一个标准正交基 $\\{q_1, q_2\\}$。该基是按序生成的，首先用向量 $v_1 = b$ 生成 $q_1$，然后用向量 $v_2 = Ab$ 生成 $q_2$。为确保答案唯一，每个基向量 $q_i$ 的第一个非零分量必须为正。\n\n您的任务是提供矩阵 $Q_2 = [q_1 | q_2]$，其中 $q_1$ 和 $q_2$ 是构成该标准正交基的列向量。请以精确的符号形式表示矩阵的元素，根据需要使用分数和平方根。", "solution": "我们对 $v_{1}=b$ 和 $v_{2}=Ab$ 使用欧几里得内积和经典的格拉姆-施密特过程。\n\n首先，设 $v_{1}=b=\\begin{pmatrix}1\\\\1\\\\0\\end{pmatrix}$。其范数为\n$$\n\\|v_{1}\\|=\\sqrt{1^{2}+1^{2}+0^{2}}=\\sqrt{2}.\n$$\n将其单位化得到\n$$\nq_{1}=\\frac{v_{1}}{\\|v_{1}\\|}=\\begin{pmatrix}\\frac{1}{\\sqrt{2}} \\\\ \\frac{1}{\\sqrt{2}} \\\\ 0\\end{pmatrix},\n$$\n其第一个非零分量为正。\n\n接下来，计算 $v_{2}=Ab$。给定\n$$\nA=\\begin{pmatrix}1&2&0\\\\0&1&3\\\\1&0&1\\end{pmatrix},\\quad b=\\begin{pmatrix}1\\\\1\\\\0\\end{pmatrix},\n$$\n我们有\n$$\nv_{2}=Ab=\\begin{pmatrix}3\\\\1\\\\1\\end{pmatrix}.\n$$\n将 $v_{2}$ 相对于 $q_{1}$ 正交化：\n$$\nh_{1,2}=q_{1}^{\\top}v_{2}=\\begin{pmatrix}\\frac{1}{\\sqrt{2}}&\\frac{1}{\\sqrt{2}}&0\\end{pmatrix}\\begin{pmatrix}3\\\\1\\\\1\\end{pmatrix}=\\frac{4}{\\sqrt{2}}=2\\sqrt{2}.\n$$\n形成正交分量\n$$\nu_{2}=v_{2}-h_{1,2}q_{1}=\\begin{pmatrix}3\\\\1\\\\1\\end{pmatrix}-2\\sqrt{2}\\begin{pmatrix}\\frac{1}{\\sqrt{2}} \\\\ \\frac{1}{\\sqrt{2}} \\\\ 0\\end{pmatrix}=\\begin{pmatrix}1\\\\-1\\\\1\\end{pmatrix}.\n$$\n将 $u_{2}$ 单位化：\n$$\n\\|u_{2}\\|=\\sqrt{1^{2}+(-1)^{2}+1^{2}}=\\sqrt{3},\\quad q_{2}=\\frac{u_{2}}{\\|u_{2}\\|}=\\begin{pmatrix}\\frac{1}{\\sqrt{3}} \\\\ -\\frac{1}{\\sqrt{3}} \\\\ \\frac{1}{\\sqrt{3}}\\end{pmatrix},\n$$\n其第一个非零分量也为正。\n\n因此，标准正交基矩阵为\n$$\nQ_{2}=\\begin{pmatrix}\n\\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{3}} \\\\\n\\frac{1}{\\sqrt{2}} & -\\frac{1}{\\sqrt{3}} \\\\\n0 & \\frac{1}{\\sqrt{3}}\n\\end{pmatrix}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}\\frac{1}{\\sqrt{2}} & \\frac{1}{\\sqrt{3}} \\\\ \\frac{1}{\\sqrt{2}} & -\\frac{1}{\\sqrt{3}} \\\\ 0 & \\frac{1}{\\sqrt{3}}\\end{pmatrix}}$$", "id": "2214825"}, {"introduction": "共轭梯度（CG）法是一种著名的 Krylov 子空间方法，但其高效性仅在处理对称正定（SPD）系统时才有保证。这个编程练习将挑战你实现 CG 算法，并观察当其核心假设被违背时的行为。通过在不定和半正定矩阵上进行测试，你将对该方法的失效模式，例如当曲率项 $p_k^T A p_k$ 变为非正数时，以及在应用算法前检查矩阵性质的重要性获得实践性的理解。[@problem_id:2407671]", "problem": "给定形式为 $A x = b$ 的线性方程组，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是实对称矩阵。标准的共轭梯度（CG）方法是为对称正定矩阵定义的，它产生的搜索方向 $p_k$ 和步长 $\\alpha_k$ 依赖于曲率量 $p_k^\\top A p_k$。请考虑以下计算任务。\n\n给定一个实对称矩阵 $A$、一个右端项 $b$、一个初始猜测值 $x_0 = 0$、一个容差 $\\varepsilon$ 以及最大迭代次数 $k_{\\max}$，请编写一个程序，尝试使用标准共轭梯度方法求解 $A x = b$，并根据以下规则为每种情况返回一个状态码：\n\n- 如果方法在某次迭代 $k \\le k_{\\max}$ 时达到 $\\lVert r_k \\rVert_2 \\le \\varepsilon$，且从未遇到非正曲率，则返回 $1$。其中 $r_k = b - A x_k$ 是残差，$\\lVert \\cdot \\rVert_2$ 表示欧几里得范数。\n- 如果在任何迭代 $k$ 中，曲率量 $p_k^\\top A p_k \\le 0$，则返回 $0$。这表明违反了标准共轭梯度方法固有的正定性要求。\n- 如果方法完成了 $k_{\\max}$ 次迭代后，仍未满足 $\\lVert r_k \\rVert_2 \\le \\varepsilon$ 且从未遇到 $p_k^\\top A p_k \\le 0$，则返回 $-1$。\n\n使用以下测试套件。在所有情况下，均使用初始猜测值 $x_0 = 0$、容差 $\\varepsilon = 10^{-10}$ 和最大迭代次数 $k_{\\max} = 10$。\n\n- 测试用例 1（对称正定，预计收敛）： \n  $$A_1 = \\begin{bmatrix} 4 & 1 & 0 \\\\ 1 & 3 & 1 \\\\ 0 & 1 & 2 \\end{bmatrix}, \\quad b_1 = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}.$$\n- 测试用例 2（对称半正定但奇异，表现出零曲率）： \n  $$A_2 = \\begin{bmatrix} 1 & 0 \\\\ 0 & 0 \\end{bmatrix}, \\quad b_2 = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}.$$\n- 测试用例 3（对称不定，表现出负曲率）： \n  $$A_3 = \\begin{bmatrix} 1 & 2 & 0 \\\\ 2 & 1 & 0 \\\\ 0 & 0 & 3 \\end{bmatrix}, \\quad b_3 = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix}.$$\n\n您的程序应产生单行输出，其中包含按测试用例顺序排列、用方括号括起来的、以逗号分隔的结果列表，例如：$[s_1,s_2,s_3]$，其中每个 $s_i \\in \\{-1,0,1\\}$ 是测试用例 $i$ 的状态码。", "solution": "所提出的问题陈述是有效的。它在数值线性代数这一成熟领域有科学依据，特别是关于 Krylov 子空间方法。该任务是实现标准共轭梯度（CG）算法，并监测其在应用于不一定为正定的对称矩阵时的行为。该问题是适定的、客观的且自洽的，提供了所有必需的矩阵、向量和参数（$x_0$、$\\varepsilon$、$k_{\\max}$），以便为每个测试用例生成唯一、确定的结果。指定的返回码对应于 CG 方法已知的失败模式或成功条件。因此，可以直接构建一个解决方案。\n\n共轭梯度法是一种求解形式为 $A x = b$ 的线性方程组的迭代算法，其中矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是对称正定（SPD）的。该方法的收敛性和稳定性关键取决于正定性，正定性确保了曲率量 $p_k^\\top A p_k$ 始终为正。这一项出现在步长 $\\alpha_k$ 的分母中，其正性保证了每一步都朝着二次型 $f(x) = \\frac{1}{2} x^\\top A x - b^\\top x$ 的最小值方向移动。\n\n标准 CG 算法定义如下。给定方程组 $A x = b$、初始猜测值 $x_0$、容差 $\\varepsilon > 0$ 和最大迭代次数 $k_{\\max}$。\n\n首先，在迭代 $k=0$ 时初始化状态变量：\n初始解给定为 $x_0 = 0$。\n初始残差为 $r_0 = b - A x_0 = b$。\n初始搜索方向设为残差：$p_0 = r_0$。\n\n算法随后进入一个迭代循环，$k = 0, 1, 2, \\ldots, k_{\\max}-1$。在每次迭代 $k$ 中，执行以下步骤：\n\n1.  计算矩阵-向量乘积 $v_k = A p_k$。\n2.  计算曲率项，它是一个标量：$d_k = p_k^\\top v_k = p_k^\\top A p_k$。问题要求我们检查 $A$ 相对于当前搜索方向是否表现为正定矩阵。如果 $d_k \\le 0$，则违反了正定性假设。算法无法以有意义的方式继续进行，因为步长 $\\alpha_k$ 会是负数、零或未定义，从而偏离解。在这种情况下，我们必须终止并返回状态码 $0$。\n3.  如果曲率为正，计算沿方向 $p_k$ 的最优步长：\n    $$ \\alpha_k = \\frac{r_k^\\top r_k}{p_k^\\top A p_k} $$\n4.  更新解向量：\n    $$ x_{k+1} = x_k + \\alpha_k p_k $$\n5.  更新残差。为避免昂贵的重新计算（$r_{k+1} = b - A x_{k+1}$），我们使用一个递推公式：\n    $$ r_{k+1} = r_k - \\alpha_k A p_k = r_k - \\alpha_k v_k $$\n6.  检查是否收敛。我们计算新残差的欧几里得范数 $\\lVert r_{k+1} \\rVert_2$。如果 $\\lVert r_{k+1} \\rVert_2 \\le \\varepsilon$，则认为解足够精确。我们终止并返回状态码 $1$。\n7.  如果方法尚未收敛，我们通过计算一个与前一个搜索方向 $p_k$ A-正交的新搜索方向 $p_{k+1}$ 来为下一次迭代做准备。这通过首先计算系数 $\\beta_k$ 来完成：\n    $$ \\beta_k = \\frac{r_{k+1}^\\top r_{k+1}}{r_k^\\top r_k} $$\n8.  然后，新的搜索方向是新残差和旧搜索方向的线性组合：\n    $$ p_{k+1} = r_{k+1} + \\beta_k p_k $$\n\n如果循环在 $k_{\\max}$ 次迭代后完成，而残差范数仍未降至容差 $\\varepsilon$ 以下，且从未遇到非正曲率，则表示该方法未能在给定的迭代次数限制内收敛。在这种情况下，我们返回状态码 $-1$。\n\n在实现时，我们创建一个函数，它以 $A$、$b$、$x_0$、$\\varepsilon$ 和 $k_{\\max}$ 作为输入。在主循环之前，我们计算初始残差 $r_0$ 并检查其范数 $\\lVert r_0 \\rVert_2$。如果它已经小于或等于 $\\varepsilon$，我们可以立即返回状态码 $1$。否则，我们继续执行上述迭代过程。提供的三个测试用例中的每一个都旨在触发三个指定结果之一：\n-   测试用例 1：$A_1$ 是一个对称正定矩阵。它的所有特征值都为正，这保证了对于任何非零向量 $p$，都有 $p^\\top A_1 p > 0$。CG 方法预计将在几次迭代内收敛到解。状态码将为 $1$。\n-   测试用例 2：$A_2$ 是一个对称半正定矩阵，因为它的特征值为 $1$ 和 $0$。它是奇异的。CG 算法可能会生成一个位于 $A_2$ 零空间中的搜索方向，这会导致曲率项 $p_k^\\top A_2 p_k = 0$。这将终止算法并产生状态码 $0$。\n-   测试用例 3：$A_3$ 是一个对称不定矩阵，同时具有正特征值和负特征值。CG 方法不保证能保持正曲率。可能会生成一个搜索方向 $p_k$ 使得 $p_k^\\top A_3 p_k < 0$。这种情况也使标准 CG 方法的前提失效，需要以状态码 $0$ 终止。\n\n程序将对三个测试用例中的每一个执行此逻辑，并报告所得的状态码。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef conjugate_gradient_with_status(A, b, x0, tol, k_max):\n    \"\"\"\n    Attempts to solve Ax=b using the Conjugate Gradient method with specific status reporting.\n\n    Args:\n        A (np.ndarray): A real symmetric matrix.\n        b (np.ndarray): The right-hand side vector.\n        x0 (np.ndarray): The initial guess for the solution.\n        tol (float): The tolerance for the residual norm.\n        k_max (int): The maximum number of iterations.\n\n    Returns:\n        int: Status code (1: converged, 0: non-positive curvature, -1: max iterations reached).\n    \"\"\"\n    x = x0.copy().astype(float)\n    r = b - A @ x\n    p = r.copy()\n    \n    # Check initial residual norm for trivial convergence\n    r_norm = np.linalg.norm(r)\n    if r_norm <= tol:\n        return 1\n\n    rs_old = np.dot(r, r)\n\n    for k in range(k_max):\n        Ap = A @ p\n        \n        # Calculate curvature: p^T * A * p\n        curvature = np.dot(p, Ap)\n        \n        # Check for non-positive curvature (breakdown of CG)\n        if curvature <= 0:\n            return 0  # Status for non-positive definite behavior\n        \n        # Update solution and residual\n        alpha = rs_old / curvature\n        x += alpha * p\n        r -= alpha * Ap\n        \n        # Check for convergence\n        r_norm = np.linalg.norm(r)\n        if r_norm <= tol:\n            return 1  # Status for successful convergence\n        \n        # Update search direction\n        rs_new = np.dot(r, r)\n        beta = rs_new / rs_old\n        p = r + beta * p\n        rs_old = rs_new\n        \n    return -1 # Status for exceeding max iterations without convergence\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases for the Conjugate Gradient problem.\n    \"\"\"\n    # Define global parameters for all test cases\n    x0_val = 0.0  # Scalar, will be broadcast to vector of zeros\n    tol = 1e-10\n    k_max = 10\n\n    # Test Case 1: Symmetric Positive Definite\n    A1 = np.array([[4, 1, 0], \n                   [1, 3, 1], \n                   [0, 1, 2]], dtype=float)\n    b1 = np.array([1, 2, 3], dtype=float)\n\n    # Test Case 2: Symmetric Positive Semidefinite (Singular)\n    A2 = np.array([[1, 0], \n                   [0, 0]], dtype=float)\n    b2 = np.array([1, 1], dtype=float)\n\n    # Test Case 3: Symmetric Indefinite\n    A3 = np.array([[1, 2, 0], \n                   [2, 1, 0], \n                   [0, 0, 3]], dtype=float)\n    b3 = np.array([1, 0, 0], dtype=float)\n    \n    test_cases = [\n        (A1, b1),\n        (A2, b2),\n        (A3, b3),\n    ]\n\n    results = []\n    for A, b in test_cases:\n        n = A.shape[0]\n        x0 = np.full(n, x0_val, dtype=float)\n        status = conjugate_gradient_with_status(A, b, x0, tol, k_max)\n        results.append(status)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2407671"}, {"introduction": "理论上，构建 Krylov 子空间正交基的方法有很多，但在有限精度的计算机世界里，算法的选择会产生深远的影响。本实践将展示在 Arnoldi 迭代中，经典 Gram-Schmidt（CGS）和修正 Gram-Schmidt（MGS）过程之间的关键差异。通过在病态问题上测量正交性的损失 $\\ell(Q_k) = \\| I_m - Q_k^T Q_k \\|_F$，你将亲眼见证为何 MGS 是构建稳健数值软件的首选方法。[@problem_id:2407638]", "problem": "给定方形实矩阵和一个初始向量，您必须数值量化当Arnoldi过程内部的正交化分别使用经典Gram–Schmidt (CGS)或修正Gram–Schmidt (MGS)时，所生成的Arnoldi基的正交性损失。考虑广义最小残差（GMRES）方法，该方法为Krylov子空间构建一个Arnoldi基。对于一个实矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和一个非零起始向量 $r_0 \\in \\mathbb{R}^n$，定义k阶Krylov子空间为\n$$\n\\mathcal{K}_k(A,r_0) = \\operatorname{span}\\{r_0, A r_0, A^2 r_0, \\dots, A^{k-1} r_0\\}.\n$$\n设 $Q_k \\in \\mathbb{R}^{n \\times m}$ 是一个矩阵，其列是在尝试为 $\\mathcal{K}_k(A,r_0)$ 生成标准正交基时产生的前 $m$ 个Arnoldi向量，其中如果因崩溃而提前终止，则 $m \\le k$。定义正交性损失度量为\n$$\n\\ell(Q_k) = \\left\\| I_m - Q_k^\\top Q_k \\right\\|_F,\n$$\n其中 $\\|\\cdot\\|_F$ 表示Frobenius范数，$I_m$ 是 $m \\times m$ 的单位矩阵。对于下文的每个测试用例，计算两个实数：$\\ell_{\\mathrm{CGS}} = \\ell(Q_k^{\\mathrm{CGS}})$ 和 $\\ell_{\\mathrm{MGS}} = \\ell(Q_k^{\\mathrm{MGS}})$，它们分别是Arnoldi过程使用经典Gram–Schmidt和修正Gram–Schmidt进行标准正交化时获得的结果。\n\n请使用双精度算术。对于所有测试用例，使用初始残差 $r_0 = b \\in \\mathbb{R}^n$，其元素为 $b_i = \\sin(i)$，其中 $i \\in \\{1,2,\\dots,n\\}$，并且正弦函数的角度单位为弧度。\n\n测试套件：\n- 情况1（对称正定三对角矩阵）：设 $n=50, k=25$，且 $A \\in \\mathbb{R}^{n \\times n}$ 定义为 $A_{i,i}=2$（$1 \\le i \\le n$），$A_{i,i+1}=A_{i+1,i}=-1$（$1 \\le i < n$），所有其他元素均为 $0$。\n- 情况2（病态对角矩阵）：设 $n=60, k=30$，且 $A=\\operatorname{diag}(\\lambda_1,\\dots,\\lambda_n)$，其中 $\\lambda_i = 10^{\\alpha_i}$ 且 $\\alpha_i = -8 + \\dfrac{(i-1)\\cdot 8}{n-1}$（$1 \\le i \\le n$）。\n- 情况3（非正规上双对角矩阵）：设 $n=50, k=25$，且 $A \\in \\mathbb{R}^{n \\times n}$ 定义为 $A_{i,i}=1$（$1 \\le i \\le n$），$A_{i,i+1}=0.9$（$1 \\le i < n$），所有其他元素均为 $0$。\n- 情况4（近亏损上双对角矩阵）：设 $n=40, k=35$，且 $A \\in \\mathbb{R}^{n \\times n}$ 定义为 $A_{i,i}=\\rho$ 且 $\\rho=0.999$（$1 \\le i \\le n$），$A_{i,i+1}=1$（$1 \\le i < n$），所有其他元素均为 $0$。\n\n您的程序必须为每种情况尝试从 $r_0=b$ 开始构建一个k阶Arnoldi基，为每个变体中实际构建的矩阵 $Q_k$（使用生成的前 $m$ 列，如果发生崩溃则 $m \\le k$）计算 $\\ell_{\\mathrm{CGS}}$ 和 $\\ell_{\\mathrm{MGS}}$，并按指定格式报告结果。\n\n最终输出格式：\n- 生成单行输出，包含一个有四个条目的列表，每个条目对应一个测试用例，其中每个条目是一个包含两个元素的列表 $[\\ell_{\\mathrm{CGS}},\\ell_{\\mathrm{MGS}}]$。\n- 每个实数必须四舍五入到10位有效数字。\n- 该行不得包含空格。\n- 例如，一个有效的形状是 $[[x_{11},x_{12}],[x_{21},x_{22}],[x_{31},x_{32}],[x_{41},x_{42}]]$，其中每个 $x_{ij}$ 都是一个经过四舍五入的小数字符串。\n\n本问题不涉及物理单位。在 b 的定义中，所有角度均以弧度为单位。每个测试用例的最终答案必须是实数，并且最终输出必须遵循上述单行格式。", "solution": "该问题要求在Arnoldi迭代的背景下，对两种正交化方案——经典Gram-Schmidt（CGS）和修正Gram-Schmidt（MGS）——的稳定性进行数值比较。稳定性是通过对一组定义明确的测试用例，测量所生成基的正交性损失来量化的。整个计算将使用双精度浮点运算进行。\n\nArnoldi迭代是数值线性代数中的一种基本算法，用于为Krylov子空间 $\\mathcal{K}_k(A, r_0) = \\operatorname{span}\\{r_0, A r_0, \\dots, A^{k-1} r_0\\}$ 构建一个标准正交基。对于给定的矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和初始向量 $r_0 \\in \\mathbb{R}^n$，该过程生成一系列标准正交向量 $q_1, q_2, \\dots, q_k$，它们的生成空间是 $\\mathcal{K}_k(A, r_0)$。这些向量构成了矩阵 $Q_k = [q_1, q_2, \\dots, q_k] \\in \\mathbb{R}^{n \\times k}$ 的列。该过程首先对初始向量进行单位化：$q_1 = r_0 / \\|r_0\\|_2$。随后，对于 $j=1, 2, \\dots, k-1$，通过计算矩阵向量乘积 $v = A q_j$ 并使其相对于先前计算的基向量 $\\{q_1, q_2, \\dots, q_j\\}$ 正交来生成向量 $q_{j+1}$。这就是Gram-Schmidt过程。然后将所得向量进行单位化。\n\n问题的核心在于此正交化步骤的实现。\n\n经典Gram-Schmidt（CGS）方法通过同时减去 $v=Aq_j$ 在所有已有基向量上的投影来计算新向量。首先，计算投影系数 $h_{i,j}$：\n$$\nh_{i,j} = q_i^T v \\quad \\text{其中 } i = 1, 2, \\dots, j.\n$$\n然后，通过减去基向量的线性组合来形成新向量 $\\hat{v}$：\n$$\n\\hat{v} = v - \\sum_{i=1}^{j} h_{i,j} q_i.\n$$\n最后，将此向量单位化以获得下一个基向量，$q_{j+1} = \\hat{v} / \\|\\hat{v}\\|_2$，其中范数 $\\|\\hat{v}\\|_2$ 对应于Hessenberg矩阵的元素 $h_{j+1,j}$。\n\n修正Gram-Schmidt（MGS）方法按顺序执行正交化。它不是将原始向量 $v$ 投影到每个基向量上，而是投影一个已经与前面基向量正交的中间向量。设 $w^{(0)} = v = A q_j$。该过程对 $i=1, 2, \\dots, j$ 进行迭代：\n$$\nh_{i,j} = q_i^T w^{(i-1)},\n$$\n$$\nw^{(i)} = w^{(i-1)} - h_{i,j} q_i.\n$$\n经过 $j$ 步后得到的向量是 $\\hat{v} = w^{(j)}$。然后将此向量单位化得到 $q_{j+1} = \\hat{v} / \\|\\hat{v}\\|_2$。\n\n在精确算术中，CGS和MGS是等价的。然而，在有限精度算术中，它们的数值属性有显著差异。由于舍入误差，计算出的基向量 $\\{q_i\\}$ 并非完全正交，即当 $i \\neq j$ 时 $q_i^T q_j \\neq 0$。在CGS中，所有的点积 $q_i^T v$ 都是用同一个向量 $v$ 计算的。如果基向量已经失去了一些正交性，误差会累积，导致一种称为灾难性抵消的现象。结果向量 $\\hat{v}$ 可能会保留本应被移除的、沿着 $q_1, \\dots, q_j$ 方向的显著分量。MGS更稳定，因为在每一步中被正交化的向量都会更新。计算 $q_i^T w^{(i-1)}$ 使用的是一个已经与 $\\{q_1, \\dots, q_{i-1}\\}$ 数值上正交的向量，这减少了舍入误差的传播，并在更高程度上保持了基向量的正交性。\n\n我们被要求使用以下度量来量化这种正交性损失\n$$\n\\ell(Q_m) = \\| I_m - Q_m^T Q_m \\|_F,\n$$\n其中 $Q_m \\in \\mathbb{R}^{n \\times m}$ 是由 $m$ 个生成的Arnoldi向量组成的矩阵（如果发生崩溃，则 $m \\le k$），$I_m$ 是 $m \\times m$ 的单位矩阵，$\\|\\cdot\\|_F$ 是Frobenius范数。对于一个完全标准正交的基，$Q_m^T Q_m = I_m$ 且 $\\ell(Q_m) = 0$。偏离零的值表示正交性的损失。\n\n解决策略如下：\n1. 对于每个测试用例，构建指定的矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和初始向量 $r_0 = b \\in \\mathbb{R}^n$，其中 $b_i = \\sin(i)$，$i=1,\\dots,n$。\n2. 为指定的步数 $k$ 实现Arnoldi迭代。该实现将包括CGS和MGS两种正交化方法的变体。\n3. 该过程必须能够检测崩溃，当待单位化的向量的范数 $h_{j+1,j}$ 低于一个很小的容差时，就会发生崩溃。如果在第 $j$ 步发生崩溃，过程将终止，产生一个维度为 $m=j$ 的基。问题指定最大步数为 $k$，因此最终的基将有 $m \\le k$ 个向量。\n4. 对于每种情况和每种方法（CGS和MGS），生成基矩阵 $Q_m$。\n5. 为 $Q_m^{\\mathrm{CGS}}$ 和 $Q_m^{\\mathrm{MGS}}$ 计算正交性损失度量 $\\ell(Q_m)$。\n6. 最终输出将是一个格式化的列表，包含每个测试用例计算出的损失值对 $[\\ell_{\\mathrm{CGS}}, \\ell_{\\mathrm{MGS}}]$。", "answer": "```python\nimport numpy as np\n\ndef format_num(n):\n    \"\"\"Formats a number to 10 significant digits for the final output.\"\"\"\n    return \"{:.10g}\".format(n)\n\ndef arnoldi_process(A, r0, k, method):\n    \"\"\"\n    Performs the Arnoldi iteration to generate an orthonormal basis Q for the\n    Krylov subspace K_k(A, r0).\n\n    Args:\n        A (np.ndarray): The matrix of size (n, n).\n        r0 (np.ndarray): The starting vector of size (n,).\n        k (int): The number of Arnoldi vectors to generate.\n        method (str): The orthogonalization method, either 'cgs' or 'mgs'.\n    \n    Returns:\n        np.ndarray: A matrix Q of size (n, m) with m <= k orthonormal columns.\n    \"\"\"\n    n = A.shape[0]\n    # Use double precision explicitly as required\n    Q = np.zeros((n, k), dtype=np.float64)\n    # A small tolerance for breakdown detection.\n    tol = 1e-12\n\n    norm_r0 = np.linalg.norm(r0)\n    if norm_r0 < tol:\n        # r0 is effectively the zero vector, Krylov subspace is trivial.\n        return np.zeros((n, 0), dtype=np.float64)\n\n    Q[:, 0] = r0 / norm_r0\n    m = 1  # Number of vectors generated so far\n\n    for j in range(k - 1):\n        v = A @ Q[:, j]\n        \n        # Orthogonalization against the current basis Q[:, :m], where m = j + 1\n        if method == 'cgs':\n            # Classical Gram-Schmidt\n            h = Q[:, :m].T @ v\n            w = v - Q[:, :m] @ h\n        \n        elif method == 'mgs':\n            # Modified Gram-Schmidt\n            w = v.copy()\n            for i in range(m):\n                # h_ij = q_i^T w\n                h_ij = Q[:, i].T @ w\n                # w = w - h_ij * q_i\n                w = w - h_ij * Q[:, i]\n        else:\n            raise ValueError(\"Method must be 'cgs' or 'mgs'\")\n            \n        h_next = np.linalg.norm(w)\n        \n        if h_next < tol:\n            # Breakdown: The Krylov subspace has dimension m and is invariant under A.\n            return Q[:, :m]\n        \n        Q[:, j + 1] = w / h_next\n        m += 1\n        \n    return Q[:, :m]\n\ndef solve():\n    \"\"\"\n    Solves the problem by running Arnoldi with CGS and MGS for each test case\n    and printing the results in the specified format.\n    \"\"\"\n    test_cases_params = [\n        {'n': 50, 'k': 25, 'id': 'case1'},\n        {'n': 60, 'k': 30, 'id': 'case2'},\n        {'n': 50, 'k': 25, 'id': 'case3'},\n        {'n': 40, 'k': 35, 'id': 'case4'}\n    ]\n\n    all_results = []\n\n    for params in test_cases_params:\n        n, k, case_id = params['n'], params['k'], params['id']\n        \n        # Construct matrix A for the current test case\n        if case_id == 'case1': # symmetric positive definite tridiagonal\n            A = np.diag(np.full(n, 2.0, dtype=np.float64)) + \\\n                np.diag(np.full(n - 1, -1.0, dtype=np.float64), k=1) + \\\n                np.diag(np.full(n - 1, -1.0, dtype=np.float64), k=-1)\n        elif case_id == 'case2': # ill-conditioned diagonal\n            i = np.arange(1, n + 1, dtype=np.float64)\n            alphas = -8.0 + (i - 1.0) * 8.0 / (n - 1.0)\n            lambdas = 10.0**alphas\n            A = np.diag(lambdas)\n        elif case_id == 'case3': # non-normal upper bidiagonal\n            A = np.diag(np.full(n, 1.0, dtype=np.float64)) + \\\n                np.diag(np.full(n - 1, 0.9, dtype=np.float64), k=1)\n        elif case_id == 'case4': # nearly defective upper bidiagonal\n            rho = 0.999\n            A = np.diag(np.full(n, rho, dtype=np.float64)) + \\\n                np.diag(np.full(n - 1, 1.0, dtype=np.float64), k=1)\n\n        # Construct initial vector b (r0)\n        i_vec = np.arange(1, n + 1, dtype=np.float64)\n        r0 = np.sin(i_vec)\n\n        case_results = []\n        for method in ['cgs', 'mgs']:\n            Q = arnoldi_process(A, r0, k, method)\n            m = Q.shape[1]\n            \n            if m == 0:\n                loss = 0.0\n            else:\n                I_m = np.eye(m, dtype=np.float64)\n                loss_matrix = I_m - Q.T @ Q\n                loss = np.linalg.norm(loss_matrix, 'fro')\n            case_results.append(loss)\n        \n        all_results.append(case_results)\n\n    # Format the final output string exactly as required\n    list_of_strs = []\n    for pair in all_results:\n        cgs_str = format_num(pair[0])\n        mgs_str = format_num(pair[1])\n        list_of_strs.append(f\"[{cgs_str},{mgs_str}]\")\n    \n    final_output_str = f\"[{','.join(list_of_strs)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "2407638"}]}