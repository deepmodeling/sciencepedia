{"hands_on_practices": [{"introduction": "预条件共轭梯度（PCG）方法是求解大型对称正定（SPD）线性系统的强大工具。然而，为了保证算法的稳定性和收敛性，所选择的预条件子 $M$ 不仅需要是 $A$ 的一个良好近似，其本身也必须是SPD矩阵。本练习通过一个简单的计算，揭示了当使用一个非SPD预条件子时PCG方法如何发生“崩溃”，从而加深您对PCG方法数学基础的理解。", "problem": "考虑线性系统 $A \\mathbf{x} = \\mathbf{b}$，其中对称正定（SPD）矩阵为\n$$\nA = \\begin{pmatrix}\n2 & 0 \\\\\n0 & 1\n\\end{pmatrix},\n$$\n右端项为\n$$\n\\mathbf{b} = \\begin{pmatrix}\n1 \\\\\n1\n\\end{pmatrix},\n$$\n初始猜测值为 $\\mathbf{x}_{0} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$。设预条件子为对称但非SPD的矩阵\n$$\nM = \\begin{pmatrix}\n1 & 0 \\\\\n0 & -1\n\\end{pmatrix}.\n$$\n定义初始残差 $\\mathbf{r}_{0} = \\mathbf{b} - A \\mathbf{x}_{0}$ 和预处理残差 $\\mathbf{z}_{0}$ 为 $M \\mathbf{z}_{0} = \\mathbf{r}_{0}$ 的唯一解。考虑标量\n$$\ns = \\mathbf{r}_{0}^{\\top} \\mathbf{z}_{0}.\n$$\n精确计算 $s$。将您的最终答案表示为单个实数。无需四舍五入。", "solution": "矩阵 $A$ 是对称正定的，因为它是一个对角矩阵，其对角线上的正元素为 $2$ 和 $1$。矩阵 $M$ 是对称的但非正定，因为其特征值为 $1$ 和 $-1$，所以它是不定的。\n\n根据定义，初始残差为\n$$\n\\mathbf{r}_{0} = \\mathbf{b} - A \\mathbf{x}_{0}.\n$$\n对于 $\\mathbf{x}_{0} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$，我们得到\n$$\n\\mathbf{r}_{0} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} - \\begin{pmatrix} 2 & 0 \\\\ 0 & 1 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}.\n$$\n预处理残差 $\\mathbf{z}_{0}$ 通过求解下式来定义\n$$\nM \\mathbf{z}_{0} = \\mathbf{r}_{0}.\n$$\n由于 $M = \\begin{pmatrix} 1 & 0 \\\\ 0 & -1 \\end{pmatrix}$ 是可逆的，且 $M^{-1} = M$，我们有\n$$\n\\mathbf{z}_{0} = M^{-1} \\mathbf{r}_{0} = M \\mathbf{r}_{0} = \\begin{pmatrix} 1 & 0 \\\\ 0 & -1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix}.\n$$\n现在计算标量\n$$\ns = \\mathbf{r}_{0}^{\\top} \\mathbf{z}_{0} = \\begin{pmatrix} 1 & 1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix} = 1 \\cdot 1 + 1 \\cdot (-1) = 0.\n$$\n这个值直接显示了预处理共轭梯度（PCG）法的一种失效模式：在标准的左预处理形式中，步长系数 $\\alpha_{0}$ 使用分子 $(\\mathbf{r}_{0}^{\\top} \\mathbf{z}_{0})$，而搜索方向的递推式使用比值 $(\\mathbf{r}_{k+1}^{\\top} \\mathbf{z}_{k+1}) / (\\mathbf{r}_{k}^{\\top} \\mathbf{z}_{k})$。当 $s = \\mathbf{r}_{0}^{\\top} \\mathbf{z}_{0} = 0$ 且 $\\mathbf{r}_{0} \\neq \\mathbf{0}$ 时，在使用非SPD预条件子 $M$ 的情况下，该方法会在第一次迭代时遇到中断。\n\n因此，所求标量为 $0$。", "answer": "$$\\boxed{0}$$", "id": "2427468"}, {"introduction": "在预条件方法之外，迭代算法本身的设计也至关重要。本练习将目光转向非对称系统，通过一个精心构造的例子，我们将看到双共轭梯度（BiCG）方法如何因其对“影子”残差的依赖而可能出现意外的计算崩溃。这个动手计算旨在阐明开发更稳健算法——如双共轭梯度稳定（BiCGSTAB）方法——的内在动机。", "problem": "考虑线性系统 $A x = b$，其中 $3 \\times 3$ 矩阵为\n$$\nA \\;=\\; \\begin{pmatrix}\n1 & 1 & 0\\\\\n0 & 1 & 1\\\\\n0 & 0 & 1\n\\end{pmatrix},\n$$\n右端项 $b = \\begin{pmatrix}1\\\\0\\\\0\\end{pmatrix}$，以及初始猜测解 $x_0 = \\begin{pmatrix}0\\\\0\\\\0\\end{pmatrix}$。在精确算术下进行计算，并假设使用单位预条件子 $M = I$ 进行左预处理。设初始残差为 $r_0 = b - A x_0$，并为双共轭梯度（BiCG）方法选择影子残差为 $r_0^{\\ast} = \\begin{pmatrix}0\\\\1\\\\0\\end{pmatrix}$。将BiCG的搜索方向初始化为 $p_0 = r_0$ 和 $p_0^{\\ast} = r_0^{\\ast}$。\n\n仅使用双共轭梯度（BiCG）方法和稳定双共轭梯度（BiCGSTAB）方法的标准定义，完成以下任务：\n\n- 计算BiCG首次迭代的分母 $d_0 = p_0^{\\ast\\,T} A p_0$，并证明对于此例，BiCG迭代在第一步即告中断。\n- 根据BiCGSTAB的定义操作，简要解释为什么在通常选择 $\\hat{r} = r_0$ 的情况下，对于相同的 $A$、$b$ 和 $x_0$，此步中相应的分母不为零，因此BiCGSTAB迭代在第一步不会遇到这种特定的中断情况。\n\n答案要求：\n- 最终答案只提供 $d_0$ 的精确值。\n- 无需四舍五入。\n- 不涉及单位。", "solution": "问题要求分析给定的线性系统 $A x = b$ 上，双共轭梯度（BiCG）和稳定双共轭梯度（BiCGSTAB）方法的首次迭代。\n\n给定的数据如下：\n矩阵 $A$ 为\n$$\nA = \\begin{pmatrix}\n1 & 1 & 0\\\\\n0 & 1 & 1\\\\\n0 & 0 & 1\n\\end{pmatrix}\n$$\n右端项向量 $b$ 为\n$$\nb = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n初始猜测解 $x_0$ 为零向量\n$$\nx_0 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n预条件子是单位矩阵 $M=I$，这意味着我们考虑的是这些算法的非预处理版本。\n\n首先，我们处理BiCG方法。初始残差 $r_0$ 计算如下：\n$$\nr_0 = b - A x_0 = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 1 & 1 & 0\\\\ 0 & 1 & 1\\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n问题指定初始影子残差 $r_0^{\\ast}$ 为：\n$$\nr_0^{\\ast} = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}\n$$\n初始搜索方向设置为 $p_0 = r_0$ 和 $p_0^{\\ast} = r_0^{\\ast}$。因此，\n$$\np_0 = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} \\quad \\text{和} \\quad p_0^{\\ast} = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}\n$$\n第一个任务是计算BiCG更新步骤中的分母 $d_0 = p_0^{\\ast\\,T} A p_0$。首先，我们计算乘积 $A p_0$：\n$$\nA p_0 = \\begin{pmatrix} 1 & 1 & 0\\\\ 0 & 1 & 1\\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 \\cdot 1 + 1 \\cdot 0 + 0 \\cdot 0 \\\\ 0 \\cdot 1 + 1 \\cdot 0 + 1 \\cdot 0 \\\\ 0 \\cdot 1 + 0 \\cdot 0 + 1 \\cdot 0 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n现在，我们可以计算 $d_0$：\n$$\nd_0 = p_0^{\\ast\\,T} (A p_0) = \\begin{pmatrix} 0 & 1 & 0 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} = 0 \\cdot 1 + 1 \\cdot 0 + 0 \\cdot 0 = 0\n$$\nBiCG算法中的步长 $\\alpha_k$ 计算公式为 $\\alpha_k = \\frac{r_k^{\\ast\\,T} r_k}{p_k^{\\ast\\,T} A p_k}$。对于首次迭代，$k=0$，步长为 $\\alpha_0 = \\frac{r_0^{\\ast\\,T} r_0}{p_0^{\\ast\\,T} A p_0}$。此表达式的分母恰好是 $d_0$。由于 $d_0 = 0$，计算 $\\alpha_0$ 时会涉及除以零。这是BiCG算法的一次“严重中断”，使其无法继续进行。发生这种中断是因为所选的影子搜索方向 $p_0^\\ast$ 与搜索方向 $p_0$ 是A-正交的，即 $p_0^{\\ast\\,T} A p_0 = 0$。\n\n接下来，我们分析BiCGSTAB方法的第一步。对于BiCGSTAB，不存在影子残差序列。取而代之的是，该算法采用了一个涉及额外一次与 $A$ 相乘的“稳定化”步骤。初始步长，记为 $\\alpha_0$，计算如下：\n$$\n\\alpha_0 = \\frac{\\rho_0}{\\hat{r}^T v_0}\n$$\n其中 $\\rho_0 = \\hat{r}^T r_0$，$v_0 = A p_0$，且 $p_0 = r_0$。向量 $\\hat{r}$ 是一个任意向量，但通常的标准选择是 $\\hat{r} = r_0$。问题要求我们考虑这种选择。\n当 $\\hat{r} = r_0$ 时，$\\alpha_0$ 的分母变为 $r_0^T v_0 = r_0^T A p_0$。由于 $p_0$ 也被初始化为 $r_0$，分母即为 $r_0^T A r_0$。\n\n我们来为给定的问题计算这个值。我们有 $r_0 = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}$，并且如前所计算，$A r_0 = A p_0 = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}$。\n分母为：\n$$\nr_0^T A r_0 = \\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} = 1 \\cdot 1 + 0 \\cdot 0 + 0 \\cdot 0 = 1\n$$\n这个分母不为零。分子是 $\\rho_0 = r_0^T r_0 = 1$，因此步长 $\\alpha_0$ 是良定义的，且等于 $1$。BiCGSTAB迭代可以继续进行，不会遇到导致BiCG方法中断的故障。\n\n总而言之，BiCG的中断是由于对初始影子残差 $r_0^{\\ast}$ 的特定（且有些刻意）选择，这使得影子搜索方向 $p_0^{\\ast}$与 $A p_0$ 正交。BiCGSTAB通过消除对影子残差序列的需求来避免这种特定的中断机制。其对应的分母 $r_0^T A r_0$ 仅依赖于标准残差 $r_0$ 和系统矩阵 $A$。对于一个非奇异矩阵 $A$ 和一个非零残差 $r_0$，对于一般的非对称矩阵，这个量 $r_0^T A r_0$ 并不保证非零，但在本例中它不为零，从而防止了在这一步发生中断。", "answer": "$$\\boxed{0}$$", "id": "2427438"}, {"introduction": "从理论基础转向实际应用，本练习将指导您为经典的二维泊松方程问题编写并评估不同的预条件策略。通过亲手实现并对比无预条件、简单的点雅可比（point-Jacobi）预条件以及更复杂的块雅可比（block-Jacobi）预条件的效果，您将获得关于预条件子设计如何影响收敛速度的第一手经验，并直观地看到更强预条件技术带来的实际效益。", "problem": "构建一个程序，该程序针对一系列线性系统，构建并应用一个块雅可比预条件子。这些线性系统来自于在内部尺寸为 $n \\times n$ 的方形网格上，对带有齐次 Dirichlet 边界条件的二维 Poisson 方程进行标准五点有限差分离散化。该预条件子的分块对应于连续的节点线。系统矩阵是 $N=n^2$ 的对称正定矩阵 $A \\in \\mathbb{R}^{N \\times N}$，定义为\n$$\nA = I_n \\otimes T_n + T_n \\otimes I_n,\n$$\n其中 $T_n \\in \\mathbb{R}^{n \\times n}$ 是一个三对角矩阵，其主对角线元素为 $2$，次对角线和超对角线元素均为 $-1$，$\\otimes$ 表示 Kronecker 积。未知向量按字典序行主序排列。设右端项为 $b = \\mathbf{1} \\in \\mathbb{R}^{N}$，初始猜测为 $x_0 = \\mathbf{0} \\in \\mathbb{R}^{N}$。\n\n通过取 $A$ 的块对角部分来定义块雅可比预条件子 $M \\in \\mathbb{R}^{N \\times N}$，这些块对角部分对应于：\n- 平行于 $x$ 轴的线（逐行分块），或\n- 平行于 $y$ 轴的线（逐列分块），\n使得每个分块都是一个等于 $T_n + 2 I_n$ 的三对角矩阵 $B \\in \\mathbb{R}^{n \\times n}$，并独立地应用于每一条线。同时考虑点雅可比预条件子 $M_{\\mathrm{pt}} = \\mathrm{diag}(A)$。\n\n对于下面测试套件中的每一组参数，使用共轭梯度法（为对称正定系统定义）在三种配置下求解线性系统 $A x = b$：无预处理、点雅可比预处理，以及具有指定方向的线块雅可比预处理。在所有情况下，当残差范数满足\n$$\n\\|r_k\\|_2 \\le \\varepsilon \\, \\|r_0\\|_2,\n$$\n时，迭代在最小的非负整数 $k$ 处终止，其中 $r_k = b - A x_k$，容差为 $\\varepsilon = 10^{-8}$（在欧几里得范数下度量），并将迭代次数限制在最多 $K_{\\max} = 5000$ 步。对每组参数，报告四个值：迭代次数 $k_{\\mathrm{none}}$、$k_{\\mathrm{pt}}$、$k_{\\mathrm{blk}}$，以及表示为实数的比率 $k_{\\mathrm{none}} / k_{\\mathrm{blk}}$。\n\n测试套件（每个案例是一个数对 $(n, \\mathrm{orientation})$，其中 $\\mathrm{orientation} \\in \\{\\text{row}, \\text{col}\\}$ 选择线块的方向）：\n- 案例 1: $(n, \\mathrm{orientation}) = (1, \\text{row})$。\n- 案例 2: $(n, \\mathrm{orientation}) = (8, \\text{row})$。\n- 案例 3: $(n, \\mathrm{orientation}) = (8, \\text{col})$。\n- 案例 4: $(n, \\mathrm{orientation}) = (32, \\text{row})$。\n\n您的程序应产生单行输出，其中包含用方括号括起来、以逗号分隔且不含空格的结果列表。每个测试案例的结果本身必须是形式为 $[k_{\\mathrm{none}},k_{\\mathrm{pt}},k_{\\mathrm{blk}},k_{\\mathrm{none}}/k_{\\mathrm{blk}}]$ 的列表。因此，总的输出格式为\n$$\n\\bigl[ [k_{\\mathrm{none}},k_{\\mathrm{pt}},k_{\\mathrm{blk}},k_{\\mathrm{none}}/k_{\\mathrm{blk}}], \\ldots \\bigr],\n$$\n例如，在一行上打印为 $[[a,b,c,d],[e,f,g,h],\\ldots]$，所有条目均为数值。", "solution": "该问题要求解线性方程组 $A x = b$，其中矩阵 $A \\in \\mathbb{R}^{N \\times N}$ ($N = n^2$) 来自于方形网格上二维 Poisson 方程的五点有限差分离散化。该矩阵由 Kronecker 积和给出：\n$$\nA = I_n \\otimes T_n + T_n \\otimes I_n\n$$\n此处，$I_n$ 是 $n \\times n$ 单位矩阵，$T_n$ 是 $n \\times n$ 三对角矩阵，其主对角线元素为 $2$，第一亚对角线和第一超对角线元素为 $-1$。此构造假设网格未知数采用字典序行主序排列。得到的矩阵 $A$ 是对称正定 (SPD) 的，这是选择求解器的一个关键属性。右端项是 $b = \\mathbf{1}$ （所有元素均为 1 的向量），初始猜测是 $x_0 = \\mathbf{0}$。\n\n所选的迭代求解器是共轭梯度 (CG) 法，它是求解 SPD 系统的标准且最高效的 Krylov 子空间方法。我们将实现预处理共轭梯度 (PCG) 算法，该算法求解系统 $M^{-1} A x = M^{-1} b$，其中 $M$ 是预条件子。针对初始猜测 $x_0$，算法如下：\n\n1.  初始化: $k=0$, $r_0 = b - A x_0$。\n2.  设置停止准则: $\\tau = \\varepsilon \\|r_0\\|_2$，其中 $\\varepsilon = 10^{-8}$。\n3.  预处理: 求解 $M z_0 = r_0$。\n4.  设置初始搜索方向: $p_0 = z_0$。\n5.  计算 $\\rho_0 = r_0^T z_0$。\n6.  对 $k = 0, 1, 2, \\ldots, K_{\\max}-1$ 进行迭代:\n    a. $q_k = A p_k$\n    b. $\\alpha_k = \\rho_k / (p_k^T q_k)$\n    c. $x_{k+1} = x_k + \\alpha_k p_k$\n    d. $r_{k+1} = r_k - \\alpha_k q_k$\n    e. 如果 $\\|r_{k+1}\\|_2 \\le \\tau$，则终止并报告迭代次数为 $k+1$。\n    f. 求解 $M z_{k+1} = r_{k+1}$。\n    g. $\\rho_{k+1} = r_{k+1}^T z_{k+1}$\n    h. $\\beta_k = \\rho_{k+1} / \\rho_k$\n    i. $p_{k+1} = z_{k+1} + \\beta_k p_k$\n    j. $\\rho_k \\leftarrow \\rho_{k+1}$\n\n我们将分析由 $M$ 的选择所定义的三种预处理策略。\n\n**1. 无预处理**\n此情况等效于将预条件子 $M$ 设置为单位矩阵 $M=I$。预处理步骤“求解 $M z_k = r_k$”变得非常简单：$z_k = r_k$。这恢复为标准共轭梯度算法。收敛速度取决于原始矩阵 $A$ 的条件数 $\\kappa(A)$，对于此问题，该值为 $O(n^2)$。这导致当 $n$ 较大时收敛缓慢。\n\n**2. 点雅可比预处理**\n点雅可比预条件子是矩阵 $A$ 的对角线，即 $M_{\\mathrm{pt}} = \\mathrm{diag}(A)$。矩阵 $A = I_n \\otimes T_n + T_n \\otimes I_n$ 的对角线元素是 $I_n \\otimes T_n$ 和 $T_n \\otimes I_n$ 的对角线元素之和。$I_n \\otimes T_n$ 的对角线是一个包含 $n^2$ 个元素的向量，所有元素都等于 $2$。$T_n \\otimes I_n$ 的对角线也是一个包含 $n^2$ 个元素的向量，所有元素都等于 $2$。因此，$A$ 的对角线是常数，其所有元素都为 $2+2=4$。预条件子是 $M_{\\mathrm{pt}} = 4I_N$。应用其逆 $M_{\\mathrm{pt}}^{-1}$ 是一个简单且计算成本低的操作：将向量进行标量除法，除以 $4$。\n\n**3. 线块雅可比预处理**\n此预条件子 $M_{\\mathrm{blk}}$ 是通过取 $A$ 的块对角部分来构建的，其中分块对应于网格上的节点线。\n对于行主序排列，矩阵 $A$ 是一个块三对角矩阵：\n$$\nA = \\begin{pmatrix}\nT_n+2I_n & -I_n & & \\\\\n-I_n & T_n+2I_n & -I_n & \\\\\n& \\ddots & \\ddots & \\ddots \\\\\n& & -I_n & T_n+2I_n\n\\end{pmatrix}\n$$\n对角分块，记为 $B$，是 $B = T_n + 2I_n$。该矩阵是三对角矩阵，对角线上为 $4$，非对角线上为 $-1$。它也是对称正定的 (SPD)。\n\n-   **逐行方向**：分块对应于网格的行。采用行主序时，单个网格行上的未知数在解向量中是连续索引的。因此，块雅可比预条件子是 $A$ 的块对角矩阵，$M_{\\mathrm{blk}} = \\mathrm{diag}(B, B, ..., B)$。将 $M_{\\mathrm{blk}}^{-1}$ 应用于残差向量 $r$ 需要求解 $n$ 个大小为 $n \\times n$ 的独立线性系统，即对每个分块 $i=1, \\ldots, n$ 求解 $B z_i = r_i$。由于 $B$ 是一个带状矩阵（三对角），这些系统可以被高效求解。\n\n-   **逐列方向**：分块对应于网格的列。在行主序排列的向量中，单个网格列的未知数不是连续的；它们被一个步长为 $n$ 的间隔分开。由于问题的对称性，耦合单列内未知数的 $A$ 的子矩阵也是矩阵 $B = T_n+2I_n$。应用预条件子逆的过程包括：对于 $n$ 个列中的每一列，(1) 从残差向量 $r$ 中收集相应的跨步元素，(2) 用矩阵 $B$ 求解 $n \\times n$ 系统，以及 (3) 将结果散布回解向量 $z$。\n\n对于逐列情况，预处理后的矩阵 $M_{\\mathrm{blk,col}}^{-1}A$ 与逐行情况的矩阵 $M_{\\mathrm{blk,row}}^{-1}A$ 相似。具体来说，如果 $P$ 是将行主序映射到列主序的置换矩阵，则 $M_{\\mathrm{blk,col}} = P^T M_{\\mathrm{blk,row}} P$。由于算子和域的对称性，$PAP^T = A$ 成立。因此，$M_{\\mathrm{blk,col}}^{-1}A$ 的特征值与 $M_{\\mathrm{blk,row}}^{-1}A$ 的特征值相同。由于共轭梯度法的收敛性取决于特征值分布，我们预期对于给定的 $n$，`row` 和 `col` 两种方向的迭代次数 $k_{\\mathrm{blk}}$ 是相同的。\n\n实现部分将构建矩阵 $A$ 和预条件子所需的结构。对于块雅可比预条件子，为提高效率，将使用带状线性求解器求解三对角系统。PCG 算法将针对每个测试案例的三种配置运行，以确定迭代次数 $k_{\\mathrm{none}}$、$k_{\\mathrm{pt}}$ 和 $k_{\\mathrm{blk}}$。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef create_A(n):\n    \"\"\"\n    Constructs the matrix A for the 2D Poisson problem on an n x n grid.\n    \"\"\"\n    if n == 0:\n        return np.array([[]])\n    if n == 1:\n        return np.array([[4.0]])\n        \n    diag_main = np.full(n, 2.0)\n    diag_off = np.full(n-1, -1.0)\n    T_n = np.diag(diag_main) + np.diag(diag_off, k=1) + np.diag(diag_off, k=-1)\n    \n    I_n = np.eye(n)\n    \n    A = np.kron(I_n, T_n) + np.kron(T_n, I_n)\n    return A\n\ndef apply_preconditioner_inv(r, n, precon_config):\n    \"\"\"\n    Applies the inverse of the preconditioner M to a vector r.\n    z = M_inv * r\n    precon_config is a tuple (type, orientation), e.g., ('block', 'row').\n    \"\"\"\n    precon_type, orientation = precon_config\n    \n    if precon_type == 'none':\n        return r.copy()\n    \n    if precon_type == 'point':\n        # M = diag(A), which is 4*I\n        return r / 4.0\n        \n    if precon_type == 'block':\n        N = n * n\n        if N == 0:\n            return np.array([])\n        z = np.zeros(N)\n        \n        # The block matrix B = T_n + 2*I_n is tridiagonal with\n        # 4 on the main diagonal and -1 on the off-diagonals.\n        # We use a banded solver for B*z_i = r_i.\n        # Banded matrix format for scipy.linalg.solve_banded:\n        # ab[0, :] are super-diagonal elements (u=1)\n        # ab[1, :] are main-diagonal elements\n        # ab[2, :] are sub-diagonal elements (l=1)\n        # Since u=1, first element of ab[0,:] is ignored.\n        # Since l=1, last element of ab[2,:] is ignored.\n        ab = np.zeros((3, n))\n        ab[0, 1:] = -1.0\n        ab[1, :] = 4.0\n        ab[2, :-1] = -1.0\n        \n        if orientation == 'row':\n            for i in range(n):\n                start, end = i * n, (i + 1) * n\n                r_i = r[start:end]\n                z_i = solve_banded((1, 1), ab, r_i)\n                z[start:end] = z_i\n        elif orientation == 'col':\n            for j in range(n):\n                r_j = r[j::n] # Gather elements for column j\n                z_j = solve_banded((1, 1), ab, r_j)\n                z[j::n] = z_j # Scatter back\n        return z\n        \n    raise ValueError(\"Unknown preconditioner type\")\n\ndef run_cg(n, precon_config):\n    \"\"\"\n    Runs the Preconditioned Conjugate Gradient method for a given n and preconditioner.\n    \"\"\"\n    N = n * n\n    if N == 0:\n        return 0\n        \n    A = create_A(n)\n    b = np.ones(N)\n    x = np.zeros(N)\n    \n    epsilon = 1e-8\n    max_iter = 5000\n    \n    r = b - A @ x\n    \n    norm_r0 = np.linalg.norm(r)\n    if norm_r0 == 0:\n        return 0\n    \n    threshold = epsilon * norm_r0\n    \n    z = apply_preconditioner_inv(r, n, precon_config)\n    p = z.copy()\n    rho_old = r @ z\n    \n    for k in range(max_iter):\n        Ap = A @ p\n        \n        # Handle potential breakdown for very small systems/singular cases\n        p_dot_Ap = p @ Ap\n        if p_dot_Ap <= 0:\n            # CG requires SPD matrix. Negative or zero value indicates problem.\n            # Could happen with non-SPD preconditioner, but ours are SPD.\n            # More likely due to floating point error accumulation.\n            # Stop if direction is not a descent direction.\n            return k + 1\n\n        alpha = rho_old / p_dot_Ap\n        x += alpha * p\n        r -= alpha * Ap\n        \n        if np.linalg.norm(r) <= threshold:\n            return k + 1\n            \n        z = apply_preconditioner_inv(r, n, precon_config)\n        rho_new = r @ z\n        \n        if rho_old == 0: # Should not happen if everything is correct\n            return k + 1\n\n        beta = rho_new / rho_old\n        p = z + beta * p\n        rho_old = rho_new\n        \n    return max_iter\n\ndef solve():\n    test_cases = [\n        (1, 'row'),\n        (8, 'row'),\n        (8, 'col'),\n        (32, 'row'),\n    ]\n    \n    results = []\n    for n, orientation in test_cases:\n        k_none = run_cg(n, ('none', None))\n        k_pt = run_cg(n, ('point', None))\n        k_blk = run_cg(n, ('block', orientation))\n        \n        # Handle division by zero if k_blk is 0\n        ratio = float(k_none) / k_blk if k_blk != 0 else float('inf')\n        \n        results.append(f\"[{k_none},{k_pt},{k_blk},{ratio}]\")\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2427470"}]}