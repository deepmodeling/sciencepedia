{"hands_on_practices": [{"introduction": "掌握任何算法的第一步都是亲手实现它。本练习将指导你从零开始编写托马斯算法，并特别关注计算效率，要求你使用一种“压缩存储”格式来表示三对角矩阵，这是在计算工程中处理稀疏矩阵的标准方法。通过这个实践，你不仅能理解算法的内部工作原理，还能掌握一种重要的内存优化技巧 [@problem_id:2446352]。", "problem": "您的任务是求解系数矩阵为三对角矩阵的线性系统。一个实三对角矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的定义是，其非零元素仅存在于主对角线以及与主对角线相邻的两条对角线上。您必须采用并使用一种紧凑存储格式，该格式由三个一维数组组成：\n- 一个次对角线数组 $l \\in \\mathbb{R}^{n-1}$，\n- 一个主对角线数组 $d \\in \\mathbb{R}^{n}$，\n- 一个超对角线数组 $u \\in \\mathbb{R}^{n-1}$。\n\n该紧凑存储必须按照以下索引约定来编码矩阵 $A$：\n- 对于 $i \\in \\{0,1,\\dots,n-2\\}$，$l[i]$ 存储矩阵元素 $A_{i+1,i}$，\n- 对于 $i \\in \\{0,1,\\dots,n-1\\}$，$d[i]$ 存储矩阵元素 $A_{i,i}$，\n- 对于 $i \\in \\{0,1,\\dots,n-2\\}$，$u[i]$ 存储矩阵元素 $A_{i,i+1}$。\n\n您的程序必须：\n- 为每个指定的测试用例构建紧凑存储 $(l,d,u)$，\n- 通过将三对角矩阵 $A$（由 $(l,d,u)$ 编码）与预设的精确解向量 $x^{\\star} \\in \\mathbb{R}^{n}$ 相乘，构建右端向量 $b \\in \\mathbb{R}^{n}$，\n- 对于每个测试用例，仅使用紧凑存储数组 $(l,d,u)$ 和向量 $b$，计算并返回精确解 $x^{\\star}$ 的一个数值近似解 $\\hat{x}$，不得将 $A$ 实体化为稠密矩阵，也不得使用任何库中的外部三对角求解器，\n- 对于每个测试用例，计算最大绝对误差 $e = \\max_{0 \\le i \\le n-1} | \\hat{x}_i - x^{\\star}_i |$。\n\n测试套件：\n- 用例 1（理想情况，对称严格对角占优）：\n  - 维度：$n = 5$。\n  - 表示 $A$ 的紧凑存储为：对于 $i \\in \\{0,1,2,3\\}$，$l[i] = -1$，对于 $i \\in \\{0,1,2,3,4\\}$，$d[i] = 2$，以及对于 $i \\in \\{0,1,2,3\\}$，$u[i] = -1$。\n  - 精确解：$x^{\\star} = [1, 2, 3, 4, 5]^{\\mathsf{T}}$。\n  - 右端项：$b = A x^{\\star}$。\n- 用例 2（边界情况 $n=1$）：\n  - 维度：$n = 1$。\n  - 表示 $A$ 的紧凑存储为：$d[0] = 3$（没有次对角线或超对角线元素）。\n  - 精确解：$x^{\\star} = [7]^{\\mathsf{T}}$。\n  - 右端项：$b = A x^{\\star}$。\n- 用例 3（非对角线元素为零，严格对角占优）：\n  - 维度：$n = 6$。\n  - 表示 $A$ 的紧凑存储为：对于 $i \\in \\{0,1,2,3,4,5\\}$，$d[i] = 4$，$u = [1, 0, 1, 0, 1]^{\\mathsf{T}}$，以及 $l = [0, 1, 0, 1, 0]^{\\mathsf{T}}$。\n  - 精确解：$x^{\\star} = [1, -1, 2, -2, 3, -3]^{\\mathsf{T}}$。\n  - 右端项：$b = A x^{\\star}$。\n- 用例 4（非对称，严格对角占优）：\n  - 维度：$n = 5$。\n  - 表示 $A$ 的紧凑存储为：$d = [5, 5, 5, 5, 5]^{\\mathsf{T}}$，$u = [2, -1, 0.5, -2.5]^{\\mathsf{T}}$，以及 $l = [-1, 0.5, -0.5, 1.5]^{\\mathsf{T}}$。\n  - 精确解：$x^{\\star} = [1, 2, -1, 0.5, -2]^{\\mathsf{T}}$。\n  - 右端项：$b = A x^{\\star}$。\n\n您的程序必须生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，列表中的每个条目是相应测试用例的最大绝对误差 $e$。例如，输出格式必须严格遵循 $[e_1,e_2,e_3,e_4]$ 的形式，不含空格。所有值都是无单位的实数。本问题不涉及角度或百分比。", "solution": "托马斯算法，也称为三对角矩阵算法（TDMA），是高斯消元法的一种高效形式，专门用于求解由三对角矩阵 $A$ 定义的线性方程组 $A\\hat{x} = b$。矩阵 $A$ 由紧凑存储格式的三个一维数组表示：次对角线数组 $l$、主对角线数组 $d$ 和超对角线数组 $u$。所有数组和向量均采用从零开始的索引。\n\n该方程组可以明确地写为：\n$$d_0 \\hat{x}_0 + u_0 \\hat{x}_1 = b_0 \\quad (\\text{当 } i=0 \\text{ 时})$$\n$$l_{i-1} \\hat{x}_{i-1} + d_i \\hat{x}_i + u_i \\hat{x}_{i+1} = b_i \\quad (\\text{对于 } i=1, 2, \\ldots, n-2)$$\n$$l_{n-2} \\hat{x}_{n-2} + d_{n-1} \\hat{x}_{n-1} = b_{n-1} \\quad (\\text{当 } i=n-1 \\text{ 时})$$\n\n托马斯算法包括两个阶段：前向消元和回代。\n\n**1. 前向消元**\n此阶段的目标是将系统转换为一个上双对角形式。我们通过修改上对角线系数和右端向量来实现这一点，生成新的系数数组 $u'$ 和 $b'$。\n\n对于第一行（$i=0$），我们对主对角线元素进行归一化（假设 $d_0 \\neq 0$）：\n$$u'_0 = \\frac{u_0}{d_0}$$\n$$b'_0 = \\frac{b_0}{d_0}$$\n\n接着，对于后续行 $i = 1, 2, \\ldots, n-1$，我们利用上一行已修改的方程来消去当前行的次对角线元素。这产生了以下递推关系：\n- 对于 $i=1, 2, \\ldots, n-2$：\n$$m_i = d_i - l_{i-1} u'_{i-1}$$\n$$u'_i = \\frac{u_i}{m_i}$$\n$$b'_i = \\frac{b_i - l_{i-1} b'_{i-1}}{m_i}$$\n为了使算法在没有主元选择的情况下保持数值稳定，所有中间分母 $m_i$ 都必须非零。对于测试套件中提供的严格对角占优矩阵，此条件是保证成立的。\n\n- 对于最后一行, $i=n-1$：\n$$m_{n-1} = d_{n-1} - l_{n-2} u'_{n-2}$$\n$$b'_{n-1} = \\frac{b_{n-1} - l_{n-2} b'_{n-2}}{m_{n-1}}$$\n注意，由于没有 $u_{n-1}$ 项，因此不需要计算 $u'_{n-1}$。\n\n**2. 回代**\n在前向消元过程之后，原始系统 $A\\hat{x}=b$ 被转换为等价的上双对角系统：\n$$\\hat{x}_i + u'_i \\hat{x}_{i+1} = b'_i \\quad (\\text{对于 } i=0, 1, \\ldots, n-2)$$\n$$\\hat{x}_{n-1} = b'_{n-1}$$\n该系统从最后一个方程开始，通过向后代入来求解。解通过以下递推关系找到：\n$$\\hat{x}_{n-1} = b'_{n-1}$$\n$$\\hat{x}_i = b'_i - u'_i \\hat{x}_{i+1} \\quad (\\text{对于 } i = n-2, n-3, \\ldots, 0)$$\n\n每个测试用例的总体流程如下：\n首先，使用提供的紧凑存储数组 $(l,d,u)$ 和精确解向量 $x^{\\star}$，通过计算矩阵向量乘积 $b = A x^{\\star}$ 来构建右端向量 $b$。\n其次，将所描述的托马斯算法应用于系统 $A\\hat{x}=b$，以获得数值解 $\\hat{x}$。\n最后，计算最大绝对误差 $e = \\max_{0 \\le i \\le n-1} | \\hat{x}_i - x^{\\star}_i |$。由于计算是使用浮点算术执行的，此误差可作为衡量实现方案数值精度的指标。对于给定的具有稳定矩阵的测试用例，该误差预计将非常接近于零，处于机器精度（machine epsilon）的量级。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It constructs tridiagonal systems, solves them using a custom \n    Thomas algorithm implementation, and computes the maximum absolute error.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Happy path, symmetric strictly diagonally dominant\n        {\n            \"n\": 5,\n            \"l\": np.array([-1.0, -1.0, -1.0, -1.0]),\n            \"d\": np.array([2.0, 2.0, 2.0, 2.0, 2.0]),\n            \"u\": np.array([-1.0, -1.0, -1.0, -1.0]),\n            \"x_star\": np.array([1.0, 2.0, 3.0, 4.0, 5.0]),\n        },\n        # Case 2: Boundary case n=1\n        {\n            \"n\": 1,\n            \"l\": np.array([]),\n            \"d\": np.array([3.0]),\n            \"u\": np.array([]),\n            \"x_star\": np.array([7.0]),\n        },\n        # Case 3: Zeros on off-diagonals, strictly diagonally dominant\n        {\n            \"n\": 6,\n            \"l\": np.array([0.0, 1.0, 0.0, 1.0, 0.0]),\n            \"d\": np.array([4.0] * 6),\n            \"u\": np.array([1.0, 0.0, 1.0, 0.0, 1.0]),\n            \"x_star\": np.array([1.0, -1.0, 2.0, -2.0, 3.0, -3.0]),\n        },\n        # Case 4: Nonsymmetric, strictly diagonally dominant\n        {\n            \"n\": 5,\n            \"l\": np.array([-1.0, 0.5, -0.5, 1.5]),\n            \"d\": np.array([5.0] * 5),\n            \"u\": np.array([2.0, -1.0, 0.5, -2.5]),\n            \"x_star\": np.array([1.0, 2.0, -1.0, 0.5, -2.0]),\n        },\n    ]\n\n    def construct_b(n, l, d, u, x_star):\n        \"\"\"\n        Constructs the right-hand side vector b = A * x_star using packed storage.\n        \"\"\"\n        if n == 0:\n            return np.array([])\n        \n        b = np.zeros(n, dtype=float)\n        \n        if n == 1:\n            b[0] = d[0] * x_star[0]\n            return b\n\n        # First row\n        b[0] = d[0] * x_star[0] + u[0] * x_star[1]\n        \n        # Middle rows\n        for i in range(1, n - 1):\n            b[i] = l[i-1] * x_star[i-1] + d[i] * x_star[i] + u[i] * x_star[i+1]\n            \n        # Last row\n        b[n-1] = l[n-2] * x_star[n-2] + d[n-1] * x_star[n-1]\n        \n        return b\n\n    def thomas_solver(n, l, d, u, b):\n        \"\"\"\n        Solves a tridiagonal system Ax=b using the Thomas algorithm (TDMA).\n        \n        Args:\n            n (int): The dimension of the system.\n            l (np.ndarray): The subdiagonal (n-1 elements).\n            d (np.ndarray): The main diagonal (n elements).\n            u (np.ndarray): The superdiagonal (n-1 elements).\n            b (np.ndarray): The right-hand side vector (n elements).\n        \n        Returns:\n            np.ndarray: The solution vector x_hat.\n        \"\"\"\n        # Handle the trivial case n=1\n        if n == 1:\n            return np.array([b[0] / d[0]])\n            \n        # Allocate space for modified coefficients\n        u_prime = np.zeros(n - 1, dtype=float)\n        b_prime = np.zeros(n, dtype=float)\n        \n        # Forward elimination sweep\n        # i = 0\n        u_prime[0] = u[0] / d[0]\n        b_prime[0] = b[0] / d[0]\n        \n        # i = 1 to n-2\n        for i in range(1, n - 1):\n            denominator = d[i] - l[i-1] * u_prime[i-1]\n            u_prime[i] = u[i] / denominator\n            b_prime[i] = (b[i] - l[i-1] * b_prime[i-1]) / denominator\n        \n        # i = n-1 (last element of b_prime)\n        denominator_last = d[n-1] - l[n-2] * u_prime[n-2]\n        b_prime[n-1] = (b[n-1] - l[n-2] * b_prime[n-2]) / denominator_last\n\n        # Backward substitution sweep\n        x_hat = np.zeros(n, dtype=float)\n        x_hat[n-1] = b_prime[n-1]\n        for i in range(n - 2, -1, -1):\n            x_hat[i] = b_prime[i] - u_prime[i] * x_hat[i+1]\n            \n        return x_hat\n\n    results = []\n    for case in test_cases:\n        n, l, d, u, x_star = case[\"n\"], case[\"l\"], case[\"d\"], case[\"u\"], case[\"x_star\"]\n        \n        # Construct the right-hand side vector b = A * x_star\n        b = construct_b(n, l, d, u, x_star)\n        \n        # Solve the system A * x_hat = b to find the numerical solution\n        x_hat = thomas_solver(n, l, d, u, b)\n        \n        # Compute the maximum absolute error\n        error = np.max(np.abs(x_hat - x_star))\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2446352"}, {"introduction": "在理想情况下运行的算法在面对真实世界的复杂性时可能会遇到挑战。数值算法的稳定性至关重要，一个关键环节是在高斯消去法中检查“主元”。这个练习将让你在托马斯算法中加入一个关键的稳定性检查，通过设置一个容差 $\\tau$ 来识别并处理因主元过小或为零而导致的数值不稳定性或奇异性问题 [@problem_id:2446297]。", "problem": "给定一系列形式为 $A \\mathbf{x} = \\mathbf{d}$ 的实三对角线性方程组，其中 $A \\in \\mathbb{R}^{n \\times n}$ 的主对角线元素为 $\\{b_i\\}_{i=0}^{n-1}$，下对角线元素为 $\\{a_i\\}_{i=0}^{n-2}$，上对角线元素为 $\\{c_i\\}_{i=0}^{n-2}$，使得\n$$\nA =\n\\begin{pmatrix}\nb_0 & c_0 & 0 & \\cdots & 0 \\\\\na_0 & b_1 & c_1 & \\ddots & \\vdots \\\\\n0 & a_1 & b_2 & \\ddots & 0 \\\\\n\\vdots & \\ddots & \\ddots & \\ddots & c_{n-2} \\\\\n0 & \\cdots & 0 & a_{n-2} & b_{n-1}\n\\end{pmatrix}, \\quad\n\\mathbf{x} =\n\\begin{pmatrix}\nx_0 \\\\ x_1 \\\\ \\vdots \\\\ x_{n-2} \\\\ x_{n-1}\n\\end{pmatrix}, \\quad\n\\mathbf{d} =\n\\begin{pmatrix}\nd_0 \\\\ d_1 \\\\ \\vdots \\\\ d_{n-2} \\\\ d_{n-1}\n\\end{pmatrix}.\n$$\n对于每个方程组，还会给定一个非负容差 $\\tau \\in \\mathbb{R}$，您必须应用以下规则：通过如下方式定义序列 $\\{p_i\\}$、$\\{c'_i\\}$ 和 $\\{d'_i\\}$\n$$\np_0 = b_0,\n$$\n对于 $i = 0$ 设置\n$$\nc'_0 = \\begin{cases}\n\\frac{c_0}{p_0}, & \\text{如果 } n \\ge 2, \\\\\n\\text{未定义}, & \\text{如果 } n = 1,\n\\end{cases}\n\\quad\nd'_0 = \\frac{d_0}{p_0}.\n$$\n对于 $i = 1, 2, \\ldots, n-1$，设置\n$$\np_i = b_i - a_{i-1} \\, c'_{i-1}.\n$$\n在任何索引 $i \\in \\{0,1,\\ldots,n-1\\}$ 处，如果 $|p_i| \\le \\tau$，则计算因奇异性或近奇异性而被视为失败，您必须声明该方程组计算失败。如果对所有 $i$ 都有 $|p_i| > \\tau$，则对于 $i = 1, 2, \\ldots, n-2$ 定义\n$$\nc'_i = \\frac{c_i}{p_i},\n$$\n并对于 $i = 1, 2, \\ldots, n-1$ 定义\n$$\nd'_i = \\frac{d_i - a_{i-1} d'_{i-1}}{p_i}.\n$$\n如果没有声明失败，则唯一解 $\\mathbf{x}$ 由以下回代关系式定义\n$$\nx_{n-1} = d'_{n-1}, \\quad\nx_i = d'_i - c'_i x_{i+1} \\quad \\text{对于 } i = n-2, n-3, \\ldots, 0.\n$$\n\n请实现一个程序，对下方的每个测试用例，遵循上述规则，并在计算成功时输出解向量 $\\mathbf{x}$（作为实数列表），或在因存在索引 $i$ 满足 $|p_i| \\le \\tau$ 而声明失败时输出布尔值 $False$。\n\n测试套件。每个测试用例由元组 $(\\{a_i\\}_{i=0}^{n-2}, \\{b_i\\}_{i=0}^{n-1}, \\{c_i\\}_{i=0}^{n-2}, \\{d_i\\}_{i=0}^{n-1}, \\tau)$ 指定，为便于实现，写成零基数组形式，即列表\n$$\na = [a_0, \\ldots, a_{n-2}], \\quad b = [b_0, \\ldots, b_{n-1}], \\quad c = [c_0, \\ldots, c_{n-2}], \\quad d = [d_0, \\ldots, d_{n-1}],\n$$\n$\\tau$ 单独给出。\n\n请提供以下六个测试用例的结果：\n- 情况 1（常规，严格对角占优）：$a = [ -1, -1, -1, -1 ]$, $b = [ 2, 2, 2, 2, 2 ]$, $c = [ -1, -1, -1, -1 ]$, $d = [ 1, 1, 1, 1, 1 ]$, $\\tau = 10^{-12}$。\n- 情况 2（边界情况，规模 $n = 1$，因第一个主元过小而失败）：$a = [\\,]$ (空列表), $b = [ 10^{-12} ]$, $c = [\\,]$, $d = [ 1 ]$, $\\tau = 10^{-10}$。\n- 情况 3（计算中出现精确的零主元）： $a = [ 1, 1 ]$, $b = [ 1, 1, 1 ]$, $c = [ 1, 1 ]$, $d = [ 1, 2, 3 ]$, $\\tau = 10^{-12}$。\n- 情况 4（对角矩阵）：$a = [ 0, 0, 0 ]$, $b = [ 3, 4, 5, 6 ]$, $c = [ 0, 0, 0 ]$, $d = [ 3, 8, 10, 12 ]$, $\\tau = 10^{-12}$。\n- 情况 5（近奇异，但在严格容差下可接受）：$a = [ 1 ]$, $b = [ 1, 1 + 10^{-9} ]$, $c = [ 1 ]$, $d = [ 1, 1 ]$, $\\tau = 10^{-12}$。\n- 情况 6（与情况5相同，但在较宽松的容差下失败）：$a = [ 1 ]$, $b = [ 1, 1 + 10^{-9} ]$, $c = [ 1 ]$, $d = [ 1, 1 ]$, $\\tau = 10^{-8}$。\n\n最终输出格式。您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。对于每个测试用例，如果规则声明失败，则输出布尔值 $False$；否则输出解向量（作为实数列表）。打印的行中不得有任何空格。例如，一个汇总了三个假设性用例结果的输出可能如下所示\n$$\n[\\,[0.5,1.0],False,[1.0]\\,].\n$$\n您的程序必须恰好输出这样一行，其中按顺序包含六个测试用例的结果，格式为 $[r_1,r_2,r_3,r_4,r_5,r_6]$，且不含任何额外文本。", "solution": "问题中描述的算法是托马斯算法，这是一种在数值线性代数中用于求解三对角系统的、成熟且计算高效的方法，本质上是高斯消元法的一种特例。该算法通过引入一个容差 $\\tau$ 来检查主元（pivots）的幅度，从而确保数值稳定性。\n\n该算法的原理基于将三对角矩阵 $A$ 分解为下双对角矩阵 $L$ 和单位上双对角矩阵 $U$ 的乘积，即 $A=LU$ 分解。其中：\n$$\nL =\n\\begin{pmatrix}\np_0 & 0 & 0 & \\cdots & 0 \\\\\na_0 & p_1 & 0 & \\ddots & \\vdots \\\\\n0 & a_1 & p_2 & \\ddots & 0 \\\\\n\\vdots & \\ddots & \\ddots & \\ddots & 0 \\\\\n0 & \\cdots & 0 & a_{n-2} & p_{n-1}\n\\end{pmatrix}, \\quad\nU =\n\\begin{pmatrix}\n1 & c'_0 & 0 & \\cdots & 0 \\\\\n0 & 1 & c'_1 & \\ddots & \\vdots \\\\\n0 & 0 & 1 & \\ddots & 0 \\\\\n\\vdots & \\ddots & \\ddots & \\ddots & c'_{n-2} \\\\\n0 & \\cdots & 0 & 0 & 1\n\\end{pmatrix}\n$$\n通过将 $A$ 的元素与乘积 $LU$ 的元素相等，我们可以推导出未知元素 $p_i$ 和 $c'_i$ 的递推关系。\n$A$ 的主对角线给出 $b_i = (LU)_{ii}$:\n- 对于 $i=0$: $b_0 = p_0$.\n- 对于 $i=1, \\ldots, n-1$: $b_i = a_{i-1} c'_{i-1} + p_i$，整理后得到 $p_i = b_i - a_{i-1} c'_{i-1}$。\n\n$A$ 的上对角线给出 $c_i = (LU)_{i,i+1}$:\n- 对于 $i=0, \\ldots, n-2$: $c_i = p_i c'_i$，整理后得到 $c'_i = c_i / p_i$。\n\n这些关系正是问题中规定的用于计算 $\\{p_i\\}$ 和 $\\{c'_i\\}$ 的前向消元步骤。元素 $\\{p_i\\}$ 是高斯消元过程中的主元。对于一个小的容差 $\\tau \\ge 0$，条件 $|p_i| \\le \\tau$ 是一个关键的数值稳定性检查。如果主元 $p_i$ 为零，矩阵 $A$ 是奇异的，算法失败。如果 $|p_i|$ 非常小，矩阵是病态的（接近奇异），除以 $p_i$ 会引入大的浮点误差，从而破坏解的稳定性。容差 $\\tau$ 提供了一个在这些情况下声明失败的实用阈值。\n\n一旦找到 $A=LU$ 分解，原始系统 $A\\mathbf{x} = \\mathbf{d}$ 就变为 $LU\\mathbf{x} = \\mathbf{d}$。这分两个阶段求解：\n1.  **前向替换：** 令 $\\mathbf{y} = U\\mathbf{x}$。求解下三角系统 $L\\mathbf{y} = \\mathbf{d}$。这得到：\n    -   $p_0 y_0 = d_0 \\implies y_0 = d_0/p_0$。\n    -   $a_{i-1} y_{i-1} + p_i y_i = d_i \\implies y_i = (d_i - a_{i-1} y_{i-1})/p_i$ for $i=1, \\ldots, n-1$。\n    通过观察这个递推的结构，我们发现向量 $\\mathbf{y}$ 与问题中定义的序列 $\\mathbf{d}' = \\{d'_i\\}_{i=0}^{n-1}$ 是相同的。因此，前向消元阶段同时计算 LU 分解并求解 $L\\mathbf{y} = \\mathbf{d}$。\n\n2.  **回代：** 求解单位上三角系统 $U\\mathbf{x} = \\mathbf{y}$（现在是 $U\\mathbf{x} = \\mathbf{d}'$）。这得到：\n    -   $x_{n-1} = y_{n-1} = d'_{n-1}$。\n    -   $x_i + c'_i x_{i+1} = y_i = d'_i \\implies x_i = d'_i - c'_i x_{i+1}$ for $i=n-2, \\ldots, 0$。\n    这与问题陈述中定义的回代阶段完全相同。\n\n总之，所提供的算法是托马斯算法的一种数值稳健的实现，其原理植根于三对角系统的 LU 分解。其逻辑是合理的，实现后将按规定产生正确的解或失败状态。", "answer": "```python\nimport numpy as np\n\ndef solve_tridiagonal(a_vec, b_vec, c_vec, d_vec, tau):\n    \"\"\"\n    Solves a tridiagonal linear system Ax=d using the Thomas algorithm.\n\n    Args:\n        a_vec (list): The subdiagonal entries [a_0, ..., a_{n-2}].\n        b_vec (list): The main diagonal entries [b_0, ..., b_{n-1}].\n        c_vec (list): The superdiagonal entries [c_0, ..., c_{n-2}].\n        d_vec (list): The right-hand side vector [d_0, ..., d_{n-1}].\n        tau (float): The non-negative tolerance for pivot checking.\n\n    Returns:\n        list or bool: The solution vector x as a list of floats, or False if\n                      the computation fails due to a small pivot.\n    \"\"\"\n    n = len(b_vec)\n    if n == 0:\n        return []\n\n    # Allocate memory for modified coefficients\n    c_prime = [0.0] * (n - 1)\n    d_prime = [0.0] * n\n\n    # --- Forward Elimination Phase ---\n\n    # Step for i = 0\n    p0 = b_vec[0]\n    if abs(p0) <= tau:\n        return False\n    \n    if n > 1:\n        c_prime[0] = c_vec[0] / p0\n    d_prime[0] = d_vec[0] / p0\n\n    # Loop for i = 1 to n-1\n    for i in range(1, n):\n        pi = b_vec[i] - a_vec[i-1] * c_prime[i-1]\n        if abs(pi) <= tau:\n            return False\n\n        if i < n - 1:\n            c_prime[i] = c_vec[i] / pi\n        \n        d_prime[i] = (d_vec[i] - a_vec[i-1] * d_prime[i-1]) / pi\n\n    # --- Backward Substitution Phase ---\n    x = [0.0] * n\n    x[n - 1] = d_prime[n - 1]\n    \n    # Loop for i = n-2 down to 0\n    for i in range(n - 2, -1, -1):\n        x[i] = d_prime[i] - c_prime[i] * x[i + 1]\n\n    return x\n\n\ndef solve():\n    \"\"\"\n    Runs the provided test suite and prints the formatted results.\n    \"\"\"\n    test_cases = [\n        # Case 1: regular, strictly diagonally dominant\n        {'a': [-1., -1., -1., -1.], 'b': [2., 2., 2., 2., 2.], 'c': [-1., -1., -1., -1.], 'd': [1., 1., 1., 1., 1.], 'tau': 1e-12},\n        # Case 2: boundary size n=1, failure due to tiny first pivot\n        {'a': [], 'b': [1e-12], 'c': [], 'd': [1.], 'tau': 1e-10},\n        # Case 3: mid-computation exact zero pivot\n        {'a': [1., 1.], 'b': [1., 1., 1.], 'c': [1., 1.], 'd': [1., 2., 3.], 'tau': 1e-12},\n        # Case 4: diagonal matrix\n        {'a': [0., 0., 0.], 'b': [3., 4., 5., 6.], 'c': [0., 0., 0.], 'd': [3., 8., 10., 12.], 'tau': 1e-12},\n        # Case 5: near-singular but acceptable under strict tolerance\n        {'a': [1.], 'b': [1., 1. + 1e-9], 'c': [1.], 'd': [1., 1.], 'tau': 1e-12},\n        # Case 6: same as Case 5 but failure under looser tolerance\n        {'a': [1.], 'b': [1., 1. + 1e-9], 'c': [1.], 'd': [1., 1.], 'tau': 1e-8},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = solve_tridiagonal(case['a'], case['b'], case['c'], case['d'], case['tau'])\n        all_results.append(result)\n\n    # Format the results into a single string with no spaces, as required.\n    string_results = []\n    for res in all_results:\n        if res is False:\n            string_results.append(\"False\")\n        else: # It is a list of numbers\n            list_as_string = \"[\" + \",\".join(map(str, res)) + \"]\"\n            string_results.append(list_as_string)\n            \n    final_output = \"[\" + \",\".join(string_results) + \"]\"\n    print(final_output)\n\nsolve()\n```", "id": "2446297"}, {"introduction": "掌握了核心算法和其稳健的实现后，我们可以探索其更深层次的应用。本练习挑战你运用托马斯算法求解器来完成一个看似不相关但极为高效的任务：计算一个矩阵逆的特定列。通过利用矩阵逆的定义 $A A^{-1} = I$，你将学会如何将这个问题巧妙地转化为一个线性系统求解问题，从而避免计算整个逆矩阵的高昂成本 [@problem_id:2446301]。", "problem": "考虑一个非奇异三对角矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其下对角线元素为 $a \\in \\mathbb{R}^{n-1}$，主对角线元素为 $b \\in \\mathbb{R}^{n}$，上对角线元素为 $c \\in \\mathbb{R}^{n-1}$。要求您设计一种方法，用于计算逆矩阵 $A^{-1}$ 的某一列，即对于给定的列索引 $j$，计算 $A^{-1}_{:,j}$，而无需计算完整的逆矩阵。托马斯算法是用于三对角系统的一种特殊形式的高斯消元法，其运行时间为线性时间。\n\n从逆矩阵的基本定义出发，第 $j$ 列 $A^{-1}_{:,j}$ 是满足 $A x = e_j$ 的唯一向量 $x \\in \\mathbb{R}^{n}$，其中 $e_j$ 是第 $j$ 个标准基向量。您的任务是实现一个程序，在给定 $(a,b,c)$ 和一个从零开始的列索引 $j \\in \\{0,1,\\dots,n-1\\}$ 的情况下，构建 $e_j$ 并使用基于托马斯算法的前向消元和回代法求解三对角线性系统 $A x = e_j$。这将得到作为 $x$ 的 $A^{-1}_{:,j}$。您绝不能构建完整的逆矩阵 $A^{-1}$。\n\n您的程序必须：\n- 实现一个求解器，用于求解 $A x = d$，其中 $A$ 是三对角矩阵，其下对角线为 $a$，主对角线为 $b$，上对角线为 $c$，右端项为 $d$。求解器需使用托马斯算法的数值稳定版本，通过要求所有主元非零来避免除以零的错误。\n- 对于每个指定的测试用例，设置 $d = e_j$ 以获得所需的列 $A^{-1}_{:,j}$。\n- 将所得向量的每个分量四舍五入到 $6$ 位小数，并以小数点后恰好有 $6$ 位数字的格式进行打印。\n\n使用以下测试套件，每个用例指定为 $(a,b,c,j)$，其中 $j$ 为从零开始的索引：\n- 测试用例 $1$ (通用，对角占优): \n  - $n=5$\n  - $a = [-1,-1,-1,-1]$\n  - $b = [4,4,4,4,4]$\n  - $c = [-1,-1,-1,-1]$\n  - $j = 2$\n- 测试用例 $2$ (对称正定，边界列): \n  - $n=6$\n  - $a = [-1,-1,-1,-1,-1]$\n  - $b = [2,2,2,2,2,2]$\n  - $c = [-1,-1,-1,-1,-1]$\n  - $j = 0$\n- 测试用例 $3$ (可变系数，最后一列): \n  - $n=6$\n  - $a = [0.5,-0.3,0.7,-0.2,1.1]$\n  - $b = [3.0,2.5,2.8,3.2,2.9,3.1]$\n  - $c = [-0.4,0.6,-0.5,0.9,-0.7]$\n  - $j = 5$\n- 测试用例 $4$ (最小维度): \n  - $n=1$\n  - $a = []$\n  - $b = [5.0]$\n  - $c = []$\n  - $j = 0$\n\n最终输出格式要求：\n- 您的程序必须生成单行输出，其中按顺序包含所有测试用例的结果，聚合为列表的列表形式，不带任何空格，并且每个浮点数打印时小数点后恰好有 $6$ 位数字。例如，格式必须类似于 $[\\,[x\\_1,x\\_2,\\dots],[y\\_1,y\\_2,\\dots],\\dots\\,]$，不含空格，如 $[[0.125000,0.000000],[\\dots],\\dots]$。\n\n不涉及物理单位。不使用角度。所有数值答案均为实数。每个测试用例的答案必须是一个浮点数列表，其中每个浮点数均四舍五入到 $6$ 位小数，最终的程序输出必须是指定格式的单行字符串。", "solution": "定义非奇异矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的逆的基本关系是 $A A^{-1} = I_n$，其中 $I_n$ 是 $n \\times n$ 的单位矩阵。设 $x^{(j)}$ 表示 $A^{-1}$ 的第 $j$ 列， $e_j$ 表示 $I_n$ 的第 $j$ 列（即在索引 $j$ 处为 $1$、其余位置为零的标准基向量）。矩阵与向量之积 $A x^{(j)}$ 得到乘积 $A A^{-1}$ 的第 $j$ 列。因此，计算逆矩阵的第 $j$ 列等价于求解以下线性方程组：\n$$\nA x^{(j)} = e_j\n$$\n问题指明矩阵 $A$ 是三对角的。此类系统可使用托马斯算法（也称为三对角矩阵算法，即 TDMA）高效求解，该算法是高斯消元法的一种简化形式，计算复杂度为 $O(n)$。\n\n该算法分两个阶段进行：前向消元过程和回代过程。设三对角矩阵 $A$ 由其下对角线 $a \\in \\mathbb{R}^{n-1}$、主对角线 $b \\in \\mathbb{R}^{n}$ 和上对角线 $c \\in \\mathbb{R}^{n-1}$ 表示。方程组 $Ax=d$ 可写为：\n$$\n\\begin{cases}\nb_0 x_0 + c_0 x_1 = d_0 & \\text{for } i=0 \\\\\na_{i-1} x_{i-1} + b_i x_i + c_i x_{i+1} = d_i & \\text{for } i=1, \\dots, n-2 \\\\\na_{n-2} x_{n-2} + b_{n-1} x_{n-1} = d_{n-1} & \\text{for } i=n-1\n\\end{cases}\n$$\n其中所有索引都是从零开始的。\n\n**1. 前向消元**\n\n此阶段的目标是消去下对角线元素，将系统转化为上双对角形式。我们通过修改矩阵的系数和右端项向量 $d$ 来实现这一目标。对于每一行 $i$，我们将 $x_i$ 表示为 $x_{i+1}$ 的函数。\n\n从第一个方程（$i=0$）开始，我们除以 $b_0$（由于 $A$ 是非奇异的，所以 $b_0$ 非零）：\n$$\nx_0 + \\frac{c_0}{b_0} x_1 = \\frac{d_0}{b_0}\n$$\n我们定义新的系数 $c'_0 = \\frac{c_0}{b_0}$ 和 $d'_0 = \\frac{d_0}{b_0}$。\n\n对于后续行 $i = 1, \\dots, n-1$，我们将前一行修改后的方程得到的 $x_{i-1}$ 表达式 $x_{i-1} = d'_{i-1} - c'_{i-1}x_i$ 代入当前行的方程 $a_{i-1}x_{i-1} + b_ix_i + c_ix_{i+1} = d_i$（约定 $c_{n-1}=0$）：\n$$\na_{i-1}(d'_{i-1} - c'_{i-1}x_i) + b_i x_i + c_i x_{i+1} = d_i\n$$\n对 $x_i$ 进行整理可得：\n$$\n(b_i - a_{i-1}c'_{i-1})x_i + c_i x_{i+1} = d_i - a_{i-1}d'_{i-1}\n$$\n项 $m_i = b_i - a_{i-1}c'_{i-1}$ 作为第 $i$ 行的主元。对于问题中指定的矩阵（对角占优或对称正定），这些主元保证为非零。用主元去除该行，我们得到第 $i$ 行修改后的方程：\n$$\nx_i + \\frac{c_i}{m_i} x_{i+1} = \\frac{d_i - a_{i-1}d'_{i-1}}{m_i}\n$$\n这给出了修改后系数 $c'_i$ 和 $d'_i$ 的递推关系：\n$$\nc'_i = \\frac{c_i}{b_i - a_{i-1}c'_{i-1}} \\quad \\text{for } i=1, \\dots, n-2\n$$\n$$\nd'_i = \\frac{d_i - a_{i-1}d'_{i-1}}{b_i - a_{i-1}c'_{i-1}} \\quad \\text{for } i=1, \\dots, n-1\n$$\n经过此前向过程，原始系统 $Ax=d$ 被转换为一个等价的上三角系统 $A'x=d'$，其中 $A'_{ii}=1$, $A'_{i,i+1}=c'_i$，所有其他元素均为零。\n\n**2. 回代**\n\n当系统处于上双对角形式时，我们可以从最后一个方程开始，通过向后代入来求解 $x$。\n最后一个方程就是 $x_{n-1} = d'_{n-1}$。\n对于其余的未知数，我们使用关系式 $x_i + c'_i x_{i+1} = d'_i$：\n$$\nx_i = d'_i - c'_i x_{i+1} \\quad \\text{for } i = n-2, \\dots, 0\n$$\n该过程得到解向量 $x = x^{(j)}$。\n\n对于每个测试用例，我们为指定的列索引 $j$ 构建向量 $d=e_j$，应用上述的托马斯算法，并报告所得的向量 $x^{(j)}$，其分量四舍五入到 $6$ 位小数。当 $n=1$ 的特殊情况下，问题简化为平凡方程 $b_0 x_0 = d_0$，解为 $x_0 = d_0 / b_0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Test case 1\n        {\n            \"a\": [-1, -1, -1, -1],\n            \"b\": [4, 4, 4, 4, 4],\n            \"c\": [-1, -1, -1, -1],\n            \"j\": 2\n        },\n        # Test case 2\n        {\n            \"a\": [-1, -1, -1, -1, -1],\n            \"b\": [2, 2, 2, 2, 2, 2],\n            \"c\": [-1, -1, -1, -1, -1],\n            \"j\": 0\n        },\n        # Test case 3\n        {\n            \"a\": [0.5, -0.3, 0.7, -0.2, 1.1],\n            \"b\": [3.0, 2.5, 2.8, 3.2, 2.9, 3.1],\n            \"c\": [-0.4, 0.6, -0.5, 0.9, -0.7],\n            \"j\": 5\n        },\n        # Test case 4\n        {\n            \"a\": [],\n            \"b\": [5.0],\n            \"c\": [],\n            \"j\": 0\n        }\n    ]\n\n    def thomas_solver(a, b, c, d):\n        \"\"\"\n        Solves a tridiagonal linear system Ax=d using the Thomas algorithm.\n        \n        Args:\n            a (list or np.ndarray): Subdiagonal elements (length n-1).\n            b (list or np.ndarray): Diagonal elements (length n).\n            c (list or np.ndarray): Superdiagonal elements (length n-1).\n            d (list or np.ndarray): Right-hand side vector (length n).\n            \n        Returns:\n            np.ndarray: The solution vector x.\n        \"\"\"\n        n = len(b)\n        \n        if n == 0:\n            return np.array([])\n        if n == 1:\n            if b[0] == 0:\n                raise ValueError(\"Division by zero in n=1 case.\")\n            return np.array([d[0] / b[0]])\n\n        # Create copies to avoid modifying input lists\n        ac = np.array(a, dtype=float)\n        bc = np.array(b, dtype=float)\n        cc = np.array(c, dtype=float)\n        dc = np.array(d, dtype=float)\n\n        c_prime = np.zeros(n - 1)\n        d_prime = np.zeros(n)\n\n        # Forward elimination phase\n        if bc[0] == 0:\n            raise ValueError(\"Pivot is zero. Thomas algorithm requires non-zero pivots.\")\n        c_prime[0] = cc[0] / bc[0]\n        d_prime[0] = dc[0] / bc[0]\n\n        for i in range(1, n):\n            denom = bc[i] - ac[i-1] * c_prime[i-1]\n            if denom == 0:\n                raise ValueError(\"Pivot is zero. Thomas algorithm requires non-zero pivots.\")\n            \n            if i < n - 1:\n                c_prime[i] = cc[i] / denom\n            \n            d_prime[i] = (dc[i] - ac[i-1] * d_prime[i-1]) / denom\n\n        # Backward substitution phase\n        x = np.zeros(n)\n        x[n-1] = d_prime[n-1]\n        for i in range(n - 2, -1, -1):\n            x[i] = d_prime[i] - c_prime[i] * x[i+1]\n            \n        return x\n\n    all_results = []\n    for case in test_cases:\n        a, b, c, j = case[\"a\"], case[\"b\"], case[\"c\"], case[\"j\"]\n        n = len(b)\n        \n        # Construct the j-th standard basis vector e_j\n        d = np.zeros(n)\n        d[j] = 1.0\n        \n        # Solve Ax = e_j to get the j-th column of A^-1\n        x = thomas_solver(a, b, c, d)\n        \n        # The problem requires rounding to 6 decimal places.\n        # The string formatting `{:.6f}` handles this rounding.\n        all_results.append(x)\n\n    # Format the final output string as specified\n    result_strings = []\n    for res in all_results:\n        # Format each number to have exactly 6 decimal places.\n        formatted_numbers = [f\"{val:.6f}\" for val in res]\n        result_strings.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2446301"}]}