{"hands_on_practices": [{"introduction": "理论学习的最佳伙伴是动手实践。第一个练习将带领你从头到尾手动求解一个线性方程组 [@problem_id:23098]。这个基础练习旨在巩固你对高斯消元法和回代法的核心步骤的理解，确保你熟练掌握将增广矩阵化为行阶梯形并求解未知数的基本功。", "problem": "考虑下列关于变量 $x$、$y$、$z$ 的线性方程组，已知该方程组有唯一解：\n\n$$\n\\begin{cases}\n0.5x + 0.5y + 0.5z = 3 \\\\\n0.4x - 0.2y + 0.6z = 2.2 \\\\\n1.5x + 4.5y - 3z = 3\n\\end{cases}\n$$\n\n使用高斯消元法和回代法，求此方程组的唯一解 $(x, y, z)$。然后，计算线性组合 $x - 2y + z$ 的值。", "solution": "我们首先通过将每个方程乘以一个常数来清除小数，以简化方程组。\n- 方程1乘以2：$x + y + z = 6$\n- 方程2乘以5：$2x - y + 3z = 11$\n- 方程3乘以2：$3x + 9y - 6z = 6$\n\n现在，我们写出增广矩阵并执行高斯消元法。\n$$\n\\left[\n\\begin{array}{ccc|c}\n1 & 1 & 1 & 6 \\\\\n2 & -1 & 3 & 11 \\\\\n3 & 9 & -6 & 6\n\\end{array}\n\\right]\n$$\n\n**第一步：前向消元**\n\n目标是将矩阵化为行阶梯形。\n1.  用第一行来消去第二行和第三行的第一个元素。\n    -   将第一行乘以2，从第二行减去 ($R_2 \\to R_2 - 2R_1$)：\n    $$\n    \\left[\n    \\begin{array}{ccc|c}\n    1 & 1 & 1 & 6 \\\\\n    0 & -3 & 1 & -1 \\\\\n    3 & 9 & -6 & 6\n    \\end{array}\n    \\right]\n    $$\n    -   将第一行乘以3，从第三行减去 ($R_3 \\to R_3 - 3R_1$)：\n    $$\n    \\left[\n    \\begin{array}{ccc|c}\n    1 & 1 & 1 & 6 \\\\\n    0 & -3 & 1 & -1 \\\\\n    0 & 6 & -9 & -12\n    \\end{array}\n    \\right]\n    $$\n2.  用第二行来消去第三行的第二个元素。\n    -   将第二行乘以2，加到第三行上 ($R_3 \\to R_3 + 2R_2$)：\n    $$\n    \\left[\n    \\begin{array}{ccc|c}\n    1 & 1 & 1 & 6 \\\\\n    0 & -3 & 1 & -1 \\\\\n    0 & 0 & -7 & -14\n    \\end{array}\n    \\right]\n    $$\n前向消元完成。矩阵现在是上三角形式。\n\n**第二步：回代**\n\n我们从最后一行开始，向上求解变量。\n1.  从第三行：\n    $-7z = -14 \\implies z = 2$\n2.  将 $z=2$ 代入第二行：\n    $-3y + z = -1 \\implies -3y + 2 = -1 \\implies -3y = -3 \\implies y = 1$\n3.  将 $y=1$ 和 $z=2$ 代入第一行：\n    $x + y + z = 6 \\implies x + 1 + 2 = 6 \\implies x + 3 = 6 \\implies x = 3$\n\n方程组的解是 $(x, y, z) = (3, 1, 2)$。\n\n**最后一步：计算表达式**\n\n计算 $x - 2y + z$ 的值：\n$3 - 2(1) + 2 = 3 - 2 + 2 = 3$。", "answer": "$$\\boxed{3}$$", "id": "23098"}, {"introduction": "高斯消元法的真正威力在于其矩阵形式——$PA=LU$ 分解。这个练习将挑战你跳出求解 $Ax=b$ 的固定流程，利用已有的 $L$、$U$ 和 $P$ 矩阵高效地解决一个新问题：求解转置系统 $A^Tx=b$ [@problem_id:2396194]。通过这个练习，你将学会如何将 LU 分解视为一个灵活的计算工具，以巧妙的代数操作实现算法上的优化。", "problem": "设 $A \\in \\mathbb{R}^{3 \\times 3}$。给定带行主元选择的下-上 (LU) 分解 $P A = L U$，其中 $P$ 是一个置换矩阵，$L$ 是单位下三角矩阵，$U$ 是上三角矩阵：\n$$\nP = \\begin{pmatrix}\n0 & 1 & 0 \\\\\n1 & 0 & 0 \\\\\n0 & 0 & 1\n\\end{pmatrix},\\quad\nL = \\begin{pmatrix}\n1 & 0 & 0 \\\\\n3 & 1 & 0 \\\\\n2 & -1 & 1\n\\end{pmatrix},\\quad\nU = \\begin{pmatrix}\n2 & -1 & 1 \\\\\n0 & 4 & 2 \\\\\n0 & 0 & 3\n\\end{pmatrix}.\n$$\n考虑线性系统 $A^{T} x = b$，其中\n$$\nb = \\begin{pmatrix} 10 \\\\ 7 \\\\ 8 \\end{pmatrix}.\n$$\n计算唯一解 $x$ 的第二个分量 $x_{2}$。给出 $x_{2}$ 的精确值。", "solution": "**求解推导**\n出发点是给定的分解 $P A = L U$。我们需要求解线性系统 $A^{T} x = b$。首先，我们必须用给定的矩阵 $P$、$L$ 和 $U$ 来表示 $A^T$。\n对分解方程两边取转置：\n$$\n(P A)^{T} = (L U)^{T}\n$$\n使用性质 $(XY)^{T} = Y^{T}X^{T}$，我们得到：\n$$\nA^{T} P^{T} = U^{T} L^{T}\n$$\n为了分离出 $A^T$，我们右乘 $P^T$ 的逆矩阵，即 $(P^T)^{-1}$。对于置换矩阵 $P$，其逆矩阵等于其转置矩阵，即 $P^{-1} = P^{T}$。因此，$(P^{T})^{-1} = (P^{-1})^{-1} = P$。\n将此代入 $A^T$ 的表达式中：\n$$\nA^{T} = U^{T} L^{T} P\n$$\n现在我们将此代入线性系统 $A^{T} x = b$ 中：\n$$\n(U^{T} L^{T} P) x = b\n$$\n通过引入中间向量，该方程可以高效地分解为三个更简单的问题序列来求解。设 $y = Px$ 和 $z = L^T y$。系统分解为以下步骤：\n1.  求解 $U^{T} z = b$ 得到向量 $z$。\n2.  求解 $L^{T} y = z$ 得到向量 $y$。\n3.  求解 $y = Px$ 得到最终解向量 $x$。\n\n**步骤 1：求解 $U^{T} z = b$**\n首先，我们求 $U$ 的转置：\n$$\nU^{T} = \\begin{pmatrix}\n2 & 0 & 0 \\\\\n-1 & 4 & 0 \\\\\n1 & 2 & 3\n\\end{pmatrix}\n$$\n该系统为 $U^{T} z = b$：\n$$\n\\begin{pmatrix}\n2 & 0 & 0 \\\\\n-1 & 4 & 0 \\\\\n1 & 2 & 3\n\\end{pmatrix}\n\\begin{pmatrix}\nz_{1} \\\\\nz_{2} \\\\\nz_{3}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n10 \\\\\n7 \\\\\n8\n\\end{pmatrix}\n$$\n这是一个下三角系统，可通过向前代入法求解。\n由第一行：$2 z_{1} = 10 \\implies z_{1} = 5$。\n由第二行：$-z_{1} + 4 z_{2} = 7 \\implies -5 + 4 z_{2} = 7 \\implies 4 z_{2} = 12 \\implies z_{2} = 3$。\n由第三行：$z_{1} + 2 z_{2} + 3 z_{3} = 8 \\implies 5 + 2(3) + 3 z_{3} = 8 \\implies 11 + 3 z_{3} = 8 \\implies 3 z_{3} = -3 \\implies z_{3} = -1$。\n因此，向量 $z$ 为：\n$$\nz = \\begin{pmatrix} 5 \\\\ 3 \\\\ -1 \\end{pmatrix}\n$$\n\n**步骤 2：求解 $L^{T} y = z$**\n接下来，我们求 $L$ 的转置：\n$$\nL^{T} = \\begin{pmatrix}\n1 & 3 & 2 \\\\\n0 & 1 & -1 \\\\\n0 & 0 & 1\n\\end{pmatrix}\n$$\n该系统为 $L^{T} y = z$：\n$$\n\\begin{pmatrix}\n1 & 3 & 2 \\\\\n0 & 1 & -1 \\\\\n0 & 0 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\ny_{1} \\\\\ny_{2} \\\\\ny_{3}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n5 \\\\\n3 \\\\\n-1\n\\end{pmatrix}\n$$\n这是一个上三角系统，可通过回代法求解。\n由第三行：$y_{3} = -1$。\n由第二行：$y_{2} - y_{3} = 3 \\implies y_{2} - (-1) = 3 \\implies y_{2} = 2$。\n由第一行：$y_{1} + 3 y_{2} + 2 y_{3} = 5 \\implies y_{1} + 3(2) + 2(-1) = 5 \\implies y_{1} + 4 = 5 \\implies y_{1} = 1$。\n因此，向量 $y$ 为：\n$$\ny = \\begin{pmatrix} 1 \\\\ 2 \\\\ -1 \\end{pmatrix}\n$$\n\n**步骤 3：求解 $y = Px$ 得到 $x$**\n最后一步是从 $y = Px$ 中求出 $x$。这等价于 $x = P^{-1}y$。如前所述，$P^{-1} = P^{T}$。在本例中，矩阵 $P$ 是对称的，所以 $P^T = P$。\n$$\nx = P y = \\begin{pmatrix}\n0 & 1 & 0 \\\\\n1 & 0 & 0 \\\\\n0 & 0 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n1 \\\\\n2 \\\\\n-1\n\\end{pmatrix}\n$$\n执行矩阵向量乘法：\n$$\nx = \\begin{pmatrix}\n(0)(1) + (1)(2) + (0)(-1) \\\\\n(1)(1) + (0)(2) + (0)(-1) \\\\\n(0)(1) + (0)(2) + (1)(-1)\n\\end{pmatrix}\n=\n\\begin{pmatrix} 2 \\\\ 1 \\\\ -1 \\end{pmatrix}\n$$\n解向量为：\n$$\nx = \\begin{pmatrix} 2 \\\\ 1 \\\\ -1 \\end{pmatrix}\n$$\n问题要求解的第二个分量，即 $x_{2}$。\n$x_2$ 的值为 $1$。", "answer": "$$\\boxed{1}$$", "id": "2396194"}, {"introduction": "在真实的计算世界中，有限的浮点精度意味着我们通过高斯消元法得到的解往往只是一个近似值。本练习介绍了一种强大的技术——迭代求精法，用于系统性地提高解的精度 [@problem_id:2396227]。你将通过计算残差并求解一个修正方程来迭代地逼近真实解，这对于处理工程中常见的病态问题尤其重要。", "problem": "一个方形线性方程组由数对 $(A,b)$ 给出，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是非奇异矩阵， $b \\in \\mathbb{R}^n$。对于下文的每个测试用例，也提供了一个初始近似解 $x_0 \\in \\mathbb{R}^n$。定义残差 $r \\in \\mathbb{R}^n$ 为 $r = b - A x_0$。定义修正量 $\\delta x \\in \\mathbb{R}^n$ 为线性系统 $A \\, \\delta x = r$ 的唯一解。定义修正后的近似解 $x_1 \\in \\mathbb{R}^n$ 为 $x_1 = x_0 + \\delta x$。你的任务是为每个测试用例计算 $x_1$。\n\n所有计算均为纯数学计算，不涉及任何物理单位。\n\n请使用以下测试套件。在每个用例中，$A$ 和 $b$ 指定了线性系统，$x_0$ 是初始近似解。\n\n- 测试用例1（良态的 $3 \\times 3$ 系统）：\n  - $\n    A_1 =\n    \\begin{bmatrix}\n    4 & 2 & 0 \\\\\n    2 & 5 & 1 \\\\\n    0 & 1 & 3\n    \\end{bmatrix}, \\quad\n    b_1 =\n    \\begin{bmatrix}\n    6 \\\\\n    9 \\\\\n    7\n    \\end{bmatrix}, \\quad\n    x_{0,1} =\n    \\begin{bmatrix}\n    1.2 \\\\\n    0.8 \\\\\n    1.9\n    \\end{bmatrix}.\n  $\n- 测试用例2（第一列需要行主元选择）：\n  - $\n    A_2 =\n    \\begin{bmatrix}\n    0 & 1 & 2 \\\\\n    1 & 0 & 3 \\\\\n    4 & 1 & 8\n    \\end{bmatrix}, \\quad\n    b_2 =\n    \\begin{bmatrix}\n    0 \\\\\n    -2 \\\\\n    -2\n    \\end{bmatrix}, \\quad\n    x_{0,2} =\n    \\begin{bmatrix}\n    0.9 \\\\\n    1.8 \\\\\n    -1.2\n    \\end{bmatrix}.\n  $\n- 测试用例3（病态的5阶 Hilbert 系统）：\n  - $\n    A_3 =\n    \\begin{bmatrix}\n    1 & \\tfrac{1}{2} & \\tfrac{1}{3} & \\tfrac{1}{4} & \\tfrac{1}{5} \\\\\n    \\tfrac{1}{2} & \\tfrac{1}{3} & \\tfrac{1}{4} & \\tfrac{1}{5} & \\tfrac{1}{6} \\\\\n    \\tfrac{1}{3} & \\tfrac{1}{4} & \\tfrac{1}{5} & \\tfrac{1}{6} & \\tfrac{1}{7} \\\\\n    \\tfrac{1}{4} & \\tfrac{1}{5} & \\tfrac{1}{6} & \\tfrac{1}{7} & \\tfrac{1}{8} \\\\\n    \\tfrac{1}{5} & \\tfrac{1}{6} & \\tfrac{1}{7} & \\tfrac{1}{8} & \\tfrac{1}{9}\n    \\end{bmatrix}, \\quad\n    b_3 = A_3 \\cdot\n    \\begin{bmatrix}\n    1 \\\\\n    1 \\\\\n    1 \\\\\n    1 \\\\\n    1\n    \\end{bmatrix}\n    , \\quad\n    x_{0,3} =\n    \\begin{bmatrix}\n    0.9 \\\\\n    1.1 \\\\\n    0.8 \\\\\n    1.2 \\\\\n    0.7\n    \\end{bmatrix}.\n  $\n- 测试用例4（具有非常小的前导系数的近奇异 $2 \\times 2$ 系统）：\n  - $\n    A_4 =\n    \\begin{bmatrix}\n    10^{-10} & 1 \\\\\n    1 & 1\n    \\end{bmatrix}, \\quad\n    b_4 = A_4 \\cdot\n    \\begin{bmatrix}\n    1 \\\\\n    1\n    \\end{bmatrix}\n    =\n    \\begin{bmatrix}\n    1.0000000001 \\\\\n    2\n    \\end{bmatrix}\n    , \\quad\n    x_{0,4} =\n    \\begin{bmatrix}\n    0.5 \\\\\n    0.5\n    \\end{bmatrix}.\n  $\n\n你的程序必须处理所有四个测试用例，并为每个用例输出修正后的近似解 $x_1$。最终输出格式要求是单行，内容是由方括号括起、逗号分隔的修正后向量的列表之列表，其中每个分量使用标准四舍五入到10位小数并以十进制表示法书写（例如，$1$ 应打印为 $1.0000000000$）。例如，两个向量的输出可能如下：$[[1.0000000000,2.0000000000],[3.5000000000,4.2500000000]]$。确保打印的行中不含空格。", "solution": "该问题要求对形如 $A x = b$ 的线性方程组（其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个非奇异矩阵， $b, x \\in \\mathbb{R}^n$）执行单步迭代改进计算。给定一个初始近似解 $x_0 \\in \\mathbb{R}^n$，目标是计算一个修正后的近似解 $x_1$。\n\n迭代改进的过程基于一个三步法，旨在减小近似解中的误差。设真实解为 $x$。初始近似解 $x_0$ 的误差为 $e_0 = x - x_0$。其基本原理是计算此误差的一个近似值，并用它来修正 $x_0$。\n\n步骤如下：\n\n1.  **计算残差**：残差向量 $r \\in \\mathbb{R}^n$ 定义为给定的右端项 $b$ 与将矩阵 $A$ 应用于当前近似解 $x_0$ 的结果之间的差。\n    $$\n    r = b - A x_0\n    $$\n    残差是衡量 $x_0$ 满足原方程程度的度量。注意残差与误差之间的关系：\n    $$\n    r = b - A x_0 = A x - A x_0 = A (x - x_0) = A e_0\n    $$\n    这表明残差是在线性变换 $A$ 作用下真实误差的像。\n\n2.  **求解修正量**：我们寻求一个修正向量 $\\delta x \\in \\mathbb{R}^n$，将其加到 $x_0$ 上后，可以得到一个对 $x$ 更好的近似。根据上面导出的关系，我们可以通过求解线性系统 $A e_0 = r$ 来解出真实误差 $e_0$。在实践中，我们求解的是误差的一个近似值，我们称之为修正量 $\\delta x$：\n    $$\n    A \\, \\delta x = r\n    $$\n    这是一个线性系统，其矩阵 $A$ 与原问题相同，但右端项是残差向量 $r$。解 $\\delta x$ 代表了为 $x_0$ 计算出的所需修正量。该系统的精确求解至关重要。对于一个通用矩阵 $A$，必须使用一种数值稳定的方法，例如带部分主元选择的高斯消去法（通常通过 LU 分解实现）。这对于处理主元可能为零或非常小的系统，以及对于减轻病态系统（例如测试用例3中的 Hilbert 矩阵）中数值误差的传播至关重要。\n\n3.  **更新近似解**：修正后的近似解 $x_1 \\in \\mathbb{R}^n$ 是通过将计算出的修正向量 $\\delta x$ 加到初始近似解 $x_0$ 上获得的。\n    $$\n    x_1 = x_0 + \\delta x\n    $$\n    如果修正系统 $A\\, \\delta x = r$ 被足够精确地求解，并且残差 $r$ 以高精度计算，那么新的近似解 $x_1$ 将比 $x_0$ 更接近真实解 $x$。在精确算术的理想情况下，由于 $\\delta x = e_0 = x - x_0$，更新操作 $x_1 = x_0 + (x-x_0) = x$ 将在单步内产生精确解 $x$。然而，在有限精度算术中，计算 $r$ 和 $\\delta x$ 时的舍入误差意味着 $x_1$ 只是一个改进的解，而非精确解。\n\n这个三步过程将被应用于所提供的四个测试用例中的每一个。对于每个用例，将使用给定的矩阵 $A$、向量 $b$ 和初始近似解 $x_0$ 来计算残差 $r$，求解修正量 $\\delta x$，并最终计算出修正后的解 $x_1$。数值计算将使用标准的双精度浮点算术进行。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes one step of iterative refinement for four different linear systems.\n    \"\"\"\n    # Define test cases\n    # Test case 1: Well-conditioned 3x3 system\n    A1 = np.array([[4, 2, 0], [2, 5, 1], [0, 1, 3]], dtype=np.float64)\n    b1 = np.array([6, 9, 7], dtype=np.float64)\n    x0_1 = np.array([1.2, 0.8, 1.9], dtype=np.float64)\n\n    # Test case 2: Requires row pivoting\n    A2 = np.array([[0, 1, 2], [1, 0, 3], [4, 1, 8]], dtype=np.float64)\n    b2 = np.array([0, -2, -2], dtype=np.float64)\n    x0_2 = np.array([0.9, 1.8, -1.2], dtype=np.float64)\n\n    # Test case 3: Ill-conditioned 5x5 Hilbert matrix\n    n3 = 5\n    A3 = np.array([[1.0 / (i + j + 1) for j in range(n3)] for i in range(n3)], dtype=np.float64)\n    x_exact_3 = np.ones(n3, dtype=np.float64)\n    b3 = A3 @ x_exact_3\n    x0_3 = np.array([0.9, 1.1, 0.8, 1.2, 0.7], dtype=np.float64)\n\n    # Test case 4: Nearly singular 2x2 system\n    A4 = np.array([[1e-10, 1], [1, 1]], dtype=np.float64)\n    x_exact_4 = np.ones(2, dtype=np.float64)\n    b4 = A4 @ x_exact_4\n    x0_4 = np.array([0.5, 0.5], dtype=np.float64)\n\n    test_cases = [\n        (A1, b1, x0_1),\n        (A2, b2, x0_2),\n        (A3, b3, x0_3),\n        (A4, b4, x0_4),\n    ]\n\n    results = []\n    for A, b, x0 in test_cases:\n        # Step 1: Compute the residual r = b - A*x0\n        r = b - A @ x0\n\n        # Step 2: Solve the linear system A*dx = r for the correction dx\n        delta_x = np.linalg.solve(A, r)\n\n        # Step 3: Compute the refined approximation x1 = x0 + dx\n        x1 = x0 + delta_x\n        results.append(x1)\n\n    # Format the output string as per problem specification\n    # e.g., [[1.0,2.0],[3.5,4.25]] -> \"[[1.0000000000,2.0000000000],[3.5000000000,4.2500000000]]\"\n    # No spaces, 10 decimal places.\n    formatted_vectors = []\n    for vec in results:\n        formatted_components = [f\"{val:.10f}\" for val in vec]\n        formatted_vectors.append(f\"[{','.join(formatted_components)}]\")\n    \n    final_output_string = f\"[{','.join(formatted_vectors)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "2396227"}]}