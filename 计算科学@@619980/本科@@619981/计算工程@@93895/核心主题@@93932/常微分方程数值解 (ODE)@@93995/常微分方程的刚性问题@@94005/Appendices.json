{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。要真正理解刚性问题，最直观的方式莫过于亲眼见证标准显式积分器在处理此类问题时的“挣扎”。本练习将指导你使用一个自适应步长的显式龙格-库塔方法（RK45）来求解一系列常微分方程，其中既有非刚性问题，也有刚性问题。通过编程观察和记录积分过程中的步长变化，你将亲身体验到刚性系统是如何迫使求解器为了维持数值稳定性而采取极端微小的步长，即便此时解本身已经非常平滑 [@problem_id:2439135]。这个实践不仅能让你对“刚性”产生具体感知，更能激发你对寻求更高效算法的思考。", "problem": "构建一个程序，用以分析显式自适应积分器在处理具有刚性特征的初值问题时的步长行为。对于每个给定的初值问题，对系统进行积分，并记录积分过程中的最小可接受时间步长。使用带有嵌入式四阶估计器的五阶显式龙格-库塔-费尔贝格方法（Runge-Kutta-Fehlberg (RKF45)），并采用标准的绝对和相对误差控制。对于所有问题，要求绝对容差 $\\mathrm{atol} = 10^{-9}$ 和相对容差 $\\mathrm{rtol} = 10^{-6}$。定义一个可接受步长为：其嵌入式局部误差估计满足一个标准加权均方根准则，且其值小于或等于 $1$。定义“极端步长缩减”为：在指定的积分区间内，出现了严格小于 $10^{-4}$ 的最小可接受时间步长。\n\n您必须评估以下初值问题测试套件：\n\n- 测试 A (非刚性标量): $$y'(t) = -y(t), \\quad y(0) = 1, \\quad t \\in [0, 10].$$\n- 测试 B (刚性标量，强迫线性): $$y'(t) = -10000\\,y(t) + 30000 - 20000\\,e^{-t}, \\quad y(0) = 0, \\quad t \\in [0, 0.1].$$\n- 测试 C (刚性线性双分量系统): $$\\begin{aligned} y_1'(t) &= -15\\,y_1(t), \\\\ y_2'(t) &= -10000\\left(y_2(t) - y_1(t)\\right), \\end{aligned} \\quad \\begin{bmatrix} y_1(0) \\\\ y_2(0) \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}, \\quad t \\in [0, 0.2].$$\n\n对每个测试，计算积分过程中遇到的最小可接受步长 $h_{\\min}$，并根据 $h_{\\min} < 10^{-4}$ 是否成立来确定一个布尔值。最终要求输出为单行文本，其中包含一个用逗号分隔的这三个布尔结果的列表，按 $\\text{[A,B,C]}$ 的顺序排列，并用方括号括起来。例如，形式为 $\\text{[False,True,True]}$ 的输出表示测试 B 和测试 C 发生了极端步长缩减，而测试 A 没有。\n\n本问题不涉及物理单位、角度和百分比。您的程序必须生成单行输出，其中包含一个用逗号分隔的列表，用方括号括起来，并严格按照上述 $\\text{[A,B,C]}$ 的顺序排列结果。", "solution": "该问题陈述已经过验证，被认为是有效的。它具有科学依据，问题定义良好、客观，并包含了构建唯一、可验证解所需的所有必要信息。该问题属于计算工程和数值分析领域，具体涉及常微分方程（ODEs）中的刚性概念。\n\n初值问题中的刚性，是指当其解包含在截然不同的时间尺度上变化的多个分量时出现的现象。这对显式数值积分方法构成了重大挑战。虽然快速衰减的分量（瞬态分量）可能很快就变得可以忽略不计，但它们在系统雅可比矩阵中的存在，会为了维持数值稳定性而继续对积分器的步长施加严格的限制。步长受限于最快的时间尺度，即使当只考虑解的光滑、慢变部分的精度要求时，本可以允许使用大得多的步长。这导致了计算效率低下的积分过程，因为求解器被迫采取了过多的极小步长。\n\n本任务旨在通过分析一个显式自适应积分器在三个不同常微分方程问题上的步长行为，来展示这一现象。所选的积分器是带有嵌入式四阶误差估计器的五阶龙格-库塔-费尔贝格方法，通常称为 RKF45。这类方法的一个现代、高质量的实现是 Dormand-Prince 5(4) 对，它在 `scipy` 库中以 `scipy.integrate.solve_ivp` 的 `method='RK45'` 形式提供。这将是用于数值积分的工具。\n\n积分过程使用基于局部误差估计的自适应步长控制。在每一步，通过比较五阶解和嵌入的四阶解来估计误差。这个误差 $E$ 使用加权均方根范数来度量，只有当 $E \\le 1$ 时，该步长才被接受。权重是指定的绝对容差 $\\mathrm{atol} = 10^{-9}$ 和相对容差 $\\mathrm{rtol} = 10^{-6}$ 的函数。具体来说，对于解向量 $y$，误差由 $\\mathrm{atol} + \\mathrm{rtol} \\times |y|$ 进行缩放。在一个大小为 $h$ 的步长被接受后，选择下一个步长大小以使估计误差保持在目标值 $1$ 附近。如果误差过大，该步长将被拒绝，并用一个更小的 $h$ 重试。\n\n我们将分析三个初值问题，并记录每个问题的最小可接受步长 $h_{\\min}$。“极端步长缩减”的条件定义为 $h_{\\min} < 10^{-4}$。\n\n测试 A：非刚性标量问题\n该常微分方程为 $y'(t) = -y(t)$，初值为 $y(0)=1$，定义在 $t \\in [0, 10]$ 上。\n系统的雅可比矩阵只是一个标量 $J = [-1]$。唯一的特征值是 $\\lambda = -1$，对应的时间常数为 $\\tau = 1/|\\lambda| = 1$。其解为 $y(t) = e^{-t}$。这里只有一个时间尺度，而且不是特别快。自适应积分器选择的步长将主要由 $\\mathrm{atol}$ 和 $\\mathrm{rtol}$ 定义的精度要求决定。我们不预期稳定性会迫使步长变得病态地小。因此，预测 $h_{\\min}$ 不会低于 $10^{-4}$ 的阈值。\n\n测试 B：刚性标量问题\n该常微分方程为 $y'(t) = -10000\\,y(t) + 30000 - 20000\\,e^{-t}$，初值为 $y(0)=0$，定义在 $t \\in [0, 0.1]$ 上。\n雅可比矩阵为 $J = [-10000]$。特征值为 $\\lambda = -10000$，对应一个极快的时间常数 $\\tau = 1/|\\lambda| = 10^{-4}\\,$s。显式龙格-库塔方法的稳定域要求步长 $h$ 和特征值 $\\lambda$ 的乘积位于复平面中的一个有界区域内。对于实负特征值，这施加了一个形如 $h \\lesssim C/|\\lambda|$ 的约束，其中 $C$ 是一个数量级为 $1$ 的常数。对于此问题，即为 $h \\lesssim C \\times 10^{-4}$。即使与此特征值相关的初始瞬态已经衰减（这在 $10^{-4}$ 的几个倍数时间内就很快发生），这个稳定性约束对于显式积分器仍然有效。因此，步长将在整个积分区间内受到严重限制。因此强烈预测 $h_{\\min}$ 将小于 $10^{-4}$。\n\n测试 C：刚性线性系统\n该系统由以下方程给出：\n$$\n\\begin{aligned}\ny_1'(t) &= -15\\,y_1(t) \\\\\ny_2'(t) &= -10000\\left(y_2(t) - y_1(t)\\right)\n\\end{aligned}\n\\quad \\text{with} \\quad\n\\begin{bmatrix} y_1(0) \\\\ y_2(0) \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}\n\\quad \\text{on} \\quad t \\in [0, 0.2].\n$$\n该系统的雅可比矩阵是：\n$$\nJ = \\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{y}} = \\begin{bmatrix} -15 & 0 \\\\ 10000 & -10000 \\end{bmatrix}\n$$\n由于该矩阵是下三角矩阵，其特征值是其对角线元素：$\\lambda_1 = -15$ 和 $\\lambda_2 = -10000$。这对应着两个截然不同的时间尺度：一个慢尺度 $\\tau_1 = 1/15 \\approx 0.067$ 和一个非常快的尺度 $\\tau_2 = 1/10000 = 10^{-4}$。特征值幅值的比率，即刚性比，为 $|\\lambda_2|/|\\lambda_1| = 10000/15 \\approx 667$，这个值很大，证实了该系统是刚性的。与测试 B 一样，显式积分器的稳定性由幅值最大的特征值 $\\lambda_2 = -10000$ 决定。步长 $h$ 将受到与此特征值相关的稳定性限制的约束，迫使 $h$ 保持在 $10^{-4}$ 或更小的数量级。因此，预测 $h_{\\min} < 10^{-4}$。\n\n程序将通过为每种情况调用 `scipy.integrate.solve_ivp` 来实现此分析。返回的解对象包含一个数组 `sol.t`，其中存储了计算解的时间点。然后，通过计算该数组中连续元素的差 `np.diff(sol.t)` 来得到可接受步长的序列。这些值中的最小值即为 $h_{\\min}$，然后将其与 $10^{-4}$ 的阈值进行比较，以生成所需的布尔值输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Analyzes step-size behavior of an explicit adaptive integrator on\n    initial value problems exhibiting stiffness, as per the problem description.\n    \"\"\"\n\n    # Define common parameters for the analysis.\n    atol = 1e-9\n    rtol = 1e-6\n    step_size_threshold = 1e-4\n\n    # Define the test cases.\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"fun\": lambda t, y: -y,\n            \"t_span\": [0, 10],\n            \"y0\": [1],\n        },\n        {\n            \"name\": \"B\",\n            \"fun\": lambda t, y: -10000 * y[0] + 30000 - 20000 * np.exp(-t),\n            \"t_span\": [0, 0.1],\n            \"y0\": [0],\n        },\n        {\n            \"name\": \"C\",\n            \"fun\": lambda t, y: np.array([-15 * y[0], -10000 * (y[1] - y[0])]),\n            \"t_span\": [0, 0.2],\n            \"y0\": [1, 0],\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Integrate the ODE system using the specified method and tolerances.\n        # The 'RK45' method in SciPy is the Dormand-Prince 5(4) pair, a standard\n        # high-quality implementation of the class of methods described in the problem.\n        sol = solve_ivp(\n            fun=case[\"fun\"],\n            t_span=case[\"t_span\"],\n            y0=case[\"y0\"],\n            method='RK45',\n            atol=atol,\n            rtol=rtol,\n        )\n\n        # The 'sol.t' attribute contains the time points of the accepted steps.\n        # The differences between consecutive time points are the accepted step sizes.\n        if len(sol.t) < 2:\n            # This case should not occur for the given problems but is a safe check.\n            # If only one point (initial) exists, there are no steps.\n            # We can treat this as no extreme reduction, or handle as an error.\n            # For this problem's context, it indicates no steps were taken or needed,\n            # so no small steps were taken.\n            h_min = np.inf\n        else:\n            step_sizes = np.diff(sol.t)\n            h_min = np.min(step_sizes)\n\n        # Determine if extreme step-size reduction occurred.\n        # The problem defines this as h_min strictly less than the threshold.\n        extreme_reduction = h_min < step_size_threshold\n        results.append(extreme_reduction)\n\n    # Format the final output string as a comma-separated list of booleans.\n    # Python's `str(bool)` converts True to 'True' and False to 'False',\n    # which is not what the example output shows. The problem asks for a list\n    # of boolean values, which is commonly represented textually as true/false\n    # or True/False. We will stick to the standard Python representation.\n    # The example [False,True,True] uses capitalized boolean literals.\n    # Let's format it exactly as specified.\n    results_str = [str(r) for r in results]\n    \n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "2439135"}, {"introduction": "理解了理论之后，我们便可以着手构建解决方案。此练习旨在让你亲手实现并验证一种简单而强大的隐式方法——后向欧拉法（也称为一阶向后分化公式，BDF1）。你将为典型的刚性测试方程 $ y'(t) = \\lambda y(t) $ 编写一个求解程序，并通过一系列精心设计的测试案例，来检验该方法的 A-稳定性和 L-稳定性 [@problem_id:2439069]。这次编码实践将使隐式方法的概念不再抽象，你会通过定量分析，证实该方法即使在 $ h|\\lambda| $ 极大的情况下也能保持稳定并有效抑制快速衰减的分量，从而深刻理解为何它是求解刚性问题的可靠工具。", "problem": "一个代表耦合耗散过程的线性时不变系统由常微分方程 $\\,\\mathbf{u}'(t)=\\mathbf{A}\\,\\mathbf{u}(t)\\,$ 给出，其中\n$$\n\\mathbf{A}=\\begin{bmatrix}\n-1 & 0\\\\\n0 & -900\n\\end{bmatrix},\\quad \\mathbf{u}(0)=\\begin{bmatrix}1\\\\1\\end{bmatrix}, \\quad t\\in[0,2].\n$$\n一位工程师建议使用经典四阶龙格-库塔 (RK4) 方法或后向欧拉 (BE) 方法，并采用 $\\,h=0.004\\,$ 的恒定步长对该系统进行积分。根据应用于标量测试方程 $\\,y'(t)=\\lambda y(t)\\,$ 的单步法线性稳定性的定义以及 $\\,\\mathbf{A}\\,$ 的谱映射进行推理，选择所有正确的陈述。\n\nA. 使用步长 $\\,h=0.004\\,$，经典的四阶龙格-库塔 (RK4) 方法对 $\\,\\mathbf{A}\\,$ 的两个本征模在 $\\,t\\in[0,2]\\,$ 上都产生线性稳定的更新。\n\nB. 使用步长 $\\,h=0.004\\,$，经典的四阶龙格-库塔 (RK4) 方法对于 $\\,\\mathbf{A}\\,$ 的快本征模是线性不稳定的，因此即使真实解是衰减的，数值解也可能增长。\n\nC. 对于任何步长 $\\,h>0\\,$，后向欧拉 (BE) 方法对该系统都是线性稳定的。\n\nD. 在标准的计算工程意义上，该系统是刚性的：显式步长的限制是由快模态决定的，而不是由解析慢模态所需的精度决定的。\n\nE. 因为两个特征值都在左开半平面，所以任何相容的显式龙格-库塔方法对于任意 $\\,h>0\\,$ 在此问题上都是无条件稳定的。", "solution": "首先对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n- 控制常微分方程 (ODE) 是一个线性时不变系统：$\\mathbf{u}'(t)=\\mathbf{A}\\,\\mathbf{u}(t)$。\n- 系统矩阵为 $\\mathbf{A}=\\begin{bmatrix} -1 & 0\\\\ 0 & -900 \\end{bmatrix}$。\n- 初始条件为 $\\mathbf{u}(0)=\\begin{bmatrix}1\\\\1\\end{bmatrix}$。\n- 时间域为 $t\\in[0,2]$。\n- 建议的恒定步长为 $h=0.004$。\n- 考虑两种数值积分方法：经典的四阶龙格-库塔 (RK4) 方法和后向欧拉 (BE) 方法。\n- 分析必须基于应用于标量测试方程 $y'(t)=\\lambda y(t)$ 的线性稳定性理论以及矩阵 $\\mathbf{A}$ 的谱。\n\n### 步骤2：使用提取的已知条件进行验证\n所给出的问题是常微分方程数值分析领域中一个标准的、定义明确的初值问题。\n- **科学依据：** 该问题使用了线性代数、微分方程和数值稳定性（RK4、后向欧拉、刚性）等基本概念，这些都是计算科学与工程中的既定原理。这是一个用于说明刚性概念的教科书式例子。\n- **适定的：** 该问题为一个具有初值条件的线性ODE系统提供了完整的说明，该系统拥有唯一的、稳定的解析解。所提出的问题是具体的，且基于标准的稳定性理论有确切的答案。\n- **客观性：** 问题陈述使用精确的数学和技术语言表达，没有歧义、主观性或非科学的主张。\n- **完整性与一致性：** 提供了所有必要的信息（矩阵 $\\mathbf{A}$、初始条件 $\\mathbf{u}(0)$、时间区间 $t \\in [0,2]$、步长 $h$、方法）。没有矛盾之处。\n\n### 步骤3：结论与行动\n该问题是有效的。可以进行严谨的求解和选项评估。\n\n### 推导\n对于系统 $\\mathbf{u}' = \\mathbf{A}\\mathbf{u}$，数值方法的稳定性由其在标量测试问题 $y' = \\lambda y$ 上的行为决定，其中 $\\lambda$ 是 $\\mathbf{A}$ 的特征值。矩阵 $\\mathbf{A}$ 是对角矩阵，因此其特征值是对角线上的元素：$\\lambda_1 = -1$ 和 $\\lambda_2 = -900$。给定初始条件 $\\mathbf{u}(0)=\\begin{bmatrix}1\\\\1\\end{bmatrix}$，该系统的精确解为 $\\mathbf{u}(t) = \\begin{bmatrix}e^{\\lambda_1 t} \\\\ e^{\\lambda_2 t}\\end{bmatrix} = \\begin{bmatrix}e^{-t} \\\\ e^{-900t}\\end{bmatrix}$。随着 $t$ 的增加，解的两个分量都衰减。\n\n如果一个单步数值方法对于一个真实解衰减的问题其数值解不增长，则该方法是线性稳定的。对于测试方程 $y' = \\lambda y$，数值更新为 $y_{n+1} = R(z) y_n$，其中 $z = h\\lambda$，$R(z)$ 是该方法的稳定性函数。线性稳定的条件是 $|R(z)| \\le 1$。\n\n建议的步长是 $h = 0.004$。我们必须对两个特征值计算 $z = h\\lambda$：\n- 对于与 $\\lambda_1 = -1$ 相关的“慢”模态：$z_1 = h \\lambda_1 = 0.004 \\times (-1) = -0.004$。\n- 对于与 $\\lambda_2 = -900$ 相关的“快”模态：$z_2 = h \\lambda_2 = 0.004 \\times (-900) = -3.6$。\n\n现在我们分析这两种方法。\n\n1.  **经典四阶龙格-库塔 (RK4) 方法：**\n    RK4 的稳定性函数是指数函数的截断泰勒级数，$R_{RK4}(z) = 1 + z + \\frac{z^2}{2!} + \\frac{z^3}{3!} + \\frac{z^4}{4!}$。对于负实数 $z$，其绝对稳定区域 $\\{z \\in \\mathbb{C} : |R_{RK4}(z)| \\le 1\\}$ 对应于区间大约 $[-2.785, 0]$。\n    - 对于慢模态：$z_1 = -0.004$。该值位于区间 $[-2.785, 0]$ 内。因此，该方法对此模态是稳定的。\n    - 对于快模态：$z_2 = -3.6$。该值位于区间 $[-2.785, 0]$ 之外，因为 $-3.6 < -2.785$。该方法对此模态是不稳定的。\n\n2.  **后向欧拉 (BE) 方法：**\n    其稳定性函数为 $R_{BE}(z) = (1-z)^{-1}$。其绝对稳定区域为 $\\{z \\in \\mathbb{C} : |R_{BE}(z)| \\le 1\\}$，这等价于 $\\{z \\in \\mathbb{C} : |1-z| \\ge 1\\}$。该区域包括整个左开半平面 $\\text{Re}(z) < 0$。具有此性质的方法称为 A-稳定。\n    - 对于两个特征值 $\\lambda_1 = -1$ 和 $\\lambda_2 = -900$，以及任意步长 $h > 0$，值 $z_1 = h\\lambda_1$ 和 $z_2 = h\\lambda_2$ 都是负实数。它们总是位于左半平面内。因此，对于任意 $h > 0$，后向欧拉方法对两个模态都是稳定的。\n\n### 逐项分析\n\n**A. 使用步长 $\\,h=0.004\\,$，经典的四阶龙格-库塔 (RK4) 方法对 $\\,\\mathbf{A}\\,$ 的两个本征模在 $\\,t\\in[0,2]\\,$ 上都产生线性稳定的更新。**\n如上所述，对于快本征模 $\\lambda_2 = -900$，稳定性参数为 $z_2 = -3.6$。此值在 RK4 方法的稳定性区间 $[-2.785, 0]$ 之外。因此，对快模态的更新是不稳定的。该陈述声称对*两个*本征模都稳定，这是错误的。\n**结论：错误。**\n\n**B. 使用步长 $\\,h=0.004\\,$，经典的四阶龙格-库塔 (RK4) 方法对于 $\\,\\mathbf{A}\\,$ 的快本征模是线性不稳定的，因此即使真实解是衰减的，数值解也可能增长。**\n如前所示，RK4 对快模态确实是线性不稳定的，因为 $z_2 = -3.6$ 在稳定区域之外。当一个方法线性不稳定时，对应于该模态的数值解分量的幅度在每一步都会被放大，即 $|R_{RK4}(-3.6)| > 1$。这导致数值解中的误差呈指数级增长，并最终主导整个计算，尽管真实解的分量 $e^{-900t}$ 会迅速衰减到零。该陈述正确描述了违反稳定性条件的后果。\n**结论：正确。**\n\n**C. 对于任何步长 $\\,h>0\\,$，后向欧拉 (BE) 方法对该系统都是线性稳定的。**\n后向欧拉方法是 A-稳定的。其绝对稳定区域包含整个复数左半平面，即 $\\{z \\in \\mathbb{C} : \\text{Re}(z) \\le 0\\}$。系统矩阵 $\\mathbf{A}$ 的特征值为 $\\lambda_1 = -1$ 和 $\\lambda_2 = -900$，两者都在左开半平面。对于任何 $h > 0$，乘积 $h\\lambda_1$ 和 $h\\lambda_2$ 也将位于左开半平面内。因此，它们将始终在后向欧拉方法的稳定区域内。该方法对于此问题是无条件稳定的。\n**结论：正确。**\n\n**D. 在标准的计算工程意义上，该系统是刚性的：显式步长的限制是由快模态决定的，而不是由解析慢模态所需的精度决定的。**\n当时间尺度存在巨大差异时，就会出现刚性。在这里，时间尺度为 $\\tau_1 = 1/|\\lambda_1| = 1$ 秒 和 $\\tau_2 = 1/|\\lambda_2| = 1/900 \\approx 0.0011$ 秒。比率 $\\tau_1/\\tau_2 = 900 \\gg 1$。在一个非常短暂的瞬态周期（$\\tau_2$ 的几倍）之后，快分量 $e^{-900t}$ 变得可以忽略不计，解的行为类似于 $e^{-t}$。为了精确地解析这种慢行为，一个相对较大的步长（例如 $h=0.1$）就足够了。然而，为了使像 RK4 这样的显式方法保持稳定，步长必须满足 $h \\le 2.785/|\\lambda_2| = 2.785/900 \\approx 0.0031$。这个步长是由快速、瞬态模态的稳定性决定的，而不是由慢速、持续模态的精度要求决定的。这正是刚性系统的定义。\n**结论：正确。**\n\n**E. 因为两个特征值都在左开半平面，所以任何相容的显式龙格-库塔方法对于任意 $\\,h>0\\,$ 在此问题上都是无条件稳定的。**\n这个陈述是根本错误的。没有显式龙格-库塔方法可以是 A-稳定的。显式方法的稳定性函数 $R(z)$ 是一个关于 $z$ 的多项式。当 $|z| \\to \\infty$ 时，任何多项式都是无界的，因此对于左半平面中的所有 $z$，$|R(z)|$ 不可能小于或等于 $1$。显式方法的稳定区域总是有限的。因此，对于任何此类方法和任何 $\\lambda < 0$，总存在一个足够大的步长 $h$，使得 $h\\lambda$ 落在此稳定区域之外。因此，对于刚性问题，所有显式方法对 $h$ 都有一个条件稳定性限制。\n**结论：错误。**", "answer": "$$\\boxed{BCD}$$", "id": "2439060"}, {"introduction": "理解了理论之后，我们便可以着手构建解决方案。此练习旨在让你亲手实现并验证一种简单而强大的隐式方法——后向欧拉法（也称为一阶向后分化公式，BDF1）。你将为典型的刚性测试方程 $ y'(t) = \\lambda y(t) $ 编写一个求解程序，并通过一系列精心设计的测试案例，来检验该方法的 A-稳定性和 L-稳定性 [@problem_id:2439069]。这次编码实践将使隐式方法的概念不再抽象，你会通过定量分析，证实该方法即使在 $ h|\\lambda| $ 极大的情况下也能保持稳定并有效抑制快速衰减的分量，从而深刻理解为何它是求解刚性问题的可靠工具。", "problem": "实现一个一阶单步后向差分格式方法，用于求解由典型刚性测试方程定义的标量线性初值问题。考虑常微分方程 $y^{\\prime}(t)=\\lambda y(t)$，初始条件为 $y(0)=y_0$。设时间网格是均匀的，步长为 $h&gt;0$，因此对于整数 $n \\ge 0$，有 $t_n = n h$。令 $N$ 表示所取的步数，使得最终时间为 $t_N = N h$。对于下面列出的每个测试用例，使用相同的初始值 $y_0=1$，并应用该实现来近似计算在 $t_N$ 时的数值解。然后，对每个用例使用规定的量化标准评估指定的属性。\n\n要求评估的属性：\n- A-稳定性检查：对于标记为 A-稳定性的用例，如果 $t_N$ 时的数值解幅值不超过初始幅值，即 $\\lvert y_N \\rvert \\le \\lvert y_0 \\rvert$，则返回布尔值 true，否则返回 false。\n- L-稳定性检查：对于标记为 L-稳定性的用例，如果单步能产生相对于初始值的刚性衰减，具体来说，如果 $\\lvert y_1 \\rvert / \\lvert y_0 \\rvert \\le \\tau_L$，其中容差 $\\tau_L=10^{-6}$，则返回布尔值 true，否则返回 false。\n- 零特征值边界检查：对于标记为零边界的用例，如果 $N$ 步后的数值解在严格容差 $\\tau_0=10^{-12}$ 内等于初始条件，即 $\\lvert y_N - y_0 \\rvert \\le \\tau_0$，则返回布尔值 true，否则返回 false。\n\n测试套件：\n- 用例 1 (A-稳定性)：$\\lambda=-2.5$, $h=4.0$, $N=5$。\n- 用例 2 (A-稳定性，极端刚性但步长大)：$\\lambda=-10^3$, $h=10^2$, $N=2$。\n- 用例 3 (L-稳定性)：$\\lambda=-10^9$, $h=10^{-2}$, $N=1$, 容差 $\\tau_L=10^{-6}$。\n- 用例 4 (零特征值边界)：$\\lambda=0$, $h=10$, $N=3$, 容差 $\\tau_0=10^{-12}$。\n- 用例 5 (正 $\\lambda$ 值的非 A-稳定配置)：$\\lambda=0.5$, $h=3.0$, $N=5$。\n- 用例 6 (靠近负实轴上一个代表性边界的 A-稳定性)：$\\lambda=-10^{-12}$, $h=10^{12}$, $N=4$。\n\n所有计算都应使用不带物理单位的纯数进行。不涉及角度。不得使用百分比。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来（例如 $[result_1,result_2,\\dots,result_6]$），其中每个条目是按上述测试套件顺序列出的布尔值。", "solution": "问题陈述经过严格审查，被认定是有效的。这是一个在计算工程领域中定义明确、具有科学依据的问题，具体涉及求解刚性常微分方程方法的数值稳定性。所有参数和标准都得到了足够精确的定义。\n\n任务是为典型的刚性测试方程 $y'(t) = \\lambda y(t)$（初始条件为 $y(0)=y_0$）实现一阶单步后向差分格式 (BDF1)，该方法也称为后向欧拉法。然后，我们必须对一组给定的测试用例评估某些稳定性属性。\n\n首先，我们推导数值格式。BDF1 方法使用一阶后向差分来近似时间 $t_{n+1}$ 处的导数 $y'(t)$：\n$$\ny'(t_{n+1}) \\approx \\frac{y_{n+1} - y_n}{h}\n$$\n其中 $y_n$ 是对 $y(t_n)$ 的数值近似，而 $h = t_{n+1} - t_n$ 是恒定的时间步长。对于给定的常微分方程 (ODE)，$y'(t_{n+1}) = \\lambda y(t_{n+1})$。因此，BDF1 离散化是隐式的：\n$$\n\\frac{y_{n+1} - y_n}{h} = \\lambda y_{n+1}\n$$\n为了获得递推关系，我们必须求解 $y_{n+1}$（用 $y_n$ 表示）：\n$$\ny_{n+1} - y_n = h \\lambda y_{n+1}\n$$\n$$\ny_{n+1} (1 - h \\lambda) = y_n\n$$\n$$\ny_{n+1} = \\frac{1}{1 - h \\lambda} y_n\n$$\n此递推关系定义了每个时间步的数值解。其中 $R(z) = \\frac{1}{1 - z}$（$z = h\\lambda$）是该方法的稳定性函数。通过重复应用此公式，第 $N$ 步的数值解可以用一个闭式形式表示：\n$$\ny_N = \\left( \\frac{1}{1 - h \\lambda} \\right)^N y_0\n$$\n这个单一的公式足以评估所有测试用例。初始条件给定为 $y_0=1$。\n\n问题要求检查 A-稳定性和 L-稳定性。如果一个数值方法的绝对稳定域包含整个复平面的左半部分，即 $\\{z \\in \\mathbb{C} \\mid \\text{Re}(z) \\le 0 \\}$，则该方法是 A-稳定的。这意味着对于任何稳定的常微分方程（其中 $\\text{Re}(\\lambda) \\le 0$），无论步长 $h$ 如何，数值解都不会增长。对于 BDF1 方法，其稳定性函数为 $R(z) = (1 - z)^{-1}$。如果我们令 $z = x + iy$ 且 $x \\le 0$，则其幅值的平方为：\n$$\n|R(z)|^2 = \\left| \\frac{1}{1 - (x+iy)} \\right|^2 = \\frac{1}{(1-x)^2 + y^2}\n$$\n因为 $x \\le 0$，所以 $1-x \\ge 1$，因此 $(1-x)^2 \\ge 1$。所以， $|R(z)|^2 \\le 1$，这证实了对于所有 $\\text{Re}(z) \\le 0$ 的情况，都有 $|R(z)| \\le 1$。BDF1 方法是 A-稳定的。因此，A-稳定性检查 $|y_N| \\le |y_0|$ 对于所有 $\\lambda \\le 0$ 的用例都应为真。\n\nL-稳定性是一个更强的条件，它要求在 A-稳定的基础上，稳定性函数在左半平面的无穷远处趋于零：$\\lim_{\\text{Re}(z) \\to -\\infty} |R(z)| = 0$。对于 BDF1，当 $\\text{Re}(z) \\to -\\infty$ 时， $|1-z| \\to \\infty$，所以 $|R(z)| \\to 0$。该方法确实是 L-稳定的。此属性对于刚性问题至关重要，因为它能确保与非常大的负特征值相对应的分量被迅速衰减。\n\n现在，我们使用推导出的公式 $y_N = (1 - h \\lambda)^{-N} y_0$ 和给定的标准，以 $y_0 = 1$ 来评估每个测试用例。\n\n用例 1 (A-稳定性)：$\\lambda=-2.5$, $h=4.0$, $N=5$。\n乘积 $z = h\\lambda = (4.0)(-2.5) = -10.0$。\n$y_5 = (\\frac{1}{1 - (-10.0)})^5 (1) = (\\frac{1}{11})^5$。\n标准是 $|y_5| \\le |y_0|$，即 $|\\frac{1}{11^5}| \\le 1$。这是正确的。\n\n用例 2 (A-稳定性)：$\\lambda=-10^3$, $h=10^2$, $N=2$。\n乘积 $z = h\\lambda = (10^2)(-10^3) = -10^5$。\n$y_2 = (\\frac{1}{1 - (-10^5)})^2 (1) = (\\frac{1}{100001})^2$。\n标准是 $|y_2| \\le |y_0|$，即 $|\\frac{1}{100001^2}| \\le 1$。这是正确的。\n\n用例 3 (L-稳定性)：$\\lambda=-10^9$, $h=10^{-2}$, $N=1$, $\\tau_L=10^{-6}$。\n乘积 $z = h\\lambda = (10^{-2})(-10^9) = -10^7$。\n$y_1 = (\\frac{1}{1 - (-10^7)})^1 (1) = \\frac{1}{10000001}$。\n标准是 $|y_1| / |y_0| \\le \\tau_L$，即 $|\\frac{1}{10000001}| \\le 10^{-6}$。这等价于 $\\frac{1}{10000001} \\le \\frac{1}{1000000}$，这是正确的。\n\n用例 4 (零特征值边界)：$\\lambda=0$, $h=10$, $N=3$, $\\tau_0=10^{-12}$。\n乘积 $z = h\\lambda = (10)(0) = 0$。\n$y_3 = (\\frac{1}{1 - 0})^3 (1) = 1$。\n标准是 $|y_3 - y_0| \\le \\tau_0$，即 $|1 - 1| \\le 10^{-12}$，或 $0 \\le 10^{-12}$。这是正确的。\n\n用例 5 (非 A-稳定配置)：$\\lambda=0.5$, $h=3.0$, $N=5$。\n由于 $\\lambda > 0$，该常微分方程本身是不稳定的。预期 A-稳定性风格的检查 $|y_N| \\le |y_0|$ 会失败。\n乘积 $z = h\\lambda = (3.0)(0.5) = 1.5$。\n$y_5 = (\\frac{1}{1 - 1.5})^5 (1) = (\\frac{1}{-0.5})^5 = (-2)^5 = -32$。\n标准是 $|y_5| \\le |y_0|$，即 $|-32| \\le 1$，或 $32 \\le 1$。这是错误的。\n\n用例 6 (A-稳定性)：$\\lambda=-10^{-12}$, $h=10^{12}$, $N=4$。\n乘积 $z = h\\lambda = (10^{12})(-10^{-12}) = -1$。\n$y_4 = (\\frac{1}{1 - (-1)})^4 (1) = (\\frac{1}{2})^4 = \\frac{1}{16}$。\n标准是 $|y_4| \\le |y_0|$，即 $|\\frac{1}{16}| \\le 1$。这是正确的。\n\n结果序列为：True, True, True, True, False, True。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests the BDF1 method for the canonical stiff test equation\n    y'(t) = lambda * y(t) across a suite of predefined test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'id': 1, 'lambda_val': -2.5, 'h': 4.0, 'N': 5, 'check': 'A-stability', 'tol': None},\n        {'id': 2, 'lambda_val': -1.0e3, 'h': 1.0e2, 'N': 2, 'check': 'A-stability', 'tol': None},\n        {'id': 3, 'lambda_val': -1.0e9, 'h': 1.0e-2, 'N': 1, 'check': 'L-stability', 'tol': 1.0e-6},\n        {'id': 4, 'lambda_val': 0.0, 'h': 10.0, 'N': 3, 'check': 'zero-boundary', 'tol': 1.0e-12},\n        {'id': 5, 'lambda_val': 0.5, 'h': 3.0, 'N': 5, 'check': 'A-stability', 'tol': None},\n        {'id': 6, 'lambda_val': -1.0e-12, 'h': 1.0e12, 'N': 4, 'check': 'A-stability', 'tol': None},\n    ]\n\n    results = []\n    y0 = 1.0\n\n    for case in test_cases:\n        lambda_val = case['lambda_val']\n        h = case['h']\n        N = case['N']\n        check_type = case['check']\n        tol = case['tol']\n\n        # The closed-form solution for y_N is y_0 * (1 / (1 - h*lambda))^N\n        # Let z = h*lambda, the stability function is R(z) = 1 / (1 - z)\n        # y_N = y_0 * R(z)^N\n        # Using standard Python floats (double precision) is sufficient for these values.\n        z = h * lambda_val\n        R = 1.0 / (1.0 - z)\n\n        result_bool = False\n        if check_type == 'A-stability':\n            # Check if |y_N| <= |y_0|\n            y_N = (R**N) * y0\n            result_bool = np.abs(y_N) <= np.abs(y0)\n        elif check_type == 'L-stability':\n            # Check if |y_1| / |y_0| <= tau_L\n            # For this case N is always 1\n            y_1 = R * y0\n            # Since y0=1.0, this simplifies to checking |y_1| <= tol\n            result_bool = np.abs(y_1) / np.abs(y0) <= tol\n        elif check_type == 'zero-boundary':\n            # Check if |y_N - y_0| <= tau_0\n            y_N = (R**N) * y0\n            result_bool = np.abs(y_N - y0) <= tol\n        \n        results.append(result_bool)\n\n    # Final print statement in the exact required format.\n    # The default string representation of a boolean in Python is 'True' or 'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2439069"}]}