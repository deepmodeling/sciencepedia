{"hands_on_practices": [{"introduction": "我们从一个代表阻尼振荡器的线性常微分方程（ODE）系统开始我们的实践之旅。这个练习的目标是揭示一个令人惊讶的基础性质，它将显式中点法和改进欧拉法应用于此类问题时联系起来。通过亲手实现并比较它们在求解线性自治系统 $y' = Ay$ 时的表现，您将验证一个重要的理论结论，并为理解这些方法的代数结构奠定坚实的基础。[@problem_id:2444104]", "problem": "考虑线性自治常微分方程（ODE）组 $y'(t) = A y(t)$，其中 $A$ 是一个常实 $2 \\times 2$ 矩阵，其特征值为具有负实部的复数，对应于一个欠阻尼振子。设初始条件为 $y(0) = y_0 \\in \\mathbb{R}^2$。其精确解为 $y(t) = \\exp(A t)\\, y_0$，其中 $\\exp(\\cdot)$ 表示矩阵指数。\n\n要求您针对几组参数集，在使用显式中点法和修正欧拉法，在步长为 $h$ 的均匀网格上对该系统进行数值积分时，计算在最终时刻 $T$ 的全局误差。全局误差定义为在 $t = T$ 时，数值解与精确解之差的欧几里得二范数。本问题不要求使用物理单位，并且所有角度（如果在您的内部推导中出现）均以弧度为单位。\n\n对于下文的每个测试用例，系统矩阵 $A$ 表示一个阻尼振子，其自然频率 $\\omega  0$ 和阻尼比 $\\zeta \\in (0,1)$ 由下式给出\n$$\nA(\\omega,\\zeta) = \\begin{bmatrix}\n0  1 \\\\\n-\\omega^2  -2 \\zeta \\omega\n\\end{bmatrix},\n$$\n初始条件为 $y_0 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$，并指定了最终时刻 $T$ 和步长 $h$。假定比率 $T/h$ 是一个正整数，从而总共进行 $N = T/h$ 个均匀步长的积分。\n\n对于每个测试用例，计算两个浮点数：\n- $E_{\\text{mid}}$：使用步长为 $h$ 的显式中点法进行 $N$ 步积分后，在 $t = T$ 时的全局误差。\n- $E_{\\text{mod}}$：使用步长为 $h$ 的修正欧拉法进行 $N$ 步积分后，在 $t = T$ 时的全局误差。\n\n使用欧几里得二范数计算误差。精确值 $y(T)$ 必须通过矩阵指数 $y(T) = \\exp(A T) y_0$ 来计算。将每个误差以浮点小数形式报告。\n\n测试套件：\n1. $(\\omega, \\zeta, T, h) = (5.0, 0.1, 2.0, 0.01)$\n2. $(\\omega, \\zeta, T, h) = (5.0, 0.1, 1.0, 0.2)$\n3. $(\\omega, \\zeta, T, h) = (10.0, 0.999, 0.5, 0.005)$\n4. $(\\omega, \\zeta, T, h) = (40.0, 0.2, 1.0, 0.002)$\n5. $(\\omega, \\zeta, T, h) = (5.0, 0.1, 2.0, 0.001)$\n\n最终输出格式：\n- 您的程序应产生一行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。该列表必须为每个测试用例包含一个条目，顺序与上文列表一致。每个条目本身必须是一个形式为 $[E_{\\text{mid}}, E_{\\text{mod}}]$ 的二元列表。例如，总的输出格式为\n`[[E_{\\text{mid}}^{(1)},E_{\\text{mod}}^{(1)}],[E_{\\text{mid}}^{(2)},E_{\\text{mod}}^{(2)}],...,[E_{\\text{mid}}^{(5)},E_{\\text{mod}}^{(5)}]]`，\n其中每个 $E_{\\text{mid}}^{(i)}$ 和 $E_{\\text{mod}}^{(i)}$ 都以十进制数报告。为了便于表示，可将每个数字四舍五入到十位小数。", "solution": "问题陈述已经过验证，并被确定是合理的。它有科学依据、是适定的、客观的，并包含获得唯一解所需的所有必要信息。该问题描述了一个经典的阻尼谐振子系统，并要求比较两种标准的数值积分方法。\n\n**解的推导**\n\n该问题要求对用于求解线性自治常微分方程（ODE）组的两种数值格式的全局误差进行比较：\n$$\n\\frac{dy}{dt} = A y(t), \\quad y(0) = y_0\n$$\n其中 $y(t) \\in \\mathbb{R}^2$ 且 $A \\in \\mathbb{R}^{2 \\times 2}$ 是一个常数矩阵。\n这两种数值方法是显式中点法和修正欧拉法。设 $y_n$ 是在时刻 $t_n = n h$ 时 $y(t_n)$ 的数值近似值。定义该 ODE 的函数是 $f(t,y) = A y$。由于该系统是自治的，$f$ 不显式依赖于 $t$。\n\n**1. 显式中点法**\n对于 ODE $y' = f(t,y)$，显式中点法的一般形式为：\n$$\nk_1 = f(t_n, y_n)\n$$\n$$\nk_2 = f(t_n + h/2, y_n + \\frac{h}{2} k_1)\n$$\n$$\ny_{n+1} = y_n + h k_2\n$$\n对于我们的线性系统，其中 $f(y) = A y$，其步骤变为：\n$$\nk_1 = A y_n\n$$\n$$\nk_2 = A \\left( y_n + \\frac{h}{2} (A y_n) \\right) = A y_n + \\frac{h}{2} A^2 y_n = \\left( A + \\frac{h}{2} A^2 \\right) y_n\n$$\n将 $k_2$ 代入 $y_{n+1}$ 的更新规则中：\n$$\ny_{n+1} = y_n + h \\left( A + \\frac{h}{2} A^2 \\right) y_n = \\left( I + h A + \\frac{h^2}{2} A^2 \\right) y_n\n$$\n因此，从一步到下一步的传播由放大矩阵 $M_{\\text{mid}} = I + h A + \\frac{h^2}{2} A^2$ 控制。\n\n**2. 修正欧拉法 (Heun 法)**\n修正欧拉法，也称为 Heun 法或显式梯形法则，其一般形式为：\n$$\nk_1 = f(t_n, y_n)\n$$\n$$\nk_2 = f(t_n + h, y_n + h k_1)\n$$\n$$\ny_{n+1} = y_n + \\frac{h}{2} (k_1 + k_2)\n$$\n对于我们的线性系统，其中 $f(y) = A y$:\n$$\nk_1 = A y_n\n$$\n$$\nk_2 = A (y_n + h (A y_n)) = A y_n + h A^2 y_n = (A + h A^2) y_n\n$$\n将 $k_1$ 和 $k_2$ 代入 $y_{n+1}$ 的更新规则中:\n$$\ny_{n+1} = y_n + \\frac{h}{2} \\left( A y_n + (A + h A^2) y_n \\right) = y_n + \\frac{h}{2} (2 A y_n + h A^2 y_n)\n$$\n$$\ny_{n+1} = y_n + h A y_n + \\frac{h^2}{2} A^2 y_n = \\left( I + h A + \\frac{h^2}{2} A^2 \\right) y_n\n$$\n此方法的放大矩阵为 $M_{\\text{mod}} = I + h A + \\frac{h^2}{2} A^2$。\n\n**关于方法等价性的结论**\n对于线性自治 ODE 系统 $y' = A y$，显式中点法和修正欧拉法在数学上是等价的。两种方法产生相同的近似序列 $y_n$，因为它们的放大矩阵是相同的：\n$$\nM_{\\text{mid}} = M_{\\text{mod}} = I + h A + \\frac{h^2}{2} A^2\n$$\n该矩阵是精确单步传播子 $\\exp(hA)$ 的泰勒级数展开式，并截断至二阶。因此，两种方法在最终时刻 $T$ 的全局误差必须相同，即 $E_{\\text{mid}} = E_{\\text{mod}}$。\n\n**误差计算算法**\n对于每个测试用例 $(\\omega, \\zeta, T, h)：$\n1. 构造矩阵 $A$：\n   $$\n   A = \\begin{bmatrix}\n   0  1 \\\\\n   -\\omega^2  -2 \\zeta \\omega\n   \\end{bmatrix}\n   $$\n2.  定义初始条件 $y_0 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$。\n3.  计算步数 $N = T/h$，根据问题陈述，该值必须为整数。\n4.  计算在 $t = T$ 时的精确解。该初值问题的精确解为 $y(t) = \\exp(At) y_0$。在最终时刻 $T$，解为：\n   $$\n   y_{\\text{exact}} = \\exp(A T) y_0\n   $$\n   矩阵指数 $\\exp(A T)$ 将使用高精度库函数计算。\n5.  计算在 $t = T$ 时的数值解。设 $M = I + h A + \\frac{h^2}{2} A^2$ 为放大矩阵。经过 $N$ 步后，数值解为：\n   $$\n   y_{\\text{num}} = M^N y_0\n   $$\n   矩阵幂 $M^N$ 将被高效地计算。\n6.  计算全局误差。误差是数值解与精确解之差的欧几里得范数：\n   $$\n   E = \\| y_{\\text{num}} - y_{\\text{exact}} \\|_2\n   $$\n7.  由于两种方法是等价的，我们设定 $E_{\\text{mid}} = E$ 且 $E_{\\text{mod}} = E$。对所有五个测试用例重复此过程。\n\n该实现将使用 `numpy` 进行矩阵运算，并使用 `scipy.linalg.expm` 计算矩阵指数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Computes the global error for two numerical methods on an ODE system\n    representing a damped oscillator.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (omega, zeta, T, h)\n    test_cases = [\n        (5.0, 0.1, 2.0, 0.01),\n        (5.0, 0.1, 1.0, 0.2),\n        (10.0, 0.999, 0.5, 0.005),\n        (40.0, 0.2, 1.0, 0.002),\n        (5.0, 0.1, 2.0, 0.001)\n    ]\n\n    all_results = []\n    for case in test_cases:\n        omega, zeta, T, h = case\n\n        # Construct the system matrix A\n        A = np.array([\n            [0.0, 1.0],\n            [-omega**2, -2.0 * zeta * omega]\n        ])\n\n        # Initial condition\n        y0 = np.array([1.0, 0.0])\n\n        # Number of steps N (guaranteed to be integer)\n        N = int(T / h)\n\n        # 1. Exact solution using matrix exponential\n        # y(T) = exp(A*T) * y0\n        y_exact_T = expm(A * T) @ y0\n\n        # 2. Numerical solution\n        # For a linear autonomous system y' = Ay, both the explicit midpoint\n        # and modified Euler methods use the same amplification matrix:\n        # M = I + hA + (h^2/2)A^2\n        I = np.identity(2)\n        A_squared = A @ A\n        M = I + h * A + (h**2 / 2.0) * A_squared\n\n        # The solution at T is y_N = M^N * y0\n        # np.linalg.matrix_power is efficient for this\n        y_numerical_T = np.linalg.matrix_power(M, N) @ y0\n\n        # 3. Global error calculation\n        # Error is the Euclidean 2-norm of the difference\n        error = np.linalg.norm(y_numerical_T - y_exact_T)\n\n        # Since E_mid and E_mod are identical for this problem, they are both equal to 'error'.\n        E_mid = error\n        E_mod = error\n        \n        all_results.append([E_mid, E_mod])\n\n    # Final print statement in the exact required format.\n    # Example format: [[E_mid^(1),E_mod^(1)],[E_mid^(2),E_mod^(2)],...]\n    formatted_results = []\n    for res_pair in all_results:\n        # The problem states it is acceptable to round to 10 decimal places.\n        formatted_pair_str = f\"[{res_pair[0]:.10f}, {res_pair[1]:.10f}]\"\n        formatted_results.append(formatted_pair_str)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2444104"}, {"introduction": "在了解了这两种方法在线性系统上的表现之后，我们现在转向一个更真实、更具挑战性的非线性问题：单摆模型。这个实践要求您为一个非线性系统实现显式中点法和改进欧拉法，并通过计算一个可测量的物理量——振荡周期——来比较它们的精度。这个练习将帮助您把理论知识应用到具体的物理仿真中，体验数值方法在解决现实世界工程问题中的力量。[@problem_id:2444127]", "problem": "考虑一个长度为 $L$ 的单平面摆在均匀重力 $g$ 作用下的非线性常微分方程 (ODE) 初值问题：\n$$\n\\theta''(t) \\;=\\; -\\frac{g}{L}\\,\\sin\\big(\\theta(t)\\big), \\quad \\theta(0) \\;=\\; \\theta_0,\\quad \\theta'(0) \\;=\\; 0,\n$$\n其中 $\\theta(t)$ 是以弧度为单位的角位移。引入状态向量 $\\mathbf{y}(t) = \\begin{bmatrix}\\theta(t) \\\\ \\omega(t)\\end{bmatrix}$，其中 $\\omega(t) = \\theta'(t)$，并将该二阶 ODE 重写为一阶系统\n$$\n\\mathbf{y}'(t) \\;=\\; \\mathbf{f}(t,\\mathbf{y}) \\;=\\; \\begin{bmatrix}\\omega \\\\ -\\dfrac{g}{L}\\sin(\\theta) \\end{bmatrix}.\n$$\n你的任务是实现两种二阶、显式、两阶段的 Runge–Kutta (RK) 方法——显式中点法和改进欧拉法（也称为 Heun 方法）——来近似大振幅摆动的完整振荡周期，并将计算出的周期与理论值进行比较。\n\n你可以假定以下基本知识为已知：ODE 初值问题的定义、通过匹配到二阶的泰勒展开式推导出的单步法的概念，以及用第一类完全椭圆积分表示的非线性摆的已知理论周期。具体来说，振幅为 $\\theta_0$ 时的理论周期是\n$$\nT_{\\mathrm{th}}(\\theta_0;L,g) \\;=\\; 4\\sqrt{\\frac{L}{g}}\\,K\\!\\Big(m\\Big),\\quad m \\;=\\; \\sin^2\\!\\Big(\\frac{\\theta_0}{2}\\Big),\n$$\n其中第一类完全椭圆积分为\n$$\nK(m) \\;=\\; \\int_{0}^{\\pi/2} \\frac{1}{\\sqrt{1 - m\\sin^2\\phi}}\\; d\\phi.\n$$\n\n算法任务：\n- 为一阶系统 $\\mathbf{y}'=\\mathbf{f}(t,\\mathbf{y})$ 实现显式中点法和改进欧拉法。\n- 对于每种方法，给定 $(\\theta_0,L,g)$ 和一个固定的时间步长 $h$，从 $t=0$ 开始在时间上向前进行数值积分，直到可以稳健地估计出从 $\\theta(0)=\\theta_0$ 静止开始的振荡周期 $T_{\\mathrm{num}}$。使用以下稳健规则：检测 $t0$ 后 $\\omega(t)$ 的前两个过零点（即 $\\omega$ 改变符号的时刻），在步长内进行时间上的线性插值来估计这些过零时刻 $t_1$ 和 $t_2$，然后将完整周期估计为\n$$\nT_{\\mathrm{num}} \\;=\\; 2\\,(t_2 - t_1).\n$$\n- 对于每种方法，计算绝对相对误差\n$$\n\\varepsilon \\;=\\; \\frac{\\left|T_{\\mathrm{num}} - T_{\\mathrm{th}}\\right|}{T_{\\mathrm{th}}}\n$$\n结果为无量纲小数。\n\n角度必须以弧度为单位，长度以米为单位，重力加速度以米/秒²为单位，时间以秒为单位。所有输出必须以十进制数报告。不得使用百分号；如果您希望表达类似百分比的数值，请以小数形式报告。\n\n测试套件：\n使用以下5组参数 $(\\theta_0,h,L,g)$，这些参数组的选择旨在探测典型和具挑战性的情况，包括大振幅和较粗的时间步长：\n- 情况 1：$(\\theta_0,h,L,g) = (1.2,\\; 0.01,\\; 1.0,\\; 9.81)$.\n- 情况 2：$(\\theta_0,h,L,g) = (2.8,\\; 0.01,\\; 1.0,\\; 9.81)$.\n- 情况 3：$(\\theta_0,h,L,g) = (2.8,\\; 0.05,\\; 1.0,\\; 9.81)$.\n- 情况 4：$(\\theta_0,h,L,g) = (0.1,\\; 0.02,\\; 1.0,\\; 9.81)$.\n- 情况 5：$(\\theta_0,h,L,g) = (3.0,\\; 0.005,\\; 1.0,\\; 9.81)$.\n\n对于每种情况，您必须计算两个数：显式中点法的绝对相对误差和改进欧拉法的绝对相对误差，每个数都四舍五入到8位小数。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个由逗号分隔的5个方括号对组成的列表，每个方括号对按 $[\\varepsilon_{\\text{midpoint}},\\varepsilon_{\\text{modified\\_Euler}}]$ 的顺序排列，所有内容都包含在一个外层方括号中。例如，使用占位符数字的语法正确的输出如下所示\n`[[0.00000000,0.00000000],[0.00000000,0.00000000],[0.00000000,0.00000000],[0.00000000,0.00000000],[0.00000000,0.00000000]]`。\n您的程序必须严格遵循指定的测试套件，并且只打印这一行输出。不允许用户输入。所提供的代码必须是完整且可运行的。", "solution": "对所述问题进行验证。\n\n**步骤 1：提取已知信息**\n\n问题提供了以下信息：\n- 单平面摆的控制二阶常微分方程 (ODE)：\n$$\n\\theta''(t) \\;=\\; -\\frac{g}{L}\\,\\sin\\big(\\theta(t)\\big)\n$$\n- 初始条件：\n$$\n\\theta(0) \\;=\\; \\theta_0,\\quad \\theta'(0) \\;=\\; 0\n$$\n- 状态向量定义 $\\mathbf{y}(t) = \\begin{bmatrix}\\theta(t) \\\\ \\omega(t)\\end{bmatrix}$，其中 $\\omega(t) = \\theta'(t)$。\n- 等效的一阶 ODE 系统：\n$$\n\\mathbf{y}'(t) \\;=\\; \\mathbf{f}(t,\\mathbf{y}) \\;=\\; \\begin{bmatrix}\\omega \\\\ -\\dfrac{g}{L}\\sin(\\theta) \\end{bmatrix}\n$$\n- 振幅为 $\\theta_0$ 时的理论周期 $T_{\\mathrm{th}}$：\n$$\nT_{\\mathrm{th}}(\\theta_0;L,g) \\;=\\; 4\\sqrt{\\frac{L}{g}}\\,K\\!\\Big(m\\Big),\\quad m \\;=\\; \\sin^2\\!\\Big(\\frac{\\theta_0}{2}\\Big)\n$$\n- 第一类完全椭圆积分的定义：\n$$\nK(m) \\;=\\; \\int_{0}^{\\pi/2} \\frac{1}{\\sqrt{1 - m\\sin^2\\phi}}\\; d\\phi\n$$\n- 数值任务涉及两种特定的二阶 Runge-Kutta 方法：显式中点法和改进欧拉法 (Heun 方法)。\n- 数值估算周期 $T_{\\mathrm{num}}$ 的规则：通过线性插值找到 $t  0$ 时 $\\omega(t)$ 的前两个过零点 $t_1$ 和 $t_2$，并计算 $T_{\\mathrm{num}} = 2(t_2 - t_1)$。\n- 绝对相对误差的定义：\n$$\n\\varepsilon \\;=\\; \\frac{\\left|T_{\\mathrm{num}} - T_{\\mathrm{th}}\\right|}{T_{\\mathrm{th}}}\n$$\n- 提供了五个测试用例，形式为 $(\\theta_0, h, L, g)$ 的元组：\n1. $(1.2, 0.01, 1.0, 9.81)$\n2. $(2.8, 0.01, 1.0, 9.81)$\n3. $(2.8, 0.05, 1.0, 9.81)$\n4. $(0.1, 0.02, 1.0, 9.81)$\n5. $(3.0, 0.005, 1.0, 9.81)$\n- 要求的输出格式是误差对列表的特定字符串表示。\n\n**步骤 2：使用提取的已知信息进行验证**\n\n根据验证标准对问题进行评估。\n- **科学依据**：该问题基于经典力学（单摆）和数值分析（Runge-Kutta 方法）的原理。控制方程、其一阶表示形式以及周期的解析公式都是物理学和数学中的标准且正确的结果。\n- **适定性**：该问题是一个适定的初值问题。函数 $\\mathbf{f}(t, \\mathbf{y})$ 是连续可微的，这保证了解的存在性和唯一性。计算数值周期及其误差的任务定义清晰，对于给定的方法和步长会产生唯一的结果。\n- **客观性**：问题以精确、形式化和客观的数学语言陈述。\n- **缺陷分析**：\n    1.  **科学或事实不健全**：无。物理和数学原理是正确的。\n    2.  **非形式化或不相关**：无。该问题是数值方法在计算工程中的直接和具体应用。\n    3.  **不完整或矛盾的设置**：无。所有必要组件均已提供：模型、方法、分析步骤和测试数据。\n    4.  **不切实际或不可行**：无。物理参数和初始条件是现实的。初始振幅虽然较大，但在物理上是可达到的（小于在 $\\theta = \\pi$ 处的不稳定平衡点）。\n    5.  **不适定或结构不良**：无。指令是明确的。确定数值周期的方法是稳健的。\n    6.  **超出科学可验证性范围**：无。结果是可通过计算验证的。\n\n**步骤 3：结论与行动**\n\n该问题是 **有效的**。有必要提供完整解答。\n\n问题的核心是使用两种不同的数值方案求解一阶系统 $\\mathbf{y}' = \\mathbf{f}(t, \\mathbf{y})$ 的初值问题。状态向量为 $\\mathbf{y} = [\\theta, \\omega]^T$。一个通用的单步法将解从时间 $t_n$推进到 $t_{n+1} = t_n + h$，其形式为 $\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\Phi(t_n, \\mathbf{y}_n, h; \\mathbf{f})$，其中 $\\Phi$ 是增量函数。\n\n首先，我们定义所需的两种二阶、两阶段的 Runge-Kutta 方法。\n\n1.  **显式中点法**：通过在时间间隔的中点处评估导数来计算增量，其中使用前向欧拉步来估计该中点处的状态。\n    更新规则是：\n    $$\n    \\mathbf{k}_1 = \\mathbf{f}(t_n, \\mathbf{y}_n)\n    $$\n    $$\n    \\mathbf{k}_2 = \\mathbf{f}\\left(t_n + \\frac{h}{2}, \\mathbf{y}_n + \\frac{h}{2}\\mathbf{k}_1\\right)\n    $$\n    $$\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + h\\mathbf{k}_2\n    $$\n\n2.  **改进欧拉法 (Heun's Method)**：这是一种预测-校正方法。使用前向欧拉法对 $\\mathbf{y}_{n+1}$ 进行初步预测（预测步），并利用此预测值来估计区间末端的斜率。最终的更新步骤对区间起点和终点的斜率进行平均（校正步）。\n    更新规则是：\n    $$\n    \\mathbf{k}_1 = \\mathbf{f}(t_n, \\mathbf{y}_n)\n    $$\n    $$\n    \\mathbf{k}_2 = \\mathbf{f}(t_n + h, \\mathbf{y}_n + h\\mathbf{k}_1)\n    $$\n    $$\n    \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{2}(\\mathbf{k}_1 + \\mathbf{k}_2)\n    $$\n\n为了评估这些方法的准确性，我们必须将数值计算的振荡周期 $T_{\\mathrm{num}}$ 与理论周期 $T_{\\mathrm{th}}$ 进行比较。\n\n理论周期 $T_{\\mathrm{th}}$ 由包含第一类完全椭圆积分 $K(m)$ 的公式给出：\n$$\nT_{\\mathrm{th}} = 4\\sqrt{\\frac{L}{g}}\\,K(m), \\quad \\text{其中} \\quad m = \\sin^2\\left(\\frac{\\theta_0}{2}\\right)\n$$\n该积分必须进行数值计算，可以使用标准的库函数来完成。\n\n数值周期 $T_{\\mathrm{num}}$ 是通过追踪角速度 $\\omega(t)$ 来确定的。摆锤从其最大位移处静止开始运动，因此 $\\omega(0) = 0$。在 $t  0$ 时，$\\omega(t)$ 第一次回到零的位置是在相对的转折点，对应半个周期 ($t_1 \\approx T/2$)。第二次回到零的位置是在完成一个完整周期时 ($t_2 \\approx T$)。问题指定了稳健的估计公式 $T_{\\mathrm{num}} = 2(t_2 - t_1)$，如果 $t_1=T/2$ 且 $t_2=T$，该公式可以正确地计算出 $T$。\n为了找到过零时刻 $t_1$ 和 $t_2$，我们迭代数值方法并监控角速度分量 $\\omega_n$ 的符号。如果在时间步 $t_n$ 和 $t_{n+1}$ 之间 $\\omega_n \\cdot \\omega_{n+1}  0$，则发生了一次过零。然后使用在点 $(t_n, \\omega_n)$ 和 $(t_{n+1}, \\omega_{n+1})$ 之间的线性插值来估计精确的过零时刻 $t_{\\text{cross}}$：\n$$\nt_{\\text{cross}} = t_n - \\omega_n \\frac{t_{n+1} - t_n}{\\omega_{n+1} - \\omega_n} = t_n - \\omega_n \\frac{h}{\\omega_{n+1}-\\omega_n}\n$$\n在 $t  0$ 时找到的前两个此类过零时刻将是 $t_1$ 和 $t_2$。\n\n最后，对于每种方法和每个测试用例，绝对相对误差 $\\varepsilon$ 的计算方式如下：\n$$\n\\varepsilon = \\frac{|T_{\\mathrm{num}} - T_{\\mathrm{th}}|}{T_{\\mathrm{th}}}\n$$\n\n对于每个测试用例 $(\\theta_0, h, L, g)$ 的总体算法如下：\n1.  使用提供的公式和高精度的椭圆积分值计算 $T_{\\mathrm{th}}$。\n2.  对于每种数值方法（显式中点法和改进欧拉法）：\n    a. 初始化状态 $\\mathbf{y}_0 = [\\theta_0, 0]^T$、时间 $t_0 = 0$ 以及一个用于存储过零时刻的空列表。\n    b. 重复应用方法的更新规则在时间上向前步进，$\\mathbf{y}_{n+1} = \\text{step}(\\mathbf{y}_n)$。\n    c. 在每一步，检查 $\\omega(t)$ 是否过零。如果检测到过零，使用线性插值计算 $t_{\\text{cross}}$ 并记录下来。\n    d. 继续执行直到记录下两个过零时刻 $t_1$ 和 $t_2$。\n    e. 计算 $T_{\\mathrm{num}} = 2(t_2 - t_1)$。\n    f. 计算误差 $\\varepsilon$。\n3.  存储该测试用例的误差对 $[\\varepsilon_{\\text{midpoint}}, \\varepsilon_{\\text{modified\\_Euler}}]$。\n4.  处理完所有测试用例后，将结果格式化为指定的字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import ellipk\n\ndef solve():\n    \"\"\"\n    Solves the pendulum problem for the given test suite, calculating the\n    relative error in the period for two numerical methods.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (theta0, h, L, g)\n        (1.2, 0.01, 1.0, 9.81),\n        (2.8, 0.01, 1.0, 9.81),\n        (2.8, 0.05, 1.0, 9.81),\n        (0.1, 0.02, 1.0, 9.81),\n        (3.0, 0.005, 1.0, 9.81),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        theta0, h, L, g = case\n        \n        # --- Define the ODE system ---\n        def f_ode(t, y, g_val, L_val):\n            \"\"\"\n            Represents the first-order system y' = f(t, y).\n            y = [theta, omega]\n            y' = [omega, -g/L * sin(theta)]\n            \"\"\"\n            theta, omega = y\n            return np.array([omega, -(g_val / L_val) * np.sin(theta)])\n\n        # --- Define the numerical methods ---\n        def explicit_midpoint_step(f, t, y, h_step, g_val, L_val):\n            k1 = f(t, y, g_val, L_val)\n            k2 = f(t + h_step / 2.0, y + (h_step / 2.0) * k1, g_val, L_val)\n            y_next = y + h_step * k2\n            return y_next\n\n        def modified_euler_step(f, t, y, h_step, g_val, L_val):\n            k1 = f(t, y, g_val, L_val)\n            k2 = f(t + h_step, y + h_step * k1, g_val, L_val)\n            y_next = y + (h_step / 2.0) * (k1 + k2)\n            return y_next\n            \n        # --- Function to compute numerical period ---\n        def compute_numerical_period(step_func, y0_val, h_step, g_val, L_val):\n            t = 0.0\n            y = np.copy(y0_val)\n            \n            crossing_times = []\n            max_steps = int(2.0 * (4 * np.sqrt(L_val/g_val) * 10) / h_step) # Generous max steps\n\n            # We need to find the first two zero crossings of omega for t  0\n            for i in range(max_steps):\n                y_prev = np.copy(y)\n                t_prev = t\n                \n                y = step_func(f_ode, t, y, h_step, g_val, L_val)\n                t = t + h_step\n\n                omega_prev = y_prev[1]\n                omega_curr = y[1]\n\n                # Check for sign change in omega; omega(0)=0 so let's start checking after first step\n                if omega_prev * omega_curr  0.0:\n                    # Linear interpolation to find the zero-crossing time\n                    t_cross = t_prev - omega_prev * h_step / (omega_curr - omega_prev)\n                    crossing_times.append(t_cross)\n                    \n                    if len(crossing_times) == 2:\n                        break\n            \n            if len(crossing_times)  2:\n                # Should not happen with well-chosen max_steps\n                return -1.0 \n            \n            t1, t2 = crossing_times\n            T_num = 2.0 * (t2 - t1)\n            return T_num\n\n        # --- Function to compute theoretical period ---\n        def compute_theoretical_period(theta0_val, L_val, g_val):\n            m = np.sin(theta0_val / 2.0)**2\n            K_m = ellipk(m)\n            T_th = 4.0 * np.sqrt(L_val / g_val) * K_m\n            return T_th\n\n        # --- Main calculation for the case ---\n        case_results = []\n        y0 = np.array([theta0, 0.0])\n        T_th = compute_theoretical_period(theta0, L, g)\n        \n        methods = [explicit_midpoint_step, modified_euler_step]\n        \n        for method in methods:\n            T_num = compute_numerical_period(method, y0, h, g, L)\n            rel_error = np.abs(T_num - T_th) / T_th\n            case_results.append(f\"{rel_error:.8f}\")\n\n        all_results.append(f\"[{','.join(case_results)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2444127"}, {"introduction": "最后的这个实践将我们的视野从局部精度转向长期积分的定性行为。通过模拟经典的 Lotka-Volterra 捕食者-猎物模型——一个拥有守恒量的系统——我们将观察到这些显式数值方法在长时间积分后如何处理（或无法处理）这样的不变量。这个练习引入了“数值漂移”这一关键概念，并揭示了它在评估长期仿真稳定性和保真度方面的重要性。[@problem_id:2444171]", "problem": "考虑一个二维的 Lotka–Volterra 捕食者-猎物系统，该系统被描述为一个常微分方程 (ODE) 的初值问题：\n$$\n\\begin{cases}\n\\dfrac{\\mathrm{d}x}{\\mathrm{d}t} = \\alpha x - \\beta x y,\n\\\\\n\\dfrac{\\mathrm{d}y}{\\mathrm{d}t} = -\\gamma y + \\delta x y,\n\\end{cases}\n\\quad\n(x(0),y(0)) = (x_0,y_0),\n$$\n其中 $\\alpha0$, $\\beta0$, $\\gamma0$, $\\delta0$，且 $(x(t),y(t))$ 分别表示猎物和捕食者的种群数量。对于连续系统，具有正初始数据的非平凡轨迹保持在唯一的正平衡点\n$$\n(x^\\ast,y^\\ast) = \\left(\\dfrac{\\gamma}{\\delta}, \\dfrac{\\alpha}{\\beta}\\right)\n$$\n周围的闭合水平集上。\n定义该系统的一个不变量候选项（首次积分）为\n$$\nH(x,y) = \\delta x - \\gamma \\ln x + \\beta y - \\alpha \\ln y,\n$$\n对于 $x0$，$y0$，该量沿着精确解是恒定的。您将数值近似计算轨迹，并通过检查 $H$ 的变化来判断离散轨迹是形成闭合环路，还是向内/向外呈螺旋状。\n\n您的任务是编写一个完整的程序，对每个测试用例，使用以下两种不同的两阶 Runge–Kutta (RK) 方法之一来推进系统：显式中点法或改进的 Euler 法（Heun 法）。对于给定的时间步长 $h0$ 和一个表示标称振荡周期的正整数 $P$，积分总时间 $T_{\\text{int}}$，定义为\n$$\nT_{\\text{int}} = P \\cdot \\dfrac{2\\pi}{\\sqrt{\\alpha \\gamma}},\n$$\n并使用 $N = \\left\\lfloor \\dfrac{T_{\\text{int}}}{h} + \\tfrac{1}{2}\\right\\rfloor$ 个大小为 $h$ 的时间步来覆盖此区间。令 $H_0 = H(x_0,y_0)$ 和 $H_N = H(x_N,y_N)$ 分别表示数值轨迹开始和结束时 $H$ 的值。\n\n分类规则：定义相对漂移\n$$\n\\rho = \\dfrac{H_N - H_0}{|H_0|}.\n$$\n使用容差 $\\tau = 0.01$（以小数表示），对每个测试用例的轨迹进行如下分类：\n- 如果 $|\\rho| \\le \\tau$，则为闭合环路，编码为整数 $0$，\n- 如果 $\\rho  \\tau$，则为向外螺旋，编码为整数 $1$，\n- 如果 $\\rho  -\\tau$，则为向内螺旋，编码为整数 $-1$。\n\n您的程序必须分别实现这两种方法，并为每个测试用例应用指定的方法。\n\n测试套件：您的程序必须计算以下四个测试用例的分类。每个案例是一个形式为 $(m,\\alpha,\\beta,\\gamma,\\delta,x_0,y_0,h,P)$ 的元组，其中 $m$ 选择方法（$m=0$ 为显式中点法，$m=1$ 为改进的 Euler 法）。\n- 案例 1：$(0,\\,1,\\,1,\\,1,\\,1,\\,1.2,\\,0.8,\\,0.05,\\,30)$。\n- 案例 2：$(1,\\,1,\\,1,\\,1,\\,1,\\,1.2,\\,0.8,\\,0.05,\\,30)$。\n- 案例 3：$(0,\\,1,\\,1,\\,1,\\,1,\\,1.5,\\,0.6,\\,0.2,\\,30)$。\n- 案例 4：$(1,\\,1,\\,1,\\,1,\\,1,\\,1.5,\\,0.6,\\,0.2,\\,30)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含四个案例的整数分类，以逗号分隔，并用方括号括起来，顺序与上述案例一致。例如，一个语法上有效的格式是像 `[rA,rB,rC,rD]` 这样的一行，其中 rA、rB、rC、rD 均为 $-1$、 $0$ 或 $1$ 之一。", "solution": "问题陈述是有效的。这是一个来自计算工程领域的适定初值问题，其基础是数学生物学和数值分析的既定原理。所有参数、条件和方法都得到了清晰明确的定义。\n\n该问题围绕 Lotka–Volterra 捕食者-猎物模型的数值积分展开，该模型是一个由两个耦合的一阶非线性常微分方程 (ODE) 组成的系统：\n$$\n\\frac{\\mathrm{d}x}{\\mathrm{d}t} = f_x(x,y) = \\alpha x - \\beta x y\n$$\n$$\n\\frac{\\mathrm{d}y}{\\mathrm{d}t} = f_y(x,y) = -\\gamma y + \\delta x y\n$$\n这里，$x(t)$ 是猎物种群，$y(t)$ 是捕食者种群，参数 $\\alpha, \\beta, \\gamma, \\delta$ 是正常数。系统的初始状态由 $(x(0), y(0)) = (x_0, y_0)$ 给出。\n\n精确连续系统的一个显著特征是存在一个守恒量，或称首次积分，由下式给出：\n$$\nH(x,y) = \\delta x - \\gamma \\ln x + \\beta y - \\alpha \\ln y\n$$\n在任何 $x0$ 和 $y0$ 的精确解轨迹上，$H(x(t), y(t))$ 的值保持不变。这意味着解的轨迹是在 $(x,y)$ 相空间中函数 $H$ 的闭合水平集曲线，代表了周期性的种群循环。\n\n数值方法作为离散近似，通常无法精确地保持这类不变量。累积的误差会导致数值轨迹或者向外螺旋（以 $H$ 衡量是“能量”增加），或者向内螺旋（“能量”损失）。这种现象被称为数值漂移。在积分区间内 $H$ 变化的符号和大小为数值解的长期定性行为提供了定量的诊断依据。\n\n该任务要求实现两个不同的二阶 Runge–Kutta (RK) 方法，以将解从初始状态 $\\mathbf{u}_n = [x_n, y_n]^T$ 推进到下一个状态 $\\mathbf{u}_{n+1}$，步长为 $h$。该 ODE 以向量形式表示为 $\\frac{\\mathrm{d}\\mathbf{u}}{\\mathrm{d}t} = \\mathbf{f}(\\mathbf{u})$。\n\n第一种方法 ($m=0$) 是**显式中点法**。其公式为：\n$1$. 计算起点的斜率：\n$$\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{u}_n)\n$$\n$2$. 使用 $\\mathbf{k}_1$ 估计时间区间中点的状态，并计算该点的斜率：\n$$\n\\mathbf{k}_2 = \\mathbf{f}\\left(\\mathbf{u}_n + \\frac{h}{2}\\mathbf{k}_1\\right)\n$$\n$3$. 使用中点斜率 $\\mathbf{k}_2$ 更新状态：\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + h \\mathbf{k}_2\n$$\n\n第二种方法 ($m=1$) 是**改进的 Euler 法**（也称为 Heun 法）：\n$1$. 计算起点的斜率：\n$$\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{u}_n)\n$$\n$2$. 使用 $\\mathbf{k}_1$ 进行一个完整的初步步骤（预测步），并计算此预测点的斜率：\n$$\n\\mathbf{k}_2 = \\mathbf{f}\\left(\\mathbf{u}_n + h \\mathbf{k}_1\\right)\n$$\n$3$. 使用初始斜率和预测斜率的平均值（校正步）来更新状态：\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\frac{h}{2}(\\mathbf{k}_1 + \\mathbf{k}_2)\n$$\n\n对于每个测试用例，模拟过程如下：\n$1$. 总积分时间 $T_{\\text{int}}$ 由 $P$ 个线性化系统的标称周期决定，$T_{\\text{int}} = P \\cdot \\frac{2\\pi}{\\sqrt{\\alpha\\gamma}}$。\n$2$. 步数 $N$通过对总时间与步长之比进行四舍五入计算得出：$N = \\left\\lfloor \\frac{T_{\\text{int}}}{h} + \\frac{1}{2}\\right\\rfloor$。\n$3$. 计算不变量的初始值 $H_0 = H(x_0, y_0)$。\n$4$. 应用选定的数值积分器进行 $N$ 步运算，以找到最终状态 $(x_N, y_N)$。\n$5$. 计算最终不变量值 $H_N = H(x_N, y_N)$。\n$6$. 计算相对漂移 $\\rho = \\frac{H_N - H_0}{|H_0|}$。\n$7$. 根据 $\\rho$ 相对于容差 $\\tau = 0.01$ 的值对轨迹进行分类：\n    - **闭合环路（代码 $0$）：** 如果 $|\\rho| \\le \\tau$，则认为漂移可以忽略不计。\n    - **向外螺旋（代码 $1$）：** 如果 $\\rho  \\tau$，则数值能量显著增加。\n    - **向内螺旋（代码 $-1$）：** 如果 $\\rho  -\\tau$，则数值能量显著减少。\n\n实现过程将把此逻辑应用于四个指定的测试用例，具体方法由参数 $m$ 选择。最终输出由每个测试用例的整数分类代码组成。", "answer": "```python\n# The complete and runnable Python 3  code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Lotka-Volterra problem for four test cases, classifies trajectory\n    behavior by analyzing the drift of a system invariant.\n    \"\"\"\n\n    def lotka_volterra_rhs(u, alpha, beta, gamma, delta):\n        \"\"\"\n        Computes the right-hand side of the Lotka-Volterra ODE system.\n        u: state vector [x, y]\n        alpha, beta, gamma, delta: system parameters\n        \"\"\"\n        x, y = u\n        dxdt = alpha * x - beta * x * y\n        dydt = -gamma * y + delta * x * y\n        return np.array([dxdt, dydt])\n\n    def invariant_H(u, alpha, beta, gamma, delta):\n        \"\"\"\n        Computes the invariant (first integral) H of the Lotka-Volterra system.\n        u: state vector [x, y]\n        alpha, beta, gamma, delta: system parameters\n        \"\"\"\n        x, y = u\n        # The problem statement ensures x  0 and y  0 for initial conditions.\n        # Trajectories of the LV system do not cross the axes.\n        return delta * x - gamma * np.log(x) + beta * y - alpha * np.log(y)\n\n    def explicit_midpoint_step(u_n, h, f_rhs, params):\n        \"\"\"\n        Performs a single step of the explicit midpoint method.\n        u_n: current state vector\n        h: time step\n        f_rhs: function for the ODE's right-hand side\n        params: tuple of system parameters (alpha, beta, gamma, delta)\n        \"\"\"\n        k1 = f_rhs(u_n, *params)\n        k2 = f_rhs(u_n + 0.5 * h * k1, *params)\n        u_n1 = u_n + h * k2\n        return u_n1\n\n    def modified_euler_step(u_n, h, f_rhs, params):\n        \"\"\"\n        Performs a single step of the modified Euler (Heun's) method.\n        u_n: current state vector\n        h: time step\n        f_rhs: function for the ODE's right-hand side\n        params: tuple of system parameters (alpha, beta, gamma, delta)\n        \"\"\"\n        k1 = f_rhs(u_n, *params)\n        k2 = f_rhs(u_n + h * k1, *params)\n        u_n1 = u_n + 0.5 * h * (k1 + k2)\n        return u_n1\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (m, alpha, beta, gamma, delta, x0, y0, h, P)\n        # m=0: explicit midpoint, m=1: modified Euler\n        (0, 1.0, 1.0, 1.0, 1.0, 1.2, 0.8, 0.05, 30),\n        (1, 1.0, 1.0, 1.0, 1.0, 1.2, 0.8, 0.05, 30),\n        (0, 1.0, 1.0, 1.0, 1.0, 1.5, 0.6, 0.2, 30),\n        (1, 1.0, 1.0, 1.0, 1.0, 1.5, 0.6, 0.2, 30),\n    ]\n\n    results = []\n    tau = 0.01  # Tolerance for classification\n\n    for case in test_cases:\n        m, alpha, beta, gamma, delta, x0, y0, h, P = case\n        \n        params = (alpha, beta, gamma, delta)\n        \n        # Set initial state vector\n        u_0 = np.array([x0, y0])\n        \n        # Calculate total integration time and number of steps\n        T_int = P * 2 * np.pi / np.sqrt(alpha * gamma)\n        # N = floor(T_int/h + 1/2) as per problem statement\n        N = int(T_int / h + 0.5)\n        \n        # Compute initial value of the invariant\n        H_0 = invariant_H(u_0, alpha, beta, gamma, delta)\n        \n        # Select the numerical method based on m\n        if m == 0:\n            stepper = explicit_midpoint_step\n        else:  # m == 1\n            stepper = modified_euler_step\n            \n        # Perform the numerical integration\n        u_current = u_0\n        for _ in range(N):\n            u_current = stepper(u_current, h, lotka_volterra_rhs, params)\n        u_N = u_current\n        \n        # Compute final value of the invariant\n        H_N = invariant_H(u_N, alpha, beta, gamma, delta)\n        \n        # Calculate the relative drift\n        rho = (H_N - H_0) / np.abs(H_0)\n        \n        # Classify the trajectory based on the drift\n        if np.abs(rho) = tau:\n            classification = 0\n        elif rho  tau:\n            classification = 1\n        else:  # rho  -tau\n            classification = -1\n            \n        results.append(classification)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2444171"}]}