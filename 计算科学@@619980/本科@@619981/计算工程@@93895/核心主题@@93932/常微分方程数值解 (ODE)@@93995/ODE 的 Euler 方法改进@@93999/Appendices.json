{"hands_on_practices": [{"introduction": "在我们改进一个方法之前，我们必须首先从根本上理解它的局限性。这个练习将带您深入探究显式欧拉法的局部截断误差。通过一个精心构建的思维实验，您将推导出一个精确的条件，在此条件下该方法能够达到意想不到的高精度，从而揭示其误差的数学结构。[@problem_id:2402543]", "problem": "在计算工程学中，求解常微分方程 (ODE) 的显式欧拉法的一种常见改进是利用问题结构，通过抵消主导误差项，在单步计算中实现更高的精度。考虑标量常微分方程 (ODE)\n$$\n\\frac{dy}{dt} = \\alpha t^{2} + \\beta t + \\gamma,\n$$\n其中 $\\alpha$、$\\beta$ 和 $\\gamma$ 为实常数且 $\\alpha \\neq 0$，并设初始时间为 $t_{0}$，初始值为 $y(t_{0}) = y_{0}$。您将从 $t_{0}$ 到 $t_{0} + h$ 进行单步显式欧拉法计算。\n\n从精确解的泰勒展开和显式欧拉更新的定义这些基本原理出发，推导出一个非零步长 $h$（表示为包含 $\\alpha$、$\\beta$ 和 $t_{0}$ 的符号代数表达式），使得二阶局部截断误差项被三阶项抵消，从而在这一单步计算中实现超收敛。在这个特定的 ODE 中，这种抵消使得对于该 $h$ 值的欧拉步长计算结果是精确的。请以闭合形式给出最终的 $h$。无需四舍五入。答案无需带单位。", "solution": "所述问题已经过验证，被认为是科学上可靠、适定且客观的。这是一个关于显式欧拉法局部截断误差的数值分析标准问题。因此，我们可以进行严格的推导。\n\n问题的核心在于分析显式欧拉法单步计算的局部截断误差 (LTE)。LTE 定义为，假设数值方法从当前时间步的精确值开始，下一个时间步的精确解与该数值方法产生的值之间的差值。\n\n设时间 $t$ 时的精确解为 $y(t)$。给定的常微分方程为：\n$$\n\\frac{dy}{dt} = y'(t) = \\alpha t^{2} + \\beta t + \\gamma\n$$\n初始条件为 $y(t_{0}) = y_{0}$。\n\n单步显式欧拉法用一个新值 $y_1$ 来近似解 $y(t_0 + h)$，其表达式为：\n$$\ny_{1} = y_{0} + h \\cdot f(t_{0}, y_{0}) = y(t_{0}) + h \\cdot y'(t_{0})\n$$\n时间 $t_{0} + h$ 时的精确解可以用围绕 $t_{0}$ 的泰勒级数展开来表示：\n$$\ny(t_{0} + h) = y(t_{0}) + h y'(t_{0}) + \\frac{h^{2}}{2!} y''(t_{0}) + \\frac{h^{3}}{3!} y'''(t_{0}) + \\frac{h^{4}}{4!} y^{(4)}(t_{0}) + \\dots\n$$\n这一单步的局部截断误差 $T_{1}$ 是 $y(t_{0} + h) - y_{1}$ 的差值：\n$$\nT_{1} = \\left( y(t_{0}) + h y'(t_{0}) + \\frac{h^{2}}{2} y''(t_{0}) + \\frac{h^{3}}{6} y'''(t_{0}) + \\dots \\right) - \\left( y(t_{0}) + h y'(t_{0}) \\right)\n$$\n$$\nT_{1} = \\frac{h^{2}}{2} y''(t_{0}) + \\frac{h^{3}}{6} y'''(t_{0}) + \\frac{h^{4}}{24} y^{(4)}(t_{0}) + \\dots\n$$\n该级数中的各项是关于 $h$ 的升阶误差项。问题指定了一个特定的 ODE，我们必须为之计算这些项。我们从 ODE 本身求出 $y(t)$ 的必要导数：\n$$\ny'(t) = \\alpha t^{2} + \\beta t + \\gamma\n$$\n$$\ny''(t) = \\frac{d}{dt} (\\alpha t^{2} + \\beta t + \\gamma) = 2\\alpha t + \\beta\n$$\n$$\ny'''(t) = \\frac{d}{dt} (2\\alpha t + \\beta) = 2\\alpha\n$$\n$$\ny^{(4)}(t) = \\frac{d}{dt} (2\\alpha) = 0\n$$\n由于四阶导数及所有更高阶的导数都为零，因此 $y(t_{0}+h)$ 的泰勒级数是有限的，并在三阶项之后终止。因此，局部截断误差精确地由二阶项和三阶项之和给出：\n$$\nT_{1} = \\frac{h^{2}}{2} y''(t_{0}) + \\frac{h^{3}}{6} y'''(t_{0})\n$$\n问题要求找到一个非零步长 $h$，使得二阶误差项 $\\frac{h^{2}}{2} y''(t_{0})$ 被三阶误差项 $\\frac{h^{3}}{6} y'''(t_{0})$ 抵消。这个条件在数学上等同于它们的和为零。由于对于这个特定的 ODE，这个和构成了全部误差，因此将其设为零意味着欧拉步长计算的结果变得精确。\n$$\n\\frac{h^{2}}{2} y''(t_{0}) + \\frac{h^{3}}{6} y'''(t_{0}) = 0\n$$\n将在 $t_{0}$ 处求值的导数表达式代入：\n$$\ny''(t_{0}) = 2\\alpha t_{0} + \\beta\n$$\n$$\ny'''(t_{0}) = 2\\alpha\n$$\n方程变为：\n$$\n\\frac{h^{2}}{2} (2\\alpha t_{0} + \\beta) + \\frac{h^{3}}{6} (2\\alpha) = 0\n$$\n$$\nh^{2} \\left[ \\frac{1}{2}(2\\alpha t_{0} + \\beta) + \\frac{\\alpha h}{3} \\right] = 0\n$$\n这个关于 $h$ 的方程有两个解。一个是平凡解 $h=0$。问题明确要求一个非零步长。因此，我们通过将括号内的表达式设为零来求解非平凡解：\n$$\n\\frac{1}{2}(2\\alpha t_{0} + \\beta) + \\frac{\\alpha h}{3} = 0\n$$\n现在，我们求解 $h$：\n$$\n\\frac{\\alpha h}{3} = -\\frac{1}{2}(2\\alpha t_{0} + \\beta)\n$$\n因为题目给定 $\\alpha \\neq 0$，我们可以用 $\\alpha$ 除：\n$$\n\\frac{h}{3} = -\\frac{1}{2\\alpha}(2\\alpha t_{0} + \\beta)\n$$\n$$\nh = -\\frac{3}{2\\alpha}(2\\alpha t_{0} + \\beta)\n$$\n只要 $2\\alpha t_0 + \\beta \\neq 0$，即 $y''(t_0) \\neq 0$，那么这个 $h$ 的解就保证是非零的。如果 $y''(t_0)$ 为零，二阶误差项将不存在，所述的抵消问题本身将是不适定的。因此，推导出的表达式是一般的非平凡解。该表达式可以简化为：\n$$\nh = -\\frac{6\\alpha t_{0} + 3\\beta}{2\\alpha} = -3 t_{0} - \\frac{3\\beta}{2\\alpha}\n$$\n然而，因式分解的形式同样正确且紧凑。我们以该形式给出最终答案。", "answer": "$$\n\\boxed{-\\frac{3(2\\alpha t_{0} + \\beta)}{2\\alpha}}\n$$", "id": "2402543"}, {"introduction": "直接建立在对误差项的理论理解之上，本实践引入了一种实用的改进策略：延迟校正法。您将开发一个两阶段程序，首先运行标准的欧拉积分，然后利用该初步结果来估计并抵消主导误差项。这个动手练习将展示一个“后处理”步骤如何能显著提高基本数值方法的精度。[@problem_id:2402452]", "problem": "要求您针对常微分方程初值问题，形式化并实现一种前向欧拉法 (Forward Euler method) 的延迟校正改进方法。考虑在均匀网格 $t_n=t_0+n h$, $n=0,1,\\dots,N$ 上的形如 $y'(t)=f(t,y(t))$ 的问题，其中 $h=(T-t_0)/N$，并带有初始条件 $y(t_0)=y_0$。通过 $y_{n+1}^{E}=y_n^{E}+h\\,f(t_n,y_n^{E})$（其中 $y_0^{E}=y_0$）定义一个初步的前向欧拉近似值 $y_n^{E}$。利用这个完整的欧拉计算过程，通过以下差商来定义主误差项 $y''(t_n)$ 的一个近似值：\n$$\n\\widehat{y''}(t_n) \\coloneqq \\frac{ f(t_{n+1},\\,y_{n+1}^{E}) - f(t_n,\\,y_n^{E}) }{h}.\n$$\n然后，通过一个包含此估计值的单步法重新求解一个校正后的问题，使得校正后的数值解 $y_n^{C}$ 由下式定义：\n$$\ny_{n+1}^{C} \\coloneqq y_n^{C} + h\\,f(t_n,y_n^{C}) + \\frac{h^2}{2}\\,\\widehat{y''}(t_n), \\quad y_0^{C}=y_0.\n$$\n对于下面的每个测试用例，计算前向欧拉解和校正解在最终时刻 $T$ 的绝对误差，并计算定义为前向欧拉误差除以校正误差的误差比。\n\n此外，对于指定的观测阶测试，使用两个步长 $h_1$ 和 $h_2=h_1/2$，通过以下公式计算校正方法的观测全局阶 $p$：\n$$\np \\coloneqq \\frac{\\log\\!\\big(e(h_1)/e(h_2)\\big)}{\\log(2)},\n$$\n其中 $e(h)$ 是使用步长 $h$ 的校正方法在最终时刻 $T$ 得到的绝对误差。\n\n所有答案必须表示为无量纲实数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个数字必须以十进制科学记数法打印，并四舍五入到六位有效数字，例如 $[1.234560\\mathrm{e}{-03},2.500000\\mathrm{e}{+00}]$。\n\n测试套件和要求的输出：\n\n- 测试用例 1 (标准情况，线性自治)：$y'(t)=\\lambda y(t)$，其中 $\\lambda=-3$, $t_0=0$, $T=1$, $y_0=1$, $h=0.1$。在 $T$ 时刻的精确值为 $y(T)=\\exp(\\lambda T)$。输出三个数字：前向欧拉绝对误差、校正后的绝对误差以及它们的比值。\n\n- 测试用例 2 (边界/边缘：单步)：$y'(t)=\\lambda y(t)$，其中 $\\lambda=-1$, $t_0=0$, $T=1$, $y_0=1$, $h=1$。在 $T$ 时刻的精确值为 $y(T)=\\exp(\\lambda T)$。输出与测试用例 1 相同的三个数字。\n\n- 测试用例 3 (非线性自治)：$y'(t)=-y(t)^3$, $t_0=0$, $T=1$, $y_0=1$, $h=0.1$。在 $T$ 时刻的精确值为 $y(T)=1/\\sqrt{1+2T}$。输出与测试用例 1 相同的三个数字。\n\n- 测试用例 4 (含时线性)：$y'(t)=t - y(t)$, $t_0=0$, $T=1$, $y_0=0$, $h=0.1$。在 $T$ 时刻的精确值为 $y(T)=T-1+\\exp(-T)$。输出与测试用例 1 相同的三个数字。\n\n- 测试用例 5 (线性自治问题的观测阶)：对于 $y'(t)=\\lambda y(t)$，其中 $\\lambda=-3$, $t_0=0$, $T=1$, $y_0=1$，计算使用 $h_1=0.2$ 和 $h_2=0.1$ 时校正方法在 $T$ 时刻的绝对误差，然后通过上述公式计算 $p$。输出一个数字：观测阶 $p$。\n\n- 测试用例 6 (非线性自治问题的观测阶)：对于 $y'(t)=-y(t)^3$, $t_0=0$, $T=1$, $y_0=1$，计算使用 $h_1=0.2$ 和 $h_2=0.1$ 时校正方法在 $T$ 时刻的绝对误差，然后通过上述公式计算 $p$。输出一个数字：观测阶 $p$。\n\n最终输出格式：您的程序必须打印单行，格式为\n$[r_1,r_2,\\dots,r_{14}]$\n其中各项按顺序分别为：测试用例 1 的三个数字，测试用例 2 的三个数字，测试用例 3 的三个数字，测试用例 4 的三个数字，接着是测试用例 5 的一个数字和测试用例 6 的一个数字，每个数字均按上文指定的六位有效数字的十进制科学记数法格式化。", "solution": "所给出的问题是有效的，它形式化了一种延迟校正技术，用于改进求解形如 $y'(t)=f(t,y(t))$ 并带有初始条件 $y(t_0)=y_0$ 的初值问题的前向欧拉法。该方法在科学上是合理的，适定的，并且所有术语和步骤都得到了明确的定义。这是常微分方程数值分析领域的一个标准问题。我们着手求解。\n\n该方法的基本原理是校正前向欧拉法局部截断误差中的主项。精确解 $y(t)$ 在 $t_n$ 附近的泰勒级数展开为\n$$\ny(t_{n+1}) = y(t_n) + h y'(t_n) + \\frac{h^2}{2} y''(t_n) + O(h^3),\n$$\n其中 $h$ 是步长，$y'(t) = f(t, y(t))$。前向欧拉法 $y_{n+1} = y_n + h f(t_n, y_n)$ 通过仅保留到 $h$ 的一阶项来近似此展开。因此，局部截断误差为 $y(t_{n+1}) - (y(t_n) + h f(t_n, y(t_n))) = \\frac{h^2}{2} y''(t_n) + O(h^3)$，这导致了 $O(h)$ 阶的全局误差。\n\n为了提高精度，可以尝试估计并包含二阶项 $\\frac{h^2}{2} y''(t_n)$。这定义了一个理想化的二阶方法。挑战在于 $y''(t_n)$ 通常是未知的。所提出的延迟校正方案通过一个两阶段过程来解决这个问题。\n\n首先，在整个区间 $[t_0, T]$ 上，使用标准的前向欧拉法计算一个初步的、完整的解轨迹，记为 $y_n^E$：\n$$\ny_{n+1}^E = y_n^E + h f(t_n, y_n^E), \\quad y_0^E = y_0.\n$$\n尽管这个解只有一阶精度，全局误差为 $O(h)$，但它提供了在所有网格点 $t_n$ 上的解的近似值。\n\n其次，使用这个初步解来估计真解的二阶导数 $y''(t_n)$。二阶导数的定义是 $y''(t) = \\frac{d}{dt} y'(t) = \\frac{d}{dt} f(t, y(t))$。在 $t_n$ 时刻对此导数的一阶有限差分近似是 $\\frac{f(t_{n+1}, y(t_{n+1})) - f(t_n, y(t_n))}{h}$。该方法通过将初步欧拉计算得到的 $y_n^E$ 和 $y_{n+1}^E$ 替代真解值 $y(t_n)$ 和 $y(t_{n+1})$ 来近似这个差分：\n$$\n\\widehat{y''}(t_n) \\coloneqq \\frac{f(t_{n+1}, y_{n+1}^E) - f(t_n, y_n^E)}{h}.\n$$\n此计算在所有必要的步上进行，即对 $n=0, 1, \\dots, N-1$。由于 $y_n^E = y(t_n) + O(h)$，可以证明这个近似是一阶精度的，即 $\\widehat{y''}(t_n) = y''(t_n) + O(h)$。\n\n最后，计算一个新的、校正后的解 $y_n^C$。积分格式被修改以包含估计的误差项。这产生了一种新的一步法，其中校正项是预先计算的，并充当一个强迫项：\n$$\ny_{n+1}^C = y_n^C + h f(t_n, y_n^C) + \\frac{h^2}{2} \\widehat{y''}(t_n), \\quad y_0^C = y_0.\n$$\n该校正方法的局部截断误差为 $O(h^3)$，因为泰勒展开中的 $O(h^2)$ 项被校正项近似抵消了：$\\frac{h^2}{2} y''(t_n) - \\frac{h^2}{2} \\widehat{y''}(t_n) = \\frac{h^2}{2} (y''(t_n) - (y''(t_n) + O(h))) = O(h^3)$。一个局部截断误差为 $O(h^{p+1})$ 的方法通常具有 $O(h^p)$ 的全局误差。因此，我们期望这个校正方法是二阶精度的，全局误差为 $O(h^2)$。这一假设在指定的观测阶计算中得到了检验。\n\n该算法被实现为一个通用的求解器函数，它接受微分方程 $f$、初始和最终时间 $t_0$ 和 $T$、初始值 $y_0$ 以及步长 $h$。该函数首先执行欧拉计算，然后计算 $\\widehat{y''}(t_n)$ 值的数组，最后执行校正后的积分。然后将此求解器应用于问题陈述中定义的六个测试用例中的每一个。所要求的量——欧拉法和校正方法的绝对误差、它们的比值以及收敛的观测阶——被计算并收集起来用于最终输出。步数 $N$ 取为 $(T-t_0)/h$，对于所有测试用例，该比率都是整数，这符合均匀网格的要求。提供的精确解用于计算在最终时间 $T$ 的误差。收敛的观测阶 $p$ 是使用公式 $p = \\log(e(h_1)/e(h_2)) / \\log(2)$ 计算的，这直接源于误差 $e(h)$ 的行为近似于 $e(h) \\approx C h^p$（其中 $C$ 为某个常数）的假设。", "answer": "```python\nimport numpy as np\n\ndef deferred_correction_solver(f, t0, T, y0, h):\n    \"\"\"\n    Solves an ODE y'(t) = f(t, y) using Forward Euler and a deferred correction method.\n\n    Args:\n        f (callable): The function f(t, y).\n        t0 (float): Initial time.\n        T (float): Final time.\n        y0 (float): Initial value y(t0).\n        h (float): Step size.\n\n    Returns:\n        tuple: A tuple containing:\n            - y_euler_final (float): The final value from the Forward Euler method.\n            - y_corrected_final (float): The final value from the corrected method.\n    \"\"\"\n    if not np.isclose((T - t0) / h, round((T - t0) / h)):\n        raise ValueError(\"T-t0 must be an integer multiple of h\")\n    N = int(round((T - t0) / h))\n    t_grid = np.linspace(t0, T, N + 1)\n\n    # Stage 1: Compute preliminary solution using Forward Euler\n    yE = np.zeros(N + 1)\n    yE[0] = y0\n    for n in range(N):\n        yE[n + 1] = yE[n] + h * f(t_grid[n], yE[n])\n\n    # Stage 1.5: Compute the approximation of the second derivative\n    ypp_hat = np.zeros(N)\n    for n in range(N):\n        ypp_hat[n] = (f(t_grid[n + 1], yE[n + 1]) - f(t_grid[n], yE[n])) / h\n\n    # Stage 2: Compute the corrected solution\n    yC = np.zeros(N + 1)\n    yC[0] = y0\n    for n in range(N):\n        yC[n + 1] = yC[n] + h * f(t_grid[n], yC[n]) + (h**2 / 2) * ypp_hat[n]\n\n    return yE[N], yC[N]\n\ndef solve():\n    \"\"\"\n    Runs all test cases and prints the formatted results.\n    \"\"\"\n    results = []\n\n    # Test Case 1: y'(t) = -3y(t), h=0.1\n    f1 = lambda t, y: -3 * y\n    t0_1, T_1, y0_1, h_1 = 0, 1, 1, 0.1\n    y_exact_1 = np.exp(-3 * T_1)\n    yE_1, yC_1 = deferred_correction_solver(f1, t0_1, T_1, y0_1, h_1)\n    err_E1 = np.abs(yE_1 - y_exact_1)\n    err_C1 = np.abs(yC_1 - y_exact_1)\n    ratio1 = err_E1 / err_C1\n    results.extend([err_E1, err_C1, ratio1])\n\n    # Test Case 2: y'(t) = -y(t), h=1.0\n    f2 = lambda t, y: -1 * y\n    t0_2, T_2, y0_2, h_2 = 0, 1, 1, 1.0\n    y_exact_2 = np.exp(-1 * T_2)\n    yE_2, yC_2 = deferred_correction_solver(f2, t0_2, T_2, y0_2, h_2)\n    err_E2 = np.abs(yE_2 - y_exact_2)\n    err_C2 = np.abs(yC_2 - y_exact_2)\n    ratio2 = err_E2 / err_C2\n    results.extend([err_E2, err_C2, ratio2])\n\n    # Test Case 3: y'(t) = -y(t)^3, h=0.1\n    f3 = lambda t, y: -y**3\n    t0_3, T_3, y0_3, h_3 = 0, 1, 1, 0.1\n    y_exact_3 = 1 / np.sqrt(1 + 2 * T_3)\n    yE_3, yC_3 = deferred_correction_solver(f3, t0_3, T_3, y0_3, h_3)\n    err_E3 = np.abs(yE_3 - y_exact_3)\n    err_C3 = np.abs(yC_3 - y_exact_3)\n    ratio3 = err_E3 / err_C3\n    results.extend([err_E3, err_C3, ratio3])\n\n    # Test Case 4: y'(t) = t - y(t), h=0.1\n    f4 = lambda t, y: t - y\n    t0_4, T_4, y0_4, h_4 = 0, 1, 0, 0.1\n    y_exact_4 = T_4 - 1 + np.exp(-T_4)\n    yE_4, yC_4 = deferred_correction_solver(f4, t0_4, T_4, y0_4, h_4)\n    err_E4 = np.abs(yE_4 - y_exact_4)\n    err_C4 = np.abs(yC_4 - y_exact_4)\n    ratio4 = err_E4 / err_C4\n    results.extend([err_E4, err_C4, ratio4])\n\n    # Test Case 5: Observed order for Test Case 1\n    h5_1, h5_2 = 0.2, 0.1\n    _, yC_h1_5 = deferred_correction_solver(f1, t0_1, T_1, y0_1, h5_1)\n    err_h1_5 = np.abs(yC_h1_5 - y_exact_1)\n    err_h2_5 = err_C1 # Re-use calculation from Test Case 1\n    p5 = np.log(err_h1_5 / err_h2_5) / np.log(2)\n    results.append(p5)\n\n    # Test Case 6: Observed order for Test Case 3\n    h6_1, h6_2 = 0.2, 0.1\n    _, yC_h1_6 = deferred_correction_solver(f3, t0_3, T_3, y0_3, h6_1)\n    y_exact_6 = y_exact_3\n    err_h1_6 = np.abs(yC_h1_6 - y_exact_6)\n    err_h2_6 = err_C3 # Re-use calculation from Test Case 3\n    p6 = np.log(err_h1_6 / err_h2_6) / np.log(2)\n    results.append(p6)\n\n    # Format output as specified\n    formatted_results = [f\"{x:.6e}\" for x in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2402452"}, {"introduction": "虽然事后校正误差是一种强大的技术，但有时更好的方法是使用一种本质上更稳定、更适合问题结构的积分方法。本实践将探讨应用于质点-弹簧-阻尼系统的半隐式欧拉法，这是一个工程学的基石模型。通过实现这一方案，您将发现其卓越的稳定性，它允许比显式方法大得多的时间步长，这在对性能要求苛刻的应用中是至关重要的优势。[@problem_id:2402453]", "problem": "给定一个一维质量-弹簧-阻尼器模型，其由以下常微分方程 (ODE) 控制： $$m \\, \\ddot{x}(t) + c \\, \\dot{x}(t) + k \\, x(t) = 0,$$ 其中 $m$ 是质量（单位：千克），$c$ 是粘性阻尼系数（单位：千克/秒），$k$ 是弹簧刚度（单位：牛顿/米）。引入速度变量 $v(t) = \\dot{x}(t)$。考虑对此系统在大小为 $h$ 秒的均匀时间步长上进行如下的一阶时间离散化：\n$$v_{n+1} = \\frac{v_n - h \\, \\frac{k}{m} \\, x_n}{1 + h \\, \\frac{c}{m}}, \\quad x_{n+1} = x_n + h \\, v_{n+1},$$\n初始条件为 $x_0$ 和 $v_0$。量 $x_n$ 和 $v_n$ 分别是离散时间点 $t_n = n h$ 上位置和速度的近似值。\n\n您的任务是编写一个完整、可运行的程序，该程序：\n- 为指定的步数 $N$，实现上述离散时间更新以传播 $x_n$ 和 $v_n$。\n- 对下面指定的每个测试用例，计算：\n  1. 最终位置 $x_N$（单位：米）。\n  2. 最终速度 $v_N$（单位：米/秒）。\n  3. 最终机械能 $$E_N = \\tfrac{1}{2} m v_N^2 + \\tfrac{1}{2} k x_N^2$$（单位：焦耳）。\n  4. 一个有界性指标，定义如下：令 $$M = \\max_{0 \\le n \\le N} \\max\\{|x_n|, |v_n|\\}。$$ 如果 $M \\le B$，则结果定义为 $1$，否则为 $0$，其中 $B = 10^6$。\n- 所有值 $x_N$、$v_N$ 和 $E_N$ 都必须以国际单位制 (SI) 表示。不要打印单位；数值本身将被解释为SI单位。\n\n使用以下测试套件，每个用例是一个元组 $(m, c, k, h, N, x_0, v_0)$：\n- 用例 $1$：$(1.0, 0.5, 100.0, 0.1, 500, 1.0, 0.0)$\n- 用例 $2$：$(1.0, 10.0, 2500.0, 0.02, 1000, 1.0, 0.0)$\n- 用例 $3$：$(1.0, 0.0, 1.0, 2.2, 200, 1.0, 0.0)$\n\n您的程序应生成一行输出，其中包含一个由方括号括起来的逗号分隔列表。对于每个用例，按顺序附加四个值 $[x_N, v_N, E_N, \\text{bounded}]$，其中有界性指标用整数 $1$ 表示真，$0$ 表示假。因此，最终输出必须包含 $12$ 个逗号分隔的条目，对应于上述三个用例（按顺序排列），例如：\n\"[x1,v1,E1,b1,x2,v2,E2,b2,x3,v3,E3,b3]\".", "solution": "在尝试任何解决方案之前，首先对问题陈述进行严格的验证，以确保其科学和逻辑上的完整性。\n\n### 步骤 1：提取已知条件\n\n问题陈述中逐字提供了以下信息：\n- **控制常微分方程：** $m \\, \\ddot{x}(t) + c \\, \\dot{x}(t) + k \\, x(t) = 0$，其中 $m$ 是质量 (kg)，$c$ 是阻尼系数 (kg/s)，$k$ 是弹簧刚度 (N/m)。\n- **状态变量：** $v(t) = \\dot{x}(t)$。\n- **离散化方案：**\n  - 时间步长：$h$ (s)。\n  - $t_n = n h$ 时的近似值：$x_n, v_n$。\n  - 更新方程：\n    $$v_{n+1} = \\frac{v_n - h \\, \\frac{k}{m} \\, x_n}{1 + h \\, \\frac{c}{m}}, \\quad x_{n+1} = x_n + h \\, v_{n+1}$$\n- **初始条件：** $x_0, v_0$。\n- **任务：** 对于给定的步数 $N$，计算：\n  1. 最终位置 $x_N$ (m)。\n  2. 最终速度 $v_N$ (m/s)。\n  3. 最终机械能 $E_N = \\tfrac{1}{2} m v_N^2 + \\tfrac{1}{2} k x_N^2$ (J)。\n  4. 有界性指标：令 $M = \\max_{0 \\le n \\le N} \\max\\{|x_n|, |v_n|\\}$。如果 $M \\le B$，则指标为 $1$，否则为 $0$，其中 $B = 10^6$。\n- **测试用例：** 每个用例是一个元组 $(m, c, k, h, N, x_0, v_0)$。\n  - 用例 $1$: $(1.0, 0.5, 100.0, 0.1, 500, 1.0, 0.0)$\n  - 用例 $2$: $(1.0, 10.0, 2500.0, 0.02, 1000, 1.0, 0.0)$\n  - 用例 $3$: $(1.0, 0.0, 1.0, 2.2, 200, 1.0, 0.0)$\n\n### 步骤 2：使用提取的已知条件进行验证\n\n- **科学依据：** 该控制方程是质量-弹簧-阻尼器系统的基本线性模型，是经典力学的基石。机械能的定义是正确的。该数值方案是求解常微分方程的有效方法。该问题具有科学合理性。\n- **适定性：** 该常微分方程的初值问题是适定的。所提供的离散化方案在其更新规则中是显式的，意味着 $x_{n+1}$ 和 $v_{n+1}$ 由 $x_n$ 和 $v_n$ 唯一确定。对于所有有效的物理参数（$m>0, c\\ge0, h>0$），分母 $1 + h \\, \\frac{c}{m}$ 均不为零。该问题是适定的。\n- **客观性：** 该问题使用精确、客观的数学和物理术语进行表述。任务是定量的且明确无误。该问题是客观的。\n- **完整性与一致性：** 每个测试用例都提供了所有必要的常数、初始条件和参数（$m, c, k, h, N, x_0, v_0, B$）。该问题是自洽且一致的。单位被指定为国际单位制 (SI)，这是一致的。\n\n### 步骤 3：结论与行动\n\n问题陈述具有科学依据、适定且完整。判定其为**有效**。将着手开发解决方案。\n\n### 解决方案\n\n该解决方案需要实现一个数值时间步进算法，以近似质量-弹簧-阻尼器系统的动力学。\n\n**1. 数学公式**\n\n通过引入速度变量 $v(t) = \\dot{x}(t)$，二阶常微分方程 (ODE)\n$$m \\, \\ddot{x}(t) + c \\, \\dot{x}(t) + k \\, x(t) = 0$$\n被转换为一个一阶常微分方程组。该系统变为：\n$$\n\\begin{cases}\n\\dot{x}(t) = v(t) \\\\\n\\dot{v}(t) = -\\frac{k}{m} x(t) - \\frac{c}{m} v(t)\n\\end{cases}\n$$\n\n**2. 离散化方案分析**\n\n提供的更新规则为：\n$$\nv_{n+1} = \\frac{v_n - h \\, \\frac{k}{m} \\, x_n}{1 + h \\, \\frac{c}{m}} \\tag{1}\n$$\n$$\nx_{n+1} = x_n + h \\, v_{n+1} \\tag{2}\n$$\n其中 $h$ 是时间步长，$(x_n, v_n)$ 是在时间 $t_n = n h$ 时 $(x(t_n), v(t_n))$ 的近似值。\n\n该方案可被识别为一种半隐式方法。通过将方程重排为有限差分形式，我们可以看到其结构：\n$$\n\\frac{x_{n+1} - x_n}{h} = v_{n+1} \\quad \\text{（位置的隐式/后向 Euler 步）}\n$$\n$$\n\\frac{v_{n+1} - v_n}{h} = -\\frac{k}{m} x_n - \\frac{c}{m} v_{n+1} \\quad \\text{（速度的混合步）}\n$$\n速度更新使用了旧的位置 $x_n$（对弹簧力的显式或前向处理）和新的速度 $v_{n+1}$（对阻尼力的隐式或后向处理）。这种结构通常比完全显式的方法（如标准的前向 Euler 方法）提供更好的稳定性，特别是对于刚性或振荡系统。\n\n**3. 无阻尼情况下的稳定性考虑**\n\n数值方法的一个关键方面是稳定性。考虑用例 3，其中阻尼不存在 ($c=0$)。参数 $c_m = c/m$ 变为 $0$。更新方程简化为：\n$$\nv_{n+1} = v_n - h \\frac{k}{m} x_n\n$$\n$$\nx_{n+1} = x_n + h v_{n+1}\n$$\n这是著名的辛 Euler 方法。对于简谐振子，其稳定性取决于时间步长的大小。稳定性判据是 $|h \\omega_0| \\le 2$，其中 $\\omega_0 = \\sqrt{k/m}$ 是固有角频率。\n\n对于用例 3，我们有 $m=1.0$，$k=1.0$ 和 $h=2.2$。固有频率为 $\\omega_0 = \\sqrt{1.0/1.0} = 1.0 \\, \\text{rad/s}$。我们检查稳定性条件：\n$$\n|h \\omega_0| = |2.2 \\times 1.0| = 2.2\n$$\n由于 $2.2 > 2.0$，稳定性条件被违反。对于这组参数选择，该数值方案是不稳定的。因此，我们必须预测用例 3 的数值解将无界增长，并且有界性指标应正确地为 $0$。这是该测试用例的一个特点，而非问题本身的缺陷。\n\n**4. 算法流程**\n\n程序将对每个测试用例 $(m, c, k, h, N, x_0, v_0)$ 执行以下步骤：\n1.  初始化状态变量 $x = x_0$ 和 $v = v_0$。\n2.  初始化用于有界性检查的跟踪变量，$M_{max} = \\max(|x_0|, |v_0|)$。\n3.  预先计算常数系数 $\\frac{k}{m}$ 和 $\\frac{c}{m}$ 以避免循环内的重复计算。分母项 $1 + h \\frac{c}{m}$ 也将被预先计算。\n4.  执行一个从 $n=0$到 $N-1$ 的循环：\n    a. 使用方程 $(1)$ 计算 $v_{n+1}$。\n    b. 使用方程 $(2)$ 计算 $x_{n+1}$。\n    c. 更新状态：$(x_n, v_n) \\leftarrow (x_{n+1}, v_{n+1})$。\n    d. 更新跟踪器：$M_{max} = \\max(M_{max}, |x_{n+1}|, |v_{n+1}|)$。\n5.  循环完成后，最终状态为 $(x_N, v_N)$。\n6.  计算最终能量 $E_N = \\frac{1}{2} m v_N^2 + \\frac{1}{2} k x_N^2$。\n7.  确定有界性指标：如果 $M_{max} \\le 10^6$，则为 $1$，否则为 $0$。\n8.  收集四个结果：$x_N, v_N, E_N$ 和有界性指标。\n\n此流程将系统地应用于所有提供的测试用例，以生成最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the mass-spring-damper problem for a given set of test cases\n    using the specified semi-implicit numerical scheme.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (m, c, k, h, N, x0, v0)\n    test_cases = [\n        (1.0, 0.5, 100.0, 0.1, 500, 1.0, 0.0),\n        (1.0, 10.0, 2500.0, 0.02, 1000, 1.0, 0.0),\n        (1.0, 0.0, 1.0, 2.2, 200, 1.0, 0.0),\n    ]\n\n    # Bounding constant B\n    BOUND = 10**6\n\n    results = []\n    \n    for case in test_cases:\n        m, c, k, h, N, x0, v0 = case\n\n        # Initialize state variables\n        x = float(x0)\n        v = float(v0)\n\n        # Initialize tracker for boundedness check\n        max_abs_val = max(abs(x), abs(v))\n\n        # Pre-compute coefficients for efficiency\n        k_over_m = k / m\n        c_over_m = c / m\n        denominator = 1.0 + h * c_over_m\n\n        # Time-stepping loop\n        for _ in range(int(N)):\n            # Apply the update equations\n            v_new = (v - h * k_over_m * x) / denominator\n            x_new = x + h * v_new\n\n            # Update the state\n            x, v = x_new, v_new\n            \n            # Update the maximum absolute value observed\n            max_abs_val = max(max_abs_val, abs(x), abs(v))\n\n        # Final state\n        x_N = x\n        v_N = v\n\n        # Calculate final mechanical energy\n        E_N = 0.5 * m * v_N**2 + 0.5 * k * x_N**2\n\n        # Determine boundedness indicator\n        is_bounded = 1 if max_abs_val <= BOUND else 0\n\n        # Append results for this case\n        results.extend([x_N, v_N, E_N, is_bounded])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2402453"}]}