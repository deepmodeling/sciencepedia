{"hands_on_practices": [{"introduction": "一个用于求解微分方程的数值方法必须是收敛的，这意味着当步长缩小时，其解会逼近真实解。本实践探讨了收敛性理论的一个基石：零点稳定性。通过实现一个特意设计来违反根条件的数值方法，你将直接观察到理论所预测的发散现象，从而更深刻地体会到为何零点稳定性是任何可靠线性多步法不可或缺的要求 [@problem_id:2410027]。", "problem": "设 $y(t)$ 满足初值问题 $y'(t) = -y(t)$ 且 $y(0) = 1$。考虑由下式定义的两步线性多步法 (LMM)\n$$ y_{n+2} - 2 y_{n+1} + y_n = 0, $$\n应用于步长为 $h > 0$ 的均匀网格 $t_n = n h$。该方法由 $y_0 = 1$ 初始化，并根据每种情况的指定，使用 $y_1 = e^{-h}$ 或 $y_1 = 1$。\n\n任务：\n1. 使用基本定义，判断该方法是否是相容的，以及是否满足零稳定性的根条件。你的判断应仅基于线性多步法相容性和根条件的定义。\n2. 精确地按照上述方法实现，计算每个测试用例在 $t=T$ 时的数值近似解。对于给定的 $T$ 和 $h$，取 $N = T/h$（假设 $N$ 为整数），并使用指定的 $y_1$ 初始化来计算该方法产生的数值 $y_N$。计算绝对误差 $|y_N - e^{-T}|$。\n3. 使用以下测试集，每个测试用例以三元组 $(T,h,\\text{start})$ 的形式指定，其中 $\\text{start}$ 为 $\\text{exact}$ 表示 $y_1 = e^{-h}$，或为 $\\text{constant}$ 表示 $y_1 = 1$：\n- $(1, 0.1, \\text{exact})$\n- $(1, 0.05, \\text{exact})$\n- $(1, 0.025, \\text{exact})$\n- $(0, 0.1, \\text{exact})$\n- $(10, 0.1, \\text{exact})$\n- $(1, 0.1, \\text{constant})$\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,\\dots]$），列表中的每个 $r_i$ 是对应测试用例（按所列顺序）的绝对误差 $|y_N - e^{-T}|$。此问题不涉及物理单位。若出现任何角度，都必须以弧度为单位，但此处并未使用角度。", "solution": "所述问题在数学上是良定的且内部一致。它提出了一个在常微分方程数值分析中标准且具有启发性的问题。我们将着手进行分析和求解。\n\n该问题要求分析由以下递推关系给出的两步线性多步法 (LMM)：\n$$ y_{n+2} - 2 y_{n+1} + y_n = 0 $$\n此方法将应用于初值问题 (IVP) $y'(t) = -y(t)$，其中 $y(0) = 1$。\n\n一般的 $k$ 步 LMM 表示为：\n$$ \\sum_{j=0}^{k} \\alpha_j y_{n+j} = h \\sum_{j=0}^{k} \\beta_j f(t_{n+j}, y_{n+j}) $$\n对于给定的方法，步数 $k=2$。通过比较两种形式，我们可以确定系数：\n- $\\alpha_2 = 1$, $\\alpha_1 = -2$, $\\alpha_0 = 1$。\n- $\\beta_2 = 0$, $\\beta_1 = 0$, $\\beta_0 = 0$。\n\n一个关键的观察是，所有 $\\beta_j$ 系数都为零。这意味着该数值方法没有利用微分方程 $y' = f(t,y)$（在此例中为 $f(t,y)=-y$）的信息。该方法的演化仅取决于其自身的系数和初始值，而不取决于它本应模拟的动力学过程。这是一个严重的缺陷，正式的分析将阐明这一点。\n\n### 第1部分：相容性与零稳定性\n\n**相容性分析**\n如果一个 LMM 的精度阶 $p$ 至少为 1（$p \\ge 1$），则称该方法是相容的。这等价于其系数满足以下两个代数条件：\n1. $\\sum_{j=0}^{k} \\alpha_j = 0$\n2. $\\sum_{j=0}^{k} j \\alpha_j = \\sum_{j=0}^{k} \\beta_j$\n\n让我们对给定的方法验证这些条件：\n1. $\\sum_{j=0}^{2} \\alpha_j = \\alpha_0 + \\alpha_1 + \\alpha_2 = 1 + (-2) + 1 = 0$。此条件满足。\n2. 对于左边：$\\sum_{j=0}^{2} j \\alpha_j = (0 \\cdot \\alpha_0) + (1 \\cdot \\alpha_1) + (2 \\cdot \\alpha_2) = (0 \\cdot 1) + (1 \\cdot (-2)) + (2 \\cdot 1) = -2 + 2 = 0$。\n对于右边：$\\sum_{j=0}^{2} \\beta_j = \\beta_0 + \\beta_1 + \\beta_2 = 0 + 0 + 0 = 0$。\n左边等于右边。此条件也满足。\n\n由于两个条件都成立，该方法是**相容的**。为确定其阶，我们考察局部截断误差，它由算子 $L[y(t); h] = \\sum_{j=0}^k \\alpha_j y(t+jh) - h \\sum_{j=0}^k \\beta_j y'(t+jh)$ 定义。对于此方法：\n$$ L[y(t); h] = y(t+2h) - 2y(t+h) + y(t) $$\n使用 $y(t+h)$ 和 $y(t+2h)$ 在 $t$ 点的泰勒级数展开：\n$y(t+h) = y(t) + h y'(t) + \\frac{h^2}{2} y''(t) + O(h^3)$\n$y(t+2h) = y(t) + 2h y'(t) + \\frac{(2h)^2}{2} y''(t) + O(h^3) = y(t) + 2h y'(t) + 2h^2 y''(t) + O(h^3)$\n将这些代入 $L[y(t); h]$ 的表达式中：\n$$ L[y(t); h] = [y(t) + 2h y'(t) + 2h^2 y''(t)] - 2[y(t) + h y'(t) + \\frac{h^2}{2} y''(t)] + y(t) + O(h^3) $$\n$$ L[y(t); h] = (1-2+1)y(t) + (2-2)h y'(t) + (2-1)h^2 y''(t) + O(h^3) = h^2 y''(t) + O(h^3) $$\n方法的阶 $p$ 由 $L[y(t); h] = O(h^{p+1})$ 定义。此处 $p+1=2$，所以阶为 $p=1$。相容性得到确认。\n\n**零稳定性分析**\nLMM 的零稳定性由其第一特征多项式 $\\rho(z)$ 的根决定：\n$$ \\rho(z) = \\sum_{j=0}^{k} \\alpha_j z^j $$\n对于给定的方法，该多项式为：\n$$ \\rho(z) = \\alpha_0 + \\alpha_1 z + \\alpha_2 z^2 = 1 - 2z + z^2 = (z-1)^2 $$\n$\\rho(z)=0$ 的根通过求解 $(z-1)^2 = 0$ 得到，即在 $z_1 = z_2 = 1$ 处有一个二重根。\n\n零稳定性的**根条件**要求：\n1. $\\rho(z)$ 的所有根必须位于复平面的单位圆内或圆上（即 $|z| \\le 1$）。\n2. 任何位于单位圆上的根（即 $|z|=1$）必须是单根（重数为 $1$）。\n\n在我们的例子中，根 $z=1$ 的模为 $|1|=1$，因此它位于单位圆上。然而，它的重数是 $2$，大于 $1$。因此，根条件的第二部分被违反。该方法是**非零稳定的**。\n\n根据 Dahlquist 等价定理，一个 LMM 是收敛的当且仅当它既是相容的又是零稳定的。由于该方法非零稳定，因此它是**不收敛的**。这意味着当步长 $h$ 趋近于零时，数值解不会收敛到该 IVP 的真实解。数值测试将展示这种发散性。\n\n### 第2部分：实现与计算\n\n该数值格式是一个常系数线性齐次递推关系：\n$$ y_{n+2} = 2y_{n+1} - y_n $$\n这个递推关系的特征方程是 $r^2 - 2r + 1 = 0$，与多项式 $\\rho(r)$ 相同。它有一个二重根 $r=1$。这种递推关系的通解形式为：\n$$ y_n = c_1 (1)^n + c_2 n (1)^n = c_1 + c_2 n $$\n常数 $c_1$ 和 $c_2$ 由序列的初始两个值 $y_0$ 和 $y_1$ 决定。\n- 当 $n=0$ 时：$y_0 = c_1 + c_2 \\cdot 0 \\implies c_1 = y_0$。\n- 当 $n=1$ 时：$y_1 = c_1 + c_2 \\cdot 1 \\implies c_2 = y_1 - c_1 = y_1 - y_0$。\n\n因此，在第 $n$ 步的数值解的显式公式为：\n$$ y_n = y_0 + n(y_1 - y_0) $$\n这个表达式表明数值解随步数索引 $n$ 线性增长。这是 $z=1$ 处二重根的直接后果，也是不稳定的机理。\n\n为了计算在最终时间 $T=Nh$ 时的数值近似解 $y_N$，我们直接使用该公式并令 $n=N$。对于每个测试用例 $(T, h, \\text{start})$：\n1. 计算步数 $N = T/h$。\n2. 设置初始值 $y_0 = 1$。\n3. 根据 'start' 条件确定第二个值 $y_1$：\n    - 如果是 'exact'，则 $y_1 = e^{-h}$。\n    - 如果是 'constant'，则 $y_1 = 1$。\n4. 计算在 $t=T$ 时的数值解：$y_N = y_0 + N(y_1 - y_0)$。\n5. 计算在 $t=T$ 时的真实解：$y(T) = e^{-T}$。\n6. 绝对误差为 $|y_N - e^{-T}|$。\n\n这个递推关系的解析解在计算上是精确的，并且比基于循环的实现更高效，避免了任何浮点误差的累积。最终答案中的程序将实现这一逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the given problem by analyzing a linear multistep method and calculating\n    the absolute error for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (T, h, start_type)\n        (1.0, 0.1, \"exact\"),\n        (1.0, 0.05, \"exact\"),\n        (1.0, 0.025, \"exact\"),\n        (0.0, 0.1, \"exact\"),\n        (10.0, 0.1, \"exact\"),\n        (1.0, 0.1, \"constant\"),\n    ]\n\n    results = []\n    for T, h, start_type in test_cases:\n        # The problem statement assumes N = T/h is an integer.\n        # We handle T = 0 as a special case for N.\n        if T == 0.0:\n            N = 0\n        else:\n            # Use rounding to handle potential floating point inaccuracies in T/h\n            N = int(round(T / h))\n\n        # Initial condition from the IVP: y(0) = 1\n        y0 = 1.0\n\n        # Determine y_1 based on the start type specified in the test case.\n        if start_type == \"exact\":\n            y1 = np.exp(-h)\n        elif start_type == \"constant\":\n            y1 = 1.0\n        else:\n            # This path should not be reached with the given test cases.\n            raise ValueError(f\"Unknown start_type: {start_type}\")\n\n        # The linear multistep method y_{n+2} - 2*y_{n+1} + y_n = 0 is a\n        # linear recurrence relation. Its characteristic equation r^2 - 2r + 1 = 0\n        # has a double root r=1. The general solution is y_n = c1 + c2*n.\n        # Using y_0 and y_1 to find the constants c1 and c2, we get the\n        # specific solution: y_n = y_0 + n * (y_1 - y_0).\n        # We can use this analytical solution of the recurrence to compute y_N directly.\n        if N == 0:\n            y_N = y0\n        else:\n            y_N = y0 + N * (y1 - y0)\n\n        # The exact solution to the IVP y'(t) = -y(t) with y(0) = 1 is y(t) = exp(-t).\n        y_exact_T = np.exp(-T)\n\n        # Compute the absolute error |y_N - y(T)|.\n        error = np.abs(y_N - y_exact_T)\n        results.append(error)\n\n    # Print the results in the specified format: [r1,r2,r3,...]\n    # The format string ensures a consistent number of decimal places for clarity.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "2410027"}, {"introduction": "虽然零点稳定性保证了当步长 $h \\to 0$ 时的收敛性，但实际计算中使用的是有限的步长 $h$。本实践将焦点转向绝对稳定性，它决定了一个方法对于给定的非零步长是否保持稳定。你将构建一个常用的“预测-求值-校正-求值”（PECE）格式，并分析其稳定域，这对于在实际仿真中选择合适的步长以避免数值不稳定性至关重要 [@problem_id:2371160]。", "problem": "考虑标量初值问题 $y'(t)=\\lambda y(t)$，其中 $y(0)=1$，$\\lambda \\in \\mathbb{C}$ 的物理单位为 $\\mathrm{s}^{-1}$，$t$ 的单位为秒。通过将二阶显式 Adams–Bashforth 预估子与梯形法则校正子（也称为二阶 Adams–Moulton 方法）耦合，构建一个两步预估-求值-校正-求值（PECE）格式，每步执行一次校正。将此 PECE 格式应用于线性测试方程 $y'(t)=\\lambda y(t)$，推导出齐次线性两步递推关系，该关系使用固定的步长 $h>0$ 秒，将 $y_n \\approx y(t_n)$ 推进到 $y_{n+1} \\approx y(t_{n+1})$，其中 $t_{n+1}=t_n+h$。令 $z = h\\lambda$ 表示无量纲步长参数。\n\n定义此两步 PECE 方法在测试方程上的绝对稳定性如下：对于给定的 $z \\in \\mathbb{C}$，构建所推导的线性两步递推关系的特征多项式，并令 $\\xi_1(z)$ 和 $\\xi_2(z)$ 为其两个根。当且仅当两个根都满足 $|\\xi_1(z)| \\le 1$ 和 $|\\xi_2(z)| \\le 1$ 时，该方法在 $z$ 处是绝对稳定的。如果根的模恰好等于 $1$，则假定其为单根。\n\n您的程序必须从第一性原理出发，进行符号推导，以计算任意 $z \\in \\mathbb{C}$ 的特征多项式，然后用它来评估给定 $(\\lambda,h)$ 的稳定性。此外，沿着负实轴 $z\\in \\mathbb{R}_{\\le 0}$（即 $\\lambda \\in \\mathbb{R}_{<0}$ 且 $h \\ge 0$），对于给定的负实数 $\\lambda$，确定使该方法保持绝对稳定的最大步长 $h_{\\max}$（单位为秒）。\n\n使用以下参数值测试套件来检验您的实现：\n- 稳定性查询（每个返回一个布尔值）：\n  1. $(\\lambda,h)=(-1,\\,0.5)$，\n  2. $(\\lambda,h)=(-1,\\,1.5)$，\n  3. $(\\lambda,h)=(-40,\\,0.05)$，\n  4. $(\\lambda,h)=(-1+10\\,\\mathrm{i},\\,0.05)$，\n  5. $(\\lambda,h)=(10\\,\\mathrm{i},\\,0.1)$，\n  6. $(\\lambda,h)=(-3,\\,0)$，\n其中 $\\mathrm{i}$ 表示虚数单位，所有 $\\lambda$ 的单位为 $\\mathrm{s}^{-1}$，所有 $h$ 的单位为 $\\mathrm{s}$。\n\n- 最大稳定步长查询（返回一个以秒为单位的浮点数）：\n  7. 对于 $\\lambda=-1$（单位为 $\\mathrm{s}^{-1}$），计算 $h_{\\max}$（单位为 $\\mathrm{s}$），其定义为满足 $z=h\\lambda \\in \\mathbb{R}_{\\le 0}$ 时方法绝对稳定的 $h\\ge 0$ 的上确界。将 $h_{\\max}$ 表示为四舍五入到 $6$ 位小数的十进制数（单位为秒）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为严格按照上述测试用例顺序排列的结果。其中，第 1 到 6 项为布尔值，第 7 项为单个浮点数（四舍五入到 6 位小数）。例如，输出格式必须为 $[b_1,b_2,b_3,b_4,b_5,b_6,h_{\\max}]$，其中每个 $b_j$ 是 $\\mathrm{True}$ 或 $\\mathrm{False}$，$h_{\\max}$ 是一个小数点后有 $6$ 位数字的十进制数。所有时间单位都视为 $\\mathrm{s}$，所有速率单位都视为 $\\mathrm{s}^{-1}$。", "solution": "问题陈述已经过验证，被认为可以进行分析。它具有科学依据，提法恰当且客观。我们开始求解。\n\n任务是分析应用于线性测试方程 $y'(t) = \\lambda y(t)$（其中 $\\lambda \\in \\mathbb{C}$）的两步预估-求值-校正-求值（PECE）数值格式的绝对稳定性。该格式使用二阶 Adams-Bashforth (AB2) 方法作为预估子，梯形法则（即单步二阶 Adams-Moulton 方法，AM2）作为校正子，每步进行一次校正。\n\n对于固定步长 $h > 0$，令 $y_n$ 为时间 $t_n = n h$ 时 $y(t_n)$ 的数值近似解。令 $f_n = f(t_n, y_n) = \\lambda y_n$。为了方便起见，使用无量纲参数 $z = h\\lambda$。\n\nPECE 格式通过以下步骤将解从 $(y_{n-1}, y_n)$ 推进到 $y_{n+1}$：\n\n1.  **预估 (P)**：使用显式两步 AB2 公式计算预估值 $y_{n+1}^{(P)}$：\n    $$y_{n+1}^{(P)} = y_n + \\frac{h}{2}(3f_n - f_{n-1})$$\n    对于测试方程，这变为：\n    $$y_{n+1}^{(P)} = y_n + \\frac{h\\lambda}{2}(3y_n - y_{n-1}) = \\left(1 + \\frac{3z}{2}\\right)y_n - \\frac{z}{2}y_{n-1}$$\n\n2.  **求值 (E)**：使用预估值 $y_{n+1}^{(P)}$ 计算函数 $f$：\n    $$f_{n+1}^{(P)} = \\lambda y_{n+1}^{(P)}$$\n\n3.  **校正 (C)**：使用隐式梯形法则计算该步的最终值 $y_{n+1}$，通过使用 $f_{n+1}^{(P)}$ 使其显式化：\n    $$y_{n+1} = y_n + \\frac{h}{2}(f_{n+1}^{(P)} + f_n)$$\n    对于测试方程，这变为：\n    $$y_{n+1} = y_n + \\frac{h\\lambda}{2}(y_{n+1}^{(P)} + y_n) = \\left(1 + \\frac{z}{2}\\right)y_n + \\frac{z}{2}y_{n+1}^{(P)}$$\n\n4.  **求值 (E)**：执行最终的求值 $f_{n+1} = \\lambda y_{n+1}$，该值将在下一个积分步中使用（即用于计算 $y_{n+2}$）。\n\n为推导递推关系，我们将预估步骤中 $y_{n+1}^{(P)}$ 的表达式代入校正方程：\n$$y_{n+1} = \\left(1 + \\frac{z}{2}\\right)y_n + \\frac{z}{2}\\left[\\left(1 + \\frac{3z}{2}\\right)y_n - \\frac{z}{2}y_{n-1}\\right]$$\n$$y_{n+1} = \\left(1 + \\frac{z}{2} + \\frac{z}{2} + \\frac{3z^2}{4}\\right)y_n - \\frac{z^2}{4}y_{n-1}$$\n$$y_{n+1} = \\left(1 + z + \\frac{3z^2}{4}\\right)y_n - \\frac{z^2}{4}y_{n-1}$$\n\n这给出了齐次线性两步递推关系：\n$$y_{n+1} - \\left(1 + z + \\frac{3z^2}{4}\\right)y_n + \\frac{z^2}{4}y_{n-1} = 0$$\n\n为了分析稳定性，我们寻找形式为 $y_n = \\xi^n$ 的解。将其代入递推关系并除以 $\\xi^{n-1}$（对于 $\\xi \\neq 0$），得到特征多项式 $P(\\xi; z)$：\n$$P(\\xi; z) = \\xi^2 - \\left(1 + z + \\frac{3z^2}{4}\\right)\\xi + \\frac{z^2}{4} = 0$$\n该方法在给定 $z$ 处的稳定性由该二次方程的根 $\\xi_1(z)$ 和 $\\xi_2(z)$ 的模决定。根据问题定义，如果 $|\\xi_1(z)| \\le 1$ 且 $|\\xi_2(z)| \\le 1$，则该方法是绝对稳定的。规定如果根的模为 $1$，则视其为单根，因此稳定性区域边界上的点也包括在内。\n\n**稳定性查询（情况 1-6）：**\n我们通过计算 $z=h\\lambda$ 并求特征多项式的根来评估每对给定 $(\\lambda, h)$ 的稳定性。\n\n1.  $(\\lambda, h) = (-1, 0.5) \\implies z = -0.5$。多项式为 $\\xi^2 - 0.6875\\xi + 0.0625 = 0$。根为 $\\xi_1 \\approx 0.5797$ 和 $\\xi_2 \\approx 0.1078$。两个根的模都小于 $1$。稳定。\n2.  $(\\lambda, h) = (-1, 1.5) \\implies z = -1.5$。多项式为 $\\xi^2 - 1.1875\\xi + 0.5625 = 0$。根为共轭复数 $\\xi_{1,2} \\approx 0.59375 \\pm 0.45821i$。两个根的模为 $|\\xi| = \\sqrt{0.5625} = 0.75 < 1$。稳定。\n3.  $(\\lambda, h) = (-40, 0.05) \\implies z = -2.0$。多项式为 $\\xi^2 - 2\\xi + 1 = (\\xi-1)^2 = 0$。根为 $\\xi_1 = \\xi_2 = 1$。模恰好为 $1$。根据问题的稳定性定义，这被认为是稳定的。\n4.  $(\\lambda, h) = (-1+10i, 0.05) \\implies z = -0.05 + 0.5i$。多项式具有复系数。数值计算得出的根为 $\\xi_1 \\approx 0.6792 + 0.5255i$ 和 $\\xi_2 \\approx 0.0851 - 0.0630i$。模分别为 $|\\xi_1| \\approx 0.8588$ 和 $|\\xi_2| \\approx 0.1059$。两者均小于 $1$。稳定。\n5.  $(\\lambda, h) = (10i, 0.1) \\implies z = i$。多项式为 $\\xi^2 - (0.25+i)\\xi - 0.25 = 0$。数值计算得出的根为 $\\xi_1 \\approx 0.125 + 1.1408i$ 和 $\\xi_2 \\approx 0.125 - 0.1408i$。模分别为 $|\\xi_1| \\approx 1.1477$ 和 $|\\xi_2| \\approx 0.1883$。由于 $|\\xi_1| > 1$，该方法不稳定。\n6.  $(\\lambda, h) = (-3, 0) \\implies z = 0$。多项式为 $\\xi^2 - \\xi = 0$。根为 $\\xi_1 = 1$ 和 $\\xi_2 = 0$。两个根的模都小于或等于 $1$。稳定。\n\n**最大稳定步长（情况 7）：**\n我们需要找到负实轴上的稳定区间，即对于 $z \\in \\mathbb{R}_{\\le 0}$。稳定性边界是通过将根条件 $|\\xi_i| \\le 1$ 应用于实数 $z$ 的特征多项式来确定的。对于具有实系数的二阶多项式 $\\xi^2 - A\\xi + B = 0$，其根位于单位圆内的条件（Jury 稳定性判据）是：\n1. $P(1) = 1 - A + B \\ge 0$\n2. $P(-1) = 1 + A + B \\ge 0$\n3. $|B| \\le 1$\n\n对于我们的多项式，$A(z) = 1+z+\\frac{3z^2}{4}$ 且 $B(z) = \\frac{z^2}{4}$。\n1. $1 - (1+z+\\frac{3z^2}{4}) + \\frac{z^2}{4} = -z - \\frac{z^2}{2} = -z(1+\\frac{z}{2}) \\ge 0$。由于 $z \\le 0$，所以 $-z \\ge 0$。因此，我们需要 $1+\\frac{z}{2} \\ge 0 \\implies z \\ge -2$。\n2. $1 + (1+z+\\frac{3z^2}{4}) + \\frac{z^2}{4} = 2 + z + z^2$。这个二次多项式具有正的主导系数和复数根，因此对于实数 $z$ 它总是正的。此条件始终满足。\n3. $|\\frac{z^2}{4}| \\le 1 \\implies z^2 \\le 4 \\implies |z| \\le 2$。对于 $z \\le 0$，这等价于 $z \\ge -2$。\n\n综合这些条件，该方法在 $z \\in [-2, 0]$ 时是稳定的。\n给定 $\\lambda = -1 \\ \\mathrm{s}^{-1}$，我们有 $z = -h$。稳定性条件变为 $-2 \\le -h \\le 0$，可简化为 $0 \\le h \\le 2$。稳定步长的集合是 $[0, 2]$。\n最大稳定步长 $h_{\\max}$ 是此集合的上确界，即 $h_{\\max} = 2 \\ \\mathrm{s}$。要求的格式是四舍五入到 6 位小数的浮点数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by analyzing the stability of a PECE scheme\n    for a given set of parameters.\n    \"\"\"\n\n    # Test cases for stability queries (lambda, h)\n    # lambda is in 1/s, h is in s.\n    stability_test_cases = [\n        (-1.0, 0.5),           # Case 1\n        (-1.0, 1.5),           # Case 2\n        (-40.0, 0.05),         # Case 3\n        (-1.0 + 10.0j, 0.05),  # Case 4\n        (10.0j, 0.1),          # Case 5\n        (-3.0, 0.0),           # Case 6\n    ]\n\n    results = []\n\n    def is_stable(z):\n        \"\"\"\n        Checks the stability of the method for a given non-dimensional step z.\n        The characteristic polynomial is xi^2 - A*xi + B = 0.\n        \"\"\"\n        z = complex(z)  # Ensure z is treated as a complex number\n        \n        # Coefficients of the characteristic polynomial\n        A = 1 + z + 0.75 * z**2\n        B = 0.25 * z**2\n        \n        # Find the roots of the polynomial: xi^2 - A*xi + B = 0\n        coeffs = [1.0, -A, B]\n        roots = np.roots(coeffs)\n        \n        # The method is stable if all roots have magnitude <= 1.\n        # The problem states to assume roots with magnitude=1 are simple.\n        # A small tolerance is added to handle floating-point inaccuracies.\n        return np.all(np.abs(roots) <= 1.0 + 1e-9)\n\n    # Process stability queries\n    for lambda_val, h_val in stability_test_cases:\n        z = lambda_val * h_val\n        results.append(is_stable(z))\n\n    # Process maximum stable step size query (Case 7)\n    # For lambda = -1, the stability interval for z=h*lambda=-h is [-2, 0].\n    # This implies -2 <= -h <= 0, which means 0 <= h <= 2.\n    # The supremum h_max is therefore 2.0.\n    h_max = 2.0\n    results.append(f\"{h_max:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2371160"}, {"introduction": "在实践中，我们不仅需要理论上正确且稳定的方法，更追求高效的方法。本练习探讨了预测-校正方法在精度和计算成本之间的微妙权衡。通过比较不同阶的 Adams–Bashforth 预测子与一个固定的 Adams–Moulton 校正子的组合，你将学会基于“成本-精度”度量来评估数值格式，这是优化计算模拟的一项关键技能 [@problem_id:2410035]。", "problem": "实现一个程序，比较对于一个固定的 Adams–Moulton 三步校正子，三种不同预测子选择的成本-精度权衡。考虑由线性常微分方程 $y'(t)=\\lambda y(t)$、初始条件 $y(0)=1$ 在区间 $t\\in[0,T]$ 上定义的标量初值问题。其精确解为 $y(t)=\\exp(\\lambda t)$。对于下面的每个实验，使用均匀步长 $h$（使得 $T/h$ 为整数），并计算 $N=T/h$ 步。您必须比较三种预测-校正格式。这三种格式都使用单次校正步骤和三阶 Adams–Moulton (AM) 校正子，但预测子不同：分别是两步 Adams–Bashforth (AB2)、三步 Adams–Bashforth (AB3) 和四步 Adams–Bashforth (AB4)。此处，Adams–Bashforth (AB) 和 Adams–Moulton (AM) 代表标准的线性多步法。校正子是三阶 Adams–Moulton 方法。预测子则分别为二阶、三阶或四阶的 Adams–Bashforth 方法。\n\n对每个格式，采用以下成本模型。每一次右端函数 $f(t,y)=\\lambda y$ 的求值计为成本 $1$。为启动多步格式，在所需的过去网格点 $t_k=kh$ 处，使用 $y_k = \\exp(\\lambda t_k)$ 精确初始化所需的最少历史信息，并计算相应的 $f_k=f(t_k,y_k)$；将这些函数求值计入成本。此后的每一步，使用单次 Adams–Moulton 校正，执行恰好一次预测和一次校正。在此过程中，您必须在预测值处求值一次 $f$，在校正值处再求值一次 $f$。将这两次求值都计入成本。不对校正子执行任何进一步的迭代。令最终时刻的绝对全局误差为 $E=|y_N - \\exp(\\lambda T)|$，函数求值总成本为 $C$。\n\n定义成本归一化误差为 $E/C$。对于下面的每个测试用例，判断在使用 AB3 预测子和 AM3 校正子的情况下，其成本归一化误差是否在 AB2、AB3 和 AB4 三种选择中是最小的。如果一个方法达到了最小的 $E/C$ 值，则认为它在此意义上是最优的；如果出现平局，则选择预测子阶数最小的方法。\n\n测试套件。运行以下五个参数集，每个参数集指定为 $(\\lambda, T, h)$:\n- 案例 1: $(\\lambda, T, h)=(-1.0,\\,1.0,\\,0.05)$。\n- 案例 2: $(\\lambda, T, h)=(-10.0,\\,1.0,\\,0.02)$。\n- 案例 3: $(\\lambda, T, h)=(-1.0,\\,1.0,\\,0.01)$。\n- 案例 4: $(\\lambda, T, h)=(1.0,\\,1.0,\\,0.01)$。\n- 案例 5: $(\\lambda, T, h)=(-1.0,\\,1.0,\\,0.2)$。\n\n您的程序必须为每个案例生成一个布尔值，该值指示在成本归一化误差标准下 AB3 是否为最优。最终输出必须是单行，其中包含从案例 1 到案例 5 的五个布尔结果的列表，格式化为逗号分隔的 Python 风格列表，例如 $[b_1,b_2,b_3,b_4,b_5]$，其中每个 $b_i$ 为 $\\mathrm{True}$ 或 $\\mathrm{False}$。", "solution": "在尝试给出解决方案之前，问题陈述需要进行严格验证。\n\n**第 1 步：提取已知条件**\n\n- **微分方程：** $y'(t) = \\lambda y(t)$\n- **初始条件：** $y(0) = 1$\n- **区间：** $t \\in [0, T]$\n- **精确解：** $y(t) = \\exp(\\lambda t)$\n- **步长：** 均匀步长 $h$，使得 $N = T/h$ 为整数。\n- **校正子方法（固定）：** 三阶 Adams-Moulton (AM)。问题也称其为“三步校正子”，这造成了歧义。\n- **预测子方法（可变）：**\n    1.  两步 Adams-Bashforth (AB2)\n    2.  三步 Adams-Bashforth (AB3)\n    3.  四步 Adams-Bashforth (AB4)\n- **积分格式：** PECE（预测-求值-校正-求值）模式，带单次校正步骤。\n- **成本模型：**\n    - 单次函数求值 $f(t, y) = \\lambda y$ 的成本为 $1$。\n    - 初始化：对于一个需要直到 $t_k$ 的历史信息的方法，其值 $y_0, y_1, ..., y_k$ 取自精确解。成本包括对这些点中的每一个点进行一次函数求值，即计算 $f_0, f_1, ..., f_k$。\n    - 每一步：每个 PECE 步骤产生 $2$ 的成本（预测子一次求值，校正子一次求值）。\n- **度量指标：**\n    - 全局误差： $E = |y_N - \\exp(\\lambda T)|$\n    - 总成本：$C$，函数求值的总次数。\n    - 性能度量：成本归一化误差，$E/C$。\n- **目标：** 判断 AB3/AM 格式是否最优，即它是否产生最小的 $E/C$。\n- **平局决胜规则：** 如果多个方法产生相同的最小 $E/C$，则认为预测子阶数最小的那个方法最优。\n- **测试用例 $(\\lambda, T, h)$：**\n    1.  $(-1.0, 1.0, 0.05)$\n    2.  $(-10.0, 1.0, 0.02)$\n    3.  $(-1.0, 1.0, 0.01)$\n    4.  $(1.0, 1.0, 0.01)$\n    5.  $(-1.0, 1.0, 0.2)$\n\n**第 2 步：使用提取的已知条件进行验证**\n\n该问题具有科学依据、是适定的且客观的。它涉及求解常微分方程的标准数值方法。然而，问题陈述中存在一个微小的不一致之处。它指定了“一个固定的 Adams–Moulton 三步校正子”，同时又说“校正子是三阶 Adams–Moulton 方法”。\n\n- 一个标准的**三步** Adams-Moulton 方法 (AM3) 是**四阶**的。其公式为 $y_{n+1} = y_n + \\frac{h}{24}(9f_{n+1} + 19f_n - 5f_{n-1} + f_{n-2})$。\n- 一个标准的**三阶** Adams-Moulton 方法 (AM2) 是一个**两步**方法。其公式为 $y_{n+1} = y_n + \\frac{h}{12}(5f_{n+1} + 8f_n - f_{n-1})$。\n\n这是一个矛盾。严格的解释会使该问题无效。然而，由于“阶”是数值方法一个比“步数”（其计算方式可能不同）更基本且歧义更少的属性，我将假设“三阶”的规定是预期的设定。这是对该歧义的合理解释。\n\n**结论：** 该问题被认为是有效的，但这取决于对所指出歧义的解决。解决方案将基于三阶 Adams-Moulton 校正子。\n\n**第 3 步：构建解决方案**\n\n我们将实现三种预测-校正格式。所有格式都使用 PECE 模式，并以三阶 Adams-Moulton (AM2) 方法作为校正子。\n\n常微分方程为 $y' = f(t,y) = \\lambda y$。令 $y_n$ 为 $y(t_n)$ 在 $t_n = n h$ 处的数值近似，且 $f_n = f(t_n, y_n) = \\lambda y_n$。\n\n**校正子：三阶 Adams-Moulton (AM2，两步)**\n校正步骤使用预测的函数值 $f_{n+1}^{(p)} = f(t_{n+1}, y_{n+1}^{(p)})$ 计算最终值 $y_{n+1}$。\n$$ y_{n+1} = y_n + \\frac{h}{12} (5 f_{n+1}^{(p)} + 8 f_n - f_{n-1}) $$\n该方法需要历史值 $y_n$ 和 $f_n, f_{n-1}$。因此，它可以从 $n=1$ 开始应用以计算 $y_2$。\n\n我们根据它们的预测子来分析这三种格式。\n\n**格式 1：AB2 预测子 / AM2 校正子**\n预测子是二阶 Adams-Bashforth 方法（两步）：\n$$ y_{n+1}^{(p)} = y_n + \\frac{h}{2} (3 f_n - f_{n-1}) $$\n- **初始化：** 预测子需要 $f_0$ 和 $f_1$。校正子也需要直到索引 $1$ 的值。因此，我们必须精确地初始化 $y_0$ 和 $y_1$。\n  - $y_0 = y(0) = 1$。计算 $f_0 = \\lambda y_0$。成本: $1$。\n  - $y_1 = y(h) = \\exp(\\lambda h)$。计算 $f_1 = \\lambda y_1$。成本: $1$。\n  - 初始成本为 $2$。\n- **迭代：** 主循环从 $n=1$ 到 $N-1$ 运行，执行 $(N-1)$ 步。每步成本为 $2$。\n- **总成本 ($C_2$)：** $C_2 = 2 + 2(N-1) = 2N$。\n\n**格式 2：AB3 预测子 / AM2 校正子**\n预测子是三阶 Adams-Bashforth 方法（三步）：\n$$ y_{n+1}^{(p)} = y_n + \\frac{h}{12} (23 f_n - 16 f_{n-1} + 5 f_{n-2}) $$\n- **初始化：** 预测子需要 $f_0, f_1, f_2$。我们精确初始化 $y_0, y_1, y_2$。\n  - 计算 $f_0, f_1, f_2$。初始成本为 $3$。\n- **迭代：** 第一个要计算的值是 $y_3$。循环从 $n=2$ 到 $N-1$ 运行，执行 $(N-2)$ 步。\n- **总成本 ($C_3$)：** $C_3 = 3 + 2(N-2) = 2N - 1$。\n\n**格式 3：AB4 预测子 / AM2 校正子**\n预测子是四阶 Adams-Bashforth 方法（四步）：\n$$ y_{n+1}^{(p)} = y_n + \\frac{h}{24} (55 f_n - 59 f_{n-1} + 37 f_{n-2} - 9 f_{n-3}) $$\n- **初始化：** 预测子需要 $f_0, f_1, f_2, f_3$。我们精确初始化 $y_0, y_1, y_2, y_3$。\n  - 计算 $f_0, f_1, f_2, f_3$。初始成本为 $4$。\n- **迭代：** 第一个要计算的值是 $y_4$。循环从 $n=3$ 到 $N-1$ 运行，执行 $(N-3)$ 步。\n- **总成本 ($C_4$)：** $C_4 = 4 + 2(N-3) = 2N - 2$。\n\n**最优性条件**\n对于每个测试用例，我们计算成本归一化误差 $v_2 = E_2/C_2$、$v_3 = E_3/C_3$ 和 $v_4 = E_4/C_4$。当且仅当 AB3 格式的度量 $v_3$ 严格小于 $v_2$ 且小于或等于 $v_4$ 时，它被确定为最优。形式上，AB3 是最优的条件是：\n$$ (v_3  v_2) \\land (v_3 \\le v_4) $$\n这个逻辑包含了平局决胜规则，该规则偏好低阶预测子。如果 $v_3 = v_2$，则选择 AB2。如果 $v_3 = v_4$，则选择 AB3。\n\n将为每个测试用例实现该算法，以计算这三个度量指标并评估此条件。每个案例的最终结果将是一个布尔值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the experiments for each test case.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: (lambda, T, h)\n        (-1.0, 1.0, 0.05),\n        # Case 2\n        (-10.0, 1.0, 0.02),\n        # Case 3\n        (-1.0, 1.0, 0.01),\n        # Case 4\n        (1.0, 1.0, 0.01),\n        # Case 5\n        (-1.0, 1.0, 0.2),\n    ]\n\n    results = []\n    for params in test_cases:\n        v2 = run_predictor_corrector_scheme(predictor_order=2, params=params)\n        v3 = run_predictor_corrector_scheme(predictor_order=3, params=params)\n        v4 = run_predictor_corrector_scheme(predictor_order=4, params=params)\n\n        # Optimality condition for AB3: E/C is minimal.\n        # Tie-breaking rule: smallest predictor order wins.\n        # AB3 is optimal if (v3  v2) AND (v3 = v4).\n        is_ab3_optimal = (v3  v2) and (v3 = v4)\n        results.append(is_ab3_optimal)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_predictor_corrector_scheme(predictor_order, params):\n    \"\"\"\n    Runs a single predictor-corrector scheme for a given predictor order and parameters.\n\n    Args:\n        predictor_order (int): The order of the Adams-Bashforth predictor (2, 3, or 4).\n        params (tuple): A tuple containing (lambda, T, h).\n\n    Returns:\n        float: The cost-normalized error E/C.\n    \"\"\"\n    lam, T, h = params\n    N = int(round(T / h))\n    \n    # f(t, y) = lambda * y\n    f = lambda y_val: lam * y_val\n\n    # Arrays to store solution y and function evaluations f\n    y = np.zeros(N + 1, dtype=np.float64)\n    f_vals = np.zeros(N + 1, dtype=np.float64)\n    \n    # s is the number of steps for the predictor, which determines initialization\n    s = predictor_order\n\n    # Initialization\n    # Initialize minimal required history using exact solution y(t) = exp(lambda*t)\n    # The cost is 1 for each function evaluation.\n    cost = 0\n    for k in range(s):\n        tk = k * h\n        y[k] = np.exp(lam * tk)\n        f_vals[k] = f(y[k])\n        cost += 1\n\n    # Main PECE loop\n    # Loop starts after the initialized history, i.e., at n = s-1\n    for n in range(s - 1, N):\n        # P: Predict y_{n+1}\n        if predictor_order == 2: # AB2\n            y_pred = y[n] + (h / 2.0) * (3.0 * f_vals[n] - f_vals[n-1])\n        elif predictor_order == 3: # AB3\n            y_pred = y[n] + (h / 12.0) * (23.0 * f_vals[n] - 16.0 * f_vals[n-1] + 5.0 * f_vals[n-2])\n        elif predictor_order == 4: # AB4\n            y_pred = y[n] + (h / 24.0) * (55.0 * f_vals[n] - 59.0 * f_vals[n-1] + 37.0 * f_vals[n-2] - 9.0 * f_vals[n-3])\n        else:\n            raise ValueError(\"Unsupported predictor order.\")\n        \n        # E: Evaluate f at predicted value\n        f_pred = f(y_pred)\n        cost += 1\n        \n        # C: Correct y_{n+1} using AM2 (order 3)\n        y[n+1] = y[n] + (h / 12.0) * (5.0 * f_pred + 8.0 * f_vals[n] - f_vals[n-1])\n        \n        # E: Evaluate f at corrected value for the next step\n        f_vals[n+1] = f(y[n+1])\n        cost += 1\n        \n    # Calculate final error and cost-normalized error\n    y_exact_final = np.exp(lam * T)\n    error = np.abs(y[N] - y_exact_final)\n    \n    if cost == 0:\n        return float('inf')\n\n    return error / cost\n\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2410035"}]}