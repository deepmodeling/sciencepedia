{"hands_on_practices": [{"introduction": "许多工程和科学问题（例如化学反应动力学和电路模拟）都涉及“刚性”微分方程组。对于这类问题，像前向欧拉法这样的显式方法会遇到严重的稳定性限制，需要极小的步长才能避免数值解的爆炸。本练习将通过一个具体的编码示例，让您亲手对比前向欧拉法和后向欧拉法在求解刚性系统时的表现，直观地感受后向欧拉法强大的A-稳定性如何使其能够使用大得多的时间步长，从而高效地获得稳定解。[@problem_id:2372859]", "id": "2372859", "problem": "考虑由 $\\dot{x}(t)=A\\,x(t)$ 给出的线性自治常微分方程（ODE）组，其中 $A\\in\\mathbb{R}^{2\\times 2}$ 是一个常数矩阵，且 $x(t)\\in\\mathbb{R}^{2}$。将采用两种单步法进行时间推进。显式方法定义为 $x_{n+1}=x_{n}+h\\,A\\,x_{n}$，步长为 $h>0$。隐式方法定义为 $x_{n+1}=x_{n}+H\\,A\\,x_{n+1}$，步长为 $H>0$，当逆矩阵存在时，可等价地写为 $x_{n+1}=(I-H\\,A)^{-1}x_{n}$。\n\n您的任务是编写一个完整的程序，对下面指定的每个测试用例，在给定 $2\\times 2$ 矩阵 $A$、初始向量 $x_{0}$ 和小步长 $h$ 的情况下，执行以下操作：\n\n1. 从 $x_{0}$ 开始，使用更新规则 $x_{n+1}=x_{n}+h\\,A\\,x_{n}$，以步长 $h$ 计算 $N_{\\mathrm{FE}}$ 步的显式迭代，从而得到 $x_{\\mathrm{FE,final}}$。\n2. 定义大步长 $H=1000\\,h$。从 $x_{0}$ 开始，使用更新规则 $x_{n+1}=(I-H\\,A)^{-1}x_{n}$，以步长 $H$ 计算 $N_{\\mathrm{BE}}$ 步的隐式迭代，从而得到 $x_{\\mathrm{BE,final}}$。\n3. 设 $\\lVert\\cdot\\rVert$ 表示 $\\mathbb{R}^{2}$ 上的欧几里得范数。定义：如果 $\\lVert x_{\\mathrm{FE,final}}\\rVert>10\\,\\lVert x_{0}\\rVert$，则显式方法“爆炸”；如果 $\\lVert x_{\\mathrm{BE,final}}\\rVert<\\lVert x_{0}\\rVert$，则隐式方法“衰减”。对于每个用例，当且仅当这两个条件都成立时，输出一个为真的布尔值。\n\n使用以下测试套件：\n\n- 用例 $\\mathbf{1}$（理想情况，对角刚性系统）：\n  - $A=\\begin{bmatrix}-1&0\\\\0&-1000\\end{bmatrix}$,\n  - $x_{0}=\\begin{bmatrix}1\\\\1\\end{bmatrix}$,\n  - $h=0.003$,\n  - $H=1000\\,h=3$,\n  - $N_{\\mathrm{FE}}=12$,\n  - $N_{\\mathrm{BE}}=3$.\n- 用例 $\\mathbf{2}$（接近显式稳定性边界的边界条件）：\n  - $A=\\begin{bmatrix}-1&0\\\\0&-1000\\end{bmatrix}$,\n  - $x_{0}=\\begin{bmatrix}1\\\\1\\end{bmatrix}$,\n  - $h=0.002$,\n  - $H=1000\\,h=2$,\n  - $N_{\\mathrm{FE}}=12$,\n  - $N_{\\mathrm{BE}}=3$.\n- 用例 $\\mathbf{3}$（耦合刚性系统）：\n  - $A=\\begin{bmatrix}-1&100\\\\0&-1000\\end{bmatrix}$,\n  - $x_{0}=\\begin{bmatrix}1\\\\1\\end{bmatrix}$,\n  - $h=0.003$,\n  - $H=1000\\,h=3$,\n  - $N_{\\mathrm{FE}}=12$,\n  - $N_{\\mathrm{BE}}=3$.\n\n最终输出格式：您的程序应生成一行输出，其中按顺序包含三个用例的布尔结果，格式为方括号括起来的逗号分隔列表（例如，$[{\\rm True},{\\rm False},{\\rm True}]$）。不应打印任何其他文本。", "solution": "所述问题要求分析求解线性常微分方程组 $\\dot{x}(t) = A x(t)$ 的两种数值方法。这是计算工程和数值分析领域的一个标准问题。我将首先验证问题的陈述。\n\n### 第 1 步：提取已知条件\n\n已知条件如下：\n- ODE 系统：$\\dot{x}(t)=A\\,x(t)$，其中 $A\\in\\mathbb{R}^{2\\times 2}$ 且 $x(t)\\in\\mathbb{R}^{2}$。\n- 显式方法 (Forward Euler)：$x_{n+1}=x_{n}+h\\,A\\,x_{n} = (I + hA)x_n$，步长 $h>0$。\n- 隐式方法 (Backward Euler)：$x_{n+1}=x_{n}+H\\,A\\,x_{n+1}$，等价于 $x_{n+1}=(I-H\\,A)^{-1}x_{n}$，步长 $H>0$。\n- 大步长定义为 $H=1000\\,h$。\n- 显式方法“爆炸”的条件定义为 $\\lVert x_{\\mathrm{FE,final}}\\rVert>10\\,\\lVert x_{0}\\rVert$，其中 $\\lVert\\cdot\\rVert$ 是欧几里得范数。\n- 隐式方法“衰减”的条件定义为 $\\lVert x_{\\mathrm{BE,final}}\\rVert<\\lVert x_{0}\\rVert$。\n- 每个用例的最终布尔输出为真，当且仅当“爆炸”条件和“衰减”条件都成立。\n\n提供的测试用例如下：\n- **用例 1**：$A=\\begin{bmatrix}-1&0\\\\0&-1000\\end{bmatrix}$, $x_{0}=\\begin{bmatrix}1\\\\1\\end{bmatrix}$, $h=0.003$, $H=3$, $N_{\\mathrm{FE}}=12$, $N_{\\mathrm{BE}}=3$。\n- **用例 2**：$A=\\begin{bmatrix}-1&0\\\\0&-1000\\end{bmatrix}$, $x_{0}=\\begin{bmatrix}1\\\\1\\end{bmatrix}$, $h=0.002$, $H=2$, $N_{\\mathrm{FE}}=12$, $N_{\\mathrm{BE}}=3$。\n- **用例 3**：$A=\\begin{bmatrix}-1&100\\\\0&-1000\\end{bmatrix}$, $x_{0}=\\begin{bmatrix}1\\\\1\\end{bmatrix}$, $h=0.003$, $H=3$, $N_{\\mathrm{FE}}=12$, $N_{\\mathrm{BE}}=3$。\n\n### 第 2 步：使用提取的已知条件进行验证\n\n该问题有科学依据、客观且适定。\n- **有科学依据**：该问题探讨了刚性常微分方程数值稳定性的基本概念，比较了条件稳定的 Forward Euler 方法和 A-稳定的 Backward Euler 方法。这些都是数值分析中的经典课题。\n- **适定性**：对于每个测试用例，所有参数（$A$, $x_0$, $h$, $H$, $N_{\\mathrm{FE}}$, $N_{\\mathrm{BE}}$）都有精确的定义。“爆炸”和“衰减”的标准明确无误。每个用例都存在唯一的结果。对于所有提供的用例，矩阵 $(I-HA)$ 都是可逆的，因为 $HA$ 的特征值不等于 $1$。\n- **客观性**：该问题以客观的数学语言陈述，没有任何主观解释的余地。\n\n### 第 3 步：结论与行动\n\n问题有效。我将继续提供完整解答。\n\n这个问题的核心在于刚性系统的数值稳定性概念。如果矩阵 $A$ 的特征值实部均为非正数，且数值上相差几个数量级，则系统 $\\dot{x}=Ax$ 被认为是刚性的。数值方法的稳定性由其放大因子 $G$ 决定，该因子控制着数值解的传播：$x_{n+1} = G x_n$。为使解保持有界，放大因子的谱半径 $\\rho(G)$ 必须满足 $\\rho(G) \\le 1$。\n\n对于显式 Forward Euler 方法，放大矩阵为 $G_{\\mathrm{FE}} = I + hA$。稳定性条件是 $\\rho(I+hA) \\le 1$，这对于 $A$ 的所有特征值 $\\lambda_i$ 转化为 $|1+h\\lambda_i| \\le 1$。这为乘积 $h\\lambda$ 在复平面上定义了一个稳定域。对于稳定系统（其中 $\\mathrm{Re}(\\lambda_i) \\le 0$），该方法只是条件稳定的；它要求步长 $h$ 足够小，通常受模最大的特征值的限制。\n\n对于隐式 Backward Euler 方法，放大矩阵为 $G_{\\mathrm{BE}} = (I - HA)^{-1}$。稳定性条件是 $\\rho((I-HA)^{-1}) \\le 1$，这对于 $A$ 的所有特征值 $\\lambda_i$ 转化为 $|(1-H\\lambda_i)^{-1}| \\le 1$。只要 $\\mathrm{Re}(\\lambda_i) \\leq 0$，对于任何 $H > 0$ 该条件都满足。此性质被称为 A-稳定性，使得该方法对于刚性系统是无条件稳定的。它允许使用大得多的步长 $H$ 而不会出现数值不稳定性，这在计算上是有利的。\n\n现在，我们来分析每个用例。\n\n**用例 1**：$A=\\begin{bmatrix}-1&0\\\\0&-1000\\end{bmatrix}$。特征值为 $\\lambda_1 = -1$ 和 $\\lambda_2 = -1000$。步长为 $h=0.003$。\n- **Forward Euler**：我们检查稳定性条件 $|1+h\\lambda_i| \\le 1$。\n  - 对于 $\\lambda_1 = -1$：$|1 + (0.003)(-1)| = |0.997| = 0.997 \\le 1$。此分量是稳定的。\n  - 对于 $\\lambda_2 = -1000$：$|1 + (0.003)(-1000)| = |1 - 3| = |-2| = 2 > 1$。此分量是不稳定的。\n  由于不稳定的模式，数值解将呈指数增长，我们预期在 $N_{\\mathrm{FE}}=12$ 步后，“爆炸”条件会得到满足。\n- **Backward Euler**：步长为 $H=3$。该方法是 A-稳定的。特征模式的放大因子为：\n  - 对于 $\\lambda_1 = -1$：$|(1 - (3)(-1))^{-1}| = |1/4| = 0.25 < 1$。此分量被强衰减。\n  - 对于 $\\lambda_2 = -1000$：$|(1 - (3)(-1000))^{-1}| = |1/3001| \\approx 3.33 \\times 10^{-4} < 1$。此分量被非常强地衰减。\n  解向量的范数将会减小。因此，我们预期“衰减”条件会得到满足。\n- **结论**：预计两个条件都为真。用例1的结果是 `True`。\n\n**用例 2**：$A=\\begin{bmatrix}-1&0\\\\0&-1000\\end{bmatrix}$。特征值为 $\\lambda_1 = -1$ 和 $\\lambda_2 = -1000$。步长为 $h=0.002$。\n- **Forward Euler**：我们检查稳定性条件 $|1+h\\lambda_i| \\le 1$。\n  - 对于 $\\lambda_1 = -1$：$|1 + (0.002)(-1)| = |0.998| = 0.998 \\le 1$。此分量是稳定的。\n  - 对于 $\\lambda_2 = -1000$：$|1 + (0.002)(-1000)| = |1 - 2| = |-1| = 1 \\le 1$。该分量处于稳定域的边界上。\n  解的范数不会指数增长。解的第二个分量将以恒定振幅振荡，而第一个分量则衰减。总范数预计不会增长 10 倍。“爆炸”条件将为假。\n- **Backward Euler**：步长为 $H=2$。该方法是 A-稳定的。\n  - 对于 $\\lambda_1 = -1$ 的放大因子：$|(1 - (2)(-1))^{-1}| = |1/3| < 1$。\n  - 对于 $\\lambda_2 = -1000$ 的放大因子：$|(1 - (2)(-1000))^{-1}| = |1/2001| < 1$。\n  解将被衰减。\n- **结论**：“爆炸”条件为假，因此组合条件为假。用例2的结果是 `False`。\n\n**用例 3**：$A=\\begin{bmatrix}-1&100\\\\0&-1000\\end{bmatrix}$。这是一个上三角矩阵，所以其特征值是其对角线上的元素：$\\lambda_1 = -1$ 和 $\\lambda_2 = -1000$。步长为 $h=0.003$。\n- **Forward Euler**：稳定性分析仅取决于特征值，与用例1中的特征值相同。当 $h=0.003$ 时，特征值 $\\lambda_2 = -1000$ 导致 $|1 + (0.003)(-1000)| = 2 > 1$，因此方法是不稳定的。耦合项 $A_{12}=100$ 会将能量从不稳定模式传递到稳定模式，但整体解将由不稳定特征分量的指数增长主导。预期“爆炸”条件会得到满足。\n- **Backward Euler**：步长为 $H=3$。该方法是 A-稳定的，与耦合无关。放大因子由特征值决定，与用例1中的相同。解将被“衰减”。\n- **结论**：预计两个条件都为真。用例3的结果是 `True`。\n\n总而言之，理论分析预测三个用例的结果分别为 `True`、`False` 和 `True`。下面的程序将执行直接数值模拟来验证这一结论。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the given problem by simulating two numerical methods for a system of ODEs\n    and checking for specific stability-related conditions.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"A\": np.array([[-1, 0], [0, -1000]]),\n            \"x0\": np.array([1, 1]),\n            \"h\": 0.003,\n            \"N_FE\": 12,\n            \"N_BE\": 3\n        },\n        {\n            \"A\": np.array([[-1, 0], [0, -1000]]),\n            \"x0\": np.array([1, 1]),\n            \"h\": 0.002,\n            \"N_FE\": 12,\n            \"N_BE\": 3\n        },\n        {\n            \"A\": np.array([[-1, 100], [0, -1000]]),\n            \"x0\": np.array([1, 1]),\n            \"h\": 0.003,\n            \"N_FE\": 12,\n            \"N_BE\": 3\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        A = case[\"A\"]\n        x0 = case[\"x0\"].astype(float)\n        h = case[\"h\"]\n        N_FE = case[\"N_FE\"]\n        N_BE = case[\"N_BE\"]\n        \n        # The large stepsize H is defined as 1000*h\n        H = 1000 * h\n\n        # Calculate initial norm\n        norm_x0 = np.linalg.norm(x0)\n\n        # 1. Explicit method (Forward Euler) simulation\n        x_fe = x0.copy()\n        for _ in range(N_FE):\n            x_fe = x_fe + h * (A @ x_fe)\n        \n        norm_fe_final = np.linalg.norm(x_fe)\n        explodes = norm_fe_final > 10 * norm_x0\n\n        # 2. Implicit method (Backward Euler) simulation\n        x_be = x0.copy()\n        # Pre-compute the inverse of (I - H*A)\n        # I is the 2x2 identity matrix\n        I = np.identity(2)\n        inv_mat_be = np.linalg.inv(I - H * A)\n        \n        for _ in range(N_BE):\n            x_be = inv_mat_be @ x_be\n        \n        norm_be_final = np.linalg.norm(x_be)\n        damped = norm_be_final < norm_x0\n        \n        # 3. Check if both conditions hold\n        results.append(explodes and damped)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "后向欧拉法的稳定性优势源于其“隐式”特性，即在每个时间步中，需要求解一个包含未来状态 $y_{n+1}$ 的方程。这就引出了一个实际问题：我们如何有效地求解这个隐式方程？本练习将引导您从理论层面进行实践，通过分析简单的不动点迭代法，推导出保证迭代求解过程收敛的时间步长条件，从而揭示数值方法的稳定性和其内部求解器收敛性之间的重要联系。[@problem_id:2372866]", "id": "2372866", "problem": "考虑自治常微分方程 (ODE) $\\frac{dy}{dt} = f(y)$ 的后向欧拉时间离散，其中 $f:\\mathbb{R}\\to\\mathbb{R}$。假定在一个包含所有正在考虑的迭代值的闭凸集上，$f$ 是 Lipschitz 连续的，其 Lipschitz 常数为 $L>0$。从已知状态 $y_n$ 出发，使用时间步长 $h>0$ 的一个后向欧拉步需要求解隐式方程\n$$\ny_{n+1} = y_n + h\\, f\\!\\left(y_{n+1}\\right).\n$$\n假设此隐式方程通过简单不动点迭代\n$$\nz^{(k+1)} = y_n + h\\, f\\!\\left(z^{(k)}\\right), \\quad k=0,1,2,\\dots,\n$$\n求解，并使用同一集合中的任意 $z^{(0)}$ 进行初始化。\n\n请确定最大允许时间步长 $h_{\\max}$（表示为 $L$ 的函数），该步长能保证对于集合中任意选择的初始迭代值 $z^{(0)}$，此不动点迭代均收敛。请仅用 $L$ 将最终答案表示为一个闭式表达式。不要包含单位，也不要以不等式或方程的形式报告。", "solution": "不动点迭代可写作 $z^{(k+1)} = G\\!\\left(z^{(k)}\\right)$，其中迭代映射 $G$ 定义为\n$$\nG(z) \\equiv y_n + h\\, f(z).\n$$\n为保证对于集合中的任意初始迭代值该迭代都能收敛，$G$ 是该集合上的一个压缩映射是充分条件。根据压缩映射的定义，$G$ 必须满足\n$$\n|G(u)-G(v)| \\leq q\\, |u-v| \\quad \\text{对于集合中所有的 } u,v \\text{，且 } q \\in [0,1).\n$$\n利用 $f$ 的 Lipschitz 连续性（常数为 $L$），我们估计 $G$ 的 Lipschitz 常数：\n$$\n|G(u)-G(v)| = |y_n + h f(u) - (y_n + h f(v))| = h\\, |f(u)-f(v)| \\leq h\\, L\\, |u-v|.\n$$\n因此，如果其 Lipschitz 因子 $h\\,L$ 满足\n$$\nh\\,L < 1.\n$$\n则 $G$ 是一个压缩映射。这个严格不等式刻画了能使迭代对集合中任意初始迭代值都收敛的时间步长 $h$。因此，在所有可允许的 $h$ 的上确界的意义上，最大允许时间步长是使压缩常数等于 $1$ 的边界值，即\n$$\nh_{\\max} = \\frac{1}{L}.\n$$\n注意，当 $h = \\frac{1}{L}$ 时，该映射不再是严格压缩（其 Lipschitz 因子等于 $1$），因此收敛性保证要求 $h < \\frac{1}{L}$。然而，题目所要求的作为 $L$ 的函数的最大允许时间步长（即这类 $h$ 的上确界）是 $h_{\\max} = \\frac{1}{L}$。", "answer": "$$\\boxed{\\frac{1}{L}}$$"}, {"introduction": "掌握了后向欧拉法这样稳定的工具后，我们很容易认为可以随意使用非常大的时间步长来加速计算。然而，稳定性并不等同于准确性。这个最后的练习将通过一个放射性衰变的模拟，让您亲身体会这一关键区别：虽然使用大步长的后向欧拉法能够保持解的稳定，但对于系统中衰变较慢（非刚性）的组分，其计算结果的精度可能会严重下降。这个练习强调了在选择时间步长时，必须在稳定性、准确性和计算成本之间进行权衡。[@problem_id:2372906]", "id": "2372906", "problem": "考虑一个双同位素、非耦合的放射性衰变模型，该模型由以下常微分方程(ODE)组描述\n$$\n\\frac{dc_f}{dt} = -\\lambda_f\\,c_f,\\qquad \\frac{dc_s}{dt} = -\\lambda_s\\,c_s,\n$$\n其初始条件为\n$$\nc_f(0)=c_{f,0},\\qquad c_s(0)=c_{s,0},\n$$\n其中 $c_f$ 和 $c_s$ 分别表示快衰变和慢衰变同位素的浓度，$\\lambda_f$ 和 $\\lambda_s$ 为正衰变率，且 $\\lambda_f > \\lambda_s$。每种同位素的精确解为\n$$\nc_f(t)=c_{f,0}\\,e^{-\\lambda_f t},\\qquad c_s(t)=c_{s,0}\\,e^{-\\lambda_s t}.\n$$\n你需要使用 Backward Euler (BE) 方法，以恒定的时间步长 $h$ 从 $t=0$ 到最终时间 $t=T$ 对解进行近似。假设 $T/h$ 是一个整数，因此总共执行 $N=T/h$ 步。所有量都是无量纲的；不要在任何数值后附加单位。\n\n对于每个测试用例，计算慢同位素分量的以下两个量：\n1. 应用于慢分量的单步映射的稳定性指标 $s$，定义为：如果每步放大因子的模小于或等于 $1$，则 $s=1$，否则 $s=0$。\n2. 在时间 $T$ 的绝对误差 $E=\\lvert c_s^{\\text{BE}}(T)-c_s^{\\text{exact}}(T)\\rvert$。\n\n使用以下参数集测试套件 $(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)$：\n- 测试 A: $(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)=(\\$10\\$,\\$0.1\\$,\\$1\\$,\\$1\\$,\\$1\\$,\\$5\\$)$。\n- 测试 B: $(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)=(\\$50\\$,\\$0.2\\$,\\$2\\$,\\$2\\$,\\$10\\$,\\$50\\$)$。\n- 测试 C: $(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)=(\\$1\\$,\\$0.01\\$,\\$3\\$,\\$1\\$,\\$100\\$,\\$100\\$)$。\n- 测试 D: $(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)=(\\$5\\$,\\$10^{-6}\\$,\\$1\\$,\\$1.5\\$,\\$10^{6}\\$,\\$10^{6}\\$)$。\n\n你的程序应产生单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。每个测试用例贡献一个双元素列表 $[s,E]$，其中 $s$ 是一个整数，$E$ 是一个浮点数。最终输出格式必须为\n$$\n[\\,[s_A,E_A],[s_B,E_B],[s_C,E_C],[s_D,E_D]\\,],\n$$\n测试用例分别按 A, B, C, D 的顺序排列，且不得包含额外的空格或文本。例如，使用占位符值的输出将如下所示\n$$\n[[1,0.0],[1,0.0],[1,0.0],[1,0.0]].\n$$", "solution": "对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- **控制方程**：用于放射性衰变的两个非耦合常微分方程(ODE)组：\n$$\n\\frac{dc_f}{dt} = -\\lambda_f\\,c_f,\\qquad \\frac{dc_s}{dt} = -\\lambda_s\\,c_s\n$$\n- **初始条件**：$c_f(0)=c_{f,0}$ 和 $c_s(0)=c_{s,0}$。\n- **参数**：$c_f$ 和 $c_s$ 是浓度。$\\lambda_f$ 和 $\\lambda_s$ 是正衰变率，且 $\\lambda_f > \\lambda_s$。\n- **精确解**：$c_f(t)=c_{f,0}\\,e^{-\\lambda_f t}$ 和 $c_s(t)=c_{s,0}\\,e^{-\\lambda_s t}$。\n- **数值方法**：Backward Euler (BE) 方法，时间步长 $h$ 恒定，从 $t=0$ 到 $t=T$。$N=T/h$ 是一个整数。\n- **待计算的量**：对于慢同位素分量 ($c_s$)：\n    1. 稳定性指标 $s$：如果每步放大因子的模小于或等于 $1$，则 $s=1$；否则 $s=0$。\n    2. 在最终时间 $T$ 的绝对误差 $E=\\lvert c_s^{\\text{BE}}(T)-c_s^{\\text{exact}}(T)\\rvert$。\n- **测试用例**：\n    - 测试 A: $(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)=(\\$10\\$,\\$0.1\\$,\\$1\\$,\\$1\\$,\\$1\\$,\\$5\\$)$\n    - 测试 B: $(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)=(\\$50\\$,\\$0.2\\$,\\$2\\$,\\$2\\$,\\$10\\$,\\$50\\$)$\n    - 测试 C: $(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)=(\\$1\\$,\\$0.01\\$,\\$3\\$,\\$1\\$,\\$100\\$,\\$100\\$)$\n    - 测试 D: $(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)=(\\$5\\$,\\$10^{-6}\\$,\\$1\\$,\\$1.5\\$,\\$10^{6}\\$,\\$10^{6}\\$)$\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据，使用经典的数值方法 (Backward Euler) 对一个标准的物理过程（放射性衰变）进行建模。该问题是适定的、客观的且自洽的。所有必要的数据均已提供，且没有内部矛盾。对于每个测试用例，比率 $T/h$ 均如陈述所述为整数。该问题是常微分方程数值分析中的一个标准练习。注意到存在快衰变同位素 ($c_f$, $\\lambda_f$) 的参数，但由于该常微分方程组是非耦合的，这些参数与所要求的慢衰变同位素 ($c_s$) 的计算无关。这不构成缺陷，而是考验对系统是否能正确理解。\n\n**步骤 3：结论与行动**\n问题有效。将提供解决方案。\n\n该问题要求分析由以下 ODE 控制的慢衰变同位素的浓度 $c_s$：\n$$\n\\frac{dc_s}{dt} = -\\lambda_s c_s\n$$\n初始条件为 $c_s(0) = c_{s,0}$。与快衰变同位素 $c_f$ 相关的参数对于本任务是无关的，因为两个 ODE 是非耦合的。\n\n我们将应用 Backward Euler 方法。设 $c_s^n$ 为在时间 $t_n = n h$ 时 $c_s(t_n)$ 的数值近似，其中 $h$ 是时间步长。该 ODE 的 Backward Euler 离散化形式为：\n$$\n\\frac{c_s^{n+1} - c_s^n}{h} = -\\lambda_s c_s^{n+1}\n$$\n为找到更新规则，我们求解 $c_s^{n+1}$：\n$$\nc_s^{n+1}(1 + h\\lambda_s) = c_s^n\n$$\n$$\nc_s^{n+1} = \\left(\\frac{1}{1 + h\\lambda_s}\\right) c_s^n\n$$\n这个方程定义了从一个时间层级到下一个的单步映射。\n\n**1. 稳定性指标 $s$**\n每步放大因子 $g$ 是将上一步的解相乘以获得当前步解的项：\n$$\ng = \\frac{1}{1 + h\\lambda_s}\n$$\n该方法的稳定性取决于该因子的大小 $|g|$。问题陈述，如果 $|g| \\le 1$，则稳定性指标 $s$ 为 $1$，否则为 $0$。\n根据问题给出的条件，衰变率 $\\lambda_s$ 为正，时间步长 $h$ 也为正。因此，它们的乘积 $h\\lambda_s$ 严格为正。这意味着：\n$$\n1 + h\\lambda_s > 1\n$$\n$$\n0 < \\frac{1}{1 + h\\lambda_s} < 1\n$$\n因此，放大因子 $g$ 满足 $0 < g < 1$，这意味着其模 $|g|$ 总是小于 $1$，无论 $h > 0$ 和 $\\lambda_s > 0$ 的选择如何。这是 Backward Euler 方法应用于此类问题时众所周知的 A-稳定性 属性。因此，对于所有指定的测试用例，稳定性条件都得到满足，稳定性指标 $s$ 将为 1。\n\n**2. 绝对误差 $E$**\n为了找到最终时间 $T$ 的数值解，我们应用单步映射 $N$ 次，其中 $N=T/h$。从初始条件 $c_s^0 = c_{s,0}$ 开始，我们得到一个等比级数：\n$$\nc_s^N = g^N c_s^0 = \\left(\\frac{1}{1 + h\\lambda_s}\\right)^N c_{s,0}\n$$\n因此，在 $t=T$ 时的数值解为：\n$$\nc_s^{\\text{BE}}(T) = c_{s,0} \\left(\\frac{1}{1 + h\\lambda_s}\\right)^{T/h}\n$$\n在 $t=T$ 时的精确解由下式给出：\n$$\nc_s^{\\text{exact}}(T) = c_{s,0} e^{-\\lambda_s T}\n$$\n绝对误差 $E$ 是在 $t=T$ 时数值解与精确解之差的模：\n$$\nE = \\lvert c_s^{\\text{BE}}(T) - c_s^{\\text{exact}}(T) \\rvert = \\left| c_{s,0} \\left(\\frac{1}{1 + h\\lambda_s}\\right)^{T/h} - c_{s,0} e^{-\\lambda_s T} \\right|\n$$\n由于所有测试用例中的 $c_{s,0}$ 都为正，我们可以写成：\n$$\nE = c_{s,0} \\left| \\left(\\frac{1}{1 + h\\lambda_s}\\right)^{T/h} - e^{-\\lambda_s T} \\right|\n$$\n这些公式被应用于每个测试用例，以计算所需的数对 $[s, E]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes stability indicator and absolute error for a radioactive decay\n    model using the Backward Euler method for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (lambda_f, lambda_s, c_f0, c_s0, h, T)\n    test_cases = [\n        (10.0, 0.1, 1.0, 1.0, 1.0, 5.0),          # Test A\n        (50.0, 0.2, 2.0, 2.0, 10.0, 50.0),         # Test B\n        (1.0, 0.01, 3.0, 1.0, 100.0, 100.0),       # Test C\n        (5.0, 1e-6, 1.0, 1.5, 1e6, 1e6),           # Test D\n    ]\n\n    # Store formatted results for each test case\n    formatted_results = []\n    \n    for case in test_cases:\n        # Unpack parameters. The fast-decaying isotope parameters (lambda_f, c_f0)\n        # are not used as the system is uncoupled.\n        _lambda_f, lambda_s, _c_f0, c_s0, h, T = case\n\n        # 1. Compute the stability indicator s\n        # The amplification factor for Backward Euler on dc/dt = -lambda*c is g = 1 / (1 + h*lambda).\n        # Since lambda_s > 0 and h > 0, g is always between 0 and 1.\n        # Thus, the method is unconditionally stable, and s=1 for all cases.\n        amplification_factor = 1.0 / (1.0 + h * lambda_s)\n        s = 1 if np.abs(amplification_factor) <= 1.0 else 0\n\n        # 2. Compute the absolute error E at time T\n        \n        # The problem statement guarantees N = T/h is an integer.\n        N = int(T / h)\n\n        # Numerical solution using Backward Euler after N steps\n        c_s_be = c_s0 * (amplification_factor ** N)\n\n        # Exact solution at time T\n        c_s_exact = c_s0 * np.exp(-lambda_s * T)\n\n        # Absolute error\n        error_E = np.abs(c_s_be - c_s_exact)\n        \n        # Format the result pair as a string \"[s,E]\"\n        formatted_results.append(f\"[{s},{error_E}]\")\n\n    # Final print statement in the exact required format.\n    # e.g., [[s_A,E_A],[s_B,E_B],...]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}]}