{"hands_on_practices": [{"introduction": "本练习通过经典的弹跳球示例，向你介绍事件检测的基本概念。你将构建一个模拟，它结合了重力作用下的连续运动和离散的碰撞事件，从中学习如何精确定位事件并实现状态重置规则。此实践是理解如何为混合动力系统建模的关键，在这类系统中，连续的演化会被瞬时变化所打断 [@problem_id:2390118]。", "problem": "要求您设计并实现一个完整的、可运行的程序，该程序在数值时间积分中使用事件检测来模拟一维弹跳球。垂直位置由 $y(t)$ 表示，地面位于 $y(t)=0$ 处，且向上的方向为正方向。碰撞之间的主导运动由牛顿第二定律和速度的定义给出，即以下常微分方程（ODE）组：\n$$\n\\frac{dy}{dt} = v, \\quad \\frac{dv}{dt} = -g,\n$$\n其中 $g>0$ 是恒定的重力加速度。当事件函数 $h(t,y,v)=y$ 从正值穿越零点时，发生碰撞事件，这意味着约束 $y(t)=0$ 在从上方接近的条件下被满足。在每次碰撞时，垂直速度会发生瞬时跳变，而位置保持连续。设 $v^{-}<0$ 为碰撞前瞬间的垂直速度，$v^{+}>0$ 为碰撞后瞬间的速度。该跳变定律由恢复系数 $e(\\,\\cdot\\,)$ 决定，该系数依赖于碰撞前速度的大小，其具有物理动机的模型如下：\n$$\ne(s) \\;=\\; e_{\\min} \\;+\\; \\left(e_{\\max}-e_{\\min}\\right) \\exp\\!\\left(-\\frac{s}{v_c}\\right), \\quad s\\ge 0,\n$$\n其中 $0<e_{\\min}<e_{\\max}<1$ 和 $v_c>0$ 是参数。跳变定律为：\n$$\nv^{+} \\;=\\; -\\,e\\!\\left(\\left|v^{-}\\right|\\right)\\, v^{-}.\n$$\n在连续碰撞之间，解会随时间向前积分，直到发生下一次从上方接近的 $y(t)=0$ 事件，或者直到达到指定的最终时间 $T_{\\text{end}}$。为避免无限次的衰减反弹，当计算出的碰撞后速度 $v^{+}$ 小于一个小的阈值 $v_{\\text{stop}}>0$（单位：$\\text{m}/\\text{s}$）时，假定球在模拟的剩余时间内粘在地面上，即此后它保持在 $y(t)=0$ 且 $v(t)=0$。\n\n从上述基本定律出发，实现一个鲁棒的、带事件检测的时间积分方法，该方法：\n- 对 $y(t)$ 使用根查找事件，以高精度地检测和定位碰撞。\n- 在每次碰撞时，使用给定的 $e(\\,\\cdot\\,)$ 更新速度。\n- 以分段方式继续积分，直到达到 $T_{\\text{end}}$ 或发生粘滞。\n\n您的程序必须为下面的测试套件中的每个测试用例计算：\n- 在时间 $t \\le T_{\\text{end}}$ 内发生的碰撞整数次数。\n- 最终高度 $y(T_{\\text{end}})$，单位为米，表示为小数点后六位数。\n- 在 $T_{\\text{end}}$ 或之前发生的最后一次碰撞的时间，单位为秒，表示为小数点后六位数。如果在 $T_{\\text{end}}$ 之前没有发生碰撞，则此值返回 $-1.000000$。\n\n使用国际单位制（SI单位）：$y$ 的单位是米，$v$ 的单位是米/秒，$t$ 的单位是秒。重力加速度为 $g=9.81\\,\\text{m}/\\text{s}^2$。本问题不使用角度。所有数值答案必须按规定以SI单位报告。您的算法应确保事件时间和状态的计算具有足够的精度，以使四舍五入到小数点后六位是有意义的。\n\n测试套件（每个用例以元组 $(y_0,v_0,e_{\\min},e_{\\max},v_c,T_{\\text{end}},v_{\\text{stop}})$ 的形式给出）：\n- 用例 1：$(10.0,\\,0.0,\\,0.2,\\,0.9,\\,2.0,\\,2.2,\\,10^{-3})$。\n- 用例 2：$(50.0,\\,0.0,\\,0.1,\\,0.8,\\,1.0,\\,3.4,\\,10^{-3})$。\n- 用例 3：$(0.001,\\,0.0,\\,0.3,\\,0.9,\\,0.5,\\,0.1,\\,10^{-3})$。\n- 用例 4：$(1.0,\\,5.0,\\,0.2,\\,0.9,\\,2.0,\\,0.1,\\,10^{-3})$。\n\n对于每个测试用例，程序必须生成一个结果三元组 $[N,\\,Y,\\,T]$，其中 $N$ 是直到（并包括）$T_{\\text{end}}$ 的碰撞整数次数，$Y$ 是最终高度 $y(T_{\\text{end}})$（单位为米，四舍五入到小数点后六位），$T$ 是在 $T_{\\text{end}}$ 或之前发生的最后一次碰撞的时间（单位为秒，四舍五入到小数点后六位，如果没有碰撞则为 $-1.000000$）。您的程序应生成一行输出，其中包含所有测试用例的结果，形式为一个用方括号括起来的逗号分隔列表，每个内部三元组也用方括号括起来，并且浮点数值使用标准十进制表示法，小数点后恰好有六位数字。例如： \"[[N1,Y1,T1],[N2,Y2,T2],[N3,Y3,T3],[N4,Y4,T4]]\"。", "solution": "所提出的问题是一个针对混合动力系统的良定义初值问题，这是计算工程中的一种常见范式。它以牛顿力学为科学基础，涉及由离散事件中断的分段连续演化。该问题是有效的，并存在唯一、可验证的解。\n\n**1. 连续动力学：解析轨迹**\n在碰撞之间，运动由以下线性常微分方程（ODE）组控制：\n$$\n\\frac{dy}{dt} = v, \\quad \\frac{dv}{dt} = -g\n$$\n其中 $g = 9.81 \\, \\text{m}/\\text{s}^2$ 是重力加速度。对于从时间 $t_k$ 开始、初始状态为 $(y(t_k), v(t_k)) = (y_k, v_k)$ 的一段运动，该方程组有精确的解析解。对时间积分方程，可得出对于任何 $t \\ge t_k$ 的速度和位置：\n$$\nv(t) = v_k - g(t - t_k)\n$$\n$$\ny(t) = y_k + v_k(t - t_k) - \\frac{1}{2}g(t - t_k)^2\n$$\n该轨迹在 $y-t$ 平面中是一条抛物线。鉴于此解析解的简洁性和精确性，使用如龙格-库塔法之类的通用数值常微分方程积分器是不必要的，并且会引入可避免的离散化误差。我们的算法将利用此精确解来获得更高的精度和效率。\n\n**2. 离散事件：碰撞检测与处理**\n碰撞事件定义为当事件函数 $h(t, y, v) = y$ 从正值穿越零点时发生。利用解析轨迹，我们可以通过求解 $y(t) = 0$ 来精确确定下一次碰撞的时间。设 $\\Delta t = t - t_k$ 为自当前飞行段开始以来经过的时间。我们必须求解以下二次方程：\n$$\n\\frac{1}{2}g(\\Delta t)^2 - v_k \\Delta t - y_k = 0\n$$\n对于时间正向演化（$\\Delta t > 0$），其物理上有意义的解是：\n$$\n\\Delta t_{\\text{impact}} = \\frac{v_k + \\sqrt{v_k^2 + 2gy_k}}{g}\n$$\n因此，下一次碰撞的时间为 $t_{k+1} = t_k + \\Delta t_{\\text{impact}}$。\n\n在碰撞瞬间，位置是连续的（$y(t_{k+1}) = 0$），但速度会发生瞬时跳变。碰撞前瞬间的速度 $v^{-}$ 可通过计算在 $t = t_{k+1}$ 时的速度方程得到：\n$$\nv^{-} = v_k - g \\cdot \\Delta t_{\\text{impact}} < 0\n$$\n碰撞后速度 $v^{+}$ 由跳变定律确定：\n$$\nv^{+} = -e(|v^{-}|) \\cdot v^{-}\n$$\n恢复系数 $e(\\,\\cdot\\,)$ 模拟了碰撞过程中的能量损失，并以碰撞速度 $s = |v^{-}|$ 的函数形式给出：\n$$\ne(s) = e_{\\min} + (e_{\\max} - e_{\\min}) \\exp\\left(-\\frac{s}{v_c}\\right)\n$$\n其中 $e_{\\min}$、$e_{\\max}$ 和 $v_c$ 是给定参数。\n\n**3. 模拟终止条件**\n模拟从一次碰撞进行到下一次，直到满足以下两个条件之一：\n1.  **达到最终时间**：计算出的下一次碰撞时间 $t_{k+1}$ 晚于指定的最终模拟时间 $T_{\\text{end}}$。在这种情况下，不再处理任何后续碰撞，并使用区间 $[t_k, T_{\\text{end}}]$ 上的解析轨迹计算最终状态 $(y(T_{\\text{end}}), v(T_{\\text{end}}))$。\n2.  **粘滞条件**：为防止出现无限次的、反弹高度递减的碰撞序列（一种芝诺现象），引入了粘滞条件。如果计算出的碰撞后速度 $v^{+}$ 小于阈值 $v_{\\text{stop}}$，则认为球已静止。模拟终止，并且对于所有后续时间，状态都固定为 $(y, v) = (0, 0)$。因此，最终高度 $y(T_{\\text{end}})$ 为 $0$。\n\n**4. 算法实现**\n该模拟实现为一个循环，将时间从一个事件推进到下一个事件。\n\n1.  **初始化**：设置当前时间 $t = 0$ 和状态 $(y, v) = (y_0, v_0)$。初始化碰撞次数 $N=0$ 和最后一次碰撞时间 $T_{\\text{last\\_impact}} = -1.0$。\n2.  **循环执行**：只要当前时间 $t < T_{\\text{end}}$，循环就继续。\n    a. **事件预测**：使用上面推导的解析公式计算下一次碰撞的时间 $t_{\\text{impact}}$。\n    b. **事件调度**：\n       - 如果 $t_{\\text{impact}} > T_{\\text{end}}$，下一个事件就是模拟结束。在当前轨迹上计算最终位置 $y(T_{\\text{end}})$ 并终止循环。\n       - 如果 $t_{\\text{impact}} \\le T_{\\text{end}}$，则发生一次碰撞。将 $N$ 增加 1 并更新 $T_{\\text{last\\_impact}} = t_{\\text{impact}}$。\n    c. **事件处理**：\n       - 计算碰撞前速度 $v^{-}$ 和碰撞后速度 $v^{+}$。\n       - 检查粘滞条件：如果 $v^{+} < v_{\\text{stop}}$，将最终位置 $y(T_{\\text{end}})$ 设置为 $0$ 并终止循环。\n       - 否则，为下一段更新系统状态：设置 $t = t_{\\text{impact}}$，$y = 0$，以及 $v = v^{+}$。\n3.  **结果汇总**：循环终止后，将计算出的 $N$、$y(T_{\\text{end}})$ 和 $T_{\\text{last\\_impact}}$ 的值组装成所需的输出格式。这种解析的、事件驱动的方法确保了对模型的高保真度，避免了固定步长或自适应数值积分方案的复杂性和潜在的不精确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef coefficient_of_restitution(s, emin, emax, vc):\n    \"\"\"\n    Calculates the velocity-dependent coefficient of restitution.\n    s: pre-impact speed (|v-|)\n    emin, emax, vc: model parameters\n    \"\"\"\n    if vc <= 0:\n        return emin\n    return emin + (emax - emin) * np.exp(-s / vc)\n\ndef simulate_bounce(y0, v0, emin, emax, vc, T_end, v_stop):\n    \"\"\"\n    Simulates the one-dimensional bouncing ball for a single test case.\n    The simulation uses an analytical solution for the trajectory between impacts.\n    \"\"\"\n    g = 9.81\n\n    # Initial state\n    t = 0.0\n    y = y0\n    v = v0\n\n    # Result tracking\n    impact_count = 0\n    last_impact_time = -1.0\n\n    # The simulation loop advances from one event (impact) to the next.\n    while t < T_end:\n        # Determine time to next impact, assuming current state (t, y, v)\n        # is the beginning of a free-flight phase.\n        # The position y should be non-negative at the start of any segment.\n        \n        # A small tolerance is used to handle floating-point inaccuracies where y should be 0.\n        if y < 1e-12 and v <= 0:\n            # Ball is on the ground and not moving upwards, so it is considered stuck.\n            # No more flight is possible. The final height will be 0.\n            y_final = 0.0\n            return impact_count, y_final, last_impact_time\n\n        # To find time to impact, we solve y_new = 0 for dt, where y_new = y + v*dt - 0.5*g*dt^2.\n        # This is a quadratic equation: 0.5*g*(dt)^2 - v*dt - y = 0.\n        discriminant = v**2 + 2 * g * y\n        \n        # The discriminant should be non-negative for a physical upward or downward trajectory.\n        if discriminant < 0:\n            # This case indicates an unphysical state (e.g., y is negative).\n            # This can happen due to precision loss, so we treat it as stuck.\n            y_final = 0.0\n            return impact_count, y_final, last_impact_time\n            \n        # The physically correct root for forward time gives the time delta to impact.\n        dt_impact = (v + np.sqrt(discriminant)) / g\n        t_impact = t + dt_impact\n\n        # Check if this impact occurs after the simulation end time.\n        if t_impact > T_end:\n            # No more impacts will occur within the simulation window.\n            # Calculate the final position at T_end on the current trajectory.\n            dt_final_flight = T_end - t\n            y_final = y + v * dt_final_flight - 0.5 * g * dt_final_flight**2\n            return impact_count, y_final, last_impact_time\n\n        # An impact occurs at or before T_end.\n        impact_count += 1\n        last_impact_time = t_impact\n\n        # Calculate pre-impact velocity using v_final = v_initial - g*dt.\n        v_minus = v - g * dt_impact\n\n        # Calculate post-impact velocity using the coefficient of restitution.\n        s = abs(v_minus)\n        e = coefficient_of_restitution(s, emin, emax, vc)\n        v_plus = e * s  # This is the magnitude of the post-impact velocity.\n\n        # Check for the sticking condition.\n        if v_plus < v_stop:\n            # The ball loses enough energy to stick to the ground.\n            # The simulation ends conceptually at this impact.\n            y_final = 0.0\n            return impact_count, y_final, last_impact_time\n\n        # If not sticking, update the state for the next free-flight segment.\n        t = t_impact\n        y = 0.0  # Position is reset to the ground after impact.\n        v = v_plus # Velocity is reset to the new upward velocity.\n\n    # This part of the code is reached if the simulation loop terminates because t >= T_end.\n    # This can happen if an impact or sticking event occurs exactly at T_end.\n    # In this case, the final position y(T_end) is 0.\n    y_final = 0.0\n    return impact_count, y_final, last_impact_time\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (y0, v0, emin, emax, vc, T_end, v_stop)\n        (10.0, 0.0, 0.2, 0.9, 2.0, 2.2, 1e-3),\n        (50.0, 0.0, 0.1, 0.8, 1.0, 3.4, 1e-3),\n        (0.001, 0.0, 0.3, 0.9, 0.5, 0.1, 1e-3),\n        (1.0, 5.0, 0.2, 0.9, 2.0, 0.1, 1e-3),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Calculate the result for one case\n        N, Y, T = simulate_bounce(*case)\n        # Format the result list for this case\n        results.append(f\"[{N},{Y:.6f},{T:.6f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2390118"}, {"introduction": "超越简单的力学系统，本问题挑战你在一个不存在解析解的混沌系统——著名的洛伦兹吸引子——中检测事件。你将学习使用标准数值常微分方程（ODE）求解器强大的事件查找功能，来计算系统轨迹穿越状态空间中特定平面的次数。此实践展示了一种分析复杂非线性动力学行为的关键技术 [@problem_id:2390102]。", "problem": "一个三维非线性动力系统由以下 Lorenz 方程定义\n$$\n\\frac{dx}{dt} = \\sigma\\,(y - x), \\quad\n\\frac{dy}{dt} = x\\,(\\rho - z) - y, \\quad\n\\frac{dz}{dt} = x\\,y - \\beta\\,z,\n$$\n其参数为 $\\sigma > 0$、$\\beta > 0$ 和 $\\rho > 0$，初始条件为 $(x(0), y(0), z(0)) = (x_0, y_0, z_0)$。考虑标量函数\n$$\ng(t) = z(t) - (\\rho - 1).\n$$\n在时间 $t^\\star \\in (0, T]$ 对平面 $z = \\rho - 1$ 的一次严格穿越定义为：存在 $\\epsilon > 0$，使得 $g(t)$ 在 $(t^\\star - \\epsilon, t^\\star + \\epsilon)$ 上连续，并且 $g(t)$ 在 $t^\\star$ 两侧变号，即对于所有足够小的 $\\delta \\in (0, \\epsilon)$，都有 $g(t^\\star - \\delta)\\,g(t^\\star + \\delta) < 0$。初始时间 $t = 0$ 时的穿越，即使 $g(0) = 0$，也不得计算在内。两种穿越方向都需计数；不区分 $g$ 是从负变正还是从正变负。\n\n对于下述每个测试用例，确定在闭合时间区间 $[0, T]$ 内发生的对平面 $z = \\rho - 1$ 的严格穿越的整数次数，不包括 $t = 0$ 时的穿越，但包括 $t = T$ 时可能存在的任何严格穿越。所有量均为无量纲。\n\n测试集：\n1. $\\sigma = 10$, $\\beta = \\frac{8}{3}$, $\\rho = 28$, $(x_0, y_0, z_0) = (1, 1, 1)$, $T = 20$.\n2. $\\sigma = 10$, $\\beta = \\frac{8}{3}$, $\\rho = 28$, $(x_0, y_0, z_0) = (0, 1, 27)$, $T = 10$.\n3. $\\sigma = 10$, $\\beta = \\frac{8}{3}$, $\\rho = 28$, $(x_0, y_0, z_0) = (1, 1, 1)$, $T = 1$.\n\n你的程序必须产生单行输出，其中包含三个测试用例的结果，形式为由方括号括起的、逗号分隔的整数列表，并按以上顺序排列。例如，计数结果为 $a$、$b$ 和 $c$ 的输出必须严格按以下格式打印：\n`[a,b,c]`\n不应打印任何额外文本。", "solution": "所述问题是有效的。这是一个计算科学领域中适定且有科学依据的练习，具体涉及带有事件检测功能的常微分方程组的数值积分。Lorenz 系统是混沌理论中的一个经典模型，而定位状态空间穿越是动力系统分析中的一个标准程序。所有必需的参数、初始条件和定义都已足够清晰地提供，并且相互一致。\n\n问题要求我们找出 Lorenz 方程解的轨迹\n$$\n\\frac{d\\mathbf{u}}{dt} = \\mathbf{f}(t, \\mathbf{u}; \\sigma, \\rho, \\beta),\n$$\n穿越由 $z = \\rho - 1$ 定义的平面的次数。此处，状态向量为 $\\mathbf{u}(t) = [x(t), y(t), z(t)]^T$，矢量场 $\\mathbf{f}$ 由下式给出：\n$$\n\\mathbf{f}(t, \\mathbf{u}) =\n\\begin{bmatrix}\n\\sigma(y - x) \\\\\nx(\\rho - z) - y \\\\\nxy - \\beta z\n\\end{bmatrix}\n$$\n该问题是在时间区间 $[0, T]$ 上的一个初值问题 (IVP)，其初始状态为 $\\mathbf{u}(0) = [x_0, y_0, z_0]^T$。\n\n穿越条件由标量事件函数 $g(t) = z(t) - (\\rho - 1)$ 定义。在时间 $t^\\star \\in (0, T]$ 的一次“严格穿越”对应于该函数的一个根 $g(t^\\star) = 0$，并且 $g(t)$ 在此点变号。题目要求我们计数所有这样的根，而不论符号变化的方向。\n\n为解决此问题，必须使用一个能够定位事件的数值ODE求解器。`scipy.integrate.solve_ivp` 函数是用于此目的的一个合适且稳健的工具。它使用自适应步长方法（例如 `LSODA`，此方法对刚性和非刚性问题均有效）来对IVP进行积分以保持精度，同时监测事件的发生。\n\n事件是通过向求解器提供一个可调用函数来定义的。对此问题而言，事件函数恰好是 $g(t, \\mathbf{u}) = u_2 - (\\rho - 1)$，其中 $u_2$ 对应于状态变量 $z(t)$。求解器通过检查积分步之间的符号变化，然后使用求根算法（例如 Brent 方法的一个变体）来找到该函数的根，从而精确定位事件发生的准确时间 $t^\\star$。\n\n问题的具体要求可通过如下方式满足：\n$1$. **计数所有严格穿越**：这可以通过将事件函数的 `direction` 属性设置为 $0$ 来实现。这会指示求解器检测所有发生符号变化的根，无论函数值是从负过渡到正还是从正过渡到负。\n$2$. **非终止性事件**：为了计数区间 $[0, T]$ 内的所有穿越，积分在第一次事件发生后不得停止。这可以通过将事件函数的 `terminal` 属性设置为 `False` 来完成。\n$3$. **排除 $t=0$**：积分从 $t=0$ 开始随时间向前进行。求解器的事件查找机制自然会在积分步之间的开区间 $(t_n, t_{n+1})$ 中定位根。因此，任何检测到的事件的时间都将满足 $t^\\star > 0$，从而自动满足排除初始时间穿越的条件。在 $g(0) = z_0 - (\\rho - 1) = 27 - (28-1) = 0$ 的测试用例中，初始导数 $\\frac{dz}{dt}|_{t=0} = x_0 y_0 - \\beta z_0 = 0 \\cdot 1 - \\frac{8}{3} \\cdot 27 = -72$ 表明轨迹立即进入 $z < \\rho-1$ 区域。因此，在 $t=0$ 处没有符号变化，一个正确实现的求解器不会将此记录为事件，这与问题对“严格穿越”的定义是一致的。\n$4$. **包含 $t=T$**：`solve_ivp` 能正确找到直至并包括积分区间终点时刻在内的所有事件。\n\n最终的算法包括遍历每个测试用例，使用指定的参数 $(\\sigma, \\rho, \\beta)$、初始条件 $(x_0, y_0, z_0)$ 和时间范围 $T$ 来建立 Lorenz 系统和事件函数。使用这些输入调用 `solve_ivp` 函数。每个用例的严格穿越次数即为求解器返回的事件时间数组的长度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the Lorenz system for three test cases and counts the number of\n    times the z-component crosses a specified plane.\n    \"\"\"\n\n    # Test suite: (sigma, beta, rho, (x0, y0, z0), T)\n    test_cases = [\n        (10.0, 8.0/3.0, 28.0, (1.0, 1.0, 1.0), 20.0),\n        (10.0, 8.0/3.0, 28.0, (0.0, 1.0, 27.0), 10.0),\n        (10.0, 8.0/3.0, 28.0, (1.0, 1.0, 1.0), 1.0),\n    ]\n\n    results = []\n\n    # System of ODEs for the Lorenz attractor\n    def lorenz_system(t, u, sigma, rho, beta):\n        x, y, z = u\n        dxdt = sigma * (y - x)\n        dydt = x * (rho - z) - y\n        dzdt = x * y - beta * z\n        return [dxdt, dydt, dzdt]\n\n    for case in test_cases:\n        sigma, beta, rho, u0, T = case\n\n        # Event function: g(t) = z(t) - (rho - 1)\n        # The solver requires the event function to accept the same arguments\n        # as the ODE system function when passed via 'args'.\n        def event_plane_crossing(t, u, sigma, rho, beta):\n            return u[2] - (rho - 1.0)\n\n        # Attribute: terminal=False to continue integration after an event.\n        event_plane_crossing.terminal = False\n        # Attribute: direction=0 to detect crossings in both directions.\n        event_plane_crossing.direction = 0\n\n        # Integrate the Lorenz equations over the interval [0, T]\n        # and find all events.\n        # LSODA is a good general-purpose solver for stiff or non-stiff systems.\n        # dense_output=True is recommended for accurate root finding.\n        sol = solve_ivp(\n            fun=lorenz_system,\n            t_span=(0, T),\n            y0=u0,\n            method='LSODA',\n            args=(sigma, rho, beta),\n            events=event_plane_crossing,\n            dense_output=True,\n            atol=1e-9,  # Absolute tolerance\n            rtol=1e-6   # Relative tolerance\n        )\n        \n        # The solver returns a list of event time arrays. Since we have one\n        # event function, we access the first element. The number of crossings\n        # is the length of this array.\n        num_crossings = len(sol.t_events[0])\n        results.append(num_crossings)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2390102"}, {"introduction": "最后的实践将探讨一个高级且实用的工程场景：一个基于累积能量而跳闸的断路器。关键挑战在于如何在一个积分量上定义事件，这需要通过引入一个代表累积能量的新变量来增强系统的状态向量。本练习将教授一种强大的建模技术，这对于模拟其行为依赖于历史过程的系统至关重要 [@problem_id:2390055]。", "problem": "您的任务是为一个简单的电气系统实现时间积分中的鲁棒事件检测。在该系统中，当累计电阻能量损耗达到一个临界阈值时，保护装置（一个断路器）会跳闸。该系统是一个由已知电压输入驱动的串联电阻-电感元件。您的程序必须使用带有事件检测的时间积分来计算跳闸时间，并为提供的测试套件返回一个单一的聚合结果。\n\n物理模型由以下基本定律和核心定义来描述：\n- 根据基尔霍夫电压定律 (KVL)，一个带有输入电压 $V(t)$ 的串联电阻-电感电路满足\n$$L \\frac{di}{dt} + R i(t) = V(t),$$\n其中 $i(t)$ 是电流，$R$ 是电阻，$L$ 是电感。\n- 根据焦耳热效应，瞬时电阻功率为 $p(t) = i(t)^2 R$，到时间 $t$ 为止在电阻中耗散的累计能量为\n$$e(t) = \\int_{0}^{t} i(\\tau)^2 R \\, d\\tau.$$\n\n断路器的跳闸条件是累计能量 $e(t)$ 首次达到一个临界阈值 $E_{\\mathrm{crit}} > 0$。定义事件函数 $g(t) = E_{\\mathrm{crit}} - e(t)$。跳闸发生在满足 $g(t_{\\mathrm{trip}}) = 0$ 的最小时间 $t_{\\mathrm{trip}} \\ge 0$。如果在规定的时间范围内不存在这样的时间，则断路器在所考虑的区间内不跳闸。\n\n您的任务：\n- 仅使用上述基本关系，将系统表述为一个关于状态 $\\mathbf{y}(t) = [i(t), e(t)]^T$ 的增广常微分方程 (ODE)，初始条件为 $i(0) = 0$ 和 $e(0) = 0$。\n- 对增广系统进行数值积分，并通过与连续时间动态一致的、基于求根的事件定位方法来检测事件 $g(t) = 0$（不要依赖于没有插值的步进式阈值检查）。\n- 对于每个测试用例，如果在指定的积分时域 $[0, T_{\\max}]$ 内找到事件，则报告第一个跳闸时间 $t_{\\mathrm{trip}}$（单位：秒）。如果事件未在 $[0, T_{\\max}]$ 内发生，则为该测试用例报告 $-1.0$。\n\n角度单位和物理单位：\n- 所有时间都必须以秒为单位，并且您必须以秒为单位报告跳闸时间。\n- 任何三角函数输入都使用弧度；对于正弦输入 $V(t) = V_{0} \\sin(2 \\pi f t)$，其参数 $2 \\pi f t$ 以弧度为单位。\n- 电阻单位为欧姆，电感单位为亨利，电压单位为伏特，能量单位为焦耳。\n\n数值规格：\n- 对所有测试用例使用初始条件 $i(0) = 0$ 和 $e(0) = 0$。\n- 使用带有事件检测的数值 ODE 求解器来精确地定位 $t_{\\mathrm{trip}}$。\n- 当跳闸发生时，输出第一个事件时间，四舍五入到六位小数。\n- 如果在给定的时间范围内没有发生跳闸，则为该测试用例输出 $-1.0$。\n\n测试套件：\n- 用例 $1$（正弦输入，典型跳闸）：$R = 2\\,\\Omega$， $L = 0.005\\,\\mathrm{H}$，$V(t) = 10 \\sin(2 \\pi \\cdot 50 \\, t)\\,\\mathrm{V}$，$E_{\\mathrm{crit}} = 0.5\\,\\mathrm{J}$，$T_{\\max} = 0.2\\,\\mathrm{s}$。\n- 用例 $2$（直流阶跃，极早跳闸）：$R = 1\\,\\Omega$，$L = 0.01\\,\\mathrm{H}$，$V(t) = 5\\,\\mathrm{V}$，$E_{\\mathrm{crit}} = 0.001\\,\\mathrm{J}$，$T_{\\max} = 0.05\\,\\mathrm{s}$。\n- 用例 $3$（斜坡输入，在时域内未跳闸）：$R = 10\\,\\Omega$，$L = 0.05\\,\\mathrm{H}$，$V(t) = a \\, t$，其中 $a = 5\\,\\mathrm{V/s}$，$E_{\\mathrm{crit}} = 100\\,\\mathrm{J}$，$T_{\\max} = 2.0\\,\\mathrm{s}$。\n- 用例 $4$（零电阻边缘情况，无耗散）：$R = 0\\,\\Omega$，$L = 0.01\\,\\mathrm{H}$，$V(t) = 10 \\sin(2 \\pi \\cdot 60 \\, t)\\,\\mathrm{V}$，$E_{\\mathrm{crit}} = 0.1\\,\\mathrm{J}$，$T_{\\max} = 0.2\\,\\mathrm{s}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的结果列表。\n- 每个元素按上面列出的顺序对应一个测试用例。\n- 对于发生跳闸的用例，打印四舍五入到六位小数的跳闸时间；对于在时间范围内未发生跳闸的用例，打印 $-1.0$。\n- 所需输出结构的示例（仅为说明）：`[0.012345,-1.0,0.100000,0.250000]`。", "solution": "对问题陈述的评估表明其是有效的。它在科学上植根于电气工程的基本原理，在数学上是适定的，并为计算任务提供了完整而明确的规范。我们将着手进行形式化的求解。\n\n问题的核心是为串联电阻-电感 (RL) 电路的动态行为建模，并基于一个积分量来检测事件。该系统的行为由两个基本原理支配：基尔霍夫电压定律和焦耳第一定律。\n\n基尔chowhoff电压定律给出了关于电流 $i(t)$ 的主导微分方程：\n$$ L \\frac{di}{dt} + R i(t) = V(t) $$\n在电阻中耗散的累计能量 $e(t)$ 是瞬时功率 $p(t) = i(t)^2 R$ 的时间积分：\n$$ e(t) = \\int_{0}^{t} i(\\tau)^2 R \\, d\\tau $$\n为了对该系统进行数值求解，我们构建一个增广初值问题 (IVP)。我们定义一个状态向量 $\\mathbf{y}(t) = [y_1(t), y_2(t)]^T$，其中 $y_1(t) = i(t)$ 是电流，$y_2(t) = e(t)$ 是累计能量。然后我们推导出关于 $\\mathbf{y}(t)$ 的一阶常微分方程 (ODEs) 组。\n\n根据基尔霍夫定律，第一个状态变量的导数为：\n$$ \\frac{dy_1}{dt} = \\frac{di}{dt} = \\frac{1}{L} \\left( V(t) - R i(t) \\right) = \\frac{1}{L} \\left( V(t) - R y_1(t) \\right) $$\n通过将微积分基本定理应用于 $e(t)$ 的定义，我们得到第二个状态变量的导数：\n$$ \\frac{dy_2}{dt} = \\frac{de}{dt} = \\frac{d}{dt} \\int_{0}^{t} i(\\tau)^2 R \\, d\\tau = i(t)^2 R = y_1(t)^2 R $$\n这得到了以下的增广 ODE 系统：\n$$\n\\frac{d}{dt} \\begin{pmatrix} y_1 \\\\ y_2 \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{L} (V(t) - R y_1) \\\\ R y_1^2 \\end{pmatrix}\n$$\n问题指定了初始条件 $i(0) = 0$ 和 $e(0) = 0$，这对应于初始状态向量 $\\mathbf{y}(0) = [0, 0]^T$。\n\n断路器跳闸是一个事件，当 $e(t)$ 达到临界阈值 $E_{\\mathrm{crit}}$ 时发生。我们定义一个事件函数 $g(t)$，其根对应于事件时间：\n$$ g(t) = E_{\\mathrm{crit}} - e(t) = E_{\\mathrm{crit}} - y_2(t) $$\n我们寻找使 $g(t_{\\mathrm{trip}}) = 0$ 成立的最小时间 $t_{\\mathrm{trip}} \\ge 0$。由于 $R \\ge 0$，能量的导数 $\\frac{de}{dt} = R i^2$ 是非负的，这意味着 $e(t)$ 是一个非减函数。因此，事件函数 $g(t)$ 是非增的，这保证了如果存在根，该根是唯一的。\n\n为了找到 $t_{\\mathrm{trip}}$，我们使用一个能够处理事件检测的数值 ODE 求解器，例如 `scipy.integrate.solve_ivp`。该求解器在时间范围 $[0, T_{\\max}]$ 内对增广 ODE 系统进行积分，同时监控事件函数 $g(t)$ 的符号。我们将求解器配置为检测 $g(t)$ 从正到负的过零点。当在积分步之间检测到这样的过零时，会使用一个精确的求根算法作用于求解器的密集输出（一个连续的插值多项式）上，以定位事件的确切时间。这确保了准确性，并且优于在离散时间步长上进行简单的阈值检查。如果积分到 $T_{\\max}$ 完成而未检测到任何事件，我们断定在指定区间内没有发生跳闸。\n\n当电阻 $R=0$ 时，会出现一个特殊情况。在这种情形下，能量的导数 $\\frac{de}{dt} = 0 \\cdot y_1^2$ 恒为零。在初始条件为 $e(0)=0$ 的情况下，能量 $e(t)$ 在所有时间 $t \\ge 0$ 内都保持为零。对于任何 $E_{\\mathrm{crit}} > 0$，事件条件 $e(t) = E_{\\mathrm{crit}}$ 永远不会满足，因此不可能发生跳闸。\n\n所描述的数值程序被实现并应用于所提供的四个测试用例中的每一个，为每个用例使用特定的参数 $R$, $L$, $E_{\\mathrm{crit}}$, $T_{\\max}$ 以及驱动函数 $V(t)$。报告的跳闸时间四舍五入到六位小数，如果在时间范围内未发生跳闸，则报告为 $-1.0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves for the circuit breaker trip time in a series RL circuit\n    for a suite of test cases.\n    \"\"\"\n\n    def find_trip_time(R, L, V_func, E_crit, T_max):\n        \"\"\"\n        Computes the trip time for a single set of circuit parameters.\n\n        Args:\n            R (float): Resistance in ohms.\n            L (float): Inductance in henries.\n            V_func (callable): Voltage function V(t).\n            E_crit (float): Critical energy threshold in joules.\n            T_max (float): Maximum integration time in seconds.\n\n        Returns:\n            float: The trip time rounded to 6 decimal places, or -1.0 if no trip.\n        \"\"\"\n        \n        # In the case of zero resistance, no energy is dissipated via Joule heating.\n        # Since e(0) = 0 and de/dt = R*i^2 = 0, e(t) will always be 0.\n        # If E_crit > 0, the event can never occur.\n        if R == 0.0 and E_crit > 0.0:\n            return -1.0\n\n        def ode_system(t, y, R_val, L_val, V_f):\n            \"\"\"\n            Defines the augmented ODE system dy/dt = f(t, y).\n            y[0] = i(t) (current)\n            y[1] = e(t) (cumulative energy)\n            \"\"\"\n            i, _ = y\n            # di/dt = (V(t) - R*i) / L\n            di_dt = (V_f(t) - R_val * i) / L_val\n            # de/dt = R * i^2\n            de_dt = R_val * i**2\n            return [di_dt, de_dt]\n\n        def event_function(t, y, E_crit_val):\n            \"\"\"\n            Event function g(t) = E_crit - e(t). A root is sought.\n            \"\"\"\n            return E_crit_val - y[1]\n\n        # The solver must stop when the event is found.\n        event_function.terminal = True\n        # We are looking for a crossing from positive to negative (e(t) increasing).\n        event_function.direction = -1\n\n        # Initial conditions: i(0) = 0, e(0) = 0.\n        y0 = [0.0, 0.0]\n        t_span = [0.0, T_max]\n\n        sol = solve_ivp(\n            fun=lambda t, y: ode_system(t, y, R, L, V_func),\n            t_span=t_span,\n            y0=y0,\n            events=lambda t, y: event_function(t, y, E_crit),\n            dense_output=True,  # Necessary for accurate event location\n            rtol=1e-8, # Stricter tolerance for accuracy\n            atol=1e-8\n        )\n\n        # sol.t_events is a list of arrays, one for each event function.\n        # We have one event function, so we check sol.t_events[0].\n        if sol.t_events and len(sol.t_events[0]) > 0:\n            trip_time = sol.t_events[0][0]\n            return round(trip_time, 6)\n        else:\n            return -1.0\n\n    # Test suite from the problem statement.\n    test_cases = [\n        # Case 1: Sinusoidal input, typical trip\n        {'R': 2.0, 'L': 0.005, 'V_func': lambda t: 10.0 * np.sin(2 * np.pi * 50 * t), 'E_crit': 0.5, 'T_max': 0.2},\n        # Case 2: Direct current step, very early trip\n        {'R': 1.0, 'L': 0.01, 'V_func': lambda t: 5.0, 'E_crit': 0.001, 'T_max': 0.05},\n        # Case 3: Ramp input, no trip within horizon\n        {'R': 10.0, 'L': 0.05, 'V_func': lambda t: 5.0 * t, 'E_crit': 100.0, 'T_max': 2.0},\n        # Case 4: Zero resistance edge case, no dissipation\n        {'R': 0.0, 'L': 0.01, 'V_func': lambda t: 10.0 * np.sin(2 * np.pi * 60 * t), 'E_crit': 0.1, 'T_max': 0.2},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_trip_time(\n            case['R'],\n            case['L'],\n            case['V_func'],\n            case['E_crit'],\n            case['T_max']\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2390055"}]}