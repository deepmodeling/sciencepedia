{"hands_on_practices": [{"introduction": "理论知识告诉我们，隐式方法在求解刚性问题时具有卓越的稳定性。但是，这种稳定性在实践中究竟意味着什么？本练习通过一个巧妙的思想实验——时间反向积分——来直观地揭示 A-稳定性的强大威力。通过在一个本身不稳定的系统上反向求解，我们将看到显式方法如何因为其有限的稳定域而彻底失效，而 A-稳定的隐式龙格-库塔（IRK）方法却能稳健地给出精确结果 [@problem_id:2402097]。这个练习将让你亲身体验数值稳定性的重要性，并深刻理解为何隐式方法是求解刚性系统的关键。", "problem": "考虑线性刚性常微分方程 (ODE) $y'(t) = \\lambda\\, y(t)$，其终端值给定为 $y(T) = 1$。目标是通过使用负步长从 $t = T$ 到 $t = 0$ 进行时间上的向后积分来计算 $y(0)$。其精确解为 $y(t) = \\exp(\\lambda (t - T))$，因此 $y(0) = \\exp(-\\lambda T)$。\n\n为从 $t_n$ 到 $t_{n+1} = t_n + h$ 的单步定义一族单步法如下，其中 $h < 0$ 表示负时间步长，$z = h \\lambda$：\n- 显式前向欧拉法为 $y_{n+1} = y_n + h \\lambda y_n = (1 + z)\\, y_n$。\n- 所使用的隐式 Runge–Kutta (IRK) 法是参数为 $\\gamma = 1 - \\frac{1}{\\sqrt{2}}$ 的两阶段单对角隐式 Runge–Kutta (SDIRK) 格式。其 Butcher 表为\n$$\n\\begin{array}{c|cc}\n\\gamma & \\gamma & 0 \\\\\n1 & 1-\\gamma & \\gamma \\\\\n\\hline\n& 1-\\gamma & \\gamma\n\\end{array}\n$$\n对于标量线性测试方程 $y' = \\lambda y$，此 SDIRK 方法的稳定性函数为\n$$\nR(z) = \\frac{1 + (1 - 2\\gamma)\\, z}{(1 - \\gamma z)^2},\n$$\n因此，单步映射为 $y_{n+1} = R(z)\\, y_n$。\n\n您的程序必须对每个测试用例，从 $y_N = y(T) = 1$ 开始，使用大小为 $h = -T/N$ 的 $N$ 个均匀步长向后步进到 $t = 0$，其中一次使用显式前向欧拉更新因子 $(1 + z)$，另一次使用 SDIRK 稳定性函数 $R(z)$。设 $t=0$ 处的两个数值近似解分别记为 $y_{\\text{explicit}}(0)$ 和 $y_{\\text{IRK}}(0)$。设精确值为 $y_{\\text{exact}}(0) = \\exp(-\\lambda T)$。对每个测试用例，计算绝对误差\n$$\ne_{\\text{IRK}} = \\left| y_{\\text{IRK}}(0) - y_{\\text{exact}}(0) \\right|,\\quad\ne_{\\text{explicit}} = \\left| y_{\\text{explicit}}(0) - y_{\\text{exact}}(0) \\right|.\n$$\n\n使用以下参数测试套件 $(\\lambda, T, N)$：\n- 测试 1 (刚性问题，中等大小的后向步长)：$(\\lambda, T, N) = (1000, 0.1, 5)$。\n- 测试 2 (单个后向步长的显式欧拉法稳定性边界)：$(\\lambda, T, N) = (2, 1, 1)$。\n- 测试 3 (非常刚性的问题，中等大小的后向步长)：$(\\lambda, T, N) = (5000, 0.05, 5)$。\n\n所有量均为无量纲；不涉及物理单位。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：\n`[e_{\\text{IRK}}^{(1)}, e_{\\text{explicit}}^{(1)}, e_{\\text{IRK}}^{(2)}, e_{\\text{explicit}}^{(2)}, e_{\\text{IRK}}^{(3)}, e_{\\text{explicit}}^{(3)}]`，其中上标表示测试用例的索引。每个条目必须是浮点数。", "solution": "问题陈述已经过严格评估，并被认为是有效的。它构成了计算数学中的一个适定问题，特别是在刚性常微分方程的数值分析领域。所有提供的定义、常数和方程均符合既定原则。任务是比较一种显式和一种隐式 Runge-Kutta 方法在刚性问题上的性能，这是展示数值稳定性概念的一个经典练习。\n\n问题的核心在于求解带有终端条件 $y(T) = 1$ 的线性常微分方程 (ODE) $y'(t) = \\lambda y(t)$。积分从 $t=T$ 到 $t=0$ 在时间上向后进行。这个问题的精确解为 $y(t) = C \\exp(\\lambda t)$。使用终端条件，我们得到 $1 = C \\exp(\\lambda T)$，这意味着 $C = \\exp(-\\lambda T)$。因此，精确解为 $y(t) = \\exp(\\lambda(t-T))$。所以在初始时间 $t=0$ 的精确值为 $y_{\\text{exact}}(0) = \\exp(-\\lambda T)$。\n\n我们需要用两种数值格式通过 $N$ 个均匀步长来近似该解。从 $t=T$ 到 $t=0$ 的向后积分的时间步长是负数，由 $h = (0 - T) / N = -T/N$ 给出。\n\n对于标量线性测试方程 $y'=\\lambda y$，从 $y_n$ 到 $y_{n+1}$ 的单步法的一步可以表示为 $y_{n+1} = R(z) y_n$，其中 $R(z)$ 是该方法的稳定性函数，$z = h\\lambda$。因此，从初始值 $y_0 = y(T) = 1$ 开始，经过 $N$ 步后，在最终时间 $t_N = T+Nh = T+N(-T/N) = 0$ 的数值近似解由 $y_{\\text{num}}(0) = [R(z)]^N y_0 = [R(z)]^N$ 给出。\n\n数值积分的稳定性取决于稳定性函数的大小 $|R(z)|$。对于稳定的计算，我们要求 $|R(z)| \\leq 1$。如果 $|R(z)| > 1$，数值解将会发散，表现出误差的指数级增长。所提供的测试用例涉及大的正值 $\\lambda$ 和负值 $h$，导致 $z = h\\lambda$ 为大的负值。这代表了一种刚性问题的情景。\n\n需要比较的两种方法是：\n$1$. 显式前向欧拉法。其稳定性函数为 $R_{\\text{explicit}}(z) = 1 + z$。在 $t=0$ 处的数值近似解为 $y_{\\text{explicit}}(0) = (1 + h\\lambda)^N$。该方法的稳定域为 $|1+z| \\le 1$，即在复平面上以 $z=-1$ 为中心、半径为 1 的圆盘。对于实数 $z$，这对应于区间 $[-2, 0]$。\n\n$2$. 两阶段单对角隐式 Runge-Kutta (SDIRK) 法。其稳定性函数为 $R_{\\text{IRK}}(z) = \\frac{1 + (1 - 2\\gamma)z}{(1 - \\gamma z)^2}$，参数为 $\\gamma = 1 - \\frac{1}{\\sqrt{2}}$。在 $t=0$ 处的数值近似解为 $y_{\\text{IRK}}(0) = [R_{\\text{IRK}}(h\\lambda)]^N$。该方法是 L-稳定的，这意味着它是 A-稳定的 (其稳定域包含整个左半平面，即 $\\operatorname{Re}(z) \\le 0$)，并且额外满足 $\\lim_{z \\to -\\infty} |R(z)| = 0$。对于刚性问题，这个性质非常理想，因为它能有效衰减高频 (瞬态) 分量。\n\n对每个测试用例 $(\\lambda, T, N)$ 的计算步骤如下：\n$1$. 计算步长 $h = -T/N$ 和参数 $z = h\\lambda$。\n$2$. 计算数值解 $y_{\\text{explicit}}(0) = (1+z)^N$ 和 $y_{\\text{IRK}}(0) = [R_{\\text{IRK}}(z)]^N$。\n$3$. 计算精确解 $y_{\\text{exact}}(0) = \\exp(-\\lambda T)$。\n$4$. 计算绝对误差 $e_{\\text{explicit}} = | y_{\\text{explicit}}(0) - y_{\\text{exact}}(0) |$ 和 $e_{\\text{IRK}} = | y_{\\text{IRK}}(0) - y_{\\text{exact}}(0) |$。\n\n对三个指定的测试用例均执行此过程，并以要求的格式呈现结果。刚性问题（测试 1 和 3）预计将显示显式方法因不稳定性 ($|z| > 2$) 而显著失败，而 L-稳定的 SDIRK 方法应产生一个小的、可控的误差。测试 2 将显式方法置于其稳定域的边界上，预计与 SDIRK 方法相比，其结果也会很差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares the error of explicit Euler and a SDIRK method\n    for a stiff ODE integrated backward in time.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1000.0, 0.1, 5),   # Test 1 (stiff, moderately large backward step)\n        (2.0, 1.0, 1),      # Test 2 (boundary of explicit Euler stability)\n        (5000.0, 0.05, 5),  # Test 3 (very stiff, moderately large backward steps)\n    ]\n\n    results = []\n    \n    # Define the SDIRK method parameter gamma\n    gamma = 1.0 - 1.0 / np.sqrt(2.0)\n\n    for case in test_cases:\n        lambda_val, T, N = case\n\n        # Calculate the uniform negative step size h and the parameter z\n        h = -T / N\n        z = h * lambda_val\n\n        # --- Method 1: Explicit Forward Euler ---\n        # The stability function for forward Euler is R(z) = 1 + z.\n        R_explicit = 1.0 + z\n        # The numerical solution at t=0 is obtained by applying the update N times, starting from y(T)=1.\n        y_explicit_0 = R_explicit**N\n\n        # --- Method 2: SDIRK ---\n        # The stability function for the SDIRK method is R(z) = (1 + (1-2g)z) / (1 - gz)^2.\n        R_irk_numerator = 1.0 + (1.0 - 2.0 * gamma) * z\n        R_irk_denominator = (1.0 - gamma * z)**2\n        R_irk = R_irk_numerator / R_irk_denominator\n        # The numerical solution at t=0 after N steps.\n        y_irk_0 = R_irk**N\n\n        # --- Exact Solution ---\n        # The exact solution is y(t) = exp(lambda * (t - T)), so y(0) = exp(-lambda*T).\n        y_exact_0 = np.exp(-lambda_val * T)\n\n        # --- Compute Absolute Errors ---\n        # error = | y_numerical(0) - y_exact(0) |\n        e_irk = np.abs(y_irk_0 - y_exact_0)\n        e_explicit = np.abs(y_explicit_0 - y_exact_0)\n\n        results.append(e_irk)\n        results.append(e_explicit)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2402097"}, {"introduction": "理解了隐式方法的必要性之后，下一步就是亲手构建一个。本练习将指导你从零开始实现一个功能完备的刚性系统求解器——单对角隐式龙格-库塔（Singly Diagonally Implicit Runge–Kutta, SDIRK）方法。这个过程的核心挑战在于求解隐式方法所引入的代数方程组，你将学习如何利用牛顿法来迭代求解各个阶段的值 [@problem_id:2402149]。通过在一系列经典的刚性测试问题（从化学动力学到振荡器）上验证你的求解器，你将不仅掌握隐式方法的实现细节，更会获得解决真实世界计算问题的宝贵经验。", "problem": "给定一个由常微分方程 $y'(t) = f(t,y)$ 和初始条件 $y(t_0) = y_0$ 定义的初值问题，其中 $y \\in \\mathbb{R}^d$。实现一个固定步长的两级单对角隐式 Runge–Kutta 方法（Singly Diagonally Implicit Runge–Kutta (SDIRK)，这是一类对角隐式 Runge–Kutta 方法），该方法由对角系数为 $\\gamma = 1 - \\frac{1}{\\sqrt{2}}$ 的 Butcher 表定义：\n$$\n\\begin{array}{c|cc}\n\\gamma & \\gamma & 0 \\\\\n1 & 1 - 2\\gamma & \\gamma \\\\\n\\hline\n & \\tfrac{1}{2} & \\tfrac{1}{2}\n\\end{array}\n$$\n即，$A = \\begin{bmatrix} \\gamma & 0 \\\\ 1 - 2\\gamma & \\gamma \\end{bmatrix}$，$b = \\begin{bmatrix} \\tfrac{1}{2} & \\tfrac{1}{2} \\end{bmatrix}$，$c = \\begin{bmatrix} \\gamma & 1 \\end{bmatrix}^\\top$，其中 $\\gamma = 1 - \\frac{1}{\\sqrt{2}}$。对于每个大小为 $h > 0$ 的时间步，计算内部级并构造更新式 $y_{n+1} = y_n + h \\sum_{i=1}^2 b_i f(t_n + c_i h, Y_i)$。求解级 $Y_i$ 的非线性代数方程组时，必须在无穷范数下达到 $10^{-12}$ 的绝对容差。假设每个测试用例都提供了雅可比矩阵 $\\partial f/\\partial y$。\n\n您的实现必须对维度 $d \\ge 1$ 具有通用性，使用固定的步长 $h$，该步长可以整除 $T - t_0$，以使步数 $N = (T - t_0)/h$ 为整数，并且必须能处理刚性问题。\n\n测试套件。实现求解器并将其应用于以下五个测试用例，每个用例都由函数 $f(t,y)$、其雅可比矩阵 $J(t,y) = \\partial f/\\partial y$、初始数据、区间和步长定义：\n\n- 测试 $1$（标量线性刚性衰减）：\n  - 维度：$d = 1$。\n  - 右端项：$f(t,y) = -\\lambda y$，其中 $\\lambda = 1000$。\n  - 雅可比矩阵：$J(t,y) = [-\\lambda]$。\n  - 初始条件：$t_0 = 0$ 时 $y_0 = 1$。\n  - 最终时间：$T = 1$。\n  - 步长：$h = 0.1$。\n\n- 测试 $2$（刚性 Van der Pol 振子）：\n  - 维度：$d = 2$，其中 $y = [x, v]^\\top$。\n  - 参数：$\\mu = 100$。\n  - 右端项：$f(t, [x, v]^\\top) = \\begin{bmatrix} v \\\\ \\mu (1 - x^2) v - x \\end{bmatrix}$。\n  - 雅可比矩阵：$J(t, [x, v]^\\top) = \\begin{bmatrix} 0 & 1 \\\\ -2\\mu x v - 1 & \\mu (1 - x^2) \\end{bmatrix}$。\n  - 初始条件：$t_0 = 0$ 时 $y_0 = [2, 0]^\\top$。\n  - 最终时间：$T = 0.3$。\n  - 步长：$h = 0.001$。\n  - 要求报告的量：第一个分量 $x(T)$。\n\n- 测试 $3$（Robertson 化学动力学，刚性，三物种）：\n  - 维度：$d = 3$，其中 $y = [y_1, y_2, y_3]^\\top$。\n  - 右端项：\n    $$\n    \\begin{aligned}\n    f_1 &= -0.04 y_1 + 10^4 y_2 y_3, \\\\\n    f_2 &= 0.04 y_1 - 10^4 y_2 y_3 - 3 \\cdot 10^7 y_2^2, \\\\\n    f_3 &= 3 \\cdot 10^7 y_2^2.\n    \\end{aligned}\n    $$\n  - 雅可比矩阵：\n    $$\n    J = \\begin{bmatrix}\n    -0.04 & 10^4 y_3 & 10^4 y_2 \\\\\n    0.04 & -10^4 y_3 - 6 \\cdot 10^7 y_2 & -10^4 y_2 \\\\\n    0 & 6 \\cdot 10^7 y_2 & 0\n    \\end{bmatrix}.\n    $$\n  - 初始条件：$t_0 = 0$ 时 $y_0 = [1, 0, 0]^\\top$。\n  - 最终时间：$T = 10^{-4}$。\n  - 步长：$h = 10^{-6}$。\n  - 要求报告的量：第三个分量 $y_3(T)$。\n\n- 测试 $4$（零向量场，不变性检验）：\n  - 维度：$d = 1$。\n  - 右端项：$f(t,y) = 0$。\n  - 雅可比矩阵：$J(t,y) = [0]$。\n  - 初始条件：$t_0 = 0$ 时 $y_0 = -5.5$。\n  - 最终时间：$T = 3.7$。\n  - 步长：$h = 0.37$。\n\n- 测试 $5$（线性、非正规、中等刚性的 $2 \\times 2$ 系统）：\n  - 维度：$d = 2$，其中 $y = [y_1, y_2]^\\top$。\n  - 矩阵：$A = \\begin{bmatrix} -50 & 49 \\\\ 0 & -1 \\end{bmatrix}$。\n  - 右端项：$f(t,y) = A y$。\n  - 雅可比矩阵：$J(t,y) = A$。\n  - 初始条件：$t_0 = 0$ 时 $y_0 = [1, 1]^\\top$。\n  - 最终时间：$T = 1$。\n  - 步长：$h = 0.05$。\n  - 要求报告的量：第一个分量 $y_1(T)$。\n\n最终输出格式。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试 $1$ 到 $5$ 的顺序排列结果，其中每个条目都是一个四舍五入到 $10$ 位小数的实数。对于测试 2 和 5，报告最终时间的第一个分量；对于测试 3，报告最终时间的第三个分量；对于测试 1 和 4，报告最终时间的标量状态。例如，输出格式必须严格为\n`[r_1,r_2,r_3,r_4,r_5]`\n不含空格，其中每个 $r_i$ 均按要求四舍五入到 $10$ 位小数。", "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于常微分方程的数值方法理论，是适定的，提供了所有必要信息，并且表述客观。所提供的测试用例是刚性积分器的标准基准测试。我们可以开始求解。\n\n任务是为求解初值问题 $y'(t) = f(t,y)$，$y(t_0) = y_0$ 实现一个特定的两级单对角隐式 Runge-Kutta (SDIRK) 方法。该方法由 Butcher 表定义：\n$$\n\\begin{array}{c|cc}\n\\gamma & \\gamma & 0 \\\\\n1 & 1 - 2\\gamma & \\gamma \\\\\n\\hline\n & \\tfrac{1}{2} & \\tfrac{1}{2}\n\\end{array}\n$$\n参数为 $\\gamma = 1 - 1/\\sqrt{2}$。这对应于系数 $c_1 = \\gamma$, $c_2 = 1$；$b_1 = 1/2$, $b_2 = 1/2$；以及矩阵 $A = \\begin{bmatrix} \\gamma & 0 \\\\ 1 - 2\\gamma & \\gamma \\end{bmatrix}$。\n\n一个通用的 $s$ 级 Runge-Kutta 方法使用以下公式将解从时间 $t_n$ 推进到 $t_{n+1} = t_n + h$：\n$$ y_{n+1} = y_n + h \\sum_{i=1}^s b_i k_i $$\n其中级导数 $k_i$ 通过 $k_i = f(t_n + c_i h, Y_i)$ 与级值 $Y_i$ 相关。级 $Y_i$ 由以下方程组隐式定义：\n$$ Y_i = y_n + h \\sum_{j=1}^s a_{ij} k_j = y_n + h \\sum_{j=1}^s a_{ij} f(t_n + c_j h, Y_j) $$\n对于指定的方法，级由下式给出：\n$$ Y_1 = y_n + h \\gamma k_1 $$\n$$ Y_2 = y_n + h (1 - 2\\gamma) k_1 + h \\gamma k_2 $$\n将 $k_i$ 的定义代入，得到关于级导数 $k_1, k_2 \\in \\mathbb{R}^d$ 的方程组：\n$$ k_1 = f(t_n + \\gamma h, y_n + h \\gamma k_1) $$\n$$ k_2 = f(t_n + h, y_n + h(1 - 2\\gamma)k_1 + h \\gamma k_2) $$\n矩阵 $A$ 的下三角结构使得这些方程可以顺序求解。这类方法被称为对角隐式 Runge-Kutta (DIRK) 方法。由于对角元素 $a_{11}$ 和 $a_{22}$ 相同 ($a_{ii} = \\gamma$)，这是一种单对角 DIRK (SDIRK) 方法，它为刚性系统提供了计算上的优势。\n\n实现的核心是在每个时间步求解这些关于 $k_1$ 和 $k_2$ 的非线性代数方程组。对于刚性问题，其雅可比矩阵 $\\partial f / \\partial y$ 具有大特征值，这些方程不能通过简单的函数迭代法求解。相反，需要一个稳健的求根算法，如牛顿法。\n\n对于第一级，我们必须求函数 $G_1(k_1) = 0$ 的根，其中：\n$$ G_1(k_1) = k_1 - f(t_n + \\gamma h, y_n + h \\gamma k_1) $$\n$k_1$ 的牛顿迭代由下式给出：\n$$ k_1^{(m+1)} = k_1^{(m)} - [J_{G_1}(k_1^{(m)})]^{-1} G_1(k_1^{(m)}) $$\n其中 $m$ 是迭代指数，$J_{G_1}$ 是 $G_1$ 关于 $k_1$ 的雅可比矩阵：\n$$ J_{G_1}(k_1) = \\frac{\\partial G_1}{\\partial k_1} = I - h \\gamma \\frac{\\partial f}{\\partial y}(t_n + \\gamma h, y_n + h \\gamma k_1) $$\n此处，$I$ 是维度为 $d$ 的单位矩阵。该迭代需要在每一步为修正量 $\\Delta k_1^{(m)}$ 求解一个线性系统：\n$$ (I - h \\gamma J_f) \\Delta k_1^{(m)} = -G_1(k_1^{(m)}) $$\n其中 $J_f$ 是 $f$ 的雅可比矩阵，在 $(t_n + \\gamma h, y_n + h \\gamma k_1^{(m)})$ 处求值。迭代从一个初始猜测（如 $k_1^{(0)} = \\mathbf{0}$）开始，直到残差的无穷范数 $||G_1(k_1^{(m)})||_\\infty$ 小于指定的容差 $10^{-12}$。\n\n一旦 $k_1$ 收敛，我们通过求 $G_2(k_2) = 0$ 的根来求解第二级导数 $k_2$：\n$$ G_2(k_2) = k_2 - f(t_n + h, y_n + h(1-2\\gamma)k_1 + h \\gamma k_2) $$\n$k_2$ 的牛顿迭代是类似的。相应的修正量 $\\Delta k_2^{(m)}$ 的线性系统为：\n$$ (I - h \\gamma J_f) \\Delta k_2^{(m)} = -G_2(k_2^{(m)}) $$\n其中 $J_f$ 现在在 $(t_n + h, y_n + h(1-2\\gamma)k_1 + h \\gamma k_2^{(m)})$ 处求值。线性系统的矩阵 $I - h\\gamma J_f$ 对两个级具有相同的结构，这是 SDIRK 方法的定义特征。为获得最大的稳健性，将使用完全牛顿法，即在每次迭代中重新计算雅可比矩阵 $J_f$。\n\n在 $k_1$ 和 $k_2$ 都计算到所需容差后，解被推进：\n$$ y_{n+1} = y_n + \\frac{h}{2} (k_1 + k_2) $$\n对指定的步数 $N = (T-t_0)/h$ 重复整个过程，以获得最终时间 $T$ 的解。实现必须对任何维度 $d \\ge 1$ 具有通用性。为每个测试用例提供解析雅可比矩阵对于牛顿求解器的效率和准确性至关重要，特别是对于刚性系统。最终呈现的代码严格遵循此逻辑和数值分析框架。", "answer": "```python\nimport numpy as np\n\ndef sdirk_solver(f, jac, y0, t0, T, h):\n    \"\"\"\n    Solves an initial value problem using a 2-stage SDIRK method.\n\n    Args:\n        f (callable): The right-hand side function f(t, y).\n        jac (callable): The Jacobian of f, J(t, y).\n        y0 (np.ndarray): The initial condition vector.\n        t0 (float): The initial time.\n        T (float): The final time.\n        h (float): The fixed step size.\n\n    Returns:\n        np.ndarray: The solution vector at time T.\n    \"\"\"\n    gamma = 1.0 - 1.0 / np.sqrt(2.0)\n    b1, b2 = 0.5, 0.5\n    a11 = gamma\n    a21 = 1.0 - 2.0 * gamma\n    a22 = gamma\n    c1, c2 = gamma, 1.0\n    tol = 1e-12\n    max_newton_iter = 50\n    dim = len(y0)\n    identity = np.eye(dim)\n\n    # Use np.isclose for robust comparison with floating point numbers\n    num_steps = round((T - t0) / h)\n    if not np.isclose(t0 + num_steps * h, T):\n        raise ValueError(\"Step size h must divide the interval T-t0 exactly.\")\n        \n    t = t0\n    y = y0.copy()\n\n    for _ in range(num_steps):\n        # Stage 1\n        k1 = np.zeros(dim)\n        for _ in range(max_newton_iter):\n            y1_arg = y + h * a11 * k1\n            t1_arg = t + c1 * h\n            g1 = k1 - f(t1_arg, y1_arg)\n            \n            if np.linalg.norm(g1, ord=np.inf) < tol:\n                break\n                \n            j_f_val = jac(t1_arg, y1_arg)\n            m_matrix = identity - h * a11 * j_f_val\n            delta_k1 = np.linalg.solve(m_matrix, -g1)\n            k1 += delta_k1\n        else:\n            raise RuntimeError(\"Newton's method failed to converge for stage 1.\")\n\n        # Stage 2\n        k2 = np.zeros(dim)\n        for _ in range(max_newton_iter):\n            y2_arg = y + h * a21 * k1 + h * a22 * k2\n            t2_arg = t + c2 * h\n            g2 = k2 - f(t2_arg, y2_arg)\n\n            if np.linalg.norm(g2, ord=np.inf) < tol:\n                break\n\n            j_f_val = jac(t2_arg, y2_arg)\n            m_matrix = identity - h * a22 * j_f_val\n            delta_k2 = np.linalg.solve(m_matrix, -g2)\n            k2 += delta_k2\n        else:\n            raise RuntimeError(\"Newton's method failed to converge for stage 2.\")\n            \n        y += h * (b1 * k1 + b2 * k2)\n        t += h\n        \n    return y\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the SDIRK solver.\n    \"\"\"\n    test_cases = [\n        {\n            \"id\": 1,\n            \"f\": lambda t, y: -1000.0 * y,\n            \"jac\": lambda t, y: np.array([[-1000.0]]),\n            \"y0\": np.array([1.0]),\n            \"t0\": 0.0,\n            \"T\": 1.0,\n            \"h\": 0.1,\n            \"report_idx\": 0,\n        },\n        {\n            \"id\": 2,\n            \"f\": (lambda mu: lambda t, y: np.array([y[1], mu * (1 - y[0]**2) * y[1] - y[0]]))(100.0),\n            \"jac\": (lambda mu: lambda t, y: np.array([[0, 1.0], [-2*mu*y[0]*y[1] - 1.0, mu*(1-y[0]**2)]]))(100.0),\n            \"y0\": np.array([2.0, 0.0]),\n            \"t0\": 0.0,\n            \"T\": 0.3,\n            \"h\": 0.001,\n            \"report_idx\": 0,\n        },\n        {\n            \"id\": 3,\n            \"f\": lambda t, y: np.array([\n                -0.04 * y[0] + 1e4 * y[1] * y[2],\n                0.04 * y[0] - 1e4 * y[1] * y[2] - 3e7 * y[1]**2,\n                3e7 * y[1]**2\n            ]),\n            \"jac\": lambda t, y: np.array([\n                [-0.04, 1e4 * y[2], 1e4 * y[1]],\n                [0.04, -1e4 * y[2] - 6e7 * y[1], -1e4 * y[1]],\n                [0.0, 6e7 * y[1], 0.0]\n            ]),\n            \"y0\": np.array([1.0, 0.0, 0.0]),\n            \"t0\": 0.0,\n            \"T\": 1e-4,\n            \"h\": 1e-6,\n            \"report_idx\": 2,\n        },\n        {\n            \"id\": 4,\n            \"f\": lambda t, y: 0.0 * y,\n            \"jac\": lambda t, y: np.array([[0.0]]),\n            \"y0\": np.array([-5.5]),\n            \"t0\": 0.0,\n            \"T\": 3.7,\n            \"h\": 0.37,\n            \"report_idx\": 0,\n        },\n        {\n            \"id\": 5,\n            \"f\": (lambda A: lambda t, y: A @ y)(np.array([[-50.0, 49.0], [0.0, -1.0]])),\n            \"jac\": (lambda A: lambda t, y: A)(np.array([[-50.0, 49.0], [0.0, -1.0]])),\n            \"y0\": np.array([1.0, 1.0]),\n            \"t0\": 0.0,\n            \"T\": 1.0,\n            \"h\": 0.05,\n            \"report_idx\": 0,\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        y_final = sdirk_solver(case[\"f\"], case[\"jac\"], case[\"y0\"], case[\"t0\"], case[\"T\"], case[\"h\"])\n        results.append(y_final[case[\"report_idx\"]])\n\n    # Format output as specified: list of strings rounded to 10 decimal places.\n    formatted_results = [f\"{r:.10f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2402149"}, {"introduction": "不同的龙格-库塔方法看似拥有截然不同的系数（Butcher 表），但它们之间是否存在更深层次的联系？本练习将引导你探索一个更通用、更抽象的视角来看待隐式方法。通过为一个线性刚性系统实现一个通用的 IRK 求解器框架，你将比较两种不同类型但同阶的隐式方法 [@problem_id:2402175]。这个过程不仅将向你介绍一种优雅的、基于克罗内克积（Kronecker product）的实现技术，还将揭示一个核心概念：对于线性问题，方法的行为完全由其稳定性函数 $R(z)$ 决定，这解释了为何看似不同的方法可能产生相同的结果。", "problem": "您的任务是实现并比较两种不同的同代数阶隐式龙格-库塔方法在一个刚性线性系统上的表现。此比较必须是定量的，使用一个数学上定义的误差度量，并且最终程序必须按照要求的输出格式为指定的测试套件生成结果。\n\n其基本根据是针对自治线性刚性常微分方程组的初值问题(IVP)，定义为\n$$\n\\frac{d\\mathbf{y}}{dt} = \\mathbf{J}\\,\\mathbf{y}, \\quad \\mathbf{y}(0)=\\mathbf{y}_0,\n$$\n其中 $\\mathbf{y}(t)\\in\\mathbb{R}^n$，$\\mathbf{J}\\in\\mathbb{R}^{n\\times n}$ 是常数矩阵，其精确解为\n$$\n\\mathbf{y}(t) = \\exp(t\\,\\mathbf{J})\\,\\mathbf{y}_0.\n$$\n对于待求解的具体问题，设 $n=2$，$\\mathbf{y}_0 = [1,\\,1]^\\top$，并且\n$$\n\\mathbf{J} =\n\\begin{bmatrix}\n-1000 & 999\\\\\n0 & -999\n\\end{bmatrix}.\n$$\n对于此系统，精确解的分量为\n$$\ny_2(t) = e^{-999 t}, \\qquad\ny_1(t) = 999\\,e^{-999 t} - 998\\,e^{-1000 t}.\n$$\n\n您必须以通用形式实现一个单步隐式龙格-库塔时间积分器。给定步长 $h>0$ 和具有 $s$ 个节点的Butcher系数 $(\\mathbf{A},\\mathbf{b},\\mathbf{c})$，内部节点值 $\\mathbf{Y}_i \\in \\mathbb{R}^n$ 满足\n$$\n\\mathbf{Y}_i = \\mathbf{y}_n + h \\sum_{j=1}^{s} a_{ij}\\, f(\\mathbf{Y}_j), \\quad i=1,\\dots,s,\n$$\n并且步长更新公式为\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\sum_{i=1}^{s} b_i\\, f(\\mathbf{Y}_i),\n$$\n对于本问题，$f(\\mathbf{y})=\\mathbf{J}\\mathbf{y}$。对于线性自治系统，这可以写成一个分块线性系统\n$$\n\\left(\\mathbf{I}_{sn} - h\\,\\mathbf{A}\\otimes \\mathbf{J}\\right)\\, \\mathbf{Y} = \\mathbf{1}_s \\otimes \\mathbf{y}_n,\n$$\n其中 $\\mathbf{Y}\\in\\mathbb{R}^{sn}$ 是将所有节点向量堆叠而成的向量，$\\mathbf{I}_{sn}$ 是大小为 $sn \\times sn$ 的单位矩阵，$\\otimes$ 表示克罗内克积，$\\mathbf{1}_s$ 是 $s$ 维的全1向量。在求解出 $\\mathbf{Y}$ 之后，更新步骤为\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\sum_{i=1}^{s} b_i\\, \\mathbf{J}\\mathbf{Y}_i.\n$$\n\n实现并比较以下两种代数阶均为 $2$ 的隐式龙格-库塔方法：\n- 隐式中点法（在 $c_1=\\tfrac{1}{2}$ 处的单节点Gauss–Legendre配置），其Butcher表系数为\n$$\n\\mathbf{A} = \\begin{bmatrix} \\tfrac{1}{2} \\end{bmatrix}, \\quad\n\\mathbf{b} = \\begin{bmatrix} 1 \\end{bmatrix}, \\quad\n\\mathbf{c} = \\begin{bmatrix} \\tfrac{1}{2} \\end{bmatrix}.\n$$\n\n- 梯形法则（在 $c_1=0$, $c_2=1$ 处的双节点Lobatto IIIA配置），其Butcher表系数为\n$$\n\\mathbf{A} = \\begin{bmatrix} 0 & 0 \\\\ \\tfrac{1}{2} & \\tfrac{1}{2} \\end{bmatrix}, \\quad\n\\mathbf{b} = \\begin{bmatrix} \\tfrac{1}{2} & \\tfrac{1}{2} \\end{bmatrix}, \\quad\n\\mathbf{c} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}.\n$$\n\n使用最终时刻全局误差的无穷范数，定义为\n$$\n\\|\\mathbf{e}\\|_{\\infty} = \\max\\left( |e_1|, |e_2| \\right), \\quad \\mathbf{e} = \\mathbf{y}_{\\text{num}}(T) - \\mathbf{y}_{\\text{exact}}(T),\n$$\n其中 $\\mathbf{y}_{\\text{num}}(T)$ 是使用步长 $h$ 进行 $N$ 步（$N = T/h$）后的数值解，而 $\\mathbf{y}_{\\text{exact}}(T)$ 是如上所述的精确解。\n\n测试套件与要求输出：\n- 所有测试的最终时间均为 $T=1$。对于每个指定的步长 $h$，分别使用每种方法从相同的初始条件开始，执行 $N=T/h$ 个均匀步长，并计算每种方法在 $t=T$ 时的误差无穷范数。\n- 对每个测试用例，计算比率\n$$\nr(h) = \\frac{\\|\\mathbf{e}\\|_{\\infty}^{\\text{midpoint}}}{\\|\\mathbf{e}\\|_{\\infty}^{\\text{trapezoidal}}}.\n$$\n\n使用以下三个测试用例，它们涵盖了大步长情形、典型的中等步长情形和精细步长情形：\n- 测试 1：$h = 1$。\n- 测试 2：$h = 0.1$。\n- 测试 3：$h = 0.01$。\n\n您的程序应生成单行输出，其中包含按测试用例顺序排列的三个比率，格式为方括号括起来的逗号分隔列表（例如，`[r1,r2,r3]`）。不应打印任何其他文本。所有值都是无量纲的；没有需要报告的物理单位。不涉及角度。不涉及百分比，且不得使用。", "solution": "所提出的问题已经过验证，被认定是科学上可靠、适定且客观的。它构成了刚性常微分方程数值分析领域的一个标准练习。所有必要的数据和定义均已提供，不存在矛盾或歧义。因此，我将继续提供完整的解决方案。\n\n该问题要求在一个刚性线性初值问题(IVP)上，实现并比较两种不同的二阶隐式龙格-库塔(IRK)方法。解决方案的核心是基于为线性自治系统提供的矩阵公式，构建一个通用的时间步进函数，然后应用每种方法特有的Butcher表系数来执行计算。\n\n控制性IVP由 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{J}\\,\\mathbf{y}$ 给出，其中 $\\mathbf{y}(t) \\in \\mathbb{R}^2$，$\\mathbf{y}(0) = [1, 1]^\\top$，并且常数雅可比矩阵为\n$$\n\\mathbf{J} =\n\\begin{bmatrix}\n-1000 & 999\\\\\n0 & -999\n\\end{bmatrix}.\n$$\n在时间 $t$ 时的精确解为 $\\mathbf{y}_{\\text{exact}}(t) = \\exp(t\\mathbf{J})\\mathbf{y}_0$。\n\n一个通用的 $s$ 节点IRK方法从 $\\mathbf{y}_n$到 $\\mathbf{y}_{n+1}$，跨越一个时间步长 $h$ 的单步计算，由内部节点值 $\\mathbf{Y}_i$ 和更新规则定义。对于线性系统 $f(\\mathbf{y}) = \\mathbf{J}\\mathbf{y}$，节点方程可以整合为一个单一的分块线性系统：\n$$\n\\left(\\mathbf{I}_{sn} - h\\,\\mathbf{A}\\otimes \\mathbf{J}\\right)\\, \\mathbf{Y} = \\mathbf{1}_s \\otimes \\mathbf{y}_n.\n$$\n这里，$s$ 是节点数，$n=2$ 是常微分方程组的维数，$\\mathbf{A}$ 是来自Butcher表的 $s \\times s$ 矩阵，$\\otimes$ 表示克罗内克积，$\\mathbf{I}_{sn}$ 是大小为 $sn$ 的单位矩阵，$\\mathbf{1}_s$ 是 $s$ 维的全1向量，而 $\\mathbf{Y} \\in \\mathbb{R}^{sn}$ 是所有节点解的扁平化向量，即 $\\mathbf{Y} = [\\mathbf{Y}_1^\\top, \\dots, \\mathbf{Y}_s^\\top]^\\top$。\n\n该算法的基石是在每个时间步求解这个 $sn \\times sn$ 的线性系统以得到 $\\mathbf{Y}$。一旦求得 $\\mathbf{Y}$，解就通过更新公式推进到下一个时间层级：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\sum_{i=1}^{s} b_i\\, f(\\mathbf{Y}_i) = \\mathbf{y}_n + h \\sum_{i=1}^{s} b_i\\, \\mathbf{J}\\mathbf{Y}_i,\n$$\n其中系数 $b_i$是来自Butcher表的权重。这为任何IRK方法提供了一个统一的算法框架。\n\n待比较的两种方法是：\n1.  **隐式中点法：** 一个 $s=1$ 节点的Gauss-Legendre方法，其系数为 $\\mathbf{A} = [\\frac{1}{2}]$，$\\mathbf{b} = [1]$。节点的线性系统大小为 $1 \\cdot 2 = 2$。\n2.  **梯形法则：** 一个 $s=2$ 节点的Lobatto IIIA方法，其系数为 $\\mathbf{A} = \\begin{bmatrix} 0 & 0 \\\\ \\frac{1}{2} & \\frac{1}{2} \\end{bmatrix}$，$\\mathbf{b} = [\\frac{1}{2}, \\frac{1}{2}]^\\top$。节点的线性系统大小为 $2 \\cdot 2 = 4$。\n\n对于形如 $\\dot{\\mathbf{y}} = \\mathbf{J}\\mathbf{y}$ 的线性问题，单步计算后的数值解可以表示为 $\\mathbf{y}_{n+1} = R(h\\mathbf{J})\\mathbf{y}_n$，其中 $R(z)$ 是方法的稳定性函数。对于隐式中点法和梯形法则，其稳定性函数均为指数函数的 $(1,1)$阶Padé近似，$R(z) = (1 + z/2)/(1 - z/2)$。因此，对于任何线性问题，这两种方法理论上会产生完全相同的解序列 $\\{\\mathbf{y}_n\\}$。然而，它们各自的计算实现，由通用框架和其不同的Butcher表所决定，涉及不同的中间步骤和矩阵大小。因此，所要求的比较将揭示这些不同计算路径中因浮点运算而产生的任何差异。\n\n实现过程如下：\n首先，创建一个通用函数 `irk_step(yn, h, J, A, b)`。该函数完全遵循数学规范，构建并求解关于节点 $\\mathbf{Y}$ 的线性系统，然后计算更新后的 $\\mathbf{y}_{n+1}$。\n\n其次，一个仿真函数 `run_simulation(h, A, b)` 将重复调用 `irk_step` 函数 $N = T/h$ 次，以将解从 $t=0$ 积分到 $t=T=1$。\n\n第三，对由步长 $h \\in \\{1, 0.1, 0.01\\}$ 定义的每个测试用例，对两种方法都进行仿真。使用提供的解析公式计算精确解 $\\mathbf{y}_{\\text{exact}}(T)$。计算每种方法的全局误差 $\\mathbf{e} = \\mathbf{y}_{\\text{num}}(T) - \\mathbf{y}_{\\text{exact}}(T)$，并确定其无穷范数 $\\|\\mathbf{e}\\|_\\infty$。\n\n最后，为每个 $h$ 计算误差范数的比率 $r(h) = \\|\\mathbf{e}\\|_{\\infty}^{\\text{midpoint}} / \\|\\mathbf{e}\\|_{\\infty}^{\\text{trapezoidal}}$。这些比率的集合构成了最终结果。鉴于这两种方法对于此问题的理论等价性，该比率预计会非常接近于 $1$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares implicit midpoint and trapezoidal Runge-Kutta methods\n    on a stiff linear system, as specified in the problem statement.\n    \"\"\"\n\n    # Define problem parameters\n    J = np.array([[-1000.0, 999.0], [0.0, -999.0]])\n    Y0 = np.array([1.0, 1.0])\n    T_FINAL = 1.0\n\n    def y_exact(t: float) -> np.ndarray:\n        \"\"\"\n        Computes the exact solution of the IVP at a given time t.\n\n        Args:\n            t: The time at which to evaluate the solution.\n\n        Returns:\n            The solution vector y(t).\n        \"\"\"\n        if t < 0:\n            raise ValueError(\"Time must be non-negative.\")\n        \n        # For large negative exponents, np.exp underflows to 0.0, which is correct.\n        exp_m999t = np.exp(-999.0 * t)\n        exp_m1000t = np.exp(-1000.0 * t)\n        \n        y2 = exp_m999t\n        y1 = 999.0 * exp_m999t - 998.0 * exp_m1000t\n        \n        return np.array([y1, y2])\n\n    def irk_step(yn: np.ndarray, h: float, J_matrix: np.ndarray, A: np.ndarray, b: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Performs a single step of a generic implicit Runge-Kutta method for a\n        linear system dy/dt = J*y.\n\n        Args:\n            yn: Solution vector at the beginning of the step.\n            h: Step size.\n            J_matrix: The constant Jacobian matrix of the linear system.\n            A: The 'A' matrix from the Butcher tableau.\n            b: The 'b' vector from the Butcher tableau.\n\n        Returns:\n            The solution vector at the end of the step.\n        \"\"\"\n        s = A.shape[0]\n        n = J_matrix.shape[0]\n\n        # Form the linear system for the stages Y:\n        # (I_sn - h * A kron J) * Y_stacked = 1_s kron yn\n        M = np.eye(s * n) - h * np.kron(A, J_matrix)\n        rhs = np.kron(np.ones((s, 1)), yn.reshape(-1, 1))\n\n        # Solve for the stacked stage vector Y_stacked\n        Y_stacked = np.linalg.solve(M, rhs)\n\n        # Reshape Y_stacked into s stage vectors of size n\n        Y_stages = Y_stacked.reshape(s, n)\n\n        # Compute the update using the formula:\n        # y_{n+1} = y_n + h * sum(b_i * J * Y_i)\n        update_sum = np.zeros(n)\n        for i in range(s):\n            update_sum += b[i] * np.dot(J_matrix, Y_stages[i])\n\n        yn_plus_1 = yn + h * update_sum\n        return yn_plus_1\n\n    def run_simulation(h: float, A: np.ndarray, b: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Runs the full simulation from t=0 to T_FINAL with a given step size h\n        and a specific IRK method.\n\n        Args:\n            h: The step size.\n            A: The Butcher 'A' matrix for the method.\n            b: The Butcher 'b' vector for the method.\n\n        Returns:\n            The numerical solution at T_FINAL.\n        \"\"\"\n        # The problem implies T/h is an integer number of steps.\n        # Use round to handle potential floating-point inaccuracies in division.\n        num_steps = int(round(T_FINAL / h))\n        \n        y = Y0.copy()\n        for _ in range(num_steps):\n            y = irk_step(y, h, J, A, b)\n        \n        return y\n\n    # Define Butcher tableaus for the two methods\n    # Method 1: Implicit Midpoint (s=1, order 2)\n    A_midpoint = np.array([[0.5]])\n    b_midpoint = np.array([1.0])\n\n    # Method 2: Trapezoidal Rule (s=2, order 2)\n    A_trap = np.array([[0.0, 0.0], [0.5, 0.5]])\n    b_trap = np.array([0.5, 0.5])\n    \n    # Define test cases from the problem statement\n    test_cases = [\n        1.0,    # Test 1\n        0.1,    # Test 2\n        0.01,   # Test 3\n    ]\n\n    results = []\n    \n    # Calculate exact solution at final time\n    y_exact_final = y_exact(T_FINAL)\n\n    for h in test_cases:\n        # Run simulation for both methods\n        y_num_midpoint = run_simulation(h, A_midpoint, b_midpoint)\n        y_num_trap = run_simulation(h, A_trap, b_trap)\n\n        # Calculate the infinity norm of the global error for each method\n        error_midpoint = np.max(np.abs(y_num_midpoint - y_exact_final))\n        error_trap = np.max(np.abs(y_num_trap - y_exact_final))\n\n        # Compute the ratio of the errors\n        if error_trap == 0.0:\n            # This case occurs if the trapezoidal method is numerically exact.\n            # If midpoint error is also zero, ratio is 1. Otherwise, it's infinite.\n            ratio = 1.0 if error_midpoint == 0.0 else np.inf\n        else:\n            ratio = error_midpoint / error_trap\n            \n        results.append(ratio)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2402175"}]}