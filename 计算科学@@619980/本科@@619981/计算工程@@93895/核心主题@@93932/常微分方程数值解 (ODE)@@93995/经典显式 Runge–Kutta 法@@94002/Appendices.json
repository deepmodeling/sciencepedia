{"hands_on_practices": [{"introduction": "在计算科学中，信任数值结果之前，必须先验证代码的正确性。一个核心的验证技术是确认数值方法是否达到了其理论收敛阶（order of accuracy）。本练习将指导你实现一个通用的龙格-库塔求解器，并使用“制造解方法”(Method of Manufactured Solutions)来数值地验证几种常见方法的收敛阶，这是确保数值模拟可靠性的基础。[@problem_id:2376768]", "problem": "编写一个完整的程序，根据以 Butcher 表形式给出的几种显式 Runge-Kutta (RK) 方法，通过对一个常微分方程 (ODE) 初值问题的制造解进行测试，来数值验证每种方法的精度阶数。制造解定义如下：设精确解为 $y(t)=\\exp(\\sin t)$，对于 $t \\in [0,1]$，其中角度以弧度为单位。该 ODE 为 $y'(t)=f(t,y(t))$，其中 $f(t,y)=\\cos(t)\\,y$，初始条件为 $y(0)=1$，最终时间为 $T=1$。使用最终时间 $t=T$ 时的全局误差来量化精度。\n\n使用以下显式 Runge-Kutta 方法，每种方法均由其 Butcher 表 $(A,b,c)$ 指定：\n- 方法 $1$ (显式 Euler 法，期望阶数为 $1$)：$s=1$, $A=\\begin{bmatrix}0\\end{bmatrix}$, $b=\\begin{bmatrix}1\\end{bmatrix}$, $c=\\begin{bmatrix}0\\end{bmatrix}$。\n- 方法 $2$ (显式中点法，期望阶数为 $2$)：$s=2$, $A=\\begin{bmatrix}0 & 0\\\\ \\tfrac{1}{2} & 0\\end{bmatrix}$, $b=\\begin{bmatrix}0 & 1\\end{bmatrix}$, $c=\\begin{bmatrix}0 & \\tfrac{1}{2}\\end{bmatrix}$。\n- 方法 $3$ (Kutta 三阶方法，期望阶数为 $3$)：$s=3$, $A=\\begin{bmatrix}0 & 0 & 0\\\\ \\tfrac{1}{2} & 0 & 0\\\\ -1 & 2 & 0\\end{bmatrix}$, $b=\\begin{bmatrix}\\tfrac{1}{6} & \\tfrac{2}{3} & \\tfrac{1}{6}\\end{bmatrix}$, $c=\\begin{bmatrix}0 & \\tfrac{1}{2} & 1\\end{bmatrix}$。\n- 方法 $4$ (经典 RK4 法，期望阶数为 $4$)：$s=4$, $A=\\begin{bmatrix}0 & 0 & 0 & 0\\\\ \\tfrac{1}{2} & 0 & 0 & 0\\\\ 0 & \\tfrac{1}{2} & 0 & 0\\\\ 0 & 0 & 1 & 0\\end{bmatrix}$, $b=\\begin{bmatrix}\\tfrac{1}{6} & \\tfrac{1}{3} & \\tfrac{1}{3} & \\tfrac{1}{6}\\end{bmatrix}$, $c=\\begin{bmatrix}0 & \\tfrac{1}{2} & \\tfrac{1}{2} & 1\\end{bmatrix}$。\n\n对于每种方法，在 $[0,1]$ 上使用大小为 $h=1/N$ 的均匀时间步长进行时间积分，其中 $N$ 在测试集 $\\{10,20,40,80,160,320\\}$ 中。对于每个 $N$，计算在 $t=1$ 时的数值近似解 $y_N$，计算全局误差 $E(h)=\\lvert y_N - y(1)\\rvert$，然后通过对测试集中所有 $N$ 值的数据 $(\\log h,\\log E(h))$ 进行线性拟合，将所得直线的最小二乘斜率作为观测阶数 $p$ 的估计值。$\\log$ 使用自然对数。\n\n您的程序必须在单行中输出一个用方括号括起来的逗号分隔列表，其中包含方法 $1$ 到方法 $4$ 的四个估计阶数 $(p_1,p_2,p_3,p_4)$，每个阶数需四舍五入到两位小数。不应打印任何其他文本。\n\n测试集与答案规范：\n- 测试集由上述四种方法组成，每种方法都使用 $N \\in \\{10,20,40,80,160,320\\}$ 进行测试。\n- 最终答案是四个浮点数 $p_1$、$p_2$、$p_3$、$p_4$，分别是相应方法的观测阶数估计值。\n- 最终输出格式必须是形如 $\\texttt{[p1,p2,p3,p4]}$ 的单行文本，其中每个 $p_k$ 是四舍五入到两位小数的十进制数。", "solution": "问题陈述已经过严格分析。它具有科学依据，提法明确，并包含了获得唯一且有意义解所需的所有信息。指定的常微分方程、其制造解析解、通过 Butcher 表对 Runge-Kutta 方法的定义，以及用于数值验证精度阶数的程序，全都是标准的、正确的且自洽的。该问题有效。我们现在将构建解答。\n\n基本任务是求解一个形如下式的初值问题 (IVP)：\n$$ y'(t) = f(t, y(t)), \\quad y(t_0) = y_0 $$\n对于 $t \\in [t_0, T]$。问题给出了具体函数 $f(t, y) = \\cos(t) y$、初始条件 $y(0) = 1$ 以及时间区间 $[0, 1]$。精确解被给出为 $y(t) = \\exp(\\sin t)$，这可以通过求导很容易地得到验证：$y'(t) = \\exp(\\sin t) \\cdot \\cos(t) = y(t)\\cos(t)$，并检查初始条件：$y(0) = \\exp(\\sin 0) = \\exp(0) = 1$。\n\n一个 $s$ 阶显式 Runge-Kutta (RK) 方法通过以步长 $h$ 向前步进的方式来近似求解。从 $t_n$ 时刻的解 $y_n$ 出发，计算 $t_{n+1} = t_n + h$ 时刻的解 $y_{n+1}$。该方法由一组排列在 Butcher 表中的系数定义：\n$$\n\\begin{array}{c|c}\nc & A \\\\\n\\hline\n  & b^T\n\\end{array} \\quad \\text{其中 } c \\in \\mathbb{R}^s, b \\in \\mathbb{R}^s, A \\in \\mathbb{R}^{s \\times s}\n$$\n对于显式方法，矩阵 $A$ 是严格下三角矩阵，意味着当 $j \\ge i$ 时 $a_{ij} = 0$。计算分阶段进行。首先，对于 $i=1, 2, \\dots, s$，计算 $s$ 个阶段导数 $k_i$：\n$$ k_i = f\\left(t_n + c_i h, y_n + h \\sum_{j=1}^{i-1} a_{ij} k_j\\right) $$\n然后，使用这些阶段导数的加权平均来推进解：\n$$ y_{n+1} = y_n + h \\sum_{i=1}^{s} b_i k_i $$\n\n数值方法的精度由其收敛阶数 $p$ 来表征。对于一个 $p$ 阶方法，在固定的最终时间 $T$ 时的全局误差（表示为 $E(h)$）预计会随着步长 $h$ 的减小而遵循以下关系式减小：\n$$ E(h) = |y_N - y(T)| \\approx C h^p $$\n其中 $y_N$ 是在 $T=Nh$ 时的数值解，$C$ 是一个依赖于方法和问题，但不依赖于 $h$ 的常数。\n\n为了数值验证阶数 $p$，我们可以对该关系式两边取自然对数来进行变换：\n$$ \\ln(E(h)) \\approx \\ln(C) + p \\ln(h) $$\n该方程的形式为 $Y = mX + B$，其中 $Y = \\ln(E(h))$，$X = \\ln(h)$，斜率为 $m = p$，截距为 $B = \\ln(C)$。这种线性关系意味着 $\\ln(E(h))$ 关于 $\\ln(h)$ 的图将近似于一条直线，其斜率即为该方法的阶数 $p$。\n\n指定的步骤如下：\n$1$. 对于给定的四种 RK 方法中的每一种，都必须在区间 $[0, 1]$ 上执行一系列数值积分。\n$2$. 积分将使用一系列递减的步长 $h = 1/N$，其中 $N \\in \\{10, 20, 40, 80, 160, 320\\}$。\n$3$. 对于每个特定步长 $h$ 的积分，计算最终时刻的数值近似解 $y_N$。\n$4$. 全局误差计算为 $E(h) = |y_N - y(1)|$，其中精确值为 $y(1) = \\exp(\\sin 1)$。\n$5$. 计算完所有步长的误差后，收集数据对 $(\\ln(h), \\ln(E(h)))$。\n$6$. 对这些数据点执行线性最小二乘回归。所得最佳拟合直线的斜率提供了精度阶数 $p$ 的实验估计值。一组数据点 $(x_i, y_i)$ 的斜率 $p$ 由下式给出：\n$$ p = \\frac{\\sum_{i=1}^{M} (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i=1}^{M} (x_i - \\bar{x})^2} $$\n其中 $x_i = \\ln(h_i)$，$y_i = \\ln(E(h_i))$，$\\bar{x}$ 和 $\\bar{y}$ 是平均值，而 $M=6$ 是测试集中的步长数量。\n\n此过程将对所提供的四个 Butcher 表中的每一个都实施，从而得到四个估计的精度阶数 $(p_1, p_2, p_3, p_4)$，这些值预期将分别接近其理论值 $1, 2, 3,$ 和 $4$。最终结果将是这四个值，并四舍五入到两位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Numerically verifies the order of accuracy of several explicit Runge-Kutta methods.\n    \"\"\"\n    # Define the Ordinary Differential Equation and its analytical solution\n    f = lambda t, y: np.cos(t) * y\n    t_start = 0.0\n    y_start = 1.0\n    t_end = 1.0\n    \n    # Pre-calculate the exact solution at the final time for error computation\n    y_exact_final = np.exp(np.sin(t_end))\n\n    # Define the Butcher tableaus for the four RK methods\n    methods = [\n        {\n            # Method 1: Explicit Euler (Order 1)\n            'A': np.array([[0.0]]),\n            'b': np.array([1.0]),\n            'c': np.array([0.0])\n        },\n        {\n            # Method 2: Explicit Midpoint (Order 2)\n            'A': np.array([[0.0, 0.0], [0.5, 0.0]]),\n            'b': np.array([0.0, 1.0]),\n            'c': np.array([0.0, 0.5])\n        },\n        {\n            # Method 3: Kutta's third-order method (Order 3)\n            'A': np.array([[0.0, 0.0, 0.0], [0.5, 0.0, 0.0], [-1.0, 2.0, 0.0]]),\n            'b': np.array([1.0/6.0, 2.0/3.0, 1.0/6.0]),\n            'c': np.array([0.0, 0.5, 1.0])\n        },\n        {\n            # Method 4: Classical RK4 (Order 4)\n            'A': np.array([\n                [0.0, 0.0, 0.0, 0.0],\n                [0.5, 0.0, 0.0, 0.0],\n                [0.0, 0.5, 0.0, 0.0],\n                [0.0, 0.0, 1.0, 0.0]\n            ]),\n            'b': np.array([1.0/6.0, 1.0/3.0, 1.0/3.0, 1.0/6.0]),\n            'c': np.array([0.0, 0.5, 0.5, 1.0])\n        }\n    ]\n\n    # Test suite of step counts\n    N_values = [10, 20, 40, 80, 160, 320]\n    h_values = np.array([1.0 / N for N in N_values])\n\n    estimated_orders = []\n\n    for method in methods:\n        A, b, c = method['A'], method['b'], method['c']\n        s = len(b)  # Number of stages\n        errors = []\n\n        for N in N_values:\n            h = (t_end - t_start) / N\n            y_current = y_start\n            \n            # Time integration loop\n            for n in range(N):\n                t_n = t_start + n * h\n                k_stages = np.zeros(s)\n                \n                # Calculate stage derivatives k_i\n                for i in range(s):\n                    stage_sum = 0.0\n                    for j in range(i):\n                        stage_sum += A[i, j] * k_stages[j]\n                    \n                    y_stage_input = y_current + h * stage_sum\n                    t_stage_input = t_n + c[i] * h\n                    k_stages[i] = f(t_stage_input, y_stage_input)\n                \n                # Update solution\n                y_current += h * np.dot(b, k_stages)\n            \n            # Store the global error at t=T\n            errors.append(np.abs(y_current - y_exact_final))\n\n        # Use natural logarithm for the log-log plot\n        log_h = np.log(h_values)\n        log_E = np.log(np.array(errors))\n        \n        # Perform linear regression (polynomial fit of degree 1)\n        # The slope of the line is the estimated order of accuracy\n        # np.polyfit returns [slope, intercept]\n        slope = np.polyfit(log_h, log_E, 1)[0]\n        estimated_orders.append(slope)\n        \n    # Format the output as specified: [p1,p2,p3,p4]\n    formatted_results = [f'{p:.2f}' for p in estimated_orders]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2376768"}, {"introduction": "当我们掌握了经过验证的数值方法后，一个自然的问题是它们在解决实际问题时表现如何。本练习将让你应用从一阶（欧拉法）到四阶（经典RK4）等不同阶数的龙格-库塔方法来求解一个非线性常微分方程。通过比较它们在不同步长下的精度和维持解的定性行为的能力，你将直观地感受到高阶格式的强大之处。[@problem_id:2376808]", "problem": "考虑由常微分方程 $y'(t)=-y(t)^3$ 和初始条件 $y(0)=1$ 定义的初值问题。其唯一的精确解为 $y(t)=\\dfrac{1}{\\sqrt{1+2t}}$。令 $f(t,y)=-y^3$。\n\n定义四种经典的显式 Runge-Kutta 方法，使用均匀时间步长 $h>0$ 将近似值 $y_n \\approx y(t_n)$ 推进到 $y_{n+1} \\approx y(t_{n+1})$：\n- $RK1$：前向欧拉法（一阶）。\n- $RK2$：显式中点法（二阶）。\n- $RK3$：Kutta 三阶方法（三阶）。\n- $RK4$：经典四阶方法（四阶）。\n\n对于下面指定的每个测试用例，从 $t_0=0$, $y_0=1$ 开始，使用均匀步长 $h$ 经过 $N=T/h$ 步（假设 $T/h$ 为整数）到达最终时刻 $T$。对于每个测试用例，计算以下四个量：\n1. 最终时刻的绝对误差 $E=\\lvert y_N - y(T)\\rvert$，其中 $y(T)=1/\\sqrt{1+2T}$。报告 $E$ 时四舍五入到10位小数。\n2. 一个布尔值，指示序列 $\\{y_n\\}_{n=0}^N$ 是否单调非增，即对所有 $n$ 满足 $y_{n+1}\\le y_n+\\varepsilon$，其中 $\\varepsilon=10^{-12}$。\n3. 一个布尔值，指示所有迭代值是否在容差范围内非负，即对所有 $n$ 满足 $y_n\\ge -\\varepsilon$，其中 $\\varepsilon=10^{-12}$。\n4. 达到 $T$ 所用的整数时间步数 $N$。\n\n使用以下测试套件，其中每个案例以三元组 $(\\text{method},T,h)$ 的形式给出，其中 $T$ 的单位是时间， $h$ 的单位是时间：\n- 案例 $1$：$(RK1,\\,T=10,\\,h=1)$。\n- 案例 $2$：$(RK2,\\,T=10,\\,h=1)$。\n- 案例 $3$：$(RK3,\\,T=10,\\,h=1)$。\n- 案例 $4$：$(RK4,\\,T=10,\\,h=1)$。\n- 案例 $5$：$(RK1,\\,T=10,\\,h=2)$。\n- 案例 $6$：$(RK4,\\,T=10,\\,h=0.5)$。\n- 案例 $7$：$(RK1,\\,T=10,\\,h=0.5)$。\n- 案例 $8$：$(RK2,\\,T=100,\\,h=1)$。\n- 案例 $9$：$(RK3,\\,T=100,\\,h=1)$。\n- 案例 $10$：$(RK4,\\,T=100,\\,h=1)$。\n\n您的程序必须生成单行输出，该输出包含一个用方括号括起来的逗号分隔列表。该列表应按上述顺序为每个测试用例包含一个条目。每个条目本身必须是如上定义的四个值 $[E,\\,\\text{monotone},\\,\\text{nonnegative},\\,N]$ 的列表，其中 $E$ 是一个四舍五入到10位小数的浮点数，$\\text{monotone}$ 和 $\\text{nonnegative}$ 是布尔值，$N$ 是一个整数。例如，整体输出格式必须是\n$$\n\\big[\\,[E_1,\\text{mon}_1,\\text{nonneg}_1,N_1],\\,[E_2,\\text{mon}_2,\\text{nonneg}_2,N_2],\\,\\dots,\\,[E_{10},\\text{mon}_{10},\\text{nonneg}_{10},N_{10}]\\,\\big].\n$$\n不涉及角度或物理单位；所有量均为无量纲。所有浮点输出都必须遵守上述四舍五入规范。", "solution": "问题陈述已经过严格审查，并被确定为有效。这是一个在计算工程领域中提法明确、有科学依据的问题，具体涉及常微分方程的数值解法。所有必要的数据、定义和边界条件都已提供，不存在矛盾或歧义。\n\n任务是求解由常微分方程（ODE）定义的初值问题（IVP）：\n$$\ny'(t) = -y(t)^3\n$$\n初始条件为 $y(0)=1$。等式右侧的函数为 $f(t,y) = -y^3$。这是一个可分离的常微分方程，其对于给定初始条件的唯一精确解是：\n$$\ny(t) = \\frac{1}{\\sqrt{1+2t}}\n$$\n我们需要使用四种经典的显式 Runge-Kutta (RK) 方法来近似该解。在时刻 $t_n$ 的近似值 $y_n$ 使用均匀时间步长 $h > 0$ 推进到时刻 $t_{n+1} = t_n + h$ 的 $y_{n+1}$。每个测试用例的模拟从 $t_0=0$ 时的 $y_0=1$ 开始，经过 $N=T/h$ 步到达最终时刻 $T$。\n\n指定的四种 RK 方法如下：\n$1$. **RK1 (前向欧拉法，1 阶):**\n$$\ny_{n+1} = y_n + h f(t_n, y_n)\n$$\n\n$2$. **RK2 (显式中点法，2 阶):**\n$$\n\\begin{aligned}\nk_1 &= f(t_n, y_n) \\\\\nk_2 &= f\\left(t_n + \\frac{h}{2}, y_n + \\frac{h}{2} k_1\\right) \\\\\ny_{n+1} &= y_n + h k_2\n\\end{aligned}\n$$\n\n$3$. **RK3 (Kutta 三阶方法，3 阶):**\n$$\n\\begin{aligned}\nk_1 &= f(t_n, y_n) \\\\\nk_2 &= f\\left(t_n + \\frac{h}{2}, y_n + \\frac{h}{2} k_1\\right) \\\\\nk_3 &= f\\left(t_n + h, y_n - h k_1 + 2h k_2\\right) \\\\\ny_{n+1} &= y_n + \\frac{h}{6}(k_1 + 4k_2 + k_3)\n\\end{aligned}\n$$\n\n$4$. **RK4 (经典四阶方法，4 阶):**\n$$\n\\begin{aligned}\nk_1 &= f(t_n, y_n) \\\\\nk_2 &= f\\left(t_n + \\frac{h}{2}, y_n + \\frac{h}{2} k_1\\right) \\\\\nk_3 &= f\\left(t_n + \\frac{h}{2}, y_n + \\frac{h}{2} k_2\\right) \\\\\nk_4 &= f\\left(t_n + h, y_n + h k_3\\right) \\\\\ny_{n+1} &= y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n\\end{aligned}\n$$\n\n对于由元组 $(\\text{method}, T, h)$ 定义的每个测试用例，执行以下算法：\n首先，用 $t_0=0$, $y_0=1$ 初始化模拟。总步数为 $N = T/h$。初始化一个列表以存储近似值序列 $\\{y_n\\}_{n=0}^N$。\n然后，一个循环对 $n$ 从 $0$ 到 $N-1$ 运行。在每次迭代中，使用指定 RK 方法的公式从 $y_n$ 计算出值 $y_{n+1}$。新值 $y_{n+1}$ 被追加到历史列表中。\n\n完成所有 $N$ 步后，计算四个量：\n$1$. 最终时刻 $T$ 的绝对误差 $E$，计算公式为 $E = \\lvert y_N - y(T) \\rvert$，其中 $y_N$ 是最终的数值近似值，而 $y(T)$ 是在 $T$ 处求值的精确解。报告此值时需四舍五入到10位小数。\n$2$. 一个布尔值，指示计算出的序列 $\\{y_n\\}$ 是否单调非增。通过检查是否对所有 $n \\in \\{0, 1, \\dots, N-1\\}$ 都满足 $y_{n+1} \\le y_n + \\varepsilon$ 来验证此项，其中 $\\varepsilon = 10^{-12}$ 是一个用于考虑浮点不精确性的小容差。精确解是严格递减的，因此稳定的数值解应具备此性质。\n$3$. 一个布尔值，指示所有迭代值是否为非负。通过检查是否对所有 $n \\in \\{0, 1, \\dots, N\\}$ 都满足 $y_n \\ge -\\varepsilon$ 来验证此项。精确解是严格为正的，因此任何负值都是数值伪影，通常由不稳定性引起。\n$4$. 完成模拟所用的整数时间步数 $N$。\n\n此过程将应用于所提供的全部10个测试用例。然后将结果汇总到单个列表之列表中，以供最终输出。实现将使用指定的 Python 环境和库。", "answer": "```python\nimport numpy as np\n\ndef f(t, y):\n    \"\"\"\n    Implements the right-hand side of the ODE y' = -y^3.\n    The parameter t is unused as the ODE is autonomous.\n    \"\"\"\n    return -y**3\n\ndef exact_solution(t):\n    \"\"\"\n    Calculates the exact solution y(t) = 1/sqrt(1 + 2t).\n    \"\"\"\n    return 1.0 / np.sqrt(1.0 + 2.0 * t)\n\ndef step_rk1(y_n, h):\n    \"\"\"Performs one step of the Forward Euler (RK1) method.\"\"\"\n    return y_n + h * f(0, y_n)\n\ndef step_rk2(y_n, h):\n    \"\"\"Performs one step of the explicit midpoint (RK2) method.\"\"\"\n    k1 = f(0, y_n)\n    k2 = f(0, y_n + h / 2.0 * k1)\n    return y_n + h * k2\n\ndef step_rk3(y_n, h):\n    \"\"\"Performs one step of Kutta's third-order (RK3) method.\"\"\"\n    k1 = f(0, y_n)\n    k2 = f(0, y_n + h / 2.0 * k1)\n    k3 = f(0, y_n - h * k1 + 2.0 * h * k2)\n    return y_n + (h / 6.0) * (k1 + 4.0 * k2 + k3)\n\ndef step_rk4(y_n, h):\n    \"\"\"Performs one step of the classical fourth-order (RK4) method.\"\"\"\n    k1 = f(0, y_n)\n    k2 = f(0, y_n + h / 2.0 * k1)\n    k3 = f(0, y_n + h / 2.0 * k2)\n    k4 = f(0, y_n + h * k3)\n    return y_n + (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\ndef run_simulation(method, T, h):\n    \"\"\"\n    Runs the simulation for a given method, final time T, and step size h.\n    \"\"\"\n    steppers = {\n        'RK1': step_rk1,\n        'RK2': step_rk2,\n        'RK3': step_rk3,\n        'RK4': step_rk4,\n    }\n    stepper = steppers[method]\n    \n    y0 = 1.0\n    epsilon = 1e-12\n    # The problem statement guarantees T/h is an integer.\n    N = int(T / h)\n\n    y_history = [y0]\n    y_current = y0\n    for _ in range(N):\n        y_current = stepper(y_current, h)\n        y_history.append(y_current)\n    \n    y_N = y_history[-1]\n    y_exact_T = exact_solution(T)\n    \n    # 1. Absolute error at the final time, rounded to 10 decimal places.\n    E = abs(y_N - y_exact_T)\n    E_rounded = round(E, 10)\n    \n    # 2. Monotonically nonincreasing check.\n    is_monotone = all(y_history[i+1] <= y_history[i] + epsilon for i in range(len(y_history) - 1))\n            \n    # 3. Nonnegative check.\n    is_nonnegative = all(y_val >= -epsilon for y_val in y_history)\n            \n    return [E_rounded, is_monotone, is_nonnegative, N]\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite, then prints the formatted results.\n    \"\"\"\n    test_cases = [\n        ('RK1', 10.0, 1.0),\n        ('RK2', 10.0, 1.0),\n        ('RK3', 10.0, 1.0),\n        ('RK4', 10.0, 1.0),\n        ('RK1', 10.0, 2.0),\n        ('RK4', 10.0, 0.5),\n        ('RK1', 10.0, 0.5),\n        ('RK2', 100.0, 1.0),\n        ('RK3', 100.0, 1.0),\n        ('RK4', 100.0, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        method, T, h = case\n        result = run_simulation(method, T, h)\n        results.append(result)\n        \n    # Format the final output string as specified.\n    # The str() representation of a list is \"[item1, item2, ...]\"\n    # which matches the required sub-format for each test case result.\n    result_strings = [str(r) for r in results]\n    output_string = f\"[{','.join(result_strings)}]\"\n    \n    print(output_string)\n\nsolve()\n```", "id": "2376808"}, {"introduction": "一个常见的误解是，阶数越高的数值方法总是越好。本练习将通过一个精心设计的“病态”案例来挑战这一假设。通过分析一个使用了较大时间步长的简单线性常微分方程，你将发现高阶方法有时反而不如低阶方法精确，从而学到关于数值稳定性的一个关键而深刻的教训。[@problem_id:2376761]", "problem": "在计算工程实践中，由于稳定性函数的行为，一个形式精度阶数较高的数值方法在给定的步长下可能表现更差。考虑如下初值问题\n$$\ny'(t)=\\lambda\\,y(t),\\qquad y(0)=1,\n$$\n其中常系数 $\\lambda=-5$。使用从 $t=0$ 到 $t=h$ 的单个时间步长 $h=1$，分别用经典的四阶Runge–Kutta方法和显式中点两阶段二阶Runge–Kutta方法近似计算 $y(h)$。令\n$$\n\\rho=\\frac{\\left|y_{\\mathrm{RK4}}(h)-y(h)\\right|}{\\left|y_{\\mathrm{mid}}(h)-y(h)\\right|}.\n$$\n计算 $\\rho$ 并将其值以纯数字形式给出。将您的答案四舍五入到 $4$ 位有效数字。", "solution": "问题陈述已经过验证，并被确认为计算工程和数值分析领域中一个有效的、适定的问题。我们着手进行求解。\n\n该初值问题 (IVP) 由以下线性常微分方程给出：\n$$\ny'(t) = \\lambda y(t), \\quad y(0) = 1\n$$\n其中常系数 $\\lambda = -5$。题目要求我们使用两种不同的显式Runge-Kutta方法在 $t=h=1$ 处计算近似值，并比较它们的误差。\n\n首先，我们确定该IVP的精确解。这是一个标准的一阶线性齐次微分方程，其解的形式为 $y(t) = C \\exp(\\lambda t)$。使用初始条件 $y(0)=1$，我们得到 $1 = C \\exp(\\lambda \\cdot 0)$，这意味着 $C=1$。因此，精确解为：\n$$\ny(t) = \\exp(\\lambda t)\n$$\n在时间 $t=h=1$，当 $\\lambda = -5$ 时，精确值为：\n$$\ny(h) = \\exp(-5 \\cdot 1) = \\exp(-5)\n$$\n\n接下来，我们分析将显式Runge-Kutta (RK) 方法应用于此测试问题。对于形式为 $y' = f(t,y)$ 的常微分方程，显式RK方法的单步计算形式为 $y_{n+1} = y_n + h \\Phi(t_n, y_n, h)$。当应用于 $y' = \\lambda y$ 时，由于 $f(t,y) = \\lambda y$ 与 $t$ 无关，公式得以简化。下一步的值 $y_1$ 通过稳定性函数 $R(z)$ 与上一步的值 $y_0$ 相关，该函数是 $z=h\\lambda$ 的一个多项式：\n$$\ny_1 = R(h\\lambda) y_0\n$$\n在本例中，$y_0 = y(0) = 1$ 且 $z = h\\lambda = 1 \\cdot (-5) = -5$。因此，在 $t=h$ 处的近似值就是该方法的稳定性函数在 $z=-5$ 处的值。\n\n我们来计算使用经典的四阶Runge-Kutta (RK4) 方法得到的近似值。RK4的稳定性函数是指数函数的4次泰勒多项式：\n$$\nR_{\\mathrm{RK4}}(z) = 1 + z + \\frac{z^2}{2!} + \\frac{z^3}{3!} + \\frac{z^4}{4!}\n$$\n我们计算当 $z=-5$ 时的值：\n$$\ny_{\\mathrm{RK4}}(h) = R_{\\mathrm{RK4}}(-5) = 1 + (-5) + \\frac{(-5)^2}{2} + \\frac{(-5)^3}{6} + \\frac{(-5)^4}{24}\n$$\n$$\ny_{\\mathrm{RK4}}(h) = 1 - 5 + \\frac{25}{2} - \\frac{125}{6} + \\frac{625}{24}\n$$\n为对这些分数求和，我们使用公分母 $24$：\n$$\ny_{\\mathrm{RK4}}(h) = \\frac{24}{24} - \\frac{120}{24} + \\frac{300}{24} - \\frac{500}{24} + \\frac{625}{24} = \\frac{24 - 120 + 300 - 500 + 625}{24} = \\frac{329}{24}\n$$\n\n现在，我们计算使用显式两阶段二阶中点法得到的近似值。该方法的稳定性函数是指数函数的2次泰勒多项式：\n$$\nR_{\\mathrm{mid}}(z) = 1 + z + \\frac{z^2}{2!}\n$$\n我们计算当 $z=-5$ 时的值：\n$$\ny_{\\mathrm{mid}}(h) = R_{\\mathrm{mid}}(-5) = 1 + (-5) + \\frac{(-5)^2}{2} = 1 - 5 + \\frac{25}{2} = -4 + 12.5 = 8.5 = \\frac{17}{2}\n$$\n\n问题要求计算绝对误差的比值 $\\rho$：\n$$\n\\rho = \\frac{\\left|y_{\\mathrm{RK4}}(h)-y(h)\\right|}{\\left|y_{\\mathrm{mid}}(h)-y(h)\\right|}\n$$\n代入计算出的值：\n$$\n\\rho = \\frac{\\left|\\frac{329}{24} - \\exp(-5)\\right|}{\\left|\\frac{17}{2} - \\exp(-5)\\right|}\n$$\n为了计算最终的数值，我们使用以下近似值：\n$\\exp(-5) \\approx 0.006737947$\n$\\frac{329}{24} \\approx 13.7083333$\n$\\frac{17}{2} = 8.5$\n\n分子是RK4方法的绝对误差：\n$$\n\\left|y_{\\mathrm{RK4}}(h)-y(h)\\right| = |13.7083333... - 0.0067379...| \\approx 13.7015954\n$$\n分母是中点法的绝对误差：\n$$\n\\left|y_{\\mathrm{mid}}(h)-y(h)\\right| = |8.5 - 0.0067379...| \\approx 8.4932621\n$$\n因此，比值 $\\rho$ 为：\n$$\n\\rho \\approx \\frac{13.7015954}{8.4932621} \\approx 1.613245\n$$\n这一结果揭示了数值分析中的一个关键概念。步长 $h=1$ 导致 $z = h\\lambda = -5$，这个值位于两种方法的绝对稳定区域之外（RK4的绝对稳定区域约为 $[-2.78, 0]$，中点法的约为 $[-2, 0]$）。当 $|R(z)| > 1$ 时，数值解是不稳定的且会增长，而真实解 $y(t) = \\exp(-5t)$ 是衰减的。在这种不稳定机制下，稳定性函数模 $|R(z)|$ 更大的方法会产生更大的误差。此处，$|R_{\\mathrm{RK4}}(-5)| = \\frac{329}{24} \\approx 13.71$ 远大于 $|R_{\\mathrm{mid}}(-5)| = 8.5$。因此，对于这个较大的步长，四阶方法得到的结果不如二阶方法准确，这一点由 $\\rho > 1$ 所证实。\n\n将 $\\rho$ 的值四舍五入到 $4$ 位有效数字，我们得到 $1.613$。", "answer": "$$\n\\boxed{1.613}\n$$", "id": "2376761"}]}