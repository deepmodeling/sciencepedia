{"hands_on_practices": [{"introduction": "在求解常微分方程时，一个核心挑战是处理“刚性”系统，即包含多个差异巨大的时间尺度的系统。本练习 [@problem_id:2446924] 将通过一个典型的化学反应模型，引导你亲身感受这一挑战。你将首先从第一性原理出发，分析显式欧拉法在这种问题上的稳定性限制，并看到其时间步长会受到多么严苛的制约，然后通过实现无条件稳定的隐式欧拉法来高效地求解该问题，从而深刻理解显式与隐式方法在处理刚性问题时的根本区别。", "problem": "编写一个完整程序，用于分析和时间步进一个由双物种不可逆反应产生的刚性初值问题。控制该问题的初值问题是一个线性系统\n$$\n\\frac{d}{dt}\n\\begin{bmatrix}\ny_1(t)\\\\\ny_2(t)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-k_1 & 0\\\\\nk_1 & -k_2\n\\end{bmatrix}\n\\begin{bmatrix}\ny_1(t)\\\\\ny_2(t)\n\\end{bmatrix},\\quad\n\\begin{bmatrix}\ny_1(0)\\\\\ny_2(0)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\ny_{1,0}\\\\\ny_{2,0}\n\\end{bmatrix},\n$$\n其中 $y_1(t)$ 和 $y_2(t)$ 表示物种浓度，$k_1$ 和 $k_2$ 是以 $\\mathrm{s}^{-1}$ 为单位的反应速率。当 $k_1 \\gg k_2$ 时，系统呈现刚性。重点是初值问题时间步进的基础知识：显式时间步进的稳定性限制以及使用隐式方法的稳健积分。\n\n对于每个指定的测试用例，你的程序必须从第一性原理出发，完成以下所有任务：\n\n- 使用标量线性测试方程作为稳定性分析的基础，确定使前向欧拉法对该系统线性稳定所需的最大恒定时间步长 $h_{\\mathrm{FE}}$。通过系统的本征模态论证从该系统到标量测试方程的映射，并要求对衰减最快的模态保持稳定。不要使用任何黑箱稳定性表。\n- 计算到达最终时间 $T$ 所需的前向欧拉法步数的最小整数值 $N_{\\mathrm{FE}} = \\lceil T / h_{\\mathrm{FE}} \\rceil$。\n- 使用测试用例中提供的恒定时间步长 $h_{\\mathrm{BE}}$，通过后向欧拉法（也称为隐式欧拉法）对系统进行数值积分。如果 $T$ 不是 $h_{\\mathrm{BE}}$ 的整数倍，则在最后走一个较短的步长，以确保最终时间恰好等于 $T$。\n- 在 $t=T$ 处计算解析解，并报告后向欧拉法解在最终时间的相对误差，\n$$\n\\varepsilon = \\frac{\\left\\| \\mathbf{y}_{\\mathrm{BE}}(T) - \\mathbf{y}_{\\mathrm{exact}}(T) \\right\\|_2}{\\left\\| \\mathbf{y}_{\\mathrm{exact}}(T) \\right\\|_2},\n$$\n其中 $\\|\\cdot\\|_2$ 是欧几里得范数。\n\n你必须将你的推导建立在以下核心定义和事实上：\n- 初值问题的定义 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(t,\\mathbf{y})$，其中 $\\mathbf{y}(0)$ 已知。\n- 前向欧拉法的更新公式 $\\mathbf{y}^{n+1} = \\mathbf{y}^n + h \\mathbf{f}(t^n,\\mathbf{y}^n)$ 及其标量线性测试方程 $\\dot{z} = \\lambda z$ 与放大因子 $1 + h \\lambda$。\n- 后向欧拉法的更新公式 $\\mathbf{y}^{n+1} = \\mathbf{y}^n + h \\mathbf{f}(t^{n+1},\\mathbf{y}^{n+1})$，对于线性 $\\mathbf{f}$，这需要在每一步求解一个线性系统。\n\n为了验证，请使用通过求解该线性系统得到的闭式解析解：\n- $y_1(t) = y_{1,0} e^{-k_1 t}$。\n- 对于 $k_1 \\neq k_2$，有 $y_2(t) = y_{2,0} e^{-k_2 t} + \\dfrac{k_1 y_{1,0}}{k_2 - k_1}\\left( e^{-k_1 t} - e^{-k_2 t} \\right)$。\n- 对于 $k_1 = k_2$，有 $y_2(t) = \\left( y_{2,0} + k_1 y_{1,0} t \\right) e^{-k_2 t}$。\n\n测试套件和覆盖要求。你的程序必须运行以下独立的测试用例，这些用例共同涵盖了极端刚性、中度刚性、速率相近和速率完全相等边界的情况：\n- 用例 A（极端刚性，长时程）：$(k_1, k_2, T, h_{\\mathrm{BE}}, y_{1,0}, y_{2,0}) = (10^9, 1, 10, 10^{-2}, 1, 0)$。\n- 用例 B（中度刚性）：$(k_1, k_2, T, h_{\\mathrm{BE}}, y_{1,0}, y_{2,0}) = (10^3, 1, 10, 2\\times 10^{-2}, 1, 0)$。\n- 用例 C（速率相近，不相等）：$(k_1, k_2, T, h_{\\mathrm{BE}}, y_{1,0}, y_{2,0}) = (5, 5.000001, 3, 5\\times 10^{-2}, 0.7, 0.3)$。\n- 用例 D（速率完全相等，边界情况）：$(k_1, k_2, T, h_{\\mathrm{BE}}, y_{1,0}, y_{2,0}) = (5, 5, 3, 5\\times 10^{-2}, 1, 0)$。\n\n最终输出格式。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例按顺序贡献一对值 $[N_{\\mathrm{FE}}, \\varepsilon]$。要求的格式为\n$$\n\\big[ [N_{\\mathrm{FE}}^{(A)}, \\varepsilon^{(A)}], [N_{\\mathrm{FE}}^{(B)}, \\varepsilon^{(B)}], [N_{\\mathrm{FE}}^{(C)}, \\varepsilon^{(C)}], [N_{\\mathrm{FE}}^{(D)}, \\varepsilon^{(D)}] \\big].\n$$\n每对值中的第一个是整数，第二个是浮点数。输出中不需要物理单位；报告纯数字。你的程序必须严格按照此格式打印一行，例如\n$$\n\\big[ [5000000000, 5.2\\times 10^{-2}], [\\dots], [\\dots], [\\dots] \\big],\n$$\n其中省略号将被其他用例的计算值替换。", "solution": "所提出的问题是有效的。它构成了一个适定的初值问题，是计算科学与工程中刚性线性系统的一个典型例子。它在科学上基于化学动力学和数值分析的原理，并提供了所有必要的数据和定义。我们将从第一性原理出发，进行严谨的推导和求解。\n\n该问题需要分析常微分方程组（ODEs）\n$$\n\\frac{d\\mathbf{y}}{dt} = \\mathbf{A}\\mathbf{y}, \\quad \\text{with} \\quad \\mathbf{y}(t) = \\begin{bmatrix} y_1(t) \\\\ y_2(t) \\end{bmatrix}, \\quad \\mathbf{A} = \\begin{bmatrix} -k_1 & 0 \\\\ k_1 & -k_2 \\end{bmatrix},\n$$\n以及初始条件 $\\mathbf{y}(0) = [y_{1,0}, y_{2,0}]^T$。参数 $k_1 > 0$ 和 $k_2 > 0$ 是反应速率。\n\n我们的分析将分三部分进行：首先，显式前向欧拉法的稳定性分析；其次，隐式后向欧拉法的实现；第三，计算数值解相对于所提供解析解的误差。\n\n**第一部分：前向欧拉法的稳定性**\n\n对于线性系统 $\\dot{\\mathbf{y}} = \\mathbf{A}\\mathbf{y}$，数值方法的稳定性取决于该方法如何处理矩阵 $\\mathbf{A}$ 的本征模态。通过基变换，该系统可以解耦为一组标量常微分方程，其形式为 $\\dot{z} = \\lambda z$，其中 $\\lambda$ 是矩阵 $\\mathbf{A}$ 的特征值。\n\n矩阵 $\\mathbf{A}$ 是一个下三角矩阵，因此其特征值即为其对角线元素：\n$$\n\\lambda_1 = -k_1 \\quad \\text{and} \\quad \\lambda_2 = -k_2.\n$$\n由于 $k_1, k_2 > 0$，两个特征值都是实数且为负。这些特征值决定了系统响应的时间尺度。$|\\lambda|$ 的大值对应于快速衰减的分量（“刚性”分量），而小值则对应于慢速分量。\n\n前向欧拉法由更新规则 $\\mathbf{y}^{n+1} = \\mathbf{y}^n + h \\mathbf{f}(t^n, \\mathbf{y}^n)$ 定义。对于我们的线性系统，这变为 $\\mathbf{y}^{n+1} = \\mathbf{y}^n + h \\mathbf{A} \\mathbf{y}^n = (\\mathbf{I} + h\\mathbf{A})\\mathbf{y}^n$。此迭代的稳定性取决于放大矩阵 $\\mathbf{G} = \\mathbf{I} + h\\mathbf{A}$ 的谱半径小于或等于 $1$。这等价于要求对于 $\\mathbf{A}$ 的每个特征值 $\\lambda$，$\\mathbf{G}$ 对应的特征值（即 $1+h\\lambda$）的模不大于 $1$。\n\n对于每个特征值 $\\lambda_i$，我们必须满足标量测试方程 $\\dot{z} = \\lambda_i z$ 的稳定性条件：\n$$\n|1 + h\\lambda_i| \\le 1.\n$$\n由于我们的特征值 $\\lambda_1 = -k_1$ 和 $\\lambda_2 = -k_2$ 是实数且为负，这个不等式变为：\n$$\n-1 \\le 1 + h\\lambda_i \\le 1.\n$$\n右侧不等式，$1 + h\\lambda_i \\le 1$，简化为 $h\\lambda_i \\le 0$，对于 $h > 0$ 和 $\\lambda_i < 0$ 总是成立。左侧不等式，$-1 \\le 1 + h\\lambda_i$，得出 $h\\lambda_i \\ge -2$，即 $h \\le -2/\\lambda_i$。代入 $\\lambda_i = -k_i$，即为 $h \\le 2/k_i$。\n\n为了使数值格式对整个系统都稳定，时间步长 $h$ 必须同时对所有本征模态都稳定。这就施加了最严格的约束，该约束来自于模最大的特征值（最快的时间尺度）：\n$$\nh \\le \\frac{2}{\\max(k_1, k_2)}.\n$$\n因此，前向欧拉法所允许的最大恒定时间步长为\n$$\nh_{\\mathrm{FE}} = \\frac{2}{\\max(k_1, k_2)}.\n$$\n任何更大的步长都会导致至少一个模态被放大，从而引发灾难性的数值不稳定性。那么，到达时间 $T$ 所需的步数是满足 $N_{\\mathrm{FE}} \\cdot h_{\\mathrm{FE}} \\ge T$ 的最小整数 $N_{\\mathrm{FE}}$，由 $N_{\\mathrm{FE}} = \\lceil T / h_{\\mathrm{FE}} \\rceil$ 给出。\n\n**第二部分：使用后向欧拉法进行积分**\n\n后向欧拉法是一种隐式方法，其更新规则定义为：\n$$\n\\mathbf{y}^{n+1} = \\mathbf{y}^n + h \\mathbf{f}(t^{n+1}, \\mathbf{y}^{n+1}).\n$$\n对于线性系统 $\\dot{\\mathbf{y}} = \\mathbf{A}\\mathbf{y}$，这变为：\n$$\n\\mathbf{y}^{n+1} = \\mathbf{y}^n + h \\mathbf{A} \\mathbf{y}^{n+1}.\n$$\n为了求解未知状态 $\\mathbf{y}^{n+1}$，我们必须在每个时间步求解一个线性系统：\n$$\n(\\mathbf{I} - h\\mathbf{A})\\mathbf{y}^{n+1} = \\mathbf{y}^n.\n$$\n代入矩阵 $\\mathbf{A}$，我们得到：\n$$\n\\begin{bmatrix}\n1 + h k_1 & 0 \\\\\n-h k_1 & 1 + h k_2\n\\end{bmatrix}\n\\begin{bmatrix}\ny_1^{n+1} \\\\\ny_2^{n+1}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\ny_1^n \\\\\ny_2^n\n\\end{bmatrix}.\n$$\n这个下三角系统可以通过向前代入法高效求解。首先，我们求解 $y_1^{n+1}$：\n$$\n(1 + h k_1)y_1^{n+1} = y_1^n \\implies y_1^{n+1} = \\frac{y_1^n}{1 + h k_1}.\n$$\n然后，我们将此结果代入第二个方程以求解 $y_2^{n+1}$：\n$$\n-h k_1 y_1^{n+1} + (1 + h k_2)y_2^{n+1} = y_2^n \\implies y_2^{n+1} = \\frac{y_2^n + h k_1 y_1^{n+1}}{1 + h k_2}.\n$$\n后向欧拉法是 A-稳定的，这意味着其绝对稳定域包含整个复平面的左半部分。因此，对于任何刚性系统，无论时间步长 $h > 0$ 多大，它都是稳定的。因此，步长 $h_{\\mathrm{BE}}$ 的选择是基于精度考虑，而非稳定性。这就是对刚性问题使用隐式方法的根本原因。\n\n积分过程使用给定的步长 $h_{\\mathrm{BE}}$ 从 $t=0$ 进行到 $T$。如果 $T$ 不是 $h_{\\mathrm{BE}}$ 的整数倍，算法将执行 $N = \\lfloor T/h_{\\mathrm{BE}} \\rfloor$ 个大小为 $h_{\\mathrm{BE}}$ 的完整步长，以及一个大小为 $h_{final} = T - N h_{\\mathrm{BE}}$ 的最终较短步长。\n\n**第三部分：误差计算**\n\n在将系统积分到 $t=T$ 得到数值解 $\\mathbf{y}_{\\mathrm{BE}}(T)$ 后，我们将其与精确解析解 $\\mathbf{y}_{\\mathrm{exact}}(T)$ 进行比较。解析解由下式给出：\n-   $y_1(t) = y_{1,0} e^{-k_1 t}$。\n-   对于 $k_1 \\neq k_2$，有 $y_2(t) = y_{2,0} e^{-k_2 t} + \\frac{k_1 y_{1,0}}{k_2 - k_1} (e^{-k_1 t} - e^{-k_2 t})$。\n-   对于 $k_1 = k_2$，有 $y_2(t) = (y_{2,0} + k_1 y_{1,0} t) e^{-k_2 t}$。\n\n数值解在最终时间 $T$ 的相对误差使用欧几里得范数（$\\|\\cdot\\|_2$）计算：\n$$\n\\varepsilon = \\frac{\\left\\| \\mathbf{y}_{\\mathrm{BE}}(T) - \\mathbf{y}_{\\mathrm{exact}}(T) \\right\\|_2}{\\left\\| \\mathbf{y}_{\\mathrm{exact}}(T) \\right\\|_2}.\n$$\n这个量度量了在所选步长 $h_{\\mathrm{BE}}$ 下，后向欧拉法积分的准确性。分母对误差进行归一化，使其成为一个相对度量。所提供的测试用例将展示后向欧拉法在不同刚性程度下的稳健性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Format: (k1, k2, T, h_BE, y1_0, y2_0)\n    test_cases = [\n        (1e9, 1.0, 10.0, 1e-2, 1.0, 0.0),\n        (1e3, 1.0, 10.0, 2e-2, 1.0, 0.0),\n        (5.0, 5.000001, 3.0, 5e-2, 0.7, 0.3),\n        (5.0, 5.0, 3.0, 5e-2, 1.0, 0.0),\n    ]\n\n    results = []\n    for k1, k2, T, h_BE, y1_0, y2_0 in test_cases:\n        # Part 1: Forward Euler stability analysis\n        # The largest stable time step is h_FE = 2 / max(|lambda_i|).\n        # Eigenvalues are -k1 and -k2.\n        h_FE = 2.0 / max(k1, k2)\n        \n        # Number of steps to reach T. Use np.ceil for ceiling operation.\n        N_FE = int(np.ceil(T / h_FE))\n\n        # Part 2: Backward Euler integration\n        y = np.array([y1_0, y2_0], dtype=np.float64)\n        \n        # Determine number of steps and handle the final step if T is not a multiple of h_BE\n        num_steps = int(np.floor(T / h_BE))\n        last_h = T - num_steps * h_BE\n\n        # Integration loop for full steps\n        for _ in range(num_steps):\n            # Solve (I - hA)y_new = y_old\n            # y1_new = y1_old / (1 + h*k1)\n            y[0] = y[0] / (1.0 + h_BE * k1)\n            # y2_new = (y2_old + h*k1*y1_new) / (1 + h*k2)\n            y[1] = (y[1] + h_BE * k1 * y[0]) / (1.0 + h_BE * k2)\n        \n        # Final shorter step, if necessary\n        if last_h > 1e-15: # Use a tolerance for floating point comparison\n            y[0] = y[0] / (1.0 + last_h * k1)\n            y[1] = (y[1] + last_h * k1 * y[0]) / (1.0 + last_h * k2)\n\n        y_BE_T = y\n\n        # Part 3: Analytical solution and error calculation\n        y_exact_T = np.zeros(2, dtype=np.float64)\n        \n        # Analytical solution for y1(T)\n        y_exact_T[0] = y1_0 * np.exp(-k1 * T)\n\n        # Analytical solution for y2(T) depends on whether k1 and k2 are equal\n        if abs(k1 - k2)  1e-15:\n            y_exact_T[1] = (y2_0 + k1 * y1_0 * T) * np.exp(-k2 * T)\n        else:\n            term1 = y2_0 * np.exp(-k2 * T)\n            factor = (k1 * y1_0) / (k2 - k1)\n            term2 = factor * (np.exp(-k1 * T) - np.exp(-k2 * T))\n            y_exact_T[1] = term1 + term2\n\n        # Calculate the relative error using Euclidean norm\n        norm_diff = np.linalg.norm(y_BE_T - y_exact_T)\n        norm_exact = np.linalg.norm(y_exact_T)\n        \n        epsilon = norm_diff / norm_exact if norm_exact > 1e-15 else 0.0\n\n        results.append(f\"[{N_FE}, {epsilon:.12e}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver function\nsolve()\n```", "id": "2446924"}, {"introduction": "在数值计算中，我们通常认为高阶方法比低阶方法更精确，但这并非总是如此，尤其是在时间步长未能充分解析系统动态时。这个练习 [@problem_id:2446910] 精心设计了一个场景，让你能观察到一个令人惊讶的现象：对于一个特定的、较大的时间步长 $\\Delta t$，一阶的前向欧拉法竟然比四阶的龙格-库塔法（RK4）更为准确。通过这个实践，你将揭示采样效应（或称混叠）是如何误导高阶方法的，并认识到选择数值方法时，理解并解析问题本身的特性是多么重要。", "problem": "考虑常微分方程（ODE）初值问题\n$$\n\\frac{dy}{dt} = f(t), \\quad y(0)=0,\n$$\n其右侧项具有时间周期性，定义如下。设 $p0$ 为周期，$A0$ 为振幅，$\\sigma \\in (0,0.5)$ 为无量纲宽度参数。定义约化相位\n$$\nr(t) = t - p \\left\\lfloor \\frac{t}{p} \\right\\rfloor \\in [0,p),\n$$\n中心化相位\n$$\ns(t) = r(t) - \\frac{p}{2},\n$$\n并设\n$$\nf(t) = A \\exp\\!\\left(-\\frac{s(t)^2}{2\\,(\\sigma p)^2}\\right).\n$$\n固定参数 $p=1.0$，$A=10.0$，$\\sigma=0.05$，以及最终时间 $T=64.0$。你将分析在 $[0,T]$ 区间上对以下给定的时间步长（单位均为秒）的近似值：$\\Delta t_1 = 1.0$，$\\Delta t_2 = 2.0$，$\\Delta t_3 = 0.5$，以及 $\\Delta t_4 = 0.125$。注意，每个 $\\Delta t_i$ 都能整除 $T$。\n\n对于这些数据，根据应用于该 ODE 的微积分基本定理，时间 $T$ 处的精确解在此可简化为\n$$\ny(T) \\;=\\; \\int_{0}^{T} f(t)\\,dt.\n$$\n因为 $f(t)$ 是周期为 $p$ 的周期函数，并且 $T$ 是 $p$ 的整数倍，所以该积分可以以闭合形式计算为\n$$\ny(T) \\;=\\; \\frac{T}{p}\\, \\int_{0}^{p} A \\exp\\!\\left(-\\frac{(t-\\frac{p}{2})^2}{2\\,(\\sigma p)^2}\\right) dt \n\\;=\\; T \\, A \\, \\sigma \\, \\sqrt{2\\pi}\\, \\operatorname{erf}\\!\\left(\\frac{1}{2\\sqrt{2}\\,\\sigma}\\right),\n$$\n其中 $\\operatorname{erf}(\\cdot)$ 表示高斯误差函数。\n\n你的任务是，对于每个 $\\Delta t_i$，使用以下每种单步时间步进近似法，在均匀网格 $t_n = n\\,\\Delta t_i$ 上应用，并计算在时间 $T$ 处的绝对误差：\n\n1) Forward Euler:\n$$\ny^{n+1}_{\\mathrm{FE}} \\;=\\; y^n_{\\mathrm{FE}} \\;+\\; \\Delta t_i \\, f(t_n), \n\\quad y^0_{\\mathrm{FE}} = 0.\n$$\n\n2) Classical fourth-order Runge–Kutta method (RK4):\n\\begin{align*}\nk_1 = f(t_n),\\\\\nk_2 = f\\!\\left(t_n+\\tfrac{1}{2}\\Delta t_i\\right),\\\\\nk_3 = f\\!\\left(t_n+\\tfrac{1}{2}\\Delta t_i\\right),\\\\\nk_4 = f\\!\\left(t_n+\\Delta t_i\\right),\\\\\ny^{n+1}_{\\mathrm{RK4}} = y^n_{\\mathrm{RK4}} \\;+\\; \\Delta t_i \\,\\frac{k_1 + 2k_2 + 2k_3 + k_4}{6}, \n\\quad y^0_{\\mathrm{RK4}} = 0.\n\\end{align*}\n\n对于每个 $\\Delta t_i$，计算绝对误差\n$$\nE_{\\mathrm{FE}}(\\Delta t_i) \\;=\\; \\left|y_{\\mathrm{FE}}(T;\\Delta t_i) - y(T)\\right|, \n\\qquad\nE_{\\mathrm{RK4}}(\\Delta t_i) \\;=\\; \\left|y_{\\mathrm{RK4}}(T;\\Delta t_i) - y(T)\\right|.\n$$\n\n测试套件：\n- 情况 1：$\\Delta t_1 = 1.0$ (一个等于激励周期 $p$ 的大步长)。\n- 情况 2：$\\Delta t_2 = 2.0$ (一个等于 $2p$ 的非常大的步长)。\n- 情况 3：$\\Delta t_3 = 0.5$ (一个等于 $p/2$ 的中等步长)。\n- 情况 4：$\\Delta t_4 = 0.125$ (一个等于 $p/8$ 的小步长)。\n\n对于每种情况，报告布尔值\n$$\nB_i = \\big( E_{\\mathrm{FE}}(\\Delta t_i)  E_{\\mathrm{RK4}}(\\Delta t_i) \\big),\n$$\n即，对于该特定的 $\\Delta t_i$，Forward Euler 方法是否比 fourth-order Runge–Kutta 方法更精确。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含四个情况的布尔值，以逗号分隔并用方括号括起，例如 `[True, False, True, False]`。", "solution": "该问题是数值分析中一个定义明确的练习，特别是关于常微分方程的单步法研究。该问题在科学上是合理的，基于微积分和求解 ODE 的数值方法的基本概念，并且问题陈述是完整和一致的。它所研究的现象——高阶方法在特定、选择不当的步长下可能不如低阶方法精确——是数值分析中一个与采样和混叠有关的已知且重要的概念。\n\n目标是在时间区间 $[0, T]$ 上，使用两种不同的数值方法，Forward Euler (FE) 和 fourth-order Runge-Kutta (RK4)，针对一组四个不同的时间步长 $\\Delta t_i$，求解初值问题 $dy/dt = f(t)$ 且 $y(0)=0$。对于每种情况，我们必须确定一阶 FE 方法在最终时间 $T$ 产生的绝对误差是否小于四阶 RK4 方法。\n\n控制参数设置为 $p=1.0$，$A=10.0$，$\\sigma=0.05$ 和 $T=64.0$。激励函数 $f(t)$ 是一个周期为 $p$ 的高斯状脉冲序列。因为 ODE 的形式是 $dy/dt=f(t)$，其解是直接积分 $y(t) = \\int_0^t f(\\tau)d\\tau$。因此，数值方案是对该积分的近似。具体来说，FE 方法得到的总累积值 $y(T)$ 对应于使用复合左矩形法则的积分近似，而对于这种特定的 ODE 形式，RK4 方法等价于复合辛普森法则。\n\n首先，我们使用提供的公式计算精确解 $y(T)$：\n$$\ny(T) = T \\, A \\, \\sigma \\, \\sqrt{2\\pi}\\, \\operatorname{erf}\\!\\left(\\frac{1}{2\\sqrt{2}\\,\\sigma}\\right)\n$$\n代入给定参数：\n$$\ny(T) = 64.0 \\cdot 10.0 \\cdot 0.05 \\cdot \\sqrt{2\\pi} \\cdot \\operatorname{erf}\\!\\left(\\frac{1}{2\\sqrt{2} \\cdot 0.05}\\right) = 32.0 \\cdot \\sqrt{2\\pi} \\cdot \\operatorname{erf}\\!\\left(\\frac{1}{0.1\\sqrt{2}}\\right)\n$$\n误差函数的参数约为 7.071，此时 $\\operatorname{erf}$ 的值非常接近 1.0。因此 $y(T) \\approx 32.0\\sqrt{2\\pi} \\approx 80.2121$。\n\n接下来，我们为每个 $\\Delta t_i \\in \\{1.0, 2.0, 0.5, 0.125\\}$ 实现数值方案。对于每个 $\\Delta t$，步数为 $N = T / \\Delta t$。时间网格为 $t_n = n \\Delta t$，其中 $n=0, 1, \\dots, N-1$。\n\n过程如下：\n对于每个 $\\Delta t_i$：\n 1. 初始化 $y_{\\mathrm{FE}}=0$ 和 $y_{\\mathrm{RK4}}=0$。\n 2. 从 $n=0$ 迭代到 $N-1$：\n    - 计算 $f(t_n)$ 并更新 FE 解：$y_{\\mathrm{FE}} \\mathrel{+}= \\Delta t_i f(t_n)$。\n    - 计算 RK4 的各阶段 $k_1 = f(t_n)$、$k_2=k_3 = f(t_n+\\tfrac{1}{2}\\Delta t_i)$、$k_4 = f(t_n+\\Delta t_i)$，并更新 RK4 解：$y_{\\mathrm{RK4}} \\mathrel{+}= \\Delta t_i (k_1 + 4k_2 + k_4)/6$ (使用 $k_2=k_3$ 的简化形式)。\n 3. 计算最终的绝对误差：$E_{\\mathrm{FE}}(\\Delta t_i) = |y_{\\mathrm{FE}} - y(T)|$ 和 $E_{\\mathrm{RK4}}(\\Delta t_i) = |y_{\\mathrm{RK4}} - y(T)|$。\n 4. 评估布尔值 $B_i = (E_{\\mathrm{FE}}(\\Delta t_i)  E_{\\mathrm{RK4}}(\\Delta t_i))$。\n\n各情况分析：\n- **情况 1：$\\Delta t_1 = 1.0 = p$**：\n  - FE 在 $t_n = n \\cdot p$ 处对 $f(t)$ 进行采样。在这些点上，$r(t_n)=0$ 且 $s(t_n)=-p/2$。因此，$f(t_n) = A \\exp(-1/(8\\sigma^2)) \\approx 10 e^{-50}$，这几乎为零。FE 近似值 $y_{\\mathrm{FE}}(T)$ 将非常接近于 0。误差 $E_{\\mathrm{FE}}$ 约为 $|0 - 80.21| \\approx 80.21$。\n  - RK4 在 $t_n$、$t_n+p/2$ 和 $t_n+p$ 处进行采样。在 $t_n+p/2$ 处的采样点正好是高斯脉冲的峰值，此时 $s(t)=0$ 且 $f(t)=A=10.0$。由于辛普森法则给予该中点样本很大的权重，该方法严重高估了每个周期内的积分。$y_{\\mathrm{RK4}}(T) \\approx (T/p) \\cdot (p/6)(f(0)+4f(p/2)+f(p)) \\approx 64 \\cdot (1/6)(0 + 4 \\cdot 10 + 0) \\approx 426.67$。误差 $E_{\\mathrm{RK4}}$ 约为 $|426.67 - 80.21| \\approx 346.46$。\n  - 此处，$E_{\\mathrm{FE}}  E_{\\mathrm{RK4}}$。因此，$B_1$ 为 True。这个与直觉相反的结果展示了混叠现象：时间步长太大，无法解析 $f(t)$ 的特征，导致高阶方法灾难性地失败。\n\n- **情况 2：$\\Delta t_2 = 2.0 = 2p$**：\n  - FE 在 $t_n = n \\cdot 2p$ 处进行采样，得到 $f(t_n)=f(0) \\approx 0$。结果 $y_{\\mathrm{FE}}(T) \\approx 0$，误差 $E_{\\mathrm{FE}} \\approx 80.21$。\n  - RK4 在 $t_n=n \\cdot 2p$、$t_n+p$ 和 $t_n+2p$ 处进行采样。$f(n \\cdot 2p)=f(0)$，$f(n \\cdot 2p+p)=f(p)=f(0)$，以及 $f(n \\cdot 2p+2p)=f(2p)=f(0)$。所有采样点都得到相同的近零值。\n  - 两种方法产生几乎相同的结果：$y_{\\mathrm{FE}}(T) \\approx y_{\\mathrm{RK4}}(T) \\approx 0$，导致 $E_{\\mathrm{FE}} \\approx E_{\\mathrm{RK4}}$。\n  - 条件 $E_{\\mathrm{FE}}  E_{\\mathrm{RK4}}$ 为 False。因此，$B_2$ 为 False。\n\n- **情况 3：$\\Delta t_3 = 0.5 = p/2$**：\n  - FE 在 $t=0, 0.5, 1.0, 1.5, \\dots$ 处进行采样。它交替采样近零的尾部 $f(0)$ 和峰值 $f(0.5)=A=10$。这导致了很大的高估 $y_{\\mathrm{FE}}(T) \\approx T \\cdot (f(0)+f(0.5))/2 \\approx 64 \\cdot (0+10)/2 = 320$。误差 $E_{\\mathrm{FE}} \\approx |320 - 80.21| \\approx 239.79$。\n  - RK4 使用更精细的采样网格，包括像 $t=0.25$ 和 $t=0.75$ 这样的点，从而更好地解析高斯脉冲的形状。其结果明显更精确。\n  - $E_{\\mathrm{FE}}  E_{\\mathrm{RK4}}$。因此，$B_3$ 为 False。\n\n- **情况 4：$\\Delta t_4 = 0.125 = p/8$**：\n  - 随着时间步长变小，这些方法开始在它们预期的渐近收敛区域内运行。RK4 的误差以 $\\mathcal{O}((\\Delta t)^4)$ 的速度收敛，将远小于 FE 的误差（以 $\\mathcal{O}(\\Delta t)$ 的速度收敛）。\n  - 我们预计 RK4 会明显更精确。\n  - $E_{\\mathrm{FE}}  E_{\\mathrm{RK4}}$。因此，$B_4$ 为 False。\n\n最终的布尔结果是通过数值实现此逻辑来计算的，预计为 `[True, False, False, False]`。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Solves the given ODE problem for four different time steps and compares\n    the accuracy of Forward Euler and RK4 methods.\n    \"\"\"\n    # Define problem parameters\n    p = 1.0\n    A = 10.0\n    sigma = 0.05\n    T = 64.0\n\n    # Define test cases for time steps\n    test_cases = [1.0, 2.0, 0.5, 0.125]\n\n    # Define the forcing function f(t)\n    def f(t, p_val, a_val, sigma_val):\n        \"\"\"\n        Computes the value of the periodic forcing function f(t).\n        \"\"\"\n        r_t = t - p_val * np.floor(t / p_val)\n        s_t = r_t - p_val / 2.0\n        exponent = -s_t**2 / (2.0 * (sigma_val * p_val)**2)\n        return a_val * np.exp(exponent)\n\n    # Calculate the exact solution y(T)\n    arg_erf = 1.0 / (2.0 * np.sqrt(2.0) * sigma)\n    y_exact_T = T * A * sigma * np.sqrt(2.0 * np.pi) * erf(arg_erf)\n\n    results = []\n\n    for dt in test_cases:\n        # Ensure the number of steps is an integer\n        if T % dt != 0:\n            raise ValueError(f\"Time step dt={dt} does not evenly divide T={T}\")\n        N = int(T / dt)\n\n        # --- Forward Euler (FE) simulation ---\n        y_fe = 0.0\n        # The sum can be vectorized for efficiency\n        time_points_fe = np.arange(N) * dt\n        f_values_fe = f(time_points_fe, p, A, sigma)\n        y_fe = np.sum(f_values_fe) * dt\n        \n        error_fe = np.abs(y_fe - y_exact_T)\n\n        # --- RK4 simulation ---\n        y_rk4 = 0.0\n        # The ODE y'=f(t) simplifies the RK4 scheme, which is equivalent to\n        # composite Simpson's rule for integration.\n        time_points_rk4 = np.arange(N) * dt\n        \n        k1 = f(time_points_rk4, p, A, sigma)\n        k2 = f(time_points_rk4 + 0.5 * dt, p, A, sigma)\n        # For y'=f(t), k3 is identical to k2\n        k4 = f(time_points_rk4 + dt, p, A, sigma)\n        \n        y_rk4 = np.sum((dt / 6.0) * (k1 + 4.0 * k2 + k4))\n\n        error_rk4 = np.abs(y_rk4 - y_exact_T)\n\n        # Compare errors and store boolean result\n        # Python's bool converted to string will be \"True\" or \"False\"\n        results.append(str(error_fe  error_rk4))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2446910"}, {"introduction": "许多工程和物理系统模型包含开关、碰撞等瞬时变化事件，这在数学上表现为常微分方程（ODE）右端函数 $f(y, t)$ 的不连续性。本练习 [@problem_id:2446886] 旨在探究先进的自适应步长求解器在遇到此类不连续点时的行为。你将分析为什么在这种情况下，高阶方法的局部误差估计会失效并导致收敛阶骤降，以及求解器为何会通过反复减小步长来“定位”不连续点，从而理解处理非光滑问题的标准最佳实践。", "problem": "考虑一个常微分方程（ODE）的初值问题\n$$\n\\frac{dy}{dt} = f(y,t) = -y + H(t - t_d), \\quad t \\in [0,1], \\quad y(0)=0,\n$$\n其中 $H(\\cdot)$ 是单位阶跃函数，定义为当 $\\tau0$ 时 $H(\\tau)=0$ 和当 $\\tau \\ge 0$ 时 $H(\\tau)=1$，$t_d \\in (0,1)$ 是方程右端（RHS）的一个固定的不连续时间点。假设使用一个阶数为 $(p,p-1)$（其中 $p \\ge 2$）的自适应嵌入式显式龙格-库塔方法对来求解此问题，并采用标准的局部误差控制，即如果标量误差估计 $e$ 满足以下条件，则接受从 $t_n$ 到 $t_{n+1}=t_n+h$ 的试验步长\n$$\n|e| \\le \\mathrm{atol} + \\mathrm{rtol}\\,|y_{n+1}|,\n$$\n其中 $\\mathrm{atol}0$ 和 $\\mathrm{rtol}0$ 是用户指定的容差。\n\n重点关注当一个提议的步长区间 $[t_n,t_{n+1}]$ 包含不连续点 $t_d$（即 $t_n  t_d  t_{n+1}$）时，自适应时间步长选择器的行为。下列哪个陈述是正确的？\n\nA. 如果一个试验步长跨越了 $t_d$，嵌入式局部误差估计通常表现为 $\\mathcal{O}(h)$ 的量级，而不是 $\\mathcal{O}(h^{p+1})$，因此控制器将减小 $h$（可能重复多次），直到不连续点被隔离。\n\nB. 为了在远离 $t_d$ 的区域保持精度和标称阶数，应当检测不连续点，并强制步长恰好在 $t_d$ 处结束，然后在下一个光滑子区间上重新启动积分器。\n\nC. 如果步长端点不与 $t_d$ 对齐，那么对于固定的 $p$，当最大步长 $h \\to 0$ 时，在 $[0,1]$ 上的全局误差通常仅以 $\\mathcal{O}(h)$ 的速度收敛，无论 $p$ 是多少。\n\nD. 仅增加方法阶数 $p$（而不修改步长位置）可以消除在给定 $\\mathrm{atol}$ 和 $\\mathrm{rtol}$ 下于 $t_d$ 处的步长拒绝。\n\nE. 在跨越不连续点的步长上，嵌入式误差估计器会系统性地低估真实局部误差，因此步长选择器通常会接受一个过大的步长 $h$ 跨越 $t_d$。", "solution": "### 问题分析与解析解\n\n给定的初值问题是：\n$$\n\\frac{dy}{dt} = f(y,t) = -y + H(t - t_d), \\quad t \\in [0,1], \\quad y(0)=0\n$$\n其中 $H(\\cdot)$ 是单位阶跃函数。该ODE的解 $y(t)$ 是连续的，但其一阶导数 $y'(t)$ 在 $t=t_d$ 处不连续。我们可以分段求解：\n1.  对于 $t \\in [0, t_d)$，方程为 $\\frac{dy}{dt} = -y$，初始条件为 $y(0)=0$，解为 $y(t)=0$。\n2.  对于 $t \\ge t_d$，方程为 $\\frac{dy}{dt} = -y + 1$。其通解为 $y(t) = 1 + C e^{-t}$。为了保证解在 $t_d$ 处的连续性，我们要求 $\\lim_{t \\to t_d^+} y(t) = y(t_d^-) = 0$。代入可得 $0 = 1 + C e^{-t_d}$，因此 $C = -e^{t_d}$。所以，对于 $t \\ge t_d$，解为 $y(t) = 1 - e^{t_d} e^{-t} = 1 - e^{-(t-t_d)}$。\n\n完整的解析解为：\n$$ y(t) = \\begin{cases} 0  \\text{若 } 0 \\le t  t_d \\\\ 1 - e^{-(t-t_d)}  \\text{若 } t_d \\le t \\le 1 \\end{cases} $$\n通过求导可以发现：\n- $\\lim_{t \\to t_d^-} y'(t) = 0$\n- $\\lim_{t \\to t_d^+} y'(t) = \\left. \\frac{d}{dt}(1 - e^{-(t-t_d)}) \\right|_{t=t_d^+} = \\left. e^{-(t-t_d)} \\right|_{t=t_d^+} = 1$\n由于 $y'(t)$ 在 $t_d$ 处的左右极限不相等，解 $y(t)$ 是连续的（$C^0$），但不是连续可微的（不是 $C^1$）。\n\n### 嵌入式龙格-库塔方法的行为\n\n一个阶数为 $(p, p-1)$ 的嵌入式龙格-库塔方法对在每一步都会计算两个近似值：一个 $p$ 阶精度的解 $y_{n+1}$ 和一个 $p-1$ 阶精度的解 $\\hat{y}_{n+1}$。它们的差值 $e = y_{n+1} - \\hat{y}_{n+1}$ 被用作局部截断误差的估计。\n\n这些方法的误差理论是建立在解 $y(t)$ 足够光滑（通常要求至少是 $C^p$ 或 $C^{p+1}$）的假设之上的。在这种情况下，误差估计 $e$ 的阶数为 $\\mathcal{O}(h^p)$。然而，当一个时间步 $[t_n, t_{n+1}]$ 跨越了不连续点 $t_d$ 时，光滑性假设被严重违反。龙格-库塔法本质上是对积分 $\\int_{t_n}^{t_{n+1}} f(y(s),s) ds$ 的一种数值逼近。当被积函数 $f$ 在积分区间内存在跳跃间断时，任何基于多项式插值的求积方法都会失效。其结果是，两种阶数的近似解的局部误差都会从高阶退化为仅仅 $\\mathcal{O}(h)$。因此，它们的差值，即局部误差估计 $e$，也会退化为 $\\mathcal{O}(h)$。\n\n### 逐项分析\n\n**A. 如果一个试验步长跨越了 $t_d$，嵌入式局部误差估计通常表现为 $\\mathcal{O}(h)$ 的量级，而不是 $\\mathcal{O}(h^{p+1})$，因此控制器将减小 $h$（可能重复多次），直到不连续点被隔离。**\n这个陈述是正确的。如上所述，跨越不连续点会导致局部误差估计 $e$ 从光滑区域的 $\\mathcal{O}(h^p)$ 突然变为 $\\mathcal{O}(h)$。由于 $p \\ge 2$，对于一个足够小的 $h$，这个 $\\mathcal{O}(h)$ 的误差会远大于自适应步长控制器所期望的 $\\mathcal{O}(h^p)$ 误差，因此几乎必然会超出给定的容差（$|e| > \\text{tol}$）。步长控制器的标准反应是拒绝当前步长，并用一个更小的步长重试。这个过程会反复进行，导致步长在不连续点附近急剧减小，从而有效地“定位”并“隔离”不连续点。该选项对现象的描述基本准确（尽管它将光滑情况下的误差估计阶数写为 $\\mathcal{O}(h^{p+1})$，而通常是 $\\mathcal{O}(h^p)$，但这不影响核心逻辑的正确性）。\n\n**B. 为了在远离 $t_d$ 的区域保持精度和标称阶数，应当检测不连续点，并强制步长恰好在 $t_d$ 处结束，然后在下一个光滑子区间上重新启动积分器。**\n这个陈述是正确的。它描述了处理非光滑ODE的标准“最佳实践”。让求解器自动通过减小步长来“找到”不连续点是低效的。如果不连续点的位置 $t_d$ 是已知的，最高效和最准确的方法是：将积分区间在 $t_d$ 处断开，先从 $t_0$ 积分到 $t_d$，然后以 $y(t_d)$ 为新的初始值，从 $t_d$ 重新开始积分到最终时间。这样可以确保求解器始终在解是光滑的区间内运行，从而保持其设计的高阶收敛性和效率。\n\n**C. 如果步长端点不与 $t_d$ 对齐，那么对于固定的 $p$，当最大步长 $h \\to 0$ 时，在 $[0,1]$ 上的全局误差通常仅以 $\\mathcal{O}(h)$ 的速度收敛，无论 $p$ 是多少。**\n这个陈述是正确的。全局误差是所有局部误差累积的结果。即使只有一个步长跨越了不连续点，它也会引入一个量级为 $\\mathcal{O}(h)$ 的局部误差。这个低阶误差会污染整个后续的计算过程，并且当所有步长都按比例缩小时，这个 $\\mathcal{O}(h)$ 的误差项将主导全局误差。因此，无论方法本身的阶数 $p$ 有多高，最终的全局收敛阶数都会被这个“最薄弱环节”拉低到一阶。\n\n**D. 仅增加方法阶数 $p$（而不修改步长位置）可以消除在给定 $\\mathrm{atol}$ 和 $\\mathrm{rtol}$ 下于 $t_d$ 处的步长拒绝。**\n这个陈述是错误的。恰恰相反，增加阶数 $p$ 通常会使问题变得更糟。更高阶的方法对解的光滑性要求更高，也更敏感。在光滑区域，为了达到同样的容差，高阶方法倾向于采用更大的步长 $h$。当这个更大的步长试图跨越不连续点时，产生的 $\\mathcal{O}(h)$ 误差会更大，从而导致更剧烈的步长拒绝。高阶方法无法“强行”通过不连续点；它们更容易被不连续点“绊倒”。\n\n**E. 在跨越不continuous点的步长上，嵌入式误差估计器会系统性地低估真实局部误差，因此步长选择器通常会接受一个过大的步长 $h$ 跨越 $t_d$。**\n这个陈述是错误的。它描述了与实际情况相反的行为。如选项A的分析所述，误差估计器通常会报告一个非常大的误差（从 $\\mathcalO(h^p)$ 跃升至 $\\mathcal{O}(h)$），这会触发步长*拒绝*和缩减，而不是接受。虽然在某些病态情况下误差估计器可能失效，但对于简单的跳跃不连续点，标准行为是检测到一个大误差并采取纠正措施。\n\n因此，选项A、B和C是正确的。", "answer": "$$\\boxed{ABC}$$", "id": "2446886"}]}