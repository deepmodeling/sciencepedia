{"hands_on_practices": [{"introduction": "任何复杂算法的学习都始于对其基本步骤的掌握。本练习将 QR 算法分解为其核心组成部分：一次 QR 分解和一次矩阵乘法。通过对一个简单的 $2 \\times 2$ 矩阵手动执行这些步骤，你将为这个强大的特征值求解方法的迭代过程建立起具体而直观的理解 [@problem_id:1057107]。", "problem": "QR 算法是一种用于求解矩阵特征值和特征向量的迭代方法。基本的（无位移）算法从一个矩阵 $A_0$ 开始，并通过以下步骤生成一个矩阵序列 $\\{A_k\\}_{k=0}^\\infty$：\n1. 对于给定的矩阵 $A_k$，计算其 QR 分解 $A_k = Q_k R_k$，其中 $Q_k$ 是一个正交矩阵，$R_k$ 是一个对角元非负的上三角矩阵。\n2. 序列中的下一个矩阵由 $A_{k+1} = R_k Q_k$ 给出。\n\n可以证明，所有的矩阵 $A_k$ 都与 $A_0$ 相似，因为 $A_{k+1} = R_k Q_k = (Q_k^{-1} A_k) Q_k = Q_k^T A_k Q_k$。在特定条件下，序列 $A_k$ 收敛到一个上三角或准三角矩阵（Schur 型），从而揭示出 $A_0$ 的特征值。\n\n考虑在 $\\mathbb{R}^2$ 上的一个线性算子，其在标准基下的矩阵表示由下式给出：\n$$\nA_0 = \\begin{pmatrix} 1 & 4 \\\\ 1 & 1 \\end{pmatrix}\n$$\n对矩阵 $A_0$ 执行两步连续的无位移 QR 算法，生成序列 $A_0 \\to A_1 \\to A_2$，该过程涉及到正交矩阵 $Q_0$ 和 $Q_1$。\n\n你的任务是计算这两个初始正交矩阵之积的迹，即 $\\text{Tr}(Q_0 Q_1)$。", "solution": "我们对下式给出的矩阵执行两步无位移 QR 步骤：\n$$A_0=\\begin{pmatrix}1&4\\\\1&1\\end{pmatrix}.$$\n1. 对 $A_0$ 进行 QR 分解。令\n\n$$\na_1=(1,1)^T,\\quad\\|a_1\\|=\\sqrt{2},\\quad e_1=\\frac{a_1}{\\sqrt2}=(1/\\sqrt2,1/\\sqrt2)^T.\n$$\n\n\n$$\na_2=(4,1)^T,\\quad e_1^Ta_2=\\frac{5}{\\sqrt2},\\quad\n\\mathrm{proj}_{e_1}a_2=\\frac{5}{2}(1,1)^T,\n$$\n\n\n$$\nu_2=a_2-\\mathrm{proj}_{e_1}a_2=(3/2,-3/2)^T,\\quad\\|u_2\\|=\\frac{3}{\\sqrt2},\\quad\ne_2=\\frac{u_2}{\\|u_2\\|}=(1/\\sqrt2,-1/\\sqrt2)^T.\n$$\n\n因此\n\n$$\nQ_0=\\frac1{\\sqrt2}\\begin{pmatrix}1&1\\\\1&-1\\end{pmatrix},\\quad\nR_0=Q_0^TA_0=\\begin{pmatrix}2/\\sqrt2&5/\\sqrt2\\\\0&3/\\sqrt2\\end{pmatrix},\n$$\n\n\n$$\nA_1=R_0Q_0\n=\\begin{pmatrix}7/2&-3/2\\\\3/2&-3/2\\end{pmatrix}.\n$$\n\n\n2. 对 $A_1$ 进行 QR 分解。令\n\n$$\na_1'=(7/2,\\,3/2)^T,\\quad\\|a_1'\\|=\\frac{\\sqrt{58}}2,\\quad\ne_1'=\\frac{1}{\\sqrt{58}}(7,3)^T,\n$$\n\n\n$$\na_2'=(-3/2,-3/2)^T,\\quad\ne_1'^Ta_2'=-\\frac{15}{\\sqrt{58}},\\quad\n\\mathrm{proj}_{e_1'}a_2'=-\\frac{15}{58}(7,3)^T,\n$$\n\n\n$$\nu_2'=a_2'-\\mathrm{proj}_{e_1'}a_2'=\\bigl(9/29,-21/29\\bigr)^T,\\quad\n\\|u_2'\\|=\\frac{3\\sqrt{58}}{29},\\quad\ne_2'=\\frac{1}{\\sqrt{58}}(3,-7)^T.\n$$\n\n于是\n\n$$\nQ_1=\\frac1{\\sqrt{58}}\\begin{pmatrix}7&3\\\\3&-7\\end{pmatrix}.\n$$\n\n\n3. 计算 $Q_0Q_1$ 的迹。\n\n$$\nQ_0Q_1\n=\\begin{pmatrix}1/\\sqrt2&1/\\sqrt2\\\\1/\\sqrt2&-1/\\sqrt2\\end{pmatrix}\n\\frac1{\\sqrt{58}}\\begin{pmatrix}7&3\\\\3&-7\\end{pmatrix}\n=\\begin{pmatrix}5/\\sqrt{29}&\\ast\\\\\\ast&5/\\sqrt{29}\\end{pmatrix},\n$$\n\n所以\n\n$$\n\\mathrm{Tr}(Q_0Q_1)\n=\\frac{5}{\\sqrt{29}}+\\frac{5}{\\sqrt{29}}\n=\\frac{10}{\\sqrt{29}}.\n$$", "answer": "$$\\boxed{\\frac{10}{\\sqrt{29}}}$$", "id": "1057107"}, {"introduction": "QR 算法的实际效率不仅源于其基本迭代，更得益于诸如移位 (shifting) 等巧妙策略。本练习将通过一个理想化的思想实验，探讨当我们使用的移位量 $\\sigma$ 恰好是矩阵 $A$ 的一个特征值时会发生什么。这个过程将揭示该算法效率的关键——“降维” (deflation) 机制，即一个特征值被完美分离，从而简化问题并加速收敛 [@problem_id:2445523]。", "problem": "设 $A \\in \\mathbb{R}^{n\\times n}$ 是一个未约化上Hessenberg矩阵，并考虑在精确算术下使用一个实位移 $\\sigma \\in \\mathbb{R}$ 执行一步隐式单步位移Francis正交三角（QR）步。根据Francis步的定义，我们计算正交三角（QR）分解\n$$A - \\sigma I = Q R,$$\n其中 $Q \\in \\mathbb{R}^{n\\times n}$ 是正交矩阵，$R \\in \\mathbb{R}^{n\\times n}$ 是上三角矩阵，然后构成更新后的矩阵\n$$A_{+} = R Q + \\sigma I = Q^{\\mathsf T} A Q,$$\n该矩阵与 $A$ 正交相似，并保持上Hessenberg结构。假设所选位移 $\\sigma$ 精确等于 $A$ 的一个特征值，即 $\\det(A - \\sigma I) = 0$。在精确算术下，以下哪个陈述是正确的？\n\nA. 经过这一步，更新后的矩阵 $A_{+}$与 $A$ 正交相似，并且其末尾的次对角线元素 $a^{(+)}_{n,n-1}$ 精确等于 $0$，因此 $A_{+}$ 是一个分块上三角矩阵，其末尾有一个等于 $\\sigma$ 的 $1\\times 1$ 子块（立即紧缩）。\n\nB. 分解 $A - \\sigma I = Q R$ 不存在，因为 $A - \\sigma I$ 是奇异的，所以Francis步没有定义。\n\nC. 更新后的矩阵满足 $A_{+} = A$，因此迭代停滞，没有取得任何进展。\n\nD. 这一步破坏了上Hessenberg结构；即使在精确算术下，$A_{+}$ 通常也是稠密的。\n\nE. 在 $A - \\sigma I = Q R$ 中得到的矩阵 $Q$ 不是正交的，即 $Q^{\\mathsf T} Q \\neq I$，因为 $A - \\sigma I$ 是奇异的。", "solution": "在尝试求解之前，必须首先验证问题陈述的科学合理性、自洽性和清晰性。\n\n### 步骤1：提取已知条件\n\n已知条件如下：\n1.  $A \\in \\mathbb{R}^{n\\times n}$ 是一个未约化上Hessenberg矩阵。这意味着对于所有 $i > j+1$，$a_{i,j} = 0$；并且对于所有 $i \\in \\{1, 2, \\dots, n-1\\}$，$a_{i+1,i} \\neq 0$。\n2.  在精确算术下，使用一个实位移 $\\sigma \\in \\mathbb{R}$ 执行一步Francis QR步。\n3.  这一步由QR分解 $A - \\sigma I = Q R$ 定义，其中 $Q$ 是正交的（$Q^{\\mathsf T} Q = I$），$R$ 是上三角的。\n4.  更新后的矩阵是 $A_{+} = R Q + \\sigma I$。\n5.  已知 $A_{+} = Q^{\\mathsf T} A Q$，这证实了正交相似性和上Hessenberg结构的保持。\n6.  位移 $\\sigma$ 是 $A$ 的一个精确特征值：$\\det(A - \\sigma I) = 0$。\n7.  任务是在这些条件下，确定所提供的陈述中哪一个是正确的。\n\n### 步骤2：使用已知条件进行验证\n\n问题陈述描述了数值线性代数中一个特定的、众所周知的场景：当使用精确特征值作为位移时，QR算法的行为。诸如未约化Hessenberg矩阵、QR分解、Francis步、特征值等概念都是标准且精确定义的。精确算术的假设是一种常见的理论工具，用于在没有浮点误差复杂性的情况下分析算法。这些前提是相互一致的，并且足以推导出唯一的结论。该问题具有科学依据、是适定的、并且是客观的。因此，它是有效的。\n\n### 步骤3：推导正确答案\n\n问题的核心在于奇异矩阵 $M = A - \\sigma I$ 的QR分解的性质。\n\n首先，我们分析 $M = A - \\sigma I$ 的结构。由于 $A$ 是一个未约化上Hessenberg矩阵，其所有次对角线元素 $a_{i+1,i}$（对于 $i = 1, \\dots, n-1$）都是非零的。矩阵 $M$ 也是上Hessenberg矩阵，其次对角线元素与 $A$ 的相同，因此对于 $i=1, \\dots, n-1$，$m_{i+1,i} = a_{i+1,i} \\neq 0$。所以，$M$ 也是一个未约化上Hessenberg矩阵。\n\n一个 $n \\times n$ 未约化上Hessenberg矩阵的一个关键性质是其前 $n-1$ 列是线性无关的。我们可以用反证法证明这一点。假设前 $k$ 列的某个非平凡线性组合是零向量，对于某个 $k \\le n-1$：$\\sum_{j=1}^{k} c_j \\mathbf{m}_j = \\mathbf{0}$，其中 $\\mathbf{m}_j$ 是 $M$ 的第 $j$ 列，且不所有的 $c_j$ 都为零。令 $k$ 是满足 $c_k \\neq 0$ 的最大索引。考察该向量方程的第 $(k+1)$ 行，我们有 $\\sum_{j=1}^{k} c_j m_{k+1,j} = 0$。由于 $M$ 是上Hessenberg矩阵，对于 $j < k$，有 $m_{k+1,j} = 0$。该方程简化为 $c_k m_{k+1,k} = 0$。因为 $M$ 是未约化的，所以 $m_{k+1,k} \\neq 0$。这迫使 $c_k=0$，与我们 $c_k \\neq 0$ 的假设相矛盾。因此，$M$ 的前 $n-1$ 列必须是线性无关的。\n\n我们已知 $\\sigma$ 是 $A$ 的一个特征值，这意味着矩阵 $M = A - \\sigma I$ 是奇异的，即其秩小于 $n$。由于我们已经确定其前 $n-1$ 列是线性无关的，所以 $M$ 的秩必须恰好是 $n-1$。这意味着最后一列 $\\mathbf{m}_n$ 必定是前面 $n-1$ 列的线性组合。\n\n现在，考虑QR分解 $M = QR$。$Q$ 的列，记为 $\\mathbf{q}_1, \\dots, \\mathbf{q}_n$，构成一个标准正交基。$M$ 和 $R$ 之间的关系由 $R = Q^{\\mathsf T} M$ 给出。上三角矩阵 $R$ 的对角线元素是 $r_{kk} = \\mathbf{q}_k^{\\mathsf T} \\mathbf{m}_k$。在Gram-Schmidt过程的背景下， $|r_{kk}|$ 是 $\\mathbf{m}_k$ 正交于由 $\\{\\mathbf{m}_1, \\dots, \\mathbf{m}_{k-1}\\}$ 所张成的子空间的那个分量的范数。\n由于 $M$ 的前 $n-1$ 列是线性无关的，所以对于 $k=1, \\dots, n-1$，$r_{kk} \\neq 0$。\n然而，对于最后一列，$\\mathbf{m}_n$ 位于由 $\\{\\mathbf{m}_1, \\dots, \\mathbf{m}_{n-1}\\}$ 张成的空间中。由 $\\{\\mathbf{m}_1, \\dots, \\mathbf{m}_{n-1}\\}$ 张成的子空间与由标准正交向量 $\\{\\mathbf{q}_1, \\dots, \\mathbf{q}_{n-1}\\}$ 张成的子空间是相同的。因此，$\\mathbf{m}_n$与 $\\mathbf{q}_n$ 正交。所以，$R$ 的最后一个对角线元素是 $r_{nn} = \\mathbf{q}_n^{\\mathsf T} \\mathbf{m}_n = 0$。\n\n由于 $R$ 是一个上三角矩阵且其最后一个对角元素 $r_{nn}$ 是零，因此 $R$ 的整个最后一行必须是零。也就是说，对于所有 $j=1, \\dots, n$，$R_{n,j} = 0$。\n\n现在我们来分析更新后的矩阵 $A_{+} = R Q + \\sigma I$。让我们检查它的最后一行。\n乘积 $RQ$ 的最后一行是 $R$ 的最后一行与矩阵 $Q$ 的乘积。由于 $R$ 的最后一行是零向量，所以 $RQ$ 的最后一行也是零向量。\n$\\sigma I$ 的最后一行是 $[0, 0, \\dots, 0, \\sigma]$。\n因此，$A_{+}$ 的最后一行是这两行之和，即 $[0, 0, \\dots, 0, \\sigma]$。\n\n$A_{+}$ 最后一行这个结果意味着两件事：\n1.  元素 $a^{(+)}_{n,n-1} = 0$。\n2.  元素 $a^{(+)}_{n,n} = \\sigma$。\n\n$a^{(+)}_{n,n-1} = 0$ 这个事实意味着矩阵 $A_+$ 不再是未约化的。它具有一个分块上三角结构：\n$$ A_{+} =\n\\begin{pmatrix}\nA'_{11} & A'_{12} \\\\\n\\mathbf{0} & \\sigma\n\\end{pmatrix}\n$$\n其中 $A'_{11}$ 是一个 $(n-1) \\times (n-1)$ 的上Hessenberg矩阵。这个现象被称为紧缩（deflation），因为特征值 $\\sigma$ 已被成功分离出来，问题被简化为寻找更小的矩阵 $A'_{11}$ 的特征值。\n\n### 选项评估\n\n**A. 经过这一步，更新后的矩阵 $A_{+}$与 $A$ 正交相似，并且其末尾的次对角线元素 $a^{(+)}_{n,n-1}$ 精确等于 $0$，因此 $A_{+}$ 是一个分块上三角矩阵，其末尾有一个等于 $\\sigma$ 的 $1\\times 1$ 子块（立即紧缩）。**\n这个陈述完美地总结了我们的推导过程。\n- $A_{+} = Q^{\\mathsf T} A Q$，所以它与 $A$ 正交相似。正确。\n- $a^{(+)}_{n,n-1} = 0$。正确。\n- $A_{+}$ 是分块上三角矩阵，其末尾的 $1 \\times 1$ 子块 $a^{(+)}_{n,n} = \\sigma$。正确。\n这个过程被称为立即紧缩。因此，该陈述完全正确。\n**结论：正确。**\n\n**B. 分解 $A - \\sigma I = Q R$ 不存在，因为 $A - \\sigma I$ 是奇异的，所以Francis步没有定义。**\n任何实数或复数矩阵，无论其秩或是否奇异，都存在QR分解。矩阵的奇异性只意味着 $R$ 因子中至少有一个对角线元素为零。该陈述根本上是错误的。\n**结论：不正确。**\n\n**C. 更新后的矩阵满足 $A_{+} = A$，因此迭代停滞，没有取得任何进展。**\n$A_{+} = R Q + \\sigma I$ 且 $A = Q R + \\sigma I$。$A_{+} = A$ 将意味着 $RQ=QR$。一般来说，矩阵乘法不满足交换律。$Q$ 和 $R$ 不会交换，除非它们具有非常特殊的结构，但这里并非如此。正如我们对A的推导所示，$A_{+} \\neq A$，并且取得了重大进展（紧缩）。\n**结论：不正确。**\n\n**D. 这一步破坏了上Hessenberg结构；即使在精确算术下，$A_{+}$ 通常也是稠密的。**\n这与Francis QR步的一个基本性质相矛盾。正如问题陈述中所给出和从理论中所知，如果 $A$ 是上Hessenberg矩阵，那么 $A_{+} = Q^{\\mathsf T} A Q$ 也是上Hessenberg矩阵。根据隐式Q定理，结构是保持的。\n**结论：不正确。**\n\n**E. 在 $A - \\sigma I = Q R$ 中得到的矩阵 $Q$ 不是正交的，即 $Q^{\\mathsf T} Q \\neq I$，因为 $A - \\sigma I$ 是奇异的。**\n根据其定义，QR分解会产生一个正交矩阵 $Q$。计算它的标准算法，例如基于Householder反射或Givens旋转的算法，将 $Q$ 构造为正交矩阵的乘积，其本身也是正交的。被分解矩阵的奇异性影响的是 $R$ 因子，而不是 $Q$ 因子的正交性。\n**结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "2445523"}, {"introduction": "这是从理论到实践的终极挑战。你将综合运用 QR 迭代、移位策略（如 Wilkinson 移位）和降维等概念，从零开始构建一个完整且稳健的特征值求解器。通过这个编程实践，抽象的原理将转化为一个切实的计算工具，从而巩固你对该算法在真实世界中如何实现的深刻理解 [@problem_id:2445542]。", "problem": "实现一个完整的程序，使用正交三角(QR)分解及降阶技术，计算实对称矩阵的实特征值。核心计算任务是设计一个稳健的相似迭代方案，该方案仅基于以下经过充分检验的事实和核心定义：\n\n- 对于一个实方阵 $A \\in \\mathbb{R}^{n \\times n}$，若存在一个非零向量 $x \\in \\mathbb{R}^{n}$ 使得 $A x = \\lambda x$ 成立，则标量 $\\lambda \\in \\mathbb{R}$ 是一个特征值。\n- 对任意实方阵 $A$，都存在一个正交矩阵 $Q$ 和一个上三角矩阵 $R$，使得 $A = Q R$。\n- 正交相似变换保持特征值不变：如果 $Q^{\\top} Q = I$，那么 $A$ 和 $Q^{\\top} A Q$ 具有相同的特征值多重集。\n- 如果一个实对称矩阵是（精确或近似）块对角矩阵，其特征值是其对角线上各块特征值的并集；当某个次对角线元素足够小时，这为执行降阶（deflation）提供了理论基础。\n\n你的程序必须实现一个带位移的QR迭代，并结合显式降阶：\n\n- 在对大小为 $m \\times m$ 的活动前导主子矩阵的每一步迭代中，应用一个单位移QR步骤，其使用的Wilkinson型位移 $\\mu$ 根据尾部的 $2 \\times 2$ 主子矩阵构造。\n- 构造 $A_{k} - \\mu I = Q R$，然后更新 $A_{k+1} = R Q + \\mu I$，该矩阵与 $A_{k}$ 正交相似。\n- 使用降阶准则：对于用户指定的容差 $\\tau$，当次对角线元素 $|a_{m,m-1}|$ 满足 $|a_{m,m-1}| \\le \\tau \\cdot \\left(|a_{m-1,m-1}| + |a_{m,m}|\\right)$ 时，视其为可忽略。执行降阶时，将 $a_{m,m}$ 锁定为一个已收敛的特征值，将 $m$ 减为 $m \\leftarrow m - 1$，并在缩减后的前导主子矩阵上继续。当 $m=1$ 时，锁定最后一个对角线元素。\n- 假设所有输入矩阵均为实对称矩阵。本任务不涉及角度，也不涉及物理单位。\n\n数值要求与约束：\n\n- 对单个矩阵的整个计算过程，使用相对降阶容差 $\\tau = 10^{-12}$ 和硬性迭代上限 $K_{\\max} = 10000$ 次。如果在所有降阶完成前达到迭代上限，则返回活动块当前的对角线元素作为剩余特征值的估计值。\n- 在每个相似变换步骤之后，可以通过将活动块与其转置矩阵求平均值来强制其对称性，以抵消浮点运算带来的不对称性。\n\n测试套件：\n\n你的程序必须能在以下矩阵上运行。每个矩阵都必须作为一个独立的测试用例处理。\n\n- 测试用例 1 （大小 $3 \\times 3$）：\n  $$\n  A_{1} = \\begin{bmatrix}\n  4 & 1 & 0 \\\\\n  1 & 3 & 1 \\\\\n  0 & 1 & 2\n  \\end{bmatrix}.\n  $$\n- 测试用例 2 （大小 $5 \\times 5$）：一个三对角Toeplitz矩阵，其主对角线元素为 $2$，第一条次对角线和超对角线元素为 $-1$，\n  $$\n  A_{2} = \\begin{bmatrix}\n  2 & -1 & 0 & 0 & 0 \\\\\n  -1 & 2 & -1 & 0 & 0 \\\\\n  0 & -1 & 2 & -1 & 0 \\\\\n  0 & 0 & -1 & 2 & -1 \\\\\n  0 & 0 & 0 & -1 & 2\n  \\end{bmatrix}.\n  $$\n- 测试用例 3 （大小 $2 \\times 2$）：一个近乎对角、其次对角线元素可立即被降阶的矩阵，\n  $$\n  A_{3} = \\begin{bmatrix}\n  2 & 10^{-12} \\\\\n  10^{-12} & 2\n  \\end{bmatrix}.\n  $$\n- 测试用例 4 （大小 $1 \\times 1$）：\n  $$\n  A_{4} = \\begin{bmatrix}\n  7\n  \\end{bmatrix}.\n  $$\n\n要求的输出格式：\n\n- 对每个测试用例，使用所述的带降阶的QR迭代计算所有实特征值。将特征值按非递减顺序排序，并将每个特征值四舍五入到8位小数。\n- 你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。列表中的每个元素是对应一个测试用例（按 $A_{1}, A_{2}, A_{3}, A_{4}$ 的顺序）的四舍五入后的特征值列表。例如，整体格式必须为\n  $$\n  [ [\\cdot,\\cdots,\\cdot], [\\cdot,\\cdots,\\cdot], [\\cdot,\\cdots,\\cdot], [\\cdot] ].\n  $$\n\n答案类型：\n\n- 每个测试用例的答案是一个浮点数列表。因此，最终输出是一个浮点数列表的列表，并需按上文描述的精确格式以单行打印。", "solution": "所述问题具有科学依据、问题适定、客观且内容完整。它描述了计算线性代数中一个标准且重要的数值算法——用于求解实对称矩阵特征值的带Wilkinson位移的QR迭代法。所有参数、基本原理和测试用例都足够清晰和精确，可以得出一个唯一且可验证的解。因此，该问题是有效的。\n\n任务是计算给定实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的实特征值。指定的方法是采用特定位移策略和降阶准则的QR算法。该迭代算法生成一个矩阵序列 $A_0, A_1, A_2, \\dots$，序列中的每个矩阵都与初始矩阵 $A_0 = A$ 正交相似，并且该序列会收敛到一个对角矩阵，其对角线上的元素即为 $A$ 的特征值。\n\n其基本原理是正交相似变换保持特征值不变。如果 $A = Q R$，其中 $Q$ 是正交矩阵（$Q^{\\top}Q = I$），$R$ 是上三角矩阵，那么基本的QR迭代将序列中的下一个矩阵定义为 $A_1 = R Q$。这个新矩阵 $A_1$ 与 $A$ 正交相似，因为 $A_1 = R Q = (Q^{\\top}A) Q = Q^{\\top}A Q$。对于对称矩阵 $A$，序列 $\\{A_k\\}$ 会收敛到一个对角矩阵。\n\n为了加速收敛，尤其对于对称矩阵，在每一步迭代 $k$ 中引入一个原点位移 $\\mu_k$。迭代过程变为：\n1. 选择一个位移 $\\mu_k$。\n2. 对位移后的矩阵进行分解：$A_k - \\mu_k I = Q_k R_k$。\n3. 计算下一个迭代矩阵：$A_{k+1} = R_k Q_k + \\mu_k I$。\n此变换同样保持特征值不变：$A_{k+1} = R_k Q_k + \\mu_k I = (Q_k^{\\top}(A_k - \\mu_k I))Q_k + \\mu_k I = Q_k^{\\top}A_k Q_k - \\mu_k Q_k^{\\top}I Q_k + \\mu_k I = Q_k^{\\top}A_k Q_k - \\mu_k I + \\mu_k I = Q_k^{\\top}A_k Q_k$。因此，$A_{k+1}$ 与 $A_k$ 正交相似。一个好的位移 $\\mu_k$ 选择可以显著提高收敛速度。\n\n按规定，该算法在一个大小为 $m \\times m$ (其中 $m$ 初始值为 $n$)、且规模逐渐缩小的活动前导主子矩阵上运行。主过程持续进行，直到找到所有特征值（$m=0$）或达到最大迭代次数 $K_{\\max} = 10000$。\n\n在每个阶段，算法首先检查是否可以进行降阶。这是提高效率的关键一步。当相应的非对角元素变得可以忽略时，就认为一个特征值已经收敛。问题指定了一个明确的降阶策略，重点关注活动子矩阵的尾部元素。如果次对角线元素 $|a_{m,m-1}|$ 满足条件\n$$\n|a_{m,m-1}| \\le \\tau \\cdot \\left(|a_{m-1,m-1}| + |a_{m,m}|\\right)\n$$\n（容差 $\\tau = 10^{-12}$），则尾部对角元素 $a_{m,m}$ 被接受为已收敛的特征值。然后，活动矩阵的大小减一（$m \\leftarrow m - 1$），并在新的、更小的 $(m-1) \\times (m-1)$ 子矩阵上继续该过程。如果 $m=1$，则单个元素 $a_{1,1}$ 立即被确定为一个特征值。\n\n如果降阶准则未被满足，则对当前 $m \\times m$ 大小的活动子矩阵执行一步带位移的QR迭代。所指定的位移是Wilkinson位移，这是处理对称矩阵的一种高效选择，已知其具有渐进三次收敛的特性。Wilkinson位移 $\\mu$ 通过检查活动块的尾部 $2 \\times 2$ 主子矩阵来确定：\n$$\n\\begin{bmatrix}\na_{m-2,m-2} & a_{m-2,m-1} \\\\\na_{m-1,m-2} & a_{m-1,m-1}\n\\end{bmatrix}\n$$\n令 $d = a_{m-1,m-1}$，$a = a_{m-2,m-2}$，$b = a_{m-1,m-2}$，以及 $\\delta = (a - d)/2$，位移 $\\mu$ 是这个 $2 \\times 2$ 矩阵中更接近 $d$ 的那个特征值。计算此位移的数值稳定公式为：\n$$\n\\mu = d - \\frac{b^2}{\\delta + \\operatorname{sgn}(\\delta) \\sqrt{\\delta^2 + b^2}}\n$$\n如果 $\\delta = 0$，则公式简化为 $\\mu = d - |b|$。计算出 $\\mu$ 后，在 $m \\times m$ 子矩阵上执行QR步骤 $A_k - \\mu I = QR$ 和更新步骤 $A_{k+1} = RQ + \\mu I$。\n\n由于浮点运算，矩阵在更新后可能会失去完美的对称性。为抵消此影响，在每一步之后通过将矩阵与其转置求平均来强制对称性：$A \\leftarrow (A + A^{\\top}) / 2$。\n\n如果在所有特征值收敛之前（即 $m>0$）迭代次数 $K_{\\max}$ 已耗尽，则算法终止，并将剩余 $m \\times m$ 活动子矩阵的对角线元素作为剩余特征值的估计值返回。\n\n最后，对给定矩阵计算出的所有特征值进行收集，按非递减顺序排序，并按要求四舍五入到8位小数。此过程独立应用于每个测试用例矩阵。", "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the eigenvalue computation on the test suite.\n    \"\"\"\n\n    def qr_eigenvalues(A_orig: np.ndarray, tol: float, max_iter: int):\n        \"\"\"\n        Computes the eigenvalues of a real symmetric matrix using the QR algorithm\n        with Wilkinson shifts and explicit deflation.\n\n        Args:\n            A_orig: The input real symmetric matrix.\n            tol: The relative tolerance for deflation.\n            max_iter: The maximum number of iterations allowed for the entire matrix.\n\n        Returns:\n            A list of computed eigenvalues, sorted in nondecreasing order.\n        \"\"\"\n        A = A_orig.copy().astype(np.float64)\n        n = A.shape[0]\n        m = n\n        eigenvalues = []\n        total_iters = 0\n\n        while m > 0:\n            if total_iters >= max_iter:\n                # Iteration cap reached, return current diagonal entries of active block.\n                for i in range(m):\n                    eigenvalues.append(A[i, i])\n                break\n\n            if m == 1:\n                eigenvalues.append(A[0, 0])\n                m = 0\n                continue\n\n            # Check for deflation at the bottom of the active submatrix\n            sub_diag_val = A[m - 1, m - 2]\n            diag1 = A[m - 2, m - 2]\n            diag2 = A[m - 1, m - 1]\n            \n            # The deflation criterion check. The epsilon is to prevent division by zero in rare cases.\n            if abs(sub_diag_val) <= tol * (abs(diag1) + abs(diag2)) + np.finfo(float).eps:\n                eigenvalues.append(diag2)\n                m -= 1\n                # After deflation, we might be able to deflate again, so continue the loop\n                continue\n\n            # No deflation, perform a shifted QR step on the active m x m submatrix\n            active_block = A[:m, :m]\n\n            # Calculate the Wilkinson shift from the trailing 2x2 submatrix\n            d = active_block[m - 1, m - 1]\n            a = active_block[m - 2, m - 2]\n            b = active_block[m - 1, m - 2]\n            \n            delta = (a - d) / 2.0\n            \n            if delta == 0.0:\n                 # Handle the case where the denominator in the main formula would be zero.\n                 # This can happen if delta is zero. Eigenvalues are d +/- |b|.\n                 # Convention is to pick one, e.g., the one further from d.\n                 mu = d - abs(b)\n            else:\n                 # Numerically stable formula for the eigenvalue of the 2x2 submatrix closer to d.\n                 mu = d - (b**2) / (delta + np.sign(delta) * np.sqrt(delta**2 + b**2))\n\n            # Perform the QR decomposition and update step\n            I = np.identity(m)\n            Q, R = scipy.linalg.qr(active_block - mu * I, mode='full')\n            \n            updated_block = R @ Q + mu * I\n            \n            # Enforce symmetry to counteract floating-point errors\n            A[:m, :m] = (updated_block + updated_block.T) / 2.0\n            \n            total_iters += 1\n            \n        return sorted(eigenvalues)\n\n    # Numerical requirements and constraints from the problem\n    tau = 1e-12\n    K_max = 10000\n\n    # Test suite\n    test_cases = [\n        np.array([[4, 1, 0], \n                  [1, 3, 1], \n                  [0, 1, 2]]),\n        \n        np.array([[2, -1, 0, 0, 0], \n                  [-1, 2, -1, 0, 0], \n                  [0, -1, 2, -1, 0], \n                  [0, 0, -1, 2, -1], \n                  [0, 0, 0, -1, 2]]),\n        \n        np.array([[2, 1e-12], \n                  [1e-12, 2]]),\n        \n        np.array([[7]])\n    ]\n\n    results = []\n    for A in test_cases:\n        eigs = qr_eigenvalues(A, tol=tau, max_iter=K_max)\n        rounded_eigs = [round(val, 8) for val in eigs]\n        results.append(rounded_eigs)\n\n    # Format the final output as a single-line string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2445542"}]}