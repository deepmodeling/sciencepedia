{"hands_on_practices": [{"introduction": "将理论付诸实践是掌握代数特征值问题的关键。这个练习将指导你实现一个核心的数值算法——带位移的逆迭代法，用于精确寻找最接近特定目标值（如共振频率）的特征值和特征向量。通过这个实践，你不仅能理解该方法的数学原理，还能学会在编程中处理数值稳定性和计算效率等实际问题。[@problem_id:2442752]", "problem": "实现一个程序，该程序使用带实数位移的逆迭代法为多个实数矩阵计算近似特征对。其目标是近似求解与矩阵 $A$ 的特定特征值相对应的特征对，该特征值最接近一个给定的目标共振频率（即位移）$\\sigma$。程序必须遵循植根于代数特征值问题和谱分解的原则性算法设计。\n\n从以下基本原理开始：\n- 一个实方阵 $A \\in \\mathbb{R}^{n \\times n}$ 的特征对 $(\\lambda, v)$ 满足 $A v = \\lambda v$，其中 $v \\neq 0$。\n- 如果 $A$ 是可对角化的，则存在一个由特征向量组成的基 $\\{v_i\\}_{i=1}^n$ 及对应的特征值 $\\{\\lambda_i\\}_{i=1}^n$，使得对于任意向量 $x \\in \\mathbb{R}^n$ 都可以写成 $x = \\sum_{i=1}^n \\alpha_i v_i$。\n- 对于一个实数标量位移 $\\sigma \\in \\mathbb{R}$，如果 $A - \\sigma I$ 可逆，那么矩阵 $(A - \\sigma I)^{-1}$ 与 $A$ 具有相同的特征向量，其特征值为 $\\{(\\lambda_i - \\sigma)^{-1}\\}_{i=1}^n$。\n\n您必须按如下方式实现带位移 $\\sigma$ 的逆迭代法：\n- 在第 $k$ 次迭代时，使用位移线性系统 $(A - \\sigma I) y^{(k)} = x^{(k-1)}$，其中初始向量 $x^{(0)}$ 为单位二范数（欧几里得范数）归一化后的全1向量。\n- 为在多次迭代中稳健且高效地求解该线性系统，请使用LU（下三角-上三角）分解对同一个系数矩阵进行一次分解并重复使用。如果 $(A - \\sigma I)$ 是奇异或数值病态的，则从序列 $\\{0, 10^{-12}, 10^{-10}, 10^{-8}, 10^{-6}, 10^{-4}\\}$ 中选取最小的非负 $\\delta$，将其替换为 $(A - \\sigma I + \\delta I)$，使得新矩阵在二范数下的条件数小于 $10^{12}$。\n- 在每次迭代时，进行归一化 $x^{(k)} = y^{(k)} / \\| y^{(k)} \\|_2$。\n- 在每次迭代时，计算瑞利商 $\\mu^{(k)} = (x^{(k)})^\\top A x^{(k)}$ 作为特征值的估计，并计算残差二范数 $r^{(k)} = \\| A x^{(k)} - \\mu^{(k)} x^{(k)} \\|_2$。\n- 当 $r^{(k)} \\le \\tau$ （其中 $\\tau = 10^{-10}$）或迭代次数达到 $k_{\\max} = 100$ 时终止。\n\n对于每个测试用例，您的程序必须产出最终的特征值估计 $\\mu^{(*)}$，其形式为一个四舍五入到六位小数的浮点数。无需打印特征向量的估计值。\n\n本问题不涉及角度单位。没有物理单位；所有计算都在实数算术下进行，输出是无量纲的。\n\n测试套件（矩阵 $A$ 和位移 $\\sigma$）：\n- 案例 $1$（对称三对角矩阵）：\n  $$A_1 = \\begin{bmatrix} 4 & 1 & 0 \\\\ 1 & 3 & 1 \\\\ 0 & 1 & 2 \\end{bmatrix}, \\quad \\sigma_1 = 3.2.$$\n- 案例 $2$（上三角，非对称；精确位移奇异性）：\n  $$A_2 = \\begin{bmatrix} 1 & 2 & 0 \\\\ 0 & 3 & 1 \\\\ 0 & 0 & 5 \\end{bmatrix}, \\quad \\sigma_2 = 3.0.$$\n- 案例 $3$（对角矩阵，特征值在位移附近聚集）：\n  $$A_3 = \\operatorname{diag}(2.0, 2.1, 10.0), \\quad \\sigma_3 = 2.08.$$\n- 案例 $4$（对称稠密矩阵）：\n  $$A_4 = \\begin{bmatrix} 6 & 2 & 1 \\\\ 2 & 3 & 1 \\\\ 1 & 1 & 1 \\end{bmatrix}, \\quad \\sigma_4 = 6.5.$$\n\n实现要求：\n- 每个测试用例仅对选定的系数矩阵执行一次LU（下三角-上三角）分解，并在多次迭代中重复使用该分解结果。\n- 从指定序列中选择最小的 $\\delta$，以确保 $A - \\sigma I + \\delta I$ 在二范数下的条件数小于 $10^{12}$。如果没有 $\\delta$ 满足此条件，则使用序列中最后一个值 $\\delta = 10^{-4}$。\n- 使用归一化为单位二范数的全1向量来初始化 $x^{(0)}$。全程使用实数算术。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的结果，形式为逗号分隔的列表，例如：\n  $$[\\mu_1,\\mu_2,\\mu_3,\\mu_4],$$\n  其中每个 $\\mu_i$ 是案例 $i$ 的最终特征值估计，四舍五入到六位小数，表示为十进制数（而非分数）。\n\n您的程序必须是自包含的，且不需要任何输入。它必须执行四个指定的测试用例，并严格按照上述格式打印一行输出。", "solution": "所提出的问题是计算线性代数中的一个标准任务：对于一个方阵 $A$，寻找其特征对 $(\\lambda, v)$ 的一个近似值，其中特征值 $\\lambda$ 最接近一个指定的实数 $\\sigma$（称为位移）。指定的方法是带位移的逆迭代算法，这是一种稳健且广泛使用的数值技术。\n\n该方法的基础在于矩阵求逆和位移操作下特征值的性质。标准特征值问题由方程 $A v = \\lambda v$ 定义，其中 $\\lambda$ 是标量特征值，$v$ 是对应的非零特征向量。如果我们考虑一个位移矩阵 $(A - \\sigma I)$，其中 $\\sigma \\in \\mathbb{R}$ 是位移，$I$ 是单位矩阵，则其特征值为 $(\\lambda_i - \\sigma)$，其中 $\\{\\lambda_i\\}$ 是 $A$ 的特征值。特征向量保持不变。\n\n假设位移矩阵 $(A - \\sigma I)$ 可逆，我们可以考虑其逆矩阵 $(A - \\sigma I)^{-1}$。该逆矩阵的特征值是 $(A - \\sigma I)$ 特征值的倒数，即 $\\{(\\lambda_i - \\sigma)^{-1}\\}$。当幂法应用于一个矩阵时，它会迭代收敛到与模最大的特征值相关联的特征向量。因此，将幂法应用于 $(A - \\sigma I)^{-1}$ 将会收敛到对应于特征值 $(\\lambda_j - \\sigma)^{-1}$ 的特征向量，该特征值具有最大的绝对值。这种情况在分母 $|\\lambda_j - \\sigma|$ 最小时发生。因此，该过程分离出了原始矩阵 $A$ 中与最接近位移 $\\sigma$ 的特征值 $\\lambda_j$ 相对应的特征向量 $v_j$。这就是位移反演法（shift-and-invert）或带位移的逆迭代法的原理。\n\n迭代过程由 $x^{(k)} = c_k (A - \\sigma I)^{-1} x^{(k-1)}$ 给出，其中 $c_k$ 是一个归一化常数。在实践中，计算矩阵的逆既计算成本高昂又数值不稳定。求解等价的线性方程组效率要高得多：\n$$\n(A - \\sigma I) y^{(k)} = x^{(k-1)}\n$$\n然后通过对解向量 $y^{(k)}$ 进行归一化来获得新的迭代向量：\n$$\nx^{(k)} = \\frac{y^{(k)}}{\\|y^{(k)}\\|_2}\n$$\n为了在多次迭代中高效地求解线性系统，系数矩阵（我们称之为 $M = A - \\sigma I$）只需分解一次。本问题指定使用 LU 分解。这种分解会找到一个下三角矩阵 $L$、一个上三角矩阵 $U$ 和一个置换矩阵 $P$，使得 $PM = LU$。线性系统 $My^{(k)} = x^{(k-1)}$ 随之被重写为 $P^{-1}LU y^{(k)} = x^{(k-1)}$，或 $LU y^{(k)} = P x^{(k-1)}$。这个方程分两个阶段求解：首先，通过前向代换求解 $Lz = P x^{(k-1)}$ 得到 $z$；其次，通过反向代换求解 $Uy^{(k)} = z$ 得到 $y^{(k)}$。这个两步过程比在每次迭代中都从头求解系统要快得多。\n\n一个关键的考虑是当位移 $\\sigma$ 与 $A$ 的某个特征值非常接近或相等时。在这种情况下，矩阵 $M = A - \\sigma I$ 会变得病态或奇异，导致线性系统无解或其解对误差高度敏感。本问题强制要求一个特定的、稳健的协议来处理这种情况。我们必须计算 $M$ 在二范数下的条件数 $\\kappa_2(M)$。如果 $\\kappa_2(M) \\ge 10^{12}$，则该矩阵被认为是病态的。为了对其进行正则化，我们引入一个小的扰动 $\\delta > 0$，并使用矩阵 $M' = A - \\sigma I + \\delta I$。我们必须从提供的序列 $\\{0, 10^{-12}, 10^{-10}, 10^{-8}, 10^{-6}, 10^{-4}\\}$ 中选择最小的 $\\delta$，使得 $\\kappa_2(M') < 10^{12}$。然后对这个正则化后的矩阵 $M'$ 执行 LU 分解。\n\n对每个测试用例 $(A, \\sigma)$，算法按如下步骤进行：\n$1.$ 定义扰动序列 $\\Delta = \\{0, 10^{-12}, 10^{-10}, 10^{-8}, 10^{-6}, 10^{-4}\\}$。\n$2.$ 对 $\\Delta$ 中的每个 $\\delta$，构造矩阵 $M = A - \\sigma I + \\delta I$。计算其条件数 $\\kappa_2(M)$。选择第一个使 $\\kappa_2(M) < 10^{12}$ 的 $\\delta$，并使用这个矩阵 $M$ 进行迭代。如果不存在这样的 $\\delta$，则使用最后一个值 $\\delta = 10^{-4}$。\n$3.$ 对选定的矩阵 M 进行 LU 分解。\n$4.$ 将迭代向量 $x^{(0)}$ 初始化为欧几里得范数为1的全1向量。\n$5.$ 对于 $k = 1, 2, \\ldots, k_{\\max}$：\n    a. 使用预先计算的 LU 分解求解线性系统 $M y^{(k)} = x^{(k-1)}$。\n    b. 归一化结果向量：$x^{(k)} = y^{(k)} / \\| y^{(k)} \\|_2$。\n    c. 使用瑞利商计算特征值估计：$\\mu^{(k)} = (x^{(k)})^\\top A x^{(k)}$。\n    d. 计算残差范数：$r^{(k)} = \\| A x^{(k)} - \\mu^{(k)} x^{(k)} \\|_2$。\n    e. 检查收敛性：如果 $r^{(k)} \\le 10^{-10}$，则迭代终止。\n$6.$ 如果达到最大迭代次数 $k_{\\max} = 100$，迭代也会终止。\n$7.$ 最终的特征值估计 $\\mu^{(*)}$ 是最后计算出的 $\\mu^{(k)}$ 的值，然后将其四舍五入到六位小数作为输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Computes an approximate eigenpair for several matrices using inverse iteration with a real shift.\n    - An eigenpair (lambda, v) satisfies A v = lambda v.\n    - Inverse iteration with shift sigma finds the eigenvalue of A closest to sigma.\n    - The method iteratively solves (A - sigma I) y_k = x_{k-1} and normalizes x_k = y_k / ||y_k||.\n    - LU factorization is used for efficient solving of the linear system.\n    - Ill-conditioning is handled by perturbing the matrix with a small delta.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (symmetric tridiagonal)\n        (np.array([[4, 1, 0], [1, 3, 1], [0, 1, 2]], dtype=float), 3.2),\n        # Case 2 (upper triangular, non-symmetric; exact-shift singularity)\n        (np.array([[1, 2, 0], [0, 3, 1], [0, 0, 5]], dtype=float), 3.0),\n        # Case 3 (diagonal, clustered eigenvalues near the shift)\n        (np.diag([2.0, 2.1, 10.0]), 2.08),\n        # Case 4 (symmetric dense)\n        (np.array([[6, 2, 1], [2, 3, 1], [1, 1, 1]], dtype=float), 6.5)\n    ]\n\n    results = []\n    \n    # Constants defined in the problem\n    k_max = 100\n    tau = 1e-10\n    cond_threshold = 1e12\n    deltas = [0, 1e-12, 1e-10, 1e-8, 1e-6, 1e-4]\n\n    for A, sigma in test_cases:\n        n = A.shape[0]\n        I = np.identity(n)\n        \n        # Step 1: Select coefficient matrix M by handling ill-conditioning\n        M = None\n        chosen_delta = None\n        \n        for delta in deltas:\n            M_candidate = A - sigma * I + delta * I\n            # The problem specifies condition number in the two-norm\n            cond_num = np.linalg.cond(M_candidate, p=2)\n            \n            if cond_num < cond_threshold:\n                M = M_candidate\n                chosen_delta = delta\n                break\n        \n        # If no delta satisfied the condition, use the last one\n        if M is None:\n            delta = deltas[-1]\n            M = A - sigma * I + delta * I\n            chosen_delta = delta\n            \n        # Step 2: Perform LU factorization once\n        lu_factor = linalg.lu_factor(M)\n        \n        # Step 3: Initialize the vector x_0\n        x = np.ones(n, dtype=float)\n        x = x / np.linalg.norm(x, 2)\n        \n        mu_final = 0.0\n        \n        # Step 4: Inverse Iteration Loop\n        for k in range(k_max):\n            # Solve (A - sigma*I + delta*I) y_k = x_{k-1} using LU decomposition\n            y = linalg.lu_solve(lu_factor, x)\n            \n            # Normalize to get the next iterate x_k\n            x = y / np.linalg.norm(y, 2)\n            \n            # Compute Rayleigh quotient as eigenvalue estimate\n            mu = (x.T @ A @ x)\n            mu_final = mu\n            \n            # Compute residual norm for convergence check\n            residual_norm = np.linalg.norm(A @ x - mu * x, 2)\n            \n            # Termination condition\n            if residual_norm <= tau:\n                break\n        \n        results.append(round(mu_final, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2442752"}, {"introduction": "特征值分析是理解和预测动态系统行为的强大工具，尤其是在计算工程的数值模拟中。本练习将探讨如何利用放大矩阵的谱半径来判断一个常见时间积分格式（前向欧拉法）的数值稳定性。这个实践将让你亲身体验特征值的大小如何直接决定模拟结果是收敛还是发散，从而揭示理论与计算实践之间的深刻联系。[@problem_id:2442744]", "problem": "考虑线性自治系统 $ \\dot{\\mathbf{u}}(t) = A \\mathbf{u}(t) $，其中 $ A \\in \\mathbb{C}^{n \\times n} $。采用步长为 $ \\Delta t \\in \\mathbb{R}_{>0} $ 的显式前向欧拉时间步进格式，可得到递推关系 $ \\mathbf{u}^{k+1} = G \\mathbf{u}^{k} $，其中放大矩阵为\n$$\nG = I + \\Delta t \\, A,\n$$\n其中 $ I $ 是大小为 $ n $ 的单位矩阵。令 $ \\{ \\lambda_i(G) \\}_{i=1}^n $ 表示 $ G $ 的特征值，并定义谱半径为\n$$\n\\rho(G) = \\max_{1 \\le i \\le n} |\\lambda_i(G)|.\n$$\n\n对于显式格式的线性不稳定性，采用以下数学上精确的分类标准：\n- 如果 $ \\rho(G) > 1 $，则判定格式为“不稳定”(unstable)。\n- 如果 $ \\rho(G) = 1 $，当且仅当 $ G $ 在 $ \\mathbb{C} $ 上不可对角化时，判定格式为“不稳定”(unstable)。\n- 其他情况，判定格式为“非不稳定”(not unstable)。\n\n所有涉及与 $ 1 $ 相等以及可对角化性的判断，必须使用容差 $ \\varepsilon = 10^{-10} $ 来考虑有限精度，具体如下：\n- 如果 $ |x - 1| \\le \\varepsilon $，则将实数 $ x $ 视为等于 $ 1 $。\n- 如果 $ \\rho(G) \\ge 1 + \\varepsilon $，则视为 $ \\rho(G) > 1 $。\n- 如果 $ \\rho(G) \\le 1 - \\varepsilon $，则视为 $ \\rho(G) < 1 $。\n- 当且仅当特征向量矩阵具有满列秩 $ n $（秩检验使用容差 $ \\varepsilon $ 进行评估）时，将 $ G $ 视为在 $ \\mathbb{C} $ 上可对角化。\n\n对于下方的每个测试用例，计算：\n$ (i) $ 谱半径 $ \\rho(G) $，\n$ (ii) $ 一个布尔标志，根据上述标准指示格式是否不稳定，以及\n$ (iii) $ 一个布尔标志，指示 $ G $ 在 $ \\mathbb{C} $ 上是否可对角化。\n\n测试套件（每个用例均为一对 $ (A, \\Delta t) $，其中 $ A \\in \\mathbb{R}^{2 \\times 2} $ 且 $ \\Delta t \\in \\mathbb{R}_{>0} $）：\n- 用例 1：\n$$\nA_1 = \\begin{bmatrix} -2 & 0 \\\\ 0 & -5 \\end{bmatrix}, \\quad \\Delta t_1 = 0.2.\n$$\n- 用例 2：\n$$\nA_2 = \\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\end{bmatrix}, \\quad \\Delta t_2 = 0.6.\n$$\n- 用例 3：\n$$\nA_3 = \\begin{bmatrix} 0 & 1 \\\\ 0 & 0 \\end{bmatrix}, \\quad \\Delta t_3 = 0.5.\n$$\n- 用例 4：\n$$\nA_4 = \\begin{bmatrix} -4 & 0 \\\\ 0 & 0 \\end{bmatrix}, \\quad \\Delta t_4 = 0.5.\n$$\n\n最终输出格式：\n您的程序必须生成单行输出，其中包含按顺序排列的 $4$ 个测试用例的结果列表。每个测试用例的结果必须是一个列表 $ [\\rho(G),\\ \\text{is\\_unstable},\\ \\text{is\\_diagonalizable}] $。整个输出必须是包含这 $4$ 个列表的单个方括号列表，打印在同一行上，无额外文本。例如，包含 $2$ 个用例的输出应如下所示：\n[[1.0,False,True],[1.2,True,True]]", "solution": "本题要求对线性常微分方程组 $ \\dot{\\mathbf{u}}(t) = A \\mathbf{u}(t) $ 的显式前向欧拉方法进行稳定性分析。需对给定的几个测试用例执行此分析。\n\n前向欧拉格式通过有限差分来近似时间导数，$ \\dot{\\mathbf{u}}(t) \\approx (\\mathbf{u}^{k+1} - \\mathbf{u}^{k}) / \\Delta t $，其中 $ \\mathbf{u}^k $ 表示在时间 $ t_k = k \\Delta t $ 时的数值解，$ \\Delta t $ 是时间步长。将此代入控制微分方程，可得到递推关系：\n$$ \\frac{\\mathbf{u}^{k+1} - \\mathbf{u}^{k}}{\\Delta t} = A \\mathbf{u}^{k} $$\n$$ \\mathbf{u}^{k+1} = \\mathbf{u}^{k} + \\Delta t A \\mathbf{u}^{k} = (I + \\Delta t A) \\mathbf{u}^{k} $$\n矩阵 $ G = I + \\Delta t A $ 是放大矩阵，它将第 $ k $ 步的解映射到第 $ k+1 $ 步。数值格式的稳定性由该矩阵 $ G $ 的性质决定。\n\n当 $ k \\to \\infty $ 时，解的行为由 $ G $ 的特征值决定。如果 $ \\left\\{ \\mu_j \\right\\}_{j=1}^n $ 是矩阵 $ A $ 的特征值，那么 $ G $ 的特征值（记为 $ \\left\\{ \\lambda_j \\right\\}_{j=1}^n $）由关系式 $ \\lambda_j = 1 + \\Delta t \\, \\mu_j $ 给出。格式的稳定性取决于这些特征值的模。\n\n题目指定了一套精确的准则，用于根据 $ G $ 的谱半径 $ \\rho(G) = \\max_j |\\lambda_j(G)| $ 及其可对角化性来对格式的稳定性进行分类。对于所有浮点数比较，都强制要求使用 $ \\varepsilon = 10^{-10} $ 的数值容差。\n\n稳定性准则如下：\n1.  如果 $ \\rho(G) \\ge 1 + \\varepsilon $，则判定格式为“不稳定”(unstable)。此时至少有一个特征值位于复平面的单位圆之外，导致数值解呈指数增长。\n2.  如果 $ |\\rho(G) - 1| \\le \\varepsilon $，则稳定性取决于 $ G $ 的特征空间的结构。\n    - 如果 $ G $ 不可对角化，则对于模为 $1$ 的特征值，它至少有一个尺寸大于 $1$ 的若尔当块 (Jordan block)。这会导致长期增长（例如，形式为 $ c k \\lambda^k $），格式为“不稳定”(unstable)。\n    - 如果 $ G $ 可对角化，则所有模为 $1$ 的特征值对应的模式均为非增长的，格式为“非不稳定”(not unstable)。\n3.  如果 $ \\rho(G) \\le 1 - \\varepsilon $，则所有特征值都严格位于单位圆内部，确保数值解衰减至零。格式为“非不稳定”(not unstable)。\n\n一个矩阵 $ G \\in \\mathbb{C}^{n \\times n} $ 可对角化的充要条件是它拥有 $ n $ 个线性无关的特征向量。这等价于其特征向量矩阵 $V$ 具有满秩，即 $ \\text{rank}(V) = n $。在数值计算上，通过计算 $V$ 的奇异值中大于给定容差 $ \\varepsilon $ 的数量，可以稳健地计算秩。\n\n现在我们根据这些原则分析每个测试用例。\n\n**用例 1:** $ A_1 = \\begin{bmatrix} -2 & 0 \\\\ 0 & -5 \\end{bmatrix} $, $ \\Delta t_1 = 0.2 $。\n- 放大矩阵为 $ G_1 = I + 0.2 A_1 = \\begin{bmatrix} 1+0.2(-2) & 0 \\\\ 0 & 1+0.2(-5) \\end{bmatrix} = \\begin{bmatrix} 0.6 & 0 \\\\ 0 & 0 \\end{bmatrix} $。\n- 这个对角矩阵的特征值可见于其对角线上：$ \\lambda_1 = 0.6 $ 和 $ \\lambda_2 = 0 $。\n- 谱半径为 $ \\rho(G_1) = \\max(|0.6|, |0|) = 0.6 $。\n- 由于 $ 0.6 \\le 1 - \\varepsilon $，格式为“非不稳定”(not unstable)。\n- $G_1$ 是一个对角矩阵，所有对角矩阵都是可对角化的。\n- 结果: $ [\\rho(G_1) = 0.6, \\text{is\\_unstable} = \\text{False}, \\text{is\\_diagonalizable} = \\text{True}] $。\n\n**用例 2:** $ A_2 = \\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\end{bmatrix} $, $ \\Delta t_2 = 0.6 $。\n- 放大矩阵为 $ G_2 = I + 0.6 A_2 = \\begin{bmatrix} 1 & 0.6 \\\\ 0.6 & 1 \\end{bmatrix} $。\n- 特征方程为 $ \\det(G_2 - \\lambda I) = (1-\\lambda)^2 - 0.6^2 = 0 $，得到特征值 $ \\lambda = 1 \\pm 0.6 $。因此，$ \\lambda_1 = 1.6 $ 和 $ \\lambda_2 = 0.4 $。\n- 谱半径为 $ \\rho(G_2) = \\max(|1.6|, |0.4|) = 1.6 $。\n- 由于 $ 1.6 \\ge 1 + \\varepsilon $，格式为“不稳定”(unstable)。\n- $G_2$ 是一个实对称矩阵，这保证了它在 $ \\mathbb{R} $ 上可对角化，因此在 $ \\mathbb{C} $ 上也可对角化。\n- 结果: $ [\\rho(G_2) = 1.6, \\text{is\\_unstable} = \\text{True}, \\text{is\\_diagonalizable} = \\text{True}] $。\n\n**用例 3:** $ A_3 = \\begin{bmatrix} 0 & 1 \\\\ 0 & 0 \\end{bmatrix} $, $ \\Delta t_3 = 0.5 $。\n- 放大矩阵为 $ G_3 = I + 0.5 A_3 = \\begin{bmatrix} 1 & 0.5 \\\\ 0 & 1 \\end{bmatrix} $。\n- 该矩阵是上三角矩阵，因此其特征值是其对角线元素：$ \\lambda_1 = \\lambda_2 = 1 $。\n- 谱半径为 $ \\rho(G_3) = |1| = 1.0 $。\n- 现在我们评估其可对角化性。对于 $ \\lambda=1 $ 的特征空间是 $ G_3 - 1I = \\begin{bmatrix} 0 & 0.5 \\\\ 0 & 0 \\end{bmatrix} $ 的零空间。方程 $ (G_3 - I)\\mathbf{v} = \\mathbf{0} $ 要求 $ 0.5 v_2 = 0 $。这意味着特征空间由单个向量 $ [1, 0]^T $ 张成。几何重数（$1$）小于代数重数（$2$），因此矩阵 $ G_3 $ 不可对角化。\n- 根据准则，由于 $ \\rho(G_3) = 1 $ 且 $ G_3 $ 不可对角化，格式为“不稳定”(unstable)。\n- 结果: $ [\\rho(G_3) = 1.0, \\text{is\\_unstable} = \\text{True}, \\text{is\\_diagonalizable} = \\text{False}] $。\n\n**用例 4:** $ A_4 = \\begin{bmatrix} -4 & 0 \\\\ 0 & 0 \\end{bmatrix} $, $ \\Delta t_4 = 0.5 $。\n- 放大矩阵为 $ G_4 = I + 0.5 A_4 = \\begin{bmatrix} 1+0.5(-4) & 0 \\\\ 0 & 1+0.5(0) \\end{bmatrix} = \\begin{bmatrix} -1 & 0 \\\\ 0 & 1 \\end{bmatrix} $。\n- 特征值为 $ \\lambda_1 = -1 $ 和 $ \\lambda_2 = 1 $。\n- 谱半径为 $ \\rho(G_4) = \\max(|-1|, |1|) = 1.0 $。\n- $G_4$ 是一个对角矩阵，因此是可对角化的。\n- 由于 $ \\rho(G_4) = 1 $ 且 $ G_4 $ 可对角化，格式为“非不稳定”(not unstable)。\n- 结果: $ [\\rho(G_4) = 1.0, \\text{is\\_unstable} = \\text{False}, \\text{is\\_diagonalizable} = \\text{True}] $。\n\n结果是基于这些推导通过算法计算得出的。", "answer": "```python\nimport numpy as np\n\ndef analyze_stability(A, dt, epsilon):\n    \"\"\"\n    Analyzes the stability of the forward Euler scheme for a given matrix A and time step dt.\n\n    Args:\n        A (np.ndarray): The matrix from the ODE system.\n        dt (float): The time step size.\n        epsilon (float): The tolerance for floating-point comparisons.\n\n    Returns:\n        list: A list containing [rho(G), is_unstable, is_diagonalizable].\n    \"\"\"\n    n = A.shape[0]\n    I = np.identity(n)\n    G = I + dt * A\n\n    # (i) Compute eigenvalues of G and its spectral radius\n    eigenvalues_G = np.linalg.eigvals(G)\n    rho_G = np.max(np.abs(eigenvalues_G))\n\n    # (iii) Check diagonalizability of G\n    # A matrix is diagonalizable if and only if it has a full set of n linearly independent eigenvectors.\n    # We compute the eigenvector matrix V and check its rank.\n    # The rank is determined by counting singular values greater than the tolerance.\n    _, V = np.linalg.eig(G)\n    singular_values = np.linalg.svd(V, compute_uv=False)\n    rank_V = np.sum(singular_values > epsilon)\n    is_diagonalizable = (rank_V == n)\n\n    # (ii) Determine instability based on the given criteria\n    is_unstable = False\n    if rho_G >= 1 + epsilon:\n        is_unstable = True\n    elif np.abs(rho_G - 1) <= epsilon:\n        if not is_diagonalizable:\n            is_unstable = True\n    # Otherwise, rho_G is <= 1 - epsilon, for which the scheme is \"not unstable\".\n\n    return [rho_G, is_unstable, is_diagonalizable]\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the results.\n    \"\"\"\n    epsilon = 1e-10\n\n    # Test cases defined in the problem statement\n    test_cases = [\n        (np.array([[-2.0, 0.0], [0.0, -5.0]]), 0.2), # Case 1\n        (np.array([[0.0, 1.0], [1.0, 0.0]]), 0.6),   # Case 2\n        (np.array([[0.0, 1.0], [0.0, 0.0]]), 0.5),   # Case 3\n        (np.array([[-4.0, 0.0], [0.0, 0.0]]), 0.5),   # Case 4\n    ]\n\n    results = []\n    for A, dt in test_cases:\n        result = analyze_stability(A, dt, epsilon)\n        results.append(result)\n\n    # Format the output string as required by the problem.\n    # e.g., [[rho1,False,True],[rho2,True,True]]\n    # Python's str() for booleans produces capitalized True/False, which matches the example.\n    # The list-to-string conversion with f-strings and join creates the exact format.\n    inner_lists_str = [f\"[{res[0]},{res[1]},{res[2]}]\" for res in results]\n    final_output_str = f\"[{','.join(inner_lists_str)}]\"\n\n    print(final_output_str)\n\nsolve()\n```", "id": "2442744"}, {"introduction": "在许多工程领域，尤其是在结构动力学中，我们需要处理更复杂的广义特征值问题 $K v = \\lambda M v$。这个实践将引导你设计一个“谱滤波器”，通过在由质量矩阵 $M$ 定义的内积空间中进行投影，来移除一个模拟机械结构中的特定振动模式。这项任务不仅让你接触到广义特征值问题，还能加深你对谱分解如何用于主动控制和修改系统动态响应的理解。[@problem_id:2442802]", "problem": "一个有限维、无阻尼的机械系统，其质量矩阵$M \\in \\mathbb{R}^{n \\times n}$为对称正定（SPD）矩阵，刚度矩阵为$K \\in \\mathbb{R}^{n \\times n}$。该系统的微小自由振动由以下代数广义特征值问题决定：找到非零向量$v \\in \\mathbb{R}^{n}$和标量$\\lambda \\in \\mathbb{R}$，使得$K v = \\lambda M v$。在计算工程中，振动模态是该问题的特征向量，并且可以使用一个由特征向量构成的$M$-正交归一基进行谱分解。\n\n您的任务是设计一个谱滤波器，该滤波器仅使用线性代数的基本定义，通过在$M$-内积下进行投影来移除一个预设的振动模态子集：\n\n- 向量$x,y \\in \\mathbb{R}^{n}$的$M$-内积为$\\langle x, y \\rangle_{M} = x^{\\mathsf{T}} M y$。\n- 一组特征向量$\\{v_{i}\\}_{i=1}^{n}$可以被选择为$M$-正交归一的，使得$v_{i}^{\\mathsf{T}} M v_{j} = \\delta_{ij}$，其中$\\delta_{ij}$是克罗内克（Kronecker）δ函数。\n- 针对某个内积，到一个子空间的投影算子是线性的、幂等的（即$P^{2} = P$），并且保持目标子空间中的向量不变，同时将其正交补（根据该内积定义）中的向量湮没。\n\n从这些定义出发（并且不引入任何未经证明的快捷公式），推导出一个线性算子，它充当谱滤波器，移除一个向量沿着选定特征向量子集（相对于$M$-内积）的分量，并保持在该子集的$M$-正交补中的分量不变。然后，通过计算广义特征分解、选择适当的特征向量并应用您推导的投影，以算法形式实现它。\n\n使用以下具体的无量纲矩阵和数据，以实现一个完全指定且可测试的实现：\n\n- 维度$n = 4$。\n- 质量矩阵\n$$\nM = \\begin{bmatrix}\n2 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 1.5 & 0 \\\\\n0 & 0 & 0 & 1.2\n\\end{bmatrix}.\n$$\n- 刚度矩阵\n$$\nK = \\begin{bmatrix}\n2 & -1 & 0 & 0 \\\\\n-1 & 2 & -1 & 0 \\\\\n0 & -1 & 2 & -1 \\\\\n0 & 0 & -1 & 2\n\\end{bmatrix}.\n$$\n- 设广义特征对$(\\lambda_{i}, v_{i})$按特征值$\\lambda_{i}$升序排列，索引$i \\in \\{0,1,2,3\\}$。确保您的特征向量经过缩放，使得对所有$i$都有$v_{i}^{\\mathsf{T}} M v_{i} = 1$，且当$i \\neq j$时有$v_{i}^{\\mathsf{T}} M v_{j} = 0$。\n\n对于下面的每个测试用例，您必须：\n- 构建一个谱滤波器，移除由索引集$S$指示的模态集。\n- 将该滤波器应用于给定的输入向量$u$，以获得滤波后的向量$\\hat{u}$。\n- 计算所要求的标量诊断值。\n\n测试套件（涵盖一个典型情况、混合模态移除和两个边界情况）：\n\n- 测试用例1：$u = \\begin{bmatrix}1 \\\\ 0 \\\\ 0 \\\\ 0\\end{bmatrix}$, $S = \\{0\\}$。输出标量\n$$\nr_{1} = \\max_{i \\in S} \\left| \\alpha_{i} \\right|, \\quad \\text{其中 } \\alpha = V^{\\mathsf{T}} M \\hat{u} \\text{ 是滤波后的模态坐标，且 } V = [v_{0}\\ v_{1}\\ v_{2}\\ v_{3}]。\n$$\n- 测试用例2：$u = \\begin{bmatrix}1 \\\\ 2 \\\\ -1 \\\\ 0.5\\end{bmatrix}$, $S = \\{0,2\\}$。输出标量\n$$\nr_{2} = \\max_{i \\in S} \\left| \\alpha_{i} \\right| \\text{，计算方式同上}。\n$$\n- 测试用例3（边界情况：不移除任何模态）：$u = \\begin{bmatrix}-0.2 \\\\ 0.4 \\\\ 0.6 \\\\ -0.8\\end{bmatrix}$, $S = \\varnothing$。输出标量\n$$\nr_{3} = \\left\\| \\hat{u} - u \\right\\|_{2}。\n$$\n- 测试用例4（边界情况：移除所有模态）：$u = \\begin{bmatrix}3 \\\\ -1 \\\\ 0.5 \\\\ 2\\end{bmatrix}$, $S = \\{0,1,2,3\\}$。输出标量\n$$\nr_{4} = \\left\\| \\hat{u} \\right\\|_{2}。\n$$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_{1},r_{2},r_{3},r_{4}]$）。所有计算都是无量纲的；不需要报告物理单位。$r_{1}$、$r_{2}$、$r_{3}$和$r_{4}$的最终数值必须是您的程序计算出的浮点数。设计必须是通用的，并严格基于上述基本原理和定义，而不是本说明中任何预先提供的投影公式。", "solution": "我们已对问题陈述进行了严格评估，并认为其是有效的。该问题具有科学依据，提法恰当，并包含了获得唯一且有意义解所需的所有必要信息。我们将着手进行推导和实现。\n\n基本背景是一个有限维向量空间$\\mathbb{R}^n$，它配备了一个由对称正定（SPD）质量矩阵$M$定义的内积。这就是$M$-内积，对于任意向量$x,y \\in \\mathbb{R}^n$，$M$-内积由$\\langle x, y \\rangle_M = x^{\\mathsf{T}} M y$给出。\n\n对于对称矩阵$K$和SPD矩阵$M$的广义特征值问题$K v = \\lambda M v$，其保证了存在$n$个实特征值$\\lambda_i$和一组对应的特征向量$\\{v_i\\}_{i=0}^{n-1}$。这些特征向量可以被选择构成$\\mathbb{R}^n$的一个$M$-正交归一基。这意味着它们满足条件$\\langle v_i, v_j \\rangle_M = v_i^{\\mathsf{T}} M v_j = \\delta_{ij}$，其中$\\delta_{ij}$是克罗内克δ函数。\n\n任何向量$u \\in \\mathbb{R}^n$都可以唯一地表示为这些基向量的线性组合：\n$$\nu = \\sum_{i=0}^{n-1} \\alpha_i v_i\n$$\n这些系数$\\alpha_i$被称为$u$的模态坐标，它们是通过使用$M$-内积将$u$投影到每个基向量上来确定的。将上述方程与一个基向量$v_j$取$M$-内积：\n$$\n\\langle u, v_j \\rangle_M = \\left\\langle \\sum_{i=0}^{n-1} \\alpha_i v_i, v_j \\right\\rangle_M\n$$\n根据内积的线性性质，这变为：\n$$\n\\langle u, v_j \\rangle_M = \\sum_{i=0}^{n-1} \\alpha_i \\langle v_i, v_j \\rangle_M = \\sum_{i=0}^{n-1} \\alpha_i \\delta_{ij} = \\alpha_j\n$$\n因此，第$j$个模态坐标为$\\alpha_j = \\langle u, v_j \\rangle_M = u^{\\mathsf{T}} M v_j$。\n\n任务是设计一个谱滤波器，用以移除向量$u$中对应于一个由索引集$S$指定的预设模态集的分量。设$V_S$是由待移除的特征向量$\\{v_i\\}_{i \\in S}$张成的子空间，设$V_{S^\\perp}$是其$M$-正交补，由待保留的特征向量$\\{v_j\\}_{j \\notin S}$张成。\n$$\nV_S = \\text{span}\\{v_i \\mid i \\in S\\}\n$$\n$$\nV_{S^\\perp} = \\text{span}\\{v_j \\mid j \\notin S\\}\n$$\n空间$\\mathbb{R}^n$是这两个子空间的直和，即$\\mathbb{R}^n = V_S \\oplus V_{S^\\perp}$。因此，任何向量$u$都可以唯一地分解为$u = u_S + u_{S^\\perp}$，其中$u_S \\in V_S$且$u_{S^\\perp} \\in V_{S^\\perp}$。根据模态展开，这些分量是：\n$$\nu_S = \\sum_{i \\in S} \\alpha_i v_i \\quad \\text{和} \\quad u_{S^\\perp} = \\sum_{j \\notin S} \\alpha_j v_j\n$$\n问题要求滤波器“移除”$V_S$中的分量并“保持不变”$V_{S^\\perp}$中的分量。这正是关于$M$-内积在子空间$V_{S^\\perp}$上的投影的精确定义。我们将这个投影算子记为$P$。因此，滤波后的向量$\\hat{u}$由$\\hat{u} = P(u)$给出。\n\n根据定义，$u$在$V_{S^\\perp}$上的投影是向量$\\hat{u} \\in V_{S^\\perp}$，使得误差向量$u - \\hat{u}$与$V_{S^\\perp}$中的每个向量$M$-正交。\n因为$\\hat{u} \\in V_{S^\\perp}$，它可以展开为$\\hat{u} = \\sum_{j \\notin S} \\beta_j v_j$的形式，其中$\\beta_j$为某些系数。\n正交条件是$\\langle u - \\hat{u}, v_k \\rangle_M = 0$对所有$k \\notin S$成立。\n代入$u$和$\\hat{u}$的展开式：\n$$\n\\left\\langle \\sum_{i=0}^{n-1} \\alpha_i v_i - \\sum_{j \\notin S} \\beta_j v_j, v_k \\right\\rangle_M = 0 \\quad \\text{对于 } k \\notin S\n$$\n利用线性和$M$-正交归一性：\n$$\n\\alpha_k - \\beta_k = 0 \\implies \\beta_k = \\alpha_k \\quad \\text{对于所有 } k \\notin S\n$$\n这表明投影向量在基$\\{v_j\\}_{j \\notin S}$中的系数就是原始的模态坐标$\\alpha_j$。因此，滤波后的向量是：\n$$\n\\hat{u} = \\sum_{j \\notin S} \\alpha_j v_j\n$$\n为了构造算子$P$使得$\\hat{u} = P u$，我们代入$\\alpha_j$的表达式：\n$$\n\\hat{u} = \\sum_{j \\notin S} (v_j^{\\mathsf{T}} M u) v_j = \\sum_{j \\notin S} v_j (v_j^{\\mathsf{T}} M u) = \\left( \\sum_{j \\notin S} v_j v_j^{\\mathsf{T}} M \\right) u\n$$\n因此，谱滤波算子的显式矩阵形式为：\n$$\nP = \\sum_{j \\notin S} v_j v_j^{\\mathsf{T}} M\n$$\n该算子是线性的、幂等的（$P^2=P$），并将任何向量投影到子空间$V_{S^\\perp}$上，其方向沿着它的$M$-正交补$V_S$，这符合要求。\n\n在算法上，构造并应用矩阵$P$的效率不高。一个更直接的步骤是：\n1.  求解广义特征值问题$K v = \\lambda M v$，找到特征值$\\lambda_i$和$M$-正交归一的特征向量矩阵$V = [v_0, v_1, \\dots, v_{n-1}]$。\n2.  对于给定的输入向量$u$，计算其完整的模态坐标向量：$\\alpha = V^{\\mathsf{T}} M u$。\n3.  通过将要移除的模态所对应的坐标设置为零来构造滤波后的模态坐标向量$\\hat{\\alpha}$：如果$i \\in S$，则$\\hat{\\alpha}_i = 0$；如果$i \\notin S$，则$\\hat{\\alpha}_i = \\alpha_i$。\n4.  通过乘以特征向量矩阵，在原始基中重构滤波后的向量：$\\hat{u} = V \\hat{\\alpha}$。\n\n将此逻辑应用于具体的测试用例：\n- 对于测试用例1和2，我们对向量$u$进行滤波得到$\\hat{u}$。诊断值为$r = \\max_{i \\in S} |(V^{\\mathsf{T}} M \\hat{u})_i|$。由于$V^{\\mathsf{T}} M \\hat{u} = V^{\\mathsf{T}} M (V \\hat{\\alpha}) = (V^{\\mathsf{T}} M V) \\hat{\\alpha} = I \\hat{\\alpha} = \\hat{\\alpha}$，并且我们已明确设置对所有$i \\in S$都有$\\hat{\\alpha}_i = 0$，因此诊断值必须为$0$。\n- 对于测试用例3，$S = \\varnothing$。没有模态被移除。算子$P$是单位算子，所以$\\hat{u} = u$。因此，诊断值$r_3 = \\|\\hat{u} - u\\|_2$必须为$0$。\n- 对于测试用例4，$S = \\{0, 1, 2, 3\\}$。所有模态都被移除。算子$P$是零算子，所以$\\hat{u} = 0$。因此，诊断值$r_4 = \\|\\hat{u}\\|_2$必须为$0$。\n\n实现将验证这些理论推论。数值结果应为零，或由于浮点运算而处于机器精度量级的值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Solves the spectral filtering problem by deriving and applying a projection operator.\n    \"\"\"\n    # Define problem parameters for n=4 as specified.\n    M = np.array([\n        [2.0, 0.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0, 0.0],\n        [0.0, 0.0, 1.5, 0.0],\n        [0.0, 0.0, 0.0, 1.2]\n    ])\n\n    K = np.array([\n        [2.0, -1.0, 0.0, 0.0],\n        [-1.0, 2.0, -1.0, 0.0],\n        [0.0, -1.0, 2.0, -1.0],\n        [0.0, 0.0, -1.0, 2.0]\n    ])\n\n    # Define the test suite.\n    test_cases = [\n        {'u': np.array([1.0, 0.0, 0.0, 0.0]), 'S': {0}},\n        {'u': np.array([1.0, 2.0, -1.0, 0.5]), 'S': {0, 2}},\n        {'u': np.array([-0.2, 0.4, 0.6, -0.8]), 'S': set()},\n        {'u': np.array([3.0, -1.0, 0.5, 2.0]), 'S': {0, 1, 2, 3}},\n    ]\n\n    # Step 1: Solve the generalized eigenvalue problem Kv = lambda*M*v.\n    # eigh returns eigenvalues in ascending order and M-orthonormal eigenvectors.\n    # That is, for eigenvectors V, the condition V.T @ M @ V = I holds.\n    eigenvalues, V = eigh(K, b=M)\n    \n    results = []\n\n    for i, case in enumerate(test_cases):\n        u = case['u']\n        S = case['S']\n        \n        # Step 2: Compute the full vector of modal coordinates.\n        alpha = V.T @ M @ u\n        \n        # Step 3: Filter by setting modal coordinates in S to zero.\n        alpha_hat = alpha.copy()\n        if S: # If S is not empty\n            indices_to_remove = list(S)\n            alpha_hat[indices_to_remove] = 0.0\n            \n        # Step 4: Reconstruct the filtered vector.\n        u_hat = V @ alpha_hat\n\n        # Compute the requested scalar diagnostic for each test case.\n        if i == 0 or i == 1: # Test cases 1 and 2\n            # Diagnostic: max(|alpha_i|) for i in S, where alpha are modal coordinates of u_hat.\n            # As derived, modal coordinates of u_hat are alpha_hat.\n            alpha_post_filter = V.T @ M @ u_hat\n            indices_to_check = list(S)\n            result = np.max(np.abs(alpha_post_filter[indices_to_check]))\n            results.append(result)\n\n        elif i == 2: # Test case 3\n            # Diagnostic: ||u_hat - u||_2\n            result = np.linalg.norm(u_hat - u)\n            results.append(result)\n            \n        elif i == 3: # Test case 4\n            # Diagnostic: ||u_hat||_2\n            result = np.linalg.norm(u_hat)\n            results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2442802"}]}