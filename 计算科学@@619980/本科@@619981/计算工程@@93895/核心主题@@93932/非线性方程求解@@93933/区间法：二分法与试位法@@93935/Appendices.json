{"hands_on_practices": [{"introduction": "我们首先将区间法的知识应用于一个源自光学的实际问题。这个练习要求你找到两种不同材料具有相同折射率的特定波长，这是设计消色差光学元件中的一项关键任务。通过将这一物理情景构建为一个求根问题 $f(\\lambda) = n_1(\\lambda) - n_2(\\lambda)=0$，你将获得使用数值方法解决真实世界工程挑战的实践经验。[@problem_id:2375454]", "problem": "一个单变量连续标量函数被定义为两个折射率色散定律之差，每个定律均由一个三项 Cauchy 模型给出。对于一种系数为 $A$、$B$ 和 $C$ 的材料，当真空波长 $\\lambda$ 以微米为单位时，其折射率由以下模型描述：\n$$\nn(\\lambda) \\;=\\; A \\;+\\; \\frac{B}{\\lambda^{2}} \\;+\\; \\frac{C}{\\lambda^{4}} \\quad \\text{for} \\quad \\lambda > 0.\n$$\n对于下方的每个测试用例，请使用指定的材料和系数对来定义 $f(\\lambda) \\;=\\; n_{1}(\\lambda) \\;-\\; n_{2}(\\lambda)$。对于每个给定的闭区间 $[\\lambda_{L}, \\lambda_{R}]$ 和绝对公差 $\\tau$，请确定一个值 $\\lambda^{\\ast} \\in [\\lambda_{L}, \\lambda_{R}]$，使得 $f(\\lambda^{\\ast}) = 0$，并且波长变量的绝对误差最多为 $\\tau$。此处的假设是：函数 $f$ 在 $[\\lambda_{L}, \\lambda_{R}]$ 上连续，且每种情况下解都存在。\n\n使用 Cauchy 模型及以下物理上合理的系数集（所有波长单位均为微米）：\n- 材料 $M_{A}$：$A = 1.42$，$B = 0.01$，$C = 0.0004$。\n- 材料 $M_{B}$：$A = 1.46$，$B = 0.002$，$C = 0.00005$。\n- 材料 $M_{C}$：$A = 1.38$，$B = 0.03$，$C = 0.001$。\n- 材料 $M_{D}$：$A = 1.45$，$B = 0.005$，$C = 0.00015$。\n\n测试套件：\n1. $f(\\lambda) = n_{A}(\\lambda) - n_{B}(\\lambda)$，区间为 $[\\lambda_{L}, \\lambda_{R}] = [0.45, 0.50]$，$\\tau = 1.0 \\times 10^{-12}$。\n2. $f(\\lambda) = n_{A}(\\lambda) - n_{B}(\\lambda)$，区间为 $[\\lambda_{L}, \\lambda_{R}] = [0.486, 0.49]$，$\\tau = 1.0 \\times 10^{-12}$。\n3. $f(\\lambda) = n_{C}(\\lambda) - n_{D}(\\lambda)$，区间为 $[\\lambda_{L}, \\lambda_{R}] = [0.60, 0.65]$，$\\tau = 1.0 \\times 10^{-12}$。\n4. $f(\\lambda) = n_{C}(\\lambda) - n_{D}(\\lambda)$，区间为 $[\\lambda_{L}, \\lambda_{R}] = [0.40, 1.00]$，$\\tau = 1.0 \\times 10^{-12}$。\n\n将每个波长以微米表示，并四舍五入到 $12$ 位小数。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔结果列表（例如 $[x_{1},x_{2},x_{3},x_{4}]$），列表中的每个 $x_{k}$ 是测试用例 $k$ 计算出的 $\\lambda^{\\ast}$ 值。", "solution": "该问题要求在指定的区间 $[\\lambda_{L}, \\lambda_{R}]$ 内、绝对误差容限为 $\\tau$ 的条件下，为函数 $f(\\lambda) = n_{1}(\\lambda) - n_{2}(\\lambda) = 0$ 寻找一个根 $\\lambda^{\\ast}$。每种材料的折射率 $n(\\lambda)$ 由三项 Cauchy 模型给出：\n$$\nn(\\lambda) \\;=\\; A \\;+\\; \\frac{B}{\\lambda^{2}} \\;+\\; \\frac{C}{\\lambda^{4}}\n$$\n其中 $\\lambda$ 是以微米为单位的真空波长。因此，待求解的函数为：\n$$\nf(\\lambda) \\;=\\; (A_{1} - A_{2}) \\;+\\; (B_{1} - B_{2})\\lambda^{-2} \\;+\\; (C_{1} - C_{2})\\lambda^{-4} \\;=\\; 0\n$$\n这是一个针对闭区间上连续函数的标准求根问题。问题陈述保证了在每个给定的区间内解都存在且函数是连续的。鉴于这些条件，并注意到该问题是在计算方法的背景下提出的，二分法 (Bisection Method) 是完成此项任务的一个合适且稳健的算法。如果函数在区间端点的值异号，则其收敛性可以得到保证。\n\n我们来定义待分析的两个函数的系数：\n对于测试用例 1 和 2，$f(\\lambda) = n_{A}(\\lambda) - n_{B}(\\lambda)$。其系数为：\n- $A_A = 1.42$，$B_A = 0.01$，$C_A = 0.0004$。\n- $A_B = 1.46$，$B_B = 0.002$，$C_B = 0.00005$。\n得到的函数为：\n$$\nf_{A-B}(\\lambda) \\;=\\; (1.42 - 1.46) + (0.01 - 0.002)\\lambda^{-2} + (0.0004 - 0.00005)\\lambda^{-4}\n$$\n$$\nf_{A-B}(\\lambda) \\;=\\; -0.04 \\;+\\; 0.008\\lambda^{-2} \\;+\\; 0.00035\\lambda^{-4}\n$$\n对于测试用例 3 和 4，$f(\\lambda) = n_{C}(\\lambda) - n_{D}(\\lambda)$。其系数为：\n- $A_C = 1.38$，$B_C = 0.03$，$C_C = 0.001$。\n- $A_D = 1.45$，$B_D = 0.005$，$C_D = 0.00015$。\n得到的函数为：\n$$\nf_{C-D}(\\lambda) \\;=\\; (1.38 - 1.45) + (0.03 - 0.005)\\lambda^{-2} + (0.001 - 0.00015)\\lambda^{-4}\n$$\n$$\nf_{C-D}(\\lambda) \\;=\\; -0.07 \\;+\\; 0.025\\lambda^{-2} \\;+\\; 0.00085\\lambda^{-4}\n$$\n\n二分法算法按以下步骤进行：\n$1$. 从区间 $[a, b]$ 开始，其中 $a = \\lambda_L$ 且 $b = \\lambda_R$。验证 $f(a)$ 和 $f(b)$ 异号，即 $f(a)f(b)  0$。这个条件是介值定理 (Intermediate Value Theorem) 的一个推论，它保证了在 $(a, b)$ 内至少存在一个根。所有提供的测试用例都满足此要求。\n$2$. 计算区间的中点：$c = a + (b-a)/2$。\n$3$. 计算函数在中点处的值 $f(c)$。\n$4$. 真实根 $\\lambda^{\\ast}$ 保证位于区间 $[a, b]$ 内。中点 $c$ 是 $\\lambda^{\\ast}$ 的一个近似值，其绝对误差不大于区间宽度的一半：$|\\lambda^{\\ast} - c| \\le (b-a)/2$。当此误差界限小于或等于指定的公差 $\\tau$ 时，满足终止条件。因此，只要 $(b-a)/2 > \\tau$，迭代过程就会继续。\n$5$. 若过程尚未终止，则更新区间。如果 $f(a)f(c)  0$，根位于区间的左半部分，因此新区间变为 $[a, c]$。否则，根必在右半部分，新区间变为 $[c, b]$。\n$6$. 使用新的、更小的区间，从步骤 2 开始重复。\n\n终止时，最终区间的中点即为所求的解 $\\lambda^{\\ast}$。该过程将被实现，并应用于四个测试用例，每个用例都使用其各自的函数、区间 $[\\lambda_{L}, \\lambda_{R}]$ 和指定的公差 $\\tau = 1.0 \\times 10^{-12}$。最终结果将以微米表示，并四舍五入到 $12$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the root of f(lambda) = n1(lambda) - n2(lambda) = 0\n    using the bisection method for the given test cases.\n    \"\"\"\n    \n    # Material coefficients as per the problem statement.\n    # A (dimensionless), B (um^2), C (um^4)\n    materials = {\n        'M_A': (1.42, 0.01, 0.0004),\n        'M_B': (1.46, 0.002, 0.00005),\n        'M_C': (1.38, 0.03, 0.001),\n        'M_D': (1.45, 0.005, 0.00015),\n    }\n\n    # Define the test cases.\n    # Each case: (Material 1 name, Material 2 name, lambda_L, lambda_R, tolerance)\n    test_cases = [\n        ('M_A', 'M_B', 0.45, 0.50, 1.0e-12),\n        ('M_A', 'M_B', 0.486, 0.49, 1.0e-12),\n        ('M_C', 'M_D', 0.60, 0.65, 1.0e-12),\n        ('M_C', 'M_D', 0.40, 1.00, 1.0e-12),\n    ]\n\n    def bisection(func, a, b, tol):\n        \"\"\"\n        Implementation of the bisection method for root finding.\n\n        Args:\n            func: The function for which to find a root.\n            a: The left endpoint of the interval.\n            b: The right endpoint of the interval.\n            tol: The desired absolute error tolerance for the root.\n\n        Returns:\n            The estimated root of the function.\n        \"\"\"\n        fa = func(a)\n        fb = func(b)\n\n        if fa * fb >= 0:\n            # This should not happen for the given problem as a solution is assumed to exist.\n            raise ValueError(\"Bisection method requires function to have opposite signs at interval endpoints.\")\n\n        # The loop condition ensures the final midpoint has an error = tol.\n        # c = (a+b)/2, error is |c - root| = (b-a)/2. We need (b-a)/2 = tol.\n        while (b - a) / 2.0 > tol:\n            c = a + (b - a) / 2.0  # Use this form to avoid potential floating point overflow\n            fc = func(c)\n            \n            if fc == 0.0:\n                # Found the exact root\n                return c\n            \n            if fa * fc  0:\n                b = c\n                fb = fc # Not strictly necessary, but can be a micro-optimization\n            else:\n                a = c\n                fa = fc # Same as above\n\n        # Return the midpoint of the final interval\n        return a + (b - a) / 2.0\n\n    results = []\n    for case in test_cases:\n        mat1_name, mat2_name, lambda_L, lambda_R, tolerance = case\n        \n        A1, B1, C1 = materials[mat1_name]\n        A2, B2, C2 = materials[mat2_name]\n        \n        # Define the function f(lambda) = n1(lambda) - n2(lambda)\n        # f(x) = (A1-A2) + (B1-B2)/x^2 + (C1-C2)/x^4\n        def f(lam):\n            lam_sq = lam * lam\n            lam_q = lam_sq * lam_sq\n            return (A1 - A2) + (B1 - B2) / lam_sq + (C1 - C2) / lam_q\n\n        # Find the root using the bisection method\n        root = bisection(f, lambda_L, lambda_R, tolerance)\n        \n        # Format the result to 12 decimal places and append\n        results.append(f\"{root:.12f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "2375454"}, {"introduction": "虽然试位法通常比二分法收敛得更快，但它并非没有缺陷。这个分析性练习将探讨一个经典场景，在该场景下，试位法的性能会显著下降——一个函数在其根部的导数无穷大的情况。通过分析这种情况，你将理解“停滞”或单侧收敛的概念，并体会为何二分法稳健、可预测的特性有时更具优势。[@problem_id:2375443]", "problem": "在区间求根的背景下，考虑将错位法（regula falsi）应用于连续、严格递增的函数 $f(x)=\\sqrt[3]{x-x_{\\star}}$。该函数在 $x=x_{\\star}$ 处有一个单根，但该点的斜率是无穷的，意即当 $x\\to x_{\\star}$ 时，$f^{\\prime}(x)$ 是无界的。设初始区间为 $[a,b]=[x_{\\star}-s_{L},\\,x_{\\star}+s_{R}]$，其中 $s_{L}>0$ 且 $s_{R}>0$，使得 $f(a)f(b)0$。假设二分法和错位法都采用标准实现。\n\n下列哪个陈述是正确的？\n\nA. 对于特定函数 $f(x)=\\sqrt[3]{x}$ 和对称的初始区间 $[-s,s]$（其中 $s>0$），第一个错位法迭代点等于精确根 $x=0$。\n\nB. 如果初始区间是不对称的，且 $s_{L}\\ll s_{R}$，那么对于 $f(x)=\\sqrt[3]{x-x_{\\star}}$，错位法将在多次迭代中重复替换右端点而保持左端点不变，导致向 $x_{\\star}$ 的收敛非常缓慢，而二分法在每次迭代中都将区间长度减半，无论 $f^{\\prime}(x_{\\star})$ 的行为如何。\n\nC. 错位法不能应用于 $f(x)=\\sqrt[3]{x-x_{\\star}}$，因为 $f^{\\prime}(x_{\\star})$ 是无穷大，并且割线构造会失效。\n\nD. 在一个 $\\lvert f^{\\prime}(x_{\\star})\\rvert$ 无界的根附近，错位法会变为超线性收敛，并且通常表现优于二分法。\n\nE. 对于任何满足 $f(a)f(b)0$ 的有效区间 $[a,b]$，标准的错位法必然会无限次地替换两个端点；它不可能在多次迭代中保持一个端点固定。", "solution": "该问题陈述科学严谨、定义明确且客观。它涉及将标准的数值方法，即二分法和错位法，应用于一个明确定义的函数 $f(x)=\\sqrt[3]{x-x_{\\star}}$。这个函数是用于分析求根算法收敛性质的经典例子，特别是在涉及根处导数为无穷大的情况下。该问题是有效的，并且可以解决。\n\n错位法（regula falsi）通过找到连接点 $(a_k, f(a_k))$ 和 $(b_k, f(b_k))$ 的割线与x轴的交点，来计算区间 $[a_k, b_k]$ 中根的下一个近似值 $c_{k+1}$。其公式为：\n$$c_{k+1} = \\frac{a_k f(b_k) - b_k f(a_k)}{f(b_k) - f(a_k)}$$\n给定函数为 $f(x) = \\sqrt[3]{x-x_{\\star}}$。该函数是连续且严格递增的。它的一阶导数为 $f^{\\prime}(x) = \\frac{1}{3}(x-x_{\\star})^{-2/3}$，当 $x \\to x_{\\star}$ 时，该导数是无界的。二阶导数为 $f^{\\prime\\prime}(x) = -\\frac{2}{9}(x-x_{\\star})^{-5/3}$。\n二阶导数的符号决定了函数的凹凸性：\n- 当 $x > x_{\\star}$ 时，有 $x-x_{\\star} > 0$，所以 $(x-x_{\\star})^{-5/3} > 0$。因此 $f^{\\prime\\prime}(x)  0$，函数是下凹的。\n- 当 $x  x_{\\star}$ 时，有 $x-x_{\\star}  0$，所以 $(x-x_{\\star})^{-5/3}  0$。因此 $f^{\\prime\\prime}(x) > 0$，函数是上凹的。\n\n对每个选项的分析如下。\n\nA. 对于特定函数 $f(x)=\\sqrt[3]{x}$ 和对称的初始区间 $[-s,s]$（其中 $s>0$），第一个错位法迭代点等于精确根 $x=0$。\n\n我们已知 $f(x) = \\sqrt[3]{x}$，这意味着根在 $x_{\\star} = 0$。初始区间为 $[a, b] = [-s, s]$，对于某个 $s>0$。\n端点处的函数值为：\n$f(a) = f(-s) = \\sqrt[3]{-s} = -s^{1/3}$\n$f(b) = f(s) = \\sqrt[3]{s} = s^{1/3}$\n我们使用错位法公式计算第一个迭代点 $c_1$：\n$$c_1 = \\frac{a f(b) - b f(a)}{f(b) - f(a)} = \\frac{(-s)(s^{1/3}) - (s)(-s^{1/3})}{s^{1/3} - (-s^{1/3})}$$\n$$c_1 = \\frac{-s \\cdot s^{1/3} + s \\cdot s^{1/3}}{2s^{1/3}} = \\frac{0}{2s^{1/3}}$$\n由于 $s>0$，分母 $2s^{1/3}$ 不为零。因此，$c_1 = 0$。\n第一个迭代点恰好是根 $x_{\\star} = 0$。\n结论：**正确**。\n\nB. 如果初始区间是不对称的，且 $s_{L}\\ll s_{R}$，那么对于 $f(x)=\\sqrt[3]{x-x_{\\star}}$，错位法将在多次迭代中重复替换右端点而保持左端点不变，导致向 $x_{\\star}$ 的收敛非常缓慢，而二分法在每次迭代中都将区间长度减半，无论 $f^{\\prime}(x_{\\star})$ 的行为如何。\n\n设初始区间为 $[a_0, b_0] = [x_{\\star}-s_{L}, x_{\\star}+s_{R}]$，其中 $s_{L} > 0$ 且 $s_{R} > 0$。\n函数值为 $f(a_0) = \\sqrt[3]{-s_L} = -s_L^{1/3}$ 和 $f(b_0) = \\sqrt[3]{s_R} = s_R^{1/3}$。\n新的迭代点 $c_1$ 位于 $x_{\\star}$ 的同一侧，这一侧是函数图像更“平坦”的一侧，即函数值的绝对值相对于其到根的距离更小。为了确定哪个端点是固定的，我们找出新迭代点 $c_1$ 相对于根 $x_{\\star}$ 的位置。\n$$c_1 - x_{\\star} = \\frac{a_0 f(b_0) - b_0 f(a_0)}{f(b_0) - f(a_0)} - x_{\\star} = \\frac{(a_0-x_{\\star}) f(b_0) - (b_0-x_{\\star}) f(a_0)}{f(b_0) - f(a_0)}$$\n代入数值：\n$$c_1 - x_{\\star} = \\frac{(-s_L)(s_R^{1/3}) - (s_R)(-s_L^{1/3})}{s_R^{1/3} - (-s_L^{1/3})} = \\frac{-s_L s_R^{1/3} + s_R s_L^{1/3}}{s_R^{1/3} + s_L^{1/3}}$$\n$$c_1 - x_{\\star} = \\frac{s_L^{1/3}s_R^{1/3}(s_R^{2/3} - s_L^{2/3})}{s_R^{1/3} + s_L^{1/3}}$$\n由于 $s_L, s_R > 0$，$(c_1 - x_{\\star})$ 的符号由 $(s_R^{2/3} - s_L^{2/3})$ 的符号决定。题目陈述 $s_L \\ll s_R$，这意味着 $s_L  s_R$，因此 $s_L^{2/3}  s_R^{2/3}$。因此，$(s_R^{2/3} - s_L^{2/3}) > 0$，这意味着 $c_1 - x_{\\star} > 0$，即 $c_1 > x_{\\star}$。\n由于 $c_1 > x_{\\star}$，我们有 $f(c_1) > 0$。新的区间必须仍然包含根，所以我们将 $c_1$ 与函数值为负的端点配对，即 $a_0$。新的区间是 $[a_1, b_1] = [a_0, c_1]$。\n左端点 $a_0$ 被保留，而右端点 $b_0$ 被 $c_1$ 替换。这个过程将会重复：下一个迭代点 $c_2$ 也将大于 $x_{\\star}$，导致新的区间为 $[a_0, c_2]$，依此类推。左端点变得“固定”，而右端点从一侧缓慢地收敛到根。这种单侧收敛是线性的，并且可能非常缓慢，特别是因为区间长度 $(c_k - a_0)$ 不会迅速缩小。\n相比之下，二分法的收敛是有保证的，每一步区间长度都减半，即 $|b_{k+1}-a_{k+1}| = \\frac{1}{2}|b_k-a_k|$。这个性质与函数的形状或其导数无关。\n结论：**正确**。\n\nC. 错位法不能应用于 $f(x)=\\sqrt[3]{x-x_{\\star}}$，因为 $f^{\\prime}(x_{\\star})$ 是无穷大，并且割线构造会失效。\n\n错位法需要在区间端点进行函数求值 $f(a)$ 和 $f(b)$。它在任何点都不使用导数 $f'(x)$。只要初始区间 $[a, b]$ 包含根（$f(a)f(b)0$）并且不包含根本身作为端点（$a, b \\neq x_{\\star}$），函数值 $f(a)$ 和 $f(b)$ 就是有限且定义明确的。由于 $f$ 是严格递增的，所以 $f(a) \\neq f(b)$，因此公式中的分母 $f(b)-f(a)$ 不为零。因此该方法是完全适用的。根处的无穷导数影响的是该方法的*收敛速度*，而不是其*适用性*。\n结论：**不正确**。\n\nD. 在一个 $\\lvert f^{\\prime}(x_{\\star})\\rvert$ 无界的根附近，错位法会变为超线性收敛，并且通常表现优于二分法。\n\n对于这个函数，这个陈述与事实恰好相反。如选项B中所分析的，$f(x)=\\sqrt[3]{x-x_{\\star}}$ 的具体特性（无界导数和在根处凹凸性改变）导致标准的错位法出现单侧收敛问题，即区间的一个端点变得固定。这将收敛速度从超线性降级为线性。此外，这个线性收敛速度可能非常慢（收敛因子接近1），使其效率远低于二分法，因为二分法具有可靠的线性收敛速度，收敛因子为0.5。这个例子函数是二分法优于标准错位法的经典案例。\n结论：**不正确**。\n\nE. 对于任何满足 $f(a)f(b)0$ 的有效区间 $[a,b]$，标准的错位法必然会无限次地替换两个端点；它不可能在多次迭代中保持一个端点固定。\n\n这是一个错误的概括。一个端点在多次（或所有）迭代中变得“固定”或静止的现象是错位法一个众所周知的弱点。这通常发生在函数在包含根的整个区间内是凸的或凹的情况下。我们对选项B的分析为给定的函数 $f(x)=\\sqrt[3]{x-x_{\\star}}$ 提供了一个直接的反例，其中一个端点保证保持固定。因此，“两个端点都必须被无限次替换”这个说法是错误的。\n结论：**不正确**。", "answer": "$$\\boxed{AB}$$", "id": "2375443"}, {"introduction": "在分析了试位法的一个关键弱点之后，我们现在转向一个建设性的解决方案。这个实践性的编程挑战要求你构建一个更稳健的混合算法，在必要时通过引入二分法步骤来降低停滞风险。这个练习体现了计算工程学的精髓，超越了简单地使用算法，而是积极地设计和改进算法，以提高其在现实世界中的可靠性。[@problem_id:2375457]", "problem": "设计并实现一个程序，该程序为每个指定的测试用例，计算一个连续标量函数 $f:\\mathbb{R}\\to\\mathbb{R}$ 在满足包围条件 $f(a)\\cdot f(b)\\le 0$ 的闭区间 $[a,b]$ 内的一个实根 $x^\\star$ 的近似值。程序必须始终保持区间的包围性质。在每次迭代中，必须按以下方式选择试探点 $c$：使用穿过 $(a,f(a))$ 和 $(b,f(b))$ 的直线与 $x$ 轴相交的唯一交点，即\n$$\nc_{\\text{rf}}=\\frac{a\\,f(b)-b\\,f(a)}{f(b)-f(a)},\n$$\n除非当 $f(a)=f(b)$ 或某个端点连续至少 $2$ 次迭代保持不变时，此时下一个试探点必须是中点\n$$\nc_{\\text{bis}}=\\frac{a+b}{2}。\n$$\n计算出 $c$ 和 $f(c)$ 后，将区间更新为 $[a,c]$ 或 $[c,b]$，以使更新后的区间继续满足 $f(a)\\cdot f(b)\\le 0$。如果 $|f(c)|\\le \\varepsilon_f$ 或 $|b-a|\\le \\varepsilon_x$，则终止并将当前的 $c$ 作为近似值返回。如果在任何时候 $|f(a)|\\le \\varepsilon_f$ 或 $|f(b)|\\le \\varepsilon_f$，则立即返回相应的端点。迭代次数不得超过给定的最大值 $N_{\\max}$。\n\n对于以下所有测试用例，使用绝对函数容差 $\\varepsilon_f=10^{-12}$，绝对区间宽度容差 $\\varepsilon_x=10^{-12}$，以及最大迭代次数 $N_{\\max}=100$。输出中的所有实数必须四舍五入到 $10$ 位小数。\n\n需要通过单次运行程序求解的测试套件：\n- 用例 $1$：$f(x)=x^3 - x - 2$，$a=1$ 且 $b=2$。\n- 用例 $2$：$f(x)=e^{-x} - x$， $a=0$ 且 $b=1$。\n- 用例 $3$：$f(x)=x^3 + 10^{-6}x - 1$， $a=0$ 且 $b=1$。\n- 用例 $4$：$f(x)=x$， $a=0$ 且 $b=3$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4]$），其中每个 $r_i$ 是用例 $i$ 的近似根，并按要求四舍五入到 $10$ 位小数。", "solution": "用户指定了求根算法的设计和实现。首先将对问题陈述的正确性和完整性进行验证。\n\n**步骤1：提取已知条件**\n\n从问题陈述中逐字提取已知条件：\n- **函数**：一个连续标量函数 $f:\\mathbb{R}\\to\\mathbb{R}$。\n- **区间**：一个闭区间 $[a,b]$，满足包围条件 $f(a)\\cdot f(b)\\le 0$。\n- **主要试探点（试位法）**：$$c_{\\text{rf}}=\\frac{a\\,f(b)-b\\,f(a)}{f(b)-f(a)}$$\n- **次要试探点（二分法）**：$$c_{\\text{bis}}=\\frac{a+b}{2}$$\n- **二分法使用条件**：当 $f(a)=f(b)$ 或“某个端点连续至少 $2$ 次迭代保持不变”时，使用二分法。\n- **区间更新规则**：计算试探点 $c$ 和函数值 $f(c)$ 后，新区间变为 $[a,c]$ 或 $[c,b]$ 中能保持包围性质的那一个。\n- **终止条件和返回值**：\n    1. 如果 $|f(c)|\\le \\varepsilon_f$，终止并返回 $c$。\n    2. 如果 $|b-a|\\le \\varepsilon_x$，终止并返回 $c$。\n    3. 如果在任何时候 $|f(a)|\\le \\varepsilon_f$ 或 $|f(b)|\\le \\varepsilon_f$，终止并分别返回 $a$ 或 $b$。\n    4. 最大迭代次数为 $N_{\\max}$。\n- **参数**：\n    - 绝对函数容差：$\\varepsilon_f=10^{-12}$。\n    - 绝对区间宽度容差：$\\varepsilon_x=10^{-12}$。\n    - 最大迭代次数：$N_{\\max}=100$。\n- **测试用例**：\n    - 用例 $1$：在 $[1, 2]$ 上的 $f(x)=x^3 - x - 2$。\n    - 用例 $2$：在 $[0, 1]$ 上的 $f(x)=e^{-x} - x$。\n    - 用例 $3$：在 $[0, 1]$ 上的 $f(x)=x^3 + 10^{-6}x - 1$。\n    - 用例 $4$：在 $[0, 3]$ 上的 $f(x)=x$。\n- **输出格式**：所有测试用例的结果以逗号分隔列表的形式放在方括号中，每个结果四舍五入到 $10$ 位小数。\n\n**步骤2：使用提取的已知条件进行验证**\n\n根据验证标准对问题进行评估。\n- **科学依据**：该问题描述了一种结合了试位法（False Position method）和二分法的混合数值方法。这是数值分析中的一种标准且有据可查的技术，而数值分析是计算工程和应用数学的核心学科。为解决试位法停滞问题而做的修改是一种已知的改进策略（与 Illinois 算法相关）。该问题在科学上是合理的。\n- **适定性**：该问题是适定的。它提供了具体的函数、满足所需包围条件的初始区间、明确的算法步骤和无歧义的终止标准。对于适当选择的函数和区间，该算法保证收敛到一个根。\n- **客观性**：该问题以精确、客观的数学语言陈述，不含任何主观或非形式化内容。\n\n所有有效问题的标准均已满足。不存在违反科学原理之处，没有矛盾，也没有会妨碍严格实现的歧义。\n\n**步骤3：结论与行动**\n\n该问题被判定为**有效**。将构建一个解决方案。\n\n**基于原理的解决方案**\n\n目标是找到连续函数 $f(x)$ 在区间 $[a, b]$ 内的一个实根 $x^\\star$，其中 $f(a)$ 和 $f(b)$ 异号或其中一个为零，即 $f(a)f(b) \\le 0$。介值定理保证了该区间内至少存在一个根。指定的方法是一种区间包围算法，意味着它系统地缩小区间 $[a, b]$，同时确保根始终位于其中。\n\n该算法的核心是一个迭代过程。在每一步 $k$，我们有一个包含根的区间 $[a_k, b_k]$。我们必须选择一个新的点 $c_k \\in (a_k, b_k)$ 进行测试。\n\n选择 $c_k$ 的主要方法是试位法。这涉及构造一条穿过点 $(a_k, f(a_k))$ 和 $(b_k, f(b_k))$ 的直线（一条割线）。下一个近似值 $c_k$ 是这条直线与 $x$ 轴的交点。该点的公式由直线的两点式方程导出，如下所示：\n$$\nc_{\\text{rf}} = \\frac{a_k f(b_k) - b_k f(a_k)}{f(b_k) - f(a_k)}\n$$\n这种方法通常比二分法收敛得更快。然而，它有一个显著的缺点：如果函数弯曲程度很大，区间的一个端点可能会变得“停滞”（在多次迭代中保持不变），导致收敛非常缓慢。区间宽度 $|b_k - a_k|$ 可能不会趋近于零。\n\n为了解决这种停滞问题，题目指定了一种混合策略。默认使用试位法，但当检测到停滞时，会使用一个不同的试探点。停滞被定义为“某个端点连续至少 $2$ 次迭代保持不变”的情况。在这种情况下，或者如果 $f(a_k) = f(b_k)$（这会使 $c_{\\text{rf}}$ 的分母为零），算法必须切换到二分法执行一步。二分法的试探点就是区间的中点：\n$$\nc_{\\text{bis}} = \\frac{a_k + b_k}{2}\n$$\n二分法步骤迫使搜索离开停滞的端点，通常能打破缓慢收敛的模式。执行一次二分法步骤后，停滞计数器被重置，算法恢复使用试位法。\n\n在计算出试探点 $c_k$（$c_{\\text{rf}}$ 或 $c_{\\text{bis}}$）及其函数值 $f(c_k)$ 后，确定下一次迭代的区间 $[a_{k+1}, b_{k+1}]$。为保持包围性质，我们检查 $f(c_k)$ 的符号：\n- 如果 $f(a_k) f(c_k)  0$，根位于 $[a_k, c_k]$ 中，因此我们设置 $a_{k+1} = a_k$ 和 $b_{k+1} = c_k$。在这种情况下，端点 $a_k$ 保持不变。\n- 如果 $f(b_k) f(c_k)  0$（由于 $f(a_k) f(b_k)  0$，这等价于 $f(a_k) f(c_k) > 0$），根位于 $[c_k, b_k]$ 中，因此我们设置 $a_{k+1} = c_k$ 和 $b_{k+1} = b_k$。在这种情况下，端点 $b_k$ 保持不变。\n- 如果 $f(c_k) = 0$，则已精确找到根。\n\n重复此过程，直到满足指定的终止条件之一：\n1. 试探点处的函数值足够接近零：$|f(c_k)| \\le \\varepsilon_f$。\n2. 包围区间的宽度足够小：$|b_k - a_k| \\le \\varepsilon_x$。\n3. 达到迭代次数上限 $N_{\\max}$。\n\n问题还指定，在每次迭代开始时，应检查端点处的函数值 $f(a_k)$ 和 $f(b_k)$ 是否满足 $\\varepsilon_f$。如果任一值足够小，则该端点即被视为根。\n\n实现中将维护一个计数器，记录同一端点保持不变的连续迭代次数。如果此计数器达到 $2$，则在当前迭代中强制执行一步二分法，并重置计数器。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the specified test cases and print the results.\n    \"\"\"\n\n    def find_root(f, a, b, eps_f, eps_x, n_max):\n        \"\"\"\n        Computes a root of f in [a, b] using a hybrid of Regula Falsi and Bisection.\n\n        Args:\n            f (callable): The function for which to find a root.\n            a (float): The lower bound of the interval.\n            b (float): The upper bound of the interval.\n            eps_f (float): Absolute function value tolerance.\n            eps_x (float): Absolute interval width tolerance.\n            n_max (int): Maximum number of iterations.\n\n        Returns:\n            float: The approximated root.\n        \"\"\"\n        fa = f(a)\n        fb = f(b)\n\n        # Initial checks on endpoints as per problem statement\n        if abs(fa) = eps_f:\n            return a\n        if abs(fb) = eps_f:\n            return b\n\n        # The problem statement guarantees the bracketing condition f(a)*f(b) = 0\n        \n        stagnant_counter = 0\n        # This flag tracks which endpoint ('a' or 'b') was unchanged in the last update.\n        # True if 'a' was unchanged, False if 'b' was unchanged, None otherwise.\n        last_unchanged_endpoint_is_a = None\n        \n        c = a # Initialize c to a valid float\n\n        for _ in range(n_max):\n            \n            # Determine if a bisection step is required\n            use_bisection = (stagnant_counter >= 2) or (fa == fb)\n            \n            # Calculate trial point c\n            if use_bisection:\n                c = (a + b) / 2.0\n            else:\n                c = (a * fb - b * fa) / (fb - fa)\n\n            fc = f(c)\n\n            # Termination checks, in the order specified by the problem.\n            # The problem states to return the *current* c if interval width is small.\n            if abs(b - a) = eps_x:\n                return c\n            \n            if abs(fc) = eps_f:\n                return c\n\n            # Update the interval and stagnation state\n            is_bisect_step = use_bisection\n\n            if fa * fc  0:  # Root is in [a, c], so b is updated\n                b = c\n                fb = fc\n                # Endpoint 'a' has remained unchanged\n                if last_unchanged_endpoint_is_a is True:\n                    stagnant_counter += 1\n                else:\n                    last_unchanged_endpoint_is_a = True\n                    stagnant_counter = 1\n            elif fb * fc  0:  # Root is in [c, b], so a is updated\n                a = c\n                fa = fc\n                # Endpoint 'b' has remained unchanged\n                if last_unchanged_endpoint_is_a is False:\n                    stagnant_counter += 1\n                else:\n                    last_unchanged_endpoint_is_a = False\n                    stagnant_counter = 1\n            else:  # This case implies fc is 0.0, which is handled by the termination condition above\n                return c\n\n            # After a bisection step, reset the stagnation counter\n            if is_bisect_step:\n                stagnant_counter = 0\n                last_unchanged_endpoint_is_a = None\n\n        # Return the last computed c if max iterations is reached\n        return c\n\n    # Define common parameters for all test cases\n    eps_f = 1e-12\n    eps_x = 1e-12\n    n_max = 100\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        (lambda x: x**3 - x - 2, 1.0, 2.0),\n        (lambda x: np.exp(-x) - x, 0.0, 1.0),\n        (lambda x: x**3 + 1e-6 * x - 1, 0.0, 1.0),\n        (lambda x: x, 0.0, 3.0),\n    ]\n\n    results = []\n    for f, a, b in test_cases:\n        root = find_root(f, a, b, eps_f, eps_x, n_max)\n        # Format the result to 10 decimal places as a string\n        results.append(f\"{root:.10f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\n# Execute the main function\nsolve()\n```", "id": "2375457"}]}