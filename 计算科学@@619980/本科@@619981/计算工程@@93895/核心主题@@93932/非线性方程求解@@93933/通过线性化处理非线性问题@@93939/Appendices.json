{"hands_on_practices": [{"introduction": "许多物理系统本质上是轻微非线性的，直接求解它们的运动方程很有挑战性。这个练习探讨了达芬方程 (Duffing equation)，一个描述非线性振荡器的典型模型。通过应用微扰理论 (perturbation theory)，我们可以将一个复杂的非线性问题分解为一系列更简单的线性问题来近似求解，这是处理非线性的一个核心思想 [@problem_id:2398884]。你将通过此实践计算振荡频率的一阶修正，从而掌握分析弱非线性系统的关键技巧。", "problem": "考虑一个由杜芬方程控制的非线性振子\n$$\\ddot{x} + x + \\epsilon x^{3} = 0,$$\n其中 $\\epsilon$ 是一个无量纲参数，满足 $|\\epsilon| \\ll 1$。设初始条件为 $x(0) = A$ 和 $\\dot{x}(0) = 0$，其中 $A>0$。定义线性固有角频率为 $\\omega_{0} = 1$。求由三次非线性项引起的最终周期运动的角频率修正 $\\Delta \\omega(A,\\epsilon)$（精确到 $\\epsilon$ 的一阶），使得角频率为 $\\omega = \\omega_{0} + \\Delta \\omega(A,\\epsilon) + \\mathcal{O}(\\epsilon^{2})$。请以 $A$ 和 $\\epsilon$ 的单个闭式解析表达式的形式给出最终结果。答案无需舍入，也无单位。", "solution": "该问题要求确定由杜芬方程描述的非线性振子的角频率的一阶修正。控制方程为：\n$$\n\\ddot{x} + x + \\epsilon x^{3} = 0\n$$\n初始条件为 $x(0) = A$ 和 $\\dot{x}(0) = 0$，其中 $A>0$ 且 $|\\epsilon| \\ll 1$。线性固有角频率给定为 $\\omega_{0} = 1$。\n\n这是非线性动力学中的一个经典问题，可以使用微扰理论来解决。我们将采用林德斯特-庞加莱方法。该技术通过将解和频率同时按小参数 $\\epsilon$ 的幂次进行展开，来解决直接微扰展开中出现的久期项（即随时间无界增长的项）问题。\n\n首先，我们引入一个新的无量纲时间变量 $\\tau = \\omega t$，其中 $\\omega$ 是周期运动的真实未知角频率。关于 $t$ 的导数变换如下：\n$$\n\\frac{d}{dt} = \\frac{d\\tau}{dt} \\frac{d}{d\\tau} = \\omega \\frac{d}{d\\tau}\n$$\n$$\n\\frac{d^2}{dt^2} = \\omega^2 \\frac{d^2}{d\\tau^2}\n$$\n将这些代入杜芬方程，并用撇号表示对 $\\tau$ 的微分，我们得到：\n$$\n\\omega^2 x''(\\tau) + x(\\tau) + \\epsilon x(\\tau)^3 = 0\n$$\n接下来，我们寻求解 $x(\\tau)$ 和频率的平方 $\\omega^2$ 按 $\\epsilon$ 的幂次的级数展开。通常，我们展开 $\\omega$ 本身，但展开 $\\omega^2$ 在代数上是等价的，并且通常更简单。\n$$\nx(\\tau) = x_0(\\tau) + \\epsilon x_1(\\tau) + \\epsilon^2 x_2(\\tau) + \\dots\n$$\n$$\n\\omega = \\omega_0 + \\epsilon \\omega_1 + \\epsilon^2 \\omega_2 + \\dots\n$$\n给定 $\\omega_0 = 1$，$\\omega^2$ 的展开式变为：\n$$\n\\omega^2 = (1 + \\epsilon \\omega_1 + \\dots)^2 = 1 + 2\\epsilon \\omega_1 + \\mathcal{O}(\\epsilon^2)\n$$\n将这些展开式代入变换后的微分方程：\n$$\n(1 + 2\\epsilon \\omega_1 + \\mathcal{O}(\\epsilon^2))(x_0'' + \\epsilon x_1'' + \\dots) + (x_0 + \\epsilon x_1 + \\dots) + \\epsilon(x_0 + \\epsilon x_1 + \\dots)^3 = 0\n$$\n我们展开乘积并合并 $\\epsilon$ 的同次幂项。\n\n$\\epsilon^0$ 阶：\n$$\nx_0'' + x_0 = 0\n$$\n这是一个简谐振子方程。原问题的初始条件必须转换到展开项上。在 $t=0$ 时，我们有 $\\tau=0$。\n$x(0) = x_0(0) + \\epsilon x_1(0) + \\dots = A$ 因此 $x_0(0) = A, x_1(0)=0, \\dots$\n$\\dot{x}(t) = \\omega \\frac{dx}{d\\tau} = \\omega(x_0'(\\tau) + \\epsilon x_1'(\\tau) + \\dots)$。\n$\\dot{x}(0) = \\omega(x_0'(0) + \\epsilon x_1'(0) + \\dots) = 0$ 因此 $x_0'(0)=0, x_1'(0)=0, \\dots$\n零阶方程的通解为 $x_0(\\tau) = C \\cos(\\tau) + D \\sin(\\tau)$。应用初始条件：\n$x_0(0) = C = A$\n$x_0'(0) = D = 0$\n因此，零阶解为：\n$$\nx_0(\\tau) = A \\cos(\\tau)\n$$\n\n$\\epsilon^1$ 阶：\n从展开的方程中收集所有与 $\\epsilon$ 成正比的项，得到：\n$$\nx_1'' + x_0 + 2\\omega_1 x_0'' + x_0^3 = 0\n$$\n重新整理以得到关于 $x_1$ 的方程：\n$$\nx_1'' + x_1 = -2\\omega_1 x_0'' - x_0^3\n$$\n我们将零阶解 $x_0(\\tau) = A \\cos(\\tau)$ 及其二阶导数 $x_0''(\\tau) = -A \\cos(\\tau)$ 代入方程右边 (RHS)：\n$$\n\\text{RHS} = -2\\omega_1 (-A \\cos(\\tau)) - (A \\cos(\\tau))^3 = 2\\omega_1 A \\cos(\\tau) - A^3 \\cos^3(\\tau)\n$$\n为分析强迫项，我们使用三角恒等式 $\\cos(3\\theta) = 4\\cos^3(\\theta) - 3\\cos(\\theta)$，由此得到 $\\cos^3(\\theta) = \\frac{1}{4}(\\cos(3\\theta) + 3\\cos(\\theta))$。\n将此恒等式应用于 $\\cos^3(\\tau)$：\n$$\n\\text{RHS} = 2\\omega_1 A \\cos(\\tau) - A^3 \\left(\\frac{3}{4}\\cos(\\tau) + \\frac{1}{4}\\cos(3\\tau)\\right)\n$$\n合并各项：\n$$\n\\text{RHS} = \\left(2\\omega_1 A - \\frac{3A^3}{4}\\right)\\cos(\\tau) - \\frac{A^3}{4}\\cos(3\\tau)\n$$\n因此 $x_1$ 的方程为：\n$$\nx_1'' + x_1 = \\left(2\\omega_1 A - \\frac{3A^3}{4}\\right)\\cos(\\tau) - \\frac{A^3}{4}\\cos(3\\tau)\n$$\n该方程齐次部分的固有频率为 $1$。强迫项包含一个具有相同频率的分量 $\\cos(\\tau)$。这将导致共振响应，在 $x_1$ 的解中产生形式为 $\\tau \\sin(\\tau)$ 的久期项。这样的项会无界增长，这违背了周期运动的物理假设。林德斯特-庞加莱方法的核心原理是，精确地选择频率修正 $\\omega_1$ 以消除产生久期项的强迫项。\n我们必须将共振项 $\\cos(\\tau)$ 的系数设为零：\n$$\n2\\omega_1 A - \\frac{3A^3}{4} = 0\n$$\n由于给定 $A > 0$，我们可以除以 $2A$：\n$$\n\\omega_1 - \\frac{3A^2}{8} = 0 \\implies \\omega_1 = \\frac{3A^2}{8}\n$$\n这就给出了频率的一阶修正。问题要求的是量 $\\Delta \\omega(A, \\epsilon)$，即直到 $\\epsilon$ 一阶的频率总修正。根据我们的展开式 $\\omega = \\omega_0 + \\epsilon \\omega_1 + \\mathcal{O}(\\epsilon^2)$，我们有：\n$$\n\\Delta \\omega(A, \\epsilon) = \\omega - \\omega_0 = \\epsilon \\omega_1 + \\mathcal{O}(\\epsilon^2)\n$$\n精确到 $\\epsilon$ 的一阶，修正是：\n$$\n\\Delta \\omega(A, \\epsilon) = \\frac{3\\epsilon A^2}{8}\n$$\n此表达式表示了由于弱三次非线性，振子的角频率随初始振幅 $A$ 和非线性参数 $\\epsilon$ 变化的量。对于一个“硬”弹簧（$\\epsilon>0$），频率随振幅增加。", "answer": "$$\n\\boxed{\\frac{3\\epsilon A^{2}}{8}}\n$$", "id": "2398884"}, {"introduction": "在计算工程中，对复杂的多变量函数进行线性化是许多算法（如优化和求解非线性方程组）的基石，而这通常需要计算其雅可比矩阵 (Jacobian matrix)。本练习 [@problem_id:2398904] 让你通过两种基本方法实现这一过程：直观但近似的有限差分法 (finite differences)，以及精确到机器精度的前向模式自动微分 (forward-mode automatic differentiation)。通过亲手实现并比较它们，你将深刻理解这两种计算线性化模型方法的精度、效率和实际应用中的权衡。", "problem": "要求您通过两种方式计算一个非线性复合映射的雅可比矩阵，并比较它们的数值精度，从而研究如何使用线性化来处理非线性问题。考虑由以下分量定义的复合函数。设 $\\mathbf{x} \\in \\mathbb{R}^{3}$，其分量为 $\\mathbf{x} = [x_{1}, x_{2}, x_{3}]^{\\top}$。定义一个中间映射 $\\mathbf{g}: \\mathbb{R}^{3} \\rightarrow \\mathbb{R}^{3}$ 为\n$$\n\\mathbf{g}(\\mathbf{x}) =\n\\begin{bmatrix}\n\\exp\\!\\big(x_{1} x_{2}\\big) \\\\\n\\sin\\!\\big(x_{2} + x_{3}\\big) \\\\\nx_{1}^{2} + x_{3}\n\\end{bmatrix},\n$$\n以及第二个映射 $\\mathbf{h}: \\mathbb{R}^{3} \\rightarrow \\mathbb{R}^{2}$ 为\n$$\n\\mathbf{h}(\\mathbf{u}) =\n\\begin{bmatrix}\nu_{1} \\cos(u_{2}) + u_{3}^{3} \\\\\n\\ln\\!\\big(1 + u_{1}^{2} + u_{2}^{2}\\big) + \\tanh(u_{3})\n\\end{bmatrix}.\n$$\n三角函数 $\\sin(\\cdot)$ 和 $\\cos(\\cdot)$ 的角度应以弧度为单位。复合函数为 $\\mathbf{F} = \\mathbf{h} \\circ \\mathbf{g}: \\mathbb{R}^{3} \\rightarrow \\mathbb{R}^{2}$。\n\n您的任务是在几个输入点 $\\mathbf{x}$ 处，使用以下两种方法计算雅可比矩阵 $\\mathbf{J}_{\\mathbf{F}}(\\mathbf{x}) \\in \\mathbb{R}^{2 \\times 3}$：\n- 基于对偶数的前向模式自动微分方法，以及\n- 使用两种步长的中心有限差分近似。\n\n雅可比矩阵 $\\mathbf{J}_{\\mathbf{F}}(\\mathbf{x})$ 的元素定义为 $[\\mathbf{J}_{\\mathbf{F}}(\\mathbf{x})]_{ij} = \\partial F_{i}(\\mathbf{x}) / \\partial x_{j}$。线性化是指使用此雅可比矩阵对 $\\mathbf{F}$ 在 $\\mathbf{x}$ 附近进行的一阶近似。\n\n对于前向模式自动微分方法，您必须实现表示数对 $(v, \\dot{v})$ 的对偶数，该数对根据基本原理（乘法法则、链式法则以及基本函数的标准导数）通过基本运算和函数来传播值和方向导数。对于有限差分法，使用中心差分公式近似雅可比矩阵的第 $j$ 列\n$$\n\\frac{\\mathbf{F}(\\mathbf{x} + h \\mathbf{e}_{j}) - \\mathbf{F}(\\mathbf{x} - h \\mathbf{e}_{j})}{2 h},\n$$\n其中 $\\mathbf{e}_{j}$ 是 $\\mathbb{R}^{3}$ 中的第 $j$ 个标准基向量，而 $h$ 是一个正标量步长。\n\n为了量化精度差异，请对每个测试输入和每个步长，计算有限差分雅可比矩阵 $\\mathbf{J}_{\\mathrm{fd}}$ 与自动微分雅可比矩阵 $\\mathbf{J}_{\\mathrm{ad}}$ 之间的相对 Frobenius 范数误差：\n$$\n\\varepsilon_{\\mathrm{rel}} = \\frac{\\left\\| \\mathbf{J}_{\\mathrm{fd}} - \\mathbf{J}_{\\mathrm{ad}} \\right\\|_{F}}{\\max\\!\\left(1, \\left\\| \\mathbf{J}_{\\mathrm{ad}} \\right\\|_{F}\\right)},\n$$\n其中 $\\|\\cdot\\|_{F}$ 表示 Frobenius 范数。这种归一化避免了除以小于 1 的值，并在雅可比矩阵范数非常小时保持度量的良好缩放。\n\n测试套件：\n- 使用以下四个输入向量 $\\mathbf{x}$（无量纲）：\n  - $\\mathbf{x}^{(1)} = [0.2, -0.3, 0.5]^{\\top}$，\n  - $\\mathbf{x}^{(2)} = [10^{-8}, -10^{-8}, 10^{-8}]^{\\top}$，\n  - $\\mathbf{x}^{(3)} = [1.5, 0.7, -1.2]^{\\top}$，\n  - $\\mathbf{x}^{(4)} = [-2.0, 0.4, 0.3]^{\\top}$。\n- 对于中心差分，使用两种步长 $h$：\n  - $h_{1} = 10^{-6}$，\n  - $h_{2} = 10^{-8}$。\n\n程序要求：\n- 从基本原理出发，为 $\\mathbf{F}$ 中出现的基本运算和函数实现对偶数前向模式自动微分。\n- 按规定实现中心有限差分雅可比矩阵近似。\n- 对于每个测试输入 $\\mathbf{x}^{(k)}$，计算两个值：使用 $h = h_{1}$ 和使用 $h = h_{2}$ 时的 $\\varepsilon_{\\mathrm{rel}}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表用方括号括起来，不含空格。该列表必须按以下顺序包含八个浮点数值：\n  - $\\mathbf{x}^{(1)}$ 在 $h_{1}$ 下的 $\\varepsilon_{\\mathrm{rel}}$，然后在 $h_{2}$ 下，\n  - $\\mathbf{x}^{(2)}$ 在 $h_{1}$ 下的 $\\varepsilon_{\\mathrm{rel}}$，然后在 $h_{2}$ 下，\n  - $\\mathbf{x}^{(3)}$ 在 $h_{1}$ 下的 $\\varepsilon_{\\mathrm{rel}}$，然后在 $h_{2}$ 下，\n  - $\\mathbf{x}^{(4)}$ 在 $h_{1}$ 下的 $\\varepsilon_{\\mathrm{rel}}$，然后在 $h_{2}$ 下。\n例如, 输出必须如下所示\n$$\n[\\varepsilon_{1,1},\\varepsilon_{1,2},\\varepsilon_{2,1},\\varepsilon_{2,2},\\varepsilon_{3,1},\\varepsilon_{3,2},\\varepsilon_{4,1},\\varepsilon_{4,2}],\n$$\n其中每个 $\\varepsilon_{k,\\ell}$ 是一个浮点数。不应打印任何额外文本。", "solution": "问题陈述已经过验证，被认为是有效的。它在计算工程领域内提出了一个适定的、有科学依据的计算任务，具体涉及通过线性化处理非线性问题。所有函数、参数和评估指标都经过了精确的数学定义，问题没有歧义或事实错误。\n\n### 1. 分析框架\n\n复合函数为 $\\mathbf{F}(\\mathbf{x}) = \\mathbf{h}(\\mathbf{g}(\\mathbf{x}))$，其中 $\\mathbf{g}: \\mathbb{R}^{3} \\rightarrow \\mathbb{R}^{3}$ 且 $\\mathbf{h}: \\mathbb{R}^{3} \\rightarrow \\mathbb{R}^{2}$。\n$$\n\\mathbf{g}(\\mathbf{x}) =\n\\begin{bmatrix}\ng_{1}(\\mathbf{x}) \\\\ g_{2}(\\mathbf{x}) \\\\ g_{3}(\\mathbf{x})\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\exp\\!\\big(x_{1} x_{2}\\big) \\\\\n\\sin\\!\\big(x_{2} + x_{3}\\big) \\\\\nx_{1}^{2} + x_{3}\n\\end{bmatrix}\n$$\n$$\n\\mathbf{h}(\\mathbf{u}) =\n\\begin{bmatrix}\nh_{1}(\\mathbf{u}) \\\\ h_{2}(\\mathbf{u})\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nu_{1} \\cos(u_{2}) + u_{3}^{3} \\\\\n\\ln\\!\\big(1 + u_{1}^{2} + u_{2}^{2}\\big) + \\tanh(u_{3})\n\\end{bmatrix}\n$$\n复合函数的雅可比矩阵由多元链式法则给出：\n$$\n\\mathbf{J}_{\\mathbf{F}}(\\mathbf{x}) = \\mathbf{J}_{\\mathbf{h}}(\\mathbf{g}(\\mathbf{x})) \\cdot \\mathbf{J}_{\\mathbf{g}}(\\mathbf{x})\n$$\n其中 $\\mathbf{J}_{\\mathbf{h}} \\in \\mathbb{R}^{2 \\times 3}$ 且 $\\mathbf{J}_{\\mathbf{g}} \\in \\mathbb{R}^{3 \\times 3}$。\n\n### 2. 前向模式自动微分（AD）\n\n前向模式 AD 通过在基本运算层面系统地应用链式法则来计算精确导数。这是通过对偶数代数实现的。一个对偶数是一个有序对 $(v, \\dot{v})$，表示一个值 $v$ 及其方向导数 $\\dot{v}$。它可以写成 $v + \\epsilon \\dot{v}$ 的形式，其中 $\\epsilon$ 是一个无穷小量，其性质为 $\\epsilon^2 = 0$。\n\n算术和基本函数的规则源自标准微分法则：\n- **求和法则**: $(u \\pm w)' = u' \\pm w'$ $\\implies$ $(u_{v}, u_{\\dot{v}}) \\pm (w_{v}, w_{\\dot{v}}) = (u_{v} \\pm w_{v}, u_{\\dot{v}} \\pm w_{\\dot{v}})$\n- **乘法法则**: $(u w)' = u'w + uw'$ $\\implies$ $(u_{v}, u_{\\dot{v}}) \\cdot (w_{v}, w_{\\dot{v}}) = (u_{v} w_{v}, u_{\\dot{v}} w_{v} + u_{v} w_{\\dot{v}})$\n- **链式法则**: $(f(u))' = f'(u) u'$ $\\implies$ $f((u_{v}, u_{\\dot{v}})) = (f(u_{v}), f'(u_{v}) u_{\\dot{v}})$\n\n为了计算雅可比矩阵 $\\mathbf{J}_{\\mathbf{F}}(\\mathbf{x})$ 的第 $j$ 列（该列包含关于 $x_j$ 的偏导数），我们计算 $\\mathbf{F}$ 沿标准基向量 $\\mathbf{e}_j$ 方向的方向导数。这通过将输入导数（“种子”）设置为 $\\dot{\\mathbf{x}} = \\mathbf{e}_j$ 来完成。\n\n对于每一列 $j = 1, 2, 3$，该算法包括以下步骤：\n1.  将输入向量 $\\mathbf{x}$ 初始化为对偶数向量，其中 $x_{i}$ 变为 $(x_{i}, \\delta_{ij})$，$\\delta_{ij}$ 是克罗内克 δ。\n2.  使用对偶数算术评估函数 $\\mathbf{F}$。该评估通过复合运算 $\\mathbf{h} \\circ \\mathbf{g}$ 传播值及其导数。\n3.  结果是一个对偶数向量 $\\mathbf{F}(\\mathbf{x}_{\\text{dual}}) = [(F_{1}, \\dot{F}_{1}), (F_{2}, \\dot{F}_{2})]^{\\top}$。其导数分量 $(\\dot{F}_{1}, \\dot{F}_{2})^{\\top}$ 构成了雅可比矩阵的第 $j$ 列：$[\\mathbf{J}_{\\mathbf{F}}]_{ij} = \\dot{F}_i$。\n\n对每个输入变量重复此过程，以构建完整的雅可比矩阵 $\\mathbf{J}_{\\mathrm{ad}}$。\n\n### 3. 中心有限差分（FD）近似\n\n有限差分法通过在扰动点上评估函数来近似导数。雅可比矩阵第 $j$ 列的中心差分公式如下：\n$$\n(\\mathbf{J}_{\\mathrm{fd}})_{:,j} = \\frac{\\mathbf{F}(\\mathbf{x} + h \\mathbf{e}_{j}) - \\mathbf{F}(\\mathbf{x} - h \\mathbf{e}_{j})}{2 h}\n$$\n其中 $h$ 是一个小步长。该公式由 $\\mathbf{F}(\\mathbf{x} \\pm h \\mathbf{e}_{j})$ 在 $\\mathbf{x}$ 附近的泰勒级数展开导出。此近似的截断误差为 $O(h^2)$ 阶，意味着误差与步长的平方成正比。\n\n然而，总误差是此截断误差和浮点运算产生的舍入误差的组合。当 $h$ 减小时，分子中减法运算的舍入误差会增加，导致有效数字损失。这就产生了一个权衡：较小的 $h$ 会减少截断误差，但会增加舍入误差。我们将通过使用两个不同的步长 $h_1 = 10^{-6}$ 和 $h_2 = 10^{-8}$ 来研究这个问题。\n\n### 4. 误差量化\n\n为了比较有限差分法与自动微分结果的精度，我们计算相对 Frobenius 范数误差：\n$$\n\\varepsilon_{\\mathrm{rel}} = \\frac{\\left\\| \\mathbf{J}_{\\mathrm{fd}} - \\mathbf{J}_{\\mathrm{ad}} \\right\\|_{F}}{\\max\\!\\left(1, \\left\\| \\mathbf{J}_{\\mathrm{ad}} \\right\\|_{F}\\right)}\n$$\nFrobenius 范数定义为 $\\|\\mathbf{A}\\|_{F} = \\sqrt{\\sum_{i,j} |A_{ij}|^2}$。通过 $\\max(1, \\left\\| \\mathbf{J}_{\\mathrm{ad}} \\right\\|_{F})$ 进行归一化提供了一个稳定的误差度量，既能防止除以接近零的值，又能相对于“真实”雅可比矩阵的量级对误差进行缩放。\n\n### 5. 实现策略\n\n该解决方案使用 Python 实现。定义了一个 `Dual` 类来表示对偶数并重载标准算术运算符。为基本数学运算（`exp`、 `sin`、 `cos`、 `ln`、 `tanh`）实现了全局函数，使其具有多态性，可以处理标准浮点数和 `Dual` 对象。然后，使用这些多态运算编写特定于问题的函数 $\\mathbf{g}$ 和 $\\mathbf{h}$，使它们能够无缝地用于 AD 和 FD 计算。主程序遍历指定的测试输入和步长，通过两种方法计算雅可比矩阵，并计算每种情况下的相对误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# A strict Russian professor insists on scientific correctness from first principles.\n\nclass Dual:\n    \"\"\"\n    Represents a dual number for forward-mode automatic differentiation.\n    A dual number has a real part (value) and an infinitesimal part (derivative).\n    d = value + derivative * epsilon, where epsilon^2 = 0.\n    \"\"\"\n    def __init__(self, value, derivative=0.0):\n        self.value = float(value)\n        self.derivative = float(derivative)\n\n    def __repr__(self):\n        return f\"Dual({self.value}, {self.derivative})\"\n\n    def __add__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value + other.value, self.derivative + other.derivative)\n        return Dual(self.value + other, self.derivative)\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value - other.value, self.derivative - other.derivative)\n        return Dual(self.value - other, self.derivative)\n\n    def __rsub__(self, other):\n        return Dual(other - self.value, -self.derivative)\n\n    def __mul__(self, other):\n        if isinstance(other, Dual):\n            # Product rule: (uv)' = u'v + uv'\n            return Dual(self.value * other.value, \n                        self.derivative * other.value + self.value * other.derivative)\n        return Dual(self.value * other, self.derivative * other)\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n    \n    def __pow__(self, exponent):\n        if isinstance(exponent, (int, float)):\n            # Power rule for constant exponent: (u^c)' = c*u^(c-1)*u'\n            val = self.value ** exponent\n            der = exponent * (self.value ** (exponent - 1)) * self.derivative\n            return Dual(val, der)\n        raise NotImplementedError(\"Dual to the power of Dual is not implemented.\")\n\n    def __truediv__(self, other):\n        if isinstance(other, Dual):\n            # Quotient rule: (u/v)' = (u'v - uv') / v^2\n            val = self.value / other.value\n            der = (self.derivative * other.value - self.value * other.derivative) / (other.value ** 2)\n            return Dual(val, der)\n        return Dual(self.value / other, self.derivative / other)\n\n    def __rtruediv__(self, other):\n        val = other / self.value\n        der = (-other * self.derivative) / (self.value ** 2)\n        return Dual(val, der)\n    \n    def __neg__(self):\n        return Dual(-self.value, -self.derivative)\n\n# Polymorphic elementary functions that work with both floats and Dual numbers.\ndef exp(d):\n    if not isinstance(d, Dual): return np.exp(d)\n    val = np.exp(d.value)\n    der = val * d.derivative\n    return Dual(val, der)\n\ndef sin(d):\n    if not isinstance(d, Dual): return np.sin(d)\n    val = np.sin(d.value)\n    der = np.cos(d.value) * d.derivative\n    return Dual(val, der)\n\ndef cos(d):\n    if not isinstance(d, Dual): return np.cos(d)\n    val = np.cos(d.value)\n    der = -np.sin(d.value) * d.derivative\n    return Dual(val, der)\n\ndef log(d):\n    if not isinstance(d, Dual): return np.log(d)\n    val = np.log(d.value)\n    der = (1 / d.value) * d.derivative\n    return Dual(val, der)\n\ndef tanh(d):\n    if not isinstance(d, Dual): return np.tanh(d)\n    val = np.tanh(d.value)\n    # Derivative of tanh(x) is sech^2(x) = 1 - tanh^2(x)\n    der = (1 - val**2) * d.derivative\n    return Dual(val, der)\n\n# Problem-specific nonlinear mappings\ndef g(x_vec):\n    \"\"\" Intermediate mapping g: R^3 -> R^3 \"\"\"\n    x1, x2, x3 = x_vec[0], x_vec[1], x_vec[2]\n    return [\n        exp(x1 * x2),\n        sin(x2 + x3),\n        x1**2 + x3\n    ]\n\ndef h(u_vec):\n    \"\"\" Final mapping h: R^3 -> R^2 \"\"\"\n    u1, u2, u3 = u_vec[0], u_vec[1], u_vec[2]\n    return [\n        u1 * cos(u2) + u3**3,\n        log(1 + u1**2 + u2**2) + tanh(u3)\n    ]\n\ndef F(x_vec):\n    \"\"\" Composed mapping F = h(g(x)) \"\"\"\n    return h(g(x_vec))\n\ndef compute_jacobian_ad(x_val):\n    \"\"\"Computes the Jacobian using forward-mode automatic differentiation.\"\"\"\n    n_in = len(x_val)\n    # Dynamically determine output dimension by a sample evaluation\n    n_out = len(F(x_val))\n    J_ad = np.zeros((n_out, n_in))\n    \n    for j in range(n_in):\n        # Create dual number inputs with a seed for the j-th partial derivative\n        x_dual = [Dual(x_val[i], 1.0 if i == j else 0.0) for i in range(n_in)]\n        \n        # Evaluate the function with dual numbers\n        F_dual = F(x_dual)\n        \n        # The derivative part of the output is the j-th column of the Jacobian\n        for i in range(n_out):\n            J_ad[i, j] = F_dual[i].derivative\n            \n    return J_ad\n\ndef compute_jacobian_fd(x_val, h_step):\n    \"\"\"Computes the Jacobian using the central finite-difference formula.\"\"\"\n    x_val = np.array(x_val, dtype=float)\n    n_in = len(x_val)\n    n_out = len(F(x_val))\n    J_fd = np.zeros((n_out, n_in))\n    \n    for j in range(n_in):\n        e_j = np.zeros(n_in)\n        e_j[j] = 1.0\n        \n        x_fwd = x_val + h_step * e_j\n        x_bwd = x_val - h_step * e_j\n        \n        F_fwd = np.array(F(x_fwd))\n        F_bwd = np.array(F(x_bwd))\n        \n        column = (F_fwd - F_bwd) / (2 * h_step)\n        J_fd[:, j] = column\n        \n    return J_fd\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [0.2, -0.3, 0.5],\n        [1e-8, -1e-8, 1e-8],\n        [1.5, 0.7, -1.2],\n        [-2.0, 0.4, 0.3]\n    ]\n    step_sizes = [1e-6, 1e-8]\n    \n    results = []\n    for x_vec in test_cases:\n        # Compute the \"exact\" Jacobian using Automatic Differentiation\n        J_ad = compute_jacobian_ad(x_vec)\n        norm_J_ad = np.linalg.norm(J_ad, 'fro')\n\n        for h in step_sizes:\n            # Compute the approximate Jacobian using Finite Differences\n            J_fd = compute_jacobian_fd(x_vec, h)\n            \n            # Calculate the relative Frobenius-norm error\n            norm_diff = np.linalg.norm(J_fd - J_ad, 'fro')\n            error = norm_diff / max(1.0, norm_J_ad)\n            results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2398904"}, {"introduction": "将非线性问题转化为线性近似来求解，是科学与工程计算中威力强大的通用策略，其中牛顿法 (Newton's method) 是最经典的范例。这个练习将你置于一个引人入胜的密码分析场景中 [@problem_id:2398877]。你需要从一个假设的加密系统侧信道泄漏信息中，推导出一个关键的非线性方程，并应用牛顿法——即迭代地求解该问题的线性化版本——来破解密码。这个实践不仅能巩固你对线性化方法的理解，也展示了它在解决现实世界问题中的巨大潜力。", "problem": "一个公钥密码系统使用由 $N = p\\,q$ 定义的 Rivest–Shamir–Adleman (RSA) 模数，其中 $p$和$q$是未知素数，且满足 $p \\le q$。一次旁道测量揭示了素数因子之间的一个非线性代数约束：平方和 $p^2 + q^2$ 等于一个泄露值$L$。您的任务是通过求解一个由定义推导出的单变量非线性方程来计算$p$，并实现一个牛顿线性化过程来找到其根。\n\n基础原理：\n- 根据模数的定义，$N = p\\,q$。\n- 泄露信息提供了 $p^2 + q^2 = L$。\n- 目标是消去 $q$，将 $p$ 作为标量非线性方程的正根来求解，求解时使用牛顿法（一阶泰勒线性化），并基于标量函数相对于标量迭代值的导数进行更新。\n\n算法要求：\n- 使用 $N$ 的定义消去 $q$，从而得到一个关于未知数 $p$ 的单变量方程，该方程与泄露信息 $p^2 + q^2 = L$ 一致。\n- 定义一个连续可微的标量函数 $f(x)$，使得真实的 $p$ 是 $f(x) = 0$ 的一个单根。\n- 从基本原理（初等微积分）推导精确导数 $f'(x)$，以支持牛顿法。\n- 实现牛顿法，其迭代式为 $x_{\\text{new}} = x - f(x)/f'(x)$。\n- 使用一个严格为正的初始猜测值 $x_0$，其值等于 $\\sqrt{N}$。\n- 强制迭代值为正，并根据 $x$ 的变化或 $f$ 的残差（任选其一）提供一个合理的停止准则。使用有限的最大迭代次数来保证终止。\n- 收敛后，仅在最后一步通过四舍五入将数值根映射为整数因子，并返回较小的素数因子。如果牛顿法的估计值更接近 $q$，则使用关系式 $q = N/p$ 来确保仍然返回较小的素数 $p$。\n\n测试套件：\n您的程序必须解决以下四个独立的实例。对于每个实例，输入是一对 $(N, L)$，要求输出是较小的素数因子 $p$（作为整数）。\n\n- 实例 A: $N = 17473$, $L = 40130$。\n- 实例 B: $N = 272953$, $L = 548210$。\n- 实例 C: $N = 119989$, $L = 1539578$。\n- 实例 D: $N = 1005973$, $L = 2012090$。\n\n输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按 $[p_A, p_B, p_C, p_D]$ 的顺序排列。例如，如果计算出的四个较小因子是 $a$、$b$、$c$ 和 $d$，则在单行上打印 $[a,b,c,d]$。", "solution": "在尝试任何解决方案之前，需对问题陈述进行验证。\n\n### 第 1 步：提取已知条件\n\n- 公钥密码系统，其 RSA 模数为 $N = p\\,q$。\n- $p$ 和 $q$ 是未知素数，且满足 $p \\le q$。\n- 一次旁道泄露提供了一个非线性代数约束：$p^2 + q^2 = L$。\n- 目标是计算素数因子 $p$。\n- 指定的方法是使用牛顿线性化过程求解关于 $p$ 的单变量非线性方程。\n- 标量非线性方程 $f(x)=0$（其中 $p$ 是一个根）必须通过消去 $q$ 来推导。\n- 牛顿法由迭代更新式 $x_{\\text{new}} = x - f(x)/f'(x)$ 定义。\n- 导数 $f'(x)$ 必须从基本原理推导。\n- 迭代的初始猜测值为 $x_0 = \\sqrt{N}$。\n- 迭代值 $x$ 必须保持为正。\n- 需要一个基于迭代值变化或残差的停止准则，并设置最大迭代次数以确保终止。\n- 最终的数值根必须映射为整数，并且必须返回较小的素数因子。如果估计值更接近 $q$，则应通过 $p = N/q$ 计算出较小的因子 $p$。\n- 测试套件：\n    - 实例 A: $(N = 17473, L = 40130)$\n    - 实例 B: $(N = 272953, L = 548210)$\n    - 实例 C: $(N = 119989, L = 1539578)$\n    - 实例 D: $(N = 1005973, L = 2012090)$\n- 要求的输出格式：单行输出，包含一个用方括号括起来的逗号分隔列表，格式为：$[p_A, p_B, p_C, p_D]$。\n\n### 第 2 步：使用提取的已知条件进行验证\n\n根据既定的有效性标准对问题进行评估。\n\n- **科学性**：该问题基于代数（求解多项式方程）和数值分析（牛顿法）的基本原理。RSA 密码学和旁道攻击的背景是计算工程和计算机科学中一个有效且成熟的课题。其中的数学关系是合理的。\n- **适定性**：问题陈述清晰。它提供了足够的信息（$N$，$L$）和一个具体的、定义明确的数值方法（牛顿法），以找到唯一的解（较小的素数因子 $p$）。\n- **客观性**：问题以精确、客观的数学语言表述。没有主观或模糊的术语。\n- **完整性与一致性**：问题是自洽的。所提供的数据（$N, L$）足以进行推导和求解。没有内部矛盾。为了使解存在，$p$ 和 $q$ 必须有实数根，这要求相关二次方程的判别式为非负。这意味着 $L^2 - 4N^2 \\ge 0$，即 $L \\ge 2N$。所有测试实例都满足此条件，证实了它们的物理一致性。\n    - A: $L=40130$, $2N=34946$。$L > 2N$。\n    - B: $L=548210$, $2N=545906$。$L > 2N$。\n    - C: $L=1539578$, $2N=239978$。$L > 2N$。\n    - D: $L=2012090$, $2N=2011946$。$L > 2N$。\n- **可形式化**：该问题不是隐喻性的，可以直接形式化为一个数学过程。它正确地属于通过线性化处理非线性问题的主题。\n\n该问题没有表现出任何与科学性不健全、不可形式化、不完整、不可行或非适定性相关的缺陷。\n\n### 第 3 步：结论与行动\n\n该问题是**有效的**。将提供一个解决方案。\n\n### 求解推导\n\n解决方案需要推导一个标量非线性函数 $f(x)=0$（其根为所求的素数因子 $p$），然后应用牛顿法。\n\n**1. 非线性方程的推导**\n\n我们有两个基本方程：\n$$\nN = p\\,q\n$$\n$$\np^2 + q^2 = L\n$$\n从第一个方程，假设 $p \\neq 0$（对素数因子而言这是保证的），我们可以用 $p$ 和 $N$ 表示 $q$：\n$$\nq = \\frac{N}{p}\n$$\n将这个 $q$ 的表达式代入第二个方程，可以消去 $q$：\n$$\np^2 + \\left(\\frac{N}{p}\\right)^2 = L\n$$\n$$\np^2 + \\frac{N^2}{p^2} = L\n$$\n为了得到多项式形式，我们将整个方程乘以 $p^2$：\n$$\np^4 + N^2 = L p^2\n$$\n整理项后得到一个关于 $p$ 的单变量非线性方程：\n$$\np^4 - L p^2 + N^2 = 0\n$$\n我们定义一个连续可微的标量函数 $f(x)$，其根对应于素数因子：\n$$\nf(x) = x^4 - L x^2 + N^2\n$$\n问题现在简化为求解 $f(x) = 0$ 的较小正根。\n\n**2. 牛顿法所需导数的推导**\n\n牛顿法需要函数 $f(x)$ 的导数，记为 $f'(x)$。应用初等微积分中的幂法则进行微分：\n$$\nf'(x) = \\frac{d}{dx} \\left( x^4 - L x^2 + N^2 \\right)\n$$\n$$\nf'(x) = 4x^3 - 2Lx\n$$\n\n**3. 牛顿法的实现**\n\n牛顿法的迭代公式是：\n$$\nx_{k+1} = x_k - \\frac{f(x_k)}{f'(x_k)} = x_k - \\frac{x_k^4 - L x_k^2 + N^2}{4x_k^3 - 2Lx_k}\n$$\n问题指定了初始猜测值 $x_0 = \\sqrt{N}$。这是一个合乎逻辑的选择。由于 $p \\le q$，因此有 $p \\le \\sqrt{N} \\le q$。所以，初始猜测值位于 $f(x)=0$ 的两个正根之间。函数 $f(x)$ 是一个 'W' 形的四次函数，在 $x=0$ 处有一个局部极大值，在 $x = \\pm\\sqrt{L/2}$ 处有局部极小值。正如在验证中所确立的，$L \\ge 2N$，这蕴含着 $\\sqrt{L/2} \\ge \\sqrt{N}$。初始猜测值 $x_0 = \\sqrt{N}$ 位于区间 $(p, \\sqrt{L/2})$ 内。在此区间内，$f(x)$ 和 $f'(x)$ 均为负值，导致项 $f(x)/f'(x)$ 为正值。更新式 $x_{k+1} = x_k - (\\text{正值})$ 确保了迭代序列 $x_k$ 单调递减并收敛到较小的根 $p$。\n\n迭代过程如下：\n1.  初始化 $x_k = \\sqrt{N}$。\n2.  迭代最多达到一个最大步数（例如 100）以保证终止。\n3.  在每一步中，计算更新量 $\\Delta x = f(x_k)/f'(x_k)$。\n4.  更新估计值：$x_{k+1} = x_k - \\Delta x$。\n5.  如果更新量的绝对值 $|\\Delta x|$ 小于指定的容差 $\\epsilon$（例如 $10^{-9}$），则终止。\n6.  一旦迭代收敛到一个根 $x^*$，该值就是 $p$ 的一个浮点近似值。\n\n**4. 最终结果计算**\n\n收敛的根 $x^*$ 必须转换为最终的整数答案。\n1.  将数值根四舍五入到最近的整数，以获得因子的整数估计值：$p_{\\text{est}} = \\text{round}(x^*)$。\n2.  计算相应的另一个因子：$q_{\\text{est}} = \\text{round}(N / p_{\\text{est}})$。\n3.  问题要求返回较小的素数因子 $p$。确定这一点的稳健方法是取两个估计值的最小值：$\\min(p_{\\text{est}}, q_{\\text{est}})$。这种方法能正确识别出较小的因子，无论数值方法可能收敛到哪个根，尽管我们选择的 $x_0$ 能确保收敛到 $p$。\n\n该过程将应用于测试套件中的每一对 $(N, L)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the smaller prime factor p given N=pq and L=p^2+q^2\n    using Newton's method.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (17473, 40130),    # Instance A\n        (272953, 548210),   # Instance B\n        (119989, 1539578),  # Instance C\n        (1005973, 2012090), # Instance D\n    ]\n\n    results = []\n    for N, L in test_cases:\n        # This function implements Newton's method to find a root of\n        # f(x) = x^4 - L*x^2 + N^2 = 0.\n        \n        # Initial guess as specified: x_0 = sqrt(N).\n        # This guess is between the two positive roots p and q,\n        # and closer to the smaller root p.\n        x = np.sqrt(N)\n        \n        # Parameters for Newton's method\n        max_iterations = 100\n        tolerance = 1e-9\n        \n        for i in range(max_iterations):\n            # Evaluate the function f(x) and its derivative f'(x).\n            # f(x) = x^4 - L*x^2 + N^2\n            # f'(x) = 4*x^3 - 2*L*x\n            x_sq = x * x\n            fx = x_sq * x_sq - L * x_sq + N * N\n            \n            dfx = 4.0 * x * x_sq - 2.0 * L * x\n            \n            # Avoid division by zero, though unlikely for this problem's setup.\n            if abs(dfx) < 1e-12:\n                break\n                \n            # Newton's method update step\n            step = fx / dfx\n            x = x - step\n            \n            # Check for convergence\n            if abs(step) < tolerance:\n                break\n        \n        # The iteration converges to a high-precision estimate of one of the roots.\n        # Since the initial guess x_0 = sqrt(N) is closer to p (p <= sqrt(N)),\n        # the method converges to p.\n        x_root = x\n        \n        # Map the numerical root to the integer factor.\n        # Round the result to the nearest integer to get the first factor candidate.\n        factor1 = int(round(x_root))\n        \n        # Compute the other factor candidate using the definition N = pq.\n        # Rounding here handles any small floating-point inaccuracies.\n        factor2 = int(round(N / factor1))\n        \n        # The smaller of the two factors is the required prime p.\n        p = min(factor1, factor2)\n        results.append(p)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2398877"}]}