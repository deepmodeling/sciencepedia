{"hands_on_practices": [{"introduction": "开普勒方程是天体力学中的基石，用于描述天体在椭圆轨道上的位置。然而，它是一个超越方程，无法直接解析求解出偏近点角 $E$。这个练习将引导你使用像牛顿-拉夫逊法这样的强大迭代方法，来高效地找到这个方程的数值解 [@problem_id:2434125]。通过这个实践，你不仅能将一个重要的物理定律转化为数值算法，还能体会到数值方法在解决经典科学问题中的威力。", "problem": "给定标量非线性方程（用于椭圆运动的开普勒方程）$M = E - e \\sin(E)$，其参数为 $e \\in [0,1)$ 和 $M \\in [0,2\\pi)$。对于每对参数，请以高数值精度确定满足该方程的唯一解 $E \\in [0,2\\pi]$。所有角度必须以弧度为单位进行处理和报告。\n\n定义函数 $f(E) = E - e \\sin(E) - M$。对于每个给定的参数对 $(e,M)$，计算唯一根 $E$ 使得 $f(E) = 0$，并满足以下正确性要求：\n- 绝对残差必须满足 $\\lvert f(E) \\rvert \\leq 10^{-13}$。\n- 报告的解必须四舍五入到12位小数。\n\n测试套件（每对为 $(e,M)$，其中 $M$ 的单位为弧度）：\n- 案例1：$(e,M) = (0.999, 0.001)$。\n- 案例2：$(e,M) = (0.9999, \\pi)$。\n- 案例3：$(e,M) = (0.9, 2.0)$。\n- 案例4：$(e,M) = (0.0, 4.0)$。\n- 案例5：$(e,M) = (0.999999, 0.000001)$。\n- 案例6：$(e,M) = (0.9995, 2\\pi - 0.000001)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序与上述测试套件相同。每个$E$值都需四舍五入到12位小数，例如：$[E_1,E_2,E_3,E_4,E_5,E_6]$，其中每个$E_k$是单位为弧度的十进制数，四舍五入到12位小数，且不打印任何额外文本。", "solution": "该问题要求在给定离心率 $e$ 和平近点角 $M$ 的情况下，对开普勒方程 $M = E - e \\sin(E)$ 进行数值求解，以得到偏近点角 $E$。这是计算天体动力学中的一项基本任务。在进行求解之前，我们必须严格地验证问题陈述的有效性。\n\n给定的条件是：\n- 方程：$M = E - e \\sin(E)$\n- 参数范围：离心率 $e \\in [0, 1)$，平近点角 $M \\in [0, 2\\pi)$\n- 解域：偏近点角 $E \\in [0, 2\\pi]$\n- 测试案例：六对 $(e, M)$ 参数。\n- 数值要求：残差 $|E - e \\sin(E) - M| \\leq 10^{-13}$，且结果必须四舍五入到12位小数。\n\n该问题具有科学依据，植根于天体力学。它是适定的、客观的，并包含了确定唯一解所需的所有信息。测试案例包含了一些对数值方法具有挑战性的情景，例如高离心率（$e \\approx 1$）与接近 $0$ 或 $2\\pi$ 的平近点角相结合的情况，但这些情况在物理上和数学上仍然是有效的。因此，该问题是有效的，我们可以继续进行求解。\n\n任务是对于给定的参数 $e$ 和 $M$，找到标量函数 $f(E) = E - e \\sin(E) - M$ 的根。\n\n首先，我们确定对于任意 $M \\in [0, 2\\pi)$ 和 $e \\in [0, 1)$，解 $E \\in [0, 2\\pi]$ 的存在性和唯一性。$f(E)$ 对 $E$ 的一阶导数是：\n$$ f'(E) = \\frac{d}{dE} (E - e \\sin(E) - M) = 1 - e \\cos(E) $$\n由于 $e \\in [0, 1)$，我们有 $e  1$。余弦函数是有界的，即 $|\\cos(E)| \\le 1$。因此，对于任意 $E$，$e \\cos(E)  1$。这意味着导数 $f'(E)$ 对所有 $E$ 都严格为正：\n$$ f'(E) = 1 - e \\cos(E)  1 - e  0 $$\n导数严格为正意味着 $f(E)$ 是一个严格单调递增的函数。这样的函数与轴 $f(E)=0$ 最多只有一个交点，这保证了根的唯一性。\n\n为证明存在性，我们计算函数在定义域 $[0, 2\\pi]$ 边界处的值：\n$$ f(0) = 0 - e \\sin(0) - M = -M $$\n$$ f(2\\pi) = 2\\pi - e \\sin(2\\pi) - M = 2\\pi - M $$\n给定 $M \\in [0, 2\\pi)$，我们有 $f(0) = -M \\le 0$ 和 $f(2\\pi) = 2\\pi - M  0$。由于 $f(E)$ 在区间 $[0, 2\\pi]$ 上是连续的且符号发生变化，根据介值定理，该区间内至少存在一个根 $E$。结合唯一性，这证实了在 $[0, 2\\pi]$ 中存在唯一的根。\n\n为了数值求解这个根，我们采用牛顿-拉夫逊方法。这是一个高效的迭代算法，在有利条件下具有二次收敛性。从 $E_k$ 得到逐次逼近值 $E_{k+1}$ 的迭代公式为：\n$$ E_{k+1} = E_k - \\frac{f(E_k)}{f'(E_k)} = E_k - \\frac{E_k - e \\sin(E_k) - M}{1 - e \\cos(E_k)} $$\n该方法需要一个初始猜测值 $E_0$。对于开普勒方程，一个简单且通常有效的选择是 $E_0 = M$。尽管存在更复杂的初始猜测值，特别是在 $e \\to 1$ 且 $M \\to 0$ 或 $M \\to 2\\pi$ 的挑战性情况下，但选择 $E_0=M$ 对于所有给定的测试案例都足够鲁棒以实现收敛。迭代过程持续进行，直到残差的绝对值 $|f(E_k)|$ 小于或等于指定的容差 $10^{-13}$。\n\n对于每对 $(e, M)$ 的算法如下：\n1. 设置偏近点角的初始猜测值：$E \\leftarrow M$。\n2. 开始一个迭代循环：\n   a. 计算残差：$r = E - e \\sin(E) - M$。\n   b. 检查收敛性：如果 $|r| \\le 10^{-13}$，则终止循环。\n   c. 计算导数：$g = 1 - e \\cos(E)$。\n   d. 更新偏近点角的估计值：$E \\leftarrow E - r/g$。\n3. 循环终止后，得到的 $E$ 值即为解。然后根据要求将此解四舍五入到12位小数。该过程系统地应用于所有测试案例。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves Kepler's equation for a suite of test cases using the Newton-Raphson method.\n    \"\"\"\n    \n    # Test cases: each tuple is (eccentricity, mean_anomaly_in_radians)\n    test_cases = [\n        (0.999, 0.001),\n        (0.9999, np.pi),\n        (0.9, 2.0),\n        (0.0, 4.0),\n        (0.999999, 0.000001),\n        (0.9995, 2 * np.pi - 0.000001),\n    ]\n\n    results = []\n    \n    # Numerical tolerance for the residual\n    TOLERANCE = 1e-13\n    # Maximum number of iterations to prevent infinite loops\n    MAX_ITERATIONS = 50\n\n    for e, M in test_cases:\n        # For e=0, the equation simplifies to E = M.\n        if e == 0.0:\n            results.append(round(M, 12))\n            continue\n        \n        # For M=pi and M=0 (or 2pi), E=M is the root due to sin(M)=0.\n        if M == np.pi or M == 0.0 or M == 2 * np.pi:\n            results.append(round(M, 12))\n            continue\n\n        # Initial guess for Newton-Raphson method\n        E = M\n\n        for _ in range(MAX_ITERATIONS):\n            # Function f(E) = E - e*sin(E) - M\n            residual = E - e * np.sin(E) - M\n            \n            # Check for convergence\n            if abs(residual) = TOLERANCE:\n                break\n            \n            # Derivative f'(E) = 1 - e*cos(E)\n            gradient = 1 - e * np.cos(E)\n            \n            # Newton-Raphson update step\n            E = E - residual / gradient\n        \n        # Round the final result to 12 decimal places\n        results.append(round(E, 12))\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2434125"}, {"introduction": "从天体物理学转向地球上的工程应用，柯尔布鲁克方程在计算管道内湍流的摩擦系数时至关重要。与开普勒方程类似，这个方程也是隐式的，无法直接求解。这个练习通过一个在流体力学中广泛应用的公式，进一步巩固了牛顿法在求解复杂非线性问题上的应用 [@problem_id:2434180]。它展示了求根技术在不同学科中的通用性，并让你有机会处理更复杂的函数形式。", "problem": "考虑用于模拟圆形管道中完全发展的湍流内流的达西摩擦因子隐式 Colebrook 关系式，其表达式为\n$$\n\\frac{1}{\\sqrt{f_D}} \\;=\\; -2.0\\,\\log_{10}\\!\\left(\\frac{\\epsilon/D}{3.7} \\;+\\; \\frac{2.51}{\\text{Re}\\,\\sqrt{f_D}}\\right),\n$$\n其中 $f_D$ 是达西摩擦因子（无量纲），$\\epsilon/D$ 是相对粗糙度（无量纲），$\\text{Re}$ 是雷诺数（无量纲），$\\log_{10}$ 表示以 10 为底的对数。对于下方的每一组参数，确定唯一的、物理相关的解 $f_D \\in (0,1)$，该解满足方程，且方程本身的绝对残差容差在 $10^{-12}$ 以内。\n\n使用以下参数值测试集 $(\\text{Re},\\,\\epsilon/D)：$\n- 测试 $1$：$(10^5,\\;0)$\n- 测试 $2$：$(4000,\\;10^{-4})$\n- 测试 $3$：$(10^6,\\;2.5\\times 10^{-4})$\n- 测试 $4$：$(10^7,\\;5.0\\times 10^{-3})$\n- 测试 $5$：$(3.0\\times 10^4,\\;10^{-2})$\n\n要求：\n- 将所有量视为无量纲。\n- 对于每次测试，返回满足方程且绝对残差小于 $10^{-12}$ 的单个标量 $f_D$。\n- 将每个报告的 $f_D$ 四舍五入到 8 位小数。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果与测试顺序相同，例如 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$，其中每个 $\\text{result}_i$ 是对应测试的 $f_D$ 的四舍五入值。", "solution": "所提出的问题是针对隐式 Colebrook 方程的一个标准求根任务，该方程是流体力学中关于湍流管流的一个基本关系式。需要采用数值方法，根据给定的雷诺数 $\\text{Re}$ 和相对粗糙度 $\\epsilon/D$ 来确定达西摩擦因子 $f_D$。\n\n控制方程为：\n$$\n\\frac{1}{\\sqrt{f_D}} \\;=\\; -2.0\\,\\log_{10}\\!\\left(\\frac{\\epsilon/D}{3.7} \\;+\\; \\frac{2.51}{\\text{Re}\\,\\sqrt{f_D}}\\right)\n$$\n为了应用求根算法，我们必须首先将方程表示为 $g(f_D) = 0$ 的规范形式。这通过移项整理实现：\n$$\ng(f_D) = \\frac{1}{\\sqrt{f_D}} + 2.0\\,\\log_{10}\\!\\left(\\frac{\\epsilon/D}{3.7} \\;+\\; \\frac{2.51}{\\text{Re}\\,\\sqrt{f_D}}\\right) = 0\n$$\nNewton-Raphson 方法是解决此问题的有效选择，在给定良好初始估计值的情况下可实现二次收敛。该方法需要函数 $g(f_D)$ 及其导数 $g'(f_D)$。为方便求导，使用自然对数来表示以 10 为底的对数：$\\log_{10}(x) = \\ln(x) / \\ln(10)$。\n我们定义常数 $C_1 = \\frac{\\epsilon/D}{3.7}$ 和 $C_2 = \\frac{2.51}{\\text{Re}}$。则函数 $g(f_D)$ 为：\n$$\ng(f_D) = f_D^{-1/2} + \\frac{2.0}{\\ln(10)} \\ln\\left( C_1 + C_2 f_D^{-1/2} \\right)\n$$\n$g(f_D)$ 关于 $f_D$ 的导数可通过应用标准微分法则求得：\n$$\ng'(f_D) = \\frac{d}{df_D} \\left( f_D^{-1/2} \\right) + \\frac{2.0}{\\ln(10)} \\frac{d}{df_D} \\left( \\ln\\left( C_1 + C_2 f_D^{-1/2} \\right) \\right)\n$$\n使用幂法则和链式法则，我们得到：\n$$\ng'(f_D) = -\\frac{1}{2} f_D^{-3/2} + \\frac{2.0}{\\ln(10)} \\frac{1}{C_1 + C_2 f_D^{-1/2}} \\left( C_2 \\cdot \\left(-\\frac{1}{2} f_D^{-3/2}\\right) \\right)\n$$\n提出公因式 $-\\frac{1}{2} f_D^{-3/2}$ 可以简化导数的表达式：\n$$\ng'(f_D) = -\\frac{1}{2} f_D^{-3/2} \\left[ 1 + \\frac{2.0 C_2}{\\ln(10) \\left( C_1 + C_2 f_D^{-1/2} \\right)} \\right]\n$$\nNewton-Raphson 迭代格式由以下关系式定义：\n$$\nf_{D, n+1} = f_{D, n} - \\frac{g(f_{D, n})}{g'(f_{D, n})}\n$$\n其中 $n$ 是迭代索引。该过程必须从一个初始猜测值 $f_{D, 0}$ 开始。高质量的初始猜测值可确保快速稳定的收敛。为此，我们使用显式 Haaland 方程，这是一个著名且精确的摩擦因子近似公式：\n$$\n\\frac{1}{\\sqrt{f_{D, 0}}} = -1.8 \\log_{10} \\left[ \\left(\\frac{\\epsilon/D}{3.7}\\right)^{1.11} + \\frac{6.9}{\\text{Re}} \\right]\n$$\n由此可分离出 $f_{D,0}$：\n$$\nf_{D, 0} = \\left( -1.8 \\log_{10} \\left[ \\left(\\frac{\\epsilon/D}{3.7}\\right)^{1.11} + \\frac{6.9}{\\text{Re}} \\right] \\right)^{-2}\n$$\n当残差的绝对值 $|g(f_{D, n})|$ 小于所需容差 $10^{-12}$ 时，迭代过程终止。\n\n要实现的算法如下：\n$1$. 对于每对参数 $(\\text{Re}, \\epsilon/D)$，计算常数 $C_1$ 和 $C_2$。\n$2$. 使用 Haaland 方程计算初始猜测值 $f_{D,0}$。\n$3$. 开始 Newton-Raphson 迭代循环。在每一步中，计算 $g(f_{D,n})$ 和 $g'(f_{D,n})$。\n$4$. 检查是否有 $|g(f_{D,n})|  10^{-12}$。如果为真，则解已收敛。\n$5$. 如果未收敛，计算下一个近似值 $f_{D,n+1}$ 并继续循环。应包含最大迭代次数的保护措施。\n$6$. 收敛后，按要求将最终的 $f_D$ 值四舍五入到 8 位小数。\n此过程将应用于每个测试用例，以生成最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Colebrook equation for the Darcy friction factor for a given\n    set of test cases using the Newton-Raphson method.\n    \"\"\"\n    TOLERANCE = 1e-12\n    MAX_ITERATIONS = 50\n\n    def solve_colebrook(Re, rel_rough):\n        \"\"\"\n        Calculates the Darcy friction factor f_D using Newton-Raphson.\n\n        Args:\n            Re (float): Reynolds number.\n            rel_rough (float): Relative roughness (epsilon/D).\n\n        Returns:\n            float: The calculated Darcy friction factor.\n        \"\"\"\n        # 1. Initial guess for f_D using the Haaland equation.\n        # This provides a very accurate starting point for the iteration.\n        haaland_term = (rel_rough / 3.7)**1.11 + 6.9 / Re\n        f_d = (-1.8 * np.log10(haaland_term))**-2\n\n        # 2. Define constants for the Colebrook equation.\n        c1 = rel_rough / 3.7\n        c2 = 2.51 / Re\n        ln10 = np.log(10)\n\n        # 3. Perform Newton-Raphson iteration.\n        for _ in range(MAX_ITERATIONS):\n            sqrt_fd = np.sqrt(f_d)\n            \n            # The function g(f_D) whose root we are seeking.\n            # g(f_D) = 1/sqrt(f_D) + 2.0*log10(c1 + c2/sqrt(f_D))\n            log_term_val = c1 + c2 / sqrt_fd\n            g = 1.0 / sqrt_fd + (2.0 / ln10) * np.log(log_term_val)\n\n            # Check for convergence based on the residual of the function g(f_D).\n            if abs(g)  TOLERANCE:\n                break\n            \n            # The derivative of the function, g'(f_D).\n            # g'(f_D) = -0.5*f_D**(-1.5) * [1 + (2.0*c2 / (ln(10)*(c1 + c2/sqrt(f_D))))]\n            g_prime = (-0.5 * f_d**-1.5) * (1.0 + (2.0 * c2) / (ln10 * log_term_val)  )\n            \n            # Update step for Newton-Raphson method.\n            f_d = f_d - g / g_prime\n        \n        return f_d\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1e5, 0.0),             # Test 1\n        (4000.0, 1e-4),         # Test 2\n        (1e6, 2.5e-4),          # Test 3\n        (1e7, 5.0e-3),          # Test 4\n        (3.0e4, 1e-2)           # Test 5\n    ]\n\n    results = []\n    for Re_val, rel_rough_val in test_cases:\n        # Calculate the friction factor for the current case.\n        f_d_solution = solve_colebrook(Re_val, rel_rough_val)\n        # Round the result to 8 decimal places as required.\n        results.append(f\"{f_d_solution:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2434180"}, {"introduction": "在成功应用了牛顿法之后，理解其局限性也同样重要。本练习探讨了一种在实际计算中可能遇到的典型失败情景。它深入分析了当使用数值方法近似计算导数时，浮点运算中的“灾难性抵消”现象是如何导致牛顿法失效的 [@problem_id:2434157]。这项“头脑实践”旨在培养你对数值稳定性的深刻理解，教会你在使用数值工具时保持批判性思维和敏锐的洞察力。", "problem": "一个标量非线性方程 $f(x)=0$ 将通过牛顿-拉夫逊迭代法求解，其中导数通过在浮点运算中计算的对称差商来近似：\n$$\nf'(x)\\approx \\frac{f(x+h)-f(x-h)}{2h}.\n$$\n考虑函数 $f(x)= (x-1)^{8}-10^{-8}$，该函数在 $x=1$ 处有一个非常平坦的极小值点。初始猜测值为 $x_0=1+10^{-3}$。导数使用上述对称差分进行近似，步长为 $h=10^{-16}$。所有函数求值和算术运算均在电气和电子工程师协会 (Institute of Electrical and Electronics Engineers, IEEE) 754 双精度下进行，单位舍入误差为 $u=2^{-53}\\approx 1.11\\times 10^{-16}$，且每个计算出的函数值 $\\widehat{f}(x)$ 满足 $|\\widehat{f}(x)-f(x)|\\le u\\,|f(x)|$。\n\n哪个选项最能描述第一次计算出的牛顿更新量 $\\Delta x_0 = -f(x_0) / \\widehat{f}'(x_0)$ 及其数值原因？\n\nA. 分子 $f(x_0+h)-f(x_0-h)$ 被舍入误差主导，因此 $\\widehat{f}'(x_0)$ 的量级约为 $5\\times 10^{-9}$，且 $\\Delta x_0 \\approx +2$，这使得 $x_1$ 远离根。\n\nB. 有限差分得到的结果恰好是 $\\widehat{f}'(x_0)=0$，因此牛顿更新量因除以零而未定义。\n\nC. 有限差分的相对误差精度为 $\\mathcal{O}(u)$，因此 $\\widehat{f}'(x_0)\\approx f'(x_0)=8\\times 10^{-21}$ 且 $\\Delta x_0 \\approx +1.25\\times 10^{12}$。\n\nD. 选择更小的步长，例如 $h=10^{-20}$，会减少 $f(x_0+h)-f(x_0-h)$ 中的相消误差，并恢复可靠的导数估计和收敛性。", "solution": "首先必须验证问题陈述的科学合理性和一致性。\n\n**步骤 1：提取已知条件**\n-   非线性方程: $f(x) = 0$。\n-   函数: $f(x) = (x-1)^8 - 10^{-8}$。\n-   数值方法: 牛顿-拉夫逊迭代法。\n-   导数近似: 对称差商，$\\widehat{f}'(x) = \\frac{\\widehat{f}(x+h) - \\widehat{f}(x-h)}{2h}$。\n-   初始猜测值: $x_0 = 1 + 10^{-3}$。\n-   有限差分步长: $h = 10^{-16}$。\n-   算术精度: 电气和电子工程师协会 (Institute of Electrical and Electronics Engineers, IEEE) $754$ 双精度。\n-   单位舍入误差: $u = 2^{-53} \\approx 1.11 \\times 10^{-16}$。\n-   函数求值误差模型: $|\\widehat{f}(x) - f(x)| \\le u|f(x)|$，其中 $\\widehat{f}(x)$ 是 $f(x)$ 的计算值。\n-   待分析量: 第一次牛顿更新量 $\\Delta x_0 = -f(x_0)/\\widehat{f}'(x_0)$。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学基础：** 该问题完全基于数值分析的既定原则，特别是标量求根（牛顿-拉夫逊法）、数值微分（有限差分）和浮点运算（IEEE $754$ 误差分析）。函数 $f(x)$ 是一个标准示例，用于测试数值算法在存在近乎平坦区域时的稳健性。所有参数都已定义，并与典型的计算工程场景一致。\n-   **适定性：** 问题是适定的。它要求在指定的数值条件下分析一个确定性算法的第一步。结果可以从给定的信息中推导出。\n-   **客观性：** 问题陈述使用精确、客观的语言表达，没有歧义或主观论断。\n\n**步骤 3：结论与行动**\n问题陈述是有效的。可以推导出严谨的解。\n\n**求解过程**\n牛顿-拉夫逊迭代由 $x_{k+1} = x_k - f(x_k)/f'(x_k)$ 给出。我们被要求分析第一次更新量 $\\Delta x_0 = -f(x_0)/f'(x_0)$，其中导数 $f'(x_0)$ 被数值近似为 $\\widehat{f}'(x_0)$。\n\n首先，我们在初始猜测值 $x_0 = 1 + 10^{-3}$ 处计算函数值：\n$$\nf(x_0) = f(1 + 10^{-3}) = ((1 + 10^{-3}) - 1)^8 - 10^{-8} = (10^{-3})^8 - 10^{-8} = 10^{-24} - 10^{-8}\n$$\n在浮点运算中，项 $10^{-24}$ 远小于 $10^{-8}$，会因吸收或舍入而丢失。因此，计算值将约为 $\\widehat{f}(x_0) \\approx -10^{-8}$。\n\n接下来，我们分析在 $x_0$ 处的导数数值近似：\n$$\n\\widehat{f}'(x_0) = \\frac{\\widehat{f}(x_0+h) - \\widehat{f}(x_0-h)}{2h}\n$$\n其中 $x_0 = 1 + 10^{-3}$ 且 $h = 10^{-16}$。\n\n分析的核心在于分子 $\\widehat{f}(x_0+h) - \\widehat{f}(x_0-h)$ 的计算。这涉及到两个几乎相等的数相减，是灾难性相消的典型场景。\n\n我们来确定被减项的量级。对于 $x_0$ 邻域内的 $y$，函数值为：\n$$\nf(y) = (y-1)^8 - 10^{-8} \\approx (x_0-1)^8 - 10^{-8} = (10^{-3})^8 - 10^{-8} \\approx -10^{-8}\n$$\n所以，$f(x_0+h)$ 和 $f(x_0-h)$ 都非常接近 $-10^{-8}$。\n\n根据问题的误差模型，计算值 $\\widehat{f}(y)$ 的绝对误差为 $|\\widehat{f}(y) - f(y)| \\le u|f(y)|$。对于 $y=x_0 \\pm h$，这个绝对误差约为：\n$$\n\\text{Error}(\\widehat{f}(y)) \\approx u |f(y)| \\approx (1.11 \\times 10^{-16}) \\times |-10^{-8}| \\approx 1.11 \\times 10^{-24}\n$$\n分子的真实值由泰勒展开给出：\n$$\nf(x_0+h) - f(x_0-h) = 2h f'(x_0) + O(h^3)\n$$\n精确导数是 $f'(x) = 8(x-1)^7$。在 $x_0$ 处，该值为 $f'(x_0) = 8(10^{-3})^7 = 8 \\times 10^{-21}$。\n所以，分子的真实值约为 $2h f'(x_0) = 2(10^{-16})(8 \\times 10^{-21}) = 1.6 \\times 10^{-36}$。\n\n当计算分子 $\\widehat{f}(x_0+h) - \\widehat{f}(x_0-h)$ 时，其真实值（$1.6 \\times 10^{-36}$）完全被两项的舍入误差所淹没。两个数的相减，每个数都有约 $10^{-24}$ 的绝对舍入误差，其计算出的差值实际上是噪声。这个噪声的量级与原始舍入误差的量级相当。\n$$\n|\\text{Numerator}| \\approx |\\widehat{f}(x_0+h) - \\widehat{f}(x_0-h)| \\approx u|f(x_0)| \\sim 10^{-24}\n$$\n这个结果的符号基本上是随机的。\n\n现在，我们可以估计计算出的导数：\n$$\n\\widehat{f}'(x_0) = \\frac{\\text{Numerator}}{2h} \\approx \\frac{\\pm O(10^{-24})}{2 \\times 10^{-16}} \\approx \\pm O(0.5 \\times 10^{-8}) = \\pm O(5 \\times 10^{-9})\n$$\n计算出的导数量级约为 $5 \\times 10^{-9}$。\n\n最后，我们计算牛顿更新量 $\\Delta x_0$：\n$$\n\\Delta x_0 = -\\frac{\\widehat{f}(x_0)}{\\widehat{f}'(x_0)} \\approx -\\frac{-10^{-8}}{\\pm 5 \\times 10^{-9}} = \\pm \\frac{10^{-8}}{5 \\times 10^{-9}} = \\pm 2\n$$\n牛顿更新量的量级约为 $2$。这将使得下一个迭代值 $x_1 = x_0 + \\Delta x_0 \\approx 1.001 \\pm 2$，远离开近 $x=1.1$ 和 $x=0.9$ 的真实根。\n\n**逐项分析选项**\n\nA. 分子 $f(x_0+h)-f(x_0-h)$ 被舍入误差主导，因此 $\\widehat{f}'(x_0)$ 的量级约为 $5\\times 10^{-9}$，且 $\\Delta x_0 \\approx +2$，这使得 $x_1$ 远离根。\n该选项正确地指出分子被舍入误差（灾难性相消）主导。计算出的导数量级 $\\approx 5 \\times 10^{-9}$ 和随后的牛顿更新量 $\\Delta x_0 \\approx +2$ 与我们的推导精确匹配。这个更新量会使迭代值远离根的结论也是正确的。更新量的符号取决于舍入误差的随机符号，但其量级是数值失败的关键指标。\n结论：**正确**。\n\nB. 有限差分得到的结果恰好是 $\\widehat{f}'(x_0)=0$，因此牛顿更新量因除以零而未定义。\n如果参数的浮点表示完全相同，即 $fl(x_0+h) = fl(x_0-h)$，就会发生这种情况。由于 $h = 10^{-16}$ 且在 1 附近的浮点数间距为 $\\text{ulp}(1) = 2^{-52} \\approx 2.22 \\times 10^{-16}$，参数之间的距离 $2h=2 \\times 10^{-16}$ 与一个 ulp 相当。不能保证它们会舍入为同一个数。更普遍的现象是灾难性相消产生一个无意义的非零结果。因此，与 A 中描述的情况相比，这种特定结果对一般问题的代表性较差。\n结论：**不正确**。\n\nC. 有限差分的相对误差精度为 $\\mathcal{O}(u)$，因此 $\\widehat{f}'(x_0)\\approx f'(x_0)=8\\times 10^{-21}$ 且 $\\Delta x_0 \\approx +1.25\\times 10^{12}$。\n该选项声称导数计算是准确的。这从根本上是错误的。所选的步长 $h = 10^{-16}$ 太小了，会导致灾难性相消，而不是一个准确的结果。与 $u/h$ 成正比的舍入误差，主导了与 $h^2$ 成正比的截断误差。所给出的计算对应于没有舍入误差的理想情况，这与问题设定相矛盾。\n结论：**不正确**。\n\nD. 选择更小的步长，例如 $h=10^{-20}$，会减少 $f(x_0+h)-f(x_0-h)$ 中的相消误差，并恢复可靠的导数估计和收敛性。\n这种说法是不正确的。在有限差分公式中，由相消引起的误差量级为 $O(u/h)$。将 $h$ 从 $10^{-16}$ 减小到 $10^{-20}$ 将会*增加*舍入误差，使得导数估计更加不可靠。为了获得更好的估计，必须选择一个更大的步长，以平衡舍入误差与截断误差（量级为 $O(h^2)$）。\n结论：**不正确**。", "answer": "$$\\boxed{A}$$", "id": "2434157"}]}