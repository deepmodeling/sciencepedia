{"hands_on_practices": [{"introduction": "计算几何的核心思想之一是根据邻近性对空间进行划分。这个练习将通过构建一个离散的沃罗诺伊图来让你亲身体验这一概念。通过在网格上使用曼哈顿距离（$L_1$ 范数），你将直接应用“最近”的定义，为每个“站点”划分其势力范围，而无需处理连续空间中复杂算法的开销，这是一个理解空间划分基本原理的绝佳起点。[@problem_id:3223457]", "problem": "给定平面上的一个有限位置点集，每个位置点都有整数坐标，以及一个具有整数端点的矩形域。对于给定的曼哈顿（也称为 $L_1$）距离，一个位置点的受限 Voronoi 单元是域的一个子集，由所有比其他任何位置点更接近该位置点的点组成，距离相等的情况将以确定性方式处理。您的任务是，对于几个测试用例，计算限制在矩形域的整数格点上的离散 $L_1$ Voronoi 图，并报告分配给每个位置点的格点数量。\n\n定义和假设：\n- 两点 $(x,y)$ 和 $(a,b)$ 之间的曼哈顿距离为 $d_1\\big((x,y),(a,b)\\big) = |x-a| + |y-b|$。\n- 给定一个位置点集 $S = \\{p_1, p_2, \\dots, p_k\\}$，其中 $p_i = (x_i, y_i)$，以及一个矩形域 $R = [x_{\\min}, x_{\\max}] \\times [y_{\\min}, y_{\\max}]$，位置点 $p_i$ 的离散受限 Voronoi 单元是\n$$\nV_R(p_i) = \\left\\{(x,y) \\in \\mathbb{Z}^2 : x_{\\min} \\le x \\le x_{\\max},\\ y_{\\min} \\le y \\le y_{\\max},\\ d_1\\big((x,y),p_i\\big) \\le d_1\\big((x,y),p_j\\big)\\ \\text{for all}\\ j \\in \\{1,\\dots,k\\}\\right\\}.\n$$\n- 距离相等的情况通过最小的位置点索引来解决：如果对于多个 $i$，点 $(x,y)$ 满足 $d_1\\big((x,y),p_i\\big) = d_1\\big((x,y),p_j\\big)$，则将 $(x,y)$ 分配给这些最小化者中索引最小的位置点。\n- 所有坐标都是整数；不涉及物理单位。\n\n您的程序必须从第一性原理出发实现以下内容：\n- 对于每个测试用例，遍历 $R$ 中的所有整数格点，并根据曼哈顿距离规则和距离相等处理规则将每个点精确地分配给一个位置点。\n- 对于每个测试用例，输出一个长度为 $k$ 的整数列表，其中第 $i$ 个整数是分配给位置点 $p_i$ 的格点数量。\n\n测试套件（每个用例由一个域和按指定顺序排列的位置点列表组成）：\n- 用例 1：$R = [0,8] \\times [0,8]$，$S = \\{(1,1),(6,2),(5,7)\\}$。\n- 用例 2：$R = [0,6] \\times [0,6]$，$S = \\{(2,2),(4,4),(6,2)\\}$。\n- 用例 3：$R = [0,6] \\times [0,6]$，$S = \\{(3,3)\\}$。\n- 用例 4：$R = [0,5] \\times [0,5]$，$S = \\{(-1,2),(7,2),(2,-1),(2,7)\\}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。顶层列表每个测试用例对应一个内部列表，顺序与上述相同，每个内部列表按该用例中给定的位置点顺序包含位置点计数。例如，一个包含两个用例的有效输出字符串应类似于 $[[a_1,a_2],[b_1,b_2,b_3]]$，不含空格。\n- 不得打印任何附加文本。\n\n约束和期望：\n- 使用距离和 Voronoi 单元的基本定义来证明您的方法。避免使用快捷公式或依赖外部专门的计算几何例程。\n- 您的算法必须在给定矩形内的整数格点上操作，并遵守确定性的距离相等处理规则。\n- 每个测试用例的答案是一个整数列表。聚合的单行输出是这些列表的列表。", "solution": "问题陈述需经过验证。\n\n### 步骤 1：提取已知条件\n- **任务**：在离散、受限的 $L_1$ Voronoi 图中，计算分配给每个位置点的整数格点数量。\n- **位置点集**：一个有限集合 $S = \\{p_1, p_2, \\dots, p_k\\}$，其中每个位置点 $p_i = (x_i, y_i)$ 具有整数坐标。\n- **域**：一个矩形域 $R = [x_{\\min}, x_{\\max}] \\times [y_{\\min}, y_{\\max}]$，其中端点为整数。\n- **距离度量**：曼哈顿（$L_1$）距离，定义为 $d_1\\big((x,y),(a,b)\\big) = |x-a| + |y-b|$。\n- **Voronoi 单元定义**：位置点 $p_i$ 的离散受限 Voronoi 单元是域 $R$ 内的整数点 $(x,y)$ 的集合，这些点比其他任何位置点 $p_j$ 更接近或等距于 $p_i$。\n$$V_R(p_i) = \\left\\{(x,y) \\in \\mathbb{Z}^2 : x_{\\min} \\le x \\le x_{\\max},\\ y_{\\min} \\le y \\le y_{\\max},\\ d_1\\big((x,y),p_i\\big) \\le d_1\\big((x,y),p_j\\big)\\ \\text{for all}\\ j \\in \\{1,\\dots,k\\}\\right\\}$$\n- **距离相等处理规则**：如果一个点 $(x,y)$ 到多个位置点的最小距离相同，则将其分配给输入位置点列表中索引最小的位置点。\n- **测试用例**：\n    1.  $R = [0,8] \\times [0,8]$，$S = \\{(1,1),(6,2),(5,7)\\}$。\n    2.  $R = [0,6] \\times [0,6]$，$S = \\{(2,2),(4,4),(6,2)\\}$。\n    3.  $R = [0,6] \\times [0,6]$，$S = \\{(3,3)\\}$。\n    4.  $R = [0,5] \\times [0,5]$，$S = \\{(-1,2),(7,2),(2,-1),(2,7)\\}$。\n- **输出**：一个单行字符串，表示一个列表的列表，其中每个内部列表包含给定测试用例中每个位置点的整数点数。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题在计算几何学中有充分的依据。Voronoi 图、曼哈顿距离和离散格点的概念是标准的数学和算法主题。\n- **适定性**：该问题是适定的。域是一个有限的整数点集。对于每个点，到每个位置点的距离都是唯一定义的。距离相等处理规则是确定性和详尽的，确保域中的每个点都只分配给一个位置点。因此，存在唯一的解（计数的集合）。\n- **客观性**：该问题使用精确、客观的数学语言陈述，没有歧义或主观性陈述。\n- **缺陷检查**：该问题不违反任何无效性标准。它在科学上是合理的、可形式化的、完整的且结构良好。\n\n### 步骤 3：结论和行动\n该问题是**有效的**。将提供一个解决方案。\n\n### 基于原理的解决方案\n该解决方案是所提供的离散、受限 Voronoi 图定义的直接实现。核心原理是根据与一组位置点 $S$ 的邻近度，对给定矩形域 $R$ 内的整数格点进行划分。\n\n设位置点集为 $S = \\{p_0, p_1, \\dots, p_{k-1}\\}$，其中索引对应于距离相等时的处理优先级。域 $R = [x_{\\min}, x_{\\max}] \\times [y_{\\min}, y_{\\max}]$ 定义了一个有限的整数点网格。我们必须考虑每个点 $q=(x,y)$，使得 $x \\in \\{x_{\\min}, \\dots, x_{\\max}\\}$ 和 $y \\in \\{y_{\\min}, \\dots, y_{\\max}\\}$。\n\n对于每个测试用例，算法按以下步骤进行：\n1.  将计数向量 $\\mathbf{c} = [c_0, c_1, \\dots, c_{k-1}]$ 初始化为全零。元素 $c_i$ 将存储分配给位置点 $p_i$ 的格点总数。\n2.  生成域 $R$ 内的所有整数格点 $q=(x,y)$。\n3.  对于每个点 $q$，计算其到每个位置点 $p_i \\in S$ 的曼哈顿距离 $d_1(q, p_i)$。将这些距离存储在一个序列 $D_q = (d_1(q,p_0), d_1(q,p_1), \\dots, d_1(q,p_{k-1}))$ 中。\n4.  确定点 $q$ 分配给哪个位置点。这通过找到序列 $D_q$ 中对应于最小值的索引 $i^*$ 来实现。问题规定，如果多个位置点共享相同的最小距离，则选择索引最小的那个。在数学上，这表示为：\n    $$i^* = \\arg\\min_{i \\in \\{0, \\dots, k-1\\}} \\{d_1(q, p_i)\\}$$\n    按照惯例，$\\arg\\min$ 函数返回达到最小值的第一个索引，从而满足距离相等处理规则。\n5.  为分配的位置点增加计数器：$c_{i^*} \\leftarrow c_{i^*} + 1$。\n6.  在遍历域中所有点 $q$ 之后，向量 $\\mathbf{c}$ 将包含每个位置点的最终计数。\n\n这种暴力枚举在计算上简单直接，并直接反映了数学定义。为了高效实现，我们可以采用向量化。我们可以构建两个矩阵 $X$ 和 $Y$，表示网格上每个点的 $x$ 和 $y$ 坐标。对于每个位置点 $p_i=(x_i, y_i)$，可以通过一次操作为整个网格计算一个距离矩阵 $D_i$：$D_i = |X - x_i| + |Y - y_i|$。然后，这 $k$ 个距离矩阵可以被堆叠成一个三维数组。接着可以沿位置点维度应用 `argmin` 操作，生成一个二维分配矩阵，其中每个元素包含对应网格点的获胜位置点的索引 $i^*$。最后，计算分配矩阵中每个索引的出现次数即可得到期望的结果。这种向量化方法不是捷径，而是对逐点评估这一基本原理的计算高效实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the number of lattice points in a restricted discrete L1 Voronoi diagram\n    for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (domain, list_of_sites)\n    # Domain is a tuple: (x_min, x_max, y_min, y_max)\n    # Sites are given as a list of (x, y) tuples.\n    test_cases = [\n        # Case 1\n        (((0, 8), (0, 8)), [(1, 1), (6, 2), (5, 7)]),\n        # Case 2\n        (((0, 6), (0, 6)), [(2, 2), (4, 4), (6, 2)]),\n        # Case 3\n        (((0, 6), (0, 6)), [(3, 3)]),\n        # Case 4\n        (((0, 5), (0, 5)), [(-1, 2), (7, 2), (2, -1), (2, 7)]),\n    ]\n\n    all_results = []\n    for domain_spec, sites_list in test_cases:\n        (x_min, x_max), (y_min, y_max) = domain_spec\n        sites = np.array(sites_list, dtype=np.int32)\n        num_sites = len(sites)\n\n        # Create the integer lattice grid for the domain\n        x_range = np.arange(x_min, x_max + 1)\n        y_range = np.arange(y_min, y_max + 1)\n        grid_x, grid_y = np.meshgrid(x_range, y_range)\n\n        # A list to hold the distance matrix for each site\n        all_dists = []\n\n        # For each site, calculate the L1 distance to every point in the grid\n        for site in sites:\n            site_x, site_y = site\n            dist_matrix = np.abs(grid_x - site_x) + np.abs(grid_y - site_y)\n            all_dists.append(dist_matrix)\n\n        # Stack the distance matrices into a 3D array (num_sites, height, width)\n        dist_stack = np.stack(all_dists, axis=0)\n\n        # Find the index of the site with the minimum distance for each grid point.\n        # np.argmin naturally handles the tie-breaking rule by returning the\n        # index of the first occurrence of the minimum value.\n        assignments = np.argmin(dist_stack, axis=0)\n\n        # Count the number of points assigned to each site.\n        # .flatten() turns the 2D assignment matrix into a 1D array.\n        # minlength ensures that even sites with 0 points are included in the count.\n        counts = np.bincount(assignments.flatten(), minlength=num_sites)\n        \n        all_results.append(counts.tolist())\n\n    # Final print statement in the exact required format: [[...],[...]]\n    # str() on a list adds spaces, so we remove them.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3223457"}, {"introduction": "在掌握了逐点分析之后，我们来学习一种更强大的算法范式：平面扫描。这个练习要求你计算一组矩形并集的面积，这是平面扫描算法的一个经典应用。通过将二维问题简化为沿扫描线的一系列一维问题，并结合高效的数据结构来管理状态，你将学会解决一整类复杂的几何测量问题。[@problem_id:3223497]", "problem": "给定欧几里得平面上有限个与坐标轴对齐的矩形。每个矩形由四个整数 $(x_1, y_1, x_2, y_2)$ 指定，其中 $x_1 \\le x_2$ 且 $y_1 \\le y_2$，分别代表左下角点 $(x_1, y_1)$ 和右上角点 $(x_2, y_2)$。若一个矩形的 $x_1 = x_2$ 或 $y_1 = y_2$，则其面积为零，对并集面积没有贡献。任务是使用基于计算几何第一性原理的平面扫描算法，高效地计算这些矩形并集的面积。\n\n基本依据与要求：\n- 平面上一组集合的并集面积是该并集的二维勒贝格测度。对于与坐标轴对齐的矩形，在常规欧几里得度量下，其并集面积是有限且良定义的。\n- 矩形是闭集，但只要所有矩形使用相同的边界约定（无论是闭、开还是半开），并集面积在任何边界约定选择下都是不变的，因为边界的测度为零。\n- 一种有效的方法是，概念上用一条垂直线沿 $x$ 轴扫描，同时维护当前活动 $y$ 区间并集的总长度。在两个连续的 $x$ 坐标位置之间累积的面积，等于这两个位置的水平距离乘以该“板”上被覆盖的 $y$ 轴长度。\n\n你的程序必须实现一个沿 $x$ 轴的高效平面扫描，并使用一种适当的数据结构（如带有坐标压缩的线段树 Segment Tree, ST）来维护 $y$ 区间并集的长度。对于 $n$ 个矩形，目标渐近时间复杂度为 $O(n \\log n)$。你必须处理重复矩形、嵌套矩形、不相交矩形、边缘接触、零面积矩形、负坐标以及不会超出典型64位整数范围的大坐标值。\n\n测试套件：\n计算以下每个独立测试用例的并集面积。在每个测试用例中，输入是一个由 $(x_1,y_1,x_2,y_2)$ 四元组表示的矩形列表。\n\n- 测试用例 $1$：$\\big((0,0,3,2),(2,1,5,4),(1,3,4,5)\\big)$\n- 测试用例 $2$：$\\big((0,0,2,1),(2,0,4,1)\\big)$\n- 测试用例 $3$：$\\big((0,0,10,10),(2,2,8,8)\\big)$\n- 测试用例 $4$：$\\big((0,0,1,1),(3,3,4,5)\\big)$\n- 测试用例 $5$：$\\big((0,0,2,2),(1,1,1,5),(2,2,5,2)\\big)$\n- 测试用例 $6$：$\\big((-3,-1,-1,2),(-2,1,1,3)\\big)$\n- 测试用例 $7$：$\\big((0,0,100000000,1),(50000000,0,150000000,1)\\big)$\n- 测试用例 $8$：$\\big((0,0,3,1),(0,1,3,2),(0,2,3,3),(1,-1,2,4)\\big)$\n\n输出规范：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。第 $i$ 个条目是测试用例 $i$ 的并集面积，表示为整数。例如，格式必须严格遵循 $\\texttt{[a_1,a_2,\\dots,a_8]}$，其中 $a_i$ 表示测试用例 $i$ 的计算面积。", "solution": "该问题要求使用平面扫描算法计算一组与坐标轴对齐的矩形并集的面积。该算法通过将二维面积问题转化为一系列一维区间问题来解决，其核心思想如下：\n\n1.  **事件点与扫描线**：我们将一条垂直的“扫描线”从左到右扫过整个平面。只有在扫描线遇到矩形的左边界或右边界时，并集的几何形状才会发生改变。因此，我们将所有矩形的左、右x坐标作为“事件点”。我们将这些事件点按x坐标排序。\n\n2.  **处理事件**：我们按顺序处理每个事件点。对于任意两个相邻的事件点 $x_i$ 和 $x_{i+1}$，它们之间的“条带”内，与扫描线相交的矩形集合是固定的。因此，在这个条带内增加的面积等于条带的宽度 $(x_{i+1} - x_i)$ 乘以当前被矩形覆盖的y轴区间的总长度。\n\n3.  **维护y轴区间**：关键挑战在于如何高效地计算当前被覆盖的y轴区间的总长度。这可以通过一个专门的数据结构——线段树（Segment Tree）来解决。\n    *   **坐标压缩**：由于矩形的y坐标可能很大且稀疏，我们首先收集所有矩形的不重复的 $y_1, y_2$ 坐标，并进行排序和离散化（坐标压缩）。这定义了一组基本的一维y轴区间。\n    *   **线段树**：我们基于这些压缩后的y轴区间构建一个线段树。树的每个叶节点代表一个基本的y轴区间，而每个内部节点代表其子节点区间的并集。\n    *   **更新与查询**：当扫描线遇到一个矩形的左边界 $(x_1, y_1, y_2)$ 时，我们在线段树中对 $[y_1, y_2]$ 对应的区间范围执行“增加”操作（将覆盖计数器加1）。当遇到右边界 $(x_2, y_1, y_2)$ 时，我们执行“减少”操作（计数器减1）。线段树的每个节点维护一个 `count`（表示该节点代表的区间被多少个活动矩形完全覆盖）和一个 `length`（表示该区间内实际被覆盖的长度）。如果一个节点的 `count > 0`，则其 `length` 就是该区间的实际长度；否则，其 `length` 是其子节点 `length` 的和。\n\n4.  **计算总面积**：在每次移动扫描线到下一个事件点之前，我们从线段树的根节点查询总的覆盖长度（即 `lengths[0]`），并将其乘以扫描线移动的距离（`dx`），累加到总面积中。\n\n通过这种方法，每个矩形产生两个事件。对 $2n$ 个事件排序需要 $O(n \\log n)$ 时间。每次事件处理中，线段树的更新操作需要 $O(\\log n)$ 时间（因为y坐标最多有 $2n$ 个）。因此，总时间复杂度为 $O(n \\log n)$，满足了问题的效率要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the union area of rectangles problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        [(0, 0, 3, 2), (2, 1, 5, 4), (1, 3, 4, 5)],\n        # Test case 2\n        [(0, 0, 2, 1), (2, 0, 4, 1)],\n        # Test case 3\n        [(0, 0, 10, 10), (2, 2, 8, 8)],\n        # Test case 4\n        [(0, 0, 1, 1), (3, 3, 4, 5)],\n        # Test case 5\n        [(0, 0, 2, 2), (1, 1, 1, 5), (2, 2, 5, 2)],\n        # Test case 6\n        [(-3, -1, -1, 2), (-2, 1, 1, 3)],\n        # Test case 7\n        [(0, 0, 100000000, 1), (50000000, 0, 150000000, 1)],\n        # Test case 8\n        [(0, 0, 3, 1), (0, 1, 3, 2), (0, 2, 3, 3), (1, -1, 2, 4)],\n    ]\n\n    results = []\n    for rectangles in test_cases:\n        area = calculate_union_area(rectangles)\n        results.append(area)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_union_area(rectangles):\n    \"\"\"\n    Calculates the area of the union of a list of axis-aligned rectangles.\n    \n    This function implements a plane sweep algorithm with a segment tree.\n    \"\"\"\n    events = []\n    y_coords = set()\n\n    for x1, y1, x2, y2 in rectangles:\n        # Per the problem statement, zero-area rectangles do not contribute.\n        if x1  x2 and y1  y2:\n            events.append((x1, y1, y2, 1))  # 1 for enter\n            events.append((x2, y1, y2, -1)) # -1 for leave\n            y_coords.add(y1)\n            y_coords.add(y2)\n\n    if not events:\n        return 0\n\n    # Sort events by x-coordinate\n    events.sort()\n\n    # Coordinate compression for y-coordinates\n    all_y = sorted(list(y_coords))\n    y_map = {y: i for i, y in enumerate(all_y)}\n    \n    num_y_intervals = len(all_y) - 1\n    if num_y_intervals = 0:\n        return 0\n\n    # Segment tree represented by numpy arrays.\n    # The size 4 * num_y_intervals is a safe upper bound for a segment tree.\n    counts = np.zeros(4 * num_y_intervals, dtype=int)\n    lengths = np.zeros(4 * num_y_intervals, dtype=int)\n\n\n    def update_segment_tree(node_idx, node_start, node_end, update_start, update_end, value):\n        \"\"\"Recursively update the segment tree.\"\"\"\n        # The range this node represents is [node_start, node_end].\n        # The range to update is [update_start, update_end].\n\n        # If the update range is outside the node's range, do nothing.\n        if update_start > node_end or update_end  node_start:\n            return\n\n        # If the node's range is completely within the update range.\n        if update_start = node_start and node_end = update_end:\n            counts[node_idx] += value\n        # Otherwise, recurse on children.\n        else:\n            mid = (node_start + node_end) // 2\n            left_child_idx = 2 * node_idx + 1\n            right_child_idx = 2 * node_idx + 2\n            update_segment_tree(left_child_idx, node_start, mid, update_start, update_end, value)\n            update_segment_tree(right_child_idx, mid + 1, node_end, update_start, update_end, value)\n        \n        # After updating counts, recalculate the covered length for this node.\n        if counts[node_idx] > 0:\n            # This node's entire y-interval range is covered.\n            lengths[node_idx] = all_y[node_end + 1] - all_y[node_start]\n        elif node_start == node_end:\n            # Leaf node with count 0 has 0 covered length.\n            lengths[node_idx] = 0\n        else:\n            # Internal node with count 0: covered length is sum of children's.\n            left_child_idx = 2 * node_idx + 1\n            right_child_idx = 2 * node_idx + 2\n            lengths[node_idx] = lengths[left_child_idx] + lengths[right_child_idx]\n\n\n    total_area = 0\n    last_x = events[0][0]\n\n    for event in events:\n        current_x, y1, y2, type_val = event\n        \n        # Calculate the area of the slab between last_x and current_x\n        dx = current_x - last_x\n        if dx > 0:\n            covered_length = lengths[0]  # Root of the segment tree\n            total_area += covered_length * dx\n        \n        # Process the current event by updating the segment tree\n        y1_idx = y_map[y1]\n        y2_idx = y_map[y2]\n\n        # The update is for the range of intervals [y1_idx, y2_idx - 1]\n        if y1_idx  y2_idx:\n            update_segment_tree(0, 0, num_y_intervals - 1, y1_idx, y2_idx - 1, type_val)\n\n        last_x = current_x\n        \n    return total_area\n\n# Execute the solution\nsolve()\n\n```", "id": "3223497"}, {"introduction": "现在，我们将挑战涉及复杂形状之间相互作用的问题。寻找两个凸多边形之间的最短距离是计算几何中一个典型的优化问题。这个练习引导你将问题分解为更简单的子问题（例如，边与边之间的距离），并应用微积分原理来寻找函数的最小值，从而揭示几何学与优化方法之间的深刻联系。[@problem_id:3223483]", "problem": "给定欧几里得平面上的两个封闭、严格不相交的凸多边形。对于每一对多边形，您必须计算一条最短的连接线段（“桥”），其一个端点在多边形 $A$ 的边界上，另一个端点在多边形 $B$ 的边界上。此问题必须基于计算几何的基本原理解决，除了基本的向量算术外，不得依赖任何专门的第三方库。\n\n将使用的基本基础和定义如下。凸多边形 $P$ 是 $\\mathbb{R}^2$ 中的一个紧凸子集，由有限个点的凸包给出；它可以通过一个逆时针（CCW）顺序的顶点循环序列来表示，其中连续的顶点由直线段连接，最后一个顶点与第一个顶点相连。向量 $x$ 的欧几里得范数为 $\\lVert x \\rVert_2 = \\sqrt{x_1^2 + x_2^2}$。两个非空集合 $X,Y \\subset \\mathbb{R}^2$ 之间的距离为 $d(X,Y) = \\inf\\{\\lVert x - y \\rVert_2 : x \\in X, y \\in Y\\}$。对于封闭、不相交的凸集，这个下确界至少可以由一对点达到。点 $p$ 和 $q$ 之间的线段是集合 $\\{(1 - t)p + tq : t \\in [0,1]\\}$。\n\n您的任务。对于下面的每个测试用例，执行以下操作：\n- 计算一对点 $(p^\\star, q^\\star)$，其中 $p^\\star \\in \\partial A$ 且 $q^\\star \\in \\partial B$，使得在所有 $p \\in \\partial A$，$q \\in \\partial B$ 中，欧几里得距离 $\\lVert p - q \\rVert_2$ 最小。这里 $\\partial A$ 和 $\\partial B$ 表示多边形的边界。\n- 在所有最小化点对中，按如下方式打破平局：选择在 $A$ 上的点是字典序最小的点对，如果仍然存在平局，则选择在 $B$ 上的点是字典序最小的点对，其中点的字典序定义为：如果 $x_1  x_2$ 或者 $(x_1 = x_2$ 且 $y_1  y_2)$，则 $(x_1,y_1) \\prec (x_2,y_2)$。\n- 报告桥的端点及其长度。\n\n不需要角度单位。不涉及物理单位。所需的数值输出必须四舍五入到 $6$ 位小数。\n\n此问题的输入模型固定在程序内部；不要读取任何外部输入。您必须使用以下凸多边形测试套件，每个多边形都以逆时针顺序的顶点有序列表形式给出，且末尾不重复第一个顶点。\n\n测试套件：\n- 测试用例 $1$：\n  - 多边形 $A$：$[(-2,-1),(-2,1),(-1,1),(-1,-1)]$。\n  - 多边形 $B$：$[(1,-0.5),(1,0.5),(2,0.5),(2,-0.5)]$。\n- 测试用例 $2$：\n  - 多边形 $A$：$[(0,0),(1,1),(0,2)]$。\n  - 多边形 $B$：$[(3,0.5),(3,1.5),(5,1.5),(5,0.5)]$。\n- 测试用例 $3$：\n  - 多边形 $A$：$[(0,0),(0,1),(4,1),(4,0)]$。\n  - 多边形 $B$：$[(1,3),(1,4),(5,4),(5,3)]$。\n- 测试用例 $4$：\n  - 多边形 $A$：$[(0,0),(0,1),(1,1),(1,0)]$。\n  - 多边形 $B$：$[(1.001,0),(1.001,1),(2.001,1),(2.001,0)]$。\n- 测试用例 $5$：\n  - 多边形 $A$：$[(0,0),(0,1),(1,1),(1,0)]$。\n  - 多边形 $B$：$[(3,3),(3,4),(4,4),(4,3)]$。\n\n要求：\n- 对于每个测试用例，输出所选桥端点在 $A$ 上的坐标 $(p^\\star_x,p^\\star_y)$ 和在 $B$ 上的坐标 $(q^\\star_x,q^\\star_y)$，然后是桥的长度 $\\ell^\\star = \\lVert p^\\star - q^\\star \\rVert_2$，所有数值都四舍五入到 $6$ 位小数。\n- 最终输出格式必须是单行，包含一个类似 JSON 的列表的列表，每个测试用例一个，并按顺序排列。每个内部列表必须是 $[p^\\star_x,p^\\star_y,q^\\star_x,q^\\star_y,\\ell^\\star]$ 的形式，所有数字都四舍五入到 $6$ 位小数。例如，一个包含两个结果的列表看起来像 $[[x_1,y_1,x_2,y_2,\\ell_1],[x_3,y_3,x_4,y_4,\\ell_2]]$。\n\n设计约束和指导：\n- 您的推理应基于基本定义：凸性、欧几里得范数以及紧集上连续函数的性质。\n- 您可以假设一个来自初等几何的著名且可验证的事实：两个不相交的封闭凸多边形之间的距离由位于它们边界上的一对点实现，对于多边形，最小化点出现在边或顶点上。但是，您不得使用任何预先推导的“快捷”公式来计算最终距离。相反，您必须通过在段参数的箱式约束下最小化一个二次型来推导两条线段之间的距离。\n- 为确保全面覆盖，给定的测试套件包括最近点位于顶点到边、具有平行支撑线的边到边、顶点到顶点以及近乎接触的情况。\n\n您的程序应生成单行输出，其中包含一个由内部列表组成的逗号分隔列表，并用方括号括起来，格式与上述规定完全一致。", "solution": "该问题要求我们找到欧几里得平面中两个不相交的封闭凸多边形 $A$ 和 $B$ 之间的最短连接线段，即“桥”。对于每对多边形，我们必须在其各自的边界 $\\partial A$ 和 $\\partial B$ 上确定一点对 $(p^\\star, q^\\star)$，以最小化欧几里得距离 $\\lVert p - q \\rVert_2$。\n\n该解决方案基于几何学和优化的基本原理。由于多边形是凸的且是紧集（即封闭且有界），根据 Weierstrass 极值定理，至少存在一对这样的最小化点对。两个多边形之间的距离 $d(A, B)$ 是两个多边形所有可能的特征（顶点和边）对之间距离的最小值。这可以表示为：\n$$\nd(A, B) = \\min_{i,j} d(e_i, f_j)\n$$\n其中 $e_i$ 是多边形 $A$ 的一条边，$f_j$ 是多边形 $B$ 的一条边。这种方法是全面的，因为一条边与另一个特征之间的距离隐含地覆盖了顶点到特征的距离，因为顶点是边的端点。\n\n正如题目指导的那样，问题的核心是确定两条线段之间的距离。设线段 $e_A$ 由其端点 $p_1, p_2$ 定义，另一条线段 $e_B$ 由 $q_1, q_2$ 定义。$e_A$ 上的任意点可以参数化为 $p(s) = p_1 + s(p_2 - p_1)$，其中 $s \\in [0,1]$；$e_B$ 上的任意点可以参数化为 $q(t) = q_1 + t(q_2 - q_1)$，其中 $t \\in [0,1]$。\n\n我们的目标是最小化平方欧几里得距离 $D^2(s,t) = \\lVert p(s) - q(t) \\rVert_2^2$，约束条件为 $s,t \\in [0,1]$。令 $u = p_2 - p_1$，$v = q_2 - q_1$，$w_0 = p_1 - q_1$。平方距离为：\n$$\nD^2(s,t) = \\lVert w_0 + su - tv \\rVert_2^2 = (w_0+su-tv) \\cdot (w_0+su-tv)\n$$\n这是一个关于 $s$ 和 $t$ 的二次函数：\n$$\nF(s,t) = (u \\cdot u)s^2 - 2(u \\cdot v)st + (v \\cdot v)t^2 + 2(w_0 \\cdot u)s - 2(w_0 \\cdot v)t + (w_0 \\cdot w_0)\n$$\n由于该函数是凸函数，其在定义域 $[0,1] \\times [0,1]$ 上的最小值要么出现在梯度为零的内部临界点，要么出现在定义域的边界上。\n\n临界点 $(s_0, t_0)$ 通过求解线性方程组 $\\nabla F(s,t) = 0$ 得到：\n$$\n\\begin{cases}\n(u \\cdot u) s - (u \\cdot v) t = -w_0 \\cdot u \\\\\n-(u \\cdot v) s + (v \\cdot v) t = w_0 \\cdot v\n\\end{cases}\n$$\n该方程组矩阵的行列式为 $(u \\cdot u)(v \\cdot v) - (u \\cdot v)^2$，根据 Cauchy-Schwarz 不等式，该值非负。如果行列式为正（即线段不平行），则存在唯一解 $(s_0, t_0)$。\n- 如果 $(s_0, t_0) \\in [0,1] \\times [0,1]$，则最短距离在内部点 $p(s_0)$ 和 $q(t_0)$ 之间。\n- 否则，最小值必须位于参数空间的边界上（即 $s \\in \\{0,1\\}$ 或 $t \\in \\{0,1\\}$）。这对应于计算一个线段的端点到另一整个线段的距离。例如，设置 $s=0$ 将问题简化为计算点 $p_1$到线段 $e_B$ 的最短距离。\n\n这为寻找两条线段之间距离提供了一个稳健的策略：\n1.  计算内部点到内部点的情况下的距离，这仅在求解出的参数 $(s_0, t_0)$ 位于 $[0,1]^2$ 内时有效。\n2.  计算四个端点到线段的距离：$d(p_1, e_B)$、$d(p_2, e_B)$、$d(q_1, e_A)$ 和 $d(q_2, e_A)$。\n3.  这些潜在距离中的最小值就是两条线段之间的真实最小距离。这涵盖了所有情况：顶点-顶点、顶点-边和边-边。\n\n整体算法分两步进行：\n**第一步：确定最小距离。** 遍历多边形 $A$ 和 $B$ 的所有边对 $(e_i, f_j)$。对于每对边，使用上述的线段-线段距离方法计算它们的最小平方距离。全局最小平方距离 $\\ell^{\\star 2}$ 是所有边对计算出的这些值中的最小值。\n\n**第二步：识别所有最优点对。** 再次遍历所有边对。对于每对边 $(e_i, f_j)$，找出这些线段上所有能达到距离 $\\ell^\\star$ 的点对 $(p,q)$。这需要仔细处理：\n-   如果最小值是由一个线段的端点和另一线段上的一个点实现的，那么多个边对可能会识别出相同的最优对（因为一个顶点由两条边共享）。\n-   如果线段平行且它们的投影重叠，则存在一个连续的最优点对集合。对于这种特殊情况，我们必须直接应用平局打破规则。选择边上字典序最小的点，该点对应于其端点之一。这样就从连续的解中确定了一个唯一的最优点对。\n\n**平局打破：** 在收集了所有达到最小距离 $\\ell^\\star$ 的点对 $(p,q)$ 之后，我们应用指定的平局打破规则。候选点对集合首先按点 $p \\in \\partial A$ 的字典序排序，如果出现平局，则按点 $q \\in \\partial B$ 的字典序排序。排序后列表中的第一对即为最终答案 $(p^\\star, q^\\star)$。这种两步法确保我们能正确识别全局最小距离，然后再根据问题标准解决任何歧义或多解情况。\n\n最终的实现使用 `numpy`进行向量运算，并严格遵守所述逻辑，同时使用一个小的容差 $\\epsilon$ 仔细处理浮点数比较。", "answer": "```python\nimport numpy as np\n\n# A small tolerance for floating-point comparisons\nEPSILON = 1e-9\n\ndef solve():\n    \"\"\"\n    Main function to solve the computational geometry problem for all test cases.\n    \"\"\"\n\n    def dist_point_segment_sq(p, a, b):\n        \"\"\"\n        Calculates the squared Euclidean distance from a point p to a line segment [a, b].\n        Returns the squared distance and the closest point on the segment.\n        \"\"\"\n        ab = b - a\n        ap = p - a\n        \n        len_sq = np.dot(ab, ab)\n        if len_sq  EPSILON:\n            return np.dot(ap, ap), a\n\n        t = np.dot(ap, ab) / len_sq\n        \n        if t  0.0:\n            closest_point = a\n        elif t > 1.0:\n            closest_point = b\n        else:\n            closest_point = a + t * ab\n            \n        dist_sq = np.dot(p - closest_point, p - closest_point)\n        return dist_sq, closest_point\n\n    def get_segment_pair_min_dist_sq(p1, p2, q1, q2):\n        \"\"\"\n        Calculates the minimum squared distance between two line segments [p1,p2] and [q1,q2].\n        \"\"\"\n        u = p2 - p1\n        v = q2 - q1\n        w = p1 - q1\n\n        a = np.dot(u, u)\n        b = np.dot(u, v)\n        c = np.dot(v, v)\n        d = np.dot(u, w)\n        e = np.dot(v, w)\n        \n        det = a * c - b * b\n        \n        # Start with a very large number\n        min_dist_sq = float('inf')\n\n        # Case 1: Interior to Interior (if not parallel)\n        if det > EPSILON:\n            s = (b * e - c * d) / det\n            t = (a * e - b * d) / det\n            if 0.0 = s = 1.0 and 0.0 = t = 1.0:\n                dist_sq = np.dot((p1 + s * u) - (q1 + t * v), (p1 + s * u) - (q1 + t * v))\n                min_dist_sq = min(min_dist_sq, dist_sq)\n        \n        # Case 2: Endpoint to Segment\n        dist_sq, _ = dist_point_segment_sq(p1, q1, q2)\n        min_dist_sq = min(min_dist_sq, dist_sq)\n        \n        dist_sq, _ = dist_point_segment_sq(p2, q1, q2)\n        min_dist_sq = min(min_dist_sq, dist_sq)\n        \n        dist_sq, _ = dist_point_segment_sq(q1, p1, p2)\n        min_dist_sq = min(min_dist_sq, dist_sq)\n        \n        dist_sq, _ = dist_point_segment_sq(q2, p1, p2)\n        min_dist_sq = min(min_dist_sq, dist_sq)\n        \n        return min_dist_sq\n\n    def find_segment_pair_optimal_points(p1, p2, q1, q2, target_dist_sq):\n        \"\"\"\n        Finds all pairs of points between two segments that achieve the target squared distance.\n        \"\"\"\n        optimal_pairs = []\n        \n        u = p2 - p1\n        v = q2 - q1\n        w = p1 - q1\n\n        a = np.dot(u, u)\n        b = np.dot(u, v)\n        c = np.dot(v, v)\n        d = np.dot(u, w)\n        e = np.dot(v, w)\n        det = a * c - b * b\n\n        # Case 1: Parallel Segments with Overlap\n        if abs(det)  EPSILON and b > 0: # Ensure they are not collinear and opposing\n            # Distance between parallel lines\n            dist_lines_sq = float('inf')\n            if c > EPSILON:\n                proj_p1_on_line_q = q1 + (np.dot(p1 - q1, v) / c) * v\n                dist_lines_sq = np.dot(p1 - proj_p1_on_line_q, p1 - proj_p1_on_line_q)\n\n            if abs(dist_lines_sq - target_dist_sq)  EPSILON:\n                # Find overlap interval\n                s_of_q1 = np.dot(q1 - p1, u) / a if a > EPSILON else 0.0\n                s_of_q2 = np.dot(q2 - p1, u) / a if a > EPSILON else 0.0\n                \n                s_overlap_min = max(0.0, min(s_of_q1, s_of_q2))\n                s_overlap_max = min(1.0, max(s_of_q1, s_of_q2))\n\n                if s_overlap_min = s_overlap_max + EPSILON:\n                    p1_lex_smaller = (p1[0]  p2[0]) or (abs(p1[0] - p2[0])  EPSILON and p1[1]  p2[1])\n                    s_best = s_overlap_min if p1_lex_smaller else s_overlap_max\n                    p_best = p1 + s_best * u\n                    t_best = np.dot(p_best - q1, v) / c if c > EPSILON else 0.0\n                    q_best = q1 + t_best * v\n                    optimal_pairs.append((p_best, q_best))\n                    \n        # Case 2: Interior to Interior (non-parallel)\n        if det > EPSILON:\n            s_opt = (b * e - c * d) / det\n            t_opt = (a * e - b * d) / det\n            if 0.0 = s_opt = 1.0 and 0.0 = t_opt = 1.0:\n                p_cand = p1 + s_opt * u\n                q_cand = q1 + t_opt * v\n                dist_sq = np.dot(p_cand - q_cand, p_cand - q_cand)\n                if abs(dist_sq - target_dist_sq)  EPSILON:\n                    optimal_pairs.append((p_cand, q_cand))\n        \n        # Case 3: Endpoint to Segment\n        dist_sq, q_on_seg = dist_point_segment_sq(p1, q1, q2)\n        if abs(dist_sq - target_dist_sq)  EPSILON:\n            optimal_pairs.append((p1, q_on_seg))\n            \n        dist_sq, q_on_seg = dist_point_segment_sq(p2, q1, q2)\n        if abs(dist_sq - target_dist_sq)  EPSILON:\n            optimal_pairs.append((p2, q_on_seg))\n            \n        dist_sq, p_on_seg = dist_point_segment_sq(q1, p1, p2)\n        if abs(dist_sq - target_dist_sq)  EPSILON:\n            optimal_pairs.append((p_on_seg, q1))\n            \n        dist_sq, p_on_seg = dist_point_segment_sq(q2, p1, p2)\n        if abs(dist_sq - target_dist_sq)  EPSILON:\n            optimal_pairs.append((p_on_seg, q2))\n            \n        return optimal_pairs\n\n    test_cases = [\n        {'A': [(-2,-1),(-2,1),(-1,1),(-1,-1)], 'B': [(1,-0.5),(1,0.5),(2,0.5),(2,-0.5)]},\n        {'A': [(0,0),(1,1),(0,2)], 'B': [(3,0.5),(3,1.5),(5,1.5),(5,0.5)]},\n        {'A': [(0,0),(0,1),(4,1),(4,0)], 'B': [(1,3),(1,4),(5,4),(5,3)]},\n        {'A': [(0,0),(0,1),(1,1),(1,0)], 'B': [(1.001,0),(1.001,1),(2.001,1),(2.001,0)]},\n        {'A': [(0,0),(0,1),(1,1),(1,0)], 'B': [(3,3),(3,4),(4,4),(4,3)]}\n    ]\n\n    final_results = []\n\n    for case in test_cases:\n        poly_A_verts = [np.array(v) for v in case['A']]\n        poly_B_verts = [np.array(v) for v in case['B']]\n\n        edges_A = [(poly_A_verts[i], poly_A_verts[(i + 1) % len(poly_A_verts)]) for i in range(len(poly_A_verts))]\n        edges_B = [(poly_B_verts[i], poly_B_verts[(i + 1) % len(poly_B_verts)]) for i in range(len(poly_B_verts))]\n        \n        # Pass 1: Find the minimum distance\n        min_dist_sq = float('inf')\n        for p1, p2 in edges_A:\n            for q1, q2 in edges_B:\n                dist_sq = get_segment_pair_min_dist_sq(p1, p2, q1, q2)\n                min_dist_sq = min(min_dist_sq, dist_sq)\n\n        # Pass 2: Collect all pairs achieving the minimum distance\n        candidate_pairs = []\n        for p1, p2 in edges_A:\n            for q1, q2 in edges_B:\n                pairs = find_segment_pair_optimal_points(p1, p2, q1, q2, min_dist_sq)\n                candidate_pairs.extend(pairs)\n        \n        # Apply tie-breaking rules\n        candidate_pairs.sort(key=lambda item: (item[0][0], item[0][1], item[1][0], item[1][1]))\n        \n        # Filter for unique pairs\n        unique_candidates = []\n        if candidate_pairs:\n            unique_candidates.append(candidate_pairs[0])\n            for i in range(1, len(candidate_pairs)):\n                p_curr, q_curr = candidate_pairs[i]\n                p_last, q_last = unique_candidates[-1]\n                if np.linalg.norm(p_curr - p_last) > EPSILON or np.linalg.norm(q_curr - q_last) > EPSILON:\n                    unique_candidates.append(candidate_pairs[i])\n\n        p_star, q_star = unique_candidates[0]\n        length = np.sqrt(min_dist_sq)\n\n        result = [\n            round(p_star[0], 6), round(p_star[1], 6),\n            round(q_star[0], 6), round(q_star[1], 6),\n            round(length, 6)\n        ]\n        final_results.append(result)\n\n    # Format output as a JSON-like string\n    output_str = \"[\" + \",\".join([f\"[{','.join(f'{x:.6f}' for x in r)}]\" for r in final_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3223483"}]}