{"hands_on_practices": [{"introduction": "这个练习是子集动态规划（或称“状态压缩 DP”）的一个经典入门问题。我们旨在对一个给定集合的所有子集进行计数，这些子集的元素之和等于一个特定目标值。由于集合的大小被限制在一个很小的范围内（$|S| \\le 20$），这使得我们可以通过一种称为“位掩码” (bitmask) 的技术，用整数来唯一表示和遍历每一个子集，从而高效地探索整个解空间。通过这个练习 [@problem_id:3203681]，你将掌握使用位运算来管理组合状态的基本方法，这是解决许多涉及子集问题的关键技巧。", "problem": "给定一个满足 $|S|\\leq 20$ 的有限整数列表 $S$。将 $S$ 解释为一个有序序列 $S=(s_1,s_2,\\dots,s_n)$，其中 $n=|S|$。即使元素的值相等，也使用索引来区分它们。同时给定一个整数目标值 $T$。一个子集由其索引集 $X\\subseteq\\{1,2,\\dots,n\\}$ 定义。如果 $\\sum_{i\\in X}s_i=T$，则称子集 $X$ 实现了 $T$。您的任务是计算实现 $T$ 的、索引不同的子集 $X$ 的数量，其中每个 $s_i$ 最多只能使用一次。此任务的输入通过测试套件在程序内部固定；没有用户输入。这是一个纯粹的数学和算法问题，因此不适用任何物理单位。\n\n推理所使用的基本原理：动态规划原理，其出发点是经过充分检验的事实，即对独立选择的组合计数可以分解为子问题，并且子问题可以通过划分选择空间来结构化。具体而言，相关基础包括状态空间的定义、最优子结构原理，以及在通过部分和对子集进行计数时存在重叠子问题。\n\n您的程序必须评估一个由以下参数集 $(S,T)$ 组成的测试套件，其中 $S$ 以列表形式编写，$T$ 以整数形式编写：\n- 测试用例 1：$S=[3,34,4,12,5,2]$，$T=9$。\n- 测试用例 2：$S=[0,0,0]$，$T=0$。\n- 测试用例 3：$S=[-1,1,2,-2,3]$，$T=0$。\n- 测试用例 4：$S=[1,1,1,1]$，$T=2$。\n- 测试用例 5：$S=[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]$（即 $|S|=20$ 且每个元素都等于 $1$），$T=10$。\n- 测试用例 6：$S=[5,6,7]$，$T=1$。\n\n您的程序应生成一行输出，其中包含测试套件的结果，形式为方括号内以逗号分隔的列表。第 $i$ 个条目必须是对于测试用例 $i$，$S$ 中元素之和等于 $T$ 的索引不同的子集的数量。例如，格式必须为 $[r_1,r_2,r_3,r_4,r_5,r_6]$，其中每个 $r_i$ 都是一个整数。", "solution": "所给问题是一个明确定义的组合计数任务。它要求计算给定整数序列 $S = (s_1, s_2, \\dots, s_n)$ 中元素之和等于目标值 $T$ 的、索引不同的子集的数量。$S$ 的元素通过其索引来区分，即使它们的数值相同。\n\n首先，对问题陈述进行验证。\n**步骤 1：提取已知条件**\n- 一个有序整数序列 $S=(s_1,s_2,\\dots,s_n)$，其中 $n=|S|\\leq 20$。\n- 一个整数目标值 $T$。\n- 一个子集由其索引集 $X\\subseteq\\{1,2,\\dots,n\\}$ 定义。\n- 如果 $\\sum_{i\\in X}s_i=T$，则称子集 $X$ 实现了 $T$。\n- 任务是计算此类索引不同的子集 $X$ 的数量。\n- 推理的基本原理被指定为动态规划原理。\n- 提供了一个包含 6 个用例的固定测试套件。\n\n**步骤 2：验证已知条件**\n该问题在科学上和数学上是合理的。它是经典子集和问题（Subset Sum Problem）的一个变体，这是计算机科学和数学中一个著名的问题。该问题是自洽的、客观的且没有歧义。约束条件 $n \\le 20$ 是一个关键信息，它指导了合适算法的选择。所有术语都有正式定义。因此，该问题被认为是有效的。\n\n**步骤 3：结论与行动**\n问题有效。下面是基于原理的解决方案。\n\n**基于原理的解决方案推导**\n该问题是计数子集，这表明应采用组合方法。对于序列 $S$ 中的每个元素 $s_i$，我们可以做出一个二元选择：要么将 $s_i$ 包含在我们的子集中，要么排除它。这种独立选择的结构是适合使用动态规划解决的问题的一个标志。\n\n让我们定义一个函数 $C(i, t)$，表示后缀序列 $(s_i, s_{i+1}, \\dots, s_n)$ 中元素之和等于值 $t$ 的子集数量。我们的目标是计算 $C(1, T)$。\n\n对元素 $s_i$ 的决策导致以下递推关系：\n1.  **排除 $s_i$**：如果我们不将 $s_i$ 包含在子集中，我们必须在剩余元素 $(s_{i+1}, \\dots, s_n)$ 中找到一个子集，其和等于相同的目标 $t$。实现这一目标的方法数量是 $C(i+1, t)$。\n2.  **包含 $s_i$**：如果我们包含 $s_i$，我们必须在剩余元素 $(s_{i+1}, \\dots, s_n)$ 中找到一个子集，其和等于调整后的目标 $t - s_i$。方法数量是 $C(i+1, t - s_i)$。\n\n根据不相交选择的加法原理，总方法数是这两种情况之和：\n$$C(i, t) = C(i+1, t) + C(i+1, t - s_i)$$\n\n递归的基本情况是：\n-   如果 $t=0$，我们已经找到了一个有效的元素组合。我们将其计为 $1$ 个解。这表示到目前为止所做的选择达到了期望的和。（注意：更严格的基本情况是在序列末尾）。\n-   一组更正式的基本情况发生在我们考虑完所有元素时（即当 $i > n$ 时）：\n    -   $C(n+1, 0) = 1$（空集的和为 $0$，代表一条成功的路径）。\n    -   对于 $t \\neq 0$，$C(n+1, t) = 0$（我们未能达到目标和 $0$）。\n\n这种递归公式存在重叠子问题，因为相同的状态 $(i, t)$ 可以通过不同的选择序列达到。直接实现会效率低下。我们可以使用记忆化（一种自顶向下的动态规划方法）来存储和重用每个状态 $(i, t)$ 的结果。这种方法的复杂度与状态数量成正比，约为 $O(n \\cdot \\Delta)$，其中 $\\Delta$ 是可能的中间目标值的范围。虽然这种伪多项式复杂度通常很高效，但如果 $S$ 中的值（从而 $\\Delta$）很大，则可能会出现问题。\n\n然而，问题提供了一个关键约束：$|S| = n \\le 20$。这个约束使得一个关于 $n$ 的指数时间复杂度的解是可行的。具体来说，复杂度为 $O(n \\cdot 2^n)$ 的算法是可以接受的。对于 $n=20$，$2^{20} \\approx 10^6$，而 $20 \\cdot 2^{20} \\approx 2 \\cdot 10^7$，这完全在现代处理器的能力范围内。\n\n这引出了第二种更直接的方法，该方法利用了 $n$ 值较小的特点，通常被归类为“位掩码动态规划”。我们可以使用一个 $n$ 位整数（称为位掩码）来表示 $2^n$ 个可能的索引子集中的每一个。对于一个掩码 $m$，如果第 $j$ 位设置为 $1$，表示元素 $s_{j+1}$ 被包含在子集中；如果该位为 $0$，则表示被排除。\n\n算法如下：\n1.  初始化有效子集的计数器为 $0$。\n2.  遍历从 $0$ 到 $2^n - 1$ 的所有整数 $m$。每个整数 $m$ 都是一个位掩码，代表 $S$ 的一个唯一子集。\n3.  对于每个掩码 $m$，计算相应子集的和。这通过从 $j=0$ 到 $n-1$ 迭代来完成：如果 $m$ 的第 $j$ 位被设置，则将 $s_{j+1}$ 加到一个运行的 `current_sum` 中。\n4.  如果 `current_sum` 等于目标值 $T$，则增加计数器。\n5.  在检查完所有 $2^n$ 个掩码后，计数器的值就是最终答案。\n\n这种方法穷举地检查了每一个子集。它可以被看作是一种自底向上的动态规划方法，我们计算了每个可能子集的和。一个子集（掩码）的和可以从一个更小子集（子掩码）的和推导出来，例如 `sum[mask] = sum[mask_without_lowest_bit] + s[lowest_bit_index]`。然而，直接基于循环计算每个和同样高效且更易于实现。鉴于问题对“位掩码动态规划”的提示以及 $n \\le 20$ 的约束，这种基于位掩码的枚举是最直接和稳健的方法。\n\n例如，对于 $S=[1,1,1,1]$ 和 $T=2$（$n=4$），我们需要找到和为 $2$ 的子集。由于所有值都是 $1$，这等价于选择恰好两个元素。从 $4$ 个索引中选择 $2$ 个的方法数是 $\\binom{4}{2}=6$。位掩码方法将从 $m=0$（二进制的 `0000`）迭代到 $m=15$（二进制的 `1111`）。它会发现恰好有两位被设置的掩码（`0011`、`0101`、`0110`、`1001`、`1010`、`1100`）对应的子集元素之和为 $2$，从而得到正确的计数 $6$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    test_cases = [\n        # S (list of integers), T (target integer)\n        ([3, 34, 4, 12, 5, 2], 9),\n        ([0, 0, 0], 0),\n        ([-1, 1, 2, -2, 3], 0),\n        ([1, 1, 1, 1], 2),\n        ([1] * 20, 10),\n        ([5, 6, 7], 1),\n    ]\n\n    results = []\n    for s_list, t_target in test_cases:\n        # Calculate the number of subsets for the current case.\n        result = count_subsets_with_sum(s_list, t_target)\n        results.append(result)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef count_subsets_with_sum(S, T):\n    \"\"\"\n    Computes the number of index-distinct subsets of S that sum to T.\n\n    This function uses a bitmasking approach to iterate through all possible\n    subsets of S. Given that |S| is at most 20, the total number of subsets\n    is at most 2^20, which is computationally feasible.\n\n    Args:\n        S: A list of integers.\n        T: The target integer sum.\n\n    Returns:\n        The number of subsets of S that sum to T.\n    \"\"\"\n    n = len(S)\n    if n > 20:\n        # This implementation is only efficient for n = 20.\n        # A different DP approach would be needed for larger n.\n        raise ValueError(\"Input list S is too large for this method.\")\n\n    count = 0\n    num_subsets = 1  n  # This is equivalent to 2**n\n\n    # Iterate through all possible subsets using a bitmask from 0 to 2^n - 1.\n    for i in range(num_subsets):\n        current_sum = 0\n        # For each subset, calculate its sum.\n        for j in range(n):\n            # Check if the j-th element is in the current subset.\n            # This is done by checking if the j-th bit of i is set.\n            if (i >> j)  1:\n                current_sum += S[j]\n        \n        # If the sum of the subset equals the target, increment the count.\n        if current_sum == T:\n            count += 1\n            \n    return count\n\n# Run the solver.\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3203681"}, {"introduction": "本练习是一个更高级的树形动态规划问题，挑战我们去计算一棵树中大小恰好为 $K$ 的连通子图的数量。解决这个问题的核心思想是，任何一个连通子图都可以被唯一地视为以其“最高”节点为根的结构。通过这种方式，我们可以定义一个 DP 状态 $dp[u][k]$，表示在以 $u$ 为根的子树中，包含 $u$ 且大小为 $k$ 的连通子图数量，从而将总问题分解为对所有节点作为子图根的计数之和。这个练习 [@problem_id:3203742] 完美地展示了树形 DP 中一种被称为“树上背包”的常见模式，它通过在父子节点间合并解来系统地构建最终答案。", "problem": "给定一个无向树 $G=(V,E)$，它有 $|V|=N$ 个顶点（标记为 $1$ 到 $N$）和 $|E|=N-1$ 条边。树的定义是连通、无环的图。对于一个整数 $K$，一个大小恰好为 $K$ 的连通子图被定义为一个顶点子集 $S \\subseteq V$，其大小 $|S|=K$，且由 $S$ 诱导的子图是连通的（即，对于 $S$ 中的每一对顶点，都存在一条完全位于 $S$ 内部的路径连接它们）。任务是计算大小恰好为 $K$ 的不同连通诱导子图的数量。所有计数都是没有物理单位的纯整数。\n\n依赖的基本原则：\n- 树的定义：一个连通、无环的无向图。\n- 树的性质：任意两个顶点之间存在唯一的简单路径。\n- 诱导子图的概念：对于 $S \\subseteq V$，其诱导子图包含 $S$ 中的所有顶点以及所有满足 $u \\in S$ 和 $v \\in S$ 的边 $(u,v) \\in E$。\n\n你的程序必须为以下每个测试用例计算数量。每个测试用例由 $N$、$K$ 和一组边指定。顶点标记为 $1$ 到 $N$。\n\n测试套件：\n1. 案例 $\\mathrm{A}$：$N=7$，$K=3$，边集合 $\\{(1,2),(1,3),(2,4),(2,5),(3,6),(3,7)\\}$。\n2. 案例 $\\mathrm{B}$：$N=5$，$K=2$，边集合 $\\{(1,2),(2,3),(3,4),(4,5)\\}$。\n3. 案例 $\\mathrm{C}$：$N=5$，$K=3$，边集合 $\\{(1,2),(1,3),(1,4),(1,5)\\}$。\n4. 案例 $\\mathrm{D}$：$N=1$，$K=1$，边集合 $\\{\\}$。\n5. 案例 $\\mathrm{E}$：$N=3$，$K=0$，边集合 $\\{(1,2),(2,3)\\}$。对于 $K=0$，计数定义为 $0$，因为没有非空连通子图的大小为 $0$。\n6. 案例 $\\mathrm{F}$：$N=6$，$K=6$，边集合 $\\{(1,2),(2,3),(3,4),(4,5),(5,6)\\}$。\n7. 案例 $\\mathrm{G}$：$N=4$，$K=5$，边集合 $\\{(1,2),(1,3),(1,4)\\}$。对于 $K>N$，计数定义为 $0$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,\\dots]$），其中 $r_i$ 是按上述顺序列出的第 $i$ 个测试用例的整数计数。不应产生其他输出。此任务不涉及角度或物理单位。所有输出均为整数。", "solution": "所述问题是图论领域一个定义明确的组合计数问题。所有术语都是标准的，测试用例是一致且可验证的。该问题是有效的，可以使用成熟的算法技术来解决。\n\n任务是在一棵树 $G=(V, E)$（其中 $|V|=N$）中，计算大小为 $K$ 的不同连通诱导子图的数量。对所有 $\\binom{N}{K}$ 个顶点子集进行暴力检查在计算上是不可行的。图的树形结构表明可以采用一种树上动态规划的方法，通常称为树形 DP。\n\n树 $G$ 中连通子图 $S$ 的一个基本性质是 $S$ 本身也是一棵树。如果我们将主树 $G$ 在任意顶点 $r$ 处定根，那么任何连通子图 $S$ 都将拥有一个唯一的“最高”顶点，即 $S$ 中相对于根 $r$ 而言是 $S$ 中所有其他顶点的祖先的那个顶点。这个唯一的顶点可以被指定为子图 $S$ 的“根”。\n\n这一观察使我们能够根据其唯一的根来划分所有连通子图的集合，从而确保每个子图只被计数一次。总数是对于所有顶点 $u \\in V$，以 $u$ 为根的大小为 $K$ 的连通子图数量之和。\n\n我们设计一个动态规划状态来计算这些数量。让我们为整棵树 $G$ 固定一个任意的根，例如顶点 $1$。然后我们将从这个根开始执行一次后序遍历（DFS）。对于每个顶点 $u$，我们的 DP 状态将捕获关于以 $u$ 为根的子图的信息。\n\n设 $dp[u][k]$ 表示大小为 $k$ 的连通子图的数量，这些子图完全包含在以 $u$ 为根的 $G$ 的子树中，并且它们本身也以 $u$ 为根。\n\nDP 值通过后序遍历计算：\n\n**基本情况：** 对于任何叶顶点 $u$，在其自身子树中以 $u$ 为根的唯一连通子图是由单个顶点 $\\{u\\}$ 组成的子图。因此，$dp[u][1] = 1$，并且对于所有 $k > 1$，$dp[u][k] = 0$。\n\n**递归步骤：** 对于一个内部顶点 $u$，我们基于只包含其自身的子图来初始化其 DP 表：$dp[u][1] = 1$，且对于 $k > 1$，$dp[u][k] = 0$。然后我们遍历它的每个子节点（比如 $v_i$），并将来自子节点子树的 DP 信息合并到父节点的 DP 表中。\n\n当处理一个子节点 $v_i$ 时，我们已经计算了它的 DP 表 $dp[v_i]$。一个新的、更大的以 $u$ 为根的连通子图可以通过组合一个已有的、大小为 $k_1$、以 $u$ 为根的连通子图（使用 $u$ 及其先前处理过的子节点构建）和一个大小为 $k_2$、以 $v_i$ 为根的连通子图来形成。连接是通过边 $(u, v_i)$ 建立的。得到的子图以 $u$ 为根，其新大小为 $k_1 + k_2$。形成这样一个子图的方式数量是 $dp[u][k_1]$ 和 $dp[v_i][k_2]$ 的乘积。\n\n这个组合过程对每个子节点依次执行。设 $dp_{u, \\text{old}}$ 为合并子节点 $v_i$ 之前 $u$ 的 DP 数组。新的 DP 数组 $dp_{u, \\text{new}}$ 计算如下：\n$dp_{u, \\text{new}}[k] = dp_{u, \\text{old}}[k] + \\sum_{k_1+k_2=k} dp_{u, \\text{old}}[k_1] \\times dp_{v_i}[k_2]$。\n第一项 $dp_{u, \\text{old}}[k]$ 计算了那些不包含来自 $v_i$ 子树中任何顶点的、以 $u$ 为根的子图。求和项则计算了通过包含来自 $v_i$ 子树的一个连通分量而形成的新子图。\n\n后序遍历完成后，每个顶点 $u$ 的 $dp[u][k]$ 表就最终确定了。整棵树中大小为 $K$ 的连通子图总数是所有可能根的和：$\\sum_{u \\in V} dp[u][K]$。\n\n时间复杂度主要由 DP 合并操作决定。在遍历中的每条边 $(u, v)$ 上，我们执行一个类似于两个数组卷积的操作，数组大小与各自子树的大小成比例。在一棵树的所有边上，这些子树大小乘积的总和以 $O(N^2)$ 为界。空间复杂度为 $O(N^2)$，用于存储所有 $N$ 个顶点的 DP 表，其中每个表最多可有 $N+1$ 个条目。\n\n根据问题陈述，$K=0$ 或 $K>N$ 的特殊情况直接处理，计数为 $0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport sys\n\n# It is good practice to increase the recursion limit for deep trees,\n# although not strictly necessary for the small N in the test cases.\nsys.setrecursionlimit(2000)\n\ndef count_connected_subgraphs(N, K, edges):\n    \"\"\"\n    Calculates the number of connected induced subgraphs of size K in a tree.\n\n    Args:\n        N (int): The number of vertices in the tree.\n        K (int): The desired size of the connected subgraphs.\n        edges (list of tuples): A list of edges defining the tree.\n\n    Returns:\n        int: The number of distinct connected subgraphs of size K.\n    \"\"\"\n    if K == 0 or K > N:\n        return 0\n    if N == 0:\n        return 0\n    # A single vertex graph.\n    if not edges:\n        return 1 if N == 1 and K == 1 else 0\n\n    adj = [[] for _ in range(N + 1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # dp[u][k] stores the number of connected subgraphs of size k\n    # in the subtree of u, with u as the root of the subgraph.\n    # We use np.int64 to prevent potential integer overflow with larger N.\n    dp = np.zeros((N + 1, N + 1), dtype=np.int64)\n\n    def dfs(u, p):\n        \"\"\"\n        Performs a post-order traversal to compute the DP tables.\n\n        Args:\n            u (int): The current vertex.\n            p (int): The parent of the current vertex in the DFS traversal.\n\n        Returns:\n            int: The size of the subtree rooted at u.\n        \"\"\"\n        # Base case for the DP: the subgraph with only vertex u.\n        dp[u][1] = 1\n        current_size = 1\n        \n        for v in adj[u]:\n            if v == p:\n                continue\n            \n            child_size = dfs(v, u)\n            \n            # This temporary array holds the new DP values for u after merging child v.\n            # This corresponds to the polynomial multiplication: P_u_new = P_u_old * (1 + P_v),\n            # where P(x) is the generating function for the DP counts.\n            temp_dp_u = dp[u].copy()\n\n            for k1 in range(1, current_size + 1):\n                if dp[u][k1] == 0:\n                    continue\n                for k2 in range(1, child_size + 1):\n                    if dp[v][k2] == 0:\n                        continue\n                    if k1 + k2 = N:\n                        # Combine a component of size k1 from u's current set\n                        # with a component of size k2 from v's subtree.\n                        temp_dp_u[k1 + k2] += dp[u][k1] * dp[v][k2]\n\n            dp[u] = temp_dp_u\n            current_size += child_size\n        \n        return current_size\n\n    # Start DFS from an arbitrary root (vertex 1), with a dummy parent 0.\n    dfs(1, 0)\n\n    # The total count is the sum of dp[u][K] over all possible subgraph roots u.\n    total_count = np.sum(dp[:, K])\n    \n    return total_count\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite, printing the results in the required format.\n    \"\"\"\n    test_cases = [\n        # Case A: N=7, K=3, edges={(1,2),(1,3),(2,4),(2,5),(3,6),(3,7)}\n        (7, 3, [(1,2),(1,3),(2,4),(2,5),(3,6),(3,7)]),\n        # Case B: N=5, K=2, edges={(1,2),(2,3),(3,4),(4,5)}\n        (5, 2, [(1,2),(2,3),(3,4),(4,5)]),\n        # Case C: N=5, K=3, edges={(1,2),(1,3),(1,4),(1,5)}\n        (5, 3, [(1,2),(1,3),(1,4),(1,5)]),\n        # Case D: N=1, K=1, edges={}\n        (1, 1, []),\n        # Case E: N=3, K=0, edges={(1,2),(2,3)}\n        (3, 0, [(1,2),(2,3)]),\n        # Case F: N=6, K=6, edges={(1,2),(2,3),(3,4),(4,5),(5,6)}\n        (6, 6, [(1,2),(2,3),(3,4),(4,5),(5,6)]),\n        # Case G: N=4, K=5, edges={(1,2),(1,3),(1,4)}\n        (4, 5, [(1,2),(1,3),(1,4)])\n    ]\n    \n    results = []\n    for N, K, edges in test_cases:\n        result = count_connected_subgraphs(N, K, edges)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3203742"}, {"introduction": "这个问题展示了如何将深刻的图论见解与算法技巧相结合来解决看似复杂的问题。计算树中路径长度为偶数的节点对，其关键在于一个优雅的性质：任意两个节点之间的路径长度为偶数，当且仅当它们在树的二分图划分中属于同一部分。一旦我们利用这个性质将问题简化，它就变成了一个组合计数任务。进一步地，当需要为一组特定节点的任意子集解决此问题时，位掩码动态规划就成了一个强大的工具。这个练习 [@problem_id:3203759] 强调了一个重要的解题思维：首先利用数据结构的内在属性简化问题，然后应用合适的算法技术高效求解。", "problem": "给定一个连通的无向树，其顶点集由连续整数标记。树是一个没有环的连通简单图。对于任意两个顶点，它们之间有且仅有一条简单路径。路径的长度是其包含的边数。对于任意有序的不同顶点对，其路径长度要么是偶数，要么是奇数。任务是，对于一棵给定的树，计算其无序不同顶点对中，唯一路径长度为偶数的对数。\n\n本问题的基础概念如下：\n- 树是一个顶点集上的连通、无环、简单图，因此任意两个顶点之间有且仅有一条简单路径。\n- 任何树都是二分图：存在一个顶点集的划分，将其分为两个独立集，使得每条边都连接来自不同部分的一个顶点。\n- 树上动态规划指的是在子树上计算量，并沿着唯一的父子关系将它们组合起来。\n- 位掩码动态规划指的是通过使用表示子集的位掩码的递推关系，来计算一个小集合的所有子集的值。\n\n你的程序必须为每个测试树计算两个相关的输出：\n1. 在整个顶点集上，路径长度（以边数计）为偶数的无序不同顶点对的总数。\n2. 给定一个大小为 $m$ 的指定小标记顶点列表，对于这些标记顶点的每个子集 $S$（包括空子集），计算 $S$ 中路径长度（以边数计）为偶数的无序不同顶点对的数量。子集 $S$ 由从 $0$ 到 $2^m-1$ 的位掩码索引，其中第 $i$ 位对应于包含列表中第 $i$ 个标记顶点。\n\n你必须基于上述基本定义实现一个解决方案，而不是通过猜测或使用未从这些原则中证明的预先推导的捷径。该方法必须是可靠的，并且必须从树的二分结构和动态规划的定义出发进行论证。不涉及物理单位或角度。\n\n测试套件和输入规范：\n没有外部输入。你的程序必须嵌入并处理以下四个测试用例。在每个案例中，顶点从 $1$ 标记到 $n$，边是无序对 $(u,v)$，标记列表是不同顶点的有序列表。对于每个案例，计算：\n- 首先，在整个树上路径长度为偶数的无序不同顶点对的总数。\n- 其次，对于给定的规模为 $m$ 的标记列表，计算一个长度为 $2^m$ 的向量 $g$，其中 $g[\\text{mask}]$ 是由 $\\text{mask}$ 选定的顶点中路径长度为偶数的无序对的数量，按掩码从 $0$ 到 $2^m-1$ 的升序排列。\n\n测试用例如下：\n- 测试用例 1：$n=1$，边集合 $\\{\\}$，标记列表 $\\{1\\}$。\n- 测试用例 2：$n=5$，边集合 $\\{(1,2),(1,3),(1,4),(1,5)\\}$，标记列表 $\\{1,2,3\\}$。\n- 测试用例 3：$n=6$，边集合 $\\{(1,2),(2,3),(3,4),(4,5),(5,6)\\}$，标记列表 $\\{2,3,5,6\\}$。\n- 测试用例 4：$n=7$，边集合 $\\{(1,2),(1,3),(2,4),(2,5),(3,6),(3,7)\\}$，标记列表 $\\{4,5,6\\}$。\n\n输出格式：\n你的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。该列表必须通过按顺序（从 1 到 4）连接每个测试用例的以下内容形成：\n- 首先，是该案例中全树偶数对计数的单个整数。\n- 然后，是该案例标记列表的 $2^m$ 个整数 $g[0], g[1], \\dots, g[2^m-1]$。\n\n因此，最终输出是一个长度为 $L$ 的单个扁平整数列表，其中 $L$ 等于所有测试用例的 $1+2^m$ 之和。不应打印任何额外文本。", "solution": "问题要求我们计算树中由偶数长度路径连接的无序不同顶点对的数量。这项任务首先要对整个顶点集进行，其次要对给定标记顶点列表的所有子集进行。解决方案必须从基本原则推导得出，即树的二分性质和动态规划。\n\n### 基本原理：树中的路径奇偶性与二分划分\n\n任何树（一种连通无环图）的一个关键性质是它是一个二分图。这意味着顶点集 $V$ 可以被划分为两个不相交且非空（对于任何至少有两个顶点的树）的集合 $V_0$ 和 $V_1$，使得树中的每条边都连接一个 $V_0$ 中的顶点和一个 $V_1$ 中的顶点。同一集合内的两个顶点之间没有边相连。\n\n两个顶点 $u$ 和 $v$ 之间的距离，记作 $d(u,v)$，是它们之间唯一简单路径的长度。这个二分划分属性对路径长度的奇偶性有直接影响。让我们固定一个任意的根顶点 $r$，并将其分配到一个划分中，比如 $V_0$。任何顶点 $v$ 如果其与 $r$ 的距离 $d(v,r)$ 为偶数，则它在 $V_0$ 中。反之，任何顶点 $v$ 如果其与 $r$ 的距离 $d(v,r)$ 为奇数，则它在 $V_1$ 中。对于任意两个顶点 $u, v \\in V$，距离 $d(u,v)$ 的奇偶性与它们到根 $r$ 的距离的奇偶性相关，公式如下：\n$$ d(u,v) \\equiv d(u,r) + d(v,r) \\pmod 2 $$\n这个关系成立，因为从 $u$ 到 $v$ 的路径可以由从 $u$ 到 $r$ 和从 $v$ 到 $r$ 的路径构造而成。其长度为 $d(u,v) = d(u,r) + d(v,r) - 2 \\cdot d(\\text{lca}(u,v), r)$，其中 $\\text{lca}(u,v)$ 是 $u$ 和 $v$ 的最低公共祖先。项 $2 \\cdot d(\\text{lca}(u,v), r)$ 总是偶数，因此它不影响奇偶性。\n\n由此得出，$d(u,v)$ 为偶数当且仅当 $d(u,r)$ 和 $d(v,r)$ 具有相同的奇偶性。这等价于说 $u$ 和 $v$ 在二分划分 $(V_0, V_1)$ 中属于同一个划分集。\n\n### 任务 1 的算法：总偶数路径对\n\n基于上述原理，计算具有偶数长度路径的顶点对等同于计算位于同一划分集中的顶点对。\n\n1.  **树的二分划分**：我们可以使用图遍历算法，如广度优先搜索（BFS）或深度优先搜索（DFS），来找到二分划分 $(V_0, V_1)$。我们从一个任意顶点（比如 $v_{start}$）开始，并将其分配给 $V_0$。然后我们遍历树：$V_0$ 中顶点的任何邻居都被分配给 $V_1$，而 $V_1$ 中顶点的任何邻居都被分配给 $V_0$。这个过程等价于一种树上动态规划方法，其中一个节点的状态（其所属划分）由其父节点的状态决定。\n\n2.  **计数对数**：一旦划分完成，令 $n_0 = |V_0|$ 和 $n_1 = |V_1|$ 为这两个集合的大小。都在 $V_0$ 中的无序不同顶点对的数量由二项式系数 $\\binom{n_0}{2}$ 给出。类似地，$V_1$ 中的对数是 $\\binom{n_1}{2}$。具有偶数路径长度的总对数是这两个量的和：\n    $$ \\text{Total Count} = \\binom{n_0}{2} + \\binom{n_1}{2} = \\frac{n_0(n_0-1)}{2} + \\frac{n_1(n_1-1)}{2} $$\n\n### 任务 2 的算法：标记顶点子集中的偶数路径对\n\n对于第二个任务，我们给定一个包含 $m$ 个标记顶点的列表 $M = [v_0, v_1, \\dots, v_{m-1}]$。我们需要为 $M$ 的每个子集计算偶数长度路径对的数量。子集由从 $0$ 到 $2^m-1$ 的位掩码标识。一个掩码代表一个子集 $S_{\\text{mask}} \\subseteq M$。\n\n这个问题可以通过应用位掩码动态规划来解决。\n\n1.  **预计算**：首先，我们像任务 1 中一样对整个树进行二分划分，以确定每个顶点属于哪个划分（$V_0$ 或 $V_1$）。\n\n2.  **位掩码 DP 状态**：对于从 $0$ 到 $2^m-1$ 的每个掩码，我们需要计算相应子集 $S_{\\text{mask}}$ 中属于 $V_0$ 和 $V_1$ 的顶点数量。我们定义：\n    -   $c_0[\\text{mask}]$：$S_{\\text{mask}}$ 中属于 $V_0$ 的顶点数量。\n    -   $c_1[\\text{mask}]$：$S_{\\text{mask}}$ 中属于 $V_1$ 的顶点数量。\n\n3.  **DP 递推**：这些计数可以被高效地计算。我们初始化 $c_0[0] = 0$ 和 $c_1[0] = 0$。对于表示单元素子集的掩码（即，2 的幂的掩码），我们可以直接设置计数。对于一个掩码 $2^i$，对应子集 $\\{v_i\\}$：\n    -   如果 $v_i \\in V_0$，则 $c_0[2^i] = 1$ 且 $c_1[2^i] = 0$。\n    -   如果 $v_i \\in V_1$，则 $c_0[2^i] = 0$ 且 $c_1[2^i] = 1$。\n\n    对于任何其他掩码，我们可以使用一个递推关系。如果 $i$ 是 $\\text{mask}$ 的最低有效位的索引，并且 $\\text{prev\\_mask} = \\text{mask} \\oplus 2^i$，那么：\n    $$ c_0[\\text{mask}] = c_0[\\text{prev\\_mask}] + c_0[2^i] $$\n    $$ c_1[\\text{mask}] = c_1[\\text{prev\\_mask}] + c_1[2^i] $$\n    这使我们能够在 $O(2^m)$ 时间内计算出所有掩码的 $c_0$ 和 $c_1$。\n\n4.  **最终计算**：一旦所有掩码的 $c_0[\\text{mask}]$ 和 $c_1[\\text{mask}]$ 都已知，每个子集 $S_{\\text{mask}}$ 的期望计数，记作 $g[\\text{mask}]$，可以类似于任务 1 进行计算：\n    $$ g[\\text{mask}] = \\binom{c_0[\\text{mask}]}{2} + \\binom{c_1[\\text{mask}]}{2} $$\n    这对从 $0$ 到 $2^m-1$ 的每个掩码进行计算。对于 $|S_{\\text{mask}}|  2$ 的掩码，此计数正确地为 $0$。\n\n将用于二分划分的树遍历（一种树上 DP 的形式）与对子集的系统计算（位掩码 DP）相结合，提供了一个完整且有原则的解决方案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 1,\n            \"edges\": [],\n            \"marked_list\": [1],\n        },\n        {\n            \"n\": 5,\n            \"edges\": [(1, 2), (1, 3), (1, 4), (1, 5)],\n            \"marked_list\": [1, 2, 3],\n        },\n        {\n            \"n\": 6,\n            \"edges\": [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)],\n            \"marked_list\": [2, 3, 5, 6],\n        },\n        {\n            \"n\": 7,\n            \"edges\": [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)],\n            \"marked_list\": [4, 5, 6],\n        }\n    ]\n\n    final_results = []\n    for case in test_cases:\n        total_count, g_vector = solve_case(case[\"n\"], case[\"edges\"], case[\"marked_list\"])\n        final_results.append(total_count)\n        final_results.extend(g_vector)\n\n    print(f\"[{','.join(map(str, final_results))}]\")\n\ndef solve_case(n, edges, marked_list):\n    \"\"\"\n    Solves the problem for a single test case.\n    \"\"\"\n    if n == 0:\n        m = len(marked_list)\n        return 0, [0] * (1  m)\n\n    # Use 1-based indexing for vertices to match problem statement\n    adj = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Step 1: Bipartition the tree using BFS\n    # partitions[i] = 0 or 1, representing the partition group of vertex i\n    # -1 indicates unvisited.\n    partitions = [-1] * (n + 1)\n    \n    # Store partition counts for all vertices\n    n_counts = [0, 0]\n\n    # Handle potentially disconnected components, though problem states connected tree\n    for i in range(1, n + 1):\n        if partitions[i] == -1:\n            q = deque([(i, 0)])\n            partitions[i] = 0\n            \n            while q:\n                u, p = q.popleft()\n                n_counts[p] += 1\n                for v in adj[u]:\n                    if partitions[v] == -1:\n                        partitions[v] = 1 - p\n                        q.append((v, 1 - p))\n\n    # Task 1: Count even-path pairs over the entire tree\n    n0, n1 = n_counts[0], n_counts[1]\n    total_even_pairs = (n0 * (n0 - 1) // 2) + (n1 * (n1 - 1) // 2)\n\n    # Task 2: Count even-path pairs for subsets of marked vertices\n    m = len(marked_list)\n    num_masks = 1  m\n    \n    # counts0[mask] / counts1[mask] store the number of marked vertices in the\n    # subset 'mask' that belong to partition 0 / 1.\n    counts0 = np.zeros(num_masks, dtype=int)\n    counts1 = np.zeros(num_masks, dtype=int)\n\n    # Bitmask DP to calculate counts for all subsets\n    for mask in range(1, num_masks):\n        # Find the index of the least significant bit\n        lsb_idx = (mask  -mask).bit_length() - 1\n        prev_mask = mask ^ (1  lsb_idx)\n        \n        # Get the vertex corresponding to this bit\n        vertex = marked_list[lsb_idx]\n        \n        # Determine its partition\n        part = partitions[vertex]\n        \n        # DP recurrence\n        if part == 0:\n            counts0[mask] = counts0[prev_mask] + 1\n            counts1[mask] = counts1[prev_mask]\n        else: # part == 1\n            counts0[mask] = counts0[prev_mask]\n            counts1[mask] = counts1[prev_mask] + 1\n            \n    # Calculate the final counts g[mask] for each subset\n    g = np.zeros(num_masks, dtype=int)\n    for mask in range(num_masks):\n        n0_mask = counts0[mask]\n        n1_mask = counts1[mask]\n        g[mask] = (n0_mask * (n0_mask - 1) // 2) + (n1_mask * (n1_mask - 1) // 2)\n        \n    return total_even_pairs, g.tolist()\n\nsolve()\n```", "id": "3203759"}]}