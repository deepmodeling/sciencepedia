{"hands_on_practices": [{"introduction": "快速傅里叶变换（FFT）的原始输出是一个复数数组，其索引从 $0$ 到 $N-1$。为了从这些数据中提取有意义的信息，我们必须学会如何将这些抽象的“频点”索引映射到实际的物理频率。这个练习 [@problem_id:2213513] 提供了一个直接的现实世界场景，演示了在给定采样率的情况下如何完成这一关键转换，从而将算法输出与可测量的物理量联系起来。", "problem": "一位生物医学工程师正在分析肌电图 (EMG) 信号以研究肌肉疲劳，该信号测量骨骼肌的电活动。信号是使用表面电极从一名运动员的腿部肌肉采集的。数据以 $f_s = 400$ Hz 的恒定速率进行采样。为了进行频谱分析，使用快速傅里叶变换 (FFT) 算法处理了一段包含 $N = 128$ 个连续数据点的信号。生成的频谱在频率索引 $k=10$ 处显示出一个显著的峰值。这个峰值代表了在特定收缩期间肌肉放电率中的一个主导频率分量。假设索引 $k=0$ 对应于直流 (DC) 分量，请确定该主导分量的物理频率。\n\n答案以赫兹 (Hz) 为单位，用数值表示。", "solution": "对于一个以速率 $f_s$ 采样并用 $N$ 点 DFT/FFT 进行分析的离散时间信号，其频率间隔（分辨率）为\n$$\n\\Delta f = \\frac{f_s}{N}.\n$$\n对应于索引 $k$（其中 $k=0$ 为直流分量）的物理频率为\n$$\nf_k = k\\,\\Delta f = \\frac{k f_s}{N}.\n$$\n已知 $f_s = 400$ Hz, $N = 128$, 且 $k = 10$，\n$$\nf_{10} = \\frac{10 \\times 400}{128} = \\frac{4000}{128} = \\frac{250}{8} = 31.25 \\text{ Hz}.\n$$\n因此，主导分量的频率为 31.25 Hz。", "answer": "$$\\boxed{31.25}$$", "id": "2213513"}, {"introduction": "FFT 最强大的应用之一是它能够以远超直接计算的效率执行卷积运算。本练习 [@problem_id:1717795] 将演示如何利用 FFT，通过卷积定理来计算两个序列的线性卷积——这是信号处理和算法设计中的一个基本任务。通过这个实践，你将掌握在频域中实现卷积的关键技术，特别是理解为什么以及如何正确使用零填充（zero-padding）。", "problem": "考虑两个离散时间有限长度信号，$x[n]$ 和 $h[n]$，它们仅在 $n \\ge 0$ 时非零。信号定义如下：\n*   $x[n] = 2\\delta[n] + \\delta[n-1] - \\delta[n-2]$\n*   $h[n] = \\delta[n] + 3\\delta[n-1]$\n其中 $\\delta[n]$ 是克罗内克 $\\delta$ 函数。\n\n令 $y[n]$ 表示 $x[n]$ 和 $h[n]$ 的线性卷积，即 $y[n] = (x * h)[n]$。你的任务是使用频域方法计算此卷积。具体来说，你必须使用快速傅里叶变换 (FFT) 和快速傅里叶逆变换 (IFFT) 在频域中执行乘法运算。\n\n确定输出样本 $y[2]$ 的值。", "solution": "我们希望通过使用 $N$ 点 FFT/IFFT 进行频域相乘来得到 $y[n]=(x*h)[n]$，其中 $N\\geq L_{x}+L_{h}-1$。$x[n]$ 的非零支撑集在 $n\\in\\{0,1,2\\}$上，$h[n]$ 的非零支撑集在 $n\\in\\{0,1\\}$上，因此 $L_{x}=3$，$L_{h}=2$，且 $L_{x}+L_{h}-1=4$。选择 $N=4$，这样在补零后，$4$ 点圆周卷积就等于线性卷积。\n\n补零至长度为 $4$：\n$$\nx[0]=2,\\;x[1]=1,\\;x[2]=-1,\\;x[3]=0,\\qquad\nh[0]=1,\\;h[1]=3,\\;h[2]=0,\\;h[3]=0.\n$$\n\n定义 $N$ 点 DFT 核 $W_{N}=\\exp(-i 2\\pi/N)$，其中 $i^{2}=-1$。对于 $N=4$，$W_{4}=\\exp(-i\\pi/2)$ 且 $W_{4}^{0}=1$, $W_{4}^{1}=-i$, $W_{4}^{2}=-1$, $W_{4}^{3}=i$。\n\n计算 $4$ 点 DFT $X[k]=\\sum_{n=0}^{3}x[n]W_{4}^{kn}$ 和 $H[k]=\\sum_{n=0}^{3}h[n]W_{4}^{kn}$：\n- 对于 $X[k]$：\n$$\n\\begin{aligned}\nX[0]&=2+1+(-1)+0=2,\\\\\nX[1]&=2+1(-i)+(-1)(-1)+0=3-i,\\\\\nX[2]&=2+1(-1)+(-1)(1)+0=0,\\\\\nX[3]&=2+1(i)+(-1)(-1)+0=3+i.\n\\end{aligned}\n$$\n- 对于 $H[k]$：\n$$\n\\begin{aligned}\nH[0]&=1+3+0+0=4,\\\\\nH[1]&=1+3(-i)=1-3i,\\\\\nH[2]&=1+3(-1)=-2,\\\\\nH[3]&=1+3(i)=1+3i.\n\\end{aligned}\n$$\n\n在频域中相乘：$Y[k]=X[k]H[k]$：\n$$\n\\begin{aligned}\nY[0]&=2\\cdot 4=8,\\\\\nY[1]&=(3-i)(1-3i)=-10i,\\\\\nY[2]&=0\\cdot(-2)=0,\\\\\nY[3]&=(3+i)(1+3i)=10i.\n\\end{aligned}\n$$\n\n应用 $4$ 点 IFFT 来得到 $y[n]=\\frac{1}{4}\\sum_{k=0}^{3}Y[k]\\exp(i 2\\pi kn/4)$。对于 $n=2$：\n$$\ny[2]=\\frac{1}{4}\\sum_{k=0}^{3}Y[k]\\exp(i\\pi k)=\\frac{1}{4}\\sum_{k=0}^{3}Y[k](-1)^{k}.\n$$\n代入 $Y[k]$：\n$$\ny[2]=\\frac{1}{4}\\left(8-(-10i)+0-(10i)\\right)=\\frac{1}{4}\\left(8+10i-10i\\right)=\\frac{8}{4}=2.\n$$\n\n因为 $N=4\\geq L_{x}+L_{h}-1$，这个 IFFT 样本等于所需的线性卷积样本，所以 $y[2]=2$。", "answer": "$$\\boxed{2}$$", "id": "1717795"}, {"introduction": "要真正掌握 FFT，理解其内部的分治策略至关重要。这个高级练习 [@problem_id:3228590] 将指导你从零开始，基于分治思想实现 FFT 算法，并将其应用于解决经典的多项式乘法问题。通过亲手实现这一过程，你将深刻体会到卷积定理如何与高效算法设计相结合，从而将一个看似 $\\mathcal{O}(n^2)$ 的问题转化为 $\\mathcal{O}(n \\log n)$ 的解决方案。", "problem": "实现一个完整的程序，使用分治快速傅里叶变换 (FFT) 方法乘以两个一元多项式。该程序必须为固定的测试套件计算乘积多项式的系数列表，并以指定格式在一行内打印所有结果。\n\n您必须遵守以下要求。\n\n- 输入模型与表示：\n  - 一元多项式由一个按次数升序排列的实数系数列表表示。例如，列表 $[a_0,a_1,\\dots,a_{n-1}]$ 表示多项式 $a_0 + a_1 x + \\dots + a_{n-1} x^{n-1}$。\n  - 测试套件中的所有系数均为整数，但您的方法必须能对实数系数正确运行。\n\n- 算法约束：\n  - 您必须使用分治快速傅里叶变换实现多项式乘法。该方法应基于以下基本事实：离散傅里叶变换 (DFT) 是一种线性变换，系数域中的卷积对应于求值域中的逐点相乘。您不得使用任何库中的傅里叶变换例程。\n  - 使用零填充，使变换大小为不小于操作数长度之和减 $1$ 的最小 $2$ 的幂。\n  - 对于变换大小为 $n$，算法必须在 $\\mathcal{O}(n \\log n)$ 时间内运行，并应使用基-2 Cooley–Tukey 风格的分治递归。\n\n- 输出规范：\n  - 对于两个长度为 $m$ 和 $n$ 的输入列表，输出列表的长度必须恰好为 $m+n-1$。\n  - 由于浮点数舍入误差，当输入为整数时，您必须将每个结果系数四舍五入到最接近的整数。使用标准的四舍五入到最接近整数的方法。\n  - 除了强制确保长度为 $m+n-1$ 外，不要修剪前导或尾随的零。\n  - 程序的最终输出必须是单行，包含所有给定测试用例结果的逗号分隔列表，并用一对单独的方括号括起来。每个单独的结果本身也必须是一个采用相同方括号、逗号分隔形式的列表。例如，一个有效的整体输出格式是 $[[1,2,3],[4,5]]$。\n\n- 测试套件：\n  - 您的程序必须按此确切顺序为以下操作数对计算结果：\n    - 情况 $1$（一般情况）：$A = [3,2,5]$，$B = [5,1,2]$。\n    - 情况 $2$（长度不匹配和零）：$A = [-1,0,0,2]$，$B = [0,3]$。\n    - 情况 $3$（零多项式）：$A = [0]$，$B = [0]$。\n    - 情况 $4$（总长度非2的幂，中等规模）：$A = [1,1,1,1,1]$，$B = [1,2,3,4,5,6]$。\n    - 情况 $5$（负数和零）：$A = [2,-3,0,4]$，$B = [-1,5]$。\n\n- 可交付成果：\n  - 您的程序必须生成单行输出，其中包含如上所述的列表的逗号分隔列表形式的结果，不得包含任何额外文本。\n\n本问题不涉及角度或物理单位。本问题陈述中的所有数值量、符号、函数和变量均为数学实体，应按标准数学单位进行解释，无需额外的单位转换。答案完全由上述数值列表指定。", "solution": "该问题要求使用基于快速傅里叶变换 (FFT) 的分治算法来实现多项式乘法。解决方案基于卷积定理，该定理将两个序列的卷积与它们的傅里叶变换的逐点乘积联系起来。\n\n次数为 $m-1$ 的一元多项式 $A(x)$ 由其系数向量 $\\mathbf{a} = [a_0, a_1, \\dots, a_{m-1}]$ 表示，其中 $A(x) = \\sum_{i=0}^{m-1} a_i x^i$。同样，次数为 $n-1$ 的多项式 $B(x)$ 由 $\\mathbf{b} = [b_0, b_1, \\dots, b_{n-1}]$ 表示。它们的乘积 $C(x) = A(x)B(x)$ 是一个次数为 $(m-1) + (n-1) = m+n-2$ 的多项式。乘积多项式 $C(x)$ 的系数向量 $\\mathbf{c} = [c_0, c_1, \\dots, c_{m+n-2}]$ 由系数向量 $\\mathbf{a}$ 和 $\\mathbf{b}$ 的离散卷积给出：\n$$\nc_k = (\\mathbf{a} * \\mathbf{b})_k = \\sum_{j=0}^{k} a_j b_{k-j}\n$$\n直接计算此卷积需要 $\\mathcal{O}((m+n)^2)$ 的时间。FFT 提供了一种更高效的 $\\mathcal{O}(N \\log N)$ 方法，其中 $N$ 是变换大小。\n\n该算法主要分三个阶段进行：求值、逐点相乘和插值。\n\n1.  **填充与求值（正向 FFT）：**\n    为了使用卷积定理，我们将系数域表示转换为点值表示。这是通过在一组不同的点上对多项式进行求值来实现的。FFT 算法能高效地在 $N$ 个复数 $N$ 次单位根 $\\omega_N^k = e^{2\\pi i k / N}$ (对于 $k \\in \\{0, 1, \\dots, N-1\\}$) 处对一个 $N-1$ 次多项式进行求值。该求值的结果就是系数向量的离散傅里叶变换 (DFT)。\n\n    乘积多项式 $C(x)$ 有 $m+n-1$ 个系数。为确保逆变换的结果对应于线性卷积而非循环卷积，我们必须用零将系数向量 $\\mathbf{a}$ 和 $\\mathbf{b}$ 填充到长度 $N \\ge m+n-1$。为了基-2 FFT 算法的效率，$N$ 必须是 $2$ 的幂。问题指定选择满足此条件的最小的 $2$ 的幂。\n\n    正向 DFT 定义为：\n    $$\n    \\hat{\\mathbf{a}}_k = \\text{DFT}(\\mathbf{a})_k = \\sum_{j=0}^{N-1} a_j e^{-2\\pi i jk / N}\n    $$\n    我们实现一个递归的、分治的 Cooley-Tukey FFT 算法。一个大小为 $N$ 的输入向量被分成偶数索引和奇数索引的元素，每个子问题的大小为 $N/2$。这些子问题的 FFT 被递归计算，然后通过 $\\mathcal{O}(N)$ 时间的合并操作来产生最终结果。此合并步骤的递推关系为：\n    $$\n    \\hat{\\mathbf{a}}_k = \\hat{\\mathbf{a}}_{\\text{even}, k} + e^{-2\\pi i k / N} \\cdot \\hat{\\mathbf{a}}_{\\text{odd}, k}\n    $$\n    $$\n    \\hat{\\mathbf{a}}_{k + N/2} = \\hat{\\mathbf{a}}_{\\text{even}, k} - e^{-2\\pi i k / N} \\cdot \\hat{\\mathbf{a}}_{\\text{odd}, k}\n    $$\n    对于 $k \\in \\{0, 1, \\dots, N/2-1\\}$。递归的基例是长度为 1 的向量，其 FFT 就是向量本身。\n\n2.  **逐点相乘：**\n    卷积定理指出 $\\text{DFT}(\\mathbf{a} * \\mathbf{b}) = \\text{DFT}(\\mathbf{a}) \\cdot \\text{DFT}(\\mathbf{b})$，其中右侧的乘积是逐点（或称逐元素）相乘。在计算填充后系数向量的 DFT，即 $\\hat{\\mathbf{a}} = \\text{DFT}(\\mathbf{a}_{\\text{padded}})$ 和 $\\hat{\\mathbf{b}} = \\text{DFT}(\\mathbf{b}_{\\text{padded}})$ 之后，我们通过逐元素相乘这两个向量来计算乘积系数向量的 DFT，即 $\\hat{\\mathbf{c}}$：\n    $$\n    \\hat{c}_k = \\hat{a}_k \\cdot \\hat{b}_k \\quad \\text{for } k \\in \\{0, 1, \\dots, N-1\\}\n    $$\n\n3.  **插值（逆 FFT）与最终处理：**\n    为了从点值表示 $\\hat{\\mathbf{c}}$ 中恢复系数向量 $\\mathbf{c}$，我们应用逆离散傅里叶变换 (IDFT)：\n    $$\n    c_j = \\text{IDFT}(\\hat{\\mathbf{c}})_j = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{c}_k e^{2\\pi i jk / N}\n    $$\n    IDFT 的结构与正向 DFT 几乎相同，仅在复指数中指数的符号和最终的 $1/N$ 缩放因子上有所不同。因此，可以通过提供一个用于翻转指数符号的 `inverse` 标志，使用相同的递归 FFT 函数来计算 IDFT。\n\n    计算 IDFT 后，我们执行最后的处理步骤：\n    a.  将结果向量的每个元素缩放 $1/N$。\n    b.  由于输入系数是实数，结果系数也必须是实数。我们取结果中每个复数的实部，丢弃由浮点不精确性产生的微小虚部。\n    c.  问题指出，对于整数输入，结果应四舍五入到最接近的整数。我们使用 `numpy.round()`，它实现了“四舍五入到偶数”的标准，这是科学计算中的一个常用约定。\n    d.  最后，将长度为 $N$ 的结果向量截断为乘积多项式系数向量的正确长度，即 $m+n-1$。\n\n整个过程是：填充 $\\to$ FFT $\\to$ 逐点相乘 $\\to$ 逆 FFT $\\to$ 缩放、舍入和截断。这就得出了乘积多项式的最终系数列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef fft(coeffs, inverse=False):\n    \"\"\"\n    Computes the Discrete Fourier Transform (DFT) or its inverse (IDFT)\n    of a sequence using a recursive Cooley-Tukey radix-2 FFT algorithm.\n    The length of the input sequence must be a power of 2.\n    \"\"\"\n    n = len(coeffs)\n    if n == 1:\n        return coeffs\n\n    # Recursively compute FFT for even and odd indexed parts\n    coeffs_even = fft(coeffs[0::2], inverse)\n    coeffs_odd = fft(coeffs[1::2], inverse)\n\n    # Combine results\n    # The sign of the exponent depends on whether it is a forward or inverse transform.\n    factor = 2j * np.pi / n\n    if not inverse:\n        factor = -factor\n    \n    twiddle_base = np.exp(factor)\n    twiddle_k = 1.0 + 0.0j # Represents omega^k, starts at k=0\n\n    y = np.zeros(n, dtype=np.complex128)\n    for k in range(n // 2):\n        t = twiddle_k * coeffs_odd[k]\n        y[k] = coeffs_even[k] + t\n        y[k + n // 2] = coeffs_even[k] - t\n        twiddle_k *= twiddle_base\n    \n    return y\n\ndef multiply_poly(A, B):\n    \"\"\"\n    Multiplies two polynomials A and B represented by their coefficient lists\n    using an FFT-based algorithm.\n    \"\"\"\n    m = len(A)\n    n = len(B)\n    \n    # The product polynomial has degree (m-1) + (n-1), so it has m+n-1 coefficients.\n    result_len = m + n - 1\n    if result_len <= 0:\n        return []\n\n    # Determine transform size N, the smallest power of 2 >= result_len.\n    N = 1\n    while N < result_len:\n        N *= 2\n\n    # Pad input coefficient lists with zeros to length N.\n    # We use numpy arrays for vectorized operations and complex number support.\n    # The resize method pads with zeros.\n    A_padded = np.array(A, dtype=np.complex128)\n    A_padded.resize(N)\n    B_padded = np.array(B, dtype=np.complex128)\n    B_padded.resize(N)\n\n    # Step 1: Evaluation (Forward FFT)\n    A_fft = fft(A_padded, inverse=False)\n    B_fft = fft(B_padded, inverse=False)\n\n    # Step 2: Pointwise multiplication in the frequency domain\n    C_fft = A_fft * B_fft\n\n    # Step 3: Interpolation (Inverse FFT)\n    C_coeffs_padded = fft(C_fft, inverse=True)\n\n    # Step 4: Finalization\n    # Scale by 1/N and take the real part (imaginary part is due to float error).\n    coeffs = np.real(C_coeffs_padded) / N\n    \n    # Round to the nearest integer as specified for integer inputs.\n    # np.round uses \"round half to even\", a standard rounding method.\n    rounded_coeffs = np.round(coeffs).astype(int)\n    \n    # Truncate to the correct final length m+n-1 and convert to list.\n    return rounded_coeffs[:result_len].tolist()\n\n\ndef solve():\n    \"\"\"\n    Runs the polynomial multiplication for the test suite specified in the problem\n    and prints the results in the required format.\n    \"\"\"\n    test_cases = [\n        ([3, 2, 5], [5, 1, 2]),\n        ([-1, 0, 0, 2], [0, 3]),\n        ([0], [0]),\n        ([1, 1, 1, 1, 1], [1, 2, 3, 4, 5, 6]),\n        ([2, -3, 0, 4], [-1, 5]),\n    ]\n\n    results = []\n    for case in test_cases:\n        A, B = case\n        result = multiply_poly(A, B)\n        results.append(result)\n\n    # Format the final output string to be a single line, comma-separated list\n    # of lists, without spaces, e.g., [[1,2],[3,4,5]]\n    result_strings = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3228590"}]}