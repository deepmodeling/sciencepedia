{"hands_on_practices": [{"introduction": "二进制计数器是学习摊销分析的经典切入点。本练习将指导你使用势能法来分析 $m$ 次连续递增操作的总成本，但我们的目标不仅仅是得出一个上界，而是推导出精确的闭式表达式。通过这个过程，你将体会到势能法在精确量化总成本方面的强大能力，并熟悉最常用的势能函数之一。[@problem_id:3204641]", "problem": "一个二进制计数器以二进制（基数为$2$）形式存储非负整数，其中最低有效位在位置$0$。对于从状态 $i$ 到状态 $i+1$ 的每次增量操作，我们将操作的实际成本定义为 $i$ 和 $i+1$ 的二进制表示之间值发生变化的比特位数。该成本是 $i$ 和 $i+1$ 二进制表示之间的汉明距离，即两个等长字符串在相应位置上值不同的数量。\n\n从计数器状态 $0$ 开始，对于一个固定的正整数 $m$，执行恰好 $m$ 次连续的增量操作。设 $\\mathcal{C}(m)$ 为这 $m$ 次增量操作所累积的总实际成本。请从第一性原理出发，使用聚合方法、核算方法或势能方法中的任意一种，推导出一个关于 $\\mathcal{C}(m)$ 的精确闭式表达式，该表达式仅含 $m$ 项，不含求和符号。你可以使用函数符号 $s_{2}(m)$ 来表示 $m$ 的二进制表示中 1 的数量。\n\n你的最终答案必须是 $\\mathcal{C}(m)$ 的单个闭式解析表达式，答案中不得包含任何不等式或方程式。无需进行四舍五入。", "solution": "此问题是有效的，因为它是算法分析中的一个标准的、适定性的问题。它在数学和计算机科学上有科学依据，表述规范且客观。我们将使用摊销分析中的势能法来推导总成本 $\\mathcal{C}(m)$ 的闭式表达式。\n\n设二进制计数器经过 $i$ 次增量操作后的状态由整数 $i$ 表示。初始状态为 $0$。我们执行 $m$ 次增量操作序列，使计数器经历状态 $0, 1, 2, \\dots, m$。\n\n设 $c_k$ 为第 $k$ 次增量操作的实际成本，该操作使计数器从状态 $k-1$ 转换到状态 $k$。问题将此成本定义为在此转换期间翻转的比特数。$m$ 次增量操作的总实际成本为 $\\mathcal{C}(m) = \\sum_{k=1}^{m} c_k$。\n\n为应用势能法，我们定义一个势函数 $\\Phi$，它将数据结构的状态映射到一个实数。对于处于状态 $i$ 的计数器，一个合适的势函数选择（我们称之为 $\\Phi(i)$）是 $i$ 的二进制表示中 1 的数量。我们使用问题中的符号 $s_2(i)$ 来表示这个量。\n$$\n\\Phi(i) = s_2(i)\n$$\n为使势能法有效，必须对所有状态 $i$ 满足 $\\Phi(i) \\ge \\Phi(0)$。初始状态为 $0$，且 $\\Phi(0) = s_2(0) = 0$。由于任何非负整数的二进制表示中 1 的数量都是非负的，因此对于所有 $i \\ge 0$，有 $s_2(i) \\ge 0$。因此，条件 $\\Phi(i) \\ge \\Phi(0)$ 得以满足。\n\n第 $k$ 次操作的摊销成本 $a_k$ 定义为实际成本加上势能的变化：\n$$\na_k = c_k + \\Phi(k) - \\Phi(k-1)\n$$\n我们来分析第 $k$ 次增量操作（从状态 $k-1$ 到 $k$）中计数器的变化。假设 $k-1$ 的二进制表示有 $j$ 个尾随的 1。也就是说，其二进制形式为 $\\dots p_j 0 1 \\dots 1$，其中末尾有一个由 $j$ 个 1 组成的连续块，前面是一个 0。\n增量操作将这 $j$ 个 1 翻转为 0，并将最右边的 0（在位置 $j$）翻转为 1。位置 $j$ 左侧的所有比特保持不变。\n此操作中的比特翻转次数为 $j$（对于 $1 \\to 0$ 的翻转）加上 $1$（对于 $0 \\to 1$ 的翻转）。因此，实际成本为：\n$$\nc_k = j+1\n$$\n这也涵盖了 $k-1$ 是偶数的情况，即其二进制表示以 $0$ 结尾。在这种情况下，$j=0$，只有最后一位从 $0$ 翻转到 $1$，所以 $c_k=1$，与公式相符。\n\n现在，我们计算势能的变化，$\\Phi(k) - \\Phi(k-1) = s_2(k) - s_2(k-1)$。\n状态 $k-1$ 中 1 的数量可以用高于位置 $j$ 的比特中 1 的数量（我们称之为 $N$）和 $j$ 个尾随的 1 来表示。所以，$s_2(k-1) = N+j$。\n在状态 $k$ 中， $j$ 个尾随的 1 变成了 0，而位置 $j$ 处的 0 变成了 1。更高位的比特保持不变。因此，状态 $k$ 中 1 的数量是 $s_2(k) = N+1$。\n1 的数量的变化是：\n$$\ns_2(k) - s_2(k-1) = (N+1) - (N+j) = 1-j\n$$\n这给出了势能的变化：$\\Delta\\Phi_k = \\Phi(k) - \\Phi(k-1) = 1-j$。\n\n现在我们可以计算摊销成本 $a_k$：\n$$\na_k = c_k + \\Delta\\Phi_k = (j+1) + (1-j) = 2\n$$\n每次增量操作的摊销成本是一个常数，$2$。\n\n总实际成本 $\\mathcal{C}(m)$ 通过摊销分析的基本定理与总摊销成本相关联：\n$$\n\\sum_{k=1}^{m} c_k = \\sum_{k=1}^{m} a_k - (\\Phi(m) - \\Phi(0))\n$$\n代入已知量：\n$$\n\\mathcal{C}(m) = \\sum_{k=1}^{m} 2 - (s_2(m) - s_2(0))\n$$\n常数摊销成本的总和是 $\\sum_{k=1}^{m} 2 = 2m$。初始状态的势能是 $\\Phi(0) = s_2(0) = 0$。最终状态的势能是 $\\Phi(m) = s_2(m)$。\n代入这些值，我们得到总实际成本的表达式：\n$$\n\\mathcal{C}(m) = 2m - (s_2(m) - 0)\n$$\n$$\n\\mathcal{C}(m) = 2m - s_2(m)\n$$\n这就是从 $0$ 开始对一个二进制计数器进行 $m$ 次连续增量操作期间发生的比特翻转总次数的精确闭式表达式。该表达式由 $2m$ 项和作为最终状态 $m$ 中 1 的数量的修正项组成。", "answer": "$$\\boxed{2m - s_{2}(m)}$$", "id": "3204641"}, {"introduction": "现在，我们将视角从计数器转向另一种基本数据结构——栈，并运用聚合方法进行分析。这个问题模拟了一个包含廉价操作（$PUSH$）和潜在昂贵操作（$MULTI-POP$）的序列，这是摊销分析大显身手的典型场景。你将学习如何通过一个简单的全局不变量来约束整个操作序列的总成本，从而领会聚合分析的直观和有效性。[@problem_id:3204566]", "problem": "考虑一个栈抽象数据类型（ADT），它在后进先出（LIFO）原则下支持以下操作：一个 `` `PUSH(x)` `` 操作，将元素 $x$ 放置到栈顶；以及一个 `` `MULTI-POP(k)` `` 操作，该操作重复应用基本操作 `POP`，最多 $k$ 次，或直到栈变为空，以先发生者为准。假设栈初始为空。采用以下单位成本模型：每次 `` `PUSH` `` 的实际成本为 $1$，每次成功的单次 `POP` 操作的实际成本为 $1$；`` `MULTI-POP(k)` `` 的实际成本是它执行的成功单次 `POP` 操作的次数。给定一个操作序列，其中包含恰好 $n^{2}$ 次 `` `PUSH` `` 操作和恰好 $n$ 次 `` `MULTI-POP(n)` `` 操作，这些操作以任意方式交错排列。\n\n使用摊还分析中的聚合方法，从栈的核心定义和给定的成本模型出发，推导出整个序列的精确最坏情况总实际成本，并将其表示为 $n$ 的函数。您的答案必须是关于 $n$ 的单个闭式表达式。无需进行舍入，最终表达式中也不应包含任何单位。", "solution": "该问题经评估为有效，因为它在科学上基于计算机科学的原理，特别是算法和数据结构的分析。问题提法明确，所有必要的条件、定义和约束都已清楚说明。其语言客观且正式。\n\n任务是使用聚合方法，找出一个由 $n^2$ 次 `PUSH` 操作和 $n$ 次 `MULTI-POP(n)` 操作组成的 $n^2 + n$ 个操作的序列的最坏情况总实际成本。\n\n设 $C_{total}$ 为整个操作序列的总实际成本。总成本是序列中所有单个操作的实际成本之和。\n$$\nC_{total} = \\sum_{i=1}^{n^2+n} c_i\n$$\n其中 $c_i$ 是序列中第 $i$ 个操作的实际成本。\n\n该序列包含两种类型的操作：`PUSH` 和 `MULTI-POP`。我们可以将总成本分解为所有 `PUSH` 操作的成本之和（我们称之为 $C_{\\text{PUSH}}$）以及所有 `MULTI-POP` 操作的成本之和（$C_{\\text{MULTI-POP}}$）。\n$$\nC_{total} = C_{\\text{PUSH}} + C_{\\text{MULTI-POP}}\n$$\n\n首先，我们来分析 `PUSH` 操作贡献的成本。\n问题陈述中明确指出有 $n^2$ 次 `PUSH` 操作。\n每次 `PUSH` 操作的实际成本定义为 $1$。\n因此，所有 `PUSH` 操作的总成本是固定的，与它们在序列中的位置无关：\n$$\nC_{\\text{PUSH}} = n^2 \\times 1 = n^2\n$$\n\n接下来，我们分析 `MULTI-POP` 操作贡献的成本。\n有 $n$ 次 `MULTI-POP(n)` 操作。\n一次 `MULTI-POP(k)` 操作的实际成本定义为它执行的成功单次 `POP` 操作的次数。如果一次单次 `POP` 操作从非空栈中移除了一个元素，则该操作是成功的。\n栈的一个核心原则是，一个元素只有在先前被压入栈后才能被弹出。由于栈初始为空，每个被弹出的元素都必须对应于序列中较早发生的一次唯一的 `PUSH` 操作。每个被压入的元素最多只能被弹出一次。\n\n这个基本关系为聚合分析提供了一个关键的界限。在整个操作序列中，成功的单次 `POP` 操作的总数不能超过所执行的 `PUSH` 操作的总数。\n设 $N_{pop}$ 为序列中成功的单次 `POP` 操作的总数，$N_{push}$ 为 `PUSH` 操作的总数。\n我们有：\n$$\nN_{pop} \\le N_{push}\n$$\n在本问题中，$N_{push} = n^2$。\n所有 `MULTI-POP` 操作的总成本 $C_{\\text{MULTI-POP}}$ 等于成功的单次 `POP` 操作的总数 $N_{pop}$。\n因此，我们得到了这部分成本的一个上界：\n$$\nC_{\\text{MULTI-POP}} = N_{pop} \\le n^2\n$$\n\n现在，我们可以为任何可能的操作交错方式，建立总实际成本 $C_{total}$ 的一个上界。\n$$\nC_{total} = C_{\\text{PUSH}} + C_{\\text{MULTI-POP}} \\le n^2 + n^2 = 2n^2\n$$\n\n为了确定这个上界是否代表了精确的最坏情况总实际成本，我们必须证明存在至少一个操作序列，其成本能够达到这个值。如果我们能构造出这样一个序列，那么 $2n^2$ 确实就是最坏情况成本。\n\n考虑以下序列，这是其中一种可能的任意交错方式：\n1.  首先，连续执行所有 $n^2$ 次 `PUSH` 操作。\n2.  然后，连续执行所有 $n$ 次 `MULTI-POP(n)` 操作。\n\n让我们计算这个特定序列的总成本，假设 $n \\ge 1$。$n=0$ 的情况是平凡的，导致 $0$ 次操作和 $0$ 成本，这与 $2(0)^2=0$ 相符。\n-   **`PUSH` 阶段的成本：** 有 $n^2$ 次 `PUSH` 操作，每次成本为 $1$。此阶段的总成本是 $n^2 \\times 1 = n^2$。在此阶段之后，栈中包含 $n^2$ 个元素。\n\n-   **`MULTI-POP` 阶段的成本：** 此阶段包含 $n$ 次对 `MULTI-POP(n)` 的调用。\n    -   在第1次 `MULTI-POP(n)` 调用时，栈中包含 $n^2$ 个元素。由于 $n \\le n^2$（对于 $n \\ge 1$），该操作成功弹出 $n$ 个元素。其成本为 $n$。栈中现在包含 $n^2 - n$ 个元素。\n    -   在第2次 `MULTI-POP(n)` 调用时，栈中包含 $n^2 - n$ 个元素。由于 $n \\le n^2 - n$（对于 $n \\ge 2$），该操作成功弹出 $n$ 个元素。其成本为 $n$。栈中现在包含 $n^2 - 2n$ 个元素。\n    -   一般来说，在第 $i$ 次 `MULTI-POP(n)` 调用时（其中 $1 \\le i \\le n$），栈中包含 $n^2 - (i-1)n$ 个元素。为了使该操作能弹出 $n$ 个元素，栈的大小必须至少为 $n$。我们检验此条件：\n        $$\n        n^2 - (i-1)n = n(n - (i-1)) = n(n - i + 1)\n        $$\n        因为 $i \\le n$，所以有 $n-i \\ge 0$，这意味着 $n-i+1 \\ge 1$。因此，栈的大小 $n(n-i+1)$ 总是大于或等于 $n$。\n    -   这证明了 $n$ 次 `MULTI-POP(n)` 调用中的每一次都将完全成功，恰好弹出 $n$ 个元素。\n    -   $n$ 次 `MULTI-POP(n)` 操作中每次的成本都是 $n$。\n    -   此阶段的总成本是 $n \\times (\\text{每次调用的成本}) = n \\times n = n^2$。\n\n这个特定的最坏情况序列的总实际成本是两个阶段成本的总和：\n$$\nC_{\\text{total, worst}} = (\\text{`PUSH` 操作的成本}) + (\\text{`MULTI-POP` 操作的成本}) = n^2 + n^2 = 2n^2\n$$\n\n由于我们已经为任何序列的总成本建立了一个 $2n^2$ 的上界，并且构造了一个达到此成本的特定序列，因此我们得出结论：整个序列的精确最坏情况总实际成本是 $2n^2$。这就完成了使用聚合方法的推导过程。", "answer": "$$\\boxed{2n^{2}}$$", "id": "3204566"}, {"introduction": "本练习是对你摊销分析理解能力的进阶考验，我们回归二进制计数器，但引入一个非标准的成本模型。在这个模型中，标准势能函数将不再适用，你必须从第一性原理出发，为这个特定成本模型量身打造一个新的势能函数或信用不变式。解决这个问题将证明你已掌握摊销分析的精髓——即其方法的灵活性与普适性。[@problem_id:3204622]", "problem": "给定一个无界二进制计数器，其位由非负整数索引，位 $i$ 的权重为 $2^{i}$，位 $0$ 是最低有效位 (LSB)。计数器从全零状态开始。一次增量操作以二进制方式给计数器加 $1$，这会把末尾连续的 $1$ 位块（如果有的话）翻转为 $0$，然后将下一个更高的 $0$ 位翻转为 $1$。实际成本模型如下：翻转位 $i$ 的成本为 $i+1$。因此，一次增量的实际成本是该次增量所翻转的所有位 $i$ 的 $i+1$ 之和。考虑从全零状态开始的任意 $m$ 次增量序列，假设没有溢出（计数器有足够多的位，以使所有 $m$ 次增量都可行）。\n\n仅从二进制增量的形式语义和上述成本模型出发，完成以下任务。\n- 使用聚合方法，通过计算每个位 $i$ 在前 $m$ 次增量中翻转了多少次，并对这些贡献求和，来推导 $m$ 次增量总成本 $C(m)$ 的一个闭式上界。你的推导必须从第一性原理开始，并且只能使用基本的级数知识。\n- 使用核算法，提出一个固定的每次增量的摊还费用 $c$，以及一个信用不变式，该不变式根据位 $i$ 及其当前是 $1$ 还是 $0$ 的状态，为每个位 $i$ 分配一个非负的存储信用额度，使得对于每次增量，从翻转为 $0$ 的位释放的信用额度与收取的费用 $c$ 一起，足以支付该次增量的实际成本并重新建立不变式。证明这个方案对于从零状态开始的所有 $m$ 都有效，并确定使之可行的最小常数 $c$。\n- 使用势能法，定义一个仅依赖于当前位模式的势函数 $\\Phi$，并证明每次增量的摊还成本（定义为实际成本加上势能变化）对于每一次增量（无论 $m$ 为何值）都精确地等于你通过核算法找到的那个常数 $c$。\n- 最后，使用你的聚合分析来评估 $\\lim_{m \\to \\infty} \\frac{C(m)}{m}$，并论证你得到的常数 $c$ 是紧确的。\n\n将最小常数 $c$ 作为你的最终答案。无需四舍五入，也不涉及单位。最终答案必须是一个实数。", "solution": "这个问题要求在一个非标准成本模型下，对二进制计数器的增量操作进行摊还分析。我们被要求使用聚合方法、核算法和势能法来找出并证明一个 $m$ 次增量序列的最紧确的常数摊还成本。\n\n首先，我们来确定成本模型和操作动态。一个二进制计数器从 $0$ 开始。一次增量操作加 $1$。这会导致末尾的一串 $1$ 翻转为 $0$，以及下一个 $0$ 翻转为 $1$。翻转位 $i$ 的成本定义为 $i+1$。一次增量的实际成本是所有被翻转位的成本之和。\n\n**1. 聚合方法**\n\n聚合方法计算一个包含 $m$ 次操作的序列的总实际成本 $C(m)$，然后确定每次操作的平均成本，即 $C(m)/m$。\n\n为了找到 $C(m)$，我们对 $m$ 次增量过程中的所有位翻转成本进行求和。我们可以按位来求和，而不是按每次增量来求和。总成本 $C(m)$ 是对所有位 $i$ 的贡献求和，即其翻转成本 $(i+1)$ 乘以其在前 $m$ 次增量中的翻转次数。\n\n翻转位 $i$ 的成本为 $i+1$。\n当计数器从值 $v$ 变为 $v+1$，且 $v$ 和 $v+1$ 的二进制表示在位 $i$ 上不同时，位 $i$ 会翻转。这恰好发生在加 $1$ 操作产生的进位传播到位 $i$ 时。位 $i$ 从 $0$ 翻转到 $1$ 或从 $1$ 翻转到 $0$ 的充要条件是，在增量操作之前，位 $0, 1, \\dots, i-1$ 全都是 $1$。这发生在计数器值为 $k \\cdot 2^i + (2^i - 1)$（对于任意整数 $k \\ge 0$）的形式时。增量操作将值变为 $(k+1) \\cdot 2^i$。因此，如果在第 $j$ 次增量时 $j$ 是 $2^i$ 的倍数，位 $i$ 就会翻转。\n\n在一个 $m$ 次增量的序列中（从值 $0$ 到 $m-1$，最终计数器值为 $m$），位 $i$ 会在第 $1 \\cdot 2^i, 2 \\cdot 2^i, 3 \\cdot 2^i, \\dots, \\lfloor m/2^i \\rfloor \\cdot 2^i$ 次增量时翻转。位 $i$ 翻转的次数恰好是 $\\lfloor m/2^i \\rfloor$。\n\n总成本 $C(m)$ 是对所有位 $i$ 的求和：\n$$C(m) = \\sum_{i=0}^{\\infty} (i+1) \\left\\lfloor \\frac{m}{2^i} \\right\\rfloor$$\n这个和是有限的，因为当 $2^i > m$ 时，项 $\\lfloor m/2^i \\rfloor$ 变为 $0$。\n\n为了找到一个闭式上界，我们使用不等式 $\\lfloor x \\rfloor \\le x$：\n$$C(m) \\le \\sum_{i=0}^{\\infty} (i+1) \\frac{m}{2^i} = m \\sum_{i=0}^{\\infty} \\frac{i+1}{2^i}$$\n这个和是一个算术-几何级数。设 $S = \\sum_{k=0}^{\\infty} (k+1)x^k$。这个级数是一个相关几何级数的导数。我们知道对于 $|x|1$，有 $\\sum_{k=0}^{\\infty} x^k = \\frac{1}{1-x}$。对 $x$ 求导得到 $\\sum_{k=1}^{\\infty} kx^{k-1} = \\frac{1}{(1-x)^2}$。令 $i=k-1$，则为 $\\sum_{i=0}^{\\infty} (i+1)x^i = \\frac{1}{(1-x)^2}$。\n对于我们的求和，$x=1/2$，所以：\n$$S = \\sum_{i=0}^{\\infty} \\frac{i+1}{2^i} = \\frac{1}{(1-1/2)^2} = \\frac{1}{(1/4)} = 4$$\n因此，总成本有上界：\n$$C(m) \\le 4m$$\n这表明每次操作的摊还成本为 $4$。\n\n**2. 核算法**\n\n在核算法中，我们为每次操作收取一个固定的摊还成本 $c$。这笔费用的一部分用于支付当前的实际成本，其余部分作为“信用”存储在数据结构上。这个信用可以在以后用来支付昂贵的操作。总信用额度永远不能为负。\n\n根据我们的聚合分析，我们提议摊还费用为 $c=4$。我们需要定义一个信用不变式。一个常见的策略是将信用存储在被设置为 $1$ 的位上。我们定义信用不变式：\n*如果位 $i$ 是 $1$，它存储 $\\phi_i$ 的信用。*\n*如果位 $i$ 是 $0$，它存储 $0$ 的信用。*\n\n我们需要确定函数 $\\phi_i$。初始状态是全零，所以总信用为 $0$。\n考虑一次增量操作，它将位 $0, 1, \\dots, k-1$ 从 $1$ 翻转为 $0$，并将位 $k$ 从 $0$ 翻转为 $1$。\n这次操作的实际成本是 $A_k = (\\sum_{i=0}^{k-1} (i+1)) + (k+1) = \\frac{k(k+1)}{2} + (k+1) = \\frac{(k+1)(k+2)}{2}$。\n为了支付这次操作，我们使用收取的费用 $c$以及从 $1$ 翻转为 $0$ 的位所释放的任何信用。\n释放的信用：$\\sum_{i=0}^{k-1} \\phi_i$。\n操作之后，我们必须通过在现在为 $1$ 的位 $k$ 上存储信用，来重新建立不变式。\n需要存储的信用：$\\phi_k$。\n\n核算法的基本不等式是：\n摊还费用 + 释放的信用 $\\ge$ 实际成本 + 存储的信用\n$$c + \\sum_{i=0}^{k-1} \\phi_i \\ge \\frac{(k+1)(k+2)}{2} + \\phi_k$$\n我们需要找到一个非负函数 $\\phi_i$，使得对于 $c=4$ 和所有 $k \\ge 0$，这个不等式都成立。我们尝试通过将此设为等式来找到 $\\phi_i$：\n$$4 = \\frac{(k+1)(k+2)}{2} + \\phi_k - \\sum_{i=0}^{k-1} \\phi_i$$\n让我们测试一个简单的线性函数，比如 $\\phi_i = i+B$。\n$$4 = \\frac{k^2+3k+2}{2} + (k+B) - \\sum_{i=0}^{k-1} (i+B)$$\n$$4 = \\frac{k^2+3k+2}{2} + k+B - \\left(\\frac{(k-1)k}{2} + Bk\\right)$$\n$$4 = \\frac{k^2+3k+2}{2} + k+B - \\frac{k^2-k}{2} - Bk$$\n$$8 = k^2+3k+2 + 2k+2B - k^2+k - 2Bk$$\n$$8 = 6k+2+2B(1-k)$$\n这个方程依赖于 $k$，所以 $\\phi_i=i+B$ 是不正确的。\n\n让我们从思考过程中发展出的第一性原理来推导 $\\phi_i$。$m$ 次增量后的总成本是 $C(m) = \\sum_{j=1}^m (\\text{摊还成本}_j - \\Delta \\Phi_j) = mc - (\\Phi_m - \\Phi_0)$。当 $\\Phi_0=0$ 时，$C(m)=mc - \\Phi_m$。根据聚合方法，$C(m) = \\sum_{i=0}^\\infty (i+1)\\lfloor m/2^i \\rfloor$。我们设置 $mc - \\Phi_m \\ge C(m)_{exact}$。我们需要 $\\Phi_m\\le mc-C(m) = m \\sum \\frac{i+1}{2^i} - \\sum(i+1)\\lfloor \\frac{m}{2^i} \\rfloor = \\sum (i+1)(m/2^i - \\lfloor m/2^i \\rfloor) = \\sum(i+1)\\{m/2^i\\}$。\n我们知道 $\\{m/2^i\\} = \\sum_{j=0}^{i-1} b_j 2^{j-i}$，其中 $b_j$ 是 $m$ 的第 $j$ 位。\n$\\Phi_m = \\sum_j b_j \\phi_j \\le \\sum_i (i+1) \\sum_{j=0}^{i-1} b_j 2^{j-i} = \\sum_j b_j (\\sum_{i=j+1}^\\infty (i+1)2^{j-i})$。\n如果我们设置 $\\phi_j = \\sum_{i=j+1}^{\\infty} (i+1)2^{j-i} = 2^j \\sum_{i=j+1}^{\\infty} \\frac{i+1}{2^i}$，这个条件就满足了。\n这个和是 $S - S_j = 4 - (4 - \\frac{j+3}{2^j}) = \\frac{j+3}{2^j}$。\n所以, $\\phi_j = 2^j (\\frac{j+3}{2^j}) = j+3$。\n我们的信用不变式是：一个设置为 $1$ 的位 $i$ 存储 $\\phi_i = i+3$ 的信用。\n让我们对 $c=4$ 来验证这一点。\n$$4 + \\sum_{i=0}^{k-1} (i+3) \\ge \\frac{(k+1)(k+2)}{2} + (k+3)$$\n$$4 + \\frac{(k-1)k}{2} + 3k \\ge \\frac{k^2+3k+2}{2} + k+3$$\n$$4 + \\frac{k^2-k+6k}{2} \\ge \\frac{k^2+3k+2+2k+6}{2}$$\n$$4 + \\frac{k^2+5k}{2} \\ge \\frac{k^2+5k+8}{2}$$\n$$\\frac{8+k^2+5k}{2} \\ge \\frac{k^2+5k+8}{2}$$\n这是一个等式，所以它成立。对于任何一次增量，费用 $c=4$ 都恰好足够支付实际成本并维持信用不变式。因此，最小的常数费用是 $c=4$。\n\n**3. 势能法**\n\n势能法定义了一个势函数 $\\Phi$，它将数据结构的状态映射到一个非负实数，初始状态的 $\\Phi=0$。一次操作的摊还成本 $c_a$ 是其真实成本 $c_{act}$ 加上势能的变化量，即 $c_a = c_{act} + \\Delta\\Phi$。\n\n我们使用核算法中的信用函数来定义我们的势函数。设计数器的状态由值为 $1$ 的位的索引集合 $S$ 定义。\n$$\\Phi(S) = \\sum_{i \\in S} (i+3)$$\n初始状态是全零，所以 $S=\\emptyset$ 且 $\\Phi(\\emptyset)=0$。由于 $i \\ge 0$，对于所有状态 $\\Phi(S) \\ge 0$。\n\n考虑一次增量，它将位 $0, 1, \\dots, k-1$ 从 $1$ 翻转为 $0$，并将位 $k$ 从 $0$ 翻转为 $1$。\n之前的状态是 $S_{old} = \\{0, 1, \\dots, k-1\\} \\cup S'$，其中 $S'$ 代表大于 $k$ 且值为 $1$ 的位。\n之后的状态是 $S_{new} = \\{k\\} \\cup S'$。\n实际成本是 $c_{act} = \\frac{(k+1)(k+2)}{2}$。\n势能的变化是 $\\Delta\\Phi = \\Phi(S_{new}) - \\Phi(S_{old})$。\n$\\Phi(S_{new}) = (k+3) + \\sum_{i \\in S'} (i+3)$。\n$\\Phi(S_{old}) = \\sum_{i=0}^{k-1} (i+3) + \\sum_{i \\in S'} (i+3)$。\n$\\Delta\\Phi = (k+3) - \\sum_{i=0}^{k-1} (i+3) = (k+3) - \\left(\\frac{(k-1)k}{2} + 3k\\right) = k+3 - \\frac{k^2-k+6k}{2} = \\frac{2k+6 - k^2-5k}{2} = \\frac{-k^2-3k+6}{2}$。\n摊还成本是：\n$$c_a = c_{act} + \\Delta\\Phi = \\frac{k^2+3k+2}{2} + \\frac{-k^2-3k+6}{2} = \\frac{8}{2} = 4$$\n每次增量操作的摊还成本都精确地为 $4$，无论计数器的状态如何。这证实了 $c=4$ 是一个有效的常数攤還成本。\n\n**4. 渐近分析与紧确性**\n\n常数 $c=4$ 是平均成本的一个上界。为了证明它是紧确的，我们必须表明每次操作的平均成本可以任意接近 $4$。我们可以通过分析当操作次数 $m$ 趋于无穷大时平均成本的变化来做到这一点。\n\n$m$ 次增量后的平均成本是 $\\frac{C(m)}{m}$。使用聚合分析中的公式：\n$$\\frac{C(m)}{m} = \\frac{1}{m} \\sum_{i=0}^{\\infty} (i+1) \\left\\lfloor \\frac{m}{2^i} \\right\\rfloor = \\sum_{i=0}^{\\infty} (i+1) \\frac{\\lfloor m/2^i \\rfloor}{m}$$\n当 $m \\to \\infty$ 时，项 $\\frac{\\lfloor m/2^i \\rfloor}{m}$ 趋近于 $\\frac{m/2^i}{m} = \\frac{1}{2^i}$。所以我们可以求极限：\n$$\\lim_{m\\to\\infty} \\frac{C(m)}{m} = \\lim_{m\\to\\infty} \\sum_{i=0}^{\\infty} (i+1) \\frac{\\lfloor m/2^i \\rfloor}{m} = \\sum_{i=0}^{\\infty} (i+1) \\lim_{m\\to\\infty} \\frac{\\lfloor m/2^i \\rfloor}{m}$$\n(极限和求和的交换是由控制收敛定理保证的，因为各项被一个绝对收敛级数 $(i+1)/2^i$ 所界定。)\n$$\\lim_{m\\to\\infty} \\frac{C(m)}{m} = \\sum_{i=0}^{\\infty} \\frac{i+1}{2^i} = 4$$\n由于每次操作的平均成本趋近于 $4$，任何小于 $4$ 的常数摊还成本都不可能对所有 $m$ 都有效。如果我们选择 $c'  4$，对于足够大的 $m$，总支付 $m c'$ 将会小于总实际成本 $C(m) \\approx 4m$，这违反了摊还成本的定义。\n因此，常数 $c=4$ 是可能的最小值，即它是紧确的。\n\n总之，三种摊还分析方法都一致地指向最小常数摊还成本为 $4$。", "answer": "$$\\boxed{4}$$", "id": "3204622"}]}