{"hands_on_practices": [{"introduction": "让我们从实现一种最高效、最优雅的凸包算法——单调链算法（Monotone Chain Algorithm）开始。这项练习将引导你从基本几何原理（如字典序排序和方向测试）出发，一步步构建完整的算法。通过完成这个练习 [@problem_id:3205841]，你不仅能获得一段可工作的代码，更能深刻理解如何将点集分解为上下两个凸壳，并最终组合成完整的凸包。", "problem": "你需要设计、规约并用代码实现一个函数，该函数使用单调链算法计算一个有限二维点集的凸包。你的推理基础必须从以下几点出发：平面 $\\mathbb{R}^2$ 中的凸性定义、有限点集的凸包定义（即包含该点集的最小凸集）、点对 $(x,y)$ 的字典序概念，以及作为增量构造过程中维持凸性准则的三点方向性概念。不要使用任何快捷公式或预先给定的算法模板；相反，你必须从这些基本定义和事实中推导出你将要规约的算法步骤。你的规约必须是一个带有精确契约、清晰的伪代码函数，并且必须可以直接实现。\n\n给定一个具有整数坐标的有限集合 $P \\subset \\mathbb{R}^2$，定义一个伪代码函数，该函数对于输入 $P$，返回凸包多边形的顶点。这些顶点需按逆时针排序，从字典序最小的点（首先按 $x$ 排序，然后按 $y$ 排序）开始，移除重复点，并且从返回的顶点列表中排除严格位于内部的共线点。返回的多边形末尾不能重复起始顶点。如果输入的不同点少于 $2$ 个，则返回按字典序排序的这些不同点。如果所有点共线，则仅返回按字典序排序的两个极端端点。\n\n你的最终程序应实现你的伪代码，并针对以下明确的点集测试套件运行。每个测试用例都是一个由有序对表示的点列表，每个坐标对都以数学符号形式提供。角度单位不适用于本问题。没有物理单位。每个测试用例所需的输出类型是一个整数列表的列表。\n\n测试套件：\n- 测试用例 $1$（包含内部点的一般情况）：$[(0,0),(2,0),(2,2),(0,2),(1,1)]$\n- 测试用例 $2$（空集）：$[]$\n- 测试用例 $3$（单点）：$[(5,5)]$\n- 测试用例 $4$（包含重复点的共线点）：$[(0,0),(1,1),(2,2),(3,3),(1,1),(2,2)]$\n- 测试用例 $5$（所有点都在边界上，且包含边界上的共线点）：$[(0,0),(3,0),(3,3),(0,3),(1,0),(2,0),(3,1),(3,2),(2,3),(1,3),(0,2),(0,1)]$\n- 测试用例 $6$（两个相同的点）：$[(7,7),(7,7)]$\n- 测试用例 $7$（包含内部点和负坐标的菱形）：$[(-2,0),(0,2),(2,0),(0,-2),(-1,0),(0,1),(1,0),(0,-1)]$\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的结果列表。每个结果必须是对应输入的凸包，表示为一个点列表，其中每个点是一个双整数列表 $[x,y]$，且凸包从字典序最小的顶点开始按逆时针排序。例如，三个用例的输出可能看起来像 $[[x_1,y_1],[x_2,y_2]],[[u_1,v_1],[u_2,v_2],[u_3,v_3]],[]]$ 聚合为单个列表：$[[[x_1,y_1],[x_2,y_2]],[[u_1,v_1],[u_2,v_2],[u_3,v_3]],[]]$。\n- 你的程序必须完全自包含，不得读取任何输入；它必须完全按照上面提供的方式使用测试套件。", "solution": "用户要求设计并实现用于计算二维点集凸包的单调链算法。推导过程必须基于第一性原理：凸性、凸包的定义、字典序以及三点组的方向性。\n\n### 步骤 1：问题验证\n\n**1.1. 提取给定信息**\n\n*   **输入**：一个具有整数坐标的有限二维点集 $P \\subset \\mathbb{R}^2$。\n*   **算法**：单调链。\n*   **基本概念**：\n    *   $\\mathbb{R}^2$ 中的凸性定义。\n    *   有限点集的凸包定义。\n    *   点对 $(x,y)$ 的字典序。\n    *   三点组的方向性。\n*   **输出约束**：\n    *   返回凸包多边形的顶点列表。\n    *   顶点必须按逆时针排序。\n    *   排序必须从字典序最小的点开始。\n    *   必须移除输入的重复点。\n    *   必须排除边上严格位于内部的共线点。\n    *   返回的多边形末尾不能重复起始顶点。\n*   **边界情况**：\n    *   如果不同点少于 $2$ 个，则返回按字典序排序的这些不同点。\n    *   如果所有点共线，则仅返回按字典序排序的两个极端端点。\n*   **测试套件**：提供了七个特定的测试用例。\n*   **最终输出格式**：单行表示测试套件结果的列表，其中每个结果是一个点列表（每个点是一个双整数列表）。\n\n**1.2. 使用提取的信息进行验证**\n\n*   **科学依据**：该问题是计算几何学中一个标准的、成熟的问题。所有概念（凸包、单调链算法、字典序、方向测试）都是基础且数学上合理的。\n*   **良态问题**：该问题是良态的。输入已定义，期望输出已精确指定，约束条件（排序、共线点处理）清晰。对于任何给定的有限点集，都存在唯一解。\n*   **客观性**：问题以精确、客观的数学语言陈述。没有主观或模棱两可的术语。\n*   **完整性**：问题提供了所有必要信息，包括要使用的算法、推导的基础原理以及一个全面的测试套件。诸如如何处理共线点和少量输入等约束条件都已明确定义，消除了歧义。\n\n**1.3. 结论与行动**\n\n该问题被判定为**有效**。这是一个来自数据结构与算法领域的形式化、自包含且良态的问题。我将继续进行基于原理的推导和求解。\n\n### 步骤 2：基于原理的推导与算法规约\n\n**2.1. 基本原理**\n\n1.  **凸性**：一个集合 $S \\subset \\mathbb{R}^2$ 是凸的，如果对于 $S$ 中的任意两点 $p_1, p_2 \\in S$，连接它们的线段完全包含在 $S$ 内。\n2.  **凸包**：有限点集 $P$ 的凸包，记作 $CH(P)$，是包含 $P$ 中所有点的最小凸集。对于有限点集，$CH(P)$ 是一个凸多边形，其顶点是 $P$ 的一个子集。\n3.  **字典序**：对于两个点 $p_1 = (x_1, y_1)$ 和 $p_2 = (x_2, y_2)$，我们说 $p_1$ 的字典序小于 $p_2$，记作 $p_1  p_2$，当且仅当 $(x_1  x_2)$ 或 $(x_1 = x_2 \\text{ 且 } y_1  y_2)$。这种全序关系使我们能够唯一地对所有点进行排序。字典序最小和最大的点保证是凸包的顶点。\n4.  **方向测试**：一个有序三点组 $(p_1, p_2, p_3)$ 的方向决定了从 $p_1$ 到 $p_2$ 再到 $p_3$ 的路径是构成“左转”（逆时针，CCW）、“右转”（顺时针，CW），还是三点共线。这可以通过向量 $\\vec{p_1p_2}$ 和 $\\vec{p_1p_3}$ 的二维叉积来计算。设 $p_1=(x_1,y_1)$，$p_2=(x_2,y_2)$ 和 $p_3=(x_3,y_3)$。方向值 $O$ 为：\n    $$O(p_1, p_2, p_3) = (x_2 - x_1)(y_3 - y_1) - (y_2 - y_1)(x_3 - x_1)$$\n    *   $O  0$：逆时针（左转）。\n    *   $O  0$：顺时针（右转）。\n    *   $O = 0$：共线。\n\n**2.2. 单调链算法的推导**\n\n单调链算法的核心思想是通过分别构建凸包的上下边界（链）来构造凸包。\n\n1.  **排序**：第一步是按字典序对唯一性点集 $P$ 进行排序。这将点从左到右排列，并通过从下到上的方式解决平局问题。设排序后的点为 $p_1, p_2, \\ldots, p_n$。点 $p_1$ 和 $p_n$ 是绝对的“最左”和“最右”点，它们必然在凸包上。\n\n2.  **凸包构造**：凸包是一个其顶点按逆时针排序的多边形。当我们按逆时针顺序遍历凸多边形的周界时，在每个顶点处所做的转弯都必须是“左转”。这是构造凸包的关键见解。\n\n3.  **下凸包和上凸包**：我们可以将凸包的逆时针路径分解为两部分：\n    *   **下凸包**，即沿着点集“底部”从 $p_1$ 到 $p_n$ 的路径。\n    *   **上凸包**，即沿着点集“顶部”从 $p_n$ 回到 $p_1$ 的路径。\n\n4.  **增量构造**：我们将使用基于栈的方法来构建每个凸包。我们遍历排序后的点，并维护一个当前形成凸路径的点列表（“链”）。在考虑新点时，我们检查添加它是否能保持凸性。\n    *   假设当前链是一个点列表，我们正在考虑添加一个新点 $p_i$。设链上的最后两个点是 $p_{last-1}$ 和 $p_{last}$。三元组 $(p_{last-1}, p_{last}, p_i)$ 必须形成一个左转，以保持整个多边形的逆时针凸性。\n    *   如果方向 $O(p_{last-1}, p_{last}, p_i)$ 是右转（$O  0$），这意味着点 $p_{last}$ 造成了一个凹陷，不能在凸包上。因此，我们必须从链中弹出 $p_{last}$ 并重复检查。\n    *   如果方向是共线（$O = 0$），则点 $p_{last}$ 是从 $p_{last-1}$ 到 $p_i$ 的线段上的一个“严格内部共线点”。问题规定必须排除此类点。因此，在这种情况下我们也要弹出 $p_{last}$。\n    *   因此，从链中弹出最后一个点的条件是 $O(p_{last-1}, p_{last}, p_i) \\leq 0$。我们继续弹出，直到此条件为假或链中少于两个点。然后，我们将新点 $p_i$ 添加到链中。\n\n5.  **构建上下凸包**：\n    *   要构建**下凸包**，我们从 $p_1$ 到 $p_n$ 遍历排序后的点，应用上述逻辑。这将生成从左到右排序的凸包下链。\n    *   要构建**上凸包**，我们可以应用完全相同的逻辑，但按相反顺序遍历点，即从 $p_n$ 到 $p_1$。这将生成从右到左排序的上链。\n\n6.  **合并凸包**：最终的凸包是下凸包和上凸包的串联。下凸包包含从 $p_1$ 到 $p_n$ 的顶点。上凸包包含从 $p_n$ 回到 $p_1$ 的顶点。为避免重复端点 $p_1$ 和 $p_n$，我们将下凸包（不包括其最后一个点 $p_n$）和上凸包（不包括其最后一个点 $p_1$）串联起来。\n\n**2.3. 伪代码**\n\n`函数 MonotoneChain(Points):`\n    `// 输入：一个二维点列表 P。`\n    `// 输出：构成凸包的点列表，按逆时针排序。`\n\n    `// 步骤 0：预处理和边界情况`\n    `1. unique_points = 从 Points 中移除重复点。`\n    `2. n = unique_points 的数量。`\n    `3. 如果 n  3:`\n    `4.   按字典序对 unique_points 排序。`\n    `5.   返回 unique_points。`\n    `6. 按字典序对 unique_points 排序。设它们为 p_1, p_2, ..., p_n。`\n\n    `// 用于方向判断的辅助函数`\n    `函数 orientation(p1, p2, p3):`\n    `  返回 (p2.x - p1.x)*(p3.y - p1.y) - (p2.y - p1.y)*(p3.x - p1.x)`\n\n    `// 步骤 1：构建下凸包`\n    `7. lower_hull = []`\n    `8. 对于 p_1, ..., p_n 中的每个点 p_i:`\n    `9.   当 lower_hull 的长度 >= 2 且 orientation(lower_hull[-2], lower_hull[-1], p_i) = 0 时:`\n    `10.    从 lower_hull 弹出最后一个点。`\n    `11.  将 p_i 推入 lower_hull。`\n\n    `// 步骤 2：构建上凸包`\n    `12. upper_hull = []`\n    `13. 对于 p_n, ..., p_1 中的每个点 p_i (逆序):`\n    `14.  当 upper_hull 的长度 >= 2 且 orientation(upper_hull[-2], upper_hull[-1], p_i) = 0 时:`\n    `15.    从 upper_hull 弹出最后一个点。`\n    `16.  将 p_i 推入 upper_hull。`\n\n    `// 步骤 3：合并凸包`\n    `17. // 移除每个凸包的最后一个点，因为它们与`\n    `    // 另一个凸包的第一个点相同。`\n    `18. hull = lower_hull[:-1] + upper_hull[:-1]`\n    `19. 返回 hull`", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the convex hull for a predefined suite of test cases\n    and prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (general case with interior points)\n        [(0,0), (2,0), (2,2), (0,2), (1,1)],\n        # Test case 2 (empty set)\n        [],\n        # Test case 3 (single point)\n        [(5,5)],\n        # Test case 4 (collinear points with duplicates)\n        [(0,0), (1,1), (2,2), (3,3), (1,1), (2,2)],\n        # Test case 5 (all points on the boundary with boundary collinear points included)\n        [(0,0), (3,0), (3,3), (0,3), (1,0), (2,0), (3,1), (3,2), (2,3), (1,3), (0,2), (0,1)],\n        # Test case 6 (two identical points)\n        [(7,7), (7,7)],\n        # Test case 7 (diamond with interior points and negative coordinates)\n        [(-2,0), (0,2), (2,0), (0,-2), (-1,0), (0,1), (1,0), (0,-1)]\n    ]\n\n    results = []\n    for case in test_cases:\n        hull = compute_convex_hull(case)\n        results.append(hull)\n\n    # Convert results to the required string representation for the final output.\n    # The format is a list of lists, e.g., [[[x1,y1],[x2,y2]], [[u1,v1]], ...].\n    # Using np.array(pt).tolist() ensures points are lists, not tuples.\n    # The outer list comprehension handles conversion of each hull.\n    # repr() is used to get the string representation of the list of lists.\n    # However, repr() adds spaces, so we build the string manually.\n    \n    result_strings = []\n    for hull in results:\n        point_strings = [f\"[{p[0]},{p[1]}]\" for p in hull]\n        result_strings.append(f\"[{','.join(point_strings)}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\n\ndef compute_convex_hull(points):\n    \"\"\"\n    Computes the convex hull of a set of 2D points using the Monotone Chain algorithm.\n\n    Args:\n        points: A list of (x, y) tuples representing the points.\n\n    Returns:\n        A list of [x, y] lists representing the vertices of the convex hull,\n        ordered counter-clockwise starting from the lexicographically smallest point.\n    \"\"\"\n    # Step 0: Preprocessing and edge cases\n    # Use a set of tuples to efficiently remove duplicate points.\n    unique_points = sorted(list(set(points)))\n    n = len(unique_points)\n    \n    # If there are fewer than 3 points, they form the \"hull\" themselves.\n    # The problem specifies returning points for n  2, but the logic extends\n    # correctly to n  3 as no polygon can be formed.\n    if n  3:\n        # Convert tuples to lists as per output format\n        return [list(p) for p in unique_points]\n\n    # Helper function for orientation based on 2D cross product.\n    # O > 0: counter-clockwise (left turn)\n    # O  0: clockwise (right turn)\n    # O = 0: collinear\n    def orientation(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\n    # Step 1: Build the lower hull\n    lower_hull = []\n    for p in unique_points:\n        # Pop from the hull if the new point creates a right turn or is collinear.\n        # This maintains a strictly counter-clockwise (left-turning) chain.\n        while len(lower_hull) >= 2 and orientation(lower_hull[-2], lower_hull[-1], p) = 0:\n            lower_hull.pop()\n        lower_hull.append(p)\n\n    # Step 2: Build the upper hull\n    upper_hull = []\n    for p in reversed(unique_points):\n        # The logic is identical for the upper hull, iterating in reverse.\n        while len(upper_hull) >= 2 and orientation(upper_hull[-2], upper_hull[-1], p) = 0:\n            upper_hull.pop()\n        upper_hull.append(p)\n\n    # Step 3: Combine hulls\n    # The final hull is the lower hull followed by the upper hull.\n    # The first and last points of each hull are the same (the lexicographically\n    # smallest and largest points), so we exclude them from the concatenation\n    # to avoid duplicates.\n    full_hull_tuples = lower_hull[:-1] + upper_hull[:-1]\n    \n    # Convert tuples to lists for the final output format.\n    return [list(p) for p in full_hull_tuples]\n\nsolve()\n```", "id": "3205841"}, {"introduction": "单调链算法通过坐标排序，而经典的葛立恒扫描法（Graham Scan）则依赖于围绕一个枢纽点对点集进行极角排序。如果使用三角函数，这个看似简单的步骤会充满数值精度问题的陷阱。本练习 [@problem_id:3224274] 挑战你仅使用整数算术和叉积来稳健地实现角度排序，这将让你对支撑许多计算几何算法的底层几何谓词有更深刻的理解。", "problem": "给定二维平面中的有限点集，每个点集由整数坐标对表示。目标是为每个点集实现 Graham Scan 凸包算法中使用的角度排序步骤，并遵循严格的约束条件：不使用任何三角函数，不使用任何浮点数除法，仅依靠整数算术和叉积来比较角度。排序必须是相对于一个从点集中确定性选择的基准点来定义。最终程序必须生成单行输出，该输出编码了所有给定测试用例的排序顺序。\n\n使用的基本定义：\n- 一个点是由一对整数 $(x, y)$ 表示的平面上的位置。\n- 给定点 $\\mathbf{a} = (x_a, y_a)$ 和 $\\mathbf{b} = (x_b, y_b)$，以及基准点 $\\mathbf{p} = (x_p, y_p)$，定义平移后的向量 $\\mathbf{u} = \\mathbf{a} - \\mathbf{p} = (x_a - x_p, y_a - y_p)$ 和 $\\mathbf{v} = \\mathbf{b} - \\mathbf{p} = (x_b - x_p, y_b - y_p)$。\n- 叉积（由 $\\mathbf{u}$ 和 $\\mathbf{v}$ 构成的平行四边形的有向面积）由 $\\mathbf{u} \\times \\mathbf{v} = (x_a - x_p)(y_b - y_p) - (y_a - y_p)(x_b - x_p)$ 给出，当坐标为整数时，其结果为整数。\n- 从 $\\mathbf{p}$ 到 $\\mathbf{a}$ 的欧几里得距离的平方为 $d^2(\\mathbf{p}, \\mathbf{a}) = (x_a - x_p)^2 + (y_a - y_p)^2$，当坐标为整数时，其结果为整数。\n\n要求的角度排序行为：\n- 选择 $y$ 坐标最小的点作为基准点 $\\mathbf{p}$；如果 $y$ 坐标相同，则选择其中 $x$ 坐标最小的点。\n- 将基准点从排序中排除。\n- 将所有其余点按其围绕 $\\mathbf{p}$ 的极角，从正 $x$ 轴开始以逆时针顺序排序。对于两点 $\\mathbf{a}$ 和 $\\mathbf{b}$，此排序必须完全使用整数比较以及它们相对于 $\\mathbf{p}$ 的平移向量 $\\mathbf{u}$ 和 $\\mathbf{v}$ 的叉积 $\\mathbf{u} \\times \\mathbf{v}$ 来确定。您必须仅使用以下方法来确定哪个向量的角度更小：\n  - 相对于正 $x$ 轴的半平面分类：如果 $y_w  0$ 或者 $y_w = 0$ 且 $x_w \\ge 0$，则向量 $\\mathbf{w} = (x_w, y_w)$ 位于上半平面，否则位于下半平面。\n  - 叉积 $\\mathbf{u} \\times \\mathbf{v}$ 的符号。如果两个向量位于同一半平面且 $\\mathbf{u} \\times \\mathbf{v}  0$，则 $\\mathbf{u}$ 的角度小于 $\\mathbf{v}$；如果 $\\mathbf{u} \\times \\mathbf{v}  0$，则 $\\mathbf{v}$ 的角度小于 $\\mathbf{u}$。\n- 如果相对于 $\\mathbf{p}$ 共线，即 $\\mathbf{u} \\times \\mathbf{v} = 0$，则按欧几里得距离的平方 $d^2(\\mathbf{p}, \\cdot)$ 的递增顺序来打破平局，将较近的点排在前面。\n\n索引和输出：\n- 在每个输入集中，按给定顺序为点建立从 $0$ 到 $n-1$ 的索引。\n- 对于每个测试用例，输出按上述规则排序后的点的索引列表，不包括基准点的索引。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身也是一个用方括号括起来的逗号分隔列表。例如，最终输出格式必须类似于 $[[i_{0,0},i_{0,1},\\dots],[i_{1,0},i_{1,1},\\dots],\\dots]$，不含空格。\n\n测试套件：\n- 测试用例 $1$：点 $[(0,0),(2,1),(1,2),(-1,1),(-2,0),(-1,-1),(1,-2),(2,-1),(0,2),(0,-2)]$。\n- 测试用例 $2$：点 $[(-3,0),(-1,0),(0,0),(2,0),(5,0)]$。\n- 测试用例 $3$：点 $[(1,1),(2,2),(2,2),(3,3),(0,0)]$。\n- 测试用例 $4$：点 $[(4,0),(0,4),(-4,0),(0,-4),(1,-3),(2,-2),(-2,-2),(-1,-3),(3,3),(-3,3)]$。\n\n答案规范：\n- 对每个测试用例，生成一个整数列表，对应于根据其基准点按要求的角度顺序排序的索引。\n- 最终答案必须是一个程序，该程序打印上述单行文本，并且只执行整数计算，不使用任何三角函数或浮点数除法。", "solution": "用户提供的问题是计算几何中一个定义明确的任务，具体与用于寻找凸包的 Graham Scan 算法的排序阶段有关。该问题在算法上是合理的、自洽的，并为获得唯一解提供了所有必要的定义和约束。核心挑战是仅使用整数算术，根据一个基准点按极角对一组点进行排序。这通过利用叉积和欧几里得距离平方的几何特性来完成，从而避免了使用三角函数和浮点计算。\n\n对于每个给定的测试用例，解决方案按以下逻辑步骤进行：\n\n**1. 基准点识别**\n\n首先，必须从输入点集中确定性地选择一个基准点 $\\mathbf{p}$。问题指定了一个明确的规则：基准点是具有最小 $y$ 坐标的点。如果出现平局，则选择其中具有最小 $x$ 坐标的点。如果一个点集表示为 $S = \\{\\mathbf{p}_0, \\mathbf{p}_1, \\dots, \\mathbf{p}_{n-1}\\}$，其中每个 $\\mathbf{p}_i = (x_i, y_i)$，那么基准点 $\\mathbf{p} = (x_p, y_p)$ 是这样一个点，对于 $S$ 中的任何其他点 $\\mathbf{p}_j = (x_j, y_j)$，要么 $y_p  y_j$，要么（$y_p = y_j$ 且 $x_p  x_j$）。这保证了任何非空点集都有一个唯一的基准点。基准点本身不参与排序过程。\n\n**2. 用于排序的比较函数**\n\n基本任务是根据剩余点相对于基准点 $\\mathbf{p}$ 的极角，建立一个全序关系。这需要一个比较函数，对于任意两点 $\\mathbf{a}$ 和 $\\mathbf{b}$，该函数能够确定从 $\\mathbf{p}$ 点发出且平行于正 $x$ 轴的射线开始，按逆时针方向，哪个点的极角更小。此比较完全使用整数算术实现。\n\n设要比较的两点为 $\\mathbf{a} = (x_a, y_a)$ 和 $\\mathbf{b} = (x_b, y_b)$，基准点为 $\\mathbf{p} = (x_p, y_p)$。我们定义它们对应的平移向量为 $\\mathbf{u} = \\mathbf{a} - \\mathbf{p} = (x_a - x_p, y_a - y_p) = (u_x, u_y)$ 和 $\\mathbf{v} = \\mathbf{b} - \\mathbf{p} = (x_b - x_p, y_b - y_p) = (v_x, v_y)$。比较逻辑如下：\n\n**2.1. 半平面分类**\n相对于基准点 $\\mathbf{p}$，平面被划分为两个半平面，以处理跨越 $\\pi$ 弧度（或 $180^\\circ$）的角度。“上半”平面包含角度在 $[0, \\pi)$ 范围内的向量，“下半”平面包含角度在 $[\\pi, 2\\pi)$ 范围内的向量。\n如果 $w_y  0$，或者 $w_y = 0$ 且 $w_x  0$，则向量 $\\mathbf{w} = (w_x, w_y)$ 位于上半平面。虽然规定了 $w_x \\ge 0$ 的条件，但由于基准点被排除在排序之外，平移后的向量 $\\mathbf{w}$ 不可能是零向量 $(0,0)$，因此当 $w_y=0$ 时，$w_x$ 必定非零。\n- 如果向量 $\\mathbf{u}$ 在上半平面而 $\\mathbf{v}$ 在下半平面，则 $\\mathbf{u}$ 的极角更小。\n- 如果向量 $\\mathbf{v}$ 在上半平面而 $\\mathbf{u}$ 在下半平面，则 $\\mathbf{v}$ 的极角更小。\n\n**2.2. 用于角度比较的叉积**\n如果向量 $\\mathbf{u}$ 和 $\\mathbf{v}$ 均位于同一半平面，它们的相对角度顺序由其二维叉积的符号决定。叉积定义为 $\\mathbf{u} \\times \\mathbf{v} = u_x v_y - u_y v_x$。\n- 如果 $\\mathbf{u} \\times \\mathbf{v}  0$，从 $\\mathbf{u}$ 到 $\\mathbf{v}$ 的转向是逆时针的，这意味着 $\\mathbf{u}$ 的角度小于 $\\mathbf{v}$ 的角度。\n- 如果 $\\mathbf{u} \\times \\mathbf{v}  0$，转向是顺时针的，这意味着 $\\mathbf{v}$ 的角度小于 $\\mathbf{u}$ 的角度。\n\n**2.3. 共线点的平局处理**\n如果叉积 $\\mathbf{u} \\times \\mathbf{v} = 0$，则点 $\\mathbf{a}$ 和 $\\mathbf{b}$ 与基准点 $\\mathbf{p}$ 共线。平局通过根据它们与基准点的距离进行排序来打破。为避免使用平方根和浮点数，我们比较它们的欧几里得距离的平方。\n从 $\\mathbf{p}$ 到 $\\mathbf{a}$ 的距离平方为 $d^2(\\mathbf{p}, \\mathbf{a}) = u_x^2 + u_y^2$。\n- 如果 $d^2(\\mathbf{p}, \\mathbf{a})  d^2(\\mathbf{p}, \\mathbf{b})$，点 $\\mathbf{a}$ 更近，因此在排序顺序中排在前面。\n- 如果 $d^2(\\mathbf{p}, \\mathbf{a})  d^2(\\mathbf{p}, \\mathbf{b})$，点 $\\mathbf{b}$ 更近，排在前面。\n如果距离平方也相等（并且点是共线的），则这些点是相同的。它们的相对顺序将根据排序算法的稳定性来保持。\n\n**3. 算法实现**\n\n每个测试用例的总体算法是：\n1.  用从 $0$ 到 $n-1$ 的原始索引枚举输入点。\n2.  找到基准点 $\\mathbf{p}$ 及其索引。\n3.  创建一个包含所有其他点的列表，每个点都存储为一个元组，包含点的坐标及其原始索引。\n4.  使用标准排序算法对此列表进行排序。排序键必须是一个自定义比较函数，该函数严格实现步骤 2 中描述的逻辑。在 Python 中，这可以方便地使用 `functools.cmp_to_key` 来完成。\n5.  排序后，从已排序的点列表中提取原始索引。\n6.  收集每个测试用例的结果索引列表，并将其格式化为指定的单行字符串输出。\n\n此过程根据指定规则生成一个正确排序的点索引列表，满足问题陈述的所有要求。", "answer": "```python\nimport sys\nfrom functools import cmp_to_key\n\ndef solve():\n    \"\"\"\n    Solves the angle-sorting problem for the given test cases using only\n    integer arithmetic as specified.\n    \"\"\"\n    test_cases = [\n        [(0,0),(2,1),(1,2),(-1,1),(-2,0),(-1,-1),(1,-2),(2,-1),(0,2),(0,-2)],\n        [(-3,0),(-1,0),(0,0),(2,0),(5,0)],\n        [(1,1),(2,2),(2,2),(3,3),(0,0)],\n        [(4,0),(0,4),(-4,0),(0,-4),(1,-3),(2,-2),(-2,-2),(-1,-3),(3,3),(-3,3)],\n    ]\n\n    all_results = []\n\n    for points in test_cases:\n        # 1. Find the pivot point (min y, then min x).\n        min_y = sys.maxsize\n        min_x_at_min_y = sys.maxsize\n        pivot_idx = -1\n        \n        for i, (x, y) in enumerate(points):\n            if y  min_y:\n                min_y = y\n                min_x_at_min_y = x\n                pivot_idx = i\n            elif y == min_y:\n                if x  min_x_at_min_y:\n                    min_x_at_min_y = x\n                    pivot_idx = i\n        \n        pivot_point = points[pivot_idx]\n\n        # 2. Collect points to be sorted (all except the pivot)\n        # along with their original indices.\n        points_to_sort = []\n        for i, p in enumerate(points):\n            if i != pivot_idx:\n                points_to_sort.append((p, i))\n\n        # 3. Define the comparison function based on the problem rules.\n        def compare_points(item1, item2):\n            \"\"\"\n            Compares two points based on their polar angle relative to the pivot.\n            Returns -1 if item1  item2, 1 if item1 > item2, 0 if equal.\n            \"\"\"\n            p1 = item1[0]\n            p2 = item2[0]\n\n            # Translate points to vectors relative to the pivot\n            u_x, u_y = p1[0] - pivot_point[0], p1[1] - pivot_point[1]\n            v_x, v_y = p2[0] - pivot_point[0], p2[1] - pivot_point[1]\n\n            # Half-plane classification\n            is_upper_u = (u_y > 0) or (u_y == 0 and u_x > 0)\n            is_upper_v = (v_y > 0) or (v_y == 0 and v_x > 0)\n\n            if is_upper_u != is_upper_v:\n                return -1 if is_upper_u else 1\n\n            # Both in the same half-plane, use cross product\n            cross_product = u_x * v_y - u_y * v_x\n            if cross_product != 0:\n                return -1 if cross_product > 0 else 1\n\n            # Collinear, use squared Euclidean distance for tie-breaking\n            dist_sq_u = u_x**2 + u_y**2\n            dist_sq_v = v_x**2 + v_y**2\n            \n            if dist_sq_u  dist_sq_v:\n                return -1\n            elif dist_sq_u > dist_sq_v:\n                return 1\n            \n            return 0\n\n\n        # 4. Sort the points using the custom comparator.\n        points_to_sort.sort(key=cmp_to_key(compare_points))\n\n        # 5. Extract the original indices of the sorted points.\n        sorted_indices = [item[1] for item in points_to_sort]\n        all_results.append(sorted_indices)\n\n    # 6. Format the final output string.\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, r))}]' for r in all_results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3224274"}, {"introduction": "掌握了通用点集的算法后，我们现在转向一个更具结构性的特殊情况：求解一个简单多边形的凸包。当输入点已经构成一个无自交的边界时，$O(n \\log n)$ 的排序步骤便不再是必需的。这项进阶练习 [@problem_id:3224335] 将展示如何调整葛立恒扫描法的核心思想，以实现在线性时间 $O(n)$ 内求解的卓越算法，凸显了利用输入结构特性对算法性能进行优化的威力。", "problem": "给定二维欧几里得空间中一个简单多边形的顶点序列。一个简单多边形定义为由 $n$ 个不同点 $(x_i,y_i)$（$i \\in \\{0,1,\\dots,n-1\\}$）按顺序通过直线段连接而成的闭合链，其中只有相邻的线段相交，且链不自相交。一个有限点集的凸包定义为包含所有这些点的最小凸集；等价地，它是这些点的所有凸组合的集合。\n\n从一个基础概念出发：三点的方向可以通过二维叉积的符号来确定，对于点 $o=(x_o,y_o)$、$a=(x_a,y_a)$ 和 $b=(x_b,y_b)$，其有向面积（带符号的叉积）为\n$$\n\\text{cross}(o,a,b) = (x_a - x_o)(y_b - y_o) - (y_a - y_o)(x_b - x_o),\n$$\n以及一个基本事实：凸多边形的特征是所有连续边的方向都以相同方式转动（对于逆时针遍历，每次转动都是左转）。基于这些，推导并实现 Graham Scan 算法的一种改编版本，该版本利用给定的多边形顶点顺序，在 $O(n)$ 时间内计算凸包，而无需任何排序。您的改编必须有原则性：它必须维护一个显式的凸包顶点堆栈（或双端队列），并应用方向测试来强制执行凸性不变量，移除那些会产生右转或导致在当前凸包内部形成直线的顶点。该算法必须能处理逆时针和顺时针两种输入顺序，并且必须一致地处理共线情况，即凸包边上的内部共线顶点应被排除，而极端的共线顶点应被保留。\n\n您的程序必须：\n- 不接受任何输入，并对下面提供的固定内部测试套件进行操作。\n- 对每个测试用例，使用上述原则在 $O(n)$ 时间内计算给定简单多边形的凸包。\n- 以逆时针顺序返回凸包顶点，从字典序最小的顶点（先按 $x$ 排序，再按 $y$ 排序）开始。如果计算出的凸包是顺时针的，则将其反转为逆时针。\n- 排除凸包边上的内部共线点，但包括极端的端点。\n\n未使用角度单位，因此不需要。不涉及物理单位。测试套件如下，每个多边形以整数坐标 $(x,y)$ 的有序列表形式给出：\n- 测试用例 1（凸正方形，逆时针）：$[(0,0),(3,0),(3,3),(0,3)]$。\n- 测试用例 2（带内凹的凹五边形，逆时针）：$[(0,0),(4,0),(4,4),(2,1),(0,4)]$。\n- 测试用例 3（一条边上有三个共线顶点的凸五边形，逆时针）：$[(0,0),(2,0),(4,0),(4,3),(0,3)]$。\n- 测试用例 4（三角形，顺时针）：$[(1,1),(3,4),(5,1)]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。每个结果是对应测试用例的凸包，表示为一个没有空格的坐标对列表，按逆时针顺序，从字典序最小的顶点开始。例如，输出格式为\n$[result_1,result_2,result_3,result_4]$，\n其中每个 $result_i$ 是一个类似 $[[x_0,y_0],[x_1,y_1],\\dots]$ 的列表。", "solution": "我们从计算几何的核心定义和事实出发。平面上有限点集的凸包是包含所有这些点的唯一最小凸多边形。当只有连续的边相交且没有自相交时，多边形链是简单的。三点的方向由叉积的符号确定\n$$\n\\text{cross}(o,a,b) = (x_a - x_o)(y_b - y_o) - (y_a - y_o)(x_b - x_o),\n$$\n当结果 $0$ 时为左转，$ 0$ 时为右转，$=0$ 时为共线。这个方向测试是实现增量式凸包维护的基本局部谓词：如果我们维护一个有序的顶点序列，并确保每一步都产生一个左转，我们就能在逆时针遍历中保持凸性。\n\n经典的 Graham Scan 算法首先围绕一个锚点按极角对点进行排序，然后用一个堆栈进行扫描，弹出那些会产生右转的点。排序是其主要的时间开销，复杂度为 $O(n \\log n)$。然而，如果输入是沿其边界（顺时针或逆时针）按顶点顺序给出的简单多边形，我们就可以利用这个已有的顺序来避免排序。一个经过充分检验的原则是，可以通过维护一个候选凸包顶点的双端队列，并对当前的极值边应用方向测试，在线性时间内计算出简单多边形链的凸包。这是对 Graham Scan 堆栈规则的一种改编，以适应已排序的序列：我们不再按角度排序，而是相信边界顺序，仅通过剔除那些不能维持凸包支撑线的顶点来强制实现凸性。这样可以在 $O(n)$ 时间内完成，因为每个顶点被插入一次，且最多可能被移除常数次。\n\n算法设计：\n- 设输入多边形为有序列表 $p_0, p_1, \\dots, p_{n-1}$，索引以 $n$ 为模。我们首先确保从一个不共线的三元组开始，以初始化双端队列的不变量。如果初始三个点共线，我们旋转起始索引，直到找到三个连续顶点 $p_t, p_{t+1}, p_{t+2}$ 使得 $\\text{cross}(p_t, p_{t+1}, p_{t+2}) \\neq 0$。这种旋转保留了多边形的邻接性，最坏情况下成本为 $O(n)$，但它是线性的且只执行一次。\n- 用这三个点初始化一个双端队列（deque），其顺序使当前凸包为逆时针：如果 $\\text{cross}(p_t,p_{t+1},p_{t+2})  0$，则推入 $[p_{t+2}, p_t, p_{t+1}, p_{t+2}]$，使得两端都重复最后一个点；如果方向为负，则在此初始化中交换 $p_t$ 和 $p_{t+1}$ 以保持不变量的一致性。这确保了双端队列的第一条和最后一条有向边是当前的支撑线。\n- 对于旋转后序列中的每个后续顶点 $p_i$：\n  1. 如果 $p_i$ 严格位于双端队列 $D$ 的第一条边 $(D[0] \\to D[1])$ 和最后一条边 $(D[m-2] \\to D[m-1])$ 的左侧，那么 $p_i$ 位于当前凸包内部，我们可以跳过它而不改变 $D$。形式上，如果 $\\text{cross}(D[0],D[1],p_i)  0$ 且 $\\text{cross}(D[m-2],D[m-1],p_i)  0$，我们就继续。在存在共线性的情况下，边上的点（叉积为零）不应被视为严格在左侧；因此，只有当它扩展凸包时才会触发更新。\n  2. 否则，我们必须扩展凸包以包含 $p_i$。当 $p_i$ 不在最后一条边的严格左侧时（即，当 $\\text{cross}(D[m-2],D[m-1],p_i) \\le 0$ 时），我们从右侧弹出元素，然后将 $p_i$ 附加到右侧。类似地，当 $p_i$ 不在第一条边的严格左侧时（即，当 $\\text{cross}(D[0],D[1],p_i) \\le 0$ 时），我们从左侧弹出元素，然后将 $p_i$ 前插到左侧。这些调整恢复了凸性不变量：双端队列边界上的所有转弯都变成左转，并且内部的共线点因不满足严格左转测试而被弹出移除。\n- 扫描结束时，双端队列中保存着凸包的顶点，为了不变量的对称性，两端都有一个重复的端点。我们移除重复项，得到按边界顺序排列的凸包。\n- 为了规范化输出，我们计算凸包序列的带符号面积，\n$$\nA = \\frac{1}{2}\\sum_{i=0}^{k-1} (x_i y_{i+1} - x_{i+1} y_i),\n$$\n其中索引以 $k$ 为模。如果 $A  0$，则顶点是顺时针排列的；我们将其反转以获得逆时针顺序。最后，我们旋转序列，使其从字典序最小的顶点 $(x,y)$ 开始，以提供确定性的输出。\n\n正确性源于两个事实：(i) 双端队列不变量强制所维护的多边形是凸的，因为所有局部转弯都是左转，且边界是简单的；(ii) 每当一个新点位于当前凸包之外时，我们通过弹出操作调整支撑边，直到新的凸包以严格左转的方式包含该点。任何位于当前凸包内部的点都不应被添加，因为它不可能是最终凸包的极点。共线性通过严格不等式来处理：边内部的点（叉积为零）不被视为严格在左侧，它们将被移除或跳过，除非它们扩展了凸包，在这种情况下，弹出操作会移除内部点并保留极端的端点。\n\n复杂度分析：每个点只被考虑一次。在最坏的情况下，它可能导致从双端队列的任一端弹出元素；然而，每个点在被推入后最多只能被弹出一次，因此双端队列操作的总数是 $n$ 的线性函数。初始化和规范化也是线性的。因此，总时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。\n\n将此算法应用于测试套件：\n- 测试用例 1 是一个凸正方形；其凸包等于输入的多边形，按逆时针排序，从 $(0,0)$ 开始。\n- 测试用例 2 是一个凹五边形；凹顶点 $(2,1)$ 位于最终凸包的内部，最终凸包是角点为 $(0,0)$、$(4,0)$、$(4,4)$、$(0,4)$ 的矩形。\n- 测试用例 3 在底边包含三个共线顶点；算法排除了内部的共线点 $(2,0)$，只保留了该边上的极端端点 $(0,0)$ 和 $(4,0)$，以及顶边的端点 $(4,3)$ 和 $(0,3)$。\n- 测试用例 4 是一个按顺时针顺序给出的三角形；算法返回相同的三角形，但会反转为逆时针顺序，并规范化为从字典序最小的顶点开始。\n\n最终的程序实现了这种改编方法，为所有测试多边形生成凸包，并打印单行输出，其中包含凸包列表，每个凸包表示为一个没有空格的坐标对列表，按逆时针顺序，从字典序最小的顶点开始。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef cross(o, a, b):\n    # 2D cross product (signed area * 2)\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\ndef polygon_area2(poly):\n    # Returns twice the signed area\n    s = 0\n    n = len(poly)\n    for i in range(n):\n        x1, y1 = poly[i]\n        x2, y2 = poly[(i + 1) % n]\n        s += x1 * y2 - x2 * y1\n    return s\n\ndef rotate_to_noncollinear(points):\n    n = len(points)\n    if n  3:\n        return points[:]\n    for t in range(n):\n        o = points[t]\n        a = points[(t + 1) % n]\n        b = points[(t + 2) % n]\n        if cross(o, a, b) != 0:\n            # rotate list to start at t\n            return points[t:] + points[:t]\n    # Degenerate: all collinear; return as-is\n    return points[:]\n\ndef melkman_simple_polygon(points):\n    # Adaptation of Graham scan for ordered simple polygon using Melkman deque method.\n    n = len(points)\n    if n == 0:\n        return []\n    if n == 1:\n        return [points[0]]\n    if n == 2:\n        # Hull is the two points; canonicalization later will handle orientation\n        return [points[0], points[1]]\n\n    pts = rotate_to_noncollinear(points)\n    n = len(pts)\n\n    # Find first noncollinear triple for robust init\n    # After rotate_to_noncollinear, the first triple is noncollinear\n    p0, p1, p2 = pts[0], pts[1], pts[2]\n    D = deque()\n    if cross(p0, p1, p2) > 0:\n        # Counterclockwise\n        D.append(p2)\n        D.append(p0)\n        D.append(p1)\n        D.append(p2)\n    else:\n        # Clockwise\n        D.append(p2)\n        D.append(p1)\n        D.append(p0)\n        D.append(p2)\n\n    for i in range(3, n):\n        pi = pts[i]\n        # If inside (strictly left of both ends), skip\n        if cross(D[0], D[1], pi) > 0 and cross(D[-2], D[-1], pi) > 0:\n            continue\n        # Fix right end\n        while cross(D[-2], D[-1], pi) = 0:\n            D.pop()\n        D.append(pi)\n        # Fix left end\n        while cross(D[0], D[1], pi) = 0:\n            D.popleft()\n        D.appendleft(pi)\n\n    # Remove duplicated last point\n    hull = list(D)[:-1]\n    # Canonicalize to CCW and lexicographically smallest start\n    if len(hull) >= 3:\n        area2 = polygon_area2(hull)\n        if area2  0:\n            hull.reverse()\n    # Rotate to lexicographically smallest vertex\n    if hull:\n        min_idx = min(range(len(hull)), key=lambda i: (hull[i][0], hull[i][1]))\n        hull = hull[min_idx:] + hull[:min_idx]\n    return hull\n\ndef serialize_no_spaces(obj):\n    # Serialize nested lists/tuples of numbers into a compact string without spaces\n    if isinstance(obj, (list, tuple)):\n        return '[' + ','.join(serialize_no_spaces(x) for x in obj) + ']'\n    else:\n        return str(obj)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: convex square, counterclockwise\n        [(0,0),(3,0),(3,3),(0,3)],\n        # Test case 2: concave pentagon with a dent, counterclockwise\n        [(0,0),(4,0),(4,4),(2,1),(0,4)],\n        # Test case 3: convex pentagon with three collinear points along one edge, counterclockwise\n        [(0,0),(2,0),(4,0),(4,3),(0,3)],\n        # Test case 4: triangle, clockwise\n        [(1,1),(3,4),(5,1)],\n    ]\n\n    results = []\n    for pts in test_cases:\n        hull = melkman_simple_polygon(pts)\n        # Ensure integer coordinates in output\n        hull_out = [[int(x), int(y)] for (x, y) in hull]\n        results.append(hull_out)\n\n    # Final print statement in the exact required format (no spaces).\n    print(serialize_no_spaces(results))\n\nsolve()\n```", "id": "3224335"}]}