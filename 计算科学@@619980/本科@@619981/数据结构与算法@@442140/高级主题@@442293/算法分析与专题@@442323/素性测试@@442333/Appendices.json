{"hands_on_practices": [{"introduction": "理论知识是基础，但亲手实践才能带来深刻的理解。本练习将指导您逐步完成一次米勒-拉宾（Miller-Rabin）测试的完整计算 [@problem_id:3088381]。通过处理一个著名的“费马伪素数”，您将具体地看到该测试是如何通过寻找模 $n$ 下 $1$ 的非平凡平方根来识别合数的。这项动手计算对于揭开算法的神秘面纱、理解其背后精妙的数论原理至关重要。", "problem": "考虑奇合数 $n=341$ 和底数 $a=2$。米勒-拉宾强伪素数测试的步骤是：首先将 $n-1$ 写成 $2^{r}d$ 的形式，其中 $d$ 是奇数；然后计算模幂 $x_{0}\\equiv a^{d} \\pmod{n}$；接着构建平方链 $x_{j+1}\\equiv x_{j}^{2}\\pmod{n}$，其中 $j=0,1,\\dots,r-1$。在此框架中，当某个 $j\\geq 1$ 满足 $x_{j}\\equiv 1 \\pmod{n}$ 而 $x_{j-1}\\not\\equiv \\pm 1 \\pmod{n}$ 时，就出现了一个见证其合数的步骤，这揭示了一个模 $n$ 的非平凡平方根。使用模算术、幂运算和 $n-1$ 分解的定义，对给定的 $n$ 和 $a$ 执行一次完整的米勒-拉宾迭代：确定 $r$ 和 $d$，计算 $x_{0}$ 以及随后的 $x_{j}$ 值直到 $j=r$，找出最早见证其合数的步骤，然后利用最大公约数（GCD）从该步骤中提取 $n$ 的一个非平凡因子。\n\n请给出与第一个见证步骤相关的 $\\gcd(x_{j-1}-1, n)$ 的精确整数值作为你的最终答案。不要四舍五入，以精确整数形式表示你的答案。", "solution": "问题陈述是米勒-拉宾素性测试的一个有效应用，该测试是数论中一个明确定义的算法。所有必要的数据（$n=341$, $a=2$）和定义均已提供，问题本身是自洽的、客观的且科学上合理的。我们可以开始求解。\n\n目标是使用底数 $a=2$ 对整数 $n=341$ 执行一次米勒-拉宾测试迭代，找出见证其合数的步骤，并利用该信息找到一个非平凡因子。\n\n首先，我们必须将 $n-1$ 分解为 $2^r d$ 的形式，其中 $d$ 是一个奇数。\n给定 $n=341$，我们有 $n-1 = 340$。\n我们从 $340$ 中分解出 $2$ 的幂：\n$$340 = 10 \\times 34 = (2 \\times 5) \\times (2 \\times 17) = 4 \\times 85 = 2^2 \\times 85$$\n此处，$d=85$ 是奇数。因此，我们确定 $r=2$ 和 $d=85$。\n\n米勒-拉宾测试序列由 $x_0 \\equiv a^d \\pmod{n}$ 和 $x_{j+1} \\equiv x_j^2 \\pmod{n}$ 定义，其中 $j=0, 1, \\dots, r-1$。\n\n我们首先计算 $x_0$：\n$$x_0 \\equiv a^d \\pmod{n} \\equiv 2^{85} \\pmod{341}$$\n为了高效地计算这个模幂，我们使用二进制取幂法（也称为快速幂）。指数 $d=85$ 的二进制表示是 $1010101_2$，它对应于 $2$ 的幂次之和：$85 = 64 + 16 + 4 + 1$。\n我们计算所需的 $2$ 的幂模 $341$：\n\\begin{align*} 2^1 \\equiv 2 \\pmod{341} \\\\ 2^2 \\equiv 4 \\pmod{341} \\\\ 2^4 \\equiv 4^2 \\equiv 16 \\pmod{341} \\\\ 2^8 \\equiv 16^2 \\equiv 256 \\pmod{341} \\\\ 2^{16} \\equiv 256^2 = 65536 \\pmod{341} \\end{align*}\n为化简 $65536$，我们将其除以 $341$：$65536 = 192 \\times 341 + 4$。所以，$2^{16} \\equiv 4 \\pmod{341}$。\n\\begin{align*} 2^{32} \\equiv 4^2 \\equiv 16 \\pmod{341} \\\\ 2^{64} \\equiv 16^2 \\equiv 256 \\pmod{341} \\end{align*}\n现在，我们结合这些结果来计算 $2^{85}$：\n$$2^{85} = 2^{64} \\cdot 2^{16} \\cdot 2^4 \\cdot 2^1$$\n$$x_0 \\equiv 2^{85} \\equiv 256 \\cdot 4 \\cdot 16 \\cdot 2 \\pmod{341}$$\n我们一步一步地计算这个乘积：\n$$256 \\cdot 4 = 1024$$\n将 $1024$ 除以 $341$ 得到 $1024 = 3 \\times 341 + 1$，所以 $1024 \\equiv 1 \\pmod{341}$。\n将此结果代回 $x_0$ 的表达式中：\n$$x_0 \\equiv (1) \\cdot 16 \\cdot 2 \\equiv 32 \\pmod{341}$$\n因此，$x_0 = 32$。\n\n测试首先检查是否 $x_0 \\equiv \\pm 1 \\pmod{n}$。由于 $32 \\not\\equiv 1 \\pmod{341}$ 且 $32 \\not\\equiv -1 \\pmod{341}$（因为 $-1 \\equiv 340 \\pmod{341}$），测试进入下一步。\n\n接下来，我们计算序列 $x_j$，其中 $j=1, \\dots, r-1$。由于 $r=2$，我们只需要计算 $x_1$。\n$$x_1 \\equiv x_0^2 \\pmod{n} \\equiv 32^2 \\pmod{341}$$\n$$x_1 \\equiv 1024 \\pmod{341}$$\n如前所述，$1024 = 3 \\times 341 + 1$。因此：\n$$x_1 \\equiv 1 \\pmod{341}$$\n测试发现，当 $j=1$ 时，我们有 $x_1 \\equiv 1 \\pmod{341}$。见证合数的条件已满足，因为 $x_1 \\equiv 1 \\pmod{n}$，而序列中的前一项 $x_{1-1}=x_0=32$ 不与 $\\pm 1 \\pmod{n}$ 同余。这是第一个见证 $n$ 是合数的步骤。\n\n这样一个 $x_0$ 的存在意味着它是模 $n$ 的一个非平凡平方根。即，$x_0^2 \\equiv 1 \\pmod{n}$ 但 $x_0 \\not\\equiv \\pm 1 \\pmod{n}$。这可以改写为 $x_0^2 - 1 \\equiv 0 \\pmod{n}$，或 $(x_0 - 1)(x_0 + 1) \\equiv 0 \\pmod{n}$。\n这意味着 $n$ 整除乘积 $(x_0 - 1)(x_0 + 1)$。由于 $n$ 不能整除 $x_0-1$（因为 $x_0 \\not\\equiv 1 \\pmod n$）且 $n$ 不能整除 $x_0+1$（因为 $x_0 \\not\\equiv -1 \\pmod n$），所以 $n$ 必须与 $(x_0 - 1)$ 和 $(x_0 + 1)$ 都共享一个非平凡因子。\n\n问题要求使用最大公约数（GCD）从见证步骤中提取一个非平凡因子。具体来说，我们必须计算 $\\gcd(x_{j-1}-1, n)$，其中 $j=1$ 是第一个见证步骤。\n这需要计算 $\\gcd(x_0 - 1, n)$。\n代入我们找到的值：\n$$\\gcd(32 - 1, 341) = \\gcd(31, 341)$$\n为了计算这个GCD，我们可以使用欧几里得算法。由于 $31$ 是一个素数，我们可以简单地测试 $31$ 是否是 $341$ 的一个因子。\n$$341 \\div 31 = 11$$\n这个除法是整除的。因此，$31$ 是 $341$ 的一个因子，最大公约数是 $31$。\n$$\\gcd(31, 341) = 31$$\n这就是从米勒-拉宾测试中提取出的 $n=341$ 的非平凡因子。", "answer": "$$\\boxed{31}$$", "id": "3088381"}, {"introduction": "米勒-拉宾测试的强大之处，在与较弱测试的对比中体现得淋漓尽致。这个编程练习要求您找出那些能够通过简单的费马素性测试，却被米勒-拉宾测试准确识别为合数的数字 [@problem_id:3260318]。通过实现并对比这两种算法，您将清楚地看到费马测试的具体弱点，并理解为何我们需要米勒-拉宾测试所执行的更严格的检查。", "problem": "要求您设计并实现一个完整的、可运行的程序，用于合成满足以下条件的合数 $n$：该数能通过以 $a=2$ 为基的 Fermat 素性检验，但会被以相同基 $a=2$ 的 Miller–Rabin 检验（MR）检测为合数。目标是探究这类整数的结构，并论证为何在数据结构和算法中需要使用更强的检验方法。\n\n请从以下基本事实开始：\n\n1.  Fermat 小定理：对于一个素数 $p$ 和任意整数 $a$ 且 $\\gcd(a,p)=1$，有 $a^{p-1} \\equiv 1 \\pmod{p}$。这启发了针对奇数 $n2$ 的 Fermat 检验：对于一个与 $n$ 互素的选定基 $a$，如果 $a^{n-1} \\equiv 1 \\pmod{n}$，则宣布 $n$ 为“可能素数”。\n2.  Miller–Rabin 检验 (MR)：对于奇数 $n2$，将 $n-1$ 写作 $n-1 = 2^s d$，其中 $d$ 为奇数。对于一个与 $n$ 互素的选定基 $a$，计算 $x_0 \\equiv a^d \\pmod{n}$，然后重复平方，$x_{r+1} \\equiv x_r^2 \\pmod{n}$，其中 $r = 0,1,\\dots,s-2$。如果 $x_0 \\equiv 1 \\pmod{n}$ 或存在某个 $x_r \\equiv -1 \\pmod{n}$，MR 检验宣布 $n$ 为“可能素数”；否则，MR 检验宣布 $n$ 为合数。\n\n在此任务中，您必须：\n\n-   实现一个函数，检查一个奇数 $n2$ 是否满足 $2^{n-1} \\equiv 1 \\pmod{n}$（Fermat 基 $a=2$）。\n-   实现一个专门针对基 $a=2$ 和奇数 $n2$ 的 Miller–Rabin 检验，使用 $n-1=2^s d$ 的分解和上述序列。该函数返回一个布尔值，指示 MR 是否接受 $n$ 为“可能素数”（true）或检测到 $n$ 为合数（false）。\n-   合成既能通过 Fermat 基 $a=2$ 检验（true）又不能通过 MR 基 $a=2$ 检验（false）的整数 $n$。只考虑奇数 $n2$。\n-   通过检查 Carmichael 数的 Korselt 判别法来探究它们的结构：一个奇合数 $n$ 是一个 Carmichael 数，当且仅当 $n$ 是无平方因子的，并且对于 $n$ 的每一个素因子 $p$，都有 $(p-1) \\mid (n-1)$。实现一个函数，返回一个布尔值，指示给定的 $n$ 是否满足 Korselt 判别法。\n\n对于每个提供的测试用例，您的程序必须按升序搜索奇数 $n$ 直至给定的上限 $L$，收集最多指定数量 $K$ 个满足 $2^{n-1} \\equiv 1 \\pmod{n}$ 且无法通过以 $a=2$ 为基的 MR 检验的整数 $n$，然后为每个收集到的 $n$ 报告一个由整数 $n$ 和一个指示其是否满足 Korselt 判别法的布尔值组成的数对。如果在 $L$ 范围内存在的此类整数少于 $K$ 个，则报告所有找到的整数。如果在 $L$ 范围内不存在此类整数，则报告一个空列表。\n\n本问题不涉及物理单位或角度。所有输出均为纯数值和布尔值。\n\n测试套件和最终输出规范：\n\n-   使用包含三个用例的以下测试套件：\n    1.  用例 1：$L=5000$, $K=10$。\n    2.  用例 2：$L=300$, $K=5$。\n    3.  用例 3：$L=20000$, $K=7$。\n-   对于每个用例，生成一个数对列表 $[n,c]$，其中 $n$ 是合成的整数，$c$ 是指示 $n$ 是否满足 Korselt 判别法的布尔值。\n-   您的程序应生成单行输出，其中包含三个用例的结果，形式为由方括号括起来的逗号分隔列表。每个用例的结果本身也必须是其 $[n,c]$ 数对的、由方括号括起来的逗号分隔列表。例如，输出格式必须严格遵循以下形式\n    $$[ [n_1,c_1],[n_2,c_2],\\dots ],[ \\dots ],[ \\dots ]$$\n    不含空格，其中最外层的方括号包含三个用例的结果，每个内层方括号包含该用例找到的数对。具体来说，您的程序必须打印类似\n    $$[[n_1,c_1],[n_2,c_2]],[[\\dots]],[[\\dots]]$$\n    的内容，但使用实际计算出的值，并确保该行中没有任何空格。", "solution": "经过深入分析，该问题被认定为有效。它在科学上基于已建立的数论，问题提出得当，要求清晰一致，并以客观的数学语言表述。核心任务是识别和分析一类特定的合数：那些被以 $a=2$ 为基的 Fermat 素性检验识别为“可能素数”，但被以相同基的更强 Miller-Rabin (MR) 检验正确识别为合数的数。这些数是基于 2 的 Fermat 伪素数，但不是基于 2 的强伪素数。\n\n问题陈述中关于 Miller-Rabin 检验的描述，在检查 $x_r \\equiv -1 \\pmod{n}$ 的索引范围上略有歧义。我们将采用 MR 检验的标准解释，这与问题旨在将其与较弱的 Fermat 检验进行对比的意图相符。对于奇数 $n  2$ 且 $n-1 = 2^s d$（其中 $d$ 为奇数）以及基 $a$，标准的 MR 检验在满足 $a^d \\equiv 1 \\pmod{n}$ 或对于某个 $0 \\le r  s$ 范围内的 $r$ 满足 $a^{2^r d} \\equiv -1 \\pmod{n}$ 时通过。如果一个数未能通过此检验，则被宣布为合数。\n\n解决方案将通过为每个所需的数论检验实现辅助函数，然后将它们集成到指定的搜索算法中来构建。\n\n### 方法与实现步骤\n\n**1. 模幂运算**\n\nFermat 和 Miller-Rabin 检验的核心都是高效计算 $a^b \\pmod{m}$。这可以通过平方求幂法来完成，Python 的内置函数 `pow(base, exp, mod)` 提供了该功能。此函数将用于所有模幂运算需求。\n\n**2. Fermat 素性检验（基 $a=2$）**\n\n该检验是 Fermat 小定理的直接应用。对于给定的奇数 $n  2$，我们检查它是否满足同余式 $2^{n-1} \\equiv 1 \\pmod{n}$。问题要求找到通过此检验的整数。函数 `is_fermat_prp(n)` 将实现此检查。由于搜索范围是奇数 $n$，条件 $\\gcd(2, n)=1$ 总是满足的。如果 $n$ 是以 2 为基的 Fermat 伪素数，函数返回 `True`，否则返回 `False`。\n\n`is_fermat_prp(n)`：\n- 计算 $2^{n-1} \\pmod{n}$。\n- 如果结果为 $1$，则返回 `True`，否则返回 `False`。\n\n**3. Miller-Rabin 检验（基 $a=2$）**\n\nMR 检验为素性提供了更严格的检查。对于一个奇数 $n  2$，我们首先将 $n-1$ 分解为 $2^s d$ 的形式，其中 $d$ 是奇数。然后，检验会检查序列 $x_r = 2^{2^r d} \\pmod{n}$ 的值，其中 $r = 0, 1, \\dots, s-1$。如果 $n$ 是以 2 为基的强可能素数（通过检验），函数 `is_miller_rabin_prp(n)` 将返回 `True`，如果它确定是合数，则返回 `False`。\n\n`is_miller_rabin_prp(n)`：\n- 找到 $s$ 和 $d$ 使得 $n-1 = 2^s d$ 且 $d$ 为奇数。这通过将 $n-1$ 反复除以 2 直到它变为奇数来完成。\n- 计算 $x \\equiv 2^d \\pmod{n}$。\n- 如果 $x=1$ 或 $x=n-1$，$n$ 通过检验。返回 `True`。\n- 循环 $s-1$ 次：在每一步中将 $x$ 对 $n$ 取模后平方。\n  - $x \\leftarrow x^2 \\pmod{n}$。\n  - 如果 $x=n-1$，$n$ 通过检验。返回 `True`。\n- 如果循环完成而条件 $x=n-1$ 未被满足，$n$ 未通过检验。返回 `False`。\n\n**4. 结构探究：Korselt 判别法**\n\n问题要求检查合成的数是否满足 Carmichael 数的 Korselt 判别法。一个奇合数 $n$ 满足此判别法，条件是它是无平方因子的，并且对于 $n$ 的每个素因子 $p$，都有 $(p-1) \\mid (n-1)$。\n\n`is_korselt_carmichael(n)`：\n- **步骤4a：素因子分解和无平方因子检查**：该函数首先需要找到 $n$ 的所有不同素因子。对于给定的上限，试除法是足够的。在分解过程中，我们可以同时检查 $n$ 是否是无平方因子的。如果在任何时候我们找到一个因子 $p$ 且 $n/p$ 也能被 $p$ 整除，那么 $n$ 就不是无平方因子的，函数可以立即返回 `False`。\n- **步骤4b：整除性检查**：如果发现 $n$ 是无平方因子的，我们遍历其每个不同的素因子 $p_i$。对于每个 $p_i$，我们检查 $(p_i-1)$ 是否能整除 $(n-1)$。如果这个条件对任何素因子失败，函数返回 `False`。\n- 如果所有素因子都满足条件，函数返回 `True`。\n\n需要一个辅助函数 `is_prime(k)`，使用试除法直到 $\\sqrt{k}$，以确保我们只搜索合数 $n$。\n\n**5. 合成与最终输出生成**\n\n主程序逻辑遍历提供的测试用例 $(L, K)$。对于每个用例，它从 $3$ 开始搜索奇数 $n$ 直至上限 $L$。\n\n给定 $(L, K)$ 的主搜索循环：\n- 初始化一个空列表 `found_numbers`。\n- 从 $3$ 到 $L$ 迭代 $n$，步长为 $2$。\n- 对于每个 $n$：\n  - 使用 `is_prime(n)` 检查 $n$ 是否为合数。如果是素数，则继续下一个 $n$。\n  - 检查 `is_fermat_prp(n)` 是否为 `True`。\n  - 检查 `is_miller_rabin_prp(n)` 是否为 `False`。\n  - 如果两个条件都满足，$n$ 就是一个我们感兴趣的数。\n    - 检查 `is_korselt_carmichael(n)`。\n    - 将数对 $[n, \\text{korselt_result}]$ 添加到 `found_numbers`。\n    - 如果找到的数的数量达到 $K$，则中断搜索循环。\n- 循环结束后，列表 `found_numbers` 包含当前测试用例的结果。\n\n最后，所有测试用例的结果按照严格的规范格式化为单个字符串：`[[case1_results],[case2_results],[case3_results]]`，不含任何空格。这是通过为每个用例的结果列表生成字符串表示，然后用逗号连接这些字符串，并用一对最外层的方括号括起来实现的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as specified.\n    It synthesizes composite integers that pass the Fermat test but fail the Miller-Rabin test for base 2,\n    and checks them against Korselt's criterion.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"\n        Checks if a number is prime using trial division.\n        Assumes n is an odd integer  2 for optimization inside the main loop.\n        \"\"\"\n        if n  2:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        # Only need to check odd divisors up to sqrt(n)\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n\n    def is_fermat_prp(n):\n        \"\"\"\n        Checks if n passes the Fermat primality test for base a=2.\n        Returns True if 2^(n-1) === 1 (mod n).\n        \"\"\"\n        return pow(2, n - 1, n) == 1\n\n    def is_miller_rabin_prp(n):\n        \"\"\"\n        Checks if n passes the Miller-Rabin primality test for base a=2.\n        Returns True if n is a strong probable prime to base 2, False if composite.\n        \"\"\"\n        if n = 2 or n % 2 == 0:\n            return n == 2\n        \n        # Write n-1 as 2^s * d\n        d = n - 1\n        s = 0\n        while d % 2 == 0:\n            d //= 2\n            s += 1\n        \n        # x = 2^d mod n\n        x = pow(2, d, n)\n        \n        if x == 1 or x == n - 1:\n            return True\n            \n        for _ in range(s - 1):\n            x = pow(x, 2, n)\n            if x == n - 1:\n                return True\n        \n        return False\n\n    def is_korselt_carmichael(n):\n        \"\"\"\n        Checks if n satisfies Korselt's criterion for Carmichael numbers.\n        1. n must be square-free.\n        2. For every prime factor p of n, (p-1) must divide (n-1).\n        This function assumes n is odd and composite.\n        \"\"\"\n        n_minus_1 = n - 1\n        \n        # Factorize n and check for square-free property and divisibility.\n        temp_n = n\n        factors = []\n        \n        # Trial division for factorization\n        d = 3\n        while d * d = temp_n:\n            if temp_n % d == 0:\n                # Found a prime factor\n                factors.append(d)\n                if n_minus_1 % (d - 1) != 0:\n                    return False\n                \n                temp_n //= d\n                # Check if not square-free\n                if temp_n % d == 0:\n                    return False\n            d += 2\n        \n        # Handle the last factor if it exists\n        if temp_n  1:\n            factors.append(temp_n)\n            if n_minus_1 % (temp_n - 1) != 0:\n                return False\n\n        # Must be composite, so at least 2 factors. This is guaranteed by the calling context.\n        return True if len(factors) = 2 else False\n\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (5000, 10),\n        (300, 5),\n        (20000, 7),\n    ]\n\n    overall_results = []\n    for L, K in test_cases:\n        case_results = []\n        # Search odd integers n from 3 up to L\n        for n in range(3, L + 1, 2):\n            if len(case_results) = K:\n                break\n            \n            # Problem asks for composite integers n\n            if is_prime(n):\n                continue\n            \n            # Condition: Pass Fermat base 2, Fail MR base 2\n            if is_fermat_prp(n) and not is_miller_rabin_prp(n):\n                korselt_result = is_korselt_carmichael(n)\n                case_results.append([n, korselt_result])\n        \n        overall_results.append(case_results)\n\n    # Format the final output string precisely as required, with no spaces.\n    case_strings = []\n    for case_res in overall_results:\n        # Convert each [n, c] pair to a string like \"[n,True]\"\n        pair_strings = [f\"[{item[0]},{item[1]}]\" for item in case_res]\n        # Join pairs into \"[p1,p2,...]\"\n        case_strings.append(f\"[{','.join(pair_strings)}]\")\n    \n    # Join all case strings into \"[c1,c2,c3]\"\n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3260318"}, {"introduction": "米勒-拉宾测试是概率性的，这意味着单次测试无法提供绝对的确定性。这项高级编程挑战要求您找出最小的“强伪素数”——即那些能够骗过一系列给定基的米勒-拉宾测试的合数 [@problem_id:3260350]。通过寻找这些“强说谎者”，您将对该测试的概率性有更深的体会，并理解为何在构建高可信度的素性测试应用时，使用多个精心挑选的基是必不可少的。", "problem": "您的任务是设计并实现一个完整的、可运行的程序，对于每个给定的 $k$ 值，找出最小的合数 $n$，该数是对于前 $k$ 个素数底的强伪素数。本任务的教学背景是高等本科水平的数据结构与算法，要求从基本原理出发，对源于基础事实的素性检验进行推理。\n\n推导的基本依据：\n- 使用费马小定理：若 $p$ 是素数且 $\\gcd(a,p)=1$，则 $a^{p-1} \\equiv 1 \\pmod{p}$。\n- 使用 Miller-Rabin (MR) 强伪素数检验的定义，该定义源于将 $n-1$ 分解为 $n-1 = 2^{s} \\cdot d$（其中 $d$ 为奇数）、模算术下的重复平方以及 $\\gcd(a,n)=1$ 的必要性。\n\n问题所要求的形式化定义：\n- 令 $n$ 为一个奇数且 $n \\geq 3$，令 $a$ 为一个满足 $1  a  n$ 和 $\\gcd(a,n)=1$ 的整数。将 $n-1$ 写成 $n-1 = 2^{s} \\cdot d$ 的形式，其中 $d$ 为奇数。如果 $a^{d} \\equiv 1 \\pmod{n}$，或者存在一个 $r \\in \\{0,1,\\ldots,s-1\\}$ 使得 $a^{d \\cdot 2^{r}} \\equiv -1 \\pmod{n}$，则整数 $n$ 是以 $a$ 为底的强伪素数。\n- 在此任务中，“前 $k$ 个素数底”指的是集合 $\\{p_1, p_2, \\ldots, p_k\\}$，其中 $p_1=2, p_2=3, p_3=5, p_4=7, p_5=11, p_6=13$，依此类推，按升序排列。您必须将注意力限制在奇数 $n$ 上，因为任何偶合数 $n$ 在底为 $2$ 时会因 $\\gcd(2,n) \\neq 1$ 而立即失败。\n\n算法要求：\n- 从所述基本原理推导出一个算法，该算法针对输入的 $k$，按升序枚举候选奇数 $n \\geq 3$，并检验 $n$ 是否对 $\\{p_1,\\ldots,p_k\\}$ 中的每个底都是强伪素数。此检验必须使用与因子分解 $n-1 = 2^{s} \\cdot d$ 一致的模幂运算和重复平方来实现。\n- 您的算法必须验证返回的 $n$ 是合数。在搜索范围内使用数学上可靠的合数检验方法（例如，对于所遇到的数值大小，使用具有足够强固定底集的确定性 Miller-Rabin (MR) 检验），并确保不返回任何素数。\n- 效率是设计的一部分：您应通过逻辑筛选来减少不必要的工作，这种筛选基于每个底 $a$ 的 $\\gcd(a,n)=1$ 的要求，并通过使用由 $\\{p_1,\\ldots,p_k\\}$ 中小素数的乘积构建的模轮来跳过能被这些素数整除的候选数。\n\n输入和输出规范：\n- 程序没有用户输入。程序必须在内部运行一组固定的 $k$ 值测试套件，并打印相应的最小合数 $n$ 值。\n- 测试套件参数：\n  - 情况 1：$k=1$（仅底 2）。\n  - 情况 2：$k=2$（底 2 和 3）。\n  - 情况 3：$k=3$（底 2、3 和 5）。\n- 每种情况的答案必须是整数。您的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。例如，格式应为“[x1,x2,x3]”，其中 $x_1$、$x_2$ 和 $x_3$ 按顺序是这三种情况的整数答案。\n\n科学真实性和约束：\n- 所有逻辑纯粹是数学的，使用整数算术和模算术；不涉及任何物理单位。\n- 程序必须是自包含的，可在任何支持指定执行约束的现代环境中运行，并且不得读取任何外部输入。\n\n您的任务是生成该程序，并附上一份有理有据的解决方案，解释算法为何正确以及如何从上述基本依据推导而来。", "solution": "该问题要求设计并实现一个算法，以找到对于前 $k$ 个素数底（其中 $k \\in \\{1, 2, 3\\}$）而言的最小合数 $n$，该数是一个强伪素数。推导过程必须基于基本原理，即费马小定理和强伪素数的定义。\n\n**1. 基本原理：从费马小定理到 Miller-Rabin 检验**\n\n许多素性检验的基础是费马小定理，该定理指出，如果 $p$ 是一个素数，那么对于任何不能被 $p$ 整除的整数 $a$，我们有 $a^{p-1} \\equiv 1 \\pmod{p}$。其逆否命题提供了一种合数检验方法：如果一个整数 $n$ 对于某个与 $n$ 互质的整数 $a$（即 $\\gcd(a, n) = 1$），不满足 $a^{n-1} \\equiv 1 \\pmod{n}$，那么 $n$ 必定是合数。\n\n然而，一些被称为卡迈克尔数的合数，对于所有与 $n$ 互质的 $a$ 都满足 $a^{n-1} \\equiv 1 \\pmod{n}$，这使得这种简单的检验方法不够充分。Miller-Rabin 检验通过利用素数更深层次的性质来完善这一点。如果 $p$ 是素数，那么在模 $p$ 意义下，1 的平方根只有 $1$ 和 $-1$。也就是说，同余式 $x^2 \\equiv 1 \\pmod{p}$ 意味着 $x \\equiv 1 \\pmod{p}$ 或 $x \\equiv -1 \\pmod{p}$。\n\nMiller-Rabin 检验利用了这一事实。对于待检验的给定奇数 $n  2$，我们将 $n-1$ 分解为 $2^s \\cdot d$ 的形式，其中 $d$ 是奇数且 $s \\ge 1$。然后，我们考虑对于一个底 $a$（$1  a  n-1$）的模幂序列：\n$a^d, a^{2d}, a^{4d}, \\ldots, a^{2^{s-1}d} \\pmod{n}$。\n如果 $n$ 是素数，最后一项 $a^{2^s d} = a^{n-1}$ 必须是 $1 \\pmod{n}$（根据费马小定理，假设 $\\gcd(a,n)=1$）。当我们观察这个序列时，如果 $n$ 是素数，那么序列中第一个等于 $1 \\pmod{n}$ 的项，其前一项必须等于 $-1 \\pmod{n}$，除非第一项（$a^d$）本身就是 $1 \\pmod{n}$。任何其他结果都揭示了 $1 \\pmod{n}$ 的一个非平凡平方根，从而证明 $n$ 是合数。\n\n这引出了问题中陈述的强伪素数的形式化定义：一个奇合数 $n$ 如果满足素数所应满足的条件，则称其为以 $a$ 为底的强伪素数。也就是说，当 $n-1 = 2^s \\cdot d$（$d$ 为奇数）时，以下条件之一必须成立：\n1. $a^d \\equiv 1 \\pmod{n}$\n2. 存在某个 $r \\in \\{0, 1, \\ldots, s-1\\}$，使得 $a^{d \\cdot 2^r} \\equiv -1 \\pmod{n}$。\n\n如果一个合数 $n$ 通过了对底 $a$ 的这个检验，那么 $a$ 就被称为 $n$ 的“强说谎者”。我们的任务是找到最小的合数 $n$，使得前 $k$ 个素数都是它的强说谎者。\n\n**2. 算法设计**\n\n问题要求进行构造性搜索以找到最小的此类整数。因此，该算法将包含三个主要部分：对候选整数的系统性搜索、一个稳健的合数检验方法，以及强伪素数检验的实现。\n\n**2.1. 候选数枚举与优化**\n我们必须从 $n=3$ 开始，按升序搜索奇合数 $n$，以保证找到的第一个数是最小的。一个朴素的搜索方法是每步将 $n$ 增加 $2$。然而，我们可以根据问题的约束条件应用关键的优化。\n\n以 $a$ 为底的强伪素数的定义要求 $\\gcd(a, n) = 1$。当对前 $k$ 个素数底 $\\{p_1, \\ldots, p_k\\}$ 进行检验时，任何候选数 $n$ 都必须与它们全部互质。例如，当 $k=3$ 时，底是 $\\{2, 3, 5\\}$，所以我们只需要考虑那些不能被 $2$、$3$ 或 $5$ 整除的候选数 $n$。\n\n这自然地引出了轮式分解法。一个基于乘积 $M = p_1 \\cdot p_2 \\cdot \\ldots \\cdot p_k$ 的轮子可以让我们跳过这些素数的所有倍数。对于 $k=3$，$M=30$。我们只需要测试满足 $\\gcd(n, 30)=1$ 的数 $n$。这些数是模 $30$ 同余于 $\\{1, 7, 11, 13, 17, 19, 23, 29\\}$ 的数。这将候选数的数量减少到整数的 $\\phi(30)/30 = 8/30 \\approx 26.7\\%$，这是一个显著的效率提升。\n\n**2.2. 合数检验**\n对于每个候选数 $n$，在检查其是否满足强伪素数条件之前，我们必须验证它是合数。对于预期的 $n$ 的范围（最高约 $2.5 \\times 10^7$），试除法是一种计算上高效且确定的方法。我们可以预先计算一个素数列表，其上限为 $\\sqrt{N_{max}}$，其中 $N_{max}$ 是我们搜索范围的一个宽松上限。对于 $N_{max} = 3 \\times 10^7$，我们需要计算到 $\\sqrt{3 \\times 10^7} \\approx 5478$ 的素数。一个筛法可以生成这些素数。然后，对 $n$ 的合数检验包括检查它是否能被每个预计算出的素数 $p$（其中 $p^2 \\le n$）整除。如果找到一个因子，$n$ 就是合数。如果没有找到这样的因子，$n$ 就是素数，我们继续处理下一个候选数。\n\n**2.3. 强伪素数检验的实现 (`is_spsp`)**\n这个函数，我们称之为 `is_spsp(n, a)`，直接实现了形式化定义。\n1. 给定 $n$ 和底 $a$，首先找到 $s$ 和 $d$ 使得 $n-1 = 2^s \\cdot d$ 且 $d$ 为奇数。这可以通过反复将 $n-1$ 除以 $2$ 直到其变为奇数来实现。\n2. 使用高效的模幂算法（例如，二进制幂或重复平方）计算 $x = a^d \\pmod{n}$。\n3. 如果 $x=1$ 或 $x=n-1$，条件满足，$n$ 是以 $a$ 为底的强伪素数。\n4. 否则，对于从 $1$ 到 $s-1$ 的 $r$，反复将 $x$ 在模 $n$ 意义下平方（即 $x \\leftarrow x^2 \\pmod n$）。如果 $x=n-1$，则条件满足。\n5. 如果循环完成而未满足条件，则 $n$ 不是以 $a$ 为底的强伪素数。\n\n**3. 最终算法的综合**\n\n对于每个要求的 $k$ 值（$k \\in \\{1, 2, 3\\}$）：\n1. 生成前 $k$ 个素数底的集合 $B = \\{p_1, \\ldots, p_k\\}$。\n2. 使用筛法预计算一个素数列表，其上限足以进行合数检验（例如，上限为 $6000$）。\n3. 根据基于 $B$ 的轮子初始化候选数 $n$ 和搜索进程。对于 $k=1$，从 $n=9$ 开始，步长为 $2$。对于 $k1$，使用轮子生成与各底数互质的候选数。\n4. 无限循环：\n    a. 从枚举方案中选择下一个候选数 $n$。\n    b. 使用与筛出的素数进行试除的方法来验证 $n$ 是合数。如果 $n$ 是素数，则继续下一个候选数。\n    c. 假设 $n$ 是一个潜在的答案（`is_candidate = True`）。\n    d. 对于 $B$ 中的每个底 $a$：\n        i. 如果 `is_spsp(n, a)` 返回 `False`，则设置 `is_candidate = False` 并跳出内层循环。\n    e. 如果在检查所有底之后 `is_candidate` 仍然为 `True`，那么 $n$ 就是满足条件的最小合数。返回 $n$ 并终止此搜索。\n\n这个系统化的过程，结合了优化的搜索与数学上可靠的合数检验和强伪素数性质检验，保证了能为每个 $k$ 找到正确的最小整数。已知 $k=1, k=2$ 和 $k=3$ 的结果分别为 $2047$、$1,373,653$ 和 $25,326,001$。算法必须足够高效，才能在合理的时间内找到这些数字。对于 $k=2$ 和 $k=3$ 的情况，使用轮式法对性能至关重要。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to find the smallest composite strong pseudoprime for k=1, 2, 3.\n    \"\"\"\n\n    # The numpy import is included to conform to the problem's execution environment\n    # specification, but it is not used in the algorithmic logic.\n\n    def is_spsp(n, a):\n        \"\"\"\n        Checks if n is a strong pseudoprime to base a (Miller-Rabin test).\n        Assumes n is an odd integer  2.\n        \"\"\"\n        if n % a == 0:  # Base a divides n, so gcd(a, n) != 1\n            return False\n\n        # Decompose n-1 into 2^s * d\n        d, s = n - 1, 0\n        while d % 2 == 0:\n            d //= 2\n            s += 1\n\n        # Compute x = a^d mod n\n        x = pow(a, d, n)\n\n        if x == 1 or x == n - 1:\n            return True\n\n        # Repeatedly square x\n        for _ in range(s - 1):\n            x = pow(x, 2, n)\n            if x == n - 1:\n                return True\n\n        return False\n\n    def find_smallest_spsp(k):\n        \"\"\"\n        Finds the smallest composite integer n that is a strong pseudoprime\n        to the first k prime bases.\n        \"\"\"\n        # Generate a list of primes for bases and for compositeness testing\n        max_prime_sieve = 6000  # sqrt(3.6e7) is ~6000, covers up to k=3 answer\n        primes = []\n        is_prime_sieve = [True] * max_prime_sieve\n        is_prime_sieve[0] = is_prime_sieve[1] = False\n        for p in range(2, max_prime_sieve):\n            if is_prime_sieve[p]:\n                primes.append(p)\n                for i in range(p * p, max_prime_sieve, p):\n                    is_prime_sieve[i] = False\n        \n        bases = primes[:k]\n\n        def is_composite(n):\n            \"\"\"\n            Tests if n is composite using trial division with sieved primes.\n            Returns True if composite, False if prime.\n            \"\"\"\n            for p in primes:\n                if p * p  n:\n                    break\n                if n % p == 0:\n                    return True\n            return False\n\n        # Set up search parameters based on k\n        if k == 1: # Bases {2}\n            n = 3\n            increment_gen = (2 for _ in iter(int, 1)) # Generator for odd numbers\n        elif k == 2: # Bases {2, 3}, wheel for mod 6\n            n = 5\n            increments = [2, 4]\n            i_idx = 0\n            def gen_inc():\n                nonlocal i_idx\n                while True:\n                    yield increments[i_idx]\n                    i_idx = (i_idx + 1) % len(increments)\n            increment_gen = gen_inc()\n        elif k == 3: # Bases {2, 3, 5}, wheel for mod 30\n            n = 7\n            increments = [4, 2, 4, 2, 4, 6, 2, 6]\n            i_idx = 0\n            def gen_inc():\n                nonlocal i_idx\n                while True:\n                    yield increments[i_idx]\n                    i_idx = (i_idx + 1) % len(increments)\n            increment_gen = gen_inc()\n        else:\n            # Fallback for k  3, not required by problem\n            n = 3\n            increment_gen = (2 for _ in iter(int, 1))\n\n        while True:\n            # For k  1, the wheel generation already filters out multiples of bases.\n            # We add an explicit check for k=1 case (not needed, but for consistency)\n            # and to handle the starting n not being a multiple of a base.\n            \n            # The wheel guarantees n is not divisible by any base in B,\n            # except potentially for the starting n, which we choose carefully.\n            \n            if is_composite(n):\n                is_candidate = True\n                for b in bases:\n                    if not is_spsp(n, b):\n                        is_candidate = False\n                        break\n                if is_candidate:\n                    return n\n            \n            n += next(increment_gen)\n\n\n    test_cases = [1, 2, 3]\n    results = []\n    for k_val in test_cases:\n        result = find_smallest_spsp(k_val)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3260350"}]}