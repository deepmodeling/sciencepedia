{"hands_on_practices": [{"introduction": "许多数论问题乍看之下颇为复杂，但通过巧妙运用模运算的性质，我们常常能将其转化为一个更简洁、更易于解决的形式。本练习就是一个绝佳的例子，它要求我们找出一个满足一系列线性同余方程的最小正整数。通过对这些同余关系进行代数变换，你将发现一个优雅的解法，这不仅能加深你对模运算的理解，还能锻炼你的问题转化能力。[@problem_id:3256445]", "problem": "一个正整数 $x$ 需要满足联立的模关系\n$x \\equiv 1 \\pmod{2}$，$x \\equiv 2 \\pmod{3}$，$x \\equiv 3 \\pmod{4}$，以此类推，直到 $x \\equiv 9 \\pmod{10}$。仅使用模算术和整除性的核心定义，结合用于求最大公约数 (gcd) 的欧几里得算法和最小公倍数 (lcm) 的定义，确定满足所有这些关系的最小正整数 $x$。你只能在描述相容性和关于一个适当模数的唯一性时，引用中国剩余定理 (CRT) 的广义形式。报告确切的整数；无需四舍五入。", "solution": "该问题要求找到满足以下联立线性同余方程组的最小正整数 $x$：\n$x \\equiv 1 \\pmod{2}$\n$x \\equiv 2 \\pmod{3}$\n$x \\equiv 3 \\pmod{4}$\n...\n$x \\equiv 9 \\pmod{10}$\n\n这个方程组可以更普遍地表示为 $x \\equiv k \\pmod{k+1}$，其中整数 $k$ 的取值范围为从 $1$ 到 $9$。\n\n首先，我们分析每个独立同余方程的结构。根据定义，关系 $x \\equiv k \\pmod{k+1}$ 等价于 $k+1$ 整除差值 $x-k$。\n我们可以通过加减 $1$ 来变换表达式 $x-k$：\n$x-k = x+1 - 1 - k = (x+1) - (k+1)$。\n因此，$k+1$ 整除 $x-k$ 的条件变成了 $k+1$ 整除 $(x+1) - (k+1)$。\n因为任何整数 $m$ 都能整除自身，所以 $k+1$ 整除 $k+1$ 总是成立的。\n要使 $k+1$ 整除两项之差，而其中一项是 $k+1$ 的倍数，则另一项也必须是 $k+1$ 的倍数。\n因此，必然有 $k+1$ 整除 $x+1$。\n这等价于同余式 $x+1 \\equiv 0 \\pmod{k+1}$，可以重写为 $x \\equiv -1 \\pmod{k+1}$。\n\n将此简化应用于原始方程组中的每个同余式，我们得到一个等价的方程组：\n$x \\equiv -1 \\pmod{2}$\n$x \\equiv -1 \\pmod{3}$\n$x \\equiv -1 \\pmod{4}$\n...\n$x \\equiv -1 \\pmod{10}$\n\n该方程组表明，$x$ 被集合 $\\{2, 3, 4, 5, 6, 7, 8, 9, 10\\}$ 中的任何整数 $m$ 除时，余数都为 $-1$。这等价于说 $x+1$ 能被这个集合中的每个整数整除。\n换句话说，$x+1$ 必须是整数 $2, 3, 4, 5, 6, 7, 8, 9, 10$ 的一个公倍数。\n\n问题要求的是*最小正整数* $x$。这需要我们找到满足整除条件的 $x+1$ 的最小正值。一组整数的最小正公倍数是它们的最小公倍数 (lcm)。\n令 $L = \\text{lcm}(2, 3, 4, 5, 6, 7, 8, 9, 10)$。\n$x+1$ 的最小正值是 $L$。因此，最小正整数 $x$ 将是 $L-1$。\n\n为了计算 lcm，我们使用算术基本定理。我们找出集合中每个数的质因数分解：\n$2 = 2^1$\n$3 = 3^1$\n$4 = 2^2$\n$5 = 5^1$\n$6 = 2 \\times 3$\n$7 = 7^1$\n$8 = 2^3$\n$9 = 3^2$\n$10 = 2 \\times 5$\n\nlcm 是所有质因数分解中出现的每个质因数的最高次幂的乘积。涉及的质因数是 $2$，$3$，$5$ 和 $7$。\n$2$ 的最高次幂是 $2^3$（来自 $8$ 的分解）。\n$3$ 的最高次幂是 $3^2$（来自 $9$ 的分解）。\n$5$ 的最高次幂是 $5^1$（来自 $5$ 和 $10$ 的分解）。\n$7$ 的最高次幂是 $7^1$（来自 $7$ 的分解）。\n\n现在我们计算 $L$ 的值：\n$$L = 2^3 \\times 3^2 \\times 5^1 \\times 7^1$$\n$$L = 8 \\times 9 \\times 5 \\times 7$$\n$$L = 72 \\times 35$$\n$$L = 2520$$\n\n所以，最小公倍数是 $2520$。这是 $x+1$ 的最小正值。\n因此，最小正整数 $x$ 由下式给出：\n$$x = L - 1 = 2520 - 1 = 2519$$\n\n广义中国剩余定理证实了解的存在性，因为对于任意一对同余式 $x \\equiv -1 \\pmod{n_i}$ 和 $x \\equiv -1 \\pmod{n_j}$，条件 $-1 \\equiv -1 \\pmod{\\gcd(n_i, n_j)}$ 是平凡满足的。所有整数解的集合由 $x \\equiv -1 \\pmod{L}$ 给出，即 $x \\equiv -1 \\pmod{2520}$。解的形式为 $x = 2520k - 1$，其中 $k$ 为任意整数。最小正解在 $k=1$ 时出现，此时 $x = 2519$。", "answer": "$$\\boxed{2519}$$", "id": "3256445"}, {"introduction": "理论的威力在应用中得以彰显。本练习将带你进入密码学的世界，运用模运算的核心工具——求解线性同余方程和计算模逆元——来破解一个经典的仿射密码。通过分析已知的明文和密文对，你将像一名密码分析师一样，一步步推导出加密密钥，亲身体验数论算法在信息安全领域的基础性作用。[@problem_id:3256441]", "problem": "一个针对英文字母表的仿射密码通过一个线性同余方程将一个被编码为整数的明文字母映射到一个密文字母。字母表使用标准映射进行编码，其中 $A \\mapsto 0$，$B \\mapsto 1$，$\\dots$，$Z \\mapsto 25$。加密函数为 $E(x) \\equiv a x + b \\pmod{26}$，其中 $x$ 是明文整数，$E(x)$ 是密文整数，密钥 $(a,b)$ 满足 $\\gcd(a,26)=1$ 以确保可逆性。给定从一个由固定密钥加密的单一消息中观察到的以下明文-密文对：\n- $N \\mapsto R$\n- $U \\mapsto G$\n- $E \\mapsto U$\n- $D \\mapsto D$\n\n利用模算术的基本性质和线性同余方程的可逆性准则，恢复满足 $0 \\leq a  26$ 和 $0 \\leq b  26$ 的唯一密钥 $(a,b)$。将你的最终答案表示为行矩阵 $\\begin{pmatrix} a  b \\end{pmatrix}$。无需四舍五入，不涉及单位。", "solution": "该问题要求恢复一个针对26个英文字母的仿射密码的密钥 $(a,b)$。加密函数为 $E(x) \\equiv a x + b \\pmod{26}$，其中 $x$ 是明文字母的整数表示，$E(x)$ 是密文字母的整数表示。字母表编码为 $A \\mapsto 0, B \\mapsto 1, \\dots, Z \\mapsto 25$。密钥必须满足条件 $\\gcd(a, 26) = 1$，以确保存在唯一的解密函数。密钥参数被约束在 $0 \\leq a  26$ 和 $0 \\leq b  26$ 的范围内。\n\n首先，我们将给定的明文-密文字母对转换为它们对应的整数表示：\n\\begin{itemize}\n    \\item $N \\mapsto R$：明文字母 $N$ 是第14个字母，所以其整数表示为 $x_1 = 13$。密文字母 $R$ 是第18个字母，所以其整数表示为 $E(x_1) = 17$。\n    \\item $U \\mapsto G$：明文字母 $U$ 对应 $x_2 = 20$。密文字母 $G$ 对应 $E(x_2) = 6$。\n    \\item $E \\mapsto U$：明文字母 $E$ 对应 $x_3 = 4$。密文字母 $U$ 对应 $E(x_3) = 20$。\n    \\item $D \\mapsto D$：明文字母 $D$ 对应 $x_4 = 3$。密文字母 $D$ 对应 $E(x_4) = 3$。\n\\end{itemize}\n\n这些对应关系产生了一个包含两个未知变量 $a$ 和 $b$ 的四个线性同余方程组：\n\\begin{enumerate}\n    \\item $E(13) = 17 \\implies a(13) + b \\equiv 17 \\pmod{26}$\n    \\item $E(20) = 6 \\implies a(20) + b \\equiv 6 \\pmod{26}$\n    \\item $E(4) = 20 \\implies a(4) + b \\equiv 20 \\pmod{26}$\n    \\item $E(3) = 3 \\implies a(3) + b \\equiv 3 \\pmod{26}$\n\\end{enumerate}\n\n为了求解 $a$ 和 $b$，我们可以选择其中任意两个同余方程。让我们使用前两个。\n$$13a + b \\equiv 17 \\pmod{26}$$\n$$20a + b \\equiv 6 \\pmod{26}$$\n将第二个同余方程从第一个中减去，得到：\n$$(13a + b) - (20a + b) \\equiv 17 - 6 \\pmod{26}$$\n$$-7a \\equiv 11 \\pmod{26}$$\n由于 $-7 \\equiv 19 \\pmod{26}$，我们可以写成：\n$$19a \\equiv 11 \\pmod{26}$$\n为了解出 $a$，我们必须求出 $19$ 模 $26$ 的乘法逆元。该逆元存在的充分必要条件是 $\\gcd(19, 26) = 1$。我们应用扩展欧几里得算法：\n\\begin{align*} 26 = 1 \\cdot 19 + 7 \\\\ 19 = 2 \\cdot 7 + 5 \\\\ 7 = 1 \\cdot 5 + 2 \\\\ 5 = 2 \\cdot 2 + 1 \\end{align*}\n最大公约数为 $1$，所以逆元存在。现在，我们将 $1$ 表示为 $19$ 和 $26$ 的线性组合：\n\\begin{align*} 1 = 5 - 2 \\cdot 2 \\\\ = 5 - 2 \\cdot (7 - 1 \\cdot 5) = 5 - 2 \\cdot 7 + 2 \\cdot 5 = 3 \\cdot 5 - 2 \\cdot 7 \\\\ = 3 \\cdot (19 - 2 \\cdot 7) - 2 \\cdot 7 = 3 \\cdot 19 - 6 \\cdot 7 - 2 \\cdot 7 = 3 \\cdot 19 - 8 \\cdot 7 \\\\ = 3 \\cdot 19 - 8 \\cdot (26 - 1 \\cdot 19) = 3 \\cdot 19 - 8 \\cdot 26 + 8 \\cdot 19 \\\\ = 11 \\cdot 19 - 8 \\cdot 26 \\end{align*}\n从等式 $11 \\cdot 19 - 8 \\cdot 26 = 1$，我们可以推断出 $11 \\cdot 19 \\equiv 1 \\pmod{26}$。因此，$19$ 模 $26$ 的乘法逆元是 $11$。\n\n现在我们将同余方程 $19a \\equiv 11 \\pmod{26}$ 的两边都乘以 $11$：\n$$11 \\cdot (19a) \\equiv 11 \\cdot 11 \\pmod{26}$$\n$$1a \\equiv 121 \\pmod{26}$$\n为了简化 $121 \\pmod{26}$，我们进行除法运算：$121 = 4 \\times 26 + 17$。因此，$121 \\equiv 17 \\pmod{26}$。\n所以，我们得到 $a \\equiv 17 \\pmod{26}$。根据约束条件 $0 \\leq a  26$，我们得出 $a = 17$。\n我们必须验证 $a$ 的这个值是否满足可逆性条件 $\\gcd(a, 26) = 1$。确实，$\\gcd(17, 26) = 1$，因为 $17$ 是一个质数，并且不能整除 $26 = 2 \\times 13$。\n\n接下来，我们将 $a = 17$ 代入其中一个原始同余方程来求解 $b$。使用第一个同余方程，$13a + b \\equiv 17 \\pmod{26}$：\n$$13(17) + b \\equiv 17 \\pmod{26}$$\n$$221 + b \\equiv 17 \\pmod{26}$$\n我们计算 $221 \\pmod{26}$：$221 = 8 \\times 26 + 13$，所以 $221 \\equiv 13 \\pmod{26}$。\n该同余方程变为：\n$$13 + b \\equiv 17 \\pmod{26}$$\n$$b \\equiv 17 - 13 \\pmod{26}$$\n$$b \\equiv 4 \\pmod{26}$$\n根据约束条件 $0 \\leq b  26$，我们得出 $b = 4$。\n\n候选密钥为 $(a,b) = (17,4)$。我们必须验证这个密钥是否满足剩下的两个同余方程，以确保所提供的数据是一致的。\n对于同余方程(3)，$4a + b \\equiv 20 \\pmod{26}$：\n$$4(17) + 4 = 68 + 4 = 72$$\n我们检查 $72 \\equiv 20 \\pmod{26}$ 是否成立。$72 = 2 \\times 26 + 20 = 52 + 20$。该式成立。\n对于同余方程(4)，$3a + b \\equiv 3 \\pmod{26}$：\n$$3(17) + 4 = 51 + 4 = 55$$\n我们检查 $55 \\equiv 3 \\pmod{26}$ 是否成立。$55 = 2 \\times 26 + 3 = 52 + 3$。该式也成立。\n\n所有四个明文-密文对都与密钥 $(a,b) = (17,4)$ 一致。该密钥满足问题的所有条件。\n恢复的密钥为 $(a,b) = (17,4)$。", "answer": "$$\\boxed{\\begin{pmatrix} 17  4 \\end{pmatrix}}$$", "id": "3256441"}, {"introduction": "现代密码学的安全性常常依赖于特定数论问题的计算难度。这个综合性练习将引导你实现一个针对 RSA 密码系统的真实攻击，即当模数 $N$ 由两个相近的素数构成时，如何利用费马分解法高效地破解它。通过编写代码来完成从因数分解、计算私钥到最终解密的完整流程，你将深刻体会到算法设计与密码安全之间的紧密联系。[@problem_id:3256532]", "problem": "给定一个由模数 $N$ 和公钥指数 $e$ 组成的 Rivest–Shamir–Adleman (RSA) 公钥。模数 $N$ 是两个奇整数的乘积，通常是两个大素数 $p$ 和 $q$。在此任务中，您必须设计并实现一种攻击方法，该方法在 $p$ 和 $q$ 非常接近时有效，且仅使用以下基本事实和定义：\n- 在模算术中，对于整数 $a$、$b$ 和 $n$，关系 $a \\equiv b \\pmod{n}$ 表示 $n$ 整除 $a-b$。\n- 两个整数 $x$ 和 $y$ 的最大公约数 (gcd)，记为 $\\gcd(x,y)$，是能同时整除 $x$ 和 $y$ 的最大整数。\n- 在适当条件下，一个奇数可以表示为两个平方数之差。\n- $e$ 模 $\\varphi(N)$ 的乘法逆元（其中 $\\varphi(N)$ 是欧拉总计函数）是一个整数 $d$，满足 $ed \\equiv 1 \\pmod{\\varphi(N)}$。\n- 对于模数 $N=pq$（其中 $p$ 和 $q$ 是不同的素数），$\\varphi(N)=(p-1)(q-1)$。对于素数幂 $N=p^2$，$\\varphi(N)=p(p-1)$。\n\n您的程序必须：\n1. 当 $p$ 和 $q$ 接近时，基于平方差的观察来分解 $N$，并恢复 $p$ 和 $q$。\n2. 根据分解发现的 $N$ 的结构计算 $\\varphi(N)$。\n3. 使用扩展欧几里得算法 (EEA) 计算 $e$ 模 $\\varphi(N)$ 的模逆元 $d$，并验证 $ed \\equiv 1 \\pmod{\\varphi(N)}$。\n4. 对于每个测试用例，使用 $c \\equiv m^e \\pmod{N}$ 从给定的消息 $m$ 构建密文 $c$，然后使用恢复的 $d$ 通过计算 $m_{\\text{recovered}} \\equiv c^d \\pmod{N}$ 来解密并恢复 $m$。\n5. 为您的分解步骤使用 $B=5000$ 的迭代预算；如果分解在 $B$ 次迭代内未成功，则将该测试用例视为失败。\n\n您不得依赖任何专用的因数分解库或黑盒例程；所有逻辑必须从列出的基本事实推导而来。仅使用整数算术。\n\n测试套件：\n- 案例 1 (正常路径，大 $N$ 且素数接近):\n  - $N=1000036000099$, $e=65537$, $m=123456789$。\n- 案例 2 (边界路径，素数相差为 $2$):\n  - $N=10403$, $e=11$, $m=1234$。\n- 案例 3 (边缘案例，平方模数 $N=p^2$):\n  - $N=100140049$, $e=17$, $m=67890$。\n- 案例 4 (失败路径，素数不够接近，超出预算 $B$):\n  - $N=200250077$, $e=65537$, $m=424242$。\n\n输出规范：\n- 对于每个测试用例，如果分解在迭代预算 $B$ 内成功，则按顺序输出四整数列表 $[p,q,d,m_{\\text{recovered}}]$。\n- 如果分解在预算 $B$ 内失败，则输出布尔值 $False$。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，聚合为一个用方括号括起来的逗号分隔列表。例如，它应该看起来像 $[[p_1,q_1,d_1,m_1],False,[p_3,q_3,d_3,m_3],[p_4,q_4,d_4,m_4]]$，但没有空格：$[[p_1,q_1,d_1,m_1],False,[p_3,q_3,d_3,m_3],[p_4,q_4,d_4,m_4]]$。", "solution": "该问题要求实现一种针对 RSA 的特定密码学攻击，当模数 $N$ 的两个素数因子彼此接近时，该攻击有效。这种攻击基于 Fermat 的因数分解法。解决方案涉及几个步骤：分解 $N$、计算欧拉总计函数 $\\varphi(N)$、找到私钥指数 $d$，最后演示解密过程。\n\n### 步骤 1：使用 Fermat 方法分解 $N$\n\n攻击的核心在于模数 $N$ 是两个接近的奇整数 $p$ 和 $q$ 的乘积。设 $p \\le q$。由于它们很接近，它们的算术平均值 $a = \\frac{p+q}{2}$ 将是一个略大于其几何平均值 $\\sqrt{pq} = \\sqrt{N}$ 的整数。\n\n我们定义两个整数 $a$ 和 $b$：\n$$ a = \\frac{q+p}{2} $$\n$$ b = \\frac{q-p}{2} $$\n由于 $p$ 和 $q$ 都是奇数，它们的和 ($q+p$) 与差 ($q-p$) 都是偶数，这确保了 $a$ 和 $b$ 是整数。\n\n根据这些定义，我们可以用 $a$ 和 $b$ 来表示 $p$ 和 $q$：\n$$ p = a-b $$\n$$ q = a+b $$\n\n将这些代入 $N$ 的表达式中：\n$$ N = pq = (a-b)(a+b) = a^2 - b^2 $$\n这个方程可以重新排列为：\n$$ a^2 - N = b^2 $$\n\n这个恒等式是 Fermat 分解法的基础。为了分解 $N$，我们寻找一个整数 $a$，使得 $a^2 - N$ 是一个完全平方数，记为 $b^2$。一旦找到这样的数对 $(a, b)$，$N$ 的因子就可以立即恢复为 $p = a-b$ 和 $q = a+b$。\n\n对 $a$ 的搜索从它可能取的最小整数值开始。由于 $a = \\frac{p+q}{2}$ 且根据算术-几何平均值不等式 $\\frac{p+q}{2} \\ge \\sqrt{pq}$，我们知道 $a \\ge \\sqrt{N}$。因此，对 $a$ 的搜索可以从 $a_0 = \\lceil\\sqrt{N}\\rceil$ 开始。\n\n算法如下：\n1.  将搜索值 $a$ 初始化为 $\\lceil\\sqrt{N}\\rceil$。在整数运算中，如果 $N$ 是一个完全平方数，这等价于 `math.isqrt(N)`；否则为 `math.isqrt(N) + 1`。\n2.  最多迭代 $B$ 次，其中 $B$ 是给定的迭代预算 ($B=5000$)。\n3.  在每次迭代中，计算 $b^2 = a^2 - N$。\n4.  检查 $b^2$ 是否为完全平方数。这可以通过整数算术来验证，即计算 $b = \\text{isqrt}(b^2)$ 并检查是否 $b \\times b = b^2$。\n5.  如果 $b^2$ 是一个完全平方数，我们就找到了解。因子是 $p = a - b$ 和 $q = a + b$。迭代停止。\n6.  如果 $b^2$ 不是完全平方数，则将 $a$ 增加 1 并继续下一次迭代。\n7.  如果循环完成仍未找到解，则表示在给定的预算内分解失败。\n\n一个特殊情况是当 $N$ 是一个完全平方数时，即 $N=p^2$。在这种情况下，测试的第一个 $a$ 值将是 $a = \\sqrt{N} = p$。这将导致 $b^2 = a^2 - N = p^2 - p^2 = 0$，这是一个完全平方数。因此，$b=0$，因子被正确地识别为 $p=a-b=p$ 和 $q=a+b=p$。\n\n### 步骤 2：计算欧拉总计函数 $\\varphi(N)$\n\n成功将 $N$ 分解为 $p$ 和 $q$ 后，我们计算欧拉总计函数 $\\varphi(N)$。$\\varphi(N)$ 的公式取决于因子是否不同。\n-   如果 $p$ 和 $q$ 是不同的 ($p \\neq q$)，则 $\\varphi(N) = (p-1)(q-1)$。\n-   如果 $p=q$ (即 $N=p^2$)，则 $\\varphi(N) = p(p-1)$。\n\n这个值对下一步至关重要，因为它定义了计算私钥指数的模数。\n\n### 步骤 3：计算私钥指数 $d$\n\nRSA 私钥指数 $d$ 是公钥指数 $e$ 模 $\\varphi(N)$ 的乘法逆元。这由同余关系定义：\n$$ ed \\equiv 1 \\pmod{\\varphi(N)} $$\n为了找到 $d$，我们使用扩展欧几里得算法 (EEA)。EEA 找到满足 Bézout 恒等式的整数 $x$ 和 $y$，对于两个整数 $e$ 和 $\\varphi(N)$：\n$$ ex + \\varphi(N)y = \\gcd(e, \\varphi(N)) $$\n对于一个有效的 RSA 密钥，$\\gcd(e, \\varphi(N))$ 必须为 $1$。在这种情况下，将方程对 $\\varphi(N)$ 取模，我们得到：\n$$ ex \\equiv 1 \\pmod{\\varphi(N)} $$\n因此，由 EEA 返回的整数 $x$ 是 $e$ 的一个模逆元。$x$ 的值可能是负数，所以 $d$ 的最终值取为 $x \\pmod{\\varphi(N)}$，通常在范围 $[1, \\varphi(N)-1]$ 内。\n\n### 步骤 4：加密和解密\n\n在私钥的所有组件都准备好后，我们就可以执行解密。\n首先，使用公钥 $(N, e)$ 对给定的消息 $m$ 进行加密以生成密文 $c$：\n$$ c \\equiv m^e \\pmod{N} $$\n然后，使用私钥 $(N, d)$ 将密文 $c$ 解密回原始消息：\n$$ m_{\\text{recovered}} \\equiv c^d \\pmod{N} $$\n模幂运算（例如，快速幂算法）用于高效计算这些大数幂。最终结果应为 $m_{\\text{recovered}} = m$，这确认了恢复的私钥的正确性。\n对于每个测试用例，最终输出是列表 $[p, q, d, m_{\\text{recovered}}]$，或者如果分解失败，则为布尔值 `False`。", "answer": "```python\nimport math\n\ndef extended_euclidean_algorithm(a, b):\n    \"\"\"\n    Returns (gcd, x, y) such that a*x + b*y = gcd(a, b).\n    Handles large integers.\n    \"\"\"\n    if a == 0:\n        return b, 0, 1\n    else:\n        gcd, x1, y1 = extended_euclidean_algorithm(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n\ndef mod_inverse(e, phi):\n    \"\"\"\n    Computes the modular multiplicative inverse of e modulo phi.\n    \"\"\"\n    gcd, x, _ = extended_euclidean_algorithm(e, phi)\n    if gcd != 1:\n        # This case should not be reached for valid RSA parameters\n        # but is a safeguard.\n        raise ValueError('Modular inverse does not exist')\n    return (x % phi + phi) % phi\n\ndef is_perfect_square(n):\n    \"\"\"\n    Checks if n is a perfect square using integer arithmetic.\n    Returns (bool, integer_sqrt)\n    \"\"\"\n    if n  0:\n        return False, -1\n    if n == 0:\n        return True, 0\n    x = math.isqrt(n)\n    return x * x == n, x\n\ndef factorize_fermats(N, B):\n    \"\"\"\n    Factors N using Fermat's factorization method within a budget B.\n    \"\"\"\n    # N must be odd for this method to be defined with integer a, b.\n    # The problem statement guarantees this.\n    \n    a_start = math.isqrt(N)\n\n    # Handle the case where N is a perfect square.\n    if a_start * a_start == N:\n        return a_start, a_start\n\n    # If not a perfect square, start search from ceil(sqrt(N)).\n    a_start += 1\n    \n    for i in range(B):\n        a = a_start + i\n        b_squared = a * a - N\n        \n        is_sq, b = is_perfect_square(b_squared)\n        if is_sq:\n            p = a - b\n            q = a + b\n            # A final check to ensure factors are correct.\n            if p * q == N:\n                # Return factors sorted, as per convention.\n                return min(p, q), max(p, q)\n    \n    # Return None if factorization fails within budget\n    return None, None\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path, large N with close primes)\n        (1000036000099, 65537, 123456789),\n        # Case 2 (boundary path, primes differing by 2)\n        (10403, 11, 1234),\n        # Case 3 (edge case, square modulus N=p^2)\n        (100140049, 17, 67890),\n        # Case 4 (failure path, primes not close enough)\n        (200250077, 65537, 424242),\n    ]\n    budget_B = 5000\n    results = []\n\n    for N, e, m in test_cases:\n        p, q = factorize_fermats(N, budget_B)\n\n        if p is None:\n            results.append(False)\n            continue\n\n        phi_N = 0\n        if p == q:\n            # Case N = p^2\n            phi_N = p * (p - 1)\n        else:\n            # Case N = p*q with distinct p, q\n            phi_N = (p - 1) * (q - 1)\n        \n        # Compute private exponent d\n        d = mod_inverse(e, phi_N)\n        \n        # Encrypt the message m\n        c = pow(m, e, N)\n        \n        # Decrypt the ciphertext c\n        m_recovered = pow(c, d, N)\n        \n        results.append([p, q, d, m_recovered])\n\n    # Format the final output string exactly as specified\n    formatted_results = []\n    for res in results:\n        if isinstance(res, list):\n            formatted_results.append(f\"[{','.join(map(str, res))}]\")\n        else:\n            formatted_results.append(str(res))\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3256532"}]}