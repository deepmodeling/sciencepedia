{"hands_on_practices": [{"introduction": "第一个练习旨在巩固你对基本构建模块——两两线段相交测试的理解。通过实现一个计数不同颜色线段之间交点的函数，你将掌握处理一般性交叉以及共线重叠、端点接触等关键特殊情况的逻辑。该练习提供了方向谓词在解决具体计数问题中的直接应用 [@problem_id:3244190]。", "problem": "给定一个在二维 (2D) 欧几里得平面上的有限闭合线段集合。每条线段都标有一种来自一小组颜色名称的颜色。两点之间的闭合线段是其端点凸组合得到的所有点的集合。形式上，端点为 $(x_1,y_1)$ 和 $(x_2,y_2)$ 的线段是集合 $\\{(x,y)\\mid (x,y)=\\lambda(x_1,y_1)+(1-\\lambda)(x_2,y_2),\\ \\lambda\\in[0,1]\\}$。如果两条闭合线段至少共享一个点，则称它们相交。在端点处的相交也算作相交。共线重叠的线段被视为相交，对于这样的一对线段，相交应只计数一次。您必须只计算颜色不同的线段之间的交点；相同颜色线段之间的交点应被忽略。\n\n使用的基本原理和定义：\n- 向量 $(a_1,a_2)$ 和 $(b_1,b_2)$ 在二维中的向量叉积是标量 $a_1b_2-a_2b_1$。给定三个点 $p=(p_x,p_y)$，$q=(q_x,q_y)$ 和 $r=(r_x,r_y)$，有向面积（三角形 $pqr$ 有向面积的两倍）等于 $(q-p)$ 和 $(r-p)$ 的叉积，即 $(q_x-p_x)(r_y-p_y)-(q_y-p_y)(r_x-p_x)$。其符号决定了方向：正数表示逆时针，负数表示顺时针，零表示共线。\n- 当且仅当点 $r$ 与 $p$、$q$ 三点共线，并且 $r_x$ 和 $r_y$ 分别位于由 $p_x,q_x$ 和 $p_y,q_y$ 构成的闭区间内时，点 $r$ 才位于由 $p$ 和 $q$ 定义的闭合线段上。\n\n从这些定义出发，设计一个算法，对每个提供的测试用例，计算颜色不同的相交无序线段对的数量。该算法必须对所有一般位置和退化情况都正确，包括：\n- 线段在内部点相交的正常交叉。\n- 线段在单个端点处相接的端点接触。\n- 线段共享无穷多点的共线重叠，每对应计一次。\n- 长度为零的退化线段（一个点），可能位于另一条线段上或与另一个退化线段重合。\n\n您的程序必须是一个完整、可运行的程序，用于评估以下测试套件。每个测试用例是一个线段列表，每条线段由其端点和颜色标签指定。端点以整数坐标给出；所有数学实体都在平面 $\\mathbb{R}^2$ 中定义。\n\n测试套件：\n- 测试用例 $1$：\n  - 线段：红色 $((0,0),(5,5))$，蓝色 $((0,5),(5,0))$，红色 $((6,0),(6,5))$，绿色 $((3,3),(7,3))$。\n- 测试用例 $2$：\n  - 线段：红色 $((0,0),(2,0))$，红色 $((2,0),(4,0))$，蓝色 $((2,0),(2,2))$。\n- 测试用例 $3$：\n  - 线段：绿色 $((0,1),(4,1))$，蓝色 $((1,1),(3,1))$，绿色 $((0,0),(4,0))$。\n- 测试用例 $4$：\n  - 线段：红色 $((1,1),(1,1))$，蓝色 $((0,0),(2,2))$，蓝色 $((1,1),(1,1))$。\n- 测试用例 $5$：\n  - 线段：红色 $((0,0),(5,0))$，绿色 $((2,-1),(2,1))$，蓝色 $((3,-1),(3,1))$，红色 $((1,-1),(1,1))$，蓝色 $((0,0),(5,0))$，绿色 $((5,0),(6,0))$。\n\n覆盖性设计：\n- 测试用例 $1$ 涵盖了一般交叉、端点接触和不相交线段对。\n- 测试用例 $2$ 涵盖了端点接触，并排除了相同颜色的接触。\n- 测试用例 $3$ 涵盖了不同颜色间的共线重叠和平行不相交情况。\n- 测试用例 $4$ 涵盖了退化的点线段及其相交情况。\n- 测试用例 $5$ 涵盖了多重相交、不同颜色间的重叠、不同颜色间的端点接触，以及排除同色相交的情况。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含五个测试用例的结果，格式为用方括号括起来的逗号分隔列表。例如，如果测试用例的计数为 $a_1,a_2,a_3,a_4,a_5$，则输出必须严格采用 $[a_1,a_2,a_3,a_4,a_5]$ 的格式，不含空格。\n\n此问题不涉及任何物理单位。所有可能出现的角度都应被视为纯几何量，不带单位，但您的算法不得明确依赖角度测量。每个测试用例的答案必须是整数。程序必须是自包含的，不需要任何输入；它必须在执行时计算并打印给定测试套件的结果。", "solution": "问题要求我们计算不同颜色线段对之间的交点数量。解决方案必须稳健，并能处理所有几何构型，包括一般交叉、端点与线段接触以及共线重叠。判断两条闭合线段（例如，由端点 $p_1$ 和 $q_1$ 定义的 $S_1$ 以及由端点 $p_2$ 和 $q_2$ 定义的 $S_2$）是否相交，可以使用方向测试在算法上进行构建。\n\n基本工具是方向函数 $o(p, q, r)$，它确定有序三点组 $(p, q, r)$ 的方向。根据问题中的定义，这基于向量 $(q-p)$ 和 $(r-p)$ 的二维叉积的符号。设 $p=(p_x, p_y)$，$q=(q_x, q_y)$，$r=(r_x, r_y)$。叉积由 $(q_x-p_x)(r_y-p_y) - (q_y-p_y)(r_x-p_x)$ 给出。该值的符号决定了方向：\n-   $o(p, q, r) > 0$：点构成逆时针（或“左”）转。点 $r$ 位于从 $p$ 到 $q$ 的有向直线的左侧。\n-   $o(p, q, r)  0$：点构成顺时针（或“右”）转。点 $r$ 位于从 $p$ 到 $q$ 的有向直线的右侧。\n-   $o(p, q, r) = 0$：点 $p$、$q$ 和 $r$ 共线。\n\n相交逻辑分为两大类：一般情况和涉及共线的特殊情况。\n\n1.  **一般情况：正常相交**\n    两条线段 $S_1=p_1q_1$ 和 $S_2=p_2q_2$ 发生正常相交（即它们在两者的内部单点交叉）当且仅当每条线段的端点位于包含另一条线段的直线的两侧。这个条件可以转化为方向测试：\n    -   端点 $p_2$ 和 $q_2$ 必须位于包含 $p_1q_1$ 的直线的两侧。这意味着方向 $o(p_1, q_1, p_2)$ 和 $o(p_1, q_1, q_2)$ 必须不同且非零。\n    -   同时，端点 $p_1$ 和 $q_1$ 必须位于包含 $p_2q_2$ 的直线的两侧。这意味着方向 $o(p_2, q_2, p_1)$ 和 $o(p_2, q_2, q_1)$ 必须不同且非零。\n    如果这两个条件都成立，则线段相交。\n\n2.  **特殊情况：共线性**\n    如果一般情况下的四个方向测试中有任何一个结果为零，则表示有三个点共线。这涵盖了线段在端点处接触、一条线段位于另一条线段上（共线重叠）或退化的点线段位于另一条线段上的情况。如果一个与另一线段共线的点也位于该线段的*边界之内*，则发生相交。对于一个点 $r$ 要位于由 $p$ 和 $q$ 定义的闭合线段上，它必须与它们共线，并且其坐标 $(r_x, r_y)$ 必须满足 $r_x \\in [\\min(p_x, q_x), \\max(p_x, q_x)]$ 和 $r_y \\in [\\min(p_y, q_y), \\max(p_y, q_y)]$。这引出了四个具体的检查：\n    -   如果 $o(p_1, q_1, p_2) = 0$ 且点 $p_2$ 位于线段 $p_1q_1$ 上，则它们相交。\n    -   如果 $o(p_1, q_1, q_2) = 0$ 且点 $q_2$ 位于线段 $p_1q_1$ 上，则它们相交。\n    -   如果 $o(p_2, q_2, p_1) = 0$ 且点 $p_1$ 位于线段 $p_2q_2$ 上，则它们相交。\n    -   如果 $o(p_2, q_2, q_1) = 0$ 且点 $q_1$ 位于线段 $p_2q_2$ 上，则它们相交。\n\n    这些条件正确地处理了所有退化情况。例如，如果 $S_1$ 是一个点线段（$p_1=q_1$），则方向 $o(p_1, q_1, p_2)$ 和 $o(p_1, q_1, q_2)$ 将为零。相交测试随后正确地简化为通过测试 $o(p_2, q_2, p_1)=0$ 和坐标边界检查来判断点 $p_1$ 是否位于线段 $p_2q_2$ 上。同样，共线重叠的线段也会被检测到，因为一条线段的一个端点必然会位于另一条线段上。\n\n整个算法的流程如下：\n将交点计数初始化为 $0$。遍历输入集合中所有唯一的无序线段对 $(S_i, S_j)$。对于每一对，首先检查它们的颜色是否不同。如果不同，则应用上述全面的相交测试。如果测试结果为真，则增加交点计数。在检查完所有线段对后，最终的计数就是该测试用例的结果。对套件中的每个测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import namedtuple\n\n# Use a namedtuple for points for clarity and immutability.\nPoint = namedtuple('Point', ['x', 'y'])\n\ndef orientation(p, q, r):\n    \"\"\"\n    Computes the orientation of the ordered triplet (p, q, r).\n    The function uses the cross-product method as specified in the problem statement.\n    \n    Returns:\n     0 --> p, q, and r are colinear.\n     1 --> Counter-clockwise turn (left turn).\n    -1 --> Clockwise turn (right turn).\n    \"\"\"\n    # Cross product of vectors (q-p) and (r-p).\n    val = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x)\n    if val == 0:\n        return 0\n    return 1 if val > 0 else -1\n\ndef on_segment(p, q, r):\n    \"\"\"\n    Given three colinear points p, q, r, this function checks if point r lies on segment pq.\n    This check is valid only if orientation(p, q, r) is 0.\n    \"\"\"\n    return (r.x = max(p.x, q.x) and r.x >= min(p.x, q.x) and\n            r.y = max(p.y, q.y) and r.y >= min(p.y, q.y))\n\ndef intersects(s1_geom, s2_geom):\n    \"\"\"\n    Determines if two line segments intersect.\n    s1_geom and s2_geom are tuples of endpoint tuples, e.g., ((x1,y1), (x2,y2)).\n    \"\"\"\n    p1, q1 = Point(*s1_geom[0]), Point(*s1_geom[1])\n    p2, q2 = Point(*s2_geom[0]), Point(*s2_geom[1])\n\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    # General case: a proper intersection.\n    # The endpoints of each segment are on opposite sides of the other.\n    if o1 * o2  0 and o3 * o4  0:\n        return True\n    \n    # Special Cases: one or more points are colinear with another segment.\n    # These checks handle endpoint touching, colinear overlap, and point-on-segment cases.\n    if o1 == 0 and on_segment(p1, q1, p2):\n        return True\n\n    if o2 == 0 and on_segment(p1, q1, q2):\n        return True\n\n    if o3 == 0 and on_segment(p2, q2, p1):\n        return True\n\n    if o4 == 0 and on_segment(p2, q2, q1):\n        return True\n\n    return False\n\ndef solve():\n    \"\"\"\n    Main function to run the algorithm on the provided test suite.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        [\n            (((0, 0), (5, 5)), 'red'), \n            (((0, 5), (5, 0)), 'blue'), \n            (((6, 0), (6, 5)), 'red'), \n            (((3, 3), (7, 3)), 'green')\n        ],\n        # Test case 2\n        [\n            (((0, 0), (2, 0)), 'red'), \n            (((2, 0), (4, 0)), 'red'), \n            (((2, 0), (2, 2)), 'blue')\n        ],\n        # Test case 3\n        [\n            (((0, 1), (4, 1)), 'green'), \n            (((1, 1), (3, 1)), 'blue'), \n            (((0, 0), (4, 0)), 'green')\n        ],\n        # Test case 4\n        [\n            (((1, 1), (1, 1)), 'red'), \n            (((0, 0), (2, 2)), 'blue'),\n            (((1, 1), (1, 1)), 'blue')\n        ],\n        # Test case 5\n        [\n            (((0, 0), (5, 0)), 'red'), \n            (((2, -1), (2, 1)), 'green'),\n            (((3, -1), (3, 1)), 'blue'),\n            (((1, -1), (1, 1)), 'red'),\n            (((0, 0), (5, 0)), 'blue'),\n            (((5, 0), (6, 0)), 'green')\n        ]\n    ]\n\n    results = []\n    for case in test_cases:\n        count = 0\n        num_segments = len(case)\n        for i in range(num_segments):\n            for j in range(i + 1, num_segments):\n                s1_geom, s1_color = case[i]\n                s2_geom, s2_color = case[j]\n                \n                # Count intersections only between segments of different colors.\n                if s1_color != s2_color:\n                    if intersects(s1_geom, s2_geom):\n                        count += 1\n        results.append(count)\n\n    # The final print statement must follow the exact format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3244190"}, {"introduction": "在成对相交测试的基础上，这个问题挑战你将其应用于更复杂的几何结构：多边形。你将设计一个算法，通过系统地检查其不相邻的边来检测多边形是否自相交。这个练习强调了仔细进行问题分解以及将几何规则（如边的邻接性）正确转化为算法逻辑的重要性 [@problem_id:3244246]。", "problem": "给定一个由有序顶点列表定义的平面多边形。设顶点表示为 $p_0, p_1, \\dots, p_{n-1}$，其中每个 $p_i$ 是欧几里得平面中的一个点，具有整数坐标 $p_i = (x_i, y_i)$。多边形的边是线段 $e_i = [p_i, p_{(i+1) \\bmod n}]$，其中 $i = 0, 1, \\dots, n-1$。如果存在一对索引 $i \\neq j$ 的边 $e_i$ 和 $e_j$ 具有非空交集，则称该多边形为自相交多边形，但连续边在其共享端点处的交点是允许的。非连续边之间在端点或内部发生的交点被视为自相交。退化边（即 $p_i = p_{(i+1) \\bmod n}$）是允许的。退化边本身不会使多边形自相交，但如果退化边位于任何不相邻的边上或与之接触，则算作自相交。\n\n从平面几何和方向的核心定义出发，设计一个算法来确定给定的多边形是否自相交。仅使用整数算术。您的算法必须基于以下平面几何的基本定义和事实：\n\n- 对于点 $a = (x_a, y_a)$，$b = (x_b, y_b)$ 和 $c = (x_c, y_c)$，三角形 $(a, b, c)$ 的有向面积（带符号的叉积）为\n$$\n\\Delta(a, b, c) = (x_b - x_a)(y_c - y_a) - (y_b - y_a)(x_c - x_a).\n$$\n- 如果 $\\Delta(a, b, c) > 0$，则 $(a, b, c)$ 的方向为逆时针；如果 $\\Delta(a, b, c)  0$，则为顺时针；如果 $\\Delta(a, b, c) = 0$，则为共线。\n- 当且仅当点 $b$ 与 $(a, c)$ 共线，并且 $x_b$ 位于 $\\min(x_a, x_c)$ 和 $\\max(x_a, x_c)$ 之间，且 $y_b$ 位于 $\\min(y_a, y_c)$ 和 $\\max(y_a, y_c)$ 之间时，点 $b$ 位于闭合线段 $[a, c]$ 上。\n\n您的程序必须为两个闭合线段 $[p_1, q_1]$ 和 $[p_2, q_2]$ 实现一个相交测试，该测试能正确处理一般情况和共线的特殊情况。如果两条边的索引在模 $n$ 意义下是连续的（即 $j = (i+1) \\bmod n$ 或 $i = (j+1) \\bmod n$），则认为它们是相邻的。相邻边在其共享端点处的交点必须被忽略。\n\n您的任务是编写一个完整的程序，评估以下多边形测试套件，每个多边形按顺序列出整数坐标对，并输出每个多边形是否自相交：\n\n- 测试 $1$（简单凸四边形）：$[(0, 0), (3, 0), (3, 3), (0, 3)]$。\n- 测试 $2$（简单三角形）：$[(0, 0), (5, 0), (2, 4)]$。\n- 测试 $3$（具有正常交叉的蝶形多边形）：$[(0, 0), (4, 4), (0, 4), (4, 0)]$。\n- 测试 $4$（因重复顶点导致的不相邻端点接触）：$[(0, 0), (3, 0), (3, 3), (0, 3), (0, 0)]$。\n- 测试 $5$（共线重叠的非相邻边）：$[(0, 0), (2, 0), (3, 0), (1, 0)]$。\n- 测试 $6$（不产生非相邻交点的零长度边）：$[(0, 0), (2, 0), (2, 0), (2, 2), (0, 2)]$。\n- 测试 $7$（非相邻边之间的内部交叉）：$[(0, 0), (2, 0), (1, 1), (1, -1)]$。\n- 测试 $8$（凹但简单的多边形）：$[(0, 0), (4, 0), (4, 3), (2, 5), (0, 3)]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个结果必须是布尔值。例如，输出格式必须与 $[r_1, r_2, \\dots, r_8]$ 完全一样，其中每个 $r_i$ 是 $True$ 或 $False$，按顺序对应于测试 $i$。", "solution": "用户希望解决一个计算几何问题。\n\n问题是确定一个由有序顶点列表定义的多边形是否自相交。解决方案必须基于问题陈述中提供的基本几何图元，并且必须仅使用整数算术。\n\n### 第 1 步：提取已知信息\n- **顶点**：一个有序点列表 $p_0, p_1, \\dots, p_{n-1}$，其中每个 $p_i = (x_i, y_i)$ 具有整数坐标。\n- **边**：线段 $e_i = [p_i, p_{(i+1) \\bmod n}]$，其中 $i = 0, 1, \\dots, n-1$。\n- **自相交定义**：如果存在一对索引 $i \\neq j$ 的边 $e_i$ 和 $e_j$ 具有非空交集，则多边形为自相交。\n- **自相交的例外情况**：连续边在其共享端点处的交点是允许的（即不被视为自相交）。\n- **自相交规则**：非连续边之间的交点，无论是在端点还是在边的内部，都视为自相交。\n- **退化边**：允许边长为零的边，即 $p_i = p_{(i+1) \\bmod n}$。退化边本身不会导致自相交，但如果它与任何不相邻的边相交，则算作自相交。\n- **相邻边定义**：边 $e_i$ 和 $e_j$ 如果其索引在模 $n$ 意义下是连续的，则为相邻边，即 $j = (i+1) \\bmod n$ 或 $i = (j+1) \\bmod n$。\n- **方向公式**：对于点 $a = (x_a, y_a)$，$b = (x_b, y_b)$ 和 $c = (x_c, y_c)$，带符号的叉积为 $\\Delta(a, b, c) = (x_b - x_a)(y_c - y_a) - (y_b - y_a)(x_c - x_a)$。方向由 $\\Delta(a, b, c)$ 的符号确定：正数为逆时针，负数为顺时针，零为共线。\n- **在在线段上条件**：点 $b$ 位于闭合线段 $[a, c]$ 上当且仅当它与 $a$ 和 $c$ 共线（即 $\\Delta(a, b, c) = 0$）并且其坐标位于线段的边界框内：$x_b \\in [\\min(x_a, x_c), \\max(x_a, x_c)]$ 且 $y_b \\in [\\min(y_a, y_c), \\max(y_a, y_c)]$。\n- **测试用例**：问题提供了八个特定的多边形进行测试。\n\n### 第 2 步：使用提取的已知信息进行验证\n对问题进行严格的验证过程。\n\n- **科学依据**：该问题在标准欧几里得几何和计算几何中有坚实的基础。方向（叉积）、共线性、线段相交的定义是基本的且在数学上是合理的。\n- **问题明确**：问题定义清晰。多边形、边、邻接和自相交的定义是精确和明确的。这种结构保证了对于任何给定的多边形，都有一个唯一的、确定性的布尔答案。\n- **客观性**：语言是正式和客观的。它提供了数学定义，避免了任何主观或基于意见的陈述。\n- **完整性与一致性**：问题是自包含的。所有必要的定义和公式都已提供。处理一般情况、特殊共线情况、退化边和邻接的规则是明确且一致的。\n- **可行性**：约束是现实的。所有坐标都是整数，所需的计算可以使用整数算术执行，从而避免浮点精度问题。\n\n该问题没有可识别的缺陷。这是计算几何中一个标准但微妙的问题。定义是严谨的，必须精确遵循，尤其是在区分连续边和非连续边时，这种区分基于顶点索引，而不仅仅是几何上的邻接关系。\n\n### 第 3 步：结论与行动\n该问题是**有效的**。将根据所提供的原则构建一个解决方案。\n\n### 算法设计\n\n该算法的核心是检查每一对非连续边是否相交。这可以分解为三个主要部分。\n\n1.  **几何图元**：我们首先根据提供的定义为基本几何测试实现辅助函数。\n    -   `orientation(p, q, r)`：此函数将接收三个点 $p$、$q$ 和 $r$，并计算 $\\Delta(p, q, r)$ 的值。该值的符号决定了从线段 $[p, q]$ 到 $[q, r]$ 的转向是逆时针（$> 0$）、顺时针（$ 0$）还是点共线（$= 0$）。\n    -   `on_segment(p, q, r)`：此函数检查点 $q$ 是否位于线段 $[p, r]$ 上。它仅在已知这三个点共线时使用。它验证 $q$ 的坐标是否在 $p$ 和 $r$ 的最小和最大坐标范围内。\n\n2.  **线段相交测试**：一个函数 `segments_intersect(p1, q1, p2, q2)` 将确定两条闭合线段 $[p1, q1]$ 和 $[p2, q2]$ 是否相交。此函数必须处理两类情况：\n    -   **一般情况**：线段正常交叉。当每个线段的端点位于包含另一个线段的直线的两侧时，会发生这种情况。这可以通过计算四个方向来测试：$\\Delta(p1, q1, p2)$、$\\Delta(p1, q1, q2)$、$\\Delta(p2, q2, p1)$ 和 $\\Delta(p2, q2, q1)$。如果前两个方向的符号相反，并且后两个方向的符号也相反，则发生相交。使用整数算术，这通过检查方向的乘积是否为负（例如，$\\Delta_1 \\cdot \\Delta_2  0$）来完成。\n    -   **特殊（共线）情况**：一个线段的端点位于另一条线段上。这包括线段在端点处接触（T形连接）或沿一条线重叠的情况。对于四个方向计算中的每一个，如果结果为 $0$，则表示三个点共线。然后我们必须使用 `on_segment` 函数来检查此共线点是否位于相关线段上。例如，如果 $\\Delta(p1, q1, p2) = 0$，我们检查 $p2$ 是否位于线段 $[p1, q1]$ 上。如果满足这四个共线条件中的任何一个，则存在交点。\n\n3.  **多边形自相交检查**：主函数 `is_self_intersecting(polygon)` 遍历多边形的所有唯一边对 $(e_i, e_j)$ 并检查相交情况。\n    -   顶点数为 $n$。边为 $e_0, e_1, \\dots, e_{n-1}$。\n    -   我们使用嵌套循环遍历所有索引对 $(i, j)$，使得 $0 \\le i  j  n$。\n    -   对于每对 $(i, j)$，我们必须首先确定边 $e_i$ 和 $e_j$ 是否是连续的。根据问题，如果边的索引在模 $n$ 意义下是连续的，则它们是连续的。对于一对 $(i, j)$ 其中 $i  j$，这意味着如果 $j = i+1$（标准邻接）或如果 $i=0$ 且 $j=n-1$（环绕邻接），我们必须跳过检查。\n    -   如果边不是连续的，我们对它们调用 `segments_intersect`。\n    -   如果 `segments_intersect` 对任何一对非连续边返回 true，我们已找到自相交。该函数可以立即返回 `True`。\n    -   如果循环完成而没有找到任何此类交点，则多边形是简单的，函数返回 `False`。\n\n这种算法结构系统地、正确地实现了问题陈述中指定的所有规则，包括仔细处理非连续边在端点处的交点，这种情况可能由多边形定义中的重复顶点引起。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the polygon self-intersection problem for a suite of test cases.\n    \"\"\"\n\n    # Helper function to compute the orientation of an ordered triplet (p, q, r).\n    # The orientation determines if the turn from segment pq to qr is\n    # counter-clockwise, clockwise, or collinear.\n    # Returns: the raw cross product value.\n    # > 0 for counter-clockwise\n    #  0 for clockwise\n    # = 0 for collinear\n    def orientation(p, q, r):\n        # Using the formula: (q_x - p_x)(r_y - p_y) - (q_y - p_y)(r_x - p_x)\n        # All coordinates are integers, so the result is a guaranteed integer.\n        val = (q[0] - p[0]) * (r[1] - p[1]) - \\\n              (q[1] - p[1]) * (r[0] - p[0])\n        return val\n\n    # Helper function to check if point q lies on the closed segment [p, r].\n    # This function assumes p, q, and r are already known to be collinear.\n    def on_segment(p, r, q):\n        # Checks if q's coordinates are within the bounding box of p and r.\n        return (q[0] = max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n                q[1] = max(p[1], r[1]) and q[1] >= min(p[1], r[1]))\n\n    # Function to check if line segment [p1, q1] and [p2, q2] intersect.\n    def segments_intersect(p1, q1, p2, q2):\n        # Calculate the four orientations needed for general and special cases.\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n\n        # General case: The segments cross each other.\n        # This happens if the orientations (p1,q1,p2) and (p1,q1,q2) are different,\n        # and (p2,q2,p1) and (p2,q2,q1) are also different.\n        if o1 * o2  0 and o3 * o4  0:\n            return True\n\n        # Special Cases (Collinear):\n        # An endpoint of one segment lies on the other segment.\n        # o1 = 0: p1, q1, p2 are collinear. Check if p2 is on segment [p1, q1].\n        if o1 == 0 and on_segment(p1, q1, p2):\n            return True\n        # o2 = 0: p1, q1, q2 are collinear. Check if q2 is on segment [p1, q1].\n        if o2 == 0 and on_segment(p1, q1, q2):\n            return True\n        # o3 = 0: p2, q2, p1 are collinear. Check if p1 is on segment [p2, q2].\n        if o3 == 0 and on_segment(p2, q2, p1):\n            return True\n        # o4 = 0: p2, q2, q1 are collinear. Check if q1 is on segment [p2, q2].\n        if o4 == 0 and on_segment(p2, q2, q1):\n            return True\n\n        # If none of the above, the segments do not intersect.\n        return False\n\n    # Main function to determine if a polygon is self-intersecting.\n    def is_self_intersecting(polygon):\n        n = len(polygon)\n        if n  3:\n            # A polygon must have at least 3 vertices to potentially self-intersect.\n            return False\n\n        # Iterate through all unique pairs of edges (e_i, e_j).\n        for i in range(n):\n            for j in range(i + 1, n):\n                # According to the problem, adjacent edges are defined by consecutive indices.\n                # We must skip pairs of adjacent edges.\n                # Case 1: Standard adjacency (e.g., e_i and e_{i+1})\n                if j == i + 1:\n                    continue\n                # Case 2: Wrap-around adjacency (e.g., e_{n-1} and e_0)\n                if i == 0 and j == n - 1:\n                    continue\n\n                # Get the endpoints of the two edges e_i and e_j.\n                p1 = polygon[i]\n                q1 = polygon[(i + 1) % n]\n                p2 = polygon[j]\n                q2 = polygon[(j + 1) % n]\n\n                # Check for intersection between these non-adjacent edges.\n                # Any intersection (endpoint or interior) counts as a self-intersection.\n                if segments_intersect(p1, q1, p2, q2):\n                    return True\n        \n        # If no intersections between non-adjacent edges are found, the polygon is simple.\n        return False\n\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: simple convex quadrilateral\n        [(0, 0), (3, 0), (3, 3), (0, 3)],\n        # Test 2: simple triangle\n        [(0, 0), (5, 0), (2, 4)],\n        # Test 3: bow-tie polygon with a proper crossing\n        [(0, 0), (4, 4), (0, 4), (4, 0)],\n        # Test 4: nonadjacent endpoint touch due to repeated vertex\n        [(0, 0), (3, 0), (3, 3), (0, 3), (0, 0)],\n        # Test 5: collinear overlapping nonadjacent edges\n        [(0, 0), (2, 0), (3, 0), (1, 0)],\n        # Test 6: non-consecutive edges touching due to a repeated vertex\n        [(0, 0), (2, 0), (2, 0), (2, 2), (0, 2)],\n        # Test 7: interior crossing between nonadjacent edges\n        [(0, 0), (2, 0), (1, 1), (1, -1)],\n        # Test 8: concave but simple polygon\n        [(0, 0), (4, 0), (4, 3), (2, 5), (0, 3)],\n    ]\n\n    results = []\n    for polygon in test_cases:\n        result = is_self_intersecting(polygon)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The output format is a string representation of a Python list of booleans.\n    # Using map(str, ...) and join handles the True/False capitalization correctly.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3244246"}, {"introduction": "在掌握了纯粹的几何理论之后，这最后一个练习将深入探讨计算几何的一个关键现实问题：数值稳定性。你将构建旨在挑战算法极限的对抗性测试用例，并将一个使用浮点数的天真实现与一个基于精确整数运算的谓词进行比较，从而直接观察由精度损失引起的计算失败。这个练习能让你深刻理解，为什么稳健的几何算法需要精确的算术处理以避免灾难性错误 [@problem_id:3244227]。", "problem": "你的任务是设计并实现一个完整的程序，该程序构造平面线段对的对抗性集合，并评估朴素浮点线段相交测试相对于精确谓词线段相交测试的鲁棒性。数学基础必须从第一性原理开始：通过平移向量的行列式定义平面朝向，以及由此产生的线段相交的逻辑条件。具体来说，给定平面上的三个点 $p=(p_x,p_y)$、$q=(q_x,q_y)$ 和 $r=(r_x,r_y)$，由这些点确定的三角形的有向面积由二维叉积定义：\n$$\n\\operatorname{orient}(p,q,r) = (q_x - p_x)\\cdot(r_y - p_y) - (q_y - p_y)\\cdot(r_x - p_x).\n$$\n$\\operatorname{orient}(p,q,r)$ 的符号决定了朝向：正数表示逆时针，零表示共线，负数表示顺时针。两条线段 $[p_1,q_1]$ 和 $[p_2,q_2]$ 相交，当且仅当它们的朝向满足从这些定义导出的一般情况下的交叉条件和边界共线情况。朴素谓词使用双精度浮点数计算 $\\operatorname{orient}$ 和所有比较，而精确谓词使用整数计算所有值，从而在所有输入坐标都是整数时保证精确性。\n\n你必须实现两个基于上述定义的相交谓词：\n- 一个朴素的浮点谓词，它使用编程语言默认的 $64$ 位浮点类型，以双精度浮点进行所有算术评估。\n- 一个精确谓词，它使用整数运算进行所有算术评估，在坐标为整数时利用精确整数算术。\n\n然后，你必须生成旨在考验数值鲁棒性的对抗性测试输入：\n- 坐标值极大且间距很小的近乎平行或平行的线段，使得在给定数量级下，小于末位单元（$ULP$）的差异在浮点舍入下丢失。\n- 共享端点的线段，以测试边界处理。\n- 重叠的共线线段和不重叠的共线线段，以测试共线性和线段上点（on-segment）逻辑。\n\n使用以下测试套件。每个测试用例是一组线段对，并且所有坐标必须是整数。令 $B = 2^{60}$。\n\n1. 正常路径中等规模（$N=12$ 对）：对于 $i=0,1,2,3,4,5$，包含线段对\n   - $[p_1,q_1]=[(i,0),(i,10)]$，$[p_2,q_2]=[(i-1,5),(i+1,5)]$，\n   它们相交。对于 $i=6,7,8,9,10,11$，包含线段对\n   - $[p_1,q_1]=[(i,0),(i,10)]$，$[p_2,q_2]=[(i-1,15),(i+1,15)]$，\n   它们不相交。这些测试用例在浮点算术预期可靠的中等数量级下，检验了一般的交叉逻辑。\n\n2. 大规模对抗性近乎平行（$N=16$ 对）：对于 $i=0,1,\\dots,15$，包含线段对\n   - $[p_1,q_1]=[(B+i,B),(B+i,B+10)]$ 和 $[p_2,q_2]=[(B+i+10,B),(B+i+10,B+10)]$。\n   这是两条垂直线段，水平间距为 $10$。在 $B=2^{60}$ 的数量级下，双精度的 $ULP$ 是 $2^{8}=256$，因此加上 $10$ 或任何小于 $256$ 的值在浮点格式中无法表示；像 $(B+i+10)-(B+i)$ 这样的差值在转换为浮点数时将被舍入为 $0$。这会产生严重的舍入误差，可能导致朴素谓词将不相交的线段错误分类。\n\n3. 中等规模共享端点（$N=10$ 对）：对于 $i=0,1,\\dots,9$，包含线段对\n   - $[p_1,q_1]=[(i,i),(i+5,i+5)]$ 和 $[p_2,q_2]=[(i+5,i+5),(i+10,i)]$。\n   这些线段对共享端点 $(i+5,i+5)$，构成一个边界相交的情况。\n\n4. 大规模共线重叠与不重叠（$N=12$ 对）：包含 $6$ 对重叠线段和 $6$ 对不重叠线段，它们位于水平线 $y=B$ 上：\n   - 重叠（$6$ 对）：$[p_1,q_1]=[(B,B),(B+5,B)]$，$[p_2,q_2]=[(B+2,B),(B+7,B)]$。\n   - 不重叠（$6$ 对）：$[p_1,q_1]=[(B,B),(B+5,B)]$，$[p_2,q_2]=[(B+6,B),(B+10,B)]$。\n   在 $B=2^{60}$ 的数量级下，将任何小于 $256$ 的整数加到 $B$ 上都会在浮点运算中被舍去，因此朴素谓词可能会混淆不同的点或线段，将不重叠的线段错误地分类为重叠。\n\n对于每个测试用例，计算朴素谓词相对于精确谓词的失败率，结果为一个小数 $f = \\frac{\\text{不匹配数}}{\\text{线段对数}}$。同时计算整个测试套件中所有线段对的总失败率。你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：$[\\text{rate\\_happy},\\text{rate\\_near\\_parallel},\\text{rate\\_shared\\_endpoint},\\text{rate\\_collinear},\\text{rate\\_overall}]$。程序不需要任何输入；所有数据必须由程序内部生成。条目唯一可接受的输出类型是十进制数（浮点数）、整数、布尔值或这些类型的列表；在这里，你必须使用十进制数表示比率。此任务中不涉及物理单位或角度。", "solution": "该问题是有效的，因为它科学地基于计算几何的原理，问题定义良好，具有唯一的确定性解，并使用客观、形式化的语言陈述。任务是实现并比较一个精确算术的线段相交谓词和一个朴素的浮点谓词，使用旨在突显有限精度算术陷阱的对抗性测试用例。\n\n判断两条线段是否相交的数学基础是朝向测试。给定平面上的三个有序点 $p=(p_x, p_y)$，$q=(q_x, q_y)$ 和 $r=(r_x, r_y)$，其朝向可以通过计算向量 $\\vec{pq}$ 和 $\\vec{pr}$ 的二维叉积的符号来确定。这由以下行列式给出：\n$$\n\\operatorname{orient}(p,q,r) = \\det(\\vec{pq}, \\vec{pr}) = (q_x - p_x)(r_y - p_y) - (q_y - p_y)(r_x - p_x)\n$$\n该表达式的符号决定了朝向：\n- 如果 $\\operatorname{orient}(p,q,r) > 0$，点序列 $p \\to q \\to r$ 构成逆时针（左）转。\n- 如果 $\\operatorname{orient}(p,q,r)  0$，则是顺时针（右）转。\n- 如果 $\\operatorname{orient}(p,q,r) = 0$，这三个点共线。\n\n两条线段 $[p_1, q_1]$ 和 $[p_2, q_2]$ 相交，当且仅当满足以下两个条件之一：\n1.  **一般情况：** 线段恰当交叉。这种情况发生于每条线段的两个端点位于包含另一条线段的直线的两侧。此条件满足当且仅当朝向 $(\\operatorname{orient}(p_1, q_1, p_2), \\operatorname{orient}(p_1, q_1, q_2))$ 和 $(\\operatorname{orient}(p_2, q_2, p_1), \\operatorname{orient}(p_2, q_2, q_1))$ 都是符号相反的对（一个为正，一个为负）。\n2.  **特殊情况（共线）：** 一条线段的一个端点位于另一条线段上。这包括共享端点和重叠共线线段的情况。这种情况发生于一个朝向测试结果为零（例如，$\\operatorname{orient}(p_1, q_1, p_2)=0$），并且该测试中涉及的点（这里是 $p_2$）位于线段（这里是 $[p_1, q_1]$）的边界框内。一个点 $r$ 在线段 $[p,q]$ 上的条件是，它与 $p$ 和 $q$ 共线，并且其坐标位于 $p$ 和 $q$ 的坐标之间：\n    $$\n    (\\min(p_x, q_x) \\le r_x \\le \\max(p_x, q_x)) \\land (\\min(p_y, q_y) \\le r_y \\le \\max(p_y, q_y))\n    $$\n\n程序将实现此相交算法的两个版本：\n-   **精确谓词：** 此谓词对整数坐标进行操作。由于所有输入都被指定为整数，朝向公式仅涉及整数的减法和乘法。Python 的任意精度整数保证了这些运算在执行时不会损失精度，从而得出数学上精确的行列式符号结果。\n-   **朴素谓词：** 此谓词使用标准的 $64$ 位双精度浮点算术（语言的 `float` 类型，此处明确为 `numpy.float64`）。输入的整数坐标首先被转换为浮点数。\n\n对抗性测试用例旨在利用浮点表示的固有局限性。一个标准的 $64$ 位浮点数具有有限的精度（一个 $52$ 位的尾数）。这导致几何计算中两种主要的失效模式：\n-   **大数值下的精度损失：** 对于一个大数 $x$，它与下一个可表示的浮点数之间的间隙，即末位单元（$ULP$），会变得很大。对于 $x = B = 2^{60}$，$ULP$ 为 $2^{60-52} = 2^8 = 256$。因此，将一个小的整数 $\\delta$（其中 $|\\delta|  ULP/2 = 128$）加到 $B$ 上，其结果会舍入回 $B$ 的原始浮点表示。即，$fl(B+\\delta) = fl(B)$。对抗性测试利用这一点，定义了诸如 $(B+i, B)$ 和 $(B+i+10, B)$ 这样的坐标，它们在整数算术中是不同的，但在浮点算术中会塌缩为相同的点，导致朴素谓词失败。\n-   **灾难性抵消：** 朝向公式涉及减法。当两个几乎相等的大数相减时，前面的有效数字会相互抵消，结果由舍入误差主导。这可能导致计算出的朝向值符号错误或错误地为零，从而导致错误的相交结果。\n\n解决方案程序遵循以下步骤：\n1. 实现精确和朴素的朝向及相交谓词。\n2. 生成四个指定的测试套件：一个具有中等坐标的“正常路径”，一个共享端点的情况，以及两个使用大数值 $B=2^{60}$ 的对抗性情况，用于测试近乎平行的不相交线段和共线线段。\n3. 对于每个测试套件中的每一对线段，比较朴素谓词和精确谓词的结果。如果结果不同，则记录为一次不匹配。\n4. 每个套件的失败率计算为不匹配次数与该套件中总线段对数的比率。同时计算所有测试用例的总失败率。\n5. 将最终结果格式化并打印为逗号分隔的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs, implements, and evaluates naive vs. exact line segment intersection predicates.\n    \"\"\"\n\n    # --- PREDICATE IMPLEMENTATIONS ---\n\n    def orient_exact(p, q, r):\n        \"\"\"\n        Computes the orientation of ordered triplet (p, q, r) using exact integer arithmetic.\n        Returns: 1 for CCW, -1 for CW, 0 for collinear.\n        \"\"\"\n        val = (q[0] - p[0]) * (r[1] - p[1]) - \\\n              (q[1] - p[1]) * (r[0] - p[0])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else -1\n\n    def orient_naive(p, q, r):\n        \"\"\"\n        Computes the orientation using 64-bit floating-point arithmetic.\n        \"\"\"\n        px, py = np.float64(p[0]), np.float64(p[1])\n        qx, qy = np.float64(q[0]), np.float64(q[1])\n        rx, ry = np.float64(r[0]), np.float64(r[1])\n        \n        val = (qx - px) * (ry - py) - (qy - py) * (rx - px)\n        \n        if val == 0.0:\n            return 0\n        return 1 if val > 0.0 else -1\n\n    def on_segment_exact(p, q, r):\n        \"\"\"\n        Given three collinear integer points p, q, r, checks if r lies on segment pq.\n        \"\"\"\n        return (r[0] = max(p[0], q[0]) and r[0] >= min(p[0], q[0]) and\n                r[1] = max(p[1], q[1]) and r[1] >= min(p[1], q[1]))\n    \n    def on_segment_naive(p, q, r):\n        \"\"\"\n        Given three collinear float points p, q, r, checks if r lies on segment pq.\n        \"\"\"\n        return (r[0] = max(p[0], q[0]) and r[0] >= min(p[0], q[0]) and\n                r[1] = max(p[1], q[1]) and r[1] >= min(p[1], q[1]))\n\n    def intersects_exact(s1, s2):\n        \"\"\"\n        Returns true if segments s1 and s2 intersect, using exact predicates.\n        \"\"\"\n        p1, q1 = s1\n        p2, q2 = s2\n        \n        o1 = orient_exact(p1, q1, p2)\n        o2 = orient_exact(p1, q1, q2)\n        o3 = orient_exact(p2, q2, p1)\n        o4 = orient_exact(p2, q2, q1)\n\n        if o1 * o2  0 and o3 * o4  0:\n            return True\n        if o1 == 0 and on_segment_exact(p1, q1, p2): return True\n        if o2 == 0 and on_segment_exact(p1, q1, q2): return True\n        if o3 == 0 and on_segment_exact(p2, q2, p1): return True\n        if o4 == 0 and on_segment_exact(p2, q2, q1): return True\n            \n        return False\n\n    def intersects_naive(s1, s2):\n        \"\"\"\n        Returns true if segments s1 and s2 intersect, using naive predicates.\n        \"\"\"\n        p1, q1 = s1\n        p2, q2 = s2\n        \n        o1 = orient_naive(p1, q1, p2)\n        o2 = orient_naive(p1, q1, q2)\n        o3 = orient_naive(p2, q2, p1)\n        o4 = orient_naive(p2, q2, q1)\n\n        if o1 * o2  0 and o3 * o4  0:\n            return True\n\n        p1_f = (np.float64(p1[0]), np.float64(p1[1]))\n        q1_f = (np.float64(q1[0]), np.float64(q1[1]))\n        p2_f = (np.float64(p2[0]), np.float64(p2[1]))\n        q2_f = (np.float64(q2[0]), np.float64(q2[1]))\n            \n        if o1 == 0 and on_segment_naive(p1_f, q1_f, p2_f): return True\n        if o2 == 0 and on_segment_naive(p1_f, q1_f, q2_f): return True\n        if o3 == 0 and on_segment_naive(p2_f, q2_f, p1_f): return True\n        if o4 == 0 and on_segment_naive(p2_f, q2_f, q1_f): return True\n        \n        return False\n\n    # --- TEST CASE GENERATION ---\n\n    def generate_test_cases():\n        B = 2**60\n        \n        happy_path = []\n        for i in range(6):\n            happy_path.append((((i, 0), (i, 10)), ((i - 1, 5), (i + 1, 5))))\n        for i in range(6, 12):\n            happy_path.append((((i, 0), (i, 10)), ((i - 1, 15), (i + 1, 15))))\n\n        near_parallel = []\n        for i in range(16):\n            p1 = (B + i, B)\n            q1 = (B + i, B + 10)\n            p2 = (B + i + 10, B)\n            q2 = (B + i + 10, B + 10)\n            near_parallel.append(((p1, q1), (p2, q2)))\n            \n        shared_endpoint = []\n        for i in range(10):\n            p1, q1 = (i, i), (i + 5, i + 5)\n            p2, q2 = (i + 5, i + 5), (i + 10, i)\n            shared_endpoint.append(((p1, q1), (p2, q2)))\n\n        collinear = []\n        for _ in range(6): # Overlapping\n            collinear.append((((B, B), (B + 5, B)), ((B + 2, B), (B + 7, B))))\n        for _ in range(6): # Non-overlapping\n            collinear.append((((B, B), (B + 5, B)), ((B + 6, B), (B + 10, B))))\n            \n        return [happy_path, near_parallel, shared_endpoint, collinear]\n\n    # --- MAIN EXECUTION LOGIC ---\n\n    test_suites = generate_test_cases()\n    failure_rates = []\n    total_mismatches = 0\n    total_pairs = 0\n\n    for suite in test_suites:\n        mismatches = 0\n        num_pairs = len(suite)\n        if num_pairs == 0:\n            failure_rates.append(0.0)\n            continue\n            \n        for s1, s2 in suite:\n            exact_result = intersects_exact(s1, s2)\n            naive_result = intersects_naive(s1, s2)\n            if exact_result != naive_result:\n                mismatches += 1\n        \n        rate = mismatches / num_pairs if num_pairs > 0 else 0.0\n        failure_rates.append(rate)\n        \n        total_mismatches += mismatches\n        total_pairs += num_pairs\n        \n    overall_rate = total_mismatches / total_pairs if total_pairs > 0 else 0.0\n    failure_rates.append(overall_rate)\n\n    print(f\"[{','.join(map(str, failure_rates))}]\")\n\nsolve()\n```", "id": "3244227"}]}