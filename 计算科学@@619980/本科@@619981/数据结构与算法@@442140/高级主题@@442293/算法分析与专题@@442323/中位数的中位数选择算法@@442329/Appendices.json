{"hands_on_practices": [{"introduction": "“中位数的中位数”算法的优雅之处在于其递归设计。在分析其性能之前，我们必须首先掌握其核心机制：将输入数组分成小组，然后对这些小组的中位数进行递归处理。这个练习将带你检验对算法第一步的理解，通过一个简单的计算来确定中位数数组的大小，这是后续所有复杂分析的基础。", "problem": "考虑一种确定性的线性时间选择过程，通常称为中位数的中位数（Median-of-Medians, MoM）。给定一个包含 $n$ 个元素的输入数组，该过程将数组划分为大小固定为 $g=5$ 的连续分组，最后一个分组可能除外，它可能包含 $s$ 个元素，其中 $1 \\leq s \\leq 5$。对于每个大小为 $s$ 的分组，将其-th位数定义为该分组中第 $\\lceil s/2 \\rceil$ 小的元素，并从每个分组中收集一个这样的中位数，放入一个单独的辅助数组，记为 $M$。$M$ 的大小等于分区中形成的分组数量。\n\n严格依据上述定义，确定最小的整数 $n$，使得辅助数组 $M$ 的大小大于或等于分组大小 $g=5$。请提供 $n$ 的确切整数值。", "solution": "在尝试解答之前，将首先根据指定标准对问题进行验证。\n\n### 第一步：提取已知条件\n- 算法是中位数的中位数（MoM）选择过程。\n- 输入是一个包含 $n$ 个元素的数组。\n- 数组被划分为大小固定为 $g=5$ 的连续分组。\n- 最后一个分组的大小可以是 $s$，其中 $1 \\leq s \\leq 5$。\n- 大小为 $s$ 的分组的中位数是其第 $\\lceil s/2 \\rceil$ 小的元素。\n- 通过从每个分组中收集一个中位数来形成一个辅助数组 $M$。\n- $M$ 的大小等于形成的分组数量。\n- 目标是找到最小的整数 $n$，使得 $M$ 的大小大于或等于分组大小 $g=5$。\n\n### 第二步：使用提取的已知条件进行验证\n- **科学基础**：该问题描述了 BFPR（Blum-Floyd-Pratt-Rivest-Tarjan）中位数的中位数选择算法中的一个关键步骤，这是计算机科学和算法中的一个基本主题。定义和设置是标准的、科学合理的。\n- **适定性**：问题要求找到满足一个明确定义的数学条件的最小整数 $n$。预期存在一个唯一的整数解。\n- **客观性**：语言正式且无歧义，是算法分析问题的典型特征。\n- **完整性和一致性**：提供了所有必要的参数（$g=5$）和定义。问题是自包含的，没有矛盾。\n\n### 第三步：结论与行动\n问题被判定为**有效**。将提供解答。\n\n### 解答\n问题要求找到满足特定条件的最小整数 $n$。我们来分析这个条件的组成部分。\n\n输入数组有 $n$ 个元素。它被划分为大小为 $g=5$ 的分组。最后一个分组可能更小。设 $k$ 是创建的分组总数。分组数 $k$ 由元素总数 $n$ 和分组大小 $g$ 决定。具体来说，如果我们将 $n$ 个元素分成大小为 $g$ 的分组，分组的数量将是元素总数除以分组大小，向上取整。这在数学上用向上取整函数表示：\n$$k = \\left\\lceil \\frac{n}{g} \\right\\rceil$$\n\n根据问题陈述，辅助数组 $M$ 包含来自每个分组的一个中位数。因此，$M$ 的大小（我们可以表示为 $|M|$）等于分组的数量 $k$。\n$$|M| = k$$\n\n问题要求我们找到最小的整数 $n$，使得辅助数组 $M$ 的大小大于或等于分组大小 $g$。这个条件可以写成：\n$$|M| \\geq g$$\n\n代入 $|M|=k$ 和 $k=\\lceil n/g \\rceil$，我们得到不等式：\n$$\\left\\lceil \\frac{n}{g} \\right\\rceil \\geq g$$\n\n给定分组大小为 $g=5$。将这个值代入不等式：\n$$\\left\\lceil \\frac{n}{5} \\right\\rceil \\geq 5$$\n\n我们需要找到满足这个不等式的最小整数 $n$。让我们分析一下向上取整函数的性质。对于一个整数 $C$，表达式 $\\lceil x \\rceil \\geq C$ 等价于严格不等式 $x > C-1$。如果 $x$ 等于 $C-1$，$\\lceil x \\rceil$ 将是 $C-1$。为了使 $\\lceil x \\rceil$ 至少为 $C$，$x$ 必须严格大于 $C-1$。\n\n将此性质应用于我们的不等式，其中 $x = n/5$ 且 $C=5$：\n$$\\frac{n}{5} > 5 - 1$$\n$$\\frac{n}{5} > 4$$\n\n为了解出 $n$，我们将不等式两边乘以 $5$：\n$$n > 20$$\n\n由于 $n$ 代表数组中元素的数量，它必须是一个整数。问题要求满足条件 $n > 20$ 的最小整数 $n$。大于 $20$ 的最小整数是 $21$。\n\n因此，$n$ 的最小整数值是 $21$。\n\n我们可以验证这个结果：\n- 如果 $n=20$，分组数为 $k = \\lceil 20/5 \\rceil = \\lceil 4 \\rceil = 4$。条件 $k \\geq 5$ 不满足，因为 $4  5$。\n- 如果 $n=21$，分组数为 $k = \\lceil 21/5 \\rceil = \\lceil 4.2 \\rceil = 5$。条件 $k \\geq 5$ 满足，因为 $5=5$。\n\n因此，使得分组数至少为 $5$ 的最小整数 $n$ 确实是 $21$。", "answer": "$$\\boxed{21}$$", "id": "3250861"}, {"introduction": "“中位数的中位数”算法的强大之处在于其保证的最坏情况线性时间性能，这源于它即使在最不利的情况下也能确保一个“足够好”的划分。本练习挑战你逆向工程这一保证，通过构建一个精心设计的“对抗性”输入数组，你将具体地看到最坏情况的划分是如何产生的，并深刻理解算法性能界限为何成立。", "problem": "考虑一种确定性的线性时间选择算法，通常称为中位数的中位数（median-of-medians）方法。该算法的运作方式是：将输入数组划分为等大的组，计算每组的中位数，选择这些中位数的中位数作为主元（pivot），并围绕该主元进行分区；然后根据所需顺序统计量的秩（rank），在其中一侧进行递归。对于大小为 $5$ 的分组，该算法正确性和运行时间的分析取决于计算保证严格小于和严格大于被选为中位数的中位数的主元的元素数量。\n\n你需要构造一个大小为 $n=25$、包含不同整数的显式输入数组 $A$，其排列方式要能迫使算法的分区步骤，在按给定数组顺序进行大小为 $5$ 的连续块分组的标准情况下，产生可能的最大递归子问题。你的构造必须遵循以下结构性约束：\n\n- 将 $A$ 按数组顺序划分为五个大小为 $5$ 的连续组 $G_1, G_2, G_3, G_4, G_5$。\n- 在每个 $G_i$ 中，中位数（组中第三小的元素）必须是明确定义的，并且在各组之间互不相同。\n- 中位数的中位数主元 $p$ 必须是五个组中位数的中位数，即通过对这五个中位数排序并取第三小的值得到。\n\n设计 $A$，使得在围绕 $p$ 进行分区后，严格小于 $p$ 的元素数量在满足算法分组和主元选择所隐含的保证的前提下被最小化，而剩余元素则被对抗性地放置，以最大化较大递归子数组的大小。明确给出你构造的五个组 $G_1, G_2, G_3, G_4, G_5$，并证明中位数的中位数主元确实如预期那样是 $p$。\n\n最后，计算你的构造在围绕 $p$ 进行分区步骤后所产生的较大递归子数组的确切大小。仅报告此大小作为你的最终数值答案。你的数值答案应当是精确的，不要四舍五入。", "solution": "所述问题在形式上是合理的、自洽的，并且基于计算机科学中算法分析的既定原则。它就中位数的中位数选择算法在特定参数下的最坏情况行为提出了一个明确定义的问题。因此，该问题是有效的，可以构造出严谨的解。\n\n目标是构造一个包含 $n=25$ 个不同整数的数组 $A$，当使用分组大小为 $5$ 的中位数的中位数算法处理时，能够最大化递归调用中两个子数组中较大的那个的规模。这相当于找到一个对抗性输入，迫使算法产生其保证范围内最不平衡的分区。\n\n该算法的步骤如下：\n1.  大小为 $n=25$ 的输入数组 $A$ 被划分为 $\\lceil n/5 \\rceil = \\lceil 25/5 \\rceil = 5$ 个连续的组 $G_1, G_2, G_3, G_4, G_5$，每组大小为 $5$。\n2.  对每个组 $G_i$，计算其中位数 $m_i$。这将产生一个包含 $5$ 个中位数的集合 $\\{m_1, m_2, m_3, m_4, m_5\\}$。\n3.  算法找到这些中位数的中位数，我们将其表示为主元 $p$。这是通过对这些中位数进行排序并选择中间元素来完成的。\n4.  原始数组 $A$ 围绕主元 $p$ 被划分为两个子数组：一个包含严格小于 $p$ 的元素，另一个包含严格大于 $p$ 的元素。\n5.  算法在包含所需顺序统计量的子数组上进行递归。\n\n为了最大化较大递归子数组的大小，我们必须使分区尽可能地不平衡。让我们分析分区大小的理论界限。设中位数集合为 $M = \\{m_1, m_2, m_3, m_4, m_5\\}$。设排序后的中位数为 $m_{(1)} \\le m_{(2)} \\le m_{(3)} \\le m_{(4)} \\le m_{(5)}$。主元是 $p = m_{(3)}$。\n\n考虑保证小于或等于 $p$ 的元素数量：\n- 有 $\\lceil 5/2 \\rceil = 3$ 个中位数小于或等于 $p$，即 $m_{(1)}$、$m_{(2)}$ 和 $p=m_{(3)}$。\n- 对于这 $3$ 个中位数中的每一个，其中位数本身以及其所在组内的两个更小的元素都小于或等于该中位数。由于这 $3$ 个中位数都小于或等于 $p$，因此相应的 $3 \\times 3 = 9$ 个元素都小于或等于 $p$。\n- 由于数组 $A$ 的所有元素都是不同的，这 $9$ 个元素也是不同的。因此，在 $A$ 中至少有 $9$ 个元素小于或等于 $p$。这意味着严格小于 $p$ 的元素数量至少为 $9 - 1 = 8$。\n\n考虑保证大于或等于 $p$ 的元素数量：\n- 根据对称性论证，有 $\\lceil 5/2 \\rceil = 3$ 个中位数大于或等于 $p$，即 $p=m_{(3)}$、$m_{(4)}$ 和 $m_{(5)}$。\n- 对于这 $3$ 个组中的每一个，其中位数和两个更大的元素都大于或等于该中位数。因此，这 $3 \\times 3 = 9$ 个元素都大于或等于 $p$。\n- 这保证了严格大于 $p$ 的元素数量至少为 $8$。\n\n围绕 $p$ 对 $A$ 进行分区，会产生一个由小于 $p$ 的元素组成的子数组（大小为 $|S_|$）和一个由大于 $p$ 的元素组成的子数组（大小为 $|S_>|$）。我们有 $|S_| \\ge 8$ 和 $|S_>| \\ge 8$。由于 $|S_| + |S_>| = n-1 = 24$，如果一侧被最小化，另一侧则被最大化。任一分区的最小大小为 $8$。如果 $|S_|=8$，则 $|S_>| = 24 - 8 = 16$。如果 $|S_>|=8$，则 $|S_|=16$。无论哪种情况，较大递归子数组可能的最大大小都是 $16$。\n\n我们现在构造一个实现这种 $8/16$ 分割的显式数组 $A$。我们将使用从 $1$ 到 $25$ 的不同整数。为了创建最不平衡的分区，我们将设计这些组，使得严格小于主元 $p$ 的元素数量被最小化到 $8$。这迫使主元为 $p=9$。\n\n设五个组为 $G_1, G_2, G_3, G_4, G_5$。我们如下构造它们：\n\n-   设两个组，比如 $G_1$ 和 $G_2$，其中位数小于 $p=9$。为了最小化小编号元素的数量，我们尽可能地用大编号元素来填充它们。\n    -   $G_1 = \\{13, 1, 5, 12, 2\\}$：排序后的元素为 $\\{1, 2, 5, 12, 13\\}$。中位数为 $m_1 = 5$。元素 $\\{1, 2, 5\\}$ 小于 $p=9$。元素 $\\{12, 13\\}$ 大于 $p=9$。\n    -   $G_2 = \\{15, 3, 6, 14, 4\\}$：排序后的元素为 $\\{3, 4, 6, 14, 15\\}$。中位数为 $m_2 = 6$。元素 $\\{3, 4, 6\\}$ 小于 $p=9$。元素 $\\{14, 15\\}$ 大于 $p=9$。\n\n-   设一个组，比如 $G_3$，其中位数为为主元 $p=9$。\n    -   $G_3 = \\{11, 7, 9, 10, 8\\}$：排序后的元素为 $\\{7, 8, 9, 10, 11\\}$。中位数为 $m_3 = 9$。元素 $\\{7, 8\\}$ 小于 $p=9$。元素 $9$ 是主元。元素 $\\{10, 11\\}$ 大于 $p=9$。\n\n-   设余下的两个组，$G_4$ 和 $G_5$，其中位数大于 $p=9$。为了创建对抗性情况，这些组中的所有元素都必须大于 $p=9$。\n    -   $G_4 = \\{18, 16, 20, 17, 19\\}$：排序后的元素为 $\\{16, 17, 18, 19, 20\\}$。中位数为 $m_4 = 18$。所有 $5$ 个元素都大于 $p=9$。\n    -   $G_5 = \\{23, 21, 25, 22, 24\\}$：排序后的元素为 $\\{21, 22, 23, 24, 25\\}$。中位数为 $m_5 = 23$。所有 $5$ 个元素都大于 $p=9$。\n\n主元的论证：\n中位数的集合是 $M = \\{m_1, m_2, m_3, m_4, m_5\\} = \\{5, 6, 9, 18, 23\\}$。\n该集合的中位数是排序后列表 $(5, 6, 9, 18, 23)$ 中的第 $3$ 个元素，即 $9$。因此，算法选择的主元确实是 $p=9$，与构造的意图一致。\n\n围绕 $p=9$ 进行分区：\n完整的数组 $A$ 由这些组串联而成。 $A$ 中所有整数的集合是 $\\{1, 2, \\dots, 25\\}$。\n-   $A$ 中严格小于 $p=9$ 的元素是：来自 $G_1$ 的 $\\{1, 2, 5\\}$；来自 $G_2$ 的 $\\{3, 4, 6\\}$；以及来自 $G_3$ 的 $\\{7, 8\\}$。这就得到了集合 $\\{1, 2, 3, 4, 5, 6, 7, 8\\}$。这个子数组的大小是 $8$。\n-   $A$ 中严格大于 $p=9$ 的元素是：来自 $G_1$ 的 $\\{12, 13\\}$；来自 $G_2$ 的 $\\{14, 15\\}$；来自 $G_3$ 的 $\\{10, 11\\}$；来自 $G_4$ 的 $\\{16, 17, 18, 19, 20\\}$；以及来自 $G_5$ 的 $\\{21, 22, 23, 24, 25\\}$。这就得到了集合 $\\{10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25\\}$。这个子数组的大小是 $16$。\n\n两个递归子问题的规模将是 $8$ 和 $16$。两者中较大的那个规模为 $16$。我们的构造成功地产生了最大程度不平衡的分区。\n\n因此，较大递归子数组的大小是 $16$。", "answer": "$$\\boxed{16}$$", "id": "3250877"}, {"introduction": "检验是否真正理解一个算法的试金石，是能否对其进行修改和扩展以解决新问题。本练习要求你改编“中位数的中位数”算法，使其能够在一个偶数长度的数组中同时找到两个中位数，并且保持令人称道的 $O(n)$ 时间复杂度。这需要你进行严谨的分类讨论，从而加深对算法递归逻辑和效率的认识。", "problem": "给定一个长度为偶数 $n$ 的未排序数组 $A$，要求您使用对确定性选择算法（通常称为 Blum–Floyd–Pratt–Rivest–Tarjan (BFPRT) 算法）的一种修改，在最坏情况时间 $O(n)$ 内计算出 $A$ 的两个中位数。在零基索引下，这两个中位数被定义为在 $A$ 的排序顺序中秩为 $k_1 = \\frac{n}{2} - 1$ 和 $k_2 = \\frac{n}{2}$ 的元素。计算必须在不对 $A$ 进行端到端排序的情况下执行。\n\n使用的基本原理：\n- 顺序统计量的定义：对于一个长度为 $n$ 的数组 $A$，秩为 $k$ 的元素是 $A$ 中第 $k$ 小的元素。\n- 通过 5 元素分组进行确定性主元选择：将 $A$ 划分为连续的 5 元素组，计算每组的中位数，并递归地确定这些中位数的中位数作为主元。\n- 三路划分不变量：围绕主元值 $p$ 进行划分后，所考虑的数组区域被分割为一个严格小于 $p$ 的元素的左侧区域、一个等于 $p$ 的元素的相等区域，以及一个严格大于 $p$ 的元素的右侧区域。\n\n设计与推导要求：\n- 从上述基本原理出发，推导出一个修改后的选择过程，该过程能够同时定位秩 $k_1$ 和 $k_2$，而无需对输入进行排序。确保您的推导仅依赖于所述的基本原理和原则，如基于比较的划分和递归，并且不依赖于未经证实的捷径。\n- 您的算法必须通过使用中位数的中位数主元选择来保证最坏情况时间 $O(n)$，并证明在每个递归步骤中，当目标秩区间 $[k_1, k_2]$ 与主元划分创建的相等区域相交时，最多只会处理一个子问题。请明确论证为何此性质能保证 $O(n)$ 的时间界限。\n\n实现要求：\n- 实现一个函数，对于给定的偶数长度数组 $A$，返回一个数对 $[m_{\\text{lo}}, m_{\\text{hi}}]$，其中 $m_{\\text{lo}}$ 是秩为 $k_1$ 的元素，$m_{\\text{hi}}$ 是秩为 $k_2$ 的元素。\n- 实现必须使用大小为 5 的分组的中位数的中位数主元策略和三路划分方案。对于小规模子问题，通过对子数组排序并取相对于子数组的 $k_1$ 和 $k_2$ 位置上的元素来进行直接计算。\n- 所有数组都是纯粹的数学序列；不涉及物理单位。\n\n测试套件：\n使用以下数组（每个长度均为偶数）作为测试用例，为每个数组计算中位数对 $[m_{\\text{lo}}, m_{\\text{hi}}]$：\n1. $A_1 = [12,7,3,9,1,5,8,6,10,2]$，$n = 10$，$k_1 = 4$，$k_2 = 5$。\n2. $A_2 = [4,1]$，$n = 2$，$k_1 = 0$，$k_2 = 1$。\n3. $A_3 = [5,5,5,5]$，$n = 4$，$k_1 = 1$，$k_2 = 2$。\n4. $A_4 = [-2,-1,-3,-4,-5,-6,-7,-8]$，$n = 8$，$k_1 = 3$，$k_2 = 4$。\n5. $A_5 = [0,1,2,3,4,5]$，$n = 6$，$k_1 = 2$，$k_2 = 3$。\n6. $A_6 = [2,8,1,7,3,6,4,5]$，$n = 8$，$k_1 = 3$，$k_2 = 4$。\n\n答案规范：\n- 对于每个测试用例，输出必须是一个包含两个整数的列表 $[m_{\\text{lo}}, m_{\\text{hi}}]$，代表下中位数和上中位数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是对应一个测试用例的数对（例如，$[[m_{\\text{lo}_1},m_{\\text{hi}_1}],[m_{\\text{lo}_2},m_{\\text{hi}_2}],\\dots]$）。", "solution": "用户希望在一个长度为偶数 $n$ 的未排序数组 $A$ 中找到两个中位数。这两个中位数由它们的零基索引秩 $k_1 = \\frac{n}{2} - 1$ 和 $k_2 = \\frac{n}{2}$ 定义。解决方案必须是对 Blum–Floyd–Pratt–Rivest–Tarjan (BFPRT) 确定性选择算法（通常称为中位数的中位数算法）的修改，并且必须达到 $O(n)$ 的最坏情况时间复杂度。\n\n**算法推导**\n\n问题的核心是将一个设计用于查找单个秩为 $k$ 的元素的选择算法，调整为能够同时查找两个相邻秩 $k_1$ 和 $k_2$ 的元素，而不降低最坏情况下的线性时间性能。一个朴素的方法是运行两次 $O(n)$ 的 BFPRT 算法，一次针对 $k_1$，一次针对 $k_2$，总时间将是 $O(n) + O(n) = O(n)$。但是，问题要求的是一个单一的、修改过的、能够“同时定位两个秩”的过程，这表明需要一种更集成的方法。\n\n我们推导这样一个过程，我们称之为 `DualSelect`。这个过程将依赖 BFPRT 算法的基本组成部分：通过中位数的中位数保证“良好”的主元选择和递归划分。\n\n1.  **高层策略**：该算法将是一个递归的分治过程。在每一步，它将选择一个主元元素 $p$ 并将当前子数组划分为三个区域：$L$（元素  $p$）、$E$（元素 = $p$）和 $R$（元素 > $p$）。然后，算法根据两个目标秩 $k_1$ 和 $k_2$ 相对于这三个区域的位置来决定下一步行动。\n\n2.  **主元选择**：为了保证 $O(n)$ 的最坏情况时间复杂度，主元 $p$ 必须通过 BFPRT 算法（即中位数的中位数方法，分组大小为5）来选择。这确保了划分后的子问题大小至多是原问题大小的一个固定比例（约 $7n/10$）。\n\n3.  **递归逻辑**：在围绕主元 $p$ 进行三路划分后，我们得到三个区域 $L$（大小为 $|L|$）、$E$（大小为 $|E|$）和 $R$（大小为 $|R|$）。设子数组内元素的数量为 $m$。\n    *   **情况 1：两个秩都在 $L$ 区间内。** 如果 $k_2  |L|$，那么两个中位数都在 $L$ 区域。我们对 $L$ 区域进行一次递归调用 `DualSelect(A, ..., k1, k2)`。\n    *   **情况 2：两个秩都在 $R$ 区间内。** 如果 $k_1 \\ge |L| + |E|$，那么两个中位数都在 $R$ 区域。我们对 $R$ 区域进行一次递归调用，但需要更新秩为 $k_1' = k_1 - (|L| + |E|)$ 和 $k_2' = k_2 - (|L| + |E|)$。\n    *   **情况 3：秩跨越了区域边界。** 这是最关键的情况，它避免了两次独立的递归调用。\n        *   如果 $k_1  |L|$ 且 $|L| \\le k_2  |L|+|E|$（$k_1$ 在 $L$ 中，$k_2$ 在 $E$ 中），那么下中位数 $m_{\\text{lo}}$ 在 $L$ 中，上中位数 $m_{\\text{hi}}$ 就是主元 $p$。我们只需对 $L$ 区域进行一次标准的 BFPRT `Select` 调用来找到秩为 $k_1$ 的元素。\n        *   如果 $|L| \\le k_1  |L|+|E|$ 且 $k_2 \\ge |L|+|E|$（$k_1$ 在 $E$ 中，$k_2$ 在 $R$ 中），那么下中位数 $m_{\\text{lo}}$ 就是主元 $p$，上中位数 $m_{\\text{hi}}$ 在 $R$ 中。我们只需对 $R$ 区域进行一次标准的 BFPRT `Select` 调用来找到秩为 $k_2 - (|L| + |E|)$ 的元素。\n        *   如果两个秩 $k_1, k_2$ 都在 $E$ 区域内，那么两个中位数都是主元 $p$。\n        *   因为 $k_2 = k_1 + 1$，$k_1$ 在 $L$ 中而 $k_2$ 在 $R$ 中的情况是不可能的，因为它们之间至少隔着一个 $E$ 区域（除非 $E$ 为空，但划分逻辑也能正确处理）。\n\n4.  **时间复杂度分析**：在每一步，算法的开销包括：选择主元（$T(m/5)$）、划分（$O(m)$）和一个递归调用。在情况1和2中，递归调用的问题规模最多为 $7m/10$。在情况3中，我们进行一次标准的 `Select` 调用，其成本也服从相同的线性递归关系。因此，总的递归关系保持为 $T(n) \\le T(n/5) + T(7n/10) + O(n)$，这保证了总时间复杂度为 $O(n)$。\n\n**具体实现**\n\n以下是针对给定测试用例的计算结果。\n\n1.  **A1 = [12,7,3,9,1,5,8,6,10,2]**:\n    - $n=10$, $k_1=4, k_2=5$。\n    - 排序后: `[1,2,3,5,6,7,8,9,10,12]`。\n    - 秩为4的元素是 6，秩为5的元素是 7。\n    - 结果: `[6, 7]`\n\n2.  **A2 = [4,1]**:\n    - $n=2$, $k_1=0, k_2=1$。\n    - 排序后: `[1,4]`。\n    - 结果: `[1, 4]`\n\n3.  **A3 = [5,5,5,5]**:\n    - $n=4$, $k_1=1, k_2=2$。\n    - 排序后: `[5,5,5,5]`。\n    - 结果: `[5, 5]`\n\n4.  **A4 = [-2,-1,-3,-4,-5,-6,-7,-8]**:\n    - $n=8$, $k_1=3, k_2=4$。\n    - 排序后: `[-8,-7,-6,-5,-4,-3,-2,-1]`。\n    - 秩为3的元素是 -5，秩为4的元素是 -4。\n    - 结果: `[-5, -4]`\n\n5.  **A5 = [0,1,2,3,4,5]**:\n    - $n=6$, $k_1=2, k_2=3$。\n    - 排序后: `[0,1,2,3,4,5]`。\n    - 秩为2的元素是 2，秩为3的元素是 3。\n    - 结果: `[2, 3]`\n\n6.  **A6 = [2,8,1,7,3,6,4,5]**:\n    - $n=8$, $k_1=3, k_2=4$。\n    - 排序后: `[1,2,3,4,5,6,7,8]`。\n    - 秩为3的元素是 4，秩为4的元素是 5。\n    - 结果: `[4, 5]`\n\n综上，所有测试用例的预期输出汇总为 `[[6,7],[1,4],[5,5],[-5,-4],[2,3],[4,5]]`。", "answer": "```python\nimport numpy as np\n\n# A small cutoff for switching to sorting-based selection\n# is a standard optimization for selection algorithms.\nSELECTION_CUTOFF = 10\n\ndef _partition3(A, left, right, pivot_val):\n    \"\"\"\n    Performs a three-way partition on the subarray A[left...right]\n    around a given pivot value.\n    Rearranges the subarray into three parts:\n    - Elements less than pivot_val\n    - Elements equal to pivot_val\n    - Elements greater than pivot_val\n    Returns a tuple (i, j) where A[i...j] is the equal partition.\n    \"\"\"\n    lt, gt = left, right\n    i = left\n    while i = gt:\n        if A[i]  pivot_val:\n            A[lt], A[i] = A[i], A[lt]\n            lt += 1\n            i += 1\n        elif A[i] > pivot_val:\n            A[gt], A[i] = A[i], A[gt]\n            gt -= 1\n        else:\n            i += 1\n    return lt, gt\n\ndef _select(A, left, right, k):\n    \"\"\"\n    Finds the k-th smallest element in A[left...right] (0-indexed)\n    using the BFPRT (median-of-medians) algorithm.\n    This function is guaranteed to run in worst-case O(n) time.\n    \"\"\"\n    while True:\n        if right - left + 1 = SELECTION_CUTOFF:\n            sub_array = A[left : right + 1]\n            sub_array.sort()\n            return sub_array[k]\n\n        m = right - left + 1\n        num_groups = (m + 4) // 5\n        medians = np.empty(num_groups, dtype=A.dtype)\n\n        for i in range(num_groups):\n            start = left + i * 5\n            end = min(start + 5, right + 1)\n            group = A[start:end]\n            group.sort()\n            medians[i] = group[len(group) // 2]\n        \n        pivot_val = _select(medians, 0, len(medians) - 1, len(medians) // 2)\n\n        i, j = _partition3(A, left, right, pivot_val)\n\n        s_L = i - left\n        s_E = j - i + 1\n\n        if k  s_L:\n            right = i - 1\n        elif k >= s_L + s_E:\n            k -= (s_L + s_E)\n            left = j + 1\n        else:\n            return pivot_val\n\ndef _dual_select(A, left, right, k1, k2):\n    \"\"\"\n    Finds the k1-th and k2-th smallest elements in A[left...right]\n    simultaneously in worst-case O(n) time.\n    \"\"\"\n    while True:\n        m = right - left + 1\n        if m = SELECTION_CUTOFF:\n            sub_array = A[left : right + 1]\n            sub_array.sort()\n            return [sub_array[k1], sub_array[k2]]\n\n        num_groups = (m + 4) // 5\n        medians = np.empty(num_groups, dtype=A.dtype)\n\n        for i in range(num_groups):\n            start = left + i * 5\n            end = min(start + 5, right + 1)\n            group = A[start:end]\n            group.sort()\n            medians[i] = group[len(group) // 2]\n        \n        pivot_val = _select(medians, 0, len(medians) - 1, len(medians) // 2)\n        \n        i, j = _partition3(A, left, right, pivot_val)\n\n        s_L = i - left\n        s_E = j - i + 1\n\n        if k2  s_L: # Both ranks are in the left partition\n            right = i - 1\n            # Relative ranks k1, k2 do not change\n        elif k1 >= s_L + s_E: # Both ranks are in the right partition\n            k1 -= (s_L + s_E)\n            k2 -= (s_L + s_E)\n            left = j + 1\n        else: # Ranks straddle partitions or are inside E\n            k1_in_L = k1  s_L\n            k2_in_L = k2  s_L\n            \n            k1_in_E = s_L = k1  s_L + s_E\n            k2_in_E = s_L = k2  s_L + s_E\n            \n            k1_in_R = k1 >= s_L + s_E\n            k2_in_R = k2 >= s_L + s_E\n\n            if k1_in_E and k2_in_E:\n                return [pivot_val, pivot_val]\n            elif k1_in_L and k2_in_E:\n                m_lo = _select(A, left, i - 1, k1)\n                m_hi = pivot_val\n                return [m_lo, m_hi]\n            elif k1_in_E and k2_in_R:\n                m_lo = pivot_val\n                m_hi = _select(A, j + 1, right, k2 - (s_L + s_E))\n                return [m_lo, m_hi]\n            else: # This case k1_in_L and k2_in_R is impossible since k2=k1+1\n                  # Fallback to two separate calls for robustness, though not expected\n                m_lo = _select(A, left, right, k1)\n                m_hi = _select(A, left, right, k2)\n                return [m_lo, m_hi]\n\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the specified test cases.\n    \"\"\"\n    test_cases = [\n        np.array([12, 7, 3, 9, 1, 5, 8, 6, 10, 2]),\n        np.array([4, 1]),\n        np.array([5, 5, 5, 5]),\n        np.array([-2, -1, -3, -4, -5, -6, -7, -8]),\n        np.array([0, 1, 2, 3, 4, 5]),\n        np.array([2, 8, 1, 7, 3, 6, 4, 5])\n    ]\n\n    results = []\n    for A in test_cases:\n        n = len(A)\n        # We work on a copy to prevent modifying the original test case arrays\n        A_copy = np.copy(A)\n        \n        k1 = n // 2 - 1\n        k2 = n // 2\n        \n        medians = _dual_select(A_copy, 0, n - 1, k1, k2)\n        results.append(medians)\n    \n    # Format the output string exactly as specified, without spaces\n    formatted_results = [str(r).replace(' ', '') for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3250889"}]}