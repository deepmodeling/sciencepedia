{"hands_on_practices": [{"introduction": "我们常说追加操作的摊还成本是常数。但这对于单个元素意味着什么呢？本练习将视角从总体成本转移到单个元素的“生命历程”，特别是经历复制次数最多的那个元素。通过计算一个元素可能被复制的最大次数，你将对重置大小的成本如何在数组的生命周期内分布建立更具体的直觉。[@problem_id:3206830]", "problem": "考虑一个初始容量为 $1$ 且为空的动态数组。该数组支持追加操作，在有可用容量时，该操作以常数时间在末尾放置一个新元素。当追加操作发现数组已满时，数组会执行一次调整大小（resize）：它会分配一个新的连续内存块，其容量恰好是当前容量的两倍，然后将所有当前元素从旧块按顺序复制到新块中，之后再追加新元素。假设不发生删除操作。定义元素的“复制”为该元素在调整大小过程中的一次移动（元素在追加时的初始放置不计为复制）。\n\n在执行了恰好 $N \\ge 1$ 次追加操作后，请确定，在这 $N$ 次追加操作序列中，任何单个元素因调整大小而被复制的最大可能次数，并以 $N$ 的封闭形式表达式表示。请给出精确表达式作为答案；不需要数值近似或四舍五入。", "solution": "用户希望我解决一个关于动态数组的问题。\n\n### 步骤 1：提取已知条件\n- 初始数组容量：$1$。\n- 初始数组大小：$0$。\n- 追加操作：在末尾放置一个新元素。\n- 调整大小的条件：当试图向一个已满的数组追加元素时发生。\n- 调整大小的机制：\n    1. 新分配的容量为当前容量的 $2 \\times$。\n    2. 所有现有元素被复制到新块中。\n    3. 然后追加新元素。\n- “复制”的定义：元素在调整大小过程中的移动。元素的初始插入不计为复制。\n- 操作总数：执行恰好 $N$ 次追加操作，其中 $N \\ge 1$。\n- 目标：确定任何单个元素被复制的最大可能次数。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题是算法分析中的一个标准练习，具体涉及动态数组（也称为向量或 ArrayList）的摊销分析。所描述的模型（在调整大小时将容量加倍）是一种经典的实现策略。该问题在科学和数学上是合理的。\n- **适定性**：该问题是适定的。初始条件、操作规则以及待求量都已精确指定。存在唯一的、确定性的解。\n- **客观性**：问题陈述是客观的，并使用了正式、明确的语言。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。这是计算机科学领域中关于数据结构和算法的一个明确定义的问题。我现在将进行正式求解。\n\n### 解题推导\n问题要求在 $N$ 次追加操作后，任何单个元素被复制的最大次数。为了使一个元素的复制次数最大化，我们应该考虑在数组中存在时间最长的元素，因为它将经历其插入后发生的每一次调整大小操作。第一个被追加的元素，我们称之为 $E_1$，满足这个条件。因此，任何元素的最大复制次数就是 $E_1$ 被复制的次数。\n\n我们来分析动态数组的状态，特别是它的容量。容量（我们用 $C$ 表示）仅在调整大小操作期间发生变化。根据题目描述，初始容量为 $C_0 = 1$。一次调整大小操作会将容量加倍。因此，数组可能具有的容量序列是 $2$ 的幂：$1, 2, 4, 8, \\dots, 2^k$，其中 $k$ 为非负整数。容量为 $C=2^k$ 的数组最多可以容纳 $2^k$ 个元素。\n\n当试图向一个已满的数组追加元素时，会触发调整大小。也就是说，如果数组的容量为 $C$ 并且已经包含 $C$ 个元素，下一次追加操作将导致调整大小。\n\n我们来追踪一下这个过程：\n1.  **初始状态**：容量 $C=1$，大小 $S=0$。\n2.  **第 1 次追加**：我们追加元素 $E_1$。数组有空间，因此不发生调整大小。状态变为 $C=1$, $S=1$。$E_1$ 的复制次数为 $0$。\n3.  **第 2 次追加**：我们尝试追加 $E_2$。数组已满 ($S=C=1$)。触发调整大小。\n    - 分配一个容量为 $2 \\times 1 = 2$ 的新数组。\n    - 元素 $E_1$ 从旧数组复制到新数组。这是 $E_1$ 的**第一次复制**。\n    - 追加元素 $E_2$。\n    - 状态变为 $C=2$, $S=2$。\n4.  **第 3 次追加**：我们尝试追加 $E_3$。数组已满 ($S=C=2$)。触发调整大小。\n    - 分配一个容量为 $2 \\times 2 = 4$ 的新数组。\n    - 元素 $E_1$ 和 $E_2$ 被复制。这是 $E_1$ 的**第二次复制**。\n    - 追加元素 $E_3$。\n    - 状态变为 $C=4$, $S=3$。\n5.  **第 4 次追加**：我们追加 $E_4$。数组未满 ($S=3, C=4$)。不调整大小。状态变为 $C=4, S=4$。$E_1$ 仍然被复制了两次。\n6.  **第 5 次追加**：我们尝试追加 $E_5$。数组已满 ($S=C=4$)。触发调整大小，容量变为 $2 \\times 4 = 8$。这涉及到 $E_1$ 的**第三次复制**。\n\n通过此分析可以清楚地看到，$E_1$ 在其初始放置后发生的每一次调整大小事件中都会被复制。因此，$E_1$ 被复制的次数等于在 $N$ 次追加操作中发生调整大小的总次数。\n\n从容量 $2^k$ 到 $2^{k+1}$ 的调整大小是由第 $(2^k+1)$ 次追加操作触发的。元素 $E_1$ 存在于所有从初始容量 $2^0$ 开始增加容量的调整大小操作中。\n\n经过 $N$ 次追加后，数组必须能容纳 $N$ 个元素。数组的容量 $C_N$ 必须至少为 $N$。由于容量是 2 的幂，所以 $C_N$ 必须是大于或等于 $N$ 的最小的 2 的幂。设此容量为 $C_N = 2^k$。\n$C_N = 2^k \\ge N$ 且 $k$ 是满足该条件的最小整数，这意味着之前的容量 $2^{k-1}$ 是不够的，即 $2^{k-1}  N$。\n所以，我们得到不等式：\n$$2^{k-1}  N \\le 2^k$$\n这个不等式对 $N  1$ 成立。如果 $N=1$，容量是 $1=2^0$，所以 $k=0$。\n对于 $N  1$，我们可以对不等式两边取以 2 为底的对数：\n$$\\log_2(2^{k-1})  \\log_2(N) \\le \\log_2(2^k)$$\n$$k-1  \\log_2(N) \\le k$$\n这个关系是向上取整函数（ceiling function）的定义。因此，对于 $N  1$，最终容量的指数 $k$ 由下式给出：\n$$k = \\lceil \\log_2(N) \\rceil$$\n我们来验证 $N=1$ 的情况。最终容量是 $1 = 2^0$，所以 $k=0$。该公式给出 $\\lceil \\log_2(1) \\rceil = \\lceil 0 \\rceil = 0$。所以该公式对所有 $N \\ge 1$ 都成立。\n\n数组为达到容量 $2^k$ 所必须经历的容量序列是 $2^0, 2^1, 2^2, \\ldots, 2^k$。\n这个序列中从 $2^j$ 到 $2^{j+1}$ 的每一步（其中 $j=0, 1, \\ldots, k-1$）都对应一次调整大小操作。\n第一个元素 $E_1$ 从容量为 $C=2^0$ 时就存在于数组中。它将在随后的每一次调整大小中被复制。这些调整大小操作是：\n- 从 $2^0 \\to 2^1$\n- 从 $2^1 \\to 2^2$\n- ...\n- 从 $2^{k-1} \\to 2^k$\n\n这些调整大小事件的总数是 $(k-1) - 0 + 1 = k$。\n因此，任何单个元素被复制的最大次数是 $k$。代入 $k$ 的表达式：\n$$\\text{Maximum copies} = \\lceil \\log_2(N) \\rceil$$\n这个表达式是关于 $N$ 的封闭形式，并且对所有 $N \\ge 1$ 都有效。", "answer": "$$\\boxed{\\lceil \\log_2(N) \\rceil}$$", "id": "3206830"}, {"introduction": "动态数组追加操作具有常数摊还成本的证明，依赖于一个关键假设：复制 $k$ 个元素的成本与 $k$ 成正比。如果这个假设不成立会怎样？本题通过引入二次方复制成本（$k^2$）来挑战这一基础，迫使你重新进行聚合分析。这将加深你对标准模型为何高效的理解，并揭示摊还分析结果对底层成本模型的敏感性。[@problem_id:3206794]", "problem": "给定一个连续存储元素的动态数组。该数组初始为空，初始容量为 $1$。每当一次追加操作会超出当前容量时，数组会通过分配一个容量为当前容量 $2$ 倍的新数组来进行大小调整，然后按顺序将所有现有元素迁移到新数组中。\n\n成本模型如下：每次将单个元素写入可用槽位的追加操作成本为 $1$ 个单位；当发生大小调整时，将 $k$ 个现有元素复制到新数组中的成本为 $k^2$ 个单位（这不包括触发此次大小调整的追加操作本身的 $1$ 单位成本）。\n\n你需要执行恰好 $n$ 次追加操作，其中 $n$ 是 $2$ 的幂（即，对于某个整数 $t \\ge 0$，有 $n = 2^t$）。\n\n仅使用“单次操作的摊销成本等于总成本除以操作次数”这一定义以及指定的大小调整策略，推导出每次追加操作的精确摊销成本，并表示为 $n$ 的函数。请将你的最终答案以一个关于 $n$ 的单一简化封闭形式解析表达式给出。最终答案中不要包含单位。无需进行四舍五入。", "solution": "问题要求计算对一个动态数组执行 $n$ 次追加操作序列中，单次追加操作的精确摊销成本，其中 $n$ 是 $2$ 的幂（$n = 2^t$，对于某个整数 $t \\ge 0$）。摊销成本定义为总成本除以操作次数。\n\n首先，我们必须计算执行 $n$ 次追加操作的总成本。总成本 $C_{total}$ 是两个部分之和：所有追加操作的总成本和所有调整大小并复制操作的总成本。\n\n成本模型规定如下：\n1.  基本追加成本：每次将元素写入可用槽位的追加操作成本为 $1$ 个单位。\n2.  调整大小成本：当触发大小调整时，复制 $k$ 个现有元素的成本为 $k^2$ 个单位。这不包括触发调整的追加操作本身的 $1$ 单位成本。\n\n总基本追加成本：\n由于总共有 $n$ 次追加操作，每次基本成本为 $1$，所以总基本追加成本为 $n \\times 1 = n$。\n\n总调整大小成本：\n当尝试向一个已满的数组追加元素时，会发生大小调整。数组的初始容量为 $1$。每次调整大小时，容量会加倍。\n让我们追踪数组的状态，特别是其大小（元素数量）和容量。\n-   最初，大小为 $0$，容量为 $1$。\n-   第 $1$ 次追加：大小变为 $1$。数组已满。\n-   第 $2$ 次追加：由于大小（$1$）等于容量（$1$），这会触发第一次大小调整。需要复制的元素数量为 $k=1$。新容量将为 $2 \\times 1 = 2$。此次复制的成本为 $k^2 = 1^2 = 1$。\n-   第 $3$ 次追加：此时大小为 $2$，容量为 $2$。这会触发一次大小调整。需要复制的元素数量为 $k=2$。新容量将为 $2 \\times 2 = 4$。此次复制的成本为 $k^2 = 2^2 = 4$。\n-   第 $5$ 次追加：此时大小为 $4$，容量为 $4$。这会触发一次大小调整。需要复制的元素数量为 $k=4$。新容量将为 $2 \\times 4 = 8$。此次复制的成本为 $k^2 = 4^2 = 16$。\n\n从这个模式中，我们可以进行归纳。当数组中的元素数量是 $2$ 的幂（比如 $2^j$）并且我们需要追加一个新元素时，就会触发一次大小调整。需要复制的元素数量为 $k=2^j$。单次大小调整操作的成本为 $k^2 = (2^j)^2 = 4^j$。\n\n我们总共执行 $n=2^t$ 次追加操作。将触发大小调整的数组大小分别为 $1, 2, 4, \\dots, 2^{t-1}$。\n-   当大小为 $1=2^0$ 时，下一次追加会触发大小调整。复制成本为 $(2^0)^2 = 4^0$。这对应于 $j=0$。\n-   当大小为 $2=2^1$ 时，下一次追加会触发大小调整。复制成本为 $(2^1)^2 = 4^1$。这对应于 $j=1$。\n-   这个过程一直持续到数组大小为 $2^{t-1}$。下一次追加（第 $2^{t-1}+1$ 次操作）会触发一次大小调整，新容量为 $2 \\times 2^{t-1} = 2^t$。需要复制的元素数量为 $k=2^{t-1}$，成本为 $(2^{t-1})^2 = 4^{t-1}$。这对应于 $j=t-1$。\n\n在第 $n=2^t$ 次追加操作之后，数组的大小将为 $2^t$，容量也为 $2^t$。在这 $n$ 次操作的序列中，不会再发生大小调整。因此，大小调整对应于 $j$ 从 $0$ 到 $t-1$ 的情况。\n\n总调整大小成本 $C_{resize}$ 是所有这些大小调整操作的成本之和：\n$$C_{resize} = \\sum_{j=0}^{t-1} (2^j)^2 = \\sum_{j=0}^{t-1} 4^j$$\n这是一个有 $t$ 项的有限几何级数，首项为 $4^0=1$，公比为 $4$。其和由公式 $\\frac{r^{\\text{项数}} - 1}{r-1}$ 给出。\n$$C_{resize} = \\frac{4^t - 1}{4 - 1} = \\frac{4^t - 1}{3}$$\n这个计算对于 $t \\ge 1$ 是有效的。如果 $t=0$，则 $n=1$，此时求和为空，其值为 $0$。我们的公式给出 $\\frac{4^0-1}{3}=0$，因此它对 $t=0$ 也成立。\n\n现在，我们可以通过将总基本追加成本和总调整大小成本相加来得到总成本 $C_{total}$：\n$$C_{total} = (\\text{Total Append Cost}) + (\\text{Total Resize Cost}) = n + \\frac{4^t - 1}{3}$$\n\n为了完全用 $n$ 来表示这个表达式，我们使用给定的关系 $n=2^t$。将两边平方得到 $n^2 = (2^t)^2 = 2^{2t} = (2^2)^t = 4^t$。\n将 $4^t = n^2$ 代入 $C_{total}$ 的表达式中：\n$$C_{total} = n + \\frac{n^2 - 1}{3}$$\n\n最后，每次追加的摊销成本 $A(n)$ 是总成本除以操作次数 $n$。\n$$A(n) = \\frac{C_{total}}{n} = \\frac{n + \\frac{n^2 - 1}{3}}{n}$$\n我们可以简化这个表达式：\n$$A(n) = \\frac{n}{n} + \\frac{n^2 - 1}{3n} = 1 + \\frac{n^2 - 1}{3n}$$\n为了将其写成单一分数的形式，我们进行通分：\n$$A(n) = \\frac{3n}{3n} + \\frac{n^2 - 1}{3n} = \\frac{3n + n^2 - 1}{3n}$$\n重新排列分子中的各项，得到最终的简化表达式：\n$$A(n) = \\frac{n^2 + 3n - 1}{3n}$$\n这就是以 $n$ 表示的、单一简化的封闭形式解析表达式所给出的每次追加的精确摊销成本。", "answer": "$$ \\boxed{\\frac{n^2 + 3n - 1}{3n}} $$", "id": "3206794"}, {"introduction": "一个高效的动态数组不仅要能有效增长，还必须能有效收缩。本题研究了一种看似直观的收缩策略，但在交替进行追加和弹出操作的常见模式下，该策略会导致灾难性的性能。通过分析这种“颠簸”（thrashing）行为，你将学到算法设计中至关重要的一课：必须精心选择重置大小的策略，以避免最坏情况下的周期性性能陷阱，从而揭示“滞后”思想的重要性。[@problem_id:3206841]", "problem": "考虑一个实现两种操作的动态数组：追加和弹出。该数组维护一个容量 $C$ 和一个当前大小 $S$，其中 $0 \\leq S \\leq C$。数组使用以下调整大小的策略：\n- 在追加时，如果 $S = C$，数组会通过分配一个容量为 $\\lambda C$ 的新数组来增长，其中 $\\lambda  1$ 是一个固定的增长因子，并在追加新元素之前将所有 $S$ 个现有元素复制到新数组中。\n- 在弹出时，元素被移除后（因此新大小为 $S-1$），数组会通过分配一个容量恰好等于新大小的新数组来收缩，即 $C := S-1$，并将其余所有 $S-1$ 个元素复制到新数组中。\n\n使用以下成本模型：在任何调整大小期间，复制单个元素的成本为 $1$ 个单位，不进行大小调整的追加或弹出操作的成本为 $1$ 个单位。调整大小期间的复制成本与移动的元素数量成线性关系。\n\n假设数组从一个稳定状态开始，其大小为 $s_0 \\geq 1$，容量为 $c_0 = s_0$。考虑一个包含 $2m$ 次操作的序列，该序列交替进行追加和弹出操作，从追加开始，因此整个过程中大小在 $s_0$ 和 $s_0+1$ 之间切换。使用第一性原理的聚合摊销分析，推导每个操作的摊销成本的精确闭式表达式，该表达式是 $m$ 和 $s_0$ 的函数，并报告当 $m \\to \\infty$ 时，以 $s_0$ 表示的稳态摊销成本。将您的最终答案表示为单个闭式解析表达式。不需要四舍五入。", "solution": "该问题陈述是有效的，因为它在算法分析领域具有科学依据，是适定的（提供了所有必要信息），并以客观、正式的语言表述。其调整大小的策略虽然不寻常，但明确无误。因此，我们可以继续进行求解。\n\n问题要求使用聚合方法，为包含 $2m$ 次操作的特定序列计算每个操作的摊销成本。聚合方法计算操作序列的总成本，然后除以操作次数。\n\n设 $S$ 为动态数组中元素的数量（其大小），设 $C$ 为其容量。\n数组的初始状态给定为大小 $s_0 \\geq 1$ 和容量 $c_0 = s_0$。\n这个包含 $2m$ 次操作的序列是一个从 `append` 开始，交替进行 `append` 和 `pop` 操作的序列。\n\n让我们分析一对 `append` 后跟 `pop` 操作的成本和数组状态。这对应于任何 $k \\in \\{1, 2, \\dots, m\\}$ 的第 $2k-1$ 次和第 $2k$ 次操作。\n\n设第一次操作前的状态为 $(S, C) = (s_0, s_0)$。\n\n**操作 1: Append**\n- 当前状态为 $(S, C) = (s_0, s_0)$。\n- `append` 操作时调整大小的条件是 $S = C$，此条件已满足。\n- 执行一次调整大小操作。\n    - 所有 $S = s_0$ 个元素被复制到一个新数组中。此复制的成本是 $s_0$。\n    - 新容量是 $C' = \\lambda C = \\lambda s_0$。\n- 然后追加新元素。`append` 操作的固有成本是 $1$。\n- 这次 `append` 操作的总成本是复制成本和操作成本之和：$s_0 + 1$。\n- `append` 操作后，新大小为 $S' = s_0 + 1$。\n- 数组现在的状态是 $(S, C) = (s_0 + 1, \\lambda s_0)$。\n\n**操作 2: Pop**\n- 当前状态是 $(S, C) = (s_0 + 1, \\lambda s_0)$。\n- 一个元素被移除。大小变为 $S' = S - 1 = (s_0 + 1) - 1 = s_0$。\n- `pop` 操作的调整大小策略是总是收缩数组。\n    - 分配一个容量等于新大小的新数组。新容量是 $C' = s_0$。\n    - 所有 $s_0$ 个剩余元素被复制到这个新数组中。此复制的成本是 $s_0$。\n- `pop` 操作的固有成本是 $1$。\n- 这次 `pop` 操作的总成本是复制成本和操作成本之和：$s_0 + 1$。\n- 在 `pop` 和调整大小之后，最终状态是 $(S, C) = (s_0, s_0)$。\n\n经过一对 `append-pop` 操作后，数组的状态 $(S, C)$ 回到了其初始状态 $(s_0, s_0)$。`append` 操作产生的成本是 $s_0 + 1$，`pop` 操作的成本也是 $s_0 + 1$。\n\n这建立了一个循环。对于后续的每一对 `append-pop` 操作，过程和成本都是相同的。增长因子 $\\lambda$ 会影响一次 `append` 操作后的中间容量，但这个容量会立即被随后的 `pop` 操作的调整大小策略所丢弃。因此，$\\lambda$ 的值不影响这个特定操作序列的总成本。\n\n该序列包含 $m$ 个这样的 `append-pop` 循环。\n- 有 $m$ 次 `append` 操作，每次成本为 $s_0 + 1$。\n- 有 $m$ 次 `pop` 操作，每次成本为 $s_0 + 1$。\n\n总操作次数为 $2m$。\n整个 $2m$ 次操作序列的总成本 $C_{total}$ 是：\n$$ C_{total} = m \\times (\\text{cost of append}) + m \\times (\\text{cost of pop}) $$\n$$ C_{total} = m(s_0 + 1) + m(s_0 + 1) = 2m(s_0 + 1) $$\n\n第一个任务是找到每个操作的摊销成本的精确闭式表达式 $A(m, s_0)$。这是总成本除以操作次数：\n$$ A(m, s_0) = \\frac{C_{total}}{2m} = \\frac{2m(s_0 + 1)}{2m} = s_0 + 1 $$\n这个表达式是作为 $m$ 和 $s_0$ 的函数的摊销成本。它相对于 $m$ 是一个常数。\n\n第二个任务是找到当 $m \\to \\infty$ 时的稳态摊销成本。这是 $A(m, s_0)$ 在 $m$ 趋于无穷大时的极限：\n$$ \\lim_{m \\to \\infty} A(m, s_0) = \\lim_{m \\to \\infty} (s_0 + 1) $$\n由于 $s_0 + 1$ 不依赖于 $m$，该极限就是：\n$$ \\lim_{m \\to \\infty} (s_0 + 1) = s_0 + 1 $$\n\n每个操作的稳态摊销成本是 $s_0 + 1$。", "answer": "$$\\boxed{s_0 + 1}$$", "id": "3206841"}]}