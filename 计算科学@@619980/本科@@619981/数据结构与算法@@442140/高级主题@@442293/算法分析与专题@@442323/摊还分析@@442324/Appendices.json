{"hands_on_practices": [{"introduction": "本练习将引导你对动态数组进行基础分析。通过从第一性原理推导平摊成本常数，你将定量地理解增长因子 $\\alpha$ 如何直接影响性能，并揭示为何某些增长因子的效率更高。这个练习是掌握动态数组设计核心权衡的关键。[@problem_id:3206964]", "problem": "动态数组支持在末尾附加单个元素的操作。数组创建时为空，初始容量为 $1$。每当对一个容量为 $C$ 的满数组进行附加操作时，数组会重新分配大小，方法是分配一个容量恰好为 $\\alpha C$ 的新数组（其中 $\\alpha>1$ 是一个固定的实数增长因子），然后将所有 $C$ 个当前元素复制到新数组中。成本模型只计算由调整大小引起的元素移动（即，将现有元素复制到新数组中）；写入新附加的元素不计入成本。令 $M_{\\alpha}(N)$ 表示从一个空数组开始，在前 $N$ 次附加操作期间，因所有调整大小操作而移动的现有元素总数。\n\n定义 $c_{\\alpha}$ 为满足不等式 $M_{\\alpha}(N)\\leq c_{\\alpha} N$ 对所有整数 $N\\geq 1$ 成立的最小实数常数。\n\n仅使用摊销分析的基本原理和几何级数的基本性质，推导出 $c_{\\alpha}$，然后计算比率 $c_{3/2}/c_{2}$ 的精确值。将最终答案表示为一个无单位的精确数字。除了上述定义之外，不要使用任何关于动态数组的已有结论。", "solution": "问题要求推导与动态数组中附加操作的摊销成本相关的常数 $c_{\\alpha}$，并计算比率 $c_{3/2}/c_{2}$。\n\n首先，我们根据问题陈述建立调整大小过程的模型。数组的初始容量为 $1$。当对一个容量为 $C$ 的满数组执行附加操作时，会分配一个容量为 $\\alpha C$ 的新数组，并复制 $C$ 个现有元素。增长因子 $\\alpha$ 是一个大于 $1$ 的实数。\n\n让我们分析事件的序列。\n初始状态：数组为空，其容量为 $C_0 = 1$。\n第一次附加操作将一个元素放入数组中，此时数组包含 $n=1$ 个元素，容量为 $C_0=1$。数组已满。没有发生复制，所以 $M_{\\alpha}(1) = 0$。\n\n对于第二次附加（$N=2$），数组已满。触发了一次调整大小。\n需要复制的元素数量是当前容量，即 $C_0=1$。\n新容量变为 $C_1 = \\alpha C_0 = \\alpha$。\n第一次调整大小后，数组包含 $2$ 个元素。\n\n在此分析中，一个标准的简化假设是（这与“基本原理”和“几何级数”的指令相符）将容量建模为一个直接的等比数列。我们将在调整大小完成时的容量序列视为 $C_k = \\alpha^k$，其中 $k=0, 1, 2, \\ldots$。当数组满载 $\\alpha^{k-1}$ 个元素且需要再附加一个元素时，会发生一次从容量 $C_{k-1} = \\alpha^{k-1}$ 到 $C_k = \\alpha^k$ 的调整大小。这次调整大小的成本是复制的元素数量，即 $\\alpha^{k-1}$。\n\n让我们考虑一个包含 $N$ 次附加操作的序列，其中 $N \\ge 1$。令 $m$ 为已发生调整大小操作的总次数。这意味着数组的当前容量是 $C_m = \\alpha^m$。元素数量 $N$ 必须大于前一个容量 $C_{m-1} = \\alpha^{m-1}$，但不能超过当前容量 $C_m = \\alpha^m$。因此，我们有条件 $\\alpha^{m-1}  N \\le \\alpha^m$。注意，对于 $N=1$，我们有 $m=0$（没有调整大小），$\\alpha^{-1}  1 \\le \\alpha^0=1$。\n\n元素移动总数 $M_{\\alpha}(N)$ 是所有 $m$ 次调整大小的成本之和。成本是每次调整大小之前的容量：$C_0, C_1, \\ldots, C_{m-1}$。\n$$M_{\\alpha}(N) = \\sum_{k=0}^{m-1} C_k = \\sum_{k=0}^{m-1} \\alpha^k$$\n这是一个首项为 $1$，公比为 $\\alpha$，共有 $m$ 项的有限几何级数。其和为：\n$$M_{\\alpha}(N) = \\frac{\\alpha^m - 1}{\\alpha-1}$$\n常数 $c_{\\alpha}$ 定义为满足对所有 $N \\ge 1$ 都有 $M_{\\alpha}(N) \\le c_{\\alpha} N$ 的最小实数常数。这等价于找出比率 $\\frac{M_{\\alpha}(N)}{N}$ 在所有整数 $N \\ge 1$ 上的上确界 (supremum)。\n$$c_{\\alpha} = \\sup_{N \\ge 1} \\frac{M_{\\alpha}(N)}{N}$$\n让我们分析这个比率。对于给定的 $N$，我们找到 $m$ 使得 $\\alpha^{m-1}  N \\le \\alpha^m$。该比率为：\n$$\\frac{M_{\\alpha}(N)}{N} = \\frac{1}{N} \\left(\\frac{\\alpha^m - 1}{\\alpha-1}\\right)$$\n在范围 $\\alpha^{m-1}  N \\le \\alpha^m$ 内，分子是常数，而分母 $N$ 是变化的。因此，当 $N$ 尽可能小时，该比率达到最大值。此函数的峰值出现在每次调整大小之后，即对于每个 $m$，在 $N$ 取最小整数值时。这些值的形式为 $N = \\lfloor \\alpha^{m-1} \\rfloor + 1$。\n\n为了找到上确界，我们可以建立该比率的一个上界。我们知道 $N > \\alpha^{m-1}$，这意味着 $\\frac{1}{N}  \\frac{1}{\\alpha^{m-1}}$。\n$$\\frac{M_{\\alpha}(N)}{N}  \\frac{1}{\\alpha^{m-1}} \\left(\\frac{\\alpha^m - 1}{\\alpha-1}\\right) = \\frac{\\alpha^m - 1}{\\alpha^{m-1}(\\alpha-1)} = \\frac{\\alpha - \\frac{1}{\\alpha^{m-1}}}{\\alpha-1}$$\n因为 $\\alpha > 1$，我们有 $\\frac{1}{\\alpha^{m-1}} > 0$。因此：\n$$\\frac{M_{\\alpha}(N)}{N}  \\frac{\\alpha}{\\alpha-1}$$\n这表明 $\\frac{\\alpha}{\\alpha-1}$ 是比率 $\\frac{M_{\\alpha}(N)}{N}$ 的一个严格上界。为了证明它是最小上界（即上确界），我们必须证明我们可以任意接近这个值。让我们考虑点序列 $N_m = \\lfloor \\alpha^{m-1} \\rfloor + 1$（对于 $m \\ge 1$），它表示第 $m$ 次调整大小刚完成后的状态。\n对于这些点，比率为：\n$$\\frac{M_{\\alpha}(N_m)}{N_m} = \\frac{(\\alpha^m - 1)/(\\alpha-1)}{\\lfloor \\alpha^{m-1} \\rfloor + 1}$$\n我们取 $m \\to \\infty$ 时的极限（这对应于 $N \\to \\infty$）：\n$$\\lim_{m\\to\\infty} \\frac{M_{\\alpha}(N_m)}{N_m} = \\lim_{m\\to\\infty} \\frac{\\alpha^m - 1}{(\\alpha-1)(\\lfloor \\alpha^{m-1} \\rfloor + 1)}$$\n为了计算这个极限，我们将分子和分母同时除以 $\\alpha^{m-1}$：\n$$\\lim_{m\\to\\infty} \\frac{\\alpha - \\frac{1}{\\alpha^{m-1}}}{(\\alpha-1)\\left(\\frac{\\lfloor \\alpha^{m-1} \\rfloor}{\\alpha^{m-1}} + \\frac{1}{\\alpha^{m-1}}\\right)}$$\n当 $m \\to \\infty$ 时，$\\frac{1}{\\alpha^{m-1}} \\to 0$。对于项 $\\frac{\\lfloor \\alpha^{m-1} \\rfloor}{\\alpha^{m-1}}$，我们使用性质 $x-1  \\lfloor x \\rfloor \\le x$。这给出 $1 - \\frac{1}{\\alpha^{m-1}}  \\frac{\\lfloor \\alpha^{m-1} \\rfloor}{\\alpha^{m-1}} \\le 1$。根据夹逼定理，$\\lim_{m\\to\\infty} \\frac{\\lfloor \\alpha^{m-1} \\rfloor}{\\alpha^{m-1}} = 1$。\n将这些极限代入表达式中，得到：\n$$\\frac{\\alpha - 0}{(\\alpha-1)(1+0)} = \\frac{\\alpha}{\\alpha-1}$$\n由于比率 $\\frac{M_\\alpha(N)}{N}$ 可以任意接近 $\\frac{\\alpha}{\\alpha-1}$，这个值就是上确界。\n因此，最小常数 $c_{\\alpha}$ 是：\n$$c_{\\alpha} = \\frac{\\alpha}{\\alpha-1}$$\n现在，我们必须计算比率 $c_{3/2}/c_{2}$。\n首先，我们通过设置 $\\alpha = 3/2$ 来计算 $c_{3/2}$：\n$$c_{3/2} = \\frac{\\frac{3}{2}}{\\frac{3}{2} - 1} = \\frac{\\frac{3}{2}}{\\frac{1}{2}} = 3$$\n接着，我们通过设置 $\\alpha = 2$ 来计算 $c_2$：\n$$c_{2} = \\frac{2}{2 - 1} = \\frac{2}{1} = 2$$\n最后，我们计算比率：\n$$\\frac{c_{3/2}}{c_{2}} = \\frac{3}{2}$$", "answer": "$$\\boxed{\\frac{3}{2}}$$", "id": "3206964"}, {"introduction": "让我们使用记账法，将视角从分析转向设计。本问题不再是为给定系统计算成本，而是挑战你确定在固定的操作预算下，系统必须满足的参数——即增长因子 $\\alpha$。这个练习将提升你运用记账法的能力，并突显其在数据结构工程实践中的价值。[@problem_id:3206856]", "problem": "您正在设计一个动态数组，每当数组满时，它会按因子 $\\alpha  1$ 进行几何增长。\n\n成本模型如下：将一个追加的元素写入任何可用位置的成本为 $1$，当数组扩容时，将每个现有元素复制到新数组的成本为每个元素 $1$。内存分配和指针更新的成本假定为与 $n$ 无关的常数，因此予以忽略。\n\n您将使用摊还分析中的核算方法：为每次追加操作分配一个可能超过其实际成本的摊还费用，并将任何盈余作为信用点数存储起来，这些信用点数可用于支付未来扩容时产生的移动成本。信用点数在任何时候都不能为负。\n\n设计一个核算方案，其中每次追加操作精确收取 $3$ 个单位的费用：$1$ 个单位用于支付其自身的即时写入，$2$ 个单位作为信用点数存入，这些信用点数仅用于支付未来扩容时的移动成本（信用点数可用于支付移动任何元素的成本，而不必是产生这些信用点数的那个元素）。假设数组初始为空，容量为 $1$，并考虑一个不含删除操作的任意有限追加序列。请确定最小的增长因子 $\\alpha$，使得对于所有此类序列，该核算方案都能持续下去而不会出现信用赤字。\n\n您的最终答案必须是 $\\alpha$ 的一个精确值，无需四舍五入。", "solution": "我们的目标是为动态数组找到最小的增长因子 $\\alpha$，以确保一个特定的核算方案在任意追加序列下都能维持，即信用余额永不为负。\n\n#### 模型设定\n-   **成本模型**: 每次写入操作的实际成本为 $1$。每次扩容操作中，复制每个元素的成本为 $1$。\n-   **核算方案**: 每次追加操作收取 $3$ 单位的摊还费用。其中 $1$ 单位用于支付即时写入，剩下的 $2$ 单位作为信用点存入。扩容时的复制成本完全由这些信用点支付。\n-   **扩容机制**: 初始容量为 $1$。当容量为 $C$ 的数组变满时，它会扩容至 $\\alpha C$。为简化分析，我们考虑容量序列为 $C_k = \\alpha^k$ ($k=0, 1, 2, \\ldots$)。第 $k$ 次扩容（从容量 $\\alpha^{k-1}$ 到 $\\alpha^k$）发生在数组已有 $\\alpha^{k-1}$ 个元素，并尝试追加下一个元素时。\n\n#### 临界点分析\n核算方案的可行性取决于信用余额在任何时候都不能为负。最严峻的考验发生在一次昂贵的扩容操作之前，此时积累的信用必须足以支付即将到来的复制成本。\n\n让我们分析系统在即将进行第 $k$ 次扩容（$k \\ge 1$）时的状态。\n- 此时，数组中已有 $\\alpha^{k-1}$ 个元素。\n- 自数组创建以来，总共进行了 $\\alpha^{k-1}$ 次追加操作。\n- 每次追加都存入了 $2$ 个信用点，所以总存入的信用为 $2 \\times \\alpha^{k-1}$。\n- 在此之前，系统已经历了 $k-1$ 次扩容（从 $\\alpha^0$ 到 $\\alpha^1$，...，从 $\\alpha^{k-2}$ 到 $\\alpha^{k-1}$）。\n- 这些过去扩容的总成本（即总支出）为：\n$$ \\text{Cost}_{\\text{past resizes}} = \\sum_{m=0}^{k-2} \\alpha^m = \\frac{\\alpha^{k-1}-1}{\\alpha-1} $$\n- 因此，在第 $k$ 次扩容前，可用的信用余额 $B$ 为总存入减去总支出：\n$$ B = 2\\alpha^{k-1} - \\frac{\\alpha^{k-1}-1}{\\alpha-1} $$\n\n#### 建立并求解不等式\n即将到来的第 $k$ 次扩容需要复制 $\\alpha^{k-1}$ 个元素，成本为 $\\alpha^{k-1}$。为了避免信用赤字，可用余额必须不小于此成本：\n$$ B \\ge \\alpha^{k-1} $$\n将 $B$ 的表达式代入：\n$$ 2\\alpha^{k-1} - \\frac{\\alpha^{k-1}-1}{\\alpha-1} \\ge \\alpha^{k-1} $$\n简化此不等式：\n$$ \\alpha^{k-1} \\ge \\frac{\\alpha^{k-1}-1}{\\alpha-1} $$\n因为 $\\alpha > 1$，所以 $\\alpha-1 > 0$。两边同乘以 $(\\alpha-1)$：\n$$ \\alpha^{k-1}(\\alpha-1) \\ge \\alpha^{k-1}-1 $$\n$$ \\alpha^k - \\alpha^{k-1} \\ge \\alpha^{k-1}-1 $$\n$$ \\alpha^k - 2\\alpha^{k-1} + 1 \\ge 0 $$\n提出 $\\alpha^{k-1}$ 因子：\n$$ \\alpha^{k-1}(\\alpha - 2) + 1 \\ge 0 $$\n这个不等式必须对所有 $k \\ge 1$ 成立。\n-   **如果 $\\alpha = 2$**: 不等式变为 $2^{k-1}(2 - 2) + 1 = 1 \\ge 0$，恒成立。\n-   **如果 $\\alpha > 2$**: $\\alpha-2 > 0$，所以 $\\alpha^{k-1}(\\alpha - 2) + 1$ 总是正数，不等式成立。\n-   **如果 $1  \\alpha  2$**: $\\alpha-2  0$。当 $k$ 增大时，$\\alpha^{k-1}$ 趋向无穷大，$\\alpha^{k-1}(\\alpha - 2)$ 趋向负无穷大。因此，对于任意给定的 $1  \\alpha  2$，总能找到一个足够大的 $k$ 使得不等式不成立。\n\n综上所述，为了保证方案对所有 $k \\ge 1$ 都有效，必须满足 $\\alpha \\ge 2$。\n\n#### 结论\n所要求的最小增长因子 $\\alpha$ 是 $2$。", "answer": "$$\\boxed{2}$$", "id": "3206856"}, {"introduction": "优秀的数据结构设计不仅要优化平均情况，更要避免灾难性的最坏情况。本练习将探讨一种危险的“颠簸”现象，其中不明智的增长与收缩策略组合会导致性能急剧下降。通过分析这个病态案例，你将理解为何必须谨慎选择调整大小的参数以确保稳健的效率。[@problem_id:3206966]", "problem": "动态数组将元素存储在连续的内存块中，其当前大小为 $s$，容量为 $C$。当 $s = C$ 时，数组会通过分配一个容量为 $\\alpha C$ 的新块并复制所有 $s$ 个元素来进行扩容；当 $s \\leq \\beta C$ 时，数组会通过分配一个容量为 $\\beta C$ 的新块并复制所有 $s$ 个元素来进行缩容。假设成本模型如下：复制一个元素的成本为 $1$，每次不触发容量调整的插入或删除操作的成本为 $1$，而分配内存的成本可忽略不计。序列的摊销成本采用聚合成本法定义：每个操作的摊销成本等于总成本除以操作总数。\n\n考虑增长因子和收缩因子近似互为倒数的情况，此时数组容易发生振荡性的容量调整。设 $k$ 为一个固定的正整数，增长因子设为 $\\alpha = \\frac{k+1}{k}$，收缩因子设为 $\\beta = \\frac{k}{k+1}$，因此 $\\alpha \\beta = 1$。假设初始容量为 $C_{0} = n$，$n$ 可被 $k$ 整除，且数组初始时是满的，即 $s = n$。现在重复执行以下由两个操作组成的循环：\n1. 插入一个元素。\n2. 删除一个元素。\n\n在 $s = C \\Rightarrow$ 扩容至容量 $\\alpha C$ 和 $s \\leq \\beta C \\Rightarrow$ 缩容至容量 $\\beta C$ 的调整策略下，并使用所述的成本模型，当 $\\alpha \\beta = 1$ 时，这一交替序列会在每次操作时都引发容量调整，从而产生“抖动”行为。\n\n请从第一性原理出发，推导上述交替序列中每个操作的精确摊销成本（总成本除以操作总数），并将其表示为关于 $n$ 的封闭形式解析表达式。无需四舍五入。请将你的最终答案以单个表达式的形式给出。", "solution": "问题要求使用聚合成本法计算动态数组上一特定操作序列的每个操作的摊销成本。该分析需要从第一性原理出发进行逐步推导，跟踪数组的状态（大小 $s$ 和容量 $C$）以及产生的成本。\n\n给定的参数如下：\n- 增长因子：对于正整数 $k$，$\\alpha = \\frac{k+1}{k}$。\n- 收缩因子：$\\beta = \\frac{k}{k+1}$，这意味着 $\\alpha \\beta = 1$。\n- 扩容条件：如果数组已满（即 $s=C$），则在插入前触发容量调整。\n- 缩容条件：如果数组利用率过低（即 $s \\leq \\beta C$），则在删除后触发容量调整。\n- 成本模型：一次插入或删除操作的成本为 $1$ 加上其触发的任何容量调整的成本。容量调整的成本等于被复制的元素数量。\n\n数组的初始状态给定如下：\n- 初始容量：$C_0 = n$。\n- 初始大小：$s_0 = n$（数组已满）。\n- 另外还给定 $n$ 可被 $k$ 整除。\n\n操作序列是一个重复的循环，每次循环包括一次插入和一次删除。我们将分析一个完整循环的成本和状态变化。\n\n**第 1 步：分析第一个操作（插入）**\n\n系统起始状态为 $(s_0, C_0) = (n, n)$。\n执行一次插入操作。\n首先，我们检查容量调整的条件。由于 $s_0 = n$ 和 $C_0 = n$，满足条件 $s=C$。这会在新元素插入之前触发一次扩容操作。\n分配一个新的、更大的数组。新容量 $C_1$ 计算如下：\n$$C_1 = \\alpha C_0 = \\left(\\frac{k+1}{k}\\right) n$$\n这次扩容操作的成本是必须从旧数组复制到新数组的元素数量。此时，大小为 $s_0 = n$。\n$$ \\text{Cost}_{\\text{copy, grow}} = s_0 = n $$\n容量调整后，执行插入操作本身。这有 $1$ 的基本成本。\n第一个操作（带容量调整的插入）的总成本是复制成本和基本插入成本之和：\n$$ \\text{Cost}_1 = \\text{Cost}_{\\text{copy, grow}} + \\text{Cost}_{\\text{base insert}} = n + 1 $$\n此操作后，数组的大小增加一。数组的新状态为：\n- 新大小：$s_1 = s_0 + 1 = n + 1$。\n- 新容量：$C_1 = \\left(\\frac{k+1}{k}\\right) n$。\n\n**第 2 步：分析第二个操作（删除）**\n\n系统现在处于状态 $(s_1, C_1) = \\left(n+1, \\left(\\frac{k+1}{k}\\right)n\\right)$。\n执行一次删除操作。这使元素数量减少一。\n数组的大小变为 $s' = s_1 - 1 = (n+1) - 1 = n$。\n元素被移除后，我们检查缩容的条件。条件是 $s' \\leq \\beta C_1$。\n让我们评估缩容阈值 $\\beta C_1$：\n$$ \\beta C_1 = \\left(\\frac{k}{k+1}\\right) \\times C_1 = \\left(\\frac{k}{k+1}\\right) \\left(\\frac{k+1}{k}\\right) n = 1 \\cdot n = n $$\n因此要检查的条件是 $s' \\leq n$。由于 $s' = n$，条件 $n \\leq n$ 成立。这触发了一次缩容操作。\n分配一个新的、更小的数组。新容量 $C_2$ 为：\n$$ C_2 = \\beta C_1 = n $$\n这次缩容操作的成本是要复制的元素数量，即当前大小 $s' = n$。\n$$ \\text{Cost}_{\\text{copy, shrink}} = s' = n $$\n删除操作的基本成本是 $1$。\n第二个操作（带容量调整的删除）的总成本是复制成本和基本删除成本之和：\n$$ \\text{Cost}_2 = \\text{Cost}_{\\text{copy, shrink}} + \\text{Cost}_{\\text{base delete}} = n + 1 $$\n此操作后，数组的状态为：\n- 新大小：$s_2 = s' = n$。\n- 新容量：$C_2 = n$。\n\n**第 3 步：计算摊销成本**\n\n经过两次操作（一次插入，一次删除）后，数组的状态为 $(s_2, C_2) = (n, n)$。这与初始状态 $(s_0, C_0)$ 完全相同。\n操作和成本的序列将无限重复。因此，我们可以通过分析一个由两次操作组成的单一循环来计算摊销成本。\n一个循环中的总操作次数为 $2$。\n一个循环的总成本是两次操作的成本之和：\n$$ \\text{Total Cost}_{\\text{cycle}} = \\text{Cost}_1 + \\text{Cost}_2 = (n+1) + (n+1) = 2n + 2 $$\n根据聚合成本法的定义，每个操作的摊销成本是总成本除以总操作次数。\n$$ \\text{Amortized Cost} = \\frac{\\text{Total Cost}_{\\text{cycle}}}{\\text{Number of Operations}_{\\text{cycle}}} = \\frac{2n + 2}{2} = n + 1 $$\n这就是给定序列中每个操作的精确摊销成本，它展示了“抖动”行为，即每次操作都会触发一次高昂的容量调整，导致摊销成本与数组大小 $n$ 呈线性关系。条件“$n$ 可被 $k$ 整除”确保了中间容量 $C_1$ 是一个整数，从而使问题是良定义的。", "answer": "$$\\boxed{n+1}$$", "id": "3206966"}]}