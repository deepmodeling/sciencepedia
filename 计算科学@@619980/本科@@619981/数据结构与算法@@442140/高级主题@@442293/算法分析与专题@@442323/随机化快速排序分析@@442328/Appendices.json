{"hands_on_practices": [{"introduction": "在理解了单步划分的概率行为后，我们将视野扩大到整个算法的执行过程。本练习 [@problem_id:3263936] 是一个经典的分析问题，它将引导我们使用一种名为“指示器随机变量”的强大技术来计算算法在处理不含重复元素的数组时的总比较次数期望。掌握这一方法是分析许多随机算法性能的关键。", "problem": "考虑一个快速排序算法的版本，其输入数组 $A$ 是集合 $\\{1, 2, \\ldots, n\\}$ 的一个排列，其中 $n \\ge 2$。在每次对连续子数组 $A[L..R]$ 操作的递归调用中，令 $m = R - L + 1$ 表示子数组的长度。该算法通过调用一个随机数生成器 (RNG) 从子数组中均匀随机地选择主元索引。该RNG返回一个从区间 $[0, 1)$ 中均匀抽取的独立同分布 (i.i.d.) 的实数值 $\\operatorname{rand}()$，然后将主元索引设置为 $L - 1 + \\lceil \\operatorname{rand}() \\cdot m \\rceil$。然后，仅通过键值比较对子数组进行划分，其中主元键值与子数组中的其他每个键值恰好比较一次，之后算法对两个分区进行递归。假设不同递归层级上的RNG调用是相互独立的。\n\n仅使用概率论中期望的基本定义、上述主元选择的均匀性以及快速排序的结构行为，推导该算法在整个执行过程中所执行的键值比较总数的精确期望值，并将其表示为一个关于 $n$ 和第 $n$ 个调和数 $H_n = \\sum_{k=1}^{n} \\frac{1}{k}$ 的闭式解析表达式。\n\n你的最终答案必须是一个关于 $n$ 和 $H_n$ 的单一解析表达式。无需进行数值取整。", "solution": "用户希望解决以下问题：\n考虑一个快速排序算法的版本，其输入数组 $A$ 是集合 $\\{1, 2, \\ldots, n\\}$ 的一个排列，其中 $n \\ge 2$。在每次对连续子数组 $A[L..R]$ 操作的递归调用中，令 $m = R - L + 1$ 表示子数组的长度。该算法通过调用一个随机数生成器 (RNG) 从子数组中均匀随机地选择主元索引。该RNG返回一个从区间 $[0, 1)$ 中均匀抽取的独立同分布 (i.i.d.) 的实数值 $\\operatorname{rand}()$，然后将主元索引设置为 $L - 1 + \\lceil \\operatorname{rand}() \\cdot m \\rceil$。然后，仅通过键值比较对子数组进行划分，其中主元键值与子数组中的其他每个键值恰好比较一次，之后算法对两个分区进行递归。假设不同递归层级上的RNG调用是相互独立的。\n\n仅使用概率论中期望的基本定义、上述主元选择的均匀性以及快速排序的结构行为，推导该算法在整个执行过程中所执行的键值比较总数的精确期望值，并将其表示为一个关于 $n$ 和第 $n$ 个调和数 $H_n = \\sum_{k=1}^{n} \\frac{1}{k}$ 的闭式解析表达式。\n\n### 步骤1：提取已知条件\n- 算法：对数组 $A$ 进行快速排序。\n- 输入：$A$ 是集合 $\\{1, 2, \\ldots, n\\}$ 的一个排列，其中 $n \\ge 2$。\n- 考虑的子数组：长度为 $m = R - L + 1$ 的 $A[L..R]$。\n- 主元选择：从范围 $[L, R]$ 中均匀随机选择一个索引。其机制定义为`主元索引` $= L - 1 + \\lceil \\operatorname{rand}() \\cdot m \\rceil$，其中 $\\operatorname{rand}()$ 是 $[0, 1)$ 上的一个均匀随机变量。\n- 划分：主元元素与它所在子数组中的每个其他元素恰好比较一次。\n- 目标：推导键值比较总数的精确期望值。\n- 约束：推导过程必须只使用期望的基本定义、指定的主元选择均匀性以及快速排序的结构。最终答案必须是关于 $n$ 和 $H_n$ 的闭式表达式。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据：** 是。该问题设置在算法分析的形式框架内，这是计算机科学和离散数学的一个分支。随机化快速排序的模型是标准且易于理解的。主元选择机制 `$L - 1 + \\lceil \\operatorname{rand}() \\cdot m \\rceil$` 正确地模拟了从 $1$到 $m$ 均匀选择一个整数，这对应于从 $L$ 到 $R$ 均匀选择一个索引。这是一个数学上合理的设置。\n- **良构性：** 是。该问题在明确指定的条件下要求一个具体的、明确定义的量（期望比较次数）。已知存在唯一解。\n- **客观性：** 是。该问题以精确、正式的语言陈述，没有歧义或主观因素。\n- **完整性和一致性：** 是。该问题提供了进行推导所需的所有必要信息。条件 $n \\ge 2$ 是合理的，因为当 $n=0$ 和 $n=1$ 时，比较次数为零。\n- **其他缺陷：** 该问题不存在任何其他列出的缺陷。这是一个非平凡、标准且可验证的问题。\n\n### 步骤3：结论与行动\n问题有效。将提供完整解答。\n\n### 推导\n设 $X$ 为随机变量，表示随机化快速排序算法在大小为 $n$ 的输入上执行的键值比较总数。我们希望计算 $X$ 的期望，记为 $E[X]$。\n\n我们使用指示器随机变量的方法。设输入数组中的不同元素排序后为 $z_1  z_2  \\ldots  z_n$。由于输入是 $\\{1, 2, \\ldots, n\\}$ 的一个排列，我们有 $z_i = i$，其中 $i \\in \\{1, 2, \\ldots, n\\}$。\n\n令 $X_{ij}$ 为一个指示器随机变量，表示元素 $z_i$ 和 $z_j$ 在算法执行过程中的某个时刻被比较的事件。根据指示器变量的定义，\n$$\nX_{ij} =\n\\begin{cases}\n1   \\text{如果 } z_i \\text{ 和 } z_j \\text{ 被比较} \\\\\n0   \\text{否则}\n\\end{cases}\n$$\n总比较次数 $X$ 是这些指示器变量在所有不同元素对上的总和。不失一般性，我们假设 $i  j$。\n$$ X = \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} X_{ij} $$\n根据期望的线性性质，期望的总比较次数为：\n$$ E[X] = E\\left[\\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} X_{ij}\\right] = \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} E[X_{ij}] $$\n指示器随机变量的期望是它所指示事件的概率：\n$$ E[X_{ij}] = 1 \\cdot P(z_i \\text{ 和 } z_j \\text{ 被比较}) + 0 \\cdot P(z_i \\text{ 和 } z_j \\text{ 未被比较}) = P(z_i \\text{ 和 } z_j \\text{ 被比较}) $$\n现在，我们必须确定 $z_i$ 和 $z_j$ 被比较的概率。两个元素被比较当且仅当其中一个被选为主元，而另一个仍在同一个子数组中。\n\n考虑元素集合 $S_{ij} = \\{z_i, z_{i+1}, \\ldots, z_j\\}$。这些是值介于 $z_i$ 和 $z_j$ 之间（含两端）的元素。任何在此范围之外选择的主元都不会将 $z_i$ 和 $z_j$ 分到不同的分区中。只有当选择的主元 $p$ 满足 $z_i \\le p \\le z_j$ 时，$z_i$ 和 $z_j$ 才会被分开。事实上，如果从集合 $S_{ij}$ 中选出的第一个主元是元素 $z_k$ (其中 $i  k  j$)，那么 $z_i$ 将被放入“小于 $z_k$”的分区，而 $z_j$ 将被放入“大于 $z_k$”的分区。此后，它们将永远不会在同一个子数组中，也永远不会被比较。\n\n因此，$z_i$ 和 $z_j$ 被比较，当且仅当从集合 $S_{ij}$ 中选出的第一个主元是 $z_i$ 或 $z_j$。\n\n问题陈述，主元是从当前子数组中存在的元素中均匀随机选择的。这意味着 $S_{ij}$ 中的任何元素都有同等可能成为从该集合中选出的第一个主元。集合 $S_{ij}$ 包含 $j - i + 1$ 个元素。在总共 $j - i + 1$ 个等可能的结果中，有两个“有利”于发生比较的结果（即主元是 $z_i$ 或 $z_j$）。\n\n因此，比较的概率是：\n$$ P(z_i \\text{ 和 } z_j \\text{ 被比较}) = \\frac{2}{j - i + 1} $$\n所以，$E[X_{ij}] = \\frac{2}{j-i+1}$。\n\n现在我们可以通过对所有满足 $1 \\le i  j \\le n$ 的对 $(i, j)$ 求和来计算总的期望比较次数：\n$$ E[X] = \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\frac{2}{j-i+1} $$\n为了计算这个双重求和，我们可以重新索引。让我们按从 $z_i$ 到 $z_j$ 的区间大小对各项进行分组。令 $k = j-i+1$ 为集合 $S_{ij}$ 的大小。$k$ 的最小值为 $2$（当 $j=i+1$ 时），最大值为 $n$（当 $i=1, j=n$ 时）。\n\n对于一个固定的值 $k \\in \\{2, 3, \\ldots, n\\}$，我们需要计算存在多少对 $(i, j)$ 使得 $1 \\le i  j \\le n$ 且 $j-i+1=k$。这个条件等价于 $j-i = k-1$。\n当 $i=1$ 时，$j=1+(k-1)=k$。\n当 $i=2$ 时，$j=2+(k-1)=k+1$。\n...\n当 $j=n$ 时，$i$ 取到最大可能值。此时，$i = j - (k-1) = n - k + 1$。\n所以，对于一个固定的 $k$，$i$ 的范围是从 $1$ 到 $n-k+1$。这样的对 $(i,j)$ 的数量是 $n-k+1$。\n\n我们现在可以通过先对 $k$ 求和来重写 $E[X]$ 的和式：\n$$ E[X] = \\sum_{k=2}^{n} (\\text{大小为 } k \\text{ 的对的数量}) \\cdot \\frac{2}{k} $$\n$$ E[X] = \\sum_{k=2}^{n} (n-k+1) \\frac{2}{k} = 2 \\sum_{k=2}^{n} \\frac{n-k+1}{k} $$\n我们可以拆分求和式内部的项：\n$$ E[X] = 2 \\sum_{k=2}^{n} \\left(\\frac{n+1}{k} - \\frac{k}{k}\\right) = 2 \\sum_{k=2}^{n} \\left(\\frac{n+1}{k} - 1\\right) $$\n将求和式分成两部分：\n$$ E[X] = 2 \\left( \\sum_{k=2}^{n} \\frac{n+1}{k} - \\sum_{k=2}^{n} 1 \\right) $$\n对于第一部分：\n$$ \\sum_{k=2}^{n} \\frac{n+1}{k} = (n+1) \\sum_{k=2}^{n} \\frac{1}{k} $$\n使用第 $n$ 个调和数 $H_n = \\sum_{k=1}^{n} \\frac{1}{k}$ 的定义，我们可以写出：\n$$ \\sum_{k=2}^{n} \\frac{1}{k} = \\left(\\sum_{k=1}^{n} \\frac{1}{k}\\right) - \\frac{1}{1} = H_n - 1 $$\n所以，第一部分是 $(n+1)(H_n - 1)$。\n\n对于第二部分：\n$$ \\sum_{k=2}^{n} 1 = (n - 2 + 1) = n-1 $$\n将这些结果代回 $E[X]$ 的表达式中：\n$$ E[X] = 2 \\left( (n+1)(H_n - 1) - (n-1) \\right) $$\n现在，我们简化表达式：\n$$ E[X] = 2 \\left( (n+1)H_n - (n+1) - (n-1) \\right) $$\n$$ E[X] = 2 \\left( (n+1)H_n - n - 1 - n + 1 \\right) $$\n$$ E[X] = 2 \\left( (n+1)H_n - 2n \\right) $$\n$$ E[X] = 2(n+1)H_n - 4n $$\n这就是期望总键值比较次数的最终闭式表达式。", "answer": "$$\\boxed{2(n+1)H_n - 4n}$$", "id": "3263936"}, {"introduction": "现实世界的数据往往包含重复的键值，这可能会对算法的性能产生影响。本练习 [@problem_id:3263993] 挑战我们将前一个练习中的分析方法应用到一个更复杂但更贴近实际的场景中。通过分析仅含两种不同元素数组的排序过程，我们可以更深入地理解划分策略与数据分布之间的相互作用。", "problem": "设一个输入数组包含 $n = n_0 + n_1$ 个元素，这些元素取自二元字母表 $\\{0, 1\\}$，其中恰好有 $n_0 \\ge 1$ 个 $0$ 和 $n_1 \\ge 1$ 个 $1$。考虑以下随机化快速排序的一个变体：在每次递归调用中，算法从当前子数组中均匀随机地选择一个主元 (pivot)，并执行一次双路划分，将每个满足 $x  \\text{pivot}$ 的元素 $x$ 放置到左部，将每个满足 $x \\ge \\text{pivot}$ 的元素 $x$ 放置到右部。算法接着对两部分进行递归调用。成本只计算键值比较（即数组元素与主元的比较）；忽略交换和其他操作。\n\n仅从随机化快速排序的核心定义以及“当一个大小为 $m$ 的子数组中的所有键值都相同时，该算法在该子数组上恰好执行 $m(m-1)/2$ 次比较”这一事实出发，从第一性原理推导出该算法在整个数组上执行的键值比较总数的期望值关于 $n_0$ 和 $n_1$ 的闭式表达式。将最终答案表示为关于 $n_0$ 和 $n_1$ 的单一精确解析表达式。无需进行取整。", "solution": "用户希望找到一种特定变体的随机化快速排序，在处理一个包含 $n_0$ 个 $0$ 和 $n_1$ 个 $1$ 的数组时，其键值比较总数的期望值。\n\n设 $C$ 是表示键值比较总数的随机变量。我们寻求计算期望值 $E[C]$。我们将使用期望的线性性。比较总数是数组中所有不同元素对的比较次数之和。设数组元素从 $1$ 到 $n=n_0+n_1$ 进行索引。设 $X_{i,j}$ 为指示随机变量，如果第 $i$ 个元素和第 $j$ 个元素被比较，则其值为 $1$，否则为 $0$。总比较次数为 $C = \\sum_{1 \\le i  j \\le n} X_{i,j}$。根据期望的线性性，有 $E[C] = \\sum_{1 \\le i  j \\le n} E[X_{i,j}] = \\sum_{1 \\le i  j \\le n} P(\\text{元素 } i \\text{ 和 } j \\text{ 被比较})$。\n\n我们可以根据元素的值对元素对 $(i, j)$ 进行分类：\n1.  两个元素都是 $0$。有 $\\binom{n_0}{2}$ 对这样的元素对。\n2.  两个元素都是 $1$。有 $\\binom{n_1}{2}$ 对这样的元素对。\n3.  一个元素是 $0$，另一个是 $1$。有 $n_0 n_1$ 对这样的元素对。\n\n让我们分析每种情况下发生比较的概率。划分规则是，满足 $x  \\text{pivot}$ 的元素进入左分区，满足 $x \\ge \\text{pivot}$ 的元素进入右分区。\n\n情况1：一对两个零，比如 $0_a$ 和 $0_b$。\n让我们考虑在什么情况下这对元素会被分到不同的分区。\n- 如果主元是 $0$：$0_a$ 和 $0_b$ 都 $\\ge$ 主元。它们都进入右分区。它们不会被分开。\n- 如果主元是 $1$：$0_a$ 和 $0_b$ 都小于主元。它们都进入左分区。它们不会被分开。\n由于没有任何主元的选择可以分开两个零，任何一对零在算法的整个执行过程中都将始终保留在同一个子数组中。最终，它们将成为一个仅由 $n_0$ 个零组成的子数组的一部分。问题陈述中给出，在一个包含 $m$ 个相同键值的子数组上，比较次数恰好是 $\\frac{m(m-1)}{2}$，即 $\\binom{m}{2}$。这意味着这样一个子数组中的每一对元素都被比较了恰好一次。因此，任何一对特定的零被比较的概率是 $1$。\n两个零组成的元素对之间的期望比较次数是这些元素对的数量乘以该概率：\n$E_{00} = \\binom{n_0}{2} \\times 1 = \\frac{n_0(n_0-1)}{2}$。\n\n情况2：一对两个一，比如 $1_a$ 和 $1_b$。\n我们进行类似的分析。\n- 如果主元是 $0$：$1_a$ 和 $1_b$ 都 $\\ge$ 主元。它们都进入右分区。它们不会被分开。\n- 如果主元是 $1$：$1_a$ 和 $1_b$ 都 $\\ge$ 主元。它们都进入右分区。它们不会被分开。\n与零的情况类似，任何一对一都不会被分开。它们最终会形成一个由所有 $n_1$ 个一组成的子数组。该子数组内的比较次数将是 $\\frac{n_1(n_1-1)}{2}$。任何一对特定的一被比较的概率是 $1$。\n两个一组成的元素对之间的期望比较次数是：\n$E_{11} = \\binom{n_1}{2} \\times 1 = \\frac{n_1(n_1-1)}{2}$。\n\n情况3：一个由一个零和一个一组成的对，比如 $0_a$ 和 $1_b$。\n两个元素被比较，当且仅当在它们被分到不同分区之前，它们中的一个被选为主元。让我们确定它们何时被分开。\n- 如果主元是 $0$：元素 $0_a$ 进入右分区（$0_a \\ge 0$），而 $1_b$ 也进入右分区（$1_b \\ge 0$）。它们不会被分开。\n- 如果主元是 $1$：元素 $0_a$ 进入左分区（$0_a  1$），但 $1_b$ 进入右分区（$1_b \\ge 1$）。它们被分开了。\n\n所以，元素对 $(0_a, 1_b)$ 被分开，当且仅当从包含它们的子数组中选出的主元是一个 $1$。\n\n考虑由 $0_a$ 和所有 $n_1$ 个一组成的元素集合：$K = \\{0_a, 1_1, 1_2, \\ldots, 1_{n_1}\\}$，其中 $1_b$ 是 $1_j$ 中的一个。这个集合的大小是 $|K| = n_1 + 1$。任何被选为枢轴的、非 $0_a$ 的零，都不会将 $K$ 中的任何元素彼此分开。因此，元素对 $(0_a, 1_b)$ 的命运取决于从集合 $K$ 中第一个被选为主元的元素。由于主元是从其子数组中均匀随机选择的，因此 $K$ 中的任何元素都有同等的机会成为第一个从 $K$ 中被选出的元素。\n\n让我们根据从 $K$ 中首先选出的主元是哪个元素来分析结果：\n- 如果首先选择 $0_a$：$0_a$ 成为主元。其子数组中的所有其他元素，包括 $1_b$，都将与它进行比较。所以，$0_a$ 和 $1_b$ 会被比较。\n- 如果首先选择 $1_b$：$1_b$ 成为主元。其子数组中的所有其他元素，包括 $0_a$，都将与它进行比较。所以，$0_a$ 和 $1_b$ 会被比较。\n- 如果首先选择任何其他的一，即 $1_j$（其中 $j \\ne b$）：$1_j$ 成为主元。在划分步骤中，$0_a$ 与 $1_j$ 比较后被送到左分区，而 $1_b$ 与 $1_j$ 比较后被送到右分区。因此，$0_a$ 和 $1_b$ 被分开了，并且不会相互比较。\n\n$0_a$ 和 $1_b$ 之间发生比较，当且仅当从集合 $K$ 中选出的第一个主元是 $0_a$ 或 $1_b$。在 $|K| = n_1+1$ 种可能性中，有 $2$ 种是有利结果。\n因此，元素对 $(0_a, 1_b)$ 的比较概率是 $P(\\text{比较}) = \\frac{2}{n_1+1}$。\n\n这个概率对于所有 $n_0 n_1$ 个由一个零和一个一组成的元素对都是相同的。零和一之间的总期望比较次数是：\n$E_{01} = n_0 n_1 \\times \\frac{2}{n_1+1} = \\frac{2 n_0 n_1}{n_1+1}$。\n\n最后，总期望比较次数是所有类型元素对的期望之和：\n$E[C] = E_{00} + E_{11} + E_{01}$\n$E[C] = \\frac{n_0(n_0-1)}{2} + \\frac{n_1(n_1-1)}{2} + \\frac{2 n_0 n_1}{n_1+1}$。\n\n这就是键值比较总数期望值的闭式表达式。", "answer": "$$\n\\boxed{\\frac{n_0(n_0-1)}{2} + \\frac{n_1(n_1-1)}{2} + \\frac{2 n_0 n_1}{n_1+1}}\n$$", "id": "3263993"}]}