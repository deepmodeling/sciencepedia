{"hands_on_practices": [{"introduction": "前缀和（或扫描）操作是并行计算中的一个基本构件，对于解决许多看似固有的顺序问题至关重要。本练习 [@problem_id:3258324] 演示了如何利用基于树的方法为此任务构建一个高效的并行算法，然后将其应用于计算移动平均值等实际问题。通过这个练习，你将深入理解如何利用加法的结合律来设计具有 $O(\\log n)$ 深度和 $O(n)$ 功的高效并行算法。", "problem": "您需要基于并行随机存取机（PRAM）模型和“功-深度”（Work–Depth, WD）模型，对一个并行算法进行论证和实现。PRAM 模型假定有一组同步处理器访问一个共享内存；请使用“独占读独占写”（EREW）变体，这意味着在任何单一步骤中，没有两个处理器能从同一内存单元读取或写入同一内存单元。在“功-深度”模型中，总“功”是在所有处理器上执行的单位成本操作的总数（在所有同步步骤上求和），而“深度”是最长依赖链的长度，等价于在 EREW 约束下，假设处理器数量无限时的同步并行步骤数。\n\n任务 A。基于这两个模型，并仅使用以下基本原理，从第一性原理出发：\n- PRAM、EREW 和“功-深度”的定义，\n- 加法具有结合律，以及对于 $n$ 个叶子，平衡二叉树的高度为 $\\lceil \\log_{2} n \\rceil$ 这一事实，\n推导一个并行算法，用于计算长度为 $n$ 的输入序列 $A$ 的前缀和。其中，包含性前缀和序列 $S$ 定义为 $S[i] = \\sum_{k=0}^{i} A[k]$，对于 $i \\in \\{0,\\dots,n-1\\}$。您的推导必须在 EREW-PRAM 模型下证明 $O(\\log n)$ 的深度界限和 $O(n)$ 的功界限。不要假定任何“黑盒”扫描原语；请基于上述基本原理进行论证。\n\n任务 B。修改任务 A 的方法，以计算长度为 $w$ 的移动平均值。给定一个长度为 $n$ 的序列 $A$ 和一个整数窗口 $w$，满足 $1 \\le w \\le n$，将长度为 $n-w+1$ 的移动平均序列 $M$ 定义为\n$$\nM[i] \\;=\\; \\frac{1}{w} \\sum_{k=i}^{i+w-1} A[k], \\quad i \\in \\{0,\\dots,n-w\\}.\n$$\n在 EREW-PRAM 上实现时，根据“功-深度”模型推导您的移动平均算法的深度和功。您的推导应从前缀和的构造出发，并论证所需的额外步骤。\n\n测试套件和输出的实现要求。为了生成具体、可验证的输出：\n- 在为您的实现分析“功-深度”成本时，请采用以下与教科书中的 EREW 构造相匹配的标准实例化：\n\n  1) 通过在一个完全二叉树上执行上扫（归约）和下扫来计算一个排他性前缀和 $P$。该完全二叉树的叶子数量为下一个 2 的幂 $m$，满足 $m \\ge n$（使用零填充至长度 $m$）。将每个算术运算计为单位功。此排他性扫描的成本等于两次扫描中完成的算术运算总数，其深度是执行的并行层级数。\n\n  2) 使用恒等式\n  $$\n  M[i] \\;=\\; \\frac{P[i+w] - P[i]}{w}\n  $$\n  从 $P$ 计算移动平均值，该恒等式对所有有效的 $i$ 并行应用。将每次减法和每次除法计为一个单位功和一个同步步骤。总深度是扫描深度与这两个并行过程的深度之和。\n\n- 对于所有实数输出，四舍五入到 $6$ 位小数。\n- 对于所有输入，假定 $1 \\le w \\le n$ 和 $n \\ge 1$。\n\n您的程序必须实现上述要求，为以下 $(A,w)$ 对的测试套件生成输出：\n\n1) $A = [1,2,3,4,5,6,7,8]$, $w = 3$。\n\n2) $A = [42]$, $w = 1$。\n\n3) $A = [-2,0,5,-1,3]$, $w = 5$。\n\n4) $A = [0.5,-0.5,1.5,2.0]$, $w = 2$。\n\n5) $A = [3,1,4,1,5,9]$, $w = 4$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个列表。对于每个测试用例，输出一个包含两个元素的列表，其第一个元素是移动平均值列表（四舍五入到 $6$ 位小数），第二个元素是给出上述实例化下的总功和深度的双元素列表 $[W,D]$。整个输出必须打印为一个无空格的类 JSON 列表，例如：\n$[[\\dots,[W_1,D_1]],[\\dots,[W_2,D_2]],\\dots]$。", "solution": "我们从并行随机存取机（PRAM）、独占读独占写（EREW）约束和“功-深度”（WD）模型的定义开始。在 PRAM 模型下，同步处理器步调一致地执行；EREW 约束禁止对同一内存单元的同时读取或写入；而“功-深度”度量将总功定义为所有处理器上执行的基本操作的总数，将深度定义为在 EREW 约束下，假设处理器数量无限时的同步步骤数（最长依赖链）。\n\n推导并行前缀和。考虑一个长度为 $n$ 的序列 $A$。前缀和利用了加法的结合律。一个基本的构造方法是使用一个平衡二叉树，其叶子节点对应于 $A$ 的元素。为避免 $n$ 为任意值时的不均匀性，我们用零填充序列至长度 $m$，其中 $m$ 是满足 $m \\ge n$ 的最小的 2 的幂。该树有 $m$ 个叶子，高度为 $\\log_{2} m$。\n\n该构造过程分两个阶段进行：\n\n- 上扫（归约）：在层级 $\\ell \\in \\{1,\\dots,\\log_{2} m\\}$，成对的部分和相加来构建父节点的和。第一层有 $m/2$ 次加法，第二层有 $m/4$ 次，依此类推，直到根节点处的 1 次。加法总数为 $\\sum_{j=0}^{\\log_{2} m -1} m/2^{j+1} = m - 1$，深度为 $\\log_{2} m$，因为各层是顺序执行的。\n\n- 下扫（分发）：此阶段通过将左前缀值向下分发到树中来传播排他性前缀和：每个内部节点将其当前值发送给其左子节点，并将其当前值与左子节点原始子树和的总和发送给其右子节点。每个层级为右子节点的更新执行加法。加法总数同样为 $m - 1$，深度为 $\\log_{2} m$。\n\n将两个阶段相加，功为 $W_{\\text{scan}} = (m - 1) + (m - 1) = 2m - 2$，深度为 $D_{\\text{scan}} = \\log_{2} m + \\log_{2} m = 2 \\log_{2} m$。由于 $m \\le 2n$，我们有 $W_{\\text{scan}} \\in \\Theta(n)$ 和 $D_{\\text{scan}} \\in \\Theta(\\log n)$，满足 $O(n)$ 的功界限和 $O(\\log n)$ 的深度界限。这是一个 EREW-PRAM 算法，因为在每个层级，不相交的节点对被读取和写入，没有冲突。\n\n调整以计算移动平均值。将排他性前缀和 $P$ 定义为 $P[0] = 0$ 和 $P[i] = \\sum_{k=0}^{i-1} A[k]$，对于 $i \\in \\{1,\\dots,n\\}$（$P$ 自然地扩展到填充后的长度 $m$）。对于满足 $1 \\le w \\le n$ 的窗口长度 $w$，窗口 $A[i] + \\dots + A[i+w-1]$ 的和通过伸缩求和（telescoping）为 $P[i+w] - P[i]$。因此，移动平均值为\n$$\nM[i] \\;=\\; \\frac{P[i+w] - P[i]}{w}, \\quad i \\in \\{0,\\dots,n-w\\}.\n$$\n这 $n-w+1$ 个值可以通过一个同步减法步骤并行计算，以计算所有有效 $i$ 的 $P[i+w] - P[i]$（深度 1，功 $n-w+1$），然后通过一个同步除法步骤除以 $w$（深度 1，功 $n-w+1$）。完整算法的成本为：\n$$\nW \\;=\\; W_{\\text{scan}} + (n-w+1) + (n-w+1) \\;=\\; 2m - 2 + 2(n-w+1),\n$$\n$$\nD \\;=\\; D_{\\text{scan}} + 1 + 1 \\;=\\; 2 \\log_{2} m + 2,\n$$\n其中 $m$ 是满足 $m \\ge n$ 的最小的 2 的幂。由于 $m \\le 2n$，我们有 $W \\in \\Theta(n)$ 和 $D \\in \\Theta(\\log n)$，因此移动平均算法在 EREW-PRAM 上也实现了 $O(n)$ 的功和 $O(\\log n)$ 的深度。\n\n测试套件的数值输出。使用上述方法并将所有实数四舍五入到 $6$ 位小数：\n- 测试 1：$A = [1,2,3,4,5,6,7,8]$，$w = 3$，$n = 8$，$m = 8$。移动平均值为 $[2.000000,3.000000,4.000000,5.000000,6.000000,7.000000]$。成本：$W = 2 \\cdot 8 - 2 + 2 \\cdot (8-3+1) = 14 + 12 = 26$，$D = 2 \\log_{2} 8 + 2 = 6 + 2 = 8$。\n\n- 测试 2：$A = [42]$，$w = 1$，$n = 1$，$m = 1$。移动平均值为 $[42.000000]$。成本：$W = 2 \\cdot 1 - 2 + 2 \\cdot (1-1+1) = 0 + 2 = 2$，$D = 2 \\log_{2} 1 + 2 = 0 + 2 = 2$。\n\n- 测试 3：$A = [-2,0,5,-1,3]$，$w = 5$，$n = 5$，$m = 8$。移动平均值为 $[1.000000]$。成本：$W = 2 \\cdot 8 - 2 + 2 \\cdot (5-5+1) = 14 + 2 = 16$，$D = 2 \\log_{2} 8 + 2 = 6 + 2 = 8$。\n\n- 测试 4：$A = [0.5,-0.5,1.5,2.0]$，$w = 2$，$n = 4$，$m = 4$。移动平均值为 $[0.000000,0.500000,1.750000]$。成本：$W = 2 \\cdot 4 - 2 + 2 \\cdot (4-2+1) = 6 + 6 = 12$，$D = 2 \\log_{2} 4 + 2 = 4 + 2 = 6$。\n\n- 测试 5：$A = [3,1,4,1,5,9]$，$w = 4$，$n = 6$，$m = 8$。移动平均值为 $[2.250000,2.750000,4.750000]$。成本：$W = 2 \\cdot 8 - 2 + 2 \\cdot (6-4+1) = 14 + 6 = 20$，$D = 2 \\log_{2} 8 + 2 = 6 + 2 = 8$。\n\n最终答案中的程序实现了使用前缀和计算移动平均值，并使用上述实例化报告了相应的功和深度。它会打印一个无空格的类 JSON 列表，其中每个测试用例贡献一个由移动平均值列表和 $[W,D]$ 列表组成的对，所有实数都四舍五入到 $6$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef next_power_of_two(n: int) -> int:\n    \"\"\"Return the smallest power of two >= n for n >= 1.\"\"\"\n    if n == 1:\n        return 1\n    return 1 << (n - 1).bit_length()\n\ndef compute_work_depth(n: int, w: int) -> tuple[int, int]:\n    \"\"\"\n    Compute total work and depth under the specified EREW-PRAM instantiation:\n    - Exclusive scan via up-sweep and down-sweep over m = next_power_of_two(n),\n      with W_scan = 2*m - 2, D_scan = 2*log2(m).\n    - Then one parallel subtraction pass and one parallel division pass over\n      (n - w + 1) elements (each pass depth 1 and work n - w + 1).\n    \"\"\"\n    m = next_power_of_two(n)\n    W_scan = 2 * m - 2  # total arithmetic ops across both sweeps\n    # log2(m) since m is power of two equals bit_length-1\n    D_scan = 2 * (m.bit_length() - 1)\n    window_count = n - w + 1\n    W_total = W_scan + window_count + window_count\n    D_total = D_scan + 1 + 1\n    return W_total, D_total\n\ndef moving_average_via_prefix(A: list[float], w: int) -> list[float]:\n    \"\"\"\n    Compute moving averages using exclusive prefix sums:\n    M[i] = (P[i+w] - P[i]) / w where P[0] = 0 and P[k] = sum_{t=0}^{k-1} A[t].\n    Returns floats rounded only at formatting time; values are double precision.\n    \"\"\"\n    # Exclusive prefix sums: P[0]=0, P[i+1]=P[i]+A[i]\n    P = [0.0]\n    s = 0.0\n    for x in A:\n        s += float(x)\n        P.append(s)\n    n = len(A)\n    res = []\n    for i in range(0, n - w + 1):\n        window_sum = P[i + w] - P[i]\n        res.append(window_sum / float(w))\n    return res\n\ndef format_no_spaces(value):\n    \"\"\"\n    Format nested lists of ints/floats without spaces.\n    Floats are rendered with exactly 6 decimal places.\n    \"\"\"\n    if isinstance(value, list):\n        return \"[\" + \",\".join(format_no_spaces(v) for v in value) + \"]\"\n    # Handle numpy scalar types\n    if isinstance(value, (np.floating,)):\n        return f\"{float(value):.6f}\"\n    if isinstance(value, (np.integer,)):\n        return str(int(value))\n    if isinstance(value, float):\n        return f\"{value:.6f}\"\n    if isinstance(value, int):\n        return str(value)\n    # Fallback: convert to float if possible\n    try:\n        fv = float(value)\n        return f\"{fv:.6f}\"\n    except Exception:\n        return str(value)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Each case is (A, w)\n        ([1, 2, 3, 4, 5, 6, 7, 8], 3),\n        ([42], 1),\n        ([-2, 0, 5, -1, 3], 5),\n        ([0.5, -0.5, 1.5, 2.0], 2),\n        ([3, 1, 4, 1, 5, 9], 4),\n    ]\n\n    results = []\n    for A, w in test_cases:\n        n = len(A)\n        # Compute moving averages via prefix sums\n        mavgs = moving_average_via_prefix(A, w)\n        # Compute work and depth according to the specified model\n        W, D = compute_work_depth(n, w)\n        # Round moving averages at formatting time; store as floats\n        results.append([mavgs, [W, D]])\n\n    # Final print statement in the exact required format: no spaces.\n    print(format_no_spaces(results))\n\nsolve()\n```", "id": "3258324"}, {"introduction": "许多问题，例如寻找最长公共子序列（LCS），传统上使用动态规划（DP）来解决，这似乎是顺序的。然而，我们可以利用其依赖结构进行并行化。这个练习 [@problem_id:3258264] 介绍了强大的“波前”或“反斜线”方法，这是在 CREW PRAM 模型上并行化 DP 问题的一种常见模式，让你学会识别并利用计算中的并行性。", "problem": "在并行随机存取机 (PRAM) 模型下，设计并分析一个并行算法，用于计算两个等长字符串的最长公共子序列 (LCS) 长度。您的算法必须针对 PRAM 的并发读取独占写入 (CREW) 变体（Concurrent Read Exclusive Write (CREW) PRAM）进行指定，并在“工作-深度”(WD) 模型中进行分析，其中总工作量用 $W$ 表示，深度（也称为跨度或关键路径长度）用 $D$ 表示。“工作-深度”(WD) 模型将 $W$ 解释为原始操作的总数，将 $D$ 解释为算法有向无环图中​​最长依赖链的长度。\n\n从以下基本前提开始：\n- 两个字符串之间的 LCS 长度可以通过一个动态规划表 $D[i,j]$ 计算，该表定义在索引 $i \\in \\{0,\\dots,n\\}$ 和 $j \\in \\{0,\\dots,n\\}$ 上，边界条件为 $D[0,j] = 0$ 和 $D[i,0] = 0$。$D[i,j]$ 的依赖项完全来自 $D[i-1,j-1]$、$D[i-1,j]$ 和 $D[i,j-1]$ 这些条目。\n- 在 CREW PRAM 模型中，多个处理器可以在同一步骤中读取同一内存位置，但在一个步骤中最多只能有一个处理器写入任何内存位置。\n- 在“工作-深度”(WD) 模型中，$W$ 是所有处理器执行的操作总数，$D$ 是沿最长依赖链的并行步骤数。如果有 $p$ 个处理器可用，一个理想化的调度器可以得出量级为 $W/p + D$ 的运行时间上界。\n\n任务：\n1. 提出了一个并行算法，该算法在 CREW PRAM 上利用反对角线（波前）调度，通过其依赖结构来计算 LCS 的动态规划表。请精确描述每一步的计算过程以及同一反对角线内单元格之间的独立性。\n2. 对于长度为 $n$ 的等长输入，仅使用上述基本前提推导出工作量 $W(n)$ 和深度 $D(n)$。\n3. 实现一个程序，对于下面给定的一个固定的等长字符串对测试套件，计算：\n   - 使用与 CREW PRAM 假设一致的反对角线调度计算 LCS 长度，\n   - 对每个测试用例，计算推导出的 $W(n)$ 和 $D(n)$，其中 $n$ 是该字符串对的公共长度。\n4. 边界条件：如果 $n = 0$，则定义深度为 $D(0) = 0$，工作量为 $W(0) = 0$。\n5. 用于覆盖正确性和分析方面的测试套件：\n   - 案例 A (小型，不匹配): $(\"a\",\"b\")$，其中 $n = 1$。\n   - 案例 B (小型，相同): $(\"abc\",\"abc\")$，其中 $n = 3$。\n   - 案例 C (中型，部分重叠): $(\"abcde\",\"acebd\")$，其中 $n = 5$。\n   - 案例 D (统一，不相交): $(\"aaaa\",\"bbbb\")$，其中 $n = 4$。\n   - 案例 E (经典，丰富): $(\"XMJYAUZQ\",\"MZJAWXUQ\")$，其中 $n = 8$。\n6. 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例以三元组 $[\\ell, W, D]$ 的形式报告，其中 $\\ell$ 是 LCS 长度，$W$ 和 $D$ 是根据给定 $n$ 的分析得出的整数。该行中任何地方都不得有空格。对于上述五个按顺序排列的案例，输出格式为：\n   - $[[\\ell_1,W_1,D_1],[\\ell_2,W_2,D_2],[\\ell_3,W_3,D_3],[\\ell_4,W_4,D_4],[\\ell_5,W_5,D_5]]$。\n\n所有答案纯粹是数学或算法性质的，不带任何物理单位。不涉及角度。不涉及百分比。测试套件的最终输出必须是整数。", "solution": "计算两个字符串的最长公共子序列 (LCS) 是一个经典的动态规划问题。给定两个长度均为 $n$ 的字符串，$X = x_1x_2...x_n$ 和 $Y = y_1y_2...y_n$。任务是为 CREW PRAM 模型设计并分析一个并行算法，以找出它们 LCS 的长度。\n\n设 $D[i,j]$ 表示前缀 $X[1..i]$ 和 $Y[1..j]$ 的 LCS 长度，其中索引 $i$ 和 $j$ 的范围是从 $0$ 到 $n$。动态规划公式由以下递推关系定义：\n$$\nD[i,j] =\n\\begin{cases}\n  0  &\\text{如果 } i=0 \\text{ 或 } j=0 \\\\\n  D[i-1,j-1] + 1  &\\text{如果 } i,j > 0 \\text{ 且 } x_i = y_j \\\\\n  \\max(D[i-1,j], D[i,j-1])  &\\text{如果 } i,j > 0 \\text{ 且 } x_i \\neq y_j\n\\end{cases}\n$$\n值 $D[n,n]$ 给出了完整字符串 $X$ 和 $Y$ 的最终 LCS 长度。\n\n此递推关系的依赖结构表明，$D[i,j]$ 的计算需要单元格 $(i-1,j-1)$、$(i-1,j)$ 和 $(i,j-1)$ 的值。这种结构表明，按行或按列进行简单的并行化是不可行的，因为一行/列中的每个单元格都依赖于同一行/列中的前一个单元格。\n\n### 第 1 部分：使用反对角线波前调度的并行算法\n\n一种合适的并行化策略是反对角线或波前方法。我们可以根据索引之和将 DP 表 $D$ 的单元格分组。一条反对角线，记为 $A_k$，是所有满足 $i+j=k$（其中 $1 \\le i, j \\le n$）的单元格 $(i,j)$ 的集合。\n\n关键的观察是，给定反对角线 $A_k$ 上的所有单元格 $D[i,j]$ 可以在一个并行步骤中同时计算。这是因为它们的依赖项——$D[i-1,j-1]$、$D[i-1,j]$ 和 $D[i,j-1]$——都属于之前的反对角线。具体来说，对于一个单元格 $(i,j) \\in A_k$：\n- 依赖项 $(i-1, j-1)$ 位于反对角线 $A_{k-2}$ 上，因为 $(i-1)+(j-1) = k-2$。\n- 依赖项 $(i-1, j)$ 和 $(i, j-1)$ 位于反对角线 $A_{k-1}$ 上，因为 $(i-1)+j = k-1$ 且 $i+(j-1) = k-1$。\n\n因此，如果直到 $A_{k-1}$ 的所有反对角线的值都已计算完毕，那么 $A_k$ 的所有值都可以并行计算，它们之间没有任何数据依赖。该算法以“波前”的形式从 DP 表的左上角向右下角推进。\n\nCREW PRAM 的算法如下：\n1.  **初始化**：对所有 $i \\in \\{0, \\dots, n\\}$ 设置 $D[i,0] = 0$，对所有 $j \\in \\{0, \\dots, n\\}$ 设置 $D[0,j] = 0$。这可以用 $2n+1$ 个处理器在一个并行步骤中完成，或者被视为一个耗时 $O(1)$ 的预计算步骤。\n2.  **迭代计算**：反对角线索引 $k=i+j$ 的范围从单元格 $(1,1)$ 对应的 $k=2$ 到单元格 $(n,n)$ 对应的 $k=2n$。算法以离散的时间步 $s = 1, 2, \\dots, 2n-1$ 进行。\n    - 对于从 $1$ 到 $2n-1$ 的每一步 $s$：\n        - 设反对角线索引为 $k = s+1$。\n        - 对于反对角线 $A_k$ 上的每个单元格 $(i,j)$（即所有满足 $i+j=k$ 且 $1 \\le i,j \\le n$ 的 $(i,j)$），分配一个处理器。\n        - 为 $(i,j)$ 分配的处理器执行以下操作：\n            - **读取**：它从共享内存中读取 $D[i-1,j-1]$、$D[i-1,j]$ 和 $D[i,j-1]$ 的值。它还读取字符 $x_i$ 和 $y_j$。同一反对角线上不同单元格的多个处理器可能会读取相同的值（例如，处理 $(i,j)$ 的处理器和处理 $(i-1, j+1)$ 的处理器都读取 $D[i-1,j]$）。这在并发读取 (CR) 规则下是允许的。\n            - **计算**：它使用 LCS 递推关系计算 $D[i,j]$ 的值。\n            - **写入**：它将计算出的值写入 $D[i,j]$ 的内存位置。由于在当前步骤中每个处理器都被分配给一个唯一的单元格 $(i,j)$，因此没有两个处理器会尝试写入同一个内存位置。这符合独占写入 (EW) 规则。\n\n3.  **结果**：在对应于 $k=2n$ 的最后一步之后，值 $D[n,n]$ 即为 LCS 长度。\n\n### 第 2 部分：工作量和深度分析\n\n我们在“工作-深度”(WD) 模型中分析该算法，针对长度为 $n$ 的字符串。\n\n**深度 ($D(n)$)**：\n并行算法的深度是最长顺序依赖链的长度，这对应于并行步骤的数量。在我们的反对角线算法中，每一步计算一条完整的反对角线。在一个步骤内，每个单元格的计算是常数时间操作，因此每个并行步骤耗时 $O(1)$。总步骤数由必须计算的反对角线数量决定。\n反对角线由 $k=i+j$ 索引，其中 $1 \\le i,j \\le n$。索引 $k$ 的范围从 $1+1=2$ 到 $n+n=2n$。这样的反对角线数量为 $(2n) - 2 + 1 = 2n-1$。\n因此，有 $2n-1$ 个顺序步骤。\n- 对于 $n \\ge 1$，深度为 $D(n) = 2n-1$。\n- 根据问题陈述，对于 $n=0$，表格为空，无需计算，因此 $D(0)=0$。\n\n**工作量 ($W(n)$)**：\n工作量是所有处理器执行的基本操作总数。核心计算涉及填充 DP 表的 $n \\times n$ 网格（索引从 $1$ 到 $n$）。对于 $n^2$ 个单元格中的每一个，我们都执行常数数量的操作：字符比较、读取最多 $3$ 个值、一次可能的加法和一次取最大值操作。\n在“工作-深度”模型中，通常将工作量定义为主要计算任务的总数。在这里，任务是更新单个单元格 $D[i,j]$。由于对于 $1 \\le i,j \\le n$ 有 $n^2$ 个这样的单元格需要计算，总工作量与 $n^2$ 成正比。通过将比例常数设为 $1$（即，将每个单元格更新计为一个工作单位），我们得到：\n- 对于 $n \\ge 0$，工作量为 $W(n) = n^2$。\n\n这与 $W(0)=0$ 的边界条件一致。\n\n总结分析如下：\n- 工作量：$W(n) = n^2$\n- 深度：对于 $n \\ge 1$，$D(n) = 2n-1$；对于 $n=0$，$D(0)=0$。\n\n### 第 3 和 4 部分：实现与测试用例\n\n实现将使用标准的顺序动态规划算法计算 LCS 长度，因为其结果与并行算法的结果相同。然后，它将对每个测试用例使用推导出的公式计算 $W(n)$ 和 $D(n)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes LCS length, Work (W), and Depth (D) for a test suite\n    of string pairs based on a CREW PRAM anti-diagonal algorithm.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"a\", \"b\"),            # Case A\n        (\"abc\", \"abc\"),        # Case B\n        (\"abcde\", \"acebd\"),    # Case C\n        (\"aaaa\", \"bbbb\"),      # Case D\n        (\"XMJYAUZQ\", \"MZJAWXUQ\")  # Case E\n    ]\n\n    results = []\n    for s1, s2 in test_cases:\n        n = len(s1)\n        \n        # Part 4: Handle edge conditions (although not present in test suite)\n        if n == 0:\n            lcs_len = 0\n            W = 0\n            D = 0\n        else:\n            # Part 2: Derive Work and Depth\n            # Work W(n) is the total number of cells to compute.\n            W = n * n\n            # Depth D(n) is the number of anti-diagonals to process.\n            D = 2 * n - 1\n\n            # Part 3: Compute LCS length\n            # The LCS length is computed using a standard dynamic programming\n            # approach, which fills the table in an order consistent with\n            # the dependencies of the anti-diagonal schedule.\n            dp_table = np.zeros((n + 1, n + 1), dtype=int)\n            \n            for i in range(1, n + 1):\n                for j in range(1, n + 1):\n                    if s1[i - 1] == s2[j - 1]:\n                        dp_table[i, j] = dp_table[i - 1, j - 1] + 1\n                    else:\n                        dp_table[i, j] = max(dp_table[i - 1, j], dp_table[i, j - 1])\n            \n            lcs_len = dp_table[n, n]\n\n        results.append([lcs_len, W, D])\n\n    # Part 6: Format the output as specified, with no spaces.\n    # e.g., [[l1,W1,D1],[l2,W2,D2],...]\n    output_parts = [f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]\n    final_output = f\"[{','.join(output_parts)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "3258264"}, {"introduction": "理解不同并行模型的能力和局限性与设计算法本身同样重要。本练习 [@problem_id:3258271] 探讨了一个更理论化的问题：如何在功能较弱的模型上模拟功能更强的模型？通过在 CREW PRAM 上模拟 Priority CRCW PRAM 的并发写入，你将量化处理写入冲突的代价（以功和深度衡量），从而更深刻地理解并行机模型中的权衡。", "problem": "要求您形式化并实现一个确定性模拟，该模拟在一个并发读互斥写并行随机存取机 (CREW PRAM) 上仿真一个优先并发读并发写并行随机存取机 (Priority CRCW PRAM) 的单次并行写入步骤，然后量化此仿真所导致的工作量和深度的扩张。并行随机存取机 (PRAM) 被定义为一个同步并行模型，它拥有一个共享内存和一组以锁步方式执行的处理器。在优先 CRCW PRAM 中，多个处理器可以读取同一个内存单元，也可以同时尝试写入同一个内存单元；在发生写冲突时，具有最小标识符的处理器获胜（此为优先规则），其值将被写入。在 CREW PRAM 中，多个处理器可以并发地从同一个单元读取，但对任何一个单元的写入必须是互斥的，即在一步中最多只有一个处理器可以写入一个给定的单元。\n\n您必须使用的基本定义：\n- 工作量-深度模型：对于一个并行算法，所有处理器执行的基本操作（如读取、写入和比较）总数是工作量，记为 $W$，而最长数据依赖链的长度（理想调度下的并行时间）是深度，记为 $D$。\n- 要计算的基本操作：在此仿真中，将每次比较和每次内存写入计为 $1$ 个单位的工作量；并发读取是允许的，除了执行比较所必需的读取外，不计入工作量。您必须将单个 CRCW 步骤视为每个尝试写入的处理器执行一次写入操作，无论是否存在写冲突；因此，对于有 $P$ 个处理器尝试写入的单个步骤，CRCW 的工作量为 $W_{\\text{CRCW}} = P$，该步骤的 CRCW 深度为 $D_{\\text{CRCW}} = 1$。\n\n任务：\n- 对于每个内存地址 $a$，假设在 CRCW 步骤中尝试写入 $a$ 的处理器集合为 $S_a$，其大小为 $k_a = |S_a|$。通过使用一个以平衡二叉树形式组织的两两比较的确定性锦标赛树，在 $k_a$ 个竞争者中进行仲裁，以在 CREW 上仿真优先 CRCW 写入。此仲裁确定 $S_a$ 中最小的处理器标识符。只有该获胜者才能对 $a$ 执行互斥写入。\n- 对于地址 $a$ 的仲裁，计算其贡献的工作量为 $k_a - 1$ 次比较加上 $1$ 次写入，贡献的深度为 $\\lceil \\log_2(k_a) \\rceil + 1$（对于 $k_a \\ge 1$ 的情况；如果 $k_a = 0$，则深度为零）。总仿真深度 $D_{\\text{CREW}}$ 是所有地址的单位地址深度的最大值。总仿真工作量 $W_{\\text{CREW}}$ 是所有 $k_a \\ge 1$ 的地址的单位地址工作量的总和。\n\n计算并报告：\n- 仿真步骤后每个内存地址的最终内容（没有写入者的地址值保持为 $0$）。\n- 深度扩张率，定义为 $D_{\\text{CREW}} / D_{\\text{CRCW}}$。\n- 工作量扩张率，定义为 $W_{\\text{CREW}} / W_{\\text{CRCW}}$。\n\n您的程序必须为以下测试套件实现上述仿真。每个测试用例提供处理器数量 $P$、内存地址数量 $M$ 以及一个写入尝试列表，每个尝试指定为三元组 $(\\text{proc\\_id}, \\text{address}, \\text{value})$。处理器标识符是 $\\{0,1,\\dots,P-1\\}$ 中的不同整数，地址是 $\\{0,1,\\dots,M-1\\}$ 中的整数。初始内存内容全为 $0$。\n\n测试套件：\n- 案例 1：$P=8$, $M=5$, 写入操作 $\\{(0,0,10),(1,2,20),(2,0,5),(3,3,7),(4,2,15),(5,4,9),(6,0,12),(7,3,8)\\}$。\n- 案例 2：$P=4$, $M=4$, 写入操作 $\\{(0,0,11),(1,1,22),(2,2,33),(3,3,44)\\}$。\n- 案例 3：$P=6$, $M=3$, 写入操作 $\\{(0,1,100),(1,1,200),(2,1,300),(3,1,400),(4,1,500),(5,1,600)\\}$。\n- 案例 4：$P=1$, $M=2$, 写入操作 $\\{(0,0,7)\\}$。\n\n输出规范：\n- 对于每个测试用例，生成一个列表，其前两个条目分别是深度扩张率 $D_{\\text{CREW}} / D_{\\text{CRCW}}$（浮点数或整数）和工作量扩张率 $W_{\\text{CREW}} / W_{\\text{CRCW}}$（浮点数），随后是地址 $0$ 到 $M-1$ 的最终内存内容（整数）。将所有测试用例的结果聚合到单行输出中，该输出包含一个用方括号括起来的逗号分隔列表，且不含空格，例如 $[[\\dots],[\\dots],[\\dots],[\\dots]]$。", "solution": "该任务要求在一个并发读互斥写（CREW）PRAM 上仿真一个优先并发读并发写（CRCW）PRAM 的单次写入步骤。我们必须量化由此产生的工作量（$W$）和深度（$D$）的变化，并确定内存的最终状态。\n\n根据问题定义，原始单个 CRCW 步骤的成本为：\n- 工作量 $W_{\\text{CRCW}} = N_w$，其中 $N_w$ 是尝试写入的处理器总数。\n- 深度 $D_{\\text{CRCW}} = 1$。\n\n在 CREW PRAM 上的仿真通过独立解决每个内存地址的写冲突来进行。对于给定的内存地址 $a$，设 $S_a$ 是尝试向其写入的处理器集合，并设 $k_a = |S_a|$ 为竞争者数量。优先 CRCW 规则规定，$S_a$ 中标识符最小的处理器获胜。\n\n在每个 $k_a > 0$ 的地址 $a$ 上的仿真算法如下：\n1. 在 $k_a$ 个竞争者之间举行一场锦标赛，以找到处理器ID最小的一个。这被构建为一个两两比较的平衡二叉树。这需要 $\\lceil \\log_2(k_a) \\rceil$ 个并行比较步骤。\n2. 获胜的处理器对地址 $a$ 执行一次互斥写入。这需要 $1$ 步。\n\n此仿真的成本定义如下：\n- 单位地址工作量 $W_a$：对于 $k_a \\ge 1$，这包括锦标赛中的 $k_a - 1$ 次比较和 $1$ 次最终写入，总计 $W_a = (k_a - 1) + 1 = k_a$。如果 $k_a = 0$，则 $W_a = 0$。\n- 单位地址深度 $D_a$：对于 $k_a \\ge 1$，这是锦标赛的深度 $\\lceil \\log_2(k_a) \\rceil$，加上最终写入的深度 $1$。因此，$D_a = \\lceil \\log_2(k_a) \\rceil + 1$。如果 $k_a = 0$，则 $D_a = 0$。\n\n总的 CREW 成本聚合如下：\n- 总 CREW 工作量：$W_{\\text{CREW}} = \\sum_{a} W_a = \\sum_{a} k_a$。由于总写入尝试次数 $N_w$ 也是 $\\sum_a k_a$，我们有 $W_{\\text{CREW}} = N_w = W_{\\text{CRCW}}$。这意味着工作量扩张率 $W_{\\text{CREW}} / W_{\\text{CRCW}}$ 始终为 $1$。\n- 总 CREW 深度：$D_{\\text{CREW}} = \\max_a D_a$。深度由写冲突最严重的地址决定。\n\n现在我们将此过程应用于每个测试用例。\n\n**案例 1：**\n- 已知条件：$P=8$, $M=5$。写入尝试： $\\{(0,0,10),(1,2,20),(2,0,5),(3,3,7),(4,2,15),(5,4,9),(6,0,12),(7,3,8)\\}$。\n- 共有 $N_w = 8$ 次写入尝试，所以 $W_{\\text{CRCW}} = 8$ 且 $D_{\\text{CRCW}} = 1$。\n- 按地址对写入进行分组：\n  - 地址 $0$：$\\{(0,10), (2,5), (6,12)\\}$。竞争者 $k_0 = 3$。\n  - 地址 $1$：无写入。$k_1 = 0$。\n  - 地址 $2$：$\\{(1,20), (4,15)\\}$。竞争者 $k_2 = 2$。\n  - 地址 $3$：$\\{(3,7), (7,8)\\}$。竞争者 $k_3 = 2$。\n  - 地址 $4$：$\\{(5,9)\\}$。竞争者 $k_4 = 1$。\n- 各地址分析：\n  - 地址 $0$：$k_0=3$。处理器ID为 $\\{0, 2, 6\\}$。获胜者是处理器 $0$，写入值 $10$。\n    - $W_0 = k_0 = 3$。\n    - $D_0 = \\lceil \\log_2(3) \\rceil + 1 = 2 + 1 = 3$。\n  - 地址 $1$：$k_1=0$。内存保持为 $0$。$W_1 = 0$, $D_1 = 0$。\n  - 地址 $2$：$k_2=2$。处理器ID为 $\\{1, 4\\}$。获胜者是处理器 $1$，写入值 $20$。\n    - $W_2 = k_2 = 2$。\n    - $D_2 = \\lceil \\log_2(2) \\rceil + 1 = 1 + 1 = 2$。\n  - 地址 $3$：$k_3=2$。处理器ID为 $\\{3, 7\\}$。获胜者是处理器 $3$，写入值 $7$。\n    - $W_3 = k_3 = 2$。\n    - $D_3 = \\lceil \\log_2(2) \\rceil + 1 = 1 + 1 = 2$。\n  - 地址 $4$：$k_4=1$。处理器ID为 $\\{5\\}$。获胜者是处理器 $5$，写入值 $9$。\n    - $W_4 = k_4 = 1$。\n    - $D_4 = \\lceil \\log_2(1) \\rceil + 1 = 0 + 1 = 1$。\n- 最终内存状态：$[10, 0, 20, 7, 9]$。\n- 总 CREW 成本：\n  - $W_{\\text{CREW}} = W_0+W_1+W_2+W_3+W_4 = 3+0+2+2+1 = 8$。\n  - $D_{\\text{CREW}} = \\max(D_0, D_1, D_2, D_3, D_4) = \\max(3, 0, 2, 2, 1) = 3$。\n- 扩张率因子：\n  - 深度扩张率：$D_{\\text{CREW}} / D_{\\text{CRCW}} = 3 / 1 = 3$。\n  - 工作量扩张率：$W_{\\text{CREW}} / W_{\\text{CRCW}} = 8 / 8 = 1$。\n- 案例 1 的结果：$[3, 1.0, 10, 0, 20, 7, 9]$。\n\n**案例 2：**\n- 已知条件：$P=4$, $M=4$。写入操作：$\\{(0,0,11),(1,1,22),(2,2,33),(3,3,44)\\}$。\n- $N_w = 4$，所以 $W_{\\text{CRCW}} = 4$ 且 $D_{\\text{CRCW}} = 1$。\n- 无写入冲突。地址 $\\{0,1,2,3\\}$ 中的每一个都只接收一次写入尝试。\n- 对于每个地址 $a \\in \\{0, 1, 2, 3\\}$，$k_a=1$。\n- 单位地址成本：$W_a = 1$，$D_a = \\lceil \\log_2(1) \\rceil + 1 = 1$。\n- 最终内存状态：$[11, 22, 33, 44]$。\n- 总 CREW 成本：$W_{\\text{CREW}} = 1+1+1+1 = 4$。$D_{\\text{CREW}} = \\max(1, 1, 1, 1) = 1$。\n- 扩张率因子：深度：$1 / 1 = 1$。工作量：$4 / 4 = 1$。\n- 案例 2 的结果：$[1, 1.0, 11, 22, 33, 44]$。\n\n**案例 3：**\n- 已知条件：$P=6$, $M=3$。写入操作：$\\{(0,1,100),(1,1,200),(2,1,300),(3,1,400),(4,1,500),(5,1,600)\\}$。\n- $N_w = 6$，所以 $W_{\\text{CRCW}} = 6$ 且 $D_{\\text{CRCW}} = 1$。\n- 所有 6 次写入都针对地址 1。\n- 地址 $0$：$k_0=0$。地址 $1$：$k_1=6$。地址 $2$：$k_2=0$。\n- 地址 1 的分析：$k_1=6$。处理器ID为 $\\{0, 1, 2, 3, 4, 5\\}$。获胜者是处理器 $0$，写入值 $100$。\n  - $W_1 = 6$。\n  - $D_1 = \\lceil \\log_2(6) \\rceil + 1 = 3 + 1 = 4$。\n- 最终内存状态：$[0, 100, 0]$。\n- 总 CREW 成本：$W_{\\text{CREW}} = 6$。$D_{\\text{CREW}} = \\max(0, 4, 0) = 4$。\n- 扩张率因子：深度：$4 / 1 = 4$。工作量：$6 / 6 = 1$。\n- 案例 3 的结果：$[4, 1.0, 0, 100, 0]$。\n\n**案例 4：**\n- 已知条件：$P=1$, $M=2$。写入操作：$\\{(0,0,7)\\}$。\n- $N_w = 1$，所以 $W_{\\text{CRCW}} = 1$ 且 $D_{\\text{CRCW}} = 1$。\n- 一次对地址 0 的写入。\n- 地址 $0$：$k_0=1$。地址 $1$：$k_1=0$。\n- 地址 0 的分析：$k_0=1$。获胜者是处理器 $0$，值 $7$。\n  - $W_0=1$。\n  - $D_0 = \\lceil \\log_2(1) \\rceil + 1 = 0 + 1 = 1$。\n- 最终内存状态：$[7, 0]$。\n- 总 CREW 成本：$W_{\\text{CREW}} = 1$。$D_{\\text{CREW}} = 1$。\n- 扩张率因子：深度：$1 / 1 = 1$。工作量：$1 / 1 = 1$。\n- 案例 4 的结果：$[1, 1.0, 7, 0]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Simulates a Priority CRCW PRAM write step on a CREW PRAM for a suite of test cases.\n    Calculates final memory state, work blow-up, and depth blow-up.\n    \"\"\"\n    test_cases = [\n        {\n            \"P\": 8, \"M\": 5,\n            \"writes\": {(0, 0, 10), (1, 2, 20), (2, 0, 5), (3, 3, 7), (4, 2, 15), (5, 4, 9), (6, 0, 12), (7, 3, 8)}\n        },\n        {\n            \"P\": 4, \"M\": 4,\n            \"writes\": {(0, 0, 11), (1, 1, 22), (2, 2, 33), (3, 3, 44)}\n        },\n        {\n            \"P\": 6, \"M\": 3,\n            \"writes\": {(0, 1, 100), (1, 1, 200), (2, 1, 300), (3, 1, 400), (4, 1, 500), (5, 1, 600)}\n        },\n        {\n            \"P\": 1, \"M\": 2,\n            \"writes\": {(0, 0, 7)}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        M = case[\"M\"]\n        writes = case[\"writes\"]\n\n        # Base CRCW costs\n        # W_CRCW is the number of processors attempting a write\n        W_crcw = len(writes)\n        # D_CRCW for a single step is 1\n        D_crcw = 1\n\n        # Group write attempts by memory address\n        writes_by_address = defaultdict(list)\n        for proc_id, address, value in writes:\n            writes_by_address[address].append((proc_id, value))\n\n        # Initialize CREW emulation metrics\n        memory = [0] * M\n        W_crew = 0\n        D_crew = 0\n\n        # Process each address to resolve conflicts\n        for address, contenders in writes_by_address.items():\n            k_a = len(contenders)\n            if k_a == 0:\n                continue\n\n            # Apply priority rule: smallest processor ID wins\n            winner = min(contenders, key=lambda x: x[0])\n            winning_proc_id, winning_value = winner\n            memory[address] = winning_value\n\n            # Calculate work for this address's emulation\n            # W_a = (k_a - 1) comparisons + 1 write = k_a\n            W_a = k_a\n            W_crew += W_a\n\n            # Calculate depth for this address's emulation\n            # D_a = ceil(log2(k_a)) for tournament + 1 for write\n            # np.log2(1) is 0, np.ceil(0) is 0, so formula works for k_a=1\n            if k_a == 1:\n                D_a = 1\n            else:\n                D_a = np.ceil(np.log2(k_a)) + 1\n            \n            if D_crew  D_a:\n                D_crew = D_a\n\n        # If there were no writes at all, depth is 0\n        if not writes:\n            D_crew = 0\n            \n        # The problem states D_a is zero if k_a=0. D_crew is max of all D_a.\n        # This is handled by initializing D_crew=0 and only updating if a larger D_a is found.\n\n        # Calculate blow-up factors\n        depth_blowup = float(D_crew / D_crcw) if D_crcw != 0 else 0.0\n        work_blowup = float(W_crew / W_crcw) if W_crcw != 0 else 0.0\n\n        # Assemble the result for this test case\n        case_result = [depth_blowup, work_blowup] + memory\n        # Handle cases where depth blowup is an integer, output as int or float\n        if case_result[0].is_integer():\n             case_result[0] = int(case_result[0])\n        results.append(case_result)\n\n\n    # Format final output string as per problem specification\n    # e.g., [[res1_item1,res1_item2,...],[res2_item1,res2_item2,...]]\n    inner_strings = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3258271"}]}