{"hands_on_practices": [{"introduction": "矩阵转置是一项基本的线性代数运算，但其实现方式是内存访问效率的一个经典案例。本练习 [@problem_id:3208160] 要求您比较一种简单的嵌套循环方法与一种缓存无关的分治算法。通过分析它们的块传输成本，您将具体理解为何跨步内存访问（strided memory access）会损害性能，以及递归分解如何自然地增强空间局部性。", "problem": "给出两种算法，用于将一个以行主序存储的 $N \\times N$ 矩阵 $A$ 转置到一个独立的矩阵 $B$（也以行主序存储）中，其中每个元素占用一个单位的存储空间。内存由理想缓存模型建模：一个大小为 $M$ 个元素的全相联缓存，块大小为 $B$ 个元素，并采用最优替换策略。每次缓存未命中（miss）会从主存和缓存之间传输恰好一个包含 $B$ 个连续元素的块。计算每种算法产生的块传输（缓存未命中）次数。假设满足高缓存（tall-cache）条件 $M = \\Omega(B^2)$，并且 $N$ 渐近地大于 $M/B$（即，存在一个常数 $\\alpha > 0$，使得对于所有足够大的 $N$，都有 $N \\ge \\alpha \\cdot M/B$）。\n\n算法描述：\n- 朴素转置：\n  对于 $i$ 从 $0$ 到 $N - 1$：\n    对于 $j$ 从 $0$ 到 $N - 1$：\n      设置 $B[j][i] \\leftarrow A[i][j]$。\n- 缓存无关转置：\n  一种分治算法，通过将矩阵划分为子矩阵，递归地将问题分解为子问题，并在这些子矩阵上进行递归，直到达到常数大小的基本情况，且没有任何参数依赖于 $M$ 或 $B$。\n\n从第一性原理出发，对两种算法的访问模式进行建模，并选择能够正确描述其在上述假设下，作为 $N$、$B$ 和 $M$ 的函数，其块传输次数的渐近数量（忽略常数因子和低阶项）的选项。\n\nA. 朴素算法产生 $\\Theta(N^2)$ 次块传输，而缓存无关算法产生 $\\Theta(N^2 / B)$ 次块传输。\n\nB. 朴素算法和缓存无关算法都产生 $\\Theta(N^2 / B)$ 次块传输。\n\nC. 朴素算法读取 $A$ 产生 $\\Theta(N^2 / B)$ 次块传输，写入 $B$ 产生 $\\Theta(N^2 / B)$ 次块传输，总计 $\\Theta(N^2 / B)$，而缓存无关算法产生 $\\Theta(N^2 / (B \\sqrt{M}))$ 次块传输。\n\nD. 朴素算法产生 $\\Theta(N^2)$ 次块传输，而缓存无关算法由于递归开销产生 $\\Theta((N^2 \\log N) / B)$ 次块传输。", "solution": "用户希望对两种矩阵转置算法的缓存复杂度进行详细分析。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- **矩阵**：一个 $N \\times N$ 的矩阵 $A$ 被转置成一个 $N \\times N$ 的矩阵 $B$。\n- **数据布局**：$A$ 和 $B$ 都以行主序存储。\n- **元素大小**：每个元素占用一个单位的存储空间。\n- **缓存模型**：理想缓存模型，具有以下参数：\n    - 全相联。\n    - 缓存大小：$M$ 个元素。\n    - 块大小：$B$ 个元素。\n    - 替换策略：最优。\n- **块传输**：一次缓存未命中会传输一个包含 $B$ 个连续元素的块。\n- **目标**：计算两种算法的块传输（缓存未命中）次数。\n- **假设**：\n    1.  高缓存条件：$M = \\Omega(B^2)$，这意味着存在一个常数 $c > 0$，使得对于足够大的 $B$，有 $M \\ge cB^2$。\n    2.  大矩阵条件：$N$ 渐近地大于 $M/B$。具体来说，存在一个常数 $\\alpha > 0$，使得对于所有足够大的 $N$，都有 $N \\ge \\alpha \\cdot M/B$。\n- **算法 1 (朴素转置)**：\n  ```\n  For i from 0 to N-1:\n    For j from 0 to N-1:\n      Set $B[j][i] \\leftarrow A[i][j]$.\n  ```\n- **算法 2 (缓存无关转置)**：\n  - 一种分治算法。\n  - 递归地将矩阵划分为子矩阵。\n  - 递归持续进行，直到达到常数大小的基本情况。\n  - 算法的结构不依赖于缓存参数 $M$ 或 $B$。\n\n**步骤 2：使用提取的已知条件进行验证**\n问题陈述是分析缓存感知和缓存无关算法的一个标准练习，这是计算机科学和高性能计算中的一个基本主题。\n- **科学性**：问题基于公认的理想缓存模型、行主序内存布局和标准算法范式。这些都是算法分析的核心概念。不存在伪科学。\n- **适定性**：问题定义清晰。它要求计算块传输的渐近数量，这在给定的模型和假设下是一个具体、可解的量。所提供的假设（高缓存、大 $N$）是此类分析的标准假设，确保问题聚焦于渐近有趣的案例。\n- **客观性**：语言精确、数学化，没有主观性。\n- **不完整或矛盾的设置**：问题是自洽的，并提供了分析所需的所有定义和约束。没有矛盾之处。\n- **不切实际或不可行**：虽然理想缓存模型是对真实硬件的简化，但它是一个理论上合理且广泛用于算法分析的模型。该问题是一个理论练习，因此物理真实性不是首要关注点。\n- **不适定或结构不良**：问题结构良好。对算法的描述足以对其内存访问模式进行渐近分析。\n\n**步骤 3：结论与行动**\n问题陈述是**有效的**。可以进行分析。\n\n### 解题推导\n\n目标是确定每种算法的缓存未命中次数的渐近数量。当请求的内存地址不在缓存中时，就会发生缓存未命中，这需要从主存传输一个大小为 $B$ 个元素的块。\n\n**朴素转置算法分析**\n\n该算法由嵌套循环结构给出：\n```\nFor i from 0 to N-1:\n  For j from 0 to N-1:\n    $B[j][i] \\leftarrow A[i][j]$\n```\n我们分别分析从矩阵 $A$ 读取和向矩阵 $B$ 写入的内存访问。两个矩阵都以行主序存储，这意味着对于一个 $N \\times N$ 矩阵 $X$，元素 $X[r][c]$ 位于距矩阵基地址 $r \\times N + c$ 的内存偏移处。\n\n1.  **从矩阵 $A$ 读取**：\n    算法按顺序访问 $A$ 的元素：$A[0][0], A[0][1], \\dots, A[0][N-1]$，然后是 $A[1][0], \\dots, A[1][N-1]$，依此类推。对于任何固定的行 $i$，内层关于 $j$ 的循环会扫描元素 $A[i][0], \\dots, A[i][N-1]$。由于行主序布局，这些元素在内存中是连续存储的。这是一种顺序扫描。\n    - 每次缓存未命中会将一个包含 $B$ 个元素的块带入缓存。\n    - 要读取一行完整的 $N$ 个元素，必须传输 $\\lceil N/B \\rceil$ 个块。\n    - 由于对 $N$ 行中的每一行都执行此操作，读取整个 $A$ 的总未命中次数为 $N \\times \\lceil N/B \\rceil$。\n    - 渐近地，这是 $\\Theta(N^2/B)$。这种访问模式表现出极好的空间局部性。\n\n2.  **向矩阵 $B$ 写入**：\n    算法按顺序写入 $B$ 的元素：$B[0][0], B[1][0], \\dots, B[N-1][0]$，然后是 $B[0][1], \\dots, B[N-1][1]$，依此类推。对于任何固定的外层循环索引 $i$，内层关于 $j$ 的循环会写入元素 $B[0][i], B[1][i], \\dots, B[N-1][i]$。这些是矩阵 $B$ 的第 $i$ 列的元素。\n    - 在行主序中，$B[j][i]$ 的内存地址是 `base_B` $+ j \\times N + i$。下一个写入的元素 $B[j+1][i]$ 的地址是 `base_B` $+ (j+1) \\times N + i$。\n    - 连续内存访问之间的步长是 $N$ 个元素。\n    - 问题假设对于某个 $\\alpha > 0$，有 $N \\ge \\alpha \\cdot M/B$。这意味着 $N$ 很大。在这种分析相关的典型场景中，单列在内存中的大小（整个列的地址空间为 $N \\times N$，尽管只有 $N$ 个元素）远远超过缓存大小 $M$。\n    - 当步长 $N$ 大于块大小 $B$ 时，每次访问 `B[j][i]` 和 `B[j+1][i]` 都会落入不同的缓存块中。\n    - 此外，如果在遍历一列期间接触到的不同块的总数超过了缓存的容量（$M/B$），那么块在被重用之前就会被驱逐。内层循环中的第 $j$ 次访问（对于固定的 $i$）会接触一个块。第 $(j+1)$ 次访问会接触到 $N$ 字节之外的一个块。到我们访问足够多的元素以至于可能重用一个块时（反正这种访问模式下不会发生），我们至少已经引入了 $M/B$ 个其他块，导致驱逐。\n    - 因此，对一列进行的 $N$ 次写入中的每一次都会导致一次缓存未命中。由于外层循环运行 $N$ 次，写入 $B$ 的总未命中次数是 $N \\times N = N^2$。\n    - 渐近地，这是 $\\Theta(N^2)$。这种访问模式表现出极差的空间局部性。\n\n**朴素转置的总未命中次数**：\n总块传输次数是读取 $A$ 和写入 $B$ 的未命中次数之和：\n$$ \\text{Total Misses} = \\Theta(N^2/B) + \\Theta(N^2) = \\Theta(N^2) $$\n写入 $B$ 的成本主导了整体复杂度。\n\n**缓存无关转置算法分析**\n\n该算法使用分治策略。一个 $N \\times N$ 的矩阵被划分为四个 $(N/2) \\times (N/2)$ 的子矩阵。然后通过递归地转置这些子矩阵来执行转置操作。\n对于一个 $n \\times n$ 的子问题，缓存未命中次数 $Q(n)$ 的递推关系如下：\n- 如果子问题很大，无法放入缓存，则将问题分解。转置一个 $n \\times n$ 的矩阵涉及对 $(n/2) \\times (n/2)$ 的子矩阵进行四次递归调用。所以，$Q(n) = 4Q(n/2)$。\n- 如果子问题足够小，可以放入缓存，递归实际上就停止了，子问题将以最优的内存传输次数解决。\n\n让我们确定基本情况的大小。一个关于 $n \\times n$ 子矩阵的递归子问题需要访问 $A$ 的一个 $n \\times n$ 部分和 $B$ 的一个 $n \\times n$ 部分。这些子矩阵不是连续的内存块。一个 $n\\times n$ 的子矩阵由 $n$ 个独立的行段组成，每个行段长度为 $n$。\n- 一个这样的 $n \\times n$ 子矩阵所占用的块数大约是 $n \\times \\lceil n/B \\rceil$。对于 $n>B$，这是 $\\Theta(n^2/B)$。对于 $n \\le B$，这是 $\\Theta(n)$。\n- 递归的基本情况发生在子问题足够小，以至于其组成部分（来自 $A$ 和 $B$）能同时放入缓存中。这使得小型转置能够以最大的数据重用率执行。\n- 让我们找出能使来自 $A$ 的一个 $n \\times n$ 子问题和来自 $B$ 的一个子问题都放入缓存中的最大边长 $n$。所需的总块数大约是 $2 \\times (n \\cdot \\lceil n/B \\rceil)$。我们要求这个值小于缓存容量 $M/B$。\n- 使用高缓存假设 ($M = \\Omega(B^2)$)，我们知道当子问题的数据足迹（footprint）与缓存大小 $M$ 在同一数量级时，会发生转换。数据足迹大约是 $2n^2$ 个元素。所以，我们设定对于某个常数 $c$，有 $c \\cdot n^2 \\approx M$，这给出 $n \\approx \\sqrt{M}$。我们将这个临界大小表示为 $n_0 = \\Theta(\\sqrt{M})$。\n- 对于大小为 $n \\le n_0$ 的子问题，它可以很好地放入缓存中。加载它一次的缓存未命中次数是它所占用的块数，即 $\\Theta(n^2/B)$。所以，基本情况的成本是 $Q(n_0) = \\Theta(n_0^2/B)$。\n\n现在我们可以为原始 $N \\times N$ 问题的总未命中次数求解递推关系。递归进行 $k$ 层，直到子问题大小 $N/2^k$ 达到 $n_0$ 的数量级。\n$$ \\frac{N}{2^k} \\approx n_0 \\implies 2^k \\approx \\frac{N}{n_0} \\implies k \\approx \\log_2\\left(\\frac{N}{n_0}\\right) $$\n未命中次数为 $Q(N) = 4^k Q(N/2^k) = 4^k Q(n_0)$。\n代入 $4^k = (2^k)^2 \\approx (N/n_0)^2$ 和 $Q(n_0)$ 的表达式：\n$$ Q(N) \\approx \\left(\\frac{N}{n_0}\\right)^2 \\cdot \\Theta\\left(\\frac{n_0^2}{B}\\right) = \\frac{N^2}{n_0^2} \\cdot \\Theta\\left(\\frac{n_0^2}{B}\\right) = \\Theta\\left(\\frac{N^2}{B}\\right) $$\n缓存无关算法实现了最优的内存传输次数，相当于简单地线性扫描矩阵。它能自动适应缓存大小而无需显式地知道它。\n\n**结果总结**：\n- 朴素转置块传输次数：$\\Theta(N^2)$\n- 缓存无关转置块传输次数：$\\Theta(N^2/B)$\n\n### 逐项分析选项\n\n**A. 朴素算法产生 $\\Theta(N^2)$ 次块传输，而缓存无关算法产生 $\\Theta(N^2 / B)$ 次块传输。**\n此选项与我们为两种算法推导出的结果相符。朴素算法的性能受限于步长写入，导致 $\\Theta(N^2)$ 次未命中。缓存无关算法的递归结构确保了在内存层次结构的各个级别上都有良好的缓存局部性，从而实现了最优的 $\\Theta(N^2/B)$ 次未命中。\n**结论：正确**\n\n**B. 朴素算法和缓存无关算法都产生 $\\Theta(N^2 / B)$ 次块传输。**\n这是不正确的。虽然它正确地陈述了缓存无关算法的复杂度，但它错误地声称朴素算法也能达到这种性能。如分析所示，由于其向目标矩阵写入的内存访问模式，朴素算法的效率要低得多。\n**结论：不正确**\n\n**C. 朴素算法读取 $A$ 产生 $\\Theta(N^2 / B)$ 次块传输，写入 $B$ 产生 $\\Theta(N^2 / B)$ 次块传输，总计 $\\Theta(N^2 / B)$，而缓存无关算法产生 $\\Theta(N^2 / (B \\sqrt{M}))$ 次块传输。**\n此选项因几个原因而不正确。\n- 对于朴素算法，它正确地陈述了读取成本，但错误地将写入成本陈述为 $\\Theta(N^2/B)$。写入成本是 $\\Theta(N^2)$。因此总成本是 $\\Theta(N^2)$，而不是 $\\Theta(N^2/B)$。\n- 对于缓存无关算法，它陈述的复杂度为 $\\Theta(N^2 / (B \\sqrt{M}))$。这是众所周知的缓存无关矩阵*乘法*的复杂度，而不是转置。如前所推导，转置的复杂度是 $\\Theta(N^2/B)$。\n**结论：不正确**\n\n**D. 朴素算法产生 $\\Theta(N^2)$ 次块传输，而缓存无关算法由于递归开销产生 $\\Theta((N^2 \\log N) / B)$ 次块传输。**\n此选项正确地陈述了朴素算法的复杂度。然而，它错误地陈述了缓存无关算法的复杂度。对于此问题，递归结构不会在缓存未命中复杂度中引入对数因子。分析表明，工作集中在递归树的叶子节点上（即适合放入缓存的基本情况），将这些加总并不会产生 $\\log N$ 项。正确的复杂度是 $\\Theta(N^2/B)$。\n**结论：不正确**", "answer": "$$\\boxed{A}$$", "id": "3208160"}, {"introduction": "本练习 [@problem_id:3220337] 在递归设计原则的基础上，向您提出了一个更复杂的挑战：分析选择问题（例如，寻找中位数）的缓存无关算法。您将应用著名的“中位数中的中位数”（median-of-medians）技巧，并通过建立和求解相应的递推关系来推导其 I/O 复杂度。这个练习将展示如何对递归结构比简单划分更复杂的算法进行效率的严格证明。", "problem": "给定一个包含 $N$ 个不同键的数组，这些键连续存储在主内存中，以及一个双层内存模型，其中缓存大小为 $M$，数据以大小为 $B$ 的块在磁盘和缓存之间移动。考虑在理想缓存下的缓存无关模型，并满足高缓存假设 $M \\ge B^2$。在该模型中，算法不知道 $M$ 或 $B$ 的值，但其性能通过磁盘和缓存之间的输入/输出（I/O）块传输次数来分析。对大小为 $x$ 的数组进行一次顺序扫描会产生恰好 $x/B$ 次块传输；读取和写入操作被同等看待。\n\n设计一个缓存无关的选择算法，返回 $N$ 个键的中位数。使用以下基本事实和约束条件：\n\n- 算法必须是基于比较的、缓存无关的，将其数据访问模式组织成连续的子数组，而无需针对 $M$ 或 $B$ 进行调优。\n- 对于主元的选择，使用“中位数的中位数”策略，将键分为 5 个一组：形成每 5 个键的中位数，递归地选择这些中位数的中位数，并将其用作主元。\n- 在分组大小为 5 的中位数的中位数算法中，假设经过充分验证的最坏情况收缩性质成立：至少有 $3N/10$ 的键严格小于主元，且至少有 $3N/10$ 的键严格大于主元。因此，包含中位数的递归子问题的规模最多为 $7N/10$。\n- 在每个递归层级，假设缓存无关的、连续的顺序扫描会产生以下具体的 I/O 成本：\n  1. 读取 $N$ 个键并计算每 5 个键的中位数，需要一次扫描（$N/B$ 次传输）。\n  2. 将 $N/5$ 个中位数写入一个单独的连续缓冲区，需要一次扫描（$(N/5)/B$ 次传输）。\n  3. 围绕所选主元对原始的 $N$ 个键进行分区，需要两次扫描（总计 $2N/B$ 次传输）。\n- 对 $N/5$ 个中位数和最多 $7N/10$ 的分区进行的递归选择都遵循相同的方案，并根据相同的假设产生 I/O。\n\n仅从这些事实以及外存 I/O 模型和缓存无关设计的基本原理出发，推导该算法执行的总块传输次数 $T(N)$ 的一个封闭形式上界，该上界是 $N$ 和 $B$ 的函数。您的推导过程必须明确地建立并求解相应的递推关系，不得使用快捷公式。简要讨论为什么朴素的递归模式在缓存无关的环境下可能无法实现相同的界限（例如，对两个分区都进行递归或导致非顺序访问），但您最终的数值界限必须反映上述算法。将您的最终界限表示为关于 $N$ 和 $B$ 的单个解析表达式。无需取整。", "solution": "问题要求为一个对包含 $N$ 个键的数组进行操作的缓存无关中位数选择算法，推导其总块传输次数 $T(N)$ 的一个封闭形式上界。该算法使用分组大小为 5 的中位数的中位数方法。分析在外存模型中进行，该模型具有大小为 $M$ 的缓存和大小为 $B$ 的块，并满足高缓存假设 $M \\ge B^2$。\n\n首先，我们建立 $T(N)$ 的递推关系。该算法以递归方式进行。在每一步中，对于一个大小为 $N$ 的问题，执行以下操作：\n\n1.  **主元选择**：\n    a. 扫描大小为 $N$ 的输入数组，形成 $\\lceil N/5 \\rceil$ 组，每组 5 个键。计算每组的中位数。这需要对 $N$ 个键进行一次顺序扫描。此次扫描的 I/O 传输次数为 $N/B$。\n    b. 将 $\\lceil N/5 \\rceil$ 个中位数收集到一个新的连续缓冲区中。为了简化对大 $N$ 的分析，我们将 $\\lceil N/5 \\rceil$ 近似为 $N/5$。将这些中位数写入新缓冲区构成对这 $N/5$ 个中位数的一次顺序扫描，产生 $(N/5)/B$ 次 I/O 传输。\n    c. 算法递归调用自身，以找到这 $N/5$ 个中位数的中位数。设这次递归调用的成本为 $T(N/5)$。得到的键即为当前层级的主元。\n\n2.  **分区**：\n    a. 原始的 $N$ 个键的数组围绕所选主元进行分区。此过程涉及读取 $N$ 个键，并将它们写入两个独立的输出缓冲区：一个用于存放小于主元的键，另一个用于存放大于主元的键。题目指出这总共耗费 $2N/B$ 次传输，对应于对 $N$ 个元素的一次完整读取扫描和一次完整写入扫描。\n\n3.  **递归子问题**：\n    a. 分区后，算法确定两个分区中哪一个包含整体中位数。题目指出，由于中位数的中位数保证，后续递归子问题的规模最多为 $7N/10$。然后算法对这个分区进行递归调用。此步骤的成本最多为 $T(7N/10)$。\n\n综合这些成本，对于大小为 $N$ 的问题，总块传输次数 $T(N)$ 的上界是线性扫描成本和递归调用成本之和。当前层级的线性扫描成本是步骤 $1a$、$1b$ 和 $2a$ 的成本之和：\n$$ \\text{线性扫描成本} = \\frac{N}{B} + \\frac{N/5}{B} + \\frac{2N}{B} = \\left(1 + \\frac{1}{5} + 2\\right)\\frac{N}{B} = \\frac{16}{5}\\frac{N}{B} $$\n因此，$T(N)$ 的递推关系为：\n$$ T(N) \\le T\\left(\\frac{N}{5}\\right) + T\\left(\\frac{7N}{10}\\right) + \\frac{16}{5}\\frac{N}{B} $$\n此递推的基准情况发生在问题规模 $N$ 小到可以装入常数个内存块时，即 $N \\le B$。在这种情况下，I/O 次数是常数，即 $T(N) = O(1)$。我们寻求的是对于大 $N$ 的渐近上界。\n\n我们可以通过观察子问题规模的分数总和来求解这个线性递推关系：$\\frac{1}{5} + \\frac{7}{10} = \\frac{2}{10} + \\frac{7}{10} = \\frac{9}{10} < 1$。这表明在递归的每一层所做的工作量呈几何级数递减，总工作量由顶层的工作量主导。总体复杂度应与扫描成本成线性关系，即 $T(N) = O(N/B)$。\n\n为了找到常数因子，我们可以假设一个形式为 $T(N) \\le k \\frac{N}{B}$ 的解（其中 $k$ 为某个常数），并使用代入法求解 $k$。\n$$ k\\frac{N}{B} \\ge T\\left(\\frac{N}{5}\\right) + T\\left(\\frac{7N}{10}\\right) + \\frac{16}{5}\\frac{N}{B} $$\n假设该界对较小的输入成立：\n$$ k\\frac{N}{B} \\ge k\\frac{N/5}{B} + k\\frac{7N/10}{B} + \\frac{16}{5}\\frac{N}{B} $$\n对于 $N>0$ 和 $B>0$，我们可以将不等式两边同时除以 $N/B$：\n$$ k \\ge k\\left(\\frac{1}{5}\\right) + k\\left(\\frac{7}{10}\\right) + \\frac{16}{5} $$\n$$ k \\ge k\\left(\\frac{2}{10} + \\frac{7}{10}\\right) + \\frac{16}{5} $$\n$$ k \\ge k\\left(\\frac{9}{10}\\right) + \\frac{16}{5} $$\n$$ k - \\frac{9}{10}k \\ge \\frac{16}{5} $$\n$$ \\frac{1}{10}k \\ge \\frac{16}{5} $$\n$$ k \\ge 10 \\cdot \\frac{16}{5} $$\n$$ k \\ge 32 $$\n选择最小的有效整数常数 $k=32$，我们得到上界 $T(N) \\le 32 \\frac{N}{B}$。这表明总 I/O 传输次数与存储数据所需的块数成线性关系，对于必须读取其所有输入的问题来说，这是最优的。\n\n或者，我们可以对递归树的所有层级所做的工作求和。总工作量是一个几何级数的和：\n$$ T(N) \\le \\sum_{i=0}^{\\infty} \\left(\\frac{9}{10}\\right)^i \\left(\\frac{16}{5}\\frac{N}{B}\\right) = \\frac{16}{5}\\frac{N}{B} \\sum_{i=0}^{\\infty} \\left(\\frac{9}{10}\\right)^i $$\n这个无穷几何级数的和是 $\\frac{1}{1 - 9/10} = 10$。\n$$ T(N) \\le \\frac{16}{5}\\frac{N}{B} \\cdot 10 = 32\\frac{N}{B} $$\n这证实了我们的结果。\n\n关于为什么朴素的递归模式可能会失败的简要讨论：该算法的 I/O 效率取决于其缓存无关设计，该设计依赖于两个关键原则。首先，分治方法创建的子问题最终会变得足够小，以至于可以装入缓存，而无论缓存大小 $M$ 如何。其次，所有对大型数据集的操作都被构造成顺序扫描。一个朴素的递归算法可能在第二点上失败。例如，如果对 $N/5$ 个中位数和 $7N/10$ 的分区的递归调用是在单个大数组内的非连续内存位置上操作，那么内存访问模式将是非顺序的，从而导致大量的缓存未命中和块传输。指定的算法通过将子问题显式地写入新的、连续的缓冲区来避免这种情况，确保每个递归阶段都顺序处理其数据。此外，仅对一个分区（包含中位数的那个）进行递归是至关重要的。一个像排序算法那样对两个分区都进行递归的朴素算法，将导致高得多的 I/O 复杂度，即 $O\\left(\\frac{N}{B}\\log_{M/B}\\frac{N}{B}\\right)$，从而无法达到选择问题的最优线性界。", "answer": "$$\n\\boxed{32 \\frac{N}{B}}\n$$", "id": "3220337"}, {"introduction": "高效的缓存性能并不仅仅取决于算法的执行流程，数据在内存中的布局也同样至关重要。本练习 [@problem_id:3220363] 介绍了强大的 van Emde Boas (vEB) 布局，这是一种针对树形数据结构的递归存储策略。通过分析采用这种布局的二叉树上的查询 I/O 成本，您将了解到巧妙的数据排列如何能保证对数级的块传输次数，从而在结构层面实现缓存无关性。", "problem": "考虑一个具有两级存储层次结构的缓存无关计算模型：一个容量任意大的慢速内存和一个大小为 $M$ 字的快速内存。数据在两者之间以 $B$ 个连续字的数据块为单位进行传输。算法不知道 $M$ 或 $B$ 的值。代价的度量标准是块传输（也称为内存传输或输入/输出操作）的次数。假设满足高缓存条件 $M \\ge c B^2$（其中 $c \\ge 1$ 为某个固定常数），并且每个存储的节点占用 $\\Theta(1)$ 个字的空间。\n\n设 $n = 2^h$，其中 $h \\ge 1$ 为整数。Fenwick 树（二叉索引树）通过在前缀区间的规范分解中每个层级恰好访问一个节点，来支持对一个包含 $n$ 个元素的数组进行前缀和查询。考虑将此结构实现为一个具有 $n$ 个叶节点的完全二叉树，其中每个内部节点存储其两个子节点的和，并以缓存无关的 van Emde Boas (vEB) 顺序将节点在内存中布局。\n\n一次最坏情况的前缀和查询（例如，索引为 $t = n-1$ 的查询）会从叶节点层到根节点，在每个层级恰好访问一个节点，总共访问 $h$ 个节点。请从缓存无关模型的基本定义和 van Emde Boas 布局的结构特性（特别是，它递归地对子树进行分组，使得任何大小至多为 $\\Theta(B)$ 的子树都占据 $\\Theta(1)$ 个连续块）出发，推导单次前缀和查询在最坏情况下引起的块传输次数的紧凑首项表达式，该表达式是关于 $n$ 和 $B$ 的函数。\n\n您的答案必须是使用自然对数的单一闭式解析表达式，并且必须省略所有常数乘法因子和低阶加法项。最终表达式中不允许使用大O或相关的渐近符号，并且无需单位。", "solution": "问题要求找到在大小为 $n=2^h$ 的 Fenwick 树上进行前缀和查询时，最坏情况下块传输次数的首项表达式。该树被实现为一棵完全二叉树，并使用 van Emde Boas (vEB) 顺序进行内存布局。\n\n### 第 1 步：问题形式化\n设 $W(h)$ 为遍历一棵高度为 $h$ 的完全二叉树的查询路径所需的最坏情况下的块传输（I/O）次数。问题指明，一次最坏情况的查询路径长度为 $h$，从叶节点到根节点，在每个层级访问一个节点。数组的大小为 $n = 2^h$，因此对应的完全二叉树的高度为 $h = \\log_2(n)$。\n\n此分析在缓存无关模型中进行，在该模型中，算法不知道内存大小 $M$ 和块大小 $B$。代价以块传输次数度量。高缓存假设 $M \\ge cB^2$（对于某个 $c \\ge 1$）确保了一个行为良好的存储层次结构，但正如我们将看到的，对于这个特定问题，它不直接进入首项的计算。\n\n### 第 2 步：van Emde Boas (vEB) 布局分析\nvEB 布局是针对完全二叉树的一种递归内存布局。一棵高度为 $h$ 的树在其中心层级被分割。这将树分为：\n1.  一个高度为 $h_{top} = \\lceil h/2 \\rceil$ 的“顶部”子树。\n2.  $2^{\\lceil h/2 \\rceil}$ 个“底部”子树，每个高度为 $h_{bot} = \\lfloor h/2 \\rfloor$。\n\n在内存中，顶部子树被连续存储，其后跟着所有的底部子树，每个底部子树都以递归方式布局。从叶节点到根节点的查询路径会在其中一个底部子树中遍历一条长度为 $h_{bot}$ 的路径，然后在顶部子树中遍历一条长度为 $h_{top}$ 的路径。由于顶部子树和所选的底部子树存储在不同的、不连续的内存区域中，路径遍历自然地分解为对应于这两个结构的两个子问题。\n\n### 第 3 步：块传输的递推关系\n总块传输次数 $W(h)$ 是在底部子树中遍历路径和在顶部子树中遍历路径所产生的块传输次数之和。这导出了以下递推关系：\n$$W(h) = W(\\lfloor h/2 \\rfloor) + W(\\lceil h/2 \\rceil)$$\n只要所涉及的子树足够大，可以被递归分解，这个递推关系就成立。\n\n### 第 4 步：递推的基例\n当子树变得足够小时，递归终止。问题给出了 vEB 布局的一个关键特性：“任何大小至多为 $\\Theta(B)$ 的子树都占据 $\\Theta(1)$ 个连续块”。\n\n一棵高度为 $h_{base}$ 的完全二叉树总共有 $2^{h_{base}+1}-1$ 个节点，其大小为 $\\Theta(2^{h_{base}})$。基例的条件是当子树的大小与块大小 $B$ 同阶时：\n$$\\Theta(2^{h_{base}}) = \\Theta(B)$$\n对两边取对数，我们得到基例情况下的子树高度：\n$$h_{base} = \\log_2(B) + \\mathcal{O}(1)$$\n对于高度为 $h \\le h_{base}$ 的子树，整个子树存储在 $\\Theta(1)$ 个块中。在此子树内一条长度为 $h$ 的路径最多需要 $\\mathcal{O}(1)$ 次块传输。因此，该递推关系的基例是：\n$$W(h) = \\mathcal{O}(1) \\quad \\text{for } h \\le \\log_2(B)$$\n\n### 第 5 步：求解递推关系\n我们需要求解递推关系 $W(h) = W(\\lfloor h/2 \\rfloor) + W(\\lceil h/2 \\rceil)$，其基例为 $W(h_0) = C$，其中 $h_0 \\le \\log_2(B)$，$C$ 是一个常数。为简化和进行首项分析，我们可以分析 $h$ 是 2 的幂次的情况，这不影响渐近结果。设 $h$ 是 2 的幂。递推关系变为：\n$$W(h) = 2W(h/2)$$\n我们可以展开这个递推式：\n$$W(h) = 2W(h/2) = 2(2W(h/4)) = 4W(h/4) = \\dots = 2^k W(h/2^k)$$\n当 $W$ 的参数达到基例高度 $\\log_2(B)$ 时，递归在 $k$ 步后停止。\n$$ \\frac{h}{2^k} \\approx \\log_2(B) $$\n解出因子 $2^k$：\n$$ 2^k \\approx \\frac{h}{\\log_2(B)} $$\n现在，我们将其代回展开后的递推方程。$W$ 在基例处的值 $W(\\log_2(B))$ 是一个常数 $\\mathcal{O}(1)$。\n$$ W(h) \\approx 2^k \\cdot W(\\log_2(B)) \\approx \\frac{h}{\\log_2(B)} \\cdot \\mathcal{O}(1) $$\n问题要求一个紧凑的首项表达式，并省略所有常数乘法因子。因此，块传输次数为：\n$$ W(h) \\approx \\frac{h}{\\log_2(B)} $$\n\n### 第 6 步：最终表达式\n树的高度 $h$ 与元素数量 $n$ 通过 $h = \\log_2(n)$ 相关。将此代入我们关于 $W(h)$ 的表达式中：\n$$ W(n, B) \\approx \\frac{\\log_2(n)}{\\log_2(B)} $$\n使用对数的换底公式 $\\log_b(a) = \\frac{\\log_c(a)}{\\log_c(b)}$，我们可以将其写作：\n$$ W(n, B) \\approx \\log_B(n) $$\n最后，问题要求答案用自然对数（$\\ln$）表示。我们再次应用换底公式：\n$$ \\log_B(n) = \\frac{\\ln(n)}{\\ln(B)} $$\n这就是所求的最坏情况下块传输次数的紧凑首项表达式。", "answer": "$$\\boxed{\\frac{\\ln(n)}{\\ln(B)}}$$", "id": "3220363"}]}