{"hands_on_practices": [{"introduction": "理论是基础，但亲手实践才能真正揭示算法的精髓。这个练习将带你深入 Alpha-Beta 剪枝算法的内部工作机制，通过在一个具体的小型博弈树上追踪其执行过程，你将直观地看到不同的走法排序启发式如何影响搜索路径和剪枝效率。这个实践旨在巩固你对 $\\alpha$ 和 $\\beta$ 界限如何更新以及剪枝何时发生的理解。[@problem_id:3252710]", "problem": "考虑一个固定的层深（ply-depth）、确定性的、零和的、完美信息博弈树，其根节点 $R$ 位于深度 $0$。标准的极小化极大（minimax）定义适用：一个最大化（Maximizer, MAX）节点的值等于其子节点中的最大值，一个最小化（Minimizer, MIN）节点的值等于其子节点中的最小值。Alpha-beta 剪枝沿搜索路径维护一个边界 $[\\alpha,\\beta]$，其不变式为：当一个最大化（Maximizer）节点的已知最佳下界 $\\alpha$ 达到或超过其祖先最小化（Minimizer）节点的已知最佳上界 $\\beta$ 时，无需再探索其子节点；对称地，对于一个最小化（Minimizer）节点，当 $\\beta \\le \\alpha$ 时也是如此。\n\n该树的结构如下。根节点 $R$ 是一个 MAX 节点，有两个 MIN 子节点，$A$（左）和 $B$（右）。$A$ 和 $B$ 各有两个 MAX 子节点。$A$ 的 MAX 子节点是 $A_1$（左）和 $A_2$（右）。$B$ 的 MAX 子节点是 $B_1$（左）和 $B_2$（右）。每个 MAX 子节点都恰好有两个终端叶节点，其效用值如下所示。所有终端效用都是精确且确定性的。\n\n- $A_1$ 下的叶节点：$\\{4,2\\}$。\n- $A_2$ 下的叶节点：$\\{4,1\\}$。\n- $B_1$ 下的叶节点：$\\{4,1\\}$。\n- $B_2$ 下的叶节点：$\\{4,2\\}$。\n\n因此，该树是左右镜像的：$A$ 下的叶节点效用多重集为 $\\{4,2,4,1\\}$，$B$ 下的为 $\\{4,1,4,2\\}$。\n\n假设对终端叶节点进行全宽度搜索，但非终端节点的移动顺序由局部评估函数驱动。给出了两种不同的评估函数 $E_1$ 和 $E_2$，它们都仅用于在搜索前对兄弟节点进行排序。在每个非终端节点，子节点按照该节点上评估函数值的严格递减顺序进行扩展。在终端节点，$E_1$ 和 $E_2$ 都返回精确的效用值。由 $E_1$ 和 $E_2$ 产生的兄弟节点排序如下：\n\n- 在 $R$ 处：$E_1(A) = 4.10$ 且 $E_1(B) = 4.00$；$E_2(A) = 3.95$ 且 $E_2(B) = 4.05$。\n- 在 $A$ 处：$E_1(A_1) = 4.20$ 且 $E_1(A_2) = 4.15$；$E_2(A_1) = 4.00$ 且 $E_2(A_2) = 4.05$。\n- 在 $B$ 处：$E_1(B_1) = 4.60$ 且 $E_1(B_2) = 4.40$；$E_2(B_1) = 4.35$ 且 $E_2(B_2) = 4.50$。\n- 在每个 MAX 节点的叶节点处，按终端效用递减排序，即效用值为 $4$ 的叶节点在效用值为 $2$ 或 $1$ 的叶节点之前被访问。\n\n在极小化极大选择中的平局打破规则是“先遇到者优先”：当一个节点的多个子节点共享相同的极小化极大值时，算法会使用这些平局的子节点中第一个被访问的来记录主变例（PV）。\n\n分别使用 $E_1$ 排序和 $E_2$ 排序各运行一次 alpha-beta 搜索。仅根据上述形式化定义和精确的叶节点效用，选择所有正确的陈述。\n\nA. 在使用 $E_1$ 和 $E_2$ 的情况下，根节点的极小化极大值均为 $4$。\n\nB. 使用 $E_1$ 和 $E_2$ 时，主变例不同：使用 $E_1$ 时为 $R \\rightarrow A \\rightarrow A_1 \\rightarrow$ 效用为 $4$ 的叶节点，而使用 $E_2$ 时为 $R \\rightarrow B \\rightarrow B_2 \\rightarrow$ 效用为 $4$ 的叶节点。\n\nC. 在使用 $E_1$ 和 $E_2$ 的情况下，由于树的左右对称性以及指定的排序和打破平局规则，alpha-beta 剪枝都恰好剪掉了 $3$ 个终端叶节点的评估。\n\nD. 尽管在使用 $E_1$ 和 $E_2$ 时剪枝的叶节点数量可能相同，但两次搜索中被剪枝的叶节点的身份完全相同。\n\nE. 在使用 $E_2$ 时，因为 $B_1$ 包含一个效用为 $5$ 的叶节点，所以根节点的极小化极大值变为 $5$。\n\n选择所有正确的选项。通过根据所提供的定义从第一性原理推导极小化极大值和 alpha-beta 截断来证明你的选择。不要假设任何超出规定范围的未说明属性。", "solution": "## 问题验证\n\n### 第 1 步：提取已知条件\n- **博弈树**: 确定性、零和、完美信息、固定的层深。\n- **根节点**: $R$，位于深度 $0$，是一个 MAX 节点。\n- **节点结构**:\n    - $R$ 有两个 MIN 子节点：$A$ (左) 和 $B$ (右)。\n    - $A$ 有两个 MAX 子节点：$A_1$ (左) 和 $A_2$ (右)。\n    - $B$ 有两个 MAX 子节点：$B_1$ (左) 和 $B_2$ (右)。\n- **终端效用**:\n    - $A_1$ 下的叶节点：$\\{4, 2\\}$。\n    - $A_2$ 下的叶节点：$\\{4, 1\\}$。\n    - $B_1$ 下的叶节点：$\\{4, 1\\}$。\n    - $B_2$ 下的叶节点：$\\{4, 2\\}$。\n- **移动顺序**: 子节点按评估函数值的严格递减顺序扩展。\n- **评估函数 $E_1$ 排序**:\n    - 在 $R$ 处: $E_1(A) = 4.10 > E_1(B) = 4.00 \\implies$ 顺序是 $A$，然后是 $B$。\n    - 在 $A$ 处: $E_1(A_1) = 4.20 > E_1(A_2) = 4.15 \\implies$ 顺序是 $A_1$，然后是 $A_2$。\n    - 在 $B$ 处: $E_1(B_1) = 4.60 > E_1(B_2) = 4.40 \\implies$ 顺序是 $B_1$，然后是 $B_2$。\n- **评估函数 $E_2$ 排序**:\n    - 在 $R$ 处: $E_2(A) = 3.95 < E_2(B) = 4.05 \\implies$ 顺序是 $B$，然后是 $A$。\n    - 在 $A$ 处: $E_2(A_1) = 4.00 < E_2(A_2) = 4.05 \\implies$ 顺序是 $A_2$，然后是 $A_1$。\n    - 在 $B$ 处: $E_2(B_1) = 4.35 < E_2(B_2) = 4.50 \\implies$ 顺序是 $B_2$，然后是 $B_1$。\n- **叶节点排序**: 在 MAX 节点（$A_1, A_2, B_1, B_2$），终端叶节点按效用递减顺序访问。\n- **打破平局规则**: 对于主变例 (PV)，选择产生极小化极大值的第一个遇到的子节点。\n- **Alpha-Beta 剪枝规则**: 在 MAX 节点，如果 $\\alpha \\ge \\beta$ 则剪枝。在 MIN 节点，如果 $\\beta \\le \\alpha$ 则剪枝。\n\n### 第 2 步：使用提取的已知条件进行验证\n问题陈述在科学上是合理的、适定的和客观的。它为一个博弈树、终端效用和两种不同场景下的确定性移动排序规则提供了完整且一致的描述。这使得对每种情况下的 alpha-beta 搜索算法进行严格且唯一的追踪成为可能。该问题是人工智能算法中的一个标准练习，没有事实错误、矛盾或歧义。其前提是可形式化的，并与主题直接相关。选项 E 引入了一个前提（“$B_1$ 包含一个效用为 $5$ 的叶节点”），这与已知条件相矛盾，但这是待评估选项的一个特点，而非核心问题陈述中的缺陷。任务是根据给定的设置确定哪些选项是正确的，而一个基于错误前提的选项根本不是关于给定问题的真实陈述。\n\n### 第 3 步：结论和行动\n问题是**有效的**。解决方案将通过推导每种评估函数的 alpha-beta 搜索结果，然后评估每个选项来继续。\n\n## 解答推导\n\n首先，我们确定没有剪枝时树的真实极小化极大值，作为基准。\n- 值($A_1$) = $\\max(4, 2) = 4$。\n- 值($A_2$) = $\\max(4, 1) = 4$。\n- 值($B_1$) = $\\max(4, 1) = 4$。\n- 值($B_2$) = $\\max(4, 2) = 4$。\n- 值($A$) = $\\min(\\text{值}(A_1), \\text{值}(A_2)) = \\min(4, 4) = 4$。\n- 值($B$) = $\\min(\\text{值}(B_1), \\text{值}(B_2)) = \\min(4, 4) = 4$。\n- 值($R$) = $\\max(\\text{值}(A), \\text{值}(B)) = \\max(4, 4) = 4$。\n根节点 $R$ 的真实极小化极大值为 $4$。\n\n### 使用 $E_1$ 排序的 Alpha-Beta 搜索\n\n遍历顺序为：$R \\rightarrow A \\rightarrow A_1 \\rightarrow \\text{叶节点} \\rightarrow A_2 \\rightarrow \\text{叶节点} \\rightarrow B \\rightarrow B_1 \\rightarrow \\text{叶节点} \\rightarrow B_2 \\rightarrow \\text{叶节点}$。叶节点顺序按效用从高到低排列。\n\n1.  **$R$ (MAX, $\\alpha=-\\infty, \\beta=+\\infty$)**: 访问子节点 $A$。\n2.  **$A$ (MIN, $\\alpha=-\\infty, \\beta=+\\infty$)**: 访问子节点 $A_1$。\n3.  **$A_1$ (MAX, $\\alpha=-\\infty, \\beta=+\\infty$)**: 访问效用为 $4$ 的叶节点。$A_1$ 的局部 $\\alpha$ 变为 $4$。访问效用为 $2$ 的叶节点。$\\max(4,2)=4$。$A_1$ 返回值 $4$。\n4.  **$A$ (MIN, $\\alpha=-\\infty, \\beta=+\\infty$)**: 从 $A_1$ 接收到 $4$。作为一个 MIN 节点，其值现在 $\\le 4$。$A$ 更新其 $\\beta$ 为 $4$。其剩余子节点的当前边界为 $[\\alpha=-\\infty, \\beta=4]$。\n5.  **$A$ (MIN, $\\alpha=-\\infty, \\beta=4$)**: 访问子节点 $A_2$。\n6.  **$A_2$ (MAX, $\\alpha=-\\infty, \\beta=4$)**: 访问效用为 $4$ 的叶节点。$A_2$ 的局部 $\\alpha$ 变为 $4$。**剪枝检查**：$\\alpha \\ge \\beta$ ($4 \\ge 4$) 为真。**剪枝** $A_2$ 的剩余子节点（效用为 $1$ 的叶节点）。$A_2$ 返回其当前最佳值 $4$。\n7.  **$A$ (MIN, $\\alpha=-\\infty, \\beta=4$)**: 从 $A_2$ 接收到 $4$。值为 $\\min(4, 4)=4$。$A$ 没有更多子节点，返回最终值 $4$。\n8.  **$R$ (MAX, $\\alpha=-\\infty, \\beta=+\\infty$)**: 从 $A$ 接收到 $4$。作为一个 MAX 节点，其值现在 $\\ge 4$。$R$ 更新其 $\\alpha$ 为 $4$。其剩余子节点的当前边界为 $[\\alpha=4, \\beta=+\\infty]$。\n9.  **$R$ (MAX, $\\alpha=4, \\beta=+\\infty$)**: 访问子节点 $B$。\n10. **$B$ (MIN, $\\alpha=4, \\beta=+\\infty$)**: 访问子节点 $B_1$。\n11. **$B_1$ (MAX, $\\alpha=4, \\beta=+\\infty$)**: 访问效用为 $4$ 的叶节点。局部 $\\alpha$ 为 $\\max(4,4)=4$。访问效用为 $1$ 的叶节点。$\\max(4,1)=4$。$B_1$ 返回值 $4$。\n12. **$B$ (MIN, $\\alpha=4, \\beta=+\\infty$)**: 从 $B_1$ 接收到 $4$。作为一个 MIN 节点，其值现在 $\\le 4$。$B$ 更新其 $\\beta$ 为 $4$。**剪枝检查**：$\\beta \\le \\alpha$ ($4 \\le 4$) 为真。**剪枝** $B$ 的剩余子节点（节点 $B_2$ 及其两个叶节点）。$B$ 返回其当前最佳值 $4$。\n13. **$R$ (MAX, $\\alpha=4, \\beta=+\\infty$)**: 从 $B$ 接收到 $4$。值为 $\\max(4, 4)=4$。$R$ 没有更多子节点，返回最终值 $4$。\n\n**$E_1$ 总结**:\n- 根极小化极大值为 $4$。\n- 剪枝的叶节点：1个（在 $A_2$ 下），2个（在 $B_2$ 下）。总计：$3$ 个叶节点。\n- 主变例 (PV): $R \\rightarrow A \\rightarrow A_1 \\rightarrow \\text{叶节点}(4)$。\n\n### 使用 $E_2$ 排序的 Alpha-Beta 搜索\n\n遍历顺序为：$R \\rightarrow B \\rightarrow B_2 \\rightarrow \\text{叶节点} \\rightarrow B_1 \\rightarrow \\text{叶节点} \\rightarrow A \\rightarrow A_2 \\rightarrow \\text{叶节点} \\rightarrow A_1 \\rightarrow \\text{叶节点}$。\n\n1.  **$R$ (MAX, $\\alpha=-\\infty, \\beta=+\\infty$)**: 访问子节点 $B$。\n2.  **$B$ (MIN, $\\alpha=-\\infty, \\beta=+\\infty$)**: 访问子节点 $B_2$。\n3.  **$B_2$ (MAX, $\\alpha=-\\infty, \\beta=+\\infty$)**: 访问叶节点 $4$。局部 $\\alpha$ 变为 $4$。访问叶节点 $2$。$\\max(4,2)=4$。$B_2$ 返回值 $4$。\n4.  **$B$ (MIN, $\\alpha=-\\infty, \\beta=+\\infty$)**: 从 $B_2$ 接收到 $4$。值 $\\le 4$。$B$ 更新其 $\\beta$ 为 $4$。边界为 $[\\alpha=-\\infty, \\beta=4]$。\n5.  **$B$ (MIN, $\\alpha=-\\infty, \\beta=4$)**: 访问子节点 $B_1$。\n6.  **$B_1$ (MAX, $\\alpha=-\\infty, \\beta=4$)**: 访问叶节点 $4$。局部 $\\alpha$ 变为 $4$。**剪枝检查**：$\\alpha \\ge \\beta$ ($4 \\ge 4$) 为真。**剪枝** 剩余的子叶节点（效用为 $1$）。$B_1$ 返回 $4$。\n7.  **$B$ (MIN, $\\alpha=-\\infty, \\beta=4$)**: 从 $B_1$ 接收到 $4$。值为 $\\min(4,4)=4$。$B$ 返回最终值 $4$。\n8.  **$R$ (MAX, $\\alpha=-\\infty, \\beta=+\\infty$)**: 从 $B$ 接收到 $4$。值 $\\ge 4$。$R$ 更新其 $\\alpha$ 为 $4$。边界为 $[\\alpha=4, \\beta=+\\infty]$。\n9.  **$R$ (MAX, $\\alpha=4, \\beta=+\\infty$)**: 访问子节点 $A$。\n10. **$A$ (MIN, $\\alpha=4, \\beta=+\\infty$)**: 访问子节点 $A_2$。\n11. **$A_2$ (MAX, $\\alpha=4, \\beta=+\\infty$)**: 访问叶节点 $4$。局部 $\\alpha$ 为 $\\max(4,4)=4$。访问叶节点 $1$。$\\max(4,1)=4$。$A_2$ 返回值 $4$。\n12. **$A$ (MIN, $\\alpha=4, \\beta=+\\infty$)**: 从 $A_2$ 接收到 $4$。值 $\\le 4$。$A$ 更新其 $\\beta$ 为 $4$。**剪枝检查**：$\\beta \\le \\alpha$ ($4 \\le 4$) 为真。**剪枝** 剩余子节点 $A_1$（及其两个叶节点）。$A$ 返回 $4$。\n13. **$R$ (MAX, $\\alpha=4, \\beta=+\\infty$)**: 从 $A$ 接收到 $4$。值为 $\\max(4, 4)=4$。$R$ 返回最终值 $4$。\n\n**$E_2$ 总结**:\n- 根极小化极大值为 $4$。\n- 剪枝的叶节点：1个（在 $B_1$ 下），2个（在 $A_1$ 下）。总计：$3$ 个叶节点。\n- 主变例 (PV): $R \\rightarrow B \\rightarrow B_2 \\rightarrow \\text{叶节点}(4)$。\n\n## 选项评估\n\n**A. 在使用 $E_1$ 和 $E_2$ 的情况下，根节点的极小化极大值均为 $4$。**\n我们的分析证实了这一点。使用 $E_1$ 的搜索得出的根值为 $4$。使用 $E_2$ 的搜索也得出的根值为 $4$。这些都与树的真实极小化极大值相符。\n结论：**正确**。\n\n**B. 使用 $E_1$ 和 $E_2$ 时，主变例不同：使用 $E_1$ 时为 $R \\rightarrow A \\rightarrow A_1 \\rightarrow$ 效用为 $4$ 的叶节点，而使用 $E_2$ 时为 $R \\rightarrow B \\rightarrow B_2 \\rightarrow$ 效用为 $4$ 的叶节点。**\n我们对 $E_1$ 的追踪显示，主变例确实是 $R \\rightarrow A \\rightarrow A_1 \\rightarrow \\text{叶节点}(4)$。在使用 $E_1$ 时，$A$ 被首先访问。在 $A$ 处，$A_1$ 被首先访问且值为 $4$。由于 $A$ 的极小化极大值为 $4$，根据打破平局规则，主变例遵循这条首先遇到的路径。我们对 $E_2$ 的追踪显示，主变例是 $R \\rightarrow B \\rightarrow B_2 \\rightarrow \\text{叶节点}(4)$。在使用 $E_2$ 时，$B$ 被首先访问。在 $B$ 处，$B_2$ 被首先访问且值为 $4$。由于 $B$ 的极小化极大值为 $4$，主变例遵循这条路径。该陈述准确地描述了两个主变例。\n结论：**正确**。\n\n**C. 在使用 $E_1$ 和 $E_2$ 的情况下，由于树的左右对称性以及指定的排序和打破平局规则，alpha-beta 剪枝都恰好剪掉了 $3$ 个终端叶节点的评估。**\n我们对 $E_1$ 的追踪显示，$A_2$ 下效用为 $1$ 的叶节点和 $B_2$ 下的两个叶节点（效用为 $4$ 和 $2$）被剪枝，总共剪枝了 $3$ 个叶节点。我们对 $E_2$ 的追踪显示，$B_1$ 下效用为 $1$ 的叶节点和 $A_1$ 下的两个叶节点（效用为 $4$ 和 $2$）被剪枝，总共剪枝了 $3$ 个叶节点。两种情况下都恰好剪枝 $3$ 个叶节点的陈述是正确的。\n结论：**正确**。\n\n**D. 尽管在使用 $E_1$ 和 $E_2$ 时剪枝的叶节点数量可能相同，但两次搜索中被剪枝的叶节点的身份完全相同。**\n- 在 $E_1$ 下剪枝的叶节点：$\\{$ $A_2$ 下的叶节点($1$)， $B_2$ 下的叶节点($4$)， $B_2$ 下的叶节点($2$) $\\}$。\n- 在 $E_2$ 下剪枝的叶节点：$\\{$ $B_1$ 下的叶节点($1$)， $A_1$ 下的叶节点($4$)， $A_1$ 下的叶节点($2$) $\\}$。\n这两组叶节点完全不同。该陈述是错误的。\n结论：**不正确**。\n\n**E. 在使用 $E_2$ 时，因为 $B_1$ 包含一个效用为 $5$ 的叶节点，所以根节点的极小化极大值变为 $5$。**\n该陈述的前提，“因为 $B_1$ 包含一个效用为 $5$ 的叶节点”，与问题给出的条件（$B_1$ 下的叶节点是 $\\{4, 1\\}$）在事实上不符。一个基于错误前提的陈述不能被认为是关于所定义问题的真实陈述。此外，即使我们考虑这个假设：如果 $B_1$ 的叶节点是 $\\{5, 1\\}$，它的值将变为 $\\max(5,1)=5$。按照 $E_2$ 的搜索顺序：$R$ 探索 $B$；$B$ 探索 $B_2$（值为 $4$），将 $B$ 的 $\\beta$ 设置为 $4$。然后 $B$ 探索 $B_1$。$B_1$ 将访问其值为 $5$ 的叶节点，其局部 $\\alpha$ 将变为 $5$，并且由于 $\\alpha=5 \\ge \\beta=4$，它会立即剪枝其另一个叶节点。$B_1$ 将返回 $5$。节点 $B$ 的值将是 $\\min(4, 5)=4$。然后 $R$ 将从 $B$ 分支获得值 $4$，将其 $\\alpha$ 设置为 $4$，搜索的其余部分将和之前一样进行，最终得出根值为 $4$，而不是 $5$。所以，前提和结论都是错误的。\n结论：**不正确**。", "answer": "$$\\boxed{ABC}$$", "id": "3252710"}, {"introduction": "在体验了良好排序带来的剪枝优势后，探索其性能的下限也同样重要。此练习通过一个思想实验，分析了 Alpha-Beta 剪枝在一种特意设计的“最差”走法排序下的性能表现。通过推导在这种假设场景下的节点评估次数，你将揭示走法排序对算法效率的决定性影响，并理解为何优秀的启发式函数是发挥 Alpha-Beta 算法潜力的关键。[@problem_id:3204196]", "problem": "考虑一个确定性的、完全信息的、零和的、双人博弈，该博弈表示为一棵深度为 $d$ 的均匀完全 $b$ 叉博弈树，其根节点为一个极大值玩家（MAX）。假设 $b \\geq 2$ 且 $d \\in \\mathbb{N}$，$d \\geq 1$。搜索过程使用标准的带 $\\alpha$-$\\beta$ 剪枝的极小化极大算法，在根节点处初始化 $\\alpha=-\\infty$ 和 $\\beta=+\\infty$。静态评估函数仅在深度为 $d$ 的叶节点上应用，并且不存在置换、记忆化、扩展或静态搜索。\n\n移动排序在对抗意义上是反最优的，具体如下：在每个 MAX 节点，其子节点按照真实极小化极大值的非递减顺序被访问（对 MAX 来说最差的优先）；在每个 MIN 节点，其子节点按照真实极小化极大值的非递增顺序被访问（对 MIN 来说最差的优先）。\n\n仅从极小化极大的形式语义以及 $\\alpha$-$\\beta$ 边界及其剪枝条件的定义出发，推导出一个封闭形式表达式，表示 $\\alpha$-$\\beta$ 算法在该树上执行的静态评估的最坏情况总数，该表达式应以 $b$ 和 $d$ 表示。最终答案必须是单一的解析表达式。无需四舍五入，也无物理单位。", "solution": "用户需要对在一个特定博弈树上，根据定义的移动排序最坏情况下，$\\alpha$-$\\beta$ 剪枝搜索算法执行的静态评估次数进行细致而严谨的推导。\n\n### 步骤 1：提取已知条件\n- **博弈类型**：确定性的、完全信息的、零和的双人博弈。\n- **树结构**：深度为 $d$ 的均匀完全 $b$ 叉博弈树。\n- **根节点玩家**：极大值玩家（MAX）。\n- **参数约束**：分支因子 $b \\geq 2$。深度 $d \\in \\mathbb{N}$ 且 $d \\geq 1$。\n- **搜索算法**：带 $\\alpha$-$\\beta$ 剪枝的极小化极大算法。\n- **初始化**：在根节点，$\\alpha=-\\infty$ 和 $\\beta=+\\infty$。\n- **评估**：静态评估函数仅在叶节点（深度 $d$）上应用。\n- **简化假设**：无置换、无记忆化、无扩展、无静态搜索。\n- **移动排序（对抗性反最优）**：\n  - 在每个 MAX 节点，子节点按其真实极小化极大值的非递减顺序被访问。\n  - 在每个 MIN 节点，子节点按其真实极小化极大值的非递增顺序被访问。\n- **目标**：推导在最坏情况下，静态评估总数的封闭形式表达式，以 $b$ 和 $d$ 表示。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学基础**：该问题是人工智能领域的一个标准理论练习，特别涉及对抗性搜索和博弈论。所有概念，包括极小化极大、$\\alpha$-$\\beta$ 剪枝、博弈树和复杂度分析，在计算机科学中都是公认的。该问题在科学和数学上是合理的。\n- **良定义**：该问题定义清晰，包含所有必要的参数（$b, d$）、特定的算法、精确的树结构和明确的移动排序规则。它要求一个特定的量（静态评估次数），在给定约束下期望有唯一解。\n- **客观性**：问题以形式化、客观的语言陈述，没有任何主观或模棱两可的术语。\n\n该问题不违反任何无效性标准。它是一个在理论计算机科学中良定义的形式化问题。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将提供完整的解答推导。\n\n### 解答推导\n\n设 $N$ 为执行的静态评估总数，这对应于 $\\alpha$-$\\beta$ 搜索算法访问的叶节点数量。根的深度为 $0$，叶节点在深度 $d$。\n\n$\\alpha$-$\\beta$ 剪枝算法的核心在于其通过将当前节点的潜在值与其从祖先继承的 $\\alpha$（MAX 迄今为止的最佳值）和 $\\beta$（MIN 迄今为止的最佳值）边界进行比较来剪掉分支的能力。剪枝在两种情况下发生：\n1.  在 MAX 节点，如果发现其值大于或等于现有的 $\\beta$ 边界 $(\\alpha' \\ge \\beta)$，则该分支被剪枝（beta 剪枝）。\n2.  在 MIN 节点，如果发现其值小于或等于现有的 $\\alpha$ 边界 $(\\beta' \\le \\alpha)$，则该分支被剪枝（alpha 剪枝）。\n\n问题指定了基于节点的真实极小化极大值的特定移动排序。设 $V(n)$ 表示节点 $n$ 的真实极小化极大值。\n\n让我们分析树中任意节点的搜索过程。\n\n**情况 1：节点是 MAX 节点 $P$。**\n设 $P$ 的子节点为 $C_1, C_2, \\ldots, C_b$。这些是 MIN 节点。指定的移动排序规定它们的访问顺序使得 $V(C_1) \\leq V(C_2) \\leq \\ldots \\leq V(C_b)$。$P$ 的真实极小化极大值为 $V(P) = \\max_i V(C_i) = V(C_b)$。\n\n$\\alpha$-$\\beta$ 搜索过程如下：\n1.  $P$ 对其第一个子节点 $C_1$ 发起搜索。传递给此搜索的边界为 $(\\alpha_P, \\beta_P)$。在对 $C_1$ 子树的搜索完成后，它返回 $V(C_1)$。\n2.  $P$ 更新其自身的 $\\alpha$ 值：$\\alpha'_P = \\max(\\alpha_P, V(C_1))$。\n3.  然后 $P$ 以更新后的边界 $(\\alpha'_P, \\beta_P)$ 对其第二个子节点 $C_2$ 发起搜索。\n4.  为了在搜索 $C_2$ 的子树期间发生 beta 剪枝，必须找到一个大于或等于 $\\beta_P$ 的值。更新后的 $\\alpha'_P$ 无助于导致 beta 剪枝。子节点的探索顺序对 MAX 来说是最差的，意味着决定该节点真实值的最高价值子节点最后被探索。这种排序策略最小化了提前发生 beta 剪枝的机会。\n\n**情况 2：节点是 MIN 节点 $M$。**\n设 $M$ 的子节点为 $G_1, G_2, \\ldots, G_b$。这些是 MAX 节点。指定的移动排序规定它们的访问顺序使得 $V(G_1) \\geq V(G_2) \\geq \\ldots \\geq V(G_b)$。$M$ 的真实极小化极大值为 $V(M) = \\min_j V(G_j) = V(G_b)$。\n\n搜索过程如下：\n1.  $M$ 以边界 $(\\alpha_M, \\beta_M)$ 对其第一个子节点 $G_1$ 发起搜索。搜索返回 $V(G_1)$。\n2.  $M$ 更新其自身的 $\\beta$ 值：$\\beta'_M = \\min(\\beta_M, V(G_1))$。\n3.  然后 $M$ 以更新后的边界 $(\\alpha_M, \\beta'_M)$ 对其第二个子节点 $G_2$ 发起搜索。\n4.  为了在搜索 $C_2$ 的子树期间发生 alpha 剪枝，必须找到一个小于或等于 $\\alpha_M$ 的值。子节点的探索顺序对 MIN 来说是最差的，意味着决定该节点真实值的最低价值子节点最后被探索。这会延迟任何潜在的 alpha 剪枝。\n\n**来自兄弟节点交互的关键洞见**\n\n让我们结合这些观察。考虑一个 MAX 节点 $P$，其 MIN 子节点为 $C_1$ 和 $C_2$，其中 $V(C_1) \\leq V(C_2)$。\n- $P$ 首先探索 $C_1$。假设这需要探索 $C_1$ 的整个子树。完成后，$P$ 的局部 $\\alpha$ 值变为 $V(C_1)$。\n- 然后 $P$ 探索 $C_2$，并向其传递边界 $\\alpha = V(C_1)$。\n- $C_2$ 是一个 MIN 节点。如果在 $C_2$ 处可以证明其自身的值小于或等于它收到的 alpha 边界，即 $V(C_2) \\leq V(C_1)$，则会发生 alpha 剪枝。\n- 然而，问题的排序规则规定 $V(C_1) \\leq V(C_2)$。这意味着除非 $V(C_1) = V(C_2)$，否则不可能发生剪枝。在 $V(C_1)  V(C_2)$ 的一般情况下，从 $P$ 传递给 $C_2$ 的边界从根本上是无法剪枝的。$C_2$ 永远无法证明其值小于或等于 $V(C_1)$。\n\n让我们将其形式化。在 MIN 节点 $M$（其子节点为 $G_j$）处发生 alpha 剪枝需要找到一个子节点 $G_k$，使得 $V(G_k) \\leq \\alpha_{parent}$。当 $P$ 调用 $C_2$ 时，边界为 $\\alpha_{parent} = V(C_1)$。因此，在 $C_2$ 处发生剪枝需要找到一个子节点 $G_{2,k}$，使得 $V(G_{2,k}) \\leq V(C_1)$。\n但我们知道 $V(C_2) = \\min_k V(G_{2,k})$。移动排序给出 $V(C_1) \\leq V(C_2)$。\n因此，$V(C_1) \\leq \\min_k V(G_{2,k})$，这意味着对于 $C_2$ 的所有子节点 $k$，$V(C_1) \\leq V(G_{2,k})$。\n剪枝条件 $V(G_{2,k}) \\leq V(C_1)$ 永远不能满足（除非在值相等的非一般情况下）。\n\n对称的论证适用于 MIN 节点。考虑一个 MIN 节点 $M$，其 MAX 子节点为 $G_1$ 和 $G_2$，其中 $V(G_1) \\geq V(G_2)$。\n- $M$ 探索 $G_1$，其局部 $\\beta$ 值变为 $V(G_1)$。\n- 然后 $M$ 探索 $G_2$，并向其传递边界 $\\beta = V(G_1)$。\n- $G_2$ 是一个 MAX 节点。如果它能证明其值大于或等于 $\\beta$，即 $V(G_2) \\geq V(G_1)$，则会发生 beta 剪枝。\n- 但排序规则规定 $V(G_1) \\geq V(G_2)$。除非 $V(G_1) = V(G_2)$，否则剪枝条件不可能满足。\n- 从 $M$ 传递给其后续子节点 $G_2$ 的边界是无法剪枝的。\n\n这个逻辑表明，在兄弟子树之间传递的边界被系统地构造成对剪枝无效。因此，对任何子节点子树的搜索都独立于其先前搜索过的兄弟节点的结果。这意味着在这种对抗性的排序下，$\\alpha-\\beta$ 算法无法剪掉任何分支。它被迫探索整棵博弈树，就像朴素的极小化极大算法一样。\n\n我们要计算的是静态评估的总数，它等于算法访问的叶节点数。在一棵深度为 $d$ 的均匀完全 $b$ 叉博弈树中，叶节点的总数位于深度 $d$。在深度 $k$ 有 $b^k$ 个节点。因此，在深度 $d$ 有 $b^d$ 个叶节点。\n\n由于没有发生剪枝，算法必须访问所有 $b^d$ 个叶节点以执行静态评估。\n\n因此，静态评估的最坏情况总数为 $b^d$。", "answer": "$$\n\\boxed{b^{d}}\n$$", "id": "3204196"}, {"introduction": "这个终极实践将理论与代码相结合，让你全面掌握 Alpha-Beta 剪枝。你需要构建一个完整的程序，实现 Alpha-Beta 算法，并在几种不同的走法排序策略下测试其性能——从精心设计的最佳排序到刻意构造的最差排序。通过这个编码练习，你将能够用实验数据来验证算法性能的理论边界，深刻体会到算法分析与实际实现之间的紧密联系。[@problem_id:3252714]", "problem": "给定一个由分支因子 $b$ 和搜索深度 $d$ 定义的均匀博弈树。评估函数仅在叶节点处定义，内部节点在最大化层和最小化层之间交替，从一个最大化根节点开始。设一条子节点索引路径 $(p_0,p_1,\\dots,p_{d-1})$ 的叶节点效用为整数\n$$\nU(p_0,p_1,\\dots,p_{d-1})=\\sum_{i=0}^{d-1} p_i \\cdot b^{\\,d-1-i},\n$$\n即由子节点索引构成的b进制数。此构造为每个内部节点的每个子节点导出了不相交且严格有序的效用区间。\n\n基本定义：\n- 深度为 $k$ 的节点的Minimax值是通过在最大化层应用最大化算子、在最小化层应用最小化算子直至叶节点而获得的值。该值通过递归计算：在深度为 $d$ 的叶节点处，其值等于其效用 $U$；在内部节点处，其值等于其子节点值的适当极值。\n- Alpha-Beta (AB) 剪枝算法维护一个区间 $[\\alpha,\\beta]$，其中 $\\alpha$ 是最大化方可达值的下界，$\\beta$ 是最小化方可达值的上界。剪枝条件是 $\\alpha \\ge \\beta$，此时当前分支无法影响最终决策，因此不再进一步探索。\n\n程序必须：\n1. 通过首先计算每个内部节点所有子节点的精确Minimax值来构建一个完美排序生成器。在最大化节点，完美排序按其子节点Minimax值的非递增顺序评估子节点；在最小化节点，则按非递减顺序评估。已知这种排序能在Alpha-Beta剪枝中最大化截断次数。\n2. 通过在每个节点反转完美排序来构建一个人工最差情况排序，这种排序会最小化截断次数，并迫使探索尽可能接近完整树。\n3. 实现Alpha-Beta剪枝，以测量在三种评估顺序下的已访问节点数：基准（自然子节点索引顺序 $0,1,\\dots,b-1$）、完美排序和人工最差情况排序。\n\n需要验证的理论界限：\n- 完整树的大小 $T(b,d)$（以节点数计）为\n$$\nT(b,d)=\\sum_{i=0}^{d} b^{\\,i}=\\frac{b^{\\,d+1}-1}{b-1},\n$$\n这是无剪枝的Minimax算法访问的精确节点数。在最差情况排序下，Alpha-Beta剪枝必须访问至少与最小化截断所允许的一样多的节点，并且在此构造中，它应恰好访问 $T(b,d)$ 个节点。\n- 在完美排序下，Alpha-Beta剪枝的复杂度为 $O\\!\\left(b^{\\,d/2}\\right)$。对于均匀树，在完美排序情况下，已访问节点数的一个具体且保守的上界是\n$$\nU(b,d)=2 \\cdot \\sum_{i=0}^{\\lceil d/2 \\rceil} b^{\\,i}.\n$$\n您的程序必须验证 $N_{\\text{best}}(b,d) \\le U(b,d)$，其中 $N_{\\text{best}}(b,d)$ 是在完美排序下测得的已访问节点数。\n\n测试套件：\n评估以下参数集 $(b,d)：$\n- $(2,0)$ 这是一个仅有叶节点的边界情况，\n- $(1,5)$ 这是一个在每个节点只有一个子节点的退化链，\n- $(2,4)$ 一个偶数深度的二叉树，\n- $(3,3)$ 一个奇数深度的三叉树，\n- $(4,5)$ 一个更高分支的树。\n\n对于每个测试用例，生成列表\n$$\n\\big[\\,T(b,d),\\,N_{\\text{worst}}(b,d),\\,N_{\\text{baseline}}(b,d),\\,N_{\\text{best}}(b,d),\\,U(b,d),\\,\\text{cond}_1,\\,\\text{cond}_2,\\,\\text{cond}_3\\,\\big],\n$$\n其中 $\\text{cond}_1$ 是 $N_{\\text{worst}}(b,d)=T(b,d)$ 的布尔结果，$\\text{cond}_2$ 是 $N_{\\text{best}}(b,d) \\le U(b,d)$ 的布尔结果，$\\text{cond}_3$ 是 $T(b,d) \\ge N_{\\text{baseline}}(b,d) \\ge N_{\\text{best}}(b,d)$ 的布尔结果。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例的结果本身也是一个用方括号括起来且无空格的逗号分隔列表，例如\n$$\n[\\,[1,1,1,1,2,\\text{True},\\text{True},\\text{True}],\\,[6,6,6,6,8,\\text{True},\\text{True},\\text{True}]\\,].\n$$\n不读取任何输入；所有测试用例都嵌入在程序中。不涉及物理单位或角度，所有输出均为整数或布尔值。", "solution": "用户提供了一个问题，要求在一个特殊构造的均匀博弈树上实现并分析Alpha-Beta剪枝算法。\n\n### 步骤1：问题验证\n\n我将首先根据指定标准验证问题陈述。\n\n**1. 提取已知条件：**\n- **树结构**：一个分支因子为 $b$、深度为 $d$ 的均匀博弈树。根节点位于深度0，是一个最大化（MAX）节点。各层在MAX和MIN节点之间交替。叶节点位于深度 $d$。\n- **叶节点效用**：通过子节点索引路径 $(p_0, p_1, \\dots, p_{d-1})$ 到达的叶节点的效用由 $U(p_0, \\dots, p_{d-1}) = \\sum_{i=0}^{d-1} p_i \\cdot b^{d-1-i}$ 给出。\n- **算法**：Minimax和Alpha-Beta (AB)剪枝（$\\alpha \\ge \\beta$ 截断）。\n- **节点排序方案**：\n    - **基准**：自然子节点索引顺序：$(0, 1, \\dots, b-1)$。\n    - **完美**：对于MAX节点，按子节点Minimax值的非递增顺序；对于MIN节点，按非递减顺序。已知此排序可最大化截断次数。\n    - **最差情况**：在每个节点处反转完美排序。\n- **测量指标**：\n    - $N_{\\text{baseline}}(b,d)$: 使用基准排序时访问的节点数。\n    - $N_{\\text{best}}(b,d)$: 使用完美排序时访问的节点数。\n    - $N_{\\text{worst}}(b,d)$: 使用最差情况排序时访问的节点数。\n- **用于验证的理论界限**：\n    - 完整树大小：$T(b,d) = \\sum_{i=0}^{d} b^i = \\frac{b^{d+1}-1}{b-1}$ (对于 $b1$)。\n    - 完美排序上界：$U(b,d) = 2 \\cdot \\sum_{i=0}^{\\lceil d/2 \\rceil} b^i$。\n- **验证条件**：\n    - $\\text{cond}_1: N_{\\text{worst}}(b,d) = T(b,d)$。\n    - $\\text{cond}_2: N_{\\text{best}}(b,d) \\le U(b,d)$。\n    - $\\text{cond}_3: T(b,d) \\ge N_{\\text{baseline}}(b,d) \\ge N_{\\text{best}}(b,d)$。\n- **测试用例**：$(b,d)$ 对：$(2,0), (1,5), (2,4), (3,3), (4,5)$。\n- **输出格式**：列表的列表，例如 $[[T_1, N_{w1}, \\dots], [T_2, N_{w2}, \\dots]]$。\n\n**2. 验证分析：**\n- **科学依据**：该问题在计算机科学领域的博弈树搜索算法的既定理论中有充分的依据。Minimax、Alpha-Beta剪枝、完美排序和最差情况排序等概念都是标准概念。叶节点效用函数是一种常见的构造，用于创建一个具有有序叶节点值的测试平台。\n- **良定性**：该问题是良定的。树、效用函数和算法的定义都是确定性的，确保每个测试用例都存在一组唯一、稳定且有意义的节点计数。\n- **客观性**：问题以精确、客观和数学化的语言陈述。\n- **完整性与一致性**：所有必要的参数（$b, d$）、函数和条件都已提供。定义在内部是一致的。验证任务是*检查*给定的条件，而不是证明它们。某个条件对某些测试用例可能为假，这将是实验的有效结果，而不是问题本身的失效。例如，所提供的 $U(b,d)$ 公式是一个非标准的保守上界，验证其有效性是任务的一部分。\n- **可行性**：测试用例在计算上是可行的。最大的树，对于 $(b,d)=(4,5)$，有 $T(4,5) = 1365$ 个节点，这完全在现代计算机的分析能力范围之内。\n\n**3. 结论：**\n该问题是**有效的**。这是一个在算法领域内清晰、独立且科学上合理的问题。\n\n### 步骤2：解决方案设计\n\n解决方案将涉及实现Alpha-Beta搜索算法，并使用三种不同的节点评估排序方式运行它。\n\n**1. 确定节点排序：**\n一个关键步骤是确定完美排序和最差情况排序。这需要找出节点子节点的Minimax值的排序。\n我们来分析一个位于深度 $k$，其子节点位于深度 $k+1$、通过路径 $(p_0, \\dots, p_k)$ 到达的子节点的Minimax值。它的值由其下方子树的Minimax评估确定。该子树中的叶节点效用由以下公式给出：\n$$U(p_0, \\dots, p_{d-1}) = \\sum_{i=0}^{k} p_i b^{d-1-i} + \\sum_{i=k+1}^{d-1} p_i b^{d-1-i}$$\n子树的Minimax值 $V(p_0, \\dots, p_k)$ 可以被证明是其索引 $p_k$ 的严格递增函数。这是因为 $p_k$ 的系数 $b^{d-1-(k+1)}$ 是正的，并且在Minimax计算中，这个主要项的影响会传递上来。\n\n这一洞见使我们无需显式计算Minimax值即可定义排序：\n- **MAX节点（偶数深度 $k$）**：为使结果最大化，完美排序按其值的降序探索子节点，这对应于其索引的降序：$(b-1, b-2, \\dots, 0)$。最差情况则相反：$(0, 1, \\dots, b-1)$。\n- **MIN节点（奇数深度 $k$）**：为使结果最小化，完美排序按其值的升序探索子节点，即索引的升序：$(0, 1, \\dots, b-1)$。最差情况则相反：$(b-1, b-2, \\dots, 0)$。\n**基准**排序始终是 $(0, 1, \\dots, b-1)$。\n\n**2. Alpha-Beta实现：**\n一个递归函数 `alpha_beta_recursive` 将遍历概念上的博弈树。它将接收当前路径、alpha-beta边界和树参数作为参数。将使用一个全局计数器来跟踪每次运行中访问的节点数。\n- 递归在深度为 $d$ 时终止。\n- 在每个内部节点，它根据指定的排序（'perfect'、'worst' 或 'baseline'）遍历子节点。\n- 如果满足条件 $\\alpha \\ge \\beta$，它会更新alpha或beta值并对搜索进行剪枝。\n- 到达一个节点的路径将作为索引列表传递，用于计算叶节点的效用。为优化效用计算，将预先计算 $b$ 的幂（$b^{d-1}, b^{d-2}, \\dots, b^0$）。\n\n**3. 主逻辑：**\n主函数将循环遍历测试套件。对于每对 $(b,d)$：\n1. 它计算理论值 $T(b,d)$ 和 $U(b,d)$，并处理 $b=1$ 的边界情况。\n2. 它调用alpha-beta搜索函数三次，每种排序方案（`worst`、`baseline`、`perfect`）一次，以获得 $N_{\\text{worst}}$、$N_{\\text{baseline}}$ 和 $N_{\\text{best}}$。\n3. 它评估三个布尔条件（$\\text{cond}_1$、$\\text{cond}_2$、$\\text{cond}_3$）。\n4. 它将结果组合成一个列表，并为最终输出进行格式化。\n\n该设计系统地解决了问题陈述的所有要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\n# A mutable object to hold the visited nodes counter.\n# This avoids using 'global' keyword inside the recursive function directly,\n# making the data flow slightly more explicit.\n_visited_nodes_counter = [0]\n\ndef _calculate_utility(path, powers):\n    \"\"\"\n    Calculates the leaf utility value using pre-calculated powers of b.\n    The path must have length d, same as the length of powers vector.\n    \"\"\"\n    if not path:\n        return 0\n    return np.dot(path, powers)\n\ndef _alpha_beta_recursive(path, alpha, beta, b, d, orderings, powers):\n    \"\"\"\n    Recursive core of the alpha-beta search algorithm.\n    It returns the minimax value of the node defined by 'path'.\n    The number of visited nodes is updated via the counter.\n    \"\"\"\n    _visited_nodes_counter[0] += 1\n    depth = len(path)\n\n    if depth == d:\n        return _calculate_utility(path, powers)\n\n    is_max_node = (depth % 2 == 0)\n    order = orderings[depth]\n\n    if is_max_node:\n        value = -np.inf\n        for child_idx in order:\n            child_path = path + [child_idx]\n            child_value = _alpha_beta_recursive(child_path, alpha, beta, b, d, orderings, powers)\n            value = max(value, child_value)\n            alpha = max(alpha, value)\n            if alpha = beta:\n                break\n        return value\n    else:  # MIN node\n        value = np.inf\n        for child_idx in order:\n            child_path = path + [child_idx]\n            child_value = _alpha_beta_recursive(child_path, alpha, beta, b, d, orderings, powers)\n            value = min(value, child_value)\n            beta = min(beta, value)\n            if alpha = beta:\n                break\n        return value\n\ndef _get_orderings(b, d, order_type):\n    \"\"\"\n    Determines the child evaluation order for each depth based on the ordering type.\n    \"\"\"\n    orderings = []\n    natural_order = list(range(b))\n    reverse_order = list(range(b - 1, -1, -1))\n    \n    for depth in range(d):\n        is_max_node = (depth % 2 == 0)\n        if order_type == 'baseline':\n            orderings.append(natural_order)\n        elif order_type == 'perfect':\n            orderings.append(reverse_order if is_max_node else natural_order)\n        elif order_type == 'worst':\n            orderings.append(natural_order if is_max_node else reverse_order)\n    return orderings\n\ndef run_ab_search(b, d, order_type):\n    \"\"\"\n    Sets up and runs an alpha-beta search, returning the number of nodes visited.\n    \"\"\"\n    _visited_nodes_counter[0] = 0\n    \n    # A single node tree (root is a leaf)\n    if d == 0:\n        return 1\n\n    orderings = _get_orderings(b, d, order_type)\n    # Pre-calculate powers of b for efficient utility calculation\n    powers = np.array([b**(d - 1 - i) for i in range(d)], dtype=np.int64)\n\n    _alpha_beta_recursive([], -np.inf, np.inf, b, d, orderings, powers)\n    \n    return _visited_nodes_counter[0]\n\ndef solve_case(b, d):\n    \"\"\"\n    Solves a single test case for parameters (b, d) and returns the formatted result list.\n    \"\"\"\n    # Handle d=0 edge case\n    if d == 0:\n        T_bd, N_worst, N_baseline, N_best = 1, 1, 1, 1\n        U_bd = 2  # U(b,0) = 2 * b^0 = 2\n    # Handle b=1 edge case\n    elif b == 1:\n        T_bd, N_worst, N_baseline, N_best = d + 1, d + 1, d + 1, d + 1\n        ceil_d_2 = math.ceil(d / 2)\n        U_bd = 2 * (ceil_d_2 + 1) # Sum of 1 for i=0 to ceil_d_2 is (ceil_d_2 + 1)\n    # General case\n    else:\n        T_bd = (b**(d + 1) - 1) // (b - 1)\n        \n        ceil_d_2 = math.ceil(d / 2)\n        u_bd_sum_term = (b**(ceil_d_2 + 1) - 1) // (b - 1)\n        U_bd = 2 * u_bd_sum_term\n        \n        N_worst = run_ab_search(b, d, 'worst')\n        N_baseline = run_ab_search(b, d, 'baseline')\n        N_best = run_ab_search(b, d, 'perfect')\n    \n    cond1 = (N_worst == T_bd)\n    cond2 = (N_best = U_bd)\n    cond3 = (T_bd = N_baseline and N_baseline = N_best)\n    \n    return [int(T_bd), int(N_worst), int(N_baseline), int(N_best), int(U_bd), cond1, cond2, cond3]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        (2, 0),\n        (1, 5),\n        (2, 4),\n        (3, 3),\n        (4, 5),\n    ]\n\n    all_results_str = []\n    for b, d in test_cases:\n        case_result = solve_case(b, d)\n        str_case_result = f\"[{','.join(map(str, case_result))}]\"\n        all_results_str.append(str_case_result)\n\n    final_output = f\"[{','.join(all_results_str)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3252714"}]}