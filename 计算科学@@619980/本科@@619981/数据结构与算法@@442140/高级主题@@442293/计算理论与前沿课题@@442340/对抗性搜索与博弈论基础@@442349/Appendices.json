{"hands_on_practices": [{"introduction": "掌握对抗性搜索的核心在于理解并实现 alpha-beta 剪枝算法。本练习提供了一个预定义的博弈树，让你能够专注于算法本身，而不必分心于博弈规则的实现。通过解决这个问题 ([@problem_id:3204257])，你将实践在一个常见的三值效用系统（赢、平、输）下，如何通过维护 $\\alpha$ 和 $\\beta$ 边界来有效地剪枝搜索空间，这是构建高效博弈AI的基础。", "problem": "一个双人、确定性、完全信息博弈被表示为一个有限有根树，其节点标明了移动的玩家，叶节点标明了终局结果。设玩家被称为 MAX 和 MIN。每个终局叶节点的结果都在集合 $\\{-1, 0, 1\\}$ 中，其中 $1$ 表示 MAX 获胜，$-1$ 表示 MIN 获胜，$0$ 表示平局。两名玩家都具有与此全序一致的字典序偏好：MAX 偏好 $1$ 胜过 $0$ 胜过 $-1$，而 MIN 偏好 $-1$ 胜过 $0$ 胜过 $1$。目标是在最优博弈下计算根节点的游戏理论值，其中有一个特殊的行为约束，即当 MIN 无法强制获胜时，其目标是强制平局。这个约束已经被所述的偏好顺序所涵盖。\n\n从基本定义开始，考虑在博弈树上递归定义的极小化极大值函数 $V(n)$：\n- 如果 $n$ 是终局节点，$V(n)$ 等于其终局结果。\n- 如果 $n$ 是一个 MAX 节点，$V(n) = \\max\\{V(c) \\mid c \\text{ is a child of } n\\}$，其中最大值是根据全序 $-1  0  1$ 来取的。\n- 如果 $n$ 是一个 MIN 节点，$V(n) = \\min\\{V(c) \\mid c \\text{ is a child of } n\\}$，使用相同的全序。\n\n搜索必须使用适用于这种三值效用设置的 $\\alpha$–$\\beta$ 剪枝策略来实现。量 $\\alpha$ 和 $\\beta$ 分别表示 MAX 能保证的值的当前下界和 MIN 能保证的值的当前上界，两者都以相同的全序衡量。剪枝必须在这些边界方面是可靠的。\n\n实现一个完整的程序，使用所描述的改编版 $\\alpha$–$\\beta$ 剪枝为以下每个测试用例计算 $V(\\text{root})$。每个测试用例使用整数节点标识符、每个内部节点处移动玩家的指定、子节点邻接列表和终局结果来指定一个博弈树。程序应生成单行输出，其中包含所有测试用例的结果，格式为方括号内以逗号分隔的列表，每个条目是该测试用例计算出的整数值 $V(\\text{root})$。\n\n测试套件：\n\n- 测试用例 1 (混合结果的一般情况)：\n  - 节点：$0$ (MAX), $1$ (MIN), $2$ (MIN), $3$ (终局 $1$), $4$ (终局 $0$), $5$ (终局 $0$), $6$ (终局 $-1$)。\n  - 边：$0 \\to \\{1,2\\}$, $1 \\to \\{3,4\\}$, $2 \\to \\{5,6\\}$。\n\n- 测试用例 2 (根为 MIN，多分枝)：\n  - 节点：$0$ (MIN), $1$ (MAX), $2$ (MAX), $3$ (终局 $-1$), $4$ (终局 $-1$), $5$ (终局 $0$), $6$ (终局 $1$), $7$ (终局 $1$)。\n  - 边：$0 \\to \\{1,2,3\\}$, $1 \\to \\{4,5\\}$, $2 \\to \\{6,7\\}$。\n\n- 测试用例 3 (终局根节点)：\n  - 节点：$0$ (终局 $0$)。\n\n- 测试用例 4 (剪枝场景)：\n  - 节点：$0$ (MAX), $1$ (MIN), $2$ (MIN), $3$ (MIN), $4$ (终局 $1$), $5$ (终局 $1$), $6$ (终局 $-1$), $7$ (终局 $1$), $8$ (终局 $0$), $9$ (终局 $0$)。\n  - 边：$0 \\to \\{1,2,3\\}$, $1 \\to \\{4,5\\}$, $2 \\to \\{6,7\\}$, $3 \\to \\{8,9\\}$。\n\n要求的输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是按所列顺序的第 $i$ 个测试用例的整数值 $V(\\text{root})$。不允许有其他额外输出。", "solution": "用户希望我扮演一位严谨的STEM教授，解决一个与对抗性搜索和博弈论相关的问题。\n\n### 问题验证\n\n首先，我将根据指定标准验证问题陈述。\n\n**步骤1：提取已知条件**\n\n-   **博弈类型**：双人、确定性、完全信息博弈。\n-   **玩家**：MAX 和 MIN。\n-   **博弈表示**：有限有根树。\n-   **终局状态（叶节点）**：结果在集合 $\\{-1, 0, 1\\}$ 中，其中 $1$ 是 MAX 获胜，$-1$ 是 MIN 获胜，$0$ 是平局。\n-   **玩家偏好**：\n    -   MAX 偏好 $1$ 胜过 $0$ 胜过 $-1$。\n    -   MIN 偏好 $-1$ 胜过 $0$ 胜过 $1$。\n-   **目标**：在最优博弈下计算根节点的游戏理论值 $V(\\text{root})$。\n-   **极小化极大值函数 $V(n)$**：\n    -   如果 $n$ 是终局节点，$V(n)$ = 终局结果。\n    -   如果 $n$ 是一个 MAX 节点，$V(n) = \\max\\{V(c) \\mid c \\text{ is a child of } n\\}$。\n    -   如果 $n$ 是一个 MIN 节点，$V(n) = \\min\\{V(c) \\mid c \\text{ is a child of } n\\}$。\n    -   $\\max$ 和 $\\min$ 的排序为 $-1  0  1$。\n-   **算法要求**：搜索必须使用 $\\alpha$–$\\beta$ 剪枝。\n-   **$\\alpha$–$\\beta$ 边界**：\n    -   $\\alpha$：MAX 能保证的值的下界。\n    -   $\\beta$：MIN 能保证的值的上界。\n-   **测试套件**：提供了四个特定的博弈树，包括节点类型、子节点邻接关系和终局值。\n    -   测试用例 1：一个以 MAX 节点开始的通用树。\n    -   测试用例 2：一个以 MIN 节点开始的树。\n    -   测试用例 3：一个只有终局根节点的简单树。\n    -   测试用例 4：一个为触发剪枝而设计的树。\n-   **输出格式**：单行输出，结果包含在方括号内，以逗号分隔的列表，例如 `[$r_1$,$r_2$,...]`。\n\n**步骤2：使用提取的已知条件进行验证**\n\n1.  **科学依据**：该问题植根于经典的博弈论，这是数学和人工智能的一个成熟分支。极小化极大值、博弈树和alpha-beta剪枝等概念是基础性的，并且描述准确。三值效用方案是赢/平/输博弈的标准模型。该问题在科学上是合理的。\n2.  **适定性**：该问题是适定的。对于任何有限、确定性、完全信息的博弈，都存在一个唯一博弈理论值。所提供的测试用例是完全指定的，包含了计算此值所需的所有必要信息（树结构、玩家角色、终局值）。要求的算法，alpha-beta剪枝，是进行此计算的标准且正确的方法。\n3.  **客观性**：问题以精确、形式化的语言陈述。所有定义、规则和约束都是客观且无歧义的。\n4.  **不完整或矛盾的设置**：问题是自洽且一致的。每个测试用例都提供了博弈树的完整描述。关于 MIN 偏好平局胜过失败已被效用值和标准 `min` 运算符所涵盖的澄清，避免了任何歧义。\n5.  **不切实际或不可行**：该问题处理的是抽象的数学博弈树，因此物理现实性不适用。所提供的树很小，在计算上分析起来微不足道。\n6.  **其他缺陷**：该问题没有其他列出的缺陷。这是其领域内一个标准的、形式化的问题，既不（在其一般形式下）是琐碎的，也不是不适定的。\n\n**步骤3：结论与行动**\n\n问题是**有效的**。我将继续提供一个完整的、有理有据的解决方案。\n\n### 解决方案\n\n该问题要求使用alpha-beta剪枝算法计算博弈树根节点的极小化极大值。该算法通过探索博弈树来为双人博弈找到最优走法，同时“剪掉”那些可证明与最终结果无关的分支。\n\n**理论基础：极小化极大和Alpha-Beta剪枝**\n\n博弈树中节点 $n$ 的博弈理论值，记为 $V(n)$，由**极小化极大原则**确定。该原则假设双方玩家都进行最优博弈，以实现对自身最有利的结果。该值递归定义如下：\n\n1.  如果节点 $n$ 是一个终局状态，其值 $V(n)$ 是其预定义的效用（在本例中，来自集合 $\\{-1, 0, 1\\}$）。\n2.  如果节点 $n$ 是 MAX 玩家的回合，MAX 将选择导致具有最大值的子节点的走法。因此，$V(n) = \\max_{c \\in \\text{children}(n)} V(c)$。\n3.  如果节点 $n$ 是 MIN 玩家的回合，MIN 将选择导致具有最小值的子节点的走法。因此，$V(n) = \\min_{c \\in \\text{children}(n)} V(c)$。\n\n此定义的直接递归实现将对博弈树执行完全的深度优先搜索。**Alpha-beta剪枝**是一种显著的优化，它减少了被评估的节点数量。它通过在搜索过程中维护两个值来运作：\n\n-   $\\alpha$：到目前为止，在从根到当前节点的路径上为 MAX 玩家找到的最佳（最高）值。它代表 MAX 能保证的最低分数。\n-   $\\beta$：到目前为止，在从根到当前节点的路径上为 MIN 玩家找到的最佳（最低）值。它代表 MIN 能保证的最高分数（即 MIN 可以将 MAX 的分数限制在不高于 $\\beta$）。\n\n搜索以递归方式进行。在 MAX 节点，算法尝试增加 $\\alpha$。在 MIN 节点，它尝试减少 $\\beta$。剪枝逻辑的核心是条件 $\\alpha \\geq \\beta$。如果满足此条件，则意味着当前探索路径对于其中一个玩家来说，可证明比他们已经找到的另一条路径更差。\n\n-   **Alpha 剪枝（在 MIN 节点）**：如果在评估 MIN 节点的子节点时，来自某个子节点的值导致 $\\beta$ 小于或等于 $\\alpha$（$\\alpha$ 从 MAX 祖先节点传递下来），则可以忽略该 MIN 节点的其余子节点。这是因为试图最大化其分数的 MAX 玩家已经有了一个可以保证至少得到 $\\alpha$ 分的选择。由于此 MIN 节点路径将导致得分最多为 $\\beta$（其中 $\\beta \\le \\alpha$），因此 MAX 玩家永远不会选择它。\n-   **Beta 剪枝（在 MAX 节点）**：对称地，如果在探索 MAX 节点的子节点时，来自某个子节点的值导致 $\\alpha$ 大于或等于 $\\beta$（$\\beta$ 从 MIN 祖先节点传递下来），则可以忽略其余子节点。MIN 玩家已有一个选择，可以保证将 MAX 的分数限制在最多为 $\\beta$。由于此 MAX 路径将导致得分至少为 $\\alpha$（其中 $\\alpha \\ge \\beta$），因此 MIN 玩家永远不会允许博弈达到这种状态。\n\n**算法实现**\n\n我们将实现一个递归函数 `alphabeta(node_id, alpha, beta, nodes_info)`，该函数根据当前的 $\\alpha$ 和 $\\beta$ 边界计算一个节点的值。\n\n该函数将按如下方式运作：\n-   它接受当前节点的标识符 (`node_id`)、边界 $\\alpha$ 和 $\\beta$，以及表示整个树的数据结构 (`nodes_info`)。\n-   对根节点的初始调用将使用 $\\alpha = -\\infty$ 和 $\\beta = +\\infty$。由于效用值在 $\\{-1, 0, 1\\}$ 中，我们可以用 $-2$ 代表 $-\\infty$，用 $+2$ 代表 $+\\infty$。\n-   **基本情况**：如果节点是终局节点，则返回其存储的效用值。\n-   **MAX 节点逻辑**：它将一个局部变量 `v` 初始化为 $-\\infty$ (即 $-2$)。然后，它遍历其子节点，为每个子节点递归调用 `alphabeta`。每次调用后，它更新 `v = $\\max(v, \\text{child\\_value})$` 和 $\\alpha = \\max(\\alpha, v)$。如果在任何时候 $\\alpha \\geq \\beta$, 它将剪掉剩余的子节点并返回 `v`。\n-   **MIN 节点逻辑**：它将 `v` 初始化为 $+\\infty$ (即 $+2$)。它遍历其子节点，递归调用 `alphabeta`。每次调用后，它更新 `v = $\\min(v, \\text{child\\_value})$` 和 $\\beta = \\min(\\beta, v)$。如果 $\\alpha \\geq \\beta$，它将剪枝并返回 `v`。\n\n主程序将为四个测试用例定义结构，遍历它们，为每个根节点调用 `alphabeta` 函数，并收集结果以进行最终格式化。每个测试用例的博弈树将存储在一个字典中，将整数节点标识符映射到描述节点类型及其子节点或终局值的元组。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the game theory problem by implementing alpha-beta pruning\n    for the given test cases.\n    \"\"\"\n\n    def alphabeta(node_id, alpha, beta, nodes_info):\n        \"\"\"\n        Computes the minimax value for a node using alpha-beta pruning.\n\n        Args:\n            node_id: The identifier of the current node in the tree.\n            alpha: The best value (highest) found so far for the MAX player.\n            beta: The best value (lowest) found so far for the MIN player.\n            nodes_info: A dictionary representing the game tree structure.\n\n        Returns:\n            The minimax value of the node.\n        \"\"\"\n        player, data = nodes_info[node_id]\n\n        if player == 'TERMINAL':\n            return data  # `data` is the terminal value\n\n        if player == 'MAX':\n            value = -2  # Represents -infinity for the utility set {-1, 0, 1}\n            child_ids = data\n            for child_id in child_ids:\n                child_value = alphabeta(child_id, alpha, beta, nodes_info)\n                value = max(value, child_value)\n                alpha = max(alpha, value)\n                if alpha >= beta:\n                    break  # Beta cut-off\n            return value\n\n        if player == 'MIN':\n            value = 2  # Represents +infinity for the utility set {-1, 0, 1}\n            child_ids = data\n            for child_id in child_ids:\n                child_value = alphabeta(child_id, alpha, beta, nodes_info)\n                value = min(value, child_value)\n                beta = min(beta, value)\n                if alpha >= beta:\n                    break  # Alpha cut-off\n            return value\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1 (general case with mixed outcomes)\n        {\n            \"root\": 0,\n            \"nodes\": {\n                0: ('MAX', [1, 2]),\n                1: ('MIN', [3, 4]),\n                2: ('MIN', [5, 6]),\n                3: ('TERMINAL', 1),\n                4: ('TERMINAL', 0),\n                5: ('TERMINAL', 0),\n                6: ('TERMINAL', -1),\n            }\n        },\n        # Test Case 2 (root MIN, multiple branches)\n        {\n            \"root\": 0,\n            \"nodes\": {\n                0: ('MIN', [1, 2, 3]),\n                1: ('MAX', [4, 5]),\n                2: ('MAX', [6, 7]),\n                3: ('TERMINAL', -1),\n                4: ('TERMINAL', -1),\n                5: ('TERMINAL', 0),\n                6: ('TERMINAL', 1),\n                7: ('TERMINAL', 1),\n            }\n        },\n        # Test Case 3 (terminal root)\n        {\n            \"root\": 0,\n            \"nodes\": {\n                0: ('TERMINAL', 0),\n            }\n        },\n        # Test Case 4 (pruning scenario)\n        {\n            \"root\": 0,\n            \"nodes\": {\n                0: ('MAX', [1, 2, 3]),\n                1: ('MIN', [4, 5]),\n                2: ('MIN', [6, 7]),\n                3: ('MIN', [8, 9]),\n                4: ('TERMINAL', 1),\n                5: ('TERMINAL', 1),\n                6: ('TERMINAL', -1),\n                7: ('TERMINAL', 1),\n                8: ('TERMINAL', 0),\n                9: ('TERMINAL', 0),\n            }\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Initial call with alpha = -infinity (-2) and beta = +infinity (2)\n        result = alphabeta(case[\"root\"], -2, 2, case[\"nodes\"])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3204257"}, {"introduction": "真实的博弈过程通常比简单的树形结构更复杂，可能包含循环或巨大的状态空间。本练习 ([@problem_id:3204272]) 将你的技能提升到新的层次，要求你在一个通用的有向图上实现深度受限的minimax搜索。你将学习如何使用启发式评估函数来处理搜索截断，并利用转置表（一种记忆化技术）来处理循环和避免重复计算，这些都是开发强大博弈引擎的关键技术。", "problem": "给定一个确定性的、双人、零和博弈，该博弈表示为一个有限有向状态图。玩家轮流行动，最大化玩家（Max）选择行动以最大化结果，最小化玩家（Min）选择行动以最小化结果。设状态集表示为 $S$，有向边关系 $E \\subseteq S \\times S$ 描述了合法移动。一个终止状态 $s \\in S$ 有一个已定义的效用值 $u(s) \\in \\mathbb{R}$，一个非终止状态有一个启发式估价值 $h(s) \\in \\mathbb{R}$。行动顺序严格随深度交替：起始状态由 Max 行动，然后是 Min，依此类推。\n\n请在此图上实现一个深度受限的 Minimax 算法，该算法使用置换表（记忆化）来避免重复计算并安全地处理循环。你的算法必须计算一个价值函数 $V(s,d)$，该函数满足以下要求，这些要求源于对抗性搜索和零和效用的核心定义：\n\n1. 对于终止状态 $s$，在任何剩余深度 $d \\geq 0$ 下，$V(s,d) = u(s)$。\n2. 对于非终止状态 $s$，当剩余深度为 $d = 0$ 时，$V(s,0) = h(s)$。\n3. 对于 $d  0$ 且 $s$ 为非终止状态：\n   - 如果轮到 Max 在 $s$ 行动，则\n     $$V(s,d) = \\max_{s' \\in \\text{Succ}(s)} V(s', d-1).$$\n   - 如果轮到 Min 在 $s$ 行动，则\n     $$V(s,d) = \\min_{s' \\in \\text{Succ}(s)} V(s', d-1).$$\n4. 循环处理：如果在递归过程中遇到一个已存在于当前递归栈中的状态 $s$（即，在当前路径中形成循环的后向边），立即使用启发式函数对其进行评估，并为当前调用返回 $h(s)$。此规则确保了算法的终止性，并为循环提供了一致的回退策略。\n5. 置换表：缓存并重用已计算的值，这些值以元组 $(s, d, \\text{player})$ 为键，其中 $\\text{player}$ 指示在状态 $s$ 处轮到 Max 还是 Min 行动。这确保了重复的子问题即使通过不同路径到达也只被解决一次。\n\n如果状态 $s$ 是非终止状态且没有后继状态，则将其视为启发式回退情况，并返回 $h(s)$。\n\n你的程序必须实现以上逻辑，并为以下每个测试用例评估起始状态。下面提供的所有整数和实数都应解释为没有物理单位的纯数值。\n\n测试套件：\n- 测试用例 $1$（包含简单循环和可达终止状态的正常路径）：\n  - 状态：$\\{0,1,2,3\\}$。\n  - 边：$0 \\to \\{1,2\\}$，$1 \\to \\{3\\}$，$2 \\to \\{0\\}$，$3 \\to \\{\\}$。\n  - 终止状态效用：$u(3) = 5$。\n  - 启发式估值：$h(0) = 1$，$h(1) = 2$，$h(2) = 0$，$h(3) = 5$。\n  - 深度限制：$L = 4$。\n  - 起始状态：$s_0 = 0$。\n- 测试用例 $2$（边界：起始深度限制为零）：\n  - 与测试用例 $1$ 相同的图，但深度限制 $L = 0$。\n- 测试用例 $3$（混合分支，包含循环、多个终止状态和负效用值）：\n  - 状态：$\\{0,1,2,3,4,5\\}$。\n  - 边：$0 \\to \\{1,2\\}$，$1 \\to \\{3,4\\}$，$2 \\to \\{5\\}$，$3 \\to \\{\\}$，$4 \\to \\{1\\}$，$5 \\to \\{\\}$。\n  - 终止状态效用：$u(3) = -2$，$u(5) = 0$。\n  - 启发式估值：$h(0) = 0$，$h(1) = 3$，$h(2) = -1$，$h(3) = -2$，$h(4) = 2$，$h(5) = 0$。\n  - 深度限制：$L = 3$。\n  - 起始状态：$s_0 = 0$。\n- 测试用例 $4$（没有终止状态的纯循环）：\n  - 状态：$\\{0,1\\}$。\n  - 边：$0 \\to \\{1\\}$，$1 \\to \\{0\\}$。\n  - 终止状态效用：无。\n  - 启发式估值：$h(0) = 2$，$h(1) = -3$。\n  - 深度限制：$L = 5$。\n  - 起始状态：$s_0 = 0$。\n- 测试用例 $5$（强调启发式截断的浅层搜索）：\n  - 与测试用例 $3$ 相同的图，但深度限制 $L = 1$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[v_1,v_2,v_3,v_4,v_5]$），其中 $v_i$ 是根据上述规则为测试用例 $i$ 计算出的整数值 $V(s_0, L)$。", "solution": "该问题要求在一个表示为有向图的博弈上，实现一个深度受限的 Minimax 搜索算法。该算法必须通过置换表进行记忆化增强，并包含处理图中循环的特定规则。目标是在指定的初始搜索深度 $L$ 下，计算给定起始状态 $s_0$ 的博弈论价值。\n\n该解决方案基于对抗性搜索和博弈论领域的几项既定原则。\n\n**算法的指导原则**\n\n1.  **Minimax 原则**：算法的核心是 Minimax 过程，该过程专为双人、确定性、零和博弈设计。在此类博弈中，一个玩家（Max）试图最大化一个效用分数，而另一个玩家（Min）则试图最小化它。一个博弈状态 $s$ 的价值，记为 $V(s)$，是递归定义的。如果轮到 Max 从状态 $s$ 移动，则其价值是从任何后继状态可获得的最大值：$V(s) = \\max_{s' \\in \\text{Succ}(s)} V(s')$。相反，如果轮到 Min，则价值是最小值：$V(s) = \\min_{s' \\in \\text{Succ}(s)} V(s')$。此递归展开直到到达终止状态，在终止状态下，博弈结束并被赋予一个固定的效用值 $u(s) \\in \\mathbb{R}$。\n\n2.  **深度受限搜索与启发式评估**：对于规模庞大或包含循环的博弈图，将整个博弈树探索至终止状态通常在计算上是不可行的。深度受限搜索通过将搜索限制在最大深度 $L$ 来解决此问题。当剩余搜索深度 $d$ 递减到 $0$ 时，递归终止。在这些可能是非终止状态的截断点，状态的价值使用启发式函数 $h(s) \\in \\mathbb{R}$ 进行估计。因此，价值函数被推广为同时依赖于状态和剩余深度，即 $V(s, d)$。规则也相应调整：对于非终止状态 $s$，$V(s, 0) = h(s)$。\n\n3.  **行动方确定**：问题规定玩家的行动顺序严格随搜索深度交替。初始调用 $V(s_0, L)$ 对应于层数（从搜索开始的移动次数） $p = 0$。按照惯例，这是 Max 的回合。在深度 $d$ 处的递归调用对应于层数 $p = L-d$。如果 $p$ 是偶数，则轮到 Max；如果 $p$ 是奇数，则轮到 Min。这可以通过条件 $(L-d) \\pmod 2 = 0$ 来检查。\n\n**为保证鲁棒性和效率的高级算法机制**\n\n问题陈述要求对基础算法进行两项关键增强。\n\n1.  **置换表（记忆化）**：在图中，一个状态通常可以通过多条不同路径到达。一个朴素的递归实现会重复解决相同的子问题——即每次遇到给定的玩家和 $(s,d)$ 时都重新计算 $V(s,d)$。置换表是记忆化或动态规划的一种应用，可以防止这种冗余工作。每个已解决子问题的价值都存储在缓存中，以唯一标识该子问题的元组 $(s, d, \\text{player})$ 作为键。在计算子问题的价值之前，算法首先检查该表。如果找到一个值，就立即返回它。\n\n2.  **循环处理**：状态图中的循环（例如，$s_1 \\to s_2 \\to s_1$）带来了无限递归的风险。指定的处理方法是维护当前递归路径的记录（即当前调用栈中的祖先状态集）。如果算法试图评估一个已经在此路径上的状态 $s$，则检测到一个循环。该分支的递归将立即终止，并返回启发式价值 $h(s)$。这为循环路径提供了一致且能终止的评估。\n\n**综合算法结构**\n完整的算法实现为一个递归函数，我们称之为 `compute_v(state, depth, path)`，它整合了以上所有原则。评估一个状态的逻辑流程遵循严格的操作顺序：\n\n1.  根据初始深度 $L$ 和当前剩余深度 $d$ 确定当前玩家（Max 或 Min）。\n2.  为当前子问题构造键：$(\\text{state}, d, \\text{player})$。\n3.  检查置换表以查找此键。如果存在条目，则返回缓存的值。\n4.  应用终止递归的基准情况：\n    a. 如果 `state` 是一个终止状态，其价值为 $u(\\text{state})$。\n    b. 如果 `depth` 为 $0$，搜索被截断，其价值为启发式估值 $h(\\text{state})$。\n    c. 如果检测到循环（即 `state` 已在递归 `path` 中），其价值为 $h(\\text{state})$。\n    d. 如果 `state` 是非终止状态但没有后继状态（死局），其价值为 $h(\\text{state})$。\n5.  如果没有满足基准情况，则继续递归步骤：\n    a. 将当前 `state` 添加到 `path` 集合中，以标记其进入递归栈。\n    b. 通过对所有后继状态 $s'$ 递归调用 `compute_v`（深度减为 $d-1$）来生成一个值列表。\n    c. 在其所有子节点都被评估后，从 `path` 集合中移除当前 `state`。\n    d. 如果是 Max 的回合，结果是子节点价值的最大值。如果是 Min 的回合，结果是最小值。\n6.  在返回计算结果之前，将其及其对应的键存储在置换表中，以便将来查找。\n\n这种设计确保了计算的正确性、高效性和终止性，并遵守了问题陈述中指定的所有约束。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass GameSolver:\n    \"\"\"\n    Implements a depth-limited minimax algorithm with transposition tables and cycle handling.\n    \"\"\"\n    def __init__(self, edges, terminals, heuristics, initial_depth):\n        # Graph representation as an adjacency list\n        self.adj = edges\n        # Terminal states and their utilities\n        self.terminals = terminals\n        # Heuristic values for non-terminal states\n        self.heuristics = heuristics\n        # The total depth of the search from the start node\n        self.initial_depth = initial_depth\n        # Transposition table for memoization\n        self.memo = {}\n\n    def is_max_turn(self, depth: int) -> bool:\n        \"\"\"\n        Determines if it is the maximizing player's turn based on ply.\n        Ply is the number of moves from the start of the search.\n        The starting state is at ply 0 (Max's turn).\n        \"\"\"\n        ply = self.initial_depth - depth\n        return ply % 2 == 0\n\n    def compute_v(self, state: int, depth: int, path: set) -> float:\n        \"\"\"\n        Recursively computes the value of a state using depth-limited minimax.\n\n        Args:\n            state: The current state to evaluate.\n            depth: The remaining search depth.\n            path: The set of states in the current recursion stack (to detect cycles).\n\n        Returns:\n            The computed value of the state.\n        \"\"\"\n        is_max = self.is_max_turn(depth)\n        \n        # 1. Check transposition table (memoization)\n        memo_key = (state, depth, is_max)\n        if memo_key in self.memo:\n            return self.memo[memo_key]\n\n        # 2. Base Case: Terminal state\n        if state in self.terminals:\n            return float(self.terminals[state])\n\n        # 3. Base Case: Depth limit reached\n        if depth == 0:\n            return float(self.heuristics[state])\n            \n        # 4. Base Case: Cycle detected\n        if state in path:\n            return float(self.heuristics[state])\n\n        successors = self.adj.get(state, [])\n        \n        # 5. Base Case: Non-terminal state with no successors\n        if not successors:\n            return float(self.heuristics[state])\n\n        # 6. Recursive step\n        path.add(state)\n        \n        child_values = [self.compute_v(next_state, depth - 1, path) for next_state in successors]\n        \n        path.remove(state) # Backtrack\n\n        if is_max:\n            result = max(child_values)\n        else:\n            result = min(child_values)\n            \n        # Store result in transposition table before returning\n        self.memo[memo_key] = result\n        return result\n\ndef solve():\n    \"\"\"\n    Sets up and runs the test cases for the minimax algorithm.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        {\n            \"start_state\": 0,\n            \"depth_limit\": 4,\n            \"states\": {0, 1, 2, 3},\n            \"edges\": {0: [1, 2], 1: [3], 2: [0]},\n            \"terminals\": {3: 5},\n            \"heuristics\": {0: 1, 1: 2, 2: 0, 3: 5},\n        },\n        # Test Case 2\n        {\n            \"start_state\": 0,\n            \"depth_limit\": 0,\n            \"states\": {0, 1, 2, 3},\n            \"edges\": {0: [1, 2], 1: [3], 2: [0]},\n            \"terminals\": {3: 5},\n            \"heuristics\": {0: 1, 1: 2, 2: 0, 3: 5},\n        },\n        # Test Case 3\n        {\n            \"start_state\": 0,\n            \"depth_limit\": 3,\n            \"states\": {0, 1, 2, 3, 4, 5},\n            \"edges\": {0: [1, 2], 1: [3, 4], 2: [5], 4: [1]},\n            \"terminals\": {3: -2, 5: 0},\n            \"heuristics\": {0: 0, 1: 3, 2: -1, 3: -2, 4: 2, 5: 0},\n        },\n        # Test Case 4\n        {\n            \"start_state\": 0,\n            \"depth_limit\": 5,\n            \"states\": {0, 1},\n            \"edges\": {0: [1], 1: [0]},\n            \"terminals\": {},\n            \"heuristics\": {0: 2, 1: -3},\n        },\n        # Test Case 5\n        {\n            \"start_state\": 0,\n            \"depth_limit\": 1,\n            \"states\": {0, 1, 2, 3, 4, 5},\n            \"edges\": {0: [1, 2], 1: [3, 4], 2: [5], 4: [1]},\n            \"terminals\": {3: -2, 5: 0},\n            \"heuristics\": {0: 0, 1: 3, 2: -1, 3: -2, 4: 2, 5: 0},\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        solver = GameSolver(\n            edges=case[\"edges\"],\n            terminals=case[\"terminals\"],\n            heuristics=case[\"heuristics\"],\n            initial_depth=case[\"depth_limit\"]\n        )\n        # Initial call to compute the value from the start state\n        value = solver.compute_v(\n            state=case[\"start_state\"],\n            depth=case[\"depth_limit\"],\n            path=set()\n        )\n        # The problem asks for an integer value in the output\n        results.append(int(round(value)))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3204272"}, {"introduction": "现在，是时候将所有知识融会贯通，从零开始构建一个完整的博弈AI了。这个综合性练习 ([@problem_id:3204320]) 要求你为一个在环形棋盘上进行的独特连接游戏实现一个AI玩家。你不仅需要应用带有alpha-beta剪枝的minimax算法，还必须亲自设计游戏的状态表示、合法走法生成和复杂的胜利条件检测，从而全面体验将抽象算法应用于具体问题的整个过程。", "problem": "设计并实现一个完整的程序，该程序在一个确定性的、信息完備的、双人零和博弈中，使用带有 Alpha-Beta 剪枝 (ABP) 的极小化极大原则（minimax principle）进行对抗性搜索。该博弈在一个环形棋盘上进行。环形棋盘是一个离散网格，其索引在边缘处会回绕。该博弈是放置棋子的一种变体，玩家轮流放置自己的棋子。当一名玩家在水平、垂直、东南对角线或西南对角线这四个基本方向中的任意一个方向上，成功创建一条完全由其自身棋子组成的、长度为 $k$ 的连线时，该玩家获胜。棋盘的边缘是回绕的，因此从一边跨出边缘会从另一边重新出现。\n\n基本与核心定义：\n- 双人零和博弈对于一个状态 $s$ 有一个效用函数 $u(s)$，使得一方玩家的收益即为另一方玩家的损失。最大化玩家寻求最大化 $u(s)$，而最小化玩家寻求最小化 $u(s)$。设两名玩家分别为 $X$ (最大化玩家) 和 $O$ (最小化玩家)。\n- 极小化极大算法递归地定义状态 $s$ 的值为：如果是 $X$ 的回合，则 $V(s) = \\max_{a \\in A(s)} V(T(s,a))$；如果是 $O$ 的回合，则 $V(s) = \\min_{a \\in A(s)} V(T(s,a))$。其中 $A(s)$ 是状态 $s$ 下的合法行动集合，$T(s,a)$ 是确定性的状态转移函数。\n- Alpha-Beta 剪枝维护边界值 $\\alpha$ 和 $\\beta$，使得对于博弈树中的任何节点，如果最大化玩家当前的最优值至少为 $\\beta$，或者最小化玩家当前的最优值至多为 $\\alpha$，那么对兄弟节点的进一步探索就可以被剪枝，而不会影响最终的极小化极大值。\n- 环形回绕通过对索引进行模运算实现。对于一个大小为 $n \\times n$ 的棋盘，从单元格 $(r,c)$ 沿方向 $(\\Delta r, \\Delta c)$ 移动一步，会到达下一个单元格 $(r', c')$，其坐标由 $r' = (r + \\Delta r) \\bmod n$ 和 $c' = (c + \\Delta c) \\bmod n$ 给出。四个方向为 $(\\Delta r, \\Delta c) \\in \\{(0,1), (1,0), (1,1), (1,-1)\\}$。\n\n博弈规则：\n- 棋盘是一个 $n \\times n$ 的网格，其中 $n \\in \\mathbb{Z}_{\\ge 2}$。\n- 每个单元格包含 $X$、$O$ 或空符号点 $.$.。\n- 玩家轮流在空单元格中放置自己的棋子。\n- 当存在一个由 $k$ 个单元格组成的序列，其中每一步都沿着上述四个方向之一进行，且所有 $k$ 个单元格都包含同一玩家的棋子时，该玩家獲胜。索引按模 $n$ 回绕。\n- 终止效用定义如下：如果 $X$ 有获胜连线，则 $u(s) = +1$；如果 $O$ 有获胜连线，则 $u(s) = -1$；如果棋盘已满且没有获胜连线，则 $u(s) = 0$。如果 $X$ 和 $O$ 同时拥有获胜连线（这在合法博弈中不可能发生，但可能出现在任意输入中），则定义 $u(s) = 0$。\n- 程序必须实现带有 ABP 的极小化极大算法，以计算当前玩家在当前状态下的最优效用和一个最优移动。\n\n获胜检测的数学表述：\n- 对于每个起始单元格 $(r,c)$ 和每个方向 $(\\Delta r, \\Delta c)$，检查单元格集合 $\\{(r + t \\Delta r \\bmod n, c + t \\Delta c \\bmod n) \\mid t \\in \\{0,1,\\dots,k-1\\}\\}$ 是否全部包含 $X$ 或全部包含 $O$。\n\n本问题的输入和输出规范：\n- 没有用户输入。将下述测试套件直接硬编码在程序中。\n- 对于每个测试用例，程序必须计算一个包含以下两项的对：\n  - 当前玩家的最优极小化极大效用，表示为 $\\{-1,0,+1\\}$ 中的一个整数。\n  - 一个最优移动，表示为使用零基索引的坐标 $(r,c)$。如果局面已是终止状态或没有合法移动，则输出哨兵值 $(r,c) = (-1,-1)$。\n- 最终输出格式为单行，包含所有测试用例的结果列表。每个独立的结果必须是 $[u,r,c]$ 形式的包含三个整数的列表，且整个输出必须是 $[[u_1,r_1,c_1],[u_2,r_2,c_2],\\dots]$ 格式的单个列表，使用逗号分隔且无空格。\n\n测试套件：\n每个测试用例指定为一个元组 $(n,k,\\text{board},P)$，其中 $n$ 是棋盘大小，$k$ 是获胜所需连线长度，$\\text{board}$ 是一个由 $n$ 个长度为 $n$ 的字符串组成的列表（使用字母表 $\\{X,O,.\\}$），$P \\in \\{X,O\\}$ 是当前要移动的玩家。\n\n- 测试用例 1 ($X$ 可通过环绕东南对角线立即获胜)：\n  - $n = 3$, $k = 3$, $P = X$。\n  - $\\text{board} = [\".OO\", \".X.\", \"..X\"]$。\n  - 预期最优移动会利用环绕对角线 $(2,2) \\to (0,0) \\to (1,1)$。\n\n- 测试用例 2 ($O$ 可立即完成水平连线)：\n  - $n = 3$, $k = 3$, $P = O$。\n  - $\\text{board} = [\"O.O\", \"X.X\", \"X..\"]$。\n  - 最优移动将完成顶行。\n\n- 测试用例 3 (已为终止状态，$X$ 在一条环绕对角线上获胜)：\n  - $n = 3$, $k = 3$, $P = O$。\n  - $\\text{board} = [\"XOO\", \"OXO\", \"..X\"]$。\n  - 东南对角线 $(0,0) \\to (1,1) \\to (2,2)$ 全是 $X$。\n\n- 测试用例 4 (大小为 4，$k=4$，$O$ 可立即完成一行)：\n  - $n = 4$, $k = 4$, $P = O$。\n  - $\\text{board} = [\".OOO\", \"XX..\", \"....\", \"....\"]$。\n\n- 测试用例 5 (大小为 4，$k=3$，$X$ 可通过一个不平凡的模式在环绕东南对角线上获胜)：\n  - $n = 4$, $k = 3$, $P = X$。\n  - $\\text{board} = [\"....\", \"X...\", \"....\", \"..X.\"]$。\n  - 获胜移动将完成环绕对角线 $(3,2) \\to (0,3) \\to (1,0)$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表（例如，\"[[u1,r1,c1],[u2,r2,c2],...]\"），输出行中任何地方都不能有空格。所有索引 $(r,c)$ 必须是零基整数，效用值必须是 $\\{-1,0,+1\\}$ 中的整数。", "solution": "该问题要求实现带有 Alpha-Beta 剪枝 (ABP) 的极小化极大算法，以在环形网格上的一个双人零和博弈中找到最优移动。解决方案的设计思路是先将博弈规则和状态形式化，然后应用对抗性搜索的原理。\n\n整体方法涉及从当前状态开始对博弈树进行递归探索。每个状态的值由极小化极大原则确定，该原则假设双方玩家都采取最优策略。最大化玩家 $X$ 旨在达到可能效用最高的状态，而最小化玩家 $O$ 则旨在达到效用最低的状态。Alpha-Beta 剪枝用于优化此搜索过程，它通过消除那些不可能影响最终决策的博弈树分支来实现。\n\n该实现分为四个主要部分：\n1.  **状态评估**：一个函数，用于确定博弈状态是否为终止状态并计算其效用。\n2.  **移动生成**：一个函数，用于识别给定状态下的所有合法移动。\n3.  **递归搜索**：核心的 Alpha-Beta 搜索函数，它递归地计算一个状态的极小化极大值。\n4.  **顶层驱动**：一个函数，用于组织对初始状态的搜索，以识别最优移动及其对应的效用。\n\n**1. 状态表示与终止评估**\n一个博弈状态 $s$ 由 $n \\times n$ 的棋盘配置和轮到哪位玩家移动来定义。棋盘表示为一个二维数组，其中单元格可被 $X$、$O$ 占据，或者为空 ($_.$)。\n\n如果一个玩家已形成获胜连线或棋盘已满，则状态为终止状态。效用函数 $u(s)$ 定义如下：\n- 如果玩家 $X$ 有获胜连线，则 $u(s) = +1$。\n- 如果玩家 $O$ 有获胜连线，则 $u(s) = -1$。\n- 如果棋盘已满且没有赢家（平局），则 $u(s) = 0$。\n- 如果双方玩家同时拥有获胜连线，则 $u(s) = 0$。\n\n获胜检测逻辑至关重要。玩家通过形成一条由 $k$ 个自己棋子组成的连线来获胜。由于棋盘的环形特性，连线可以环绕边缘。为了检查获胜，我们必须检查棋盘上的每个单元格 $(r,c)$ 作为潜在获胜连线的起点。对于每个起始单元格，我们在四个基本方向 $(\\Delta r, \\Delta c) \\in \\{(0,1), (1,0), (1,1), (1,-1)\\}$ 中的每一个方向上进行检查。如果序列\n$$ \\{(r + t \\Delta r \\pmod n, c + t \\Delta c \\pmod n) \\mid t \\in \\{0, 1, \\dots, k-1\\}\\} $$\n中的所有 $k$ 个单元格都被该玩家的棋子占据，则该玩家存在一条获胜连线。模运算符处理环形回绕。评估函数首先检查 $X$ 是否获胜，然后检查 $O$ 是否获胜，最后检查棋盘是否已满，以确定状态的效用。如果状态不是终止状态，则不返回效用。\n\n**2. 移动生成**\n对于一个非终止状态 $s$，可用行动集合 $A(s)$ 由棋盘上所有空单元格组成。通过对棋盘网格进行简单迭代，可以识别出所有内容为空符号的坐标 $(r,c)$。\n\n**3. Alpha-Beta 搜索算法**\n解决方案的核心是一个递归函数 `alpha_beta_search(state, player, alpha, beta)`，它计算给定状态的极小化极大值。参数 $\\alpha$ 和 $\\beta$ 表示在搜索树中到目前为止已发现的可能效用值的边界。\n- $\\alpha$：到目前为止，在通往根节点的路径上为最大化玩家找到的最佳值（最高效用）。\n- $\\beta$：到目前为止，在通往根节点的路径上为最小化玩家找到的最佳值（最低效用）。\n\n该函数按以下方式运作：\n首先，它评估输入状态。如果状态是终止状态，它返回相应的效用值 ($+1, -1, 0$)。如果棋盘已满且没有赢家，则为平局，效用为 $0$。\n\n如果状态不是终止状态，函数将根据当前玩家继续执行：\n- **如果 `player` 是 $X$ (最大化玩家)：** 目标是最大化结果。函数初始化一个值 $v = -\\infty$。然后它遍历每个合法移动，应用移动创建一个新的后继状态，并为最小化玩家的回合（`player` = $O$）递归调用 `alpha_beta_search`。值 $v$ 被更新为在子节点中找到的最大效用：$v = \\max(v, \\text{recursive\\_result})$。最大化玩家的下界 $\\alpha$ 被更新：$\\alpha = \\max(\\alpha, v)$。如果在任何時候 $\\alpha \\ge \\beta$，则该分支的搜索将被终止（剪枝），因为这意味着最小化玩家在树的更上层有一个更好的备选移动。\n\n- **如果 `player` 是 $O$ (最小化玩家)：** 目标是最小化结果。函数初始化一个值 $v = +\\infty$。它遍历合法移动，创建后继状态，并为最大化玩家的回合（`player` = $X$）递归调用 `alpha_beta_search`。值 $v$ 被更新为最小效用：$v = \\min(v, \\text{recursive\\_result})$。最小化玩家的上界 $\\beta$ 被更新：$\\beta = \\min(\\beta, v)$。如果 $\\beta \\le \\alpha$，则发生剪枝，因为这意味着最大化玩家在其他地方有更好的选择。\n\n**4. 顶层驱动程序**\n一个主驱动函数启动该过程。它接受初始博弈状态 $(n, k, \\text{board}, P)$ 作为输入。\n1. 它首先检查初始状态是否已经是终止状态或没有合法移动。如果是，它返回该状态的效用和哨兵移動 $(-1,-1)$。\n2. 否则，它遍历当前玩家 $P$ 的所有可用合法移动。\n3. 对于每个潜在移动，它生成结果棋盘状态，并调用 `alpha_beta_search` 函数来确定该移动的效用，前提是假设对手采取最优策略。对搜索函数的初始调用使用 $\\alpha = -\\infty$ 和 $\\beta = +\\infty$。\n4. 它跟踪为当前玩家 ($P$) 带来最佳可能效用的移动。对于玩家 $X$，这是导致最大效用的移动；对于玩家 $O$，这是导致最小效用的移动。\n5. 函数返回计算出的最优效用和相应的最优移动 $(r,c)$。\n这种全面的、基于原则的设计确保了根据极小化极大定理正确而高效地确定最优移动。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass ToroidalGame:\n    \"\"\"\n    Implements the logic for a toroidal k-in-a-row game and its solution\n    using minimax with alpha-beta pruning.\n    \"\"\"\n    def __init__(self, n, k, board_str, current_player):\n        self.n = int(n)\n        self.k = int(k)\n        self.board = np.array([list(row) for row in board_str])\n        self.current_player = current_player\n        self.directions = [(0, 1), (1, 0), (1, 1), (1, -1)]\n\n    def _check_win(self, board, player_mark):\n        \"\"\"Checks if a given player has a winning line on the board.\"\"\"\n        for r in range(self.n):\n            for c in range(self.n):\n                for dr, dc in self.directions:\n                    is_win = True\n                    for t in range(self.k):\n                        nr, nc = (r + t * dr) % self.n, (c + t * dc) % self.n\n                        if board[nr, nc] != player_mark:\n                            is_win = False\n                            break\n                    if is_win:\n                        return True\n        return False\n\n    def _evaluate_terminal(self, board):\n        \"\"\"\n        Evaluates a board state. Returns utility if terminal, else None.\n        Utility: +1 for X win, -1 for O win, 0 for draw or simultaneous win.\n        \"\"\"\n        win_X = self._check_win(board, 'X')\n        win_O = self._check_win(board, 'O')\n\n        if win_X and win_O:\n            return 0\n        if win_X:\n            return 1\n        if win_O:\n            return -1\n        if np.all(board != '.'):\n            return 0\n        return None  # Not terminal\n\n    def _get_legal_moves(self, board):\n        \"\"\"Returns a list of legal moves (empty cells).\"\"\"\n        return [(r, c) for r, c in zip(*np.where(board == '.'))]\n\n    def _alpha_beta_search(self, board, player, alpha, beta):\n        \"\"\"\n        Recursive core of the minimax algorithm with alpha-beta pruning.\n        \"\"\"\n        utility = self._evaluate_terminal(board)\n        if utility is not None:\n            return utility\n\n        moves = self._get_legal_moves(board)\n        if not moves:\n            return 0  # Draw if no moves and not a win state\n\n        if player == 'X':  # Maximizer\n            max_eval = -np.inf\n            for r, c in moves:\n                new_board = board.copy()\n                new_board[r, c] = 'X'\n                eval_child = self._alpha_beta_search(new_board, 'O', alpha, beta)\n                max_eval = max(max_eval, eval_child)\n                alpha = max(alpha, eval_child)\n                if beta = alpha:\n                    break\n            return max_eval\n        else:  # Minimizer (player == 'O')\n            min_eval = np.inf\n            for r, c in moves:\n                new_board = board.copy()\n                new_board[r, c] = 'O'\n                eval_child = self._alpha_beta_search(new_board, 'X', alpha, beta)\n                min_eval = min(min_eval, eval_child)\n                beta = min(beta, eval_child)\n                if beta = alpha:\n                    break\n            return min_eval\n\n    def find_best_move(self):\n        \"\"\"\n        Top-level driver to find the optimal move and utility for the current player.\n        \"\"\"\n        utility = self._evaluate_terminal(self.board)\n        if utility is not None:\n            return utility, -1, -1\n\n        moves = self._get_legal_moves(self.board)\n        if not moves:\n            return 0, -1, -1\n\n        best_move = (-1, -1)\n        if self.current_player == 'X':\n            best_val = -np.inf\n            for r, c in moves:\n                new_board = self.board.copy()\n                new_board[r, c] = 'X'\n                val = self._alpha_beta_search(new_board, 'O', -np.inf, np.inf)\n                if val > best_val:\n                    best_val = val\n                    best_move = (r, c)\n                # Optimization: if a winning move is found, no need to search further.\n                if best_val == 1:\n                    break\n        else:  # self.current_player == 'O'\n            best_val = np.inf\n            for r, c in moves:\n                new_board = self.board.copy()\n                new_board[r, c] = 'O'\n                val = self._alpha_beta_search(new_board, 'X', -np.inf, np.inf)\n                if val  best_val:\n                    best_val = val\n                    best_move = (r, c)\n                # Optimization: if a winning move is found, no need to search further.\n                if best_val == -1:\n                    break\n        \n        return int(best_val), int(best_move[0]), int(best_move[1])\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (3, 3, [\".OO\", \".X.\", \"..X\"], 'X'),\n        (3, 3, [\"O.O\", \"X.X\", \"X..\"], 'O'),\n        (3, 3, [\"XOO\", \"OXO\", \"..X\"], 'O'),\n        (4, 4, [\".OOO\", \"XX..\", \"....\", \"....\"], 'O'),\n        (4, 3, [\"....\", \"X...\", \"....\", \"..X.\"], 'X'),\n    ]\n\n    results = []\n    for n, k, board_str, player in test_cases:\n        game = ToroidalGame(n, k, board_str, player)\n        utility, r, c = game.find_best_move()\n        results.append([utility, r, c])\n\n    output_str = f\"[{','.join([f'[{u},{r},{c}]' for u, r, c in results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3204320"}]}