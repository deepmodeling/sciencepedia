{"hands_on_practices": [{"introduction": "Christofides 算法是度量旅行商问题（TSP）最著名的近似算法之一。在着手实现之前，理解其为何能提供一个可靠的性能保证是至关重要的一步。本练习将引导你仅从基本定义出发，例如最小生成树的性质和度量空间的三角不等式，一步步推导出其经典的 $\\frac{3}{2}$ 近似比。通过这个推导，你将对该算法的理论基石建立深刻的理解。[@problem_id:3280068]", "problem": "考虑一个在欧几里得平面 $\\mathbb{R}^{2}$ 中嵌入的包含 $n$ 个点的集合 $V$ 上的完全图，其边权重由欧几里得距离 $d(u,v)$ 给出（其中 $u,v \\in V$），因此 $d$ 是一个满足三角不等式的度量。您希望使用以下流程来计算旅行商问题（TSP）的一个巡回：\n\n1.  用一个稀疏超图 $H$ 替换稠密图，该超图可被证明包含欧几里得最小生成树（MST），例如 Delaunay 三角剖分。Delaunay 三角剖分可以在期望 $O(n\\log n)$ 时间内构建，并且有 $O(n)$ 条边。或者，对于随机输入，您可以讨论基于 $k$-近邻的启发式方法，这些方法可以减少候选边的数量，同时保持期望 $O(n\\log n)$ 的构建时间；但是，近似的正确性不得依赖于随机性。\n2.  在 $H$ 上运行带有不相交集合并（DSU，也称并查集）的 Kruskal 算法来计算一个最小生成树 $T$；因为 $H$ 包含了原始完全图的一个最小生成树，所以 $H$ 的最小生成树 $T$ 也是 $V$ 上完全图的一个最小生成树。\n3.  令 $S \\subseteq V$ 为 $T$ 中度数为奇数的顶点集合。计算 $S$ 上关于度量 $d$ 的一个最小权重完美匹配 $M$，并形成多重图 $G' = T \\cup M$。因为 $G'$ 中所有顶点的度数都是偶数，所以 $G'$ 是一个欧拉图。计算 $G'$ 的一个欧拉巡回，并利用三角不等式通过抄近路跳过重复的顶点，以获得 $V$ 上的一个哈密顿回路 $C$。\n\n仅从关于度量、生成树和欧拉巡回的基本定义和事实出发，推导一个最坏情况下的乘法常数 $c$，使得返回的 TSP 巡回的长度 $w(C)$ 满足 $w(C) \\leq c \\cdot w(\\mathrm{OPT})$，其中 $w(\\mathrm{OPT})$ 表示在该度量下的最优 TSP 巡回的长度。您的推导除了三角不等式和每个构造对象的定义外，不得假设任何先验界限。\n\n请将常数 $c$ 的精确值报告为单个最简分数或实数，不带单位。如果您选择讨论通过 $k$-近邻进行的启发式剪枝，请确保您对 $c$ 的推导通过依赖一个包含 MST 的确定性稀疏超图来保持其有效性，而不受启发式随机性的影响。时间复杂度的讨论和剪枝细节是推理过程的一部分，但最终要求的答案只是常数 $c$。", "solution": "该问题要求在一个度量空间中，为旅行商问题（TSP）的一个特定算法推导其最坏情况近似比 $c$。该算法是 Christofides 算法的一个变体，它构造一个巡回 $C$，我们的目标是找到常数 $c$，使得其权重 $w(C)$ 满足 $w(C) \\leq c \\cdot w(\\mathrm{OPT})$，其中 $w(\\mathrm{OPT})$ 是最优 TSP 巡回的权重。推导过程将通过分析算法每一步的权重贡献来进行。\n\n问题定义在一个顶点集为 $V$（大小为 $n$）的完全图上，其中顶点是 $\\mathbb{R}^2$ 中的点。边权重由欧几里得距离 $d(u,v)$ 给出，该距离满足三角不等式：对于任意三个顶点 $u, v, w \\in V$，$d(u,w) \\leq d(u,v) + d(v,w)$。此推导对任何通用度量都成立，而不仅仅是欧几里得度量。\n\n该算法包括以下步骤：\n$1$. 计算 $V$ 上完全图的一个最小生成树（MST），记为 $T$。问题描述中提到，这可以通过先构建一个保证包含完全图 MST 的稀疏超图 $H$（例如 Delaunay 三角剖分），然后在 $H$ 上运行 MST 算法来高效完成。MST 的权重为 $w(T)$。\n$2$. 找出 $T$ 中所有度数为奇数的顶点集合 $S$。\n$3$. 在集合 $S$ 的顶点上计算一个最小权重完美匹配 $M$。该匹配的权重为 $w(M)$。\n$4$. 形成一个多重图 $G' = T \\cup M$。\n$5$. 在 $G'$ 中找到一个欧拉巡回，并通过抄近路跳过重复的顶点，将其转换为一个哈密顿回路（最终的巡回 $C$）。\n\n现在，我们将用最优巡回 $\\mathrm{OPT}$ 的权重来界定最终巡回 $C$ 的权重。\n\n首先，我们建立 MST 的权重 $w(T)$ 与最优巡回的权重 $w(\\mathrm{OPT})$ 之间的关系。一个最优 TSP 巡回是一个访问 $V$ 中每个顶点的哈密顿回路。如果我们从这个巡回中移除任意一条边，结果是一个生成路径，它是一种特定类型的生成树。该生成路径的权重严格小于 $w(\\mathrm{OPT})$（假设所有边权重都是正的）。根据定义，最小生成树 $T$ 是权重尽可能小的生成树。因此，$T$ 的权重必须小于或等于任何其他生成树的权重，包括从最优巡回派生出的那个。因此，我们得到基本不等式：\n$$w(T) \\leq w(\\mathrm{OPT})$$\n对于边权重可以为零的情况，不等式将是 $w(T) \\leq w(\\mathrm{OPT})$，这对我们的目的而言是足够的。\n\n其次，我们分析 MST $T$ 中奇数度顶点的集合 $S$。图论中的一个著名定理（握手引理）指出，任何有限图中所有顶点的度数之和等于边数的两倍。这个和必须是一个偶数。\n$$\\sum_{v \\in V} \\deg_T(v) = 2|E_T|$$\n其中 $E_T$ 是 $T$ 的边集。我们可以根据度数的奇偶性将这个和进行划分：\n$$\\sum_{v \\in S} \\deg_T(v) + \\sum_{v \\in V \\setminus S} \\deg_T(v) = 2|E_T|$$\n第二个和是偶数度顶点的度数之和，因此其中每一项都是偶数，这个和本身也是偶数。为了使整个表达式为偶数，第一个和 $\\sum_{v \\in S} \\deg_T(v)$ 也必须是偶数。由于这个和中的每一项都是奇数（根据 $S$ 的定义），所以项数 $|S|$ 必须是偶数。这证明了奇数度顶点的数量是偶数，这是在 $S$ 上存在完美匹配的必要条件。\n\n第三，我们界定最小权重完美匹配 $M$ 的权重 $w(M)$。设 $S$ 的顶点为 $\\{s_1, s_2, \\ldots, s_{2k}\\}$，其中 $|S| = 2k$，对于某个整数 $k \\geq 1$（假设图不仅仅是一条路径，在这种情况下 $|S|$ 可能为 $0$ 或 $2$，论证也平凡成立）。考虑最优 TSP 巡回 $\\mathrm{OPT}$。我们创建一个子巡回 $C_S$，它仅按照顶点在 $\\mathrm{OPT}$ 中出现的顺序访问 $S$ 中的顶点。通过应用三角不等式对 $\\mathrm{OPT}$ 中经过非 $S$ 顶点的路径进行抄近路，这个子巡回的总权重 $w(C_S)$ 不大于原始最优巡回的权重：\n$$w(C_S) \\leq w(\\mathrm{OPT})$$\n巡回 $C_S$ 是一个包含 $2k$ 个顶点的回路。我们可以将这个回路的边划分为 $S$ 上的两个不相交的完美匹配。设巡回中的顶点顺序为 $(v_1, v_2, \\ldots, v_{2k})$。第一个匹配 $M_1$ 由边 $(v_1, v_2), (v_3, v_4), \\ldots, (v_{2k-1}, v_{2k})$ 组成。第二个匹配 $M_2$ 由边 $(v_2, v_3), (v_4, v_5), \\ldots, (v_{2k}, v_1)$ 组成。这两个匹配的权重之和恰好是巡回 $C_S$ 的权重：\n$$w(M_1) + w(M_2) = w(C_S)$$\n由此可知，这两个匹配中较轻者的权重至多是总权重的一半：\n$$\\min(w(M_1), w(M_2)) \\leq \\frac{1}{2} w(C_S)$$\n该算法计算了 $M$，即 $S$ 上的最小权重完美匹配。根据最小性的定义，其权重 $w(M)$ 必须小于或等于 $S$ 上任何其他完美匹配的权重，包括 $M_1$ 和 $M_2$。因此，$w(M) \\leq \\min(w(M_1), w(M_2))$。结合这些不等式，我们得到：\n$$w(M) \\leq \\frac{1}{2} w(C_S) \\leq \\frac{1}{2} w(\\mathrm{OPT})$$\n\n第四，我们考虑多重图 $G' = T \\cup M$。$G'$ 中一个顶点 $v$ 的度数是 $\\deg_{G'}(v) = \\deg_T(v) + \\deg_M(v)$。\n- 如果 $v \\in S$，那么 $\\deg_T(v)$ 是奇数，$\\deg_M(v) = 1$（因为 $M$ 是 $S$ 上的完美匹配）。所以，$\\deg_{G'}(v)$ 是偶数。\n- 如果 $v \\notin S$，那么 $\\deg_T(v)$ 是偶数，$\\deg_M(v) = 0$。所以，$\\deg_{G'}(v)$ 是偶数。\n由于 $G'$ 中所有顶点都具有偶数度，并且图是连通的（因为它包含了生成树 $T$），所以 $G'$ 是一个欧拉图。一个欧拉巡回恰好遍历 $G'$ 的每条边一次。这样一个巡回的总长度是 $G'$ 中所有边的权重之和，即 $w(G') = w(T) + w(M)$。\n\n最后，该算法通过遍历欧拉巡回并抄近路跳过任何先前访问过的顶点来构造 TSP 巡回 $C$。对于欧拉巡回中的任何路径 $u \\to w_1 \\to \\dots \\to w_m \\to v$，三角不等式保证了直接边权重 $d(u,v)$ 小于或等于该路径的长度 $d(u,w_1) + \\ldots + d(w_m,v)$。通过重复应用此原理，最终的哈密顿回路 $C$ 的总权重 $w(C)$ 不大于欧拉巡回的总长度：\n$$w(C) \\leq w(G')$$\n\n综合我们所有的发现，我们可以完成对近似比 $c$ 的推导：\n$$w(C) \\leq w(G') = w(T) + w(M)$$\n代入我们为 $w(T)$ 和 $w(M)$ 推导出的界限：\n$$w(C) \\leq w(\\mathrm{OPT}) + \\frac{1}{2} w(\\mathrm{OPT})$$\n$$w(C) \\leq \\frac{3}{2} w(\\mathrm{OPT})$$\n这表明该算法产生的巡回长度至多是最优巡回长度的 $1.5$ 倍。因此，最坏情况下的乘法常数是 $c = \\frac{3}{2}$。", "answer": "$$\\boxed{\\frac{3}{2}}$$", "id": "3280068"}, {"introduction": "掌握了理论保证之后，下一步便是将算法付诸实践，看看它在真实数据上的表现。本练习要求你完整实现 Christofides 算法，并与精确的 TSP 求解器进行性能比较。通过在不同的 $L_p$ 度量空间下进行测试，你不仅能凭经验验证算法的近似效果，还能更深刻地体会到其理论保证的普适性——它仅仅依赖于度量性质本身，而与具体的度量标准无关。[@problem_id:3280045]", "problem": "给定平面上的一组点，要求您研究在 $L_p$ 度量族下的旅行商问题 (TSP)。对于点 $(x_i,y_i) \\in \\mathbb{R}^2$ 和参数 $p \\in [1,\\infty]$，两点 $(x,y)$ 和 $(x',y')$ 之间的 $L_p$ 距离定义为\n$$\nd_p\\big((x,y),(x',y')\\big) = \\begin{cases}\n\\left(|x-x'|^p + |y-y'|^p\\right)^{1/p}  \\text{若 } 1 \\le p  \\infty \\\\\n\\max\\left(|x-x'|,|y-y'|\\right)  \\text{若 } p = \\infty.\n\\end{cases}\n$$\n考虑一个度量 TSP 问题，其对象是一个完全图，图的顶点是给定的点集，边权重由 $d_p$ 给出。实现 Christofides 算法，并通过计算 Christofides 算法得到的路径长度与最优 TSP 路径长度（通过动态规划精确计算）的比率，来比较该算法在不同 $p$ 值下的经验性能。\n\n在您的推导和算法设计中应使用的基础知识：\n- 完全度量图上的旅行商问题 (TSP)：每对顶点之间都有一条满足三角不等式的非负权重边，目标是找到一条访问每个顶点恰好一次的最小权重哈密顿回路。\n- 最小生成树 (MST) 是连通无向图中总权重最小的生成树。\n- Christofides 算法通过以下步骤构造一条路径：计算一个 MST，找到 MST 中所有奇度顶点组成的集合，在该集合上计算一个最小权重完美匹配，通过组合 MST 和匹配形成一个欧拉多重图，最后通过走捷径得到一个哈密顿回路。走捷径不会增加路径长度的保证依赖于三角不等式。\n- 用于精确求解 TSP 的 Held–Karp 动态规划方法可以在 $O(n^2 2^n)$ 的时间内解决完全图上的 TSP 问题，其中 $n$ 是顶点数。\n\n任务：\n1. 为测试套件中指定的 $p$ 值，实现用于 $L_p$ 度量的 Christofides 算法。对于奇度顶点集上的最小权重完美匹配步骤，请在这些顶点的诱导完全子图上使用精确配对的动态规划方法；对于所提供的实例，这种方法在计算上是可行的。\n2. 实现 Held–Karp 动态规划算法，为相同的实例和相同的 $p$ 值计算精确的最优 TSP 路径长度。\n3. 对每个测试用例，计算比率\n$$\n\\rho(p) = \\frac{\\text{Christofides}_{p}}{\\text{OPT}_{p}},\n$$\n其中 $\\text{Christofides}_{p}$ 是 Christofides 算法在 $L_p$ 度量下返回的路径长度，而 $\\text{OPT}_{p}$ 是在相同度量下的精确最优路径长度。将 $\\rho(p)$ 表示为一个四舍五入到六位小数的实数。\n\n理论分析要求：\n- 从第一性原理出发，解释为什么当距离由 $L_p$ 度量衡量时，Christofides 算法的 $1.5$ 常数因子界在 $p \\in [1,\\infty]$ 的范围内是不变的。\n\n测试套件：\n使用以下平面点实例集和度量参数。每个实例是一个点列表，每个 $p$ 是指定的数值之一。对于下面的每一对 $(\\text{points}, p)$，计算 $\\rho(p)$。\n\n- 实例 $\\mathcal{I}_1$（6 个点）：\n$$\n\\{(0,0),(4,0),(4,1),(0,1),(2,0),(2,1)\\}.\n$$\n- 实例 $\\mathcal{I}_2$（7 个点）：\n$$\n\\{(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(9,0)\\}.\n$$\n- 实例 $\\mathcal{I}_3$（8 个点）：\n$$\n\\{(0,0),(5,0),(5,5),(0,5),(2,1),(3,1),(2,4),(3,4)\\}.\n$$\n- 对于每个实例，使用 $p \\in \\{1,2,10,\\infty\\}$。\n\n总共产生 12 个测试用例。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须包含 12 个浮点数，对应于上述测试用例的 $\\rho(p)$ 值，每个值都四舍五入到六位小数，并按以下顺序排列：\n$$\n\\big[\\rho_{\\mathcal{I}_1}(1),\\rho_{\\mathcal{I}_1}(2),\\rho_{\\mathcal{I}_1}(10),\\rho_{\\mathcal{I}_1}(\\infty),\\rho_{\\mathcal{I}_2}(1),\\rho_{\\mathcal{I}_2}(2),\\rho_{\\mathcal{I}_2}(10),\\rho_{\\mathcal{I}_2}(\\infty),\\rho_{\\mathcal{I}_3}(1),\\rho_{\\mathcal{I}_3}(2),\\rho_{\\mathcal{I}_3}(10),\\rho_{\\mathcal{I}_3}(\\infty)\\big].\n$$\n不应打印任何额外文本。", "solution": "该问题是有效的，因为它具有科学依据、问题明确、客观，并包含了完整解决方案所需的所有必要信息。这是算法和计算几何领域的标准问题。\n\n### 理论分析：Christofides 近似比的不变性\n\n对于度量图上的旅行商问题 (TSP)，Christofides 算法保证其生成的路径长度最多是最优路径长度的 $1.5$ 倍。我们将从第一性原理证明，对于任何 $p \\in [1, \\infty]$，这一保证与 $L_p$ 度量的具体选择无关。该证明的有效性完全依赖于度量空间的性质，而所有 $L_p$ 空间都是度量空间。\n\n一个函数 $d(u,v)$ 若对所有点 $u, v, w$ 满足以下三个性质，则它是一个度量：\n1.  **非负性和不可分者同一性**：$d(u,v) \\ge 0$，且 $d(u,v) = 0$ 当且仅当 $u=v$。\n2.  **对称性**：$d(u,v) = d(v,u)$。\n3.  **三角不等式**：$d(u,w) \\le d(u,v) + d(v,w)$。\n\n对于 $p \\in [1, \\infty)$，$L_p$ 距离是一个有效的度量；它满足三角不等式是 Minkowski 不等式的直接推论。对于 $p=\\infty$，可以通过简单的案例分析证明三角不等式。由于我们 TSP 实例中的边权重由 $L_p$ 距离定义，该图是一个度量图。Christofides 近似比的证明仅依赖于这一事实。\n\n设 $\\mathcal{G} = (V, E)$ 是点集上的完全图，其边权重由 $L_p$ 度量给出。设 $T^*$ 是权重为 $W(T^*)$ 的最优 TSP 路径。\n\nChristofides 算法的步骤及其成本分析如下：\n\n1.  **计算最小生成树 (MST)**：设 $M$ 是 $\\mathcal{G}$ 的一个 MST。MST 的权重 $W(M)$ 是最优路径长度的一个下界。具体来说，通过从最优路径 $T^*$ 中移除任意一条边，我们可以得到一条生成路径，它是一种生成树。根据定义，MST 是所有可能的生成树中权重最小的。因此：\n    $$W(M) \\le W(T^*)$$\n\n2.  **识别奇度顶点**：设 $O \\subseteq V$ 是在 MST $M$ 中度数为奇数的顶点集合。任何图的一个基本性质是奇度顶点的数量必须是偶数。设 $|O| = 2k$，其中 $k \\ge 0$ 为整数。\n\n3.  **找到最小权重完美匹配 (MWPM)**：考虑由 $O$ 中顶点诱导的 $\\mathcal{G}$ 的子图。在这些顶点上找到一个最小权重完美匹配 $P$。为了界定这个匹配的权重 $W(P)$，我们再次使用最优路径 $T^*$。\n    -   考虑最优路径 $T^*$，并通过走捷径使其只按原始顺序访问 $O$ 中的顶点。这会在 $O$ 的顶点上创建一个回路。由于三角不等式对任何 $L_p$ 度量都成立，这个新回路的权重 $W(T^*_O)$ 不会大于原始路径的权重：$W(T^*_O) \\le W(T^*)$。\n    -   回路 $T^*_O$ 是一个包含偶数个顶点（$2k$ 个）的路径。它可以分解为 $O$ 上的两个不相交的完美匹配，例如 $P_1$ 和 $P_2$，使得 $W(T^*_O) = W(P_1) + W(P_2)$。\n    -   根据鸽巢原理，这两个匹配中至少有一个的权重不超过该回路总权重的一半：$\\min(W(P_1), W(P_2)) \\le W(T^*_O) / 2$。\n    -   由于 $P$ 是 $O$ 上的*最小权重*完美匹配，其权重不会超过 $O$ 上任何其他完美匹配的权重。因此，$W(P) \\le \\min(W(P_1), W(P_2))$。\n    -   结合这些不等式，我们得到了匹配权重的关键界限：\n    $$W(P) \\le \\frac{W(T^*_O)}{2} \\le \\frac{W(T^*)}{2}$$\n\n4.  **形成欧拉多重图**：通过取 MST ($M$) 和完美匹配 ($P$) 的边的并集，形成一个新的多重图 $\\mathcal{G}'$。$\\mathcal{G}'$ 中边的总权重为 $W(\\mathcal{G}') = W(M) + W(P)$。现在 $\\mathcal{G}'$ 中所有顶点的度数都是偶数：最初在 $M$ 中度数为偶数的顶点不受 $P$ 的影响，度数保持为偶数；而 $O$ 中的顶点（在 $M$ 中度数为奇数）恰好与一条来自 $P$ 的边相连，使其新的总度数变为偶数。\n\n5.  **找到欧拉回路并走捷径**：由于 $\\mathcal{G}'$ 中所有顶点的度数均为偶数，因此存在一条欧拉回路（一条恰好遍历每条边一次的回路）。这条欧拉回路的长度恰好是 $W(\\mathcal{G}')$。使用我们在步骤 1 和步骤 3 中得到的界限：\n    $$W(\\mathcal{G}') = W(M) + W(P) \\le W(T^*) + \\frac{W(T^*)}{2} = 1.5 \\cdot W(T^*)$$\n    最后，通过遍历欧拉回路并跳过任何已经访问过的顶点，将欧拉回路转换为哈密顿回路（最终的 Christofides 路径 $T_C$）。三角不等式保证了这个“走捷径”的过程不会增加总长度。因此，最终路径的长度 $W(T_C)$ 满足：\n    $$W(T_C) \\le W(\\mathcal{G}') \\le 1.5 \\cdot W(T^*)$$\n\n此推导完全独立于 $p$ 的具体值。证明仅依赖于该图是一个度量空间，这是所有 $L_p$ 度量都满足的条件。因此，Christofides 算法的 $1.5$ 近似保证在 $p \\in [1, \\infty]$ 的范围内是不变的。\n\n### 算法设计\n\n解决方案需要实现两种算法：Christofides 启发式算法和精确的 Held-Karp 算法。\n\n**1. Christofides 算法实现**\n对于给定的一组 $n$ 个点和一个参数 $p$，路径长度按以下方式计算：\n- **距离矩阵**：首先，构造一个完整的 $n \\times n$ 距离矩阵，其中条目 $(i, j)$ 是点 $i$ 和点 $j$ 之间的 $L_p$ 距离。\n- **最小生成树 (MST)**：使用 Prim 算法在完全图上找到 MST。Prim 算法对于稠密图是高效的，运行时间为 $O(n^2)$。它通过迭代添加连接 MST 中顶点与 MST 外顶点的最便宜的边来构建 MST。\n- **奇度顶点**：计算所生成的 MST 中所有顶点的度数。收集度数为奇数的顶点集合 $O$。\n- **最小权重完美匹配 (MWPM)**：在奇度顶点 $O$ 的诱导子图上找到一个精确的最小权重完美匹配。根据要求，这通过使用位掩码的动态规划来解决。设 $|O| = 2k$。一个 DP 状态 `dp[mask]` 存储由 `mask` 表示的 $O$ 的子集上的最小匹配成本。递推关系为：\n  `dp[mask] = min_{j \\in S \\setminus \\{i\\}} (d(i, j) + dp[S \\setminus \\{i, j\\}])`，其中 $i$ 是对应于 `mask` 的子集 $S$ 的一个固定元素。此过程的运行时间为 $O(k^2 2^k)$。\n- **欧拉回路和走捷径**：将来自 MST 和 MWPM 的边组合起来，形成一个欧拉多重图的邻接表表示。然后使用 Hierholzer 算法在 $O(n^2)$ 时间内找到一个欧拉回路。最后，遍历此回路，通过跳过任何已访问的顶点（走捷径）来生成哈密顿回路。计算并返回此最终路径的总长度。\n\n**2. 精确 TSP (Held-Karp 算法)**\nHeld-Karp 算法使用动态规划来找到最优 TSP 路径长度。\n- **DP 状态**：状态定义为 `dp[mask][i]`，表示从一个固定顶点（例如，顶点 0）出发，访问位掩码 `mask` 所代表的顶点子集，并结束于顶点 `i` 的最短路径长度。\n- **递推关系**：通过迭代大小递增的子集来填充 DP 表。对于一个子集 `S`（由 `mask` 表示）和 `S` 中的一个顶点 `j`，其值计算如下：\n  $$ \\text{dp}[\\text{mask}][j] = \\min_{k \\in S \\setminus \\{j\\}} \\left( \\text{dp}[\\text{mask} \\setminus \\{j\\}][k] + d(k, j) \\right) $$\n- **基本情况**：基本情况是 `dp[{0}][0] = 0`。\n- **最终结果**：在为所有大小至 $n$ 的子集计算 DP 表之后，通过考虑所有访问了每个顶点并结束于某个顶点 $j \\neq 0$ 的路径，然后加上从 $j$ 回到起始顶点 $0$ 的边，来找到最优路径长度：\n  $$ \\text{OPT} = \\min_{j \\in \\{1, \\dots, n-1\\}} \\left( \\text{dp}[\\{0, \\dots, n-1\\}][j] + d(j, 0) \\right) $$\n整体复杂度为 $O(n^2 2^n)$。\n\n**最终计算**\n对于 12 个测试用例中的每一个（实例， $p$ 值对），计算来自 Christofides 算法 ($\\text{Christofides}_p$) 和 Held-Karp 算法 ($\\text{OPT}_p$) 的长度。计算比率 $\\rho(p) = \\text{Christofides}_p / \\text{OPT}_p$，四舍五入到六位小数，并存储。最终输出是这 12 个比率的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to solve the TSP approximation problem.\n    It orchestrates the validation, computation, and formatting of the final answer.\n    \"\"\"\n\n    test_cases = [\n        # Instance 1\n        (np.array([(0,0),(4,0),(4,1),(0,1),(2,0),(2,1)]), 1),\n        (np.array([(0,0),(4,0),(4,1),(0,1),(2,0),(2,1)]), 2),\n        (np.array([(0,0),(4,0),(4,1),(0,1),(2,0),(2,1)]), 10),\n        (np.array([(0,0),(4,0),(4,1),(0,1),(2,0),(2,1)]), float('inf')),\n        # Instance 2\n        (np.array([(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(9,0)]), 1),\n        (np.array([(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(9,0)]), 2),\n        (np.array([(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(9,0)]), 10),\n        (np.array([(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(9,0)]), float('inf')),\n        # Instance 3\n        (np.array([(0,0),(5,0),(5,5),(0,5),(2,1),(3,1),(2,4),(3,4)]), 1),\n        (np.array([(0,0),(5,0),(5,5),(0,5),(2,1),(3,1),(2,4),(3,4)]), 2),\n        (np.array([(0,0),(5,0),(5,5),(0,5),(2,1),(3,1),(2,4),(3,4)]), 10),\n        (np.array([(0,0),(5,0),(5,5),(0,5),(2,1),(3,1),(2,4),(3,4)]), float('inf')),\n    ]\n\n    results = []\n    for points, p_val in test_cases:\n        n = len(points)\n        dist_matrix = np.zeros((n, n))\n        for i in range(n):\n            for j in range(i, n):\n                if p_val == float('inf'):\n                    dist = np.max(np.abs(points[i] - points[j]))\n                else:\n                    dist = np.power(np.sum(np.power(np.abs(points[i] - points[j]), p_val)), 1/p_val)\n                dist_matrix[i, j] = dist_matrix[j, i] = dist\n\n        christofides_len = _compute_christofides(dist_matrix)\n        optimal_len = _compute_held_karp(dist_matrix)\n        \n        ratio = christofides_len / optimal_len if optimal_len != 0 else 1.0\n        results.append(f\"{ratio:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef _compute_christofides(dist_matrix):\n    \"\"\"Computes the length of a TSP tour using Christofides' algorithm.\"\"\"\n    n = dist_matrix.shape[0]\n    if n == 0:\n        return 0\n\n    # 1. Minimum Spanning Tree (Prim's algorithm)\n    mst_parent = [-1] * n\n    key = [float('inf')] * n\n    in_mst = [False] * n\n    key[0] = 0\n    \n    for _ in range(n):\n        min_key = float('inf')\n        u = -1\n        for v_idx in range(n):\n            if not in_mst[v_idx] and key[v_idx]  min_key:\n                min_key = key[v_idx]\n                u = v_idx\n        \n        if u == -1: continue # Should not happen in a connected graph\n        in_mst[u] = True\n        \n        for v in range(n):\n            if dist_matrix[u, v] > 0 and not in_mst[v] and dist_matrix[u, v]  key[v]:\n                key[v] = dist_matrix[u, v]\n                mst_parent[v] = u\n\n    mst_edges = []\n    for i in range(1, n):\n        mst_edges.append((mst_parent[i], i))\n\n    # 2. Find odd-degree vertices\n    degree = collections.defaultdict(int)\n    for u, v in mst_edges:\n        degree[u] += 1\n        degree[v] += 1\n    \n    odd_vertices = [i for i, deg in degree.items() if deg % 2 != 0]\n\n    # 3. Minimum Weight Perfect Matching on odd_vertices\n    memo_mwpm = {}\n    \n    def get_mwpm_edges(nodes_tuple):\n        if not nodes_tuple:\n            return []\n        if nodes_tuple in memo_mwpm:\n            return memo_mwpm[nodes_tuple]\n\n        p1 = nodes_tuple[0]\n        nodes_rest = nodes_tuple[1:]\n        \n        best_pairing = None\n        min_cost = float('inf')\n\n        for i in range(len(nodes_rest)):\n            p2 = nodes_rest[i]\n            remaining_nodes = tuple(sorted(nodes_rest[:i] + nodes_rest[i+1:]))\n            \n            sub_matching = get_mwpm_edges(remaining_nodes)\n            current_cost = dist_matrix[p1, p2] + sum(dist_matrix[u, v] for u, v in sub_matching)\n            \n            if current_cost  min_cost:\n                min_cost = current_cost\n                best_pairing = [(p1, p2)] + sub_matching\n        \n        memo_mwpm[nodes_tuple] = best_pairing\n        return best_pairing\n\n    matching_edges = []\n    if odd_vertices:\n        matching_edges = get_mwpm_edges(tuple(sorted(odd_vertices)))\n\n    # 4. Form Eulerian multigraph\n    adj = collections.defaultdict(list)\n    for u, v in mst_edges + matching_edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # 5. Find Eulerian path (Hierholzer's algorithm)\n    start_node = 0\n    stack = [start_node]\n    euler_path = []\n    while stack:\n        u = stack[-1]\n        if adj[u]:\n            v = adj[u].pop()\n            adj[v].remove(u)\n            stack.append(v)\n        else:\n            euler_path.append(stack.pop())\n    \n    euler_path.reverse()\n\n    # 6. Shortcut to create Hamiltonian cycle\n    visited = set()\n    final_tour = []\n    for node in euler_path:\n        if node not in visited:\n            final_tour.append(node)\n            visited.add(node)\n    \n    # Calculate tour length\n    tour_len = 0\n    for i in range(len(final_tour)):\n        u = final_tour[i]\n        v = final_tour[(i + 1) % len(final_tour)]\n        tour_len += dist_matrix[u, v]\n        \n    return tour_len\n\ndef _compute_held_karp(dist_matrix):\n    \"\"\"Computes the optimal TSP tour length using Held-Karp algorithm.\"\"\"\n    n = dist_matrix.shape[0]\n    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n\n    # dp[mask][i] = cost of path from 0 to i visiting nodes in mask\n    dp = np.full((1  n, n), float('inf'))\n    \n    # Base case: path from 0 to 0 has cost 0\n    dp[1, 0] = 0\n    \n    for mask in range(1, 1  n):\n        for j in range(n):\n            if (mask >> j)  1:  # if j is in the set\n                if mask == (1  j): # if j is the only one in the set\n                    if j == 0:\n                        continue # this is the base case\n                    else:\n                        # this path must start from 0\n                        dp[mask, j] = dist_matrix[0,j]\n                \n                prev_mask = mask ^ (1  j)\n                if prev_mask == 0:\n                    continue\n\n                # Find the minimum cost to reach j from a previous node k\n                min_val = float('inf')\n                for k in range(n):\n                    if (prev_mask >> k)  1: # if k is in the previous set\n                        if dp[prev_mask, k] != float('inf'):\n                            min_val = min(min_val, dp[prev_mask, k] + dist_matrix[k, j])\n                dp[mask,j] = min_val\n\n    # Final step: complete the tour by returning to the start node\n    final_mask = (1  n) - 1\n    min_tour_len = float('inf')\n    \n    for j in range(1, n):\n        if dp[final_mask, j] != float('inf'):\n            min_tour_len = min(min_tour_len, dp[final_mask, j] + dist_matrix[j, 0])\n            \n    return min_tour_len if min_tour_len != float('inf') else 0\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3280045"}, {"introduction": "Christofides 算法的理论保证依赖于一个关键且计算成本较高的步骤：在奇度顶点集上找到一个最小权完美匹配。在实践中，我们有时会用更简单的启发式方法来替代它。本练习将探索这种权衡，要求你用一种快速的贪心策略来代替完美匹配，并与原始算法进行比较，从而亲手分析算法效率和解的质量之间的得失。[@problem_id:3280073]", "problem": "给定度量环境下的旅行商问题（TSP）：对于一个有限点集，任意两点之间的距离满足三角不等式。请考虑以下基于最小生成树（MST）及MST中奇度数顶点集的近似回路构建方案。该方案在奇度数顶点集上的匹配步骤有两种变体：（i）最小代价完美匹配（精确最优匹配）和（ii）贪婪匹配（迭代选择当前可用的、不会产生冲突的最短边，直到所有顶点都配对）。计算出匹配后，用匹配的边扩充MST以获得一个欧拉多重图，找到一条欧拉回路，然后通过“走捷径”的方式跳过重复顶点以获得哈密顿回路，其长度在给定的度量下进行测量。\n\n需要使用的基本定义：\n- 度量旅行商问题（metric TSP）定义在一个完整的加权图上，其顶点集为 $V$，权重函数为 $d: V \\times V \\to \\mathbb{R}_{\\ge 0}$，满足对于所有 $u,v \\in V$，$d(u,v) = d(v,u)$，$d(u,u) = 0$，并且对于所有 $u,v,w \\in V$，三角不等式 $d(u,v) \\le d(u,w) + d(w,v)$ 成立。\n- 一个加权无向图的最小生成树（MST）是一棵使边权重之和最小化的生成树。\n- 在任何树中，奇度数顶点的数量为偶数。设 $O \\subseteq V$ 表示MST中奇度数顶点的集合。\n- 集合 $O$ 上的完美匹配是一组不相交的配对，它恰好覆盖 $O$ 中的所有顶点一次。最小代价完美匹配使匹配对的权重之和最小化。\n- 欧拉多重图是一个无向多重图，其中每个顶点的度数均为偶数；这样的图允许存在一条访问每条边恰好一次的闭合路径（欧拉回路）。\n- 在度量环境下对欧拉回路进行“走捷径”操作，意味着按照顶点在回路中首次出现的顺序访问它们，并跳过重复的访问；三角不等式保证了走捷径不会增加总长度。\n\n您的任务是根据这些定义实现以下内容：\n1. 在由给定平面点集导出的完全图上，使用欧几里得距离 $d((x_1,y_1),(x_2,y_2)) = \\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}$ 构建MST。\n2. 从MST中识别出奇度数顶点集 $O$。\n3. 在 $O$ 上实现两种匹配过程：\n   - 最小代价完美匹配（精确），通过基于子集的、有原则的动态规划计算。\n   - 贪婪匹配，通过将 $O$ 中所有可能的配对按权重排序，并贪婪地添加不冲突的配对，直到所有顶点都被匹配。\n4. 用匹配的边扩充MST以获得欧拉多重图，构建欧拉回路，并通过走捷径得到哈密顿回路。\n5. 对给定的小型实例，通过暴力破解法精确计算最优TSP回路的长度。\n\n您必须从第一性原理出发，推导两种方案，并计算每个实例得到的回路长度。您还必须量化贪婪匹配相对于最小代价匹配和最优TSP回路对最终回路质量的影响。\n\n测试套件规范：\n- 每个测试实例都包含一个明确的平面点 $(x_i,y_i)$ 列表，使用欧几里得距离；此处不考虑角度（如果需要的话），距离是根据坐标计算的无单位实数，不需要任何物理单位。\n- 对于每个实例，您必须计算并返回两个浮点数：\n  - $r_{g/o}$，基于贪婪匹配的回路长度与最优TSP回路长度的比率。\n  - $r_{g/m}$，基于贪婪匹配的回路长度与基于最小代价匹配的回路长度的比率。\n\n提供一个覆盖不同方面的测试套件：\n- 实例 A（一般位置，理想情况）：$6$ 个点构成一个轻微扰动的六边形：$(0,0)$, $(1,0)$, $(1.5,0.866)$, $(0.5,1.3)$, $(-0.3,0.7)$, $(-0.2,-0.1)$。\n- 实例 B（边界情况，共线点）：$6$ 个点在一条直线上：$(0,0)$, $(1,0)$, $(2,0)$, $(3,0)$, $(4,0)$, $(5,0)$。\n- 实例 C（聚类结构）：$8$ 个点分为两簇：$(-2,-2)$, $(-2,2)$, $(-1,-1)$, $(-1,1)$, $(2,-2)$, $(2,2)$, $(1,-1)$, $(1,1)$。\n- 实例 D（构造的压力测试）：$8$ 个点被安排用来对贪婪匹配进行压力测试：$(0,0)$, $(2,0)$, $(0,3)$, $(2,3)$, $(6,0)$, $(6,3)$, $(3,1.5)$, $(9,1.5)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含 $[r_{g/o}^{A}, r_{g/m}^{A}, r_{g/o}^{B}, r_{g/m}^{B}, r_{g/o}^{C}, r_{g/m}^{C}, r_{g/o}^{D}, r_{g/m}^{D}]$，其中上标表示实例。所有值都必须打印为Python浮点数。", "solution": "用户提供了一个在度量旅行商问题（TSP）近似算法领域中定义明确的计算问题。该问题具有科学依据，逻辑一致，且所有术语和步骤都经过了形式化说明。任务是实现并比较一个类Christofides近似算法的两种变体，将它们相互比较，并与几个小型实例的最优TSP解进行比较。这两种变体的不同之处在于在最小生成树（MST）的奇度数顶点集上寻找完美匹配所使用的方法。\n\n解决方案通过从第一性原理出发，实现所有必需的算法组件来推进：\n1.  **距离矩阵**：一个辅助函数计算所有输入点对之间的欧几里得距离，形成一个代表完全图 $K_n$ 的对称矩阵。\n2.  **最优TSP回路 ($L_{opt}$)**：对于提供的小型实例（$n \\in \\{6, 8\\}$），通过暴力破解法计算最优回路长度。这涉及遍历所有可能的哈密顿回路，计算它们的长度，并找到最小值。此类回路的数量为 $(n-1)!/2$，对于小的 $n$ 来说，计算上是可行的。\n3.  **最小生成树 (MST)**：使用 Kruskal 算法来寻找图的MST。边按权重排序，并使用一个并查集（DSU）数据结构，通过添加连接先前不相连组件的边来构建树。\n4.  **奇度数顶点 ($O$)**：构建MST后，识别出度数为奇数的顶点集。任何图（因此也包括任何树）的一个基本性质是奇度数顶点的数量总是偶数。\n5.  **最小代价完美匹配 (MCM)**：问题指定在集合 $O$ 上计算一个精确的最小代价完美匹配。这是通过在 $O$ 的子集上使用动态规划来实现的。状态 $dp[S]$ 存储了匹配子集 $S \\subseteq O$ 中顶点的最小代价。通过选择一个任意顶点 $i \\in S$ 并将其与 $S$ 中的每个其他顶点 $j$ 配对，对边权重 $d(i,j)$ 和匹配剩余集合 $S \\setminus \\{i,j\\}$ 的代价之和进行最小化，来构建递推关系。\n6.  **贪婪匹配**：实现了第二种更简单的匹配启发式算法。生成 $O$ 中顶点对之间的所有可能的边，并按权重非降序排序。算法从这个排序列表中贪婪地选择边，如果 $u$ 和 $v$ 都尚未被匹配，则将边 $(u,v)$ 添加到匹配中，直到 $O$ 中的所有顶点都被覆盖。\n7.  **回路构建与走捷径**：对于两种匹配方案中的每一种，用相应的匹配边来扩充MST的边。这会创建一个欧拉多重图（所有顶点度数均为偶数）。使用 Hierholzer 算法找到一条遍历每条边恰好一次的欧拉回路。这条回路可能会多次访问顶点。最终的哈密顿回路（TSP回路）通过“走捷径”获得：按顶点在欧拉回路中首次出现的顺序遍历它们。对于欧几里得距离成立的三角不等式保证了走捷径过程不会增加总回路长度。\n8.  **比率计算**：计算由最小代价匹配（$L_{mcm}$）和贪婪匹配（$L_{greedy}$）生成的回路长度。对于每个测试实例，计算所需的比率 $r_{g/o} = L_{greedy} / L_{opt}$ 和 $r_{g/m} = L_{greedy} / L_{mcm}$。\n\n整个过程被封装在一个单一函数中，并应用于四个指定的测试实例中的每一个。最终输出是这些计算出的比率的列表。", "answer": "```python\nimport numpy as np\nimport itertools\nimport math\n\ndef solve():\n    # Per the problem specification, all logic is contained within this function.\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Instance A: General position, 6 points\n        [(0, 0), (1, 0), (1.5, 0.866), (0.5, 1.3), (-0.3, 0.7), (-0.2, -0.1)],\n        # Instance B: Collinear points, 6 points\n        [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0)],\n        # Instance C: Clustered structure, 8 points\n        [(-2, -2), (-2, 2), (-1, -1), (-1, 1), (2, -2), (2, 2), (1, -1), (1, 1)],\n        # Instance D: Constructed stress test, 8 points\n        [(0, 0), (2, 0), (0, 3), (2, 3), (6, 0), (6, 3), (3, 1.5), (9, 1.5)],\n    ]\n\n    # ========== HELPER CLASSES AND FUNCTIONS ==========\n\n    class DSU:\n        \"\"\"A Disjoint Set Union data structure for Kruskal's algorithm.\"\"\"\n        def __init__(self, n):\n            self.parent = list(range(n))\n        \n        def find(self, i):\n            if self.parent[i] == i:\n                return i\n            self.parent[i] = self.find(self.parent[i])\n            return self.parent[i]\n\n        def union(self, i, j):\n            root_i = self.find(i)\n            root_j = self.find(j)\n            if root_i != root_j:\n                self.parent[root_j] = root_i\n                return True\n            return False\n\n    def compute_distance_matrix(points):\n        \"\"\"Computes the Euclidean distance matrix for a set of points.\"\"\"\n        n = len(points)\n        dist_matrix = np.zeros((n, n), dtype=float)\n        for i in range(n):\n            for j in range(i, n):\n                dist = math.sqrt((points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2)\n                dist_matrix[i, j] = dist_matrix[j, i] = dist\n        return dist_matrix\n\n    def solve_tsp_optimal(dist_matrix):\n        \"\"\"Computes the optimal TSP tour length by brute force.\"\"\"\n        n = dist_matrix.shape[0]\n        if n = 1:\n            return 0.0\n        \n        min_len = float('inf')\n        nodes = list(range(1, n)) # Exclude starting node 0\n\n        for p in itertools.permutations(nodes):\n            current_len = dist_matrix[0, p[0]]\n            for i in range(len(p) - 1):\n                current_len += dist_matrix[p[i], p[i+1]]\n            current_len += dist_matrix[p[-1], 0]\n            if current_len  min_len:\n                min_len = current_len\n        return min_len\n\n    def compute_mst(dist_matrix):\n        \"\"\"Computes an MST using Kruskal's algorithm.\"\"\"\n        n = dist_matrix.shape[0]\n        edges = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                edges.append((dist_matrix[i, j], i, j))\n        edges.sort()\n        \n        dsu = DSU(n)\n        mst_edges = []\n        for weight, u, v in edges:\n            if dsu.union(u, v):\n                mst_edges.append((u, v))\n                if len(mst_edges) == n - 1:\n                    break\n        return mst_edges\n\n    def find_odd_degree_vertices(mst_edges, n):\n        \"\"\"Finds vertices with odd degree in the MST.\"\"\"\n        degrees = [0] * n\n        for u, v in mst_edges:\n            degrees[u] += 1\n            degrees[v] += 1\n        return [i for i, deg in enumerate(degrees) if deg % 2 != 0]\n\n    def solve_mcm_dp(odd_vertices, dist_matrix):\n        \"\"\"Computes the Minimum-Cost Perfect Matching using dynamic programming.\"\"\"\n        k = len(odd_vertices)\n        if k == 0:\n            return [], 0.0\n\n        memo = {}\n        def dp(mask):\n            if mask == 0:\n                return 0.0, []\n            if mask in memo:\n                return memo[mask]\n\n            min_cost = float('inf')\n            best_edges = []\n            \n            p1_local = (mask  -mask).bit_length() - 1\n            \n            for p2_local in range(p1_local + 1, k):\n                if (mask >> p2_local)  1:\n                    p1_global = odd_vertices[p1_local]\n                    p2_global = odd_vertices[p2_local]\n                    cost = dist_matrix[p1_global, p2_global]\n                    new_mask = mask ^ (1  p1_local) ^ (1  p2_local)\n                    sub_cost, sub_edges = dp(new_mask)\n                    \n                    if cost + sub_cost  min_cost:\n                        min_cost = cost + sub_cost\n                        best_edges = sub_edges + [(p1_global, p2_global)]\n\n            memo[mask] = (min_cost, best_edges)\n            return min_cost, best_edges\n\n        total_cost, edges = dp((1  k) - 1)\n        return edges, total_cost\n\n    def solve_greedy_matching(odd_vertices, dist_matrix):\n        \"\"\"Computes a perfect matching on odd vertices using a greedy approach.\"\"\"\n        if not odd_vertices:\n            return [], 0.0\n        \n        pairs = list(itertools.combinations(odd_vertices, 2))\n        sorted_pairs = sorted(pairs, key=lambda p: dist_matrix[p[0], p[1]])\n        \n        matched, matching_edges = set(), []\n        for u, v in sorted_pairs:\n            if u not in matched and v not in matched:\n                matching_edges.append((u, v))\n                matched.update([u, v])\n            if len(matched) == len(odd_vertices):\n                break\n        return matching_edges\n\n    def build_and_shortcut_tour(mst_edges, matching_edges, n, dist_matrix):\n        \"\"\"Builds an Eulerian multigraph, finds a tour, shortcuts, and returns its length.\"\"\"\n        adj = [[] for _ in range(n)]\n        for u, v in mst_edges:\n            adj[u].append(v)\n            adj[v].append(u)\n        for u, v in matching_edges:\n            adj[u].append(v)\n            adj[v].append(u)\n\n        if not any(adj): return 0.0\n            \n        start_node = next((i for i, sublist in enumerate(adj) if sublist), 0)\n        \n        euler_path = []\n        # Non-recursive Hierholzer\n        stack = [start_node]\n        path_rev = []\n        while stack:\n            u = stack[-1]\n            if adj[u]:\n                v = adj[u].pop()\n                adj[v].remove(u)\n                stack.append(v)\n            else:\n                path_rev.append(stack.pop())\n        euler_path = path_rev[::-1]\n        \n        if not euler_path: return 0.0\n\n        path, visited = [], set()\n        for node in euler_path:\n            if node not in visited:\n                path.append(node)\n                visited.add(node)\n        \n        if len(path) = 1: return 0.0\n        tour_len = sum(dist_matrix[path[i], path[i+1]] for i in range(len(path) - 1))\n        tour_len += dist_matrix[path[-1], path[0]]\n        return tour_len\n\n    # ========== MAIN PROCESSING LOGIC ==========\n\n    final_results = []\n    for points in test_cases:\n        n = len(points)\n        dist_matrix = compute_distance_matrix(points)\n        \n        l_opt = solve_tsp_optimal(dist_matrix)\n        mst_edges = compute_mst(dist_matrix)\n        odd_vertices = find_odd_degree_vertices(mst_edges, n)\n        \n        mcm_edges, _ = solve_mcm_dp(odd_vertices, dist_matrix)\n        greedy_edges = solve_greedy_matching(odd_vertices, dist_matrix)\n        \n        l_mcm = build_and_shortcut_tour(list(mst_edges), mcm_edges, n, dist_matrix)\n        l_greedy = build_and_shortcut_tour(list(mst_edges), greedy_edges, n, dist_matrix)\n        \n        r_g_o = l_greedy / l_opt if l_opt > 0 else 1.0\n        r_g_m = l_greedy / l_mcm if l_mcm > 0 else 1.0\n        \n        final_results.extend([r_g_o, r_g_m])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "3280073"}]}