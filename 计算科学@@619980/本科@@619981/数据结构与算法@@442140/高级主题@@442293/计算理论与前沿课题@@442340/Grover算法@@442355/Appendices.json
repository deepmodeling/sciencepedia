{"hands_on_practices": [{"introduction": "Grover 算法的核心在于一个被称为“神谕”（Oracle）的黑箱操作，其作用是识别并“标记”我们正在寻找的目标。这个练习将带你深入探索神谕的构建方式，理解它如何通过翻转量子态的相位来标记目标，这是整个算法能够放大目标概率的根本机制。通过分析不同的数学和门电路表示，你将掌握构建 Grover 算法第一个关键模块的知识 [@problem_id:1426367]。", "problem": "在量子计算理论中，Grover 算法为搜索无结构数据库提供了显著的加速。该算法的一个关键组成部分是一个称为神谕（oracle）的“黑箱”算子 $U_f$，它能识别出我们想要的目标项。\n\n考虑一个 3 量子比特的量子寄存器。该系统的状态可以描述为一个 8 维复希尔伯特空间中的向量，该空间由计算基矢 $\\{|000\\rangle, |001\\rangle, |010\\rangle, |011\\rangle, |100\\rangle, |101\\rangle, |110\\rangle, |111\\rangle\\}$ 张成，并按其二进制到整数的值排序。\n\n神谕算子 $U_f$ 作用于基矢 $|x\\rangle$ 的规则为 $U_f|x\\rangle = (-1)^{f(x)}|x\\rangle$，其中 $f(x)$ 是一个布尔函数，当 $|x\\rangle$ 是我们寻找的标记态时 $f(x)=1$，否则 $f(x)=0$。\n\n对于本问题，我们寻找一个单一的标记项，即状态 $|\\omega\\rangle = |101\\rangle$。\n\n以下哪个表达式正确地表示了针对此特定搜索问题的神谕算子 $U_f$？选择所有适用项。\n\n在以下选项中：\n- $I$ 表示 $8 \\times 8$ 单位矩阵。\n- $X_k$ 表示作用在第 $k$ 个量子比特上的泡利-X 算子，其中量子比特从左到右索引为 0, 1, 2。例如，$X_1$ 是算子 $I_0 \\otimes X_1 \\otimes I_2$ 的简写。\n- $Z_k$ 表示作用在第 $k$ 个量子比特上的泡利-Z 算子。\n- $CCZ$ 表示受控-受控-Z 门，它会翻转基矢 $|111\\rangle$ 的符号，而保持所有其他计算基矢不变。\n\nA. $I - 2 |101\\rangle\\langle 101|$\n\nB. $I - |101\\rangle\\langle 101|$\n\nC. $Z_0 \\otimes Z_2$\n\nD. $X_1 \\cdot CCZ \\cdot X_1$\n\nE. $8 \\times 8$ 对角矩阵 `diag(1, 1, 1, 1, 1, -1, 1, 1)`", "solution": "对于单一标记态 $|\\omega\\rangle=|101\\rangle$ 的神谕定义为 $U_{f}|x\\rangle=(-1)^{f(x)}|x\\rangle$，其中当且仅当 $|x\\rangle=|101\\rangle$ 时 $f(x)=1$，否则 $f(x)=0$。因此，$U_{f}$ 会翻转 $|101\\rangle$ 的符号，并保持所有其他计算基矢不变。\n\n选项 A：考虑算子 $U=I-2|101\\rangle\\langle 101|$。对于任何状态 $|\\psi\\rangle=\\alpha|101\\rangle+|\\psi_{\\perp}\\rangle$ 且 $\\langle 101|\\psi_{\\perp}\\rangle=0$，我们有\n$$\nU|\\psi\\rangle=(I-2|101\\rangle\\langle 101|)(\\alpha|101\\rangle+|\\psi_{\\perp}\\rangle)=\\alpha|101\\rangle-2\\alpha|101\\rangle+|\\psi_{\\perp}\\rangle=-\\alpha|101\\rangle+|\\psi_{\\perp}\\rangle.\n$$\n因此，$U|101\\rangle=-|101\\rangle$ 且对于所有 $|x\\rangle\\neq|101\\rangle$ 有 $U|x\\rangle=|x\\rangle$，这与所需的作用相符。因此 A 是正确的。\n\n选项 B：考虑 $U=I-|101\\rangle\\langle 101|$。作用于 $|101\\rangle$ 得到\n$$\nU|101\\rangle=(I-|101\\rangle\\langle 101|)|101\\rangle=|101\\rangle-|101\\rangle=0,\n$$\n这不是幺正的，也没有实现相位翻转。因此 B 是不正确的。\n\n选项 C：算子 $Z_{0}\\otimes Z_{2}$ 作用于基矢 $|q_{0}q_{1}q_{2}\\rangle$ 时，会附加一个相位 $(-1)^{q_{0}}(-1)^{q_{2}}=(-1)^{q_{0}+q_{2}}$。作用于 $|101\\rangle$ 上得到 $(-1)^{1+1}=(-1)^{2}=1$，所以 $|101\\rangle$ 的相位没有被翻转，而 $q_{0}\\neq q_{2}$ 的态的相位被翻转了。这与神谕的作用不符。因此 C 是不正确的。\n\n选项 D：令 $U=X_{1}\\cdot CCZ\\cdot X_{1}$。$CCZ$ 门仅对 $|111\\rangle$ 施加一个 $-1$ 的相位。通过 $X_{1}$ 进行的变换在 $CCZ$ 门之前将 $|q_{0}q_{1}q_{2}\\rangle$ 映射到 $|q_{0},q_{1}\\oplus 1,q_{2}\\rangle$，因此，当且仅当 $q_{0}=1$，$q_{1}\\oplus 1=1$ 和 $q_{2}=1$ 时，即当 $(q_{0},q_{1},q_{2})=(1,0,1)$ 时，会施加一个 $-1$ 的相位。最后的 $X_{1}$ 操作恢复了中间的量子比特。因此，$U$ 翻转了 $|101\\rangle$ 的符号，并保持所有其他计算基矢不变。因此 D 是正确的。\n\n选项 E：当计算基矢按 $|000\\rangle,|001\\rangle,|010\\rangle,|011\\rangle,|100\\rangle,|101\\rangle,|110\\rangle,|111\\rangle$ 的顺序排列时，对角矩阵\n$$\n\\mathrm{diag}(1,1,1,1,1,-1,1,1)\n$$\n仅对 $|101\\rangle$ 施加 $-1$，对所有其他基矢施加 $+1$，这与神谕的作用完全匹配。因此 E 是正确的。\n\n由于 $I-2|101\\rangle\\langle 101|$ 的作用是仅翻转 $|101\\rangle$ 符号的反射，给定的对角矩阵施加了相应的相位模式，并且 $X_{1}\\cdot CCZ\\cdot X_{1}$ 通过变换实现了相同的相位翻转，因此正确的选项是 A、D 和 E。", "answer": "$$\\boxed{ADE}$$", "id": "1426367"}, {"introduction": "Grover 算法并非一步到位的过程，而是一个迭代优化的过程。每一次迭代（Grover iteration）都会放大找到正确答案的概率，但过多的迭代反而会使概率下降，如同“过犹不及”。这个练习将教你如何计算最佳的迭代次数 $k$，以最大限度地提高搜索成功率，这是将 Grover 算法付诸实践的一项关键技能 [@problem_id:1426405]。", "problem": "一个网络安全团队正在使用一台量子计算机来搜索一个密码系统中的漏洞。总搜索空间包含 $N = 2^{10}$ 种可能的配置。由于一个设计缺陷，已知这些配置中恰好有 $M=4$ 个是“弱”配置，如果找到它们，将会危及系统的安全。该团队采用 Grover 搜索算法来寻找这些弱配置中的一个。\n\n在 Grover 算法中，一系列量子操作（统称为“Grover 迭代”）被重复地应用于一个量子态。在一定数量的迭代之后，会进行一次测量。测量到弱配置的概率取决于所执行的迭代次数。\n\n确定该团队应该执行的 Grover 迭代的最佳次数 $k$，以便在测量时有最高的概率识别出弱配置。迭代次数必须是整数。", "solution": "设 $N$ 为项目总数，$M$ 为标记（弱）项目的数量。在 Grover 算法中，角度 $\\theta$ 由以下公式定义\n$$\n\\sin(\\theta)=\\sqrt{\\frac{M}{N}}.\n$$\n经过 $k$ 次 Grover 迭代后，成功概率为\n$$\nP(k)=\\sin^{2}\\big((2k+1)\\theta\\big).\n$$\n当 $(2k+1)\\theta$ 尽可能接近 $\\frac{\\pi}{2}$ 时，该概率达到最大值，这给出了最佳迭代次数\n$$\nk^{\\ast}=\\left\\lfloor \\frac{\\pi}{4\\theta}-\\frac{1}{2}\\right\\rfloor.\n$$\n对于给定的值 $N=2^{10}$ 和 $M=4$，\n$$\n\\sqrt{\\frac{M}{N}}=\\sqrt{\\frac{4}{2^{10}}}=\\sqrt{\\frac{1}{256}}=\\frac{1}{16},\n$$\n所以\n$$\n\\theta=\\arcsin\\!\\left(\\frac{1}{16}\\right).\n$$\n因此，\n$$\nk^{\\ast}=\\left\\lfloor \\frac{\\pi}{4\\arcsin\\!\\left(\\frac{1}{16}\\right)}-\\frac{1}{2}\\right\\rfloor.\n$$\n为了选择正确的整数，进行近似计算。使用 $\\arcsin(x)$ 在 $x=\\frac{1}{16}$ 处的级数展开，\n$$\n\\arcsin(x)=x+\\frac{x^{3}}{6}+\\frac{3x^{5}}{40}+\\frac{5x^{7}}{112}+\\cdots,\n$$\n可得\n$$\n\\theta=\\arcsin\\!\\left(\\frac{1}{16}\\right)\\approx 0.062540761796,\n$$\n因此\n$$\n\\frac{\\pi}{4\\theta}\\approx \\frac{3.141592653589793}{4\\times 0.062540761796}\\approx 12.5581803,\n$$\n于是\n$$\n\\frac{\\pi}{4\\theta}-\\frac{1}{2}\\approx 12.0581803.\n$$\n取底函数（向下取整）得到 $k^{\\ast}=12$。同样地，使用常用近似公式 $k\\approx \\left\\lfloor \\frac{\\pi}{4}\\sqrt{\\frac{N}{M}} \\right\\rfloor$ 会得到 $\\left\\lfloor \\frac{\\pi}{4}\\cdot 16 \\right\\rfloor=\\left\\lfloor 4\\pi \\right\\rfloor=12$，这与更精确的计算结果一致。", "answer": "$$\\boxed{12}$$", "id": "1426405"}, {"introduction": "Grover 算法的威力不仅限于“寻找”一个目标。通过将其核心操作（Grover 算子）与量子相位估计算法相结合，我们可以解决一个更普遍的问题：数据库中到底有“多少”个目标？这项被称为“量子计数”（Quantum Counting）的技术展示了量子算法的强大组合能力。这个高级编程练习将引导你通过状态矢量模拟，亲手实现量子计数，从而深入理解 Grover 算子谱结构及其在更广泛应用中的价值 [@problem_id:3238073]。", "problem": "您的任务是通过在 Grover 算子上运行相位估计算法 (PEA) 来实现量子计数的态矢量模拟。目标是估计一个在 $N$ 个基态上的搜索问题中的解的数量 $M$。整个工作在由 $n$ 个搜索量子比特（其中 $N = 2^n$）和 $t$ 个计数量子比特组成的计算基中进行。所有角度必须以弧度表示。\n\n基本基础和定义：\n- 设神谕（oracle）为一个函数 $f : \\{0,1\\}^n \\to \\{0,1\\}$，其中如果 $x$ 是一个解，则 $f(x) = 1$，否则 $f(x) = 0$。相应的相位神谕酉算子 $O$ 在计算基上以对角方式作用：$O |x\\rangle = (-1)^{f(x)} |x\\rangle$。\n- 设 $|s\\rangle$ 表示 $N$ 个基态上的均匀叠加态，即 $|s\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x=0}^{N-1} |x\\rangle$。\n- 扩散算子为 $D = 2 |s\\rangle\\langle s| - I$，其中 $I$ 是 $N$ 维搜索希尔伯特空间上的单位算子。\n- Grover 算子为 $G = D O$。\n- 相位估计算法 (PEA) 的实现过程如下：将 $t$ 个计数量子比特制备到均匀叠加态，将 $n$ 个搜索量子比特制备到 $|s\\rangle$ 态，对于 $k \\in \\{0,1,\\dots,t-1\\}$，当计数量子比特 $k$ 为 $|1\\rangle$ 时，施加受控的 $G^{2^k}$ 次幂操作，然后对计数寄存器应用逆量子傅里叶变换 (IQFT)。\n- 作用于 $t$ 个量子比特的量子傅里叶变换 (QFT) 是一个酉算子，它将 $|j\\rangle$ 映射到 $\\frac{1}{\\sqrt{2^t}} \\sum_{k=0}^{2^t-1} e^{2 \\pi i j k / 2^t} |k\\rangle$。IQFT 是其共轭转置。\n\n要求：\n- 使用复数态矢量实现一个模拟器。不要使用随机性；在 IQFT 之后，通过选择具有最大概率的计数寄存器基索引来确定相位估计。如果出现概率相同的情况，选择最小的索引。利用从第一性原理推导出的 Grover 算子本征相位与标记比例之间的谱关系，将此相位估计映射到解的数量 $M$ 的估计值。所有角度都以弧度表示。将最终的 $M$ 估计值四舍五入到最近的整数，并将其限制在区间 $[0, N]$ 内，以确保科学真实性。\n- 搜索空间的基态由整数 $x \\in \\{0,1,\\dots,N-1\\}$ 标识，并解释为二进制形式的计算基 $|x\\rangle$。神谕由一组标记索引指定，即那些满足 $f(x)=1$ 的 $x$。\n\n您的程序必须：\n- 为每个测试用例构建 $O$、$D$ 和 $G$。\n- 使用受控的 $G^{2^k}$ 操作（其中 $k = 0,1,\\dots,t-1$）执行 PEA。\n- 对计数寄存器应用 IQFT。\n- 确定性地计算最可能的计数结果，并根据从 Grover 算子谱中推导出的理论将其映射到 $M$ 的估计值。\n\n测试套件：\n使用以下五个测试用例，每个用例由 $(n, t, \\text{标记索引})$ 指定：\n1. $(n = 3, t = 6, \\text{标记索引} = \\{0\\})$。\n2. $(n = 3, t = 6, \\text{标记索引} = \\{0, 1\\})$。\n3. $(n = 5, t = 8, \\text{标记索引} = \\{0, 1, 2, 3, 4\\})$。\n4. $(n = 3, t = 6, \\text{标记索引} = \\varnothing)$。\n5. $(n = 3, t = 6, \\text{标记索引} = \\{0, 1, 2, 3, 4, 5, 6, 7\\})$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含五个测试用例的 $M$ 的估计值，格式为用方括号括起来的逗号分隔列表。例如，如果估计值为 $m_1, m_2, m_3, m_4, m_5$，程序应准确打印出\n$[m_1,m_2,m_3,m_4,m_5]$。", "solution": "该问题要求对量子计数算法进行态矢量模拟，以估计在大小为 $N=2^n$ 的搜索空间中的解的数量 $M$。这是通过将相位估计算法 (PEA) 应用于 Grover 算子 $G$ 来实现的。该模拟将是确定性的，相位从具有最高概率的测量结果中估计得出。\n\n### 数学框架\n\n整个系统由一个 $t$ 量子比特的计数寄存器和一个 $n$ 量子比特的搜索寄存器组成。组合的希尔伯特空间是张量积 $\\mathcal{H} = \\mathcal{H}_{\\text{count}} \\otimes \\mathcal{H}_{\\text{search}}$，维度为 $2^t \\times 2^n$。\n\n**搜索空间上的算子 ($\\mathcal{H}_{\\text{search}}$)**\n\n搜索空间的维度为 $N=2^n$。核心算子是：\n1.  **相位神谕 ($O$)**：这个酉算子标记解状态。对于计算基态 $|x\\rangle$，其作用定义为 $O |x\\rangle = (-1)^{f(x)} |x\\rangle$，其中如果 $x$ 是一个解，则 $f(x)=1$，否则 $f(x)=0$。作为矩阵，$O$ 是对角的，其对角元为 $O_{xx} = (-1)^{f(x)}$。\n\n2.  **扩散算子 ($D$)**：该算子也称为 Grover 扩散算子，它执行关于均匀叠加态 $|s\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x=0}^{N-1} |x\\rangle$ 的反转操作。它定义为 $D = 2 |s\\rangle\\langle s| - I$，其中 $I$ 是 $N \\times N$ 的单位矩阵。\n\n3.  **Grover 算子 ($G$)**：这是量子计数或 Grover 迭代算子，由乘积 $G = D O$ 给出。\n\n**Grover 算子的谱**\n\n要估计与 $G$ 相关的相位，我们必须理解其谱特性。$G$ 的作用局限于一个二维子空间，该子空间由“获胜”（标记）态的均匀叠加 $|w\\rangle = \\frac{1}{\\sqrt{M}} \\sum_{x:f(x)=1} |x\\rangle$ 和“失败”（未标记）态的均匀叠加 $|u\\rangle = \\frac{1}{\\sqrt{N-M}} \\sum_{x:f(x)=0} |x\\rangle$ 张成。我们假设 $0  M  N$。\n\n搜索寄存器的初始态 $|s\\rangle$ 可以在此基中表示：\n$$\n|s\\rangle = \\sqrt{\\frac{N-M}{N}}|u\\rangle + \\sqrt{\\frac{M}{N}}|w\\rangle\n$$\n让我们定义一个角度 $\\alpha$ 使得 $\\sin(\\alpha) = \\sqrt{M/N}$ 并且 $\\cos(\\alpha) = \\sqrt{(N-M)/N}$。那么，$|s\\rangle = \\cos(\\alpha)|u\\rangle + \\sin(\\alpha)|w\\rangle$。\n\n算子 $O$ 和 $D$ 在这个 $\\{|u\\rangle, |w\\rangle\\}$ 子空间内作用。神谕 $O$ 翻转 $|w\\rangle$ 的相位：$O|u\\rangle = |u\\rangle$ 且 $O|w\\rangle = -|w\\rangle$。扩散算子 $D$ 是关于态 $|s\\rangle$ 的反射。在此基中，$G=DO$ 的矩阵是一个旋转：\n$$\nG = \\begin{pmatrix} \\cos(2\\alpha)  -\\sin(2\\alpha) \\\\ \\sin(2\\alpha)  \\cos(2\\alpha) \\end{pmatrix}\n$$\n这个旋转的角度为 $\\theta = 2\\alpha$。$G$ 的本征值为 $e^{\\pm i\\theta}$。根据我们对 $\\alpha$ 的定义，我们得到了相位 $\\theta$ 与解的数量 $M$ 之间的关键关系：\n$$\n\\sin(\\theta/2) = \\sin(\\alpha) = \\sqrt{M/N}\n$$\n相位估计算法就是为了估计这个相位 $\\theta$。\n\n### 算法模拟步骤\n\n1.  **状态初始化**：模拟开始时，整个系统处于状态 $|\\Psi_0\\rangle$。$t$ 个计数量子比特被制备在均匀叠加态，而 $n$ 个搜索量子比特被制备在态 $|s\\rangle$ 中：\n    $$\n    |\\Psi_0\\rangle = \\left( \\frac{1}{\\sqrt{2^t}} \\sum_{j=0}^{2^t-1} |j\\rangle \\right) \\otimes |s\\rangle\n    $$\n    在模拟中，这对应于一个大小为 $2^{t+n}$ 的态矢量。\n\n2.  **受控 Grover 迭代**：PEA 的核心是应用一系列受控酉运算。对于每个计数量子比特 $k \\in \\{0, 1, \\dots, t-1\\}$，操作 $G^{2^k}$ 会在量子比特 $k$ 的状态为 $|1\\rangle$ 的条件下应用于搜索寄存器。这些操作的累积效应将状态转换为：\n    $$\n    |\\Psi_1\\rangle = \\frac{1}{\\sqrt{2^t}} \\sum_{j=0}^{2^t-1} |j\\rangle \\otimes G^j |s\\rangle\n    $$\n    其中 $j$ 是由计数寄存器的基态表示的整数。\n\n3.  **逆量子傅里叶变换 (IQFT)**：IQFT 被应用于计数寄存器。作用于 $t$ 个量子比特的 IQFT 算子通过其对基态 $|k\\rangle$ 的作用来定义：\n    $$\n    \\text{IQFT} |k\\rangle = \\frac{1}{\\sqrt{2^t}} \\sum_{j=0}^{2^t-1} e^{-2\\pi i j k / 2^t} |j\\rangle\n    $$\n    将 $\\text{IQFT} \\otimes I_N$ 应用于 $|\\Psi_1\\rangle$ 得到最终状态 $|\\Psi_f\\rangle$。由于初始搜索态 $|s\\rangle$ 是 $G$ 的两个本征向量 $|\\psi_{\\pm}\\rangle$ 的叠加，计数寄存器的最终状态将是两个态的叠加，这两个态在估计相位 $\\theta$ 和 $2\\pi - \\theta$ 的值附近出现尖锐的峰值。\n\n### 相位和解的估计\n\n1.  **测量模拟**：我们确定性地找到具有最大概率的计数寄存器基态。测量结果为 $m \\in \\{0, 1, \\dots, 2^t-1\\}$ 的概率由最终状态 $|\\Psi_f\\rangle$ 中相应子矢量的范数平方给出。我们找到 $j_{\\text{max}} = \\arg\\max_m P(m)$，并通过选择最小的索引 $m$ 来打破平局。\n\n2.  **相位估计**：结果 $j_{\\text{max}}$ 提供了相位的估计。一个测量值 $j$ 对应于 $2\\pi j / 2^t$ 的相位估计。由于存在两个本征值 $e^{\\pm i\\theta}$，我们预期概率峰值会出现在 $j_1 \\approx \\theta \\frac{2^t}{2\\pi}$ 和 $j_2 \\approx (2\\pi - \\theta) \\frac{2^t}{2\\pi} = 2^t - j_1$ 附近。为了唯一确定角度 $\\theta \\in [0, \\pi]$，我们选择两个可能的相位角中较小的一个。这对应于一个有效索引 $j_{\\text{best}} = \\min(j_{\\text{max}}, 2^t - j_{\\text{max}})$。相位 $\\theta$ 随后被估计为：\n    $$\n    \\hat{\\theta} = \\frac{2 \\pi j_{\\text{best}}}{2^t}\n    $$\n\n3.  **解数量估计**：利用推导出的谱关系，我们将其反转以估计 $M$：\n    $$\n    \\hat{M} = N \\sin^2(\\hat{\\theta}/2) = N \\sin^2\\left(\\frac{\\pi j_{\\text{best}}}{2^t}\\right)\n    $$\n    最终值通过将 $\\hat{M}$ 四舍五入到最近的整数，并将结果限制在有效范围 $[0, N]$ 内获得。对于 $M=0$ 或 $M=N$ 的边缘情况，相位分别为 $\\theta=0$ 或 $\\theta=\\pi$，算法能正确地得出 $\\hat{M}=0$ 或 $\\hat{M}=N$。", "answer": "```python\nimport numpy as np\nfrom typing import Set\n\ndef run_quantum_counting(n: int, t: int, marked_indices: Set[int]) -> int:\n    \"\"\"\n    Simulates the Quantum Counting algorithm using state vector evolution.\n\n    Args:\n        n: The number of qubits in the search register.\n        t: The number of qubits in the counting register.\n        marked_indices: A set of integers representing the marked basis states.\n\n    Returns:\n        The estimated number of solutions, M, as an integer.\n    \"\"\"\n    N = 1  n\n    T = 1  t\n    M = len(marked_indices)\n\n    # Handle trivial edge cases directly for efficiency and correctness.\n    if M == 0:\n        return 0\n    if M == N:\n        return N\n\n    # 1. Construct operators on the N-dimensional search space\n    # Phase Oracle 'O' flips the phase of marked states.\n    O = np.identity(N, dtype=np.complex128)\n    if M > 0:\n        marked_list = list(marked_indices)\n        O[marked_list, marked_list] = -1.0\n\n    # Diffuser 'D' reflects about the uniform superposition state |s>.\n    s_ket = np.ones((N, 1), dtype=np.complex128) / np.sqrt(N)\n    D = 2 * (s_ket @ s_ket.T.conj()) - np.identity(N, dtype=np.complex128)\n\n    # Grover operator 'G' is one iteration.\n    G = D @ O\n\n    # 2. Initialize the full (t+n)-qubit state vector\n    # Counting register in uniform superposition.\n    count_initial = np.ones(T, dtype=np.complex128) / np.sqrt(T)\n    # Search register in uniform superposition.\n    search_initial = s_ket.flatten()\n    # Combine using Kronecker product.\n    psi = np.kron(count_initial, search_initial)\n\n    # 3. Apply controlled-G^(2^k) operations\n    psi_reshaped = psi.reshape(T, N)\n    for k in range(t):\n        G_pow = np.linalg.matrix_power(G, 1  k)\n        for j in range(T):\n            if (j >> k)  1:\n                psi_reshaped[j, :] = G_pow @ psi_reshaped[j, :]\n\n    # 4. Apply Inverse Quantum Fourier Transform (IQFT) on the counting register\n    # Construct the IQFT matrix for t qubits.\n    IQFT_mat = np.zeros((T, T), dtype=np.complex128)\n    omega = np.exp(-2j * np.pi / T)\n    for i in range(T):\n        for j in range(T):\n            IQFT_mat[i, j] = omega**(i * j)\n    IQFT_mat /= np.sqrt(T)\n    \n    # Apply IQFT to the counting register part of the state.\n    psi_reshaped = IQFT_mat @ psi_reshaped\n\n    # 5. Find the measurement outcome with the highest probability\n    # Probabilities are the squared norms of the state vectors for each count.\n    probabilities = np.sum(np.abs(psi_reshaped)**2, axis=1)\n    j_max = np.argmax(probabilities)\n\n    # 6. Estimate the phase theta and then the number of solutions M\n    # The two eigenvalues e^(i*theta) and e^(-i*theta) give peaks near j_max and T - j_max.\n    # We want the smaller angle theta in [0, pi], which corresponds to the smaller index.\n    if j_max > T / 2:\n        j_best = T - j_max\n    else:\n        j_best = j_max\n\n    # Estimate phase from the most likely measurement outcome.\n    theta_est = (2 * np.pi * j_best) / T\n    \n    # Use the spectral relation to find M: sin(theta/2) = sqrt(M/N)\n    # This gives M = N * sin^2(theta/2)\n    # Handle the case where theta_est is 0 to avoid precision issues if j_best is 0.\n    if np.isclose(theta_est, 0.0):\n        M_est = 0.0\n    else:\n        M_est = N * (np.sin(theta_est / 2)**2)\n\n    # 7. Round to the nearest integer and clip to the valid range [0, N].\n    M_final = int(np.round(M_est))\n    \n    return np.clip(M_final, 0, N)\n\ndef main():\n    \"\"\"\n    Runs the quantum counting simulation for the specified test suite\n    and prints the results in the required format.\n    \"\"\"\n    test_cases = [\n        (3, 6, {0}),\n        (3, 6, {0, 1}),\n        (5, 8, {0, 1, 2, 3, 4}),\n        (3, 6, set()),\n        (3, 6, {0, 1, 2, 3, 4, 5, 6, 7}),\n    ]\n\n    results = []\n    for n, t, marked_indices in test_cases:\n        m_est = run_quantum_counting(n, t, marked_indices)\n        results.append(m_est)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    main()\n```", "id": "3238073"}]}