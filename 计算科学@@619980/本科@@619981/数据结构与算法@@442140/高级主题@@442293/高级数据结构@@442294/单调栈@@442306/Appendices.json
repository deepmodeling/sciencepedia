{"hands_on_practices": [{"introduction": "理论学习之后，最好的巩固方式就是实践。这项练习是掌握单调栈的绝佳起点，因为它将两个核心模式——寻找下一个更大元素（NGE）和上一个更大元素（PGE）——结合在一个问题中。通过独立计算这两个值并最终将它们相乘，你将熟练掌握解决这类问题的标准双通道扫描技术。[@problem_id:3254179]", "problem": "你必须编写一个完整的程序，对于一个整数数组中的每个元素，计算其“下一个更大元素”和“前一个更大元素”的乘积，只能使用下面给出的定义以及数组、整数顺序和栈的基本性质。程序不读取任何输入；相反，程序必须在内部评估本说明中指定的一组固定的测试数组，并按要求生成一个单一的聚合输出。\n\n将用作基本依据的定义：\n- 设 $A$ 是一个长度为 $n$ 的整数数组。索引是基于 $0$ 的，即有效索引为 $0, 1, \\dots, n-1$。\n- 对于每个索引 $i$（$0 \\le i \\le n-1$），定义“下一个更大元素”$\\mathrm{NGE}(i)$ 如下。如果存在索引 $j$ 满足 $j  i$ 且 $A[j]  A[i]$，则令 $\\mathrm{NGE}(i) = A[j^{\\ast}]$，其中 $j^{\\ast}$ 是大于 $i$ 且满足 $A[j^{\\ast}]  A[i]$ 的最小索引。如果不存在这样的 $j$，则定义 $\\mathrm{NGE}(i) = -1$。\n- 对于每个索引 $i$（$0 \\le i \\le n-1$），定义“前一个更大元素”$\\mathrm{PGE}(i)$ 如下。如果存在索引 $k$ 满足 $k  i$ 且 $A[k]  A[i]$，则令 $\\mathrm{PGE}(i) = A[k^{\\ast}]$，其中 $k^{\\ast}$ 是小于 $i$ 且满足 $A[k^{\\ast}]  A[i]$ 的最大索引。如果不存在这样的 $k$，则定义 $\\mathrm{PGE}(i) = -1$。\n- 对于每个索引 $i$（$0 \\le i \\le n-1$），定义乘积 $P[i] = \\mathrm{NGE}(i) \\times \\mathrm{PGE}(i)$。\n\n你的任务是，对于每个给定的测试数组 $A$，计算包含这些乘积的长度为 $n$ 的列表 $P$，并按照从 $0$ 到 $n-1$ 的索引顺序排列。\n\n科学现实性和约束条件：\n- 数组可以包含任何整数（包括负值）、重复值，并且其长度可以为 $0$ 或更大。\n- 严格不等式 $$ 用于定义“更大”，因此相等的值不被视为更大。\n- 如果数组长度为 $0$，则该情况的输出为空列表。\n\n待程序评估的测试套件：\n- 案例 $1$：$A = [\\,5, 1, 3, 2, 4\\,]$。\n- 案例 $2$：$A = [\\,1, 2, 3, 4\\,]$。\n- 案例 $3$：$A = [\\,4, 3, 2, 1\\,]$。\n- 案例 $4$：$A = [\\,2, 2, 2\\,]$。\n- 案例 $5$：$A = [\\,7\\,]$。\n- 案例 $6$：$A = [\\,\\,]$ (空数组)。\n\n最终输出格式要求：\n- 你的程序应生成单行输出，该输出包含所有案例的结果，形式为一个单一列表，其中每个元素本身就是对应案例的列表 $P$，顺序与上述案例相同。\n- 该行必须是方括号括起来的逗号分隔列表，任何地方都不能有空格，包括内部列表。例如，如果有两个案例的结果分别为 $[\\,x_1, x_2\\,]$ 和 $[\\,y_1\\,]$，则输出格式应严格为 \"[[x_1,x_2],[y_1]]\"，其中每个 $x_1, x_2, y_1$ 都被替换为其整数值，并且完全没有空格。\n\n每个案例的答案是一个整数列表。程序对于所提供的测试套件必须是正确的，并且其设计应采用适合数据结构与算法高级本科课程的原则，例如利用顺序属性和栈的行为，而不是通过临时的枚举方法。", "solution": "问题陈述已经过验证，被认为是有效的。它是自洽的、数学上定义明确的，并且没有矛盾或歧义。“下一个更大元素”($\\mathrm{NGE}$) 和“前一个更大元素”($\\mathrm{PGE}$) 的定义是精确的，确保了对于任何给定的整数数组，都存在唯一的解。该问题是算法设计中的一个标准练习，适合用数据结构进行分析。\n\n下面提供一个完整的、附带推理的解决方案。\n\n问题要求我们对给定长度为 $n$ 的数组 $A$ 中的每个元素 $A[i]$，计算乘积 $P[i] = \\mathrm{NGE}(i) \\times \\mathrm{PGE}(i)$。“下一个更大元素” $\\mathrm{NGE}(i)$ 是在 $A[i]$ 右侧第一个严格大于 $A[i]$ 的元素。“前一个更大元素” $\\mathrm{PGE}(i)$ 是在 $A[i]$ 左侧第一个严格大于 $A[i]$ 的元素。如果不存在这样的元素，则相应的值定义为 $-1$。\n\n一个直接但效率低下的方法是为每个元素遍历数组。为了找到 $\\mathrm{NGE}(i)$，需要扫描所有 $j  i$ 的元素 $A[j]$。为了找到 $\\mathrm{PGE}(i)$，需要扫描所有 $k  i$ 的元素 $A[k]$。此方法涉及嵌套循环，对于长度为 $n$ 的数组，其时间复杂度为 $O(n^2)$。对于大型数组，这种方法的计算成本很高。问题暗示了一种更复杂的方法，使用单调栈可以实现线性时间 $O(n)$ 的解决方案。\n\n单调栈的原理是维护一个数据结构（一个栈），其中的元素始终保持特定的排序顺序（递增或递减）。这种结构允许在单次遍历中高效地确定所有元素的下一个或前一个更大/更小元素。\n\n整个算法包括三个主要步骤：\n1. 计算数组 $A$ 中每个元素的 $\\mathrm{NGE}$。\n2. 计算数组 $A$ 中每个元素的 $\\mathrm{PGE}$。\n3. 根据前两步的结果计算最终的乘积数组 $P$。\n\n**1. 计算下一个更大元素 ($\\mathrm{NGE}$)**\n\n为计算所有元素的 $\\mathrm{NGE}$，我们可以从右到左（从索引 $i = n-1$ 到 $0$）遍历数组 $A$，并使用一个栈来存储目前遇到的元素值。该栈将维持一个从栈底到栈顶严格递减的元素顺序。\n\n算法如下：\n- 初始化一个空栈 $s$ 和一个大小为 $n$ 的结果数组 $nge\\_arr$，所有值都初始化为 $-1$。\n- 对于从 $n-1$ 到 $0$ 的每个索引 $i$：\n    a. 当栈 $s$ 不为空且栈顶元素小于或等于 $A[i]$ 时（即 $s.\\mathrm{top}() \\le A[i]$），从栈中弹出元素。任何这样被弹出的元素，比如 $A[k]$（其中 $ki$），都不可能是 $A[i]$ 或 $A[i]$ 左侧任何元素的 $\\mathrm{NGE}$，因为 $A[i]$ 本身更近且更大。\n    b. 在 while 循环之后，如果栈不为空，其栈顶元素就是 $A[i]$ 右侧第一个大于 $A[i]$ 的元素。我们设置 $nge\\_arr[i] = s.\\mathrm{top}()$。\n    c. 如果栈为空，说明右侧没有找到更大的元素，因此 $nge\\_arr[i]$ 保持为 $-1$。\n    d. 将当前元素 $A[i]$ 推入栈中。此操作保持了栈的单调（严格递减）属性。\n\n$A$ 的每个元素最多被推入和弹出栈一次。因此，这次遍历的时间复杂度为 $O(n)$。\n\n**2. 计算前一个更大元素 ($\\mathrm{PGE}$)**\n\n计算 $\\mathrm{PGE}$ 的逻辑与计算 $\\mathrm{NGE}$ 的逻辑是对称的。我们从左到右（从索引 $i = 0$ 到 $n-1$）遍历数组 $A$，并使用类似的单调栈。\n\n算法如下：\n- 初始化一个空栈 $s$ 和一个大小为 $n$ 的结果数组 $pge\\_arr$，所有值都初始化为 $-1$。\n- 对于从 $0$ 到 $n-1$ 的每个索引 $i$：\n    a. 当栈 $s$ 不为空且栈顶元素小于或等于 $A[i]$ 时（即 $s.\\mathrm{top}() \\le A[i]$），从栈中弹出元素。其推理与 $\\mathrm{NGE}$ 的情况类似：这些被弹出的元素不可能是当前元素或任何后续元素的 $\\mathrm{PGE}$。\n    b. 在循环之后，如果栈不为空，其栈顶元素就是 $A[i]$ 左侧最近的更大元素。我们设置 $pge\\_arr[i] = s.\\mathrm{top}()$。\n    c. 如果栈为空，说明左侧不存在更大的元素，因此 $pge\\_arr[i]$ 保持为 $-1$。\n    d. 将当前元素 $A[i]$ 推入栈中。\n\n这次遍历的时间复杂度也为 $O(n)$。\n\n**3. 最终乘积计算**\n\n在计算出 $nge\\_arr$ 和 $pge\\_arr$ 数组后，通过逐元素相乘得到最终的乘积数组 $P$：对于从 $0$ 到 $n-1$ 的每个索引 $i$，计算 $P[i] = nge\\_arr[i] \\times pge\\_arr[i]$。这最后一步也需要 $O(n)$ 的时间。\n\n这种方法的总时间复杂度为 $O(n) + O(n) + O(n) = O(n)$，空间复杂度为 $O(n)$，用于存储栈和结果数组。该设计是高效的，并按预期直接利用了问题的结构特性。对于空输入数组，结果如规定所示，为空列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_products(A: list[int]) - list[int]:\n    \"\"\"\n    Computes the product of the Next Greater Element and Previous Greater Element\n    for each element in an array using a monotonic stack approach.\n    \"\"\"\n    n = len(A)\n    if n == 0:\n        return []\n\n    # Initialize result arrays for NGE and PGE with -1.\n    # We use numpy for efficient array operations as permitted.\n    nge_arr = np.full(n, -1, dtype=np.int64)\n    pge_arr = np.full(n, -1, dtype=np.int64)\n\n    # 1. Compute Next Greater Element (NGE) for each element.\n    # We iterate from right-to-left. The stack stores elements from the right\n    # that are candidates for being an NGE.\n    stack = []\n    for i in range(n - 1, -1, -1):\n        # Pop elements from the stack that are less than or equal to the current element.\n        # They cannot be the NGE for A[i] or any elements to the left of A[i].\n        while stack and stack[-1] = A[i]:\n            stack.pop()\n        \n        # If the stack is not empty, the top element is the NGE.\n        if stack:\n            nge_arr[i] = stack[-1]\n        \n        # Push the current element onto the stack for subsequent elements to the left.\n        stack.append(A[i])\n\n    # 2. Compute Previous Greater Element (PGE) for each element.\n    # We iterate from left-to-right. The logic is symmetric to the NGE computation.\n    stack = []\n    for i in range(n):\n        # Pop elements from the stack that are less than or equal to the current element.\n        while stack and stack[-1] = A[i]:\n            stack.pop()\n        \n        # If the stack is not empty, the top element is the PGE.\n        if stack:\n            pge_arr[i] = stack[-1]\n            \n        # Push the current element onto the stack for subsequent elements to the right.\n        stack.append(A[i])\n\n    # 3. Compute the element-wise product of NGE and PGE arrays.\n    products = np.multiply(nge_arr, pge_arr)\n    \n    # Return the result as a standard Python list of integers.\n    return products.tolist()\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the computation for each case,\n    and prints the aggregated results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [5, 1, 3, 2, 4],  # Case 1\n        [1, 2, 3, 4],      # Case 2\n        [4, 3, 2, 1],      # Case 3\n        [2, 2, 2],         # Case 4\n        [7],               # Case 5\n        [],                # Case 6\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_products(case)\n        results.append(result)\n\n    # Format the final output string as a list of lists with no spaces.\n    # E.g., [[r1_1,r1_2],[r2_1],[],...]\n    string_parts = []\n    for res_list in results:\n        # Format each inner list as \"[el1,el2,...]\"\n        string_parts.append(f\"[{','.join(map(str, res_list))}]\")\n    \n    # Join the inner list strings and wrap with outer brackets.\n    final_output = f\"[{','.join(string_parts)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "3254179"}, {"introduction": "在掌握了基础知识后，让我们来处理一个更细致的变体。这个问题要求我们不仅要找到左侧和右侧的更大元素，还要根据索引距离找出“最近”的一个。这促使我们思考如何利用单调栈不仅找到值，还找到它们的位置，并根据额外条件（在本例中是距离和决胜规则）做出决策。这项练习能很好地训练我们将单调栈的输出用于更复杂的逻辑判断。[@problem_id:3254259]", "problem": "给定一个在全序域（例如，具有常规顺序的整数）上的长度为 $n$ 的数组 $A$。对于每个索引 $i$（$0 \\le i  n$），定义目标索引 $j$ 为在满足严格不等式 $A[j]  A[i]$ 的前提下，最小化绝对索引距离 $|i - j|$ 的索引。如果不存在这样的索引 $j$，则该位置返回 $-1$。在距离相等的情况下，即当存在索引 $j_\\ell$ 和 $j_r$，满足 $j_\\ell  i  j_r$，$A[j_\\ell]  A[i]$，$A[j_r]  A[i]$，且 $|i - j_\\ell| = |j_r - i|$ 时，选择较小的索引（即左边的索引），也就是 $j_\\ell$。\n\n你的任务是实现一个程序，对于给定的数组 $A$，计算一个长度为 $n$ 的列表 $B$，其中 $B[i]$ 是按上述定义选择的索引 $j$，如果不存在这样的索引，则为 $-1$。\n\n请从第一性原理出发，仅使用数组和栈的基本定义，以及栈数据结构支持后进先出（last-in-first-out）顺序的推入（push）和弹出（pop）操作这一经过充分验证的事实来设计你的解决方案。不要假设或引用任何用于“最近更大元素”查询的预先推导的专门公式；而是要论证能够导出一个线性时间方法的数据结构不变量。\n\n测试套件和要求的输出：\n- 使用以下数组作为测试用例：\n    1. $[2,1,3,2,4]$\n    2. $[1,2,3,4]$\n    3. $[4,3,2,1]$\n    4. $[2,2,2,2]$\n    5. $[5,1,5,1,5]$\n    6. $[2,1,1,3]$\n    7. $[7]$\n- 对于每个测试用例，计算相应的整数索引列表 $B$。最终的程序输出必须将所有测试用例的结果聚合到单行中，该行包含一个逗号分隔的各测试用例结果的列表，每个结果本身是一个整数列表，并且整个聚合体用方括号括起来。例如，如果有三个测试用例，结果分别为 $R_1$、$R_2$ 和 $R_3$，则输出格式为 $[R_1,R_2,R_3]$，其中每个 $R_k$ 都以 $[\\dots]$ 的形式打印，不带空格。", "solution": "该问题是有效的，因为它是自洽的、在数学上是适定的，并且植根于计算机科学和离散数学的原理。它提出了一个清晰、客观的算法挑战，没有任何科学上的不一致或歧义。\n\n任务是为数组 $A$（长度为 $n$）中的每个元素 $A[i]$，找到一个元素 $A[j]$ 的索引 $j$，该元素严格大于 $A[i]$ 并且在索引距离 $|i - j|$ 上离 $i$ 最近。一个特定的决胜规则是在存在两个等距离的此类元素时，倾向于较小的索引（左侧的索引）。\n\n一个直接的暴力方法是，对从 $0$ 到 $n-1$ 的每个索引 $i$，从 $i$ 向左、右两个方向向外搜索，以找到第一个满足 $A[j]  A[i]$ 的索引 $j$。这将导致对每个 $i$ 都需要搜索多达 $O(n)$ 个其他索引，从而使总体时间复杂度达到 $O(n^2)$。我们可以利用栈数据结构设计一个更高效的解决方案，其时间复杂度为线性时间 $O(n)$。\n\n核心思想是将问题分解为两个独立的子问题：\n1. 对每个索引 $i$，找到“左侧最近更大元素”，我们记作 $j_\\ell(i)$。这是满足 $A[k]  A[i]$ 且离 $i$ 最近（即最大的 $k$）的索引 $k  i$。如果不存在这样的索引，我们定义 $j_\\ell(i) = -1$。\n2. 对每个索引 $i$，找到“右侧最近更大元素”，我们记作 $j_r(i)$。这是满足 $A[k]  A[i]$ 且离 $i$ 最近（即最小的 $k$）的索引 $k  i$。如果不存在这样的索引，我们定义 $j_r(i) = -1$。\n\n一旦我们计算出数组 $J_\\ell = [j_\\ell(0), j_\\ell(1), \\dots, j_\\ell(n-1)]$ 和 $J_r = [j_r(0), j_r(1), \\dots, j_r(n-1)]$，我们就可以通过比较候选者 $j_\\ell(i)$ 和 $j_r(i)$ 来确定每个索引 $i$ 的最终结果 $B[i]$：\n- 如果 $j_\\ell(i)$ 和 $j_r(i)$ 均为 $-1$，则不存在这样的更大元素，所以 $B[i] = -1$。\n- 如果只有一个存在（不为 $-1$），那么它就是答案。例如，如果 $j_\\ell(i) \\ne -1$ 且 $j_r(i) = -1$，则 $B[i] = j_\\ell(i)$。\n- 如果两者都存在，我们比较距离。到左侧的距离是 $d_\\ell = i - j_\\ell(i)$，到右侧的距离是 $d_r = j_r(i) - i$。根据问题的决胜规则，如果 $d_\\ell \\le d_r$，我们选择左侧的索引。因此，如果 $i - j_\\ell(i) \\le j_r(i) - i$，则 $B[i] = j_\\ell(i)$，否则 $B[i] = j_r(i)$。\n\n主要挑战在于在线性时间内计算 $J_\\ell$ 和 $J_r$。我们可以使用单调栈来实现这一点。让我们从第一性原理推导计算 $J_\\ell$ 的算法。$J_r$ 的逻辑是对称的。\n\n为了计算 $J_\\ell$，我们从左到右遍历数组 $A$，从 $i=0$ 到 $n-1$。我们使用一个栈 `st` 来存储我们已经处理过的元素的索引。关键步骤是在这个栈上维护一个特定的不变量。\n\n**不变量**：栈 `st` 将包含一系列索引 $p_1, p_2, \\dots, p_k$（从栈底到栈顶），使得它们在数组 $A$ 中对应的值是严格递减的：$A[p_1]  A[p_2]  \\dots  A[p_k]$。这被称为单调递减栈。\n\n**寻找左侧最近更大元素（$J_\\ell$）的算法：**\n我们初始化一个空栈 `st` 和一个大小为 $n$、填充为 $-1$ 的结果数组 $J_\\ell$。然后我们用索引 $i$ 从 $0$ 到 $n-1$ 进行迭代：\n1. 对于当前元素 $A[i]$，我们查看栈顶的索引 $p$。\n2. 当栈不为空且栈顶索引对应的元素小于或等于当前元素（$A[st.\\text{top}()] \\le A[i]$）时，我们从栈中弹出元素。这样做是正确的，因为如果 $A[st.\\text{top}()] \\le A[i]$，那么索引 $st.\\text{top}()$ 永远不能成为任何未来元素 $A[k]$（其中 $ki$）的“左侧最近更大元素”，因为 $i$ 是一个离 $k$ 更近的索引，且 $A[i]$ 的值至少一样大，这使得 $st.\\text{top}()$ 成为一个次优候选者。\n3. 弹出循环结束后，栈要么是空的，要么其栈顶元素是一个索引 $p$，其中 $A[p]  A[i]$。因为我们弹出了所有值小于或等于 $A[i]$ 的、位于 $p$ 右侧的索引，所以这个索引 $p$ 是 $i$ 左侧值严格大于 $A[i]$ 的最近索引。因此，我们设置 $j_\\ell(i) = st.\\text{top}()$。如果栈变为空，则表示左侧没有比 $A[i]$ 更大的元素，$j_\\ell(i)$ 保持为 $-1$。\n4. 最后，我们将当前索引 $i$ 推入栈中。此操作保持了单调递减的不变量，因为所有值小于或等于 $A[i]$ 的元素都已被移除。\n\n这个过程会访问数组的每个元素一次。每个索引被精确地推入栈一次，并且至多被弹出一个。因此，计算整个 $J_\\ell$ 数组的时间复杂度为 $O(n)$。\n\n$J_r$ 数组的计算遵循对称的逻辑。我们可以从右到左遍历数组 $A$，从 $i=n-1$ 到 $0$，应用相同的单调栈原理。\n\n完整的算法如下：\n1. 使用从左到右的遍历和单调栈，在 $O(n)$ 时间内计算数组 $J_\\ell$。\n2. 使用从右到左的遍历和单调栈，在 $O(n)$ 时间内计算数组 $J_r$。\n3. 通过从 $i=0$ 到 $n-1$ 进行迭代，并应用距离比较和决胜逻辑，在 $O(n)$ 时间内将结果合并到最终数组 $B$ 中。\n\n总时间复杂度为 $O(n) + O(n) + O(n) = O(n)$，空间复杂度为 $O(n)$，用于存储栈以及中间数组 $J_\\ell$ 和 $J_r$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the nearest greater element problem for a list of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [2, 1, 3, 2, 4],\n        [1, 2, 3, 4],\n        [4, 3, 2, 1],\n        [2, 2, 2, 2],\n        [5, 1, 5, 1, 5],\n        [2, 1, 1, 3],\n        [7]\n    ]\n\n    results = []\n    for a in test_cases:\n        n = len(a)\n        if n == 0:\n            results.append([])\n            continue\n\n        # 1. Compute Nearest Greater to the Left (ngl)\n        # We iterate from left to right. The stack stores indices of elements\n        # in a monotonically decreasing value order.\n        ngl = [-1] * n\n        stack = []\n        for i in range(n):\n            # While stack is not empty and the element at the index on top of the stack\n            # is less than or equal to the current element, pop.\n            while stack and a[stack[-1]] = a[i]:\n                stack.pop()\n            # If the stack is not empty after popping, the top element is the NGL.\n            if stack:\n                ngl[i] = stack[-1]\n            # Push the current index onto the stack.\n            stack.append(i)\n\n        # 2. Compute Nearest Greater to the Right (ngr)\n        # We iterate from right to left. The logic is symmetric to NGL.\n        ngr = [-1] * n\n        stack = []\n        for i in range(n - 1, -1, -1):\n            # Pop elements from stack that are less than or equal to current element.\n            while stack and a[stack[-1]] = a[i]:\n                stack.pop()\n            # If stack is not empty, its top is the NGR.\n            if stack:\n                ngr[i] = stack[-1]\n            # Push current index.\n            stack.append(i)\n\n        # 3. Combine ngl and ngr to find the final result\n        result = [-1] * n\n        for i in range(n):\n            j_left, j_right = ngl[i], ngr[i]\n\n            # Case 1: No greater element exists\n            if j_left == -1 and j_right == -1:\n                result[i] = -1\n            # Case 2: Only greater element is to the right\n            elif j_left == -1:\n                result[i] = j_right\n            # Case 3: Only greater element is to the left\n            elif j_right == -1:\n                result[i] = j_left\n            # Case 4: Greater elements exist on both sides\n            else:\n                dist_left = i - j_left\n                dist_right = j_right - i\n                # Tie-breaking rule: choose left if distances are equal or left is closer.\n                if dist_left = dist_right:\n                    result[i] = j_left\n                else:\n                    result[i] = j_right\n        \n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Each result list is formatted as a string \"[i1,i2,...]\"\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3254259"}, {"introduction": "这项练习将我们的思维从单调栈的具体实现提升到其核心解题模式的抽象应用。寻找“最长山脉子数组”问题，其最优解的结构与我们之前看到的模式惊人地相似：它需要一次从左到右的遍历来计算上升序列的长度，以及一次从右到左的遍历来计算下降序列的长度。通过在每个潜在的“顶峰”将这两部分信息结合起来，我们能够高效地解决问题。这个例子证明了将问题分解为左右两个单调子问题的思想是一种强大的通用策略。[@problem_id:3254270]", "problem": "给定一个有限的整数序列，你需要为每个序列计算其最长连续“山脉”子数组的长度。山脉子数组被定义为一个先严格递增后严格递减的连续片段，且至少包含一次递增和一次递减。形式上，给定一个长度为 $n$ 的数组 $A$，一个索引满足 $0 \\le \\ell  r  n$ 的子数组 $A[\\ell \\dots r]$ 是一个山脉，如果存在一个索引 $p$ 满足 $\\ell  p  r$，使得以下严格不等式成立：$A_{\\ell}  A_{\\ell+1}  \\dots  A_{p-1}  A_{p}$ 且 $A_{p}  A_{p+1}  \\dots  A_{r}$。该子数组的长度为 $r - \\ell + 1$。如果不存在山脉子数组，则所需长度为 $0$。\n\n你的程序必须是一个完整、可运行的程序，能够计算本说明中提供的每个测试用例的最长山脉长度，并以指定格式将结果汇总打印在单行中。\n\n算法设计必须植根于数据结构和算法的基本定义。相关的基础是：\n- 栈是一种支持后进先出（LIFO）访问的容器。单调栈是一种其内容被维护以使存储的键序列保持单调（通常是严格递增或严格递减）的栈，它能够单次遍历计算不等式变化的边界索引。\n- 严格不等式、传递性和连续性约束定义了山脉的结构：从左到右遍历数组时，不等式 $A_{i-1}  A_{i}$ 表征一个递增步骤，而 $A_{i}  A_{i+1}$ 表征一个递减步骤。这些属性是局部的，并组合形成连续区域。\n\n除这些定义外，你不得假定任何特定的快捷公式。设计必须从单调性和不变量维护的第一性原理出发。\n\n输入数组由整数组成，可能包含负值，也可能包含重复值。严格性意味着任何相等情况 $A_{i} = A_{i+1}$ 都会在该边界处中断递增和递减的运行。山脉长度必须是元素的整数计数。不涉及物理单位。\n\n测试套件：\n- 用例 $1$：$[2,1,4,7,3,2,5]$。\n- 用例 $2$：$[2,2,2]$。\n- 用例 $3$：$[1,2,3,4]$。\n- 用例 $4$：$[4,3,2,1]$。\n- 用例 $5$：$[1,3,2]$。\n- 用例 $6$：$[1,2,2,3,2,1]$。\n- 用例 $7$：$[0,1,2,3,4,5,4,3,2,1,0]$。\n- 用例 $8$：$[-3,-2,-1,-2,-3]$。\n- 用例 $9$：$[1]$。\n- 用例 $10$：$[2,1,2,3,4,3,2,1,2]$。\n\n输出规范：\n- 对于每个测试用例，计算一个等于给定数组中最长山脉子数组长度的整数（如果不存在山脉，则为 $0$）。\n- 你的程序应生成单行输出，其中包含以逗号分隔的列表形式的结果，并用方括号括起来，不含空格，顺序与上述测试用例一致，例如 $[x_1,x_2,\\dots,x_{10}]$，其中每个 $x_i$ 是第 $i$ 个用例的整数长度。\n\n你的程序必须在没有任何外部输入的情况下运行，并且必须使用嵌入在代码中的测试套件。运行环境是一种现代语言；实现必须是通用的，并且应该能够扩展到大型数组，但在这里它将在给定的小型测试套件上执行。核心设计必须基于所描述的单调性原则，并且必须通过仔细处理边界情况（例如长度小于 $3$ 的数组、存在 $A_{i} = A_{i+1}$ 的平台的数组以及纯粹递增或纯粹递减的数组）来确保正确性。", "solution": "在着手解决方案之前，我们首先对问题陈述进行严格验证，以确保其科学和逻辑上的健全性。\n\n### 步骤1：提取给定条件\n\n问题提供了以下数据、定义和约束：\n- **目标**：对于给定的有限整数序列，计算其最长连续“山脉”子数组的长度。\n- **山脉子数组的定义**：给定一个长度为 $n$ 的数组 $A$，一个索引满足 $0 \\le \\ell  r  n$ 的连续子数组 $A[\\ell \\dots r]$ 是一个山脉，如果存在一个索引 $p$ 满足 $\\ell  p  r$，使得 $A_{\\ell}  A_{\\ell+1}  \\dots  A_{p-1}  A_{p}$ 且 $A_{p}  A_{p+1}  \\dots  A_{r}$。\n- **核心条件**：子数组必须包含至少一个严格递增步骤和至少一个严格递减步骤。\n- **长度定义**：子数组 $A[\\ell \\dots r]$ 的长度定义为 $r - \\ell + 1$。\n- **基本情况**：如果不存在山脉子数组，则长度为 $0$。\n- **算法基础**：解决方案必须从单调性和不变量维护的第一性原理推导得出，并特别提到单调栈作为相关概念。\n- **输入属性**：输入数组由整数组成，可能包含负值，也可能包含重复值。\n- **严格不等式**：相等情况 $A_{i} = A_{i+1}$ 构成“平台”，并会中断严格递增和严格递减的运行。\n- **测试套件**：\n    - 用例 $1$：$[2,1,4,7,3,2,5]$\n    - 用例 $2$：$[2,2,2]$\n    - 用例 $3$：$[1,2,3,4]$\n    - 用例 $4$：$[4,3,2,1]$\n    - 用例 $5$：$[1,3,2]$\n    - 用例 $6$：$[1,2,2,3,2,1]$\n    - 用例 $7$：$[0,1,2,3,4,5,4,3,2,1,0]$\n    - 用例 $8$：$[-3,-2,-1,-2,-3]$\n    - 用例 $9$：$[1]$\n    - 用例 $10$：$[2,1,2,3,4,3,2,1,2]$\n- **输出规范**：单行输出，包含以逗号分隔的整数结果，并用方括号括起来，例如 $[x_1,x_2,\\dots,x_{10}]$。\n\n### 步骤2：使用提取的给定条件进行验证\n\n根据验证标准对问题进行评估：\n- **科学性**：该问题是数学和计算机科学（特别是算法）领域中一个明确定义的练习。它依赖于序列、子数组和严格不等式的形式化定义。它没有任何非科学的前提。\n- **适定性**：该问题是适定的。对于任何有限数组，其所有连续子数组的集合是有限的。对于每个子数组，“山脉”属性是可判定的。所有有效山脉子数组的长度集合是一个有限的非负整数集合，必然存在一个明确定义的最大值。因此，存在唯一的解。\n- **客观性**：该问题使用精确、客观的数学语言陈述。诸如“连续”、“严格递增”和“严格递减”之类的术语是明确的。\n- **缺陷分析**：\n    1.  **科学或事实上的不健全性**：无。该问题在逻辑和数学上是一致的。\n    2.  **非形式化或不相关**：该问题是可形式化的。这些概念可以直接转化为算法。对单调栈的引用正确地将问题定位在数据结构和算法领域内。\n    3.  **不完整或矛盾的设置**：该问题是自洽的。山脉的定义是完整的，指明了结构、峰顶的存在、严格的单调性、隐含的最小长度 $3$（一次上升，一次下降）以及默认结果 $0$。\n    4.  **不现实或不可行**：不适用，因为该问题处理的是抽象的数学对象（整数数组）。\n    5.  **不适定或结构不良**：无。问题结构保证了一个唯一的、有意义的解。\n    6.  **伪深刻、琐碎或同义反复**：该问题并非琐碎，需要一个有效的算法方法来高效求解。它代表了一类标准的数组处理问题。\n    7.  **超出科学可验证性**：对于任何给定的输入，其解在数学上都是可验证的。\n\n### 步骤3：结论与行动\n\n该问题是**有效的**。这是一个清晰、自洽且逻辑上健全的算法挑战。我们现在将基于第一性原理着手制定解决方案。\n\n### 解决方案\n\n该问题要求我们找到符合“山脉”结构的最长连续子数组的长度。山脉的特征在于一个峰顶元素、一段通往峰顶的严格递增序列以及一段紧随峰顶的严格递减序列。这一结构意味着，任何元素要成为峰顶，它必须严格大于其直接相邻的元素。\n\n解决这个问题的核心原则是将山脉结构分解为其基本的单调组成部分：一个严格递增部分和一个严格递减部分。我们可以系统地分析数组，为每个潜在的峰顶量化这些组成部分。动态规划方法特别适合此问题，因为它允许我们从较小子问题的解来构建最终解。\n\n设输入数组为 $A$，长度为 $n$。该算法分三个阶段进行：\n\n1.  **计算上坡长度**：我们定义一个与 $A$ 大小相同的数组 `up`。对于从 $0$ 到 $n-1$ 的每个索引 $i$，`up`$[i]$ 将存储以索引 $i$ 结尾的最长严格递增连续子数组的长度。\n    这可以通过从左到右的单次遍历来计算。根据定义，`up`$[0] = 1$。对于任何后续索引 $i0$：\n    - 如果 $A[i]  A[i-1]$，则递增序列得以延伸。因此，`up`$[i] = \\text{`up`}[i-1] + 1$。\n    - 如果 $A[i] \\le A[i-1]$，则严格递增序列被中断。一个长度为 $1$ 的新序列（仅包含 $A[i]$）从此索引开始。因此，`up`$[i] = 1$。\n\n2.  **计算下坡长度**：类似地，我们定义一个大小为 $n$ 的数组 `down`。对于每个索引 $i$，`down`$[i]$ 将存储从索引 $i$ 开始的最长严格递减连续子数组的长度。\n    这可以通过从右到左的单次遍历来计算。根据定义，`down`$[n-1] = 1$。对于任何之前的索引 $i  n-1$：\n    - 如果 $A[i]  A[i+1]$，则递减序列从右侧延伸。因此，`down`$[i] = \\text{`down`}[i+1] + 1$。\n    - 如果 $A[i] \\le A[i+1]$，则严格递减序列被中断。一个长度为 $1$ 的新序列从此索引开始。因此，`down`$[i] = 1$。\n\n3.  **合并并寻找最大长度**：一个元素 $A[i]$ 能作为山脉的峰顶，当且仅当它之前有一个严格递增序列，之后有一个严格递减序列。这等价于条件 `up`$[i]  1$ 和 `down`$[i]  1$。条件 `up`$[i]  1$ 确保至少有一个上坡步骤，而 `down`$[i]  1$ 确保至少有一个下坡步骤。\n    如果这些条件满足，以 $i$ 为峰顶的山脉的总长度是上坡部分的长度加上下坡部分的长度。峰顶元素 $A[i]$ 在 `up`$[i]$ 和 `down`$[i]$ 中都被计数，所以我们必须减去 $1$ 以避免重复计数。这样一个山脉的长度是 `up`$[i] + \\text{`down`}[i] - 1$。\n    我们遍历从 $0$ 到 $n-1$ 的所有索引 $i$。对于每个符合峰顶条件的 $i$，我们计算其山脉长度，并更新我们目前为止找到的最大长度记录。初始最大长度为 $0$。\n\n该方法系统地检查了每个潜在的峰顶，正确计算了与其相关的山脉长度，并找到了全局最大值。由于对数组进行了三次独立的线性遍历，其时间复杂度为 $O(n)$，而用于辅助数组 `up` 和 `down` 的空间复杂度为 $O(n)$。这种方法直接体现了问题中提到的通过分析单调段来解决问题的原则。\n\n任何可能包含山脉的数组的最小长度为 $3$。长度 $n  3$ 的数组无法满足条件 $\\ell  p  r$，因此其最长山脉长度不证自明地为 $0$。这一点可以通过 `up`$[i]  1$ 和 `down`$[i]  1$ 的条件自然处理，但对 $n  3$ 进行初始检查是一种审慎的优化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_longest_mountain(arr: list[int]) - int:\n    \"\"\"\n    Computes the length of the longest contiguous mountain subarray.\n\n    A mountain subarray is defined as a contiguous segment that is strictly\n    increasing and then strictly decreasing. It must have at least one\n    increase and at least one decrease.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The length of the longest mountain subarray, or 0 if none exists.\n    \"\"\"\n    n = len(arr)\n    # A mountain must have length at least 3.\n    if n  3:\n        return 0\n\n    # up[i] will store the length of the strictly increasing subarray ending at i.\n    # We use numpy arrays as permitted by the execution environment.\n    up = np.ones(n, dtype=int)\n    for i in range(1, n):\n        # Extend the increasing run if the current element is greater than the previous.\n        if arr[i]  arr[i-1]:\n            up[i] = up[i-1] + 1\n\n    # down[i] will store the length of the strictly decreasing subarray starting at i.\n    down = np.ones(n, dtype=int)\n    for i in range(n - 2, -1, -1):\n        # Extend the decreasing run if the current element is greater than the next.\n        if arr[i]  arr[i+1]:\n            down[i] = down[i+1] + 1\n            \n    max_length = 0\n    # Iterate through all possible peak indices.\n    for i in range(n):\n        # A valid peak requires at least one step up and one step down.\n        # This is equivalent to the uphill and downhill runs having length  1.\n        if up[i]  1 and down[i]  1:\n            # The total length is the sum of the run lengths, subtracting 1\n            # to not double-count the peak element.\n            current_length = up[i] + down[i] - 1\n            if current_length  max_length:\n                max_length = current_length\n                \n    return int(max_length)\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the solver on each case, and\n    prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        [2,1,4,7,3,2,5],          # Case 1\n        [2,2,2],                  # Case 2\n        [1,2,3,4],                # Case 3\n        [4,3,2,1],                # Case 4\n        [1,3,2],                  # Case 5\n        [1,2,2,3,2,1],            # Case 6\n        [0,1,2,3,4,5,4,3,2,1,0],  # Case 7\n        [-3,-2,-1,-2,-3],         # Case 8\n        [1],                      # Case 9\n        [2,1,2,3,4,3,2,1,2],    # Case 10\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_longest_mountain(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3254270"}]}