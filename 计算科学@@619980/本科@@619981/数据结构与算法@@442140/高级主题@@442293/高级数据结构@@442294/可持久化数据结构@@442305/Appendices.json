{"hands_on_practices": [{"introduction": "我们的动手实践始于一个经典问题：实现一个持久化队列。这个练习将帮助你掌握持久化数据结构的核心思想，即不变性（immutability）和结构共享（structural sharing）。你将通过一个巧妙的双链表设计，来达到队列操作的均摊 $O(1)$ 时间复杂度，这本身就是一个值得学习的算法技巧。[@problem_id:3246712]", "problem": "您需要从基本原理开始，使用单向链表实现一个持久化的先进先出（FIFO）队列。在此队列中，任何在概念上改变队列的操作都会返回一个新队列，并保持原队列不变。请从核心定义开始：队列是一种抽象数据类型，其中最早添加的元素最先被移除；单向链表由节点组成，每个节点包含一个值和一个指向下一个节点的引用；持久化数据结构在更新时会返回一个新版本，而不会改变先前的版本，从而实现版本间的结构共享。您必须确保在队列的任何先前版本中，已存在的节点在创建后都不得被修改。目标时间复杂度是每次入队和出队操作的均摊时间复杂度为 $O(1)$。\n\n您必须实现一个完整的、可运行的程序，该程序定义了：\n- 一个用于整数的不可变单向链表节点类型。\n- 一个队列类型，其操作不会修改现有节点。\n- 一个操作 $\\mathrm{enqueue}(q, x)$，它返回一个在队尾添加了整数 $x$ 的新队列。\n- 一个操作 $\\mathrm{dequeue}(q)$，它返回一个三元组 $(s, v, q')$，其中 $s$ 是一个布尔值，指示操作是否成功；当 $s$ 为真时，$v$ 是被移除的整数；$q'$ 是新的队列。如果 $q$ 为空，则 $s$ 为假，$v$ 必须为 $0$，且 $q' = q$。\n- 一个函数，用于计算队列的大小，返回一个非负整数。\n\n您的程序不得依赖任何用户输入，并且必须在内部执行以下测试套件。每个测试用例都是对持久化队列的一系列操作，并且必须产生可量化的整数或布尔值结果，并按指定的输出格式汇总。\n\n测试套件：\n- 测试用例 $A$ (正常流程与持久化检查)：\n  1. 设 $q_0$ 为空队列。\n  2. 设 $q_1 = \\mathrm{enqueue}(q_0, 1)$。\n  3. 设 $q_2 = \\mathrm{enqueue}(q_1, 2)$。\n  4. 设 $q_3 = \\mathrm{enqueue}(q_2, 3)$。\n  5. 执行 $\\mathrm{dequeue}(q_3)$，得到 $(s_1, v_1, q_4)$。\n  6. 执行 $\\mathrm{dequeue}(q_4)$，得到 $(s_2, v_2, q_5)$。\n  7. 执行 $\\mathrm{dequeue}(q_3)$，得到 $(s_3, v_3, q_6)$。\n  此测试用例的输出必须是列表 $[v_1, v_2, v_3]$。\n\n- 测试用例 $B$ (队尾到队首的重组边界情况)：\n  1. 设 $q_0$ 为空队列。\n  2. 设 $q_1 = \\mathrm{enqueue}(q_0, 10)$。\n  3. 设 $q_2 = \\mathrm{enqueue}(q_1, 20)$。\n  4. 设 $q_3 = \\mathrm{enqueue}(q_2, 30)$。\n  5. 设 $q_4 = \\mathrm{enqueue}(q_3, 40)$。\n  6. 执行 $\\mathrm{dequeue}(q_4)$，得到 $(s_4, v_4, q_5)$。\n  7. 执行 $\\mathrm{dequeue}(q_5)$，得到 $(s_5, v_5, q_6)$。\n  此测试用例的输出必须是列表 $[v_4, v_5]$。\n\n- 测试用例 $C$ (空队列边界情况)：\n  1. 设 $q_0$ 为空队列。\n  2. 执行 $\\mathrm{dequeue}(q_0)$，得到 $(s_0, v_0, q_1)$，其中 $s_0$ 预期为假，$v_0$ 必须为 $0$。\n  3. 设 $q_2 = \\mathrm{enqueue}(q_0, 99)$。\n  4. 执行 $\\mathrm{dequeue}(q_2)$，得到 $(s_6, v_6, q_3)$。\n  此测试用例的输出必须是列表 $[s_0, s_6, v_6]$。\n\n设计时需确保正确性和持久性：所有操作都必须保持现有节点的不可变性，并按要求返回新的队列实例。您的程序应生成单行输出，其中包含按以下确切顺序连接的测试用例 $A$、测试用例 $B$ 和测试用例 $C$ 的结果，格式为逗号分隔的列表并由方括号括起：$[v_1, v_2, v_3, v_4, v_5, s_0, s_6, v_6]$。所有输出均为纯整数或布尔值，不涉及物理单位、角度或百分比。", "solution": "该问题要求使用单向链表实现一个持久化的先进先出（FIFO）队列。实现必须从基本原理开始，确保所有操作都是非修改性的（持久化的），并且`enqueue`和`dequeue`操作达到均摊时间复杂度 $O(1)$。\n\n根据定义，持久化数据结构在被修改时会保留其先前版本。任何在概念上改变结构的操作都会返回一个新的、被修改的实例，同时保持原始实例不变。这使得数据结构的不同版本能够共存并共享公共子结构，这既节省内存，又对某些函数式编程范式和算法至关重要。\n\n使用单个单向链表实现队列的朴素方法无法满足性能要求。单向链表天然支持在其头部进行高效的、常数时间（$O(1)$）的添加和移除操作。如果我们使用头部进行`dequeue`，那么`enqueue`必须将元素添加到尾部。找到单向链表的尾部需要从头部开始遍历，这是一个时间复杂度为线性 $O(n)$ 的操作，其中 $n$ 是元素的数量。这将使得`enqueue`操作慢得无法接受。\n\n为了实现所期望的均摊 $O(1)$ 复杂度，标准且正确的方法是使用两个单向链表来表示队列：一个`front`列表和一个`rear`列表。\n\n设队列 $q$ 的状态由一对列表 $(f, r)$ 表示，其中 $f$ 是`front`列表，$r$ 是`rear`列表。\n- `front`列表以正确的出队顺序存储元素。也就是说，`front`列表的头部是队列中最早的元素。\n- `rear`列表以相反的顺序（像一个栈）存储新入队的元素。`rear`列表的头部是最近入队的元素。\n\n操作设计如下：\n- **`enqueue(q, x)`**：要将元素 $x$ 添加到队列 $q = (f, r)$ 中，我们为 $x$ 创建一个新节点，并将其前插到`rear`列表的头部。返回一个新的队列实例 $q' = (f, \\mathrm{cons}(x, r))$。`front`列表 $f$ 是共享的，并且因为我们只在 $r$ 的头部插入，所以原始的`rear`列表也是共享的。这纯粹是一个局部修改，只创建一个新节点，因此是一个 $O(1)$ 操作。\n\n- **`dequeue(q)`**：此操作移除队列头部的元素。设队列为 $q = (f, r)$。\n    1.  如果`front`列表 $f$ 非空，其头部包含最早的元素。我们返回该元素的值。新的队列状态是 $(f_{\\mathrm{tail}}, r)$，其中 $f_{\\mathrm{tail}}$ 是去除了头部的`front`列表。这也是一个 $O(1)$ 操作，因为它只涉及指针操作和创建一个共享现有列表结构的新队列对象。\n    2.  如果`front`列表 $f$ 为空，这表明所有先前准备好出队的元素都已被消耗。为了继续，我们必须将元素从`rear`列表 $r$ 移动到`front`列表。由于`rear`列表以相反的顺序存储元素，我们必须执行一次列表反转。我们创建一个新列表 $f'$，它是 $r$ 的反转。这个新列表 $f'$ 成为队列的`front`列表，而`rear`列表变为空。此反转操作的时间复杂度为 $O(k)$，其中 $k$ 是`rear`列表中的元素数量。在这次重新平衡之后，队列状态实际上变为 $(f', \\mathrm{empty\\_list})$，然后我们可以像情况1一样，从 $f'$ 的头部出队。\n\n反转操作的 $O(k)$ 开销并未违反均摊 $O(1)$ 的复杂度要求。这次昂贵的`dequeue`操作的成本可以被分摊，或“均摊”，到构建`rear`列表的 $k$ 次廉价的`enqueue`操作上。队列中的每个元素都只入队一次（$O(1)$），至多从`rear`列表移动到`front`列表一次（即，作为反转的一部分，平均成本 $O(1)$），并且出队一次（$O(1)$）。因此，每次操作的平均成本保持为常数。\n\n持久化的一个关键方面是，反转操作不得修改现有的`rear`列表。相反，它必须构建一个全新的节点列表来表示反转后的序列。这确保了任何共享此`rear`列表的队列先前版本保持有效且不变。这一特性由测试用例 A 明确测试，其中`dequeue`在同一个队列版本 $q_3$ 上被调用两次，要求该操作是可重复且无副作用的。\n\n实现将包括一个不可变的`Node`类和一个`PersistentQueue`类，该类封装了`front`和`rear`列表以及`enqueue`、`dequeue`和`size`操作的相关逻辑。空队列是两个列表都为空的特殊情况。对空队列执行`dequeue`操作会返回一个失败状态、一个占位符值 $0$ 以及原始的空队列实例，正如所规定的那样。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a persistent FIFO queue and runs the specified test suite.\n    \"\"\"\n\n    class Node:\n        \"\"\"\n        An immutable singly linked list node for integers.\n        Immutability is by convention; attributes are not privately enforced.\n        \"\"\"\n        __slots__ = ('value', 'next')\n\n        def __init__(self, value: int, next_node=None):\n            self.value = value\n            self.next = next_node\n\n    def _reverse_list(node: Node | None) -> Node | None:\n        \"\"\"\n        Persistently reverses a singly linked list.\n        It creates a new list structure without mutating the original.\n        \"\"\"\n        new_head = None\n        current = node\n        while current:\n            new_head = Node(current.value, new_head)\n            current = current.next\n        return new_head\n\n    class PersistentQueue:\n        \"\"\"\n        A persistent FIFO queue implemented with two singly linked lists.\n        \"\"\"\n        # A cached singleton instance for the empty queue for efficiency.\n        _EMPTY_INSTANCE = None\n\n        def __init__(self, front: Node | None = None, rear: Node | None = None, size: int = 0):\n            \"\"\"\n            Private constructor. Use get_empty_queue() for the initial queue.\n            \"\"\"\n            self.front = front\n            self.rear = rear\n            self._size = size\n\n        @staticmethod\n        def get_empty_queue():\n            \"\"\"Factory method for creating or retrieving the empty queue instance.\"\"\"\n            if PersistentQueue._EMPTY_INSTANCE is None:\n                PersistentQueue._EMPTY_INSTANCE = PersistentQueue()\n            return PersistentQueue._EMPTY_INSTANCE\n        \n        def enqueue(self, value: int):\n            \"\"\"\n            Returns a new queue with the integer value added at the back.\n            Amortized time complexity: O(1).\n            \"\"\"\n            # Creates a new node and prepends it to the rear list.\n            return PersistentQueue(self.front, Node(value, self.rear), self._size + 1)\n\n        def dequeue(self):\n            \"\"\"\n            Returns a triple (success, value, new_queue).\n            If the queue is empty, success is False, value is 0, and a reference\n            to the same empty queue is returned.\n            Amortized time complexity: O(1).\n            \"\"\"\n            if self._size == 0:\n                return (False, 0, self)\n\n            # If the front list is not empty, we can dequeue from it directly.\n            if self.front is not None:\n                value = self.front.value\n                # The new queue shares the rear list.\n                new_queue = PersistentQueue(self.front.next, self.rear, self._size - 1)\n                return (True, value, new_queue)\n            \n            # If the front list is empty, the rear list must be reversed to become\n            # the new front list. This is the expensive step.\n            new_front = _reverse_list(self.rear)\n            value = new_front.value\n            # The new queue's rear list is now empty.\n            new_queue = PersistentQueue(new_front.next, None, self._size - 1)\n            return (True, value, new_queue)\n\n        def get_size(self) -> int:\n            \"\"\"\n            Returns the total number of elements in the queue.\n            Time complexity: O(1).\n            \"\"\"\n            return self._size\n\n    # --- Test Suite Execution ---\n    all_results = []\n\n    # Test Case A (happy path and persistence check)\n    q0_a = PersistentQueue.get_empty_queue()\n    q1_a = q0_a.enqueue(1)\n    q2_a = q1_a.enqueue(2)\n    q3_a = q2_a.enqueue(3)\n    s1, v1, q4_a = q3_a.dequeue()\n    s2, v2, q5_a = q4_a.dequeue()\n    s3, v3, q6_a = q3_a.dequeue() # Re-use q3 to check persistence\n    all_results.extend([v1, v2, v3])\n\n    # Test Case B (rear-to-front reorganization edge)\n    q0_b = PersistentQueue.get_empty_queue()\n    q1_b = q0_b.enqueue(10)\n    q2_b = q1_b.enqueue(20)\n    q3_b = q2_b.enqueue(30)\n    q4_b = q3_b.enqueue(40)\n    s4, v4, q5_b = q4_b.dequeue()\n    s5, v5, q6_b = q5_b.dequeue()\n    all_results.extend([v4, v5])\n\n    # Test Case C (empty boundary case)\n    q0_c = PersistentQueue.get_empty_queue()\n    s0, v0, q1_c = q0_c.dequeue()\n    q2_c = q0_c.enqueue(99)\n    s6, v6, q3_c = q2_c.dequeue()\n    all_results.extend([s0, s6, v6])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3246712"}, {"introduction": "在掌握了基础之后，我们来挑战一个更高级的应用：为一种高效的数据结构——芬威克树（Fenwick Tree）添加持久化能力。这个练习将引导你实现“部分持久化”，即只在最新版本上进行更新，但可以查询任意历史版本。你将学习如何通过“胖节点”（fat nodes）技术，在每个节点上记录其值的变更历史，并结合二分搜索来高效地回答历史前缀和查询。[@problem_id:3258634]", "problem": "请从基本原理出发，实现一个部分持久化树状数组（Fenwick tree，也称作二叉索引树），该数据结构支持历史版本的前缀和查询。您的设计和分析必须基于数据结构中部分持久化的核心定义以及树状数组的标准结构和不变量，不得调用或假设任何预先构建的持久化框架。您还需要监测在历史版本查找过程中，二分搜索所执行的关键比较次数，并为提供的测试套件中的每个查询，报告其数值前缀和与比较次数。\n\n一个部分持久化数据结构允许对任意历史版本进行查询，但将更新限制在最新版本。考虑一个长度为 $n$ 的数组 $A$，其版本 $0$ 初始化为全零。在逻辑时间 $t \\in \\{1,2,\\dots\\}$ 的一次更新操作，会通过对某个索引 $p \\in \\{1,2,\\dots,n\\}$ 应用一个整数偏移量 $\\Delta$ 的单点增量，从版本 $t-1$ 生成版本 $t$。一次历史版本前缀和查询由一个版本 $v$ 和一个前缀索引 $i \\in \\{0,1,\\dots,n\\}$ 参数化，要求计算在版本 $v$ 时数组 $A[1] + A[2] + \\dots + A[i]$ 的和。定义前缀索引 $i=0$ 时返回的和为 $0$。\n\n您必须实现一个大小为 $n$ 的树状数组，其中索引 $j$ 处的单元格存储由 $j$ 的最低有效位（least significant set bit）所覆盖的索引范围内的部分和。为了使其部分持久化，在每个树状数组索引 $j$ 处，您需要维护一个按时间排序的序对 $(t, \\mathrm{val})$ 序列，其中 $t$ 是最后一次改变该树状数组索引值的更新操作的逻辑时间，而 $\\mathrm{val}$ 是该次更新后树状数组单元格的值。用基准序对 $(0,0)$ 初始化每个索引，以确保在版本 $0$ 上的查询有明确定义。每次在时间 $t$ 的更新必须访问 $O(\\log n)$ 个树状数组索引，并在每个被访问的索引处追加一个带有时间 $t$ 和更新后值的新序对。一次在版本 $v$ 和前缀索引 $i$ 的历史版本前缀和查询，必须从 $i$ 开始执行常规的树状数组向下遍历，并在每个被访问的树状数组索引 $j$ 处，对其按时间排序的序列执行二分搜索，以检索时间戳 $\\le v$ 的最新值。在遍历过程中检索到的这些值的总和即为答案。\n\n请按如下方式监测二分搜索。对于在某个树状数组索引上执行的每次二分搜索，在搜索过程中每评估一次形如“当前时间 $\\le v$？”的谓词，就计为一次比较。一个查询的总比较次数是该查询遍历过程中访问的所有树状数组索引上这些计数之和。对于每个查询，报告一个序对 $[S,C]$，其中 $S$ 是整数历史前缀和， $C$ 是该查询期间所有二分搜索执行的时间比较总次数（整数）。\n\n您必须在以下测试套件上实现并运行您的解决方案。首先，为长度为 $n=8$ 的数组构建一个部分持久化树状数组，并按顺序应用以下 $8$ 次更新，生成版本 $t=1$ 到 $t=8$：\n\n- 在时间 $t=1$ 时：在位置 $p=3$ 处增加 $\\Delta=+5$。\n- 在时间 $t=2$ 时：在位置 $p=5$ 处增加 $\\Delta=-2$。\n- 在时间 $t=3$ 时：在位置 $p=1$ 处增加 $\\Delta=+7$。\n- 在时间 $t=4$ 时：在位置 $p=8$ 处增加 $\\Delta=+4$。\n- 在时间 $t=5$ 时：在位置 $p=3$ 处增加 $\\Delta=+3$。\n- 在时间 $t=6$ 时：在位置 $p=2$ 处增加 $\\Delta=-1$。\n- 在时间 $t=7$ 时：在位置 $p=5$ 处增加 $\\Delta=+6$。\n- 在时间 $t=8$ 时：在位置 $p=7$ 处增加 $\\Delta=+2$。\n\n构建完版本 $t=0,1,\\dots,8$ 后，评估以下历史版本前缀和查询 $(v,i)$：\n\n- $(v=0,i=8)$\n- $(v=1,i=3)$\n- $(v=5,i=5)$\n- $(v=7,i=5)$\n- $(v=8,i=8)$\n- $(v=8,i=0)$\n- $(v=5,i=3)$\n- $(v=4,i=4)$\n\n您的程序必须输出单行结果，其聚合格式必须完全如下：一个包含 $8$ 个结果的单一列表，其中每个结果本身是一个双元素列表 $[S,C]$，输出中不含任何空格。例如，格式必须类似于 $[[S_1,C_1],[S_2,C_2],\\dots,[S_8,C_8]]$，其中的数字由您的程序填充。\n\n您的实现和分析必须满足以下源于核心定义的约束：\n\n- 使用标准的树状数组遍历不变量，在 $O(\\log n)$ 个被访问索引内完成更新和查询。\n- 通过追加带版本的值来实现部分持久化，绝不修改历史条目，并在查询时通过二分搜索选择历史值。\n- 每次二分搜索谓词评估精确地计为一次比较；不要进行近似计算。\n\n每个测试用例的答案必须是一个整数列表。最终程序必须以要求的格式生成单行输出，包含由您的实现计算出的八个 $[S,C]$ 序对。", "solution": "用户要求实现一个部分持久化树状数组（也称为二叉索引树或BIT）。我将首先验证问题陈述，然后着手提供一个详尽的、基于原理的解决方案。\n\n### 步骤1：提取给定信息\n\n- **数据结构**：部分持久化树状数组（二叉索引树）。\n- **数组大小 `n`**：$8$。\n- **索引**：问题指定了数组位置 $p \\in \\{1, 2, \\dots, n\\}$ 和前缀索引 $i \\in \\{0, 1, \\dots, n\\}$。为方便起见，树状数组天然使用基于1的索引实现，这与问题对 $p$ 和 $i > 0$ 的规范一致。\n- **初始状态（版本0）**：一个长度为 $n$ 的数组 $A$ 初始化为全零。这意味着树状数组的所有单元格在逻辑时间 $t=0$ 时也都是零。\n- **更新操作**：在逻辑时间 $t$，将一个整数偏移量 $\\Delta$ 加到位置 $p$ 的元素上。这会从版本 $t-1$ 创建版本 $t$。更新仅限于最新版本。\n- **查询操作**：历史版本前缀和查询 $(v, i)$ 要求计算在版本 $v$ 时 $\\sum_{k=1}^{i} A[k]$ 的值。对于 $i=0$，和定义为 $0$。\n- **持久化机制**：每个树状数组索引 $j$ 必须存储一个按时间排序的序对 $(t, \\text{val})$ 序列，代表该树单元格在时间 $t$ 的值。每个索引 $j$ 的初始状态是 $(0, 0)$。更新操作会在受影响索引的序列中追加一个新的 $(t, \\text{val})$ 序对。对版本 $v$ 的查询必须为每个所需索引找到时间戳不晚于 $v$ 的最新值。\n- **值检索**：对于查询 $(v,i)$，查询路径中每个树状数组索引 $j$ 的值，是通过对其按时间排序的序列进行二分搜索，以检索具有最大时间戳 $t \\le v$ 的序对 $(t, \\text{val})$ 中的值来找到的。\n- **监测**：对于每个查询，计算所有二分搜索过程中执行的比较总数。单次比较是指对谓词“当前时间 $\\le v$?”的一次评估。\n- **输出格式**：对于每个查询，输出一个序对 $[S, C]$，其中 $S$ 是和， $C$ 是比较次数。最终输出必须是包含这些序对的单行列表，例如 $[[S_1,C_1],[S_2,C_2],\\dots]$。\n- **更新序列**：\n    1. $t=1$: $p=3, \\Delta=+5$\n    2. $t=2$: $p=5, \\Delta=-2$\n    3. $t=3$: $p=1, \\Delta=+7$\n    4. $t=4$: $p=8, \\Delta=+4$\n    5. $t=5$: $p=3, \\Delta=+3$\n    6. $t=6$: $p=2, \\Delta=-1$\n    7. $t=7$: $p=5, \\Delta=+6$\n    8. $t=8$: $p=7, \\Delta=+2$\n- **查询序列**：\n    1. $(v=0, i=8)$\n    2. $(v=1, i=3)$\n    3. $(v=5, i=5)$\n    4. $(v=7, i=5)$\n    5. $(v=8, i=8)$\n    6. $(v=8, i=0)$\n    7. $(v=5, i=3)$\n    8. $(v=4, i=4)$\n\n### 步骤2：使用提取的给定信息进行验证\n对问题进行严格的验证检查。\n- **有科学依据**：是。该问题描述了一个著名但高级的数据结构，它结合了树状数组和部分持久化的原理。这些是计算机科学和算法领域的标准主题。\n- **定义明确**：是。初始状态、操作、约束和期望输出都被明确规定。测试套件提供了具体的输入，存在唯一的、可计算的解。\n- **客观**：是。问题以精确、正式的语言陈述，不含主观性或个人观点。\n- **缺陷清单**：该问题没有违反任何无效性标准。它科学上合理、可形式化、完整且结构良好。它代表了一个非平凡的算法挑战。\n\n### 步骤3：结论与行动\n问题是 **有效**的。将开始开发解决方案。\n\n### 解决方案设计\n\n解决方案的核心在于设计一个 `PartiallyPersistentFenwickTree` 类，该类封装了所需的状态和操作。\n\n**数据结构**\n一个大小为 $n$ 的数组的树状数组可以用一个大小为 $n+1$ 的数组（或列表）来表示，使用基于1的索引。为了实现所述的部分持久化，这个树状数组的每个元素将不是一个单一的值，而是一个带版本的值的列表。\n- 设 `self.tree` 是一个大小为 $n+1$ 的列表的列表。\n- `self.tree[j]` 将为树状数组索引 $j$ 存储一个按时间排序的元组列表 `(time, value)`。\n- 一个逻辑时间计数器 `self.current_time` 将跟踪当前版本号，从 $0$ 开始。\n\n**初始化**\n构造函数 `__init__(self, size)` 将：\n1.  设置大小，`self.n = size`。\n2.  初始化 `self.current_time = 0`。\n3.  将 `self.tree` 初始化为一个包含 $n+1$ 个空列表的列表。然后，对于从 $1$ 到 $n$ 的每个索引 $j$，用一个初始条目 `(0, 0)` 填充 `self.tree[j]`。这建立了数组全为零的基础版本 $v=0$。\n\n**更新操作**\n方法 `update(self, p, delta)` 将在位置 $p$ 上使用值 $\\Delta$ 执行单点更新：\n1.  增加逻辑时间：`self.current_time += 1`。\n2.  遵循标准的树状数组更新路径。从 `idx = p` 开始。\n3.  当 `idx = self.n` 时：\n    a. 检索树状数组索引 `idx` 的最新值。由于更新总是在最新版本上进行，这个值就是列表 `self.tree[idx]` 中的最后一个。设其值为 `prev_val`。\n    b. 计算新值：`new_val = prev_val + delta`。\n    c. 将新的带版本条目 `(self.current_time, new_val)` 追加到列表 `self.tree[idx]` 中。\n    d. 移动到路径中的下一个索引：`idx += idx  -idx` (其中 `` 是按位与运算符)。\n\n**历史版本查询操作**\n方法 `query(self, version, i)` 将计算截至特定历史版本 $v$ 时索引 $i$ 之前的前缀和。\n1.  处理基本情况：如果 $i = 0$，根据问题定义，返回和为 $0$ 和 $0$ 次比较。\n2.  初始化 `total_sum = 0` 和 `total_comparisons = 0`。\n3.  遵循标准的树状数组查询路径。从 `idx = i` 开始。\n4.  当 `idx > 0` 时：\n    a. 在当前树状数组索引 `idx` 处，找到正确的历史值。这需要在 `self.tree[idx]` 上搜索具有最大时间戳 $t$ 且满足 $t \\le \\text{version}$ 的条目 `(t, val)`。\n    b. 这个搜索将作为一个手动二分搜索来实现，以便精确计数比较次数。二分搜索将在列表 `self.tree[idx]` 上进行。\n        - 设该列表为 `history`。初始化 `low = 0`, `high = len(history) - 1`, `ans_idx = 0`（由于有 `(0,0)` 条目，这个值保证是安全的），以及 `comps = 0`。\n        - 当 `low = high` 时：\n            - `mid = low + (high - low) // 2`。\n            - `comps` 加一。\n            - 如果 `history[mid][0] = version`，它是一个候选答案。存储其索引 `ans_idx = mid` 并搜索更晚的时间：`low = mid + 1`。\n            - 否则，`history[mid][0] > version`。时间太新了。向更早的时间搜索：`high = mid - 1`。\n        - 最终得到的值是 `history[ans_idx][1]`。\n    c. 将找到的值加到 `total_sum`。\n    d. 将二分搜索的比较次数加到 `total_comparisons`。\n    e. 移动到路径中的下一个索引：`idx -= idx  -idx`。\n5.  返回序对 `[total_sum, total_comparisons]`。\n\n此设计正确实现了部分持久化树状数组及其监测的指定逻辑。一次更新的时间复杂度是 $O(\\log n)$，因为它向 $O(\\log n)$ 个列表追加元素。一次查询的复杂度是 $O(\\log n \\cdot \\log M)$，其中 $M$ 是更新次数，因为它在版本条目列表上执行 $O(\\log n)$ 次二分搜索。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass PartiallyPersistentFenwickTree:\n    \"\"\"\n    Implements a partially persistent Fenwick tree (Binary Indexed Tree).\n    \n    This data structure supports point updates on the latest version and historical\n    prefix-sum queries on any past version.\n    \n    Persistence is achieved by storing a time-ordered list of values at each node\n    of the tree, rather than mutating values in place. Historical queries are\n    resolved by performing a binary search on these lists.\n    \"\"\"\n    def __init__(self, size: int):\n        \"\"\"\n        Initializes the persistent Fenwick tree.\n        \n        Args:\n            size: The size of the conceptual array (n). The tree will be of size n+1\n                  to accommodate 1-based indexing.\n        \"\"\"\n        self.n = size\n        self.current_time = 0\n        \n        # self.tree[j] stores a list of (time, value) pairs for Fenwick index j.\n        # We use 1-based indexing for the tree.\n        self.tree = [[] for _ in range(self.n + 1)]\n        \n        # Initialize version 0: all values are 0.\n        for j in range(1, self.n + 1):\n            self.tree[j].append((0, 0))\n\n    def _find_value_at_version(self, tree_idx: int, version: int) -> tuple[int, int]:\n        \"\"\"\n        Finds the value of a tree node at a specific historical version.\n        \n        This is done by binary searching the time-ordered list of values for the\n        given tree index to find the most recent entry at or before the target version.\n        \n        Args:\n            tree_idx: The 1-based index in the Fenwick tree.\n            version: The historical version (logical time) to query.\n            \n        Returns:\n            A tuple (value, comparisons), where 'value' is the historical value and\n            'comparisons' is the count of comparisons made during the binary search.\n        \"\"\"\n        history = self.tree[tree_idx]\n        low, high = 0, len(history) - 1\n        ans_idx = 0  # The initial (0, 0) entry guarantees a valid answer.\n        comparisons = 0\n        \n        while low = high:\n            mid = low + (high - low) // 2\n            mid_time, _ = history[mid]\n            \n            comparisons += 1\n            if mid_time = version:\n                # This is a valid candidate; try to find a more recent one.\n                ans_idx = mid\n                low = mid + 1\n            else:\n                # This entry is too recent; search in the past.\n                high = mid - 1\n                \n        return history[ans_idx][1], comparisons\n\n    def update(self, p: int, delta: int):\n        \"\"\"\n        Applies a point update to the latest version of the array.\n        \n        This creates a new version of the data structure.\n        \n        Args:\n            p: The 1-based position in the conceptual array to update.\n            delta: The value to add at position p.\n        \"\"\"\n        self.current_time += 1\n        idx = p\n        while idx = self.n:\n            # For a partially persistent structure where updates are only on the\n            # latest version, the previous value is always the last one in the list.\n            _, prev_value = self.tree[idx][-1]\n            new_value = prev_value + delta\n            self.tree[idx].append((self.current_time, new_value))\n            \n            # Move to the parent node in the Fenwick tree.\n            idx += idx  -idx\n\n    def query(self, version: int, i: int) -> list[int]:\n        \"\"\"\n        Performs a historical prefix-sum query.\n        \n        Calculates the sum of the first i elements of the array as of the\n        specified version.\n        \n        Args:\n            version: The historical version (logical time) to query.\n            i: The 1-based prefix index. Sum is A[1] + ... + A[i].\n               If i=0, the sum is 0.\n            \n        Returns:\n            A list [S, C], where S is the prefix sum and C is the total number\n            of comparisons performed during the query's binary searches.\n        \"\"\"\n        if i == 0:\n            return [0, 0]\n        \n        total_sum = 0\n        total_comparisons = 0\n        idx = i\n        while idx > 0:\n            value, comps = self._find_value_at_version(idx, version)\n            total_sum += value\n            total_comparisons += comps\n            \n            # Move to the next node in the Fenwick tree's query path.\n            idx -= idx  -idx\n            \n        return [total_sum, total_comparisons]\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test suite and print the results.\n    \"\"\"\n    # Define the problem size, updates, and queries.\n    n = 8\n    updates = [\n        (3, 5),   # t=1\n        (5, -2),  # t=2\n        (1, 7),   # t=3\n        (8, 4),   # t=4\n        (3, 3),   # t=5\n        (2, -1),  # t=6\n        (5, 6),   # t=7\n        (7, 2),   # t=8\n    ]\n    queries = [\n        (0, 8),\n        (1, 3),\n        (5, 5),\n        (7, 5),\n        (8, 8),\n        (8, 0),\n        (5, 3),\n        (4, 4),\n    ]\n\n    # Instantiate and build the persistent Fenwick tree\n    pp_ft = PartiallyPersistentFenwickTree(n)\n    for p, delta in updates:\n        pp_ft.update(p, delta)\n\n    # Execute queries and collect results\n    results = []\n    for v, i in queries:\n        result = pp_ft.query(v, i)\n        results.append(result)\n\n    # Format the output string exactly as required (no spaces).\n    inner_parts = [f\"[{s},{c}]\" for s, c in results]\n    final_output = f\"[{','.join(inner_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3258634"}, {"introduction": "最后，我们将处理一个更具挑战性的问题：实现一个支持路径压缩和按大小合并的持久化并查集（Disjoint Set Union, DSU）。这个练习的精髓在于解决一个核心矛盾：像路径压缩这样的优化本质上是可变的（mutative），而持久化则要求不变性。你将通过“路径复制”（path copying）的策略，在创建新版本时应用优化，同时确保所有历史版本都保持完整和不变。[@problem_id:3258660]", "problem": "要求您设计并实现一个部分持久化的不相交集并（Disjoint Set Union, DSU），也称为并查集（Union-Find）。该数据结构需要支持路径压缩和按秩或大小合并，同时保留以前的版本。其持久化必须是部分持久化的，即任何更新都会创建一个新版本，而不会修改早期的版本。实现必须功能完备，且能作为一个完整的程序运行。\n\n使用的基本原理：\n- DSU 维护一个有限元素集合的划分，将其分为若干不相交的等价类。等价关系满足自反性、对称性和传递性。两个元素当且仅当它们的代表元（根节点）相同时，才属于同一个集合。\n- 按大小（或秩）合并会将较小的树附加到较大的树下，以维持平衡的森林结构并改善时间复杂度。\n- 路径压缩会修改搜索路径上的父指针，使其直接指向根节点，从而降低未来查找操作的成本。\n- 部分持久化可以通过胖节点实现：每个数组单元存储一个更新历史，形式为版本标识符和值的配对；查询时通过搜索此历史记录来检索指定版本的值。\n\n设计约束：\n- 设全集为由整数 $0$到 $n-1$ 索引的元素集合。\n- 版本标识符为整数，从 $0$ 开始，代表每个元素都是单元素集的初始版本。\n- 合并（union）操作接受一个基础版本 $v_{\\text{base}}$ 和两个元素 $a$ 和 $b$，在 $v_{\\text{base}}$ 中计算它们的根（在新创建的版本 $v_{\\text{new}}$ 中应用路径压缩），然后按大小合并这两个集合。如果大小相等，为了确保确定性，将索引较大的根附加到索引较小的根之下。该操作输出新版本的标识符 $v_{\\text{new}}$。\n- 查找（find）操作接受一个版本 $v$ 和一个元素 $x$，返回 $x$ 在版本 $v$ 中的代表元（根）。\n- 连通性查询（connectivity query）接受一个版本 $v$ 和两个元素 $a$ 和 $b$，返回在版本 $v$ 中 $a$ 和 $b$ 是否有相同的代表元。\n- 路径压缩必须只影响新创建的版本；早期的版本必须保持不变。\n\n输入和输出要求：\n- 没有外部输入。您的程序必须构建数据结构并执行指定的操作序列。\n- 所有数值输出必须是整数或布尔值；不涉及物理单位。\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。\n\n测试套件规范：\n- 在版本 $0$ 中初始化一个包含 $n = 8$ 个元素的 DSU。\n- 执行以下操作，其中联合操作通过递增全局版本计数器来创建新版本：\n    1. $v_1 = \\text{union}(0, 0, 1)$。\n    2. $v_2 = \\text{union}(v_1, 2, 3)$。\n    3. $v_3 = \\text{union}(v_2, 1, 3)$。\n    4. 查询 $\\text{connected}(v_3, 0, 3)$，记录布尔值。\n    5. 查询 $\\text{connected}(v_2, 0, 3)$，记录布尔值。\n    6. $v_4 = \\text{union}(v_3, 4, 5)$。\n    7. $v_5 = \\text{union}(v_4, 5, 6)$。\n    8. $v_6 = \\text{union}(v_5, 6, 7)$。\n    9. 查询 $\\text{connected}(v_6, 4, 7)$，记录布尔值。\n    10. 查询 $\\text{connected}(v_3, 7, 4)$，记录布尔值。\n    11. $v_7 = \\text{union}(v_6, 0, 4)$。\n    12. 查询 $\\text{connected}(v_7, 2, 7)$，记录布尔值。\n    13. 查询 $\\text{find}(v_7, 7)$，记录整数代表元。\n    14. $v_8 = \\text{union}(v_7, 3, 7)$。\n    15. 查询 $\\text{connected}(v_8, 1, 6)$，记录布尔值。\n    16. $v_9 = \\text{union}(v_2, 2, 2)$。\n    17. 查询 $\\text{connected}(v_2, 2, 2)$，记录布尔值。\n    18. 查询 $\\text{find}(v_2, 3)$，记录整数代表元。\n- 您的程序必须将所有记录的结果按顺序聚合到一行上输出，格式例如 $[\\text{result}_1,\\text{result}_2,\\dots]$。\n\n正确性期望：\n- 设计必须严格保留旧版本，这意味着在创建版本 $v_{\\text{new}}$ 时执行的任何合并或路径压缩操作都不得改变在任何版本 $v  v_{\\text{new}}$ 中的查找结果。\n- 合并两个不同集合时，必须应用按大小合并以及指定的平局打破规则。\n- 对现有版本执行的查找操作不得在这些版本中压缩路径；只有合并操作通过将路径复制到 $v_{\\text{new}}$ 中来在新版本中创建压缩路径。\n\n您的实现必须是一个完整的、可运行的程序，该程序构建持久化 DSU，执行操作，并按指定格式打印结果。输出值必须仅为布尔值和整数，并且必须严格遵守单行聚合格式要求。", "solution": "问题陈述是有效的。它涉及设计和实现一个部分持久化的不相交集并（DSU）数据结构，这是计算机科学中一个明确定义的主题。其功能需求，包括路径压缩、按大小合并和持久化，都得到了清晰且一致的规定。该问题是自包含的，提供了完整的测试套件和输出格式，使其具有科学依据、问题明确且客观。其中没有矛盾、歧义或违反科学原则之处。\n\n该解决方案通过采用问题描述中建议的“胖节点”技术，实现了一个部分持久化的 DSU。在此模型中，DSU 中元素的每个属性不是单个值，而是随时间变化的值的历史记录。DSU 的状态由一个父节点数组 $parent$ 和一个大小数组 $size$ 定义。对于一个包含 $n$ 个元素（索引为 $0, \\dots, n-1$）的全集，我们维护：\n- $parent$：一个列表的列表，其中 $parent[i]$ 存储元素 $i$ 的父节点的历史记录。\n- $size$：一个列表的列表，其中 $size[i]$ 存储以 $i$ 为根的集合的大小的历史记录。\n\n每个历史列表，例如 $parent[i]$，包含形如 $(v, p)$ 的元组，其中 $v$ 是版本标识符（一个整数），$p$ 是从版本 $v$ 开始元素 $i$ 的父节点。这些历史列表按版本号排序。初始状态（版本 $0$）通过将每个元素设为自己的父节点且大小为 $1$ 来构建：对于每个元素 $i \\in \\{0, \\dots, n-1\\}$，$parent[i] = [(0, i)]$ 且 $size[i] = [(0, 1)]$。\n\n为了在特定版本 $v$ 中检索元素 $i$ 的某个属性（父节点或大小）的值，我们必须找到在版本 $v$ 或之前记录的最新更新。这可以通过在相应的历史列表上使用二分查找来高效完成。具体来说，我们找到最右边的元组 $(v', \\text{val})$ 的索引，使得 $v' \\le v$。此元组的值部分 $\\text{val}$ 即为在版本 $v$ 时的有效值。\n\n操作的实现如下：\n\n1.  $\\text{find}(v, x)$：此操作确定元素 $x$ 在版本 $v$ 中的代表元（根）。这是一个只读查询，不会改变任何版本的状态。其实现通过从 $x$ 开始迭代地跟随父指针直至根节点。在每一步中，它都使用上述的二分查找方法检索当前元素在指定版本 $v$ 的父节点。此过程持续进行，直到找到一个元素是其自身的父节点为止。\n\n2.  $\\text{connected}(v, a, b)$：这是一个直接的查询，返回一个布尔值，指示元素 $a$ 和 $b$ 在版本 $v$ 中是否属于同一个集合。它通过调用 $\\text{find}(v, a)$ 和 $\\text{find}(v, b)$ 并检查它们的结果是否相同来实现。\n\n3.  $\\text{union}(v_{\\text{base}}, a, b)$：这是核心的更新操作。它创建一个新版本 $v_{\\text{new}}$，该版本比最新现有版本大一。过程如下：\n    a. 在 DSU 于 $v_{\\text{base}}$ 的状态下找到元素 $a$ 和 $b$ 的根。在此寻根过程中，记录从 $a$ 和 $b$ 到它们各自根的路径。\n    b. 如果根相同，则元素已在同一集合中。无需合并，操作完成，只是创建了一个新的但在结构上相同的版本 $v_{\\text{new}}$。\n    c. 如果根不同，则执行合并。应用按大小合并的启发式策略。从版本 $v_{\\text{base}}$ 中检索两个集合（以找到的根为根）的大小。较小集合的根（`loser_root`）被附加到较大集合的根（`winner_root`）。问题指定了一个平局打破规则：如果大小相等，则将索引较大的根附加到索引较小的根上。\n    d. 为新版本 $v_{\\text{new}}$ 执行路径压缩。将从 $a$ 和 $b$ 到它们合并前根的路径上的所有节点的父指针更新为直接指向最终的 `winner_root`。这通过向两个路径上每个节点的父节点历史记录中追加一个新的元组 $(v_{\\text{new}}, \\text{winner\\_root})$ 来记录。\n    e. 通过在版本 $v_{\\text{new}}$ 中也将 `loser_root` 的父节点设置为 `winner_root` 来最终完成合并，这同样通过向 $parent[\\text{loser\\_root}]$ 的历史记录中追加 $(v_{\\text{new}}, \\text{winner\\_root})$ 来实现。\n    f. 最后，在版本 $v_{\\text{new}}$ 中将 `winner_root` 集合的大小更新为两个原始集合大小之和。这通过向 $size[\\text{winner\\_root}]$ 的历史记录中追加 $(v_{\\text{new}}, \\text{new\\_size})$ 来记录。\n    g. 返回新版本的标识符 $v_{\\text{new}}$。\n\n此设计严格遵守部分持久化的原则。所有更新都记录在 $v_{\\text{new}}$ 中，使得所有先前的版本 $v  v_{\\text{new}}$ 完全保持不变且可访问。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport bisect\n\nclass PersistentDSU:\n    \"\"\"\n    Implements a partially persistent Disjoint Set Union (DSU) data structure\n    using the \"fat node\" approach, where each node maintains a history of its\n    parent and size across different versions.\n    \"\"\"\n    def __init__(self, n: int):\n        \"\"\"\n        Initializes the DSU with n elements. In version 0, each element\n        is in its own set.\n        \"\"\"\n        self.n = n\n        # Parent history for each element. parent[i] is a list of (version, value).\n        self.parent = [[(0, i)] for i in range(n)]\n        # Size history for each element. Only meaningful for roots.\n        self.size = [[(0, 1)] for i in range(n)]\n        # The latest version number created. Starts at 0.\n        self.latest_version = 0\n\n    def _get_value_at_version(self, history: list, version: int) -> int:\n        \"\"\"\n        Retrieves the value from a history list for a specific version\n        using binary search.\n        \"\"\"\n        # bisect_right finds an insertion point which comes after (to the right of)\n        # any existing entries of (version, ...). idx-1 gives the last entry\n        # with version = the query version.\n        idx = bisect.bisect_right(history, (version, float('inf')))\n        return history[idx - 1][1]\n\n    def _find_path_and_root(self, version: int, i: int) -> tuple[int, list[int]]:\n        \"\"\"\n        Finds the root of element i at a given version and records the path.\n        This is a helper for both find() and union(). It does not perform mutations.\n        \"\"\"\n        path = []\n        current_node = i\n        while True:\n            parent_node = self._get_value_at_version(self.parent[current_node], version)\n            if current_node == parent_node:\n                break\n            path.append(current_node)\n            current_node = parent_node\n        root = current_node\n        return root, path\n\n    def find(self, version: int, i: int) -> int:\n        \"\"\"\n        Finds the representative (root) of element i at a given version.\n        This is a read-only operation.\n        \"\"\"\n        root, _ = self._find_path_and_root(version, i)\n        return root\n\n    def connected(self, version: int, a: int, b: int) -> bool:\n        \"\"\"\n        Checks if elements a and b are in the same set at a given version.\n        \"\"\"\n        return self.find(version, a) == self.find(version, b)\n\n    def union(self, base_version: int, a: int, b: int) -> int:\n        \"\"\"\n        Performs a union of the sets containing a and b, based on the state at\n        base_version. This creates a new version.\n        \"\"\"\n        new_version = self.latest_version + 1\n        self.latest_version = new_version\n\n        root_a, path_a = self._find_path_and_root(base_version, a)\n        root_b, path_b = self._find_path_and_root(base_version, b)\n\n        if root_a != root_b:\n            size_a = self._get_value_at_version(self.size[root_a], base_version)\n            size_b = self._get_value_at_version(self.size[root_b], base_version)\n\n            if size_a  size_b:\n                winner_root, loser_root = root_b, root_a\n            elif size_b  size_a:\n                winner_root, loser_root = root_a, root_b\n            else:  # Equal sizes, use tie-breaker\n                if root_a  root_b:\n                    winner_root, loser_root = root_a, root_b\n                else:\n                    winner_root, loser_root = root_b, root_a\n\n            # Path compression for the new version: all nodes on the paths point to the final winner root.\n            for node in path_a:\n                self.parent[node].append((new_version, winner_root))\n            for node in path_b:\n                self.parent[node].append((new_version, winner_root))\n\n            # Union: point loser root to winner root in the new version.\n            self.parent[loser_root].append((new_version, winner_root))\n\n            # Update size of the winner root in the new version.\n            self.size[winner_root].append((new_version, size_a + size_b))\n        \n        # A new version is created even if the elements are already in the same set.\n        return new_version\n\ndef solve():\n    \"\"\"\n    Executes the specified test suite for the PersistentDSU.\n    \"\"\"\n    dsu = PersistentDSU(n=8)\n    results = []\n    \n    # The version numbers are returned by union operations and stored in variables\n    # v1, v2, ... corresponding to the problem description.\n    # Version 0 is the initial state.\n    \n    # 1. v1 = union(0, 0, 1)\n    v1 = dsu.union(0, 0, 1)\n    \n    # 2. v2 = union(v1, 2, 3)\n    v2 = dsu.union(v1, 2, 3)\n    \n    # 3. v3 = union(v2, 1, 3)\n    v3 = dsu.union(v2, 1, 3)\n    \n    # 4. Query connected(v3, 0, 3)\n    results.append(dsu.connected(v3, 0, 3))\n    \n    # 5. Query connected(v2, 0, 3)\n    results.append(dsu.connected(v2, 0, 3))\n    \n    # 6. v4 = union(v3, 4, 5)\n    v4 = dsu.union(v3, 4, 5)\n    \n    # 7. v5 = union(v4, 5, 6)\n    v5 = dsu.union(v4, 5, 6)\n    \n    # 8. v6 = union(v5, 6, 7)\n    v6 = dsu.union(v5, 6, 7)\n    \n    # 9. Query connected(v6, 4, 7)\n    results.append(dsu.connected(v6, 4, 7))\n    \n    # 10. Query connected(v3, 7, 4)\n    results.append(dsu.connected(v3, 7, 4))\n    \n    # 11. v7 = union(v6, 0, 4)\n    v7 = dsu.union(v6, 0, 4)\n    \n    # 12. Query connected(v7, 2, 7)\n    results.append(dsu.connected(v7, 2, 7))\n    \n    # 13. Query find(v7, 7)\n    results.append(dsu.find(v7, 7))\n    \n    # 14. v8 = union(v7, 3, 7)\n    v8 = dsu.union(v7, 3, 7)\n    \n    # 15. Query connected(v8, 1, 6)\n    results.append(dsu.connected(v8, 1, 6))\n    \n    # 16. v9 = union(v2, 2, 2)\n    v9 = dsu.union(v2, 2, 2)\n    \n    # 17. Query connected(v2, 2, 2)\n    results.append(dsu.connected(v2, 2, 2))\n    \n    # 18. Query find(v2, 3)\n    results.append(dsu.find(v2, 3))\n\n    # Convert boolean True/False to lowercase \"true\"/\"false\" if needed,\n    # but standard str() gives \"True\"/\"False\" which is also common. Sticking to standard.\n    # The requirement is a list of results, so Python's default string conversion is fine.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3258660"}]}