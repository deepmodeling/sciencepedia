{"hands_on_practices": [{"introduction": "“寻找下一个更大元素”是单调栈/队列最经典、最基础的应用。这个练习将帮助你掌握如何通过单次遍历，高效地为数组中的每个元素找到其左侧和右侧最近的严格大于它的元素。这个技巧是许多更复杂问题的基石，通过解决这个问题 [@problem_id:3253891]，你将为后续的挑战打下坚实的基础。", "problem": "给定一个长度为 $n$ 的整数序列 $A = [a_0, a_1, \\dots, a_{n-1}]$，使用从 $0$ 开始的索引。对于每个位置 $i$ ($0 \\le i  n$)，定义两个量：左侧最近的严格大于的元素和右侧最近的严格大于的元素。更精确地说，位置 $i$ 左侧最近的严格大于的元素是索引 $j$，满足 $0 \\le j  i$、$a_j > a_i$ 且 $i - j$ 最小；如果不存在这样的 $j$，则位置 $i$ 左侧的输出为 $-1$。类似地，位置 $i$ 右侧最近的严格大于的元素是索引 $k$，满足 $i  k \\le n-1$、$a_k > a_i$ 且 $k - i$ 最小；如果不存在这样的 $k$，则位置 $i$ 右侧的输出为 $-1$。您的任务是编写一个完整的、可运行的程序，对于下面测试套件中的每个数组，计算出两个列表：所有位置 $i$ 的左侧最近严格大于元素索引的列表，以及所有位置 $i$ 的右侧最近严格大于元素索引的列表。\n\n基本原理：使用双端队列（deque）的核心定义，即一个支持在两端进行插入和移除同时保持顺序的序列，并利用单调数据结构在推入和弹出操作下保持非递增或非递减顺序的标准不变量。从这些定义出发，推导出一种对每个数组都以 $\\mathcal{O}(n)$ 时间运行的算法，而无需提供任何快捷公式。\n\n用于评估您程序的测试套件：\n- 案例 1：$$A_1 = [3,7,1,7,8,4]$$\n- 案例 2：$$A_2 = [1,2,3,4]$$\n- 案例 3：$$A_3 = [9,7,5,3,1]$$\n- 案例 4：$$A_4 = [5,5,5,5]$$\n- 案例 5：$$A_5 = [10]$$\n- 案例 6：$$A_6 = [2,1,2,1,2]$$\n\n输出规范：\n- 对于每个案例 $A_t$，输出一个列表对 $[L_t, R_t]$，其中 $L_t$ 包含所有位置 $i$ 左侧最近的严格大于元素的索引，而 $R_t$ 包含所有位置 $i$ 右侧最近的严格大于元素的索引。如果某个位置 $i$ 的一侧不存在严格大于的元素，则在相应列表的该位置使用 $-1$。\n- 您的程序应生成单行输出，其中包含六个案例的结果，结果为逗号分隔的列表，并用方括号括起来，不含空格。例如，一个有效的格式是 $[[L_1,R_1],[L_2,R_2],\\dots,[L_6,R_6]]$。\n\n所有答案均为整数索引列表。不涉及物理单位、角度单位或百分比。请确保算法设计具有普适性，并从单调数据结构的不变量和定义中逻辑地推导出来。", "solution": "该问题经评估有效。它是一个定义明确、自成体系且客观的算法任务，植根于计算机科学的原理之中。它没有科学上的不健全性、歧义和矛盾之处。\n\n任务是为序列 $A = [a_0, a_1, \\dots, a_{n-1}]$ 中的每个元素找到其左侧和右侧最近的严格大于的元素。我们需要基于双端队列（deque）和单调数据结构的基本性质，推导出一个时间复杂度为 $\\mathcal{O}(n)$ 的算法。\n\n让我们首先将两个子问题形式化：\n1.  **左侧最近更大值 (NGL)**：对于每个索引 $i \\in [0, n-1]$，找到一个索引 $j$，使得 $j  i$，$a_j > a_i$，并且距离 $i-j$ 最小化。如果不存在这样的 $j$，结果为 $-1$。\n2.  **右侧最近更大值 (NGR)**：对于每个索引 $i \\in [0, n-1]$，找到一个索引 $k$，使得 $k > i$，$a_k > a_i$，并且距离 $k-i$ 最小化。如果不存在这样的 $k$，结果为 $-1$。\n\n这两个问题是对称的。我们可以为 NGL 推导出一个解决方案，然后反向应用相同的逻辑来解决 NGR。\n\n### NGL 算法的推导\n\n一种为每个元素 $a_i$ 寻找 NGL 的朴素方法是扫描其左侧的所有元素，从 $j=i-1$ 向下到 $0$。第一个满足 $a_j > a_i$ 的 $j$ 就是答案。这需要一个嵌套循环结构，导致最坏情况下的时间复杂度为 $\\mathcal{O}(n^2)$，例如当输入数组按升序排序时。这种方法效率低下，不满足问题的性能要求。\n\n为了实现 $\\mathcal{O}(n)$ 的解法，我们必须在单次遍历中处理数组。让我们从左到右遍历数组，从 $i=0$ 到 $n-1$。在每一步 $i$，我们需要高效地在元素 $[a_0, a_1, \\dots, a_{i-1}]$ 中找到 $a_i$ 的 NGL。\n\n考虑 $a_i$ 左侧的元素集合。并非所有元素都是未来元素的 NGL 的可行候选者。假设我们有两个索引 $p$ 和 $q$，使得 $p  q  i$。如果 $a_p \\le a_q$，那么对于任何未来的元素 $a_k$（其中 $k > i$），$a_p$ 永远不可能是其 NGL。这是因为如果 $a_p$ 是一个潜在的候选者（即 $a_p > a_k$），那么 $a_q$ 也必定是一个候选者（$a_q \\ge a_p > a_k$），并且由于 $q$ 比 $p$ 更接近 $k$，$a_q$ 将被优先选择。因此，$a_p$ 被 $a_q$ “阻挡”了，可以从我们的潜在 NGL 候选者集合中丢弃。\n\n这个观察导出了一个关键的不变量：当从左到右读取时，对应于有用的 NGL 候选者的索引集合，必须对应一个严格递减的值序列。让这些候选索引存储在一个序列 $s = [j_1, j_2, \\dots, j_m]$ 中，其中 $j_1  j_2  \\dots  j_m  i$。为了使这个集合有用，它必须满足 $a_{j_1} > a_{j_2} > \\dots > a_{j_m}$。这就是**单调递减栈**的定义属性。\n\n将双端队列用作栈，是维护此候选索引序列的理想数据结构。当我们处理一个新元素 $a_i$ 时，我们执行以下步骤：\n\n1.  **维护单调不变量**：我们查看栈顶的索引 $j$。如果 $a_j \\le a_i$，那么 $a_j$ 不可能是 $a_i$ 的 NGL（因为它不是严格更大），也不可能是任何未来元素的 NGL，因为 $a_i$ 更近且值至少一样大。因此，我们可以将 $j$ 从栈中弹出。我们重复这个过程，直到栈为空或栈顶元素严格大于 $a_i$。\n\n2.  **寻找 NGL**：在步骤 1 之后，栈的状态得以确定。\n    *   如果栈现在为空，则意味着 $a_i$ 左侧没有任何元素严格大于它。$a_i$ 的 NGL 是 $-1$。\n    *   如果栈不为空，顶部的索引 $j$ 是 $i$ 左侧第一个满足 $a_j > a_i$ 的元素。由于我们按递增顺序处理索引，这个 $j$ 保证是最近的一个。所以，$a_i$ 的 NGL 是栈顶的索引。\n\n3.  **添加当前元素**：我们将当前索引 $i$ 推入栈中。这使得 $a_i$ 成为后续元素的 NGL 候选者。由于其左侧所有较小的元素都已被移除，不变量得以维持。\n\n每个索引都只被推入栈一次，最多被弹​​出一次。因此，栈操作的总数与 $n$ 成正比，使得整个遍历的摊销时间复杂度为 $\\mathcal{O}(n)$。\n\n### NGR 算法的推导\n\nNGR 问题是 NGL 问题的一个镜像。我们可以通过应用完全相同的单调栈逻辑来找到所有元素的 NGR，但需要从右到左遍历数组（即从 $i=n-1$ 向下到 $0$）。逻辑保持不变：对于每个 $a_i$，我们从栈中弹出所有对应于小于或等于 $a_i$ 的值的索引。栈顶剩下的元素（如果有的话）就是 NGR。\n\n### 完整算法\n\n最终算法包括对输入数组的两次独立遍历，每次遍历耗时 $\\mathcal{O}(n)$。\n\n**第 1 遍：左侧最近更大值 (NGL)**\n1.  初始化一个空的双端队列/栈 `s`，用于存储索引。\n2.  初始化一个大小为 $n$ 的结果数组 $L$。\n3.  使用索引 $i$ 从 $0$ 遍历到 $n-1$：\n    a. 当 `s` 不为空且 $a_{\\text{s.top()}} \\le a_i$ 时，从 `s` 中弹出。\n    b. 如果 `s` 不为空，则设置 $L[i] = \\text{s.top()}$，否则设置 $L[i] = -1$。\n    c. 将 $i$ 推入 `s`。\n\n**第 2 遍：右侧最近更大值 (NGR)**\n1.  清空双端队列/栈 `s`。\n2.  初始化一个大小为 $n$ 的结果数组 $R$。\n3.  使用索引 $i$ 从 $n-1$ 遍历到 $0$：\n    a. 当 `s` 不为空且 $a_{\\text{s.top()}} \\le a_i$ 时，从 `s` 中弹出。\n    b. 如果 `s` 不为空，则设置 $R[i] = \\text{s.top()}$，否则设置 $R[i] = -1$。\n    c. 将 $i$ 推入 `s`。\n\n列表对 $[L, R]$ 就是输入数组 $A$ 的解。总时间复杂度为 $\\mathcal{O}(n) + \\mathcal{O}(n) = \\mathcal{O}(n)$，栈和结果数组所需的空间复杂度为 $\\mathcal{O}(n)$。该设计具有普适性，并且是直接从单调数据结构的不变量推导出来的。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the nearest strictly greater element problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        [3, 7, 1, 7, 8, 4],       # Case 1\n        [1, 2, 3, 4],             # Case 2\n        [9, 7, 5, 3, 1],          # Case 3\n        [5, 5, 5, 5],             # Case 4\n        [10],                     # Case 5\n        [2, 1, 2, 1, 2],          # Case 6\n    ]\n\n    def compute_nearest_greater_elements(arr):\n        \"\"\"\n        Computes the nearest strictly greater element to the left (NGL) and right (NGR)\n        for each element in the input array using a monotonic stack.\n\n        The algorithm performs two passes, one left-to-right for NGL and one\n        right-to-left for NGR. Each pass has an O(n) time complexity.\n\n        Args:\n            arr (list): The input list of integers.\n\n        Returns:\n            list: A pair of lists, [left_results, right_results], where\n                  left_results contains NGL indices and right_results contains\n                  NGR indices.\n        \"\"\"\n        n = len(arr)\n        if n == 0:\n            return [[], []]\n\n        # Initialize result arrays with -1\n        left_greater = np.full(n, -1, dtype=int)\n        right_greater = np.full(n, -1, dtype=int)\n\n        # Using a standard list as a stack to store indices\n        stack = []\n\n        # Pass 1: Left-to-Right for Nearest Greater to the Left (NGL)\n        for i in range(n):\n            # While stack is not empty and the element at the index on top of the stack\n            # is less than or equal to the current element, pop from the stack.\n            # This maintains the monotonic (strictly decreasing) property of the\n            # values corresponding to the indices in the stack.\n            while stack and arr[stack[-1]] = arr[i]:\n                stack.pop()\n            \n            # If the stack is not empty after popping, the index at the top is the NGL.\n            if stack:\n                left_greater[i] = stack[-1]\n            \n            # Push the current index onto the stack for future comparisons.\n            stack.append(i)\n\n        # Clear the stack for the second pass\n        stack.clear()\n\n        # Pass 2: Right-to-Left for Nearest Greater to the Right (NGR)\n        # The logic is symmetric to the first pass.\n        for i in range(n - 1, -1, -1):\n            while stack and arr[stack[-1]] = arr[i]:\n                stack.pop()\n            \n            if stack:\n                right_greater[i] = stack[-1]\n            \n            stack.append(i)\n            \n        return [left_greater.tolist(), right_greater.tolist()]\n\n    all_results_str = []\n    for case_array in test_cases:\n        # Compute the result pair [L, R]\n        result_pair = compute_nearest_greater_elements(case_array)\n        \n        # Manually format the output strings to avoid spaces, as per the specification.\n        # Format the list of left indices, e.g., \"[-1,-1,1,-1,-1,4]\"\n        left_str = f\"[{','.join(map(str, result_pair[0]))}]\"\n        # Format the list of right indices, e.g., \"[1,4,3,4,-1,-1]\"\n        right_str = f\"[{','.join(map(str, result_pair[1]))}]\"\n        \n        # Combine into the final string for one case, e.g., \"[[-1,-1,1,-1,-1,4],[1,4,3,4,-1,-1]]\"\n        pair_str = f\"[{left_str},{right_str}]\"\n        all_results_str.append(pair_str)\n\n    # Join all case results into a single line, e.g., \"[[...],[...],...]\"\n    final_output = f\"[{','.join(all_results_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3253891"}, {"introduction": "这个练习展示了如何将核心技巧应用于更复杂的场景。初看起来，计算所有子数组的最大值之和可能需要暴力求解，但通过转换思路，我们可以巧妙地利用“下一个更大元素”的模式。该练习 [@problem_id:3253905] 的关键在于计算每个元素作为最大值时对总和的贡献，这体现了单调队列在解决计数和求和问题中的威力。", "problem": "给定一个长度为 $n$ 的整数数组 $A$，其中可能包含负值。对于 $A$ 的每个连续子数组 $B$，令 $\\max(B)$ 表示 $B$ 的最大元素。您的任务是计算 $A$ 的所有非空连续子数组 $B$ 的 $\\max(B)$ 之和。如果 $A$ 为空，则总和定义为 $0$。\n\n推理和推导的基本依据：\n- 连续子数组的定义：对于满足 $0 \\le \\ell \\le r  n$ 的整数 $\\ell$ 和 $r$，序列 $A[\\ell], A[\\ell+1], \\dots, A[r]$ 是一个连续子数组。\n- 最大值的定义：对于任何有限整数集合 $S$，值 $\\max(S)$ 是 $S$ 中的唯一元素 $m \\in S$，使得对于所有 $s \\in S$ 都有 $m \\ge s$。\n- 关于双端队列的成熟事实：双端队列（也称为 deque）支持在两端进行插入和删除。单调双端队列会维护其存储索引所关联的值的有序不变量（非递增或非递减），并且在标准的推入-弹出规则下，每个索引最多被插入和移除一次，使得每次操作的均摊时间为 $\\mathcal{O}(1)$，在 $n$ 次操作中的总时间为 $\\mathcal{O}(n)$。\n- 计数原理：如果不相交的组划分了一个有限集，则该集合的总大小等于各组大小之和。\n\n您的程序必须实现一种基于这些基本定义和事实的算法，不依赖任何给定的快捷公式，来推导出一个使用单调双端队列的 $\\mathcal{O}(n)$ 方法，以汇总 $A$ 中每个元素的贡献。\n\n输入和输出由以下测试套件固定。不涉及物理单位或角度。\n\n测试套件：\n为以下每个数组 $A$ 评估所述的总和：\n- 测试 $1$：$[3,1,2,4]$\n- 测试 $2$：$[2,2,2]$\n- 测试 $3$：$[5,4,3,2,1]$\n- 测试 $4$：$[-1,0,-3,2]$\n- 测试 $5$：$[]$\n- 测试 $6$：$[7]$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含测试 $1$ 到 $6$ 的结果，按顺序排列，形式为方括号括起来的逗号分隔列表，不含空格。例如，包含三个结果的输出应如 \"[r1,r2,r3]\"。", "solution": "目标是计算给定整数数组 $A$ 的所有非空连续子数组的最大元素之和。设此总和为 $S$。该问题可正式表述为：\n$$ S = \\sum_{\\ell=0}^{n-1} \\sum_{r=\\ell}^{n-1} \\max(A[\\ell \\dots r]) $$\n其中 $A[\\ell \\dots r]$ 表示从索引 $\\ell$ 到 $r$ 的连续子数组，$n$ 是 $A$ 的长度。\n\n基于此公式的直接计算将涉及遍历所有 $\\mathcal{O}(n^2)$ 个连续子数组，并找到每个子数组的最大值（这可能需要高达 $\\mathcal{O}(n)$ 的时间），导致总体时间复杂度为 $\\mathcal{O}(n^3)$，或优化后为 $\\mathcal{O}(n^2)$。对于大的 $n$ 来说，这是低效的。题目要求 $\\mathcal{O}(n)$ 的解决方案，这表明需要采用不同的方法。\n\n我们可以应用计数原理来重构此问题。与其对子数组求和，不如对 $A$ 的元素求和，计算每个元素对总和的贡献。元素 $A[i]$ 的贡献是 $A[i]$ 乘以 $A[i]$ 作为最大元素的连续子数组的数量。\n$$ S = \\sum_{i=0}^{n-1} A[i] \\cdot (\\text{其中 } A[i] \\text{ 是最大元素的子数组数量}) $$\n\n一个关键问题是如何处理子数组中多个元素共享相同最大值的情况。为确保每个子数组的最大值只被计算一次，我们需要一个一致的平局决胜规则。一个标准的约定是，将子数组中最大值的*第一次*出现指定为其“官方”最大值。\n因此，要使元素 $A[i]$ 成为子数组 $A[\\ell \\dots r]$（其中 $\\ell \\le i \\le r$）的指定最大值，必须满足两个条件：\n1. 对于子数组中的所有其他元素 $A[k]$（即 $k \\in [\\ell, r]$），$A[k] \\le A[i]$。\n2. 对于子数组中 $A[i]$ 左侧的所有元素 $A[k]$（即 $k \\in [\\ell, i-1]$），不等式必须是严格的：$A[k]  A[i]$。\n\n要为固定的索引 $i$ 计算此类子数组的数量，我们需要找到起始索引 $\\ell$ 和结束索引 $r$ 的有效范围。\n条件 $A[k]  A[i]$ (对于所有 $k \\in [\\ell, i-1]$) 意味着子数组不能向左扩展到包含任何满足 $j  i$ 且 $A[j] \\ge A[i]$ 的元素 $A[j]$。设 $p_i$ 是 $i$ 左侧最近的元素索引，使得 $A[p_i] \\ge A[i]$。这是“前一个大于或等于”的元素。如果不存在这样的元素，我们定义 $p_i = -1$。起始索引 $\\ell$ 必须大于 $p_i$，所以 $\\ell \\in [p_i+1, i]$。$\\ell$ 的选择数量为 $i - (p_i+1) + 1 = i - p_i$。\n\n条件 $A[k] \\le A[i]$ (对于所有 $k \\in [i+1, r]$) 意味着子数组不能向右扩展到包含任何满足 $j > i$ 且 $A[j] > A[i]$ 的元素 $A[j]$。设 $q_i$ 是 $i$ 右侧最近的元素索引，使得 $A[q_i] > A[i]$。这是“后一个严格大于”的元素。如果不存在这样的元素，我们定义 $q_i = n$。结束索引 $r$ 必须小于 $q_i$，所以 $r \\in [i, q_i-1]$。$r$ 的选择数量为 $(q_i-1) - i + 1 = q_i - i$。\n\n$A[i]$ 作为指定最大值的子数组总数是 $\\ell$ 和 $r$ 选择数量的乘积，即 $(i - p_i) \\cdot (q_i - i)$。$A[i]$ 对总和的贡献是 $A[i] \\cdot (i - p_i) \\cdot (q_i - i)$。总和为：\n$$ S = \\sum_{i=0}^{n-1} A[i] \\cdot (i - p_i) \\cdot (q_i - i) $$\n\n剩下的任务是在线性时间内计算索引数组 $p$ (PGE) 和 $q$ (NSG)。这是一个单调双端队列（或栈）的经典应用。\n\n**1. 计算“前一个大于或等于”(PGE) 的索引 ($p_i$)：**\n我们从 $i=0$ 到 $n-1$ 遍历，并使用一个栈来存储元素值呈单调递减顺序的索引。\n设 `stack` 是一个用作栈的双端队列。对于每个索引 $i$：\n- 当 `stack` 不为空且 $A[\\text{stack.top()}]  A[i]$ 时，从栈中弹出。被弹出的元素比 $A[i]$ 小且在其左侧，所以它们不可能是 $A[i]$ 或任何后续元素的 PGE。\n- 循环结束后，如果 `stack` 为空，则左侧没有大于或等于 $A[i]$ 的元素，所以 $p_i = -1$。\n- 否则，`stack.top()` 保存了左侧最近的大于或等于 $A[i]$ 的元素的索引，所以 $p_i = \\text{stack.top()}$。\n- 将 $i$ 推入 `stack`。这维持了单调属性。\n\n**2. 计算“后一个严格大于”(NSG) 的索引 ($q_i$)：**\n可以使用类似的单调栈方法。一个巧妙的方法是认识到数组 $A$ 的 NSG 与反转数组 $A^R$ 的“前一个严格大于”(PSG) 相关。\n设 $A^R$ 是反转数组，其中 $A^R[j] = A[n-1-j]$。我们为 $A^R$ 的每个元素计算 PSG。\nPSG 算法与 PGE 算法类似：\n- 设 `stack` 是一个双端队列。对于 $A^R$ 的每个索引 $j=0, \\dots, n-1$：\n- 当 `stack` 不为空且 $A^R[\\text{stack.top()}] \\le A^R[j]$ 时，从栈中弹出。\n- $A^R[j]$ 的 PSG 索引是 `stack.top()`（如果栈不为空），否则为 $-1$。\n- 将 $j$ 推入 `stack`。\n\n设 `psg_R` 是 $A^R$ 的 PSG 索引数组。元素 $A[i]$ 的 NSG 索引 $q_i$ 可以通过映射索引找到。元素 $A[i]$ 对应于 $A^R[n-1-i]$。它在 $A^R$ 中的 PSG 位于某个索引 $j' = \\text{psg\\_R}[n-1-i]$。在原始数组 $A$ 中的对应索引是 $n-1-j'$。如果没有 PSG 存在（即 $j' = -1$），那么 $A[i]$ 也没有 NSG，所以 $q_i = n$。因此，如果 $\\text{psg\\_R}[n-1-i] \\ne -1$，则 $q_i = n-1-\\text{psg\\_R}[n-1-i]$，否则 $q_i = n$。\n\n两次遍历都花费 $\\mathcal{O}(n)$ 时间，因为每个索引最多被推入和弹出一次。最终的求和也是 $\\mathcal{O}(n)$。总时间复杂度为 $\\mathcal{O}(n)$，空间复杂度为 $\\mathcal{O}(n)$（用于辅助数组和栈）。\n\n对于空数组 $A$，$n=0$，总和定义为 $0$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the sum of maximums over all contiguous subarrays for multiple test cases.\n    \"\"\"\n\n    def calculate_sum_of_subarray_maxes(A: list[int]) - int:\n        \"\"\"\n        Computes the sum of max(B) for all contiguous subarrays B of A in O(n) time.\n        \"\"\"\n        n = len(A)\n        if n == 0:\n            return 0\n\n        # 1. Compute `left`: Previous Greater or Equal (PGE)\n        # `left[i]` stores the index of the nearest element to the left of `i`\n        # which is greater than or equal to A[i].\n        left = np.full(n, -1, dtype=np.int64)\n        stack = []  # A list used as a stack, stores indices\n        for i in range(n):\n            while stack and A[stack[-1]]  A[i]:\n                stack.pop()\n            if stack:\n                left[i] = stack[-1]\n            stack.append(i)\n        \n        # 2. Compute `right`: Next Strictly Greater (NSG)\n        # This is equivalent to finding Previous Strictly Greater (PSG) on the reversed array.\n        # `right[i]` stores the index of the nearest element to the right of `i`\n        # which is strictly greater than A[i].\n        right = np.full(n, n, dtype=np.int64)\n        stack = []\n        for i in range(n - 1, -1, -1):\n            while stack and A[stack[-1]] = A[i]:\n                stack.pop()\n            if stack:\n                right[i] = stack[-1]\n            stack.append(i)\n            \n        # 3. Calculate the total sum based on contributions\n        # The contribution of A[i] is A[i] * (number of subarrays where A[i] is the first max).\n        # Number of such subarrays is (i - left[i]) * (right[i] - i).\n        total_sum = 0\n        for i in range(n):\n            count = (i - left[i]) * (right[i] - i)\n            total_sum += A[i] * count\n            \n        return int(total_sum)\n\n    test_cases = [\n        [3, 1, 2, 4],      # Test 1\n        [2, 2, 2],         # Test 2\n        [5, 4, 3, 2, 1],   # Test 3\n        [-1, 0, -3, 2],    # Test 4\n        [],                # Test 5\n        [7]                # Test 6\n    ]\n\n    results = []\n    for A in test_cases:\n        result = calculate_sum_of_subarray_maxes(A)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3253905"}, {"introduction": "准备好迎接一个“逆向工程”的挑战了吗？这个问题将考验你对单调队列工作原理的深层理解。与计算输出不同，我们在这里需要根据滑动窗口每一步的最小值序列来反向推导出一个可能的输入数组 [@problem_id:3253922]。解决这个问题需要你仔细分析数据结构在每一步所施加的约束条件，从而构建出满足所有条件的解。", "problem": "给定一个整数序列，表示在一个固定大小的滑动窗口上，经过每个处理步骤后单调最小队列的队首元素值。单调最小队列是一种标准数据结构，它在每一步通过以非递减顺序存储候选值，并使离开窗口的索引过期，从而维护当前滑动窗口的最小值；其队首元素等于活动窗口的最小值。形式上，假设有一个未知整数数组 $A_0, A_1, \\dots, A_{n-1}$ 和一个固定的窗口大小 $w \\geq 1$。对于每个索引 $i$（$0 \\leq i \\leq n-1$），定义窗口起始位置 $s_i = \\max(0, i - w + 1)$ 和活动窗口 $W_i = \\{A_{s_i}, A_{s_i+1}, \\dots, A_i\\}$。处理索引 $i$ 后，单调最小队列的队首等于 $\\min(W_i)$，我们将其表示为 $m_i$。给定序列 $m_0, m_1, \\dots, m_{n-1}$ 和窗口大小 $w$。您的任务是重构一个长度为 $n$ 的任意整数数组 $A$，使得对于每一个 $i$，等式 $\\min(W_i) = m_i$ 都成立。如果不存在这样的数组，则返回空列表。\n\n使用数据结构和算法中的以下基本定义和事实：\n- 先进先出（FIFO）队列根据进入和离开窗口的索引的过期顺序来维护秩序；单调最小队列维护一个非递减的候选值序列，以使其队首等于窗口最小值。\n- 对于一个整数集合 $S$，最小值由 $\\min(S)$ 定义，并且形式为 $A_j \\geq x$ 的约束会传播到所有包含索引 $j$ 的窗口。\n- 对于每个窗口 $W_i$，所有包含的元素必须满足 $A_j \\geq m_i$（其中 $j \\in [s_i, i]$），并且必须存在至少一个索引 $j \\in [s_i, i]$ 使得 $A_j = m_i$。\n\n从第一性原理出发，推导出一个构造性方法，该方法要么能生成一个有效的数组 $A$，要么能检测到不可能存在的情况。然后实现一个完整、可运行的程序，对下面的测试套件执行此重构，并按指定格式输出结果。\n\n精确定义和约束：\n- 给定 $n$、窗口大小 $w$ 和序列 $m_0, m_1, \\dots, m_{n-1}$，为每个索引 $j$ 定义下界\n$$\n\\mathrm{LB}_j = \\max \\{ m_i \\mid j \\in [s_i, i] \\}.\n$$\n- 任何有效的数组都必须对所有 $j$ 满足 $A_j \\geq \\mathrm{LB}_j$，并且对于每个 $i$，必须存在某个 $j \\in [s_i, i]$ 使得 $A_j = m_i$。如果对于任何 $i$，我们有 $\\min \\{\\mathrm{LB}_{s_i}, \\mathrm{LB}_{s_i+1}, \\dots, \\mathrm{LB}_i\\} > m_i$，则不存在有效数组。\n- 由 $A_j = \\mathrm{LB}_j$ 定义的候选数组在分量序上是最小的，并且它有效的充要条件是对于所有的 $i$，\n$$\n\\min \\{\\mathrm{LB}_{s_i}, \\mathrm{LB}_{s_i+1}, \\dots, \\mathrm{LB}_i\\} = m_i.\n$$\n\n程序要求：\n- 实现一个算法，在给定 $w$ 和序列 $m_0, m_1, \\dots, m_{n-1}$ 的情况下，计算所有 $j$ 的 $\\mathrm{LB}_j$ 并验证上述一致性条件。在你的设计中使用单调队列以达到 $n$ 的线性时间复杂度。\n- 如果一致，输出由 $A_j = \\mathrm{LB}_j$ 定义的重构数组 $A$。如果不一致，输出空列表。\n\n测试套件：\n- 案例 1 (一般成功路径)：$n = 10$，$w = 3$，$m = [4,3,3,2,2,1,1,1,4,4]$。\n- 案例 2 (边界 w=1)：$n = 5$，$w = 1$，$m = [7,3,9,9,2]$。\n- 案例 3 (增长阶段早期不可能的增加)：$n = 4$，$w = 3$，$m = [5,6,5,5]$。\n- 案例 4 (窗口大小大于数组长度)：$n = 5$，$w = 10$，$m = [5,5,3,3,3]$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，每个结果要么是一个整数列表（表示重构的数组），要么是一个空列表（表示不可能）。例如，对于四个测试用例，程序应打印类似 $[\\,[1,2],[],[3],[]\\,]$ 的内容。\n- 不涉及物理单位或角度；所有输出均为整数列表或空列表。", "solution": "我们从滑动窗口和单调最小队列的核心定义开始。在步骤 $i$，活动窗口是 $W_i = \\{A_{s_i}, A_{s_i+1}, \\dots, A_i\\}$，其中 $s_i = \\max(0, i - w + 1)$，单调最小队列的队首等于 $\\min(W_i) = m_i$。该数据结构维护一个非递减的候选值序列，但其本质上的不变量是纯数学的：$W_i$ 中的每个元素必须至少为 $m_i$，并且必须存在至少一个元素等于 $m_i$。\n\n从这些不变量中，我们推导出对每个位置 $j$ 的约束。对于一个索引 $j$，考虑所有包含 $j$ 的窗口，即所有满足 $j \\in [s_i, i]$ 的 $i$。每个这样的窗口都施加了约束 $A_j \\geq m_i$。因此，$A_j$ 的一个聚合下界是\n$$\n\\mathrm{LB}_j = \\max \\{ m_i \\mid j \\in [s_i, i] \\}.\n$$\n任何有效的数组都必须对所有 $j$ 满足 $A_j \\geq \\mathrm{LB}_j$。此外，对于每个窗口 $W_i$，我们必须有\n$$\n\\min \\{A_{s_i}, A_{s_i+1}, \\dots, A_i\\} = m_i.\n$$\n因为对于所有 $j$ 都有 $A_j \\geq \\mathrm{LB}_j$，所以可以得出\n$$\n\\min \\{A_{s_i}, \\dots, A_i\\} \\geq \\min \\{\\mathrm{LB}_{s_i}, \\dots, \\mathrm{LB}_i\\}.\n$$\n如果我们通过 $A_j = \\mathrm{LB}_j$ 来定义一个候选数组，那么在 $A$ 上计算出的窗口最小值将变为\n$$\n\\min \\{ \\mathrm{LB}_{s_i}, \\mathrm{LB}_{s_i+1}, \\dots, \\mathrm{LB}_i \\}.\n$$\n这个最小值不能小于 $m_i$，因为每个 $\\mathrm{LB}_j$ 都是覆盖 $j$ 的窗口最小值的最大值，特别是，对于所有 $j \\in [s_i, i]$ 都有 $\\mathrm{LB}_j \\geq m_i$。因此，\n$$\n\\min \\{ \\mathrm{LB}_{s_i}, \\dots, \\mathrm{LB}_i \\} \\geq m_i.\n$$\n为使候选数组 $A_j = \\mathrm{LB}_j$ 有效，我们必须对所有 $i$ 都有等式成立：\n$$\n\\min \\{ \\mathrm{LB}_{s_i}, \\dots, \\mathrm{LB}_i \\} = m_i.\n$$\n如果对于任何 $i$，这个最小值严格大于 $m_i$，那么该最小值序列与任何可能的数组都不一致，因为即使是最小的可行下界也无法产生低至 $m_i$ 的窗口最小值。\n\n这就得出了一个基于第一性原理的构造性算法：\n- 计算每个 $j$ 的 $\\mathrm{LB}_j$，其值为所有包含 $j$ 的窗口对应的 $m_i$ 的最大值。观察到 $j \\in [s_i,i]$ 当且仅当 $j \\leq i$ 且 $i \\leq j + w - 1$，因此计算 $\\mathrm{LB}_j$ 的相关索引集合为 $i \\in [j, \\min(n-1, j + w - 1)]$。于是，\n$$\n\\mathrm{LB}_j = \\max \\{ m_i \\mid i \\in [j, \\min(n-1, j + w - 1)] \\}.\n$$\n这是一个在序列 $\\{m_i\\}$ 上，窗口宽度为 $w$ 的前向锚定滑动窗口最大值问题。\n- 通过计算每个 $i$ 对应的 $\\{\\mathrm{LB}_{s_i}, \\dots, \\mathrm{LB}_i\\}$ 的最小值，并检查其是否等于 $m_i$ 来验证一致性。这是一个在序列 $\\{\\mathrm{LB}_j\\}$ 上，窗口宽度为 $w$ 的后向滑动窗口最小值问题。\n\n为了在线性时间内实现这些，我们使用单调队列技术：\n- 对于前向锚定滑动最大值 $j \\mapsto \\max \\{ m_j, m_{j+1}, \\dots, m_{\\min(n-1, j+w-1)} \\}$，我们从 $n-1$ 向下扫描到 $0$，并维护一个双端队列，其中存储的索引对应的 $m$ 值非递增，使超出右端点 $\\min(n-1, j+w-1)$ 的索引过期，并确保队首持有当前窗口的最大值。\n- 对于后向滑动最小值 $i \\mapsto \\min \\{\\mathrm{LB}_{s_i}, \\dots, \\mathrm{LB}_i\\}$，我们从 $0$ 向上扫描到 $n-1$，并维护一个双端队列，其中存储的索引对应的 $\\mathrm{LB}$ 值非递减，使早于 $s_i = \\max(0, i-w+1)$ 的索引过期，并确保队首持有当前窗口的最小值。\n\n正确性源于单调队列的不变量：由于单调性和过期规则，队首元素始终等于活动窗口上的极值（最大值或最小值）。聚合下界构造保证了对所有 $j$ 都有 $A_j \\geq \\mathrm{LB}_j$，并且窗口最小值等式 $\\min \\{\\mathrm{LB}_{s_i}, \\dots, \\mathrm{LB}_i\\} = m_i$ 是存在性的充分必要条件。如果检查通过，则候选数组 $A_j = \\mathrm{LB}_j$ 是有效的；否则，没有任何数组能够产生给定的最小值序列。\n\n复杂度分析：由于是线性扫描且双端队列大小有界，两个滑动极值计算都在 $\\mathcal{O}(n)$ 时间和 $\\mathcal{O}(w)$ 空间内运行。因此，重构和验证总共在 $\\mathcal{O}(n)$ 时间和 $\\mathcal{O}(n)$ 空间内运行。\n\n将此方法应用于测试套件：\n- 案例 1，$n=10, w=3, m=[4,3,3,2,2,1,1,1,4,4]$，产生一个一致的重构，例如 $A=[4,3,3,2,2,1,4,4,4,4]$。\n- 案例 2，$n=5, w=1, m=[7,3,9,9,2]$，得出 $A=[7,3,9,9,2]$，因为每个窗口大小为 1。\n- 案例 3，$n=4, w=3, m=[5,6,5,5]$，是不可能的，因为在初始增长阶段（$i  w-1$），窗口最小值不能增加；验证过程会检测到即使是最小下界产生的 $\\min$ 也严格大于 $m_0$。\n- 案例 4，$n=5, w=10, m=[5,5,3,3,3]$，是一致的；一个有效的重构是 $A=[5,5,3,3,3]$。\n\n程序会相应地以指定的单行格式输出重构的数组或空列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef forward_anchor_sliding_max(m, w):\n    \"\"\"\n    Compute LB[j] = max over m[j .. min(n-1, j+w-1)] for all j,\n    using a monotonic decreasing deque scanning from right to left.\n    \"\"\"\n    n = len(m)\n    lb = [0] * n\n    dq = deque()  # store indices with m values in nonincreasing order\n\n    for j in range(n - 1, -1, -1):\n        end = min(n - 1, j + w - 1)\n        # Expire indices beyond the window's right endpoint\n        while dq and dq[0] > end:\n            dq.popleft()\n        # Maintain nonincreasing values: pop smaller or equal from the right\n        while dq and m[dq[-1]] = m[j]:\n            dq.pop()\n        dq.append(j)\n        # Front holds the maximum in [j .. end]\n        lb[j] = m[dq[0]]\n    return lb\n\ndef trailing_sliding_min(arr, w):\n    \"\"\"\n    Compute min over arr[s_i .. i] for each i with s_i = max(0, i-w+1),\n    using a monotonic increasing deque scanning from left to right.\n    \"\"\"\n    n = len(arr)\n    res = [0] * n\n    dq = deque()  # store indices with arr values in nondecreasing order\n\n    for i in range(n):\n        s_i = max(0, i - w + 1)\n        # Expire indices left of the window start\n        while dq and dq[0]  s_i:\n            dq.popleft()\n        # Maintain nondecreasing values: pop larger from the right\n        while dq and arr[dq[-1]] >= arr[i]:\n            dq.pop()\n        dq.append(i)\n        # Front holds the minimum in [s_i .. i]\n        res[i] = arr[dq[0]]\n    return res\n\ndef reconstruct_from_min_queue_fronts(m, w):\n    \"\"\"\n    Given the sequence m (fronts of a monotonic min-queue per step)\n    and window size w, reconstruct a possible array A or return [] if impossible.\n    \"\"\"\n    n = len(m)\n    if w = 0:\n        return []  # invalid window size, treat as impossible\n\n    # Compute LB[j] = max of m over windows that include j\n    lb = forward_anchor_sliding_max(m, w)\n    # Verify that min of LB over each window equals m[i]\n    m_check = trailing_sliding_min(lb, w)\n\n    for i in range(n):\n        if m_check[i] != m[i]:\n            return []  # inconsistent, impossible\n\n    # Candidate reconstruction: A = LB\n    return lb\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: general happy path\n        {\"w\": 3, \"m\": [4,3,3,2,2,1,1,1,4,4]},\n        # Case 2: boundary w = 1\n        {\"w\": 1, \"m\": [7,3,9,9,2]},\n        # Case 3: impossible early increase during growth\n        {\"w\": 3, \"m\": [5,6,5,5]},\n        # Case 4: window size larger than array length\n        {\"w\": 10, \"m\": [5,5,3,3,3]},\n    ]\n\n    results = []\n    for case in test_cases:\n        w = case[\"w\"]\n        m = case[\"m\"]\n        result = reconstruct_from_min_queue_fronts(m, w)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Each result is a list (possibly empty). We print a single line containing the list of results.\n    print(f\"[{','.join(str(r).replace(' ', '') for r in results)}]\")\n\nsolve()\n```", "id": "3253922"}]}