{"hands_on_practices": [{"introduction": "这个练习将堆中节点的总数 $N$ 与构成它的二项树集合直接联系起来。理解这种基于 $N$ 的二进制表示的直接关联，是掌握二项堆性质的第一步。通过这个练习 [@problem_id:3216510]，你将锻炼组合推理能力，并巩固对堆基本结构的理解。", "problem": "二项堆是二项树的森林，其中每棵二项树 $B_{i}$ 有 $2^{i}$ 个节点，且森林中对于每个阶 $i$ 最多只包含一棵树。考虑通过逐个插入 $N$ 个不同的键来构建一个二项堆，使用标准的二项堆插入方法，该方法通过链接来合并同阶的树，并假设不发生删除或键值减小操作。固定一个整数 $k \\geq 3$，并考虑所有满足 $1 \\leq N \\leq 2^{k} - 1$ 的整数 $N$。确定，作为 $k$ 的函数，在这 $N$ 次插入之后，二项堆的根列表中恰好有 $3$ 棵树的此类 $N$ 的数量。将最终答案表示为关于 $k$ 的封闭形式解析表达式。", "solution": "## 问题验证\n\n### 步骤 1：提取已知条件\n- **数据结构：** 二项堆是二项树的森林。\n- **二项树性质：** 阶为 $i$ 的树，记为 $B_i$，有 $2^i$ 个节点。\n- **堆结构性质：** 一个二项堆对于每个阶 $i$ 最多包含一棵树。\n- **操作：** 通过逐个插入 $N$ 个不同的键来构建堆。\n- **插入方法：** 使用通过链接合并同阶树的标准方法。\n- **操作约束：** 不发生删除或 `decrease-key` 操作。\n- **参数：** 固定一个整数 $k \\geq 3$。\n- **$N$ 的范围：** 节点数 $N$ 是一个满足 $1 \\leq N \\leq 2^k - 1$ 的整数。\n- **目标条件：** 生成的二项堆的根列表中必须恰好有 $3$ 棵树。\n- **目标：** 确定在指定范围内满足目标条件的整数 $N$ 的数量，并表示为关于 $k$ 的封闭形式解析函数。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题陈述进行评估：\n\n1.  **科学依据：** 该问题基于二项堆的标准且成熟的理论，这是计算机科学和算法中的一种基本数据结构。所描述的性质（例如，一棵树 $B_i$ 有 $2^i$ 个节点，包含 $N$ 个项的堆的结构）都是教科书上的定义。\n2.  **适定性：** 该问题提供了所有必要信息。定义清晰，$N$ 的范围由 $k$ 精确定义，要满足的条件（恰好 $3$ 棵树）是明确的。问题要求计数，这意味着存在一个唯一的数值答案，该答案是 $k$ 的函数。\n3.  **客观性：** 语言是形式化和客观的。没有主观或基于观点的陈述。\n4.  **无缺陷：**\n    - 它不违反科学原理。\n    - 这是数据结构和算法领域的一个形式化问题，特别与二项堆有关。\n    - 问题设置是完整和一致的。约束条件 $k \\geq 3$ 至关重要，并且已经给出。\n    - 在该数据结构的理论背景下，这些条件并非不切实际或不可行。\n    - 问题结构良好，并导向一个唯一的、有意义的解决方案。\n    - 该问题并非无足轻重；它需要理解二项堆结构的核心性质。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。这是一个关于二项堆性质的、定义明确的组合问题。将提供完整的解答。\n\n## 解答\n\n包含 $N$ 个节点的二项堆的结构由整数 $N$ 的二进制表示唯一确定。具体来说，一个包含 $N$ 个节点的二项堆含有一个阶为 $i$ 的二项树 $B_i$，当且仅当 $N$ 的二进制表示中第 $i$ 位为 $1$。设 $N$ 的二进制表示为 $(c_{m} c_{m-1} \\dots c_1 c_0)_2$，其中 $c_i \\in \\{0, 1\\}$。那么，节点数 $N = \\sum_{i=0}^{m} c_i 2^i$。该堆将由树的集合 $\\{B_i \\mid c_i = 1\\}$ 组成。\n\n因此，二项堆根列表中的树的数量等于森林中二项树的数量。这又等于 $N$ 的二进制表示中 $1$ 的数量。这个量也被称为 $N$ 的人口计数（population count）或汉明权重（Hamming weight）。\n\n问题要求找出使得包含 $N$ 个项的堆恰好有 $3$ 棵树的整数 $N$ 的数量。这等价于找出其二进制表示中恰好包含三个 $1$ 的整数 $N$ 的数量。\n\n问题指定 $N$ 的范围为 $1 \\leq N \\leq 2^k - 1$，其中 $k \\geq 3$ 是一个固定的整数。\n数 $2^k - 1$ 在二进制中表示为连续 $k$ 个 $1$ 的字符串。在范围 $1 \\leq N \\leq 2^k - 1$ 内的任何整数 $N$ 都可以用最多 $k$ 个比特（从比特位置 $0$ 到比特位置 $k-1$）来表示。我们可以将任何这样的 $N$ 的二进制表示看作是一个长度为 $k$ 的二进制字符串，可能带有前导零。例如，如果 $k=5$，数字 $N=7$ 是 $(111)_2$，可以写成 $5$ 位字符串 $(00111)_2$。\n\n因此，问题转化为以下组合问题：在范围 $1 \\leq N \\leq 2^k - 1$ 内有多少个整数 $N$ 的二进制表示中恰好有三个 $1$？\n\n这等价于计算长度为 $k$ 且包含恰好三个 $1$ 的二进制字符串的数量。这 $k$ 个比特的位置对应于二项树的阶，即位置 $0, 1, \\dots, k-1$。要形成一个在其二进制表示中有三个 $1$ 的数，我们必须从 $k$ 个可用的比特位置中恰好选择 $3$ 个位置来放置 $1$。剩下的 $k-3$ 个位置将用 $0$ 填充。\n\n从 $k$ 个不同位置中选择 $3$ 个位置的方法数由二项式系数“k 选 3”给出，记为 $\\binom{k}{3}$。\n\n每个这样的选择都对应一个唯一的整数 $N  2^k$。因为我们选择三个 $1$，所以得到的数 $N$ 将是三个不同 $2$ 的幂之和。当选择最低的三个比特位置（$0$、$1$ 和 $2$）时，出现最小的可能数，即 $N = 2^0 + 2^1 + 2^2 = 1 + 2 + 4 = 7$。由于问题说明 $k \\geq 3$，所以 $N$ 的最小可能值总是 $7$，这满足条件 $N \\geq 1$。因此，所有这些组合都会在指定范围内产生一个有效的 $N$。\n\n此类整数 $N$ 的数量为：\n$$ \\binom{k}{3} $$\n为了将其表示为关于 $k$ 的封闭形式解析表达式，我们展开二项式系数：\n$$ \\binom{k}{3} = \\frac{k!}{3!(k-3)!} = \\frac{k(k-1)(k-2)(k-3)!}{(3 \\cdot 2 \\cdot 1)(k-3)!} $$\n对于 $k \\geq 3$，$(k-3)!$ 项相互抵消，剩下：\n$$ \\frac{k(k-1)(k-2)}{6} $$\n该表达式给出了在范围 $1 \\leq N \\leq 2^k-1$ 内，使得大小为 $N$ 的二项堆恰好有 $3$ 棵树的整数 $N$ 的数量。", "answer": "$$\\boxed{\\frac{k(k-1)(k-2)}{6}}$$", "id": "3216510"}, {"introduction": "在牢固掌握堆的结构之后，我们现在可以着手设计高效的算法。这个问题 [@problem_id:3216453] 挑战你在对数时间 $O(\\log n)$ 内找到第二小元素，这是优先队列的一个经典任务。解决这个问题需要你仔细考虑次小值所有可能的位置，并同时利用最小堆有序属性和根列表的组织方式。", "problem": "一个索引优先队列被实现为二项堆，其键值满足堆序属性（节点的键值大于或等于其父节点的键值）。设该二项堆包含 $n$ 个元素，维护一个指向最小根的直接指针，并支持常规操作，但在查询期间不允许修改数据结构。\n\n根据基本定义：二项堆是一个由二项树 $\\{B_k\\}$ 组成的森林，其中每个 $B_k$ 有 $2^k$ 个节点，其根的度为 $k$。该森林每种阶数的树最多包含一棵，因此根的数量最多为 $\\lfloor \\log_2 n \\rfloor + 1$。在每个具有堆序的二项树中，根键值是其树中最小的，而在最小根所在的树中，除去根之外的最小值必定在根的子节点中，因为任何子节点的所有后代节点的键值都大于或等于该子节点。\n\n选择一个选项，该选项既能正确识别第二小元素必须位于何处，又能在不修改堆的情况下实现最坏情况 $O(\\log n)$ 的时间复杂度：\n\nA. 只检查最小根的子节点，并返回其中最小的一个；这样做是可行的，因为第二小的元素必须在最小根的子节点中，并且根的度最多为 $O(\\log n)$。\n\nB. 只检查除最小根之外的其他根，并返回其中最小的一个；这样做是可行的，因为树中的任何节点都大于或等于其根，并且有 $O(\\log n)$ 个根。\n\nC. 对除最小值之外的 $n-1$ 个元素构建一个临时二叉堆，然后提取其最小值以获得第二小值；这样做是可行的，构建需要 $O(n)$ 时间，提取需要 $O(\\log n)$ 时间。\n\nD. 检查最小根的子节点与所有其他根的并集，并返回该集合中的最小值；这样做是可行的，因为在最小根之外的任何元素至少与其所在树的根一样大，而在最小根的树内的任何元素（不包括根）至少与其对应的子节点一样大；该集合的大小为 $O(\\log n)$。\n\nE. 执行一次 delete-min 操作，使第二小值成为新的最小值，然后记录它并通过重新插入被移除的子树来恢复原始堆；这样做是可行的，delete-min 操作需要 $O(\\log n)$ 时间，外加额外的重新插入成本。", "solution": "问题陈述已经过验证，被认为是表述清晰、科学合理且内部一致的。它描述了一个关于二项堆的标准计算机科学问题。所提供的定义和约束是标准且明确的。\n\n任务是在一个包含 $n$ 个元素、实现为最小堆的二项堆中，在最坏情况 $O(\\log n)$ 的时间内找到第二小的元素，且不修改数据结构。\n\n设该二项堆为 $H$。它是一个满足最小堆属性的二项树森林。问题陈述指出，我们有一个指向具有全局最小键值的根的直接指针。设这个根为 $r_{\\min}$，其键值为 $k_{\\min}$。根据定义，$k_{\\min}$ 是整个堆 $H$ 中最小的键值。\n\n堆中的第二小元素必须有一个大于 $k_{\\min}$ 的键值。要找到这个元素，我们必须识别出所有其键值可能是第二小的潜在候选者。堆中所有节点的集合可以被划分为两个不相交的集合：\n1. 包含最小根 $r_{\\min}$ 的二项树 $T_{\\min}$。\n2. 森林中所有其他二项树的集合，$\\{T_1, T_2, \\dots, T_m\\}$。\n\n第二小的元素必须是排除 $r_{\\min}$ 后的所有节点集合中键值最小的元素。我们可以通过从每个分区中找到最小候选者然后进行比较来找到这个集合的最小值。\n\n来自树 $T_{\\min}$ 的候选集合：\n$T_{\\min}$ 中的节点（不包括根 $r_{\\min}$）是 $r_{\\min}$ 的后代。设 $c_1, c_2, \\dots, c_d$ 为 $r_{\\min}$ 的子节点，其中 $d$ 是 $r_{\\min}$ 的度。由于最小堆属性，对于任何节点 $x$，其键值都大于或等于其父节点的键值。这意味着两件事：\n- 对于 $r_{\\min}$ 的任何子节点 $c_i$，有 $key(c_i) \\ge key(r_{\\min})$。\n- 对于以子节点 $c_i$ 为根的子树中的任何节点 $x$，有 $key(x) \\ge key(c_i)$。\n因此，$r_{\\min}$ 的所有后代中的最小键值必须属于其直接子节点之一。第二小键值的第一个候选集合是 $r_{\\min}$ 的子节点的键值集合。\n\n来自其他树 $\\{T_1, T_2, \\dots, T_m\\}$ 的候选集合：\n设这些其他树的根为 $r_1, r_2, \\dots, r_m$。对于该集合中的任何树 $T_j$，最小堆属性保证其根 $r_j$ 持有该整棵树中的最小键值。因此，所有这些其他树的并集中的最小键值就是它们根的键值的最小值，即 $\\min\\{key(r_1), key(r_2), \\dots, key(r_m)\\}$。第二小键值的第二个候选集合是堆的根列表中所有其他二项树的根的键值集合。\n\n综合这些发现，整个堆中的第二小元素必须是这两个候选集合的并集的最小值：最小根 $r_{\\min}$ 的子节点集合，以及堆的根列表中所有其他根的集合。\n\n让我们分析这种方法的时间复杂度。\n一个包含 $n$ 个元素的二项堆最多由 $\\lfloor \\log_2 n \\rfloor + 1$ 棵二项树组成，即 $O(\\log n)$。所以，根列表中的根总数为 $O(\\log n)$。“其他根”的数量因此也是 $O(\\log n)$。\n在一个包含 $n$ 个元素的二项堆中，一个根的度最多为 $\\lfloor \\log_2 n \\rfloor$。因此，最小根 $r_{\\min}$ 的子节点数量为 $O(\\log n)$。\n需要检查的候选者总数是 $r_{\\min}$ 的子节点数与其他根的数量之和，即 $O(\\log n) + O(\\log n) = O(\\log n)$。\n在一个大小为 $O(\\log n)$ 的集合中找到最小元素需要 $O(\\log n)$ 次比较。这种方法不会改变堆的结构，满足了问题的约束。\n\n现在，我们评估每个选项：\n\nA. 只检查最小根的子节点，并返回其中最小的一个；这样做是可行的，因为第二小的元素必须在最小根的子节点中，并且根的度最多为 $O(\\log n)$。\n这是不正确的。这种方法没有考虑到第二小的元素可能是森林中另一棵二项树的根。例如，在一个包含两棵树的堆中，一棵根为 $1$（子节点为 $10$），另一棵根为 $2$，第二小的元素是 $2$，它不是最小根 $1$ 的子节点。\n\nB. 只检查除最小根之外的其他根，并返回其中最小的一个；这样做是可行的，因为树中的任何节点都大于或等于其根，并且有 $O(\\log n)$ 个根。\n这是不正确的。这种方法没有考虑到第二小的元素可能是最小根的一个子节点。例如，在一个只有一棵树的堆中，根为 $1$，子节点为 $2$，没有其他根。第二小的元素是 $2$，是最小根的一个子节点。\n\nC. 对除最小值之外的 $n-1$ 个元素构建一个临时二叉堆，然后提取其最小值以获得第二小值；这样做是可行的，构建需要 $O(n)$ 时间，提取需要 $O(\\log n)$ 时间。\n这是不正确的。虽然这个算法能正确找到第二小的元素，但其时间复杂度主要由构建临时堆决定，这需要遍历 $n-1$ 个元素，耗时 $O(n)$。题目要求最坏情况时间复杂度为 $O(\\log n)$。\n\nD. 检查最小根的子节点与所有其他根的并集，并返回该集合中的最小值；这样做是可行的，因为在最小根之外的任何元素至少与其所在树的根一样大，而在最小根的树内的任何元素（不包括根）至少与其对应的子节点一样大；该集合的大小为 $O(\\log n)$。\n这是正确的。如上所述，第二小元素的候选集合恰好是最小根的子节点与根列表中所有其他根的并集。这个集合的大小是 $O(\\log n)$，找到最小值需要 $O(\\log n)$ 的时间。这个过程不修改堆。选项中提供的理由也是合理的。\n\nE. 执行一次 `delete-min` 操作，使第二小值成为新的最小值，然后记录它并通过重新插入被移除的子树来恢复原始堆；这样做是可行的，`delete-min` 操作需要 $O(\\log n)$ 时间，外加额外的重新插入成本。\n这是不正确的。问题陈述中明确包含约束：“在查询期间不允许修改数据结构”。`delete-min` 操作从根本上修改了堆的结构。即使堆之后可以被恢复，查询本身也涉及修改，这违反了问题的核心约束。", "answer": "$$\\boxed{D}$$", "id": "3216453"}, {"introduction": "在实际应用中，数据结构可能会因错误操作而损坏。这个动手编码练习 [@problem_id:3216483] 要求你为一个基于指针的二项堆实现一个关键的诊断工具：循环检测器。通过应用深度优先搜索（DFS）等图遍历算法，你将学会如何验证一个复杂的指针数据结构的结构完整性。", "problem": "给定一个数据结构的基于指针的表示，该结构旨在成为一个二项堆。二项堆是一个由二项树组成的森林，其中每棵树的结构定义如下：一棵阶为 $0$ 的二项树（记为 $B_0$）是一个单独的节点；对于任何整数 $k \\ge 1$，一棵阶为 $k$ 的二项树（记为 $B_k$）由一棵二项树 $B_{k-1}$ 连接到另一棵二项树 $B_{k-1}$ 的根作为其子节点而形成。在一个典型的基于指针的表示中，每个节点都有一个键、一个度、一个父指针、一个指向其最左子节点的指针，以及一个指向其同一层级下一个兄弟节点的指针。堆的根列表是通过兄弟指针连接的单向链表。在一个合法的二项堆中，如果只考虑由子指针和兄弟指针构成的有向边，其结构必须是无环的，因为每个组成部分都是一棵树，且根列表是一个简单的链表。\n\n从“树是一个无环连通图”以及“在有向图中检测环可通过探索可达顶点并识别反向边来完成”这两个基本的图论事实出发，设计一个程序化方法，来判断给定的基于指针的结构中是否包含任何仅通过跟踪 `child` 和 `sibling` 指针可达的环。在环检测中不应遍历父指针，因为在遍历子指针的同时遍历父指针，会在任何合法的树中内在地形成一个环。\n\n您的任务是实现一个完整的程序，该程序：\n- 在内存中构建一小组测试堆，每个堆的定义如下所述。\n- 从根列表的头部开始，仅遍历 `child` 和 `sibling` 指针，检测是否存在环。\n- 生成一行输出，其中包含每个测试用例的布尔结果，结果按顺序排列，形式为方括号括起来的逗号分隔列表，并使用小写字面量 $true$ 和 $false$。\n\n使用以下测试套件，其中每个节点名称表示一个不同的节点，所有未指定的指针均为 $None$：\n\n- 测试用例 1（合法结构，无环）：定义节点 $r_1, r_2, r_3, a, b, c$，指针如下。根列表：$r_1.sibling = r_2$, $r_2.sibling = r_3$, $r_3.sibling = None$。子节点：$r_2.child = a$ 且 $a.sibling = None$；$r_3.child = b$ 且 $b.sibling = c$ 以及 $c.sibling = None$。父指针：$a.parent = r_2$, $b.parent = r_3$, $c.parent = r_3$。\n- 测试用例 2（根兄弟节点之间存在环）：定义节点 $u, v$。根列表环：$u.sibling = v$, $v.sibling = u$。\n- 测试用例 3（通过子节点自环形成环）：定义节点 $x$，其 $x.child = x$。\n- 测试用例 4（通过兄弟节点自环形成环）：定义节点 $y$，其 $y.sibling = y$。\n- 测试用例 5（跨两棵树的环）：定义节点 $p, q, m, n$。根列表：$p.sibling = q$, $q.sibling = None$。子节点跨树形成环：$p.child = m$, $m.sibling = q$, $q.child = n$, $n.sibling = p$。\n- 测试用例 6（空堆）：根列表的头部为 $None$。\n- 测试用例 7（单节点堆）：定义节点 $z$，没有子节点也没有兄弟节点。\n\n要求的最终输出格式为单行：\n- 一个用方括号括起来的逗号分隔列表，如果检测到环，则每个条目为 $true$，否则为 $false$。\n- 例如，输出应类似于 $[true,false,\\dots]$，不含任何空格。\n\n您的程序应构建这些精确的结构，并按给定顺序为测试用例输出指定格式的单行结果。", "solution": "该问题要求一种方法来验证旨在成为二项堆的基于指针的数据结构的结构完整性。具体来说，我们必须检测当该结构被视为一个有向图时是否存在任何环，其中边仅由 `child` 和 `sibling` 指针定义。遍历 `parent` 指针是被正确禁止的，因为这样做与 `child` 指针结合，会在任何合法的树结构中轻易地产生环。\n\n此任务的基本原则来自图论。一个合法的二项堆是二项树的森林，而根据定义，树是一个无环连通图。节点的集合以及指定的指针（`child` 和 `sibling`）构成了一个有向图。此图中的环代表了一个结构性缺陷。我们的目标是确定是否存在这样一个从堆的根列表头部可达的环。\n\n在有向图中进行环检测的一个标准且鲁棒的算法是深度优先搜索（DFS）。为此目的使用 DFS 的核心思想是在遍历过程中跟踪每个节点的状态。我们可以将每个节点分为以下三种状态之一：\n1. 未访问（Unvisited）：尚未遇到该节点。\n2. 正在访问（Visiting）：该节点当前位于 DFS 遍历的递归栈中。我们已经从这个节点开始探索，但尚未完成探索其所有后代。\n3. 已访问（Visited）：该节点及其所有后代都已完全探索。\n\n当且仅当 DFS 遇到一个当前处于 `Visiting` 状态的节点时，就检测到了一个环。这样一条从一个节点指向其在 DFS 树中某个祖先的边，被称为反向边。\n\n该算法可以通过一个递归辅助函数来实现，我们可以称之为 `_has_cycle_util`。这个函数将接收当前节点和两个集合 `visiting` 和 `visited`，以维护对应于 `Visiting` 和 `Visited` 分类的状态。\n\n整体流程如下：\n- 定义一个递归函数 `_has_cycle_util(node, visiting, visited)`。\n- `visiting` 集合将存储当前在递归栈中的节点（灰色集合）。\n- `visited` 集合将存储已完全探索的节点（黑色集合）。\n- 递归的基准情形处理终止条件：\n    a. 如果 `node` 是 `None`，则没有路径可以从这里继续，因此沿此路径没有发现环。返回 `false`。\n    b. 如果 `node` 已经在 `visiting` 集合中，我们找到了一个反向边。这确凿地证明了环的存在。返回 `true`。\n    c. 如果 `node` 已经在 `visited` 集合中，说明这个子图已经被探索过并且被发现是无环的。我们可以在这里进行剪枝以避免冗余工作，并返回 `false`。\n- 如果不满足任何基准情形，我们继续对当前 `node` 进行遍历：\n    a. 将 `node` 添加到 `visiting` 集合中，标记它为当前遍历路径的一部分。\n    b. 对节点的每个相关邻居递归调用 `_has_cycle_util`。在这个问题中，邻居是由 `child` 和 `sibling` 指针指向的节点。\n    c. 如果对 `node.child` 的递归调用返回 `true`，则在下游发现了环。我们立即通过返回 `true` 来传播此结果。\n    d. 同样，如果对 `node.sibling` 的递归调用返回 `true`，则发现了环，我们返回 `true`。\n- 如果对所有邻居的递归调用都完成而没有找到环，这表明从当前 `node` 可达的子图是无环的。然后我们执行两个操作：\n    a. 从 `visiting` 集合中移除 `node`，因为它不再处于活跃的递归路径上。\n    b. 将 `node` 添加到 `visited` 集合中，以标记它及其整个可达子图为已完全探索且无环。\n    c. 返回 `false`。\n\n主函数 `detect_cycle` 将初始化空的 `visiting` 和 `visited` 集合，并通过使用根列表的头节点对 `_has_cycle_util` 进行初始调用来启动该过程。由于任何测试用例中描述的整个结构都可以从其头节点通过 `sibling`（用于根列表）和 `child`（用于子树）指针的组合到达，因此单次初始遍历足以探索整个相关图。空堆（其中头节点为 `None`）是一个特殊情况，它会被递归的基准情形正确处理，从而得到 `false` 的返回值。该算法能正确识别所有指定的环类型，从自环到跨越多棵树的复杂环。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    A node in the binomial heap structure. For this problem, only child and\n    sibling pointers are relevant for the cycle detection logic.\n    \"\"\"\n    def __init__(self, name: str):\n        self.name = name\n        self.child = None\n        self.sibling = None\n        # The following attributes are part of a full binomial heap node\n        # but are not used in the cycle detection logic itself.\n        # self.key = None\n        # self.degree = 0\n        # self.parent = None\n\n    def __repr__(self):\n        return f\"Node({self.name})\"\n\ndef _has_cycle_util(node: Node | None, visiting: set, visited: set) - bool:\n    \"\"\"\n    Recursive helper for DFS-based cycle detection.\n\n    Args:\n        node: The current node to visit.\n        visiting: A set of nodes currently in the recursion stack (gray set).\n        visited: A set of nodes that have been fully explored (black set).\n    \n    Returns:\n        True if a cycle is detected, False otherwise.\n    \"\"\"\n    if node is None:\n        return False\n\n    if node in visiting:\n        # A back edge is found, indicating a cycle.\n        return True\n\n    if node in visited:\n        # This node and its descendants have been checked and are acyclic.\n        return False\n\n    # Mark the current node as being visited.\n    visiting.add(node)\n\n    # Recurse on neighbors (child and sibling).\n    if _has_cycle_util(node.child, visiting, visited):\n        return True\n    \n    if _has_cycle_util(node.sibling, visiting, visited):\n        return True\n\n    # Remove node from the recursion stack and mark as fully visited.\n    visiting.remove(node)\n    visited.add(node)\n\n    return False\n\ndef detect_cycle(head: Node | None) - bool:\n    \"\"\"\n    Detects if a cycle exists in the structure reachable from the head node,\n    traversing only child and sibling pointers.\n    \"\"\"\n    visiting = set()\n    visited = set()\n    return _has_cycle_util(head, visiting, visited)\n\ndef solve():\n    \"\"\"\n    Constructs all test cases, runs cycle detection on each, and prints\n    the results in the specified format.\n    \"\"\"\n    # --- Test Case Construction ---\n    \n    # Test case 1 (valid structure, no cycle)\n    r1, r2, r3 = Node('r1'), Node('r2'), Node('r3')\n    a, b, c = Node('a'), Node('b'), Node('c')\n    r1.sibling = r2\n    r2.sibling = r3\n    r2.child = a\n    r3.child = b\n    b.sibling = c\n    head1 = r1\n\n    # Test case 2 (cycle among root siblings)\n    u, v = Node('u'), Node('v')\n    u.sibling = v\n    v.sibling = u\n    head2 = u\n\n    # Test case 3 (cycle via child self-loop)\n    x = Node('x')\n    x.child = x\n    head3 = x\n\n    # Test case 4 (cycle via sibling self-loop)\n    y = Node('y')\n    y.sibling = y\n    head4 = y\n\n    # Test case 5 (cycle across two trees)\n    p, q, m, n = Node('p'), Node('q'), Node('m'), Node('n')\n    p.sibling = q\n    p.child = m\n    m.sibling = q\n    q.child = n\n    n.sibling = p\n    head5 = p\n\n    # Test case 6 (empty heap)\n    head6 = None\n\n    # Test case 7 (single node heap)\n    z = Node('z')\n    head7 = z\n\n    test_heads = [head1, head2, head3, head4, head5, head6, head7]\n    \n    results = []\n    for head in test_heads:\n        has_cycle = detect_cycle(head)\n        results.append(str(has_cycle).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3216483"}]}