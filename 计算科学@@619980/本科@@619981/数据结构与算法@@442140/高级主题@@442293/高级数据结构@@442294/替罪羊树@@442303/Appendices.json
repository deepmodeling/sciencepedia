{"hands_on_practices": [{"introduction": "要掌握替罪羊树，第一步是理解如何识别不平衡的节点。这个练习提供了一个动手编码的挑战，要求你实现这一核心机制。你将把 $\\alpha$-权重平衡的正式定义转化为一个具体的算法，这涉及到计算子树大小并在插入路径上检查平衡条件。这项实践对于掌握替罪羊树如何决定哪部分需要重建至关重要。[@problem_id:3216147]", "problem": "您的任务是实现一个逻辑，用于在一棵刚经历单次插入操作的二叉树中，根据替罪羊树的准则检测不平衡子树。检测必须沿着特定的插入路径进行。请从以下基本定义和事实开始：\n\n- 二叉树是一种数据结构，其中每个节点最多有两个孩子，通常分别称为左孩子和右孩子。\n- 对于任何节点，定义子树大小函数 $s(v)$ 为以节点 $v$ 为根的子树中的节点总数，包括 $v$ 本身。\n- 对于一个满足 $ \\frac{1}{2}  \\alpha  1$ 的实数参数 $\\alpha$，如果节点 $u$ 的左右子树的大小均不超过 $\\alpha \\cdot s(u)$，则该节点被认为是 $\\alpha$-权重平衡的。也就是说，如果用 $L(u)$ 表示 $u$ 的左子树大小，$R(u)$ 表示 $u$ 的右子树大小，那么当 $L(u) \\le \\alpha \\cdot s(u)$ 且 $R(u) \\le \\alpha \\cdot s(u)$ 时，$u$ 是 $\\alpha$-权重平衡的。如果一个节点 $u$ 不是 $\\alpha$-权重平衡的，即 $L(u) > \\alpha \\cdot s(u)$ 或 $R(u) > \\alpha \\cdot s(u)$，则它是一个 $\\alpha$-替罪羊。\n\n您必须实现一个程序，在给定一棵二叉树、一个参数 $\\alpha$ 以及一条以新插入节点为终点的指定插入路径的情况下，从新插入节点的父节点开始沿给定路径向上遍历，检测第一个 $\\alpha$-替罪羊祖先。如果沿此路径没有任何祖先违反 $\\alpha$-权重平衡条件，则返回 $-1$。检测必须基于应用插入操作后精确的子树大小。\n\n程序中要使用的表示细节：\n- 每棵树由一个三元组列表 $(\\text{id}, \\text{left}, \\text{right})$ 指定，其中 $\\text{id}$、$\\text{left}$ 和 $\\text{right}$ 均为整数，$-1$ 表示空孩子。\n- 插入路径以列表 $[p_0, p_1, \\dots, p_k]$ 的形式给出，其中 $p_0$ 是根标识符，$p_k$ 是新插入节点的标识符。插入操作根据一个明确的方向指示符，将 $p_k$ 作为其父节点 $p_{k-1}$ 的左孩子或右孩子附加。\n- 应用插入后，计算从根可达的所有节点的 $s(v)$，并检测路径 $[p_0, p_1, \\dots, p_{k-1}]$ 上满足违规条件 $L(u) > \\alpha \\cdot s(u)$ 或 $R(u) > \\alpha \\cdot s(u)$ 的最深祖先（最接近 $p_k$ 的祖先）。\n\n您的程序必须完全按照规定嵌入并处理以下五个测试用例：\n\n- 测试用例 1：\n  - 节点：$(8, 4, 12)$, $(4, 2, -1)$, $(12, 10, 14)$, $(2, -1, -1)$, $(6, -1, -1)$, $(10, -1, -1)$, $(14, -1, -1)$。\n  - 根节点：$8$。\n  - 参数：$\\alpha = 0.7$。\n  - 插入路径：$[8, 12, 14, 15]$，在父节点 $14$ 处方向为 $R$，意味着将节点 $15$ 作为 $14$ 的右孩子附加。\n  - 预期检测：在插入后计算 $s(v)$，并确定路径上的第一个 $\\alpha$-替罪羊祖先，如果没有则为 $-1$。\n\n- 测试用例 2：\n  - 节点：$(10, 5, -1)$, $(5, 3, -1)$, $(3, -1, -1)$。\n  - 根节点：$10$。\n  - 参数：$\\alpha = 0.6$。\n  - 插入路径：$[10, 5, 3, 2]$，在父节点 $3$ 处方向为 $L$，意味着将节点 $2$ 作为 $3$ 的左孩子附加。\n  - 预期检测：在插入后计算 $s(v)$，并确定路径上的第一个 $\\alpha$-替罪羊祖先，如果没有则为 $-1$。\n\n- 测试用例 3：\n  - 节点：$(50, 40, -1)$, $(40, 30, -1)$, $(30, 20, -1)$, $(20, 10, -1)$, $(10, -1, -1)$。\n  - 根节点：$50$。\n  - 参数：$\\alpha = 0.8$。\n  - 插入路径：$[50, 40, 30, 20, 10, 5]$，在父节点 $10$ 处方向为 $L$，意味着将节点 $5$ 作为 $10$ 的左孩子附加。\n  - 预期检测：在插入后计算 $s(v)$，并确定路径上的第一个 $\\alpha$-替罪羊祖先，如果没有则为 $-1$。\n\n- 测试用例 4：\n  - 节点：$(1, -1, -1)$。\n  - 根节点：$1$。\n  - 参数：$\\alpha = 0.6$。\n  - 插入路径：$[1, 2]$，在父节点 $1$ 处方向为 $L$，意味着将节点 $2$ 作为 $1$ 的左孩子附加。\n  - 预期检测：在插入后计算 $s(v)$，并确定路径上的第一个 $\\alpha$-替罪羊祖先，如果没有则为 $-1$。\n\n- 测试用例 5：\n  - 节点：$(9, 4, 13)$, $(4, -1, 6)$, $(6, 5, 7)$, $(5, -1, -1)$, $(7, -1, -1)$, $(13, -1, -1)$。\n  - 根节点：$9$。\n  - 参数：$\\alpha = 0.6$。\n  - 插入路径：$[9, 4, 6, 7, 8]$，在父节点 $7$ 处方向为 $R$，意味着将节点 $8$ 作为 $7$ 的右孩子附加。\n  - 预期检测：在插入后计算 $s(v)$，并确定路径上的第一个 $\\alpha$-替罪羊祖先，如果没有则为 $-1$。\n\n您的程序应生成单行输出，其中包含五个测试用例的结果，格式为逗号分隔的列表，并用方括号括起，顺序与测试用例相同（例如，$[r_1, r_2, r_3, r_4, r_5]$）。每个 $r_i$ 必须是一个整数，等于检测到的替罪羊节点标识符；如果该用例未检测到替罪羊，则为 $-1$。", "solution": "该问题要求我们根据替罪羊树理论中关于 $\\alpha$-权重平衡的定义，在二叉树的插入路径上识别出第一个“替罪羊”祖先。如果一个节点的某个子树的大小超过其自身总子树大小特定比例 $\\alpha$，该节点就成为替罪羊。\n\n对于每个测试用例，解决方案系统地遵循以下四个主要步骤：\n1.  **树的构建**：相比于所提供的三元组列表，我们使用一种更方便的类图结构在内存中表示树。每个节点都是一个对象，包含其标识符、对其左孩子、右孩子和父节点的引用，以及一个用于存储其子树大小的属性。我们首先从输入列表中创建所有节点对象，并将它们存储在一个将整数标识符映射到对象的字典中。然后，我们再次遍历列表，以在这些对象之间建立父子链接，从而形成以指定根节点为根的完整树结构。\n\n2.  **模拟插入**：问题指定刚刚发生了一次插入。我们通过为插入的元素创建一个新节点，并将其附加到其指定父节点的孩子位置来模拟此过程。父节点是给定插入路径中的倒数第二个节点，附加方向（左或右）已明确提供。新节点的 `parent` 指针也相应设置。\n\n3.  **子树大小计算**：插入后，新插入节点的所有祖先的子树大小都会改变。为确保正确性，我们必须重新计算树中每个节点的大小。节点 $v$ 的子树大小 $s(v)$ 定义为 $1$（节点自身）加上其左右子树的大小：$s(v) = 1 + s(\\text{v.left}) + s(\\text{v.right})$。这个递归定义自然地引导我们使用后序遍历（一种深度优先搜索）来进行计算。该算法在计算一个节点自身的大小之前，会递归地计算其孩子节点的大小。此过程从树的根节点开始，保证了当我们评估一个节点 $v$ 时，其子树中所有节点的大小都已计算并存储完毕。\n\n4.  **替罪羊检测**：核心任务是找到插入节点的第一个违反 $\\alpha$-权重平衡条件的祖先。一个节点 $u$ 是 $\\alpha$-权重平衡的条件是 $L(u) \\le \\alpha \\cdot s(u)$ 且 $R(u) \\le \\alpha \\cdot s(u)$，其中 $L(u)$ 和 $R(u)$ 分别是左右子树的大小。如果 $L(u) > \\alpha \\cdot s(u)$ 或 $R(u) > \\alpha \\cdot s(u)$，则发生违规，使 $u$ 成为替罪羊。\n为了找到“最深”的这样一个祖先（最接近新叶节点的那个），我们向上遍历插入路径，从新添加节点的父节点开始，向根节点移动。插入路径为 $[p_0, p_1, \\dots, p_{k-1}, p_k]$，因此需要检查的祖先路径是 $[p_{k-1}, p_{k-2}, \\dots, p_0]$。对于此路径上的每个祖先 $u$，我们检索其孩子预先计算好的大小 $L(u)$ 和 $R(u)$，以及它自身的大小 $s(u)$。然后我们应用替罪羊测试。沿此向上遍历过程中第一个未通过测试的节点即为所求的替罪羊。如果遍历完成仍未找到任何此类节点，则意味着路径上没有祖先是替罪羊，我们按照题目要求返回 $-1$。\n\n让我们将此逻辑应用于测试用例 2：\n- **给定**：根节点 $10$，$\\alpha = 0.6$，插入路径 $[10, 5, 3, 2]$，方向为 L。\n- **初始树**：一个线性链：$10 \\to 5 \\to 3$。\n- **插入**：节点 $2$ 作为节点 $3$ 的左孩子被附加。树变为 $10 \\to 5 \\to 3 \\to 2$。\n- **大小计算**：后序遍历得出：$s(2) = 1$，$s(3) = 1 + s(2) = 2$，$s(5) = 1 + s(3) = 3$，$s(10) = 1 + s(5) = 4$。\n- **替罪羊检测**：需要自底向上检查的祖先路径是 $[3, 5, 10]$。\n  1.  **检查节点 $3$**：$s(3) = 2$。其左孩子是 $2$，大小为 $L(3) = s(2) = 1$。其右孩子为空，因此 $R(3) = 0$。平衡条件与 $\\alpha \\cdot s(3) = 0.6 \\cdot 2 = 1.2$ 进行比较。由于 $L(3) = 1 \\ngtr 1.2$ 且 $R(3) = 0 \\ngtr 1.2$，节点 $3$ 是平衡的。\n  2.  **检查节点 $5$**：$s(5) = 3$。其左孩子是 $3$，大小为 $L(5) = s(3) = 2$。其右孩子为空，因此 $R(5) = 0$。平衡条件与 $\\alpha \\cdot s(5) = 0.6 \\cdot 3 = 1.8$ 进行比较。此处，$L(5) = 2 > 1.8$。条件被违反。\n- **结果**：节点 $5$ 是遇到的第一个替罪羊。算法终止并返回 $5$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"Represents a node in the binary tree.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.parent = None\n        self.size = 0\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"nodes\": [(8, 4, 12), (4, 2, -1), (12, 10, 14), (2, -1, -1), (6, -1, -1), (10, -1, -1), (14, -1, -1)],\n            \"root\": 8,\n            \"alpha\": 0.7,\n            \"path\": [8, 12, 14, 15],\n            \"side\": 'R'\n        },\n        {\n            \"nodes\": [(10, 5, -1), (5, 3, -1), (3, -1, -1)],\n            \"root\": 10,\n            \"alpha\": 0.6,\n            \"path\": [10, 5, 3, 2],\n            \"side\": 'L'\n        },\n        {\n            \"nodes\": [(50, 40, -1), (40, 30, -1), (30, 20, -1), (20, 10, -1), (10, -1, -1)],\n            \"root\": 50,\n            \"alpha\": 0.8,\n            \"path\": [50, 40, 30, 20, 10, 5],\n            \"side\": 'L'\n        },\n        {\n            \"nodes\": [(1, -1, -1)],\n            \"root\": 1,\n            \"alpha\": 0.6,\n            \"path\": [1, 2],\n            \"side\": 'L'\n        },\n        {\n            \"nodes\": [(9, 4, 13), (4, -1, 6), (6, 5, 7), (5, -1, -1), (7, -1, -1), (13, -1, -1)],\n            \"root\": 9,\n            \"alpha\": 0.6,\n            \"path\": [9, 4, 6, 7, 8],\n            \"side\": 'R'\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(process_case(case))\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\ndef process_case(case_data):\n    \"\"\"\n    Processes a single test case: builds the tree, performs insertion,\n    calculates sizes, and finds the scapegoat.\n    \"\"\"\n    node_list = case_data[\"nodes\"]\n    root_id = case_data[\"root\"]\n    alpha = case_data[\"alpha\"]\n    insertion_path = case_data[\"path\"]\n    insertion_side = case_data[\"side\"]\n\n    nodes = {}\n\n    # First pass: create all node objects\n    all_node_ids = set()\n    for key, left, right in node_list:\n        all_node_ids.add(key)\n        if left != -1: all_node_ids.add(left)\n        if right != -1: all_node_ids.add(right)\n    \n    for key in all_node_ids:\n        if key in nodes: continue\n        nodes[key] = Node(key)\n\n    # Second pass: link nodes\n    for key, left_key, right_key in node_list:\n        node = nodes[key]\n        if left_key != -1:\n            node.left = nodes[left_key]\n            nodes[left_key].parent = node\n        if right_key != -1:\n            node.right = nodes[right_key]\n            nodes[right_key].parent = node\n\n    # Perform insertion\n    parent_key = insertion_path[-2]\n    new_node_key = insertion_path[-1]\n\n    parent_node = nodes[parent_key]\n    new_node = Node(new_node_key)\n    nodes[new_node_key] = new_node\n    new_node.parent = parent_node\n\n    if insertion_side == 'L':\n        parent_node.left = new_node\n    else: # 'R'\n        parent_node.right = new_node\n    \n    # Calculate subtree sizes using post-order traversal (DFS)\n    root_node = nodes[root_id]\n    compute_sizes(root_node)\n\n    # Traverse up the insertion path to find the scapegoat\n    ancestor_path = insertion_path[:-1]\n    scapegoat_id = -1\n\n    for node_key in reversed(ancestor_path):\n        current_node = nodes[node_key]\n        \n        left_size = current_node.left.size if current_node.left else 0\n        right_size = current_node.right.size if current_node.right else 0\n        total_size = current_node.size\n        \n        # Check for alpha-weight-balance violation\n        if left_size  alpha * total_size or right_size  alpha * total_size:\n            scapegoat_id = current_node.key\n            break\n            \n    return scapegoat_id\n\n\ndef compute_sizes(node):\n    \"\"\"\n    Recursively computes the size of the subtree rooted at `node`.\n    Uses post-order traversal logic.\n    \"\"\"\n    if node is None:\n        return 0\n    \n    left_size = compute_sizes(node.left)\n    right_size = compute_sizes(node.right)\n    \n    node.size = 1 + left_size + right_size\n    return node.size\n\nsolve()\n```", "id": "3216147"}, {"introduction": "一个稳健的数据结构不仅要高效处理插入，还必须高效处理删除。这个问题聚焦于替罪羊树的摊还效率，通过考察多次删除后触发重建的规则。你将扮演一个试图强制执行最昂贵操作——即全树重建——的“对手”。这个练习要求你分析条件 $n \\lt \\alpha m$ 以找出触发它的最短操作序列，从而让你对最坏情况分析以及替罪羊树摊还效率保证背后的逻辑有宝贵的见解。[@problem_id:3268410]", "problem": "考虑一个替罪羊树（Scapegoat Tree），它是一种权重平衡二叉搜索树（BST），由一个固定的平衡常数 $\\alpha \\in ( \\frac{1}{2}, 1 )$ 参数化。替罪羊树维护以下不变性和规则：\n\n- 对于任何子树大小为 $s(v)$ 的节点 $v$，权重平衡要求是：对于 $v$ 的每个子节点 $u$，其子树大小满足 $s(u) \\leq \\alpha \\, s(v)$。\n- 每次插入时，一个键作为叶子节点插入，并且在必要时，会确定一个违反条件的祖先节点，并重建其子树以满足权重平衡条件。\n- 每次删除时，树会维护一个变量 $m$，其值等于自上次完全重建以来树所达到的最大大小。删除操作后，如果当前的键数 $n$ 满足 $n  \\alpha \\, m$，则整个树将被重建，并且 $m$ 会被重置为 $n$。\n\n一个对手知道 $\\alpha$ 的值，并且可以从一个空的替罪羊树开始，执行一个由插入和删除组成的操作序列。对手的目标是强制触发一次代价尽可能高的单次重建，这被定义为在树恰好包含 $N$ 个键时重建整个树（即根节点的子树），从而使得重建代价与 $N$ 成正比。\n\n在所有能在树恰好有 $N$ 个键时触发全树重建的对手操作序列中，请确定其最小可能长度，并给出一个关于 $\\alpha$ 和 $N$ 的封闭形式表达式。序列的长度定义为从开始到触发重建的操作（包括该操作）所执行的总操作数（插入和删除的总和）。请以精确形式给出答案，无需进行四舍五入。", "solution": "用户希望找到一个操作序列（包含插入和删除）的最小长度，该序列能强制在一棵替罪羊树的大小恰好变为 $N$ 时触发一次全树重建。\n\n根据问题描述，一次全树重建会在删除操作后被触发，条件是删除后树中的节点数 $n$ 和自上次全树重建以来的最大节点数 $m$ 满足 $n  \\alpha m$。对手的目标是在树的最终大小为 $n=N$ 时触发此事件。因此，该操作序列必须最终导致这样一种状态：一次删除操作使得树的大小变为 $N$，并且满足条件 $N  \\alpha m$。\n\n假设操作序列包含 $I$ 次插入和 $D$ 次删除。序列的总长度为 $L = I + D$。由于树中最终的节点数为 $N$，我们有关系式 $I - D = N$。我们可以用 $I$ 和 $N$ 来表示总长度 $L$：\n$$L = I + D = I + (I - N) = 2I - N$$\n为了最小化长度 $L$，对手必须最小化总插入次数 $I$。\n\n变量 $m$ 跟踪树曾达到的最大大小。为了满足重建条件 $N  \\alpha m$，树必须在某个时刻至少包含 $m$ 个节点。实现这一点的最有效方法是执行插入操作，直到树的大小达到某个峰值，我们将这个峰值设为我们的 $m$。因此，插入次数 $I$ 必须至少为 $m$，即 $I \\ge m$。为了最小化 $I$，对手应该选择可行的最小 $m$ 值，并令 $I=m$。问题因此简化为寻找 $m$ 的最小可行值。\n\n对手最小化操作次数的策略如下：\n1. 执行 $m$ 次插入，使树的大小达到 $n=m$。此时，最大大小变量也是 $m$。尚未发生任何删除操作。\n2. 执行 $m - (N+1)$ 次删除，将树的大小减小到 $N+1$。\n3. 执行最后一次删除，将树的大小从 $N+1$ 减小到 $N$。这最后一次操作必须触发全树重建。\n\n为使此策略成功且操作数最少，必须满足与重建触发相关的两个条件：\na) 最后一次将大小从 $N+1$ 减小到 $N$ 的删除操作必须触发重建。根据规则，这意味着新的大小 $N$ 必须满足：\n$$N  \\alpha m$$\nb) 为了确保这是删除阶段触发的第一次全树重建，之前的删除操作（例如，将大小从 $N+2$ 减小到 $N+1$）必须*不*触发重建。一般而言，任何导致树大小变为 $k > N$ 的删除操作都不应触发重建。其中最严格的约束发生在大小变为 $N+1$ 时。因此，大小为 $N+1$ 的树必须*不*满足重建条件：\n$$N+1 \\ge \\alpha m$$\n\n结合这两个不等式，我们得到整数 $m$ 必须满足的单个条件：\n$$N  \\alpha m \\le N+1$$\n两边同除以 $\\alpha$（因为 $\\alpha \\in (\\frac{1}{2}, 1)$，所以 $\\alpha$ 为正数），我们得到：\n$$\\frac{N}{\\alpha}  m \\le \\frac{N+1}{\\alpha}$$\n区间 $(\\frac{N}{\\alpha}, \\frac{N+1}{\\alpha}]$ 的长度是 $\\frac{N+1}{\\alpha} - \\frac{N}{\\alpha} = \\frac{1}{\\alpha}$。由于 $\\alpha \\in (\\frac{1}{2}, 1)$，我们有 $\\frac{1}{\\alpha} \\in (1, 2)$。一个长度大于 1 的区间保证至少包含一个整数，因此总存在一个满足此条件的整数 $m$。\n\n为了最小化总操作数 $L = 2I - N$，我们必须最小化 $I$。由于最小插入次数为 $I=m$，我们必须找到满足上述推导不等式的最小整数 $m$。严格大于 $\\frac{N}{\\alpha}$ 的最小整数 $m$ 由下式给出：\n$$m_{\\min} = \\left\\lfloor \\frac{N}{\\alpha} \\right\\rfloor + 1$$\n我们已经证明了在所需区间内存在整数 $m$，并且由于此公式给出了大于下界 $\\frac{N}{\\alpha}$ 的最小整数，因此这个 $m_{\\min}$ 必定是最小的有效峰值大小。\n\n因此，最小插入次数为 $I_{\\min} = m_{\\min} = \\lfloor \\frac{N}{\\alpha} \\rfloor + 1$。\n达到最终大小 $N$ 所需的相应删除次数为 $D = I_{\\min} - N = (\\lfloor \\frac{N}{\\alpha} \\rfloor + 1) - N$。\n对手序列的最小总长度为 $L_{\\min} = I_{\\min} + D$。\n$$L_{\\min} = \\left( \\left\\lfloor \\frac{N}{\\alpha} \\right\\rfloor + 1 \\right) + \\left( \\left( \\left\\lfloor \\frac{N}{\\alpha} \\right\\rfloor + 1 \\right) - N \\right)$$\n$$L_{\\min} = 2 \\left( \\left\\lfloor \\frac{N}{\\alpha} \\right\\rfloor + 1 \\right) - N$$\n这就是所需的最少操作次数。对手的序列包括 $I_{\\min}$ 次插入以达到峰值大小 $m_{\\min}$，随后是 $D = m_{\\min} - N$ 次删除。在此过程中，不需要发生由插入触发的全树重建（对手可以选择合适的插入键以保持树的平衡），并且根据我们对 $m_{\\min}$ 的选择，直到最后一次删除操作之前，都不会发生由删除触发的重建。", "answer": "$$\n\\boxed{2 \\left( \\left\\lfloor \\frac{N}{\\alpha} \\right\\rfloor + 1 \\right) - N}\n$$", "id": "3268410"}]}