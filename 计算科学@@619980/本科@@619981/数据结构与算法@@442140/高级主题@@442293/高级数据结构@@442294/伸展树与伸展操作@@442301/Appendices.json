{"hands_on_practices": [{"introduction": "本练习旨在探讨伸展树单次操作的最坏情况性能。虽然伸展树提供了优异的均摊效率，但认识到单次操作的成本可能很高是至关重要的。本练习将指导您构建一个特定的插入序列，该序列将导致树结构退化，然后分析后续单次伸展操作的成本，从而亲身体验这种最坏情况下的行为。[@problem_id:3269554]", "problem": "自平衡二叉搜索树（BST）是一种二叉搜索树，它在操作过程中进行结构性调整，以维持有利的高度界限，而无需在每个节点存储显式的平衡信息。伸展树是一个典型例子：它执行一系列称为“伸展”（splaying）的旋转操作，将被访问的节点移动到根节点。基本操作是单次旋转和三种伸展步骤，这些步骤是针对一个节点 $x$、其父节点 $p$ 和祖父节点 $g$ 定义的：zig（当 $x$ 没有祖父节点时应用），zig-zig（当 $x$ 和 $p$ 同为左孩子或同为右孩子时应用），以及 zig-zag（当 $x$ 和 $p$ 分别位于父节点的两侧时应用）。每次旋转都是一次常数时间的指针重排操作。考虑在伸展树上执行以下操作序列，该伸展树在插入和搜索后使用经典的自底向上伸展方法，并且不包含重复的键：\n\n- 从一棵空树开始。\n- 按严格递减顺序 $N,N-1,\\dots,2,1$ 插入键，每次插入键 $k$ 后，立即对 $k$ 应用伸展操作（这是伸展树插入的标准做法）。\n- 然后搜索键 $N$，并在搜索结束时对 $N$ 应用伸展操作。\n\n请从第一性原理和伸展步骤的定义出发，推导在最后一次对 $N$ 进行搜索和伸展操作期间所执行的单次旋转的确切次数，并将其表示为 $N$ 的函数。将你的最终答案表示为关于 $N$ 的闭式表达式。无需四舍五入，也不涉及单位。你的推导必须从二叉搜索树（BST）的性质和伸展步骤的定义（zig、zig-zig、zig-zag）开始，并且不得借助任何关于伸展树摊还界限的未经证明的捷径。在最后一次搜索之前树的形态的正确性必须使用这些基本操作和BST的顺序性质来证明。最终答案必须是关于 $N$ 的单个解析表达式。", "solution": "问题要求在伸展树中，按照一个特定的插入序列执行操作后，推导在搜索键 $N$ 及后续伸展过程中所执行的单次旋转的确切次数。推导必须从第一性原理出发。\n\n解决方案分为两个主要部分。首先，我们确定在指定的插入序列之后伸展树的精确结构。其次，我们基于此结构分析对 $N$ 的搜索以及对节点 $N$ 的伸展操作，以计算旋转次数。\n\n**第一部分：确定伸展树的结构**\n\n初始状态是一棵空树。按顺序插入键 $N, N-1, \\dots, 2, 1$。每次插入键 $k$ 后，包含 $k$ 的节点会被伸展到根节点。\n\n我们将通过归纳法证明，在插入键 $N, N-1, \\dots, k$（对于 $1 \\le k \\le N$）之后，得到的树是一个以 $k$ 为根的右偏链（“棍状”结构）。树中的节点为 $\\{k, k+1, \\dots, N\\}$，对于该集合中任意满足 $i  N$ 的节点 $i$，其右孩子是 $i+1$，左孩子为空。\n\n**基础情形：** 第一个插入的键是 $N$。\n- 树只包含一个节点 $N$。伸展此节点没有效果，因为它已经是根节点。\n- 树是一个长度为1、根为 $N$ 的右偏链。命题对 $k=N$ 成立。\n\n**归纳假设：** 假设在插入键 $N, N-1, \\dots, k+1$ 后，树是一个以 $k+1$ 为根的右偏链。其结构为：\n$$(k+1) \\rightarrow_R (k+2) \\rightarrow_R \\dots \\rightarrow_R N$$\n其中 $\\rightarrow_R$ 表示一个右孩子链接。\n\n**归纳步骤：** 现在我们插入键 $k$。\n1.  根据二叉搜索树（BST）的性质，要插入 $k$，我们从根节点 $k+1$ 开始。因为 $k  k+1$，我们必须向左走。\n2.  根据归纳假设，根节点 $k+1$ 没有左孩子。因此，新节点 $k$ 作为 $k+1$ 的左孩子被插入。\n3.  在插入之后、伸展 $k$ 之前，树的结构是：根为 $k+1$，其左孩子为 $k$，并保留其原始的右子树。\n4.  下一步是伸展新插入的节点 $k$。节点 $k$ 的父节点是 $p = k+1$。父节点 $p$ 是树的根，所以 $k$ 没有祖父节点。\n5.  根据伸展步骤的定义，当要伸展的节点（$x=k$）有父节点但没有祖父节点时，执行一次 **Zig** 步骤。这包括一次单旋转，使 $x$ 成为新的根节点。\n6.  在本例中，$k$ 是 $k+1$ 的左孩子。对 $k+1$ 和 $k$ 之间的边执行一次右旋转。\n7.  旋转后，$k$ 成为新的根节点。其前父节点 $k+1$ 成为 $k$ 的右孩子。$k$ 原本的右子树（为空）成为 $k+1$ 的左孩子。$k+1$ 原本的右子树保持为其右子树。\n8.  得到的树以 $k$ 为根，其右孩子是 $k+1$，后者的右孩子是 $k+2$，依此类推。其结构为：\n$$k \\rightarrow_R (k+1) \\rightarrow_R (k+2) \\rightarrow_R \\dots \\rightarrow_R N$$\n这是一个以 $k$ 为根的右偏链。归纳完成。\n\n根据这个归纳论证，在插入从 $N$ 到 $1$ 的所有键之后，树的最终结构（对于 $k=1$）是一个以 $1$ 为根的右偏链：\n$$1 \\rightarrow_R 2 \\rightarrow_R 3 \\rightarrow_R \\dots \\rightarrow_R (N-1) \\rightarrow_R N$$\n\n**第二部分：分析最终的搜索和伸展操作**\n\n最终操作是搜索键 $N$，然后将其节点伸展到根节点。\n\n**搜索路径：**\n- 对 $N$ 的搜索从根节点开始，即键为 $1$ 的节点。\n- 因为 $N > 1$，我们遍历到右孩子，即节点 $2$。\n- 因为 $N > 2$，我们遍历到右孩子，即节点 $3$。\n- 这个过程沿着右偏链一直持续，直到我们到达键为 $N$ 的节点。\n- 遍历路径是 $1 \\rightarrow 2 \\rightarrow \\dots \\rightarrow N$。\n- 节点的深度是从根到该节点的路径上的边数。到 $N$ 的路径有 $N-1$ 条边。因此，节点 $N$ 的深度是 $d = N-1$。\n\n**伸展操作：**\n我们现在从深度 $d=N-1$ 的位置伸展节点 $N$。从根到 $N$ 的路径完全由右孩子链接组成。设 $x$ 为被伸展的节点，初始时 $x=N$。\n\n- 每当 $x$ 有一个祖父节点 $g$ 时，其父节点为 $p$。在我们的树中，$x$ 是 $p$ 的右孩子，$p$ 是 $g$ 的右孩子。这种情况需要一个 **Zig-Zig** 步骤。\n- 一个 Zig-Zig 步骤包含两次单旋转。其效果是将 $x$ 在树中向上移动两层，取代其祖父节点。\n\n- 对位于直线路径上深度为 $d$ 的节点进行伸展的过程如下：\n  1.  只要节点有祖父节点，就重复应用 Zig-Zig 步骤。每个 Zig-Zig 步骤消耗 $2$ 次旋转，并将节点的深度减少 $2$。可能执行的 Zig-Zig 步骤数为 $\\lfloor d/2 \\rfloor$。\n  2.  这些步骤的总旋转次数为：$2 \\times \\lfloor d/2 \\rfloor$。\n  3.  这些步骤之后，节点的剩余深度为 $d_{rem} = d - 2 \\times \\lfloor d/2 \\rfloor$。这等价于 $d \\pmod 2$。\n  4.  如果 $d_{rem} = 1$（当且仅当 $d$ 为奇数时发生），节点现在是根节点的一个孩子。它有父节点但没有祖父节点。需要一个最后的 **Zig** 步骤。一个 Zig 步骤消耗 $1$ 次旋转，并使该节点成为根。\n  5.  如果 $d_{rem} = 0$（当且仅当 $d$ 为偶数时发生），节点已经成为根，操作完成。\n\n单次旋转的总次数是所有 Zig-Zig 步骤和最后（可能有的）Zig 步骤的旋转次数之和。\n总旋转次数 $= (2 \\times \\text{Zig-Zig 步骤数}) + (1 \\times \\text{Zig 步骤数})$\n总旋转次数 $= 2 \\times \\lfloor d/2 \\rfloor + (d \\pmod 2)$。\n\n对于任意非负整数 $d$，表达式 $2 \\lfloor d/2 \\rfloor + (d \\pmod 2)$ 恒等于 $d$。\n- 如果 $d$ 是偶数，设 $d=2k$，其中 $k \\ge 0$ 是整数。表达式变为 $2 \\times \\lfloor 2k/2 \\rfloor + (2k \\pmod 2) = 2 \\times k + 0 = 2k = d$。\n- 如果 $d$ 是奇数，设 $d=2k+1$，其中 $k \\ge 0$ 是整数。表达式变为 $2 \\times \\lfloor (2k+1)/2 \\rfloor + ((2k+1) \\pmod 2) = 2 \\times k + 1 = 2k+1 = d$。\n\n因此，将一个位于深度为 $d$ 的直线路径上的节点伸展到根的总旋转次数恰好是 $d$。\n\n在我们的问题中，要伸展的节点是 $N$，其深度为 $d = N-1$。\n将此代入我们的结果，单次旋转的总次数是 $N-1$。\n\n这对所有 $N \\ge 1$ 都成立。\n- 如果 $N=1$，树只有一个节点 $1$。搜索在根处找到它（深度 $d=0$）。旋转次数是 $0$。我们的公式给出 $1-1=0$。\n- 如果 $N>1$，深度 $d=N-1 \\ge 1$，推导出的计数成立。\n\n因此，在最后一次对 $N$ 进行搜索和伸展操作期间所执行的单次旋转的确切次数是 $N-1$。", "answer": "$$\\boxed{N-1}$$", "id": "3269554"}, {"introduction": "本练习在最坏情况场景概念的基础上，进一步深入探讨伸展树操作的基本成本。我们不再仅仅计算旋转次数，而是对 `Delete-Minimum` 操作所需的指针更新总数进行精细分析。通过这个练习，您将更清晰地理解像 `zig` 和 `zig-zig` 这样的伸展步骤在指针层面是如何实现的，以及如何精确量化其计算成本。[@problem_id:3233390]", "problem": "给定一个二叉搜索树（BST），它被实现为一棵伸展树，并具有常规的自底向上伸展操作。每个节点存储三个指针字段：$left$、$right$ 和 $parent$。还有一个外部变量 $root$，它持有指向树根的指针。考虑 Delete-Minimum 操作，该操作删除包含最小键的节点。该实现遵循以下规则：首先通过跟随 $left$ 指针搜索最小值，然后使用仅包含适用于纯 $left$ 边路径的 $zig$ 和 $zig$-$zig$ 步骤的自底向上伸展操作，将该最小节点伸展到根部，最后通过将其右子树替换为根来删除原根节点。\n\n就本问题而言，指针更新被定义为对节点的 $left$、$right$ 或 $parent$ 字段的任何写入，或对外部 $root$ 变量的任何写入。读取不计数，内存释放也不算作指针更新。单次旋转是标准的常数时间 BST 旋转，它仅重新分配必要的 $left$、$right$ 和 $parent$ 指针以保持 BST 不变性。\n\n设操作前最小节点的深度（以边数计）为 $h \\geq 0$。假设子树处于与 BST 不变性和伸展规则一致的最坏情况对抗性排列，并假设自底向上的伸展是通过组合单次旋转实现的（因此一个 $zig$-$zig$ 步骤是两次单次旋转）。\n\n从第一性原理和定义出发，推导在这样的伸展树上执行 Delete-Minimum 操作期间，所执行的指针更新总数的最坏情况下的一个关于 $h$ 的封闭形式表达式。你的最终答案必须是一个关于 $h$ 的单一解析表达式，不含未求值的求和或不等式。不需要四舍五入。", "solution": "我们从二叉搜索树（BST）、伸展树和标准单次旋转的核心定义开始。BST 不变性要求，对于任何节点 $u$，其 $u.left$ 处子树中的所有键都小于 $u$ 处的键，而其 $u.right$ 处子树中的所有键都大于 $u$ 处的键。伸展树使用自底向上的伸展：给定一个目标节点 $x$，根据众所周知的各种情况重复进行旋转，直到 $x$ 成为根。在一条仅由 $left$ 边组成的路径上，只会出现 $zig$（一次右旋）和 $zig$-$zig$（两次连续的右旋）。\n\n我们用指针更新来衡量成本，其中对任何节点的 $left$、$right$ 或 $parent$ 字段的每次赋值，或对外部 $root$ 的每次赋值，都精确地算作 $1$ 次更新。\n\n步骤 $1$：计算将最小节点伸展所需的旋转次数。设最小节点位于深度 $h$ 处，这意味着从根到该节点的唯一路径上有 $h$ 条边。因为该路径仅由 $left$ 边组成，所以使用的伸展情况是：\n- 如果 $h$ 是偶数，例如 $h = 2k$，那么我们执行 $k$ 次连续的 $zig$-$zig$ 步骤，每个步骤是两次单次右旋，总共 $2k = h$ 次单次旋转。\n- 如果 $h$ 是奇数，例如 $h = 2k + 1$，那么我们执行 $k$ 次 $zig$-$zig$ 步骤，然后执行一次 $zig$ 步骤，总共 $2k + 1 = h$ 次单次旋转。\n因此，在所有情况下，将最小值伸展到根部都恰好执行 $h$ 次单次旋转。\n\n步骤 $2$：每次单次旋转的指针更新次数。考虑在节点 $y$ 及其左孩子 $x$ 处进行的一次右旋，其中移动的子树为 $B = x.right$。有两种子情况：\n\n- 如果 $y$ 不是根并且有父节点 $p$：\n  - 更新 $p$ 的相应子指针指向 $x$：$p.left \\leftarrow x$ 或 $p.right \\leftarrow x$（$1$ 次更新）。\n  - 设置 $x.parent \\leftarrow p$（$1$ 次更新）。\n  - 设置 $y.parent \\leftarrow x$（$1$ 次更新）。\n  - 使 $x$ 将 $y$ 作为其右孩子：$x.right \\leftarrow y$（$1$ 次更新）。\n  - 使 $y$ 将 $B$ 作为其左孩子：$y.left \\leftarrow B$（$1$ 次更新）。\n  - 如果 $B \\neq \\varnothing$，设置 $B.parent \\leftarrow y$（$1$ 次更新）。\n\n- 如果 $y$ 是根：\n  - 更新 $root \\leftarrow x$（$1$ 次更新）。\n  - 设置 $x.parent \\leftarrow \\varnothing$（$1$ 次更新）。\n  - 设置 $y.parent \\leftarrow x$（$1$ 次更新）。\n  - 设置 $x.right \\leftarrow y$（$1$ 次更新）。\n  - 设置 $y.left \\leftarrow B$（$1$ 次更新）。\n  - 如果 $B \\neq \\varnothing$，设置 $B.parent \\leftarrow y$（$1$ 次更新）。\n\n在这两种子情况中，旋转无条件地执行恰好 $5$ 次指针更新，并且当且仅当 $B \\neq \\varnothing$ 时，会额外增加 $1$ 次指针更新。对于左旋，也存在类似的计数。\n\n沿着最小值的纯 $left$ 路径，每次单次旋转都是一次右旋，其 $B$ 是旋转对中较低节点 $x$ 的当前 $x.right$。为了获得最小节点深度为 $h$ 的树的最坏情况界限，我们可以通过对抗性选择，使树的每个这样的 $B$ 都是非空的（例如，$left$ 脊柱上的每个节点都有一个非空的右子树）。因此，在最坏情况下， $h$ 次旋转中的每一次都会产生 $6$ 次指针更新。因此，在最坏情况下，伸展阶段的成本最多为 $6h$ 次指针更新。\n\n步骤 $3$：伸展后删除根节点。伸展后，最小节点 $x$ 位于根部，并且根据构造，$x.left = \\varnothing$。删除根节点相当于用 $R = x.right$ 替换根。这需要：\n- 赋值 $root \\leftarrow R$（$1$ 次更新）。\n- 如果 $R \\neq \\varnothing$，设置 $R.parent \\leftarrow \\varnothing$（$1$ 次更新）。\n\n对于 $h \\geq 1$，路径长度为正意味着在伸展之前 $x$ 上方至少有一个祖先；在伸展过程中，$x.right$ 变成了这些祖先之一，这保证了 $R \\neq \\varnothing$。因此对于 $h \\geq 1$，此步骤的成本恰好是 $2$ 次指针更新。对于 $h = 0$，如果原始根有一个非空的右子树，最坏情况下也会产生 $2$ 次更新。\n\n步骤 $4$：合并计数。在最坏情况下，伸展阶段贡献了 $6h$ 次更新，而最后的根替换额外贡献了 $2$ 次更新。因此，作为最小节点深度 $h$ 的函数，Delete-Minimum 操作的指针更新总数的最坏情况是\n$$6h + 2.$$\n\n该表达式对所有 $h \\geq 0$ 均有效，并且在所述的对抗性假设下是紧确的。", "answer": "$$\\boxed{6h+2}$$", "id": "3233390"}, {"introduction": "理论分析给出了最坏情况下的界限，但伸展树在实践中处理不同数据访问模式时表现如何？最后一个动手练习将从理论转向实证研究。您将实现一棵伸展树，并将其与静态平衡二叉搜索树进行比较，以观察在具有不同局部性特征的访问序列下性能的差异，从而深入了解伸展树自适应策略的实际优势与劣势。[@problem_id:3273326]", "problem": "给定一项任务，要求使用两种搜索树模型构建并评估一个有序键集上的一系列访问排列：一种是静态平衡二叉搜索树（BST），另一种是带有标准伸展操作的伸展树（Splay Tree）。二叉搜索树（BST）被定义为一种有根二叉树，其中序遍历会按排序顺序产生键；伸展树是一种自适应的二叉搜索树，每次访问后会执行伸展旋转，通过称为 zig、zig-zig 和 zig-zag 的操作将被访问的节点移动到根部。推理的基本依据必须从核心定义出发：平衡 BST 的高度为 $\\Theta(\\log n)$，因此搜索任何键需要 $\\Theta(\\log n)$ 次比较；而伸展树执行旋转以动态重组自身，其性能受结构特性（如引用局部性和工作集大小）的制约。目标是构建一个排列族，在该族中，对平衡 BST 进行静态贪心搜索在单位成本模型下达到 $O(m \\log n)$，而伸展树在经验上表现更优；然后，对造成这种差距的排列属性提出假设。\n\n形式上，考虑有序键集 $\\{1,2,\\dots,n\\}$ 和一个作为这些键的排列的访问序列，因此访问次数为 $m=n$。在同一键集上初始化两棵树：\n- 一个在 $\\{1,2,\\dots,n\\}$ 上通过中位数递归构建的完美平衡 BST，在所有访问过程中保持静态。\n- 一个初始化为相同完美平衡结构的伸展树，每次访问后执行标准的伸展旋转（zig、zig-zig、zig-zag）以将被访问节点移动到根部。\n\n使用以下单位成本模型来量化处理单次访问的成本：\n- 静态平衡 BST 成本：成本等于从根到键的搜索路径上访问的节点数。由于 BST 是平衡的，其高度为 $\\Theta(\\log n)$，因此每次搜索的成本为 $\\Theta(\\log n)$ 次节点访问，总成本为 $O(m \\log n)$。\n- 伸展树成本：成本等于从根到键的搜索路径上访问的节点数，加上伸展过程中执行的旋转次数（将每次单一旋转计为成本 $1$）。对于伸展操作，将 zig 视为一次旋转，zig-zig 和 zig-zag 各视为两次旋转，以反映实际执行的指针更改。\n\n您的程序必须构建以下排列族，并为每个排列计算静态平衡 BST 总成本与伸展树总成本的比率，两者均在上述单位成本模型下计算。所有情况均使用 $n=64$，并在键 $\\{1,\\dots,64\\}$ 上构建初始树：\n- 情况 $1$（升序排列）：访问序列为 $[1,2,\\dots,64]$。\n- 情况 $2$（步幅为 $4$ 的排列）：按模 $4$ 的余数对索引进行分区，并按列主序访问：$[1,5,9,\\dots,61,2,6,10,\\dots,62,3,7,11,\\dots,63,4,8,12,\\dots,64]$。\n- 情况 $3$（步幅为 $32$ 的排列）：与情况 $2$ 类似，但步幅为 $32$。\n- 情况 $4$（位反转排列）：将索引 $0$ 到 $63$ 解释为 $6$ 位的二进制数，反转每个索引的位，然后加 $1$ 以映射回键空间 $\\{1,\\dots,64\\}$。\n- 情况 $5$（交替极值，或 Z 字形）：访问序列为 $[64,1,63,2,62,3,\\dots]$，交替访问剩余的最大键和最小键。\n\n对于每种情况，计算：\n- 静态平衡 BST 的总成本，即静态树下所有 $n$ 次访问的节点访问总和。\n- 伸展树的总成本，即所有 $n$ 次访问中，节点访问数加上将被访问节点伸展到根部时执行的旋转次数的总和。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的第 $i$ 个元素是情况 $i$ 的静态平衡 BST 总成本与伸展树总成本的比率，四舍五入到 $6$ 位小数。例如，输出格式必须完全像 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是一个四舍五入到 $6$ 位小数的浮点数。不应读取任何输入；测试套件已按上述规定固定。关于导致性能差距的属性的假设必须在解决方案中进行讨论，这些假设应源于基本定义和程序测量的经验结果。", "solution": "该问题要求对一个静态、平衡的二叉搜索树（BST）和一个动态的伸展树进行比较分析。此分析将通过模拟它们在 $n=64$ 时，对键集 $\\{1, 2, \\dots, n\\}$ 上的五个不同访问排列的性能来进行。任务的核心是实现指定的数据结构和成本模型，计算每个排列的总操作成本，并得出静态 BST 成本与伸展树成本的比率。随后，将基于数据结构的理论原则，对这些排列中导致观察到性能差异的属性提出假设。\n\n### 1. 模型定义\n\n设 $S = \\{1, 2, \\dots, n\\}$ 为键集，其中 $n=64$。访问次数为 $m=n=64$。\n\n**静态平衡 BST**：\n静态 BST 在键集 $S$ 上构建一次后保持不变。构建方法指定为“中位数递归”：对于一个键范围 `[low, high]`，选择索引为 `mid = floor((low + high) / 2)` 的键作为子树的根，然后对子范围 `[low, mid-1]` 和 `[mid+1, high]` 递归应用此过程。虽然被称为“完美平衡”，但对于 $n=64$（其形式不为 $2^k-1$），这种构建方法产生的树是近似平衡的，但并非严格意义上的完全二叉树。然而，其结构是唯一确定的。\n\n单次访问的成本定义为从根到包含被访问键的节点的路径上访问的节点数。根的深度为 $1$。一个访问序列的总成本是每次单独访问成本的总和。由于指定的访问序列是 $S$ 中所有键的一个排列，静态 BST 的总成本是树中所有节点深度的总和，即 $\\sum_{k=1}^{n} \\text{depth}(k)$。这个总成本对于五个排列中的任何一个都是恒定的。\n\n**伸展树**：\n伸展树是一种自适应的 BST。它被初始化为与静态 BST 完全相同的结构。每次访问一个键后，都会对被访问的节点执行“伸展”操作，将其移动到树的根部。此操作由一系列旋转组成。标准的伸展步骤是：\n- **Zig**：当被访问节点的父节点是根节点时执行。它涉及一次旋转。\n- **Zig-Zig**：当被访问节点及其父节点都是左孩子或都是右孩子时执行。它涉及两次旋转。\n- **Zig-Zag**：当被访问节点是右孩子而其父节点是左孩子时执行，反之亦然。它涉及两次旋转。\n\n伸展树的成本模型更为复杂，既考虑了搜索成本，也考虑了重组成本。单次访问的成本是以下两项之和：\n$1.$ 搜索键时访问的节点数（即伸展前节点的深度）。\n$2.$ 随后的伸展操作中执行的旋转次数。每个 zig 步骤成本为 $1$，而 zig-zig 和 zig-zag 步骤成本为 $2$，反映了基本旋转的数量。\n\n总成本是在整个排列上这些单次访问成本的总和。\n\n### 2. 访问排列与性能假设分析\n\n伸展树的性能在很大程度上取决于引用局部性原则。具有高时间或空间局部性的访问模式使伸展树能够调整其结构，以保持频繁或最近访问的元素靠近根部，从而减少后续的访问时间。所选的排列旨在展示一系列不同的局部性属性。\n\n**情况 1：升序排列 $[1, 2, \\dots, 64]$**\n这个序列在键空间中表现出很强的空间局部性，但对于伸展树来说是一个已知的病态案例。访问最小的键 $1$ 使其成为根，并将所有其他节点排列成一个长链作为其右后代。随后访问键 $2$ 需要遍历此链，使 $2$ 成为新的根，并重新形成另一条长链。每次访问基本上都需要遍历一条线性时间的路径。第 $i$ 次访问的成本与 $i$ 成正比，导致总成本为 $O(n^2)$。而静态 BST 保持对数时间的访问，总成本为 $O(n \\log n)$。\n*假设*：伸展树的性能将显著差于静态 BST。成本比率（BST/Splay）预计将远小于 $1$。\n\n**情况 2：步幅为 $4$ 的排列 $[1, 5, \\dots, 61, 2, 6, \\dots]$**\n此模式以固定步幅访问键，有效地交错了四个升序序列。虽然它打破了简单的顺序局部性，但它具有另一种规律性。访问像 $1, 5, 9, \\dots$ 这样的键可能会在树结构中表现出一定的局部性，因为伸展一个键可能会使来自同一余数类的其他键更靠近根。这是一个经典的例子，用于测试伸展树处理步幅内存访问模式的能力。\n*假设*：此模式具有中等局部性。伸展树的自适应特性可能有益，也可能无益，这取决于伸展操作与步幅访问的相互作用。性能预计与静态 BST 相当，或者可能稍好。比率应接近 $1$。\n\n**情况 3：步幅为 $32$ 的排列 $[1, 33, 2, 34, \\dots]$**\n这个排列对 $i=1, \\dots, 32$ 反复交替访问两个键 $i$ 和 $i+32$。这种模式呈现了一个小的、移动的键“工作集”$\\{i, i+32\\}$。伸展树的摊还分析保证了当最近访问的键集很小时，性能是高效的。访问 $i$ 之后，访问 $i+32$。伸展 $i$ 会重构树；然后，伸展 $i+32$ 也会做同样的事情。对一对键的频繁访问应使伸展树能够将它们保持在相对靠近根的位置。\n*假设*：伸展树预计能很好地适应这个小工作集。其性能应优于静态 BST 固定的对数成本访问。比率应大于 $1$。\n\n**情况 4：位反转排列**\n此排列通过反转索引 $0, \\dots, 63$ 的二进制表示的位来生成。众所周知，它表现出较差的局部性；访问序列中的连续元素在键空间中往往相距很远（例如，索引 $0 \\to$ 键 $1$，索引 $1 \\to$ 键 $33$）。这种伪随机访问模式几乎没有规律性可供伸展树利用。\n*假设*：由于没有可辨别的局部性，伸展树的自适应启发式方法不太可能提供显著优势。重组的成本可能会抵消任何偶然的好处。性能预计与静态 BST 非常相似。比率应接近 $1$。\n\n**情况 5：交替极值（Z 字形）排列 $[64, 1, 63, 2, \\dots]$**\n此序列反复访问可用的最大和最小键。伸展树的“动态指头定理”指出，在访问键 $y$ 之后访问键 $x$ 的成本与 $O(\\log |x-y|)$ 成正比。在这种情况下，连续访问之间的距离 $|x-y|$ 始终很大。这表明每次访问都将是昂贵的。树将在每一步中被急剧重构（例如，将最大元素移动到根，然后将最小元素移动到根）。\n*假设*：此模式在每次访问时都强制进行最大程度的重构。与访问远距离键相关的高成本表明，伸展树的性能不会超过静态 BST，并且由于伸展的开销，其性能可能会更差。比率预计小于或等于 $1$。\n\n### 3. 经验验证\n提供的 Python 程序按描述实现了模拟。它计算了两种树类型在所有五个排列下的总成本，并计算了指定的性能比率。这些经验结果用于验证或驳斥上述假设，为伸展树在这些不同访问模式下的行为提供了具体数据。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np # Imported as per spec, but not strictly necessary for this logic.\n\nclass Node:\n    \"\"\"A node in a binary search tree.\"\"\"\n    def __init__(self, key, parent=None, left=None, right=None):\n        self.key = key\n        self.parent = parent\n        self.left = left\n        self.right = right\n\n    def __repr__(self):\n        return f\"Node({self.key})\"\n\nclass SplayTree:\n    \"\"\"Implementation of a Splay Tree.\"\"\"\n    def __init__(self, keys):\n        self.root = self._build_balanced_tree(keys)\n\n    def _build_balanced_tree(self, keys):\n        \"\"\"Builds a balanced BST using median recursion and sets parent pointers.\"\"\"\n        sorted_keys = sorted(keys)\n        return self._build_recursive(sorted_keys, 0, len(sorted_keys) - 1, None)\n\n    def _build_recursive(self, keys, low, high, parent):\n        if low > high:\n            return None\n        mid = (low + high) // 2\n        node = Node(keys[mid], parent=parent)\n        node.left = self._build_recursive(keys, low, mid - 1, node)\n        node.right = self._build_recursive(keys, mid + 1, high, node)\n        return node\n    \n    def _left_rotate(self, x):\n        y = x.right\n        x.right = y.left\n        if y.left is not None:\n            y.left.parent = x\n        y.parent = x.parent\n        if x.parent is None:\n            self.root = y\n        elif x == x.parent.left:\n            x.parent.left = y\n        else:\n            x.parent.right = y\n        y.left = x\n        x.parent = y\n\n    def _right_rotate(self, x):\n        y = x.left\n        x.left = y.right\n        if y.right is not None:\n            y.right.parent = x\n        y.parent = x.parent\n        if x.parent is None:\n            self.root = y\n        elif x == x.parent.right:\n            x.parent.right = y\n        else:\n            x.parent.left = y\n        y.right = x\n        x.parent = y\n\n    def _splay(self, x):\n        \"\"\"Splays node x to the root and returns the number of rotations.\"\"\"\n        rotations = 0\n        while x.parent is not None:\n            p = x.parent\n            g = p.parent\n            if g is None:  # Zig\n                if x == p.left:\n                    self._right_rotate(p)\n                else:\n                    self._left_rotate(p)\n                rotations += 1\n            elif x == p.left and p == g.left:  # Zig-Zig\n                self._right_rotate(g)\n                self._right_rotate(p)\n                rotations += 2\n            elif x == p.right and p == g.right:  # Zig-Zig\n                self._left_rotate(g)\n                self._left_rotate(p)\n                rotations += 2\n            elif x == p.right and p == g.left:  # Zig-Zag\n                self._left_rotate(p)\n                self._right_rotate(g)\n                rotations += 2\n            else:  # Zig-Zag (x is left child, p is right child)\n                self._right_rotate(p)\n                self._left_rotate(g)\n                rotations += 2\n        return rotations\n\n    def access(self, key):\n        \"\"\"Accesses a key, splays it, and returns the total cost.\"\"\"\n        # 1. Search for the key and find depth (search cost)\n        node = self.root\n        search_cost = 0\n        if node is None:\n            return 0\n        \n        while node is not None and node.key != key:\n            search_cost += 1\n            if key  node.key:\n                node = node.left\n            else:\n                node = node.right\n        \n        if node is None: # Should not happen for this problem's permutations\n            return search_cost \n\n        search_cost += 1 # Count the node itself\n\n        # 2. Splay the node and find rotation cost\n        rotation_cost = self._splay(node)\n\n        return search_cost + rotation_cost\n\ndef get_static_bst_cost(n):\n    \"\"\"Calculates the total cost for a static BST for a permutation of all keys.\"\"\"\n    depths = {}\n    \n    def build_and_get_depths(low, high, depth):\n        if low > high:\n            return\n        mid = (low + high) // 2\n        depths[mid] = depth\n        build_and_get_depths(low, mid - 1, depth + 1)\n        build_and_get_depths(mid + 1, high, depth + 1)\n\n    build_and_get_depths(1, n, 1)\n    # The total cost is the sum of depths for all nodes, as the permutation accesses each key once.\n    return sum(depths.values())\n\ndef generate_permutations(n):\n    \"\"\"Generates the five specified access permutations for n keys.\"\"\"\n    perms = {}\n    \n    # Case 1: Ascending\n    perms[1] = list(range(1, n + 1))\n    \n    # Case 2: Stride-4\n    perms[2] = [j for i in range(1, 5) for j in range(i, n + 1, 4)]\n    \n    # Case 3: Stride-32\n    perms[3] = [j for i in range(1, 33) for j in range(i, n + 1, 32)]\n    \n    # Case 4: Bit-reversal\n    seq = []\n    num_bits = (n - 1).bit_length()\n    for i in range(n):\n        binary_i = f'{i:0{num_bits}b}'\n        rev_binary_i = binary_i[::-1]\n        rev_i = int(rev_binary_i, 2)\n        seq.append(rev_i + 1)\n    perms[4] = seq\n\n    # Case 5: Alternating extremes\n    keys_list = list(range(1, n + 1))\n    seq = []\n    while keys_list:\n        seq.append(keys_list.pop())\n        if keys_list:\n            seq.append(keys_list.pop(0))\n    perms[5] = seq\n    \n    return perms\n\ndef solve():\n    \"\"\"Main function to run the simulation and produce the output.\"\"\"\n    n = 64\n    keys = list(range(1, n + 1))\n    \n    # Calculate static BST cost (this is constant for all cases)\n    static_bst_total_cost = get_static_bst_cost(n)\n    \n    # Generate the 5 test permutations\n    permutations = generate_permutations(n)\n    \n    results = []\n    for case_num in sorted(permutations.keys()):\n        perm = permutations[case_num]\n        \n        # Initialize a new splay tree for each case\n        splay_tree = SplayTree(keys)\n        \n        splay_total_cost = 0\n        for key in perm:\n            cost = splay_tree.access(key)\n            splay_total_cost += cost\n            \n        ratio = static_bst_total_cost / splay_total_cost\n        results.append(f\"{ratio:.6f}\")\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3273326"}]}