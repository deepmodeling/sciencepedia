{"hands_on_practices": [{"introduction": "从 Treap 中删除一个节点比插入要复杂，因为它可能同时违反二叉搜索树（BST）和堆的属性。标准方法是通过旋转将目标节点“下沉”，直到它成为一个叶节点，然后将其移除。本练习旨在让你使用栈以非递归方式实现这一过程，这将加深你对树遍历和父子指针操作的理解，这些都是高级数据结构实现中的核心技能。[@problem_id:3280508]", "problem": "树堆（treap）是一种结合了二叉搜索树（BST）属性和堆属性的数据结构。在树堆中，每个节点存储一个键和一个独立的优先级。BST 属性要求，对于任意一个键为 $k$ 的节点，其左子树中的所有键都严格小于 $k$，其右子树中的所有键都严格大于 $k$。堆属性（本问题中为最小堆）要求，对于任意一个优先级为 $p$ 的节点，其子节点的优先级都严格大于 $p$。对于给定的键-优先级对集合，树堆可以被看作是同时满足这两个属性的唯一树形结构。\n\n本问题的基本定义和事实如下：\n- 二叉搜索树（BST）属性：对于每个键为 $k$ 的节点，其左子树中的所有键 $x$ 满足 $x  k$，其右子树中的所有键 $y$ 满足 $y > k$。\n- 堆属性（基于优先级的最小堆）：对于每个优先级为 $p$ 的节点，其任意子节点的优先级 $p_c$ 满足 $p \\le p_c$。\n- 树旋转是一种局部变换，它在保持 BST 属性的同时修改父子关系。旋转是用于在结构变化后恢复堆属性的基本操作。\n\n你的任务是推导、实现并验证一个非递归的树堆删除操作。该删除操作必须使用一个栈来管理从根到目标节点的路径。设计必须基于上述基本属性，并且删除操作必须避免使用递归。你必须实现的高级步骤如下：\n- 使用 BST 引导的遍历搜索键为 $k$ 的节点，并在栈中记录路径。\n- 如果找到节点，通过旋转反复将其“下沉”，直到待删除节点最多只有一个子节点。在每一步中，选择优先级较小的子节点进行旋转，以保持堆属性的有效性。使用栈来确定性地、非递归地维护和更新祖先链接。\n- 通过将其父节点重新连接到其单个子节点（如果是叶子节点，则连接到空子节点）来移除该节点。\n- 验证结果树是否保持了 BST 和堆属性。\n\n除了删除操作，你可以用任何方法实现插入操作。然而，删除操作必须是非递归的，并且必须显式地使用栈来管理路径。\n\n验证要求：\n- 实现一个函数，通过执行中序遍历并确认序列是严格递增的来检查 BST 属性。\n- 实现一个函数，通过确认为每个节点其优先级小于或等于其子节点的优先级来检查堆属性（基于优先级的最小堆）。\n- 实现一个函数，返回键的中序序列。\n\n复杂度要求：\n- 对于从 $n$ 个具有独立优先级的节点构建的树堆，期望高度为 $\\mathcal{O}(\\log n)$，删除操作必须在 $\\mathcal{O}(h)$ 时间内运行，其中 $h$ 是树堆的高度。\n\n测试套件：\n为确保确定性，你将获得明确的键-优先级对，而不是随机生成的优先级。对于每个测试用例，通过插入给定的键-优先级对来构建树堆，然后对指定的键执行一次删除操作。对于每个测试用例，你的程序必须输出一个列表，其中包含：\n- 一个布尔值，指示是否找到并删除了具有给定键的节点。\n- 一个布尔值，指示结果结构是否满足 BST 属性。\n- 一个布尔值，指示结果结构是否满足堆属性。\n- 删除后的键的中序遍历列表。\n\n使用以下测试用例：\n- 测试用例 1：键-优先级对 $\\{(5,10),(3,20),(8,30)\\}$，删除键 $3$。\n- 测试用例 2：键-优先级对 $\\{(5,10),(3,20),(4,15)\\}$，删除键 $4$。\n- 测试用例 3：键-优先级对 $\\{(5,10),(3,20),(7,15),(6,25)\\}$，删除键 $5$。\n- 测试用例 4：键-优先级对 $\\{(5,10),(3,20),(7,15)\\}$，删除键 $42$。\n- 测试用例 5：键-优先级对 $\\{\\}$，删除键 $1$。\n- 测试用例 6：键-优先级对 $\\{(50,5),(20,15),(70,10),(10,25),(30,40),(60,35),(80,20),(25,30),(35,45)\\}$，删除键 $50$。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。每个元素对应一个测试用例的结果，其本身是如上所述包含四个元素的列表。例如：“[$[r_1], [r_2], \\dots$]”，其中每个 $[r_i]$ 的结构为 $[\\text{deleted}, \\text{bst\\_ok}, \\text{heap\\_ok}, \\text{inorder}]$。本问题不涉及单位。", "solution": "树堆（Treap）是一种随机化的二叉搜索树，它以高概率实现自我平衡。其名称是“tree”（树）和“heap”（堆）的混合词。树堆中的每个节点都拥有一个满足二叉搜索树（BST）属性的键，以及一个随机分配的、满足堆属性的优先级。这种双重结构确保了对于任何给定的键-优先级对集合，树堆的形状是唯一的。\n\n**基本属性：**\n$1$. **二叉搜索树（BST）属性：** 对于任意一个键为 $k$ 的节点，其左子树中的所有键都严格小于 $k$，其右子树中的所有键都严格大于 $k$。此属性使得搜索、插入和删除操作能够高效执行，类似于标准的 BST。\n$2$. **最小堆属性：** 对于任意一个优先级为 $p$ 的节点，其子节点的优先级 $p_c$ 必须大于或等于 $p$（即 $p \\le p_c$）。这意味着在任何子树中，具有最小优先级的节点总是该子树的根。因此，整个树堆中优先级最小的节点是整棵树的根。\n\n**通过旋转实现删除：**\n要删除一个键为 $k$ 的节点，我们首先使用 BST 属性定位它。类似于 BST 删除的简单移除操作可能会破坏堆属性。树堆中删除的标准方法是通过一系列旋转将目标节点“下沉”，直到它成为一个叶子节点或只有一个子节点的节点。此时，可以将其从树中剪接出去，而无需进行复杂的结构重组。这个过程在概念上等同于将目标节点的优先级设置为无穷大，使其在树中下沉。\n\n操作的核心在于选择正确的旋转。如果待删除的节点有两个子节点，我们比较它们的优先级。我们将该节点与其优先级较小的子节点进行旋转。例如，如果左子节点的优先级较小，我们对目标节点执行右旋转。这会使左子节点上升，成为新的父节点，而目标节点则下移。这种特定的旋转选择至关重要，因为它保持了相关节点之间的堆属性（新的父节点比其新的子节点——即目标节点——具有更小的优先级）。由于旋转本身就是为了保持 BST 属性而设计的，因此在整个过程中，树始终是一个有效的 BST。\n\n**使用栈的非递归实现：**\n本问题要求使用非递归方式实现删除操作，并明确要求使用栈。栈对于管理从根到正在操作的节点的路径至关重要。\n\n**分步算法：**\n$1$. **搜索与路径跟踪：** 我们从根节点开始遍历树，以找到具有目标键 $k$ 的节点。在遍历过程中，我们使用一个栈来存储所经过的路径。栈中的每个元素代表一个父节点以及遍历的方向（例如，以元组 `(parent_node, is_left_child)` 的形式）。在旋转后，此路径信息对于更新父子链接至关重要。\n\n$2$. **迭代“下沉”：** 如果找到目标节点并且它有两个子节点，我们进入一个循环。在每次迭代中：\n    a. 我们比较左右子节点的优先级。\n    b. 如果左子节点的优先级小于右子节点，我们对目标节点执行右旋转。否则，我们执行左旋转。\n    c. 旋转后，目标节点下移了一层。其原始父节点现在必须指向旋转后子树的新根。我们使用路径栈中的信息来找到这个父节点，并更新其 `left` 或 `right` 子指针。\n    d. 然后更新栈以反映目标节点新的父子关系，为下一次迭代做准备（如果该节点仍有两个子节点）。\n\n$3$. **最终节点移除：** 当目标节点最多只有一个子节点时，循环终止。此时，可以通过使其父节点直接指向其单个子节点（如果是叶子节点，则指向 `None`）来将其移除。路径栈提供了执行此 C++ 风格指针操作所需的最终父节点信息。\n\n**验证：**\n为确保实现的正确性，我们实现了两个验证函数：\n- `check_bst()`：此函数对树堆执行中序遍历。如果树堆是有效的 BST，则得到的键序列必须是严格递增的。\n- `check_heap()`：此函数对树堆执行遍历（例如 BFS 或 DFS）。对于每个节点，它验证其优先级是否小于或等于其子节点的优先级，以符合最小堆属性。\n\n这种基于原则的、分步的方法确保了非递归删除操作能够正确维护 BST 和堆两种不变性，并且其正确性可以被严格验证。时间复杂度与树的高度成正比，对于树堆来说，期望高度为 $\\mathcal{O}(\\log n)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\nclass Node:\n    \"\"\"A class to represent a node in the treap.\"\"\"\n    def __init__(self, key, priority):\n        self.key = int(key)\n        self.priority = int(priority)\n        self.left = None\n        self.right = None\n\nclass Treap:\n    \"\"\"A class to represent a treap data structure.\"\"\"\n    def __init__(self):\n        self.root = None\n\n    def _rotate_left(self, y):\n        \"\"\"Performs a left rotation on the subtree rooted at y.\"\"\"\n        x = y.right\n        T2 = x.left\n        x.left = y\n        y.right = T2\n        return x\n\n    def _rotate_right(self, y):\n        \"\"\"Performs a right rotation on the subtree rooted at y.\"\"\"\n        x = y.left\n        T2 = x.right\n        x.right = y\n        y.left = T2\n        return x\n\n    def _insert_recursive(self, node, key, priority):\n        \"\"\"Recursive helper for insertion, maintaining treap properties.\"\"\"\n        if not node:\n            return Node(key, priority)\n\n        if key  node.key:\n            node.left = self._insert_recursive(node.left, key, priority)\n            # If heap property is violated, rotate right\n            if node.left.priority  node.priority:\n                node = self._rotate_right(node)\n        elif key > node.key:\n            node.right = self._insert_recursive(node.right, key, priority)\n            # If heap property is violated, rotate left\n            if node.right.priority  node.priority:\n                node = self._rotate_left(node)\n        \n        return node\n\n    def insert(self, key, priority):\n        \"\"\"Public method for insertion.\"\"\"\n        self.root = self._insert_recursive(self.root, key, priority)\n\n    def delete(self, key):\n        \"\"\"\n        Non-recursive deletion using a stack to manage the path.\n        \"\"\"\n        # Step 1: Find the node and store the path to it.\n        # The stack stores tuples of (parent_node, is_left_child_bool).\n        path_stack = []\n        node = self.root\n        \n        while node and node.key != key:\n            parent = node\n            if key  node.key:\n                path_stack.append((parent, True))\n                node = node.left\n            else:\n                path_stack.append((parent, False))\n                node = node.right\n        \n        if not node:\n            return False  # Key not found\n\n        # Step 2: \"Bubble down\" the node using rotations until it has at most one child.\n        while node.left and node.right:\n            # Decide rotation based on child priorities.\n            if node.left.priority  node.right.priority:\n                new_sub_root = self._rotate_right(node)\n            else:\n                new_sub_root = self._rotate_left(node)\n\n            # Update the parent of the rotated subtree.\n            if not path_stack:\n                self.root = new_sub_root\n            else:\n                parent, is_left = path_stack[-1]\n                if is_left:\n                    parent.left = new_sub_root\n                else:\n                    parent.right = new_sub_root\n            \n            # The node to delete has moved down. Update path_stack for the next iteration.\n            # a new parent-child relation is established for the node we are deleting.\n            path_stack.append((new_sub_root, node is new_sub_root.left))\n\n        # Step 3: Remove the node, which now has at most one child.\n        child = node.left if node.left else node.right\n        \n        if not path_stack:\n            self.root = child\n        else:\n            parent, is_left = path_stack[-1]\n            if is_left:\n                parent.left = child\n            else:\n                parent.right = child\n        \n        return True\n\n    def get_in_order_keys(self):\n        \"\"\"Returns a list of keys from an in-order traversal.\"\"\"\n        if not self.root:\n            return []\n        \n        result = []\n        stack = []\n        current = self.root\n        while current or stack:\n            while current:\n                stack.append(current)\n                current = current.left\n            current = stack.pop()\n            result.append(current.key)\n            current = current.right\n        return result\n\n    def check_bst(self):\n        \"\"\"Checks if the tree satisfies the BST property (strictly increasing keys in-order).\"\"\"\n        keys = self.get_in_order_keys()\n        for i in range(1, len(keys)):\n            if keys[i] = keys[i-1]:\n                return False\n        return True\n\n    def check_heap(self):\n        \"\"\"Checks if the tree satisfies the min-heap property on priorities.\"\"\"\n        if not self.root:\n            return True\n        \n        q = deque([self.root])\n        while q:\n            node = q.popleft()\n            if node.left:\n                if node.priority > node.left.priority:\n                    return False\n                q.append(node.left)\n            if node.right:\n                if node.priority > node.right.priority:\n                    return False\n                q.append(node.right)\n        return True\n\ndef solve():\n    test_cases = [\n        ({'pairs': {(5,10),(3,20),(8,30)}, 'delete_key': 3}),\n        ({'pairs': {(5,10),(3,20),(4,15)}, 'delete_key': 4}),\n        ({'pairs': {(5,10),(3,20),(7,15),(6,25)}, 'delete_key': 5}),\n        ({'pairs': {(5,10),(3,20),(7,15)}, 'delete_key': 42}),\n        ({'pairs': set(), 'delete_key': 1}),\n        ({'pairs': {(50,5),(20,15),(70,10),(10,25),(30,40),(60,35),(80,20),(25,30),(35,45)}, 'delete_key': 50}),\n    ]\n\n    results = []\n    for case in test_cases:\n        treap = Treap()\n        for key, priority in case['pairs']:\n            treap.insert(key, priority)\n        \n        deleted = treap.delete(case['delete_key'])\n        bst_ok = treap.check_bst()\n        heap_ok = treap.check_heap()\n        inorder = treap.get_in_order_keys()\n        \n        results.append([deleted, bst_ok, heap_ok, inorder])\n\n    # Final print statement in the exact required format.\n    # Using str() and replace() to ensure no spaces in the list representation\n    # e.g., [1,2] instead of [1, 2]\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3280508"}, {"introduction": "Treap 的效率源于其随机分配的优先级，这确保了树在期望上保持平衡。为了真正理解这一点，我们必须分析其结构特性。本练习将引导你通过经典的概率分析方法，推导出一个 Treap 中叶节点的期望数量，这个过程会用到建立并求解递推关系这一强大技巧。[@problem_id:3280490]", "problem": "树堆 (Treap) 是一种二叉搜索树 (BST; Binary Search Tree)，其每个节点都增加了一个堆序优先级：对于一组 $n$ 个不同的键，每个键都被分配一个独立同分布 (i.i.d.) 的连续随机优先级，该树通过键来维持二叉搜索树的顺序，同时通过优先级来维持堆属性。由于优先级是连续的，最小优先级的索引在 $\\{1,2,\\dots,n\\}$ 上均匀分布，并且以具有最小优先级的节点为根，其左右子树是基于不相交的优先级子集构建的独立树堆。\n\n设 $n \\geq 2$。将叶节点定义为没有子节点的节点。从这些基本事实（优先级的独立性及最小优先级索引的均匀性）出发，推导出一个关于 $n$ 的闭式表达式，用于表示一个由 $n$ 个具有独立同分布连续优先级的不同键构建的树堆中叶节点的期望数量。\n\n你的最终答案必须是仅取决于 $n$ 的单个闭式解析表达式。无需四舍五入。", "solution": "我们利用由独立同分布连续优先级导出的树堆的递归结构，以及最小优先级索引是均匀分布这一事实。设 $T_n$ 表示一个由 $n$ 个具有独立同分布连续优先级的不同键构建的树堆。设 $L(T_n)$ 为 $T_n$ 中的叶节点数量，并定义\n$$\nX_n \\coloneqq \\mathbb{E}[L(T_n)]。\n$$\n我们采用标准约定 $X_0 = 0$ （空树没有叶节点）和 $X_1 = 1$ （单节点树有一个叶节点）。\n\n以 $n$ 个节点中最小优先级的索引为条件，我们将其记为 $R$。由于优先级是独立同分布且连续的，$R$ 在 $\\{1,2,\\dots,n\\}$ 上均匀分布。索引为 $R$ 的节点成为根节点。其左子树包含 $R-1$ 个键，右子树包含 $n-R$ 个键。根据独立性和树堆的递归定义，这些子树是独立的，并且各自的分布与相应大小的树堆相同。对于 $n \\geq 2$，根节点不是叶节点，除非其两个子树都为空，而这种情况只在 $n=1$ 时发生（已在基本情况中处理）。因此，对于 $n \\geq 2$：\n$$\nX_n \\;=\\; \\mathbb{E}[L(T_{R-1}) + L(T_{n-R})]\n\\;=\\; \\frac{1}{n} \\sum_{r=1}^{n} \\bigl(X_{r-1} + X_{n-r}\\bigr)\n\\;=\\; \\frac{2}{n} \\sum_{k=0}^{n-1} X_k.\n$$\n\n定义部分和 $S_m \\coloneqq \\sum_{k=0}^{m} X_k$。那么对于 $n \\geq 2$：\n$$\nX_n = \\frac{2}{n} S_{n-1}, \\quad\\text{and}\\quad S_n = S_{n-1} + X_n = \\left(1 + \\frac{2}{n}\\right) S_{n-1}.\n$$\n我们还有 $S_1 = X_0 + X_1 = 0 + 1 = 1$。对 $S_n$ 的乘法递推关系进行迭代，可得对于 $n \\geq 2$：\n$$\nS_n \\;=\\; S_1 \\prod_{k=2}^{n} \\left(1 + \\frac{2}{k}\\right)\n\\;=\\; \\prod_{k=2}^{n} \\frac{k+2}{k}\n\\;=\\; \\frac{(n+2)(n+1)}{6}.\n$$\n代入 $X_n = \\frac{2}{n} S_{n-1}$，我们得到对于 $n \\geq 2$：\n$$\nX_n \\;=\\; \\frac{2}{n} \\cdot \\frac{n(n+1)}{6} \\;=\\; \\frac{n+1}{3}.\n$$\n\n因此，对于 $n \\geq 2$，一个由 $n$ 个具有独立同分布连续优先级的不同键构建的树堆中，叶节点的期望数量是\n$$\n\\frac{n+1}{3}。\n$$\n这与通过公式和直接枚举两种方法得到的基本计算结果相符：$X_2 = 1$ 和 $X_3 = \\frac{4}{3}$。基本情况 $X_1 = 1$ 与树堆的定义一致，但它是一个在递推关系之外的边界情况。根据要求，最终的闭式表达式（对于 $n \\geq 2$）是 $\\frac{n+1}{3}$。", "answer": "$$\\boxed{\\frac{n+1}{3}}$$", "id": "3280490"}, {"introduction": "Treap 不仅仅是键值存储结构，它还可以被改造用来解决复杂的动态序列问题。本练习将介绍“隐式 Treap”的概念，其中节点的键是它们在中序遍历中的排名。你将使用这种强大的变体来建模并解决经典的“约瑟夫问题”的动态版本，从而展示 Treap 高效处理索引插入、删除和区间旋转等复杂操作的能力。[@problem_id:3280389]", "problem": "要求您设计并实现一个程序，使用隐式 treap（带隐式索引的随机化二叉搜索树）来模拟动态群体大小下的环形淘汰过程（通常称为 Josephus 问题）。目标是计算多个测试场景下，随着操作进行，被淘汰标签的精确序列。程序必须是完全确定性的，并且不得读取任何输入。\n\n此问题的基本背景如下。二叉搜索树是一种有根树，满足二叉搜索性质，即对于每个节点，其左子树中的所有键都较小，右子树中的所有键都较大。堆是一种有根树，它关于某个优先级满足堆性质，即每个节点的优先级不大于其子节点的优先级。Treap 是一种数据结构，它按键值同时是二叉搜索树，按次要优先级同时是堆。隐式 treap 是一种 treap，其二叉搜索树的键是中序排名（位置），并通过存储子树大小来隐式维护。对于当前大小为 $n$ 的情况，隐式 treap 支持以下操作，期望时间复杂度为 $\\mathcal{O}(\\log n)$：在指定位置插入、在指定位置删除、按位置分裂以及合并两个 treap。这是因为独立的随机优先级能产生 $\\mathcal{O}(\\log n)$ 的期望高度。\n\n定义和要求：\n- 存在一个参与者的循环列表。每个参与者都有一个唯一的整数标签。\n- 状态以环的线性化形式维护，并带有一个称为“当前指针”的特殊指定当前位置。当前线性化表示中索引为 $0$ 的元素是当前元素。索引从 $0$ 开始，对于大小为 $n$ 的情况，范围是 $\\{0,1,\\dots,n-1\\}$。\n- 对于步长为 $s$ 和当前大小为 $n$ 的 Josephus 淘汰，会移除当前线性化表示中位置为 $((s-1) \\bmod n)$ 的元素。移除后，当前指针前进到更新后的线性化表示中相同索引处的元素，这对应于环中的下一个元素。\n- 您必须使用隐式 treap 在该环形结构上支持以下命令：\n  - $\\text{INIT}(n)$: 按顺序用标签 $1,2,\\dots,n$ 初始化结构，并将当前指针设置到标签为 $1$ 的元素（即索引 $0$）。\n  - $\\text{STEP}(s,t)$: 使用固定步长 $s$ 顺序执行 $t$ 次淘汰，应用上述规则。如果在执行完 $t$ 次淘汰前结构变为空，则提前停止。将每个被淘汰的标签按顺序附加到该测试用例的结果序列中。\n  - $\\text{ADD\\_AT}(i,x)$: 插入一个标签为 $x$ 的新参与者，使其成为当前线性化表示中索引为 $i$ 的元素，其中 $i \\in \\{0,1,\\dots,n\\}$。插入后，新大小为 $n+1$。如果 $i=0$，新元素成为当前元素。\n  - $\\text{DEL\\_AT}(i)$: 删除当前线性化表示中索引为 $i$ 的元素，其中 $i \\in \\{0,1,\\dots,n-1\\}$。如果 $i=0$，下一个元素（如果存在）成为新的当前元素；否则，当前元素保持不变。\n- 所有插入操作都使用当前不存在的唯一标签。测试套件中的所有索引在应用时对于当时的状态都是有效的。\n\n您的实现必须使用一个隐式 treap，该 treap 维护子树大小，支持按排名分裂和按堆优先级合并，并通过旋转 treap 来实现环形行为，从而使当前元素始终位于索引 $0$。\n\n测试套件。您的程序必须按顺序执行以下四个测试用例，每个测试用例都从一个空状态开始，并报告淘汰序列作为输出。每个测试用例产生一个按淘汰顺序排列的被淘汰标签列表。\n\n- 测试用例 1（包含所有操作的正常路径）：\n  - $\\text{INIT}(7)$\n  - $\\text{STEP}(3,4)$\n  - $\\text{ADD\\_AT}(2,100)$\n  - $\\text{STEP}(2,2)$\n  - $\\text{DEL\\_AT}(1)$\n  - $\\text{STEP}(5,10)$\n- 测试用例 2（边界情况：从空开始，仅插入，然后淘汰）：\n  - $\\text{INIT}(0)$\n  - $\\text{ADD\\_AT}(0,1)$\n  - $\\text{ADD\\_AT}(1,2)\n  - $\\text{ADD\\_AT}(2,3)$\n  - $\\text{STEP}(1,5)$\n- 测试用例 3（删除当前元素，在开头插入，然后淘汰至空）：\n  - $\\text{INIT}(5)$\n  - $\\text{STEP}(1,0)$\n  - $\\text{DEL\\_AT}(0)$\n  - $\\text{ADD\\_AT}(0,99)$\n  - $\\text{STEP}(2,10)$\n- 测试用例 4（大步长环绕）：\n  - $\\text{INIT}(6)$\n  - $\\text{STEP}(10,6)$\n\n最终输出格式。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身也是一个不含任何空格的方括号括起来的逗号分隔列表。例如，如果有两个测试生成列表 $[a,b]$ 和 $[c]$，则输出必须是 $[[a,b],[c]]$，方括号内没有任何空格。角度或物理单位在此无关紧要，所有答案都是指定的整数标签。程序不得读取任何输入，并且必须在内部计算测试套件的结果。", "solution": "隐式 treap 是一种概率性数据结构，它维护一个序列，并能在期望对数时间内完成按排名分裂、合并、插入和删除操作。该数据结构利用了两个基本原则：\n\n- 按隐式键满足的二叉搜索树性质：中序遍历顺序决定了序列中每个节点的位置（排名），而排名通过子树大小来隐式维护。对于一个存储值（标签）为 $v$ 的节点，令 $\\mathrm{size}(v)$ 表示以 $v$ 为根的子树的大小；那么 $v$ 的中序排名是其左子树的大小加 $1$。\n- 按独立选择的随机优先级满足的堆性质：每个节点都被赋予一个从固定分布中抽取的独立优先级。树在这些优先级下被维护为一个堆。一个经过充分检验的事实是，这种随机化的优先级对于 $n$ 个节点能产生 $\\mathcal{O}(\\log n)$ 的期望高度，这为更新和查询操作提供了期望 $\\mathcal{O}(\\log n)$ 的时间界限。\n\n表示序列。考虑一个在中序遍历中存储参与者的隐式 treap。节点的序列索引是其中序排名减 $1$（以实现从 $0$ 开始的索引）。我们在每个节点上维护以下字段：值（标签）、优先级、左子节点、右子节点和子树大小。函数 $\\mathrm{recalc}(u)$ 将 $\\mathrm{size}(u)$ 重新计算为 $1+\\mathrm{size}(u.\\mathrm{left})+\\mathrm{size}(u.\\mathrm{right})$。\n\n分裂与合并。对于一个 treap 根 $T$ 和一个整数 $k$（其中 $0 \\le k \\le \\mathrm{size}(T)$），$\\mathrm{split}(T,k)$ 将序列在索引 $k$ 处划分为两个 treap $(L,R)$，使得 $L$ 包含前 $k$ 个元素，而 $R$ 包含剩余的 $\\mathrm{size}(T)-k$ 个元素。其递归定义依赖于中序排名和堆性质：如果 $T$ 的左子树大小为 $\\ell$ 且 $k \\le \\ell$，我们递归地分裂左子树；否则，我们在 $k-\\ell-1$ 处分裂右子树。反之，$\\mathrm{merge}(A,B)$ 合并两个 treap，其中 $A$ 的所有元素在序列中都在 $B$ 的所有元素之前。合并操作选择优先级较小的根作为新根，并递归地合并其适当的子节点，从而同时保持按优先级的堆性质和中序序列性质。\n\n按索引插入和删除。要在位置 $i$ 插入一个值，我们在 $i$ 处分裂得到 $(L,R)$，创建一个节点 $X$，然后设置为 $\\mathrm{merge}(\\mathrm{merge}(L,X),R)$。要删除位置 $i$ 的元素，我们在 $i$ 处分裂，然后在右半部分在 $1$ 处再次分裂以分离出要删除的单个节点，丢弃它，然后将剩余的两部分合并回来。\n\n环形行为和当前指针。环形列表通过一个线性的隐式 treap 来维护，并带有一个不变量，即当前元素始终位于索引 $0$。这个不变量通过一次分裂-合并实现的旋转来保持：要向左旋转 $r$ 个位置（使得旧索引 $r$ 处的元素成为新索引 $0$ 处的元素），我们计算 $(A,B)=\\mathrm{split}(T,r)$，然后设置 $T'=\\mathrm{merge}(B,A)$。这实现了当前指针在环中的前进。\n\nJosephus 淘汰步骤。设当前 treap 的大小为 $n>0$，步长为 $s>0$。下一个要移除的索引是当前以索引 $0$ 为锚点的线性化表示中的 $i=((s-1) \\bmod n)$。我们在索引 $i$ 处删除以获得被淘汰的标签。然后，如果 treap 不为空，我们向左旋转 $i \\bmod (n-1)$，这样被删除位置之后的元素就成为新的索引 $0$ 处的元素，这与 Josephus 的定义相符。重复此过程 $t$ 次，当 treap 变为空时提前停止，即可得到 $\\mathrm{STEP}(s,t)$ 命令所要求的淘汰序列。\n\n正确性论证。基于带隐式排名的二叉搜索树性质和按随机优先级的堆性质，隐式 treap 通过分裂和合并的不变量来维护精确的中序序列。在索引 $i$ 处插入会产生一个序列，其中新节点占据排名 $i$，所有之前和之后的元素保持其相对顺序。在索引 $i$ 处删除会移除第 $i$ 个元素并保持剩余元素的顺序。通过在 $r$ 处分裂并以相反顺序合并实现的旋转，将旧索引 $r$ 处的元素置于新索引 $0$ 处，并将每个后续元素映射到其模除大小的前驱索引，从而为当前指针实现了正确的环形移位。因此，为下一次淘汰计算索引 $((s-1) \\bmod n)$ 并在删除后按该索引旋转，这完全是从第一性原理出发实现了 Josephus 过程。因为 treap 的期望高度是 $\\mathcal{O}(\\log n)$，所以每个 $\\mathrm{split}$、$\\mathrm{merge}$、插入和删除操作的期望运行时间都是 $\\mathcal{O}(\\log n)$，因此每次淘汰和每次动态更新的期望时间都是 $\\mathcal{O}(\\log n)$，从而得出总期望运行时间与操作次数乘以 $\\mathcal{O}(\\log n)$ 成正比。\n\n边界情况和测试覆盖。测试套件涵盖了：\n- 一个包含所有操作的通用混合情况，即使 $t$ 更大，也会在淘汰完所有元素后停止（测试用例 1）。\n- 从空开始，在淘汰前仅使用插入操作，包括在完成 $t$ 次淘汰前因变空而提前停止（测试用例 2）。\n- 删除当前元素，然后在索引 0 处插入（该元素成为新的当前元素），随后淘汰至空（测试用例 3）。\n- 大步长重复环绕当前大小（测试用例 4）。\n这些用例共同验证了在任意索引处的插入、在任意索引处的删除、当前指针的环形旋转不变量以及 Josephus 步骤中的模运算。\n\n最终程序构建一个隐式 treap，为每个测试用例精确执行指定的命令，收集每个测试用例中被淘汰的标签，并以所要求的精确的、不含内部空格的带方括号的逗号分隔格式打印单行结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport random\nfrom typing import Optional, Tuple, List\n\nclass Node:\n    __slots__ = (\"val\", \"prio\", \"left\", \"right\", \"size\")\n    def __init__(self, val: int, prio: int):\n        self.val = val\n        self.prio = prio\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n        self.size = 1\n\ndef sz(t: Optional[Node]) - int:\n    return t.size if t is not None else 0\n\ndef recalc(t: Optional[Node]) - None:\n    if t is not None:\n        t.size = 1 + sz(t.left) + sz(t.right)\n\ndef split(t: Optional[Node], k: int) - Tuple[Optional[Node], Optional[Node]]:\n    # Split into (L, R): L has first k elements by rank\n    if t is None:\n        return None, None\n    left_sz = sz(t.left)\n    if k = left_sz:\n        L, t_left_right = split(t.left, k)\n        t.left = t_left_right\n        recalc(t)\n        return L, t\n    else:\n        t_right_left, R = split(t.right, k - left_sz - 1)\n        t.right = t_right_left\n        recalc(t)\n        return t, R\n\ndef merge(a: Optional[Node], b: Optional[Node]) - Optional[Node]:\n    if a is None:\n        return b\n    if b is None:\n        return a\n    if a.prio  b.prio:\n        a.right = merge(a.right, b)\n        recalc(a)\n        return a\n    else:\n        b.left = merge(a, b.left)\n        recalc(b)\n        return b\n\ndef insert_at(t: Optional[Node], idx: int, node: Node) - Optional[Node]:\n    L, R = split(t, idx)\n    return merge(merge(L, node), R)\n\ndef erase_at(t: Optional[Node], idx: int) - Tuple[Optional[Node], Optional[int]]:\n    # Remove element at index idx, return new root and removed value\n    L, R = split(t, idx)\n    M, R2 = split(R, 1)\n    removed_val = M.val if M is not None else None\n    new_root = merge(L, R2)\n    return new_root, removed_val\n\ndef rotate_left(t: Optional[Node], r: int) - Optional[Node]:\n    n = sz(t)\n    if t is None or n == 0:\n        return t\n    r %= n\n    if r == 0:\n        return t\n    L, R = split(t, r)\n    return merge(R, L)\n\ndef build_from_list(vals: List[int], rng: random.Random) - Optional[Node]:\n    # Build by successive merges at the end (amortized expected O(n))\n    root = None\n    for v in vals:\n        node = Node(v, rng.randint(1, 1  30))\n        root = merge(root, node)\n    return root\n\ndef process_test(commands: List[Tuple], rng: random.Random) - List[int]:\n    root: Optional[Node] = None\n    eliminated: List[int] = []\n    for cmd in commands:\n        op = cmd[0]\n        if op == \"INIT\":\n            n = cmd[1]\n            if n == 0:\n                root = None\n            else:\n                root = build_from_list(list(range(1, n + 1)), rng)\n            # current is at index 0 by construction\n        elif op == \"ADD_AT\":\n            i, x = cmd[1], cmd[2]\n            n = sz(root)\n            # Assume indices are valid (0..n) per problem; clamp defensively\n            i = max(0, min(i, n))\n            node = Node(x, rng.randint(1, 1  30))\n            root = insert_at(root, i, node)\n        elif op == \"DEL_AT\":\n            i = cmd[1]\n            n = sz(root)\n            if n == 0:\n                continue\n            # Assume valid per problem; clamp defensively\n            i = max(0, min(i, n - 1))\n            root, _ = erase_at(root, i)\n            # current remains at index 0 by erase semantics\n        elif op == \"STEP\":\n            s, t = cmd[1], cmd[2]\n            for _ in range(t):\n                n = sz(root)\n                if n == 0:\n                    break\n                idx = (s - 1) % n\n                root, val = erase_at(root, idx)\n                if val is not None:\n                    eliminated.append(val)\n                n_after = sz(root)\n                if n_after > 0:\n                    root = rotate_left(root, idx % n_after)\n        else:\n            # Unknown command: ignore\n            pass\n    return eliminated\n\ndef format_no_spaces(obj) - str:\n    if isinstance(obj, list):\n        return \"[\" + \",\".join(format_no_spaces(x) for x in obj) + \"]\"\n    else:\n        return str(obj)\n\ndef solve():\n    rng = random.Random(1337)\n    test_cases = [\n        # Test case 1\n        [\n            (\"INIT\", 7),\n            (\"STEP\", 3, 4),\n            (\"ADD_AT\", 2, 100),\n            (\"STEP\", 2, 2),\n            (\"DEL_AT\", 1),\n            (\"STEP\", 5, 10),\n        ],\n        # Test case 2\n        [\n            (\"INIT\", 0),\n            (\"ADD_AT\", 0, 1),\n            (\"ADD_AT\", 1, 2),\n            (\"ADD_AT\", 2, 3),\n            (\"STEP\", 1, 5),\n        ],\n        # Test case 3\n        [\n            (\"INIT\", 5),\n            (\"STEP\", 1, 0),\n            (\"DEL_AT\", 0),\n            (\"ADD_AT\", 0, 99),\n            (\"STEP\", 2, 10),\n        ],\n        # Test case 4\n        [\n            (\"INIT\", 6),\n            (\"STEP\", 10, 6),\n        ],\n    ]\n\n    results = []\n    for commands in test_cases:\n        res = process_test(commands, rng)\n        results.append(res)\n\n    print(format_no_spaces(results))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3280389"}]}