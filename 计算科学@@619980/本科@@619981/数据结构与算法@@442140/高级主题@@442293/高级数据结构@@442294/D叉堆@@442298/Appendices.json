{"hands_on_practices": [{"introduction": "这项练习旨在检验你对 d 叉堆核心结构的理解。你需要应用基于数组表示的父子索引关系，高效地验证一个给定数组是否满足最大堆属性。在处理更复杂的操作之前，这个实践对于打下坚实的基础至关重要。[@problem_id:3225698]", "problem": "给定一个长度为 $n$ 的数组 $A$（使用从 $0$ 开始的索引）和一个整数分支因子 $d \\ge 2$。在完全 $d$ 叉树的标准数组表示中，$d$ 叉最大堆的定义是：每个节点的键都大于或等于其所有子节点的键。任务是在 $O(n)$ 时间内判断数组 $A$ 在这种表示下是否编码了一个有效的 $d$ 叉最大堆。\n\n从第一性原理出发，使用以下基本事实：\n- 一个完全 $d$ 叉树可以通过按层序排列节点来用数组表示，这样父子关系仅由索引算术确定。\n- 堆属性是局部的：每个父节点必须满足相对于其子节点的排序约束。\n- 对树结构（例如边数和内部节点数）的计数论证可用于推导所需比较次数的紧界。\n\n给定 $A$ 和 $d$，哪个选项正确地指定了一个算法，该算法能为所有适用的父子对验证堆属性，并在 $O(n)$ 时间内运行？\n\nA. 将 $i$ 从 $0$ 迭代到 $\\left\\lfloor \\dfrac{n - 2}{d} \\right\\rfloor$。对于每个 $i$，将 $j$ 从 $d i + 1$ 迭代到 $\\min(d i + d, n - 1)$。如果对于任何这样的 $j$ 有 $A[i]  A[j]$，则返回 $\\text{false}$；否则继续。如果所有检查都通过，则返回 $\\text{true}$。时间复杂度：$O(n)$。\n\nB. 对每个内部节点 $i$，计算其整个子树中的最大值，并验证 $A[i] \\ge \\max\\{A[j] : j \\text{ 在以 } i \\text{ 为根的子树中}\\}$。如果任何检查失败，则返回 $\\text{false}$；否则返回 $\\text{true}$。时间复杂度：$O(n)$，因为每个子树被每个父节点扫描一次。\n\nC. 将 $j$ 从 $1$ 迭代到 $n - 1$，并对每个 $j$ 检查 $A\\!\\left[\\left\\lceil \\dfrac{j}{d} \\right\\rceil\\right] \\ge A[j]$。如果任何检查失败，则返回 $\\text{false}$；否则返回 $\\text{true}$。时间复杂度：$O(n)$。\n\nD. 将 $i$ 从 $0$ 迭代到 $\\left\\lfloor \\dfrac{n}{d} \\right\\rfloor$。对于每个 $i$，将 $j$ 从 $d i$ 迭代到 $\\min(d i + d - 1, n - 1)$ 并检查 $A[i] \\ge A[j]$。如果任何检查失败，则返回 $\\text{false}$；否则返回 $\\text{true}$。时间复杂度：$O(n)$。", "solution": "问题要求一个在 $O(n)$ 时间内运行的算法，以确定一个给定的长度为 $n$ 的数组 $A$ 是否表示一个有效的 $d$ 叉最大堆，使用从 $0$ 开始的索引。\n\n### 第 1 步：提取已知条件\n-   一个长度为 $n$ 的数组 $A$。\n-   数组使用从 $0$ 开始的索引。\n-   一个整数分支因子 $d \\ge 2$。\n-   数组表示一个完全 $d$ 叉树。\n-   $d$ 叉最大堆属性：每个节点的键大于或等于其所有子节点的键。\n-   算法必须在 $O(n)$ 时间内运行。\n\n### 第 2 步：验证问题陈述\n问题陈述是明确的，并且基于关于数据结构的标准计算机科学原理。一个完全 $d$ 叉树的数组表示是一个标准概念，其中节点按层存储。父索引和子索引之间的关系可以通过数学推导得出。任务是为所有父子对验证局部堆属性。这是一个清晰、客观且可解决的问题。$O(n)$ 的时间复杂度约束是问题的关键部分。问题是有效的。\n\n### 第 3 步：从第一性原理推导\n\n为了验证数组 $A$ 表示一个有效的 $d$ 叉最大堆，我们必须检查对于每个父节点 $i$，条件 $A[i] \\ge A[j]$ 对其所有子节点 $j$ 都成立。\n\n首先，我们必须为完全 $d$ 叉树的从 $0$ 开始的数组表示建立父节点和子节点之间的索引映射。\n- 树的根在索引 $0$ 处。\n- 索引为 $0$ 的节点的子节点位于索引 $1, 2, \\dots, d$ 处。\n- 索引为 $1$ 的节点的子节点位于索引 $d+1, \\dots, 2d$ 处。\n- 一般来说，对于索引为 $i$ 的节点，其子节点位于从 $d \\cdot i + 1$ 到 $d \\cdot i + d$ 的索引处。\n\n反过来，对于索引为 $j$ 的节点（其中 $j > 0$），其父节点位于索引 $p$ 处。$p$ 的子节点是 $d \\cdot p + 1, \\dots, d \\cdot p + d$。索引 $j$ 必须落在这个范围内。因此，$d \\cdot p + 1 \\le j \\le d \\cdot p + d$。这意味着 $d \\cdot p \\le j - 1  d \\cdot p + d$。两边除以 $d$ 得到 $p \\le \\frac{j-1}{d}  p+1$。因此，父节点索引是 $p = \\left\\lfloor \\frac{j-1}{d} \\right\\rfloor$。\n\n要验证堆属性，我们必须对所有子节点检查 $A[\\text{parent}] \\ge A[\\text{child}]$。这等同于对所有父节点及其各自的所有子节点检查 $A[\\text{parent}] \\ge A[\\text{child}]$。让我们采用后一种方法，因为大多数选项都采用了这种方法。\n\n算法必须遍历所有作为父节点的节点。如果节点 $i$ 的第一个子节点（索引为 $d \\cdot i + 1$）在数组边界内，那么它就是父节点。也就是说，$d \\cdot i + 1  n$。\n$d \\cdot i  n - 1$\n$i  \\frac{n-1}{d}$\n因为 $i$ 必须是整数，所以父节点的最大可能索引是 $\\left\\lfloor \\frac{n-2}{d} \\right\\rfloor$。我们来验证一下。数组中的最后一个元素在索引 $n-1$ 处。其父节点在索引 $\\left\\lfloor \\frac{(n-1)-1}{d} \\right\\rfloor = \\left\\lfloor \\frac{n-2}{d} \\right\\rfloor$ 处。任何索引大于此值的节点都不可能是数组内任何节点的父节点。因此，我们只需要检查范围 $0 \\le i \\le \\left\\lfloor \\frac{n-2}{d} \\right\\rfloor$ 内的节点 $i$。\n\n对于每个父节点 $i$，我们必须将其与其所有子节点进行比较。$i$ 的子节点位于从 $d \\cdot i + 1$ 到 $d \\cdot i + d$ 的索引 $j$ 处。然而，如果树不是满的，并非所有这些子节点都存在。数组长度为 $n$，所以索引最多到 $n-1$。因此，对于每个父节点 $i$，我们必须遍历其子节点 $j$，使得 $d \\cdot i + 1 \\le j \\le d \\cdot i + d$ 且 $j  n$。这个针对子节点 $j$ 的内层循环可以写成从 $d \\cdot i + 1$ 迭代到 $\\min(d \\cdot i + d, n-1)$。\n\n由此产生的算法如下：\n1.  用索引 $i$ 从 $0$ 迭代到 $\\left\\lfloor \\frac{n-2}{d} \\right\\rfloor$。\n2.  对于每个 $i$，用索引 $j$ 从 $d \\cdot i + 1$ 迭代到 $\\min(d \\cdot i + d, n-1)$。\n3.  在内层循环中，检查是否 $A[i]  A[j]$。如果此条件为真，则违反了最大堆属性，算法可以终止并返回 `false`。\n4.  如果循环完成而没有发现任何违规，则该数组是有效的最大堆，算法返回 `true`。\n\n让我们分析时间复杂度。执行的总比较次数等于由前 $n$ 个节点表示的树结构中的父子关系（边）的数量。一个有 $n$ 个节点的树有 $n-1$ 条边。每个非根节点（索引从 $1$ 到 $n-1$）只有一个父节点。该算法对这 $n-1$ 个节点中的每一个都与其父节点进行一次比较。因此，总比较次数是 $n-1$。总体时间复杂度是 $O(n)$。\n\n现在我们评估给出的选项。\n\n### 逐项分析选项\n\nA. 将 $i$ 从 $0$ 迭代到 $\\left\\lfloor \\dfrac{n - 2}{d} \\right\\rfloor$。对于每个 $i$，将 $j$ 从 $d i + 1$ 迭代到 $\\min(d i + d, n - 1)$。如果对于任何这样的 $j$ 有 $A[i]  A[j]$，则返回 $\\text{false}$；否则继续。如果所有检查都通过，则返回 $\\text{true}$。时间复杂度：$O(n)$。\n-   **父节点循环：** $i$ 的范围，从 $0$ 到 $\\left\\lfloor \\frac{n-2}{d} \\right\\rfloor$，正确地识别了堆中所有的父节点。\n-   **子节点循环：** $j$ 的范围，从 $d i + 1$ 迭代到 $\\min(d i + d, n-1)$，正确地识别了节点 $i$ 在大小为 $n$ 的数组中存在的所有子节点。对于一个包含性的循环，这个上界是正确的。例如，对于 $n=9, d=3$，最后一个父节点是 $i=\\lfloor(9-2)/3\\rfloor=2$。它的子节点应该从 $d\\cdot2+1=7$ 开始。数组的最后一个索引是 $8$。循环上界是 $\\min(3\\cdot2+3, 9-1)=\\min(9,8)=8$。因此，内循环正确地从 $j=7$ 迭代到 $8$。循环边界是正确的。\n-   **条件：** $A[i]  A[j]$ 正确地检查了是否违反了最大堆属性。\n-   **复杂度：** 分析表明该算法执行 $n-1$ 次比较，因此时间复杂度的确是 $O(n)$。\n-   **结论：** **正确**。\n\nB. 对每个内部节点 $i$，计算其整个子树中的最大值，并验证 $A[i] \\ge \\max\\{A[j] : j \\text{ 在以 } i \\text{ 为根的子树中}\\}$。如果任何检查失败，则返回 $\\text{false}$；否则返回 $\\text{true}$。时间复杂度：$O(n)$，因为每个子树被每个父节点扫描一次。\n-   **算法逻辑：** 验证父节点大于或等于其子树中的所有节点是确认堆属性的一种有效但更强的方式。如果局部属性成立，通过传递性，这个全局属性也成立。\n-   **复杂度分析：** $O(n)$ 复杂度的理由是有缺陷的。要检查根节点（$i=0$），必须扫描其整个子树，这包括所有 $n$ 个节点（或 $n-1$ 个其他节点）。这需要 $O(n)$ 时间。要检查第 1 层的节点，必须扫描其子树，其大小约为 $n/d$。有 $d$ 个这样的节点，为该层的总工作量贡献了 $d \\times O(n/d) = O(n)$。由于大约有 $\\log_d n$ 层的内部节点，总复杂度大约是 $\\sum_{k=0}^{\\log_d n} O(n) = O(n \\log_d n)$。一个深度为 $k$ 的节点是 $k+1$ 个子树（它自己的以及其祖先的子树）的一部分。总工作量是 $\\sum_{j=0}^{n-1} (\\text{depth of } j)$，对于一个完全树，这已知是 $O(n \\log n)$。声称的 $O(n)$ 是错误的。\n-   **结论：** **不正确**。该算法有效，但时间复杂度是 $O(n \\log n)$，而不是声称的 $O(n)$。\n\nC. 将 $j$ 从 $1$ 迭代到 $n - 1$，并对每个 $j$ 检查 $A\\!\\left[\\left\\lceil \\dfrac{j}{d} \\right\\rceil\\right] \\ge A[j]$。如果任何检查失败，则返回 $\\text{false}$；否则返回 $\\text{true}$。时间复杂度：$O(n)$。\n-   **算法逻辑：** 这种方法遍历每个子节点并将其与其父节点进行比较。这是一个有效的策略。时间复杂度显然是 $O(n)$，因为循环运行 $n-1$ 次，内部工作量为 $O(1)$。\n-   **父节点公式：** 关键元素是父节点索引的公式：$\\left\\lceil \\frac{j}{d} \\right\\rceil$。这个公式适用于从 $1$ 开始的索引方案。对于问题指定的从 $0$ 开始的索引，节点 $j$ 的父节点是 $\\left\\lfloor \\frac{j-1}{d} \\right\\rfloor$。让我们用 $d=2$ 和 $j=2$（根的第二个子节点）来测试给定的公式。正确的父节点索引是 $0$。该公式给出 $\\lceil \\frac{2}{2} \\rceil = 1$。这是不正确的。该算法将比较不处于父子关系中的节点。\n-   **结论：** **不正确**。用于查找父索引的公式对于从 $0$ 开始的索引是错误的。\n\nD. 将 $i$ 从 $0$ 迭代到 $\\left\\lfloor \\dfrac{n}{d} \\right\\rfloor$。对于每个 $i$，将 $j$ 从 $d i$ 迭代到 $\\min(d i + d - 1, n - 1)$ 并检查 $A[i] \\ge A[j]$。如果任何检查失败，则返回 $\\text{false}$；否则返回 $\\text{true}$。时间复杂度：$O(n)$。\n-   **父节点循环：** 父节点 `i` 的上界被指定为 $\\left\\lfloor \\frac{n}{d} \\right\\rfloor$。这与正确的界限 $\\left\\lfloor \\frac{n-2}{d} \\right\\rfloor$ 不同。虽然它会覆盖所有父节点，但根据 $n$ 和 $d$ 的值，它可能包含一些非父节点。\n-   **子节点循环：** 子节点 $j$ 的起始索引被指定为 $di$。节点 $i$ 的第一个子节点在索引 $di+1$ 处。索引 $di$ 是完全不同的一个节点（在树中通常是“堂兄弟”或“叔伯”节点）。对于 $i>0$，节点 $di$ 是节点 $i-1$ 的最后一个子节点。算法会错误地检查 $A[i] \\ge A[di]$，这不是堆属性的要求。例如，如果 $d=2$，$A = [100, 20, 90, \\dots]$。根的堆属性得到满足（$100 \\ge 20, 100 \\ge 90$）。节点 $i=1$（值为 $20$）的子节点从索引 $2(1)+1=3$ 开始。该算法会检查 $A[1] \\ge A[2]$，即 $20 \\ge 90$，并错误地报告违规。\n-   **结论：** **不正确**。该算法检查了不正确的节点对，因为子节点的内层循环从错误的索引开始。\n\n根据分析，只有选项 A 正确描述了一个具有适当时间复杂度的有效算法。", "answer": "$$\\boxed{A}$$", "id": "3225698"}, {"introduction": "这道题将引导你超越简单的验证，对 `build_heap` 算法进行严格的最坏情况分析。通过推导比较次数的精确公式，你将更深刻地体会到自底向上建堆过程的效率，并练习形式化算法分析中使用的数学技巧。请注意，该问题设定了一个完美的 d 叉树这一理想化场景，旨在简化推导过程，让你能专注于分析方法本身。[@problem_id:3225640]", "problem": "给定一个d叉最大堆（其中 $d \\ge 2$），它使用从0开始的索引存储在一个连续数组中。对于每个索引 $i$，其子节点是仍在数组边界内的索引 $d i + 1, d i + 2, \\ldots, d i + d$。考虑自底向上的堆构建过程（通常称为Floyd建堆算法）：从最后一个内部节点开始向上直到根节点，对每个节点 $i$ 执行一次筛选下沉（sift-down）操作。该操作会重复地将节点 $i$ 处的键与其子节点中较大的一个进行替换，前提是该子节点大于当前键。节点 $i$ 的筛选下沉操作会逐层进行，直到该键到达一个其所有现有子节点都比它小或者到达一个叶节点的位置。使用以下成本模型：\n\n- 两个键之间的每次比较成本为 $1$。\n- 在任何具有 $k$ 个现有子节点的节点上，确定最大的子节点需要恰好 $k-1$ 次比较。\n- 选出最大的子节点后，将当前键与该子节点进行比较需要恰好 $1$ 次比较。\n\n假设输入大小 $n$ 等于一个高度为 $H \\ge 1$ 且最后一层完全填满的完全d叉树的节点数，即 \n$$\nn \\;=\\; \\frac{d^{H+1} - 1}{d - 1}.\n$$\n在这种建堆过程的最坏情况下（即每次筛选下沉都下降到叶节点层级），请仅根据 $n$ 和 $d$，从基本原理出发，推导出整个建堆过程所执行的键比较总数的一个精确闭式表达式。你的最终答案必须是一个只包含 $n$ 和 $d$ 的单一闭式解析表达式（不得包含未求值的和或极限）。不要进行近似或四舍五入。", "solution": "问题要求在对一个具有 $n$ 个节点且最后一层完全填满的完全d叉树进行自底向上d叉堆构建的最坏情况下，键比较的总次数。\n\n首先，让我们确定题目所指定的树的结构和算法的成本模型。\n\n该树是一个高度为 $H \\ge 1$ 的完全d叉树，根节点位于层级 $h=0$，叶节点位于层级 $h=H$。任何层级 $h$ 的节点数为 $d^h$。总节点数 $n$ 是从层级 $0$ 到 $H$ 所有节点数的总和：\n$$n = \\sum_{h=0}^{H} d^h = \\frac{d^{H+1} - 1}{d - 1}$$\n这与给定的 $n$ 的公式相符。\n\n建堆算法从最后一个内部节点开始，向上遍历至根节点。对于本问题，内部节点是所有非叶节点，即位于层级 $h=0, 1, \\ldots, H-1$ 的节点。对于每个内部节点，算法都会执行一次筛选下沉操作。\n\n从节点 $i$ 开始的单次筛选下沉操作的成本由比较次数决定。问题定义了最坏情况，即节点 $i$ 处的键一直被筛选下沉到叶节点。键下沉的层数等于节点 $i$ 的高度。位于层级 $h$ 的节点的高度是 $H-h$。\n\n在筛选下沉的每一步中，临时节点上的键都将与其子节点进行比较。由于该树是完全的且最后一层是满的，筛选下沉路径上的任何节点（非叶节点）都将恰好有 $d$ 个子节点。成本模型指定：\n1.  在 $d$ 个子节点中找到最大值需要 $d-1$ 次比较。\n2.  将当前键与这个最大的子节点比较需要 $1$ 次比较。\n\n因此，在筛选下沉中每下降一层需要 $(d-1) + 1 = d$ 次比较。\n对于一个位于层级 $h$ 的节点，其高度为 $H-h$。从该节点开始的最坏情况筛选下沉涉及 $H-h$ 个下沉步骤。因此，对一个位于层级 $h$ 的节点进行筛选下沉的总成本是 $d \\times (H-h)$。\n\n整个建堆过程的总比较次数 $C$ 是对所有内部节点进行筛选下沉的成本之和。\n$$C = \\sum_{\\text{internal nodes } i} (\\text{cost to sift-down } i)$$\n我们可以按层级 $h$ 对节点进行分组。层级 $h$ 有 $d^h$ 个节点。内部节点位于层级 $h=0, 1, \\ldots, H-1$。\n$$C = \\sum_{h=0}^{H-1} (\\text{number of nodes at level } h) \\times (\\text{cost for a node at level } h)$$\n$$C = \\sum_{h=0}^{H-1} d^h \\cdot [d(H-h)] = d \\sum_{h=0}^{H-1} d^h(H-h)$$\n\n和式 $\\sum_{h=0}^{H-1} d^h(H-h)$ 代表所有内部节点的高度之和。由于叶节点（位于层级 $H$）的高度为 $H-H=0$，这个和式等价于树中所有节点的高度之和。设此和为 $S_{H}$。\n$$S_H = \\sum_{h=0}^{H} d^h(H-h)$$\n让我们从基本原理出发计算这个和。我们可以将和式拆分：\n$$S_H = H \\sum_{h=0}^{H} d^h - \\sum_{h=0}^{H} h d^h$$\n第一项包含一个标准的几何级数：\n$$H \\sum_{h=0}^{H} d^h = H \\left(\\frac{d^{H+1}-1}{d-1}\\right) = Hn$$\n第二项是一个算术-几何级数，$A_H = \\sum_{h=0}^{H} h d^h = \\sum_{h=1}^{H} h d^h$。我们可以使用一种涉及几何级数导数的著名技巧来计算这个级数。令 $G(x) = \\sum_{h=0}^{H} x^h = \\frac{x^{H+1}-1}{x-1}$。\n那么 $\\sum_{h=0}^{H} h x^h = x \\frac{d}{dx}G(x)$。\n$$\\frac{dG(x)}{dx} = \\frac{(H+1)x^H(x-1) - (x^{H+1}-1)(1)}{(x-1)^2} = \\frac{(H+1)x^{H+1} - (H+1)x^H - x^{H+1} + 1}{(x-1)^2} = \\frac{Hx^{H+1} - (H+1)x^H + 1}{(x-1)^2}$$\n乘以 $x$ 并设 $x=d$：\n$$A_H = \\sum_{h=1}^{H} h d^h = d \\frac{Hd^{H+1} - (H+1)d^H + 1}{(d-1)^2} = \\frac{Hd^{H+2} - (H+1)d^{H+1} + d}{(d-1)^2}$$\n现在，将此结果代入 $S_H$ 的表达式中：\n$$S_H = Hn - A_H = H\\frac{d^{H+1}-1}{d-1} - \\frac{Hd^{H+2} - (H+1)d^{H+1} + d}{(d-1)^2}$$\n为了合并这些项，我们将它们通分到共同的分母 $(d-1)^2$ 上：\n$$S_H = \\frac{H(d^{H+1}-1)(d-1) - [Hd^{H+2} - (H+1)d^{H+1} + d]}{(d-1)^2}$$\n让我们展开分子：\n$$\n\\begin{align*}\n\\text{Numerator} = H(d^{H+2} - d^{H+1} - d + 1) - Hd^{H+2} + (H+1)d^{H+1} - d \\\\\n= Hd^{H+2} - Hd^{H+1} - Hd + H - Hd^{H+2} + Hd^{H+1} + d^{H+1} - d \\\\\n= d^{H+1} - Hd + H - d \\\\\n= d^{H+1} - H(d-1) - d\n\\end{align*}\n$$\n所以，高度之和为：\n$$S_H = \\frac{d^{H+1} - H(d-1) - d}{(d-1)^2}$$\n我们可以通过代入 $n$ 的关系式来简化这个表达式。由 $n = \\frac{d^{H+1}-1}{d-1}$，我们得到 $d^{H+1} = n(d-1)+1$。\n$$S_H = \\frac{(n(d-1)+1) - H(d-1) - d}{(d-1)^2} = \\frac{n(d-1) - H(d-1) - (d-1)}{(d-1)^2} = \\frac{(n - H - 1)(d-1)}{(d-1)^2} = \\frac{n-H-1}{d-1}$$\n总比较次数为 $C = d \\cdot S_H$。\n$$C = d \\left(\\frac{n-H-1}{d-1}\\right)$$\n最后一步是用 $n$ 和 $d$ 来表示 $H$。由 $d^{H+1} = n(d-1)+1$，我们对等式两边取以 $d$ 为底的对数：\n$$\\log_d(d^{H+1}) = \\log_d(n(d-1)+1)$$\n$$H+1 = \\log_d(n(d-1)+1)$$\n$$H = \\log_d(n(d-1)+1) - 1$$\n将 $H$ 的这个表达式代入我们的 $C$ 公式中：\n$$C = \\frac{d}{d-1} \\left( n - \\left( \\log_d(n(d-1)+1) - 1 \\right) - 1 \\right)$$\n$$C = \\frac{d}{d-1} \\left( n - \\log_d(n(d-1)+1) + 1 - 1 \\right)$$\n$$C = \\frac{d}{d-1} \\left( n - \\log_d(n(d-1)+1) \\right)$$\n这就是以 $n$ 和 $d$ 表示的总比较次数的最终闭式表达式。", "answer": "$$ \\boxed{ \\frac{d\\left(n - \\log_{d}\\left(n(d-1)+1\\right)\\right)}{d-1} } $$", "id": "3225640"}, {"introduction": "最后的这项实践将理论与应用联系起来，要求你对一个真实世界中的性能优化问题进行建模。你将分析与分支因子 $d$ 相关的权衡，并建立一个成本模型，以确定在给定工作负载下的最优 $d$ 值。这个练习展示了理论分析如何指导实际的工程决策，例如针对特定硬件和使用模式调整数据结构。[@problem_id:3225717]", "problem": "您需要设计并实现一个完整的、可运行的程序。该程序在给定一组特定于机器的成本参数和工作负载权重后，会选择一个 $d$ 叉堆的叉数 $d$，以最小化一个基于最坏情况和基本操作的成本模型。目标是以一种受控、可复现的方式模拟一项实证研究，方法是使用一个有原则的成本模型，该模型将中央处理器（CPU）、缓存层次结构和随机存取存储器（RAM）带宽的影响抽象为基本操作成本。您的程序不得执行任何计时测量；相反，它必须使用一个基于标准定义推导出的解析模型来计算使成本最小化的 $d$。\n\n使用的基本原理：\n- $d$ 叉堆是一个以层序存储在数组中的完全树。其高度是最小的整数 $L$，使得一个分支因子为 $d$、高度为 $L$ 的树至少可以容纳 $n$ 个节点。等价地，$L$ 是满足 $d^{L} \\ge n$ 的最小整数，这意味着对于 $n \\ge 1$，$L = \\lceil \\log_{d} n \\rceil$。\n- 索引为 $i$ 的节点（使用从零开始的索引）的父节点位于索引 $\\left\\lfloor \\dfrac{i-1}{d} \\right\\rfloor$，其子节点位于索引 $d\\cdot i + j$，其中 $j \\in \\{1,2,\\dots,d\\}$，前提是这些索引存在于数组中。\n- 基于 $d$ 叉最小堆构建的标准优先队列的操作语义：\n  - 减小键值（decrease-key）和插入（insert）操作都可能通过与父节点反复比较和交换，将一个键向上移动，直到恢复堆属性。在最坏情况下，向上移动的次数等于高度 $L$。\n  - 提取最小值（extract-min）操作会移除根节点，换入最后一个元素，然后通过在最多 $d$ 个子节点中反复选择最小的子节点并向下交换，来恢复堆属性，直到堆属性被恢复。在最坏情况下，向下移动的次数等于高度 $L$。\n\n使用的成本模型：\n- 只计算两种基本成本：\n  - $c_{c}$：每次键比较的成本。\n  - $c_{s}$：每次交换两个键的成本（将一次交换视为具有此成本的单个基本操作；内部赋值和内存流量被抽象到 $c_{s}$ 中）。\n- 每次操作的最坏情况基本计数，由操作语义证明：\n  - 插入和减小键值：最多向上遍历 $L$ 层，执行最多 $L$ 次比较和 $L$ 次交换。\n  - 提取最小值：一次固定的交换以移除根节点并将最后一个元素置于根部，外加最多向下遍历 $L$ 层。在每一层，从最多 $d$ 个子节点中选择最小的子节点，执行最多 $d-1$ 次比较，然后进行一次交换以将空位向下移动。\n- 工作负载模型：\n  - 设 $w_{\\mathrm{ex}}$、$w_{\\mathrm{in}}$ 和 $w_{\\mathrm{dec}}$ 为非负权重，分别表示提取最小值、插入和减小键值操作的相对频率。您可以假设 $w_{\\mathrm{ex}} + w_{\\mathrm{in}} + w_{\\mathrm{dec}} > 0$。\n  - 对于给定的 $d$，每次操作的最坏情况加权成本是相应基本操作计数乘以基本成本的加权和。\n\n任务：\n- 仅使用上述基本原理和最坏情况推理，推导出一个关于 $d$、$n$、$c_{c}$、$c_{s}$、$w_{\\mathrm{ex}}$、$w_{\\mathrm{in}}$ 和 $w_{\\mathrm{dec}}$ 的每次操作最坏情况加权成本的表达式。推导过程必须源自所述语义。不要假设任何平均情况行为。\n- 实现一个程序，该程序：\n  - 对于每个测试用例，考虑 $[2, d_{\\max}]$ 闭区间内的所有整数 $d$。\n  - 计算堆高度 $L(d,n) = \\lceil \\log_{d} n \\rceil$，并遵循 $L(d,1) = 0$ 的约定。\n  - 使用您推导的计数以及提供的基本成本和权重，计算该 $d$ 值的最坏情况加权成本。\n  - 选择使此成本最小化的 $d$。如果出现平局，选择最小的 $d$。\n  - 为每个测试用例输出所选的 $d$。\n- 输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3]”）。\n\n测试套件：\n- 每个测试用例是一个元组 $(n, w_{\\mathrm{ex}}, w_{\\mathrm{in}}, w_{\\mathrm{dec}}, c_{c}, c_{s}, d_{\\max})$，具有以下特定值。所有数字都是精确且无单位的。\n  - 用例 1：$(n=\\,$$1$$,\\, w_{\\mathrm{ex}}=\\,$$1.0$$,\\, w_{\\mathrm{in}}=\\,$$0.0$$,\\, w_{\\mathrm{dec}}=\\,$$0.0$$,\\, c_{c}=\\,$$5.0$$,\\, c_{s}=\\,$$10.0$$,\\, d_{\\max}=\\,$$16$$)$\n  - 用例 2：$(n=\\,$$1000000$$,\\, w_{\\mathrm{ex}}=\\,$$0.6$$,\\, w_{\\mathrm{in}}=\\,$$0.3$$,\\, w_{\\mathrm{dec}}=\\,$$0.1$$,\\, c_{c}=\\,$$3.0$$,\\, c_{s}=\\,$$8.0$$,\\, d_{\\max}=\\,$$32$$)$\n  - 用例 3：$(n=\\,$$1000000$$,\\, w_{\\mathrm{ex}}=\\,$$0.8$$,\\, w_{\\mathrm{in}}=\\,$$0.1$$,\\, w_{\\mathrm{dec}}=\\,$$0.1$$,\\, c_{c}=\\,$$50.0$$,\\, c_{s}=\\,$$5.0$$,\\, d_{\\max}=\\,$$16$$)$\n  - 用例 4：$(n=\\,$$5000000$$,\\, w_{\\mathrm{ex}}=\\,$$0.2$$,\\, w_{\\mathrm{in}}=\\,$$0.6$$,\\, w_{\\mathrm{dec}}=\\,$$0.2$$,\\, c_{c}=\\,$$2.0$$,\\, c_{s}=\\,$$40.0$$,\\, d_{\\max}=\\,$$64$$)$\n  - 用例 5：$(n=\\,$$1000$$,\\, w_{\\mathrm{ex}}=\\,$$1.0$$,\\, w_{\\mathrm{in}}=\\,$$0.0$$,\\, w_{\\mathrm{dec}}=\\,$$0.0$$,\\, c_{c}=\\,$$1.0$$,\\, c_{s}=\\,$$1.0$$,\\, d_{\\max}=\\,$$2$$)$\n\n答案规格：\n- 您的程序必须为上述五个用例中的每一个计算出最小化成本的 $d$，并按顺序将它们打印为单行，格式完全符合指定要求。", "solution": "用户要求设计一个程序，为 $d$ 叉堆找到最优的叉数 $d$，以最小化一个基于最坏情况的操作成本模型。此过程首先对问题陈述进行形式化验证，然后推导成本函数并加以实现。\n\n### 问题验证\n\n**第1步：提取已知条件**\n\n*   **堆结构**：一个 $d$ 叉堆是一个存储在数组中的完全树。\n*   **堆高度 ($L$)**：对于 $n \\ge 1$，$L = \\lceil \\log_{d} n \\rceil$。给定一个特殊约定：$L(d, 1) = 0$。\n*   **父/子索引（从0开始）**：节点 $i$ 的父节点是 $\\lfloor(i-1)/d\\rfloor$。子节点是 $d \\cdot i + j$，其中 $j \\in \\{1, 2, \\dots, d\\}$。\n*   **操作语义（最坏情况）**：\n    *   `insert` / `decrease-key`：$L$ 次比较和 $L$ 次交换。\n    *   `extract-min`：1 次固定的交换，加上 $L$ 次向下步骤。每个向下步骤涉及最多 $d-1$ 次比较和 1 次交换。\n*   **成本基元**：\n    *   $c_c$：每次键比较的成本。\n    *   $c_s$：每次键交换的成本。\n*   **工作负载模型**：\n    *   $w_{\\mathrm{ex}}$、$w_{\\mathrm{in}}$、$w_{\\mathrm{dec}}$：`extract-min`、`insert` 和 `decrease-key` 操作的非负权重，且 $w_{\\mathrm{ex}} + w_{\\mathrm{in}} + w_{\\mathrm{dec}} > 0$。\n*   **目标**：对于每个测试用例，找到整数 $d \\in [2, d_{\\max}]$，以最小化最坏情况下的加权成本。平局时选择最小的 $d$。\n*   **测试套件**：提供了五个测试用例，包含 $(n, w_{\\mathrm{ex}}, w_{\\mathrm{in}}, w_{\\mathrm{dec}}, c_{c}, c_{s}, d_{\\max})$ 的具体值。\n\n**第2步：使用提取的已知条件进行验证**\n\n根据验证标准分析问题陈述。\n\n*   **科学基础**：该问题基于 $d$ 叉堆这一标准且成熟的数据结构。成本模型是算法分析中常用且有效的抽象，用于在不进行直接机器计时的情况下对性能进行建模。它在科学上和算法上都是合理的。\n*   **良构性**：问题定义清晰。目标是在整数 $d \\in [2, d_{\\max}]$ 的有限离散域上找到一个函数的最小值。最小值保证存在。平局决胜规则（选择最小的 $d$）确保了解决方案的唯一性。\n*   **目标明确**：语言精确且数学化。所有参数和约束都进行了量化定义。\n*   **完整性与一致性**：问题提供了推导成本函数和执行所需搜索所必需的所有数据和定义。对 $n=1$ 的约定已明确说明，避免了歧义。不存在矛盾。\n\n**第3步：结论与行动**\n\n问题是**有效的**。它自成体系、有科学依据、良构，并且为其解决提供了所有必要信息。可以开始求解过程。\n\n### 最坏情况加权成本函数的推导\n\n目标是推导出每次操作的总最坏情况加权成本，记为 $C(d)$，作为叉数 $d$ 和给定参数的函数。此推导直接遵循问题陈述中指定的基本操作成本。\n\n1.  **堆高度**：对于 $n$ 个元素和叉数 $d$，堆的高度由 $L(d, n) = \\lceil \\log_{d} n \\rceil$ 给出。对于特殊情况 $n=1$，$L(d, 1) = \\lceil \\log_{d} 1 \\rceil = \\lceil 0 \\rceil = 0$，这与提供的约定一致。\n\n2.  **单个操作的成本**：我们通过对其组成的基本操作（比较和交换）的成本求和来确定每种操作类型的最坏情况成本。\n\n    *   **插入和减小键值**：问题陈述指出，在最坏情况下，一个元素会向上移动整个树的高度。这涉及 $L(d, n)$ 层。在每一层，会发生一次与父节点的比较和一次交换。\n        `insert` 操作的成本 $C_{\\mathrm{in}}(d)$ 为：\n        $$C_{\\mathrm{in}}(d) = L(d, n) \\cdot c_c + L(d, n) \\cdot c_s = L(d, n) (c_c + c_s)$$\n        同样，`decrease-key` 操作的成本 $C_{\\mathrm{dec}}(d)$ 为：\n        $$C_{\\mathrm{dec}}(d) = L(d, n) \\cdot c_c + L(d, n) \\cdot c_s = L(d, n) (c_c + c_s)$$\n\n    *   **提取最小值**：此操作包括两个阶段。首先，根节点被堆中的最后一个元素替换，这需要一次交换。其次，新的根元素“向下筛选”以恢复堆属性。这个向下遍历最多覆盖 $L(d, n)$ 层。在每一层，该元素与其最多 $d$ 个子节点进行比较以找到最小值，这需要最多 $d-1$ 次比较。然后，与最小的子节点进行一次交换。\n        `extract-min` 操作的成本 $C_{\\mathrm{ex}}(d)$ 是初始交换和向下筛选过程的成本之和：\n        $$C_{\\mathrm{ex}}(d) = (1 \\cdot c_s) + L(d, n) \\cdot ((d-1) \\cdot c_c + 1 \\cdot c_s)$$\n        $$C_{\\mathrm{ex}}(d) = c_s + L(d, n) ((d-1)c_c + c_s)$$\n\n3.  **总加权成本函数**：总最坏情况加权成本 $C(d)$ 是每个操作的成本乘以其各自权重的总和。\n    $$C(d) = w_{\\mathrm{ex}} \\cdot C_{\\mathrm{ex}}(d) + w_{\\mathrm{in}} \\cdot C_{\\mathrm{in}}(d) + w_{\\mathrm{dec}} \\cdot C_{\\mathrm{dec}}(d)$$\n    代入上面推导出的表达式：\n    $$ C(d) = w_{\\mathrm{ex}} \\left(c_s + L(d, n) ((d-1)c_c + c_s)\\right) + w_{\\mathrm{in}} \\left(L(d, n) (c_c + c_s)\\right) + w_{\\mathrm{dec}} \\left(L(d, n) (c_c + c_s)\\right) $$\n    我们可以提出因子 $L(d, n)$ 来简化表达式：\n    $$ C(d) = w_{\\mathrm{ex}} c_s + L(d, n) \\left[ w_{\\mathrm{ex}} ((d-1)c_c + c_s) + (w_{\\mathrm{in}} + w_{\\mathrm{dec}})(c_c + c_s) \\right] $$\n    让我们在方括号内按 $c_c$ 和 $c_s$ 展开并分组项：\n    $$ \\left[ w_{\\mathrm{ex}}(d-1)c_c + w_{\\mathrm{ex}}c_s + (w_{\\mathrm{in}} + w_{\\mathrm{dec}})c_c + (w_{\\mathrm{in}} + w_{\\mathrm{dec}})c_s \\right] $$\n    $$ = c_c \\left( w_{\\mathrm{ex}}(d-1) + w_{\\mathrm{in}} + w_{\\mathrm{dec}} \\right) + c_s \\left( w_{\\mathrm{ex}} + w_{\\mathrm{in}} + w_{\\mathrm{dec}} \\right) $$\n    这就得出了总最坏情况加权成本的最终解析表达式：\n    $$ C(d) = w_{\\mathrm{ex}} c_s + \\lceil \\log_{d} n \\rceil \\left[ c_c \\left( w_{\\mathrm{ex}}(d-1) + w_{\\mathrm{in}} + w_{\\mathrm{dec}} \\right) + c_s \\left( w_{\\mathrm{ex}} + w_{\\mathrm{in}} + w_{\\mathrm{dec}} \\right) \\right] $$\n    对于 $[2, d_{\\max}]$ 范围内的每个整数 $d$，将对此函数进行求值，以找到使 $C(d)$ 最小化的 $d$ 值。对数向上取整 $\\lceil \\log_{d} n \\rceil$ 可以使用任何方便的对数底（例如，自然对数）计算为 `ceil(log(n) / log(d))`。\n\n### 最小化过程\n\n对于每个测试用例，我们将遍历从 $2$ 到 $d_{\\max}$（含）的所有可能的整数值 $d$。在每次迭代中，我们使用推导出的公式计算成本 $C(d)$。我们记录迄今为止找到的最小成本以及对应的 $d$ 值。如果新计算的给定 $d$ 的成本严格小于当前最小值，我们就更新最小成本和最优 $d$。这个过程自然地遵守了选择最小 $d$ 的平局决胜规则，因为较小的 $d$ 值会先被评估。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the optimal arity 'd' for a d-ary heap for a given set of\n    test cases based on a worst-case operational cost model.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (n, w_ex, w_in, w_dec, c_c, c_s, d_max)\n    test_cases = [\n        (1, 1.0, 0.0, 0.0, 5.0, 10.0, 16),\n        (1000000, 0.6, 0.3, 0.1, 3.0, 8.0, 32),\n        (1000000, 0.8, 0.1, 0.1, 50.0, 5.0, 16),\n        (5000000, 0.2, 0.6, 0.2, 2.0, 40.0, 64),\n        (1000, 1.0, 0.0, 0.0, 1.0, 1.0, 2),\n    ]\n\n    results = []\n    for case in test_cases:\n        n, w_ex, w_in, w_dec, c_c, c_s, d_max = case\n\n        min_cost = float('inf')\n        best_d = -1\n\n        # Iterate through all possible arities d from 2 to d_max (inclusive).\n        for d in range(2, d_max + 1):\n            # Calculate heap height L(d, n).\n            # L = ceil(log_d(n)).\n            # Per problem spec, L(d, 1) is 0.\n            if n == 1:\n                L = 0\n            else:\n                # Use numpy for safe floating point logarithm calculation.\n                # np.ceil returns a float, so cast to int.\n                L = int(np.ceil(np.log(n) / np.log(d)))\n\n            # From the derivation, the total weighted cost C(d) is:\n            # C(d) = w_ex * c_s + L * [c_c * (w_ex * (d-1) + w_in + w_dec) + c_s * (w_ex + w_in + w_dec)]\n\n            # Pre-calculate terms for clarity.\n            total_weight = w_ex + w_in + w_dec\n            comparison_workload = w_ex * (d - 1) + w_in + w_dec\n            \n            # Cost from comparisons and swaps during sift-up/sift-down.\n            variable_cost_per_level = c_c * comparison_workload + c_s * total_weight\n            \n            # Total cost is the fixed cost of extract-min plus the height-dependent costs.\n            cost = w_ex * c_s + L * variable_cost_per_level\n\n            # Check if this d yields a new minimum cost.\n            # The problem asks to choose the smallest d in case of a tie.\n            # By using '' and iterating d in increasing order, the first d\n            # that achieves the minimum cost will be retained if a later d\n            # produces the same cost, fulfilling the tie-breaker rule.\n            if cost  min_cost:\n                min_cost = cost\n                best_d = d\n        \n        results.append(best_d)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3225717"}]}