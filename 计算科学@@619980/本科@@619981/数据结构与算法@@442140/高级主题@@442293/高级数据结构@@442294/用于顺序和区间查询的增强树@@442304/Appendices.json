{"hands_on_practices": [{"introduction": "理论知识是基础，但真正的掌握来自于实践。本节我们将通过一系列动手实践来深化对增强树的理解。首先，我们来解决一个基本但非常普遍的问题：如何在动态数据集中高效地计算任意区间的元素之和。朴素的方法（例如遍历区间内的所有元素）在大型数据集上效率低下。通过为平衡二叉搜索树的每个节点增加一个简单的增强——子树所有键的总和——我们可以将查询时间从线性级别优化到对数级别 [@problem_id:3210369]。这个练习将帮助你掌握增强树的核心思想：如何通过维护聚合信息来加速查询。", "problem": "设计并实现一棵增强的平衡二叉搜索树 (BBST)，该树支持整数键，允许通过多次插入相同值来处理重复键，并能在每次操作的渐进时间 $O(\\log n)$ 内回答区间和查询，其中 $n$ 是计入重复次数的已插入元素总数。从二叉搜索树的基本原理出发，即对于任何键为 $k$ 的节点，其左子树中的所有键都严格小于 $k$，右子树中的所有键都严格大于 $k$；并且平衡树能确保树的高度为 $O(\\log n)$。允许进行增强，前提是增强的属性源自 BBST 结构及其不变性。\n\n您的程序必须在此类树上构建并维护以下针对整数键的操作：\n\n- 将键 $x$ 插入树中。插入一个与现有键相等的键会使其重复次数增加 $1$。\n- 从树中删除一个键 $x$。删除一个键会使其重复次数减少 $1$，如果重复次数变为 $0$，则从树中移除该键。\n- 计算位于闭区间 $[low, high]$ 内的所有键的总和（计入重复次数）。\n\n您必须设计增强方案，使得在 BBST 上对 $[low, high]$ 的区间和查询能在渐进时间 $O(\\log n)$ 内完成。解决方案必须从二叉搜索树的不变性和平衡高度属性推导而来，不得依赖任何特殊的内置数据结构。\n\n测试套件。您的程序必须按顺序执行以下场景，并汇总所有查询的输出：\n\n场景 $\\mathsf{A}$（一般情况、插入、删除和查询）：\n- 按顺序 $[5,3,8,1,4,7,9]$ 插入键来初始化树。\n- 查询 $[3,8]$ 范围内的总和。\n- 删除键 $4$。\n- 查询 $[3,8]$ 范围内的总和。\n\n场景 $\\mathsf{B}$（边界条件：空树、负值和无效范围）：\n- 初始化一棵空树。\n- 查询 $[0,10]$ 范围内的总和。\n- 插入键 $-2$。\n- 查询 $[-5,-1]$ 范围内的总和。\n- 查询 $[2,1]$ 范围内的总和（注意这是一个无效范围，因为 $low > high$；定义结果为 $0$）。\n\n场景 $\\mathsf{C}$（重复项和选择性删除）：\n- 按顺序 $[2,2,2,3,3,10]$ 插入键来初始化树。\n- 查询 $[2,3]$ 范围内的总和。\n- 删除一次键 $2$。\n- 查询 $[2,2]$ 范围内的总和。\n\n场景 $\\mathsf{D}$（范围完全覆盖当前集合，以及删除的影响）：\n- 按顺序 $[0,-5,5,1]$ 插入键来初始化树。\n- 查询 $[-10,10]$ 范围内的总和。\n- 删除键 $1$。\n- 查询 $[-10,10]$ 范围内的总和。\n\n最终输出格式。您的程序应生成单行输出，其中包含按顺序排列的所有查询结果，格式为一个由方括号括起来的逗号分隔列表，例如 `[result_1,result_2,...]`。每个查询的输出必须是整数。本问题不涉及物理单位，也没有角度或百分比。", "solution": "经评估，用户提供的问题是 **有效的**。这是一个来自数据结构与算法领域的、定义明确且具有科学依据的问题，不包含矛盾、歧义或不成立的前提。该问题可以通过形式化推导并实现一棵增强的平衡二叉搜索树 (BBST) 来解决。\n\n任务是设计一棵 BBST，使其支持对整数键的插入、删除和区间和查询操作，所有操作的渐进时间复杂度均为 $O(\\log n)$，其中 $n$ 是包含重复项在内的元素总数。\n\n### 原理与设计\n\n标准的二叉搜索树 (BST) 维护着一个不变性：对于任何键为 $k$ 的节点，其左子树中的所有键都小于 $k$，右子树中的所有键都大于 $k$。为了处理重复键，我们可以增强每个节点，使其存储一个重复次数或计数。平衡二叉搜索树（例如，AVL 树或红黑树）进一步保证树的高度保持在 $O(\\log n)$，从而确保了基于遍历的操作（如搜索、插入和删除）的高效性。\n\n要在 $O(\\log n)$ 时间内回答闭区间 $[low, high]$ 的区间和查询，标准的 BST 是不够的，因为它需要中序遍历，时间复杂度为 $O(k + \\log n)$，其中 $k$ 是区间内的元素数量。关键在于用额外信息来增强树节点，从而允许在不访问区间内每个节点的情况下计算总和。\n\n对 $[low, high]$ 内总和的查询可以分解为两个更基本的查询：\n$$ \\text{RangeSum}(low, high) = \\text{Sum}(\\leq high) - \\text{Sum}(\\leq low - 1) $$\n其中 $\\text{Sum}(\\leq k)$ 是树中所有小于或等于 $k$ 的键的总和。如果我们能在 $O(\\log n)$ 时间内计算出 $\\text{Sum}(\\leq k)$，那么区间和查询也能在 $O(\\log n)$ 时间内解决。\n\n为实现这一目标，我们为 BBST 中的每个节点 $v$ 增强以下信息：\n1. `v.key`：存储在节点上的整数键。\n2. `v.count`：键 `v.key` 的重复次数。\n3. `v.left`, `v.right`：指向左、右子节点的指针。\n4. `v.height`：以 $v$ 为根的子树的高度（用于平衡，例如在 AVL 树中）。\n5. `v.subtree_sum`：以 $v$ 为根的子树中所有键的总和，计入重复次数。\n\n关键的增强是 `v.subtree_sum`。这个值可以递归地维护。对于任何节点 $v$，其 `subtree_sum` 定义为：\n$$ v.subtree\\_sum = (v.key \\times v.count) + (v.left.subtree\\_sum \\text{ if } v.left) + (v.right.subtree\\_sum \\text{ if } v.right) $$\n其中，如果子节点为空，其子树总和为 $0$。\n\n这个增强属性可以在插入和删除操作期间进行维护。当插入或删除节点，或为再平衡执行旋转时，受影响的节点及其祖先的 `subtree_sum` 必须更新。由于这些操作只修改从根到叶子的一条路径（并在旋转时涉及常数数量的节点），更新操作耗时 $O(\\log n)$，因此保持了插入和删除的整体时间复杂度。\n\n### $\\text{Sum}(\\leq k)$ 的算法\n\n有了 `subtree_sum` 增强，我们可以通过遍历从根开始的一条路径，在 $O(\\log n)$ 时间内计算出 $\\text{Sum}(\\leq k)$。设当前节点为 `curr`，并初始化一个累计总和 `sum = 0`。\n\n从根节点开始：\n- 如果 $k  \\text{curr.key}$：当前节点及其右子树中的所有键都大于 $k$。答案必然完全在左子树中。我们继续访问左子节点：`curr = curr.left`。\n- 如果 $k > \\text{curr.key}$：左子树中的所有键以及当前节点的键都小于或等于 $k$。我们将左子树的总和（`curr.left.subtree_sum`）和当前节点键的总和（`curr.key \\times curr.count`）加到我们的累计总和中。然后，我们继续在右子树中搜索更多的键：`sum += curr.left.subtree_sum + (curr.key \\times curr.count)`，然后 `curr = curr.right`。\n- 如果 $k == \\text{curr.key}$：左子树中的所有键和当前节点的键都小于或等于 $k$。右子树中的所有键都大于 $k$。因此，我们加上左子树的总和以及当前节点的总和，然后终止。`sum += curr.left.subtree_sum + (curr.key \\times curr.count)`。\n\n这个过程遍历一条单一路径，耗时 $O(\\text{height}) = O(\\log n)$。\n\n### 使用 AVL 树实现\n\n我们将使用 AVL 树作为底层的 BBST。AVL 树通过确保任何节点的两个子树的高度差最多为 $1$ 来维持平衡。这在插入和删除过程中通过旋转（左旋和右旋）来维护。每次修改和旋转后，每个节点的 `height` 和 `subtree_sum` 属性都会被更新。\n\n`insert` 操作将找到键的正确位置。如果键已存在，其 `count` 会增加。如果不存在，则创建一个新节点。然后，在向上回溯到根的过程中，通过执行必要的旋转来重新平衡树。\n\n`delete` 操作将找到该键。如果其 `count > 1`，则将计数减一。如果 `count == 1`，则使用标准的 BST 删除算法移除该节点（例如，用其中序后继节点替换它）。然后对树进行再平衡。\n\n`range_sum` 方法将实现 $\\text{Sum}(\\leq high) - \\text{Sum}(\\leq low - 1)$ 的逻辑。问题规定，如果 $low > high$，结果应为 $0$；这作为一个基本情况来处理。\n\n下面的 Python 实现封装了这一设计。一个 `Node` 类持有键、计数、高度、总和以及子节点指针。一个 `AugmentedAVLTree` 类实现了所描述的操作和平衡逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"Node for the Augmented AVL Tree.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.count = 1\n        self.height = 1\n        self.subtree_sum = key\n        self.left = None\n        self.right = None\n\nclass AugmentedAVLTree:\n    \"\"\"\n    Augmented AVL Tree to support range-sum queries.\n    - Handles duplicate keys via a `count` attribute in each node.\n    - Augments nodes with `subtree_sum` for O(log n) range sum queries.\n    \"\"\"\n\n    def __init__(self):\n        self.root = None\n        self.query_results = []\n\n    def _get_height(self, node):\n        return node.height if node else 0\n\n    def _get_sum(self, node):\n        return node.subtree_sum if node else 0\n\n    def _update_node_attributes(self, node):\n        \"\"\"Updates height and subtree_sum of a node based on its children.\"\"\"\n        if not node:\n            return\n        node.height = 1 + max(self._get_height(node.left), self._get_height(node.right))\n        node.subtree_sum = (node.key * node.count) + self._get_sum(node.left) + self._get_sum(node.right)\n\n    def _get_balance(self, node):\n        return self._get_height(node.left) - self._get_height(node.right) if node else 0\n\n    def _right_rotate(self, y):\n        x = y.left\n        T2 = x.right\n        x.right = y\n        y.left = T2\n        self._update_node_attributes(y)\n        self._update_node_attributes(x)\n        return x\n\n    def _left_rotate(self, x):\n        y = x.right\n        T2 = y.left\n        y.left = x\n        x.right = T2\n        self._update_node_attributes(x)\n        self._update_node_attributes(y)\n        return y\n\n    def _rebalance(self, node, key):\n        \"\"\"Rebalances the node and returns the new root of the subtree.\"\"\"\n        self._update_node_attributes(node)\n        balance = self._get_balance(node)\n\n        # Left Left Case\n        if balance > 1 and key  node.left.key:\n            return self._right_rotate(node)\n        # Right Right Case\n        if balance  -1 and key > node.right.key:\n            return self._left_rotate(node)\n        # Left Right Case\n        if balance > 1 and key > node.left.key:\n            node.left = self._left_rotate(node.left)\n            return self._right_rotate(node)\n        # Right Left Case\n        if balance  -1 and key  node.right.key:\n            node.right = self._right_rotate(node.right)\n            return self._left_rotate(node)\n        \n        return node\n\n    def insert(self, key):\n        self.root = self._insert_recursive(self.root, key)\n\n    def _insert_recursive(self, node, key):\n        if not node:\n            return Node(key)\n        \n        if key  node.key:\n            node.left = self._insert_recursive(node.left, key)\n        elif key > node.key:\n            node.right = self._insert_recursive(node.right, key)\n        else:\n            node.count += 1\n            # Only sum needs update if key exists, height and balance don't change\n            self._update_node_attributes(node)\n            return node\n        \n        return self._rebalance(node, key)\n\n    def delete(self, key):\n        self.root = self._delete_recursive(self.root, key)\n\n    def _delete_recursive(self, node, key):\n        if not node:\n            return node\n        \n        if key  node.key:\n            node.left = self._delete_recursive(node.left, key)\n        elif key > node.key:\n            node.right = self._delete_recursive(node.right, key)\n        else:\n            if node.count > 1:\n                node.count -= 1\n                self._update_node_attributes(node)\n                return node\n            \n            if not node.left or not node.right:\n                temp = node.left if node.left else node.right\n                node = None\n                return temp\n            else:\n                temp = self._get_min_value_node(node.right)\n                node.key = temp.key\n                node.count = temp.count\n                # Set count to 1 to ensure standard deletion of successor\n                temp.count = 1\n                node.right = self._delete_recursive(node.right, temp.key)\n        \n        if not node:\n            return node # Tree was empty or node became null\n\n        # Rebalance the node\n        self._update_node_attributes(node)\n        balance = self._get_balance(node)\n\n        # Left Left Case\n        if balance > 1 and self._get_balance(node.left) >= 0:\n            return self._right_rotate(node)\n        # Left Right Case\n        if balance > 1 and self._get_balance(node.left)  0:\n            node.left = self._left_rotate(node.left)\n            return self._right_rotate(node)\n        # Right Right Case\n        if balance  -1 and self._get_balance(node.right) = 0:\n            return self._left_rotate(node)\n        # Right Left Case\n        if balance  -1 and self._get_balance(node.right) > 0:\n            node.right = self._right_rotate(node.right)\n            return self._left_rotate(node)\n        \n        return node\n\n    def _get_min_value_node(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n\n    def range_sum(self, low, high):\n        if low > high:\n            return 0\n        sum_high = self._sum_le(high)\n        sum_low_minus_1 = self._sum_le(low - 1)\n        return sum_high - sum_low_minus_1\n\n    def _sum_le(self, k):\n        \"\"\"Returns the sum of all keys less than or equal to k.\"\"\"\n        current = self.root\n        total_sum = 0\n        while current:\n            if k  current.key:\n                current = current.left\n            elif k > current.key:\n                total_sum += self._get_sum(current.left) + (current.key * current.count)\n                current = current.right\n            else: # k == current.key\n                total_sum += self._get_sum(current.left) + (current.key * current.count)\n                break\n        return total_sum\n    \n    def process_query(self, low, high):\n        result = self.range_sum(low, high)\n        self.query_results.append(result)\n\ndef solve():\n    all_results = []\n\n    # Scenario A\n    tree_a = AugmentedAVLTree()\n    for key in [5, 3, 8, 1, 4, 7, 9]:\n        tree_a.insert(key)\n    tree_a.process_query(3, 8)\n    tree_a.delete(4)\n    tree_a.process_query(3, 8)\n    all_results.extend(tree_a.query_results)\n\n    # Scenario B\n    tree_b = AugmentedAVLTree()\n    tree_b.process_query(0, 10)\n    tree_b.insert(-2)\n    tree_b.process_query(-5, -1)\n    tree_b.process_query(2, 1) # Invalid range\n    all_results.extend(tree_b.query_results)\n\n    # Scenario C\n    tree_c = AugmentedAVLTree()\n    for key in [2, 2, 2, 3, 3, 10]:\n        tree_c.insert(key)\n    tree_c.process_query(2, 3)\n    tree_c.delete(2)\n    tree_c.process_query(2, 2)\n    all_results.extend(tree_c.query_results)\n\n    # Scenario D\n    tree_d = AugmentedAVLTree()\n    for key in [0, -5, 5, 1]:\n        tree_d.insert(key)\n    tree_d.process_query(-10, 10)\n    tree_d.delete(1)\n    tree_d.process_query(-10, 10)\n    all_results.extend(tree_d.query_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3210369"}, {"introduction": "在掌握了基本的数值增强后，让我们探索一个更精细的应用：从一个动态集合中快速找出符合特定条件的第$k$个元素。这个问题 [@problem_id:3210334] 挑战我们去寻找第$k$个奇数，这代表了一类“带条件的顺序统计”问题。我们将学习如何通过增强节点来存储子树中元素的特定属性（例如偶数元素的数量），从而在对数时间内完成对筛选后子集的排名查询。这种技术在需要对数据进行分类和排序的各种应用中非常有用。", "problem": "给定一个有限的整数键集合，要求您使用一个通过子树元数据增强的二叉搜索树来支持对其奇数元素的顺序查询。请使用以下基本原理来设计您的解决方案。\n\n从二叉搜索树（BST）的定义开始：对于存储键 $x$ 的每个节点，其左子树中的所有键都严格小于 $x$，其右子树中的所有键都严格大于 $x$。用两个字段增强树中的每个节点 $v$，这两个字段必须在插入和旋转操作下精确维护：子树大小 $s(v)$，即以 $v$ 为根的子树中的节点总数，以及以 $v$ 为根的子树中偶数键的数量 $e(v)$。这些字段必须满足不变量\n$$\ns(v) = 1 + s(\\text{left}(v)) + s(\\text{right}(v)),\n$$\n$$\ne(v) = \\mathbf{1}_{\\text{even}}( \\text{key}(v) ) + e(\\text{left}(v)) + e(\\text{right}(v)),\n$$\n其中，如果 $y$ 是一个偶数，$\\mathbf{1}_{\\text{even}}(y)$ 的值为 $1$，否则为 $0$；$\\text{left}(v)$ 和 $\\text{right}(v)$ 表示 $v$ 的左子节点和右子节点，并约定 $s(\\text{null}) = 0$ 和 $e(\\text{null}) = 0$。设以 $v$ 为根的子树中奇数键的数量为 $o(v) = s(v) - e(v)$。\n\n您的任务是实现一个完整、可运行的程序，该程序：\n- 在给定的整数键上构建一个随机化平衡二叉搜索树（例如，Treap），该树具有 BST 属性，并在插入和旋转操作下精确维护增强字段 $s(v)$ 和 $e(v)$，\n- 忽略重复的插入，以使该结构表示一个数学上的键集合，\n- 仅使用增强字段和 BST 结构来回答“查找升序排列的第 $k$ 个奇数键”的查询，而不将集合转换为数组或执行枚举所有元素的中序遍历。\n\n如果第 $k$ 个奇数键不存在（例如，集合中奇数键的数量少于 $k$ 个，或 $k \\le 0$），则输出整数 $0$ 以表示“未找到”。键的定义域是所有整数 $\\mathbb{Z}$，并且请注意 $0$ 不是奇数，因此这个哨兵值不会与任何有效的奇数键冲突。\n\n请从第一性原理出发设计您的过程：使用 BST 排序法则和增强不变量来推导如何沿树下降以定位第 $k$ 个奇数键。不要依赖于将结构转换为数组，也不要使用任何未从给定不变量推导出的快捷公式。\n\n您的程序必须使用内部指定的测试套件运行。对于每个测试用例，程序将：\n- 将提供的整数键序列插入集合中（忽略重复项），\n- 计算并记录针对给定 $k$ 的单个查询的结果，\n- 根据上述规则将结果作为单个整数返回。\n\n测试套件（每个用例是一个对 $(S, k)$，其中 $S$ 是插入序列，$k$ 是选择索引）：\n- 用例 1：$S = [\\,1, 2, 3, 4, 5, 6, 7\\,]$, $k = 3$。\n- 用例 2：$S = [\\,2, 4, 6, 8\\,]$, $k = 1$。\n- 用例 3：$S = [\\,\\,]$ (空序列), $k = 1$。\n- 用例 4：$S = [\\,9, 11, 13\\,]$, $k = 3$。\n- 用例 5：$S = [\\,5, 5, 5, 2, 2, 9, 10\\,]$, $k = 2$。\n- 用例 6：$S = [\\,100, 99, 98, 97, 96, 95\\,]$, $k = 4$。\n- 用例 7：$S = [\\,-3, -2, -1, 0, 1\\,]$, $k = 2$。\n\n要求的最终输出格式是包含上述用例结果的单行，结果为逗号分隔的列表，并用方括号括起来。例如，输出应类似于 `[result_1,result_2,...,result_7]`，不含任何额外的字符或行。\n\n此问题不涉及物理单位；所有输出均为整数。角度不适用。百分比不适用。", "solution": "该问题是有效的。这是一个在数据结构和算法领域中定义良好、具有科学依据的问题。它提供了一套完整且一致的定义、约束和目标，没有歧义或矛盾。任务是设计并实现一个特定的增强型数据结构，一个随机化平衡二叉搜索树（BST），以支持对其元素的一个子集（奇数键）进行顺序统计查询。这是树增强的一个经典应用，并且该问题可以按要求从第一性原理出发解决。\n\n### 基于原理的解决方案设计\n\n该解决方案基于增强平衡二叉搜索树以维护其子树的聚合信息的原理。然后，这些信息可用于在对数时间内回答查询，这远比线性遍历高效。我们将使用 Treap，一种随机化 BST，以高概率确保树的平衡。\n\n#### 1. 数据结构：增强型 Treap 节点\n\nTreap 是一种 BST，它同时满足相对于随机分配的优先级的堆属性。我们的 Treap 中的每个节点 $v$ 将存储：\n- `key(v)`：整数键，遵循 BST 属性。左子树中的所有键都小于 `key(v)`，右子树中的所有键都大于 `key(v)`。\n- `priority(v)`：随机分配的优先级。维持最大堆属性：`priority(v)` 大于或等于其子节点的优先级。\n- `left(v)` 和 `right(v)`：指向左子节点和右子节点的指针。\n- `s(v)`：以 $v$ 为根的子树中的节点总数（子树大小）。\n- `e(v)`：以 $v$ 为根的子树中偶数键的数量。\n\n#### 2. 维护增强不变量\n\n增强字段 $s(v)$ 和 $e(v)$ 必须在所有结构性修改（插入和旋转）中得到正确维护。问题提供了以下不变量：\n$$\ns(v) = 1 + s(\\text{left}(v)) + s(\\text{right}(v))\n$$\n$$\ne(v) = \\mathbf{1}_{\\text{even}}( \\text{key}(v) ) + e(\\text{left}(v)) + e(\\text{right}(v))\n$$\n其中 $s(\\text{null}) = 0$ 且 $e(\\text{null}) = 0$。$\\mathbf{1}_{\\text{even}}(y)$ 是一个指示函数，如果 $y$ 是偶数则为 $1$，否则为 $0$。一个应用于节点 $v$ 的局部更新函数，可以使用其子节点 `left(v)` 和 `right(v)` 已经正确的值来重新计算 $s(v)$ 和 $e(v)$。此更新必须在受结构变化影响的任何节点上执行，从变化处沿树向上进行。\n\n#### 3. 结构操作：插入与旋转\n\n- **插入**：要插入一个新键，我们首先像在标准 BST 中一样遍历树以找到正确的位置。为了维护集合语义，如果键已存在，则操作终止。如果是一个新键，则创建一个具有随机分配优先级的新叶节点。如果新节点的优先级大于其父节点的优先级，则可能违反堆属性。\n- **旋转**：为恢复堆属性，需要执行树旋转操作。`left_rotate` 或 `right_rotate` 操作会局部地重构树，将具有较高优先级的子节点上移，其父节点下移。旋转会保持 BST 属性。关键在于，在涉及节点 $x$ 和 $y$ 的旋转之后，必须使用更新函数重新计算 $y$ 然后是 $x$ 的增强字段（按此自底向上的顺序），以反映它们新的子树。Treap 的递归插入算法优雅地将插入路径查找与必要的旋转和更新结合在一起。\n\n#### 4. 查询算法：查找第 $k$ 个奇数键\n\n问题的核心是设计一个算法，仅使用 BST 结构和增强字段 $s(v)$ 和 $e(v)$ 来查找升序排列的第 $k$ 个奇数键。我们也可以使用子树中奇数键数量的派生量 $o(v) = s(v) - e(v)$。搜索从树的根节点开始。设当前节点为 $v$，期望的排名为 $k$。\n\n1.  **初始检查**：仅当 $k > 0$ 且 $k$ 不超过树中奇数键总数 $o(\\text{root})$ 时，查询才有效。如果不满足这些条件，则键不存在，我们返回哨兵值 $0$。\n\n2.  **递归搜索**：\n    令 `left_odd_count` 为 $o(\\text{left}(v))$，它表示小于 $\\text{key}(v)$ 的奇数键的数量。我们分析第 $k$ 个奇数键相对于当前节点 $v$ 的位置：\n\n    - **情况1：目标在左子树中。** 如果 $k \\le \\text{left\\_odd\\_count}$，则第 $k$ 个奇数键必定是左子树中的一个键。我们通过在左子节点上递归调用函数来继续搜索：`find_kth_odd(left(v), k)`。排名 $k$ 保持不变。\n\n    - **情况2：目标是当前节点。** 如果 $\\text{key}(v)$ 本身是奇数，那么键 $\\text{key}(v)$ 是以 $v$ 为根的子树中第 $(\\text{left\\_odd\\_count} + 1)$ 个奇数键。如果 $\\text{key}(v)$ 是奇数且 $k = \\text{left\\_odd\\_count} + 1$，那么我们找到了目标，并返回 $\\text{key}(v)$。\n\n    - **情况3：目标在右子树中。** 如果键不在左子树中，也不是 $\\text{key}(v)$，那么它必定在右子树中。必须从 $k$ 中减去左子树中的奇数键数量以及根节点的奇数键（如果 $\\text{key}(v)$ 是奇数），以找到目标在右子树中的相对排名。设此偏移量为 `offset = left_odd_count + (1 if key(v) is odd else 0)`。我们在右子树中递归搜索第 $(k - \\text{offset})$ 个奇数键：`find_kth_odd(right(v), k - offset)`。\n\n这种递归下降算法在每一步都划分搜索空间，利用 BST 排序和增强计数，实现了与树高成正比的搜索时间，对于平衡树而言即为 $O(\\log N)$，其中 $N$ 是键的总数。这正确地避免了对树的完全遍历。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding the k-th odd key in a set of integers\n    using an augmented, randomized balanced binary search tree (Treap).\n    \"\"\"\n\n    class Node:\n        \"\"\"\n        A node in the Treap. It stores the key, a random priority,\n        pointers to left and right children, and augmentation fields:\n        s (subtree size) and e (count of even keys in the subtree).\n        \"\"\"\n        def __init__(self, key):\n            self.key = key\n            # Use numpy for random priorities as specified.\n            # Large range to reduce priority collision probability.\n            self.priority = np.random.randint(0, 2**31 - 1)\n            self.left = None\n            self.right = None\n            # s: size of subtree rooted at this node\n            self.s = 1\n            # e: number of even keys in the subtree\n            self.e = 1 if key % 2 == 0 else 0\n\n    class Treap:\n        \"\"\"\n        Implements an augmented Treap data structure to support\n        order statistic queries on odd keys.\n        \"\"\"\n        def __init__(self):\n            self.root = None\n            # Seed for reproducible random priorities for testing.\n            np.random.seed(42)\n\n        def _get_s(self, node):\n            return node.s if node else 0\n\n        def _get_e(self, node):\n            return node.e if node else 0\n        \n        def _get_o(self, node):\n            # o(v) = s(v) - e(v)\n            return self._get_s(node) - self._get_e(node)\n\n        def _update_node(self, node):\n            if node:\n                node.s = 1 + self._get_s(node.left) + self._get_s(node.right)\n                is_even = 1 if node.key % 2 == 0 else 0\n                node.e = is_even + self._get_e(node.left) + self._get_e(node.right)\n\n        def _rotate_right(self, y):\n            x = y.left\n            y.left = x.right\n            x.right = y\n            self._update_node(y)\n            self._update_node(x)\n            return x\n\n        def _rotate_left(self, x):\n            y = x.right\n            x.right = y.left\n            y.left = x\n            self._update_node(x)\n            self._update_node(y)\n            return y\n\n        def _insert(self, node, key):\n            if not node:\n                return Node(key)\n\n            if key == node.key:\n                # Duplicate key, do nothing to maintain set semantics.\n                return node\n            \n            if key  node.key:\n                node.left = self._insert(node.left, key)\n                if node.left and node.left.priority > node.priority:\n                    node = self._rotate_right(node)\n            else: # key > node.key\n                node.right = self._insert(node.right, key)\n                if node.right and node.right.priority > node.priority:\n                    node = self._rotate_left(node)\n\n            self._update_node(node)\n            return node\n\n        def insert(self, key):\n            self.root = self._insert(self.root, key)\n\n        def _query_kth_odd(self, node, k):\n            if not node:\n                return 0 # Should not be reached with initial checks\n            \n            left_odd_count = self._get_o(node.left)\n            \n            if k = left_odd_count:\n                return self._query_kth_odd(node.left, k)\n            \n            is_odd = (node.key % 2 != 0)\n            \n            current_rank = left_odd_count + 1\n            if is_odd and k == current_rank:\n                return node.key\n                \n            offset = left_odd_count + (1 if is_odd else 0)\n            return self._query_kth_odd(node.right, k - offset)\n\n        def find_kth_odd(self, k):\n            total_odds = self._get_o(self.root)\n            if k = 0 or k > total_odds:\n                return 0\n            \n            return self._query_kth_odd(self.root, k)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: S = [1, 2, 3, 4, 5, 6, 7], k = 3. Odd set: {1, 3, 5, 7}. 3rd is 5.\n        ([1, 2, 3, 4, 5, 6, 7], 3),\n        # Case 2: S = [2, 4, 6, 8], k = 1. Odd set: {}. Not found.\n        ([2, 4, 6, 8], 1),\n        # Case 3: S = [], k = 1. Odd set: {}. Not found.\n        ([], 1),\n        # Case 4: S = [9, 11, 13], k = 3. Odd set: {9, 11, 13}. 3rd is 13.\n        ([9, 11, 13], 3),\n        # Case 5: S = [5, 5, 5, 2, 2, 9, 10], k = 2. Set: {2, 5, 9, 10}. Odd: {5, 9}. 2nd is 9.\n        ([5, 5, 5, 2, 2, 9, 10], 2),\n        # Case 6: S = [100, 99, 98, 97, 96, 95], k = 4. Set: {95-100}. Odd: {95, 97, 99}. 4th not found.\n        ([100, 99, 98, 97, 96, 95], 4),\n        # Case 7: S = [-3, -2, -1, 0, 1], k = 2. Set: {-3, -2, -1, 0, 1}. Odd: {-3, -1, 1}. 2nd is -1.\n        ([-3, -2, -1, 0, 1], 2),\n    ]\n\n    results = []\n    for keys, k in test_cases:\n        treap = Treap()\n        for key in keys:\n            treap.insert(key)\n        result = treap.find_kth_odd(k)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3210334"}, {"introduction": "最后，我们将 tackling 一个计算几何中的经典问题：动态管理区间集合并查询与给定区间重叠的所有区间。这个问题在日程安排、基因组学和资源分配等领域有广泛应用。我们将构建一个真正的“区间树”[@problem_id:3210424]，它通过一个巧妙的增强——记录子树中所有区间的最大右端点——来实现高效查询。这个增强使得我们可以在搜索过程中剪掉那些不可能包含重叠区间的整个子树，从而实现对数时间的查询性能，即使在区间可以动态调整大小的情况下也是如此。", "problem": "您需要设计并实现一个增强二叉搜索树，用于维护整数线上的一个动态闭区间集合。每个区间都有一个唯一的标识符。该树必须支持插入新区间、通过修改端点来调整现有区间的大小，以及查询与给定闭合查询区间重叠的所有区间。最终程序必须是一个完整的、可运行的程序，它会执行一个固定的测试套件，并在一行上打印聚合结果。\n\n请从以下基本概念出发：一个以区间左端点为键的二叉搜索树，该树通过增强子树信息来有效回答重叠查询；两个闭区间之间的重叠概念；以及一个平衡树设计，以确保更新和搜索的期望运行时间为对数级。您必须通过仔细定义不变量，并证明每个操作如何保持这些不变量，来推导出您的设计和实现。\n\n定义和要求：\n\n- 设一个区间为整数线上的闭区间 $[\\ell,r]$，其中 $\\ell \\le r$ 且端点 $\\ell,r \\in \\mathbb{Z}$。每个区间都有一个唯一的标识符 $i \\in \\mathbb{Z}$。\n- 该树必须是一个平衡二叉搜索树，以 $(\\ell,i)$ 按字典序作为键，并且每个节点都必须增强以存储其子树中的最大右端点。具体来说，对于一个存储标识符为 $i$ 的区间 $[\\ell,r]$ 的节点，定义其增强字段为 $$\\mathrm{max\\_end} = \\max\\left(r, \\mathrm{max\\_end}\\left(\\text{left subtree}\\right), \\mathrm{max\\_end}\\left(\\text{right subtree}\\right)\\right).$$\n- 两个闭区间 $[\\ell_1,r_1]$ 和 $[\\ell_2,r_2]$ 重叠，当且仅当 $$\\ell_1 \\le r_2 \\quad \\text{and} \\quad \\ell_2 \\le r_1.$$\n- 该树必须支持以下操作：\n  1. $\\mathrm{insert}(i,\\ell,r)$: 插入一个标识符为 $i$、端点为 $\\ell,r$ 的新区间，需满足规则 $\\ell \\le r$。\n  2. $\\mathrm{resize}(i,\\ell',r')$: 将由 $i$ 标识的现有区间的端点更改为新端点 $\\ell',r'$，需满足规则 $\\ell' \\le r'$，同时保留标识 $i$。此操作必须正确更新所有增强信息并维护平衡树不变量。\n  3. $\\mathrm{query}(q_\\ell,q_r)$: 返回树中与查询区间 $[q_\\ell,q_r]$ 重叠的所有区间的标识符列表。该列表必须按标识符升序排序。\n- 目标时间界限：通过使用带有适当增强信息的平衡二叉搜索树，每个操作的期望运行时间必须为 $O\\!\\left(\\log n\\right)$，其中 $n$ 是树中区间的数量。\n\n您的程序必须实现上述规范，运行以下测试套件，并按稍后描述的精确最终输出格式生成所有查询的结果。\n\n测试套件：\n\n- 测试用例 1 (常规功能和调整大小，包括收缩和移位)：\n  1. $\\mathrm{insert}(1,1,5)$\n  2. $\\mathrm{insert}(2,4,7)$\n  3. $\\mathrm{insert}(3,10,12)$\n  4. $\\mathrm{insert}(4,6,6)$\n  5. $\\mathrm{insert}(5,0,2)$\n  6. $\\mathrm{query}(5,6)$\n  7. $\\mathrm{resize}(1,2,3)$\n  8. $\\mathrm{query}(1,2)$\n  9. $\\mathrm{resize}(4,7,9)$\n  10. $\\mathrm{query}(8,10)$\n  这三个查询的预期输出是与相应查询区间重叠的已排序标识符列表。\n\n- 测试用例 2 (边界条件，包括零长度区间和负端点)：\n  1. $\\mathrm{insert}(10,-5,-1)$\n  2. $\\mathrm{insert}(11,-1,0)$\n  3. $\\mathrm{insert}(12,0,0)$\n  4. $\\mathrm{insert}(13,0,1)$\n  5. $\\mathrm{query}(0,0)$\n  6. $\\mathrm{resize}(11,-2,-2)$\n  7. $\\mathrm{query}(-2,-2)$\n  8. $\\mathrm{resize}(12,-1,1)$\n  9. $\\mathrm{query}(-1,0)$\n  这三个查询的预期输出是与相应查询区间重叠的已排序标识符列表。\n\n- 测试用例 3 (多个具有相同左端点的区间，改变顺序的调整大小操作，以及全面的重叠情况)：\n  1. $\\mathrm{insert}(20,5,10)$\n  2. $\\mathrm{insert}(21,5,5)$\n  3. $\\mathrm{insert}(22,5,7)$\n  4. $\\mathrm{insert}(23,2,3)$\n  5. $\\mathrm{query}(4,5)$\n  6. $\\mathrm{resize}(23,6,12)$\n  7. $\\mathrm{query}(8,9)$\n  8. $\\mathrm{resize}(21,4,6)$\n  9. $\\mathrm{query}(6,6)$\n  这三个查询的预期输出是与相应查询区间重叠的已排序标识符列表。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个查询结果列表，而每个查询结果本身是一个标识符列表。例如，格式必须为 `[result_case_1,result_case_2,result_case_3],` 其中每个 `result_case_k` 是一个对应于测试用例 $k$ 中查询的整数列表的列表。不得有额外文本，空格是可选的，并且必须只有一行输出。", "solution": "该问题要求设计并实现一个动态数据结构，用于存储和查询整数线上的闭区间。该结构必须是一个平衡二叉搜索树，并通过增强来支持高效的重叠查询。所需的操作包括插入新区间、调整现有区间的大小，以及查询与给定查询区间重叠的所有区间。所有操作都必须达到 $O(\\log n)$ 的期望时间复杂度，其中 $n$ 是区间的数量。\n\n为满足这些要求，我们将实现一个增强的 Treap。Treap 是一种随机化的二叉搜索树，它以高概率保持平衡，从而为搜索、插入和删除操作提供期望对数时间复杂度。\n\n### 数据结构：增强 Treap 节点\nTreap 中的每个节点将代表一个区间。节点结构包含以下字段：\n- **键 (Key)**：一个元组 $(\\ell, i)$，表示区间的左端点 $\\ell$ 及其唯一标识符 $i$。树按此键的字典序排序。这确保了每个区间都有一个唯一的位置，即使多个区间共享相同的左端点。\n- **标识符 (Identifier)**：唯一的整数标识符 $i$。\n- **区间 (Interval)**：闭区间 $[\\ell, r]$ 的端点 $(\\ell, r)$。\n- **优先级 (Priority)**：一个随机分配的整数，用于维护 Treap 的堆属性。\n- **子节点 (Children)**：指向左右子节点的指针 `left` 和 `right`。\n- **增强信息 (Augmentation)**：一个字段 `max_end`，存储以此节点为根的子树中所有区间的最大右端点。\n\n### 增强 Treap 的不变量\n我们数据结构的正确性依赖于对树中每个节点 $x$ 维护三个不变量：\n\n$1$. **二叉搜索树 (BST) 不变量**：对于任意节点 $x$，其左子树中的所有键都小于 $x$ 的键，其右子树中的所有键都大于 $x$ 的键。即，对于 $x$ 左子树中的任意节点 $y$，$y.key  x.key$；对于 $x$ 右子树中的任意节点 $z$，$z.key > x.key$。\n\n$2$. **堆不变量**：节点 $x$ 的优先级大于或等于其子节点的优先级。即，如果 $y$ 是 $x$ 的一个子节点，则 $x.priority \\ge y.priority$。\n\n$3$. **增强不变量**：节点 $x$ 的 `max_end` 字段是其自身区间右端点及其子节点 `max_end` 值中的最大值。设 $x.\\text{interval}$ 为 $[\\ell, r]$。那么，\n$$x.\\mathrm{max\\_end} = \\max(r, x.\\mathrm{left}.\\mathrm{max\\_end}, x.\\mathrm{right}.\\mathrm{max\\_end})$$\n其中，不存在的子节点（即 `None`）的 `max_end` 被视为 $-\\infty$。\n\n### 维护不变量\nBST 和堆不变量通过涉及旋转的标准 Treap 操作来维护。在对树进行任何结构性修改（插入、删除、旋转）后，必须恢复增强不变量。这通过一个辅助函数 `_update_max_end(node)` 实现，该函数根据定义重新计算 `node.max_end`。此函数以自底向上的方式在所有受影响的节点上调用。旋转是重新平衡的基本操作，它们必须正确更新 `max_end` 字段。\n\n- `_rotate_left(y)`：设 $x$ 是 $y$ 的右子节点。旋转使 $x$ 成为该子树的新根，并使 $y$ 成为其左子节点。必须先更新 $y$（新子节点）的 `max_end` 字段，然后再更新 $x$（新父节点）的 `max_end` 字段，因为 $x$ 的新值取决于 $y$ 更新后的值。\n- `_rotate_right(x)`：设 $y$ 是 $x$ 的左子节点。旋转使 $y$ 成为新根，并使 $x$ 成为其右子节点。`max_end` 字段先为 $x$ 更新，再为 $y$ 更新。\n\n### 操作实现\n为了方便 `resize` 操作（该操作需要通过标识符 $i$ 查找节点），我们使用一个辅助字典，将每个标识符 $i$ 映射到其在树中对应的节点对象。\n\n$1$. **$\\mathrm{insert}(i, \\ell, r)$**：\n- 创建一个新节点，其键为 $(\\ell, i)$，区间为 $[\\ell, r]$，并具有随机生成的优先级。\n- 遵循标准的 BST 插入逻辑将该节点插入树中，根据其键将其放置在叶子位置。\n- 然后通过沿从新节点到根的路径向上执行旋转来重新平衡树，在任何违反堆不变量的地方（即子节点的优先级高于父节点）恢复该不变量。\n- 在插入路径的递归回溯过程中，所有祖先节点的 `max_end` 值都会被更新。\n- 辅助字典会用从 $i$ 到新创建节点的映射进行更新。\n此过程的期望时间复杂度为 $O(\\log n)$。\n\n$2$. **$\\mathrm{resize}(i, \\ell', r')$**：\n`resize` 操作将与标识符 $i$ 关联的区间修改为 $[\\ell', r']$。如果左端点 $\\ell$ 变为 $\\ell'$，节点的键 $(\\ell, i)$ 会改变，需要其在树中进行物理上的重新定位以维护 BST 不变量。处理此问题的最稳健方法是执行一次删除操作，然后执行一次插入操作。\n- 使用辅助字典可以在 $O(1)$ 时间内定位要修改的节点。设其当前区间为 $[\\ell, r]$。\n- 从 Treap 中删除键为 $(\\ell, i)$ 的节点。Treap 中的删除操作涉及将目标节点向下旋转直至其成为叶子节点，然后移除它。在此过程中，路径上的 `max_end` 值会被更新。\n- 使用上述的 `insert` 操作将一个标识符为 $i$、端点为 $[\\ell', r']$ 的新区间插入树中。\n由于删除和插入操作的期望时间复杂度均为 $O(\\log n)$，因此整个 `resize` 操作的期望时间复杂度也为 $O(\\log n)$。\n\n$3$. **$\\mathrm{query}(q_\\ell, q_r)$**：\n查询操作会找到树中与查询区间 $[q_\\ell, q_r]$ 重叠的所有区间 $[\\ell, r]$。两个区间 $[\\ell_1, r_1]$ 和 $[\\ell_2, r_2]$ 重叠的条件是 $\\ell_1 \\le r_2$ 且 $\\ell_2 \\le r_1$。查询算法递归地遍历树，使用 `max_end` 增强信息来剪枝搜索路径。\n\n在存储区间 $[\\ell, r]$ 的给定节点 $x$ 处的搜索过程如下：\n- **检查当前节点**：测试区间 $[\\ell, r]$ 是否与 $[q_\\ell, q_r]$ 重叠。如果 $\\ell \\le q_r$ 且 $q_\\ell \\le r$，则将标识符 $i$ 添加到结果集中。\n- **搜索左子树**：如果左子树可能包含重叠区间，则必须进入左子树进行搜索。左子树中的一个区间 $[l_{sub}, r_{sub}]$ 只有在 $r_{sub} \\ge q_\\ell$ 时才可能与 $[q_\\ell, q_r]$ 重叠。左子节点的 `max_end` 字段，即 $x.\\text{left}.\\mathrm{max\\_end}$，代表了整个子树中可能的最大 $r_{sub}$。因此，只有当 $x.\\text{left}$ 不为 `None` 且 $x.\\text{left}.\\mathrm{max\\_end} \\ge q_\\ell$ 时，我们才需要搜索左子树。如果不满足此条件，则可以剪掉整个左子树。\n- **搜索右子树**：根据 BST 不变量，右子树中的所有区间的左端点都大于或等于 $\\ell$。如果 $\\ell > q_r$，那么右子树中的任何区间的左端点也都将大于 $q_r$，使得重叠不可能发生。因此，只有当 $x.\\text{right}$ 不为 `None` 且 $\\ell \\le q_r$ 时，我们才搜索右子树。\n\n这种搜索策略遍历有限数量的路径，从而获得 $O(k + \\log n)$ 的高效查询时间，其中 $k$ 是报告的重叠区间数量。问题陈述的目标是 $O(\\log n)$，在范围和区间查询的上下文中，这通常用作此类复杂度的简写。最后，收集到的标识符按升序排序。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass IntervalTree:\n    \"\"\"\n    An augmented Treap for managing and querying dynamic sets of closed intervals.\n    The tree is keyed by (left_endpoint, identifier) and augmented with the\n    maximum right endpoint in each subtree.\n    \"\"\"\n\n    class Node:\n        def __init__(self, id, l, r, priority):\n            self.id = id\n            self.l = l\n            self.r = r\n            self.key = (l, id)\n            self.priority = priority\n            self.max_end = r\n            self.left = None\n            self.right = None\n\n    def __init__(self, seed=None):\n        self.root = None\n        self.id_to_node = {}\n        if seed is not None:\n            self._rng = np.random.RandomState(seed)\n        else:\n            self._rng = np.random\n        # Using a fixed seed for reproducibility across runs.\n        np.random.seed(42)\n\n    def _get_max_end(self, node):\n        return node.max_end if node else -float('inf')\n\n    def _update_max_end(self, node):\n        if node:\n            node.max_end = max(node.r, self._get_max_end(node.left), self._get_max_end(node.right))\n\n    def _rotate_right(self, y):\n        x = y.left\n        y.left = x.right\n        x.right = y\n        self._update_max_end(y)\n        self._update_max_end(x)\n        return x\n\n    def _rotate_left(self, x):\n        y = x.right\n        x.right = y.left\n        y.left = x\n        self._update_max_end(x)\n        self._update_max_end(y)\n        return y\n\n    def _insert(self, root, node):\n        if not root:\n            return node\n        \n        if node.key  root.key:\n            root.left = self._insert(root.left, node)\n            if root.left.priority > root.priority:\n                root = self._rotate_right(root)\n        else:\n            root.right = self._insert(root.right, node)\n            if root.right.priority > root.priority:\n                root = self._rotate_left(root)\n        \n        self._update_max_end(root)\n        return root\n\n    def insert(self, i, l, r):\n        if i in self.id_to_node:\n            raise ValueError(f\"Identifier {i} already exists.\")\n        \n        priority = self._rng.randint(0, 2**32 - 1)\n        node = self.Node(i, l, r, priority)\n        self.id_to_node[i] = node\n        self.root = self._insert(self.root, node)\n\n    def _delete(self, root, key):\n        if not root:\n            return None\n        \n        if key  root.key:\n            root.left = self._delete(root.left, key)\n        elif key > root.key:\n            root.right = self._delete(root.right, key)\n        else:\n            if not root.left:\n                return root.right\n            if not root.right:\n                return root.left\n            \n            if root.left.priority > root.right.priority:\n                root = self._rotate_right(root)\n                root.right = self._delete(root.right, key)\n            else:\n                root = self._rotate_left(root)\n                root.left = self._delete(root.left, key)\n        \n        self._update_max_end(root)\n        return root\n\n    def resize(self, i, l_new, r_new):\n        if i not in self.id_to_node:\n            raise ValueError(f\"Identifier {i} not found for resizing.\")\n        \n        # Delete the old node\n        old_node = self.id_to_node[i]\n        self.root = self._delete(self.root, old_node.key)\n        del self.id_to_node[i]\n        \n        # Insert the new version\n        self.insert(i, l_new, r_new)\n\n    def _query(self, node, q_l, q_r, results):\n        if not node:\n            return\n\n        # Prune left subtree if no interval can possibly overlap the query's start\n        if node.left and node.left.max_end >= q_l:\n            self._query(node.left, q_l, q_r, results)\n        \n        # Check current node for overlap\n        if node.l = q_r and q_l = node.r:\n            results.add(node.id)\n\n        # Prune right subtree if its intervals start after the query ends\n        if node.l = q_r:\n            self._query(node.right, q_l, q_r, results)\n\n    def query(self, q_l, q_r):\n        results = set()\n        self._query(self.root, q_l, q_r, results)\n        return sorted(list(results))\n\ndef solve():\n    test_suite = [\n        [ # Test case 1\n            (\"insert\", (1, 1, 5)),\n            (\"insert\", (2, 4, 7)),\n            (\"insert\", (3, 10, 12)),\n            (\"insert\", (4, 6, 6)),\n            (\"insert\", (5, 0, 2)),\n            (\"query\", (5, 6)),\n            (\"resize\", (1, 2, 3)),\n            (\"query\", (1, 2)),\n            (\"resize\", (4, 7, 9)),\n            (\"query\", (8, 10)),\n        ],\n        [ # Test case 2\n            (\"insert\", (10, -5, -1)),\n            (\"insert\", (11, -1, 0)),\n            (\"insert\", (12, 0, 0)),\n            (\"insert\", (13, 0, 1)),\n            (\"query\", (0, 0)),\n            (\"resize\", (11, -2, -2)),\n            (\"query\", (-2, -2)),\n            (\"resize\", (12, -1, 1)),\n            (\"query\", (-1, 0)),\n        ],\n        [ # Test case 3\n            (\"insert\", (20, 5, 10)),\n            (\"insert\", (21, 5, 5)),\n            (\"insert\", (22, 5, 7)),\n            (\"insert\", (23, 2, 3)),\n            (\"query\", (4, 5)),\n            (\"resize\", (23, 6, 12)),\n            (\"query\", (8, 9)),\n            (\"resize\", (21, 4, 6)),\n            (\"query\", (6, 6)),\n        ]\n    ]\n\n    all_results = []\n    for case_ops in test_suite:\n        tree = IntervalTree()\n        case_results = []\n        for op, args in case_ops:\n            if op == \"insert\":\n                tree.insert(*args)\n            elif op == \"resize\":\n                tree.resize(*args)\n            elif op == \"query\":\n                result = tree.query(*args)\n                case_results.append(result)\n        all_results.append(case_results)\n    \n    # Format the output string precisely as required, with no spaces.\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "3210424"}]}