{"hands_on_practices": [{"introduction": "任何复杂数据结构的核心都在于其必须始终保持的一组“不变性”（invariants）。对于斐波那契堆这样精巧的结构，一套健全的不变性检查是调试和验证正确性的基石。本练习将挑战你识别出定义一个有效斐波那契堆所需的最恰当的断言集合，这不仅是对理论知识的检验，更是编写可靠代码的第一步。[@problem_id:3234539]", "problem": "你正在为一个最小堆调试一个斐波那契堆的实现。在一次长时间的随机测试后，你观察到一些症状，例如 `decrease-key` 操作偶尔未能调整报告的最小值，遍历根列表时零星出现循环，以及节点的报告度数与遍历其子列表时遇到的子节点数量偶尔不匹配。你决定编写一个不变量检查器，在每次操作后运行，并标记出结构上的不一致性。仅使用关于斐波那契堆的基本定义和经过充分检验的事实，哪组断言最适合包含进来，以便在不过度约束有效状态的情况下，暴露常见的结构性错误？\n\n选择最佳选项。\n\nA. 断言以下所有内容：\n- 堆序：对于每个父节点为 $p(x)$ 的非根节点 $x$，满足 $key(p(x)) \\le key(x)$。\n- 根列表结构：根列表是一个具有指针一致性的循环双向链表，即对于每个根 $r$，满足 $r.\\mathrm{left}.\\mathrm{right} = r$ 和 $r.\\mathrm{right}.\\mathrm{left} = r$，并且每个根的 $r.\\mathrm{parent} = \\mathrm{null}$。\n- 最小指针：$H.\\mathrm{min}$ 指向一个根，其关键字等于 $\\min\\{key(r) : r \\text{ 是一个根}\\}$。\n- 度一致性：对于每个节点 $x$，存储的度 $deg(x)$ 等于遍历 $x$ 的子循环列表一圈可达的子节点数量；该列表中的每个子节点 $c$ 都满足 $c.\\mathrm{parent} = x$。\n- 标记一致性：所有根都是未标记的；如果一个节点被标记，那么它不是根，并且其 $x.\\mathrm{parent} \\ne \\mathrm{null}$。\n- 合并后的唯一性：在每次 `delete-min` 操作之后，所有根的度都是两两不同的。\n\nB. 断言以下所有内容：\n- 根的数量恰好是 $\\lfloor \\log_{\\varphi} n \\rfloor$，其中 $\\varphi = \\frac{1+\\sqrt{5}}{2}$，$n$ 是节点数。\n- 最小指针 $H.\\mathrm{min}$ 是堆中所有节点（不仅仅是根节点）中全局最小的关键字。\n- 只要遍历能够到达所有子节点，子列表可以是单向链接的。\n- 根节点可以被标记，因为标记仅表示一个节点在某个时刻失去过一个子节点。\n\nC. 断言以下所有内容：\n- 堆序是严格的：对于每个父节点为 $p(x)$ 的非根节点 $x$，满足 $key(p(x))  key(x)$。\n- 度是后代的总数：对于每个节点 $x$，$deg(x)$ 等于以 $x$ 为根的子树中的节点数减 1。\n- 度的唯一性在任何时候都适用于整个堆：没有两个节点（无论是根节点还是非根节点）具有相同的 $deg(\\cdot)$ 值。\n- 如果子节点可以通过从根列表进行指针追溯来到达，则它们无需维护父指针。\n\nD. 断言以下所有内容：\n- 势能函数值 $\\Phi = T + 2M$（其中 $T$ 是根的数量，$M$ 是标记节点的数量）在任何操作中都不会增加。\n- 最小指针 $H.\\mathrm{min}$ 在 `decrease-key` 操作后可能暂时不正确，但必须仅在 `extract-min` 操作后才被修正。\n- 合并操作可以延迟对等度根的配对，直到执行了 $k$ 次 `delete-min` 操作之后（对于某个固定的 $k > 1$）。\n- 除非节点被标记，否则可以省略父指针；在这种情况下，它必须指向一个有效的父节点。", "solution": "## 问题验证\n\n### 第1步：提取已知信息\n- **数据结构：** 一个实现为斐波那契堆的最小堆。\n- **背景：** 一个实现正在通过随机测试进行调试。\n- **观察到的症状：**\n    1. `decrease-key` 操作偶尔未能调整报告的最小值。\n    2. 遍历根列表时零星出现循环。\n    3. 节点的报告度数与遍历其子列表时遇到的子节点数量偶尔不匹配。\n- **任务：** 为一个在每次操作后运行的不变量检查器定义一组断言。\n- **目标：** 断言必须仅使用关于斐波那契堆的基本定义和经过充分检验的事实，在不过度约束有效状态的情况下，暴露常见的结构性错误。\n- **问题：** 所提供的断言集合中哪一个最合适？\n\n### 第2步：使用提取的已知信息进行验证\n问题陈述是有效的。\n- **科学依据：** 该问题设置在数据结构和算法的背景下，这是计算机科学的一个正式分支。斐波那契堆是一个定义明确的数学构造，具有已确立的属性（不变量）。所描述的症状是由于堆操作的错误实现而可能出现的合理错误。创建一个不变量检查器是调试复杂数据结构的标准且严谨的方法。\n- **问题定义明确：** 该问题要求找到“最合适的”断言集合，以实现一个明确定义的目标：暴露特定类型的错误，同时不排除堆的有效中间状态。这种结构允许通过将给定选项与斐波那\n那契堆的既定理论进行比较来确定唯一的最佳答案。\n- **客观性：** 该问题使用该领域特有的精确技术语言进行描述。症状是具体且可测量的，而对断言的期望属性是客观标准（暴露错误，不过度约束）。\n\n### 第3步：结论与行动\n问题是有效的。接下来将进行分析以推导出解决方案。\n\n## 解题推导\n\n目标是确定能够正确捕捉用于最小堆的斐波那契堆的结构不变量的断言集合。这样的集合应足以检测所描述的实现错误。我们将根据斐波那契堆的规范定义来评估每个选项。\n\n一个斐波那契堆 $H$ 是一组满足最小堆性质的树的集合。在公共操作之间必须保持为真的结构不变量是：\n\n1.  **最小堆序：** 对于每个有父节点 $p(x)$ 的节点 $x$，不等式 $key(p(x)) \\le key(x)$ 必须成立。\n2.  **根列表：** 所有树的根都链接在一个循环双向链表中。每个根的父节点都是 $\\mathrm{null}$。\n3.  **最小指针：** 一个指针 $H.\\mathrm{min}$ 必须指向具有最小关键字值的根节点。\n4.  **节点字段：** 每个节点 $x$ 维护其度 $deg(x)$（子节点数量）、一个子节点指针、一个父节点指针和一个布尔标记。\n5.  **子列表：** 每个节点 $x$ 的子节点也链接在一个循环双向链表中。每个子节点的父指针必须指回 $x$。\n6.  **标记规则：** 如果一个非根节点 $x$ 自从上次成为其当前父节点的子节点以来失去了一个子节点，则该节点被标记。所有根节点都是未标记的。\n\n所描述的错误对应于对这些不变量的违反：\n- `decrease-key` 未能更新最小值违反了不变量 #3。\n- 根列表中的循环违反了不变量 #2。\n- 度与子节点数量不匹配违反了不变量 #4 和 #5。\n\n现在，我们来评估每个选项。\n\n### 逐项分析\n\n**A. 断言以下所有内容：**\n1.  **堆序：对于每个父节点为 $p(x)$ 的非根节点 $x$，满足 $key(p(x)) \\le key(x)$。** 这是基本的最小堆性质和核心不变量。**此断言是正确的。**\n2.  **根列表结构：根列表是一个具有指针一致性的循环双向链表，即对于每个根 $r$，满足 $r.\\mathrm{left}.\\mathrm{right} = r$ 和 $r.\\mathrm{right}.\\mathrm{left} = r$，并且每个根的 $r.\\mathrm{parent} = \\mathrm{null}$。** 这正确地定义了根列表的结构和指针完整性。检查这一点可以检测到“零星出现的循环”错误。**此断言是正确的。**\n3.  **最小指针：$H.\\mathrm{min}$ 指向一个根，其关键字等于 $\\min\\{key(r) : r \\text{ 是一个根}\\}$。** 这是最小指针作用的定义，确保了 $O(1)$ 的 `find-min` 操作。它可以检测到 `decrease-key` 未能更新最小值的错误。**此断言是正确的。**\n4.  **度一致性：对于每个节点 $x$，存储的度 $deg(x)$ 等于遍历 $x$ 的子循环列表一圈可达的子节点数量；该列表中的每个子节点 $c$ 都满足 $c.\\mathrm{parent} = x$。** 此检查直接解决了关于度不匹配的错误，并验证了子-父链接的完整性，这对于 `cut` 操作至关重要。**此断言是正确的。**\n5.  **标记一致性：所有根都是未标记的；如果一个节点被标记，那么它不是根，并且其 $x.\\mathrm{parent} \\ne \\mathrm{null}$。** 这正确地陈述了标记规则。根据定义，根节点是未标记的（当它们成为根时，它们的标记被清除）。**此断言是正确的。**\n6.  **合并后的唯一性：在每次 `delete-min` 操作之后，所有根的度都是两两不同的。** 这是一个关于斐波那契堆在 `delete-min` （或 `extract-min`）操作的合并步骤*之后立即*状态的正确陈述。虽然它不是在*每次*操作后都成立的全局不变量（例如，`insert` 可能会创建一个度已存在的根），但它是 `delete-min` 的一个关键后置条件。不变量检查器可以有条件地使用此断言。在创建一个全面的检查套件以调试实现的情况下，这是一个非常合适且有用的断言。\n\n这组断言完全由斐波那契堆的正确属性组成。前五个是全局不变量，第六个是一个主要操作的关键后置条件。它们共同作用，能高效地暴露所描述的结构性错误。\n**结论：正确。**\n\n**B. 断言以下所有内容：**\n1.  **根的数量恰好是 $\\lfloor \\log_{\\varphi} n \\rfloor$，其中 $\\varphi = \\frac{1+\\sqrt{5}}{2}$，$n$ 是节点数。** 这是不正确的。根的数量不是固定的。它可以高达 $n$。$O(\\log n)$ 的界限适用于堆中任何节点的最大*度*，而不是根的数量。\n2.  **最小指针 $H.\\mathrm{min}$ 是堆中所有节点（不仅仅是根节点）中全局最小的关键字。** 虽然这个陈述是最小堆性质的一个真实推论（最小值必须位于根节点），但主要的、可直接检查的不变量是 $H.\\mathrm{min}$ 指向*根节点中*的最小值。这样表述不如选项 A 中的断言直接。\n3.  **只要遍历能够到达所有子节点，子列表可以是单向链接的。** 这是不正确的。子列表必须是双向链接的，以支持从兄弟节点中高效地剪切一个节点，这是 `decrease-key` 的 $O(1)$ 摊还时间所必需的。\n4.  **根节点可以被标记，因为标记仅表示一个节点在某个时刻失去过一个子节点。** 这是不正确的。根据定义，当一个节点成为根时，它是未标记的。\n这个集合包含多个基本错误。\n**结论：不正确。**\n\n**C. 断言以下所有内容：**\n1.  **堆序是严格的：对于每个父节点为 $p(x)$ 的非根节点 $x$，满足 $key(p(x))  key(x)$。** 这是一个过度约束。斐波那契堆可以存储具有重复关键字的元素，因此堆性质是非严格的（$ \\le $）。\n2.  **度是后代的总数：对于每个节点 $x$，$deg(x)$ 等于以 $x$ 为根的子树中的节点数减 1。** 这是不正确的。节点的度是其直接子节点的数量，而不是其所有后代的数量。\n3.  **度的唯一性在任何时候都适用于整个堆：没有两个节点（无论是根节点还是非根节点）具有相同的 $deg(\\cdot)$ 值。** 这是不正确的。度的唯一性没有保证，即使对于根节点，也只有在合并之后才能保证。\n4.  **如果子节点可以通过从根列表进行指针追溯来到达，则它们无需维护父指针。** 这是不正确的。父指针对于 `decrease-key` 操作中的 `cut` 和 `cascading-cut` 过程至关重要，这些过程需要从一个节点向上移动到树中。\n这个集合包含多个基本错误。\n**结论：不正确。**\n\n**D. 断言以下所有内容：**\n1.  **势能函数值 $\\Phi = T + 2M$（其中 $T$ 是根的数量，$M$ 是标记节点的数量）在任何操作中都不会增加。** 这是不正确的。势能函数是摊还分析的工具；它不是一个不变量，并且在某些操作期间可能会增加（例如，`insert` 会增加 $T$）。被限制的是摊还成本，而不是势能本身。\n2.  **最小指针 $H.\\mathrm{min}$ 在 `decrease-key` 操作后可能暂时不正确，但必须仅在 `extract-min` 操作后才被修正。** 这是不正确的。如果新的最小根的关键字小于当前最小值，`decrease-key` 操作负责更新 $H.\\mathrm{min}$。允许它不正确将违反 `find-min` 操作的语义。问题对这种行为的描述是*错误的症状*，而不是一个允许的状态。\n3.  **合并操作可以延迟对等度根的配对，直到执行了 $k$ 次 `delete-min` 操作之后（对于某个固定的 $k > 1$）。** 这描述了对标准算法的修改，而不是斐波那契堆基本定义的属性。标准算法在每次 `delete-min` 期间都会进行合并。\n4.  **除非节点被标记，否则可以省略父指针；在这种情况下，它必须指向一个有效的父节点。** 这是不正确的。`cascading-cut` 过程从一个节点向上移动到其父节点，该父节点最初可能是未标记的。因此，所有非根节点都必须有父指针。\n这个集合包含多个基本错误。\n**结论：不正确。**\n\n### 结论\n选项 A 提供了一组断言，这些断言都是关于斐波那契堆结构和性质的正确陈述。前五个是通用不变量，第六个是 `delete-min` 的特定后置条件。这个集合完美地定制用于检测问题陈述中提到的特定错误，而不会过度限制（因为那个特定的后置条件被正确地限定了）。选项 B、C 和 D 都包含多个对斐波那契堆的根本性错误描述。因此，选项 A 毫无疑问是最合适的断言集。", "answer": "$$\\boxed{A}$$", "id": "3234539"}, {"introduction": "斐波那契堆的 `decrease-key` 操作因其独特的“切削”（cut）与“级联切削”（cascading cut）机制而闻名，但这也使其成为实现中最容易出错的部分。本练习将让你扮演一名“bug猎人”。通过刻意实现一个有缺陷的版本，并与正确版本进行对比测试，你将深刻理解这些复杂机制对于维护堆属性的至关重要性。[@problem_id:3234524]", "problem": "考虑一个斐波那契堆，它是由满足堆序性质的树组成的集合。堆序性质规定，对于每个键为 $k(u)$ 的节点 $u$ 及其每个键为 $k(v)$ 的子节点 $v$，关系 $k(u) \\leq k(v)$ 必须成立。一个标准的斐波那契堆维护一个指针 $min(H)$，指向堆 $H$ 中所有根里键最小的那个根。本练习的基础是堆序性质的核心定义以及一个不变量：堆的最小元素必须是根，这是由堆序性质推导出来的。\n\n实现两个版本的斐波那契堆：\n- 一个遵循常规定义和不变量的正确版本。\n- 一个有缺陷的版本，其 `decrease-key` 操作仅将节点的键设置为新值，但不执行任何剪切（cut）操作（即使新键变得严格小于其父节点的键从而违反了堆序性质），并且在减小键值后也不更新全局最小指针 $min(H)$。这种错误行为必须被有意地实现。\n\n你必须在堆 $H$ 上验证以下不变量：\n- 堆序不变量：对于每条边 $(u,v)$，其中 $v$ 是 $u$ 的子节点，必须满足 $k(u) \\leq k(v)$。\n- 最小指针不变量：$min(H)$ 指向一个根节点，该节点的键等于 $H$ 中所有节点中的最小键。\n\n设计一个包含三个操作序列的测试套件。对于每个序列，将其应用于正确和有缺陷的堆，并生成一个布尔值，该值指示该序列是否通过在有缺陷的堆上违反至少一个不变量而揭示了错误，同时正确的堆保持所有不变量。这些序列是：\n\n- 序列 $S_1$ （揭示堆序违规的通用情况）：\n  1. 将键 $20$, $7$, $25$, $17$, $26$, $18$ 插入一个初始为空的堆 $H$。\n  2. 执行一次 `extract-min` 操作。\n  3. 选择任意一个非根节点 $x$ （一个满足 $parent(x) \\neq \\varnothing$ 的节点）。设 $p$ 是其父节点，$k(p)$ 是其键。执行 `decrease-key`($x, k(p) - 5$)。\n\n- 序列 $S_2$ （根节点减小键值揭示最小指针违规）：\n  1. 将键 $30$, $10$, $40$ 插入一个初始为空的堆 $H$。\n  2. 设 $r$ 是当前键为 $30$ 的根节点。执行 `decrease-key`($r, 5$)。\n\n- 序列 $S_3$ （保持不变量的边界情况）：\n  1. 将键 $50$, $60$, $70$, $80$ 插入一个初始为空的堆 $H$。\n  2. 执行一次 `extract-min` 操作。\n  3. 选择任意一个父节点为 $p$ 的非根节点 $x$。执行 `decrease-key`($x, k(p)$)。\n\n对于每个序列 $S_i$，你的程序必须计算一个布尔结果，当且仅当有缺陷的堆违反了至少一个所述不变量而正确的堆没有违反时，该结果为 $true$，否则为 $false$。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如 $[true,false,true]$。\n\n本问题中给出的所有数值均为无量纲整数；不涉及物理单位。角度不适用。百分比不适用。\n\n你的解决方案必须是一个完整的、可运行的程序，该程序构建正确和有缺陷的堆，执行指定的序列，检查不变量，并以所描述的精确格式为三个测试用例输出聚合的布尔结果。", "solution": "用户提供的问题陈述已经过分析和验证。它在科学上基于数据结构和算法的既定原则，特别是关于斐波那契堆的原则。该问题提法恰当、客观，并包含一套完整、一致的实现和测试规范。未发现与科学合理性、形式化、完整性、可行性或结构相关的缺陷。因此，该问题被视为 **有效**。\n\n下面是根据问题要求设计的完整解决方案。这涉及实现一个 `Node` 类、一个包含共享功能的 `BaseFibHeap` 类，以及两个子类：`CorrectFibHeap` 和 `FaultyFibHeap`，它们在 `decrease_key` 方法上有所不同。包含了不变量检查方法，用于在操作后验证堆的属性。最后，在两种堆的变体上执行三个测试序列，以确定有缺陷的实现中的错误是否被揭示。\n\n### 数据结构\n\n定义了一个 `Node` 类来表示堆中的元素。每个节点存储其 `key`、用于构建树和列表的 `parent`、`child`、`left` 和 `right` 指针。它还维护其 `degree`（子节点数量）和一个用于 `decrease_key` 操作的布尔值 `mark`。根据测试序列的要求，添加了一个 `initial_key` 属性来唯一标识节点以便检索。\n\n`BaseFibHeap` 类封装了两种堆实现的通用逻辑。这包括 `insert`、`extract_min` 和辅助函数 `consolidate`，这些对于两个版本都是相同的。它还包含用于验证两个关键不变量的方法：\n1.  **堆序不变量**：`_check_heap_order` 遍历所有节点，以确保对于每个节点 `u` 及其子节点 `v`，都有 $k(u) \\leq k(v)$。\n2.  **最小指针不变量**：`_check_min_pointer` 验证 `min_node` 指针引用的是一个根节点，且该节点的键是堆中所有键的最小值。\n\n### 堆的实现\n\n1.  **`CorrectFibHeap`**：此类实现了标准的斐波那契堆算法。其 `decrease_key` 方法通过执行 `cut` 和 `cascading_cut` 操作来正确处理对堆序性质的违反，并在创建新的最小值时更新堆的最小指针。\n\n2.  **`FaultyFibHeap`**：此类继承自 `BaseFibHeap`，但用问题中指定的有意错误的行​​为覆盖了 `decrease_key` 方法。此版本仅更改节点的键，不执行后续的结构调整（无剪切）或对最小指针的更新。\n\n### 测试序列与分析\n\n解决方案接着为三个测试序列（$S_1$、$S_2$、$S_3$）中的每一个定义一个函数。每个函数实例化一个 `CorrectFibHeap` 和一个 `FaultyFibHeap`，应用指定的操作序列，然后在两个堆上评估不变量。如果正确的堆保持有效而有缺陷的堆变为无效，则认为该序列揭示了错误。\n\n-   **序列 $S_1$ （堆序违规）**：在插入和一次 `extract_min` 操作后，一个非根节点的键被减小到小于其父节点的键的值。\n    -   **正确堆**：`decrease_key` 操作触发一次 `cut`，将该节点移动到根列表以恢复堆序性质。最小指针更新为这个新的、更小的根。所有不变量都得以保持。\n    -   **有缺陷的堆**：键被减小，但没有发生剪切。这创建了一条边 $(p, x)$，其中 $k(p) > k(x)$，违反了堆序不变量。最小指针未被更新，也违反了最小指针不变量。\n    -   **结果**：错误被揭示。结果为 `true`。\n\n-   **序列 $S_2$ （最小指针违规）**：一个根节点的键被减小到小于当前最小值的值。\n    -   **正确堆**：由于该节点是根节点，因此无需剪切。最小指针更新为此节点。所有不变量都得以保持。\n    -   **有缺陷的堆**：键被减小，但最小指针未被更新。该指针继续引用一个不再是最小值的节点，违反了最小指针不变量。\n    -   **结果**：错误被揭示。结果为 `true`。\n\n-   **序列 $S_3$ （边界情况）**：一个非根节点的键被减小到等于其父节点的键的值。\n    -   **正确堆**：新键不严格小于父节点的键（由于 $k(p) = k(x)$，所以 $k(p) \\leq k(x)$ 成立），因此不需要剪切。最小值没有改变。所有不变量都得以保持。\n    -   **有缺陷的堆**：键被减小。由于此更改没有违反堆序性质，也没有创建新的全局最小值，因此两个不变量都巧合地保持完好。\n    -   **结果**：错误未被揭示，因为有缺陷的堆仍然有效。结果为 `false`。\n\n最终程序将这些布尔结果整理成所需的输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Note: numpy is imported to adhere to the specified environment but is not used.\nimport math\n\nclass Node:\n    \"\"\"Represents a node in the Fibonacci heap.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.initial_key = key  # For stable node lookup\n        self.degree = 0\n        self.parent = None\n        self.child = None\n        self.left = self\n        self.right = self\n        self.mark = False\n\n    def __repr__(self):\n        return f\"Node({self.key})\"\n\nclass BaseFibHeap:\n    \"\"\"Base class with common Fibonacci heap functionality.\"\"\"\n    def __init__(self):\n        self.min_node = None\n        self.num_nodes = 0\n        self.nodes_by_initial_key = {}\n\n    def insert(self, key):\n        \"\"\"Inserts a new key into the heap.\"\"\"\n        node = Node(key)\n        self.nodes_by_initial_key[key] = node\n        self._add_to_root_list(node)\n        if self.min_node is None or node.key  self.min_node.key:\n            self.min_node = node\n        self.num_nodes += 1\n        return node\n    \n    def _add_to_root_list(self, node):\n        \"\"\"Adds a node to the circular doubly-linked root list.\"\"\"\n        if self.min_node is None:\n            self.min_node = node\n        else:\n            node.right = self.min_node.right\n            node.left = self.min_node\n            self.min_node.right.left = node\n            self.min_node.right = node\n\n    def _remove_from_list(self, node):\n        \"\"\"Removes a node from a circular doubly-linked list.\"\"\"\n        node.left.right = node.right\n        node.right.left = node.left\n\n    def extract_min(self):\n        \"\"\"Extracts the node with the minimum key.\"\"\"\n        z = self.min_node\n        if z is not None:\n            if z.child is not None:\n                child = z.child\n                while True:\n                    next_child = child.right\n                    child.parent = None\n                    self._add_to_root_list(child)\n                    if next_child == z.child:\n                        break\n                    child = next_child\n            \n            self._remove_from_list(z)\n\n            if z == z.right:\n                self.min_node = None\n            else:\n                self.min_node = z.right\n                self.consolidate()\n            self.num_nodes -= 1\n        return z\n\n    def consolidate(self):\n        \"\"\"Consolidates the root list to reduce the number of trees.\"\"\"\n        degree_table = {}\n        roots = []\n        if self.min_node is None:\n            return\n            \n        curr = self.min_node\n        while True:\n            roots.append(curr)\n            if curr.right == self.min_node:\n                break\n            curr = curr.right\n\n        for w in roots:\n            x = w\n            d = x.degree\n            while d in degree_table:\n                y = degree_table[d]\n                if x.key  y.key:\n                    x, y = y, x\n                self._link(y, x)\n                del degree_table[d]\n                d += 1\n            degree_table[d] = x\n\n        self.min_node = None\n        for d in degree_table:\n            node = degree_table[d]\n            node.left = node\n            node.right = node\n            self._add_to_root_list(node)\n            if self.min_node is None or node.key  self.min_node.key:\n                self.min_node = node\n\n    def _link(self, y, x):\n        \"\"\"Links tree rooted at y to tree rooted at x.\"\"\"\n        self._remove_from_list(y)\n        y.parent = x\n        if x.child is None:\n            x.child = y\n            y.right = y\n            y.left = y\n        else:\n            y.left = x.child\n            y.right = x.child.right\n            x.child.right.left = y\n            x.child.right = y\n        x.degree += 1\n        y.mark = False\n\n    def _iter_nodes(self):\n        \"\"\"Generator to iterate over all nodes in the heap.\"\"\"\n        if not self.min_node:\n            return\n        \n        q = []\n        visited = set()\n\n        curr = self.min_node\n        while True:\n            q.append(curr)\n            if curr.right == self.min_node:\n                break\n            curr = curr.right\n            \n        while q:\n            node = q.pop(0)\n            if node in visited: continue\n            visited.add(node)\n            yield node\n            if node.child:\n                child = node.child\n                while True:\n                    q.append(child)\n                    if child.right == node.child:\n                        break\n                    child = child.right\n\n    def check_invariants(self):\n        \"\"\"Checks both heap invariants.\"\"\"\n        return self._check_heap_order() and self._check_min_pointer()\n\n    def _check_heap_order(self):\n        \"\"\"Checks if k(parent) = k(child) for all nodes.\"\"\"\n        for node in self._iter_nodes():\n            if node.child:\n                child = node.child\n                while True:\n                    if node.key  child.key:\n                        return False\n                    if child.parent != node:\n                        return False # Parent pointer check\n                    if child.right == node.child:\n                        break\n                    child = child.right\n        return True\n\n    def _check_min_pointer(self):\n        \"\"\"Checks if min_node points to a root with the minimum key.\"\"\"\n        if self.num_nodes == 0:\n            return self.min_node is None\n        \n        if self.min_node is None:\n            return False\n            \n        if self.min_node.parent is not None:\n            return False # Min node must be a root\n\n        actual_min_key = float('inf')\n        for node in self._iter_nodes():\n            actual_min_key = min(actual_min_key, node.key)\n\n        return self.min_node.key == actual_min_key\n    \n    def get_any_non_root(self):\n        for node in self._iter_nodes():\n            if node.parent is not None:\n                return node\n        return None\n\nclass CorrectFibHeap(BaseFibHeap):\n    \"\"\"A correct implementation of a Fibonacci heap.\"\"\"\n    def decrease_key(self, x, k):\n        if k  x.key:\n            raise ValueError(\"New key is greater than current key\")\n        x.key = k\n        p = x.parent\n        if p is not None and x.key  p.key:\n            self._cut(x, p)\n            self._cascading_cut(p)\n        if x.key  self.min_node.key:\n            self.min_node = x\n\n    def _cut(self, x, p):\n        self._remove_from_list(x)\n        if x.right == x:\n            p.child = None\n        else:\n            p.child = x.right\n        p.degree -= 1\n        self._add_to_root_list(x)\n        x.parent = None\n        x.mark = False\n\n    def _cascading_cut(self, p):\n        pp = p.parent\n        if pp is not None:\n            if not p.mark:\n                p.mark = True\n            else:\n                self._cut(p, pp)\n                self._cascading_cut(pp)\n\nclass FaultyFibHeap(BaseFibHeap):\n    \"\"\"A faulty implementation of a Fibonacci heap for testing.\"\"\"\n    def decrease_key(self, x, k):\n        if k  x.key:\n            raise ValueError(\"New key is greater than current key\")\n        x.key = k\n        # Intentionally does not perform cuts or update min_node\n\ndef run_sequence(sequence_id):\n    \"\"\"Runs a test sequence on both correct and faulty heaps.\"\"\"\n    correct_heap = CorrectFibHeap()\n    faulty_heap = FaultyFibHeap()\n\n    if sequence_id == 1:\n        keys_to_insert = [20, 7, 25, 17, 26, 18]\n        for key in keys_to_insert:\n            correct_heap.insert(key)\n            faulty_heap.insert(key)\n        \n        correct_heap.extract_min()\n        faulty_heap.extract_min()\n        \n        node_c = correct_heap.get_any_non_root()\n        node_f = faulty_heap.nodes_by_initial_key[node_c.initial_key]\n        \n        parent_key = node_c.parent.key\n        new_key = parent_key - 5\n        \n        correct_heap.decrease_key(node_c, new_key)\n        faulty_heap.decrease_key(node_f, new_key)\n\n    elif sequence_id == 2:\n        keys_to_insert = [30, 10, 40]\n        for key in keys_to_insert:\n            correct_heap.insert(key)\n            faulty_heap.insert(key)\n        \n        node_c = correct_heap.nodes_by_initial_key[30]\n        node_f = faulty_heap.nodes_by_initial_key[30]\n        \n        correct_heap.decrease_key(node_c, 5)\n        faulty_heap.decrease_key(node_f, 5)\n\n    elif sequence_id == 3:\n        keys_to_insert = [50, 60, 70, 80]\n        for key in keys_to_insert:\n            correct_heap.insert(key)\n            faulty_heap.insert(key)\n        \n        correct_heap.extract_min()\n        faulty_heap.extract_min()\n\n        node_c = correct_heap.get_any_non_root()\n        node_f = faulty_heap.nodes_by_initial_key[node_c.initial_key]\n\n        new_key = node_c.parent.key\n\n        correct_heap.decrease_key(node_c, new_key)\n        faulty_heap.decrease_key(node_f, new_key)\n        \n    correct_valid = correct_heap.check_invariants()\n    faulty_valid = faulty_heap.check_invariants()\n\n    return correct_valid and not faulty_valid\n\ndef solve():\n    \"\"\"\n    Main function to execute the test sequences and print results.\n    \"\"\"\n    results = [\n        run_sequence(1),\n        run_sequence(2),\n        run_sequence(3)\n    ]\n    \n    # Format the final output as a comma-separated list of lowercase booleans\n    # e.g., [true,false,true]\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```", "id": "3234524"}, {"introduction": "检验是否真正掌握一个数据结构的标志，是能否为其拓展新的功能。本练习要求你实现一个 `split` 操作，根据一个给定的键值将一个斐波那契堆分割成两个。这项任务不仅需要你遍历堆的复杂内部结构，还要利用基础的 `insert` 操作来构建新堆，这将全面巩固你对整个数据结构的驾驭能力。[@problem_id:3234478]", "problem": "设计并实现一个完整、可运行的程序，以实现对斐波那契堆（FH）的分割操作。斐波那契堆是由满足堆序性质的树组成的集合，它支持一组具有较低攤還时间的操作。设计的根本基础必须是堆序性质：对于任意一个键值为 $k_p$ 的父节点及其任意一个键值为 $k_c$ 的子节点，关系 $k_p \\le k_c$ 恒成立。该堆表示为一个由树根组成的循环双向链表，每个根是一个满足堆序性质的树的入口点。在任何算法中需要保持的关键结构不变量是：堆序性质、根节点之间的循环双向链表结构、正确的父子关系以及一个指向堆中最小键根节点的指针。\n\n你的任务是：\n- 从堆序性质出发，推導出一个正确的算法，将给定的斐波那契堆 $H$ 根据阈值 $x \\in \\mathbb{Z}$ 分割成两个斐波那契堆 $(H_{\\le}, H_{})$，使得 $H_{\\le}$ 恰好包含 $H$ 中所有键 $k$ 满足 $k \\le x$ 的元素，而 $H_{}$ 恰好包含所有键 $k$ 满足 $k  x$ 的元素。\n- 在一个程序中实现该算法，该程序能从给定的整数键序列构建斐波那契堆，可选地执行指定次数的提取最小值操作以创建非平凡的树结构，然后应用分割操作产生 $(H_{\\le}, H_{})$。\n- 对于每个测试用例，计算并返回可用于自动验证的量化结果：\n  - $c_{\\le}$：$H_{\\le}$ 中的键的数量（整数）。\n  - $c_{}$：$H_{}$ 中的键的数量（整数）。\n  - $s_{\\le}$：$H_{\\le}$ 中的键的总和（整数）。\n  - $s_{}$：$H_{}$ 中的键的总和（整数）。\n  - $m_{\\le}$：$H_{\\le}$ 中的最小键，如果 $H_{\\le}$ 为空则为 $-1$（整数）。\n  - $m_{}$：$H_{}$ 中的最小键，如果 $H_{}$ 为空则为 $-1$（整数）。\n  - $v$：一个布尔标志，当且仅当以下所有条件都成立时为真：\n    - $H_{\\le}$ 中的每个键 $k$ 都满足 $k \\le x$，并且 $H_{}$ 中的每个键 $k$ 都满足 $k  x$。\n    - $H_{\\le}$ 和 $H_{}$ 中键的多重集并集等于 $H$ 中原有的键的多重集。\n    - $H_{\\le}$ 和 $H_{}$ 都满足堆序性质并且拥有正确的最小指针（如果非空），即存储的最小值等于存在的最小键。\n\n程序要求：\n- 使用显式节点表示斐波那契堆，节点包含键、度、标记、父指针、一个子指针以及构成循环双向链表的左右兄弟指针等字段。\n- 仅使用从定义中推导出的、逻辑上合理的标准操作：插入、合并（union/meld）、以及带有通过重复链接度数相同的树来进行合并（consolidation）功能的 `extract-min`（提取最小值）操作。\n- 分割算法必须从堆序性质推导而来，可以通过遍历 $H$ 的所有节点一次并将每个键插入到合适的目标堆中来实现。向斐波那契堆中插入操作的攤還时间为 $O(1)$；遍历会以常数次数访问每个节点，因此总攤還时间为 $O(n)$，其中 $n$ 是节点数。\n\n测试套件和构建协议：\n- 对于每个测试用例，通过按给定顺序插入键来构建堆 $H$。然后，执行恰好 $e$ 次 `extract-min` 操作（如果 $H$ 在 $e$ 次提取完成前变空，则忽略后续的提取）。最后，在阈值 $x$ 处执行分割。\n- 使用以下测试套件，其中每个测试用例是一个三元组 $(\\langle k_1, k_2, \\dots, k_m \\rangle, x, e)$：\n  - 测试 $1$：$\\left(\\langle 7, 3, 18, 39, 52, 41, 17, 30, 24, 26, 46 \\rangle, x = 30, e = 1\\right)$。\n  - 测试 $2$：$\\left(\\langle 1, 2, 2, 2, 3 \\rangle, x = 3, e = 0\\right)$。\n  - 测试 $3$：$\\left(\\langle 10, 11, 12 \\rangle, x = 5, e = 0\\right)$。\n  - 测试 $4$：$\\left(\\langle -5, -1, 0, 0, 6, 6, 7 \\rangle, x = 0, e = 2\\right)$。\n  - 测试 $5$：$\\left(\\langle \\rangle, x = 0, e = 0\\right)$ (空堆)。\n  - 测试 $6$：$\\left(\\langle 5, 5, 5 \\rangle, x = 5, e = 1\\right)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素是每个测试用例的列表 $[c_{\\le}, c_{}, s_{\\le}, s_{}, m_{\\le}, m_{}, v]$。例如，形式为 $[[\\dots],[\\dots],\\dots]$ 的一行。\n- 不从标准输入读取任何输入。所有计算均由编译进程序中的测试套件确定。\n- 不涉及物理单位或角度；所有键和输出都是无单位的整数或布尔值。", "solution": "该问题要求设计并实现一个斐波那契堆的 `split` 操作。一个给定的斐波那契堆 $H$ 需要根据指定的整数阈值 $x$ 被分割成两个新的斐波那契堆 $H_{\\le}$ 和 $H_{}$。$H_{\\le}$ 必须包含 $H$ 中所有键 $k \\le x$ 的元素，而 $H_{}$ 必须包含所有键 $k  x$ 的元素。该算法必须从基本的堆序性质推导而来，并且解决方案必须包括一个完整、可运行的程序，实现该堆、分割操作，并为给定的测试套件计算多个验证指标。\n\n斐波那契堆是一种优先队列的具体实现，由一组满足堆序性质的树组成。这些树的根被维护在一个循环双向链表中。其定义性特征是**堆序性质**：对于任意节点 $p$（键值为 $k_p$）及其任意子节点 $c$（键值为 $k_c$），不等式 $k_p \\le k_c$ 必须成立。此性质意味着沿任何从根到叶的路径，键值都是非递减的。堆维护一个指针 `min_node`，指向具有最小键的根节点，从而允许以 $O(1)$ 的时间访问最小元素。主要操作包括插入、查找最小值、提取最小值、减小键值和合并（union）。斐波那契堆的效率源于其“惰性”性质，即结构性工作被推迟到执行 `extract-min` 操作时才进行。\n\n任务是设计一个 `split(H, x)` 算法。为了对 $H$ 中的键集合进行划分，必须检查每一个键，以确定它是小于等于 $x$ 还是大于 $x$。因此，需要对堆 $H$ 中的所有节点进行一次完整遍历，这需要 $O(n)$ 的时间，其中 $n$ 是 $H$ 中的节点数。设遍历中的一个节点为 $u$。\n\n推导的核心与堆序性质有关。最终的结构 $H_{\\le}$ 和 $H_{}$ 必须是有效的斐波那契堆，这意味着它们必须满足所有结构不变量，其中最主要的是堆序性质。一个保证这一点的健壮且直接的方法是使用一系列有效的堆操作从头构建 $H_{\\le}$ 和 $H_{}$。\n\n提出的算法如下：\n1. 初始化两个新的空斐波那契堆，$H_{\\le}$ 和 $H_{}$。\n2. 遍历原始堆 $H$ 中的每一个节点 $u$。这可以通过从根列表中的根开始进行广度优先或深度优先搜索来完成。\n3. 对于每个键为 $k$ 的节点 $u$，将 $k$ 与阈值 $x$ 进行比较。\n   - 如果 $k \\le x$，使用其标准的 `insert` 操作将键 $k$ 插入到 $H_{\\le}$ 中。\n   - 如果 $k  x$，使用其 `insert` 操作将键 $k$ 插入到 $H_{}$ 中。\n4. 在处理完 $H$ 中的所有节点后，$H_{\\le}$ 和 $H_{}$ 就包含了划分后的键集合，并且根据构造方法，它们是有效的斐波那契堆。\n\n该算法的正确性直接“从堆序性质推导而来”，因为 `insert` 操作从根本上就是为了保持此性质而设计的。通过完全使用 `insert` 来构建新堆，我们确保了最终的结构是有效的。虽然可以构想更复杂的、涉及剪切子树和重构的原地算法，但对于此划分任务，它们并没有渐近时间复杂度上的优势，反而引入了显著的出错机会。遍历并重新插入的方法利用了基本 `insert` 操作的已证实的正确性，该操作的攤還时间为 $O(1)$。由于遍历会访问 $n$ 个节点中的每一个一次，因此分割操作的总攤還时间复杂度为 $O(n)$。\n\n实现需要一个完整的斐波那契堆数据结构。一个 `Node` 类封装了以下字段：`key`、`degree`（子节点数）、`mark`（用于 `decrease-key` 操作，尽管在本问题中不核心）、`parent`、`child`、`left` 和 `right` 兄弟指针。`FibonacciHeap` 类管理节点集合，维护一个指向最小键根节点 `min_node` 的指针和一个总节点数 `num_nodes`。需要实现的关键操作有：\n- `insert(key)`: 创建一个新的单节点树，并以 $O(1)$ 时间将其添加到根列表中。\n- `extract_min()`: 移除最小节点，将其子节点提升到根列表，并调用 `consolidate()` 来重组堆。这是最复杂的操作。\n- `consolidate()`: 合并根列表中的树，使得没有两棵树具有相同的度。这是通过迭代地链接度数相同的树来实现的。它确保了任何节点的最大度都有对数界。\n- `get_all_nodes()`: 一个遍历函数，用于访问堆中的每个节点，这对于 `split` 操作和验证都是必需的。\n- `split(x)`: 实现上述的遍历和重新插入算法。\n\n最后，对于每个测试用例，程序构建一个堆，执行指定次数的 `extract-min` 操作，然后执行 `split`。通过以下方式验证结果：\n1. 遍历最终的堆 $H_{\\le}$ 和 $H_{}$ 以收集它们的键。\n2. 计算所需的指标：数量 ($c_{\\le}, c_{}$)、总和 ($s_{\\le}, s_{}$) 和最小值 ($m_{\\le}, m_{}$)。\n3. 为布尔标志 $v$ 执行一系列检查：\n   - **划分正确性**：$H_{\\le}$ 中的每个键必须 $\\le x$，而 $H_{}$ 中的每个键必须 $ x$。\n   - **键值守恒**：$H_{\\le}$ 和 $H_{}$ 中键的多重集并集必须与分割前原始堆 $H$ 中的键的多重集完全相同。\n   - **堆的有效性**：$H_{\\le}$ 和 $H_{}$ 都必须是结构上有效的斐波那契堆，这通过检查所有父子对的堆序性质并确认 `min_node` 指针是否正确来验证。\n这些指标的集合为算法的正确性提供了全面且可自动验证的评估。", "answer": "```python\nimport numpy as np\n\n# A meticulous and complete implementation of a Fibonacci Heap.\nclass FibonacciHeap:\n    \"\"\"\n    Implements a Fibonacci Heap data structure supporting insert, extract-min,\n    and a custom split operation.\n    \"\"\"\n    class Node:\n        \"\"\"Represents a node in the heap.\"\"\"\n        def __init__(self, key):\n            self.key = key\n            self.degree = 0\n            self.parent = None\n            self.child = None\n            self.left = self\n            self.right = self\n            self.mark = False\n\n    def __init__(self):\n        \"\"\"Initializes an empty Fibonacci Heap.\"\"\"\n        self.min_node = None\n        self.num_nodes = 0\n\n    def is_empty(self):\n        \"\"\"Returns True if the heap is empty, False otherwise.\"\"\"\n        return self.min_node is None\n\n    def insert(self, key):\n        \"\"\"Inserts a new key into the heap.\"\"\"\n        node = self.Node(key)\n        if self.min_node is None:\n            self.min_node = node\n        else:\n            # Add node to the root list\n            node.right = self.min_node.right\n            node.left = self.min_node\n            self.min_node.right.left = node\n            self.min_node.right = node\n            if key  self.min_node.key:\n                self.min_node = node\n        self.num_nodes += 1\n        return node\n\n    def get_min(self):\n        \"\"\"Returns the minimum key in the heap.\"\"\"\n        return self.min_node.key if self.min_node is not None else None\n\n    def _link(self, y, x):\n        \"\"\"Makes node y a child of node x.\"\"\"\n        # Remove y from root list\n        y.left.right = y.right\n        y.right.left = y.left\n        \n        # Make y a child of x\n        y.parent = x\n        if x.child is None:\n            x.child = y\n            y.right = y\n            y.left = y\n        else:\n            y.left = x.child\n            y.right = x.child.right\n            x.child.right.left = y\n            x.child.right = y\n        x.degree += 1\n        y.mark = False\n\n    def _consolidate(self):\n        \"\"\"Consolidates the root list to enforce the property of unique degrees.\"\"\"\n        if self.num_nodes = 1:\n            return\n        \n        # The max degree is bounded by log_phi(n)\n        max_degree = int(np.floor(np.log(self.num_nodes) / np.log((1 + np.sqrt(5)) / 2))) + 2\n        A = [None] * max_degree\n        \n        roots = []\n        curr = self.min_node\n        start = self.min_node\n        if curr is None: return\n        while True:\n            roots.append(curr)\n            curr = curr.right\n            if curr == start:\n                break\n        \n        for root in roots:\n            x = root\n            d = x.degree\n            while A[d] is not None:\n                y = A[d]\n                if x.key  y.key:\n                    x, y = y, x\n                self._link(y, x)\n                A[d] = None\n                d += 1\n            A[d] = x\n\n        self.min_node = None\n        for node in A:\n            if node is not None:\n                if self.min_node is None:\n                    self.min_node = node\n                    node.left = node.right = node\n                else:\n                    node.left = self.min_node\n                    node.right = self.min_node.right\n                    self.min_node.right.left = node\n                    self.min_node.right = node\n                    if node.key  self.min_node.key:\n                        self.min_node = node\n\n    def extract_min(self):\n        \"\"\"Extracts the minimum node from the heap.\"\"\"\n        z = self.min_node\n        if z is not None:\n            # Add children to the root list\n            if z.child is not None:\n                child = z.child\n                while True:\n                    next_child = child.right\n                    child.parent = None\n                    # Add child to root list next to z\n                    child.left = z\n                    child.right = z.right\n                    z.right.left = child\n                    z.right = child\n                    if next_child == z.child:\n                        break\n                    child = next_child\n\n            # Remove z from the root list\n            z.left.right = z.right\n            z.right.left = z.left\n\n            if z == z.right:\n                self.min_node = None\n            else:\n                self.min_node = z.right\n                self._consolidate()\n            \n            self.num_nodes -= 1\n        return z\n\n    def get_all_nodes(self):\n        \"\"\"Returns a list of all nodes in the heap via a traversal.\"\"\"\n        if self.is_empty():\n            return []\n        \n        all_nodes = []\n        queue = []\n        visited_roots = set()\n\n        # Add all roots to the queue to start traversal\n        start_node = self.min_node\n        curr = start_node\n        while True:\n            if curr in visited_roots: break\n            visited_roots.add(curr)\n            queue.append(curr)\n            curr = curr.right\n            if curr == start_node: break\n        \n        head = 0\n        while head  len(queue):\n            node = queue[head]\n            head += 1\n            all_nodes.append(node)\n            \n            if node.child is not None:\n                child_start = node.child\n                curr_child = child_start\n                while True:\n                    queue.append(curr_child)\n                    curr_child = curr_child.right\n                    if curr_child == child_start: break\n        \n        return all_nodes\n\n    def split(self, x):\n        \"\"\"Splits the heap into two heaps based on threshold x.\"\"\"\n        nodes = self.get_all_nodes()\n        h_le = FibonacciHeap()\n        h_gt = FibonacciHeap()\n        for node in nodes:\n            if node.key = x:\n                h_le.insert(node.key)\n            else:\n                h_gt.insert(node.key)\n        return h_le, h_gt\n\n    def is_valid(self):\n        \"\"\"Verifies the heap-order property and the min_node pointer.\"\"\"\n        if self.min_node is None:\n            return self.num_nodes == 0\n        \n        all_nodes = self.get_all_nodes()\n        if len(all_nodes) != self.num_nodes:\n            return False\n\n        if not all_nodes:\n            return self.num_nodes == 0\n\n        actual_min_key = float('inf')\n        for node in all_nodes:\n            actual_min_key = min(actual_min_key, node.key)\n            if node.parent is None: # It's a root\n                pass # No parent to check against\n            \n            if node.child is not None:\n                child_start = node.child\n                curr_child = child_start\n                while True:\n                    if curr_child.key  node.key: return False # Heap-order violation\n                    if curr_child.parent != node: return False # Parent pointer mismatch\n                    curr_child = curr_child.right\n                    if curr_child == child_start: break\n        \n        return self.min_node.key == actual_min_key\n\ndef solve():\n    \"\"\"\n    Runs the test suite for the Fibonacci heap split operation and prints results.\n    \"\"\"\n    test_cases = [\n        (tuple([7, 3, 18, 39, 52, 41, 17, 30, 24, 26, 46]), 30, 1),\n        (tuple([1, 2, 2, 2, 3]), 3, 0),\n        (tuple([10, 11, 12]), 5, 0),\n        (tuple([-5, -1, 0, 0, 6, 6, 7]), 0, 2),\n        (tuple([]), 0, 0),\n        (tuple([5, 5, 5]), 5, 1)\n    ]\n\n    final_results = []\n    for keys, x, e in test_cases:\n        h = FibonacciHeap()\n        for k in keys:\n            h.insert(k)\n\n        for _ in range(e):\n            if h.is_empty():\n                break\n            h.extract_min()\n\n        original_keys_after_extraction = sorted([node.key for node in h.get_all_nodes()])\n\n        h_le, h_gt = h.split(x)\n\n        keys_le = [node.key for node in h_le.get_all_nodes()]\n        keys_gt = [node.key for node in h_gt.get_all_nodes()]\n\n        c_le = len(keys_le)\n        c_gt = len(keys_gt)\n        s_le = sum(keys_le) if c_le  0 else 0\n        s_gt = sum(keys_gt) if c_gt  0 else 0\n        m_le = h_le.get_min() if c_le  0 else -1\n        m_gt = h_gt.get_min() if c_gt  0 else -1\n\n        v = True\n        # 1. Partition correctness\n        if not all(k = x for k in keys_le): v = False\n        if not all(k  x for k in keys_gt): v = False\n        # 2. Key conservation\n        if sorted(keys_le + keys_gt) != original_keys_after_extraction: v = False\n        # 3. Heap validity\n        if not h_le.is_valid(): v = False\n        if not h_gt.is_valid(): v = False\n\n        final_results.append([c_le, c_gt, s_le, s_gt, m_le, m_gt, v])\n\n    print(f\"[{','.join(f'[{\",\".join(map(str, res))}]' for res in final_results)}]\")\n\nsolve()\n```", "id": "3234478"}]}