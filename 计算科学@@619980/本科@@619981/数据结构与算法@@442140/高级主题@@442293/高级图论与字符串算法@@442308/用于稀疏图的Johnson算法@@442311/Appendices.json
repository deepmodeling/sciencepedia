{"hands_on_practices": [{"introduction": "Johnson 算法的核心在于其巧妙的重赋权（reweighting）步骤，它能消除负权重边，从而允许使用高效的 Dijkstra 算法。在动手实现整个算法之前，从数学上深入理解重赋权的性质至关重要。这项练习 [@problem_id:3242440] 将引导你推导重赋权后边权重的一个精确上界，这能让你深刻理解原始权重、最短路径和新的非负权重之间的内在联系。", "problem": "考虑一个有向图 $G=(V,E)$，其权重函数为 $w:E \\to \\mathbb{R}$，并假设 $G$ 中没有负权重环。为了计算稀疏图上的所有点对最短路径，Johnson 算法会添加一个新的源顶点 $s$ 以及对于每个 $v \\in V$ 添加一条零权重边 $(s,v)$，然后从 $s$ 开始运行 Bellman-Ford 算法来计算一个势函数 $h:V \\to \\mathbb{R}$，其中 $h(v)$ 等于增广图 $G'$ 中从 $s$ 到 $v$ 的最短路径距离。该算法随后使用势函数将每条边 $(u,v) \\in E$ 的权重重新赋为 $w'(u,v)$。令 $d(x,y)$ 表示原始图 $G$ 中（使用权重函数 $w$）从 $x$ 到 $y$ 的最短路径距离，由于 $G$ 没有负权重环，这个距离是明确定义的。\n\n从最短路径距离和路径拼接的基本定义出发，推导对于任意边 $(u,v) \\in E$ 的重赋权边权重 $w'(u,v)$ 的最紧可能上界。该上界必须仅用 $w(u,v)$ 以及在增广和重赋权之前由原始图 $G$ 决定的量来表示。你的最终答案必须是一个单一的闭式解析表达式。无需进行取整。", "solution": "问题陈述经过严格验证，被认定是自洽的，在算法理论方面具有科学依据，且提法明确。它没有任何验证标准中列出的缺陷。因此，下面推导出正式的解。\n\n设 $G=(V,E)$ 是一个有向图，其权重函数 $w:E \\to \\mathbb{R}$ 为实值函数，且图中没有负权重环。设 $(u,v)$ 是 $E$ 中的一条任意边。问题要求解出在 Johnson 算法中定义的重赋权边权重 $w'(u,v)$ 的最紧可能上界。\n\nJohnson 算法中的重赋权过程依赖于一个势函数 $h:V \\to \\mathbb{R}$。对于一条边 $(u,v) \\in E$，其重赋权后的边权重 $w'(u,v)$ 定义为：\n$$w'(u,v) = w(u,v) + h(u) - h(v)$$\n\n对于每个顶点 $v \\in V$，势函数 $h(v)$ 的计算方法是：引入一个新顶点 $s$ 构成增广图 $G'$。在 $G'$ 中，对于每个顶点 $v \\in V$，添加一条权重为 $w(s,v)=0$ 的新边 $(s,v)$。然后，势函数 $h(v)$ 定义为这个增广图 $G'$ 中从 $s$ 到 $v$ 的最短路径距离。我们用 $d(x,y)$ 表示原始图 $G$ 中从顶点 $x$到顶点 $y$ 的最短路径距离。由于 $G$ 没有负权重环，所以对于所有 $x,y \\in V$，$d(x,y)$ 都是明确定义的。\n\n在 $G'$ 中，从 $s$ 到 $v$ 的路径必须以一条形如 $(s,x)$（其中 $x \\in V$）的边开始，后接一条仅使用原始图 $G$ 中边的从 $x$ 到 $v$ 的路径。这样一条路径的权重为 $w(s,x) + \\text{weight}(\\text{path } x \\to v) = 0 + \\text{weight}(\\text{path } x \\to v)$。为了找到从 $s$ 到 $v$ 的最短路径距离，我们必须在所有可能的首个顶点 $x$ 的选择中，找到权重最小的路径。从 $x$到 $v$ 的子路径本身必须是 $G$ 中的一条最短路径。因此，势函数 $h(v)$ 可以用原始图 $G$ 中的最短路径距离来表示：\n$$h(v) = \\delta_{G'}(s,v) = \\min_{x \\in V} \\{d(x,v)\\}$$\n注意，由于 $G$ 中没有负权重环，对于任何 $x \\in V$ 都有 $d(x,x)=0$。因此，$h(v) = \\min_{x \\in V} \\{d(x,v)\\} \\le d(v,v) = 0$，所以对于所有 $v \\in V$，都有 $h(v) \\le 0$。\n\n我们的目标是找到 $w'(u,v) = w(u,v) + h(u) - h(v)$ 的一个上界。这等价于找到 $h(u) - h(v)$ 这一项的上界。\n\n根据 $G$ 中最短路径的定义，三角不等式成立。对于任意三个顶点 $x, v, u \\in V$，从 $x$ 到 $u$ 的最短路径不会比先沿着一条最短路径从 $x$ 到 $v$，再沿着一条最短路径从 $v$ 到 $u$ 的路径更长。这便得出不等式：\n$$d(x,u) \\le d(x,v) + d(v,u)$$\n如果从 $v$到 $u$ 没有路径，则 $d(v,u) = \\infty$，该不等式平凡成立。\n\n这个不等式对任意顶点 $x \\in V$ 的选择都有效。既然它对所有的 $x$ 都成立，那么它对所有 $x \\in V$ 取最小值后也必然成立。\n$$\\min_{x \\in V} \\{d(x,u)\\} \\le \\min_{x \\in V} \\{d(x,v) + d(v,u)\\}$$\n项 $d(v,u)$ 相对于对 $x$ 的最小化而言是一个固定值。因此，它可以从右侧的最小化运算中提出来：\n$$\\min_{x \\in V} \\{d(x,u)\\} \\le \\left(\\min_{x \\in V} \\{d(x,v)\\}\\right) + d(v,u)$$\n代入势函数 $h$ 的定义，我们得到：\n$$h(u) \\le h(v) + d(v,u)$$\n整理这个不等式，可得到差值 $h(u) - h(v)$ 的一个上界：\n$$h(u) - h(v) \\le d(v,u)$$\n现在，我们将此结果代回重赋权边 $(u,v)$ 的表达式中：\n$$w'(u,v) = w(u,v) + h(u) - h(v) \\le w(u,v) + d(v,u)$$\n这就得到了 $w'(u,v)$ 的一个上界，该上界完全用原始图 $G$ 中的量来表示：边自身的权重 $w(u,v)$，以及从 $v$ 回到 $u$ 的最短路径距离 $d(v,u)$。\n\n为证明这是最紧可能上界，我们必须证明对于某个图 $G$ 和某条边 $(u,v) \\in E$，这个界是可以达到的。等式成立的充要条件是 $h(u)-h(v) = d(v,u)$。\n\n考虑一个图 $G=(V,E)$，其中 $V=\\{u, v, z\\}$，边集 $E = \\{(u,v), (v,u), (z,v)\\}$。设权重定义为 $w(u,v) = 10$，$w(v,u) = 2$ 以及 $w(z,v)=-5$。\n该图没有负权重环，因为唯一的环 $u \\to v \\to u$ 的权重为 $w(u,v)+w(v,u) = 10+2=12 > 0$。\n\n我们来计算 $G$ 中必要的最短路径距离 $d(x,y)$：\n$d(v,u) = w(v,u) = 2$。\n$d(z,v) = w(z,v) = -5$。\n$d(z,u)$ 是从 $z$ 到 $u$ 的最短路径。路径 $z \\to v \\to u$ 的权重为 $w(z,v)+w(v,u) = -5+2=-3$。这是唯一的路径，所以 $d(z,u)=-3$。\n\n现在我们计算势函数 $h(u)$ 和 $h(v)$：\n$h(u) = \\min\\{d(u,u), d(v,u), d(z,u)\\} = \\min\\{0, 2, -3\\} = -3$。\n$h(v) = \\min\\{d(u,v), d(v,v), d(z,v)\\} = \\min\\{10, 0, -5\\} = -5$。\n\n使用这些势函数，我们求得重赋权后的边权重 $w'(u,v)$：\n$w'(u,v) = w(u,v) + h(u) - h(v) = 10 + (-3) - (-5) = 10 - 3 + 5 = 12$。\n\n现在，我们来计算针对这条特定边推导出的上界：\n$w(u,v) + d(v,u) = 10 + 2 = 12$。\n\n由于 $w'(u,v) = 12$ 并且上界计算结果也为 $12$，所以这个界是可达的。这证明了上界 $w(u,v) + d(v,u)$ 确实是最紧可能上界。", "answer": "$$\\boxed{w(u,v) + d(v,u)}$$", "id": "3242440"}, {"introduction": "Johnson 算法是一个多阶段的过程，其中每一步都环环相扣。如果某个步骤执行不当，会发生什么呢？这个思想实验 [@problem_id:3242397] 探讨了当用于计算势能（potentials）的 Bellman-Ford 步骤提前终止时的后果。通过分析由此引发的连锁错误——从不正确的势能到可能出现的负权重，再到 Dijkstra 算法的失效——你将能体会到算法中每个组件的正确性为何都至关重要。", "problem": "考虑一个有向图 $G = (V,E)$，其中 $V = \\{v_{1}, v_{2}, v_{3}\\}$，边权重函数 $w : E \\to \\mathbb{R}$ 由以下边给出：$(v_{1}, v_{2})$ 的权重为 $w(v_{1}, v_{2}) = 1$，$(v_{1}, v_{3})$ 的权重为 $w(v_{1}, v_{3}) = 0$，以及 $(v_{2}, v_{3})$ 的权重为 $w(v_{2}, v_{3}) = -2$。图中没有其他边。假设 $G$ 中没有负权重环。\n\nJohnson 算法通过增加一个超级源点 $s^{*}$ 和对每个 $v \\in V$ 增加权重为 $0$ 的边 $(s^{*}, v)$ 来增强图 $G$，然后从 $s^{*}$ 运行 Bellman–Ford 算法以获得顶点势函数，并使用这些势能为边重新赋权。之后，从每个源点运行 Dijkstra 算法以生成所有点对的最短路径距离，这些距离最终被映射回原始权重。\n\n在本问题中，Bellman–Ford 步骤在恰好一次松弛迭代后提前终止，产生一个近似的势函数 $\\tilde{h}$，并且算法照常进行重新赋权和运行 Dijkstra 算法，以生成在原始权重下所有有序点对 $(u,v) \\in V \\times V$ 的报告距离。\n\n仅使用最短路径距离的定义、Bellman–Ford 算法经过 $k$ 次松弛迭代后能对所有从源点出发且至多包含 $k$ 条边的路径产生正确距离的这一性质、以及 Dijkstra 算法要求边权重为非负的这一要求，确定在这个提前终止的 Johnson 算法报告的距离与 $G$ 中的真实最短路径距离之间，在所有有序点对 $(u,v) \\in V \\times V$ 上的最大绝对误差。将你的最终答案表示为一个实数。无需四舍五入。", "solution": "问题陈述经核实具有科学依据、提法恰当且客观。它提供了一个有向图和 Johnson 算法修改版的完整且一致的描述。任务是分析此修改的后果，这是一个算法领域中的可形式化问题。陈述中没有矛盾、歧义或事实错误。我们可以开始求解。\n\n解决方案包含三个主要部分：\n1.  计算给定图 $G$ 中真实的所有点对最短路径距离。\n2.  模拟所述的提前终止的 Johnson 算法，以找到报告的所有点对最短路径距离。\n3.  比较真实距离和报告距离，以找到最大绝对误差。\n\n**第 1 部分：真实最短路径距离**\n\n图为 $G=(V, E)$，其中 $V = \\{v_1, v_2, v_3\\}$，边的权重为 $w(v_1, v_2) = 1$，$w(v_1, v_3) = 0$ 和 $w(v_2, v_3) = -2$。该图是一个有向无环图 (DAG)，因此最短路径是良定义的。我们将从顶点 $u$ 到顶点 $v$ 的真实最短路径距离表示为 $\\delta(u,v)$。\n\n-   从 $v_1$ 出发的路径：\n    -   到 $v_1$：最短路径长度为 $0$。$\\delta(v_1, v_1) = 0$。\n    -   到 $v_2$：唯一的路径是 $v_1 \\to v_2$。$\\delta(v_1, v_2) = w(v_1, v_2) = 1$。\n    -   到 $v_3$：有两条路径：$v_1 \\to v_3$ 的权重为 $0$，以及 $v_1 \\to v_2 \\to v_3$ 的权重为 $w(v_1, v_2) + w(v_2, v_3) = 1 + (-2) = -1$。最短路径的权重为 $-1$。所以，$\\delta(v_1, v_3) = -1$。\n-   从 $v_2$ 出发的路径：\n    -   到 $v_2$：最短路径长度为 $0$。$\\delta(v_2, v_2) = 0$。\n    -   到 $v_3$：唯一的路径是 $v_2 \\to v_3$。$\\delta(v_2, v_3) = w(v_2, v_3) = -2$。\n    -   到 $v_1$：没有路径。$\\delta(v_2, v_1) = \\infty$。\n-   从 $v_3$ 出发的路径：\n    -   到 $v_3$：最短路径长度为 $0$。$\\delta(v_3, v_3) = 0$。\n    -   到 $v_1$ 和 $v_2$：没有路径。$\\delta(v_3, v_1) = \\infty$ 和 $\\delta(v_3, v_2) = \\infty$。\n\n真实最短路径距离矩阵为：\n$$ \\delta = \\begin{pmatrix} \\delta(v_1, v_1) & \\delta(v_1, v_2) & \\delta(v_1, v_3) \\\\ \\delta(v_2, v_1) & \\delta(v_2, v_2) & \\delta(v_2, v_3) \\\\ \\delta(v_3, v_1) & \\delta(v_3, v_2) & \\delta(v_3, v_3) \\end{pmatrix} = \\begin{pmatrix} 0 & 1 & -1 \\\\ \\infty & 0 & -2 \\\\ \\infty & \\infty & 0 \\end{pmatrix} $$\n\n**第 2 部分：修改后的 Johnson 算法模拟**\n\n我们遵循问题中描述的步骤。\n\n**步骤 A：增强图并运行部分 Bellman-Ford 算法**\n图 $G$ 增加了一个新的源顶点 $s^*$，并为每个 $v_i \\in V$ 添加了权重为零的边 $(s^*, v_i)$。从 $s^*$ 运行 Bellman-Ford 算法，且仅进行一次松弛迭代。\n\n顶点 $v$ 的势函数 $\\tilde{h}(v)$ 是从 $s^*$ 到 $v$ 使用至多一条边的最短路径距离。从 $s^*$ 出发的初始距离为 $\\tilde{h}(s^*) = 0$ 和 $\\tilde{h}(v_i) = \\infty$（对于 $i \\in \\{1, 2, 3\\}$）。\n经过一次对从 $s^*$ 出发的边的松弛后：\n-   $\\tilde{h}(v_1) = \\min(\\infty, \\tilde{h}(s^*) + w(s^*, v_1)) = \\min(\\infty, 0 + 0) = 0$。\n-   $\\tilde{h}(v_2) = \\min(\\infty, \\tilde{h}(s^*) + w(s^*, v_2)) = \\min(\\infty, 0 + 0) = 0$。\n-   $\\tilde{h}(v_3) = \\min(\\infty, \\tilde{h}(s^*) + w(s^*, v_3)) = \\min(\\infty, 0 + 0) = 0$。\n\n得到的近似势函数为 $\\tilde{h}(v_1) = 0$, $\\tilde{h}(v_2) = 0$, 和 $\\tilde{h}(v_3) = 0$。\n\n**步骤 B：为边重新赋权**\n新的边权重 $\\tilde{w}(u,v)$ 使用公式 $\\tilde{w}(u,v) = w(u,v) + \\tilde{h}(u) - \\tilde{h}(v)$ 计算。\n由于对所有 $u,v \\in V$ 都有 $\\tilde{h}(u) = \\tilde{h}(v) = 0$，重新赋权的边与原始权重相同：$\\tilde{w}(u,v) = w(u,v)$。\n重新赋权的图有边 $(\\tilde{w}(v_1, v_2) = 1)$，$(\\tilde{w}(v_1, v_3) = 0)$ 和 $(\\tilde{w}(v_2, v_3) = -2)$。\n\n**步骤 C：运行 Dijkstra 算法**\n在重新赋权的图上，从每个顶点 $u \\in V$ 运行 Dijkstra 算法。关键是，重新赋权的图包含一条负权边 $\\tilde{w}(v_2, v_3) = -2$。在存在负权重边的情况下，Dijkstra 算法不保证能产生正确的最短路径距离。我们模拟其标准行为。令 $\\tilde{\\delta}_{\\tilde{w}}(u,v)$ 为 Dijkstra 算法在该图上报告的从 $u$ 到 $v$ 的距离。\n\n-   **从 $v_1$ 出发**：\n    1.  初始化距离：$d(v_1)=0, d(v_2)=\\infty, d(v_3)=\\infty$。优先队列 (PQ)：$\\{(v_1, 0)\\}$。\n    2.  提取 $v_1$ (成本为 $0$)。松弛其边：\n        -   $(v_1, v_2)$：更新 $d(v_2)=1$。将 $(v_2, 1)$ 加入优先队列。\n        -   $(v_1, v_3)$：更新 $d(v_3)=0$。将 $(v_3, 0)$ 加入优先队列。\n    3.  优先队列现在是 $\\{(v_3, 0), (v_2, 1)\\}$。提取 $v_3$ (成本为 $0$)。将 $v_3$ 标记为已访问。没有出边。\n    4.  优先队列现在是 $\\{(v_2, 1)\\}$。提取 $v_2$ (成本为 $1$)。将 $v_2$ 标记为已访问。松弛其边 $(v_2, v_3)$，权重为 $-2$。通过 $v_2$ 到 $v_3$ 的路径成本为 $d(v_2) + \\tilde{w}(v_2, v_3) = 1 + (-2) = -1$。然而，由于 $v_3$ 已被标记为已访问，标准的 Dijkstra 算法实现不会更新其距离。\n    5.  算法终止。从 $v_1$ 出发的报告距离为 $\\tilde{\\delta}_{\\tilde{w}}(v_1, v_1) = 0$，$\\tilde{\\delta}_{\\tilde{w}}(v_1, v_2) = 1$ 和 $\\tilde{\\delta}_{\\tilde{w}}(v_1, v_3) = 0$。这是不正确的；在此图中从 $v_1$ 到 $v_3$ 的真实最短路径权重为 $-1$。\n\n-   **从 $v_2$ 出发**：\n    1.  初始化 $d(v_2)=0$。优先队列：$\\{(v_2, 0)\\}$。\n    2.  提取 $v_2$。松弛 $(v_2, v_3)$：更新 $d(v_3)=-2$。将 $(v_3, -2)$ 加入优先队列。\n    3.  提取 $v_3$。没有出边。\n    4.  算法终止。报告的距离为：$\\tilde{\\delta}_{\\tilde{w}}(v_2, v_2)=0, \\tilde{\\delta}_{\\tilde{w}}(v_2, v_3)=-2$。对于这个子图，这些是正确的。\n\n-   **从 $v_3$ 出发**：没有出边。报告的距离为：$\\tilde{\\delta}_{\\tilde{w}}(v_3, v_3)=0$。\n\nDijkstra 算法找到的距离矩阵是：\n$$ \\tilde{\\delta}_{\\tilde{w}} = \\begin{pmatrix} 0 & 1 & 0 \\\\ \\infty & 0 & -2 \\\\ \\infty & \\infty & 0 \\end{pmatrix} $$\n\n**步骤 D：转换回距离**\n最终报告的距离 $\\tilde{\\delta}(u,v)$ 计算为 $\\tilde{\\delta}(u,v) = \\tilde{\\delta}_{\\tilde{w}}(u,v) - \\tilde{h}(u) + \\tilde{h}(v)$。\n因为所有 $\\tilde{h}(v_i) = 0$，我们有 $\\tilde{\\delta}(u,v) = \\tilde{\\delta}_{\\tilde{w}}(u,v)$。\n所以，最终报告的距离矩阵是：\n$$ \\tilde{\\delta} = \\begin{pmatrix} 0 & 1 & 0 \\\\ \\infty & 0 & -2 \\\\ \\infty & \\infty & 0 \\end{pmatrix} $$\n\n**第 3 部分：最大绝对误差**\n\n我们计算报告距离 $\\tilde{\\delta}$ 和真实距离 $\\delta$ 之间的逐元素绝对差。\n$$ |\\tilde{\\delta} - \\delta| = \\left| \\begin{pmatrix} 0 & 1 & 0 \\\\ \\infty & 0 & -2 \\\\ \\infty & \\infty & 0 \\end{pmatrix} - \\begin{pmatrix} 0 & 1 & -1 \\\\ \\infty & 0 & -2 \\\\ \\infty & \\infty & 0 \\end{pmatrix} \\right| $$\n有限距离不同的唯一条目是点对 $(v_1, v_3)$。\n-   $(v_1, v_3)$ 的误差：$|\\tilde{\\delta}(v_1, v_3) - \\delta(v_1, v_3)| = |0 - (-1)| = 1$。\n-   对于所有其他具有有限距离的点对 $(u,v)$，误差为 $0$。\n-   对于距离为无穷大的点对，误差被认为是 $0$。\n\n绝对误差矩阵是：\n$$ |\\tilde{\\delta} - \\delta| = \\begin{pmatrix} 0 & 0 & 1 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix} $$\n此矩阵中的最大值为 $1$。\n因此，在所有有序点对 $(u,v) \\in V \\times V$ 上的最大绝对误差为 $1$。", "answer": "$$ \\boxed{1} $$", "id": "3242397"}, {"introduction": "在深入探讨了算法的理论基础和潜在的失效模式之后，现在是时候将所有知识整合起来了。这项实践 [@problem_id:3242404] 要求你完整地实现 Johnson 算法。你的目标不仅是计算所有顶点对之间的最短路径距离，还要构建一个前驱矩阵（predecessor matrix）来重构这些最短路径，这是将最短路径算法应用于实际问题的关键一步。", "problem": "给定一个有向加权图 $G = (V,E)$，其顶点索引为 $V = \\{0,1,\\dots,n-1\\}$，边权重为实数。一条路径 $P = (v_0,v_1,\\dots,v_k)$ 的权重定义为其边权重之和，即 $$W(P) = \\sum_{i=0}^{k-1} w(v_i,v_{i+1}).$$ 从源点 $s$ 到顶点 $t$ 的最短路径距离定义为 $$d(s,t) = \\min_{P \\in \\mathcal{P}(s,t)} W(P),$$ 其中 $\\mathcal{P}(s,t)$ 是从 $s$ 到 $t$ 的所有有向路径的集合。如果路径不存在，$d(s,t)$ 定义为 $+\\infty$。\n\n目标是为稀疏图实现 Johnson 算法的一个版本，该版本能产生两个产物：\n- 一个所有顶点对之间的距离矩阵 $D$，使得对于所有 $s,t \\in V$ 都有 $D[s][t] = d(s,t)$。\n- 一个通过前驱矩阵 $P$ 表示的紧凑的所有顶点对之间的最短路径表示，其中 $P[s][t]$ 是原始图 $G$ 中从 $s$ 到 $t$ 的某条最短路径上顶点 $t$ 的前驱顶点的索引。如果 $t=s$ 或者 $t$ 从 $s$ 不可达，则 $P[s][t] = -1$。\n\n您必须将您的方法建立在最短路径的基本定义、势函数下重加权的正确性以及诸如 Bellman-Ford 算法和 Dijkstra 算法等成熟的单源最短路径 (SSSP) 算法之上。您必须检测图中是否存在任何负权重环。如果检测到负权重环，Johnson 算法对于该图无效；在这种情况下，将该图的输出定义如下：布尔标志为 $false$，并且扁平化的距离矩阵和扁平化的前驱矩阵均为空列表。\n\n您的程序必须是一个完整的、可运行的实现，对于每个提供的测试用例，返回三个项目：\n- 一个布尔值 $b$，如果没有检测到负权重环，则为 $true$，否则为 $false$。\n- 一个扁平化的所有顶点对之间的距离列表，首先按源点排序，然后按目标点排序，即 $(D[0][0],D[0][1],\\dots,D[0][n-1],D[1][0],\\dots,D[n-1][n-1])$。\n- 一个扁平化的所有顶点对之间的前驱列表，按同样的方式排序，即 $(P[0][0],P[0][1],\\dots,P[0][n-1],P[1][0],\\dots,P[n-1][n-1])$。\n\n如果顶点 $t$ 从源点 $s$ 不可达，则 $D[s][t]$ 必须为 $+\\infty$；在您的输出中，请使用编程语言中正无穷大的浮点表示来表达。对于任何满足 $t=s$ 或 $t$ 从 $s$ 不可达的 $t$，设置 $P[s][t] = -1$。\n\n测试套件：\n使用以下图作为测试用例。每个测试用例由顶点数 $n$ 和一个有向边列表 $(u,v,w)$ 描述，其中 $u,v \\in \\{0,1,\\dots,n-1\\}$，权重为 $w$。\n\n- 测试用例 $1$ (正常路径，稀疏图，存在负权重边但无负权重环): $n = 5$，边为\n  $(0,1,-2)$, $(1,2,3)$, $(0,3,4)$, $(3,4,1)$, $(4,2,-1)$, $(1,4,2)$。\n- 测试用例 $2$ (边界情况：无边): $n = 4$，边为\n  (无)。\n- 测试用例 $3$ (边缘情况：单顶点图): $n = 1$，边为\n  (无)。\n- 测试用例 $4$ (存在负权重环): $n = 3$，边为\n  $(0,1,1)$, $(1,2,-2)$, $(2,0,0)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。此列表中的每个元素对应一个测试用例，并且本身必须是一个三元列表 $[b,\\text{distances\\_flat},\\text{predecessors\\_flat}]$，其中 $b$ 是一个布尔值，$\\text{distances\\_flat}$ 是扁平化的距离列表，而 $\\text{predecessors\\_flat}$ 是扁平化的前驱列表。例如，打印的输出应如下所示：\n$[[b_1,[d_{1,0},d_{1,1},\\dots],[p_{1,0},p_{1,1},\\dots]],[b_2,[\\dots],[\\dots]],\\dots]$。\n\n您的实现不得读取任何输入，并且必须按原样运行，以便为提供的测试套件生成指定的输出。", "solution": "该问题要求计算有向加权图 $G=(V, E)$ 中所有顶点对之间的最短路径。由于存在实数值的边权重，其中可能包括负值，因此需要谨慎选择算法。从每个顶点运行 Dijkstra 算法是无效的，因为其正确性依赖于非负的边权重。从每个顶点执行 Bellman-Ford 算法是一种有效但效率低下的方法，其时间复杂度为 $O(|V|^2|E|)$，对于大型图来说是不可行的。Johnson 算法提供了一种优雅且更高效的方法，尤其适用于稀疏图。它通过对边进行重加权来消除负权重，从而允许使用更快的 Dijkstra 算法。\n\nJohnson 算法的核心原理基于一个势函数 $h: V \\to \\mathbb{R}$。对于每个权重为 $w(u, v)$ 的边 $(u, v) \\in E$，我们定义一个新的重加权边权重 $w_h(u, v)$ 如下：\n$$w_h(u, v) = w(u, v) + h(u) - h(v)$$\n\n这种重加权方案有一个显著的特性：它能保持最短路径不变。考虑从源点 $s=v_0$ 到目标点 $t=v_k$ 的任意路径 $P = (v_0, v_1, \\dots, v_k)$。该路径在重加权图中的权重 $W_h(P)$ 为：\n$$W_h(P) = \\sum_{i=0}^{k-1} w_h(v_i, v_{i+1}) = \\sum_{i=0}^{k-1} (w(v_i, v_{i+1}) + h(v_i) - h(v_{i+1}))$$\n这个和是伸缩求和，得出：\n$$W_h(P) = \\left(\\sum_{i=0}^{k-1} w(v_i, v_{i+1})\\right) + h(v_0) - h(v_k) = W(P) + h(s) - h(t)$$\n由于对于任何从 $s$ 到 $t$ 的路径，$h(s)$ 和 $h(t)$ 都是常数，因此当且仅当一条路径的重加权权重 $W_h(P)$ 最小时，其原始权重 $W(P)$ 也最小。因此，最短路径在这种变换下是不变的。\n\n挑战在于找到一个势函数 $h$，使得所有重加权后的边都是非负的，即对于所有 $(u, v) \\in E$，$w_h(u, v) \\ge 0$。这个条件等价于：\n$$w(u, v) + h(u) - h(v) \\ge 0 \\implies h(v) \\le h(u) + w(u, v)$$\n这个不等式就是三角不等式，它是最短路径算法的基础。这表明势函数 $h(v)$可以定义为从某个源顶点出发的最短路径距离。\n\n为了构造这样一个势函数，我们扩展原始图 $G$ 来创建一个新图 $G' = (V', E')$。我们添加一个不在 $V$ 中的新源顶点 $s'$，形成 $V' = V \\cup \\{s'\\}$。然后，我们从 $s'$向 $V$ 中的每个顶点 $v$ 添加权重为零的有向边，创建 $E' = E \\cup \\{(s', v) \\mid v \\in V, w(s', v) = 0\\}$。\n\n接着，我们使用 Bellman-Ford 算法计算在 $G'$ 中从 $s'$ 到所有其他顶点的最短路径距离。我们将势函数 $h(v)$ 定义为 $G'$ 中从 $s'$到 $v$ 的最短路径距离，即 $h(v) = d_{G'}(s', v)$。根据最短路径的三角不等式性质，对于任何边 $(u,v) \\in E \\subset E'$，我们必须有 $d_{G'}(s', v) \\le d_{G'}(s', u) + w(u, v)$，这正是 $h(v) \\le h(u) + w(u, v)$。这保证了我们选择的势函数将导致非负的重加权边 $w_h(u,v) \\ge 0$。\n\nBellman-Ford 算法还有一个关键的次要目的：检测负权重环。如果图 $G$ 包含一个负权重环，那么 $G'$ 也将包含一个。Bellman-Ford 可以检测到这样的环；如果在 $|V'|-1$ 次松弛操作后，某个距离仍然可以被缩短，则存在一个从源点可达的负权重环。由于 $s'$ 连接到所有原始顶点，因此 $G$ 中的任何负权重环都是可达的。如果检测到这样的环，Johnson 算法无法继续进行，我们必须报告此失败。\n\n如果没有发现负权重环，算法按以下步骤进行：\n1.  **增广：** 通过添加一个新的源顶点 $s'$ 以及对所有 $v \\in V$ 添加权重为零的边 $(s', v)$ 来构建图 $G'$。\n2.  **重加权势函数计算：** 在 $G'$ 上以 $s'$ 为源点运行 Bellman-Ford 算法。如果检测到负权重环，则终止并报告该图无效。否则，将每个顶点 $v \\in V$ 的势函数设置为 $h(v) = d_{G'}(s', v)$。\n3.  **图重加权：** 为原始图 $G$ 中的所有边计算非负权重 $w_h(u, v) = w(u, v) + h(u) - h(v)$。\n4.  **通过 Dijkstra 算法计算所有顶点对之间的最短路径：** 对每个顶点 $u \\in V$，在重加权图上以 $u$ 为源点运行 Dijkstra 算法，以找到所有 $v \\in V$ 的最短路径距离 $d_h(u, v)$ 和前驱。\n5.  **距离转换：** 使用逆变换恢复原始图中的最终最短路径距离：$d(u, v) = d_h(u, v) - h(u) + h(v)$。如果 $d_h(u,v)$ 是无穷大，$d(u,v)$ 也是无穷大。前驱矩阵不需要转换，因为最短路径的结构被保留了下来。\n\n总时间复杂度主要由 Bellman-Ford 步骤决定，为 $O(|V||E'|) = O(|V|(|V|+|E|)) = O(|V||E|)$ (因为在连通图中 $|E| \\ge |V|-1$)，以及 $|V|$ 次 Dijkstra 算法的运行。使用二叉堆实现的 Dijkstra 算法，这一步需要 $O(|V|(|E|+|V|\\log|V|))$ 的时间。对于稀疏图，其中 $|E|$接近 $|V|$，复杂度约为 $O(|V|^2 \\log|V|)$，这比运行 $|V|$ 次 Bellman-Ford 算法有了显著的改进。\n\n该实现将构建距离矩阵 $D$（其中 $D[s][t] = d(s, t)$）和前驱矩阵 $P$（其中 $P[s][t]$ 是从 $s$ 到 $t$ 的一条最短路径上 $t$ 的前驱）。根据问题要求，如果 $t$ 从 $s$ 不可达，则 $D[s][t] = \\infty$；如果 $t=s$ 或 $t$ 从 $s$ 不可达，则 $P[s][t] = -1$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run Johnson's algorithm on them.\n    Produces the final formatted output.\n    \"\"\"\n    \n    # Test Suite\n    test_cases = [\n        # Test case 1 (happy path, sparse, negative edges but no negative cycle)\n        {\n            \"n\": 5,\n            \"edges\": [(0, 1, -2), (1, 2, 3), (0, 3, 4), (3, 4, 1), (4, 2, -1), (1, 4, 2)]\n        },\n        # Test case 2 (boundary: no edges)\n        {\n            \"n\": 4,\n            \"edges\": []\n        },\n        # Test case 3 (edge case: single-vertex graph)\n        {\n            \"n\": 1,\n            \"edges\": []\n        },\n        # Test case 4 (negative cycle present)\n        {\n            \"n\": 3,\n            \"edges\": [(0, 1, 1), (1, 2, -2), (2, 0, 0)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        edges = case[\"edges\"]\n        has_neg_cycle, dist_matrix, pred_matrix = johnson_algorithm(n, edges)\n        \n        if has_neg_cycle:\n            results.append([False, [], []])\n        else:\n            dist_flat = dist_matrix.flatten().tolist()\n            pred_flat = pred_matrix.flatten().tolist()\n            results.append([True, dist_flat, pred_flat])\n\n    # Final print statement in the exact required format.\n    # Convert Python boolean `True`/`False` to string 'True'/'False'\n    # and `inf` to 'inf'.\n    # `str()` on a list will handle this correctly.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef johnson_algorithm(n, edges):\n    \"\"\"\n    Implements Johnson's algorithm for all-pairs shortest paths.\n    \n    Args:\n        n (int): The number of vertices.\n        edges (list): A list of tuples (u, v, w) representing directed edges.\n        \n    Returns:\n        A tuple (has_neg_cycle, dist_matrix, pred_matrix).\n        - has_neg_cycle (bool): True if a negative-weight cycle is detected.\n        - dist_matrix (np.array): The n x n all-pairs shortest path distance matrix.\n        - pred_matrix (np.array): The n x n predecessor matrix.\n    \"\"\"\n    if n == 0:\n        return False, np.array([]), np.array([])\n\n    # Step 1: Form the augmented graph G'\n    augmented_edges = list(edges)\n    num_vertices_augmented = n + 1\n    new_source = n\n    for i in range(n):\n        augmented_edges.append((new_source, i, 0))\n\n    # Step 2: Run Bellman-Ford from the new source\n    dist_h = np.full(num_vertices_augmented, float('inf'))\n    dist_h[new_source] = 0\n\n    for _ in range(num_vertices_augmented - 1):\n        for u, v, w in augmented_edges:\n            if dist_h[u] != float('inf') and dist_h[u] + w < dist_h[v]:\n                dist_h[v] = dist_h[u] + w\n\n    # Check for negative-weight cycles\n    for u, v, w in augmented_edges:\n        if dist_h[u] != float('inf') and dist_h[u] + w < dist_h[v]:\n            return True, None, None\n            \n    h = dist_h[:n]\n\n    # Step 3: Reweight the original graph\n    adj_list_reweighted = [[] for _ in range(n)]\n    for u, v, w in edges:\n        w_h = w + h[u] - h[v]\n        adj_list_reweighted[u].append((v, w_h))\n\n    # Step 4 & 5: Run Dijkstra from each vertex and compute final results\n    all_pairs_dist = np.full((n, n), float('inf'))\n    all_pairs_pred = np.full((n, n), -1, dtype=int)\n\n    for s in range(n):\n        # Run Dijkstra on the reweighted graph\n        dist_reweighted, pred_reweighted = dijkstra(n, adj_list_reweighted, s)\n        \n        # Convert distances back to original weights and store results\n        for t in range(n):\n            if dist_reweighted[t] != float('inf'):\n                all_pairs_dist[s, t] = dist_reweighted[t] - h[s] + h[t]\n            all_pairs_pred[s, t] = pred_reweighted[t]\n\n    return False, all_pairs_dist, all_pairs_pred\n\n\ndef dijkstra(n, adj, start_node):\n    \"\"\"\n    Dijkstra's algorithm for SSSP on a weighted graph with non-negative weights.\n    \n    Args:\n        n (int): Number of vertices.\n        adj (list): Adjacency list representation of the graph.\n        start_node (int): The source vertex.\n        \n    Returns:\n        A tuple (dist, pred):\n        - dist (np.array): Shortest path distances from the start node.\n        - pred (np.array): Predecessor array for reconstructing paths.\n    \"\"\"\n    dist = np.full(n, float('inf'))\n    pred = np.full(n, -1, dtype=int)\n    dist[start_node] = 0\n    pq = [(0, start_node)]  # (distance, vertex)\n\n    while pq:\n        d, u = heapq.heappop(pq)\n        \n        if d > dist[u]:\n            continue\n\n        for v, weight in adj[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                pred[v] = u\n                heapq.heappush(pq, (dist[v], v))\n    \n    return dist, pred\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3242404"}]}