{"hands_on_practices": [{"introduction": "稳定婚姻问题的核心是“阻塞对”这一概念。在寻找稳定匹配之前，我们必须首先能够精确地识别和计算这些不稳定性的来源。这项练习将引导你实践这一基本定义，通过实现一个高效的算法来计算阻塞对，你不仅能巩固对稳定性的理解，还能学习到使用排名矩阵来提升计算性能的关键优化技巧。[@problem_id:3274083]", "problem": "给定经典的稳定婚姻问题 (Stable Marriage Problem, SMP)，它包含两个大小相等的不相交集合，一个男性集合和一个女性集合。设男性人数为 $n$，女性人数为 $n$，男性的索引为 $\\{0,1,\\dots,n-1\\}$，女性的索引为 $\\{0,1,\\dots,n-1\\}$。每个男性提供一个关于所有女性的严格全序（无并列），每个女性也提供一个关于所有男性的严格全序（无并列）。一个完美匹配是一个双射 $\\mu$，它将每个男性 $m$ 与唯一一位女性 $\\mu(m)$ 配对，并将每个女性 $w$ 与唯一一位男性 $\\mu^{-1}(w)$ 配对。\n\n如果男性 $m$ 和女性 $w$ 在匹配 $\\mu$ 中没有配对，并且 $m$ 和 $w$ 都严格偏好对方胜过自己在 $\\mu$ 下的伴侣，则称对 $(m,w)$ 为匹配 $\\mu$ 的一个阻塞对 (blocking pair)。当且仅当不存在阻塞对时，一个匹配是稳定的。\n\n从上述基本定义出发，设计一个算法，在给定以下输入的情况下：\n- 所有男性和女性的完整严格偏好配置，以及\n- 一个完美匹配 $\\mu$，\n\n利用排名矩阵计算阻塞对的确切数量。在提供了偏好和匹配之后，您的算法必须在 $O(n^2)$ 时间内运行。男性的排名矩阵，记为 $R^{M}$，定义为：如果女性 $w$ 在男性 $m$ 的偏好列表中的排名为 $r$，则 $R^{M}[m][w] = r$（值越小表示偏好越强）。同样，女性的排名矩阵，记为 $R^{W}$，定义为：如果男性 $m$ 在女性 $w$ 的偏好列表中的排名为 $r$，则 $R^{W}[w][m] = r$（值越小表示偏好越强）。\n\n您的任务是实现这个算法，然后用它来通过以下归一化不稳定性指数来衡量一个匹配与稳定性的接近程度：\n$$\nI(\\mu) = \n\\begin{cases}\n\\frac{B(\\mu)}{n^2 - n},  \\text{if } n^2 - n \\neq 0 \\\\\n0,  \\text{if } n^2 - n = 0\n\\end{cases}\n$$\n其中 $B(\\mu)$ 是 $\\mu$ 的阻塞对数量。分母 $n^2 - n$ 是在一个完美匹配中所有未配对的交叉对 $(m,w)$ 的总数。归一化不稳定性指数 $I(\\mu)$ 的取值范围在 $[0,1]$ 内。\n\n实现一个程序，针对下面的每个测试用例，返回一个双元素列表 $[B(\\mu), I(\\mu)]$，其中 $B(\\mu)$ 是一个整数，$I(\\mu)$ 是一个四舍五入到三位小数的实数。\n\n涵盖一系列情况的测试套件：\n- 情况 A（边界大小）：$n=1$。\n  - 男性偏好：$[[0]]$。\n  - 女性偏好：$[[0]]$。\n  - 匹配：$[0]$。\n- 情况 B（稳定匹配，无阻塞对）：$n=3$。\n  - 男性偏好：$[[0,1,2],[1,2,0],[2,0,1]]$。\n  - 女性偏好：$[[0,1,2],[1,2,0],[2,0,1]]$。\n  - 匹配：$[0,1,2]$。\n- 情况 C（存在一些阻塞对）：$n=3$。\n  - 男性偏好：$[[1,0,2],[0,1,2],[0,1,2]]$。\n  - 女性偏好：$[[1,0,2],[0,1,2],[0,1,2]]$。\n  - 匹配：$[0,1,2]$。\n- 情况 D（相对于大小，存在许多阻塞对）：$n=4$。\n  - 男性偏好：$[[0,1,2,3],[0,1,2,3],[0,1,2,3],[0,1,2,3]]$。\n  - 女性偏好：$[[0,1,2,3],[0,1,2,3],[0,1,2,3],[0,1,2,3]]$。\n  - 匹配：$[3,2,1,0]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素是对应测试用例的双元素列表，顺序与上面列出的一致。例如，输出必须是\n\"[[B_A,I_A],[B_B,I_B],[B_C,I_C],[B_D,I_D]]\"\n的形式，其中 $I_A,I_B,I_C,I_D$ 均四舍五入到三位小数。", "solution": "该问题是有效的。这是一个来自离散数学和计算机科学领域的明确定义的算法任务，具体涉及稳定婚姻问题背景下的匹配分析。所有输入、定义和约束都清晰、一致且科学上合理。\n\n该问题要求我们设计一个算法，对于一个大小为 $n$ 的稳定婚姻实例中给定的完美匹配 $\\mu$，计算其阻塞对的数量。该算法必须在 $O(n^2)$ 的时间复杂度内运行。随后，这个计数将用于计算归一化不稳定性指数 $I(\\mu)$。\n\n对于一个完美匹配 $\\mu$，阻塞对是一个由男性 $m$ 和女性 $w$ 组成的对 $(m, w)$，他们彼此没有配对，但都严格偏好对方胜过自己在 $\\mu$ 下的伴侣。形式上，当且仅当满足三个条件时，$(m, w)$ 是一个阻塞对：\n1.  男性 $m$ 和女性 $w$ 没有配对：$\\mu(m) \\neq w$。\n2.  男性 $m$ 偏好女性 $w$ 胜过其指定伴侣 $\\mu(m)$。\n3.  女性 $w$ 偏好男性 $m$ 胜过其指定伴侣 $\\mu^{-1}(w)$。\n\n一个朴素的方法是遍历所有不在匹配 $\\mu$ 中的 $n^2 - n$ 个对 $(m, w)$，并对每一对检查两个偏好条件。通过搜索长度为 $n$ 的个人偏好列表来验证一个偏好需要 $O(n)$ 的时间。这导致总体时间复杂度为 $O(n^3)$，效率低下且不满足指定的 $O(n^2)$ 约束。\n\n为了达到所要求的 $O(n^2)$ 复杂度，我们必须在常数时间 $O(1)$ 内执行偏好检查。如题目所建议，这可以通过将偏好列表预处理成排名矩阵来实现。我们定义两个排名矩阵，一个用于男性 ($R^M$)，一个用于女性 ($R^W$)。\n\n男性的排名矩阵 $R^M$ 是一个 $n \\times n$ 的矩阵，其中条目 $R^M[m][w]$ 存储女性 $w$ 在男性 $m$ 偏好列表中的排名。较低的排名值表示较高的偏好。例如，如果男性 $m$ 最偏好的女性是 $w_i$，则 $R^M[m][w_i] = 0$。该矩阵可以通过遍历每个男性的偏好列表在 $O(n^2)$ 时间内构建。对于从 $0$ 到 $n-1$ 的每个男性 $m$，我们遍历他的偏好列表：如果女性 $w$ 在列表中的位置（排名）为 $r$，我们设置 $R^M[m][w] = r$。\n\n同样，女性的排名矩阵 $R^W$ 是一个 $n \\times n$ 的矩阵，其中 $R^W[w][m]$ 存储男性 $m$ 在女性 $w$ 偏好列表中的排名。该矩阵也可以在 $O(n^2)$ 时间内构建。\n\n有了这些排名矩阵，检查阻塞对 $(m, w)$ 的偏好条件可以在 $O(1)$ 时间内完成：\n- 男性 $m$ 偏好 $w$ 胜过 $\\mu(m)$ 当且仅当 $R^M[m][w]  R^M[m][\\mu(m)]$。\n- 女性 $w$ 偏好 $m$ 胜过 $\\mu^{-1}(w)$ 当且仅当 $R^W[w][m]  R^W[w][\\mu^{-1}(w)]$。\n\n完整的 $O(n^2)$ 算法如下：\n\n1.  **预处理（时间：$O(n^2)$）：**\n    a. 给定男性的偏好列表，构建男性的排名矩阵 $R^M$。这需要 $O(n^2)$ 的时间。\n    b. 给定女性的偏好列表，构建女性的排名矩阵 $R^W$。这也需要 $O(n^2)$ 的时间。\n    c. 给定匹配 $\\mu$（一个数组，其中 `matching[m]` $= \\mu(m)$），构建逆匹配 $\\mu^{-1}$（一个数组，其中 `inverse_matching[w]` $= \\mu^{-1}(w)$）。这需要 $O(n)$ 的时间。\n\n2.  **阻塞对计数（时间：$O(n^2)$）：**\n    a. 初始化阻塞对数量的计数器 $B(\\mu)$ 为 $0$。\n    b. 遍历所有可能的男性 $m$（从 $0$ 到 $n-1$）和女性 $w$（从 $0$ 到 $n-1$）的配对。\n    c. 对于每一对 $(m, w)$，首先检查他们是否已经配对，即 $w = \\mu(m)$。如果是，则该对不可能是阻塞对，我们继续到下一对。\n    d. 如果他们没有配对，使用排名矩阵检查两个偏好条件：\n        i.  $R^M[m][w]  R^M[m][\\mu(m)]$\n        ii. $R^W[w][m]  R^W[w][\\mu^{-1}(w)]$\n    e. 如果两个条件都为真，则对 $(m, w)$ 是一个阻塞对。将计数器 $B(\\mu)$ 加一。\n\n3.  **不稳定性指数计算（时间：$O(1)$）：**\n    a. 遍历完所有 $n^2$ 个配对后，计数器 $B(\\mu)$ 将保存阻塞对的总数。\n    b. 然后根据以下公式计算归一化不稳定性指数 $I(\\mu)$：\n    $$\n    I(\\mu) = \n    \\begin{cases}\n    \\frac{B(\\mu)}{n^2 - n},  \\text{if } n^2 - n \\neq 0 \\\\\n    0,  \\text{if } n^2 - n = 0\n    \\end{cases}\n    $$\n    $n^2-n=0$ 的情况仅在 $n=0$ 或 $n=1$ 时发生。对于 $n=1$，没有未配对的对，因此 $B(\\mu)$ 必然为 $0$，且 $I(\\mu)$ 被定义为 $0$。对于 $n>1$，分母非零。该指数 $I(\\mu)$ 代表了不稳定的非匹配对所占的比例。\n\n该算法的总时间复杂度是其各步骤复杂度的总和：预处理为 $O(n^2)$，计数为 $O(n^2)$，得出的总体复杂度为 $O(n^2)$，满足问题的约束。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_instability(n, men_prefs, women_prefs, matching):\n    \"\"\"\n    Computes the number of blocking pairs and the instability index for a given matching.\n\n    Args:\n        n (int): The number of men and women.\n        men_prefs (list of list of int): Men's preference lists.\n        women_prefs (list of list of int): Women's preference lists.\n        matching (list of int): The matching to analyze, where matching[m] = w.\n\n    Returns:\n        tuple: A tuple (B, I) where B is the number of blocking pairs and I is the\n               normalized instability index.\n    \"\"\"\n    if n == 1:\n        # For n=1, there are no non-matched pairs, so B=0.\n        # The problem defines I=0 for this case.\n        return 0, 0.0\n\n    # Step 1: Preprocessing\n    # a. Construct men's rank matrix R_M\n    # R_M[m][w] = rank of woman w in man m's preference list\n    R_M = np.zeros((n, n), dtype=int)\n    for m in range(n):\n        for rank, w in enumerate(men_prefs[m]):\n            R_M[m, w] = rank\n\n    # b. Construct women's rank matrix R_W\n    # R_W[w][m] = rank of man m in woman w's preference list\n    R_W = np.zeros((n, n), dtype=int)\n    for w in range(n):\n        for rank, m in enumerate(women_prefs[w]):\n            R_W[w, m] = rank\n\n    # c. Construct the inverse matching\n    inverse_matching = np.zeros(n, dtype=int)\n    for m, w in enumerate(matching):\n        inverse_matching[w] = m\n    \n    # Pre-fetch the ranks of the current partners for faster lookups\n    # Although not strictly necessary for complexity, it can clarify the loop\n    man_partner_ranks = np.zeros(n, dtype=int)\n    for m in range(n):\n        man_partner_ranks[m] = R_M[m, matching[m]]\n        \n    woman_partner_ranks = np.zeros(n, dtype=int)\n    for w in range(n):\n        woman_partner_ranks[w] = R_W[w, inverse_matching[w]]\n\n    # Step 2: Blocking Pair Count\n    blocking_pairs_count = 0\n    for m in range(n):\n        for w in range(n):\n            # A pair cannot block itself\n            if matching[m] == w:\n                continue\n\n            # Check if (m, w) is a blocking pair\n            # Condition 1: m prefers w to his current partner\n            m_prefers_w = R_M[m, w]  man_partner_ranks[m]\n            \n            # Condition 2: w prefers m to her current partner\n            w_prefers_m = R_W[w, m]  woman_partner_ranks[w]\n\n            if m_prefers_w and w_prefers_m:\n                blocking_pairs_count += 1\n    \n    B = blocking_pairs_count\n    \n    # Step 3: Instability Index Calculation\n    # Denominator is the total number of non-matched pairs\n    denominator = n**2 - n\n    I = B / denominator if denominator != 0 else 0.0\n\n    return B, I\n\ndef solve():\n    \"\"\"\n    Defines the test cases and runs the instability calculation for each,\n    then prints the formatted results.\n    \"\"\"\n    test_cases = [\n        # Case A (boundary size): n=1\n        {\n            \"n\": 1,\n            \"men_prefs\": [[0]],\n            \"women_prefs\": [[0]],\n            \"matching\": [0]\n        },\n        # Case B (stable matching, no blocking pairs): n=3\n        {\n            \"n\": 3,\n            \"men_prefs\": [[0, 1, 2], [1, 2, 0], [2, 0, 1]],\n            \"women_prefs\": [[0, 1, 2], [1, 2, 0], [2, 0, 1]],\n            \"matching\": [0, 1, 2]\n        },\n        # Case C (some blocking pairs): n=3\n        {\n            \"n\": 3,\n            \"men_prefs\": [[1, 0, 2], [0, 1, 2], [0, 1, 2]],\n            \"women_prefs\": [[1, 0, 2], [0, 1, 2], [0, 1, 2]],\n            \"matching\": [0, 1, 2]\n        },\n        # Case D (many blocking pairs relative to size): n=4\n        {\n            \"n\": 4,\n            \"men_prefs\": [[0, 1, 2, 3], [0, 1, 2, 3], [0, 1, 2, 3], [0, 1, 2, 3]],\n            \"women_prefs\": [[0, 1, 2, 3], [0, 1, 2, 3], [0, 1, 2, 3], [0, 1, 2, 3]],\n            \"matching\": [3, 2, 1, 0]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        B, I = calculate_instability(case[\"n\"], case[\"men_prefs\"], case[\"women_prefs\"], case[\"matching\"])\n        # Round the instability index to three decimal places\n        I_rounded = round(I, 3)\n        results.append([B, I_rounded])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3274083"}, {"introduction": "经典的Gale-Shapley算法假设偏好列表是完整的，即任何男性都可以与任何女性匹配。然而，现实世界的情景常常包含各种约束，例如因外部原因而永远不能匹配的“禁止配对”。这项实践挑战你调整标准算法以处理这类现实世界的复杂性，你将学习如何修改求婚过程以遵循这些约束，并分析在何种条件下仍然可以找到一个稳定（尽管可能不完美）的匹配。[@problem_id:3274062]", "problem": "考虑一个带有不完整列表和禁止配对的稳定婚姻问题 (SMP)。设有两组不相交的代理人集合，提议方 $U$ 和接收方 $V$，其中对于某个整数 $n \\geq 1$，有 $|U| = |V| = n$。每个 $U$ 中的代理人 $u$ 对 $V$ 中代理人的一个子集有一个严格的偏好序，同样，每个 $V$ 中的代理人 $v$ 对 $U$ 中代理人的一个子集有一个严格的偏好序。一对 $(u,v)$ 是可接受的，当且仅当 $u$ 的列表中包含 $v$ 且 $v$ 的列表中包含 $u$。此外，一个配对子集 $F \\subseteq U \\times V$ 被声明为禁止配对，意味着任何属于 $F$ 的配对 $(u,v)$ 永远不能被匹配，即使根据代理人的列表，该配对是可接受的。\n\n一个匹配 $M \\subseteq U \\times V$ 是一组不相交的配对（没有代理人出现在超过一个配对中）。允许存在未匹配的代理人。对于可接受性，一对 $(u,v)$ 属于 $M$ 仅当 $(u,v)$ 是可接受的且 $(u,v) \\notin F$。一个不在 $M$ 中的配对 $(u,v)$ 是一个阻塞对，如果 $(u,v)$ 是可接受的，$(u,v) \\notin F$，代理人 $u$ 严格偏好 $v$ 胜过其在 $M$ 中的当前伴侣（或未匹配状态），并且代理人 $v$ 严格偏好 $u$ 胜过其在 $M$ 中的当前伴侣（或未匹配状态）。如果一个匹配没有阻塞对，则称其为稳定的。\n\n从稳定性、可接受性和严格偏好的核心定义出发，并以 Gale–Shapley 算法 (GSA) 为基本程序，调整该算法，使其永远不会向禁止的或不可接受的伴侣发出提议。你的算法必须能处理双方可能不完整的偏好列表以及禁止集合 $F$。程序必须：\n- 构建一个 $U$ 方提议的 Gale–Shapley 程序，该程序忽略禁止和不可接受的配对。\n- 生成一个稳定的匹配 $M$（可能是不完整的）。\n- 通过使用上述正式定义计算阻塞对的数量来验证稳定性。\n- 分析是否存在稳定的完美匹配（即匹配双方所有代理人的匹配）：返回一个布尔值，指示调整后的 Gale-Shapley 程序是否产生了一个完美匹配。在带有不完整列表且无平局的 SMP 中，这个条件是稳定完美匹配存在的充要条件。\n\n对于每个测试用例，你的程序必须返回一个列表 $[s, p, b, u, M]$，其中：\n- $s$ 是一个布尔值，指示算法是否产生了一个稳定的匹配（当且仅当 $b = 0$ 时，该值应为 true），\n- $p$ 是一个布尔值，指示匹配是否是完美的（$U$ 中的所有 $n$ 个代理人都被匹配），\n- $b$ 是阻塞对的整数数量，\n- $u$ 是 $U$ 中未匹配代理人的整数数量，\n- $M$ 是一个已匹配配对的列表，编码为列表的列表形式 $[[u_1, v_1], [u_2, v_2], \\dots]$，其中每个 $u_i$ 和 $v_i$ 都以整数形式表示。\n\n实现你的解决方案，并为以下测试套件计算输出。在每个案例中，都指定了 $n$、偏好列表和禁止配对。列表中的所有整数都表示代理人索引。\n\n- 测试用例 1 (理想情况，存在完美匹配):\n  - $n = 3$\n  - $P_U = \\{0 : [0,1,2],\\ 1 : [1,2,0],\\ 2 : [2,1,0]\\}$\n  - $P_V = \\{0 : [1,0,2],\\ 1 : [0,1,2],\\ 2 : [2,1,0]\\}$\n  - $F = \\{(0,2)\\}$\n\n- 测试用例 2 (无禁止配对，标准 SMP):\n  - $n = 3$\n  - $P_U = \\{0 : [1,0,2],\\ 1 : [1,2,0],\\ 2 : [0,2,1]\\}$\n  - $P_V = \\{0 : [2,0,1],\\ 1 : [0,1,2],\\ 2 : [1,2,0]\\}$\n  - $F = \\{\\}$\n\n- 测试用例 3 (一个代理人因禁止配对导致可接受列表为空，无完美匹配):\n  - $n = 4$\n  - $P_U = \\{0 : [0,1,2,3],\\ 1 : [1,0,2,3],\\ 2 : [2,3,1,0],\\ 3 : [3,2,1,0]\\}$\n  - $P_V = \\{0 : [1,0,2,3],\\ 1 : [0,1,2,3],\\ 2 : [2,3,1,0],\\ 3 : [3,2,1,0]\\}$\n  - $F = \\{(3,0),(3,1),(3,2),(3,3)\\}$\n\n- 测试用例 4 (多个提议者竞争一个备选方案受限的接收者，无完美匹配):\n  - $n = 4$\n  - $P_U = \\{0 : [0],\\ 1 : [0],\\ 2 : [1,2,3],\\ 3 : [3,2,1]\\}$\n  - $P_V = \\{0 : [1,0,2,3],\\ 1 : [2,3,1,0],\\ 2 : [2,3,1,0],\\ 3 : [3,2,1,0]\\}$\n  - $F = \\{(1,1),(1,2),(1,3)\\}$\n\n- 测试用例 5 (边界情况，最小规模，一个提议者没有可接受的伴侣):\n  - $n = 2$\n  - $P_U = \\{0 : [0],\\ 1 : [1,0]\\}$\n  - $P_V = \\{0 : [1,0],\\ 1 : [1,0]\\}$\n  - $F = \\{(0,0)\\}$\n\n你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,\\dots,result_k]$），其中每个 $result_i$ 对应一个测试用例，并严格按照上述 $[s,p,b,u,M]$ 的格式。程序必须是自包含的，不需要任何输入，并使用指定的运行时环境。所有返回的值必须来自基本类型集合：布尔值、整数、浮点数或这些类型的列表。在编码的匹配 $M$ 中不允许使用字符串。", "solution": "该问题要求对 Gale-Shapley 算法 (GSA) 进行调整，以解决带有不完整列表和禁止配对的稳定婚姻问题。解决方案必须处理这些约束，生成一个稳定的匹配，并验证其属性。指导此解决方案的核心原则是可接受性、禁止配对和稳定性的正式定义。\n\n整体方法分为三个主要阶段：\n$1$. **预处理**：我们首先为提议方代理人 ($U$) 构建有效的偏好列表。一对 $(u,v)$ 成为一个有效的匹配候选，仅当它既是*可接受的*（即 $u$ 在 $v$ 的偏好列表上，且 $v$ 在 $u$ 的列表上）又*不是被禁止的*（即 $(u,v) \\notin F$）。通过在开始时筛选每个提议者的偏好列表，只包含此类有效伴侣，我们确保后续算法只考虑有资格成为稳定匹配一部分的配对。这将问题转化为一个等价的带不完整列表的稳定婚姻问题 (SMPI) 实例，对此 GSA 是一种标准的解决方法。\n\n$2$. **执行（调整后的 Gale-Shapley 算法）**：然后使用这些经过预处理的有效偏好列表来执行 $U$ 方提议的 GSA。\n    - 初始化一个来自集合 $U$ 的“自由”代理人队列。\n    - 当队列不为空时，一个自由代理人 $u$ 出队，并向其有效列表上尚未提议过的排名最高的代理人 $v$ 提议。\n    - 接收方代理人 $v$ 评估该提议。如果 $v$ 当前未匹配，他们会暂时接受。如果 $v$ 已与代理人 $u'$ 匹配，他们会根据自己原始的、完整的偏好列表比较 $u$ 和 $u'$。如果 $v$ 偏好 $u$ 胜过 $u'$，他们会解除与 $u'$ 的配对（$u'$ 重新变为自由身）并暂时接受来自 $u$ 的提议。否则，$v$ 拒绝 $u$，而 $u$ 保持自由状态，可以向其列表上的下一个代理人提议。\n    - 一个用尽其有效偏好列表（该列表可能从一开始就是空的）的代理人 $u$ 将永久保持未匹配状态。\n    - 当自由代理人队列为空时，算法终止。此时的临时配对集合构成了最终的稳定匹配。用于 SMPI 的 GSA 保证了此过程会终止，并产生一个 $U$ 方最优的稳定匹配，这意味着 $U$ 中的任何代理人在任何其他稳定匹配中都无法获得更好的结果。\n\n$3$. **验证与分析**：在获得匹配 $M$ 后，将进行严格的验证过程，以确认其符合问题陈述所要求的属性。\n    - **稳定性检查**：计算阻塞对的数量。一对 $(u,v) \\notin M$ 是一个阻塞对，如果：($a$) 它是可接受的，($b$) 它不被禁止，($c$) $u$ 偏好 $v$ 胜过其在 $M$ 中的伴侣（或未匹配状态），以及 ($d$) $v$ 偏好 $u$ 胜过其在 $M$ 中的伴侣（或未匹配状态）。此检查将对 $(U \\times V) \\setminus M$ 中的所有配对进行穷尽式检查。对于一个正确实现的 GSA，此计数必须为 $0$。稳定性布尔值 $s$ 为真当且仅当此计数为 $0$。\n    - **完美性与未匹配代理人**：如果 $U$ 中的每个代理人都被匹配，则该匹配是完美的。布尔值 $p$ 会相应设置，而 $U$ 中未匹配的代理人数量（表示为 $u$）计算为 $n - |M|$。\n    - **最终输出组装**：将结果汇编成指定的列表格式：$[s, p, b, u, M]$。\n\n这种有原则的设计通过首先简化问题约束，然后应用一个经过验证的算法，最后根据初始的复杂规则集对结果进行形式化验证，从而确保了正确性。\n\n为了实现这一点，需要预先计算偏好排名以便进行高效查找。对于一个代理人 $w$ 和一个潜在伴侣 $z$，$rank(w, z)$ 是 $z$ 在 $w$ 偏好列表中的位置。如果 $z$ 不在 $w$ 的列表上，则分配一个无穷大的排名（例如，一个比任何可能排名都大的数字）。这使得代理人在评估新提议与当前伴侣时可以进行简单的数值比较。\n\n对于阻塞对检查，给定一对 $(u, v) \\notin M$：\n- 如果 $rank(u, v)  rank(u, \\text{$u$ 的当前伴侣})$，则 $u$ 偏好 $v$。如果 $u$ 未匹配，其当前伴侣的排名被视为无穷大，因此任何有效的提议都会被偏好。\n- 同样的逻辑也适用于 $v$ 的偏好。\n- 一个阻塞对的所有四个条件必须同时满足，计数才会增加。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a series of Stable Marriage Problems with Incomplete Lists and Forbidden Pairs.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"n\": 3,\n            \"P_U\": {0: [0, 1, 2], 1: [1, 2, 0], 2: [2, 1, 0]},\n            \"P_V\": {0: [1, 0, 2], 1: [0, 1, 2], 2: [2, 1, 0]},\n            \"F\": [[0, 2]]\n        },\n        {\n            \"n\": 3,\n            \"P_U\": {0: [1, 0, 2], 1: [1, 2, 0], 2: [0, 2, 1]},\n            \"P_V\": {0: [2, 0, 1], 1: [0, 1, 2], 2: [1, 2, 0]},\n            \"F\": []\n        },\n        {\n            \"n\": 4,\n            \"P_U\": {0: [0, 1, 2, 3], 1: [1, 0, 2, 3], 2: [2, 3, 1, 0], 3: [3, 2, 1, 0]},\n            \"P_V\": {0: [1, 0, 2, 3], 1: [0, 1, 2, 3], 2: [2, 3, 1, 0], 3: [3, 2, 1, 0]},\n            \"F\": [[3, 0], [3, 1], [3, 2], [3, 3]]\n        },\n        {\n            \"n\": 4,\n            \"P_U\": {0: [0], 1: [0], 2: [1, 2, 3], 3: [3, 2, 1]},\n            \"P_V\": {0: [1, 0, 2, 3], 1: [2, 3, 1, 0], 2: [2, 3, 1, 0], 3: [3, 2, 1, 0]},\n            \"F\": [[1, 1], [1, 2], [1, 3]]\n        },\n        {\n            \"n\": 2,\n            \"P_U\": {0: [0], 1: [1, 0]},\n            \"P_V\": {0: [1, 0], 1: [1, 0]},\n            \"F\": [[0, 0]]\n        },\n    ]\n\n    def format_result(res):\n        \"\"\"Formats a single result list into the required string representation.\"\"\"\n        s, p, b, u, M = res\n        s_str = 'true' if s else 'false'\n        p_str = 'true' if p else 'false'\n        m_str_parts = [f\"[{pair[0]},{pair[1]}]\" for pair in M]\n        m_str = f\"[{','.join(m_str_parts)}]\"\n        return f\"[{s_str},{p_str},{b},{u},{m_str}]\"\n\n    def run_smp_case(n, P_U, P_V, F):\n        \"\"\"Processes a single test case of the stable marriage problem.\"\"\"\n        F_set = {tuple(p) for p in F}\n\n        # 1. Preprocessing: Create effective preference lists for U\n        cleaned_U_prefs = {u: [] for u in range(n)}\n        for u in range(n):\n            if u in P_U:\n                for v in P_U[u]:\n                    is_acceptable = v in P_V and u in P_V.get(v, [])\n                    is_not_forbidden = (u, v) not in F_set\n                    if is_acceptable and is_not_forbidden:\n                        cleaned_U_prefs[u].append(v)\n        \n        # Pre-calculate V's rankings for efficient lookups\n        v_rankings = np.full((n, n), n, dtype=int)\n        for v in range(n):\n            if v in P_V:\n                for rank, u in enumerate(P_V[v]):\n                    v_rankings[v, u] = rank\n\n        # 2. Execution: U-proposing Gale-Shapley Algorithm\n        free_men = list(range(n))\n        u_proposal_idx = np.zeros(n, dtype=int)\n        v_partners = np.full(n, -1, dtype=int)\n\n        while free_men:\n            u = free_men.pop(0)\n            u_prefs = cleaned_U_prefs[u]\n            \n            if u_proposal_idx[u]  len(u_prefs):\n                v = u_prefs[u_proposal_idx[u]]\n                u_proposal_idx[u] += 1\n                \n                current_partner = v_partners[v]\n                if current_partner == -1:\n                    v_partners[v] = u\n                else:\n                    if v_rankings[v, u]  v_rankings[v, current_partner]:\n                        v_partners[v] = u\n                        free_men.append(current_partner)\n                    else:\n                        free_men.append(u)\n            # If u has exhausted their list, they remain unmatched.\n        \n        # 3. Verification and Analysis\n        \n        # Construct final matching M and related stats\n        M_dict = {v_partners[v]: v for v in range(n) if v_partners[v] != -1}\n        M_list = sorted(list(M_dict.items()))\n        \n        u_unmatched_count = n - len(M_list)\n        p_is_perfect = (len(M_list) == n)\n\n        # Count blocking pairs\n        u_rankings = np.full((n, n), n, dtype=int)\n        for u in range(n):\n            if u in P_U:\n                for rank, v in enumerate(P_U[u]):\n                    u_rankings[u, v] = rank\n\n        b_blocking_pairs_count = 0\n        for u in range(n):\n            u_current_partner = M_dict.get(u, -1)\n            u_current_rank = n if u_current_partner == -1 else u_rankings[u, u_current_partner]\n\n            if u not in P_U: continue\n\n            for v in P_U[u]:\n                if u_current_partner == v: continue # Not an outside pair\n\n                # Check if (u,v) is a blocking pair\n                is_acceptable = v in P_V and u in P_V.get(v, [])\n                is_not_forbidden = (u,v) not in F_set\n                \n                if is_acceptable and is_not_forbidden:\n                    u_prefers = u_rankings[u, v]  u_current_rank\n                    \n                    if u_prefers:\n                        v_current_partner = -1\n                        for i in range(n):\n                            if v_partners[i] == v:\n                                v_current_partner = v_partners[i]\n                                break\n\n                        # Find the actual partner of v for comparison\n                        v_actual_partner = -1\n                        for i_v_partner, i_u_partner in M_dict.items():\n                            if i_u_partner == v:\n                                v_actual_partner = i_v_partner\n                                break\n                        \n                        v_current_rank = n if v_actual_partner == -1 else v_rankings[v, v_actual_partner]\n                        v_prefers = v_rankings[v, u]  v_current_rank\n                        \n                        if v_prefers:\n                            b_blocking_pairs_count += 1\n        \n        s_is_stable = b_blocking_pairs_count == 0\n        \n        return [s_is_stable, p_is_perfect, b_blocking_pairs_count, u_unmatched_count, M_list]\n\n    results = [run_smp_case(**case) for case in test_cases]\n    results_as_strings = [format_result(r) for r in results]\n    \n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```", "id": "3274062"}, {"introduction": "基础稳定婚姻问题中的另一个理想化假设是所有偏好都是严格的。在现实中，个体常常对多个选项持无所谓态度。这项练习将探讨如何处理偏好列表中的这种“平局”情况。通过实现一个随机打破平局的规则，你将涉足算法的概率分析领域，这项高级问题要求你枚举所有可能的结果来计算一个智能体的期望结果，从而深入洞察算法在不确定性下的行为。[@problem_id:3273994]", "problem": "您的任务是修改经典的稳定匹配问题 (Stable Marriage Problem, SMP)，以处理偏好列表中的并列（无差异）情况。您需要应用一个随机打破并列的规则，然后分析单个指定参与者的期望结果。工作背景设定为有 $n$ 个男性和 $n$ 个女性，其中偏好可能包含并列。每个参与者的偏好是一个层级序列：层级 $1$ 是最偏好的，层级 $2$ 是次偏好的，以此类推；在同一层级内，参与者对所有候选人无差异。\n\n基本概念：\n- 一个匹配是男性集合与女性集合之间的一个双射。\n- 如果不存在阻塞对 $\\left(m,w\\right)$，使得 $m$ 偏好 $w$ 胜过其当前伴侣，并且 $w$ 也偏好 $m$ 胜过其当前伴侣，则该匹配是稳定的。\n- 当在严格偏好列表上运行时，男性提议的 Gale–Shapley 算法 (GS) 总能终止并得到男性最优的稳定匹配。\n\n随机打破并列规则：\n- 对每个参与者独立地，并对每个并列层级独立地，通过对该层级内的参与者进行均匀随机排列来打破并列。跨层级的相对顺序保持不变。这样为每个参与者生成一个严格全序。\n- 打破并列后，在得到的严格偏好上运行男性提议的 Gale–Shapley 算法。\n\n待分析的量：\n- 固定一个索引为 $i$ 的指定男性（参与者索引为 $0,1,\\dots,n-1$）。对于每个完整的打破并列的结果，GS 算法的输出是一个完美匹配。使用该指定男性原始的带并列的偏好，将其匹配到的伴侣映射到一个层级索引：如果匹配到的女性位于层级 $t$，则记录数值层级 $t$（层级 $1$ 为最优）。\n- 将指定男性的期望层级定义为，在所有打破并列结果的均匀分布下，所记录层级的平均值。\n\n计算任务：\n- 对于每个测试用例，通过枚举所有可能的打破并列结果（即所有参与者及其所有并列层级的所有独立排列的笛卡尔积），计算指定男性的精确期望层级。对每个结果：\n  1. 使用该结果的排列，将带并列的偏好转换为严格偏好。\n  2. 运行男性提议的 Gale–Shapley 算法以获得匹配。\n  3. 从该指定男性原始的带并列偏好中，记录其层级索引。\n- 将所有结果中记录的层级索引取平均值，以获得期望层级。将结果报告为一个四舍五入到 $6$ 位小数的浮点数。\n\n带并列偏好的表示方法：\n- 每个男性的偏好以层级列表的形式给出，其中每个层级是一个女性索引的列表。同样地，每个女性的偏好也是如此。例如，一个男性的偏好列表 $[[0,1],[2]]$ 意味着集合 $\\{0,1\\}$ 是层级 $1$（对女性 $0$ 和 $1$ 无差异），而 $\\{2\\}$ 是层级 $2$。\n\n假设：\n- 所有偏好列表都是完整的：对每个男性，所有层级恰好覆盖所有女性一次；对每个女性，所有层级恰好覆盖所有男性一次。\n- 每一方的参与者索引从 $0$ 到 $n-1$。\n- Gale–Shapley 算法使用男性提议。\n\n测试套件：\n- 您必须在以下 $4$ 个测试用例中计算指定男性的期望层级。在所有用例中，$n=3$，除了最后一个用例 $n=2$。每个测试用例由男性的层级偏好、女性的层级偏好和指定男性的索引指定。\n\n- 测试用例 $1$ (双方均有少量并列):\n  - 男性:\n    - $M_0$: $[[0,1],[2]]$\n    - $M_1$: $[[1],[0],[2]]$\n    - $M_2$: $[[1],[2],[0]]$\n  - 女性:\n    - $W_0$: $[[0,1],[2]]$\n    - $W_1$: $[[2],[1],[0]]$\n    - $W_2$: $[[0],[1],[2]]$\n  - 指定男性: $0$\n\n- 测试用例 $2$ (无并列；边界确定性):\n  - 男性:\n    - $M_0$: $[[0],[1],[2]]$\n    - $M_1$: $[[1],[0],[2]]$\n    - $M_2$: $[[1],[2],[0]]$\n  - 女性:\n    - $W_0$: $[[1],[0],[2]]$\n    - $W_1$: $[[0],[1],[2]]$\n    - $W_2$: $[[0],[1],[2]]$\n  - 指定男性: $1$\n\n- 测试用例 $3$ (仅接收方有并列；女性有并列，男性严格):\n  - 男性:\n    - $M_0$: $[[0],[1],[2]]$\n    - $M_1$: $[[1],[0],[2]]$\n    - $M_2$: $[[1],[2],[0]]$\n  - 女性:\n    - $W_0$: $[[0,1],[2]]$\n    - $W_1$: $[[1,2],[0]]$\n    - $W_2$: $[[0],[1],[2]]$\n  - 指定男性: $0$\n\n- 测试用例 $4$ (双方均完全并列；$n=2$；边缘均匀性):\n  - 男性:\n    - $M_0$: $[[0,1]]$\n    - $M_1$: $[[0,1]]$\n  - 女性:\n    - $W_0$: $[[0,1]]$\n    - $W_1$: $[[0,1]]$\n  - 指定男性: $0$\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表。第 $k$ 个数字必须是测试用例 $k$ 的期望层级，每个数字都四舍五入到 $6$ 位小数，例如 `[1.234000,2.000000,1.750000,1.000000]`。", "solution": "该问题被评估为有效。这是一个定义明确的计算任务，植根于成熟的稳定匹配算法理论和离散概率论。问题陈述是自洽的，数学上一致，并为计算唯一解提供了所有必要的数据和定义。所规定的计算方法，即枚举所有打破并列的可能性，对于测试套件中指定的小问题规模是可行的。\n\n解决此问题的方法涉及计算指定男性的期望层级，该期望层级定义为在偏好列表中所有可能的随机并列解消方案下，他得到的伴侣层级的平均值。单个测试用例的处理过程如下。\n\n设男性集合为 $M = \\{M_0, M_1, \\dots, M_{n-1}\\}$，女性集合为 $W = \\{W_0, W_1, \\dots, W_{n-1}\\}$，其中 $n$ 是男性和女性的数量。每个参与者 $a \\in M \\cup W$ 的偏好以层级列表 $P_a = (T_{a,1}, T_{a,2}, \\dots)$ 的形式给出，其中 $T_{a,j}$ 是另一组参与者的集合。参与者 $a$ 对给定层级 $T_{a,j}$ 中的所有参与者无差异，并且当且仅当 $j  k$ 时，他偏好层级 $T_{a,j}$ 中的任何参与者胜过层级 $T_{a,k}$ 中的任何参与者。\n\n随机打破并列规则规定，对于每个规模 $|T_{a,j}| > 1$ 的层级 $T_{a,j}$，通过从该层级中参与者的 $|T_{a,j}|!$ 种可能排列中均匀随机选择一个线性排序来替换 $T_{a,j}$，从而打破并列。这些选择对于所有参与者及其各自的所有层级都是独立进行的。\n\n一个结果 $\\omega$ 是对所有参与者的所有并列进行一次此类打破并列的完整规范。所有可能结果的集合表示为 $\\Omega$。唯一结果的总数是所有并列层级规模的阶乘之积：\n$$ |\\Omega| = \\prod_{a \\in M \\cup W} \\prod_{j \\text{ s.t. } |T_{a,j}|>1} |T_{a,j}|! $$\n\n对于每个结果 $\\omega \\in \\Omega$，我们可以为所有参与者构建一组严格偏好列表 $P'(\\omega)$。使用这些严格偏好，男性提议的 Gale-Shapley 算法（表示为 $\\text{GS}$）保证会产生一个唯一的稳定匹配，我们将其表示为 $\\mu_{\\omega}$。\n\n设指定男性为 $M_i$。在匹配 $\\mu_{\\omega}$ 中，他与某个女性 $w^* = \\mu_{\\omega}(M_i)$ 配对。然后我们参考 $M_i$ 原始的带并列的偏好列表 $P_{M_i}$，找到包含 $w^*$ 的层级。如果 $w^* \\in T_{M_i,t}$，我们记录这个层级索引 $t$。我们将此函数表示为 $\\text{Tier}(M_i, \\mu_{\\omega}) = t$。\n\n男性 $M_i$ 的期望层级是这些层级索引在所有可能结果上的算术平均值：\n$$ \\mathbb{E}[\\text{tier}(M_i)] = \\frac{1}{|\\Omega|} \\sum_{\\omega \\in \\Omega} \\text{Tier}(M_i, \\mu_{\\omega}) $$\n\n计算过程是该公式的直接实现：\n\n1.  **识别并列并生成排列**：对于每个测试用例，我们首先解析所有男性和女性的偏好列表，以找到所有规模大于 $1$ 的层级。对于每个这样的层级，我们生成所有可能排列的集合。\n\n2.  **枚举结果**：我们构建上一步中生成的所有排列集合的笛卡尔积。该积中的每个元素对应一个完整的打破并列的结果 $\\omega$。\n\n3.  **迭代和计算**：我们遍历笛卡尔积中的每个结果 $\\omega$。对于每个 $\\omega$：\n    a. 我们通过用 $\\omega$ 指定的具体排列替换每个并列层级，为所有 $n$ 个男性和 $n$ 个女性构建完整的严格偏好列表集合 $P'(\\omega)$。\n    b. 我们使用这些严格偏好 $P'(\\omega)$ 执行男性提议的 Gale-Shapley 算法。算法过程如下：\n        i. 初始化所有男性为自由状态。\n        ii. 当存在自由男性 $m$ 时，他向其偏好列表 $P'_m(\\omega)$ 中下一个尚未求婚过的女性 $w$ 求婚。\n        iii. 如果 $w$ 是自由的，她接受并与 $m$ 订婚。\n        iv. 如果 $w$ 已与男性 $m'$ 订婚，她使用她的偏好列表 $P'_w(\\omega)$ 比较 $m$ 和 $m'$。如果她偏好 $m$ 胜过 $m'$，她与 $m'$ 解除婚约（使 $m'$ 变为自由），并接受 $m$。否则，她拒绝 $m$。\n        v. 当没有男性是自由状态时，算法终止。得到的订婚集合即为稳定匹配 $\\mu_{\\omega}$。为实现高效，每个女性的偏好列表都被转换为一个排名映射，以允许常数时间的比较。\n    c. 我们确定指定男性 $M_i$ 的伴侣。设其为 $w^* = \\mu_{\\omega}(M_i)$。\n    d. 我们在 $M_i$ 原始的、未打破并列的偏好中确定 $w^*$ 的层级索引。将此索引添加到一个运行总和中。\n\n4.  **计算平均值**：遍历所有结果后，将记录的层级索引的总和除以结果总数 $|\\Omega|$，得到最终的期望层级。然后将该值四舍五入到所需的小数位数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import permutations, product\n\ndef run_gale_shapley(n, men_prefs, women_prefs):\n    \"\"\"\n    Executes the men-proposing Gale-Shapley algorithm.\n\n    Args:\n        n (int): The number of men/women.\n        men_prefs (list of list of int): Strict preference lists for men.\n        women_prefs (list of list of int): Strict preference lists for women.\n\n    Returns:\n        list of int: A list where the i-th element is the partner of man i.\n    \"\"\"\n    # Create rank maps for women for O(1) preference lookups.\n    # women_ranks[w][m] gives the rank of man m in woman w's preference list.\n    women_ranks = [[0] * n for _ in range(n)]\n    for w in range(n):\n        for rank, m in enumerate(women_prefs[w]):\n            women_ranks[w][m] = rank\n\n    # woman_partner[w] is the man currently engaged to woman w, -1 if free.\n    woman_partner = [-1] * n\n    # man_partner[m] is the woman currently engaged to man m, -1 if free.\n    man_partner = [-1] * n\n    # next_proposal[m] is the index of the next woman man m will propose to.\n    next_proposal = [0] * n\n\n    # Initially, all men are free.\n    free_men_q = list(range(n))\n\n    while free_men_q:\n        m = free_men_q.pop(0)\n        \n        # Man m proposes to the next woman on his list.\n        w = men_prefs[m][next_proposal[m]]\n        next_proposal[m] += 1\n\n        if woman_partner[w] == -1:\n            # Woman w is free, she accepts.\n            woman_partner[w] = m\n            man_partner[m] = w\n        else:\n            # Woman w is engaged, she compares her current partner with the new suitor.\n            current_partner = woman_partner[w]\n            if women_ranks[w][m]  women_ranks[w][current_partner]:\n                # She prefers the new man m.\n                woman_partner[w] = m\n                man_partner[m] = w\n                \n                # Her old partner becomes free.\n                man_partner[current_partner] = -1\n                free_men_q.append(current_partner)\n            else:\n                # She rejects m, m remains free and will propose to the next on his list.\n                free_men_q.append(m)\n    \n    return man_partner\n\ndef solve_case(n, men_tiered_prefs, women_tiered_prefs, designated_man_idx):\n    \"\"\"\n    Calculates the expected tier for a designated man for a single test case.\n    \"\"\"\n    # 1. Identify all ties and generate the set of permutations for each.\n    # tie_permutations_list will be a list of lists of tuples, e.g., [[(0,1), (1,0)], [(0,1), (1,0)]]\n    tie_permutations_list = []\n    \n    def find_ties(agent_prefs_list):\n        for agent_prefs in agent_prefs_list:\n            for tier in agent_prefs:\n                if len(tier) > 1:\n                    tie_permutations_list.append(list(permutations(tier)))\n\n    find_ties(men_tiered_prefs)\n    find_ties(women_tiered_prefs)\n\n    # 2. Prepare for iteration by creating a tier lookup map for the designated man.\n    # This maps each woman to her tier index (1-based) in the original preferences.\n    designated_man_tier_map = {}\n    for tier_idx, tier in enumerate(men_tiered_prefs[designated_man_idx]):\n        for woman in tier:\n            designated_man_tier_map[woman] = tier_idx + 1\n\n    total_tier_sum = 0\n    num_outcomes = 0\n\n    # Handle the case where there are no ties.\n    if not tie_permutations_list:\n        outcomes_iterator = [()]\n    else:\n        outcomes_iterator = product(*tie_permutations_list)\n\n    # 3. Iterate through all possible tie-breaking outcomes.\n    for outcome_permutations in outcomes_iterator:\n        num_outcomes += 1\n        perm_iterator = iter(outcome_permutations)\n\n        # 3a. For each outcome, build strict preference lists.\n        def build_strict_list(tiered_prefs):\n            strict_list = []\n            for tier in tiered_prefs:\n                if len(tier) > 1:\n                    strict_list.extend(next(perm_iterator))\n                else:\n                    strict_list.extend(tier)\n            return strict_list\n        \n        strict_men_prefs = [build_strict_list(p) for p in men_tiered_prefs]\n        strict_women_prefs = [build_strict_list(p) for p in women_tiered_prefs]\n        \n        # 3b. Run Gale-Shapley algorithm.\n        matching = run_gale_shapley(n, strict_men_prefs, strict_women_prefs)\n        \n        # 3c/d. Find designated man's partner, look up tier, and add to sum.\n        partner = matching[designated_man_idx]\n        tier = designated_man_tier_map[partner]\n        total_tier_sum += tier\n\n    # 4. Calculate the expected tier.\n    return total_tier_sum / num_outcomes\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"n\": 3,\n            \"men_prefs\": [[[0, 1], [2]], [[1], [0], [2]], [[1], [2], [0]]],\n            \"women_prefs\": [[[0, 1], [2]], [[2], [1], [0]], [[0], [1], [2]]],\n            \"designated_man\": 0,\n        },\n        # Test case 2\n        {\n            \"n\": 3,\n            \"men_prefs\": [[[0], [1], [2]], [[1], [0], [2]], [[1], [2], [0]]],\n            \"women_prefs\": [[[1], [0], [2]], [[0], [1], [2]], [[0], [1], [2]]],\n            \"designated_man\": 1,\n        },\n        # Test case 3\n        {\n            \"n\": 3,\n            \"men_prefs\": [[[0], [1], [2]], [[1], [0], [2]], [[1], [2], [0]]],\n            \"women_prefs\": [[[0, 1], [2]], [[1, 2], [0]], [[0], [1], [2]]],\n            \"designated_man\": 0,\n        },\n        # Test case 4\n        {\n            \"n\": 2,\n            \"men_prefs\": [[[0, 1]], [[0, 1]]],\n            \"women_prefs\": [[[0, 1]], [[0, 1]]],\n            \"designated_man\": 0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        expected_tier = solve_case(\n            case[\"n\"], case[\"men_prefs\"], case[\"women_prefs\"], case[\"designated_man\"]\n        )\n        results.append(f\"{expected_tier:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3273994"}]}