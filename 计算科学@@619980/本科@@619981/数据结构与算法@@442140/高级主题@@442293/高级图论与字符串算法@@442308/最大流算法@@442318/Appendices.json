{"hands_on_practices": [{"introduction": "在许多现实世界的网络中，例如交通枢纽或通信中心，瓶颈不仅存在于连接点之间的“边”上，也存在于节点本身。本练习将引导你掌握一种核心建模技巧：如何将一个包含节点容量的网络，等价地转换为一个只包含边容量的标准网络。掌握这种转换 [@problem_id:3249870] 对于将最大流算法应用于更广泛的实际问题至关重要。", "problem": "考虑一个有向流网络，该网络有一个指定的源点 $s$ 和汇点 $t$。除了边的容量限制外，每个内部节点还有一个容量，限制了能够通过该节点的总流量。网络包含节点 $s$、$v_{1}$、$v_{2}$、$v_{3}$、$v_{4}$ 和 $t$。有向边及其容量如下：$s \\to v_{1}$ 容量为 $8$，$s \\to v_{2}$ 容量为 $7$，$v_{1} \\to v_{3}$ 容量为 $5$，$v_{1} \\to v_{4}$ 容量为 $3$，$v_{2} \\to v_{3}$ 容量为 $4$，$v_{2} \\to v_{4}$ 容量为 $6$，$v_{3} \\to t$ 容量为 $9$，$v_{4} \\to t$ 容量为 $5$。节点容量为：$c(v_{1}) = 6$，$c(v_{2}) = 5$，$c(v_{3}) = 7$，$c(v_{4}) = 4$，源点 $s$ 和汇点 $t$ 没有节点容量限制（等效于无限大）。\n\n仅使用流网络的基础理论——即边和节点的容量限制，以及中间节点的流量守恒——并应用一种与 Ford–Fulkerson 方法、Edmonds–Karp 算法或 Dinic 算法一致的正确归约或算法策略，确定此网络中的最大 $s-t$ 流量值。\n\n请以一个实数形式给出最终答案，代表最大流量值。无需四舍五入。", "solution": "我们从流网络的定义开始。一个可行流 $f$ 为每条有向边 $(u,v)$ 赋一个非负值 $f(u,v)$，使得对于每个边的容量 $c(u,v)$，都有 $0 \\le f(u,v) \\le c(u,v)$，并且每个中间节点都满足流量守恒：对于任意节点 $w \\notin \\{s,t\\}$，流入该节点的总流量等于流出该节点的总流量。对于有节点容量的情况，每个内部节点 $w$ 还需满足通过 $w$ 的总流量至多为该节点的容量 $c(w)$，这可以通过确保从 $w$ 流出的总流量（等价于流入的总流量）不超过 $c(w)$ 来实现。\n\n一个标准且经过检验的归约方法，是将节点容量转换为边容量：将每个节点 $v$ 拆分为两个节点 $v_{\\mathrm{in}}$ 和 $v_{\\mathrm{out}}$，并用一条容量为 $c(v)$ 的边 $(v_{\\mathrm{in}}, v_{\\mathrm{out}})$ 连接它们；然后将每条原始的入边 $(u,v)$ 重定向为 $(u, v_{\\mathrm{in}})$，并将每条原始的出边 $(v,w)$ 重定向为 $(v_{\\mathrm{out}}, w)$。源点 $s$ 和汇点 $t$ 可以不拆分，或视为具有无限容量。变换后图中的最大流量等于原始带节点容量网络中的最大流量。\n\n我们分析给定的网络。边和容量：\n- $s \\to v_{1}$ 容量为 $8$，\n- $s \\to v_{2}$ 容量为 $7$，\n- $v_{1} \\to v_{3}$ 容量为 $5$，\n- $v_{1} \\to v_{4}$ 容量为 $3$，\n- $v_{2} \\to v_{3}$ 容量为 $4$，\n- $v_{2} \\to v_{4}$ 容量为 $6$，\n- $v_{3} \\to t$ 容量为 $9$，\n- $v_{4} \\to t$ 容量为 $5$。\n\n节点容量：\n- $c(v_{1}) = 6$，\n- $c(v_{2}) = 5$，\n- $c(v_{3}) = 7$，\n- $c(v_{4}) = 4$，\n- $c(s)$ 和 $c(t)$ 等效于无限大。\n\n根据基本的容量限制，能够离开 $v_{1}$ 的总流量至多为 $6$，并且还必须遵守其出边上 $5$ 和 $3$ 的边容量。能够离开 $v_{2}$ 的总流量至多为 $5$，并且还必须遵守 $4$ 和 $6$ 的边容量。在汇点一侧，能够通过 $v_{3}$ 的总流量至多为 $7$，并且还必须遵守到 $t$ 的边容量 $9$；对于 $v_{4}$，总流量至多为 $4$，并且必须遵守到 $t$ 的边容量 $5$。\n\n这些观察立即给出了总 $s-t$ 流量的上限：\n- 从源点一侧看，无论连接源点的边容量 $8$ 和 $7$ 有多大，通过与源点相邻的两个内部节点的流量不能超过 $c(v_{1}) + c(v_{2}) = 6 + 5 = 11$。\n- 从汇点一侧看，无论连接汇点的边容量 $9$ 和 $5$ 有多大，在到达 $t$ 之前，两个内部节点能吸收的流量不能超过 $c(v_{3}) + c(v_{4}) = 7 + 4 = 11$。\n\n因此，最大流量值的上限为 $11$。\n\n我们现在构造一个达到 $11$ 的显式可行流，结合该上限，即可证明其最优性。设变量表示中间边上的流量：\n- $x_{13} = f(v_{1}, v_{3})$，满足 $0 \\le x_{13} \\le 5$，\n- $x_{14} = f(v_{1}, v_{4})$，满足 $0 \\le x_{14} \\le 3$，\n- $y_{23} = f(v_{2}, v_{3})$，满足 $0 \\le y_{23} \\le 4$，\n- $y_{24} = f(v_{2}, v_{4})$，满足 $0 \\le y_{24} \\le 6$。\n\n节点容量限制转化为：\n- 对于 $v_{1}$：$x_{13} + x_{14} \\le 6$，\n- 对于 $v_{2}$：$y_{23} + y_{24} \\le 5$，\n- 对于 $v_{3}$：$x_{13} + y_{23} \\le 7$（也因边 $v_{3} \\to t$ 而需 $\\le 9$，因此 $7$ 是约束性的），\n- 对于 $v_{4}$：$x_{14} + y_{24} \\le 4$（也因边 $v_{4} \\to t$ 而需 $\\le 5$，因此 $4$ 是约束性的）。\n\n到 $t$ 的总流量等于 $(x_{13} + y_{23}) + (x_{14} + y_{24})$。选择以下数值：\n- $x_{14} = 3$ 且 $y_{24} = 1$，使得 $x_{14} + y_{24} = 4$，这饱和了 $v_{4}$ 的节点容量，并满足边容量限制 $3$ 和 $6$。\n- $x_{13} = 3$ 且 $y_{23} = 4$，使得 $x_{13} + y_{23} = 7$，这饱和了 $v_{3}$ 的节点容量，并满足边容量限制 $5$ 和 $4$。\n\n验证节点容量：\n- $v_{1}$：$x_{13} + x_{14} = 3 + 3 = 6 \\le 6$，\n- $v_{2}$：$y_{23} + y_{24} = 4 + 1 = 5 \\le 5$，\n- $v_{3}$：$x_{13} + y_{23} = 3 + 4 = 7 \\le 7$，\n- $v_{4}$：$x_{14} + y_{24} = 3 + 1 = 4 \\le 4$。\n\n验证边容量：\n- $v_{1} \\to v_{3}$：$x_{13} = 3 \\le 5$，\n- $v_{1} \\to v_{4}$：$x_{14} = 3 \\le 3$，\n- $v_{2} \\to v_{3}$：$y_{23} = 4 \\le 4$，\n- $v_{2} \\to v_{4}$：$y_{24} = 1 \\le 6$，\n- $v_{3} \\to t$：总流量 $7 \\le 9$，\n- $v_{4} \\to t$：总流量 $4 \\le 5$，\n- $s \\to v_{1}$ 和 $s \\to v_{2}$ 的容量是足够的，因为 $f(s,v_{1}) = x_{13} + x_{14} = 6 \\le 8$ 且 $f(s,v_{2}) = y_{23} + y_{24} = 5 \\le 7$。\n\n根据构造，每个中间节点都满足流量守恒，并且源点和汇点的流量相匹配：总流量值为\n$$\n(x_{13} + y_{23}) + (x_{14} + y_{24}) = 7 + 4 = 11.\n$$\n这个可行流达到了上限 $11$，因此，根据最大流和容量限制的基本原则，给定带节点容量网络中的最大 $s-t$ 流量为 $11$。", "answer": "$$\\boxed{11}$$", "id": "3249870"}, {"introduction": "现实世界中的许多物流与分配问题，都需要从多个起点向多个终点输送资源。这个动手编程练习 [@problem_id:3249859] 将挑战你实现一个经典的最大流变种问题的解决方案。你需要通过构建一个“超级源点”和“超级汇点”，将复杂的多源多汇问题转化为可以用标准算法（如Edmonds-Karp）求解的单源单汇问题。", "problem": "你的任务是计算具有多个源顶点和多个汇顶点的有向网络中可行流的最大值。你的程序必须仅依赖于网络流的基本定义和经过充分检验的算法原理。流网络是一个边上带有容量的有向图。一个可行的流函数必须满足：对于每条有向边，其上的流量介于零和其容量之间；对于除指定的源点和汇点之外的每个顶点，其净流量守恒。割是任何将所有源点与所有汇点分开的顶点划分，任何可行流的值都不能超过任何割的容量。\n\n基于这些基础，推导并实现一种正确且高效的方法，用于计算具有一组源点和一组汇点的网络的最大流。该方法必须基于一种构造，即通过增加一个超级源点和一个超级汇点来将多源多汇网络简化为单源单汇实例。超级源点连接到所有原始源点，而所有原始汇点都连接到超级汇点，这些新边的容量要足够大。其正确性应源于流量守恒和容量约束，以及最大流最小割定理，而不应假设任何捷径公式。\n\n你必须实现一个完整的、可运行的程序，对下面测试套件中的每个测试用例，构造相应的增广网络并计算其最大流值。你的算法设计必须基于经典原理，例如构建残差网络并通过广度优先搜索（BFS）来寻找增广路径，例如在Edmonds-Karp算法中实现的那样。首次使用缩略词时需定义（例如，广度优先搜索 (BFS)）。\n\n本规范中的所有数字都是整数，应被解释为无量纲的。没有物理单位。\n\n硬编码在程序中的输入格式：\n- 每个测试用例包括：顶点数 $n$（标记为 $0$ 到 $n-1$），一个带容量的有向边列表，一组源顶点和一组汇顶点。\n\n测试套件：\n- 测试用例 $1$（具有多条路径和平衡汇点的通用情况）：\n  - 顶点：$n = 8$，标记为 $0,1,2,3,4,5,6,7$。\n  - 源点：$\\{0,1\\}$。\n  - 汇点：$\\{6,7\\}$。\n  - 带容量的有向边（三元组 $(u,v,c)$ 表示一条从 $u$ 到 $v$ 容量为 $c$ 的边）：\n    $\\{(0,2,10),(0,3,5),(1,3,15),(1,4,4),(2,5,15),(3,2,4),(3,5,8),(3,4,6),(4,5,10),(5,6,10),(5,7,10),(4,7,5),(2,6,5)\\}$。\n  - 预期的最大流值将由你的算法确定。\n- 测试用例 $2$（零容量割和断开源点的边界情况）：\n  - 顶点：$n = 5$，标记为 $0,1,2,3,4$。\n  - 源点：$\\{0,1\\}$。\n  - 汇点：$\\{3,4\\}$。\n  - 边：$\\{(0,2,7),(2,3,0),(2,4,0)\\}$。请注意，顶点 $1$ 没有出边，并且从 $0$ 到任何汇点的唯一路径都经过零容量边。\n- 测试用例 $3$（单个瓶颈边主导最大流）：\n  - 顶点：$n = 6$，标记为 $0,1,2,3,4,5$。\n  - 源点：$\\{0,1\\}$。\n  - 汇点：$\\{4,5\\}$。\n  - 边：$\\{(0,2,100),(1,2,100),(2,3,7),(3,4,100),(3,5,100)\\}$。\n- 测试用例 $4$（平行边和分流到多个汇点）：\n  - 顶点：$n = 6$，标记为 $0,1,2,3,4,5$。\n  - 源点：$\\{0,1\\}$。\n  - 汇点：$\\{4,5\\}$。\n  - 边包括表示为独立三元组的平行边：\n    $\\{(0,2,5),(0,2,7),(1,2,3),(2,3,4),(2,3,6),(3,4,100),(2,5,1)\\}$。\n\n输出规范：\n- 你的程序必须为每个测试用例计算从给定源点集到给定汇点集的整数最大流值。\n- 你的程序必须生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例的顺序列出结果，例如：`[x_1,x_2,x_3,x_4]`，其中 $x_i$ 是测试用例 $i$ 的最大流值。\n\n约束和说明：\n- 所有容量均为非负整数。\n- 在构造超级源点和超级汇点时，将超级源点连接到每个原始源点，并将每个原始汇点连接到超级汇点，其容量至少为原始图中所有有限容量的总和，这足以避免限制真实的最大流。\n- 不读取外部输入；所有测试用例均按规定硬编码。", "solution": "该问题要求我们计算一个具有多个源点和多个汇点的网络中的最大流。标准的最大流算法，如Edmonds-Karp或Dinic，是为单源单汇网络设计的。因此，解决此问题的关键在于将给定的多源多汇网络等价地转换为一个标准的单源单汇网络。\n\n### 转换方法\n\n我们可以通过引入一个“超级源点”（super-source）和一个“超级汇点”（super-sink）来完成这个转换。具体步骤如下：\n\n1.  **创建超级源点 $S'$**：在原图中增加一个新节点 $S'$。对于原图中的每一个源点 $s_i$，我们从 $S'$ 向 $s_i$ 添加一条新的有向边 $(S', s_i)$。\n2.  **创建超级汇点 $T'$**：同样，在原图中增加一个新节点 $T'$。对于原图中的每一个汇点 $t_j$，我们从 $t_j$ 向 $T'$ 添加一条新的有向边 $(t_j, T')$。\n3.  **设置新边的容量**：为了确保这些新添加的边不会成为流量的瓶颈，它们的容量必须足够大。理论上，我们可以将容量设置为无穷大 $(\\infty)$。在实际计算中，一个安全且常用的做法是将其容量设置为一个大于或等于网络中所有原始边容量之和的数。这保证了任何可能的最大流都不会受到这些新边的限制。\n\n### 求解\n\n经过上述转换后，我们得到了一个只有单一源点 $S'$ 和单一汇点 $T'$ 的增广图。原多源多汇问题中的最大流值，就等于这个新的单源单汇网络中从 $S'$ 到 $T'$ 的最大流值。\n\n接下来，我们可以应用任何标准的最大流算法来解决这个问题。本解决方案中提供的代码采用了 **Edmonds-Karp算法**。该算法的流程如下：\n\n1.  在残差网络（residual graph）中，使用**广度优先搜索（BFS）** 不断寻找从 $S'$ 到 $T'$ 的增广路径（augmenting path）。\n2.  每找到一条增广路径，就计算其瓶颈容量，并用该容量更新路径上各边的流量和残差容量。\n3.  重复此过程，直到残差网络中再也找不到从 $S'$ 到 $T'$ 的增广路径为止。此时，累积的总流量即为最大流。\n\n提供的Python代码实现了这一完整流程：它首先根据每个测试用例构建增广图，然后调用Edmonds-Karp算法计算最大流，并最终输出所有测试用例的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the multi-source, multi-sink max-flow problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"n\": 8,\n            \"sources\": {0, 1},\n            \"sinks\": {6, 7},\n            \"edges\": [\n                (0, 2, 10), (0, 3, 5), (1, 3, 15), (1, 4, 4), (2, 5, 15),\n                (3, 2, 4), (3, 5, 8), (3, 4, 6), (4, 5, 10), (5, 6, 10),\n                (5, 7, 10), (4, 7, 5), (2, 6, 5)\n            ],\n        },\n        {\n            \"n\": 5,\n            \"sources\": {0, 1},\n            \"sinks\": {3, 4},\n            \"edges\": [(0, 2, 7), (2, 3, 0), (2, 4, 0)],\n        },\n        {\n            \"n\": 6,\n            \"sources\": {0, 1},\n            \"sinks\": {4, 5},\n            \"edges\": [\n                (0, 2, 100), (1, 2, 100), (2, 3, 7), (3, 4, 100), (3, 5, 100)\n            ],\n        },\n        {\n            \"n\": 6,\n            \"sources\": {0, 1},\n            \"sinks\": {4, 5},\n            \"edges\": [\n                (0, 2, 5), (0, 2, 7), (1, 2, 3), (2, 3, 4), (2, 3, 6),\n                (3, 4, 100), (2, 5, 1)\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        sources = case[\"sources\"]\n        sinks = case[\"sinks\"]\n        edges = case[\"edges\"]\n\n        # 1. Construct the augmented graph\n        # Super-source will be at index n, super-sink at n+1\n        super_source = n\n        super_sink = n + 1\n        num_vertices_aug = n + 2\n\n        # Adjacency matrix for residual capacities\n        graph = np.zeros((num_vertices_aug, num_vertices_aug), dtype=np.int64)\n\n        total_capacity_sum = 0\n        for u, v, c in edges:\n            graph[u, v] += c\n            total_capacity_sum += c\n        \n        # A sufficiently large capacity for super-edges\n        # Sum of all original capacities is a safe upper bound on the max flow.\n        # If total_capacity_sum is 0, we use 1 to handle disconnected graphs.\n        inf_capacity = total_capacity_sum if total_capacity_sum > 0 else 1\n\n        for s in sources:\n            graph[super_source, s] = inf_capacity\n        for t in sinks:\n            graph[t, super_sink] = inf_capacity\n\n        results.append(edmonds_karp(graph, super_source, super_sink))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef bfs(graph, s, t, parent):\n    \"\"\"\n    Breadth-First Search to find an augmenting path in the residual graph.\n    `graph` is the residual capacity matrix.\n    `s` is the source, `t` is the sink.\n    `parent` is an array to store the path.\n    Returns True if a path is found, False otherwise.\n    \"\"\"\n    num_vertices = graph.shape[0]\n    visited = [False] * num_vertices\n    \n    # Use a list as a queue for BFS. For problem constraints, performance is acceptable.\n    queue = []\n    queue.append(s)\n    visited[s] = True\n    parent[s] = -1\n\n    while queue:\n        u = queue.pop(0)\n        for v in range(num_vertices):\n            if not visited[v] and graph[u, v] > 0:\n                queue.append(v)\n                visited[v] = True\n                parent[v] = u\n                if v == t:\n                    return True\n    return False\n\ndef edmonds_karp(graph, source, sink):\n    \"\"\"\n    Implements the Edmonds-Karp algorithm to find the maximum flow.\n    `graph` is the initial capacity matrix.\n    `source` and `sink` are the vertices for the flow.\n    \"\"\"\n    num_vertices = graph.shape[0]\n    parent = np.empty(num_vertices, dtype=np.int64)\n    max_flow = 0\n\n    # `residual_graph` will be modified in place\n    residual_graph = np.copy(graph)\n\n    while bfs(residual_graph, source, sink, parent):\n        # Find the bottleneck capacity of the path found by BFS\n        path_flow = np.iinfo(np.int64).max\n        v = sink\n        while v != source:\n            u = parent[v]\n            path_flow = min(path_flow, residual_graph[u, v])\n            v = u\n\n        # Update residual capacities of the edges and reverse edges\n        v = sink\n        while v != source:\n            u = parent[v]\n            residual_graph[u, v] -= path_flow\n            residual_graph[v, u] += path_flow\n            v = u\n\n        # Add path flow to overall flow\n        max_flow += path_flow\n\n    return max_flow\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3249859"}, {"introduction": "最大流算法不仅能计算网络的最大容量，还能作为分析网络稳健性和脆弱性的强大工具。在本练习 [@problem_id:3249860] 中，你的任务是找出网络中的“最关键的边”——即移除哪条边会导致网络流通能力下降最多。这个过程将展示最大流算法如何用于复杂系统中的敏感性分析和风险评估。", "problem": "给定一个有向流网络族。每个网络都是一个有向图 $G=(V,E)$，其中包含一个指定的源点 $s \\in V$ 和一个汇点 $t \\in V$。每条有向边 $e \\in E$都有一个非负整数容量 $c(e) \\in \\mathbb{Z}_{\\ge 0}$。一个可行流是一个函数 $f:E \\to \\mathbb{R}_{\\ge 0}$，它满足所有边 $e \\in E$ 的容量限制 $0 \\le f(e) \\le c(e)$，并且对于每个不包括源点和汇点的顶点 $v \\in V \\setminus \\{s,t\\}$，满足流量守恒约束，即流入 $v$ 的总流量等于流出 $v$ 的总流量。一个流的值是从 $s$ 发送到 $t$ 的净流量，可以计算为离开 $s$ 的边的流量总和，或等效地，进入 $t$ 的边的流量总和。残留网络 $G_f$ 是根据 $G$ 构建的，方法是为每条边 $(u,v)$ 分配一个等于 $c(u,v) - f(u,v)$ 的残留容量，并添加一条容量等于 $f(u,v)$ 的反向边 $(v,u)$；增广路径是 $G_f$ 中一条从 $s$ 到 $t$ 的路径，可以沿着它推送额外的流量。一个广为接受的定理是，最大流值等于最小 $s-t$ 割的容量，其中 $s-t$ 割是 $V$ 的一个划分 $(S,T)$，满足 $s \\in S$ 和 $t \\in T$，割的容量是从 $S$ 到 $T$ 的所有边的容量总和。\n\n定义一条“最关键”边为这样一条边 $e^\\star \\in E$，将其容量减少到零（即从网络中移除 $e^\\star$）会导致 $s$ 和 $t$ 之间最大流值的最大下降。形式上，令 $F^\\star$ 为原始网络中的最大流值。对于每条边 $e_i \\in E$，令 $F_i$ 为将 $e_i$ 的容量设置为 $0$ 后修改网络中的最大流值。移除 $e_i$ 导致的下降量为 $D_i = F^\\star - F_i$。最关键的边是任何能使 $D_i$ 最大化的 $e^\\star$。如果出现平局，选择在给定输入顺序中索引最小的边。\n\n从上述核心定义出发，编写一个完整的程序，为提供的测试套件中的每个网络计算：\n- 基准最大流值 $F^\\star$，\n- 每次移除一条边所获得的下降值 $D_i$，\n- 最关键边的索引 $i^\\star$（从零开始，根据输入顺序）以及相应的下降量 $D_{i^\\star}$。\n\n您的程序必须实现一个基于残差网络和增广路径的正确最大流算法（例如，使用广度优先搜索寻找增广路径的Edmonds-Karp算法）。最终输出必须是单行，包含一个用方括号括起来的逗号分隔列表，其中每个元素是对应测试用例的一个双整数列表 $[i^\\star,D_{i^\\star}]$。例如，如果有 $k$ 个测试用例，输出格式为 `[[i^\\star_1,D_{i^\\star_1}],...,[i^\\star_k,D_{i^\\star_k}]]`。所有容量均为整数，没有物理单位。\n\n使用以下测试套件。在每个案例中，顶点索引从 $0$到 $n-1$，边以有序三元组 $\\langle u,v,c \\rangle$ 的形式列出，其中 $u$ 是起点，$v$ 是终点，$c$ 是容量。边的索引是其在列表中的位置，从 $0$ 开始。\n\n测试用例 1：\n- $n = 6$，$s = 0$，$t = 5$，\n- 边：\n  - $\\langle 0,1,10 \\rangle$，\n  - $\\langle 0,2,8 \\rangle$，\n  - $\\langle 1,3,4 \\rangle$，\n  - $\\langle 1,2,2 \\rangle$，\n  - $\\langle 2,3,6 \\rangle$，\n  - $\\langle 3,4,8 \\rangle$，\n  - $\\langle 4,5,10 \\rangle$，\n  - $\\langle 2,4,3 \\rangle$。\n\n测试用例 2：\n- $n = 4$，$s = 0$，$t = 3$，\n- 边：\n  - $\\langle 0,1,5 \\rangle$，\n  - $\\langle 0,2,5 \\rangle$，\n  - $\\langle 1,3,5 \\rangle$，\n  - $\\langle 2,3,5 \\rangle$。\n\n测试用例 3：\n- $n = 5$，$s = 0$，$t = 4$，\n- 边：\n  - $\\langle 0,1,7 \\rangle$，\n  - $\\langle 0,1,3 \\rangle$，\n  - $\\langle 1,2,4 \\rangle$，\n  - $\\langle 2,1,4 \\rangle$，\n  - $\\langle 1,3,6 \\rangle$，\n  - $\\langle 3,4,5 \\rangle$，\n  - $\\langle 2,4,4 \\rangle$。\n\n测试用例 4：\n- $n = 3$，$s = 0$，$t = 2$，\n- 边：\n  - $\\langle 0,1,5 \\rangle$，\n  - $\\langle 1,0,3 \\rangle$。\n\n您的程序应生成单行输出，包含以方括号括起来的逗号分隔列表形式的结果，每个结果按测试用例的顺序编码为双整数列表 $[i^\\star,D_{i^\\star}]$。例如，输出必须类似于 `[[i_1,d_1],[i_2,d_2],[i_3,d_3],[i_4,d_4]]`，不含多余的空格或文本。", "solution": "该问题被评估为有效。它在科学上基于已建立的网络流数学理论，问题定义良好（良定），并通过平局打破规则保证了唯一答案，且使用客观、正式的语言表述。解决问题所需的所有数据和定义均已提供。\n\n该问题要求在流网络中识别出一条“最关键边”。其定义为从网络中移除后，会导致从给定源点 $s$到汇点 $t$ 的最大流值下降幅度最大的那条边。\n\n设给定的有向图为 $G=(V, E)$，其中源点为 $s \\in V$，汇点为 $t \\in V$，所有边 $e \\in E$ 的容量为 $c(e) \\ge 0$。设输入中提供的边列表表示为 $L = [e_0, e_1, \\dots, e_{m-1}]$，其中 $m = |E|$。\n\n总体算法流程如下：\n1. 首先，计算原始网络 $G$ 中的最大流值 $F^\\star$。这通过从完整的边列表 $L$ 构建容量图并运行最大流算法来完成。\n2. 然后，对于列表 $L$ 中的每条边 $e_i$（其中 $i$ 是其从 $0$ 到 $m-1$ 的从零开始的索引）：\n    a. 通过有效移除边 $e_i$ 来构建一个修改后的网络 $G_i$。这对应于从边列表 $L \\setminus \\{e_i\\}$ 创建一个图。\n    b. 为这个修改后的网络 $G_i$ 计算最大流值 $F_i$。\n    c. 计算最大流的下降量 $D_i = F^\\star - F_i$。\n3. 在计算完所有下降值 $D_0, D_1, \\dots, D_{m-1}$ 后，我们找出使该下降量最大化的索引 $i^\\star$。问题规定，在出现平局的情况下，选择索引 $i$ 最小的边。形式上，$i^\\star = \\min(\\arg\\max_{i \\in \\{0, \\dots, m-1\\}} D_i)$。\n4. 对于给定的网络，最终结果是数对 $[i^\\star, D_{i^\\star}]$。\n\n此过程的核心是最大流的计算。问题要求使用一种基于残留网络和增广路径的方法，例如由广度优先搜索（BFS）驱动的方法。Edmonds-Karp 算法是此类方法的典型例子，并将用于本解决方案。\n\nEdmonds-Karp 算法的运作方式如下：\n1. 从零流开始，$f(e) = 0$ 对于所有 $e \\in E$。总流量值为 $0$。\n2. 构建残留图 $G_f$。对于每条边 $(u,v) \\in E$，残留图包含一条残留容量为 $c_f(u,v) = c(u,v) - f(u,v)$ 的前向边 $(u,v)$ 和一条残留容量为 $c_f(v,u) = f(u,v)$ 的后向边 $(v,u)$。在实践中，我们可以维护一个可迭代更新的单一残留容量矩阵。\n3. 使用广度优先搜索（BFS）在残留图 $G_f$ 中重复查找从 $s$到 $t$ 的增广路径。增广路径是其中每条边都具有严格正残留容量的路径。BFS 用于查找边数最少的此类路径。\n4. 如果 BFS 找到一条路径 $p$：\n    a. 确定路径的瓶颈容量 $\\delta$，即路径 $p$ 上任何边的最小残留容量。$\\delta = \\min_{(u,v) \\in p} \\{c_f(u,v)\\}$。\n    b. 将流量增加 $\\delta$。这包括在 $p$ 中的所有前向边上增加 $\\delta$ 的流量，并在所有后向边上减少 $\\delta$ 的流量。在残留容量表示中，这意味着对于 $p$ 中的每条边 $(u,v)$，将 $c_f(u,v)$ 减少 $\\delta$ 并将 $c_f(v,u)$ 增加 $\\delta$。\n    c. 将 $\\delta$ 加到总流量值中。\n5. 如果 BFS 未能找到从 $s$到 $t$ 的路径，则算法终止。根据最大流最小割定理，累积的总流量即为最大流值。\n\n图将由一个 $n \\times n$ 的容量矩阵表示，其中 $n = |V|$。对于在同一对顶点之间存在多条边的测试用例（如测试用例3中的多重图），这些平行边的容量将被相加以形成容量矩阵中的条目。在每次最大流计算之前，逐个移除边的迭代操作是在原始边列表上执行的，然后再构建容量矩阵。这确保了我们正在评估每个特定输入边的关键性，包括单个的平行边。\n例如，为了计算 $F^\\star$，容量矩阵是使用所有边构建的。为了计算 $F_i$，容量矩阵是使用除 $e_i$ 之外的所有边从头开始构建的。\n整个过程是确定性的，并保证会终止，为每个测试用例产生所需的 $[i^\\star, D_{i^\\star}]$ 对。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 6, \"s\": 0, \"t\": 5,\n            \"edges\": [\n                (0, 1, 10), (0, 2, 8), (1, 3, 4), (1, 2, 2),\n                (2, 3, 6), (3, 4, 8), (4, 5, 10), (2, 4, 3)\n            ]\n        },\n        {\n            \"n\": 4, \"s\": 0, \"t\": 3,\n            \"edges\": [\n                (0, 1, 5), (0, 2, 5), (1, 3, 5), (2, 3, 5)\n            ]\n        },\n        {\n            \"n\": 5, \"s\": 0, \"t\": 4,\n            \"edges\": [\n                (0, 1, 7), (0, 1, 3), (1, 2, 4), (2, 1, 4),\n                (1, 3, 6), (3, 4, 5), (2, 4, 4)\n            ]\n        },\n        {\n            \"n\": 3, \"s\": 0, \"t\": 2,\n            \"edges\": [\n                (0, 1, 5), (1, 0, 3)\n            ]\n        }\n    ]\n\n    final_results = []\n    \n    for case in test_cases:\n        n, s, t, edges = case[\"n\"], case[\"s\"], case[\"t\"], case[\"edges\"]\n        \n        # 1. Compute baseline maximum flow F_star\n        F_star = edmonds_karp(n, s, t, edges)\n        \n        drops = []\n        # 2. Iterate through each edge, remove it, and compute the new max flow\n        for i in range(len(edges)):\n            # Create a temporary list of edges with the i-th edge removed\n            temp_edges = edges[:i] + edges[i+1:]\n            \n            # Compute max flow F_i for the modified network\n            F_i = edmonds_karp(n, s, t, temp_edges)\n            \n            # Calculate the drop D_i\n            D_i = F_star - F_i\n            drops.append(D_i)\n        \n        # 3. Find the index and value of the maximum drop\n        if not drops:\n            # Handle cases with no edges\n            best_index, max_drop = 0, 0\n        else:\n            max_drop = -1\n            best_index = -1\n            for i, drop in enumerate(drops):\n                if drop > max_drop:\n                    max_drop = drop\n                    best_index = i\n            # If all drops are 0, the first edge (index 0) is chosen due to the tie-breaking rule\n            if best_index == -1:\n                best_index = 0\n                max_drop = 0\n\n        final_results.append([best_index, max_drop])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\".replace(\" \", \"\"))\n\ndef build_capacity_matrix(n, edges):\n    \"\"\"\n    Constructs a capacity matrix from a list of edges.\n    Handles parallel edges by summing their capacities.\n    \"\"\"\n    capacity = np.zeros((n, n), dtype=int)\n    for u, v, c in edges:\n        capacity[u, v] += c\n    return capacity\n\ndef bfs_augmenting_path(n, s, t, residual_graph):\n    \"\"\"\n    Finds an augmenting path from s to t in the residual graph using BFS.\n    Returns the path and its bottleneck capacity.\n    \"\"\"\n    parent = {node: None for node in range(n)}\n    queue = deque([s])\n    visited = {s}\n    \n    while queue:\n        u = queue.popleft()\n        if u == t:\n            break\n        \n        for v in range(n):\n            if v not in visited and residual_graph[u, v] > 0:\n                parent[v] = u\n                visited.add(v)\n                queue.append(v)\n        else:\n            continue # Continue if inner loop wasn't broken\n        break # Break outer loop if u == t\n    else: # If while loop finishes without finding t\n       return None, 0\n\n    # Reconstruct path and find bottleneck capacity\n    path = []\n    curr = t\n    path_flow = float('inf')\n    while curr != s:\n        prev = parent[curr]\n        path.append((prev, curr))\n        path_flow = min(path_flow, residual_graph[prev, curr])\n        curr = prev\n    \n    path.reverse()\n    return path, path_flow\n    \ndef edmonds_karp(n, s, t, edges):\n    \"\"\"\n    Computes the maximum flow in a network using the Edmonds-Karp algorithm.\n    \"\"\"\n    # Build capacity matrix from the given edges.\n    capacity_matrix = build_capacity_matrix(n, edges)\n    \n    # Create a copy for the residual graph, which will be modified.\n    residual_graph = capacity_matrix.copy()\n    \n    max_flow = 0\n    while True:\n        path, path_flow = bfs_augmenting_path(n, s, t, residual_graph)\n        \n        if path_flow == 0:\n            break\n            \n        max_flow += path_flow\n        \n        # Update residual capacities\n        for u, v in path:\n            residual_graph[u, v] -= path_flow\n            residual_graph[v, u] += path_flow\n            \n    return max_flow\n\nsolve()\n```", "id": "3249860"}]}