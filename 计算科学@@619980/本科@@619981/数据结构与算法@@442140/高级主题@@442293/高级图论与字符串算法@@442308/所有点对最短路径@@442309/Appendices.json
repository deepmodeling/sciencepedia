{"hands_on_practices": [{"introduction": "理解任何算法的第一步都是亲手执行它。本练习将带你逐步完成Floyd-Warshall算法的核心迭代过程，通过手动更新距离矩阵，让你直观地感受动态规划是如何通过引入中间节点来逐步优化路径的。这个基础练习对于掌握算法的底层机制至关重要。[@problem_id:1504965]", "problem": "考虑一个有4个顶点的加权有向图，顶点标记为1、2、3和4。任意两个顶点之间的直接路径成本由一个初始距离矩阵 $D^{(0)}$ 给出。在此矩阵中，元素 $D^{(0)}_{ij}$ 表示从顶点 $i$到顶点 $j$ 的有向边的权重。如果从 $i$到 $j$不存在直接边，则权重被视为无穷大（$\\infty$）。对于所有顶点，自环距离 $D^{(0)}_{ii}$均为0。\n\n初始距离矩阵 $D^{(0)}$ 如下：\n$$ D^{(0)} = \\begin{pmatrix} 0  4  \\infty  7 \\\\ \\infty  0  1  \\infty \\\\ 6  \\infty  0  2 \\\\ 3  -2  \\infty  0 \\end{pmatrix} $$\n\nFloyd-Warshall算法通过迭代更新此矩阵来计算所有顶点对之间的最短路径。在第 $k$ 次迭代中（对于 $k=1, 2, \\dots, 4$），该算法考虑使用顶点 $k$作为中间顶点的路径，以期找到任意两个顶点 $i$ 和 $j$ 之间更短的路径。\n\n从给定的矩阵 $D^{(0)}$ 开始，执行Floyd-Warshall算法的前两次迭代，以计算矩阵 $D^{(1)}$ (使用 $k=1$) 和 $D^{(2)}$ (使用 $k=2$)。你的任务是确定第二次迭代后距离矩阵的最终状态 $D^{(2)}$。", "solution": "我们使用Floyd-Warshall更新规则：对于每次迭代 $k$以及所有的 $i,j$，\n$$\nD^{(k)}_{ij}=\\min\\left(D^{(k-1)}_{ij},\\,D^{(k-1)}_{ik}+D^{(k-1)}_{kj}\\right).\n$$\n给定\n$$\nD^{(0)}=\\begin{pmatrix}\n0  4  \\infty  7\\\\\n\\infty  0  1  \\infty\\\\\n6  \\infty  0  2\\\\\n3  -2  \\infty  0\n\\end{pmatrix},\n$$\n我们执行第一次迭代，令 $k=1$，使用 $D^{(1)}_{ij}=\\min\\left(D^{(0)}_{ij},\\,D^{(0)}_{i1}+D^{(0)}_{1j}\\right)$。\n\n对于 $i=1$：\n- $j=1$: $\\min(0,\\,0+0)=0$。\n- $j=2$: $\\min(4,\\,0+4)=4$。\n- $j=3$: $\\min(\\infty,\\,0+\\infty)=\\infty$。\n- $j=4$: $\\min(7,\\,0+7)=7$。\n\n对于 $i=2$ (由于 $D^{(0)}_{21}=\\infty$，所有经过1的路径均为 $\\infty$):\n- $j=1$: $\\min(\\infty,\\,\\infty)=\\infty$。\n- $j=2$: $\\min(0,\\,\\infty)=0$。\n- $j=3$: $\\min(1,\\,\\infty)=1$。\n- $j=4$: $\\min(\\infty,\\,\\infty)=\\infty$。\n\n对于 $i=3$ (其中 $D^{(0)}_{31}=6$):\n- $j=1$: $\\min(6,\\,6+0)=6$。\n- $j=2$: $\\min(\\infty,\\,6+4)=10$。\n- $j=3$: $\\min(0,\\,6+\\infty)=0$。\n- $j=4$: $\\min(2,\\,6+7)=2$。\n\n对于 $i=4$ (其中 $D^{(0)}_{41}=3$):\n- $j=1$: $\\min(3,\\,3+0)=3$。\n- $j=2$: $\\min(-2,\\,3+4)=-2$。\n- $j=3$: $\\min(\\infty,\\,3+\\infty)=\\infty$。\n- $j=4$: $\\min(0,\\,3+7)=0$。\n\n因此\n$$\nD^{(1)}=\\begin{pmatrix}\n0  4  \\infty  7\\\\\n\\infty  0  1  \\infty\\\\\n6  10  0  2\\\\\n3  -2  \\infty  0\n\\end{pmatrix}.\n$$\n\n接下来，执行第二次迭代，令 $k=2$，使用 $D^{(2)}_{ij}=\\min\\left(D^{(1)}_{ij},\\,D^{(1)}_{i2}+D^{(1)}_{2j}\\right)$。\n\n对于 $i=1$ (其中 $D^{(1)}_{12}=4$):\n- $j=1$: $\\min(0,\\,4+\\infty)=0$。\n- $j=2$: $\\min(4,\\,4+0)=4$。\n- $j=3$: $\\min(\\infty,\\,4+1)=5$。\n- $j=4$: $\\min(7,\\,4+\\infty)=7$。\n\n对于 $i=2$ (其中 $D^{(1)}_{22}=0$):\n- $j=1$: $\\min(\\infty,\\,0+\\infty)=\\infty$。\n- $j=2$: $\\min(0,\\,0+0)=0$。\n- $j=3$: $\\min(1,\\,0+1)=1$。\n- $j=4$: $\\min(\\infty,\\,0+\\infty)=\\infty$。\n\n对于 $i=3$ (其中 $D^{(1)}_{32}=10$):\n- $j=1$: $\\min(6,\\,10+\\infty)=6$。\n- $j=2$: $\\min(10,\\,10+0)=10$。\n- $j=3$: $\\min(0,\\,10+1)=0$。\n- $j=4$: $\\min(2,\\,10+\\infty)=2$。\n\n对于 $i=4$ (其中 $D^{(1)}_{42}=-2$):\n- $j=1$: $\\min(3,\\, -2+\\infty)=3$。\n- $j=2$: $\\min(-2,\\, -2+0)=-2$。\n- $j=3$: $\\min(\\infty,\\, -2+1)=-1$。\n- $j=4$: $\\min(0,\\, -2+\\infty)=0$。\n\n因此，第二次迭代后的矩阵是\n$$\nD^{(2)}=\\begin{pmatrix}\n0  4  5  7\\\\\n\\infty  0  1  \\infty\\\\\n6  10  0  2\\\\\n3  -2  -1  0\n\\end{pmatrix}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}0  4  5  7 \\\\ \\infty  0  1  \\infty \\\\ 6  10  0  2 \\\\ 3  -2  -1  0\\end{pmatrix}}$$", "id": "1504965"}, {"introduction": "计算所有点对之间的最短路径本身通常不是最终目的，而是解决更复杂的网络分析问题的基础。这个练习将Floyd-Warshall算法作为一个强大的工具，用于评估网络中每条边的“重要性”，即移除某条边会对整个网络的总通行成本产生多大影响。这项实践将理论算法与网络稳健性分析等实际应用联系起来。[@problem_id:3206137]", "problem": "给定一个网络集合，每个网络表示为一个有限、简单、无向、带非负边权的加权图。对于一个有 $n$ 个顶点的图，顶点被标记为 $0,1,\\dots,n-1$。我们感兴趣的量是所有顶点对之间的最短路径（All-Pairs Shortest Paths, APSP）的总和，定义如下。设 $\\operatorname{dist}_G(i,j)$ 表示图 $G$ 中顶点 $i$ 和 $j$ 之间的最短路径距离。如果 $i$ 和 $j$ 之间没有路径，则定义 $\\operatorname{dist}_G(i,j)=+\\infty$。将 APSP 总和定义为\n$$\nS(G) \\;=\\; \\sum_{0 \\le i  j  n} \\operatorname{dist}_G(i,j).\n$$\n对于图 $G$ 中的一条边 $e$，设 $G \\setminus e$ 表示移除边 $e$ 后得到的图（同时保持所有其他边不变）。将边 $e$ 相对于 APSP 总和的“重要性”（vitality）定义为\n$$\nV(e) \\;=\\; S(G \\setminus e) \\;-\\; S(G).\n$$\n您的任务是，对于每个给定的测试图，确定“最重要”边的索引，即在图中所有边中使 $V(e)$ 最大化的边 $e^\\star$。如果出现平局（多条边达到相同的最大重要性），则选择索引最小的边。\n\n边以三元组 $(u,v,w)$ 的形式给出，其中 $u$ 和 $v$ 是顶点索引，$w$ 是一个非负实数权重。保证图在初始时是连通的（即在移除任何边之前），但移除某些边可能会使图变得不连通。在这种情况下，相应的 $\\operatorname{dist}_{G\\setminus e}(i,j)$ 可能为 $+\\infty$，因此 $S(G\\setminus e)$ 和 $V(e)$ 也可能为 $+\\infty$。所有计算都是纯数学的，没有单位。\n\n使用任何正确的算法方法来确定 $S(G)$ 和 $S(G\\setminus e)$，该方法需与带非负权重的图中标准的最短路径定义一致。边的索引由其在给定列表中的位置定义，从 $0$ 开始。\n\n测试套件：\n- 测试用例 $1$：$n=3$，边（按索引顺序）\n  - 边 $0$：$(0,1,1)$\n  - 边 $1$：$(1,2,1)$\n  - 边 $2$：$(0,2,2)$\n- 测试用例 $2$：$n=4$，边（按索引顺序）\n  - 边 $0$：$(0,1,1)$\n  - 边 $1$：$(1,2,1)$\n  - 边 $2$：$(2,3,1)$\n- 测试用例 $3$：$n=4$，边（按索引顺序）\n  - 边 $0$：$(0,1,1)$\n  - 边 $1$：$(1,2,1)$\n  - 边 $2$：$(0,2,2)$\n  - 边 $3$：$(1,3,1)$\n  - 边 $4$：$(2,3,5)$\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。每个条目应是上面列出的相应测试用例的最重要边的整数索引。例如，输出必须类似于 $[r_1,r_2,r_3]$，其中 $r_k$ 是测试用例 $k$ 选定的边索引。", "solution": "用户提供的问题是有效的，因为它在图论领域有科学依据，问题定义明确，有唯一且有意义的解，并以客观、正式的语言表述。它提出了一个与网络敏感性分析相关的标准算法挑战。\n\n该问题要求在加权无向图中找到“最重要”的边。一条边 $e$ 的重要性（vitality），记为 $V(e)$，定义为移除 $e$ 后所有顶点对之间最短路径（APSP）总和的增量。\n设 $G=(V,E)$ 是一个有 $n$ 个顶点的图，顶点标记为 $0, 1, \\dots, n-1$。顶点 $i$ 和 $j$ 之间的最短路径距离是 $\\operatorname{dist}_G(i,j)$。APSP 总和为 $S(G) = \\sum_{0 \\le i  j  n} \\operatorname{dist}_G(i,j)$。边 $e \\in E$ 的重要性是 $V(e) = S(G \\setminus e) - S(G)$，其中 $G \\setminus e$ 是从图 $G$ 中移除边 $e$ 后的图。我们需要找到使 $V(e)$ 最大化的边 $e^\\star$ 的索引，若出现平局，则选择最小的边索引。\n\n问题的核心是计算 APSP 总和。由于图具有非负边权，Floyd-Warshall 算法是计算所有顶点对之间最短路径的合适方法。对于一个有 $n$ 个顶点的图，该算法的时间复杂度为 $O(n^3)$。\n\n整体算法流程如下：\n1.  使用邻接矩阵表示图，其中条目 $(i,j)$ 存储顶点 $i$ 和 $j$ 之间边的权重。如果不存在直接边，则初始距离为 $+\\infty$。任何顶点到其自身的距离为 $0$。\n2.  使用 Floyd-Warshall 算法计算原始图 $G$ 的所有顶点对之间最短路径距离矩阵。设该矩阵为 $D_G$。\n3.  从 $D_G$ 计算初始 APSP 总和，$S(G) = \\sum_{0 \\le i  j  n} D_G[i,j]$。\n4.  遍历图中的每条边 $e_k$，其中 $k$ 是边的索引。对于每条边：\n    a.  通过概念上移除边 $e_k$ 来构建图 $G_k = G \\setminus e_k$。这通过将邻接矩阵中相应的权重设置为 $+\\infty$ 来完成。\n    b.  在修改后的邻接矩阵上运行 Floyd-Warshall 算法，计算 $G_k$ 的所有顶点对之间最短路径距离矩阵，设为 $D_{G_k}$。\n    c.  计算新的 APSP 总和，$S(G_k) = \\sum_{0 \\le i  j  n} D_{G_k}[i,j]$。如果 $G_k$ 变得不连通，某些距离将为 $+\\infty$，因此 $S(G_k)$ 也将为 $+\\infty$。\n    d.  计算该边的重要性：$V(e_k) = S(G_k) - S(G)$。\n5.  记录找到的最大重要性以及相应边的索引。平局规则（最小索引）通过仅在找到严格更大的重要性时才更新最大值来自然处理。\n\n让我们将此过程应用于测试用例。\n\n**测试用例 1**：一个有 $n=3$ 个顶点和边 $e_0=(0,1,1)$、$e_1=(1,2,1)$ 和 $e_2=(0,2,2)$ 的图。\n- 原始图 $G$ 是一个三角形。最短路径距离为 $\\operatorname{dist}_G(0,1)=1$、$\\operatorname{dist}_G(1,2)=1$ 和 $\\operatorname{dist}_G(0,2)=\\min(2, 1+1)=2$。\n- APSP 总和为 $S(G) = 1 + 1 + 2 = 4$。\n- 移除 $e_0=(0,1,1)$：从 $0$ 到 $1$ 的路径改道为 $0-2-1$，距离为 $2+1=3$。其他距离保持不变。$S(G \\setminus e_0) = 3+1+2 = 6$。因此，$V(e_0)=6-4=2$。\n- 移除 $e_1=(1,2,1)$：从 $1$ 到 $2$ 的路径改道为 $1-0-2$，距离为 $1+2=3$。$S(G \\setminus e_1) = 1+3+2 = 6$。因此，$V(e_1)=6-4=2$。\n- 移除 $e_2=(0,2,2)$：从 $0$ 到 $2$ 的最短路径长度已经是 $2$（通过 $0-1-2$）。所以，$\\operatorname{dist}_{G\\setminus e_2}(0,2)=2$。距离没有变化。$S(G \\setminus e_2) = 4$。因此，$V(e_2)=4-4=0$。\n- 最大重要性为 $2$，由边 $e_0$ 和 $e_1$ 实现。平局规则选择索引最小的一个，即 $0$。\n\n**测试用例 2**：一个有 $n=4$ 个顶点和边 $e_0=(0,1,1)$、$e_1=(1,2,1)$ 和 $e_2=(2,3,1)$ 的图。这是一个路径图 $0-1-2-3$。\n- 初始 APSP 总和为 $S(G) = \\operatorname{dist}(0,1)+\\operatorname{dist}(0,2)+\\operatorname{dist}(0,3)+\\operatorname{dist}(1,2)+\\operatorname{dist}(1,3)+\\operatorname{dist}(2,3) = 1+2+3+1+2+1=10$。\n- 这个路径图中的每条边都是一个桥。移除其中任何一条都会使图不连通。\n- 移除 $e_0=(0,1,1)$ 会断开顶点 $0$。距离 $\\operatorname{dist}(0,1)$、$\\operatorname{dist}(0,2)$、$\\operatorname{dist}(0,3)$ 变为 $+\\infty$。因此 $S(G \\setminus e_0) = +\\infty$，且 $V(e_0)=+\\infty$。\n- 类似地，移除 $e_1=(1,2,1)$ 或 $e_2=(2,3,1)$ 也会使图不连通，导致 $V(e_1)=+\\infty$ 和 $V(e_2)=+\\infty$。\n- 所有三条边的重要性均为 $+\\infty$。平局规则选择索引最小的一个，即 $0$。\n\n**测试用例 3**：一个有 $n=4$ 个顶点和 5 条边的图。\n- 原始图 $G$：运行 Floyd-Warshall 算法后，我们找到距离矩阵并计算出 $S(G) = 9$。\n- 移除 $e_0=(0,1,1)$：几条路径被改道。例如，$(0,1)$ 的最短路径变为 $0-2-1$（长度为 $3$），$(0,3)$ 的最短路径变为 $0-2-1-3$（长度为 $4$）。总的变化量为 $4$。$V(e_0)=4$。\n- 移除 $e_1=(1,2,1)$：$(1,2)$ 的最短路径变为 $1-0-2$（长度为 $3$），$(2,3)$ 的最短路径变为 $2-0-1-3$（长度为 $4$）。总的变化量为 $4$。$V(e_1)=4$。\n- 移除 $e_2=(0,2,2)$：边 $(0,2)$ 的权重为 $2$，但存在一条备用路径 $0-1-2$，其长度为 $1+1=2$。移除这条边不会改变任何最短路径距离。$V(e_2)=0$。\n- 移除 $e_3=(1,3,1)$：这条边是几条最短路径的一部分。例如，$\\operatorname{dist}_G(1,3)=1$。移除后，新路径 $1-2-3$ 涉及权重为 $5$ 的直接边 $(2,3)$，路径长度为 $\\operatorname{dist}(1,2)+5=6$，但通过 $1-0-2-3$ 的路径 $\\operatorname{dist}(1,0)+\\operatorname{dist}(0,2)+\\operatorname{dist}(2,3)=1+2+5=8$ 更优——等一下，路径 $1-2-3$ 在 $G \\setminus e_3$ 中有一条新的最短路径。新的 $\\operatorname{dist}_{G \\setminus e_3}(2,3)$ 是 5。所以路径 $1-2-3$ 变为 $1+5=6$。通过 Floyd-Warshall 算法的详细重新计算显示，对 $(0,3)$、$(1,3)$ 和 $(2,3)$ 产生了变化，总变化量为 $13$。$V(e_3)=13$。\n- 移除 $e_4=(2,3,5)$：在图 $G$ 中，$2$ 和 $3$ 之间的最短路径是 $2-1-3$，长度为 $2$。边 $(2,3,5)$ 不在任何最短路径上。移除它对 APSP 总和没有影响。$V(e_4)=0$。\n- 最大重要性为 $13$，对应于边索引 $3$。\n\n最终结果为 $[0, 0, 3]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef floyd_warshall(n, edges):\n    \"\"\"\n    Computes all-pairs shortest paths using the Floyd-Warshall algorithm.\n\n    Args:\n        n (int): The number of vertices in the graph.\n        edges (list): A list of tuples (u, v, w) representing edges.\n\n    Returns:\n        numpy.ndarray: A 2D array representing the distance matrix.\n    \"\"\"\n    dist = np.full((n, n), np.inf, dtype=np.float64)\n    np.fill_diagonal(dist, 0)\n\n    for u, v, w in edges:\n        dist[u, v] = min(dist[u, v], w)\n        dist[v, u] = min(dist[v, u], w)\n\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dist[i, j] = min(dist[i, j], dist[i, k] + dist[k, j])\n    \n    return dist\n\ndef calculate_apsp_sum(dist_matrix):\n    \"\"\"\n    Calculates the sum of all-pairs shortest paths from a distance matrix.\n    The sum is over unique pairs (i, j) where i  j.\n\n    Args:\n        dist_matrix (numpy.ndarray): The all-pairs shortest path distance matrix.\n\n    Returns:\n        float: The sum of shortest path distances. Returns np.inf if any path is infinite.\n    \"\"\"\n    n = dist_matrix.shape[0]\n    total_sum = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += dist_matrix[i, j]\n    return total_sum\n\ndef find_most_vital_edge(n, edges):\n    \"\"\"\n    Finds the index of the most vital edge in a graph.\n\n    Args:\n        n (int): The number of vertices.\n        edges (list): A list of edge tuples (u, v, w).\n\n    Returns:\n        int: The index of the most vital edge.\n    \"\"\"\n    # Calculate APSP sum for the original graph\n    dist_G = floyd_warshall(n, edges)\n    S_G = calculate_apsp_sum(dist_G)\n\n    max_vitality = -1.0\n    best_edge_index = -1\n\n    for k in range(len(edges)):\n        # Create graph G \\ e_k by excluding the k-th edge\n        edges_k = [edge for i, edge in enumerate(edges) if i != k]\n        \n        # Calculate APSP sum for the modified graph\n        dist_Gk = floyd_warshall(n, edges_k)\n        S_Gk = calculate_apsp_sum(dist_Gk)\n        \n        vitality = S_Gk - S_G\n\n        if vitality  max_vitality:\n            max_vitality = vitality\n            best_edge_index = k\n            \n    return best_edge_index\n\ndef solve():\n    \"\"\"\n    Defines test cases and solves them, printing the final results.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 3,\n            \"edges\": [(0,1,1), (1,2,1), (0,2,2)]\n        },\n        {\n            \"n\": 4,\n            \"edges\": [(0,1,1), (1,2,1), (2,3,1)]\n        },\n        {\n            \"n\": 4,\n            \"edges\": [(0,1,1), (1,2,1), (0,2,2), (1,3,1), (2,3,5)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        edges = case[\"edges\"]\n        result = find_most_vital_edge(n, edges)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3206137"}, {"introduction": "现实世界的最短路径问题常常伴随着额外的约束条件，例如预算、时间或资源限制。这个练习挑战你扩展标准的最短路径算法，以解决一个带有限制（此处为“收费路段”数量）的路径规划问题。它旨在训练一种关键的算法设计思维：通过扩展问题的“状态”来将约束融入到动态规划或图搜索算法中。[@problem_id:3206273]", "problem": "考虑一个有向加权图 $G = (V,E)$，其中 $V = \\{0,1,\\dots,n-1\\}$（$n \\geq 1$ 为某个整数），$E \\subseteq V \\times V$ 是一个有向边集合。每条有向边 $(u,v) \\in E$ 都有一个关联的非负实数权重 $w(u,v) \\geq 0$ 和一个二元属性 $\\tau(u,v) \\in \\{0,1\\}$，该属性指示该边是收费路段（$\\tau(u,v) = 1$）还是非收费路段（$\\tau(u,v) = 0$）。对于任意顶点序对 $(u,v) \\in V \\times V$，从 $u$ 到 $v$ 的一条路径 $\\pi$ 是一个顶点序列 $(u = x_0, x_1, \\dots, x_m = v)$，使得对于所有满足 $0 \\leq i  m$ 的整数 $i$，都有 $(x_i, x_{i+1}) \\in E$。路径 $\\pi$ 的长度定义为权重之和 $\\sum_{i=0}^{m-1} w(x_i, x_{i+1})$，路径 $\\pi$ 的收费段计数定义为 $\\sum_{i=0}^{m-1} \\tau(x_i, x_{i+1})$。对于给定的非负整数 $k$，将受约束的所有点对最短路径距离 $d_k(u,v)$ 定义为从 $u$ 到 $v$ 的所有路径中，收费段计数至多为 $k$ 的那些路径的长度的下确界。如果不存在这样的路径，则定义 $d_k(u,v) = +\\infty$。\n\n您的任务是编写一个完整的、可运行的程序，为每个提供的测试用例计算受约束的所有点对最短路径距离矩阵 $D_k \\in \\mathbb{R}^{n \\times n}$，其中第 $i$ 行第 $j$ 列的条目等于 $d_k(i,j)$。该计算必须从基本原理出发，从路径的定义和最优化原理开始，并且必须能处理有向图、非负边权重以及收费段约束。在输出中，使用编程语言标准数值类型的浮点无穷大来表示 $+\\infty$。\n\n请使用以下测试套件，其中每个测试用例指定了 $(n, E, k)$ 和明确的边。每条边以四元组 $(u,v,w,\\tau)$ 的形式给出，其中 $u$ 和 $v$ 是 $\\{0,1,\\dots,n-1\\}$ 中的整数，$w$ 是一个非负实数权重，$\\tau \\in \\{0,1\\}$ 指示该边是否为收费路段。所有出现的数字都是精确且无单位的。\n\n测试用例 1（一般情况，混合收费段，中等约束）：\n- $n = 4$\n- $E = \\{(0,1,2,0), (1,2,3,1), (0,2,10,0), (2,3,1,0), (1,3,1,1), (0,3,100,0)\\}$\n- $k = 1$\n\n测试用例 2（边界情况，不允许收费段）：\n- $n = 4$\n- $E = \\{(0,1,2,0), (1,2,3,1), (0,2,10,0), (2,3,1,0), (1,3,1,1), (0,3,100,0)\\}$\n- $k = 0$\n\n测试用例 3（所有边都是收费段，收费预算有限，有向可达性边界情况）：\n- $n = 3$\n- $E = \\{(0,1,5,1), (1,2,5,1), (0,2,20,1)\\}$\n- $k = 1$\n\n测试用例 4（含混合收费段的有向环，较大约束）：\n- $n = 5$\n- $E = \\{(0,1,1,0), (1,2,1,1), (2,4,1,0), (0,3,10,0), (3,2,1,1), (1,3,2,0), (3,4,2,0), (4,1,1,1), (4,0,5,0)\\}$\n- $k = 3$\n\n您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表，其中每个元素是对应测试用例的 $n \\times n$ 距离矩阵 $D_k$，表示为浮点数的列表之列表，其中 $+\\infty$ 用语言的浮点无穷大表示。例如，输出格式应为 $[M_1,M_2,M_3,M_4]$ 的形式，其中每个 $M_t$ 是测试用例 $t$ 的矩阵。", "solution": "用户提供的问题是一个定义明确的受约束所有点对最短路径问题的实例。根据指定规则进行的验证过程确认，该问题具有科学依据、自成体系且客观。所有参数都得到了明确定义，其前提与图论和算法的既定原则相符。因此，该问题被认定为有效，并应给出正式解法。\n\n核心任务是为一个有向图 $G=(V,E)$（其中 $V=\\{0,1,\\dots,n-1\\}$）计算受约束的所有点对最短路径距离 $d_k(u,v)$。此距离是从顶点 $u$ 到顶点 $v$ 的所有路径中，总收费段计数至多为 $k$ 的那些路径的长度的下确界。路径的收费段计数是其所有边上的二元收费属性 $\\tau$ 之和，而长度则是非负权重 $w$ 之和。\n\n这个问题可以通过将其转换为一个增广图上的标准最短路径问题来解决，这是一种直接植根于最优化原理的技术。路径的状态不仅必须编码当前顶点，还必须编码已消耗的资源——在本例中，即已使用的收费段数量。\n\n我们来定义一个增广图 $G'=(V', E')$。\n顶点集合 $V'$ 是原始顶点集 $V$ 与可能的收费段计数组合 $\\{0, 1, \\dots, k\\}$ 的笛卡尔积。\n$$V' = V \\times \\{0, 1, \\dots, k\\}$$\n一个顶点 $(v,t) \\in V'$ 表示在遍历了一条总收费段计数恰好为 $t$ 的路径后到达顶点 $v \\in V$ 的状态。$V'$ 的大小为 $n \\cdot (k+1)$。\n\n边集合 $E'$ 是根据 $E$ 中的边构造的。对于 $E$ 中的每条边 $(u,v)$，其权重为 $w(u,v)$，收费属性为 $\\tau(u,v)$，我们在 $G'$ 中定义一组相应的边。$G$ 中从 $u$ 到 $v$ 的一条边允许从位于 $u$ 的某个状态转换到位于 $v$ 的某个状态。具体来说，如果我们当前位于顶点 $u$ 且已使用 $t$ 个收费段，遍历边 $(u,v)$ 会将我们带到顶点 $v$，新的收费段计数为 $t + \\tau(u,v)$。仅当新的收费段计数不超过预算 $k$ 时，此转换才有效。\n形式上，对于每条边 $(u,v) \\in E$ 和每个整数 $t \\in \\{0, 1, \\dots, k\\}$：\n如果 $t + \\tau(u,v) \\le k$，我们就在 $E'$ 中添加一条从顶点 $(u,t)$ 到顶点 $(v, t + \\tau(u,v))$ 的有向边，其权重为 $w(u,v)$。\n$$E' = \\{ ((u,t), (v, t+\\tau(u,v))) \\mid (u,v) \\in E, t \\in \\{0,\\dots,k\\}, t+\\tau(u,v) \\le k \\}$$\n$G'$ 中边 $((u,t), (v, t+\\tau(u,v)))$ 的权重定义为 $w(u,v)$。\n\n由于所有原始边权重 $w(u,v)$ 都是非负的，因此 $G'$ 中的所有边权重也都是非负的。这是一个关键属性，因为它允许应用像 Dijkstra 算法这样的高效最短路径算法。图 $G'$ 是一个有向图，如果原始图 $G$ 包含环，它也可能包含环。然而，$G'$ 中由对应于 $G$ 中收费边的边所形成的任何环，都会导致顶点收费段计数分量的增加，而非收费边形成的环则会使收费段计数分量保持不变。因此，状态空间的探索保证会终止。\n\n问题要求的是 $d_k(u,v)$，即从 $u$到 $v$ 使用*至多* $k$ 个收费段的最短路径。在图 $G$ 中，从 $u$ 出发的路径开始时已使用的收费段为 $0$。在增广图 $G'$ 中，这对应于从顶点 $(u,0)$ 开始。在 $G$ 中到 $v$ 的一条使用至多 $k$ 个收费段的路径，对应于 $G'$ 中从 $(u,0)$ 到任意顶点 $(v,t')$（其中 $t' \\in \\{0, 1, \\dots, k\\}$）的一条路径。这样一条最短路径的长度是从 $(u,0)$ 到这些可能的目标顶点中每一个的距离的最小值。\n设 $\\text{dist}_{G'}((a, t_a), (b, t_b))$ 为 $G'$ 中的最短路径距离。那么，受约束的距离 $d_k(u,v)$ 由下式给出：\n$$d_k(u,v) = \\min_{0 \\le t' \\le k} \\left\\{ \\text{dist}_{G'}((u,0), (v,t')) \\right\\}$$\n为了计算所有点对矩阵 $D_k$，我们必须为所有点对 $(u,v) \\in V \\times V$ 找到这些值。这可以通过对所有 $u \\in V$，从每个形如 $(u,0)$ 的源顶点在 $G'$ 上运行单源最短路径 (SSSP) 算法来实现。\n\n总的算法流程如下：\n1. 将一个 $n \\times n$ 的结果矩阵 $D_k$ 的所有条目初始化为 $+\\infty$，对角线上的条目初始化为 $0$。\n2. 对于每个起始顶点 $s \\in \\{0, 1, \\dots, n-1\\}$：\n    a. 我们需要找到从 $(s,0)$ 到 $G'$ 中所有其他顶点 $(v,t)$ 的最短路径距离。我们可以为此使用 Dijkstra 算法。\n    b. 初始化一个大小为 $n \\times (k+1)$ 的距离数组 $\\delta_s$ 为 $+\\infty$，表示从 $(s,0)$ 出发的已知最短距离。设置 $\\delta_s(s,0) = 0$。\n    c. 为 Dijkstra 算法使用一个优先队列，存储 (距离, 顶点, 收费段数) 的元组。初始时，它包含 $(0, s, 0)$。\n    d. 当优先队列非空时，提取具有最小距离 $d$ 的状态 $(d, u_{curr}, t_{curr})$。如果 $d > \\delta_s(u_{curr}, t_{curr})$，说明这是一个过时的条目，跳过它。\n    e. 对于每个出边 $(u_{curr}, v_{next}) \\in E$，其权重为 $w$，收费属性为 $\\tau$：\n        i. 计算新的收费段计数 $t_{next} = t_{curr} + \\tau$。\n        ii. 如果 $t_{next} \\le k$：\n            - 如果 $\\delta_s(u_{curr}, t_{curr}) + w  \\delta_s(v_{next}, t_{next})$，更新距离：$\\delta_s(v_{next}, t_{next}) = \\delta_s(u_{curr}, t_{curr}) + w$。\n            - 将 $(\\delta_s(v_{next}, t_{next}), v_{next}, t_{next})$ 添加到优先队列中。\n    f. Dijkstra 算法终止后，数组 $\\delta_s$ 包含从 $(s,0)$ 到所有可达状态 $(v,t)$ 的最短路径距离。\n    g. 对于每个目标顶点 $v \\in \\{0, 1, \\dots, n-1\\}$，计算最终结果矩阵的条目：\n       $$(D_k)_{sv} = \\min_{0 \\le t' \\le k} \\delta_s(v, t')$$\n3. 在遍历完所有起始顶点 $s \\in V$ 后，矩阵 $D_k$ 将被完全填充为受约束的所有点对最短路径距离。\n\n此方法是在扩展状态空间上对最优化原理的直接应用，并能正确解决给定问题。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases.\n    \"\"\"\n    \n    # Test case 1 (general case, mixed tolls, moderate constraint):\n    # n = 4, k = 1\n    # E = {(0,1,2,0), (1,2,3,1), (0,2,10,0), (2,3,1,0), (1,3,1,1), (0,3,100,0)}\n    test_case_1 = {\n        \"n\": 4,\n        \"k\": 1,\n        \"edges\": [(0,1,2,0), (1,2,3,1), (0,2,10,0), (2,3,1,0), (1,3,1,1), (0,3,100,0)]\n    }\n\n    # Test case 2 (boundary case, no tolls allowed):\n    # n = 4, k = 0\n    # E = {(0,1,2,0), (1,2,3,1), (0,2,10,0), (2,3,1,0), (1,3,1,1), (0,3,100,0)}\n    test_case_2 = {\n        \"n\": 4,\n        \"k\": 0,\n        \"edges\": [(0,1,2,0), (1,2,3,1), (0,2,10,0), (2,3,1,0), (1,3,1,1), (0,3,100,0)]\n    }\n\n    # Test case 3 (all edges are toll segments, limited toll budget, directed reachability edge cases):\n    # n = 3, k = 1\n    # E = {(0,1,5,1), (1,2,5,1), (0,2,20,1)}\n    test_case_3 = {\n        \"n\": 3,\n        \"k\": 1,\n        \"edges\": [(0,1,5,1), (1,2,5,1), (0,2,20,1)]\n    }\n\n    # Test case 4 (directed cycles with mixed tolls, larger constraint):\n    # n = 5, k = 3\n    # E = {(0,1,1,0), (1,2,1,1), (2,4,1,0), (0,3,10,0), (3,2,1,1), (1,3,2,0), (3,4,2,0), (4,1,1,1), (4,0,5,0)}\n    test_case_4 = {\n        \"n\": 5,\n        \"k\": 3,\n        \"edges\": [(0,1,1,0), (1,2,1,1), (2,4,1,0), (0,3,10,0), (3,2,1,1), (1,3,2,0), (3,4,2,0), (4,1,1,1), (4,0,5,0)]\n    }\n\n    test_cases = [test_case_1, test_case_2, test_case_3, test_case_4]\n    results = []\n\n    for case in test_cases:\n        n = case[\"n\"]\n        k = case[\"k\"]\n        edges = case[\"edges\"]\n        \n        # Adjacency list representation of the graph\n        adj = [[] for _ in range(n)]\n        for u, v, w, tau in edges:\n            adj[u].append((v, w, tau))\n\n        # The final n x n distance matrix for this test case\n        result_matrix = np.full((n, n), np.inf)\n\n        for start_node in range(n):\n            # dists[v][t]: shortest distance to vertex v using exactly t tolls\n            dists = np.full((n, k + 1), np.inf)\n            \n            # Priority queue for Dijkstra's algorithm\n            # (distance, vertex, tolls_used)\n            pq = [(0, start_node, 0)]\n            dists[start_node][0] = 0\n\n            while pq:\n                d, u, t = heapq.heappop(pq)\n\n                # If we found a shorter path already, skip\n                if d  dists[u][t]:\n                    continue\n\n                # Explore neighbors in the original graph\n                for v, w, tau in adj[u]:\n                    new_t = t + tau\n                    if new_t = k:\n                        if dists[u][t] + w  dists[v][new_t]:\n                            dists[v][new_t] = dists[u][t] + w\n                            heapq.heappush(pq, (dists[v][new_t], v, new_t))\n            \n            # For the current start_node, find the shortest path to all other nodes\n            # by taking the minimum over all possible toll counts up to k.\n            for end_node in range(n):\n                min_dist = np.min(dists[end_node, :])\n                result_matrix[start_node, end_node] = min_dist\n\n        results.append(result_matrix.tolist())\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists containing np.inf is 'inf'\n    # which is the standard representation for float('inf').\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3206273"}]}