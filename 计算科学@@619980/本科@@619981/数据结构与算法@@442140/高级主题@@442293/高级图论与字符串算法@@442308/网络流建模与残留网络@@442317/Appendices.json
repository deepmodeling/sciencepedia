{"hands_on_practices": [{"introduction": "网络流的整数性定理是一个基石，它保证了当所有容量为整数时，最大流值也为整数。这个练习将带你探索该定理的边界，通过引入一个非整数容量，你将分析网络瓶颈如何变化，并精确确定最大流值从整数变为非整数的临界条件。这有助于加深对最大流最小割定理以及容量变化对流值影响的理解。[@problem_id:3255308]", "problem": "一个有向网络有源点 $s$、汇点 $t$ 以及中间顶点 $a$ 和 $b$。所有现有边的容量都是整数：\n- 边 $s \\to b$ 的容量为 $1$。\n- 边 $a \\to t$ 的容量为 $5$。\n- 边 $b \\to t$ 的容量为 $10$。\n\n你可以添加一条新的有向边 $e = (s,a)$，其容量为 $c \\in \\mathbb{R}_{>0}$，其中 $c$ 可以是非整数。令 $f^{\\star}(c)$ 表示所得网络中最大 $s$–$t$ 流的流量值。\n\n仅使用 $s$–$t$ 割的核心定义、最大流最小割定理以及 Ford–Fulkerson 方法（通过残留网络）对于整数容量的经典整数性定理作为基础。从第一性原理推导出精确的最大实数 $T$，使得对于每个满足 $0  c \\leq T$ 的非整数 $c$，最大流流量值 $f^{\\star}(c)$ 都是非整数。然后报告 $T$ 的值。\n\n给出你的答案，要求是精确数（不要四舍五入）。", "solution": "本题将使用网络流理论的原理来解决，特别是最大流最小割定理。设给定的网络为 $G_c$，其顶点集为 $V = \\{s, a, b, t\\}$，其中 $s$ 是源点，$t$ 是汇点。边容量是参数 $c \\in \\mathbb{R}_{0}$ 的函数，具体如下：\n$C(s, b) = 1$\n$C(a, t) = 5$\n$C(b, t) = 10$\n$C(s, a) = c$\n所有其他边的容量假定为 $0$。我们关心的是从 $s$ 到 $t$ 的最大流流量值 $f^{\\star}(c)$。\n\n最大流最小割定理指出，网络中的最大流流量值等于任意 $s$–$t$ 割的最小容量。一个 $s$–$t$ 割是将顶点集 $V$ 划分为两个不相交的集合 $S$ 和 $T$ 的一种划分，使得 $s \\in S$ 且 $t \\in T$。一个割 $(S, T)$ 的容量是所有边 $(u, v)$（其中 $u \\in S$ 且 $v \\in T$）的容量之和。\n\n为了找到 $f^{\\star}(c)$，我们必须枚举网络 $G_c$ 中所有可能的 $s$–$t$ 割，并计算它们的容量。顶点 $s$ 和 $t$ 必须分别在集合 $S$ 和 $T$ 中。中间顶点 $a$ 和 $b$ 既可以在 $S$ 中也可以在 $T$ 中。这给出了 $2^2 = 4$ 种可能的 $s$–$t$ 割需要考虑。\n\n1.  **割 1**：$S_1 = \\{s\\}$，$T_1 = \\{a, b, t\\}$。\n    从 $S_1$ 到 $T_1$ 的边是 $(s, a)$ 和 $(s, b)$。\n    这个割的容量是 $C(S_1, T_1) = C(s, a) + C(s, b) = c + 1$。\n\n2.  **割 2**：$S_2 = \\{s, a\\}$，$T_2 = \\{b, t\\}$。\n    从 $S_2$ 到 $T_2$ 的边是 $(s, b)$ 和 $(a, t)$。在计算简单割容量时，没有从 $T_2$ 到 $S_2$ 的边需要考虑。边 $(s,a)$ 完全在 $S_2$ 内部。\n    这个割的容量是 $C(S_2, T_2) = C(s, b) + C(a, t) = 1 + 5 = 6$。\n\n3.  **割 3**：$S_3 = \\{s, b\\}$，$T_3 = \\{a, t\\}$。\n    从 $S_3$ 到 $T_3$ 的边是 $(s, a)$ 和 $(b, t)$。边 $(s,b)$ 在 $S_3$ 内部。\n    这个割的容量是 $C(S_3, T_3) = C(s, a) + C(b, t) = c + 10$。\n\n4.  **割 4**：$S_4 = \\{s, a, b\\}$，$T_4 = \\{t\\}$。\n    从 $S_4$ 到 $T_4$ 的边是 $(a, t)$ 和 $(b, t)$。\n    这个割的容量是 $C(S_4, T_4) = C(a, t) + C(b, t) = 5 + 10 = 15$。\n\n根据最大流最小割定理，最大流流量值 $f^{\\star}(c)$ 是这些割容量中的最小值：\n$$f^{\\star}(c) = \\min(c + 1, 6, c + 10, 15)$$\n因为 $c  0$，所以 $c + 10  c + 1$ 恒成立。此外，$15  6$。因此，$f^{\\star}(c)$ 的表达式可以简化为：\n$$f^{\\star}(c) = \\min(c + 1, 6)$$\n这将 $f^{\\star}(c)$ 定义为关于 $c$ 的分段函数。当 $c + 1 = 6$ 时，函数的行为发生改变，这发生在 $c = 5$ 时。\n\n-   **情况一：$0  c \\leq 5$**\n    在这个区间内，$c + 1 \\leq 6$，所以最小值是 $c + 1$。\n    $$f^{\\star}(c) = c + 1$$\n    问题要求的是对于每个非整数 $c$，$f^{\\star}(c)$ 都是非整数的条件。如果 $c$ 是一个非整数，那么 $c+1$ 也是一个非整数。（反证法：如果对于某个整数 $k$ 有 $c+1=k$，那么 $c=k-1$，这将是一个整数，与假设矛盾。）因此，对于区间 $(0, 5]$ 中的所有非整数 $c$，最大流流量值 $f^{\\star}(c)$ 都是非整数。\n\n-   **情况二：$c  5$**\n    在这个区间内，$c + 1  6$，所以最小值是 $6$。\n    $$f^{\\star}(c) = 6$$\n    在这种情况下，无论 $c$ 是否为整数，最大流流量值总是整数 $6$。对于任何大于 5 的非整数 $c$（例如，$c=5.5$），最大流 $f^{\\star}(5.5) = 6$ 是一个整数。\n\n问题要求找到最大的实数 $T$，使得对于每个满足 $0  c \\leq T$ 的非整数 $c$，值 $f^{\\star}(c)$ 都是非整数。\n\n根据我们的分析：\n-   对于区间 $(0, 5]$，任何非整数 $c$ 都会产生一个非整数的流值 $f^{\\star}(c) = c+1$。点 $c=5$ 本身是一个整数，所以它不属于“每个非整数 $c$”这一条件的讨论范围。因此，任何 $T \\leq 5$ 都将满足该性质。\n\n-   考虑任何大于 5 的值 $T$。例如，设 $T = 5 + \\epsilon$，其中 $\\epsilon  0$。该区间是 $(0, 5+\\epsilon]$。我们可以在这个区间内选择一个非整数 $c_0$，使得 $5  c_0 \\leq 5+\\epsilon$。例如，$c_0 = 5 + \\epsilon/2$。对于这个 $c_0$，$f^{\\star}(c_0) = 6$，这是一个整数。这违反了题目要求的条件，即对于区间内的*每一个*非整数 `c`，流都是非整数。\n\n因此，没有大于 5 的 $T$ 值能满足该条件。$T$ 的最大可能值为 $5$。\n\n网络流的整数性定理指出，如果所有容量都是整数，那么最大流流量值也是整数。在这里，当 $c  5$ 时，最小割由具有整数容量的边决定，即 $C(s,b)=1$ 和 $C(a,t)=5$。尽管网络包含一个非整数容量 $c$，但它不是瓶颈，最大流流量值最终为一个整数。当 $0  c \\leq 5$ 时，具有非整数容量 $c$ 的边是瓶颈割的一部分，这迫使最大流流量值本身也为非整数。过渡点恰好是两个竞争的割容量相等的地方，即 $c+1=6$，也就是在 $c=5$ 处。\n\n满足该条件的最大实数 $T$ 是 $5$。", "answer": "$$\\boxed{5}$$", "id": "3255308"}, {"introduction": "网络流的强大之处在于其广泛的建模能力，它能解决许多看似无关的问题。本练习将介绍一种核心建模技术——节点分裂，它能将“点不相交路径”问题转化为标准的最大流问题。通过这个练习，你将学会如何通过巧妙的图变换来约束单个节点的使用次数，从而将节点容量的概念融入到流网络中。[@problem_id:3255356]", "problem": "考虑一个有向图 $G = (V, E)$，其顶点集为 $V = \\{s, t, a, b, c, d, p, q, r, x, y, z\\}$，边集 $E$ 由以下有向边组成：$(s, a)$, $(s, b)$, $(s, c)$, $(s, d)$, $(a, p)$, $(a, q)$, $(a, r)$, $(b, p)$, $(b, q)$, $(b, r)$, $(c, p)$, $(c, q)$, $(c, r)$, $(d, p)$, $(d, q)$, $(d, r)$, $(p, x)$, $(p, y)$, $(q, y)$, $(q, z)$, $(r, x)$, $(r, z)$, $(x, t)$, $(y, t)$, $(z, t)$。您将通过标准的节点分裂构造法将 $G$ 转换为一个流网络 $G'$，以实现 $s$-$t$ 路径的内部顶点不相交性：对于每个内部顶点 $v \\in V \\setminus \\{s, t\\}$，用两个由有向边 $(v^{\\mathrm{in}}, v^{\\mathrm{out}})$ 连接的顶点 $v^{\\mathrm{in}}$ 和 $v^{\\mathrm{out}}$ 替换 $v$，该边的容量为 $1$。对于每条原始边 $(u, v) \\in E$，在 $G'$ 中添加一条容量为 $\\infty$ 的有向边 $(u^{\\mathrm{out}}, v^{\\mathrm{in}})$。源点 $s$ 和汇点 $t$ 不进行分裂；与 $s$ 或 $t$ 相关的边分别变为 $(s, v^{\\mathrm{in}})$ 和 $(u^{\\mathrm{out}}, t)$，每条边的容量均为 $\\infty$。使用此构造法，通过在 $G'$ 中找到最大 $s$-$t$ 流量值来建模并计算两两内部顶点不相交的 $s$-$t$ 路径的最大数量。请将您的最终答案表示为单个整数。无需四舍五入，也不涉及物理单位。", "solution": "用户希望按照以下步骤解决问题：\n1.  验证问题陈述是否有效。\n2.  如果有效，则继续进行解答。\n3.  如果无效，则说明原因并终止。\n\n### 步骤 1：提取已知信息\n-   **图：** 一个有向图 $G = (V, E)$。\n-   **顶点集：** $V = \\{s, t, a, b, c, d, p, q, r, x, y, z\\}$。源点是 $s$，汇点是 $t$。\n-   **边集：** $E = \\{(s, a), (s, b), (s, c), (s, d)\\} \\cup \\{(u, v) \\mid u \\in \\{a, b, c, d\\}, v \\in \\{p, q, r\\}\\} \\cup \\{(p, x), (p, y), (q, y), (q, z), (r, x), (r, z)\\} \\cup \\{(x, t), (y, t), (z, t)\\}$.\n-   **转换为流网络 $G'$：**\n    -   对于每个内部顶点 $v \\in V \\setminus \\{s, t\\}$，用两个顶点 $v^{\\mathrm{in}}$ 和 $v^{\\mathrm{out}}$ 替换 $v$，并添加一条有向边 $(v^{\\mathrm{in}}, v^{\\mathrm{out}})$，其容量 $c(v^{\\mathrm{in}}, v^{\\mathrm{out}}) = 1$。\n    -   对于每条原始边 $(u, v) \\in E$，其中 $u, v \\in V \\setminus \\{s, t\\}$，在 $G'$ 中添加一条有向边 $(u^{\\mathrm{out}}, v^{\\mathrm{in}})$，其容量 $c(u^{\\mathrm{out}}, v^{\\mathrm{in}}) = \\infty$。\n    -   对于一条边 $(s, v) \\in E$，在 $G'$ 中添加一条边 $(s, v^{\\mathrm{in}})$，其容量 $c(s, v^{\\mathrm{in}}) = \\infty$。\n    -   对于一条边 $(u, t) \\in E$，在 $G'$ 中添加一条边 $(u^{\\mathrm{out}}, t)$，其容量 $c(u^{\\mathrm{out}}, t) = \\infty$。\n-   **目标：** 通过在构造的网络 $G'$ 中找到最大 $s-t$ 流量值，计算 $G$ 中两两内部顶点不相交的 $s-t$ 路径的最大数量。\n\n### 步骤 2：使用提取的已知信息进行验证\n-   **科学依据：** 该问题基于图论和网络流算法的基本概念。通过节点分裂将内部顶点不相交路径与最大流联系起来，是一个标准且成熟的结论，通常作为 Menger 定理和最大流最小割定理的推论出现。该问题在科学上是合理的。\n-   **良构性：** 图 $G$ 的定义明确无歧义。流网络 $G'$ 的构造是精确的。目标是明确的：计算最大流量值。存在唯一解。该问题是良构的。\n-   **客观性：** 问题使用形式化的数学语言陈述，没有任何主观性或歧义。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整的解答。\n\n问题要求在给定的有向图 $G$ 中，从源点 $s$ 到汇点 $t$ 的两两内部顶点不相交路径的最大数量。问题指定了使用的方法：标准的节点分裂构造法创建一个流网络 $G'$，然后计算最大流。$G'$ 中的最大流量值将等于 $G$ 中此类路径的数量。这是最大流最小割定理与关于顶点连通性的 Menger 定理的直接应用。\n\n网络中的最大流量值等于一个 $s-t$ 割的最小容量。一个 $s-t$ 割是将 $G'$ 的顶点划分为两个集合 $S$ 和 $T$，使得 $s \\in S$ 且 $t \\in T$。割 $(S, T)$ 的容量是所有边 $(u, v)$ (其中 $u \\in S$ 且 $v \\in T$) 的容量之和。\n\n让我们分析图 $G$ 的结构。内部顶点的集合可以划分为三个连续的层：\n- 第 1 层：$L_1 = \\{a, b, c, d\\}$\n- 第 2 层：$L_2 = \\{p, q, r\\}$\n- 第 3 层：$L_3 = \\{x, y, z\\}$\n\n每条从 $s$ 到 $t$ 的路径都必须先经过 $L_1$ 中的一个顶点，然后是 $L_2$ 中的一个顶点，最后是 $L_3$ 中的一个顶点。一个内部顶点的集合，其移除会断开所有从 $s$ 到 $t$ 的路径，被称为一个 $s-t$ 顶点割。这种割的最小规模给出了内部顶点不相交路径的最大数量。\n\n集合 $L_2$ 和 $L_3$ 本身就是 $s-t$ 顶点割。\n$L_1$ 的大小是 $|L_1| = 4$。\n$L_2$ 的大小是 $|L_2| = 3$。\n$L_3$ 的大小是 $|L_3| = 3$。\n\n这些基于层的割的最小规模是 $3$。这表明最小顶点割的大小最多为 $3$。让我们通过在流网络 $G'$ 中构造一个相应的 $s-t$ 割来形式化这一点。\n\n考虑 $G$ 中的顶点割 $L_2 = \\{p, q, r\\}$。我们可以在 $G'$ 中定义一个 $s-t$ 割 $(S, T)$ 如下：\n- 令 $S = \\{s\\} \\cup \\{v^{\\mathrm{in}}, v^{\\mathrm{out}} \\mid v \\in L_1\\} \\cup \\{v^{\\mathrm{in}} \\mid v \\in L_2\\}$。\n- 令 $T$ 为 $G'$ 中所有其他顶点的集合，因此 $t \\in T$。\n\n从 $S$ 到 $T$ 的边有：\n1.  形如 $(v^{\\mathrm{in}}, v^{\\mathrm{out}})$ 的边：\n对于 $v \\in L_2 = \\{p, q, r\\}$，我们有 $v^{\\mathrm{in}} \\in S$ 和 $v^{\\mathrm{out}} \\in T$。这三条边，$(p^{\\mathrm{in}}, p^{\\mathrm{out}})$、$(q^{\\mathrm{in}}, q^{\\mathrm{out}})$ 和 $(r^{\\mathrm{in}}, r^{\\mathrm{out}})$，跨越了该割。每条边的容量为 $1$。来自这些边的总容量是 $1+1+1=3$。\n\n2.  对应于 $E$ 中原始边的边（容量为 $\\infty$）：\n任何从 $S$ 到 $T$ 的此类边 $(u,v)$ 都会使割的容量为无穷大。我们必须验证不存在这样的边。\n- $(s, v^{\\mathrm{in}})$ 对于 $v \\in L_1$：$s \\in S, v^{\\mathrm{in}} \\in S$。不跨越。\n- $(u^{\\mathrm{out}}, v^{\\mathrm{in}})$ 对于 $u \\in L_1, v \\in L_2$：$u^{\\mathrm{out}} \\in S, v^{\\mathrm{in}} \\in S$。不跨越。\n- 所有其他容量为无穷大的边（例如，对于 $u \\in L_2, v \\in L_3$ 的 $(u^{\\mathrm{out}}, v^{\\mathrm{in}})$）要么两个端点都在 $T$ 中，要么不存在。例如，对于像 $(p^{\\mathrm{out}}, x^{\\mathrm{in}})$ 这样的边，$p^{\\mathrm{out}} \\in T$ 且 $x^{\\mathrm{in}} \\in T$。它不从 $S$ 跨越到 $T$。\n\n这个割 $(S,T)$ 的总容量恰好是 $3$。根据最大流最小割定理，最大流量值小于或等于任何割的容量，所以 $f_{\\max} \\le 3$。\n\n现在，我们需要为最大流建立一个下界。我们可以通过在 $G$ 中找到一组内部顶点不相交的路径来做到这一点。如果我们找到 $k$ 条这样的路径，那么最大流必须至少为 $k$。让我们尝试找到 $3$ 条这样的路径。\n考虑以下三条路径：\n- 路径 1：$s \\to a \\to p \\to x \\to t$。内部顶点集是 $P_1 = \\{a, p, x\\}$。\n- 路径 2：$s \\to b \\to q \\to y \\to t$。内部顶点集是 $P_2 = \\{b, q, y\\}$。\n- 路径 3：$s \\to c \\to r \\to z \\to t$。内部顶点集是 $P_3 = \\{c, r, z\\}$。\n\n我们必须验证这些路径是有效的（即，边存在）并且它们是内部顶点不相交的。\n- 边 $(s,a)$, $(s,b)$, $(s,c)$ 存在。\n- 边 $(a,p)$, $(b,q)$, $(c,r)$ 存在，因为在 $\\{a,b,c,d\\}$ 和 $\\{p,q,r\\}$ 之间存在一个完全二分图。\n- 根据问题描述，边 $(p,x)$, $(q,y)$, $(r,z)$ 存在。\n- 边 $(x,t)$, $(y,t)$, $(z,t)$ 存在。\n所有路径都是有效的。\n\n内部顶点集分别是 $P_1 = \\{a, p, x\\}$，$P_2 = \\{b, q, y\\}$ 和 $P_3 = \\{c, r, z\\}$。这些集合是不相交的：$P_1 \\cap P_2 = \\emptyset$，$P_1 \\cap P_3 = \\emptyset$ 和 $P_2 \\cap P_3 = \\emptyset$。因此，这三条路径是两两内部顶点不相交的。\n\n存在 $3$ 条内部顶点不相交的路径意味着此类路径的最大数量至少为 $3$。在流网络 $G'$ 中，这对应于一个值为 $3$ 的流。因此，$f_{\\max} \\ge 3$。\n\n结合这两个结果：\n- 从最小割分析，我们得到 $f_{\\max} \\le 3$。\n- 从路径构造，我们得到 $f_{\\max} \\ge 3$。\n\n因此，最大流量值必须恰好是 $3$。这个值代表了两两内部顶点不相交的 $s-t$ 路径的最大数量。", "answer": "$$\\boxed{3}$$", "id": "3255356"}, {"introduction": "在实际应用中，我们常常需要评估网络中各个组件的重要性。这个练习将最大流算法作为一个强大的分析工具，用于量化网络中节点的重要性。你需要设计一个算法，通过系统性地移除节点并重新计算最大流，来找到对网络连通性影响最大的“关键节点”。这个过程能够锻炼你将基础算法应用于解决更复杂问题的能力。[@problem_id:3255325]", "problem": "给定一个有向网络，其边具有非负整数容量，并有一个指定的源顶点和一个指定的汇顶点。该网络表示为一个有限有向图，其顶点集为 $\\{0,1,2,\\dots,n-1\\}$，并含有一组有向边，其中每条有向边 $(u,v)$ 都有一个关联的容量 $c(u,v)$，该容量为正整数。一个可行流是定义在有向边上的函数 $f(u,v)$，它满足每条有向边 $(u,v)$ 的容量约束 $0 \\le f(u,v) \\le c(u,v)$，以及对于除指定源点 $s$ 和指定汇点 $t$ 之外的每个顶点 $u$，都满足流量守恒约束 $\\sum_{(x,u)} f(x,u) = \\sum_{(u,y)} f(u,y)$。一个可行流的值是从源点流出的净流量，即 $\\sum_{(s,y)} f(s,y) - \\sum_{(x,s)} f(x,s)$。最大流问题的目标是确定从 $s$ 到 $t$ 的可行流可能的最大值。\n\n关于一个可行流 $f$ 的残留网络是基于相同顶点集的有向图，其中每条有向边 $(u,v)$ 的残留容量为 $c_f(u,v) = c(u,v) - f(u,v)$，并且对于每条原始边 $(u,v)$，也存在一条残留容量为 $c_f(v,u) = f(u,v)$ 的反向边 $(v,u)$。一条增广路径是在残留网络中从 $s$到 $t$ 的一条有向路径，其上每条边的残留容量都严格为正。一个经过充分检验的事实是，当不存在增广路径时，当前流即为最大流。最大流最小割定理确保了最大流的值等于最小 $s$-$t$ 割的容量。\n\n定义“最有价值”的顶点为任意一个顶点 $v \\in \\{0,1,\\dots,n-1\\} \\setminus \\{s,t\\}$，移除该顶点（删除该顶点及其所有邻接边）会导致最大 $s$-$t$ 流量值出现最大程度的下降，该下降量以 $\\Delta(v) = \\operatorname{maxflow}(G) - \\operatorname{maxflow}(G \\setminus \\{v\\})$ 来衡量。如果多个顶点达到相同的最大下降量，则选择索引最小的那个。如果没有可移除的顶点（即网络只有两个顶点 $s$ 和 $t$），则将答案定义为序对 $[-1,0]$。\n\n你的任务是编写一个完整、可运行的程序，为每个给定的测试用例计算一个二元列表 $[v^\\star,\\Delta^\\star]$，其中 $v^\\star$ 是最有价值顶点的索引（根据平局决胜规则），$\\Delta^\\star$ 是对应的最大流量下降值。你必须使用基于上述基本定义的、以残留网络为基础的算法来确定最大流。程序不得接受任何输入，并且必须将所有测试用例的聚合结果打印为单行，格式为一个用方括号括起来的逗号分隔列表，其中每个测试用例的结果本身就是一个二元列表 $[v^\\star,\\Delta^\\star]$。例如，整体输出应类似于一个列表的列表，如 $[ [a,b], [c,d], [e,f] ]$。\n\n解释细节和要求：\n- 顶点由 $\\{0,1,\\dots,n-1\\}$ 中的整数标记。\n- 图是有向的。允许在同一有序顶点对之间存在多条边，并应将它们视为不同的平行边。\n- 移除顶点 $v$ 意味着删除 $v$ 以及所有边 $(v, \\cdot)$ 和 $(\\cdot, v)$，然后在剩余顶点构成的图中重新计算从 $s$ 到 $t$ 的最大流。\n- 只有 $v \\notin \\{s,t\\}$ 的顶点被视为可移除的候选顶点。\n- 如果没有候选顶点（即顶点集恰好为 $\\{s,t\\}$），则对该测试用例输出 $[-1,0]$。\n\n需要实现和求解的测试套件：\n对于每个测试用例，实例由 $(n, s, t, \\text{Edges})$ 给出，其中 $\\text{Edges}$ 是一个三元组 $(u,v,c)$ 的列表。\n\n- Case $1$: $n=4$, $s=0$, $t=3$, $\\text{Edges} = \\{(0,1,3), (1,3,3), (0,2,2), (2,3,2)\\}$。\n- Case $2$: $n=4$, $s=0$, $t=3$, $\\text{Edges} = \\{(0,1,2), (1,3,2), (0,2,2), (2,3,2)\\}$。\n- Case $3$: $n=5$, $s=0$, $t=4$, $\\text{Edges} = \\{(0,1,5), (1,3,1), (3,4,5), (0,2,5), (2,3,1)\\}$。\n- Case $4$: $n=2$, $s=0$, $t=1$, $\\text{Edges} = \\{(0,1,7)\\}$。\n- Case $5$: $n=6$, $s=0$, $t=5$, $\\text{Edges} = \\{(0,1,10), (1,2,1), (2,5,10), (0,3,10), (3,4,1), (4,5,10), (1,3,10), (2,4,10)\\}$。\n\n最终输出格式规范：\n- 你的程序必须精确地产生一行输出，包含所有结果的组合，形式为单个列表，其中每个元素是对应测试用例的二元列表 $[v^\\star,\\Delta^\\star]$，顺序与上述案例顺序一致。\n- 不要打印任何其他文本。输出必须是包含单个列表的单行。例如，形如 $[[a,b],[c,d],[e,f]]$ 的语法形式是可接受的。", "solution": "用户提供了一个问题，要求在有向网络中找到“最有价值”的顶点。顶点的价值由移除该顶点后最大 $s$-$t$ 流量的下降幅度定义。这个问题根植于网络流的经典理论。\n\n### 问题验证\n问题陈述已经过验证，被确定为一个定义明确、有科学依据且客观的算法任务。\n\n1.  **已知条件**：问题提供了网络流问题所需的所有必要定义：一个有向图 $G$，其顶点集为 $\\{0, 1, \\dots, n-1\\}$，一个源点 $s$，一个汇点 $t$，以及边上的非负整数容量 $c(u,v)$。它定义了可行流 $f(u,v)$、流的值、残留网络 $G_f$ 的概念以及增广路径。它引入了“最有价值”顶点 $v^\\star$ 的定义，即 $v^\\star \\notin \\{s,t\\}$ 且能最大化流量下降量 $\\Delta(v) = \\operatorname{maxflow}(G) - \\operatorname{maxflow}(G \\setminus \\{v\\})$。问题还指定了平局决胜规则（最小索引）和一个基础情况（对于仅有两个顶点 $s$ 和 $t$ 的网络）。此外，提供了一套包含5个测试用例的测试套件。\n\n2.  **验证**：\n    -   **科学依据**：该问题建立在网络流理论的基础原则之上，包括最大流最小割定理。所有定义都是标准且正确的。\n    -   **良构性**：目标是找到一个特定的顶点 $v^\\star$ 和相应的流量下降量 $\\Delta^\\star$。最大流的存在性是有保证的。使用整数容量确保了像 Edmonds-Karp 这样的标准算法将终止并得到一个整数值的最大流。指定的平局决胜规则保证了 $v^\\star$ 的唯一解。\n    -   **客观性与完整性**：问题以精确、正式的语言陈述。为每个测试用例提供了所有必要的数据和约束。\n\n3.  **结论**：该问题是有效的，可以构建解决方案。\n\n### 基于原则的解决方案设计\n\n问题的核心是多次计算网络中的最大流：一次是为原始图计算，然后对每个移除了一个候选顶点的图变体再分别计算一次。\n\n**1. 最大流算法**\n\n最大流将使用 Edmonds-Karp 算法计算，该算法是 Ford-Fulkerson 方法的一种实现。此算法的原理是在残留网络中寻找增广路径。\n\n-   **残留网络**：给定一个流 $f$，前向边 $(u,v)$ 的残留容量为 $c_f(u,v) = c(u,v) - f(u,v)$，并引入一条容量为 $c_f(v,u) = f(u,v)$ 的反向边 $(v,u)$。\n-   **增广路径搜索**：Edmonds-Karp 算法采用广度优先搜索 (BFS) 来寻找从源点 $s$ 到汇点 $t$ 的增广路径。如果一条路径上的每条边都具有严格为正的残留容量，则该路径是“增广的”。使用 BFS 是因为它能找到边数最少的路径，这保证了算法的终止性。\n-   **流量增广**：一旦找到增广路径，流就增加该路径的瓶颈容量，即其上各边残留容量的最小值。然后相应地更新残留容量：前向边的残留容量减少，反向边的残留容量增加。\n-   **终止条件**：重复寻找增广路径和增加流量的过程，直到在残留网络中再也找不到从 $s$ 到 $t$ 的增广路径为止。根据最大流最小割定理，得到的流是最大的。\n\n**2. 寻找最有价值的顶点**\n\n对于每个测试用例 $(n, s, t, \\text{Edges})$，整体算法流程如下：\n\n-   **步骤 1：基础情况检查**：如果顶点数 $n$ 为 $2$（或更少），则没有可移除的顶点（即除 $s$ 和 $t$ 之外的顶点）。根据问题规范，此情况的结果为 $[-1, 0]$。\n\n-   **步骤 2：计算初始最大流**：首先，为原始图 $G$ 构建容量矩阵。对于平行的边 $(u,v)$，其容量为 $c_1, c_2, \\dots$，通过将它们的容量相加成一个条目 $c(u,v) = \\sum c_i$ 来处理。然后，使用 Edmonds-Karp 算法计算该图的最大流 $\\operatorname{maxflow}(G)$。\n\n-   **步骤 3：迭代并评估候选顶点**：\n    -   确定可移除的候选顶点集，$V' = \\{v \\in \\{0, \\dots, n-1\\} \\mid v \\ne s \\text{ and } v \\ne t\\}$。\n    -   初始化找到的最佳顶点 $v^\\star$ 和最大下降量 $\\Delta^\\star$。一个合理的初始化是 $v^\\star = -1$ 和 $\\Delta^\\star = -\\infty$。\n    -   按索引递增的顺序遍历每个候选顶点 $v \\in V'$。此顺序对于正确应用平局决胜规则至关重要。\n    -   对于每个 $v$，通过移除 $v$ 及其所有邻接边来构建图 $G \\setminus \\{v\\}$。这等效于从原始边列表中构建一个新的容量矩阵，排除任何以 $v$ 为起点或终点的边。\n    -   计算这个修改后图的最大流 $\\operatorname{maxflow}(G \\setminus \\{v\\})$。\n    -   计算流量下降量：$\\Delta(v) = \\operatorname{maxflow}(G) - \\operatorname{maxflow}(G \\setminus \\{v\\})$。\n    -   将 $\\Delta(v)$ 与当前最大下降量 $\\Delta^\\star$进行比较。如果 $\\Delta(v)  \\Delta^\\star$，则更新 $\\Delta^\\star = \\Delta(v)$ 和 $v^\\star = v$。因为我们是按索引递增的顺序遍历顶点，所以第一个达到新的最大下降量的顶点，在所有达到相同下降量的顶点中索引是最小的。因此，如果 $\\Delta(v) = \\Delta^\\star$，我们不进行更新。\n\n-   **步骤 4：最终结果**：遍历完所有候选顶点后，序对 $[v^\\star, \\Delta^\\star]$ 即为该测试用例的结果。\n\n### 测试用例分析\n\n-   **Case 1**: $n=4, s=0, t=3, E=\\{(0,1,3), (1,3,3), (0,2,2), (2,3,2)\\}$。\n    -   网络有两条不相交的路径：$0 \\to 1 \\to 3$（容量 3）和 $0 \\to 2 \\to 3$（容量 2）。\n    -   $\\operatorname{maxflow}(G) = 3 + 2 = 5$。\n    -   可移除的顶点：$\\{1, 2\\}$。\n    -   移除 $v=1$：路径 $0 \\to 1 \\to 3$ 被移除。$\\operatorname{maxflow}(G \\setminus \\{1\\}) = 2$。$\\Delta(1) = 5 - 2 = 3$。\n    -   移除 $v=2$：路径 $0 \\to 2 \\to 3$ 被移除。$\\operatorname{maxflow}(G \\setminus \\{2\\}) = 3$。$\\Delta(2) = 5 - 3 = 2$。\n    -   最大下降量为 $3$，由移除顶点 $1$ 产生。结果：$[1, 3]$。\n\n-   **Case 2**: $n=4, s=0, t=3, E=\\{(0,1,2), (1,3,2), (0,2,2), (2,3,2)\\}$。\n    -   路径：$0 \\to 1 \\to 3$（容量 2）和 $0 \\to 2 \\to 3$（容量 2）。\n    -   $\\operatorname{maxflow}(G) = 2 + 2 = 4$。\n    -   可移除的顶点：$\\{1, 2\\}$。\n    -   移除 $v=1$：$\\operatorname{maxflow}(G \\setminus \\{1\\}) = 2$。$\\Delta(1) = 4-2=2$。\n    -   移除 $v=2$：$\\operatorname{maxflow}(G \\setminus \\{2\\}) = 2$。$\\Delta(2) = 4-2=2$。\n    -   两者都得到 $\\Delta=2$。根据平局决胜规则（最小索引），$v^\\star=1$。结果：$[1, 2]$。\n\n-   **Case 3**: $n=5, s=0, t=4, E=\\{(0,1,5), (1,3,1), (3,4,5), (0,2,5), (2,3,1)\\}$。\n    -   顶点 $3$ 是一个瓶颈。有两条路径通过它：$0 \\to 1 \\to 3 \\to 4$ 和 $0 \\to 2 \\to 3 \\to 4$。它们的流量分别受限于 $c(1,3)=1$ 和 $c(2,3)=1$，并且都必须通过 $3 \\to 4$。\n    -   最小割是 $S=\\{0,1,2\\}, T=\\{3,4\\}$，容量为 $c(1,3)+c(2,3) = 1+1=2$。所以，$\\operatorname{maxflow}(G) = 2$。\n    -   可移除的顶点：$\\{1, 2, 3\\}$。\n    -   移除 $v=1$：路径 $0 \\to 1 \\to 3 \\to 4$ 消失。剩余路径为 $0 \\to 2 \\to 3 \\to 4$，流量为 $1$。$\\Delta(1) = 2-1=1$。\n    -   移除 $v=2$：路径 $0 \\to 2 \\to 3 \\to 4$ 消失。剩余路径为 $0 \\to 1 \\to 3 \\to 4$，流量为 $1$。$\\Delta(2) = 2-1=1$。\n    -   移除 $v=3$：两条路径都被切断。流量为 $0$。$\\Delta(3) = 2-0=2$。\n    -   最大下降量为 $2$（对于顶点 $3$）。结果：$[3, 2]$。\n\n-   **Case 4**: $n=2, s=0, t=1, E=\\{(0,1,7)\\}$。\n    -   顶点集为 $\\{s,t\\}$。没有可移除的顶点。根据问题规则，答案是 $[-1, 0]$。\n\n-   **Case 5**: $n=6, s=0, t=5, E=\\{\\dots\\}$。\n    -   最小割是 $S=\\{0,1,3\\}, T=\\{2,4,5\\}$，容量为 $c(1,2)+c(3,4) = 1+1=2$。所以，$\\operatorname{maxflow}(G)=2$。\n    -   可移除的顶点：$\\{1, 2, 3, 4\\}$。\n    -   移除 $v=1$：$\\operatorname{maxflow}(G \\setminus \\{1\\})=1$。$\\Delta(1)=1$。\n    -   移除 $v=2$：$\\operatorname{maxflow}(G \\setminus \\{2\\})=1$。$\\Delta(2)=1$。\n    -   移除 $v=3$：$\\operatorname{maxflow}(G \\setminus \\{3\\})=1$。$\\Delta(3)=1$。\n    -   移除 $v=4$：$\\operatorname{maxflow}(G \\setminus \\{4\\})=1$。$\\Delta(4)=1$。\n    -   所有可移除的顶点都导致流量下降 $1$。最大下降量为 $1$。达到此下降量的最小索引是 $1$。结果：$[1, 1]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef max_flow(n, s, t, capacity_matrix):\n    \"\"\"\n    Computes the maximum flow from source s to sink t in a network\n    using the Edmonds-Karp algorithm.\n    \"\"\"\n    capacity = np.copy(capacity_matrix)\n    flow = 0\n    \n    while True:\n        # Find an augmenting path using BFS\n        parent = np.full(n, -1, dtype=int)\n        queue = [(s, float('inf'))]\n        parent[s] = s\n        path_flow = 0\n        \n        head = 0\n        while head  len(queue):\n            u, current_flow = queue[head]\n            head += 1\n            \n            if u == t:\n                path_flow = current_flow\n                break\n            \n            for v in range(n):\n                if parent[v] == -1 and capacity[u, v] > 0:\n                    parent[v] = u\n                    new_flow = min(current_flow, capacity[u, v])\n                    queue.append((v, new_flow))\n            \n            if path_flow > 0:\n                break\n        \n        # If no augmenting path is found, the flow is maximal\n        if path_flow == 0:\n            break\n            \n        # Add path flow to total flow\n        flow += path_flow\n        \n        # Update residual capacities\n        v = t\n        while v != s:\n            u = parent[v]\n            capacity[u, v] -= path_flow\n            capacity[v, u] += path_flow\n            v = u\n            \n    return int(flow)\n\ndef build_capacity_matrix(n, edges, removed_vertex=None):\n    \"\"\"\n    Builds an n x n capacity matrix from a list of edges.\n    Handles parallel edges by summing their capacities.\n    Optionally ignores edges connected to a removed_vertex.\n    \"\"\"\n    capacity = np.zeros((n, n), dtype=int)\n    for u, v, c in edges:\n        if removed_vertex is not None and (u == removed_vertex or v == removed_vertex):\n            continue\n        capacity[u, v] += c\n    return capacity\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        (4, 0, 3, [(0, 1, 3), (1, 3, 3), (0, 2, 2), (2, 3, 2)]),\n        (4, 0, 3, [(0, 1, 2), (1, 3, 2), (0, 2, 2), (2, 3, 2)]),\n        (5, 0, 4, [(0, 1, 5), (1, 3, 1), (3, 4, 5), (0, 2, 5), (2, 3, 1)]),\n        (2, 0, 1, [(0, 1, 7)]),\n        (6, 0, 5, [(0, 1, 10), (1, 2, 1), (2, 5, 10), (0, 3, 10), (3, 4, 1), (4, 5, 10), (1, 3, 10), (2, 4, 10)])\n    ]\n\n    all_results = []\n\n    for n, s, t, edges in test_cases:\n        # Identify removable vertices (not source or sink)\n        removable_vertices = [v for v in range(n) if v != s and v != t]\n\n        # Handle the case with no removable vertices\n        if not removable_vertices:\n            all_results.append([-1, 0])\n            continue\n\n        # Calculate the original maximum flow\n        original_capacity_matrix = build_capacity_matrix(n, edges)\n        original_max_flow = max_flow(n, s, t, original_capacity_matrix)\n\n        best_v = -1\n        max_decrease = float('-inf')\n\n        # Iterate through removable vertices to find the \"most valuable\" one\n        for v in removable_vertices:\n            # Create capacity matrix with vertex v removed\n            capacity_matrix_removed = build_capacity_matrix(n, edges, removed_vertex=v)\n            \n            # Calculate the max flow in the modified graph\n            flow_after_removal = max_flow(n, s, t, capacity_matrix_removed)\n\n            decrease = original_max_flow - flow_after_removal\n\n            # Update if a larger decrease is found.\n            # Tie-breaking (smallest index) is handled by iterating in\n            # ascending order of v and only updating on strictly greater decreases.\n            if decrease > max_decrease:\n                max_decrease = decrease\n                best_v = v\n        \n        # If no vertex removal causes a positive decrease, max_decrease might be 0 or negative.\n        # The logic still correctly picks the first vertex in sorted order in case of ties.\n        # If best_v wasn't updated (e.g., all decreases were negative),\n        # this means the highest decrease (least negative) was caused by the first vertex.\n        if best_v == -1 and removable_vertices:\n             # This case happens if all decreases are equal (e.g. all negative or all zero).\n             # The first vertex is the tie-breaker.\n             v = removable_vertices[0]\n             capacity_matrix_removed = build_capacity_matrix(n, edges, removed_vertex=v)\n             flow_after_removal = max_flow(n, s, t, capacity_matrix_removed)\n             max_decrease = original_max_flow - flow_after_removal\n             best_v = v\n\n\n        all_results.append([best_v, int(max_decrease)])\n\n    # Format the final output as a single-line string representation of a list of lists.\n    # e.g., [[1, 3], [1, 2], [3, 2], [-1, 0], [1, 1]]\n    output_str = \"[\" + \",\".join(map(str, all_results)) + \"]\"\n    print(output_str.replace(\" \", \"\"))\n\nsolve()\n```", "id": "3255325"}]}