{"hands_on_practices": [{"introduction": "在探索图的结构时，一个常见的问题是顶点的度数如何影响网络的韧性。这个练习旨在澄清一个普遍的误解：即图的最小度数是否能保证网络中不存在“桥”这样的单点故障。通过构建反例和证明，你将对桥的本质属性有更深刻的理解，这对于设计稳健的网络至关重要。[@problem_id:1487123]", "problem": "一位网络架构师正在设计一个新的鲁棒通信网络。该网络的拓扑被建模为一个简单连通图 $G=(V, E)$，其中顶点集 $V$ 代表数据中心，边集 $E$ 代表高带宽光纤链路。如果移除一条链路会导致网络断开成两个或更多的独立组件，那么该链路就被认为是“单点故障”。在图论中，这样的边被称为桥。\n\n架构师正在探索与顶点度数相关的各种设计约束，以增强网络的弹性。一个顶点的度数是与其相连的链路数量。图的最小度，记作 $\\delta(G)$，是图中所有顶点的最小度数。架构师想要理解网络图的最小度与可能存在的桥之间的基本关系。\n\n对于任何至少有两个顶点的简单连通图 $G$，以下哪个陈述正确地描述了这种关系？\n\nA. 一个连通图 $G$ 没有桥，当且仅当其最小度 $\\delta(G) \\geq 2$。\n\nB. 如果一个连通图 $G$ 有桥，那么它的最小度 $\\delta(G)$ 必须是 1。\n\nC. 对于任何整数 $k \\geq 1$，可以构造一个有桥的连通图 $G$，使得 $G$ 的最小度恰好为 $k$。\n\nD. 如果一条边是连通图 $G$ 中的桥，那么它的至少一个端点的度数必须为 1。\n\nE. 任何最小度 $\\delta(G) \\geq 2$ 的连通图 $G$ 都不能包含桥。", "solution": "我们回顾一下定义。在一个简单连通图 $G=(V,E)$ 中，如果移除边 $e \\in E$ 会增加连通分量的数量，则 $e$ 是一座桥。最小度是 $\\delta(G)=\\min_{v \\in V}\\deg(v)$。\n\n评估每个陈述：\n\nA. 陈述：“$G$ 没有桥当且仅当 $\\delta(G) \\geq 2$。”正向是正确的：如果 $G$ 没有桥，那么没有顶点的度数可以为 1，因为如果存在一个度数为 $\\deg(u)=1$ 的顶点 $u$，其唯一的关联边将是一座桥，这与前提矛盾。因此 $\\delta(G) \\geq 2$。反向是错误的。反例：取两个圈并通过一条边将它们连接起来。形式上，设 $G$ 是通过在两个不相交的圈 $C_m$ 和 $C_n$ 之间添加一条边 $(x, y)$ 而得到的，其中 $x \\in V(C_m)$ 且 $y \\in V(C_n)$。那么 $\\delta(G)=2$，但添加的边 $(x, y)$ 是两部分之间唯一的连接，所以 $(x, y)$ 是一座桥。因此 A 是错误的。\n\nB. 陈述：“如果 $G$ 有桥，那么 $\\delta(G)=1$。”这是错误的。上面同样的反例有一个桥 $(x, y)$，而 $\\delta(G)=2$。因此 B 是错误的。\n\nC. 陈述：“对于任何整数 $k \\geq 1$，存在一个有桥且 $\\delta(G)=k$ 的连通图 $G$。”构造：\n- 对于 $k=1$，任何至少有两个顶点的树都是连通的，有桥，并且 $\\delta(G)=1$。\n- 对于 $k \\geq 2$，取两个连通的 $k$-正则图（例如，两个 $K_{k+1}$ 的副本，它是 $k$-正则的）。从每个副本中各选一个顶点，并在它们之间添加一条边。得到的图是连通的；添加的边是两个副本之间唯一的互连，因此它是一座桥。所选端点的度数增加到 $k+1$，而所有其他顶点的度数仍为 $k$，所以最小度保持为 $\\delta(G)=k$。因此 C 是正确的。\n\nD. 陈述：“如果一条边是桥，那么它的至少一个端点的度数为 1。”这是错误的。在前面用两个圈（或两个三角形）通过一条边连接的构造中，桥的端点度数至少为 2（在两个三角形的例子中实际上是 3），而不是 1。因此 D 是错误的。\n\nE. 陈述：“任何最小度 $\\delta(G) \\geq 2$ 的连通图都不包含桥。”这是 A 中正确推论的逆命题，并且可以用用于 A 和 B 的相同反例来反驳。因此 E 是错误的。\n\n因此，唯一正确的陈述是 C。", "answer": "$$\\boxed{C}$$", "id": "1487123"}, {"introduction": "理论知识需要通过实践来巩固。这个练习将带你从理论走向实践，要求你实现一个经典的算法来找出图中的所有桥，并在此基础上解决一个更具体的问题：在带权图中定位“最薄弱的环节”。通过编码实现 Tarjan 桥查找算法，你将掌握识别网络中关键基础设施的核心技能。[@problem_id:3218710]", "problem": "给定一个由有限顶点集和边集描述的无向带权图。设图表示为 $G = (V, E)$，其权重函数为 $w : E \\to \\mathbb{N}$，其中 $\\mathbb{N}$ 是非负整数集。每条边 $e \\in E$ 连接两个顶点 $u, v \\in V$，并具有一个关联的整数权重 $w(e)$。允许同一无序顶点对之间存在多重边，且图可能是不连通的。顶点由从 $0$ 到 $n-1$ 的连续整数标记，其中 $n = |V|$。\n\n如果从图 $G$ 中移除一条边 $e \\in E$ 会增加 $G$ 的连通分量数量，则称该边为桥。形式上，如果图 $G' = (V, E \\setminus \\{e\\})$ 的连通分量数量严格多于 $G$，则 $e$ 是一个桥。定义 $G$ 的“最弱一环”为权重最小的桥。如果存在多个具有相同最小权重的桥，则选择其无序端点对（按升序排列）字典序最小的那个。如果仍然存在平局（例如，具有相同无序端点和相同权重的平行边），则选择在给定输入顺序中最早出现的边。\n\n您的任务是编写一个程序，从无向图、连通性和深度优先搜索 (DFS) 的核心定义出发，推导并实现一种方法来确定桥的集合，并根据上述规则选出最弱一环。对于每个测试用例，程序必须返回最弱一环的端点和权重，形式为列表 $[u, v, w]$（其中 $u  v$），或者在没有桥存在时返回空列表 $[]$。\n\n输入不是以交互方式提供的；相反，您的程序必须嵌入并使用以下测试套件。每个测试用例指定了 $n$ 和一个边列表，边的形式为三元组 $(u, v, w)$，其中 $u$ 和 $v$ 是满足 $0 \\le u, v \\le n-1$ 的整数，且 $w \\in \\mathbb{N}$。\n\n测试套件：\n- 测试用例 1（包含环和叶节点的常规路径）：$n = 5$，边 $= [(0, 1, 5), (1, 2, 2), (2, 3, 10), (1, 3, 4), (3, 4, 3)]$。\n- 测试用例 2（无桥：一个简单环）：$n = 3$，边 $= [(0, 1, 7), (1, 2, 8), (2, 0, 9)]$。\n- 测试用例 3（路径图，所有边都是桥）：$n = 4$，边 $= [(0, 1, 7), (1, 2, 1), (2, 3, 5)]$。\n- 测试用例 4（不连通图，包含一个环和一个单边分量）：$n = 5$，边 $= [(0, 1, 5), (1, 2, 6), (2, 0, 4), (3, 4, 8)]$。\n- 测试用例 5（平行边；只有叶边是桥）：$n = 3$，边 $= [(0, 1, 1), (0, 1, 2), (1, 2, 4)]$。\n- 测试用例 6（权重相同，通过端点的字典序解决）：$n = 4$，边 $= [(0, 1, 3), (2, 3, 3)]$。\n\n您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个用方括号括起来的逗号分隔列表，其中每个元素要么是空列表 $[]$，要么是所定义的列表 $[u, v, w]$。例如，三个用例的有效输出应类似于 $[[u_1, v_1, w_1],[],[u_3, v_3, w_3]]$。", "solution": "问题陈述已解析并确定为有效。它在图论和算法领域内提出了一个定义明确的任务，并提供了所有必要的条件和数据。桥和“最弱一环”的定义是精确且可形式化的。\n\n任务是识别给定无向带权图 $G = (V, E)$ 中的“最弱一环”。它被定义为权重最小的桥，并有针对字典序最小的端点和最早输入顺序的特定平局决胜规则。\n\n桥是一条边，移除它会增加图中连通分量的数量。在图中寻找所有桥的标准算法基于深度优先搜索 (DFS) 遍历。该方法的推导从第一性原理开始，如下所示。\n\n对图 $G$ 进行 DFS 遍历会将其边划分为两种类型：树边，它们构成一个 DFS 生成森林；以及反向边，它们将一个顶点连接到其在 DFS 树中的某个祖先（不包括其直接父节点）。一条边 $(u, v)$（其中 $u$ 是 $v$ 在 DFS 树中的父节点）是桥，当且仅当不存在从以 $v$ 为根的子树中的任何顶点到 $u$ 或其任何祖先的反向边。这种反向边的存在意味着存在一条从 $v$ 回到 $u$ 的替代路径（从而形成一个环），这意味着移除树边 $(u, v)$ 不会使图断开。\n\n这个原理可以通过在 DFS 期间为每个顶点 $u$ 跟踪两个关键值来形式化：\n$1$. 发现时间 `$disc[u]$`：一个时间戳（一个单调递增的计数器），记录 $u$ 首次被访问的时间。\n$2$. 低链接值 `$low[u]$`：从 $u$（包括其自身）出发，通过遍历其子树中零条或多条树边，然后再经过至多一条反向边，所能到达的最低发现时间。\n\n该算法通过一个递归的 DFS 函数进行。对于每个顶点 $u$，我们初始化 $low[u] = disc[u]$。然后，对于 $u$ 的每个邻居 $v$：\n- 如果 $v$ 已被访问，则边 $(u, v)$ 是一条反向边。顶点 $u$ 可以到达一个祖先或一个已访问过的节点，因此我们更新其低链接值：$low[u] = \\min(low[u], disc[v])$。\n- 如果 $v$ 未被访问，则 $(u, v)$ 是一条树边。我们执行递归调用 `dfs(v)`。从递归返回后，以 $v$ 为根的整个子树的 $low[v]$ 值已经计算完毕。顶点 $u$ 可以到达 $v$ 能到达的所有地方，因此我们相应地更新 $low[u]$：$low[u] = \\min(low[u], low[v])$。\n\n此更新之后，我们应用桥条件。边 $(u, v)$ 是桥，当且仅当 $low[v] > disc[u]$。这个不等式表示从以 $v$ 为根的子树可达的最早顶点是 $v$ 本身。没有从 $v$ 的子树发出的反向边能到达 $u$ 或其任何祖先。因此，移除边 $(u, v)$ 将把以 $v$ 为根的子树与图的其余部分分离开，从而增加连通分量的数量。\n\n此问题的特殊考虑因素：\n- **多重边**：图中可能包含平行边。在 DFS 中进行简单的父顶点检查（即 `if v == parent`）是不够的，因为它会错误地忽略所有到父节点的平行边，而不仅仅是用于遍历的那条。这里采用了一种更稳健的方法，即将父边的索引传递给递归调用，并仅忽略那条特定的边，从而正确地将平行边识别为可能形成环的反向边。\n- **不连通图**：主过程必须遍历从 $0$ 到 $n-1$ 的所有顶点，并从任何未访问过的顶点启动 DFS，以确保所有连通分量都被遍历。\n\n总体算法如下：\n$1$. 用它们的原始索引 $0, 1, 2, \\dots$ 来增强输入边，以便于最终的平局决胜规则。\n$2$. 构建图的邻接表表示法，其中每个条目存储邻居、权重和原始边索引。\n$3$. 初始化 `disc`、`low` 和 `visited` 数组。\n$4$. 遍历所有顶点。如果一个顶点未被访问，则从它开始修改后的 DFS。\n$5$. DFS 函数使用 $low[v] > disc[u]$ 条件来识别所有桥。每个发现的桥都存储为一个元组，包含其权重、按升序排序的端点及其原始索引：$(w, u_{sorted}, v_{sorted}, \\text{index})$。\n$6$. 遍历完成后，如果未找到桥，则结果为空列表。\n$7$. 否则，对发现的桥列表进行排序。Python 的默认元组排序机制自然地实现了所需的多级排序标准：首先按权重，然后按第一个端点，再按第二个端点，最后按原始索引。\n$8$. 排序后列表的第一个元素就是“最弱一环”。其端点和权重被格式化为所需的输出列表 $[u, v, w]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_weakest_link(n, edges):\n    \"\"\"\n    Finds the \"weakest link\" in a graph, defined as the bridge with the minimum\n    weight, with specific tie-breaking rules.\n    \"\"\"\n    if n == 0 or not edges:\n        return []\n\n    # Adjacency list: adj[u] - list of (v, w, edge_idx)\n    adj = [[] for _ in range(n)]\n    for i, (u, v, w) in enumerate(edges):\n        # We assume u and v are valid vertex indices\n        adj[u].append((v, w, i))\n        adj[v].append((u, w, i))\n\n    # Tarjan's bridge-finding algorithm data structures\n    disc = np.full(n, -1, dtype=int)\n    low = np.full(n, -1, dtype=int)\n    time = 0\n    bridges = []\n\n    def dfs(u, parent_edge_idx):\n        \"\"\"\n        Performs Depth-First Search to find bridges.\n        \n        Args:\n            u: The current vertex.\n            parent_edge_idx: The index of the edge used to arrive at u. This is\n                             used to handle multigraphs correctly, preventing the\n                             traversal from immediately going back on the same edge.\n        \"\"\"\n        nonlocal time\n        disc[u] = low[u] = time\n        time += 1\n\n        for v, w, edge_idx in adj[u]:\n            if edge_idx == parent_edge_idx:\n                continue\n\n            if disc[v] != -1:  # v is a visited vertex (back edge)\n                low[u] = min(low[u], disc[v])\n            else:  # v is an unvisited vertex (tree edge)\n                dfs(v, edge_idx)\n                low[u] = min(low[u], low[v])\n\n                if low[v]  disc[u]:\n                    # The edge (u, v) is a bridge.\n                    # Sort endpoints for lexicographical comparison.\n                    u_sorted, v_sorted = sorted((u, v))\n                    # Store tuple for sorting: (weight, u, v, original_index)\n                    bridges.append((w, u_sorted, v_sorted, edge_idx))\n    \n    # Iterate through all vertices to handle disconnected graphs\n    for i in range(n):\n        if disc[i] == -1:\n            dfs(i, -1)\n    \n    if not bridges:\n        return []\n\n    # Sort according to the problem's tie-breaking rules:\n    # 1. Minimum weight (primary key)\n    # 2. Lexicographically minimal endpoint pair (secondary keys u, then v)\n    # 3. Earliest edge in input order (tertiary key, edge_idx)\n    # Python's default tuple sorting handles this hierarchy correctly.\n    bridges.sort()\n\n    weakest = bridges[0]\n    w, u, v, _ = weakest\n    return [u, v, w]\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the solver for each case, and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (5, [(0, 1, 5), (1, 2, 2), (2, 3, 10), (1, 3, 4), (3, 4, 3)]),\n        (3, [(0, 1, 7), (1, 2, 8), (2, 0, 9)]),\n        (4, [(0, 1, 7), (1, 2, 1), (2, 3, 5)]),\n        (5, [(0, 1, 5), (1, 2, 6), (2, 0, 4), (3, 4, 8)]),\n        (3, [(0, 1, 1), (0, 1, 2), (1, 2, 4)]),\n        (4, [(0, 1, 3), (2, 3, 3)]),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        result = find_weakest_link(n, edges)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The str() function for a list automatically adds spaces, e.g., '[1, 2, 4]'.\n    # This matches the example output format style.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3218710"}, {"introduction": "在现实世界的网络中，最优路径的定义往往是多维度的。这个高级练习挑战你综合运用多种图算法，解决一个复杂的路径规划问题：找到一条穿越最少数量桥梁的最短路径。这个问题引导你将桥识别作为预处理步骤，并将其与经典的 Dijkstra 算法相结合，从而解决带有词典序优化目标的路径问题。[@problem_id:3218591]", "problem": "给定一个无向简单图，其顶点标记为 $0$ 到 $n-1$，以及一个无权边集。如果移除一条边会增加图的连通分量数量，则称该边为桥。对于给定的两个顶点 $u$ 和 $v$，我们将一条从 $u$ 到 $v$ 的路径的目标定义为按字典序排列的数对 $(b, \\ell)$，其中 $b$ 是路径上的桥边数量，$\\ell$ 是路径上的边数。目标是选择一条从 $u$ 到 $v$ 的最优路径，最优的定义如下：首先最小化 $b$，然后在所有满足条件的路径中，最小化 $\\ell$。如果 $u$ 和 $v$ 不连通，则需要输出数对 $(-1,-1)$。\n\n仅使用无向图、连通分量和桥的基本定义。您必须实现一个完整的程序，对下面的每个测试用例，计算所定义的最优数对 $(b,\\ell)$。如果指定的 $u$ 和 $v$ 之间没有路径，则对该测试用例输出 $(-1,-1)$。\n\n您的程序必须产生单行输出，其中包含与测试用例对应的结果列表，每个结果是该测试用例的数对 $[b,\\ell]$。格式必须是单个列表的列表，例如 $[[b_1,\\ell_1],[b_2,\\ell_2],\\dots]$。\n\n使用的测试套件：\n- 测试用例 $1$：\n  - $n=8$\n  - 边集 $\\{(0,1),(1,2),(2,3),(3,0),(1,7),(3,4),(4,5),(5,6),(6,4)\\}$\n  - $u=0$, $v=5$\n- 测试用例 $2$：\n  - $n=5$\n  - 边集 $\\{(0,1),(1,2),(2,3),(3,4),(4,0)\\}$\n  - $u=0$, $v=3$\n- 测试用例 $3$：\n  - $n=4$\n  - 边集 $\\{(0,1),(2,3)\\}$\n  - $u=0$, $v=3$\n- 测试用例 $4$：\n  - $n=7$\n  - 边集 $\\{(0,1),(1,2),(1,3),(3,4),(3,5),(5,6)\\}$\n  - $u=2$, $v=6$\n- 测试用例 $5$：\n  - $n=3$\n  - 边集 $\\{(0,1),(1,2)\\}$\n  - $u=1$, $v=1$\n\n最终输出格式：\n- 您的程序应精确打印一行，该行为一个列表的列表，其中每个内部列表是对应测试用例的 $[b,\\ell]$，顺序与上文相同。对于不可达的顶点对，使用 $[-1,-1]$。例如，一个有效的输出形如 $[[0,3],[1,4],[-1,-1]]$。", "solution": "用户提供的问题是一个明确定义的图论练习，具体要求是根据一个字典序目标函数，计算两个顶点之间的最优路径。该问题在科学上是合理的、自洽的，并且可以通过算法解决。\n\n目标是找到从源顶点 $u$ 到目标顶点 $v$ 的一条路径，该路径使数对 $(b, \\ell)$ 最小化，其中 $b$ 是路径上的桥数量，$\\ell$ 是总边数（路径长度）。最小化是按字典序进行的，即主要目标是最小化 $b$，次要目标是在所有具有最小 $b$ 值的路径中最小化 $\\ell$。\n\n该问题可以建模为一个带权图上的最短路径问题，其中遍历一条边的“权重”不是单个标量，而是一个数值对。设遍历一条边 $(x, y)$ 的成本为数对 $(w_b, w_\\ell)$，其中如果该边是桥，则 $w_b=1$，否则 $w_b=0$，而对所有边 $w_\\ell=1$。一条路径的总成本是其构成边的成本的逐分量之和。问题就变成了找到一条从 $u$ 到 $v$ 的路径，其总成本在字典序上最小。\n\n解决方案策略包括两个主要阶段：\n1.  **桥的识别**：预处理图以识别所有桥边。\n2.  **最优路径搜索**：使用一个修改过的最短路径算法来找到使字典序成本 $(b, \\ell)$ 最小的路径。\n\n**阶段 1：桥的识别**\n\n在无向图中，桥是一条移除后会增加连通分量数量的边。一个标准且高效的寻找图中所有桥的算法是基于深度优先搜索 (DFS) 遍历。在 DFS 期间，我们为每个顶点 $i$ 维护两个值：\n-   `$disc[i]$`: 顶点 $i$ 的“发现时间”，即首次访问 $i$ 时的时间（一个在每次访问顶点时递增的计数器）。\n-   `$low[i]$`: 顶点 $i$ 的“低链接”值，即从 $i$（包括其自身）通过 DFS 树可达的最小发现时间，可能需要通过一条“后向边”到达一个祖先节点。\n\n该算法按以下步骤进行：\n我们为所有顶点初始化发现时间、低链接值和一个父节点跟踪器。我们遍历从 $0$ 到 $n-1$ 的每个顶点。如果一个顶点尚未被访问，我们就从它开始进行 DFS。\n\n在顶点 $u$（其父节点为 $p$）的递归 DFS 函数中：\n1.  将 $u$ 标记为已访问。将 $disc[u]$ 和 $low[u]$ 设置为当前时间，并增加时间计数器。\n2.  对于 $u$ 的每个邻居 $v$：\n    a. 如果 $v$ 是父节点 $p$，则忽略它。\n    b. 如果 $v$ 已经被访问过（且不是父节点），这意味着存在一条从 $u$ 到祖先节点 $v$ 的后向边。这条后向边表示一个环。我们更新 $low[u]$ 如下：$low[u] = \\min(low[u], disc[v])$。\n    c. 如果 $v$ 未被访问，我们将 $v$ 的父节点设置为 $u$，并对 $v$ 递归调用 DFS。递归调用返回后，我们根据其子节点 $v$ 的低链接值更新 $low[u]$：$low[u] = \\min(low[u], low[v])$。\n    d. 桥检测的关键步骤：如果 $low[v] > disc[u]$，则边 $(u, v)$ 是一个桥。这个条件意味着从以 $v$ 为根的子树能到达的最早的顶点是 $v$ 本身，并且从该子树没有后向边连接到 $u$ 的任何祖先。因此，移除边 $(u, v)$ 会将 $v$ 及其后代与 $u$ 断开连接。\n\n我们将所有这样识别出的桥收集到一个集合中，以便在下一阶段进行高效查找。\n\n**阶段 2：最优路径搜索**\n\n在识别出桥的集合后，我们可以继续寻找最优路径。这是一个带有向量值成本函数的最短路径问题，可以使用 Dijkstra 算法的修改版来解决，以处理字典序比较。\n\n该算法如下：\n1.  为所有顶点初始化一个距离数据结构 `dist`。$dist[i]$ 将存储迄今为止找到的从 $u$到 $i$ 的路径的字典序最小数对 $(b, \\ell)$。我们初始化 $dist[u] = (0, 0)$，对于所有其他顶点 $i \\neq u$，初始化 $dist[i] = (\\infty, \\infty)$。\n2.  使用一个最小优先队列来存储形式为 $(b, \\ell, \\text{顶点})$ 的元组。优先队列将根据数对 $(b, \\ell)$ 自然地对元素进行字典序排序。\n3.  将起始元组 $(0, 0, u)$ 推入优先队列。\n4.  当优先队列不为空时：\n    a. 提取具有最小字典序成本的元素：$(b_{curr}, \\ell_{curr}, v_{curr})$。\n    b. 如果 $(b_{curr}, \\ell_{curr})$ 在字典序上大于当前已知的 $dist[v_{curr}]$，这意味着我们之前已经找到了通往 $v_{curr}$ 的更优路径。我们跳过此条目并继续。\n    c. 对于 $v_{curr}$ 的每个邻居 $v_{next}$：\n        i. 确定边 $(v_{curr}, v_{next})$ 的成本。如果它是桥，成本为 $(1, 1)$。否则，成本为 $(0, 1)$。设其为 $(b_{edge}, \\ell_{edge})$。\n        ii. 计算到 $v_{next}$ 的新路径成本：$(b_{new}, \\ell_{new}) = (b_{curr} + b_{edge}, \\ell_{curr} + \\ell_{edge})$。\n        iii. 将这个新成本与当前已知的 $v_{next}$ 的最优成本 $dist[v_{next}]$ 进行比较。如果 $(b_{new}, \\ell_{new})$ 在字典序上小于 $dist[v_{next}]$，我们就找到了一个更优的路径。\n        iv. 更新 $dist[v_{next}] = (b_{new}, \\ell_{new})$ 并将新元组 $(b_{new}, \\ell_{new}, v_{next})$ 推入优先队列。\n\n5.  算法终止后，$dist[v]$ 将包含到目标顶点 $v$ 的最优数对 $(b, \\ell)$。如果 $dist[v]$ 仍然是 $(\\infty, \\infty)$，这意味着 $v$ 从 $u$ 不可达，结果为 $(-1, -1)$。特殊情况 $u=v$ 通过初始化 $dist[u]=(0,0)$ 得到正确处理，产生一个成本为 $(0,0)$ 的路径。这个过程保证能找到最优路径，因为与标准的 Dijkstra 算法一样，它按照“距离”（在此例中为字典序成本）的递增顺序探索顶点。", "answer": "```python\nimport numpy as np\nimport heapq\nfrom collections import defaultdict\nimport sys\n\n# It is good practice to increase the recursion limit for deep graphs in DFS.\nsys.setrecursionlimit(2000)\n\ndef find_optimal_path(n, edges, u, v):\n    \"\"\"\n    Finds the optimal path from u to v based on lexicographical minimization of (bridges, length).\n    \"\"\"\n    if u == v:\n        return [0, 0]\n\n    adj = defaultdict(list)\n    for x, y in edges:\n        adj[x].append(y)\n        adj[y].append(x)\n\n    # --- Phase 1: Find all bridges using Tarjan's bridge-finding algorithm ---\n    \n    # Using numpy arrays for performance with large N.\n    disc = np.full(n, -1, dtype=int)\n    low = np.full(n, -1, dtype=int)\n    parent = np.full(n, -1, dtype=int)\n    visited = np.full(n, False, dtype=bool)\n    \n    bridges = set()\n    time = 0\n\n    def find_bridges_dfs(curr_node):\n        nonlocal time\n        visited[curr_node] = True\n        disc[curr_node] = low[curr_node] = time\n        time += 1\n\n        for neighbor in adj[curr_node]:\n            if neighbor == parent[curr_node]:\n                continue\n            if visited[neighbor]:\n                low[curr_node] = min(low[curr_node], disc[neighbor])\n            else:\n                parent[neighbor] = curr_node\n                find_bridges_dfs(neighbor)\n                low[curr_node] = min(low[curr_node], low[neighbor])\n                if low[neighbor]  disc[curr_node]:\n                    # The edge (curr_node, neighbor) is a bridge.\n                    # Store it in a canonical form (smaller, larger) for easy lookup.\n                    bridge_edge = tuple(sorted((curr_node, neighbor)))\n                    bridges.add(bridge_edge)\n\n    # The graph might be disconnected, so we iterate through all vertices.\n    for i in range(n):\n        if not visited[i]:\n            find_bridges_dfs(i)\n\n    # --- Phase 2: Modified Dijkstra's algorithm for lexicographical shortest path ---\n    \n    # dist[i] will store the pair (number_of_bridges, length)\n    dist = {i: (float('inf'), float('inf')) for i in range(n)}\n    dist[u] = (0, 0)\n\n    # Priority queue stores (bridges, length, vertex)\n    pq = [(0, 0, u)]\n\n    while pq:\n        b_curr, l_curr, v_curr = heapq.heappop(pq)\n\n        # If we found a better path already, skip\n        if (b_curr, l_curr)  dist[v_curr]:\n            continue\n\n        if v_curr == v:\n            # Since Dijkstra explores paths in increasing cost order,\n            # the first time we reach v, it's via an optimal path.\n            break\n\n        for v_next in adj[v_curr]:\n            edge = tuple(sorted((v_curr, v_next)))\n            b_edge = 1 if edge in bridges else 0\n            l_edge = 1\n            \n            b_new = b_curr + b_edge\n            l_new = l_curr + l_edge\n\n            # Lexicographical comparison\n            if (b_new, l_new)  dist[v_next]:\n                dist[v_next] = (b_new, l_new)\n                heapq.heappush(pq, (b_new, l_new, v_next))\n\n    final_dist = dist[v]\n    if final_dist == (float('inf'), float('inf')):\n        return [-1, -1]\n    else:\n        return [final_dist[0], final_dist[1]]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {'n': 8, 'edges': {(0, 1), (1, 2), (2, 3), (3, 0), (1, 7), (3, 4), (4, 5), (5, 6), (6, 4)}, 'u': 0, 'v': 5},\n        # Test case 2\n        {'n': 5, 'edges': {(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)}, 'u': 0, 'v': 3},\n        # Test case 3\n        {'n': 4, 'edges': {(0, 1), (2, 3)}, 'u': 0, 'v': 3},\n        # Test case 4\n        {'n': 7, 'edges': {(0, 1), (1, 2), (1, 3), (3, 4), (3, 5), (5, 6)}, 'u': 2, 'v': 6},\n        # Test case 5\n        {'n': 3, 'edges': {(0, 1), (1, 2)}, 'u': 1, 'v': 1},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_optimal_path(case['n'], case['edges'], case['u'], case['v'])\n        results.append(result)\n\n    # The final output must be a single line in the specified format.\n    # We use join and map to construct the string representation of the list of lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3218591"}]}