{"hands_on_practices": [{"introduction": "理论知识的精髓在于其定义。在我们深入研究复杂的算法之前，让我们通过一个构造性问题来巩固对强连通分量基本定义的理解。这个练习要求我们从第一性原理出发，思考构成一个强连通分量所需的最小结构，从而为更复杂的分析打下坚实的基础。", "problem": "设 $V$ 是一个满足 $V \\geq 2$ 的正偶数。考虑一个有限简单有向图 $G=(\\mathcal{V},\\mathcal{E})$，其顶点数 $|\\mathcal{V}|=V$，图中没有平行边和自环。该图需要恰好有 $V/2$ 个强连通分量 (SCC)，每个分量的大小为 2。\n\n请仅使用有向图中强连通分量的核心定义——即一个顶点子集 $C \\subseteq \\mathcal{V}$，其中对于任意一对顶点 $u,v \\in C$，都存在从 $u$ 到 $v$ 和从 $v$ 到 $u$ 的有向路径——来确定 $|\\mathcal{E}|$ 的最小可能值，并将其表示为关于 $V$ 的封闭形式表达式。你的论证必须包括一个能达到此下界的构造，以及一个证明，说明任何满足要求的图都不能使用更少的边。你可以假设用于计算 SCC 的 Kosaraju 算法和 Tarjan 算法等算法在线性时间 $O(|\\mathcal{V}|+|\\mathcal{E}|)$ 内运行，但在你的推导中，除了基本的 SCC 定义外，不得使用这些算法的任何性质。\n\n请将最终答案表示为关于 $V$ 的单个解析表达式。无需取整。", "solution": "问题要求对于一个具有 $|\\mathcal{V}|=V$ 个顶点的简单有向图 $G=(\\mathcal{V},\\mathcal{E})$，找出其边数 $|\\mathcal{E}|$ 的最小可能值。已知 $V$ 是一个正偶数（$V \\geq 2$），且该图恰好有 $V/2$ 个强连通分量（SCC），每个分量的大小为 2。推导过程必须仅依赖于 SCC 的基本定义。\n\n设顶点集为 $\\mathcal{V}$。根据题意，图 $G$ 的顶点被划分为 $V/2$ 个不相交的子集 $C_1, C_2, \\dots, C_{V/2}$，这些子集构成了图的强连通分量。每个分量的大小为 $|C_i| = 2$。\n设 $\\mathcal{E}$ 为图的边集。我们可以将边集 $\\mathcal{E}$ 划分为两个不相交的子集：\n1.  $\\mathcal{E}_{intra}$：两个端点位于同一个 SCC 内部的边的集合。\n2.  $\\mathcal{E}_{inter}$：两个端点位于不同 SCC 之间的边的集合。\n\n总边数为 $|\\mathcal{E}| = |\\mathcal{E}_{intra}| + |\\mathcal{E}_{inter}|$。要最小化 $|\\mathcal{E}|$，我们必须找到 $|\\mathcal{E}_{intra}|$ 和 $|\\mathcal{E}_{inter}|$ 的最小可能值。\n\n首先，我们来确定单个 SCC 内部所需的最少边数。考虑一个任意的 SCC，$C_k$，其中 $|C_k|=2$。设该分量中的两个顶点为 $u$ 和 $v$，即 $C_k = \\{u, v\\}$。\n强连通分量的定义要求，对于分量中的每一对顶点，都存在从第一个顶点到第二个顶点的有向路径，反之亦然。\n将此定义应用于 $C_k$：\n- 必须存在一条从 $u$ 到 $v$ 的路径。\n- 必须存在一条从 $v$ 到 $u$ 的路径。\n\n由于图是简单的，没有自环（例如 $(u,u)$）和平行边。$u$ 和 $v$ 之间的路径只能涉及 $\\mathcal{V}$ 中的顶点。然而，为了使 $C_k$ 成为一个强连通分量，建立其强连通性的路径若要被看作是最小单元的一部分，则必须存在于由 $C_k$ 诱导的子图中。更正式地讲，如果我们考虑任何从 $u$ 到 $v$ 的路径，该路径包含一个顶点 $w \\notin C_k$，那么为使 $C_k$ 保持为一个独立的强连通分量，就不能存在从 $w$ 回到 $u$ 或 $v$ 的路径，这会使结构变得复杂。满足该定义的最直接方式是使用完全在 $\\{u,v\\}$ 内部的边。\n\n要仅使用顶点 $\\{u,v\\}$ 来构造一条从 $u$ 到 $v$ 的路径，最短且唯一可能的简单路径是单条边 $(u,v)$。\n同样，要仅使用顶点 $\\{u,v\\}$ 来构造一条从 $v$ 到 $u$ 的路径，最短的路径是边 $(v,u)$。\n因此，要使集合 $\\{u,v\\}$ 强连通，我们至少需要这两条边：$(u,v)$ 和 $(v,u)$。如果只有一条边，比如 $(u,v)$，那么将不存在从 $v$ 到 $u$ 的路径。因此，对于每个大小为 2 的 SCC，最少需要 2 条边。\n\n共有 $V/2$ 个这样的不相交 SCC。每个 SCC 内部至少需要 2 条边。因此，$\\mathcal{E}_{intra}$ 中边的总数最少为各分量所需最少边数之和：\n$$|\\mathcal{E}_{intra}|_{min} = \\sum_{i=1}^{V/2} 2 = \\frac{V}{2} \\times 2 = V$$\n\n接下来，我们考虑分量间的边集 $\\mathcal{E}_{inter}$。这些边连接一个 SCC（$C_i$）中的顶点到另一个不同 SCC（$C_j$）中的顶点（其中 $i \\neq j$）。\nSCC 的一个基本性质是“分量图”（其中每个节点代表 $G$ 的一个 SCC）必须是一个有向无环图（DAG）。如果分量图中存在一个环（例如，存在从 $C_i$到 $C_j$ 的路径，也存在从 $C_j$ 回到 $C_i$ 的路径），那么 $C_i$ 和 $C_j$ 中的所有顶点都将相互可达。这将导致它们合并成一个更大的 SCC，这与题目陈述中 $C_i$ 和 $C_j$ 是不同的 SCC 相矛盾。\n边数 $|\\mathcal{E}_{inter}|$ 必须是非负的，即 $|\\mathcal{E}_{inter}| \\geq 0$。为了最小化总边数 $|\\mathcal{E}|$，我们必须为 $|\\mathcal{E}_{inter}|$ 选择最小可能值，即 $0$。如果 $|\\mathcal{E}_{inter}| = 0$，则意味着在任何 SCC 之间都没有边。在这种情况下，分量图没有边，这显然是一个 DAG。这个选择不违反题目的任何条件。\n\n综合以上发现，总边数的最小可能值为：\n$$|\\mathcal{E}|_{min} = |\\mathcal{E}_{intra}|_{min} + |\\mathcal{E}_{inter}|_{min} = V + 0 = V$$\n这就为 $|\\mathcal{E}|$ 确立了一个下界 $V$。\n\n为了完成证明，我们必须通过构造一个满足所有给定条件且恰好有 $V$ 条边的图来表明这个下界是可以达到的。\n设顶点集为 $\\mathcal{V} = \\{v_1, v_2, \\dots, v_V\\}$。\n我们将 $\\mathcal{V}$ 划分为 $V/2$ 个顶点对：$C_i = \\{v_{2i-1}, v_{2i}\\}$，其中 $i=1, 2, \\dots, V/2$。\n我们如下定义边集 $\\mathcal{E}$：对于每个顶点对 $C_i$，我们添加边 $(v_{2i-1}, v_{2i})$ 和 $(v_{2i}, v_{2i-1})$。\n完整的边集为 $\\mathcal{E} = \\bigcup_{i=1}^{V/2} \\{ (v_{2i-1}, v_{2i}), (v_{2i}, v_{2i-1}) \\}$。\n这个构造出的图的总边数为 $|\\mathcal{E}| = \\sum_{i=1}^{V/2} 2 = V$。\n\n现在，我们验证这个图是否满足题目的标准：\n1.  该图有 $V$ 个顶点，并且是简单的（根据构造，没有自环或平行边）。\n2.  对于任何集合 $C_i$，顶点 $v_{2i-1}$ 和 $v_{2i}$ 通过在该集合内构造的边是相互可达的。因此，每个 $C_i$ 都是一个强连通集合。\n3.  在任何两个不同的集合 $C_i$ 和 $C_j$（其中 $i \\neq j$）之间没有边。因此，$C_i$ 中的顶点无法到达 $C_j$ 中的顶点。这确保了没有 SCC 会比任何一个集合 $C_i$ 更大。\n4.  根据第 2 点和第 3 点，最大的强连通顶点子集恰好是集合 $C_1, C_2, \\dots, C_{V/2}$。\n5.  因此，该图恰好有 $V/2$ 个 SCC，并且每个 SCC 的大小都为 2。\n\n该构造是有效的，并且其边数 $|\\mathcal{E}| = V$。既然我们证明了下界为 $V$，并展示了一个达到该下界的构造方法，那么 $|\\mathcal{E}|$ 的最小可能值就是 $V$。", "answer": "$$\\boxed{V}$$", "id": "3276714"}, {"introduction": "掌握了强连通分量的基本概念后，下一步就是学习如何高效地找出它们。这个实践任务将引导你完整地实现一个经典的线性时间算法（如 Kosaraju 算法），从伪代码设计、正确性证明到实际编程，全方位锻炼你将理论应用于实践的能力。", "problem": "设计并指定一个完整算法，用于计算有向图的所有强连通分量 (SCCs)，并从图可达性和深度优先搜索 (DFS) 的第一性原理出发证明其正确性。您必须将该算法实现为一个可运行的程序，该程序为一组固定的测试图输出规范化的 SCC。您的算法必须是 Kosaraju 算法或 Tarjan 算法之一；您必须做出一个明确的选择，并为其提供完整的伪代码规范。\n\n用作起点的基础和定义：\n- 有向图是一个有序对 $G=(V,E)$，其中 $V$ 是一个有限的顶点集合，顶点由连续整数 $0,\\dots,n-1$ 标记（对于某个整数 $n \\ge 0$），$E \\subseteq V \\times V$ 是一个有向边集合。\n- 对于 $u,v \\in V$，如果存在一个顶点序列 $u=x_0,x_1,\\dots,x_k=v$（其中 $k \\ge 0$）并且对于所有 $i \\in \\{0,\\dots,k-1\\}$ 都有 $(x_i,x_{i+1}) \\in E$，则称存在一条从 $u$ 到 $v$ 的路径。\n- 一个子集 $C \\subseteq V$ 是一个强连通分量，如果对于所有 $u,v \\in C$，都存在一条从 $u$ 到 $v$ 的路径和一条从 $v$ 到 $u$ 的路径，并且在该属性下，$C$ 对于集合包含关系是极大的。\n- 深度优先搜索 (DFS) 通过递归访问未访问过的出邻点来探索路径，根据标准的 DFS 分类，每条边 $(u,v)$ 要么是树边、返祖边、前向边，要么是横叉边。顶点的 DFS 完成时间是它被完全探索并添加到完成顺序栈中的时间。转置图 $G^T=(V,E^T)$ 具有 $E^T=\\{(v,u)\\mid (u,v)\\in E\\}$。\n- $G$ 的缩点（分量）图将每个强连通分量收缩为单个顶点，从而产生一个有向无环图 (DAG)。\n\n您的任务：\n1. 选择 Kosaraju 算法或 Tarjan 算法之一，并提供精确的、与语言无关的伪代码。该伪代码接受一个以邻接表 $Adj[0..n-1]$ 形式给出的有向图 $G=(V,E)$作为输入，其中 $Adj[u]$ 枚举了所有满足 $(u,v)\\in E$ 的 $v$。所有中间变量、函数名和数字都必须使用 LaTeX 表示法编写。\n2. 从第一性原理推导算法的正确性。从上述基础定义以及关于 DFS 和转置图的公认事实出发，解释为什么该算法能将 $V$ 划分为 SCC。您的推理不得依赖任何未经证明的捷径论述，并且必须阐明保证正确性的不变量。\n3. 分析算法在 $n=|V|$ 和 $m=|E|$ 方面的运行时间，并说明空间使用情况。\n4. 确定性输出的规范化要求：对于每个 SCC $C$，按升序输出其顶点。对于所有 SCC 的集合，按这些已排序顶点列表的字典序输出该列表。对于 $n=0$ 的空图，输出为空列表。\n5. 实现要求：将您选择的算法实现为一个完整的程序，该程序不接受任何输入，而是在以下固定的测试套件上运行（图由 $n$ 和邻接表给出）。顶点标记为 $0$ 到 $n-1$。\n- 测试 $1$：$n=8$，边集合 $\\{(0,1),(1,2),(2,0),(2,3),(3,4),(4,5),(5,3),(6,7)\\}$。邻接表：$Adj = [[1],[2],[0,3],[4],[5],[3],[7],[]]$。\n- 测试 $2$：$n=0$，边集合 $\\emptyset$。邻接表：$Adj = []$。\n- 测试 $3$：$n=1$，边集合 $\\emptyset$。邻接表：$Adj = [[]]$。\n- 测试 $4$：$n=1$，边集合 $\\{(0,0)\\}$。邻接表：$Adj = [[0]]$。\n- 测试 $5$：$n=5$，边集合 $\\{(0,1),(1,2),(2,3),(3,4),(4,0),(0,2),(1,3),(2,4),(3,0),(4,1)\\}$。邻接表：$Adj = [[1,2],[2,3],[3,4],[4,0],[0,1]]$。\n- 测试 $6$：$n=6$，边集合 $\\{(0,1),(1,2),(3,4),(4,5)\\}$。邻接表：$Adj = [[1],[2],[],[4],[5],[]]$。\n\n最终输出格式：\n- 您的程序必须向标准输出生成一行内容。该行必须是一个单独的方括号列表，其中包含测试 1 到 6 的结果，按顺序排列。每个结果本身是一个整数列表的列表，并按规定进行了规范化。整行必须是形如 $[r_1,r_2,r_3,r_4,r_5,r_6]$ 的单个字符串，其中每个 $r_i$ 是测试 $i$ 的规范化 SCC 列表。不得打印任何解释性文本。\n- 答案是纯整数列表；不涉及物理单位或角度单位。", "solution": "计算有向图的强连通分量 (SCC) 是图论和计算机科学中的一个基本任务。问题陈述是有效的，因为它基于标准的、明确定义的数学概念，是自洽的，并提出了一个具有客观解题标准的、定义明确的问题。我将选择 Kosaraju 算法，因为它概念清晰，依赖于两次连续的深度优先搜索 (DFS) 应用。\n\nKosaraju 算法主要分三个阶段运行：\n1.  对输入图 $G=(V,E)$ 执行一次 DFS 遍历，以确定所有顶点的完成时间。顶点按其完成顺序存储在一个数据结构（例如栈或列表）中。\n2.  计算转置图 $G^T=(V,E^T)$，其中 $E^T = \\{ (v,u) \\mid (u,v) \\in E \\}$。\n3.  在转置图 $G^T$ 上执行第二次 DFS 遍历。此 DFS 的主循环按第一次遍历计算出的完成时间的降序来考虑顶点。生成的 DFS 森林中的每棵树都对应一个不同的强连通分量。\n\n现在我将提供正式的伪代码，从第一性原理推导其正确性，并分析其复杂度。\n\n**1. Kosaraju 算法的伪代码**\n\n设输入图为 $G=(V,E)$，其中 $|V|=n$ 和 $|E|=m$，由邻接表 $Adj$ 表示。\n\n主过程是 `KOSARAJU`。它使用两个辅助过程，`DFS_PASS1` 和 `DFS_PASS2`。\n\n`全局变量:`\n- $visited$: 一个大小为 $n$ 的布尔数组，初始化为 $false$。\n- $F$: 一个列表或栈，用于按完成顺序存储顶点。\n\n`过程 KOSARAJU(G=(V,E))`:\n1. 对于每个顶点 $u \\in V$:\n2.     $visited[u] \\leftarrow false$\n3. $F \\leftarrow \\text{空列表}$\n4. 对于每个顶点 $u \\in V$:\n5.     如果 $visited[u]$ 为假:\n6.         `DFS_PASS1(G, u)`\n7. 从 $G$ 计算 $G^T$。\n8. 对于每个顶点 $u \\in V$:\n9.     $visited[u] \\leftarrow false$\n10. $SCCs \\leftarrow \\text{空列表的列表}$\n11. 当 $F$ 不为空时:\n12.     $u \\leftarrow F.\\text{pop}()$ (获取具有最晚完成时间的顶点)\n13.     如果 $visited[u]$ 为假:\n14.         $component \\leftarrow \\text{空列表}$\n15.         `DFS_PASS2(G^T, u, component)`\n16.         将 $component$ 追加到 $SCCs$。\n17. 返回 $SCCs$。\n\n`过程 DFS_PASS1(G, u)`:\n1. $visited[u] \\leftarrow true$\n2. 对于 $G$ 中 $u$ 的每个邻居 $v$:\n3.     如果 $visited[v]$ 为假:\n4.         `DFS_PASS1(G, v)`\n5. 将 $u$ 推到列表 $F$ 的前端。\n\n`过程 DFS_PASS2(G^T, u, component)`:\n1. $visited[u] \\leftarrow true$\n2. 将 $u$ 添加到 $component$。\n3. 对于 $G^T$ 中 $u$ 的每个邻居 $v$:\n4.     如果 $visited[v]$ 为假:\n5.         `DFS_PASS2(G^T, v, component)`\n\n**2. 正确性证明**\n\nKosaraju 算法的正确性取决于缩点图和 DFS 完成时间的一个基本性质。缩点图 $G^{SCC}$ 是通过将 $G$ 的每个 SCC 收缩为单个超顶点而形成的。如果在 $G$ 中存在从某个顶点 $u \\in C_i$ 到某个顶点 $v \\in C_j$ 的边（其中 $C_i$ 和 $C_j$ 是对应于 $S_i$ 和 $S_j$ 的 SCC），则在 $G^{SCC}$ 中存在从超顶点 $S_i$ 到 $S_j$ 的边。根据 SCC 的定义，$G^{SCC}$ 是一个有向无环图 (DAG)。\n\n令 $\\text{f}(u)$ 表示在对 $G$ 进行第一次 DFS 遍历时顶点 $u$ 的完成时间。对于任意 SCC $C \\subseteq V$，令 $\\text{f}_{\\max}(C) = \\max_{u \\in C} \\{\\text{f}(u)\\}$。\n\n**核心引理：** 如果 $C_1$ 和 $C_2$ 是 $G$ 中两个不同的 SCC，并且存在一条边 $(u,v) \\in E$，其中 $u \\in C_1$ 且 $v \\in C_2$，那么 $\\text{f}_{\\max}(C_1) > \\text{f}_{\\max}(C_2)$。\n\n**引理证明：**\n我们考虑在对 $G$ 进行第一次 DFS 遍历时的两种情况。\n- **情况 1：** DFS 在访问 $C_1$ 中的任何顶点之前，首先访问了 $C_2$ 中的一个顶点。设 $x \\in C_2$ 是在 $C_2$ 中被访问的第一个顶点。从 $x$ 开始的 DFS 遍历将探索所有从 $x$ 可达的顶点。由于 $C_2$ 中的所有顶点是相互可达的，它们都将作为以 $x$ 为根（或 $x$ 在 $C_2$ 内的某个后代）的 DFS 树的一部分被访问。因为不存在从 $C_2$ 中任何顶点回到 $C_1$ 中任何顶点的路径（否则它们将属于同一个 SCC），所以从 $x$ 开始的 DFS 不会访问 $C_1$ 中的任何顶点。因此，$C_2$ 中的所有顶点都将在包含它们的子树遍历完成之前被探索并完成。具体来说，$C_2$ 中的所有顶点都会在 $x$ 完成之前完成。由于此时 $C_1$ 中的顶点都尚未被访问，所以 $C_1$ 中的所有顶点都将在 $C_2$ 中所有顶点完成之后才开始和完成。因此，$\\text{f}_{\\max}(C_1) > \\text{f}_{\\max}(C_2)$。\n- **情况 2：** DFS 在访问 $C_2$ 中的任何顶点之前，首先访问了 $C_1$ 中的一个顶点。设 $x \\in C_1$ 是在 $C_1$ 中被访问的第一个顶点。从 $x$ 开始的 DFS 将探索所有从 $x$ 可达的顶点。这包括 $C_1$ 中的所有顶点（根据 SCC 的定义）以及由于边 $(u, v)$ 和 $C_1$ 内部的路径，也包括 $C_2$ 中的所有顶点。因此，整个分量 $C_2$ 将被包含在以 $x$ 为根的 DFS 子树内。在 DFS 中，子树中的任何顶点都会在该子树的根完成之前完成。因此，$C_2$ 中所有顶点的完成时间都将小于 $\\text{f}(x)$。由于 $x \\in C_1$，我们有 $\\text{f}_{\\max}(C_2)  \\text{f}(x) \\le \\text{f}_{\\max}(C_1)$。\n\n在两种情况下，引理都成立。\n\n**主要论证：**\n算法的第二阶段在转置图 $G^T$ 上执行 DFS，按照第一次遍历得到的完成时间 $\\text{f}(u)$ 的降序处理顶点。\n\n令 $s$ 为 $V$ 中具有最高完成时间的顶点。令 $C_s$ 为包含 $s$ 的 SCC。根据核心引理，如果 $G$ 中存在从另一个 SCC（比如 $C'$）到 $C_s$ 的边，那么将意味着 $\\text{f}_{\\max}(C')  \\text{f}_{\\max}(C_s)$。但 $s$ 拥有全局最高的完成时间，所以 $\\text{f}_{\\max}(C_s)$ 必须是所有 SCC 中最大的。这是一个矛盾。因此，在 $G$ 中不可能存在从任何其他 SCC 到 $C_s$ 的边。这意味着 $C_s$ 是缩点图 $G^{SCC}$ 中的一个“汇点分量”。\n\n在转置图 $G^T$ 中，分量之间的所有边都被反转。$G$ 中一条边 $(u,v)$（其中 $u \\in C_i, v \\in C_j$）在 $G^T$ 中变为 $(v,u)$。因此，$G^{SCC}$ 中的汇点分量在 $G^T$ 的缩点图中变成了一个“源点分量”。在 $G^T$ 中，不存在从任何其他 SCC *到* $C_s$ 的边。\n\n当第二次 DFS 在 $G^T$ 上从顶点 $s$ 开始时，它可以到达 $C_s$ 中的所有其他顶点，因为它们在 $G$ 中是相互可达的，因此在 $G^T$ 中也是如此。然而，它无法到达 $C_s$ 之外的任何顶点，因为这将意味着在 $G^T$ 中存在一条从 $C_s$ 中的顶点到另一个分量中顶点的边，而我们刚刚证明这是不可能的。因此，在第二次遍历中找到的第一个 DFS 树恰好由 SCC $C_s$ 的顶点组成。\n\n在这个第一个 SCC 被识别之后，它的顶点被标记为已访问。然后算法选择剩余未访问顶点中具有最高完成时间的顶点。该顶点属于一个 SCC，该 SCC 在由剩余未访问顶点诱导的 $G$ 的子图中是一个汇点分量。同样的论证递归适用。这个过程持续进行，正确地将整个顶点集 $V$ 划分为其强连通分量。`KOSARAJU` 主循环中对 `DFS_PASS2` 的每次调用都恰好识别一个 SCC。\n\n**3. 复杂度分析**\n\n- **时间复杂度：**\n    1. 第一次 DFS 遍历 (`DFS_PASS1`) 对 $G$ 的每个顶点和每条边恰好访问一次。其运行时间为 $O(n+m)$。\n    2. 计算转置图 $G^T$ 需要遍历 $G$ 的所有边，构建新的邻接表需要 $O(m)$ 时间，或者初始化并构建它需要 $O(n+m)$ 时间。\n    3. 第二次 DFS 遍历 (`DFS_PASS2`) 对 $G^T$ 的每个顶点和每条边恰好访问一次。顶点数为 $n$，边数为 $m$。其运行时间为 $O(n+m)$。\n    总时间复杂度是这些步骤的总和，即 $O(n+m) + O(n+m) + O(n+m) = O(n+m)$。\n\n- **空间复杂度：**\n    1. 将图 $G$ 及其转置图 $G^T$ 存储为邻接表需要 $O(n+m)$ 的空间。\n    2. $visited$ 数组需要 $O(n)$ 的空间。\n    3. 用于存储完成顺序的列表 $F$ 需要 $O(n)$ 的空间。\n    4. DFS 过程的递归栈在最坏情况下（例如，路径图）深度可达 $n$，需要 $O(n)$ 的空间。\n    总空间复杂度由图的存储主导，为 $O(n+m)$。\n\n**4. 规范化**\n\n指定的规范化要求两个层面的排序。\n1.  对于每个识别出的 SCC，其顶点索引列表必须按升序排序。\n2.  所有 SCC 的最终列表必须按字典序排序。这意味着，对于表示为已排序列表的两个 SCC $C_1$ 和 $C_2$，如果 $C_1$ 在字典上小于 $C_2$，则 $C_1$ 排在 $C_2$ 之前。\n\n这些排序步骤在核心算法识别出分量后应用。排序的复杂度不是主导性的。如果有 $k$ 个 SCC，其中 $|C_i|$ 是第 $i$ 个分量的大小，对它们全部进行排序需要 $\\sum_{i=1}^{k} O(|C_i| \\log |C_i|)$，其上界为 $O(n \\log n)$。对最终的 $k$ 个分量列表进行排序相比之下可以忽略不计。对于典型的图，总的 $O(n+m)$ 复杂度仍然是主导的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport sys\nimport numpy as np\n\n# It is good practice to increase the recursion limit for deep graphs in Python DFS.\n# The test cases here are small, but this makes the implementation robust.\nsys.setrecursionlimit(200000)\n\ndef solve():\n    \"\"\"\n    Main function to run Kosaraju's algorithm on a fixed set of test cases\n    and print the results in the specified canonical format.\n    \"\"\"\n\n    # Test cases defined as tuples of (n, adjacency_list)\n    test_cases = [\n        # Test 1: Two SCCs {0,1,2} and {3,4,5}, and two trivial ones {6}, {7}\n        (8, [[1], [2], [0, 3], [4], [5], [3], [7], []]),\n        # Test 2: Empty graph\n        (0, []),\n        # Test 3: Single vertex, no edges\n        (1, [[]]),\n        # Test 4: Single vertex, self-loop\n        (1, [[0]]),\n        # Test 5: Fully connected component\n        (5, [[1, 2], [2, 3], [3, 4], [4, 0], [0, 1]]),\n        # Test 6: Two disjoint paths, all vertices are trivial SCCs\n        (6, [[1], [2], [], [4], [5], []]),\n    ]\n    \n    final_results = []\n\n    for n, adj in test_cases:\n        if n == 0:\n            final_results.append(\"[]\")\n            continue\n\n        # --- Kosaraju's Algorithm ---\n        \n        # Step 1: First DFS pass on G to compute finishing order\n        visited = [False] * n\n        finish_stack = []\n        \n        def dfs1(u):\n            visited[u] = True\n            for v in adj[u]:\n                if not visited[v]:\n                    dfs1(v)\n            finish_stack.append(u)\n\n        for i in range(n):\n            if not visited[i]:\n                dfs1(i)\n        \n        # Step 2: Compute the transpose graph G^T\n        adj_t = [[] for _ in range(n)]\n        for u in range(n):\n            for v in adj[u]:\n                adj_t[v].append(u)\n\n        # Step 3: Second DFS pass on G^T in decreasing order of finishing times\n        visited = [False] * n\n        sccs = []\n        \n        def dfs2(u, current_scc):\n            visited[u] = True\n            current_scc.append(u)\n            for v in adj_t[u]:\n                if not visited[v]:\n                    dfs2(v, current_scc)\n\n        while finish_stack:\n            u = finish_stack.pop()\n            if not visited[u]:\n                current_scc = []\n                dfs2(u, current_scc)\n                # Canonicalization Step 1: Sort vertices within the SCC\n                current_scc.sort()\n                sccs.append(current_scc)\n        \n        # Canonicalization Step 2: Sort the list of SCCs lexicographically\n        sccs.sort()\n        \n        # Format the result for this test case as a string\n        case_result_str = str(sccs).replace(\" \", \"\")\n        final_results.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```", "id": "3205772"}, {"introduction": "寻找强连通分量本身固然重要，但其真正的威力在于它能作为解决更复杂图论问题的工具。通过这个练习，你将学会如何利用强连通分量的概念来分析图的宏观结构，并解决一个关于图连通性的优化问题。这展示了将一个复杂图分解为其基本构造块（即强连通分量）的分析威力。", "problem": "考虑有向图 $G = (V, E)$，其中 $V = \\{1, 2, \\dots, 14\\}$ 且\n$$E = \\{(1,3), (3,5), (5,7), (2,4), (4,6), (6,8), (6,7), (7,9), (9,12), (12,14), (9,13), (10,11)\\}.$$\n假设 $G$ 是一个有向无环图 (DAG)。请仅使用基本定义（例如，强连通性和强连通分量的定义）以及关于强连通分量的线性时间算法（如 Tarjan 算法和 Kosaraju 算法）的公认事实，来确定为了使图 $G$ 变为强连通图，最少需要添加多少条有向边（不允许删除任何现有边，也不允许创建平行边或自环）。你的推理应从强连通性的定义以及强连通分量的缩点图的结构开始，并且可以依赖于强连通分量可以在 $O(|V| + |E|)$ 时间内计算这一事实。\n\n请将最终答案表示为一个整数（无单位）。无需四舍五入。", "solution": "问题要求的是，为了使给定的有向图 $G=(V,E)$ 变为强连通图，最少需要添加的有向边数量。该图由顶点集 $V = \\{1, 2, \\dots, 14\\}$ 和边集 $E = \\{(1,3), (3,5), (5,7), (2,4), (4,6), (6,8), (6,7), (7,9), (9,12), (12,14), (9,13), (10,11)\\}$ 定义。问题指出 $G$ 是一个有向无环图 (DAG)。\n\n首先，我们回顾一下相关定义。如果对于任意一对不同的顶点 $(u, v)$，都存在一条从 $u$ 到 $v$ 的有向路径，则称该有向图是强连通的。有向图的强连通分量 (SCC) 是指其是强连通的极大子图。\n\n任何有向图都可以被唯一地划分为其强连通分量。通过将每个强连通分量收缩成一个单一的超级顶点，我们可以形成缩点图，$G_{SCC}$。在 $G_{SCC}$ 中，从超级顶点 $C_i$ 到超级顶点 $C_j$ 存在一条边，当且仅当在原图 $G$ 中，存在一条从 $C_i$ 中的某个顶点到 $C_j$ 中的某个顶点的边。缩点图的一个基本性质是它总是一个有向无环图 (DAG)。\n\n要使原图 $G$ 强连通，我们必须添加一些边，使得任意两个顶点之间都存在路径。这等价于使缩点图 $G_{SCC}$ 强连通。由于 $G_{SCC}$ 是一个 DAG，使其强连通意味着将其简化为单个 SCC，这可以通过添加边来创建一个包含 $G_{SCC}$ 所有超级顶点的环来实现。\n\n问题指出初始图 $G$ 是一个 DAG。根据定义，DAG 中不存在有向环。对于一个包含两个或更多顶点的集合，要形成一个 SCC，必须存在一个包含它们的环。由于 $G$ 没有环，因此 $G$ 中的任何 SCC 都必须由单个顶点组成。因此，对于给定的图 $G$，它的 14 个顶点中的每一个都是其自身的 SCC。\n\n这意味着缩点图 $G_{SCC}$ 与原图 $G$ 同构。$G_{SCC}$ 的超级顶点就是 $G$ 的顶点，而 $G_{SCC}$ 的边就是 $G$ 的边。因此，问题简化为在给定的 DAG $G$ 中添加最少数量的边，使其变为强连通图。\n\n对于一个拥有多于一个顶点的 DAG，要使其强连通，每个顶点都必须至少有一条入边和一条出边。设 $S$ 为“源”顶点（入度为 0 的顶点）的数量， $T$ 为“汇”顶点（出度为 0 的顶点）的数量。要消除所有源点，我们必须添加至少 $S$ 条边，每条边指向一个源点。要消除所有汇点，我们必须添加至少 $T$ 条边，每条边从一个汇点发出。\n\n图论中一个著名的结论指出，如果缩点图不平凡（即，顶点数多于一个），则使图强连通所需添加的最小边数为 $\\max(S, T)$。我们可以通过添加边将汇点“链接”到源点来实现这一点。例如，如果我们有汇点 $\\{t_1, \\dots, t_T\\}$ 和源点 $\\{s_1, \\dots, s_S\\}$，我们可以将这些极端分量组成一个环。最优构造所需的边数恰好是 $\\max(S, T)$。由于我们的图 $G$ 有 $|V| = 14$ 个顶点，这些顶点作为 SCC，且 $14  1$，因此该结论适用。\n\n现在我们必须为给定的图 $G$ 计算 $S$ 和 $T$。我们将计算 $V = \\{1, 2, \\dots, 14\\}$ 中每个顶点的入度和出度。\n\n边集为 $E = \\{(1,3), (3,5), (5,7), (2,4), (4,6), (6,8), (6,7), (7,9), (9,12), (12,14), (9,13), (10,11)\\}$.\n\n入度如下：\n- $\\text{入度}(1) = 0$\n- $\\text{入度}(2) = 0$\n- $\\text{入度}(3) = 1$ (来自顶点 $1$)\n- $\\text{入度}(4) = 1$ (来自顶点 $2$)\n- $\\text{入度}(5) = 1$ (来自顶点 $3$)\n- $\\text{入度}(6) = 1$ (来自顶点 $4$)\n- $\\text{入度}(7) = 2$ (来自顶点 $5$ 和 $6$)\n- $\\text{入度}(8) = 1$ (来自顶点 $6$)\n- $\\text{入度}(9) = 1$ (来自顶点 $7$)\n- $\\text{入度}(10) = 0$\n- $\\text{入度}(11) = 1$ (来自顶点 $10$)\n- $\\text{入度}(12) = 1$ (来自顶点 $9$)\n- $\\text{入度}(13) = 1$ (来自顶点 $9$)\n- $\\text{入度}(14) = 1$ (来自顶点 $12$)\n\n源顶点（入度为 $0$）是 $\\{1, 2, 10\\}$。因此，源点数量为 $S = 3$。\n\n出度如下：\n- $\\text{出度}(1) = 1$ (指向顶点 $3$)\n- $\\text{出度}(2) = 1$ (指向顶点 $4$)\n- $\\text{出度}(3) = 1$ (指向顶点 $5$)\n- $\\text{出度}(4) = 1$ (指向顶点 $6$)\n- $\\text{出度}(5) = 1$ (指向顶点 $7$)\n- $\\text{出度}(6) = 2$ (指向顶点 $7$ 和 $8$)\n- $\\text{出度}(7) = 1$ (指向顶点 $9$)\n- $\\text{出度}(8) = 0$\n- $\\text{出度}(9) = 2$ (指向顶点 $12$ 和 $13$)\n- $\\text{出度}(10) = 1$ (指向顶点 $11$)\n- $\\text{出度}(11) = 0$\n- $\\text{出度}(12) = 1$ (指向顶点 $14$)\n- $\\text{出度}(13) = 0$\n- $\\text{出度}(14) = 0$\n\n汇顶点（出度为 $0$）是 $\\{8, 11, 13, 14\\}$。因此，汇点数量为 $T = 4$。\n\n必须添加的最小边数为 $\\max(S, T)$。\n代入计算出的值，我们得到：\n$$ \\text{最少边数} = \\max(3, 4) = 4 $$\n因此，至少需要添加 $4$ 条边才能使图 $G$ 强连通。", "answer": "$$\n\\boxed{4}\n$$", "id": "3276553"}]}