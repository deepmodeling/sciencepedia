{"hands_on_practices": [{"introduction": "计算图中所有顶点对之间的传递闭包可能是一项计算密集型任务。本练习将介绍一种优雅而高效的方法，它将 Warshall 算法与位运算相结合，通过一次性处理邻接矩阵的整行来显著提升在稠密图上的计算速度。你将学习如何将路径查找的高层逻辑转化为底层的、高性能的位操作。[@problem_id:3279685]", "problem": "给定一个包含 $n$ 个顶点的有向图，以稠密形式表示为一个包含 $n$ 个非负整数的数组。索引 $i$ 处的整数使用位编码从顶点 $i$ 到其他顶点的有向边的存在：当且仅当存在从顶点 $i$ 到顶点 $j$ 的有向边时，该整数的第 $j$ 个最低有效位被设置。该图是 $0$ 索引的。您必须计算可达性的自反传递闭包，定义为关系 $R^{*}$，它包含所有满足从顶点 $i$ 到顶点 $j$ 存在长度大于或等于 $0$ 的路径的顶点对 $(i,j)$。必须使用基于整数编码行的位运算实现的 Warshall 算法来计算该闭包。\n\n使用的基本原理和定义：\n- 一个有向图 $G$ 由一个顶点集 $V=\\{0,1,\\dots,n-1\\}$ 和一个有向边集 $E\\subseteq V\\times V$ 定义。\n- $G$ 的邻接矩阵 $A$ 是一个 $n\\times n$ 矩阵，其中当且仅当 $(i,j)\\in E$ 时，$A_{ij}=1$，否则 $A_{ij}=0$。\n- 传递闭包 $R^{+}$ 是所有有序对 $(i,j)$ 的集合，其中从 $i$ 到 $j$ 存在一条长度大于或等于 $1$ 的路径。\n- 自反传递闭包 $R^{*}$ 通过包含每个 $i\\in V$ 的所有 $(i,i)$ 对来扩充 $R^{+}$，这些对应于长度为 $0$ 的路径。\n- 关系复合是可结合的，布尔半环上的邻接矩阵使用逻辑析取和逻辑合取来表示沿路径的可达性的并集和复合。\n\n您的程序必须：\n- 将每个测试用例解释为一个包含 $n$ 个整数的数组，这些整数如上所述编码邻接矩阵的行。\n- 使用在这些整数上实现的位运算的 Warshall 算法来计算 $R^{*}$。具体来说，您必须通过迭代地允许中间顶点 $k$ 并通过执行与布尔矩阵运算一致的整数位运算来更新从每个 $i$ 可达的顶点集，从而实现该算法。在执行闭包计算之前，您必须通过将对角线元素 $A_{ii}$ 初始设置为 $1$ 来处理自可达性。\n- 以相同的整数编码行形式生成传递闭包：输出一个包含 $n$ 个整数的数组，其中索引 $i$ 处的整数的第 $j$ 位被设置，当且仅当顶点 $j$ 可以通过一条长度大于或等于 $0$ 的路径从顶点 $i$ 到达。\n\n测试套件：\n使用以下测试用例集，每个测试用例由整数编码的邻接行指定。每个邻接输入最初不包括自反边；您必须根据计算 $R^{*}$ 的需要添加它们。\n- 测试用例 $1$ (链)：$n=4$，行 $[2,4,8,0]$。这编码了边 $0\\to 1$，$1\\to 2$，$2\\to 3$。\n- 测试用例 $2$ (无自环的近似完全稠密图)：$n=5$，行 $[30,29,27,23,15]$。对于每个 $i$，都有一条边 $i\\to j$ 指向所有 $j\\neq i$。\n- 测试用例 $3$ (有向环)：$n=6$，行 $[2,4,8,16,32,1]$。这编码了边 $i\\to (i+1)\\pmod 6$。\n- 测试用例 $4$ (混合连通分量)：$n=7$，行 $[2,4,0,16,8,0,0]$。存在一个链 $0\\to 1\\to 2$，一个 $3$ 和 $4$ 之间的双向对，以及孤立顶点 $5$ 和 $6$。\n- 测试用例 $5$ (单个顶点)：$n=1$，行 $[0]$。\n- 测试用例 $6$ (空图)：$n=0$，行 $[]$。\n\n答案规范：\n- 对于每个测试用例，以具有相同索引约定的整数数组形式输出自反传递闭包。\n- 最终输出格式必须是单行，包含一个由逗号分隔的、用方括号括起来的各测试用例结果列表，其中每个测试用例的结果本身是一个由逗号分隔的、用方括号括起来的整数列表，并且没有任何空格。例如，一个有效的格式是 $[[a_{1,1},\\dots,a_{1,n_1}],[a_{2,1},\\dots,a_{2,n_2}],\\dots]$，其中 $a_{t,i}$ 是整数，$n_t$ 是测试用例 $t$ 中的顶点数。\n\n您的任务是实现计算，并为提供的测试套件生成与此确切格式匹配的单行输出。输出中的值必须仅为指定的整数和整数列表。", "solution": "该问题要求计算有向图 $G=(V,E)$ 的自反传递闭包，记为 $R^*$，其中 $V = \\{0, 1, \\dots, n-1\\}$。该图以紧凑的位格式提供，其中一个包含 $n$ 个整数的数组表示邻接矩阵 $A$。索引 $i$ 处的整数编码了 $A$ 的第 $i$ 行，第 $j$ 位对应于条目 $A_{ij}$。我们被要求使用以位运算实现的 Warshall 算法。\n\n首先，我们对问题进行形式化。如果从顶点 $i$ 到顶点 $j$ 存在一条长度为 $0$ 或更长的路径，则自反传递闭包 $R^*$ 包含对 $(i,j)$。任何顶点到其自身都存在一条长度为 $0$ 的路径。因此，$R^*$ 必须包含所有 $i \\in V$ 的所有对 $(i,i)$。问题陈述正确地指导我们通过在主计算之前确保可达性矩阵的所有对角线条目均为 $1$ 来实现这一点。这等同于从表示关系 $A \\cup I$ 的矩阵开始，其中 $A$ 是邻接关系，$I$ 是恒等关系。在我们的位表示中，对于从 $0$ 到 $n-1$ 的每个行索引 $i$，我们必须设置该索引处整数的第 $i$ 位。这通过位或运算完成：$M_i \\leftarrow M_i \\lor (1 \\ll i)$，其中 $M_i$ 是第 $i$ 行的整数，$\\ll$ 表示按位左移运算符。我们将得到的整数数组记为 $M$。\n\n计算的核心是 Warshall 算法。它通过系统地考虑所有路径的所有可能中间顶点来计算传递闭包。设 $M^{(k)}_{ij}$ 是一个布尔值，表示是否仅使用集合 $\\{0, 1, \\dots, k-1\\}$ 中的中间顶点，就存在从顶点 $i$ 到顶点 $j$ 的路径。该算法以 $M^{(0)}$ 作为（自反的）邻接矩阵开始，并从 $k=0$ 迭代到 $n-1$。更新规则由布尔半环上的递推关系给出：\n$$M^{(k)}_{ij} = M^{(k-1)}_{ij} \\lor (M^{(k-1)}_{ik} \\land M^{(k-1)}_{kj})$$\n这表明，如果满足以下任一条件，则存在一条使用至多为 $k-1$ 的中间顶点从 $i$ 到 $j$ 的路径：\n1. 已经存在一条使用至多为 $k-2$ 的中间顶点从 $i$ 到 $j$ 的路径。\n2. 存在一条从 $i$ 到 $k$ 的路径和一条从 $k$ 到 $j$ 的路径，两者都使用至多为 $k-2$ 的中间顶点。\n\n实现的关键洞见在于，循环可以按中间顶点 $k$ 在最外层的顺序排列。状态可以就地更新。设被更新的单个矩阵为 $M$。算法如下：\n`for k from 0 to n-1:`\n  `for i from 0 to n-1:`\n    `for j from 0 to n-1:`\n      `M[i,j] := M[i,j] OR (M[i,k] AND M[k,j])`\n\n我们必须将此矩阵公式转换为对我们整数编码行的位运算。整数 $M_i$ 表示矩阵的整个第 $i$ 行，即 $(M_{i,0}, M_{i,1}, \\dots, M_{i,n-1})$。我们来分析固定行 $i$ 和中间顶点 $k$ 的更新。我们检查谓词 $M_{ik}$，它测试从 $i$到 $k$ 是否存在路径。\n- 如果 $M_{ik}$ 为 $0$ (假)，则 $(M_{ik} \\land M_{kj})$ 始终为 $0$。更新规则简化为 $M_{ij} \\leftarrow M_{ij}$。因此，第 $i$ 行不改变。\n- 如果 $M_{ik}$ 为 $1$ (真)，则对于所有 $j \\in \\{0, \\dots, n-1\\}$，行 $i$ 的更新规则变为 $M_{ij} \\leftarrow M_{ij} \\lor M_{kj}$。这意味着如果我们能从 $i$ 到达 $k$，那么我们就能从 $i$ 到达任何可以从 $k$ 到达的顶点 $j$。从 $i$ 可达的新顶点集是旧集合与从 $k$ 可达的顶点集的并集。\n\n这个可达性集合的并集直接对应于整数行上的位或运算。对所有 $j$ 的运算 $M_{ij} \\leftarrow M_{ij} \\lor M_{kj}$ 等价于 $M_i \\leftarrow M_i \\lor M_k$。\n\n因此，Warshall 算法的完整位运算实现如下：\n1. 设 $M$ 是表示图的整数数组。\n2. 对于每个顶点 $i \\in \\{0, \\dots, n-1\\}$，添加一个自环以确保自反性：$M_i \\leftarrow M_i \\lor (1 \\ll i)$。\n3. 对于每个中间顶点 $k \\in \\{0, \\dots, n-1\\}$：\n4.  对于每个起始顶点 $i \\in \\{0, \\dots, n-1\\}$：\n5.   检查是否存在从 $i$ 到 $k$ 的路径。如果 $M_i$ 的第 $k$ 位被设置，则为真。这可以通过表达式 $(M_i \\land (1 \\ll k)) \\neq 0$ 来测试。\n6.   如果存在这样的路径，则通过与 $k$ 的可达性取并集来更新 $i$ 的可达性：$M_i \\leftarrow M_i \\lor M_k$。\n\n这些循环完成后，数组 $M$ 将包含最终自反传递闭包矩阵 $R^*$ 的整数编码行。此过程正确且高效地解决了指定的问题。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the reflexive transitive closure problem for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [2, 4, 8, 0],              # Test case 1: n=4, chain 0->1->2->3\n        [30, 29, 27, 23, 15],     # Test case 2: n=5, almost complete graph\n        [2, 4, 8, 16, 32, 1],     # Test case 3: n=6, cycle 0->1->...->5->0\n        [2, 4, 0, 16, 8, 0, 0],   # Test case 4: n=7, mixed components\n        [0],                       # Test case 5: n=1, single vertex\n        [],                        # Test case 6: n=0, empty graph\n    ]\n\n    results = []\n    for adj_rows in test_cases:\n        n = len(adj_rows)\n        \n        if n == 0:\n            results.append([])\n            continue\n\n        # Use numpy array with a sufficiently large unsigned integer type\n        # to handle bitwise operations for up to 64 vertices.\n        # This also matches the code structure provided in the problem.\n        R = np.array(adj_rows, dtype=np.uint64)\n        \n        # Step 1: Add self-loops to compute the reflexive closure.\n        # This corresponds to initializing the reachability matrix with the\n        # identity matrix OR-ed with the adjacency matrix.\n        for i in range(n):\n            R[i] |= (np.uint64(1)  i)\n            \n        # Step 2: Apply Warshall's algorithm using bitwise operations.\n        # The outer loop must be over the intermediate vertex k.\n        for k in range(n):\n            for i in range(n):\n                # If there is a path from i to k (i.e., k-th bit is set in R[i])\n                if (R[i]  (np.uint64(1)  k)):\n                    # Then i can reach everything that k can reach.\n                    # This is a union of reachability sets, which corresponds to\n                    # a bitwise OR on the integer-encoded rows.\n                    R[i] |= R[k]\n                    \n        results.append(R.tolist())\n\n    # Final print statement in the exact required format.\n    # e.g., [[r1_1,r1_2],[r2_1,r2_2,r2_3],...] with no spaces.\n    inner_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(inner_results)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3279685"}, {"introduction": "传递闭包告诉我们两个顶点之间是否存在路径，而传递规约 (transitive reduction) 则通过移除冗余的边来揭示图的本质“骨架”。对于有向无环图 (DAG)，这种最小化的表示是唯一的，它能提供关于图结构的重要洞见。本练习将挑战你进行逆向思维：在给定完整可达性信息的情况下，推导出定义该可达性的最小直接连接集合。[@problem_id:3279619]", "problem": "给定一个有限顶点集上的有向无环图（DAG）的传递闭包矩阵，你的任务是重构其唯一的传递归约：一个在相同顶点集上的、具有最少边数的有向图，其可达性关系与给定的传递闭包相匹配。请纯粹从数学和算法角度进行处理，不涉及任何物理单位。\n\n作为基本依据的定义：\n- 设一个有向无环图（DAG）是一个没有有向环的有向图。对于一个顶点集为 $V$、边集为 $E \\subseteq V \\times V$ 的 DAG，其可达性关系 $R \\subseteq V \\times V$ 定义为：当且仅当存在一条从 $u$ 到 $v$ 的长度至少为一的有向路径时，$(u,v) \\in R$。一个 DAG 的传递闭包正是这个可达性关系。\n- 有限集 $V$ 上的一个二元关系 $R$ 是传递的，如果对于所有 $u,v,w \\in V$，只要 $(u,w) \\in R$ 且 $(w,v) \\in R$，那么 $(u,v) \\in R$。对于 DAG 的可达性关系，$R$ 也是反对称的：如果 $(u,v) \\in R$ 且 $(v,u) \\in R$，那么 $u=v$。\n- 一个 DAG 的传递归约是具有最少可能边数的有向图 $G_{\\min}=(V,E_{\\min})$，其可达性关系与原始 DAG 的可达性关系相等。对于 DAG 而言，这个传递归约是唯一的。\n\n此问题的输入模型：\n- 你将得到一个布尔矩阵 $T \\in \\{0,1\\}^{n \\times n}$，它表示某个顶点索引为 $0,1,\\dots,n-1$ 的 DAG 的传递闭包（严格可达性）。矩阵 $T$ 满足以下性质：对于所有 $i$，$T[i][i]=0$（不存在长度至少为一的自可达路径）；它是反对称的，即如果 $T[i][j]=1$，则 $T[j][i]=0$；并且它是传递的，即如果 $T[i][k]=1$ 且 $T[k][j]=1$，则 $T[i][j]=1$。\n- 你的目标是计算传递归约图的邻接矩阵 $A \\in \\{0,1\\}^{n \\times n}$，该图的可达性关系等于 $T$。矩阵 $A$ 必须对所有 $i$ 满足 $A[i][i]=0$。\n\n需要实现的推导过程：\n- 仅从上述定义出发，推导出一个算法，该算法能从 $T$ 重构出最小边集，使得其可达性关系恰好为 $T$。该算法必须对任何 $n \\in \\mathbb{N}$ 以及任何满足上述性质的 $T$ 都有效，并且应在多项式时间内运行。\n\n程序规格：\n- 实现一个程序，对于每个提供的测试用例 $T$，计算其传递归约的邻接矩阵 $A$，并以行主序输出扁平化的 $A$ 作为 $\\{0,1\\}$ 中的整数列表。对于矩阵 $A \\in \\{0,1\\}^{n \\times n}$，其扁平化形式为列表 $[A[0][0],A[0][1],\\dots,A[0][n-1],A[1][0],\\dots,A[n-1][n-1]]$。\n- 你的程序必须将所有测试用例的输出聚合到单行中，格式完全如下：一个单独的方括号列表，其元素是每个测试用例的扁平化列表，其中不含任何空格。例如，对于两个扁平化输出分别为 $[0,1]$ 和 $[1,0,0,1]$ 的测试用例，最终输出必须是 [[0,1],[1,0,0,1]]。\n\n测试套件：\n对于下面的每个测试用例，输入是一个表示某个 DAG 传递闭包的矩阵 $T$。\n\n- 测试用例 1 ($n=4$): 4 个顶点上的全序（链），因此当且仅当 $i  j$ 时 $T[i][j]=1$。\n$$\nT_1 = \\begin{bmatrix}\n0  1  1  1 \\\\\n0  0  1  1 \\\\\n0  0  0  1 \\\\\n0  0  0  0\n\\end{bmatrix}\n$$\n\n- 测试用例 2 ($n=4$): 一个具有一个源点和一个汇点的菱形结构。\n$$\nT_2 = \\begin{bmatrix}\n0  1  1  1 \\\\\n0  0  0  1 \\\\\n0  0  0  1 \\\\\n0  0  0  0\n\\end{bmatrix}\n$$\n\n- 测试用例 3 ($n=3$): 一个在闭包中存在冗余长边的情况（该边将在归约中被排除）。\n$$\nT_3 = \\begin{bmatrix}\n0  1  1 \\\\\n0  0  1 \\\\\n0  0  0\n\\end{bmatrix}\n$$\n\n- 测试用例 4 ($n=5$): 两个不连通分量，一个长度为 3 的链和一个单边。\n$$\nT_4 = \\begin{bmatrix}\n0  1  1  0  0 \\\\\n0  0  1  0  0 \\\\\n0  0  0  0  0 \\\\\n0  0  0  0  1 \\\\\n0  0  0  0  0\n\\end{bmatrix}\n$$\n\n- 测试用例 5 ($n=1$): 一个孤立顶点。\n$$\nT_5 = \\begin{bmatrix}\n0\n\\end{bmatrix}\n$$\n\n输出规格：\n- 对于每个测试用例 $T_k$，输出其传递归约的扁平化邻接矩阵 $A_k$，作为一个由 0 和 1 组成的整数列表。\n- 最终输出必须是包含所有测试用例的嵌套列表的单行，不含空格，格式完全如下：\n  $$\\texttt{[[a\\_1\\_0,a\\_1\\_1,\\dots],[a\\_2\\_0,a\\_2\\_1,\\dots],\\dots]}$$\n  其中 $\\texttt{[a\\_k\\_0,a\\_k\\_1,\\dots]}$ 是测试用例 $k$ 的扁平化邻接矩阵。\n\n你的解决方案必须是一个完整、可运行的程序，执行此计算并精确打印指定的单行输出。不需要也不允许用户输入。", "solution": "所陈述的问题是有效的。这是一个在图算法领域内定义明确、有科学依据的问题，基于有向无环图（DAG）、传递闭包和传递归约的标准定义。所有提供的信息都是自洽、一致和客观的。因此，我们可以着手解决。\n\n任务是根据给定的传递闭包矩阵 $T \\in \\{0, 1\\}^{n \\times n}$，重构一个 DAG 的唯一传递归约的邻接矩阵 $A \\in \\{0, 1\\}^{n \\times n}$。顶点从 $0$ 到 $n-1$ 索引。\n\n根据定义，一个 DAG 的传递归约是具有与原始 DAG 相同可达性关系的边数最少的图。在传递归约中，从顶点 $u$ 到顶点 $v$ 的边（记为 $(u,v)$）存在，当且仅当在原始图中存在一条从 $u$ 到 $v$ 的路径，且该路径的长度恰好为 $1$。任何长度大于 $1$ 的路径都被认为是“可归约的”，因为它提供的可达性是路径关系传递性的结果。例如，如果存在一条路径 $u \\to w \\to v$，那么从 $u$到 $v$ 的可达性是由从 $u$ 到 $w$ 和从 $w$ 到 $v$ 的可达性传递地蕴含的。\n\n我们得到的是传递闭包矩阵 $T$，其中 $T[i][j]=1$ 表示存在一条从顶点 $i$ 到顶点 $j$ 的长度至少为一的路径。我们的目标是找到传递归约的邻接矩阵 $A$，其中 $A[i][j]=1$ 表示在这个最小图中存在一条直接边 $(i,j)$。\n\n一条边 $(i,j)$ 存在于传递归约中，当且仅当：\n1. 存在一条从 $i$ 到 $j$ 的路径。\n2. 不存在从 $i$ 到 $j$ 的长度大于 $1$ 的路径。\n\n第一个条件由输入矩阵 $T$ 直接给出：从 $i$ 到 $j$ 的路径存在，当且仅当 $T[i][j]=1$。\n\n第二个条件需要更仔细的审视。一条从 $i$ 到 $j$ 的长度大于 $1$ 的路径必须包含至少一个中间顶点。也就是说，必须存在某个顶点 $k$（其中 $k \\neq i$ 且 $k \\neq j$），使得该路径可以分解为一条从 $i$ 到 $k$ 的路径和一条从 $k$ 到 $j$ 的路径。由于矩阵 $T$ 包含了所有可达性信息，这样一条复合路径的存在等价于存在一个顶点 $k$，使得 $T[i][k]=1$ 且 $T[k][j]=1$。注意，由于图是 DAG，如果存在从 $i$ 到 $k$ 和从 $k$ 到 $j$ 的路径，我们不可能有 $i=k$ 或 $j=k$（因为这将意味着 $T[i][i]=1$ 或 $T[j][j]=1$，而这对于长度 $\\ge 1$ 的路径是被排除的）。\n\n因此，一条边 $(i,j)$ 属于传递归约，当且仅当 $T[i][j]=1$ 并且不存在顶点 $k$ 使得 $T[i][k]=1$ 且 $T[k][j]=1$。\n\n这个条件可以用布尔矩阵乘法优雅地表达。让我们将矩阵 $T^2$ 定义为 $T$ 与自身的布尔矩阵乘积：\n$$\n(T^2)[i][j] = \\bigvee_{k=0}^{n-1} (T[i][k] \\land T[k][j])\n$$\n在此表达式中，$\\lor$ 表示逻辑或运算，$\\land$ 表示逻辑与运算。当且仅当存在至少一个顶点 $k$ 作为从 $i$ 到 $j$ 路径上的中间站时，条目 $(T^2)[i][j]$ 才为 $1$。换句话说，$(T^2)[i][j]=1$ 表示存在一条从 $i$ 到 $j$ 的长度至少为 $2$ 的路径（具体来说，是由连接两条记录在 $T$ 中的路径形成的）。\n\n借此，我们可以将边 $(i,j)$ 存在于传递归约中的条件形式化。邻接矩阵中对应的条目 $A[i][j]$ 为 $1$，当且仅当 $T[i][j]=1$ 且 $(T^2)[i][j]=0$。这可以写作：\n$$\nA[i][j] = T[i][j] \\land \\neg((T^2)[i][j])\n$$\n其中 $\\neg$ 是逻辑非运算符。\n\n值得注意的是，因为 $T$ 是传递的，如果 $(T^2)[i][j]=1$，那么 $T[i][j]=1$ 也必定成立。这是因为 $(T^2)[i][j]=1$ 意味着存在一个 $k$ 使得 $T[i][k]=1$ 且 $T[k][j]=1$。根据 $T$ 的传递性，这直接蕴含了 $T[i][j]=1$。因此，$T^2$ 中的关系集合是 $T$ 中关系集合的子集。我们的任务是找出在 $T$ 中但不在 $T^2$ 中的关系。\n\n因此，算法如下：\n1. 给定 $n \\times n$ 的传递闭包矩阵 $T$。\n2. 使用布尔矩阵乘法计算矩阵 $T^2 = T \\times T$。可以使用标准的矩阵乘法算法，其时间复杂度为 $O(n^3)$。\n3. 构建传递归约的邻接矩阵 $A$。对于每对索引 $(i,j)$，如果 $T[i][j]=1$ 且 $(T^2)[i][j]=0$，则设置 $A[i][j]=1$。否则，设置 $A[i][j]=0$。此步骤耗时 $O(n^2)$。\n总体时间复杂度由矩阵乘法主导，为多项式时间复杂度 $O(n^3)$，满足问题要求。这个推导出的算法对任何 DAG 都是正确的，因为其传递归约是唯一的，并且完全由其可达性关系确定。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the transitive reduction problem for a suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each test case is a matrix T representing the transitive closure of a DAG.\n    test_cases = [\n        # Test case 1 (n=4): a total order (chain)\n        [[0, 1, 1, 1],\n         [0, 0, 1, 1],\n         [0, 0, 0, 1],\n         [0, 0, 0, 0]],\n\n        # Test case 2 (n=4): a diamond shape\n        [[0, 1, 1, 1],\n         [0, 0, 0, 1],\n         [0, 0, 0, 1],\n         [0, 0, 0, 0]],\n\n        # Test case 3 (n=3): a chain with a redundant edge\n        [[0, 1, 1],\n         [0, 0, 1],\n         [0, 0, 0]],\n\n        # Test case 4 (n=5): two disconnected components\n        [[0, 1, 1, 0, 0],\n         [0, 0, 1, 0, 0],\n         [0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 1],\n         [0, 0, 0, 0, 0]],\n\n        # Test case 5 (n=1): a single isolated vertex\n        [[0]]\n    ]\n\n    results = []\n    for t_matrix_list in test_cases:\n        # Convert the input list-of-lists to a NumPy array for efficient computation.\n        T = np.array(t_matrix_list, dtype=int)\n\n        # Principle: An edge (i,j) is in the transitive reduction if there is a\n        # path from i to j (T[i,j]=1), but no path of length  1. A path of\n        # length  1 from i to j implies the existence of an intermediate vertex k\n        # such that there is a path from i to k and from k to j.\n\n        # We can find all pairs (i, j) connected by a path of length = 2\n        # by computing the boolean square of the transitive closure matrix T.\n        # The numpy '@' operator performs matrix multiplication.\n        # (T @ T)[i, j] will be  0 if and only if there exists at least one\n        # intermediate vertex k on a path from i to j.\n        T_squared = (T @ T).astype(bool)\n\n        # The adjacency matrix A of the transitive reduction contains an edge (i, j)\n        # if and only if T[i, j] is true AND (T^2)[i, j] is false.\n        # We perform this logical operation element-wise.\n        A = T.astype(bool)  ~T_squared\n\n        # Convert the resulting boolean matrix back to integers (0s and 1s),\n        # flatten it into row-major order, and convert to a list.\n        result = A.astype(int).flatten().tolist()\n        results.append(result)\n\n    # Final print statement must be a single line in the exact specified format.\n    # str(results) produces a string with spaces, e.g., '[[0, 1], [1, 0]]'.\n    # .replace(\" \", \"\") removes all spaces to match the output specification.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3279619"}, {"introduction": "在许多现实世界的应用中，图是随时间动态变化的。每当图发生微小变化（例如增加一条边）时，从头重新计算传递闭包是极其低效的。这个高级练习将引导你推导出一个“增量”算法来更新已有的传递闭包，教会你如何分析一个局部变化是如何在整个图中传播并产生新路径的。[@problem_id:3279786]", "problem": "给定一个顶点集为 $\\{0,1,\\dots,n-1\\}$ 的有向图，由一个二元邻接矩阵 $A \\in \\{0,1\\}^{n \\times n}$ 表示。对于顶点 $i$ 和 $j$，如果存在一条从 $i$ 到 $j$ 的长度至少为 $1$ 的有向路径，我们称 $j$ 是从 $i$ 可达的。$A$ 的传递闭包 $T \\in \\{0,1\\}^{n \\times n}$ 记录了可达性：当且仅当在由 $A$ 定义的图中存在一条从 $i$ 到 $j$ 的长度至少为 $1$ 的有向路径时，$T[i][j]=1$，否则 $T[i][j]=0$。注意，$T[i][i]=1$ 当且仅当存在一个经过 $i$ 的有向环。\n\n请从有向路径和可达性的核心定义出发，推导出一个增量算法，该算法在向图中添加一条有向边 $(a,b)$ 时，将 $T$ 更新为 $T'$。您的推导必须仅基于以下基础进行推理：\n- 有向图的邻接矩阵 $A$ 和传递闭包 $T$ 的定义。\n- 有向路径的定义，即一个顶点序列，其中每对连续的顶点都对应图中的一条边。\n- 关于二元关系的基本命题逻辑（例如，可达性是邻接关系的传递闭包）。\n\n您不得依赖、引用或假设任何现有的关于传递闭包或其更新的特定算法公式；相反，您应逻辑地推导出因添加一条边而可能变得新可达的点对集合。\n\n在推导出算法后，请将其实现为一个程序，对下面的每个测试用例执行以下步骤：\n1. 构造大小为 $n \\times n$ 的初始邻接矩阵 $A$。\n2. 计算初始传递闭包 $T$，该闭包编码了长度至少为 $1$ 的路径。\n3. 在添加单条边 $(a,b)$ 时，应用您的增量更新方法以获得更新后的闭包 $T'$，而不是从头重新计算闭包。\n4. 对于每个测试用例，计算新可达有序对的整数数量，定义为满足 $T[i][j]=0$ 和 $T'[i][j]=1$ 的索引对 $(i,j)$ 的数量。\n\n测试套件。每个测试用例以 $(n, \\text{边列表}, (a,b))$ 的形式给出，其中 $n$ 是顶点数，边列表是初始包含的有向边集合，而 $(a,b)$ 是要添加的单条边。所有顶点的编号从 $0$ 到 $n-1$。请精确使用以下五个测试用例：\n- 测试用例 $1$：$(n=5, \\{(0,1),(1,2),(3,4)\\}, (2,3))$。\n- 测试用例 $2$：$(n=4, \\{(0,1),(1,2),(2,3)\\}, (0,3))$。\n- 测试用例 $3$：$(n=3, \\{(0,1),(1,0),(1,2)\\}, (0,1))$。\n- 测试用例 $4$：$(n=2, \\{(0,1)\\}, (1,1))$。\n- 测试用例 $5$：$(n=3, \\{(0,1),(1,2)\\}, (2,0))$。\n\n您的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔列表（例如，$[x_1,x_2,x_3,x_4,x_5]$），$x_k$ 是测试用例 $k$ 的新可达有序对的整数数量。\n\n所有输出都是无单位的整数。不需要外部输入；程序必须嵌入上述测试套件并打印所需的单行输出。", "solution": "该问题要求推导一个增量更新算法，用于在有向图中添加单条边时更新其传递闭包。推导必须基于第一性原理。随后，需要实现此算法并将其应用于特定的测试套件。\n\n对问题陈述的初步验证确认其在图论方面具有科学依据，是良构的、客观且内部一致的。未发现任何缺陷。\n\n**增量更新算法的推导**\n\n设该有向图为 $G=(V, E)$，其中 $V = \\{0, 1, \\dots, n-1\\}$ 是顶点集，E 是边集。该图由其邻接矩阵 $A \\in \\{0, 1\\}^{n \\times n}$ 表示，其中如果 $(i,j) \\in E$，则 $A[i,j] = 1$，否则 $A[i,j] = 0$。\n\n$G$ 的传递闭包由矩阵 $T \\in \\{0, 1\\}^{n \\times n}$ 表示。根据定义，当且仅当存在一条从顶点 $i$ 到顶点 $j$ 的长度至少为 $1$ 的有向路径时，$T[i,j] = 1$。否则，$T[i,j] = 0$。\n\n我们要向图 $G$ 中添加一条有向边 $(a, b)$，得到一个新图 $G' = (V, E \\cup \\{(a,b)\\})$。我们需要通过更新原始闭包 $T$ 来找到 $G'$ 的传递闭包 $T'$，而不是从头重新计算。核心任务是识别出那些变得新可达的有序对 $(i,j)$。如果 $T[i,j]=0$ 且 $T'[i,j]=1$，则该对 $(i,j)$ 是新可达的。\n\n根据定义，$G$ 中的任何路径也是 $G'$ 中的路径。因此，如果 $T[i,j] = 1$，那么必然有 $T'[i,j] = 1$。新的可达性连接（即 $T'[i,j]=1$ 但 $T[i,j]=0$ 的情况）只能由利用了新添加的边 $(a,b)$ 的 $G'$ 中的路径产生。\n\n考虑一条在 $G'$ 中从顶点 $i$ 到顶点 $j$ 且使用了边 $(a,b)$ 的路径。这样的路径必然是三部分的拼接：\n1. 从顶点 $i$ 到顶点 $a$ 的路径。\n2. 新的边 $(a,b)$。\n3. 从顶点 $b$ 到顶点 $j$ 的路径。\n\n我们来分析到 $a$ 和从 $b$ 出发的路径。这些子路径必须存在于原始图 $G$ 中。\n从一个顶点到其自身的“路径”可以长度为 $0$。为了正式处理 $i=a$ 或 $j=b$ 的情况，使用自反传递闭包（表示为 $T^*$）会很方便。矩阵 $T^*$ 定义为：如果存在一条从 $i$ 到 $j$ 长度为 $0$ 或更长的路径，则 $T^*[i,j] = 1$。它可以通过将 $T$ 的对角线元素设置为 $1$ 来计算，因为从任何顶点到其自身都存在一条长度为 $0$ 的路径。在矩阵代数中，$T^* = T \\lor I$，其中 $I$ 是 $n \\times n$ 的单位矩阵，$\\lor$ 表示按位逻辑或运算。\n\n因此，在 $G'$ 中存在一条使用边 $(a,b)$ 的路径 $i \\to j$ 的条件可以表述为：\n- 在 $G$ 中存在一条从 $i$ 到 $a$ 长度 $\\ge 0$ 的路径。这等价于逻辑条件 $T^*[i,a]=1$。\n- 并且，在 $G$ 中存在一条从 $b$ 到 $j$ 长度 $\\ge 0$ 的路径。这等价于逻辑条件 $T^*[b,j]=1$。\n\n综合这些，当且仅当 $(T^*[i,a] \\land T^*[b,j]) = 1$ 时，存在一条通过新边 $(a,b)$ 从 $i$ 到 $j$ 的路径，其中 $\\land$ 是逻辑与运算。\n\n这个表达式捕捉了由新边创建的所有可达性。新图 $G'$ 的完整传递闭包 $T'$ 可以表示为旧可达性与这个新可达性来源的并集：\n$$T'[i,j] = T[i,j] \\lor (T^*[i,a] \\land T^*[b,j])$$\n\n我们关心的是*新*可达对的数量。如果一个对 $(i,j)$ 在旧闭包 $T$ 中的条目为 $0$，而在新闭包 $T'$ 中的条目为 $1$，那么它就是新可达的。根据 $T'$ 的方程，这恰好在以下情况发生：\n$$T[i,j] = 0 \\quad \\text{and} \\quad (T^*[i,a] \\land T^*[b,j]) = 1$$\n\n这个推导为我们提供了一个直接的算法来寻找新可达的对：\n1.  从初始传递闭包矩阵 $T$ 开始。\n2.  计算自反传递闭包 $T^* = T \\lor I$。\n3.  识别出在 $G$ 中所有能到达 $a$ 的顶点集合 $P_a$（包括 $a$ 本身）。该集合为 $P_a = \\{i \\in V \\mid T^*[i,a]=1\\}$。这对应于 $T^*$ 第 $a$ 列中非零条目的索引。\n4.  识别出在 $G$ 中所有从 $b$ 可达的顶点集合 $S_b$（包括 $b$ 本身）。该集合为 $S_b = \\{j \\in V \\mid T^*[b,j]=1\\}$。这对应于 $T^*$ 第 $b$ 行中非零条目的索引。\n5.  所有潜在新路径的集合是笛卡尔积 $P_a \\times S_b$。\n6.  为了找到严格新增路径的数量，遍历所有对 $(i,j) \\in P_a \\times S_b$，当且仅当 $T[i,j]=0$ 时，将计数器加一。\n\n该过程通过仅考虑由单条边 $(a,b)$ 引入的结构变化来正确计算新可达对的数量，符合要求。对于从邻接矩阵 $A$ 初始计算 $T$，像 Floyd-Warshall 算法这样的标准算法是合适且高效的。Floyd-Warshall 算法通过迭代地将每个顶点视为所有路径中的潜在中间节点来计算传递闭包。\n\n**应用于测试用例**\n\n对于每个测试用例 $(n, \\text{边列表}, (a,b))$：\n1.  从给定的边列表构造一个 $n \\times n$ 的邻接矩阵 $A$。\n2.  使用 Floyd-Warshall 算法从 $A$ 计算初始传递闭包 $T$。\n3.  通过对 $T$ 和单位矩阵 $I$ 进行逻辑或运算得到自反闭包 $T^*$。\n4.  确定集合 $P_a = \\{i \\mid T^*[i,a]=1\\}$ 和 $S_b = \\{j \\mid T^*[b,j]=1\\}$。\n5.  计算满足 $i \\in P_a$，$j \\in S_b$ 且 $T[i,j]=0$ 的对 $(i, j)$ 的数量。这个计数就是该测试用例的最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the incremental transitive closure problem for a given test suite.\n    \"\"\"\n    \n    # Test suite as defined in the problem statement.\n    # Each case is (n, edge_list, (a, b))\n    test_cases = [\n        (5, [(0, 1), (1, 2), (3, 4)], (2, 3)),\n        (4, [(0, 1), (1, 2), (2, 3)], (0, 3)),\n        (3, [(0, 1), (1, 0), (1, 2)], (0, 1)),\n        (2, [(0, 1)], (1, 1)),\n        (3, [(0, 1), (1, 2)], (2, 0)),\n    ]\n\n    results = []\n\n    for n, edges, new_edge in test_cases:\n        a, b = new_edge\n\n        # Step 1: Construct the initial adjacency matrix A\n        A = np.zeros((n, n), dtype=int)\n        for u, v in edges:\n            A[u, v] = 1\n\n        # Step 2: Compute the initial transitive closure T\n        # We use the Floyd-Warshall algorithm for this standard computation.\n        T = np.copy(A)\n        for k in range(n):\n            for i in range(n):\n                for j in range(n):\n                    T[i, j] = T[i, j] or (T[i, k] and T[k, j])\n\n        # Step 3: Apply the incremental update logic to find new paths.\n        \n        # First, compute the reflexive-transitive closure T_star.\n        # T_star[i, j] = 1 if there's a path of length = 0.\n        # This is equivalent to T OR'd with the identity matrix.\n        I = np.identity(n, dtype=int)\n        T_star = np.logical_or(T, I).astype(int)\n\n        # According to the derived algorithm, a new path from i to j is formed\n        # if and only if i can reach a (or i is a) and b can reach j (or b is j),\n        # and there was no pre-existing path from i to j.\n\n        # Find all vertices that can reach a (predecessors in closure graph).\n        predecessors_of_a = np.where(T_star[:, a] == 1)[0]\n        \n        # Find all vertices reachable from b (successors in closure graph).\n        successors_of_b = np.where(T_star[b, :] == 1)[0]\n\n        # Step 4: Compute the integer count of newly reachable ordered pairs.\n        newly_reachable_count = 0\n        for i in predecessors_of_a:\n            for j in successors_of_b:\n                # Check if this path candidate did NOT exist before.\n                if T[i, j] == 0:\n                    newly_reachable_count += 1\n        \n        results.append(newly_reachable_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3279786"}]}