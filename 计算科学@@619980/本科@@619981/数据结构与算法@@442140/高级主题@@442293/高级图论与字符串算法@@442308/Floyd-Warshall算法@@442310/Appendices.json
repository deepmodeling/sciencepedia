{"hands_on_practices": [{"introduction": "理解一个算法最好的方式之一就是亲手执行它。这项练习 [@problem_id:3235663] 将引导你在一个带有负权重边的小型图上手动、一步步地执行 Floyd-Warshall 算法。你的目标是观察距离矩阵如何演变，并精确定位到负权环路被检测到的那一刻，从而揭开该算法一个关键特性的神秘面纱。", "problem": "考虑以下有向加权图，该图有 $n=6$ 个顶点，标记为 $1,2,3,4,5,6$。其加权邻接矩阵 $W$ 如下：\n$$\nW \\;=\\;\n\\begin{pmatrix}\n0   3   \\infty   \\infty   \\infty   \\infty\\\\\n\\infty   0   4   2   \\infty   \\infty\\\\\n-10   \\infty   0   5   \\infty   \\infty\\\\\n\\infty   \\infty   \\infty   0   1   \\infty\\\\\n\\infty   \\infty   \\infty   \\infty   0   1\\\\\n\\infty   \\infty   \\infty   1   \\infty   0\n\\end{pmatrix}.\n$$\n假设采用一个标准的全对最短路径动态规划程序，该程序基于以下基本定义：路径是由有向边连接的顶点序列；路径的权重是其边权重之和；最短路径是在所有具有相同端点的路径中总权重最小的路径。该程序分阶段 $k=0,1,2,\\dots,6$ 进行，维护一个距离矩阵 $D^{(k)}$ 和一个后继矩阵 $\\mathrm{next}^{(k)}$。在阶段 $k$，这两个矩阵共同编码了所有有序顶点对 $(i,j)$ 的最短路径信息，并遵循一个不变式：在阶段 $k$ 考虑的任何路径，其所有内部顶点都必须来自集合 $\\{1,2,\\dots,k\\}$。初始时，$D^{(0)}=W$，而后继矩阵 $\\mathrm{next}^{(0)}$ 的定义如下：如果 $W[i,j]  \\infty$ 且 $i \\neq j$，则 $\\mathrm{next}^{(0)}[i,j]=j$；对所有 $i$，$\\mathrm{next}^{(0)}[i,i]=i$；其他情况下 $\\mathrm{next}^{(0)}[i,j]=\\varnothing$。\n\n你的任务是：\n- 仅使用上述基本定义，用你自己的话陈述这个不变式。\n- 写下初始化后的 $D^{(0)}$ 和 $\\mathrm{next}^{(0)}$。\n- 对于阶段 $k=1,2,3$，应用与所述不变式一致的程序更新策略，生成 $D^{(1)}$、$D^{(2)}$ 和 $D^{(3)}$，并注释在每个阶段发生变化的 $\\mathrm{next}$ 矩阵的条目。通过明确指出其内部顶点位于 $\\{1,2,\\dots,k\\}$ 中的一个严格更短的路径来证明每次更改的合理性。\n- 精确解释某个对角线元素 $d_{ii}^{(k)}$ 在何时以及为何变为负数，指出具体的环路以及根据不变式在该阶段使其成为可接受路径的内部顶点集。\n\n回答要求：令 $k^\\star$ 表示 $D^{(k)}$ 的任一对角线元素首次变为负值时的最小阶段索引 $k\\in\\{1,2,\\dots,6\\}$。提供 $k^\\star$ 作为一个整数。无需四舍五入，也无物理单位。你的最终答案必须只有这个整数。", "solution": "该问题要求逐步执行 Floyd-Warshall 算法，以找到首次检测到负权环路的具体阶段。\n\n首先，我们来陈述算法的不变式。根据所提供的定义，该程序所维护的不变式是：在阶段 $k$ 结束时，对于任意顶点对 $(i,j)$，条目 $D^{(k)}[i,j]$ 存储了从顶点 $i$ 到顶点 $j$ 的所有路径中，其内部顶点全部包含在集合 $\\{1, 2, \\dots, k\\}$ 内的路径的最小权重。\n\n接下来，我们建立算法在阶段 $k=0$ 的初始状态。距离矩阵 $D^{(0)}$ 是给定的加权邻接矩阵 $W$。后继矩阵 $\\mathrm{next}^{(0)}$ 根据指定规则填充。\n$$ D^{(0)} = W =\n\\begin{pmatrix}\n0   3   \\infty   \\infty   \\infty   \\infty\\\\\n\\infty   0   4   2   \\infty   \\infty\\\\\n-10   \\infty   0   5   \\infty   \\infty\\\\\n\\infty   \\infty   \\infty   0   1   \\infty\\\\\n\\infty   \\infty   \\infty   \\infty   0   1\\\\\n\\infty   \\infty   \\infty   1   \\infty   0\n\\end{pmatrix}\n$$\n$$ \\mathrm{next}^{(0)} =\n\\begin{pmatrix}\n1   2   \\varnothing   \\varnothing   \\varnothing   \\varnothing \\\\\n\\varnothing   2   3   4   \\varnothing   \\varnothing \\\\\n1   \\varnothing   3   4   \\varnothing   \\varnothing \\\\\n\\varnothing   \\varnothing   \\varnothing   4   5   \\varnothing \\\\\n\\varnothing   \\varnothing   \\varnothing   \\varnothing   5   6 \\\\\n\\varnothing   \\varnothing   \\varnothing   4   \\varnothing   6\n\\end{pmatrix}\n$$\n动态规划程序的更新规则是 $D^{(k)}[i,j] = \\min(D^{(k-1)}[i,j], D^{(k-1)}[i,k] + D^{(k-1)}[k,j])$。如果发生更新，后继节点设置为 $\\mathrm{next}^{(k)}[i,j] = \\mathrm{next}^{(k-1)}[i,k]$。\n\n阶段 $k=1$：我们考虑以顶点 $1$ 为内部顶点的路径。\n进入顶点 $1$ 的唯一边来自顶点 $3$，权重为 $D^{(0)}[3,1] = -10$。离开顶点 $1$ 的唯一边去往顶点 $2$，权重为 $D^{(0)}[1,2] = 3$。这使得可能存在一条从 $3$ 经过 $1$ 到达 $2$ 的新路径。\n- 对于顶点对 $(3,2)$：我们计算 $D^{(0)}[3,1] + D^{(0)}[1,2] = -10 + 3 = -7$。这小于当前距离 $D^{(0)}[3,2] = \\infty$。\n- 证明：找到一条新的、严格更短的路径 $3\\to1\\to2$。其总权重为 $-7$。其内部顶点为 $\\{1\\}$，这与阶段 $k=1$ 的不变式一致。\n- 更新：$D^{(1)}[3,2] = -7$。\n- 后继更新：$\\mathrm{next}^{(1)}[3,2] = \\mathrm{next}^{(0)}[3,1] = 1$。\n没有其他路径得到改善。阶段 $k=1$ 的距离矩阵为：\n$$ D^{(1)} =\n\\begin{pmatrix}\n0   3   \\infty   \\infty   \\infty   \\infty\\\\\n\\infty   0   4   2   \\infty   \\infty\\\\\n-10   -7   0   5   \\infty   \\infty\\\\\n\\infty   \\infty   \\infty   0   1   \\infty\\\\\n\\infty   \\infty   \\infty   \\infty   0   1\\\\\n\\infty   \\infty   \\infty   1   \\infty   0\n\\end{pmatrix}\n$$\n\n阶段 $k=2$：我们考虑内部顶点来自集合 $\\{1, 2\\}$ 的路径。枢轴顶点是 $2$。我们检查形如 $i \\to \\dots \\to 2 \\to \\dots \\to j$ 的路径。\n- 对于 $(1,3)$：$D^{(1)}[1,2] + D^{(1)}[2,3] = 3 + 4 = 7$。当前 $D^{(1)}[1,3]=\\infty$。\n  - 证明：路径 $1\\to2\\to3$ 的权重为 $7$。内部顶点为 $\\{2\\} \\subseteq \\{1,2\\}$。\n  - 更新：$D^{(2)}[1,3] = 7$。$\\mathrm{next}^{(2)}[1,3] = \\mathrm{next}^{(1)}[1,2] = 2$。\n- 对于 $(1,4)$：$D^{(1)}[1,2] + D^{(1)}[2,4] = 3 + 2 = 5$。当前 $D^{(1)}[1,4]=\\infty$。\n  - 证明：路径 $1\\to2\\to4$ 的权重为 $5$。内部顶点为 $\\{2\\} \\subseteq \\{1,2\\}$。\n  - 更新：$D^{(2)}[1,4] = 5$。$\\mathrm{next}^{(2)}[1,4] = \\mathrm{next}^{(1)}[1,2] = 2$。\n- 对于 $(3,3)$：$D^{(1)}[3,2] + D^{(1)}[2,3] = -7 + 4 = -3$。当前 $D^{(1)}[3,3]=0$。\n  - 证明：从 $3$ 到 $2$ 的路径是 $3\\to1\\to2$（权重为 $-7$）。从 $2$ 到 $3$ 的路径是直接的（权重为 $4$）。连接起来得到环路 $3\\to1\\to2\\to3$，权重为 $-3$。内部顶点集为 $\\{1,2\\}$，这正是阶段 $k=2$ 所允许的集合。\n  - 更新：$D^{(2)}[3,3] = -3$。$\\mathrm{next}^{(2)}[3,3] = \\mathrm{next}^{(1)}[3,2] = 1$。这是第一个负的对角线元素。\n- 对于 $(3,4)$：$D^{(1)}[3,2] + D^{(1)}[2,4] = -7 + 2 = -5$。当前 $D^{(1)}[3,4]=5$。\n  - 证明：路径 $3\\to1\\to2\\to4$ 的权重为 $-5$。内部顶点为 $\\{1,2\\}$。\n  - 更新：$D^{(2)}[3,4] = -5$。$\\mathrm{next}^{(2)}[3,4] = \\mathrm{next}^{(1)}[3,2] = 1$。\n阶段 $k=2$ 的距离矩阵为：\n$$ D^{(2)} =\n\\begin{pmatrix}\n0   3   7   5   \\infty   \\infty\\\\\n\\infty   0   4   2   \\infty   \\infty\\\\\n-10   -7   -3   -5   \\infty   \\infty\\\\\n\\infty   \\infty   \\infty   0   1   \\infty\\\\\n\\infty   \\infty   \\infty   \\infty   0   1\\\\\n\\infty   \\infty   \\infty   1   \\infty   0\n\\end{pmatrix}\n$$\n\n阶段 $k=3$：我们考虑内部顶点来自集合 $\\{1, 2, 3\\}$ 的路径。枢轴顶点是 $3$。\n- 对于 $(1,1)$：$D^{(2)}[1,3] + D^{(2)}[3,1] = 7 + (-10) = -3$。当前 $D^{(2)}[1,1]=0$。\n  - 证明：环路 $1\\to2\\to3\\to1$ 的权重为 $-3$。内部顶点为 $\\{2,3\\} \\subseteq \\{1,2,3\\}$。\n  - 更新：$D^{(3)}[1,1] = -3$。$\\mathrm{next}^{(3)}[1,1] = \\mathrm{next}^{(2)}[1,3] = 2$。\n- 对于 $(1,2)$：$D^{(2)}[1,3] + D^{(2)}[3,2] = 7 + (-7) = 0$。当前 $D^{(2)}[1,2]=3$。\n  - 证明：路径 $1\\to2\\to3\\to1\\to2$ 的权重为 $0$。内部顶点为 $\\{1,2,3\\} \\subseteq \\{1,2,3\\}$。\n  - 更新：$D^{(3)}[1,2] = 0$。$\\mathrm{next}^{(3)}[1,2] = \\mathrm{next}^{(2)}[1,3] = 2$。\n- 对于 $(1,4)$：$D^{(2)}[1,3] + D^{(2)}[3,4] = 7 + (-5) = 2$。当前 $D^{(2)}[1,4]=5$。\n  - 证明：路径 $1\\to2\\to3\\to\\dots\\to4$ (其中 $3\\to\\dots\\to4$ 是路径 $3\\to1\\to2\\to4$) 的总权重为 $2$。内部顶点集为 $\\{1,2,3\\}$。\n  - 更新：$D^{(3)}[1,4] = 2$。$\\mathrm{next}^{(3)}[1,4] = \\mathrm{next}^{(2)}[1,3] = 2$。\n- 对于 $(2,1)$：$D^{(2)}[2,3] + D^{(2)}[3,1] = 4 + (-10) = -6$。当前 $D^{(2)}[2,1]=\\infty$。\n  - 证明：路径 $2\\to3\\to1$ 的权重为 $-6$。内部顶点为 $\\{3\\} \\subseteq \\{1,2,3\\}$。\n  - 更新：$D^{(3)}[2,1] = -6$。$\\mathrm{next}^{(3)}[2,1] = \\mathrm{next}^{(2)}[2,3] = 3$。\n- 对于 $(2,2)$：$D^{(2)}[2,3] + D^{(2)}[3,2] = 4 + (-7) = -3$。当前 $D^{(2)}[2,2]=0$。\n  - 证明：环路 $2\\to3\\to1\\to2$ 的权重为 $-3$。内部顶点为 $\\{1,3\\} \\subseteq \\{1,2,3\\}$。\n  - 更新：$D^{(3)}[2,2] = -3$。$\\mathrm{next}^{(3)}[2,2] = \\mathrm{next}^{(2)}[2,3] = 3$。\n- 对于 $(2,4)$：$D^{(2)}[2,3] + D^{(2)}[3,4] = 4 + (-5) = -1$。当前 $D^{(2)}[2,4]=2$。\n  - 证明：路径 $2\\to3\\to\\dots\\to4$ (其中 $3\\to\\dots\\to4$ 是路径 $3\\to1\\to2\\to4$) 的总权重为 $-1$。内部顶点为 $\\{1,2,3\\}$。\n  - 更新：$D^{(3)}[2,4] = -1$。$\\mathrm{next}^{(3)}[2,4] = \\mathrm{next}^{(2)}[2,3] = 3$。\n阶段 $k=3$ 的距离矩阵为：\n$$ D^{(3)} =\n\\begin{pmatrix}\n-3   0   7   2   \\infty   \\infty\\\\\n-6   -3   4   -1   \\infty   \\infty\\\\\n-10   -7   -3   -5   \\infty   \\infty\\\\\n\\infty   \\infty   \\infty   0   1   \\infty\\\\\n\\infty   \\infty   \\infty   \\infty   0   1\\\\\n\\infty   \\infty   \\infty   1   \\infty   0\n\\end{pmatrix}\n$$\n\n当首次发现一个包含顶点 $i$ 的负权重环路时，对角线元素 $d_{ii}^{(k)}$ 就会变为负数。根据算法，如果在阶段 $k$，从某个顶点（比如 $j$）经过枢轴顶点 $k$ 回到自身的路径权重为负，即 $D^{(k-1)}[j,k] + D^{(k-1)}[k,j]  0$，这种情况就会发生。得到的路径 $j \\rightsquigarrow k \\rightsquigarrow j$ 的内部顶点取自集合 $\\{1, \\dots, k-1\\} \\cup \\{k\\}$。\n\n在阶段 $k=1$，对于任何 $j$，条件 $D^{(0)}[j,1] + D^{(0)}[1,j]  0$ 都不满足。\n\n在阶段 $k=2$，我们测试条件 $D^{(1)}[j,2] + D^{(1)}[2,j]  0$。对于 $j=3$：\n$$ D^{(1)}[3,2] + D^{(1)}[2,3] = -7 + 4 = -3 $$\n由于 $-3  0$，条目 $D^{(2)}[3,3]$ 从 $0$ 更新为 $-3$。这是任一对角线元素首次变为负值的时刻。发现的具体环路是 $3 \\to 1 \\to 2 \\to 3$。它是由以下两条路径连接而成：在阶段 $k=1$ 后已知的从 $3$ 到 $2$ 的最短路径（即 $3\\to1\\to2$，内部顶点为 $\\{1\\}$），以及在阶段 $k=1$ 后已知的从 $2$ 到 $3$ 的最短路径（即直接边 $2\\to3$，没有内部顶点）。该环路的内部顶点集为 $\\{1, 2\\}$。这个集合恰好是在阶段 $k=2$ 所考虑的路径的允许内部顶点集。因此，该环路在这一阶段对算法变得“可见”。\n\n因此，$D^{(k)}$ 的对角线元素首次变为负值的最小阶段索引 $k^\\star \\in \\{1, 2, \\dots, 6\\}$ 是 $k^\\star=2$。", "answer": "$$\\boxed{2}$$", "id": "3235663"}, {"introduction": "Floyd-Warshall 算法的真正威力不仅在于解决最短路径问题，更在于其底层的动态规划结构。这项练习 [@problem_id:3235604] 挑战你将这一结构应用于一个不同的问题：寻找“最宽路径”（或称“瓶颈路径”），其目标是最大化路径上的最小容量。这展示了如何通过改变代数运算（一个与半环概念相关的思想）来推广其核心逻辑。", "problem": "您将收到若干个独立的测试用例。每个测试用例包含一个有向图，其边的容量为非负数，并以邻接矩阵表示；还有一个查询对，指定了源顶点和目标顶点。一条路径的容量定义为该路径上所有边的最小容量。目标是为每个测试用令计算从源点到目标点的最大可能路径容量，即在所有路径中，取每条路径上最小边容量的最大值。这通常被称为最宽路径或瓶颈路径问题。\n\n基本原理和约束条件：\n- 一个有向图由一个顶点集和一组有向边构成，其中每条从顶点 $i$ 到顶点 $j$ 的有向边都有一个非负容量 $w_{ij} \\in \\mathbb{R}_{\\ge 0}$。邻接矩阵 $W$ 将此编码为 $W[i][j] = w_{ij}$。\n- 一条路径 $P = (v_0, v_1, \\dots, v_\\ell)$ 的容量是值 $\\min\\{ w_{v_0 v_1}, w_{v_1 v_2}, \\dots, w_{v_{\\ell-1} v_\\ell} \\}$。\n- 如果从源点到目标点不存在路径，则容量定义为 $0$。\n- 邻接矩阵中没有用容量 $0$ 表示的边。可能存在自环；为了动态规划的目的，将一个顶点到其自身的容量视为无限大（概念上为 $+\\infty$），但请注意，以下查询均不使用相同的源顶点和目标顶点。\n- 您必须改编经典的 Floyd–Warshall 算法（该算法用于计算传递闭包或所有点对最短路径）来解决最宽路径问题。这需要使用基于最优性原理的动态规划公式：通过一个中间顶点扩展部分解，其路径容量不会超过其各部分容量的最小值；在候选路径中，您必须根据最宽路径目标选择最佳路径。利用这一思想，推导出一个针对中间顶点、源点和目标点的三层嵌套迭代算法，该算法能在 $\\mathcal{O}(n^3)$ 时间内计算出具有 $n$ 个顶点的图的所有点对最宽路径容量。\n\n程序要求：\n- 实现一个程序，为每个测试用例根据给定的邻接矩阵构建所有点对最宽路径容量矩阵，并返回指定查询对 $(s, t)$ 的容量。索引从 $0$ 开始。\n- 所有边的容量和输出均为整数。如果从 $s$ 到 $t$ 没有路径，则输出 $0$。\n\n测试套件：\n对于下面的每个测试用例，图由其邻接矩阵 $W$ 指定，其中 $W[i][j]$ 是边 $(i \\to j)$ 的容量，$0$ 表示没有边。查询对 $(s, t)$ 在矩阵之后给出。顶点从 $0$ 开始索引。\n\n- 测试用例 1（正常情况：间接路径优于直接路径）：\n  - $n = 4$\n  - `W = [[0, 5, 6, 3], [0, 0, 0, 7], [0, 0, 0, 4], [0, 0, 0, 0]]`\n  - 查询 $(s, t) = (0, 3)$\n  - 预期最宽容量为 5。\n\n- 测试用例 2（目标点不可达）：\n  - $n = 3$\n  - `W = [[0, 2, 0], [0, 0, 0], [0, 0, 0]]`\n  - 查询 $(s, t) = (0, 2)$\n  - 预期最宽容量为 0。\n\n- 测试用例 3（自环无用；直接路径优于狭窄的绕行路径）：\n  - $n = 3$\n  - `W = [[0, 10, 2], [0, 100, 1], [0, 0, 0]]`\n  - 查询 $(s, t) = (0, 2)$\n  - 预期最宽容量为 2。\n\n- 测试用例 4（多条最宽路径并列）：\n  - $n = 4$\n  - `W = [[0, 8, 7, 4], [0, 0, 0, 5], [0, 0, 0, 5], [0, 0, 0, 0]]`\n  - 查询 $(s, t) = (0, 3)$\n  - 预期最宽容量为 5。\n\n- 测试用例 5（零容量边无法提升容量）：\n  - $n = 3$\n  - `W = [[0, 0, 3], [0, 0, 9], [0, 0, 0]]`\n  - 查询 $(s, t) = (0, 2)$\n  - 预期最宽容量为 3。\n\n- 测试用例 6（更长的路径链优于直接边）：\n  - $n = 4$\n  - `W = [[0, 6, 0, 5], [0, 0, 6, 0], [0, 0, 0, 6], [0, 0, 0, 0]]`\n  - 查询 $(s, t) = (0, 3)$\n  - 预期最宽容量为 6。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按上述测试用例的顺序排列。对于提供的 $6$ 个测试用例，确切格式为：\n\"[r1,r2,r3,r4,r5,r6]\"\n其中每个 $r_i$ 是测试用例 $i$ 的整数最宽容量。", "solution": "我们基于有向图的最优性原理，使用动态规划来构建最宽路径问题。考虑一个顶点集为 $\\{0, 1, \\dots, n-1\\}$ 的有向图，其邻接矩阵为 $W$，其中 $W[i][j] = w_{ij} \\in \\mathbb{R}_{\\ge 0}$ 表示边 $(i \\to j)$ 的容量，$w_{ij} = 0$ 表示不存在该边。\n\n将路径 $P = (v_0, v_1, \\dots, v_\\ell)$ 的容量定义为 $\\mathrm{cap}(P) = \\min\\{ w_{v_0 v_1}, w_{v_1 v_2}, \\dots, w_{v_{\\ell-1} v_\\ell} \\}$。对于顶点 $i$ 和 $j$，最宽路径容量为值\n$$\nC(i,j) = \\max_{P \\in \\mathcal{P}_{ij}} \\mathrm{cap}(P),\n$$\n其中 $\\mathcal{P}_{ij}$ 是从 $i$ 到 $j$ 的所有有向路径的集合。如果 $\\mathcal{P}_{ij}$ 为空，我们定义 $C(i,j) = 0$。\n\n为了在 $\\mathcal{O}(n^3)$ 时间内高效地计算所有点对的 $C(i,j)$，我们改编 Floyd–Warshall 范式。引入一个按中间顶点预算索引的动态规划。设 $D^{(k)}[i][j]$ 表示从 $i$ 到 $j$ 仅使用来自 $\\{0,1,\\dots,k-1\\}$ 的中间顶点（即，路径的内部顶点取自前 $k$ 个顶点）时的最宽路径容量。基础情况 $k=0$ 排除了所有中间顶点；因此只允许直接边和 $i=j$ 的平凡零长度路径。因此，\n- 对于 $i \\ne j$，我们设置 $D^{(0)}[i][j] = W[i][j]$，因为唯一的候选路径是直接边。\n- 对于 $i = j$，我们设置 $D^{(0)}[i][i] = +\\infty$，这反映了零边路径的容量是无限的，以便通过最小值与其他路径段组合；这确保了 $\\min(D^{(k)}[i][i], D^{(k)}[i][j]) = D^{(k)}[i][j]$ 并且不会人为地降低容量。\n\n对于归纳步骤，当允许顶点 $k$ 作为中间顶点时，任何从 $i$ 到 $j$ 的路径要么不使用 $k$ 作为中间顶点，这种情况下其容量已由 $D^{(k)}[i][j]$ 计算；要么使用 $k$，这种情况下它可以分解为从 $i$ 到 $k$ 的路径和从 $k$ 到 $j$ 的路径，其容量分别为 $D^{(k)}[i][k]$ 和 $D^{(k)}[k][j]$。根据路径容量的定义，通过 $k$ 的串联路径的容量是这两个容量的最小值。根据最宽路径目标，我们在避开 $k$ 的选项和经过 $k$ 的选项中取最大值。因此，递推关系为\n$$\nD^{(k+1)}[i][j] = \\max\\Big( D^{(k)}[i][j], \\min\\big( D^{(k)}[i][k], D^{(k)}[k][j] \\big) \\Big).\n$$\n处理完所有 $k \\in \\{0,1,\\dots,n-1\\}$ 后，我们得到 $D^{(n)} = C$，即所求的所有点对最宽路径容量矩阵。这正是 Floyd–Warshall 结构，其中半环运算被替换为：用 $\\min$ 作为路径扩展运算符，用 $\\max$ 作为路径选择运算符。\n\n算法实现细节：\n- 初始化一个矩阵 $D$，对于 $i \\ne j$ 有 $D[i][j] \\leftarrow W[i][j]$，对于 $i=j$ 有 $D[i][i] \\leftarrow +\\infty$。\n- 对于 $k$ 从 $0$到 $n-1$：\n  - 对于 $i$ 从 $0$到 $n-1$：\n    - 对于 $j$ 从 $0$到 $n-1$：\n      - 更新 $$D[i][j] \\leftarrow \\max\\big( D[i][j], \\min(D[i][k], D[k][j]) \\big)$$。\n- 对于查询对 $(s,t)$，答案是 $D[s][t]$（如果有限），如果不存在路径则为 $0$。在我们的表示法中，不存在路径会使 $D[s][t]$ 始终保持为 $0$，因此返回 $D[s][t]$ 即可。\n\n正确性简述：\n- 基础正确性：对于 $k=0$，$D^{(0)}$ 正确地捕捉了没有中间顶点的路径容量。对角线上的 $+\\infty$ 确保与恒等路径组合不会降低容量。\n- 归纳步骤：假设 $D^{(k)}$ 正确地编码了使用来自 $\\{0,\\dots,k-1\\}$ 的中间顶点的最宽容量。在步骤 $k+1$ 中允许的任何路径要么避开 $k$，要么包含 $k$。如果避开 $k$，其最佳容量为 $D^{(k)}[i][j]$。如果包含 $k$，则在 $k$ 的第一次和最后一次出现处进行分解，得到两条子路径，其容量受 $D^{(k)}[i][k]$ 和 $D^{(k)}[k][j]$ 的限制，任何这样的串联路径的容量等于两者中的最小值。在这两种情况下取最大值，即可得到使用来自 $\\{0,\\dots,k\\}$ 的最优容量。因此，该递推关系保持了正确性。\n- 终止时得到 $D^{(n)} = C$。\n\n时间和空间复杂度：\n- 三层循环的运行时间为 $\\mathcal{O}(n^3)$，使用 $\\mathcal{O}(n^2)$ 的空间。\n\n现在将此算法应用于提供的测试套件：\n\n- 测试用例 1：从 $0$ 到 $3$ 的路径包括直接容量为 3 的路径、容量为 $\\min(5, 7) = 5$ 的路径 $0 \\to 1 \\to 3$，以及容量为 $\\min(6, 4) = 4$ 的路径 $0 \\to 2 \\to 3$。最宽容量是 5。\n\n- 测试用例 2：从 $0$ 到 $2$ 没有路径，因此容量保持为 0。\n\n- 测试用例 3：从 $0$ 到 $2$，直接边的容量是 2。绕行路径 $0 \\to 1 \\to 2$ 的容量为 $\\min(10, 1) = 1$。在顶点 $1$ 处的容量为 100 的自环并不会增加这个值，因为 $\\min(10, 100, 1) = 1$。因此，最宽容量是 $\\max(2, 1) = 2$。\n\n- 测试用例 4：从 $0$ 到 $3$ 有两条候选绕行路径：$0 \\to 1 \\to 3$ 的容量为 $\\min(8, 5) = 5$，$0 \\to 2 \\to 3$ 的容量为 $\\min(7, 5) = 5$。直接边的容量为 4。最宽容量是 5。\n\n- 测试用例 5：经过顶点 $1$ 的绕行路径容量为 $\\min(0, 9) = 0$，这并未超过直接边容量 3。最宽容量是 3。\n\n- 测试用例 6：路径链 $0 \\to 1 \\to 2 \\to 3$ 的容量为 $\\min(6, 6, 6) = 6$，超过了直接边容量 5。因此，最宽容量是 6。\n\n因此，按顺序输出的结果是 $[5, 0, 2, 5, 3, 6]$，程序必须以指定的单行格式生成此结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef widest_path_all_pairs(adj):\n    \"\"\"\n    Compute all-pairs widest path capacities using a Floyd–Warshall-style DP.\n    adj: list of lists (n x n) with nonnegative integers; 0 denotes no edge.\n    Returns: matrix D (n x n) of widest capacities; D[i][j] is an integer,\n             with D[i][j] == 0 meaning no path from i to j.\n    \"\"\"\n    n = len(adj)\n    # Initialize DP matrix with floats to use +inf on diagonal.\n    D = [[float(adj[i][j]) for j in range(n)] for i in range(n)]\n    for i in range(n):\n        D[i][i] = float('inf')\n    # Floyd–Warshall over max-min semiring\n    for k in range(n):\n        Dik = D  # local alias for speed/readability\n        for i in range(n):\n            dik = Dik[i][k]\n            # If dik is 0, min(0, anything) stays 0; but we can still compute uniformly.\n            for j in range(n):\n                via = dik\n                dkj = Dik[k][j]\n                if dkj  via:\n                    via = dkj\n                if via  Dik[i][j]:\n                    Dik[i][j] = via\n    # Convert back to integers; keep 0 for no path; do not emit infinities.\n    out = [[(0 if (i == j or not np.isfinite(D[i][j])) else int(D[i][j]))\n             if D[i][j] != float('inf') else 0\n            for j in range(n)] for i in range(n)]\n    return out\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (adjacency matrix, (s, t))\n    test_cases = [\n        # Test case 1\n        (\n            [\n                [0,5,6,3],\n                [0,0,0,7],\n                [0,0,0,4],\n                [0,0,0,0],\n            ],\n            (0,3),\n        ),\n        # Test case 2\n        (\n            [\n                [0,2,0],\n                [0,0,0],\n                [0,0,0],\n            ],\n            (0,2),\n        ),\n        # Test case 3\n        (\n            [\n                [0,10,2],\n                [0,100,1],\n                [0,0,0],\n            ],\n            (0,2),\n        ),\n        # Test case 4\n        (\n            [\n                [0,8,7,4],\n                [0,0,0,5],\n                [0,0,0,5],\n                [0,0,0,0],\n            ],\n            (0,3),\n        ),\n        # Test case 5\n        (\n            [\n                [0,0,3],\n                [0,0,9],\n                [0,0,0],\n            ],\n            (0,2),\n        ),\n        # Test case 6\n        (\n            [\n                [0,6,0,5],\n                [0,0,6,0],\n                [0,0,0,6],\n                [0,0,0,0],\n            ],\n            (0,3),\n        ),\n    ]\n\n    results = []\n    for adj, (s, t) in test_cases:\n        D = widest_path_all_pairs(adj)\n        results.append(D[s][t])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3235604"}, {"introduction": "检测到负权环路很有用，但我们常常还需要知道这个环路具体是什么。这个编程练习 [@problem_id:3235685] 就聚焦于这项实际任务：不仅利用算法的最终状态检测负权环路，还要重建构成该环路的顶点序列。这需要对前驱矩阵进行仔细的管理和解读，这是在实际场景（如分析金融套利机会）中应用该算法的一项关键技能。", "problem": "给定一个以邻接矩阵形式表示的有向加权图族，以及每个图的一个指定锚定顶点。您的任务是实现一个完整的程序，使用 Floyd–Warshall 算法来检测是否存在与锚定顶点相关的负循环，如果存在，则重构该特定负循环的顶点序列。重构必须仅基于算法执行期间累积的前驱（父）矩阵。最终输出必须将所有给定测试用例的结果汇总到一行中。\n\n一个有向加权图是一个对 $(V,E)$，其中 $|V| = n$，边权重由一个矩阵 $W \\in \\mathbb{R}^{n \\times n}$ 给出，$W[i][j]$ 是从顶点 $i$ 到顶点 $j$ 的边的权重。如果从 $i$到 $j$ 没有边，则 $W[i][j]$ 为 $+\\infty$。对于所有的 $i$，对角线元素 $W[i][i]$ 为 $0$，除非存在显式的自环。路径是顶点的序列，其总权重是其边权重之和。所有顶点对最短路径（APSP）问题旨在寻找所有顶点对之间的最短路径。\n\n理论基础：\n- 最短路径的最优子结构性质：最短路径的任何子路径本身都是其端点之间的最短路径。\n- 应用于APSP的动态规划原理：逐步考虑允许的中间顶点集合，以在遵循最优子结构的同时优化路径距离。\n\n闭包中负循环的检测定义：\n- 在对所有顶点执行 Floyd–Warshall 闭包后，当且仅当闭包距离 $D[v][v]$ 严格小于 $0$ 时，顶点 $v$ 属于或受负循环影响。\n\n重构指令：\n- 对于一个锚定顶点 $s \\in V$，如果 $D[s][s]  0$，则使用最终的前驱矩阵 $P$ 重构一个特定的负循环。令 $n = |V|$。将 $u$ 定义为从 $(s,s)$ 开始应用前驱指针 $n$ 次的结果：从 $u \\leftarrow s$ 开始，重复设置 $u \\leftarrow P[s][u]$ 共 $n$ 步。然后，从 $u$ 开始，继续沿着前驱 $P[s][\\cdot]$ 追溯，直到再次访问到 $u$，从而形成一个循环。以顶点索引列表的形式输出该循环，该列表以 $u$ 开始，并以重复的 $u$ 作为最后一个元素结束。如果对于该锚定顶点不存在这样的循环（即 $D[s][s] \\ge 0$ 或重构失败），则输出空列表 $[]$。\n\n程序要求：\n- 实现 Floyd–Warshall 算法以计算一个闭包距离矩阵 $D$ 和一个前驱矩阵 $P$，该矩阵为每个有序对 $(i,j)$ 存储当前从 $i$到 $j$ 的最短路径上 $j$ 的直接前驱。\n- 对缺失的边使用 $+\\infty$。\n- 对每个测试用例，生成重构的循环（如上所述）或 $[]$。\n\n测试套件（每个测试用例是一个由矩阵 $W$ 和锚定顶点 $s$ 组成的对）：\n1. $W_1$，其中 $n=4$：\n   - 行 $0$: $[\\,0,\\;2,\\;+\\infty,\\;+\\infty\\,]$\n   - 行 $1$: $[\\,+\\infty,\\;0,\\;-1,\\;2\\,]$\n   - 行 $2$: $[\\, -2,\\;+\\infty,\\;0,\\;+\\infty\\,]$\n   - 行 $3$: $[\\,+\\infty,\\;-2,\\;+\\infty,\\;0\\,]$\n   锚定顶点 $s_1 = 0$。\n2. $W_2$，其中 $n=4$：\n   - 行 $0$: $[\\,0,\\;+\\infty,\\;+\\infty,\\;2\\,]$\n   - 行 $1$: $[\\,+\\infty,\\;0,\\;-3,\\;+\\infty\\,]$\n   - 行 $2$: $[\\,+\\infty,\\;+\\infty,\\;0,\\;1\\,]$\n   - 行 $3$: $[\\,+\\infty,\\;1,\\;+\\infty,\\;0\\,]$\n   锚定顶点 $s_2 = 2$。\n3. $W_3$，其中 $n=3$：\n   - 行 $0$: $[\\,0,\\;1,\\;+\\infty\\,]$\n   - 行 $1$: $[\\,+\\infty,\\;0,\\;1\\,]$\n   - 行 $2$: $[\\,1,\\;+\\infty,\\;0\\,]$\n   锚定顶点 $s_3 = 0$。\n4. $W_4$，其中 $n=3$：\n   - 行 $0$: $[\\,0,\\;+\\infty,\\;+\\infty\\,]$\n   - 行 $1$: $[\\,+\\infty,\\;0,\\;+\\infty\\,]$\n   - 行 $2$: $[\\,+\\infty,\\;+\\infty,\\;-1\\,]$\n   锚定顶点 $s_4 = 2$。\n5. $W_5$，其中 $n=3$：\n   - 行 $0$: $[\\,0,\\;1,\\;+\\infty\\,]$\n   - 行 $1$: $[\\,1,\\;0,\\;+\\infty\\,]$\n   - 行 $2$: $[\\,+\\infty,\\;+\\infty,\\;-1\\,]$\n   锚定顶点 $s_5 = 0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，且不含空格。每个元素本身是一个用方括号括起来的、以逗号分隔的整数列表，表示一个循环；如果无循环可返回，则为空列表。例如，输出可能看起来像 $[[a_0,a_1,\\dots,a_0],[],\\dots]$，其中第一个循环在同一个顶点开始和结束。", "solution": "用户提供了一个问题，要求实现 Floyd-Warshall 算法来寻找有向加权图中的所有顶点对最短路径。主要任务是检测与特定锚定顶点相关的负循环，如果存在，则使用算法生成的前驱矩阵重构该循环中的顶点序列。\n\n### 基于原则的设计\n\n该解决方案基于动态规划原理在所有顶点对最短路径（APSP）问题中的应用。\n\n**1. Floyd-Warshall 算法：**\nFloyd-Warshall 算法通过迭代地将每个顶点视为任意两个其他顶点之间路径上的中间点来解决 APSP 问题。它依赖于最优子结构性质：一个经过中间顶点 $k$ 的、连接顶点 $i$ 和 $j$ 的最短路径，是由一条从 $i$ 到 $k$ 的最短路径和一条从 $k$ 到 $j$ 的最短路径组成的。\n\n令 $D^{(k)}[i][j]$ 为从顶点 $i$ 到顶点 $j$ 仅使用集合 $\\{0, 1, \\dots, k\\}$ 中的顶点作为中间顶点的最短路径的权重。该算法计算一系列矩阵 $D^{(0)}, D^{(1)}, \\dots, D^{(n)}$，其中 $n$ 是顶点数。\n\n递推关系为：\n$$\nD^{(k)}[i][j] = \\min(D^{(k-1)}[i][j], D^{(k-1)}[i][k] + D^{(k-1)}[k,j])\n$$\n基础情况 $D^{(-1)}$ 是输入的权重矩阵 $W$，其中如果从 $i$ 到 $j$ 没有边，则 $W[i][j] = \\infty$。在实现中，我们可以原地更新矩阵，从而省略上标。算法通过三个嵌套循环进行：\n对于 $k$ 从 $0$ 到 $n-1$：\n  对于 $i$ 从 $0$ 到 $n-1$：\n    对于 $j$ 从 $0$ 到 $n-1$：\n      $D[i][j] \\leftarrow \\min(D[i][j], D[i][k] + D[k][j])$\n\n**2. 用于路径重构的前驱矩阵：**\n为了重构最短路径，我们维护一个前驱矩阵 $P$。$P[i][j]$ 存储从 $i$到 $j$ 的最短路径上紧邻 $j$ 的前一个顶点。\n\n- **初始化：** 前驱矩阵 $P$ 根据输入图进行初始化。对于输入矩阵 $W$ 中从 $i$ 到 $j$ 的每条权重有限的边，我们设置 $P[i][j] = i$。如果没有直接的边，则前驱是未定义的（用一个特殊值如 $-1$ 表示）。这也包括自环，即如果 $W[i][i]$ 是有限的，则 $P[i][i]=i$。\n\n- **更新规则：** 在 Floyd-Warshall 算法的主循环中，如果我们发现一条通过 $k$ 从 $i$到 $j$ 的更短路径（即 $D[i][k] + D[k][j]  D[i][j]$），我们不仅更新距离 $D[i][j]$，还更新前驱 $P[i][j]$。从 $i$到 $j$ 的新路径是从 $i$ 到 $k$ 的路径和从 $k$ 到 $j$ 的路径的拼接。因此，在新路径上 $j$ 的前驱与从 $k$ 开始的路径上 $j$ 的前驱相同。更新规则是：\n如果 $D[i][k] + D[k][j]  D[i][j]$, 那么 $P[i][j] \\leftarrow P[k][j]$\n\n**3. 负循环检测：**\nFloyd-Warshall 算法的一个关键特性是它能够检测负循环。一个图包含一个可以从顶点 $i$ 到达并且可以到达顶点 $i$ 的负权重循环，当且仅当算法完成后，从 $i$ 到其自身的最短路径距离 $D[i][i]$ 为负。问题指定了对给定的锚定顶点 $s$ 检查此条件：如果 $D[s][s]  0$，则存在一个与 $s$ 相关的负循环。\n\n**4. 循环重构：**\n在 Floyd-Warshall 算法完成后，问题提供了一个特定的、非传统的指令，用于根据最终的前驱矩阵 $P$ 重构循环。设锚定顶点为 $s$，顶点数为 $n$。\n\n- **步骤 4.1：识别循环上的一个顶点：** 如果 $D[s][s]  0$，这意味着从 $s$ 到其自身的最短路径涉及一个循环。可以通过重复应用前驱函数来找到此循环上的一个顶点 $u$。从一个指向 $s$ 的指针开始，我们沿着从 $s$ 到 $s$ 的“最短路径”向后追溯。该过程是初始化 $u \\leftarrow s$，然后迭代更新 $u \\leftarrow P[s][u]$ 共 $n$ 次。由于任何简单路径最多有 $n-1$ 条边，遍历 $n$ 个前驱链接可以保证最终的顶点 $u$ 位于源为 $s$ 的前驱图中的一个循环上。\n\n- **步骤 4.2：追溯循环：** 一旦识别出顶点 $u$，就可以通过从 $u$ 开始，并为源 $s$ 重复地跟随前驱，直到再次访问 $u$ 来追溯循环本身。也就是说，我们生成序列 $v_0=u, v_1=P[s][v_0], v_2=P[s][v_1], \\dots, v_m=u$。这个顶点序列以反向路径顺序表示该循环。\n\n- **步骤 4.3：格式化输出：** 指令要求输出以 $u$ 开始并以重复的 $u$ 结束的顶点索引列表。这对应于序列 $[v_0, v_1, \\dots, v_{m-1}, v_m]$，这正是追溯过程生成的列表。\n\n### 算法实现\n\n整个程序将首先定义指定的测试用例。对于每个由权重矩阵 $W$ 和锚定顶点 $s$ 组成的测试用例，执行以下过程：\n\n1.  用 $W$ 的值初始化一个 $n \\times n$ 的距离矩阵 $D$，以及一个 $n \\times n$ 的前驱矩阵 $P$。对于每个 $W[i][j]  \\infty$ 的 $(i, j)$，设置 $P[i][j] \\leftarrow i$。$P$ 中的其他条目初始化为 $-1$。\n2.  每当通过顶点 $k$ 改进了距离 $D[i][j]$ 时，使用前驱更新规则 $P[i][j] \\leftarrow P[k][j]$ 执行 Floyd-Warshall 算法。\n3.  循环完成后，检查 $D[s][s]  0$ 是否成立。如果不成立，此测试用例的结果为空列表 `[]`。\n4.  如果 $D[s][s]  0$，则进行重构：\n    a. 通过从 $u \\leftarrow s$ 开始并迭代 $u \\leftarrow P[s][u]$ 共 $n$ 次来确定循环顶点 $u$。\n    b. 从 $u$ 开始，并沿着前驱 $P[s][\\cdot]$ 追溯，直到再次到达 $u$，从而生成顶点序列以追溯循环。\n    c. 将此序列格式化为以 $u$ 开始和结束的整数列表。\n5.  收集所有测试用例的结果，并按指定格式将其格式化为单行字符串。\n\n这种结构化方法通过严格遵守 Floyd-Warshall 算法的既定原则和问题陈述的明确指令来确保正确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_negative_cycle(W: np.ndarray, s: int) - list[int]:\n    \"\"\"\n    Uses the Floyd-Warshall algorithm to detect and reconstruct a negative cycle\n    associated with an anchor vertex.\n\n    Args:\n        W: The adjacency matrix of the graph.\n        s: The anchor vertex.\n\n    Returns:\n        A list of vertices representing the reconstructed negative cycle, starting\n        and ending with a specific vertex `u` on the cycle. Returns an empty\n        list if no such cycle is detected for the anchor.\n    \"\"\"\n    n = W.shape[0]\n\n    # Step 1: Initialize distance and predecessor matrices\n    dist = np.copy(W)\n    pred = np.full((n, n), -1, dtype=int)\n\n    for i in range(n):\n        for j in range(n):\n            if W[i, j] != np.inf:\n                pred[i, j] = i\n\n    # Step 2: Floyd-Warshall Algorithm\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if dist[i, k] != np.inf and dist[k, j] != np.inf:\n                    if dist[i, k] + dist[k, j]  dist[i, j]:\n                        dist[i, j] = dist[i, k] + dist[k, j]\n                        pred[i, j] = pred[k, j]\n\n    # Step 3: Check for negative cycle at the anchor vertex\n    if dist[s, s] = 0:\n        return []\n\n    # Step 4: Reconstruct the negative cycle\n    # 4.1: Find a vertex 'u' that is part of the cycle.\n    # By repeatedly applying the predecessor function n times from s,\n    # we are guaranteed to land on a vertex within the cycle.\n    u = s\n    for _ in range(n):\n        if u == -1: # Predecessor path ended, should not happen if dist[s,s]  0\n            return []\n        u = pred[s, u]\n    \n    if u == -1: # This vertex must be on the cycle\n        return []\n\n    # 4.2: Trace the cycle starting from u by following predecessors.\n    # The problem asks for the sequence generated by following predecessors,\n    # which represents the cycle in reverse.\n    v = u\n    cycle = []\n    while True:\n        cycle.append(v)\n        v = pred[s, v]\n        if v == u:\n            break\n    \n    # 4.3: Add the starting vertex `u` to the end to close the cycle display\n    cycle.append(u)\n    \n    return cycle\n\ndef solve():\n    \"\"\"\n    Solves the problem for all given test cases and prints the final output.\n    \"\"\"\n    inf = np.inf\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (np.array([\n            [0, 2, inf, inf],\n            [inf, 0, -1, 2],\n            [-2, inf, 0, inf],\n            [inf, -2, inf, 0]\n        ]), 0), # s1=0\n        (np.array([\n            [0, inf, inf, 2],\n            [inf, 0, -3, inf],\n            [inf, inf, 0, 1],\n            [inf, 1, inf, 0]\n        ]), 2), # s2=2\n        (np.array([\n            [0, 1, inf],\n            [inf, 0, 1],\n            [1, inf, 0]\n        ]), 0), # s3=0\n        (np.array([\n            [0, inf, inf],\n            [inf, 0, inf],\n            [inf, inf, -1]\n        ]), 2), # s4=2\n        (np.array([\n            [0, 1, inf],\n            [1, 0, inf],\n            [inf, inf, -1]\n        ]), 0)  # s5=0\n    ]\n\n    results = []\n    for W, s in test_cases:\n        cycle_list = find_negative_cycle(W, s)\n        results.append(f\"[{','.join(map(str, cycle_list))}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3235685"}]}