{"hands_on_practices": [{"introduction": "在处理多维数组时，一个常见的基础操作是计算任意矩形子区域内所有元素的和。如果对每个查询都进行暴力求和，当查询数量巨大时，效率会非常低下。本练习将引导你实现积分图（或称前缀和数组），这是一种强大的预计算技术，通过它我们能以恒定时间 $O(1)$ 响应任何矩形区域的和查询，是图像处理和计算几何领域中许多算法的基石。[@problem_id:3254618]", "problem": "考虑一个 $d=2$ 的二维矩形数组 $A$，其中 $A \\in \\mathbb{Z}^{n \\times m}$ 使用基于 $0$ 的包含性坐标进行索引。任务是设计、推导并实现一个方法，在一次性预处理步骤之后，能够以常数时间回答关于 $A$ 的任意轴对齐矩形和查询。从基本定义和容斥原理出发，不要假设任何预先推导出的公式。\n\n基本基础：\n- 定义 $A$ 的一个条目子集上的矩形和如下。对于索引 $r_1, r_2, c_1, c_2$ 满足 $0 \\le r_1 \\le r_2  n$ 和 $0 \\le c_1 \\le c_2  m$，矩形和为\n$$\nS(r_1, c_1, r_2, c_2) = \\sum_{i=r_1}^{r_2} \\sum_{j=c_1}^{c_2} A[i,j].\n$$\n- 定义一个由 $A$ 构建的二维前缀和数组（也称为积分图）$P \\in \\mathbb{Z}^{(n+1) \\times (m+1)}$，使得 $P$ 的每个条目编码了 $A$ 的一个左上角在原点的连续子数组的和。为 $P$ 使用基于 $1$ 的填充以避免边界特殊情况，这样 $P$ 的行索引范围从 $0$ 到 $n$，列索引范围从 $0$ 到 $m$，并且 $P[0,\\cdot] = 0$ 和 $P[\\cdot,0] = 0$。\n\n你的任务：\n1. 仅使用上述定义和容斥原理，推导一个用 $P$ 表示 $S(r_1, c_1, r_2, c_2)$ 的公式，该公式可实现每次查询 $O(1)$ 的时间复杂度。你的推导必须逻辑严谨，并基于求和性质和容斥原理；不要引入或假设任何快捷公式。\n2. 从第一性原理出发，推导使用 $A$ 构建 $P$ 的递推关系，以确保 $P$ 的所有条目都是正确的。清晰地解释为什么这个构建过程需要 $O(nm)$ 的时间。\n3. 实现一个程序，该程序：\n   - 从每个测试用例的 $A$ 构建 $P$。\n   - 使用你推导出的关于 $P$ 的容斥公式，在 $O(1)$ 时间内计算指定的矩形和查询 $S(r_1, c_1, r_2, c_2)$。\n   - 对所有提供的测试用例，按其出现的顺序，生成一行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。\n\n索引和正确性要求：\n- 对 $A$ 的矩形查询使用基于 $0$ 的包含性索引 $(r_1, c_1, r_2, c_2)$。\n- 按规定为 $P$ 使用基于 $1$ 的填充，以避免模糊的边界情况。\n- 所有数组和索引必须与所述约定保持一致处理。\n\n测试套件：\n- 测试用例 $1$：$n = 3$, $m = 4$，矩阵 $A^{(1)}$ 为 $[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]$，查询 $(r_1, c_1, r_2, c_2) = (1, 1, 2, 3)$。\n- 测试用例 $2$：相同的 $A^{(1)}$，查询 $(r_1, c_1, r_2, c_2) = (0, 0, 2, 3)$。\n- 测试用例 $3$：相同的 $A^{(1)}$，查询 $(r_1, c_1, r_2, c_2) = (0, 0, 0, 0)$。\n- 测试用例 $4$：$n = 2$, $m = 2$，矩阵 $A^{(4)}$ 为 $[[-1, 2], [3, -4]]$，查询 $(r_1, c_1, r_2, c_2) = (0, 0, 1, 1)$。\n- 测试用例 $5$：$n = 3$, $m = 3$，矩阵 $A^{(5)}$ 为 $[[0, 0, 0], [0, 1, 0], [0, 0, 0]]$，查询 $(r_1, c_1, r_2, c_2) = (0, 0, 1, 2)$。\n\n预期输出格式：\n- 你的程序应生成一行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表（例如，$[\\,\\text{result}_1,\\text{result}_2,\\text{result}_3\\,]$）。每个 $\\text{result}_k$ 必须是第 $k$ 个测试用例对应的矩形和 $S(r_1, c_1, r_2, c_2)$ 的整数值，并按上述给定的顺序排列。", "solution": "问题陈述经评估为**有效**。它在科学上基于计算机科学和数学的既定原理，特别是关于数据结构（多维数组）和算法（前缀和）。该问题定义良好，具有清晰、明确的定义、一致的约束和一组可验证的测试用例。它是自洽的，不需要外部信息或主观解释。因此，可以推导并实现一个形式化的解决方案。\n\n推导和实现按要求分两个阶段进行：推导常数时间查询公式和线性时间构建递推式，然后进行实现。\n\n### 1. 常数时间查询公式的推导\n\n目标是使用一个预计算的前缀和数组 $P$，在 $O(1)$ 时间内计算任意矩形子数组的和 $S(r_1, c_1, r_2, c_2)$。\n\n**前缀和数组 ($P$) 的定义**\n\n问题定义了一个带有基于 $1$ 的填充的前缀和数组 $P \\in \\mathbb{Z}^{(n+1) \\times (m+1)}$。$P[i,j]$ 处的值表示原数组 $A$ 中从原点 $(0,0)$ 到点 $(i-1, j-1)$（包含边界）的矩形内所有元素的和。形式上，对于 $i > 0$ 和 $j > 0$：\n$$\nP[i, j] = \\sum_{k=0}^{i-1} \\sum_{l=0}^{j-1} A[k,l]\n$$\n填充确保了当 $i=0$ 或 $j=0$ 时 $P[i,j] = 0$。这个约定通过消除边界检查的需要简化了查询公式。\n\n**使用容斥原理进行推导**\n\n查询要求计算和 $S(r_1, c_1, r_2, c_2) = \\sum_{i=r_1}^{r_2} \\sum_{j=c_1}^{c_2} A[i,j]$。这个和对应于由角点 $(r_1, c_1)$ 和 $(r_2, c_2)$ 定义的矩形区域。我们可以通过从一个始于 $(0,0)$ 的更大矩形开始，系统地减去不在查询矩形内的部分来计算这个和。这是容斥原理的直接应用。\n\n我们定义一个辅助函数 $Sum(r, c) = \\sum_{k=0}^{r} \\sum_{l=0}^{c} A[k,l]$，它表示从 $(0,0)$ 到 $(r,c)$ 的矩形和。用我们的前缀和数组 $P$ 来表示，即为 $Sum(r, c) = P[r+1, c+1]$。\n\n所期望的和 $S(r_1, c_1, r_2, c_2)$ 可以被看作是一个大矩形的面积减去其两个相邻的小矩形，再加上一个被减去了两次的小角矩形。\n\n1.  **包含大矩形：** 首先计算从原点 $(0,0)$ 到查询矩形右下角 $(r_2, c_2)$ 的所有元素的和。这个和是 $Sum(r_2, c_2) = P[r_2+1, c_2+1]$。我们称这个区域为 $D$，它包含了目标矩形以及其他三个区域。\n\n2.  **排除上方矩形：** 查询矩形上方的区域从 $(0,0)$ 延伸到 $(r_1-1, c_2)$。其和为 $Sum(r_1-1, c_2) = P[(r_1-1)+1, c_2+1] = P[r_1, c_2+1]$。我们称这个区域为 $C$。减去这个和可以移除我们目标矩形上方的元素。\n\n3.  **排除左侧矩形：** 查询矩形左侧的区域从 $(0,0)$ 延伸到 $(r_2, c_1-1)$。其和为 $Sum(r_2, c_1-1) = P[r_2+1, (c_1-1)+1] = P[r_2+1, c_1]$。我们称这个区域为 $B$。减去这个和可以移除我们目标矩形左侧的元素。\n\n4.  **重新包含被重复排除的角：** 当我们减去上方矩形 ($C$) 和左侧矩形 ($B$) 时，我们减去了它们相交的部分两次。这个相交部分是从 $(0,0)$ 到 $(r_1-1, c_1-1)$ 的小矩形。其和为 $Sum(r_1-1, c_1-1) = P[(r_1-1)+1, (c_1-1)+1] = P[r_1, c_1]$。我们称这个区域为 $A$。为了修正重复减法，我们必须将这个和加回来一次。\n\n结合这些步骤得到最终公式：\n$$\nS(r_1, c_1, r_2, c_2) = D - B - C + A\n$$\n$$\nS(r_1, c_1, r_2, c_2) = P[r_2+1, c_2+1] - P[r_2+1, c_1] - P[r_1, c_2+1] + P[r_1, c_1]\n$$\n该公式在预计算的数组 $P$ 中需要正好 $4$ 次查找和 $3$ 次算术运算（两次减法，一次加法）。由于这些操作耗时为常数，任何查询都可以在 $O(1)$ 时间内回答。使用带填充的数组 $P$ 巧妙地处理了 $r_1=0$ 或 $c_1=0$ 的情况，因为相应的项如 $P[r_2+1, 0]$ 或 $P[0, c_2+1]$ 会正确地计算为 $0$。\n\n### 2. 前缀和数组构建递推式的推导\n\n第二个任务是推导一个递推关系，用于在 $O(nm)$ 时间内从输入数组 $A$ 构建前缀和数组 $P$。\n\n根据 $P$ 的定义，单个元素 $A[i-1, j-1]$ 的值可以用 $P$ 中的值来表示。这等同于将我们的查询公式应用于一个 $1 \\times 1$ 的矩形：\n$$\nA[i-1, j-1] = S(i-1, j-1, i-1, j-1)\n$$\n使用推导出的公式，并令 $r_1=r_2=i-1$ 和 $c_1=c_2=j-1$：\n$$\nA[i-1, j-1] = P[(i-1)+1, (j-1)+1] - P[(i-1)+1, (j-1)] - P[(i-1), (j-1)+1] + P[(i-1), (j-1)]\n$$\n$$\nA[i-1, j-1] = P[i, j] - P[i, j-1] - P[i-1, j] + P[i-1, j-1]\n$$\n我们的目标是找到 $P[i,j]$ 的递推式。我们可以重新整理上述方程来解出 $P[i,j]$：\n$$\nP[i,j] = A[i-1, j-1] + P[i-1, j] + P[i, j-1] - P[i-1, j-1]\n$$\n这就是所求的递推关系。它表明，到 $A$ 的单元格 $(i-1, j-1)$ 为止的前缀和，可以由当前元素 $A[i-1, j-1]$ 和 $P$ 中三个相邻的、先前已计算的前缀和来计算：上方的一个 ($P[i-1,j]$)、左侧的一个 ($P[i,j-1]$) 和左上对角的一个 ($P[i-1, j-1]$)。\n\n要构建整个数组 $P$，我们可以遍历其索引，对从 $1$ 到 $n$ 的 $i$ 和从 $1$ 到 $m$ 的 $j$，在每一步应用此递推式。基准情况是填充的行和列，它们被初始化为 $0$。\n一个嵌套循环结构计算 $P$ 的每一个 $n \\times m$ 非填充条目：\n```\nfor i from 1 to n:\n  for j from 1 to m:\n    P[i,j] = A[i-1, j-1] + P[i-1,j] + P[i,j-1] - P[i-1,j-1]\n```\n由于每个 $P[i,j]$ 的计算涉及常数数量的算术运算和数组查找 ($O(1)$)，并且这对所有 $n \\times m$ 个单元格都执行一次，因此构建前缀和数组 $P$ 的总时间复杂度为 $O(nm)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the rectangle sum query problem for a suite of test cases.\n    It follows a two-phase process:\n    1. Preprocessing: Builds a 2D prefix-sum array (integral image).\n    2. Querying: Uses the prefix-sum array to answer queries in O(1) time.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"A\": np.array([\n                [1, 2, 3, 4],\n                [5, 6, 7, 8],\n                [9, 10, 11, 12]\n            ], dtype=np.int64),\n            \"query\": (1, 1, 2, 3)\n        },\n        # Test case 2\n        {\n            \"A\": np.array([\n                [1, 2, 3, 4],\n                [5, 6, 7, 8],\n                [9, 10, 11, 12]\n            ], dtype=np.int64),\n            \"query\": (0, 0, 2, 3)\n        },\n        # Test case 3\n        {\n            \"A\": np.array([\n                [1, 2, 3, 4],\n                [5, 6, 7, 8],\n                [9, 10, 11, 12]\n            ], dtype=np.int64),\n            \"query\": (0, 0, 0, 0)\n        },\n        # Test case 4\n        {\n            \"A\": np.array([\n                [-1, 2],\n                [3, -4]\n            ], dtype=np.int64),\n            \"query\": (0, 0, 1, 1)\n        },\n        # Test case 5\n        {\n            \"A\": np.array([\n                [0, 0, 0],\n                [0, 1, 0],\n                [0, 0, 0]\n            ], dtype=np.int64),\n            \"query\": (0, 0, 1, 2)\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        A = case[\"A\"]\n        query_coords = case[\"query\"]\n        \n        # Get dimensions of the original matrix A.\n        # A is 0-indexed, with dimensions n x m.\n        n, m = A.shape\n        \n        # 1. Preprocessing Step: Build the prefix-sum array P.\n        # P is (n+1) x (m+1) with 1-based padding for simplified calculations.\n        # P[0,:] and P[:,0] are all 0s by initialization.\n        P = np.zeros((n + 1, m + 1), dtype=np.int64)\n        \n        # Build P using the derived recurrence relation:\n        # P[i,j] = A[i-1,j-1] + P[i-1,j] + P[i,j-1] - P[i-1,j-1]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                P[i, j] = A[i - 1, j - 1] + P[i - 1, j] + P[i, j - 1] - P[i - 1, j - 1]\n                \n        # 2. Query Step: Compute the sum in O(1) time.\n        # The query is for the rectangle with inclusive 0-based coordinates\n        # (r1, c1) to (r2, c2).\n        r1, c1, r2, c2 = query_coords\n        \n        # Use the derived inclusion-exclusion formula:\n        # S(r1, c1, r2, c2) = P[r2+1, c2+1] - P[r1, c2+1] - P[r2+1, c1] + P[r1, c1]\n        # The indices of P are offset by +1 relative to A's indices.\n        sum_val = P[r2 + 1, c2 + 1] - P[r1, c2 + 1] - P[r2 + 1, c1] + P[r1, c1]\n        \n        results.append(sum_val)\n\n    # Final print statement in the exact required format.\n    # np.int64 objects must be converted to standard Python ints for str()\n    # to format them without any type-specific annotations.\n    print(f\"[{','.join(map(str, [int(r) for r in results]))}]\")\n\nsolve()\n```", "id": "3254618"}, {"introduction": "在掌握了如何高效求和子区域之后，我们可以挑战一个更复杂的经典优化问题：寻找具有最大元素和的连续子矩阵。这个问题展示了一种强大的算法设计范式：将高维度问题降解为一系列更简单的低维度问题。通过巧妙地将二维矩阵的行进行组合，并结合著名的一维最大子数组和算法（Kadane's Algorithm），你将能够系统性地解决这个问题。[@problem_id:3254593]", "problem": "一位开发人员需要处理整数值的多维数组，并且必须从数组中和与连续性的基本原理出发，计算其中的最大和连续区域。从以下基本定义开始：一个二维数组的形状为 $n \\times m$，一个三维数组的形状为 $n \\times m \\times k$；一维中的连续子数组由索引区间 $[i,j]$ 指定，其中 $0 \\le i \\le j  N$；二维中的连续子矩阵由区间 $[r_1,r_2]$ 和 $[c_1,c_2]$ 指定，其中 $0 \\le r_1 \\le r_2  n$ 且 $0 \\le c_1 \\le c_2  m$；三维中的连续子长方体由区间 $[r_1,r_2]$、$[c_1,c_2]$ 和 $[z_1,z_2]$ 指定，其中 $0 \\le r_1 \\le r_2  n$、$0 \\le c_1 \\le c_2  m$ 且 $0 \\le z_1 \\le z_2  k$。任何此类区域的和定义为将指定范围内索引的所有条目相加。一维最大连续子数组问题要求找到一个具有最大和的连续区间；已知该问题存在一种通过动态规划 (Dynamic Programming (DP)) 实现的线性时间解法，该解法仅使用常数额外空间。基于这些基础，任务是推导并实现两种算法：首先，对于二维矩阵，推导一种方法，该方法迭代选择行边界对，并将问题简化为对一个适当构造的压缩数组进行跨列的一维最大连续子数组问题；其次，对于三维张量，推广该思想，通过固定两个维度（行和列）形成一个沿剩余深度维度的一维数组，并计算最大连续深度区间。开发人员必须将算法以程序形式呈现，为提供的测试套件计算所需的最大和，然后在附带的分析中，根据 $n$、$m$ 和 $k$ 对两种算法的时间复杂度进行量化，并阐明所使用的任何预计算的效果。\n\n程序必须是完全自包含的（无用户输入），并生成单行输出，该输出将所有提供的测试用例的整数结果汇总成一个包含在方括号中的逗号分隔列表，顺序与下面列出的完全一致。此问题不涉及物理单位或角度，也没有舍入操作。\n\n实现上述两种算法，并将其应用于以下测试套件。\n\n二维 (2D) 矩阵：\n- 形状为 $4 \\times 5$ 的矩阵 $A_1$：\n  $[ [1, -2, -1, 4, -1], [ -8, 3, 4, -2, 2 ], [ 3, -1, 2, 1, -5 ], [ -4, 2, -1, 3, 1 ] ]$\n- 形状为 $2 \\times 2$ 的矩阵 $A_2$（全为负数，用于测试边界情况）：\n  $[ [-5, -1], [-2, -3] ]$\n\n三维 (3D) 张量：\n- 形状为 $3 \\times 3 \\times 4$ 的张量 $B_1$，以沿深度维度的四个层的形式给出（每层是一个 $3 \\times 3$ 的矩阵）：\n  层 $z=0$：$[ [1, -2, 0], [-1, 3, -1], [2, -1, 1] ]$\n  层 $z=1$：$[ [-2, 1, 4], [3, -1, 2], [-1, 2, -3] ]$\n  层 $z=2$：$[ [0, 2, -1], [-3, 4, 1], [2, -2, 0] ]$\n  层 $z=3$：$[ [-1, -2, 3], [1, 0, -1], [2, 1, -2] ]$\n- 形状为 $3 \\times 3 \\times 1$ 的张量 $B_2$（深度为 1，可简化为单个二维层）：\n  单层 $z=0$：$[ [-1, 2, -3], [4, -5, 6], [-7, 8, -9] ]$\n\n对于每个 2D 测试用例，计算所有连续子矩阵的最大和。对于每个 3D 测试用例，计算所有连续子长方体的最大和。您的程序应生成单行输出，其中包含一个逗号分隔的、用方括号括起来的结果列表，顺序为 $[A_1, A_2, B_1, B_2]$，例如 $[r_1,r_2,r_3,r_4]$，其中 $r_i$是表示相应最大和的整数。\n\n覆盖设计：\n- 案例 $A_1$ 是一个一般的混合符号 2D 实例，用于检验跨列累加简化为一维问题的方法。\n- 案例 $A_2$ 是一个全为负值条目的 2D 边界实例，以确保算法在所有和都为负时能正确返回最大的单个条目。\n- 案例 $B_1$ 是一个混合符号 3D 实例，需要固定两个维度并使用高效的每层矩形求和来为一维最大连续子数组算法构建一维深度序列。\n- 案例 $B_2$ 是一个 $k=1$ 的 3D 边界实例，它简化为 2D 最大和子矩阵问题。", "solution": "该问题被评估为有效。这是一个良构的算法挑战，立足于数据结构与算法领域中动态规划和计算复杂度的既定原则。定义清晰，目标可形式化，测试用例具体，可用于验证所推导算法在各种条件下的正确性。\n\n问题的核心是通过推广一个已知的一维 (1D) 解法，来寻找二维 (2D) 和三维 (3D) 整数值数组中的最大和连续区域。\n\n### 1. 一维基本情况：最大连续子数组和\n\n这个问题的基础是一维最大连续子数组和问题。给定一个长度为 $N$ 的一维数组 $A$，目标是找到索引 $i$ 和 $j$（$0 \\le i \\le j  N$），使得和 $\\sum_{k=i}^{j} A[k]$ 最大化。\n\n这个问题可以使用 Kadane's algorithm 在 $O(N)$ 时间和 $O(1)$ 额外空间内解决，这是一种经典的动态规划方法。其核心思想是遍历数组，同时维护以当前位置结尾的子数组的最大和。设 $c_i$ 是以索引 $i$ 结尾的连续子数组的最大和，而 $g$ 是目前为止找到的全局最大和。递推关系为：\n$c_i = \\max(A[i], c_{i-1} + A[i])$\n$g_i = \\max(g_{i-1}, c_i)$\n\n该逻辑能正确处理全为负数的数组，在这种情况下，结果是数组中最大（即负得最少）的单个元素。\n\n### 2. 二维算法的推导\n\n对于一个形状为 $n \\times m$ 的二维矩阵 $A$，我们需要找到具有最大和的连续子矩阵。该问题要求一种能将此 2D 问题简化为一系列 1D 问题的方法。\n\n算法按以下步骤进行：\n1.  初始化一个全局最大和 $S_{max}$ 为一个非常小的数（例如，$-\\infty$）。\n2.  遍历所有可能的顶部和底部行边界对，由索引 $r_1$ 和 $r_2$ 表示，其中 $0 \\le r_1 \\le r_2  n$。\n3.  对于每个固定的对 $(r_1, r_2)$，我们创建一个大小为 $m$ 的临时一维数组，称之为 `col_sums`。每个元素 `col_sums[c]` 将存储从行 $r_1$ 到 $r_2$ 的列 $c$ 中元素的和。即 $\\text{col\\_sums}[c] = \\sum_{r=r_1}^{r_2} A[r][c]$。\n4.  这个 `col_sums` 数组代表了由行 $r_1$ 到 $r_2$ 定义的子矩阵的“压缩”视图。`col_sums` 中任何和为 $S$ 的连续子数组都对应于原始矩阵 $A$ 中一个和同样为 $S$ 的连续子矩阵（跨越行 $r_1$ 到 $r_2$ 以及相应的列区间）。\n5.  将一维最大连续子数组算法 (Kadane's) 应用于 `col_sums` 数组，以找到固定行 $r_1$ 和 $r_2$ 的最大和。\n6.  如果第 5 步的结果更大，则用其更新全局最大和 $S_{max}$。\n\n在遍历所有可能的 $(r_1, r_2)$ 对之后，$S_{max}$ 将持有最大子矩阵和。\n\n**复杂度分析 (2D)：**\n- $r_1$ 的外层循环运行 $n$ 次。\n- $r_2$ 的内层循环平均运行 $n/2$ 次，因此为 $O(n)$。\n- 在循环内部，我们构建 `col_sums` 数组。这可以高效地完成。对于一个固定的 $r_1$，当 $r_2$ 递增时，我们可以通过加上新行 $r_2$ 的值来更新 `col_sums`。此更新需要 $O(m)$ 时间。\n- 将 Kadane's algorithm 应用于 `col_sums` 需要 $O(m)$ 时间。\n- 总时间复杂度是这些嵌套操作的乘积：$O(n \\cdot n \\cdot m) = O(n^2 m)$。\n- 空间复杂度为 $O(m)$，用于存储 `col_sums` 数组。此方法没有指定或需要预计算。\n\n### 3. 三维算法的推导\n\n对于一个形状为 $n \\times m \\times k$ 的三维张量 $B$，我们推广上述策略。该问题要求我们固定两个维度（行和列）的边界，并将问题简化为沿第三个维度（深度）的一维搜索。\n\n算法如下：\n1.  初始化一个全局最大和 $S_{max}$ 为 $-\\infty$。\n2.  遍历 $n \\times m$ 平面中所有可能的矩形横截面。这由四个边界索引定义：$r_1, r_2, c_1, c_2$，其中 $0 \\le r_1 \\le r_2  n$ 且 $0 \\le c_1 \\le c_2  m$。\n3.  对于每个固定的矩形区域 $(r_1, c_1)$ 到 $(r_2, c_2)$，创建一个大小为 $k$ 的临时一维数组 `depth_sums`。\n4.  每个元素 `depth_sums[z]` 是在深度切片 $z$ 处固定矩形内所有元素的和。即 $\\text{depth\\_sums}[z] = \\sum_{r=r_1}^{r_2} \\sum_{c=c_1}^{c_2} B[r][c][z]$。\n5.  将一维最大连续子数组算法 (Kadane's) 应用于 `depth_sums`。其结果给出了横截面为该固定矩形的连续子长方体的最大和。\n6.  用第 5 步的结果更新全局最大和 $S_{max}$。\n\n**复杂度分析 (3D)：**\n对每个矩形和每个深度切片在第 4 步中进行朴素的求和计算将是低效的。直接实现将具有大约 $O(n^2 \\cdot m^2 \\cdot k \\cdot n \\cdot m) = O(n^3 m^3 k)$ 的复杂度。这在计算上是不可行的。\n\n为了使之可行，我们引入一个预计算步骤。\n- **预计算：** 对于 $k$ 个深度切片中的每一个，我们计算一个二维和区域表 (SAT)。对于一个矩阵 $M$，其 SAT $S$ 定义为 $S[i][j] = \\sum_{x=0}^{i} \\sum_{y=0}^{j} M[x][y]$。为一个 $n \\times m$ 矩阵构建 SAT 需要 $O(nm)$ 时间。由于有 $k$ 个切片，此预计算的总时间为 $O(nmk)$。\n- **主计算：** 有了 SAT，任何矩形区域的和（第 4 步）都可以在 $O(1)$ 时间内计算出来。主算法由四个针对 $r_1, r_2, c_1, c_2$ 的嵌套循环组成，为矩形横截面提供了 $O(n^2 m^2)$ 种选择。对于每种选择：构建大小为 $k$ 的 `depth_sums` 数组需要 $O(k)$ 时间，因为每次求和都是 $O(1)$ 的查找。将 Kadane's algorithm 应用于 `depth_sums` 需要 $O(k)$ 时间。主计算的总时间为 $O(n^2 m^2 \\cdot k)$。\n- **总体复杂度：** 总复杂度是预计算和主计算的和：$O(nmk + n^2 m^2 k)$。由于第二项占主导地位，因此总体时间复杂度为 $O(n^2 m^2 k)$。空间复杂度为 $O(nmk)$，用于存储 SAT。通过选择这种优化算法，满足了题干中讨论预计算的要求。\n\n算法现已完全指定，其复杂度也已分析。接下来将实现这些算法以解决给定的测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and applies algorithms for finding the maximum-sum contiguous sub-region\n    in 2D and 3D arrays, as per the problem specification.\n    \"\"\"\n\n    def kadane(arr: np.ndarray) - int:\n        \"\"\"\n        Computes the maximum contiguous subarray sum in O(N) time using Kadane's algorithm.\n        Handles the all-negative case correctly.\n        \"\"\"\n        if arr.size == 0:\n            return 0\n        \n        max_so_far = arr[0]\n        current_max = arr[0]\n        for i in range(1, arr.size):\n            x = arr[i]\n            current_max = max(x, current_max + x)\n            max_so_far = max(max_so_far, current_max)\n        return max_so_far\n\n    def max_sum_2d(matrix: np.ndarray) - int:\n        \"\"\"\n        Computes the maximum sum of a contiguous submatrix.\n        Complexity: O(n*n*m) where shape is (n, m).\n        \"\"\"\n        n, m = matrix.shape\n        if n == 0 or m == 0:\n            return 0\n\n        max_overall_sum = -float('inf')\n\n        for r1 in range(n):\n            col_sums = np.zeros(m, dtype=int)\n            for r2 in range(r1, n):\n                # Update column sums by adding the new row r2\n                col_sums += matrix[r2, :]\n                \n                # Apply Kadane's algorithm to find the max sum for the submatrix from r1 to r2\n                current_max = kadane(col_sums)\n                max_overall_sum = max(max_overall_sum, current_max)\n                \n        return int(max_overall_sum)\n\n    def get_sum_from_2d_sat(sat_2d: np.ndarray, r1: int, c1: int, r2: int, c2: int) - int:\n        \"\"\"\n        Calculates the sum of a rectangle from a 2D summed-area table in O(1).\n        \"\"\"\n        res = sat_2d[r2, c2]\n        if r1  0:\n            res -= sat_2d[r1 - 1, c2]\n        if c1  0:\n            res -= sat_2d[r2, c1 - 1]\n        if r1  0 and c1  0:\n            res += sat_2d[r1 - 1, c1 - 1]\n        return res\n\n    def max_sum_3d(tensor: np.ndarray) - int:\n        \"\"\"\n        Computes the maximum sum of a contiguous sub-cuboid.\n        Complexity: O(n*n*m*m*k) where shape is (n, m, k), using precomputation.\n        \"\"\"\n        n, m, k = tensor.shape\n        if n == 0 or m == 0 or k == 0:\n            return 0\n        \n        # Precomputation: Build a 2D summed-area table for each depth slice.\n        # Complexity: O(n*m*k)\n        sats = np.zeros_like(tensor, dtype=int)\n        for z in range(k):\n            sats[:, :, z] = np.cumsum(np.cumsum(tensor[:, :, z], axis=0), axis=1)\n\n        max_overall_sum = -float('inf')\n\n        # Main computation: Iterate over all possible (r,c) rectangles, then find max\n        # contiguous sum along depth.\n        # Complexity: O(n^2 * m^2 * k)\n        for r1 in range(n):\n            for r2 in range(r1, n):\n                for c1 in range(m):\n                    for c2 in range(c1, m):\n                        # Construct a 1D array of sums along the depth dimension\n                        # for the fixed rectangle (r1,c1)-(r2,c2).\n                        depth_sums = np.zeros(k, dtype=int)\n                        for z in range(k):\n                            depth_sums[z] = get_sum_from_2d_sat(sats[:, :, z], r1, c1, r2, c2)\n                        \n                        current_max = kadane(depth_sums)\n                        max_overall_sum = max(max_overall_sum, current_max)\n        \n        return int(max_overall_sum)\n\n    # Define the test cases from the problem statement.\n    A1 = np.array([\n        [1, -2, -1, 4, -1],\n        [-8, 3, 4, -2, 2],\n        [3, -1, 2, 1, -5],\n        [-4, 2, -1, 3, 1]\n    ], dtype=int)\n\n    A2 = np.array([\n        [-5, -1],\n        [-2, -3]\n    ], dtype=int)\n\n    B1_layers = [\n        np.array([[1, -2, 0], [-1, 3, -1], [2, -1, 1]], dtype=int),\n        np.array([[-2, 1, 4], [3, -1, 2], [-1, 2, -3]], dtype=int),\n        np.array([[0, 2, -1], [-3, 4, 1], [2, -2, 0]], dtype=int),\n        np.array([[-1, -2, 3], [1, 0, -1], [2, 1, -2]], dtype=int)\n    ]\n    B1 = np.stack(B1_layers, axis=2)\n\n    B2_layers = [\n        np.array([[-1, 2, -3], [4, -5, 6], [-7, 8, -9]], dtype=int)\n    ]\n    B2 = np.stack(B2_layers, axis=2)\n\n    # Calculate results for all test cases\n    results = [\n        max_sum_2d(A1),\n        max_sum_2d(A2),\n        max_sum_3d(B1),\n        max_sum_3d(B2)\n    ]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3254593"}, {"introduction": "尽管积分图对于查询非常高效，但它是静态的，意味着如果数组中的任何元素发生变化，重新计算整个积分图的成本会很高。本次高级实践将介绍树状数组（Fenwick Tree），一种能够同时支持高效单点更新和前缀和查询的动态数据结构。将此概念扩展到三维空间，并仔细处理不同索引约定（从一开始或从零开始）带来的细微差别，将构成一项严谨的挑战，从而巩固你对动态数据结构设计的理解。[@problem_id:3254617]", "problem": "给定一个三维数组 $A \\in \\mathbb{Z}^{n_x \\times n_y \\times n_z}$，其中 $n_x$、$n_y$ 和 $n_z$ 是正整数。任务是设计和分析三维 Fenwick 树（也称为二进制索引树，BIT）的两种实现，以支持对 $A$ 进行高效的单点更新和前缀和查询。其中一个实现必须使用基于 1 的索引，另一个必须使用基于 0 的索引。目标是形式化并验证在每种索引约定下，描述每个内部树单元存储内容的不变量，并彻底测试边界处的差一行为。\n\n您必须基于以下基本原则和经过充分检验的事实进行推导和设计：\n- 数组 $A$ 在整数加法下构成一个加法幺半群，且加法满足结合律和交换律。\n- 对于基于 1 的索引，三维数组的前缀和定义为 $P(x,y,z) = \\sum_{i=1}^{x} \\sum_{j=1}^{y} \\sum_{k=1}^{z} A[i,j,k]$，当任何参数为非正数时，其自然值为零；对于基于 0 的索引，定义为 $P(x,y,z) = \\sum_{i=0}^{x} \\sum_{j=0}^{y} \\sum_{k=0}^{z} A[i,j,k]$，当任何参数为负数时，其自然值为零。\n- 通过最低有效位进行的二进制分解定义为 $lsb(i) = i \\land (-i)$，其中 $i$ 为正整数，$\\land$ 表示按位与。对于基于 1 的索引，树桶是区间 $\\left[i - lsb(i) + 1, i\\right]$。对于基于 0 的索引，树桶使用恒等式 $i \\land (i+1)$ 来定义桶的起始位置。\n\n您必须实现：\n- 一个基于 1 的三维 Fenwick 树，其不变量是其内部单元 $T[i,j,k]$ 存储 $A[x,y,z]$ 的和，其中 $x \\in \\left[i - lsb(i) + 1, i\\right]$，$y \\in \\left[j - lsb(j) + 1, j\\right]$，$z \\in \\left[k - lsb(k) + 1, k\\right]$。\n- 一个基于 0 的三维 Fenwick 树，其不变量是其内部单元 $E[i,j,k]$ 存储 $A[x,y,z]$ 的和，其中 $x \\in \\left[i \\land (i+1), i\\right]$，$y \\in \\left[j \\land (j+1), j\\right]$，$z \\in \\left[k \\land (k+1), k\\right]$。\n\n您的程序必须：\n- 构建三维 Fenwick 树的两种变体。\n- 对 $A$ 应用指定的单点更新序列。\n- 对每个测试用例，验证：\n    1. 所有从 Fenwick 树计算出的被查询的轴对齐长方体和，都等于通过直接累加从 $A$ 中朴素计算出的相应和值。\n    2. 树的所有内部单元都满足各自的不变量，方法是将每个存储的单元与不变量所隐含的 $A$ 相应桶区域的和进行比较。\n\n使用容斥原理从前缀和计算常规长方体和。对于基于 1 的索引，对包含边界的长方体 $\\left[x_1,x_2\\right] \\times \\left[y_1,y_2\\right] \\times \\left[z_1,z_2\\right]$ 的查询必须使用由 $P(\\cdot,\\cdot,\\cdot)$ 构建的八项容斥表达式进行求值，这同样适用于基于 0 的索引，其中参数 $-1$ 产生零值。\n\n必须完全按照规定实现以下测试套件。每个测试用例指定索引模式、维度 $\\left(n_x,n_y,n_z\\right)$、形式为 $\\left(x,y,z,\\Delta\\right)$ 的更新序列，以及形式为 $\\left(x_1,y_1,z_1,x_2,y_2,z_2\\right)$ 的查询，所有查询都包含边界：\n\n- 测试用例 1（基于 1 的索引）：维度 $\\left(3,3,3\\right)$；更新 $\\left(1,1,1,5\\right)$, $\\left(3,3,3,7\\right)$, $\\left(2,2,2,-3\\right)$, $\\left(1,3,2,4\\right)$；查询 $\\left(1,1,1,3,3,3\\right)$, $\\left(2,2,2,2,2,2\\right)$, $\\left(1,3,2,1,3,2\\right)$, $\\left(1,2,2,3,2,2\\right)$, $\\left(3,3,3,3,3,3\\right)$。\n- 测试用例 2（基于 0 的索引）：维度 $\\left(3,3,3\\right)$；更新 $\\left(0,0,0,5\\right)$, $\\left(2,2,2,7\\right)$, $\\left(1,1,1,-3\\right)$, $\\left(0,2,1,4\\right)$；查询 $\\left(0,0,0,2,2,2\\right)$, $\\left(1,1,1,1,1,1\\right)$, $\\left(0,2,1,0,2,1\\right)$, $\\left(0,2,1,2,2,1\\right)$, $\\left(2,2,2,2,2,2\\right)$。\n- 测试用例 3（基于 1 的索引）：维度 $\\left(1,1,1\\right)$；更新 $\\left(1,1,1,10\\right)$, $\\left(1,1,1,-4\\right)$；查询 $\\left(1,1,1,1,1,1\\right)$, $\\left(1,1,1,1,1,1\\right)$。\n- 测试用例 4（基于 1 的索引）：维度 $\\left(4,2,5\\right)$；更新 $\\left(4,2,5,9\\right)$, $\\left(2,1,3,6\\right)$, $\\left(3,2,1,-7\\right)$, $\\left(1,1,5,8\\right)$, $\\left(2,2,5,-5\\right)$；查询 $\\left(1,1,1,4,2,5\\right)$, $\\left(2,1,3,4,2,5\\right)$, $\\left(3,2,1,3,2,1\\right)$, $\\left(1,2,5,4,2,5\\right)$。\n- 测试用例 5（基于 0 的索引）：维度 $\\left(5,5,5\\right)$；更新 $\\left(4,4,4,11\\right)$, $\\left(0,4,0,5\\right)$, $\\left(4,0,4,-2\\right)$, $\\left(2,2,3,7\\right)$, $\\left(1,3,4,-4\\right)$；查询 $\\left(0,0,0,4,4,4\\right)$, $\\left(1,3,4,4,4,4\\right)$, $\\left(0,4,0,0,4,0\\right)$, $\\left(0,0,4,4,0,4\\right)$, $\\left(2,2,3,2,2,3\\right)$。\n\n对于每个测试用例，您的程序必须计算一个布尔结果，指示不变量验证和所有查询比较是否都成功。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$）。不涉及物理单位或角度，所有结果都必须是布尔值。实现必须是一个完整的、可运行的程序，无需任何外部输入即可执行测试套件。", "solution": "该问题要求设计、实现并严格验证三维 Fenwick 树（或二进制索引树，BIT）的两种变体，一种采用基于 1 的索引，另一种采用基于 0 的索引。验证必须确认范围和查询的外部正确性，以及树的数据结构与其理论不变量的内部一致性。\n\nFenwick 树是一种数据结构，可以高效地计算数组中单个元素的前缀和与更新。其效率源于一种基于索引二进制表示的巧妙分解，使得这两种操作都能在相对于数组大小的对数时间内完成。对于一个 $d$ 维数组，这些操作需要 $O(\\log^{d} n)$ 的时间，其中 $n$ 是一个维度的大小。本问题涉及的是 $d=3$ 的情况。\n\nFenwick 树的基础在于这样一个原则：任何前缀和都可以表示为少量预先计算的子数组和（称为“桶”，bucket）的总和。Fenwick 树中的每个单元存储这样一个桶的和。不同索引方案之间的核心区别在于这些桶的定义方式。\n\n**1. 基于 1 的索引公式**\n\n在基于 1 的系统中，数组索引的范围是从 $1$ 到 $n$。Fenwick 树的结构是使用索引的最低有效位 (LSB) 来定义的。\n\n**原理：** 正整数 $i$ 的最低有效位，记为 $lsb(i)$，是其二进制表示中最右边的 '1' 的值。利用二进制补码整数表示，可以通过按位运算 $lsb(i) = i \\land (-i)$ 高效地计算它。\n\n**不变量：** 问题指定了基于 1 的三维 Fenwick 树的不变量，我们将其表示为 $T$。对于 $i \\in [1, n_x], j \\in [1, n_y], k \\in [1, n_z]$，单元 $T[i,j,k]$ 存储了原始数组 $A$ 中一个矩形长方体（桶）的和：\n$$T[i,j,k] = \\sum_{x=i-lsb(i)+1}^{i} \\sum_{y=j-lsb(j)+1}^{j} \\sum_{z=k-lsb(k)+1}^{k} A[x,y,z]$$\n树本身使用一个大小为 $(n_x+1) \\times (n_y+1) \\times (n_z+1)$ 的数组来实现，以自然地适应基于 1 的索引。\n\n**更新操作：** 要将 $A[x,y,z]$ 的值更新一个增量 $\\Delta$，我们必须将 $\\Delta$ 加到每个其桶包含元素 $A[x,y,z]$ 的树单元 $T[i,j,k]$ 上。当且仅当 $i-lsb(i)+1 \\le x \\le i$，$j-lsb(j)+1 \\le y \\le j$ 且 $k-lsb(k)+1 \\le z \\le k$ 时，此条件成立。所有这样的 $(i,j,k)$ 集合可以通过从 $(x,y,z)$ 开始，并反复将每个索引推进到其在隐式树结构中的“父”节点来找到。这种遍历通过更新规则 $i \\leftarrow i + lsb(i)$（对 $j$ 和 $k$ 也类似）实现。该过程一直持续到索引超出数组边界。\n\n**前缀和查询：** 为了计算前缀和 $P(x,y,z) = \\sum_{i=1}^{x} \\sum_{j=1}^{y} \\sum_{k=1}^{z} A[i,j,k]$，我们对一组特定的树单元的值求和，这些单元的桶构成了体积 $[1,x] \\times [1,y] \\times [1,z]$ 的一个不相交划分。这个集合可以通过从 $(x,y,z)$ 开始，并反复移动到“前驱”索引来找到，该索引定义了划分中的下一个桶。这种遍历由规则 $i \\leftarrow i - lsb(i)$（对 $j$ 和 $k$ 也类似）给出。该过程一直持续到索引变为零。\n\n**范围和（长方体）查询：** 对一个常规长方体 $[x_1, x_2] \\times [y_1, y_2] \\times [z_1, z_2]$ 的求和是使用容斥原理从前缀和计算得出的。设 $P(x,y,z)$ 为前缀和查询函数。其和为：\n$$ \\begin{align*} S = P(x_2, y_2, z_2) - P(x_1-1, y_2, z_2) - P(x_2, y_1-1, z_2) - P(x_2, y_2, z_1-1) \\\\ + P(x_1-1, y_1-1, z_2) + P(x_1-1, y_2, z_1-1) + P(x_2, y_1-1, z_1-1) \\\\ - P(x_1-1, y_1-1, z_1-1) \\end{align*} $$\n前缀和函数必须正确处理非正数参数，返回 $0$。\n\n**2. 基于 0 的索引公式**\n\n在基于 0 的系统中，数组索引的范围是从 $0$ 到 $n-1$。其位运算逻辑略有不同，但实现了相同的目标。\n\n**原理：** 桶的定义以及因此产生的更新/查询遍历，由按位与 ($\\land$) 和按位或 ($\\lor$) 运算的组合来控制。\n\n**不变量：** 问题指定了基于 0 的三维 Fenwick 树的不变量，我们将其表示为 $E$。对于 $i \\in [0, n_x-1], j \\in [0, n_y-1], k \\in [0, n_z-1]$，单元 $E[i,j,k]$ 存储了其在原始数组 $A$ 中对应桶的和：\n$$E[i,j,k] = \\sum_{x=i \\land (i+1)}^{i} \\sum_{y=j \\land (j+1)}^{j} \\sum_{z=k \\land (k+1)}^{k} A[x,y,z]$$\n该树可以使用一个大小为 $n_x \\times n_y \\times n_z$ 的数组来实现。\n\n**更新操作：** 要将 $A[x,y,z]$ 更新 $\\Delta$，我们必须将 $\\Delta$ 加到所有其桶包含 $A[x,y,z]$ 的 $E[i,j,k]$ 上。找到这些“父”单元的遍历从 $(x,y,z)$ 开始，并遵循规则 $i \\leftarrow i \\lor (i+1)$（对 $j$ 和 $k$ 也类似），直到索引越界。\n\n**前缀和查询：** 为了计算前缀和 $P(x,y,z) = \\sum_{i=0}^{x} \\sum_{j=0}^{y} \\sum_{k=0}^{z} A[i,j,k]$，我们从 $(x,y,z)$ 向后遍历。找到下一个前驱索引的规则是 $i \\leftarrow (i \\land (i+1)) - 1$（对 $j$ 和 $k$ 也类似）。该过程一直持续到索引变为负数。\n\n**范围和（长方体）查询：** 应用与基于 1 的情况相同的容斥公式。前缀和函数必须正确处理负数参数，返回 $0$。\n\n**3. 验证策略**\n\n为确保实现的正确性，在应用所有更新后，对每个测试用例执行双重验证。\n\n**内部不变量验证：** 这是一个关键的、低级别的检查。我们遍历内部 Fenwick 树数组（$T$ 或 $E$）的每个单元。对于每个单元，我们根据理论不变量，在一个朴素维护的基准真相数组 $A$ 中计算相应桶内元素的和。然后将这个计算出的和与树单元中存储的值进行比较。任何差异都表明更新逻辑的实现存在缺陷或对不变量的理解有误。\n\n**外部查询验证：** 此检查验证面向公众的功能。对于每个指定的长方体查询，我们使用 Fenwick 树的 `query` 方法计算和，该方法依赖于应用于前缀和的容斥原理。我们还通过直接迭代基准真相数组 $A$ 的相应元素来计算相同的和。不匹配表示前缀和逻辑或容斥原理实现中存在错误。\n\n只有当内部不变量验证和所有外部查询验证都通过时，一个测试用例才被认为是成功的。这个严格的过程通过验证其内部状态和外部行为，为实现的正确性提供了强有力的证据。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass FenwickTree3DOneBased:\n    \"\"\"A three-dimensional Fenwick tree with one-based indexing.\"\"\"\n    def __init__(self, nx: int, ny: int, nz: int):\n        self.nx = nx\n        self.ny = ny\n        self.nz = nz\n        self.tree = np.zeros((nx + 1, ny + 1, nz + 1), dtype=np.int64)\n\n    def update(self, x: int, y: int, z: int, delta: int):\n        \"\"\"Adds delta to the element at (x, y, z). Coordinates are 1-based.\"\"\"\n        i = x\n        while i = self.nx:\n            j = y\n            while j = self.ny:\n                k = z\n                while k = self.nz:\n                    self.tree[i, j, k] += delta\n                    k += k  -k\n                j += j  -j\n            i += i  -i\n\n    def _prefix_sum(self, x: int, y: int, z: int) - int:\n        \"\"\"Computes the prefix sum up to (x, y, z). Coordinates are 1-based.\"\"\"\n        if x = 0 or y = 0 or z = 0:\n            return 0\n        \n        s = 0\n        i = x\n        while i  0:\n            j = y\n            while j  0:\n                k = z\n                while k  0:\n                    s += self.tree[i, j, k]\n                    k -= k  -k\n                j -= j  -j\n            i -= i  -i\n        return s\n\n    def query(self, x1: int, y1: int, z1: int, x2: int, y2: int, z2: int) - int:\n        \"\"\"Computes the sum over the cuboid [x1..x2, y1..y2, z1..z2].\"\"\"\n        p = self._prefix_sum\n        res = (p(x2, y2, z2) - p(x1 - 1, y2, z2) - p(x2, y1 - 1, z2) - p(x2, y2, z1 - 1) +\n               p(x1 - 1, y1 - 1, z2) + p(x1 - 1, y2, z1 - 1) + p(x2, y1 - 1, z1 - 1) -\n               p(x1 - 1, y1 - 1, z1 - 1))\n        return res\n\nclass FenwickTree3DZeroBased:\n    \"\"\"A three-dimensional Fenwick tree with zero-based indexing.\"\"\"\n    def __init__(self, nx: int, ny: int, nz: int):\n        self.nx = nx\n        self.ny = ny\n        self.nz = nz\n        self.tree = np.zeros((nx, ny, nz), dtype=np.int64)\n\n    def update(self, x: int, y: int, z: int, delta: int):\n        \"\"\"Adds delta to the element at (x, y, z). Coordinates are 0-based.\"\"\"\n        i = x\n        while i  self.nx:\n            j = y\n            while j  self.ny:\n                k = z\n                while k  self.nz:\n                    self.tree[i, j, k] += delta\n                    k = k | (k + 1)\n                j = j | (j + 1)\n            i = i | (i + 1)\n\n    def _prefix_sum(self, x: int, y: int, z: int) - int:\n        \"\"\"Computes the prefix sum up to (x, y, z). Coordinates are 0-based.\"\"\"\n        if x  0 or y  0 or z  0:\n            return 0\n        \n        s = 0\n        i = x\n        while i = 0:\n            j = y\n            while j = 0:\n                k = z\n                while k = 0:\n                    s += self.tree[i, j, k]\n                    k = (k  (k + 1)) - 1\n                j = (j  (j + 1)) - 1\n            i = (i  (i + 1)) - 1\n        return s\n\n    def query(self, x1: int, y1: int, z1: int, x2: int, y2: int, z2: int) - int:\n        \"\"\"Computes the sum over the cuboid [x1..x2, y1..y2, z1..z2].\"\"\"\n        p = self._prefix_sum\n        res = (p(x2, y2, z2) - p(x1 - 1, y2, z2) - p(x2, y1 - 1, z2) - p(x2, y2, z1 - 1) +\n               p(x1 - 1, y1 - 1, z2) + p(x1 - 1, y2, z1 - 1) + p(x2, y1 - 1, z1 - 1) -\n               p(x1 - 1, y1 - 1, z1 - 1))\n        return res\n\ndef solve():\n    test_cases = [\n        {\n            \"mode\": \"one-based\", \"dims\": (3, 3, 3),\n            \"updates\": [(1, 1, 1, 5), (3, 3, 3, 7), (2, 2, 2, -3), (1, 3, 2, 4)],\n            \"queries\": [(1, 1, 1, 3, 3, 3), (2, 2, 2, 2, 2, 2), (1, 3, 2, 1, 3, 2), (1, 2, 2, 3, 2, 2), (3, 3, 3, 3, 3, 3)]\n        },\n        {\n            \"mode\": \"zero-based\", \"dims\": (3, 3, 3),\n            \"updates\": [(0, 0, 0, 5), (2, 2, 2, 7), (1, 1, 1, -3), (0, 2, 1, 4)],\n            \"queries\": [(0, 0, 0, 2, 2, 2), (1, 1, 1, 1, 1, 1), (0, 2, 1, 0, 2, 1), (0, 2, 1, 2, 2, 1), (2, 2, 2, 2, 2, 2)]\n        },\n        {\n            \"mode\": \"one-based\", \"dims\": (1, 1, 1),\n            \"updates\": [(1, 1, 1, 10), (1, 1, 1, -4)],\n            \"queries\": [(1, 1, 1, 1, 1, 1), (1, 1, 1, 1, 1, 1)]\n        },\n        {\n            \"mode\": \"one-based\", \"dims\": (4, 2, 5),\n            \"updates\": [(4, 2, 5, 9), (2, 1, 3, 6), (3, 2, 1, -7), (1, 1, 5, 8), (2, 2, 5, -5)],\n            \"queries\": [(1, 1, 1, 4, 2, 5), (2, 1, 3, 4, 2, 5), (3, 2, 1, 3, 2, 1), (1, 2, 5, 4, 2, 5)]\n        },\n        {\n            \"mode\": \"zero-based\", \"dims\": (5, 5, 5),\n            \"updates\": [(4, 4, 4, 11), (0, 4, 0, 5), (4, 0, 4, -2), (2, 2, 3, 7), (1, 3, 4, -4)],\n            \"queries\": [(0, 0, 0, 4, 4, 4), (1, 3, 4, 4, 4, 4), (0, 4, 0, 0, 4, 0), (0, 0, 4, 4, 0, 4), (2, 2, 3, 2, 2, 3)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        nx, ny, nz = case[\"dims\"]\n        ground_truth = np.zeros((nx, ny, nz), dtype=np.int64)\n        is_valid = True\n\n        if case[\"mode\"] == \"one-based\":\n            bit = FenwickTree3DOneBased(nx, ny, nz)\n            for x, y, z, delta in case[\"updates\"]:\n                ground_truth[x - 1, y - 1, z - 1] += delta\n                bit.update(x, y, z, delta)\n\n            # 1. Invariant validation\n            for i in range(1, nx + 1):\n                for j in range(1, ny + 1):\n                    for k in range(1, nz + 1):\n                        x_start = i - (i  -i)\n                        y_start = j - (j  -j)\n                        z_start = k - (k  -k)\n                        expected_sum = np.sum(ground_truth[x_start:i, y_start:j, z_start:k])\n                        if bit.tree[i, j, k] != expected_sum:\n                            is_valid = False\n                            break\n                    if not is_valid: break\n                if not is_valid: break\n            \n            # 2. Query validation\n            if is_valid:\n                for x1, y1, z1, x2, y2, z2 in case[\"queries\"]:\n                    bit_sum = bit.query(x1, y1, z1, x2, y2, z2)\n                    naive_sum = np.sum(ground_truth[x1 - 1:x2, y1 - 1:y2, z1 - 1:z2])\n                    if bit_sum != naive_sum:\n                        is_valid = False\n                        break\n        \n        elif case[\"mode\"] == \"zero-based\":\n            bit = FenwickTree3DZeroBased(nx, ny, nz)\n            for x, y, z, delta in case[\"updates\"]:\n                ground_truth[x, y, z] += delta\n                bit.update(x, y, z, delta)\n            \n            # 1. Invariant validation\n            for i in range(nx):\n                for j in range(ny):\n                    for k in range(nz):\n                        x_start = i  (i + 1)\n                        y_start = j  (j + 1)\n                        z_start = k  (k + 1)\n                        expected_sum = np.sum(ground_truth[x_start:i + 1, y_start:j + 1, z_start:k + 1])\n                        if bit.tree[i, j, k] != expected_sum:\n                            is_valid = False\n                            break\n                    if not is_valid: break\n                if not is_valid: break\n\n            # 2. Query validation\n            if is_valid:\n                for x1, y1, z1, x2, y2, z2 in case[\"queries\"]:\n                    bit_sum = bit.query(x1, y1, z1, x2, y2, z2)\n                    naive_sum = np.sum(ground_truth[x1:x2 + 1, y1:y2 + 1, z1:z2 + 1])\n                    if bit_sum != naive_sum:\n                        is_valid = False\n                        break\n        \n        results.append(is_valid)\n\n    print(f\"[{','.join(map(str, [r.lower() if isinstance(r, bool) else r for r in results]))}]\")\n\nsolve()\n```", "id": "3254617"}]}