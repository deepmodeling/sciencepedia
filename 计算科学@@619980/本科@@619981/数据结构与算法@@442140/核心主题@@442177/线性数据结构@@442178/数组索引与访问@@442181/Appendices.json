{"hands_on_practices": [{"introduction": "许多高级编程语言（如Python）提供了负数索引的便利功能，让我们可以从末尾轻松访问数组元素。这个练习将带你深入底层，探索如何在基础的、从零开始的连续内存模型之上，设计并实现这一功能。这不仅是关于编写代码，更是关于理解高级语言特性与底层硬件限制之间的桥梁——抽象层。[@problem_id:3208099]", "problem": "您的任务是指定并实现一个用于索引线性数组的规范化规则，该规则支持负数索引，其精神与 Python 编程语言一致。从随机存取存储器 (RAM) 中线性数组的基本模型开始，该模型是一个连续的内存块，其元素可通过从零开始的索引进行寻址。回想一下，中央处理器 (CPU) 通过将与 $j$ 成比例的偏移量添加到基地址来计算索引 $j$ 处元素的地址。在标准的从零开始的索引中，长度为 $N$ 的数组的有效索引正是满足 $0 \\le j \\le N - 1$ 的整数 $j$。在此基本模型中，负数索引不是直接有效的。\n\n您的目标是设计、论证并实现一个规范化方案，该方案将一个可能是负数的索引 $i$ 映射到长度为 $N$ 的数组的一个有效的从零开始的索引 $j$，其行为与广为人知的 Python 负数索引语义一致。具体来说，一个索引 $i$ 被认为是有效的，当且仅当它位于由 $N$ 决定的某个闭开区间内；并且如果 $i$ 是有效的，则规范化后的索引 $j$ 必须是集合 $\\{0, 1, \\dots, N-1\\}$ 中唯一的整数，该整数在该语义下指向与 $i$ 相同的元素。如果 $i$ 无效，您的程序必须报告该索引无效。您不能假设超出 Python 语义所允许的任何环绕行为；不要使用无约束的模约简。\n\n设计一个使用以下具体测试套件的程序。对于每个测试用例，您会得到一个非负整数数组 $A$ 和一个索引 $i$。您的程序必须计算：\n- 如果 $i$ 有效，则计算规范化索引 $j$；否则为规范化索引输出 $-1$，以及\n- 如果 $i$ 有效，则计算访问到的值 $v$；否则为访问到的值输出 $-1$。\n\n因此，每个测试用例的结果必须是一个双元素列表 $[j, v]$，其中 $j \\in \\{-1\\} \\cup \\{0, 1, \\dots, N-1\\}$ 且 $v \\in \\{-1\\} \\cup \\mathbb{Z}_{\\ge 0}$，用 $-1$ 表示无效访问。数组仅包含非负整数，因此哨兵值 $-1$ 是明确的。\n\n测试套件：\n- 令 $A_1 = [\\,5, 9, 2, 7\\,]$，长度 $N_1 = 4$。\n  1. $(A_1, i = -1)$\n  2. $(A_1, i = -4)$\n  3. $(A_1, i = 0)$\n  4. $(A_1, i = 3)$\n  5. $(A_1, i = 4)$\n  6. $(A_1, i = -5)$\n- 令 $A_2 = [\\,42\\,]$，长度 $N_2 = 1$。\n  7. $(A_2, i = -1)$\n  8. $(A_2, i = 0)$\n  9. $(A_2, i = 1)$\n  10. $(A_2, i = -2)$\n- 令 $A_3 = [\\,1, 3, 5, 7, 9\\,]$，长度 $N_3 = 5$。\n  11. $(A_3, i = -2)$\n  12. $(A_3, i = -5)$\n  13. $(A_3, i = -6)$\n  14. $(A_3, i = 4)$\n  15. $(A_3, i = 5)$\n\n您的程序必须按顺序计算上述所有 15 个测试用例的结果，并生成单行输出，将它们聚合为一个用方括号括起来的、以逗号分隔的列表。该列表的每个元素本身必须是对应测试用例的一个双元素列表 $[j, v]$。例如，输出的形式为 $[[j_1, v_1],[j_2, v_2],\\dots,[j_{15}, v_{15}]]$，不含空格。此问题中没有物理单位或角度，因此不需要单位转换。\n\n约束和要求：\n- 您的推理必须基于从零开始的数组索引的规范模型和内存的连续性，并论证 $i$ 的有效性区间以及从 $i$ 和 $N$ 计算 $j$ 的方法，而不要使用任何没有根据的“捷径”公式。\n- 每个测试用例的规范化和访问时间复杂度必须为 $O(1)$。\n- 最终输出格式必须是仅包含一行结果的字符串，该结果为一个用方括号括起来的、以逗号分隔的列表，不含空格，其中每个结果都是一个指定的双元素列表 $[j,v]$。", "solution": "我们从存储在随机存取存储器 (RAM) 中长度为 $N$ 的线性数组的核心定义开始：有效的从零开始的索引正是满足 $0 \\le j \\le N - 1$ 的整数 $j$。中央处理器 (CPU) 通过计算基地址加上一个与 $j$ 成比例的偏移量来定位元素 $A[j]$，因此任何有效的引用都必须映射到集合 $\\{0,1,\\dots,N-1\\}$ 中的一个整数 $j$。\n\n我们必须扩展索引以允许负数索引，其方式要与 Python 一致，同时忠实于基本模型。在 Python 中，负数索引指的是从序列末尾开始计数的位置：最后一个元素的索引为 $-1$，倒数第二个为 $-2$，依此类推。只要从末尾开始的计数不超过序列长度，这种解释才是有意义的。因此，对于长度为 $N$ 的数组，可接受的索引 $i$ 集合恰好是整数区间\n$$\n-N \\le i \\le N-1,\n$$\n这可以解释为半开区间 $[-N, N)$，因为 $i = N$ 将指向末尾之后的一个位置。\n\n现在我们来论证这个规范化规则，它为每个可接受的 $i$ 产生一个唯一的从零开始的索引 $j \\in \\{0,1,\\dots,N-1\\}$：\n- 如果 $i$ 已经是非负且在界限内，即 $0 \\le i \\le N-1$，那么 $i$ 指向的元素已经是 $A[i]$，所以规范化后的索引必须是 $j = i$。\n- 如果 $i$ 是负数但不是太负，即 $-N \\le i \\le -1$，那么 $-i$ 是从末尾开始的计数，所以期望的元素是其从零开始的索引为 $N - (-i) = N + i$ 的那个。这给出了一个候选值 $j = N + i$。我们必须检查 $0 \\le j \\le N-1$：由于 $i \\le -1$，我们有 $j \\le N-1$；由于 $i \\ge -N$，我们有 $j \\ge 0$。因此 $j$ 是有效且唯一的。\n\n如果 $i$ 落在可接受的区间 $[-N, N)$ 之外——即，如果 $i \\le -N - 1$ 或 $i \\ge N$——那么在从零开始的模型中，没有数组元素与 $i$ 对应，访问必须被视为无效。\n\n总结一下规范化函数 $f(i, N)$，它返回规范化索引 $j$ 或发出无效信号：\n- 如果 $0 \\le i \\le N-1$，则 $f(i, N) = i$。\n- 否则如果 $-N \\le i \\le -1$，则 $f(i, N) = N + i$。\n- 否则，$i$ 无效。\n\n这个规则是直接从零基索引的基础和将负数索引解释为从末尾计数的概念推导出来的，没有调用无约束的模运算，后者会错误地允许超出区间 $[-N, N)$ 的索引。\n\n算法设计：\n- 给定数组 $A$ 和索引 $i$，计算 $N = \\lvert A \\rvert$。\n- 如果 $0 \\le i \\le N-1$，返回序对 $[i, A[i]]$。\n- 否则如果 $-N \\le i \\le -1$，返回序对 $[N + i, A[N + i]]$。\n- 否则，返回序对 $[-1, -1]$ 以表示无效访问。\n每个检查和算术操作都是 $O(1)$，所以每个测试用例的总时间是 $O(1)$。\n\n我们现在将此应用于指定的测试套件。\n\n对于 $A_1 = [\\,5, 9, 2, 7\\,]$，其中 $N_1 = 4$：\n1. $i = -1$：因为 $-4 \\le -1 \\le -1$，所以 $j = 4 + (-1) = 3$，值 $= 7$，结果 $[3, 7]$。\n2. $i = -4$：因为 $-4 \\le -4 \\le -1$，所以 $j = 4 + (-4) = 0$，值 $= 5$，结果 $[0, 5]$。\n3. $i = 0$：$0 \\le 0 \\le 3$, $j = 0$，值 $= 5$，结果 $[0, 5]$。\n4. $i = 3$：$0 \\le 3 \\le 3$, $j = 3$，值 $= 7$，结果 $[3, 7]$。\n5. $i = 4$：$i \\ge N_1$，无效，结果 $[-1, -1]$。\n6. $i = -5$：$i \\le -N_1 - 1$，无效，结果 $[-1, -1]$。\n\n对于 $A_2 = [\\,42\\,]$，其中 $N_2 = 1$：\n7. $i = -1$：$-1 \\le -1 \\le -1$, $j = 1 + (-1) = 0$，值 $= 42$，结果 $[0, 42]$。\n8. $i = 0$：$0 \\le 0 \\le 0$, $j = 0$，值 $= 42$，结果 $[0, 42]$。\n9. $i = 1$：$i \\ge N_2$，无效，结果 $[-1, -1]$。\n10. $i = -2$：$i \\le -N_2 - 1$，无效，结果 $[-1, -1]$。\n\n对于 $A_3 = [\\,1, 3, 5, 7, 9\\,]$，其中 $N_3 = 5$：\n11. $i = -2$：$-5 \\le -2 \\le -1$, $j = 5 + (-2) = 3$，值 $= 7$，结果 $[3, 7]$。\n12. $i = -5$：$-5 \\le -5 \\le -1$, $j = 5 + (-5) = 0$，值 $= 1$，结果 $[0, 1]$。\n13. $i = -6$：$i \\le -N_3 - 1$，无效，结果 $[-1, -1]$。\n14. $i = 4$：$0 \\le 4 \\le 4$, $j = 4$，值 $= 9$，结果 $[4, 9]$。\n15. $i = 5$：$i \\ge N_3$，无效，结果 $[-1, -1]$。\n\n因此，按从测试 1 到测试 15 的顺序，程序必须输出单行编码：\n$$\n[[3,7],[0,5],[0,5],[3,7],[-1,-1],[-1,-1],[0,42],[0,42],[-1,-1],[-1,-1],[3,7],[0,1],[-1,-1],[4,9],[-1,-1]]\n$$\n按输出格式要求，不含任何中间的空格。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport json\n\ndef normalize_index(i: int, n: int) - int:\n    \"\"\"\n    Normalize possibly negative index i for sequence length n under Python-like semantics.\n    Returns:\n        - normalized index in [0, n-1] if valid\n        - -1 if invalid\n    \"\"\"\n    if 0 = i  n:\n        return i\n    if -n = i  0:\n        return n + i\n    return -1\n\ndef access_with_normalization(arr, i):\n    \"\"\"\n    Return [j, v] where j is normalized index or -1 if invalid,\n    and v is arr[j] if valid else -1.\n    \"\"\"\n    n = len(arr)\n    j = normalize_index(i, n)\n    if j == -1:\n        return [-1, -1]\n    return [j, arr[j]]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    A1 = [5, 9, 2, 7]     # N1 = 4\n    A2 = [42]             # N2 = 1\n    A3 = [1, 3, 5, 7, 9]  # N3 = 5\n\n    test_cases = [\n        (A1, -1),\n        (A1, -4),\n        (A1, 0),\n        (A1, 3),\n        (A1, 4),\n        (A1, -5),\n\n        (A2, -1),\n        (A2, 0),\n        (A2, 1),\n        (A2, -2),\n\n        (A3, -2),\n        (A3, -5),\n        (A3, -6),\n        (A3, 4),\n        (A3, 5),\n    ]\n\n    results = []\n    for arr, idx in test_cases:\n        results.append(access_with_normalization(arr, idx))\n\n    # Final print statement in the exact required format: no spaces.\n    print(json.dumps(results, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3208099"}, {"introduction": "对于一个标准的二维数组，交换两行数据意味着大量的内存复制，操作成本与行宽成正比（$O(m)$）。本练习将引导你设计一种更高效的数据结构，通过引入一个间接层（或称“行指针数组”），实现近乎瞬时的（$O(1)$）行交换。这个实践将揭示计算机科学中的一个核心思想：通过分离数据的逻辑视图与物理存储，我们可以用微小的访问开销换取特定操作的巨大性能提升。[@problem_id:3208065]", "problem": "考虑一个构建在随机存取存储器 (RAM) 之上的二维数组抽象，其中通过索引访问任何条目的时间是常数时间，记为 $O(1)$。在传统的行主序表示法中，元素 $A[i][j]$ 的地址是通过基地址和线性偏移量使用步幅（列数）计算得出的。具体而言，在行主序布局下，线性偏移量为 $i \\cdot m + j$，其中 $i$ 是行索引，$j$ 是列索引，$m$ 是列数。在具有显式指针的语言和系统中，可以将二维数组表示为一个指向行块的指针数组。在这种设计中，交换整行可以通过交换指针数组中相应的指针来实现，而不是移动行数据，这在原则上是 $O(1)$ 的操作。\n\n你的任务是设计一个二维数组数据结构，通过操作一个内部的行引用数组来支持常数时间的行交换，同时保持 $O(1)$ 的索引性能。你将把此设计实现为一个完整、可运行的程序，该程序执行一个确定性的测试套件，并以指定格式输出结果。\n\n需求和约束：\n- 数据结构必须维护：\n  - 一个包含 $n$ 个行块的存储区，每个行块长度为 $m$，其中包含实际值。\n  - 一个长度为 $n$ 的行间接向量 $R$，使得逻辑坐标 $\\langle i, j \\rangle$ 处的值是通过物理存储中由 $R[i]$ 索引的行、第 $j$ 列的值来检索的。\n- 需要支持的操作有：\n  - get$(i,j)$：以 $O(1)$ 的时间复杂度返回逻辑行 $i$ 和逻辑列 $j$ 处的值。\n  - set$(i,j,v)$：以 $O(1)$ 的时间复杂度将逻辑行 $i$ 和逻辑列 $j$ 处的值设置为 $v$。\n  - row\\_swap$(i,k)$：通过更新间接向量 $R$，以 $O(1)$ 的时间复杂度交换逻辑行 $i$ 和 $k$。\n  - sum\\_row$(i)$：返回逻辑行 $i$ 中所有值的总和；此操作可能需要 $O(m)$ 的时间。\n- 你必须在你的解决方案中证明，为什么在单位成本随机存取模型（unit-cost RAM model）下，get$(i,j)$、set$(i,j,v)$ 和 row\\_swap$(i,k)$ 的时间复杂度都是 $O(1)$。\n\n测试套件的初始化规则：\n- 对于每个测试用例，初始化存储行，使得物理存储行 $i$ 和列 $j$ 处的值由每个用例给定的函数 $f(i,j)$ 定义。\n\n测试套件规范：\n- 实现以下四个测试用例，以探究正确性的不同方面：\n\n  用例 1（一般情况）：\n  - 参数：$n = 3$, $m = 4$ 及 $f(i,j) = 10 \\cdot i + j$。\n  - 操作和记录的结果：\n    - $r_1$：在任何交换之前执行 get$(1,2)$。\n    - 执行 row\\_swap$(0,2)$。\n    - $r_2$：在交换后执行 get$(0,3)$。\n    - 执行 set$(2,1,999)$。\n    - $r_3$：在设置值后执行 get$(2,1)$。\n    - $r_4$：在所有操作后执行 sum\\_row$(0)$。\n\n  用例 2（单行边界情况）：\n  - 参数：$n = 1$, $m = 5$ 及 $f(i,j) = i + j$。\n  - 操作和记录的结果：\n    - $r_1$：在任何交换之前执行 get$(0,4)$。\n    - 执行 row\\_swap$(0,0)$。\n    - $r_2$：在交换后执行 get$(0,4)$。\n    - 执行 set$(0,2,50)$。\n    - $r_3$：在设置值后执行 get$(0,2)$。\n    - $r_4$：在所有操作后执行 sum\\_row$(0)$。\n\n  用例 3（单列边界情况）：\n  - 参数：$n = 4$, $m = 1$ 及 $f(i,j) = 100 \\cdot i + j$。\n  - 操作和记录的结果：\n    - $r_1$：在任何交换之前执行 get$(3,0)$。\n    - 执行 row\\_swap$(3,0)$。\n    - $r_2$：在交换后执行 get$(3,0)$。\n    - 执行 set$(0,0,7)$。\n    - $r_3$：在设置值后执行 get$(0,0)$。\n    - $r_4$：在所有操作后执行 sum\\_row$(0)$。\n\n  用例 4（多次交换的组合）：\n  - 参数：$n = 5$, $m = 3$ 及 $f(i,j) = i \\cdot m + j$。\n  - 操作和记录的结果：\n    - $r_1$：在任何交换之前执行 get$(2,1)$。\n    - 执行 row\\_swap$(0,4)$，然后执行 row\\_swap$(1,3)$，再执行 row\\_swap$(0,1)$。\n    - $r_2$：在交换后执行 get$(2,1)$。\n    - 执行 set$(4,2,12345)$。\n    - $r_3$：在设置值后执行 get$(4,2)$。\n    - $r_4$：在所有操作后执行 sum\\_row$(0)$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含所有四个用例的结果，形式为一个用方括号括起来的、无空白字符的逗号分隔列表。每个用例的结果必须是一个包含四个整数的、用方括号括起来的逗号分隔列表。例如，输出必须看起来像 $[[a_1,a_2,a_3,a_4],[b_1,b_2,b_3,b_4],[c_1,c_2,c_3,c_4],[d_1,d_2,d_3,d_4]]$，其中每个符号表示其所在用例中指定操作产生的整数。", "solution": "该问题要求设计并实现一个支持常数时间行交换的二维数组数据结构。这通过使用一个间接层来实现，其中逻辑行索引被映射到物理行索引。\n\n提出的数据结构由两个主要部分组成：\n$1$. 一个维度为 $n \\times m$ 的物理存储数组，记为 $S$。该数组保存实际的数据元素。在我们的实现中，这将是一个 `NumPy` 数组。\n$2$. 一个长度为 $n$ 的行间接向量，记为 $R$。该向量存储从逻辑行索引到物理行索引的映射。最初，对于从 $0$ 到 $n-1$ 的所有逻辑行索引 $i$，$R[i]$ 被设置为 $i$，表示一个直接的一一映射。\n\n坐标 $\\langle i, j \\rangle$ 处的逻辑值是通过首先从间接向量中找到物理行索引 `physical_row_index = R[i]`，然后访问 `S[physical_row_index][j]` 处的元素来获取的。\n\n操作的实现如下：\n\n- `get(i, j)`：要检索逻辑行 $i$ 和逻辑列 $j$ 的值，数据结构会执行两次查找。首先，它访问间接向量 $R$ 的索引 $i$ 以找到物理行索引，我们称之为 $p_i = R[i]$。其次，它访问物理存储 $S$ 的第 $p_i$ 行和第 $j$ 列。该值即为 $S[p_i][j]$。\n  - **复杂度证明**：在单位成本随机存取存储器 (RAM) 模型下，通过索引访问数组元素是常数时间操作，记为 $O(1)$。`get` 操作由两次这样的数组访问组成：一次在 $R$ 上，一次在 $S$ 上。常数次 $O(1)$ 操作得出的总体时间复杂度为 $O(1)$。\n\n- `set(i, j, v)`：要将逻辑行 $i$ 和逻辑列 $j$ 的值设置为新值 $v$，其过程与 `get` 类似。它首先解析出物理行索引 $p_i = R[i]$，然后将新值赋给 $S[p_i][j]$ 处的元素。\n  - **复杂度证明**：此操作涉及一次对 $R$ 的数组查找和一次对 $S$ 的数组写入。在 RAM 模型中，两者都是 $O(1)$ 操作。因此，`set` 操作的时间复杂度为 $O(1)$。\n\n- `row_swap(i, k)`：要交换逻辑行 $i$ 和 $k$，数据结构仅操作间接向量 $R$。它交换存储在 $R$ 中索引 $i$ 和 $k$ 处的值。也就是说，值 $R[i]$ 和 $R[k]$ 被交换。包含大量数据的物理存储 $S$ 保持不变。\n  - **复杂度证明**：交换数组中的两个元素需要固定数量的操作（通常是使用一个临时变量进行三次赋值）。由于操作数量与数组（$n$）或行（$m$）的大小无关，`row_swap` 操作的时间复杂度为 $O(1)$。这是基于间接的设计的关键优势。\n\n- `sum_row(i)`：要计算逻辑行 $i$ 中所有元素的总和，该结构首先以 $O(1)$ 的时间找到对应的物理行索引 $p_i = R[i]$。然后，它需要遍历物理行 $S[p_i]$ 的所有 $m$ 个元素并累加它们的和。\n  - **复杂度分析**：此操作涉及一次 $O(1)$ 查找，然后是一个执行 $m-1$ 次加法的循环。总时间与列数 $m$ 成正比。因此，`sum_row` 操作的时间复杂度为 $O(m)$。\n\n让我们跟踪用例 1 的执行过程来演示其机制。\n- 参数：$n = 3$, $m = 4$ 及 $f(i,j) = 10 \\cdot i + j$。\n- 初始状态：\n  - 物理存储 $S$ 是一个 $3 \\times 4$ 的矩阵，其中 $S_{i,j} = 10 \\cdot i + j$：\n  $$S = \\begin{pmatrix} 0  1  2  3 \\\\ 10  11  12  13 \\\\ 20  21  22  23 \\end{pmatrix}$$\n  - 间接向量 $R$ 初始化为 `$[0, 1, 2]$`。\n- 操作 1：$r_1 = \\text{get}(1,2)$。\n  - 逻辑行为 $i=1$。物理行为 $R[1]=1$。值为 $S[1][2] = 12$。因此，$r_1=12$。\n- 操作 2：执行 `row_swap(0,2)`。\n  - 交换 $R[0]$ 和 $R[2]$。$R$ 原为 `$[0, 1, 2]$`。现在 $R = [2, 1, 0]$。\n- 操作 3：$r_2 = \\text{get}(0,3)$。\n  - 逻辑行为 $i=0$。物理行为 $R[0]=2$。值为 $S[2][3] = 23$。因此，$r_2=23$。\n- 操作 4：执行 `set(2,1,999)`。\n  - 逻辑行为 $i=2$。物理行为 $R[2]=0$。将 $S[0][1]$ 设置为 $999$。$S$ 的第一行变为 `$[0, 999, 2, 3]$`。\n- 操作 5：$r_3 = \\text{get}(2,1)$。\n  - 逻辑行为 $i=2$。物理行为 $R[2]=0$。值为 $S[0][1] = 999$。因此，$r_3=999$。\n- 操作 6：$r_4 = \\text{sum_row}(0)$。\n  - 逻辑行为 $i=0$。物理行为 $R[0]=2$。对 $S$ 中第 $2$ 行的元素求和：$20+21+22+23 = 86$。因此，$r_4=86$。\n- 用例 1 的结果是 $[12, 23, 999, 86]$。其他用例通过应用相同的逻辑来解决。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass IndirectionArray:\n    \"\"\"\n    A 2D array supporting O(1) row swaps via an indirection vector.\n    \"\"\"\n    def __init__(self, n, m, f):\n        \"\"\"\n        Initializes the data structure.\n\n        Args:\n            n (int): The number of rows.\n            m (int): The number of columns.\n            f (callable): A function f(i, j) to populate the initial storage.\n        \"\"\"\n        self.n = n\n        self.m = m\n        \n        # Physical storage for the array data.\n        self.storage = np.zeros((n, m), dtype=np.int64)\n        for i in range(n):\n            for j in range(m):\n                self.storage[i, j] = f(i, j)\n        \n        # Indirection vector mapping logical rows to physical rows.\n        # Initially, it's a direct mapping: logical row i - physical row i.\n        self.row_indices = np.arange(n)\n\n    def get(self, i, j):\n        \"\"\"\n        Returns the value at logical row i and column j in O(1).\n        \"\"\"\n        physical_row = self.row_indices[i]\n        return self.storage[physical_row, j]\n\n    def set(self, i, j, v):\n        \"\"\"\n        Sets the value at logical row i and column j to v in O(1).\n        \"\"\"\n        physical_row = self.row_indices[i]\n        self.storage[physical_row, j] = v\n\n    def row_swap(self, i, k):\n        \"\"\"\n        Swaps logical rows i and k in O(1).\n        \"\"\"\n        self.row_indices[i], self.row_indices[k] = self.row_indices[k], self.row_indices[i]\n\n    def sum_row(self, i):\n        \"\"\"\n        Returns the sum of values in logical row i in O(m).\n        \"\"\"\n        physical_row = self.row_indices[i]\n        return np.sum(self.storage[physical_row, :])\n\n\ndef solve():\n    \"\"\"\n    Executes the deterministic test suite and prints the final result.\n    \"\"\"\n    all_results = []\n\n    # Case 1 (general case)\n    case1_params = {'n': 3, 'm': 4, 'f': lambda i, j: 10 * i + j}\n    arr1 = IndirectionArray(**case1_params)\n    results1 = []\n    results1.append(arr1.get(1, 2))\n    arr1.row_swap(0, 2)\n    results1.append(arr1.get(0, 3))\n    arr1.set(2, 1, 999)\n    results1.append(arr1.get(2, 1))\n    results1.append(arr1.sum_row(0))\n    all_results.append(results1)\n\n    # Case 2 (single row boundary)\n    case2_params = {'n': 1, 'm': 5, 'f': lambda i, j: i + j}\n    arr2 = IndirectionArray(**case2_params)\n    results2 = []\n    results2.append(arr2.get(0, 4))\n    arr2.row_swap(0, 0)\n    results2.append(arr2.get(0, 4))\n    arr2.set(0, 2, 50)\n    results2.append(arr2.get(0, 2))\n    results2.append(arr2.sum_row(0))\n    all_results.append(results2)\n\n    # Case 3 (single column boundary)\n    case3_params = {'n': 4, 'm': 1, 'f': lambda i, j: 100 * i + j}\n    arr3 = IndirectionArray(**case3_params)\n    results3 = []\n    results3.append(arr3.get(3, 0))\n    arr3.row_swap(3, 0)\n    results3.append(arr3.get(3, 0))\n    arr3.set(0, 0, 7)\n    results3.append(arr3.get(0, 0))\n    results3.append(arr3.sum_row(0))\n    all_results.append(results3)\n\n    # Case 4 (composition of multiple swaps)\n    case4_params = {'n': 5, 'm': 3, 'f': lambda i, j: i * 3 + j}\n    arr4 = IndirectionArray(**case4_params)\n    results4 = []\n    results4.append(arr4.get(2, 1))\n    arr4.row_swap(0, 4)\n    arr4.row_swap(1, 3)\n    arr4.row_swap(0, 1)\n    results4.append(arr4.get(2, 1))\n    arr4.set(4, 2, 12345)\n    results4.append(arr4.get(4, 2))\n    results4.append(arr4.sum_row(0))\n    all_results.append(results4)\n\n    # Format the final output string as specified.\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3208065"}, {"introduction": "想象一下，你是一位正在分析内存转储文件的“数据侦探”。这个练习将挑战你的分析能力，它颠覆了常规的思维方式：你不再是根据索引计算地址，而是要根据一系列内存地址反向推导出数组的维度和存储顺序。这个“逆向工程”问题将是你对行主序和列主序存储方式理解程度的终极考验，让你深刻体会理论公式在实际内存布局中的具体表现。[@problem_id:3208033]", "problem": "考虑一个三维数组 $A$，其索引为从零开始的 $(i,j,k)$，在内存中以行主序或列主序连续存储。维度 $(D_1,D_2,D_3)$ 是未知的正整数。元素类型为固定宽度，大小为 $s$ 字节，其中 $s=8$。元素、行、平面或任何更高级别的切片之间没有填充。设 $A(0,0,0)$ 的基地址为 $B$，其中 $B=100000$。\n\n一个探针在保持另外两个索引固定的情况下，一次只改变一个索引，记录了以下内存地址序列：\n\n1. 当 $(j,k)=(0,0)$ 固定，改变 $i$ 时，观察到的 $A(0,0,0)$, $A(1,0,0)$, $A(2,0,0)$ 的地址为 $100000$, $100160$, $100320$。\n2. 当 $(i,k)=(0,0)$ 固定，改变 $j$ 时，观察到的 $A(0,0,0)$, $A(0,1,0)$, $A(0,2,0)$ 的地址为 $100000$, $100032$, $100064$。\n3. 当 $(i,j)=(0,0)$ 固定，改变 $k$ 时，观察到的 $A(0,0,0)$, $A(0,0,1)$, $A(0,0,2)$ 的地址为 $100000$, $100008$, $100016$。\n\n此外，对所有有效的 $(i,j,k)$ 值进行完整扫描后，报告遇到的最后一个元素的地址为 $100472$。\n\n仅使用连续数组布局的基本定义以及行主序和列主序存储顺序的区别，推导出维度 $(D_1,D_2,D_3)$ 并确定存储顺序。然后，计算单个代码值\n$$C = 10^{3} O + 10^{2} D_3 + 10^{1} D_2 + D_1,$$\n其中如果数组是行主序，则 $O=0$；如果是列主序，则 $O=1$。提供 $C$ 作为您的最终答案。无需四舍五入，答案无单位。", "solution": "该问题要求推导一个三维数组 $A$ 的存储顺序（行主序或列主序）和维度 $(D_1, D_2, D_3)$，然后计算一个特定的代码值 $C$。\n\n**步骤1：问题验证**\n\n给定的条件逐字摘录如下：\n- 一个三维数组 $A$，索引从零开始，为 $(i,j,k)$。\n- 维度为 $(D_1, D_2, D_3)$，是未知的正整数。\n- 数组在内存中以行主序或列主序连续存储。\n- 元素大小为 $s=8$ 字节。\n- 没有填充。\n- 基地址为 $B = \\text{Address}(A(0,0,0)) = 100000$。\n- 探针1（当 $(j,k)=(0,0)$ 时改变 $i$）：$A(0,0,0)$, $A(1,0,0)$, $A(2,0,0)$ 的地址为 $100000$, $100160$, $100320$。\n- 探针2（当 $(i,k)=(0,0)$ 时改变 $j$）：$A(0,0,0)$, $A(0,1,0)$, $A(0,2,0)$ 的地址为 $100000$, $100032$, $100064$。\n- 探针3（当 $(i,j)=(0,0)$ 时改变 $k$）：$A(0,0,0)$, $A(0,0,1)$, $A(0,0,2)$ 的地址为 $100000$, $100008$, $100016$。\n- 最后一个元素 $A(D_1-1, D_2-1, D_3-1)$ 的地址是 $100472$。\n- 目标表达式为 $C = 10^{3}O + 10^{2}D_3 + 10^{1}D_2 + D_1$，其中行主序 $O=0$，列主序 $O=1$。\n\n该问题在科学上基于数据结构和内存布局的原理。问题陈述清晰，提供了充分且一致的信息来确定唯一解。语言客观精确。因此，该问题是有效的。\n\n**步骤2：地址计算公式化**\n\n元素 $A(i,j,k)$ 的内存地址是根据其索引、数组维度、元素大小 $s$ 和基地址 $B$ 计算得出的。索引范围为 $0 \\le i \\le D_1 - 1$，$0 \\le j \\le D_2 - 1$ 和 $0 \\le k \\le D_3 - 1$。\n\n在**行主序**中，最后一个索引 $k$ 变化最快。地址公式为：\n$$ \\text{Address}(i,j,k)_{\\text{row}} = B + (i \\cdot D_2 \\cdot D_3 + j \\cdot D_3 + k) \\cdot s $$\n\n在**列主序**中，第一个索引 $i$ 变化最快。地址公式为：\n$$ \\text{Address}(i,j,k)_{\\text{col}} = B + (k \\cdot D_1 \\cdot D_2 + j \\cdot D_1 + i) \\cdot s $$\n\n**步骤3：分析探针数据以确定步长**\n\n特定索引的步长是指在保持其他索引不变的情况下，该索引加一时内存地址的差值。我们可以从提供的探针数据中计算出步长。\n\n- **索引 $i$ 的步长 ($S_i$)：**\n这是 $A(i+1,j,k)$ 和 $A(i,j,k)$ 之间的地址差。\n根据第一个探针数据，我们有：\n$S_i = \\text{Address}(A(1,0,0)) - \\text{Address}(A(0,0,0)) = 100160 - 100000 = 160$ 字节。\n差值是一致的：$\\text{Address}(A(2,0,0)) - \\text{Address}(A(1,0,0)) = 100320 - 100160 = 160$。\n\n- **索引 $j$ 的步长 ($S_j$)：**\n这是 $A(i,j+1,k)$ 和 $A(i,j,k)$ 之间的地址差。\n根据第二个探针数据：\n$S_j = \\text{Address}(A(0,1,0)) - \\text{Address}(A(0,0,0)) = 100032 - 100000 = 32$ 字节。\n差值是一致的：$\\text{Address}(A(0,2,0)) - \\text{Address}(A(0,1,0)) = 100064 - 100032 = 32$。\n\n- **索引 $k$ 的步长 ($S_k$)：**\n这是 $A(i,j,k+1)$ 和 $A(i,j,k)$ 之间的地址差。\n根据第三个探针数据：\n$S_k = \\text{Address}(A(0,0,1)) - \\text{Address}(A(0,0,0)) = 100008 - 100000 = 8$ 字节。\n差值是一致的：$\\text{Address}(A(0,0,2)) - \\text{Address}(A(0,0,1)) = 100016 - 100008 = 8$。\n\n我们得到了经验步长：$S_i = 160$，$S_j = 32$ 和 $S_k = 8$。给定的元素大小为 $s=8$。\n\n**步骤4：推导存储顺序和维度**\n\n现在我们将经验步长与从地址公式推导出的理论步长进行比较。\n\n对于**行主序**：\n- $S_i = (\\text{Address}(i+1,j,k) - \\text{Address}(i,j,k)) = ((i+1)D_2 D_3 - i D_2 D_3)s = D_2 D_3 s$\n- $S_j = (\\text{Address}(i,j+1,k) - \\text{Address}(i,j,k)) = ((j+1)D_3 - j D_3)s = D_3 s$\n- $S_k = (\\text{Address}(i,j,k+1) - \\text{Address}(i,j,k)) = ((k+1) - k)s = s$\n\n对于**列主序**：\n- $S_i = (\\text{Address}(i+1,j,k) - \\text{Address}(i,j,k)) = ((i+1) - i)s = s$\n- $S_j = (\\text{Address}(i,j+1,k) - \\text{Address}(i,j,k)) = ((j+1)D_1 - j D_1)s = D_1 s$\n- $S_k = (\\text{Address}(i,j,k+1) - \\text{Address}(i,j,k)) = ((k+1)D_1 D_2 - k D_1 D_2)s = D_1 D_2 s$\n\n让我们测试这两种可能性：\n\n- **假设1：数组为行主序。**\n  - $S_k = s$。数据显示 $S_k = 8$ 且 $s=8$。这是一致的。\n  - $S_j = D_3 s \\implies 32 = D_3 \\cdot 8 \\implies D_3 = 4$。\n  - $S_i = D_2 D_3 s \\implies 160 = D_2 \\cdot 4 \\cdot 8 \\implies 160 = 32 \\cdot D_2 \\implies D_2 = 5$。\n  这个假设与步长数据完全一致。我们已经找到了 $D_2=5$ 和 $D_3=4$。\n\n- **假设2：数组为列主序。**\n  - $S_i = s$。数据显示 $S_i = 160$ 且 $s=8$。由于 $160 \\neq 8$，这是一个矛盾。\n  因此，列主序的假设是错误的。\n\n存储方案必须是**行主序**。这意味着最终计算的参数 $O$ 为 $O=0$。我们还确定了其中两个维度：$D_2 = 5$ 和 $D_3 = 4$。\n\n**步骤5：确定维度 $D_1$**\n\n最后一条信息是数组中最后一个元素 $A(D_1-1, D_2-1, D_3-1)$ 的地址，其地址为 $100472$。\n使用行主序地址公式：\n$$ \\text{Address}(D_1-1, D_2-1, D_3-1) = B + ((D_1-1)D_2 D_3 + (D_2-1)D_3 + (D_3-1))s $$\n这个表达式可以简化。数组中的元素总数为 $N = D_1 D_2 D_3$。在一个从零开始的、连续的一维表示中，最后一个元素的索引是 $N-1$。\n最后一个元素的地址就是 $B + (N-1)s$。\n$$ \\text{Address}(D_1-1, D_2-1, D_3-1) = B + (D_1 D_2 D_3 - 1)s $$\n代入已知值：\n$$ 100472 = 100000 + (D_1 \\cdot 5 \\cdot 4 - 1) \\cdot 8 $$\n$$ 100472 - 100000 = (20 D_1 - 1) \\cdot 8 $$\n$$ 472 = (20 D_1 - 1) \\cdot 8 $$\n两边同时除以 $8$：\n$$ \\frac{472}{8} = 20 D_1 - 1 $$\n$$ 59 = 20 D_1 - 1 $$\n$$ 60 = 20 D_1 $$\n$$ D_1 = \\frac{60}{20} = 3 $$\n所以，第一个维度是 $D_1=3$。维度为 $(D_1, D_2, D_3) = (3, 5, 4)$。所有维度都是正整数，符合要求。\n\n**步骤6：计算最终代码值 $C$**\n\n问题要求计算 $C = 10^{3}O + 10^{2}D_3 + 10^{1}D_2 + D_1$ 的值。\n我们已经确定：\n- 存储顺序是行主序，所以 $O=0$。\n- $D_1 = 3$。\n- $D_2 = 5$。\n- $D_3 = 4$。\n\n将这些值代入 $C$ 的表达式中：\n$$ C = 10^3 \\cdot 0 + 10^2 \\cdot 4 + 10^1 \\cdot 5 + 3 $$\n$$ C = 0 + 100 \\cdot 4 + 10 \\cdot 5 + 3 $$\n$$ C = 400 + 50 + 3 $$\n$$ C = 453 $$\n最终代码值为 $453$。", "answer": "$$\\boxed{453}$$", "id": "3208033"}]}