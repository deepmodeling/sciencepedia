{"hands_on_practices": [{"introduction": "动态数组通过自动调整大小来适应不断增长的数据，但这个过程涉及复制元素的开销。这项练习旨在量化这一核心机制的成本([@problem_id:3206830])。通过计算在 $N$ 次追加操作后单个元素被复制的最大次数，你将揭示加倍策略背后的对数增长规律，并深入理解其摊销效率的来源。", "problem": "考虑一个动态数组，其初始容量为 $1$ 且为空。该数组支持追加操作，当有可用容量时，该操作以常数时间在末尾放置一个新元素。当追加操作发现数组已满时，数组会执行一次“调整大小”（resize）：它会分配一个新的连续内存块，其容量恰好是当前容量的两倍，然后按顺序将所有当前元素从旧块复制到新块，之后再追加新元素。假设不发生删除操作。定义元素的“复制”为该元素在调整大小过程中的移动（元素在追加时的初始放置不计为复制）。\n\n在执行了恰好 $N \\ge 1$ 次追加操作后，请确定在此 $N$ 次追加序列中，任何单个元素因调整大小而被复制的最大可能次数，并以 $N$ 的封闭形式表达式给出。请提供精确表达式作为答案；不需要数值近似或四舍五入。", "solution": "用户希望我解决一个关于动态数组的问题。\n\n### 第 1 步：提取已知条件\n- 初始数组容量：$1$。\n- 初始数组大小：$0$。\n- 追加操作：在末尾放置一个新元素。\n- 调整大小的条件：当试图向一个已满的数组追加元素时发生。\n- 调整大小的机制：\n    1. 分配新容量为当前容量的 $2 \\times$。\n    2. 所有现有元素被复制到新块中。\n    3. 然后追加新元素。\n- “复制”的定义：元素在调整大小过程中的移动。元素的初始插入不属于复制。\n- 总操作数：执行了恰好 $N$ 次追加，其中 $N \\ge 1$。\n- 目标：确定任何单个元素被复制的最大可能次数。\n\n### 第 2 步：使用提取的已知条件进行验证\n- **科学依据**：该问题是算法分析中的一个标准练习，具体涉及动态数组（也称为向量或 ArrayList）的摊还分析。所描述的模型（调整大小时容量加倍）是一种经典的实现策略。该问题在科学和数学上是合理的。\n- **适定性**：该问题是适定的。初始条件、操作规则以及待求量都已精确指定。存在唯一的、确定性的解。\n- **客观性**：问题陈述是客观的，并使用了正式、无歧义的语言。\n\n### 第 3 步：结论与行动\n该问题是有效的。它是计算机科学领域中关于数据结构和算法的一个定义明确的问题。我现在将进行正式求解。\n\n### 解题推导\n问题要求在 $N$ 次追加操作序列后，任何单个元素被复制的最大次数。为了最大化一个元素的复制次数，我们应该考虑在数组中存在时间最长的元素，因为它将经历其插入后发生的每一次调整大小操作。第一个被追加的元素，我们称之为 $E_1$，满足这个条件。因此，任何元素的最大复制次数就是 $E_1$ 被复制的次数。\n\n我们来分析动态数组的状态，特别是其容量。容量（我们用 $C$ 表示）仅在调整大小操作期间发生变化。根据问题陈述，初始容量为 $C_0 = 1$。调整大小操作会使容量加倍。因此，数组可能具有的容量序列是 $2$ 的幂：$1, 2, 4, 8, \\dots, 2^k$，其中 $k$ 为非负整数。容量为 $C=2^k$ 的数组最多可以容纳 $2^k$ 个元素。\n\n当试图向一个已满的数组追加元素时，会触发调整大小。也就是说，如果数组的容量为 $C$ 并且已经包含 $C$ 个元素，下一次追加操作将导致调整大小。\n\n我们来追踪一下这个过程：\n1.  **初始状态**：容量 $C=1$，大小 $S=0$。\n2.  **第 1 次追加**：我们追加元素 $E_1$。数组有空间，不发生调整大小。状态变为 $C=1, S=1$。$E_1$ 的复制次数为 $0$。\n3.  **第 2 次追加**：我们尝试追加 $E_2$。数组已满（$S=C=1$）。触发调整大小。\n    - 分配一个容量为 $2 \\times 1 = 2$ 的新数组。\n    - 元素 $E_1$ 从旧数组复制到新数组。这是 $E_1$ 的**第一次复制**。\n    - 追加元素 $E_2$。\n    - 状态变为 $C=2, S=2$。\n4.  **第 3 次追加**：我们尝试追加 $E_3$。数组已满（$S=C=2$）。触发调整大小。\n    - 分配一个容量为 $2 \\times 2 = 4$ 的新数组。\n    - 元素 $E_1$ 和 $E_2$ 被复制。这是 $E_1$ 的**第二次复制**。\n    - 追加元素 $E_3$。\n    - 状态变为 $C=4, S=3$。\n5.  **第 4 次追加**：我们追加 $E_4$。数组未满（$S=3, C=4$）。不调整大小。状态变为 $C=4, S=4$。$E_1$ 仍然被复制了两次。\n6.  **第 5 次追加**：我们尝试追加 $E_5$。数组已满（$S=C=4$）。触发调整大小，容量变为 $2 \\times 4 = 8$。这涉及到 $E_1$ 的**第三次复制**。\n\n从这个分析中可以清楚地看出，$E_1$ 在其初始放置后发生的每一次调整大小事件中都会被复制。因此，$E_1$ 被复制的次数等于在 $N$ 次追加过程中发生调整大小的总次数。\n\n从容量 $2^k$ 到 $2^{k+1}$ 的调整大小是由第 $(2^k+1)$ 次追加操作触发的。元素 $E_1$ 存在于所有从初始值 $2^0$ 增加容量的调整大小操作中。\n\n经过 $N$ 次追加后，数组必须容纳 $N$ 个元素。数组的容量 $C_N$ 必须至少为 $N$。由于容量是 2 的幂，所以 $C_N$ 必须是大于或等于 $N$ 的最小的 2 的幂。设此容量为 $C_N = 2^k$。\n条件 $C_N = 2^k \\ge N$ 中 $k$ 是满足该条件的最小整数，这意味着之前的容量 $2^{k-1}$ 是不足的，即 $2^{k-1}  N$。\n所以，我们得到不等式：\n$$2^{k-1}  N \\le 2^k$$\n这个不等式对 $N > 1$ 成立。如果 $N=1$，容量为 $1=2^0$，所以 $k=0$。\n对于 $N > 1$，我们可以对不等式两边取以 2 为底的对数：\n$$\\log_2(2^{k-1})  \\log_2(N) \\le \\log_2(2^k)$$\n$$k-1  \\log_2(N) \\le k$$\n这个关系是向上取整函数（ceiling function）的定义。因此，对于 $N > 1$，最终容量的指数 $k$ 由下式给出：\n$$k = \\lceil \\log_2(N) \\rceil$$\n我们来验证 $N=1$ 的情况。最终容量是 $1 = 2^0$，所以 $k=0$。公式给出 $\\lceil \\log_2(1) \\rceil = \\lceil 0 \\rceil = 0$。所以该公式对所有 $N \\ge 1$ 都成立。\n\n数组为了达到 $2^k$ 的容量所必须经历的容量序列是 $2^0, 2^1, 2^2, \\ldots, 2^k$。\n这个序列中从 $2^j$ 到 $2^{j+1}$（其中 $j=0, 1, \\ldots, k-1$）的每一步都对应一次调整大小的操作。\n第一个元素 $E_1$ 从容量为 $C=2^0$ 时就存在于数组中。在随后的每一次调整大小中，它都会被复制。\n调整大小的操作如下：\n- 从 $2^0 \\to 2^1$\n- 从 $2^1 \\to 2^2$\n- ...\n- 从 $2^{k-1} \\to 2^k$\n\n这些调整大小事件的总数是 $(k-1) - 0 + 1 = k$。\n因此，任何单个元素被复制的最大次数是 $k$。代入 $k$ 的表达式：\n$$\\text{最大复制次数} = \\lceil \\log_2(N) \\rceil$$\n这个表达式是关于 $N$ 的一个封闭形式，并且对所有 $N \\ge 1$ 都有效。", "answer": "$$\\boxed{\\lceil \\log_2(N) \\rceil}$$", "id": "3206830"}, {"introduction": "尽管动态数组的尾部追加（`push_back`）操作非常高效，但并非所有操作都如此。本练习聚焦于一个常见性能瓶颈：从数组前端移除元素（`pop_front`）([@problem_id:3230221])。你将首先实现并分析一个朴素的线性时间复杂度方案，然后通过设计一个精巧的环形缓冲区，将 `pop_front` 和 `push_back` 的摊销时间复杂度均优化至 $\\mathcal{O}(1)$，从而体验数据结构设计中为提升性能而进行的巧妙权衡。", "problem": "你的任务是从第一性原理出发，对动态数组和摊还分析进行推理，并通过实现两种具体的、基于数组的结构来验证你的推理。仅使用以下基础原则：在随机存取存储器（RAM）中，数组索引是常数时间操作；复制或赋值单个元素的成本为单位成本；复制 $k$ 个元素的成本与 $k$ 成正比；除了显式赋值外，创建新数组和复制现有元素是数据移动的唯一来源；通过加倍方式增长时，动态数组的容量始终是 $2$ 的幂。\n\n你的任务是：\n\n- 实现一个标准的动态数组，在数组满时通过加倍容量的方式，以支持摊还常数时间的 $push\\_back$ 操作。通过将所有剩余元素向左移动一个位置来实现 $pop\\_front$。纯粹通过计算 $pop\\_front$ 操作内部执行的元素赋值次数来分析其时间成本。在回答有关 $pop\\_front$ 的问题时，忽略因 $push\\_back$ 引起的任何重新分配成本。\n\n- 设计并实现一个基于数组的队列，使其 $push\\_back$ 和 $pop\\_front$ 操作均达到摊还 $\\mathcal{O}(1)$ 的时间复杂度。在一个动态数组上使用循环缓冲区（环形），当溢出时容量加倍，当操作后大小不大于容量的四分之一时容量减半。在调整大小（无论是增长还是缩小）时，将所有元素按逻辑顺序复制到一个从索引 $0$ 开始的新数组中。每次操作最多执行一次大小调整。计算在调整大小期间（且仅在此期间）完成的元素复制数量，以量化成本。\n\n根据上述基础原则和你的实现，推导出为什么朴素的 $pop\\_front$ 的成本与当前大小呈线性关系，以及为什么在指定的加倍/减半策略下，环形缓冲区能使 $push\\_back$ 和 $pop\\_front$ 操作都达到摊还常数时间。\n\n测试套件和要求输出：\n\n实现你的程序来执行以下四个测试用例，使用精确的操作序列。对于朴素动态数组，仅计算因移位而在 $pop\\_front$ 内部执行的元素赋值次数。对于环形缓冲区，仅计算在调整大小期间执行的元素复制次数。对于在空结构上执行的任何 $pop\\_front$ 操作，不执行任何操作并在内部返回一个特殊值（例如 null）；这样的空操作不应影响计数器。\n\n- 测试用例 1 (朴素动态数组的移位成本):\n  - 从空数组开始。\n  - 按递增顺序执行 $push\\_back$ 操作，压入整数 $1$ 到 $10$。\n  - 执行 $pop\\_front$ 操作恰好 $3$ 次。\n  - 按递增顺序执行 $push\\_back$ 操作，压入整数 $11$ 到 $15$。\n  - 执行 $pop\\_front$ 操作恰好 $4$ 次。\n  - 按递增顺序执行 $push\\_back$ 操作，压入整数 $16$ 到 $20$。\n  - 此用例的输出：一个整数，等于所有 $pop\\_front$ 操作执行的元素赋值总数（忽略由 $push\\_back$ 引起的任何重新分配）。\n\n- 测试用例 2 (混合操作下环形缓冲区的大小调整复制计数):\n  - 从空缓冲区开始。\n  - 执行 $push\\_back$ 操作，压入 $1$ 到 $10$。\n  - 执行 $pop\\_front$ 操作 $3$ 次。\n  - 执行 $push\\_back$ 操作，压入 $11$ 到 $15$。\n  - 执行 $pop\\_front$ 操作 $4$ 次。\n  - 执行 $push\\_back$ 操作，压入 $16$ 到 $20$。\n  - 此用例的输出：一个整数，等于所有大小调整（包括增长和收缩）期间执行的元素复制总数。\n\n- 测试用例 3 (环形缓冲区的正确性和环绕行为):\n  - 从空缓冲区开始。\n  - 执行 $push\\_back$ 操作，压入 $1$ 到 $6$。\n  - 执行 $pop\\_front$ 操作 $4$ 次。\n  - 执行 $push\\_back$ 操作，压入 $7$、$8$、$9$、$10$。\n  - 执行 $pop\\_front$ 操作 $2$ 次。\n  - 此用例的输出：环形缓冲区的最终内容，以从头到尾的逻辑顺序的整数列表形式表示。\n\n- 测试用例 4 (环形缓冲区的增长和收缩复制计数):\n  - 从空缓冲区开始。\n  - 执行 $push\\_back$ 操作，压入 $1$ 到 $16$。\n  - 执行 $pop\\_front$ 操作 $12$ 次。\n  - 执行 $push\\_back$ 操作，压入 $17$ 到 $24$。\n  - 执行 $pop\\_front$ 操作 $8$ 次。\n  - 此用例的输出：一个整数，等于所有大小调整（包括增长和收缩）期间执行的元素复制总数。\n\n最终输出格式：\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按顺序包含四个测试用例的结果：$[$result\\_1,result\\_2,result\\_3,result\\_4$]$。第一个、第二个和第四个结果是整数。第三个结果是一个整数列表。例如，一个语法上有效的输出看起来像 $[42,7,[3,5,8],19]$，其中的具体数字必须与上述测试套件的正确结果相匹配。", "solution": "该问题要求对两种基于数组的数据结构进行分析和实现，以比较它们在类队列操作（特别是 `push_back` 和 `pop_front`）上的性能。分析必须从第一性原理出发，并基于一个指定的成本模型，其中元素赋值和复制是工作量的主要度量标准。\n\n**基础原则和成本模型**\n\n分析基于以下公理：\n1.  随机存取存储器（RAM）允许以常数时间 $\\mathcal{O}(1)$ 通过索引访问任何数组元素。\n2.  单个元素赋值或复制的成本是单位成本，我们可以表示为 $\\mathcal{O}(1)$。\n3.  复制 $k$ 个连续元素块的成本是 $\\mathcal{O}(k)$。\n4.  数据移动仅限于显式赋值或数组调整大小期间的块复制。\n5.  动态数组在增长时，其容量始终是当前容量加倍后得到的 $2$ 的幂。\n\n**第1部分：带有移位 `pop_front` 的朴素动态数组**\n\n标准动态数组通过在末尾附加一个元素来支持 `push_back`。如果底层数组已满，则会分配一个更大的新数组（在本例中为双倍容量），将所有现有元素复制到其中，并丢弃旧数组。这种加倍策略确保了 `push_back` 的摊还成本为 $\\mathcal{O}(1)$。\n\n问题为 `pop_front` 指定了一个朴素的实现。此操作必须移除索引为 $0$ 的元素。为了保持数组的连续性，并使其第一个逻辑元素位于索引 $0$，所有后续元素都必须向左移动一个位置。\n\n**朴素 `pop_front` 的成本分析**\n设动态数组包含 $N$ 个元素，索引从 $0$ 到 $N-1$。\n1.  位于索引 $0$ 的元素被移除。\n2.  位于索引 $1$ 的元素被复制到索引 $0$。\n3.  位于索引 $2$ 的元素被复制到索引 $1$。\n4.  此过程一直持续到位于索引 $N-1$ 的最后一个元素被复制到索引 $N-2$。\n\n这个序列涉及 $N-1$ 次独立的元素赋值操作。根据规定的成本模型，每次赋值的成本为单位成本，因此单次 `pop_front` 操作的总成本与 $N-1$ 成正比。因此，朴素 `pop_front` 的时间复杂度为 $\\mathcal{O}(N)$，其中 $N$ 是数组中当前的元素数量。每次调用 `pop_front` 都会产生这个成本，因此没有摊还的机会；最坏情况和平均情况的成本都与数组的大小成线性关系。\n\n**第2部分：带有循环缓冲区（环形缓冲区）的基于数组的队列**\n\n为了同时实现高效的 `push_back` 和 `pop_front` 操作，我们采用了一种循环缓冲区（或环形缓冲区）。这种结构在动态数组上实现，但将数组的内存视为一个环。使用两个指针 `head` 和 `tail`（或等效的表示方式，如 `head` 和 `size`）来标记队列的逻辑起点和终点。\n\n-   `push_back`：在 `tail` 位置添加一个元素并前移 `tail`。\n-   `pop_front`：从 `head` 位置移除一个元素并前移 `head`。\n\n当指针越过数组末端时，它们都会环绕到数组的开头，通常使用模运算符：`new_index = (old_index + 1) % capacity`。在不进行大小调整的情况下，`push_back` 和 `pop_front` 都只需要更新一个指针和进行一次元素读/写。这些都是 $\\mathcal{O}(1)$ 操作。\n\n**环形缓冲区大小调整的摊还分析**\n此结构的成本主要由其大小调整操作决定。指定的策略是：\n-   **增长**：如果在执行 `push_back` 时 `size == capacity`，则将容量加倍（$C \\to 2C$）。\n-   **收缩**：如果操作后 `size = capacity / 4`，则将容量减半（$C \\to C/2$）。\n\n当调整大小时，所有 $N$ 个元素都会从（可能已环绕的）旧数组中复制到一个从索引 $0$ 开始的新的连续数组中。这个过程“展开”了队列，成本为 $\\mathcal{O}(N)$。我们可以使用势能函数分析来证明这两个操作的摊还成本都是 $\\mathcal{O}(1)$。\n\n设 $N$ 为元素数量， $C$ 为容量。我们定义一个势能函数 $\\Phi$，它存储“信用”以支付未来昂贵的大小调整操作。一个适用于此方案的势能函数是：\n$$ \\Phi = \\begin{cases} 2N - C  \\text{if } N/C \\ge 1/2 \\\\ C/2 - N  \\text{if } N/C  1/2 \\end{cases} $$\n一次操作的摊还成本 $\\hat{c}$ 是其真实成本 $c$ 加上势能的变化 $\\Delta\\Phi$。\n\n1.  **`push_back` 导致增长**：假设我们有 $N=C$ 个元素并执行一次 `push_back`。真实成本 $c$ 是 $1$（用于元素写入）$+ C$（用于将 $C$ 个元素复制到新数组）。总成本为 $c = C+1$。容量从 $C$ 变为 $C' = 2C$，大小变为 $N' = C+1$。\n    -   旧势能（当 $N=C$，因此 $N/C=1 \\ge 1/2$）：$\\Phi_{old} = 2N - C = 2C - C = C$。\n    -   新势能（当 $N' = C+1, C'=2C$，因此 $N'/C' \\approx 1/2$）：$\\Phi_{new} = 2N' - C' = 2(C+1) - 2C = 2$。\n    -   $\\Delta\\Phi = \\Phi_{new} - \\Phi_{old} = 2 - C$。\n    -   摊还成本：$\\hat{c} = c + \\Delta\\Phi = (C+1) + (2-C) = 3$。这是 $\\mathcal{O}(1)$。\n\n2.  **`pop_front` 导致收缩**：假设一次 `pop_front` 将大小减小到 $N = C/4$。真实成本 $c$ 是 $1$（用于弹出逻辑）$+ N$（用于复制 $N$ 个元素）。总成本为 $c = C/4+1$。容量从 $C$ 变为 $C' = C/2$，大小保持为 $N' = N = C/4$。\n    -   收缩前的状态是在容量为 $C$ 的数组中有 $N_{pre} = C/4+1$ 个元素。由于 $N_{pre}/C  1/2$，势能为 $\\Phi_{old} = C/2 - N_{pre} = C/2 - (C/4+1) = C/4 - 1$。\n    -   新势能（当 $N' = C/4, C' = C/2$，因此 $N'/C' = 1/2$）：$\\Phi_{new} = 2N' - C' = 2(C/4) - C/2 = 0$。\n    -   $\\Delta\\Phi = \\Phi_{new} - \\Phi_{old} = 0 - (C/4-1) = 1-C/4$。\n    -   摊还成本：$\\hat{c} = c + \\Delta\\Phi = (C/4+1) + (1-C/4) = 2$。这是 $\\mathcal{O}(1)$。\n\n在所有情况下（包括可以类似分析的非调整大小的情况），摊还成本都受限于一个小的常数。大小调整策略确保了在一次调整之后，必须执行与新容量成比例数量的操作，才会需要下一次调整。这个间隔允许积累足够的“信用”（势能）来支付下一次线性成本的大小调整，从而使每次单一操作的摊还成本都为 $\\mathcal{O}(1)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Executes the four test cases defined in the problem statement\n    and prints the results in the specified format.\n    \"\"\"\n\n    # --- Test Case 1: Naive Dynamic Array Shift Cost ---\n    \n    class NaiveDynamicArray:\n        def __init__(self):\n            self.size = 0\n            self.capacity = 0\n            self.data = np.empty(self.capacity, dtype=object)\n            self.pop_front_cost = 0\n\n        def _resize(self, new_capacity):\n            new_data = np.empty(new_capacity, dtype=object)\n            if self.size > 0:\n                new_data[0:self.size] = self.data[0:self.size]\n            self.data = new_data\n            self.capacity = new_capacity\n\n        def push_back(self, value):\n            if self.size == self.capacity:\n                new_cap = 1 if self.capacity == 0 else self.capacity * 2\n                self._resize(new_cap)\n            self.data[self.size] = value\n            self.size += 1\n\n        def pop_front(self):\n            if self.size == 0:\n                return None\n            \n            value = self.data[0]\n            # Cost is the number of element assignments for the shift.\n            shift_cost = self.size - 1\n            self.pop_front_cost += shift_cost\n            \n            # Shift all elements to the left.\n            if shift_cost > 0:\n                self.data[0:shift_cost] = self.data[1:self.size]\n            \n            self.size -= 1\n            return value\n\n    nda = NaiveDynamicArray()\n    for i in range(1, 11): nda.push_back(i)\n    for _ in range(3): nda.pop_front()\n    for i in range(11, 16): nda.push_back(i)\n    for _ in range(4): nda.pop_front()\n    for i in range(16, 21): nda.push_back(i)\n    result_1 = nda.pop_front_cost\n\n    # --- Test Cases 2, 3, 4: Ring Buffer ---\n    \n    class RingBuffer:\n        def __init__(self):\n            self.size = 0\n            self.capacity = 0\n            self.head = 0\n            self.data = np.empty(self.capacity, dtype=object)\n            self.resize_cost = 0\n\n        def _resize(self, new_capacity):\n            # Cost is the number of elements copied.\n            self.resize_cost += self.size\n            \n            new_data = np.empty(new_capacity, dtype=object)\n            # Unwraps the circular buffer into a linear array.\n            for i in range(self.size):\n                old_idx = (self.head + i) % self.capacity\n                new_data[i] = self.data[old_idx]\n            \n            self.data = new_data\n            self.capacity = new_capacity\n            self.head = 0\n\n        def push_back(self, value):\n            if self.size == self.capacity:\n                new_cap = 1 if self.capacity == 0 else self.capacity * 2\n                self._resize(new_cap)\n            \n            tail_idx = (self.head + self.size) % self.capacity\n            self.data[tail_idx] = value\n            self.size += 1\n            # Per problem spec, shrink check is done after an operation.\n            # A push_back will never cause size = capacity / 4 if the\n            # invariant held before, so no shrink check needed here.\n            \n        def pop_front(self):\n            if self.size == 0:\n                return None\n            \n            value = self.data[self.head]\n            self.head = (self.head + 1) % self.capacity\n            self.size -= 1\n            \n            # Shrink condition: size is at most one quarter of capacity.\n            # Must also ensure capacity > 0 to avoid division by zero.\n            if self.capacity > 0 and self.size = self.capacity // 4:\n                # Halve capacity, minimum capacity is 1 if not empty.\n                new_cap = max(1, self.capacity // 2)\n                if new_cap  self.capacity:\n                    self._resize(new_cap)\n\n            return value\n\n        def get_contents(self):\n            contents = []\n            for i in range(self.size):\n                idx = (self.head + i) % self.capacity\n                contents.append(self.data[idx])\n            return contents\n\n    # Test Case 2\n    rb2 = RingBuffer()\n    for i in range(1, 11): rb2.push_back(i)\n    for _ in range(3): rb2.pop_front()\n    for i in range(11, 16): rb2.push_back(i)\n    for _ in range(4): rb2.pop_front()\n    for i in range(16, 21): rb2.push_back(i)\n    result_2 = rb2.resize_cost\n\n    # Test Case 3\n    rb3 = RingBuffer()\n    for i in range(1, 7): rb3.push_back(i)\n    for _ in range(4): rb3.pop_front()\n    for i in range(7, 11): rb3.push_back(i)\n    for _ in range(2): rb3.pop_front()\n    result_3 = rb3.get_contents()\n\n    # Test Case 4\n    rb4 = RingBuffer()\n    for i in range(1, 17): rb4.push_back(i)\n    for _ in range(12): rb4.pop_front()\n    for i in range(17, 25): rb4.push_back(i)\n    for _ in range(8): rb4.pop_front()\n    result_4 = rb4.resize_cost\n    \n    # Final output formatting\n    # The f-string conversion of a list automatically includes spaces, e.g., '[7, 8]'.\n    # We must remove them to match a strict list representation like '[7,8,9,10]'.\n    result_3_str = str(result_3).replace(\" \", \"\")\n\n    print(f\"[{result_1},{result_2},{result_3_str},{result_4}]\")\n\n\nsolve()\n```", "id": "3230221"}, {"introduction": "动态数组不仅是简单的数据容器，更是实现高级算法的基石。本练习将引导你利用动态数组实现经典的快速选择（Quickselect）算法，以线性期望时间找到第 $k$ 小的元素([@problem_id:3230152])。通过亲手实现这一过程，你将深刻理解动态数组的随机存取特性如何支持高效的“原地”（in-place）操作，并体会它在算法设计中的核心作用。", "problem": "您需要设计、分析并实现一个算法，该算法在给定一个未排序的动态数组和一个索引 $k$ 时，返回第 $k$ 小的元素。该方法在数组长度上应具有线性的期望运行时间。动态数组必须使用倍增扩容策略在连续存储上显式实现，并且您的选择算法必须直接在此结构上操作，不使用任何内置的排序或选择例程。\n\n使用的基本定义：\n- 动态数组是一个存储在连续内存块中的元素序列，其逻辑长度 $n$（元素数量）可以小于或等于一个独立的容量 $C$，$C$ 表示当前预留空间的元素数量。当 $n = C$ 并且要追加一个新元素时，动态数组会分配一个大小为 $2C$ 的新块并复制这 $n$ 个元素，之后 $C$ 更新为 $2C$，然后继续执行追加操作。\n- 在倍增扩容规则下，根据随机存取机（RAM）模型衡量，追加操作的均摊时间复杂度为常数时间 $O(1)$。\n- 基于分区的选择算法会围绕一个主元（pivot）重复地对数组进行分区，并对包含目标次序的一侧进行递归（或迭代）。如果主元是从当前子数组中均匀随机选择的，则找到第 $k$ 小元素的期望运行时间与 $n$ 成线性关系。\n\n您的任务：\n1. 从上述定义出发，推导出一个正确的算法策略，该策略均匀随机地选择一个主元，并对动态数组进行原地分区，使得只有一个子数组需要进一步处理。解释为什么期望运行时间与元素数量 $n$ 成线性关系，并解释为什么使用倍增扩容的动态数组在构建数组时能保持追加操作的均摊常数时间。\n2. 从基本原理开始，实现一个 `DynamicArray` 数据结构，该结构在倍增扩容策略下至少支持追加、按索引读取、按索引写入和获取长度等操作。索引应从零开始，但选择查询使用 $k$ 作为从一开始的顺序统计量（即 $k=1$ 表示最小值）。\n3. 实现一个随机化的原地选择算法，对于有效的 $k \\in \\{1,\\dots,n\\}$，返回第 $k$ 小的元素。您的实现不得使用任何内置的排序或选择工具。\n4. 使用您实现的 `DynamicArray` 逐个追加元素来为以下测试套件构建数组，然后对每对 $(A_i,k_i)$ 运行选择算法。\n\n测试套件：\n- 情况 $1$：$A_1 = [\\,7,2,9,4,1,5\\,]$，$k_1 = 3$。\n- 情况 $2$：$A_2 = [\\,-5,-1,-3,-2\\,]$，$k_2 = 1$。\n- 情况 $3$：$A_3 = [\\,3,3,3,3\\,]$，$k_3 = 4$。\n- 情况 $4$：$A_4 = [\\,5,1,5,2,5,3,5\\,]$，$k_4 = 5$。\n- 情况 $5$：$A_5 = [\\,9,8,7,6,5,4,3,2,1\\,]$，$k_5 = 9$。\n- 情况 $6$：$A_6$ 是降序序列 $[\\,1000,999,\\dots,2,1\\,]$，$k_6 = 500$。\n- 情况 $7$：$A_7 = [\\,0,-10,10,0,-10,10\\,]$，$k_7 = 4$。\n\n所有 $k_i$ 值都保证有效，即 $1 \\le k_i \\le |A_i|$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含情况 1 到 7 的结果，以逗号分隔并用方括号括起来，顺序排列，例如 $[\\,r_1,r_2,\\dots,r_7\\,]$，其中每个 $r_i$ 是为情况 $i$ 返回的第 $k_i$ 小的元素。\n- 此任务不涉及物理单位、角度或百分比。\n\n约束和注意事项：\n- 当主元在每个分区步骤中均匀随机选择时，每次选择查询的算法必须以期望线性时间 $O(n)$ 运行。\n- 程序必须是完全自包含的，除了指定的单行输出外，不得读取输入或写入任何其他内容。\n- 您必须使用您实现的动态数组来存储和处理数据，通过 $|A_i|$ 次追加操作序列来构建每个 $A_i$。", "solution": "该问题要求设计、分析并实现一个随机选择算法，以在动态数组中找到第 $k$ 小的元素。解决方案分为两部分：首先是对数据结构和算法的理论推导与分析，其次是具体的实现。\n\n**1. 算法与数据结构分析**\n\n**1.1. 采用倍增扩容策略的动态数组**\n\n动态数组必须能够容纳可变数量的元素 $n$，同时存储在一个容量为 $C$ 的固定大小连续内存块中，其中 $n \\le C$。当追加元素且数组已满（$n=C$）时，采用倍增扩容策略。系统会分配一个容量为 $2C$ 的新内存块，将现有的 $n$ 个元素复制到新块中，并释放旧块。然后，容量更新为 $C \\leftarrow 2C$，并继续执行追加操作。\n\n我们使用聚合分析法来分析 `append` 操作的均摊成本。考虑在一个初始容量为 $C_0=1$ 的空动态数组上执行 $N$ 次追加操作。对于 $i \\in \\{1, \\dots, N\\}$，第 $i$ 次追加操作的成本 $c_i$ 通常是 1 个单位（用于写入本身），如果触发了扩容，则还需加上复制成本。当追加第 $(2^j+1)$ 个元素时（$j \\ge 0$）会发生扩容。此时，元素数量为 $n = 2^j$，容量为 $C = 2^j$。这次追加操作的成本是 $c_{2^j+1} = 1 + 2^j$（1 用于写入， $2^j$ 用于复制现有元素）。所有其他追加操作的成本均为 1。\n\n$N$ 次追加的总成本 $T(N)$ 是所有非扩容追加操作和所有扩容追加操作的成本之和。\n设 $N$ 为元素总数。非扩容追加操作的次数为 $N$ 次本身（每次追加至少涉及一次写入）。当元素数量为 $1, 2, 4, \\dots, 2^m$（其中 $2^m  N$）时会发生扩容。这些扩容的成本是每一步中复制的元素数量之和。\n$$ T(N) = \\sum_{i=1}^N c_i = N + \\sum_{j=0}^{\\lfloor\\log_2(N-1)\\rfloor} 2^j $$\n该求和是一个几何级数：$\\sum_{j=0}^{k} 2^j = 2^{k+1} - 1$。这里，$k = \\lfloor\\log_2(N-1)\\rfloor$。\n$$ \\sum_{j=0}^{\\lfloor\\log_2(N-1)\\rfloor} 2^j \\le \\sum_{j=0}^{\\log_2(N)} 2^j = 2^{\\log_2(N)+1} - 1 = 2N - 1 $$\n所以，复制的总成本上限为 $2N$。$N$ 次追加的总成本为 $T(N) \\le N + 2N = 3N$。\n因此，$T(N) = O(N)$。每次操作的均摊成本是总成本除以操作次数，即 $T(N)/N = O(N)/N = O(1)$。这证实了追加操作具有均摊常数时间复杂度。\n\n**1.2. 随机化分区选择算法 (Quickselect)**\n\n在长度为 $n$ 的未排序数组中找到第 $k$ 小元素的算法通过递归地对数组进行分区来操作。该算法通常被称为 Quickselect。\n\n策略如下：\n1.  给定一个子数组（初始时为整个数组），从此子数组中均匀随机地选择一个主元。\n2.  将该子数组划分为三部分：小于主元的元素、主元本身以及大于主元的元素。这可以在线性时间 $O(m)$ 内原地完成，其中 $m$ 是子数组的大小。分区后，主元位于其最终排好序的位置，假设为索引 $p$。\n3.  设小于或等于主元的分区中的元素数量为 $L$。这对应于主元的次序。如果目标次序 $k$ 等于 $L$，则主元就是第 $k$ 小的元素，算法终止。\n4.  如果 $k  L$，第 $k$ 小的元素必定在较小元素的子数组中。算法对这个较小的子数组进行递归，仍然寻找第 $k$ 小的元素。\n5.  如果 $k > L$，第 $k$ 小的元素必定在较大元素的子数组中。算法对这个较大的子数组进行递归，但现在寻找第 $(k-L)$ 小的元素，因为左侧的 $L$ 个元素已被舍弃。\n\n效率的关键在于我们只对两个分区中的一个进行递归，而不是像 Quicksort 那样对两个都进行递归。\n\n**期望时间复杂度分析：**\n设 $T(n)$ 是算法在大小为 $n$ 的数组上的期望运行时间。分区步骤需要 $cn$ 的时间，其中 $c$ 是一个常数。主元是均匀随机选择的，因此它有相同的概率（$1/n$）成为第 $i$ 小的元素，对于任何 $i \\in \\{1, \\dots, n\\}$。\n如果主元是第 $i$ 小的元素，我们将面临一个大小为 $i-1$（如果 $k  i$）或 $n-i$（如果 $k > i$）的子问题。因此，递归调用的规模为 $\\max(i-1, n-i)$。期望时间的递推关系式为：\n$$ T(n) \\le cn + \\frac{1}{n}\\sum_{i=1}^{n} T(\\max(i-1, n-i)) $$\n对于大多数值，项 $\\max(i-1, n-i)$ 会出现两次。\n$$ T(n) \\le cn + \\frac{2}{n}\\sum_{i=\\lceil n/2 \\rceil}^{n-1} T(i) $$\n我们可以通过归纳法证明 $T(n) = O(n)$。假设对于某个常数 $a$，所有 $m  n$ 都有 $T(m) \\le am$。\n$$ T(n) \\le cn + \\frac{2a}{n} \\left( \\sum_{i=1}^{n-1} i - \\sum_{i=1}^{\\lceil n/2 \\rceil - 1} i \\right) $$\n使用前 $k$ 个整数的和的公式 $\\sum_{i=1}^{k}i = \\frac{k(k+1)}{2}$：\n$$ \\sum_{i=\\lceil n/2 \\rceil}^{n-1} i \\approx \\frac{(n-1)n}{2} - \\frac{(n/2)(n/2-1)}{2} = \\frac{n^2-n}{2} - \\frac{n^2/4-n/2}{2} \\approx \\frac{n^2}{2} - \\frac{n^2}{8} = \\frac{3n^2}{8} $$\n将此代入递推关系式中：\n$$ T(n) \\le cn + \\frac{2a}{n} \\left( \\frac{3n^2}{8} \\right) = cn + \\frac{3a}{4}n = n \\left(c + \\frac{3a}{4}\\right) $$\n为了使归纳成立，我们需要 $n(c + \\frac{3a}{4}) \\le an$。如果 $c + \\frac{3a}{4} \\le a$，即 $c \\le \\frac{a}{4}$ 或 $a \\ge 4c$，则此式成立。我们总可以选择一个足够大的常数 $a$ 来满足这个条件。\n因此，根据数学归纳法原理，$T(n) = O(n)$。期望运行时间与元素数量成线性关系。最坏情况下的时间是 $O(n^2)$，这发生在主元总是被选为最小或最大元素时，但随机选择主元时发生这种情况的概率极小。", "answer": "```python\nimport numpy as np\nimport random\nimport sys\n\n# Set a higher recursion limit for safety, although the iterative implementation avoids this.\n# sys.setrecursionlimit(2000)\n\nclass DynamicArray:\n    \"\"\"\n    A dynamic array implementation using a contiguous numpy array with a doubling-resize strategy.\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        Initializes an empty dynamic array with an initial capacity of 1.\n        \"\"\"\n        self._n = 0  # Number of elements\n        self._capacity = 1  # Allocated memory size\n        self._A = np.empty(self._capacity, dtype=object)  # Underlying storage\n\n    def __len__(self):\n        \"\"\"\n        Returns the number of elements in the array.\n        \"\"\"\n        return self._n\n\n    def __getitem__(self, k):\n        \"\"\"\n        Returns the element at index k.\n        \"\"\"\n        if not 0 = k  self._n:\n            raise IndexError('Index out of range')\n        return self._A[k]\n\n    def __setitem__(self, k, v):\n        \"\"\"\n        Sets the element at index k to value v.\n        \"\"\"\n        if not 0 = k  self._n:\n            raise IndexError('Index out of range')\n        self._A[k] = v\n\n    def append(self, item):\n        \"\"\"\n        Appends an item to the end of the array.\n        Resizes the array by doubling its capacity if it's full.\n        \"\"\"\n        if self._n == self._capacity:\n            self._resize(2 * self._capacity)\n        self._A[self._n] = item\n        self._n += 1\n\n    def _resize(self, new_capacity):\n        \"\"\"\n        Resizes the internal array to a new capacity.\n        \"\"\"\n        B = np.empty(new_capacity, dtype=object)\n        for i in range(self._n):\n            B[i] = self._A[i]\n        self._A = B\n        self._capacity = new_capacity\n\n    def __repr__(self):\n        \"\"\"\n        String representation of the array content.\n        \"\"\"\n        return f\"[{', '.join(map(str, [self._A[i] for i in range(self._n)]))}]\"\n\n\ndef _partition(arr, low, high):\n    \"\"\"\n    Helper function to partition the subarray arr[low..high] using the Lomuto partition scheme.\n    A random element is chosen as the pivot.\n    Returns the final index of the pivot.\n    \"\"\"\n    # Select a random pivot and move it to the end\n    pivot_index = random.randint(low, high)\n    arr[pivot_index], arr[high] = arr[high], arr[pivot_index]\n    pivot_value = arr[high]\n\n    # i is the index of the last element smaller than or equal to the pivot\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] = pivot_value:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n\n    # Place the pivot in its final sorted position\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n\ndef randomized_select(arr, k):\n    \"\"\"\n    Finds the k-th smallest element in a DynamicArray in expected linear time.\n    arr: A DynamicArray instance.\n    k: The one-based rank of the element to find (e.g., k=1 for minimum).\n    \"\"\"\n    n = len(arr)\n    if not 1 = k = n:\n        raise ValueError(\"k must be between 1 and the length of the array\")\n\n    # The algorithm works with 0-based indices. The k-th smallest element\n    # is at index k-1 in a sorted array.\n    target_idx = k - 1\n    \n    low, high = 0, n - 1\n\n    while True:\n        # If the subarray has only one element, it must be the one we're looking for.\n        if low == high:\n            return arr[low]\n\n        pivot_idx = _partition(arr, low, high)\n\n        if pivot_idx == target_idx:\n            return arr[pivot_idx]\n        elif target_idx  pivot_idx:\n            high = pivot_idx - 1\n        else:  # target_idx > pivot_idx\n            low = pivot_idx + 1\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final output.\n    \"\"\"\n    # Set a seed for the random number generator for reproducible results.\n    random.seed(42)\n\n    test_cases = [\n        {'A': [7, 2, 9, 4, 1, 5], 'k': 3},\n        {'A': [-5, -1, -3, -2], 'k': 1},\n        {'A': [3, 3, 3, 3], 'k': 4},\n        {'A': [5, 1, 5, 2, 5, 3, 5], 'k': 5},\n        {'A': [9, 8, 7, 6, 5, 4, 3, 2, 1], 'k': 9},\n        {'A': list(range(1000, 0, -1)), 'k': 500},\n        {'A': [0, -10, 10, 0, -10, 10], 'k': 4},\n    ]\n\n    results = []\n    for case in test_cases:\n        # 1. Construct the dynamic array by appending elements one by one.\n        dynamic_arr = DynamicArray()\n        for x in case['A']:\n            dynamic_arr.append(x)\n        \n        # 2. Find the k-th smallest element.\n        k = case['k']\n        result = randomized_select(dynamic_arr, k)\n        results.append(result)\n\n    # 3. Print the results in the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3230152"}]}