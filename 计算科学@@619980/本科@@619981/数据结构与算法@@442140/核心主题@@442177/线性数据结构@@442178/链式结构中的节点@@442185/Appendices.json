{"hands_on_practices": [{"introduction": "这第一个练习是检验你对链表遍历理解的经典问题 [@problem_id:3255694]。它不仅要求你能在链表中移动，更要求你思考如何在某个特定的相对位置停止，这是许多链表算法的关键技能。你将学习如何通过单次遍历和常数级别的额外空间来解决这个问题，并特别注意处理空链表或短链表等边界情况。", "problem": "给定单链表的定义：每个节点包含一个值和一个指向下一个节点的指针。形式上，一个节点存储一个整数值和一个对下一个节点的引用；最后一个节点的下一个引用为 $\\varnothing$。链表的头是第一个节点的引用，表示为 $head$。本任务中所有节点的值保证为非负整数，且没有节点值等于哨兵值 $-1$。\n\n设计并实现一个单次遍历算法，该算法在给定 $head$ 的情况下，返回列表中倒数第二个节点存储的值（如果存在）；否则，返回哨兵值 $-1$。该算法最多使用 $O(1)$ 的额外空间，不得修改列表，并且最多遍历列表一次。你可以假设在一个标准计算模型中，读取节点的值和跟随 next 指针的操作各需要 $O(1)$ 的时间。\n\n使用以下核心定义，从第一性原理推导该算法：\n- 单链表是由有向边连接的节点序列，除最后一个节点外，每个节点都有一个指向其后继节点的出指针，最后一个节点的后继为 $\\varnothing$。\n- 单次遍历指从 $head$ 开始，单调地跟随其后继指针访问节点，直到终止，期间不重新开始或回溯。\n\n你的程序必须硬编码并按此确切顺序处理以下输入列表的测试套件：\n- 输入列表：$\\varnothing$ (空列表)。\n- 输入列表：$[42]$。\n- 输入列表：$[1,2]$。\n- 输入列表：$[3,5,8]$。\n- 输入列表：$[9,9,9,9]$。\n- 输入列表：$[0,1,2,3,4,5]$。\n- 输入列表：$[100,200,300,400,500,600,700,800,900]$。\n\n对于每个输入列表，计算一个整数结果：倒数第二个节点的值，如果该节点不存在则为 $-1$。最终的输出格式必须将所有测试用例的结果聚合到一行，以逗号分隔的列表形式打印到标准输出，并用方括号括起来，不含空格，其确切形式为\n$[r_1,r_2,\\dots,r_7]$\n其中 $r_i$ 是第 $i$ 个测试用例的整数结果。", "solution": "在单次遍历和常数额外空间的约束下，在单链表中找到倒数第二个节点的问题，是关于指针操作和算法思维的一项基本练习。我们将从第一性原理推导此解决方案。\n\n假设一个单链表由节点序列 $N_1, N_2, \\dots, N_n$ 表示，其中 $n \\geq 0$ 是列表中的节点数。列表的头 $head$ 是对第一个节点 $N_1$ 的引用。如果列表为空 ($n=0$)，则 $head = \\varnothing$。对于 $1 \\leq i  n$ 的每个节点 $N_i$，它包含一个对其后继节点 $N_{i+1}$ 的引用 $N_i.\\text{next}$。最后一个节点 $N_n$ 的定义属性是 $N_n.\\text{next} = \\varnothing$。\n\n任务是找到倒数第二个节点 $N_{n-1}$ 的值。该节点仅在列表至少包含两个节点时（即 $n \\geq 2$）才被定义。\n\n让我们分析倒数第二个节点不存在的条件：\n1.  **空列表**：如果 $n=0$，列表为空 ($head = \\varnothing$)。此时没有节点，因此没有倒数第二个节点。\n2.  **单节点列表**：如果 $n=1$，列表只包含一个节点 $N_1$。该节点是最后一个节点，因为 $N_1.\\text{next} = \\varnothing$。此时没有倒数第二个节点。\n\n综合这两种情况，如果列表的节点数少于两个 ($n  2$)，则所需的节点不存在。这可以通过检查头指针来判断。如果 $head = \\varnothing$ 或 $head.\\text{next} = \\varnothing$，则列表分别有 0 或 1 个节点。在这些情况下，算法必须返回指定的哨兵值 $-1$。\n\n现在，考虑 $n \\geq 2$ 的情况。此时保证存在一个倒数第二个节点。设此节点为 $p$。根据定义，$p$ 是紧接在最后一个节点之前的节点。最后一个节点 $q$ 的特征是 $q.\\text{next} = \\varnothing$。因此，倒数第二个节点 $p$ 的特征是条件 $p.\\text{next} = q$ 和 $q.\\text{next} = \\varnothing$。代入 $q$ 可得到倒数第二个节点 $p$ 的定义属性：\n$$\np.\\text{next}.\\text{next} = \\varnothing\n$$\n现在问题简化为找到满足此条件的节点 $p$。约束要求单次遍历和 $O(1)$ 的额外空间。这意味着我们必须通过从 $head$ 开始单调地将一个或多个指针向列表末尾推进来定位 $p$，且只使用常数数量的辅助指针。\n\n基于此属性可以构建一个直接的算法。\n1.  首先，处理基本情况。如果 $head$ 是 $\\varnothing$ 或 $head.\\text{next}$ 是 $\\varnothing$，返回 $-1$。\n2.  如果列表至少有两个节点，我们可以从头节点开始遍历。让我们使用一个名为 `current` 的指针，初始化为 `head`。\n    $$\n    \\text{current} \\leftarrow head\n    $$\n3.  我们需要推进 `current`，直到它指向满足 $p.\\text{next}.\\text{next} = \\varnothing$ 的节点 $p$。这意味着只要 `current.next.next` *不*是 $\\varnothing$，我们就应该继续推进 `current`。\n4.  遍历循环可以表述为：\n    $$\n    \\text{while } \\text{current.next.next} \\neq \\varnothing \\text{ do} \\\\\n    \\quad \\text{current} \\leftarrow \\text{current.next} \\\\\n    \\text{end while}\n    $$\n5.  让我们追踪一下这个逻辑。当 `current.next.next` 为 $\\varnothing$ 时，循环终止。此时，`current.next` 是最后一个节点，这意味着 `current` 必定是倒数第二个节点。对 $n \\geq 2$ 的初始检查确保了表达式 `current.next.next` 在循环条件中求值是安全的，因为我们保证在首次进入循环时 `current` 和 `current.next` 都是非 $\\varnothing$ 的。对于一个恰好有两个节点 $N_1$ 和 $N_2$ 的列表，`head.next.next` 为 $\\varnothing$，所以循环条件立即为假，`current` 保持在 `head`，算法正确地将 $N_1$ 识别为倒数第二个节点。\n6.  循环终止后，指针 `current` 引用的是倒数第二个节点。所需的输出是存储在该节点中的值 `current.value`。\n\n该算法遵守所有约束：\n-   **单次遍历**：`current` 指针严格向前移动。\n-   **$O(1)$ 空间**：它使用一个辅助指针 `current`。\n-   **无修改**：列表结构只被读取，未被改变。\n-   **单次遍历**：列表被遍历一次。\n\n将此逻辑应用于给定的测试用例：\n-   输入：$\\varnothing$。$head = \\varnothing$。条件 `head == null` 为真。返回 $-1$。\n-   输入：$[42]$。$head \\neq \\varnothing$，但 $head.\\text{next} = \\varnothing$。条件 `head.next == null` 为真。返回 $-1$。\n-   输入：$[1,2]$。$head$ 和 $head.\\text{next}$ 非 $\\varnothing$。将 `current` 初始化为节点 $1$。循环条件 `current.next.next != null` 为假，因为 `node(1).next.next` 是 $\\varnothing$。循环被跳过。返回 `current.value`，即 $1$。\n-   输入：$[3,5,8]$。将 `current` 初始化为节点 $3$。循环条件 `current.next.next != null` (即 `node(3).next.next`，也就是 `node(8)`) 为真。`current` 前进到节点 $5$。现在 `current.next.next` 是 $\\varnothing$。循环终止。返回 `current.value`，即 $5$。\n-   输入：$[9,9,9,9]$。`current` 从节点 $9_1$ 开始。它前进到 $9_2$，然后到 $9_3$。在 $9_3$ 处，`current.next.next` 为 $\\varnothing$。循环终止。返回 `current.value`，即 $9$。\n-   输入：$[0,1,2,3,4,5]$。`current` 前进四次，最终停在节点 $4$。返回 $4$。\n-   输入：$[100, ..., 900]$。`current` 前进七次，最终停在节点 $800$。返回 $800$。\n\n预期的结果序列是 $[-1, -1, 1, 5, 9, 4, 800]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Definition for singly-linked list node.\nclass Node:\n    def __init__(self, val=0, next_node=None):\n        \"\"\"\n        Initializes a node for a singly linked list.\n\n        Args:\n            val (int): The integer value stored in the node.\n            next_node (Node, optional): A reference to the next node in the list. Defaults to None.\n        \"\"\"\n        self.value = val\n        self.next = next_node\n\ndef build_linked_list(values):\n    \"\"\"\n    Builds a singly linked list from a list of values.\n\n    Args:\n        values (list[int]): A list of integer values for the nodes.\n\n    Returns:\n        Node: The head of the newly created linked list, or None if the input list is empty.\n    \"\"\"\n    if not values:\n        return None\n    \n    head = Node(values[0])\n    current = head\n    for val in values[1:]:\n        current.next = Node(val)\n        current = current.next\n    return head\n\ndef find_second_to_last_value(head):\n    \"\"\"\n    Finds the value of the second-to-last node in a singly linked list.\n\n    The algorithm is single-pass, uses O(1) additional space, and does not modify the list.\n\n    Args:\n        head (Node): The head of the singly linked list.\n\n    Returns:\n        int: The value of the second-to-last node, or -1 if the list has fewer than 2 nodes.\n    \"\"\"\n    sentinel = -1\n\n    # According to the problem definition, a second-to-last node exists only if the list\n    # contains at least two nodes.\n    # Case 1: The list is empty (head is None).\n    # Case 2: The list has only one node (head.next is None).\n    if not head or not head.next:\n        return sentinel\n\n    # If the list has at least two nodes, we can safely start traversal.\n    # Let 'current' be a pointer that we will advance through the list.\n    # We want to stop when 'current' points to the second-to-last node.\n    # A node 'p' is the second-to-last node if its successor, 'p.next', is the last node.\n    # The last node 'q' is defined by q.next == None.\n    # Therefore, the second-to-last node 'p' satisfies the condition p.next.next == None.\n    current = head\n    \n    # We advance 'current' as long as its successor has a successor.\n    # This loop terminates when current.next.next is None, which means\n    # current.next is the last node, and thus 'current' is the second-to-last node.\n    while current.next.next:\n        current = current.next\n        \n    # At this point, 'current' is the second-to-last node.\n    return current.value\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the algorithm on each case, and prints the results.\n    \"\"\"\n    # The problem statement defines the test suite of input lists.\n    test_cases = [\n        [],                            # Case 1: Empty list\n        [42],                          # Case 2: Single node\n        [1, 2],                        # Case 3: Two nodes\n        [3, 5, 8],                     # Case 4: Three nodes\n        [9, 9, 9, 9],                  # Case 5: Four nodes\n        [0, 1, 2, 3, 4, 5],            # Case 6: Six nodes\n        [100, 200, 300, 400, 500, 600, 700, 800, 900] # Case 7: Nine nodes\n    ]\n\n    results = []\n    for case_values in test_cases:\n        # Construct the linked list from the list of values.\n        head_node = build_linked_list(case_values)\n        \n        # Calculate the result for the current test case.\n        result = find_second_to_last_value(head_node)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3255694"}, {"introduction": "在单向链表中，标准的删除操作需要访问前驱节点，但这无法直接获得。这个练习 [@problem_id:3255580] 挑战你跳出直接删除的思维定式，通过巧妙地操纵节点的值和指针，找到一个恒定时间复杂度的解决方案。这个问题突显了数据逻辑序列与底层物理节点结构之间的区别，并迫使你直面数据结构本身的局限性，即尾节点无法通过此方法处理的情况。", "problem": "给定一个单向链式结构，其节点由两个字段定义：一个整数值 $v$ 和一个指向下一个节点的引用 $next$。根据定义，单向链表维持着一个不变性，即每个节点存储一个后继引用，但没有前驱引用；也就是说，对于任何有后继节点 $w$ 的节点 $u$，有 $u.next = w$，但 $u$ 中没有字段指向其前驱节点。需要使用的基本假设是以下核心定义：一个单向链表是一个有限的节点序列 $\\langle u_0,u_1,\\dots,u_{n-1}\\rangle$，其中对于所有 $0 \\le i  n-1$ 的 $i$ 都有 $u_i.next = u_{i+1}$，且 $u_{n-1}.next = \\varnothing$；每个节点包含一个可观察的数据值 $v$，并且指针（引用）可以在常数时间内重新赋值。这些事实在链式结构的研究中经过了充分的测试并被广泛接受。\n\n设计并实现一个程序，在仅给定一个指向单向链表中某个节点 $u$ 的直接指针的情况下，尝试在常数时间 $O(1)$ 内删除该节点，而无需从链表头部开始遍历。该操作必须使用常数辅助空间 $O(1)$，并执行有界次数的字段读取和写入。如果在此约束下操作不可能完成，你的程序必须检测到这一点并报告失败。不允许从头节点遍历或使用任何外部索引来定位前驱节点。你只能使用通过给定节点指针 $u$ 及其通过 $u.next$ 可达的后继节点所能获得的局部信息。程序在尝试操作后必须保持链表的结构有效。\n\n实现以下行为：\n- 给定一个指向节点 $u$ 的指针，尝试仅使用 $u$ 及其可访问的 $next$ 引用，在遵守常数时间约束的情况下删除 $u$。如果删除成功，返回整数 $1$；如果删除不可能，返回整数 $0$。无论哪种情况，都应同时生成操作尝试后从头到尾的节点值列表。\n- 对此问题而言，删除操作不可能的唯一情况是当 $u$ 为尾节点 $u_{n-1}$ 时，因为在单向链表的约束下，没有后继节点来支持常数时间的局部转换。在所有其他情况下，删除必须成功，同时为除 $u$ 之外的所有节点保留链表的顺序。\n\n你的程序应该为测试套件构建链表，通过位置索引获取指针 $u$（仅用于测试构建），然后对每个测试用例，仅使用提供的指针执行删除尝试。最终的聚合输出必须是单行，包含一个列表，其中每个元素是针对一个测试用例的两部分结果，格式为 $[s, L]$，其中 $s$ 是表示成功的整数指示符（$1$ 表示成功，$0$ 表示失败），$L$ 是表示尝试后从头到尾的链表值的整数列表。\n\n要实现的测试套件：\n- 情况 A：初始值 $[1,2,3,4,5]$，指针指向索引 $2$（中间节点）。\n- 情况 B：初始值 $[1,2,3,4,5]$，指针指向索引 $0$（长度大于 $1$ 的链表中的头节点）。\n- 情况 C：初始值 $[1,2,3,4,5]$，指针指向索引 $4$（尾节点）。\n- 情况 D：初始值 $[7]$，指针指向索引 $0$（单节点链表，即尾节点）。\n- 情况 E：初始值 $[2,2,3,2]$，指针指向索引 $1$（存在重复值）。\n- 情况 F：初始值 $[9,8]$，指针指向索引 $0$（双节点链表，头节点）。\n\n你的程序应该生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，每个结果的格式如上所述。例如，输出的格式应为 $[[s_1,L_1],[s_2,L_2],\\dots]$，行内任何地方都不能有空格。所有输出都是无单位且纯逻辑的。每个 $s_i$ 必须是整数，每个 $L_i$ 必须是整数列表。", "solution": "该问题要求设计一个算法，在仅给定指向单向链表中节点 $u$ 的指针的情况下，在常数时间 $O(1)$ 内删除该节点。该解决方案还必须在常数辅助空间 $O(1)$ 内运行，并且不允许从链表头部开始遍历。\n\n单向链表的基本结构，定义为节点序列 $\\langle u_0, u_1, \\dots, u_{n-1} \\rangle$，其中每个节点 $u_i$ 包含一个指向其后继节点 $u_{i+1}$ 的引用 $u_i.next$ 但不包含指向其前驱节点 $u_{i-1}$ 的引用，这对删除操作施加了关键的约束。标准的节点 $u$ 删除操作需要修改其前驱节点（假设为 $p$）的 `next` 引用，使得 $p.next$ 重定向到 $u.next$。仅给定指向 $u$ 的指针，没有直接的方法可以在 $O(1)$ 时间内访问 $p$。通过从头节点遍历来定位 $p$ 将导致最坏情况下的时间复杂度为 $O(n)$，这违反了问题的主要约束。\n\n这个问题可以通过一种逻辑转换来解决，该转换避免了删除节点 $u$ 本身，但达到了等效的结果。其核心思想是认识到我们可以以常数时间访问节点的后继节点 $v = u.next$。如果存在这样的后继节点，我们可以通过将 $u$ 转换为 $v$ 的逻辑副本，然后从链表中移除 $v$，从而有效地“删除”$u$。\n\n对于一个不是链表尾部的给定节点 $u$，算法流程如下：\n\n1.  **识别后继节点**：令 $v = u.next$。由于 $u$ 不是尾节点，$v$ 保证是一个有效节点（即不是 $\\varnothing$）。\n\n2.  **值覆盖**：来自后继节点 $v$ 的数据被复制到节点 $u$ 中。根据问题定义，设节点的值字段为 $v$。此操作表示为 $u.v \\leftarrow v.v$。此步骤后，节点 $u$ 现在持有其后继节点原有的值。从遍历链表的观察者角度来看，最初与节点 $u$ 关联的值已从序列中移除。\n\n3.  **指针重链接**：为了完成对逻辑后继节点的删除，节点 $u$ 的 `next` 指针被更新，以绕过 $v$ 并直接指向 $v$ 的后继节点。此操作表示为 $u.next \\leftarrow v.next$，等效于 $u.next \\leftarrow u.next.next$。此操作正确地将 $v$ 从链式结构中移除。\n\n完成这两个步骤后，节点对象 $u$ 仍然在链表中，但它现在包含其原后继节点的数据，并且链表结构正确地跳过了该后继节点。链表中值的逻辑序列现在与原始节点 $u$ 被移除后的情况完全相同。这两个步骤都涉及固定数量的赋值和指针解引用，因此整个过程在常数时间 $O(1)$ 内执行，并使用常数辅助空间 $O(1)$。\n\n此算法依赖于后继节点 $u.next$ 的存在。如果给定节点 $u$ 是链表的尾节点，根据定义 $u.next$ 为 $\\varnothing$。在这种情况下，没有后继节点可以从中复制数据。在没有前驱节点引用的情况下，将其 `next` 指针修改为 $\\varnothing$ 仍然是不可能的。因此，对于尾节点，常数时间的删除是不可行的。\n\n实现时必须首先检查条件 $u.next = \\varnothing$。\n- 如果条件为真，则节点 $u$ 是尾节点。操作不可能完成，返回失败状态（$0$）。链表保持不变。\n- 如果条件为假，则节点 $u$ 不是尾节点。执行两步算法（值复制和指针重链接）。返回成功状态（$1$），链表处于正确修改后的状态。\n\n该方法正确处理了问题陈述中指定的所有情况，并遵守了所有的复杂度和操作约束。测试用例将通过以下方式处理：构建链表，为每个测试获取目标节点指针，应用删除逻辑，然后将结果链表状态与成功指示符一起序列化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of constant-time node deletion in a singly linked list.\n    \"\"\"\n\n    class Node:\n        \"\"\"Node for a singly linked list as defined in the problem.\"\"\"\n        def __init__(self, value, next_node=None):\n            self.value = value\n            self.next = next_node\n\n        def __repr__(self):\n            return f\"Node({self.value})\"\n\n    def build_list_from_values(values):\n        \"\"\"Helper to construct a linked list from a list of integer values.\"\"\"\n        if not values:\n            return None\n        head = Node(values[0])\n        current = head\n        for val in values[1:]:\n            current.next = Node(val)\n            current = current.next\n        return head\n\n    def get_node_by_index(head, index):\n        \"\"\"Helper to get the node at a specific index, for test setup only.\"\"\"\n        current = head\n        for _ in range(index):\n            if current is None:\n                return None  # Index out of bounds\n            current = current.next\n        return current\n\n    def get_list_values(head):\n        \"\"\"Helper to convert the linked list back to a Python list of values.\"\"\"\n        values = []\n        current = head\n        while current:\n            values.append(current.value)\n            current = current.next\n        return values\n\n    def attempt_delete_node(node_to_delete):\n        \"\"\"\n        Attempts to delete the given node in O(1) time by value copying.\n        Returns 1 on success, 0 on failure.\n        Failure occurs if the node is the tail of the list.\n        \"\"\"\n        # A successor node is required for this O(1) deletion method.\n        # If node_to_delete.next is None, it is the tail node, and deletion is impossible.\n        if node_to_delete is None or node_to_delete.next is None:\n            return 0  # Failure\n\n        # The node is not the tail, so deletion is possible.\n        successor = node_to_delete.next\n        \n        # Step 1: Copy the value from the successor to the current node.\n        node_to_delete.value = successor.value\n        \n        # Step 2: Bypass the successor node.\n        node_to_delete.next = successor.next\n        \n        return 1  # Success\n\n    # Test suite as defined in the problem statement.\n    test_cases = [\n        {'values': [1, 2, 3, 4, 5], 'index': 2},  # Case A\n        {'values': [1, 2, 3, 4, 5], 'index': 0},  # Case B\n        {'values': [1, 2, 3, 4, 5], 'index': 4},  # Case C\n        {'values': [7], 'index': 0},              # Case D\n        {'values': [2, 2, 3, 2], 'index': 1},      # Case E\n        {'values': [9, 8], 'index': 0},            # Case F\n    ]\n\n    results_as_strings = []\n    for case in test_cases:\n        initial_values = case['values']\n        target_index = case['index']\n        \n        # Each test must run on a fresh instance of the list.\n        head = build_list_from_values(initial_values)\n        \n        # Get the pointer to the node to be deleted (for test setup only).\n        # The core algorithm itself does not use the index.\n        node_to_delete = get_node_by_index(head, target_index)\n        \n        # Perform the deletion attempt.\n        success_code = attempt_delete_node(node_to_delete)\n        \n        # Capture the state of the list after the attempt.\n        final_values = get_list_values(head)\n        \n        # Format the result for this case according to the specified format '[s,L]'.\n        final_values_str = f\"[{','.join(map(str, final_values))}]\"\n        case_result_str = f\"[{success_code},{final_values_str}]\"\n        results_as_strings.append(case_result_str)\n\n    # Final print statement in the exact required format '[[s1,L1],[s2,L2],...]'.\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```", "id": "3255580"}, {"introduction": "我们最后的这个练习是一个综合性的挑战，它将多种高级链表技巧融合成一个优雅的解决方案 [@problem_id:3255584]。为了在严格的 $O(1)$ 空间限制下判断一个链表是否为回文，你需要找到链表的中点，就地反转其后半部分，进行比较，然后将链表恢复原状。这个练习充分展示了指针操作在高效解决复杂问题时的强大威力与灵活性。", "problem": "考虑一个单链式结构，其中每个节点包含一个整数值和一个指向下一个节点的指针。单链表由一个头节点和一系列节点定义，其中每个节点有一个存储值的字段和一个引用下一个节点的字段；最后一个节点不引用任何其他节点。如果一个有限序列正向和反向读取都相同，则称其为回文序列。形式上，一个长度为 $n$、元素为 $a_0, a_1, \\ldots, a_{n-1}$ 的序列是回文序列，当且仅当对于所有满足 $0 \\leq i  n$ 的索引 $i$，都有 $a_i = a_{n-1-i}$ 成立。您的任务是实现一个程序，为给定的测试套件构建链表，并对每个链表，使用一个源于单链表和回文属性核心定义的方法来判断它是否是回文。该方法必须以线性渐进时间（即 $O(n)$）和常数辅助空间（即 $O(1)$）运行，其中 $n$ 是链表中的节点数。程序不得假定预先知道链表长度，并且必须仅依赖于局部节点引用。在执行任何原地变换以检查回文属性后，程序必须将链表恢复到其原始结构，以保持其结构完整性以备后续操作。就本问题而言，空序列被认为是回文。不涉及物理单位或角度单位。您必须实现的测试套件包含以下链表，以节点值序列的形式给出：情况 $1$: $\\langle \\rangle$，情况 $2$: $\\langle 7 \\rangle$，情况 $3$: $\\langle 1, 2, 2, 1 \\rangle$，情况 $4$: $\\langle 1, 2, 3, 2, 1 \\rangle$，情况 $5$: $\\langle 1, 2 \\rangle$，情况 $6$: $\\langle 10, -1, -1, 10 \\rangle$，情况 $7$: $\\langle 3, 4, 5, 4, 6 \\rangle$，情况 $8$: $\\langle 1, 0, 0, 1 \\rangle$，情况 $9$: $\\langle 9, 9, 9, 9 \\rangle$，情况 $10$: $\\langle 2147483647, -2147483648, -2147483648, 2147483647 \\rangle$。您的程序应按顺序处理这 $10$ 个案例，并生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[\\,\\text{True},\\text{False},\\ldots\\,]$，如果对应的链表是回文，则每个条目为 $\\text{True}$，否则为 $\\text{False}$。", "solution": "问题要求判断一个单链表是否代表一个回文。一个长度为 $n$ 的序列 $a_0, a_1, \\ldots, a_{n-1}$ 是回文，如果对于所有有效索引 $i$ 都有 $a_i = a_{n-1-i}$。解决方案必须遵守严格的性能限制：线性时间复杂度 $O(n)$ 和常数辅助空间复杂度 $O(1)$，其中 $n$ 是链表中的节点数。此外，检查后必须恢复链表的原始结构。\n\n一种朴素的方法，例如将链表值复制到一个数组中，并使用两个指针检查回文对称性，会违反 $O(1)$ 的空间限制，因为数组需要 $O(n)$ 的空间。同样，递归解决方案会使用调用栈，在最坏情况下也构成 $O(n)$ 的辅助空间。\n\n指定的限制要求使用一种原地算法来操作链表的指针。一个满足这些要求的成熟方法包括四个步骤：找到链表的中点，反转后半部分，比较前半部分和反转后的后半部分，最后恢复原始链表结构。\n\n**步骤 1：找到中点**\n为了在不知道链表长度 $n$ 的情况下通过单次遍历找到链表中点，我们采用“龟兔赛跑”算法。两个指针，一个 $slow$ 指针和一个 $fast$ 指针，被初始化为链表的头节点。这两个指针在一个循环中遍历链表：$slow$ 指针一次移动一个节点（$slow = slow.next$），而 $fast$ 指针一次移动两个节点（$fast = fast.next.next$）。循环持续进行，只要 $fast.next$ 和 $fast.next.next$ 不为 $\\varnothing$。\n\n当这个循环终止时，$slow$ 指针将被正确定位，以划分链表的前半部分和后半部分。\n- 对于节点数为偶数 $n = 2k$ 的链表，$slow$ 指针将停在第 $k$ 个节点（前半部分的末尾）。\n- 对于节点数为奇数 $n = 2k+1$ 的链表，$slow$ 指针将停在第 $k$ 个节点，也就是中心元素的前一个节点。中心元素本身不需要比较，因为它是自己的对应项。\n\n因此，链表后半部分的头节点总是在 $slow.next$。\n\n**步骤 2：反转后半部分**\n找到中点后，必须原地反转从 $slow.next$ 开始的链表后半部分。这是链表的标准操作，可以在线性和常数空间内完成。我们使用三个指针：$previous$、$current$ 和 $next\\_node$。\n1. 初始化 $previous = \\varnothing$ 和 $current$ 为要反转的子链表的头节点（即 $slow.next$）。\n2. 当 $current \\neq \\varnothing$ 时进行迭代：\n   a. 存储下一个节点：$next\\_node = current.next$。\n   b. 反转当前节点的指针：$current.next = previous$。\n   c. 将 $previous$ 和 $current$ 指针向前移动一步：$previous = current$ 和 $current = next\\_node$。\n循环结束后，$previous$ 将指向现在已反转的后半部分的新头节点。在执行反转之前，通过设置 $slow.next = \\varnothing$ 来断开前半部分和后半部分之间的链接是至关重要的。\n\n**步骤 3：比较两半部分**\n在后半部分被反转后，我们现在可以将其与前半部分进行比较。我们使用两个指针：一个从链表的原始 $head$ 开始（$first\\_half\\_ptr$），另一个从反转后的后半部分的头节点开始（$second\\_half\\_ptr$）。这两个指针同时前进，并在每一步比较它们对应节点的值。\n- $first\\_half\\_ptr = head$\n- $second\\_half\\_ptr = head\\_of\\_reversed\\_second\\_half$\n只要 $second\\_half\\_ptr \\neq \\varnothing$，遍历就继续。如果在任何时候 $first\\_half\\_ptr.val \\neq second\\_half\\_ptr.val$，我们就断定链表不是回文，并可以停止比较。如果循环完成而没有发现任何不匹配，那么链表是回文。\n\n**步骤 4：恢复原始链表结构**\n问题的一个关键要求是让链表保持其原始状态。这通过再次反转链表的后半部分来实现，这将恢复其原始顺序。将步骤 2 中的相同反转算法应用于反转后的后半部分的头节点。这个新反转的链表的头节点随后被链接回前半部分的末尾，即 $slow.next$ 被设置为指向恢复后的后半部分的头节点。这无缝地重建了原始链表。\n\n**边界情况**\n- 空链表（$head$ 为 $\\varnothing$）是回文。\n- 只有一个节点的链表（$head.next$ 为 $\\varnothing$）也是回文。\n这些情况在函数的开头处理，以简化主逻辑。\n\n**复杂度分析**\n- **时间复杂度**：找到中点需要 $O(n/2)$ 的时间。反转后半部分需要 $O(n/2)$ 的时间。比较需要 $O(n/2)$ 的时间。恢复链表又需要 $O(n/2)$ 的时间。总时间复杂度是这些部分的总和，即 $O(n)$。\n- **空间复杂度**：该算法使用固定数量的指针（$slow$、$fast$、$previous$、$current$ 等），与链表大小 $n$ 无关。所有操作都是原地完成的。因此，辅助空间复杂度为 $O(1)$。\n\n该算法在满足所有问题约束的同时，正确地判断了回文属性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom typing import Optional, List\n\nclass Node:\n    \"\"\"\n    Represents a node in a singly linked list.\n    \"\"\"\n    def __init__(self, val: int, next_node: Optional['Node'] = None):\n        self.val = val\n        self.next = next_node\n\ndef create_linked_list(values: List[int]) - Optional[Node]:\n    \"\"\"\n    Helper function to create a singly linked list from a list of values.\n    \"\"\"\n    if not values:\n        return None\n    head = Node(values[0])\n    current = head\n    for val in values[1:]:\n        current.next = Node(val)\n        current = current.next\n    return head\n\ndef is_palindrome(head: Optional[Node]) - bool:\n    \"\"\"\n    Checks if a singly linked list is a palindrome in O(n) time and O(1) space.\n    The list is restored to its original state after the check.\n    \"\"\"\n    # Edge cases: an empty list or a list with a single node are palindromes.\n    if not head or not head.next:\n        return True\n\n    # Step 1: Find the middle of the list using the slow/fast pointer technique.\n    slow = head\n    fast = head\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    # Step 2: Reverse the second half of the list.\n    def reverse_list(node: Optional[Node]) - Optional[Node]:\n        prev = None\n        curr = node\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        return prev\n\n    # slow.next is the head of the second half.\n    second_half_head = reverse_list(slow.next)\n    \n    # Detach the first half from the second half for comparison.\n    # Note: this link will be restored later.\n    slow.next = None\n    \n    # Step 3: Compare the first half with the reversed second half.\n    is_pal = True\n    first_half_ptr = head\n    second_half_ptr = second_half_head\n    while second_half_ptr:\n        if first_half_ptr.val != second_half_ptr.val:\n            is_pal = False\n            break\n        first_half_ptr = first_half_ptr.next\n        second_half_ptr = second_half_ptr.next\n\n    # Step 4: Restore the original list by reversing the second half again\n    # and re-attaching it to the first half.\n    # The head of the re-reversed list will be the original start of the second half.\n    restored_second_half_head = reverse_list(second_half_head)\n    slow.next = restored_second_half_head\n    \n    return is_pal\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [],                            # case 1\n        [7],                           # case 2\n        [1, 2, 2, 1],                  # case 3\n        [1, 2, 3, 2, 1],               # case 4\n        [1, 2],                        # case 5\n        [10, -1, -1, 10],              # case 6\n        [3, 4, 5, 4, 6],               # case 7\n        [1, 0, 0, 1],                  # case 8\n        [9, 9, 9, 9],                  # case 9\n        [2147483647, -2147483648, -2147483648, 2147483647] # case 10\n    ]\n\n    results = []\n    for case_values in test_cases:\n        # Construct the linked list for the current test case.\n        head = create_linked_list(case_values)\n        \n        # Check if it is a palindrome and store the result.\n        result = is_palindrome(head)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3255584"}]}