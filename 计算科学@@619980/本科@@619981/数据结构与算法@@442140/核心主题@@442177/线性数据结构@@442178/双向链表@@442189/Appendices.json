{"hands_on_practices": [{"introduction": "这个实践旨在利用双向链表的核心优势：高效的双向遍历。它要求你判断一个链表中的数据是否构成回文序列，这是一个经典的算法问题，但通过同时从头部正向遍历和从尾部反向遍历，问题变得异常简洁。这项练习将巩固你对指针遍历的理解，并让你体会到双向链表结构与生俱来的好处。[@problem_id:3229848]", "problem": "您的任务是编写一个完整的、可运行的程序，该程序为多个有限整数序列判断：由该序列构建的双向链表中所存储的数据是否构成一个回文。程序必须为每个给定的序列构建一个双向链表，然后确定从头到尾读取节点数据所得到的序列是否与从尾到头读取的序列相同。\n\n基本概念。双向链表是一个有限的节点序列，其中每个节点包含一个整数载荷和两个引用：一个指向其后继的向前引用 $next$ 和一个指向其前驱的向后引用 $prev$。一个长度为 $n$ 的序列 $(a_0, a_1, \\dots, a_{n-1})$ 是回文，当且仅当对于所有满足 $0 \\le i  \\lfloor n/2 \\rfloor$ 的索引 $i$，都有 $a_i = a_{n-1-i}$ 成立。根据此定义，空序列（长度 $n = 0$）也满足回文属性。\n\n要求和约束。您的算法必须源自这些核心定义，并遵守以下约束，这些约束需要在您的解决方案中通过第一性原理解释：\n- 时间复杂度必须是关于节点数 $n$ 的线性时间，即 $\\mathcal{O}(n)$。\n- 额外的空间使用必须相对于 $n$ 是常数级别的，即 $\\mathcal{O}(1)$，这不包括存储输入双向链表本身所需的空间。特别地，不要分配大小随 $n$ 增长的辅助数组、栈或列表。\n- 不要修改节点的载荷或列表的 $next$/$prev$ 拓扑结构。您可以通过跟随 $next$ 和 $prev$ 引用进行遍历并比较载荷。\n\n测试套件。您的程序必须对以下序列评估回文谓词，每个序列都应被解释为双向链表中从头节点到尾节点的数据值顺序：\n- 测试 $1$：$\\langle 1, 2, 3, 2, 1 \\rangle$\n- 测试 $2$：$\\langle 4, 5, 5, 4 \\rangle$\n- 测试 $3$：$\\langle 1, 2, 3, 4, 5 \\rangle$\n- 测试 $4$：$\\langle 7 \\rangle$\n- 测试 $5$：$\\langle \\rangle$ (空列表)\n- 测试 $6$：$\\langle 10, -1, -1, 10 \\rangle$\n- 测试 $7$：$\\langle 2, 2, 2, 2, 2, 2 \\rangle$\n- 测试 $8$：$\\langle 1, 2, 2, 3, 2, 2, 1 \\rangle$\n- 测试 $9$：$\\langle 1, 2 \\rangle$\n- 测试 $10$：$\\langle 0, 1, 0, 1 \\rangle$\n\n答案类型。对于每个测试，您的程序必须生成一个布尔值，以表明相应的列表根据上述定义是否为回文。\n\n最终输出格式。您的程序应生成单行输出，其中包含测试1到10的结果，结果按顺序排列，以逗号分隔并用方括号括起来，每个布尔值写为字面标记 True 或 False，且不含空格。例如，一个有效的输出看起来像 [True,False,True]。您的程序必须是自包含的，不得读取任何输入；它必须在内部为测试构建列表，并打印所需的单行输出。", "solution": "问题要求创建并验证一种算法，以确定双向链表中的数据是否构成回文。该算法必须遵守严格的复杂度约束：时间复杂度为 $\\mathcal{O}(n)$，额外空间复杂度为 $\\mathcal{O}(1)$，其中 $n$ 是链表中的节点数。\n\n### 问题验证\n\n首先，对问题陈述进行验证。\n- **已知条件**：\n    1.  双向链表节点具有一个整数载荷、一个 `$next$` 引用和一个 `$prev$` 引用。\n    2.  序列 $(a_0, a_1, \\dots, a_{n-1})$ 是回文，如果对于所有满足 $0 \\le i  \\lfloor n/2 \\rfloor$ 的 $i$，都有 $a_i = a_{n-1-i}$。\n    3.  空序列（$n=0$）是回文。\n    4.  算法的时间复杂度必须为 $\\mathcal{O}(n)$。\n    5.  算法的额外空间复杂度必须为 $\\mathcal{O}(1)$。\n    6.  链表结构及其数据不得被修改。\n    7.  提供了一个包含十个测试用例的特定套件。\n- **分析**：\n    -   该问题在数据结构和算法的既定原则上具有**科学依据**。双向链表和回文的定义是标准的且数学上是精确的。\n    -   该问题是**适定的**。它提供了清晰的定义、约束和测试用例，为每个测试导向一个唯一的、可验证的布尔结果。\n    -   该问题是**客观的**，没有歧义或主观论断。\n    -   约束条件是自洽的，并且存在一个已知的、满足这些条件的有效算法。\n- **结论**：问题有效。\n\n### 基于原则的算法设计\n\n解决方案直接源自回文的定义和双向链表的结构特性。\n\n1.  **核心原则**：回文的定义 $a_i = a_{n-1-i}$ 要求比较序列中心对称位置的元素。第 $0$ 个元素必须与第 $(n-1)$ 个元素匹配，第 $1$ 个元素必须与第 $(n-2)$ 个元素匹配，以此类推，直到序列的中间。\n\n2.  **算法策略**：双向链表非常适合这种比较。它允许从两端同时遍历。我们可以采用双指针技术。让一个指针 $p_{head}$ 从链表头部开始，使用 $next$ 引用向前遍历。让第二个指针 $p_{tail}$ 从链表尾部开始，使用 $prev$ 引用向后遍历。在每一步中，我们比较 $p_{head}$ 和 $p_{tail}$ 所指向节点的数据载荷。\n\n3.  **算法形式化**：\n    *   **初始化**：开始时，我们需要访问链表的 $head$ 和 $tail$。我们初始化两个指针：$p_{head} \\leftarrow head$ 和 $p_{tail} \\leftarrow tail$。\n    *   **边界情况**：\n        *   如果链表为空（`$head$` 为空，对应 $n=0$），根据定义它是回文。算法应返回 `True`。\n        *   如果链表只有一个元素（`$head == tail$`，对应 $n=1$），它也是回文。下面设计的主循环逻辑将正确处理这种情况。\n    *   **迭代比较**：算法在一个循环中进行。在每次迭代中：\n        1.  比较数据载荷：`if $p_{head}.data \\ne p_{tail}.data$`，则发现不匹配。该序列不是回文，算法可以立即终止并返回 `False`。\n        2.  指针向中心移动：$p_{head} \\leftarrow p_{head}.next$ 和 $p_{tail} \\leftarrow p_{tail}.prev$。\n    *   **终止条件**：循环继续，直到指针相遇或交叉，这表示所有必要的对都已检查完毕。这可以通过以下两个条件之一来检测：\n        1.  $p_{head} == p_{tail}$：当指针在奇数长度链表的中心节点相遇时发生。\n        2.  $p_{head}.prev == p_{tail}$：这在偶数长度链表中指针交叉后立即发生。`while` 循环条件检查 `p_head != p_tail` 和 `p_head.prev != p_tail` 以优雅地处理这两种情况。一个更简单的方法是在移动指针*之前*检测两个指针是否相邻（$p_{head}.next == p_{tail}$），这标志着对偶数长度列表的最后一次比较。\n    *   **最终结果**：如果循环完成而没有发现任何不匹配，则确认对于所有必需的 $i$，都有 $a_i = a_{n-1-i}$。算法返回 `True`。\n\n一个鲁棒的循环内检查序列是：\n```\nwhile True:\n    if $p_{head}.data \\ne p_{tail}.data$: return False\n    if $p_{head} == p_{tail}$: break  // 到达奇数长度列表的中间\n    if $p_{head}.next == p_{tail}$: break // 到达偶数长度列表的中间\n    $p_{head} \\leftarrow p_{head}.next$\n    $p_{tail} \\leftarrow p_{tail}.prev$\nreturn True\n```\n\n4.  **复杂度证明**：\n    *   **时间复杂度**：指针 $p_{head}$ 和 $p_{tail}$ 从两端开始并相互移动。每个指针大约遍历 $n/2$ 个节点。由于每个节点完成的工作是常量的（一次比较和一次指针更新），所以总时间与 $n$ 成正比。这得出的时间复杂度为 $\\mathcal{O}(n)$，满足约束条件。\n    *   **空间复杂度**：该算法仅使用固定数量的变量（两个指针：$p_{head}$ 和 $p_{tail}$）。使用的内存量不随列表大小 $n$ 扩展。因此，额外空间复杂度为 $\\mathcal{O}(1)$，满足约束条件。\n    *   **不变性**：该算法仅从节点读取数据（`.data`）并跟随现有引用（`.next`、`.prev`）。它不修改任何节点载荷或列表的拓扑结构，遵守不变性约束。\n\n因此，这种双指针方法是针对所述问题的正确、最优且有原则的解决方案。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to construct doubly linked lists from test cases,\n    check for the palindrome property, and print the results.\n    \"\"\"\n\n    class Node:\n        \"\"\"\n        Represents a node in a doubly linked list.\n        Each node contains an integer payload, a 'next' reference,\n        and a 'prev' reference.\n        \"\"\"\n        def __init__(self, data=0, prev=None, next=None):\n            self.data = data\n            self.prev = prev\n            self.next = next\n\n    def build_doubly_linked_list(data_list):\n        \"\"\"\n        Constructs a doubly linked list from a Python list of integers.\n\n        Args:\n            data_list: A list of integers.\n\n        Returns:\n            A tuple (head, tail) representing the head and tail nodes\n            of the newly created list. Returns (None, None) for an empty list.\n        \"\"\"\n        if not data_list:\n            return None, None\n\n        # Create the head node\n        head = Node(data=data_list[0])\n        previous_node = head\n\n        # Create subsequent nodes and link them\n        for i in range(1, len(data_list)):\n            new_node = Node(data=data_list[i], prev=previous_node)\n            previous_node.next = new_node\n            previous_node = new_node\n        \n        # The last node created is the tail\n        tail = previous_node\n        return head, tail\n\n    def is_palindrome(head, tail):\n        \"\"\"\n        Determines if a doubly linked list is a palindrome.\n\n        The algorithm uses a two-pointer approach, one starting from the head and\n        one from the tail, moving towards the center and comparing node data.\n        This respects the O(n) time and O(1) space constraints.\n\n        Args:\n            head: The head node of the list.\n            tail: The tail node of the list.\n\n        Returns:\n            True if the list is a palindrome, False otherwise.\n        \"\"\"\n        # An empty list (n=0) is a palindrome by definition.\n        if head is None:\n            return True\n\n        p_head = head\n        p_tail = tail\n\n        while True:\n            # Compare data from both ends. If they differ, it's not a palindrome.\n            if p_head.data != p_tail.data:\n                return False\n\n            # Termination condition for odd-length lists: pointers meet at the center.\n            if p_head == p_tail:\n                break\n\n            # Termination condition for even-length lists: pointers are adjacent.\n            if p_head.next == p_tail:\n                break\n\n            # Move pointers towards the center.\n            p_head = p_head.next\n            p_tail = p_tail.prev\n        \n        return True\n\n    # The test suite provided in the problem statement.\n    test_cases = [\n        [1, 2, 3, 2, 1],        # Test 1\n        [4, 5, 5, 4],           # Test 2\n        [1, 2, 3, 4, 5],        # Test 3\n        [7],                    # Test 4\n        [],                     # Test 5\n        [10, -1, -1, 10],       # Test 6\n        [2, 2, 2, 2, 2, 2],     # Test 7\n        [1, 2, 2, 3, 2, 2, 1],  # Test 8\n        [1, 2],                 # Test 9\n        [0, 1, 0, 1],           # Test 10\n    ]\n\n    results = []\n    for data_list in test_cases:\n        list_head, list_tail = build_doubly_linked_list(data_list)\n        result = is_palindrome(list_head, list_tail)\n        results.append(result)\n\n    # Format and print the final output as a single string.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3229848"}, {"introduction": "除了遍历，一项关键技能是修改链表的结构。本练习要求你在一个给定节点处，将一个双向链表分割成两个独立的、有效的链表，这是许多基于列表的算法中的一项基础操作。要成功完成此任务，你需要精确地管理 `next` 和 `prev` 指针，以确保两个新链表在结构上都是完整的，尤其是在处理在头部拆分等边界情况时。[@problem_id:3229730]", "problem": "考虑一个双向链表，它由多个节点定义，其中每个节点 $u$ 包含三个字段：一个值 $u.\\text{val}$、一个后向指针 $u.\\text{prev}$ 和一个前向指针 $u.\\text{next}$。该结构必须满足以下不变式才能确保其有效性：对于任何相邻节点 $(u, v)$，若 $u.\\text{next} = v$，则必须满足 $v.\\text{prev} = u$；头节点 $h$ 必须满足 $h.\\text{prev} = \\text{None}$；尾节点 $t$ 必须满足 $t.\\text{next} = \\text{None}$。给定一个头指针 $h$ 和一个指向某个节点的指针 $p$，您必须在 $p$ 处将列表分割成两个独立的有效列表，使得左列表由从 $h$ 开始直至 $p$ 的前驱节点的连续段组成，而右列表由从 $p$ 开始直至尾节点 $t$ 的连续段组成。形式上，分割后，左列表包含从 $h$ 到 $\\text{prev}(p)$ 的节点序列，右列表包含从 $p$ 到 $t$ 的节点序列，且两个列表都各自满足双向链表的不变式。如果 $p$ 等于 $h$，则左列表为空；如果 $p$ 等于 $t$，则右列表仅包含 $t$；如果输入列表为空，或者 $p$ 不属于以 $h$ 为头节点的列表，则必须报告分割无效，且不应应用任何结构性更改。唯一允许的遍历操作是验证 $p$ 是否属于以 $h$ 为头节点的列表；所有为实现分割所需的结构性修改都必须通过常数次局部指针赋值来完成，确保修改阶段的时间复杂度为 $O(1)$。除输入存储外，内存使用量应保持为 $O(1)$。您的任务是实现一个程序，该程序构建指定的列表，尝试所描述的分割操作，验证生成的列表，并输出结果。\n\n用作推理基础的定义和要求：\n- 双向链表是一个节点序列 $(u_0, u_1, \\dots, u_{n-1})$，其中对于所有索引 $i$（$0 \\le i  n-1$），我们有 $u_i.\\text{next} = u_{i+1}$ 和 $u_{i+1}.\\text{prev} = u_i$，同时 $u_0.\\text{prev} = \\text{None}$ 且 $u_{n-1}.\\text{next} = \\text{None}$。\n- 双向链表的有效性意味着上述不变式在整个结构中都得到满足。\n- 在指针 $p$ 处的分割定义为产生两个列表 $(L_{\\text{left}}, L_{\\text{right}})$，其中 $L_{\\text{left}}$ 包含从 $h$ 开始，严格通过跟随 $.\\text{next}$ 可达的、直到节点 $\\text{prev}(p)$ 的所有节点，而 $L_{\\text{right}}$ 包含从 $p$ 开始，通过跟随 $.\\text{next}$ 可达的所有节点。\n\n程序规范：\n- 对于每个测试用例，根据给定的整数序列构建输入列表，并按位置 $k$（其中 $k$ 是从头节点开始计数的索引，从0开始）或作为一个不属于所构建列表的节点来选择指针 $p$。如上定义，在 $p$ 处尝试分割。\n- 尝试后，计算一个布尔值 $b$，表示是否发生了有效分割并且两个结果列表都满足不变式。当且仅当 $p$ 属于列表且分割后的两个结果列表都各自有效时，$b$ 的值必须为 $ \\text{True} $；否则 $b$ 必须为 $ \\text{False} $。当 $b$ 为 $ \\text{False} $ 时，左列表必须与原始列表相同，右列表必须为空。\n- 对于每个测试用例，输出一个列表 $[b, L_{\\text{left}}^{\\text{vals}}, L_{\\text{right}}^{\\text{vals}}]$，其中 $L_{\\text{left}}^{\\text{vals}}$ 和 $L_{\\text{right}}^{\\text{vals}}$ 分别是左列表和右列表中从头到尾的整数值序列。\n\n待实现的测试套件：\n- 情况 1：值为 $[2, 4, 6, 8, 10]$，在索引 $k = 2$ 处（值为 $6$ 的节点）分割。\n- 情况 2：值为 $[1, 3, 5]$，在索引 $k = 0$ 处（头节点）分割。\n- 情况 3：值为 $[7, 9, 11, 13]$，在索引 $k = 3$ 处（尾节点）分割。\n- 情况 4：值为 $[42]$，在索引 $k = 0$ 处（单元素列表）分割。\n- 情况 5：值为 $[5, 10, 15]$，使用一个指针 $p$ 分割，该指针引用自一个值为 $[99]$ 的独立列表中的节点（因此 $p$ 不属于第一个列表）。\n- 情况 6：值为 $[]$（空列表），且 $p = \\text{None}$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，每个元素按上述顺序对应一个测试用例。每个元素本身必须是 Python 列表字面量 $[b, L_{\\text{left}}^{\\text{vals}}, L_{\\text{right}}^{\\text{vals}}]$，生成形如 $[[\\dots],[\\dots],\\dots]$ 的输出。", "solution": "该问题要求在双向链表上实现分割操作，并对过程进行全面验证。我将首先验证问题陈述本身，然后着手进行算法的原则性设计及实现。\n\n### 问题验证\n\n**步骤 1：提取给定信息**\n\n- **数据结构**：双向链表由节点 $u$ 组成。每个节点包含字段 $u.\\text{val}$、$u.\\text{prev}$ 和 $u.\\text{next}$。\n- **不变式**：\n    1. 对于任何相邻节点 $(u, v)$，若 $u.\\text{next} = v$，则必须满足 $v.\\text{prev} = u$。\n    2. 头节点 $h$ 必须满足 $h.\\text{prev} = \\text{None}$。\n    3. 尾节点 $t$ 必须满足 $t.\\text{next} = \\text{None}$。\n- **输入**：指向列表的头指针 $h$ 和指向节点的指针 $p$。\n- **分割操作**：\n    - 列表被分割成两个新列表 $L_{\\text{left}}$ 和 $L_{\\text{right}}$。\n    - $L_{\\text{left}}$ 包含从 $h$ 开始，直至 $p$ 的前驱节点的连续段。形式上，即从 $h$ 到 $\\text{prev}(p)$ 的节点。\n    - $L_{\\text{right}}$ 包含从 $p$ 开始，直至尾节点 $t$ 的连续段。\n    - 如果 $p = h$，$L_{\\text{left}}$ 为空。\n- **无效分割条件**：\n    1. 输入列表为空。\n    2. 指针 $p$ 不属于以 $h$ 为头节点的列表。\n    - 在这些情况下，不应应用任何结构性更改。\n- **复杂度约束**：\n    - 结构性修改必须使用常数次局部指针赋值，从而在修改阶段实现 $O(1)$ 的时间复杂度。\n    - 允许将 $p$ 的成员资格验证作为单独的遍历步骤。\n    - 除输入存储外，内存使用量必须为 $O(1)$。\n- **程序规范**：\n    - 为每个测试用例构建列表。\n    - 尝试进行分割。\n    - 计算一个布尔值 $b$，当且仅当 $p$ 在列表中且两个结果列表都有效时，$b$ 为 $\\text{True}$。\n    - 如果 $b$ 为 $\\text{False}$，$L_{\\text{left}}$ 必须是原始列表，$L_{\\text{right}}$ 必须为空。\n    - 每个测试用例的输出：一个列表 $[b, L_{\\text{left}}^{\\text{vals}}, L_{\\text{right}}^{\\text{vals}}]$，其中 `vals` 是整数值序列。\n- **测试套件**：\n    1. 值为 $[2, 4, 6, 8, 10]$，在索引 $k=2$ 处分割。\n    2. 值为 $[1, 3, 5]$，在索引 $k=0$ 处分割。\n    3. 值为 $[7, 9, 11, 13]$，在索引 $k=3$ 处分割。\n    4. 值为 $[42]$，在索引 $k=0$ 处分割。\n    5. 值为 $[5, 10, 15]$，用来自独立列表 $[99]$ 的指针 $p$ 进行分割。\n    6. 值为 $[]$，且 $p = \\text{None}$。\n\n**步骤 2：使用提取的给定信息进行验证**\n\n根据验证标准评估问题陈述。\n\n- **有科学依据**：该问题根植于计算机科学领域，特别是数据结构和算法。双向链表、其不变式和指针操作的概念都是标准的、成熟的课题。该问题不含伪科学。\n- **适定性**：该问题是适定的。有效的双向链表的定义、分割操作以及无效分割的条件都非常精确。对于任何给定的输入 $(h, p)$，期望的输出是唯一确定的。\n- **客观性**：语言是形式化和客观的。要求是定量（例如，复杂度约束）和行为上（例如，输出格式，无效情况的处理）指定的。\n- **自包含与一致性**：问题提供了所有必要的定义、约束和测试用例。这些定义在内部是一致的。例如，修改的 $O(1)$ 时间复杂度约束与查找节点 $p$ 的 $O(n)$ 搜索被正确地区分开来。\n- **非不切实际或琐碎**：该任务是一个标准的、非琐碎的数据结构操作练习，需要仔细处理指针和边界情况（例如，在头部、尾部或单元素列表中进行分割）。它并非物理上不可行，因为它存在于计算机科学的抽象领域中。\n- **非故作高深**：要求是具体的、算法性的，而非隐喻性或哲学上空洞的。\n\n该问题没有表现出验证清单中列出的任何缺陷。\n\n**步骤 3：结论与行动**\n\n问题是有效的。我将继续提供解决方案。\n\n### 算法设计与原则\n\n解决方案围绕一个 `Node` 类和一个执行分割的主函数构建。该设计直接实现了问题陈述中概述的原则。\n\n1.  **数据表示**：定义一个 `Node` 类来表示双向链表的每个元素。它封装了整数值 $v$、指向下一个节点的指针 $n$ 和指向前一个节点的指针 $p$。此结构直接对应于字段 $u.\\text{val}$、$u.\\text{next}$ 和 $u.\\text{prev}$。\n\n2.  **列表验证**：一个关键组件是验证函数 `validate_list(head)`。此函数从 `head` 开始，系统地根据已定义的不变式检查列表。\n    - 它首先检查头部不变式：`head.prev` 必须为 `None`。\n    - 然后它从头到尾遍历列表，对每个节点 $u$，验证核心不变式：如果 $v = u.\\text{next}$，则必须有 $v.\\text{prev} = u$。\n    - 遍历确认能到达一个 `next` 为 `None` 的节点，从而隐式满足尾部不变式。\n    - 空列表（`head = None`）被认为是有效的。\n    此函数对于计算最终的布尔状态 $b$ 至关重要。\n\n3.  **分割逻辑**：核心函数 `split_list(h, p)` 实现了指定的操作并遵循严格的协议。\n    - **初始检查**：它首先处理两种导致无效分割的基本情况。如果列表为空（$h = \\text{None}$）或目标节点为空（$p = \\text{None}$），操作无法进行。问题将此定义为无效分割。\n    - **成员资格验证**：按照规定，算法必须首先验证 $p$ 是否是根植于 $h$ 的列表的成员。这是通过从 $h$ 开始的线性遍历完成的，比较对象标识（Python中的 `is` 操作符）以检查列表中的任何节点是否与 $p$ 是同一个对象。如果找不到 $p$，则分割无效。根据问题规则，原始列表 $h$ 作为“左”部分返回，空列表作为“右”部分返回。\n    - **指针操作（$O(1)$ 修改）**：如果找到 $p$，则通过常数次指针赋值执行结构性分割。设 `prev_p` 为节点 `p.prev`。\n        - 切断 `prev_p` 和 $p$ 之间的连接。将 `prev_p.next` 设置为 `None`，使 `prev_p` 成为左列表的新尾部。\n        - 切断来自 $p$ 的后向指针。将 `p.prev` 设置为 `None`，使 $p$ 成为右列表的新头部。\n    - **边界情况：在头部进行分割**：如果 $p = h$，则出现特殊情况。此时，`p.prev` 已经是 `None`，因此没有 `prev_p` 节点。左列表变为空，右列表是原始列表，现在由 `p` 正确地作为头节点，且 `p.prev = None`。\n    - **结果**：指针操作后，函数返回一个元组，包含一个表示成功的布尔值以及指向新的左、右列表的头指针。仅当成员资格检查通过时，成功布尔值才为 `True`。根据问题对 $b$ 的定义，对*结果*列表的更严格验证由调用函数处理。\n\n4.  **测试用例执行**：主函数 `solve` 负责为给定的测试套件协调整个过程。\n    - 对于每种情况，它从一个值序列构建初始双向链表。\n    - 它根据测试用例的规范（通过索引或提供外部节点）来识别节点 $p$。\n    - 它调用 `split_list` 函数。\n    - 根据返回的标志和指针，它随后执行最终的验证步骤：它对生成的左、右子列表都调用 `validate_list`。最终状态 $b$ 是初始分割可能性与两个结果列表均有效的逻辑与。\n    - 最后，它将结果格式化为 $[b, L_{\\text{left}}^{\\text{vals}}, L_{\\text{right}}^{\\text{vals}}]$，并聚合所有测试用例的结果以供最终输出。这种关注点分离——分割逻辑与最终验证——确保了实现精确匹配问题对 $b$ 的定义。\n\n这种有原则的、分步走的方法确保了问题陈述中的所有约束和定义都以逻辑和算法的严谨性得到满足。", "answer": "```python\nimport numpy as np  # Environment specified, though not used in algorithm.\n\nclass Node:\n    \"\"\"\n    Represents a node in a doubly linked list.\n    Each node u contains u.val, u.next, and u.prev.\n    \"\"\"\n    def __init__(self, value, prev_node=None, next_node=None):\n        self.val = value\n        self.prev = prev_node\n        self.next = next_node\n\ndef build_list_from_sequence(seq):\n    \"\"\"Constructs a doubly linked list from a sequence of values.\"\"\"\n    if not seq:\n        return None\n    \n    head = Node(seq[0])\n    current = head\n    for val in seq[1:]:\n        new_node = Node(val, prev_node=current)\n        current.next = new_node\n        current = new_node\n    return head\n\ndef get_list_values(head):\n    \"\"\"Traverses a doubly linked list and returns its values.\"\"\"\n    if not head:\n        return []\n    \n    values = []\n    current = head\n    while current:\n        values.append(current.val)\n        current = current.next\n    return values\n\ndef get_node_at_index(head, k):\n    \"\"\"Retrieves the node at a specific index k from the head.\"\"\"\n    if k  0:\n        return None\n    current = head\n    i = 0\n    while current and i  k:\n        current = current.next\n        i += 1\n    return current\n\ndef validate_list(head):\n    \"\"\"\n    Validates a doubly linked list against its invariants.\n    1. h.prev must be None.\n    2. For u.next = v, it must be that v.prev = u.\n    3. The last node t must have t.next = None.\n    \"\"\"\n    if head is None:\n        return True  # An empty list is valid.\n\n    # Check head invariant\n    if head.prev is not None:\n        return False\n    \n    current = head\n    while current.next is not None:\n        next_node = current.next\n        # Check forward-backward consistency\n        if next_node.prev is not current:\n            return False\n        current = next_node\n\n    # The loop terminates when current.next is None, satisfying the tail invariant.\n    return True\n\ndef split_list(h, p):\n    \"\"\"\n    Attempts to split the list at node p.\n    Returns (split_possible, left_head, right_head).\n    \"\"\"\n    original_h = h\n    \n    if h is None or p is None:\n        # Invalid split if list is empty or p is None.\n        return (False, original_h, None)\n\n    # 1. Verify that p is in the list rooted at h.\n    current = h\n    found = False\n    while current:\n        if current is p:\n            found = True\n            break\n        current = current.next\n    \n    if not found:\n        # p is not in the list.\n        return (False, original_h, None)\n\n    # 2. Perform the O(1) split operation.\n    left_head = h\n    right_head = p\n    \n    prev_p = p.prev\n    \n    if prev_p is not None:\n        # p is not the head, so we sever the link.\n        prev_p.next = None\n    else:\n        # p is the head, so the left list becomes empty.\n        left_head = None\n        \n    p.prev = None\n    \n    return (True, left_head, right_head)\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and produce the final output.\n    \"\"\"\n    # Test Suite Definition\n    test_cases_spec = [\n        {\"vals\": [2, 4, 6, 8, 10], \"k\": 2},\n        {\"vals\": [1, 3, 5], \"k\": 0},\n        {\"vals\": [7, 9, 11, 13], \"k\": 3},\n        {\"vals\": [42], \"k\": 0},\n        {\"vals\": [5, 10, 15], \"p_external\": Node(99)},\n        {\"vals\": [], \"p_external\": None}\n    ]\n\n    results = []\n\n    for case in test_cases_spec:\n        vals = case[\"vals\"]\n        head = build_list_from_sequence(vals)\n        \n        # Determine the pointer p for the split\n        if \"k\" in case:\n            p = get_node_at_index(head, case[\"k\"])\n        else:\n            p = case.get(\"p_external\")\n            \n        # Attempt the split\n        split_possible, left_head, right_head = split_list(head, p)\n        \n        # Validate the resulting lists\n        left_list_valid = validate_list(left_head)\n        right_list_valid = validate_list(right_head)\n        \n        # Determine final boolean b as per problem statement\n        b = split_possible and left_list_valid and right_list_valid\n        \n        # Per problem specification for invalid splits (b=False)\n        if not b:\n            if split_possible:\n                # If split occurred but was invalid, we must revert.\n                # A robust solution would re-link, but the problem's output format\n                # for b=False is defined based on the original list.\n                # Re-constructing the original state for output is simpler.\n                final_left_head = build_list_from_sequence(vals)\n                final_right_head = None\n            else:\n                final_left_head = left_head # Unmodified original list head\n                final_right_head = right_head # Should be None\n        else:\n            final_left_head = left_head\n            final_right_head = right_head\n\n        left_vals = get_list_values(final_left_head)\n        right_vals = get_list_values(final_right_head)\n        \n        results.append(f\"[{b}, {left_vals}, {right_vals}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3229730"}]}