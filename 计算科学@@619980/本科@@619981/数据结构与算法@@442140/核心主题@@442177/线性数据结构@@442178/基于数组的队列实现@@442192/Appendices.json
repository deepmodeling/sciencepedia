{"hands_on_practices": [{"introduction": "这个基础练习将指导你从零开始构建一个功能完备且可动态调整大小的循环队列。通过这个实践，你将掌握使用模运算处理循环索引的核心技巧，并理解动态调整数组大小以实现摊销 $O(1)$ 时间复杂度的重要性。这是掌握基于数组的队列实现的关键一步。[@problem_id:3209149]", "problem": "设计并实现一个使用循环、可调整大小数组的先进先出队列，该队列可以存储任意数据类型的元素。设计的核心必须遵循队列的基本定义和数组索引上的模运算。具体来说，使用以下基本原理：队列是一种强制执行先进先出顺序的抽象数据类型，循环缓冲区索引通过将索引 $i$ 替换为 $(i+1) \\pmod{C}$ 来推进索引，其中 $C$ 是底层数组的当前容量。\n\n实现要求：\n- 维护一个当前容量为 $C$ 的数组、一个头索引 $h$、一个尾索引 $t$ 以及一个大小 $s$（元素数量）。头索引 $h$ 指向队列逻辑前端的位置，尾索引 $t$ 指向下一个元素将被插入的位置。\n- 入队操作：在插入新元素之前，如果 $s = C$，则分配一个容量为 $2C$ 的新数组，并按逻辑顺序从索引 $0$ 开始复制当前的 $s$ 个元素。复制后，设置 $h \\leftarrow 0$ 和 $t \\leftarrow s$，然后将新元素插入索引 $t$ 处，推进 $t \\leftarrow (t+1) \\pmod{C}$，并将大小增加 $s \\leftarrow s+1$。\n- 出队操作：移除并返回索引 $h$ 处的队首元素，清除该槽位，推进 $h \\leftarrow (h+1) \\pmod{C}$，并减小大小 $s \\leftarrow s-1$。移除后，如果 $s \\le \\lfloor C/4 \\rfloor$ 且 $C$ 严格大于初始容量 $C_0$，则分配一个容量为 $\\max(C_0, \\lfloor C/2 \\rfloor)$ 的新数组，按逻辑顺序从索引 0 开始复制 $s$ 个元素，并设置 $h \\leftarrow 0$，$t \\leftarrow s$。\n- 永远不要将容量缩减到初始容量 $C_0$ 以下。假设没有任何操作会尝试从空队列中出队或查看元素。\n- 实现必须在逻辑上是通用的：它必须保持任意元素的顺序，并且不得依赖于特定数据类型的操作。在静态类型语言中，这通过模板或泛型自然实现；在动态类型语言中，通过不限制元素类型来达到相同的行为。\n\n正确性要求：\n- 保持不变量，即在任何有限的操作序列之后，队列的逻辑内容与已入队但尚未出队的元素序列完全相同，且顺序一致；头索引 $h$ 始终指示当前队首的位置（当 $s > 0$ 时）；尾索引 $t$ 始终指示最后一个元素之后紧邻的位置。所有操作在发生大小调整时的最坏情况时间复杂度必须为 $O(C)$，否则为 $O(1)$，在任何 $m$ 次操作序列上的均摊时间复杂度为 $O(1)$。\n\n您的程序必须实现此队列并运行以下测试套件。对于每个测试，计算指定的整数或浮点数结果。\n\n测试用例 A（整数的环绕和增长）：\n- 参数：初始容量 $C_0 = 4$。\n- 操作顺序：入队 $10$，入队 $20$，入队 $30$，出队，出队，入队 $40$，入队 $50$，入队 $60$，入队 $70$。\n- 此测试的要求结果：一个列表 $[s, C, f, S_{\\text{dq}}]$，其中 $s$ 是最终大小，$C$ 是最终容量，$f$ 是最终队首元素，$S_{\\text{dq}}$ 是此测试中所有出队值的总和。\n\n测试用例 B（整数的增长后收缩）：\n- 参数：初始容量 $C_0 = 2$。\n- 操作顺序：将整数 $0,1,2,\\dots,15$（含）入队，然后执行恰好 $13$ 次出队操作。\n- 此测试的要求结果：一个如上所述的列表 $[s, C, f, S_{\\text{dq}}]$，其中 $f$ 是最后一次出队后的当前队首元素，$S_{\\text{dq}}$ 是所有出队整数的总和。\n\n测试用例 C（字符串的增长和收缩；按长度聚合）：\n- 参数：初始容量 $C_0 = 3$。\n- 操作顺序：将字符串 \"x\", \"yy\", \"zzz\", \"wwww\" 入队，然后出队两次，再入队 \"vv\"，再入队 \"u\"，然后重复出队直到队列为空。\n- 此测试的要求结果：一个列表 $[s, C, L]$，其中 $s$ 是最终大小，$C$ 是最终容量，$L$ 是此测试期间所有出队字符串的长度总和。\n\n测试用例 D（浮点数的环绕，无增长）：\n- 参数：初始容量 $C_0 = 5$。\n- 操作顺序：入队 $1.5$，入队 $2.5$，入队 $3.5$，出队一次，入队 $4.5$，入队 $5.5$，出队两次，入队 $6.5$，入队 $7.5$，入队 $8.5$。\n- 此测试的要求结果：一个列表 $[s, C, f, S_{\\text{dq}}]$，其中 $s$ 是最终大小，$C$ 是最终容量，$f$ 是最终队首元素，$S_{\\text{dq}}$ 是所有出队值的总和（作为浮点数）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试的结果，形式为一个用方括号括起来的逗号分隔列表。每个测试结果本身也必须显示为用方括号括起来的逗号分隔列表。例如，整体形式必须是 $[[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$，不含任何额外文本。此问题不涉及物理单位、角度或百分比。", "solution": "该问题要求使用可调整大小的循环数组来设计和实现一个先进先出（FIFO）队列。其设计必须源于数据结构和模运算的基本原理。\n\n### 基于原理的设计\n\n**1. 队列抽象数据类型（ADT）**\n队列是一种由其行为定义的抽象数据类型：它存储一个元素集合，并强制执行先进先出（FIFO）的访问策略。元素通过 `enqueue` 操作从一端（“尾部”或“后端”）添加，并通过 `dequeue` 操作从另一端（“头部”或“前端”）移除。这种严格的顺序是指导设计的核心原则。\n\n**2. 基于数组的实现与循环索引**\n一个简单的数组可用于存储队列的元素。一种朴素的实现方式可能是在每次 `dequeue` 操作时将所有元素向左移动一个位置，以保持队首在索引 $0$ 处。然而，这会导致 `dequeue` 的时间复杂度为 $O(s)$（其中 $s$ 是元素数量），效率低下。\n\n为了实现常数时间 $O(1)$ 操作，我们将数组视为一个循环缓冲区。这通过使用模运算来完成。我们维护两个索引：一个指向第一个逻辑元素的头索引 $h$，和一个指向下一个可用槽位的尾索引 $t$。当索引前进超过数组末尾（容量为 $C-1$ 时）时，它会“环绕”到开头（$0$）。这在数学上表示为将索引 $i$ 推进到 $(i+1) \\pmod{C}$。通过这种方案，`enqueue` 和 `dequeue` 操作仅涉及更新 $h$ 或 $t$ 索引，从而实现 $O(1)$ 的时间复杂度。为了区分满队列和空队列（这两种情况都可能在 $h=t$ 时发生），我们显式地维护一个大小计数器 $s$。`enqueue` 操作会增加 $s$，而 `dequeue` 操作会减少它。如果 $s=0$，则队列为空；如果 $s=C$，则队列为满。\n\n**3. 动态调整大小与均摊分析**\n固定容量的数组具有局限性。为了支持任意数量的元素，底层数组必须是可调整大小的。所指定的策略是一种常见且高效的策略：\n- **增长（当 `enqueue` 时 $s=C$）：** 容量加倍（$C \\to 2C$）。分配一个更大的新数组。将旧数组中现有的 $s$ 个元素（可能呈环绕分布）按其逻辑顺序复制到新数组中，从索引 $0$ 开始。然后将头尾索引重置为 $h \\leftarrow 0$ 和 $t \\leftarrow s$。\n- **收缩（当 `dequeue` 时 $s \\le \\lfloor C/4 \\rfloor$）：** 为了节省内存，如果数组的占用率降至其容量的四分之一或更少，则数组会收缩。容量减半（$C \\to \\lfloor C/2 \\rfloor$），但有约束条件，即永远不会低于初始容量 $C_0$。复制和索引重置过程与增长时相同。\n\n虽然单次触发大小调整的 `enqueue` 或 `dequeue` 操作需要与当前容量成正比的时间，即 $O(C)$，但这些事件并不频繁。调整大小的成本在操作序列上被均摊。在增长到容量 $2C$ 之后，至少需要再进行 $C$ 次 `enqueue` 操作才会发生下一次增长。同样，在收缩到容量 $C/2$ 之后，至少需要进行 $C/4$ 次 `dequeue` 操作才能触发另一次收缩。这确保了 $m$ 次操作的总工作量与 $m$ 成正比，从而使每次操作的均摊时间复杂度为 $O(1)$。\n\n**4. 实现结构**\n该实现将此逻辑封装在一个类中。该类维护状态变量：数据数组、当前容量 $C$、初始容量 $C_0$、头索引 $h$、尾索引 $t$ 和大小 $s$。\n在调整大小期间复制元素的方法（`_resize`）至关重要。它必须按其逻辑 FIFO 顺序遍历元素，从旧数组中的物理索引 $h$ 开始，并使用模运算符进行环绕，然后将它们放入新数组的前 $s$ 个位置。具体来说，第 $k$ 个逻辑元素（其中 $k \\in \\{0, 1, \\dots, s-1\\}$）位于物理索引 $(h+k) \\pmod{C_{\\text{old}}}$ 处，并被复制到新数组的索引 $k$ 处。\n\n此设计在逻辑上是通用的，因为它除了存储和检索之外，不对元素本身执行任何操作。因此，它按要求保持了任意数据类型元素的完整性和顺序。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests the ResizableCircularQueue as per the problem statement.\n    \"\"\"\n\n    class ResizableCircularQueue:\n        \"\"\"\n        A FIFO queue implemented with a resizable, circular numpy array.\n        \"\"\"\n        def __init__(self, initial_capacity: int):\n            \"\"\"\n            Initializes an empty queue with a given initial capacity.\n            \"\"\"\n            if initial_capacity  1:\n                raise ValueError(\"Initial capacity must be at least 1.\")\n            self._C0 = initial_capacity\n            self._C = self._C0\n            # dtype=object allows storing elements of any type.\n            self._data = np.full(self._C, None, dtype=object)\n            self._h = 0  # Head index (points to the front element)\n            self._t = 0  # Tail index (points to the next available slot)\n            self._s = 0  # Number of elements in the queue\n\n        @property\n        def size(self) -> int:\n            \"\"\"Returns the number of elements in the queue.\"\"\"\n            return self._s\n\n        @property\n        def capacity(self) -> int:\n            \"\"\"Returns the current capacity of the underlying array.\"\"\"\n            return self._C\n        \n        def get_front(self):\n            \"\"\"Returns the front element of the queue without removing it.\"\"\"\n            if self.size == 0:\n                # Per problem statement, this will not be called on an empty queue.\n                return None\n            return self._data[self._h]\n\n        def _resize(self, new_capacity: int):\n            \"\"\"\n            Resizes the underlying array to new_capacity and copies elements.\n            \"\"\"\n            old_data = self._data\n            old_capacity = self._C\n            \n            self._data = np.full(new_capacity, None, dtype=object)\n            \n            # Copy elements from the old (circular) array to the new (linear) one.\n            walk = self._h\n            for k in range(self._s):\n                self._data[k] = old_data[walk]\n                walk = (walk + 1) % old_capacity\n            \n            # Reset indices and update capacity\n            self._C = new_capacity\n            self._h = 0\n            self._t = self._s\n\n        def enqueue(self, element):\n            \"\"\"\n            Adds an element to the tail of the queue.\n            \"\"\"\n            if self._s == self._C:\n                # Grow array if it is full.\n                self._resize(2 * self._C)\n            \n            self._data[self._t] = element\n            self._t = (self._t + 1) % self._C\n            self._s += 1\n\n        def dequeue(self):\n            \"\"\"\n            Removes and returns the element from the head of the queue.\n            Assumes the queue is not empty, as per problem statement.\n            \"\"\"\n            element = self._data[self._h]\n            self._data[self._h] = None  # Clear the slot\n            self._h = (self._h + 1) % self._C\n            self._s -= 1\n            \n            # Shrink array if it is sparsely populated, but not below C0.\n            if self._s = self._C // 4 and self._C > self._C0:\n                new_capacity = max(self._C0, self._C // 2)\n                self._resize(new_capacity)\n\n            return element\n\n    # --- Test Cases ---\n    all_results = []\n\n    # Test Case A\n    q_a = ResizableCircularQueue(initial_capacity=4)\n    dequeued_vals_a = []\n    q_a.enqueue(10)\n    q_a.enqueue(20)\n    q_a.enqueue(30)\n    dequeued_vals_a.append(q_a.dequeue())\n    dequeued_vals_a.append(q_a.dequeue())\n    q_a.enqueue(40)\n    q_a.enqueue(50)\n    q_a.enqueue(60)\n    q_a.enqueue(70)\n    result_a = [q_a.size, q_a.capacity, q_a.get_front(), sum(dequeued_vals_a)]\n    all_results.append(result_a)\n\n    # Test Case B\n    q_b = ResizableCircularQueue(initial_capacity=2)\n    dequeued_vals_b = []\n    for i in range(16):\n        q_b.enqueue(i)\n    for _ in range(13):\n        dequeued_vals_b.append(q_b.dequeue())\n    result_b = [q_b.size, q_b.capacity, q_b.get_front(), sum(dequeued_vals_b)]\n    all_results.append(result_b)\n\n    # Test Case C\n    q_c = ResizableCircularQueue(initial_capacity=3)\n    dequeued_vals_c = []\n    q_c.enqueue(\"x\")\n    q_c.enqueue(\"yy\")\n    q_c.enqueue(\"zzz\")\n    q_c.enqueue(\"wwww\")\n    dequeued_vals_c.append(q_c.dequeue())\n    dequeued_vals_c.append(q_c.dequeue())\n    q_c.enqueue(\"vv\")\n    q_c.enqueue(\"u\")\n    while q_c.size > 0:\n        dequeued_vals_c.append(q_c.dequeue())\n    L_c = sum(len(s) for s in dequeued_vals_c)\n    result_c = [q_c.size, q_c.capacity, L_c]\n    all_results.append(result_c)\n    \n    # Test Case D\n    q_d = ResizableCircularQueue(initial_capacity=5)\n    dequeued_vals_d = []\n    q_d.enqueue(1.5)\n    q_d.enqueue(2.5)\n    q_d.enqueue(3.5)\n    dequeued_vals_d.append(q_d.dequeue())\n    q_d.enqueue(4.5)\n    q_d.enqueue(5.5)\n    dequeued_vals_d.append(q_d.dequeue())\n    dequeued_vals_d.append(q_d.dequeue())\n    q_d.enqueue(6.5)\n    q_d.enqueue(7.5)\n    q_d.enqueue(8.5)\n    f_d = q_d.get_front()\n    # Ensure float precision is handled correctly for output\n    S_dq_d = float(sum(dequeued_vals_d))\n    result_d = [q_d.size, q_d.capacity, f_d, S_dq_d]\n    all_results.append(result_d)\n\n    # Format the final output string exactly as specified.\n    results_str_list = []\n    for res in all_results:\n        # Convert each item in a result list to string\n        res_items_as_str = [str(item) for item in res]\n        # Join items with a comma and enclose in brackets\n        results_str_list.append(f\"[{','.join(res_items_as_str)}]\")\n    \n    # Join all test case results with a comma and enclose in brackets\n    final_output = f\"[{','.join(results_str_list)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3209149"}, {"introduction": "在掌握了基础队列的实现后，这个实践将引导你处理一个更复杂的真实场景：呼叫中心的优先客户。你将通过实现一个 `enqueue_front`（队头入队）操作，将标准队列升级为双端队列（deque），从而赋予其处理“插队”的能力。这个练习旨在展示如何根据应用需求扩展和改造现有数据结构。[@problem_id:3208994]", "problem": "实现一个基于数组的队列，该队列使用循环缓冲区来模拟呼叫中心的等待队列，然后修改它以支持在队首插入“优先客户”。所需的操作是：标准到达时在队尾入队，优先到达时在队首入队，以及为提供服务而从队首出队。实现必须基于数组（不使用链式结构），维持一个循环布局，并在数组满时、下一次插入之前，通过将其容量加倍来自动调整底层数组的大小。目标是从队列的抽象定义和数组索引上的模运算性质推导出这些操作的正确性和复杂性，并通过一个固定的测试套件来验证其行为。\n\n使用以下基本原理：\n- 队列是一种抽象数据类型，由先进先出（FIFO）原则定义，意味着在队列中时间最长的项目将首先被服务。\n- 数组支持通过索引进行常数时间的随机访问。\n- 数组上的循环布局使用模运算；如果头索引是 $h$，尾索引是 $t$，容量是 $C$，那么前进一个位置对应于加上 $1$ 再对 $C$ 取模。具体来说，是 $i \\mapsto (i+1) \\pmod{C}$。\n- 通过分配一个大小为 $2C$ 的新数组并按逻辑顺序 $0,1,2,\\dots$ 复制现有项目来调整数组大小，可以保持项目顺序，并实现每次插入的摊销常数时间。\n\n你的任务：\n- 设计并实现一个基于数组的队列，该队列使用带有动态调整大小功能的循环缓冲区，并支持以下操作：\n  - 标准到达 `enqueue_back`：在队尾附加客户标识符 $x$。\n  - 优先到达 `enqueue_front`：在队首插入客户标识符 $x$。\n  - 服务 `dequeue_front`：移除并返回队首的标识符；如果队列为空，则该服务步骤不返回任何标识符。\n- 维护索引 $h$（头）、$t$（尾）、大小 $s$ 和容量 $C$，使得项目的逻辑顺序位于位置 $(h + k) \\pmod{C}$ 上，其中 $k \\in \\{0,1,\\dots,s-1\\}$。\n- 当向一个满的缓冲区（其中 $s = C$）插入时，首先通过将 $s$ 个项目按顺序重新定位到位置 $0,1,\\dots,s-1$ 来将容量调整为 $2C$，然后执行待处理的插入操作。不要缩小缓冲区。\n\n事件模型：\n- 每个测试用例包含一个初始容量 $C$ 和一个由三种事件组成的序列：\n  - 标准到达 $A(x)$，表示使用标识符 $x$ 执行 `enqueue_back`。\n  - 优先到达 $P(x)$，表示使用标识符 $x$ 执行 `enqueue_front`。\n  - 服务 $S(k)$，表示执行 `dequeue_front` 最多 $k$ 次；如果可服务的客户少于 $k$ 个，则服务所有可用的客户。收集测试用例中所有 $S(k)$ 事件服务的所有标识符序列，并按顺序排列。\n\n要求输出：\n- 对于每个测试用例，程序必须按顺序输出一个由整数组成的列表，该列表包含所有被服务的标识符。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个结果本身也是一个列表，并且列表打印时不能有空格，例如：$[[1,2],[3],[4,5,6]]$。\n\n测试套件：\n- 请精确使用以下五个测试用例。每个测试用例是一个序对 $(C, \\text{events})$，其中 $C$ 是初始容量，$\\text{events}$ 是有限的事件序列。\n  - 测试 $1$：$C = 4$，事件 $[A(1), A(2), A(3), S(2), A(4), P(99), S(3)]$。\n  - 测试 $2$：$C = 3$，事件 $[S(1), P(5), S(2), S(1)]$。\n  - 测试 $3$：$C = 5$，事件 $[A(10), A(11), A(12), A(13), S(3), A(14), A(15), A(16), P(7), S(4)]$。\n  - 测试 $4$：$C = 2$，事件 $[A(1), A(2), P(3), A(4), A(5), S(5)]$。\n  - 测试 $5$：$C = 4$，事件 $[P(1), P(2), P(3), A(4), A(5), S(5)]$。\n\n注意和约束：\n- 所有客户标识符和 $k$ 值均为非负整数。\n- 正确性必须源于队列的抽象定义和附加优先操作的语义，并通过模运算更新索引。确保在不调整大小的情况下，`enqueue_front` 和 `enqueue_back` 的运行时间均为 $O(1)$，并且调整大小操作在任意 $n$ 次插入序列上能产生每次插入摊销 $O(1)$ 的时间复杂度。\n- 程序必须是完全自包含的，无需用户输入或外部文件即可产生所需的单行输出。", "solution": "问题陈述是有效的。它在数据结构与算法领域提出了一个明确定义的任务，该任务基于既定的计算机科学原理。问题是自包含的、客观的，并且其要求在内部是一致且可形式化的。\n\n核心任务是使用支持动态调整大小的循环数组实现一个双端队列（deque）。该双端队列必须提供三个操作：`enqueue_back`（标准追加）、`enqueue_front`（优先前置）和 `dequeue_front`（服务）。解决方案必须通过一个特定的测试套件进行验证。\n\n该实现将被封装在一个类中，我们可以将其命名为 `CircularDeque`。该类将通过四个主要属性来管理队列的状态：\n- 一个底层的 `numpy` 数组 `data`，用于存储队列元素。\n- 该数组的容量 $C$，我们称之为 `capacity`。\n- 队列中第一个元素的索引 $h$，我们称之为 `head`。\n- 队列中当前元素的数量 $s$，我们称之为 `size`。\n\n空队列由 $s=0$ 定义。满队列由 $s=C$ 定义。问题陈述还提到了一个尾索引 $t$。该索引不是一个独立的状态变量，而是可以从其他变量派生出来。它指向队列尾部的第一个可用位置，由 $t = (h+s) \\pmod{C}$ 给出。我们将使用 $h$ 和 $s$ 作为管理队列结构的主要状态变量。\n\n队列中元素的逻辑序列（索引从 $0$ 到 $s-1$）通过模运算映射到物理数组索引上。第 $k$ 个逻辑元素（其中 $k \\in \\{0, 1, \\dots, s-1\\}$）存储在物理索引 $(h+k) \\pmod{C}$ 处。\n\n下面我们详细说明每个所需操作的设计。\n\n**1. 初始化 `__init__(self, capacity)`**\n该构造函数使用给定的初始容量 $C$ 初始化一个空队列。\n- `capacity` 被设置为提供的值。\n- `data` 数组被创建为一个大小为 $C$ 的 `numpy` 数组，并初始化为零。\n- `head` 索引 $h$ 初始化为 $0$。\n- `size` $s$ 初始化为 $0$。\n\n**2. `enqueue_back(self, x)`**\n此操作将元素 $x$ 添加到队列的尾部。\n- 首先，它检查队列是否已满（$s=C$）。如果是，则必须通过调用一个辅助方法 `_resize()` 来调整底层数组的大小。\n- 新元素的物理索引是尾部位置，计算公式为 $t = (h+s) \\pmod{C}$。\n- 元素 $x$ 被放置在 `data[t]`。\n- 队列的大小 $s$ 增加 $1$。\n- 当不发生大小调整时，此操作的时间复杂度为 $O(1)$。\n\n**3. `enqueue_front(self, x)`**\n此操作将一个优先元素 $x$ 添加到队列的前端。\n- 与 `enqueue_back` 类似，如果 $s=C$，它首先检查并调用 `_resize()` 处理溢出。\n- 要在队首插入，`head` 索引 $h$ 必须（循环地）向后移动一个位置。新的头索引计算为 $h' = (h - 1 + C) \\pmod{C}$。\n- `head` 更新为 $h'$。\n- 新元素 $x$ 被放置在 `data[h']`。\n- 队列的大小 $s$ 增加 $1$。\n- 当不发生大小调整时，此操作的时间复杂度也为 $O(1)$。\n\n**4. `dequeue_front(self)`**\n此操作从队列前端移除并返回元素。\n- 它首先检查队列是否为空（$s=0$）。如果是，根据问题描述，它返回一个指示符（例如 `None`），表示没有元素被服务。\n- 如果队列不为空，要返回的元素是 `data[h]`。\n- `head` 索引（循环地）向前移动一个位置：$h' = (h+1) \\pmod{C}$。\n- `head` 更新为 $h'$。\n- 队列的大小 $s$ 减少 $1$。\n- 返回取出的元素。\n- 此操作的时间复杂度始终为 $O(1)$。\n\n**5. 调整大小 `_resize(self)`**\n当 $s=C$ 时，入队操作会调用此辅助方法。\n- 新的容量 $C_{\\text{new}}$ 设置为 $2C$。\n- 分配一个容量为 $C_{\\text{new}}$ 的新 `numpy` 数组 `new_data`。\n- 关键步骤是将元素从旧数组复制到新数组。问题规定，元素应重新定位以占据新数组中的索引 $0, 1, \\dots, s-1$。这个过程“展开”了循环缓冲区。对于从 $0$ 到 $s-1$ 的每个逻辑元素 $k$：\n    - 它在旧数组中的索引是 $i_{\\text{old}} = (h+k) \\pmod{C}$。\n    - 元素 `data[i_old]` 被复制到 `new_data[k]`。\n- 复制完成后，`data` 数组被替换为 `new_data`，并且 `capacity` 更新为 $C_{\\text{new}}$。\n- 由于元素现在按其逻辑顺序位于新数组的开头，`head` 索引 $h$ 被重置为 $0$。`size` $s$ 在调整大小操作本身中保持不变。\n\n**正确性与复杂度分析**\n此设计的正确性植根于对所有索引计算一致地应用模运算，这正确地实现了缓冲区的循环特性。调整大小的过程通过将元素显式地展开到新的、更大的数组开头的线性序列中，正确地保持了FIFO顺序，并通过将 $h$ 重置为 $0$ 来简化状态。\n\n复杂度满足问题的要求。在不进行大小调整的情况下，`enqueue_front` 和 `enqueue_back` 都执行常数次算术运算和一次数组访问，使其时间复杂度为 $O(1)$。`dequeue_front` 操作的时间复杂度始终为 $O(1)$。`_resize` 操作需要 $O(C)$ 的时间，其中 $C$ 是当前容量。根据对几何增长的动态数组的标准摊销分析，这个 $O(C)$ 的成本被分摊到接下来的 $C$ 次插入中（在这种情况下，将容量从 $C$ 加倍到 $2C$ 至少允许 $C$ 次新的插入）。这使得在一长串操作序列中，每次插入操作的摊销时间复杂度为 $O(1)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass CircularDeque:\n    \"\"\"\n    An array-backed queue (deque) implemented with a circular buffer\n    and dynamic resizing.\n    \"\"\"\n    def __init__(self, capacity):\n        \"\"\"\n        Initializes the deque with a given capacity.\n        \"\"\"\n        if capacity  1:\n            raise ValueError(\"Capacity must be at least 1\")\n        self.capacity = capacity\n        # Using a numpy array of a specific dtype as required.\n        # Initializing with 0s is fine as we track size separately.\n        self.data = np.zeros(self.capacity, dtype=int)\n        self.head = 0  # Index of the front element\n        self.size = 0  # Number of elements in the deque\n\n    def _resize(self):\n        \"\"\"\n        Doubles the capacity of the deque when it is full.\n        The elements are unrolled into the new array starting from index 0.\n        \"\"\"\n        old_capacity = self.capacity\n        self.capacity *= 2\n        new_data = np.zeros(self.capacity, dtype=int)\n        \n        # Unroll the circular buffer into a linear layout in the new array\n        for k in range(self.size):\n            old_index = (self.head + k) % old_capacity\n            new_data[k] = self.data[old_index]\n        \n        self.data = new_data\n        self.head = 0\n\n    def enqueue_back(self, value):\n        \"\"\"\n        Adds an element to the back of the deque.\n        \"\"\"\n        if self.size == self.capacity:\n            self._resize()\n        \n        # Calculate the index for the new element at the tail\n        tail_index = (self.head + self.size) % self.capacity\n        self.data[tail_index] = value\n        self.size += 1\n\n    def enqueue_front(self, value):\n        \"\"\"\n        Adds an element to the front of the deque.\n        \"\"\"\n        if self.size == self.capacity:\n            self._resize()\n            \n        # Move head one step backwards (circularly)\n        self.head = (self.head - 1 + self.capacity) % self.capacity\n        self.data[self.head] = value\n        self.size += 1\n\n    def dequeue_front(self):\n        \"\"\"\n        Removes and returns the element from the front of the deque.\n        Returns None if the deque is empty.\n        \"\"\"\n        if self.size == 0:\n            return None\n        \n        value = self.data[self.head]\n        # Advance head one step forward (circularly)\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return value\n\ndef solve():\n    \"\"\"\n    Runs the full test suite as defined in the problem statement.\n    \"\"\"\n    # Test suite definition: (Initial Capacity, [Events])\n    # Events are tuples: ('A', value), ('P', value), ('S', count)\n    test_cases = [\n        (4, [('A', 1), ('A', 2), ('A', 3), ('S', 2), ('A', 4), ('P', 99), ('S', 3)]),\n        (3, [('S', 1), ('P', 5), ('S', 2), ('S', 1)]),\n        (5, [('A', 10), ('A', 11), ('A', 12), ('A', 13), ('S', 3), ('A', 14), ('A', 15), ('A', 16), ('P', 7), ('S', 4)]),\n        (2, [('A', 1), ('A', 2), ('P', 3), ('A', 4), ('A', 5), ('S', 5)]),\n        (4, [('P', 1), ('P', 2), ('P', 3), ('A', 4), ('A', 5), ('S', 5)]),\n    ]\n\n    all_results = []\n\n    for capacity, events in test_cases:\n        queue = CircularDeque(capacity)\n        served_identifiers = []\n        \n        for event_type, value in events:\n            if event_type == 'A':\n                queue.enqueue_back(value)\n            elif event_type == 'P':\n                queue.enqueue_front(value)\n            elif event_type == 'S':\n                for _ in range(value):\n                    served = queue.dequeue_front()\n                    if served is not None:\n                        served_identifiers.append(served)\n        \n        all_results.append(served_identifiers)\n\n    # Format the final output string as per the problem requirements.\n    # e.g., [[1,2,99,3,4],[5],[10,11,12,7,13,14,15],[3,1,2,4,5],[3,2,1,4,5]]\n    result_strings = []\n    for res_list in all_results:\n        # Create string for each inner list, e.g., \"[1,2,3]\"\n        list_str = f\"[{','.join(map(str, res_list))}]\"\n        result_strings.append(list_str)\n    \n    # Join all list strings into the final output format\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3208994"}, {"introduction": "最后的这个实践旨在展示数据结构作为高效算法构建模块的强大威力。你将使用一个功能完整的双端队列来设计一个经典的算法——回文检查器。通过这个过程，你将直观地看到，同时在队列两端进行操作如何极大地简化问题，并最终导出一个优雅的线性时间解决方案。[@problem_id:3208992]", "problem": "实现一个基于数组的双端队列（deque），并用它来设计一个高效的回文检查算法，该算法需要明确跟踪并报告前端和后端指针的相对移动。你的实现必须基于循环缓冲区（环形缓冲区），且必须提供运行时间为常数的各项操作。然后，使用该双端队列处理一小组测试字符串，并为每个测试用例返回该字符串是否是回文以及在检查过程中前端和后端指针移动的次数。\n\n基本原理和约束条件：\n- 双端队列（deque）是一个有限序列，支持在两端以常数时间进行插入和删除操作。你必须使用固定大小的数组和模运算来实现它。\n- 设容量为 $C$，前端索引为 $f$，后端索引为 $r$，当前大小为 $s$。维持不变量\n$$ s \\equiv (r - f) \\pmod{C}, \\quad \\text{with } 0 \\le s  C. $$\n- 使用标准的循环缓冲区规则，将元素存储在从索引 $f$ 到索引 $(r-1)$（模 $C$）的连续环绕段中。后端索引 $r$ 始终表示最后一个元素之后的一个位置，而当 $s > 0$ 时，前端索引 $f$ 表示第一个元素的位置。\n- 为避免满状态和空状态之间的歧义，始终保留一个数组槽位未使用。因此，当插入 $n$ 个元素时，选择 $C = n + 1$，这保证了 $s \\le n  C$。\n- 定义以下操作及其对索引和大小的规定效果：\n  - push_back：在索引 $r$ 处存储，然后更新 $r \\leftarrow (r + 1) \\pmod{C}$，以及 $s \\leftarrow s + 1$。\n  - push_front：更新 $f \\leftarrow (f - 1 + C) \\pmod{C}$，在索引 $f$ 处存储，以及 $s \\leftarrow s + 1$。\n  - pop_front：读取索引 $f$ 处的值，更新 $f \\leftarrow (f + 1) \\pmod{C}$，以及 $s \\leftarrow s - 1$。\n  - pop_back：更新 $r \\leftarrow (r - 1 + C) \\pmod{C}$，读取索引 $r$ 处的值，以及 $s \\leftarrow s - 1$。\n  - peek_front：当 $s > 0$ 时，读取索引 $f$ 处的值。\n  - peek_back：当 $s > 0$ 时，读取索引 $(r - 1 + C) \\pmod{C}$ 处的值。\n- 对于长度为 $n$ 的字符串，回文检查必须按以下步骤进行：\n  - 初始化一个容量为 $C = n + 1$ 的空双端队列。\n  - 使用 `push_back` 从左到右推入字符串的字符。\n  - 使用 `peek_front` 和 `peek_back` 重复比较首尾字符。如果相等，则使用 `pop_front` 和 `pop_back` 删除两者；否则，停止。设 $m_f$ 是成功执行的 `pop_front` 操作次数，$m_r$ 是成功执行的 `pop_back` 操作次数。\n  - 当且仅当所有首尾比较都成功，直到 $s \\le 1$ 时，该字符串才是回文。当字符串是回文时，成功移除的配对数量为 $m_f = m_r = \\left\\lfloor \\frac{n}{2} \\right\\rfloor$；当它不是回文时，过程在第一次不匹配时停止，此时 $m_f = m_r = t$，其中 $t$ 是不匹配前成功匹配的对数。\n\n算法目标和要求：\n- 从环形缓冲区不变量 $s \\equiv (r - f) \\pmod{C}$ 以及对 $f$、$r$ 和 $s$ 的操作效果推导出算法。\n- 通过将匹配移除与指针移动计数 $m_f$ 和 $m_r$ 联系起来，并将停止条件 $s \\le 1$ 与回文性联系起来，来论证其正确性。\n- 时间复杂度必须与字符串长度 $n$ 呈线性关系，每个双端队列操作的均摊时间为 $O(1)$。\n\n你必须实现并运行的测试套件：\n- 按此顺序使用以下固定的测试字符串集：\n  - \"racecar\"\n  - \"abccba\"\n  - \"abca\"\n  - \"\" (空字符串)\n  - \"x\"\n  - \"ab\"\n\n对于每个测试字符串，程序必须计算并返回一个包含四项的列表：\n- 一个布尔值，指示字符串是否为回文。\n- 整数 $m_f$，即检查期间因 `pop_front` 导致前端指针前进的次数。\n- 整数 $m_r$，即检查期间因 `pop_back` 导致后端指针后退的次数。\n- 进程停止时双端队列中剩余的整数 $s$。\n\n最终输出格式：\n- 你的程序应该生成单行输出，包含所有测试用例的结果，形式为用方括号括起来的逗号分隔列表，其中每个元素本身是针对一个测试用例的四个值 $[b, m_f, m_r, s]$ 的列表。用符号表示，所需的格式为\n  $$ [[b_1, m_{f,1}, m_{r,1}, s_1], [b_2, m_{f,2}, m_{r,2}, s_2], \\ldots, [b_k, m_{f,k}, m_{r,k}, s_k]] $$\n  对于指定的测试套件，$k=6$。该行必须只包含此方括号结构和逗号，不得有任何附加文本。\n\n单位和角度：\n- 不涉及物理量或角度；无需指定单位。\n\n答案类型：\n- 所有输出均为布尔值和整数，满足返回布尔值、整数、浮点数或这些类型的列表的要求。", "solution": "该问题是有效的，因为它为在计算机科学领域内实现一个数据结构和算法提供了完整、一致且可形式化的规范。所有术语都有明确的定义，并且该任务是数据结构和算法领域一个标准的、可验证的练习。\n\n解决方案分两个阶段进行。首先，我们严格遵守所提供的规范，设计并实现一个基于循环数组的双端队列（deque）。其次，我们使用这个双端队列来构建指定的回文检查算法。\n\n### 第 1 部分：使用循环缓冲区实现双端队列\n\n双端队列使用固定大小的数组实现，该数组充当循环缓冲区。双端队列的状态由四个部分定义：容量为 $C$ 的底层数组 `_data`、一个前端指针 $f$、一个后端指针 $r$ 以及当前元素数量 $s$。\n\n**状态和不变量：**\n- 容量 $C$：数组中的最大槽位数。对于长度为 $n$ 的字符串，我们设置 $C = n + 1$，以确保至少有一个槽位始终为空，这可以防止在不单独跟踪大小 $s$ 时，满状态和空状态之间产生歧义。尽管我们确实跟踪 $s$，但我们仍将遵守此容量规则。\n- 前端索引 $f$：双端队列中第一个元素的索引。\n- 后端索引 $r$：最后一个元素*之后*的第一个可用槽位的索引。\n- 大小 $s$：双端队列中当前元素的数量，$0 \\le s  C$。\n- 关联这些变量的核心不变量是 $s \\equiv (r - f) \\pmod{C}$。\n\n最初，对于一个空的双端队列，我们设置 $f=0$，$r=0$ 和 $s=0$。此状态满足不变量，因为 $0 \\equiv (0 - 0) \\pmod{C}$。\n\n**双端队列操作：**\n每个操作的行为由其对 $f$、$r$ 和 $s$ 的影响定义。所有索引都按模 $C$ 计算。\n\n- **`push_back(item)`**：向后端添加一个元素。此操作需要空间，因此仅当 $s  C-1$ 时有效。\n    1. 检查是否已满：如果 $s = C-1$，则引发错误。\n    2. 将项目存储在当前后端位置：`_data`$[r] \\leftarrow item$。\n    3. 将后端指针前移：$r \\leftarrow (r + 1) \\pmod{C}$。\n    4. 增加大小：$s \\leftarrow s + 1$。\n    不变量得以维持：$(r_{\\text{new}} - f) \\pmod{C} \\equiv (s_{\\text{old}}+1) \\pmod{C} = s_{\\text{new}} \\pmod{C}$。\n\n- **`pop_front()`**：从前端移除并返回元素。这仅在双端队列不为空 ($s > 0$) 时有效。\n    1. 检查是否为空：如果 $s=0$，则引发错误。\n    2. 从前端位置检索项目：item $\\leftarrow$ `_data`$[f]$。\n    3. 将前端指针前移：$f \\leftarrow (f + 1) \\pmod{C}$。\n    4. 减小大小：$s \\leftarrow s - 1$。\n    不变量得以维持：$(r - f_{\\text{new}}) \\pmod{C} \\equiv (s_{\\text{old}}-1) \\pmod{C} = s_{\\text{new}} \\pmod{C}$。\n\n- **`pop_back()`**：从后端移除并返回元素。这仅在双端队列不为空 ($s > 0$) 时有效。\n    1. 检查是否为空：如果 $s=0$，则引发错误。\n    2. 将后端指针后退：$r \\leftarrow (r - 1 + C) \\pmod{C}$。加上 $C$ 可确保在模运算之前得到一个非负结果。\n    3. 从新的后端位置检索项目：item $\\leftarrow$ `_data`$[r]$。\n    4. 减小大小：$s \\leftarrow s - 1$。\n    不变量得以维持：$(r_{\\text{new}} - f) \\pmod{C} \\equiv (s_{\\text{old}}-1) \\pmod{C} = s_{\\text{new}} \\pmod{C}$。\n\n- **`peek_front()`**：返回前端元素但不移除它。当 $s > 0$ 时有效。\n    1. 检查是否为空。\n    2. 返回 `_data`$[f]$。\n\n- **`peek_back()`**：返回后端元素但不移除它。当 $s > 0$ 时有效。\n    1. 检查是否为空。\n    2. 最后一个元素位于环绕后的索引 $(r-1)$ 处。该索引计算为 $(r - 1 + C) \\pmod{C}$。\n    3. 返回 `_data`$[(r-1+C) \\pmod C]$。\n\n这些操作都涉及常数次的算术计算和数组访问，因此它们各自的时间复杂度均为 $O(1)$。\n\n### 第 2 部分：回文检查算法\n\n回文检查算法利用双端队列来高效地比较字符串首尾的字符。\n\n**算法步骤：**\n对于给定的长度为 $n$ 的输入字符串：\n1. **初始化**：创建一个容量为 $C = n + 1$ 的空双端队列。初始化两个计数器，$m_f \\leftarrow 0$ 用于记录成功的 `pop_front` 操作次数，$m_r \\leftarrow 0$ 用于记录成功的 `pop_back` 操作次数。\n2. **加载**：从左到右遍历输入字符串。对每个字符调用 `push_back` 将其添加到双端队列中。此步骤后，双端队列按顺序包含所有 $n$ 个字符，其大小为 $s=n$。\n3. **比较和移除**：进入一个循环，只要双端队列中的元素数量大于 1（即 $s > 1$），就继续执行。在每次迭代中：\n    a. 使用 `peek_front()` 和 `peek_back()` 访问双端队列两端的字符。\n    b. **如果字符匹配**：该字符串仍可能是回文。通过调用 `pop_front()` 和 `pop_back()` 移除这两个字符。将两个计数器都加一：$m_f \\leftarrow m_f + 1$ 和 $m_r \\leftarrow m_r + 1$。\n    c. **如果字符不匹配**：该字符串不是回文。过程立即终止。\n4. **结果确定**：当且仅当比较循环完成而未发现任何不匹配时，该字符串是回文。这发生在循环条件 $s > 1$ 变为假时。最终结果是：\n    - 一个布尔值，指示字符串是否为回文。\n    - 最终计数 $m_f$。\n    - 最终计数 $m_r$。\n    - 双端队列的最终大小 $s$。\n\n对于长度为 $n$ 的回文，该过程移除 $\\lfloor n/2 \\rfloor$ 对字符，导致 $m_f = m_r = \\lfloor n/2 \\rfloor$。最终大小将为 $s = n \\pmod{2}$，对于偶数 $n$ 为 0，对于奇数 $n$ 为 1。如果字符串不是回文，过程在第一次不匹配时停止，$m_f$ 和 $m_r$ 将记录不匹配前匹配的对数。\n\n**复杂度分析：**\n- 加载阶段涉及 $n$ 次 `push_back` 操作，每次耗时 $O(1)$，总计 $O(n)$。\n- 比较阶段最多运行 $\\lfloor n/2 \\rfloor$ 次。每次迭代涉及常数次的 $O(1)$ 双端队列操作。此阶段也需要 $O(n)$ 时间。\n- 因此，算法的总时间复杂度为 $O(n) + O(n) = O(n)$。空间复杂度为 $O(n)$，用于在容量为 $C = n+1$ 的双端队列中存储字符串的字符。这满足了问题的要求。", "answer": "```python\nimport numpy as np\n\nclass Deque:\n    \"\"\"\n    An array-based double-ended queue (deque) implementation using a circular buffer.\n    \n    This implementation adheres to the problem's specifications, including the\n    capacity rule C = n + 1, and the operational effects on the front (f),\n    rear (r), and size (s) attributes.\n    \"\"\"\n    def __init__(self, capacity: int):\n        \"\"\"\n        Initializes an empty deque with a given capacity.\n        _data is initialized using numpy.empty as required.\n        \"\"\"\n        if capacity  1:\n            raise ValueError(\"Capacity must be at least 1.\")\n        self._capacity = capacity\n        # The problem requires numpy. We use it here to create the array.\n        self._data = np.empty(self._capacity, dtype=object)\n        self._front = 0\n        self._rear = 0\n        self._size = 0\n\n    def __len__(self) -> int:\n        \"\"\"Returns the current number of elements in the deque.\"\"\"\n        return self._size\n\n    def is_empty(self) -> bool:\n        \"\"\"Returns True if the deque is empty, False otherwise.\"\"\"\n        return self._size == 0\n\n    def is_full(self) -> bool:\n        \"\"\"\n        Returns True if the deque is full.\n        Fullness is defined as size reaching capacity - 1, leaving one slot unused.\n        \"\"\"\n        return self._size == self._capacity - 1\n        \n    def push_back(self, item):\n        \"\"\"Adds an item to the rear of the deque.\"\"\"\n        if self.is_full():\n            raise IndexError(\"Deque is full\")\n        self._data[self._rear] = item\n        self._rear = (self._rear + 1) % self._capacity\n        self._size += 1\n\n    def pop_front(self):\n        \"\"\"Removes and returns the item from the front of the deque.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Deque is empty\")\n        item = self._data[self._front]\n        self._data[self._front] = None  # Optional: clear the slot\n        self._front = (self._front + 1) % self._capacity\n        self._size -= 1\n        return item\n\n    def pop_back(self):\n        \"\"\"Removes and returns the item from the rear of the deque.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Deque is empty\")\n        # Per problem spec: update r, then read at new r\n        self._rear = (self._rear - 1 + self._capacity) % self._capacity\n        item = self._data[self._rear]\n        self._data[self._rear] = None  # Optional: clear the slot\n        self._size -= 1\n        return item\n\n    def peek_front(self):\n        \"\"\"Returns the item at the front of the deque without removing it.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Deque is empty\")\n        return self._data[self._front]\n\n    def peek_back(self):\n        \"\"\"Returns the item at the rear of the deque without removing it.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Deque is empty\")\n        # Rear pointer r is one past the last element, so we look at (r-1)\n        idx = (self._rear - 1 + self._capacity) % self._capacity\n        return self._data[idx]\n\ndef check_palindrome(input_str: str) -> list:\n    \"\"\"\n    Checks if a string is a palindrome using the Deque data structure.\n\n    Args:\n        input_str: The string to check.\n\n    Returns:\n        A list containing:\n        - A boolean indicating if the string is a palindrome.\n        - An integer (m_f) for the number of pop_front operations.\n        - An integer (m_r) for the number of pop_back operations.\n        - An integer (s) for the final size of the deque.\n    \"\"\"\n    n = len(input_str)\n    capacity = n + 1\n    dq = Deque(capacity)\n\n    for char in input_str:\n        dq.push_back(char)\n\n    m_f = 0\n    m_r = 0\n    is_palindrome = True\n\n    while len(dq) > 1:\n        front_char = dq.peek_front()\n        back_char = dq.peek_back()\n\n        if front_char == back_char:\n            dq.pop_front()\n            dq.pop_back()\n            m_f += 1\n            m_r += 1\n        else:\n            is_palindrome = False\n            break\n            \n    final_s = len(dq)\n    return [is_palindrome, m_f, m_r, final_s]\n\ndef solve():\n    \"\"\"\n    Runs the palindrome check on the specified test suite and prints the result.\n    \"\"\"\n    test_cases = [\n        \"racecar\",\n        \"abccba\",\n        \"abca\",\n        \"\",\n        \"x\",\n        \"ab\"\n    ]\n\n    results = []\n    for s in test_cases:\n        result = check_palindrome(s)\n        results.append(result)\n\n    # Format the final output string as per the problem specification.\n    # e.g., [[True, 3, 3, 1], [True, 3, 3, 0], ...]\n    # Using str() on the list and replacing spaces to match the required format exactly.\n    output_str = str(results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "3208992"}]}