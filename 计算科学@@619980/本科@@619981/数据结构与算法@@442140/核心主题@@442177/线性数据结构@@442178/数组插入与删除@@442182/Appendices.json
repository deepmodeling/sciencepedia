{"hands_on_practices": [{"introduction": "要真正理解数组操作的成本，我们必须超越单个动作，分析在一系列操作中成本是如何累积的。第一个练习为此分析提供了一个完美的场景。我们将跟踪一个重复从排序数组中删除中位数元素直至其变空的过程，并计算所需的所有元素移动总数。通过这个练习，你将具体理解在一个迭代过程中成本是如何累加的。[@problem_id:3208574]", "problem": "一个数组以严格递增的顺序在连续的内存单元中存储了 $n$ 个不同的键，使用从0开始的索引。考虑以下过程：当数组非空时，删除下中位数元素，当数组当前长度为 $m$ 时，该元素定义为索引为 $\\left\\lfloor \\frac{m-1}{2} \\right\\rfloor$ 的元素，然后将被删除元素右侧的元素向左移动一个位置以填补空缺。\n\n只计算由这些左移操作引起的元素写操作；忽略所有比较、索引算术和任何其他操作。\n\n仅使用以下基本定义：在一个存储于连续内存的数组中，从一个长度为 $m$ 的数组中删除索引为 $i$ 的元素，会将索引为 $i+1,i+2,\\dots,m-1$ 的 $m-i-1$ 个元素精确地向左移动一个单元（每个移动的元素算作一次写操作）。请从第一性原理出发，推导出一个关于 $n$ 的封闭形式表达式，表示直到数组变空为止，整个过程执行的元素写操作的确切总数。\n\n请将您的最终结果以一个关于 $n$ 的简化解析表达式的形式给出。不需要四舍五入。", "solution": "该问题是有效的，因为它是算法分析领域内一个定义明确、自成体系且有科学依据的问题。\n\n设 $T(n)$ 为初始大小为 $n$ 的数组的总元素写操作次数。所描述的过程是迭代的。在每一步中，一个元素被删除，数组的大小减1。这个过程一直持续到数组变空。该过程涉及大小为 $m = n, n-1, n-2, \\dots, 1$ 的数组。总写操作次数是每一步执行的写操作次数之和。\n$$T(n) = \\sum_{m=1}^{n} C(m)$$\n\n根据问题描述，对于一个长度为 $m$ 的数组，索引为 $i = \\lfloor \\frac{m-1}{2} \\rfloor$ 的元素被删除。写操作的次数等于被删除元素右侧必须向左移动一个位置的元素数量。这个数量为 $m-i-1$。\n因此，单步的成本为：\n$$C(m) = m - i - 1 = m - \\left\\lfloor \\frac{m-1}{2} \\right\\rfloor - 1$$\n\n为了找到 $C(m)$ 的一个更简单的表达式，我们根据 $m$ 的奇偶性对其进行分析。\n\n情况1：$m$ 为奇数。\n设 $m = 2k+1$，其中 $k \\ge 0$ 为某个整数。\n要删除的元素的索引为 $i = \\lfloor \\frac{(2k+1)-1}{2} \\rfloor = \\lfloor \\frac{2k}{2} \\rfloor = k$。\n写操作的次数为 $C(2k+1) = m - i - 1 = (2k+1) - k - 1 = k$。\n因为 $m = 2k+1$，我们有 $k = \\frac{m-1}{2}$。因此，对于奇数 $m$，$C(m) = \\frac{m-1}{2}$。\n\n情况2：$m$ 为偶数。\n设 $m = 2k$，其中 $k \\ge 1$ 为某个整数。\n索引为 $i = \\lfloor \\frac{2k-1}{2} \\rfloor = \\lfloor k - \\frac{1}{2} \\rfloor = k-1$。\n写操作的次数为 $C(2k) = m - i - 1 = 2k - (k-1) - 1 = k$。\n因为 $m=2k$，我们有 $k = \\frac{m}{2}$。因此，对于偶数 $m$，$C(m) = \\frac{m}{2}$。\n\n我们可以使用向下取整函数将这两种情况合并成一个单一的表达式。\n如果 $m=2k+1$（奇数），$\\lfloor \\frac{m}{2} \\rfloor = \\lfloor \\frac{2k+1}{2} \\rfloor = \\lfloor k + \\frac{1}{2} \\rfloor = k$。这与 $C(m)$ 相符。\n如果 $m=2k$（偶数），$\\lfloor \\frac{m}{2} \\rfloor = \\lfloor \\frac{2k}{2} \\rfloor = k$。这也与 $C(m)$ 相符。\n因此，对于任何 $m \\ge 1$，成本由以下简化表达式给出：\n$$C(m) = \\left\\lfloor \\frac{m}{2} \\right\\rfloor$$\n\n现在我们可以通过对 $C(m)$ 从 $m=1$ 到 $n$ 求和来计算总写操作次数 $T(n)$：\n$$T(n) = \\sum_{m=1}^{n} \\left\\lfloor \\frac{m}{2} \\right\\rfloor$$\n这个和可以通过再次考虑求和上限 $n$ 的奇偶性来计算。\n\n情况1：$n$ 为偶数。\n设 $n = 2p$，其中 $p \\ge 1$ 为某个整数。\n和变为：\n$$T(2p) = \\sum_{m=1}^{2p} \\left\\lfloor \\frac{m}{2} \\right\\rfloor = \\left\\lfloor \\frac{1}{2} \\right\\rfloor + \\left\\lfloor \\frac{2}{2} \\right\\rfloor + \\left\\lfloor \\frac{3}{2} \\right\\rfloor + \\dots + \\left\\lfloor \\frac{2p}{2} \\right\\rfloor$$\n$$T(2p) = (0+1) + (1+2) + \\dots + ((p-1)+p) = 2 \\sum_{k=1}^{p-1} k + p$$\n一个更直接的方法是分组各项：\n$$T(2p) = \\sum_{k=1}^{p} \\left\\lfloor \\frac{2k-1}{2} \\right\\rfloor + \\sum_{k=1}^{p} \\left\\lfloor \\frac{2k}{2} \\right\\rfloor = \\sum_{k=1}^{p} (k-1) + \\sum_{k=1}^{p} k$$\n$$T(2p) = \\left(\\sum_{k=1}^{p} k - \\sum_{k=1}^{p} 1\\right) + \\sum_{k=1}^{p} k = 2\\sum_{k=1}^{p} k - p = 2 \\frac{p(p+1)}{2} - p = p(p+1) - p = p^2$$\n或者，$\\sum_{k=1}^{p} (k-1) = \\sum_{j=0}^{p-1} j = \\frac{(p-1)p}{2}$。\n那么 $T(2p) = \\frac{(p-1)p}{2} + \\frac{p(p+1)}{2} = \\frac{p}{2}(p-1+p+1) = \\frac{p}{2}(2p) = p^2$。\n因为 $n=2p$，我们有 $p = \\frac{n}{2}$。将其代回得到：\n$$T(n) = \\left(\\frac{n}{2}\\right)^2 = \\frac{n^2}{4} \\quad \\text{对于偶数 } n$$\n\n情况2：$n$ 为奇数。\n设 $n = 2p+1$，其中 $p \\ge 0$ 为某个整数。\n和为：\n$$T(2p+1) = \\sum_{m=1}^{2p+1} \\left\\lfloor \\frac{m}{2} \\right\\rfloor = T(2p) + \\left\\lfloor \\frac{2p+1}{2} \\right\\rfloor$$\n使用偶数情况下的结果，$T(2p) = p^2$。\n$$T(2p+1) = p^2 + \\left\\lfloor p + \\frac{1}{2} \\right\\rfloor = p^2 + p = p(p+1)$$\n因为 $n=2p+1$，我们有 $p = \\frac{n-1}{2}$。将其代回得到：\n$$T(n) = \\left(\\frac{n-1}{2}\\right)\\left(\\frac{n-1}{2} + 1\\right) = \\left(\\frac{n-1}{2}\\right)\\left(\\frac{n+1}{2}\\right) = \\frac{n^2-1}{4} \\quad \\text{对于奇数 } n$$\n\n我们已经推导出了 $n$ 为偶数和奇数时的总写操作次数：\n$$T(n) = \\begin{cases} \\frac{n^2}{4}  \\text{若 } n \\text{ 为偶数} \\\\ \\frac{n^2-1}{4}  \\text{若 } n \\text{ 为奇数} \\end{cases}$$\n这个分情况的表达式可以使用向下取整函数统一成一个单一的封闭形式。\n如果 $n$ 为偶数，比如 $n=2p$，则 $\\lfloor \\frac{n^2}{4} \\rfloor = \\lfloor \\frac{(2p)^2}{4} \\rfloor = \\lfloor \\frac{4p^2}{4} \\rfloor = p^2 = \\frac{n^2}{4}$。\n如果 $n$ 为奇数，比如 $n=2p+1$，则 $\\lfloor \\frac{n^2}{4} \\rfloor = \\lfloor \\frac{(2p+1)^2}{4} \\rfloor = \\lfloor \\frac{4p^2+4p+1}{4} \\rfloor = \\lfloor p^2+p+\\frac{1}{4} \\rfloor = p^2+p = \\frac{n^2-1}{4}$。\n在这两种情况下，结果都与公式 $T(n) = \\lfloor \\frac{n^2}{4} \\rfloor$ 相符。\n\n因此，整个过程执行的元素写操作的确切总数是一个关于 $n$ 的简化解析表达式。", "answer": "$$\\boxed{\\left\\lfloor \\frac{n^2}{4} \\right\\rfloor}$$", "id": "3208574"}, {"introduction": "在学会了如何计算一个预定义操作序列的成本之后，一个自然的问题随之而来：我们能做得更好吗？这个练习将挑战你的策略性思维。给定一组要删除的元素，执行删除的顺序会极大地影响总成本。你的任务是找到最优的删除策略，以最小化元素移动的总次数。[@problem_id:3208390]", "problem": "考虑一个长度为 $N$、索引从 $1$ 到 $N$ 的连续数组。你的任务是逐个删除那些原始索引为完全平方数的条目，即索引 $i$ 满足 $i = k^{2}$（其中 $k$ 为某个整数且 $k \\ge 1$）。在任何时候，删除当前位于位置 $j$ 的元素，需要将所有严格位于位置 $j$ 右侧的元素向左移动一个位置，每次单独的元素移动成本为 $1$ 个单位。操作不是批处理的：每次删除都是一个独立的操作，其成本是在该操作期间移动的元素数量。你可以选择执行删除操作的顺序。\n\n仅从数组删除的核心定义（即移动所有后续元素）以及每次移动成本为 $1$ 个单位这一事实出发，从第一性原理推导出完成所有删除操作的最小可能总成本（以元素移动单位衡量）。请将你的最终答案表示为一个关于 $N$ 的单一闭式解析表达式，仅使用标准算术运算符和（如果需要）向下取整函数。不需要四舍五入，最终答案必须是单个不带单位的表达式。", "solution": "用户希望我扮演一位严谨的 STEM 教授来解决这个问题。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- 一个长度为 $N$ 的数组，索引从 $1$ 到 $N$。\n- 任务：删除原始索引为完全平方数的条目，即 $i = k^2$，其中 $k$ 为任意整数且 $k \\ge 1$。\n- 删除过程：删除当前位置 $j$ 的元素会导致其右侧的所有元素向左移动一个位置。\n- 成本：一次删除的成本是移动的元素数量，每次移动成本为 $1$ 个单位。\n- 删除是顺序执行的，而不是批处理的。\n- 删除的顺序是可选的。\n- 目标：从第一性原理推导出最小可能总成本。\n- 最终答案：一个关于 $N$ 的单一闭式解析表达式，使用标准算术运算符和向下取整函数。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学基础：** 这个问题是一个明确定义的算法分析练习，具体涉及数组操作的运算成本。它完全基于数据结构和算法的原理。\n- **适定性：** 问题提供了所有必要信息。它要求在一个有限的可能删除顺序集合上最小化一个成本函数。最小值保证存在。\n- **客观性：** 问题以精确的数学和算法术语陈述，没有歧义或主观内容。\n- **其他标准：** 问题是自洽的、一致的且可形式化的。它提出了一个重要但可解的推理挑战。\n\n**步骤 3：结论和行动**\n问题有效。将提供完整解答。\n\n### 解题推导\n\n找到最小成本的过程如下：\n1.  确定要删除的元素集合。\n2.  构建单次删除操作的成本公式。\n3.  将总成本表示为删除顺序的函数。\n4.  确定使总成本最小化的最优删除顺序。\n5.  计算此最优顺序下的总成本，并将其简化为闭式表达式。\n\n设初始数组长度为 $N$。要删除的元素是那些原始索引为完全平方数的元素。这些索引是 $1^2, 2^2, 3^2, \\dots, K^2$，满足 $K^2 \\le N$。满足条件的最大整数 $K$ 是 $K = \\lfloor\\sqrt{N}\\rfloor$。我们用 $M$ 表示这个值。因此，总共有 $M = \\lfloor\\sqrt{N}\\rfloor$ 个元素要被删除。设这些原始索引按升序排列的集合为 $S = \\{s_1, s_2, \\dots, s_M\\}$，其中对于 $k \\in \\{1, 2, \\dots, M\\}$，有 $s_k = k^2$。\n\n在当前长度为 $L$ 的数组中，删除当前位置为 $j$ 的元素的成本是必须移动的元素数量。这些元素位于位置 $j+1, j+2, \\dots, L$。这样的元素数量为 $L - j$。所以成本是 $L - j$。\n\n总成本取决于这 $M$ 个元素的删除顺序。设 $\\pi$ 是集合 $\\{1, 2, \\dots, M\\}$ 的一个排列，表示删除的顺序。在第 $t$ 步（$t=1, \\dots, M$），我们删除原始索引为 $s_{\\pi(t)}$ 的元素。\n\n让我们分析第 $t$ 次删除的成本。\n在第 $t$ 步开始时，已有 $t-1$ 个元素被删除。数组的当前长度为 $L_t = N - (t-1)$。\n要删除的元素原始索引为 $s_{\\pi(t)}$。它的当前位置 $P_t$ 是其原始索引减去那些原始位置小于 $s_{\\pi(t)}$ 且已经被删除的元素数量。在第 $1, \\dots, t-1$ 步中删除的元素是那些原始索引为 $\\{s_{\\pi(1)}, s_{\\pi(2)}, \\dots, s_{\\pi(t-1)}\\}$ 的元素。\n在这些已删除的元素中，原始位置在 $s_{\\pi(t)}$ 之前的元素数量为 $d_t = |\\{j \\in \\{1, \\dots, t-1\\} \\mid s_{\\pi(j)}  s_{\\pi(t)}\\}|$。\n因此，要删除的元素的当前位置是 $P_t = s_{\\pi(t)} - d_t$。\n这第 $t$ 次删除的成本是 $C_t = L_t - P_t = (N - t + 1) - (s_{\\pi(t)} - d_t)$。\n$C_t = N + 1 - t - s_{\\pi(t)} + d_t$。\n\n由排列 $\\pi$ 定义的删除序列的总成本是各次删除成本之和：\n$C_{total}(\\pi) = \\sum_{t=1}^{M} C_t = \\sum_{t=1}^{M} (N + 1 - t - s_{\\pi(t)} + d_t)$。\n我们可以将各项分开：\n$C_{total}(\\pi) = \\sum_{t=1}^{M} (N+1) - \\sum_{t=1}^{M} t - \\sum_{t=1}^{M} s_{\\pi(t)} + \\sum_{t=1}^{M} d_t$。\n\n我们来分析和中的每一项：\n- $\\sum_{t=1}^{M} (N+1) = M(N+1)$。这一项与删除顺序 $\\pi$ 无关。\n- $\\sum_{t=1}^{M} t = \\frac{M(M+1)}{2}$。这一项也与 $\\pi$ 无关。\n- $\\sum_{t=1}^{M} s_{\\pi(t)} = \\sum_{k=1}^{M} s_k = \\sum_{k=1}^{M} k^2 = \\frac{M(M+1)(2M+1)}{6}$。这是对要删除的索引集合求和，与顺序 $\\pi$ 无关。\n- $\\sum_{t=1}^{M} d_t = \\sum_{t=1}^{M} |\\{j \\in \\{1, \\dots, t-1\\} \\mid s_{\\pi(j)}  s_{\\pi(t)}\\}|$。这是唯一依赖于所选排列 $\\pi$ 的项。\n\n为了最小化总成本 $C_{total}(\\pi)$，我们必须最小化项 $\\sum_{t=1}^{M} d_t$。由于 $d_t$ 是元素计数，所以 $d_t \\ge 0$。因此，当每个 $d_t$ 都最小时，该和最小。每个 $d_t$ 的最小可能值为 $0$。\n对于所有 $t \\in \\{1, \\dots, M\\}$，条件 $d_t = 0$ 意味着在每一步 $t$，不存在任何先前（在步骤 $j  t$ 中）删除的元素，其原始索引 $s_{\\pi(j)}$ 小于当前元素的原始索引 $s_{\\pi(t)}$。要实现这一点，必须对所有 $j  t$ 都有 $s_{\\pi(j)} > s_{\\pi(t)}$。这意味着要删除的原始索引序列必须是严格递减的：\n$s_{\\pi(1)} > s_{\\pi(2)} > \\dots > s_{\\pi(M)}$。\n由于 $s_k = k^2$ 是关于 $k$ 的严格递增函数，这要求 $\\pi(1) > \\pi(2) > \\dots > \\pi(M)$。满足此条件的唯一排列是逆序排列：$\\pi(t) = M - t + 1$。\n这意味着最优策略是按照原始索引的降序删除元素：先删除 $M^2$，然后是 $(M-1)^2$，依此类推，直到 $1^2$。\n\n现在，我们使用这个最优顺序计算最小成本 $C_{min}$。在此顺序下，对所有 $t$ 都有 $d_t = 0$。\n$C_{min} = \\sum_{t=1}^{M} (N + 1 - t - s_{\\pi(t)})$。\n使用 $\\pi(t) = M-t+1$，我们得到 $s_{\\pi(t)} = s_{M-t+1} = (M-t+1)^2$。\n$C_{min} = \\sum_{t=1}^{M} [ (N+1) - t - (M-t+1)^2 ]$。\n$C_{min} = \\sum_{t=1}^{M} (N+1) - \\sum_{t=1}^{M} t - \\sum_{t=1}^{M} (M-t+1)^2$。\n- $\\sum_{t=1}^{M} (N+1) = M(N+1)$。\n- $\\sum_{t=1}^{M} t = \\frac{M(M+1)}{2}$。\n- 对于第三项，令 $k = M-t+1$。当 $t$ 从 $1$ 取到 $M$ 时，$k$ 从 $M$ 取到 $1$。\n  $\\sum_{t=1}^{M} (M-t+1)^2 = \\sum_{k=1}^{M} k^2 = \\frac{M(M+1)(2M+1)}{6}$。\n\n将这些代入 $C_{min}$ 的表达式中：\n$C_{min} = M(N+1) - \\frac{M(M+1)}{2} - \\frac{M(M+1)(2M+1)}{6}$。\n我们可以提出因子 $\\frac{M}{6}$ 来简化：\n$C_{min} = \\frac{M}{6} [6(N+1) - 3(M+1) - (M+1)(2M+1)]$。\n展开括号内的项：\n$C_{min} = \\frac{M}{6} [ (6N+6) - (3M+3) - (2M^2+3M+1) ]$。\n$C_{min} = \\frac{M}{6} [ 6N+6 - 3M-3 - 2M^2-3M-1 ]$。\n合并同类项：\n$C_{min} = \\frac{M}{6} [ 6N + (6-3-1) - (3M+3M) - 2M^2 ]$。\n$C_{min} = \\frac{M}{6} [ 6N + 2 - 6M - 2M^2 ]$。\n从括号中提出因子 $2$：\n$C_{min} = \\frac{M \\cdot 2}{6} [ 3N + 1 - 3M - M^2 ]$。\n$C_{min} = \\frac{M}{3} (3N + 1 - 3M - M^2)$。\n\n最后，我们代回 $M = \\lfloor\\sqrt{N}\\rfloor$。最小总成本为：\n$C_{min} = \\frac{\\lfloor\\sqrt{N}\\rfloor}{3} (3N + 1 - 3\\lfloor\\sqrt{N}\\rfloor - (\\lfloor\\sqrt{N}\\rfloor)^2)$。\n这就是从第一性原理推导出的所需单一闭式解析表达式。", "answer": "$$\n\\boxed{\\frac{\\lfloor\\sqrt{N}\\rfloor}{3} (3N + 1 - 3\\lfloor\\sqrt{N}\\rfloor - \\lfloor\\sqrt{N}\\rfloor^2)}\n$$", "id": "3208390"}, {"introduction": "虽然逐个删除在概念上很简单，但对于大规模任务来说效率低下。最后一个练习将介绍一种强大且达到工业级标准的批量删除技术，它能在线性时间内完成任务。通过使用指示数组和前缀和（scan）操作，你将学会直接计算每个元素的最终位置，从而绕过成本高昂的逐个元素移动过程。这种方法是许多高性能数据处理算法的基础。[@problem_id:3208395]", "problem": "给定一个长度为 $n$ 的抽象数组 $A$，其索引范围为 $0$ 到 $n-1$。单次批量删除操作会移除数组 $A$ 中位于指定索引集合 $D \\subseteq \\{0,1,\\ldots,n-1\\}$ 的元素（$D$ 的定义中重复的索引没有额外效果）。删除这些元素后，$A$ 中剩余的元素会按其原始相对顺序向左紧凑排列，形成一个新数组 $A'$。对于任意原始索引 $i \\in \\{0,1,\\ldots,n-1\\}$，定义一个索引映射函数，该函数返回 $A[i]$ 在新数组 $A'$ 中的位置（如果 $A[i]$ 被保留），或者在 $A[i]$ 被删除时返回一个哨兵值。\n\n基本原理。仅使用以下核心定义来推导映射和算法：\n- 数组索引与顺序：数组是一个有序序列；删除操作会保留幸存元素的相对顺序。\n- 指示函数：对于每个 $j \\in \\{0,1,\\ldots,n-1\\}$，定义 $x[j] = 1$（如果 $j \\in D$），否则 $x[j] = 0$。\n- 前缀和：对于序列 $x[0],x[1],\\ldots,x[n-1]$，定义前缀和数组 $S$ 为 $S[i] = \\sum_{j=0}^{i} x[j]$，其中 $i \\in \\{0,1,\\ldots,n-1\\}$。\n\n任务。从上述基本原理出发，不使用任何其他专用公式，完成以下任务。\n1. 推导一个数学上精确的函数，该函数将每个原始索引 $i$ 映射到执行删除和数组紧凑化操作后的新位置，或者指示该索引已被删除。你必须用指示函数及其前缀和来表达该映射。\n2. 设计一个算法，为给定的数组长度 $n$、大小为 $k = |D|$ 的删除集合 $D$ 以及包含 $q$ 个查询索引的列表 $Q = [q_0,q_1,\\ldots,q_{q-1}]$ 构建此映射。你的算法运行时间必须为 $O(n + k + q)$，并使用 $O(n)$ 的额外空间。使用整数 $-1$ 作为哨兵值，表示原始索引已被删除。你必须从第一性原理出发证明其时间复杂度。\n3. 将你的算法实现为一个完整的程序，为下面提供的每个测试用例评估该映射。\n\n每个测试用例的输入约束：\n- 数组长度 $n$ 是一个正整数。\n- 删除列表 $D$ 包含 $\\{0,1,\\ldots,n-1\\}$ 中的索引，可能包含重复项；仅集合成员关系有效。\n- 查询列表 $Q$ 包含 $\\{0,1,\\ldots,n-1\\}$ 中的索引。\n\n测试套件。你的程序必须在以下五个案例中，为每个测试用例的查询列表 $Q$ 计算映射后的索引，对已删除的位置使用 $-1$：\n- 案例 1：$n = 10$， $D = [2,5,6]$， $Q = [0,1,2,3,6,7,9]$。\n- 案例 2：$n = 5$， $D = [0]$， $Q = [0,1]$。\n- 案例 3：$n = 5$， $D = [0,1,2,3,4]$， $Q = [0,2,4]$。\n- 案例 4：$n = 5$， $D = [3,3,1]$， $Q = [1,2,3,4]$。\n- 案例 5：$n = 1$， $D = []$， $Q = [0]$。\n\n最终输出格式。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的第 $i$ 个元素对应第 $i$ 个测试用例，它本身也是该测试用例的 $Q$ 的映射索引的逗号分隔列表。例如，如果有两个测试用例，其结果分别为 $[a_0,a_1]$ 和 $[b_0,b_1,b_2]$，则输出应为单行的 $[[a_0,a_1],[b_0,b_1,b_2]]$。", "solution": "该问题要求为数组删除操作推导一个索引映射函数，基于该函数设计一个高效算法，并加以实现。推导过程必须遵循指定的第一性原理。\n\n**第 1 部分：索引映射函数的推导**\n\n设 $A$ 为原始数组，长度为 $n$，索引范围为 $\\{0, 1, \\ldots, n-1\\}$。设 $D$ 为待删除索引的集合。问题定义了一个长度为 $n$ 的指示序列 $x$，其中如果索引 $j$ 在删除集合 $D$ 中，则 $x[j] = 1$，否则 $x[j] = 0$。我们的任务是找到一个函数 $\\text{map}(i)$，它能给出原始索引为 $i$ 的元素的新索引，或者在该元素被删除时返回一个哨兵值。指定的哨兵值为 $-1$。\n\n首先，考虑一个将被删除的、位于原始索引 $i$ 的元素。这种情况当且仅当 $i \\in D$ 时发生，这等价于条件 $x[i] = 1$。对于任何此类索引，映射函数必须返回哨兵值。\n$$ \\text{if } x[i] = 1, \\text{then } \\text{map}(i) = -1 $$\n\n接下来，考虑一个在删除操作后幸存的、位于原始索引 $i$ 的元素。这种情况当且仅当 $i \\notin D$ 时发生，这等价于 $x[i] = 0$。删除后，剩余元素被紧凑排列，并保持其相对顺序。幸存元素 $A[i]$ 的新索引由其在原始数组中前面出现的其他幸存元素的数量决定。在 $A[i]$ 之前的元素是那些位于索引 $\\{0, 1, \\ldots, i-1\\}$ 的元素。此类元素的总数为 $i$。\n\n为了找到 $A[i]$ 之前幸存元素的数量，我们可以计算 $A[i]$ 之前*被删除*元素的数量，然后用前面的元素总数 $i$ 减去这个数量。索引 $j  i$ 的已删除元素的数量由这些索引的指示函数值之和给出：\n$$ \\text{Number of deleted elements before } i = \\sum_{j=0}^{i-1} x[j] $$\n问题将前缀和序列 $S$ 定义为 $S[k] = \\sum_{j=0}^{k} x[j]$，其中 $k \\in \\{0, 1, \\ldots, n-1\\}$。使用这个定义，索引 $i$ 之前被删除的元素数量为 $S[i-1]$（对于 $i=0$ 的情况，我们可以定义 $S[-1] = 0$）。\n\n$A[i]$ 的新的从 $0$ 开始的索引是它前面幸存元素的数量。这个数量是：\n$$ \\text{New index} = (\\text{total elements before } i) - (\\text{deleted elements before } i) = i - \\sum_{j=0}^{i-1} x[j] $$\n对于 $i>0$，这个值是 $i - S[i-1]$。对于 $i=0$，求和为空，等于 $0$，因此新索引是 $0-0=0$。所以，如果 $x[i]=0$，则 $\\text{map}(i) = i - S[i-1]$（其中 $S[-1]=0$）。\n\n可以推导出一个等价且更紧凑的公式。直到并包括索引 $i$ 的幸存元素数量是元素总数 $(i+1)$ 减去直到并包括索引 $i$ 的已删除元素数量，即 $S[i]$。因此，在 $\\{0, 1, \\ldots, i\\}$ 中幸存者的数量是 $(i+1) - S[i]$。如果索引 $i$ 的元素幸存（即 $x[i]=0$），其新的从 $0$ 开始的索引将是这个计数减一。\n$$ \\text{if } x[i] = 0, \\text{then } \\text{map}(i) = ((i+1) - S[i]) - 1 = i - S[i] $$\n这个公式对所有 $i \\in \\{0, \\ldots, n-1\\}$ 都成立，无需为 $S[-1]$ 设置特殊情况。它也与前一个公式等价，因为如果 $x[i]=0$，那么 $S[i] = S[i-1] + x[i] = S[i-1]$。\n\n结合删除和幸存两种情况，完整的索引映射函数是：\n$$ \\text{map}(i) = \\begin{cases} i - S[i]  \\text{if } x[i] = 0 \\\\ -1  \\text{if } x[i] = 1 \\end{cases} $$\n其中 $S[i] = \\sum_{j=0}^{i} x[j]$。此函数完全按照要求，仅用原始索引 $i$、指示序列 $x$ 及其前缀和 $S$ 来表示。\n\n**第 2 部分：算法设计与复杂度分析**\n\n基于推导出的映射函数，我们可以设计一个算法来为给定的数组长度 $n$、大小为 $k$ 的删除列表 $D$ 和大小为 $q$ 的查询列表 $Q$ 计算映射。该算法必须在 $O(n + k + q)$ 时间和 $O(n)$ 额外空间内运行。\n\n该算法分为三个主要阶段进行：\n1.  **构建指示数组和前缀和数组：** 首先，我们预先计算映射所需的信息：指示数组 `x` 和前缀和数组 `S`。\n    a.  初始化一个大小为 $n$ 的整数数组 `x_arr`，所有元素都设为 $0$。这需要 $O(n)$ 时间。\n    b.  遍历长度为 $k$ 的输入删除列表 $D$。对于每个索引 $d \\in D$，设置 `x_arr[d] = 1$。此步骤需要 $O(k)$ 时间。\n    c.  计算 `x_arr` 的前缀和数组 `S_arr`。这可以通过初始化 `S_arr[0] = x_arr[0]`，然后从 $i=1$ 迭代到 $n-1$，计算 `S_arr[i] = S_arr[i-1] + x_arr[i]` 来完成。此阶段需要 $O(n)$ 时间。\n\n2.  **计算完整索引映射（可选但清晰）：** 为了高效地回答查询，我们可以预先计算从原始索引到新索引的完整映射。\n    a.  创建一个大小为 $n$ 的映射数组 `map_arr`。\n    b.  从 $i=0$ 迭代到 $n-1$。对于每个索引 $i$：\n        i. 如果 `x_arr[i] == 1`，则设置 `map_arr[i] = -1`。\n        ii. 如果 `x_arr[i] == 0`，则设置 `map_arr[i] = i - S_arr[i]`。\n    此步骤需要 $O(n)$ 时间。\n\n3.  **处理查询：** 遍历长度为 $q$ 的查询列表 $Q$。对于每个查询索引 $q_j \\in Q$，结果就是 `map_arr[q_j]`。每次查询都是一个 $O(1)$ 的查找操作。此阶段总共需要 $O(q)$ 时间。\n\n**复杂度分析：**\n*   **时间复杂度：** 总时间是每个步骤的时间之和：$O(n)$（用于 `x_arr` 初始化） + $O(k)$（用于填充 `x_arr`） + $O(n)$（用于 `S_arr` 计算） + $O(n)$（用于 `map_arr` 计算） + $O(q)$（用于查询）。总和为 $O(n + k + q)$，符合问题要求。\n*   **空间复杂度：** 该算法使用了三个大小为 $n$ 的数组：`x_arr`、`S_arr` 和 `map_arr`。总的额外空间为 $O(n) + O(n) + O(n) = O(n)$，也符合要求。\n\n该算法正确地实现了推导出的映射函数，并满足给定的性能约束。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the index mapping problem for a suite of test cases.\n    The core logic is implemented in the compute_mapping_for_case function.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: n = 10, D = [2, 5, 6], Q = [0, 1, 2, 3, 6, 7, 9]\n        (10, [2, 5, 6], [0, 1, 2, 3, 6, 7, 9]),\n        # Case 2: n = 5, D = [0], Q = [0, 1]\n        (5, [0], [0, 1]),\n        # Case 3: n = 5, D = [0, 1, 2, 3, 4], Q = [0, 2, 4]\n        (5, [0, 1, 2, 3, 4], [0, 2, 4]),\n        # Case 4: n = 5, D = [3, 3, 1], Q = [1, 2, 3, 4]\n        (5, [3, 3, 1], [1, 2, 3, 4]),\n        # Case 5: n = 1, D = [], Q = [0]\n        (1, [], [0]),\n    ]\n\n    def compute_mapping_for_case(n, D, Q):\n        \"\"\"\n        Computes the new indices for a single test case based on the derived formula.\n        \n        Args:\n            n (int): The length of the abstract array.\n            D (list[int]): A list of original indices to delete.\n            Q (list[int]): A list of original indices to query.\n\n        Returns:\n            list[int]: A list of mapped indices, with -1 for deleted elements.\n        \"\"\"\n        \n        # Step 1: Create the indicator array `x`.\n        # `x[i] = 1` if index `i` is deleted, `0` otherwise.\n        # This takes O(n + |D|) time.\n        x = np.zeros(n, dtype=np.int32)\n        for del_idx in D:\n            if 0 = del_idx  n:\n                x[del_idx] = 1\n\n        # Step 2: Compute the prefix sum array `S`.\n        # `S[i]` stores the number of deleted elements in the range `[0, i]`.\n        # np.cumsum is an efficient O(n) operation.\n        S = np.cumsum(x, dtype=np.int32)\n\n        # Step 3: Respond to queries.\n        # For each query index q, apply the mapping function:\n        # map(q) = -1 if x[q] == 1\n        # map(q) = q - S[q] if x[q] == 0\n        # This takes O(|Q|) time.\n        results = []\n        for q_idx in Q:\n            if x[q_idx] == 1:\n                results.append(-1)\n            else:\n                # The new index is the original index minus the number of\n                # deleted items up to that point.\n                new_idx = q_idx - S[q_idx]\n                results.append(new_idx)\n        \n        return results\n\n    all_results = []\n    for case in test_cases:\n        n, D, Q = case\n        result = compute_mapping_for_case(n, D, Q)\n        all_results.append(result)\n\n    # Format the final output string to match the problem specification exactly.\n    # Produces a string like \"[[r1_1,r1_2],[r2_1,r2_2],...]\"\n    inner_strings = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3208395"}]}