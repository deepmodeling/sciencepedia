{"hands_on_practices": [{"introduction": "掌握一个数据结构意味着不仅要理解其基本操作，更要能对其进行扩展。这个练习 [@problem_id:3246760] 要求你添加一个 `find_and_remove` 函数，这个常见的需求将迫使你深入研究指针操作的细节。通过正确处理所有边缘情况——例如删除头节点、尾节点或唯一的节点——你将精通链表操作的底层机制，并理解这类基于搜索的操作为何具有 $O(n)$ 的时间复杂度。", "problem": "您需要使用一个带有显式头指针和尾指针的单向链表来实现一个先进先出队列。该队列必须支持三个以纯逻辑术语定义的操作：`enqueue` 用于追加一个元素，`dequeue` 用于移除并返回队首的元素，`find_and_remove` 用于移除第一个其存储值等于给定查询值的节点。您必须从队列作为一种抽象数据类型的核心定义以及单向链表的标准属性出发：\n- 队列存储元素的方式是，通过 `dequeue` 移除的元素总是队列中停留时间最长的那个，这与先进先出的按到达顺序排列的不变性相一致。\n- 单向链表由节点组成，每个节点包含一个值和一个指向下一个节点的指针，其中头指针引用第一个节点，尾指针引用最后一个节点，如果列表为空则为 null。\n- 如果头指针和尾指针得到一致的维护，那么在队尾进行标准的 `enqueue` 和在队首进行 `dequeue` 的操作可以以 $\\mathcal{O}(1)$ 的时间复杂度实现。\n\n您的任务：\n- 使用单向链表实现一个队列类，维护头指针和尾指针。`enqueue` 必须在队尾以 $\\mathcal{O}(1)$ 时间插入，`dequeue` 必须从队首以 $\\mathcal{O}(1)$ 时间移除，如果队列为空则返回一个特殊的空值，`find_and_remove` 必须从头到尾扫描，移除给定整数的第一个（即，在值相等的节点中最早入队的那个）匹配项（如果存在）。`find_and_remove` 操作必须返回一个布尔值，指示是否发生了移除。\n- 您必须确保在每次操作后，数据结构都保持不变性，即头指针指向第一个节点（如果队列为空则为 null），尾指针指向最后一个节点（如果为空则为 null），并且尾指针为 null 当且仅当头指针为 null。特别地，在通过 `find_and_remove` 移除头节点或尾节点后，相应的指针必须被正确更新，并且结构必须保持为有效的单向链表。\n\n语义和约束：\n- 队列中存储的值是整数。相等性是标准的整数相等性。对于 `find_and_remove`，队列必须只移除第一个匹配的节点，这与队列的排序属性一致。如果不存在匹配的节点，`find_and_remove` 必须返回 false 并且不执行任何结构性更改。\n- `dequeue` 返回的特殊空值必须是一个不在队列中的整数类型的值；在有引用的语言中，自然的选择是空引用。您必须确保在对空队列执行 `dequeue` 后，内部结构仍然有效。\n\n测试套件：\n您必须完全按照以下固定的测试用例来实现和运行，无需从输入中读取。对于每个测试用例，按顺序列出的操作。每个操作是以下之一：\n- enqueue $x$\n- dequeue\n- find\\_and\\_remove $x$\n\n对于每个测试用例，您的程序必须生成一个单一结果，该结果是一个扁平的整数列表，由两部分连接而成：\n- 从头到尾的最终队列内容，编码为一个整数列表。\n- 一个分隔符值 $-1$，后跟此测试用例中每次 `find_and_remove` 操作结果的二进制指示符序列，其中 $1$ 表示成功，$0$ 表示失败。\n整数 $-1$ 不会在任何测试用例中入队；它被保留为输出编码中的分隔符。\n\n五个测试用例是：\n- 测试用例 $1$（正常路径、中间删除、删除不存在的元素以及多次出队）：\n  - enqueue $3$, enqueue $1$, enqueue $4$, enqueue $1$, enqueue $5$, enqueue $9$, find\\_and\\_remove $4$, find\\_and\\_remove $2$, dequeue, dequeue。\n- 测试用例 $2$（头部删除、尾部删除以及对空队列执行出队）：\n  - enqueue $10$, enqueue $20$, find\\_and\\_remove $10$, find\\_and\\_remove $20$, dequeue。\n- 测试用例 $3$（在非平凡队列中删除尾部元素并进一步入队）：\n  - enqueue $7$, enqueue $8$, enqueue $9$, find\\_and\\_remove $9$, enqueue $10$。\n- 测试用例 $4$（重复值，重复移除第一个匹配项直到队列为空，然后失败）：\n  - enqueue $1$, enqueue $1$, enqueue $1$, find\\_and\\_remove $1$, find\\_and\\_remove $1$, find\\_and\\_remove $1$, find\\_and\\_remove $1$。\n- 测试用例 $5$（通过 `find_and_remove` 删除单个元素以及后续删除失败）：\n  - enqueue $42$, find\\_and\\_remove $42$, enqueue $5$, dequeue, find\\_and\\_remove $5$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含五个测试用例各自的结果，结果为一个用方括号括起来的逗号分隔列表，每个测试用例的结果本身也是一个用方括号括起来、无空格的逗号分隔整数列表。例如，一个包含 $3$ 个测试用例的输出应如下所示：`[ [...], [...], [...] ]`，但其中不应有任何空格。\n- 具体来说，对于此作业，您的程序必须打印一个单行，其确切形式为 `[$r_1$,$r_2$,$r_3$,$r_4$,$r_5$]`，其中每个 $r_i$ 是如上所述编码测试用例 $i$ 结果的无空格整数列表。\n\n此问题中没有物理单位或角度单位。所有答案都是纯整数和编码为整数的布尔值。\n\n您的程序必须是自包含的，除了指定的单行输出外，不得读取任何输入或写入任何其他输出。", "solution": "问题陈述已经过严格验证，并被认为是有效的。它在数据结构和算法领域提出了一个定义明确、具有科学依据的问题。使用单向链表实现队列的要求，包括具体操作 `enqueue`、`dequeue` 和 `find_and_remove`，是清晰、一致且完整的。测试用例和输出格式的规定足够精确，可以得出一个唯一且可验证的解。\n\n该实现将基于单向链表和先进先出（FIFO）队列的基本原则。单向链表是数据元素的线性集合，这些元素称为节点，其中每个节点指向序列中的下一个节点。为了高效地实现队列，我们维护两个指针：一个指向第一个节点的`` `head` ``指针和一个指向最后一个节点的`` `tail` ``指针。\n\n核心数据结构是 `Node` 和 `Queue` 本身。\n- `Node` 包含两个字段：一个`` `value` ``（根据题目要求，是一个整数）和一个`` `next` ``指针，它引用后续节点，如果是最后一个节点则为`` `null` ``。\n- `Queue` 类封装了列表并维护三个状态：`` `head` ``指针、`` `tail` ``指针，以及隐式地，元素的数量。`` `head` ``为`` `null` ``当且仅当`` `tail` ``为`` `null` ``这一不变性必须被严格保持。\n\n三个所需的操作实现如下：\n\n1.  **Enqueue 操作**：`` `enqueue(x)` ``操作将一个值为`` `x` ``的元素添加到队列的尾部。通过操作`` `tail` ``指针，这可以在常数时间 $\\mathcal{O}(1)$ 内实现。\n    - 创建一个值为`` `x` ``的新 `Node`。\n    - 如果队列为空（即`` `head` ``为`` `null` ``），则将`` `head` ``和`` `tail` ``都设置为指向这个新节点。\n    - 如果队列不为空，则将当前`` `tail` ``节点的`` `next` ``指针更新为指向新节点，然后将`` `tail` ``指针本身更新为这个新节点。这样就正确地将元素追加到了列表的末尾。\n\n2.  **Dequeue 操作**：`` `dequeue()` ``操作移除并返回队列前端的元素。通过操作`` `head` ``指针，这可以在常数时间 $\\mathcal{O}(1)$ 内实现。\n    - 如果队列为空（`` `head` ``为`` `null` ``），则返回一个特殊的`` `null` ``值，结构保持不变，符合要求。\n    - 如果队列不为空，则存储`` `head` ``节点的值以供返回。\n    - 将`` `head` ``指针前移，使其指向列表中的下一个节点（`` `head = head.next` ``）。\n    - 一个关键步骤是检查在移除后队列是否变空。如果新的`` `head` ``为`` `null` ``，这意味着最后一个元素刚刚被移除，因此`` `tail` ``指针也必须设置为`` `null` ``，以维护队列的结构完整性。\n\n3.  **Find and Remove 操作**：`` `find_and_remove(x)` ``操作搜索第一个值为`` `x` ``的节点并将其从队列中移除。此操作需要遍历，其时间复杂度为 $\\mathcal{O}(n)$，其中 `$n$` 是队列中元素的数量。它必须在成功移除时返回`` `True` ``，否则返回`` `False` ``，并正确更新所有情况下的指针。\n    - **情况 1：空队列。** 如果`` `head` ``为`` `null` ``，则找不到该值，函数立即返回`` `False` ``。\n    - **情况 2：头节点匹配。** 如果`` `head.value` ``等于`` `x` ``，问题简化为移除头元素。这可以通过简单调用现有的`` `dequeue()` ``方法来完成，该方法能正确处理所有指针更新。然后函数返回`` `True` ``。\n    - **情况 3：非头节点匹配。** 必须遍历列表。我们使用两个指针，`` `previous` ``和`` `current` ``，起始时`` `previous = head` ``和`` `current = head.next` ``。循环在`` `current` ``不为`` `null` ``时继续。\n        - 如果`` `current.value` ``等于`` `x` ``，我们找到了要移除的节点。将`` `previous` ``节点的`` `next` ``指针设置为绕过`` `current` ``节点（`` `previous.next = current.next` ``）。\n        - 这里需要一个特殊检查：如果被移除的节点是`` `tail` ``（`` `current == tail` ``），那么`` `tail` ``指针必须更新为指向`` `previous` ``。\n        - 成功移除节点后，函数返回`` `True` ``。\n    - 如果遍历完成而没有找到匹配的值，函数返回`` `False` ``。\n\n此设计严格遵守问题规范，确保所有不变性在所有操作中都得以维持，并且诸如空队列、单元素队列以及移除头或尾元素的边缘情况都得到正确处理。\n\n提供的测试套件将对此实现执行，以验证其正确性并生成指定的输出格式。每个测试用例将在一个新的 `Queue` 实例上运行。每个测试用例的最终结果是通过将队列中剩余的值列表（从头到尾）、一个分隔符值 `$-1$` 以及来自`` `find_and_remove` ``调用的布尔结果序列（`$1$` 代表`` `True` ``，`$0$` 代表`` `False` ``）连接起来构造的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"A node in a singly linked list.\"\"\"\n    def __init__(self, value, next_node=None):\n        self.value = value\n        self.next = next_node\n\nclass Queue:\n    \"\"\"A FIFO queue implemented using a singly linked list.\"\"\"\n    def __init__(self):\n        \"\"\"Initializes an empty queue.\"\"\"\n        self.head = None\n        self.tail = None\n\n    def enqueue(self, value):\n        \"\"\"Adds an element to the tail of the queue in O(1) time.\"\"\"\n        new_node = Node(value)\n        if self.head is None:\n            self.head = new_node\n            self.tail = new_node\n        else:\n            self.tail.next = new_node\n            self.tail = new_node\n\n    def dequeue(self):\n        \"\"\"Removes and returns the element from the head of the queue in O(1) time.\"\"\"\n        if self.head is None:\n            return None  # Distinguished null value for an empty queue\n        \n        value = self.head.value\n        self.head = self.head.next\n        \n        if self.head is None:\n            self.tail = None  # The queue is now empty\n        \n        return value\n\n    def find_and_remove(self, value):\n        \"\"\"Finds and removes the first occurrence of a value from the queue.\"\"\"\n        if self.head is None:\n            return False\n\n        # Case 1: The head node needs to be removed.\n        if self.head.value == value:\n            self.dequeue()\n            return True\n\n        # Case 2: A non-head node needs to be removed.\n        # We need a previous pointer to re-link the list.\n        prev = self.head\n        current = self.head.next\n        while current is not None:\n            if current.value == value:\n                prev.next = current.next\n                # If the removed node was the tail, update the tail pointer.\n                if current == self.tail:\n                    self.tail = prev\n                return True\n            prev = current\n            current = current.next\n\n        # Case 3: Value not found.\n        return False\n\n    def get_contents(self):\n        \"\"\"Returns the contents of the queue as a list of integers.\"\"\"\n        items = []\n        current = self.head\n        while current is not None:\n            items.append(current.value)\n            current = current.next\n        return items\n\ndef solve():\n    \"\"\"\n    Runs the entire test suite and prints the final result.\n    \"\"\"\n    test_cases = [\n        [\"enqueue 3\", \"enqueue 1\", \"enqueue 4\", \"enqueue 1\", \"enqueue 5\", \"enqueue 9\", \"find_and_remove 4\", \"find_and_remove 2\", \"dequeue\", \"dequeue\"],\n        [\"enqueue 10\", \"enqueue 20\", \"find_and_remove 10\", \"find_and_remove 20\", \"dequeue\"],\n        [\"enqueue 7\", \"enqueue 8\", \"enqueue 9\", \"find_and_remove 9\", \"enqueue 10\"],\n        [\"enqueue 1\", \"enqueue 1\", \"enqueue 1\", \"find_and_remove 1\", \"find_and_remove 1\", \"find_and_remove 1\", \"find_and_remove 1\"],\n        [\"enqueue 42\", \"find_and_remove 42\", \"enqueue 5\", \"dequeue\", \"find_and_remove 5\"]\n    ]\n\n    all_results = []\n\n    for operations in test_cases:\n        q = Queue()\n        find_remove_outcomes = []\n        for op_str in operations:\n            parts = op_str.split()\n            command = parts[0]\n            \n            if command == \"enqueue\":\n                value = int(parts[1])\n                q.enqueue(value)\n            elif command == \"dequeue\":\n                q.dequeue()\n            elif command == \"find_and_remove\":\n                value = int(parts[1])\n                success = q.find_and_remove(value)\n                find_remove_outcomes.append(1 if success else 0)\n\n        final_contents = q.get_contents()\n        result_list = final_contents + [-1] + find_remove_outcomes\n        all_results.append(result_list)\n    \n    # Format the final output string exactly as specified, with no spaces.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3246760"}, {"introduction": "数据结构是构建复杂系统模型的基石。在本次实践 [@problem_id:3246732] 中，你将不再把队列看作一个孤立的结构，而是将其作为核心组件，用于模拟一个层级组织中的信息流动。这个任务要求你在树状结构中管理多个队列实例，并实现如“轮询合并”等自定义逻辑，这是对算法组合能力的绝佳锻炼。", "problem": "你的任务是使用单向链表实现一个先进先出（FIFO）队列，并用它来模拟一个层级组织中的请求传播。该层级结构是一个有根树，其中每个节点代表指挥链中的一个位置。你的程序必须模拟两种传播方向：将请求从叶节点向上传播至根节点，以及将指令从根节点向下传播至叶节点。解决方案必须完全依赖于链表的基本定义和FIFO队列的不变性，并且必须从这些基础上推导出其正确性，不得使用任何捷径公式。\n\n基本原理：\n- 队列是先进先出（FIFO）的，意味着元素按其插入顺序被移除。基于链表的队列维护一个头指针和一个尾指针，使得在尾部入队和在头部出队的时间复杂度均为 $O(1)$，与队列长度无关。\n- 单向链表由节点组成，每个节点包含一个值和一个指向下一个节点的指针。在基于链表的队列中，入队操作在当前尾节点之后附加一个新节点并更新尾指针；出队操作移除头节点并前移头指针。\n\n层级模型：\n- 该组织被建模为一个有根树 $T$，节点由非负整数标记。根节点的索引为 $0$。对于任何节点 $u$，其子节点由一个整数索引列表给出。子节点按索引递增顺序处理。\n- 向上传播：每个叶节点持有一个初始的请求（整数）FIFO队列。在任何内部节点 $u$ 处，你需要将其子队列中的请求合并成一个新的 $u$ 的FIFO队列。合并过程采用轮询（round-robin）方式，按子节点索引递增的顺序进行。在每一轮中，从每个非空子队列的前端取至多一个元素，并保持每个子队列内部的FIFO顺序。这个合并后的队列随后向上传播至父节点。根节点的合并队列被完全出队，以产生根节点处的最终处理序列。\n- 向下传播：根节点持有一个指令（整数）FIFO队列。每个内部节点 $u$ 使用轮询方式，按子节点索引递增的顺序，将其入站FIFO队列中的指令转发给其子节点：每当 $u$ 出队一个指令，它就将该指令入队到轮询顺序中的下一个子节点的入站FIFO队列，并前移其子节点指针。当一个指令到达叶节点时，它在该叶节点出队的瞬间被视为已送达。指令到达的叶节点索引序列构成了向下传播的结果。\n\n您的实现要求：\n- 实现一个单向链表队列，包含 enqueue、dequeue、peek 和 is_empty 操作。所有操作必须维护队列的不变性，并为 enqueue 和 dequeue 提供 $O(1)$ 的时间复杂度。\n- 使用此队列实现来模拟所述的向上传播和向下传播。核心队列操作不得使用基于数组的队列捷径。\n\n测试套件：\n提供以下三个测试用例的结果。\n\n测试用例 $1$（向上传播，一般情况）：\n- 树的邻接关系（子节点列表）：节点 $0$ 的子节点为 $[1,2]$，节点 $1$ 的子节点为 $[3,4]$，节点 $2$ 的子节点为 $[5]$，节点 $3,4,5$ 是叶节点。\n- 叶节点请求队列：节点 $3$ 有 $[101,103]$，节点 $4$ 有 $[102]$，节点 $5$ 有 $[104,105]$。\n- 预期行为：节点 $1$ 轮询合并 $[3,4]$ 产生 $[101,102,103]$；节点 $2$ 产生 $[104,105]$；根节点轮询合并子节点 $[1,2]$ 产生最终的根处理顺序 $[101,104,102,105,103]$。\n\n测试用例 $2$（向上传播，含空队列的边界情况）：\n- 树的邻接关系：节点 $0$ 的子节点为 $[1,4]$，节点 $1$ 的子节点为 $[2]$，节点 $2$ 的子节点为 $[3]$，节点 $3$ 和 $4$ 是叶节点。\n- 叶节点请求队列：节点 $3$ 有 $[201,202,203]$，节点 $4$ 有 $[]$ (空)。\n- 预期行为：根节点轮询合并子节点 $[1,4]$；由于节点 $4$ 为空，最终的根处理顺序是 $[201,202,203]$。\n\n测试用例 $3$（向下传播，一般情况）：\n- 树的邻接关系：节点 $0$ 的子节点为 $[1,2,3]$，节点 $1$ 的子节点为 $[4]$，节点 $2$ 的子节点为 $[5]$，节点 $3$ 的子节点为 $[6]$，节点 $4,5,6$ 是叶节点。\n- 根指令队列：$[31,32,33,34,35]$。\n- 转发策略：在每个内部节点，按子节点索引递增的顺序进行轮询。\n- 预期行为：指令被转发，使得叶节点按 $[4,5,6,4,5]$ 的叶节点索引序列接收到指令。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 `[result1,result2,result3]`），每个 $resulti$ 是一个表示该测试用例最终序列的整数列表。对于指定的测试套件，单行输出必须是一个包含三个列表的列表，按顺序对应于测试用例 $1$、 $2$ 和 $3$。", "solution": "该问题要求使用单向链表实现一个先进先出（FIFO）队列，并将其应用于模拟树状层级结构中两种类型的信息流——向上传播和向下传播。解决方案的正确性必须从这些数据结构的基本原理中推导出来。\n\n首先，我们建立核心数据结构：一个基于单向链表的FIFO队列。单向链表是一系列节点的序列，其中每个节点包含一个数据负载和一个指向序列中下一个节点的引用（或指针）。对于我们的队列，我们定义一个 `Node` 结构，它持有一个 `value` 和一个 `next` 指针。`Queue` 本身维护两个指针：`head`，指向第一个节点；以及 `tail`，指向最后一个节点。这种双指针设计对于实现所需的时间复杂度至关重要。\n\n基本的队列操作实现如下：\n- **入队 (Enqueue)**：一个元素被添加到队列的后端。创建一个带有给定值的新 `Node`。通过将 `tail.next` 设置为新节点，将这个新节点附加到当前 `tail` 节点之后。然后 `tail` 指针更新为这个新节点。如果队列为空（`head` 和 `tail` 均为 `None`），则两个指针都设置为新节点。此操作仅涉及几次指针操作，因此其时间复杂度为 $O(1)$。\n- **出队 (Dequeue)**：一个元素从队列的前端被移除。获取 `head` 节点的值。然后将 `head` 指针前移至 `head.next`。如果此操作使队列变空（`head` 变为 `None`），则 `tail` 指针也必须设置为 `None` 以维护队列的不变性。此操作同样是 $O(1)$。\n- **查看 (Peek)**：此操作返回 `head` 节点的值，但不移除它。这是一个 $O(1)$ 操作。\n- **判空 (Is_empty)**：此操作检查队列是否为空，如果 `head` 为 `None` 则为真。这是一个 $O(1)$ 检查。\n\n接着，问题在有根树 $T$ 上指定了两种传播模型。该树由邻接表定义，其中每个节点 $u$ 与一个按其整数索引排序的子节点列表相关联。\n\n**向上传播模型：**\n该模型模拟了从层级结构的叶节点到根节点的请求聚合过程。该过程被递归定义，对应于树的后序遍历。\n对于树 $T$ 中的任何节点 $u$：\n1.  **基本情况**：如果 $u$ 是一个叶节点，其队列用给定的请求列表初始化。\n2.  **递归步骤**：如果 $u$ 是一个内部节点，我们首先递归地计算其所有子节点的队列。然后，我们通过合并其子节点的队列来构建节点 $u$ 的队列。合并过程是一个轮询（round-robin）程序，按其指定的子节点索引递增顺序执行。在每一轮中，我们尝试从每个非空子队列的前端出队一个元素，并将其入队到节点 $u$ 的队列中。此过程持续到所有子队列都为空。这种轮询策略确保了来自不同子节点的元素交错排列，同时保留了源自同一子节点的元素的FIFO顺序。\n\n向上传播测试用例的最终结果是通过完全出队为根节点（节点 $0$）计算出的队列而获得的元素序列。\n\n**向下传播模型：**\n该模型模拟了从根节点到叶节点的指令分发过程。该过程由根节点的初始指令队列驱动。与向上传播不同，指令是逐个处理的，每个指令在下一个指令被处理之前，都会从根节点遍历到某个叶节点。\n1.  树中的每个内部节点 $u$ 必须维护一个状态来处理对其子节点的轮询分发。这个状态可以是一个简单的计数器 `next_child_ptr`，指示接收下一个指令的子节点的索引。\n2.  模拟从根队列中出队第一个指令开始。\n3.  对于一个给定的指令，会从根节点向下一路追踪其路径。在这条路径上的任何内部节点 $v$ 处，该节点会查询其 `next_child_ptr` 来选择一个子节点，将指令转发给该子节点，然后为其将要处理的下一个指令递增其 `next_child_ptr`（循环递增）。\n4.  这个遍历过程持续进行，直到指令到达一个叶节点。这个叶节点的索引被记录为该指令的到达目的地。\n5.  对根初始队列中的每个指令重复整个过程。向下传播测试用例的最终结果是指令到达的叶节点索引的有序序列。\n\n通过从第一性原理实现 `Queue` 类，然后基于这些严格定义的模型构建 `solve_upward` 和 `solve_downward` 过程，我们可以模拟测试用例并产生所需的结果。所提供的测试用例及其预期结果，用于确认对这些模型的正确解读，特别是向下传播的微妙机制。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# A meticulous and exacting implementation of a singly linked-list based queue.\n\nclass Node:\n    \"\"\"\n    A node in a singly linked list.\n    \"\"\"\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\nclass Queue:\n    \"\"\"\n    A FIFO queue implemented using a singly linked list.\n    All core operations (enqueue, dequeue) are O(1).\n    \"\"\"\n    def __init__(self):\n        self.head = None\n        self.tail = None\n        self._size = 0\n\n    def is_empty(self):\n        \"\"\"Checks if the queue is empty. O(1).\"\"\"\n        return self.head is None\n\n    def enqueue(self, value):\n        \"\"\"Adds an element to the back of the queue. O(1).\"\"\"\n        new_node = Node(value)\n        if self.is_empty():\n            self.head = new_node\n            self.tail = new_node\n        else:\n            self.tail.next = new_node\n            self.tail = new_node\n        self._size += 1\n\n    def dequeue(self):\n        \"\"\"Removes and returns the element from the front of the queue. O(1).\"\"\"\n        if self.is_empty():\n            raise IndexError(\"dequeue from an empty queue\")\n        \n        value = self.head.value\n        self.head = self.head.next\n        if self.head is None:\n            self.tail = None\n        self._size -= 1\n        return value\n\n    def peek(self):\n        \"\"\"Returns the value of the front element without removing it. O(1).\"\"\"\n        if self.is_empty():\n            return None\n        return self.head.value\n\n    def size(self):\n        \"\"\"Returns the number of elements in the queue. O(1).\"\"\"\n        return self._size\n\n    def to_list(self):\n        \"\"\"Drains the queue and returns its elements as a list.\"\"\"\n        result = []\n        while not self.is_empty():\n            result.append(self.dequeue())\n        return result\n\ndef solve_upward(adj, leaf_queues_data):\n    \"\"\"\n    Solves for upward propagation.\n    Uses a post-order traversal (recursive with memoization) to build queues up the tree.\n    \"\"\"\n    memo = {}\n    \n    all_nodes = set(adj.keys())\n    for children in adj.values():\n        all_nodes.update(children)\n    \n    leaves = {node for node in all_nodes if node not in adj or not adj[node]}\n\n    def get_or_compute_queue(node_id):\n        if node_id in memo:\n            return memo[node_id]\n\n        # Base case: Leaf node\n        if node_id in leaves:\n            q = Queue()\n            for item in leaf_queues_data.get(node_id, []):\n                q.enqueue(item)\n            memo[node_id] = q\n            return q\n        \n        # Recursive step: Internal node\n        child_queues = [get_or_compute_queue(child_id) for child_id in adj[node_id]]\n        \n        merged_queue = Queue()\n        \n        # Round-robin merge\n        active_children = True\n        while active_children:\n            active_children = False\n            for child_q in child_queues:\n                if not child_q.is_empty():\n                    merged_queue.enqueue(child_q.dequeue())\n                    active_children = True\n        \n        memo[node_id] = merged_queue\n        return merged_queue\n\n    root_queue = get_or_compute_queue(0)\n    return root_queue.to_list()\n\n\ndef solve_downward(adj, root_directives):\n    \"\"\"\n    Solves for downward propagation.\n    Simulates item by item, with each internal node maintaining round-robin state.\n    \"\"\"\n    leaves = set()\n    all_nodes = set(adj.keys())\n    for children in adj.values():\n        all_nodes.update(children)\n    for node in all_nodes:\n        if node not in adj or not adj[node]:\n            leaves.add(node)\n\n    root_queue = Queue()\n    for directive in root_directives:\n        root_queue.enqueue(directive)\n        \n    # State for round-robin at each internal node\n    rr_state = {node_id: 0 for node_id in adj if adj[node_id]}\n    \n    arrival_sequence = []\n    \n    while not root_queue.is_empty():\n        directive = root_queue.dequeue()\n        current_node = 0\n        \n        while current_node not in leaves:\n            children = adj[current_node]\n            child_ptr = rr_state[current_node]\n            next_node = children[child_ptr]\n            \n            # Update state for next time\n            rr_state[current_node] = (child_ptr + 1) % len(children)\n            \n            current_node = next_node\n            \n        arrival_sequence.append(current_node)\n        \n    return arrival_sequence\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"type\": \"upward\",\n            \"adj\": {0: [1, 2], 1: [3, 4], 2: [5]},\n            \"data\": {3: [101, 103], 4: [102], 5: [104, 105]}\n        },\n        {\n            \"type\": \"upward\",\n            \"adj\": {0: [1, 4], 1: [2], 2: [3]},\n            \"data\": {3: [201, 202, 203], 4: []}\n        },\n        {\n            \"type\": \"downward\",\n            \"adj\": {0: [1, 2, 3], 1: [4], 2: [5], 3: [6]},\n            \"data\": [31, 32, 33, 34, 35]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        if case[\"type\"] == \"upward\":\n            result = solve_upward(case[\"adj\"], case[\"data\"])\n            results.append(result)\n        elif case[\"type\"] == \"downward\":\n            result = solve_downward(case[\"adj\"], case[\"data\"])\n            results.append(result)\n\n    # Format the final output string to match the required format `[[...],[...]]`\n    # by removing spaces from the default string representation of a list of lists.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3246732"}, {"introduction": "在多核处理器时代，确保数据结构的线程安全是一项至关重要的技能。这个高级练习 [@problem_id:3246704] 将指导你构建一个阻塞队列，这是并发编程的基石之一。你将学习如何使用锁来实现互斥访问，并利用条件变量来高效地管理等待数据的线程，从而获得解决“生产者-消费者”问题的实践经验。", "problem": "您需要设计并实现一个线程安全的先进先出（FIFO）队列，该队列使用单向链表和条件变量。该队列必须支持一种操作，该操作会阻塞调用者直到有项目可用，而不是返回一个哨兵值（如空值）。核心数据结构是一个带有头指针和尾指针的单向链表。实现的正确性必须遵循核心定义和经过充分测试的事实：FIFO 属性规定移除操作返回当前存储的最旧元素；互斥确保一次只有一个线程操作共享状态；条件变量语义确保线程可以在谓词变为真之前高效地等待。\n\n从以下基础开始：\n- 队列是一个序列 $Q = [x_1, x_2, \\dots, x_k]$，其中 $x_1$ 是最旧的元素，$x_k$ 是最新的元素。入队（Enqueue）在末尾追加一个元素，出队（dequeue）从前端移除一个元素。队列必须保持 FIFO 属性。\n- 单向链表节点有一个值和一个 next 指针。队列维护两个指针：一个头指针 $H$ 指向最旧的节点，一个尾指针 $T$ 指向最新的节点。空队列由 $H = \\varnothing$ 和 $T = \\varnothing$ 表示。\n- 通过锁实现的互斥确保了不变量 $H$ 和 $T$ 相对于其他线程是原子性更新的。\n- 条件变量支持在等待一个谓词的同时释放相关联的锁，并在收到通知后重新获取锁以再次检查该谓词。正确的模式是使用一个循环：当谓词为假时，等待；一旦谓词变为真，继续执行。这可以防止虚假唤醒（spurious wake-ups）。\n\n您的程序必须在链表队列上实现以下操作：\n- Enqueue（入队）：获取互斥锁，在 $O(1)$ 时间内将一个新节点追加到尾部，如果队列原为空则更新 $T$ 以及可能的 $H$，并向条件变量发信号以唤醒一个等待中的线程。\n- Blocking dequeue（阻塞式出队）：获取互斥锁，如果队列为空，则在条件变量上等待；被唤醒后，在循环中重新检查是否为空；一旦队列非空，在 $O(1)$ 时间内移除头部，如果队列因此变空则更新 $H$ 以及可能的 $T$，并返回被移除的值。此操作绝不能返回哨兵值，并且必须无限期阻塞直到有项目可用。\n\n您必须为以下测试套件生成结果。每个测试用例指定了控制入队时机以及生产者和消费者线程数量的参数。请使用单调时钟，并以秒为单位表示所有时间。\n\n测试套件：\n- 案例 $1$ (正常路径阻塞): 一个消费者线程对一个初始为空的队列执行阻塞式出队。一个生产者在延迟 $0.08$ 秒后入队一个整数。设 $t_{\\text{wait}}$ 为从进入阻塞式出队到带项目返回之间测量到的时间。在容差 $\\tau = 0.01$ 秒的情况下，报告一个布尔值，指示是否 $t_{\\text{wait}} \\ge 0.08 - 0.01$ 且返回的值等于入队的值。\n- 案例 $2$ (交错入队下的 FIFO 顺序): 一个消费者线程执行三次阻塞式出队；一个生产者分别在延迟 $0.02$ 秒、$0.05$ 秒和 $0.07$ 秒时入队三个整数。报告一个布尔值，指示消费者观察到的序列是否与按时间顺序的入队顺序相等。\n- 案例 $3$ (多消费者公平性): 三个消费者线程各自执行一次阻塞式出队；一个生产者在延迟 $0.05$ 秒后入队三个不同的整数。报告一个布尔值，指示是否所有消费者都恰好返回一个唯一的整数，并且返回值的多重集与入队值的多重集相匹配。\n- 案例 $4$ (即时可用性): 在启动执行阻塞式出队的消费者之前，先入队一个整数。设 $t_{\\text{wait}}$ 的测量方式与案例 1 相同。在阈值 $\\theta = 0.01$ 秒的情况下，报告一个布尔值，指示是否 $t_{\\text{wait}}  0.01$。\n- 案例 $5$ (虚假唤醒保护): 一个消费者线程对一个空队列执行阻塞式出队。另一个独立的线程在 $0.02$ 秒后执行一次条件变量通知，但没有入队任何项目。最后，一个生产者在额外的 $0.03$ 秒后入队一个整数。设 $t_{\\text{wait}}$ 的测量方式与案例 1 相同。在容差 $\\tau = 0.01$ 秒的情况下，报告一个布尔值，指示是否 $t_{\\text{wait}} \\ge (0.02 + 0.03) - 0.01$。这测试了实现是否能在虚假通知后正确地重新检查谓词并继续阻塞。\n\n您的程序应生成单行输出，其中包含按案例 1 到 5 顺序排列的结果，形式为方括号内以逗号分隔的列表。每个案例的结果必须是一个布尔值。例如：“[true_case1,true_case2,true_case3,true_case4,true_case5]”，但使用编程语言的规范布尔文字。不使用角度单位，所有时间测量必须以秒表示，并由语言的默认表示形式隐式舍入。程序必须是完整的，并且无需任何外部输入或文件即可运行。", "solution": "问题陈述已经过验证，被认为是科学严谨、定义明确且客观的。它提出了一个并发编程和数据结构中的标准但非平凡的问题，提供了清晰、可形式化的要求和可验证的测试套件。该问题是有效的。\n\n任务是设计并实现一个线程安全的、阻塞式的先进先出（FIFO）队列。实现必须基于一个带有头尾指针的单向链表，确保入队和出队操作的时间复杂度均为 $O(1)$。线程安全将通过互斥锁实现，而阻塞行为将由条件变量管理。\n\n首先，我们定义链表的基本组成部分 `Node`。每个 `Node` 包含一个 `value` 和一个 `next` 指针，后者指向序列中的下一个节点。\n- `Node.value`：存储在节点中的数据元素。\n- `Node.next`：对列表中下一个 `Node` 的引用，如果是最后一个节点，则为 `None`（表示 $\\varnothing$）。\n\n`BlockingQueue` 类封装了队列的状态和逻辑。其状态由以下部分定义：\n- 一个头指针 $H$，指向列表中的第一个（最旧的）节点。\n- 一个尾指针 $T$，指向列表中的最后一个（最新的）节点。\n- 一个锁，`threading.Lock` 的实例，用于确保互斥。\n- 一个条件变量，`threading.Condition` 的实例，与锁相关联，用于管理等待项目可用的线程。\n\n空队列的不变量是 $H = \\varnothing$ 和 $T = \\varnothing$。对于非空队列，$H$ 指向列表的开头，$T$ 指向列表的末尾。\n\n`BlockingQueue` 的初始化将 $H$ 和 $T$ 设置为 `None`，并实例化锁和条件变量。\n\n`enqueue(item)` 操作实现了向队列中添加元素的逻辑：\n$1$. 获取锁，以确保对队列共享状态（$H$ 和 $T$）的原子修改。\n$2$. 创建一个新的 `Node` 实例来持有 `item`。\n$3$. 通过测试 $T$ 是否为 `None` 来检查队列是否为空。\n    a. 如果队列为空 ($T = \\varnothing$)，这意味着 $H$ 也为 `None`。在这种情况下，$H$ 和 $T$ 都被设置为指向新节点。这建立了一个只有一个元素的队列。\n    b. 如果队列不为空，则将新节点追加到列表的末尾。这是通过将当前尾节点（$T$.next）的 `next` 指针设置为新节点来实现的。随后，尾指针 $T$ 被更新为指向这个新节点，它现在是最后一个元素。\n$4$. 成功添加节点并更新指针后，通过调用条件变量的 `notify()` 方法向一个等待中的线程发信号。这至关重要，因为它通知一个可能被阻塞的消费者线程状态已改变，并且现在有项目可用。\n$5$. 释放锁。使用 `with` 语句会自动处理此操作。\n整个操作的时间复杂度为 $O(1)$，因为它由固定数量的指针赋值组成。\n\n`blocking_dequeue()` 操作实现了从队列中移除元素（必要时阻塞）的逻辑：\n$1$. 获取锁以确保对队列状态的独占访问。\n$2$. 检查等待的谓词：队列是否为空。使用条件变量的正确且健壮的方法是在一个 `while` 循环内进行：`while self.head is None:`。条件 `$H = \\varnothing$` 表示队列为空。\n$3$. 如果谓词为真（队列为空），则调用 `self.condition.wait()`。这将原子地释放锁并暂停当前线程的执行，直到收到通知。唤醒后（由于 `notify()` 或 `notify_all()` 调用），线程重新获取锁，并重新评估 `while` 循环的条件。这种循环结构正确地处理了虚假唤醒，即线程可能在没有项目入队的情况下被唤醒。线程将简单地重新检查条件，发现队列仍然为空，然后返回等待状态。\n$4$. 一旦 `while` 循环终止，就可以保证队列非空（即 $H \\neq \\varnothing$）并且当前线程持有锁。\n$5$. 从头节点检索值：`value = self.head.value`。\n$6$. 通过将头指针前移到下一个节点来从队列中移除头节点：`self.head = self.head.next`。\n$7$. 必须处理一个特殊情况：如果队列因出队操作而变空（即新的 $H$ 为 `None`），则尾指针 $T$ 也必须设置为 `None`，以维持空队列的不变量（$H=\\varnothing, T=\\varnothing$）。\n$8$. 返回检索到的 `value`。锁在退出 `with` 块时被释放。\n与入队操作一样，此操作在指针操作部分的时间复杂度为 $O(1)$，不包括任何等待时间。\n\n此设计满足了问题陈述的所有要求。它使用单向链表和 $O(1)$ 操作正确地实现了 FIFO 队列，通过互斥确保了线程安全，并提供了一个正确的、非哨兵值的、能防止虚假唤醒的阻塞式出队机制。问题中提供的测试套件将用于在实现后验证此设计的正确性。", "answer": "```python\nimport threading\nimport time\nimport queue\nimport numpy as np\n\n# According to the problem statement, numpy must be imported.\n# It is not used in the core logic but its presence satisfies the constraint.\n\nclass Node:\n    \"\"\"A node in a singly linked list.\"\"\"\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\nclass BlockingQueue:\n    \"\"\"\n    A thread-safe FIFO queue implemented with a singly linked list,\n    a lock, and a condition variable. Dequeue operations block until an\n    item is available.\n    \"\"\"\n    def __init__(self):\n        self.head = None\n        self.tail = None\n        self.lock = threading.Lock()\n        self.condition = threading.Condition(self.lock)\n\n    def enqueue(self, item):\n        \"\"\"\n        Adds an item to the tail of the queue in O(1) time.\n        Signals a waiting consumer thread.\n        \"\"\"\n        new_node = Node(item)\n        with self.lock:\n            if self.tail is None:\n                # The queue is empty\n                self.head = new_node\n                self.tail = new_node\n            else:\n                # The queue is not empty\n                self.tail.next = new_node\n                self.tail = new_node\n            \n            # Signal one waiting thread that an item is now available.\n            self.condition.notify()\n\n    def blocking_dequeue(self):\n        \"\"\"\n        Removes and returns an item from the head of the queue in O(1) time.\n        Blocks if the queue is empty until an item becomes available.\n        \"\"\"\n        with self.lock:\n            # The while loop is crucial to guard against spurious wake-ups.\n            while self.head is None:\n                self.condition.wait()\n            \n            # At this point, self.head is guaranteed to be non-None.\n            value = self.head.value\n            self.head = self.head.next\n            \n            if self.head is None:\n                # The queue has become empty.\n                self.tail = None\n            \n            return value\n\ndef solve():\n    \"\"\"\n    Executes the test suite specified in the problem statement to validate\n    the BlockingQueue implementation.\n    \"\"\"\n    results = []\n\n    # Case 1: Happy path blocking\n    q1 = BlockingQueue()\n    consumer_result1 = []\n    def consumer_task_1():\n        start_time = time.monotonic()\n        val = q1.blocking_dequeue()\n        end_time = time.monotonic()\n        wait_time = end_time - start_time\n        consumer_result1.append((val, wait_time))\n    def producer_task_1(delay, value):\n        time.sleep(delay)\n        q1.enqueue(value)\n\n    delay1 = 0.08\n    tolerance1 = 0.01\n    enqueued_value1 = 42\n    \n    c1 = threading.Thread(target=consumer_task_1)\n    p1 = threading.Thread(target=producer_task_1, args=(delay1, enqueued_value1))\n    \n    c1.start()\n    p1.start()\n    c1.join()\n    p1.join()\n    \n    dequeued_value1, wait_time1 = consumer_result1[0]\n    results.append(wait_time1 >= (delay1 - tolerance1) and dequeued_value1 == enqueued_value1)\n\n    # Case 2: FIFO ordering under staggered enqueues\n    q2 = BlockingQueue()\n    dequeued_values2 = []\n    def consumer_task_2():\n        for _ in range(3):\n            dequeued_values2.append(q2.blocking_dequeue())\n    def producer_task_2():\n        enqueued_items = [(0.02, 10), (0.05, 20), (0.07, 30)]\n        current_time = 0\n        for delay, value in enqueued_items:\n            time.sleep(delay - current_time)\n            q2.enqueue(value)\n            current_time = delay\n\n    c2 = threading.Thread(target=consumer_task_2)\n    p2 = threading.Thread(target=producer_task_2)\n\n    c2.start()\n    p2.start()\n    c2.join()\n    p2.join()\n    \n    results.append(dequeued_values2 == [10, 20, 30])\n\n    # Case 3: Multiple consumers fairness\n    q3 = BlockingQueue()\n    results_q3 = queue.Queue()\n    enqueued_values3 = {101, 102, 103}\n    def consumer_task_3():\n        results_q3.put(q3.blocking_dequeue())\n    def producer_task_3():\n        time.sleep(0.05)\n        for val in enqueued_values3:\n            q3.enqueue(val)\n\n    consumers3 = [threading.Thread(target=consumer_task_3) for _ in range(3)]\n    producer3 = threading.Thread(target=producer_task_3)\n    \n    for c in consumers3:\n        c.start()\n    producer3.start()\n    \n    for c in consumers3:\n        c.join()\n    producer3.join()\n    \n    dequeued_values3 = set()\n    while not results_q3.empty():\n        dequeued_values3.add(results_q3.get())\n\n    results.append(dequeued_values3 == enqueued_values3)\n\n    # Case 4: Immediate availability\n    q4 = BlockingQueue()\n    consumer_result4 = []\n    q4.enqueue(99) # Enqueue before consumer starts\n    def consumer_task_4():\n        start_time = time.monotonic()\n        val = q4.blocking_dequeue()\n        end_time = time.monotonic()\n        wait_time = end_time - start_time\n        consumer_result4.append((val, wait_time))\n\n    c4 = threading.Thread(target=consumer_task_4)\n    c4.start()\n    c4.join()\n\n    _, wait_time4 = consumer_result4[0]\n    results.append(wait_time4  0.01)\n\n    # Case 5: Spurious wake-up guard\n    q5 = BlockingQueue()\n    consumer_result5 = []\n    def consumer_task_5():\n        start_time = time.monotonic()\n        val = q5.blocking_dequeue()\n        end_time = time.monotonic()\n        wait_time = end_time - start_time\n        consumer_result5.append((val, wait_time))\n\n    def notifier_task_5():\n        time.sleep(0.02)\n        with q5.lock:\n            q5.condition.notify()\n\n    def producer_task_5():\n        time.sleep(0.05)  # 0.02 + 0.03\n        q5.enqueue(55)\n\n    c5 = threading.Thread(target=consumer_task_5)\n    n5 = threading.Thread(target=notifier_task_5)\n    p5 = threading.Thread(target=producer_task_5)\n    \n    c5.start()\n    n5.start()\n    p5.start()\n\n    c5.join()\n    n5.join()\n    p5.join()\n\n    _, wait_time5 = consumer_result5[0]\n    total_producer_delay = 0.05\n    tolerance5 = 0.01\n    results.append(wait_time5 >= (total_producer_delay - tolerance5))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3246704"}]}