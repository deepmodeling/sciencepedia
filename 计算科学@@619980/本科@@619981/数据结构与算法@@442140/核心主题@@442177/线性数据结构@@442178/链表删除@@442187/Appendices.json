{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。本节将从链表删除最基本的操作开始：删除头节点、尾节点和指定索引的节点。这个练习 [@problem_id:3245711] 将帮助你深入理解单向链表的核心约束——即删除一个节点（头节点除外）必须先找到其前驱节点，并让你体会不同删除操作之间的时间复杂度差异。", "problem": "给定一个单链表的定义：一个节点的有限序列，每个节点存储一个非负整数键和一个指向下一个节点的引用，最后一个节点存储一个空引用。删除操作通过移除一个节点并根据需要重新链接引用来改变列表。使用单链表作为抽象数据类型（ADT）的基本原理，设计并实现以下操作，这些操作会转换一个头指针为 $H$ 的列表：\n- 操作 $delete\\_head(H)$：如果头节点存在，则移除它，并返回一个包含新头指针和被移除键的对。如果列表为空，则返回未改变的空头指针和整数 $-1$。\n- 操作 $delete\\_tail(H)$：如果尾节点存在，则移除它，并返回一个包含（可能更新的）头指针和被移除键的对。如果列表为空，则返回未改变的空头指针和整数 $-1$。\n- 操作 $delete\\_index(H,i)$（对于整数索引 $i \\ge 0$）：如果从零开始的位置 $i$ 上的节点存在，则移除它，并返回一个包含（可能更新的）头指针和被移除键的对。如果不存在这样的节点，则返回未改变的头指针和整数 $-1$。\n\n你的实现必须严格遵循单链表的核心定义：每个节点只有一个指向其后继节点的引用，没有前驱引用。你必须基于此来设计算法，包括确定在执行删除之前是否必须通过遍历来发现前驱节点。你必须确保以下属性成立：\n- 对于 $delete\\_head(H)$，操作在 $\\mathcal{O}(1)$ 时间内运行，因为只触及 $H$ 和至多下一个引用。\n- 对于 $delete\\_tail(H)$，在最坏情况下，操作在 $\\mathcal{O}(n)$ 时间内运行，其中 $n$ 是节点数，因为必须通过遍历找到最后一个节点的唯一前驱。\n- 对于 $delete\\_index(H,i)$，在最坏情况下，操作在 $\\mathcal{O}(n)$ 时间内运行，因为当 $i \\ge 1$ 时，必须通过遍历找到索引 $i$ 处节点的唯一前驱。\n\n为了使结果可量化且可由机器检查，你的程序必须将一系列操作应用于指定的初始列表，并为每个测试用例报告两个产物：\n- 被移除键的有序列表，每个操作对应一个，当无法删除时使用整数 $-1$。\n- 最终列表，以普通整数数组（从头到尾的键）的形式表示。所有初始列表中的所有键都是非负整数，因此整数 $-1$ 是“未执行删除”的无歧义哨兵值。\n\n输入在程序中是固定的；没有外部输入。使用以下测试套件，其中每个测试用例包含一个初始列表和一系列操作。使用以下操作码：$H$ 代表 $delete\\_head$，$T$ 代表 $delete\\_tail$，$I$ 带有整数参数代表 $delete\\_index$。\n- 测试用例 $1$：初始列表 $[1, 2, 3, 4, 5]$，操作 $[(H), (I, 2), (T)]$。\n- 测试用例 $2$：初始列表 $[10]$，操作 $[(H), (T), (I, 0)]$。\n- 测试用例 $3$：初始列表 $[7, 8]$，操作 $[(I, 0), (I, 1), (T)]$。\n- 测试用例 $4$：初始列表 $[9, 9, 9]$，操作 $[(T), (I, 1), (H)]$。\n- 测试用例 $5$：初始列表 $[0, 1, 2]$，操作 $[(I, 5), (T), (I, 1), (H)]$。\n- 测试用例 $6$：初始列表 $[]$，操作 $[(H), (T), (I, 0)]$。\n\n你的程序必须生成单行输出，其中包含所有测试用例的结果，结果为用方括号括起来的逗号分隔列表。对于每个测试用例，结果是一个包含两个元素的列表：第一个元素是被移除键的列表（在适用时使用 $-1$），第二个元素是最终列表。具体来说，整体输出格式是单行形式\n$[\\text{案例\\_1\\_结果},\\text{案例\\_2\\_结果},\\ldots,\\text{案例\\_6\\_结果}]$，\n其中每个 $\\text{案例\\_k\\_结果}$ 的形式为 $[\\text{移除的键}, \\text{最终列表}]$。\n\n此问题不涉及物理单位、角度或百分比。所有输出均为整数或整数列表。程序不得读取任何输入，并且必须按上述格式精确打印一行。", "solution": "该问题要求为单链表设计并实现三个基本的删除操作：删除头节点、删除尾节点以及删除位于特定从零开始的索引 $i$ 处的节点。设计必须从基本原理出发，承认在单链表中，每个节点只包含对其后继节点的引用，而不包含对其前驱节点的引用。\n\n单链表是一种抽象数据类型（ADT），定义为节点的序列。每个节点包含两个字段：一个值（在此情况下为非负整数键）和一个指向序列中下一个节点的引用（或指针）。通过头指针 $H$ 访问列表，它引用第一个节点。最后一个节点的 `next` 引用为 null，表示列表的结束。空列表由空头指针 $H$ 表示。\n\n让我们将节点结构定义为 `Node(key, next)`。\n\n**1. 操作 $delete\\_head(H)$**\n\n此操作移除列表的第一个节点。\n\n*   **原理与设计**：头节点可通过指针 $H$ 直接访问。要删除它，我们必须更新 $H$ 以指向列表中的第二个节点。原始第二个节点的引用存储在原始头节点的 `next` 字段中。\n*   **算法**：\n    1.  检查列表是否为空（即 $H$ 是否为 null）。如果是，则无法执行删除。根据问题规范，我们返回未改变的空头指针和哨兵值 $-1$。\n    2.  如果列表不为空，要移除的节点是 $H$ 指向的节点。我们存储其键，称之为 $k_{removed}$，作为返回值。\n    3.  列表的新头将是当前头的后继节点。我们通过赋值 $H = H.next$ 来更新头指针。\n    4.  返回新的头指针和被移除的键 $k_{removed}$。\n*   **复杂度分析**：此操作涉及一次空检查、获取一个键和一次指针重分配。这些都是基本的、常数时间的操作。因此，时间复杂度为 $\\mathcal{O}(1)$，满足题目要求。\n\n**2. 操作 $delete\\_tail(H)$**\n\n此操作移除列表的最后一个节点。\n\n*   **原理与设计**：尾节点定义为其 `next` 指针为 null 的节点。要移除它，我们必须修改其前驱节点，将前驱节点的 `next` 指针设置为 null。由于单链表没有提供直接访问节点前驱的方法，我们必须从头指针 $H$ 开始遍历列表以找到尾节点的前驱。\n*   **算法**：\n    1.  处理空列表情况：如果 $H$ 为 null，返回 $(H, -1)$。\n    2.  处理单节点列表情况：如果 $H.next$ 为 null，则头节点也是尾节点。这简化为删除头节点。我们存储键，将 $H$ 设置为 null，并返回新的空头指针和存储的键。\n    3.  对于拥有 $n > 1$ 个节点的列表，我们必须找到尾节点的前驱。我们可以使用双指针遍历。让 `current` 作为一个遍历列表的指针，`previous` 作为一个总是落后 `current` 一步的指针。\n    4.  初始化 `previous = H` 和 `current = H.next`。\n    5.  遍历列表直到 `current.next` 为 null。在每一步中，同时推进两个指针：`previous = current`，`current = current.next`。\n    6.  当循环终止时，`current` 指向尾节点，`previous` 指向其前驱（新的尾节点）。\n    7.  存储尾节点的键 `current.key`。\n    8.  将新尾节点的 `next` 引用更新为 null：`previous.next = null`。\n    9.  返回原始头指针 $H$（除非列表只有一个节点，否则它不变）和被移除的键。\n*   **复杂度分析**：对于大小为 $n$ 的列表，找到尾节点的前驱在最坏情况下需要遍历 $n-1$ 个节点（对于 $n > 1$）。遍历主导了运行时间。因此，时间复杂度为 $\\mathcal{O}(n)$，符合要求。\n\n**3. 操作 $delete\\_index(H, i)$**\n\n此操作移除位于给定从零开始的索引 $i \\ge 0$ 处的节点。\n\n*   **原理与设计**：\n    *   如果索引 $i$ 是 $0$，此操作与 $delete\\_head(H)$ 相同。\n    *   如果索引 $i$ 大于 $0$，我们必须移除位置 $i$ 处的节点。为此，我们需要将位置 $i-1$ 处的节点连接到位置 $i+1$ 处的节点。这需要通过从头开始遍历列表来找到位置 $i-1$ 处的节点（前驱）。\n*   **算法**：\n    1.  验证索引和列表状态。如果 $H$ 为 null 或 $i  0$，则索引无效或列表为空。我们可以返回 $(H, -1)$。题目保证 $i \\ge 0$。\n    2.  处理 $i=0$ 的情况：这等同于删除头节点。我们可以简单地调用我们的 $delete\\_head(H)$ 逻辑并返回其结果。\n    3.  处理 $i  0$ 的情况：我们需要找到索引 $i-1$ 处的前驱节点。\n    4.  初始化一个指针 `previous = H` 和一个计数器 `count = 0`。\n    5.  遍历列表，推进 `previous` 并增加 `count`，直到 `count` 达到 $i-1$。循环条件应该是 `count  i - 1` 并且 `previous.next` 不为 null。`previous.next` 检查对于优雅地处理越界索引 $i$ 至关重要。\n    6.  循环结束后，检查遍历是否成功。如果 `previous` 为 null 或 `previous.next` 为 null，这意味着我们在找到索引 $i$ 处的节点之前到达了列表的末尾。因此，索引越界。返回 $(H, -1)$。\n    7.  如果找到了前驱，设 `node_to_delete = previous.next`。\n    8.  存储 `node_to_delete` 的键。\n    9.  通过更新前驱的 `next` 指针来绕过该节点：`previous.next = node_to_delete.next`。\n    10. 返回（未改变的）头指针 $H$ 和被移除的键。\n*   **复杂度分析**：\n    *   对于 $i=0$，复杂度为 $\\mathcal{O}(1)$。\n    *   对于 $i > 0$，算法必须执行 $i-1$ 步的遍历以找到前驱。在最坏情况下，$i$ 可能是 $n-1$，需要 $n-2$ 步的遍历。因此，最坏情况下的时间复杂度与 $n$ 成正比，即 $\\mathcal{O}(n)$，满足题目要求。\n\n这些设计严格遵守单链表的约束，并为以下实现提供了基础。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    Represents a node in a singly linked list.\n    Each node has a non-negative integer key and a reference to the next node.\n    \"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.next = None\n\ndef build_list(keys):\n    \"\"\"\n    Builds a singly linked list from a list of keys.\n    Returns the head of the list.\n    \"\"\"\n    if not keys:\n        return None\n    head = Node(keys[0])\n    current = head\n    for key in keys[1:]:\n        current.next = Node(key)\n        current = current.next\n    return head\n\ndef list_to_array(head):\n    \"\"\"\n    Converts a singly linked list to a Python list of its keys.\n    \"\"\"\n    arr = []\n    current = head\n    while current:\n        arr.append(current.key)\n        current = current.next\n    return arr\n\ndef delete_head(head):\n    \"\"\"\n    Removes the head node if it exists.\n    Returns a pair (new head pointer, removed key).\n    If the list is empty, returns (null head, -1).\n    Time complexity: O(1).\n    \"\"\"\n    if not head:\n        return None, -1\n    \n    removed_key = head.key\n    new_head = head.next\n    return new_head, removed_key\n\ndef delete_tail(head):\n    \"\"\"\n    Removes the tail node if it exists.\n    Returns a pair ((possibly updated) head pointer, removed key).\n    If the list is empty, returns (null head, -1).\n    Time complexity: O(n).\n    \"\"\"\n    if not head:\n        return None, -1\n\n    # Case: Single node in the list\n    if not head.next:\n        removed_key = head.key\n        return None, removed_key\n\n    # Case: More than one node\n    # Traverse to find the second-to-last node\n    previous = head\n    current = head.next\n    while current.next:\n        previous = current\n        current = current.next\n    \n    removed_key = current.key\n    previous.next = None\n    return head, removed_key\n\ndef delete_index(head, i):\n    \"\"\"\n    Removes the node at zero-based position i.\n    Returns a pair ((possibly updated) head pointer, removed key).\n    If no such node exists, returns (unchanged head, -1).\n    Time complexity: O(n) in the worst case.\n    \"\"\"\n    if i  0 or not head:\n        return head, -1\n    \n    # Case: Delete head (i=0)\n    if i == 0:\n        return delete_head(head)\n\n    # Case: Delete at i > 0\n    # Traverse to the predecessor at index i-1\n    previous = head\n    count = 0\n    while count  i - 1 and previous:\n        previous = previous.next\n        count += 1\n    \n    # Check if index is out of bounds\n    if not previous or not previous.next:\n        return head, -1\n        \n    node_to_delete = previous.next\n    removed_key = node_to_delete.key\n    previous.next = node_to_delete.next\n    \n    return head, removed_key\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        ([1, 2, 3, 4, 5], [('H',), ('I', 2), ('T',)]),\n        # Test case 2\n        ([10], [('H',), ('T',), ('I', 0)]),\n        # Test case 3\n        ([7, 8], [('I', 0), ('I', 1), ('T',)]),\n        # Test case 4\n        ([9, 9, 9], [('T',), ('I', 1), ('H',)]),\n        # Test case 5\n        ([0, 1, 2], [('I', 5), ('T',), ('I', 1), ('H',)]),\n        # Test case 6\n        ([], [('H',), ('T',), ('I', 0)]),\n    ]\n\n    all_results = []\n    for initial_keys, operations in test_cases:\n        head = build_list(initial_keys)\n        removed_keys = []\n\n        for op in operations:\n            op_code = op[0]\n            removed_key = -1\n            if op_code == 'H':\n                head, removed_key = delete_head(head)\n            elif op_code == 'T':\n                head, removed_key = delete_tail(head)\n            elif op_code == 'I':\n                index = op[1]\n                head, removed_key = delete_index(head, index)\n            \n            removed_keys.append(removed_key)\n\n        final_list_array = list_to_array(head)\n        case_result = [removed_keys, final_list_array]\n        all_results.append(case_result)\n    \n    # Using str() on a list gives a compact representation like '[1,2,3]'\n    # Joining these string representations with a comma produces the final format.\n    results_str = ','.join(map(str, all_results))\n    \n    # The final output requires a specific format which includes replacing spaces\n    # that python's default str() for lists creates. e.g., '[1, 2]' becomes '[1,2]'\n    final_output_str = f\"[{results_str.replace(' ', '')}]\"\n    \n    print(final_output_str)\n\nsolve()\n```", "id": "3245711"}, {"introduction": "在掌握了基础删除后，我们来挑战一个更具技巧性的问题：如何在一次遍历内删除链表的倒数第 $k$ 个节点。这个练习 [@problem_id:3245572] 将引导你学习并应用一种强大而通用的算法模式——双指针技术。通过维护两个指针之间的固定距离，我们可以在单次遍历中解决看似需要两次遍历才能解决的问题。", "problem": "给定单向链表和指针操作的核心定义作为基础。单向链表是一个节点的有限序列，每个节点存储一个数据值和一个指向下一个节点的指针。形式上，一个链表可以表示为长度为 $n$ 的序列 $L = \\langle x_0, x_1, \\dots, x_{n-1} \\rangle$，其中对于 $i \\in \\{0,1,\\dots,n-1\\}$ 的每个节点 $x_i$，当 $i \\le n-2$ 时包含一个指向 $x_{i+1}$ 的引用，而 $x_{n-1}$ 包含一个指向空哨兵（表示链表结束）的引用。删除位置 $i$（$i \\in \\{0,1,\\dots,n-1\\}$）的节点，需要更新位置 $i-1$ 的节点中存储的指针（如果 $i=0$ 则调整头指针），使其指向位置 $i+1$ 的节点（如果 $i=n-1$ 则指向空）。沿单向链表的指针移动遵循以下规则：当 $i \\le n-2$ 时，前进一步会从节点 $x_i$ 移动到节点 $x_{i+1}$；当 $i=n-1$ 时，移动到空。\n\n任务：实现一个单次遍历算法，删除链表中倒数第 $k$ 个节点。给定指向链表 $L$ 的头指针和一个整数 $k \\ge 0$，你的算法必须最多从头到尾遍历一次（即每个节点总体上最多访问一次），并使用 $O(1)$ 的辅助空间。要求的行为如下：\n- 如果 $k = 0$，不移除任何节点，并返回未作更改的原始链表。\n- 如果 $k \\in \\{1,2,\\dots,n\\}$，移除索引为 $n - k$ 的节点（头节点索引为 $0$）。\n- 如果 $k  n$，不移除任何节点，并返回未作更改的原始链表。\n- 如果 $n = 0$（链表为空），对任何 $k$ 都返回空链表。\n\n你必须根据上述核心定义从逻辑上推导出你的算法，不得依赖任何未经解释的捷径。该算法必须可以通过维持一个不变量来实现单次遍历，该不变量能在到达链表末尾时正确识别待删除节点的前驱节点。\n\n你的程序的输入格式在内部是固定的；没有外部输入。你的程序应该嵌入并运行以下测试套件，其中每个测试用例包含一个链表和一个 $k$ 值。每个链表以数学序列的形式写出，$k$ 是一个整数。为清晰起见，下面的链表应被解释为顺序相同的整数序列：\n- 测试 $1$：$L = \\langle 1,2,3,4,5 \\rangle$，$k=2$。\n- 测试 $2$：$L = \\langle 10 \\rangle$，$k=1$。\n- 测试 $3$：$L = \\langle \\rangle$，$k=1$。\n- 测试 $4$：$L = \\langle 7,8,9 \\rangle$，$k=3$。\n- 测试 $5$：$L = \\langle 1,2,3 \\rangle$，$k=4$。\n- 测试 $6$：$L = \\langle 1,1,1,1 \\rangle$，$k=1$。\n- 测试 $7$：$L = \\langle 5,6 \\rangle$，$k=2$。\n- 测试 $8$：$L = \\langle 2,3,4,5 \\rangle$，$k=0$。\n- 测试 $9$：$L = \\langle 1,2,3 \\rangle$，$k=2$。\n- 测试 $10$：$L = \\langle 9,8,7,6,5 \\rangle$，$k=5$。\n\n对于每个测试，你的程序必须在应用上述删除规则后计算出结果链表。最终输出必须将所有结果聚合在一行中，格式如下：一个用方括号括起来的逗号分隔列表，其中每个元素本身就是用方括号写成且不含空格的结果链表。例如，如果前两个结果是 $\\langle 1,3,5 \\rangle$ 和 $\\langle \\rangle$，它们将显示为 `[[1,3,5],[]]`。具体来说，你的程序必须精确地打印一行，格式为一个由方括号括起来的列表，其中每个元素本身也是一个表示结果链表的列表，如 `[[1,3,5],[],[7]]`。所有列表表示中均不应包含空格。", "solution": "问题陈述是有效的。它提出了一个关于数据结构的定义明确的算法任务，具体是在严格的性能限制下从单向链表中删除一个节点。该问题在科学上基于基础的计算机科学原理，提供了一套完整且一致的规则，并使用了客观、正式的语言。因此，我们可以着手提出解决方案。\n\n任务是设计一个使用 $O(1)$ 辅助空间的单次遍历算法，从长度为 $n$ 的单向链表 $L$ 中删除倒数第 $k$ 个节点。该链表由其头指针给出。删除规则针对所有非负整数 $k$ 值都已指定。\n\n设链表为 $L = \\langle x_0, x_1, \\dots, x_{n-1} \\rangle$。要删除的节点是倒数第 $k$ 个，对应于索引为 $n-k$ 的节点（对于 $k \\in \\{1, 2, \\dots, n\\}$）。为了执行删除操作，我们必须修改其前驱节点（即索引为 $n-k-1$ 的节点）的 `next` 指针。在不先计算长度 $n$ 的情况下，单次遍历定位这个前驱节点是核心挑战。单次遍历和 $O(1)$ 空间约束排除了简单的两次遍历方法（第一次遍历找到 $n$，第二次遍历迭代到节点 $n-k-1$）。\n\n该问题可以通过在两个指针遍历链表时保持它们之间的固定距离来解决。这通常被称为双指针技术。让我们来形式化地推导该算法。\n\n为了透明地处理边界情况，例如删除链表头（当 $k=n$ 时）或处理空链表，我们引入一个哨兵节点，我们称之为 `dummy`。这个 `dummy` 节点被放置在链表的实际头节点之前，使得 `dummy.next` 指向原始的头节点 $x_0$。我们的算法将返回 `dummy.next` 作为链表的新头节点。\n\n该算法的步骤如下：\n\n1.  **初始检查**：根据问题规范，如果 $k=0$，则不进行删除操作。算法应立即返回原始链表。如果链表为空（$n=0$），`head` 指针为 `null`，算法应返回 `null` 指针。\n\n2.  **指针初始化**：我们初始化两个指针，分别称为 `slow` 和 `fast`，它们都从 `dummy` 节点开始。\n    $$ \\text{slow} \\leftarrow \\text{dummy} $$\n    $$ \\text{fast} \\leftarrow \\text{dummy} $$\n\n3.  **建立间距**：核心思想是在 `slow` 和 `fast` 指针之间创建一个 $k$ 个节点的间距。我们通过将 `fast` 指针从其初始位置向前移动 $k$ 步来实现这一点。\n    $$ \\text{for } i \\text{ from } 1 \\text{ to } k: $$\n    $$ \\quad \\text{fast} \\leftarrow \\text{fast.next} $$\n    在此阶段，我们必须处理 $k  n$ 的情况。如果 `fast` 在任何时候变为空，则意味着链表的节点数少于 $k$。在这种情况下，根据规范，链表保持不变。因此，我们在循环内检查 `fast` 是否为空，如果满足条件，则返回原始的 `head`。\n\n4.  **同步遍历**：在 `fast` 指针前进了 $k$ 步之后，我们开始同步地将两个指针一次一步地向前移动，直到 `fast` 指针到达链表的最后一个节点。循环的终止条件是 `fast.next` 为 `null`。\n    $$ \\text{while fast.next is not null}: $$\n    $$ \\quad \\text{slow} \\leftarrow \\text{slow.next} $$\n    $$ \\quad \\text{fast} \\leftarrow \\text{fast.next} $$\n\n    让我们分析指针的最终位置，以确认此过程的正确性。设链表长度为 $n$。`slow` 指针从有效索引 $-1$（`dummy` 节点）开始，而 `fast` 指针在初始前进 $k$ 步后从索引 $k-1$ 开始。然后两个指针同步前进相同的步数，假设为 $m$ 步，直到 `fast` 到达索引为 $n-1$ 的最后一个节点。`fast` 的最终索引是 $(k-1) + m$。将其与最后一个节点的索引相等，我们得到：\n    $$ (k-1) + m = n-1 \\implies m = n-k $$\n    `slow` 指针也从其起始位置索引 $-1$ 移动了 $m = n-k$ 步。因此它的最终位置是：\n    $$ \\text{index}(\\text{slow}) = -1 + m = -1 + (n-k) = n-k-1 $$\n    这恰好是待删除节点（位于索引 $n-k$）的前驱节点的索引。不变量——即 `fast` 比 `slow` 领先 $k$ 个节点——确保了当 `fast` 遍历到末尾时，`slow` 被正确定位。\n\n5.  **节点删除**：当 `slow` 指向目标节点的前驱节点时，删除操作就只是一个简单的指针操作。`slow` 的 `next` 指针被更新以绕过目标节点：\n    $$ \\text{slow.next} \\leftarrow \\text{slow.next.next} $$\n\n6.  **返回值**：最终可能已被修改的链表由 `dummy.next` 作为头节点。返回此指针。\n\n该算法能正确处理所有指定的情况。对于 $k=n$ 的情况，`fast` 指针在初始前进 $k$ 步后恰好落在最后一个节点上，因此 `while` 循环不会执行。`slow` 指针保持在 `dummy` 节点。删除步骤 `dummy.next = dummy.next.next` 正确地移除了原始的头节点。该算法只遍历链表一次，并使用常数个辅助变量（`dummy`、`slow`、`fast`），因此满足 $O(1)$ 空间和单次遍历的约束。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Definition for singly-linked list node.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the formatted output.\n    \"\"\"\n\n    test_cases = [\n        ([1, 2, 3, 4, 5], 2),\n        ([10], 1),\n        ([], 1),\n        ([7, 8, 9], 3),\n        ([1, 2, 3], 4),\n        ([1, 1, 1, 1], 1),\n        ([5, 6], 2),\n        ([2, 3, 4, 5], 0),\n        ([1, 2, 3], 2),\n        ([9, 8, 7, 6, 5], 5)\n    ]\n\n    def build_list(values: list[int]) - ListNode | None:\n        \"\"\"Helper to build a linked list from a Python list of values.\"\"\"\n        if not values:\n            return None\n        dummy = ListNode()\n        current = dummy\n        for val in values:\n            current.next = ListNode(val)\n            current = current.next\n        return dummy.next\n\n    def list_to_py_list(head: ListNode | None) - list[int]:\n        \"\"\"Helper to convert a linked list back to a Python list.\"\"\"\n        result = []\n        current = head\n        while current:\n            result.append(current.val)\n            current = current.next\n        return result\n    \n    def removeNthFromEnd(head: ListNode | None, k: int) - ListNode | None:\n        \"\"\"\n        Deletes the k-th node from the end of the list using the two-pointer approach.\n        k >= 0.\n        \"\"\"\n        if k == 0:\n            return head\n\n        dummy = ListNode(0, head)\n        left = dummy\n        right = head\n\n        # Advance right pointer k steps\n        for _ in range(k):\n             if not right: # k > n\n                 return head\n             right = right.next\n        \n        # Move both until right reaches end\n        while right:\n            left = left.next\n            right = right.next\n        \n        # left is now the predecessor of the node to delete\n        left.next = left.next.next\n        \n        return dummy.next\n\n    results = []\n    for case in test_cases:\n        list_vals, k_val = case\n        linked_list_head = build_list(list_vals)\n        \n        # Call the algorithm\n        modified_head = removeNthFromEnd(linked_list_head, k_val)\n        \n        # Convert result back to Python list\n        result_py_list = list_to_py_list(modified_head)\n        \n        # Format the list as a string without spaces\n        result_str = str(result_py_list).replace(\" \", \"\")\n        results.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3245572"}, {"introduction": "最后的练习是一个经典的链表谜题，它将挑战你的常规思维。想象一下，如果只给你一个指向待删除节点的指针，而没有头节点或前驱节点的引用，你该如何删除它？这个问题 [@problem_id:3245621] 迫使我们跳出常规的“修改前驱指针”的框架，通过巧妙地复制数据来实现逻辑上的删除，从而深化对指针和数据结构本质的理解。", "problem": "给定单向链表的定义：每个节点存储一个整数值和对下一个节点的引用，如果是最后一个节点，则引用为空。你有一个指向该链表内部某个节点的引用，但你没有直接指向链表头或前一个节点的引用。你的目标是实现一个函数，尝试删除由该单个引用标识的节点。该函数必须在以下基本约束和不变量下运行：\n\n- 单向链表由节点组成，每个节点都有一个用于存储值的字段和一个引用下一个节点的字段。没有向后的引用。形式上，一个链表是节点序列 $\\langle n_0, n_1, \\dots, n_{k-1} \\rangle$，其中对于 $0 \\le i  k-1$，每个 $n_i.\\text{next} = n_{i+1}$，且 $n_{k-1}.\\text{next} = \\text{null}$。\n- 你只被提供了一个指向链表中某个节点 $n_i$ 的引用，其索引为 $i$，其中 $0 \\le i \\le k-1$。除非 $i = 0$，否则你没有指向 $n_{i-1}$ 或头节点 $n_0$ 的引用。\n- 你可以读取和写入所提供节点及其后继节点（如果存在）的字段。由于没有向后引用，你不能遍历到任何更早的节点。\n\n任务：实现一个函数，在仅给定指向节点 $n_i$ 的指针的情况下，尝试从链表中删除该节点，同时保持所有其他节点的相对顺序。该函数必须在 $O(1)$ 时间内运行并使用 $O(1)$ 的额外空间。如果在此约束下无法删除该节点（例如，当 $n_i$ 是尾节点时），函数必须报告失败并且不更改链表。\n\n测试输入模型：你的程序将在内部构建几个链表，并为每个链表通过其索引获取一个指向目标节点的指针。然后，它将使用该节点指针调用你的删除函数，并通过原始的头引用观察结果链表。不需要用户输入。\n\n输出规范：对于每个测试用例，输出一个形式为 $[\\text{success}, L]$ 的结果，其中 $\\text{success}$ 是一个布尔值，指示删除是否执行，而 $L$ 是尝试操作后从原始头节点观察到的整数列表。将每个测试用例的结果聚合成一个单一列表，并打印一行包含该聚合列表的内容，格式为 $[r_1,r_2,\\dots,r_m]$，其中每个 $r_j$ 本身的形式为 $[\\text{success}, L]$。\n\n覆盖核心行为的测试套件：\n\n- 案例 $1$ (中间删除，正常路径)：初始列表 $[1,2,3,4,5]$，删除索引 $2$ (值 $3$) 。预期成功。\n- 案例 $2$ (仅使用头指针删除头节点)：初始列表 $[1,2,3]$，删除索引 $0$ (值 $1$) 。预期成功。\n- 案例 $3$ (尾部删除，不可能)：初始列表 $[1,2,3]$，删除索引 $2$ (值 $3$) 。预期失败，列表不变。\n- 案例 $4$ (单节点列表，不可能)：初始列表 $[42]$，删除索引 $0$ (唯一的节点，既是头也是尾)。预期失败，列表不变。\n- 案例 $5$ (重复值，结构正确性)：初始列表 $[5,5,5]$，删除索引 $1$ (中间的重复值)。预期成功，一个重复项被移除。\n- 案例 $6$ (靠近尾部的边界情况)：初始列表 $[1,2,3,4,5,6]$，删除索引 $4$ (倒数第二个位置，值 $5$) 。预期成功。\n\n正确性的形式化要求：\n\n- 如果 $\\text{success} = \\text{true}$，则输出列表等于原始序列中移除了位置 $i$ 的元素后的序列，且保持顺序，用于遍历的头引用与删除前是同一个对象引用。\n- 如果 $\\text{success} = \\text{false}$，则输出列表必须与原始序列完全相同。\n\n最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表，例如 $[[\\text{true},[1,2,4,5]],[\\text{false},[1,2,3]]]$。此问题不涉及任何物理单位、角度或百分比；所有答案都是纯粹结构性和逻辑性的。", "solution": "在尝试提供解决方案之前，将对问题 R-0 的陈述进行验证。\n\n### 步骤 1：提取已知条件\n\n1.  **数据结构定义**：单向链表是节点序列 $\\langle n_0, n_1, \\dots, n_{k-1} \\rangle$。每个节点 $n_i$ 包含一个值和一个引用 $n_i.\\text{next}$。对于 $0 \\le i  k-1$，$n_i.\\text{next}$ 指向 $n_{i+1}$。最后一个节点的引用为空，即 $n_{k-1}.\\text{next} = \\text{null}$。没有向后引用。\n2.  **输入约束**：函数只被提供一个指向链表中某个节点 $n_i$ 的引用，其索引 $i$ 满足 $0 \\le i \\le k-1$。没有提供指向头节点 $n_0$（除非 $i=0$）或前一个节点 $n_{i-1}$ 的引用。\n3.  **允许的操作**：可以读取和写入给定节点 $n_i$ 及其后继节点 $n_{i+1}$（如果存在）的字段。不能遍历到更早的节点。\n4.  **任务**：实现一个函数，尝试从链表中删除指定的节点 $n_i$，同时保持其他节点的相对顺序。\n5.  **性能约束**：函数必须在 $O(1)$ 时间内运行，并使用 $O(1)$ 的额外空间。\n6.  **失败条件**：如果在给定约束下无法删除节点（例如，如果 $n_i$ 是尾节点），函数必须报告失败并且不更改链表。\n7.  **测试用例**：\n    - 案例 1：列表 $[1,2,3,4,5]$，删除索引 $2$ (值 $3$) 。预期：成功。\n    - 案例 2：列表 $[1,2,3]$，删除索引 $0$ (值 $1$) 。预期：成功。\n    - 案例 3：列表 $[1,2,3]$，删除索引 $2$ (值 $3$) 。预期：失败。\n    - 案例 4：列表 $[42]$，删除索引 $0$。预期：失败。\n    - 案例 5：列表 $[5,5,5]$，删除索引 $1$。预期：成功。\n    - 案例 6：列表 $[1,2,3,4,5,6]$，删除索引 $4$ (值 $5$) 。预期：成功。\n8.  **输出规范**：程序的最终输出必须是单行，包含一个结果列表，其中每个结果的形式为 $[\\text{success}, L]$。例如：`[[true,[1,2,4,5]],[false,[1,2,3]]]`。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n问题经过严格验证。\n\n-   **科学依据**：该问题植根于计算机科学的基本原理，特别是基于指针的数据结构的理论和实现。单向链表是一种典型的结构，所描述的操作是标准的。该问题在科学上和逻辑上都是合理的。\n-   **适定性**：问题的目标定义明确：在特定的非标准约束下实现删除函数。成功和失败的条件都已明确说明，确保对于任何有效输入都有唯一且有意义的预期行为。测试套件提供了具体的例子来阐明所需的行为。\n-   **客观性**：问题陈述使用了形式化、精确和无歧义的语言。为关键术语（单向链表）提供了定义，并清晰地描述了约束条件。它不含主观或基于观点的内容。\n\n该问题没有表现出任何无效标志。核心挑战来自于无法访问待删除节点的前一个节点的约束。这不是一个矛盾，而是一个有意设置的约束，它使得标准的删除算法失效，并需要一种不同的方法。这是一个著名且有效的算法难题。\n\n### 步骤 3：结论与行动\n\n问题陈述是**有效的**。将开发一个解决方案。\n\n### 基于原则的解决方案设计\n\n从单向链表中删除节点 $n_i$ 的标准算法需要修改其前驱节点 $n_{i-1}$ 的指针以绕过 $n_i$。形式上，需要执行赋值操作 $n_{i-1}.\\text{next} := n_{i+1}$。给定的约束明确禁止了这一点，因为我们没有对 $n_{i-1}$ 的引用。\n\n必须重新构建问题。在没有访问其前驱节点的情况下，我们无法从链表结构本身移除给定的节点对象。但是，我们可以通过改变链表的*状态*来达到等效的结果。目标是使链表从头节点遍历时，看起来就像目标节点位置上的值已被删除。\n\n让待删除的节点表示为 $N$。我们被给予一个指向 $N$ 的引用。我们也可以访问它的后继节点 $N.\\text{next}$。关键的见解是我们可以修改节点 $N$ 的内容。\n\n提议的算法如下：\n\n1.  **识别限制情况**：该技术依赖于后继节点的存在。如果给定的节点 $N$ 是链表的尾节点，那么 $N.\\text{next}$ 为 $\\text{null}$。在这种情况下，我们没有后续节点可以从中复制数据。此外，我们无法将前驱节点的 `next` 指针更新为 $\\text{null}$，因为我们没有对前驱节点的引用。因此，在给定的约束下，删除尾节点是不可能的。这与问题要求对尾节点报告失败是一致的。这是唯一不可删除的情况。\n\n2.  **实现删除逻辑（针对非尾节点）**：如果节点 $N$ 不是尾节点，则存在一个后继节点 $N.\\text{next}$。我们可以通过将 $N$ 转换为其后继节点的逻辑副本来有效地“删除”$N$，然后删除该后继节点。\n    -   **步骤 2a：复制数据**：将后继节点 $N.\\text{next}$ 的值复制到当前节点 $N$ 中。即执行赋值操作 $N.\\text{value} := N.\\text{next}.\\text{value}$。此时，链表在逻辑上包含后继节点值的副本，而 $N$ 的原始值已被覆盖。\n    -   **步骤 2b：断开后继节点链接**：修改节点 $N$ 的 `next` 指针，以绕过其原始的后继节点。这通过赋值 $N.\\text{next} := N.\\text{next}.\\text{next}$ 来实现。此操作有效地从链表中移除了原始的后继节点。\n\n结果是节点对象 $N$ 仍然在链表结构中，但它现在持有其原始后继节点的值，并且链表缩短了一个节点。从头节点看，值的序列与目标节点被正确删除后的列表完全相同。\n\n这个过程涉及少量、恒定数量的赋值和指针解引用。因此，它在 $O(1)$ 时间内执行，并需要 $O(1)$ 的辅助空间，满足所有问题约束。\n\n让我们用一个例子来追踪这个逻辑：`list = [1, 2, 3, 4]`，我们被给予一个指向包含值 $3$ 的节点的引用。我们称这个节点为 $N_3$。\n\n-   $N_3$ 不是尾节点；其后继节点 $N_4$ (包含值 $4$) 存在。\n-   将值从 $N_4$ 复制到 $N_3$。链表在逻辑上变为 `[1, 2, 4, 4]`。原来持有 $3$ 的节点现在持有 $4$。\n-   更新 $N_3$ 的 `next` 指针，使其指向 $N_4$ 的后继节点，即 $\\text{null}$。链表结构现在是 `1 - 2 - 4 - null`。\n-   原始节点 $N_4$ 现在被孤立，并将被垃圾回收。最终的列表是 `[1, 2, 4]`。删除成功。\n\n此方法正确处理了问题中描述的所有情况，包括从头部删除（只要不是单节点列表）、从中间删除，并正确地将尾节点情况识别为不可能。", "answer": "```python\n# It is specified that no libraries outside the Python standard library are permitted, except for numpy.\n# Numpy is not required for this problem, but we import it to strictly adhere to the environment specification.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    Represents a node in a singly linked list.\n    \"\"\"\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n    def __repr__(self):\n        return f\"Node({self.val})\"\n\ndef delete_node(node_to_delete: Node) - bool:\n    \"\"\"\n    Attempts to delete a node from a singly linked list given only a reference to that node.\n    The deletion is performed in O(1) time and O(1) space.\n\n    This is achieved by copying the value and `next` reference from the subsequent node\n    into the target node, effectively overwriting the target node and unlinking the next one.\n\n    This operation is not possible if the node to be deleted is the tail of the list,\n    as there is no subsequent node to copy from.\n\n    Args:\n        node_to_delete: A reference to the node that should be removed.\n\n    Returns:\n        True if the deletion was successful, False otherwise.\n    \"\"\"\n    # A null node cannot be deleted.\n    # If the node is the tail of the list (node.next is None), we cannot perform the copy-and-unlink operation.\n    # In a standard singly linked list, we would need a reference to the predecessor to set its `next` to None.\n    # Since we don't have that, this case is impossible to handle under the problem's constraints.\n    if node_to_delete is None or node_to_delete.next is None:\n        return False\n\n    # Get a reference to the next node.\n    next_node = node_to_delete.next\n\n    # Copy the data from the next node into the current node.\n    node_to_delete.val = next_node.val\n\n    # Unlink the next node by bypassing it.\n    node_to_delete.next = next_node.next\n    \n    # next_node is now orphaned and will be garbage-collected in Python.\n\n    return True\n\ndef build_list(items: list) - 'Node' or None:\n    \"\"\"\n    Builds a singly linked list from a Python list of values.\n    \"\"\"\n    if not items:\n        return None\n    head = Node(items[0])\n    current = head\n    for val in items[1:]:\n        current.next = Node(val)\n        current = current.next\n    return head\n\ndef get_node_at(head: Node, index: int) - 'Node' or None:\n    \"\"\"\n    Retrieves the node at a specific index in the linked list.\n    \"\"\"\n    current = head\n    for _ in range(index):\n        if current is None:\n            return None\n        current = current.next\n    return current\n\ndef list_to_pylist(head: Node) - list:\n    \"\"\"\n    Converts a singly linked list back into a Python list of values.\n    \"\"\"\n    items = []\n    current = head\n    while current:\n        items.append(current.val)\n        current = current.next\n    return items\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and generate the final output.\n    \"\"\"\n    # Test cases as defined in the problem statement.\n    # Each case is a tuple: (initial list values, index of node to delete).\n    test_cases = [\n        # Case 1: middle deletion, happy path\n        ([1, 2, 3, 4, 5], 2),\n        # Case 2: head deletion using only head pointer\n        ([1, 2, 3], 0),\n        # Case 3: tail deletion, impossible\n        ([1, 2, 3], 2),\n        # Case 4: single-node list, impossible\n        ([42], 0),\n        # Case 5: duplicate values, structural correctness\n        ([5, 5, 5], 1),\n        # Case 6: boundary near tail\n        ([1, 2, 3, 4, 5, 6], 4),\n    ]\n\n    results = []\n    for initial_values, delete_index in test_cases:\n        # Construct the linked list for the current test case.\n        head = build_list(initial_values)\n        \n        # Get a reference to the node that needs to be deleted.\n        node_to_delete = get_node_at(head, delete_index)\n        \n        # Attempt the deletion.\n        success = delete_node(node_to_delete)\n        \n        # Convert the potentially modified list back to a Python list for output.\n        # The head reference remains valid even if the first node's value was changed.\n        final_values = list_to_pylist(head)\n        \n        # Format the result string for this test case as per the specification.\n        # Booleans must be lowercase 'true' or 'false'.\n        result_str = f\"[{str(success).lower()},{final_values}]\"\n        results.append(result_str.replace(\" \", \"\"))\n\n    # Final print statement must produce a single line in the exact required format.\n    # e.g., [[true,[1,2,4,5]],[false,[1,2,3]],...]\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver.\nsolve()\n```", "id": "3245621"}]}