{"hands_on_practices": [{"introduction": "约瑟夫问题是一个经典的计算机科学谜题，它为我们提供了一个绝佳的场景来练习队列的基本操作。这个练习的核心在于，如何使用一个本质上是线性的数据结构（队列）来模拟一个循环过程。通过巧妙地将队首元素移至队尾，我们可以有效地模拟“围成一圈”的场景，从而加深对队列“先进先出”特性的理解。[@problem_id:3262009]", "problem": "您需要实现一个经典的约瑟夫环淘汰问题的模拟，该模拟使用基于先进先出 (FIFO) 语义构建的循环队列。\n\n从基本定义开始：队列是一种支持遵循先进先出 (FIFO) 原则操作的序列，这意味着最早插入的项将最早被移除。队列的核心操作是 `enqueue` (在队尾插入) 和 `dequeue` (从队首移除)。循环队列的行为可以通过重复地将队首元素移动到队尾来实现。\n\n给定 $n$ 个按 $1$ 到 $n$ 编号的人围成一个圈，以及一个整数步长 $k$，约瑟夫环淘汰过程如下：重复地沿圈顺序数 $k$ 个人，并移除第 $k$ 个人，然后从每次移除后的下一个人开始继续，直到只剩下一个人。形式上，在队列当前包含 $m$ 个元素的每一轮中，您必须：\n- 将队列旋转 $r$ 次，每次旋转执行一次 `dequeue` 后跟一次 `enqueue`，其中 $r$ 等于在淘汰前需要前进的位置数，然后淘汰操作会移除当前的队首元素。为了将队首元素计为第一个，设置 $r = (k - 1) \\bmod m$，这样第 $k$ 个人就会成为队首。\n- 执行一次 `dequeue` 以淘汰第 $k$ 个人。\n- 重复此过程直到队列大小为 $1$；最后剩下的编号即为幸存者。\n\n约束和实现要求：\n- 仅使用符合先进先出 (FIFO) 语义的队列操作：在队尾 `enqueue`、从队首 `dequeue` 和获取大小 `size`。您只能通过重复的 `dequeue`-`enqueue` 操作来实现旋转。不要使用随机访问或指针算术直接跳转到某个位置。\n- 标签是 $1$ 到 $n$ 的整数。以整数形式返回幸存者的编号。\n- 本问题不涉及物理单位。\n\n您的程序必须计算以下每个测试用例的约瑟夫环幸存者：\n- 案例 A: $(n,k)=(7,3)$。\n- 案例 B: $(n,k)=(1,1)$。\n- 案例 C: $(n,k)=(10,1)$。\n- 案例 D: $(n,k)=(6,6)$。\n- 案例 E: $(n,k)=(5,12)$。\n- 案例 F: $(n,k)=(20,7)$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含按上述测试用例顺序排列的六个幸存者编号，格式为方括号括起来的逗号分隔列表，例如 `[x_A,x_B,x_C,x_D,x_E,x_F]`，其中每个 $x_i$ 是一个整数。\n- 不应打印任何其他文本。", "solution": "用户要求使用通过先进先出 (FIFO) 操作模拟的循环队列来实现约瑟夫环问题。\n\n### 步骤 1：提取已知信息\n- **问题：** 约瑟夫环淘汰模拟。\n- **数据结构：** 具有 FIFO 语义的队列。\n- **允许的操作：** `enqueue` (添加到队尾)、`dequeue` (从队首移除)、`size` (获取大小)。\n- **循环行为：** 通过重复地将队首元素移动到队尾（先 `dequeue` 后 `enqueue`）来实现。\n- **输入参数：**\n    - $n$：人数，一个整数。\n    - $k$：淘汰的步长，一个整数。\n- **初始状态：** 一个按顺序包含从 $1$ 到 $n$ 的整数的队列。\n- **每轮流程：**\n    1. 设队列中当前元素的数量为 $m$。\n    2. 将队列旋转 $r = (k - 1) \\bmod m$ 次。一次旋转包括一次 `dequeue` 和一次 `enqueue`。\n    3. `dequeue` 队首元素以将其淘汰。\n- **终止条件：** 当队列大小为 $1$ 时，过程停止。\n- **输出：** 队列中剩下的唯一整数编号。\n- **约束：**\n    - 仅使用 FIFO 队列操作。无随机访问。\n    - 标签是 $1$ 到 $n$ 的整数。\n- **测试用例：**\n    - 案例 A: $(n, k) = (7, 3)$\n    - 案例 B: $(n, k) = (1, 1)$\n    - 案例 C: $(n, k) = (10, 1)$\n    - 案例 D: $(n, k) = (6, 6)$\n    - 案例 E: $(n, k) = (5, 12)$\n    - 案例 F: $(n, k) = (20, 7)$\n- **最终输出格式：** 单行 `[x_A,x_B,x_C,x_D,x_E,x_F]`。\n\n### 步骤 2：使用提取的已知信息进行验证\n对问题陈述进行验证。\n\n- **科学上成立：** 该问题是一个经典的计算机科学谜题（约瑟夫环问题），并基于数据结构和算法中公认的原理，特别是队列理论。它不违反任何科学或数学定律。\n- **适定性：** 对于任何正整数 $n$ 和 $k$，所描述的算法是确定性的。初始状态已定义，每一步都明确无误，并且终止条件保证能够满足。因此，对于任何有效输入都存在唯一解。\n- **客观性：** 问题以精确、形式化的语言陈述。所有术语，如“队列”、“FIFO”、“enqueue”、“dequeue”以及淘汰规则 $r = (k - 1) \\bmod m$，都得到了清晰、客观的定义。\n- **完整性：** 问题是自洽的。它提供了所有必要的信息：初始设置、逐步过程、终止条件以及所需的输出格式。没有信息缺失。\n- **其他缺陷：** 该问题没有表现出任何其他缺陷。它不是比喻性的，与指定主题高度相关，没有矛盾，不包含不切实际的数据，不是不适定的，也不是微不足道的。仅使用队列操作的约束是该问题设计的一个基本方面，指导了所需的算法方法。\n\n### 步骤 3：结论和行动\n问题是**有效的**。将提供一个解决方案。\n\n### 解法推导\n\n该问题要求使用严格遵守 FIFO 原则的队列数据结构，直接模拟约瑟夫环淘汰过程。\n\n1.  **初始化：** 我们首先构建一个代表 $n$ 个人组成的圈的队列。这些人用从 $1$ 到 $n$ 的整数进行编号。我们按顺序将这些编号入队。设队列为 $Q$。初始时，$Q$ 包含 $[1, 2, 3, \\dots, n]$，其中 $1$ 在队首，$n$ 在队尾。\n\n2.  **迭代淘汰：** 算法的核心是一个循环，只要队列中的人数大于 $1$，该循环就会继续。在循环的每次迭代中，我们执行一次淘汰。\n\n    a.  **确定当前大小：** 设 $m$ 为队列的当前大小，即 $m = |Q|$。\n\n    b.  **定位被淘汰者：** 问题陈述我们需要淘汰圈中的第 $k$ 个人。为了用队列模拟这一点，我们必须将第 $k$ 个人带到队列的队首，以便通过 `dequeue` 操作将其移除。将队首的人计为位置 $1$，第 $k$ 个人距离队首有 $k-1$ 步。\n    \n    所需的旋转次数 $r$ 由公式 $r = (k - 1) \\bmod m$ 给出。模运算符处理了 $k  m$ 的情况。例如，在一个大小为 $m$ 的圈中数 $k$ 步等同于数 $k \\pmod m$ 步（如果 $k$ 是 $m$ 的倍数，则为 $m$ 步）。公式 $r = (k-1) \\pmod m$ 正确计算了将第 $k$ 个元素带到队首所需从队首移动到队尾的元素数量。\n    \n    我们通过执行 `dequeue` 操作后跟 `enqueue` 操作 $r$ 次来执行此旋转。每一对这样的操作都将队首元素移动到队尾，从而有效地旋转了圆形排列。\n\n    c.  **淘汰：** 旋转阶段之后，要被淘汰的人位于队列的队首。单个 `dequeue` 操作将此人从圈中永久移除。\n\n3.  **终止：** 步骤 2 中描述的循环在队列大小 $|Q|$ 变为 $1$ 时终止。队列中剩下的单个元素就是幸存者的编号。\n\n此过程在仅使用 FIFO 队列操作的严格约束下正确地模拟了约瑟夫环问题。我们现在将此算法应用于给定的测试用例。\n\n我们来追踪案例 A：$(n, k) = (7, 3)$。\n- **初始状态：** $Q = [1, 2, 3, 4, 5, 6, 7]$。\n- **第 1 轮：** $m = 7$。旋转 $r = (3 - 1) \\bmod 7 = 2$ 次。\n    - `dequeue(1)`，`enqueue(1)` $\\rightarrow Q = [2, 3, 4, 5, 6, 7, 1]$。\n    - `dequeue(2)`，`enqueue(2)` $\\rightarrow Q = [3, 4, 5, 6, 7, 1, 2]$。\n    - 淘汰队首：`dequeue(3)`。现在 $Q$ 是 $[4, 5, 6, 7, 1, 2]$。\n- **第 2 轮：** $m = 6$。旋转 $r = (3 - 1) \\bmod 6 = 2$ 次。\n    - `dequeue(4)`，`enqueue(4)` $\\rightarrow Q = [5, 6, 7, 1, 2, 4]$。\n    - `dequeue(5)`，`enqueue(5)` $\\rightarrow Q = [6, 7, 1, 2, 4, 5]$。\n    - 淘汰队首：`dequeue(6)`。现在 $Q$ 是 $[7, 1, 2, 4, 5]$。\n- **第 3 轮：** $m = 5$。旋转 $r = (3 - 1) \\bmod 5 = 2$ 次。\n    - `dequeue(7)`，`enqueue(7)` $\\rightarrow Q = [1, 2, 4, 5, 7]$。\n    - `dequeue(1)`，`enqueue(1)` $\\rightarrow Q = [2, 4, 5, 7, 1]$。\n    - 淘汰队首：`dequeue(2)`。现在 $Q$ 是 $[4, 5, 7, 1]$。\n- **第 4 轮：** $m = 4$。旋转 $r = (3 - 1) \\bmod 4 = 2$ 次。\n    - `dequeue(4)`，`enqueue(4)` $\\rightarrow Q = [5, 7, 1, 4]$。\n    - `dequeue(5)`，`enqueue(5)` $\\rightarrow Q = [7, 1, 4, 5]$。\n    - 淘汰队首：`dequeue(7)`。现在 $Q$ 是 $[1, 4, 5]$。\n- **第 5 轮：** $m = 3$。旋转 $r = (3 - 1) \\bmod 3 = 2$ 次。\n    - `dequeue(1)`，`enqueue(1)` $\\rightarrow Q = [4, 5, 1]$。\n    - `dequeue(4)`，`enqueue(4)` $\\rightarrow Q = [5, 1, 4]$。\n    - 淘汰队首：`dequeue(5)`。现在 $Q$ 是 $[1, 4]$。\n- **第 6 轮：** $m = 2$。旋转 $r = (3 - 1) \\bmod 2 = 0$ 次。不旋转。\n    - 淘汰队首：`dequeue(1)`。现在 $Q$ 是 $[4]$。\n- **终止：** 队列大小为 $1$。幸存者是 $4$。\n实现将对所有测试用例遵循此逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef josephus_survivor(n: int, k: int) - int:\n    \"\"\"\n    Computes the Josephus problem survivor using a queue simulation.\n\n    Args:\n        n: The initial number of people (labeled 1 to n).\n        k: The step size for elimination.\n\n    Returns:\n        The label of the sole survivor.\n    \"\"\"\n    if n == 0:\n        # No people, no survivor. Although constraints imply n = 1.\n        return 0\n    if n == 1:\n        # If there's only one person, they are the survivor.\n        return 1\n\n    # Use collections.deque for efficient append (enqueue) and popleft (dequeue).\n    # This is part of the Python standard library.\n    queue = collections.deque(range(1, n + 1))\n\n    # The elimination process continues until only one person remains in the queue.\n    while len(queue)  1:\n        # Get the current number of people in the circle.\n        current_size = len(queue)\n        \n        # Calculate the number of rotations needed to bring the k-th person to the front.\n        # This is (k-1) because we need to move k-1 people from the front to the back.\n        # The modulo operator handles cases where k is larger than the current circle size.\n        # This matches the formula r = (k - 1) mod m given in the problem statement.\n        rotations = (k - 1) % current_size\n\n        # Perform the rotations. Each rotation is a dequeue from the front followed by an enqueue to the rear.\n        for _ in range(rotations):\n            person = queue.popleft()\n            queue.append(person)\n\n        # The k-th person is now at the front of the queue. Eliminate them.\n        queue.popleft()\n\n    # The last remaining person in the queue is the survivor.\n    return queue.popleft()\n\ndef solve():\n    \"\"\"\n    Solves the Josephus problem for the given test cases and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (7, 3),   # Case A\n        (1, 1),   # Case B\n        (10, 1),  # Case C\n        (6, 6),   # Case D\n        (5, 12),  # Case E\n        (20, 7),  # Case F\n    ]\n\n    results = []\n    for n, k in test_cases:\n        survivor = josephus_survivor(n, k)\n        results.append(survivor)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main solver function.\nsolve()\n\n```", "id": "3262009"}, {"introduction": "在处理数据流（如网络数据包或用户日志）时，我们常常需要实时找出符合特定条件的第一个元素。本练习将引导你解决一个典型的数据流问题：在持续输入的字符流中，实时找到第一个不重复的字符。你将学习如何将队列（用于维持字符出现的先后顺序）与频率计数器（如哈希表）结合使用，构建一个高效的在线算法。[@problem_id:3261986]", "problem": "给定一个字符流，它一次一个字符地到达，形成一个字符串。设该流表示为 $S = (s_1, s_2, \\ldots, s_n)$，其中 $n$ 是流的长度，每个 $s_k$ 是来自固定字母表 $\\Sigma$ 的一个字符（例如，标准的美国信息交换标准代码 (ASCII) 字符集）。任务是，在每个字符到达步骤 $k$（其中 $k \\in \\{1,2,\\ldots,n\\}$）之后，计算前缀 $(s_1, s_2, \\ldots, s_k)$ 中第一个不重复的字符。如果存在这样的字符，您必须输出其 ASCII 码的整数值；否则，必须输出 $-1$。对于每个给定的流，您必须为从 $1$ 到 $n$ 的所有 $k$ 生成这些输出。\n\n要求的方法是使用一个遵循先进先出 (FIFO) 属性的队列数据结构。该队列必须用于跟踪到目前为止只出现过一次的候选字符，并保持它们首次出现的顺序。您也可以使用一个从字符到计数的辅助频率映射，以判断一个候选字符是否仍然不重复。\n\n要使用的基本定义：\n- 队列是一个序列，支持在末尾插入元素的 $\\text{enqueue}(x)$ 操作和从前端移除元素的 $\\text{dequeue}()$ 操作，遵循先进先出 (FIFO) 原则。令 $Q$ 表示队列，$F:\\Sigma \\to \\mathbb{N}$ 表示频率映射。\n- 步骤 $k$ 后的第一个不重复字符是满足 $F(s_i)=1$ 且索引 $i$ 最小的字符 $s_i$，其中 $i \\in \\{1,2,\\ldots,k\\}$。\n\n您的程序必须：\n- 对于下面测试套件中的每个流 $S$，使用队列操作和频率映射逐个处理字符。\n- 在处理完每个字符 $s_k$ 后，输出当前前缀中第一个不重复字符 $c$ 的 ASCII 码整数值 $\\operatorname{ord}(c)$，如果不存在这样的字符，则输出 $-1$。\n- 将每个流的输出收集为一个整数列表 $L = [\\ell_1,\\ell_2,\\ldots,\\ell_n]$，其中 $\\ell_k \\in \\mathbb{Z}$ 是步骤 $k$ 所要求的值，并生成单行输出，该行将所有流的结果聚合成一个用方括号括起来的逗号分隔列表。此顶层列表中的每个元素都必须是对应一个流的方括号列表 $L$，并且最终打印的字符串中不含任何空白字符。例如，两个测试用例的正确最终格式应如 `[[1,2],[-1,-1,97]]`。\n\n测试套件：\n- $S_1$：字符串字面量 \"aabcbdbe\"。\n- $S_2$：字符串字面量 \"\"（空流，其中 $n=0$）。\n- $S_3$：字符串字面量 \"aaaaa\"。\n- $S_4$：字符串字面量 \"abcab\"。\n- $S_5$：字符串字面量 \"a#b#a#c#b\"。\n\n答案类型：\n- 对于每个测试用例 $S_i$，答案是一个长度为 $n$ 的整数列表 $L_i$，其中每个整数要么是 ASCII 码（表示当前第一个不重复的字符），要么是 $-1$（如果不存在）。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内无空格。其中每个元素是列表 $L_i$ 之一，顺序与测试套件中的顺序相同：$[L_1,L_2,L_3,L_4,L_5]$。\n\n限制与要求：\n- 根据队列 (FIFO) 的定义和前缀中字符频率的概念推导出您的算法。\n- 仅使用队列操作 $\\text{enqueue}$ 和 $\\text{dequeue}$ 来管理候选集，并使用映射 $F$ 进行常数时间的频率更新。\n- 此问题不要求使用任何物理单位、角度或百分比单位。", "solution": "问题陈述已根据所需标准进行了分析和验证。\n\n### 步骤 1：提取已知条件\n- **输入流**：来自字母表 $\\Sigma$ 的字符流 $S = (s_1, s_2, \\ldots, s_n)$。\n- **任务**：对于从 $1$ 到 $n$ 的每个步骤 $k$，找到前缀 $(s_1, s_2, \\ldots, s_k)$ 中的第一个不重复字符。\n- **步骤输出**：如果存在第一个不重复字符 $c$，输出其整数 ASCII 码 $\\operatorname{ord}(c)$。否则，输出 $-1$。\n- **要求的方法**：使用一个具有先进先出 (FIFO) 操作（$\\text{enqueue}$，$\\text{dequeue}$）的队列 $Q$ 和一个辅助频率映射 $F: \\Sigma \\to \\mathbb{N}$。\n- **第一个不重复字符的定义**：在步骤 $k$，这是字符 $s_i$，其中 $i \\in \\{1, 2, \\ldots, k\\}$，频率 $F(s_i)=1$，且索引 $i$ 在所有此类字符中是最小的。\n- **测试套件**：\n  - $S_1$：\"aabcbdbe\"\n  - $S_2$：\"\"\n  - $S_3$：\"aaaaa\"\n  - $S_4$：\"abcab\"\n  - $S_5$：\"a#b#a#c#b\"\n- **最终输出格式**：包含一个逗号分隔的列表的列表的单行，不含空白字符（例如，`[[1,2],[-1,-1,97]]`）。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题定义明确、自洽且逻辑一致。它基于数据结构和算法的标准原则，特别是涉及队列和哈希表（频率计数）。目标清晰且可形式化。不存在科学或事实上的不准确之处、歧义或矛盾。该问题未违反任何指定的无效标准。\n\n### 步骤 3：结论与行动\n该问题是 **有效的**。将提供一个解决方案。\n\n### 基于原则的解决方案设计\n\n该问题要求在流的持续增长的前缀中找到第一个不重复的字符。术语“第一”指的是在流中出现的顺序。这表明我们不仅必须跟踪哪些字符是不重复的，还必须维护它们首次出现的相对顺序。\n\n队列，遵循先进先出 (FIFO) 原则，是维护此顺序的理想数据结构。一个字符首次出现即是它进入考虑范围的时刻。通过在首次遇到每个字符时将其添加到队列中，我们确保队列前端的字符始终是当前队列中所有候选字符中最早出现的那个。\n\n需要一个辅助频率映射来高效地跟踪每个字符的出现次数。哈希表或固定大小的数组（如果字母表大小已知且可管理，如具有 $256$ 个字符的标准 ASCII）可以用于此目的，提供近似常数时间，即 $O(1)$ 的更新和查找。\n\n算法通过一次处理一个字符的方式进行。设 $s_k$ 是步骤 $k$ 的字符。\n\n1.  **初始化**：\n    - 初始化一个空队列 $Q$。此队列将按首次出现的顺库存放恰好出现过一次的字符。\n    - 初始化一个频率映射 $F$。对于每个字符 $c \\in \\Sigma$，$F(c)$ 将存储其在到目前为止已处理的前缀中的计数。最初，所有计数均为 $0$。\n\n2.  **逐字符处理**：对于流 $S$ 中的每个字符 $s_k$：\n    - **更新频率**：在频率映射中增加 $s_k$ 的计数：$F(s_k) \\leftarrow F(s_k) + 1$。\n    - **首次出现时入队**：如果新的计数 $F(s_k)$ 正好为 $1$，则表明这是第一次看到该字符。为了保持其出现顺序，我们将其入队：$\\text{enqueue}(s_k)$ 到 $Q$ 中。\n    - **维护队列有效性**：队列前端的字符 $Q.\\text{front}()$ 是我们第一个不重复字符的主要候选者。然而，自从它入队以来，它自身的频率可能已经增加。因此，我们必须确保队列前端始终是频率恰好为 $1$ 的字符。我们通过重复检查队列前端的字符 $c_{front}$ 来实现这一点。如果 $F(c_{front})  1$，则意味着该字符现在已重复，不能再是*第一个*不重复的字符。因此，我们必须通过执行 $\\text{dequeue}()$ 操作将其从我们的有序候选集中丢弃。重复此过程，直到队列为空或其前端字符的频率为 $1$。\n    - **确定输出**：清理队列后，我们检查其状态：\n        - 如果 $Q$ 不为空，其前端元素 $Q.\\text{front}()$ 保证是流中当前频率为 $1$ 的最早出现的字符。这就是步骤 $k$ 的解。我们记录其 ASCII 码 $\\operatorname{ord}(Q.\\text{front}())$。\n        - 如果 $Q$ 为空，则意味着到目前为止遇到的每个字符都已出现不止一次。没有不重复的字符。我们记录 $-1$。\n\n3.  **聚合**：所有步骤 $k=1, \\ldots, n$ 的记录值构成了流 $S$ 的结果列表。\n\n### 复杂度分析\n令 $n$ 为流的长度，$|\\Sigma|$ 为字母表的大小。\n- **时间复杂度**：流中的每个字符都被处理一次。对于每个字符，我们执行一次频率映射更新 ($O(1)$) 和最多一次入队操作 ($O(1)$)。出队部分看起来更复杂，但请注意，在整个过程中，每个字符最多只能入队一次，也最多只能出队一次。因此，在所有 $n$ 个步骤中，出队操作的总数受 $n$ 的限制。因此，每个字符的均摊时间复杂度为 $O(1)$。处理长度为 $n$ 的流的总时间复杂度为 $O(n)$。\n- **空间复杂度**：频率映射所需的空间与流中唯一字符的数量成正比，最多为 $|\\Sigma|$。队列存储至少出现过一次的字符。在最坏的情况下，流中的所有字符都是唯一的，因此队列的大小可能增长到 $n$。因此，空间复杂度为 $O(\\min(n, |\\Sigma|))$。对于像 ASCII 这样的固定字母表，如果 $n$ 可以任意大，则这简化为 $O(1)$，或者更准确地说是 $O(|\\Sigma|)$。如果 $n$ 小于 $|\\Sigma|$，则为 $O(n)$。", "answer": "```python\nimport collections\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the first non-repeating character in a stream problem\n    for a given test suite.\n    \"\"\"\n\n    def process_stream(stream: str) - list[int]:\n        \"\"\"\n        Processes a single stream of characters and returns the list of outputs.\n\n        For each character in the stream, it computes the first non-repeating\n        character seen so far in the stream's prefix.\n\n        Args:\n            stream: The input string of characters.\n\n        Returns:\n            A list of integers, where each element is the ASCII code of the\n            first non-repeating character at that step, or -1 if none exists.\n        \"\"\"\n        # The queue stores characters that are candidates for being the first \n        # non-repeating one, preserving their order of first appearance.\n        # A character is enqueued only on its first appearance.\n        candidate_queue = collections.deque()\n\n        # The frequency map stores the count of each character seen so far.\n        # An array of size 256 is used for constant-time access for ASCII characters.\n        # All counts are implicitly 0 initially.\n        char_freq = [0] * 256\n\n        results_for_stream = []\n\n        for char in stream:\n            char_ascii = ord(char)\n            \n            # 1. Update frequency for the current character.\n            char_freq[char_ascii] += 1\n\n            # 2. If it's the first time seeing this character, add it to the queue.\n            if char_freq[char_ascii] == 1:\n                candidate_queue.append(char)\n            \n            # 3. Clean the queue: Remove any characters from the front of the queue\n            #    that are no longer non-repeating (i.e., their frequency is  1).\n            #    This ensures the head of the queue is always a valid candidate.\n            while candidate_queue and char_freq[ord(candidate_queue[0])]  1:\n                candidate_queue.popleft()\n\n            # 4. Determine the output for the current step.\n            if candidate_queue:\n                # If the queue is not empty, the character at the front is the\n                # first non-repeating character.\n                first_non_repeating_char = candidate_queue[0]\n                results_for_stream.append(ord(first_non_repeating_char))\n            else:\n                # If the queue is empty, there are no non-repeating characters.\n                results_for_stream.append(-1)\n        \n        return results_for_stream\n\n    test_cases = [\n        \"aabcbdbe\",\n        \"\",\n        \"aaaaa\",\n        \"abcab\",\n        \"a#b#a#c#b\",\n    ]\n\n    all_results = []\n    for s in test_cases:\n        all_results.append(process_stream(s))\n\n    # Format the final output string exactly as required, with no whitespace.\n    # Each inner list is converted to a string \"[a,b,c]\" without spaces.\n    # These strings are then joined by commas and enclosed in a final pair of brackets.\n    final_output_parts = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output_str = f\"[{','.join(final_output_parts)}]\"\n\n    print(final_output_str)\n\nsolve()\n```", "id": "3261986"}, {"introduction": "数据结构不仅仅是孤立的工具，它们也可以作为构建块来创造新的结构。这个练习提出了一个有趣而深刻的挑战：你能否仅用两个“先进先出”（$\\text{FIFO}$）的队列来实现一个“后进先出”（$\\text{LIFO}$）的栈？通过解决这个问题，你不仅能掌握如何逆转队列的固有行为，还能深入理解操作复杂度与实现策略之间的权衡。[@problem_id:3262080]", "problem": "你必须使用两个先进先出队列来实现一个后进先出栈，并在一个精确的单位成本模型下分析其某个操作的时间复杂度。该实现必须是完全自包含的，并且能够作为一个程序运行，无需读取任何输入。程序必须生成一行输出，其中包含所提供测试套件的结果，并遵循下文描述的精确最终输出格式。\n\n基本原则和约束：\n- 一个先进先出（$\\text{FIFO}$）队列支持以下基本操作：入队（enqueue）、出队（dequeue）、查看队首元素（front，不移除）、判空（is_empty）和获取大小（size）。后进先出（$\\text{LIFO}$）栈必须严格地基于这两个$\\text{FIFO}$队列实现，不能使用任何其他数据结构。\n- 在单位成本模型下，每次入队和每次出队的单位成本均为 $1$。在本任务的复杂度计算中，is_empty、size、front以及交换两个内部队列的标识均被视为成本为 $0$。\n- 你的实现所暴露的栈应用程序编程接口必须包括以下操作：对一个值执行入栈（push），出栈（pop）并返回栈顶元素或在下溢时返回哨兵值，查看栈顶（top）并返回栈顶元素或在下溢时返回相同的哨兵值，获取大小（size）并返回当前元素数量，以及判空（is_empty）并返回栈是否为空。下溢时请使用整数哨兵值 $-1$。\n- 你必须选择一种标准构造方法，仅使用允许的操作从两个队列实现一个栈。你的程序还必须提供一个机制，用于报告单次入栈操作在上述模型下所执行的基本队列操作（入队和出队）的数量。\n\n基于原理的目标：\n- 从$\\text{FIFO}$和$\\text{LIFO}$行为的核心定义以及单位成本模型出发，设计并论证一个从两个队列构造栈的方法。\n- 通过计数，分析你所实现的某一个栈操作的最坏情况时间复杂度。该计数是关于 $n$ 的函数，表示当栈在操作执行前包含 $n$ 个元素时，该操作所执行的基本队列操作的数量。\n\n测试套件和要求的输出：\n令 $S$ 表示你用两个队列实现的栈的一个新实例。程序必须执行以下测试，并将其结果按顺序聚合到一个列表中。\n\n- 测试A（功能行为，正常路径）：\n  1. 对 $1$ 执行入栈，然后对 $2$ 执行入栈，再对 $3$ 执行入栈。\n  2. 按此顺序记录以下调用的结果：pop、top、size、pop、pop、pop。\n  3. 此测试必须返回一个整数列表，代表这六个结果。例如，如果满足$\\text{LIFO}$语义且下溢返回 $-1$，则结果为 `[3,2,2,2,1,-1]`。\n\n- 测试B（空栈边界条件）：\n  1. 令 $S'$ 为一个新的空栈。记录列表 $[\\text{对 } S' \\text{ 执行 pop}, \\text{对 } S' \\text{ 执行 top}]$，如果按规定处理了下溢，该列表应为 `[-1,-1]`。\n\n- 测试C（交替操作）：\n  1. 令 $S''$ 为一个新的空栈。按此顺序执行：对 $10$ 入栈，对 $20$ 入栈，出栈，对 $30$ 入栈，对 $40$ 入栈，出栈，出栈，出栈，出栈。\n  2. 返回在此序列中每次pop操作返回的值的列表，按它们被返回的顺序排列。在正确的$\\text{LIFO}$行为下，该列表应为 `[20,40,30,10,-1]`。\n\n- 测试D（操作成本测量，展示线性增长）：\n  1. 令 $S^{(D)}$ 为一个新的空栈。\n  2. 对值 $v_1,v_2,v_3,v_4,v_5$ 执行五次连续的入栈操作（具体值与计数模型无关）。\n  3. 对于这五次入栈中的每一次，记录在上述模型下该次入栈所计数的基本队列操作数（入队和出队各计为 $1$；front、is_empty、size和队列句柄交换计为 $0$）。\n  4. 返回这五个计数的列表。对于使入栈操作与当前栈大小呈线性关系的標準构造方法，当对一个初始为空的栈执行入栈时，此列表应为 `[1,3,5,7,9]`。\n\n- 测试E（较大规模下的最坏情况成本）：\n  1. 令 $S^{(E)}$ 为一个新的空栈。\n  2. 首先执行 $99$ 次入栈操作，不进行计数。然后执行一次额外的入栈，并仅记录这最后一次入栈在相同模型下的基本队列操作数。\n  3. 返回这个单一的整数计数。对于入栈成本与当前大小呈线性关系的標準构造方法，此值应为 `199`。\n\n最终输出格式：\n- 你的程序应生成单行输出，包含一个恰好有五个元素的列表，顺序如下：测试A返回的列表，测试B返回的列表，测试C返回的列表，测试D返回的列表，以及测试E返回的整数。该列表必须以无空格、逗号分隔的形式打印，并用方括号括起来，例如 `[[3,2,2,2,1,-1],[-1,-1],[20,40,30,10,-1],[1,3,5,7,9],199]`。\n\n科学现实性与期望：\n- 你的构造方法的正确性必须源于以下基本定义：$\\text{FIFO}$队列移除的是最近最少入队的元素，而$\\text{LIFO}$栈移除的是最近入栈的元素。\n- 所要分析的线性时间行为必须通过将基本队列移动次数作为当前栈大小 $n$ 的函数来计数推导得出，而不是依赖任何预先给定的快捷公式。", "solution": "任务是使用两个先进先出（$\\text{FIFO}$）队列来实现一个后进先出（$\\text{LIFO}$）栈。根本挑战源于两者相反的访问模式：栈提供对最近添加元素的访问，而队列提供对最早添加元素的访问。这就需要一个机制来逆转存储在队列中元素的顺序，以模拟栈的行为。设这两个队列为 $q_1$ 和 $q_2$。有两种标准构造方法可以实现这一点：一种使 `push` 操作计算成本高昂，另一种则使 `pop` 操作成本高昂。问题描述，特别是关于操作成本的测试用例，指导我们选择前一种策略，即 `push` 具有线性复杂度，而 `pop` 具有常数复杂度。\n\n我们来定义栈的状态。主队列，比如说 $q_1$，将存储栈中的 $n$ 个元素。关键在于，为了允许常数时间的 `pop` 和 `top` 操作， $q_1$ 中的元素必须按特定顺序排列，使得栈顶元素位于队列的前端。次队列 $q_2$ 在 `push` 操作期间用作辅助数据存储，在其他时候为空。\n\n基于此原则的栈操作实现如下：\n- `push(x)` 操作将一个新元素 $x$ 添加到包含 $n$ 个元素的栈中。为了维持$\\text{LIFO}$顺序，使新元素 $x$ 成为栈顶，我们必须将其放置在主队列 $q_1$ 的前端。由于队列只允许在后端添加元素，因此需要进行重新排序。\n    1. 将新元素 $x$ 入队到空的辅助队列 $q_2$ 中。\n    2. 将所有 $n$ 个现有元素从 $q_1$ 移动到 $q_2$。具体操作是重复地从 $q_1$ 出队并入队到 $q_2$，直到 $q_1$ 为空。此步骤后， $q_2$ 的前端是新元素 $x$，其后是按原顺序排列的 $n$ 个原始元素。\n    3. 交换两个队列的角色。将 $q_1$ 的句柄指向原来的 $q_2$，而 $q_2$ 的句柄现在指向（已为空的）原始 $q_1$。根据问题的成本模型，这种引用交换的成本为 $0$。之后， $q_1$ 包含所有 $n+1$ 个元素，其中 $x$ 位于前端，而 $q_2$ 为空，从而恢复了我们的不变量。\n\n- `pop()` 操作仅需从主队列 $q_1$ 的前端出队一个元素，根据我们的设计，这个元素就是栈顶。这是一个单一的 `dequeue` 操作。\n- `top()` 操作使用 `front` 基本操作返回 $q_1$ 队首的元素，但不移除它。\n- `size()` 和 `is_empty()` 通过在主队列 $q_1$ 上调用相应的方法来实现。\n\n最坏情况时间复杂度分析：我们被要求分析复杂度，它是操作前栈中元素数量 $n$ 的函数。成本模型规定 `enqueue` 和 `dequeue` 的成本各为 $1$，其他操作成本为 $0$。\n让我们分析在一个大小为 $n$ 的栈上执行 `push(x)` 操作。\n1. 将新元素 $x$ 入队到 $q_2$：这是一次 `enqueue` 操作。成本 = $1$。\n2. 将 $n$ 个元素从 $q_1$ 转移到 $q_2$：对于 $n$ 个元素中的每一个，都执行一次从 $q_1$ 的 `dequeue` 和一次到 $q_2$ 的 `enqueue`。这导致了 $n$ 次 `dequeue` 操作和 $n$ 次 `enqueue` 操作。此步骤的总成本 = $n \\times 1 + n \\times 1 = 2n$。\n3. 交换队列句柄：成本 = $0$。\n\n因此，在一个大小为 $n$ 的栈上执行一次 `push` 操作的总成本为 $C(n) = 1 + 2n$。这是 $n$ 的一个线性函数，因此时间复杂度为 $O(n)$。这个理论成本函数与测试套件要求的结果相符，例如前五次入栈的序列为 $[1, 3, 5, 7, 9]$（此时 $n$ 分别为 $0, 1, 2, 3, 4$），以及当 $n=99$ 时入栈的成本为 $199$（$1 + 2 \\times 99 = 199$）。\n反之，`pop` 操作涉及一次 `dequeue`，其常数成本为 $1$。`top`、`size` 和 `is_empty` 操作的成本为 $0$。因此，`pop`、`top`、`size` 和 `is_empty` 都是 $O(1)$ 操作。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# A basic FIFO Queue implementation.\n# Its methods strictly adhere to the allowed primitive operations.\n# A Python list is used as the backing data store, which is an implementation\n# detail not exposed to the Stack class.\nclass Queue:\n    def __init__(self):\n        self._data = []\n\n    def enqueue(self, item):\n        self._data.append(item)\n\n    def dequeue(self):\n        if self.is_empty():\n            return None # Should not happen with proper checks\n        return self._data.pop(0)\n\n    def front(self):\n        if self.is_empty():\n            return None\n        return self._data[0]\n\n    def is_empty(self):\n        return len(self._data) == 0\n\n    def size(self):\n        return len(self._data)\n\n# Implementation of a LIFO Stack using two FIFO Queues.\n# This implementation makes the push operation expensive (linear time).\nclass StackWithTwoQueues:\n    def __init__(self):\n        self.q1 = Queue()\n        self.q2 = Queue()\n        self.sentinel = -1\n\n    def push(self, value):\n        \"\"\"\n        Pushes a value onto the stack. Returns the cost of the operation\n        as per the problem's unit-cost model.\n        Cost = (number of enqueues) + (number of dequeues).\n        \"\"\"\n        cost = 0\n        \n        # 1. Enqueue the new value into the auxiliary queue q2.\n        self.q2.enqueue(value)\n        cost += 1 # 1 enqueue operation\n\n        # 2. Transfer all elements from q1 to q2.\n        while not self.q1.is_empty():\n            # is_empty has cost 0.\n            elem = self.q1.dequeue()\n            cost += 1 # 1 dequeue operation\n            self.q2.enqueue(elem)\n            cost += 1 # 1 enqueue operation\n        \n        # 3. Swap the identities of q1 and q2.\n        # This is a reference swap, with cost 0 as per the model.\n        self.q1, self.q2 = self.q2, self.q1\n        \n        return cost\n\n    def pop(self):\n        if self.is_empty():\n            return self.sentinel\n        return self.q1.dequeue()\n\n    def top(self):\n        if self.is_empty():\n            return self.sentinel\n        return self.q1.front()\n\n    def size(self):\n        return self.q1.size()\n\n    def is_empty(self):\n        return self.q1.is_empty()\n\ndef solve():\n    # Helper to format results into strings without spaces\n    def format_result(res):\n        if isinstance(res, list):\n            return f\"[{','.join(map(str, res))}]\"\n        else:\n            return str(res)\n\n    all_results = []\n\n    # Test A: Functional Behavior\n    s = StackWithTwoQueues()\n    s.push(1)\n    s.push(2)\n    s.push(3)\n    results_a = [s.pop(), s.top(), s.size(), s.pop(), s.pop(), s.pop()]\n    all_results.append(results_a)\n\n    # Test B: Boundary Conditions\n    s_prime = StackWithTwoQueues()\n    results_b = [s_prime.pop(), s_prime.top()]\n    all_results.append(results_b)\n\n    # Test C: Alternating Operations\n    s_double_prime = StackWithTwoQueues()\n    popped_values_c = []\n    s_double_prime.push(10)\n    s_double_prime.push(20)\n    popped_values_c.append(s_double_prime.pop())\n    s_double_prime.push(30)\n    s_double_prime.push(40)\n    popped_values_c.append(s_double_prime.pop())\n    popped_values_c.append(s_double_prime.pop())\n    popped_values_c.append(s_double_prime.pop())\n    popped_values_c.append(s_double_prime.pop())\n    all_results.append(popped_values_c)\n\n    # Test D: Operation-Cost Measurement\n    s_d = StackWithTwoQueues()\n    costs_d = []\n    for i in range(1, 6):\n        cost = s_d.push(i)\n        costs_d.append(cost)\n    all_results.append(costs_d)\n\n    # Test E: Worst-case Cost at a Larger Size\n    s_e = StackWithTwoQueues()\n    for i in range(99):\n        s_e.push(i)  # Push 99 elements without recording cost\n    cost_e = s_e.push(100) # Record cost of 100th push\n    all_results.append(cost_e)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(format_result, all_results))}]\")\n\nsolve()\n```", "id": "3262080"}]}