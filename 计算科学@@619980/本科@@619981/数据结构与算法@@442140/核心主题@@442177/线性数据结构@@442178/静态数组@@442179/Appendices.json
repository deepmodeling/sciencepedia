{"hands_on_practices": [{"introduction": "这个问题挑战你在时间和空间限制极其严格的情况下，找出一个数组中缺失的最小正整数。解决这个问题的关键在于一个巧妙的技巧：将数组的索引本身用作一个哈希表，通过原地重排元素来记录信息。这个练习能够极好地锻炼你对静态数组原地操作和利用其结构特性解决问题的能力。[@problem_id:3275160]", "problem": "给定多个独立的测试用例，每个测试用例包含一个未排序的静态整数数组。对于每个数组，计算其中最小的缺失正整数。算法要求是，对于一个长度为 $N$ 的数组，你的方法必须在 $O(N)$ 时间内运行，并使用 $O(1)$ 的额外空间（不包括给定的静态数组本身）。静态数组是一个固定长度、连续的内存块，支持常数时间的随机访问和原地更新。\n\n仅使用以下基本原理：静态数组的定义和属性（常数时间的索引和赋值）、通过常数次赋值（包括元素交换）进行原地更新的概念，以及时间复杂度 $O(\\cdot)$ 和空间复杂度 $O(\\cdot)$ 的标准定义。不要调整数组大小，不要分配与 $N$ 成正比的辅助数组，也不要使用大小依赖于 $N$ 的哈希结构。\n\n实现一个程序，将你的算法应用于以下数组测试套件：\n- $[3,4,-1,1]$\n- $[1,1,0,-1,-2,2]$\n- $[1,2,3]$\n- $[-5,-1,-3]$\n- $[7,8,9,11,12]$\n- $[2,3,4,5,6,7]$\n- $[]$\n- $[2]$\n- $[1]$\n\n对于每个数组，答案是一个单独的整数：该数组中最小的缺失正整数。你的程序必须硬编码上述测试套件，不得读取任何输入，也不得写入任何额外的输出。\n\n最终输出格式：你的程序应生成一行输出，其中包含测试套件的结果，按顺序排列，格式为一个用方括号括起来的逗号分隔列表，例如 $[a,b,c,\\dots]$，其中每个条目是对应测试用例的整数结果。", "solution": "所述问题是有效的。这是一个来自计算机科学领域的、定义明确的算法挑战，其基础是静态数组的形式化属性和复杂度理论。该问题是自洽的、客观的，并且其约束虽然严格但可以实现。\n\n任务是在一个长度为 $N$ 的未排序静态数组中找到最小的缺失正整数。解决方案必须达到 $O(N)$ 的时间复杂度和 $O(1)$ 的空间复杂度（常数额外空间）。\n\n一个高效解决方案的核心原理在于一个观察：最小的缺失正整数必然在 $[1, N+1]$ 的范围内。如果数组包含从 $1$ 到 $N$ 的所有整数，那么答案就是 $N+1$。否则，答案就是集合 $\\{1, 2, \\dots, N\\}$ 中未在数组中出现的最小整数。这一见解极大地缩小了搜索空间。\n\n鉴于 $O(1)$ 的空间限制，我们不能使用像哈希映射或大小为 $N$ 的布尔数组这样的辅助数据结构来跟踪数字的出现情况。我们必须重用输入数组本身来存储这些信息。其策略是将数组的索引视为一个哈希表，将值视为要放置的元素。具体来说，我们的目标是对于数组中所有存在的 $k \\in \\{1, \\dots, N\\}$，都将整数 $k$ 放置到索引 $k-1$ 的位置。\n\n该算法分为两个主要阶段进行：\n\n**阶段 1：原地循环放置**\n\n此阶段的目标是重排数组，使得如果一个整数 $k$（其中 $1 \\le k \\le N$）存在于数组中，它将被移动到索引 $k-1$ 的位置。\n\n我们从索引 $i=0$ 遍历到 $N-1$。对于每个元素 $A[i]$，我们检查它的值，称之为 $v$。一个内部 `while` 循环用于处理 $v$ 的放置：\n1.  只有当值 $v = A[i]$ 落在有效范围，即 $1 \\le v \\le N$ 内时，它才是一个可被放置的候选值。\n2.  为防止存在重复值时出现无限循环，我们还必须确保值 $v$ 尚未在其目标位置。值 $v$ 的目标位置是索引 $v-1$，该位置应该包含值 $v$。因此，只有当 $A[v-1] \\neq v$ 时才应进行交换。\n\n如果两个条件都满足（$1 \\le A[i] \\le N$ 且 $A[A[i]-1] \\neq A[i]$），我们就将元素 $A[i]$ 与其目标索引 $A[A[i]-1]$ 处的元素交换。交换后，索引 $i$ 处的元素是新的，我们必须在内部 `while` 循环中对其进行重新评估。这个循环过程持续进行，直到 $A[i]$ 处的值不再是移动的候选（因为它超出了 $[1, N]$ 范围，或者它是一个已被正确放置的值的副本）。\n\n此阶段的时间复杂度为 $O(N)$。虽然存在嵌套循环结构，但每次交换都至少将一个整数放置到其正确的最终位置。一个整数一旦到达其正确索引，就不会再被移动。由于最多有 $N$ 个整数需要放置，因此在外部循环的所有迭代中，总交换次数的上限为 $N$。\n\n**阶段 2：首次不匹配检测**\n\n放置阶段之后，数组已被重排。对于任何整数 $k \\in \\{1, \\dots, N\\}$，如果 $k$ 存在于原始数组中，那么现在我们有 $A[k-1] = k$。在对应于缺失整数的位置上，可能会有一些“垃圾”值（负数、零或大于 $N$ 的数）。\n\n我们对修改后的数组从索引 $j = 0$ 到 $N-1$ 进行一次线性扫描。我们检查是否 $A[j] = j+1$。第一个使此条件不成立的索引 $j$（即 $A[j] \\neq j+1$）告诉我们，$j+1$ 是原始数组中缺失的最小正整数。然后我们可以返回 $j+1$。\n\n如果循环完成而没有找到任何此类不匹配，这意味着对于每个 $j \\in [0, N-1]$，我们都发现 $A[j] = j+1$。这表明数组包含了从 $1$ 到 $N$ 的所有整数。在这种情况下，最小的缺失正整数是 $N+1$。\n\n这种两阶段方法能够正确识别最小的缺失正整数，同时遵守严格的 $O(N)$ 时间和 $O(1)$ 空间复杂度要求。它能正确处理各种边界情况，例如空数组、全为负数的数组、包含重复项的数组以及已经排序的数组。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the smallest missing positive integer for a list of test cases,\n    adhering to O(N) time and O(1) space complexity.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # We convert them to numpy arrays to better model the concept of a 'static array'.\n    test_cases_lists = [\n        [3,4,-1,1],\n        [1,1,0,-1,-2,2],\n        [1,2,3],\n        [-5,-1,-3],\n        [7,8,9,11,12],\n        [2,3,4,5,6,7],\n        [],\n        [2],\n        [1],\n    ]\n    \n    test_cases = [np.array(tc, dtype=np.int64) for tc in test_cases_lists]\n\n    results = []\n    for nums in test_cases:\n        result = find_smallest_missing_positive(nums)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef find_smallest_missing_positive(nums: np.ndarray) -> int:\n    \"\"\"\n    Finds the smallest missing positive integer in a static array.\n    The algorithm rearranges the array in-place to use indices as a hash map.\n\n    Args:\n        nums: A numpy array of integers. The array is modified in-place.\n\n    Returns:\n        The smallest positive integer not present in the array.\n    \"\"\"\n    n = nums.size\n\n    # Phase 1: In-place cyclical placement.\n    # The goal is to place each number k (in [1, n]) at index k-1.\n    for i in range(n):\n        # Continue swapping nums[i] into its correct place as long as it's a\n        # valid candidate and not already in its correct place.\n        # Condition 1: The value must be in the range [1, n].\n        # Condition 2: The value at the target index must not already be the correct value.\n        # This prevents infinite loops on duplicate entries.\n        while 1 = nums[i] = n and nums[nums[i] - 1] != nums[i]:\n            target_idx = nums[i] - 1\n            # Swap the current number to its correct position.\n            nums[i], nums[target_idx] = nums[target_idx], nums[i]\n\n    # Phase 2: Find the first missing positive.\n    # After rearrangement, the first index i where nums[i] != i + 1\n    # indicates that i + 1 is the smallest missing positive number.\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    \n    # If the loop completes, it means all integers from 1 to n were present.\n    # The smallest missing positive is therefore n + 1.\n    return n + 1\n\nsolve()\n```", "id": "3275160"}, {"introduction": "将一维数组的原地操作思想扩展到二维空间是一个常见的进阶。这个练习要求你将一个 $N \\times N$ 的矩阵顺时针旋转90度，且不能使用额外的数组空间。其核心在于将旋转分解为对一系列同心方环的独立操作，并通过四元组循环交换来实现，这能加深你对多维数组索引变换和复杂原地算法的理解。[@problem_id:3275330]", "problem": "给定一个维度为 $N \\times N$ 的方形二维静态数组（一个大小固定且具有连续存储语义的数组）。任务是设计并实现一个完整的程序，该程序仅使用数组索引操作和常数个临时变量，将此数组就地顺时针旋转 $90$ 度。角度单位为度。程序必须在不分配任何大小依赖于 $N$ 的辅助数组的情况下实现旋转。\n\n基本原理和约束：使用静态数组的核心定义，即对于一个具有 $N$ 行和 $N$ 列的二维数组，存在一个从索引对 $(i,j)$ 到对应元素的常数时间映射，并且索引操作不会改变内存的物理布局。结果应从关于数组索引的第一性原理以及原始坐标 $(i,j)$ 在方形网格中顺时针旋转 $90$ 度后的位置之间的几何关系推导出来。问题陈述中不提供任何用于旋转的快捷公式或提示；其正确性必须源于静态数组的基本属性和离散坐标变换。最终程序必须就地执行旋转，确保所使用的临时变量数量不随 $N$ 的增长而增长。\n\n您的程序必须将旋转应用于以下每个测试矩阵，然后为每个测试用例输出行主序扁平化结果。使用以下测试套件，其设计旨在覆盖一般情况、边界条件和重要的边缘情况：\n- 测试用例 $1$ (边界: $N = 1$): $$\\begin{bmatrix} 5 \\end{bmatrix}$$\n- 测试用例 $2$ (小型偶数 $N = 2$): $$\\begin{bmatrix} 1  2 \\\\ 3  4 \\end{bmatrix}$$\n- 测试用例 $3$ (奇数 $N = 3$ 且包含负数): $$\\begin{bmatrix} -1  -2  -3 \\\\ 4  5  6 \\\\ 7  8  9 \\end{bmatrix}$$\n- 测试用例 $4$ (偶数 $N = 4$ 且包含重复值): $$\\begin{bmatrix} 1  1  2  2 \\\\ 3  3  4  4 \\\\ 5  5  6  6 \\\\ 7  7  8  8 \\end{bmatrix}$$\n- 测试用例 $5$ (奇数 $N = 5$ 且零分布在对角线上): $$\\begin{bmatrix} 0  1  2  3  4 \\\\ 5  0  7  8  9 \\\\ 10  11  0  13  14 \\\\ 15  16  17  0  19 \\\\ 20  21  22  23  0 \\end{bmatrix}$$\n\n对于每个测试用例，在执行旋转后，将矩阵按行主序扁平化为一个整数列表（例如，对于旋转后的 $2 \\times 2$ 矩阵 $\\begin{bmatrix} a  b \\\\ c  d \\end{bmatrix}$，扁平化列表为 $[a,b,c,d]$）。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，其中每个元素是一个测试用例的扁平化列表，按测试用例 1 到测试用例 5 的顺序排列。例如，输出格式必须类似于：“[[x1,x2,...],[y1,y2,...],[z1,z2,...],[u1,u2,...],[v1,v2,...]]”，其中每个内部列表对应一个测试用例且只包含整数。\n\n每个测试用例的答案是上述描述的扁平化整数列表。不允许有其他文本输出。", "solution": "用户提供的问题已经过分析并被认定为 **有效**。这是一个在数据结构和算法领域内定义明确、有科学依据的问题，提供了所有必要信息且无内部矛盾。\n\n任务是就地将一个维度为 $N \\times N$ 的方形二维静态数组顺时针旋转 $90$ 度。就地算法必须在不分配与输入数组大小成比例的辅助内存的情况下执行旋转。该约束进一步规定，只能使用常数数量的、与 $N$ 无关的临时变量。解决方案必须从第一性原理推导得出。\n\n设数组表示为 $A$。位于第 $i$ 行和第 $j$ 列的元素是 $A[i,j]$，其中索引 $i$ 和 $j$ 的范围是从 $0$ 到 $N-1$。\n\n**1. 顺时针旋转的坐标变换**\n\n基本步骤是确定每个元素在顺时针旋转 $90$ 度后的目标坐标。推导此变换的一个常用方法是将其视为两个更简单操作的组合：先进行转置，然后反转每一行。\n\n1.  **转置**：位于位置 $(i, j)$ 的元素移动到位置 $(j, i)$。因此，$A[i,j]$ 的值移动到之前由 $A[j,i]$ 占据的位置。\n2.  **行反转**：转置后，现在位于位置 $(j, i)$ 的元素在第 $j$ 行。反转该行会将其从第 $i$ 列移动到第 $N-1-i$ 列。\n\n结合这两个步骤，最初位于 $A[i,j]$ 的元素最终被移动到位置 $(j, N-1-i)$。这为我们提供了每个元素值的目标映射：初始位置 $(i,j)$ 的值移动到最终位置 $(j, N-1-i)$。\n\n**2. 循环元素交换**\n\n为了就地执行旋转，我们必须在移动元素时不覆盖尚未移动的值。这可以通过识别和置换元素的闭合循环来实现。让我们追踪一个从任意位置 $(i,j)$ 开始的元素的路径。\n\n-   位置 1：$(i, j)$\n-   位置 1 的元素移动到位置 2：$(j, N-1-i)$。\n-   位置 2 的元素移动到位置 3。将映射应用于 $(j, N-1-i)$：新行为 $(N-1-i)$，新列为 $N-1-j$。所以，位置 3 是 $(N-1-i, N-1-j)$。\n-   位置 3 的元素移动到位置 4。将映射应用于 $(N-1-i, N-1-j)$：新行为 $(N-1-j)$，新列为 $N-1-(N-1-i) = i$。所以，位置 4 是 $(N-1-j, i)$。\n-   将映射应用于位置 4，即 $(N-1-j, i)$，得到新行 $i$ 和新列 $N-1-(N-1-j) = j$。这就是 $(i,j)$，我们回到了起始位置。\n\n这揭示了旋转以四个不同位置的循环来置换元素（除非该位置是矩阵的正中心）：\n$$(i, j) \\to (j, N-1-i) \\to (N-1-i, N-1-j) \\to (N-1-j, i) \\to (i, j)$$\n\n通过为每个这样的四元素组系统地执行循环交换，可以旋转整个矩阵。单个临时变量足以执行一个 4 元素的循环交换。\n\n**3. 逐层算法方法**\n\n为确保每个元素只被移动一次，我们可以按同心方层或“壳”来处理矩阵。此类层的数量为 $\\lfloor N/2 \\rfloor$。\n\n-   一个外层循环遍历这些层，从最外层 $L=0$ 到最内层 $L = \\lfloor N/2 \\rfloor - 1$。\n-   对于每一层 $L$，一个内层循环沿着其一条边（例如，上边缘）的元素进行迭代。层 $L$ 的上边缘从列 $L$ 延伸到 $N-1-L$。我们只需要迭代到该边缘的倒数第二个元素，因为最后一个元素是一个角点，它将作为由不同边缘上的元素发起的循环的一部分被处理。因此，内层循环变量，我们称之为 $k$，从 $L$ 运行到 $N-1-L-1$。\n\n对于每对 $(L, k)$，我们识别一个唯一的 4 元素循环。让循环的第一个元素对应于由我们的循环定义的层上边缘的位置，因此其坐标为 $(i,j) = (L, k)$。循环中的其他三个位置则由上面推导的变换确定：\n-   位置 1 (顶部): $(L, k)$\n-   位置 2 (右侧): $(k, N-1-L)$\n-   位置 3 (底部): $(N-1-L, N-1-k)$\n-   位置 4 (左侧): $(N-1-k, L)$\n\n**4. 就地循环交换的实现**\n\n顺时针旋转需要将值从位置 1 移动到 2，从 2 移动到 3，从 3 移动到 4，从 4 移动到 1。这通过将一个值存储在临时变量中，然后将其余三个值沿值流动的相反方向移动来实现。\n\n设 `temp` 是一个临时变量。赋值顺序如下：\n1.  `temp` $\\leftarrow A[L, k]$ (保存顶部元素的值)\n2.  $A[L, k] \\leftarrow A[N-1-k, L]$ (将左侧元素移至顶部)\n3.  $A[N-1-k, L] \\leftarrow A[N-1-L, N-1-k]$ (将底部元素移至左侧)\n4.  $A[N-1-L, N-1-k] \\leftarrow A[k, N-1-L]$ (将右侧元素移至底部)\n5.  $A[k, N-1-L] \\leftarrow$ `temp` (将保存的顶部元素移至右侧)\n\n这一系列操作嵌套在用于层和元素的两个循环中，将仅使用一个临时变量正确地就地旋转整个矩阵，从而满足所有问题约束。空间复杂度为 $O(1)$，时间复杂度为 $O(N^2)$，因为每个元素被访问常数次。\n\n最终算法如下：\n1.  输入: $N \\times N$ 矩阵 $A$。\n2.  计算层数: `num_layers = N // 2`。\n3.  对于从 $0$ 到 `num_layers - 1` 的 $L$：\n4.      对于从 $L$ 到 $N - 1 - L - 1$ 的 $k$：\n5.          对由 $(L, k)$ 定义的循环中的元素执行上述的 4 路循环交换。\n6.  返回修改后的矩阵 $A$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rotate_matrix_in_place(matrix: np.ndarray):\n    \"\"\"\n    Rotates a square NxN matrix by 90 degrees clockwise in-place.\n    \n    The algorithm works by processing the matrix in concentric square layers.\n    For each layer, it performs a cyclic swap of 4 elements at a time.\n    \n    - The outer loop `L` iterates through the layers, from 0 to floor(N/2) - 1.\n    - The inner loop `k` iterates through the elements on one edge of the current layer.\n    - For each element on the top edge of a layer, we identify a 4-element cycle.\n      The positions in the cycle are:\n      - top: (L, k)\n      - right: (k, N-1-L)\n      - bottom: (N-1-L, N-1-k)\n      - left: (N-1-k, L)\n    - A single temporary variable is used to perform the clockwise cyclic swap:\n      left - top, bottom - left, right - bottom, top - right.\n    \"\"\"\n    n = matrix.shape[0]\n    if n = 1:\n        return\n\n    # Iterate through layers from outermost to innermost\n    for L in range(n // 2):\n        # Iterate through elements in the current layer's top edge\n        # The range is from the start of the layer to the element before the corner\n        for k in range(L, n - 1 - L):\n            # Save the top element\n            temp = matrix[L, k]\n            \n            # Move left element to top\n            matrix[L, k] = matrix[n - 1 - k, L]\n            \n            # Move bottom element to left\n            matrix[n - 1 - k, L] = matrix[n - 1 - L, n - 1 - k]\n            \n            # Move right element to bottom\n            matrix[n - 1 - L, n - 1 - k] = matrix[k, n - 1 - L]\n            \n            # Move saved top element to right\n            matrix[k, n - 1 - L] = temp\n\ndef solve():\n    \"\"\"\n    Solves the matrix rotation problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement using numpy arrays.\n    test_cases = [\n        np.array([[5]]),\n        np.array([[1, 2], [3, 4]]),\n        np.array([[-1, -2, -3], [4, 5, 6], [7, 8, 9]]),\n        np.array([[1, 1, 2, 2], [3, 3, 4, 4], [5, 5, 6, 6], [7, 7, 8, 8]]),\n        np.array([[0, 1, 2, 3, 4], \n                  [5, 0, 7, 8, 9], \n                  [10, 11, 0, 13, 14], \n                  [15, 16, 17, 0, 19], \n                  [20, 21, 22, 23, 0]])\n    ]\n\n    results_as_strings = []\n    for matrix in test_cases:\n        # Perform the in-place rotation\n        rotate_matrix_in_place(matrix)\n        \n        # Flatten the rotated matrix in row-major order\n        flattened_list = matrix.flatten().tolist()\n        \n        # Format the flattened list into the required string format \"[x,y,z]\"\n        list_str = f\"[{','.join(map(str, flattened_list))}]\"\n        results_as_strings.append(list_str)\n\n    # Final print statement in the exact required format: \"[[...],[...]]\"\n    final_output = f\"[{','.join(results_as_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3275330"}, {"introduction": "这个经典问题模拟了在一维地形剖面上计算积水量的场景，它考验的是你如何高效地处理和分析数组数据。最优解法采用了一种优雅的双指针技术，从数组两端向中心移动，从而避免了使用额外空间来存储边界信息。通过这个练习，你将学会如何通过巧妙的遍历策略，在 $O(N)$ 时间和 $O(1)$ 空间内解决看似需要全局信息的问题。[@problem_id:3275269]", "problem": "给定一个长度为 $n$ 的静态数组 $A$，它表示一个一维的海拔景观，其中每个条目 $A[i]$ 是一个非负整数，代表在索引 $i$ 处由单位单元构成的不可渗透垂直柱的高度，所有柱子的宽度统一为一个单位单元。发生了一次均匀的降雨，水在柱子之间形成的凹陷处积聚，直到达到流体静力平衡。在平衡状态下，水不能穿过柱子，不能从内部柱子之间逸出，但可以从数组最外两端自由溢出。假设重力垂直作用，且有水的地方水面是水平的，计算所有柱子上方容纳的水的单位单元总数。\n\n只能使用固定大小静态数组上可用的操作：基于索引的读取、向辅助变量进行基于索引的写入以及比较。你可以假设 $n$ 是一个整数且 $n \\ge 1$，所有高度都是整数且 $A[i] \\ge 0$，并且该景观在所述模型下是物理上合理的。\n\n你的程序必须处理以下静态数组测试套件，并为每个数组输出以单位单元（一个整数）计量的总积水体积：\n\n- $[0,1,0,2,1,0,1,3,2,1,2,1]$\n- $[1,2,3,4]$\n- $[4,3,2,1]$\n- $[0,0,0,0,0]$\n- $[5,0,0,0,5]$\n- $[3,0,2,0,4]$\n\n最终所需的输出格式为一行，包含按顺序排列的结果，形式为方括号内由逗号分隔的列表，例如 $[r_1,r_2,\\dots,r_6]$，其中每个 $r_k$ 是第 $k$ 个测试用例的总积水量的整数值。不应打印任何其他文本。", "solution": "## 问题验证\n\n### 步骤 1：提取已知条件\n- 数据结构：一个长度为 $n$ 的静态数组 $A$。\n- 数组条目：$A[i]$ 是一个表示海拔的非负整数。\n- 几何模型：由宽度统一为一个单位单元的垂直柱构成的一维景观。\n- 物理模型：\n    - 均匀降雨导致积水。\n    - 系统达到流体静力平衡。\n    - 柱子是不可渗透的。\n    - 水可以从数组的最外两端（$A[0]$ 和 $A[n-1]$）自由溢出。\n    - 水不能从内部柱子之间逸出。\n    - 重力垂直作用。\n    - 有水的地方水面是水平的。\n- 任务：计算所有柱子上方容纳的水的单位单元总数。\n- 约束条件：\n    - 允许的操作：基于索引的读取、向辅助变量进行基于索引的写入、比较。\n    - $n \\ge 1$ 且为整数。\n    - $A[i] \\ge 0$ 且为整数。\n    - 景观在物理上是合理的。\n- 测试用例：\n    1. $[0,1,0,2,1,0,1,3,2,1,2,1]$\n    2. $[1,2,3,4]$\n    3. $[4,3,2,1]$\n    4. $[0,0,0,0,0]$\n    5. $[5,0,0,0,5]$\n    6. $[3,0,2,0,4]$\n- 输出格式：一行，结果为方括号内以逗号分隔的列表：$[r_1,r_2,\\dots,r_6]$。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题陈述进行评估。\n\n- **科学性：** 该问题描述了一个简化但物理上一致的离散系统流体静力平衡模型。不可渗透的障碍、水平的水面以及水从边缘溢出等假设是构建可处理物理模型的标准理想化方法。该问题不含伪科学，并遵循基本的物理原理。\n- **适定性：** 问题是适定的。控制水积存的规则（由相邻更高的墙体包围以及从两端溢出）唯一地决定了景观中每一点的最终水位。这保证了对于任何给定的输入数组 $A$，都存在一个唯一的、稳定的、有意义的解。\n- **客观性：** 问题以客观和精确的语言表述。所有量（$A[i]$、$n$、单位单元）都有明确的定义，目标是计算总积水体积，这是一个明确的计算任务。\n\n该问题不存在任何无效性缺陷：\n1.  **科学/事实上不成立：** 无。该模型是一个有效的物理抽象。\n2.  **不可形式化/不相关：** 无。该问题是一个经典的算法挑战，可直接形式化，并与静态数组的主题相关。\n3.  **不完整/矛盾的设定：** 无。所有必要条件（$n \\ge 1$、$A[i] \\ge 0$、边界条件）都已提供并且相互一致。\n4.  **不切实际/不可行：** 无。该模型是一种理想化，但并非物理上不可能或科学上不合理。数据是一致的。\n5.  **不适定/结构不良：** 无。存在唯一解，并且所有术语都定义良好。\n6.  **故作高深/琐碎：** 无。该问题通常被称为“接雨水”，是一个需要仔细推理数组局部和全局属性的非平凡算法设计练习。\n7.  **超出科学可验证性范围：** 无。对于任何给定的输入，其解都是确定性可计算和可验证的。\n\n### 步骤 3：结论与行动\n该问题是 **有效的**。将提供一个解决方案。\n\n## 解决方案\n\n### 基于原理的设计\n问题在于计算由长度为 $n$ 的静态数组 $A$ 表示的一维海拔图中所困住的水的体积。其基本物理原理是，特定位置的水只能积聚到由周围地形限制的高度。\n\n对于任何给定的位置 $i$（其中 $0 \\le i  n$），水位受到其周围不可渗透柱子高度的限制。由于水可以从数组的两端溢出，只有当一个水坑被其左右两侧某处更高的柱子包围时，水才能形成。\n\n我们将其形式化。对于索引 $i$ 处高度为 $A[i]$ 的柱子，其上方能维持的最大水位 $h_i$ 由其左侧最高的柱子和其右侧最高的柱子决定。令 $L_i = \\max_{0 \\le j \\le i} A[j]$ 为从索引 $0$ 到 $i$ 的子数组中柱子的最大高度，令 $R_i = \\max_{i \\le j  n} A[j]$ 为从索引 $i$ 到 $n-1$ 的子数组中的最大高度。索引 $i$ 处的水面将是水平的，并受限于这两个周围峰值中较低的一个。因此，水位 $h_i$ 由以下公式给出：\n$$ h_i = \\min(L_i, R_i) $$\n在索引 $i$ 的柱子 *上方* 积存的水量，记为 $V_i$，是该水位与柱子本身高度之差。由于水量不能为负，我们有：\n$$ V_i = h_i - A[i] = \\min(L_i, R_i) - A[i] $$\n注意，根据 $L_i$ 和 $R_i$ 的定义，两者都大于或等于 $A[i]$，因此 $\\min(L_i, R_i) \\ge A[i]$，确保了 $V_i \\ge 0$。\n\n总积水体积 $V$ 是每个独立柱子上方体积的总和：\n$$ V = \\sum_{i=0}^{n-1} V_i = \\sum_{i=0}^{n-1} (\\min(L_i, R_i) - A[i]) $$\n\n基于此公式的直接计算效率低下。可以设计一种更高效的算法，通过认识到对每个单元，我们只需要其左侧和右侧的最大高度。一种朴素的实现方式是预先计算两个辅助数组，一个用于从左侧开始的最大值，一个用于从右侧开始的最大值，两者都可以在 $O(n)$ 时间内完成。然后，在最后一次 $O(n)$ 的遍历中计算总体积。这种方法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。\n\n一种最优算法可以使用双指针方法，以 $O(1)$ 的辅助空间复杂度达到相同结果。我们定义一个从索引 $0$ 开始的指针 `left` 和一个从索引 $n-1$ 开始的指针 `right`。我们还维护两个变量 `max_l` 和 `max_r`，分别存储从左端和右端至今遇到的最大高度。\n\n算法通过向内移动指针来进行：\n1. 初始化 `left = 0`，`right = n-1`，`max_l = 0`，`max_r = 0`，以及 `total_water = 0`。\n2. 当 `left  right` 时循环：\n   a. 比较两个指针处的高度，$A[\\text{left}]$ 和 $A[\\text{right}]$。\n   b. 如果 $A[\\text{left}] \\le A[\\text{right}]$：\n      `left` 位置的水位保证受限于左侧的最大高度 `max_l`，因为我们知道其右侧有一个高度至少为 $A[\\text{right}]$（即 $\\ge A[\\text{left}]$）的墙。我们更新 `max_l = \\max(\\text{max\\_l}, A[\\text{left}])$，并将该位置的积水量 $\\text{max\\_l} - A[\\text{left}]$ 加到总水量中。然后，我们增加 `left`。\n   c. 如果 $A[\\text{left}] > A[\\text{right}]$：\n      对称的论证适用。`right` 位置的水位受限于 `max_r`。我们更新 `max_r = \\max(\\text{max\\_r}, A[\\text{right}])$，并将 $\\text{max\\_r} - A[\\text{right}]$ 加到总水量中。然后，我们减少 `right`。\n3. 当 `left` 和 `right` 相遇或交错时，循环终止。累积的 `total_water` 即为最终结果。\n\n这种双指针方法每个元素只处理一次，因此时间复杂度为 $O(n)$，同时只使用常数数量的辅助变量，从而使空间复杂度达到 $O(1)$。这是满足问题约束的最有效方法。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the trapping rain water problem for a given suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        np.array([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]),\n        np.array([1, 2, 3, 4]),\n        np.array([4, 3, 2, 1]),\n        np.array([0, 0, 0, 0, 0]),\n        np.array([5, 0, 0, 0, 5]),\n        np.array([3, 0, 2, 0, 4]),\n    ]\n\n    def calculate_trapped_water(height: np.ndarray) -> int:\n        \"\"\"\n        Calculates the total volume of trapped water using a two-pointer approach.\n\n        This algorithm achieves O(n) time complexity and O(1) space complexity.\n\n        Args:\n            height: A numpy array of non-negative integers representing the elevation map.\n\n        Returns:\n            The total number of unit cells of water trapped.\n        \"\"\"\n        n = height.shape[0]\n        if n  3:\n            return 0\n\n        left, right = 0, n - 1\n        max_l, max_r = 0, 0\n        total_water = 0\n\n        while left  right:\n            # If the left column is shorter or equal to the right one\n            if height[left] = height[right]:\n                # The water level at 'left' is primarily determined by the max height\n                # seen from the left, because we know there's a boundary on the right\n                # that is at least as high as height[left].\n                if height[left] > max_l:\n                    # This column is a new left-side boundary, no water can be trapped above it.\n                    max_l = height[left]\n                else:\n                    # Water is trapped. The depth is max_l - height[left].\n                    total_water += max_l - height[left]\n                left += 1\n            else: # height[left] > height[right]\n                # Symmetrical case for the right pointer.\n                # The water level at 'right' is determined by max_r.\n                if height[right] > max_r:\n                    # New right-side boundary.\n                    max_r = height[right]\n                else:\n                    # Water is trapped. The depth is max_r - height[right].\n                    total_water += max_r - height[right]\n                right -= 1\n        \n        return int(total_water)\n\n    results = []\n    for case in test_cases:\n        result = calculate_trapped_water(case)\n        results.append(result)\n\n    # Final print statement must match the exact specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3275269"}]}