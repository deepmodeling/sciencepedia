{"hands_on_practices": [{"introduction": "本练习将介绍一个经典且强大的链表算法：“龟兔赛跑”或快慢指针技术。通过掌握此方法，你无需预先知道链表的长度，就能高效地解决涉及环、中点和奇偶性问题。这个练习 [@problem_id:3220641] 要求你应用此技术将一个循环链表分成相等的两半，这是一项基本的链表操作任务。", "problem": "给定一个环形单向链表。环形单向链表是一个节点序列，每个节点都有一个指向下一个节点的指针，且最后一个节点的 next 指针指回第一个节点。你只获得一个指向任意节点的指针，表示为 $p$，而没有指向任何指定的“头”节点。目标是设计一个算法，在节点数 $n$ 为偶数时，将该链表分割成两个大小相等的环形链表；在 $n$ 为奇数时，检测并报告无法进行等分。\n\n基本基础和假设：\n- 一个包含 $n$ 个节点的环形单向链表构成一个唯一的长度为 $n$ 的循环。\n- 在一个长度为 $n$ 的循环上，一个前进 $s$ 个节点的指针会到达一个由其起始位置经过 $s \\bmod n$ 步确定的位置。\n- 当使用两个指针，一个每次迭代前进 $1$ 个节点（“慢”指针），另一个每次迭代前进 $2$ 个节点（“快”指针）时，经过 $k$ 次迭代后，慢指针前进了 $k$ 步，快指针前进了 $2k$ 步。\n\n任务：\n- 从 $p$ 开始，确定链表的长度 $n$ 是否为偶数。如果是，找到沿循环领先 $p$ 恰好 $n/2$ 步的节点 $q$。\n- 重连 next 指针，形成两个大小相等的不相交环形链表。第一个链表必须包含 $p$，第二个链表必须包含 $q$。如果 $n$ 是奇数，则输出无法执行等分。\n- 分割算法必须仅依赖于从 $p$ 派生的链式结构中的指针操作，在分割步骤中不使用辅助数组来存储整个序列。\n\n用于测试的输入规范（嵌入在程序中）：\n- 程序将根据以下参数值的测试套件在内部构建环形单向链表。每个测试用例由一个包含节点值序列和从零开始的索引 $i$ 的对指定，$i$ 指示哪个节点的指针将作为任意指针 $p$ 提供。\n- 测试套件：\n    1. 值 $\\{10,20,30,40,50,60,70,80\\}$ 和索引 $i=3$。\n    2. 值 $\\{1,2\\}$ 和索引 $i=1$。\n    3. 值 $\\{5,5,5,5,5,5\\}$ 和索引 $i=4$。\n    4. 值 $\\{1,2,3,4,5\\}$ 和索引 $i=2$。\n    5. 值 $\\{0,-1,-2,-3\\}$ 和索引 $i=0$。\n\n输出规范：\n- 对于每个 $n$ 为偶数的测试用例，输出一个包含两个列表的列表：\n    - 第一个内部列表是从 $p$ 开始遍历第一个生成的环形链表，并在恰好 $n/2$ 步后返回到 $p$ 时遇到的值序列。\n    - 第二个内部列表是从 $q$ 开始遍历第二个生成的环形链表，并在恰好 $n/2$ 步后返回到 $q$ 时遇到的值序列。\n- 对于每个 $n$ 为奇数的测试用例，输出整数 $-1$。\n- 最终输出格式：你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素要么是 $-1$，要么是如上所述的一对列表（例如，$\\big[[a\\_1,a\\_2,\\dots],[b\\_1,b\\_2,\\dots]\\big]$）。\n\n解决方案中需展示的正确性标准：\n- 论证快慢指针技术如何在不需要头指针的情况下检测 $n$ 的奇偶性并识别分割点 $q$。\n- 解释为什么当 $n$ 为偶数时，通过局部指针更改的重连操作会产生两个长度相等的不相交循环。\n- 提供使用大O符号（Big-O）表示的渐进时间复杂度和空间复杂度。\n\n程序必须实现此逻辑，并为所提供的测试套件生成准确的聚合输出。此问题不涉及物理单位、角度单位或百分比单位。", "solution": "对用户提供的问题陈述进行形式化分析和验证。\n\n### 步骤1：提取已知条件\n- **数据结构**：一个具有未知节点数 $n$ 的环形单向链表。\n- **输入**：一个指向链表中任意节点的指针 $p$。\n- **目标**：\n    1. 确定链表长度 $n$ 是偶数还是奇数。\n    2. 如果 $n$ 是偶数，将链表分割成两个大小相等（$n/2$）的不相交环形链表。第一个链表必须包含 $p$，第二个链表必须包含距离 $p$ 为 $n/2$ 步的节点 $q$。\n    3. 如果 $n$ 是奇数，报告无法进行等分。\n- **约束条件**：算法必须“就地”操作，仅使用指针操作，在分割过程中不使用如数组之类的辅助数据结构来存储节点序列。\n- **基本假设**：\n    - 一个包含 $n$ 个节点的环形链表形成一个长度为 $n$ 的单一循环。\n    - 在长度为 $n$ 的循环上，指针前进 $s$ 步会到达一个由 $s \\pmod n$ 决定的位置。\n    - 一个慢指针（每次迭代前进1步）和一个快指针（每次迭代前进2步）在 $k$ 次迭代后，分别移动了 $k$ 步和 $2k$ 步。\n- **输出规范**：对于偶数 $n$，输出一个包含两个节点值列表的列表，对应于从 $p$ 和 $q$ 开始的两个新循环。对于奇数 $n$，输出整数 $-1$。\n- **正确性标准**：解决方案必须论证奇偶性检测方法的正确性、分割过程的正确性，并提供时间和空间复杂度的分析。\n\n### 步骤2：使用提取的已知条件进行验证\n对问题进行严格的验证过程。\n- **科学依据**：该问题设置在数据结构与算法这一计算机科学的核心领域内。它依赖于公认的概念，如链表、指针运算和“龟兔赛跑”（快慢指针）算法。所有前提在事实上和逻辑上都是合理的。\n- **良置性**：该问题是良置的。输入、目标和约束条件都以数学精度进行了规定。对于偶数和奇数长度的情况，期望的输出都有明确的定义，确保可以推导出唯一且有意义的解决方案。\n- **客观性**：问题以客观、形式化的语言陈述，没有任何主观或含糊的术语。\n\n### 步骤3：结论与行动\n问题陈述是**有效的**。它自洽、逻辑一致，并基于计算机科学的既定原则。因此，有必要提供一个完整的解决方案。\n\n### 算法设计与论证\n\n解决方案是一个三步过程：（1）确定链表长度 $n$ 的奇偶性，并同时找到分割点 $q$；（2）重连指针以形成两个独立的链表；（3）分析算法的性能。\n\n**第1部分：奇偶性检测与分割点识别**\n\n此步骤的核心是快慢指针技术。我们将两个指针 `slow` 和 `fast` 初始化为给定的起始节点 $p$。\n- `slow_ptr` = $p$\n- `fast_ptr` = $p$\n\n然后我们进行迭代，以不同的速度推进指针，直到满足终止条件。在每次迭代 $k \\ge 1$ 中：\n- `slow_ptr` 前进 $1$ 步：`slow_ptr = slow_ptr.next`。\n- `fast_ptr` 前进 $2$ 步：`fast_ptr = fast_ptr.next.next`。\n\n经过 $k$ 次迭代后，`slow_ptr` 从 $p$ 移动了 $k$ 步，`fast_ptr` 从 $p$ 移动了 $2k$ 步。关键在于 `fast_ptr` 首次返回起始节点 $p$ 的时机。\n\n**论证**：\n- **情况1：$n$ 为偶数。** 设 $n = 2m$，其中 $m \\ge 1$ 为整数。当 `fast_ptr` 的总位移 $2k$ 是 $n=2m$ 的倍数时，它会返回到 $p$。发生这种情况的最小正整数 $k$ 是 $k=m$。在这一刻：\n    - `fast_ptr` 位于相对于 $p$ 的位置 $(2m) \\pmod{2m} = 0$。因此，`fast_ptr == p`。\n    - `slow_ptr` 位于相对于 $p$ 的位置 $k=m=n/2$。这正是所期望的分割节点 $q$ 的定义。\n    - 在这种情况下，条件 `fast_ptr.next == p` 在 `fast_ptr == p` 之前永远不会满足，因为那将意味着 $2k+1$ 是 $n=2m$ 的倍数，这是不可能的，因为一个奇数不能是一个偶数的倍数。\n\n- **情况2：$n$ 为奇数。** 设 $n = 2m+1$，其中 $m \\ge 1$ 为整数。\n    - 要使 `fast_ptr` 位于 $p$， $2k$ 必须是 $n=2m+1$ 的倍数。由于 $\\gcd(2, 2m+1) = 1$，这要求 $k$ 是 $n$ 的倍数。第一次发生这种情况是在 $k=n$ 步时。\n    - 考虑条件 `fast_ptr.next == p`。这意味着 `fast_ptr` 位于 $p$ 的前一个节点，即相对于 $p$ 的位置 $n-1$ 或 $-1$。这种情况在 $2k \\equiv n-1 \\pmod n$ 时发生。对于 $n=2m+1$，即 $2k \\equiv 2m \\pmod{2m+1}$。如果我们选择 $k=m$，我们有 $2m \\equiv 2m \\pmod{2m+1}$，这是成立的。此条件在 $k=m=(n-1)/2$ 步时满足。\n    - 由于 $k=(n-1)/2$ 小于 $k=n$，对于奇数长度的链表，条件 `fast_ptr.next == p` 将首先被满足。\n\n因此，算法如下：\n1. 将 `slow` 和 `fast` 指针初始化为 $p$。\n2. 循环，每步将 `slow` 前进 1，`fast` 前进 2。\n3. 如果 `fast == p`，链表长度为偶数。此时 `slow` 指针指向 $q$。继续执行第2部分。\n4. 如果 `fast.next == p`，链表长度为奇数。无法进行等分。终止并报告。\n\n**第2部分：偶数 $n$ 的链表分割**\n\n如果链表长度 $n$ 为偶数，第1部分为我们提供了指针 $p$ 和指针 $q$（即 `slow_ptr` 的最终位置）。节点 $q$ 距离 $p$ 恰好 $n/2$ 步。原始链表结构是一个单一循环：\n$p \\rightarrow \\dots \\rightarrow p_{\\text{end}} \\rightarrow q \\rightarrow \\dots \\rightarrow q_{\\text{end}} \\rightarrow p$\n\n要创建两个长度为 $n/2$ 的不相交循环，我们必须识别节点 $p_{\\text{end}}$ 和 $q_{\\text{end}}$ 并重新映射它们的 `next` 指针。\n- $p_{\\text{end}}$ 是 $q$ 的前驱节点。\n- $q_{\\text{end}}$ 是 $p$ 的前驱节点。\n\n通过简单的遍历可以找到这些前驱节点：\n- 找到 $p_{\\text{end}}$：从 $p$ 开始一个临时指针，并前进直到其 `next` 指针为 $q$。这需要 $n/2 - 1$ 步。\n- 找到 $q_{\\text{end}}$：从 $q$ 开始一个临时指针，并前进直到其 `next` 指针为 $p$。这也需要 $n/2 - 1$ 步。\n\n一旦找到 $p_{\\text{end}}$ 和 $q_{\\text{end}}$，重连操作就很简单了：\n1. `p_end.next = p`\n2. `q_end.next = q`\n\n这将第一条链的末端重定向回其起点 ($p$)，并将第二条链的末端重定向回其起点 ($q$)，从而创建了两个独立的环形链表：\n- 循环1: $p \\rightarrow \\dots \\rightarrow p_{\\text{end}} \\rightarrow p$\n- 循环2: $q \\rightarrow \\dots \\rightarrow q_{\\text{end}} \\rightarrow q$\n\n两个循环的长度都为 $n/2$，符合要求。此过程仅依赖于局部指针操作，并遵守了问题的约束。\n\n**第3部分：复杂度分析**\n\n- **时间复杂度**：算法的运行时间主要由指针遍历决定。\n    - 奇偶性检测（第1部分）：循环运行约 $n/2$ 次迭代。每次迭代中，我们执行常数次操作（3次指针前进）。这是 $O(n)$。\n    - 寻找前驱节点（第2部分，对于偶数 $n$）：找到 $p_{\\text{end}}$ 需要 $n/2 - 1$ 步。找到 $q_{\\text{end}}$ 需要 $n/2 - 1$ 步。这也是 $O(n)$。\n    - 总体时间复杂度为 $O(n) + O(n) = O(n)$。\n\n- **空间复杂度**：算法使用固定数量的指针（`p`、`q`、`slow`、`fast` 以及用于遍历的临时指针），无论链表的大小如何。没有使用随 $n$ 规模增长的辅助数据结构。\n    - 空间复杂度是常数级的，即 $O(1)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"A node in a circular singly linked list.\"\"\"\n    def __init__(self, value, next_node=None):\n        self.value = value\n        self.next = next_node\n\n    def __repr__(self):\n        return f\"Node({self.value})\"\n\ndef build_circular_linked_list(values, start_index):\n    \"\"\"Constructs a circular linked list from a sequence of values.\"\"\"\n    if not values:\n        return None\n    \n    n = len(values)\n    nodes = [Node(val) for val in values]\n    \n    for i in range(n):\n        nodes[i].next = nodes[(i + 1) % n]\n        \n    return nodes[start_index]\n\ndef traverse_and_collect(start_node):\n    \"\"\"Traverses a circular list from a start node and collects values.\"\"\"\n    if not start_node:\n        return []\n    \n    path = []\n    current = start_node\n    while True:\n        path.append(current.value)\n        current = current.next\n        if current == start_node:\n            break\n    return path\n\ndef split_circular_list(p):\n    \"\"\"\n    Splits a circular linked list into two halves if its length is even.\n    \n    Args:\n        p: A pointer to an arbitrary node in the circular linked list.\n\n    Returns:\n        A list of two lists of node values for the new cycles if n is even.\n        -1 if n is odd.\n    \"\"\"\n    if not p or p.next == p:\n        # A list with 0 or 1 node cannot be split into two non-empty lists.\n        # The problem implies n >= 2 for a split. Odd length -> impossible.\n        return -1\n        \n    slow = p\n    fast = p\n    \n    while True:\n        slow = slow.next\n        \n        # Fast pointer must be able to advance twice\n        if not fast.next or not fast.next.next:\n            # This case should not be reached in a proper circular list > 1 node\n            return -1 \n        fast = fast.next.next\n        \n        # Condition for odd length list\n        if fast.next == p:\n            return -1\n        \n        # Condition for even length list\n        if fast == p:\n            q = slow\n            break\n            \n    # At this point, n is even and q is the node at distance n/2 from p.\n    # Now we need to find the predecessors of p and q to rewire the list.\n    \n    # Find p_end (predecessor of q)\n    p_end = p\n    while p_end.next != q:\n        p_end = p_end.next\n        \n    # Find q_end (predecessor of p)\n    q_end = q\n    while q_end.next != p:\n        q_end = q_end.next\n        \n    # Rewire the pointers to form two separate cycles\n    p_end.next = p\n    q_end.next = q\n    \n    # Collect the values from the two new lists\n    list1_values = traverse_and_collect(p)\n    list2_values = traverse_and_collect(q)\n    \n    return [list1_values, list2_values]\n    \ndef solve():\n    \"\"\"\n    Defines test cases and runs the splitting algorithm on each,\n    producing the final formatted output.\n    \"\"\"\n    test_suite = [\n        ({'values': [10, 20, 30, 40, 50, 60, 70, 80], 'index': 3}),\n        ({'values': [1, 2], 'index': 1}),\n        ({'values': [5, 5, 5, 5, 5, 5], 'index': 4}),\n        ({'values': [1, 2, 3, 4, 5], 'index': 2}),\n        ({'values': [0, -1, -2, -3], 'index': 0}),\n    ]\n\n    results = []\n    for case in test_suite:\n        p = build_circular_linked_list(case['values'], case['index'])\n        result = split_circular_list(p)\n        \n        if result == -1:\n            results.append(str(-1))\n        else:\n            list1, list2 = result\n            l1_str = f\"[{','.join(map(str, list1))}]\"\n            l2_str = f\"[{','.join(map(str, list2))}]\"\n            results.append(f\"[{l1_str},{l2_str}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3220641"}, {"introduction": "合并有序数据结构是计算机科学的基石，它构成了归并排序等算法的基础。本练习将这一基本任务应用于循环链表的独特背景下。你将练习一种常见的问题解决策略：将一个特殊的数据结构暂时转换为一个更简单的结构（线性链表），应用标准算法，然后恢复其原始结构 [@problem_id:3220711]。", "problem": "给定两个已排序的循环单链表，其节点包含整数键值。循环单链表被定义为一系列节点，其中每个节点都有一个指向下一个节点的单指针，且最后一个节点指回初始节点，形成一个环。已排序的循环单链表是指存在一个指定的起始节点（称为头节点），从该头节点开始遍历恰好等于列表中节点数的次数，会得到一个非递减的键值序列。目标是通过仅重用现有节点和重设指针，将两个输入链表合并为一个已排序的循环单链表。合并必须在 $O(n+m)$ 时间内完成，其中 $n$ 和 $m$ 分别是两个输入链表的长度，并且节点只需 $O(1)$ 的额外空间。您可以使用辅助变量和常数个额外指针，但不得分配、删除或复制任何节点。\n\n使用的基本定义：\n- 单链表节点由一个整数集中的键值和一个指向下一节点的单指针组成。循环单链表的特征是不变量：最后一个节点的 next 指针引用头节点。\n- 如果对于每对相邻的键值 $x_i$ 和 $x_{i+1}$，都有 $x_i \\le x_{i+1}$，则称序列为非递减排序。\n\n任务：\n1. 从基本原理出发，构建一个方法，该方法仅使用指针重设和整数键值比较，确定性地生成一个正确的合并后循环链表。您必须基于有序性和循环性的不变量来论证其正确性，并实现 $O(n+m)$ 的时间复杂度。\n2. 在一个完整的可运行程序中实现此方法，该程序：\n   - 根据给定的有限整数序列（每个序列代表从头节点开始遍历恰好等于链表长度的顺序）在内部构建循环链表。\n   - 将两个循环链表合并为一个已排序的循环链表。\n   - 通过选择合并后链表中键值最小的节点作为头节点，并遍历恰好 $n+m$ 步，生成合并后循环链表的规范线性表示作为输出。如果两个输入链表均为空，则合并后的链表为空，该情况的输出为空列表。\n\n测试套件：\n对于下方的每个测试用例，程序必须：\n- 根据提供的序列 $A$ 和 $B$ 构建两个循环链表。\n- 在 $O(n+m)$ 的时间内将它们合并为一个已排序的循环链表。\n- 输出一个列表，表示从合并后链表中的最小键值开始，遍历恰好 $|A|+|B|$ 步的结果。\n\n测试用例如下：\n- 用例 $1$：$A=\\langle 1,4,7 \\rangle$， $B=\\langle 2,3,9,10 \\rangle$。\n- 用例 $2$：$A=\\langle \\rangle$， $B=\\langle 5,6 \\rangle$。\n- 用例 $3$：$A=\\langle \\rangle$， $B=\\langle \\rangle$。\n- 用例 $4$：$A=\\langle 1,1,2 \\rangle$， $B=\\langle 1,2,2,3 \\rangle$。\n- 用例 $5$：$A=\\langle 5 \\rangle$， $B=\\langle 4 \\rangle$。\n- 用例 $6$：$A=\\langle -3,-1,2 \\rangle$， $B=\\langle -2,0,1,3 \\rangle$。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result_1,result_2,\\dots]$）。每个 $result_i$ 必须是一个 Python 整数列表，表示相应测试用例的合并后遍历结果。", "solution": "问题要求合并两个已排序的循环单链表（分别表示为 $A$ 和 $B$，长度为 $n$ 和 $m$）成一个单一的已排序循环单链表。约束条件是合并必须通过重设指针原地执行，时间复杂度为 $O(n+m)$，关于节点分配的空间复杂度为 $O(1)$。\n\n首先，我们确立问题陈述的有效性。\n\n### 步骤1：提取给定信息\n- **输入数据**：两个已排序的循环单链表。设其头节点为 $H_A$ 和 $H_B$。\n- **节点定义**：一个节点包含一个整数键值和一个 `next` 单指针。\n- **循环链表定义**：遍历序列中的最后一个节点指回头节点。\n- **已排序循环链表定义**：存在一个头节点，从该节点开始遍历链表长度的次数，会得到一个非递减的键值序列。每个测试用例的输入序列代表从指定的头节点开始的这种遍历。\n- **目标**：将两个链表合并为一个单一的已排序循环单链表。\n- **约束条件**：\n    - 合并必须是原地的（重用现有节点）。\n    - 时间复杂度必须为 $O(n+m)$。\n    - 用于新节点的辅助空间必须为 $O(1)$，但允许使用常数个额外指针。\n- **输出规格**：合并后的链表必须表示为一个线性的键值序列，该序列通过从具有最小键值的节点开始遍历生成。对于两个空链表，输出为空列表。\n- **测试用例**：\n    - 用例 $1$：$A=\\langle 1,4,7 \\rangle$， $B=\\langle 2,3,9,10 \\rangle$。\n    - 用例 $2$：$A=\\langle \\rangle$， $B=\\langle 5,6 \\rangle$。\n    - 用例 $3$：$A=\\langle \\rangle$，$B=\\langle \\rangle$。\n    - 用例 $4$：$A=\\langle 1,1,2 \\rangle$， $B=\\langle 1,2,2,3 \\rangle$。\n    - 用例 $5$：$A=\\langle 5 \\rangle$， $B=\\langle 4 \\rangle$。\n    - 用例 $6$：$A=\\langle -3,-1,2 \\rangle$， $B=\\langle -2,0,1,3 \\rangle$。\n\n### 步骤2：使用提取的给定信息进行验证\n该问题定义明确，且基于计算机科学中数据结构与算法这一标准主题。\n- **科学性**：循环链表、有序性以及原地合并等概念是既定且形式化的主题。没有违反科学或事实之处。\n- **适定性**：“已排序循环链表”的定义对于给定的输入是明确的。从最小键值开始的规范输出格式确保了解决方案表示的唯一性。\n- **完整性与一致性**：所有必要的定义和约束（时间、空间、原地操作）都已提供。边界情况，如空链表，也已明确提及。问题是自包含且无矛盾的。\n\n### 步骤3：结论与行动\n该问题被判定为**有效**。我们继续构建解决方案。\n\n### 基于原理的合并算法设计\n\n核心原理是将合并两个已排序循环链表的问题，简化为合并两个已排序线性链表这一众所周知的问题。这可以通过暂时断开环，执行标准的线性合并，然后在最终合并的链表中恢复循环性来实现。\n\n**步骤 $1$：处理边界情况**\n最简单的情况涉及一个或两个链表为空。\n- 如果链表 $A$ 为空（即其头指针 $H_A$ 为空），则合并的结果就是链表 $B$。\n- 如果链表 $B$ 为空（即其头指针 $H_B$ 为空），则结果是链表 $A$。\n- 如果两者都为空，则结果是一个空链表（一个空指针）。\n\n**步骤 $2$：将循环链表线性化**\n要执行线性合并，我们必须首先将循环链表视为线性链表。一个头节点为 $H$、长度为 $N > 0$ 的已排序循环链表，有一个唯一的尾节点 $T$，使得从 $H$ 开始遍历 $N-1$ 步到达 $T$，且 $T.\\text{next} = H$。\n1.  识别链表 $A$ 的尾节点，记为 $T_A$。这可以通过从 $H_A$ 开始遍历，直到找到一个节点 `curr` 使得 `curr.next` 等于 $H_A$ 来实现。此操作耗时 $O(n)$。对于只有一个节点的链表，头节点也是尾节点。\n2.  类似地，在 $O(m)$ 时间内识别链表 $B$ 的尾节点，记为 $T_B$。\n3.  通过设置 $T_A.\\text{next} = \\text{null}$ 和 $T_B.\\text{next} = \\text{null}$ 来断开循环链接。现在我们有两个标准的已排序线性链表，分别从 $H_A$ 和 $H_B$ 开始。\n\n**步骤 $3$：执行原地线性合并**\n我们将两个线性链表合并成一个单一的已排序线性链表。一个稳健的方法是使用一个虚拟头节点来简化合并后链表的初始化。\n1.  创建一个临时的虚拟节点 `dummy_head`。创建一个指针 `current_tail` 并将其初始化为 `dummy_head`。这个 `current_tail` 指针将跟踪新形成链表的末端。\n2.  初始化两个指针，$p_A = H_A$ 和 $p_B = H_B$，用于遍历这两个链表。\n3.  当 $p_A$ 和 $p_B$ 都不为空时进行迭代。在每次迭代中，比较 $p_A$ 和 $p_B$ 处的键值。\n    - 如果 $p_A.\\text{key} \\le p_B.\\text{key}$，则通过设置 `current_tail.next = p_A` 将 $p_A$ 附加到合并链表中，并将 $p_A$ 前进到其下一个节点。\n    - 否则，通过设置 `current_tail.next = p_B` 附加 $p_B$，并将 $p_B$ 前进。\n    - 无论哪种情况，都将 `current_tail` 前进到刚刚附加的节点（`current_tail = current_tail.next`）。\n4.  循环终止后，其中一个链表将被遍历完（其指针将为空）。另一个链表可能仍包含剩余节点。将未遍历完链表的整个剩余部分附加到合并链表的末尾。如果 $p_A$ 不为空，则 `current_tail.next = p_A`。否则，`current_tail.next = p_B`。\n\n完全合并后的线性链表的头节点是 `dummy_head.next`。根据问题对已排序循环链表的定义，给定的头节点 $H_A$ 和 $H_B$ 分别是它们各自链表的最小元素。线性合并过程从选择 $H_A$ 和 $H_B$ 中较小的一个开始，确保合并后链表的头节点是全局最小元素。\n\n**步骤 $4$：恢复循环性**\n线性合并后，我们得到一个单一的已排序线性链表。最后一步是使其变为循环的。\n1.  合并后链表的头节点 `merged_head` 是 `dummy_head.next`。\n2.  合并后链表的尾节点是最后附加其剩余部分的原链表的尾节点。如果链表 $A$ 先被遍历完，则 $B$ 的剩余部分被附加，新的尾节点是原来的 $T_B$。如果 $B$ 先被遍历完，则新的尾节点是 $T_A$。如果两个链表同时被遍历完，则新的尾节点是循环中 `current_tail` 的最终值。一个简单的识别尾节点的方法是，我们已经存储了 $T_A$ 和 $T_B$。指向被附加的链表段的指针（循环后的 `p_A` 或 `p_B`）决定了最终的尾节点。\n3.  将这个新尾节点的 `next` 指针设置为指向 `merged_head`。\n\n**复杂度分析**\n- **时间复杂度**：找到尾节点需要 $O(n) + O(m)$。线性合并涉及对所有节点的一次遍历，需要 $O(n+m)$。所有其他操作（指针赋值）需要 $O(1)$ 时间。总时间复杂度为 $O(n+m)$。\n- **空间复杂度**：该算法使用常数数量的辅助指针（$H_A, T_A, H_B, T_B, p_A, p_B, \\text{dummy\\_head}, \\text{current\\_tail}$）。除了单个 `dummy_head` 外，没有分配新节点。因此，辅助空间复杂度为 $O(1)$，满足问题的约束。\n\n此过程正确且高效地合并了两个链表，同时遵守所有指定约束。生成的链表是有序且循环的，其头节点是具有最小键值的节点，为规范输出遍历做好了准备。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    A node in a singly linked list.\n    It holds an integer key and a pointer to the next node.\n    \"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.next = None\n\n    def __repr__(self):\n        return f\"Node({self.key})\"\n\ndef build_circular_list(sequence):\n    \"\"\"\n    Builds a sorted circular singly linked list from a sequence of integers.\n    The sequence is assumed to be sorted and represents the traversal from the head.\n    \"\"\"\n    if not sequence:\n        return None\n\n    head = Node(sequence[0])\n    current = head\n    for i in range(1, len(sequence)):\n        current.next = Node(sequence[i])\n        current = current.next\n    \n    # Make it circular\n    current.next = head\n    return head\n\ndef traverse_and_format(head):\n    \"\"\"\n    Traverses a circular linked list starting from the head and returns the keys as a list.\n    \"\"\"\n    if not head:\n        return []\n\n    result = []\n    current = head\n    # Use a do-while loop emulation\n    result.append(current.key)\n    current = current.next\n    while current != head:\n        result.append(current.key)\n        current = current.next\n    \n    return result\n\ndef merge_sorted_circular_lists(head_a, head_b):\n    \"\"\"\n    Merges two sorted circular singly linked lists into one.\n\n    The method follows these steps:\n    1. Handles edge cases where one or both lists are empty.\n    2. Finds the tail of each list to facilitate breaking the circular structure.\n    3. Breaks the circles, turning them into two sorted linear lists.\n    4. Performs an in-place merge of the two linear lists.\n    5. Restores the circular structure on the final merged list.\n    \"\"\"\n    # 1. Handle edge cases\n    if not head_a:\n        return head_b\n    if not head_b:\n        return head_a\n\n    # 2. Find the tails of both lists\n    tail_a = head_a\n    while tail_a.next != head_a:\n        tail_a = tail_a.next\n    \n    tail_b = head_b\n    while tail_b.next != head_b:\n        tail_b = tail_b.next\n\n    # 3. Temporarily break the circles to form linear lists\n    tail_a.next = None\n    tail_b.next = None\n\n    # 4. Perform in-place linear merge using a dummy head\n    p_a, p_b = head_a, head_b\n    dummy_head = Node(None)  # A temporary node\n    current_tail = dummy_head\n\n    while p_a and p_b:\n        if p_a.key = p_b.key:\n            current_tail.next = p_a\n            p_a = p_a.next\n        else:\n            current_tail.next = p_b\n            p_b = p_b.next\n        current_tail = current_tail.next\n\n    # Append the remaining list\n    # The new overall tail will be the tail of the list that is appended.\n    if p_a:\n        current_tail.next = p_a\n    else: # p_b must exist or be None\n        current_tail.next = p_b\n\n    merged_head = dummy_head.next\n    \n    # If merged list is empty (should not happen if inputs are valid), return None\n    if not merged_head:\n        return None\n\n    # 5. Restore circularity\n    # If both lists had elements, new_tail is correctly set.\n    # If one of the original lists was empty (handled at start), this code is not reached.\n    # If both input lists had equal length and merge ended perfectly,\n    # current_tail is the true tail. new_tail was set to tail_b by default.\n    final_tail = current_tail\n    while final_tail.next:\n        final_tail = final_tail.next\n    \n    final_tail.next = merged_head\n    \n    return merged_head\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        ([1, 4, 7], [2, 3, 9, 10]),\n        # Case 2\n        ([], [5, 6]),\n        # Case 3\n        ([], []),\n        # Case 4\n        ([1, 1, 2], [1, 2, 2, 3]),\n        # Case 5\n        ([5], [4]),\n        # Case 6\n        ([-3, -1, 2], [-2, 0, 1, 3]),\n    ]\n\n    results = []\n    for case_a, case_b in test_cases:\n        head_a = build_circular_list(case_a)\n        head_b = build_circular_list(case_b)\n\n        merged_head = merge_sorted_circular_lists(head_a, head_b)\n        \n        # The problem requires traversal starting from the smallest key.\n        # The merge logic ensures merged_head is the node with the minimum key\n        # because the input heads are the minimums of their respective lists.\n        result_list = traverse_and_format(merged_head)\n        results.append(result_list)\n\n    # Format the final output as a string representing a list of lists.\n    # Python's default str() for a list already uses brackets and commas, so this is simple.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3220711"}, {"introduction": "在时间和空间复杂度最优的情况下对链表进行原地排序，是熟练掌握数据结构高级技巧的标志。这个问题要求你实现一个迭代的自底向上归并排序，这是一个相当复杂的算法，它通过避免递归来满足严格的 $O(1)$ 空间限制。成功完成此练习 [@problem_id:3220604] 表明你对指针操作和算法控制流有了深刻的理解。", "problem": "您的任务是设计并实现一个算法，该算法接收一个循环单链表（其每个节点包含一个整数键值），通过重排节点指针，使得从头节点开始遍历 $n$ 步时，节点顺序呈非递减排列，其中 $n$ 是链表中的节点数。该算法的运行时间必须为 $O(n \\log n)$，仅使用 $O(1)$ 的额外空间，并且不得分配辅助数组、使用递归，或创建超过常数个额外节点或指针。循环单链表定义为一系列节点，其中每个节点都有一个指向其后继节点的指针，且最后一个节点指向第一个节点。\n\n基本依据和定义：\n- 单链表是一系列节点，其中每个节点都有一个指向下一个节点的指针和一个存储的键值。循环单链表是一种单链表，其中最后一个节点指向第一个节点，形成一个环。节点数用 $n$ 表示。\n- 允许的操作包括比较整数键值、读取和写入指针以及重新链接节点指针。存储的键值可以是任何整数，包括负值和重复值。不允许使用超出 $O(1)$ 额外空间的外部内存；具体来说，您可以使用常数个临时指针和可选的常数大小的辅助节点，但不得分配数组或使用其栈深度依赖于 $n$ 的递归。\n\n您的目标：\n- 从第一性原理出发，推导一种在 $O(n \\log n)$ 时间和仅 $O(1)$ 额外空间内对循环单链表进行非递减排序的方法。您的推导应仅基于链表的核心定义和基于比较的归并操作的不变性，不走捷径。\n- 将此方法实现为一个完整的、可运行的程序，该程序构建几个测试用的循环链表，对它们进行原地排序，并将其排序后的内容作为整数列表输出。\n\n测试套件：\n提供并处理以下测试用例，每个用例表示为一个整数数组，将被嵌入程序中并在排序前转换为循环单链表：\n1. 空列表：$[\\ ]$，其中 $n = 0$。\n2. 单个元素：$[7]$，其中 $n = 1$。\n3. 已排序：$[1,2,3,4,5]$，其中 $n = 5$。\n4. 逆序：$[5,4,3,2,1]$，其中 $n = 5$。\n5. 有重复值：$[3,1,2,3,2,1]$，其中 $n = 6$。\n6. 旋转的非递减循环列表：$[4,5,1,2,3]$，其中 $n = 5$。\n7. 混合负数：$[-2,-1,-3,0,2]$，其中 $n = 5$。\n8. 所有元素相等：$[2,2,2,2]$，其中 $n = 4$。\n\n输出规范：\n- 对于每个测试用例，排序后，通过从头节点开始在结果循环链表中遍历 $n$ 步，提取出恰好 $n$ 个值，生成一个非递减的数组表示。\n- 您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，[$r_1$,$r_2$,$r_3$,$\\dots$]），其中每个 $r_i$ 是测试用例 $i$ 的非递减整数列表。不应打印任何其他文本。", "solution": "提交审议的问题陈述是有效的。在数据结构和算法领域，这是一个定义明确、有科学依据的问题。目标是为循环单链表设计并实现一个时间复杂度为 $O(n \\log n)$、空间复杂度为 $O(1)$ 的原地排序算法，其中 $n$ 是节点数。其约束条件虽然严格但并不矛盾，它们定义了一个经典的、非平凡的算法挑战。该问题是可形式化的，其解决方案是可验证的。因此，我们可以着手进行推导和求解。\n\n推导从第一性原理出发，通过分析约束条件来选择和改造一个合适的排序算法。\n\n**1. 算法选择：归并排序**\n\n$O(n \\log n)$ 的时间复杂度和链表数据结构的约束强烈指向**归并排序** (Merge Sort)。我们来分析一下其他替代方案：\n- 最坏情况时间复杂度为 $O(n^2)$ 的基于比较的排序算法，如**插入排序** (Insertion Sort) 或**选择排序** (Selection Sort)，速度太慢，无法满足 $O(n \\log n)$ 的要求。\n- **快速排序** (Quick Sort) 虽然平均时间复杂度为 $O(n \\log n)$，但并不适合链表。其效率依赖于一个划分步骤，该步骤需要高效地访问相对于主元 (pivot) 的元素。在数组中，这通过交换两端元素来实现，这是一种随机访问操作。在链表中，这将需要复杂的指针操作或向后遍历，而单链表不支持向后遍历，从而降低性能并使实现复杂化。此外，其最坏情况时间复杂度仍为 $O(n^2)$。\n- **堆排序** (Heap Sort) 需要一个堆数据结构，而堆最有效的实现是使用数组，以便以 $O(1)$ 的时间计算父节点和子节点的索引。在链表上模拟堆效率低下，无法达到期望的时间复杂度。\n\n**归并排序**是自然的选择。它通过递归地将列表分成两半并合并已排序的半部分来运作。这种顺序访问模式与链表的结构完美兼容。标准的归并排序能达到 $O(n \\log n)$ 的时间复杂度。然而，标准实现是递归的，对于大小为 $n$ 的列表，它会在调用栈上消耗 $O(\\log n)$ 的空间。这违反了严格的 $O(1)$ 空间约束。\n\n**2. 遵循空间约束：迭代式自底向上归并排序**\n\n为了满足 $O(1)$ 的空间约束，我们必须采用**迭代式、自底向上** (iterative, bottom-up) 的归并排序。这种方法通过从最小的已排序子列表开始，并系统地将它们合并成逐渐增大的已排序子列表来消除递归。\n\n该算法分趟 (pass) 进行。在第一趟中，我们将单个节点视为大小为 $k=1$ 的已排序子列表。我们合并相邻的这些子列表对，形成大小为 $2$ 的已排序子列表。在第二趟中，我们设置 $k=2$，并合并相邻的大小为 $2$ 的已排序子列表，形成大小为 $4$ 的已排序子列表。这个过程持续进行，每一趟都将子列表大小 $k$ 加倍 ($k = 1, 2, 4, 8, \\dots$)，直到整个列表成为一个单一的已排序序列。由于 $k$ 在每一趟中都加倍，总共将有 $\\lceil \\log_2 n \\rceil$ 趟，从而得出总时间复杂度为 $O(n \\log n)$。\n\n**3. 整体算法结构**\n\n完整的算法包括三个主要阶段：\n\n**阶段 1：预处理（线性化）**\n输入是一个循环单链表。这种结构对于拆分和合并逻辑来说不方便，因为它没有明确的起点和终点。第一步是将其转换为标准的线性链表。\n- 我们从一个任意的 `head` 节点开始遍历列表，找到最后一个节点（其 `next` 指针指向 `head` 的节点）。\n- 在此遍历期间，我们计算节点数 $n$。\n- 然后我们将最后一个节点的 `next` 指针设置为 `None`，从而有效地打破环，创建一个长度为 $n$ 的线性列表。此阶段耗时 $O(n)$。\n\n**阶段 2：迭代式归并**\n这是排序算法的核心。它包含一个循环，该循环以递增的子列表大小 $k$ 来迭代归并各趟。\n- 外层循环在 $k  n$ 的条件下运行，其中 $k = 1, 2, 4, \\dots$。\n- 在此循环内部，执行一次“归并趟”。一趟会遍历当前列表，重复地取出两个大小为 $k$ 的相邻子列表，将它们合并成一个大小为 $2k$ 的已排序子列表，并将这个合并后的子列表链接到一个新的、部分排序的列表中。\n- 为了用 $O(1)$ 的额外空间管理指针，我们维护一个指向列表未处理部分的头指针和一个指向正在构建的新列表的尾指针。\n- 在一趟中的每次归并操作：\n    1.  分离出第一个大小最多为 $k$ 的子列表。\n    2.  分离出第二个大小最多为 $k$ 的子列表。\n    3.  对这两个子列表调用一个 `merge` 函数。\n    4.  将得到的排序列表附加到正在构建的新列表的尾部。\n    5.  更新尾指针和指向未处理部分的指针。\n- 每完成一整趟后，新构建列表的头节点将成为下一趟中要处理的列表，并将 $k$ 的值加倍。\n\n**`merge(list1, list2)` 函数：**\n这个辅助函数是基于比较的排序的核心。它接收两个已排序链表的头节点 `list1` 和 `list2` 作为输入。它通过迭代比较 `list1` 和 `list2` 中当前节点的键值，并将键值较小的节点附加到合并列表中，从而创建一个包含两个输入列表中所有节点的新排序列表。使用一个临时的虚拟头节点来简化构建合并列表的逻辑。该函数返回新创建的单一排序列表的头节点。此操作所需时间与两个列表的长度之和成正比。\n\n**阶段 3：后处理（重新循环化）**\n在最后一趟归并（当 $k \\ge n$ 时）之后，结果是一个单一的、已排序的线性链表。该列表的头节点是整个数据集中包含最小键值的节点。\n- 为了恢复循环结构，我们遍历这个已排序的线性列表以找到其最后一个节点。\n- 然后我们将这个最后节点的 `next` 指针设置为指向列表的头节点。\n- 这个新的循环列表的头节点就是最终结果。此阶段耗时 $O(n)$。\n\n**复杂度分析**\n- **时间复杂度**：算法有一个外层循环，运行 $\\log n$ 次（因为 $k$ 翻倍）。内层的 `merge_pass` 在每一趟中都恰好处理 $n$ 个节点中的每一个。因此，总时间复杂度为 $O(n \\log n)$。\n- **空间复杂度**：算法使用常数个指针进行遍历和链接（例如 `head`、`current`、`tail`），与列表大小 $n$ 无关。像 `merge` 这样的辅助函数可能会使用一个临时的虚拟节点。这构成了常数量的额外空间，所以空间复杂度是 $O(1)$。\n\n这种基于第一性原理的推导产生了一个满足所有问题约束的算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"A node in a singly linked list.\"\"\"\n    def __init__(self, key, next_node=None):\n        self.key = key\n        self.next = next_node\n\n    def __repr__(self):\n        return f\"Node({self.key})\"\n\ndef build_circular_linked_list(keys):\n    \"\"\"Builds a circular singly linked list from a list of keys.\"\"\"\n    if not keys:\n        return None, 0\n    n = len(keys)\n    head = Node(keys[0])\n    current = head\n    for key in keys[1:]:\n        current.next = Node(key)\n        current = current.next\n    current.next = head  # Make it circular\n    return head, n\n\ndef to_list(head, n):\n    \"\"\"Converts n nodes of a circular linked list to a Python list.\"\"\"\n    if not head:\n        return []\n    result = []\n    current = head\n    for _ in range(n):\n        if current is None: # Should not happen for a circular list of size n > 0\n            break\n        result.append(current.key)\n        current = current.next\n    return result\n\ndef merge(list1, list2):\n    \"\"\"Merges two sorted linked lists into one.\"\"\"\n    dummy = Node(0)\n    tail = dummy\n    while list1 and list2:\n        if list1.key = list2.key:\n            tail.next = list1\n            list1 = list1.next\n        else:\n            tail.next = list2\n            list2 = list2.next\n        tail = tail.next\n    tail.next = list1 if list1 else list2\n    return dummy.next\n\ndef sort_circular_list(head, n):\n    \"\"\"\n    Sorts a circular singly linked list in-place using iterative merge sort.\n    Time complexity: O(n log n)\n    Space complexity: O(1)\n    \"\"\"\n    # 1. Handle edge cases where the list is already sorted.\n    if n = 1:\n        return head\n\n    # 2. Convert circular list to a linear list.\n    # The last node is found by traversing n-1 steps.\n    current = head\n    for _ in range(n - 1):\n        current = current.next\n    current.next = None  # Break the circle. `head` is the start of the linear list.\n\n    list_head = head\n    k = 1\n    while k  n:\n        # Each pass merges sublists of size k.\n        dummy_head = Node(0)\n        current_tail = dummy_head\n        current_head = list_head\n\n        while current_head:\n            # a. Split off list1 of size k\n            list1 = current_head\n            temp = list1\n            for _ in range(k - 1):\n                if not temp: break\n                temp = temp.next\n            \n            if not temp:  # list1 is shorter than k\n                current_head = None\n            else:\n                current_head = temp.next\n                temp.next = None  # Cut list1\n\n            # b. Split off list2 of size k, if it exists\n            list2 = current_head\n            if not list2:\n                current_tail.next = list1\n                break  # This pass is done\n\n            temp = list2\n            for _ in range(k - 1):\n                if not temp: break\n                temp = temp.next\n\n            if not temp:  # list2 is shorter than k\n                current_head = None\n            else:\n                current_head = temp.next\n                temp.next = None  # Cut list2\n\n            # c. Merge list1 and list2 and append to the result\n            merged = merge(list1, list2)\n            current_tail.next = merged\n            \n            # d. Find the new tail to continue appending\n            while current_tail.next:\n                current_tail = current_tail.next\n\n        list_head = dummy_head.next\n        k *= 2\n\n    # 3. Re-circularize the sorted list\n    new_head = list_head\n    if new_head:\n        last_node = new_head\n        while last_node.next:\n            last_node = last_node.next\n        last_node.next = new_head\n        \n    return new_head\n\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs the sorting algorithm, and prints the results.\n    \"\"\"\n    test_cases = [\n        [],\n        [7],\n        [1, 2, 3, 4, 5],\n        [5, 4, 3, 2, 1],\n        [3, 1, 2, 3, 2, 1],\n        [4, 5, 1, 2, 3],\n        [-2, -1, -3, 0, 2],\n        [2, 2, 2, 2],\n    ]\n\n    results = []\n    for case_keys in test_cases:\n        head, n = build_circular_linked_list(case_keys)\n        sorted_head = sort_circular_list(head, n)\n        sorted_list = to_list(sorted_head, n)\n        results.append(str(sorted_list))\n\n    # Final print statement in the exact required format.\n    # The str() on a list gives a string like '[1, 2, 3]'.\n    # Joining these with commas gives '[1, 2, 3],[4, 5, 6]'.\n    # We then wrap the whole thing in one more pair of brackets.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3220604"}]}