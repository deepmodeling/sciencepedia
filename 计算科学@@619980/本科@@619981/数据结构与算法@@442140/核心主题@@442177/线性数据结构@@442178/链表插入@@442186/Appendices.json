{"hands_on_practices": [{"introduction": "这项练习将挑战一种标准链表的变体：循环双向链表。你的任务是在插入元素的同时保持列表的有序性。这个练习对于熟练掌握在具有更复杂不变量（循环性和双向链接）的结构中的指针逻辑至关重要，并且需要仔细处理诸如插入新最小值等边界情况，是对实现鲁棒数据结构的一项基础挑战。[@problem_id:3229897]", "problem": "你需要实现一个支持排序插入的循环双向链表 (DLL)，同时保持节点键值的非递减有序不变量。一个循环双向链表由节点组成，每个节点存储一个键、一个指向下一个节点的指针和一个指向前一个节点的指针。该链表是循环的：如果链表非空，则头节点的前向指针指向尾节点，尾节点的后向指针指向头节点。头指针必须始终指向链表中键值最小的节点。排序插入必须将新键值放置在从头节点开始正向遍历时能保持非递减顺序的位置。\n\n需要维护的定义和不变量：\n- 每个节点存储一个整数键，记为 $k \\in \\mathbb{Z}$。\n- 对于一个头节点为 $H$ 的非空链表，令 $H = v_0$。一次完整的正向遍历会恰好访问一次节点 $v_0, v_1, \\dots, v_{n-1}$ 并返回到 $v_0$。非递减有序不变量要求对于所有 $i \\in \\{0,1,\\dots,n-2\\}$，都有 $v_i.\\text{key} \\le v_{i+1}.\\text{key}$。循环性要求 $v_{n-1}.\\text{next} = v_0$ 且 $v_0.\\text{prev} = v_{n-1}$。\n- 头指针必须始终指向当前存储的键集合中键值最小的节点。如果链表为空，则头指针为 null。\n\n你的任务：\n- 实现一个循环双向链表，其中包含一个 `SortedInsert` 方法，该方法接受一个整数键 $x \\in \\mathbb{Z}$，并插入一个键为 $x$ 的新节点，以保持非递减有序不变量。该算法必须在所有情况下都正确，包括：\n  - 向空链表中插入。\n  - 作为新的最小值插入（成为新的头节点）。\n  - 作为新的最大值插入（在尾部）。\n  - 在两个现有键之间插入。\n  - 在存在重复键时插入（最终顺序必须保持非递减；在相等键之间的任何有效位置都是可接受的）。\n- 对于每个给定的测试用例，在一系列插入操作之后，从头节点开始执行一次正向遍历，以生成最终的键序列。该序列将是该测试用例的结果。\n\n设计和推理的基本依据：\n- 节点级指针不变量：对于正向遍历中的任意两个相邻节点（例如节点 $u$ 和 $v$），双向链表结构必须满足 $u.\\text{next} = v$ 和 $v.\\text{prev} = u$。\n- 循环性约束：对于一个头节点为 $H$、尾节点为 $T$ 的非空链表，必须满足 $T.\\text{next} = H$ 和 $H.\\text{prev} = T$。\n- 顺序关系：非递减顺序意味着对于正向遍历 $v_0, v_1, \\dots, v_{n-1}$，要求对于所有适用的 $i$，都有 $v_i.\\text{key} \\le v_{i+1}.\\text{key}$。\n- 遍历的终止条件：当移动指针再次访问头节点 $H$ 时，表示已完成一轮完整的遍历。\n\n输入规范：\n- 没有外部输入。你的程序必须在内部构建并处理以下测试套件。每个测试用例是一个整数键序列，需要按照给定顺序插入到一个初始为空的循环双向链表中：\n  1. 插入单个元素 $[5]$。\n  2. 插入升序序列 $[1, 2, 3, 4]$。\n  3. 插入降序序列 $[4, 3, 2, 1]$。\n  4. 插入带有重复项的混合序列 $[3, 1, 2, 2, 5, 4, 0, 3]$。\n  5. 插入负数和非负数键 $[-1, -3, 2, -2, 0, 2]$。\n  6. 插入所有相等的键 $[2, 2, 2, 2]$。\n\n输出规范：\n- 对于每个测试用例，在其所有插入操作完成后，从头节点开始生成正向遍历序列，作为一个整数列表。\n- 你的程序应该生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的列表。这个顶层列表的每个元素对应一个测试用例的结果，其本身也是一个整数列表。输出中任何地方都不能有空格。例如，如果有两个测试用例，其正向序列分别为 $[1, 2]$ 和 $[3]$，则输出格式必须是 `[[1,2],[3]]`。\n\n计算要求：\n- `SortedInsert` 操作对于大小为 $n$ 的链表，在最坏情况下的运行时间必须为 $O(n)$，并且必须在所有情况下保持双向链表指针不变量和循环性。\n\n角度单位、物理单位和百分比格式在此不适用。\n\n每个测试用例的最终答案类型是一个整数列表。因此，程序的单行输出是一个整数列表的列表，其格式必须与上述规定完全一致。", "solution": "问题陈述已经过验证，被认为是可靠的。这是一个在数据结构和算法领域内定义明确、自成体系且可形式化的问题。不存在科学或事实上的不健全、矛盾或模糊之处。所有的不变量和要求都已明确规定。\n\n任务是为循环双向链表 (DLL) 设计并实现一个 `SortedInsert` 方法，以维护键的非递减顺序。实现必须遵守几个不变量：链表的循环性质、双向链接指针的完整性，以及 `head` 指针始终引用具有最小键值的节点的约束。\n\n首先，我们定义基本数据结构——节点。每个节点（记为 $v$）是一个包含三个字段的对象：一个整数键 $v.\\text{key} \\in \\mathbb{Z}$，一个指向下一个节点的指针 $v.\\text{next}$，以及一个指向前一个节点的指针 $v.\\text{prev}$。\n\n循环双向链表本身由一个类管理，该类维护一个单一指针 `head`。如果链表为空，`head` 为 null。否则，`head` 指向节点 $v_0$，其中 $v_0.\\text{key}$ 是链表中所有键的最小值。对于头节点为 $H$、尾节点为 $T$ 的非空链表，循环不变量要求 $T.\\text{next} = H$ 和 $H.\\text{prev} = T$。\n\n问题的核心是 `SortedInsert(x)` 方法的实现，该方法将一个键为 $x \\in \\mathbb{Z}$ 的新节点插入链表，同时保持所有不变量。其逻辑可以系统地分解为不同的情况。设 $N$ 是要创建的新节点，使得 $N.\\text{key} = x$。\n\n情况 1：向空链表中插入。\n如果链表的 `head` 指针为 null，则链表为空。新节点 $N$ 成为唯一的元素。为保持循环性，其 `next` 和 `prev` 指针必须指向自身。\n$$N.\\text{next} \\leftarrow N$$\n$$N.\\text{prev} \\leftarrow N$$\n然后，链表的 `head` 指针被更新为指向 $N$。\n$$\\text{head} \\leftarrow N$$\n\n情况 2：向非空链表中插入。\n设 $H$ 为链表的当前头节点。根据新键 $x$ 相对于现有最小值 $H.\\text{key}$ 的值，会出现两种子情况。\n\n子情况 2a：新键是新的最小值。\n当 $x \\le H.\\text{key}$ 时发生此情况。根据头节点不变量，新节点 $N$ 必须成为链表的新头节点。$N$ 必须插入在 $H$ 的正前方。链表的尾节点 $T$ 可以通过 $T = H.\\text{prev}$ 找到。必须更新指针以建立链接 $T \\leftrightarrow N \\leftrightarrow H$。\n所需的指针赋值操作如下：\n$1$. $N.\\text{next} \\leftarrow H$\n$2$. $N.\\text{prev} \\leftarrow T$\n$3$. $H.\\text{prev} \\leftarrow N$\n$4$. $T.\\text{next} \\leftarrow N$\n最后，链表的 `head` 指针必须更新为 $N$：\n$$\\text{head} \\leftarrow N$$\n\n子情况 2b：新键不是新的最小值。\n当 $x  H.\\text{key}$ 时发生此情况。新节点 $N$ 必须插入在头节点之后的某个位置。我们必须遍历链表以找到正确的位置。目标是找到两个相邻的节点 $u$ 和 $v = u.\\text{next}$，使得 $u.\\text{key} \\le x$ 并且在它们之间插入 $N$ 能保持非递减顺序。我们可以通过搜索最后一个键值小于 $x$ 的节点 $u$ 来实现这一点。\n我们初始化一个遍历指针 `current` 指向 `head`。然后，只要下一个节点的键值小于 $x$，我们就向前移动 `current`。关键是，遍历还必须处理循环链表的环绕情况。循环条件是 `current.next != head` 且 `current.next.key  x`。\n当 `current` 是应紧接在 $N$ 之前的节点时，循环终止。设这个前驱节点为 $P = \\text{current}$，其后继节点为 $S = P.\\text{next}$。节点 $N$ 将被插入到 $P$ 和 $S$ 之间。指针更新如下：\n$1$. $N.\\text{next} \\leftarrow S$\n$2$. $N.\\text{prev} \\leftarrow P$\n$3$. $P.\\text{next} \\leftarrow N$\n$4$. $S.\\text{prev} \\leftarrow N$\n这一个逻辑块能正确处理在链表中间插入以及在末尾插入（即当 $x$ 大于或等于所有现有键时）的情况。在后一种情况下，遍历循环将完成一整圈，`current` 将成为尾节点 $T$，而 `current.next` 将是头节点 $H$。新节点将被正确地插入到 $T$ 和 $H$ 之间，成为新的尾节点。\n\n为了生成所需的输出，需要一个正向遍历方法。该方法从 `head` 节点开始。如果链表非空，它会使用 `next` 指针遍历链表，按顺序收集键值，直到遍历指针返回到 `head`。`do-while` 循环是实现此功能的自然结构，因为循环体至少需要为头节点执行一次。\n\n`SortedInsert` 操作的计算复杂度由遍历步骤决定。在最坏情况（插入一个成为新最大值的键）下，算法必须遍历整个大小为 $n$ 的链表。因此，时间复杂度为 $O(n)$。空间复杂度为 $O(1)$，因为它只需要固定数量的指针和一个新节点。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    Represents a node in a doubly linked list.\n    Each node stores an integer key and pointers to the next and previous nodes.\n    \"\"\"\n    def __init__(self, key: int):\n        self.key = key\n        self.next = None\n        self.prev = None\n\nclass CircularDLL:\n    \"\"\"\n    Implements a circular doubly linked list that maintains keys in nondecreasing order.\n    The head pointer always points to the node with the minimum key.\n    \"\"\"\n    def __init__(self):\n        self.head = None\n\n    def sorted_insert(self, key: int):\n        \"\"\"\n        Inserts a new node with the given key into the list while maintaining\n        the sorted, circular, and doubly linked properties.\n        \"\"\"\n        new_node = Node(key)\n\n        # Case 1: The list is empty.\n        if self.head is None:\n            new_node.next = new_node\n            new_node.prev = new_node\n            self.head = new_node\n            return\n\n        # Case 2: The new key is less than or equal to the head's key.\n        # The new node becomes the new head.\n        if key = self.head.key:\n            tail = self.head.prev\n            \n            new_node.next = self.head\n            new_node.prev = tail\n            \n            tail.next = new_node\n            self.head.prev = new_node\n            \n            self.head = new_node\n            return\n\n        # Case 3: The new key must be inserted in the middle or at the end.\n        # Traverse to find the correct insertion point.\n        current = self.head\n        # Find the node after which the new node should be inserted.\n        while current.next != self.head and current.next.key  key:\n            current = current.next\n        \n        # 'current' is now the predecessor. 'next_node' is the successor.\n        next_node = current.next\n        \n        new_node.next = next_node\n        new_node.prev = current\n        \n        current.next = new_node\n        next_node.prev = new_node\n\n    def get_list_as_array(self) -> list[int]:\n        \"\"\"\n        Performs a forward traversal from the head and returns the keys as a list.\n        \"\"\"\n        if self.head is None:\n            return []\n        \n        result = []\n        current = self.head\n        # Emulate a do-while loop to traverse the circular list\n        while True:\n            result.append(current.key)\n            current = current.next\n            if current == self.head:\n                break\n        return result\n\ndef solve():\n    \"\"\"\n    Runs the test suite as specified in the problem statement and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [5],\n        [1, 2, 3, 4],\n        [4, 3, 2, 1],\n        [3, 1, 2, 2, 5, 4, 0, 3],\n        [-1, -3, 2, -2, 0, 2],\n        [2, 2, 2, 2],\n    ]\n\n    results = []\n    for insertions in test_cases:\n        dll = CircularDLL()\n        for key in insertions:\n            dll.sorted_insert(key)\n        results.append(dll.get_list_as_array())\n\n    # Format the final output string to be exactly \"[[...],[...]]\" with no spaces.\n    # The default str() for lists includes spaces, which violates the output requirement.\n    # We construct the string manually for precise formatting.\n    list_of_list_strs = []\n    for res_list in results:\n        list_str = f\"[{','.join(map(str, res_list))}]\"\n        list_of_list_strs.append(list_str)\n    \n    final_output_str = f\"[{','.join(list_of_list_strs)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n```", "id": "3229897"}, {"introduction": "除了标准插入操作，现实世界的应用常常需要专门的复合操作。这项练习要求你根据一个正式的定义，实现一个自定义的“交换-插入”操作。它旨在磨练你将精确规范转化为一系列正确的指针操作的能力，并确保链表在每一步都保持其完整性。[@problem_id:3246042]", "problem": "您需要形式化并实现一个双向链表上的特殊插入操作，该操作基于双向链表的核心定义及其不变式。双向链表是节点 $\\{N_0, N_1, \\dots, N_{n-1}\\}$ 的有限序列，其中每个节点存储一个值和两个引用：$prev$ 和 $next$。根据定义，对于每个有效的索引 $i$（$0 \\le i  n$），必须满足以下不变式：如果 $N_i.next$ 不为 null，则 $(N_i.next).prev = N_i$；如果 $N_i.prev$ 不为 null，则 $(N_i.prev).next = N_i$。头节点 $H$ 是唯一满足 $H.prev = \\text{null}$ 的节点，尾节点 $T$ 是唯一满足 $T.next = \\text{null}$ 的节点。标准的头部插入、尾部插入和中间插入操作通过重新连接常数数量的引用来定义，同时保持这些不变式。\n\n定义在双向链表上的以下操作，称为“交换插入”（swap-insert）。给定：\n- 一个初始双向链表 $L$，\n- $L$ 中一个由其基于 $0$ 的索引位置标识的指定节点 $A$，\n- 以及一个为新分配的节点 $B$ 准备的新值 $b$，\n\n执行操作 swap-insert$(L, A, b)$，它由以下一系列原子列表编辑组成，每一步都重新连接常数数量的引用并始终保持不变式：\n\n1. 通过连接其相邻节点，将 $A$ 从其当前位置移除。形式上，令 $P = A.prev$ 且 $Q = A.next$。设置：\n   - 如果 $P \\ne \\text{null}$，则 $P.next \\leftarrow Q$；否则，将头节点设置为 $Q$，\n   - 如果 $Q \\ne \\text{null}$，则 $Q.prev \\leftarrow P$。\n   此步骤后，$A$ 不在 $L$ 中。\n2. 创建一个值为 $b$ 的新节点 $B$，并将其插入到 $A$ 所在位置的空隙中。即，设置：\n   - $B.prev \\leftarrow P$ 和 $B.next \\leftarrow Q$，\n   - 如果 $P \\ne \\text{null}$，则 $P.next \\leftarrow B$；否则，将头节点设置为 $B$，\n   - 如果 $Q \\ne \\text{null}$，则 $Q.prev \\leftarrow B$。\n   此步骤后，$B$ 占据了先前由 $A$ 占据的精确相对位置。\n3. 在头部插入 $A$。设当前头节点为 $H$（可能 $H = \\text{null}$）。设置：\n   - $A.prev \\leftarrow \\text{null}$，$A.next \\leftarrow H$，\n   - 如果 $H \\ne \\text{null}$，则 $H.prev \\leftarrow A$，\n   - 将头节点设置为 $A$。\n\n即使对于边界情况，如 $A$ 是头节点（此时 $P = \\text{null}$）、$A$ 是尾节点（此时 $Q = \\text{null}$）以及列表仅包含单个节点时，此定义也能产生明确定义的结果。您的任务是仅使用双向链表的定义和不变式，以及标准的头部、尾部和中间插入作为指针赋值的组合，从基本原理出发实现此操作。\n\n不使用输入格式；相反，您必须在程序中嵌入以下测试套件。每个测试用例是一个三元组 $(L, i, b)$，其中 $L$ 是初始整数列表，$i$ 是节点 $A$ 在 $L$ 中的基于 $0$ 的索引，$b$ 是新节点 $B$ 的整数值：\n- 测试用例 1：$L = [10,20,30,40,50]$，$i = 2$，$b = 99$。\n- 测试用例 2：$L = [1,2,3]$，$i = 0$，$b = 7$。\n- 测试用例 3：$L = [4,5,6]$，$i = 2$，$b = 8$。\n- 测试用例 4：$L = [42]$，$i = 0$，$b = 100$。\n- 测试用例 5：$L = [5,5,5,5]$，$i = 1$，$b = -1$。\n\n对于每个测试用例，计算在执行 swap-insert$(L, A, b)$ 后的结果列表值，其中 $A$ 是初始列表 $L$ 中索引为 $i$ 的节点，$B$ 是值为 $b$ 的新节点。要求的最终输出是一行，包含一个结果列表，其中每个结果是代表该测试用例最终列表的整数列表，整个集合以逗号分隔并用方括号括起来。具体来说，输出格式必须是形如 $[$result\\_case\\_1$, $result\\_case\\_2$, \\dots$]$ 的单行，其中每个 result\\_case\\_k 本身是对应于测试用例 $k$ 的、用方括号括起来的逗号分隔的整数列表。", "solution": "该问题是形式上明确且自包含的，提供了一个双向链表、其不变式以及一个名为 `swap-insert` 的新操作的严谨定义。因此，该问题是有效的。我们将着手解决。\n\n双向链表是节点的集合，其中每个节点包含一个值和两个指针 `prev` 和 `next`，建立一个双向序列。设列表由大小为 $n$ 的节点序列 $\\{N_0, N_1, \\dots, N_{n-1}\\}$ 表示。定义结构完整性的基本不变式是：\n1.  对于任何节点 $N_i$（其中 $0 \\le i  n-1$），其 `next` 指针指向 $N_{i+1}$，反之，$(N_{i+1})$.`prev` 指向 $N_i$。即 $(N_i.next).prev = N_i$。\n2.  对于任何节点 $N_i$（其中 $0  i \\le n-1$），其 `prev` 指针指向 $N_{i-1}$，反之，$(N_{i-1})$.`next` 指向 $N_i$。即 $(N_i.prev).next = N_i$。\n3.  列表的头节点 $H = N_0$ 是其 `prev` 指针为 null ($H.prev = \\text{null}$) 的唯一节点。\n4.  列表的尾节点 $T = N_{n-1}$ 是其 `next` 指针为 null ($T.next = \\text{null}$) 的唯一节点。\n\n问题定义了一个复合操作 `swap-insert(L, A, b)`，该操作作用于一个列表 $L$，给定一个节点 $A$（由其基于 0 的索引标识）和一个新节点 $B$ 的值 $b$。该操作包括三个不同的顺序步骤。我们将为每一步形式化指针操作，确保不变式得以维持。\n\n让我们将索引为 $i$ 的节点表示为 $A$。我们将分析一般情况及其边界条件下的过程。\n\n**步骤 1：从列表中移除节点 $A$。**\n目标是将 $A$ 从其相邻节点中断开，从而在列表中有效地创建一个“空隙”。设 $P = A.prev$ 且 $Q = A.next$。\n-   我们必须连接 $P$ 和 $Q$。$P$ 的 `next` 指针必须更新为指向 $Q$，$Q$ 的 `prev` 指针必须更新为指向 $P$。\n-   **指针更新：**\n    -   `P.next` $\\leftarrow$ $Q$\n    -   `Q.prev` $\\leftarrow$ $P$\n-   这维持了链的连续性。此后，$(P.next).prev = Q.prev = P$，保持了 $P$ 的不变式。类似地，$(Q.prev).next = P.next = Q$，保持了 $Q$ 的不变式。\n-   **边界条件：**\n    -   如果 $A$ 是头节点 ($i=0$)，则 $P = \\text{null}$。第一次更新（`P.next` $\\leftarrow$ $Q$）不执行。列表的头节点必须更新为 $Q$。更新后，$Q.prev$ 将被设置为 $P$（即 `null`），正确地使 $Q$ 成为新的头节点。\n    -   如果 $A$ 是尾节点 ($i=n-1$)，则 $Q = \\text{null}$。第二次更新（`Q.prev` $\\leftarrow$ $P$）不执行。列表的尾节点必须更新为 $P$。更新后，$P.next$ 将被设置为 $Q$（即 `null`），正确地使 $P$ 成为新的尾节点。\n    -   如果列表只有一个节点 ($n=1$)，则 $A$ 既是头节点也是尾节点，所以 $P = \\text{null}$ 且 $Q = \\text{null}$。列表变为空；列表结构的头指针和尾指针都变为 `null`。\n在此步骤结束时，节点 $A$ 被隔离，但保留其原始的 `prev` 和 `next` 指针。列表 $L$ 的长度减少了一个节点，但仍然是一个有效的、连续的双向链表。\n\n**步骤 2：将新节点 $B$ 插入空隙中。**\n创建一个值为 $b$ 的新节点 $B$。它必须被插入到先前由 $A$ 占据的位置，即节点 $P$ 和 $Q$ 之间。\n-   **指针更新：**\n    -   $B.prev$ $\\leftarrow$ $P$\n    -   $B.next$ $\\leftarrow$ $Q$\n    -   $P.next$ $\\leftarrow$ $B$\n    -   $Q.prev$ $\\leftarrow$ $B$\n-   不变式得以恢复。例如，$(P.next).prev = B.prev = P$ 且 $(B.next).prev = Q.prev = B$。\n-   **边界条件：** 这些处理方式与步骤 1 相同。\n    -   如果 $P = \\text{null}$（空隙在头部），我们将列表的头节点设置为 $B$。\n    -   如果 $Q = \\text{null}$（空隙在尾部），我们将列表的尾节点设置为 $B$。\n    -   如果列表为空，则 $P$ 和 $Q$ 都为 `null`。$B$ 成为新的大小为 1 的列表的头节点和尾节点。\n此步骤后，列表的长度恢复为 $n$，节点 $B$ 位于原始节点 $A$ 的位置。\n\n**步骤 3：在列表头部插入节点 $A$。**\n现在将孤立的节点 $A$ 添加到列表的开头。设列表当前的头节点为 $H$。\n-   **指针更新：**\n    -   $A.prev$ $\\leftarrow$ $\\text{null}$ (这是使 $A$ 成为有效头节点的必要步骤)。\n    -   $A.next$ $\\leftarrow$ $H$\n    -   $H.prev$ $\\leftarrow$ $A$\n-   列表的头指针必须更新为指向 $A$。\n-   **边界条件：**\n    -   如果在此步骤之前列表为空（$H = \\text{null}$），这种情况发生在原始列表只有一个节点时，那么 $A$ 将被插入到一个空列表中。$A.next$ 被设置为 `null`，$A$ 成为头节点和尾节点。`H.prev` 的更新被跳过。\n\n在此最后一步之后，列表包含 $n+1$ 个节点。节点 $A$ 是新的头节点，新节点 $B$ 位于 $A$ 的原始索引处，列表的总长度增加了一。\n\n让我们追踪测试用例 1：$L = [10,20,30,40,50]$，$i = 2$，$b = 99$。\n1.  初始列表：$10 \\leftrightarrow 20 \\leftrightarrow 30 \\leftrightarrow 40 \\leftrightarrow 50$。节点 $A$ 的值为 30。$P$ 是节点 20，$Q$ 是节点 40。\n2.  步骤 1（移除 $A$）：节点 20 的 `next` 指向节点 40。节点 40 的 `prev` 指向节点 20。列表现在是 $10 \\leftrightarrow 20 \\leftrightarrow 40 \\leftrightarrow 50$。\n3.  步骤 2（插入 $B$）：创建一个值为 99 的新节点 $B$。其 `prev` 设置为节点 20，`next` 设置为节点 40。节点 20 的 `next` 设置为 $B$，节点 40 的 `prev` 设置为 $B$。列表现在是 $10 \\leftrightarrow 20 \\leftrightarrow 99 \\leftrightarrow 40 \\leftrightarrow 50$。头节点仍是节点 10。\n4.  步骤 3（在头部插入 $A$）：当前头节点 $H$ 是节点 10。节点 $A$（值为 30）的 `prev` 设置为 `null`，`next` 设置为 $H$。节点 $H$ 的 `prev` 设置为 $A$。列表的头指针更新为 $A$。最终列表是 $30 \\leftrightarrow 10 \\leftrightarrow 20 \\leftrightarrow 99 \\leftrightarrow 40 \\leftrightarrow 50$。\n结果值：$[30, 10, 20, 99, 40, 50]$。\n\n这种系统性的指针操作应用，以及对边界处 `null` 指针的谨慎处理，正确地实现了指定的 `swap-insert` 操作，同时在每个阶段都保持了双向链表的基本不变式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np # numpy is required by the environment but not used in this solution.\n\nclass Node:\n    \"\"\"A node in a doubly linked list.\"\"\"\n    def __init__(self, value, prev=None, next_node=None):\n        self.value = value\n        self.prev = prev\n        self.next = next_node\n\n    def __repr__(self):\n        return f\"Node({self.value})\"\n\nclass DoublyLinkedList:\n    \"\"\"A doubly linked list implementation.\"\"\"\n    def __init__(self):\n        self.head = None\n        self.tail = None\n        self.size = 0\n\n    def from_list(self, values):\n        \"\"\"Creates a doubly linked list from a Python list.\"\"\"\n        if not values:\n            return\n        \n        # Create head\n        self.head = Node(values[0])\n        self.tail = self.head\n        self.size = 1\n        \n        # Add subsequent nodes\n        current = self.head\n        for value in values[1:]:\n            new_node = Node(value, prev=current)\n            current.next = new_node\n            current = new_node\n            self.tail = current\n            self.size += 1\n\n    def to_list(self):\n        \"\"\"Converts the doubly linked list to a Python list.\"\"\"\n        values = []\n        current = self.head\n        while current:\n            values.append(current.value)\n            current = current.next\n        return values\n\n    def get_node_at(self, index):\n        \"\"\"Returns the node at a specific index.\"\"\"\n        if not (0 = index  self.size):\n            return None\n        \n        # Optimization: traverse from head or tail depending on index\n        if index  self.size / 2:\n            current = self.head\n            for _ in range(index):\n                current = current.next\n        else:\n            current = self.tail\n            for _ in range(self.size - 1 - index):\n                current = current.prev\n        return current\n\n    def swap_insert(self, A_index, b_value):\n        \"\"\"\n        Performs the swap-insert operation as defined in the problem.\n        \"\"\"\n        # Step 0: Find node A\n        A = self.get_node_at(A_index)\n        if A is None:\n            # This case implies an invalid index, but our logic proceeds as if the\n            # list structure allows it (e.g., if problem were to test invalid indices).\n            return\n\n        # Step 1: Remove A from its current place\n        P = A.prev\n        Q = A.next\n        \n        if P:\n            P.next = Q\n        else: # A was the head\n            self.head = Q\n        \n        if Q:\n            Q.prev = P\n        else: # A was the tail\n            self.tail = P\n        \n        self.size -= 1\n        # Node A is now isolated.\n\n        # Step 2: Create a new node B and insert it into the gap\n        B = Node(b_value)\n        \n        B.prev = P\n        B.next = Q\n        \n        if P:\n            P.next = B\n        else: # The gap was at the head\n            self.head = B\n            \n        if Q:\n            Q.prev = B\n        else: # The gap was at the tail\n            self.tail = B\n        \n        if self.size == 0: # If the list became empty after removing A\n            self.head = B\n            self.tail = B\n\n        self.size += 1\n        \n        # Step 3: Insert A at the head\n        H = self.head\n\n        A.prev = None\n        A.next = H\n        \n        if H:\n            H.prev = A\n        else: # The list was empty (single node case, list is now B)\n            # This 'else' will not be hit if H is correctly assigned as self.head\n            # because in the single node case, H would be B.\n            # But if H were null, A would be the only node.\n            self.tail = A\n\n        self.head = A\n        self.size += 1\n        \n        # Ensure tail is correct if list was empty before H assignment\n        if self.size == 1:\n            self.tail = self.head\n\ndef solve():\n    \"\"\"\n    Executes the test suite and prints the formatted output.\n    \"\"\"\n    test_cases = [\n        ([10, 20, 30, 40, 50], 2, 99),\n        ([1, 2, 3], 0, 7),\n        ([4, 5, 6], 2, 8),\n        ([42], 0, 100),\n        ([5, 5, 5, 5], 1, -1),\n    ]\n\n    results = []\n    for case in test_cases:\n        initial_list_values, index, new_value = case\n        \n        # Create and populate the doubly linked list\n        dll = DoublyLinkedList()\n        dll.from_list(initial_list_values)\n        \n        # Perform the swap-insert operation\n        dll.swap_insert(index, new_value)\n        \n        # Store the result\n        results.append(dll.to_list())\n\n    # Format the final output string to be exactly as required,\n    # specifically removing spaces after commas within the lists.\n    # str(results) -> '[[1, 2], [3, 4]]'\n    # .replace(' ', '') -> '[[1,2],[3,4]]'\n    final_output = str(results).replace(' ', '')\n    print(final_output)\n\nsolve()\n```", "id": "3246042"}, {"introduction": "这项高级练习引入了一个现实的约束：指针写入操作可能会失败。你将为一个双向链表设计一个插入函数，该函数在一个概率性故障模型下运行，并包含验证和重试机制。这个练习超越了理想化的条件，教你如何构建能够验证自身状态并从故障中恢复的弹性代码，这是工程可靠系统的关键技能。[@problem_id:3246078]", "problem": "你需要为一个在指针写入存在概率性故障模型下的双向链表设计并实现一个插入例程。该例程必须能处理在头部、尾部以及指定中间位置（紧跟在通过其值识别的节点之后）的插入操作。开始所需的核心定义和法则是双向链表的结构不变量以及独立指针写入失败的概率模型。\n\n定义与模型：\n- 双向链表由节点组成，每个节点有两个指针字段：一个前驱指针和一个后继指针。对于列表中任意两个相邻节点 $u$ 和 $v$，其不变量为 $u.\\text{next} = v$ 和 $v.\\text{prev} = u$。\n- 使用两个哨兵节点 $H$（头哨兵）和 $T$（尾哨兵），使得空链表满足 $H.\\text{next} = T$ 和 $T.\\text{prev} = H$。哨兵节点 $H$ 和 $T$ 永远不会被移除，用户元素存储于它们之间。\n- 对节点字段的每一次指针写入操作（即设置任意节点的 $\\text{prev}$ 或 $\\text{next}$）都以概率 $p \\in [0,1]$ 独立地失败，并以概率 $1-p$ 成功。失败时，该字段保留其旧值；成功时，它将取新值。假定指针读取是可靠的。对于给定的测试用例，概率参数 $p$ 是固定的。\n- 验证步骤是对局部不变量的只读检查，必须确保在邻居节点 $a$ 和 $b$ 之间插入节点 $y$ 时，满足四重约束：$a.\\text{next} = y$、 $y.\\text{prev} = a$、 $y.\\text{next} = b$、 $b.\\text{prev} = y$。\n\n任务：\n- 实现一个例程，该例程在头部、尾部或中间（紧跟在第一个值等于指定目标值的节点之后）插入一个具有给定整数值的新节点。该例程必须：\n  1. 仅执行插入所需的局部指针写入。\n  2. 包含一个高效的验证步骤，该步骤会回读相关指针并重试失败的写入，从而避免对已满足其目标值的字段进行不必要的重写。\n  3. 对局部邻域中的每个独立指针字段使用 $R$ 次尝试的重试预算。如果四个局部字段中的任何一个在 $R$ 次尝试内未能达到其目标值，则必须报告插入失败。\n- 每个测试用例的初始列表构建必须使用可信写入（即初始填充期间没有失败）来执行，而插入操作必须遵循上述故障模型。\n- 使用一个以 $s = 12345$ 为种子的随机数生成器（RNG）来产生可复现的结果。每次指针写入都会查询RNG，以根据 $p$ 确定失败或成功。\n\n使用的基本原理：\n- 如上定义的双向链表不变量、哨兵用法和邻接关系。\n- 指针写入结果的独立同分布特性，每次写入的失败概率为 $p$，成功概率为 $1-p$。\n- 局部验证足以恢复正确性，因为插入操作恰好影响 $4$ 个字段：$y.\\text{prev}$、 $y.\\text{next}$、 $a.\\text{next}$ 和 $b.\\text{prev}$。\n\n用于测试的程序输入模型：\n- 没有外部输入；相反，请硬编码以下测试套件。对于每个测试用例，会给出 $p$、$R$、一个初始值列表以及一个操作序列。每个测试用例的所有操作都必须按顺序应用于一个新的列表。\n- 如果一个测试用例中的所有插入都在重试预算内成功，则该测试用例的结果是从头到尾（不包括哨兵）的列表顺序表示的最终列表内容（一个整数列表）。如果有任何插入失败，则该测试用例的结果必须是单元素列表 $\\left[-1\\right]$。\n\n测试套件：\n- 案例 1：$p = 0$，$R = 3$，初始列表 $\\left[10,20\\right]$，操作：在头部插入值 $5$。\n- 案例 2：$p = 0.25$，$R = 10$，初始列表 $\\left[\\ \\right]$（空），操作：在尾部插入值 $7$。\n- 案例 3：$p = 0.5$，$R = 100$，初始列表 $\\left[1,2,3,4\\right]$，操作：在值为 $2$ 的节点后紧接着插入新值 $99$。\n- 案例 4：$p = 1$，$R = 5$，初始列表 $\\left[8,9\\right]$，操作：在尾部插入值 $77$。\n- 案例 5：$p = 0.1$，$R = 10$，初始列表 $\\left[2\\right]$，操作：在头部插入值 $1$，在尾部插入值 $3$，在值为 $1$ 的节点后紧接着插入新值 $5$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个元素是按上述规定表示的各案例结果。例如，格式必须为 $\\left[\\text{result}_1,\\text{result}_2,\\dots\\right]$，其中每个 $\\text{result}_i$ 本身是表示最终列表内容的整数列表，或在失败时为单元素列表 $\\left[-1\\right]$。", "solution": "该问题已经过验证，被确定为是定义明确、有科学依据且内部一致的。它在概率性故障模型下，为数据结构和算法领域提出了一个清晰、可形式化的挑战。因此，我们可以着手提供一个完整的解决方案。\n\n这个问题的核心在于为双向链表实现一个鲁棒的插入例程，该例程能够容忍指针写入操作中的失败并从中恢复。该解决方案建立在三个主要组成部分之上：数据结构定义、概率性写入与重试逻辑，以及用于处理测试用例的高层控制流。\n\n首先，我们定义必要的数据结构。一个 `Node` 类封装了数据（一个整数值）和两个指针 `prev` 和 `next`。`DoublyLinkedList` 类负责协调整体结构。根据问题规范，它利用两个哨兵节点，一个头哨兵 $H$ 和一个尾哨兵 $T$。在一个空列表中，不变量 $H.\\text{next} = T$ 和 $T.\\text{prev} = H$ 得以维持。这些哨兵通过确保任何插入（即使是向空列表插入）都发生在两个已存在节点之间，从而简化了插入逻辑。\n\n核心挑战在于 `_insert` 例程，它必须在指定的故障模型下，将一个新节点 $y$ 正确地放置在两个现有的相邻节点 $a$ 和 $b$ 之间。要在 $a$ 和 $b$ 之间成功插入 $y$，需要建立一个由四个指针关系组成的集合，这构成了局部的结构不变量：\n$1$. $a.\\text{next} = y$\n$2$. $y.\\text{prev} = a$\n$3$. $y.\\text{next} = b$\n$4$. $b.\\text{prev} = y$\n\n这 $4$ 个指针赋值中的每一个都是一次“写入操作”，都有可能失败。问题规定，每次写入尝试都以固定的概率 $p$ 失败，并以概率 $1-p$ 成功。为了模拟这一点，我们使用了一个以 $s=12345$ 为种子的随机数生成器（RNG），以保证结果的确定性可复现。对于每次写入尝试，都会从 $[0,1)$ 中抽取一个随机浮点数；如果该值小于 $p$，则写入失败，指针保留其先前的值。否则，写入成功。\n\n为了处理失败，我们实现了一个重试机制。该机制由一个重试预算 $R$ 控制，它规定了对 $4$ 个独立指针写入中的每一个所允许的最大尝试次数。插入逻辑会进行迭代，在每一轮中检查所有 $4$ 个指针字段的正确性。如果某个字段尚未指向其正确的目标，并且其尝试次数小于 $R$，则会尝试一次新的概率性写入，并增加该特定字段的尝试计数器。循环通过以下两种方式之一终止：\n- **成功**：所有 $4$ 个指针字段都验证为正确。局部结构是健全的，插入完成。\n- **失败**：任何单个指针字段的尝试次数达到了预算 $R$，而该字段仍然不正确。此时，整个插入操作被中止并报告为失败。根据问题要求，单次操作的这种硬性失败将导致整个测试用例失败。\n\n具体的插入操作——`insert_head`、`insert_tail` 和 `insert_after`——被实现为公共方法，它们包装了通用的 `_insert` 例程。它们负责为插入操作识别正确的前驱节点 ($a$) 和后继节点 ($b$)：\n- 对于 `insert_head`，$a$ 是头哨兵 $H$，$b$ 是其当前后继节点 $H.\\text{next}$。\n- 对于 `insert_tail`，$b$ 是尾哨兵 $T$，$a$ 是其当前前驱节点 $T.\\text{prev}$。\n- 对于 `insert_after`，$a$ 是通过搜索给定目标值找到的节点，$b$ 是其后继节点 $a.\\text{next}$。\n\n最后，主函数 `solve` 负责协调测试套件的执行。对于每个测试用例，它会用指定的 $p$ 和 $R$ 初始化一个新的 `DoublyLinkedList` 实例，使用可信写入（即 $p=0$）构建初始列表，然后使用概率模型顺序执行所需的插入操作。如果任何操作返回失败状态，该测试用例的循环将终止，结果被记录为单元素列表 $[-1]$。否则，列表的最终状态将转换为标准的 Python 列表并记录为结果。然后，将所有测试用例收集到的结果格式化为指定的单行字符串输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"Represents a node in a doubly linked list.\"\"\"\n    def __init__(self, value, prev=None, next_node=None):\n        self.value = value\n        self.prev = prev\n        self.next = next_node\n\n    def __repr__(self):\n        return f\"Node({self.value})\"\n\nclass DoublyLinkedList:\n    \"\"\"A doubly linked list with probabilistic pointer writes.\"\"\"\n\n    def __init__(self, p, R, rng):\n        \"\"\"\n        Initializes the list with probabilistic parameters.\n        p: Probability of a pointer write failure.\n        R: Retry budget for each pointer write.\n        rng: A seeded numpy random number generator.\n        \"\"\"\n        self.p = p\n        self.R = R\n        self.rng = rng\n        \n        # Initialize with sentinel nodes\n        self.head = Node(None)  # Head sentinel\n        self.tail = Node(None)  # Tail sentinel\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def build(self, values):\n        \"\"\"Constructs the initial list using trusted writes (no failures).\"\"\"\n        current = self.head\n        for value in values:\n            new_node = Node(value)\n            current.next = new_node\n            new_node.prev = current\n            self.tail.prev = new_node\n            new_node.next = self.tail\n            current = new_node\n    \n    def find(self, value):\n        \"\"\"Finds the first node with the given value.\"\"\"\n        current = self.head.next\n        while current != self.tail:\n            if current.value == value:\n                return current\n            current = current.next\n        return None\n\n    def _insert(self, a_node, b_node, new_node):\n        \"\"\"\n        Core insertion routine with probabilistic writes and retries.\n        Inserts new_node between a_node and b_node.\n        Returns True on success, False on failure.\n        \"\"\"\n        # The four pointer writes to be performed\n        targets = [\n            (a_node, 'next', new_node),\n            (new_node, 'prev', a_node),\n            (new_node, 'next', b_node),\n            (b_node, 'prev', new_node)\n        ]\n        \n        retries = [0] * 4\n\n        while True:\n            # Check if all pointers are correctly set\n            all_correct = True\n            correctness_flags = []\n            for node, field, target in targets:\n                is_correct = getattr(node, field) == target\n                correctness_flags.append(is_correct)\n                if not is_correct:\n                    all_correct = False\n            \n            if all_correct:\n                return True\n\n            # If not all are correct, attempt to fix the incorrect ones\n            for i in range(4):\n                if not correctness_flags[i]:\n                    if retries[i]  self.R:\n                        # Attempt a probabilistic write\n                        if self.rng.random() >= self.p:\n                            node, field, target = targets[i]\n                            setattr(node, field, target)\n                        # Increment retry counter regardless of outcome\n                        retries[i] += 1\n                    else:\n                        # Retry budget for this specific pointer is exhausted\n                        return False\n\n    def insert_head(self, value):\n        \"\"\"Inserts a new node at the head of the list.\"\"\"\n        new_node = Node(value)\n        a_node = self.head\n        b_node = self.head.next\n        return self._insert(a_node, b_node, new_node)\n\n    def insert_tail(self, value):\n        \"\"\"Inserts a new node at the tail of the list.\"\"\"\n        new_node = Node(value)\n        a_node = self.tail.prev\n        b_node = self.tail\n        return self._insert(a_node, b_node, new_node)\n\n    def insert_after(self, target_val, new_val):\n        \"\"\"Inserts a new node after the node with target_val.\"\"\"\n        a_node = self.find(target_val)\n        if a_node is None or a_node == self.tail:\n            return False # Target not found or is the tail sentinel\n        \n        b_node = a_node.next\n        new_node = Node(new_val)\n        return self._insert(a_node, b_node, new_node)\n\n    def to_list(self):\n        \"\"\"Returns the list content as a Python list of integers.\"\"\"\n        items = []\n        current = self.head.next\n        while current != self.tail:\n            items.append(current.value)\n            current = current.next\n        return items\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and produce the final output.\n    \"\"\"\n    # The RNG must be created once and passed to all simulations.\n    rng = np.random.default_rng(seed=12345)\n\n    test_cases = [\n        {\"p\": 0.0, \"R\": 3, \"initial\": [10, 20], \"ops\": [('head', 5)]},\n        {\"p\": 0.25, \"R\": 10, \"initial\": [], \"ops\": [('tail', 7)]},\n        {\"p\": 0.5, \"R\": 100, \"initial\": [1, 2, 3, 4], \"ops\": [('after', 2, 99)]},\n        {\"p\": 1.0, \"R\": 5, \"initial\": [8, 9], \"ops\": [('tail', 77)]},\n        {\"p\": 0.1, \"R\": 10, \"initial\": [2], \"ops\": [('head', 1), ('tail', 3), ('after', 1, 5)]}\n    ]\n\n    results = []\n    for case in test_cases:\n        dll = DoublyLinkedList(p=case['p'], R=case['R'], rng=rng)\n        dll.build(case['initial'])\n        \n        case_failed = False\n        for op_type, *op_args in case['ops']:\n            success = False\n            if op_type == 'head':\n                success = dll.insert_head(op_args[0])\n            elif op_type == 'tail':\n                success = dll.insert_tail(op_args[0])\n            elif op_type == 'after':\n                success = dll.insert_after(op_args[0], op_args[1])\n            \n            if not success:\n                case_failed = True\n                break\n        \n        if case_failed:\n            results.append([-1])\n        else:\n            results.append(dll.to_list())\n\n    # Format the final output string exactly as required, removing spaces from list representations.\n    formatted_results = [str(r).replace(' ', '') for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3246078"}]}