{"hands_on_practices": [{"introduction": "在高效使用一个工具前，我们必须理解其内部构造。这个练习将带你深入循环队列的核心：元素逻辑顺序与其在底层数组中物理存储位置之间的映射关系。通过实现一个“预窥”功能 [@problem_id:3221146]，你将直接练习并掌握这一关键的索引计算技巧，这是后续更复杂操作的基础。", "problem": "给定一个基于数组的循环队列的正式定义。一个容量为 $C$ 的循环队列由一个长度为 $C$ 的数组 $A$、一个用于标识下一个待出队元素位置的队头索引 $f$ 以及一个等于当前存储元素数量的大小 $s$ 来表示。队尾索引 $r$ 由不变式 $r \\equiv (f + s) \\bmod C$ 推导得出，且所有索引始终位于集合 $\\{0, 1, \\dots, C-1\\}$ 中。该队列支持入队 (enqueue) 和出队 (dequeue) 操作，并遵循以下不变式：$0 \\le s \\le C$；入队操作仅在 $s \\lt C$ 时定义；出队操作仅在 $s \\gt 0$ 时定义。概念上的队列顺序是指从逻辑队头开始，按照未来出队的顺序排列的元素序列，这与它们在数组 $A$ 中的具体排列方式无关。\n\n请设计并实现一个函数，该函数接收一个这样的循环队列，返回概念上出队顺序中的接下来 $k$ 个元素，且不從队列中移除任何元素。该函数必须在 $\\mathcal{O}(k)$ 时间内运行，除了输出列表外只使用常数级别的额外工作空间（即不包括存储返回元素所需的空间），并且不得改变队列的状态。如果 $k$ 超过可用元素的数量 $s$，函数必须返回长度为 $\\min(k, s)$ 的最长前缀；如果 $k = 0$ 或队列为空 ($s = 0$)，函数必须返回空列表。\n\n将你的解决方案实现为一个完整的、可运行的程序，该程序构建几个循环队列，并对每个队列使用指定的 $k$ 值调用该函数。使用以下测试套件，它涵盖了一般情况、环绕行为、边界条件和边缘情况：\n\n- 测试用例 1：容量 $C = 7$，执行元素 $10, 20, 30, 40$ 的入队操作；然后使用 $k = 3$ 调用该函数。\n- 测试用例 2：容量 $C = 5$，执行元素 $1, 2, 3, 4$ 的入队操作；执行三次出队操作；执行元素 $5, 6, 7$ 的入队操作；然后使用 $k = 4$ 调用该函数。\n- 测试用例 3：容量 $C = 6$，执行元素 $9, 8$ 的入队操作；然后使用 $k = 0$ 调用该函数。\n- 测试用例 4：容量 $C = 8$，执行元素 $100, 200, 300$ 的入队操作；然后使用 $k = 3$ 调用该函数。\n- 测试用例 5：容量 $C = 6$，执行元素 $5, 15$ 的入队操作；然后使用 $k = 5$ 调用该函数。\n- 测试用例 6：容量 $C = 4$，无入队操作；使用 $k = 2$ 调用该函数。\n- 测试用例 7：容量 $C = 4$，执行元素 $7, 8, 9, 10$ 的入队操作；然后使用 $k = 2$ 调用该函数。\n- 测试用例 8：容量 $C = 3$，执行元素 $1, 2, 3$ 的入队操作；执行两次出队操作；执行元素 $4, 5$ 的入队操作；然后使用 $k = 3$ 调用该函数。\n\n你的程序应该生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表中的每个条目本身都是对应测试用例返回的元素列表，例如 $[r_1, r_2, \\dots, r_8]$，其中每个 $r_i$ 都是一个列表。", "solution": "设计一个函数来预览循环队列中接下来的 $k$ 个元素而不改变其状态，是数据结构实现中一个定义明確且标准的任务。所提供的循环队列定义在形式上是严谨的，它使用一个基于容量为 $C$ 的数组 $A$、队头索引 $f$ 和大小 $s$ 的状态表示。\n\n解决这个问题的基本原理在于队列中元素的概念顺序与其在底层数组 $A$ 中物理位置之间的映射关系。概念顺序是元素将要被出队的顺序。第一个待出队的元素位于数组中的索引 $f$ 处。第二个元素位于下一个物理位置，由于队列的循环特性，该位置是 $(f+1) \\pmod C$。以此类推，概念上出队顺序中的第 $i$ 个元素（对于 $i=0, 1, 2, \\dots, s-1$）存储在物理数组索引中，该索引由以下表达式给出：\n$$\n\\text{physical\\_index}(i) = (f + i) \\pmod C\n$$\n这个关系对当前队列中的所有元素都成立，从队头（$i=0$）到逻辑队尾（$i=s-1$），并且能正确处理队列元素跨越数组末尾和起始位置边界的环绕行为。\n\n任务是设计一个返回此概念顺序中接下来 $k$ 个元素的函数。该函数不得改变队列的状态变量（$f$，$s$）或数组 $A$ 的内容。它必须在 $\\mathcal{O}(k)$ 时间内执行，并使用 $\\mathcal{O}(1)$ 的额外内存，不包括输出列表的存储空间。\n\n该算法可以直接根据索引映射原理进行设计：\n\n1.  **确定要返回的元素数量**：题目规定，如果 $k$ 超过可用元素的数量 $s$，函数应返回所有可用元素。如果 $k=0$ 或队列为空 ($s=0$)，它应返回一个空列表。这可以通过计算要返回的元素数量（我们称之为 $n_{peek}$）来统一处理：\n    $$\n    n_{peek} = \\min(k, s)\n    $$\n    当 $k  s$ 时，该表达式正确地得到 $s$；当 $k \\le s$ 时，得到 $k$；如果 $k=0$ 或 $s=0$，则得到 $0$。\n\n2.  **迭代并收集元素**：如果 $n_{peek}  0$，我们继续收集元素。我们可以迭代 $n_{peek}$ 次，循环索引 $i$ 从 $0$ 运行到 $n_{peek}-1$。在每次迭代中，$i$ 代表概念上出队顺序中的位置。\n\n3.  **计算物理索引**：对于每个 $i$ 值，我们使用核心映射公式来找到元素所在的数组 $A$ 中的物理索引 $j$：\n    $$\n    j = (f + i) \\pmod C\n    $$\n\n4.  **访问并存储**：访问位于 $A[j]$ 的元素并将其附加到结果列表中。此操作纯粹是读操作，不会改变队列的状态。\n\n5.  **返回结果**：循环完成后，结果列表包含了概念顺序中的前 $n_{peek}$ 个元素，并被返回。\n\n该算法满足所有给定约束：\n-   **无状态改变**：该算法只读取队列的内部状态（$f$，$s$ 和 $A$），不执行任何写操作。队列的状态保持不变。\n-   **时间复杂度**：主要工作是一个运行 $n_{peek} = \\min(k, s)$ 次的单一循环。由于 $s$ 最多为 $C$，$k$ 是输入参数，所以迭代次数受 $k$ 的限制。循环内的每一步（索引计算、数组访问、列表追加）都花费常数时间，即 $\\mathcal{O}(1)$。因此，总时间复杂度为 $\\mathcal{O}(\\min(k, s))$，这与要求的 $\\mathcal{O}(k)$ 相符。\n-   **空间复杂度**：该算法使用少量变量用于循环计数器和索引计算，消耗 $\\mathcal{O}(1)$ 的空间。返回列表所需空间被明确排除在此约束之外。因此，满足了额外工作空间的要求。\n\n实现将包含一个表示循环队列的类，该类具有 `enqueue`、`dequeue` 以及所需的预览接下来 $k$ 个元素的函数的方法，然后是一个执行指定测试套件的主程序。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass CircularQueue:\n    \"\"\"\n    An array-backed circular queue.\n    \"\"\"\n    def __init__(self, capacity: int):\n        if capacity  1:\n            raise ValueError(\"Capacity must be a positive integer.\")\n        self._capacity = capacity\n        # Use dtype=object to store any Python object, including integers.\n        self._data = np.empty(capacity, dtype=object)\n        self._front = 0\n        self._size = 0\n\n    def enqueue(self, element):\n        \"\"\"Adds an element to the rear of the queue.\"\"\"\n        if self._size == self._capacity:\n            raise OverflowError(\"Queue is full\")\n        \n        # The rear index is derived from front and size.\n        rear_index = (self._front + self._size) % self._capacity\n        self._data[rear_index] = element\n        self._size += 1\n\n    def dequeue(self):\n        \"\"\"Removes and returns the front element of the queue.\"\"\"\n        if self._size == 0:\n            raise IndexError(\"Dequeue from an empty queue\")\n        \n        element = self._data[self._front]\n        self._data[self._front] = None # Optional: clear the dequeued slot\n        self._front = (self._front + 1) % self._capacity\n        self._size -= 1\n        return element\n\n    def peek_k(self, k: int):\n        \"\"\"\n        Returns the next k elements in the conceptual dequeue order\n        without mutating the queue.\n        \"\"\"\n        num_to_peek = min(k, self._size)\n        if num_to_peek = 0:\n            return []\n        \n        result = []\n        for i in range(num_to_peek):\n            # The i-th element (0-indexed) in conceptual order is at\n            # physical index (front + i) % capacity.\n            physical_index = (self._front + i) % self._capacity\n            result.append(self._data[physical_index])\n            \n        return result\n\ndef solve():\n    \"\"\"\n    Constructs and tests circular queues as per the problem statement.\n    \"\"\"\n    # Test suite definition: (capacity, list_of_operations, k)\n    # Operations: ('e', value) for enqueue, ('d',) for dequeue\n    test_cases = [\n        # Test case 1\n        (7, [('e', 10), ('e', 20), ('e', 30), ('e', 40)], 3),\n        # Test case 2\n        (5, [('e', 1), ('e', 2), ('e', 3), ('e', 4), ('d',), ('d',), ('d',), ('e', 5), ('e', 6), ('e', 7)], 4),\n        # Test case 3\n        (6, [('e', 9), ('e', 8)], 0),\n        # Test case 4\n        (8, [('e', 100), ('e', 200), ('e', 300)], 3),\n        # Test case 5\n        (6, [('e', 5), ('e', 15)], 5),\n        # Test case 6\n        (4, [], 2),\n        # Test case 7\n        (4, [('e', 7), ('e', 8), ('e', 9), ('e', 10)], 2),\n        # Test case 8\n        (3, [('e', 1), ('e', 2), ('e', 3), ('d',), ('d',), ('e', 4), ('e', 5)], 3),\n    ]\n\n    results = []\n    for capacity, operations, k_val in test_cases:\n        queue = CircularQueue(capacity)\n        for op in operations:\n            if op[0] == 'e':\n                queue.enqueue(op[1])\n            elif op[0] == 'd':\n                queue.dequeue()\n        \n        peek_result = queue.peek_k(k_val)\n        results.append(peek_result)\n\n    # The final print statement must produce the specified single-line format.\n    # The default str() for a list includes spaces, which is acceptable.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solution\nsolve()\n\n```", "id": "3221146"}, {"introduction": "许多标准算法都可以被巧妙地改造以适用于循环数据结构。本练习挑战你将一个熟悉的算法——原地数组反转——应用于循环队列 [@problem_id:3221166]。成功解决这个问题，需要你熟练运用前一个练习中学到的模运算索引技巧，这能加深你对算法适应性的理解。", "problem": "给定一个基于固定长度数组实现的循环队列的定义。循环队列是一种先进先出（FIFO）的数据结构，其内容使用模运算在一个环中进行维护。设底层数组的容量为 $N$，队列的活动段由一个头索引 $H$ 和一个长度 $K$ 指定。逻辑位置为 $i$（其中 $0 \\le i \\le K-1$）的活动元素位于物理索引 $(H+i) \\bmod N$ 处。数组中未被这 $K$ 个活动索引覆盖的位置是未使用的，并且与队列的逻辑序列无关。\n\n从循环队列中元素的逻辑顺序由映射 $i \\mapsto (H+i) \\bmod N$ 控制这一基本定义出发，设计一个算法，原地反转循环队列的 $K$ 个活动元素，仅使用 $O(1)$ 的额外空间，并且不改变 $H$、$K$ 或 $N$。您必须根据模运算和队列定义的第一性原理进行推理，以确保算法对于所有有效参数值（包括边界情况）的正确性。该算法必须在 $O(K)$ 时间内运行，并且最多使用常数个辅助变量，这些变量与 $N$ 和 $K$ 无关。\n\n您的程序必须在以下测试集上实现此反转。每个测试用例都提供了 $N$、$A$、$H$ 和 $K$ 的具体值，其中 $A$ 是数组内容，且只有 $K$ 个活动位置需要被反转。反转后，对每个测试用例，按从头到尾的顺序输出 $K$ 个活动元素的逻辑序列，形式为一个整数列表。\n\n测试集：\n- 情况 1：$N=8$，$H=3$，$K=5$，$A=[0,0,0,10,20,30,40,50]$。\n- 情况 2：$N=7$，$H=5$，$K=4$，$A=[3,4,0,0,0,1,2]$。\n- 情况 3：$N=5$，$H=2$，$K=0$，$A=[9,8,7,6,5]$。\n- 情况 4：$N=6$，$H=4$，$K=1$，$A=[0,0,0,0,99,0]$。\n- 情况 5：$N=6$，$H=2$，$K=6$，$A=[11,12,7,8,9,10]$。\n- 情况 6：$N=1$，$H=0$，$K=1$，$A=[42]$。\n\n约束条件：\n- $N$ 是一个整数，满足 $N \\ge 1$。\n- $H$ 是一个整数，满足 $0 \\le H \\le N-1$。\n- $K$ 是一个整数，满足 $0 \\le K \\le N$。\n- $A$ 是一个长度为 $N$ 的列表；仅索引为 $(H+i) \\bmod N$（其中 $i \\in \\{0,1,\\dots,K-1\\}$）的位置构成活动队列内容。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[[result_1,result_2,\\dots]]$），其中每个 $result_j$ 本身是第 $j$ 个测试用例反转后 $K$ 个活动元素的列表。输出行中不得有任何空格。每个 $result_j$ 都是一个整数列表。例如，一个可能的输出可能看起来像 $[[2,1],[\\ ],[9]]$，其中 $[\\ ]$ 表示空列表。在您的输出中，使用 $[]$ 表示空列表。", "solution": "我们从基于容量为 $N$ 的数组的循环队列的核心定义开始。$K$ 个活动元素的逻辑序列由以下映射确定\n$$\n\\text{phys}(i) = (H + i) \\bmod N,\\quad \\text{for } i \\in \\{0,1,\\dots,K-1\\}.\n$$\n反转逻辑序列意味着对于序列前半部分的所有 $i$，逻辑位置 $i$ 处的元素必须与逻辑位置 $(K-1-i)$ 处的元素进行交换。在标准的数组反转中，这是通过围绕中心的对称交换实现的，当索引以模 $N$ 解释时，同样的原则也适用于此。\n\n基于原理的推导：\n1. 队列的逻辑顺序完全由 $H$、$K$ 和 $N$ 通过模运算确定。要在不改变表示参数（$H$、$K$、$N$）的情况下反转序列，我们必须只排列存储在与活动范围对应的物理索引处的值。\n2. 定义逻辑位置和物理位置之间的双射：\n   $$\n   f(i) = (H+i) \\bmod N,\\quad i \\in \\{0,1,\\dots,K-1\\}.\n   $$\n   该函数在指定定义域上是单射的，因为 $N \\ge 1$ 且定义域大小为 $K \\le N$。上域中的位置在模 $N$ 意义下是不同的。\n3. 反转需要将序列 $\\langle a_0,a_1,\\dots,a_{K-1} \\rangle$ 转换为 $\\langle a_{K-1},\\dots,a_1,a_0 \\rangle$。这可以通过对从 $0$ 到 $\\left\\lfloor\\frac{K}{2}\\right\\rfloor - 1$ 的每个 $i$ 执行交换来实现\n   $$\n   \\text{swap}\\left(A[f(i)],\\ A[f(K-1-i)]\\right).\n   $$\n   此类交换的次数为 $\\left\\lfloor\\frac{K}{2}\\right\\rfloor$，每次交换使用常数额外空间（一个临时变量）。\n4. 正确性论证：\n   - 对于每一对 $(i, K-1-i)$，交换操作将 $a_{K-1-i}$ 放置在物理索引 $f(i)$ 处，并将 $a_i$ 放置在物理索引 $f(K-1-i)$ 处。\n   - 因为索引 $i$ 恰好覆盖了 $\\{0,\\dots,K-1\\}$ 的前半部分，而 $K-1-i$ 恰好覆盖了后半部分，所以在所有交换之后，序列被反转。\n   - 不会触及非活动索引，因为 $f(i)$ 仅对 $[0, K-1]$ 中的 $i$ 计算。\n   - 参数 $H$、$K$、$N$ 保持不变，保留了队列的表示，而逻辑顺序现在被反转。\n5. 复杂度：\n   - 时间：该算法执行 $\\left\\lfloor\\frac{K}{2}\\right\\rfloor$ 次交换，每次交换的工作量为 $O(1)$，因此总时间为 $O(K)$。\n   - 空间：除常数个变量（循环计数器、两个索引和一个用于交换的临时变量）外，不使用额外存储，因此空间复杂度为 $O(1)$。\n6. 边界条件：\n   - 如果 $K=0$，循环不执行，数组保持不变，输出为空列表 $[]$。\n   - 如果 $K=1$，循环不执行，因此单个元素保持不变。\n   - 如果 $K=N$，所有位置 $\\{0,1,\\dots,N-1\\}$ 都是活动的，并且由于模运算，同样的程序也适用，索引会正确地环绕。\n   - 环绕情况被自然处理，因为 $f(i)$ 使用 $(H+i) \\bmod N$，确保了连续的逻辑位置可以跨越数组边界映射到正确的物理位置。\n\n输出的实现细节：\n- 执行反转后，通过读取 $A[(H+i) \\bmod N]$（其中 $i=0,1,\\dots,K-1$）来重构用于输出的逻辑序列。\n- 对于提供的测试集，每个结果都是一个整数列表。程序将所有六个结果聚合到一个列表中，并以指定的无空格格式打印，以确保严格遵守输出要求。\n\n该方法直接源于逻辑位置和模物理索引之间的基本映射，并使用了适用于循环索引的、经过充分测试的序列反转技术，从而实现了所要求的原地 $O(1)$ 空间和 $O(K)$ 时间复杂度的反转。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np  # Imported as allowed; not strictly required by the solution.\n\ndef reverse_circular_queue_in_place(A, N, H, K):\n    \"\"\"\n    Reverse the K active elements of a circular queue in-place.\n    Active logical positions i in [0, K-1] map to physical indices (H+i) % N.\n    The reversal maintains H, K, and N unchanged.\n    \"\"\"\n    # Handle trivial cases gracefully.\n    if K = 1:\n        return  # Nothing to do\n\n    # Perform symmetric swaps using modular arithmetic.\n    half = K // 2\n    for i in range(half):\n        left_idx = (H + i) % N\n        right_idx = (H + (K - 1 - i)) % N\n        # Swap A[left_idx] and A[right_idx]\n        A[left_idx], A[right_idx] = A[right_idx], A[left_idx]\n\n\ndef linearize_active(A, N, H, K):\n    \"\"\"\n    Return the logical sequence of active elements as a list:\n    [A[(H+0)%N], A[(H+1)%N], ..., A[(H+K-1)%N]]\n    \"\"\"\n    return [A[(H + i) % N] for i in range(K)]\n\n\ndef format_list_no_spaces(lst):\n    \"\"\"\n    Format a Python list (of ints) as a string without spaces, e.g., [1,2,3].\n    \"\"\"\n    return \"[\" + \",\".join(str(x) for x in lst) + \"]\"\n\n\ndef format_list_of_lists_no_spaces(list_of_lists):\n    \"\"\"\n    Format a list of lists (each inner list contains ints) without spaces.\n    Example: [[1,2],[3],[ ]] - \"[[1,2],[3],[]]\"\n    \"\"\"\n    inner = \",\".join(format_list_no_spaces(inner_lst) for inner_lst in list_of_lists)\n    return \"[\" + inner + \"]\"\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (N, A, H, K)\n    test_cases = [\n        (8, [0, 0, 0, 10, 20, 30, 40, 50], 3, 5),   # Case 1\n        (7, [3, 4, 0, 0, 0, 1, 2], 5, 4),           # Case 2\n        (5, [9, 8, 7, 6, 5], 2, 0),                 # Case 3 (empty)\n        (6, [0, 0, 0, 0, 99, 0], 4, 1),             # Case 4 (single element)\n        (6, [11, 12, 7, 8, 9, 10], 2, 6),           # Case 5 (full queue)\n        (1, [42], 0, 1),                            # Case 6 (degenerate capacity)\n    ]\n\n    results = []\n    for N, A, H, K in test_cases:\n        # Reverse the active elements in place.\n        reverse_circular_queue_in_place(A, N, H, K)\n        # Collect the logical sequence after reversal.\n        linearized = linearize_active(A, N, H, K)\n        results.append(linearized)\n\n    # Final print statement in the exact required format (no spaces).\n    print(format_list_of_lists_no_spaces(results))\n\nsolve()\n```", "id": "3221166"}]}