{"hands_on_practices": [{"introduction": "深度优先搜索（DFS）不仅能遍历显式给定的图，还能通过探索抽象的“状态空间”来生成组合对象。本练习将向您展示如何将生成有效括号序列的问题建模为在一个隐式图上的搜索任务 [@problem_id:3227706]。通过定义状态（已放置的左右括号数量）和有效的状态转移（添加“（”或“)”的规则），您将使用DFS递归地构建出所有可能的有效解，这是将递归思想应用于组合生成问题的经典实践。", "problem": "您需要设计并实现一个程序，对于每个提供的输入值，该程序使用深度优先搜索（Depth-First Search, DFS）来枚举有效括号序列的隐式状态空间，并计算长度为 $2n$ 的此类序列的总数。一个有效的括号序列，由 '(' 和 ')' 两个字符组成，其定义遵循以下形式化约束，对于一个长度为 $2n$ 的序列 $s$：\n- 开括号 '(' 的总数为 $n$，闭括号 ')' 的总数也为 $n$。\n- 对于 $s$ 的任意长度为 $i$ 的前缀，定义 $b(i)$ 为该前缀中 '(' 的数量减去 ')' 的数量。有效性约束为：对于所有 $0$ 到 $2n$ 的 $i$，$b(i) \\ge 0$，并且 $b(2n) = 0$。\n\n将生成任务建模为在一个隐式有向图上的探索。图中的节点是状态 $(o,c)$，表示一个已放置了 $o$ 个开括号和 $c$ 个闭括号的部分序列，其中 $0 \\le o \\le n$，$0 \\le c \\le n$ 且 $c \\le o$。从任何状态 $(o,c)$ 出发，最多有两条出边：如果 $o  n$，则有一条边指向 $(o+1,c)$（放置一个开括号）；如果 $c  o$，则有一条边指向 $(o,c+1)$（放置一个闭括号）。起始节点是 $(0,0)$；任何满足 $(o,c) = (n,n)$ 的节点都对应一个完整的有效序列。您的程序必须实现一个 DFS，该 DFS：\n- 通过递归或迭代方式扩展部分序列，在扩展时先尝试添加 '(' 再尝试添加 ')'，以强制执行确定性的遍历顺序，从而探索隐式图。\n- 通过始终遵守 $c \\le o$ 和 $o \\le n$ 的规则，确保所有生成的序列都满足有效性约束。\n- 通过沿着从 $(0,0)$到 $(n,n)$ 的唯一路径精确构造每个序列一次，来避免重复。\n\n您的任务是，对于每个给定的 $n$，计算您的 DFS 可以生成的有效序列的总数。您不能依赖任何预先推导出的计数公式；相反，必须通过实际的 DFS 遍历来得出计数结果，该遍历过程如果要列出所有序列，也能够枚举它们。\n\n测试套件：\n- 边界情况：$n = 0$。\n- 小规模情况：$n = 1$。\n- 典型情况：$n = 3$。\n- 大规模情况：$n = 8$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序对应于 $n = 0$、$n = 1$、$n = 3$ 和 $n = 8$；例如，格式为 $[a,b,c,d]$，其中 $a$、$b$、$c$ 和 $d$ 是计算出的整数计数。", "solution": "该问题要求通过在隐式状态空间图上执行深度优先搜索（DFS）来计算长度为 $2n$ 的有效括号序列的数量。解法必须源自遍历本身，而不是使用已知的封闭形式组合公式。\n\n有效括号序列的生成可以被建模为有向无环图上的路径寻找问题。此图中的每个节点代表序列构建过程中的一个状态，而边代表添加单个括号的操作。\n\n**状态表示**\n一个状态可以由一个元组 $(o, c)$ 唯一确定，其中 $o$ 是到目前为止构建的前缀中开括号 `(` 的数量， $c$ 是闭括号 `)` 的数量。这些计数的约束条件是 $0 \\le o \\le n$ 和 $0 \\le c \\le n$。问题通过一个条件来定义有效前缀：闭括号的数量永不超过开括号的数量，这可以转化为状态约束 $c \\le o$。\n\n-   **初始状态**：过程始于一个空序列，对应于状态 $(0, 0)$。\n-   **目标状态**：当我们达到状态 $(n, n)$ 时，就形成了一个长度为 $2n$ 的完整且有效的序列，因为它包含 $n$ 个开括号和 $n$ 个闭括号，满足平衡条件 $b(2n) = n - n = 0$。\n\n**状态转移**\n从任意给定状态 $(o, c)$，我们可以通过追加一个开括号或一个闭括号来转移到新状态。有效性规则决定了可能的状态转移：\n\n1.  **添加一个开括号 `(`**：如果我们尚未使用完所有 $n$ 个可用的开括号，就可以添加一个开括号。这对应于从状态 $(o, c)$ 到 $(o+1, c)$ 的转移。此操作当且仅当 $o  n$ 时有效。\n\n2.  **添加一个闭括号 `)`**：如果添加一个闭括号不会违反前缀有效性约束，即闭括号的数量必须保持小于或等于开括号的数量，我们就可以这样做。由于我们正在添加一个闭括号，当前闭括号数 $c$ 必须严格小于当前开括号数 $o$。这对应于从状态 $(o, c)$ 到 $(o, c+1)$ 的转移。此操作当且仅当 $c  o$ 时有效。\n\n问题指定探索应先尝试添加 `(` 再尝试添加 `)`。递归实现很自然地强制执行了这种确定性顺序。\n\n**用于计数的深度优先搜索（DFS）**\n我们可以通过实现一个使用 DFS 探索状态空间的递归函数来解决这个计数问题。我们定义一个函数 `count_sequences(o, c)`，它计算从状态 $(o, c)$ 开始完成一个有效序列的方法数。\n\n-   **基本情况**：当达到目标状态 $(n, n)$ 时，递归终止。此时，一个完整的有效序列已经生成。因此，如果 $o = n$ 且 $c = n$，函数应返回 $1$。\n\n-   **递归步骤**：对于任何其他有效状态 $(o, c)$，有效补全的总数是所有可能的后续有效状态的补全数之和。\n    -   初始化一个本地计数器 `total_count` 为 $0$。\n    -   如果到 $(o+1, c)$ 的转移是有效的（即 $o  n$），我们递归调用 `count_sequences(o+1, c)` 并将结果加到 `total_count` 上。\n    -   如果到 $(o, c+1)$ 的转移是有效的（即 $c  o$），我们递归调用 `count_sequences(o, c+1)` 并将结果加到 `total_count` 上。\n    -   函数返回 `total_count`。\n\n对于给定的 $n$，寻找序列总数的初始调用将是 `count_sequences(0, 0)`。\n\n**通过记忆化进行优化**\n一个朴素的递归实现会多次重复计算同一状态 $(o, c)$ 的结果。例如，状态 $(2, 1)$ 可以通过路径 `()` 后跟 `(` 到达，也可以通过 `((` 后跟 `)` 到达。这种重叠子问题结构表明可以使用记忆化（memoization）进行优化，这是一种自顶向下的动态规划技术。\n\n我们可以使用一个二维数组 `memo[o][c]` 来存储每个状态 $(o, c)$ 一旦计算出的结果。这个缓存的大小将是 $(n+1) \\times (n+1)$。在计算一个状态的结果之前，我们首先检查它是否已经存储在缓存中。如果是，我们直接返回存储的值。否则，我们执行计算，并在返回之前将结果存储在缓存中。\n\n这种优化将时间复杂度从与卡特兰数的大小相关的指数级降至多项式级。状态的数量与 $n^2$ 成正比，并且每个状态的值只计算一次。因此，记忆化算法的时间复杂度为 $O(n^2)$。\n\n**最终算法**\n对于每个给定的 $n$ 值：\n1.  初始化一个 $(n+1) \\times (n+1)$ 的记忆化表格，使用一个哨兵值（例如-1）来表示状态尚未计算。\n2.  从初始状态 $(0, 0)$ 开始，调用递归 DFS 函数 `dfs_count(o, c, n, memo)`。\n3.  函数按以下方式执行：\n    -   如果 $o > n$、$c > n$ 或 $c > o$，则状态无效；返回 $0$。\n    -   如果 `memo[o][c]` 的结果不是哨兵值，则返回缓存的结果。\n    -   如果达到基本情况 $(o, c) = (n, n)$，则返回 $1$。\n    -   否则，通过对有效下一状态的递归调用结果求和来计算路径数：如果 $o  n$，则调用 `dfs_count(o+1, c, n, memo)`；如果 $c  o$，则调用 `dfs_count(o, c+1, n, memo)`。\n    -   将此和存储在 `memo[o][c]` 中并返回。\n4. 初始调用 `dfs_count(0, 0, n, memo)` 返回的值即为给定 $n$ 的有效括号序列的总数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of counting valid parenthesis sequences using DFS.\n    \"\"\"\n\n    # Test suite as specified in the problem statement.\n    test_cases = [0, 1, 3, 8]\n\n    results = []\n\n    for n in test_cases:\n        # For n=0, the sequence is empty, which is 1 valid sequence.\n        # The recursion handles this, but a direct check is also clear.\n        if n == 0:\n            results.append(1)\n            continue\n\n        # Memoization table to store results of subproblems.\n        # Dimensions are (n+1) x (n+1) for states (o, c)\n        # where o and c range from 0 to n.\n        # Initialize with -1 to indicate not computed.\n        memo = np.full((n + 1, n + 1), -1, dtype=int)\n\n        def _dfs_count(o: int, c: int) -> int:\n            \"\"\"\n            Recursive DFS function to count valid sequences from state (o, c).\n            - o: number of open parentheses used.\n            - c: number of close parentheses used.\n            \"\"\"\n            \n            # Base case: A complete and valid sequence is formed.\n            if o == n and c == n:\n                return 1\n\n            # If this state has been computed, return the cached result.\n            if memo[o, c] != -1:\n                return memo[o, c]\n\n            # Recursive step: Explore valid next states.\n            count = 0\n            \n            # Option 1: Add an opening parenthesis '('\n            # This is valid if the number of open parentheses is less than n.\n            if o  n:\n                count += _dfs_count(o + 1, c)\n\n            # Option 2: Add a closing parenthesis ')'\n            # This is valid if the number of close parentheses is less than\n            # the number of open parentheses, maintaining prefix validity.\n            if c  o:\n                count += _dfs_count(o, c + 1)\n            \n            # Cache the result for the current state (o, c) before returning.\n            memo[o, c] = count\n            return count\n\n        # Start the DFS from the initial state (0, 0).\n        total_sequences = _dfs_count(0, 0)\n        results.append(total_sequences)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3227706"}, {"introduction": "除了基本的节点访问，深度优先搜索（DFS）还可以通过在遍历过程中携带额外信息来验证图的结构属性。本练习将利用DFS来判断一个图是否为二分图，这是一个在调度和资源分配等领域有重要应用的属性 [@problem_id:3227650]。您将通过在遍历时为节点“着色”并检查是否存在颜色冲突，来实践如何增强DFS算法，使其能够检测奇数长度的环路，从而高效地解决二分图判定问题。", "problem": "考虑一个模拟电路布局的无向有限图，其中顶点表示连接点，边表示直接连接。如果可以为每个顶点分配两种颜色中的一种，使得没有边连接相同颜色的顶点，则称该电路布局是 $2$-可着色的。用图论的术语来说，这等价于该图是二分图。您的任务是推导、实现并应用一种基于深度优先搜索 (DFS) 的方法，来判断一组无向图的二分性。\n\n从以下基础出发：无向图的定义为一个对 $(V, E)$，其中 $V$ 是顶点集，$E$ 是边集；路径是顶点的序列，其中连续的顶点对都在 $E$ 中；环是一条至少包含三个顶点的闭合路径，且所有顶点（除了第一个和最后一个）都不同；路径或环长度的奇偶性（偶数或奇数）以边的数量来衡量。将图的 $2$-着色定义为一个函数 $c: V \\to \\{0,1\\}$，使得对于每条边 $\\{u,v\\} \\in E$，都有 $c(u) \\neq c(v)$。使用深度优先搜索 (DFS) 来探索图并尝试构建这样的着色，并判断是否出现冲突。问题陈述中不允许使用超出这些核心定义的任何中间算法。\n\n您的程序必须是自包含的，并且不得读取任何输入。它必须编码以下无向图测试套件，每个图都由一个邻接表表示。邻接表是一个列表的有序列表；第 $i$ 个内部列表枚举了顶点 $i$ 的邻居。对于一个有 $n$ 个顶点的图，所有顶点都用从 $0$到 $n-1$ 的连续整数标记。将每个邻接表对称地解释为无向图。\n\n测试套件：\n- 案例 $1$ (偶数环，二分图): $n=6$，邻接表 $[[1,5],[0,2],[1,3],[2,4],[3,5],[4,0]]$。\n- 案例 $2$ (奇数环，非二分图): $n=3$，邻接表 $[[1,2],[0,2],[0,1]]$。\n- 案例 $3$ (空图，平凡二分图): $n=0$，邻接表 $[]$。\n- 案例 $4$ (单顶点，二分图): $n=1$，邻接表 $[[]]$。\n- 案例 $5$ (不连通，包含奇数环，非二分图): $n=6$，邻接表 $[[1],[0,2],[1],[4,5],[3,5],[3,4]]$。\n- 案例 $6$ (有平行边，但为二分图): $n=2$，邻接表 $[[1,1],[0,0]]$。\n- 案例 $7$ (有自环，非二分图): $n=1$，邻接表 $[[0]]$。\n\n设计要求：\n- 使用深度优先搜索 (DFS) 尝试沿着发现边为顶点分配颜色 $0$ 和 $1$，每一步交替颜色。如果一个邻居的颜色与当前顶点的颜色相同，则报告该图不是二分图；否则，继续。通过从每个未着色的顶点启动 DFS 来处理不连通的图。\n- 自环是直接的违规，因为边 $\\{v,v\\}$ 强制要求 $c(v) \\neq c(v)$，这是不可能的。\n- 两个顶点之间的多条边不改变二分性；但是，您的 DFS 必须对邻接表中的此类重复项具有鲁棒性。\n- 时间复杂度和空间复杂度必须与图的大小成线性关系，即时间复杂度为 $O(|V|+|E|)$，空间复杂度为 $O(|V|)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含七个案例的结果，格式为方括号括起来的逗号分隔列表，每个结果都是一个布尔值，指示相应的图是否为二分图（true 表示是二分图，false 表示不是二分图），例如 $[r_1,r_2,\\dots,r_7]$，其中每个 $r_i$ 是标准编程语言布尔表示法中的 $\\mathrm{True}$ 或 $\\mathrm{False}$。不应打印其他任何文本。", "solution": "该问题要求一种基于深度优先搜索 (DFS) 的算法方法，以确定给定的无向图是否为二分图。一个图是二分图当且仅当它是 $2$-可着色的。\n\n**理论基础**\n\n一个无向图 $G = (V, E)$（其中 $V$ 是顶点集，$E$ 是边集）被定义为二分图，如果其顶点集 $V$ 可以被划分为两个不相交的独立集 $V_0$ 和 $V_1$，使得 $E$ 中的每条边都连接 $V_0$ 中的一个顶点和 $V_1$ 中的一个顶点。一个等价的表述是存在一个 $2$-着色函数 $c: V \\to \\{0, 1\\}$，使得对于每条边 $\\{u,v\\} \\in E$，条件 $c(u) \\neq c(v)$ 都成立。\n\n图论中的一个基本定理指出，一个图是二分图当且仅当它不包含奇数长度的环。环是长度至少为一且起点和终点相同的路径。环的长度是它包含的边的数量。自环，即形如 $\\{v,v\\}$ 的边，构成一个长度为 $1$ 的环，这是奇数。因此，任何带有自环的图都不是二分图。\n\n**算法策略：通过深度优先搜索进行 $2$-着色**\n\n我们可以通过尝试使用深度优先搜索 (DFS) 构建一个有效的 $2$-着色来判断一个图是否为二分图。该算法过程如下：\n\n1.  **初始化**：我们维护一个大小为 $|V|$ 的颜色数组 `colors`，其中 `colors[i]` 存储分配给顶点 $i$ 的颜色。我们用一个特殊值（例如 $-1$）来初始化此数组，以表示还没有顶点被着色。\n\n2.  **处理不连通分量**：一个图可能由多个不相交的连通分量组成。整个图的二分性取决于每个独立分量的二分性。因此，我们遍历从 $v=0$ 到 $|V|-1$ 的所有顶点。如果一个顶点 $v$ 尚未被着色（即 `colors[v]` 为 $-1$），则它属于一个新的、未探索的分量。我们从这个顶点 $v$ 开始进行 DFS 遍历，并为其分配一个初始颜色，例如 $0$。\n\n3.  **DFS 遍历与着色**：可以递归实现的 DFS 过程执行着色和冲突检测：\n    - 当访问一个已分配颜色 $c(u)$ 的顶点 $u$ 时，我们遍历其邻接表中的所有邻居 $w$。\n    - **情况 A：邻居未着色**。如果邻居 $w$ 尚未被着色（即 `colors[w]` 为 $-1$），我们给它分配与 $u$ 相反的颜色，即 $c(w) = 1 - c(u)$。然后我们对 $w$ 进行递归调用 DFS。如果这个递归调用在其子树中检测到冲突，该冲突将被传播回来，我们便可断定该图不是二分图。\n    - **情况 B：邻居已着色**。如果邻居 $w$ 已经被着色，我们必须检查是否存在冲突。如果 $w$ 的颜色与 $u$ 相同，即 $c(w) = c(u)$，则产生冲突。这一发现意味着存在一条连接两个相同颜色顶点的边，这违反了 $2$-着色的条件。这种情况对应于在图中发现了一个奇数长度的环。从该连通分量的起始顶点到 $u$ 的路径，以及从同一始点到 $w$ 的路径，再加上边 $\\{u,w\\}$，就形成了一个环。如果 $u$ 和 $w$ 的颜色相同，那么它们距离起始顶点的距离（以边数计算）具有相同的奇偶性。环的长度是这些路径长度之和加一。`(偶数 + 偶数 + 1)` 或 `(奇数 + 奇数 + 1)` 的结果都是奇数。因此，颜色冲突标志着存在一个奇数环。\n\n4.  **终止**：如果一个分量的 DFS 遍历在没有任何颜色冲突的情况下完成，则该分量是二分图。主循环接着继续搜索其他未着色的分量。如果处理完所有顶点且未发现任何冲突，则整个图是二分图。如果在任何时刻发现冲突，算法可以立即终止并报告该图不是二分图。\n\n**复杂度分析**\n-   **时间复杂度**：每个顶点作为 DFS 调用的根（对于每个分量）被精确访问和处理一次。在邻接表表示中，每条边 $\\{u, v\\}$ 被检查两次（一次在 $u$ 的列表中，一次在 $v$ 的列表中）。每个顶点和每条边所做的工作是常数级的。因此，总时间复杂度与图的大小成线性关系，即 $O(|V| + |E|)$。\n-   **空间复杂度**：主要的空间需求是 `colors` 数组，其大小为 $|V|$。此外，在最坏的情况下（路径图），DFS 的递归栈深度最多可以达到 $|V|$。因此，空间复杂度为 $O(|V|)$。\n\n这种基于 DFS 的方法正确地解决了问题要求，包括对不连通图、自环（会立即产生冲突：$c(v)=c(v)$ 为假）和（不改变结果的冗余检查）平行边的鲁棒性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the bipartite checking problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: n=6, even cycle, bipartite\n        (6, [[1, 5], [0, 2], [1, 3], [2, 4], [3, 5], [4, 0]]),\n        # Case 2: n=3, odd cycle, not bipartite\n        (3, [[1, 2], [0, 2], [0, 1]]),\n        # Case 3: n=0, empty graph, vacuously bipartite\n        (0, []),\n        # Case 4: n=1, single vertex, bipartite\n        (1, [[]]),\n        # Case 5: n=6, disconnected with odd cycle, not bipartite\n        (6, [[1], [0, 2], [1], [4, 5], [3, 5], [3, 4]]),\n        # Case 6: n=2, parallel edges, bipartite\n        (2, [[1, 1], [0, 0]]),\n        # Case 7: n=1, self-loop, not bipartite\n        (1, [[0]]),\n    ]\n\n    results = []\n    for n, adj in test_cases:\n        results.append(is_bipartite(n, adj))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\ndef is_bipartite(n, adj):\n    \"\"\"\n    Checks if a graph is bipartite using DFS-based 2-coloring.\n\n    Args:\n        n (int): The number of vertices, |V|.\n        adj (list of list of int): The adjacency list of the graph.\n\n    Returns:\n        bool: True if the graph is bipartite, False otherwise.\n    \"\"\"\n    if n == 0:\n        return True\n\n    # colors[i] = -1: uncolored, 0: color 0, 1: color 1\n    colors = [-1] * n\n\n    def dfs(u, color):\n        \"\"\"\n        Recursive DFS to perform 2-coloring.\n\n        Args:\n            u (int): The current vertex.\n            color (int): The color to assign to the current vertex (0 or 1).\n\n        Returns:\n            bool: True if the component is bipartite, False if a conflict is found.\n        \"\"\"\n        colors[u] = color\n        for v in adj[u]:\n            if colors[v] == -1:\n                # If neighbor is uncolored, color with the opposite color\n                # and recurse. If recursion finds a conflict, propagate False.\n                if not dfs(v, 1 - color):\n                    return False\n            elif colors[v] == colors[u]:\n                # If neighbor has the same color, an odd cycle is found.\n                return False\n        return True\n\n    # Iterate through all vertices to handle disconnected graphs\n    for i in range(n):\n        if colors[i] == -1:\n            # If a component is not bipartite, the whole graph is not.\n            if not dfs(i, 0):\n                return False\n\n    return True\n\nsolve()\n```", "id": "3227650"}, {"introduction": "在有向无环图（DAG）中，深度优先搜索（DFS）的递归结构与动态规划思想可以完美结合。DFS在回溯时自然地以逆拓扑序处理节点，这为解决许多优化问题提供了强大的框架 [@problem_id:3227722]。这个高级练习将引导您设计一个算法，通过将DFS与记忆化搜索（一种自顶向下的动态规划形式）相结合，来高效地求解DAG中的最长路径问题，这充分展示了DFS在解决复杂优化问题中的强大能力。", "problem": "给定一个带有非负整数边权的有向无环图 (DAG)。您的任务有两部分：首先，仅从深度优先搜索 (DFS) 和有向无环图 (DAG) 的核心定义出发，推导出一个正确的 DFS 修改算法，用于计算任何 DAG 中的最长路径长度。您的推导必须基于图论的基本定义，确定一个递归或循环不变量，并利用 DAG 的结构特性以及 DFS 诱导的顺序来证明其终止性和正确性。其次，将您推导出的方法应用于下面的具体 DAG，并计算最长路径的长度。最终答案必须是一个实数值，等于图中任意有向路径上的最大总权重。\n\n顶点集为 $\\{1,2,3,4,5,6,7,8,9\\}$，每条边都从标号较小的顶点指向标号较大的顶点。每条有向边都标注了一个非负整数权重。边如下：\n- $(1 \\to 2,\\, 3)$, $(1 \\to 3,\\, 2)$, $(1 \\to 4,\\, 5)$\n- $(2 \\to 5,\\, 4)$, $(2 \\to 6,\\, 6)$\n- $(3 \\to 4,\\, 1)$, $(3 \\to 6,\\, 2)$, $(3 \\to 7,\\, 7)$\n- $(4 \\to 6,\\, 1)$, $(4 \\to 7,\\, 4)$, $(4 \\to 8,\\, 2)$\n- $(5 \\to 7,\\, 3)$, $(5 \\to 8,\\, 5)$\n- $(6 \\to 8,\\, 4)$, $(6 \\to 9,\\, 3)$\n- $(7 \\to 8,\\, 1)$, $(7 \\to 9,\\, 8)$\n- $(8 \\to 9,\\, 2)$\n\n假设路径的长度是其有向边权重之和。如果一个顶点没有出边，那么从该顶点开始的最长路径长度为 $0$。请将您的最终答案表示为一个数字。无需四舍五入。", "solution": "该问题要求基于深度优先搜索 (DFS) 推导一个用于在有向无环图 (DAG) 中寻找最长路径长度的算法，然后将此算法应用于一个具体的图。\n\n**第一部分：算法推导**\n\n设 $G = (V, E)$ 是一个有向无环图 (DAG)，其中 $V$ 是顶点集， $E$ 是有向边集。设 $w(u, v)$ 是边 $(u, v) \\in E$ 的非负整数权重。路径的长度是其边权重之和。只包含单个顶点的路径长度为 $0$。\n\n我们的目标是找到 $G$ 中的最长路径长度。我们定义 $L(u)$ 为从顶点 $u \\in V$ 出发的最长路径的长度。那么，整个图中的最长路径长度为 $\\max_{u \\in V} L(u)$。\n\n从 $u$ 出发的路径的一个基本性质是，它必须以一条边 $(u, v)$ 开始，通向其邻居 $v$ 之一，然后接续一条从 $v$ 出发的路径。为了最大化从 $u$ 出发的路径长度，我们必须选择一个邻居 $v$ ，使得边权重 $w(u, v)$ 与从 $v$ 出发的最长路径长度 $L(v)$ 之和最大。这引出了 $L(u)$ 的一个递归定义：\n\n1.  如果顶点 $u$ 没有出边（即它是一个终端顶点或汇点），任何从 $u$ 出发的路径仅由顶点 $u$ 本身构成。这样一条路径的长度定义为 $0$。因此，对于终端顶点 $u$，$L(u) = 0$。这构成了我们递归的基准情况。\n2.  如果顶点 $u$ 有出边，从 $u$ 出发的最长路径可以通过考虑其所有邻居来找到。对于每个邻居 $v$，以边 $(u,v)$ 开始的路径的最大长度为 $w(u,v) + L(v)$。我们必须选择使这个值最大化的邻居 $v$。因此，\n    $$L(u) = \\max_{(u,v) \\in E} \\{ w(u,v) + L(v) \\}$$\n\n这个递推关系表明，要计算 $L(u)$，我们需要 $u$ 的所有后继顶点 $v$ 的 $L(v)$ 值。DAG 的无环性质在这里至关重要。由于没有环路， $L(u)$ 的计算永远不会直接或通过一串后继间接地依赖于自身。\n\n我们可以使用深度优先搜索 (DFS) 的一个修改版本来解决这个递推系统。一个标准的递归 DFS 通过访问一个顶点，然后对其所有未访问的邻居进行递归调用来探索图。当一个递归调用 `DFS(v)` 返回其调用者 `DFS(u)` 时，意味着从 $v$ 可达的整个子图的遍历已经完成。这个执行点，在对一个顶点的所有子节点的递归调用都结束后，被称为后序处理步骤。\n\n在 DAG 的 DFS 遍历中，顶点按其完成时间的排序是一个逆拓扑排序。这意味着对于任何边 $(u,v) \\in E$，$v$ 的完成时间都小于 $u$ 的完成时间。因此，如果我们在对 $u$ 的 DFS 遍历的后序步骤中计算 $L(u)$，我们可以保证其所有后继 $v$ 的 $L(v)$ 值都已经被计算出来了。\n\n这引出了以下算法，该算法使用记忆化（一种动态规划的形式）来存储 $L(u)$ 的结果以避免重复计算。设 `dist[u]` 是一个数组，用于存储已计算的 $L(u)$ 值，初始化为一个哨兵值（例如 $-\\infty$ 或 $-1$），表示该值尚未计算。\n\n**算法: `LongestPathDFS(u)`**\n1.  如果 `dist[u]` 不是哨兵值，则返回 `dist[u]`。\n2.  初始化 `max_len = 0`。这处理了终端顶点的基准情况。\n3.  对于每个顶点 $v$ 使得 $(u, v) \\in E$：\n    a. 计算 `path_len = w(u, v) + LongestPathDFS(v)`。\n    b. 更新 `max_len = max(max_len, path_len)`。\n4.  存储结果：`dist[u] = max_len`。\n5.  返回 `dist[u]`。\n\n为了找到整个图中的最长路径，我们对每个顶点 $u \\in V$ 调用此函数，并取结果中的最大值。如果图有已知的源顶点（入度为 $0$），则从这些顶点开始搜索就足够了。\n\n**证明：**\n- **递归不变量：** 函数 `LongestPathDFS(u)` 正确计算 $L(u)$。基准情况，即终端顶点，正确返回 $0$。在递归调用 `LongestPathDFS(v)` 是正确的假设下，递归步骤正确地实现了递推关系 $L(u) = \\max_{(u,v) \\in E} \\{w(u,v) + L(v)\\}$。\n- **终止性：** 在 DAG 中，递归调用的序列遵循图中的一条简单路径。由于没有环路，递归深度受顶点数量的限制，并且由于记忆化，每个顶点的 $L(u)$ 值只被计算一次。该算法对每个顶点和每条边处理一次，因此时间复杂度为 $O(|V| + |E|)$。\n- **正确性：** 正确性源于递推关系中固有的最优性原则，以及 DFS 后序遍历所诱导的逆拓扑排序确保了所有子问题 $L(v)$ 在需要它们来计算 $L(u)$ 之前都已被解决。\n\n**第二部分：应用于给定的 DAG**\n\n给定的图具有顶点集 $V = \\{1, 2, 3, 4, 5, 6, 7, 8, 9\\}$。一个关键性质是对于每条边 $(u \\to v)$，都有 $u  v$。这个性质保证了该图是一个 DAG，并且顶点标号 $(1, 2, \\dots, 9)$ 构成一个拓扑排序。因此，我们可以通过按逆拓扑顺序（从 $u=9$ 到 $u=1$）迭代顶点来计算 $L(u)$ 的值。这等价于记忆化递归 DFS 算法的结果。\n\n设 $L(u)$ 表示从顶点 $u$ 出发的最长路径的长度。\n\n-   **顶点 9：** $L(9) = 0$，因为它是一个终端顶点。\n\n-   **顶点 8：** 唯一的出边是 $(8 \\to 9, 2)$。\n    $L(8) = w(8, 9) + L(9) = 2 + 0 = 2$。\n\n-   **顶点 7：** 出边为 $(7 \\to 8, 1)$ 和 $(7 \\to 9, 8)$。\n    $L(7) = \\max \\{ w(7, 8) + L(8), w(7, 9) + L(9) \\} = \\max \\{ 1 + 2, 8 + 0 \\} = \\max \\{ 3, 8 \\} = 8$。\n\n-   **顶点 6：** 出边为 $(6 \\to 8, 4)$ 和 $(6 \\to 9, 3)$。\n    $L(6) = \\max \\{ w(6, 8) + L(8), w(6, 9) + L(9) \\} = \\max \\{ 4 + 2, 3 + 0 \\} = \\max \\{ 6, 3 \\} = 6$。\n\n-   **顶点 5：** 出边为 $(5 \\to 7, 3)$ 和 $(5 \\to 8, 5)$。\n    $L(5) = \\max \\{ w(5, 7) + L(7), w(5, 8) + L(8) \\} = \\max \\{ 3 + 8, 5 + 2 \\} = \\max \\{ 11, 7 \\} = 11$。\n\n-   **顶点 4：** 出边为 $(4 \\to 6, 1)$、$(4 \\to 7, 4)$ 和 $(4 \\to 8, 2)$。\n    $L(4) = \\max \\{ w(4, 6) + L(6), w(4, 7) + L(7), w(4, 8) + L(8) \\} = \\max \\{ 1 + 6, 4 + 8, 2 + 2 \\} = \\max \\{ 7, 12, 4 \\} = 12$。\n\n-   **顶点 3：** 出边为 $(3 \\to 4, 1)$、$(3 \\to 6, 2)$ 和 $(3 \\to 7, 7)$。\n    $L(3) = \\max \\{ w(3, 4) + L(4), w(3, 6) + L(6), w(3, 7) + L(7) \\} = \\max \\{ 1 + 12, 2 + 6, 7 + 8 \\} = \\max \\{ 13, 8, 15 \\} = 15$。\n\n-   **顶点 2：** 出边为 $(2 \\to 5, 4)$ 和 $(2 \\to 6, 6)$。\n    $L(2) = \\max \\{ w(2, 5) + L(5), w(2, 6) + L(6) \\} = \\max \\{ 4 + 11, 6 + 6 \\} = \\max \\{ 15, 12 \\} = 15$。\n\n-   **顶点 1：** 出边为 $(1 \\to 2, 3)$、$(1 \\to 3, 2)$ 和 $(1 \\to 4, 5)$。\n    $L(1) = \\max \\{ w(1, 2) + L(2), w(1, 3) + L(3), w(1, 4) + L(4) \\} = \\max \\{ 3 + 15, 2 + 15, 5 + 12 \\} = \\max \\{ 18, 17, 17 \\} = 18$。\n\n从每个顶点出发的最长路径长度为：\n$L(1)=18$, $L(2)=15$, $L(3)=15$, $L(4)=12$, $L(5)=11$, $L(6)=6$, $L(7)=8$, $L(8)=2$, $L(9)=0$。\n\n整个图中的最长路径长度是这些值的最大值：$\\max \\{18, 15, 15, 12, 11, 6, 8, 2, 0\\} = 18$。这个值对应于从唯一的源顶点——顶点1——出发的最长路径。\n该路径为 $1 \\to 2 \\to 5 \\to 7 \\to 9$，总权重为 $w(1,2)+w(2,5)+w(5,7)+w(7,9) = 3+4+3+8 = 18$。", "answer": "$$\\boxed{18}$$", "id": "3227722"}]}