{"hands_on_practices": [{"introduction": "理解特定的图类别（如完全二分图 $K_{n,m}$）不仅仅是记住定义。这个练习将挑战你运用关于顶点度和 Leonhard Euler 的经典定理的知识，来精确确定 $K_{n,m}$ 图在何种条件下包含欧拉回路。这个练习将巩固局部顶点性质与全局图遍历性之间的关键联系。[@problem_id:3237299]", "problem": "您正在处理有限、简单、无向图。设 $K_{n,m}$ 表示完全二分图，其两部分别有 $n$ 和 $m$ 个顶点，其中 $n, m \\in \\mathbb{Z}_{\\ge 1}$。仅使用关于二分图、顶点度数、图连通性以及有限无向图中欧拉回路存在性刻画的标准定义，确定哪个陈述精确地刻画了所有使 $K_{n,m}$ 存在欧拉回路的 $(n,m)$。\n\n选择唯一的最佳选项。\n\nA. $K_{n,m}$ 存在欧拉回路当且仅当 $n$ 和 $m$ 都是偶数（且 $n,m \\ge 1$）。\n\nB. $K_{n,m}$ 存在欧拉回路当且仅当 $n$ 和 $m$ 都是奇数且 $n=m$。\n\nC. $K_{n,m}$ 存在欧拉回路当且仅当 $n$ 和 $m$ 中一个为偶数，另一个为奇数。\n\nD. $K_{n,m}$ 存在欧拉回路当且仅当 $n+m$ 是偶数（且 $n,m \\ge 1$）。\n\nE. $K_{n,m}$ 存在欧拉回路当且仅当 $n=m$ 且 $n \\ge 2$。", "solution": "问题陈述是要求确定整数 $n$ 和 $m$ 满足何种精确条件时，完全二分图 $K_{n,m}$ 存在欧拉回路。\n\n### 第一步：提取已知条件\n- 所考虑的图是有限、简单、无向的。\n- $K_{n,m}$ 表示完全二分图，其两部分别有 $n$ 和 $m$ 个顶点。\n- 划分集合的大小为 $n,m \\in \\mathbb{Z}_{\\ge 1}$，即 $n \\ge 1$ 且 $m \\ge 1$。\n- 任务是找到一个刻画 $K_{n,m}$ 中存在欧拉回路的条件。\n- 推导必须基于二分图、顶点度数、图连通性以及欧拉回路特征的标准定义。\n\n### 第二步：使用提取的已知条件进行验证\n该问题陈述是图论入门中的一个标准练习。\n- **科学基础：** 完全二分图（$K_{n,m}$）和欧拉回路的概念是图论这一数学领域中基础且严格定义的概念。该问题基于已建立的数学原理。\n- **适定性：** 该问题要求一个精确的刻画，即一个充分必要条件。所有术语都是标准的且定义清晰，约束条件（$n, m \\ge 1$）是明确的。存在一个唯一且有意义的解，并且可以从给定的原理中推导出来。\n- **客观性：** 语言是形式化和数学化的，没有歧义或主观论断。\n\n问题陈述是有效的，因为它是自洽的、一致的，并且基于已建立的数学理论。\n\n### 第三步：推导解答\n\n根据图论中的一个基本定理，一个有限无向图 $G$ 存在欧拉回路，当且仅当它满足两个条件：\n1.  $G$ 是连通的（可能除去孤立顶点，尽管一个包含遍历所有边的回路的图不可能有未连接到主连通分量的孤立顶点）。\n2.  $G$ 中的每个顶点都有偶数度。\n\n我们现在将这两个条件应用于完全二分图 $K_{n,m}$。\n\n**1. $K_{n,m}$ 的连通性**\n\n设 $K_{n,m}$ 的顶点集为 $V = U \\cup W$，其中 $U$ 和 $W$ 是不相交的划分集合，且 $|U| = n$ 和 $|W| = m$。问题规定 $n \\ge 1$ 且 $m \\ge 1$。\n\n-   设 $v_1, v_2$ 是 $V$ 中的任意两个顶点。\n    -   如果 $v_1 \\in U$ 且 $v_2 \\in W$，那么根据完全二分图的定义，边 $\\{v_1, v_2\\}$ 存在。因此，它们通过一条长度为1的路径相连。\n    -   如果 $v_1, v_2$ 都在 $U$ 中（这要求 $n \\ge 2$），由于 $m \\ge 1$，存在至少一个顶点 $w \\in W$。路径 $v_1 - w - v_2$ 连接了 $v_1$ 和 $v_2$。\n    -   如果 $v_1, v_2$ 都在 $W$ 中（这要求 $m \\ge 2$），由于 $n \\ge 1$，存在至少一个顶点 $u \\in U$。路径 $v_1 - u - v_2$ 连接了 $v_1$ 和 $v_2$。\n\n由于任意一对顶点都由一条路径连接，因此对于所有 $n, m \\ge 1$，$K_{n,m}$ 都是连通的。所以，存在欧拉回路的第一个条件总是满足的。\n\n**2. $K_{n,m}$ 中的顶点度数**\n\n现在我们来考察顶点的度数。\n-   考虑任意顶点 $u \\in U$。根据 $K_{n,m}$ 的定义，该顶点与 $W$ 中的每个顶点相连，而不与 $U$ 中的任何顶点相连。由于 $|W| = m$，因此 $U$ 中任何顶点 $u$ 的度为 $\\text{deg}(u) = m$。\n-   类似地，考虑任意顶点 $w \\in W$。该顶点与 $U$ 中的每个顶点相连，而不与 $W$ 中的任何顶点相连。由于 $|U| = n$，因此 $W$ 中任何顶点 $w$ 的度为 $\\text{deg}(w) = n$。\n\n为了使 $K_{n,m}$ 存在欧拉回路，每个顶点都必须具有偶数度。这意味着：\n-   $U$ 中所有顶点的度必须是偶数。因此，$m$ 必须是偶数。\n-   $W$ 中所有顶点的度必须是偶数。因此，$n$ 必须是偶数。\n\n综合这些，一个完全二分图 $K_{n,m}$（其中 $n, m \\ge 1$）存在欧拉回路，当且仅当 $n$ 和 $m$ 都是偶数。\n\n### 选项评估\n\n现在，我们根据推导出的条件来评估每个选项。\n\n**A. $K_{n,m}$ 存在欧拉回路当且仅当 $n$ 和 $m$ 都是偶数（且 $n,m \\ge 1$）。**\n这个陈述与我们推导出的充分必要条件完全匹配。括号中的备注“且 $n,m \\ge 1$”与问题的设定一致。\n**结论：正确。**\n\n**B. $K_{n,m}$ 存在欧拉回路当且仅当 $n$ 和 $m$ 都是奇数且 $n=m$。**\n如果 $n$ 和 $m$ 都是奇数，那么大小为 $n$ 的划分中的每个顶点的度都是 $m$（奇数），大小为 $m$ 的划分中的每个顶点的度都是 $n$（奇数）。由于所有顶点的度都是奇数，这违反了所有顶点都必须有偶数度的条件。因此，不存在欧拉回路。\n**结论：不正确。**\n\n**C. $K_{n,m}$ 存在欧拉回路当且仅当 $n$ 和 $m$ 中一个为偶数，另一个为奇数。**\n不失一般性，假设 $n$ 是偶数，$m$ 是奇数。大小为 $n$ 的划分中的 $n$ 个顶点，每个的度都是 $m$（奇数）。大小为 $m$ 的划分中的 $m$ 个顶点，每个的度都是 $n$（偶数）。因为存在奇数度的顶点（具体来说，是一个划分中的所有 $n$ 个顶点），所以该图不存在欧拉回路。（当且仅当恰好有两个奇数度的顶点时，它会存在一条欧拉路径，这将要求 $n=2$。）\n**结论：不正确。**\n\n**D. $K_{n,m}$ 存在欧拉回路当且仅当 $n+m$ 是偶数（且 $n,m \\ge 1$）。**\n和 $n+m$ 是偶数，当且仅当 $n$ 和 $m$ 的奇偶性相同。这意味着它们要么都是偶数，要么都是奇数。\n-   如果 $n$ 和 $m$ 都是偶数，则存在欧拉回路。\n-   如果 $n$ 和 $m$ 都是奇数，如选项 B 的分析所示，不存在欧拉回路。\n由于这个条件包含了一个不存在欧拉回路的情况，所以它不是一个充分条件。因此，它不是一个精确的刻画。\n**结论：不正确。**\n\n**E. $K_{n,m}$ 存在欧拉回路当且仅当 $n=m$ 且 $n \\ge 2$。**\n这个条件既不充分也不必要。\n-   不充分：考虑 $n=m=3$。此时 $n$ 和 $m$ 都是奇数，所以所有顶点的度都是3。不存在欧拉回路。这是一个反例。\n-   不必要：考虑 $K_{2,4}$。此时 $n=2$ 且 $m=4$。两者都是偶数，所以存在欧拉回路。然而，$n \\ne m$。这是一个反例。\n**结论：不正确。**\n\n基于以上分析，只有选项 A 提供了正确的刻画。", "answer": "$$\\boxed{A}$$", "id": "3237299"}, {"introduction": "这个练习将我们带入极值图论的领域，提出了一个基本问题：一个包含 $n$ 个顶点且不含任何三角形的图，最多能有多少条边？回答这个问题不仅需要应用定理，更需要从第一性原理出发，推导出一个重要的结果。这个练习将展示施加一个“局部”约束（无三角形）如何对一个“全局”属性（总边数）产生深远的影响。[@problem_id:3237303]", "problem": "在有限、简单、无向图的研究中，围长是指最短圈的长度；一个图的围长至少为 4 当且仅当它不包含长度为 3 的圈，这等价于它是无三角形的。设$G$是任意一个具有$n$个顶点的无三角形图。仅使用邻接、度、三角形概念等核心定义，通过完整的推导确定最大可能边数（作为$n$的函数），该推导需要识别出一个极值结构并证明其最优性，且不引用任何已有的极值图论定理。你的最终答案必须是关于$n$的单个闭式表达式。无需四舍五入，也不涉及任何单位。", "solution": "问题要求一个具有$n$个顶点的有限、简单、无向、无三角形图$G$中可能的最大边数。如果一个图不包含长度为$3$的圈（记为$K_3$），则称该图是无三角形的。设$G=(V, E)$是这样一个图，其中$|V|=n$且$|E|=m$。我们将通过推导一个紧上界来确定$m$的最大值。\n\n首先，我们为$m$建立一个上界。设$\\{u, v\\}$是$E$中的任意一条边。设$N(x)$表示顶点$x$的开邻域，即与$x$邻接的所有顶点的集合。顶点$x$的度为$\\deg(x) = |N(x)|$。\n\n由于图$G$是无三角形的，因此不可能存在一个同时与$u$和$v$邻接的顶点$w$。如果存在这样的$w$，则顶点$\\{u, v, w\\}$将构成一个三角形。这直接意味着邻域$N(u)$和$N(v)$没有任何公共顶点。一个更精确的陈述是，$u$的邻点集合（不包括$v$）与$v$的邻点集合（不包括$u$）是不相交的。\n\n让我们将其形式化。考虑集合$N(u) \\setminus \\{v\\}$和$N(v) \\setminus \\{u\\}$。$G$的无三角形性质意味着$(N(u) \\setminus \\{v\\}) \\cap (N(v) \\setminus \\{u\\}) = \\emptyset$。\n\n现在，考虑顶点集合$S = \\{u\\} \\cup \\{v\\} \\cup (N(u) \\setminus \\{v\\}) \\cup (N(v) \\setminus \\{u\\})$。\n$u$和$v$是不同的顶点。$N(u) \\setminus \\{v\\}$中的顶点不是$u$或$v$。$N(v) \\setminus \\{u\\}$中的顶点不是$u$或$v$。如前所述，集合$N(u) \\setminus \\{v\\}$和$N(v) \\setminus \\{u\\}$是不相交的。因此，$S$定义中的四个组成集合是两两不相交的。\n$S$中不同顶点的总数是这些集合大小之和：\n$$|S| = |\\{u\\}| + |\\{v\\}| + |N(u) \\setminus \\{v\\}| + |N(v) \\setminus \\{u\\}|$$\n这些集合的基数分别为$|N(u) \\setminus \\{v\\}| = \\deg(u) - 1$和$|N(v) \\setminus \\{u\\}| = \\deg(v) - 1$。\n$$|S| = 1 + 1 + (\\deg(u) - 1) + (\\deg(v) - 1) = \\deg(u) + \\deg(v)$$\n由于$S$是$G$的一个顶点集，其大小不能超过顶点总数$n$。\n$$|S| \\le n \\implies \\deg(u) + \\deg(v) \\le n$$\n这个不等式对无三角形图$G$中的任何一对邻接顶点$\\{u, v\\}$都成立。\n\n我们现在可以对图中所有的边将此不等式求和：\n$$\\sum_{\\{u,v\\} \\in E} (\\deg(u) + \\deg(v)) \\le \\sum_{\\{u,v\\} \\in E} n = m \\cdot n$$\n左手边的项$\\sum_{\\{u,v\\} \\in E} (\\deg(u) + \\deg(v))$，可以通过考虑每个顶点的贡献来重写。一个顶点$w \\in V$是$\\deg(w)$条边的端点。对于每一条这样的边，它的度$\\deg(w)$被包含在和中。因此，项$\\deg(w)$在总和中出现了$\\deg(w)$次。这意味着：\n$$\\sum_{\\{u,v\\} \\in E} (\\deg(u) + \\deg(v)) = \\sum_{w \\in V} \\deg(w)^2$$\n结合这些结果，我们得到不等式：\n$$\\sum_{w \\in V} \\deg(w)^2 \\le mn$$\n现在，我们使用柯西-施瓦茨不等式将此与总边数$m$联系起来。设$\\mathbf{d} = (\\deg(v_1), \\deg(v_2), \\dots, \\deg(v_n))$和$\\mathbf{1} = (1, 1, \\dots, 1)$是$\\mathbb{R}^n$中的两个向量。柯西-施瓦茨不等式表述为$(\\mathbf{d} \\cdot \\mathbf{1})^2 \\le (\\mathbf{d} \\cdot \\mathbf{d}) (\\mathbf{1} \\cdot \\mathbf{1})$。\n$$ \\left(\\sum_{w \\in V} \\deg(w)\\right)^2 \\le \\left(\\sum_{w \\in V} \\deg(w)^2\\right) \\left(\\sum_{w \\in V} 1^2\\right) $$\n根据握手引理，度数之和是边数的两倍：$\\sum_{w \\in V} \\deg(w) = 2m$。$1$的平方和就是$n$。代入这些值得到：\n$$(2m)^2 \\le \\left(\\sum_{w \\in V} \\deg(w)^2\\right) \\cdot n$$\n$$4m^2 \\le n \\sum_{w \\in V} \\deg(w)^2$$\n我们现在有两个不等式：\n1. $\\sum_{w \\in V} \\deg(w)^2 \\le mn$\n2. $4m^2 \\le n \\sum_{w \\in V} \\deg(w)^2$\n\n将第一个不等式代入第二个，得到：\n$$4m^2 \\le n(mn) = mn^2$$\n如果$m > 0$，我们可以两边同除以$m$得到$4m \\le n^2$，这意味着$m \\le \\frac{n^2}{4}$。如果$m = 0$，该不等式自然成立。由于$m$必须是整数，我们有$m \\le \\lfloor \\frac{n^2}{4} \\rfloor$。这就为任意具有$n$个顶点的无三角形图的边数建立了一个上界。\n\n为了证明这个上界是可能达到的最优界，我们必须证明存在一个具有$n$个顶点和恰好$\\lfloor \\frac{n^2}{4} \\rfloor$条边的无三角形图。这个极值结构是完全二分图$K_{\\lfloor n/2 \\rfloor, \\lceil n/2 \\rceil}$。\n\n让我们构造这个图。将$n$个顶点的集合$V$划分为两个不相交的子集$A$和$B$，使得$|A| = \\lfloor \\frac{n}{2} \\rfloor$且$|B| = \\lceil \\frac{n}{2} \\rceil$。边集$E$被定义为包含$A$中每个顶点与$B$中每个顶点之间的边。同一划分内部的顶点之间不存在边。\n\n根据构造，这个图是二分图。二分图中的圈必须在两个顶点划分之间交替。一个圈要从同一个顶点出发并返回，必须经过偶数条边。因此，二分图中的所有圈都具有偶数长度。因此，该图不包含奇数长度的圈，特别是不包含长度为$3$的圈（三角形）。所以，$K_{\\lfloor n/2 \\rfloor, \\lceil n/2 \\rceil}$是无三角形的。\n\n该图中的边数是两个划分大小的乘积：\n$$m = |A| \\cdot |B| = \\left\\lfloor \\frac{n}{2} \\right\\rfloor \\left\\lceil \\frac{n}{2} \\right\\rceil$$\n我们根据$n$的奇偶性分两种情况进行分析。\n\n情况1：$n$是偶数。设$n = 2k$，其中$k$为某个整数。\n那么$|A| = \\lfloor \\frac{2k}{2} \\rfloor = k$且$|B| = \\lceil \\frac{2k}{2} \\rceil = k$。\n边数为$m = k \\cdot k = k^2 = \\left(\\frac{n}{2}\\right)^2 = \\frac{n^2}{4}$。\n由于$\\frac{n^2}{4}$是整数，这等于$\\lfloor \\frac{n^2}{4} \\rfloor$。\n\n情况2：$n$是奇数。设$n = 2k+1$，其中$k$为某个整数。\n那么$|A| = \\lfloor \\frac{2k+1}{2} \\rfloor = k$且$|B| = \\lceil \\frac{2k+1}{2} \\rceil = k+1$。\n边数为$m = k(k+1)$。\n代入$k = \\frac{n-1}{2}$，我们得到$m = \\left(\\frac{n-1}{2}\\right)\\left(\\frac{n-1}{2}+1\\right) = \\left(\\frac{n-1}{2}\\right)\\left(\\frac{n+1}{2}\\right) = \\frac{n^2-1}{4}$。\n这恰好是当$n$为奇数时$\\lfloor \\frac{n^2}{4} \\rfloor$的值。\n\n在两种情况下，我们都构造了一个具有$n$个顶点和恰好$\\lfloor \\frac{n^2}{4} \\rfloor$条边的无三角形图。既然我们已经证明了任何这样的图的边数都不可能超过这个值，并且我们找到了一个恰好拥有这个边数的图，那么可以得出结论，最大可能的边数是$\\lfloor \\frac{n^2}{4} \\rfloor$。", "answer": "$$\\boxed{\\left\\lfloor \\frac{n^2}{4} \\right\\rfloor}$$", "id": "3237303"}, {"introduction": "图论在解决现实世界计算问题时展现出其真正的力量。这个动手实践将挑战你连接理论与应用，设计一个数据结构来管理一个动态图。你的目标是高效地判断添加一条新边是否会形成一个环，这是网络分析和算法设计中的一个核心任务，它需要你将森林和连通分量的性质转化为一个优雅的算法解决方案。[@problem_id:3237184]", "problem": "给定一个无向图 $G = (V, E)$，其顶点集 $V$ 是一个有限集，标记为整数范围 $\\{0, 1, \\dots, n-1\\}$，以及一个初始指定的边集 $E$（可能为空）。该图通过提议添加形如 $(u, v)$（其中 $u, v \\in V$）的边而演变。您的任务是设计并实现一个完整的程序，该程序维护一个基于图属性的数据结构，以便在每次提议添加边时，都能高效地报告添加边 $(u, v)$ 是否会在当前无向图中创建一个环。\n\n您必须依赖的基础是以下定义和事实的集合：\n- 在无向图中，一条简单路径是一个由不同顶点组成的序列 $(x_0, x_1, \\dots, x_k)$，使得对于每个索引 $i$（$0 \\le i < k$），点对 $(x_i, x_{i+1})$ 都是图中的一条边。\n- 在无向图中，一个环是一条路径 $(x_0, x_1, \\dots, x_{k-1}, x_0)$（$k \\ge 3$），其顶点 $x_0, x_1, \\dots, x_{k-1}$ 除了首尾顶点重合外均不相同；按照惯例，添加自环 $(u, u)$ 被认为会立即创建一个环。\n- 一个连通分量是一个极大的顶点集合，其中集合内的任意一对顶点都通过某条路径相连。\n- 树是一个连通的无向无环图，而森林是树的不交并集。\n\n您的程序必须实现一个数据结构，能够为每个提议的边 $(u, v)$ 判断添加该边是否会创建一个环。该判断必须严格基于图随接受的边添加而演变时的连通性这一图论属性。程序必须假定每个提议的边都是无向的。如果添加 $(u, v)$ 会创建一个环，程序必须为该提议输出布尔值 $\\texttt{True}$；否则，程序必须输出 $\\texttt{False}$，并将 $(u, v)$ 合并到数据结构中以备后用。自环 $(u, u)$ 总是产生 $\\texttt{True}$。\n\n您的程序必须使用以下测试套件，其中每个测试用例由 $(n, E_{\\text{init}}, E_{\\text{add}})$ 组成：\n- 测试用例 A (一般情况):\n  - $n = 5$\n  - $E_{\\text{init}} = \\emptyset$\n  - $E_{\\text{add}} = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]$\n- 测试用例 B (合并连通分量然后闭合一个环):\n  - $n = 4$\n  - $E_{\\text{init}} = [(0, 1), (2, 3)]$\n  - $E_{\\text{add}} = [(1, 2), (0, 2), (1, 3)]$\n- 测试用例 C (自环和重复连接):\n  - $n = 3$\n  - $E_{\\text{init}} = \\emptyset$\n  - $E_{\\text{add}} = [(0, 0), (1, 2), (2, 1)]$\n- 测试用例 D (单个顶点的边界情况):\n  - $n = 1$\n  - $E_{\\text{init}} = \\emptyset$\n  - $E_{\\text{add}} = [(0, 0), (0, 0)]$\n\n对于每个测试用例，您的程序必须按照 $E_{\\text{add}}$ 的顺序输出一个布尔值列表，其中每个布尔值指示在提议时对应的边的添加是否会创建一个环。您的程序应生成单行输出，其中包含所有给定测试用例的聚合结果，这些结果形成一个用方括号括起来的、逗号分隔的列表，每个测试用例的列表都包含在各自的方括号内，且没有空格。例如，两个测试用例的结果为 $\\texttt{[True,False]}$ 和 $\\texttt{[False]}$ 的聚合结果必须精确地打印为 $\\texttt{[[True,False],[False]]}$。\n\n所有答案都是纯布尔值，不涉及物理单位。本问题不出现角度和百分比。该程序必须是一个完整的、可运行的程序，不得从标准输入或文件中读取输入；它必须能够直接运行并打印指定的单行输出。", "solution": "需要采用正式的表述，将算法与问题陈述中阐述的图论原理直接联系起来。使用并查集 (Disjoint Set Union, DSU) 数据结构是关键的洞察。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass UnionFind:\n    \"\"\"\n    An implementation of the Union-Find (Disjoint Set Union) data structure.\n\n    This data structure keeps track of a set of elements partitioned into a\n    number of disjoint (non-overlapping) subsets. It provides two main\n    operations: find, which determines which subset an element is in, and\n    union, which joins two subsets into a single subset.\n\n    This implementation uses two standard optimizations for near-constant time\n    amortized performance:\n    1. Union by Rank: When merging two sets, the root of the shorter tree\n       is made a child of the root of the taller tree. This keeps the trees\n       from becoming too deep.\n    2. Path Compression: During a find operation, the path from the element\n       to the root is flattened, making future finds faster.\n    \"\"\"\n    def __init__(self, n):\n        \"\"\"\n        Initializes the Union-Find structure for n elements.\n        Each element from 0 to n-1 starts in its own set.\n        \n        Args:\n            n (int): The number of elements.\n        \"\"\"\n        # parent[i] stores the parent of element i.\n        self.parent = np.arange(n)\n        # rank[i] stores the height of the tree rooted at i.\n        self.rank = np.zeros(n, dtype=int)\n\n    def find(self, i):\n        \"\"\"\n        Finds the representative (root) of the set containing element i.\n        Implements path compression.\n        \n        Args:\n            i (int): The element to find.\n        \n        Returns:\n            int: The representative of the set.\n        \"\"\"\n        if self.parent[i] == i:\n            return i\n        # Path compression: set the parent of i directly to the root.\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        \"\"\"\n        Merges the sets containing elements i and j.\n        Implements union by rank.\n        \n        Args:\n            i (int): The first element.\n            j (int): The second element.\n        \"\"\"\n        root_i = self.find(i)\n        root_j = self.find(j)\n        \n        if root_i != root_j:\n            # Union by rank\n            if self.rank[root_i]  self.rank[root_j]:\n                self.parent[root_i] = root_j\n            elif self.rank[root_i]  self.rank[root_j]:\n                self.parent[root_j] = root_i\n            else:\n                self.parent[root_j] = root_i\n                self.rank[root_i] += 1\n\n\ndef solve():\n    \"\"\"\n    Solves the cycle detection problem for a series of test cases.\n    For each test case, it processes initial and proposed edge additions,\n    reporting for each proposed edge whether its addition would create a cycle.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case A (general case)\n        (5, [], [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]),\n        # Test case B (merging components then closing a cycle)\n        (4, [(0, 1), (2, 3)], [(1, 2), (0, 2), (1, 3)]),\n        # Test case C (self-loop and repeated connection)\n        (3, [], [(0, 0), (1, 2), (2, 1)]),\n        # Test case D (single vertex boundary)\n        (1, [], [(0, 0), (0, 0)]),\n    ]\n\n    all_results = []\n    \n    for n, E_init, E_add in test_cases:\n        # Initialize Union-Find data structure for n vertices.\n        uf = UnionFind(n)\n        \n        # Process the initial set of edges to establish the starting graph state.\n        for u, v in E_init:\n            uf.union(u, v)\n        \n        case_results = []\n        # Process each proposed edge addition.\n        for u, v in E_add:\n            # According to the problem, a self-loop (u, u) always creates a cycle.\n            if u == v:\n                case_results.append(True)\n                # The state of the graph does not change for a rejected edge.\n                continue\n\n            # Check if u and v are already in the same connected component.\n            # If find(u) == find(v), they are, and adding edge (u, v) creates a cycle.\n            if uf.find(u) == uf.find(v):\n                case_results.append(True)\n            else:\n                # If they are in different components, adding the edge does not create a cycle.\n                case_results.append(False)\n                # The edge is added to the graph, so we merge the components.\n                uf.union(u, v)\n        \n        all_results.append(case_results)\n\n    # Format the final output string as specified.\n    # e.g., [[False,False,True],[False,True]]\n    output_str = f\"[{','.join([str(res).replace(' ', '') for res in all_results])}]\"\n    print(output_str.replace(\"True\", \"true\").replace(\"False\", \"false\"))\n\nsolve()\n```", "id": "3237184"}]}