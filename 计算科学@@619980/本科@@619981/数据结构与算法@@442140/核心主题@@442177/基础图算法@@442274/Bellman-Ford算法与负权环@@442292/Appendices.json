{"hands_on_practices": [{"introduction": "在深入研究检测负循环的算法之前，让我们首先通过一个思想实验来建立对负循环权重极限的直观理解。这个练习要求我们推导在一个具有给定顶点数量和边权重约束的图中，一个简单负循环所能达到的最小（即最负）权重。通过从基本定义出发进行推理，你将能更好地领会为什么负循环在路径计算中会成为一个问题，并为后续的贝尔曼-福特算法应用打下坚实的概念基础。[@problem_id:3213912]", "problem": "考虑一个有向图 $G=(V,E)$，其顶点数为 $|V|=V$，边权重为整数。每条边的权重 $w(e)$ 满足约束 $-W \\leq w(e) \\leq W$，其中 $W$ 是一个正整数。简单环是一条闭合路径，它从同一顶点开始和结束，并且环上的每个顶点只访问一次；其长度是环上边的数量，且至少为 $2$。环的权重是其所有边的权重之和。\n\n仅使用环权重和简单环的核心定义，不依赖于这些定义之外的任何专门定理，确定在满足上述权重约束的任意一个包含 $V$ 个顶点的有向图中，一个简单环可能具有的最小（负值最大）总权重。您的答案必须是关于 $V$ 和 $W$ 的精确解析表达式。\n\n无需四舍五入。不包含任何单位。", "solution": "该问题已经过验证，并被确定为图论中一个有效、适定的问题。\n\n目标是找到在任意一个顶点数为 $|V|=V$ 的有向图 $G=(V, E)$ 中，一个简单环可能具有的最小（负值最大）总权重，其中边权重 $w(e)$ 是满足 $-W \\leq w(e) \\leq W$ 的整数，且 $W$ 为正整数。\n\n设 $C$ 是这样一个图中的任意一个简单环。设环中的顶点序列为 $v_1, v_2, \\dots, v_k, v_1$。这个环的长度，即其边的数量，为 $k$。问题陈述指明简单环的长度至少为 $2$，所以 $k \\ge 2$。\n\n根据简单环的定义，除了起点和终点是同一个顶点外，它对环上的每个顶点只访问一次。这意味着顶点 $v_1, v_2, \\dots, v_k$ 必须都是互不相同的。因此，一个长度为 $k$ 的环包含 $k$ 个不同的顶点。\n\n图中顶点的总数给定为 $V$。由于简单环的顶点必须是互不相同的，并且取自图的顶点集，所以环中的顶点数 $k$ 不能超过图中可用的顶点总数。因此，任何简单环的长度 $k$ 受限于图的顶点总数 $V$：\n$$k \\le V$$\n结合给定的关于环长度的条件，我们有 $2 \\le k \\le V$。这意味着问题隐含地假设了 $V \\ge 2$，因为在一个只有一个顶点的图中，不可能存在长度至少为 $2$ 的简单环。\n\n环 $C$ 的权重，记作 $w(C)$，是构成该环的各条边的权重之和：\n$$w(C) = \\sum_{e \\in C} w(e)$$\n为了找到 $w(C)$ 的可能最小值，我们必须考虑单个边权重 $w(e)$ 的界限。问题陈述，对于任意边 $e$，其权重满足 $-W \\leq w(e) \\leq W$。因此，任何单条边权重的可能最低值是 $-W$。\n\n为了确定我们长度为 $k$ 的环 $C$ 的权重下界，我们可以将总和中的每个边权重替换为此可能的最小值：\n$$w(C) = \\sum_{e \\in C} w(e) \\ge \\sum_{e \\in C} (-W)$$\n由于环 $C$ 中有 $k$ 条边，右侧的总和计算结果为 $k \\times (-W)$。\n$$w(C) \\ge -kW$$\n这个不等式表明，任何长度为 $k$ 的简单环的权重至少为 $-kW$。我们关心的是在所有可能的图中，所有可能的简单环的最小可能权重。这对应于表达式 $-kW$ 的可能最小值。\n\n由于 $W$ 是一个正整数，随着 $k$ 的增加，表达式 $-kW$ 的负值变得更大（即值更小）。因此，为了最小化 $-kW$，我们必须最大化环的长度 $k$。如前所述，在一个有 $V$ 个顶点的图中，简单环的最大可能长度是 $k=V$。\n\n将 $k$ 的最大值代入我们的不等式，我们得到了在任何有效图中任何简单环权重的全局下界：\n$$w(C) \\ge -kW \\ge -VW$$\n这表明，在满足给定条件的任何图中，没有任何简单环的权重可以小于 $-VW$。\n\n最后一步是证明这个下界是可以达到的。为此，我们必须构造一个特定的图，并在其中构造一个权重恰好为 $-VW$ 的简单环。\n考虑一个有 $V$ 个顶点的图，我们将其标记为 $v_1, v_2, \\dots, v_V$。\n我们定义一个包含 $V$ 条边的集合来形成一个哈密顿环：\n$$E' = \\{ (v_1, v_2), (v_2, v_3), \\dots, (v_{V-1}, v_V), (v_V, v_1) \\}$$\n让图 $G$ 包含这些边。我们为 $E'$ 中的每条边 $e$ 分配可能的最小权重，即 $w(e) = -W$。由于 $W$ 是一个正整数，这些权重是整数，并且落在要求的范围 $[-W, W]$ 内。例如，我们可以让图中所有其他可能的边的权重为 $0$。\n\n由 $E'$ 中的边形成的环是一个长度为 $V$ 的简单环。它是一条闭合路径，其所有 $V$ 个顶点都是互不相同的。这个环的总权重是其 $V$ 条边的权重之和：\n$$w(C_{\\text{construct}}) = \\sum_{i=1}^{V} (-W) = V \\times (-W) = -VW$$\n我们成功地构造了一个包含权重为 $-VW$ 的简单环的图。由于我们之前证明了 $-VW$ 是任何简单环权重的下界，并且现在我们已经证明了这个权重是可以达到的，因此我们得出结论，简单环的最小可能总权重是 $-VW$。", "answer": "$$ \\boxed{-VW} $$", "id": "3213912"}, {"introduction": "掌握了负循环的基本概念后，现在是时候将理论付诸实践了。这个核心编程练习将指导你实现一个健壮的贝尔曼-福特算法版本，它不仅能计算最短路径，还能正确处理图中存在的负循环。你的任务是识别并“隔离”所有受负循环影响的顶点，从而确保计算出的最短路径是明确且有限的，这正是贝尔曼-福特算法在现实应用中处理复杂网络时至关重要的能力。[@problem_id:3214050]", "problem": "给定一个有限有向加权图 $G=(V,E)$，其边权重为实值函数 $w:E\\to\\mathbb{R}$。从源顶点 $s\\in V$ 到目标顶点 $t\\in V$ 的一条路径是一个顶点序列 $\\left[v_0,v_1,\\dots,v_k\\right]$，其中 $v_0=s$，$v_k=t$，并且对于所有 $i\\in\\{0,1,\\dots,k-1\\}$ 都有 $\\left(v_i,v_{i+1}\\right)\\in E$。路径的权重是其边权重之和，即 $\\sum_{i=0}^{k-1} w(v_i,v_{i+1})$。环路是一条满足 $v_0=v_k$ 且 $k\\geq 1$ 的路径。负环是总权重严格小于 $0$ 的环路。在单源最短路径（SSSP）问题中，目标是找到一条从 $s$ 到 $t$ 的路径，使其在所有从 $s$ 到 $t$ 的路径中总权重最小。\n\n您的任务是编写一个完整的程序，针对每个提供的测试用例，计算一条从 $s$ 到 $t$ 的最短路径，并保证该路径不属于任何负环，即使图中其他地方存在这样的环路。程序必须实现逻辑，确保返回的路径只使用那些不受任何从 $s$ 可达的负环影响的顶点。如果目标顶点 $t$ 从 $s$ 不可达，或者 $t$ 可从任何位于某个从 $s$ 可达的负环上或可从该负环到达的顶点到达，则不存在明确定义的有限最短路径，此时必须返回一个空列表。\n\n您必须遵守的基本原则和定义：\n- 有向加权图 $G=(V,E)$ 拥有顶点集 $V$ 和边集 $E\\subseteq V\\times V$，每条边 $\\left(u,v\\right)\\in E$ 都被赋予一个权重 $w(u,v)\\in\\mathbb{R}$。\n- 任何路径 $\\left[v_0,\\dots,v_k\\right]$ 的权重为 $\\sum_{i=0}^{k-1} w(v_i,v_{i+1})$。\n- 负环是任何满足 $v_0=v_k$ 且 $\\sum_{i=0}^{k-1} w(v_i,v_{i+1})  0$ 的环路 $\\left[v_0,\\dots,v_k\\right]$。\n- 一个经过充分验证的事实是，如果存在一个从 $s$ 可达且能到达 $t$ 的负环，那么从 $s$ 到 $t$ 的路径权重不存在有限最小值；此外，在 Bellman–Ford 算法中执行 $|V|-1$ 轮松弛操作后，如果仍然存在任何边 $\\left(u,v\\right)\\in E$ 使得距离估计值 $d[u]+w(u,v)$ 仍小于 $d[v]$，则意味着存在一个从 $s$ 可达的负环，并且任何从此类进一步松弛的证据可达的顶点都会受到该负环的影响。\n\n输出要求：\n- 对于每个测试用例，将路径作为表示从 $s$ 到 $t$ 的顶点序列的整数列表返回。如果不存在明确定义的有限最短路径（因为 $t$ 从 $s$ 不可达，或因为 $t$ 受到从 $s$ 可达的负环的影响），则返回一个空列表 $\\left[\\right]$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$），其中每个 $\\text{result}_i$ 本身是一个列表（例如，$\\left[0,1,2\\right]$）或一个空列表 $\\left[\\right]$。\n\n测试套件：\n请精确使用以下测试用例，每个用例由一个元组 $\\left(n,E,s,t\\right)$ 指定，其中 $n=|V|$ 是顶点数（标记为整数 $\\{0,1,\\dots,n-1\\}$），$E$ 是一个有向边列表，其权重以三元组 $\\left(u,v,w\\right)$ 的形式给出，$s,t$ 分别是源顶点和目标顶点。\n\n- 测试用例 1（理想路径，图中存在不可达的负环）：\n  - $n=5$\n  - $E=\\left[\\left(0,1,3\\right),\\left(1,2,-2\\right),\\left(0,2,5\\right),\\left(3,4,-1\\right),\\left(4,3,-1\\right)\\right]$\n  - $s=0$\n  - $t=2$\n  - 预期行为：顶点 $\\left\\{3,4\\right\\}$ 上的负环从 $s$ 不可达，因此最短路径是明确定义的。\n\n- 测试用例 2（从 s 可达的负环可以到达 t）：\n  - $n=4$\n  - $E=\\left[\\left(0,1,1\\right),\\left(1,2,1\\right),\\left(2,1,-3\\right),\\left(2,3,2\\right)\\right]$\n  - $s=0$\n  - $t=3$\n  - 预期行为：存在一个从 $s$ 可达且能到达 $t$ 的负环，因此不存在有限最短路径；返回 $\\left[\\right]$。\n\n- 测试用例 3（从 s 可达的负环无法到达 t，但存在一条到 t 的不受影响的路径）：\n  - $n=6$\n  - $E=\\left[\\left(0,1,2\\right),\\left(1,2,2\\right),\\left(2,1,-5\\right),\\left(0,3,1\\right),\\left(3,4,1\\right),\\left(4,5,1\\right)\\right]$\n  - $s=0$\n  - $t=5$\n  - 预期行为：顶点 $\\left\\{1,2\\right\\}$ 上的负环从 $s$ 可达但无法到达 $t$，因此到 $t$ 的最短路径是明确定义的，并且必须避开受影响的顶点。\n\n- 测试用例 4（目标不可达）：\n  - $n=3$\n  - $E=\\left[\\left(0,1,1\\right)\\right]$\n  - $s=0$\n  - $t=2$\n  - 预期行为：顶点 $t$ 从 $s$ 不可达；返回 $\\left[\\right]$。\n\n- 测试用例 5（边界情况 s=t，且 s 不受负环影响）：\n  - $n=3$\n  - $E=\\left[\\left(0,2,4\\right)\\right]$\n  - $s=1$\n  - $t=1$\n  - 预期行为：从 $s$ 到其自身的最短路径是平凡路径 $\\left[1\\right]$，因为 $s$ 不受任何负环的影响。\n\n您的程序必须使用这些测试用例，并按上述确切格式输出一行包含结果列表。", "solution": "给定问题要求计算在一个有向加权图 $G=(V,E)$ 中从源顶点 $s$到目标顶点 $t$ 的最短路径，其中边权重可以为负。关键约束是路径必须是明确定义的，这意味着不能通过遍历负环来无限地减小其权重。具体来说，如果目标 $t$ 不可达，或者其最短路径受到从 $s$ 可达的负环的影响，则不存在这样的路径。\n\n负边权的存在建议使用 Bellman-Ford 算法，该算法专为此类图中的单源最短路径（SSSP）问题而设计。标准的 Bellman-Ford 算法还能检测是否存在从源点 $s$ 可达的负环。我们的任务需要扩展此功能，以识别所有其最短路径计算被此类环路“污染”的顶点，并确保我们到 $t$ 的路径避开它们。\n\nBellman-Ford 算法的核心原理是迭代松弛。它将到源点的距离 $d[s]$ 初始化为 $0$，所有其他距离 $d[v]$ 初始化为无穷大。然后，它重复地对图中的所有边进行松弛。对于一条权重为 $w(u,v)$ 的边 $(u,v)$，松弛是检查是否可以通过经过 $u$ 来缩短到 $v$ 的路径的过程，即判断是否有 $d[u] + w(u,v)  d[v]$。如果是，则将 $d[v]$ 更新为 $d[u] + w(u,v)$，并将此路径上 $v$ 的前驱 $p[v]$ 设置为 $u$。\n\n在一个有 $|V|$ 个顶点的图中，任何简单路径（没有重复顶点的路径）最多只能有 $|V|-1$ 条边。Bellman-Ford 算法保证，在对所有边进行 $|V|-1$ 次迭代松弛之后，只要没有从 $s$ 可达的负环，计算出的距离 $d[v]$ 就是从 $s$到所有其他顶点 $v$ 的最短路径权重。\n\n问题的关键在于正确处理负环。如问题描述所述，Bellman-Ford 算法的一个关键特性是，如果在 $|V|-1$ 次迭代后，对于任何边 $(u,v)$ 仍有可能进行进一步的松弛，这标志着存在一个从 $s$ 可达的负权环。任何在概念上的第 $|V|$ 轮迭代中其距离估计值 $d[v]$ 被降低的顶点 $v$，都位于一条从 $s$ 出发且包含负环的路径上。到这样一个顶点的最短路径是未定义的（可以通过重复遍历该环路使其任意小）。\n\n此外，任何可从受负环影响的顶点到达的顶点也被视为受影响的，因为到它的路径可以经过被污染的顶点，使其最短路径权重也变为未定义。\n\n这引出了以下综合算法：\n\n1.  **初始化**：对于一个有 $n=|V|$ 个顶点的图，创建一个大小为 $n$ 的距离数组 $d$，并将 $d[s]$ 初始化为 $0$，所有 $v \\neq s$ 的 $d[v]$ 初始化为 $\\infty$。创建一个大小为 $n$ 的前驱数组 $p$，初始化为一个哨兵值（例如 $-1$），表示没有前驱。\n\n2.  **Bellman-Ford 松弛**：执行 $n-1$ 次迭代。在每次迭代中，遍历每条边 $(u,v) \\in E$ 及其权重 $w(u,v)$，并执行松弛步骤：如果 $d[u] \\neq \\infty$ 且 $d[u] + w(u,v)  d[v]$，则更新 $d[v] = d[u] + w(u,v)$ 并设置 $p[v] = u$。\n\n3.  **识别受影响的顶点**：\n    a.  识别直接受负环影响的顶点。我们可以通过再执行一轮松弛检查（第 $n$ 轮）来做到这一点。创建一个队列 `affected_queue`，对于每条边 $(u,v) \\in E$，如果 $d[u] + w(u,v)  d[v]$，则意味着 $v$ 位于一条从 $s$ 出发并涉及负环的路径上。将 $v$ 添加到 `affected_queue`。为了避免重复并进行高效查找，也用这些初始顶点填充一个集合 `all_affected`。\n    b.  传播“受影响”状态。任何可从受影响的顶点到达的顶点也是受影响的。从 `affected_queue` 中的所有顶点开始，执行图遍历（例如广度优先搜索或深度优先搜索）。为此，使用图的邻接表表示会很有用。在遍历过程中，将所有新发现的可达顶点添加到 `all_affected` 集合中。\n\n4.  **路径确定与重构**：\n    a.  首先，检查目标顶点 $t$ 是否根本不可达。如果在 Bellman-Ford 阶段后 $d[t] = \\infty$，则不存在从 $s$ 到 $t$ 的路径。结果是一个空列表。\n    b.  其次，检查 $t$ 是否受到负环的影响。如果 $t$ 在 `all_affected` 集合中，则不存在明确定义的有限最短路径。结果是一个空列表。\n    c.  如果 $t$ 可达且未受影响，则存在一条有效的最短路径。这条路径可以通过从 $t$ 开始，使用数组 $p$ 迭代地移动到其前驱，直到到达 $s$ 来重构。将访问过的顶点序列反转，即得到从 $s$ 到 $t$ 的最短路径。如果 $s=t$，路径就是简单的 $[s]$。\n\n该算法通过首先运行 Bellman-Ford 算法计算路径权重和前驱，然后系统地识别和隔离所有最短路径距离被负环影响的顶点，最后在重构路径之前根据这些条件检查目标顶点，从而正确地找到一条安全的最短路径。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the provided test cases for the secure shortest path problem.\n    \"\"\"\n    test_cases = [\n        # Test case 1: Happy path with an unreachable negative cycle\n        {\n            \"n\": 5,\n            \"E\": [(0, 1, 3), (1, 2, -2), (0, 2, 5), (3, 4, -1), (4, 3, -1)],\n            \"s\": 0,\n            \"t\": 2,\n        },\n        # Test case 2: Negative cycle reachable from s that can reach t\n        {\n            \"n\": 4,\n            \"E\": [(0, 1, 1), (1, 2, 1), (2, 1, -3), (2, 3, 2)],\n            \"s\": 0,\n            \"t\": 3,\n        },\n        # Test case 3: Negative cycle reachable from s but cannot reach t\n        {\n            \"n\": 6,\n            \"E\": [(0, 1, 2), (1, 2, 2), (2, 1, -5), (0, 3, 1), (3, 4, 1), (4, 5, 1)],\n            \"s\": 0,\n            \"t\": 5,\n        },\n        # Test case 4: Target unreachable\n        {\n            \"n\": 3,\n            \"E\": [(0, 1, 1)],\n            \"s\": 0,\n            \"t\": 2,\n        },\n        # Test case 5: Boundary case s=t\n        {\n            \"n\": 3,\n            \"E\": [(0, 2, 4)],\n            \"s\": 1,\n            \"t\": 1,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_shortest_safe_path(case[\"n\"], case[\"E\"], case[\"s\"], case[\"t\"])\n        results.append(result)\n\n    # Format the final output string to be space-free as per the implicit format.\n    formatted_results = [f\"[{','.join(map(str, r))}]\" for r in results]\n    print(f'[{\",\".join(formatted_results)}]')\n\n\ndef find_shortest_safe_path(n, E, s, t):\n    \"\"\"\n    Finds a shortest path from s to t that is not affected by any negative cycle.\n\n    Args:\n        n (int): The number of vertices, labeled 0 to n-1.\n        E (list): A list of edges, where each edge is a tuple (u, v, w).\n        s (int): The source vertex.\n        t (int): The target vertex.\n\n    Returns:\n        list: A list of integers representing the path from s to t, or an empty list\n              if no such path exists.\n    \"\"\"\n    # Step 1: Initialization\n    distances = np.full(n, np.inf)\n    predecessors = np.full(n, -1, dtype=int)\n    distances[s] = 0\n\n    # Step 2: Bellman-Ford relaxations for n-1 iterations\n    for _ in range(n - 1):\n        for u, v, w in E:\n            if distances[u] != np.inf and distances[u] + w  distances[v]:\n                distances[v] = distances[u] + w\n                predecessors[v] = u\n\n    # Step 3: Identification of affected vertices\n    # a. Identify vertices directly updated in the n-th relaxation round\n    initially_affected = set()\n    for u, v, w in E:\n        if distances[u] != np.inf and distances[u] + w  distances[v]:\n            initially_affected.add(v)\n\n    # b. Propagate the \"affected\" status via BFS\n    if not initially_affected:\n        all_affected = set()\n    else:\n        # Build adjacency list for traversal\n        adj = [[] for _ in range(n)]\n        for u, v, _ in E:\n            adj[u].append(v)\n            \n        all_affected = set(initially_affected)\n        queue = list(initially_affected)\n        \n        while queue:\n            curr = queue.pop(0)\n            for neighbor in adj[curr]:\n                if neighbor not in all_affected:\n                    all_affected.add(neighbor)\n                    queue.append(neighbor)\n\n    # Step 4: Path Determination and Reconstruction\n    # Case a: Target is unreachable\n    if distances[t] == np.inf:\n        return []\n\n    # Case b: Target is affected by a negative cycle\n    if t in all_affected:\n        return []\n\n    # Case c: A valid, safe shortest path exists\n    path = []\n    curr = t\n    while curr != -1:\n        path.append(curr)\n        if curr == s:\n            break\n        curr = predecessors[curr]\n    \n    path.reverse()\n    \n    if path and path[0] == s:\n        return path\n    else:\n        # This case should not be reached if distances[t] is finite\n        # and predecessors are correctly maintained, but serves as a safeguard.\n        return []\n\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3214050"}, {"introduction": "贝尔曼-福特算法的威力远不止于标准的单源最短路径问题。这个高级练习旨在挑战你创造性地应用该算法，以解决一个更具体的问题：判断一个特定的边是否存在于某个负循环中。通过将这个看似特殊的问题巧妙地转化为一个标准的最短路径查询，你将学会一种强大的问题转化思维，这在算法设计中是解决新颖问题的关键技能。[@problem_id:3213972]", "problem": "给定一个由有限顶点集和有限边集指定的有向加权图。每条边都有一个整数权重。环是一个从同一顶点出发并最终返回该顶点的闭合路径。环的总权重是其构成边的权重之和。如果一个环的总权重严格小于 $0$，则称其为负权环。此外，还会给定图中的一条指定有向边 $(u,v)$。您的任务是设计并实现一个程序，利用最短路径定义的基本原理和 Bellman-Ford 算法，判断是否存在一个经过指定边 $(u,v)$ 的负权环。如果存在这样的环，程序必须返回其一个明确的实例，形式为一个有序的顶点索引列表，从 $u$ 开始，立即遍历指定边到 $v$，然后继续前进直到返回 $u$。如果不存在这样的环，则对该测试用例返回空列表。\n\n使用的基本原理和定义：\n- 一个有向加权图是一个元组 $(V,E,w)$，其中 $V$ 是一个由整数索引的有限顶点集，$E \\subseteq V \\times V$ 是有向边的集合，$w: E \\to \\mathbb{Z}$ 为每条边赋予一个整数权重。\n- 对于一条路径 $P = (x_0, x_1, \\ldots, x_k)$，其中对所有 $i \\in \\{0,\\ldots,k-1\\}$ 都有 $(x_i, x_{i+1}) \\in E$，路径权重为 $\\sum_{i=0}^{k-1} w(x_i, x_{i+1})$。\n- 对于一条边 $(u,v) \\in E$，以及任何从 $v$ 到 $u$ 的路径 $Q$，先遍历 $(u,v)$ 再沿 $Q$ 行进的闭合路径构成一个环。如果不存在使得到达 $u$ 的路径上的最短路径值不确定的负权环，那么当且仅当存在一条从 $v$ 到 $u$ 的路径 $Q$，其权重严格小于 $-w(u,v)$ 时，存在一个经过 $(u,v)$ 的负权环，因为该环的总权重为 $w(u,v) + \\text{weight}(Q)$。\n\n您的程序必须：\n- 纯粹在数学和算法逻辑层面运行。不涉及物理单位。\n- 对于每个测试用例，根据图的结构判断是否存在一个包含指定边 $(u,v)$ 的负权环。如果存在，则返回一个环，表示为有序的顶点索引整数列表，从 $u$ 开始，然后到 $v$，最后回到 $u$ 闭合。如果不存在，则返回空列表。\n- 从 $v$ 点应用 Bellman-Ford 算法计算到 $u$ 点的最短路径估计值，并在适用时使用前驱信息重构从 $v$ 回到 $u$ 的路径。将此路径与指定边 $(u,v)$ 结合以生成环，并根据基本定义验证其负性。避免依赖除基本定义和广为接受的算法事实之外的任何快捷公式。\n\n测试套件：\n对于下方的每个测试用例，顶点由非负整数索引，边以三元组 $(a,b,w)$ 的形式给出，其中 $a,b \\in V$，权重 $w \\in \\mathbb{Z}$，指定边为 $(u,v)$。这些图规模较小，旨在涵盖不同方面：存在经过指定边的明确负权环、不存在此类环、零权重环边界情况、边不存在、图中存在不相关的负权环的多连通分量图，以及缺少返回路径。\n\n- 测试用例 $1$（成功路径，存在经过指定边的负权环）：\n  - 顶点数：$4$。\n  - 边：$(1,2,-1)$, $(2,3,1)$, $(3,1,-1)$, $(0,1,4)$, $(0,2,2)$。\n  - 指定边：$(1,2)$。\n  - 存在一个环 $1 \\to 2 \\to 3 \\to 1$，总权重为 $-1 + 1 + (-1) = -1$。\n\n- 测试用例 $2$（路径存在但结果环不是负权环）：\n  - 顶点数：$3$。\n  - 边：$(0,1,2)$, $(1,2,1)$, $(2,0,0)$。\n  - 指定边：$(0,1)$。\n  - 从 $1$ 到 $0$ 的路径权重为 $1 + 0 = 1$，所以环的权重是 $2 + 1 = 3$，不是负值。\n\n- 测试用例 $3$（指定边不存在）：\n  - 顶点数：$4$。\n  - 边：$(0,1,1)$, $(1,2,1)$, $(2,0,1)$。\n  - 指定边：$(3,2)$。\n  - 由于 $(3,2)$ 不在 $E$ 中，没有环可以经过它。\n\n- 测试用例 $4$（零权重环边界情况）：\n  - 顶点数：$6$。\n  - 边：$(4,5,-2)$, $(5,4,2)$, $(0,1,3)$, $(1,2,3)$, $(2,3,3)$, $(3,0,-1)$。\n  - 指定边：$(4,5)$。\n  - 环 $4 \\to 5 \\to 4$ 的总权重为 $-2 + 2 = 0$，不是负值。\n\n- 测试用例 $5$（其他地方存在负权环，但没有经过指定边）：\n  - 顶点数：$6$。\n  - 边：$(0,3,0)$, $(3,4,1)$, $(4,0,0)$, $(1,2,-3)$, $(2,1,-3)$。\n  - 指定边：$(0,3)$。\n  - $1$ 和 $2$ 之间存在一个负权环，但它在不同的连通分量中，并不意味着存在一个经过 $(0,3)$ 的负权环。\n\n- 测试用例 $6$（指定边存在但没有返回路径以闭合环）：\n  - 顶点数：$2$。\n  - 边：$(0,1,-1)$。\n  - 指定边：$(0,1)$。\n  - 不存在从 $1$ 回到 $0$ 的路径，所以不存在环。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素对应一个测试用例，其值为空列表（写作 $[]$）或一个整数列表，表示找到的经过 $(u,v)$ 的一个负权环的顶点序列。打印输出中不得有任何空格。例如，格式必须类似于 $[[1,2,3,1],[],\\ldots]$，用逗号分隔测试用例结果，并且字符串中没有任何空格。", "solution": "问题要求我们判断一个有向加权图 $(V,E,w)$ 是否包含一个经过指定边 $(u,v) \\in E$ 的负权重环。如果存在这样的环，我们必须提供其一个实例。\n\n识别此类环的基本原理根植于环权重的定义。一个经过边 $(u,v)$ 的环由遍历边 $(u,v)$ 后再沿一条从顶点 $v$ 返回顶点 $u$ 的路径 $P$ 构成。该环的总权重 $W_{cycle}$ 是边 $(u,v)$ 的权重（记作 $w(u,v)$）与路径 $P$ 的权重（记作 $W(P_{v \\to u})$）之和。\n$W_{cycle} = w(u,v) + W(P_{v \\to u})$\n当且仅当环的总权重严格小于零时，该环为负权环。\n$w(u,v) + W(P_{v \\to u})  0$\n这个不等式可以重新排列，从而得到对路径权重的条件：\n$W(P_{v \\to u})  -w(u,v)$\n为了判断是否存在这样的路径，我们必须找到从 $v$ 到 $u$ 权重最小的路径。根据定义，这就是从 $v$ 到 $u$ 的最短路径。设此最短路径的权重为 $\\delta(v,u)$。如果 $\\delta(v,u)  -w(u,v)$，则保证存在一个经过 $(u,v)$ 的负权环，该环由边 $(u,v)$ 和这条最短路径构成。如果连最短路径都不满足此条件，那么其他任何路径也不会满足，因此不存在这样的负权环。\n\n问题陈述中包含一个关键说明：“如果不存在使得到达 $u$ 的路径上的最短路径值不确定的负权环”。这意味着我们可以假设最短路径权重 $\\delta(v,u)$ 是一个有限值，而不是 $-\\infty$——如果从 $v$ 到 $u$ 的最短路径上存在负权环，则会出现后一种情况。这一简化使得我们可以直接应用标准的最短路径算法。\n\nBellman-Ford 算法是完成此任务的合适工具，因为它能正确计算可能包含负权重边的图中的单源最短路径。我们将以顶点 $v$ 为源点执行 Bellman-Ford 算法，以找到到所有其他顶点（包括 $u$）的最短路径。\n\n算法流程如下：\n\n1.  **初始验证**：首先，我们验证指定边 $(u,v)$ 是否存在于图的边集 $E$ 中。如果不存在，则没有环可以经过它，该测试用例的处理终止。设其权重为 $w_{uv}$。\n\n2.  **Bellman-Ford 执行**：我们初始化一个大小为 $|V|$ 的距离数组 $d$，其中 $d[v] = 0$，对于所有其他顶点 $i \\in V$，$d[i] = \\infty$。同时初始化一个前驱数组 $p$ 用于追踪路径。Bellman-Ford 算法的核心在于对图中的每条边进行松弛操作。这个松弛步骤重复 $|V|-1$ 次。对于每条权重为 $w_{xy}$ 的边 $(x,y)$，松弛操作为：如果 $d[x] + w_{xy}  d[y]$，则将 $d[y]$ 更新为 $d[x] + w_{xy}$ 并设置 $p[y] = x$。在 $|V|-1$ 次迭代后，考虑到问题的简化假设， $d[u]$ 将保存从 $v$ 到 $u$ 的最短路径权重 $\\delta(v,u)$。\n\n3.  **路径与环存在性检查**：\n    - 如果算法完成后，$d[u]$ 仍然是 $\\infty$，这表示从 $v$ 到 $u$ 不存在路径。因此，无法形成环，我们断定不存在这样的负权环。\n    - 如果路径存在（即 $d[u]$ 是有限的），我们检查负性条件：$d[u] + w_{uv}  0$。如果不满足此条件，则由最短路径形成的环不是负权环，并且从 $v$ 到 $u$ 的其他任何路径都无法形成权重更小的环。\n\n4.  **环的重构**：如果负性条件 $d[u] + w_{uv}  0$ 得到满足，则说明找到了一个负权环。我们必须重构其顶点序列。这通过使用前驱数组 $p$ 从 $u$ 开始回溯来完成。我们从一个包含 $u$ 的列表开始，迭代地在其前端添加其前驱 $p[u]$，然后是 $p[p[u]]$，依此类推，直到到达 $v$。这个过程会生成从 $v$到 $u$ 的最短路径的顶点列表，我们称之为 `path_v_to_u`。最终的输出是构成环的有序顶点列表，该列表从 $u$ 开始，遍历到 $v$，然后沿着重构的路径返回到 $u$。这对应于将仅包含 $u$ 的列表与 `path_v_to_u` 连接起来，即 `[u] + path_v_to_u`。对于路径 $v \\to x_1 \\to \\dots \\to u$，重构的路径列表是 $[v, x_1, \\dots, u]$，最终的环列表是 $[u, v, x_1, \\dots, u]$。\n\n这种基于最短路径基本原理并通过 Bellman-Ford 算法实现的系统性方法，能够正确地按要求解决该问题。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_negative_cycle_through_edge(num_vertices, edges, u, v):\n    \"\"\"\n    Determines if a negative cycle exists through a designated edge (u, v)\n    using the Bellman-Ford algorithm.\n\n    Args:\n        num_vertices (int): The number of vertices in the graph.\n        edges (list of tuples): The list of edges, each as (source, dest, weight).\n        u (int): The starting vertex of the designated edge.\n        v (int): The ending vertex of the designated edge.\n\n    Returns:\n        list: A list of vertex indices representing the negative cycle, starting and\n              ending at u. Returns an empty list if no such cycle exists.\n    \"\"\"\n    w_uv = None\n    edge_map = {(src, dst): weight for src, dst, weight in edges}\n    \n    if (u, v) not in edge_map:\n        return []\n    w_uv = edge_map[(u, v)]\n\n    # Step 2: Bellman-Ford from source v\n    dist = [np.inf] * num_vertices\n    pred = [None] * num_vertices\n    dist[v] = 0\n\n    for _ in range(num_vertices - 1):\n        for x, y, weight in edges:\n            if dist[x] != np.inf and dist[x] + weight  dist[y]:\n                dist[y] = dist[x] + weight\n                pred[y] = x\n\n    # Step 3: Path and Cycle Existence Check\n    if dist[u] == np.inf:\n        return []\n\n    if dist[u] + w_uv >= 0:\n        return []\n\n    # Step 4: Cycle Reconstruction\n    path_vu = []\n    curr = u\n    while True:\n        path_vu.insert(0, curr)\n        if curr == v:\n            break\n        curr = pred[curr]\n        # This safeguard is for unexpected graph structures, though not expected\n        # in this problem's context. If pred[curr] is None before reaching v,\n        # it means there's no path, which contradicts dist[u] being finite.\n        if curr is None and path_vu[0] != v:\n            return [] # Should not happen under normal BF operation\n\n    # The problem asks for the cycle starting at u, traversing (u,v), and returning to u.\n    # The sequence is u, followed by the path from v to u.\n    # Our reconstructed `path_vu` is the sequence of vertices from v to u.\n    # For example, for a path v -> x -> u, path_vu is [v, x, u].\n    # Cycle sequence u -> v -> x -> u is represented as [u, v, x, u].\n    # This is [u] + path_vu.\n    cycle = [u] + path_vu\n    \n    return cycle\n    \ndef solve():\n    \"\"\"\n    Defines the test cases from the problem statement and runs the solver.\n    \"\"\"\n    test_cases = [\n        {\n            \"num_vertices\": 4,\n            \"edges\": [(1, 2, -1), (2, 3, 1), (3, 1, -1), (0, 1, 4), (0, 2, 2)],\n            \"u\": 1, \"v\": 2,\n        },\n        {\n            \"num_vertices\": 3,\n            \"edges\": [(0, 1, 2), (1, 2, 1), (2, 0, 0)],\n            \"u\": 0, \"v\": 1,\n        },\n        {\n            \"num_vertices\": 4,\n            \"edges\": [(0, 1, 1), (1, 2, 1), (2, 0, 1)],\n            \"u\": 3, \"v\": 2,\n        },\n        {\n            \"num_vertices\": 6,\n            \"edges\": [(4, 5, -2), (5, 4, 2), (0, 1, 3), (1, 2, 3), (2, 3, 3), (3, 0, -1)],\n            \"u\": 4, \"v\": 5,\n        },\n        {\n            \"num_vertices\": 6,\n            \"edges\": [(0, 3, 0), (3, 4, 1), (4, 0, 0), (1, 2, -3), (2, 1, -3)],\n            \"u\": 0, \"v\": 3,\n        },\n        {\n            \"num_vertices\": 2,\n            \"edges\": [(0, 1, -1)],\n            \"u\": 0, \"v\": 1,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_negative_cycle_through_edge(\n            case[\"num_vertices\"], case[\"edges\"], case[\"u\"], case[\"v\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    result_strs = []\n    for r in results:\n        if r:\n            result_strs.append(f\"[{','.join(map(str, r))}]\")\n        else:\n            result_strs.append(\"[]\")\n    \n    print(f\"[{','.join(result_strs)}]\")\n\nsolve()\n```", "id": "3213972"}]}