{"hands_on_practices": [{"introduction": "掌握Dijkstra算法的第一步是理解其核心操作流程。这个练习 [@problem_id:1496482] 将引导你手动模拟算法的每一步，在一个给定的网络图中确定节点的“确认”顺序。通过这种方式，你将亲身体验算法如何贪心地选择下一个最近的节点，并逐步更新路径成本，从而构建出对算法执行过程的直观认识。", "problem": "一个分布式网络由六个处理大规模计算的数据中心组成，分别标记为 A、B、C、D、E 和 F。为了优化数据路由，一个协议从主数据中心 A 启动。该协议的目标是建立从 A 到网络中其他每个中心的成本最低的通信路径。中心之间的连接是双向的，每条链路都有一个相关的延迟成本。\n\n网络拓扑和成本如下：\n- A 连接到 B，成本为 2。\n- A 连接到 C，成本为 5。\n- A 连接到 D，成本为 9。\n- B 连接到 C，成本为 2。\n- B 连接到 E，成本为 7。\n- C 连接到 D，成本为 3。\n- C 连接到 E，成本为 1。\n- D 连接到 F，成本为 2。\n- E 连接到 F，成本为 4。\n\n该协议通过维护一组“未确认”的中心及其从 A 出发的当前已知最低延迟成本来运作。最初，除 A 以外的所有中心都是未确认的，其成本设置为无穷大，而 A 的成本为 0。在每一步中，协议会选择当前成本最低的未确认中心，将其标记为“已确认”，并且如果通过这个新确认的中心发现了更短的路径，则更新其未确认邻居的成本。这个过程重复进行，直到所有中心都被确认为止。\n\n数据中心被该协议确认的顺序是什么？\n\nA. A, B, C, D, E, F\n\nB. A, B, C, E, D, F\n\nC. A, C, B, D, E, F\n\nD. A, B, D, C, E, F\n\nE. A, C, E, D, B, F", "solution": "我们将该协议解释为在以节点 A 为起点的无向加权图上运行的 Dijkstra 算法。设 $d(X)$ 表示从 A 到节点 $X$ 的当前已知最低成本。最初，设置 $d(A)=0$ 且对于所有其他节点 $d(B)=d(C)=d(D)=d(E)=d(F)=\\infty$。在每一步中，选择 $d(\\cdot)$ 值最小的未确认节点，确认它，并对其边进行松弛操作。\n\n初始化：\n$$d(A)=0,\\quad d(B)=\\infty,\\quad d(C)=\\infty,\\quad d(D)=\\infty,\\quad d(E)=\\infty,\\quad d(F)=\\infty.$$\n\n步骤 1 (确认 A)：使用成本为 2 的边 $A\\!-\\!B$、成本为 5 的边 $A\\!-\\!C$ 和成本为 9 的边 $A\\!-\\!D$ 来更新邻居节点：\n$$d(B)=\\min(\\infty,0+2)=2,\\quad d(C)=\\min(\\infty,0+5)=5,\\quad d(D)=\\min(\\infty,0+9)=9.$$\n当前未确认节点的成本为：$d(B)=2$，$d(C)=5$，$d(D)=9$，$d(E)=\\infty$，$d(F)=\\infty$。成本最低的是 B。\n\n步骤 2 (确认 B)：对成本为 2 的边 $B\\!-\\!C$ 和成本为 7 的边 $B\\!-\\!E$ 进行松弛操作：\n$$d(C)=\\min(5,2+2)=4,\\quad d(E)=\\min(\\infty,2+7)=9.$$\n当前未确认节点的成本为：$d(C)=4$，$d(D)=9$，$d(E)=9$，$d(F)=\\infty$。成本最低的是 C。\n\n步骤 3 (确认 C)：对成本为 3 的边 $C\\!-\\!D$ 和成本为 1 的边 $C\\!-\\!E$ 进行松弛操作：\n$$d(D)=\\min(9,4+3)=7,\\quad d(E)=\\min(9,4+1)=5.$$\n当前未确认节点的成本为：$d(D)=7$，$d(E)=5$，$d(F)=\\infty$。成本最低的是 E。\n\n步骤 4 (确认 E)：对成本为 4 的边 $E\\!-\\!F$ 进行松弛操作：\n$$d(F)=\\min(\\infty,5+4)=9.$$\n未确认节点的成本为：$d(D)=7$，$d(F)=9$。成本最低的是 D。\n\n步骤 5 (确认 D)：对成本为 2 的边 $D\\!-\\!F$ 进行松弛操作：\n$$d(F)=\\min(9,7+2)=9.$$\n剩余未确认节点为：$F$。\n\n步骤 6 (确认 F)：确认最后一个节点。\n\n确认顺序是 A、B、C、E、D、F，对应选项 B。", "answer": "$$\\boxed{B}$$", "id": "1496482"}, {"introduction": "在理解了标准流程之后，让我们通过一个思想实验来加深认识。本练习 [@problem_id:1363278] 提出了一个假设情景：如果算法在初始化阶段出现错误会发生什么？通过分析这个“错误”版本算法的输出，我们可以更深刻地领会为什么某些设计（例如将初始距离设为无穷大）是保证算法正确性的关键不变量，而非随意设定的规则。", "problem": "一位计算机科学专业的学生正在实现 Dijkstra 算法，以在一个有向加权图中寻找最短路径。该图的顶点用大写字母标记，边权重为非负整数。她的实现正确地识别了源顶点，但由于一个错误，它将所有其他顶点的距离初始化为 `0` 而不是无穷大。源顶点自身的距离被正确地初始化为 `0`。算法接着像通常一样继续执行，使用一个优先队列来迭代地选择具有已知最小距离的未访问顶点。在距离值出现平局的情况下，优先队列会选择按字母顺序排在前面的顶点。\n\n该图由以下有向边及其权重定义：\n*   S -> A，权重为 5\n*   S -> B，权重为 1\n*   A -> T，权重为 1\n*   B -> C，权重为 2\n*   C -> T，权重为 4\n\n源顶点是 `S`，目标顶点是 `T`。该学生错误的算法将会计算出的从 `S` 到 `T` 的距离是多少？\n\nA. 0\n\nB. 7\n\nC. 6\n\nD. 8\n\nE. 算法不会终止。", "solution": "该学生错误的算法将除源点 S 之外的所有顶点的距离初始化为 0，而不是无穷大。\n\n*   **初始状态**：距离数组为 $d(S)=0, d(A)=0, d(B)=0, d(C)=0, d(T)=0$。所有顶点都在未访问集合中。\n*   **优先队列**：优先队列根据距离选择顶点，距离相同时按字母顺序选择。因此，队列处理顶点的初始顺序将是 A, B, C, S, T（因为它们的距离都为0）。\n*   **步骤 1：处理 A**。算法从优先队列中取出 A（距离为0）。它尝试松弛边 A -> T（权重为1）。计算出的新路径距离为 $d(A) + w(A,T) = 0 + 1 = 1$。由于这个值不小于当前已知的 $d(T)=0$，因此 $d(T)$ 不会更新。\n*   **步骤 2：处理 B**。算法取出 B（距离为0）。尝试松弛边 B -> C（权重为2）。计算出的新路径距离为 $d(B) + w(B,C) = 0 + 2 = 2$。由于这个值不小于 $d(C)=0$，因此 $d(C)$ 不会更新。\n*   **步骤 3：处理 C**。算法取出 C（距离为0）。尝试松弛边 C -> T（权重为4）。计算出的新路径距离为 $d(C) + w(C,T) = 0 + 4 = 4$。由于这个值不小于 $d(T)=0$，因此 $d(T)$ 不会更新。\n*   **步骤 4：处理 S**。算法取出 S（距离为0）。它尝试松弛边 S -> A 和 S -> B。对于 S -> A，新距离为 $0+5=5$，不小于 $d(A)=0$。对于 S -> B，新距离为 $0+1=1$，不小于 $d(B)=0$。距离均未更新。\n*   **步骤 5：处理 T**。算法取出 T（距离为0）。此时所有顶点都已被访问。\n\n由于松弛条件 $d(u) + w(u,v)  d(v)$ 永远不会满足（因为所有 $d$ 值都是0，而边权重 $w$ 是非负的），所以没有任何距离值会从其初始值0更新。因此，算法报告的从 S 到 T 的最终距离是 $d(T)$ 的初始值，即 0。", "answer": "$$\\boxed{A}$$", "id": "1363278"}, {"introduction": "Dijkstra算法的应用不局限于寻找一条最短路径，其强大的框架可以被扩展以解决更复杂的问题。在这个高级练习 [@problem_id:3227957] 中，我们的任务是修改Dijkstra算法的核心逻辑，使其能够计算出两点之间所有不同最短路径的总数。这项挑战将促使我们超越简单的算法应用，进入算法设计的思维层面。", "problem": "考虑一个带权有向图，其顶点集为 $V = \\{s, a, b, c, d, e, f, g, t\\}$，以及在以下有向边上定义的非负权重函数 $w : V \\times V \\to \\mathbb{R}_{\\ge 0}$：\n$$\n(s,b): w(s,b) = 2,\\quad (s,c): w(s,c) = 2,\\quad (s,d): w(s,d) = 3,\n$$\n$$\n(b,e): w(b,e) = 2,\\quad (c,e): w(c,e) = 2,\\quad (b,f): w(b,f) = 3,\\quad (c,f): w(c,f) = 3,\\quad (d,f): w(d,f) = 1,\n$$\n$$\n(e,g): w(e,g) = 2,\\quad (f,g): w(f,g) = 2,\n$$\n$$\n(e,t): w(e,t) = 5,\\quad (f,t): w(f,t) = 5,\\quad (g,t): w(g,t) = 3,\\quad (d,t): w(d,t) = 7.\n$$\n所有其他未列出的点对 $(u,v)$ 之间没有边。设路径的长度为其边权重之和。从 $s$ 到顶点 $x$ 的一条最短路径是指从 $s$ 到 $x$ 的任意一条路径，其长度等于所有从 $s$ 到 $x$ 的路径中可能的最小长度。\n\n仅从带权图中最短路径的基本定义以及 Dijkstra 算法（该算法使用一个以暂定距离为键的优先队列（PQ））的一个不变性（即当一个顶点从优先队列中被取出时，其到该顶点的最短路径距离就已确定）出发，推导一个 Dijkstra 算法的修改版，用于计算从 $s$ 到 $t$ 的不同最短路径的总数。然后将你推导的修改版算法应用到上述图上，来确定从 $s$ 到 $t$ 的不同最短路径的总数。假设优先队列中的平局情况任意处理；计数结果必须独立于平局处理方式。将你的最终答案表示为一个不带单位的实数值。无需四舍五入。", "solution": "我们从核心定义开始。一个带权有向图 $(V,E,w)$ 有一个顶点集 $V$，一个有向边集 $E \\subseteq V \\times V$，以及一个非负权重函数 $w : E \\to \\mathbb{R}_{\\ge 0}$。对于一条路径 $P = \\langle v_{0}, v_{1}, \\dots, v_{k} \\rangle$，其中对所有 $i$ 都有 $(v_{i}, v_{i+1}) \\in E$，其长度为 $\\sum_{i=0}^{k-1} w(v_{i}, v_{i+1})$。从 $s$ 到 $x$ 的最短路径距离，记作 $d^{\\ast}(x)$，是 $\\min\\{\\text{length}(P) : P \\text{ is an } s\\text{-}x \\text{ path}\\}$。\n\nDijkstra 算法维护一个暂定距离数组 $d[v]$，初始化时 $d[s] = 0$ 且对于 $v \\neq s$ 有 $d[v] = \\infty$，以及一个以 $d[v]$ 为键的优先队列(PQ)。一个基本的不变性是：当一个顶点 $u$ 从优先队列中被取出时，$d[u] = d^{\\ast}(u)$，并且未来的松弛操作都不能减小 $d[u]$，因为所有边的权重都是非负的。\n\n为了计算不同最短路径的数量，我们通过增加一个路径计数数组 $c[v]$ 来增强 Dijkstra 算法，其中 $c[v]$ 表示与当前已知的最佳距离 $d[v]$ 一致的、从 $s$ 到 $v$ 的不同最短路径的数量。初始化为 $c[s] = 1$（到自身存在一条唯一的长度为 0 的空路径），且对于 $v \\neq s$ 有 $c[v] = 0$。当对一条权重为 $w(u,v)$ 的边 $(u,v)$ 进行松弛操作时，我们考虑候选距离 $d[u] + w(u,v)$：\n- 如果 $d[u] + w(u,v)  d[v]$，那么我们找到了一条严格更短的从 $s$ 到 $v$ 的路径。设置 $d[v] \\leftarrow d[u] + w(u,v)$ 并重置 $c[v] \\leftarrow c[u]$，因为现在每一条从 $s$ 到 $v$ 的最短路径都必须以边 $(u,v)$ 结尾，并且由一条从 $s$ 到 $u$ 的最短路径加上这条边构成。\n- 如果 $d[u] + w(u,v) = d[v]$，那么我们找到了其他长度同样为最小值的从 $s$ 到 $v$ 的最短路径。将 $c[u]$ 加到 $c[v]$ 上，即 $c[v] \\leftarrow c[v] + c[u]$，因为每一条从 $s$ 到 $u$ 的最短路径都可以通过边 $(u,v)$ 扩展，从而得到一条不同的从 $s$ 到 $v$ 的最短路径。\n\n正确性可以通过对顶点从优先队列中被取出的顺序进行归纳来证明。基础情况是 $s$，此时 $d[s] = 0 = d^{\\ast}(s)$ 且 $c[s] = 1$。假设对于所有先前被取出的顶点 $u$，我们有 $d[u] = d^{\\ast}(u)$ 并且 $c[u]$ 等于从 $s$ 到 $u$ 的不同最短路径的数量。对于一次松弛操作 $(u,v)$，如果找到了一个严格更优的距离，所有之前的从 $s$ 到 $v$ 的最短路径都变得不再是最短的，因此将 $c[v]$ 重置为 $c[u]$ 是必要且充分的，因为任何一条从 $s$ 到 $v$ 的最短路径都必须经过某个先前被取出且其 $d[u]$ 已确定的前驱顶点 $u$，然后经过最后一条边 $(u,v)$；非负权重保证了当距离确定后，在最终的最短路径有向无环图中，这种结构是无环的。如果找到了一个等长的最短距离，经过 $u$ 的路径是新的从 $s$ 到 $v$ 的最短路径，与已经为 $v$ 计数的路径不同，所以加法操作会累积出正确的总数。当 $t$ 被取出或所有松弛操作完成后，$d[t] = d^{\\ast}(t)$ 并且 $c[t]$ 等于从 $s$ 到 $t$ 的不同最短路径的数量。\n\n我们现在将此修改应用到给定的图上。我们明确指出顶点为 $V = \\{s, b, c, d, e, f, g, t\\}$，以及有向边和权重：\n$$\n(s,b) = 2, \\ (s,c) = 2, \\ (s,d) = 3;\n$$\n$$\n(b,e) = 2, \\ (c,e) = 2, \\ (b,f) = 3, \\ (c,f) = 3, \\ (d,f) = 1;\n$$\n$$\n(e,g) = 2, \\ (f,g) = 2;\n$$\n$$\n(e,t) = 5, \\ (f,t) = 5, \\ (g,t) = 3, \\ (d,t) = 7.\n$$\n\n初始化：\n- $d[s] = 0$, $c[s] = 1$。\n- 对于 $v \\in \\{b, c, d, e, f, g, t\\}$: $d[v] = \\infty$, $c[v] = 0$。\n\n松弛从 $s$ 出发的边：\n- $(s,b)$: $d[b] \\leftarrow 2$, $c[b] \\leftarrow 1$。\n- $(s,c)$: $d[c] \\leftarrow 2$, $c[c] \\leftarrow 1$。\n- $(s,d)$: $d[d] \\leftarrow 3$, $c[d] \\leftarrow 1$。\n\n取出 $d$ 值最小的顶点；假设平局任意处理。取出 $b$ ($d[b] = 2$)：\n- $(b,e)$: 候选距离 $2 + 2 = 4$。这个距离小于当前的 $d[e]=\\infty$，所以更新 $d[e] \\leftarrow 4$，$c[e] \\leftarrow c[b] = 1$。\n- $(b,f)$: 候选距离 $2 + 3 = 5$。这个距离小于当前的 $d[f]=\\infty$，所以更新 $d[f] \\leftarrow 5$，$c[f] \\leftarrow c[b] = 1$。\n\n取出 $c$ ($d[c] = 2$)：\n- $(c,e)$: 候选距离 $2 + 2 = 4$。这个距离等于当前的 $d[e]=4$，所以 $c[e] \\leftarrow c[e] + c[c] = 1 + 1 = 2$。\n- $(c,f)$: 候选距离 $2 + 3 = 5$。这个距离等于当前的 $d[f]=5$，所以 $c[f] \\leftarrow c[f] + c[c] = 1 + 1 = 2$。\n\n取出 $d$ ($d[d] = 3$)：\n- $(d,f)$: 候选距离 $3 + 1 = 4$。这个距离小于当前的 $d[f]=5$，所以我们找到了到 $f$ 的一条更短路径。更新 $d[f] \\leftarrow 4$ 并重置 $c[f] \\leftarrow c[d] = 1$。\n- $(d,t)$: 候选距离 $3 + 7 = 10$。这个距离小于当前的 $d[t]=\\infty$，所以更新 $d[t] \\leftarrow 10$，$c[t] \\leftarrow c[d] = 1$。\n\n接下来，优先队列包含 $e$（$d[e] = 4$），$f$（$d[f] = 4$），$g$（$d[g] = \\infty$），$t$（$d[t] = 10$）。取出 $e$ ($d[e] = 4$)：\n- $(e,g)$: 候选距离 $4 + 2 = 6$。这个距离小于当前的 $d[g]=\\infty$，所以更新 $d[g] \\leftarrow 6$，$c[g] \\leftarrow c[e] = 2$。\n- $(e,t)$: 候选距离 $4 + 5 = 9$。这个距离小于当前的 $d[t]=10$，所以我们找到了到 $t$ 的一条更短路径。更新 $d[t] \\leftarrow 9$ 并重置 $c[t] \\leftarrow c[e] = 2$。\n\n取出 $f$ ($d[f] = 4$)：\n- $(f,g)$: 候选距离 $4 + 2 = 6$。这个距离等于当前的 $d[g]=6$，所以 $c[g] \\leftarrow c[g] + c[f] = 2 + 1 = 3$。\n- $(f,t)$: 候选距离 $4 + 5 = 9$。这个距离等于当前的 $d[t]=9$，所以 $c[t] \\leftarrow c[t] + c[f] = 2 + 1 = 3$。\n\n取出 $g$ ($d[g] = 6$)：\n- $(g,t)$: 候选距离 $6 + 3 = 9$。这个距离等于当前的 $d[t]=9$，所以 $c[t] \\leftarrow c[t] + c[g] = 3 + 3 = 6$。\n\n最后，取出 $t$ ($d[t] = 9$)；没有相关的出边松弛操作。算法终止，得到 $d[t] = 9$，这是从 $s$ 到 $t$ 的最短路径距离，以及 $c[t] = 6$，这是从 $s$ 到 $t$ 的不同最短路径的总数。\n\n我们可以交叉检查路径结构以确保没有重复计数：\n- 经由 $e$ 直接到 $t$ 的路径：从 $s$ 到 $e$ 有 2 条最短路径（$s \\to b \\to e$ 和 $s \\to c \\to e$），每条路径通过边 $(e,t)$ 扩展后，产生 2 条总长度为 $4 + 5 = 9$ 的不同最短路径。\n- 经由 $f$ 直接到 $t$ 的路径：到 $f$ 的唯一最短路径是 $s \\to d \\to f$（长度 $3 + 1 = 4$）；通过边 $(f,t)$ 扩展后，产生 1 条长度为 9 的最短路径。\n- 经由 $g$ 到 $t$ 的路径：到 $g$ 有 3 条最短路径（两条经由 $e$，一条经由 $f$），每条路径通过边 $(g,t)$ 扩展后，产生 3 条长度为 $6 + 3 = 9$ 的不同最短路径。\n求和 $2 + 1 + 3 = 6$ 与算法产生的 $c[t] = 6$ 一致。\n\n因此，在给定图中从 $s$ 到 $t$ 的不同最短路径的总数为 $6$。", "answer": "$$\\boxed{6}$$", "id": "3227957"}]}