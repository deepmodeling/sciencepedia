{"hands_on_practices": [{"introduction": "虽然 Dijkstra 算法保证能找到正确的最短路径*长度*，但其生成的*最短路径树*并非总是唯一的。本练习将深入探讨一些看似微不足道的实现选择，例如处理等长路径的平局决胜规则，如何显著改变解路径树的拓扑结构。理解这一点对于网络分析等应用至关重要，因为在这些应用中，具体的路径本身与路径的长度同等重要。[@problem_id:3271591]", "problem": "给定一个无向加权图，其顶点集为 $V = \\{0,1,2,3,4,5,6\\}$，边集包含以下边，每条边的权重均为 $1$：$(0,1)$, $(0,2)$, $(1,3)$, $(2,3)$, $(1,4)$, $(2,4)$, $(3,5)$, $(4,5)$, $(3,6)$, $(4,6)$。所有权重均为非负。考虑从源点 $0$ 开始运行 Dijkstra 算法来计算最短路径树 (SPT)，其中 SPT 是一个以源点为根的生成有向树，树中从根到任意顶点的唯一路径实现了给定图中的最短路径距离。假设 Dijkstra 算法采用标准定义：顶点从一个以当前暂定距离为键的最小优先队列中提取，当发现一个严格更小的值时，边的松弛操作会更新暂定距离。\n\n为了在存在多条等长最短路径时完全确定父节点的选择，我们考虑 Dijkstra 算法的两种变体，它们仅在确定性的平局打破规则上有所不同：\n\n- 变体 $\\mathsf{M}$ (最小索引)：优先队列在暂定距离相等时，按较小的顶点索引打破平局；当松弛边 $(u,v)$ 得到一个与 $v$ 当前暂定距离相等的距离时，当且仅当 $u$ 的索引小于 $v$ 当前父节点的索引时，算法才将 $u$ 作为 $v$ 的父节点。\n- 变体 $\\mathsf{X}$ (最大索引)：优先队列在暂定距离相等时，按较大的顶点索引打破平局；当松弛边 $(u,v)$ 得到一个与 $v$ 当前暂定距离相等的距离时，当且仅当 $u$ 的索引大于 $v$ 当前父节点的索引时，算法才将 $u$ 作为 $v$ 的父节点。\n\n设变体 $\\mathsf{M}$ 和 $\\mathsf{X}$ 输出的树分别为 $T_{\\mathsf{M}}$ 和 $T_{\\mathsf{X}}$，两者均以 $0$ 为根。考虑构建树路径查询数据结构，例如最近公共祖先 (LCA)，其中 LCA 表示有根树中两个节点的最近公共祖先，以及欧拉序加范围最小值查询 (RMQ)，其中 RMQ 表示范围最小值查询。\n\n以下哪个陈述是正确的？选择所有适用的选项。\n\nA. 变体 $\\mathsf{M}$ 和 $\\mathsf{X}$ 计算出到所有顶点的最短路径距离是相同的，但当树本身被用作 LCA 的有根结构时，$T_{\\mathsf{M}}$ 和 $T_{\\mathsf{X}}$ 对于同一对顶点可能会得出不同的 LCA 答案。\n\nB. 变体 $\\mathsf{X}$ 可能会生成一个对此图而言不是有效 SPT 的生成树，因为某些顶点的距离相对于变体 $\\mathsf{M}$ 发生了变化。\n\nC. 无论使用 $T_{\\mathsf{M}}$ 还是 $T_{\\mathsf{X}}$，任何预处理和查询时间仅取决于顶点数量的 LCA 数据结构（例如，欧拉序加 RMQ 的预处理时间为 $O(n)$、查询时间为 $O(1)$，或二进制提升的预处理时间为 $O(n \\log n)$、查询时间为 $O(\\log n)$）都具有相同的渐近性能；然而，常数因子和确切的 LCA 结果可能会有所不同。\n\nD. 对于给定的图和源点 $0$，在 $T_{\\mathsf{M}}$ 中顶点 $5$ 和 $6$ 的 LCA 是顶点 $3$，而在 $T_{\\mathsf{X}}$ 中 $5$ 和 $6$ 的 LCA 是顶点 $4$。\n\nE. 与任何其他有效的平局打破规则相比，使用最小索引平局打破规则 $\\mathsf{M}$ 总能最小化所得到的 SPT 的高度。\n\n答案选项：A, B, C, D, E。", "solution": "我们从基本原理开始：在一个非负边权图中，从一个源点到一个顶点的最短路径是所有此类路径中总权重最小的任意一条路径。Dijkstra 算法维护一个已确定距离（等于其最短路径距离）的顶点集合，并使用一个以暂定距离为键的最小优先队列来提取下一个具有最小暂定距离的顶点。它通过将 $v$ 的暂定距离设置为 $\\min\\{ \\text{current tentative}(v), \\text{tentative}(u) + w(u,v) \\}$ 来松弛边 $(u,v)$，其中 $w(u,v)$ 是边权重。在非负权重的情况下，当一个顶点首次从优先队列中被提取出来时，其暂定距离就等于其真实的最短路径距离。最短路径树 (SPT) 是以源点为根的任意一棵生成树，使得树中从源点到每个顶点的唯一路径的长度等于原始图中的最短路径距离。\n\n因为到同一个顶点可能存在多条总权重相等的不同最短路径，所以需要一个确定性的平局打破策略来明确地定义父指针。变体 $\\mathsf{M}$ 和 $\\mathsf{X}$ 仅在距离相等时的平局打破规则上有所不同；它们绝不会选择会增加距离的父节点，因为它们只在暂定距离相等或严格更小时才采纳新的父节点。\n\n我们来分析给定的图。由于所有边权重均为 $1$，且边仅连接指定的相邻层，因此可以根据顶点到 $0$ 的最短路径距离将顶点分层：\n\n- 距离为 $1$ 的层：顶点 $1$ 和 $2$，因为 $(0,1)$ 和 $(0,2)$ 的权重为 $1$。\n- 距离为 $2$ 的层：顶点 $3$ 和 $4$，每个都可以通过 $1$ 或 $2$ 经两跳权重为 $1$ 的路径到达。\n- 距离为 $3$ 的层：顶点 $5$ 和 $6$，每个都可以通过 $3$ 或 $4$ 经三跳权重为 $1$ 的路径到达。\n\n形式上，唯一的最短路径距离函数 $d$ 满足 $d(0)=0$, $d(1)=d(2)=1$, $d(3)=d(4)=2$, $d(5)=d(6)=3$。这个结论可以由边集所引出的三角不等式以及图是无向的且所列边权重均为 $1$ 这一事实得出：不存在更短的路径，因为没有权重为 $0$ 的边或能将跳数减少到这些值以下的直接连接。\n\n现在我们证明两种变体计算出的这些距离是相同的。Dijkstra 算法的正确性依赖于非负权重；下一个被提取的顶点总是具有已确定的最短距离。在这里，第一步，$0$ 以 $d(0)=0$ 被确定。然后 $1$ 和 $2$ 的暂定距离被设为 $1$。两种变体都从 $\\{1,2\\}$ 中提取下一个顶点，但在先选择哪个等距顶点上有所不同：$\\mathsf{M}$ 先提取 $1$ 再提取 $2$，而 $\\mathsf{X}$ 先提取 $2$ 再提取 $1$。无论如何， $1$ 和 $2$ 都以距离 $1$ 被确定。接着，从 $1$ 和 $2$ 进行松弛，得到 $3$ 和 $4$ 的暂定距离为 $2$。然后它们以某种顺序以距离 $2$ 被确定。最后，从 $3$ 和 $4$ 进行松弛，得到 $5$ 和 $6$ 的暂定距离为 $3$，然后它们以距离 $3$ 被确定。平局打破规则在任何时候都不会选择一个严格更大的暂定距离；因此两种变体计算出的距离标签 $d$ 是相同的。\n\n我们现在来描述父指针以及最终生成的树 $T_{\\mathsf{M}}$ 和 $T_{\\mathsf{X}}$。因为每条边的权重都为 $1$ 并且每层的距离恰好增加 $1$，所以距离为 $k$ 的顶点的任何父节点都必须是距离为 $k-1$ 的邻居。在距离相等时存在多种选择；平局打破规则在它们之间做出决定。\n\n- 变体 $\\mathsf{M}$ 的行为：\n  - 提取 $0$ 之后，松弛操作设置暂定父节点 $\\text{parent}(1)=0$ 和 $\\text{parent}(2)=0$。\n  - 在 $1$ 和 $2$ 之间，$\\mathsf{M}$ 首先提取 $1$ (索引较小)。松弛 $(1,3)$ 和 $(1,4)$ 将 $\\text{parent}(3)=1$ 和 $\\text{parent}(4)=1$ 设置为暂定距离 $2$。当之后提取 $2$ 并松弛 $(2,3)$ 和 $(2,4)$ 时，候选距离等于当前的暂定距离 ($2$)。$\\mathsf{M}$ 中的等距平局打破规则偏好索引较小的父节点，而该父节点已经是 $1$ 了，所以父节点保持为 $\\text{parent}(3)=1$ 和 $\\text{parent}(4)=1$。\n  - 对于顶点 $5$ 和 $6$，在提取 $3$ 之后（它在相同距离上比 $4$ 的索引小），松弛操作将 $\\text{parent}(5)=3$ 和 $\\text{parent}(6)=3$ 设置为距离 $3$。当之后 $4$ 松弛 $(4,5)$ 和 $(4,6)$ 时，等距平局打破规则再次偏好索引较小的父节点，所以父节点保持为 $3$。\n  - 因此，$T_{\\mathsf{M}}$ 的父指针为：$\\text{parent}(1)=0$, $\\text{parent}(2)=0$, $\\text{parent}(3)=1$, $\\text{parent}(4)=1$, $\\text{parent}(5)=3$, $\\text{parent}(6)=3$。\n\n- 变体 $\\mathsf{X}$ 的行为：\n  - 提取 $0$ 之后，松弛操作设置暂定父节点 $\\text{parent}(1)=0$ 和 $\\text{parent}(2)=0$。\n  - 在 $1$ 和 $2$ 之间，$\\mathsf{X}$ 首先提取 $2$ (索引较大)。松弛 $(2,3)$ 和 $(2,4)$ 将 $\\text{parent}(3)=2$ 和 $\\text{parent}(4)=2$ 设置为距离 $2$。当之后提取 $1$ 并松弛 $(1,3)$ 和 $(1,4)$ 时，候选距离等于当前的暂定距离 ($2$)；$\\mathsf{X}$ 中的等距平局打破规则偏好索引较大的父节点，所以父节点保持为 $2$。\n  - 对于顶点 $5$ 和 $6$，在相同距离的 $3$ 和 $4$ 之间，$\\mathsf{X}$ 首先提取 $4$ (索引较大)，将 $\\text{parent}(5)=4$ 和 $\\text{parent}(6)=4$ 设置为距离 $3$。当之后 $3$ 松弛这些边时，等距平局打破规则偏好索引较大的父节点，所以父节点保持为 $4$。\n  - 因此，$T_{\\mathsf{X}}$ 的父指针为：$\\text{parent}(1)=0$, $\\text{parent}(2)=0$, $\\text{parent}(3)=2$, $\\text{parent}(4)=2$, $\\text{parent}(5)=4$, $\\text{parent}(6)=4$。\n\n两棵树都是有效的 SPT，因为根据构造，$T_{\\mathsf{M}}$ 或 $T_{\\mathsf{X}}$ 中从 $0$ 到每个顶点 $v$ 的路径恰好有 $d(v)$ 条权重为 $1$ 的边，因此总权重为 $d(v)$，这等于最短路径距离。\n\n我们现在来研究最近公共祖先 (LCA) 的影响。在一棵有根树中，两个顶点 $u$ 和 $v$ 的 LCA 是同时作为两者祖先的唯一的深度最大的顶点。在 $T_{\\mathsf{M}}$ 中，根是 $0$，深度（从根开始的边数）为 $\\text{depth}(0)=0$, $\\text{depth}(1)=\\text{depth}(2)=1$, $\\text{depth}(3)=\\text{depth}(4)=2$, $\\text{depth}(5)=\\text{depth}(6)=3$。此外，在 $T_{\\mathsf{M}}$ 中 $\\text{parent}(5)=3$ 且 $\\text{parent}(6)=3$，所以 $5$ 和 $6$ 的唯一最深公共祖先是 $3$。在 $T_{\\mathsf{X}}$ 中，$\\text{parent}(5)=4$ 且 $\\text{parent}(6)=4$，所以 $5$ 和 $6$ 的 LCA 是 $4$。因此，尽管图的距离是不变的，LCA 的答案可能会不同，因为它们依赖于具体的树结构。\n\n关于 LCA 的预处理和查询复杂度，经典方法如欧拉序加 RMQ (范围最小值查询) 可实现 $O(n)$ 的预处理时间和 $O(1)$ 的查询时间，而二进制提升可实现 $O(n \\log n)$ 的预处理时间和 $O(\\log n)$ 的查询时间，两者都是关于顶点数 $n$ 的函数。这些界限不依赖于树的精确形状，所以对于 $T_{\\mathsf{M}}$ 和 $T_{\\mathsf{X}}$ 来说，它们的渐近性能是相同的。然而，常数因子（例如，欧拉序中的缓存行为或填充的祖先指针的确切集合）以及给定点对的特定 LCA 顶点可能会因为树的不同而不同。\n\n我们现在分析每个选项：\n\n- 选项 A：正确。如前所述，两种变体计算出的最短路径距离是相同的，因为带有非负权重的 Dijkstra 算法会确定真实距离，而平局打破规则只在等距父节点中选择。然而，父节点的选择导致了不同的 SPT 形状，这可能并且确实会对同一点对产生不同的 LCA 答案，例如 $\\text{LCA}(5,6)$。\n- 选项 B：错误。变体 $\\mathsf{X}$ 绝不会接受一个产生严格更大暂定距离的父节点；它只在距离相等时改变父节点，因此保留了最短路径距离。因此，它仍然会产生一个有效的 SPT。\n- 选项 C：正确。标准 LCA 数据结构的渐近预处理和查询时间取决于 $n$（可能还有 $\\log n$），但不取决于树的具体形状。虽然常数因子和 LCA 结果可能会改变，但对于 $T_{\\mathsf{M}}$ 和 $T_{\\mathsf{X}}$ 来说，大O表示的界限保持不变。\n- 选项 D：正确。如前所示，$\\text{LCA}_{T_{\\mathsf{M}}}(5,6)=3$ 且 $\\text{LCA}_{T_{\\mathsf{X}}}(5,6)=4$。\n- 选项 E：错误。最小索引平局打破规则通常不保证最小化树的高度；不同的图在多种平局打破规则下可能产生相同高度的 SPT，并且存在一些图，其中不同的有效 SPT 可能具有不同的高度，而选择最小索引父节点并不一定能使其最小化。此外，在这个特定的图中，$T_{\\mathsf{M}}$ 和 $T_{\\mathsf{X}}$ 的高度都是 $3$。\n\n因此，正确的选项是 A、C 和 D。", "answer": "$$\\boxed{ACD}$$", "id": "3271591"}, {"introduction": "现实世界中的路径规划决策通常涉及平衡多个相互竞争的目标，例如同时最小化旅行时间和成本。本练习将介绍一种称为标量化的强大技术，它将一个多目标问题转化为一个标准的单源最短路径问题，从而可以应用 Dijkstra 算法求解。通过亲手实现，您将直接观察到调整不同成本（如距离和风险）之间的权衡如何导致不同的最优路径。[@problem_id:3271663]", "problem": "给定一个有向图，其每条边都标注有两个非负属性：一个距离 (distance) 和一个风险 (risk)。通过使用非负系数将这两个属性标量化为单个非负边权重函数，从而定义了一个单源最短路径问题。从图路径成本在边上可加的基本定义，以及最优路径是最小化总可加成本的路径这一定义出发，实现一个程序，该程序在多种标量化方案下计算从一个固定源点出发的单源最短路径，并报告到所有顶点的距离。\n\n用作基本基础的定义：\n- 有向图是一个对偶 $G=(V,E)$，其中 $V$ 是顶点集，$E\\subseteq V\\times V$ 是有向边集。\n- 每条有向边 $e\\in E$ 有两个给定的非负属性：$\\mathrm{dist}(e)\\ge 0$ 和 $\\mathrm{risk}(e)\\ge 0$。\n- 对于非负系数 $\\alpha\\ge 0$ 和 $\\beta\\ge 0$，定义标量化边权重函数 $w_{\\alpha,\\beta}(e)=\\alpha\\cdot \\mathrm{dist}(e)+\\beta\\cdot \\mathrm{risk}(e)$。\n- 对于一条路径 $P=(e_1,e_2,\\dots,e_k)$，其在 $(\\alpha,\\beta)$ 下的总成本为 $W_{\\alpha,\\beta}(P)=\\sum_{i=1}^k w_{\\alpha,\\beta}(e_i)$。\n- 单源最短路径问题要求计算 $d_{\\alpha,\\beta}(v)$，即从一个固定源顶点 $s$ 到顶点 $v$ 的所有路径中的最小总成本 $W_{\\alpha,\\beta}(P)$。\n\n任务：\n- 仅使用上述基本定义以及“可加的非负路径成本允许使用带优先级的贪心松弛策略”这一经过充分检验的事实，设计一个算法来为多个给定的 $(\\alpha,\\beta)$ 对计算所有 $v\\in V$ 的 $d_{\\alpha,\\beta}(v)$，并将其实现为一个无需输入即可运行的完整程序。\n- 除了可加性和非负性之外，你不得假设任何其他公式；算法步骤必须从这些原则推导出来。\n\n图的规格：\n- 顶点集 $V=\\{0,1,2,3,4,5,6\\}$，源点 $s=0$。\n- 带有属性 $(\\mathrm{dist},\\mathrm{risk})$ 的有向边 $E$ 如下，记为“从 $u$ 到 $v$ 的边属性为 $(d,r)$”：\n  - 从 $0$ 到 $1$ 的边属性为 $(2,8)$。\n  - 从 $0$ 到 $2$ 的边属性为 $(5,1)$。\n  - 从 $0$ 到 $3$ 的边属性为 $(4,4)$。\n  - 从 $0$ 到 $4$ 的边属性为 $(9,1)$。\n  - 从 $1$ 到 $3$ 的边属性为 $(2,7)$。\n  - 从 $1$ 到 $4$ 的边属性为 $(2,8)$。\n  - 从 $1$ 到 $5$ 的边属性为 $(7,2)$。\n  - 从 $2$ 到 $3$ 的边属性为 $(1,2)$。\n  - 从 $2$ 到 $4$ 的边属性为 $(5,1)$。\n  - 从 $2$ 到 $5$ 的边属性为 $(4,1)$。\n  - 从 $3$ 到 $4$ 的边属性为 $(2,4)$。\n  - 从 $3$ 到 $5$ 的边属性为 $(2,3)$。\n  - 从 $4$ 到 $6$ 的边属性为 $(3,9)$。\n  - 从 $5$ 到 $6$ 的边属性为 $(3,1)$。\n\n标量化参数测试集：\n- 情况 1：$(\\alpha,\\beta)=(1,0)$。\n- 情况 2：$(\\alpha,\\beta)=(0,1)$。\n- 情况 3：$(\\alpha,\\beta)=(1,1)$。\n- 情况 4：$(\\alpha,\\beta)=(2,1)$。\n- 情况 5：$(\\alpha,\\beta)=(1,2)$。\n- 情况 6：$(\\alpha,\\beta)=(0,0)$。\n- 情况 7：$(\\alpha,\\beta)=(10,10)$。\n- 情况 8：$(\\alpha,\\beta)=(3,0.1)$。\n\n要求：\n- 对于每种情况，按顶点索引升序计算单源最短路径距离向量 $[d_{\\alpha,\\beta}(0),d_{\\alpha,\\beta}(1),d_{\\alpha,\\beta}(2),d_{\\alpha,\\beta}(3),d_{\\alpha,\\beta}(4),d_{\\alpha,\\beta}(5),d_{\\alpha,\\beta}(6)]$，根据定义 $d_{\\alpha,\\beta}(0)=0$。\n- 所有算术运算都是无单位的实数；不要四舍五入。\n- 最终输出格式：你的程序应生成单行输出，其中包含八个情况的向量结果，形式为一个由方括号括起来的逗号分隔列表。具体来说，打印单行内容，其形式为 $[[\\text{case1}], [\\text{case2}], [\\text{case3}], [\\text{case4}], [\\text{case5}], [\\text{case6}], [\\text{case7}], [\\text{case8}]]$，其中每个内部列表是该情况下的七个距离，写成没有单位的数字。不要包含任何空格。", "solution": "我们从有向图 $G=(V,E)$ 的基本定义出发，该图具有非负的边属性和可加的路径成本。在任何固定的非负对 $(\\alpha,\\beta)$ 下，路径 $P=(e_1,\\dots,e_k)$ 的总成本为 $W_{\\alpha,\\beta}(P)=\\sum_{i=1}^k w_{\\alpha,\\beta}(e_i)$，其中 $w_{\\alpha,\\beta}(e)=\\alpha\\cdot \\mathrm{dist}(e)+\\beta\\cdot \\mathrm{risk}(e)$。因为 $\\alpha\\ge 0$, $\\beta\\ge 0$，且边属性是非负的，所以对于所有指定的情况，每条边 $e$ 的 $w_{\\alpha,\\beta}(e)\\ge 0$ 都成立，包括退化情况 $(\\alpha,\\beta)=(0,0)$，此时所有边的 $w_{\\alpha,\\beta}(e)=0$。\n\n根据最优性原理和路径成本的可加性，从源点 $s$ 到任意顶点 $v$ 的最小路径成本 $d_{\\alpha,\\beta}(v)$ 满足：存在一条最优路径，其到路径上任意中间顶点的真前缀本身也是最优的。在一个额外且经过充分检验的事实之下——即非负边权重意味着延长路径不会降低其成本（单调性）——我们可以采用贪心松弛策略：重复选择具有最小暂定距离的尚未最终确定的顶点，并松弛其所有出边。该策略通过一个优先队列来实现。每次松弛都是对不等式\n$$\nd_{\\alpha,\\beta}(v)\\le d_{\\alpha,\\beta}(u)+w_{\\alpha,\\beta}(u,v)\n$$\n的应用，对于每条边 $(u,v)\\in E$，当右侧的值小于当前的暂定值时，会发生严格改进。其正确性在于，对于非负权重，一旦一个顶点 $u$ 在所有未处理的顶点中获得了最小的暂定距离，那么通过任何其他未处理的顶点到达 $u$ 的替代路径都不可能产生更小的成本，因为那将需要经过一个暂定距离至少一样大的顶点，然后再增加一个非负的边权重，这与最小性相矛盾。\n\n基于这些原则的算法设计：\n- 对于每种情况 $(\\alpha,\\beta)$，在松弛过程中通过 $w_{\\alpha,\\beta}(e)=\\alpha\\cdot \\mathrm{dist}(e)+\\beta\\cdot \\mathrm{risk}(e)$ 即时形成隐式边权重，而无需修改图。\n- 初始化所有 $v\\in V$ 的距离为 $d_{\\alpha,\\beta}(v)=+\\infty$，除了 $d_{\\alpha,\\beta}(s)=0$。\n- 使用一个以当前暂定距离为键的最小优先队列。弹出最小的元素，将其最终确定，并使用 $d_{\\alpha,\\beta}(v)\\gets \\min\\{d_{\\alpha,\\beta}(v), d_{\\alpha,\\beta}(u)+w_{\\alpha,\\beta}(u,v)\\}$ 松弛所有出边。\n- 持续此过程直到队列为空。\n\n复杂度：使用二叉堆优先队列，每种情况的运行时间为 $O\\big((|V|+|E|)\\log |V|\\big)$，对于 $T$ 种情况，总运行时间为 $O\\big(T\\cdot (|V|+|E|)\\log |V|\\big)$。\n\n关于 $(\\alpha,\\beta)$ 的敏感性分析：\n- 改变 $(\\alpha,\\beta)$ 会线性地改变每条边的权重。随着 $(\\alpha,\\beta)$ 的变化，最短路径树可能会改变，因为距离和风险之间的不同权衡会翻转候选路径成本的顺序。\n- 正向缩放不变性：如果将 $(\\alpha,\\beta)$ 乘以任何 $\\lambda>0$，那么对于所有边 $e$，有 $w_{\\lambda\\alpha,\\lambda\\beta}(e)=\\lambda\\cdot w_{\\alpha,\\beta}(e)$，所以每条路径的成本都乘以 $\\lambda$，这会保持最小化路径的集合不变。因此，对于所有 $v$，有 $d_{\\lambda\\alpha,\\lambda\\beta}(v)=\\lambda\\cdot d_{\\alpha,\\beta}(v)$。\n\n应用于给定图：\n- 顶点为 $V=\\{0,1,2,3,4,5,6\\}$，源点 $s=0$。\n- 带有 $(\\mathrm{dist},\\mathrm{risk})$ 的边：\n  $(0\\to 1):(2,8)$, $(0\\to 2):(5,1)$, $(0\\to 3):(4,4)$, $(0\\to 4):(9,1)$,\n  $(1\\to 3):(2,7)$, $(1\\to 4):(2,8)$, $(1\\to 5):(7,2)$,\n  $(2\\to 3):(1,2)$, $(2\\to 4):(5,1)$, $(2\\to 5):(4,1)$,\n  $(3\\to 4):(2,4)$, $(3\\to 5):(2,3)$,\n  $(4\\to 6):(3,9)$, $(5\\to 6):(3,1)$.\n\n对于每种情况，运行上述算法可得出以下按顶点索引顺序 $[0,1,2,3,4,5,6]$ 排列的完整距离向量：\n- 情况 1, $(\\alpha,\\beta)=(1,0)$ (纯距离): $[0,2,5,4,4,6,7]$。\n- 情况 2, $(\\alpha,\\beta)=(0,1)$ (纯风险): $[0,8,1,3,1,2,3]$。\n- 情况 3, $(\\alpha,\\beta)=(1,1)$ (等权重): $[0,10,6,8,10,11,15]$。\n- 情况 4, $(\\alpha,\\beta)=(2,1)$ (强调距离): $[0,12,11,12,19,19,26]$。\n- 情况 5, $(\\alpha,\\beta)=(1,2)$ (强调风险): $[0,18,7,12,11,13,18]$。\n- 情况 6, $(\\alpha,\\beta)=(0,0)$ (退化的零权重): $[0,0,0,0,0,0,0]$。\n- 情况 7, $(\\alpha,\\beta)=(10,10)$ (情况 3 的正向缩放): 根据缩放不变性，这等于情况 3 的 10 倍，即 $[0,100,60,80,100,110,150]$。\n- 情况 8, $(\\alpha,\\beta)=(3,0.1)$ (距离主导，带轻微风险惩罚): $[0,6.8,15.1,12.4,13.6,18.7,23.5]$。\n\n显示敏感性的解释要点：\n- 对于顶点 $6$，在 $(1,0)$ 下的最优路线是 $0\\to 1\\to 4\\to 6$，总距离为 $7$；而在 $(0,1)$ 下，最优路线是 $0\\to 2\\to 5\\to 6$，总风险为 $3$。在 $(2,1)$ 下，最佳路线变为 $0\\to 3\\to 5\\to 6$，在 $2\\mathrm{dist}+\\mathrm{risk}$ 度量下的总成本为 $26$；而在 $(3,0.1)$ 下，路线 $0\\to 1\\to 4\\to 6$ 再次成为首选，成本为 $23.5$。\n- 情况 7 在数值上确认了相对于情况 3 的缩放不变性。\n\n下面生成的程序实现了这一计算，并按照要求的外部列表顺序，打印包含八个情况向量的单行内容，其中的数字未经四舍五入且不含空格。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Execution environment: Python 3.12, numpy 1.23.5 allowed but not required.\n# This program computes single-source shortest path distances for multiple\n# scalarizations of edge attributes (distance, risk) and prints the results\n# as a single line in the required format.\n\nimport heapq\nimport math\nimport numpy as np  # Allowed; not strictly required but imported per environment spec.\n\ndef dijkstra_scalarized(graph, n_vertices, source, alpha, beta):\n    \"\"\"Compute single-source shortest paths with edge weights w = alpha*dist + beta*risk.\"\"\"\n    dist = [math.inf] * n_vertices\n    dist[source] = 0.0\n    pq = [(0.0, source)]\n    visited = [False] * n_vertices\n    while pq:\n        d_u, u = heapq.heappop(pq)\n        if visited[u]:\n            continue\n        visited[u] = True\n        # If the popped distance is greater than recorded, skip (heap invariant)\n        if d_u > dist[u]:\n            continue\n        for v, d_attr, r_attr in graph.get(u, []):\n            w = alpha * d_attr + beta * r_attr\n            new_d = d_u + w\n            if new_d  dist[v]:\n                dist[v] = new_d\n                heapq.heappush(pq, (new_d, v))\n    return dist\n\ndef format_number(x):\n    \"\"\"Format numbers: integers without decimal point; otherwise compact float.\"\"\"\n    # Treat very small negative zeros as zero\n    if abs(x)  1e-15:\n        x = 0.0\n    # If x is very close to an integer, format as integer\n    r = round(x)\n    if math.isfinite(x) and abs(x - r)  1e-9:\n        return str(int(r))\n    # Otherwise use a compact representation with up to 12 significant digits\n    return format(x, '.12g')\n\ndef solve():\n    # Graph definition: adjacency list with tuples (to, distance, risk)\n    graph = {\n        0: [(1, 2.0, 8.0), (2, 5.0, 1.0), (3, 4.0, 4.0), (4, 9.0, 1.0)],\n        1: [(3, 2.0, 7.0), (4, 2.0, 8.0), (5, 7.0, 2.0)],\n        2: [(3, 1.0, 2.0), (4, 5.0, 1.0), (5, 4.0, 1.0)],\n        3: [(4, 2.0, 4.0), (5, 2.0, 3.0)],\n        4: [(6, 3.0, 9.0)],\n        5: [(6, 3.0, 1.0)],\n        6: []\n    }\n    n_vertices = 7\n    source = 0\n\n    # Test cases: list of (alpha, beta) pairs in the specified order.\n    test_cases = [\n        (1.0, 0.0),     # Case 1\n        (0.0, 1.0),     # Case 2\n        (1.0, 1.0),     # Case 3\n        (2.0, 1.0),     # Case 4\n        (1.0, 2.0),     # Case 5\n        (0.0, 0.0),     # Case 6\n        (10.0, 10.0),   # Case 7\n        (3.0, 0.1)      # Case 8\n    ]\n\n    all_results = []\n    for alpha, beta in test_cases:\n        dist = dijkstra_scalarized(graph, n_vertices, source, alpha, beta)\n        all_results.append(dist)\n\n    # Build the exact required output: one line, outer list of 8 inner lists, no spaces.\n    inner_lists_strings = []\n    for row in all_results:\n        nums = ','.join(format_number(x) for x in row)\n        inner_lists_strings.append(f\"[{nums}]\")\n    output = f\"[{','.join(inner_lists_strings)}]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3271663"}, {"introduction": "超越静态图，这最后一个练习将探索时变网络，其中边的可用性和遍历成本随时间变化——这是现实世界交通和公共运输系统中常见的特征。本练习要求您通过动态计算到达时间来调整 Dijkstra 算法以处理动态的边成本，这是由关键的先进先出（FIFO）属性所保证的强大修改。您将计算在一个边会周期性关闭的网络中的最早到达时间。[@problem_id:3271645]", "problem": "给定一个带有时间相关遍历约束的有向图。每条有向边仅在周期性的一个区间之外可供遍历。当在建议的出发时间边不可用时，旅行者可以在边的尾顶点等待，直到该边下一次开放时再出发。只允许在顶点处等待；一旦开始，边的遍历便不会中断，并花费固定的基础时间。您的任务是，在受周期性关闭和可选的到达截止时间约束的情况下，计算最早到达时间意义上的时间相关单源最短路径。\n\n基本原理。仅使用以下基本概念作为您的出发点：\n- 有向图是一个数对 $\\left(V,E\\right)$，其中 $V$ 是一个有限的顶点集合，$E \\subseteq V \\times V$ 是一个有向边集合。\n- 路径是一个顶点序列 $\\left(v_0,v_1,\\dots,v_k\\right)$，其中对于所有的 $i$ 都有 $\\left(v_i,v_{i+1}\\right) \\in E$。路径的成本是其各边遍历时间之和。\n- 时间相关的边遍历函数为每条边和其尾顶点的每个建议出发时间，指定了在其头顶点的到达时间。在时间相关设置中，最短路径被定义为在给定源点出发时间的情况下，使得到达目的地的时间最小化的路径。\n- 先入先出 (FIFO) 属性：如果从同一顶点沿同一条边较早出发永远不会导致在该边上较晚到达，则称该时间相关遍历系统满足 FIFO 属性。\n\n模型。设 $V = \\{0,1,\\dots,n-1\\}$ 且 $E$ 如上所述。每条有向边 $e = (u,v) \\in E$ 由四个整数指定：\n- 一个基础遍历时间 $\\tau_e \\in \\mathbb{Z}_{\\ge 1}$，\n- 一个周期 $P_e \\in \\mathbb{Z}_{\\ge 1}$，\n- 一个区间 $[\\alpha_e,\\beta_e)$（其中 $0 \\le \\alpha_e  \\beta_e \\le P_e$），描述了在每个周期内，该边不可用的时间段，\n- 并且可用性以 $P_e$ 为周期。\n\n遍历的语义。如果一个旅行者建议在时间 $t \\in \\mathbb{Z}_{\\ge 0}$ 从边 $e=(u,v)$ 出发：\n- 令 $r = t \\bmod P_e$。如果 $r \\in [\\alpha_e,\\beta_e)$，则该边关闭。旅行者必须在 $u$ 处等待到时间 $t' = t + (\\beta_e - r)$，这是最早的 $\\ge t$ 且满足 $t' \\bmod P_e \\notin [\\alpha_e,\\beta_e)$ 的时间。如果 $r \\notin [\\alpha_e,\\beta_e)$，则 $t' = t$。\n- 到达 $v$ 的时间是 $t' + \\tau_e$。\n- 如果 $\\beta_e - \\alpha_e = P_e$，则该边始终关闭，因此在任何调度下都不可行。\n\n路径可行性与截止时间。对于给定的源点 $s \\in V$ 和出发时间 $t_0 \\in \\mathbb{Z}_{\\ge 0}$，将在所有遵循上述遍历语义的从 $s$ 到 $x$ 的路径中，到达 $x$ 的时间的最小值定义为到达任意顶点 $x \\in V$ 的最早到达时间。如果施加了全局到达截止时间 $T_{\\max} \\in \\mathbb{Z}_{\\ge 0}$，则只有当路径的到达时间 $\\le T_{\\max}$ 时，该路径才被认为是可行的。如果一个顶点不可达或只能在 $T_{\\max}$ 之后到达，则报告为不可行。\n\n任务。实现一个程序，为下面描述的固定图，计算具有不同源点、出发时间、截止时间和目标顶点查询集的多个测试用例的最早到达时间。\n\n图实例。设 $n = 5$，顶点为 $\\{0,1,2,3,4\\}$。有向边如下：\n- $(0,1)$，$\\tau=5$, $P=10$，关闭区间为 $[3,7)$。\n- $(1,3)$，$\\tau=4$, $P=1$，关闭区间为 $[1,1)$。\n- $(0,2)$，$\\tau=2$, $P=1$，关闭区间为 $[1,1)$。\n- $(2,3)$，$\\tau=7$, $P=10$，关闭区间为 $[4,6)$。\n- $(1,2)$，$\\tau=3$, $P=6$，关闭区间为 $[5,6)$。\n- $(2,1)$，$\\tau=3$, $P=6$，关闭区间为 $[0,1)$。\n- $(3,2)$，$\\tau=1$, $P=5$，关闭区间为 $[2,3)$。\n- $(2,4)$，$\\tau=8$, $P=5$，关闭区间为 $[0,5)$。\n- $(0,3)$，$\\tau=30$, $P=10$，关闭区间为 $[0,10)$。\n\n注意，对于边 $(2,4)$ 和 $(0,3)$，由于 $\\beta - \\alpha = P$，这些边始终关闭，应被视为不可行。\n\n需要遵守的可行性约束：\n- 只允许在顶点处等待，不允许在边内等待。\n- 边的可用性在出发时检查；一旦遍历开始，将不间断地产生基础遍历时间 $\\tau$。\n- 关闭区间是半开区间 $[\\alpha,\\beta)$，因此在时间 $t$ 满足 $t \\bmod P = \\beta$ 时出发是被允许的。\n- 您的算法所使用的边遍历函数必须满足 FIFO 属性。\n- 如果查询的目的地的最早到达时间超过 $T_{\\max}$ 或该目的地不可达，则报告为不可行，记为 $-1$。\n\n测试套件。计算以下五个测试用例的结果：\n- 测试 $1$：$s=0$, $t_0=0$, $T_{\\max}=100$，目的地 $\\{3,4\\}$。\n- 测试 $2$：$s=0$, $t_0=5$, $T_{\\max}=100$，目的地 $\\{1,3\\}$。\n- 测试 $3$：$s=0$, $t_0=7$, $T_{\\max}=20$，目的地 $\\{1,3\\}$。\n- 测试 $4$：$s=0$, $t_0=4$, $T_{\\max}=12$，目的地 $\\{3\\}$。\n- 测试 $5$：$s=1$, $t_0=0$, $T_{\\max}=100$，目的地 $\\{4\\}$。\n\n答案规范和输出格式：\n- 对于每个测试，按给定顺序输出一个整数列表，对应于每个目的地的最早到达时间，不可行的情况报告为 $-1$。\n- 将五个测试的结果汇总成一个列表的列表，并打印一行包含此汇总结果的内容，格式为方括号和逗号分隔，不含空格，例如 $[[a,b],[c,d]]$。\n- 您的程序必须严格按照此格式产生一行输出，且不得读取任何输入。\n- 您的实现必须是一个完整的程序，执行计算并打印汇总结果。不允许外部输入、文件或网络访问。", "solution": "该问题要求在边遍历时间是时间相关的有向图中计算单源最短路径。这是一个经典的算法问题，一个稳健的解决方案必须基于图上最短路径的理论。\n\n对问题陈述的验证证实了其是适定的、科学上合理的，并且提供了所有必要的数据和约束。一个关键方面是时间相关遍历成本的性质。每条边 $e=(u,v)$ 有一个基础遍历时间 $\\tau_e$ 并受周期性不可用性的影响。如果在时间 $t$ 从顶点 $u$ 出发时，$t \\bmod P_e \\in [\\alpha_e, \\beta_e)$，则该边关闭，其中 $P_e$ 是周期，$[\\alpha_e, \\beta_e)$ 是每个周期内的关闭区间。如果旅行者在时间 $t$ 到达 $u$ 并发现边 $e$ 关闭，他们必须在 $u$ 等待直到该边重新开放。到达 $v$ 的时间是从 $u$ 的实际出发时间加上基础遍历时间 $\\tau_e$。\n\n这种等待机制为每条边 $e$ 定义了一个时间相关的到达时间函数 $A_e(t)$，该函数给出在尾部建议出发时间为 $t$ 时，在头部对应的到达时间。此类问题的一个基本属性是先入先出 (FIFO) 或非超越属性，即较晚出发不会导致较早到达。形式上，对于任意两个建议的出发时间 $t_1 \\le t_2$，必须有 $A_e(t_1) \\le A_e(t_2)$。问题陈述要求此属性必须成立，对给定遍历语义的简要分析也证实了这一点。实际出发时间 $\\text{departure}_e(t)$ 是建议出发时间 $t$ 的一个非递减函数，并且由于基础遍历时间 $\\tau_e$ 是一个正常数，到达时间函数 $A_e(t) = \\text{departure}_e(t) + \\tau_e$ 也是非递减的。\n\nFIFO 属性的有效性至关重要，因为它保证了类似于用于静态图的 Dijkstra 算法的贪心方法能够找到最优解。在这种情况下，到一个顶点的“距离”是其可能的最早到达时间。因此，该算法是 Dijkstra 算法的一个变体。\n\n对于给定的源顶点 $s \\in V$、初始出发时间 $t_0 \\in \\mathbb{Z}_{\\ge 0}$ 和截止时间 $T_{\\max} \\in \\mathbb{Z}_{\\ge 0}$，算法流程如下：\n1. 一个大小为 $n$ 的数组 `earliest_arrival`（其中 $n$ 是顶点数）被初始化为无穷大，用于存储所有顶点的已知最早到达时间。源点 $s$ 的到达时间被设置为出发时间 $t_0$。\n2. 使用一个最小优先队列来管理接下来要访问的顶点。它存储形如 $(arrival\\_time, vertex\\_id)$ 的元组，并按 `arrival_time` 排序。初始时，它只包含 $(t_0, s)$。\n3. 算法从优先队列中重复提取具有最小到达时间（设为 `current_time`）的顶点 $u$。如果 `current_time` 大于已记录的 `earliest_arrival[u]`，则此路径非最优，我们将其丢弃。\n4. 对于每个出边 $e=(u,v)$，我们计算在 $v$ 的到达时间。从 $u$ 的建议出发时间是 `current_time`。我们通过考虑由边的关闭时间表决定的任何等待期来确定实际出发时间。令 $t_{propose} = \\text{current\\_time}$。周期内的时间是 $r = t_{propose} \\bmod P_e$。如果 $r \\in [\\alpha_e, \\beta_e)$，旅行者必须等待；实际出发时间变为 $t_{depart} = t_{propose} + (\\beta_e - r)$。否则，$t_{depart} = t_{propose}$。那么在 $v$ 的到达时间是 $A_e(t_{propose}) = t_{depart} + \\tau_e$。\n5. 将这个在 $v$ 的新到达时间与 `earliest_arrival[v]` 进行比较。如果它更小，我们就找到了一个时间上更短的路径。我们更新 `earliest_arrival[v]` 并将新的数对 $(A_e(t_{propose}), v)$ 插入优先队列。\n6. 这个过程持续进行，直到优先队列为空。最终的 `earliest_arrival` 数组包含了所有可达顶点的最小到达时间。\n\n最后，对于每个测试用例中查询的目标顶点，将其计算出的最早到达时间与截止时间 $T_{\\max}$ 进行比较。如果到达时间大于 $T_{\\max}$ 或顶点不可达（到达时间仍为无穷大），则该路径被视为不可行，并报告为 $-1$。否则，整数到达时间即为结果。被标记为始终关闭的边（其中 $\\beta_e - \\alpha_e = P_e$）被视为不存在。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main function to define the graph, test cases, and compute the results.\n    \"\"\"\n\n    # Model: Graph definition\n    # The graph is represented as an adjacency list.\n    # graph[u] contains a list of tuples (v, tau, P, alpha, beta) for each edge (u, v).\n    n = 5\n    graph = [[] for _ in range(n)]\n    \n    # Edge data from the problem statement: u, v, tau, P, alpha, beta\n    edges = [\n        (0, 1, 5, 10, 3, 7),\n        (1, 3, 4, 1, 1, 1),\n        (0, 2, 2, 1, 1, 1),\n        (2, 3, 7, 10, 4, 6),\n        (1, 2, 3, 6, 5, 6),\n        (2, 1, 3, 6, 0, 1),\n        (3, 2, 1, 5, 2, 3),\n        (2, 4, 8, 5, 0, 5),    # Always closed\n        (0, 3, 30, 10, 0, 10), # Always closed\n    ]\n    \n    for u, v, tau, P, alpha, beta in edges:\n        graph[u].append((v, tau, P, alpha, beta))\n        \n    # Test suite: s, t0, T_max, destinations\n    test_cases = [\n        {'s': 0, 't0': 0, 't_max': 100, 'dests': [3, 4]},\n        {'s': 0, 't0': 5, 't_max': 100, 'dests': [1, 3]},\n        {'s': 0, 't0': 7, 't_max': 20, 'dests': [1, 3]},\n        {'s': 0, 't0': 4, 't_max': 12, 'dests': [3]},\n        {'s': 1, 't0': 0, 't_max': 100, 'dests': [4]},\n    ]\n    \n    all_results = []\n    # Execute the algorithm for each test case\n    for case in test_cases:\n        result = _compute_earliest_arrivals(\n            graph, case['s'], case['t0'], case['t_max'], case['dests']\n        )\n        all_results.append(result)\n\n    # Format the final output string according to the specification\n    # e.g., [[-1],[1,2],...] with no whitespace\n    output_str = '[' + ','.join(f'[{\",\".join(map(str, r))}]' for r in all_results) + ']'\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\ndef _compute_earliest_arrivals(graph, s, t0, t_max, destinations):\n    \"\"\"\n    Computes earliest arrival times from a source `s` departing at `t0`.\n    \n    Args:\n        graph (list): Adjacency list representation of the graph.\n        s (int): Source vertex.\n        t0 (int): Departure time from the source.\n        t_max (int): Global arrival deadline.\n        destinations (list): List of destination vertices to query.\n        \n    Returns:\n        list: A list of earliest arrival times for the specified destinations.\n              -1 indicates infeasibility (unreachable or arrival > t_max).\n    \"\"\"\n    n = len(graph)\n    earliest_arrival = [np.inf] * n\n    earliest_arrival[s] = t0\n    \n    # Priority queue stores tuples of (arrival_time, vertex)\n    pq = [(t0, s)]\n    \n    while pq:\n        current_time, u = heapq.heappop(pq)\n        \n        # If we have found a shorter path to u, this entry is stale.\n        if current_time > earliest_arrival[u]:\n            continue\n            \n        # Explore neighbors\n        for v, tau, P, alpha, beta in graph[u]:\n            # As per problem spec, edges with beta-alpha = P are always closed.\n            if beta - alpha == P:\n                continue\n\n            t_propose = current_time\n            r = t_propose % P\n            \n            # Check if proposed departure falls within a closed interval\n            if alpha = r  beta:\n                # Wait until the interval ends. Wait time is beta - r.\n                t_depart = t_propose + (beta - r)\n            else:\n                # Edge is open, no wait required.\n                t_depart = t_propose\n            \n            arrival_at_v = t_depart + tau\n            \n            # Dijkstra's relaxation step\n            if arrival_at_v  earliest_arrival[v]:\n                earliest_arrival[v] = arrival_at_v\n                heapq.heappush(pq, (arrival_at_v, v))\n                \n    # Collect results for queried destinations\n    results = []\n    for dest in destinations:\n        res = earliest_arrival[dest]\n        # Check against deadline. np.inf > t_max is true.\n        if res > t_max:\n            results.append(-1)\n        else:\n            results.append(int(res))\n            \n    return results\n\nsolve()\n```", "id": "3271645"}]}