{"hands_on_practices": [{"introduction": "理论学习之后，最重要的就是亲手实现。这个练习将带你从最原始的图表示——边列表——出发，构建邻接表并实现基于深度优先搜索（$DFS$）的环路检测算法。通过这个练习[@problem_id:3224952]，你不仅能掌握环路检测的核心逻辑，还能熟悉处理实际数据时常见的图构建步骤，为解决更复杂的问题打下坚实的基础。", "problem": "对于每个测试用例，您只得到一个有向边列表，而没有明确的邻接表或邻接矩阵。有向图定义为 $G = (V, E)$，其中 $V$ 是一个有限的顶点集合，$E \\subseteq V \\times V$ 是一个表示有向边的有序对的有限集合。有向路径是一个有限的顶点序列 $v_0, v_1, \\dots, v_k$，使得对于所有满足 $0 \\le i  k$ 的索引 $i$，都有 $(v_i, v_{i+1}) \\in E$。有向环是一条长度至少为 $1$ 的有向路径，其起始顶点与结束顶点相同；形式上，存在顶点序列 $v_0, v_1, \\dots, v_k$，$k \\ge 1$，使得对于所有满足 $0 \\le i  k$ 的索引 $i$，都有 $(v_i, v_{i+1}) \\in E$，且 $v_0 = v_k$。如果一个有向图不包含任何有向环，则称其为无环图。一个经过充分验证的事实是：一个有向图是无环的，当且仅当它的顶点允许进行拓扑排序。每个测试用例的顶点集是该测试用例边列表中出现的所有端点的集合；没有关联边的顶点不会给出，也无需推断，因为它们不可能是任何有向环的一部分。\n\n您的任务是编写一个完整的、可运行的程序，该程序为每个测试用例从提供的边列表中构建所需的任何内部表示，并判断该有向图是否包含至少一个有向环。每个测试用例的输出必须是一个布尔值：如果存在有向环，则为 $True$，否则为 $False$。程序不得假定除给定边列表之外的任何额外输入，并且必须对以下实际情况具有鲁棒性：重复边、自环、不连通分量和空边列表。\n\n请使用以下包含 $7$ 个测试用例的测试套件，每个测试用例都指定为一个有序对 $(u, v)$ 的列表，表示从顶点 $u$ 到顶点 $v$ 的一条有向边：\n- 测试用例 $1$：边 $[(1, 2), (2, 3), (3, 4)]$。\n- 测试用例 $2$：边 $[(1, 2), (2, 3), (3, 1)]$。\n- 测试用例 $3$：边 $[(5, 5)]$。\n- 测试用例 $4$：边 $[(10, 11), (11, 12), (12, 10), (20, 21)]$。\n- 测试用例 $5$：边 $[]$。\n- 测试用例 $6$：边 $[(0, 1), (0, 1), (1, 2), (0, 2)]$。\n- 测试用例 $7$：边 $[(100, 101), (101, 102), (102, 103), (103, 104), (104, 105), (105, 100), (106, 107)]$。\n\n最终输出格式：您的程序应生成单行输出，其中包含这 $7$ 个测试用例的结果，结果为逗号分隔的列表，并用方括号括起来，顺序如上所示（例如，$[True,False,True,\\dots]$）。不允许有其他输出。", "solution": "该问题要求判断一个由边列表指定的有向图是否包含至少一个环。解决方案必须对各种图结构具有鲁棒性，包括不连通分量、自环和重复边。解决这个问题的基本方法是在图上执行深度优先搜索 (DFS)，同时维护每个顶点的状态以检测反向边，反向边是存在环的标志。\n\n这个问题可以分解为两个主要部分：首先，从给定的边列表构建一个合适的图表示；其次，在该表示上实现一个环检测算法。\n\n### 原理 1：从边列表构建图表示\n\n有向图定义为一对 $G = (V, E)$，其中 $V$ 是顶点集，$E$ 是有向边集。输入是一个边列表，例如 $[(u_1, v_1), (u_2, v_2), \\dots]$。据此，我们首先需要确定顶点集 $V$，然后构建边 $E$ 的结构以便于高效遍历。\n\n1.  **顶点集构建**：问题规定，顶点集 $V$ 由任何边中作为端点出现的所有唯一顶点组成。我们可以通过遍历边列表并将所有唯一的顶点标识符收集到一个集合中来获得 $V$。对于像 $[(1, 2), (2, 3)]$ 这样的边列表，顶点集是 $V = \\{1, 2, 3\\}$。\n\n2.  **邻接表**：对于像 DFS 这样的图遍历算法，邻接表是一种常见且高效的表示方法。邻接表是每个顶点 $u \\in V$ 到一个顶点集合 $v$ 的映射，其中存在边 $(u, v) \\in E$。字典（或哈希映射）是实现这一点的理想数据结构，其中键是顶点，值是其相邻邻居的列表。\n\n    构建邻接表的过程如下：\n    - 初始化一个空字典，例如 `adj`。\n    - 对于已确定的顶点集 $V$ 中的每个顶点 $u$，初始化 `adj[u] = []`。\n    - 遍历输入列表中的每条边 $(u, v)$，并将 $v$ 追加到列表 `adj[u]` 中。\n\n这种构建方式自然地处理了指定的条件：\n-   **重复边**：如果一条边 $(u, v)$ 出现多次，$v$ 将被多次追加到 `adj[u]` 中。这是可以接受的；环检测逻辑仍然正确，因为它关心的是可达性，而不是路径的数量。\n-   **自环**：一条边 $(u, u)$ 将导致 $u$ 出现在其自身的邻接列表 `adj[u]` 中。\n-   **空边列表**：如果 $E = \\emptyset$，则 $V = \\emptyset$。邻接表将为空，算法将正确地得出结论，即不存在环。\n\n### 原理 2：使用深度优先搜索进行环检测\n\n一个有向图包含一个环，当且仅当深度优先搜索 (DFS) 遍历发现了一条“反向边”。反向边是指从一个顶点 $u$ 指向其在 DFS 树中某个祖先 $v$ 的边。为了识别反向边，我们必须在遍历过程中跟踪每个顶点的状态。每个顶点可以处于以下三种状态之一：\n1.  **未访问 (白色)**：该顶点尚未被访问。\n2.  **正在访问 (灰色)**：该顶点当前位于 DFS 的递归堆栈中。这意味着我们已经开始从这个顶点进行探索，但尚未完成对其所有后代的探索。这些是当前节点的祖先。\n3.  **已访问 (黑色)**：该顶点及其所有后代都已被完全探索。\n\n当在探索顶点 $u$ 的过程中，我们遇到了一个当前处于“正在访问”状态的邻居 $v$ 时，就检测到了一个环。这意味着我们找到了一条从 $u$ 指向其某个祖先 $v$ 的反向边，从而完成了一个环。\n\n该算法按以下步骤进行：\n-   初始化两个集合：`visiting`（用于灰色顶点）和 `visited`（用于黑色顶点）。\n-   遍历 $V$ 中的每个顶点 $u$。\n-   如果 $u$ 尚未被完全 `visited`，则从 $u$ 开始进行 DFS 遍历。\n-   如果从任何顶点开始的 DFS 遍历返回找到了环，算法可以终止并报告 `True`。\n-   如果对所有未访问的顶点都运行了 DFS 并且没有发现环，则该图是无环的，结果为 `False`。这种迭代方法确保了图的所有不连通分量都得到检查。\n\n递归 DFS 函数，例如 `dfs(u)`，工作方式如下：\n1.  将顶点 $u$ 添加到 `visiting` 集合中，标记其为“正在访问”。\n2.  对于 $u$ 的每个邻居 $v$：\n    a. 如果 $v$ 在 `visiting` 集合中，则说明找到了一条反向边 $(u, v)$。存在一个环。返回 `True`。\n    b. 如果 $v$ 不在 `visited` 集合中（以避免重新探索已完成的子树），则递归调用 `dfs(v)`。如果此递归调用返回 `True`，则意味着在下游发现了环，因此将 `True` 沿着调用栈向上传播。\n3.  一旦处理完 $u$ 的所有邻居，从 $u$ 开始的探索就完成了。将 $u$ 从 `visiting` 中移除并添加到 `visited` 中，标记其为“已访问”。\n4.  如果函数尚未返回 `True`，则意味着在从 $u$ 可达的（之前未访问过的）子图中没有发现环。返回 `False`。\n\n让我们用测试用例 $2$：边 $[(1, 2), (2, 3), (3, 1)]$ 来举例说明。\n-   $V = \\{1, 2, 3\\}$。邻接表：`adj = {1: [2], 2: [3], 3: [1]}`。\n-   初始化 `visiting = {}`, `visited = {}`。\n-   从顶点 $1$ 开始 DFS：调用 `dfs(1)`。\n    -   将 $1$ 添加到 `visiting`。`visiting = {1}`。\n    -   $1$ 的邻居是 $2$。$2$ 不在 visiting/visited 中。调用 `dfs(2)`。\n        -   将 $2$ 添加到 `visiting`。`visiting = {1, 2}`。\n        -   $2$ 的邻居是 $3$。$3$ 不在 visiting/visited 中。调用 `dfs(3)`。\n            -   将 $3$ 添加到 `visiting`。`visiting = {1, 2, 3}`。\n            -   $3$ 的邻居是 $1$。检查顶点 $1$ 的状态。\n            -   顶点 $1$ 在 `visiting` 集合中。这是一条反向边。检测到环。\n            -   `dfs(3)` 返回 `True`。\n        -   `dfs(2)` 从 `dfs(3)` 收到 `True` 并返回 `True`。\n    -   `dfs(1)` 从 `dfs(2)` 收到 `True` 并返回 `True`。\n-   主循环接收到 `True` 并得出结论：该图有环。结果为 `True`。\n\n该算法既正确又完整，满足了问题的所有要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Solves the cycle detection problem for a suite of test cases.\n    \"\"\"\n\n    # Test suite of 7 test cases, each specified as a list of directed edges.\n    test_cases = [\n        # Test case 1: A directed acyclic graph (path).\n        [(1, 2), (2, 3), (3, 4)],\n        # Test case 2: A simple cycle.\n        [(1, 2), (2, 3), (3, 1)],\n        # Test case 3: A self-loop.\n        [(5, 5)],\n        # Test case 4: A disconnected graph with one component having a cycle.\n        [(10, 11), (11, 12), (12, 10), (20, 21)],\n        # Test case 5: An empty graph.\n        [],\n        # Test case 6: A DAG with duplicate edges.\n        [(0, 1), (0, 1), (1, 2), (0, 2)],\n        # Test case 7: A more complex graph with a cycle and a separate path.\n        [(100, 101), (101, 102), (102, 103), (103, 104), (104, 105), (105, 100), (106, 107)]\n    ]\n\n    def has_cycle(edges: list[tuple[int, int]]) -> bool:\n        \"\"\"\n        Determines if a directed graph contains a cycle using Depth-First Search.\n\n        The graph is defined by a list of edges. The algorithm tracks vertex states\n        (unvisited, visiting, visited) to detect back edges, which indicate a cycle.\n\n        Args:\n            edges: A list of tuples, where each tuple (u, v) represents a\n                   directed edge from vertex u to vertex v.\n\n        Returns:\n            True if the graph contains at least one cycle, False otherwise.\n        \"\"\"\n        if not edges:\n            return False\n\n        # Build the vertex set and adjacency list from the edge list.\n        # The vertex set V is the set of all endpoints appearing in the edge list.\n        vertices = set()\n        adj = {}\n        for u, v in edges:\n            vertices.add(u)\n            vertices.add(v)\n        \n        for vertex in vertices:\n            adj[vertex] = []\n\n        for u, v in edges:\n            adj[u].append(v)\n\n        # `visiting` set tracks nodes in the current recursion stack (gray nodes).\n        # `visited` set tracks nodes that have been fully explored (black nodes).\n        visiting = set()\n        visited = set()\n\n        def _dfs(node):\n            \"\"\"Recursive DFS helper function to detect cycles.\"\"\"\n            visiting.add(node)\n\n            for neighbor in adj.get(node, []):\n                if neighbor in visiting:\n                    # A back edge is found, indicating a cycle.\n                    return True\n                if neighbor not in visited:\n                    if _dfs(neighbor):\n                        return True\n            \n            # All descendants from 'node' are explored.\n            visiting.remove(node)\n            visited.add(node)\n            return False\n\n        # Iterate through all vertices to handle disconnected components.\n        # sorted() is used for deterministic behavior, although not strictly necessary for correctness.\n        for vertex in sorted(list(vertices)):\n            if vertex not in visited:\n                if _dfs(vertex):\n                    return True\n        \n        return False\n\n    results = []\n    for case in test_cases:\n        result = has_cycle(case)\n        results.append(result)\n\n    # Format the final output as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver.\nsolve()\n```", "id": "3224952"}, {"introduction": "掌握一个算法不仅要知道它如何工作，更要理解它为何这样设计。本练习[@problem_id:3224987]提供了一个有缺陷的环路检测程序，它错误地修改了$DFS$中节点“涂黑”的规则。你的任务是像一名代码审查员一样，通过细致地追踪算法在特定图上的执行过程，找出其失败的根本原因，从而深刻理解标准$DFS$算法中三色标记法（白、灰、黑）的精妙之处和正确性保证。", "problem": "给定一个有向图 $G=(V,E)$，其中 $V=\\{1,2,3,4\\}$ 且 $E=\\{(1,2),(1,4),(2,4),(2,3),(3,1)\\}$。邻接表固定为 $\\mathrm{Adj}[1]=[2,4]$，$\\mathrm{Adj}[2]=[4,3]$，$\\mathrm{Adj}[3]=[1]$，$\\mathrm{Adj}[4]=[\\ ]$。遍历总是按顶点数值递增的顺序进行，并且在每个邻接表内部，边按从左到右的顺序扫描。\n\n考虑以下有问题的环检测过程，该过程旨在模仿使用标准白-灰-黑三色标记法的深度优先搜索（DFS），但修改了顶点变黑的时机。该过程为每个顶点 $u\\in V$ 维护一个颜色 $\\mathrm{color}[u]\\in\\{\\text{white},\\text{gray},\\text{black}\\}$，初始时均为白色。对于按递增顺序排列的每个 $u$，如果 $\\mathrm{color}[u]=\\text{white}$，则调用 $\\mathrm{Explore}(u)$。子程序 $\\mathrm{Explore}(u)$ 的操作如下：\n- 设置 $\\mathrm{color}[u]\\leftarrow\\text{gray}$。\n- 对于 $\\mathrm{Adj}[u]$ 中给出的顺序的每条边 $(u,v)\\in E$：\n  - 如果 $\\mathrm{color}[v]=\\text{white}$，则调用 $\\mathrm{Explore}(v)$。\n  - 如果 $\\mathrm{color}[v]=\\text{gray}$，算法意图检测一个有向环（如同在正确的 DFS 中一样），但请见下一条。\n- 有问题的涂黑规则：当 $u$ 为灰色时，一旦 $u$ 的所有出边邻居 $v$ 都变为非白色（即 $\\mathrm{color}[v]\\in\\{\\text{gray},\\text{black}\\}$），即使某些这样的 $v$ 仍然是灰色（它们的 $\\mathrm{Explore}$ 调用尚未结束），也立即将 $\\mathrm{color}[u]\\leftarrow\\text{black}$。\n算法仅当在扫描边 $(x,y)$ 的那一刻 $\\mathrm{color}[y]=\\text{gray}$ 时，才报告“检测到环”。否则，如果没有发生这样的扫描，它就报告“无环”。\n\n在你的推理中仅使用基本定义：有向环是一个顶点序列 $u_1,u_2,\\dots,u_k$（$k\\ge 2$），满足对所有 $i\\in\\{1,\\dots,k-1\\}$ 有 $(u_i,u_{i+1})\\in E$ 且 $(u_k,u_1)\\in E$；正确的带递归的 DFS 仅在所有从 $u$ 出发通过树边可达的后代都完成（标记为黑色）之后，才完成对顶点 $u$ 的处理（将其标记为黑色）；一条后向边是指从一个顶点到当前递归栈上（灰色集合中）的一个祖先顶点的边，它的存在等价于一个有向环的存在。\n\n问题：在图 $G$ 上按指定顺序运行这个有问题的算法，哪个选项最能解释其结果以及任何失败的精确原因？\n\nA. 算法错误地报告“无环”，因为它在扫描 $(3,1)$ 之前，一旦 $(1,2)$ 和 $(1,4)$ 都指向非白色顶点（此时 2 为灰色，4 为黑色）时，就过早地将顶点 1 涂黑；之后，扫描 $(3,1)$ 时其目标顶点是黑色而非灰色，因此后向边 $3\\to 1$ 未被识别，有向环 $1\\to 2\\to 3\\to 1$ 被错过。\n\nB. 算法正确地报告“有环”，因为在扫描 $(3,1)$ 时它遇到了一个灰色邻居，这在 DFS 中是一条后向边，因此环 $1\\to 2\\to 3\\to 1$ 被检测到。\n\nC. 该算法仅当遍历从顶点 4 而非顶点 1 开始时才会失败；在给定的从 1 开始的顺序下，它不能过早地将一个祖先顶点涂黑，因此仍然能检测到环。\n\nD. 该算法不会错过环，只可能产生假阳性（误报），因为任何指向先前访问过的顶点（灰色或黑色）的边都被视为后向边；因此它会因为 $(2,4)$ 而报告“有环”。", "solution": "用户要求对问题陈述进行批判性验证，然后详细推导解决方案，并对所有提供的选项进行评估。\n\n### 步骤1：提取已知条件\n\n-   **图**：一个有向图 $G=(V,E)$。\n-   **顶点**：$V=\\{1,2,3,4\\}$。\n-   **边**：$E=\\{(1,2),(1,4),(2,4),(2,3),(3,1)\\}$。\n-   **邻接表**：$\\mathrm{Adj}[1]=[2,4]$，$\\mathrm{Adj}[2]=[4,3]$，$\\mathrm{Adj}[3]=[1]$，$\\mathrm{Adj}[4]=[\\ ]$。\n-   **遍历顺序**：主循环按顶点数值递增的顺序（1,2,3,4）迭代。邻接表按指定的从左到右的顺序扫描。\n-   **算法状态**：每个顶点 $u$ 有一个颜色，$\\mathrm{color}[u]\\in\\{\\text{white},\\text{gray},\\text{black}\\}$，初始为白色。\n-   **算法主循环**：对于每个 $u \\in \\{1,2,3,4\\}$，如果 $\\mathrm{color}[u]=\\text{white}$，则调用 $\\mathrm{Explore}(u)$。\n-   **子程序 `Explore(u)`**：\n    1.  设置 $\\mathrm{color}[u]\\leftarrow\\text{gray}$。\n    2.  对于 $u$ 的每个邻居 $v$（按 $\\mathrm{Adj}[u]$ 顺序）：\n        -   如果 $\\mathrm{color}[v]=\\text{white}$，则调用 $\\mathrm{Explore}(v)$。\n        -   如果 $\\mathrm{color}[v]=\\text{gray}$，则（有条件地）检测到一个环（见下文）。\n-   **有问题的涂黑规则**：一个当前为灰色的顶点 $u$，一旦其所有出边邻居 $v$ 都为非白色（即 $\\mathrm{color}[v]\\in\\{\\text{gray},\\text{black}\\}$），就立即被涂成黑色。这可能在对 $u$ 或其后代的 `Explore` 调用过程中发生。\n-   **环报告**：算法当且仅当扫描到一条边 $(x,y)$ 且在那一刻 $\\mathrm{color}[y]=\\text{gray}$ 时，报告“检测到环”。否则，报告“无环”。\n\n### 步骤2：使用提取的已知条件进行验证\n\n-   **科学基础**：该问题属于计算机科学领域，特别是图算法。所有概念，如-有向图、深度优先搜索（DFS）、顶点着色和环检测，都是标准且明确定义的。这个“有问题的”过程是对标准算法的修改，这是测试对基本原理深入理解的常见有效方法。该问题在数学和逻辑上是健全的。\n-   **良态的**：图的结构、遍历顺序和算法规则（包括有问题的规则）都得到了精确无歧义的规定。这确保了算法的执行是确定性的，会产生唯一的结果。该问题是良态的。\n-   **客观性**：问题以精确、客观的语言陈述，没有任何主观性或歧义。\n\n问题陈述在科学或事实上没有不健全之处，是可形式化的，是完整的，是计算上可行的，是定义明确的，并且由于错误规则的微妙性而并非微不足道。\n\n### 步骤3：结论与行动\n\n问题是**有效的**。可以进行详细分析。\n\n### 解决方案推导\n\n我们将追踪指定有问题的算法在图 $G$ 上的执行过程。颜色缩写为 $W$ (white)，$G$ (gray)，和 $B$ (black)。初始状态是顶点 $[1, 2, 3, 4]$ 的 $\\mathrm{color} = [W, W, W, W]$。递归栈由 `Explore` 调用的序列表示。\n\n1.  **主循环**：从 $u=1$ 开始。$\\mathrm{color}[1]$ 为 $W$。调用 $\\mathrm{Explore}(1)$。\n    -   **`Explore(1)`**：设置 $\\mathrm{color}[1] \\leftarrow G$。\n        -   状态：$[G, W, W, W]$。栈：`[Explore(1)]`。\n    -   检查 1 的邻居：$\\mathrm{Adj}[1]=[2,4]$。第一个是 $v=2$。\n    -   $\\mathrm{color}[2]$ 是 $W$。调用 $\\mathrm{Explore}(2)$。\n        -   **`Explore(2)`**：设置 $\\mathrm{color}[2] \\leftarrow G$。\n            -   状态：$[G, G, W, W]$。栈：`[Explore(1), Explore(2)]`。\n        -   检查 2 的邻居：$\\mathrm{Adj}[2]=[4,3]$。第一个是 $w=4$。\n        -   $\\mathrm{color}[4]$ 是 $W$。调用 `Explore(4)`。\n            -   **`Explore(4)`**：设置 $\\mathrm{color}[4] \\leftarrow G$。\n                -   状态：$[G, G, W, G]$。栈：`[Explore(1), Explore(2), Explore(4)]`。\n            -   检查 4 的邻居：$\\mathrm{Adj}[4]=[\\ ]$。循环为空。\n            -   **对顶点 4 的错误规则检查**：将灰色顶点 $u$ 涂黑的条件是其所有出边邻居都是非白色的。对于顶点4，其邻居集合为空，因此该条件不言自明地成立。\n            -   立即设置 $\\mathrm{color}[4] \\leftarrow B$。\n                -   状态：$[G, G, W, B]$。\n            -   **错误规则全局检查**：$\\mathrm{color}[4]$ 从 $W$ 变为 $B$（通过 $G$）是一个可能触发其他灰色顶点变黑的事件。短语“一旦...立即”意味着此检查不会延迟。我们必须检查所有当前为灰色的顶点：1 和 2。\n                -   检查顶点 2（灰色）：邻居是 4, 3。$\\mathrm{color}[4]=B$，但 $\\mathrm{color}[3]=W$。条件不满足。\n                -   检查顶点 1（灰色）：邻居是 2, 4。$\\mathrm{color}[2]=G$（非白色）且 $\\mathrm{color}[4]=B$（非白色）。1 的所有邻居现在都是非白色的。条件满足。\n                -   立即设置 $\\mathrm{color}[1] \\leftarrow B$。\n                    -   状态：$[B, G, W, B]$。\n            -   `Explore(4)` 调用结束并返回。\n\n        -   回到 `Explore(2)` 中。现在的状态是 $[B, G, W, B]$。调用栈是 `[Explore(1), Explore(2)]`。注意，当我们处在更深的递归中时，$\\mathrm{color}[1]$ 变成了黑色。\n        -   继续检查 2 的邻居。下一个是 $w=3$。\n        -   $\\mathrm{color}[3]$ 是 $W$。调用 `Explore(3)`。\n            -   **`Explore(3)`**：设置 $\\mathrm{color}[3] \\leftarrow G$。\n                -   状态：$[B, G, G, B]$。栈：`[Explore(1), Explore(2), Explore(3)]`。\n            -   **错误规则全局检查**：$\\mathrm{color}[3] \\leftarrow G$ 的变化是另一个触发事件。我们检查所有灰色顶点：2 和 3。\n                -   检查顶点 2（灰色）：邻居是 4, 3。$\\mathrm{color}[4]=B$ 且 $\\mathrm{color}[3]=G$。两者都是非白色的。条件满足。立即设置 $\\mathrm{color}[2] \\leftarrow B$。\n                    -   状态：$[B, B, G, B]$。\n                -   检查顶点 3（灰色）：邻居是 1。$\\mathrm{color}[1]=B$（非白色）。条件满足。立即设置 $\\mathrm{color}[3] \\leftarrow B$。\n                    -   状态：$[B, B, B, B]$。\n            -   现在，`Explore(3)` 继续执行。状态是 $[B, B, B, B]$。\n            -   检查 3 的邻居：$\\mathrm{Adj}[3]=[1]$。\n            -   扫描边 $(3,1)$。检查 $\\mathrm{color}[1]$。它是 $B$。\n            -   报告环的条件是 $\\mathrm{color}[\\text{neighbor}] = G$。由于 $\\mathrm{color}[1]$ 是 $B$，这里不会报告环。\n            -   `Explore(3)` 循环结束。该顶点已经是黑色。它返回。\n\n        -   回到 `Explore(2)`。其邻居的循环已结束。该顶点已经是黑色。它返回。\n    -   回到 `Explore(1)`。循环继续到它的下一个邻居 $v=4$。\n    -   $\\mathrm{color}[4]$ 是 $B$。不执行任何操作。\n    -   `Adj[1]` 的循环结束。该顶点已经是黑色。`Explore(1)` 返回。\n\n2.  **主循环**：继续。$u=2$，$\\mathrm{color}[2]$ 是 $B$。跳过。$u=3$，$\\mathrm{color}[3]$ 是 $B$。跳过。$u=4$，$\\mathrm{color}[4]$ 是 $B$。跳过。\n3.  **终止**：算法终止。在执行过程中，从未在 $\\mathrm{color}[y]$ 为灰色时扫描过边 $(x,y)$。算法报告“无环”。\n\n算法错误地未能检测到环 $1 \\to 2 \\to 3 \\to 1$。失败的原因是，顶点1，作为 `Explore(3)` 递归栈上的一个祖先，被过早地涂成了黑色。当检查边 $(3,1)$（在正确的 DFS 中是一条后向边）时，顶点1被看作是黑色而不是灰色，从而掩盖了环的存在。\n\n### 逐项选项分析\n\n**A. 算法错误地报告“无环”，因为它在扫描 $(3,1)$ 之前，一旦 $(1,2)$ 和 $(1,4)$ 都指向非白色顶点（此时 2 为灰色，4 为黑色）时，就过早地将顶点 1 涂黑；之后，扫描 $(3,1)$ 时其目标顶点是黑色而非灰色，因此后向边 $3\\to 1$ 未被识别，有向环 $1\\to 2\\to 3\\to 1$ 被错过。**\n-   追踪过程显示算法报告“无环”，这是不正确的。\n-   追踪过程显示顶点1被过早地涂黑。\n-   触发这次涂黑的事件是它的邻居 2 和 4 都变成了非白色。触发此事件的具体状态是当 `Explore(4)` 结束（使 $\\mathrm{color}[4]=B$）而 `Explore(2)` 仍在运行（所以 $\\mathrm{color}[2]=G$）。这完全符合括号中的描述“（此时 2 为灰色，4 为黑色）”。\n-   这次对顶点1的涂黑发生在 `Explore(3)` 被调用之前，因此远早于边 $(3,1)$ 被扫描。\n-   当 $(3,1)$ 最终被扫描时，$\\mathrm{color}[1]$ 确实是黑色，导致环被错过。\n-   这个选项提供了对算法执行和失败模式的完整而准确的描述。\n-   **结论：正确。**\n\n**B. 算法正确地报告“有环”，因为在扫描 $(3,1)$ 时它遇到了一个灰色邻居，这在 DFS 中是一条后向边，因此环 $1\\to 2\\to 3\\to 1$ 被检测到。**\n-   这描述了一个正确的 DFS 算法的行为。然而，有问题的涂黑规则改变了执行过程。如追踪过程所示，当处理边 $(3,1)$ 时，顶点1是黑色，而不是灰色。因此，算法不报告环。\n-   **结论：不正确。**\n\n**C. 该算法仅当遍历从顶点 4 而非顶点 1 开始时才会失败；在给定的从 1 开始的顺序下，它不能过早地将一个祖先顶点涂黑，因此仍然能检测到环。**\n-   第一个分句是错误的；追踪过程显示算法从顶点1开始就失败了。\n-   第二个分句也是错误的；追踪过程明确显示 DFS 树中的祖先顶点1被过早地涂黑。\n-   因此结论也是错误的；环被错过了。\n-   **结论：不正确。**\n\n**D. 该算法不会错过环，只可能产生假阳性（误报），因为任何指向先前访问过的顶点（灰色或黑色）的边都被视为后向边；因此它会因为 $(2,4)$ 而报告“有环”。**\n-   前提“该算法不会错过环”是错误的，如追踪过程所示。过早涂黑是导致假阴性（错过环）的一种机制。\n-   给出的原因也是错误的：“任何指向先前访问过的顶点（灰色或黑色）的边都被视为后向边”。问题明确指出，*仅*在遇到指向灰色顶点的边时才报告环。指向黑色顶点的边被忽略。\n-   给出的例子是错误的：“它会因为 (2,4) 而报告'有环'”。当处理边 $(2,4)$ 时，$\\mathrm{color}[4]$ 是白色。这导致了一次递归调用，而不是环检测。边 $(2,4)$ 是一条树边。\n-   **结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "3224987"}, {"introduction": "在检测到环路存在之后，一个自然的进阶问题是：最短的环路有多长？这个练习[@problem_id:3225009]将挑战你解决这个优化问题。你将学习如何巧妙地利用广度优先搜索（$BFS$）的特性——即在无权图中找到最短路径——来系统地寻找并确定图中长度最小的环路。这个过程不仅能加深你对$BFS$的理解，也展示了如何将基础图遍历算法应用于解决更复杂的优化任务。", "problem": "给定一个具有有限顶点集和有向边的有限有向图，边上没有权重。有向环是一个顶点序列 $\\left(v_0,v_1,\\dots,v_{k-1}\\right)$，其中 $k \\ge 1$，顶点各不相同，并且对于所有 $i \\in \\{0,1,\\dots,k-1\\}$，都存在一条从 $v_i$ 到 $v_{(i+1) \\bmod k}$ 的有向边。有向环的长度是环中边的数量，在此定义中等于 $k$。请设计并实现一个算法，为每个测试图计算其最短有向环的长度（以边数计），其中图是无权的。如果一个图不包含有向环，则定义其最短有向环长度为 $0$。请从每个顶点使用广度优先搜索（BFS），但需结合基于下界的原则性剪枝，以便那些无法改进当前已知最佳环长度的搜索不会被完全探索。您还必须证明您的方法为何正确，并分析其最坏情况下的运行时间。\n\n请从适用于数据结构与算法的核心定义和性质开始，具体包括：有向图 $G = (V, E)$ 的定义（其中 $|V| = n$ 且 $|E| = m$）、可达性的概念、在无权图上BFS以最短路径长度（以边数计）的非递减顺序探索顶点的性质，以及有向图的强连通分量（SCC）的概念。不要假设或使用任何预先指定的最短环公式；请从这些基本定义中推导出任何必要的关系。\n\n您的程序必须实现该算法，并为以下图的测试套件生成结果。每个图由顶点数 $n$（标记为 $\\{0,1,\\dots,n-1\\}$）和有向边列表指定，有向边以有序对 $\\left(u,v\\right)$ 的形式表示，意为从 $u$ 到 $v$ 的一条有向边。\n\n- 测试用例 1：$n = 5$，边 $\\left[(0,1),(1,2),(2,3),(3,4)\\right]$。\n- 测试用例 2：$n = 3$，边 $\\left[(0,0),(0,1),(1,2)\\right]$。\n- 测试用例 3：$n = 4$，边 $\\left[(0,1),(1,0),(2,3)\\right]$。\n- 测试用例 4：$n = 6$，边 $\\left[(0,1),(1,2),(2,0),(3,4),(4,5),(5,3),(2,3),(5,0)\\right]$。\n- 测试用例 5：$n = 7$，边 $\\left[(0,1),(1,2),(2,3),(3,0),(4,5),(5,6)\\right]$。\n- 测试用例 6：$n = 1$，边 $\\left[\\right]$。\n\n科学真实性要求：仅在适用于无权边的情况下应用BFS。使用从定义和已建立的性质中得出的下界，例如：入度为 $0$ 的顶点不可能位于有向环上；在大小为 $1$ 且没有自环的强连通分量中的顶点不可能位于任何有向环上；以及当已知全局最佳环长度 $L^\\star$ 时，任何产生距离 $d$（其中 $d+1 \\ge L^\\star$）的BFS层都不可能产生一个更短的环，因此可以被剪枝。确保您的程序忠实地反映这些约束。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$），其中每个条目都是一个整数，等于相应测试图的最短有向环长度，用 $0$ 表示没有环。此问题不涉及物理单位、角度单位或百分比，所有答案均为整数。", "solution": "该问题要求设计一种算法，用于在给定的无权有向图中找到最短有向环的长度。如果图是无环的，长度应报告为 $0$。该算法必须基于从每个顶点执行广度优先搜索（BFS），并带有特定的剪枝优化。\n\n有向图被正式表示为一对 $G=(V, E)$，其中 $V$ 是一个有限的顶点集合，$E$ 是一组称为有向边的顶点有序对集合。令 $n = |V|$ 为顶点数，$m = |E|$ 为边数。顶点被标记为 $\\{0, 1, \\dots, n-1\\}$。\n\n简单有向环被定义为 $k \\ge 1$ 个不同顶点的序列 $(v_0, v_1, \\dots, v_{k-1})$，使得对于所有 $i \\in \\{0, 1, \\dots, k-1\\}$，都存在一条从 $v_i$ 到 $v_{(i+1) \\bmod k}$ 的有向边。这个环的长度是 $k$，即它包含的边的数量。对于 $k=1$，环 $(v_0)$ 意味着存在一个自环边 $(v_0, v_0)$。目标是找到图 $G$ 中所有环中最小的 $k$ 值。\n\n所提议算法的核心原理依赖于BFS的性质和环的结构。从源顶点 $s \\in V$ 开始的BFS逐层探索图，保证能找到从 $s$ 到任何可达顶点的最短路径（以边数计）。包含顶点 $s$ 的环可以看作是从 $s$ 到某个顶点 $u$ 的路径，后跟一条“后向边” $(u, s)$。这样一个环的长度是从 $s$ 到 $u$ 的路径长度加一。通过系统地为每个可能的顶点 $s$ 搜索最短的此类构造，我们可以找到全局最短的环。\n\n算法流程如下：\n1. 初始化一个变量 $L^*$ 来存储前面提到的最短环的长度。一个安全的初始值是 $n+1$，因为在具有 $n$ 个顶点的图中，任何简单环的长度都不会超过 $n$。\n2. 遍历每个顶点 $s \\in V$，将每个顶点视为最短环中的一个潜在顶点和BFS遍历的根。\n3. 对每个 $s$，执行一次BFS：\n    a. 初始化一个大小为 $n$ 的距离数组 $d$，其中 $d(s) = 0$，对于所有其他顶点 $v \\in V \\setminus \\{s\\}$，$d(v) = \\infty$。\n    b. 初始化一个用于BFS的队列 $Q$，并将 $s$ 入队。\n    c. 当 $Q$ 不为空时，从队列中取出一个顶点 $u$。\n    d. **剪枝**：在从 $u$ 开始探索之前，检查是否有 $d(u) + 1 \\ge L^*$。量 $d(u)+1$ 代表了任何可能通过从 $s$ 到 $u$ 的路径和一条后向边形成的环的最小长度。如果这个可能的最小长度不严格小于当前已知的最佳环长 $L^*$，那么从 $u$ 扩展搜索就不可能找到更短的环。因此，我们可以剪掉这个搜索分支，并继续处理队列中的下一个顶点。\n    e. 探索 $u$ 的邻居：对于每个顶点 $v$ 使得 $(u, v) \\in E$：\n        i. 如果 $v = s$，则找到了一个环。该环由从 $s$ 到 $u$ 的最短路径（长度为 $d(u)$）和边 $(u, s)$ 组成。其长度为 $d(u) + 1$。更新 $L^* = \\min(L^*, d(u) + 1)$。\n        ii. 如果在当前BFS中尚未访问过 $v$ （即 $d(v) = \\infty$），则更新其距离 $d(v) = d(u) + 1$ 并将 $v$ 入队。\n4. 遍历所有可能的起始顶点 $s \\in V$ 后，如果 $L^*$ 仍为 $n+1$，则表示没有找到环。在这种情况下，结果为 $0$。否则，结果是 $L^*$ 的最终值。\n\n**正确性证明**\n设 $C = (v_0, v_1, \\dots, v_{k-1}, v_0)$ 是图 $G$ 中的一个最短环，其长度为 $k$。算法最终会选择其顶点之一，比如 $s=v_0$，作为BFS遍历的起始顶点。子序列 $(v_0, v_1, \\dots, v_{k-1})$ 构成了一条从 $v_0$ 到 $v_{k-1}$ 的长度为 $k-1$ 的简单路径。这条路径必须是从 $v_0$ 到 $v_{k-1}$ 的最短路径。如果存在更短的路径，那将意味着图中存在一个更短的环，这与 $C$ 是最短环的假设相矛盾。\n由于BFS算法会找到从其源点到所有其他顶点的最短路径，因此从 $v_0$ 开始的BFS将确定到 $v_{k-1}$ 的距离为 $d(v_0, v_{k-1}) = k-1$。当BFS在处理完 $v_{k-1}$ 在最短路径上的前驱节点后，探索 $v_{k-1}$ 的邻居时，它将发现边 $(v_{k-1}, v_0)$。由于 $v_0$ 是起始顶点 $s$，算法正确地识别出一个长度为 $d(v_0, v_{k-1}) + 1 = (k-1) + 1 = k$ 的环。这确保了 $L^*$ 将被更新为至多为 $k$。因为算法考虑了所有可能性，并且 $k$ 是可能的最小环长，所以最终结果将恰好是 $k$。剪枝步骤保持了正确性，因为它只丢弃那些不可能导致比已发现的环更短的环的搜索路径。\n\n**最坏情况运行时间分析**\n该算法包含一个主循环，该循环迭代 $n$ 次，对 $V$ 中的每个顶点一次。在这个循环内部，会执行一次BFS。在一个由邻接表表示的图上，标准BFS需要 $O(n+m)$ 的时间。因此，该算法的总最坏情况时间复杂度是 $n \\times O(n+m) = O(n(n+m))$。最坏情况性能出现在无环图或具有非常长环的图上，在这些图上剪枝优化带来的好处微乎其微。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef solve_graph(n, edges):\n    \"\"\"\n    Computes the length of the shortest directed cycle in a graph.\n\n    Args:\n        n (int): The number of vertices, labeled 0 to n-1.\n        edges (list of tuple): A list of directed edges (u, v).\n\n    Returns:\n        int: The length of the shortest directed cycle, or 0 if no cycle exists.\n    \"\"\"\n    if n == 0:\n        return 0\n\n    # Adjacency list representation of the graph\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n\n    # Initialize shortest cycle length. A simple cycle length is at most n.\n    # We use n + 1 as an indicator for \"infinity\" or \"not found\".\n    min_cycle_len = n + 1\n\n    # Iterate through each vertex, treating it as a potential start of a cycle\n    for s in range(n):\n        # Start a Breadth-First Search (BFS) from vertex s.\n        # We use a numpy array for distances; -1 represents an unvisited vertex.\n        dist = np.full(n, -1, dtype=int)\n        \n        # Queue for BFS. collections.deque is efficient for this purpose.\n        q = deque()\n\n        # Initialize BFS from s\n        dist[s] = 0\n        q.append(s)\n\n        while q:\n            u = q.popleft()\n\n            # Pruning step: if the path to u is already long enough that any\n            # cycle through it cannot be shorter than the current best, we prune.\n            # a cycle found from here would have length at least dist[u] + 1.\n            if dist[u] + 1 >= min_cycle_len:\n                continue\n\n            for v in adj[u]:\n                if v == s:\n                    # Found a cycle back to the starting vertex s.\n                    # Cycle length = path length to u + edge (u, s).\n                    cycle_len = dist[u] + 1\n                    min_cycle_len = min(min_cycle_len, cycle_len)\n                elif dist[v] == -1:\n                    # First time visiting vertex v in this BFS. Record distance and enqueue.\n                    dist[v] = dist[u] + 1\n                    q.append(v)\n                # If dist[v] != -1 and v != s, we have found another path to v.\n                # Since BFS explores layer by layer, this new path cannot be shorter,\n                # so we ignore it.\n\n    # If min_cycle_len was not updated from its initial value, no cycles were found.\n    # As per the problem statement, return 0 in this case.\n    if min_cycle_len == n + 1:\n        return 0\n    else:\n        return min_cycle_len\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: Acyclic graph\n        (5, [(0, 1), (1, 2), (2, 3), (3, 4)]),\n        # Test case 2: Self-loop (cycle of length 1)\n        (3, [(0, 0), (0, 1), (1, 2)]),\n        # Test case 3: Simple cycle of length 2\n        (4, [(0, 1), (1, 0), (2, 3)]),\n        # Test case 4: Two disjoint cycles of length 3, plus connecting edges\n        (6, [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5), (5, 3), (2, 3), (5, 0)]),\n        # Test case 5: One cycle of length 4 and a separate path\n        (7, [(0, 1), (1, 2), (2, 3), (3, 0), (4, 5), (5, 6)]),\n        # Test case 6: A single vertex with no edges\n        (1, []),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        result = solve_graph(n, edges)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3225009"}]}