{"hands_on_practices": [{"introduction": "标准的寻路算法假定成本仅存在于边上。然而，在现实世界中，穿过节点本身也可能产生开销，例如通过交叉路口需要缴纳的通行费或服务器处理请求所需的时间。本练习将挑战你跳出标准模型的框架，将一个具有非标准成本函数（包括边的权重和中间节点的成本）的问题，通过巧妙的图变换，转化为一个等价的、可以用标准算法解决的问题。掌握这种模型变换的能力是算法设计者的关键技能，它让你能将现有的强大算法应用于全新的问题场景。[@problem_id:3270794]", "problem": "考虑一个有向图 $G=(V,E)$，其顶点集为 $V=\\{v_1,v_2,v_3,v_4,v_5,v_6,v_7\\}$。每条有向边 $(u,v)\\in E$ 都有一个由函数 $w:E\\to \\mathbb{R}_{\\ge 0}$ 给出的非负边权，每个顶点 $x\\in V$ 都有一个由函数 $c:V\\to \\mathbb{R}_{\\ge 0}$ 给出的非负顶点代价。对于任意一条有向 $s$-$t$ 路径 $P=\\langle s=x_0,x_1,\\dots,x_k=t\\rangle$，其路径代价定义为\n$$\n\\sum_{i=0}^{k-1} w(x_i,x_{i+1}) \\;+\\; \\sum_{i=1}^{k-1} c(x_i),\n$$\n即，路径上所有边的权重之和，加上路径上所有中间顶点（不包括源点和终点）的代价之和。假设所有边权和顶点代价都是非负的。\n\n你的任务是，基于最短路径和Dijkstra算法（该算法适用于具有非负边权的有向图）的核心定义，而不是借助任何已有的归约公式，推导出一个正确的方法，使用标准的具有非负边权的单源最短路径计算来计算上述路径代价。然后，对于下面给出的源点为 $s=v_1$、终点为 $t=v_7$ 的具体实例，计算在所述模型下从 $v_1$ 到 $v_7$ 的最小路径代价。\n\n有向边及其权重如下：\n- 边 $v_1\\to v_2$，权重 $w=4$；边 $v_1\\to v_3$，权重 $w=2$。\n- 边 $v_2\\to v_3$，权重 $w=1$；边 $v_2\\to v_4$，权重 $w=5$；边 $v_2\\to v_5$，权重 $w=7$。\n- 边 $v_3\\to v_4$，权重 $w=8$；边 $v_3\\to v_5$，权重 $w=10$；边 $v_3\\to v_6$，权重 $w=4$。\n- 边 $v_4\\to v_5$，权重 $w=2$；边 $v_4\\to v_6$，权重 $w=6$。\n- 边 $v_5\\to v_6$，权重 $w=2$；边 $v_5\\to v_7$，权重 $w=5$。\n- 边 $v_6\\to v_7$，权重 $w=1$。\n\n顶点代价如下：\n- $c(v_1)=3$, $c(v_2)=4$, $c(v_3)=2$, $c(v_4)=5$, $c(v_5)=1$, $c(v_6)=3$, $c(v_7)=6$。\n\n仅报告从 $v_1$ 到 $v_7$ 的最小路径代价值，该值应为一个实数。本实例无需进行四舍五入。", "solution": "用户提供了一个在有向图上的、具有非标准代价函数且定义明确的最短路径问题。该问题在数学上和算法上都是合理的，内容自洽且没有歧义。我将首先推导一种通过将其归约为标准单源最短路径问题来解决此类问题的方法，然后将此方法应用于所提供的具体实例。\n\n### 第1部分：归约的推导\n设有一个有向图 $G=(V,E)$，其非负边权函数为 $w:E\\to \\mathbb{R}_{\\ge 0}$，非负顶点代价函数为 $c:V\\to \\mathbb{R}_{\\ge 0}$。对于给定的源点 $s \\in V$ 和终点 $t \\in V$，我们需要找到一条路径 $P=\\langle s=x_0,x_1,\\dots,x_k=t\\rangle$，使得路径代价最小化，其定义为：\n$$\nC(P) = \\sum_{i=0}^{k-1} w(x_i,x_{i+1}) \\;+\\; \\sum_{i=1}^{k-1} c(x_i)\n$$\n该代价是路径上所有边权之和，加上所有中间顶点（即不包括源点 $s$ 和终点 $t$）的代价之和。\n\n标准的最短路径算法，如Dijkstra算法，是在代价仅与边相关联的图上运行的。我们的目标是将给定的问题转换为一个等价的、仅有边权的图上问题，使得新图中的标准最短路径代价与自定义代价 $C(P)$直接相关。\n\n让我们构建一个新图 $G'=(V, E)$，它与 $G$ 具有相同的顶点集和边集。我们需要定义一个新的边权函数 $w': E \\to \\mathbb{R}_{\\ge 0}$。关键在于将顶点代价合并到这些新的边权中。当一条路径穿过顶点 $v$ 时，会产生顶点代价 $c(v)$。这表明代价 $c(v)$ 可以加到所有进入 $v$ 的边的权重上，或者加到所有离开 $v$ 的边的权重上。\n\n让我们探讨第一种方法：将边 $(u,v)$ 的新权重定义为其原始权重与目的顶点 $v$ 的代价之和。\n对于每条边 $(u,v) \\in E$，令 $w'(u,v) = w(u,v) + c(v)$。\n由于 $w(u,v) \\ge 0$ 且 $c(v) \\ge 0$，新的边权 $w'(u,v)$ 也都是非负的。这确保了Dijkstra算法适用于转换后的图 $G'$。\n\n现在，让我们根据标准最短路径度量来考虑同一条路径 $P = \\langle s=x_0,x_1,\\dots,x_k=t\\rangle$ 在这个新图 $G'$ 中的代价。这个代价，我们称之为 $C'(P)$，是路径上新边权之和：\n$$\nC'(P) = \\sum_{i=0}^{k-1} w'(x_i,x_{i+1})\n$$\n代入 $w'$ 的定义，我们有：\n$$\nC'(P) = \\sum_{i=0}^{k-1} \\left( w(x_i,x_{i+1}) + c(x_{i+1}) \\right)\n$$\n我们可以将此和式分成两部分：\n$$\nC'(P) = \\sum_{i=0}^{k-1} w(x_i,x_{i+1}) + \\sum_{i=0}^{k-1} c(x_{i+1})\n$$\n我们展开第二个和式：\n$$\n\\sum_{i=0}^{k-1} c(x_{i+1}) = c(x_1) + c(x_2) + \\dots + c(x_{k-1}) + c(x_k)\n$$\n此和式的第一部分 $\\sum_{i=1}^{k-1} c(x_i)$ 对应于中间顶点的代价。顶点 $x_k$ 是目的顶点 $t$。所以，我们可以将 $C'(P)$ 的表达式重写为：\n$$\nC'(P) = \\left( \\sum_{i=0}^{k-1} w(x_i,x_{i+1}) + \\sum_{i=1}^{k-1} c(x_i) \\right) + c(x_k)\n$$\n括号中的表达式正是原始的代价函数 $C(P)$。由于 $x_k = t$，我们有：\n$$\nC'(P) = C(P) + c(t)\n$$\n这个关系表明，对于任何从 $s$ 到 $t$ 的路径，其在 $G'$ 中的标准代价等于其在 $G$ 中的自定义代价加上目的顶点 $t$ 的代价 $c(t)$。由于对于所有从 $s$ 到 $t$ 的路径，$c(t)$ 是一个常数，因此最小化 $C'(P)$ 的路径也就是最小化 $C(P)$ 的路径。\n\n因此，我们可以通过执行以下步骤来找到原始问题中的最小路径代价：\n1. 构建图 $G'$，其边权为 $w'(u,v) = w(u,v) + c(v)$。\n2. 从源点 $s$ 开始，在 $G'$ 上运行Dijkstra算法，找到到所有其他顶点的最短路径距离。对于任意顶点 $v$，令 $d'(s,v)$ 表示此距离。\n3. 在 $G'$ 中从 $s$到 $t$ 的最短路径距离为 $d'(s,t)$。\n4. 那么，在原始定义下的最小路径代价为 $C_{min} = d'(s,t) - c(t)$。\n\n### 第2部分：应用于具体实例\n给定图 $G=(V, E)$，其中 $V=\\{v_1, \\dots, v_7\\}$，源点为 $s=v_1$，终点为 $t=v_7$，以及以下的边权和顶点代价：\n\n**顶点代价：**\n$c(v_1)=3$, $c(v_2)=4$, $c(v_3)=2$, $c(v_4)=5$, $c(v_5)=1$, $c(v_6)=3$, $c(v_7)=6$。\n\n**图转换：**\n我们计算新的边权 $w'(u,v) = w(u,v) + c(v)$：\n- $w'(v_1, v_2) = w(v_1, v_2) + c(v_2) = 4 + 4 = 8$\n- $w'(v_1, v_3) = w(v_1, v_3) + c(v_3) = 2 + 2 = 4$\n- $w'(v_2, v_3) = w(v_2, v_3) + c(v_3) = 1 + 2 = 3$\n- $w'(v_2, v_4) = w(v_2, v_4) + c(v_4) = 5 + 5 = 10$\n- $w'(v_2, v_5) = w(v_2, v_5) + c(v_5) = 7 + 1 = 8$\n- $w'(v_3, v_4) = w(v_3, v_4) + c(v_4) = 8 + 5 = 13$\n- $w'(v_3, v_5) = w(v_3, v_5) + c(v_5) = 10 + 1 = 11$\n- $w'(v_3, v_6) = w(v_3, v_6) + c(v_6) = 4 + 3 = 7$\n- $w'(v_4, v_5) = w(v_4, v_5) + c(v_5) = 2 + 1 = 3$\n- $w'(v_4, v_6) = w(v_4, v_6) + c(v_6) = 6 + 3 = 9$\n- $w'(v_5, v_6) = w(v_5, v_6) + c(v_6) = 2 + 3 = 5$\n- $w'(v_5, v_7) = w(v_5, v_7) + c(v_7) = 5 + 6 = 11$\n- $w'(v_6, v_7) = w(v_6, v_7) + c(v_7) = 1 + 6 = 7$\n\n**在 $G'$ 上从 $v_1$ 开始运行Dijkstra算法：**\n令 $d'[v]$ 为在 $G'$ 中从 $v_1$ 到 $v \\in V$ 的最短距离。\n1. 初始化：$d'[v_1]=0$，$d'[v_i]=\\infty$ 对于 $i \\in \\{2, \\dots, 7\\}$。优先队列 $Q=\\{(0, v_1)\\}$。\n2. 取出 $v_1$ ($d'[v_1]=0$)。\n   - 松弛 $(v_1,v_2)$: $d'[v_2] = 0 + 8 = 8$。\n   - 松弛 $(v_1,v_3)$: $d'[v_3] = 0 + 4 = 4$。\n   $d' = [0, 8, 4, \\infty, \\infty, \\infty, \\infty]$。$Q=\\{(4, v_3), (8, v_2)\\}$。\n3. 取出 $v_3$ ($d'[v_3]=4$)。\n   - 松弛 $(v_3,v_4)$: $d'[v_4] = 4 + 13 = 17$。\n   - 松弛 $(v_3,v_5)$: $d'[v_5] = 4 + 11 = 15$。\n   - 松弛 $(v_3,v_6)$: $d'[v_6] = 4 + 7 = 11$。\n   $d' = [0, 8, 4, 17, 15, 11, \\infty]$。$Q=\\{(8, v_2), (11, v_6), (15, v_5), (17, v_4)\\}$。\n4. 取出 $v_2$ ($d'[v_2]=8$)。\n   - 松弛 $(v_2,v_3)$: $d'[v_3]=\\min(4, 8+3)=4$。无变化。\n   - 松弛 $(v_2,v_4)$: $d'[v_4]=\\min(17, 8+10)=17$。无变化。\n   - 松弛 $(v_2,v_5)$: $d'[v_5]=\\min(15, 8+8)=15$。无变化。\n   $Q=\\{(11, v_6), (15, v_5), (17, v_4)\\}$。\n5. 取出 $v_6$ ($d'[v_6]=11$)。\n   - 松弛 $(v_6,v_7)$: $d'[v_7] = 11 + 7 = 18$。\n   $d' = [0, 8, 4, 17, 15, 11, 18]$。$Q=\\{(15, v_5), (17, v_4), (18, v_7)\\}$。\n6. 取出 $v_5$ ($d'[v_5]=15$)。\n   - 松弛 $(v_5,v_6)$: $v_6$ 已确定最短路径。\n   - 松弛 $(v_5,v_7)$: $d'[v_7]=\\min(18, 15+11)=18$。无变化。\n   $Q=\\{(17, v_4), (18, v_7)\\}$。\n7. 取出 $v_4$ ($d'[v_4]=17$)。\n   - 邻居 $v_5, v_6$ 已确定最短路径。无变化。\n   $Q=\\{(18, v_7)\\}$。\n8. 取出 $v_7$ ($d'[v_7]=18$)。算法终止。\n\n在转换后的图中，从 $v_1$ 到 $v_7$ 的最短路径距离是 $d'(v_1, v_7) = 18$。\n\n**最终代价计算：**\n原始问题中的最小路径代价由 $C_{min} = d'(v_1, v_7) - c(v_7)$ 给出。\n已知 $c(v_7) = 6$，我们得到：\n$$\nC_{min} = 18 - 6 = 12\n$$\n产生此代价的路径是 $\\langle v_1, v_3, v_6, v_7 \\rangle$。我们可以用原始公式验证其代价：\n$C(P) = (w(v_1,v_3)+w(v_3,v_6)+w(v_6,v_7)) + (c(v_3)+c(v_6)) = (2+4+1) + (2+3) = 7+5=12$。\n结果一致。", "answer": "$$\\boxed{12}$$", "id": "3270794"}, {"introduction": "在许多导航和网络路由问题中，我们不仅要寻找最短路径，还必须遵守某些限制，例如避开施工区域、危险地带或私人领地。这个练习将指导你如何通过修改图的结构来为这类约束建模。通过移除图中“禁止”通行的顶点及其所有相关联的边，一个看似复杂的约束性寻路问题就被简化为了一个标准的单源最短路径问题，进而可以使用 Dijkstra 等经典算法高效求解。这体现了算法问题求解中的一个核心思想：将新问题转化为已知问题。[@problem_id:3270849]", "problem": "给定一个带非负边权的加权有向图 $G = (V, E)$ 和两个指定顶点 $s$ 和 $t$。令 $V_{bad} \\subset V$ 为一个禁止顶点集合，这些顶点不能出现在任何可行路径上。一条路径是可行的，当且仅当其所有内部顶点都在 $V \\setminus V_{bad}$ 中，且其端点是指定的 $s$ 和 $t$，并且 $s$ 和 $t$ 都不属于 $V_{bad}$。目标是从第一性原理出发，确定从 $s$ 到 $t$ 的最短可行路径的长度（总权重）。仅使用最短路径的核心定义和 Dijkstra 算法在非负边权图上的正确性作为基本事实，而不援引任何关于此特定图的预计算结果。\n\n考虑下面指定的实例。\n- 顶点集 $V = \\{s, a, b, c, d, e, f, g, h, t\\}$。\n- 禁止集 $V_{bad} = \\{c, f\\}$。\n- 边多重集 $E$ 及其权重 $w: E \\to \\mathbb{R}_{\\ge 0}$ 如下所示（每个三元组 $(u, v, w)$ 表示一条从 $u$ 到 $v$ 权重为 $w$ 的有向边）：\n  - $(s, a, 2)$, $(s, b, 5)$, $(s, h, 15)$, $(s, c, 1)$,\n  - $(a, c, 2)$, $(a, d, 4)$, $(a, e, 7)$,\n  - $(b, a, 1)$, $(b, d, 2)$, $(b, f, 6)$,\n  - $(c, d, 2)$, $(c, g, 5)$,\n  - $(d, e, 1)$, $(d, f, 2)$, $(d, g, 6)$,\n  - $(e, g, 1)$, $(e, h, 3)$,\n  - $(f, t, 3)$,\n  - $(g, h, 2)$, $(g, t, 4)$,\n  - $(h, t, 2)$.\n\n任务：\n- 通过移除 $V_{bad}$ 中的所有顶点以及与它们相关联的所有边，将问题形式化地归约为在导出子图 $G[V \\setminus V_{bad}]$ 中计算最短路径。然后，利用路径长度的基本定义和 Dijkstra 算法在非负权图上的正确性，逻辑上推导出在规约图中以 $s$ 为根的最短路径树（SPT），并从而确定从 $s$ 到 $t$ 的最短可行路径的长度。\n- 提供最终的数值答案，即精确的整数路径长度。无需四舍五入。\n\n在此实例中，从 $s$ 到 $t$ 的最短可行路径的长度是多少？", "solution": "首先对问题进行验证。\n\n### 步骤1：提取已知条件\n-   **图的定义**：一个带非负边权的加权有向图 $G = (V, E)$。\n-   **顶点**：$V = \\{s, a, b, c, d, e, f, g, h, t\\}$。\n-   **起始顶点和终止顶点**：源点 $s$，终点 $t$。\n-   **禁止顶点**：$V_{bad} = \\{c, f\\}$。\n-   **可行路径的定义**：一条从 $s$ 到 $t$ 的路径，其所有内部顶点都在 $V \\setminus V_{bad}$ 中。端点 $s$ 和 $t$ 也不属于 $V_{bad}$。\n-   **边和权重**：\n    -   $(s, a, 2)$, $(s, b, 5)$, $(s, h, 15)$, $(s, c, 1)$,\n    -   $(a, c, 2)$, $(a, d, 4)$, $(a, e, 7)$,\n    -   $(b, a, 1)$, $(b, d, 2)$, $(b, f, 6)$,\n    -   $(c, d, 2)$, $(c, g, 5)$,\n    -   $(d, e, 1)$, $(d, f, 2)$, $(d, g, 6)$,\n    -   $(e, g, 1)$, $(e, h, 3)$,\n    -   $(f, t, 3)$,\n    -   $(g, h, 2)$, $(g, t, 4)$,\n    -   $(h, t, 2)$.\n-   **任务**：将问题归约为一个在导出子图中的最短路径问题，然后从第一性原理出发，使用 Dijkstra 算法求出从 $s$ 到 $t$ 的最短可行路径的长度。\n\n### 步骤2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题是图论和算法中的一个标准练习，这是计算机科学和离散数学的一个子领域。它基于已建立的定义和算法。\n2.  **良态问题**：该问题提供了一个具有非负权重和明确目标的完全指定的图。“可行路径”的定义是精确的。条件 $s, t \\notin V_{bad}$（因为 $s, t \\notin \\{c, f\\}$）得到满足。由于边权非负，Dijkstra 算法适用且保证能找到解。因此，存在一个唯一的、稳定的、有意义的解（最短路径长度）。\n3.  **目标明确**：语言是正式且无歧义的。所有术语都是图论中的标准术语。\n4.  **完整性和一致性**：问题是自包含的。所有必要的信息（顶点、边、权重、禁止集）都已提供。所提供的数据中没有矛盾。\n\n### 步骤3：结论与行动\n问题是**有效的**。将推导解答。\n\n### 解题过程\n\n问题是要求解从顶点 $s$到顶点 $t$ 的最短可行路径的长度。一条路径被定义为可行的，如果其内部顶点不属于集合 $V_{bad} = \\{c, f\\}$。问题还指定了端点 $s$ 和 $t$ 不在 $V_{bad}$ 中。这意味着任何从 $s$ 到 $t$ 的可行路径必须完全由集合 $V' = V \\setminus V_{bad}$ 中的顶点组成。因此，在原始图 $G$ 中寻找最短可行路径等价于在由顶点集 $V'$ 导出的 $G$ 的子图中寻找最短路径。\n\n设这个规约图为 $G' = (V', E')$。\n顶点集 $V'$ 是：\n$V' = V \\setminus V_{bad} = \\{s, a, b, c, d, e, f, g, h, t\\} \\setminus \\{c, f\\} = \\{s, a, b, d, e, g, h, t\\}$。\n\n边集 $E'$ 包含所有满足 $u, v \\in V'$ 的边 $(u, v) \\in E$。我们筛选原始的边列表：\n-   $(s, a, 2)$: 有效，因为 $s, a \\in V'$。\n-   $(s, b, 5)$: 有效，因为 $s, b \\in V'$。\n-   $(s, h, 15)$: 有效，因为 $s, h \\in V'$。\n-   $(s, c, 1)$: 无效，因为 $c \\notin V'$。\n-   $(a, c, 2)$: 无效，因为 $c \\notin V'$。\n-   $(a, d, 4)$: 有效，因为 $a, d \\in V'$。\n-   $(a, e, 7)$: 有效，因为 $a, e \\in V'$。\n-   $(b, a, 1)$: 有效，因为 $b, a \\in V'$。\n-   $(b, d, 2)$: 有效，因为 $b, d \\in V'$。\n-   $(b, f, 6)$: 无效，因为 $f \\notin V'$。\n-   $(c, d, 2)$: 无效，因为 $c \\notin V'$。\n-   $(c, g, 5)$: 无效，因为 $c \\notin V'$。\n-   $(d, e, 1)$: 有效，因为 $d, e \\in V'$。\n-   $(d, f, 2)$: 无效，因为 $f \\notin V'$。\n-   $(d, g, 6)$: 有效，因为 $d, g \\in V'$。\n-   $(e, g, 1)$: 有效，因为 $e, g \\in V'$。\n-   $(e, h, 3)$: 有效，因为 $e, h \\in V'$。\n-   $(f, t, 3)$: 无效，因为 $f \\notin V'$。\n-   $(g, h, 2)$: 有效，因为 $g, h \\in V'$。\n-   $(g, t, 4)$: 有效，因为 $g, t \\in V'$。\n-   $(h, t, 2)$: 有效，因为 $h, t \\in V'$。\n\n最终得到的图 $G' = (V', E')$ 的所有权重都是非负的。因此，我们可以应用 Dijkstra 算法来找到从 $s$ 到所有其他顶点的最短路径。设 $d(v)$ 为迄今为止找到的从 $s$ 到 $v$ 的最短距离，$\\pi(v)$ 为最短路径上 $v$ 的前驱节点。\n\n**初始化：**\n-   一个已访问顶点的集合，$S = \\emptyset$。\n-   一个优先队列 $Q$，包含 $V'$ 中的所有顶点，按距离优先。\n-   初始化距离：$d(s) = 0$，对于所有其他 $v \\in V'$，有 $d(v) = \\infty$。\n-   初始化前驱节点：对于所有 $v \\in V'$，有 $\\pi(v) = \\text{null}$。\n初始状态是：\n$d = \\{s:0, a:\\infty, b:\\infty, d:\\infty, e:\\infty, g:\\infty, h:\\infty, t:\\infty\\}$\n$Q = \\{s(0), a(\\infty), b(\\infty), d(\\infty), e(\\infty), g(\\infty), h(\\infty), t(\\infty)\\}$\n\n**Dijkstra 算法的执行过程：**\n\n1.  **提取 $s$**：$u = s$。将 $s$ 加入 $S$。$S=\\{s\\}$。\n    -   松弛边 $(s, a)$，权重为 $2$：$d(a) > d(s)+2 \\implies \\infty > 0+2$。更新 $d(a)=2$，$\\pi(a)=s$。\n    -   松弛边 $(s, b)$，权重为 $5$：$d(b) > d(s)+5 \\implies \\infty > 0+5$。更新 $d(b)=5$，$\\pi(b)=s$。\n    -   松弛边 $(s, h)$，权重为 $15$：$d(h) > d(s)+15 \\implies \\infty > 0+15$。更新 $d(h)=15$，$\\pi(h)=s$。\n    $d = \\{s:0, a:2, b:5, d:\\infty, e:\\infty, g:\\infty, h:15, t:\\infty\\}$。\n    $Q = \\{a(2), b(5), h(15), d(\\infty), e(\\infty), g(\\infty), t(\\infty)\\}$.\n\n2.  **提取 $a$**：$u = a$。将 $a$ 加入 $S$。$S=\\{s, a\\}$。\n    -   松弛边 $(a, d)$，权重为 $4$：$d(d) > d(a)+4 \\implies \\infty > 2+4$。更新 $d(d)=6$，$\\pi(d)=a$。\n    -   松弛边 $(a, e)$，权重为 $7$：$d(e) > d(a)+7 \\implies \\infty > 2+7$。更新 $d(e)=9$，$\\pi(e)=a$。\n    $d = \\{s:0, a:2, b:5, d:6, e:9, g:\\infty, h:15, t:\\infty\\}$。\n    $Q = \\{b(5), d(6), e(9), h(15), g(\\infty), t(\\infty)\\}$.\n\n3.  **提取 $b$**：$u = b$。将 $b$ 加入 $S$。$S=\\{s, a, b\\}$。\n    -   松弛边 $(b, a)$，权重为 $1$：$d(a) > d(b)+1 \\implies 2 > 5+1$ 为假。不更新。\n    -   松弛边 $(b, d)$，权重为 $2$：$d(d) > d(b)+2 \\implies 6 > 5+2$ 为假。不更新。\n    $d$ 不变。$Q = \\{d(6), e(9), h(15), g(\\infty), t(\\infty)\\}$.\n\n4.  **提取 $d$**：$u = d$。将 $d$ 加入 $S$。$S=\\{s, a, b, d\\}$。\n    -   松弛边 $(d, e)$，权重为 $1$：$d(e) > d(d)+1 \\implies 9 > 6+1$。更新 $d(e)=7$，$\\pi(e)=d$。\n    -   松弛边 $(d, g)$，权重为 $6$：$d(g) > d(d)+6 \\implies \\infty > 6+6$。更新 $d(g)=12$，$\\pi(g)=d$。\n    $d = \\{s:0, a:2, b:5, d:6, e:7, g:12, h:15, t:\\infty\\}$。\n    $Q = \\{e(7), g(12), h(15), t(\\infty)\\}$.\n\n5.  **提取 $e$**：$u = e$。将 $e$ 加入 $S$。$S=\\{s, a, b, d, e\\}$。\n    -   松弛边 $(e, g)$，权重为 $1$：$d(g) > d(e)+1 \\implies 12 > 7+1$。更新 $d(g)=8$，$\\pi(g)=e$。\n    -   松弛边 $(e, h)$，权重为 $3$：$d(h) > d(e)+3 \\implies 15 > 7+3$。更新 $d(h)=10$，$\\pi(h)=e$。\n    $d = \\{s:0, a:2, b:5, d:6, e:7, g:8, h:10, t:\\infty\\}$。\n    $Q = \\{g(8), h(10), t(\\infty)\\}$.\n\n6.  **提取 $g$**：$u = g$。将 $g$ 加入 $S$。$S=\\{s, a, b, d, e, g\\}$。\n    -   松弛边 $(g, h)$，权重为 $2$：$d(h) > d(g)+2 \\implies 10 > 8+2$ 为假。不更新。\n    -   松弛边 $(g, t)$，权重为 $4$：$d(t) > d(g)+4 \\implies \\infty > 8+4$。更新 $d(t)=12$，$\\pi(t)=g$。\n    $d = \\{s:0, a:2, b:5, d:6, e:7, g:8, h:10, t:12\\}$。\n    $Q = \\{h(10), t(12)\\}$.\n\n7.  **提取 $h$**：$u = h$。将 $h$ 加入 $S$。$S=\\{s, a, b, d, e, g, h\\}$。\n    -   松弛边 $(h, t)$，权重为 $2$：$d(t) > d(h)+2 \\implies 12 > 10+2$ 为假。不更新。\n    $d$ 不变。$Q = \\{t(12)\\}$.\n\n8.  **提取 $t$**：$u = t$。将 $t$ 加入 $S$。$S=\\{s, a, b, d, e, g, h, t\\}$。算法终止，因为 $Q$ 现已为空。\n\n从 $s$ 出发的最终距离由数组 $d$ 给出。从 $s$ 出发的最短路径树（SPT）由前驱节点数组 $\\pi$ 隐式定义。从 $s$ 到 $t$ 的最短路径长度是 $d(t)$。\n\n从最终状态可知，$d(t) = 12$。\n\n我们可以回溯找到的最短路径：\n$t \\leftarrow \\pi(t)=g \\leftarrow \\pi(g)=e \\leftarrow \\pi(e)=d \\leftarrow \\pi(d)=a \\leftarrow \\pi(a)=s$。\n路径是 $s \\to a \\to d \\to e \\to g \\to t$。\n长度为 $w(s,a) + w(a,d) + w(d,e) + w(e,g) + w(g,t) = 2 + 4 + 1 + 1 + 4 = 12$。\n这证实了 Dijkstra 算法的结果。\n\n值得注意的是，存在另一条长度相同的路径：$s \\to a \\to d \\to e \\to h \\to t$。其长度为 $2+4+1+3+2=12$。Dijkstra 算法找到了其中一条路径，并且保证长度 $12$ 是最小的。\n\n从 $s$ 到 $t$ 的最短可行路径的长度是 $12$。", "answer": "$$\n\\boxed{12}\n$$", "id": "3270849"}, {"introduction": "在网络路由等动态应用中，边的权重（例如链路延迟或带宽成本）会随时间变化。每当发生微小变化时都从头重新计算整个最短路径树（SPT）是非常低效的。本练习将引导你探索最短路径树的动态更新。当图中某条边的权重减少时，我们可以利用已有的计算结果，仅对受影响的部分进行增量式更新。你将实现一个高效的更新过程，它精准地反映了 Dijkstra 算法的核心逻辑——在图中传播距离缩短的“好消息”，这不仅能加深你对 SPT 算法工作原理的理解，也是动态图算法的重要基石。[@problem_id:3270914]", "problem": "考虑一个有向图 $G = (V, E)$，其边权重由一个非负函数 $w : E \\to \\mathbb{R}_{\\ge 0}$ 给出，并指定一个源顶点 $s \\in V$。最短路径树 (SPT) 定义为一个前驱图 $\\pi : V \\to V \\cup \\{\\text{nil}\\}$，使得有向边集合 $\\{(\\pi(v), v) : v \\in V, \\pi(v) \\neq \\text{nil}\\}$ 构成一个以 $s$ 为根的有向生成树，并且相关的路径距离 $d : V \\to \\mathbb{R}_{\\ge 0} \\cup \\{\\infty\\}$ 满足：对于每个顶点 $v \\in V$，该树中从 $s$ 到 $v$ 的路径总权重恰好为 $d(v)$，并且该值等于所有从 $s$ 到 $v$ 的有向路径中的最小值。\n\n目标是设计并实现一个程序，在给定图 $G$ 关于源点 $s$ 的一个 SPT 的情况下，当某条有向边 $(u, v) \\in E$ 的权重减少到一个新值 $w'(u, v)$（满足 $0 \\le w'(u, v)  w(u, v)$）后，能够更新此 SPT，而不是从头进行完全的重新计算。更新操作应依赖于最短路径的基本性质以及在非负权重下的松弛行为，并且必须通过重用现有的距离 $d(\\cdot)$ 和前驱 $\\pi(\\cdot)$ 来进行，而不是像没有任何已知信息一样重新初始化所有结构。更新后的 SPT 必须反映新的最短路径距离 $d'(\\cdot)$ 和更新后的前驱图 $\\pi'(\\cdot)$。\n\n推导的基本依据：\n- 非负权重下最短路径距离的定义。\n- 最短路径的最优子结构：如果一条从 $s$ 到 $y$ 的路径是最短的，那么其从 $s$ 到任何中间顶点 $x$ 的前缀路径也是最短的。\n- 松弛不变量：对于任意边 $(x, y) \\in E$，在有效的 SPT 中必须满足不等式 $d(y) \\le d(x) + w(x, y)$；当一条边的权重减少时，只有那些其最短路径可以通过遍历此边或从其头部可达的路径得到改善的顶点才可能发生变化。\n\n您的程序必须使用适用于非负权重的正确算法来计算从 $s$ 出发的初始最短路径距离，然后，如果满足 $d(u) + w'(u, v)  d(v)$，则仅在以 $v$ 为起点进行局部松弛来应用单边权重减少的更新步骤，并通过一个最小优先队列将改进传播到受影响的顶点，直到不可能再有改进为止。程序不得从头重新运行完整的计算。\n\n您的程序必须是自包含的，并且不得读取输入。请使用以下测试套件，其中每个测试用例由顶点数、带权重的边列表、一个源顶点以及由 $(u, v, w')$ 指定的单边权重减少来规定。顶点由从 0 开始的整数索引。\n\n测试套件：\n- 测试用例 1：$|V| = 6$, $s = 0$，边由三元组 $(x, y, w)$ 列表给出：\n  $(0, 1, 7)$, $(0, 2, 9)$, $(0, 5, 14)$, $(1, 2, 10)$, $(1, 3, 15)$, $(2, 3, 11)$, $(2, 5, 2)$, $(3, 4, 6)$, $(5, 4, 9)$。将边 $(1, 2)$ 的权重减少到 $w' = 1$。\n- 测试用例 2：$|V| = 6$, $s = 0$，边与测试用例 1 相同。将边 $(3, 4)$ 的权重减少到 $w' = 4$。\n- 测试用例 3：$|V| = 6$, $s = 0$，边与测试用例 1 相同。将边 $(0, 2)$ 的权重减少到 $w' = 2$。\n\n对于每个测试用例，计算应用单边权重减少后更新的最短路径距离列表 $[d'(0), d'(1), \\dots, d'(5)]$。所有这些案例中的距离都是整数。最终输出格式必须是单行，其中包含所有测试用例的结果，这些结果聚合在一个由方括号括起来的逗号分隔列表中，每个测试用例的结果本身也是一个由方括号括起来的逗号分隔的整数列表。也就是说，输出必须是 $[\\,[d'_0^{(1)}, d'_1^{(1)}, \\dots],\\,[d'_0^{(2)}, d'_1^{(2)}, \\dots],\\,[d'_0^{(3)}, d'_1^{(3)}, \\dots]\\,]$ 的形式，不含任何额外的空白或文本。", "solution": "用户提供的问题是有效的。它在科学上基于图论和算法设计的既定原则，特别是关于具有非负边权重的有向图中的单源最短路径问题。该问题定义明确，目标清晰，提供了所有必要的数据，并且没有内部矛盾。它要求实现一个标准且高效的算法，用于在单条边权重减少后更新最短路径树 (SPT)，这是计算机科学中一个虽然不简单但已被充分理解的任务。\n\n解决方案分两个阶段进行：首先，计算初始的最短路径树；其次，在边权重减少后对该树进行增量更新。\n\n### 1. 初始最短路径树的计算\n\n给定一个有向图 $G = (V, E)$、一个非负权重函数 $w : E \\to \\mathbb{R}_{\\ge 0}$ 和一个源顶点 $s \\in V$，单源最短路径问题是为每个顶点 $v \\in V$ 找到从 $s$ 到 $v$ 的总权重最小的路径。这样一条路径的权重表示为 $d(v)$。\n\n由于所有边权重都是非负的，迪杰斯特拉 (Dijkstra) 算法是完成此任务的权威且最高效的方法。该算法维护一个顶点集合，其中包含了已确定其与源点之间最短路径的顶点。它迭代地选择一个尚未确定且已知到 $s$ 距离最小的顶点 $u$。一旦选定，$u$ 就被视为已确定，其所有出边 $(u, v)$ 都会被“松弛”：如果通过 $u$ 发现了到任何邻居 $v$ 的更短路径（即，如果 $d(u) + w(u, v)  d(v)$），则更新距离 $d(v)$ 和前驱 $\\pi(v)$。通常使用最小优先队列在每一步中高效地选择具有最小距离的顶点。\n\n算法流程如下：\n1. 初始化一个距离数组 $d$，使得 $d(s) = 0$，对于所有 $v \\neq s$， $d(v) = \\infty$。\n2. 初始化一个前驱数组 $\\pi$，使得对于所有 $v \\in V$，$\\pi(v) = \\text{nil}$。\n3. 初始化一个包含所有顶点的最小优先队列 $Q$，使用 $d$ 中的值作为键。\n4. 当 $Q$ 不为空时：\n   a. 从 $Q$ 中提取具有最小距离的顶点 $u$。\n   b. 对于与 $u$ 相邻的每个顶点 $v$（即，对于每条边 $(u, v) \\in E$）：\n      i. 执行松弛操作：如果 $d(u) + w(u, v)  d(v)$，则更新 $d(v) \\leftarrow d(u) + w(u, v)$ 和 $\\pi(v) \\leftarrow u$。必须更新优先队列 $Q$ 以反映 $v$ 的新距离。\n\n算法终止时，$d(v)$ 将为所有顶点 $v \\in V$ 保存从 $s$ 到 $v$ 的最短路径距离，而 $\\pi$ 将定义 SPT。\n\n### 2. 在边权重减少后更新最短路径树\n\n假设我们有一个现有的 SPT，由距离数组 $d$ 和前驱图 $\\pi$ 表示。给定一条边 $(u, v) \\in E$ 的权重从 $w(u, v)$ 减少到 $w'(u, v)$，其中 $0 \\le w'(u, v)  w(u, v)$。\n\n在具有非负权重的图上，最短路径的一个基本性质是，边权重的减少只会潜在地减少到其他顶点的最短路径距离；它永远不会导致距离增加。所有先前计算出的最短路径仍然是有效的路径，尽管它们可能不再是最短的。\n\n仅当修改后的边 $(u, v)$ 提供了一条比先前已知的更短的到达顶点 $v$ 的路径时，才会触发对 SPT 的更新。到 $v$ 的新潜在路径是从 $s$ 到 $u$（成本为 $d(u)$），然后穿过修改后的边 $(u, v)$（成本为 $w'(u, v)$）。因此，改进的条件是：\n$$d(u) + w'(u, v)  d(v)$$\n\n- 如果此条件为**假**，则到 $v$ 的旧最短路径仍然优于或等于任何通过修改后的边 $(u, v)$ 的新路径。因此，到所有其他顶点的最短路径也不受影响，SPT 保持不变。新的距离 $d'$ 与旧的距离 $d$ 相同。\n\n- 如果此条件为**真**，我们找到了到顶点 $v$ 的一条新最短路径。我们必须更新其距离和前驱：\n$$d'(v) \\leftarrow d(u) + w'(u, v)$$\n$$\\pi'(v) \\leftarrow u$$\n到 $v$ 的距离的这一改进，可能反过来为从 $v$ 可达的顶点创建更短的路径。对于 $v$ 的任何邻居 $z$，路径 $s \\to \\dots \\to u \\to v \\to z$ 现在可能比到 $z$ 的现有最短路径更短。\n\n这种距离改进的传播在结构上与迪杰斯特拉算法本身的过程相同。因此，我们可以执行一个高效的局部更新。我们可以只从距离首次得到改善的顶点 $v$ 开始，启动一个类似迪杰斯特拉的程序，而不是在整个图上从源点 $s$ 重新运行迪杰斯特拉算法。\n\n更新算法如下：\n1. 设初始 SPT 由距离 $d$ 和前驱 $\\pi$ 给出。\n2. 设边 $(u, v)$ 的权重减少到 $w'(u, v)$。更新图中该权重的内部表示。\n3. 检查触发条件。如果 $d(u) + w'(u, v)  d(v)$：\n   a. 更新距离数组：$d(v) \\leftarrow d(u) + w'(u, v)$。\n   b. 更新前驱数组：$\\pi(v) \\leftarrow u$。\n   c. 初始化一个最小优先队列 $Q_{update}$ 并将 $v$ 插入其中。\n   d. 当 $Q_{update}$ 不为空时：\n      i. 从 $Q_{update}$ 中提取具有最小距离的顶点 $x$。\n      ii. 对于 $x$ 的每个邻居 $y$，松弛边 $(x, y)$：如果 $d(x) + w(x, y)  d(y)$，则更新 $d(y) \\leftarrow d(x) + w(x, y)$，设置 $\\pi(y) \\leftarrow x$，并用其新的、更低的距离在 $Q_{update}$ 中添加或更新 $y$。\n4. 如果步骤 3 中的触发条件未满足，则无需任何更改。最终的距离数组 $d'$ 就是（现在已更新的）数组 $d$。\n\n此过程比完全重新计算更高效，因为它只处理其最短路径确实受到边权重减少影响的顶点。\n\n### 应用于测试用例\n\n让我们将此逻辑应用于测试用例 1：$|V| = 6$, $s = 0$, 边为 $\\{(0, 1, 7), (0, 2, 9), (0, 5, 14), (1, 2, 10), (1, 3, 15), (2, 3, 11), (2, 5, 2), (3, 4, 6), (5, 4, 9)\\}$。\n1.  **初始 Dijkstra**：从 $s=0$ 出发的初始最短路径距离计算为 $d = [0, 7, 9, 20, 20, 11]$。\n2.  **边权重减少**：边 $(1, 2)$ 的权重减少到 $w'(1, 2) = 1$。\n3.  **更新**：\n    a. 检查条件：$d(1) + w'(1, 2)  d(2)$ 变为 $7 + 1  9$，即 $8  9$。条件为真。\n    b. 更新 $d(2) \\leftarrow 8$。用顶点 $2$ 初始化 $Q_{update}$。\n    c. 提取 $2$（成本 $8$）。松弛其出边：\n       - $(2, 3)$: $d(2) + w(2, 3) = 8 + 11 = 19$。因为 $19  d(3)=20$，更新 $d(3) \\leftarrow 19$ 并将 $3$ 添加到 $Q_{update}$。\n       - $(2, 5)$: $d(2) + w(2, 5) = 8 + 2 = 10$。因为 $10  d(5)=11$，更新 $d(5) \\leftarrow 10$ 并将 $5$ 添加到 $Q_{update}$。\n    d. $Q_{update}$ 现在包含 $\\{ (10, 5), (19, 3) \\}$。提取 $5$（成本 $10$）。松弛其出边：\n       - $(5, 4)$: $d(5) + w(5, 4) = 10 + 9 = 19$。因为 $19  d(4)=20$，更新 $d(4) \\leftarrow 19$ 并将 $4$ 添加到 $Q_{update}$。\n    e. $Q_{update}$ 现在包含 $\\{ (19, 3), (19, 4) \\}$。提取 $3$（成本 $19$）。松弛其出边：\n       - $(3, 4)$: $d(3) + w(3, 4) = 19 + 6 = 25$。因为 $25 \\not d(4)=19$，不更新。\n    f. 提取 $4$（成本 $19$）。没有出边可以松弛。\n    g. $Q_{update}$ 为空。过程终止。\n4.  **最终距离**：更新后的距离数组为 $d' = [0, 7, 8, 19, 19, 10]$。\n\n类似的分析可以得出其他测试用例的结果。对于测试用例 2，触发条件未满足，因此距离保持不变。对于测试用例 3，触发条件被满足，并发生类似的更新传播。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Solves the shortest path tree update problem for a given test suite.\n    \"\"\"\n\n    # Dijkstra's algorithm for SSSP on graphs with non-negative weights.\n    def dijkstra(num_vertices, edges, source):\n        adj = [[] for _ in range(num_vertices)]\n        for u, v, w in edges:\n            adj[u].append((v, w))\n        \n        dist = np.full(num_vertices, np.inf)\n        pred = np.full(num_vertices, -1, dtype=int)\n        \n        dist[source] = 0\n        pq = [(0, source)]\n        \n        while pq:\n            d, u = heapq.heappop(pq)\n            \n            if d > dist[u]:\n                continue\n            \n            for v, weight in adj[u]:\n                if dist[u] + weight  dist[v]:\n                    dist[v] = dist[u] + weight\n                    pred[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n        \n        # Convert infinities to a large number if needed for integer output,\n        # but the test cases are all connected.\n        return dist.astype(int), pred\n\n    # Test suite definition\n    test_suite = [\n        {\n            \"num_vertices\": 6,\n            \"source\": 0,\n            \"edges\": [\n                (0, 1, 7), (0, 2, 9), (0, 5, 14), (1, 2, 10), (1, 3, 15),\n                (2, 3, 11), (2, 5, 2), (3, 4, 6), (5, 4, 9)\n            ],\n            \"decrease\": (1, 2, 1)\n        },\n        {\n            \"num_vertices\": 6,\n            \"source\": 0,\n            \"edges\": [\n                (0, 1, 7), (0, 2, 9), (0, 5, 14), (1, 2, 10), (1, 3, 15),\n                (2, 3, 11), (2, 5, 2), (3, 4, 6), (5, 4, 9)\n            ],\n            \"decrease\": (3, 4, 4)\n        },\n        {\n            \"num_vertices\": 6,\n            \"source\": 0,\n            \"edges\": [\n                (0, 1, 7), (0, 2, 9), (0, 5, 14), (1, 2, 10), (1, 3, 15),\n                (2, 3, 11), (2, 5, 2), (3, 4, 6), (5, 4, 9)\n            ],\n            \"decrease\": (0, 2, 2)\n        }\n    ]\n\n    results = []\n\n    for case in test_suite:\n        num_v = case[\"num_vertices\"]\n        edges = case[\"edges\"]\n        source = case[\"source\"]\n        u_dec, v_dec, w_prime = case[\"decrease\"]\n        \n        # 1. Compute initial SPT distances\n        initial_dist, initial_pred = dijkstra(num_v, edges, source)\n        \n        # Make a mutable copy for the update process\n        updated_dist = initial_dist.copy()\n        \n        # Build adjacency list with original weights for propagation\n        adj = [[] for _ in range(num_v)]\n        current_edges = { (u, v): w for u, v, w in edges }\n        \n        # Apply the weight decrease\n        current_edges[(u_dec, v_dec)] = w_prime\n        \n        for (u, v), w in current_edges.items():\n            adj[u].append((v, w))\n\n        # 2. Check update condition and propagate if necessary\n        if updated_dist[u_dec] + w_prime  updated_dist[v_dec]:\n            updated_dist[v_dec] = updated_dist[u_dec] + w_prime\n            \n            # 3. Propagate updates using a Dijkstra-like process\n            pq_update = [(updated_dist[v_dec], v_dec)]\n            \n            while pq_update:\n                d, x = heapq.heappop(pq_update)\n\n                if d > updated_dist[x]:\n                    continue\n                \n                for y, weight in adj[x]:\n                    if updated_dist[x] + weight  updated_dist[y]:\n                        updated_dist[y] = updated_dist[x] + weight\n                        heapq.heappush(pq_update, (updated_dist[y], y))\n        \n        results.append(list(updated_dist))\n\n    # Format the final output string exactly as required\n    inner_strings = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3270914"}]}