{"hands_on_practices": [{"introduction": "理论是基础，但真正的理解来自于应用。让我们从一个基础问题开始，检验你对欧拉回路存在性核心条件的掌握。这个问题将向你展示，有时仅通过检查网络的基本属性（如节点的连接数），我们就能迅速判断某个任务（如遍历所有连接）是否可行，这正是欧拉图理论的强大之处 [@problem_id:1502257]。", "problem": "正在为一个包含6个服务器节点的小型容错系统设计网络架构。设计要求网络拓扑必须形成一个*简单图*，这意味着任何节点上都没有自环，并且任意两个不同节点之间最多只有一条连接（边）。此外，设计规定每个节点必须与另外3个节点直接连接；这被称为3-正则图。\n\n计划设计一个诊断程序，该程序必须从一个任意节点开始，遍历网络中的每一条连接恰好一次，并最终回到起始节点。这种遍历被称为欧拉回路。\n\n根据任何此类6节点、3-正则网络的设计规范，以下关于欧拉回路存在性的陈述中，哪一个是正确的？\n\nA. 只要图是连通的，无论具体的连接布局如何，都保证存在欧拉回路。\n\nB. 在任何满足这些规范的网络中，都不可能存在欧拉回路。\n\nC. 欧拉回路的存在性取决于具体的连接布局；一些6节点上的3-正则配置会有欧拉回路，而另一些则没有。\n\nD. 当且仅当生成的图是二分图时，才存在欧拉回路。\n\nE. 存在欧拉回路，但不存在欧拉路径（即起点和终点是不同节点的路径）。", "solution": "设 $G=(V,E)$ 是一个包含 $|V|=6$ 个顶点的简单图，且该图是 $3$-正则的。根据 $3$-正则的定义，对于每个顶点 $v\\in V$，我们有 $\\deg(v)=3$。\n\n关于欧拉回路的一个基本定理指出：一个有限图拥有欧拉回路的充分必要条件是它是连通的，并且每个顶点的度都是偶数。等价地说，其度的充分必要条件是对于所有 $v\\in V$，$\\deg(v)$ 都是偶数。\n\n在给定的 $3$-正则图中，每个顶点的度 $\\deg(v)=3$，这是一个奇数。因此，在每个顶点上，欧拉回路的偶数度条件都未被满足。这个结论与具体的连接布局和图的连通性无关；即使图是连通的，欧拉回路也不可能存在，因为所有顶点的度都是奇数。\n\n因此，对于任何包含6个顶点的简单3-正则图，欧拉回路都不可能存在。在给出的选项中，这对应于选项B。", "answer": "$$\\boxed{B}$$", "id": "1502257"}, {"introduction": "在掌握了基本判定法则后，我们来探讨一个更动态的场景：当网络结构发生改变时，欧拉路径的存在性会如何变化？这个问题模拟了网络工程师连接两个独立环形网络的过程，让你亲手分析图的构建操作如何精确地创造出满足欧拉路径条件的奇数度顶点 [@problem_id:1502239]。这不仅能加深你对“恰有两个奇数度顶点”这一条件的理解，还能让你体会到图论在网络设计中的实际应用。", "problem": "一位网络工程师正在设计一种特殊的网络拓扑结构。该设计始于两个独立的、相同的环形网络，环A和环B。每个环由 $m$ 个节点组成（其中 $m \\ge 3$），排列成一个循环图 $C_m$。在这种配置中，单个环内的每个节点都恰好与同一环中的另外两个节点相连。\n\n为了创建一个更大的单一网络，工程师在两个环之间添加了 $k$ 条新的直接通信链路，其中 $1 \\le k \\le m$。这 $k$ 条链路是通过将环A中的 $k$ 个不同节点连接到环B中的 $k$ 个不同节点来建立的。因此，这 $k$ 条新链路中的每一条都连接了环A中的一个节点和环B中的一个节点，并且没有节点是多于一条此类新链路的端点。我们将最终合并的网络称为 $G(m, k)$。\n\n工程师想要运行一个诊断测试，该测试要求找到一条路径，该路径能不多不少地遍历网络中的每一条链路（包括原始链路和新链路）一次。在图论中，这样的路径被称为欧拉路径。\n\n对于以下哪对参数 $(m, k)$，网络 $G(m, k)$ 存在欧拉路径，但不存在欧拉回路？\n\nA. $m = 8, k = 4$\n\nB. $m$ 是任何 $\\ge 3$ 的整数, $k = 2$\n\nC. $m = 9, k = 9$\n\nD. $m$ 是任何 $\\ge 3$ 的整数, 且 $k = 1$\n\nE. $m = 5, k = 5$", "solution": "每个环都是一个循环图 $C_m$，因此在添加环间链路之前，每个顶点的度都为 $2$。在环A中的 $k$ 个不同顶点与环B中的 $k$ 个不同顶点之间添加 $k$ 条链路，会使这 $2k$ 个端点的度各增加 $1$。因此：\n- 所选的 $2k$ 个端点的度变为 $3$。\n- 剩下的 $2m-2k$ 个顶点的度保持为 $2$。\n\n因此，$G(m,k)$ 中奇数度顶点的数量为\n$$\nN_{\\text{odd}}=2k.\n$$\n\n根据欧拉定理的特征：\n- 一个连通图存在欧拉回路，当且仅当所有顶点的度都为偶数，即 $N_{\\text{odd}}=0$。\n- 一个连通图存在欧拉路径（但不是欧拉回路），当且仅当恰好有两个顶点的度为奇数，即 $N_{\\text{odd}}=2$。\n\n对于所有 $k\\ge 1$，连通性都成立，因为在两个环之间添加至少一条链路会将它们连接成一个单一的连通分量。\n\n因此，$G(m,k)$ 存在欧拉回路当且仅当 $2k=0$，即 $k=0$，但这被 $k\\ge 1$ 的条件排除了。它存在欧拉路径但不存在欧拉回路，当且仅当 $2k=2$，即 $k=1$，这对任何 $m\\ge 3$ 都成立。\n\n检查选项：\n- A: $k=4\\Rightarrow N_{\\text{odd}}=8\\neq 2$。\n- B: $k=2\\Rightarrow N_{\\text{odd}}=4\\neq 2$。\n- C: $k=9\\Rightarrow N_{\\text{odd}}=18\\neq 2$。\n- D: $k=1\\Rightarrow N_{\\text{odd}}=2$，且不存在回路，因为并非所有顶点的度都为偶数。\n- E: $k=5\\Rightarrow N_{\\text{odd}}=10\\neq 2$。\n\n因此，只有选项D是正确的。", "answer": "$$\\boxed{D}$$", "id": "1502239"}, {"introduction": "仅仅判断欧拉路径或回路是否存在是不够的，真正的挑战在于找到它。这个终极实践将带你从理论走向实践，要求你实现著名的Hierholzer算法 [@problem_id:3231728]。通过编写代码，你不仅能验证存在性条件，还将学习如何在一个只有局部视图的图中，一步步构建出完整的欧拉路径，从而将抽象的图论概念转化为可执行的解决方案。", "problem": "要求您设计并实现一个完整的算法解决方案，用于在无向多重图中构建欧拉迹或欧拉回路，并遵循局部视图约束：在遍历的任何一步，您只能使用当前顶点的邻居。该解决方案必须基于第一性原理，并阐明存在性条件为何成立以及遍历过程如何从基本定义中导出。\n\n无向多重图由一个有限的顶点集合和一个有限的无向边多重集定义，其中边可以重复，也可以是自环。顶点用从 $0$ 到 $n-1$ 的整数标记。游走是一个顶点序列 $(v_0,v_1,\\dots,v_k)$，使得每个连续的顶点对 $(v_i,v_{i+1})$ 都对应多重图中的一条现有边，允许顶点重复。欧拉迹是恰好使用每条边一次的游走，其起点和终点可能不同。欧拉回路是起点和终点相同的欧拉迹。顶点 $v$ 的度，记为 $\\deg(v)$，是与该顶点关联的边的端点总数；对于 $v$ 上的一个自环，它对 $\\deg(v)$ 的贡献为 $2$。\n\n请使用以下基本依据：\n- 图论中关于度和连通性的定义：如果所有度为正的顶点都属于同一个连通分量，则图是连通的。\n- 无向图中欧拉路径存在的充要条件：如果所有顶点的度均为偶数且图是连通的（忽略孤立顶点），则存在欧拉回路；如果恰好有两个顶点的度为奇数且图是连通的（忽略孤立顶点），则存在一条欧拉迹，其端点就是那两个奇度顶点；否则，不存在欧拉迹。\n\n您的任务是在局部视图约束下实现 Hierholzer 算法。遍历过程在每一步只能检查当前顶点的邻居，并在遍历时将边标记为已使用。该算法应：\n- 使用上述定义验证存在性条件。\n- 如果存在欧拉回路，则从度为正的最小标号顶点开始。\n- 如果存在欧拉迹但不存在欧拉回路，则从度为奇数的最小标号顶点开始。\n- 如果没有边，则返回包含最小标号顶点 $0$ 的单元素列表。\n- 遍历期间，当从当前顶点出发有多条未使用的边可用时，通过优先选择标号最小的邻居来打破平局，以确保确定性。\n- 将最终的游走输出为一个顶点标号列表，该列表按顺序恰好访问每条边一次。\n\n您的程序必须在不读取输入的情况下运行，并且必须在内部评估以下无向多重图测试套件，每个测试用例由顶点数 $n$ 和一个无向边列表（以顶点对 $(u,v)$ 形式表示）指定：\n- 测试用例 $1$（正常路径，欧拉回路）：$n=4$，边集 $\\{(0,1),(1,2),(2,3),(3,0)\\}$。\n- 测试用例 $2$（欧拉迹，恰好有两个奇度顶点）：$n=4$，边集 $\\{(0,1),(1,2),(2,3)\\}$。\n- 测试用例 $3$（由于不连通而无欧拉路径）：$n=6$，边集 $\\{(0,1),(1,2),(2,0),(3,4),(4,5),(5,3)\\}$。\n- 测试用例 $4$（带自环和并行边的欧拉回路）：$n=3$，边集 $\\{(0,0),(0,1),(0,1),(1,2),(1,2),(2,0),(2,0)\\}$。\n- 测试用例 $5$（边界情况，无边）：$n=3$，边集 $\\{\\}$。\n\n对于每个测试用例，要求的结果是：\n- 一个整数列表，表示遵循打破平局规则、按顺序恰好使用每条边一次的欧拉迹或欧拉回路的顶点序列。如果不存在欧拉路径，则输出一个空列表。\n\n最终输出格式规范：\n- 您的程序应生成单行输出，其中包含所有测试用例结果的汇总列表，每个测试结果的格式都是一个不含空格、用方括号括起来、逗号分隔的整数列表。例如，如果前三个结果是列表 $[0,1,2]$、$[3,4]$ 和 $[]$，则打印的行必须是 $[[0,1,2],[3,4],[]]$，并且不能有任何空格。", "solution": "在无向多重图中构造欧拉迹或欧拉回路是图论中的一个经典问题。我们的任务是实现一个基于 Hierholzer 算法的解决方案，该方案受限于图的局部视图，同时遵守关于起点和打破平局的特定规则。验证问题陈述是强制性的第一步。\n\n### 步骤 1：提取已知条件\n\n- **图模型**：一个无向多重图，其顶点用从 $0$ 到 $n-1$ 的整数标记。边可以是平行的（重复的）和自环。\n- **游走**：一个顶点序列 $(v_0, v_1, \\dots, v_k)$，其中每对 $(v_i, v_{i+1})$ 都是一条边。\n- **欧拉迹**：恰好遍历每条边一次的游走。\n- **欧拉回路**：起点和终点相同的欧拉迹。\n- **顶点度 $\\deg(v)$**：关联边的端点总数。一个自环对其顶点的度贡献为 $2$。\n- **连通性**：如果所有度大于 $0$ 的顶点都属于同一个连通分量，则图被认为是连通的。\n- **欧拉路径的存在条件**：\n    1.  **回路**：当且仅当图是连通的（忽略孤立顶点）且所有顶点的度均为偶数时，存在欧拉回路。\n    2.  **迹**：当且仅当图是连通的（忽略孤立顶点）且恰好有两个奇度顶点时，存在欧拉迹。这两个顶点将是迹的起点和终点。\n    3.  **无**：否则，不存在欧拉路径。\n- **算法**：Hierholzer 算法，在局部视图约束下实现（在任何步骤中只知道当前顶点的邻居）。\n- **起始顶点规则**：\n    - 对于欧拉回路，从度为正的最小标号顶点开始。\n    - 对于欧拉迹，从度为奇数的最小标号顶点开始。\n    - 如果图没有边，输出应为包含顶点 $0$ 的单元素列表。\n- **打破平局规则**：当从当前顶点有多条未使用的边可用时，选择通向最小标号邻居的边。\n- **输出**：\n    - 一个表示游走中顶点序列的整数列表。\n    - 如果不存在欧拉路径，则为空列表 `[]`。\n- **测试用例**：\n    - 用例 $1$：$n=4$，边集 $\\{(0,1),(1,2),(2,3),(3,0)\\}$\n    - 用例 $2$：$n=4$，边集 $\\{(0,1),(1,2),(2,3)\\}$\n    - 用例 $3$：$n=6$，边集 $\\{(0,1),(1,2),(2,0),(3,4),(4,5),(5,3)\\}$\n    - 用例 $4$：$n=3$，边集 $\\{(0,0),(0,1),(0,1),(1,2),(1,2),(2,0),(2,0)\\}$\n    - 用例 $5$：$n=3$，边集 $\\{\\}$\n\n### 步骤 2：使用提取的已知条件进行验证\n\n根据既定标准对问题进行评估：\n\n-   **科学依据**：该问题基于成熟的欧拉图数学理论。度、连通性以及欧拉路径存在的充要条件的定义都是标准且正确的。\n-   **良构性**：问题定义明确。指定的起始规则和确定性的打破平局规则确保了对于任何有效的输入图，都存在唯一的解。输出格式也已精确指定。\n-   **客观性**：问题以正式、客观的数学语言表述，不含任何主观性或观点。\n-   **完整性与一致性**：问题提供了所有必要信息，包括图结构、算法要求和明确的存在条件。不存在内部矛盾。对于无边图的特殊处理也已明确说明。\n-   **可行性**：该问题是一个抽象的算法任务。测试用例规模小，计算上是可行的。\n-   **核心概念**：该问题直接涉及欧拉路径和欧拉回路的核心概念，并要求实现一个标准、高效的算法 (Hierholzer 算法)，使其成为一项实质性的、非平凡的任务。\n\n### 步骤 3：结论与行动\n\n该问题是**有效的**。这是一个定义明确的图论经典问题，其解决方案有一套清晰的要求。我们可以继续进行算法设计和实现。\n\n### 算法解决方案\n\n解决方案分为两个主要阶段：首先，根据图的属性验证欧拉路径的存在性；其次，如果存在，则使用 Hierholzer 算法构造该路径。\n\n**阶段 1：验证存在性条件**\n\n此阶段将理论条件转化为具体的验证过程。\n\n1.  **图表示与度计算**：多重图可以使用邻接表来表示，其中每个顶点映射到其邻居的列表。对于多重图，如果一条边 $(u,v)$ 出现 $k$ 次，$v$ 将在 $u$ 的列表中出现 $k$ 次，$u$ 也将在 $v$ 的列表中出现 $k$ 次。每个顶点 $v$ 的度 $\\deg(v)$ 就是其邻接列表的长度。这种方法能正确处理自环 $(v,v)$，因为每个自环会将 $v$ 两次添加到其自身的列表中，使其度增加 $2$。为了保证确定性，每个邻接列表必须按升序排序。\n\n2.  **度分析**：我们计算度为奇数的顶点数量。根据度数和公式 $\\sum_{v \\in V} \\deg(v) = 2|E|$，奇度顶点的数量必须是偶数。问题的条件规定，要存在欧拉路径，此计数必须为 $0$（对于回路）或 $2$（对于迹）。如果计数是任何其他数字，则不存在这样的路径。\n\n3.  **连通性检查**：如果满足度条件，我们必须验证所有度大于 $0$ 的顶点是相互可达的。这可以通过从任意一个度为正的顶点开始执行图遍历（例如，广度优先搜索或深度优先搜索）来完成。然后，我们将访问过的顶点集合与所有度为正的顶点集合进行比较。如果这两个集合不相同，则图在所要求的意义上是不连通的，不存在欧拉路径。一个例外是没有边的图，其中所有顶点都是孤立的。\n\n**阶段 2：通过 Hierholzer 算法进行构造**\n\n如果存在性条件得到满足，Hierholzer 算法提供了一种寻找该路径的构造性方法。其工作原理是寻找并合并子回路。实现此算法的一种常见且直观的方法是使用栈。\n\n1.  **初始化**：\n    -   确定起始顶点 $s$。如果有两个奇度顶点，$s$ 是标号较小的那个。如果所有顶点的度都是偶数，$s$ 是度大于 $0$ 的最小标号顶点。\n    -   初始化一个空列表 `path`，它将以相反的顺序存储最终的欧拉路径。\n    -   为遍历初始化一个栈 `stack`，并将起始顶点 $s$ 推入栈中。\n\n2.  **遍历循环**：只要 `stack` 不为空，算法就继续进行。\n    -   令 $u$ 为 `stack` 顶部的顶点。\n    -   如果顶点 $u$ 有任何未遍历的边（即其邻接表不为空）：\n        -   选择与 $u$ 的已排序邻接列表中的第一个元素对应的邻居 $v$（满足打破平局规则）。\n        -   将 $v$ 推入 `stack`。\n        -   从图中移除这条边 $(u,v)$。由于图是无向的，这涉及到从 $u$ 的邻接列表中移除 $v$，并从 $v$ 的邻接列表中移除 $u$。\n    -   如果顶点 $u$ 没有更多未遍历的边（即“卡住”了）：\n        -   这表示一个子回路（或一条迹的末端）已经完成。\n        -   将 $u$ 从 `stack` 中弹出，并将其前插到最终的 `path` 中（或者等效地，将其追加到一个临时列表中，该列表最后将被反转）。\n\n3.  **最终确定**：一旦 `stack` 为空，所有边都已被遍历。`path` 列表包含了欧拉路径的顶点，但顺序是相反的。反转此列表即可得到最终的正确序列。\n\n这个过程正确地处理了“局部视图”约束，因为在每一步，我们只查询当前顶点 $u$ 的邻接表。对邻接表的破坏性修改确保了每条边都被精确遍历一次。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for Eulerian trails/circuits in a given suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1 (Eulerian circuit)\n        (4, [(0, 1), (1, 2), (2, 3), (3, 0)]),\n        # Test case 2 (Eulerian trail)\n        (4, [(0, 1), (1, 2), (2, 3)]),\n        # Test case 3 (Disconnected, no Eulerian walk)\n        (6, [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5), (5, 3)]),\n        # Test case 4 (Eulerian circuit with self-loop and parallel edges)\n        (3, [(0, 0), (0, 1), (0, 1), (1, 2), (1, 2), (2, 0), (2, 0)]),\n        # Test case 5 (Boundary case, no edges)\n        (3, []),\n    ]\n\n    all_results = []\n    for n, edges in test_cases:\n        result = _get_eulerian_path(n, edges)\n        # Format each result list into a string without spaces\n        all_results.append(str(result).replace(' ', ''))\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(all_results)}]\")\n\ndef _get_eulerian_path(n, edges):\n    \"\"\"\n    Computes an Eulerian path or circuit for a given graph.\n\n    Args:\n        n (int): The number of vertices, labeled 0 to n-1.\n        edges (list of tuples): The list of edges in the multigraph.\n\n    Returns:\n        list: The sequence of vertices in the Eulerian path/circuit, or an\n              empty list if none exists.\n    \"\"\"\n    # Special case: a graph with no edges.\n    # The problem asks to return [0] for the smallest-labeled vertex.\n    if not edges:\n        return [0]\n\n    # 1. Build adjacency list and calculate degrees.\n    adj = {i: [] for i in range(n)}\n    degrees = {i: 0 for i in range(n)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n\n    # 2. Verify existence conditions.\n    \n    # a. Check degrees.\n    odd_degree_vertices = [v for v, d in degrees.items() if d % 2 != 0]\n    if len(odd_degree_vertices) not in [0, 2]:\n        return []\n\n    # b. Check connectivity for vertices with positive degree.\n    positive_degree_vertices = {v for v, d in degrees.items() if d > 0}\n    \n    # We need a starting point for the connectivity check.\n    start_node_for_dfs = next(iter(positive_degree_vertices))\n    \n    q = [start_node_for_dfs]\n    visited = {start_node_for_dfs}\n    head = 0\n    while head < len(q):\n        u = q[head]\n        head += 1\n        for v in adj[u]:\n            if v not in visited:\n                visited.add(v)\n                q.append(v)\n\n    if visited != positive_degree_vertices:\n        return []\n\n    # Sort adjacency lists for deterministic tie-breaking.\n    for i in range(n):\n        adj[i].sort()\n\n    # 3. Determine the start vertex for Hierholzer's algorithm.\n    if odd_degree_vertices:\n        start_vertex = min(odd_degree_vertices)\n    else:\n        start_vertex = min(positive_degree_vertices)\n\n    # 4. Implement Hierholzer's algorithm.\n    stack = [start_vertex]\n    path = []\n    \n    while stack:\n        u = stack[-1]\n        if adj[u]:\n            v = adj[u].pop(0)\n            # This removal is O(N) but sufficient for these problem sizes.\n            # A more performant approach for large graphs might use pointers\n            # or a different edge representation.\n            adj[v].remove(u)\n            stack.append(v)\n        else:\n            path.append(stack.pop())\n    \n    # The path is constructed in reverse; return the corrected order.\n    return path[::-1]\n\nsolve()\n```", "id": "3231728"}]}