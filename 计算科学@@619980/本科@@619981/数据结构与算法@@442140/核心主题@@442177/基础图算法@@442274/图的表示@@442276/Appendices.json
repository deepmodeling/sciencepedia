{"hands_on_practices": [{"introduction": "我们的第一个实践探讨一个基本的图操作——反转所有有向边。我们将分别使用邻接表和邻接矩阵来实现这一转换，从而可以直接比较它们的效率和实现逻辑。这个练习突出了不同图表示法之间的关键权衡，并要求通过伴随矩阵进行交叉验证，以加深对这些结构之间关系的理解。[@problem_id:3236874]", "problem": "考虑一个有限有向多重图，它被定义为一个有序对 $(V,E)$，其中 $V$ 是一个由从0开始的连续整数标记的有限顶点集，而 $E$ 是有序对 $(u,v)$（其中 $u \\in V$ 且 $v \\in V$）的多重集，表示从 $u$ 到 $v$ 的有向边。图中不存在自环，即形如 $(u,u)$ 的边不会出现。目标是形式化并实现图的反转操作：对于 $E$ 中的每条边 $(u,v)$，生成反转后的边 $(v,u)$，并研究当图用邻接表与邻接矩阵表示时此操作如何执行，同时使用关联矩阵交叉验证结果。\n\n基本定义：\n1. 邻接表是列表的集合 $\\{L_u\\}_{u \\in V}$，其中列表 $L_u$ 为每条边 $(u,v) \\in E$ 包含一个条目 $v$；对于平行边，存在多个条目。\n2. 邻接矩阵是一个矩阵 $A \\in \\mathbb{N}^{|V| \\times |V|}$，其条目 $A[u,v]$ 等于从 $u$ 到 $v$ 的边的数量。\n3. 有向多重图的关联矩阵是一个矩阵 $M \\in \\{-1,0,1\\}^{|V| \\times |E|}$，每条边对应一列。对于一条边 $e = (u,v)$，由 $e$ 索引的列满足 $M[u,e] = -1$，$M[v,e] = +1$，且对于所有 $w \\in V$ 且 $w \\notin \\{u,v\\}$ 的顶点，$M[w,e] = 0$。由于不包含自环，每列恰好有一个 $-1$ 和一个 $+1$。\n4. 图反转算子 $\\mathcal{R}$ 将图 $(V,E)$ 映射到 $(V,E')$，其中 $E' = \\{(v,u) : (u,v) \\in E\\}$。\n\n您必须实现算法，在输入为以下内容时计算反转后的图：\n- 邻接表 $\\{L_u\\}_{u \\in V}$。\n- 邻接矩阵 $A$。\n此外，通过从邻接表构造关联矩阵 $M$，然后对其所有条目取反以进行反转，再从反转后的关联矩阵重建一个邻接矩阵，来通过关联矩阵 $M$ 验证其正确性。为进行算法比较，定义一个简单的操作计数模型：\n- 对于邻接表反转，为初始化每个空列表 $L^{\\mathrm{rev}}_u$（对于 $u \\in V$）计1次操作，在反转过程中为每条附加的边计1次操作。总计数应为 $|V| + |E|$。\n- 对于邻接矩阵反转，构造一个同样大小的新矩阵 $A^{\\mathrm{rev}}$，并通过 $A^{\\mathrm{rev}}[i,j] := A[j,i]$ 设置每个条目。为每个对 $A^{\\mathrm{rev}}[i,j]$ 的赋值操作计1次，产生 $|V|^2$ 次操作。\n- 对于关联矩阵反转，给定大小为 $|V| \\times |E|$ 的矩阵 $M$，对所有条目设置 $M^{\\mathrm{rev}}[i,e] := -M[i,e]$，每个条目赋值计1次操作，产生 $|V|\\cdot|E|$ 次操作。\n\n测试套件：\n您必须实现以下参数化测试用例，每个用例由其顶点数 $|V|$ 和一个邻接表给出。对于每个用例，您应根据上述定义推导出相应的邻接矩阵。\n\n用例 1：$|V| = 5$。邻接表 $= \\left[ [1,1], [3], [0,4], [2], [1] \\right]$。\n用例 2：$|V| = 4$。邻接表 $= \\left[ [], [], [], [] \\right]$。\n用例 3：$|V| = 2$。邻接表 $= \\left[ [1], [] \\right]$。\n用例 4：$|V| = 4$。邻接表 $= \\left[ [1,2,3], [0,2,3], [0,1,3], [0,1,2] \\right]$。\n用例 5：$|V| = 6$。邻接表 $= \\left[ [5,5], [2], [1], [], [2], [] \\right]$。\n\n对于每个测试用例，计算：\n1. 反转后的邻接表，并将其转换为矩阵 $A^{\\mathrm{rev}}_{\\text{list}}$。\n2. 通过对原始邻接矩阵进行转置得到的反转邻接矩阵 $A^{\\mathrm{rev}}_{\\text{matrix}}$。\n3. 从原始邻接表构造的关联矩阵 $M$，通过对所有条目取反得到的反转关联矩阵 $M^{\\mathrm{rev}}$，以及从 $M^{\\mathrm{rev}}$ 重建的邻接矩阵 $A^{\\mathrm{rev}}_{\\text{inc}}$。\n\n然后，为每个测试用例报告：\n- 一个布尔值，如果 $A^{\\mathrm{rev}}_{\\text{list}}$ 等于 $A^{\\mathrm{rev}}_{\\text{matrix}}$，则为真。\n- 一个布尔值，如果 $A^{\\mathrm{rev}}_{\\text{list}}$ 等于 $A^{\\mathrm{rev}}_{\\text{inc}}$，则为真。\n- 一个等于邻接表反转操作计数的整数。\n- 一个等于邻接矩阵反转操作计数的整数。\n- 一个等于关联矩阵反转操作计数的整数。\n\n最终输出格式：\n您的程序应生成单行输出，包含用方括号括起来的、以逗号分隔的结果列表。每个元素对应一个测试用例，并且必须是按上述顺序排列的列表。例如，最终输出应类似于 $\\left[ [b_1,b'_1,c^{\\mathrm{list}}_1,c^{\\mathrm{mat}}_1,c^{\\mathrm{inc}}_1], [b_2,b'_2,c^{\\mathrm{list}}_2,c^{\\mathrm{mat}}_2,c^{\\mathrm{inc}}_2], \\ldots \\right]$，其中 $b_i$ 和 $b'_i$ 是布尔值，$c^{\\mathrm{list}}_i$、$c^{\\mathrm{mat}}_i$ 和 $c^{\\mathrm{inc}}_i$ 是整数。", "solution": "该问题是有效的。这是一个在图论和数据结构领域提法恰当且有科学依据的练习，涉及有向多重图的表示和转换。所提供的邻接表、邻接矩阵和关联矩阵的定义均为标准定义，并且它们在图反转操作下的关系陈述正确。任务是通过算法实现并验证这些关系。\n\n给定一个有向多重图 $G=(V,E)$，其中 $V=\\{0, 1, \\dots, |V|-1\\}$ 是顶点集，E 是有向边 $(u,v)$（其中 $u,v \\in V$ 且 $u \\neq v$）的多重集。图反转操作（记为 $\\mathcal{R}$）将图 $G$ 转换为一个新图 $G^{\\mathrm{rev}} = (V, E^{\\mathrm{rev}})$，其中 $E^{\\mathrm{rev}} = \\{ (v,u) : (u,v) \\in E \\}$。我们将针对表示图的三种不同数据结构，对计算 $G^{\\mathrm{rev}}$ 的过程进行形式化。\n\n首先，我们为给定的图 $G=(V,E)$ 建立基本表示法。\n- 邻接表表示法是一个列表的集合 $\\{L_u\\}_{u \\in V}$，其中每个列表 $L_u$ 为每条边 $(u,v) \\in E$ 包含一个顶点 $v$ 的条目。$v$ 在 $L_u$ 中出现的次数等于从 $u$ 到 $v$ 的平行边的数量。\n- 邻接矩阵 $A$ 是一个 $|V| \\times |V|$ 的自然数矩阵 $\\mathbb{N}$，其中条目 $A[u,v]$ 表示边 $(u,v)$ 的重数，即从顶点 $u$ 到顶点 $v$ 的边的数量。\n- 关联矩阵 $M$ 是一个 $|V| \\times |E|$ 的矩阵，其条目取值于 $\\{-1, 0, 1\\}$。每列对应 $E$ 中的一条唯一边。对于一条边 $e = (u,v)$，其对应的列满足 $M[u,e] = -1$，$M[v,e] = 1$，所有其他条目均为 $0$。\n\n该任务要求基于这些表示法，实现并比较三种获取反转图的方法。\n\n**1. 通过邻接表反转**\n\n反转操作通过直接应用其定义来执行。给定图 $G$ 的邻接表 $\\{L_u\\}_{u \\in V}$，我们为反转图 $G^{\\mathrm{rev}}$ 构造邻接表 $\\{L^{\\mathrm{rev}}_v\\}_{v \\in V}$。\n\n算法流程如下：\n1. 初始化 $|V|$ 个空列表，$L^{\\mathrm{rev}}_0, L^{\\mathrm{rev}}_1, \\dots, L^{\\mathrm{rev}}_{|V|-1}$。根据问题的计数模型，此步骤对应 $|V|$ 次操作。\n2. 遍历每个顶点 $u \\in V$。\n3. 对于出现在列表 $L_u$ 中的每个顶点 $v$，这表示存在一条边 $(u,v) \\in E$：\n   a. 相应的反转边是 $(v,u)$。\n   b. 因此，将顶点 $u$ 附加到列表 $L^{\\mathrm{rev}}_v$。此步骤对应每条边1次操作。\n4. 总操作计数是这两个步骤操作的总和，即 $|V| + |E|$，其中 $|E| = \\sum_{u \\in V} |L_u|$ 是边的总数。\n\n最后，将得到的邻接表 $\\{L^{\\mathrm{rev}}_v\\}$ 转换为邻接矩阵 $A^{\\mathrm{rev}}_{\\text{list}}$ 以用于比较，其中 $A^{\\mathrm{rev}}_{\\text{list}}[i,j]$ 是 $j$ 在列表 $L^{\\mathrm{rev}}_i$ 中出现的次数。\n\n**2. 通过邻接矩阵反转**\n\n图 $G$ 的邻接矩阵 $A$ 与其反转图 $G^{\\mathrm{rev}}$ 的邻接矩阵 $A^{\\mathrm{rev}}$ 之间是转置关系。设 $A[u,v]$ 是从 $u$ 到 $v$ 的边的数量。在反转图中，从 $v$ 到 $u$ 的边的数量（即 $A^{\\mathrm{rev}}[v,u]$）必须等于原始图中从 $u$ 到 $v$ 的边的数量。因此，对于所有 $u,v \\in V$，$A^{\\mathrm{rev}}[v,u] = A[u,v]$。这正是矩阵转置的定义，即 $A^{\\mathrm{rev}} = A^T$。\n\n该算法是：\n1. 从输入的邻接表构造原始邻接矩阵 $A$。\n2. 创建一个新的 $|V| \\times |V|$ 矩阵 $A^{\\mathrm{rev}}_{\\text{matrix}}$。\n3. 对于每对索引 $(i,j)$，其中 $i, j \\in V$：\n   a. 赋值 $A^{\\mathrm{rev}}_{\\text{matrix}}[i,j] = A[j,i]$。这是一个单独的赋值操作。\n4. 总操作计数是矩阵中条目的总数，即 $|V| \\times |V| = |V|^2$。\n\n**3. 通过关联矩阵验证**\n\n此方法通过关联矩阵表示法来验证反转操作。它包括三个步骤：为原始图构造关联矩阵 $M$，将其反转得到 $M^{\\mathrm{rev}}$，并从 $M^{\\mathrm{rev}}$ 重建邻接矩阵 $A^{\\mathrm{rev}}_{\\text{inc}}$。\n\n其代数原理是，反转一条边 $(u,v)$ 相当于交换源和目标的角色。在所定义的关联矩阵中，这对应于将与该边关联的列取反。对于一条边 $e=(u,v)$，其列的条目为 $M[u,e] = -1$ 和 $M[v,e] = 1$。反转后的边 $e^{\\mathrm{rev}} = (v,u)$ 的关联列条目则为 $M^{\\mathrm{rev}}[v,e^{\\mathrm{rev}}] = -1$ 和 $M^{\\mathrm{rev}}[u,e^{\\mathrm{rev}}] = 1$。这个新列恰好是原始列的负值。因此，反转图的关联矩阵是原始关联矩阵的负矩阵：$M^{\\mathrm{rev}} = -M$。\n\n算法如下：\n1. **M 的构造**：从输入的邻接表 $\\{L_u\\}$，构造 $|V| \\times |E|$ 的关联矩阵 $M$。这通过遍历所有边来完成，对于每条边 $e_k = (u,v)$，将 $M$ 的第 $k$ 列设置为 $M[u,k] = -1$ 和 $M[v,k] = 1$。\n2. **M 的反转**：通过对 $M$ 的每个条目取反来创建一个新矩阵 $M^{\\mathrm{rev}}$：$M^{\\mathrm{rev}}[i,k] = -M[i,k]$（对于所有 $i,k$）。此步骤的操作计数是矩阵中的条目数，即 $|V| \\cdot |E|$。\n3. **A 的重建**：从 $M^{\\mathrm{rev}}$ 重建邻接矩阵 $A^{\\mathrm{rev}}_{\\text{inc}}$。对于 $M^{\\mathrm{rev}}$ 的每一列 $k$，找到行索引 $i$ 和 $j$，使得 $M^{\\mathrm{rev}}[i,k] = -1$（新的源点）和 $M^{\\mathrm{rev}}[j,k] = 1$（新的目标点）。这对应于反转图中的一条边 $(i,j)$。将计数 $A^{\\mathrm{rev}}_{\\text{inc}}[i,j]$ 加一。\n\n此过程的成功完成以及 $A^{\\mathrm{rev}}_{\\text{list}} = A^{\\mathrm{rev}}_{\\text{matrix}} = A^{\\mathrm{rev}}_{\\text{inc}}$ 的验证，展示了这些基本图论转换在不同表示法之间的一致性。操作计数提供了一个简化的度量标准，用于比较这些算法的计算成本，并突显出数据结构的最优选择取决于图的密度和要执行的特定操作。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef adj_list_to_adj_matrix(adj_list, num_vertices):\n    \"\"\"Converts an adjacency list to an adjacency matrix.\"\"\"\n    adj_matrix = np.zeros((num_vertices, num_vertices), dtype=int)\n    for u, neighbors in enumerate(adj_list):\n        for v in neighbors:\n            adj_matrix[u, v] += 1\n    return adj_matrix\n\ndef adj_list_to_inc_matrix(adj_list, num_vertices, num_edges):\n    \"\"\"Converts an adjacency list to an incidence matrix.\"\"\"\n    if num_edges == 0:\n        return np.zeros((num_vertices, 0), dtype=int)\n    inc_matrix = np.zeros((num_vertices, num_edges), dtype=int)\n    edge_idx = 0\n    for u, neighbors in enumerate(adj_list):\n        for v in neighbors:\n            inc_matrix[u, edge_idx] = -1\n            inc_matrix[v, edge_idx] = 1\n            edge_idx += 1\n    return inc_matrix\n\ndef inc_matrix_to_adj_matrix(inc_matrix, num_vertices, num_edges):\n    \"\"\"Converts an incidence matrix to an adjacency matrix.\"\"\"\n    adj_matrix = np.zeros((num_vertices, num_vertices), dtype=int)\n    for e in range(num_edges):\n        col = inc_matrix[:, e]\n        # Find source (u) and destination (v)\n        # Using np.where returns arrays of indices.\n        u_indices = np.where(col == -1)[0]\n        v_indices = np.where(col == 1)[0]\n        if u_indices.size > 0 and v_indices.size > 0:\n            u = u_indices[0]\n            v = v_indices[0]\n            adj_matrix[u, v] += 1\n    return adj_matrix\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and compute results.\n    \"\"\"\n    test_cases = [\n        (5, [[1, 1], [3], [0, 4], [2], [1]]),\n        (4, [[], [], [], []]),\n        (2, [[1], []]),\n        (4, [[1, 2, 3], [0, 2, 3], [0, 1, 3], [0, 1, 2]]),\n        (6, [[5, 5], [2], [1], [], [2], []])\n    ]\n\n    results = []\n\n    for num_vertices, adj_list in test_cases:\n        V = num_vertices\n        E = sum(len(neighbors) for neighbors in adj_list)\n\n        # 1. Adjacency List Reversal\n        rev_adj_list = [[] for _ in range(V)]\n        for u, neighbors in enumerate(adj_list):\n            for v in neighbors:\n                rev_adj_list[v].append(u)\n        \n        A_rev_list = adj_list_to_adj_matrix(rev_adj_list, V)\n        cost_list = V + E\n        \n        # 2. Adjacency Matrix Reversal\n        A_orig = adj_list_to_adj_matrix(adj_list, V)\n        A_rev_matrix = A_orig.T\n        cost_matrix = V * V\n\n        # 3. Incidence Matrix Verification\n        M_orig = adj_list_to_inc_matrix(adj_list, V, E)\n        M_rev = -M_orig\n        A_rev_inc = inc_matrix_to_adj_matrix(M_rev, V, E)\n        cost_inc = V * E\n\n        # Comparisons\n        eq_list_matrix = np.array_equal(A_rev_list, A_rev_matrix)\n        eq_list_inc = np.array_equal(A_rev_list, A_rev_inc)\n\n        results.append([\n            eq_list_matrix,\n            eq_list_inc,\n            cost_list,\n            cost_matrix,\n            cost_inc\n        ])\n\n    # Final print statement in the exact required format.\n    # The default str() for a list includes spaces, which is standard.\n    # The template 'print(f\"[{','.join(map(str, results))}]\")' ensures there are no spaces\n    # between the outer list elements, which is a subtle but important detail.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3236874"}, {"introduction": "这个练习超越了简单的变换，揭示了图论与线性代数之间强大的联系。你将发现邻接矩阵的一个代数性质——其三次方的迹（$tr(A^3)$），可以用来计算图中的三角形数量。这个实践展示了图的代数表示法如何为组合问题解锁优雅且不明显的解决方案。[@problem_id:3236897]", "problem": "设 $G$ 是一个简单无向图，其顶点集为 $V=\\{1,2,3,4,5,6\\}$，由以下邻接表表示（每一行都列出了指定顶点的开邻域）：\n- $1:\\ \\{2,3\\}$\n- $2:\\ \\{1,3,5,6\\}$\n- $3:\\ \\{1,2,4,5\\}$\n- $4:\\ \\{3,5\\}$\n- $5:\\ \\{2,3,4\\}$\n- $6:\\ \\{2\\}$\n\n设 $A$ 表示在顶点排序 $(1,2,3,4,5,6)$ 下 $G$ 的邻接矩阵，使得\n$$\nA \\;=\\;\n\\begin{pmatrix}\n0  1  1  0  0  0\\\\\n1  0  1  0  1  1\\\\\n1  1  0  1  1  0\\\\\n0  0  1  0  1  0\\\\\n0  1  1  1  0  0\\\\\n0  1  0  0  0  0\n\\end{pmatrix}.\n$$\n仅使用图邻接矩阵乘法和迹运算的核心定义，首先证明 $\\operatorname{tr}(A^3)$ 与 $G$ 中不同 $3$-圈（三角形）数量之间的关系。然后对上面给出的特定 $A$ 计算 $\\operatorname{tr}(A^3)$ 的值，并根据您证明的关系，确定 $G$ 中的三角形数量。以单个整数形式提供最终答案。不要通过观察直接数三角形；您的计算必须通过从第一性原理分析 $\\operatorname{tr}(A^3)$ 来进行。无需四舍五入。", "solution": "该问题在图论和线性代数领域内是良构的且被验证为是合理的。给定的邻接矩阵 $A$ 在指定的顶点排序下正确地表示了由邻接表描述的图 $G$。我们开始解题。\n\n首先，我们必须建立邻接矩阵三次方的迹 $\\operatorname{tr}(A^3)$ 与图 $G$ 中 $3$-圈（三角形）数量之间的关系。设 $G$ 是一个有 $n$ 个顶点的简单无向图，设 $A$ 是其邻接矩阵，其中，如果顶点 $i$ 和 $j$ 相邻，则 $A_{ij} = 1$，否则 $A_{ij} = 0$。由于图是简单的，所以没有自环，因此对于所有 $i$，都有 $A_{ii} = 0$。\n\n邻接矩阵的幂的元素有一个众所周知的组合解释。具体来说，矩阵 $A^k$ 的元素 $(A^k)_{ij}$ 表示从顶点 $i$ 到顶点 $j$ 的长度为 $k$ 的不同途径的数量。\n\n让我们考虑矩阵 $A^2$。一个元素 $(A^2)_{ij}$ 由矩阵乘法定义给出：\n$$ (A^2)_{ij} = \\sum_{k=1}^{n} A_{ik} A_{kj} $$\n一项 $A_{ik} A_{kj}$ 为 $1$ 当且仅当 $A_{ik}=1$ 且 $A_{kj}=1$，这意味着存在一条从 $i$ 到 $k$ 的边和一条从 $k$ 到 $j$ 的边。因此，$(A^2)_{ij}$ 计数了从 $i$ 到 $j$ 经过一个中间顶点 $k$ 的长度为 $2$ 的途径的数量。\n\n现在，让我们考虑 $A^3$ 的对角线元素。元素 $(A^3)_{ii}$ 由下式给出：\n$$ (A^3)_{ii} = \\sum_{j=1}^{n} \\sum_{k=1}^{n} A_{ij} A_{jk} A_{ki} $$\n一项 $A_{ij} A_{jk} A_{ki}$ 非零（等于 1）当且仅当 $A_{ij}=1$，$A_{jk}=1$ 且 $A_{ki}=1$。这对应于边 $(i, j)$、$(j, k)$ 和 $(k, i)$ 的存在。这一系列边构成了一个从顶点 $i$ 开始并结束于顶点 $i$ 的长度为 $3$ 的闭合途径：$i \\rightarrow j \\rightarrow k \\rightarrow i$。\n\n由于图 $G$ 是简单的，它没有自环，这意味着对于任何顶点 $v$，$A_{vv}=0$。\n这意味着在任何非零项 $A_{ij} A_{jk} A_{ki}$ 中，我们不能有 $i=j$、$j=k$ 或 $k=i$。例如，如果 $j=k$，该项变为 $A_{ij} A_{jj} A_{ji}$。由于 $A_{jj}=0$，该项为零。因此，为了有非零贡献，顶点 $i$、$j$ 和 $k$ 必须是不同的。\n\n一个涉及三个不同顶点 $i, j, k$ 的长度为 3 的闭合途径定义了一个顶点集为 $\\{i, j, k\\}$ 的三角形。因此，$(A^3)_{ii}$ 计数了从 $i$ 开始并结束于 $i$ 的此类途径的数量。对于一个给定的三角形 $\\{i, j, k\\}$，有两条从 $i$ 开始的此类途径：途径 $i \\rightarrow j \\rightarrow k \\rightarrow i$ 和途径 $i \\rightarrow k \\rightarrow j \\rightarrow i$。两者都在 $(A^3)_{ii}$ 的求和中被计数。因此，$(A^3)_{ii}$ 等于包含顶点 $i$ 的三角形数量的两倍。\n\n$A^3$ 的迹是其对角线元素之和：\n$$ \\operatorname{tr}(A^3) = \\sum_{i=1}^{n} (A^3)_{ii} $$\n这个和计算了图中所有长度为 3 的闭合途径。设 $T$ 是 $G$ 中不同三角形的总数。每个三角形，比如说顶点为 $\\{v_1, v_2, v_3\\}$，都会对对角线元素 $(A^3)_{v_1 v_1}$、$(A^3)_{v_2 v_2}$ 和 $(A^3)_{v_3 v_3}$ 产生贡献。如前所述，对于它的三个顶点中的每一个，它都被计数两次。与此三角形相关的途径是：\n\\begin{itemize}\n    \\item $v_1 \\rightarrow v_2 \\rightarrow v_3 \\rightarrow v_1$ (在 $(A^3)_{v_1 v_1}$ 中计数)\n    \\item $v_1 \\rightarrow v_3 \\rightarrow v_2 \\rightarrow v_1$ (在 $(A^3)_{v_1 v_1}$ 中计数)\n    \\item $v_2 \\rightarrow v_1 \\rightarrow v_3 \\rightarrow v_2$ (在 $(A^3)_{v_2 v_2}$ 中计数)\n    \\item $v_2 \\rightarrow v_3 \\rightarrow v_1 \\rightarrow v_2$ (在 $(A^3)_{v_2 v_2}$ 中计数)\n    \\item $v_3 \\rightarrow v_1 \\rightarrow v_2 \\rightarrow v_3$ (在 $(A^3)_{v_3 v_3}$ 中计数)\n    \\item $v_3 \\rightarrow v_2 \\rightarrow v_1 \\rightarrow v_3$ (在 $(A^3)_{v_3 v_3}$ 中计数)\n\\end{itemize}\n因此，在 $\\operatorname{tr}(A^3)$ 的求和中，每个三角形总共被计数 $3 \\times 2 = 6$ 次。这就得到了关系式：\n$$ \\operatorname{tr}(A^3) = 6T $$\n因此，三角形的数量是 $T = \\frac{\\operatorname{tr}(A^3)}{6}$。\n\n现在我们对给定的图 $G$ 进行计算。邻接矩阵是：\n$$ A \\;=\\; \\begin{pmatrix} 0  1  1  0  0  0\\\\ 1  0  1  0  1  1\\\\ 1  1  0  1  1  0\\\\ 0  0  1  0  1  0\\\\ 0  1  1  1  0  0\\\\ 0  1  0  0  0  0 \\end{pmatrix} $$\n首先，我们计算 $A^2 = A \\times A$：\n$$ A^2 \\;=\\; \\begin{pmatrix} 0  1  1  0  0  0\\\\ 1  0  1  0  1  1\\\\ 1  1  0  1  1  0\\\\ 0  0  1  0  1  0\\\\ 0  1  1  1  0  0\\\\ 0  1  0  0  0  0 \\end{pmatrix} \\begin{pmatrix} 0  1  1  0  0  0\\\\ 1  0  1  0  1  1\\\\ 1  1  0  1  1  0\\\\ 0  0  1  0  1  0\\\\ 0  1  1  1  0  0\\\\ 0  1  0  0  0  0 \\end{pmatrix} \\;=\\; \\begin{pmatrix} 2  1  1  1  2  1\\\\ 1  4  2  2  1  0\\\\ 1  2  4  1  2  1\\\\ 1  2  1  2  1  0\\\\ 2  1  2  1  3  1\\\\ 1  0  1  0  1  1 \\end{pmatrix} $$\n接下来，我们需要 $A^3$ 的对角线元素。我们通过计算 $(A^3)_{ii} = \\sum_{k=1}^6 A_{ik} (A^2)_{ki}$ 来找到它们。由于 $A^2$ 是对称的，$(A^2)_{ki} = (A^2)_{ik}$。\n$$ (A^3)_{11} = A_{12}(A^2)_{21} + A_{13}(A^2)_{31} = 1 \\cdot 1 + 1 \\cdot 1 = 2 $$\n$$ (A^3)_{22} = A_{21}(A^2)_{12} + A_{23}(A^2)_{32} + A_{25}(A^2)_{52} + A_{26}(A^2)_{62} = 1 \\cdot 1 + 1 \\cdot 2 + 1 \\cdot 1 + 1 \\cdot 0 = 4 $$\n$$ (A^3)_{33} = A_{31}(A^2)_{13} + A_{32}(A^2)_{23} + A_{34}(A^2)_{43} + A_{35}(A^2)_{53} = 1 \\cdot 1 + 1 \\cdot 2 + 1 \\cdot 1 + 1 \\cdot 2 = 6 $$\n$$ (A^3)_{44} = A_{43}(A^2)_{34} + A_{45}(A^2)_{54} = 1 \\cdot 1 + 1 \\cdot 1 = 2 $$\n$$ (A^3)_{55} = A_{52}(A^2)_{25} + A_{53}(A^2)_{35} + A_{54}(A^2)_{45} = 1 \\cdot 1 + 1 \\cdot 2 + 1 \\cdot 1 = 4 $$\n$$ (A^3)_{66} = A_{62}(A^2)_{26} = 1 \\cdot 0 = 0 $$\n$A^3$ 的迹是这些对角线元素之和：\n$$ \\operatorname{tr}(A^3) = (A^3)_{11} + (A^3)_{22} + (A^3)_{33} + (A^3)_{44} + (A^3)_{55} + (A^3)_{66} $$\n$$ \\operatorname{tr}(A^3) = 2 + 4 + 6 + 2 + 4 + 0 = 18 $$\n最后，我们使用推导出的关系来找到三角形的数量 $T$：\n$$ T = \\frac{\\operatorname{tr}(A^3)}{6} = \\frac{18}{6} = 3 $$\n图 $G$ 中不同三角形的数量是 3。", "answer": "$$\\boxed{3}$$", "id": "3236897"}, {"introduction": "最后的这个实践提出了一个算法挑战：仅使用邻接矩阵，在线性时间（$O(n)$）内找到有向图中的“汇点”（sink）。一个朴素的 $O(n^2)$ 方法会因为效率太低而无法接受，因此这个问题促使你批判性地思考邻接矩阵的结构，以设计出一个巧妙的最优算法。这是一个完美的例子，说明了数据结构的特性如何指导高效的算法设计。[@problem_id:3236899]", "problem": "给定一个仅由其邻接矩阵表示的有向图。一个有向图有一个顶点集 $V$，其中 $|V| = n$，顶点标记为 $0,1,\\dots,n-1$。其邻接矩阵是一个 $n \\times n$ 的矩阵 $A$，其元素属于 $\\{0,1\\}$，其中当且仅当存在一条从顶点 $i$ 到顶点 $j$ 的有向边时，$A[i][j] = 1$，否则 $A[i][j] = 0$。假设该图是简单有向图：不存在自环和多重边，因此对所有 $i$ 都有 $A[i][i] = 0$。汇点是一个顶点 $s \\in V$，其出度为 $0$，入度为 $n-1$。等价地，在邻接矩阵中，第 $s$ 行全部为零，而第 $s$ 列在除对角线位置外的所有位置上都为 1，在此设定中对角线项为零。\n\n根据上述核心定义，设计一个程序，仅使用邻接矩阵表示来判断是否存在汇点，如果存在，则返回其索引。你的程序必须在 $O(n)$ 时间内运行，其中 $n = |V|$，并且不得将邻接矩阵转换为其他表示形式，如邻接表或关联矩阵。如果没有汇点，则返回 $-1$。对于特殊的边界情况 $n = 0$，返回 $-1$。\n\n你的程序必须处理以下固定的邻接矩阵测试套件（每个矩阵是一个由 $\\{0,1\\}$ 中的整数组成的列表的列表），并为每个矩阵生成一个整数结果：\n\n- 测试用例 1 ($n = 5$): 一个在索引 3 处有汇点的图。\n  矩阵:\n  [\n    [$0$,$1$,$0$,$1$,$0$],\n    [$0$,$0$,$1$,$1$,$0$],\n    [$1$,$0$,$0$,$1$,$0$],\n    [$0$,$0$,$0$,$0$,$0$],\n    [$0$,$1$,$0$,$1$,$0$]\n  ]\n\n- 测试用例 2 ($n = 4$): 一个有向环；不存在汇点。\n  矩阵:\n  [\n    [$0$,$1$,$0$,$0$],\n    [$0$,$0$,$1$,$0$],\n    [$0$,$0$,$0$,$1$],\n    [$1$,$0$,$0$,$0$]\n  ]\n\n- 测试用例 3 ($n = 1$): 一个单顶点图；唯一的顶点是汇点。\n  矩阵:\n  [\n    [$0$]\n  ]\n\n- 测试用例 4 ($n = 0$): 空图；按惯例返回 $-1$。\n  矩阵:\n  [ ]\n\n- 测试用例 5 ($n = 4$): 一个在索引 0 处有汇点的图。\n  矩阵:\n  [\n    [$0$,$0$,$0$,$0$],\n    [$1$,$0$,$1$,$0$],\n    [$1$,$0$,$0$,$1$],\n    [$1$,$1$,$0$,$0$]\n  ]\n\n- 测试用例 6 ($n = 4$): 一个在索引 2 处有出度为 0 的顶点，但缺少一条入边；不存在汇点。\n  矩阵:\n  [\n    [$0$,$1$,$0$,$0$],\n    [$0$,$0$,$1$,$0$],\n    [$0$,$0$,$0$,$0$],\n    [$1$,$0$,$1$,$0$]\n  ]\n\n输出规范：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例 1 到 6 的顺序排列结果。例如，形如 [$r_1$,$r_2$,$r_3$,$r_4$,$r_5$,$r_6$] 的输出行，其中每个 $r_i$ 是测试用例 $i$ 的整数结果。", "solution": "该问题已经过验证，并被确定为图算法领域中一个有效且定义明确的问题。所有提供的信息都是自洽、一致的，并且科学地基于图论的既定原则。有向图、其邻接矩阵表示以及汇点的定义都是标准的。该问题要求一个具有特定时间复杂度约束 $O(n)$ 的算法，这使其从一个简单的搜索问题提升为一个正式的算法挑战。\n\n任务是在一个由 $n \\times n$ 邻接矩阵 $A$ 表示的有向图中找到一个汇点。汇点 $s$ 被定义为一个入度为 $n-1$ 且出度为 $0$ 的顶点。就邻接矩阵 $A$ 而言，这意味着对于一个汇点 $s$：\n1.  第 $s$ 行必须全为零：$A[s][j] = 0$ 对所有 $j \\in \\{0, 1, \\dots, n-1\\}$ 成立。这对应于出度为 $0$。\n2.  第 $s$ 列必须全为一，对角线位置除外：$A[j][s] = 1$ 对所有 $j \\in \\{0, 1, \\dots, n-1\\}$ 且 $j \\neq s$ 成立。这对应于入度为 $n-1$。问题规定对所有 $i$ 都有 $A[i][i] = 0$，这与该定义一致。\n\n汇点的一个关键特性是其唯一性。如果一个图包含汇点，它只能包含一个。假设，为了引出矛盾，存在两个不同的汇点 $s_1$ 和 $s_2$。由于 $s_1$ 是一个汇点，其入度必须为 $n-1$，这意味着从其他所有顶点都必须有一条有向边指向 $s_1$。因此，必须存在一条边 $(s_2, s_1)$。然而，由于 $s_2$ 也是一个汇点，其出度必须为 $0$，这意味着从 $s_2$ 不能有任何出边。这与边 $(s_2, s_1)$ 的存在相矛盾。因此，一个图最多只能有一个汇点。\n\n一种朴素的查找汇点的方法是遍历每个顶点 $i \\in \\{0, 1, \\dots, n-1\\}$，并验证它是否满足汇点的条件。验证单个顶点需要检查其整行和整列，这需要 $O(n)$ 的时间。对所有 $n$ 个顶点重复此操作，总时间复杂度为 $O(n^2)$。该问题要求一个时间复杂度为 $O(n)$ 的更高效算法。\n\n可以使用一个两阶段过程来实现 $O(n)$ 的解法：候选者排除，然后是验证。\n\n**阶段 1：候选者排除**\n\n此阶段的核心原则是在 $O(n)$ 时间内丢弃不可能是汇点的顶点，最终留下至多一个候选者。我们可以遍历顶点并逐步排除非汇点候选者。\n\n1.  我们首先假设顶点 0 是一个潜在的汇点。我们维护一个变量 `candidate`，并将其初始化为 $0$。\n2.  然后我们遍历其余的顶点，$i = 1, 2, \\dots, n-1$。在每一步中，我们将当前的 `candidate` 与顶点 $i$ 进行比较。\n3.  我们检查矩阵项 $A[\\text{candidate}][i]$。\n    -   如果 $A[\\text{candidate}][i] = 1$，这表示存在一条从 `candidate` 到 $i$ 的边。汇点不能有任何出边（出度必须为 0）。因此，当前的 `candidate` 绝对不是汇点。我们将其从考虑中排除。在这种情况下，顶点 $i$ 成为我们的新 `candidate`。虽然 $i$ 本身可能不是汇点，但它成功地“否定”了前一个候选者，并且它是下一个要考虑的顶点。\n    -   如果 $A[\\text{candidate}][i] = 0$，这表示不存在从 `candidate` 到 $i$ 的边。一个汇点必须有来自其他所有顶点的入边（入度必须为 $n-1$）。缺少从 `candidate` 到 $i$ 的边证明了顶点 $i$ 不可能是汇点。因此，我们可以将 $i$ 从考虑中排除。当前的 `candidate` 通过了这个测试，并仍然是 `candidate`。\n\n这个排除过程正好执行 $n-1$ 次比较，每次对应一个从 1 到 $n-1$ 的 $i$。循环完成后，我们只剩下一个在排除过程中幸存下来的顶点。这是我们唯一的汇点候选者。此阶段的时间复杂度为 $O(n)$。\n\n**阶段 2：候选者验证**\n\n排除阶段保证了如果存在汇点，它必定是最终的 `candidate`。然而，它并不能保证这个 `candidate` 实际上是一个汇点。该候选者可能仅仅因为它排除了所有其他竞争者而被选中，即使它本身并不满足汇点的属性。因此，最终的验证步骤是强制性的。\n\n设最终候选者为 $c$。我们必须验证 $c$ 是否满足成为汇点的两个条件：\n1.  **出度为零**：遍历列索引 $j = 0, 1, \\dots, n-1$。如果我们找到任何使得 $A[c][j] = 1$ 的 $j$，那么顶点 $c$ 的出度不为零，不可能是汇点。\n2.  **入度为 $n-1$**：遍历行索引 $i = 0, 1, \\dots, n-1$。如果我们找到任何 $i \\neq c$ 使得 $A[i][c] = 0$，那么顶点 $c$ 缺少一条入边，其入度小于 $n-1$。它不可能是汇点。我们还必须确认 $A[c][c] = 0$，这一点由问题陈述保证。\n\n这个验证需要扫描矩阵的一整行和一整列，这需要 $O(n)$ 的时间。\n\n如果候选者 $c$ 通过了两个验证检查，它就是唯一的汇点，并返回其索引 $c$。如果任一检查失败，则意味着图中没有顶点满足汇点的条件，因此不存在汇点。在这种情况下，返回 $-1$。\n\n整个算法由 $O(n)$ 的排除阶段和 $O(n)$ 的验证阶段组成，总时间复杂度为 $O(n) + O(n) = O(n)$，满足了问题的约束。该算法为候选者和循环索引使用了常数级别的额外空间，因此其空间复杂度为 $O(1)$。必须处理 $n=0$ 和 $n=1$ 的特殊情况。对于 $n=0$，没有顶点，因此没有汇点；我们返回 $-1$。对于 $n=1$，唯一的顶点 0 的入度为 $1-1=0$，出度为 $0$，因此它是一个汇点。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the sink-finding problem for a predefined test suite of graphs.\n    \"\"\"\n    # Define the test cases from the problem statement as numpy arrays.\n    test_cases = [\n        # Test case 1 (n=5, sink at 3)\n        np.array([\n            [0, 1, 0, 1, 0],\n            [0, 0, 1, 1, 0],\n            [1, 0, 0, 1, 0],\n            [0, 0, 0, 0, 0],\n            [0, 1, 0, 1, 0]\n        ]),\n        # Test case 2 (n=4, no sink)\n        np.array([\n            [0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [1, 0, 0, 0]\n        ]),\n        # Test case 3 (n=1, sink at 0)\n        np.array([\n            [0]\n        ]),\n        # Test case 4 (n=0, no sink)\n        np.array([]).reshape(0,0),\n        # Test case 5 (n=4, sink at 0)\n        np.array([\n            [0, 0, 0, 0],\n            [1, 0, 1, 0],\n            [1, 0, 0, 1],\n            [1, 1, 0, 0]\n        ]),\n        # Test case 6 (n=4, no sink)\n        np.array([\n            [0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 0],\n            [1, 0, 1, 0]\n        ])\n    ]\n\n    results = []\n    \n    for A in test_cases:\n        n = A.shape[0]\n\n        # Handle boundary case for an empty graph (n=0).\n        if n == 0:\n            results.append(-1)\n            continue\n        \n        # Phase 1: Candidate Elimination in O(n)\n        # We find a single candidate that could be a sink.\n        candidate = 0\n        for i in range(1, n):\n            # If A[candidate][i] is 1, there's an edge candidate -> i.\n            # This means 'candidate' cannot be a sink (out-degree > 0).\n            # The new candidate becomes i.\n            # If A[candidate][i] is 0, there is no edge candidate -> i.\n            # This means 'i' cannot be a sink (in-degree  n-1).\n            # The current 'candidate' survives.\n            if A[candidate, i] == 1:\n                candidate = i\n        \n        # Phase 2: Candidate Verification in O(n)\n        # Check if the final candidate is indeed a sink.\n        is_sink = True\n        for i in range(n):\n            # A sink must have an out-degree of 0.\n            # Check if the candidate's row has any 1s.\n            if A[candidate, i] == 1:\n                is_sink = False\n                break\n            \n            # A sink must have an in-degree of n-1.\n            # Check if the candidate's column has any 0s (for i != candidate).\n            # The A[i][i] == 0 condition is given.\n            if i != candidate and A[i, candidate] == 0:\n                is_sink = False\n                break\n        \n        if is_sink:\n            results.append(candidate)\n        else:\n            results.append(-1)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3236899"}]}