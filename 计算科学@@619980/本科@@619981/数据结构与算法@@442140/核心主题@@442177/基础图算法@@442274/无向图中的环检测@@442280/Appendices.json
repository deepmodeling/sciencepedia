{"hands_on_practices": [{"introduction": "这项练习将解决本主题中最基本的问题：一个图是否包含环？我们将通过设计一个不会让玩家迷路的地下城地图的场景，来探索经典的深度优先搜索（DFS）方法。通过在遍历过程中识别“返祖边”，我们可以有效地判断一个图是否为森林，这是解决许多图相关问题的基础技能。[@problem_id:3225348]", "problem": "一个视频游戏的地牢布局可以被建模为一个有限、简单、无向的图，其顶点集为 $V$，边集为 $E$。其中每个顶点是一个房间，每条边是连接两个不同房间的双向走廊。一个环是指一个由 $k \\geq 3$ 个不同顶点组成的序列 $v_0, v_1, \\dots, v_{k-1}$，使得对于每一个 $i \\in \\{0, 1, \\dots, k-1\\}$，点对 $\\{v_i, v_{(i+1) \\bmod k}\\}$ 都是一条边。如果一个图不包含任何环，则称其为无环图。森林是一个无环的无向图，可能包含多个连通分量。为确保地牢是一个简单的分支路径系统而不是一个迷宫，它的每个连通分量都必须是无环的，也就是说，它必须是一个森林。\n\n基本设定和约束：\n- 图是有限、简单且无向的：边是不同顶点的无序对，不存在多重边，也不存在自环。\n- 顶点由从 $0$ 到 $n-1$ 的连续整数标记，其中 $n = |V|$。\n- 任务是根据上述定义判断图的无环性，而不是假设任何特定的算法捷径。\n\n任务：\n- 编写一个完整的程序，对下面的每个测试用例，判断给定的无向图是否在每个连通分量中都是无环的（即，判断它是否为森林），并为每个用例输出一个布尔值。\n\n程序的输入模型：\n- 没有外部输入。请使用下面嵌入的测试套件作为内部数据源。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内不含空格，结果顺序与下方测试用例的顺序列出。每个元素必须是 `True` 或 `False`，且大小写完全一致。例如，一个有效的输出格式是 `[True,False]`。\n\n测试套件（每个测试用例是一个对 $(n, E)$，其中 $n$ 是顶点数，$E$ 是由顶点标签的无序对组成的无向边列表）：\n- 用例 1：$n = 5$, $E = \\{(0,1),(1,2),(1,3),(3,4)\\}$。这个连通图有分支但没有环；它应该是无环的。\n- 用例 2：$n = 5$, $E = \\{(0,1),(1,2),(2,3),(3,0)\\}$。这个连通图包含一个环；它应该是有环的。\n- 用例 3：$n = 7$, $E = \\{(0,1),(0,2),(2,3),(4,5)\\}$，顶点 $6$ 是孤立的。这个不连通图只包含树组件和一个孤立顶点；它应该是无环的。\n- 用例 4：$n = 6$, $E = \\{(0,1),(1,2),(2,0),(3,4),(4,5)\\}$。这个不连通图有一个有环的连通分量和一个无环的连通分量；总的来说它应该是有环的。\n- 用例 5：$n = 1$, $E = \\{\\}$。一个孤立顶点；它应该是无环的。\n- 用例 6：$n = 2$, $E = \\{(0,1)\\}$。连接两个顶点的一条边；它应该是无环的。\n\n您的程序必须为每个用例计算一个布尔值，以指示图是否为无环的（当且仅当图是森林时为 True），然后按上述确切格式打印单行文本，该行按顺序汇总了用例 1 到 6 的结果。此问题不涉及任何物理单位或角度单位，输出中不允许也不需要百分比表达式。预期的答案类型是布尔值。", "solution": "问题要求判断一个给定的简单无向图是否为森林。森林被定义为一个无环的无向图，它可能由一个或多个连通分量组成，其中每个分量都是一棵树（一个无环连通图）或一个孤立顶点。问题的核心是检测图中任何连通分量内是否存在环。一个图是无环的，当且仅当它不包含任何环。\n\n在无向图中检测环最基本、最严谨的方法是使用图遍历算法，例如深度优先搜索 (DFS)。使用 DFS 进行环检测的原理基于 DFS 遍历本身的结构，该遍历将图的边划分为树边和后向边。\n\n一个无向图中存在环，当且仅当 DFS 遍历遇到一条“后向边”。后向边是一条从当前访问的顶点 $u$ 连接到顶点 $v$ 的边 $(u, v)$，其中顶点 $v$ 已经被访问过，并且在 DFS 树中不是 $u$ 的直接父节点。如果 $v$ 是 $u$ 的父节点，那么边 $(u, v)$ 只是用于发现 $u$ 的那条树边，追溯它不会形成环。然而，如果 $v$ 已被访问过且不是 $u$ 的父节点，这意味着 $v$ 是 $u$ 在 DFS 树中的一个祖先，而边 $(u, v)$ 闭合了一条路径，从而形成一个环。\n\n对于每个测试用例，即图 $G = (V, E)$（其中 $n = |V|$ 个顶点的标签为 $0, 1, \\dots, n-1$），算法按以下步骤进行：\n\n1.  **图表示**：首先将以边列表 $E$ 形式给出的图转换为邻接表表示。邻接表（记为 `adj`）是一个数组或映射，其中 `adj[u]` 存储了所有满足 $\\{u, v\\} \\in E$ 的顶点 $v$ 的列表。这种结构可以高效地遍历任何给定顶点的邻居。\n\n2.  **状态跟踪**：初始化一个大小为 $n$ 的布尔数组 `visited`，所有条目均设为 `False`。该数组用于跟踪在遍历过程中已访问过的顶点。`visited[v] = True` 表示顶点 $v$ 已被访问过。\n\n3.  **连通分量遍历**：为了处理可能不连通的图（即具有多个连通分量），算法遍历每个顶点 $u \\in \\{0, 1, \\dots, n-1\\}$。如果一个顶点 $u$ 尚未被访问（`visited[u]` 为 `False`），这标志着一个未探索的新连通分量的开始。从该顶点 $u$ 启动一次 DFS 遍历。\n\n4.  **用于环检测的递归 DFS**：定义一个递归函数（我们称之为 `dfs_check(u, p)`）来执行遍历和环检测。\n    -   它接受两个参数：当前正在访问的顶点 $u$，以及在 DFS 树中发现 $u$ 的父节点 $p$。父节点 $p$ 对于区分有效的父子树边和形成环的后向边至关重要。对于新连通分量的初始调用，父节点可以是一个哨兵值，例如 $-1$，因为 DFS 树的根节点没有父节点。\n    -   进入 `dfs_check(u, p)` 时：\n        a. 将当前顶点 $u$ 标记为已访问：`visited[u] = True`。\n        b. 算法遍历 $u$ 的邻接表中的每个邻居 $v$。\n        c. 对于每个邻居 $v$：\n            i.  如果 $v$ 尚未被访问（`visited[v]` 为 `False`），则意味着 $(u, v)$ 是一条树边。进行递归调用 `dfs_check(v, u)` 以继续向图的更深处遍历。如果此递归调用返回 `True`（表示在以 $v$ 为根的子树中发现了环），当前函数立即返回 `True`，将环检测结果向上传递到调用栈。\n            ii. 如果 $v$ 已经被访问过（`visited[v]` 为 `True`）且 $v$ 不是 $u$ 的父节点（即 $v \\neq p$），此条件表示找到了一条后向边。顶点 $v$ 在当前遍历中较早被访问，意味着在 DFS 树中存在一条从 $v$ 到 $u$ 的路径，而边 $(u, v)$ 闭合了这条路径，形成一个环。在这种情况下，函数返回 `True`。\n    -   如果遍历完 $u$ 的所有邻居后循环结束且未返回 `True`，则意味着在以 $u$ 为根的子树中没有检测到环。函数随后返回 `False`。\n\n5.  **最终判定**：在从顶点 $0$ 遍历到 $n-1$ 的主循环中，如果任何对 `dfs_check` 的调用返回 `True`，则意味着在图的某处找到了一个环。算法可以立即终止，并断定该图不是森林。此测试用例的结果为 `False`。如果主循环完成而没有任何 `dfs_check` 调用返回 `True`，则确认图的任何连通分量中都不存在环。因此，该图是一个森林，此测试用例的结果为 `True`。\n\n这个过程对于任何有限、简单、无向图都是详尽且正确的。它能正确处理孤立顶点、单个连通分量（树）和多个不连通的分量（森林）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the cycle detection problem for a batch of test cases.\n    \"\"\"\n    \n    # Test suite as defined in the problem statement.\n    test_cases = [\n        # Case 1: n = 5, E = {(0,1),(1,2),(1,3),(3,4)} -> Acyclic (Tree)\n        (5, [(0, 1), (1, 2), (1, 3), (3, 4)]),\n        # Case 2: n = 5, E = {(0,1),(1,2),(2,3),(3,0)} -> Cyclic\n        (5, [(0, 1), (1, 2), (2, 3), (3, 0)]),\n        # Case 3: n = 7, E = {(0,1),(0,2),(2,3),(4,5)} -> Acyclic (Forest)\n        (7, [(0, 1), (0, 2), (2, 3), (4, 5)]),\n        # Case 4: n = 6, E = {(0,1),(1,2),(2,0),(3,4),(4,5)} -> Cyclic (one component)\n        (6, [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5)]),\n        # Case 5: n = 1, E = {} -> Acyclic (Isolated vertex)\n        (1, []),\n        # Case 6: n = 2, E = {(0,1)} -> Acyclic (Single edge)\n        (2, [(0, 1)])\n    ]\n\n    def is_graph_acyclic(n, edges):\n        \"\"\"\n        Determines if a graph with n vertices and a given edge list is acyclic.\n        An empty graph or a graph with no vertices is considered acyclic.\n        \n        Args:\n            n (int): The number of vertices, labeled 0 to n-1.\n            edges (list of tuples): The list of edges in the graph.\n            \n        Returns:\n            bool: True if the graph is a forest (acyclic), False otherwise.\n        \"\"\"\n        if n == 0:\n            return True\n        \n        # 1. Build adjacency list representation of the graph\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n            \n        # 2. Keep track of visited vertices for all DFS traversals\n        visited = [False] * n\n\n        def has_cycle_dfs(u, parent):\n            \"\"\"\n            Recursive DFS function to detect a cycle in a connected component.\n            \n            Args:\n                u (int): The current vertex being visited.\n                parent (int): The parent vertex from which u was discovered.\n            \n            Returns:\n                bool: True if a cycle is detected, False otherwise.\n            \"\"\"\n            visited[u] = True\n            \n            for v in adj[u]:\n                # If neighbor v is not visited yet, recurse on it\n                if not visited[v]:\n                    if has_cycle_dfs(v, u):\n                        return True\n                # If v is visited and is not the parent of u, then there is a cycle\n                elif v != parent:\n                    return True\n            \n            return False\n\n        # 3. Iterate through all vertices to handle disconnected graphs (forests)\n        for i in range(n):\n            if not visited[i]:\n                # If a cycle is found in any component, the whole graph is considered cyclic.\n                # The parent of the starting node of a component's traversal is -1 (a sentinel value).\n                if has_cycle_dfs(i, -1):\n                    return False\n        \n        # 4. If no cycles are found after checking all components, the graph is acyclic.\n        return True\n\n    results = []\n    for n, edges in test_cases:\n        # Acyclic means it's a forest, so the function should return True.\n        # We want to output this boolean directly.\n        is_acyclic = is_graph_acyclic(n, edges)\n        results.append(str(is_acyclic))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3225348"}, {"introduction": "在仅仅检测环存在与否的基础上，这项练习将挑战我们去寻找图中*最短*环的长度，这个属性被称为图的“围长”（girth）。我们将学习为何广度优先搜索（BFS）是完成此任务的理想工具，因为它天然地按距离递增的层次来探索图。这个练习有助于巩固对 BFS 特性及其在图优化问题中应用的理解。[@problem_id:3225402]", "problem": "您的任务是设计并实现一个完整的、可运行的程序，用于计算一个无向、简单、无权图的围长（girth）。图的围长定义为其最短环的长度（边的数量）。如果一个图没有环，其围长定义为 $0$。所有顶点都用从 $0$ 开始的连续整数进行标记。图由顶点数和无向边列表指定。测试套件中的图是简单图：不包含平行边和自环。\n\n基本定义和事实构成了本任务的基础：\n- 无向图 $G$ 是一个对 $G = (V, E)$，其中 $V$ 是顶点集，$E$ 是无向边集，每条边是 $V$ 的一个 $2$ 元子集。\n- 路径是一个顶点序列，其中连续的顶点对由边连接。\n- 环是一个起点和终点相同，且至少包含 $3$ 个不同顶点的路径。\n- 广度优先搜索 (BFS) 是一种算法，它在无权图中按与所选源顶点距离（以边的数量计）非递减的顺序探索顶点。\n- 从源顶点 $s$ 到顶点 $u$ 的 BFS 距离，记作 $d_s(u)$，等于从 $s$ 到 $u$ 的最短路径长度。\n\n从这些核心定义和事实出发，推导出一个计算一般无向简单图围长的算法。程序不得接受输入；相反，它必须嵌入并执行一个预定义的图测试套件，为每个图计算围长，然后按指定的最终输出格式打印结果。\n\n模型和假设：\n- 每个图由顶点数 $n$ 和一个边列表指定，边列表中的有序对 $(i,j)$ 代表无向边 $\\{i,j\\}$，其中 $i \\in \\{0,1,\\dots,n-1\\}$ 且 $j \\in \\{0,1,\\dots,n-1\\}$，且 $i \\neq j$。\n- 所有图都是简单且无向的：没有平行边，没有自环。\n- 围长是所有连通分量中最小的环长度；如果任何分量中都不存在环，则围长为 $0$。\n\n测试套件：\n为以下五个图计算围长。顶点标签从 $0$ 开始。\n\n- 测试用例 1（多个环；最小的是一个三角形）：\n  - $n = 7$\n  - $E = \\{(0,1),(1,2),(2,0),(2,3),(3,4),(4,5),(5,2),(5,6)\\}$\n  - 预期围长为 $3$。\n- 测试用例 2（无环树）：\n  - $n = 5$\n  - $E = \\{(0,1),(1,2),(2,3),(3,4)\\}$\n  - 预期围长为 $0$。\n- 测试用例 3（一个长度为 $4$ 的环带分支）：\n  - $n = 6$\n  - $E = \\{(0,1),(1,2),(2,3),(3,0),(0,4),(2,5)\\}$\n  - 预期围长为 $4$。\n- 测试用例 4（不连通：一个路径分量和一个 $5$ 环分量）：\n  - $n = 8$\n  - $E = \\{(0,1),(1,2),(3,4),(4,5),(5,6),(6,7),(7,3)\\}$\n  - 预期围长为 $5$。\n- 测试用例 5（带尾巴的六边形）：\n  - $n = 7$\n  - $E = \\{(0,1),(1,2),(2,3),(3,4),(4,5),(5,0),(0,6)\\}$\n  - 预期围长为 $6$。\n\n最终输出格式：\n您的程序应生成一行输出，包含用方括号括起来的逗号分隔的结果列表，不含空格。例如，如果计算出的五个围长是 $3, 0, 4, 5, 6$，则输出必须是 [$3$,$0$,$4$,$5$,$6$]。", "solution": "该问题要求推导并实现一个算法，以计算一个简单、无向、无权图 $G=(V, E)$ 的围长，其中 $V$ 是顶点集，$E$ 是边集。围长定义为图中最小环的长度。如果图不包含环（即，它是一个森林），其围长定义为 $0$。\n\n在图中寻找环的基本原理是在遍历过程中检测到“后向边”。后向边是指在遍历树中将一个顶点连接到其非直接父节点的祖先节点的边。寻找*最短*环最合适的遍历算法是广度优先搜索 (BFS)，因为 BFS 逐层探索图，保证能找到从源顶点到所有其他顶点的边数最少的路径。\n\n让我们将算法形式化。图的围长是其所有连通分量中最小的环长度。因此，我们的算法必须能正确处理连通图和非连通图。我们可以通过遍历图的每个顶点并发起一次遍历来实现这一点，以确保所有分量都被探索到。总围长将是每个分量中找到的最短环长度的最小值。\n\n该算法的核心在于从每个顶点 $s \\in V$ 运行一次独立的 BFS。对于从源 $s$ 开始的给定 BFS，我们维护从 $s$ 到每个其他顶点 $u$ 的距离 $d_s(u)$，以及 BFS 树中每个顶点 $u$ 的父节点 $p_s(u)$。\n\n在从 $s$ 开始的 BFS 期间，让我们考虑当我们位于顶点 $u$ 并探索其相邻顶点时的过程。对于 $u$ 的每个邻居 $v$：\n$1$。如果在此次 BFS 中 $v$ 尚未被访问（即 $d_s(v) = \\infty$），我们找到了一个新顶点加入 BFS 树。我们设置其距离 $d_s(v) = d_s(u) + 1$ 及其父节点 $p_s(v) = u$。\n$2$。如果 $v$ 已被访问，则检测到一个环。边 $(u,v)$ 闭合了一个回路。这个回路由三部分组成：从源 $s$ 到 $u$ 的路径，边 $(u,v)$，以及从 $v$ 回到源 $s$ 的路径。然而，我们必须排除 $v$ 是 $u$ 的直接父节点（即 $v = p_s(u)$）的平凡情况，因为在无向图中，这仅对应于遍历一条边及其反向边，并不构成一个环。因此，当且仅当 $v$ 已被访问且 $v \\neq p_s(u)$ 时，才确认存在一个环。\n\n当找到这样一个环时，其长度是 $u$ 和 $v$ 距源 $s$ 的距离之和，再加上闭合边 $(u,v)$ 的长度（1）。该环的长度 $L$ 由 $L = d_s(u) + d_s(v) + 1$ 给出。\n\n通过从每个顶点 $s \\in V$ 执行一次独立的 BFS，并记录所有这些遍历中发现的最小环长度，我们确保能找到全局最短环。其工作原理是，图中任何长度为 $k$ 的环都由顶点组成。当我们从这 $k$ 个顶点中的任何一个开始运行 BFS 时，该环（或一个更短的环）最终将被检测到。遍历所有可能的起始顶点的过程保证了最短环一定会被找到。\n\n完整的算法如下：\n$1$。设顶点数为 $n$，边集为 $E$。使用邻接表表示图。\n$2$。初始化一个变量用于存储最小环长度，$girth \\leftarrow \\infty$。\n$3$。对于从 $0$ 到 $n-1$ 的每个顶点 $s$：\n    a. 从 $s$ 开始进行一次 BFS。\n    b. 创建一个大小为 $n$ 的距离数组 $d$，初始化为一个表示无穷大的哨兵值（例如 $-1$），以及一个大小为 $n$ 的父节点数组 $p$，同样初始化为 $-1$。\n    c. 设置 $d[s] \\leftarrow 0$ 并用 $s$ 初始化一个队列 $Q$。\n    d. 当 $Q$ 不为空时：\n        i. 从队列中取出一个顶点 $u$。\n        ii. 对于 $u$ 的每个邻居 $v$：\n            - 如果 $d[v] = -1$（即 $v$ 未被访问）：\n                设置 $d[v] \\leftarrow d[u] + 1$。\n                设置 $p[v] \\leftarrow u$。\n                将 $v$ 入队。\n            - 否则，如果 $v \\neq p[u]$：\n                已找到一个环。计算其长度 $L = d[u] + d[v] + 1$。\n                更新 $girth \\leftarrow \\min(girth, L)$。\n$4$。外层循环结束后，如果 $girth$ 仍然是 $\\infty$，则图中没有环，所以围长为 $0$。否则，围长就是 $girth$ 的最终值。\n\n该算法的时间复杂度取决于从 $n$ 个顶点中的每一个运行一次 BFS。在具有 $n$ 个顶点和 $m$ 条边的图上进行单次 BFS 需要 $O(n+m)$ 的时间。因此，总时间复杂度为 $O(n(n+m))$。空间复杂度主要由邻接表决定，为 $O(n+m)$，以及每次 BFS 运行的数据结构（距离和父节点数组、队列），为 $O(n)$，因此总空间复杂度为 $O(n+m)$。对于问题描述中指定的图，这种方法是可靠且计算上可行的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves the girth computation problem for a predefined test suite of graphs.\n    \"\"\"\n\n    # Test cases defined in the problem statement.\n    # Each case is a tuple: (number_of_vertices, list_of_edges)\n    test_cases = [\n        # Test case 1 (multiple cycles; smallest is a triangle):\n        (7, [(0, 1), (1, 2), (2, 0), (2, 3), (3, 4), (4, 5), (5, 2), (5, 6)]),\n        # Test case 2 (acyclic tree):\n        (5, [(0, 1), (1, 2), (2, 3), (3, 4)]),\n        # Test case 3 (single cycle of length 4 with branches):\n        (6, [(0, 1), (1, 2), (2, 3), (3, 0), (0, 4), (2, 5)]),\n        # Test case 4 (disconnected: one path and one 5-cycle):\n        (8, [(0, 1), (1, 2), (3, 4), (4, 5), (5, 6), (6, 7), (7, 3)]),\n        # Test case 5 (hexagon with a tail):\n        (7, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0), (0, 6)]),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        girth = compute_girth(n, edges)\n        results.append(girth)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_girth(n, edges):\n    \"\"\"\n    Computes the girth of an undirected, simple, unweighted graph.\n\n    The girth is the length of the shortest cycle. If the graph is acyclic,\n    the girth is defined as 0.\n\n    The algorithm iterates through each vertex, treating it as a source for a\n    Breadth-First Search (BFS). During the BFS, if we encounter an already\n    visited vertex that is not the immediate parent of the current vertex,\n    we have found a cycle. The length of this cycle is the sum of the\n    distances of the two adjacent vertices from the source plus one. We keep\n    track of the minimum such length found across all BFS runs.\n\n    Args:\n        n (int): The number of vertices in the graph, labeled 0 to n-1.\n        edges (list of tuples): A list of pairs (u, v) representing\n                               undirected edges.\n\n    Returns:\n        int: The girth of the graph.\n    \"\"\"\n    if n == 0:\n        return 0\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    min_cycle_length = float('inf')\n\n    # Run a BFS from each vertex to find the shortest cycle\n    for start_node in range(n):\n        # distance array: dist[i] stores the shortest distance from start_node to i\n        # parent array: parent[i] stores the parent of i in the BFS tree\n        # Using -1 as a sentinel for unvisited nodes\n        dist = np.full(n, -1, dtype=int)\n        parent = np.full(n, -1, dtype=int)\n        \n        q = deque()\n\n        dist[start_node] = 0\n        q.append(start_node)\n\n        while q:\n            current_node = q.popleft()\n\n            for neighbor in adj[current_node]:\n                if dist[neighbor] == -1:\n                    # Neighbor has not been visited\n                    dist[neighbor] = dist[current_node] + 1\n                    parent[neighbor] = current_node\n                    q.append(neighbor)\n                elif neighbor != parent[current_node]:\n                    # Cycle detected. The neighbor has been visited and is not\n                    # the direct parent of the current node in the BFS tree.\n                    cycle_len = dist[current_node] + dist[neighbor] + 1\n                    min_cycle_length = min(min_cycle_length, cycle_len)\n    \n    # If min_cycle_length remains infinity, the graph is acyclic.\n    if min_cycle_length == float('inf'):\n        return 0\n    else:\n        return int(min_cycle_length)\n\n# Execute the solution\nsolve()\n\n```", "id": "3225402"}, {"introduction": "最后的练习将探讨一个实际应用：我们如何通过移除最少的边来消除图中所有的环？这个问题引入了最小反馈边集的概念，并展示了它与最大生成森林之间的联系。你将应用一种基于并查集（Union-Find）数据结构的精妙算法，来构建一个生成森林并识别出那些会形成环的多余边。[@problem_id:3225361]", "problem": "给定一个无向简单图 $G = (V, E)$，其顶点集 $V$ 有限，边集为 $E$。环是任意一个由 $k \\ge 3$ 个不同顶点组成的序列 $(v_0, v_1, \\dots, v_{k-1})$，使得对于所有 $i \\in \\{0,1,\\dots,k-2\\}$ 都有 $(v_i, v_{i+1}) \\in E$ 且 $(v_{k-1}, v_0) \\in E$。森林是一个无环的无向图。反馈边集是一个边子集 $F \\subseteq E$，从 $G$ 中移除 $F$ 中的边后会得到一个森林。最小反馈边集问题要求找到一个基数最小的集合 $F$，移除该集合中的边后图变为无环图。\n\n您的任务是编写一个完整的程序，根据以下平局决胜规则，为下面指定的测试套件中的每个图返回一个规范的最小反馈边集。用有序对 $(\\min(u, v), \\max(u, v))$ 表示每条无向边 $(u, v)$。将所有边按这些有序对的升序字典序排序，得到一个边序列。从包含 $V$ 中所有顶点但没有边的空图开始，从左到右扫描这个排好序的边列表。如果一条边连接了当前部分图的两个不同连通分量，则保留该边；当且仅当它将连接两个已在同一连通分量中的顶点时，才将其丢弃到反馈边集 $F$ 中。一个图的输出是所有被丢弃的边的列表，顺序为扫描过程中遇到的顺序。此规则唯一地确定了输出，而没有规定任何特定的内部数据结构。\n\n所有测试图中的顶点都由整数 $\\{0,1,\\dots,n-1\\}$ 标记，其中 $n = |V|$。边被指定为顶点对 $(u, v)$，其中 $0 \\le u, v  n$，$u \\neq v$。这些图是简单图：没有自环，也没有平行边。\n\n测试套件：\n- 图 $\\mathrm{A}$：$n = 6$，$E = \\{(0,1),(1,2),(2,0),(2,3),(3,4),(4,2),(4,5)\\}$。该图是连通的，并包含多个共享顶点的环。\n- 图 $\\mathrm{B}$：$n = 7$，$E = \\{(0,1),(1,2),(2,0),(3,4),(4,5),(5,6),(3,5)\\}$。该图有两个连通分量，一个是环，另一个是由路径增强形成的环。\n- 图 $\\mathrm{C}$：$n = 5$，$E = \\{(0,1),(1,2),(3,4)\\}$。该图已经是一个森林（无环）。\n- 图 $\\mathrm{D}$：$n = 1$，$E = \\varnothing$。该图只有一个顶点，没有边。\n- 图 $\\mathrm{E}$：$n = 4$，$E = \\{(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)\\}$。该图是四个顶点上的完全图。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个图的结果本身必须是一个边的列表，其中每条边都写作一个双元素列表 $[u,v]$ 且 $u  v$。输出中不得有任何空格。例如，一个包含两条边的结果写作 $[[u_1,v_1],[u_2,v_2]]$。对于上述五个图，最终输出应为单行形式 $[R_A,R_B,R_C,R_D,R_E]$，其中 $R_X$ 是如上所述的图 $\\mathrm{X}$ 的列表。\n\n答案仅涉及离散结构，不包含任何物理单位或角度。所有计算输出均为整数列表，这些是基本类型。", "solution": "该问题要求计算给定无向图 $G = (V, E)$ 的一个规范最小反馈边集。反馈边集是边的一个子集 $F \\subseteq E$，从 $G$ 中移除 $F$ 会得到一个无环图（森林）。最小反馈边集是具有最小可能基数的此类集合。该问题指定了一个确定性算法来找到这样一个集合，该算法也用于解决选择哪些特定边时的任何模糊性。\n\n所规定算法的核心原理与用于寻找最大生成森林的 Kruskal 算法相同。一个图的生成森林是一个子图，它本身是森林，不被任何更大的无环子图所包含，并且跨越了原图的所有顶点。最大生成森林是包含最大可能边数的生成森林。一个图中不属于给定最大生成森林的边集构成了一个最小反馈边集。对于一个有 $n = |V|$ 个顶点和 $c$ 个连通分量的图，其任何生成森林的边数都固定为 $n - c$。因此，最小反馈边集的大小为 $|E| - (n - c)$。\n\n指定的算法通过迭代添加边来构建一个最大生成森林，并收集所有不属于该森林的边。这些被收集的边正是那些添加后会产生环的边。\n\n该算法按以下步骤进行：\n$1$. **初始化**：从一个包含所有 $n$ 个顶点但没有边的图开始。这是一个每个顶点都构成其自身连通分量的森林。初始化一个并查集 (Disjoint Set Union, DSU) 或称 (Union-Find) 数据结构来管理这些连通分量。最初，有 $n$ 个不相交的集合，每个顶点 $v \\in \\{0, 1, \\dots, n-1\\}$ 一个。创建一个空列表 $F$ 来存储反馈集中的边。\n\n$2$. **边的规范化与排序**：边集 $E$ 中的每条无向边 $\\{u, v\\}$ 都由一个唯一的、规范的有序对 $(\\min(u, v), \\max(u, v))$ 表示。然后，将这些规范边对的整个列表按升序字典序排序。此步骤确保了过程的确定性。\n\n$3$. **迭代构建**：算法遍历排序后的边列表。对于每条边 $(u, v)$：\n    - 它检查顶点 $u$ 和 $v$ 是否已属于同一个连通分量。这一检查通过使用并查集数据结构的 `find` 操作来高效执行，该操作为每个分量返回一个唯一的代表元。\n    - 如果 `find(u)` 不等于 `find(v)`，则顶点位于不同的分量中。边 $(u, v)$ 连接这两个分量而不会产生环。因此，它是最大生成森林的一条边。通过使用并查集的 `union(u, v)` 操作合并这两个分量，从而将该边添加到森林中。\n    - 如果 `find(u)` 等于 `find(v)`，则顶点已在同一分量内连接。添加边 $(u, v)$ 将会引入一个环。因此，这条边必须属于反馈边集。将该边的规范表示 $(\\min(u, v), \\max(u, v))$ 追加到列表 $F$ 中。\n\n$4$. **终止**：处理完 $E$ 中的所有边后，列表 $F$ 就包含了所求的最小反馈边集。$F$ 中边的顺序由排序后的迭代顺序决定。最终构建的森林是原图 $G$ 的一个最大生成森林。\n\n该方法的效率主要由边排序步骤决定，其耗时为 $O(|E| \\log |E|)$，以及并查集操作。采用同时使用路径压缩和按大小/秩合并优化的并查集实现，所有并查集操作的总时间在摊还分析下接近常数，具体为 $O(|E| \\cdot \\alpha(|V|))$，其中 $\\alpha$ 是增长极其缓慢的反阿克曼函数。因此，总时间复杂度由排序主导，为 $O(|E| \\log |E|)$。\n\n例如，考虑图 A，$n=6$，$E = \\{(0,1),(1,2),(2,0),(2,3),(3,4),(4,2),(4,5)\\}$。\n规范化的边为 $(0,1), (1,2), (0,2), (2,3), (3,4), (2,4), (4,5)$。\n排序后的边列表为 $S = [(0,1), (0,2), (1,2), (2,3), (2,4), (3,4), (4,5)]$。\n并查集初始化为集合 $\\{0\\}, \\{1\\}, \\{2\\}, \\{3\\}, \\{4\\}, \\{5\\}$。反馈集 $F$ 为空。\n- 处理 $(0,1)$：`find(0) \\neq find(1)`。合并 0 和 1 的分量。\n- 处理 $(0,2)$：`find(0) \\neq find(2)`。合并 0 和 2 的分量。现在 $\\{0,1,2\\}$ 的分量已合并。\n- 处理 $(1,2)$：`find(1) = find(2)`。顶点 1 和 2 已经连通。将 $[1,2]$ 添加到 $F$。\n- 处理 $(2,3)$：`find(2) \\neq find(3)`。合并分量。现在 $\\{0,1,2,3\\}$ 的分量已合并。\n- 处理 $(2,4)$：`find(2) \\neq find(4)`。合并分量。现在 $\\{0,1,2,3,4\\}$ 的分量已合并。\n- 处理 $(3,4)$：`find(3) = find(4)`。顶点 3 和 4 已经连通。将 $[3,4]$ 添加到 $F$。\n- 处理 $(4,5)$：`find(4) \\neq find(5)`。合并分量。现在所有顶点都在一个分量中。\n图 A 的最终反馈边集为 $F = [[1,2],[3,4]]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the minimum feedback edge set problem for a suite of test graphs.\n    \"\"\"\n\n    class DSU:\n        \"\"\"\n        A Disjoint Set Union (DSU) data structure, also known as Union-Find,\n        optimized with path compression and union by size.\n        \"\"\"\n        def __init__(self, n):\n            \"\"\"\n            Initializes the DSU for n elements, where each element is in its\n            own set.\n            Args:\n                n (int): The number of elements.\n            \"\"\"\n            self.parent = list(range(n))\n            self.size = [1] * n\n\n        def find(self, i):\n            \"\"\"\n            Finds the representative of the set containing element i, with path\n            compression.\n            Args:\n                i (int): The element to find.\n            Returns:\n                int: The representative of the set.\n            \"\"\"\n            if self.parent[i] == i:\n                return i\n            self.parent[i] = self.find(self.parent[i])\n            return self.parent[i]\n\n        def union(self, i, j):\n            \"\"\"\n            Merges the sets containing elements i and j, using union by size.\n            Args:\n                i (int): An element in the first set.\n                j (int): An element in the second set.\n            Returns:\n                bool: True if the sets were merged, False if they were already\n                      in the same set.\n            \"\"\"\n            root_i = self.find(i)\n            root_j = self.find(j)\n            if root_i != root_j:\n                # Union by size: attach smaller tree under root of larger tree\n                if self.size[root_i]  self.size[root_j]:\n                    root_i, root_j = root_j, root_i\n                self.parent[root_j] = root_i\n                self.size[root_i] += self.size[root_j]\n                return True\n            return False\n\n    def find_minimum_feedback_edge_set(n, edges):\n        \"\"\"\n        Finds a canonical minimum feedback edge set for a graph using the\n        prescribed algorithm based on Kruskal's MST method.\n\n        Args:\n            n (int): The number of vertices in the graph.\n            edges (list of tuples): The list of edges in the graph.\n\n        Returns:\n            list of lists: The list of edges in the feedback set, ordered\n                           as they were identified.\n        \"\"\"\n        if n == 0 or not edges:\n            return []\n\n        # 1. Canonicalize edges to (min(u,v), max(u,v)) and sort them.\n        canonical_edges = sorted([(min(u, v), max(u, v)) for u, v in edges])\n        \n        dsu = DSU(n)\n        feedback_edges = []\n        \n        # 2. Iterate through sorted edges, building a maximum spanning forest.\n        for u, v in canonical_edges:\n            # 3. If an edge connects two vertices already in the same component,\n            # it forms a cycle and belongs to the feedback set.\n            if not dsu.union(u, v):\n                feedback_edges.append([u, v])\n                \n        return feedback_edges\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Graph A\n        (6, [(0,1),(1,2),(2,0),(2,3),(3,4),(4,2),(4,5)]),\n        # Graph B\n        (7, [(0,1),(1,2),(2,0),(3,4),(4,5),(5,6),(3,5)]),\n        # Graph C\n        (5, [(0,1),(1,2),(3,4)]),\n        # Graph D\n        (1, []),\n        # Graph E (K4)\n        (4, [(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)]),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        result = find_minimum_feedback_edge_set(n, edges)\n        results.append(result)\n\n    # Format the final output string according to the exact problem specification.\n    # The str() conversion might add spaces, so we remove them.\n    results_as_strings = [str(r).replace(\" \", \"\") for r in results]\n    final_output = f\"[{','.join(results_as_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3225361"}]}