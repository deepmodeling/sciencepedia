{"hands_on_practices": [{"introduction": "这个练习将抽象的图概念转化为一个具象的二维网格。这是一个经典问题，能帮助你直观地理解广度优先搜索 ($BFS$) 或深度优先搜索 ($DFS$) 等图遍历算法如何系统性地探索并识别出不同的连通区域。掌握这个问题是所有连通分量相关任务的基础。[@problem_id:3223893]", "problem": "考虑一个有限二维网格，该网格被建模为笛卡尔积 $\\{0,1,\\dots,m-1\\} \\times \\{0,1,\\dots,n-1\\}$，其中 $m$ 和 $n$ 为非负整数。一个子集 $B \\subseteq \\{0,1,\\dots,m-1\\} \\times \\{0,1,\\dots,n-1\\}$ 指定了阻塞单元格。定义一个无向图 $G=(V,E)$，其顶点集 $V$ 为所有非阻塞单元格，即 $V = \\left(\\{0,1,\\dots,m-1\\} \\times \\{0,1,\\dots,n-1\\}\\right) \\setminus B$，其边集 $E$ 精确地包含所有无序对 $\\{(i,j),(i',j')\\}$，使得两个端点都在 $V$ 中，且单元格是正交相邻的，即 $|i-i'|+|j-j'|=1$。如果存在一个顶点序列（一条步道）$u=v_0,v_1,\\dots,v_k=v$，其中每对连续顶点都在 $E$ 中构成一条边，则称两个顶点 $u,v \\in V$ 是连通的。连通分量是 $V$ 的一个极大子集，其中每对顶点都是连通的。\n\n请仅根据上述定义，推导出一个正确且高效的算法，用于计算非阻塞单元格的连通分量数量，该算法是关于 $m$、$n$ 和 $B$ 的函数。您的算法必须在上述正交邻接规则下运行，并且必须能够使用标准数据结构以确定性方式实现。\n\n您的程序应自成一体（无输入），并评估以下测试套件。每个测试用例由一个三元组 $(m,n,B)$ 给出，其中集合 $B$被明确指定。所有情况下的邻接关系均为正交（4邻域）。\n\n测试用例 1：$(m,n)=(5,7)$ 且 $B_1=\\{(0,1),(0,5),(1,1),(1,5),(2,3),(2,5),(3,0),(3,1),(3,2),(3,3),(3,5),(4,5)\\}$。\n\n测试用例 2：$(m,n)=(0,5)$ 且 $B_2=\\emptyset$。\n\n测试用例 3：$(m,n)=(3,3)$ 且 $B_3=\\{(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)\\}$。\n\n测试用例 4：$(m,n)=(1,6)$ 且 $B_4=\\{(0,1),(0,3),(0,4)\\}$。\n\n测试用例 5：$(m,n)=(3,4)$ 且 $B_5=\\emptyset$。\n\n您的程序应生成单行输出，其中包含五个测试用例的整数结果，按顺序排列，形式为方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$）。本问题不涉及任何物理单位、角度或百分比；所有输出均为无单位整数。", "solution": "该问题要求计算无向图 $G=(V,E)$ 中连通分量的数量。图的结构源于一个二维网格和一组阻塞单元格。这是图论和计算几何中的一个经典问题，可以使用标准的图遍历算法来解决。\n\n### 问题形式化\n\n网格被定义为点集 $\\{0,1,\\dots,m-1\\} \\times \\{0,1,\\dots,n-1\\}$，其中 $m$ 和 $n$ 是给定的非负整数。这些点的一个子集 $B$ 代表阻塞单元格。\n\n图 $G$ 的顶点集 $V$ 由所有非阻塞单元格组成：\n$$V = \\left(\\{0,1,\\dots,m-1\\} \\times \\{0,1,\\dots,n-1\\}\\right) \\setminus B$$\n如果任意两个顶点 $(i,j) \\in V$ 和 $(i',j') \\in V$ 是正交相邻的，则边集 $E$ 将它们连接起来。正交邻接的条件由单元格坐标之间的曼哈顿距离给出：\n$$|i-i'|+|j-j'|=1$$\n这种邻接规则也被称为4邻域连通性。\n\n连通分量是一个极大子图，其中任意两个顶点都通过一条路径相互连接。任务是确定此类连通分量的总数。\n\n### 算法方法\n\n可以通过系统地探索网格来确定连通分量的数量。核心思想是遍历网格的每个单元格。如果发现一个未访问过的非阻塞单元格，它必定属于一个新的、尚未发现的连通分量。然后，我们从该单元格开始进行图遍历，例如广度优先搜索 (BFS) 或深度优先搜索 (DFS)。此遍历将访问并标记属于同一分量的每个单元格。每次发现新分量时增加一个计数器，我们就可以找到总数。\n\n一个维度为 $m \\times n$ 的二维数组将用作网格的表示。我们可以使用此数组中的整数值来编码每个单元格的状态：\n-  值 $-1$ 可以表示一个阻塞单元格。\n-  值 $0$ 可以表示一个非阻塞且未访问的单元格。\n-  正整数 $k > 0$ 可以表示该单元格已被访问，并属于找到的第 $k$ 个分量。\n\n算法流程如下：\n\n1.  初始化分量计数器 `count` 为 $0$。\n2.  创建一个 $m \\times n$ 的网格数据结构 `grid`。将所有单元格初始化为表示“非阻塞、未访问”的状态（例如，值为 $0$）。\n3.  对于输入集 $B$ 中的每个单元格坐标 $(i,j)$，将 `grid` 中位置 $(i,j)$ 处的值更新为“阻塞”状态（例如，值为 $-1$）。\n4.  处理网格为空的边界情况：如果 $m=0$ 或 $n=0$，则顶点数为 $0$，因此连通分量数也为 $0$。\n5.  遍历网格的每个单元格 $(r,c)$，其中 $r$ 从 $0$ 到 $m-1$，$c$ 从 $0$ 到 $n-1$。\n6.  在每个单元格 $(r,c)$ 处：\n    - 如果 `grid[r,c]` 表示该单元格已被访问（值 $>0$）或被阻塞（值 $-1$），则不执行任何操作，继续处理下一个单元格。\n    - 如果 `grid[r,c]` 表示这是一个未访问的非阻塞单元格（值为 $0$），则我们找到了一个新的连通分量。\n        - 增加分量计数器：`count` $\\leftarrow$ `count` $+ 1$。\n        - 从 $(r,c)$ 开始进行广度优先搜索 (BFS)，以找到这个新分量中的所有单元格。\n            - 创建一个队列，并将起始单元格 $(r,c)$ 加入队列。\n            - 通过设置 `grid[r,c]` $\\leftarrow$ `count` 将起始单元格标记为已访问。\n            - 当队列不为空时：\n                - 从队列中取出一个单元格，记为 $(r_{\\text{curr}}, c_{\\text{curr}})$。\n                - 对于其四个正交邻居中的每一个 $(r_{\\text{neigh}}, c_{\\text{neigh}})$：\n                    - 检查邻居是否在网格边界内（$0 \\le r_{\\text{neigh}}  m$ 且 $0 \\le c_{\\text{neigh}}  n$）。\n                    - 检查邻居是否是未访问且非阻塞的 (`grid[r_neigh, c_neigh] == 0`)。\n                    - 如果两个条件都满足，则将该邻居标记为已访问 (`grid[r_neigh, c_neigh]` $\\leftarrow$ `count`) 并将其入队。\n7. 嵌套循环完成后，`count` 的最终值就是连通分量的总数。\n\n此过程保证是正确的。它会检查每个单元格。每次启动遍历时，都是在一个尚未分配给任何先前分量的单元格上进行的。遍历算法 (BFS/DFS) 确保所有可达的单元格——并且仅有这些单元格——都被详尽地识别并标记为当前分量的一部分。因此，每个分量都只被计数一次。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef count_components(m: int, n: int, B: set) - int:\n    \"\"\"\n    Computes the number of connected components in a 2D grid with blocked cells.\n\n    Args:\n        m: The number of rows in the grid.\n        n: The number of columns in the grid.\n        B: A set of tuples, where each tuple (r, c) is a blocked cell.\n\n    Returns:\n        The integer number of connected components of unblocked cells.\n    \"\"\"\n    if m == 0 or n == 0:\n        return 0\n\n    # grid[r, c] = 0: unblocked, unvisited\n    # grid[r, c] = -1: blocked\n    # grid[r, c]  0: part of component with that ID\n    grid = np.zeros((m, n), dtype=np.int32)\n    for r, c in B:\n        if 0 = r  m and 0 = c  n:\n            grid[r, c] = -1\n\n    num_components = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r, c] == 0:\n                # Found a new component\n                num_components += 1\n                \n                # Start a Breadth-First Search (BFS) to find all cells in this component\n                q = collections.deque([(r, c)])\n                grid[r, c] = num_components # Mark as visited\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    \n                    # Explore 4-directional neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        next_r, next_c = curr_r + dr, curr_c + dc\n                        \n                        # Check boundaries and if the neighbor is unvisited\n                        if 0 = next_r  m and 0 = next_c  n and grid[next_r, next_c] == 0:\n                            grid[next_r, next_c] = num_components\n                            q.append((next_r, next_c))\n                            \n    return num_components\n\ndef solve():\n    \"\"\"\n    Solves the pre-defined test cases for the connected components problem.\n    \"\"\"\n    test_cases = [\n        (5, 7, {(0, 1), (0, 5), (1, 1), (1, 5), (2, 3), (2, 5), (3, 0), (3, 1), (3, 2), (3, 3), (3, 5), (4, 5)}),\n        (0, 5, set()),\n        (3, 3, {(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)}),\n        (1, 6, {(0, 1), (0, 3), (0, 4)}),\n        (3, 4, set())\n    ]\n\n    results = []\n    for m, n, B in test_cases:\n        result = count_components(m, n, B)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3223893"}, {"introduction": "在识别出连通分量之后，我们可以进一步分析它们的内部结构。本练习将探讨一个基本的图属性：二分性。通过尝试对每个连通分量进行“二着色”，你不仅能判断它是否为二分图，还能发现该性质与图中不存在奇数长度环路之间的深刻联系。[@problem_id:3223897]", "problem": "给定无向简单图及其连通结构的基本定义。一个无向简单图 $G=(V,E)$ 有一个有限的顶点集 $V$，其中 $\\lvert V\\rvert = n$，顶点由从 $0$ 到 $n-1$ 的整数标记。其边集为 $E \\subseteq \\{\\{u,v\\} \\mid u,v \\in V, u \\neq v\\}$，其中每条边是一个无序对，没有重复的边，也没有自环。一个连通分量是一个极大子集 $C \\subseteq V$，使得对于 $C$ 中的任意两个顶点 $u,v$，在图 $G$ 中都存在一条连接 $u$ 和 $v$ 的路径。一个子图是二分图，如果其顶点集可以被划分为两个不相交的子集 $(X,Y)$，使得每条边的两个端点分别位于 $X$ 和 $Y$ 中。奇数环是长度为 $2k+1$（对于某个整数 $k \\ge 0$）的环。\n\n任务：对于下面测试套件中的每个图，为其每个连通分量确定两个布尔值，顺序为 $[b,o]$。其中，当且仅当该连通分量是二分图（即其顶点可以被划分为两个集合，所有边都跨越该划分）时，$b$ 为 $\\text{True}$；当且仅当该连通分量包含一个奇数长度的环时，$o$ 为 $\\text{True}$。如果一个图没有连通分量（例如，当 $n=0$ 时），该图的结果为空列表 $[]$。输出中的分量必须按照每个分量内最小顶点标号的升序排列。这通过按 $0,1,\\dots,n-1$ 的递增顺序扫描顶点，并在遇到未访问过的顶点时开始一个新的分量来实现。\n\n你的程序必须是一个完整的、可运行的程序，它能生成单行输出，其中包含所有测试用例的结果。结果是一个用方括号括起来的逗号分隔列表，其中每个元素是对应图的各分量结果列表。输出格式必须是严格的一行，形式为 $[r_1,r_2,\\dots,r_T]$，其中 $T$ 是测试用例的数量，每个 $r_i$ 本身是一个布尔值列表的列表，不含多余的空格（例如，$[[\\text{True},\\text{False}],[\\text{False},\\text{True}]]$）。本问题不涉及物理单位。\n\n测试套件：\n- 测试用例 1：$n=0$, $E=\\emptyset$。\n- 测试用例 2：$n=1$, $E=\\emptyset$。\n- 测试用例 3：$n=2$, $E=\\{(0,1)\\}$。\n- 测试用例 4：$n=3$, $E=\\{(0,1),(1,2),(2,0)\\}$。\n- 测试用例 5：$n=4$, $E=\\{(0,1),(1,2),(2,3),(3,0)\\}$。\n- 测试用例 6：$n=7$, $E=\\{(0,1),(1,2),(3,4),(4,5),(5,3)\\}$，顶点 $6$ 是孤立的。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$），其中每个 $r_i$ 是测试用例 $i$ 的各分量按指定顺序排列的 $[\\text{二分图},\\text{奇数环}]$ 对的列表。", "solution": "我们从图论的核心定义开始。一个无向简单图 $G=(V,E)$ 包含顶点集 $V$ 和边集 $E$，其中边连接无序的不同顶点对。一个连通分量是顶点的一个极大子集，其中任意两个顶点都通过某条路径相连。一个子图是二分图，如果其顶点集可以被划分为 $(X,Y)$（其中 $X \\cap Y = \\emptyset$），使得每条边的端点分别位于不同的部分。环是一条闭合路径，除了起点和终点外没有重复的顶点；奇数环的长度为 $2k+1$（对于某个整数 $k \\ge 0$）。\n\n一个关键且经过充分检验的特性是：一个无向图是二分图，当且仅当它不包含奇数环。我们将推导其原因，并说明它如何指导算法设计。\n\n为什么二分性排除奇数环：假设一个图是二分图，其划分为 $(X,Y)$。考虑任意一个环；由于每条边都跨越划分，边会在这两个集合之间交替。从 $X$ 中的一个顶点开始，下一个顶点在 $Y$ 中，再下一个在 $X$ 中，依此类推。要回到起点需要偶数步，因为经过奇数步后我们会位于 $Y$ 中，而不是 $X$ 中。因此，任何环都必须有偶数长度。所以，二分图中不可能存在奇数环。\n\n反之，为什么奇数环意味着非二分性：假设图有一个奇数环 $v_0,v_1,\\dots,v_{2k},v_0$。任何试图将顶点划分为两个集合（其中相邻顶点在不同集合中）的尝试都会失败。因为当我们沿着环交替分配集合时，经过奇数条边回到起点后，会要求 $v_0$ 同时属于两个集合，这是不可能的。因此，奇数环的存在排除了二分性。\n\n从第一性原理进行算法设计：\n- 为了分析连通分量，我们需要逐个处理图的每个分量。一种基于路径和邻接关系的标准方法是使用广度优先搜索（BFS）或深度优先搜索（DFS）来探索图。广度优先搜索（BFS）通过队列按扩展层访问顶点，而深度优先搜索（DFS）通过递归或栈尽可能深地进行探索。\n- 为了测试二分性，我们可以将划分形式化为一个二染色函数 $c: V \\to \\{0,1\\}$，使得对于每条边 $(u,v) \\in E$，都有 $c(u) \\neq c(v)$。我们尝试在探索一个连通分量时分配颜色：\n  1. 初始化所有顶点的颜色为 $-1$，表示未染色。\n  2. 对于每个按标号升序排列的未访问顶点 $s$，开始一个新的分量并分配 $c(s)=0$。\n  3. 通过 BFS 遍历该分量。对于遇到的每条边 $(u,v)$：\n     - 如果 $c(v)=-1$，则分配 $c(v)=1-c(u)$ 并继续。\n     - 如果 $c(v)=c(u)$，我们检测到一个冲突。这个冲突意味着存在一个奇数环。要理解原因，可以考虑从起始顶点到 $u$ 和 $v$ 的 BFS 树路径。由于 $c(u)=c(v)$，这些路径的长度具有相同的奇偶性（要么都是偶数，要么都是奇数）。添加边 $(u,v)$ 会闭合一个环，其长度是两条路径长度之和加 $1$，结果是一个奇数。因此，该分量包含一个奇数环，不可能是二分图。\n  4. 如果遍历完成而没有冲突，我们就构建了一个有效的二染色，因此该分量是二分图，且没有奇数环。\n- 该算法对每个图的运行时间为 $O(\\lvert V\\rvert + \\lvert E\\rvert)$，因为每个顶点和每条边都只被处理常数次。\n\n通过按 $0,1,\\dots,n-1$ 的递增顺序扫描顶点，并在遇到尚未访问的顶点时开始新的探索，可以确保分量的确定性顺序；对每个分量的第一次访问就是其最小标号的顶点。\n\n将算法应用于测试套件：\n- 测试用例 1：$n=0$, $E=\\emptyset$。没有顶点，因此没有分量。输出 $[]$。\n- 测试用例 2：$n=1$, $E=\\emptyset$。一个孤立顶点形成一个单独的分量。它是二分图（分配颜色 $0$），没有环，因此为 $[\\text{True},\\text{False}]$。\n- 测试用例 3：$n=2$, $E=\\{(0,1)\\}$。一条边连接两个顶点；分配颜色 $0$ 和 $1$。没有冲突，是二分图，没有奇数环：$[\\text{True},\\text{False}]$。\n- 测试用例 4：$n=3$, $E=\\{(0,1),(1,2),(2,0)\\}$。这是一个 $3$-环。二染色尝试会失败，因为相邻顶点迫使第三条边连接颜色相同的顶点，从而检测到奇数环：$[\\text{False},\\text{True}]$。\n- 测试用例 5：$n=4$, $E=\\{(0,1),(1,2),(2,3),(3,0)\\}$。这是一个 $4$-环，是二分图（颜色沿环交替）。没有奇数环：$[\\text{True},\\text{False}]$。\n- 测试用例 6：$n=7$, $E=\\{(0,1),(1,2),(3,4),(4,5),(5,3)\\}$，顶点 $6$ 是孤立的。有三个分量：\n  - 包含顶点 $\\{0,1,2\\}$ 的分量是一条路径，是二分图：$[\\text{True},\\text{False}]$。\n  - 包含顶点 $\\{3,4,5\\}$ 的分量是一个 $3$-环，不是二分图且包含一个奇数环：$[\\text{False},\\text{True}]$。\n  - 分量 $\\{6\\}$ 是一个孤立顶点，是二分图：$[\\text{True},\\text{False}]$。\n  按最小标号递增排序，分量结果为 $[[\\text{True},\\text{False}],[\\text{False},\\text{True}],[\\text{True},\\text{False}]]$。\n\n程序将为每个连通分量实现基于 BFS 的二染色算法，按指定顺序收集每个分量的布尔值，并打印一行，将所有测试用例的结果聚合为 $[r_1,r_2,r_3,r_4,r_5,r_6]$，不含多余的空格。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef analyze_components(n: int, edges: List[Tuple[int, int]]) - List[List[bool]]:\n    \"\"\"\n    For an undirected simple graph with n vertices labeled 0..n-1 and a list of edges,\n    return a list of [is_bipartite, has_odd_cycle] for each connected component.\n    Components are ordered by increasing minimum vertex label, achieved by scanning\n    vertices from 0 to n-1 and starting a new component when encountering an unvisited vertex.\n    \"\"\"\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        if u != v:\n            adj[u].append(v)\n            adj[v].append(u)\n\n    color = [-1] * n  # -1 uncolored, 0 and 1 are the two colors\n    visited = [False] * n\n    results = []\n\n    for start in range(n):\n        if visited[start]:\n            continue\n        # Start a new component at 'start'\n        comp_has_odd_cycle = False\n        queue = deque()\n        queue.append(start)\n        color[start] = 0\n        visited[start] = True\n        \n        bfs_q = deque([start])\n        # Need to use a separate visited set for the BFS traversal to correctly mark all nodes in component\n        component_nodes_visited = {start}\n\n        while bfs_q:\n            u = bfs_q.popleft()\n            cu = color[u]\n            visited[u] = True # Mark as globally visited\n            \n            for v in adj[u]:\n                if v not in component_nodes_visited:\n                    component_nodes_visited.add(v)\n                    color[v] = 1 - cu\n                    bfs_q.append(v)\n                else:\n                    # If neighbor has same color, we detected an odd cycle\n                    if color[v] == cu:\n                        comp_has_odd_cycle = True\n        \n        # The component is bipartite iff no odd cycle was detected.\n        comp_is_bipartite = not comp_has_odd_cycle\n        results.append([comp_is_bipartite, comp_has_odd_cycle])\n\n    return results\n\ndef format_case_result(case_result: List[List[bool]]) - str:\n    \"\"\"\n    Format a single test case's result (list of [bipartite, odd_cycle] pairs) without spaces.\n    \"\"\"\n    parts = []\n    for pair in case_result:\n        b_str = \"True\" if pair[0] else \"False\"\n        o_str = \"True\" if pair[1] else \"False\"\n        parts.append(f\"[{b_str},{o_str}]\")\n    return f\"[{','.join(parts)}]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: Empty graph\n        (0, []),\n        # Test case 2: Single isolated vertex\n        (1, []),\n        # Test case 3: Single edge, bipartite\n        (2, [(0, 1)]),\n        # Test case 4: Triangle (3-cycle), odd cycle present\n        (3, [(0, 1), (1, 2), (2, 0)]),\n        # Test case 5: Square (4-cycle), bipartite\n        (4, [(0, 1), (1, 2), (2, 3), (3, 0)]),\n        # Test case 6: Multiple components: path {0-1-2}, triangle {3-4-5}, isolated {6}\n        (7, [(0, 1), (1, 2), (3, 4), (4, 5), (5, 3)]),\n    ]\n\n    # Compute results for all test cases\n    all_results = []\n    for n, edges in test_cases:\n        case_result = analyze_components(n, edges)\n        all_results.append(format_case_result(case_result))\n\n    # Final print statement in the exact required format (single line, no spaces inside list representations).\n    print(f\"[{','.join(all_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3223897"}, {"introduction": "最后的这个练习展示了连通分量分析如何作为解决复杂优化问题的关键第一步。你的任务是以最小的成本连接一个破碎的图，这需要你首先识别出初始的连通分量，然后基于它们的特性设计一个贪心策略。这个问题展示了理解图连通性的实际应用价值。[@problem_id:3223947]", "problem": "给定一个有限、无向、加权图，其顶点集为 $V=\\{0,1,\\dots,n-1\\}$，边集为 $E\\subseteq \\{\\{u,v\\}\\mid u\\neq v,\\,u,v\\in V\\}$，同时给定一个非负的边权重函数 $w_E:\\,E\\to \\mathbb{R}_{\\ge 0}$。边权重 $w_E$ 仅用于定义一个真实的加权图实例，并不计入您需要计算的成本中。该图可能是不连通的，形成若干个连通分量。此外，还给定一个非负的节点价格函数 $p:\\,V\\to \\mathbb{R}_{\\ge 0}$。您可以在不属于 $E$ 的任意两个不同顶点 $u$ 和 $v$ 之间添加一条新的无向边 $\\{u,v\\}$，添加这样一条边的成本为 $p(u)+p(v)$。$E$ 中已有的边是现成的，无需额外成本。\n\n任务。仅从无向图中连通分量的基本定义以及任意两个不同分量之间必须通过至少一条新边连接才能使整个图连通的要求出发，推导出一个算法，用以计算添加边使整个图成为单个连通分量的最小总成本。如果图已经是连通的，则成本为 $0$。所有量都必须作为精确的实数处理；无需报告物理单位。您必须从基本原理出发进行推导：精确定义连通分量，描述一条新边如何合并两个分量，并确定如何组合这些合并以最小的总成本实现全局连通性。避免使用任何未经证明的快捷公式。\n\n每个测试用例的精确输入模型。一个测试用例是一个三元组 $(n,E,p)$，其中：\n1) $n$ 是一个整数，满足 $n\\ge 1$，表示标记为 $0$ 到 $n-1$ 的顶点数量；\n2) $E$ 是一个三元组 $(u,v,w)$ 的列表，其中 $u$ 和 $v$ 是满足 $0\\le u,v  n$，$u\\ne v$ 的整数，且 $w\\in \\mathbb{R}_{\\ge 0}$；每个三元组表示 $u$ 和 $v$ 之间的一条无向边，其现有权重为 $w$（这个权重不直接影响您需要计算的成本）；\n3) $p$ 是一个长度为 $n$ 的列表，其第 $i$ 个条目 $p[i]$ 等于 $p(i)\\in \\mathbb{R}_{\\ge 0}$。\n\n您的程序必须为每个测试用例计算一个数字，该数字等于在添加新边 $\\{u,v\\}$ 的成本为 $p(u)+p(v)$ 的规则下，使整个图变为连通所需的最小额外成本。如果图已经是连通的，则成本必须为 $0$。\n\n测试套件。请严格按照以下顺序使用这五个测试用例：\n1) $n=6$, $E=\\{(0,1,4),(1,2,3),(3,4,2)\\}$, $p=[4,2,7,1,3,5]$。\n2) $n=4$, $E=\\{(0,1,5),(1,2,2),(2,3,1)\\}$, $p=[10,10,10,10]$。\n3) $n=2$, $E=\\{\\}$, $p=[7,3]$。\n4) $n=7$, $E=\\{(0,1,5),(3,4,1),(5,6,8)\\}$, $p=[8,6,5,9,2,4,7]$。\n5) $n=1$, $E=\\{\\}$, $p=[5]$。\n\n输出规范。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。例如，如果五个测试用例的结果是 $a_1,a_2,a_3,a_4,a_5$，那么您必须在一行上准确打印字符串 `\"[a_1,a_2,a_3,a_4,a_5]\"`，不含空格。\n\n注意。\n1) 您必须将边视为无向的。如果 $(u,v,w)\\in E$，则 $(v,u,w)$ 也隐式地在 $E$ 中。\n2) 您的算法不应假设除指定结构外的任何特殊结构。它必须对任何非负节点价格和任何无向图结构都是正确的。\n3) 在这些特定实例中，每个测试用例的答案都是一个整数，但通用算法必须能处理其他输入中可能出现的实数值 $p(i)$。", "solution": "### 解法\n目标是通过添加新边，找到使给定图 $G=(V, E)$ 变为连通的最小成本。添加一条边 $\\{u, v\\}$ 的成本定义为 $p(u) + p(v)$。我们被要求从基本原理出发推导解决方案。\n\n**1. 连通分量与目标**\n\n如果一个无向图的任意两个顶点之间都存在路径，则该图是*连通的*。“连通”关系是顶点集 $V$ 上的一个等价关系。该关系的等价类被称为图的*连通分量*。设初始图有 $k$ 个连通分量，表示为 $C_1, C_2, \\dots, C_k$。为了使整个图连通，我们必须添加边，使得所有顶点都属于同一个分量。\n\n如果 $k \\le 1$，图已经是连通的或平凡的（单个顶点或空图），根据定义，成本为 $0$。\n\n如果 $k > 1$，我们必须添加边来将这 $k$ 个分量合并成一个。添加一条边 $\\{u, v\\}$，其中 $u \\in C_i$ 且 $v \\in C_j$，$i \\neq j$，会将分量 $C_i$ 和 $C_j$ 合并成一个更大的分量。在同一个分量内部添加边不会减少分量的数量。要连接一个有 $k$ 个分量的图，我们必须添加至少 $k-1$ 条边，在这些分量自身上形成一个生成树结构。我们的目标是选择这 $k-1$ 条边，以最小化总成本。\n\n**2. 最优连接策略**\n\n让我们在分量上对问题进行建模。考虑一个“超图”，其中每个顶点代表一个连通分量 $C_i$。我们希望在这个超图中找到一个最小生成树 (MST)。两个超顶点 $C_i$ 和 $C_j$ 之间的边权重是用一条新边连接它们的最小可能成本。\n\n连接分量 $C_i$ 和分量 $C_j$ 的成本由以下公式给出：\n$$ \\min_{u \\in C_i, v \\in C_j} \\{p(u) + p(v)\\} $$\n由于项 $p(u)$ 和 $p(v)$ 是独立的，这个最小值可以通过在每个分量中选择价格最低的顶点来获得：\n$$ \\left(\\min_{u \\in C_i} p(u)\\right) + \\left(\\min_{v \\in C_j} p(v)\\right) $$\n让我们定义 $w_i = \\min_{u \\in C_i} p(u)$ 为分量 $C_i$ 内的最小节点价格。因此，连接 $C_i$ 和 $C_j$ 的成本是 $w_i + w_j$。\n\n我们现在需要在一个有 $k$ 个顶点（代表分量）的完全图上找到一个最小生成树，其中顶点 $i$ 和顶点 $j$ 之间的边权重为 $w_i + w_j$。设所选生成树的边集为 $T_{\\text{comp}}$。总成本为：\n$$ \\text{Cost} = \\sum_{\\{i, j\\} \\in T_{\\text{comp}}} (w_i + w_j) $$\n为了最小化这个成本，一个贪心策略是有效的。我们可以将这个问题视为连接 $k$ 个“城市”（分量），其中每个城市有一个“机场”建设成本（$w_i$）。一个著名的解决方案是：找到全局最便宜的机场，成本为 $w_{\\min\\_global}$，将其作为中心枢纽。然后将所有其他 $k-1$ 个城市的机场连接到这个中心枢纽。\n\n这种策略对应于在超图上构建一个星形图。我们选择具有全局最低价格的分量作为中心的“锚”分量。设分量价格排序为 $w_{(1)} \\le w_{(2)} \\le \\dots \\le w_{(k)}$。我们选择对应于 $w_{(1)}$ 的分量作为中心。它将与其他所有 $k-1$ 个分量连接。\n\n**3. 成本公式推导**\n\n这种最优星形图策略的总成本是连接每个其他分量到锚分量的 $k-1$ 条边的成本之和：\n$$ \\text{Cost} = \\sum_{j=2}^{k} (w_{(1)} + w_{(j)}) $$\n这可以展开和简化：\n$$ \\text{Cost} = (k-1) w_{(1)} + \\sum_{j=2}^{k} w_{(j)} $$\n设 $S = \\sum_{j=1}^{k} w_{(j)}$ 是所有分量最小价格的总和。我们可以写出 $\\sum_{j=2}^{k} w_{(j)} = S - w_{(1)}$。将此代入成本表达式：\n$$ \\text{Cost} = (k-1) w_{(1)} + (S - w_{(1)}) = S + (k-2) w_{(1)} $$\n所以，最小成本是所有分量最小价格的总和，再加上 $(k-2)$ 乘以这些最小价格中的全局最小值。这个公式对 $k \\ge 2$ 成立。当 $k=2$ 时，成本是 $S + (0)w_{(1)} = S = w_{(1)} + w_{(2)}$，这是正确的。\n\n**4. 最终算法**\n\n完整的算法如下：\n1.  给定图的参数 $(n, E, p)$，构建图的邻接表表示。\n2.  识别图的连通分量。这可以通过图遍历算法（如广度优先搜索(BFS)或深度优先搜索(DFS)）来完成。维护一个 `visited` 数组来跟踪已发现的顶点。\n3.  在遍历每个分量时，找到该分量中所有顶点的最小节点价格。将这些最小价格存储在一个列表 `component_min_prices` 中。\n4.  设 $k$ 是找到的连通分量的数量（即 `component_min_prices` 的长度）。\n5.  如果 $k \\le 1$，图已经是连通的或平凡的。成本为 $0$。\n6.  如果 $k > 1$，使用推导出的公式计算最小总成本：\n    a. 计算 $S$，即 `component_min_prices` 中所有值的总和。\n    b. 找到 $w_{\\min\\_global}$，即 `component_min_prices` 中的最小值。\n    c. 总成本为 $S + (k-2) \\times w_{\\min\\_global}$。\n7.  返回计算出的成本。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for a predefined suite of test cases.\n    \"\"\"\n    # Test cases as defined in the problem statement.\n    test_cases = [\n        (6, [(0, 1, 4), (1, 2, 3), (3, 4, 2)], [4, 2, 7, 1, 3, 5]),\n        (4, [(0, 1, 5), (1, 2, 2), (2, 3, 1)], [10, 10, 10, 10]),\n        (2, [], [7, 3]),\n        (7, [(0, 1, 5), (3, 4, 1), (5, 6, 8)], [8, 6, 5, 9, 2, 4, 7]),\n        (1, [], [5])\n    ]\n\n    results = []\n    for n, E, p in test_cases:\n        cost = compute_min_cost(n, E, p)\n        # The problem statement implies integer results for these specific test cases.\n        results.append(int(cost))\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_min_cost(n, edges, prices):\n    \"\"\"\n    Computes the minimum cost to make a graph connected.\n\n    The algorithm proceeds as follows:\n    1. Identify all connected components of the graph.\n    2. For each component, find the minimum node price among its vertices.\n    3. If there is only one component (or fewer), the graph is already connected; cost is 0.\n    4. If there are k > 1 components, the minimum cost is achieved by connecting all other\n       k-1 components to the one \"anchor\" component that contains the node with the\n       globally minimum price.\n    5. The total cost is derived as S + (k-2)*w_min_global, where S is the sum of\n       all component-minimum prices and w_min_global is the smallest of these prices.\n    \"\"\"\n    if n = 1:\n        return 0\n\n    # Adjacency list representation of the graph\n    adj = [[] for _ in range(n)]\n    for u, v, _ in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * n\n    component_min_prices = []\n\n    for i in range(n):\n        if not visited[i]:\n            # A new component is found, start a traversal (DFS)\n            min_price_in_component = float('inf')\n            \n            stack = [i]\n            visited[i] = True\n            \n            while stack:\n                u = stack.pop()\n                min_price_in_component = min(min_price_in_component, prices[u])\n                \n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        stack.append(v)\n            \n            component_min_prices.append(min_price_in_component)\n\n    k = len(component_min_prices)\n    \n    if k = 1:\n        return 0\n    else:\n        # Sum of the minimum node prices from each component\n        sum_of_min_prices = sum(component_min_prices)\n        \n        # Globally minimum price among all component minimums\n        global_min_price = min(component_min_prices)\n        \n        # Derived formula for the total minimum cost\n        total_cost = sum_of_min_prices + (k - 2) * global_min_price\n        return total_cost\n\n# Execute the solution\nsolve()\n\n```", "id": "3223947"}]}