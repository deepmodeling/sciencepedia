{"hands_on_practices": [{"introduction": "许多现实世界中的寻路问题不仅仅是找到两点之间的最短路径，还可能包含必须经过某些特定地点的约束。本练习将引导你处理这类带有中间点约束的最短路径问题。你将学习如何通过将一个复杂问题分解为两个独立的、更简单的广度优先搜索子问题来巧妙地解决它。[@problem_id:3218504]", "problem": "给定有限、无权、有向图。对于每个图，顶点由从 $0$ 到 $n-1$ 的整数标记，边是由有序对 $(u,v)$ 表示的从 $u$ 到 $v$ 的有向边。从源顶点 $s$ 到目标顶点 $t$ 的路径是一个有限的顶点序列 $(v_0,v_1,\\dots,v_k)$，满足 $v_0=s$，$v_k=t$，并且对于每个 $i\\in\\{0,1,\\dots,k-1\\}$ 都存在一条边 $(v_i,v_{i+1})$。路径的长度是其上的边数，即 $k$。在本任务中，您必须找到一条从 $s$ 到 $t$ 的最短路径，该路径至少经过一个指定的中间顶点 $w$ 一次（中间顶点可以与 $s$ 或 $t$ 重合）。如果存在多条这样的最短路径，选择顶点标签序列字典序最小的那一条。如果不存在从 $s$ 到 $t$ 且包含 $w$ 的路径，则报告无解。\n\n您的程序必须为每个测试用例计算出从 $s$ 到 $t$ 经过 $w$ 的最短路径的整数长度 $L$，以及表示为顶点标签列表的相应路径 $P$。如果不存在路径，则输出 $L=-1$ 和空列表 $[]$ 作为 $P$。\n\n仅使用图和路径的基本定义。不要依赖任何无法从核心定义和数据结构与算法研究中公认的事实推导出的专门启发式方法。\n\n测试套件：\n- 测试用例 A：\n  - 顶点数：$n=6$（顶点为 $0,1,2,3,4,5$）。\n  - 有向边：$((0,1),(0,2),(1,3),(2,3),(3,4),(4,5),(1,5),(2,5))$。\n  - 源点 $s=0$，目标点 $t=5$，中间点 $w=3$。\n- 测试用例 B：\n  - 顶点数：$n=7$（顶点为 $0,1,2,3,4,5,6$）。\n  - 有向边：$((0,1),(0,2),(1,3),(2,3),(3,4),(3,5),(4,6),(5,6))$。\n  - 源点 $s=0$，目标点 $t=6$，中间点 $w=3$。\n- 测试用例 C：\n  - 顶点数：$n=4$（顶点为 $0,1,2,3$）。\n  - 有向边：$((0,1),(1,2),(2,3))$。\n  - 源点 $s=0$，目标点 $t=3$，中间点 $w=0$。\n- 测试用例 D：\n  - 顶点数：$n=5$（顶点为 $0,1,2,3,4$）。\n  - 有向边：$((0,2),(2,4))$。\n  - 源点 $s=0$，目标点 $t=4$，中间点 $w=4$。\n- 测试用例 E：\n  - 顶点数：$n=6$（顶点为 $0,1,2,3,4,5$）。\n  - 有向边：$((0,1),(1,2),(3,4),(4,5))$。\n  - 源点 $s=0$，目标点 $t=5$，中间点 $w=3$。\n- 测试用例 F：\n  - 顶点数：$n=7$（顶点为 $0,1,2,3,4,5,6$）。\n  - 有向边：$((0,1),(1,2),(2,0),(2,3),(3,4),(4,5),(5,3),(1,6),(6,4))$。\n  - 源点 $s=0$，目标点 $t=5$，中间点 $w=4$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个由方括号括起来的逗号分隔列表（例如，$[result_1,result_2,\\dots]$）。\n- 每个 $result_i$ 必须是双元素列表 $[L,P]$，其中 $L$ 是整数路径长度，$P$ 是表示满足经过 $w$ 约束条件的路径的整数列表。\n- 如果不存在这样的路径，则为该测试用例输出 $[-1,[]]$。", "solution": "## 问题验证\n\n### 第 1 步：提取已知信息\n\n问题为一系列测试用例提供了以下数据和定义：\n- 图结构：有限、无权、有向图。\n- 顶点标记：从 $0$ 到 $n-1$ 的整数，其中 $n$ 是顶点数。\n- 边表示：从顶点 $u$ 到顶点 $v$ 的边是一个有序对 $(u,v)$。\n- 路径定义：一个顶点序列 $(v_0, v_1, \\dots, v_k)$，其中 $v_0$ 是源顶点 $s$，$v_k$ 是目标顶点 $t$，并且对于每个 $i \\in \\{0, 1, \\dots, k-1\\}$，存在一条边 $(v_i, v_{i+1})$。\n- 路径长度：路径中的边数，用 $k$ 表示。\n- 主要约束：从 $s$ 到 $t$ 的路径必须至少经过一个指定的中间顶点 $w$ 一次。\n- 目标 1 (最小化)：找到一条满足约束条件且长度 $L$ 尽可能最小的路径。\n- 目标 2 (平局打破)：如果存在多条最小长度的路径，选择字典序最小的那一条。字典序比较是在整数顶点标签序列上进行的。如果路径 $P_A = (v_0, v_1, \\dots, v_k)$ 在与另一条路径 $P_B = (u_0, u_1, \\dots, u_k)$ 的第一个不同索引 $i$ 处，有 $v_i  u_i$，那么 $P_A$ 的字典序就小于 $P_B$。\n- 无解情况：如果不存在从 $s$ 到 $t$ 且经过 $w$ 的路径，则长度 $L$ 应为 $-1$，路径 $P$ 应为空列表 $[]$。\n- 测试套件：提供了六个特定的测试用例 (A-F)，每个用例都定义了顶点数 $n$、一个边集、一个源点 $s$、一个目标点 $t$ 和一个中间顶点 $w$。\n\n### 第 2 步：使用提取的已知信息进行验证\n\n根据验证标准对问题陈述进行审查：\n\n- **科学依据（关键）**：该问题本质上是一个图遍历问题。它依赖于图论中的标准和普遍接受的定义，图论是数学和计算机科学的核心领域。像有向图、路径、路径长度和字典序等概念都得到了严格的定义。该问题不含任何伪科学或事实错误。\n- **适定性 (Well-Posed)**：该问题是适定的。目标明确陈述：找到具有特定属性的最短路径。包含字典序平局打破规则确保了如果存在解，解是唯一的。构成解与无解的条件也已明确定义。\n- **客观性（关键）**：问题以精确、客观和数学化的语言陈述。它没有任何歧义、主观性或基于观点的主张。\n\n此外，该问题没有表现出任何列出的无效性缺陷：\n1.  **科学或事实不健全**：无。该问题基于合理的数学原理。\n2.  **不可形式化或不相关**：该问题可直接形式化为一个算法任务，并且是最短路径算法的经典应用，与指定主题“广度优先搜索及其应用”高度相关。\n3.  **不完整或矛盾的设置**：无。每个测试用例都是自包含的，并提供了所有必要的参数（$n$、边、$s$、$t$、$w$）。\n4.  **不切实际或不可行**：不适用。该问题处理的是抽象的数学图结构，物理真实性不是一个相关的约束。\n5.  **不适定或结构不良**：无。该问题结构良好，其目标保证了在有解的情况下，存在唯一且有意义的解。\n6.  **伪深刻、琐碎或同义反复**：无。该问题需要对标准算法进行深思熟虑的组合，以处理中间顶点约束和字典序平局打破规则，使其成为一个非琐碎的算法挑战。\n7.  **超出科学可验证性**：无。任何提出的算法解决方案都可以被严格证明是正确的，其输出可以根据问题的定义进行验证。\n\n### 第 3 步：结论和行动\n\n问题陈述是**有效的**。这是一个算法领域中清晰、一致且可解决的问题。将提供完整的解决方案。\n\n## 解决方案\n\n问题要求找到从源顶点 $s$到目标顶点 $t$ 的、字典序最小的最短路径，该路径受限于必须经过一个特定的中间顶点 $w$。\n\n### 基于原则的设计\n\n一条从 $s$ 到 $t$ 且经过 $w$ 的路径，可以从概念上分解为两个部分：一条从 $s$ 到 $w$ 的路径和一条从 $w$ 到 $t$ 的路径。要找到总的最短路径，我们必须找到这两个分段各自的最短路径。\n设 $P_{s \\to w}$ 是从 $s$ 到 $w$ 的一条最短路径，而 $P_{w \\to t}$ 是从 $w$ 到 $t$ 的一条最短路径。这两条路径的串联构成了一条从 $s$ 到 $t$ 且经过 $w$ 的路径。这条串联路径的长度是各独立路径长度之和：$L = \\text{length}(P_{s \\to w}) + \\text{length}(P_{w \\to t})$。根据最优性原则，任何经由 $w$ 从 $s$ 到 $t$ 的最短路径都必须由一条从 $s$ 到 $w$ 的最短路径和一条从 $w$ 到 $t$ 的最短路径组成。\n\n由于图是无权的，广度优先搜索（BFS）算法是寻找单源最短路径的合适方法。标准的BFS可以找到边数最少的路径。\n\n问题引入了一个平局打破规则：在所有最短路径中，我们必须选择字典序最小的那一条。为确保我们的BFS能找到字典序最小的路径，我们必须修改其探索邻居的顺序。在探索任何给定顶点的邻居时，标准的BFS算法可以按任何顺序访问它们。为了满足字典序要求，我们必须确保按顶点标签的升序访问邻居。这可以通过对每个顶点的邻接表进行排序来实现。\n\n总的算法如下：\n\n1.  **图表示**：使用邻接表表示图。对于每个顶点 $u$，列表 `adj[u]` 将存储所有存在边 $(u,v)$ 的顶点 $v$。至关重要的是，为了便于字典序平局打破，每个列表都必须按升序排序。\n\n2.  **改进的广度优先搜索**：实现一个BFS函数 `bfs(graph, source)`，它接受一个图和一个源顶点作为输入。该函数将：\n    - 使用一个队列来管理待访问的顶点前沿。\n    - 使用一个 `distance` 数组，初始化为一个表示无穷大的值（例如 $-1$），来存储从 `source` 到每个其他顶点的最短距离。\n    - 使用一个 `parent` 数组来存储最短路径中每个顶点的前驱节点，这对于路径重建是必需的。\n    - 当从队列中取出一个顶点 $u$ 时，遍历其已排序邻接表中的邻居 $v$。如果 $v$ 尚未被访问（即 `distance[v] == -1`），则更新其距离和父节点（`distance[v] = distance[u] + 1`, `parent[v] = u`）并将其入队。\n    - 函数返回 `distance` 和 `parent` 数组。\n\n3.  **路径查找与组合**：\n    a. 从源顶点 $s$ 开始执行改进的BFS：`(distances_s, parents_s) = bfs(graph, s)`。\n    b. 从中间顶点 $w$ 开始执行改进的BFS：`(distances_w, parents_w) = bfs(graph, w)`。\n\n4.  **可达性检查**：\n    a. 通过检查 `distances_s[w]` 来判断 $w$ 是否可从 $s$ 到达。\n    b. 通过检查 `distances_w[t]` 来判断 $t$ 是否可从 $w$ 到达。\n    c. 如果任一者不可达（距离为 $-1$），则不存在有效路径。在这种情况下，结果是长度为 $-1$ 和空路径 $[]$。\n\n5.  **路径重建**：\n    a. 如果两个分段都可通行，则使用 `parents_s` 数组从 $w$ 回溯到 $s$，重建从 $s$ 到 $w$ 的字典序最小的最短路径，我们称之为 $P_{s \\to w}$。\n    b. 类似地，使用 `parents_w` 数组重建从 $w$ 到 $t$ 的路径 $P_{w \\to t}$。\n\n6.  **最终路径和长度计算**：\n    a. 最终路径 $P$ 是 $P_{s \\to w}$ 和 $P_{w \\to t}$ 的串联。由于 $w$ 是 $P_{s \\to w}$ 的最后一个顶点和 $P_{w \\to t}$ 的第一个顶点，它会出现两次。必须移除其中一个实例。最终路径为 $P = P_{s \\to w} + P_{w \\to t}[1:]$，其中 `+` 表示列表拼接，`[1:]` 表示从第二个元素开始的列表切片。\n    b. 总长度 $L$ 是两个子路径长度之和：$L = \\text{distances\\_s}[w] + \\text{distances\\_w}[t]$。\n\n这种构造性方法保证能产生正确的结果。路径长度是最小的，因为它是两个最小长度子路径的和。在所有最短路径中，该路径的字典序是最小的，因为两个字典序最小的最短路径（$s \\to w$ 和 $w \\to t$）的顺序组合会产生一个整体字典序最小的路径。如果存在一条相同长度但字典序更小的路径，那将意味着其 $s \\to w$ 段或 $w \\to t$ 段的字典序更小，这与它们的构造方式相矛盾。", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves a series of graph pathfinding problems as specified in the test suite.\n    \"\"\"\n    test_cases = [\n        # Test Case A\n        {'n': 6, 'edges': ((0,1),(0,2),(1,3),(2,3),(3,4),(4,5),(1,5),(2,5)), 's': 0, 't': 5, 'w': 3},\n        # Test Case B\n        {'n': 7, 'edges': ((0,1),(0,2),(1,3),(2,3),(3,4),(3,5),(4,6),(5,6)), 's': 0, 't': 6, 'w': 3},\n        # Test Case C\n        {'n': 4, 'edges': ((0,1),(1,2),(2,3)), 's': 0, 't': 3, 'w': 0},\n        # Test Case D\n        {'n': 5, 'edges': ((0,2),(2,4)), 's': 0, 't': 4, 'w': 4},\n        # Test Case E\n        {'n': 6, 'edges': ((0,1),(1,2),(3,4),(4,5)), 's': 0, 't': 5, 'w': 3},\n        # Test Case F\n        {'n': 7, 'edges': ((0,1),(1,2),(2,0),(2,3),(3,4),(4,5),(5,3),(1,6),(6,4)), 's': 0, 't': 5, 'w': 4},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_constrained_path(case['n'], case['edges'], case['s'], case['t'], case['w'])\n        # Python's default str() for lists adds spaces, which is not ideal for the join,\n        # so we manually create a compact string representation.\n        path_str = f\"[{','.join(map(str, result[1]))}]\"\n        results.append(f\"[{result[0]},{path_str}]\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef find_constrained_path(n, edges, s, t, w):\n    \"\"\"\n    Finds the lexicographically smallest shortest path from s to t passing through w.\n    \"\"\"\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n    \n    # Sort adjacency lists to ensure lexicographically smallest path in BFS\n    for i in range(n):\n        adj[i].sort()\n\n    # Find shortest path from s to w\n    distances_s, parents_s = bfs(n, adj, s)\n    if distances_s[w] == -1:\n        return [-1, []]\n\n    # Find shortest path from w to t\n    distances_w, parents_w = bfs(n, adj, w)\n    if distances_w[t] == -1:\n        return [-1, []]\n\n    # Reconstruct paths\n    path_sw = reconstruct_path(s, w, parents_s)\n    path_wt = reconstruct_path(w, t, parents_w)\n\n    # Combine paths and total length\n    # The intermediate vertex 'w' is the end of the first path and the start of the second,\n    # so we exclude it from the second path segment to avoid duplication.\n    full_path = path_sw + path_wt[1:]\n    full_length = distances_s[w] + distances_w[t]\n    \n    return [full_length, full_path]\n\ndef bfs(n, adj, start_node):\n    \"\"\"\n    Performs a Breadth-First Search to find shortest paths from a start_node.\n    It returns distances and parent pointers for path reconstruction.\n    adjacency lists in 'adj' must be sorted to find lexicographically smallest paths.\n    \"\"\"\n    # Initialize distances and parents arrays. -1 indicates not visited.\n    distances = np.full(n, -1, dtype=int)\n    parents = np.full(n, -1, dtype=int)\n    \n    q = deque([start_node])\n    distances[start_node] = 0\n    \n    while q:\n        u = q.popleft()\n        \n        # Iterate over neighbors in pre-sorted order\n        for v in adj[u]:\n            if distances[v] == -1: # If vertex v has not been visited\n                distances[v] = distances[u] + 1\n                parents[v] = u\n                q.append(v)\n                \n    return distances, parents\n\ndef reconstruct_path(start, end, parents):\n    \"\"\"\n    Reconstructs the path from a start to an end vertex using the parent pointers.\n    \"\"\"\n    path = []\n    curr = end\n    if parents[curr] == -1 and curr != start: # End node is not reachable from start\n        return []\n        \n    while True:\n        path.append(curr)\n        if curr == start:\n            break\n        curr = parents[curr]\n    \n    return path[::-1] # Reverse to get path from start to end\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3218504"}, {"introduction": "标准的广度优先搜索（BFS）旨在寻找边数最少的路径，但当路径长度需要满足特定属性（如奇偶性）时，情况就变得复杂了。本练习探讨了如何通过扩展状态空间来解决这类带约束的寻路问题，这是将复杂约束融入图搜索算法的一种强大而通用的技巧。通过将路径的奇偶性作为状态的一部分，你可以将原问题转化为一个可以在新状态图上直接应用BFS的等价问题。[@problem_id:3218441]", "problem": "您的任务是设计并实现一个算法解决方案，该方案基于图的基本定义和广度优先搜索（BFS）算法久经检验的性质，以确定有向图中的受限最短路径。考虑一个有限、有向、无权图 $G = (V, E)$，其中 $|V| = n$ 且 $|E| = m$，$V$ 是一个有限的顶点集合，$E \\subseteq V \\times V$ 是一个有限的有向边集合。从顶点 $s \\in V$ 到顶点 $t \\in V$ 的一条路径是一个顶点序列 $(v_0, v_1, \\dots, v_k)$，使得 $v_0 = s$，$v_k = t$，并且对于所有满足 $1 \\le i \\le k$ 的整数 $i$，都有 $(v_{i-1}, v_i) \\in E$。路径的长度是其包含的边的数量，即 $k$。如果路径的长度 $k$ 是一个偶数（包括 $k = 0$），则称该路径为偶数长度路径。\n\n对于下述测试套件中的每个测试用例，您的程序必须计算从指定的源顶点 $s$ 到指定的目标顶点 $t$ 的最短偶数长度路径的长度。如果不存在偶数长度的路径，则该测试用例返回 $-1$。答案应以整数形式报告。\n\n解决方案必须基于以下基础推导得出：\n- 图、路径和路径长度的基本定义。\n- 对有限无权图进行广度优先搜索（BFS）会按距离的非递减顺序发现顶点，并以边的数量计算最短路径长度，这一久经检验的事实。\n\n测试套件。对于每个测试用例，图都是有向且无权的。每个用例都指定了顶点数 $n$、以有序对表示的边集 $E$ 以及查询 $(s, t)$。\n\n- 用例 $1$：\n  $$n = 6,\\quad E = \\{(0,1),(1,2),(2,3),(3,4),(4,5),(0,2),(2,4)\\},\\quad s = 0,\\ t = 4.$$\n- 用例 $2$：\n  $$n = 3,\\quad E = \\{(0,1),(1,2),(2,0),(2,1)\\},\\quad s = 0,\\ t = 1.$$\n- 用例 $3$：\n  $$n = 2,\\quad E = \\{(0,1)\\},\\quad s = 0,\\ t = 1.$$\n- 用例 $4$：\n  $$n = 4,\\quad E = \\{(0,1),(1,2),(2,3),(3,0)\\},\\quad s = 0,\\ t = 0.$$\n- 用例 $5$：\n  $$n = 6,\\quad E = \\{(0,1),(1,3),(3,5),(0,2),(2,4),(4,5),(1,2)\\},\\quad s = 0,\\ t = 5.$$\n- 用例 $6$：\n  $$n = 2,\\quad E = \\{(0,1),(1,1)\\},\\quad s = 0,\\ t = 1.$$\n\n要求的最终输出格式。您的程序应生成一行输出，其中包含所有用例的结果，按顺序排列，形式为用方括号括起来的逗号分隔列表，不含空格，例如 $[r_1,r_2,\\dots,r_k]$，其中每个 $r_i$ 是用例 $i$ 的整数答案。", "solution": "用户提供了一个问题，要求在一个有向无权图中找到两个顶点之间的最短偶数长度路径的长度。解决方案必须根据图论原理和广度优先搜索（BFS）算法推导得出。\n\n### 问题验证\n\n#### 第 1 步：提取已知条件\n- **图**：一个有限、有向、无权图 $G = (V, E)$，其中 $|V| = n$ 且 $|E| = m$。\n- **路径**：一个顶点序列 $(v_0, v_1, \\dots, v_k)$，使得 $v_0 = s$，$v_k = t$，并且对于 $1 \\le i \\le k$，有 $(v_{i-1}, v_i) \\in E$。\n- **路径长度**：一条路径中的边数，$k$。\n- **偶数长度路径**：长度 $k$ 为偶数（$k \\ge 0$）的路径。\n- **目标**：对于给定的源点 $s$ 和目标点 $t$，计算从 $s$ 到 $t$ 的最短偶数长度路径的长度。如果不存在这样的路径，则值为 $-1$。\n- **算法基础**：解决方案必须基于图的基本定义和广度优先搜索（BFS）的性质，特别是它能在无权图中找到最短路径。\n- **测试套件**：\n  - 用例 $1$：$n = 6$, $E = \\{(0,1),(1,2),(2,3),(3,4),(4,5),(0,2),(2,4)\\}$, $s = 0, t = 4$。\n  - 用例 $2$：$n = 3$, $E = \\{(0,1),(1,2),(2,0),(2,1)\\}$, $s = 0, t = 1$。\n  - 用例 $3$：$n = 2$, $E = \\{(0,1)\\}$, $s = 0, t = 1$。\n  - 用例 $4$：$n = 4$, $E = \\{(0,1),(1,2),(2,3),(3,0)\\}$, $s = 0, t = 0$。\n  - 用例 $5$：$n = 6$, $E = \\{(0,1),(1,3),(3,5),(0,2),(2,4),(4,5),(1,2)\\}$, $s = 0, t = 5$。\n  - 用例 $6$：$n = 2$, $E = \\{(0,1),(1,1)\\}$, $s = 0, t = 1$。\n\n#### 第 2 步：使用提取的已知条件进行验证\n根据验证标准对问题进行评估：\n- **科学依据**：该问题是图论和算法中的一个成熟课题，属于计算机科学和离散数学的子领域。它基于图、路径和路径长度的形式化定义。所有前提在事实上都是可靠的。\n- **良态问题**：问题定义清晰。目标是在特定约束（偶数长度）下找到一个最小值（最短长度）。对于有限图，这样的路径要么存在（这种情况下，保证存在一条最短路径），要么不存在。因此，存在一个唯一的、有意义的解（该长度或-1）。\n- **客观性**：问题陈述以精确、形式化的数学语言表达，没有任何主观性、模糊性或意见。\n- **相关性**：该问题与广度优先搜索及其应用的主题直接相关，正如问题陈述中所指定的。\n\n该问题没有表现出任何已定义的缺陷。它是科学可靠、可形式化、完整、可行且良态的。这是一个经典算法的标准扩展，而不是一个微不足道或人为设计的问题。\n\n#### 第 3 步：结论与行动\n问题是有效的。将提供一个解决方案。\n\n### 解决方案推导\n\n该问题要求在路径长度的奇偶性存在附加约束的情况下，求最短路径的长度。标准的广度优先搜索（BFS）算法保证在无权图中找到最短路径，其中“最短”定义为最少的边数。然而，标准的BFS本身并不区分不同奇偶性的路径。由BFS找到的最短路径可能是奇数长度的，这对于我们的问题来说不是一个有效的解。\n\n为了引入奇偶性约束，我们必须扩展搜索中使用的状态表示。在标准的BFS中，一个状态对应一个顶点 $v \\in V$。我们需要一个不仅能编码当前位置（顶点），还能编码到达该位置的路径奇偶性的状态表示。\n\n我们可以定义一个新的状态空间。一个状态可以由一个对 $(v, p)$ 表示，其中 $v \\in V$ 是一个顶点，$p \\in \\{0, 1\\}$ 是从源顶点 $s$ 到达顶点 $v$ 的路径长度的奇偶性。这里，$p=0$ 表示偶数长度路径，$p=1$ 表示奇数长度路径。\n\n这种概念上的扩充可以通过构建一个新图 $G' = (V', E')$ 来形式化。\n- 新图中的顶点集是 $V' = V \\times \\{0, 1\\}$。这个集合的大小是 $|V'| = 2n$。$G'$ 中的一个顶点 $(v, p)$ 表示我们通过一条奇偶性为 $p$ 的路径到达了 $G$ 中的顶点 $v$。\n- $G'$ 中的边集 $E'$ 是从 $G$ 中的边派生出来的。对于 $E$ 中的每条边 $(u, v)$，遍历它会使路径长度增加1，从而翻转路径长度的奇偶性。这对应到 $G'$ 中的两条有向边：\n  1. 从 $(u, 0)$ 到 $(v, 1)$ 的边：一条到 $u$ 的偶数长度路径，后跟边 $(u,v)$，会得到一条到 $v$ 的奇数长度路径。\n  2. 从 $(u, 1)$ 到 $(v, 0)$ 的边：一条到 $u$ 的奇数长度路径，后跟边 $(u,v)$，会得到一条到 $v$ 的偶数长度路径。\n\n在原始图 $G$ 中寻找从 $s$ 到 $t$ 的最短偶数长度路径的问题，现在被转换成在新图 $G'$ 中寻找从一个起始顶点到一个目标顶点的最短路径问题。起点是 $s$ 到自身的一条长度为 $0$ 的路径。由于 $0$ 是偶数，因此 $G'$ 中的起始状态是 $(s, 0)$。我们在寻找一条到 $t$ 的偶数长度路径，因此在 $G'$ 中的目标状态是 $(t, 0)$。\n\n由于原始图 $G$ 是无权的，转换后的图 $G'$ 也是无权的。因此，我们可以在 $G'$ 上应用标准的BFS算法来找到从 $(s, 0)$ 到 $(t, 0)$ 的最短路径。这条在 $G'$ 中的路径长度等于其在 $G$ 中对应路径的长度。\n\n该算法流程如下：\n1.  我们不需要显式地构建 $G'$。我们可以在隐式的状态空间上执行BFS。\n2.  我们使用一个队列来存储待访问的状态。队列中的每个元素将是一个元组 `(vertex, path_length)`。\n3.  我们使用一个二维数组 `distances[v][p]` 来存储到目前为止找到的、到达顶点 $v$ 且奇偶性为 $p$ 的最短路径的长度。该数组的大小为 $n \\times 2$，并用一个表示不可达的值（如-1）进行初始化。这个数组也用于跟踪已访问的状态，以防止循环和冗余计算。\n4.  搜索从源点 $s$ 开始，路径长度为 $0$。我们初始化 `distances[s][0] = 0` 并将 $(s, 0)$ 添加到队列中。\n5.  BFS主循环：\n    a. 从队列中取出一个状态 $(u, d)$。\n    b. 对于原始图 $G$ 中 $u$ 的每个邻居 $v$：\n        i. 到 $v$ 的新路径长度为 $d_{\\text{new}} = d + 1$。\n        ii. 这条新路径的奇偶性为 $p_{\\text{new}} = d_{\\text{new}} \\pmod 2$。\n        iii. 如果状态 $(v, p_{\\text{new}})$ 尚未被访问过（即 `distances[v][p_{new}] == -1`），我们便找到了到达此状态的最短路径。我们记录其长度 `distances[v][p_{new}] = d_{new}`，并将新状态 $(v, d_{new})$ 入队。\n6.  BFS持续进行直到队列为空。\n7.  最终答案是到达 $t$ 的最短偶数长度路径的长度，存储在 `distances[t][0]` 中。如果 `distances[t][0]` 仍然是其初始值-1，则意味着状态 $(t, 0)$ 从未被到达，因此不存在从 $s$ 到 $t$ 的偶数长度路径。\n\n一个特殊情况是当 $s = t$ 时。从 $s$ 到其自身的长度为 $0$ 的路径是一条偶数长度路径。因此，答案是 $0$。所述算法正确地处理了这种情况，因为 `distances[s][0]` 被初始化为 $0$。\n\n这种基于原则的方法通过扩展状态空间以包含约束本身，正确地改编了BFS算法来解决带约束的最短路径问题。", "answer": "```python\nimport collections\nimport numpy as np\n\ndef solve_case(n, E, s, t):\n    \"\"\"\n    Computes the length of the shortest even-length path from s to t.\n\n    The problem is solved by running a Breadth-First Search (BFS) on an\n    expanded state space. A state is defined by a pair (vertex, parity),\n    where parity is 0 for even-length paths and 1 for odd-length paths.\n\n    This is equivalent to finding the shortest path in a new graph G' where\n    each vertex v in the original graph G is split into two vertices, (v, 0)\n    and (v, 1). An edge (u, v) in G corresponds to edges ((u, 0), (v, 1))\n    and ((u, 1), (v, 0)) in G'.\n\n    We seek the shortest path from state (s, 0) to (t, 0).\n\n    Args:\n        n (int): The number of vertices.\n        E (list of tuples): The set of directed edges.\n        s (int): The source vertex.\n        t (int): The target vertex.\n\n    Returns:\n        int: The length of the shortest even-length path, or -1 if none exists.\n    \"\"\"\n    if n == 0:\n        return -1\n\n    adj = collections.defaultdict(list)\n    for u, v in E:\n        adj[u].append(v)\n    \n    # A path of length 0 from s to s is an even-length path.\n    if s == t:\n        return 0\n\n    # distances[v][p] stores the shortest distance to vertex v\n    # with a path of parity p (0 for even, 1 for odd).\n    # Initialize with -1 to indicate unreachability.\n    distances = np.full((n, 2), -1, dtype=int)\n    \n    # The queue stores tuples of (vertex, current_path_length).\n    queue = collections.deque()\n\n    # Start BFS from source s with a path of length 0.\n    # The path is even, so update distances for parity 0.\n    distances[s][0] = 0\n    queue.append((s, 0))\n\n    while queue:\n        u, path_len = queue.popleft()\n        \n        new_path_len = path_len + 1\n        new_parity = new_path_len % 2\n\n        for v in adj[u]:\n            # If we haven't found a path to vertex v with this new_parity,\n            # this must be the shortest one.\n            if distances[v][new_parity] == -1:\n                distances[v][new_parity] = new_path_len\n                queue.append((v, new_path_len))\n                \n                # If we've just reached the target with an even path, we are done\n                # because BFS guarantees this is the shortest such path.\n                if v == t and new_parity == 0:\n                    return new_path_len\n\n    # If the BFS completes and distances[t][0] is still -1, no even path exists.\n    return distances[t][0]\n\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the shortest even-length path problem.\n    \"\"\"\n    test_cases = [\n        {\"n\": 6, \"E\": [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (0, 2), (2, 4)], \"s\": 0, \"t\": 4},\n        {\"n\": 3, \"E\": [(0, 1), (1, 2), (2, 0), (2, 1)], \"s\": 0, \"t\": 1},\n        {\"n\": 2, \"E\": [(0, 1)], \"s\": 0, \"t\": 1},\n        {\"n\": 4, \"E\": [(0, 1), (1, 2), (2, 3), (3, 0)], \"s\": 0, \"t\": 0},\n        {\"n\": 6, \"E\": [(0, 1), (1, 3), (3, 5), (0, 2), (2, 4), (4, 5), (1, 2)], \"s\": 0, \"t\": 5},\n        {\"n\": 2, \"E\": [(0, 1), (1, 1)], \"s\": 0, \"t\": 1},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case[\"n\"], case[\"E\"], case[\"s\"], case[\"t\"])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3218441"}, {"introduction": "在网络路由、物流规划等领域，了解两个节点之间存在多少条不同的最短路径，对于评估网络的冗余度和鲁棒性至关重要。本练习将展示广度优先搜索（BFS）不仅能找到最短路径的长度，还能揭示图的层次结构。我们将利用这一结构，结合动态规划的思想，来高效地计算从起点到终点的所有不同最短路径的总数。[@problem_id:3218407]", "problem": "考虑一个无权无向图 $G = (V,E)$，其顶点集为 $V = \\{s,t,a,b,c,d,e,f,g,h,i,j,k,l,m,n\\}$，边集为\n$$\nE = \\{(s,a),(s,b),(s,c),(a,d),(a,e),(b,e),(b,f),(c,f),(c,g),(d,h),(e,h),(e,i),(f,i),(f,j),(g,j),(h,k),(i,k),(i,l),(j,l),(k,m),(l,m),(l,n),(m,t),(n,t)\\}.\n$$\n路径是由边连接的顶点序列，其长度是该序列中边的数量。距离 $\\mathrm{dist}(s,t)$ 是从 $s$ 到 $t$ 的最小路径长度。如果两个路径的顶点序列至少在一个位置上不同，则它们是不同的路径。确定从 $s$ 到 $t$ 的不同最短路径的总数。请将最终答案表示为一个整数。无需四舍五入。", "solution": "问题陈述已经过分析，并被认为是有效的。这是一个图论中定义明确的问题，建立在标准、清晰定义的数学原理之上。图、顶点、边和目标都已明确指定，不包含任何矛盾、歧义或科学上不成立的前提。\n\n该问题要求计算在一个无权无向图 $G = (V,E)$ 中，从源顶点 $s$ 到目标顶点 $t$ 的不同最短路径的数量。这可以通过将广度优先搜索（BFS）与动态规划方法相结合来解决。\n\n首先，我们必须确定从 $s$ 到所有其他顶点的最短路径长度。由于该图是无权的，从 $s$ 开始的广度优先搜索（BFS）将找到每个顶点 $v \\in V$ 的最短路径距离 $\\mathrm{dist}(s,v)$。BFS 根据顶点与 $s$ 的距离将顶点划分为不同的层。设 $L_k$ 是距离 $s$ 为 $k$ 的顶点集合，即 $L_k = \\{v \\in V \\mid \\mathrm{dist}(s,v) = k\\}$。\n\n让我们执行 BFS 来找到这些层：\n- 层 $L_0$：该层仅包含源顶点。$L_0 = \\{s\\}$。距离为 $\\mathrm{dist}(s,s) = 0$。\n- 层 $L_1$：这些是 $s$ 的邻居。从边集 $E$ 中，我们发现邻居是 $a$、$b$ 和 $c$。所以，$L_1 = \\{a, b, c\\}$，并且对于每个 $v \\in L_1$，$\\mathrm{dist}(s,v)=1$。\n- 层 $L_2$：这些是 $L_1$ 中顶点的未访问过的邻居。\n  - $a$ 的邻居：$\\{s,d,e\\}$。$s \\in L_0$。$d, e$ 是新发现的。\n  - $b$ 的邻居：$\\{s,e,f\\}$。$s \\in L_0$。$e$ 已被找到。$f$ 是新发现的。\n  - $c$ 的邻居：$\\{s,f,g\\}$。$s \\in L_0$。$f$ 已被找到。$g$ 是新发现的。\n  - 因此，$L_2 = \\{d, e, f, g\\}$，并且对于每个 $v \\in L_2$，$\\mathrm{dist}(s,v)=2$。\n- 层 $L_3$：$L_2$ 中顶点的未访问过的邻居。\n  - $d$ 的邻居：$\\{a,h\\}$。$a \\in L_1$。$h$ 是新发现的。\n  - $e$ 的邻居：$\\{a,b,h,i\\}$。$a,b \\in L_1$。$h$ 已被找到。$i$ 是新发现的。\n  - $f$ 的邻居：$\\{b,c,i,j\\}$。$b,c \\in L_1$。$i$ 已被找到。$j$ 是新发现的。\n  - $g$ 的邻居：$\\{c,j\\}$。$c \\in L_1$。$j$ 已被找到。\n  - 因此，$L_3 = \\{h, i, j\\}$，并且对于每个 $v \\in L_3$，$\\mathrm{dist}(s,v)=3$。\n- 层 $L_4$：$L_3$ 中顶点的未访问过的邻居。\n  - $h$ 的邻居：$\\{d,e,k\\}$。$d,e \\in L_2$。$k$ 是新发现的。\n  - $i$ 的邻居：$\\{e,f,k,l\\}$。$e,f \\in L_2$。$k$ 已被找到。$l$ 是新发现的。\n  - $j$ 的邻居：$\\{f,g,l\\}$。$f,g \\in L_2$。$l$ 已被找到。\n  - 因此，$L_4 = \\{k, l\\}$，并且对于每个 $v \\in L_4$，$\\mathrm{dist}(s,v)=4$。\n- 层 $L_5$：$L_4$ 中顶点的未访问过的邻居。\n  - $k$ 的邻居：$\\{h,i,m\\}$。$h,i \\in L_3$。$m$ 是新发现的。\n  - $l$ 的邻居：$\\{i,j,m,n\\}$。$i,j \\in L_3$。$m$ 已被找到。$n$ 是新发现的。\n  - 因此，$L_5 = \\{m, n\\}$，并且对于每个 $v \\in L_5$，$\\mathrm{dist}(s,v)=5$。\n- 层 $L_6$：$L_5$ 中顶点的未访问过的邻居。\n  - $m$ 的邻居：$\\{k,l,t\\}$。$k,l \\in L_4$。$t$ 是新发现的。\n  - $n$ 的邻居：$\\{l,t\\}$。$l \\in L_4$。$t$ 已被找到。\n  - 因此，$L_6 = \\{t\\}$，从 $s$ 到 $t$ 的最短路径距离为 $\\mathrm{dist}(s,t)=6$。\n\n现在，我们来计算不同最短路径的数量。设 $N(v)$ 是从 $s$ 到顶点 $v$ 的不同最短路径的数量。对于任何顶点 $v \\in L_k$（其中 $k > 0$），从 $s$ 到 $v$ 的任何最短路径都必须经过一个前驱顶点 $u \\in L_{k-1}$，使得 $(u,v) \\in E$。到 $v$ 的最短路径数量是到所有这些前驱顶点的最短路径数量之和。这给出了递推关系：\n$$\nN(v) = \\sum_{u \\in L_{k-1} \\text{ and } (u,v) \\in E} N(u)\n$$\n我们逐层计算所有顶点的 $N(v)$。\n\n- **层 $L_0$**：基准情况是源顶点 $s$。从 $s$ 到其自身有一条路径（空路径），所以 $N(s) = 1$。\n\n- **层 $L_1 = \\{a, b, c\\}$**：\n  - 对于 $a$：在 $L_0$ 中的唯一前驱是 $s$。$N(a) = N(s) = 1$。\n  - 对于 $b$：在 $L_0$ 中的唯一前驱是 $s$。$N(b) = N(s) = 1$。\n  - 对于 $c$：在 $L_0$ 中的唯一前驱是 $s$。$N(c) = N(s) = 1$。\n\n- **层 $L_2 = \\{d, e, f, g\\}$**：\n  - 对于 $d$：在 $L_1$ 中的唯一前驱是 $a$。$N(d) = N(a) = 1$。\n  - 对于 $e$：在 $L_1$ 中的前驱是 $a$ 和 $b$。$N(e) = N(a) + N(b) = 1 + 1 = 2$。\n  - 对于 $f$：在 $L_1$ 中的前驱是 $b$ 和 $c$。$N(f) = N(b) + N(c) = 1 + 1 = 2$。\n  - 对于 $g$：在 $L_1$ 中的唯一前驱是 $c$。$N(g) = N(c) = 1$。\n\n- **层 $L_3 = \\{h, i, j\\}$**：\n  - 对于 $h$：在 $L_2$ 中的前驱是 $d$ 和 $e$。$N(h) = N(d) + N(e) = 1 + 2 = 3$。\n  - 对于 $i$：在 $L_2$ 中的前驱是 $e$ 和 $f$。$N(i) = N(e) + N(f) = 2 + 2 = 4$。\n  - 对于 $j$：在 $L_2$ 中的前驱是 $f$ 和 $g$。$N(j) = N(f) + N(g) = 2 + 1 = 3$。\n\n- **层 $L_4 = \\{k, l\\}$**：\n  - 对于 $k$：在 $L_3$ 中的前驱是 $h$ 和 $i$。$N(k) = N(h) + N(i) = 3 + 4 = 7$。\n  - 对于 $l$：在 $L_3$ 中的前驱是 $i$ 和 $j$。$N(l) = N(i) + N(j) = 4 + 3 = 7$。\n\n- **层 $L_5 = \\{m, n\\}$**：\n  - 对于 $m$：在 $L_4$ 中的前驱是 $k$ 和 $l$。$N(m) = N(k) + N(l) = 7 + 7 = 14$。\n  - 对于 $n$：在 $L_4$ 中的唯一前驱是 $l$。$N(n) = N(l) = 7$。\n\n- **层 $L_6 = \\{t\\}$**：\n  - 对于 $t$：在 $L_5$ 中的前驱是 $m$ 和 $n$。\n  $$N(t) = N(m) + N(n) = 14 + 7 = 21$$\n\n从 $s$ 到 $t$ 的不同最短路径总数为 21。", "answer": "$$\\boxed{21}$$", "id": "3218407"}]}