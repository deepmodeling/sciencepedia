{"hands_on_practices": [{"introduction": "要真正理解最小生成树（MST）为何“最小”，一个有效方法是探究其稳定性。该练习 [@problem_id:3253184] 挑战你计算一个已在MST中的边的权重最多能增加多少而不改变其最优性。通过找到这个临界值，你将具体地应用**切割性质** (cut property)，并理解它如何保证一条边在MST中的地位。", "problem": "考虑一个连通的、无向的、带权图 $G=(V,E)$，其顶点集为 $V=\\{1,2,3,4,5,6\\}$。边权重由函数 $w:E\\to\\mathbb{R}_{\\ge 0}$ 在以下边上给出：\n- $w(\\{1,2\\})=2$, $w(\\{2,3\\})=3$, $w(\\{3,4\\})=4$, $w(\\{4,5\\})=5$, $w(\\{5,6\\})=6$,\n- $w(\\{1,3\\})=7$, $w(\\{2,4\\})=8$, $w(\\{3,5\\})=9$, $w(\\{4,6\\})=10$, $w(\\{1,4\\})=11$, $w(\\{2,5\\})=12$, $w(\\{3,6\\})=13$。\n\n设 $T$ 是由边 $\\{\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{4,5\\},\\{5,6\\}\\}$ 构成的最小生成树 (MST)。设 $e=\\{3,4\\}\\in T$ 是树边，其权重为 $w(e)=4$。\n\n仅从生成树的核心定义以及最小生成树的切割-环路性质出发，确定最大的实数 $\\Delta\\ge 0$，使得将边 $e$ 的权重增加到 $w(e)+\\Delta$ 后，$T$ 仍然是 $G$ 的一个最小生成树。将您的最终答案表示为单个实数。无需四舍五入。", "solution": "用户提供了一个关于最小生成树 (MST) 在边权重变化下的稳定性的问题。\n\n首先，确定问题陈述的有效性。\n**第1步：提取已知条件**\n-   图 $G=(V,E)$ 是连通的、无向的、带权的。\n-   顶点集 $V=\\{1,2,3,4,5,6\\}$。\n-   边权重 $w:E\\to\\mathbb{R}_{\\ge 0}$ 在以下边上给出：\n    -   $w(\\{1,2\\})=2$\n    -   $w(\\{2,3\\})=3$\n    -   $w(\\{3,4\\})=4$\n    -   $w(\\{4,5\\})=5$\n    -   $w(\\{5,6\\})=6$\n    -   $w(\\{1,3\\})=7$\n    -   $w(\\{2,4\\})=8$\n    -   $w(\\{3,5\\})=9$\n    -   $w(\\{4,6\\})=10$\n    -   $w(\\{1,4\\})=11$\n    -   $w(\\{2,5\\})=12$\n    -   $w(\\{3,6\\})=13$\n-   $T$ 是由边集 $\\{\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{4,5\\},\\{5,6\\}\\}$ 定义的最小生成树 (MST)。\n-   要修改的特定边是 $e=\\{3,4\\}\\in T$，其原始权重为 $w(e)=4$。\n-   边 $e$ 的权重增加到 $w'(e) = w(e)+\\Delta = 4+\\Delta$，其中 $\\Delta\\ge 0$。\n-   任务是找到最大的实数 $\\Delta$，使得 $T$ 仍然是一个最小生成树。\n\n**第2步：使用提取的已知条件进行验证**\n该问题在图论和算法领域内是良定义的。所有术语都是标准的，提供的数据是自洽且一致的。给定树 $T$ 是原始权重下的一个最小生成树这一前提是正确的；$T$ 中的边是整个图中权重最低的五条边（$2, 3, 4, 5, 6$），并且它们构成了一个生成树而没有形成任何环。该问题具有科学依据，是良构的且客观的。它没有表现出验证标准中列出的任何缺陷。\n\n**第3步：结论和行动**\n问题有效。将提供一个有理有据的解决方案。\n\n**求解推导**\n解决方案依赖于最小生成树的**切割性质**。切割性质指出，对于图的顶点 $V$ 的任意一个划分为两个不相交集合 $S$ 和 $V \\setminus S$（一个切分），如果最小生成树 $T$ 的一条边 $e$ 的端点分别在 $S$ 和 $V \\setminus S$ 中（即 $e$ 跨越该切分），那么 $e$ 必须是该切分的一条轻量级边，意味着它的权重在所有跨越该切分的边中是最小的。\n\n设 $e=\\{3,4\\}$ 是给定的最小生成树 $T$ 中权重将被增加的边。根据问题陈述，原始的最小生成树是 $T = \\{\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{4,5\\},\\{5,6\\}\\}$。\n\n从 $T$ 中移除边 $e=\\{3,4\\}$ 会将树分成两个连通分量，从而将顶点集 $V$ 划分为两个不相交的集合 $S_1$ 和 $S_2$。这定义了一个特定的切分 $(S_1, S_2)$。\n-   第一个分量是 $T$ 的子图，包含顶点 $3$以及在 $T \\setminus \\{e\\}$ 中与其相连的所有顶点。该分量由路径 $1-2-3$ 组成。相应的顶点集是 $S_1 = \\{1, 2, 3\\}$。\n-   第二个分量是包含顶点 $4$ 以及在 $T \\setminus \\{e\\}$ 中与其相连的所有顶点的子图。该分量由路径 $4-5-6$ 组成。相应的顶点集是 $S_2 = \\{4, 5, 6\\}$。\n\n原始图 $G$ 中所有跨越切分 $(S_1, S_2)$ 的边是那些一个端点在 $S_1$ 中，另一个端点在 $S_2$ 中的边。我们从给定的列表中找出这些边及其权重：\n-   $S_1=\\{1,2,3\\}$ 和 $S_2=\\{4,5,6\\}$ 之间的边：\n-   $w(\\{1,4\\})=11$\n-   $w(\\{2,4\\})=8$\n-   $w(\\{3,4\\})=4$（这是我们的边 $e$）\n-   $w(\\{1,3\\})=7$（不跨越该切分）\n-   $w(\\{2,5\\})=12$\n-   $w(\\{3,5\\})=9$\n-   $w(\\{4,6\\})=10$（不跨越该切分）\n-   $w(\\{3,6\\})=13$\n-   初始列表中的其他边，$\\{1,2\\}, \\{2,3\\}, \\{4,5\\}, \\{5,6\\}$，不跨越该切分。\n\n跨越切分 $(S_1, S_2)$ 的边集是 $C(S_1,S_2) = \\{\\{3,4\\}, \\{2,4\\}, \\{3,5\\}, \\{1,4\\}, \\{2,5\\}, \\{3,6\\}\\}$。\n这些边的权重是 $\\{4, 8, 9, 11, 12, 13\\}$。根据切割性质的要求，权重为 $4$ 的边 $\\{3,4\\}$ 确实是这个集合中权重最小的边。\n\n现在，边 $e=\\{3,4\\}$ 的权重增加到一个新值，$w'(e) = w(e) + \\Delta = 4 + \\Delta$。为了使树 $T$ 在修改后的图中*仍然*是一个最小生成树，边 $e$ 及其新权重 $w'(e)$ 必须仍然满足对于切分 $(S_1, S_2)$ 的切割性质。这意味着 $w'(e)$ 必须小于或等于跨越该切分的任何*其他*边的权重。\n\n这个条件可以表示为：\n对于所有 $f \\in C(S_1,S_2) \\setminus \\{e\\}$，$w'(e) \\le w(f)$。\n\n这等价于要求 $w'(e)$ 小于或等于切分集中所有其他边的最小权重。让我们找出这个最小权重：\n$$ \\min \\{ w(\\{2,4\\}), w(\\{3,5\\}), w(\\{1,4\\}), w(\\{2,5\\}), w(\\{3,6\\}) \\} $$\n$$ = \\min \\{8, 9, 11, 12, 13\\} = 8 $$\n在“竞争者”边中，最小权重是 $8$，对应于边 $\\{2,4\\}$。\n\n因此，$T$ 保持为最小生成树的条件是：\n$$ 4 + \\Delta \\le 8 $$\n求解 $\\Delta$，我们得到：\n$$ \\Delta \\le 8 - 4 $$\n$$ \\Delta \\le 4 $$\n满足此不等式的最大实数 $\\Delta \\ge 0$ 是 $\\Delta = 4$。如果 $\\Delta  4$，边 $\\{2,4\\}$ 的权重将严格小于 $\\{3,4\\}$，根据切割性质，$\\{3,4\\}$ 不可能存在于任何最小生成树中，因为存在一条更便宜的边来连接集合 $S_1$ 和 $S_2$。如果 $\\Delta = 4$，边 $\\{3,4\\}$ 的权重变为 $8$，与边 $\\{2,4\\}$ 的权重相等。在这种情况下，$\\{3,4\\}$ 仍然是该切分的一条轻量级边，因此存在包含它的最小生成树。所以，$T$ 仍然是一个最小生成树。\n\n$\\Delta$ 的最大值为 $4$。", "answer": "$$\\boxed{4}$$", "id": "3253184"}, {"introduction": "在探究了MST内部边的稳定性之后，让我们来思考一个相反的问题：一条不属于树的边在何种条件下才能被纳入其中？本练习 [@problem_id:3253209] 要求你找出一个非树边的权重阈值，一旦其权重低于该值，它就会被选入MST。这个过程是**环路性质** (cycle property) 的直接应用，你需要识别新边形成的环路，并确定必须移除哪条现有边。", "problem": "考虑一个连通的无向加权图 $G = (V, E)$，其中 $V = \\{1, 2, 3, 4, 5, 6, 7, 8\\}$。该图 $G$ 有一个指定的最小生成树 (MST) $T$，其中 $T$ 由以下 7 条边及其权重组成：权重为 $1$ 的边 $(1,2)$、权重为 $3$ 的边 $(2,3)$、权重为 $2$ 的边 $(3,4)$、权重为 $6$ 的边 $(4,5)$、权重为 $4$ 的边 $(5,6)$、权重为 $5$ 的边 $(6,7)$，以及权重为 $7$ 的边 $(7,8)$。除了 $T$ 中的边之外，该图还包含非树边：权重为 $8$ 的边 $(1,3)$、权重为 $9$ 的边 $(2,5)$、权重为 $10$ 的边 $(4,6)$、权重为 $11$ 的边 $(1,8)$，以及一条特殊的非树边 $e = (2,7)$，其当前权重为 $w = 9$。假设所有权重均为非负，并且 $T$ 是 $G$ 的一个最小生成树 (MST)。\n\n你可以只连续减小非树边 $e = (2,7)$ 的权重 $w$，同时保持所有其他边的权重不变。仅使用最小生成树 (MST) 的基本定义、加权图的切割性质和环路性质，确定精确的阈值 $w^{\\star}$，使得对于任何满足 $w  w^{\\star}$ 的 $w$，在通过适当替换一条树边以维持生成树结构后，边 $e$ 必须出现在 $G$ 的某个 MST 中。在你的推导过程中，请指明当 $w$ 降至 $w^{\\star}$ 以下时，$T$ 中的哪条特定边被替换，并从基本原理出发解释发生这种情况的原因。\n\n你的最终答案应该是 $w^{\\star}$ 的单个数值。不需要四舍五入。", "solution": "问题要求非树边 $e = (2,7)$ 的一个阈值权重 $w^{\\star}$，使得对于任何权重 $w  w^{\\star}$，边 $e$ 必须被包含在图 $G$ 的某个最小生成树 (MST) 中。推导过程必须基于 MST 的基本原理，即切割性质和环路性质。\n\n首先，必须验证问题陈述以确保其自洽、一致和科学上合理。\n已知条件如下：\n- 一个连通的无向加权图 $G = (V, E)$。\n- 顶点集 $V = \\{1, 2, 3, 4, 5, 6, 7, 8\\}$。\n- 一个初始 MST $T$，由以下边组成：$(1,2)$ 权重 $1$；$(2,3)$ 权重 $3$；$(3,4)$ 权重 $2$；$(4,5)$ 权重 $6$；$(5,6)$ 权重 $4$；$(6,7)$ 权重 $5$；$(7,8)$ 权重 $7$。\n- 一组非树边：$(1,3)$ 权重 $8$；$(2,5)$ 权重 $9$；$(4,6)$ 权重 $10$；$(1,8)$ 权重 $11$；以及初始权重为 $w=9$ 的边 $e=(2,7)$。\n- 边 $e=(2,7)$ 的权重 $w$ 可以连续减小。\n\n问题的有效性建立在这样一个前提之上：对于初始的权重集，$T$ 确实是一个 MST。这可以通过 MST 的环路性质来验证，该性质指出，对于任何非树边，其权重必须大于或等于连接其端点的 MST 中唯一路径上的任何边的权重。\n- 对于边 $(1,3)$，权重为 $8$：在 $T$ 中的路径是 $1-2-3$。路径上的最大权重是 $\\max(1, 3) = 3$。$8 \\ge 3$。\n- 对于边 $(2,5)$，权重为 $9$：在 $T$ 中的路径是 $2-3-4-5$。路径上的最大权重是 $\\max(3, 2, 6) = 6$。$9 \\ge 6$。\n- 对于边 $(4,6)$，权重为 $10$：在 $T$ 中的路径是 $4-5-6$。路径上的最大权重是 $\\max(6, 4) = 6$。$10 \\ge 6$。\n- 对于边 $(1,8)$，权重为 $11$：在 $T$ 中的路径是 $1-2-3-4-5-6-7-8$。路径上的最大权重是 $\\max(1, 3, 2, 6, 4, 5, 7) = 7$。$11 \\ge 7$。\n- 对于边 $e=(2,7)$，初始权重 $w=9$：在 $T$ 中的路径是 $2-3-4-5-6-7$。路径上的最大权重是 $\\max(3, 2, 6, 4, 5) = 6$。$9 \\ge 6$。\n由于该条件对所有非树边都成立，因此给定的树 $T$ 是一个有效的 MST。该问题是适定且科学合理的。\n\n我们关心的是，在什么条件下，权重可变的非树边 $e = (2,7)$ 会成为 MST 的一部分。这将由环路性质决定。将边 $e = (2,7)$ 添加到 MST $T$ 中会形成一个唯一的环。我们来确定这个环，记为 $C$。在 $T$ 中连接顶点 2 和 7 的路径是 $P_{2,7} = (2-3-4-5-6-7)$。环 $C$ 由这条路径和边 $e=(2,7)$ 组成。\n路径 $P_{2,7}$ 上的边及其权重如下：\n- $(2,3)$：权重 $3$\n- $(3,4)$：权重 $2$\n- $(4,5)$：权重 $6$\n- $(5,6)$：权重 $4$\n- $(6,7)$：权重 $5$\n\n环 $C$ 由这五条边以及权重为 $w$ 的边 $e=(2,7)$ 组成。\n根据环路性质，一个生成树要成为 MST，它不能包含任何环中唯一的权重最大的边。如果我们考虑环 $C$，并且如果边 $e=(2,7)$ 的权重 $w$ 严格小于 $C$ 中某条其他边的权重，我们就可以通过添加 $e$ 并移除那条更重的边，来形成一个总权重更小的新生成树。\n\n我们来找出路径 $P_{2,7}$ 上权重最大的边。这些权重是 $\\{3, 2, 6, 4, 5\\}$。最大权重是 $6$，对应于边 $(4,5)$。我们将这条边称为 $e_{max}$。所以，$e_{max} = (4,5)$ 且其权重为 $w(e_{max})=6$。\n\n$w$ 的阈值通过与 $w(e_{max})$ 进行比较来确定。\n- 如果 $w  w(e_{max}) = 6$，那么边 $e$ 比 $e_{max}$ 更重。环 $C$ 中权重最高的边要么是 $e$，要么是另一条比 $e$ 更重的边（如果存在的话）。在任何情况下，$e$ 都不是严格意义上可以替换环中更重边的最轻边，因此 $T$ 仍然是一个 MST。\n- 如果 $w = w(e_{max}) = 6$，我们可以形成一个新的生成树 $T' = (T \\setminus \\{e_{max}\\}) \\cup \\{e\\}$。$T'$ 的总权重为 $W(T') = W(T) - w(e_{max}) + w = W(T) - 6 + 6 = W(T)$。在这种情况下，$T'$ 也是一个 MST，并且边 $e$ 出现在*某个* MST 中（即 $T'$）。\n- 如果 $w  w(e_{max}) = 6$，新树 $T'$ 的总权重为 $W(T') = W(T) - 6 + w  W(T)$。这意味着原始的树 $T$ 不再是 MST，因为存在一个总权重严格更小的生成树。\n\n为了证明当 $w  6$ 时，边 $e$ **必须**出现在 MST 中，我们使用切割性质。切割性质指出，对于任何切割（将顶点集 $V$ 划分为两个不相交的集合），如果一条边的权重严格小于任何其他跨越该切割的边的权重，那么它必须属于每一个 MST。\n\n我们基于边 $e_{max} = (4,5)$ 来定义一个切割。从 $T$ 中移除这条边会将图的顶点划分为两个不相交的集合。这两个集合是 $S_1 = \\{1, 2, 3, 4\\}$ 和 $S_2 = \\{5, 6, 7, 8\\}$。\n原始图 $G$ 中跨越这个切割（即连接 $S_1$ 中的一个顶点与 $S_2$ 中的一个顶点）的边集是：\n- $(4,5)$：权重 $6$\n- $(2,5)$：权重 $9$\n- $(4,6)$：权重 $10$\n- $(1,8)$：权重 $11$\n- $e=(2,7)$：权重 $w$\n\n如果我们减小 $e$ 的权重使得 $w  6$，那么 $e=(2,7)$ 就成为跨越切割 $(S_1, S_2)$ 的唯一权重最小的边。它的权重 $w$ 严格小于任何其他跨越该切割的边的权重，这些边的权重为 $\\{6, 9, 10, 11\\}$。\n根据切割性质，由于 $e=(2,7)$ 是跨越该切割的唯一最轻边，对于任何 $w  6$，它都必须被包含在图的*每一个* MST 中。\n\n问题要求的是阈值 $w^{\\star}$，使得对于任何 $w  w^{\\star}$，边 $e$ 必须出现在某个 MST 中。我们的分析表明，对于 $w  6$，$e$ 必须出现在*每一个* MST 中，这是一个更强的条件，并且满足了题目的要求。阈值就是这种行为发生改变的值。当 $w=6$ 时，边 $e$ 与边 $(4,5)$ 的权重相同，因此它不再是跨越该切割的*唯一*最轻边。因此，可以使用 $(4,5)$ 或 $(2,7)$ 来构成 MST。当 $w > 6$ 时，$(4,5)$ 是严格更轻的边，将会被优先选择。\n\n因此，阈值是 $w^{\\star} = 6$。当 $w$ 降至此值以下时，边 $e = (2,7)$ 会被并入 MST，并且为了保持树的结构，必须从环 $C$ 中移除一条边。被移除的边是路径 $P_{2,7}$ 上最重的边，即边 $(4,5)$。\n\n因此，阈值为 $w^{\\star}=6$。对于任何 $w  6$，边 $(2,7)$ 都将存在于每一个 MST 中，并替换边 $(4,5)$。", "answer": "$$\\boxed{6}$$", "id": "3253209"}, {"introduction": "掌握了单边替换的原理后，我们现在可以应对更复杂的算法挑战。这个实践任务 [@problem_id:3253223] 要求你设计一个算法，找出图的“次优”最小生成树，即总权重严格大于MST权重的最小权重生成树。解决这个问题需要你系统地应用环路性质，评估所有可能的单边替换，从而将理论知识与实际的算法设计联系起来。", "problem": "给定一个连通的、无向的、带权图 $G = (V, E)$，其中有 $|V| = n$ 个顶点（编号从 $0$ 到 $n-1$）和 $|E| = m$ 条边，设计一个算法来计算“次优”最小生成树（MST）的权重。次优最小生成树定义为所有总权重严格大于最小生成树权重的生成树中，总权重最小的那一个。如果没有总权重严格大于最小生成树权重的生成树，则算法应返回 $-1$。所有边的权重都是非负整数。该算法必须从第一性原理出发，使用图论的基本定义和经过验证的事实，特别是生成树的切割属性和环属性。\n\n您必须使用的基本原理包括：\n- 图中生成树、环和切割的定义。\n- 最小生成树（MST）的定义，即总边权最小的生成树。\n- 切割属性：对于图中的任意切割，跨越该切割的最轻的边总是包含在某个最小生成树中。\n- 环属性：对于图中的任意环，该环上最重的边不包含在任何最小生成树中。\n\n您的程序必须实现一个算法，该算法：\n- 计算 $G$ 的一个最小生成树（您可以不加证明地假设，像 Kruskal 这样的算法在正确应用时能产生一个有效的最小生成树）。\n- 通过逻辑推理，分析使用非树边替换最小生成树中的边如何影响总权重，从而确定次优最小生成树的权重。此过程依赖于切割属性和环属性，而非快捷公式。\n\n输入作为图的测试套件嵌入在程序中。对于每个图，输出必须是一个整数：次优最小生成树的权重，或者如果没有总权重严格大于最小生成树的生成树，则为 $-1$。不涉及物理单位或角度。\n\n测试套件：\n- 测试用例 1（具有唯一最小生成树的通用连通图）：\n  - $n = 6$\n  - $E = \\{(0,1,4), (0,2,3), (1,2,1), (1,3,2), (2,3,4), (3,4,2), (4,5,6), (3,5,5), (2,5,7), (0,5,10)\\}$\n- 测试用例 2（具有多个等权重最小生成树的图，要求次优树的权重严格增加）：\n  - $n = 4$\n  - $E = \\{(0,1,1), (1,2,1), (2,3,1), (3,0,1), (0,2,2), (1,3,2)\\}$\n- 测试用例 3（次优最小生成树与最小生成树仅相差一次单边替换的小图）：\n  - $n = 3$\n  - $E = \\{(0,1,1), (1,2,1), (0,2,2)\\}$\n- 测试用例 4（所有生成树总权重相同的图，因此不存在权重严格更大的生成树）：\n  - $n = 3$\n  - $E = \\{(0,1,5), (1,2,5), (0,2,5)\\}$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试用例的结果，格式为方括号括起来的逗号分隔列表，例如 $[a,b,c,d]$，其中 $a$、$b$、$c$ 和 $d$ 是与上述测试用例按顺序对应的整数。\n\n您的实现必须是自包含的，并为给定的测试套件产生确定性的结果。所有测试用例的答案都是整数。不需要百分比或角度单位。", "solution": "此问题已经过验证，被认为是有效的。这是一个图算法领域中定义明确的问题，基于成熟的图论原理。问题陈述自成体系、前后一致，没有任何科学或逻辑上的缺陷。我现在将提供一个正式的解决方案。\n\n该问题要求计算给定连通、无向、带权图 $G = (V, E)$ 的次优最小生成树的权重。次优生成树定义为总权重严格大于最小生成树（MST）权重的所有生成树中，总权重最小的那一个。设最小生成树的权重为 $W_{MST}$。我们要寻找 $\\min \\{ W(T) \\mid T \\text{ 是 } G \\text{ 的生成树且 } W(T)  W_{MST} \\}$。如果不存在这样的树，则结果为 $-1$。\n\n解决方案源于生成树的基本属性及其与环和切割的关系。一个关键的洞见是，任何一个生成树都可以通过一系列单边交换操作转换为任何另一个生成树。单边交换操作包括添加一条非树边，并从所形成的环中移除一条树边。\n\n设 $T_{MST}$ 是 $G$ 的一个最小生成树。任何其他生成树 $T'$ 必须包含至少一条不在 $T_{MST}$ 中的边。考虑一个与 $T_{MST}$ 仅相差一次单边交换的生成树 $T'$。这样的树是通过选择一条不在 $T_{MST}$ 中的边 $e_{in} = (u,v)$ 并将其加入 $T_{MST}$ 来形成的。将 $e_{in}$ 加入 $T_{MST}$ 会创建一个唯一的环 $C$。这个环 $C$ 由 $e_{in}$ 和 $T_{MST}$ 中连接顶点 $u$ 和 $v$ 的唯一路径 $P_{uv}$ 组成。为了恢复树的属性（即恰好有 $|V|-1 = n-1$ 条边且无环），必须从环 $C$ 中移除一条边 $e_{out}$。由于 $e_{in}$ 必须在新树中，所以 $e_{out}$ 必须是路径 $P_{uv}$ 上的一条边。最终得到的边集 $T' = (T_{MST} \\setminus \\{e_{out}\\}) \\cup \\{e_{in}\\}$ 是一个新的生成树。\n\n这个新生成树 $T'$ 的权重由 $W(T') = W(T_{MST}) - w(e_{out}) + w(e_{in})$ 给出。我们寻找的是满足 $W(T')  W(T_{MST})$ 的最小 $W(T')$，这等价于寻找最小的正权重差 $\\Delta W = w(e_{in}) - w(e_{out})$。\n\n最小生成树的环属性在此至关重要。它指出，对于图中的任何环，权重最大的边不能是任何最小生成树的一部分。对于我们的构造，一个直接的推论是，对于环 $C = P_{uv} \\cup \\{e_{in}\\}$，非最小生成树边 $e_{in}$ 的权重必须大于或等于路径 $P_{uv}$ 上任何边的权重。也就是说，对于所有 $e \\in P_{uv}$，都有 $w(e_{in}) \\ge w(e)$。如果路径 $P_{uv}$ 上存在一条边 $e'$ 使得 $w(e')  w(e_{in})$，那么我们可以通过构造树 $(T_{MST} \\setminus \\{e'\\}) \\cup \\{e_{in}\\}$ 得到一个比 $W_{MST}$ 更小的权重，这与 $T_{MST}$ 是最小生成树的定义相矛盾。因此，权重差 $\\Delta W = w(e_{in}) - w(e_{out})$ 总是非负的。\n\n为了找到次优最小生成树，我们旨在找到比 $W_{MST}$ 尽可能小的权重增量。这表明我们应该考虑所有能产生权重严格大于 $W_{MST}$ 的树的单边交换，并取其中的最小值。对于一个固定的入边 $e_{in}$，当 $w(e_{out})$ 最大化时，权重增量 $w(e_{in}) - w(e_{out})$ 被最小化。因此，对于每条非最小生成树边 $e_{in}$，我们应该选择移除 $T_{MST}$ 中路径 $P_{uv}$ 上最重的边 $e_{out}$。对于特定的 $e_{in}$ 选择，这给出了最佳的候选树。\n\n这导出了一个完整的算法：\n1. 计算图 $G$ 的一个最小生成树 $T_{MST}$ 及其总权重 $W_{MST}$。Kruskal 算法适用于此步骤。这个过程自然地将边集 $E$ 划分为最小生成树边和非最小生成树边。\n\n2. 初始化一个用于存储次优权重的变量 $W_{2nd}$，将其设为一个代表无穷大的值（例如 $\\infty$）。\n\n3. 对于每条不在 $T_{MST}$ 中的边 $e_{in} = (u, v)$（权重为 $w_{in}$）：\n    a. 在 $T_{MST}$ 中确定连接顶点 $u$ 和 $v$ 的唯一路径 $P_{uv}$。\n    b. 找到该路径 $P_{uv}$ 上权重最大的边 $e_{out}$，其权重为 $w_{out}$。这可以通过在树 $T_{MST}$ 上使用图遍历算法（如广度优先搜索 (BFS) 或深度优先搜索 (DFS)）来完成。\n    c. 计算此次交换形成的新生成树的权重：$W' = W_{MST} - w_{out} + w_{in}$。\n    d. 我们只对权重严格大于 $W_{MST}$ 的生成树感兴趣。因此，如果 $w_{in}  w_{out}$（这意味着 $W'  W_{MST}$），则 $W'$ 是次优最小生成树权重的一个有效候选值。我们更新目前找到的最小值：$W_{2nd} = \\min(W_{2nd}, W')$。当 $w_{in} = w_{out}$ 时，对应于找到另一个相同权重的最小生成树，这不是我们所寻求的。\n\n4. 遍历完所有非最小生成树边后，如果 $W_{2nd}$ 仍然是 $\\infty$，则意味着无法形成权重严格更大的生成树。在这种情况下，答案是 $-1$。否则，答案是 $W_{2nd}$。\n\n该算法保证能找到次优最小生成树。虽然我们只考虑了与某个特定最小生成树相差一次单边交换的树，但可以证明，真正的次优最小生成树必将出现在这些候选者中。任何生成树都可以通过一系列交换从任何其他生成树到达。从一个最小生成树到次优最小生成树的交换路径必须包含一个增加权重的初始步骤，而在所有可能的初始步骤中，这种最小的增量将确定次优最小生成树。\n\n在实现方面，Kruskal 算法可以使用不相交集并查集（DSU）数据结构来实现。对于每条非最小生成树边，为了找到其在最小生成树中对应路径上的最重边，从一个端点到另一个端点进行简单的遍历（如 BFS），并记录父指针以重建路径，对于给定的问题约束是足够的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the weight of the second-best MST for a series of test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        (6, [(0,1,4), (0,2,3), (1,2,1), (1,3,2), (2,3,4), (3,4,2), (4,5,6), (3,5,5), (2,5,7), (0,5,10)]),\n        # Test case 2\n        (4, [(0,1,1), (1,2,1), (2,3,1), (3,0,1), (0,2,2), (1,3,2)]),\n        # Test case 3\n        (3, [(0,1,1), (1,2,1), (0,2,2)]),\n        # Test case 4\n        (3, [(0,1,5), (1,2,5), (0,2,5)]),\n    ]\n\n    results = []\n\n    for n, edges in test_cases:\n        # Step 1: Find an MST using Kruskal's algorithm\n        # A Disjoint Set Union (DSU) data structure for tracking connected components.\n        parent = list(range(n))\n        def find_set(v):\n            if v == parent[v]:\n                return v\n            parent[v] = find_set(parent[v])\n            return parent[v]\n\n        def union_sets(a, b):\n            a = find_set(a)\n            b = find_set(b)\n            if a != b:\n                parent[b] = a\n                return True\n            return False\n\n        # Sort edges by weight\n        edges.sort(key=lambda item: item[2])\n\n        mst_weight = 0\n        mst_edges = []\n        non_mst_edges = []\n\n        for u, v, w in edges:\n            if union_sets(u, v):\n                mst_weight += w\n                mst_edges.append((u, v, w))\n            else:\n                non_mst_edges.append((u, v, w))\n\n        # Check if graph was connected (MST should have n-1 edges)\n        # This is guaranteed by the problem statement, but good practice.\n        if len(mst_edges) != n - 1 and n > 0:\n            # This case corresponds to a disconnected graph.\n            # The problem assumes connected graphs.\n            # Handle as per problem spec for no second-best MST.\n             results.append(-1)\n             continue\n\n        # Step 2: Build adjacency list for the MST for traversal\n        mst_adj = [[] for _ in range(n)]\n        for u, v, w in mst_edges:\n            mst_adj[u].append((v, w))\n            mst_adj[v].append((u, w))\n\n        # Step 3: Iterate through non-MST edges to find the second-best MST weight\n        second_best_weight = float('inf')\n\n        for u_in, v_in, w_in in non_mst_edges:\n            # Find the heaviest edge on the path between u_in and v_in in the MST\n            # We can use BFS to find the path and track max edge weight.\n            # Using parent tracking in BFS is efficient.\n            parent_map = {u_in: (None, 0)} # node -> (parent, weight_to_parent)\n            queue = [u_in]\n            \n            head = 0\n            path_found = False\n            while head  len(queue):\n                curr = queue[head]\n                head += 1\n                if curr == v_in:\n                    path_found = True\n                    break\n                for neighbor, weight in mst_adj[curr]:\n                    if neighbor not in parent_map:\n                        parent_map[neighbor] = (curr, weight)\n                        queue.append(neighbor)\n            \n            if not path_found: continue\n\n            max_weight_on_path = 0\n            curr_node = v_in\n            while curr_node != u_in and curr_node is not None:\n                p_node, p_weight = parent_map[curr_node]\n                if p_weight > max_weight_on_path:\n                    max_weight_on_path = p_weight\n                curr_node = p_node\n            \n            w_out = max_weight_on_path\n            \n            # We must have a strictly greater weight for the new tree\n            if w_in > w_out:\n                candidate_weight = mst_weight - w_out + w_in\n                if candidate_weight  second_best_weight:\n                    second_best_weight = candidate_weight\n\n        if second_best_weight == float('inf'):\n            results.append(-1)\n        else:\n            results.append(int(second_best_weight))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3253223"}]}