{"hands_on_practices": [{"introduction": "掌握并查集（DSU）的第一步是理解它如何高效地处理动态连通性问题。这个练习将带你通过一个直观的场景——在网格上模拟岛屿的形成——来实践DSU的核心操作。当你逐个将水域变为陆地时，你需要利用带路径压缩和按大小合并优化的DSU来实时追踪并计算岛屿的数量，这是对DSU基本功能最经典的演练。[@problem_id:3228210]", "problem": "你需要实现一个程序，该程序使用带有按大小合并和路径压缩启发式算法的不相交集合并查集（DSU）数据结构，来模拟网格中陆地连通分量的增量形成过程。目标是在每次添加陆地后，计算在$4$-邻域邻接条件下当前连通分量（“岛屿”）的数量。\n\n基本原理和定义：\n- 不相交集合并查集（DSU）维护一个有限全集的划分，使其成为不相交的集合，并支持两种操作：$find(x)$，返回包含元素$x$的集合的规范代表；以及$union(x,y)$，如果包含$x$和$y$的集合不同，则合并它们。\n- 在按大小合并中，合并两个集合时，将较小大小的根附加到较大大小的根上，确保树的高度增长缓慢。在路径压缩中，执行$find(x)$期间，路径上访问的每个节点都直接链接到根，从而扁平化结构以供未来查询。\n- 坐标为$(i,j)$的单元格的$4$-邻域包括$(i-1,j)$、$(i+1,j)$、$(i,j-1)$和$(i,j+1)$，且必须在有效的网格索引范围内。如果两个陆地单元格之间存在一条通过$4$-邻域步骤连接的陆地单元格路径，则它们是连通的。这在陆地单元格集合上引入了一个等价关系，每个等价类对应一个岛屿。\n\n任务：\n- 考虑一个$r \\times c$的网格，其中$r \\in \\mathbb{Z}_{\\ge 0}$和$c \\in \\mathbb{Z}_{\\ge 0}$，单元格通过从零开始的坐标$(i,j)$进行索引，其中$i \\in \\{0,\\dots,r-1\\}$和$j \\in \\{0,\\dots,c-1\\}$。最初，所有单元格都是水域。\n- 给定一个包含$k$个加法操作的有序列表$(p_1, p_2, \\dots, p_k)$，其中每个$p_t = (i_t, j_t)$指定在步骤$t$将行$i_t$和列$j_t$的单元格变为陆地。如果指定的单元格已经是陆地，则该步骤网格状态不发生改变。\n- 在每个步骤$t \\in \\{1,\\dots,k\\}$之后，计算在$4$-邻域连通性下存在的岛屿数量。\n\n要求：\n- 你必须实现带有按大小合并和路径压缩启发式算法的不相交集合并查集（DSU）。\n- 你的算法除了上述给出的基本DSU定义和连通性定义外，不能假定任何先验知识。\n- 程序不应读取输入。相反，它必须在内部运行以下参数值的测试套件（每个都指定为一个元组$(r,c,\\text{additions})$）：\n  - 测试用例 $1$：$(r,c) = (3,3)$，加法操作 $\\left[(0,0),(0,1),(1,2),(2,1),(1,1)\\right]$。\n  - 测试用例 $2$：$(r,c) = (1,1)$，加法操作 $\\left[(0,0),(0,0),(0,0)\\right]$。\n  - 测试用例 $3$：$(r,c) = (2,2)$，加法操作 $\\left[(0,0),(1,1),(0,1),(1,0)\\right]$。\n  - 测试用例 $4$：$(r,c) = (2,3)$，加法操作 $\\left[(0,0),(1,1),(0,2),(1,2)\\right]$。\n  - 测试用例 $5$：$(r,c) = (5,5)$，加法操作 $\\left[\\right]$ (空列表)。\n- 对于每个测试用例，你的程序必须生成一个长度为$k$的整数列表（对于空列表，长度可能为$0$），其中第$t$个整数是处理第$t$个加法操作后的岛屿数量。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个元素对应一个测试用例，并且本身是该测试用例的整数列表。例如，输出必须具有$\\left[\\text{case}_1,\\text{case}_2,\\dots,\\text{case}_m\\right]$的形式，其中每个$\\text{case}_i$是一个类似$\\left[a_1,a_2,\\dots,a_k\\right]$的列表。\n- 此问题不涉及物理单位。所有角度（如果有）都与此问题无关。", "solution": "该问题要求模拟网格中连通分量的动态形成过程。这是不相交集合并查集（DSU）数据结构（也称为联合-查找数据结构）的经典应用。问题的核心是在添加元素（网格单元）时维护和查询连通性信息。\n\n**1. 理论基础：动态连通性与等价关系**\n\n“岛屿”或陆地单元连通分量的概念基于等价关系。如果两个陆地单元之间存在一条由相邻陆地单元（在$4$-邻域邻接下）组成的路径连接它们，则它们属于同一个分量。DSU数据结构专门设计用于管理由这种等价关系导出的集合划分。\n\n作用于一个包含$N$个元素的全集上的DSU结构维护了一组不相交的集合。它主要支持两种操作：\n-   `find(x)`：确定包含元素$x$的集合的规范代表（或“根”）。\n-   `union(x,y)`：合并包含元素$x$和$y$的两个集合。\n\n为了在均摊基础上实现近乎恒定的时间复杂度，两个启发式算法至关重要：\n-   **按大小合并**：合并两个集合时，将较小集合（根据元素数量）的根作为较大集合根的子节点。这可以防止表示集合的树变得过深。\n-   **路径压缩**：在执行`find(x)`操作期间，从$x$到其根路径上的每个节点都成为根的直接子节点。这会扁平化树结构，极大地加速了该路径上元素的未来`find`操作。\n\n当同时使用这两种启发式算法时，对$N$个元素集合执行$m$次操作的时间复杂度为$O(m \\cdot \\alpha(N))$，其中$\\alpha(N)$是增长极其缓慢的反阿克曼函数。对于所有实际目的，$\\alpha(N)$是一个小常数（小于5）。\n\n**2. 算法模型**\n\n要将DSU数据结构应用于网格问题，我们必须将网格单元映射到DSU全集的元素上。\n\n-   **全域映射**：一个维度为$r \\times c$的网格包含$r \\cdot c$个单元。我们可以将坐标为$(i,j)$的每个单元格（其中$i \\in \\{0, \\dots, r-1\\}$，$j \\in \\{0, \\dots, c-1\\}$）映射到一个唯一的整数索引。一个标准的行主序映射由公式给出：$\\text{index} = i \\cdot c + j$。这将创建一个包含元素$\\{0, 1, \\dots, r \\cdot c - 1\\}$的全域。\n\n-   **状态表示**：我们需要管理每个单元格的状态（水域或陆地）和DSU数据。一个大小为$r \\cdot c$的`parent`数组用于DSU。我们可以使用一个哨兵值（例如$-1$）来表示一个单元格是水域。当索引为`idx`的单元格变为陆地时，我们初始化其DSU条目，例如，通过设置`parent[idx] = idx`。一个相同维度的`size`数组存储每个集合的大小，这仅在集合的根处有意义。\n\n-   **分量计数**：岛屿的数量恰好是陆地单元格不相交集合的数量。我们维护一个计数器`num_components`。\n    -   当一个水域单元格变为陆地时，它最初形成一个大小为$1$的新岛屿。因此，我们增加`num_components`。\n    -   当我们对属于不同集合的两个单元格执行`union`操作时，它们各自的岛屿会合并。这将岛屿总数减少一。因此，每次成功合并，我们都减少`num_components`。\n\n**3. 逐步算法**\n\n对于每个具有参数$(r, c, \\text{additions})$的测试用例：\n\n1.  **初始化**：\n    -   如果$r=0$或$c=0$，则网格中没有单元格。结果是一个空列表。\n    -   创建一个大小为$r \\cdot c$的`parent`数组，并将其所有元素初始化为$-1$以表示水域。\n    -   创建一个大小为$r \\cdot c$的`size`数组，初始化为$1$。\n    -   初始化`num_components`为$0$。\n    -   初始化一个空列表`results`来存储每一步后的岛屿数量。\n\n2.  **处理加法操作**：对`additions`列表中的每个坐标对$(i_t, j_t)$进行迭代，其中$t=1, \\dots, k$。\n    a.  计算一维索引：$\\text{idx}_t = i_t \\cdot c + j_t$。\n    b.  **检查是否已为陆地**：如果`parent[idx_t]`不为$-1$，则该单元格已是陆地。岛屿数量不变。将当前的`num_components`追加到`results`列表中，并继续下一个加法操作。\n    c.  **添加新陆地**：如果`parent[idx_t]`为$-1$：\n        i.  将该单元格初始化为一个新分量：设置`parent[idx_t] = idx_t`。\n        ii. 将`num_components`增加$1$。\n        iii. **检查邻居**：对于$(i_t, j_t)$的$4$个邻居$(n_i, n_j)$中的每一个：\n            -   验证邻居的坐标在网格边界内（$0 \\le n_i  r$且$0 \\le n_j  c$）。\n            -   计算邻居的索引：$\\text{n_idx} = n_i \\cdot c + n_j$。\n            -   如果邻居是陆地（即`parent[n_idx] != -1`），则对$\\text{idx}_t$和$\\text{n_idx}$执行`union`操作。\n            -   `union`操作涉及使用带路径压缩的`find`来找到两个元素的根。设根为`root1`和`root2`。\n            -   如果`root1 \\neq root2`，则发生合并。实现按大小合并：将较小的树附加到较大树的根上，并更新较大树根的大小。关键地，将`num_components`减少$1$。\n    d.  检查完所有邻居后，将当前步骤$t$的最终`num_components`值追加到`results`列表中。\n\n3.  **最终结果**：处理完所有加法操作后，`results`列表包含所需的岛屿数量序列。\n\n**4. 复杂度分析**\n\n-   **时间复杂度**：$O(k \\cdot \\alpha(r \\cdot c))$，其中$k$是加法操作的数量。每次加法操作涉及常数次DSU操作（一次初始化和最多四次`union`操作，每次`union`操作包含两次`find`调用）。\n-   **空间复杂度**：$O(r \\cdot c)$，用于存储DSU结构的`parent`和`size`数组。\n\n这种方法效率很高，并且正确地模拟了岛屿形成的动态过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation on the provided test suite.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (3, 3, [(0, 0), (0, 1), (1, 2), (2, 1), (1, 1)]),\n        (1, 1, [(0, 0), (0, 0), (0, 0)]),\n        (2, 2, [(0, 0), (1, 1), (0, 1), (1, 0)]),\n        (2, 3, [(0, 0), (1, 1), (0, 2), (1, 2)]),\n        (5, 5, []),\n    ]\n\n    all_results = []\n    for r, c, additions in test_cases:\n        result = _calculate_islands(r, c, additions)\n        all_results.append(result)\n\n    # Format the final output string as specified.\n    # Each case result, being a list, is converted to a string representation\n    # without spaces, e.g., \"[1,2,3]\".\n    # These strings are then joined by commas and enclosed in an outer bracket.\n    formatted_case_results = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output_string = f\"[{','.join(formatted_case_results)}]\"\n    \n    print(final_output_string)\n\n\ndef _calculate_islands(r, c, additions):\n    \"\"\"\n    Calculates the number of islands after each addition for a single test case.\n    \n    This function implements the Disjoint-Set Union (DSU) data structure with\n    path compression and union-by-size heuristics to solve the dynamic\n    connectivity problem.\n    \"\"\"\n    if r == 0 or c == 0:\n        return []\n\n    num_cells = r * c\n    # The `parent` array serves dual purposes:\n    # 1. For the DSU structure, parent[i] stores the parent of element i.\n    # 2. A value of -1 indicates the cell is water.\n    parent = np.full(num_cells, -1, dtype=int)\n    \n    # The `size` array stores the size of the set for each root element.\n    # It is initialized to 1s, as each new land cell starts as a set of size 1.\n    size = np.ones(num_cells, dtype=int)\n    \n    num_components = 0\n    results_for_case = []\n\n    # The `find` operation with path compression.\n    # It is defined as a nested function to have access to the `parent` array.\n    def find(i):\n        if parent[i] == i:\n            return i\n        # Path compression: set the parent of i directly to the root.\n        parent[i] = find(parent[i])\n        return parent[i]\n\n    for row, col in additions:\n        idx = row * c + col\n\n        # If the cell is already land, the number of components does not change.\n        if parent[idx] != -1:\n            results_for_case.append(num_components)\n            continue\n\n        # A new land cell is added, so it initially forms a new island.\n        parent[idx] = idx\n        num_components += 1\n        \n        # Check the 4-directional neighbors.\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            n_row, n_col = row + dr, col + dc\n\n            # Check if the neighbor is within a valid grid range.\n            if 0 = n_row  r and 0 = n_col  c:\n                n_idx = n_row * c + n_col\n                \n                # If the neighbor is also land, attempt to union the two components.\n                if parent[n_idx] != -1:\n                    root1 = find(idx)\n                    root2 = find(n_idx)\n                    \n                    if root1 != root2:\n                        # Union-by-size: attach the smaller tree to the root of the larger tree.\n                        if size[root1]  size[root2]:\n                            root1, root2 = root2, root1\n                        \n                        parent[root2] = root1\n                        size[root1] += size[root2]\n                        \n                        # Merging two components reduces the island count by one.\n                        num_components -= 1\n        \n        results_for_case.append(num_components)\n        \n    return results_for_case\n\nsolve()\n```", "id": "3228210"}, {"introduction": "在掌握了基本的连通性判断后，我们可以探索并查集的更强大功能：通过增强其节点信息来维护更复杂的图属性。这个练习要求你为一个DSU增加“奇偶性”或“颜色”的维度，以动态地判断一个图在加边过程中是否始终保持为二分图。通过解决这个问题，你将学会如何扩展DSU来检测奇数环，这是将DSU应用于更高级图论问题的关键一步。[@problem_id:3228343]", "problem": "要求您设计并实现一个增强型并查集 (DSU) 数据结构，用于在插入边的过程中动态地施加二着色约束，从而检测图在添加边的过程中是否保持为二分图。\n\n并查集 (DSU)，也称为联合-查找 (Union-Find)，在两种操作下维护一个集合划分为若干不相交的子集：查找和合并。查找操作定位包含给定元素的子集的代表元（根节点），而合并操作则将两个子集合并。当通过两种启发式优化——路径压缩和按大小或按秩合并——进行增强后，每次操作的均摊复杂度接近常数。\n\n基本原理：\n- 一个图是二分图，当且仅当其顶点可以被染成两种颜色，使得每条边都连接不同颜色的顶点。等价地，一个图是二分图，当且仅当它不包含奇数长度的环。\n- DSU 在加边操作下维护不相交的连通分量。为了在仅由加边组成的动态过程中使用 DSU 判断二分性，需要为每个节点增加一个奇偶校验位，用于存储从该节点到其当前 DSU 根节点路径长度的奇偶性（模 $2$）。这个奇偶性可以解释为该节点相对于根节点的颜色。\n- 两种 DSU 启发式优化是：\n  - 路径压缩：更新从节点到根节点路径上的所有父指针，使其直接指向根节点，从而扁平化 DSU 树。\n  - 按大小（或按秩）合并：将较小的树附加到较大树的根节点下，以保持树的浅度。\n\n您的任务：\n- 对于每个测试用例，您将获得一个顶点数 $n$ 和一个无向边列表 $(u, v)$，这些边将逐一添加到一个初始无边、顶点集为 $\\{1,2,\\dots,n\\}$ 的图中。\n- 您必须确定使图变为非二分图的最早的边索引 $i$（边序列使用基于 $1$ 的索引），并假设在插入第 $i$ 条边之前图是二分的。如果所有边插入后图仍然是二分图，则返回 $0$。\n\n精确定义与约束：\n- 设 $G = (V, E)$ 为一个简单无向图，但为了测试目的，输入中允许自环。一个自环 $(u, u)$ 会立即导致图变为非二分图。\n- 维护一个 DSU，使用数组为每个节点 $x$ 存储一个父指针和一个奇偶校验位 $p[x]$，$p[x]$ 等于在当前 DSU 森林中从 $x$ 到 $\\operatorname{root}(x)$ 的唯一路径长度的奇偶性（模 $2$）。在路径压缩下，更新 $p[x]$，使其在压缩后仍然表示从 $x$ 到新父节点的路径奇偶性。\n- 当插入一条边 $(u, v)$ 时：\n  - 如果 $\\operatorname{root}(u) \\ne \\operatorname{root}(v)$，则使用按大小合并来合并这两个集合，并设置被附加的根节点的奇偶性，以保留 $u$ 和 $v$ 颜色相反的奇偶性约束。\n  - 如果 $\\operatorname{root}(u) = \\operatorname{root}(v)$，则检查当前的奇偶性是否意味着 $u$ 和 $v$ 的颜色相反。如果不是，则检测到一个奇数长度的环，图在本次插入后变为非二分图。\n\n每个测试用例的所需输出：\n- 一个整数，等于最早导致冲突的边的索引 $i$（基于 $1$ 的索引），如果未发生冲突则为 $0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按测试用例顺序排列的结果，格式为用方括号括起来、不含空格的逗号分隔列表，例如：\"[x,y,z]\"。\n\n测试套件：\n- 对于下面的每个项目，$n$ 是顶点数，后面是按顺序添加的边序列。您必须为每个项目输出一个整数，如上所述。\n  - 测试用例 1：$n = 5$，边为 $[(1,2),(3,4),(2,3),(4,5)]$。\n  - 测试用例 2：$n = 4$，边为 $[(1,2),(2,3),(3,4),(4,1)]$。\n  - 测试用例 3：$n = 3$，边为 $[(1,2),(2,3),(1,3)]$。\n  - 测试用例 4：$n = 3$，边为 $[(1,1)]$。\n  - 测试用例 5：$n = 6$，边为 $[(1,2),(2,3),(3,1),(4,5),(5,6)]$。\n  - 测试用例 6：$n = 7$，边为 $[(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(1,7)]$。\n  - 测试用例 7：$n = 5$，边为 $[]$。\n\n您的程序必须是一个完整、可运行的实现，它需要构建所描述的带有按大小合并和路径压缩的 DSU，处理每个测试用例，并按照上述格式打印单行结果。程序不应读取任何用户输入；所有数据都应嵌入在程序中。", "solution": "该问题要求设计一个增强型并查集 (DSU) 数据结构，以确定在一系列向初始无边图插入边的操作中，第一条使图变为非二分图的边。\n\n一个图是二分图当且仅当它不包含奇数长度的环。任务是在添加边的过程中检测到第一个奇数长度环的形成。DSU 非常适合用于跟踪连通分量。增强操作涉及存储额外信息以检查奇数环条件。\n\n核心思想是维护图的各个连通分量的二着色。对于每个分量，我们可以为每个顶点分配一种颜色（例如，$0$ 或 $1$），使得相邻顶点颜色不同。这等价于维护一个分量中任意两个节点之间路径长度的奇偶性。我们在 DSU 结构中为每个节点 $x$ 增加一个值，我们称之为奇偶校验位，表示其相对于其分量根节点的颜色。\n\n设 $c(x)$ 为顶点 $x$ 的颜色，其中 $c(x) \\in \\{0, 1\\}$。对于任意边 $(u,v)$，必须满足 $c(u) \\neq c(v)$。这等价于 $(c(u) + c(v)) \\pmod 2 = 1$。在我们的 DSU 中，我们不存储绝对颜色，而是存储从一个节点到其在 DSU 树中父节点距离的奇偶性。设其为 $p[x]$。该值表示 $c(x) \\oplus c(\\text{parent}[x])$，其中 $\\oplus$ 是异或 (XOR) 操作，等价于模 $2$ 加法。\n\n为了效率，DSU 将通过路径压缩和按大小合并来实现。增强操作的逻辑如下：\n\n**状态表示：**\n对于一个有 $n$ 个顶点的图，我们使用三个大小为 $n+1$ 的数组，以适应基于 1 的顶点索引：\n- $\\text{parent}[i]$：存储节点 $i$ 的父节点。一个集合的根是一个节点 $r$，其中 $\\text{parent}[r] = r$。\n- $\\text{size}[i]$：如果 $i$ 是一个根节点，则存储该集合中的元素数量。\n- $\\text{parity}[i]$：存储从节点 $i$ 到其父节点路径长度的奇偶性，即 $c(i) \\oplus c(\\text{parent}[i])$。\n\n**初始化：**\n对于每个顶点 $i \\in \\{1, \\dots, n\\}$：\n- $\\text{parent}[i] = i$。\n- $\\text{size}[i] = 1$。\n- $\\text{parity}[i] = 0$，因为一个节点到自身的距离为 $0$。\n\n**带路径压缩的查找操作：**\n`find(i)` 操作返回包含 $i$ 的分量的根节点，以及从 $i$ 到这个根节点路径长度的奇偶性。这个路径奇偶性是 $c(i) \\oplus c(\\text{root}(i))$。\n\n我们定义 `find(i)` 返回一个对 $(\\text{root}, d)$，其中 $d = c(i) \\oplus c(\\text{root})$。\n如果 $i$ 是一个根节点（$\\text{parent}[i] = i$），那么路径长度为 $0$，所以我们返回 $(i, 0)$。\n否则，我们对其父节点递归调用 `find`：$(\\text{root}, d_{\\text{parent}}) = \\text{find}(\\text{parent}[i])$。\n这里，$d_{\\text{parent}} = c(\\text{parent}[i]) \\oplus c(\\text{root})$。\n从 $i$ 到根节点的总路径奇偶性是：\n$$d = (c(i) \\oplus c(\\text{parent}[i])) \\oplus (c(\\text{parent}[i]) \\oplus c(\\text{root})) = \\text{parity}[i] \\oplus d_{\\text{parent}}$$\n在路径压缩期间，我们设置 $\\text{parent}[i] = \\text{root}$。值 $\\text{parity}[i]$ 必须更新以反映这种新的父子关系。新的 $\\text{parity}[i]$ 变为我们刚刚计算出的总路径奇偶性 $d$。\n\n**合并操作与二分性检查：**\n当考虑添加一条边 $(u, v)$ 时：\n1. 首先，我们找到 $u$ 和 $v$ 的根节点和路径奇偶性：\n   - $(\\text{root}_u, d_u) = \\text{find}(u)$\n   - $(\\text{root}_v, d_v) = \\text{find}(v)$\n   其中 $d_u = c(u) \\oplus c(\\text{root}_u)$ 且 $d_v = c(v) \\oplus c(\\text{root}_v)$。\n\n2. 如果 $\\text{root}_u = \\text{root}_v$，顶点 $u$ 和 $v$ 已经处于同一个连通分量中。添加边 $(u, v)$ 会创建一个环。图保持二分性当且仅当这个新环的长度为偶数。这意味着在分量内部 $u$ 和 $v$ 之间的路径长度必须为奇数。\n   $u$ 和 $v$ 相对于其共同根节点的颜色由它们的路径奇偶性给出。\n   $c(u) = c(\\text{root}_u) \\oplus d_u$\n   $c(v) = c(\\text{root}_u) \\oplus d_v$\n   二分性的条件是 $c(u) \\neq c(v)$，这意味着 $c(\\text{root}_u) \\oplus d_u \\neq c(\\text{root}_u) \\oplus d_v$，简化为 $d_u \\neq d_v$。如果我们发现 $d_u = d_v$，则形成了一个奇数环，图变为非二分图。这是一个冲突。\n\n3. 如果 $\\text{root}_u \\neq \\text{root}_v$，顶点位于不同的分量中。添加边 $(u, v)$ 会合并这些分量。图仍然是二分图。我们执行一次合并操作（按大小），并更新奇偶性信息。\n   假设我们将 $\\text{root}_v$ 的树附加到 $\\text{root}_u$ 的树上，使得 $\\text{parent}[\\text{root}_v] = \\text{root}_u$。我们必须定义新的 $\\text{parity}[\\text{root}_v]$，即 $c(\\text{root}_v) \\oplus c(\\text{root}_u)$。\n   边的约束 $c(u) \\neq c(v)$ 必须成立。代入 `find` 操作的关系：\n   $c(\\text{root}_u) \\oplus d_u \\neq c(\\text{root}_v) \\oplus d_v$\n   利用异或的性质重新排列得到：\n   $c(\\text{root}_u) \\oplus c(\\text{root}_v) \\neq d_u \\oplus d_v$\n   左边正是我们需要为 $\\text{parity}[\\text{root}_v]$ 设置的量。为了使不等式成立，我们必须设置 $\\text{parity}[\\text{root}_v] = d_u \\oplus d_v \\oplus 1$。在模 $2$ 算术中，这等于 $(d_u + d_v + 1) \\pmod 2$。\n\n通过按顺序对每条边应用此逻辑，我们可以找到引入冲突的第一条边的索引。如果在处理完所有边后没有出现冲突，则图保持二分性，答案为 $0$。一个自环 $(u, u)$ 也能被此逻辑正确处理：`find(u)` 被调用两次，返回相同的根和奇偶性，由于 $d_u=d_u$，立即导致冲突。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass DSU:\n    \"\"\"\n    An augmented Disjoint-Set Union (DSU) data structure.\n    It supports union by size, path compression, and tracks parity\n    to check for bipartiteness in a dynamic graph.\n    \"\"\"\n    def __init__(self, n):\n        # Vertices are 1-indexed, so we use size n+1\n        self.parent = list(range(n + 1))\n        # self.parity[i] stores the parity of the distance from i to its parent.\n        # This represents color(i) XOR color(parent(i)).\n        self.parity = [0] * (n + 1)\n        self.size = [1] * (n + 1)\n\n    def find(self, i):\n        \"\"\"\n        Finds the root of the set containing i, with path compression and parity update.\n        Returns a tuple (root, parity), where parity is the parity of the path from i to the root.\n        \"\"\"\n        if self.parent[i] == i:\n            return i, 0\n\n        # Recursively find the root of the parent\n        root, parent_parity = self.find(self.parent[i])\n\n        # Path compression: point i's parent directly to the root\n        self.parent[i] = root\n        \n        # Update parity: The new parity from i to the root is the XOR sum\n        # of parities along the old path: parity(i->parent) ^ parity(parent->root).\n        self.parity[i] = (self.parity[i] + parent_parity) % 2\n        \n        return self.parent[i], self.parity[i]\n\n    def union(self, i, j):\n        \"\"\"\n        Merges the sets containing i and j.\n        Returns True if the merge is consistent with bipartiteness, False otherwise.\n        A return value of False indicates that adding the edge (i,j) creates an odd cycle.\n        \"\"\"\n        root_i, parity_i = self.find(i)\n        root_j, parity_j = self.find(j)\n\n        if root_i != root_j:\n            # Union by size: attach smaller tree to the root of the larger tree\n            if self.size[root_i]  self.size[root_j]:\n                root_i, root_j = root_j, root_i # Ensure root_i is the larger set's root\n\n            self.parent[root_j] = root_i\n            self.size[root_i] += self.size[root_j]\n            \n            # Update parity of the attached root (root_j).\n            # The edge (i, j) requires color(i) != color(j).\n            # path_parity(i->root_i) = parity_i, path_parity(j->root_j) = parity_j.\n            # color(i) and color(j) must differ. Relative to root_i after merge:\n            # color_rel(i) = parity_i\n            # color_rel(j) = path_parity(j->root_j->root_i) = parity_j ^ parity(root_j->root_i)\n            # So, parity_i != parity_j ^ parity(root_j->root_i)\n            # which implies parity(root_j->root_i) = parity_i ^ parity_j ^ 1.\n            self.parity[root_j] = (parity_i + parity_j + 1) % 2\n            \n            return True\n        else:\n            # i and j are already in the same component.\n            # A conflict (odd cycle) occurs if they have the same relative color.\n            # This happens if their path parities to the common root are the same.\n            if parity_i == parity_j:\n                return False # Conflict detected\n            else:\n                return True # Consistent with existing coloring\n\ndef solve_case(n, edges):\n    \"\"\"\n    Processes a single test case to find the first edge that makes the graph non-bipartite.\n    \"\"\"\n    dsu = DSU(n)\n    for i, edge in enumerate(edges):\n        u, v = edge\n        if not dsu.union(u, v):\n            return i + 1  # Return 1-based index of the violating edge\n    return 0 # No violations found\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        (5, [(1, 2), (3, 4), (2, 3), (4, 5)]),\n        (4, [(1, 2), (2, 3), (3, 4), (4, 1)]),\n        (3, [(1, 2), (2, 3), (1, 3)]),\n        (3, [(1, 1)]),\n        (6, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6)]),\n        (7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (1, 7)]),\n        (5, []),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        result = solve_case(n, edges)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3228343"}, {"introduction": "并查集不仅是一个独立的数据结构，它在许多复杂算法中也扮演着至关重要的角色。本练习将展示DSU如何与Kruskal算法无缝结合，用于构建最小生成树（MST），并在此过程中解决一个高级查询问题。你的任务是在运行Kruskal算法的同时，利用DSU的合并历史来构建一棵“重构树”，并结合最近公共祖先（LCA）算法，从而能够高效查询MST中任意两点之间路径上的最大边权。[@problem_id:3228322]", "problem": "给定一个包含 $n$ 个已标记顶点的无向加权图，其边权为整数。任务是使用基于带有按秩合并（union-by-rank）和路径压缩（path-compression）启发的并查集（Disjoint-Set Union, DSU）的 Kruskal 算法来计算最小生成树（Minimum Spanning Tree, MST），并增强此过程以回答以下查询：对于任意顶点对 $(u,v)$，其在所得 MST 中唯一路径上的最大边权是多少。如果 $u$ 和 $v$ 在最小生成森林中不连通（即图是不连通的），查询应返回 $-1$。如果 $u=v$，查询应返回 $0$。\n\n此问题的根本基础是并查集（DSU）、Kruskal 算法以及最小生成树的切割属性（cut property）的定义和性质。切割属性指出，对于任意将顶点划分为两个非空集合的划分，连接这两个集合且跨越切分的最小权重边包含在每一个 MST 中。Kruskal 算法维护一个由连通分量组成的森林，并重复添加连接两个不同连通分量的最小权重边，直到形成一个生成森林。DSU 通过按秩合并和路径压缩启发式策略，支持高效的连通分量成员关系查询和合并操作，以确保接近线性的时间复杂度。\n\n您必须设计增强方案，使得在经过 $O(n \\log n)$ 的预处理后，每个关于 $u$ 和 $v$ 之间 MST 路径上最大边权的查询都能在 $O(\\log n)$ 时间内得到解答。该增强方案应从这些基础上进行逻辑推导，而不是依赖未经证明的捷径。\n\n您的程序必须实现完整的处理流程：\n- 使用基于带有按秩合并和路径压缩启发的并查集（DSU）的 Kruskal 算法构建 MST。\n- 在构建过程中，建立一个辅助树结构，以便能够回答 MST 路径上的最大边权查询。该增强方案必须由 Kruskal 算法和 DSU 的性质来证明其合理性，并应通过一种有原则的方法支持后续查询，该方法将路径最大值查询简化为树上的祖先查询。\n- 预处理这个辅助结构，以便高效地回答查询。\n\n输入作为固定的测试套件嵌入在程序中。对于每个测试用例，输入包括：\n- 一个整数 $n$，指定顶点的数量，标记为从 $0$ 到 $n-1$。\n- 一个带权边列表 $(u,v,w)$，其中 $w$ 为整数权重。\n- 一个查询对列表 $(u,v)$。\n\n您的程序应生成单行输出，其中包含所有测试用例的查询结果，这些结果被展平为一个用方括号括起来的逗号分隔列表。每个查询的答案是一个整数。如果 $u$ 和 $v$ 不连通，返回 $-1$。如果 $u=v$，返回 $0$。\n\n使用以下测试套件：\n- 测试用例 1：\n  - $n=6$\n  - 边： $\\{(1,2,1),(1,3,2),(3,4,2),(0,2,3),(0,1,4),(2,3,4),(3,5,5),(4,5,6)\\}$\n  - 查询： $\\{(0,5),(4,0),(2,3),(1,1),(4,5),(0,4)\\}$\n- 测试用例 2：\n  - $n=6$\n  - 边： $\\{(0,1,2),(1,2,3),(0,2,4),(3,4,1),(4,5,7),(3,5,8)\\}$\n  - 查询： $\\{(0,2),(3,5),(0,5),(1,1)\\}$\n- 测试用例 3：\n  - $n=1$\n  - 边： $\\{\\}$\n  - 查询： $\\{(0,0),(0,0)\\}$\n- 测试用例 4：\n  - $n=5$\n  - 边： $\\{(0,1,1),(1,2,2),(2,3,3),(3,4,4)\\}$\n  - 查询： $\\{(0,4),(1,3),(2,2)\\}$\n\n您的程序应生成单行输出，其中包含结果，格式为一个用方括号括起来的逗号分隔列表（例如，$[a_1,a_2,\\dots]$）。答案必须严格按照所有测试用例中列出的查询顺序排列。", "solution": "该问题的解决方案基于在执行Kruskal算法的过程中构建一个辅助数据结构，该结构捕获了连通分量合并的层次结构。这个结构通常被称为**Kruskal重构树**，它允许我们将路径最大权重查询转化为最近公共祖先（LCA）查询。\n\n**步骤 1：Kruskal算法与重构树**\n\nKruskal算法通过迭代添加不形成环路的最低权重边来构建最小生成树（MST）。这等同于合并两个先前不连通的连通分量。这个合并过程创建了一个自然的层次结构：较小的分量合并成较大的分量，而连接边的权重标记了该次合并的“成本”。\n\n我们可以明确地对这个层次结构进行建模。重构树将以原始的 $n$ 个顶点作为其叶子节点。当Kruskal算法使用权重为 $w$ 的边 $(u,v)$ 来合并包含 $u$ 的连通分量和包含 $v$ 的连通分量时，我们在重构树中创建一个新的内部节点。这个新节点成为刚刚合并的两个分量所对应的子树根节点的父节点。关键是，我们将权重 $w$ 与这个新的内部节点关联起来。\n\n构建过程如下：\n- 我们使用一个并查集（DSU）数据结构来跟踪连通分量。\n- 我们维护一个从DSU中每个集合的代表元到我们重构树中相应子树根节点的映射。\n- 重构树将有多达 $2n-1$ 个节点（$n$ 个叶子节点和至多 $n-1$ 个内部节点）。\n- 当我们按权重顺序遍历边时，每次对权重为 $w$ 的边执行DSU的 `union` 操作时，我们都在重构树中创建一个新的内部节点，使其成为被合并的两个子树的父节点，并为其分配权重 $w$。\n\n**步骤 2：将路径最大值问题转化为最近公共祖先（LCA）查询**\n\n核心洞见在于：对于最终MST中的任意两个顶点 $u$ 和 $v$，它们之间唯一路径上权重最大的边，正是Kruskal算法添加的、首次将包含 $u$ 的连通分量与包含 $v$ 的连通分量连接起来的那条边。\n\n在我们的重构树中，从一个叶子顶点（例如 $u$）到根的路径遵循了其所在连通分量参与的一系列合并，父节点的权重是单调递增的。$u$ 和 $v$ 的最近公共祖先，记作 `LCA(u,v)`，对应于将 $u$ 和 $v$ 放入同一连通分量的第一次合并事件。存储在这个 `LCA(u,v)` 节点上的权重就是导致这次合并的边的权重。根据Kruskal算法的贪心性质，在这次合并*之前*用于形成包含 $u$ 和 $v$ 的子分量的任何边的权重，都必须小于或等于这次合并边的权重。因此，`LCA(u,v)` 节点的权重就是MST中 $u$ 和 $v$ 之间路径上的最大权重。\n\n因此，寻找路径 $(u,v)$ 上最大边权的问题，被巧妙地简化为在重构树中寻找 `tree_weight[LCA(u, v)]`。\n\n**步骤 3：高效的LCA预处理与查询**\n\n为了在要求的 $O(\\log n)$ 时间内回答LCA查询，我们采用**倍增（binary lifting）**技术。在重构树（或森林，如果图不连通）构建完成后，我们对其进行预处理。\n\n1.  **深度计算**：首先，我们从森林的根节点（们）进行深度优先搜索（DFS），以计算每个节点的深度和每个节点的直接父节点。\n2.  **倍增表**：我们建立一个表 `up[i][j]`，它存储节点 $i$ 的第 $2^j$ 个祖先。\n    -   基本情况是 `up[i][0] = parent[i]`，在DFS期间找到。\n    -   该表使用递推关系 `up[i][j] = up[ up[i][j-1] ][j-1]` 来填充。\n3.  **LCA查询**：有了 `up` 表，我们可以在 $O(\\log n)$ 时间内找到 `LCA(u,v)`。我们首先将较深的节点提升到与较浅节点相同的层级。然后，我们同时向上提升两个节点，直到它们的父节点相同。\n\n**步骤 4：算法总结**\n\n完整的算法流程如下：\n1.  **初始化**：为 $n$ 个顶点初始化一个DSU结构。按权重非递减顺序对所有图的边进行排序。为重构树（最多 $2n-1$ 个节点的父节点和权重数组）和从DSU根到树节点的映射准备数据结构。\n2.  **Kruskal算法与树的构建**：遍历排序后的边。对于每条边 $(u,v,w)$：\n    - 如果 `find(u)` 不等于 `find(v)`，则此边连接两个不同的连通分量，是MST的一部分。\n    - 执行 `union(u,v)`。\n    - 在重构树中创建一个权重为 $w$ 的新内部节点。这个新节点成为代表 $u$ 和 $v$ 所在连通分量的节点的父节点。更新DSU根到树节点的映射。\n3.  **LCA预处理**：Kruskal算法完成后，遍历生成的重构森林以计算节点深度和 `up[i][0]` 值。然后，使用动态规划填充倍增 `up` 表的其余部分。这是一个 $O(n \\log n)$ 的操作。\n4.  **查询处理**：对于每个查询 $(u,v)$：\n    - 如果 $u=v$，答案是 $0$。\n    - 使用最终的DSU状态检查 `find(u) == find(v)`。如果不是，它们不连通，答案是 $-1$。\n    - 如果它们连通，使用预处理好的倍增表在重构树中找到 `lca_node = LCA(u,v)`。答案是存储在 `lca_node` 上的权重。\n\n这种集成方法在指定的时间复杂度内正确解决了问题，并且其合理性直接由所涉及算法的基本性质证明。", "answer": "```python\nimport numpy as np\nimport math\nimport sys\n\n# Increase recursion limit for deep trees in large test cases.\nsys.setrecursionlimit(200000)\n\ndef solve():\n    \"\"\"\n    Main solver function that defines test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 6,\n            \"edges\": [(1, 2, 1), (1, 3, 2), (3, 4, 2), (0, 2, 3), (0, 1, 4), (2, 3, 4), (3, 5, 5), (4, 5, 6)],\n            \"queries\": [(0, 5), (4, 0), (2, 3), (1, 1), (4, 5), (0, 4)]\n        },\n        {\n            \"n\": 6,\n            \"edges\": [(0, 1, 2), (1, 2, 3), (0, 2, 4), (3, 4, 1), (4, 5, 7), (3, 5, 8)],\n            \"queries\": [(0, 2), (3, 5), (0, 5), (1, 1)]\n        },\n        {\n            \"n\": 1,\n            \"edges\": [],\n            \"queries\": [(0, 0), (0, 0)]\n        },\n        {\n            \"n\": 5,\n            \"edges\": [(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 4, 4)],\n            \"queries\": [(0, 4), (1, 3), (2, 2)]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        results = _process_case(case['n'], case['edges'], case['queries'])\n        all_results.extend(results)\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nclass DSU:\n    \"\"\"Disjoint-Set Union with Union-by-Rank and Path-Compression.\"\"\"\n    def __init__(self, n):\n        self.parent = np.arange(n)\n        self.rank = np.zeros(n, dtype=int)\n\n    def find(self, i):\n        if self.parent[i] == i:\n            return i\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        root_i = self.find(i)\n        root_j = self.find(j)\n        if root_i != root_j:\n            if self.rank[root_i] > self.rank[root_j]:\n                self.parent[root_j] = root_i\n            else:\n                self.parent[root_i] = root_j\n                if self.rank[root_i] == self.rank[root_j]:\n                    self.rank[root_j] += 1\n            return True\n        return False\n\ndef _process_case(n, edges, queries):\n    \"\"\"\n    Solves a single test case: builds MST and reconstruction tree,\n    preprocesses for LCA, and answers all queries.\n    \"\"\"\n    if n == 0:\n        return [0] * len(queries)\n\n    # In a graph with n vertices, Kruskal's will create at most n-1 merges.\n    # Total nodes in reconstruction tree = n leaves + (n-1) internal nodes.\n    max_nodes = 2 * n - 1 if n > 0 else 0\n    if max_nodes == 0: max_nodes = 1\n\n    dsu = DSU(n)\n    \n    # Sort edges by weight\n    edges.sort(key=lambda x: x[2])\n\n    # Data structures for the reconstruction tree\n    # Maps a DSU component's root to its corresponding node in the reconstruction tree\n    dsu_root_to_tree_node = np.arange(n)\n    tree_parent = np.full(max_nodes, -1, dtype=int)\n    tree_weight = np.zeros(max_nodes, dtype=int)\n    next_internal_node = n\n\n    # Phase 1: Kruskal's algorithm and reconstruction tree construction\n    for u, v, w in edges:\n        root_u = dsu.find(u)\n        root_v = dsu.find(v)\n\n        if root_u != root_v:\n            # This edge connects two different components\n            tree_node_u = dsu_root_to_tree_node[root_u]\n            tree_node_v = dsu_root_to_tree_node[root_v]\n            \n            # Perform union and get the new root of the merged component\n            # The DSU implementation details determine the new root\n            if dsu.rank[root_u] > dsu.rank[root_v]:\n                new_dsu_root = root_u\n            else:\n                new_dsu_root = root_v\n            \n            dsu.union(u, v)\n\n            # Create a new internal node for the merge\n            p = next_internal_node\n            tree_parent[tree_node_u] = p\n            tree_parent[tree_node_v] = p\n            tree_weight[p] = w\n            \n            # The new component's representative maps to this new internal node\n            dsu_root_to_tree_node[new_dsu_root] = p\n            next_internal_node += 1\n    \n    num_total_nodes = next_internal_node\n    \n    # Phase 2: Preprocessing for LCA (Binary Lifting)\n    if num_total_nodes == 0:\n        return [0 if u == v else -1 for u, v in queries]\n        \n    MAX_LOG = (num_total_nodes).bit_length()\n    up = np.full((num_total_nodes, MAX_LOG), -1, dtype=int)\n    depth = np.full(num_total_nodes, -1, dtype=int)\n    \n    # Build adjacency list from parent array for easier traversal\n    adj = [[] for _ in range(num_total_nodes)]\n    roots = []\n    for i in range(num_total_nodes):\n        if tree_parent[i] != -1:\n            adj[tree_parent[i]].append(i)\n        else:\n            roots.append(i)\n\n    # DFS from each root of the forest to compute depth and up[i][0]\n    for root in roots:\n        stack = [(root, -1, 0)] # (current_node, parent_node, current_depth)\n        while stack:\n            curr, p, d = stack.pop()\n            depth[curr] = d\n            up[curr, 0] = p if p != -1 else curr # Root's parent is itself\n            for neighbor in adj[curr]:\n                stack.append((neighbor, curr, d + 1))\n\n    # Fill the rest of the 'up' table using dynamic programming\n    for j in range(1, MAX_LOG):\n        for i in range(num_total_nodes):\n            if up[i, j-1] != -1:\n                up[i, j] = up[up[i, j-1], j-1]\n\n    # --- LCA Query Function ---\n    def get_lca(u, v):\n        if depth[u]  depth[v]:\n            u, v = v, u\n\n        # Lift u to the same depth as v\n        for j in range(MAX_LOG - 1, -1, -1):\n            if depth[u] - (1  j) >= depth[v]:\n                u = up[u, j]\n\n        if u == v:\n            return u\n\n        # Lift u and v together\n        for j in range(MAX_LOG - 1, -1, -1):\n            if up[u, j] != up[v, j]:\n                u = up[u, j]\n                v = up[v, j]\n        \n        return up[u, 0]\n\n    # Phase 3: Answer queries\n    results = []\n    for u, v in queries:\n        if u == v:\n            results.append(0)\n            continue\n            \n        if dsu.find(u) != dsu.find(v):\n            results.append(-1)\n            continue\n\n        lca_node = get_lca(u, v)\n        results.append(tree_weight[lca_node])\n\n    return results\n\nsolve()\n```", "id": "3228322"}]}