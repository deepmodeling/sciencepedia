{"hands_on_practices": [{"introduction": "要真正掌握二分图检测，第一步是动手实现一个通用的核心算法。这个练习要求你使用广度优先搜索（BFS）实现一个双色着色程序，这是判断图是否为二分图的经典方法。通过在一个结构化但非平凡的超立方体图上测试你的算法，你将能验证其正确性并巩固对基本原理的理解 [@problem_id:3216705]。", "problem": "考虑一个无向图 $G = (V, E)$，其定义如下。对于给定的整数 $n \\geq 0$，顶点集 $V$ 由所有长度为 $n$ 的二进制字符串组成，即 $V = \\{0,1\\}^n$。当且仅当两个顶点 $x, y \\in V$ 的汉明距离恰好为 $1$ 时，它们之间有一条边连接，这意味着它们仅在一位上不同。该图是标准的 $n$-维超立方体。此外，还可以向超立方体中添加一个可选的无向边有限集 $E^{+} \\subseteq V \\times V$。每条添加的无向边 $(u,v) \\in E^{+}$ 都必须满足 $u \\neq v$ 和 $u, v \\in \\{0,1\\}^n$。\n\n你的任务是编写一个完整的程序，为每个指定的 $n$ 和可选的 $E^{+}$ 构建图 $G$，然后判断 $G$ 是否为二分图。你的程序必须使用一种通用算法来测试二分性，该算法尝试为顶点赋予两种颜色，以使每条边的端点颜色都不同。该算法应适用于任何无向图，而不应假设超立方体具有特殊的对称性或属性。在程序中，图的表示可以用其二进制字符串对应的 $\\{0,1,\\dots,2^n - 1\\}$ 范围内的整数来标记每个顶点。边的构建应通过翻转一位来建立超立方体的邻接关系，然后添加任何指定的 $(u,v) \\in E^{+}$。\n\n需要使用的基本定义：\n- 如果一个图 $G$ 的顶点可以被划分为两个不相交的集合 $A$ 和 $B$，使得每条边的两个端点分别位于 $A$ 和 $B$ 中，那么该图就是二分图。\n- 等价地，如果一个图的顶点可以进行二着色，使得相邻顶点的颜色不同，那么该图就是二分图。\n\n你必须实现一个基于这些定义的算法，例如一个基于遍历的二着色过程，并将其应用于每个测试用例。\n\n测试套件规范：\n按给定顺序，为以下参数集计算并报告其二分性。对于每个用例，$E^{+}$ 以整数对集合的形式列出，其中整数在 $\\{0,1,\\dots,2^n - 1\\}$ 范围内。\n\n- 用例 1：$n = 0$，$E^{+} = \\varnothing$。\n- 用例 2：$n = 1$，$E^{+} = \\varnothing$。\n- 用例 3：$n = 2$，$E^{+} = \\varnothing$。\n- 用例 4：$n = 3$，$E^{+} = \\varnothing$。\n- 用例 5：$n = 6$，$E^{+} = \\{(0, 63)\\}$，其中 $63 = 2^6 - 1$。\n- 用例 6：$n = 5$，$E^{+} = \\{(0, 31)\\}$，其中 $31 = 2^5 - 1$。\n- 用例 7：$n = 10$，$E^{+} = \\varnothing$。\n- 用例 8：$n = 4$，$E^{+} = \\{(0, 15)\\}$，其中 $15 = 2^4 - 1$。\n\n答案规范：\n- 对每个用例，输出一个布尔值，指示生成的图 $G$ 是否为二分图。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表顺序与上述测试套件相同，例如 $[{\\tt True},{\\tt False},\\dots]$。\n- 本问题不涉及物理单位、角度单位或百分比。\n\n程序必须是自包含的，不需要任何输入。它必须根据描述构建每个图，运行二分性测试，并以指定的确切格式打印结果。", "solution": "该问题是有效的。这是一个在图论和算法领域中定义良好、有科学依据的问题。所有术语都得到了清晰的定义，测试用例具体且计算上可行。\n\n这个问题的核心是判断给定的图 $G=(V, E)$ 是否为二分图。一个图是二分图当且仅当它不包含奇数长度的环。测试二分性的一个标准通用算法是使用图遍历方法（如广度优先搜索（BFS）或深度优先搜索（DFS））尝试对图的顶点进行二着色。\n\n该算法流程如下：\n1.  表示图，我们使用邻接表。顶点数量为 $N=2^n$。顶点用从 $0$ 到 $2^n - 1$ 的整数标记。\n2.  创建一个大小为 $N$ 的 `colors` 数组，用一个哨兵值（例如 $-1$）初始化，表示所有顶点尚未被着色。\n3.  遍历每个顶点 $v \\in V$。如果顶点 $v$ 尚未被着色，这意味着我们找到了图的一个新的、未被发现的连通分量。我们从这个顶点开始进行遍历（例如 BFS）。\n    a. 为源顶点 $v$ 分配一个起始颜色（比如 $0$），并将其加入 BFS 的队列中。\n    b. 当队列不为空时，从队列中取出一个顶点 $u$。\n    c. 对于 $u$ 的每个邻居 $w$：\n        i. 如果 $w$ 未被着色（即 `colors[w]` 为 $-1$），这意味着我们在此次遍历中首次访问它。我们给它分配与 $u$ 的颜色相反的颜色，即 $1 - \\text{colors}[u]$，并将 $w$ 入队。\n        ii. 如果 $w$ 已经被着色，可能会出现冲突。如果 `colors[w]` 与 `colors[u]` 相同，这意味着存在一条连接两个相同颜色顶点的边。这种情况只可能在图包含奇数长度环时发生。从该连通分量的起始顶点到 $u$ 和到 $w$ 的路径长度必须具有相同的奇偶性，它们才会被赋予相同的颜色，而边 $(u,w)$ 闭合了一个环。这个环的长度是 $(\\text{dist}(s,u) + \\text{dist}(s,w) + 1)$，其长度必定为奇数。因此，该图不是二分图，算法可以立即终止，返回 `False`。\n4.  如果算法在遍历完所有顶点及其连通分量后，没有发现任何颜色相同的相邻顶点，则意味着找到了一个有效的二着色。该图是二分图，算法返回 `True`。\n\n每个测试用例的图都是一个 $n$-维超立方体，可能由集合 $E^+$ 中的额外边增强。超立方体的顶点是长度为 $n$ 的二进制字符串，我们将其映射为从 $0$ 到 $2^n-1$ 的整数。在基础超立方体中，如果两个顶点的二进制表示仅在一位上不同，则它们之间存在一条边。这等价于它们的整数表示 $u$ 和 $v$ 满足 $v = u \\oplus (1 \\ll i)$，其中 $i \\in \\{0, 1, \\dots, n-1\\}$ 是某个位位置，$\\oplus$ 是按位异或运算符，$\\ll$ 是左移位运算符。\n\n所有超立方体天然都是二分图。顶点可以根据其二进制表示中 $1$ 的数量的奇偶性（即位数统计，population count）进行划分。超立方体中的一条边总是连接一个具有偶数位数统计的顶点和一个具有奇数位数统计的顶点。添加一条额外的边 $(u,v) \\in E^+$ 可能会破坏这一性质。如果 $u$ 和 $v$ 的位数统计具有相同的奇偶性，那么在原始的二分划分中它们将属于同一个集合。在它们之间添加一条边会创建一个奇数长度的环，从而使得图不再是二分图。$u$ 和 $v$ 的位数统计的奇偶性相同，当且仅当它们之间的汉明距离 $d(u,v) = \\text{popcount}(u \\oplus v)$ 是一个偶数。\n\n对于给定的测试用例：\n- 用例 1, 2, 3, 4, 7: $E^+ = \\varnothing$。这些图分别是维度为 $n=0, 1, 2, 3, 10$ 的纯超立方体。它们都是二分图。结果：`True`。\n- 用例 5：$n=6, E^+=\\{(0, 63)\\}$。顶点 $u=0$ 的二进制表示为 `000000`，其 $\\text{popcount}(0)=0$（偶数）。顶点 $v=63$ 是 $2^6-1$，二进制表示为 `111111`，其 $\\text{popcount}(63)=6$（偶数）。由于两个顶点的位数统计奇偶性相同，在它们之间添加一条边会创建一个奇数环。结果：`False`。\n- 用例 6：$n=5, E^+=\\{(0, 31)\\}$。顶点 $u=0$ 的 $\\text{popcount}(0)=0$（偶数）。顶点 $v=31$ 是 $2^5-1$，二进制表示为 `11111`，其 $\\text{popcount}(31)=5$（奇数）。这两个顶点的位数统计奇偶性不同，因此在它们之间添加一条边会保持二分性。结果：`True`。\n- 用例 8：$n=4, E^+=\\{(0, 15)\\}$。顶点 $u=0$ 的 $\\text{popcount}(0)=0$（偶数）。顶点 $v=15$ 是 $2^4-1$，二进制表示为 `1111`，其 $\\text{popcount}(15)=4$（偶数）。这两个顶点的位数统计奇偶性相同。该图不是二分图。结果：`False`。\n\n实现将为每个用例构建图，并按要求应用通用的基于 BFS 的二着色算法，而不使用位数统计的捷径。", "answer": "```python\nimport numpy as np\nimport collections\n\ndef is_bipartite(n, extra_edges):\n    \"\"\"\n    Determines if a graph is bipartite using a BFS-based 2-coloring algorithm.\n\n    The graph is an n-hypercube with optional additional edges.\n    \n    Args:\n        n (int): The dimension of the hypercube. Vertices are 0 to 2**n - 1.\n        extra_edges (set): A set of tuples representing additional undirected edges.\n\n    Returns:\n        bool: True if the graph is bipartite, False otherwise.\n    \"\"\"\n    if n == 0:\n        return True # A single-vertex graph (n=0) is bipartite.\n    \n    num_vertices = 1  n # This is 2**n\n        \n    adj = collections.defaultdict(list)\n\n    # Build adjacency list for the n-hypercube\n    for u in range(num_vertices):\n        for i in range(n):\n            v = u ^ (1  i)\n            adj[u].append(v)\n    \n    # Add the extra edges\n    for u, v in extra_edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # colors array: -1 for uncolored, 0 for color A, 1 for color B\n    colors = np.full(num_vertices, -1, dtype=np.int8)\n\n    # Iterate through all vertices to handle disconnected components\n    for start_node in range(num_vertices):\n        if colors[start_node] == -1:\n            # Start BFS for this component\n            colors[start_node] = 0\n            queue = collections.deque([start_node])\n            \n            while queue:\n                u = queue.popleft()\n                \n                for v in adj[u]:\n                    if colors[v] == -1:\n                        # Color the neighbor with the opposite color\n                        colors[v] = 1 - colors[u]\n                        queue.append(v)\n                    elif colors[v] == colors[u]:\n                        # An edge connects two vertices of the same color,\n                        # hence an odd cycle exists.\n                        return False\n                        \n    # If all components are successfully 2-colored, the graph is bipartite.\n    return True\n\ndef solve():\n    \"\"\"\n    Runs the bipartiteness test on the specified suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'n': 0, 'E_plus': set()},\n        # Case 2\n        {'n': 1, 'E_plus': set()},\n        # Case 3\n        {'n': 2, 'E_plus': set()},\n        # Case 4\n        {'n': 3, 'E_plus': set()},\n        # Case 5\n        {'n': 6, 'E_plus': {(0, 63)}},\n        # Case 6\n        {'n': 5, 'E_plus': {(0, 31)}},\n        # Case 7\n        {'n': 10, 'E_plus': set()},\n        # Case 8\n        {'n': 4, 'E_plus': {(0, 15)}},\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case['n']\n        extra_edges = case['E_plus']\n        result = is_bipartite(n, extra_edges)\n        results.append(result)\n    \n    # Format the final output string exactly as specified.\n    # The boolean values True/False must be capitalized.\n    output_str = f\"[{','.join(str(r) for r in results)}]\"\n    print(output_str)\n\nsolve()\n\n```", "id": "3216705"}, {"introduction": "虽然通用算法总是有效的，但优秀的算法工程师能够洞察图的特殊结构并设计出更高效的解决方案。本练习的图由一棵树和一条额外的边构成，其关键在于认识到这种结构只包含一个唯一的环 [@problem_id:3216784]。因此，判断二分性这个复杂问题被简化为计算这个环的长度是奇数还是偶数，这极大地考验了你的分析能力。", "problem": "设有一个无向、简单、连通图 $G=(V,E)$，它由一个包含 $|V|=n$ 个顶点（因此 $|E(T)|=n-1$）的树 $T$，并在 $T$ 的两个不同的、不相邻的顶点之间添加恰好 $1$ 条额外的边而得到。这样的图恰好有 $1$ 个简单环。如果一个图的顶点集可以被划分成两个不相交的部分 $A$ 和 $B$，使得每条边的两个端点一个在 $A$ 中，另一个在 $B$ 中，则称该图为二分图。你需要设计并实现一个线性时间算法，从第一性原理出发进行表述和论证，以判断图 $G$ 是否为二分图。该算法不得依赖于本问题陈述中给出的任何快捷公式，必须从基本定义和经过充分检验的事实推导得出。\n\n基本要求：\n- 仅使用图、树、路径和环的核心定义，以及“一个图是二分图当且仅当它不包含奇数长度的环”这一经过充分检验的事实。\n- 设计必须从这些基础出发，解释为什么它们能推导出对 $G$（一棵树加 1 条额外的边）所需的测试方法，并展示如何在 $O(n)$ 时间内实现该判断。\n\n程序规范：\n- 顶点由整数 $0,1,2,\\dots,n-1$ 标记。\n- 每个测试用例由以下内容指定：\n  - 一个整数 $n$（顶点数）。\n  - 一个包含 $n-1$ 条构成树 $T$ 的无向树边的列表。\n  - 一条单独的无向额外边 $(u,v)$，其端点在 $T$ 中是不同的且不相邻的。\n- 你的程序必须实现一个线性时间算法，对于每个测试用例，返回一个布尔值，指示最终生成的图 $G$ 是否为二分图。\n\n测试套件：\n提供以下测试用例的结果（所有边都是无向的）：\n- 测试用例 1：$n=3$，树边 $\\{(0,1),(1,2)\\}$，额外边 $(0,2)$。\n- 测试用例 2：$n=4$，树边 $\\{(0,1),(1,2),(2,3)\\}$，额外边 $(0,3)$。\n- 测试用例 3：$n=5$，树边 $\\{(0,1),(0,2),(0,3),(0,4)\\}$，额外边 $(1,2)$。\n- 测试用例 4：$n=6$，树边 $\\{(0,1),(1,2),(2,3),(3,4),(4,5)\\}$，额外边 $(1,4)$。\n- 测试用例 5：$n=7$，树边 $\\{(0,1),(0,2),(1,3),(1,4),(2,5),(2,6)\\}$，额外边 $(3,2)$。\n- 测试用例 6：$n=8$，树边 $\\{(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7)\\}$，额外边 $(2,6)$。\n\n输出格式：\n- 你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3]$），其中每个 $r_i$ 是按上述顺序排列的第 $i$ 个测试用例的布尔结果。\n\n不涉及物理量，因此不需要单位。不出现角度，因此不需要角度单位。不出现百分比，因此没有关于百分比格式的特殊说明。", "solution": "问题陈述的有效性已得到确认。这是一个算法图论中的良构问题，基于标准的定义和定理，没有任何科学或逻辑上的缺陷。\n\n该解决方案从第一性原理推导得出，始于二分图的基本特性。\n\n**1. 二分图的基本原理**\n\n图论中的一个基石定理指出，一个无向图是二分图，当且仅当它不包含奇数长度的简单环。如果一个图的顶点可以被划分成两个不相交的集合（例如 $A$ 和 $B$），使得每条边都连接一个在 $A$ 中的顶点和一个在 $B$ 中的顶点，那么该图就是二分图。如果一个环有奇数个顶点，例如 $v_1, v_2, \\dots, v_k, v_1$（其中 $k$ 为奇数），那么任何对其进行 2-着色的尝试都会失败。如果 $v_1$ 在集合 $A$ 中，那么 $v_2$ 必须在 $B$ 中，$v_3$ 在 $A$ 中，依此类推。对于任何顶点 $v_i$，其颜色将由其索引 $i$ 的奇偶性决定。如果 $k-1$ 是偶数（当 $k$ 是奇数时成立），顶点 $v_k$ 将与 $v_1$ 具有相同的颜色。然而，边 $(v_k, v_1)$ 连接了它们，从而产生冲突。反之，如果一个图没有奇数环，总能找到一种 2-着色方案。\n\n**2. 图 $G$ 的结构分析**\n\n问题指定图 $G=(V,E)$ 是通过一个包含 $n$ 个顶点的树 $T$，并在 $T$ 的两个不同的、不相邻的顶点之间添加一条额外的边 $(u,v)$ 来构建的。我们分析由此构造产生的环结构。\n\n- 根据定义，树是一个不包含环的连通图。\n- 树的一个基本性质是，对于任意两个顶点（例如 $u$ 和 $v$），它们之间存在一条唯一的简单路径。我们将这条在 $T$ 中的路径表示为 $P_{uv}$。\n- 图 $G$ 由树 $T$ 和边 $(u,v)$ 的并集构成。$G$ 的边集是 $E(G) = E(T) \\cup \\{(u,v)\\}$。\n- 添加边 $(u,v)$ 会创建一个环 $C$，该环由路径 $P_{uv}$ 和边 $(u,v)$ 本身组成。\n- 这个环 $C$ 是 $G$ 中*唯一*的简单环。要理解原因，假设存在另一个简单环 $C'$。如果 $C'$ 不使用边 $(u,v)$，那么它的所有边都必须属于树 $T$。这将意味着 $T$ 包含一个环，这与树的定义相矛盾。因此，$G$ 中的任何环都必须包含边 $(u,v)$。由于 $P_{uv}$ 是 $T$ 中 $u$ 和 $v$ 之间的唯一路径，任何包含 $(u,v)$ 的环都必须通过遍历 $P_{uv}$ 然后通过边 $(u,v)$ 返回而形成。因此，$C$ 是 $G$ 中唯一的简单环。\n\n**3. 二分性特定测试方法的推导**\n\n将基本原理与对 $G$ 的结构分析相结合，我们可以构建一个直接的二分性测试方法。\n\n- 根据该原理，$G$ 是二分图当且仅当它没有奇数长度的环。\n- 既然我们已经确定 $G$ 只有一个简单环 $C$，二分性的条件就简化为：$G$ 是二分图当且仅当这个唯一的环 $C$ 的长度是偶数。\n\n**4. 环长度的计算**\n\n环的长度（记为 $|C|$）是它包含的边的数量。环 $C$ 由路径 $P_{uv}$ 的边和单条边 $(u,v)$ 构成。因此，其长度为：\n$$|C| = |P_{uv}| + 1$$\n在这里，$|P_{uv}|$ 是树 $T$ 中 $u$ 和 $v$ 之间唯一路径上的边数。根据定义，这就是 $u$ 和 $v$ 在 $T$ 中的距离，记为 $\\text{dist}_T(u,v)$。\n所以，环的长度是：\n$$|C| = \\text{dist}_T(u,v) + 1$$\n$G$ 是二分图的条件是 $|C|$ 必须是偶数。这意味着 $\\text{dist}_T(u,v) + 1$ 必须是偶数，这当且仅当 $\\text{dist}_T(u,v)$ 是奇数时成立。\n\n**5. 线性时间算法**\n\n问题现在简化为计算树 $T$ 中顶点 $u$ 和 $v$ 之间的距离，并检查该距离是否为奇数。这可以在线性时间内高效地完成。\n\n- **算法**：\n    1.  根据给定的 $n-1$ 条边，构建树 $T$ 的邻接表表示。这需要遍历一次所有边，耗时 $O(n)$。\n    2.  从顶点 $u$ 开始执行广度优先搜索 (BFS)，以找到它到树中所有其他顶点的距离。我们使用一个队列和一个大小为 $n$ 的距离数组 `distances`，该数组用一个值（例如 -1）初始化，表示顶点尚未被访问。\n    3.  用 $u$ 初始化队列，并设置 `distances[u] = 0`。\n    4.  当队列不为空时，从队列中取出一个顶点（称为 `curr`）。对于 `curr` 的每个邻居 `next`，如果 `distances[next]` 是 -1，则将其更新为 `distances[curr] + 1` 并将 `next` 入队。\n    5.  BFS 会精确地遍历树的每个顶点和每条边一次。当算法完成时（或者，作为一种优化，一旦到达 `v`），`distances[v]` 的值将是 $\\text{dist}_T(u,v)$。\n    6.  最后一步是检查 `distances[v]` 是否为奇数。如果是，则图 $G$ 是二分图；否则，不是。\n\n- **复杂度分析**：\n    - 邻接表的构建是 $O(n)$ 的。\n    - 在树（一个有 $n$ 个顶点和 $n-1$ 条边的连通图）上进行 BFS 的时间复杂度是 $O(|V|+|E(T)|) = O(n + (n-1)) = O(n)$。\n    - 最后的检查是一个 $O(1)$ 操作。\n    - 因此，整个算法在 $O(n)$ 时间内运行，满足了问题的线性时间要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport collections\n\ndef is_bipartite_for_tree_plus_one_edge(n, tree_edges, extra_edge):\n    \"\"\"\n    Determines if a graph formed by a tree plus one edge is bipartite.\n\n    The method is based on the principle that a graph is bipartite if and only if\n    it contains no odd-length cycles. The given graph structure has exactly one\n    cycle, formed by the extra edge (u, v) and the unique path between u and v\n    in the tree. The graph is bipartite if and only if this cycle has an even\n    length.\n\n    Cycle length = dist_T(u, v) + 1.\n    For the cycle length to be even, dist_T(u, v) must be odd.\n\n    This function calculates the distance between u and v in the tree using BFS\n    and checks if it is odd.\n\n    Args:\n        n (int): The number of vertices.\n        tree_edges (list of tuple): A list of n-1 edges forming the tree.\n        extra_edge (tuple): The single edge added to the tree.\n\n    Returns:\n        bool: True if the graph is bipartite, False otherwise.\n    \"\"\"\n    u, v = extra_edge\n\n    # Step 1: Build the adjacency list for the tree T.\n    # Complexity: O(n) as there are n-1 edges.\n    adj = [[] for _ in range(n)]\n    for a, b in tree_edges:\n        adj[a].append(b)\n        adj[b].append(a)\n\n    # Step 2: Use Breadth-First Search (BFS) to find the distance from u to v.\n    # Complexity: O(n) for a tree with n vertices.\n    queue = collections.deque([u])\n    # distances array tracks distance from u and also serves as a visited set.\n    distances = [-1] * n\n    distances[u] = 0\n\n    while queue:\n        current_node = queue.popleft()\n\n        # If we have reached the target vertex v, we have found the distance.\n        if current_node == v:\n            break\n\n        for neighbor in adj[current_node]:\n            # If the neighbor has not been visited yet\n            if distances[neighbor] == -1:\n                distances[neighbor] = distances[current_node] + 1\n                queue.append(neighbor)\n    \n    # Step 3: Check the parity of the distance.\n    # The graph is bipartite iff the unique cycle is of even length.\n    # Cycle length = dist(u,v) + 1.\n    # Length is even iff dist(u,v) is odd.\n    distance_uv = distances[v]\n    \n    # This case should not be reached for a valid connected tree input.\n    if distance_uv == -1:\n        return False\n\n    return distance_uv % 2 == 1\n\ndef solve():\n    \"\"\"\n    Runs the algorithm on the predefined test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1: n=3, tree edges {(0,1),(1,2)}, extra edge (0,2).\n        # Path 0-1-2. dist(0,2) = 2. Cycle length = 3 (odd). Not bipartite.\n        (3, [(0, 1), (1, 2)], (0, 2)),\n        # Test case 2: n=4, tree edges {(0,1),(1,2),(2,3)}, extra edge (0,3).\n        # Path 0-1-2-3. dist(0,3) = 3. Cycle length = 4 (even). Bipartite.\n        (4, [(0, 1), (1, 2), (2, 3)], (0, 3)),\n        # Test case 3: n=5, tree edges {(0,1),(0,2),(0,3),(0,4)}, extra edge (1,2).\n        # Path 1-0-2. dist(1,2) = 2. Cycle length = 3 (odd). Not bipartite.\n        (5, [(0, 1), (0, 2), (0, 3), (0, 4)], (1, 2)),\n        # Test case 4: n=6, tree edges {(0,1),(1,2),(2,3),(3,4),(4,5)}, extra edge (1,4).\n        # Path 1-2-3-4. dist(1,4) = 3. Cycle length = 4 (even). Bipartite.\n        (6, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)], (1, 4)),\n        # Test case 5: n=7, tree edges {(0,1),(0,2),(1,3),(1,4),(2,5),(2,6)}, extra edge (3,2).\n        # Path 3-1-0-2. dist(3,2) = 3. Cycle length = 4 (even). Bipartite.\n        (7, [(0, 1), (0, 2), (1, 3), (1, 4), (2, 5), (2, 6)], (3, 2)),\n        # Test case 6: n=8, tree edges {(0,1),..,(6,7)}, extra edge (2,6).\n        # Path 2-3-4-5-6. dist(2,6) = 4. Cycle length = 5 (odd). Not bipartite.\n        (8, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)], (2, 6)),\n    ]\n\n    results = []\n    for n, tree_edges, extra_edge in test_cases:\n        result = is_bipartite_for_tree_plus_one_edge(n, tree_edges, extra_edge)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3216784"}, {"introduction": "在现实世界的许多场景中，图是动态变化的。当图的边被逐一添加时，每次都重新运行完整的二分性检测会非常低效 [@problem_id:3216756]。这个高级练习将引导你使用一种带“路径奇偶性”的并查集（Disjoint Set Union, DSU）数据结构，来高效地在线跟踪图的二分性，这是一种解决动态图问题的强大技巧。", "problem": "考虑一个无向简单图 $G = (V,E)$，其顶点集为 $V$，边集为 $E$。边按固定顺序逐一添加，生成一个嵌套图族 $G_1, G_2, \\ldots, G_m$，其中 $G_t$ 表示添加前 $t$ 条边后的图。如果一个图的顶点集 $V$ 可以被划分为 $V = X \\cup Y$，且 $X \\cap Y = \\varnothing$，使得每条边的一个端点在 $X$ 中，另一个端点在 $Y$ 中，那么这个图就称为二分图。一个公认的事实是：无向图是二分图，当且仅当它不包含奇数长度的环。\n\n仅从上述核心定义出发，设计一个程序，对每个指定的测试用例，报告使得 $G_t$ 不是二分图的最早索引 $t \\in \\{1,2,\\ldots,m\\}$。如果添加所有 $m$ 条边后图仍然是二分图，则报告 $0$。一个自环，即形如 $(u,u)$（对于某个 $u \\in V$）的边，会立即导致图变为非二分图，因为单个顶点不能同时被放置在划分的两个部分中。\n\n测试套件中的所有图都是无向的，边可能重复，顶点由从1开始的连续整数标记。添加一条边 $(u,v)$ 被解释为施加一个约束，即在包含 $u$ 和 $v$ 的连通分量的任何有效二染色中，$u$ 和 $v$ 的标签必须被赋予相反的颜色。\n\n测试套件由以下参数集组成。每个测试用例由一个顶点数 $n$ 和一个长度为 $m$ 的边序列给出，该序列写为有序对 $(u,v)$ 的形式，其中 $u,v \\in \\{1,2,\\ldots,n\\}$，并按所列顺序处理。\n\n- 测试用例 1：$n = 6$，边序列 $\\big((1,2),(2,3),(3,4),(4,5),(5,6),(6,1),(1,3)\\big)$。\n- 测试用例 2：$n = 5$，边序列 $\\big((1,2),(2,3),(3,4),(4,5)\\big)$。\n- 测试用例 3：$n = 3$，边序列 $\\big((1,2),(2,2),(2,3)\\big)$。\n- 测试用例 4：$n = 4$，边序列 $\\big((1,2),(2,3),(3,1),(4,1)\\big)$。\n- 测试用例 5：$n = 4$，边序列 $\\big((1,2),(2,3),(1,2),(3,4),(4,1),(2,4)\\big)$。\n- 测试用例 6：$n = 3$，边序列 $\\big(\\ \\big)$ (即没有边)。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，不含空格，其顺序与测试套件的顺序相同（例如，$[r_1,r_2,\\ldots,r_6]$，其中每个 $r_i$ 是如上指定的整数）。", "solution": "该问题要求设计一种算法，以确定在一系列边的添加过程中，图在哪个最早的时间点上不再是二分图。一个图 $G=(V,E)$ 被定义为二分图，如果其顶点集 $V$ 可以被划分为两个不相交的集合 $X$ 和 $Y$，使得 $E$ 中的每条边都连接 $X$ 中的一个顶点和 $Y$ 中的一个顶点。问题陈述正确地提供了基本定理：一个图是二分图，当且仅当它不包含奇数长度的环。我们处理一个包含 $m$ 条边的序列，创建一系列图 $G_1, G_2, \\ldots, G_m$，其中 $G_t$ 是包含前 $t$ 条边的图。我们寻找最小的 $t \\in \\{1, 2, \\ldots, m\\}$，使得 $G_t$ 不是二分图。如果序列中所有的图都是二分图，则结果为 $0$。\n\n问题的核心是高效地检测第一个奇数长度环的形成。向一个已有的二分图 $G$ 中添加一条边 $(u,v)$ 会使新图变为非二分图，当且仅当这条新边闭合了一个奇数长度的环。这种情况发生当且仅当顶点 $u$ 和 $v$ 已经处于同一连通分量中，并且它们在 $G$ 中的路径长度为偶数。添加边 $(u,v)$ 会创建一个环，其长度是偶数路径长度加 1，结果为奇数。\n\n从二染色的角度来看，这意味着在添加边 $(u,v)$ *之前*，顶点 $u$ 和 $v$ 在其所在连通分量的任何有效二染色中都必须具有相同的颜色。新边施加了它们必须具有不同颜色的约束，从而产生了矛盾。\n\n这个动态连通性和相对染色问题可以通过使用一个增强的并查集 (Disjoint Set Union, DSU) 数据结构来优雅地解决。标准的 DSU 用于跟踪图的连通分量。我们对其进行增强，以额外跟踪一个分量内节点之间“距离”（路径长度）的奇偶性，这对应于它们在二染色中的颜色关系。\n\n对于一个具有 $n$ 个从 1 到 $n$ 标记的顶点的图，我们的 DSU 结构将包含两个主要数组：\n1. `parent`：一个大小为 $n+1$ 的数组，其中 `parent[i]` 存储节点 $i$ 在其分量的树表示中的父节点。\n2. `parity`：一个大小为 $n+1$ 的数组，其中 `parity[i]` 存储节点 $i$ 与其父节点 `parent[i]` 之间路径长度的奇偶性（0 或 1）。`parity[i] = 1` 意味着 $i$ 和 `parent[i]` 必须具有不同的颜色，而 `parity[i] = 0` 意味着它们必须具有相同的颜色。一条边天然对应于长度为 1 的路径，因此其端点颜色不同。\n\nDSU 操作修改如下：\n\n**`find(i)` 操作**：此操作查找包含顶点 $i$ 的分量的代表元（根）。它实现路径压缩以保持效率。当路径被压缩时（即 `parent[i]` 被设置为分量的根），`parity[i]` 的值必须更新，以存储从 $i$ 到根的路径长度的奇偶性。如果从 $i$ 到根的原始路径是 $i \\to p_1 \\to p_2 \\to \\dots \\to \\text{root}$，那么新的 `parity[i]` 将变为异或和 $(\\text{parity}_{\\text{old}}[i] \\oplus \\text{parity}_{\\text{old}}[p_1] \\oplus \\dots) \\pmod 2$。递归实现可以很自然地处理这个问题。`find(i)` 操作返回一个元组，包含分量的根以及计算出的从 $i$ 到该根的路径的奇偶性。\n\n**`union(u, v)` 操作**：此操作处理新边 $(u,v)$ 的添加，并确定它是否违反了二分图的性质。\n1. 首先，我们调用 `find(u)` 和 `find(v)` 来获取它们各自的根以及相对于这些根的奇偶性：$(\\text{root}_u, \\text{parity}_u)$ 和 $(\\text{root}_v, \\text{parity}_v)$。\n2. **情况 A：不同分量 ($\\text{root}_u \\neq \\text{root}_v$)**。该边连接了两个先前分离的分量。这不会产生环，因此图仍然是二分图。我们合并这两个分量，例如，通过设置 `parent[root_v] = root_u`。然后我们必须为这个新连接建立奇偶性关系。从 $\\text{root}_v$ 到 $\\text{root}_u$ 的路径现在实际上遍历了 $\\text{root}_v \\leftarrow \\dots \\leftarrow v - u \\rightarrow \\dots \\rightarrow \\text{root}_u$。从 $\\text{root}_v$ 到 $\\text{root}_u$ 的路径长度的奇偶性是三个部分的奇偶性的异或和：从 $v$ 到 $\\text{root}_v$ 的路径（奇偶性为 $\\text{parity}_v$）、边 $(u,v)$（奇偶性为 1）以及从 $u$ 到 $\\text{root}_u$ 的路径（奇偶性为 $\\text{parity}_u$）。因此，我们设置 `parity[root_v]` = $\\text{parity}_u \\oplus \\text{parity}_v \\oplus 1$。\n3. **情况 B：相同分量 ($\\text{root}_u = \\text{root}_v$)**。该边被添加到一个已有的分量内。这将创建一个环。在 DSU 树结构中，$u$ 和 $v$ 之间的路径长度的奇偶性为 $\\text{parity}_u \\oplus \\text{parity}_v$。添加边 $(u,v)$（长度为 1）会创建一个长度奇偶性为 $(\\text{parity}_u \\oplus \\text{parity}_v \\oplus 1) \\pmod 2$ 的环。该环是奇数环，当且仅当 $\\text{parity}_u \\oplus \\text{parity}_v = 0$，这可以简化为 $\\text{parity}_u = \\text{parity}_v$。这个条件意味着，在现有分量的二染色中，$u$ 和 $v$ 被强制要求具有相同的颜色。在它们之间添加一条边会产生一个无法解决的冲突。该图不再是二分图。\n\n一个特殊情况是自环 $(u,u)$，它是一个长度为 1 的环。这是一个奇数环，因此任何包含自环的图都不是二分图。\n\n最终的算法流程如下：对于每个具有 $n$ 个顶点和 $m$ 条边的序列的测试用例，我们为 $n$ 个顶点初始化 DSU 结构。然后我们从 $t=1$ 到 $m$ 遍历这些边。对于索引为 $t$ 的每条边 $(u,v)$：\n- 如果 $u=v$，我们遇到了一个自环。图变为非二分图。我们报告 $t$ 并终止处理该测试用例。\n- 否则，我们执行 `union(u, v)` 操作。如果它返回 `False`（表明存在冲突），我们报告 $t$ 并终止。\n- 如果循环完成而没有任何冲突，则所有图 $G_1, \\dots, G_m$ 都是二分图。我们报告 $0$。", "answer": "```python\nimport numpy as np\n\n# Although numpy is available, it is not used in this solution.\n# The solution uses only standard Python libraries.\n\nclass BipartiteDSU:\n    \"\"\"\n    An augmented Disjoint Set Union (DSU) data structure to track graph\n    bipartiteness. It checks for odd cycles as edges are added.\n    \"\"\"\n    def __init__(self, n):\n        \"\"\"\n        Initializes the DSU for n vertices (labeled 1 to n).\n        \n        Args:\n            n (int): The number of vertices.\n        \"\"\"\n        # Vertices are 1-indexed, so arrays are of size n+1.\n        self.parent = list(range(n + 1))\n        # self.parity[i] stores the parity of path length from node i to its parent.\n        # This is equivalent to color difference: 0 for same color, 1 for different.\n        self.parity = [0] * (n + 1)\n\n    def find(self, i):\n        \"\"\"\n        Finds the root of the set containing i and computes the parity of the\n        path from i to the root. Implements path compression.\n\n        Args:\n            i (int): The vertex to find.\n\n        Returns:\n            tuple[int, int]: A tuple (root, parity) where root is the\n                             representative of the set and parity is the path\n                             parity from i to the root.\n        \"\"\"\n        if self.parent[i] == i:\n            return i, 0\n        \n        # Recurse to find the root and the parity from parent[i] to the root.\n        root, parent_parity = self.find(self.parent[i])\n        \n        # Path Compression: Set the parent of i directly to the root.\n        self.parent[i] = root\n        \n        # Update Parity: The new parity of i is the XOR sum of its old\n        # parity (relative to its old parent) and its old parent's parity\n        # (relative to the root).\n        self.parity[i] ^= parent_parity\n        \n        return self.parent[i], self.parity[i]\n\n    def union(self, u, v):\n        \"\"\"\n        Processes the addition of an edge (u, v) and checks for conflicts\n        with the bipartite property.\n\n        Args:\n            u (int): The first vertex of the edge.\n            v (int): The second vertex of the edge.\n\n        Returns:\n            bool: True if the graph remains bipartite after adding the edge,\n                  False if an odd cycle is created.\n        \"\"\"\n        root_u, parity_u = self.find(u)\n        root_v, parity_v = self.find(v)\n\n        if root_u != root_v:\n            # The vertices are in different components. Merging them will not\n            # create a cycle, so the graph remains bipartite.\n            self.parent[root_v] = root_u\n            \n            # The new parity for root_v is determined by the path from root_v to\n            # root_u, which goes through v and u.\n            # Path: root_v -- v -- u -- root_u\n            # Parity(root_v -> root_u) = Parity(v-root_v) ^ Parity(u-v) ^ Parity(u-root_u)\n            self.parity[root_v] = parity_u ^ parity_v ^ 1\n            return True\n        else:\n            # The vertices are already in the same component. Adding an edge\n            # will create a cycle. The graph becomes non-bipartite if this\n            # cycle is of odd length. This occurs if u and v have the same\n            # parity relative to their common root.\n            if parity_u == parity_v:\n                return False  # Conflict: odd cycle detected.\n            return True # Consistent edge, no new information.\n\ndef solve():\n    \"\"\"\n    Main function to run the bipartite test on all specified test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        (6, [(1,2),(2,3),(3,4),(4,5),(5,6),(6,1),(1,3)]),\n        # Test case 2\n        (5, [(1,2),(2,3),(3,4),(4,5)]),\n        # Test case 3\n        (3, [(1,2),(2,2),(2,3)]),\n        # Test case 4\n        (4, [(1,2),(2,3),(3,1),(4,1)]),\n        # Test case 5\n        (4, [(1,2),(2,3),(1,2),(3,4),(4,1),(2,4)]),\n        # Test case 6\n        (3, []),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        dsu = BipartiteDSU(n)\n        result_t = 0\n        for i, edge in enumerate(edges):\n            t = i + 1\n            u, v = edge\n\n            # A self-loop is an odd cycle of length 1.\n            if u == v:\n                result_t = t\n                break\n\n            if not dsu.union(u, v):\n                # union returns False if a conflict (odd cycle) is found.\n                result_t = t\n                break\n        \n        results.append(result_t)\n\n    # Format the final output string as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3216756"}]}