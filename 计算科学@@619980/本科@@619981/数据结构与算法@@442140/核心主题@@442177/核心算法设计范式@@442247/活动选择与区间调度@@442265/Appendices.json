{"hands_on_practices": [{"introduction": "我们从区间调度问题最核心的形式开始：无权重的活动选择。这个练习的目标是，在一系列潜在的活动中，选出数量最多的互不冲突的活动。通过这个实践[@problem_id:3202897]，你将从基本原理出发，推导并应用经典的贪心策略——优先选择结束时间最早的活动，这是掌握该领域所有更复杂变体的基石。", "problem": "一个调度系统接受的活动被建模为实数线上的半开区间。对于任意两个区间 $[a,b)$ 和 $[c,d)$，它们是兼容的（不重叠的）当且仅当 $b \\le c$ 或 $d \\le a$。一个调度是两两兼容的区间的集合。一个容器区间 $[S,F)$ 将可接受的活动限制在完全包含于其中的活动，即每个选定的区间 $[s,f)$ 都必须满足 $S \\le s \\text{ 且 } f \\le F$。\n\n仅根据这些基本定义，推导出一个正确的方法来确定在给定容器区间内可以容纳的两两兼容活动的最大可能数量。然后将您的方法应用于下面的具体实例，并计算其最大基数。\n\n使用上述的半开区间模型。考虑容器区间 $[S,F) = [2,19)$ 以及以下以开始-结束对 $(s,f)$ 形式给出的候选活动集：\n- $(1,4)$\n- $(2,5)$\n- $(3,7)$\n- $(5,9)$\n- $(6,10)$\n- $(8,11)$\n- $(8,12)$\n- $(11,13)$\n- $(12,14)$\n- $(13,16)$\n- $(15,18)$\n- $(17,20)$\n- $(16,19)$\n- $(0,3)$\n- $(4,5)$\n- $(7,8)$\n- $(10,11)$\n- $(14,15)$\n- $(18,19)$\n- $(19,21)$\n- $(2,3)$\n- $(3,4)$\n- $(5,6)$\n- $(6,7)$\n- $(9,10)$\n- $(12,13)$\n- $(13,14)$\n- $(16,17)$\n- $(11,12)$\n- $(4,6)$\n\n你的最终答案必须是一个整数，等于完全包含在 $[2,19)$ 内的两两兼容区间的最大数量。无需四舍五入，也无需单位。在最终的方框答案中仅填写该整数。", "solution": "### **方法推导**\n\n该问题旨在寻找一个最大规模的活动子集，使得子集中的任意两个活动都不重叠。这是一个典型的活动选择问题，可以使用贪心算法得到最优解。能够产生最优解的贪心策略是总是选择结束时间最早的活动。这个选择为其他活动留下了最多的可用时间。\n\n算法如下：\n1.  **筛选**：首先，从候选活动集中筛选出所有完全包含在容器区间 $[S, F) = [2, 19)$ 内的活动。一个活动 $[s, f)$ 是有效的，如果 $2 \\le s \\text{ 且 } f \\le 19$。\n2.  **排序**：将所有有效活动按其结束时间 $f$ 的非递减顺序排序。\n3.  **选择**：初始化一个空的解集和一个变量 `last_finish_time`，其值为容器的开始时间 $S=2$。遍历排序后的活动列表。对于每个活动，如果它的开始时间 `s` 大于或等于 `last_finish_time`，则选择该活动，将其加入解集，并更新 `last_finish_time` 为该活动的结束时间 `f`。\n4.  **计数**：最终解集中的活动数量即为最大可能数量。\n\n### **应用于具体实例**\n\n**1. 筛选活动**\n根据容器区间 $[2, 19)$，我们从给定的30个候选活动中筛选出有效的活动。有效的活动必须满足 $2 \\le s$ 且 $f \\le 19$。\n有效活动包括：\n$[2,5), [3,7), [5,9), [6,10), [8,11), [8,12), [11,13), [12,14), [13,16), [15,18), [16,19), [4,5), [7,8), [10,11), [14,15), [18,19), [2,3), [3,4), [5,6), [6,7), [9,10), [12,13), [13,14), [16,17), [11,12), [4,6)$。\n无效活动包括：\n$(1,4), (17,20), (0,3), (19,21)$。\n\n**2. 按结束时间排序有效活动**\n将26个有效活动按结束时间 $f$ 排序：\n$[2,3), [3,4), [2,5), [4,5), [5,6), [4,6), [3,7), [6,7), [7,8), [5,9), [6,10), [9,10), [8,11), [10,11), [8,12), [11,12), [11,13), [12,13), [12,14), [13,14), [14,15), [13,16), [16,17), [15,18), [16,19), [18,19)$。\n\n**3. 贪心选择过程**\n初始化已选活动计数为 $0$，最后一个活动的结束时间 `last_finish_time` 为 $2$。\n1.  选择 **[2, 3)**。`last_finish_time` = 3。计数 = 1。\n2.  选择 **[3, 4)**。`last_finish_time` = 4。计数 = 2。\n3.  选择 **[4, 5)**。`last_finish_time` = 5。计数 = 3。\n4.  选择 **[5, 6)**。`last_finish_time` = 6。计数 = 4。\n5.  选择 **[6, 7)**。`last_finish_time` = 7。计数 = 5。\n6.  选择 **[7, 8)**。`last_finish_time` = 8。计数 = 6。\n7.  选择 **[9, 10)**。`last_finish_time` = 10。计数 = 7。\n8.  选择 **[10, 11)**。`last_finish_time` = 11。计数 = 8。\n9.  选择 **[11, 12)**。`last_finish_time` = 12。计数 = 9。\n10. 选择 **[12, 13)**。`last_finish_time` = 13。计数 = 10。\n11. 选择 **[13, 14)**。`last_finish_time` = 14。计数 = 11。\n12. 选择 **[14, 15)**。`last_finish_time` = 15。计数 = 12。\n13. 选择 **[16, 17)**。`last_finish_time` = 17。计数 = 13。\n14. 选择 **[18, 19)**。`last_finish_time` = 19。计数 = 14。\n\n算法终止。最终选定的活动总数为14。\n一个最优调度方案是：\n$\\{ [2,3), [3,4), [4,5), [5,6), [6,7), [7,8), [9,10), [10,11), [11,12), [12,13), [13,14), [14,15), [16,17), [18,19) \\}$。\n\n最大基数为 $14$。", "answer": "$$\\boxed{14}$$", "id": "3202897"}, {"introduction": "仅仅记住一个算法是不够的，真正的掌握来自于理解它为什么有效，以及为什么其他看似合理的策略会失败。这个练习是一个批判性思维挑战，旨在让你构建一个反例，证明“最早开始时间”这个直观的贪心策略可能导致极差的结果。通过分析这种失败模式[@problem_id:3202999]，你将更深刻地体会到“最早结束时间”策略的精妙之处。", "problem": "考虑最大基数区间调度问题：给定实数轴上的一个有限区间集合，每个区间由一个开始时间 $s(I)$ 和一个结束时间 $f(I)$ 指定，其中 $s(I) < f(I)$。目标是找到一个两两不重叠（兼容）的区间的子集，其基数（即区间的数量）最大。\n\n请分析以下两种贪心策略：\n1. **最早开始时间（EST）**：重复选择开始时间最早的、与已选区间兼容的区间。\n2. **最早结束时间（EFT）**：重复选择结束时间最早的、与已选区间兼容的区间。\n\n已知EFT策略总能产生最优解。你的任务是评估EST策略。以下哪个选项最准确地描述了EST策略的性能，并提供了支持该描述的最小反例结构？\n\nA. EST策略可能产生任意次优的解。一个证明 $\\Theta(n)$ 次优性的输入族，由一个长区间和 $n$ 个与其冲突但两两兼容的短区间组成。导致此失败的最小结构是一个长区间与两个两两兼容的短区间冲突。\n\nB. EST策略也是最优的。它只是EFT策略在输入按开始时间而非结束时间排序时的等价形式。\n\nC. EST策略是次优的，但其性能不会比最优解差于一个常数因子。任何由 $n$ 个完全相同的区间 $[0,1]$ 组成的输入集都证明了这一点。\n\nD. EST策略是次优的，但仅在区间重叠时出现。对于任意一组两两不重叠的区间，它都能找到最优解。", "solution": "该问题要求分析用于最大基数区间调度问题的“最早开始时间”（EST）贪心策略的性能。公认的最优算法是“最早结束时间”（EFT）策略。我们需要确定EST策略的次优程度，并识别导致其失败的最小反例结构。\n\n让我们来分析EST策略的失败模式。EST策略会选择所有可用区间中开始时间最早的那个。这个选择是局部最优的，但可能是短视的。如果这个最早开始的区间非常长，它可能会与许多其他本来可以被选中的、较短且互不冲突的区间发生重叠。一旦选择了这个长区间，所有与之冲突的短区间都不能再被选择，这可能导致最终解的规模远小于最优解。\n\n**构造一个反例：**\n考虑以下区间集合：\n- 一个长区间：$I_{long} = [0, M]$，其中 $M$ 是一个较大的数。\n- 两个短区间：$I_1 = [1, 2]$ 和 $I_2 = [2, 3]$。\n\n在这个例子中：\n- EST策略会首先选择 $I_{long}$，因为它的开始时间为0，是最早的。一旦选择了 $I_{long}$，就无法再选择 $I_1$ 或 $I_2$ 了，因为它们都与 $I_{long}$ 重叠。因此，EST策略得到的解是 $\\{I_{long}\\}$，大小为1。\n- 最优解是选择两个互不冲突的短区间 $\\{I_1, I_2\\}$，其大小为2。\n\n这个最小结构（一个长区间与两个互不冲突的短区间重叠）证明了EST策略是次优的。\n\n**分析次优程度：**\n我们可以将这个例子扩展，以证明EST策略可以做到任意差。考虑一个由 $n+1$ 个区间组成的集合：\n- 一个长区间：$I_{long} = [0, n+1]$。\n- $n$ 个短区间：$I_i = [i, i+1]$，对于 $i=1, 2, \\dots, n$。\n\n分析如下：\n- EST策略会选择开始时间最早的 $I_{long}$。解为 $\\{I_{long}\\}$，大小为1。\n- 最优解是选择所有 $n$ 个短区间 $\\{I_1, I_2, \\dots, I_n\\}$，因为它们两两互不冲突。解的大小为 $n$。\n\n最优解的大小与EST解的大小的比率为 $n/1 = n$。由于 $n$ 可以任意大，这表明EST策略的性能可以比最优解差一个与问题规模成正比的因子，即 $\\Theta(n)$。因此，EST策略可能产生任意次优的解。\n\n现在我们评估给出的选项：\n\n- **A**: 该选项正确地指出EST策略可能产生任意次优的解，并给出了一个正确的证明其 $\\Theta(n)$ 次优性的输入族（一个长区间和 $n$ 个短区间）。它还正确地识别了导致失败的最小结构（一个长区间与两个两两兼容的短区间冲突）。这是正确的分析。\n- **B**: 该选项是错误的。EST不是最优的，反例已经证明了这一点。\n- **C**: 该选项错误地声称次优性受常数因子限制。我们的分析表明它可以是 $\\Theta(n)$。此外，它给出的例子（$n$ 个相同区间）并不能证明EST的次优性，因为在这种情况下，EST和最优解都会选择一个区间。\n- **D**: 该选项的前半部分是正确的（EST是次优的），但后半部分是无关紧要的。如果所有区间都两两不重叠，任何合理的算法（包括EST）都会选择所有区间，从而得到最优解。这个选项没有抓住EST策略失败的本质。\n\n因此，选项A提供了最准确和最完整的描述。", "answer": "$$\\boxed{A}$$", "id": "3202999"}, {"introduction": "当活动具有不同的价值或权重时，简单的贪心算法往往会失效，因为选择一个结束早但价值低的活动可能不是最优的。这项高级练习将我们带入带权重的区间调度问题，这需要一种更强大的技术：动态规划。此外，该问题[@problem_id:3203016]设置在环形时间轴上，进一步考验你将复杂拓扑结构分解为可解的线性子问题的能力。", "problem": "要求您实现一个程序，计算在环形日上的一组非重叠时间窗口的最大总权重。每个窗口是长度为 $T = 24$ 小时的圆上的一个区间。区间可能会跨越 $0$ 点边界（例如，从 22 点到 3 点的区间会跨越深夜和清晨）。每个区间都有一个非负整数权重，目标是选择一个互不重叠的区间子集，使其权重之和最大化。\n\n基本原理和定义：\n- 一天被建模为周长 $T = 24$ 的圆，时间以整数小时为单位，模 $24$ 计算。每个区间表示为圆上的一个半开弧 $[s_i, e_i)$，其中 $s_i, e_i \\in \\{0,1,\\dots,23\\}$。区间包含其起点，但不包含其终点。如果 $s_i \\le e_i$，则该区间为非跨越区间，对应于 $[0,24)$ 上的线性区间 $[s_i, e_i)$。如果 $s_i > e_i$，则该区间为跨越区间，对应于并集 $[s_i,24) \\cup [0, e_i)$。\n- 如果两个区间在圆上交集的测度为零，则认为它们不重叠；在半开约定下，允许在端点处精确接触，这不构成重叠。\n- 问题要求计算一组两两不重叠区间的最大可能权重之和。权重为整数。\n\n基于这些定义（这些是区间调度的标准定义），您必须从第一性原理出发，推导出一个能正确处理环形特性的方法。您不能依赖任何未经证实的捷径；相反，您必须：\n- 将您的方法建立在标准的线性带权区间调度公式之上，该公式在线性问题上通过按结束时间排序和基于前驱索引的动态规划来解决。\n- 仅使用上述定义和关于环形区间的基本逻辑推导，论证如何将环形问题无损最优性地归约为一个或多个线性实例。\n\n实现要求：\n- 假设 $T = 24$。所有区间端点 $s_i$ 和 $e_i$ 均为 $[0,24)$ 内的整数，所有权重 $w_i$ 均为非负整数。\n- 如上所述，将每个区间解释为圆上的半开区间 $[s_i, e_i)$（包含起点，不包含终点）。\n- 您的程序不得读取任何输入。它必须评估程序中嵌入的固定测试套件，并按要求格式打印结果。\n\n测试套件：\n对于每个测试用例，给定一个三元组列表 $(s_i, e_i, w_i)$，其中 $s_i$ 和 $e_i$ 是开始和结束小时， $w_i$ 是权重。所有时间都以小时为单位，模 $24$ 计算。\n\n- 测试用例 $1$（混合跨越和非跨越区间）：\n  $[(1,5,4), (4,7,2), (6,10,4), (11,13,2), (22,3,10), (3,6,3), (13,18,8), (18,22,3), (20,2,9)]$。\n- 测试用例 $2$（仅非跨越区间，线性行为）：\n  $[(0,5,5), (1,2,2), (2,4,4), (4,7,3), (6,9,6), (9,12,5)]$。\n- 测试用例 $3$（所有均为跨越区间；最多只能选择一个）：\n  $[(22,2,3), (23,1,5), (20,4,7)]$。\n- 测试用例 $4$（边界接触；半开语义允许链接）：\n  $[(0,6,1), (6,12,1), (12,18,1), (18,0,1)]$。\n- 测试用例 $5$（权衡：重的非跨越区间链与单个重的跨越区间）：\n  $[(1,8,10), (8,16,10), (16,23,10), (20,3,15)]$。\n\n要求的最终输出：\n- 对于每个测试用例，计算一个整数：在 $24$ 小时环上的非重叠约束下可实现的最大总权重。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[x_1,x_2,x_3,x_4,x_5]$，其中 $x_k$ 是测试用例 $k$ 的结果。", "solution": "### **方法推导**\n\n问题是在一个圆上找到不重叠区间的最大权重子集。我们首先陈述该问题更简单的线性版本的既定解法，然后我们将演示如何将环形问题归约为一个或多个线性问题实例。\n\n**1. 线性带权区间调度（WIS）问题**\n\n标准的WIS问题考虑一条直线上的 $n$ 个区间集合，每个区间都有开始时间 $s_i$、结束时间 $f_i$ 和权重 $w_i$。目标是找到一个总权重最大的非重叠区间子集。典型的解法使用动态规划。\n\n1.  **排序**：按结束时间对区间进行非递减排序。设排序后的区间为 $I_1, I_2, \\dots, I_n$。\n\n2.  **前驱函数**：对于每个区间 $I_i$，定义 $p(i)$ 为与 $I_i$ 兼容（即不重叠）的最新区间 $I_j$（其中 $j < i$）的索引。形式上，$p(i) = \\max(\\{j < i \\mid f_j \\le s_i\\} \\cup \\{-1\\})$。值 $-1$ 表示不存在这样的前驱。通过对排序后的结束时间进行二分搜索，可以为所有 $i$ 高效地计算出 $p(i)$ 的值。\n\n3.  **动态规划递推**：设 $DP[i]$ 为从前 $i$ 个区间 $\\{I_1, \\dots, I_i\\}$ 中选择的兼容子集的最大权重。递推关系为：\n    $$DP[i] = \\max(w_i + DP[p(i)], DP[i-1])$$\n    其中我们定义 $DP[-1] = 0$。第一项代表选择区间 $I_i$ 的情况，第二项代表不选择 $I_i$ 的情况。\n\n线性WIS问题的解是 $DP[n-1]$ 的值。\n\n**2. 将环形WIS归约为线性WIS**\n\n环形问题的关键特征是存在“跨越”区间，即那些 $s_i > e_i$ 的区间。一个关键的观察是，任意两个跨越区间必定重叠，因为它们都覆盖了时间点0。因此，任何有效的非重叠区间集最多只能包含**一个**跨越区间。\n\n这个观察使我们能够将寻找最优解的过程划分为互斥的几种情况：\n\n**情况1：最优解不包含任何跨越区间。**\n如果最优解仅由非跨越区间组成，那么所有这些区间都位于线性段 $[0, T)$ 上。这个问题就精确地是标准的线性WIS问题。我们可以使用上述动态规划方法来解决它。\n\n**情况2：最优解恰好包含一个跨越区间。**\n设所选的单个跨越区间为 $I_j = [s_j, e_j)$，权重为 $w_j$。包含 $I_j$ 会使得与弧 $[s_j, T) \\cup [0, e_j)$ 重叠的其他区间都不能被选择。这实际上是在圆上留下了一个连续的线性段 $[e_j, s_j)$ 可供调度。因此，问题归约为在时间线 $[e_j, s_j)$ 上，为所有完全包含在此段内的非跨越区间求解一个线性WIS问题。该子问题的解加上 $w_j$ 就是以 $I_j$ 为中心的解的总权重。我们必须对每个跨越区间都执行此计算。\n\n**总体算法**\n\n环形问题的最大总权重是在所有这些情况中找到的最大值。\n\n1.  初始化 `max_weight` 为0。\n2.  解决在范围 $[0, T)$ 上所有非跨越区间的线性WIS问题。将 `max_weight` 设置为该结果。\n3.  对于每一个跨越区间 $I_j$：\n    a. 识别出所有完全包含在线性段 $[e_j, s_j)$ 内的非跨越区间。\n    b. 对这个子集求解线性WIS问题，得到子问题的解 `sub_weight`。\n    c. 计算候选总权重为 `w_j + sub_weight`。\n    d. 更新 `max_weight = max(max_weight, w_j + sub_weight)`。\n4.  最终结果是 `max_weight`。\n\n此过程保证能找到最优解，因为它详尽地考虑了最优解的所有可能结构。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import namedtuple\n\n# Define an Interval tuple for better readability\nInterval = namedtuple('Interval', ['start', 'end', 'weight', 'id'])\n\ndef solve_linear_wis(intervals):\n    \"\"\"\n    Solves the linear weighted interval scheduling problem using dynamic programming.\n    \"\"\"\n    if not intervals:\n        return 0\n\n    # Sort intervals by their end times.\n    intervals.sort(key=lambda x: x.end)\n    n = len(intervals)\n\n    # Extract end times for efficient predecessor search.\n    end_times = [i.end for i in intervals]\n\n    # Precompute predecessors using binary search.\n    # p[i] is the index of the latest interval j  i that is compatible with i.\n    p = [-1] * n\n    for i in range(n):\n        # np.searchsorted(side='right') finds insertion point to maintain order.\n        # Intervals with end_time = intervals[i].start are compatible.\n        j = np.searchsorted(end_times, intervals[i].start, side='right')\n        if j > 0:\n            p[i] = j - 1\n\n    # DP table: dp[i] = max weight for intervals up to i.\n    dp = [0] * n\n    # Base case\n    dp[0] = intervals[0].weight\n\n    for i in range(1, n):\n        # Weight if we include the current interval\n        incl_profit = intervals[i].weight\n        pred_idx = p[i]\n        if pred_idx != -1:\n            incl_profit += dp[pred_idx]\n\n        # Weight if we exclude the current interval\n        excl_profit = dp[i-1]\n\n        dp[i] = max(incl_profit, excl_profit)\n\n    return dp[n-1]\n\ndef solve_circular_wis(intervals_raw):\n    \"\"\"\n    Solves the circular weighted interval scheduling problem by reducing it to\n    multiple linear WIS problems.\n    \"\"\"\n    T = 24\n    \n    if not intervals_raw:\n        return 0\n        \n    intervals = [Interval(s, e, w, i) for i, (s, e, w) in enumerate(intervals_raw)]\n\n    non_wrapping_intervals = [iv for iv in intervals if iv.start = iv.end]\n    wrapping_intervals = [iv for iv in intervals if iv.start > iv.end]\n\n    # Case 1: Optimal solution uses no wrapping intervals.\n    # This is a standard linear WIS problem on [0, T).\n    max_weight = solve_linear_wis(non_wrapping_intervals.copy())\n\n    # Case 2: Optimal solution uses exactly one wrapping interval.\n    # Iterate through each wrapping interval as the one chosen.\n    for wrap_iv in wrapping_intervals:\n        # If we pick wrap_iv, the remaining available time is the linear\n        # segment [wrap_iv.end, wrap_iv.start).\n        # We need to find the optimal schedule for non-wrapping intervals\n        # that fit entirely within this segment.\n        \n        sub_problem_intervals = []\n        for iv in non_wrapping_intervals:\n            # Check if the interval is fully contained in [wrap_iv.end, wrap_iv.start)\n            if iv.start >= wrap_iv.end and iv.end = wrap_iv.start:\n                sub_problem_intervals.append(iv)\n        \n        sub_problem_weight = solve_linear_wis(sub_problem_intervals)\n        \n        current_total_weight = wrap_iv.weight + sub_problem_weight\n        \n        if current_total_weight > max_weight:\n            max_weight = current_total_weight\n            \n    return max_weight\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (mixed wrapping and non-wrapping)\n        [(1, 5, 4), (4, 7, 2), (6, 10, 4), (11, 13, 2), (22, 3, 10), (3, 6, 3), (13, 18, 8), (18, 22, 3), (20, 2, 9)],\n        # Test case 2 (only non-wrapping intervals, linear behavior)\n        [(0, 5, 5), (1, 2, 2), (2, 4, 4), (4, 7, 3), (6, 9, 6), (9, 12, 5)],\n        # Test case 3 (all wrapping intervals; at most one can be chosen)\n        [(22, 2, 3), (23, 1, 5), (20, 4, 7)],\n        # Test case 4 (boundary touching; half-open semantics allow chaining)\n        [(0, 6, 1), (6, 12, 1), (12, 18, 1), (18, 0, 1)],\n        # Test case 5 (trade-off: heavy non-wrapping chain versus a single heavy wrapping interval)\n        [(1, 8, 10), (8, 16, 10), (16, 23, 10), (20, 3, 15)],\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_circular_wis(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3203016"}]}