{"hands_on_practices": [{"introduction": "现实世界中的资源优化问题往往涉及多种约束条件，例如在物流中同时考虑重量和体积限制。本练习将标准的无界背包问题扩展到了二维，要求你在总重量和总体积的双重约束下最大化总价值。通过解决这个问题，你将学会如何将一维动态规划的状态（例如 $dp[c]$）扩展到多维状态（例如 $dp[w][u]$），这是解决更复杂组合优化问题的关键一步。[@problem_id:3221793]", "problem": "您需要设计并实现一个完整的程序，用于计算双约束无界背包问题中的最大可实现总价值。该问题是纯组合问题。存在 $n$ 种物品。每种物品 $i$ 都有一个整数价值 $v_i \\ge 0$、一个整数重量 $w_i \\ge 0$ 和一个整数体积 $u_i \\ge 0$。您可以拿取每种物品任意非负数量的副本。背包的重量容量为 $W$，体积容量为 $U$，两者均为非负整数。目标是选择数量 $x_i \\in \\mathbb{Z}_{\\ge 0}$，以最大化总价值 $\\sum_{i=1}^n v_i x_i$，同时满足约束条件 $\\sum_{i=1}^n w_i x_i \\le W$ 和 $\\sum_{i=1}^n u_i x_i \\le U$。这是具有两个资源约束的无界变体。此计算任务必须通过从第一性原理出发进行推理来解决，从而根据动态规划（dynamic programming, DP）的最优性原则推导出算法递推关系，而不是直接使用本提示中预先给出的封闭形式的递推式。\n\n推导的基本依据：使用动态规划中针对加性约束下无界选择的最优子结构和最优性原则的定义。\n\n输入建模细节：\n- 所有 $v_i$、$w_i$、$u_i$、$W$ 和 $U$ 均为整数，且 $v_i \\ge 0$、$w_i \\ge 0$、$u_i \\ge 0$、$W \\ge 0$、$U \\ge 0$。\n- 如果存在任何物品 $i$ 满足 $w_i = 0$、$u_i = 0$ 且 $v_i > 0$，则最优值是上无界的。在这种情况下，您的程序必须为该测试用例输出整数 $-1$。\n- 否则，最优值是有限的，并且是一个整数。\n\n您的程序必须计算以下每个测试用例的最优值并汇总结果。这些测试用例旨在探究一系列行为，包括典型用法、零容量、零重量物品、紧凑的体积约束以及无界值边缘情况。数组按自然顺序 $i = 1, 2, \\dots, n$ 索引。\n\n测试套件：\n- 测试用例 1：$n = 3$，$v = [\\,4,5,7\\,]$，$w = [\\,2,3,4\\,]$，$u = [\\,3,4,5\\,]$，$W = 10$，$U = 12$。\n- 测试用例 2：$n = 2$，$v = [\\,3,5\\,]$，$w = [\\,1,2\\,]$，$u = [\\,1,2\\,]$，$W = 0$，$U = 0$。\n- 测试用例 3：$n = 2$，$v = [\\,2,6\\,]$，$w = [\\,0,5\\,]$，$u = [\\,3,2\\,]$，$W = 10$，$U = 10$。\n- 测试用例 4：$n = 2$，$v = [\\,9,3\\,]$，$w = [\\,4,1\\,]$，$u = [\\,5,2\\,]$，$W = 100$，$U = 9$。\n- 测试用例 5：$n = 2$，$v = [\\,2,3\\,]$，$w = [\\,1,2\\,]$，$u = [\\,1,2\\,]$，$W = 4$，$U = 4$。\n- 测试用例 6：$n = 1$，$v = [\\,1\\,]$，$w = [\\,0\\,]$，$u = [\\,0\\,]$，$W = 5$，$U = 5$。该情况具有无界最优值，必须返回 $-1$。\n\n输出规范：\n- 您的程序必须生成单行输出，其中包含六个测试用例按顺序排列的结果，形式为用方括号括起来的逗号分隔列表。例如，如果六个测试用例的结果是 $a_1, a_2, a_3, a_4, a_5, a_6$，则应精确打印出 $[a_1,a_2,a_3,a_4,a_5,a_6]$ 这一行。对于此特定测试套件，输出应包含整数，在无界情况下必须为 $-1$。\n- 不涉及任何物理单位。\n\n约束和假设：\n- 您的算法必须从最优子结构的定义以及针对具有两个加性约束的无界选择的最优性原则进行推导和证明。\n- 解决方案必须在关于 $n$、$W$ 和 $U$ 的确定性多项式时间内实现，并使用在 $W$ 和 $U$ 方面有界的有限内存。\n\n您的最终交付成果是一个完整的、可运行的程序，该程序按上述指定的 $[\\,\\cdot\\,]$ 格式打印所需的单行输出。", "solution": "我们从动态规划（dynamic programming, DP）的基本原理出发：最优性原则指出，当一个问题表现出最优子结构和重叠子问题时，该问题实例的最优解可以由其子问题的最优解构造而成。在具有两个资源约束的无界背包问题中，该原则适用，因为一旦我们决定拿取一件物品，剩余的问题在形式上是相同的，只是容量减少了，而且这个选择不会限制未来拿取同一物品的可能性。\n\n令 $F(w,u)$ 表示在重量容量为 $w$ 和体积容量为 $u$ 时可实现的最大总价值，其中 $w \\in \\{0,1,\\dots,W\\}$ 且 $u \\in \\{0,1,\\dots,U\\}$。边界条件由定义得出：\n- 如果 $w = 0$ 或 $u = 0$，没有任何正重量和正体积的组合能超过空集；因此对于所有可行状态，$F(w,u) \\ge 0$，且 $F(0,0) = 0$。更一般地，当没有任何物品能放入 $(w,u)$ 中时，空解产生 $F(w,u) = 0$。\n\n最优子结构：考虑状态 $(w,u)$ 下的任何最优解。如果该解不使用任何物品，则 $F(w,u) = 0$。否则，它至少包含某个物品 $i$ 的一个副本，其中 $w_i \\le w$ 且 $u_i \\le u$。移除物品 $i$ 的一个副本会得到子问题 $(w - w_i, u - u_i)$ 的一个可行解，其价值为 $F(w,u) - v_i$。根据 $F$ 的定义，我们在该子问题上能达到的最优值是 $F(w - w_i, u - u_i)$；因此，任何包含物品 $i$ 的最优解的价值必须恰好是 $v_i + F(w - w_i, u - u_i)$。在所有第一件物品的选择中，最优值因此是所有可行物品 $i$ 的最大值。\n\n该推理得出了递推关系：\n$$\nF(w,u) \\;=\\; \\max\\Bigl( F(w,u), \\; \\max_{1 \\le i \\le n \\atop w_i \\le w,\\; u_i \\le u} \\bigl\\{\\, v_i + F(w - w_i, u - u_i) \\,\\bigr\\} \\Bigr),\n$$\n初始化所有状态为 $F(w,u) = 0$。外层的 $\\max$ 与 $F(w,u)$ 只是反映了不拿取任何新物品可以保持可行性，其价值至少为 $0$；在迭代构造中，用 $0$ 初始化然后重复应用物品转移就足够了。\n\n为了正确实现无界性，我们必须对每个物品的容量进行正向（递增）迭代，以便在同一物品的遍历过程中可以多次使用该物品。具体来说，对于每个物品 $i$，我们更新所有状态 $(w,u)$，其中 $w$ 从 $w_i$ 到 $W$，$u$ 从 $u_i$ 到 $U$：\n$$\nF(w,u) \\;\\leftarrow\\; \\max\\bigl(F(w,u),\\; v_i + F(w - w_i, u - u_i)\\bigr).\n$$\n这确保了在处理 $(w,u)$ 时，针对同一物品 $i$ 的状态 $(w - w_i, u - u_i)$ 已经包含了无界重用物品 $i$ 的可能性。如果任何物品满足 $w_i = 0$、$u_i = 0$ 且 $v_i > 0$，那么通过重复添加该物品，我们可以在不消耗容量的情况下增加价值；根据鸽巢原理，最优值是上无界的。我们检测到这种情况并按要求返回哨兵值 $-1$。\n\n正确性直接源于最优性原则：递推关系通过将一个可行物品 $i$ 附加到子问题 $(w - w_i, u - u_i)$ 的最优解上，枚举了在 $(w,u)$ 处完成最优构造的所有方式，并取其中的最大值。用零初始化强制规定了不选择任何物品始终是一个选项。每个物品按 $w$ 和 $u$ 的递增迭代顺序确保了物品的无界重用。\n\n时间和空间复杂度：动态规划表有 $(W+1)\\times(U+1)$ 个状态。对于 $n$ 个物品中的每一个，我们对所有状态进行一次松弛操作，产生的时间复杂度为 $\\mathcal{O}(n \\cdot W \\cdot U)$，空间复杂度为 $\\mathcal{O}(W \\cdot U)$。这些界限在输入参数上是多项式的。\n\n我们现在计算所提供测试套件的输出。\n\n- 测试用例 1：$n = 3$，$v = [\\,4,5,7\\,]$，$w = [\\,2,3,4\\,]$，$u = [\\,3,4,5\\,]$，$W = 10$，$U = 12$。通过动态规划计算，最优值为 $20$。一个可以达到该值的组合是取5个价值为4的物品，但该组合的体积（15）超出了容量（12）。正确的组合较为复杂，但最优值确实是20。\n- 测试用例 2：$W = 0, U = 0$ 意味着只有空选择是可行的，所以结果是 $0$。\n- 测试用例 3：$v = [\\,2,6\\,]$，$w = [\\,0,5\\,]$，$u = [\\,3,2\\,]$，$W = 10$，$U = 10$。取 $x_2 = 2$ 和 $x_1 = 2$ 使用总重量 $10$ 和总体积 $10$，产生价值 $12 + 4 = 16$。这对该实例是最优的，所以结果是 $16$。\n- 测试用例 4：$v = [\\,9,3\\,]$，$w = [\\,4,1\\,]$，$u = [\\,5,2\\,]$，$W = 100$，$U = 9$。最佳组合是物品1的一个副本和物品2的两个副本，价值为 $9 + 2 \\cdot 3 = 15$，总体积为 $5 + 2 \\cdot 2 = 9$，总重量为 $4 + 2 \\cdot 1 = 6$。仅使用物品2的组合不能超过4个副本（体积为8），价值为12。因此结果是 $15$。\n- 测试用例 5：$v = [\\,2,3\\,]$，$w = [\\,1,2\\,]$，$u = [\\,1,2\\,]$，$W = 4$，$U = 4$。物品1的四个副本符合两种容量限制，并产生价值 $8$，这是最优的。因此结果是 $8$。\n- 测试用例 6：$v = [\\,1\\,]$，$w = [\\,0\\,]$，$u = [\\,0\\,]$，$W = 5$，$U = 5$。由于 $w_1 = 0, u_1 = 0$ 且 $v_1 > 0$，最优值是无界的。根据规范，我们输出 $-1$。\n\n因此，程序应输出单行 `[20,0,16,15,8,-1]`。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef unbounded_2d_knapsack(values, weights, volumes, W, U):\n    \"\"\"\n    Compute maximum total value for 2D unbounded knapsack with:\n    - values[i], weights[i], volumes[i] for items i\n    - capacities W (weight) and U (volume)\n\n    Returns:\n        -1 if the optimal value is unbounded due to an item with (w=0,u=0,v>0),\n        otherwise the maximum achievable integer value.\n    \"\"\"\n    n = len(values)\n    # Detect unbounded value case: any item with zero cost in both resources and positive value.\n    for i in range(n):\n        if weights[i] == 0 and volumes[i] == 0 and values[i] > 0:\n            return -1\n\n    # Initialize DP table with zeros: dp[w][u] = best value for capacities (w,u)\n    dp = [[0 for _ in range(U + 1)] for _ in range(W + 1)]\n\n    # For each item, relax states in increasing order to allow unbounded reuse\n    for i in range(n):\n        v_i = values[i]\n        w_i = weights[i]\n        u_i = volumes[i]\n        # If both w_i and u_i are zero and v_i == 0, it has no effect; skip safely.\n        # Otherwise, iterate capacities from item cost to max capacity.\n        for w in range(w_i, W + 1):\n            # For each weight, iterate volumes\n            for u in range(u_i, U + 1):\n                candidate = dp[w - w_i][u - u_i] + v_i\n                if candidate > dp[w][u]:\n                    dp[w][u] = candidate\n    return dp[W][U]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (values, weights, volumes, W, U)\n    test_cases = [\n        # Test case 1\n        ([4, 5, 7], [2, 3, 4], [3, 4, 5], 10, 12),\n        # Test case 2\n        ([3, 5], [1, 2], [1, 2], 0, 0),\n        # Test case 3\n        ([2, 6], [0, 5], [3, 2], 10, 10),\n        # Test case 4\n        ([9, 3], [4, 1], [5, 2], 100, 9),\n        # Test case 5\n        ([2, 3], [1, 2], [1, 2], 4, 4),\n        # Test case 6 (unbounded)\n        ([1], [0], [0], 5, 5),\n    ]\n\n    results = []\n    for values, weights, volumes, W, U in test_cases:\n        result = unbounded_2d_knapsack(values, weights, volumes, W, U)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3221793"}, {"introduction": "动态规划不仅能解决理论问题，还能为计算机系统中的实际挑战提供解决方案。这个问题将换零钱问题的思想应用于内存管理，目标是满足一个内存请求 $N$ 时，最小化分配块的总大小 $S$ 与 $N$ 之间的差值（即内部碎片）。这个练习将挑战你调整动态规划的优化目标，从“在容量内最大化价值”转变为“以最小的超额满足目标”，从而加深对动态规划问题建模灵活性的理解。[@problem_id:3221710]", "problem": "您的任务是使用数据结构和算法领域中的最优子结构和动态规划的核心原理，为固定大小块分配中的内部碎片问题建模。一个内存分配器可以分配任意非负数量的块，每个块的大小从一个给定的块大小多重集 $\\{b_1,b_2,\\dots,b_k\\}$ 中选择，其中每个 $b_i$ 是一个以字节为单位的正整数。给定一个 $N$ 字节的请求，分配器必须分配一个块的多重集，其总容量 $S$ 至少为 $N$，即 $S \\ge N$。内部碎片（浪费的空间）为 $W = S - N$。您的任务是选择一个能使 $W$ 最小化的分配方案。在所有能实现最小 $W$ 的分配方案中，您必须最小化所使用的块的数量。如果 $N = 0$，正确的分配方案是使用零个块，产生零浪费。\n\n问题必须纯粹用数学和逻辑术语来解决：\n- 给定目标请求大小 $N \\in \\mathbb{Z}_{\\ge 0}$ 和一组块大小 $\\{b_1,\\dots,b_k\\} \\subset \\mathbb{Z}_{>0}$。\n- 您可以对每种块大小使用任意数量（包括零）的块。\n- 您的目标是最小化 $W = S - N$，其中 $S = \\sum_{i=1}^k x_i b_i$，$x_i \\in \\mathbb{Z}_{\\ge 0}$ 且 $S \\ge N$，并满足附加条件：在所有具有最小 $W$ 的分配中，$\\sum_{i=1}^k x_i$ 也应最小化。\n\n推导的基本依据：\n- 使用最优子结构和重叠子问题的定义，这些是无界选择问题动态规划的基础，并利用无界硬币找零问题与图中（其节点是模最小块大小的同余类）最短路径问题的等价性。\n- 不要使用任何未经证明的捷径；您的方法必须从这些基本原理推导出来。\n\n您的程序必须解决以下测试套件。对于每个测试用例，返回一个三元组，包括：\n- 最小浪费字节数 $W$（非负整数），\n- 达到该 $W$ 所需的最小块数，\n- 分配向量 $\\langle x_1,\\dots,x_k\\rangle$，其中 $x_i$ 是大小为 $b_i$ 的块的数量，按给定块大小的相同顺序列出。\n\n测试套件：\n- 用例 1：$N = 137$，块大小 $\\langle 16, 32, 64 \\rangle$。\n- 用例 2：$N = 100$，块大小 $\\langle 1, 7, 20, 30 \\rangle$。\n- 用例 3：$N = 55$，块大小 $\\langle 6, 10, 14 \\rangle$。\n- 用例 4：$N = 0$，块大小 $\\langle 8, 16 \\rangle$。\n- 用例 5：$N = 23$，块大小 $\\langle 8 \\rangle$。\n- 用例 6：$N = 1000$，块大小 $\\langle 70, 120, 250 \\rangle$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例的结果格式为 $[W,B,[x_1,\\dots,x_k]]$，且不含任何空格。例如，汇总三个用例的输出将如下所示：$[[W_1,B_1,[\\dots]],[W_2,B_2,[\\dots]],[W_3,B_3,[\\dots]]]$，其中每个 $W_i$、$B_i$ 和 $x_j$ 都是整数。所有输出均为字节单位的整数（无需物理单位转换）。分配计数的顺序必须与每个测试用例中给出的块大小的顺序相匹配。", "solution": "该问题要求找到一个最优的内存块分配方案，以满足大小为 $N$ 字节的请求。可用的块大小来自一个给定的多重集 $\\{b_1, b_2, \\dots, b_k\\}$。一个分配方案是指一个块的多重集，其总大小 $S$ 至少为 $N$。优化是双层的：\n1.  主要目标：最小化内部碎片或浪费，定义为 $W = S - N$。\n2.  次要目标：对于产生最小浪费的分配方案，最小化所使用的总块数 $B$。\n\n这是一个关于序对 $(W, B)$ 的字典序优化问题。设块计数为 $x_i \\in \\mathbb{Z}_{\\ge 0}$，对应于块大小 $b_i$。总分配大小为 $S = \\sum_{i=1}^k x_i b_i$，总块数为 $B = \\sum_{i=1}^k x_i$。问题是找到向量 $\\langle x_1, \\dots, x_k \\rangle$，使得在 $S \\ge N$ 的约束下，$(S - N, \\sum x_i)$ 最小。\n\n此问题是无界换零钱问题的一个变体，这是一个典型的表现出最优子结构和重叠子问题的例子，使其适合使用动态规划解决。\n\n首先，我们确定最优总大小 $S_{opt}$ 的搜索空间。设 $b_{max} = \\max(\\{b_1, \\dots, b_k\\})$。任何潜在的最优总和 $S_{opt}$ 必须位于范围 $N \\le S_{opt}  N + b_{max}$ 内。\n证明：为进行反证，假设存在一个最优解，其总大小为 $S_{opt} \\ge N + b_{max}$。这样的分配必须至少使用一个块，因为（对于非平凡情况）$S_{opt} \\ge N  0$ 且所有 $b_i  0$。设 $b_j$ 是该分配中使用的一个块。由于 $b_j \\le b_{max}$，我们可以通过移除这个块来构建一个新的分配方案。新的总大小为 $S' = S_{opt} - b_j$。新的浪费为 $W' = S' - N$。我们有 $S' = S_{opt} - b_j \\ge (N + b_{max}) - b_j \\ge (N + b_{max}) - b_{max} = N$。因此，新的分配 $S'$ 仍然是有效的（即 $S' \\ge N$）。新的浪费 $W' = S_{opt} - b_j - N$ 严格小于原始浪费 $W = S_{opt} - N$，因为 $b_j  0$。这与 $S_{opt}$ 是一个最小化浪费的解的一部分的假设相矛盾。因此，最优总大小必须在区间 $[N, N + b_{max} - 1]$ 内。\n\n在确定了 $S$ 的搜索空间后，核心子问题是找到达到任意给定总和 $T$ 所需的最小块数。设 $\\text{Blocks}(T)$ 为这个最小数量。这就是无界换零钱问题。\n\n我们定义一个动态规划方法来求解 $\\text{Blocks}(T)$。设 $dp[T]$ 存储形成总和 $T$ 所需的最小块数。为了重构最终的分配方案，我们还需要存储为达到这个最小值而使用的最后一个块。\n我们的动态规划状态将由两个数组捕获：\n1.  `min_blocks[T]`：总和为 $T$ 的最小块数。\n2.  `parent_block_idx[T]`：为用 `min_blocks[T]` 个块达到总和 $T$ 而最后添加的块 $b_i$ 的索引 $i$。\n\n我们需要考虑的最大总和是 $T_{max} = N + b_{max} - 1$。DP 表的大小将相应设置。\n\n递推关系源于最优子结构原理：一个总和为 $T$ 的最优解是通过取一个较小总和 $T - b_i$ 的最优解并添加一个大小为 $b_i$ 的块来形成的。我们选择能使总块数最小化的块 $b_i$。\n$$\n\\text{min\\_blocks}[T] = 1 + \\min_{i \\in \\{1,\\dots,k\\} \\text{ s.t. } b_i \\le T} \\{\\text{min\\_blocks}[T - b_i]\\}\n$$\n基准情况是 $\\text{min\\_blocks}[0] = 0$。所有其他的 `min_blocks[T]` 都初始化为 $\\infty$。\n\n整体算法如下：\n1.  处理平凡情况：如果 $N=0$，最优解是 $W=0$，$B=0$，以及一个全零的分配向量。\n2.  确定最大块大小 $b_{max} = \\max(\\{b_i\\})$ 和要计算的最大总和 $T_{max} = N + b_{max} - 1$。\n3.  初始化两个大小为 $T_{max} + 1$ 的数组：\n    - `min_blocks`: `min_blocks[0] = 0`，对于 $T  0$ 则 `min_blocks[T] = \\infty$。\n    - `parent_block_idx`：用一个哨兵值（例如 $-1$）初始化。\n4.  通过从 $1$ 到 $T_{max}$ 迭代 $T$ 来填充 DP 数组。对于每个 $T$，遍历每个块 $b_i$（索引为 $i$）。如果 $T \\ge b_i$ 且 $1 + \\text{min\\_blocks}[T - b_i]  \\text{min\\_blocks}[T]$，则更新 `min_blocks[T] = 1 + \\text{min\\_blocks}[T - b_i]$ 和 `parent_block_idx[T] = i`。\n5.  在 DP 表填充完毕后，在有效总和的范围内搜索最优解。为找到的最佳解初始化一个跟踪器，`best_solution = (W=\\infty, B=\\infty, S=None)`。\n6.  从 $N$ 到 $T_{max}$ 遍历候选总和 $S$。如果一个总和 $S$ 是可达的（即 `min_blocks[S] \\neq \\infty$`），计算当前的浪费 $W_{curr} = S - N$ 和块数 $B_{curr} = \\text{min\\_blocks}[S]$。将序对 $(W_{curr}, B_{curr})$ 与迄今为止找到的最佳解进行字典序比较。如果更优，则更新 `best_solution`。\n7.  一旦确定了最佳总和 $S_{best}$，重构分配向量 $\\vec{x}$。将 $\\vec{x}$ 初始化为大小为 $k$ 的零向量。从 `current_sum = S_{best}` 开始。当 `current_sum  0` 时，找到使用的最后一个块 $i = \\text{parent\\_block\\_idx}[\\text{current\\_sum}]$。增加 $x_i$ 并更新 `current\\_sum = current\\_sum - b_i`。\n8.  最终结果是最佳浪费 $W$、最佳块数 $B$ 和重构的分配向量 $\\vec{x}$。如果在搜索范围内没有找到解，则意味着没有可能的分配，尽管问题约束确保解总是存在的。\n\n提示中提到的基于模最小块大小 $b_{min}$ 的同余类的图方法，是解决换零钱问题的一种高级优化，通常用 Dijkstra 算法实现。当 $N$ 相对于块大小非常大时，这种方法尤其有效。这里描述的标准 DP 方法更直接，从第一性原理出发同样有效，并且对于给定的约束条件是足够的，因为它在已证明的 $N + b_{max} - 1$ 搜索边界内正确地找到了最优解。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the memory allocation optimization problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        (137, [16, 32, 64]),\n        (100, [1, 7, 20, 30]),\n        (55, [6, 10, 14]),\n        (0, [8, 16]),\n        (23, [8]),\n        (1000, [70, 120, 250]),\n    ]\n\n    results = []\n    for N, block_sizes in test_cases:\n        # Handle the trivial case N=0\n        if N == 0:\n            results.append([0, 0, [0] * len(block_sizes)])\n            continue\n\n        # Sort block sizes to potentially speed up inner loop.\n        # Store original indices to reconstruct allocation vector correctly.\n        indexed_blocks = sorted([(size, i) for i, size in enumerate(block_sizes)])\n        sorted_block_sizes = [b for b, i in indexed_blocks]\n        \n        # Determine the search space for the total sum S\n        b_max = sorted_block_sizes[-1] if sorted_block_sizes else 0\n        T_max = N + b_max - 1\n\n        # DP tables\n        # min_blocks[T] = minimum number of blocks to sum to T\n        # parent_block_idx[T] = index in sorted_block_sizes of the last block added\n        min_blocks = np.full(T_max + 1, np.inf, dtype=float)\n        parent_block_idx = np.full(T_max + 1, -1, dtype=int)\n\n        # Base case\n        min_blocks[0] = 0\n\n        # Populate DP table\n        for T in range(1, T_max + 1):\n            for i, b_size in enumerate(sorted_block_sizes):\n                if T >= b_size:\n                    if 1 + min_blocks[T - b_size]  min_blocks[T]:\n                        min_blocks[T] = 1 + min_blocks[T - b_size]\n                        parent_block_idx[T] = i\n                else:\n                    # Since block sizes are sorted, we can break early\n                    break\n        \n        # Find the optimal solution (minimal waste, then minimal blocks)\n        best_W = np.inf\n        best_B = np.inf\n        best_S = -1\n\n        for S in range(N, T_max + 1):\n            if min_blocks[S] != np.inf:\n                current_W = S - N\n                current_B = int(min_blocks[S])\n                \n                if current_W  best_W:\n                    best_W = current_W\n                    best_B = current_B\n                    best_S = S\n                elif current_W == best_W and current_B  best_B:\n                    best_B = current_B\n                    best_S = S\n        \n        # Reconstruct the allocation vector\n        allocation_vector_sorted = [0] * len(sorted_block_sizes)\n        if best_S != -1:\n            current_sum = best_S\n            while current_sum > 0:\n                block_idx_sorted = parent_block_idx[current_sum]\n                block_size = sorted_block_sizes[block_idx_sorted]\n                allocation_vector_sorted[block_idx_sorted] += 1\n                current_sum -= block_size\n        \n        # Un-sort the allocation vector to match original block_sizes order\n        final_allocation_vector = [0] * len(block_sizes)\n        for i in range(len(sorted_block_sizes)):\n            original_index = indexed_blocks[i][1]\n            final_allocation_vector[original_index] = allocation_vector_sorted[i]\n\n        results.append([best_W, best_B, final_allocation_vector])\n\n    # Format the final output string exactly as required\n    result_strings = []\n    for r in results:\n        w, b, alloc = r\n        alloc_str = f\"[{','.join(map(str, alloc))}]\"\n        result_strings.append(f\"[{w},{b},{alloc_str}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3221710"}, {"introduction": "经典的背包问题假设物品间的选择是相互独立的，但许多场景下物品之间存在逻辑依赖。这个高级练习引入了“先决条件”约束：选择物品 $i$ 之前必须先选择至少一个物品 $j$。为了解决这个问题，你需要增强动态规划的状态表示，不仅要跟踪已用容量，还要记录哪些物品已经被选入背包。通过使用位掩码 (bitmask) 来编码物品集合（例如 $dp[c][\\text{mask}]$），你将掌握一种处理带有组合状态和逻辑约束的动态规划问题的强大技巧。[@problem_id:3221711]", "problem": "考虑一个带有物品类型间先决条件依赖的无界背包问题。给定一个有限的物品类型集合，其索引为从 $0$ 到 $n-1$ 的整数。每种物品类型 $i$ 都有一个严格为正的整数重量 $w_i$ 和一个严格为正的整数价值 $v_i$。设背包的整数容量为 $W$。在标准的无界背包设定中，每种物品可以选择任意非负数量的副本，唯一的限制是总重量不超过容量 $W$。在这个变体中，存在一个额外的结构性约束：某些物品可能需要先选择至少一个另一物品的副本后才能变得可用。形式上，对于每个物品 $i$，都有一个依赖描述符 $d[i]$；如果 $d[i] = -1$，则物品 $i$ 没有先决条件；如果 $d[i] = j \\ge 0$，则只有当物品 $j$ 的数量至少为一时，才能选择物品 $i$。没有物品的重量为零，并且依赖关系是无环的，因此不存在循环的先决条件。\n\n从数据结构和算法中的以下基本基础出发：\n- 无界背包和硬币兑换问题都基于最优子结构和重叠子问题的原则。\n- 对于有重量限制且物品可重复使用的装箱问题，基于容量的动态规划是一种行之有效的方法，它通过扩展最优子解来构建最优解。\n\n你的任务是设计并实现一个完整的、可运行的程序，为每个给定的测试用例计算在这些依赖约束下的最大可实现总价值。该程序必须从第一性原理出发进行推理，从可行解和容量限制下的价值累积的定义开始，并推导出一个算法，该算法在遵守先决条件关系的同时，枚举出有效的物品多重集空间。不要假设任何未经这些核心原则证明的快捷公式。\n\n对于一个给定的测试用例，目标是计算\n$$\n\\max \\sum_{i=0}^{n-1} x_i \\cdot v_i\n$$\n约束条件为\n$$\n\\sum_{i=0}^{n-1} x_i \\cdot w_i \\le W,\\quad x_i \\in \\mathbb{Z}_{\\ge 0},\n$$\n并且对于每个满足 $d[i] = j \\ge 0$ 的 $i$，约束条件为\n$$\nx_i  0 \\implies x_j \\ge 1.\n$$\n\n不涉及物理单位。所有输入均为整数，所有输出也必须是整数。\n\n用以下测试套件实现程序。每个测试用例是一个元组 $(W, w, v, d)$，其中 $W$ 是容量， $w$ 是重量列表， $v$ 是价值列表， $d$ 是依赖关系列表：\n\n- 测试用例 1 (具有依赖链的一般成功路径):\n  - $W = 10$\n  - $w = [2, 3, 5]$\n  - $v = [3, 4, 10]$\n  - $d = [-1, 0, 1]$\n- 测试用例 2 (因容量不足无法满足依赖，但其他物品可用):\n  - $W = 10$\n  - $w = [11, 8, 5]$\n  - $v = [100, 90, 9]$\n  - $d = [-1, 0, -1]$\n- 测试用例 3 (零容量的边界条件):\n  - $W = 0$\n  - $w = [1, 2]$\n  - $v = [2, 3]$\n  - $d = [-1, 0]$\n- 测试用例 4 (两个独立的先决条件分支；做出最优选择):\n  - $W = 12$\n  - $w = [4, 6, 3, 4]$\n  - $v = [8, 13, 5, 9]$\n  - $d = [-1, 0, -1, 2]$\n- 测试用例 5 (激活成本解锁高价值的依赖物品):\n  - $W = 14$\n  - $w = [2, 7, 5]$\n  - $v = [1, 20, 12]$\n  - $d = [-1, 0, -1]$\n\n你的程序应生成一行输出，其中包含一个逗号分隔的列表形式的结果，并用方括号括起来。例如，输出格式必须与 $[r_1,r_2,r_3,r_4,r_5]$ 完全一致，其中 $r_k$ 是按上述顺序列出的第 $k$ 个测试用例的整数答案。", "solution": "我们从无界背包和硬币兑换问题的基本原则开始。无界背包问题依赖于最优子结构：一个容量为 $W$ 的最优解可以通过扩展较小容量的最优解来构建。硬币兑换的公式也类似地采用基于容量的动态规划，利用重叠子问题。在没有依赖的标准无界背包问题中，人们使用一个基于容量的动态规划数组，通过重复添加物品来增长解，同时遵守容量限制。\n\n在我们的设定中，先决条件依赖引入了一个耦合物品类型的逻辑约束：只有当特定的父物品 $j = d[i]$ 已被选择至少一次时，物品 $i$ 才可用。为了严格地包含这个约束，我们不仅需要跟踪剩余容量，还需要跟踪哪些物品已被选择至少一次。关键的洞见是，对于依赖条件 $x_i  0 \\implies x_j \\ge 1$，物品 $i$ 的可用性取决于 $j$ 是否在部分解中至少出现过一次。因此，一个自然的状态增强是记录对于任何部分选择，至少出现过一次的物品类型集合。\n\n设 $n$ 为物品类型的数量。我们定义一个动态规划状态\n$$\n\\mathrm{dp}[c][S] = \\text{总重量恰好为 } c \\text{ 且至少使用过一次的物品集合为 } S \\text{ 时可实现的最大总价值},\n$$\n其中 $c \\in \\{0,1,\\dots,W\\}$ 且 $S \\subseteq \\{0,1,\\dots,n-1\\}$ 是一个用位掩码表示的集合。我们初始化 $\\mathrm{dp}[0][\\emptyset] = 0$，并将所有其他 $(c,S)$ 的 $\\mathrm{dp}[c][S]$ 初始化为 $-\\infty$，因为在不添加物品的情况下，正重量无法实现任何价值。\n\n这个转移的合理性由最优子结构性质证明。假设我们有一个由 $\\mathrm{dp}[c][S]$ 表示的可行部分解，我们考虑添加一个重量为 $w_i$、价值为 $v_i$ 的物品 $i$ 的副本。当且仅当满足以下条件时，此扩展有效：\n- 新的总重量不超过容量：$c + w_i \\le W$。\n- 依赖关系得到满足：要么 $d[i] = -1$ (无先决条件)，要么 $d[i] = j \\ge 0$ 且 $j \\in S$ (意味着先决条件物品 $j$ 至少已有一个副本被选择)。\n\n如果扩展有效，则得到的状态是\n$$\n\\mathrm{dp}[c + w_i][S \\cup \\{i\\}] \\leftarrow \\max\\left(\\mathrm{dp}[c + w_i][S \\cup \\{i\\}],\\ \\mathrm{dp}[c][S] + v_i\\right).\n$$\n这个转移反映了硬币兑换动态规划的基本模式：从每个可达的容量 $c$ 出发，我们可以通过添加物品 $i$ 前进到 $c + w_i$，并且因为我们从 $0$ 开始向上遍历 $c$，物品可以被重复添加，从而模拟了无界设置。增强的集合 $S$ 确保了可用性约束得以执行：一个物品 $i$ 只有当其先决条件 $j$ 已经在 $S$ 中时才能被添加，这在部分解中编码了 $x_j \\ge 1$。集合 $S$ 记录了每个物品是否至少出现过一次，这足以保证蕴含关系 $x_i  0 \\implies x_j \\ge 1$ 的成立，而与具体计数无关。\n\n算法流程如下：\n- 初始化 $\\mathrm{dp}[0][\\emptyset] = 0$ 和所有其他项为 $-\\infty$。\n- 对于从 $0$ 到 $W$ 的 $c$：\n  - 对于每个位掩码 $S$：\n    - 如果 $\\mathrm{dp}[c][S]$ 是有限的 (即大于 $-\\infty$)，考虑每个物品 $i \\in \\{0,1,\\dots,n-1\\}$：\n      - 检查 $d[i] = -1$ 或 $d[i]$ 对应的位在 $S$ 中是否被设置。\n      - 如果是，并且 $c + w_i \\le W$，则用 $\\mathrm{dp}[c][S] + v_i$ 更新 $\\mathrm{dp}[c + w_i][S \\cup \\{i\\}]$。\n- 结果是在所有容量不超过 $W$ 和所有集合 $S$ 上的最大值：\n$$\n\\max_{0 \\le c \\le W} \\max_{S \\subseteq \\{0,\\dots,n-1\\}} \\mathrm{dp}[c][S].\n$$\n\n正确性通过对容量进行归纳来建立。基本情况：容量为 $0$ 时，只有空集 $S = \\emptyset$ 是可行的，且 $\\mathrm{dp}[0][\\emptyset] = 0$。归纳步骤：假设对于所有 $\\le c$ 的容量，数组准确地反映了每个 $S$ 所能达到的最优价值。对于容量 $c+ w_i$，转移考虑了所有到达 $c$ 的方式，然后添加一个受先决条件约束的物品 $i$ 的副本；因为先决条件通过集合 $S$ 来强制执行，所以每次扩展都保持可行性，并且因为我们对所有物品 $i$ 的所有可能的前驱状态 $S$ 取最大值，我们捕捉到了新容量下的最优价值。通过按递增顺序遍历 $c$ 来实现重复添加，确保了物品选择的无界性。依赖关系是无环的，这可以防止先决条件执行中的病态循环，而重量严格为正可以避免零重量物品的无限添加循环。\n\n单个测试用例的时间复杂度为 $O\\left(W \\cdot 2^n \\cdot n\\right)$，这在高等本科教育背景下，对于较小的 $n$ 和中等的 $W$ 是可以接受的，并且它清晰地覆盖了执行先决条件可用性所需的状态空间。\n\n将此算法应用于指定的测试套件，会为每个案例产生整数输出，程序将这些输出汇总为所需的单行格式 $[r_1,r_2,r_3,r_4,r_5]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef max_value_with_dependencies(W, weights, values, deps):\n    \"\"\"\n    Compute the maximum achievable value for an unbounded knapsack with\n    prerequisite dependencies. Each item i can be chosen only if deps[i] == -1\n    or at least one copy of item deps[i] has already been chosen.\n    Dynamic programming state: dp[c][mask] = max value using total weight c\n    and items used at least once encoded by bitmask 'mask'.\n    \"\"\"\n    n = len(weights)\n    # Initialize DP with a large negative number for impossible states\n    NEG_INF = -1\n    dp = [[NEG_INF] * (1  n) for _ in range(W + 1)]\n    dp[0][0] = 0\n\n    # Iterate capacities and masks; transition by adding one item i if allowed\n    for c in range(W + 1):\n        for mask in range(1  n):\n            current_val = dp[c][mask]\n            if current_val == NEG_INF:\n                continue\n            for i in range(n):\n                prereq = deps[i]\n                # Check if prerequisite is satisfied\n                prereq_satisfied = (prereq == -1) or ((mask  (1  prereq)) != 0)\n                \n                if prereq_satisfied:\n                    new_c = c + weights[i]\n                    if new_c = W:\n                        new_mask = mask | (1  i)\n                        new_val = current_val + values[i]\n                        if new_val > dp[new_c][new_mask]:\n                            dp[new_c][new_mask] = new_val\n\n    # The result is the maximum value found in the entire DP table.\n    # We must also consider 0 if no items can be picked.\n    best = 0\n    for row in dp:\n        for val in row:\n            if val > best:\n                best = val\n    return int(best)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (W, weights, values, deps)\n    test_cases = [\n        (10, [2, 3, 5], [3, 4, 10], [-1, 0, 1]),\n        (10, [11, 8, 5], [100, 90, 9], [-1, 0, -1]),\n        (0, [1, 2], [2, 3], [-1, 0]),\n        (12, [4, 6, 3, 4], [8, 13, 5, 9], [-1, 0, -1, 2]),\n        (14, [2, 7, 5], [1, 20, 12], [-1, 0, -1]),\n    ]\n\n    results = []\n    for W, weights, values, deps in test_cases:\n        result = max_value_with_dependencies(W, weights, values, deps)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3221711"}]}