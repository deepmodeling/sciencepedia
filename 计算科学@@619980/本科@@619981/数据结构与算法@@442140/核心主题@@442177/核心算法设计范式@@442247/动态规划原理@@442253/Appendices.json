{"hands_on_practices": [{"introduction": "动态规划在有向无环图（DAG）上的应用是其最基本和直观的体现之一。这个练习将指导你如何利用拓扑排序来线性地处理子问题，从而解决DAG中的最长路径问题。通过这个实践，你将掌握在图结构上应用动态规划的核心思想，即按照正确的顺序解决相互依赖的子问题。[@problem_id:3230587]", "problem": "您将处理有向无环图（DAG）最长路径问题的多个实例，其中路径质量由边权重的乘积聚合定义。在每个实例中，节点由整数标记，有向边带有严格为正的实数权重。路径得分是其边权重的乘积。目标是针对指定的源节点和目标节点，确定在此乘法定义下的最大可能路径得分。如果不存在路径，则路径得分定义为 $0$。从一个节点到其自身的空路径乘积为 $1$，并且当源节点等于目标节点时，这是允许的。\n\n从以下基本原理开始：动态规划的最优性原理指出，当一个问题表现出最优子结构时，其最优解可以由其子问题的最优解构建而成。对于有向无环图，拓扑排序提供了一种处理顶点的方法，使得所有边都从排序中较早的顶点指向较晚的顶点。利用这些核心事实，推导出一个算法策略来计算从给定源节点到给定目标节点的最优乘法路径得分，并确保该方法对于任何具有正边权重的DAG都是正确的。\n\n您的程序必须实现此策略并解决以下测试套件。每个测试用例包含节点数 $n$、一个由三元组 $(u,v,w)$ 组成的边列表（描述一条从节点 $u$ 到节点 $v$ 权重为 $w$ 的有向边）、一个源节点 $s$ 和一个目标节点 $t$。不涉及物理单位。所有权重都是严格为正的实数。\n\n测试套件：\n- 案例 $1$ (存在多条竞争路径的一般情况):\n  - $n = 6$\n  - edges $= \\{(0,1,2.0),(1,2,3.0),(0,3,1.5),(3,2,2.0),(2,4,0.5),(3,4,4.0),(4,5,1.25),(1,4,1.2)\\}$\n  - $s = 0$, $t = 5$\n- 案例 $2$ (边界情况：单个节点，无边，源节点等于目标节点):\n  - $n = 1$\n  - edges $= \\{\\}$\n  - $s = 0$, $t = 0$\n- 案例 $3$ (边缘情况：目标节点无法从源节点到达):\n  - $n = 3$\n  - edges $= \\{(0,1,0.9)\\}$\n  - $s = 0$, $t = 2$\n- 案例 $4$ (权重小于 $1$ 的路径与权重大于 $1$ 的较短路径竞争):\n  - $n = 4$\n  - edges $= \\{(0,1,0.5),(1,3,0.5),(0,2,1.1),(2,3,0.95)\\}$\n  - $s = 0$, $t = 3$\n- 案例 $5$ (混合使用大权重和小权重以测试路径选择):\n  - $n = 5$\n  - edges $= \\{(0,1,10.0),(1,2,0.01),(0,3,3.0),(3,2,2.0),(2,4,0.5),(3,4,0.6)\\}$\n  - $s = 0$, $t = 4$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,result_3,result_4,result_5]$），其中每个 $result_i$是根据上述规则计算出的案例 $i$ 的最大乘法路径得分（浮点数）。", "solution": "所提出的问题是在有向无环图（DAG）中找到从源节点 $s$ 到目标节点 $t$ 的路径的最大得分。路径的得分定义为其构成边的权重之积。所有边权重都给定为严格为正的实数。此问题是 DAG 上动态规划的一个原型示例。\n\n该解决方案建立在最优性原理之上，该原理假定从节点 $u$ 到节点 $v$ 的最优路径包含从 $u$ 到路径上任何中间节点的最优路径。对于当前问题，这意味着从源 $s$ 到任何节点 $v$ 的最大乘法得分路径必须通过将从 $s$ 到 $v$ 的某个前驱节点（例如 $u$）的最大得分路径沿边 $(u,v)$ 延伸而形成。\n\n让我们定义子问题。设 $D[v]$ 为从源节点 $s$ 到给定节点 $v$ 的最大乘法路径得分。我们的目标是计算 $D[t]$。\n\n我们动态规划公式的基本情况涉及源节点 $s$ 本身。根据规定，空路径的权重乘积为 $1$。因此，到达 $s$ 的初始最大得分为 $1$。对于任何其他节点 $v \\neq s$，我们尚不知道任何从 $s$ 出发的路径，因此我们将其得分初始化为 $0$。这种初始化有两个目的：它正确地指示一个节点目前尚无法从 $s$ 到达，并且它为非负得分的最大化操作提供了一个中性元素。\n因此，初始条件为：\n$$\nD[v] =\n\\begin{cases}\n1  \\text{if } v = s \\\\\n0  \\text{if } v \\neq s\n\\end{cases}\n$$\n\n递推关系在此基础上建立。要计算 $D[v]$，我们必须考虑所有指向 $v$ 的入边。对于每条权重为 $w(u,v)$ 的边 $(u,v)$，我们可以通过延伸到 $u$ 的最佳路径来形成一条到 $v$ 的路径。这样一条路径的得分将是 $D[u] \\times w(u,v)$。因为我们寻求 $v$ 的最大可能得分，所以我们对它所有的前驱节点 $u$ 取最大值：\n$$\nD[v] = \\max_{(u,v) \\in E} \\{D[u] \\times w(u,v)\\}\n$$\n其中 $E$ 表示图中所有边的集合。这个“松弛”步骤在通过某个前驱节点找到一条更好的路径时更新 $v$ 的得分。\n\n保证正确性的关键因素是我们计算 $D[v]$ 值的顺序。 $D[v]$ 的递推关系依赖于 $v$ 的所有前驱节点 $u$ 的 $D[u]$ 值。这意味着我们必须在最终确定一个节点的分数之前，先最终确定其所有前驱节点的最优分数。在有向无环图中，拓扑排序提供了这样一种顺序。DAG 的拓扑排序是其顶点的一种线性排序，对于从顶点 $u$ 到顶点 $v$ 的每条有向边， $u$ 在排序中都出现在 $v$ 之前。\n\n通过按拓扑顺序处理顶点，我们确保在考虑顶点 $u$ 时，其所有前驱节点 $p$ 的值 $D[p]$ 都已被计算并且是最优的。因此，当我们松弛 $u$ 的出边时，我们正在传播从 $s$ 到 $u$ 的真正最优得分。\n\n完整的算法如下：\n$1$. **图表示**：根据输入的边列表构建 DAG 的邻接表表示，其中对于每个节点 $u$，我们存储一个包含所有权重为 $w$ 的出边 $(u,v)$ 的对 $(v, w)$ 的列表。\n$2$. **拓扑排序**：计算 DAG 顶点的拓扑排序。这可以使用 Kahn 算法（基于入度）或深度优先搜索（DFS）遍历来实现。设得到的有序顶点列表为 $L$。\n$3$. **初始化**：创建一个大小为 $n$（节点数）的数组 $D$，初始化为 $D[s] = 1.0$，对于所有其他顶点 $v \\neq s$，则初始化为 $D[v] = 0.0$。\n$4$. **路径得分计算**：按拓扑顺序遍历顶点 $u \\in L$。对于每个顶点 $u$，遍历其邻居 $v$（由权重为 $w(u,v)$ 的边 $(u,v)$ 连接）。执行松弛步骤：\n$$\nD[v] = \\max(D[v], D[u] \\times w(u,v))\n$$\n$5$. **最终结果**：迭代完成后，$D[t]$ 的值将是从 $s$ 到 $t$ 的最大乘法路径得分。如果 $t$ 从 $s$ 不可达，其得分 $D[t]$ 将保持其初始值 $0$（对于 $s \\neq t$）。\n\n该算法正确利用了图的无环性质和最优性原理，在线性于顶点数和边数的时间内解决问题，具体为 $O(n+m)$，其中 $n$ 是顶点数，$m$ 是边数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_max_path_score(n, edges, s, t):\n    \"\"\"\n    Calculates the maximum multiplicative path score in a DAG.\n\n    Args:\n        n (int): The number of nodes in the graph, labeled 0 to n-1.\n        edges (list of tuples): A list of (u, v, w) triples representing\n                                directed edges from u to v with weight w.\n        s (int): The source node.\n        t (int): The target node.\n\n    Returns:\n        float: The maximum multiplicative path score from s to t. Returns 0.0\n               if no path exists, and 1.0 if s equals t.\n    \"\"\"\n    if n == 0:\n        return 0.0\n\n    # Build adjacency list\n    adj = {i: [] for i in range(n)}\n    for u, v, w in edges:\n        adj[u].append((v, w))\n\n    # Step 1: Topological Sort using DFS\n    topo_order = []\n    visited = [False] * n\n\n    def dfs(u):\n        visited[u] = True\n        for v, w in adj[u]:\n            if not visited[v]:\n                dfs(v)\n        topo_order.append(u)\n\n    # The topological sort needs to be robust for disconnected components\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n    \n    # The result of DFS is a reverse topological sort\n    topo_order.reverse()\n\n    # Step 2: Initialize distances\n    # Scores for paths from source s\n    scores = np.zeros(n, dtype=float)\n    if s  n:\n        scores[s] = 1.0\n\n    # Step 3: Iterate through topologically sorted nodes to calculate scores\n    # The topological sort guarantees that we process nodes in an order\n    # such that all predecessors of a node are processed before the node itself.\n    for u in topo_order:\n        # If a node is unreachable from the source, its score will be 0,\n        # and it cannot contribute to any path scores originating from s.\n        # We only need to relax edges from nodes that have a non-zero score.\n        if scores[u] > 0:\n            for v, w in adj[u]:\n                # Relaxation step for multiplicative weights\n                new_score = scores[u] * w\n                if new_score > scores[v]:\n                    scores[v] = new_score\n    \n    if t  n:\n        return scores[t]\n    else:\n        # Target node index is out of bounds\n        return 0.0\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the DAG longest multiplicative path problem.\n    \"\"\"\n    test_cases = [\n        # Case 1 (general case with multiple competing paths)\n        {\n            \"n\": 6,\n            \"edges\": [(0, 1, 2.0), (1, 2, 3.0), (0, 3, 1.5), (3, 2, 2.0),\n                      (2, 4, 0.5), (3, 4, 4.0), (4, 5, 1.25), (1, 4, 1.2)],\n            \"s\": 0, \"t\": 5\n        },\n        # Case 2 (boundary case: single node, no edges, source equals target)\n        {\n            \"n\": 1,\n            \"edges\": [],\n            \"s\": 0, \"t\": 0\n        },\n        # Case 3 (edge case: target unreachable from source)\n        {\n            \"n\": 3,\n            \"edges\": [(0, 1, 0.9)],\n            \"s\": 0, \"t\": 2\n        },\n        # Case 4 (weights  1 compete against a shorter path with weights > 1)\n        {\n            \"n\": 4,\n            \"edges\": [(0, 1, 0.5), (1, 3, 0.5), (0, 2, 1.1), (2, 3, 0.95)],\n            \"s\": 0, \"t\": 3\n        },\n        # Case 5 (mixture of large and small weights to test path selection)\n        {\n            \"n\": 5,\n            \"edges\": [(0, 1, 10.0), (1, 2, 0.01), (0, 3, 3.0),\n                      (3, 2, 2.0), (2, 4, 0.5), (3, 4, 0.6)],\n            \"s\": 0, \"t\": 4\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_max_path_score(case[\"n\"], case[\"edges\"], case[\"s\"], case[\"t\"])\n        results.append(result)\n\n    # Format output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3230587"}, {"introduction": "经典的背包问题是动态规划的典范，但现实世界的问题往往带有额外的约束。本练习在0-1背包问题的基础上增加了一个“不相邻”选择的限制，要求你修改标准的动态规划状态转移方程。这个挑战旨在训练你如何根据新增的约束条件，灵活地调整和设计递推关系，这是解决复杂DP问题的关键能力。[@problem_id:3230647]", "problem": "给定一个从 $0$ 到 $n-1$ 索引的包含 $n$ 个物品的序列。每个物品 $i$ 都有一个正整数重量 $w_i$ 和一个非负整数价值 $v_i$。您还给定了一个非负整数容量 $C$。您必须选择一个物品子集，以最大化价值总和，但需满足两个约束条件：(i) 所选物品的重量总和最多为 $C$，以及 (ii) 所选物品中任意两个在原始索引顺序中都不相邻。邻接约束意味着如果选择了物品 $i$，那么物品 $i-1$ 和物品 $i+1$（如果存在）就不能被选择。\n\n您的任务是编写一个完整的程序，对测试套件中的每组参数，计算在这些约束条件下可实现的最大总价值。\n\n推理和设计的基本依据：\n- 动态规划（DP）的最优性原理：一个问题的任何最优解都包含其子问题的最优解。\n- 经典的 $0$-$1$ 背包问题结构，扩展了一个禁止选择相邻索引的邻接（转移）约束。\n\n使用的定义：\n- 设物品为 $i \\in \\{0,1,\\dots,n-1\\}$。\n- 设 $w_i \\in \\mathbb{Z}_{0}$ 为重量，$v_i \\in \\mathbb{Z}_{\\ge 0}$ 为价值。\n- 设 $C \\in \\mathbb{Z}_{\\ge 0}$ 为容量限制。\n\n程序的输入格式：\n- 没有外部输入。您的程序必须按照下面的规定在内部嵌入测试套件。\n\n要求的输出格式：\n- 您的程序应生成一行输出，其中包含所有测试用例的结果，格式为方括号内以逗号分隔的列表，没有空格。例如，如果结果是 $r_1$、$r_2$ 和 $r_3$，则打印 $[r_1,r_2,r_3]$。\n\n测试套件：\n- 案例 $1$（通用“理想”路径）：\n  - $w = [\\,2,1,6,4,3,5,2\\,]$\n  - $v = [\\,6,3,5,6,4,6,2\\,]$\n  - $C = 10$\n- 案例 $2$（边界容量 $0$）：\n  - $w = [\\,1,2,3\\,]$\n  - $v = [\\,5,6,7\\,]$\n  - $C = 0$\n- 案例 $3$（所有重量都超过容量）：\n  - $w = [\\,5,6,7\\,]$\n  - $v = [\\,5,20,4\\,]$\n  - $C = 4$\n- 案例 $4$（密集的邻接冲突；容量允许多个但邻接限制）：\n  - $w = [\\,1,1,1,1\\,]$\n  - $v = [\\,10,1,10,1\\,]$\n  - $C = 2$\n- 案例 $5$（单个物品，容量不足）：\n  - $w = [\\,5\\,]$\n  - $v = [\\,10\\,]$\n  - $C = 3$\n- 案例 $6$（大容量，选择由邻接而非容量驱动）：\n  - $w = [\\,1,2,3,4\\,]$\n  - $v = [\\,1,2,3,4\\,]$\n  - $C = 100$\n\n答案类型：\n- 对每个案例，输出一个等于在约束条件下可实现的最大总价值的整数。\n\n您的程序必须遵守上述输出格式规范，并将所有案例的结果按所列顺序汇总到单行打印的列表中。", "solution": "该问题是经典 0/1 背包问题的一个变种，增加了“不相邻选择”的约束。这种组合要求我们在标准的背包动态规划框架中融入处理邻接限制的逻辑。问题具有最优子结构和重叠子问题，因此适合使用动态规划解决。\n\n我们定义一个二维动态规划状态 $dp[i][c]$，表示在考虑前 $i+1$ 个物品（索引从 $0$ 到 $i$）且背包总容量为 $c$ 的情况下，可以获得的最大总价值。我们的最终目标是找到 $dp[n-1][C]$。\n\n对于每个物品 $i$（从 $0$ 到 $n-1$），我们面临两种决策：\n\n1.  **不选择物品 $i$**：在这种情况下，我们没有使用物品 $i$，因此最大价值与只考虑前 $i$ 个物品（即到索引 $i-1$ 为止）时所能获得的最大价值相同。该价值由 $dp[i-1][c]$ 给出。\n\n2.  **选择物品 $i$**：这个选择仅在当前容量 $c$ 大于或等于物品 $i$ 的重量 $w_i$ 时才可行。根据邻接约束，如果选择了物品 $i$，那么物品 $i-1$ 就不能被选择。因此，此选择的价值等于物品 $i$ 的价值 $v_i$，加上在考虑前 $i-1$ 个物品（即到索引 $i-2$ 为止）且剩余容量为 $c - w_i$ 的情况下所能获得的最大价值。该价值为 $v_i + dp[i-2][c - w_i]$。\n\n结合这两种选择，我们得到状态转移递推关系：\n$$\ndp[i][c] = \\max(dp[i-1][c], \\quad v_i + dp[i-2][c - w_i])\n$$\n其中，第二项仅在 $c \\ge w_i$ 时考虑。\n\n**基本情况与实现：**\n- 我们可以初始化一个大小为 $n \\times (C+1)$ 的 DP 表。\n- **对于 $i=0$**：我们只考虑第一个物品。如果不选，价值为0。如果选（且 $c \\ge w_0$），价值为 $v_0$。因此 $dp[0][c] = v_0$ (若 $c \\ge w_0$) 或 $0$ (否则)。\n- **对于 $i=1$**：递推关系变为 $dp[1][c] = \\max(dp[0][c], v_1)$ (若 $c \\ge w_1$)，因为 $dp[-1]$ 项可以视为0。\n- **对于 $i \\ge 2$**：完整的递推关系适用。\n\n算法的实现将涉及按顺序从 $i=0$ 到 $n-1$ 填充 DP 表。对于每个 $i$，再从 $c=0$ 到 $C$ 迭代，并应用上述递推关系，小心处理边界情况（如 $i2$）。最终的答案即为 $dp[n-1][C]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the specified dynamic programming problem for a suite of test cases.\n    \"\"\"\n    # Test suite cases: each is a tuple of (weights, values, capacity)\n    test_cases = [\n        # Case 1: general \"happy path\"\n        ([2, 1, 6, 4, 3, 5, 2], [6, 3, 5, 6, 4, 6, 2], 10),\n        # Case 2: boundary capacity 0\n        ([1, 2, 3], [5, 6, 7], 0),\n        # Case 3: all weights exceed capacity\n        ([5, 6, 7], [5, 20, 4], 4),\n        # Case 4: dense adjacency conflict\n        ([1, 1, 1, 1], [10, 1, 10, 1], 2),\n        # Case 5: single item, capacity insufficient\n        ([5], [10], 3),\n        # Case 6: large capacity, adjacency is primary constraint\n        ([1, 2, 3, 4], [1, 2, 3, 4], 100),\n    ]\n\n    results = []\n    for weights, values, capacity in test_cases:\n        result = _solve_knapsack_adjacent_constraint(weights, values, capacity)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _solve_knapsack_adjacent_constraint(w, v, C):\n    \"\"\"\n    Calculates the maximum value for the knapsack problem with adjacency constraint.\n\n    Args:\n        w: A list of positive integer weights.\n        v: A list of non-negative integer values.\n        C: A non-negative integer capacity.\n\n    Returns:\n        The maximum achievable value as an integer.\n    \"\"\"\n    n = len(w)\n\n    if n == 0 or C == 0:\n        return 0\n\n    # dp[i][c] = max value from items 0..i with capacity c\n    # Use np.int64 to prevent overflow with large values/capacities, though not strictly\n    # necessary for the given test cases, it's good practice.\n    dp = np.zeros((n, C + 1), dtype=np.int64)\n\n    # Base case: i = 0\n    # For the first item, we can take it if its weight is within capacity.\n    for c in range(w[0], C + 1):\n        dp[0, c] = v[0]\n\n    # Fill DP table for items i = 1 to n-1\n    for i in range(1, n):\n        for c in range(C + 1):\n            # Option 1: Don't take item i.\n            # The value is the best we could do with items up to i-1.\n            value_without_i = dp[i - 1, c]\n\n            # Option 2: Take item i.\n            # This is only possible if c >= w[i].\n            value_with_i = 0\n            if c >= w[i]:\n                # Value of item i itself.\n                value_with_i = v[i]\n                # Plus value from non-adjacent previous items (up to i-2).\n                if i > 1:\n                    value_with_i += dp[i - 2, c - w[i]]\n            \n            # dp[i, c] is the maximum of the two options.\n            dp[i, c] = max(value_without_i, value_with_i)\n\n    # The final answer is the max value considering all items up to n-1 and full capacity C.\n    return int(dp[n - 1, C])\n\nsolve()\n```", "id": "3230647"}, {"introduction": "动态规划不仅能找到最优解的值，还能用于分析最优解的结构和数量。这个练习将带你超越寻找单一最优解的范畴，挑战你统计所有不同最优解的数量。通过增强动态规划的状态，你将学会如何在一个DP框架内同时追踪最优值和达成该值的路径数量，从而加深对DP状态设计的理解。[@problem_id:3230550]", "problem": "您被要求修改一个标准的动态规划（DP）问题，使其目标不仅是找到一个最优解，还要计算所有不同的最优解的数量。以经典的 $0/1$ 背包问题为基础。给定一个包含 $n$ 个物品的有限集合，每个物品 $i$ 有一个整数重量 $w_i \\ge 0$ 和一个整数价值 $v_i \\ge 0$，同时给定一个非负整数容量 $C$。一个可行子集是索引的任意子集 $S \\subseteq \\{1,2,\\ldots,n\\}$，满足 $\\sum_{i \\in S} w_i \\le C$。标准目标是最大化所有可行子集的总价值 $\\sum_{i \\in S} v_i$。在此任务中，您必须计算存在多少个不同的最优子集。这里的“不同”是根据所选索引的集合来定义的：两个子集 $S$ 和 $T$ 被认为是不同的，当且仅当存在至少一个索引 $j$，使得 $j \\in S$ 且 $j \\notin T$，或者 $j \\in T$ 且 $j \\notin S$。\n\n仅从与动态规划（DP）相关的基本定义出发，特别是最优子结构和重叠子问题的原则，推导出一个正确且高效的算法。该算法针对每个输入实例，返回在不超过容量的情况下达到最大可实现总价值的不同子集的数量。您的推导必须遵循原则，不得依赖任何未经证实的捷径公式。\n\n您的程序必须是完全自包含的，不接受任何输入，并且必须处理以下固定的实例测试套件。每个实例是一个元组，包含重量列表、价值列表和容量，所有条目均为整数：\n- 实例 1：重量 $\\{3,2,2\\}$，价值 $\\{4,3,3\\}$，容量 $4$。\n- 实例 2：重量 $\\{1,1,1\\}$，价值 $\\{1,1,1\\}$，容量 $2$。\n- 实例 3：重量 $\\{5,4,4,2\\}$，价值 $\\{6,5,5,3\\}$，容量 $8$。\n- 实例 4：重量 $\\{\\}$，价值 $\\{\\}$，容量 $0$。\n- 实例 5：重量 $\\{3,3,3,3\\}$，价值 $\\{5,5,5,5\\}$，容量 $6$。\n- 实例 6：重量 $\\{2,1,2,1\\}$，价值 $\\{2,1,2,1\\}$，容量 $3$。\n- 实例 7：重量 $\\{0,0\\}$，价值 $\\{0,0\\}$，容量 $0$。\n\n对于每个实例，要求的输出是一个整数：如上定义的不同的最优子集的数量。此问题不涉及任何物理单位。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果与上述实例的顺序相同。例如，该行必须类似于 $[r_1,r_2,\\ldots,r_7]$，其中每个 $r_k$ 是实例 $k$ 的整数计数。", "solution": "我们从证明动态规划（DP）合理性的两个基本原则开始：最优子结构和重叠子问题。最优子结构原则指出，一个问题的最优解可以由其子问题的最优解构造而成。在 $0/1$ 背包问题的背景下，考虑对物品 $i$ 的决策：我们要么包含物品 $i$，要么不包含。如果我们不包含物品 $i$，那么问题就简化为对前 $i-1$ 个物品在容量为 $C$ 的情况下求解。如果我们包含物品 $i$，那么剩余容量为 $C - w_i$，子问题就简化为对前 $i-1$ 个物品在这个缩减后的容量下求解。重叠子问题原则之所以成立，是因为许多子问题 $(i,C')$ 会在不同的决策路径中被重复访问。\n\n我们必须扩展用于求最大价值的标准DP，使其也能计算达到该最大值的不同子集的数量。让我们定义一个DP状态，同时存储两个量：\n- $V[i][c]$：仅使用前 $i$ 个物品，在容量限制为 $c$ 的情况下可实现的最大总价值。\n- $K[i][c]$：在前 $i$ 个物品中，在容量限制为 $c$ 的情况下达到价值 $V[i][c]$ 的不同子集的数量。\n\n我们使用从定义中推导出的以下基本条件：\n- 对于 $i = 0$（没有物品），对于每个容量 $c \\in \\{0,1,\\ldots,C\\}$，最大价值为 $V[0][c] = 0$，因为不能拿任何物品，且只有一个子集能达到这个价值：空集。因此 $K[0][c] = 1$。\n- 对于 $c = 0$（零容量），对于每个 $i \\in \\{0,1,\\ldots,n\\}$，最大价值同样为 $0$。达到此价值的子集数量是在前 $i$ 个物品中选择一个总重量为零且不超过容量 $0$ 的子集的方法数。如果存在重量为零且价值为零的物品，那么包含或不包含这类物品都能保持可行性和价值，因此计数会相应地加倍。下面的递推关系自然地捕捉了这种行为。\n\n对于状态转移，固定 $i \\ge 1$ 和 $c \\ge 0$。考虑两种选择：\n- 不包含物品 $i$：这会得到价值 $V[i-1][c]$，计数为 $K[i-1][c]$。\n- 包含物品 $i$（如果 $w_i \\le c$）：这会得到价值 $V[i-1][c - w_i] + v_i$，计数为 $K[i-1][c - w_i]$。\n\n将这两个候选值表示为\n$$\n\\text{val\\_excl} = V[i-1][c], \\quad \\text{cnt\\_excl} = K[i-1][c],\n$$\n$$\n\\text{val\\_incl} =\n\\begin{cases}\nV[i-1][c - w_i] + v_i  \\text{if } w_i \\le c, \\\\\n-\\infty  \\text{otherwise},\n\\end{cases}\n\\quad\n\\text{cnt\\_incl} =\n\\begin{cases}\nK[i-1][c - w_i]  \\text{if } w_i \\le c, \\\\\n0  \\text{otherwise}.\n\\end{cases}\n$$\n\n然后我们设置\n$$\nV[i][c] = \\max(\\text{val\\_excl}, \\text{val\\_incl}).\n$$\n对于计数，\n$$\nK[i][c] =\n\\begin{cases}\n\\text{cnt\\_incl}  \\text{if } \\text{val\\_incl} > \\text{val\\_excl}, \\\\\n\\text{cnt\\_excl}  \\text{if } \\text{val\\_excl} > \\text{val\\_incl}, \\\\\n\\text{cnt\\_excl} + \\text{cnt\\_incl}  \\text{if } \\text{val\\_excl} = \\text{val\\_incl}.\n\\end{cases}\n$$\n\n这个递推关系的合理性解释如下：\n- 如果包含物品能严格提高价值，那么在 $(i,c)$ 处的所有最优子集都必须包含物品 $i$，其数量恰好是子问题 $(i-1, c - w_i)$ 的最优子集数量，即 $\\text{cnt\\_incl}$。\n- 如果不包含物品的方案严格占优，那么在 $(i,c)$ 处的最优子集就恰好是 $(i-1,c)$ 处的最优子集，其数量为 $\\text{cnt\\_excl}$。\n- 如果两种选择的价值相等，那么在 $(i,c)$ 处的每个最优子集要么包含物品 $i$，要么不包含它。这两个子集族是不相交的，因为它们在是否包含 $i$ 上存在差异。因此，总计数是 $\\text{cnt\\_excl} + \\text{cnt\\_incl}$ 的和。\n\n注意，如果 $w_i = 0$ 且 $v_i = 0$，那么对于任何 $c$，我们有 $\\text{val\\_incl} = \\text{val\\_excl}$ 和 $\\text{cnt\\_incl} = \\text{cnt\\_excl}$；因此递推关系得出 $K[i][c] = 2 \\cdot K[i-1][c]$，这正确地计算了包含或不包含这样一个物品都能产生最优子集，并且这些子集因索引不同而被视为不同。如果 $w_i = 0$ 但 $v_i > 0$，那么包含操作会严格提高价值，在 $(i,c)$ 处的所有最优子集都必须包含 $i$，这一点也被正确地捕捉到。\n\n正确性可以通过对 $i$ 进行归纳来证明：\n- 基本情况 $i=0$ 根据定义成立：$V[0][c] = 0$ 且 $K[0][c] = 1$。\n- 归纳步骤：假设对于所有容量 $c'$，$V[i-1][c']$ 和 $K[i-1][c']$ 都是正确的。对于容量 $c$，在 $(i,c)$ 处的任何最优子集要么不包含 $i$，对应于由 $(V[i-1][c], K[i-1][c])$ 计数的某个最优子集；要么包含 $i$（如果可行），对应于由 $(V[i-1][c-w_i], K[i-1][c-w_i])$ 计数的某个最优子集。这两种选择中的最大价值定义了 $V[i][c]$，而包含和不包含的子集族之间的不相交性证明了上述计数规则的合理性。因此，$V[i][c]$ 和 $K[i][c]$ 是正确的。\n\n该算法填充一个大小为 $(n+1) \\times (C+1)$ 的表格，每个条目的计算时间为常数时间，因此时间复杂度为 $\\mathcal{O}(n \\cdot C)$，空间复杂度为 $\\mathcal{O}(n \\cdot C)$。对于测试套件中的小型固定实例，这是可以接受的。\n\n将该方法应用于所提供的实例，得到：\n- 实例 1：通过选择两个重量为 $2$ 的物品，最大价值为 $6$；恰好有 $1$ 个最优子集，所以计数为 $1$。\n- 实例 2：通过从 $3$ 个物品中任选 $2$ 个，最大价值为 $2$；计数为 $\\binom{3}{2} = 3$。\n- 实例 3：通过选择两个重量为 $4$、价值为 $5$ 的物品，最大价值为 $10$；计数为 $1$。\n- 实例 4：没有物品且容量为 $0$，唯一的子集是空集，其最优价值为 $0$；计数为 $1$。\n- 实例 5：通过从 $4$ 个物品中任选 $2$ 个，最大价值为 $10$；计数为 $\\binom{4}{2} = 6$。\n- 实例 6：在容量 $3$ 内，通过选择一个价值为 $2$ 的物品和一个价值为 $1$ 的物品，最大价值为 $3$；共有 $4$ 对这样的组合，所以计数为 $4$。\n- 实例 7：由于两个物品的重量和价值都为零，在容量 $0$ 内，所有子集的价值都为 $0$；共有 $2^2 = 4$ 个子集，所以计数为 $4$。\n\n因此，程序应输出单行\n$$\n[1,3,1,1,6,4,4].\n$$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef count_optimal_knapsack_subsets(weights, values, capacity):\n    n = len(weights)\n    C = capacity\n    # dp_value[i][c] = best value using first i items with capacity c\n    # dp_count[i][c] = number of subsets achieving dp_value[i][c]\n    dp_value = [[0] * (C + 1) for _ in range(n + 1)]\n    dp_count = [[0] * (C + 1) for _ in range(n + 1)]\n    # Base case: with 0 items, value is 0 and exactly one subset (empty set)\n    for c in range(C + 1):\n        dp_value[0][c] = 0\n        dp_count[0][c] = 1\n\n    for i in range(1, n + 1):\n        w = weights[i - 1]\n        v = values[i - 1]\n        for c in range(0, C + 1):\n            # Exclude current item\n            val_excl = dp_value[i - 1][c]\n            cnt_excl = dp_count[i - 1][c]\n            # Include current item if feasible\n            if w = c:\n                val_incl = dp_value[i - 1][c - w] + v\n                cnt_incl = dp_count[i - 1][c - w]\n            else:\n                val_incl = float('-inf')\n                cnt_incl = 0\n            # Choose best value and set counts accordingly\n            if val_incl > val_excl:\n                dp_value[i][c] = val_incl\n                dp_count[i][c] = cnt_incl\n            elif val_excl > val_incl:\n                dp_value[i][c] = val_excl\n                dp_count[i][c] = cnt_excl\n            else:\n                # Tie: both choices produce optimal value; counts add\n                dp_value[i][c] = val_excl  # same as val_incl\n                dp_count[i][c] = cnt_excl + cnt_incl\n\n    return dp_count[n][C]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is (weights, values, capacity)\n    test_cases = [\n        ([3, 2, 2], [4, 3, 3], 4),         # Instance 1\n        ([1, 1, 1], [1, 1, 1], 2),         # Instance 2\n        ([5, 4, 4, 2], [6, 5, 5, 3], 8),   # Instance 3\n        ([], [], 0),                       # Instance 4\n        ([3, 3, 3, 3], [5, 5, 5, 5], 6),   # Instance 5\n        ([2, 1, 2, 1], [2, 1, 2, 1], 3),   # Instance 6\n        ([0, 0], [0, 0], 0),               # Instance 7\n    ]\n\n    results = []\n    for weights, values, capacity in test_cases:\n        result = count_optimal_knapsack_subsets(weights, values, capacity)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3230550"}]}