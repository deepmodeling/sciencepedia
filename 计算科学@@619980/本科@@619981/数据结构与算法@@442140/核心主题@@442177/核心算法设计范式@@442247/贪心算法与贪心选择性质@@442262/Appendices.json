{"hands_on_practices": [{"introduction": "二叉搜索树（BST）的构建是一个经典的计算问题，其标准的插入算法本质上是贪心的：每个新键都根据与当前节点的局部比较来决定其最终位置。这个练习 [@problem_id:3237674] 旨在揭示一个深刻的观点：即使是同一个简单的贪心规则，其最终结果的优劣也极大地依赖于输入数据的顺序。通过亲手构造一个性能最佳的平衡树和一个性能最差的退化树，你将直观地感受到局部最优选择的序列如何累积成截然不同的全局结构。", "problem": "考虑以下一组互不相同、全序的键：$S = \\{2, 5, 7, 9, 12, 15, 20, 22, 25, 28, 31, 33, 36, 40, 44\\}$。二叉搜索树（BST）是一种有根二叉树，用于存储键，其性质是：对于任意一个键为 $x$ 的节点，其左子树中的所有键都严格小于 $x$，其右子树中的所有键都严格大于 $x$。标准的二叉搜索树插入算法是贪心算法：给定一个新键 $k$，从根节点开始，将 $k$ 与当前节点的键进行比较，如果 $k$ 较小则移动到左孩子，如果 $k$ 较大则移动到右孩子，持续这个局部选择过程，直到找到一个可以插入 $k$ 的空位。\n\n您将使用贪心插入算法，通过两种不同的插入顺序，在集合 $S$ 上构建两棵二叉搜索树：\n\n1.  一棵退化树，通过选择一个能产生严格右偏树（一条链）的插入顺序获得。请提供一个这样的插入顺序，并论证为何贪心插入算法会为其生成一棵右偏树。\n\n2.  一棵平衡树，通过选择一个能产生完全平衡二叉搜索树（即高度为 $h$ 且拥有 $2^{h+1}-1$ 个节点，所有层都已满的完全二叉树）的插入顺序获得。请提供一个这样的插入顺序，并论证为何贪心插入算法会为其生成一棵完全平衡树。\n\n假设对集合 $S$ 中所有键的成功搜索是均匀随机的。一个键的成功搜索成本定义为执行的比较次数，对于深度为 $d$ 的节点（其中根节点深度为 $0$），该成本等于 $d+1$。\n\n计算您构建的退化树中成功搜索的平均比较次数与平衡树中成功搜索的平均比较次数之差。请用一个精确分数表示您的最终答案。无需四舍五入。", "solution": "该问题要求我们从一个给定的包含 $15$ 个键的集合 $S = \\{2, 5, 7, 9, 12, 15, 20, 22, 25, 28, 31, 33, 36, 40, 44\\}$ 出发，使用贪心插入算法构建两棵不同的二叉搜索树（BST）。然后，我们必须计算这两棵树之间成功搜索的平均搜索成本之差。键的数量为 $N=15$。对于深度为 $d$ 的键，成功搜索的成本为 $d+1$，其中根节点的深度为 $d=0$。假设搜索是均匀随机地分布在所有键上的。\n\n首先，我们分析退化的右偏树的构造和成本。\n要创建一个右偏树，其中每个节点最多只有一个右孩子，那么每个新插入的键都必须大于树中已有的所有键。贪心BST插入算法将一个键 $k$ 放置在一个键为 $x$ 的节点的右侧，如果 $k > x$。通过重复进行这种局部选择，要构建一个右孩子的链，我们必须按严格递增的顺序插入键。排序后的键集是 $(2, 5, 7, 9, 12, 15, 20, 22, 25, 28, 31, 33, 36, 40, 44)$。\n因此，一个这样的插入顺序是：$(2, 5, 7, 9, 12, 15, 20, 22, 25, 28, 31, 33, 36, 40, 44)$。\n我们来追踪插入过程：\n1. 插入 $2$：树是一个单节点，即根节点，键为 $2$。\n2. 插入 $5$：因为 $5 > 2$，它被作为 $2$ 的右孩子插入。\n3. 插入 $7$：因为 $7 > 2$，我们移动到右孩子（$5$）。因为 $7 > 5$，它被作为 $5$ 的右孩子插入。\n这个过程对所有键继续进行。每个新键由于是当前最大的，总是会从根节点遍历最右侧的路径，并被作为新的最右叶子节点插入。这就创建了一棵向右延伸的简单链状退化树。\n\n在这棵右偏树中，这些键位于深度 $d=0, 1, 2, \\ldots, 14$。键 $2$ 在深度 $0$，$5$ 在深度 $1$，依此类推，直到键 $44$ 在深度 $14$。因此，这 $15$ 个键的搜索成本（$d+1$）分别为 $1, 2, 3, \\ldots, 15$。\n由于搜索是均匀分布的，搜索任何特定键的概率是 $\\frac{1}{15}$。成功搜索的平均比较次数 $C_{\\text{degen}}$ 是所有单个搜索成本的总和除以键的总数：\n$$C_{\\text{degen}} = \\frac{1}{15} \\sum_{i=1}^{15} i$$\n使用前 $n$ 个整数求和公式 $\\sum_{i=1}^{n} i = \\frac{n(n+1)}{2}$：\n$$C_{\\text{degen}} = \\frac{1}{15} \\left( \\frac{15(15+1)}{2} \\right) = \\frac{16}{2} = 8$$\n\n接下来，我们分析完全平衡二叉搜索树的构造和成本。\n问题将完全平衡二叉搜索树定义为一棵所有层都已满的完全二叉树。这样一棵高度为 $h$ 的树的节点数是 $2^{h+1}-1$。我们的集合有 $N=15$ 个键，由于 $15 = 2^{3+1}-1$，可以形成一棵高度为 $h=3$ 的完全平衡二叉搜索树。\n\n为了使用贪心插入法构建这棵树，我们必须选择一个能将正确的键放置在正确位置的插入顺序。平衡二叉搜索树的根必须是排序后键的中位数。其左右子树中的键必须以同样的方式递归地构建。这表明插入顺序应遵循目标平衡树的先序遍历。\n排序后的键集是 $S = (2, 5, 7, 9, 12, 15, 20, 22, 25, 28, 31, 33, 36, 40, 44)$。\n$15$ 个键的中位数是第 $\\frac{15+1}{2} = 8$ 个键，即 $22$。这将是根节点。\n左子树将包含比 $22$ 小的 $7$ 个键：$\\{2, 5, 7, 9, 12, 15, 20\\}$。其根将是它们的中位数，即第 $4$ 个键 $9$。\n右子树将包含比 $22$ 大的 $7$ 个键：$\\{25, 28, 31, 33, 36, 40, 44\\}$。其根将是它们的中位数，即第 $4$ 个键 $33$。\n继续这个逻辑，我们推断出每一层上的键：\n- 深度 $d=0$：$\\{22\\}$ ($1$ 个节点)\n- 深度 $d=1$：$\\{9, 33\\}$ ($2$ 个节点)\n- 深度 $d=2$：$\\{5, 15, 28, 40\\}$ ($4$ 个节点)\n- 深度 $d=3$：$\\{2, 7, 12, 20, 25, 31, 36, 44\\}$ ($8$ 个节点)\n\n一个能创建这棵树的插入顺序是最终树结构的先序遍历：$(22, 9, 5, 2, 7, 15, 12, 20, 33, 28, 25, 31, 40, 36, 44)$。当从这个序列中插入一个键时，贪心算法会将其放置在一个空位上。因为我们在插入每个子树的任何子节点之前先插入该子树的根，所以算法找到的空位恰好是该键在完全平衡树中的正确位置。\n\n现在我们计算平均搜索成本 $C_{\\text{bal}}$。成本是 $d+1$。\n- 深度 $d=0$：$1$ 个节点，成本 $0+1=1$。总成本：$1 \\times 1 = 1$。\n- 深度 $d=1$：$2$ 个节点，成本 $1+1=2$。总成本：$2 \\times 2 = 4$。\n- 深度 $d=2$：$4$ 个节点，成本 $2+1=3$。总成本：$4 \\times 3 = 12$。\n- 深度 $d=3$：$8$ 个节点，成本 $3+1=4$。总成本：$8 \\times 4 = 32$。\n所有可能的成功搜索的总成本是这些成本之和：$1 + 4 + 12 + 32 = 49$。\n平均搜索成本是总成本除以键的数量 $N=15$：\n$$C_{\\text{bal}} = \\frac{49}{15}$$\n\n最后，我们计算退化树和平衡树中平均比较次数的差值：\n$$\\text{Difference} = C_{\\text{degen}} - C_{\\text{bal}} = 8 - \\frac{49}{15}$$\n为了进行减法，我们找到一个公分母：\n$$\\text{Difference} = \\frac{8 \\times 15}{15} - \\frac{49}{15} = \\frac{120}{15} - \\frac{49}{15} = \\frac{120 - 49}{15} = \\frac{71}{15}$$\n数字 $71$ 是一个素数，不能被 $15$ 整除，所以这个分数是最简形式。", "answer": "$$\\boxed{\\frac{71}{15}}$$", "id": "3237674"}, {"introduction": "最短超串问题是生物信息学和数据压缩中的一个基本挑战。一个非常诱人的贪心策略是“每次合并重叠最长的字符串对”，因为它似乎能最大程度地缩减总长度。然而，这个看似“最佳”的局部选择是否总能引导我们找到全局最短的超串呢？本练习 [@problem_id:3237659] 提供了一个经典的警示案例，要求你一步步执行这个贪心策略，并将其结果与真正的最优解进行比较，从而揭示贪心选择性质在此失效的根本原因。", "problem": "考虑一个有限字母表上的最短超字符串问题。对于两个字符串 $x$ 和 $y$，定义有向重叠长度 $\\operatorname{ov}(x,y)$ 为满足 $x$ 的长度为 $k$ 的后缀等于 $y$ 的长度为 $k$ 的前缀的最大整数 $k \\geq 0$。贪心策略在当前的字符串多重集中重复选择具有最大 $\\operatorname{ov}(x,y)$ 的字符串对 $(x,y)$，并用它们的合并结果替换它们。合并结果定义为以 $x$ 为前缀、以 $y$ 为后缀的唯一最短字符串（通过重叠匹配的后缀和前缀创建）。贪心选择属性要求在每一步选择局部最优的字符串对，能够导向一个全局最优的最短超字符串。\n\n分析贪心策略在以下四个字符串上的表现：\n- $s_A = \\text{PQRSUVWX}$\n- $s_B = \\text{VWXtuUVW}$\n- $s_C = \\text{UVWXYZ}$\n- $s_D = \\text{XYZK}$\n\n任务：\n1. 计算所有有序对 $(s_i, s_j)$ 的重叠长度 $\\operatorname{ov}(s_i,s_j)$，其中 $s_i,s_j \\in \\{s_A,s_B,s_C,s_D\\}$ 且 $i \\neq j$。\n2. 在 $\\{s_A,s_B,s_C,s_D\\}$ 上逐步执行贪心算法，显示每一步选择的字符串对以及每次合并后得到的字符串的长度。仅当重叠长度相等时，算法可以任意打破平局；在这种情况下，请确保第一个选择的对是唯一具有严格最大重叠的对。\n3. 展示一个能产生最短超字符串的四个字符串的最优排序，并从第一性原理证明其最优性（即，通过将可行的合并序列视为最大化已实现重叠总和的路径进行论证），并计算这个最优最短超字符串的长度。\n4. 令 $L_{\\text{greedy}}$ 为贪心策略得到的最终长度，$L_{\\text{opt}}$ 为最优最短超字符串的长度。以精确比率 $R = \\frac{L_{\\text{greedy}}}{L_{\\text{opt}}}$ 的形式提供最终答案。无需四舍五入。\n\n你的最终答案必须是一个分数形式的单个数字。", "solution": "通过合并一系列字符串形成的超字符串的长度，等于各个字符串的长度之和减去每一步合并所实现的重叠长度之和。为了找到最短的超字符串，我们必须找到一个能最大化总重叠的合并序列。\n\n**任务 1：计算所有有序对的重叠长度**\n给定的字符串是：\n- $s_A = \\text{PQRSUVWX}$ (长度 8)\n- $s_B = \\text{VWXtuUVW}$ (长度 8)\n- $s_C = \\text{UVWXYZ}$ (长度 6)\n- $s_D = \\text{XYZK}$ (长度 4)\n\n我们计算所有 12 个 $i \\neq j$ 的有序对 $(s_i, s_j)$ 的重叠长度 $\\operatorname{ov}(s_i, s_j)$：\n- $\\operatorname{ov}(s_A, s_B)$: $s_A$ 的后缀是 `...VWX`，$s_B$ 的前缀是 `VWX...`。重叠部分是 `VWX`，所以 $\\operatorname{ov}(s_A, s_B) = 3$。\n- $\\operatorname{ov}(s_A, s_C)$: $s_A$ 的后缀是 `...UVWX`，$s_C$ 的前缀是 `UVWX...`。重叠部分是 `UVWX`，所以 $\\operatorname{ov}(s_A, s_C) = 4$。\n- $\\operatorname{ov}(s_A, s_D)$: $s_A$ 的后缀是 `...X`，$s_D$ 的前缀是 `X...`。重叠部分是 `X`，所以 $\\operatorname{ov}(s_A, s_D) = 1$。\n- $\\operatorname{ov}(s_B, s_A)$: 没有公共的非空后缀/前缀。$\\operatorname{ov}(s_B, s_A) = 0$。\n- $\\operatorname{ov}(s_B, s_C)$: $s_B$ 的后缀是 `...UVW`，$s_C$ 的前缀是 `UVW...`。重叠部分是 `UVW`，所以 $\\operatorname{ov}(s_B, s_C) = 3$。\n- $\\operatorname{ov}(s_B, s_D)$: 没有公共的非空后缀/前缀。$\\operatorname{ov}(s_B, s_D) = 0$。\n- $\\operatorname{ov}(s_C, s_A)$: 没有公共的非空后缀/前缀。$\\operatorname{ov}(s_C, s_A) = 0$。\n- $\\operatorname{ov}(s_C, s_B)$: 没有公共的非空后缀/前缀。$\\operatorname{ov}(s_C, s_B) = 0$。\n- $\\operatorname{ov}(s_C, s_D)$: $s_C$ 的后缀是 `...XYZ`，$s_D$ 的前缀是 `XYZ...`。重叠部分是 `XYZ`，所以 $\\operatorname{ov}(s_C, s_D) = 3$。\n- $\\operatorname{ov}(s_D, s_A)$: 没有公共的非空后缀/前缀。$\\operatorname{ov}(s_D, s_A) = 0$。\n- $\\operatorname{ov}(s_D, s_B)$: 没有公共的非空后缀/前缀。$\\operatorname{ov}(s_D, s_B) = 0$。\n- $\\operatorname{ov}(s_D, s_C)$: 没有公共的非空后缀/前缀。$\\operatorname{ov}(s_D, s_C) = 0$。\n\n非零的重叠长度有：$\\operatorname{ov}(s_A, s_C) = 4$，$\\operatorname{ov}(s_A, s_B) = 3$，$\\operatorname{ov}(s_B, s_C) = 3$，$\\operatorname{ov}(s_C, s_D) = 3$，以及 $\\operatorname{ov}(s_A, s_D) = 1$。\n\n**任务 2：执行贪心算法**\n初始字符串集合为 $\\{s_A, s_B, s_C, s_D\\}$。长度总和为 $8+8+6+4=26$。\n\n**第 1 步：** 贪心策略选择具有最大重叠的字符串对。唯一的最大重叠是 $\\operatorname{ov}(s_A, s_C) = 4$。\n我们合并 $s_A$ 和 $s_C$：\n- $s_A = \\text{PQRS} \\underline{\\text{UVWX}}$\n- $s_C = \\underline{\\text{UVWX}} \\text{YZ}$\n合并后的字符串是 $s_{AC} = \\text{PQRSUVWXYZ}$。\n这个新字符串的长度是 $|s_A| + |s_C| - \\operatorname{ov}(s_A, s_C) = 8 + 6 - 4 = 10$。\n当前的字符串集合是 $\\{s_{AC}, s_B, s_D\\}$。\n\n**第 2 步：** 我们为新的集合计算重叠长度：\n- $\\operatorname{ov}(s_{AC}, s_B)$: $s_{AC}$ 的后缀是 `...Z`，$s_B$ 的前缀是 `V...`。重叠为 $0$。\n- $\\operatorname{ov}(s_{AC}, s_D)$: $s_{AC}$ 的后缀是 `...XYZ`，$s_D$ 的前缀是 `XYZ...`。重叠是 `XYZ`，所以 $\\operatorname{ov}(s_{AC}, s_D) = 3$。\n- $\\operatorname{ov}(s_B, s_{AC})$: $s_B$ 的后缀是 `...W`，$s_{AC}$ 的前缀是 `P...`。重叠为 $0$。\n- 原始字符串之间剩余的重叠是 $\\operatorname{ov}(s_B, s_D) = 0$ 和 $\\operatorname{ov}(s_D, s_B) = 0$。\n现在的最大重叠是 $\\operatorname{ov}(s_{AC}, s_D) = 3$。\n我们合并 $s_{AC}$ 和 $s_D$：\n- $s_{AC} = \\text{PQRSUVW} \\underline{\\text{XYZ}}$\n- $s_D = \\underline{\\text{XYZ}} \\text{K}$\n合并后的字符串是 $s_{ACD} = \\text{PQRSUVWXYZK}$。\n长度为 $|s_{AC}| + |s_D| - \\operatorname{ov}(s_{AC}, s_D) = 10 + 4 - 3 = 11$。\n当前的字符串集合是 $\\{s_{ACD}, s_B\\}$。\n\n**第 3 步：** 只剩下一对需要合并，即 $(s_{ACD}, s_B)$ 或 $(s_B, s_{ACD})$。\n- $\\operatorname{ov}(s_{ACD}, s_B)$: 后缀 `...K`，前缀 `V...`。重叠为 $0$。\n- $\\operatorname{ov}(s_B, s_{ACD})$: 后缀 `...W`，前缀 `P...`。重叠为 $0$。\n重叠为 $0$。我们通过拼接来合并它们。我们按第一种顺序来。\n最终的字符串是 $s_{\\text{greedy}} = s_{ACD}s_B = \\text{PQRSUVWXYZKVWXtuUVW}$。\n最终长度是 $|s_{ACD}| + |s_B| - 0 = 11 + 8 = 19$。\n\n贪心算法实现的总重叠是 $4 + 3 + 0 = 7$。\n长度是 $L_{\\text{greedy}} = 26 - 7 = 19$。\n\n**任务 3：展示一个最优解**\n贪心算法不保证得到最优解。选择最大的初始重叠 $\\operatorname{ov}(s_A, s_C) = 4$ 可能会排除掉其他能够产生更大总重叠的合并序列。我们必须寻找一个包含 $n-1 = 3$ 次合并且能最大化总重叠的序列。\n\n让我们考虑一个与路径 $s_A \\to s_B \\to s_C \\to s_D$ 对应的替代合并序列。\n**第 1 步：** 合并 $s_A$ 和 $s_B$，重叠长度为 $\\operatorname{ov}(s_A, s_B) = 3$：\n- $s_A = \\text{PQRSU} \\underline{\\text{VWX}}$\n- $s_B = \\underline{\\text{VWX}} \\text{tuUVW}$\n- 合并后的字符串 $s_{AB} = \\text{PQRSUVWXt uUVW}$。长度为 $|s_A|+|s_B|-3 = 8+8-3=13$。\n\n**第 2 步：** 将 $s_{AB}$ 与 $s_C$ 合并。\n- $s_{AB}$ 的后缀是 `...UVW`。$s_C = \\text{UVWXYZ}$ 的前缀是 `UVW...`。\n- 重叠长度为 $\\operatorname{ov}(s_{AB}, s_C) = 3$。\n- 合并后的字符串 $s_{ABC} = \\text{PQRSUVWXt uUVWXYZ}$。长度为 $|s_{AB}|+|s_C|-3 = 13+6-3=16$。\n\n**第 3 步：** 将 $s_{ABC}$ 与 $s_D$ 合并。\n- $s_{ABC}$ 的后缀是 `...XYZ`。$s_D = \\text{XYZK}$ 的前缀是 `XYZ...`。\n- 重叠长度为 $\\operatorname{ov}(s_{ABC}, s_D) = 3$。\n- 合并后的字符串 $s_{ABCD} = \\text{PQRSUVWXt uUVWXYZK}$。长度为 $|s_{ABC}|+|s_D|-3 = 16+4-3=17$。\n\n这个序列的总重叠是 $3 + 3 + 3 = 9$。\n得到的超字符串长度为 $L_{\\text{opt}} = (8+8+6+4) - 9 = 26 - 9 = 17$。\n\n这个长度 $17$ 比贪心算法得到的结果 $19$ 要短。为了证明其最优性，我们考虑可能的总重叠。可用的重叠值为 $\\{4, 3, 3, 3, 1\\}$。我们需要选择 3 次合并。贪心算法选择的重叠总和为 $4+3+0=7$。我们的替代路径选择的重叠总和为 $3+3+3=9$。没有其他 3 次合并的组合能产生大于 9 的总和，因为使用重叠 4（来自 $s_A \\to s_C$）使得无法同时使用重叠 $s_A \\to s_B$ 和 $s_B \\to s_C$。一个有效的 3 次合并序列能产生的最大重叠总和是 9。因此，长度为 17 的超字符串是最优的。\n\n$L_{\\text{opt}} = 17$。\n\n**任务 4：计算比率**\n我们需要计算比率 $R = \\frac{L_{\\text{greedy}}}{L_{\\text{opt}}}$。\n$L_{\\text{greedy}} = 19$\n$L_{\\text{opt}} = 17$\n比率为 $R = \\frac{19}{17}$。", "answer": "$$\\boxed{\\frac{19}{17}}$$", "id": "3237659"}, {"introduction": "图的顶点着色问题在资源调度、寄存器分配等领域有着广泛应用，而为其设计高效算法是一个著名的难题。一种常见的贪心启发式方法是优先为“约束最强”（即度数最高）的顶点着色，这符合我们优先处理最困难部分的直觉。本练习 [@problem_id:3237691] 将引导你对一个特制的图应用此贪心策略，通过计算其使用的颜色数，你会发现这种直觉性的贪心选择有时会系统性地偏离最优解，这强调了在评判一个贪心算法时进行严格反例分析的重要性。", "problem": "考虑在一个简单无向图中进行顶点着色的任务，其中一个正常的着色为每个顶点分配一个正整数标签（一种颜色），使得相邻的顶点获得不同的颜色。一个图的色数是进行正常着色所需的最少颜色数。一种常见的贪心启发式算法是：将顶点按度数的非递增顺序排序，若度数相同，则按标签的字典序打破平局，然后按此顺序为每个顶点分配一个未被其任何已着色邻居使用的最小正整数颜色。这被称为基于度排序的首次适应贪心着色算法，通常通过一个假定的贪心选择性质（即优先选择度数最高的顶点被认为是局部最优的）来非正式地证明其合理性。\n\n你的任务是分析下面明确给出的图，并确定在指定的排序规则下，上述贪心算法使用了多少种颜色。\n\n设顶点集为\n$$\nV=\\{x,y,a,b,c,v\\}\\cup\\{L_{x,1},L_{x,2},L_{x,3},L_{x,4}\\}\\cup\\{L_{y,1},L_{y,2},L_{y,3}\\}\\cup\\{L_{b,1},L_{b,2}\\}\\cup\\{L_{c,1},L_{c,2}\\}.\n$$\n设边集由以下邻接关系构成：\n- 顶点 $x$ 与 $y$、$a$、$b$ 以及每个 $L_{x,i}$ (其中 $i\\in\\{1,2,3,4\\}$) 相邻。\n- 顶点 $y$ 与 $x$、$a$、$c$ 以及每个 $L_{y,j}$ (其中 $j\\in\\{1,2,3\\}$) 相邻。\n- 顶点 $a$ 与 $x$、$y$ 和 $v$ 相邻。\n- 顶点 $b$ 与 $x$、$v$ 以及 $L_{b,1}$ 和 $L_{b,2}$ 相邻。\n- 顶点 $c$ 与 $y$、$v$ 以及 $L_{c,1}$ 和 $L_{c,2}$ 相邻。\n- 顶点 $v$ 与 $a$、$b$ 和 $c$ 相邻。\n- 每个叶节点 $L_{x,i}$ 仅与 $x$ 相邻；每个叶节点 $L_{y,j}$ 仅与 $y$ 相邻；每个叶节点 $L_{b,k}$ 仅与 $b$ 相邻；每个叶节点 $L_{c,\\ell}$ 仅与 $c$ 相邻。\n\n不存在其他边。\n\n在指定的贪心规则（按度数非递增排序，按顶点标签的字典序打破平局，然后进行首次适应着色）下，将该算法应用于上述图，并计算算法使用的总颜色数。\n\n此外，为了使你的推理基于第一性原理，请仅使用以下内容作为基本依据：度、正常着色、色数的定义，以及贪心算法的过程描述。你应该通过找出一个能用更少颜色着色的明确的不同排序，来解释为什么这个图证明了该启发式算法的贪心选择性质是失败的。然而，对于你最终报告的值，只给出度排序贪心算法在给定图上使用的颜色数。\n\n你的最终答案必须是一个整数。如果你觉得考虑一个备选排序有帮助，可以这样做，但不要报告任何比率或差异；只报告指定的贪心算法在该图上使用的颜色数。", "solution": "任务是确定一个特定的贪心着色算法在给定图上使用的颜色数量。该算法分两个阶段进行：首先，对顶点进行排序；其次，分配颜色。\n\n排序规则是按顶点度数的非递增顺序对顶点进行排序。度数相同时按顶点标签的字典序打破平局。\n着色规则是首次适应：对于排序序列中的每个顶点，分配一个当前未被其任何已着色邻居使用的最小正整数颜色。\n\n首先，我们必须构建图并计算每个顶点的度数。顶点集为 $V=\\{x,y,a,b,c,v\\}\\cup\\{L_{x,1},L_{x,2},L_{x,3},L_{x,4}\\}\\cup\\{L_{y,1},L_{y,2},L_{y,3}\\}\\cup\\{L_{b,1},L_{b,2}\\}\\cup\\{L_{c,1},L_{c,2}\\}$。根据指定的邻接关系，各顶点的度数为：\n- $\\text{deg}(x) = 3 (\\text{连接到 } y,a,b) + 4 (\\text{连接到 } L_{x,i}) = 7$\n- $\\text{deg}(y) = 3 (\\text{连接到 } x,a,c) + 3 (\\text{连接到 } L_{y,j}) = 6$\n- $\\text{deg}(a) = 3 (\\text{连接到 } x,y,v)$\n- $\\text{deg}(b) = 2 (\\text{连接到 } x,v) + 2 (\\text{连接到 } L_{b,k}) = 4$\n- $\\text{deg}(c) = 2 (\\text{连接到 } y,v) + 2 (\\text{连接到 } L_{c,\\ell}) = 4$\n- $\\text{deg}(v) = 3 (\\text{连接到 } a,b,c)$\n- 所有叶节点 $L_{*,*}$ 的度数均为 $1$。\n\n接下来，我们根据指定的规则（度数非递增，字典序打破平局）来确定顶点排序。\n- 度为 7: $x$\n- 度为 6: $y$\n- 度为 4: $b, c$。按字典序，$b$ 在 $c$ 之前。\n- 度为 3: $a, v$。按字典序，$a$ 在 $v$ 之前。\n- 度为 1: 所有 11 个叶节点。按字典序，顺序为 $L_{b,1}, L_{b,2}, L_{c,1}, L_{c,2}, L_{x,1}, L_{x,2}, L_{x,3}, L_{x,4}, L_{y,1}, L_{y,2}, L_{y,3}$。\n\n最终的完整顶点排序是：\n$(x, y, b, c, a, v, L_{b,1}, L_{b,2}, L_{c,1}, L_{c,2}, L_{x,1}, L_{x,2}, L_{x,3}, L_{x,4}, L_{y,1}, L_{y,2}, L_{y,3})$\n\n现在，我们将首次适应着色算法应用于此序列。设 $\\text{color}(u)$ 为分配给顶点 $u$ 的颜色。颜色是正整数 $\\{1, 2, 3, \\dots\\}$。对于每个顶点 $u$，我们分配 $\\text{color}(u) = \\min\\{k \\in \\mathbb{Z}^+ : k \\neq \\text{color}(w) \\text{ for all colored neighbors } w \\text{ of } u\\}$。\n\n1.  顶点 $x$：没有已着色的邻居。$\\text{color}(x) = 1$。\n2.  顶点 $y$：其唯一的已着色邻居是 $x$。其邻居使用的颜色集合为 $\\{\\text{color}(x)\\} = \\{1\\}$。最小可用颜色为 $2$。$\\text{color}(y) = 2$。\n3.  顶点 $b$：其唯一的已着色邻居是 $x$。已用颜色集合为 $\\{\\text{color}(x)\\} = \\{1\\}$。最小可用颜色为 $2$。$\\text{color}(b) = 2$。\n4.  顶点 $c$：其唯一的已着色邻居是 $y$。已用颜色集合为 $\\{\\text{color}(y)\\} = \\{2\\}$。最小可用颜色为 $1$。$\\text{color}(c) = 1$。\n5.  顶点 $a$：其已着色的邻居是 $x$ 和 $y$。已用颜色集合为 $\\{\\text{color}(x), \\text{color}(y)\\} = \\{1, 2\\}$。最小可用颜色为 $3$。$\\text{color}(a) = 3$。\n6.  顶点 $v$：其已着色的邻居是 $a, b, c$。已用颜色集合为 $\\{\\text{color}(a), \\text{color}(b), \\text{color}(c)\\} = \\{3, 2, 1\\}$。最小可用颜色为 $4$。$\\text{color}(v) = 4$。\n7.  剩下的顶点是叶节点。对它们进行着色不会引入任何大于 $4$ 的新颜色。\n    - $L_{b,1}, L_{b,2}$：邻居是 $b$，$\\text{color}(b)=2$。它们都被分配颜色 $1$。\n    - $L_{c,1}, L_{c,2}$：邻居是 $c$，$\\text{color}(c)=1$。它们都被分配颜色 $2$。\n    - $L_{x,1}, \\dots, L_{x,4}$：邻居是 $x$，$\\text{color}(x)=1$。它们都被分配颜色 $2$。\n    - $L_{y,1}, \\dots, L_{y,3}$：邻居是 $y$，$\\text{color}(y)=2$。它们都被分配颜色 $1$。\n\n在此过程中使用的颜色集合是 $\\{1, 2, 3, 4\\}$。因此，贪心算法总共使用了 $4$ 种颜色。\n\n该启发式算法体现了一种贪心选择：选择度数最高的顶点被认为是朝向全局最小着色方案的一个局部最优步骤。这个例子表明情况并非如此。这个图的色数 $\\chi(G)$ 实际上是 $3$。贪心算法选择尽早为 $b$ 和 $c$ 着色（因为它们的度数高），并使用最小的可用颜色，这结果被证明是一个糟糕的全局决策。这种为 $c$ 和 $b$ 使用颜色 $1$ 和 $2$ 的“局部最优”选择，迫使它们的共同邻居 $v$（在之后被着色）需要一种新的、第四种颜色。一个更具全局意识的策略本可以对 $b$ 和 $c$ 进行不同的着色以避免在 $v$ 处的这种冲突，从而实现最优的 3-着色。因此，贪心选择启发式算法（度数最高优先）并不能保证为顶点着色问题产生最优解。\n\n然而，最终答案是指定算法所使用的颜色数。", "answer": "$$\\boxed{4}$$", "id": "3237691"}]}